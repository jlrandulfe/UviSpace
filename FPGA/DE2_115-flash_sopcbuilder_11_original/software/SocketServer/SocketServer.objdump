
SocketServer.elf:     file format elf32-littlenios2
SocketServer.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x032001c0

Program Header:
    LOAD off    0x00001000 vaddr 0x02800000 paddr 0x02800000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x03200020 paddr 0x03200020 align 2**12
         filesz 0x00050608 memsz 0x00050608 flags r-x
    LOAD off    0x00051628 vaddr 0x03250628 paddr 0x03252724 align 2**12
         filesz 0x000020fc memsz 0x000020fc flags rw-
    LOAD off    0x00053820 vaddr 0x03254820 paddr 0x03254820 align 2**12
         filesz 0x00000000 memsz 0x00008cd0 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  02800000  02800000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   000001a0  03200020  03200020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004beb4  032001c0  032001c0  000011c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000045b4  0324c074  0324c074  0004d074  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000020fc  03250628  03252724  00051628  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00008cd0  03254820  03254820  00053820  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000023  00000000  00000000  00053724  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00001e98  00000000  00000000  00053748  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 0000588c  00000000  00000000  000555e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0008d609  00000000  00000000  0005ae6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0001485f  00000000  00000000  000e8475  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00049c32  00000000  00000000  000fccd4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00006c74  00000000  00000000  00146908  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00003cec  00000000  00000000  0014d57c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00019c10  00000000  00000000  00151268  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000060  00000000  00000000  0016ae78  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000b48  00000000  00000000  0016aed8  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000006  00000000  00000000  00176747  2**0
                  CONTENTS, READONLY
 18 .cpu          00000003  00000000  00000000  0017674d  2**0
                  CONTENTS, READONLY
 19 .simulation_enabled 00000001  00000000  00000000  00176750  2**0
                  CONTENTS, READONLY
 20 .sysid_hash   00000004  00000000  00000000  00176751  2**0
                  CONTENTS, READONLY
 21 .sysid_base   00000004  00000000  00000000  00176755  2**0
                  CONTENTS, READONLY
 22 .sysid_time   00000004  00000000  00000000  00176759  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000009  00000000  00000000  0017675d  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000009  00000000  00000000  00176766  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000009  00000000  00000000  0017676f  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 0000000c  00000000  00000000  00176778  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 00000032  00000000  00000000  00176784  2**0
                  CONTENTS, READONLY
 28 .jdi          00004353  00000000  00000000  001767b6  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
02800000 l    d  .entry	00000000 .entry
03200020 l    d  .exceptions	00000000 .exceptions
032001c0 l    d  .text	00000000 .text
0324c074 l    d  .rodata	00000000 .rodata
03250628 l    d  .rwdata	00000000 .rwdata
03254820 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
03200208 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_error_handler.c
00000000 l    df *ABS*	00000000 camera.c
03254820 l     O .bss	00000004 vga.1628
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 network_utilities.c
00000000 l    df *ABS*	00000000 simple_socket_server.c
03254830 l     O .bss	00000004 SSSCommand.4717
03254a2c l     O .bss	00000814 conn.5299
00000000 l    df *ABS*	00000000 trackers.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
03204380 l     F .text	0000007c udivmodsi4
00000000 l    df *ABS*	00000000 ctype_.c
0324d575 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
03204820 l     F .text	00000058 std
0320492c l     F .text	00000008 __fp_lock
03204934 l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 getc.c
00000000 l    df *ABS*	00000000 impure.c
03250668 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 perror.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 refill.c
032075d0 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 rget.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 sscanf.c
03207790 l     F .text	00000008 eofread
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strerror.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 u_strerr.c
00000000 l    df *ABS*	00000000 vfprintf.c
032081c0 l     F .text	00000058 __sprint_r
0324df16 l     O .rodata	00000010 blanks.3452
0324df06 l     O .rodata	00000010 zeroes.3453
00000000 l    df *ABS*	00000000 vfscanf.c
0324df2e l     O .rodata	00000022 basefix.3357
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
0320bbd8 l     F .text	00000218 quorem
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
032525f4 l     O .rwdata	00000004 charset
0324df70 l     O .rodata	00000030 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 mprec.c
0324e0b8 l     O .rodata	0000000c p05.2458
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 s_isinfd.c
00000000 l    df *ABS*	00000000 s_isnand.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
0320ec74 l     F .text	00000048 match
03250e90 l     O .rwdata	00000014 fpi.1950
0324e0d4 l     O .rodata	00000028 tinytens
03250e7c l     O .rwdata	00000014 fpinan.1986
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
032110ec l     F .text	00000024 htinit
03211178 l     F .text	000000b0 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
032119e0 l     F .text	0000004c L_shift
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
03212aa4 l     F .text	00000410 _fpadd_parts
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_fstat.c
03214700 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
03214820 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
03214900 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
03214a5c l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
03214b84 l     F .text	000000dc alt_file_locked
03214de8 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
03252600 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_env_lock.c
03252604 l     O .rwdata	00000004 lockid
0325485c l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
03252608 l     O .rwdata	00000004 lockid
03254864 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
0321693c l     F .text	00000044 OS_InitMisc
03216980 l     F .text	0000006c OS_InitRdyList
03216ae4 l     F .text	000000e0 OS_InitTCBList
03216860 l     F .text	000000dc OS_InitEventList
032169ec l     F .text	0000007c OS_InitTaskIdle
03216a68 l     F .text	0000007c OS_InitTaskStat
03216d58 l     F .text	00000070 OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
03218c78 l     F .text	00000110 OS_FlagTaskRdy
032189d0 l     F .text	000001c4 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
03250ea4 l     O .rwdata	000000d8 ext_flash
03250f7c l     O .rwdata	0000106c jtag_uart
03251fe8 l     O .rwdata	00000124 lcd
0321d614 l     F .text	00000038 alt_dev_reg
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash.c
0321d6e8 l     F .text	00000038 alt_flash_device_register
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_table.c
0321e4d8 l     F .text	0000007c alt_read_16bit_query_entry
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0321f5d4 l     F .text	000002c8 altera_avalon_jtag_uart_irq
0321f89c l     F .text	00000114 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207.c
03252680 l     O .rwdata	00000004 colstart
032200b4 l     F .text	000000b8 lcd_write_command
0322016c l     F .text	000000d4 lcd_write_data
03220240 l     F .text	000000c4 lcd_clear_screen
03220304 l     F .text	000001ec lcd_repaint_screen
032204f0 l     F .text	000000c8 lcd_scroll_up
032205b8 l     F .text	000002d0 lcd_handle_escape
03220dc0 l     F .text	000000cc alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
03221048 l     F .text	00000074 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 avalon_locator.c
00000000 l    df *ABS*	00000000 ins_eth_ocm.c
03221a4c l     F .text	000000a0 eth_ocm_pkt_send
03221f5c l     F .text	000000f4 eth_ocm_isr
03222050 l     F .text	000001dc eth_ocm_read_init
03221ca0 l     F .text	000002bc eth_ocm_tx_isr
03221aec l     F .text	000001b4 eth_ocm_low_send
0322222c l     F .text	0000035c eth_ocm_rx_isr
00000000 l    df *ABS*	00000000 alt_iniche_close.c
00000000 l    df *ABS*	00000000 alt_iniche_dev.c
00000000 l    df *ABS*	00000000 alt_iniche_read.c
00000000 l    df *ABS*	00000000 alt_iniche_write.c
00000000 l    df *ABS*	00000000 ipnet.c
00000000 l    df *ABS*	00000000 ipstart.c
032548cc l     O .bss	00000004 nclosers
03255268 l     O .bss	0000003c closers
00000000 l    df *ABS*	00000000 igmp_cmn.c
00000000 l    df *ABS*	00000000 bsdsock.c
00000000 l    df *ABS*	00000000 cksum.c
03252690 l     O .rwdata	00000004 cksum_select
00000000 l    df *ABS*	00000000 in_utils.c
032552a4 l     O .bss	00000018 tistring
00000000 l    df *ABS*	00000000 netmain.c
00000000 l    df *ABS*	00000000 tk_crnos.c
00000000 l    df *ABS*	00000000 dhcpclnt.c
03228e5c l     F .text	000000cc dh_getlong
00000000 l    df *ABS*	00000000 dhcputil.c
00000000 l    df *ABS*	00000000 pktalloc.c
00000000 l    df *ABS*	00000000 q.c
00000000 l    df *ABS*	00000000 udp_open.c
0322ab88 l       .text	00000000 done
0322aa18 l       .text	00000000 asm1
0322ab44 l       .text	00000000 loop0
0322aa40 l       .text	00000000 loop
0322ab60 l       .text	00000000 fold
00000000 l    df *ABS*	00000000 brdutils.c
0325492c l     O .bss	00000004 kbd_init.3791
03254938 l     O .bss	00000004 cpu_statusreg
00000000 l    df *ABS*	00000000 osportco.c
00000000 l    df *ABS*	00000000 targnios.c
00000000 l    df *ABS*	00000000 nptcp.c
0325496c l     O .bss	00000004 in_tcptick
00000000 l    df *ABS*	00000000 rawsock.c
00000000 l    df *ABS*	00000000 sockcall.c
0322f28c l     F .text	00000098 sockargs
0322e4c8 l     F .text	000001fc t_getname
00000000 l    df *ABS*	00000000 socket.c
00000000 l    df *ABS*	00000000 socket2.c
00000000 l    df *ABS*	00000000 soselect.c
00000000 l    df *ABS*	00000000 tcp_in.c
00000000 l    df *ABS*	00000000 tcp_out.c
032375c0 l     F .text	000000e8 bld_options
00000000 l    df *ABS*	00000000 tcp_subr.c
00000000 l    df *ABS*	00000000 tcp_timr.c
00000000 l    df *ABS*	00000000 tcp_usr.c
00000000 l    df *ABS*	00000000 tcpport.c
00000000 l    df *ABS*	00000000 udpsock.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
0323a1d0 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
0323a2ec l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0323a3cc l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0323a7cc l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_read.c
0323abe8 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_remap_cached.c
00000000 l    df *ABS*	00000000 alt_remap_uncached.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
0323b0a0 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 altera_nios2_irq.c
00000040 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_amd.c
0323b9b8 l     F .text	000000bc alt_write_word_amd
0323b894 l     F .text	00000124 alt_wait_for_command_to_complete_amd
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_intel.c
0323bc6c l     F .text	0000018c alt_unlock_block_intel
0323bdf8 l     F .text	000000dc alt_write_word_intel
00000000 l    df *ABS*	00000000 eth_ocm_phy.c
032552bc l     O .bss	0000000c eth_ocm_phy_profile_array
0323c0cc l     F .text	00000074 eth_ocm_wait
00000000 l    df *ABS*	00000000 eth_ocm_phy_profiles.c
0323c418 l     F .text	000000bc phy_cfg_MVL88E1111
0325238c l     O .rwdata	00000060 profile_MVL88E1111
032523ec l     O .rwdata	00000060 profile_DP83848C
00000000 l    df *ABS*	00000000 allports.c
032549a4 l     O .bss	00000004 inside_pktdemux
00000000 l    df *ABS*	00000000 timeouts.c
0323c9a8 l     F .text	00000198 check_interval_timers
032549b0 l     O .bss	00000004 numtimers
00000000 l    df *ABS*	00000000 tk_misc.c
00000000 l    df *ABS*	00000000 alt_iniche_fcntl.c
00000000 l    df *ABS*	00000000 et_arp.c
032549b4 l     O .bss	00000004 arp_timer
032549cc l     O .bss	00000004 cachetime
00000000 l    df *ABS*	00000000 iface.c
00000000 l    df *ABS*	00000000 ip.c
0325270c l     O .rwdata	00000004 uid
00000000 l    df *ABS*	00000000 ip_reasm.c
00000000 l    df *ABS*	00000000 ipdemux.c
00000000 l    df *ABS*	00000000 ipmc.c
00000000 l    df *ABS*	00000000 ipport.c
00000000 l    df *ABS*	00000000 ipraw.c
00000000 l    df *ABS*	00000000 iproute.c
00000000 l    df *ABS*	00000000 udp.c
032549fc l     O .bss	00000002 usocket
00000000 l    df *ABS*	00000000 igmp.c
00000000 l    df *ABS*	00000000 igmp2.c
00000000 l    df *ABS*	00000000 ipopt.c
00000000 l    df *ABS*	00000000 u_mctest.c
03252714 l     O .rwdata	00000004 iCounter.4549
00000000 l    df *ABS*	00000000 dhcsetup.c
00000000 l    df *ABS*	00000000 memdev.c
00000000 l    df *ABS*	00000000 parseip.c
032552c8 l     O .bss	0000001e nearBuf.4227
00000000 l    df *ABS*	00000000 tcpcksum.c
00000000 l    df *ABS*	00000000 in_pcb.c
00000000 l    df *ABS*	00000000 vfsfiles.c
00000000 l    df *ABS*	00000000 vfsport.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_fcntl.c
0324a4b8 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 icmp.c
032525c4 l     O .rwdata	00000018 dsts
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 calloc.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 vprintf.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0324bde4 l     F .text	00000004 register_fini
00000000 l    df *ABS*	00000000 alt_exit.c
0324bf98 l     F .text	00000040 alt_sim_halt
03206d40 g     F .text	0000001c putchar
0325ce5c g     O .bss	00000014 soq
0320de20 g     F .text	00000094 _mprec_log10
03252656 g     O .rwdata	00000002 OSTaskNameSize
0320df0c g     F .text	00000088 __any_on
0320d73c g     F .text	00000070 _isatty_r
0324e090 g     O .rodata	00000028 __mprec_tinytens
0323e890 g     F .text	00000780 ip_write_internal
03214abc g     F .text	000000c8 alt_main
0324b9d0 g     F .text	0000008c strcpy
0322a2dc g     F .text	000000ac pk_free
03206d64 g     F .text	000000a0 _puts_r
0321df98 g     F .text	00000048 alt_read_query_entry_32bit
0325d1f8 g     O .bss	00000100 alt_irq
0323c140 g     F .text	000002d8 eth_ocm_phy_init
03252464 g     O .rwdata	00000009 rtp_priority
0320d89c g     F .text	00000078 _lseek_r
0324b52c g     F .text	00000334 icmp_timex
0322bc68 g     F .text	00000044 m_freem
03249cd0 g     F .text	00000048 vgetc
0322ad04 g     F .text	0000001c clock_c
03254984 g     O .bss	00000004 tcp_optionbuf
0323e358 g     F .text	00000084 if_getbynum
0321956c g     F .text	000000d0 OS_MemInit
03254924 g     O .bss	00000004 dsc_rlyerrs
03254914 g     O .bss	00000004 dsc_releases
0321d720 g     F .text	000002c0 alt_flash_cfi_write
03226a04 g     F .text	00000074 TK_OSTaskQuery
0322a9f8 g       .text	00000000 asm_cksum
03252724 g       *ABS*	00000000 __flash_rwdata_start
0321d4ac g     F .text	00000064 OSTimeSet
03249bb0 g     F .text	00000120 vgetc_locked
0322b544 g     F .text	00000020 post_task_setup
03242288 g     F .text	00000354 ipr_stats
03238f2c g     F .text	00000134 tcp_attach
032526a0 g     O .rwdata	00000004 reqlist_len
0322d114 g     F .text	00000084 tcp_tick
03225c50 g     F .text	00000074 print_ipad
03226900 g     F .text	00000104 tcp_wakeup
0320d3a4 g     F .text	000000a0 __sflags
032135c4 g     F .text	00000088 __eqdf2
03254828 g     O .bss	00000004 last_flash_sector_offset
032548d0 g     O .bss	00000004 igmp_timers_are_running
03235e4c g     F .text	0000012c tcp_pulloutofband
032154b8 g     F .text	000006b4 OSEventPendMulti
0325d4f0 g       *ABS*	00000000 __alt_heap_start
0323b500 g     F .text	00000020 OSTaskCreateHook
03229ac8 g     F .text	00000074 dhc_ifacedone
03242630 g     F .text	00000400 ip_rcv
03249900 g     F .text	0000017c vfseek
03231cac g     F .text	00000120 soqremque
032552e8 g     O .bss	00002000 task1_stk
03244480 g     F .text	00000858 udpdemux
03206adc g     F .text	00000044 printf
032549d0 g     O .bss	00000004 rt_mib
0325262e g     O .rwdata	00000002 OSMboxEn
032299d8 g     F .text	00000060 dhc_state_init
0324bc8c g     F .text	00000024 vsprintf
03215bc0 g     F .text	0000007c OSIntEnter
03200000 g       *ABS*	00000000 __alt_mem_sram
032078ac g     F .text	00000068 __sseek
03204888 g     F .text	000000a4 __sinit
032435d4 g     F .text	00000118 in_delmulti
0320b868 g     F .text	00000130 __swbuf_r
032549e8 g     O .bss	00000004 so_evtmap_create
0325263e g     O .rwdata	00000002 OSQEn
03247e80 g     F .text	00000094 in_pcballoc
032526bc g     O .rwdata	00000002 socket_defaults
0320d7fc g     F .text	00000084 _setlocale_r
0323d184 g     F .text	00000498 send_arp
03204988 g     F .text	00000068 __sfmoreglue
0324896c g     F .text	00000368 vfopen_locked
0321101c g     F .text	0000001c ungetc
03215174 g     F .text	000000d0 __malloc_unlock
0323b55c g     F .text	0000001c OSTaskStatHook
0323c88c g     F .text	00000058 prep_modules
03225188 g     F .text	000001b8 bsd_i_sockoptlen
0325486c g     O .bss	00000001 OSLockNesting
03252698 g     O .rwdata	00000004 xids
0320ecbc g     F .text	000014e4 _strtod_r
03207ad0 g     F .text	00000674 strerror
03248ecc g     F .text	00000040 vfclose
0325cefc g     O .bss	0000002c tcb
0325267c g     O .rwdata	00000002 OSDataSize
0323ac48 g     F .text	00000038 alt_remap_cached
0325486d g     O .bss	00000001 OSRunning
0323e08c g     F .text	000002cc grat_arp
03201854 g     F .text	0000006c get_ip_addr
03247898 g     F .text	000000ac inet_pton
0323e4bc g     F .text	0000009c reg_type
0325ca00 g     O .bss	000000f0 dhc_states
03223f90 g     F .text	0000019c igmp_fasttimo
03249090 g     F .text	0000005c vunlink_flag_open_files
03229780 g     F .text	00000088 dhc_halt
03254908 g     O .bss	00000004 dsc_acks
0325cf28 g     O .bss	000000e0 tcpstat
03241b38 g     F .text	0000035c ip_reasm_copy_queued_fragments_into_reassy_buffer
0322c1f8 g     F .text	000000a8 dtom
032374c4 g     F .text	000000fc tcp_setpersist
0322e8a0 g     F .text	000001a4 t_getsockopt
0320686c g     F .text	000000e0 memmove
03254918 g     O .bss	00000004 dsc_naks
0322c69c g     F .text	000005f8 ip_output
0323b5a0 g     F .text	0000001c OSInitHookBegin
0324b860 g     F .text	00000054 icmp_du
03252694 g     O .rwdata	00000004 num_net_tasks
03254a0c g     O .bss	00000004 vfiles
03252674 g     O .rwdata	00000002 OSTmrSize
03246f94 g     F .text	00000104 dhc_main_ipset
03204978 g     F .text	00000010 _cleanup
03240c30 g     F .text	000002e0 ip_reasm_process_first_fragment
0320df94 g     F .text	000000bc _Balloc
03201da4 g     F .text	00000194 get_board_mac_addr
03254870 g     O .bss	00000004 OSIdleCtr
03245eac g     F .text	000005f0 ip_setmoptions
032136d4 g     F .text	00000088 __gtdf2
03247358 g     F .text	0000002c md_fseek
0323b1cc g       .text	00000000 OSStartTsk
00000000  w      *UND*	00000000 __errno
0321708c g     F .text	000002e0 OS_TCBInit
03240f10 g     F .text	000000a0 ip_reassm
03229808 g     F .text	000001d0 dhc_reclaim
0321e124 g     F .text	00000048 alt_write_flash_command_32bit_device_16bit_mode
0325d1e8 g     O .bss	00000010 udp_mib
02800000 g     F .entry	0000001c __reset
0322f0d8 g     F .text	000000e4 t_shutdown
0320356c g     F .text	000001ec sss_handle_receive
0322eb34 g     F .text	00000150 t_recvfrom
0325267a g     O .rwdata	00000002 OSTmrWheelTblSize
03246690 g     F .text	0000067c u_mctest_run
0324375c g     F .text	00000094 prep_ifaces
03200020 g       *ABS*	00000000 __flash_exceptions_start
032548ec g     O .bss	00000001 to_netmain
03229f48 g     F .text	000000dc pk_alloc
0325261a g     O .rwdata	00000002 OSEventSize
03200ac8 g     F .text	000002ec alt_SSSErrorHandler
03254874 g     O .bss	00000001 OSPrioHighRdy
03205580 g     F .text	00000074 _fstat_r
03226678 g     F .text	0000004c tk_nettick
0323b520 g     F .text	00000020 OSTaskDelHook
0321dc3c g     F .text	000002d8 alt_flash_program_block
03254834 g     O .bss	00000004 errno
03207638 g     F .text	00000014 __srget
032226f4 g     F .text	000000e8 eth_ocm_close
03232fd8 g     F .text	000000cc in_pcbnotify
0320b768 g     F .text	00000024 __svfscanf
0323b1ac g       .text	00000000 OSStartHighRdy
0325caf0 g     O .bss	00000014 lilfreeq
0320020c g     F .text	00000624 alt_uCOSIIErrorHandler
03243818 g     F .text	00000028 evtmap_setup
0321bc80 g     F .text	00000200 OSTaskCreateExt
032548f0 g     O .bss	00000004 tcp_sleep_timeout
032326d8 g     F .text	000001d0 sbdrop
032549e4 g     O .bss	00000004 net_system_exit
0325d2f8 g     O .bss	00000068 icmp_mib
03238018 g     F .text	00000078 tcp_getseq
03243c28 g     F .text	000000cc ip_raw_alloc
032184ec g     F .text	00000068 OSFlagPendGetFlagsRdy
0325265a g     O .rwdata	00000002 OSTaskStatStkSize
03227ea4 g     F .text	00000b3c dhc_request
03230364 g     F .text	000007e4 soreceive
03213ebc g     F .text	0000002c __make_fp
032174f8 g     F .text	00000334 OSFlagAccept
03219ca4 g     F .text	000000c8 OSQFlush
0321963c g     F .text	00000154 OSQAccept
03254854 g     O .bss	00000004 alt_argv
0325a5dc g       *ABS*	00000000 _gp
032425dc g     F .text	00000054 ip_reasm_send_icmp_timex
0323ae68 g     F .text	00000118 usleep
03248f0c g     F .text	00000048 vfflush
0325ce04 g     O .bss	00000040 resid_semaphore
03225b08 g     F .text	00000148 hexdump
03240ae8 g     F .text	000000a8 ip_reasm_incr_mem_useage
0322b59c g     F .text	00000034 calloc2
03224640 g     F .text	0000007c igmp_leavegroup
0321baac g     F .text	000001d4 OSTaskCreate
03201088 g     F .text	00000058 set_image_size
0321b538 g     F .text	00000574 OSTaskChangePrio
03254868 g     O .bss	00000004 alt_heapsem
03237e64 g     F .text	000000e8 tcp_close
0321736c g     F .text	0000018c OSDebugInit
0321be80 g     F .text	0000040c OSTaskDel
0324a12c g     F .text	0000006c vferror
03245190 g     F .text	000000c0 udp_alloc
0325220c g     O .rwdata	00000180 alt_fd_list
03259430 g     O .bss	00000370 OSFlagTbl
03254970 g     O .bss	00000008 mbstat
03205d84 g     F .text	00000090 _getc_r
03205cec g     F .text	00000098 getc
03206d5c g     F .text	00000008 _putchar_r
0321663c g     F .text	000000b8 OS_EventTaskRemove
03245a9c g     F .text	00000158 igmpv2_chk_set_timer
032266c4 g     F .text	0000002c TK_OSTimeDly
032592e8 g     O .bss	00000048 trackers
0323a4f4 g     F .text	00000094 alt_find_dev
032067cc g     F .text	000000a0 memcpy
03254920 g     O .bss	00000004 dsc_rebind
03211a2c g     F .text	00000248 __hexnan
0323cd88 g     F .text	00000080 task_stats
0322dbc4 g     F .text	0000004c DOMAIN_CHECK
0322cc94 g     F .text	00000040 in_broadcast
03252644 g     O .rwdata	00000002 OSRdyTblSize
032010e0 g     F .text	00000050 get_image_exposure
03254a08 g     O .bss	00000004 vfsystems
032450c0 g     F .text	000000d0 udp_socket
032548c0 g     O .bss	00000004 MaxMtu
03232c6c g     F .text	00000158 sock_selscan
0320496c g     F .text	0000000c _cleanup_r
032138f4 g     F .text	000000f8 __floatsidf
03240894 g     F .text	000000d0 ip_reasm_match_frag_with_ire
03231e1c g     F .text	00000050 socantrcvmore
032023bc g     F .text	000010f0 sss_exec_command
03206ac8 g     F .text	00000014 perror
0323a890 g     F .text	00000078 alt_io_redirect
032137e4 g     F .text	00000088 __ltdf2
0325494c g     O .bss	00000004 netq_intmask
03247828 g     F .text	00000070 hextoa
0324c074 g       *ABS*	00000000 __DTOR_END__
0322eeb0 g     F .text	00000228 t_send
0323a0d4 g     F .text	000000fc alt_close
03254978 g     O .bss	00000002 select_wait
03206e04 g     F .text	00000014 puts
0322619c g     F .text	00000044 std_out
03249d18 g     F .text	00000138 vfslookup_locked
0322fb4c g     F .text	0000009c soaccept
03215244 g     F .text	00000130 OSEventNameGet
03252628 g     O .rwdata	00000002 OSFlagMax
0320d994 g     F .text	00000040 mbrtowc
0323b100 g     F .text	00000020 altera_nios2_irq_init
0325ce70 g     O .bss	0000003c tcpmib
0322f324 g     F .text	0000009c t_errno
03243840 g     F .text	000000f0 ip_raw_open
0320b78c g     F .text	00000068 _vfscanf_r
03228d44 g     F .text	00000118 dhc_decline
0320dd70 g     F .text	000000b0 __ratio
03215c3c g     F .text	00000100 OSIntExit
03252710 g     O .rwdata	00000004 ipRoutes
03249038 g     F .text	00000058 vfeof
03238330 g     F .text	0000005c tcp_canceltimers
0322766c g     F .text	0000021c dhc_buildheader
03252662 g     O .rwdata	00000002 OSTCBSize
03254875 g     O .bss	00000001 OSPrioCur
0321fb18 g     F .text	000002c0 altera_avalon_jtag_uart_read
0324b948 g     F .text	00000014 malloc
03254a04 g     O .bss	00000004 inpcb_cachemiss
03206b20 g     F .text	00000034 _printf_r
03247a30 g     F .text	000000c4 inet46_addr
03254a00 g     O .bss	00000004 inpcb_cachehits
032044bc g     F .text	00000008 __udivsi3
032521cc g     O .rwdata	0000000b tcp_outflags
03214760 g     F .text	000000c0 isatty
03252648 g     O .rwdata	00000002 OSStkWidth
0320d7ac g     F .text	0000002c iswspace
0324dfa0 g     O .rodata	000000c8 __mprec_tens
032487c8 g     F .text	0000007c vf_alloc_and_link_vop
0325263c g     O .rwdata	00000002 OSPtrSize
032549d4 g     O .bss	00000004 ipr_curr_mem
03223c1c g     F .text	0000006c exit_hook
0322144c g     F .text	000000b0 get_search_window
032548d4 g     O .bss	00000004 igmp_cticks
03254960 g     O .bss	00000004 mheap_sem_ptr
032361e4 g     F .text	00000048 ip4_tcpmss
0320d7d8 g     F .text	00000008 __locale_charset
0325261c g     O .rwdata	00000002 OSEventTblSize
0325d16c g     O .bss	00000014 netlist
03230b48 g     F .text	000000a8 soshutdown
03211d0c g     F .text	000000a4 __fixunsdfsi
032014e8 g     F .text	00000100 select_vga_output
0323b120 g       .text	00000000 OSCtxSw
0323c81c g     F .text	0000004c packet_check
032289e0 g     F .text	00000280 dhc_setip
0324a518 g     F .text	00000090 alt_icache_flush
0325ceac g     O .bss	00000014 mbufq
0322fafc g     F .text	00000050 soabort
03254838 g     O .bss	00000004 __malloc_top_pad
03254878 g     O .bss	00000004 OSTCBList
0322a5cc g     F .text	00000110 qdel
03221184 g     F .text	000001c4 get_current_corners
0323c694 g     F .text	0000014c station_state
03243d90 g     F .text	00000184 rt_lookup
03254990 g     O .bss	00000004 alt_fd_list_lock
03210a90 g     F .text	00000024 strtoul
032525f0 g     O .rwdata	00000004 __mb_cur_max
032246bc g     F .text	0000035c igmp_validate
0320d7e0 g     F .text	0000000c _localeconv_r
03223938 g     F .text	000002e4 ip_startup
03210ab4 g     F .text	000002f0 _strtoull_r
0322df00 g     F .text	00000298 t_accept
0323189c g     F .text	0000008c soisdisconnecting
0320e68c g     F .text	0000003c __i2b
032055f4 g     F .text	0000049c __sfvwrite_r
032232f0 g     F .text	000003d4 pktdemux
032597a0 g     O .bss	00000c30 OSMemTbl
0325487c g     O .bss	00000001 OSTickStepState
0322abbc g     F .text	000000ac kbhit
0322e6c4 g     F .text	000001dc t_setsockopt
0320764c g     F .text	00000070 _sbrk_r
0323ba74 g     F .text	00000084 alt_program_intel
0325244c g     O .rwdata	00000018 icmpdu_types
032490ec g     F .text	00000220 vunlink
03252640 g     O .rwdata	00000002 OSQMax
03225948 g     F .text	000000b0 ccksum
03248844 g     F .text	000000d8 vf_alloc_buffer
032549f8 g     O .bss	00000004 cachedRoute
032526a4 g     O .rwdata	00000004 lilbufs
0325a3d0 g     O .bss	00000800 OSTaskStatStk
03247384 g     F .text	00000024 md_ftell
032259f8 g     F .text	00000068 cksum
03219154 g     F .text	0000010c OSMemNameGet
0322f6d8 g     F .text	00000130 sofree
032548c8 g     O .bss	00000004 ifNumber
03252620 g     O .rwdata	00000002 OSFlagEn
0320ea08 g     F .text	00000078 _read_r
03221144 g     F .text	00000040 locator_init
03252666 g     O .rwdata	00000002 OSTimeTickHookEn
0323a230 g     F .text	00000078 alt_dcache_flush
0321a208 g     F .text	00000180 OSQPost
03218d88 g     F .text	000000ac OS_FlagUnlink
03250e70 g     O .rwdata	0000000c __lc_ctype
032526e4 g     O .rwdata	00000004 alt_max_fd
0321df14 g     F .text	00000040 alt_read_query_entry_8bit
03216c18 g     F .text	0000006c OS_MemCopy
032526ac g     O .rwdata	00000004 bigbufs
03239060 g     F .text	000000d4 tcp_disconnect
03216c84 g     F .text	000000d4 OS_Sched
032141fc g     F .text	00000138 __unpack_d
032044cc g     F .text	00000110 _fclose_r
03219050 g     F .text	00000104 OSMemGet
03203f20 g     F .text	000000b4 get_search_window_of_tracker
0321c5b4 g     F .text	000001c4 OSTaskNameSet
0323baf8 g     F .text	00000174 alt_erase_block_intel
032047ec g     F .text	00000034 fflush
0325483c g     O .bss	00000004 __malloc_max_sbrked_mem
03254880 g     O .bss	00000004 OSCtxSwCtr
0325c978 g     O .bss	00000064 igmpstats
032015e8 g     F .text	00000060 write_in_lcd
0323b578 g     F .text	00000028 OSTimeTickHook
03227da0 g     F .text	00000104 dhc_rx_offer
03225340 g     F .text	00000120 bsd_getsockopt
0323a908 g     F .text	000001c0 alt_irq_register
0325262a g     O .rwdata	00000002 OSFlagNameSize
0325d1d0 g     O .bss	00000018 ire_stats
032392d0 g     F .text	000001b8 udp_soinput
0322a51c g     F .text	000000b0 putq
032166f4 g     F .text	00000104 OS_EventTaskRemoveMulti
032548e8 g     O .bss	00000004 iniche_net_ready
03212f34 g     F .text	00000074 __adddf3
0321293c g     F .text	00000078 __nesf2
032164e8 g     F .text	00000154 OS_EventTaskWaitMulti
0324a0e4 g     F .text	00000048 isvfile
03230cf0 g     F .text	000004c0 sosetopt
032264fc g     F .text	000000f4 netmain
0323622c g     F .text	0000011c tcp_mss
0320dc50 g     F .text	00000120 __b2d
032474a4 g     F .text	0000031c parse_ipad
032487a8 g     F .text	00000020 get_vfopen_error
03252642 g     O .rwdata	00000002 OSQSize
0321238c g     F .text	000005b0 __umoddi3
0321496c g     F .text	000000f0 lseek
0323c8e4 g     F .text	000000c4 inet_timer
0321ade4 g     F .text	0000027c OSSemPend
032020ec g     F .text	000002d0 sss_send_menu
032525e4 g     O .rwdata	00000004 _global_impure_ptr
03225e34 g     F .text	00000164 print_eth
03248cd4 g     F .text	00000050 vfopen
0323aac8 g     F .text	00000120 alt_read
03206e18 g     F .text	000005f4 _realloc_r
03200830 g     F .text	00000298 alt_NetworkErrorHandler
0325262c g     O .rwdata	00000002 OSLowestPrio
0325d4f0 g       *ABS*	00000000 __bss_end
0322bb34 g     F .text	00000134 m_free
0323b5f4 g     F .text	00000020 OSTCBInitHook
0322a024 g     F .text	000002b8 pk_validate
03252672 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
0323ad58 g     F .text	00000110 alt_tick
03248524 g     F .text	0000025c in_pcblookup
03229bec g     F .text	000000cc find_opt
03259330 g     O .bss	00000100 __hexdig
03211db0 g     F .text	000005dc __udivdi3
0322b98c g     F .text	000001a8 m_getnbuf
0322a3a8 g     F .text	000000ac dump_buf_estats
032549c8 g     O .bss	00000004 arpRepsOut
03252614 g     O .rwdata	00000002 OSEventEn
0324e068 g     O .rodata	00000028 __mprec_bigtens
0320e8e8 g     F .text	00000120 __s2b
0325266e g     O .rwdata	00000002 OSTmrCfgNameSize
03213b38 g     F .text	00000194 __floatunsidf
0323c510 g     F .text	000000fc netmain_init
0320db70 g     F .text	00000060 __mcmp
03254904 g     O .bss	00000004 dsc_requests
03237818 g     F .text	00000488 tcp_respond
0323970c g     F .text	0000033c udp4_sockbind
032525dc g     O .rwdata	00000004 __ctype_ptr
03254950 g     O .bss	00000004 old_mode
032243d4 g     F .text	0000026c igmp_joingroup
0322cdbc g     F .text	00000358 so_icmpdu
03204954 g     F .text	00000018 __fp_lock_all
03254a18 g     O .bss	00000004 vfs_dir_stale
03241e94 g     F .text	000000e4 ip_reasm_process_timer_tick
0324a198 g     F .text	0000005c vclearerr
0322585c g     F .text	000000ec bsd_setsockopt
0322c1a0 g     F .text	00000058 mbuf_len
03218b94 g     F .text	000000e4 OS_FlagInit
0323acc0 g     F .text	00000098 alt_alarm_stop
03249e98 g     F .text	000001e8 strippath
0325269c g     O .rwdata	00000004 reqlist
03226760 g     F .text	000001a0 tcp_sleep
03210524 g     F .text	00000024 strtol
03226e3c g     F .text	00000830 dhc_upcall
03239134 g     F .text	000000e0 tcp_usrclosed
0325493c g     O .bss	00000004 cticks_factor
03252650 g     O .rwdata	00000002 OSTaskIdleStkSize
03247f68 g     F .text	00000254 in_pcbbind
03204088 g     F .text	0000017c get_current_windows_of_activated_trackers
03254994 g     O .bss	00000004 alt_irq_active
0321a970 g     F .text	000000c0 OSSemAccept
03219380 g     F .text	000000f0 OSMemPut
03218e34 g     F .text	0000021c OSMemCreate
03254884 g     O .bss	00000004 OSIdleCtrMax
032000ec g     F .exceptions	000000d4 alt_irq_handler
032521e4 g     O .rwdata	00000028 alt_dev_null
03250628 g     O .rwdata	00000028 camera
032526be g     O .rwdata	00000001 tcprexmtthresh
03252664 g     O .rwdata	00000002 OSTicksPerSec
0323e558 g     F .text	00000098 if_killsocks
0323f010 g     F .text	00000248 ip_write
03242a30 g     F .text	0000060c ip_rcv_phase2
0322e484 g     F .text	00000044 t_getsockname
0322e198 g     F .text	000002a8 t_connect
032216b8 g     F .text	00000394 eth_ocm_init
032526b8 g     O .rwdata	00000004 TCPTV_MSL
0325cb04 g     O .bss	00000010 memestats
0322ac68 g     F .text	00000060 getch
03213d4c g     F .text	000000c8 __unpack_f
0321e42c g     F .text	000000ac alt_set_flash_algorithm_func
03252544 g     O .rwdata	00000080 vfs_root_path
0322e440 g     F .text	00000044 t_getpeername
03240b90 g     F .text	000000a0 ip_reasm_decr_mem_useage
03231fa8 g     F .text	00000080 soreserve
0323b120 g       .text	00000000 OSIntCtxSw
0322b5d0 g     F .text	000000f4 npalloc
0323a2a8 g     F .text	00000044 alt_dcache_flush_all
0320da3c g     F .text	00000070 __hi0bits
032549f4 g     O .bss	00000004 ipraw_eps
03229cb8 g     F .text	00000290 pk_init
03247158 g     F .text	00000180 md_fread
0324b8e0 g     F .text	0000001c calloc
032139ec g     F .text	000000d8 __fixdfsi
0325d008 g     O .bss	00000064 intimers
03232088 g     F .text	00000048 sbrelease
0323310c g     F .text	000000f0 ifd_clr
032329b8 g     F .text	00000094 sbdroprecord
03225f98 g     F .text	00000080 uslash
0323af80 g     F .text	00000120 alt_write
0321dfe0 g     F .text	0000003c alt_write_flash_command_8bit_device_8bit_mode
032549c4 g     O .bss	00000004 arpRepsIn
03226cac g     F .text	00000090 dhc_get_srv_ipaddr
0323cb40 g     F .text	0000017c in_timerset
032102c4 g     F .text	0000001c strtod
03254888 g     O .bss	00000004 OSTCBFreeList
03252724 g       *ABS*	00000000 __ram_rwdata_end
0321b060 g     F .text	0000017c OSSemPendAbort
03236348 g     F .text	0000117c tcp_output
032549a0 g     O .bss	00000004 activehost
032526dc g     O .rwdata	00000008 alt_dev_list
032262d0 g     F .text	0000022c parse_args
03254954 g     O .bss	00000004 global_TCPwakeup_setIndx
0320d4a8 g     F .text	00000058 _fputc_r
032229ec g     F .text	00000070 write
0322b6c4 g     F .text	000000b8 npfree
03206c58 g     F .text	000000e8 _putc_r
0323d8d8 g     F .text	00000294 arpReply
03225a8c g     F .text	0000007c nextarg
03252668 g     O .rwdata	00000002 OSVersionNbr
03241540 g     F .text	00000594 ip_reasm_process_subsequent_fragments
0325271c g     O .rwdata	00000004 pton_error
032548f8 g     O .bss	00000004 dsc_errors
032129b4 g     F .text	00000078 __gtsf2
032572e8 g     O .bss	00002000 SSSInitialTaskStk
0325c654 g     O .bss	00000014 rcvdq
032330a4 g     F .text	00000068 tcp_notify
03250628 g       *ABS*	00000000 __ram_rodata_end
0321462c g     F .text	000000d4 fstat
03204bf0 g     F .text	0000002c fprintf
0322fbe8 g     F .text	000000d4 soconnect
03243d34 g     F .text	0000005c ip_raw_maxalloc
0321386c g     F .text	00000088 __ledf2
03227888 g     F .text	00000518 dhc_discover
0321f280 g     F .text	000000dc alt_check_primary_table
032484a8 g     F .text	0000007c in_setpeeraddr
03252610 g     O .rwdata	00000004 OSEndiannessTest
0322acc8 g     F .text	0000003c clock_init
03248f54 g     F .text	000000e4 vfgets
0323cf0c g     F .text	0000017c et_send
0320e7c8 g     F .text	00000120 __pow5mult
03254844 g     O .bss	00000004 __nlocale_changed
032044c4 g     F .text	00000008 __umodsi3
0321da70 g     F .text	00000068 alt_flash_cfi_read
0321e1b4 g     F .text	00000034 alt_write_native_8bit
032477c0 g     F .text	00000068 inet_addr
03240a50 g     F .text	00000098 ip_reasm_check_mem_useage
03230bf0 g     F .text	00000100 sorflush
0324bc1c g     F .text	00000020 vprintf
0325cc18 g     O .bss	000000fc global_tcb_ext
0323f6e0 g     F .text	00000488 ip_fragment_lc
0325c668 g     O .bss	00000300 netstatic
0322dca0 g     F .text	0000017c t_bind
03201440 g     F .text	000000a8 select_sensor_output
03252622 g     O .rwdata	00000002 OSFlagGrpSize
0322a914 g     F .text	000000e4 udp_close
0322b2b4 g     F .text	0000021c alt_iniche_init
0323bf44 g     F .text	00000074 eth_ocm_write_phy_reg
0325d4f0 g       *ABS*	00000000 end
0322aeec g     F .text	00000088 UNLOCK_NET_RESOURCE
0322ea44 g     F .text	000000f0 t_recv
032143fc g     F .text	00000160 __pack_f
0321e01c g     F .text	0000007c alt_write_flash_command_16bit_device_8bit_mode
03220888 g     F .text	00000538 altera_avalon_lcd_16207_write
0324930c g     F .text	000001ac vfread
03223208 g     F .text	000000e8 netclose
03203758 g     F .text	000001ac SSSSimpleSocketServerTask
0324b8c8 g     F .text	0000000c _atoi_r
0320555c g     F .text	00000024 fseek
0321e554 g     F .text	00000580 alt_read_cfi_table
032526c8 g     O .rwdata	00000004 tcp_keepintvl
0321f4a4 g     F .text	00000130 altera_avalon_jtag_uart_init
03216efc g     F .text	000000c8 OS_TaskStat
032548fc g     O .bss	00000004 dsc_discovers
03252184 g     O .rwdata	00000018 tcp_protosw
0324c070 g       *ABS*	00000000 __CTOR_LIST__
03254a14 g     O .bss	00000004 vfopen_error
03400000 g       *ABS*	00000000 __alt_stack_pointer
03254988 g     O .bss	00000004 tcp_maxidle
03254928 g     O .bss	00000004 firstudp
032210bc g     F .text	00000088 alt_avalon_timer_sc_init
03213ccc g     F .text	00000080 __clzsi2
03204204 g     F .text	0000017c get_current_corners_of_activated_trackers
0321fdd8 g     F .text	000002dc altera_avalon_jtag_uart_write
0321d64c g     F .text	0000009c alt_flash_cfi_init
03204878 g     F .text	00000004 __sfp_lock_acquire
032066e8 g     F .text	000000e4 memchr
03216bc4 g     F .text	00000054 OS_MemClr
03208218 g     F .text	00001eac ___vfprintf_internal_r
0323b1f0 g     F .text	00000310 OSTaskStkInit
03201648 g     F .text	00000088 task1
03207730 g     F .text	00000060 _sprintf_r
03204e0c g     F .text	00000314 _free_r
03245bf4 g     F .text	00000170 igmpv2_chk4_rtr_alert_opt
03200f14 g     F .text	0000011c write_camera_registers
0322f1bc g     F .text	000000d0 t_socketclose
03216244 g     F .text	00000194 OS_EventTaskRdy
0324bde8 g     F .text	000001b0 __call_exitprocs
032075ec g     F .text	0000004c __srget_r
032039bc g     F .text	000000a0 trackers_free
0325488c g     O .bss	00000001 OSCPUUsage
0325c968 g     O .bss	00000010 nets
0322ae2c g     F .text	000000c0 LOCK_NET_RESOURCE
03228c60 g     F .text	000000e4 dhc_resetip
03254848 g     O .bss	00000004 __mlocale_changed
0322dc10 g     F .text	00000090 t_socket
032525ec g     O .rwdata	00000004 __malloc_sbrk_base
032001c0 g     F .text	0000004c _start
0323ceb8 g     F .text	00000054 etainit
03254998 g     O .bss	00000004 _alt_tick_rate
0323c868 g     F .text	00000024 mcastlist
03219d6c g     F .text	00000320 OSQPend
03203fd4 g     F .text	000000b4 get_current_corners_of_tracker
0325cb14 g     O .bss	000000f0 pktlog
03210548 g     F .text	00000318 _strtoll_r
03245704 g     F .text	0000014c igmpv2_process_report
03233270 g     F .text	00000080 ifd_isset
0324433c g     F .text	00000144 del_route
032081b8 g     F .text	00000008 _user_strerror
0321cf78 g     F .text	0000014c OSTimeDly
03222588 g     F .text	0000016c eth_ocm_stats
0323bed4 g     F .text	00000070 eth_ocm_set_phy_addr
032017fc g     F .text	00000058 get_mac_addr
0322f5e8 g     F .text	000000f0 solisten
0320e358 g     F .text	0000014c __lshift
0325499c g     O .bss	00000004 _alt_nticks
03201330 g     F .text	00000058 set_sensor_mode
03222974 g     F .text	00000078 read
0321d544 g     F .text	000000d0 alt_sys_init
03237f4c g     F .text	0000004c tcp_quench
03226018 g     F .text	00000184 ns_printf
032069e4 g     F .text	00000078 _open_r
0323e3dc g     F .text	000000e0 isbcast
0322af74 g     F .text	00000214 TK_NEWTASK
0324bcb0 g     F .text	00000134 __register_exitproc
0325488d g     O .bss	00000001 OSTaskCtr
03240964 g     F .text	000000ec ip_reasm_determine_type_of_frag
0324ba5c g     F .text	000000f0 strncmp
03201130 g     F .text	00000048 set_image_exposure
0321df54 g     F .text	00000044 alt_read_query_entry_16bit
0321d0c4 g     F .text	00000174 OSTimeDlyHMSM
0323ac80 g     F .text	00000040 alt_remap_uncached
03243930 g     F .text	000000c0 ip_raw_close
0320e4a4 g     F .text	000001e8 __multiply
03252494 g     O .rwdata	000000b0 mdlist
0321f9b0 g     F .text	00000074 altera_avalon_jtag_uart_close
03223e98 g     F .text	000000f8 igmp_input
0323f608 g     F .text	000000d8 ip_raw_write
03250628 g       *ABS*	00000000 __ram_rwdata_start
032494b8 g     F .text	000003e8 vfwrite_locked
0324bb4c g     F .text	000000bc strncpy
0324c074 g       *ABS*	00000000 __ram_rodata_start
03254900 g     O .bss	00000004 dsc_offers
03255240 g     O .bss	00000028 __malloc_current_mallinfo
03252616 g     O .rwdata	00000002 OSEventMax
03247af4 g     F .text	00000074 inet_setport
0321e24c g     F .text	000001e0 alt_set_flash_width_func
0320e050 g     F .text	0000017c __d2b
0321b1dc g     F .text	00000128 OSSemPost
03235cbc g     F .text	00000190 tcp_dooptions
032317a0 g     F .text	000000fc soisconnected
03215dc8 g     F .text	000000e4 OSSchedUnlock
032437f0 g     F .text	00000028 netexit
032018c0 g     F .text	000001dc get_serial_number
032548e4 g     O .bss	00000004 nettick_wakes
0325497c g     O .bss	00000001 tcpprintfs
0323ccbc g     F .text	000000a8 in_timerkill
032455a4 g     F .text	00000160 igmpv2_input
03254910 g     O .bss	00000004 dsc_declines
0321f35c g     F .text	00000058 altera_avalon_jtag_uart_read_fd
03210860 g     F .text	00000230 _strtoul_r
03225a60 g     F .text	0000002c do_trap
0323a6a8 g     F .text	000000f4 alt_get_fd
03225460 g     F .text	00000104 bsd_ioctl
03254890 g     O .bss	00000004 OSMemFreeList
03215f1c g     F .text	000000ac OSStatInit
0322c4b0 g     F .text	000001ec tcp_rcv
03225df0 g     F .text	00000044 panic
03254a1c g     O .bss	00000004 vfs_open_files
0324a218 g     F .text	0000014c alt_busy_sleep
03223794 g     F .text	000001a4 ip2mac
032188fc g     F .text	000000d4 OSFlagQuery
03214334 g     F .text	000000c8 __fpcmp_parts_d
03232dc4 g     F .text	00000214 sock_select
03246d0c g     F .text	00000288 dhc_setup
032376a8 g     F .text	00000058 tcp_init
03254958 g     O .bss	00000004 cticks
032548ed g     O .bss	00000001 to_nettick
0325264c g     O .rwdata	00000002 OSTaskCreateExtEn
0320bb68 g     F .text	00000070 _close_r
03222a5c g     F .text	0000064c Netinit
0322b564 g     F .text	00000038 prep_armintcp
0324346c g     F .text	00000168 in_addmulti
03237700 g     F .text	00000118 tcp_template
0322c2a0 g     F .text	00000070 remque
0323b67c g     F .text	00000218 alt_erase_block_amd
0324bc08 g     F .text	00000014 _vprintf_r
03233360 g     F .text	00000408 tcp_reass
03247cb4 g     F .text	000001cc tcp_cksum
03239a48 g     F .text	000003dc udp4_socksend
03248d24 g     F .text	000001a8 vfclose_locked
032331fc g     F .text	00000074 ifd_set
0324b95c g     F .text	00000074 memcmp
03216228 g     F .text	0000001c OS_Dummy
0321f40c g     F .text	00000048 altera_avalon_jtag_uart_close_fd
03229b3c g     F .text	000000b0 dhc_set_state
032548c4 g     O .bss	00000004 NDEBUG
0325d4f0 g       *ABS*	00000000 __alt_stack_base
0325482c g     O .bss	00000004 last_flash_sector
0321f454 g     F .text	00000050 altera_avalon_jtag_uart_ioctl_fd
03232028 g     F .text	00000060 sbreserve
032439f0 g     F .text	00000238 ip_raw_input
03205c10 g     F .text	0000009c _fwrite_r
03200e1c g     F .text	000000f8 read_camera_registers
032526a8 g     O .rwdata	00000004 lilbufsiz
0323c4d4 g     F .text	0000003c eth_ocm_phy_profiles_init
032332f0 g     F .text	00000070 ifd_get
03231f0c g     F .text	0000009c sbwakeup
03207820 g     F .text	00000084 sscanf
0320ba2c g     F .text	0000013c __swsetup_r
0321ead4 g     F .text	000007ac alt_read_cfi_width
0325abd0 g     O .bss	000001e0 OSQTbl
03235f78 g     F .text	0000026c tcp_xmit_timer
0321336c g     F .text	00000258 __divdf3
032049f0 g     F .text	000000f0 __sfp
03201c68 g     F .text	0000013c generate_mac_addr
0323e6ec g     F .text	000001a4 ip_bldhead
0320deb4 g     F .text	00000058 __copybits
032320d0 g     F .text	000000a8 sbappend
03250a68 g     O .rwdata	00000408 __malloc_av_
03204884 g     F .text	00000004 __sinit_lock_release
03254894 g     O .bss	00000004 OSTCBHighRdy
03212fa8 g     F .text	000003c4 __muldf3
0323f258 g     F .text	000003b0 ip_write2
03207990 g     F .text	00000060 __sread
03252708 g     O .rwdata	00000004 arp_ageout
0320d6fc g     F .text	00000040 fread
03254898 g     O .bss	00000004 OSQFreeList
0323c028 g     F .text	000000a4 eth_ocm_phy_add_profile
0323e5f0 g     F .text	000000fc ip_init
0323a588 g     F .text	00000120 alt_find_file
03243cf4 g     F .text	00000040 ip_raw_free
0323d7c4 g     F .text	00000114 make_arp_entry
0323a318 g     F .text	000000b4 alt_dev_llist_insert
0321506c g     F .text	00000108 __malloc_lock
03204c1c g     F .text	00000034 _fprintf_r
03214ea8 g     F .text	000000bc sbrk
03239260 g     F .text	00000070 udp_lookup
03215374 g     F .text	00000144 OSEventNameSet
032045f0 g     F .text	000001fc _fflush_r
03211038 g     F .text	000000b4 _calloc_r
0325489c g     O .bss	00000001 OSRdyGrp
03247110 g     F .text	00000028 md_fopen
0325219c g     O .rwdata	00000018 udp_protosw
032525f8 g     O .rwdata	00000008 alt_flash_dev_list
0321e0e0 g     F .text	00000044 alt_write_flash_command_16bit_device_16bit_mode
0324842c g     F .text	0000007c in_setsockaddr
03204bd4 g     F .text	0000001c fopen
03254820 g       *ABS*	00000000 __bss_start
0320399c g     F .text	00000020 trackers_number
03232178 g     F .text	000000e0 sbappendrecord
0325d180 g     O .bss	00000050 ip_mib
0320694c g     F .text	00000098 memset
0322fcbc g     F .text	000000a0 sodisconnect
03201780 g     F .text	0000007c main
03201228 g     F .text	00000058 get_sensor_size
03254858 g     O .bss	00000004 alt_envp
03254840 g     O .bss	00000004 __malloc_max_total_mem
0320207c g     F .text	00000070 sss_reset_connection
0322bfd0 g     F .text	000001d0 m_adj
0321f3b4 g     F .text	00000058 altera_avalon_jtag_uart_write_fd
0320b998 g     F .text	0000001c __swbuf
032473a8 g     F .text	000000d8 md_fgetc
0324e23c g     O .rodata	00000100 OSUnMapTbl
03240238 g     F .text	000002b8 ip_dump
03226aa4 g     F .text	00000208 tk_stats
03212a2c g     F .text	00000078 __ltsf2
0320d500 g     F .text	000001fc _fread_r
03252684 g     O .rwdata	00000008 alt_iniche_dev_list
03220e8c g     F .text	00000164 altera_avalon_lcd_16207_init
03252646 g     O .rwdata	00000002 OSSemEn
03254940 g     O .bss	00000004 OS_TPS
0322d3dc g     F .text	000007e8 rawip_usrreq
03218554 g     F .text	000003a8 OSFlagPost
03203c88 g     F .text	000000e0 free_tracker
032078a4 g     F .text	00000008 __sclose
032479d0 g     F .text	00000060 print46_addr
03400000 g       *ABS*	00000000 __alt_heap_limit
032045dc g     F .text	00000014 fclose
032163d8 g     F .text	00000110 OS_EventTaskWait
032102e0 g     F .text	00000244 _strtol_r
03213ac4 g     F .text	00000074 __truncdfsf2
03225cc4 g     F .text	0000012c print_uptime
03216fc4 g     F .text	000000c8 OS_TaskStatStkChk
0325d360 g     O .bss	00000190 _atexit0
0321c28c g     F .text	00000170 OSTaskDelReq
0320bdf0 g     F .text	000015b4 _dtoa_r
03205fa8 g     F .text	00000740 _malloc_r
03247480 g     F .text	00000024 md_unlink
03247f14 g     F .text	00000054 in_pcbdetach
032526e8 g     O .rwdata	00000004 alt_errno
03252718 g     O .rwdata	00000004 mdlist_size
03215eac g     F .text	00000070 OSStart
03210da4 g     F .text	000000dc __submore
0321e16c g     F .text	00000048 alt_write_flash_command_32bit_device_32bit_mode
03246660 g     F .text	00000030 u_mctest_init
03215010 g     F .text	0000005c __env_unlock
03203bc4 g     F .text	000000c4 disable_tracker
03205b58 g     F .text	000000b8 _fwalk
0321c778 g     F .text	00000218 OSTaskResume
03219470 g     F .text	000000fc OSMemQuery
03247b68 g     F .text	0000014c convert_ip
0323d61c g     F .text	000001a8 find_oldest_arp
03252658 g     O .rwdata	00000002 OSTaskStatEn
032549bc g     O .bss	00000004 arpReqsIn
0324891c g     F .text	00000050 vf_free_buffer
0321dad8 g     F .text	00000164 alt_write_value_to_flash
0320d9d4 g     F .text	00000040 _mbtowc_r
0324a364 g     F .text	00000154 alt_fcntl
03252632 g     O .rwdata	00000002 OSMemMax
0321a388 g     F .text	00000188 OSQPostFront
0321e1e8 g     F .text	00000034 alt_write_native_16bit
0322ab8c g     F .text	00000030 dtrap
032526b4 g     O .rwdata	00000004 kb_last
03206b54 g     F .text	00000104 putc
032012d8 g     F .text	00000058 get_sensor_mode
032043fc g     F .text	00000060 __divsi3
0325489d g     O .bss	00000003 OSRdyTbl
0325260c g     O .rwdata	00000002 OSDebugEn
0324e118 g     O .rodata	00000014 __thenan_df
03223c88 g     F .text	000000d0 ip_exit
03204ce0 g     F .text	0000012c _malloc_trim_r
0324c074 g       *ABS*	00000000 __CTOR_END__
03252624 g     O .rwdata	00000002 OSFlagNodeSize
032548f4 g     O .bss	00000004 dhc_conn
03201030 g     F .text	00000058 get_image_size
0322ad20 g     F .text	0000006c cticks_hook
0325266c g     O .rwdata	00000002 OSTmrCfgMax
0323c7e0 g     F .text	0000003c sysuptime
0320ebb8 g     F .text	000000bc strcmp
03201a9c g     F .text	000001cc generate_and_store_mac_addr
03241f78 g     F .text	000001c8 ip_reasm_delete_ire
03219790 g     F .text	00000214 OSQCreate
0322ad8c g     F .text	0000005c irq_Mask
0321c3fc g     F .text	000001b8 OSTaskNameGet
032549a8 g     O .bss	00000004 nextppp
03254934 g     O .bss	00000004 irq_level
03201388 g     F .text	000000b8 camera_configure
032230a8 g     F .text	00000160 fixup_subnet_mask
0324c074 g       *ABS*	00000000 __flash_rodata_start
0321a510 g     F .text	00000234 OSQPostOpt
03215fc8 g     F .text	00000240 OSTimeTick
0324075c g     F .text	00000138 ip_copypkt
03229a38 g     F .text	00000090 dhc_alldone
03252654 g     O .rwdata	00000002 OSTaskMax
0324c074 g       *ABS*	00000000 __DTOR_LIST__
0321aa30 g     F .text	00000114 OSSemCreate
032548d8 g     O .bss	00000004 igmp_all_hosts_group
03252678 g     O .rwdata	00000002 OSTmrWheelSize
03231e6c g     F .text	00000038 sbselqueue
032548e0 g     O .bss	00000004 netmain_wakes
0323db6c g     F .text	00000260 arprcv
032266f0 g     F .text	00000070 TK_OSTaskResume
03224a18 g     F .text	000003e0 igmp_print_stats
0321364c g     F .text	00000088 __nedf2
0322b81c g     F .text	000000a0 pffindtype
0325264e g     O .rwdata	00000002 OSTaskDelEn
032526cc g     O .rwdata	00000004 tcp_sendspace
03249a7c g     F .text	00000134 vftell
0325c9dc g     O .bss	00000012 eth_prt_buf
0321b304 g     F .text	00000130 OSSemQuery
032199a4 g     F .text	00000300 OSQDel
0321a08c g     F .text	0000017c OSQPendAbort
0321d510 g     F .text	00000034 alt_irq_init
0325ce44 g     O .bss	00000018 app_semaphore
03214e48 g     F .text	00000060 alt_release_fd
0322b23c g     F .text	00000078 post_app_sem
03223de8 g     F .text	000000b0 igmp_init
032076bc g     F .text	00000074 sprintf
0324e12c g     O .rodata	00000100 __clz_tab
0325491c g     O .bss	00000004 dsc_renew
032472d8 g     F .text	00000080 md_fwrite
0325484c g     O .bss	00000004 _PathLocale
03254944 g     O .bss	00000004 tcp_sleep_count
0322c310 g     F .text	0000007c insque
032101a0 g     F .text	00000124 strtof
0324b8b4 g     F .text	00000014 atexit
03254a10 g     O .bss	00000004 vfsfiles
0320b9b4 g     F .text	00000078 _write_r
0324bc3c g     F .text	00000050 _vsprintf_r
03244cd8 g     F .text	000002b8 udp_send
03215d3c g     F .text	0000008c OSSchedLock
0322412c g     F .text	000002a8 igmp_send
0320d880 g     F .text	0000001c setlocale
03221348 g     F .text	00000104 set_search_window
0321782c g     F .text	0000013c OSFlagCreate
0322ade8 g     F .text	00000044 irq_Unmask
0322de1c g     F .text	000000e4 t_listen
0320ebb0 g     F .text	00000008 nanf
032525e0 g     O .rwdata	00000004 _impure_ptr
03250650 g     O .rwdata	00000018 ssstask
03254850 g     O .bss	00000004 alt_argc
03238828 g     F .text	00000704 tcp_usrreq
03239488 g     F .text	00000284 udp_usrreq
0322b77c g     F .text	00000054 ncpalloc
0320d914 g     F .text	00000080 _mbrtowc_r
0323a490 g     F .text	00000064 _do_dtors
0325261e g     O .rwdata	00000002 OSEventMultiEn
03252700 g     O .rwdata	00000004 pingdelay
03205120 g     F .text	0000043c _fseek_r
0323d110 g     F .text	00000074 arp_send_pending
032452bc g     F .text	000002e8 igmpv1_input
0320740c g     F .text	000001c4 __srefill_r
0322b4d0 g     F .text	00000074 pre_task_setup
03254964 g     O .bss	00000004 rcvdq_sem_ptr
0322505c g     F .text	0000012c bsd_getsockname
03242140 g     F .text	00000148 ip_reasm_mark_compact_rfq
03201f38 g     F .text	00000144 FindLastFlashSectorOffset
03217968 g     F .text	000002a8 OSFlagDel
032548a0 g     O .bss	00000004 OSEventFreeList
03226df8 g     F .text	00000044 dhc_set_callback
03200020 g       .exceptions	00000000 alt_irq_entry
032549b8 g     O .bss	00000004 arpcache
03203904 g     F .text	00000098 trackers_init
0324b1dc g     F .text	00000350 icmp_destun
032436ec g     F .text	00000070 lookup_mcast
03249e50 g     F .text	00000048 vfslookup
0324303c g     F .text	00000430 ip_demux
0320dbd0 g     F .text	00000080 __ulp
0320ea80 g     F .text	00000040 __isinfd
03254948 g     O .bss	00000004 tcp_wakeup_count
03217ea8 g     F .text	00000644 OSFlagPend
0325266a g     O .rwdata	00000002 OSTmrEn
0320493c g     F .text	00000018 __fp_unlock_all
0322b188 g     F .text	000000b4 wait_app_sem
03220ff0 g     F .text	00000058 altera_avalon_lcd_16207_write_fd
0320d444 g     F .text	00000064 fputc
0325268c g     O .rwdata	00000004 ipmcfail_str
0325495c g     O .bss	00000004 memtrapsize
0322bcac g     F .text	00000324 m_copy
032526d4 g     O .rwdata	00000008 alt_fs_list
03203d68 g     F .text	000001b8 set_search_window_of_tracker
0325cec0 g     O .bss	00000014 mfreeq
03216dc8 g     F .text	00000080 OS_StrCopy
0322f58c g     F .text	0000005c sobind
03247098 g     F .text	00000078 init_memdev
03254824 g     O .bss	00000001 to_ssstask
0321e098 g     F .text	00000048 alt_write_flash_command_32bit_device_8bit_mode
0322c38c g     F .text	00000124 nptcp_init
03201280 g     F .text	00000058 set_sensor_size
03252634 g     O .rwdata	00000002 OSMemNameSize
0325cd14 g     O .bss	000000f0 global_TCPwakeup_set
0323b5bc g     F .text	0000001c OSInitHookEnd
03231928 g     F .text	000000bc soisdisconnected
03200020 g       *ABS*	00000000 __ram_exceptions_start
0323d088 g     F .text	00000088 arp_free_pending
03252660 g     O .rwdata	00000002 OSTCBPrioTblMax
0320d7ec g     F .text	00000010 localeconv
0322f808 g     F .text	000002f4 soclose
0325cc04 g     O .bss	00000014 bigfreeq
0325265c g     O .rwdata	00000002 OSTaskStatStkChkEn
032526fc g     O .rwdata	00000004 prompt
0325210c g     O .rwdata	00000048 eth_ocm_0
032526c4 g     O .rwdata	00000004 tcp_keepidle
0322d208 g     F .text	000001d4 rawip_soinput
032498a0 g     F .text	00000060 vfwrite
03252630 g     O .rwdata	00000002 OSMemEn
03231c00 g     F .text	000000ac soqinsque
032549ec g     O .bss	00000004 so_evtmap_delete
03205cac g     F .text	00000040 fwrite
03211110 g     F .text	00000068 __hexdig_init
03207798 g     F .text	00000088 _sscanf_r
0325263a g     O .rwdata	00000002 OSMutexEn
032549d8 g     O .bss	00000004 h_ireq
03252724 g       *ABS*	00000000 _edata
0323fb68 g     F .text	00000624 ip_fragment
03222830 g     F .text	00000144 iniche_devices_init
0325ced4 g     O .bss	00000028 tcp_saveti
032261e0 g     F .text	000000f0 con_page
0325d4f0 g       *ABS*	00000000 _end
032311b0 g     F .text	00000540 sogetopt
0321455c g     F .text	0000007c alt_flash_open_dev
032548a4 g     O .bss	00000001 OSIntNesting
03252154 g     O .rwdata	00000030 nettasks
0322a388 g     F .text	00000020 pk_get_max_intrsafe_buf_len
032404f0 g     F .text	0000026c iproute
0322ccd4 g     F .text	000000e8 np_stripoptions
032549f0 g     O .bss	00000001 so_evtmap
032001c0 g       *ABS*	00000000 __ram_exceptions_end
0320b7f4 g     F .text	00000074 vfscanf
0321fa24 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
03204c50 g     F .text	00000074 _fputs_r
0321d238 g     F .text	00000210 OSTimeDlyResume
03243f14 g     F .text	00000428 add_route
03217d54 g     F .text	00000154 OSFlagNameSet
032236c4 g     F .text	000000d0 c_older
03232648 g     F .text	00000090 sbflush
0323bfb8 g     F .text	00000070 eth_ocm_read_phy_reg
03247138 g     F .text	00000020 md_fclose
03226a78 g     F .text	0000002c tk_yield
032034ac g     F .text	000000c0 sss_handle_accept
0321c990 g     F .text	000001fc OSTaskStkChk
0322fd5c g     F .text	00000608 sosend
03252636 g     O .rwdata	00000002 OSMemSize
03201178 g     F .text	00000058 get_start_image
0324018c g     F .text	000000ac ip_mymach
03207914 g     F .text	0000007c __swrite
03254930 g     O .bss	00000004 cticks_initialized
03252704 g     O .rwdata	00000004 deflength
0322ec84 g     F .text	0000022c t_sendto
032525e8 g     O .rwdata	00000004 __malloc_trim_threshold
03206a5c g     F .text	0000006c _perror_r
032548a8 g     O .bss	00000004 OSTCBCur
0322f3c0 g     F .text	000001cc socreate
0324b8fc g     F .text	00000038 exit
0325d06c g     O .bss	00000100 arp_table
03254a28 g     O .bss	00000004 icmpdu_hook
03252638 g     O .rwdata	00000002 OSMemTblSize
03205a90 g     F .text	000000c8 _fwalk_reent
0323cd64 g     F .text	00000024 create_apptasks
032526c0 g     O .rwdata	00000004 tcp_ttl
0320e1cc g     F .text	0000018c __mdiff
032145d8 g     F .text	00000054 alt_flash_close_dev
0322b7d0 g     F .text	0000004c ncpfree
0320445c g     F .text	00000060 __modsi3
032548bc g     O .bss	00000004 MaxLnh
032011d0 g     F .text	00000058 set_start_image
03247944 g     F .text	0000008c inet_ntop
03245250 g     F .text	0000002c udp_maxalloc
03400000 g       *ABS*	00000000 __alt_data_end
03200020 g     F .exceptions	00000000 alt_exception
0320487c g     F .text	00000004 __sfp_lock_release
03215b6c g     F .text	00000054 OSInit
0321cdb8 g     F .text	00000144 OSTaskQuery
0323c60c g     F .text	00000088 icmp_port_du
0325498c g     O .bss	00000004 tcp_iss
0321a8c4 g     F .text	000000ac OS_QInit
0320eaf0 g     F .text	000000c0 __sccl
0324b8d4 g     F .text	0000000c atoi
032526b0 g     O .rwdata	00000004 bigbufsiz
03216e48 g     F .text	00000058 OS_StrLen
03237f98 g     F .text	00000080 tcp_putseq
03219260 g     F .text	00000120 OSMemNameSet
0324d474 g     O .rodata	00000101 _ctype_
03232258 g     F .text	00000208 sbappendaddr
02800000 g       *ABS*	00000000 __alt_mem_ext_flash
03254a20 g     O .bss	00000004 vfs_total_rw_space
0324649c g     F .text	00000140 ip_getmoptions
03252652 g     O .rwdata	00000002 OSTaskProfileEn
03244f90 g     F .text	00000130 udpswap
032548ac g     O .bss	00000004 OSTime
03254968 g     O .bss	00000004 nextslow
03238090 g     F .text	000002a0 tcp_slowtimo
03237ca0 g     F .text	00000118 tcp_newtcpcb
0323ddcc g     F .text	000001a8 send_via_arp
03226d3c g     F .text	000000bc dhc_init
03241ad4 g     F .text	00000064 ip_reasm_find_ire
03213e14 g     F .text	000000a8 __fpcmp_parts_f
0325adb0 g     O .bss	00000800 OSTaskIdleStk
03204ae0 g     F .text	000000f4 _fopen_r
0324bfd8 g     F .text	0000002c _exit
0324a080 g     F .text	00000064 isvfile_locked
0320eac0 g     F .text	00000030 __isnand
032256f4 g     F .text	00000168 bsd_select
03239f80 g     F .text	00000154 alt_alarm_start
03217c10 g     F .text	00000144 OSFlagNameGet
0324527c g     F .text	00000040 udp_free
0322a454 g     F .text	000000c8 getq
0324a1f4 g     F .text	00000024 prep_vfs
0321d448 g     F .text	00000064 OSTimeGet
032526f8 g     O .rwdata	00000004 name
032328a8 g     F .text	00000110 sbdropend
03211c74 g     F .text	00000098 __muldi3
03205e14 g     F .text	00000194 __smakebuf_r
0321e21c g     F .text	00000030 alt_write_native_32bit
0323df74 g     F .text	00000118 cb_arpent_tmo
03208144 g     F .text	00000074 strlen
03245d64 g     F .text	00000148 IPADDR_TO_NETP
03225564 g     F .text	00000030 bsd_inet_ntoa
0323b540 g     F .text	0000001c OSTaskSwHook
03214c60 g     F .text	00000188 open
0322a6dc g     F .text	00000238 udp_open
0325b5b0 g     O .bss	00000b40 OSEventTbl
03231dcc g     F .text	00000050 socantsendmore
03254a24 g     O .bss	00000004 vfs_total_dyna_files
0321375c g     F .text	00000088 __gedf2
0325c0f0 g     O .bss	00000510 OSTCBTbl
03211228 g     F .text	000007b8 __gethex
032549c0 g     O .bss	00000004 arpReqsOut
0321b434 g     F .text	00000104 OSSemSet
03252720 g     O .rwdata	00000004 http_root_path
03228f28 g     F .text	000002bc dhc_extract_opts
03240fb0 g     F .text	00000590 ip_reasm_compute_overlap
0321d9e0 g     F .text	00000090 alt_flash_cfi_get_info
0323a79c g     F .text	00000030 alt_icache_flush_all
032079f0 g     F .text	000000e0 strchr
0325c9ee g     O .bss	00000012 ipreturn
032549e0 g     O .bss	00000004 port_prep
032521d7 g     O .rwdata	0000000d tcp_backoff
03231734 g     F .text	0000006c soisconnecting
032016d0 g     F .text	000000b0 SSSInitialTask
03204cc4 g     F .text	0000001c fputs
032526ec g     O .rwdata	00000004 alt_priority_mask
03245850 g     F .text	0000024c igmpv2_process_query
03232a4c g     F .text	00000220 t_select
0321ab44 g     F .text	000002a0 OSSemDel
03203a5c g     F .text	00000168 activate_tracker
03239e24 g     F .text	0000015c udp4_sockaddr
032548b0 g     O .bss	00000004 OSFlagFreeList
032481bc g     F .text	00000210 in_pcbconnect
03254980 g     O .bss	00000004 dropline
032549dc g     O .bss	00000004 ire_cticks
03252618 g     O .rwdata	00000002 OSEventNameSize
0320a0c4 g     F .text	00000024 __vfprintf_internal
032265f0 g     F .text	00000088 tk_netmain
032483cc g     F .text	00000060 in_pcbdisconnect
032548b4 g     O .bss	00000001 OSStatRdy
03200db4 g     F .text	00000068 camera_init
0325c600 g     O .bss	00000054 OSTCBPrioTbl
032214fc g     F .text	000001bc eth_ocm_prep
03214f64 g     F .text	000000ac __env_lock
0325265e g     O .rwdata	00000002 OSTaskSwHookEn
03252470 g     O .rwdata	00000024 mdio
03224df8 g     F .text	00000138 bsd_accept
032526d0 g     O .rwdata	00000004 tcp_recvspace
03212eb4 g     F .text	00000080 __subdf3
03239214 g     F .text	0000004c tcpinit
032548dc g     O .bss	00000004 igmp_all_rtrs_group
0322d198 g     F .text	00000070 rawip_lookup
0323ce08 g     F .text	000000b0 fcntl
0320daac g     F .text	000000c4 __lo0bits
03232460 g     F .text	000001e8 sbcompress
0320a0e8 g     F .text	00001680 __svfscanf_r
032526f0 g     O .rwdata	00000008 alt_alarm_list
03210e80 g     F .text	0000019c _ungetc_r
03237db8 g     F .text	000000ac tcp_drop
03252626 g     O .rwdata	00000002 OSFlagWidth
0323a42c g     F .text	00000064 _do_ctors
0323838c g     F .text	0000049c tcp_timers
03223d58 g     F .text	00000090 if_netnumber
032465dc g     F .text	00000084 ip_freemoptions
032316f0 g     F .text	00000044 sohasoutofband
03233768 g     F .text	00002554 tcp_input
03224f30 g     F .text	0000012c bsd_getpeername
03225594 g     F .text	00000160 bsd_recvfrom
032227dc g     F .text	00000054 close
0325490c g     O .bss	00000004 dsc_bpreplys
0323b614 g     F .text	00000068 alt_program_amd
03254860 g     O .bss	00000004 alt_envsem
032548b8 g     O .bss	00000004 OSIdleCtrRun
03216208 g     F .text	00000020 OSVersion
03252670 g     O .rwdata	00000002 OSTmrCfgWheelSize
03214880 g     F .text	00000080 alt_load
0321cefc g     F .text	0000007c OS_TaskStkClr
03248780 g     F .text	00000028 set_vfopen_error
03213ee8 g     F .text	00000314 __pack_d
0325264a g     O .rwdata	00000002 OSTaskCreateEn
032521b4 g     O .rwdata	00000018 rawip_protosw
03231ea4 g     F .text	00000068 sbwait
032167f8 g     F .text	00000068 OS_EventWaitListInit
032291e4 g     F .text	0000059c dhc_second
032549ac g     O .bss	00000004 port_1s_callout
0323b5d8 g     F .text	0000001c OSTaskIdleHook
0324b934 g     F .text	00000014 free
03204880 g     F .text	00000004 __sinit_lock_acquire
0320e6c8 g     F .text	00000100 __multadd
0321cb8c g     F .text	0000022c OSTaskSuspend
0320da14 g     F .text	00000028 _Bfree
032319e4 g     F .text	0000021c sonewconn
0324a5a8 g     F .text	00000c34 icmprcv
0322b8bc g     F .text	000000d0 pffindproto
03216ea0 g     F .text	0000005c OS_TaskIdle
03252676 g     O .rwdata	00000002 OSTmrTblSize
0321a744 g     F .text	00000180 OSQQuery



Disassembly of section .entry:

02800000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 2800000:	00900014 	movui	r2,16384
#endif

0:
    initi r2
 2800004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 2800008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 280000c:	00bffd16 	blt	zero,r2,2800004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 2800010:	0040c834 	movhi	at,800
    ori r1, r1, %lo(_start)
 2800014:	08407014 	ori	at,at,448
    jmp r1
 2800018:	0800683a 	jmp	at
 280001c:	00000000 	call	0 <OSTCBStkPtr_OFFSET>

Disassembly of section .exceptions:

03200020 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -76
 3200020:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
 3200024:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
 3200028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 320002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 3200030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 3200034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 3200038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 320003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 3200040:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
 3200044:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
 3200048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 320004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 3200050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 3200054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 3200058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 320005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 3200060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 3200064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 3200068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 320006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 3200070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 3200074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 3200078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 320007c:	10000326 	beq	r2,zero,320008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 3200080:	20000226 	beq	r4,zero,320008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 3200084:	32000ec0 	call	32000ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 3200088:	00000306 	br	3200098 <alt_exception+0x78>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
 320008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
 3200090:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
 3200094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 3200098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 320009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 32000a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 32000a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 32000a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 32000ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 32000b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 32000b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 32000b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 32000bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 32000c0:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
 32000c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 32000c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 32000cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 32000d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 32000d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 32000d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 32000dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 32000e0:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
 32000e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 32000e8:	ef80083a 	eret

032000ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 32000ec:	defff904 	addi	sp,sp,-28
 32000f0:	dfc00615 	stw	ra,24(sp)
 32000f4:	df000515 	stw	fp,20(sp)
 32000f8:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 32000fc:	3215bc00 	call	3215bc0 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 3200100:	0005313a 	rdctl	r2,ipending
 3200104:	e0bffc15 	stw	r2,-16(fp)

  return active;
 3200108:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 320010c:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
 3200110:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 3200114:	00800044 	movi	r2,1
 3200118:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 320011c:	e0ffff17 	ldw	r3,-4(fp)
 3200120:	e0bffe17 	ldw	r2,-8(fp)
 3200124:	1884703a 	and	r2,r3,r2
 3200128:	1005003a 	cmpeq	r2,r2,zero
 320012c:	1000171e 	bne	r2,zero,320018c <alt_irq_handler+0xa0>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
 3200130:	e0bffd17 	ldw	r2,-12(fp)
 3200134:	00c0c9b4 	movhi	r3,806
 3200138:	18f47e04 	addi	r3,r3,-11784
 320013c:	100490fa 	slli	r2,r2,3
 3200140:	10c5883a 	add	r2,r2,r3
 3200144:	11800017 	ldw	r6,0(r2)
 3200148:	e0bffd17 	ldw	r2,-12(fp)
 320014c:	00c0c9b4 	movhi	r3,806
 3200150:	18f47e04 	addi	r3,r3,-11784
 3200154:	100490fa 	slli	r2,r2,3
 3200158:	10c5883a 	add	r2,r2,r3
 320015c:	10800104 	addi	r2,r2,4
 3200160:	11000017 	ldw	r4,0(r2)
 3200164:	e17ffd17 	ldw	r5,-12(fp)
 3200168:	303ee83a 	callr	r6
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 320016c:	0005313a 	rdctl	r2,ipending
 3200170:	e0bffb15 	stw	r2,-20(fp)

  return active;
 3200174:	e0bffb17 	ldw	r2,-20(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
 3200178:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
 320017c:	e0bfff17 	ldw	r2,-4(fp)
 3200180:	1004c03a 	cmpne	r2,r2,zero
 3200184:	103fe21e 	bne	r2,zero,3200110 <alt_irq_handler+0x24>
 3200188:	00000706 	br	32001a8 <alt_irq_handler+0xbc>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
 320018c:	e0bffe17 	ldw	r2,-8(fp)
 3200190:	1085883a 	add	r2,r2,r2
 3200194:	e0bffe15 	stw	r2,-8(fp)
      i++;
 3200198:	e0bffd17 	ldw	r2,-12(fp)
 320019c:	10800044 	addi	r2,r2,1
 32001a0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 32001a4:	003fdd06 	br	320011c <alt_irq_handler+0x30>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 32001a8:	3215c3c0 	call	3215c3c <OSIntExit>
}
 32001ac:	e037883a 	mov	sp,fp
 32001b0:	dfc00117 	ldw	ra,4(sp)
 32001b4:	df000017 	ldw	fp,0(sp)
 32001b8:	dec00204 	addi	sp,sp,8
 32001bc:	f800283a 	ret

Disassembly of section .text:

032001c0 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 32001c0:	00900014 	movui	r2,16384
#endif

0:
    initd 0(r2)
 32001c4:	10000033 	initd	0(r2)
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 32001c8:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 32001cc:	00bffd16 	blt	zero,r2,32001c4 <_start+0x4>
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 32001d0:	06c0d034 	movhi	sp,832
    ori sp, sp, %lo(__alt_stack_pointer)
 32001d4:	dec00014 	ori	sp,sp,0

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
 32001d8:	0680c974 	movhi	gp,805
    ori gp, gp, %lo(_gp)
 32001dc:	d6a97714 	ori	gp,gp,42460
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 32001e0:	0080c974 	movhi	r2,805
    ori r2, r2, %lo(__bss_start)
 32001e4:	10920814 	ori	r2,r2,18464

    movhi r3, %hi(__bss_end)
 32001e8:	00c0c974 	movhi	r3,805
    ori r3, r3, %lo(__bss_end)
 32001ec:	18f53c14 	ori	r3,r3,54512

    beq r2, r3, 1f
 32001f0:	10c00326 	beq	r2,r3,3200200 <_start+0x40>

0:
    stw zero, (r2)
 32001f4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 32001f8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 32001fc:	10fffd36 	bltu	r2,r3,32001f4 <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 3200200:	32148800 	call	3214880 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 3200204:	3214abc0 	call	3214abc <alt_main>

03200208 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 3200208:	003fff06 	br	3200208 <alt_after_alt_main>

0320020c <alt_uCOSIIErrorHandler>:
#include <errno.h>
#include "includes.h"
#include "alt_error_handler.h"
 
void alt_uCOSIIErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 320020c:	defff904 	addi	sp,sp,-28
 3200210:	dfc00615 	stw	ra,24(sp)
 3200214:	df000515 	stw	fp,20(sp)
 3200218:	df000504 	addi	fp,sp,20
 320021c:	e17ffd15 	stw	r5,-12(fp)
 3200220:	e13ffc05 	stb	r4,-16(fp)
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
 3200224:	e0bffc03 	ldbu	r2,-16(fp)
 3200228:	1005003a 	cmpeq	r2,r2,zero
 320022c:	10017b1e 	bne	r2,zero,320081c <alt_uCOSIIErrorHandler+0x610>
   {
      return;
   }
   
   fault_level = SYSTEM;  
 3200230:	00800084 	movi	r2,2
 3200234:	e0bffb15 	stw	r2,-20(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 3200238:	3215d3c0 	call	3215d3c <OSSchedLock>
      
   switch (error_code)
 320023c:	e0bffc03 	ldbu	r2,-16(fp)
 3200240:	e0bffe15 	stw	r2,-8(fp)
 3200244:	e0fffe17 	ldw	r3,-8(fp)
 3200248:	18800a20 	cmpeqi	r2,r3,40
 320024c:	1000371e 	bne	r2,zero,320032c <alt_uCOSIIErrorHandler+0x120>
 3200250:	e0fffe17 	ldw	r3,-8(fp)
 3200254:	18800a48 	cmpgei	r2,r3,41
 3200258:	10001a1e 	bne	r2,zero,32002c4 <alt_uCOSIIErrorHandler+0xb8>
 320025c:	e0fffe17 	ldw	r3,-8(fp)
 3200260:	18800120 	cmpeqi	r2,r3,4
 3200264:	1000761e 	bne	r2,zero,3200440 <alt_uCOSIIErrorHandler+0x234>
 3200268:	e0fffe17 	ldw	r3,-8(fp)
 320026c:	18800148 	cmpgei	r2,r3,5
 3200270:	10000a1e 	bne	r2,zero,320029c <alt_uCOSIIErrorHandler+0x90>
 3200274:	e0fffe17 	ldw	r3,-8(fp)
 3200278:	188000a0 	cmpeqi	r2,r3,2
 320027c:	1000911e 	bne	r2,zero,32004c4 <alt_uCOSIIErrorHandler+0x2b8>
 3200280:	e0fffe17 	ldw	r3,-8(fp)
 3200284:	188000c8 	cmpgei	r2,r3,3
 3200288:	1000771e 	bne	r2,zero,3200468 <alt_uCOSIIErrorHandler+0x25c>
 320028c:	e0fffe17 	ldw	r3,-8(fp)
 3200290:	18800060 	cmpeqi	r2,r3,1
 3200294:	10005e1e 	bne	r2,zero,3200410 <alt_uCOSIIErrorHandler+0x204>
 3200298:	0000d806 	br	32005fc <alt_uCOSIIErrorHandler+0x3f0>
 320029c:	e0fffe17 	ldw	r3,-8(fp)
 32002a0:	18800520 	cmpeqi	r2,r3,20
 32002a4:	10004f1e 	bne	r2,zero,32003e4 <alt_uCOSIIErrorHandler+0x1d8>
 32002a8:	e0fffe17 	ldw	r3,-8(fp)
 32002ac:	188007a0 	cmpeqi	r2,r3,30
 32002b0:	1000ad1e 	bne	r2,zero,3200568 <alt_uCOSIIErrorHandler+0x35c>
 32002b4:	e0fffe17 	ldw	r3,-8(fp)
 32002b8:	188002a0 	cmpeqi	r2,r3,10
 32002bc:	1000761e 	bne	r2,zero,3200498 <alt_uCOSIIErrorHandler+0x28c>
 32002c0:	0000ce06 	br	32005fc <alt_uCOSIIErrorHandler+0x3f0>
 32002c4:	e0fffe17 	ldw	r3,-8(fp)
 32002c8:	18801020 	cmpeqi	r2,r3,64
 32002cc:	10009c1e 	bne	r2,zero,3200540 <alt_uCOSIIErrorHandler+0x334>
 32002d0:	e0fffe17 	ldw	r3,-8(fp)
 32002d4:	18801048 	cmpgei	r2,r3,65
 32002d8:	10000a1e 	bne	r2,zero,3200304 <alt_uCOSIIErrorHandler+0xf8>
 32002dc:	e0fffe17 	ldw	r3,-8(fp)
 32002e0:	18800f60 	cmpeqi	r2,r3,61
 32002e4:	10008b1e 	bne	r2,zero,3200514 <alt_uCOSIIErrorHandler+0x308>
 32002e8:	e0fffe17 	ldw	r3,-8(fp)
 32002ec:	18800fa0 	cmpeqi	r2,r3,62
 32002f0:	10007e1e 	bne	r2,zero,32004ec <alt_uCOSIIErrorHandler+0x2e0>
 32002f4:	e0fffe17 	ldw	r3,-8(fp)
 32002f8:	18800aa0 	cmpeqi	r2,r3,42
 32002fc:	1000151e 	bne	r2,zero,3200354 <alt_uCOSIIErrorHandler+0x148>
 3200300:	0000be06 	br	32005fc <alt_uCOSIIErrorHandler+0x3f0>
 3200304:	e0fffe17 	ldw	r3,-8(fp)
 3200308:	18801920 	cmpeqi	r2,r3,100
 320030c:	1000a11e 	bne	r2,zero,3200594 <alt_uCOSIIErrorHandler+0x388>
 3200310:	e0fffe17 	ldw	r3,-8(fp)
 3200314:	18803fe0 	cmpeqi	r2,r3,255
 3200318:	1000aa1e 	bne	r2,zero,32005c4 <alt_uCOSIIErrorHandler+0x3b8>
 320031c:	e0fffe17 	ldw	r3,-8(fp)
 3200320:	188010a0 	cmpeqi	r2,r3,66
 3200324:	10001d1e 	bne	r2,zero,320039c <alt_uCOSIIErrorHandler+0x190>
 3200328:	0000b406 	br	32005fc <alt_uCOSIIErrorHandler+0x3f0>
   {  
      case OS_PRIO_EXIST:
         fprintf(stderr, "Attempted to assign task priority aready in use.\n");
 320032c:	0080c974 	movhi	r2,805
 3200330:	10897804 	addi	r2,r2,9696
 3200334:	10800017 	ldw	r2,0(r2)
 3200338:	11c00317 	ldw	r7,12(r2)
 320033c:	0100c974 	movhi	r4,805
 3200340:	21301d04 	addi	r4,r4,-16268
 3200344:	01400044 	movi	r5,1
 3200348:	01800c44 	movi	r6,49
 320034c:	3205cac0 	call	3205cac <fwrite>
         break;
 3200350:	0000c106 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_PRIO_INVALID:
         fprintf(stderr, "Specified task priority higher than allowed max.\n");
 3200354:	0080c974 	movhi	r2,805
 3200358:	10897804 	addi	r2,r2,9696
 320035c:	10800017 	ldw	r2,0(r2)
 3200360:	11c00317 	ldw	r7,12(r2)
 3200364:	0100c974 	movhi	r4,805
 3200368:	21302a04 	addi	r4,r4,-16216
 320036c:	01400044 	movi	r5,1
 3200370:	01800c44 	movi	r6,49
 3200374:	3205cac0 	call	3205cac <fwrite>
         fprintf(stderr, "Task can't be assigned a priority higher than %d\n",
 3200378:	0080c974 	movhi	r2,805
 320037c:	10897804 	addi	r2,r2,9696
 3200380:	10800017 	ldw	r2,0(r2)
 3200384:	11000317 	ldw	r4,12(r2)
 3200388:	0140c974 	movhi	r5,805
 320038c:	29703704 	addi	r5,r5,-16164
 3200390:	01800504 	movi	r6,20
 3200394:	3204bf00 	call	3204bf0 <fprintf>
            OS_LOWEST_PRIO);
         break;
 3200398:	0000af06 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_NO_MORE_TCB:
         fprintf(stderr, "Task Control Blocks have been exhausted\n");
 320039c:	0080c974 	movhi	r2,805
 32003a0:	10897804 	addi	r2,r2,9696
 32003a4:	10800017 	ldw	r2,0(r2)
 32003a8:	11c00317 	ldw	r7,12(r2)
 32003ac:	0100c974 	movhi	r4,805
 32003b0:	21304404 	addi	r4,r4,-16112
 32003b4:	01400044 	movi	r5,1
 32003b8:	01800a04 	movi	r6,40
 32003bc:	3205cac0 	call	3205cac <fwrite>
         fprintf(stderr, "Current max number of tasks is %d\n",OS_MAX_TASKS);
 32003c0:	0080c974 	movhi	r2,805
 32003c4:	10897804 	addi	r2,r2,9696
 32003c8:	10800017 	ldw	r2,0(r2)
 32003cc:	11000317 	ldw	r4,12(r2)
 32003d0:	0140c974 	movhi	r5,805
 32003d4:	29704f04 	addi	r5,r5,-16068
 32003d8:	01800284 	movi	r6,10
 32003dc:	3204bf00 	call	3204bf0 <fprintf>
         break;
 32003e0:	00009d06 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_MBOX_FULL:
         fault_level = NONE;
 32003e4:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted Post to Mailbox already holding message\n");
 32003e8:	0080c974 	movhi	r2,805
 32003ec:	10897804 	addi	r2,r2,9696
 32003f0:	10800017 	ldw	r2,0(r2)
 32003f4:	11c00317 	ldw	r7,12(r2)
 32003f8:	0100c974 	movhi	r4,805
 32003fc:	21305804 	addi	r4,r4,-16032
 3200400:	01400044 	movi	r5,1
 3200404:	01800c84 	movi	r6,50
 3200408:	3205cac0 	call	3205cac <fwrite>
         break;
 320040c:	00009206 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_EVENT_TYPE:
         fault_level = TASK;
 3200410:	00800044 	movi	r2,1
 3200414:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, 
 3200418:	0080c974 	movhi	r2,805
 320041c:	10897804 	addi	r2,r2,9696
 3200420:	10800017 	ldw	r2,0(r2)
 3200424:	11c00317 	ldw	r7,12(r2)
 3200428:	0100c974 	movhi	r4,805
 320042c:	21306504 	addi	r4,r4,-15980
 3200430:	01400044 	movi	r5,1
 3200434:	01801244 	movi	r6,73
 3200438:	3205cac0 	call	3205cac <fwrite>
"Attempted to access a resource with no match for the required data type.\n");
         break;
 320043c:	00008606 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_PEVENT_NULL:
         fprintf(stderr, "Attempting to access a resource pointing to NULL\n");
 3200440:	0080c974 	movhi	r2,805
 3200444:	10897804 	addi	r2,r2,9696
 3200448:	10800017 	ldw	r2,0(r2)
 320044c:	11c00317 	ldw	r7,12(r2)
 3200450:	0100c974 	movhi	r4,805
 3200454:	21307804 	addi	r4,r4,-15904
 3200458:	01400044 	movi	r5,1
 320045c:	01800c44 	movi	r6,49
 3200460:	3205cac0 	call	3205cac <fwrite>
         break;
 3200464:	00007c06 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_POST_NULL_PTR:
         fault_level = TASK;
 3200468:	00800044 	movi	r2,1
 320046c:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, "Attempted to Post a NULL to a resource. \n");
 3200470:	0080c974 	movhi	r2,805
 3200474:	10897804 	addi	r2,r2,9696
 3200478:	10800017 	ldw	r2,0(r2)
 320047c:	11c00317 	ldw	r7,12(r2)
 3200480:	0100c974 	movhi	r4,805
 3200484:	21308504 	addi	r4,r4,-15852
 3200488:	01400044 	movi	r5,1
 320048c:	01800a44 	movi	r6,41
 3200490:	3205cac0 	call	3205cac <fwrite>
         break;
 3200494:	00007006 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TIMEOUT:
         fault_level = NONE;
 3200498:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Resource not received in specified time\n");
 320049c:	0080c974 	movhi	r2,805
 32004a0:	10897804 	addi	r2,r2,9696
 32004a4:	10800017 	ldw	r2,0(r2)
 32004a8:	11c00317 	ldw	r7,12(r2)
 32004ac:	0100c974 	movhi	r4,805
 32004b0:	21309004 	addi	r4,r4,-15808
 32004b4:	01400044 	movi	r5,1
 32004b8:	01800a04 	movi	r6,40
 32004bc:	3205cac0 	call	3205cac <fwrite>
         break;
 32004c0:	00006506 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_PEND_ISR:
         fprintf(stderr, "Attempting to pend for a resource in an ISR\n");
 32004c4:	0080c974 	movhi	r2,805
 32004c8:	10897804 	addi	r2,r2,9696
 32004cc:	10800017 	ldw	r2,0(r2)
 32004d0:	11c00317 	ldw	r7,12(r2)
 32004d4:	0100c974 	movhi	r4,805
 32004d8:	21309b04 	addi	r4,r4,-15764
 32004dc:	01400044 	movi	r5,1
 32004e0:	01800b04 	movi	r6,44
 32004e4:	3205cac0 	call	3205cac <fwrite>
         break;
 32004e8:	00005b06 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_IDLE:
         fprintf(stderr, "Attempted to delete the IDLE task\n");
 32004ec:	0080c974 	movhi	r2,805
 32004f0:	10897804 	addi	r2,r2,9696
 32004f4:	10800017 	ldw	r2,0(r2)
 32004f8:	11c00317 	ldw	r7,12(r2)
 32004fc:	0100c974 	movhi	r4,805
 3200500:	2130a704 	addi	r4,r4,-15716
 3200504:	01400044 	movi	r5,1
 3200508:	01800884 	movi	r6,34
 320050c:	3205cac0 	call	3205cac <fwrite>
         break;
 3200510:	00005106 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_ERR:
         fault_level = NONE;
 3200514:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted to delete a task that does not exist\n");
 3200518:	0080c974 	movhi	r2,805
 320051c:	10897804 	addi	r2,r2,9696
 3200520:	10800017 	ldw	r2,0(r2)
 3200524:	11c00317 	ldw	r7,12(r2)
 3200528:	0100c974 	movhi	r4,805
 320052c:	2130b004 	addi	r4,r4,-15680
 3200530:	01400044 	movi	r5,1
 3200534:	01800bc4 	movi	r6,47
 3200538:	3205cac0 	call	3205cac <fwrite>
         break;
 320053c:	00004606 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_ISR:
         fprintf(stderr, "Attempted to delete a task from an ISR\n");
 3200540:	0080c974 	movhi	r2,805
 3200544:	10897804 	addi	r2,r2,9696
 3200548:	10800017 	ldw	r2,0(r2)
 320054c:	11c00317 	ldw	r7,12(r2)
 3200550:	0100c974 	movhi	r4,805
 3200554:	2130bc04 	addi	r4,r4,-15632
 3200558:	01400044 	movi	r5,1
 320055c:	018009c4 	movi	r6,39
 3200560:	3205cac0 	call	3205cac <fwrite>
         break;
 3200564:	00003c06 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_Q_FULL:
         fault_level = NONE;
 3200568:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted to post to a full message queue\n");
 320056c:	0080c974 	movhi	r2,805
 3200570:	10897804 	addi	r2,r2,9696
 3200574:	10800017 	ldw	r2,0(r2)
 3200578:	11c00317 	ldw	r7,12(r2)
 320057c:	0100c974 	movhi	r4,805
 3200580:	2130c604 	addi	r4,r4,-15592
 3200584:	01400044 	movi	r5,1
 3200588:	01800a84 	movi	r6,42
 320058c:	3205cac0 	call	3205cac <fwrite>
         break;
 3200590:	00003106 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_NOT_MUTEX_OWNER:
         fault_level = TASK;
 3200594:	00800044 	movi	r2,1
 3200598:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, "Attempted to post a mutex not owned by the task\n");
 320059c:	0080c974 	movhi	r2,805
 32005a0:	10897804 	addi	r2,r2,9696
 32005a4:	10800017 	ldw	r2,0(r2)
 32005a8:	11c00317 	ldw	r7,12(r2)
 32005ac:	0100c974 	movhi	r4,805
 32005b0:	2130d104 	addi	r4,r4,-15548
 32005b4:	01400044 	movi	r5,1
 32005b8:	01800c04 	movi	r6,48
 32005bc:	3205cac0 	call	3205cac <fwrite>
         break;
 32005c0:	00002506 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 32005c4:	00800084 	movi	r2,2
 32005c8:	e0bffb15 	stw	r2,-20(fp)
         printf(
 32005cc:	0100c974 	movhi	r4,805
 32005d0:	2130de04 	addi	r4,r4,-15496
 32005d4:	3206adc0 	call	3206adc <printf>
"\n[MicroC/OS-II]: See STDERR for expanded diagnosis translation.");    
         fprintf(stderr, "\n[MicroC/OS-II]: Expanded Diagnosis: %s.", 
 32005d8:	0080c974 	movhi	r2,805
 32005dc:	10897804 	addi	r2,r2,9696
 32005e0:	10800017 	ldw	r2,0(r2)
 32005e4:	11000317 	ldw	r4,12(r2)
 32005e8:	e1bffd17 	ldw	r6,-12(fp)
 32005ec:	0140c974 	movhi	r5,805
 32005f0:	2970ee04 	addi	r5,r5,-15432
 32005f4:	3204bf00 	call	3204bf0 <fprintf>
                 (char *)expanded_diagnosis_ptr);
         break;           
 32005f8:	00001706 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      default:
         printf("\n[MicroC/OS-II]: (Not a MicroC/OS-II error) See STDERR.\n");    
 32005fc:	0100c974 	movhi	r4,805
 3200600:	2130f904 	addi	r4,r4,-15388
 3200604:	3206e040 	call	3206e04 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]:");
 3200608:	0080c974 	movhi	r2,805
 320060c:	10897804 	addi	r2,r2,9696
 3200610:	10800017 	ldw	r2,0(r2)
 3200614:	11c00317 	ldw	r7,12(r2)
 3200618:	0100c974 	movhi	r4,805
 320061c:	21310704 	addi	r4,r4,-15332
 3200620:	01400044 	movi	r5,1
 3200624:	01800404 	movi	r6,16
 3200628:	3205cac0 	call	3205cac <fwrite>
         fprintf(stderr, "\nError_code %d.\n", error_code);
 320062c:	0080c974 	movhi	r2,805
 3200630:	10897804 	addi	r2,r2,9696
 3200634:	10800017 	ldw	r2,0(r2)
 3200638:	11000317 	ldw	r4,12(r2)
 320063c:	e1bffc03 	ldbu	r6,-16(fp)
 3200640:	0140c974 	movhi	r5,805
 3200644:	29710c04 	addi	r5,r5,-15312
 3200648:	3204bf00 	call	3204bf0 <fprintf>
         perror("\n[MicroC/OS-II]: (Not a MicroC/OS-II error), ERRNO: ");
 320064c:	0100c974 	movhi	r4,805
 3200650:	21311104 	addi	r4,r4,-15292
 3200654:	3206ac80 	call	3206ac8 <perror>

   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */  
   switch (fault_level) {
 3200658:	e0bffb17 	ldw	r2,-20(fp)
 320065c:	e0bfff15 	stw	r2,-4(fp)
 3200660:	e0ffff17 	ldw	r3,-4(fp)
 3200664:	18800060 	cmpeqi	r2,r3,1
 3200668:	1000071e 	bne	r2,zero,3200688 <alt_uCOSIIErrorHandler+0x47c>
 320066c:	e0ffff17 	ldw	r3,-4(fp)
 3200670:	18800070 	cmpltui	r2,r3,1
 3200674:	10003f1e 	bne	r2,zero,3200774 <alt_uCOSIIErrorHandler+0x568>
 3200678:	e0ffff17 	ldw	r3,-4(fp)
 320067c:	188000a0 	cmpeqi	r2,r3,2
 3200680:	10001d1e 	bne	r2,zero,32006f8 <alt_uCOSIIErrorHandler+0x4ec>
 3200684:	00005806 	br	32007e8 <alt_uCOSIIErrorHandler+0x5dc>
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is TASK).");
 3200688:	0100c974 	movhi	r4,805
 320068c:	21311f04 	addi	r4,r4,-15236
 3200690:	3206adc0 	call	3206adc <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is TASK");
 3200694:	0080c974 	movhi	r2,805
 3200698:	10897804 	addi	r2,r2,9696
 320069c:	10800017 	ldw	r2,0(r2)
 32006a0:	11c00317 	ldw	r7,12(r2)
 32006a4:	0100c974 	movhi	r4,805
 32006a8:	21312c04 	addi	r4,r4,-15184
 32006ac:	01400044 	movi	r5,1
 32006b0:	01800904 	movi	r6,36
 32006b4:	3205cac0 	call	3205cac <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Task is being deleted.\n");
 32006b8:	0080c974 	movhi	r2,805
 32006bc:	10897804 	addi	r2,r2,9696
 32006c0:	10800017 	ldw	r2,0(r2)
 32006c4:	11c00317 	ldw	r7,12(r2)
 32006c8:	0100c974 	movhi	r4,805
 32006cc:	21313604 	addi	r4,r4,-15144
 32006d0:	01400044 	movi	r5,1
 32006d4:	01800a04 	movi	r6,40
 32006d8:	3205cac0 	call	3205cac <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 32006dc:	3215dc80 	call	3215dc8 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 32006e0:	01003fc4 	movi	r4,255
 32006e4:	321be800 	call	321be80 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 32006e8:	e13ffc03 	ldbu	r4,-16(fp)
 32006ec:	000b883a 	mov	r5,zero
 32006f0:	320020c0 	call	320020c <alt_uCOSIIErrorHandler>
         break;
 32006f4:	00004806 	br	3200818 <alt_uCOSIIErrorHandler+0x60c>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 32006f8:	0100c974 	movhi	r4,805
 32006fc:	21314104 	addi	r4,r4,-15100
 3200700:	3206adc0 	call	3206adc <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is SYSTEM");
 3200704:	0080c974 	movhi	r2,805
 3200708:	10897804 	addi	r2,r2,9696
 320070c:	10800017 	ldw	r2,0(r2)
 3200710:	11c00317 	ldw	r7,12(r2)
 3200714:	0100c974 	movhi	r4,805
 3200718:	21314f04 	addi	r4,r4,-15044
 320071c:	01400044 	movi	r5,1
 3200720:	01800984 	movi	r6,38
 3200724:	3205cac0 	call	3205cac <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: FATAL Error, Restart required.");
 3200728:	0080c974 	movhi	r2,805
 320072c:	10897804 	addi	r2,r2,9696
 3200730:	10800017 	ldw	r2,0(r2)
 3200734:	11c00317 	ldw	r7,12(r2)
 3200738:	0100c974 	movhi	r4,805
 320073c:	21315904 	addi	r4,r4,-15004
 3200740:	01400044 	movi	r5,1
 3200744:	01800bc4 	movi	r6,47
 3200748:	3205cac0 	call	3205cac <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Locking scheduler - endless loop.\n");
 320074c:	0080c974 	movhi	r2,805
 3200750:	10897804 	addi	r2,r2,9696
 3200754:	10800017 	ldw	r2,0(r2)
 3200758:	11c00317 	ldw	r7,12(r2)
 320075c:	0100c974 	movhi	r4,805
 3200760:	21316504 	addi	r4,r4,-14956
 3200764:	01400044 	movi	r5,1
 3200768:	01800cc4 	movi	r6,51
 320076c:	3205cac0 	call	3205cac <fwrite>
         while(1); /* Since scheduler is locked,loop halts all task activity.*/
 3200770:	003fff06 	br	3200770 <alt_uCOSIIErrorHandler+0x564>
         break;
      case NONE:
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is NONE");
 3200774:	0080c974 	movhi	r2,805
 3200778:	10897804 	addi	r2,r2,9696
 320077c:	10800017 	ldw	r2,0(r2)
 3200780:	11c00317 	ldw	r7,12(r2)
 3200784:	0100c974 	movhi	r4,805
 3200788:	21317204 	addi	r4,r4,-14904
 320078c:	01400044 	movi	r5,1
 3200790:	01800904 	movi	r6,36
 3200794:	3205cac0 	call	3205cac <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Informational error only, control"); 
 3200798:	0080c974 	movhi	r2,805
 320079c:	10897804 	addi	r2,r2,9696
 32007a0:	10800017 	ldw	r2,0(r2)
 32007a4:	11c00317 	ldw	r7,12(r2)
 32007a8:	0100c974 	movhi	r4,805
 32007ac:	21317c04 	addi	r4,r4,-14864
 32007b0:	01400044 	movi	r5,1
 32007b4:	01800c84 	movi	r6,50
 32007b8:	3205cac0 	call	3205cac <fwrite>
         fprintf(stderr, 
 32007bc:	0080c974 	movhi	r2,805
 32007c0:	10897804 	addi	r2,r2,9696
 32007c4:	10800017 	ldw	r2,0(r2)
 32007c8:	11c00317 	ldw	r7,12(r2)
 32007cc:	0100c974 	movhi	r4,805
 32007d0:	21318904 	addi	r4,r4,-14812
 32007d4:	01400044 	movi	r5,1
 32007d8:	01800f84 	movi	r6,62
 32007dc:	3205cac0 	call	3205cac <fwrite>
            "returned to task to complete processing at application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */
 32007e0:	3215dc80 	call	3215dc8 <OSSchedUnlock>
         return;   
 32007e4:	00000d06 	br	320081c <alt_uCOSIIErrorHandler+0x610>
         break;      
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
 32007e8:	0100c974 	movhi	r4,805
 32007ec:	21319904 	addi	r4,r4,-14748
 32007f0:	3206e040 	call	3206e04 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
 32007f4:	0080c974 	movhi	r2,805
 32007f8:	10897804 	addi	r2,r2,9696
 32007fc:	10800017 	ldw	r2,0(r2)
 3200800:	11c00317 	ldw	r7,12(r2)
 3200804:	0100c974 	movhi	r4,805
 3200808:	2131a704 	addi	r4,r4,-14692
 320080c:	01400044 	movi	r5,1
 3200810:	01800ac4 	movi	r6,43
 3200814:	3205cac0 	call	3205cac <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 3200818:	003fff06 	br	3200818 <alt_uCOSIIErrorHandler+0x60c>
}
 320081c:	e037883a 	mov	sp,fp
 3200820:	dfc00117 	ldw	ra,4(sp)
 3200824:	df000017 	ldw	fp,0(sp)
 3200828:	dec00204 	addi	sp,sp,8
 320082c:	f800283a 	ret

03200830 <alt_NetworkErrorHandler>:

void alt_NetworkErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 3200830:	defffa04 	addi	sp,sp,-24
 3200834:	dfc00515 	stw	ra,20(sp)
 3200838:	df000415 	stw	fp,16(sp)
 320083c:	df000404 	addi	fp,sp,16
 3200840:	e17ffe15 	stw	r5,-8(fp)
 3200844:	e13ffd05 	stb	r4,-12(fp)
   FAULT_LEVEL fault_level;

   if(error_code == OS_NO_ERR)
 3200848:	e0bffd03 	ldbu	r2,-12(fp)
 320084c:	1005003a 	cmpeq	r2,r2,zero
 3200850:	1000981e 	bne	r2,zero,3200ab4 <alt_NetworkErrorHandler+0x284>
   {
      return;
   }

   fault_level = SYSTEM;   
 3200854:	00800084 	movi	r2,2
 3200858:	e0bffc15 	stw	r2,-16(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */  
 320085c:	3215d3c0 	call	3215d3c <OSSchedLock>

   if (error_code == EXPANDED_DIAGNOSIS_CODE) 
 3200860:	e0bffd03 	ldbu	r2,-12(fp)
 3200864:	10803fd8 	cmpnei	r2,r2,255
 3200868:	1000111e 	bne	r2,zero,32008b0 <alt_NetworkErrorHandler+0x80>
   {
      fault_level = SYSTEM;
 320086c:	00800084 	movi	r2,2
 3200870:	e0bffc15 	stw	r2,-16(fp)
      printf("\n[Network]: See STDERR for expanded diagnosis translation.");    
 3200874:	0100c974 	movhi	r4,805
 3200878:	2131b204 	addi	r4,r4,-14648
 320087c:	3206adc0 	call	3206adc <printf>
      fprintf(stderr, "\n[Network]: %s", (char *)expanded_diagnosis_ptr);
 3200880:	0080c974 	movhi	r2,805
 3200884:	10897804 	addi	r2,r2,9696
 3200888:	10800017 	ldw	r2,0(r2)
 320088c:	11000317 	ldw	r4,12(r2)
 3200890:	e1bffe17 	ldw	r6,-8(fp)
 3200894:	0140c974 	movhi	r5,805
 3200898:	2971c104 	addi	r5,r5,-14588
 320089c:	3204bf00 	call	3204bf0 <fprintf>
      /* Check errno also in case it has been set. */
      perror("\n[Network]:  ERRNO: ");
 32008a0:	0100c974 	movhi	r4,805
 32008a4:	2131c504 	addi	r4,r4,-14572
 32008a8:	3206ac80 	call	3206ac8 <perror>
 32008ac:	00001006 	br	32008f0 <alt_NetworkErrorHandler+0xc0>
   }
   else 
   {
      fault_level = TASK;
 32008b0:	00800044 	movi	r2,1
 32008b4:	e0bffc15 	stw	r2,-16(fp)
      printf("\n[Network]: See STDERR.\n");    
 32008b8:	0100c974 	movhi	r4,805
 32008bc:	2131cb04 	addi	r4,r4,-14548
 32008c0:	3206e040 	call	3206e04 <puts>
      fprintf(stderr, "\n[Network]: Error_code %d!\n", error_code);        
 32008c4:	0080c974 	movhi	r2,805
 32008c8:	10897804 	addi	r2,r2,9696
 32008cc:	10800017 	ldw	r2,0(r2)
 32008d0:	11000317 	ldw	r4,12(r2)
 32008d4:	e1bffd03 	ldbu	r6,-12(fp)
 32008d8:	0140c974 	movhi	r5,805
 32008dc:	2971d104 	addi	r5,r5,-14524
 32008e0:	3204bf00 	call	3204bf0 <fprintf>
      perror("\n[Network]:  ERRNO: ");
 32008e4:	0100c974 	movhi	r4,805
 32008e8:	2131c504 	addi	r4,r4,-14572
 32008ec:	3206ac80 	call	3206ac8 <perror>
   }

   /* Process error based on fault level, reenable scheduler if appropriate. */     
   switch (fault_level) 
 32008f0:	e0bffc17 	ldw	r2,-16(fp)
 32008f4:	e0bfff15 	stw	r2,-4(fp)
 32008f8:	e0ffff17 	ldw	r3,-4(fp)
 32008fc:	18800060 	cmpeqi	r2,r3,1
 3200900:	1000071e 	bne	r2,zero,3200920 <alt_NetworkErrorHandler+0xf0>
 3200904:	e0ffff17 	ldw	r3,-4(fp)
 3200908:	18800070 	cmpltui	r2,r3,1
 320090c:	10003f1e 	bne	r2,zero,3200a0c <alt_NetworkErrorHandler+0x1dc>
 3200910:	e0ffff17 	ldw	r3,-4(fp)
 3200914:	188000a0 	cmpeqi	r2,r3,2
 3200918:	10001d1e 	bne	r2,zero,3200990 <alt_NetworkErrorHandler+0x160>
 320091c:	00005806 	br	3200a80 <alt_NetworkErrorHandler+0x250>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is TASK).");
 3200920:	0100c974 	movhi	r4,805
 3200924:	2131d804 	addi	r4,r4,-14496
 3200928:	3206adc0 	call	3206adc <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is TASK");
 320092c:	0080c974 	movhi	r2,805
 3200930:	10897804 	addi	r2,r2,9696
 3200934:	10800017 	ldw	r2,0(r2)
 3200938:	11c00317 	ldw	r7,12(r2)
 320093c:	0100c974 	movhi	r4,805
 3200940:	2131e404 	addi	r4,r4,-14448
 3200944:	01400044 	movi	r5,1
 3200948:	018007c4 	movi	r6,31
 320094c:	3205cac0 	call	3205cac <fwrite>
         fprintf(stderr, "\n[Network]: Task is being deleted.\n");
 3200950:	0080c974 	movhi	r2,805
 3200954:	10897804 	addi	r2,r2,9696
 3200958:	10800017 	ldw	r2,0(r2)
 320095c:	11c00317 	ldw	r7,12(r2)
 3200960:	0100c974 	movhi	r4,805
 3200964:	2131ec04 	addi	r4,r4,-14416
 3200968:	01400044 	movi	r5,1
 320096c:	018008c4 	movi	r6,35
 3200970:	3205cac0 	call	3205cac <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 3200974:	3215dc80 	call	3215dc8 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 3200978:	01003fc4 	movi	r4,255
 320097c:	321be800 	call	321be80 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 3200980:	e13ffd03 	ldbu	r4,-12(fp)
 3200984:	000b883a 	mov	r5,zero
 3200988:	320020c0 	call	320020c <alt_uCOSIIErrorHandler>
         break;
 320098c:	00004806 	br	3200ab0 <alt_NetworkErrorHandler+0x280>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 3200990:	0100c974 	movhi	r4,805
 3200994:	2131f504 	addi	r4,r4,-14380
 3200998:	3206adc0 	call	3206adc <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is SYSTEM.");
 320099c:	0080c974 	movhi	r2,805
 32009a0:	10897804 	addi	r2,r2,9696
 32009a4:	10800017 	ldw	r2,0(r2)
 32009a8:	11c00317 	ldw	r7,12(r2)
 32009ac:	0100c974 	movhi	r4,805
 32009b0:	21320104 	addi	r4,r4,-14332
 32009b4:	01400044 	movi	r5,1
 32009b8:	01800884 	movi	r6,34
 32009bc:	3205cac0 	call	3205cac <fwrite>
         fprintf(stderr, "\n[Network]: FATAL Error, Restart required.");
 32009c0:	0080c974 	movhi	r2,805
 32009c4:	10897804 	addi	r2,r2,9696
 32009c8:	10800017 	ldw	r2,0(r2)
 32009cc:	11c00317 	ldw	r7,12(r2)
 32009d0:	0100c974 	movhi	r4,805
 32009d4:	21320a04 	addi	r4,r4,-14296
 32009d8:	01400044 	movi	r5,1
 32009dc:	01800a84 	movi	r6,42
 32009e0:	3205cac0 	call	3205cac <fwrite>
         fprintf(stderr, "\n[Network]: Locking scheduler - endless loop.\n");
 32009e4:	0080c974 	movhi	r2,805
 32009e8:	10897804 	addi	r2,r2,9696
 32009ec:	10800017 	ldw	r2,0(r2)
 32009f0:	11c00317 	ldw	r7,12(r2)
 32009f4:	0100c974 	movhi	r4,805
 32009f8:	21321504 	addi	r4,r4,-14252
 32009fc:	01400044 	movi	r5,1
 3200a00:	01800b84 	movi	r6,46
 3200a04:	3205cac0 	call	3205cac <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 3200a08:	003fff06 	br	3200a08 <alt_NetworkErrorHandler+0x1d8>
         break;
      case NONE:
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is NONE.");
 3200a0c:	0080c974 	movhi	r2,805
 3200a10:	10897804 	addi	r2,r2,9696
 3200a14:	10800017 	ldw	r2,0(r2)
 3200a18:	11c00317 	ldw	r7,12(r2)
 3200a1c:	0100c974 	movhi	r4,805
 3200a20:	21322104 	addi	r4,r4,-14204
 3200a24:	01400044 	movi	r5,1
 3200a28:	01800804 	movi	r6,32
 3200a2c:	3205cac0 	call	3205cac <fwrite>
         fprintf(stderr, "\n[Network]: Informational "
 3200a30:	0080c974 	movhi	r2,805
 3200a34:	10897804 	addi	r2,r2,9696
 3200a38:	10800017 	ldw	r2,0(r2)
 3200a3c:	11c00317 	ldw	r7,12(r2)
 3200a40:	0100c974 	movhi	r4,805
 3200a44:	21322a04 	addi	r4,r4,-14168
 3200a48:	01400044 	movi	r5,1
 3200a4c:	01800d84 	movi	r6,54
 3200a50:	3205cac0 	call	3205cac <fwrite>
                         "error only, control returned");
         fprintf(stderr, 
 3200a54:	0080c974 	movhi	r2,805
 3200a58:	10897804 	addi	r2,r2,9696
 3200a5c:	10800017 	ldw	r2,0(r2)
 3200a60:	11c00317 	ldw	r7,12(r2)
 3200a64:	0100c974 	movhi	r4,805
 3200a68:	21323804 	addi	r4,r4,-14112
 3200a6c:	01400044 	movi	r5,1
 3200a70:	01800e44 	movi	r6,57
 3200a74:	3205cac0 	call	3205cac <fwrite>
            "to task to complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 3200a78:	3215dc80 	call	3215dc8 <OSSchedUnlock>
         return;
 3200a7c:	00000d06 	br	3200ab4 <alt_NetworkErrorHandler+0x284>
         break;         
      default:
         printf("\n[Network]: See STDERR (FAULT_LEVEL is unknown).\n");    
 3200a80:	0100c974 	movhi	r4,805
 3200a84:	21324704 	addi	r4,r4,-14052
 3200a88:	3206e040 	call	3206e04 <puts>
         fprintf(stderr, "\n[Network] FAULT_LEVEL is unknown !?!\n");
 3200a8c:	0080c974 	movhi	r2,805
 3200a90:	10897804 	addi	r2,r2,9696
 3200a94:	10800017 	ldw	r2,0(r2)
 3200a98:	11c00317 	ldw	r7,12(r2)
 3200a9c:	0100c974 	movhi	r4,805
 3200aa0:	21325404 	addi	r4,r4,-14000
 3200aa4:	01400044 	movi	r5,1
 3200aa8:	01800984 	movi	r6,38
 3200aac:	3205cac0 	call	3205cac <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 3200ab0:	003fff06 	br	3200ab0 <alt_NetworkErrorHandler+0x280>
}
 3200ab4:	e037883a 	mov	sp,fp
 3200ab8:	dfc00117 	ldw	ra,4(sp)
 3200abc:	df000017 	ldw	fp,0(sp)
 3200ac0:	dec00204 	addi	sp,sp,8
 3200ac4:	f800283a 	ret

03200ac8 <alt_SSSErrorHandler>:
   
   
void alt_SSSErrorHandler(INT8U error_code, 
                         void *expanded_diagnosis_ptr)
{
 3200ac8:	defff804 	addi	sp,sp,-32
 3200acc:	dfc00715 	stw	ra,28(sp)
 3200ad0:	df000615 	stw	fp,24(sp)
 3200ad4:	df000604 	addi	fp,sp,24
 3200ad8:	e17ffc15 	stw	r5,-16(fp)
 3200adc:	e13ffb05 	stb	r4,-20(fp)
   FAULT_LEVEL fault_level;
   
   if   (error_code == OS_NO_ERR)
 3200ae0:	e0bffb03 	ldbu	r2,-20(fp)
 3200ae4:	1005003a 	cmpeq	r2,r2,zero
 3200ae8:	1000ad1e 	bne	r2,zero,3200da0 <alt_SSSErrorHandler+0x2d8>
   {
      return;
   }

   fault_level = (error_code == OS_NO_ERR) ? NONE : SYSTEM;
 3200aec:	e0bffb03 	ldbu	r2,-20(fp)
 3200af0:	1004c03a 	cmpne	r2,r2,zero
 3200af4:	1000021e 	bne	r2,zero,3200b00 <alt_SSSErrorHandler+0x38>
 3200af8:	e03ffe15 	stw	zero,-8(fp)
 3200afc:	00000206 	br	3200b08 <alt_SSSErrorHandler+0x40>
 3200b00:	00800084 	movi	r2,2
 3200b04:	e0bffe15 	stw	r2,-8(fp)
 3200b08:	e0fffe17 	ldw	r3,-8(fp)
 3200b0c:	e0fffa15 	stw	r3,-24(fp)
   
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 3200b10:	3215d3c0 	call	3215d3c <OSSchedLock>
   switch (error_code)
 3200b14:	e0bffb03 	ldbu	r2,-20(fp)
 3200b18:	e0bffd15 	stw	r2,-12(fp)
 3200b1c:	e0fffd17 	ldw	r3,-12(fp)
 3200b20:	188007a0 	cmpeqi	r2,r3,30
 3200b24:	1000121e 	bne	r2,zero,3200b70 <alt_SSSErrorHandler+0xa8>
 3200b28:	e0fffd17 	ldw	r3,-12(fp)
 3200b2c:	18803fe0 	cmpeqi	r2,r3,255
 3200b30:	1000011e 	bne	r2,zero,3200b38 <alt_SSSErrorHandler+0x70>
 3200b34:	00001906 	br	3200b9c <alt_SSSErrorHandler+0xd4>
   {
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 3200b38:	00800084 	movi	r2,2
 3200b3c:	e0bffa15 	stw	r2,-24(fp)
         printf("\n[SSS]: See STDERR for expanded diagnosis translation.");    
 3200b40:	0100c974 	movhi	r4,805
 3200b44:	21325e04 	addi	r4,r4,-13960
 3200b48:	3206adc0 	call	3206adc <printf>
         fprintf(stderr, "\n[SSS]: %s", (char *)expanded_diagnosis_ptr);
 3200b4c:	0080c974 	movhi	r2,805
 3200b50:	10897804 	addi	r2,r2,9696
 3200b54:	10800017 	ldw	r2,0(r2)
 3200b58:	11000317 	ldw	r4,12(r2)
 3200b5c:	e1bffc17 	ldw	r6,-16(fp)
 3200b60:	0140c974 	movhi	r5,805
 3200b64:	29726c04 	addi	r5,r5,-13904
 3200b68:	3204bf00 	call	3204bf0 <fprintf>
         break;
 3200b6c:	00001b06 	br	3200bdc <alt_SSSErrorHandler+0x114>
         
      case OS_Q_FULL:
         fault_level = NONE;
 3200b70:	e03ffa15 	stw	zero,-24(fp)
         fprintf(stderr,"\n[SSS]: Attempted to post to a full message queue.");
 3200b74:	0080c974 	movhi	r2,805
 3200b78:	10897804 	addi	r2,r2,9696
 3200b7c:	10800017 	ldw	r2,0(r2)
 3200b80:	11c00317 	ldw	r7,12(r2)
 3200b84:	0100c974 	movhi	r4,805
 3200b88:	21326f04 	addi	r4,r4,-13892
 3200b8c:	01400044 	movi	r5,1
 3200b90:	01800c84 	movi	r6,50
 3200b94:	3205cac0 	call	3205cac <fwrite>
         break;
 3200b98:	00001006 	br	3200bdc <alt_SSSErrorHandler+0x114>
      
      default:
         fault_level = SYSTEM;
 3200b9c:	00800084 	movi	r2,2
 3200ba0:	e0bffa15 	stw	r2,-24(fp)
         printf("\n[SSS]: See STDERR.\n");    
 3200ba4:	0100c974 	movhi	r4,805
 3200ba8:	21327c04 	addi	r4,r4,-13840
 3200bac:	3206e040 	call	3206e04 <puts>
         fprintf(stderr, "\n[SSS]: Error_code %d!", error_code);        
 3200bb0:	0080c974 	movhi	r2,805
 3200bb4:	10897804 	addi	r2,r2,9696
 3200bb8:	10800017 	ldw	r2,0(r2)
 3200bbc:	11000317 	ldw	r4,12(r2)
 3200bc0:	e1bffb03 	ldbu	r6,-20(fp)
 3200bc4:	0140c974 	movhi	r5,805
 3200bc8:	29728104 	addi	r5,r5,-13820
 3200bcc:	3204bf00 	call	3204bf0 <fprintf>
         perror("\n[SSS]:  ERRNO: ");
 3200bd0:	0100c974 	movhi	r4,805
 3200bd4:	21328704 	addi	r4,r4,-13796
 3200bd8:	3206ac80 	call	3206ac8 <perror>
   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */     
   switch (fault_level) 
 3200bdc:	e0bffa17 	ldw	r2,-24(fp)
 3200be0:	e0bfff15 	stw	r2,-4(fp)
 3200be4:	e0ffff17 	ldw	r3,-4(fp)
 3200be8:	18800060 	cmpeqi	r2,r3,1
 3200bec:	1000071e 	bne	r2,zero,3200c0c <alt_SSSErrorHandler+0x144>
 3200bf0:	e0ffff17 	ldw	r3,-4(fp)
 3200bf4:	18800070 	cmpltui	r2,r3,1
 3200bf8:	10003f1e 	bne	r2,zero,3200cf8 <alt_SSSErrorHandler+0x230>
 3200bfc:	e0ffff17 	ldw	r3,-4(fp)
 3200c00:	188000a0 	cmpeqi	r2,r3,2
 3200c04:	10001d1e 	bne	r2,zero,3200c7c <alt_SSSErrorHandler+0x1b4>
 3200c08:	00005806 	br	3200d6c <alt_SSSErrorHandler+0x2a4>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is TASK).");
 3200c0c:	0100c974 	movhi	r4,805
 3200c10:	21328c04 	addi	r4,r4,-13776
 3200c14:	3206adc0 	call	3206adc <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is TASK");
 3200c18:	0080c974 	movhi	r2,805
 3200c1c:	10897804 	addi	r2,r2,9696
 3200c20:	10800017 	ldw	r2,0(r2)
 3200c24:	11c00317 	ldw	r7,12(r2)
 3200c28:	0100c974 	movhi	r4,805
 3200c2c:	21329704 	addi	r4,r4,-13732
 3200c30:	01400044 	movi	r5,1
 3200c34:	018006c4 	movi	r6,27
 3200c38:	3205cac0 	call	3205cac <fwrite>
         fprintf(stderr, "\n[SSS]: Task is being deleted.\n");
 3200c3c:	0080c974 	movhi	r2,805
 3200c40:	10897804 	addi	r2,r2,9696
 3200c44:	10800017 	ldw	r2,0(r2)
 3200c48:	11c00317 	ldw	r7,12(r2)
 3200c4c:	0100c974 	movhi	r4,805
 3200c50:	21329e04 	addi	r4,r4,-13704
 3200c54:	01400044 	movi	r5,1
 3200c58:	018007c4 	movi	r6,31
 3200c5c:	3205cac0 	call	3205cac <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 3200c60:	3215dc80 	call	3215dc8 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 3200c64:	01003fc4 	movi	r4,255
 3200c68:	321be800 	call	321be80 <OSTaskDel>
         /* Invoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 3200c6c:	e13ffb03 	ldbu	r4,-20(fp)
 3200c70:	000b883a 	mov	r5,zero
 3200c74:	320020c0 	call	320020c <alt_uCOSIIErrorHandler>
         break;
 3200c78:	00004806 	br	3200d9c <alt_SSSErrorHandler+0x2d4>
      case SYSTEM:
          /* Total System Failure, Restart Required */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 3200c7c:	0100c974 	movhi	r4,805
 3200c80:	2132a604 	addi	r4,r4,-13672
 3200c84:	3206adc0 	call	3206adc <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is SYSTEM.");
 3200c88:	0080c974 	movhi	r2,805
 3200c8c:	10897804 	addi	r2,r2,9696
 3200c90:	10800017 	ldw	r2,0(r2)
 3200c94:	11c00317 	ldw	r7,12(r2)
 3200c98:	0100c974 	movhi	r4,805
 3200c9c:	2132b104 	addi	r4,r4,-13628
 3200ca0:	01400044 	movi	r5,1
 3200ca4:	01800784 	movi	r6,30
 3200ca8:	3205cac0 	call	3205cac <fwrite>
         fprintf(stderr, "\n[SSS]: FATAL Error, Restart required.");
 3200cac:	0080c974 	movhi	r2,805
 3200cb0:	10897804 	addi	r2,r2,9696
 3200cb4:	10800017 	ldw	r2,0(r2)
 3200cb8:	11c00317 	ldw	r7,12(r2)
 3200cbc:	0100c974 	movhi	r4,805
 3200cc0:	2132b904 	addi	r4,r4,-13596
 3200cc4:	01400044 	movi	r5,1
 3200cc8:	01800984 	movi	r6,38
 3200ccc:	3205cac0 	call	3205cac <fwrite>
         fprintf(stderr, "\n[SSS]: Locking scheduler - endless loop.\n");
 3200cd0:	0080c974 	movhi	r2,805
 3200cd4:	10897804 	addi	r2,r2,9696
 3200cd8:	10800017 	ldw	r2,0(r2)
 3200cdc:	11c00317 	ldw	r7,12(r2)
 3200ce0:	0100c974 	movhi	r4,805
 3200ce4:	2132c304 	addi	r4,r4,-13556
 3200ce8:	01400044 	movi	r5,1
 3200cec:	01800a84 	movi	r6,42
 3200cf0:	3205cac0 	call	3205cac <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 3200cf4:	003fff06 	br	3200cf4 <alt_SSSErrorHandler+0x22c>
         break;
      case NONE:
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is NONE.");
 3200cf8:	0080c974 	movhi	r2,805
 3200cfc:	10897804 	addi	r2,r2,9696
 3200d00:	10800017 	ldw	r2,0(r2)
 3200d04:	11c00317 	ldw	r7,12(r2)
 3200d08:	0100c974 	movhi	r4,805
 3200d0c:	2132ce04 	addi	r4,r4,-13512
 3200d10:	01400044 	movi	r5,1
 3200d14:	018006c4 	movi	r6,27
 3200d18:	3205cac0 	call	3205cac <fwrite>
         fprintf(stderr, 
 3200d1c:	0080c974 	movhi	r2,805
 3200d20:	10897804 	addi	r2,r2,9696
 3200d24:	10800017 	ldw	r2,0(r2)
 3200d28:	11c00317 	ldw	r7,12(r2)
 3200d2c:	0100c974 	movhi	r4,805
 3200d30:	2132d504 	addi	r4,r4,-13484
 3200d34:	01400044 	movi	r5,1
 3200d38:	01800f44 	movi	r6,61
 3200d3c:	3205cac0 	call	3205cac <fwrite>
            "\n[SSS] Informational error only, control returned to task to ");
         fprintf(stderr,
 3200d40:	0080c974 	movhi	r2,805
 3200d44:	10897804 	addi	r2,r2,9696
 3200d48:	10800017 	ldw	r2,0(r2)
 3200d4c:	11c00317 	ldw	r7,12(r2)
 3200d50:	0100c974 	movhi	r4,805
 3200d54:	2132e504 	addi	r4,r4,-13420
 3200d58:	01400044 	movi	r5,1
 3200d5c:	01800b84 	movi	r6,46
 3200d60:	3205cac0 	call	3205cac <fwrite>
            "complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 3200d64:	3215dc80 	call	3215dc8 <OSSchedUnlock>
         return;         
 3200d68:	00000d06 	br	3200da0 <alt_SSSErrorHandler+0x2d8>
         break;
      default:
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is Unknown).\n");
 3200d6c:	0100c974 	movhi	r4,805
 3200d70:	2132f104 	addi	r4,r4,-13372
 3200d74:	3206e040 	call	3206e04 <puts>
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is unknown!?!\n");
 3200d78:	0080c974 	movhi	r2,805
 3200d7c:	10897804 	addi	r2,r2,9696
 3200d80:	10800017 	ldw	r2,0(r2)
 3200d84:	11c00317 	ldw	r7,12(r2)
 3200d88:	0100c974 	movhi	r4,805
 3200d8c:	2132fd04 	addi	r4,r4,-13324
 3200d90:	01400044 	movi	r5,1
 3200d94:	01800844 	movi	r6,33
 3200d98:	3205cac0 	call	3205cac <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 3200d9c:	003fff06 	br	3200d9c <alt_SSSErrorHandler+0x2d4>
}
 3200da0:	e037883a 	mov	sp,fp
 3200da4:	dfc00117 	ldw	ra,4(sp)
 3200da8:	df000017 	ldw	fp,0(sp)
 3200dac:	dec00204 	addi	sp,sp,8
 3200db0:	f800283a 	ret

03200db4 <camera_init>:

// Creates the camera handler device
CAMERA camera = {CAMERA_BASE};

void camera_init()
{
 3200db4:	defffe04 	addi	sp,sp,-8
 3200db8:	dfc00115 	stw	ra,4(sp)
 3200dbc:	df000015 	stw	fp,0(sp)
 3200dc0:	d839883a 	mov	fp,sp
	IOWR_CAMERA_CONFIGURE(camera.base, 1); // Initialization
 3200dc4:	0080c974 	movhi	r2,805
 3200dc8:	10818a04 	addi	r2,r2,1576
 3200dcc:	10800017 	ldw	r2,0(r2)
 3200dd0:	10800104 	addi	r2,r2,4
 3200dd4:	1007883a 	mov	r3,r2
 3200dd8:	00800044 	movi	r2,1
 3200ddc:	18800035 	stwio	r2,0(r3)
	while (!IORD_CAMERA_READY(camera.base));
 3200de0:	0080c974 	movhi	r2,805
 3200de4:	10818a04 	addi	r2,r2,1576
 3200de8:	10800017 	ldw	r2,0(r2)
 3200dec:	10800104 	addi	r2,r2,4
 3200df0:	10800037 	ldwio	r2,0(r2)
 3200df4:	1005003a 	cmpeq	r2,r2,zero
 3200df8:	103ff91e 	bne	r2,zero,3200de0 <camera_init+0x2c>
	read_camera_registers(&camera);
 3200dfc:	0100c974 	movhi	r4,805
 3200e00:	21018a04 	addi	r4,r4,1576
 3200e04:	3200e1c0 	call	3200e1c <read_camera_registers>
}
 3200e08:	e037883a 	mov	sp,fp
 3200e0c:	dfc00117 	ldw	ra,4(sp)
 3200e10:	df000017 	ldw	fp,0(sp)
 3200e14:	dec00204 	addi	sp,sp,8
 3200e18:	f800283a 	ret

03200e1c <read_camera_registers>:

/* Reads values of camera registers. */
void read_camera_registers(CAMERA *sp)
{
 3200e1c:	defffe04 	addi	sp,sp,-8
 3200e20:	df000115 	stw	fp,4(sp)
 3200e24:	df000104 	addi	fp,sp,4
 3200e28:	e13fff15 	stw	r4,-4(fp)
	sp->width = IORD_CAMERA_WIDTH(sp->base);
 3200e2c:	e0bfff17 	ldw	r2,-4(fp)
 3200e30:	10800017 	ldw	r2,0(r2)
 3200e34:	10800804 	addi	r2,r2,32
 3200e38:	10c00037 	ldwio	r3,0(r2)
 3200e3c:	e0bfff17 	ldw	r2,-4(fp)
 3200e40:	10c00115 	stw	r3,4(r2)
	sp->height = IORD_CAMERA_HEIGHT(sp->base);
 3200e44:	e0bfff17 	ldw	r2,-4(fp)
 3200e48:	10800017 	ldw	r2,0(r2)
 3200e4c:	10800a04 	addi	r2,r2,40
 3200e50:	10c00037 	ldwio	r3,0(r2)
 3200e54:	e0bfff17 	ldw	r2,-4(fp)
 3200e58:	10c00215 	stw	r3,8(r2)
	sp->exposure = IORD_CAMERA_EXPOSURE(sp->base);
 3200e5c:	e0bfff17 	ldw	r2,-4(fp)
 3200e60:	10800017 	ldw	r2,0(r2)
 3200e64:	10801804 	addi	r2,r2,96
 3200e68:	10c00037 	ldwio	r3,0(r2)
 3200e6c:	e0bfff17 	ldw	r2,-4(fp)
 3200e70:	10c00315 	stw	r3,12(r2)
	sp->start_column = IORD_CAMERA_START_COLUMN(sp->base);
 3200e74:	e0bfff17 	ldw	r2,-4(fp)
 3200e78:	10800017 	ldw	r2,0(r2)
 3200e7c:	10800e04 	addi	r2,r2,56
 3200e80:	10c00037 	ldwio	r3,0(r2)
 3200e84:	e0bfff17 	ldw	r2,-4(fp)
 3200e88:	10c00415 	stw	r3,16(r2)
	sp->start_row = IORD_CAMERA_START_ROW(sp->base);
 3200e8c:	e0bfff17 	ldw	r2,-4(fp)
 3200e90:	10800017 	ldw	r2,0(r2)
 3200e94:	10800c04 	addi	r2,r2,48
 3200e98:	10c00037 	ldwio	r3,0(r2)
 3200e9c:	e0bfff17 	ldw	r2,-4(fp)
 3200ea0:	10c00515 	stw	r3,20(r2)
	sp->column_size = IORD_CAMERA_COLUMN_SIZE(sp->base);
 3200ea4:	e0bfff17 	ldw	r2,-4(fp)
 3200ea8:	10800017 	ldw	r2,0(r2)
 3200eac:	10801204 	addi	r2,r2,72
 3200eb0:	10c00037 	ldwio	r3,0(r2)
 3200eb4:	e0bfff17 	ldw	r2,-4(fp)
 3200eb8:	10c00615 	stw	r3,24(r2)
	sp->row_size = IORD_CAMERA_ROW_SIZE(sp->base);
 3200ebc:	e0bfff17 	ldw	r2,-4(fp)
 3200ec0:	10800017 	ldw	r2,0(r2)
 3200ec4:	10801004 	addi	r2,r2,64
 3200ec8:	10c00037 	ldwio	r3,0(r2)
 3200ecc:	e0bfff17 	ldw	r2,-4(fp)
 3200ed0:	10c00715 	stw	r3,28(r2)
	sp->column_mode = IORD_CAMERA_COLUMN_MODE(sp->base);
 3200ed4:	e0bfff17 	ldw	r2,-4(fp)
 3200ed8:	10800017 	ldw	r2,0(r2)
 3200edc:	10801604 	addi	r2,r2,88
 3200ee0:	10c00037 	ldwio	r3,0(r2)
 3200ee4:	e0bfff17 	ldw	r2,-4(fp)
 3200ee8:	10c00815 	stw	r3,32(r2)
	sp->row_mode = IORD_CAMERA_ROW_MODE(sp->base);
 3200eec:	e0bfff17 	ldw	r2,-4(fp)
 3200ef0:	10800017 	ldw	r2,0(r2)
 3200ef4:	10801404 	addi	r2,r2,80
 3200ef8:	10c00037 	ldwio	r3,0(r2)
 3200efc:	e0bfff17 	ldw	r2,-4(fp)
 3200f00:	10c00915 	stw	r3,36(r2)
}
 3200f04:	e037883a 	mov	sp,fp
 3200f08:	df000017 	ldw	fp,0(sp)
 3200f0c:	dec00104 	addi	sp,sp,4
 3200f10:	f800283a 	ret

03200f14 <write_camera_registers>:

/* Writes values of camera registers. */
void write_camera_registers(CAMERA *sp)
{
 3200f14:	defffe04 	addi	sp,sp,-8
 3200f18:	df000115 	stw	fp,4(sp)
 3200f1c:	df000104 	addi	fp,sp,4
 3200f20:	e13fff15 	stw	r4,-4(fp)
	IOWR_CAMERA_WIDTH(sp->base, sp->width);
 3200f24:	e0bfff17 	ldw	r2,-4(fp)
 3200f28:	10800017 	ldw	r2,0(r2)
 3200f2c:	11000804 	addi	r4,r2,32
 3200f30:	e0bfff17 	ldw	r2,-4(fp)
 3200f34:	10c00117 	ldw	r3,4(r2)
 3200f38:	2005883a 	mov	r2,r4
 3200f3c:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_HEIGHT(sp->base, sp->height);
 3200f40:	e0bfff17 	ldw	r2,-4(fp)
 3200f44:	10800017 	ldw	r2,0(r2)
 3200f48:	11000a04 	addi	r4,r2,40
 3200f4c:	e0bfff17 	ldw	r2,-4(fp)
 3200f50:	10c00217 	ldw	r3,8(r2)
 3200f54:	2005883a 	mov	r2,r4
 3200f58:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_EXPOSURE(sp->base, sp->exposure);
 3200f5c:	e0bfff17 	ldw	r2,-4(fp)
 3200f60:	10800017 	ldw	r2,0(r2)
 3200f64:	11001804 	addi	r4,r2,96
 3200f68:	e0bfff17 	ldw	r2,-4(fp)
 3200f6c:	10c00317 	ldw	r3,12(r2)
 3200f70:	2005883a 	mov	r2,r4
 3200f74:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_START_COLUMN(sp->base, sp->start_column);
 3200f78:	e0bfff17 	ldw	r2,-4(fp)
 3200f7c:	10800017 	ldw	r2,0(r2)
 3200f80:	11000e04 	addi	r4,r2,56
 3200f84:	e0bfff17 	ldw	r2,-4(fp)
 3200f88:	10c00417 	ldw	r3,16(r2)
 3200f8c:	2005883a 	mov	r2,r4
 3200f90:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_START_ROW(sp->base, sp->start_row);
 3200f94:	e0bfff17 	ldw	r2,-4(fp)
 3200f98:	10800017 	ldw	r2,0(r2)
 3200f9c:	11000c04 	addi	r4,r2,48
 3200fa0:	e0bfff17 	ldw	r2,-4(fp)
 3200fa4:	10c00517 	ldw	r3,20(r2)
 3200fa8:	2005883a 	mov	r2,r4
 3200fac:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_COLUMN_SIZE(sp->base, sp->column_size);
 3200fb0:	e0bfff17 	ldw	r2,-4(fp)
 3200fb4:	10800017 	ldw	r2,0(r2)
 3200fb8:	11001204 	addi	r4,r2,72
 3200fbc:	e0bfff17 	ldw	r2,-4(fp)
 3200fc0:	10c00617 	ldw	r3,24(r2)
 3200fc4:	2005883a 	mov	r2,r4
 3200fc8:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_ROW_SIZE(sp->base, sp->row_size);
 3200fcc:	e0bfff17 	ldw	r2,-4(fp)
 3200fd0:	10800017 	ldw	r2,0(r2)
 3200fd4:	11001004 	addi	r4,r2,64
 3200fd8:	e0bfff17 	ldw	r2,-4(fp)
 3200fdc:	10c00717 	ldw	r3,28(r2)
 3200fe0:	2005883a 	mov	r2,r4
 3200fe4:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_COLUMN_MODE(sp->base, sp->column_mode);
 3200fe8:	e0bfff17 	ldw	r2,-4(fp)
 3200fec:	10800017 	ldw	r2,0(r2)
 3200ff0:	11001604 	addi	r4,r2,88
 3200ff4:	e0bfff17 	ldw	r2,-4(fp)
 3200ff8:	10c00817 	ldw	r3,32(r2)
 3200ffc:	2005883a 	mov	r2,r4
 3201000:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_ROW_MODE(sp->base, sp->row_mode);
 3201004:	e0bfff17 	ldw	r2,-4(fp)
 3201008:	10800017 	ldw	r2,0(r2)
 320100c:	11001404 	addi	r4,r2,80
 3201010:	e0bfff17 	ldw	r2,-4(fp)
 3201014:	10c00917 	ldw	r3,36(r2)
 3201018:	2005883a 	mov	r2,r4
 320101c:	10c00035 	stwio	r3,0(r2)
}
 3201020:	e037883a 	mov	sp,fp
 3201024:	df000017 	ldw	fp,0(sp)
 3201028:	dec00104 	addi	sp,sp,4
 320102c:	f800283a 	ret

03201030 <get_image_size>:

int get_image_size(CAMERA *sp, char *char_buffer)
{
 3201030:	defffb04 	addi	sp,sp,-20
 3201034:	dfc00415 	stw	ra,16(sp)
 3201038:	df000315 	stw	fp,12(sp)
 320103c:	df000304 	addi	fp,sp,12
 3201040:	e13ffe15 	stw	r4,-8(fp)
 3201044:	e17fff15 	stw	r5,-4(fp)
	int nchars = 0;
 3201048:	e03ffd15 	stw	zero,-12(fp)
	nchars = sprintf(char_buffer, "(%i,%i)", sp->width, sp->height);
 320104c:	e0bffe17 	ldw	r2,-8(fp)
 3201050:	11800117 	ldw	r6,4(r2)
 3201054:	e0bffe17 	ldw	r2,-8(fp)
 3201058:	11c00217 	ldw	r7,8(r2)
 320105c:	e13fff17 	ldw	r4,-4(fp)
 3201060:	0140c974 	movhi	r5,805
 3201064:	29730604 	addi	r5,r5,-13288
 3201068:	32076bc0 	call	32076bc <sprintf>
 320106c:	e0bffd15 	stw	r2,-12(fp)
	return nchars;
 3201070:	e0bffd17 	ldw	r2,-12(fp)
}
 3201074:	e037883a 	mov	sp,fp
 3201078:	dfc00117 	ldw	ra,4(sp)
 320107c:	df000017 	ldw	fp,0(sp)
 3201080:	dec00204 	addi	sp,sp,8
 3201084:	f800283a 	ret

03201088 <set_image_size>:

int set_image_size(CAMERA *sp, char *char_buffer, int width, int height)
{
 3201088:	defffa04 	addi	sp,sp,-24
 320108c:	dfc00515 	stw	ra,20(sp)
 3201090:	df000415 	stw	fp,16(sp)
 3201094:	df000404 	addi	fp,sp,16
 3201098:	e13ffc15 	stw	r4,-16(fp)
 320109c:	e17ffd15 	stw	r5,-12(fp)
 32010a0:	e1bffe15 	stw	r6,-8(fp)
 32010a4:	e1ffff15 	stw	r7,-4(fp)
	sp->width = width;
 32010a8:	e0fffc17 	ldw	r3,-16(fp)
 32010ac:	e0bffe17 	ldw	r2,-8(fp)
 32010b0:	18800115 	stw	r2,4(r3)
	sp->height = height;
 32010b4:	e0fffc17 	ldw	r3,-16(fp)
 32010b8:	e0bfff17 	ldw	r2,-4(fp)
 32010bc:	18800215 	stw	r2,8(r3)
	return get_image_size(sp, char_buffer);
 32010c0:	e13ffc17 	ldw	r4,-16(fp)
 32010c4:	e17ffd17 	ldw	r5,-12(fp)
 32010c8:	32010300 	call	3201030 <get_image_size>
}
 32010cc:	e037883a 	mov	sp,fp
 32010d0:	dfc00117 	ldw	ra,4(sp)
 32010d4:	df000017 	ldw	fp,0(sp)
 32010d8:	dec00204 	addi	sp,sp,8
 32010dc:	f800283a 	ret

032010e0 <get_image_exposure>:

int get_image_exposure(CAMERA *sp, char *char_buffer)
{
 32010e0:	defffb04 	addi	sp,sp,-20
 32010e4:	dfc00415 	stw	ra,16(sp)
 32010e8:	df000315 	stw	fp,12(sp)
 32010ec:	df000304 	addi	fp,sp,12
 32010f0:	e13ffe15 	stw	r4,-8(fp)
 32010f4:	e17fff15 	stw	r5,-4(fp)
	int nchars = 0;
 32010f8:	e03ffd15 	stw	zero,-12(fp)
	nchars = sprintf(char_buffer, "%i", sp->exposure);
 32010fc:	e0bffe17 	ldw	r2,-8(fp)
 3201100:	11800317 	ldw	r6,12(r2)
 3201104:	e13fff17 	ldw	r4,-4(fp)
 3201108:	0140c974 	movhi	r5,805
 320110c:	29730804 	addi	r5,r5,-13280
 3201110:	32076bc0 	call	32076bc <sprintf>
 3201114:	e0bffd15 	stw	r2,-12(fp)
	return nchars;
 3201118:	e0bffd17 	ldw	r2,-12(fp)
}
 320111c:	e037883a 	mov	sp,fp
 3201120:	dfc00117 	ldw	ra,4(sp)
 3201124:	df000017 	ldw	fp,0(sp)
 3201128:	dec00204 	addi	sp,sp,8
 320112c:	f800283a 	ret

03201130 <set_image_exposure>:

int set_image_exposure(CAMERA *sp, char *char_buffer, int exposure)
{
 3201130:	defffb04 	addi	sp,sp,-20
 3201134:	dfc00415 	stw	ra,16(sp)
 3201138:	df000315 	stw	fp,12(sp)
 320113c:	df000304 	addi	fp,sp,12
 3201140:	e13ffd15 	stw	r4,-12(fp)
 3201144:	e17ffe15 	stw	r5,-8(fp)
 3201148:	e1bfff15 	stw	r6,-4(fp)
	sp->exposure = exposure;
 320114c:	e0fffd17 	ldw	r3,-12(fp)
 3201150:	e0bfff17 	ldw	r2,-4(fp)
 3201154:	18800315 	stw	r2,12(r3)
	return get_image_exposure(sp, char_buffer);
 3201158:	e13ffd17 	ldw	r4,-12(fp)
 320115c:	e17ffe17 	ldw	r5,-8(fp)
 3201160:	32010e00 	call	32010e0 <get_image_exposure>
}
 3201164:	e037883a 	mov	sp,fp
 3201168:	dfc00117 	ldw	ra,4(sp)
 320116c:	df000017 	ldw	fp,0(sp)
 3201170:	dec00204 	addi	sp,sp,8
 3201174:	f800283a 	ret

03201178 <get_start_image>:

int get_start_image(CAMERA *sp, char *char_buffer)
{
 3201178:	defffb04 	addi	sp,sp,-20
 320117c:	dfc00415 	stw	ra,16(sp)
 3201180:	df000315 	stw	fp,12(sp)
 3201184:	df000304 	addi	fp,sp,12
 3201188:	e13ffe15 	stw	r4,-8(fp)
 320118c:	e17fff15 	stw	r5,-4(fp)
	int nchars = 0;
 3201190:	e03ffd15 	stw	zero,-12(fp)
	nchars = sprintf(char_buffer, "(%i,%i)", sp->start_column, sp->start_row);
 3201194:	e0bffe17 	ldw	r2,-8(fp)
 3201198:	11800417 	ldw	r6,16(r2)
 320119c:	e0bffe17 	ldw	r2,-8(fp)
 32011a0:	11c00517 	ldw	r7,20(r2)
 32011a4:	e13fff17 	ldw	r4,-4(fp)
 32011a8:	0140c974 	movhi	r5,805
 32011ac:	29730604 	addi	r5,r5,-13288
 32011b0:	32076bc0 	call	32076bc <sprintf>
 32011b4:	e0bffd15 	stw	r2,-12(fp)
	return nchars;
 32011b8:	e0bffd17 	ldw	r2,-12(fp)
}
 32011bc:	e037883a 	mov	sp,fp
 32011c0:	dfc00117 	ldw	ra,4(sp)
 32011c4:	df000017 	ldw	fp,0(sp)
 32011c8:	dec00204 	addi	sp,sp,8
 32011cc:	f800283a 	ret

032011d0 <set_start_image>:

int set_start_image(CAMERA *sp, char *char_buffer, int start_column, int start_row)
{
 32011d0:	defffa04 	addi	sp,sp,-24
 32011d4:	dfc00515 	stw	ra,20(sp)
 32011d8:	df000415 	stw	fp,16(sp)
 32011dc:	df000404 	addi	fp,sp,16
 32011e0:	e13ffc15 	stw	r4,-16(fp)
 32011e4:	e17ffd15 	stw	r5,-12(fp)
 32011e8:	e1bffe15 	stw	r6,-8(fp)
 32011ec:	e1ffff15 	stw	r7,-4(fp)
	sp->start_column = start_column;
 32011f0:	e0fffc17 	ldw	r3,-16(fp)
 32011f4:	e0bffe17 	ldw	r2,-8(fp)
 32011f8:	18800415 	stw	r2,16(r3)
	sp->start_row = start_row;
 32011fc:	e0fffc17 	ldw	r3,-16(fp)
 3201200:	e0bfff17 	ldw	r2,-4(fp)
 3201204:	18800515 	stw	r2,20(r3)
	return get_start_image(sp, char_buffer);
 3201208:	e13ffc17 	ldw	r4,-16(fp)
 320120c:	e17ffd17 	ldw	r5,-12(fp)
 3201210:	32011780 	call	3201178 <get_start_image>
}
 3201214:	e037883a 	mov	sp,fp
 3201218:	dfc00117 	ldw	ra,4(sp)
 320121c:	df000017 	ldw	fp,0(sp)
 3201220:	dec00204 	addi	sp,sp,8
 3201224:	f800283a 	ret

03201228 <get_sensor_size>:

int get_sensor_size(CAMERA *sp, char *char_buffer)
{
 3201228:	defffb04 	addi	sp,sp,-20
 320122c:	dfc00415 	stw	ra,16(sp)
 3201230:	df000315 	stw	fp,12(sp)
 3201234:	df000304 	addi	fp,sp,12
 3201238:	e13ffe15 	stw	r4,-8(fp)
 320123c:	e17fff15 	stw	r5,-4(fp)
	int nchars = 0;
 3201240:	e03ffd15 	stw	zero,-12(fp)
	nchars = sprintf(char_buffer, "(%i,%i)", sp->column_size, sp->row_size);
 3201244:	e0bffe17 	ldw	r2,-8(fp)
 3201248:	11800617 	ldw	r6,24(r2)
 320124c:	e0bffe17 	ldw	r2,-8(fp)
 3201250:	11c00717 	ldw	r7,28(r2)
 3201254:	e13fff17 	ldw	r4,-4(fp)
 3201258:	0140c974 	movhi	r5,805
 320125c:	29730604 	addi	r5,r5,-13288
 3201260:	32076bc0 	call	32076bc <sprintf>
 3201264:	e0bffd15 	stw	r2,-12(fp)
	return nchars;
 3201268:	e0bffd17 	ldw	r2,-12(fp)
}
 320126c:	e037883a 	mov	sp,fp
 3201270:	dfc00117 	ldw	ra,4(sp)
 3201274:	df000017 	ldw	fp,0(sp)
 3201278:	dec00204 	addi	sp,sp,8
 320127c:	f800283a 	ret

03201280 <set_sensor_size>:

int set_sensor_size(CAMERA *sp, char *char_buffer, int column_size, int row_size)
{
 3201280:	defffa04 	addi	sp,sp,-24
 3201284:	dfc00515 	stw	ra,20(sp)
 3201288:	df000415 	stw	fp,16(sp)
 320128c:	df000404 	addi	fp,sp,16
 3201290:	e13ffc15 	stw	r4,-16(fp)
 3201294:	e17ffd15 	stw	r5,-12(fp)
 3201298:	e1bffe15 	stw	r6,-8(fp)
 320129c:	e1ffff15 	stw	r7,-4(fp)
	sp->column_size = column_size;
 32012a0:	e0fffc17 	ldw	r3,-16(fp)
 32012a4:	e0bffe17 	ldw	r2,-8(fp)
 32012a8:	18800615 	stw	r2,24(r3)
	sp->row_size = row_size;
 32012ac:	e0fffc17 	ldw	r3,-16(fp)
 32012b0:	e0bfff17 	ldw	r2,-4(fp)
 32012b4:	18800715 	stw	r2,28(r3)
	return get_sensor_size(sp, char_buffer);
 32012b8:	e13ffc17 	ldw	r4,-16(fp)
 32012bc:	e17ffd17 	ldw	r5,-12(fp)
 32012c0:	32012280 	call	3201228 <get_sensor_size>
}
 32012c4:	e037883a 	mov	sp,fp
 32012c8:	dfc00117 	ldw	ra,4(sp)
 32012cc:	df000017 	ldw	fp,0(sp)
 32012d0:	dec00204 	addi	sp,sp,8
 32012d4:	f800283a 	ret

032012d8 <get_sensor_mode>:

int get_sensor_mode(CAMERA *sp, char *char_buffer)
{
 32012d8:	defffb04 	addi	sp,sp,-20
 32012dc:	dfc00415 	stw	ra,16(sp)
 32012e0:	df000315 	stw	fp,12(sp)
 32012e4:	df000304 	addi	fp,sp,12
 32012e8:	e13ffe15 	stw	r4,-8(fp)
 32012ec:	e17fff15 	stw	r5,-4(fp)
	int nchars = 0;
 32012f0:	e03ffd15 	stw	zero,-12(fp)
	nchars = sprintf(char_buffer, "(%i,%i)", sp->column_mode, sp->row_mode);
 32012f4:	e0bffe17 	ldw	r2,-8(fp)
 32012f8:	11800817 	ldw	r6,32(r2)
 32012fc:	e0bffe17 	ldw	r2,-8(fp)
 3201300:	11c00917 	ldw	r7,36(r2)
 3201304:	e13fff17 	ldw	r4,-4(fp)
 3201308:	0140c974 	movhi	r5,805
 320130c:	29730604 	addi	r5,r5,-13288
 3201310:	32076bc0 	call	32076bc <sprintf>
 3201314:	e0bffd15 	stw	r2,-12(fp)
	return nchars;
 3201318:	e0bffd17 	ldw	r2,-12(fp)
}
 320131c:	e037883a 	mov	sp,fp
 3201320:	dfc00117 	ldw	ra,4(sp)
 3201324:	df000017 	ldw	fp,0(sp)
 3201328:	dec00204 	addi	sp,sp,8
 320132c:	f800283a 	ret

03201330 <set_sensor_mode>:

int set_sensor_mode(CAMERA *sp, char *char_buffer, int column_mode, int row_mode)
{
 3201330:	defffa04 	addi	sp,sp,-24
 3201334:	dfc00515 	stw	ra,20(sp)
 3201338:	df000415 	stw	fp,16(sp)
 320133c:	df000404 	addi	fp,sp,16
 3201340:	e13ffc15 	stw	r4,-16(fp)
 3201344:	e17ffd15 	stw	r5,-12(fp)
 3201348:	e1bffe15 	stw	r6,-8(fp)
 320134c:	e1ffff15 	stw	r7,-4(fp)
	sp->column_mode = column_mode;
 3201350:	e0fffc17 	ldw	r3,-16(fp)
 3201354:	e0bffe17 	ldw	r2,-8(fp)
 3201358:	18800815 	stw	r2,32(r3)
	sp->row_mode = row_mode;
 320135c:	e0fffc17 	ldw	r3,-16(fp)
 3201360:	e0bfff17 	ldw	r2,-4(fp)
 3201364:	18800915 	stw	r2,36(r3)
	return get_sensor_mode(sp, char_buffer);
 3201368:	e13ffc17 	ldw	r4,-16(fp)
 320136c:	e17ffd17 	ldw	r5,-12(fp)
 3201370:	32012d80 	call	32012d8 <get_sensor_mode>
}
 3201374:	e037883a 	mov	sp,fp
 3201378:	dfc00117 	ldw	ra,4(sp)
 320137c:	df000017 	ldw	fp,0(sp)
 3201380:	dec00204 	addi	sp,sp,8
 3201384:	f800283a 	ret

03201388 <camera_configure>:

/* Configures the camera sensor. */
int camera_configure(CAMERA *sp, char *char_buffer)
{
 3201388:	defffb04 	addi	sp,sp,-20
 320138c:	dfc00415 	stw	ra,16(sp)
 3201390:	df000315 	stw	fp,12(sp)
 3201394:	df000304 	addi	fp,sp,12
 3201398:	e13ffe15 	stw	r4,-8(fp)
 320139c:	e17fff15 	stw	r5,-4(fp)
	printf("Configuring camera sensor...\n");
 32013a0:	0100c974 	movhi	r4,805
 32013a4:	21330904 	addi	r4,r4,-13276
 32013a8:	3206e040 	call	3206e04 <puts>
	write_camera_registers(sp);
 32013ac:	e13ffe17 	ldw	r4,-8(fp)
 32013b0:	3200f140 	call	3200f14 <write_camera_registers>
	IOWR_CAMERA_CONFIGURE(sp->base, 0);
 32013b4:	e0bffe17 	ldw	r2,-8(fp)
 32013b8:	10800017 	ldw	r2,0(r2)
 32013bc:	10800104 	addi	r2,r2,4
 32013c0:	10000035 	stwio	zero,0(r2)
	IOWR_CAMERA_CONFIGURE(sp->base, 1);
 32013c4:	e0bffe17 	ldw	r2,-8(fp)
 32013c8:	10800017 	ldw	r2,0(r2)
 32013cc:	10800104 	addi	r2,r2,4
 32013d0:	1007883a 	mov	r3,r2
 32013d4:	00800044 	movi	r2,1
 32013d8:	18800035 	stwio	r2,0(r3)
	while (!IORD_CAMERA_READY(sp->base));
 32013dc:	e0bffe17 	ldw	r2,-8(fp)
 32013e0:	10800017 	ldw	r2,0(r2)
 32013e4:	10800104 	addi	r2,r2,4
 32013e8:	10800037 	ldwio	r2,0(r2)
 32013ec:	1005003a 	cmpeq	r2,r2,zero
 32013f0:	103ffa1e 	bne	r2,zero,32013dc <camera_configure+0x54>
	printf("Camera sensor configured.\n");
 32013f4:	0100c974 	movhi	r4,805
 32013f8:	21331104 	addi	r4,r4,-13244
 32013fc:	3206e040 	call	3206e04 <puts>

	int nchars = 0;
 3201400:	e03ffd15 	stw	zero,-12(fp)
	nchars = sprintf(char_buffer, "Camera sensor configured.");
 3201404:	e0bfff17 	ldw	r2,-4(fp)
 3201408:	00c0c974 	movhi	r3,805
 320140c:	18f31104 	addi	r3,r3,-13244
 3201410:	1009883a 	mov	r4,r2
 3201414:	180b883a 	mov	r5,r3
 3201418:	01800684 	movi	r6,26
 320141c:	32067cc0 	call	32067cc <memcpy>
 3201420:	00800644 	movi	r2,25
 3201424:	e0bffd15 	stw	r2,-12(fp)
	return nchars;
 3201428:	e0bffd17 	ldw	r2,-12(fp)
}
 320142c:	e037883a 	mov	sp,fp
 3201430:	dfc00117 	ldw	ra,4(sp)
 3201434:	df000017 	ldw	fp,0(sp)
 3201438:	dec00204 	addi	sp,sp,8
 320143c:	f800283a 	ret

03201440 <select_sensor_output>:

/* Selects the sensor output. */
int select_sensor_output(CAMERA *sp, char *char_buffer, int output)
{
 3201440:	defffa04 	addi	sp,sp,-24
 3201444:	dfc00515 	stw	ra,20(sp)
 3201448:	df000415 	stw	fp,16(sp)
 320144c:	df000404 	addi	fp,sp,16
 3201450:	e13ffd15 	stw	r4,-12(fp)
 3201454:	e17ffe15 	stw	r5,-8(fp)
 3201458:	e1bfff15 	stw	r6,-4(fp)
	int nchars = 0;
 320145c:	e03ffc15 	stw	zero,-16(fp)
	if ((output < 7) && (output != 3)) {
 3201460:	e0bfff17 	ldw	r2,-4(fp)
 3201464:	108001c8 	cmpgei	r2,r2,7
 3201468:	1000101e 	bne	r2,zero,32014ac <select_sensor_output+0x6c>
 320146c:	e0bfff17 	ldw	r2,-4(fp)
 3201470:	108000e0 	cmpeqi	r2,r2,3
 3201474:	10000d1e 	bne	r2,zero,32014ac <select_sensor_output+0x6c>
		IOWR_CAMERA_CAPTURE_SELECT_SENSOR(sp->base, output);
 3201478:	e0bffd17 	ldw	r2,-12(fp)
 320147c:	10800017 	ldw	r2,0(r2)
 3201480:	10800304 	addi	r2,r2,12
 3201484:	1007883a 	mov	r3,r2
 3201488:	e0bfff17 	ldw	r2,-4(fp)
 320148c:	18800035 	stwio	r2,0(r3)
		nchars = sprintf(char_buffer, "%i", output);
 3201490:	e13ffe17 	ldw	r4,-8(fp)
 3201494:	0140c974 	movhi	r5,805
 3201498:	29730804 	addi	r5,r5,-13280
 320149c:	e1bfff17 	ldw	r6,-4(fp)
 32014a0:	32076bc0 	call	32076bc <sprintf>
 32014a4:	e0bffc15 	stw	r2,-16(fp)

/* Selects the sensor output. */
int select_sensor_output(CAMERA *sp, char *char_buffer, int output)
{
	int nchars = 0;
	if ((output < 7) && (output != 3)) {
 32014a8:	00000906 	br	32014d0 <select_sensor_output+0x90>
		IOWR_CAMERA_CAPTURE_SELECT_SENSOR(sp->base, output);
		nchars = sprintf(char_buffer, "%i", output);
	}
	else {
		nchars = sprintf(char_buffer, "Wrong sensor output.");
 32014ac:	e0bffe17 	ldw	r2,-8(fp)
 32014b0:	00c0c974 	movhi	r3,805
 32014b4:	18f31804 	addi	r3,r3,-13216
 32014b8:	1009883a 	mov	r4,r2
 32014bc:	180b883a 	mov	r5,r3
 32014c0:	01800544 	movi	r6,21
 32014c4:	32067cc0 	call	32067cc <memcpy>
 32014c8:	00800504 	movi	r2,20
 32014cc:	e0bffc15 	stw	r2,-16(fp)
	}
	return nchars;
 32014d0:	e0bffc17 	ldw	r2,-16(fp)
}
 32014d4:	e037883a 	mov	sp,fp
 32014d8:	dfc00117 	ldw	ra,4(sp)
 32014dc:	df000017 	ldw	fp,0(sp)
 32014e0:	dec00204 	addi	sp,sp,8
 32014e4:	f800283a 	ret

032014e8 <select_vga_output>:

/* Selects the vga output. */
int select_vga_output(CAMERA *sp, char *char_buffer)
{
 32014e8:	defffb04 	addi	sp,sp,-20
 32014ec:	dfc00415 	stw	ra,16(sp)
 32014f0:	df000315 	stw	fp,12(sp)
 32014f4:	df000304 	addi	fp,sp,12
 32014f8:	e13ffe15 	stw	r4,-8(fp)
 32014fc:	e17fff15 	stw	r5,-4(fp)
	static int vga = 0;

	printf("Configuring VGA...\n");
 3201500:	0100c974 	movhi	r4,805
 3201504:	21331e04 	addi	r4,r4,-13192
 3201508:	3206e040 	call	3206e04 <puts>
	vga = ~vga;
 320150c:	d0a89117 	ldw	r2,-23996(gp)
 3201510:	0084303a 	nor	r2,zero,r2
 3201514:	d0a89115 	stw	r2,-23996(gp)
	IOWR_CAMERA_CAPTURE_SELECT_VGA(sp->base, vga);
 3201518:	e0bffe17 	ldw	r2,-8(fp)
 320151c:	10800017 	ldw	r2,0(r2)
 3201520:	10800204 	addi	r2,r2,8
 3201524:	d0e89117 	ldw	r3,-23996(gp)
 3201528:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_CONFIGURE(sp->base, 0);
 320152c:	e0bffe17 	ldw	r2,-8(fp)
 3201530:	10800017 	ldw	r2,0(r2)
 3201534:	10800104 	addi	r2,r2,4
 3201538:	10000035 	stwio	zero,0(r2)
	IOWR_CAMERA_CONFIGURE(sp->base, 1);
 320153c:	e0bffe17 	ldw	r2,-8(fp)
 3201540:	10800017 	ldw	r2,0(r2)
 3201544:	10800104 	addi	r2,r2,4
 3201548:	1007883a 	mov	r3,r2
 320154c:	00800044 	movi	r2,1
 3201550:	18800035 	stwio	r2,0(r3)
	while (!IORD_CAMERA_READY(sp->base));
 3201554:	e0bffe17 	ldw	r2,-8(fp)
 3201558:	10800017 	ldw	r2,0(r2)
 320155c:	10800104 	addi	r2,r2,4
 3201560:	10800037 	ldwio	r2,0(r2)
 3201564:	1005003a 	cmpeq	r2,r2,zero
 3201568:	103ffa1e 	bne	r2,zero,3201554 <select_vga_output+0x6c>
	if (vga) IOWR_CAMERA_CAPTURE_START(sp->base);
 320156c:	d0a89117 	ldw	r2,-23996(gp)
 3201570:	1005003a 	cmpeq	r2,r2,zero
 3201574:	1000061e 	bne	r2,zero,3201590 <select_vga_output+0xa8>
 3201578:	e0bffe17 	ldw	r2,-8(fp)
 320157c:	10800017 	ldw	r2,0(r2)
 3201580:	1007883a 	mov	r3,r2
 3201584:	00800044 	movi	r2,1
 3201588:	18800035 	stwio	r2,0(r3)
 320158c:	00000306 	br	320159c <select_vga_output+0xb4>
	else IOWR_CAMERA_CAPTURE_STOP(sp->base);
 3201590:	e0bffe17 	ldw	r2,-8(fp)
 3201594:	10800017 	ldw	r2,0(r2)
 3201598:	10000035 	stwio	zero,0(r2)
	printf("VGA output configured.\n");
 320159c:	0100c974 	movhi	r4,805
 32015a0:	21332304 	addi	r4,r4,-13172
 32015a4:	3206e040 	call	3206e04 <puts>

	int nchars = 0;
 32015a8:	e03ffd15 	stw	zero,-12(fp)
	nchars = sprintf(char_buffer, "VGA output configured.");
 32015ac:	e0bfff17 	ldw	r2,-4(fp)
 32015b0:	00c0c974 	movhi	r3,805
 32015b4:	18f32304 	addi	r3,r3,-13172
 32015b8:	1009883a 	mov	r4,r2
 32015bc:	180b883a 	mov	r5,r3
 32015c0:	018005c4 	movi	r6,23
 32015c4:	32067cc0 	call	32067cc <memcpy>
 32015c8:	00800584 	movi	r2,22
 32015cc:	e0bffd15 	stw	r2,-12(fp)
	return nchars;
 32015d0:	e0bffd17 	ldw	r2,-12(fp)
}
 32015d4:	e037883a 	mov	sp,fp
 32015d8:	dfc00117 	ldw	ra,4(sp)
 32015dc:	df000017 	ldw	fp,0(sp)
 32015e0:	dec00204 	addi	sp,sp,8
 32015e4:	f800283a 	ret

032015e8 <write_in_lcd>:
OS_STK    task1_stk[TASK_STACKSIZE];

#define TASK1_PRIORITY      10

/* Print a message in LCD */
void write_in_lcd(char* msg) {
 32015e8:	defffc04 	addi	sp,sp,-16
 32015ec:	dfc00315 	stw	ra,12(sp)
 32015f0:	df000215 	stw	fp,8(sp)
 32015f4:	df000204 	addi	fp,sp,8
 32015f8:	e13fff15 	stw	r4,-4(fp)
	FILE* fp;
	fp = fopen ("/dev/lcd", "w");
 32015fc:	0100c974 	movhi	r4,805
 3201600:	21332904 	addi	r4,r4,-13148
 3201604:	0140c974 	movhi	r5,805
 3201608:	29732c04 	addi	r5,r5,-13136
 320160c:	3204bd40 	call	3204bd4 <fopen>
 3201610:	e0bffe15 	stw	r2,-8(fp)
	if (fp!=NULL) {
 3201614:	e0bffe17 	ldw	r2,-8(fp)
 3201618:	1005003a 	cmpeq	r2,r2,zero
 320161c:	1000051e 	bne	r2,zero,3201634 <write_in_lcd+0x4c>
		fprintf(fp, "%s",msg);
 3201620:	e13fff17 	ldw	r4,-4(fp)
 3201624:	e17ffe17 	ldw	r5,-8(fp)
 3201628:	3204cc40 	call	3204cc4 <fputs>
		fclose (fp);
 320162c:	e13ffe17 	ldw	r4,-8(fp)
 3201630:	32045dc0 	call	32045dc <fclose>
	}
}
 3201634:	e037883a 	mov	sp,fp
 3201638:	dfc00117 	ldw	ra,4(sp)
 320163c:	df000017 	ldw	fp,0(sp)
 3201640:	dec00204 	addi	sp,sp,8
 3201644:	f800283a 	ret

03201648 <task1>:

// TODO: Group tasks in tasks.c file

/* Prints the time of execution in seconds from reset */
void task1(void* pdata) {
 3201648:	defff404 	addi	sp,sp,-48
 320164c:	dfc00b15 	stw	ra,44(sp)
 3201650:	df000a15 	stw	fp,40(sp)
 3201654:	df000a04 	addi	fp,sp,40
 3201658:	e13fff15 	stw	r4,-4(fp)
	// Camera initialization
	camera_init();
 320165c:	3200db40 	call	3200db4 <camera_init>
	// Trackers initialization
	trackers_init();
 3201660:	32039040 	call	3203904 <trackers_init>

	char msg[16];

	while (1) {
		// Show time of execution in seconds
		i++;
 3201664:	e0bffa17 	ldw	r2,-24(fp)
 3201668:	10800044 	addi	r2,r2,1
 320166c:	e0bffa15 	stw	r2,-24(fp)
		printf("%is Run...\r", i);
 3201670:	0100c974 	movhi	r4,805
 3201674:	21332d04 	addi	r4,r4,-13132
 3201678:	e17ffa17 	ldw	r5,-24(fp)
 320167c:	3206adc0 	call	3206adc <printf>

		// Show in LCD: IP and TIME
		sprintf(msg, "#%d.%d.%d.%d\n%is Run...\n", IPADDR0, IPADDR1, IPADDR2, IPADDR3, i);
 3201680:	e13ffb04 	addi	r4,fp,-20
 3201684:	00801844 	movi	r2,97
 3201688:	d8800015 	stw	r2,0(sp)
 320168c:	00800144 	movi	r2,5
 3201690:	d8800115 	stw	r2,4(sp)
 3201694:	e0bffa17 	ldw	r2,-24(fp)
 3201698:	d8800215 	stw	r2,8(sp)
 320169c:	0140c974 	movhi	r5,805
 32016a0:	29733004 	addi	r5,r5,-13120
 32016a4:	01802604 	movi	r6,152
 32016a8:	01c00384 	movi	r7,14
 32016ac:	32076bc0 	call	32076bc <sprintf>
		write_in_lcd(msg);
 32016b0:	e13ffb04 	addi	r4,fp,-20
 32016b4:	32015e80 	call	32015e8 <write_in_lcd>

		OSTimeDlyHMSM(0, 0, 1, 0);
 32016b8:	0009883a 	mov	r4,zero
 32016bc:	000b883a 	mov	r5,zero
 32016c0:	01800044 	movi	r6,1
 32016c4:	000f883a 	mov	r7,zero
 32016c8:	321d0c40 	call	321d0c4 <OSTimeDlyHMSM>
	}
 32016cc:	003fe506 	br	3201664 <task1+0x1c>

032016d0 <SSSInitialTask>:
 * NicheStack is initialized from a task, so that RTOS will have started, and
 * I/O drivers are available.  Two tasks are created:
 *     "Inet main"  task with priority 2
 *     "clock tick" task with priority 3
 */
void SSSInitialTask(void *task_data) {
 32016d0:	defff704 	addi	sp,sp,-36
 32016d4:	dfc00815 	stw	ra,32(sp)
 32016d8:	df000715 	stw	fp,28(sp)
 32016dc:	df000704 	addi	fp,sp,28
 32016e0:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	alt_iniche_init();
 32016e4:	322b2b40 	call	322b2b4 <alt_iniche_init>

	netmain();
 32016e8:	32264fc0 	call	32264fc <netmain>

	/* Wait for the network stack to be ready before proceeding.
	 * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
	 */
	while (!iniche_net_ready) TK_SLEEP(1);
 32016ec:	00000206 	br	32016f8 <SSSInitialTask+0x28>
 32016f0:	01000084 	movi	r4,2
 32016f4:	321cf780 	call	321cf78 <OSTimeDly>
 32016f8:	0080c974 	movhi	r2,805
 32016fc:	10923a04 	addi	r2,r2,18664
 3201700:	10800017 	ldw	r2,0(r2)
 3201704:	1005003a 	cmpeq	r2,r2,zero
 3201708:	103ff91e 	bne	r2,zero,32016f0 <SSSInitialTask+0x20>


	/* Application Specific Task Launching Code Block Begin */

	printf("\nSimple Socket Server starting up\n");
 320170c:	0100c974 	movhi	r4,805
 3201710:	21333d04 	addi	r4,r4,-13068
 3201714:	3206e040 	call	3206e04 <puts>

	/* Create the main simple socket server task. */
	TK_NEWTASK(&ssstask);
 3201718:	0100c974 	movhi	r4,805
 320171c:	21019404 	addi	r4,r4,1616
 3201720:	322af740 	call	322af74 <TK_NEWTASK>

	/* Create the other tasks */
	//SSSCreateTasks();
	OSTaskCreateExt(task1,
 3201724:	0180c974 	movhi	r6,805
 3201728:	319cb904 	addi	r6,r6,29412
 320172c:	00800284 	movi	r2,10
 3201730:	d8800015 	stw	r2,0(sp)
 3201734:	0080c974 	movhi	r2,805
 3201738:	1094ba04 	addi	r2,r2,21224
 320173c:	d8800115 	stw	r2,4(sp)
 3201740:	00820004 	movi	r2,2048
 3201744:	d8800215 	stw	r2,8(sp)
 3201748:	d8000315 	stw	zero,12(sp)
 320174c:	d8000415 	stw	zero,16(sp)
 3201750:	0100c834 	movhi	r4,800
 3201754:	21059204 	addi	r4,r4,5704
 3201758:	000b883a 	mov	r5,zero
 320175c:	01c00284 	movi	r7,10
 3201760:	321bc800 	call	321bc80 <OSTaskCreateExt>

	/* Application Specific Task Launching Code Block End */


	/*This task is deleted because there is no need for it to run again */
	error_code = OSTaskDel(OS_PRIO_SELF);
 3201764:	01003fc4 	movi	r4,255
 3201768:	321be800 	call	321be80 <OSTaskDel>
 320176c:	e0bffe05 	stb	r2,-8(fp)
	alt_uCOSIIErrorHandler(error_code, 0);
 3201770:	e13ffe03 	ldbu	r4,-8(fp)
 3201774:	000b883a 	mov	r5,zero
 3201778:	320020c0 	call	320020c <alt_uCOSIIErrorHandler>

	while (1); /* Correct Program Flow should never get here */
 320177c:	003fff06 	br	320177c <SSSInitialTask+0xac>

03201780 <main>:
}

/* Main creates a single task, SSSInitialTask, and starts task scheduler.
 */
int main(int argc, char* argv[], char* envp[]) {
 3201780:	defff504 	addi	sp,sp,-44
 3201784:	dfc00a15 	stw	ra,40(sp)
 3201788:	df000915 	stw	fp,36(sp)
 320178c:	df000904 	addi	fp,sp,36
 3201790:	e13ffd15 	stw	r4,-12(fp)
 3201794:	e17ffe15 	stw	r5,-8(fp)
 3201798:	e1bfff15 	stw	r6,-4(fp)

	INT8U error_code;

	/* Clear the RTOS timer */
	OSTimeSet(0);
 320179c:	0009883a 	mov	r4,zero
 32017a0:	321d4ac0 	call	321d4ac <OSTimeSet>

	/* SSSInitialTask will initialize the NicheStack TCP/IP Stack
	 * and then initialize the rest of the Simple Socket Server example
	 * RTOS structures and tasks.
	 */
	error_code = OSTaskCreateExt(SSSInitialTask,
 32017a4:	0180c9b4 	movhi	r6,806
 32017a8:	31a4ba04 	addi	r6,r6,-27928
 32017ac:	00800144 	movi	r2,5
 32017b0:	d8800015 	stw	r2,0(sp)
 32017b4:	0080c974 	movhi	r2,805
 32017b8:	109cba04 	addi	r2,r2,29416
 32017bc:	d8800115 	stw	r2,4(sp)
 32017c0:	00820004 	movi	r2,2048
 32017c4:	d8800215 	stw	r2,8(sp)
 32017c8:	d8000315 	stw	zero,12(sp)
 32017cc:	d8000415 	stw	zero,16(sp)
 32017d0:	0100c834 	movhi	r4,800
 32017d4:	2105b404 	addi	r4,r4,5840
 32017d8:	000b883a 	mov	r5,zero
 32017dc:	01c00144 	movi	r7,5
 32017e0:	321bc800 	call	321bc80 <OSTaskCreateExt>
 32017e4:	e0bffc05 	stb	r2,-16(fp)
			SSS_INITIAL_TASK_PRIORITY,
			SSSInitialTaskStk,
			TASK_STACKSIZE,
			NULL,
			0);
	alt_uCOSIIErrorHandler(error_code, 0);
 32017e8:	e13ffc03 	ldbu	r4,-16(fp)
 32017ec:	000b883a 	mov	r5,zero
 32017f0:	320020c0 	call	320020c <alt_uCOSIIErrorHandler>

	/*
	 * As with all MicroC/OS-II designs, once the initial thread(s) and
	 * associated RTOS resources are declared, we start the RTOS. That's it!
	 */
	OSStart();
 32017f4:	3215eac0 	call	3215eac <OSStart>

	while(1); /* Correct Program Flow never gets here. */
 32017f8:	003fff06 	br	32017f8 <main+0x78>

032017fc <get_mac_addr>:
* Read the MAC address in a board specific way. Prompt user to enter serial 
* number to generate MAC address if failed to read from flash.
*
*/
int get_mac_addr(NET net, unsigned char mac_addr[6])
{
 32017fc:	defffb04 	addi	sp,sp,-20
 3201800:	dfc00415 	stw	ra,16(sp)
 3201804:	df000315 	stw	fp,12(sp)
 3201808:	df000304 	addi	fp,sp,12
 320180c:	e13ffe15 	stw	r4,-8(fp)
 3201810:	e17fff15 	stw	r5,-4(fp)
    error_t error = 0;
 3201814:	e03ffd15 	stw	zero,-12(fp)
    
    error = get_board_mac_addr(mac_addr);
 3201818:	e13fff17 	ldw	r4,-4(fp)
 320181c:	3201da40 	call	3201da4 <get_board_mac_addr>
 3201820:	e0bffd15 	stw	r2,-12(fp)
    
    if(error)
 3201824:	e0bffd17 	ldw	r2,-12(fp)
 3201828:	1005003a 	cmpeq	r2,r2,zero
 320182c:	1000031e 	bne	r2,zero,320183c <get_mac_addr+0x40>
    {
        /* Failed read MAC address from flash, prompt user to enter serial 
           number to generate MAC address. */
        error = generate_mac_addr(mac_addr);
 3201830:	e13fff17 	ldw	r4,-4(fp)
 3201834:	3201c680 	call	3201c68 <generate_mac_addr>
 3201838:	e0bffd15 	stw	r2,-12(fp)
    }
    return error;
 320183c:	e0bffd17 	ldw	r2,-12(fp)
}
 3201840:	e037883a 	mov	sp,fp
 3201844:	dfc00117 	ldw	ra,4(sp)
 3201848:	df000017 	ldw	fp,0(sp)
 320184c:	dec00204 	addi	sp,sp,8
 3201850:	f800283a 	ret

03201854 <get_ip_addr>:
int get_ip_addr(alt_iniche_dev *p_dev,
                ip_addr* ipaddr,
                ip_addr* netmask,
                ip_addr* gw,
                int* use_dhcp)
{
 3201854:	defffb04 	addi	sp,sp,-20
 3201858:	df000415 	stw	fp,16(sp)
 320185c:	df000404 	addi	fp,sp,16
 3201860:	e13ffc15 	stw	r4,-16(fp)
 3201864:	e17ffd15 	stw	r5,-12(fp)
 3201868:	e1bffe15 	stw	r6,-8(fp)
 320186c:	e1ffff15 	stw	r7,-4(fp)

    IP4_ADDR(*ipaddr, IPADDR0, IPADDR1, IPADDR2, IPADDR3);
 3201870:	e0fffd17 	ldw	r3,-12(fp)
 3201874:	00815874 	movhi	r2,1377
 3201878:	1083a604 	addi	r2,r2,3736
 320187c:	18800015 	stw	r2,0(r3)
    IP4_ADDR(*gw, GWADDR0, GWADDR1, GWADDR2, GWADDR3);
 3201880:	e0ffff17 	ldw	r3,-4(fp)
 3201884:	00805834 	movhi	r2,352
 3201888:	1083a604 	addi	r2,r2,3736
 320188c:	18800015 	stw	r2,0(r3)
    IP4_ADDR(*netmask, MSKADDR0, MSKADDR1, MSKADDR2, MSKADDR3);
 3201890:	e0fffe17 	ldw	r3,-8(fp)
 3201894:	00803ff4 	movhi	r2,255
 3201898:	10bfffc4 	addi	r2,r2,-1
 320189c:	18800015 	stw	r2,0(r3)

#ifdef DHCP_CLIENT
    *use_dhcp = 1;
 32018a0:	e0c00117 	ldw	r3,4(fp)
 32018a4:	00800044 	movi	r2,1
 32018a8:	18800015 	stw	r2,0(r3)
        ip4_addr3(*ipaddr),
        ip4_addr4(*ipaddr));
#endif /* not DHCP_CLIENT */

    /* Non-standard API: return 1 for success */
    return 1;
 32018ac:	00800044 	movi	r2,1
}
 32018b0:	e037883a 	mov	sp,fp
 32018b4:	df000017 	ldw	fp,0(sp)
 32018b8:	dec00104 	addi	sp,sp,4
 32018bc:	f800283a 	ret

032018c0 <get_serial_number>:
*
* Prompt user to enter 9-digit serial number. 
*
*/
alt_u32 get_serial_number (void)
{
 32018c0:	defff804 	addi	sp,sp,-32
 32018c4:	dfc00715 	stw	ra,28(sp)
 32018c8:	df000615 	stw	fp,24(sp)
 32018cc:	dc000515 	stw	r16,20(sp)
 32018d0:	df000504 	addi	fp,sp,20
    alt_u32 ser_num = 0;
 32018d4:	e03ffc15 	stw	zero,-16(fp)
    char serial_number[9];
    int i = 0;
 32018d8:	e03ffb15 	stw	zero,-20(fp)
    
    while(!ser_num)
 32018dc:	00006506 	br	3201a74 <get_serial_number+0x1b4>
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
 32018e0:	0100c974 	movhi	r4,805
 32018e4:	21334604 	addi	r4,r4,-13032
 32018e8:	3206e040 	call	3206e04 <puts>
        printf("label under your Nios dev. board. The first 3 digits of the \n");
 32018ec:	0100c974 	movhi	r4,805
 32018f0:	21335604 	addi	r4,r4,-12968
 32018f4:	3206e040 	call	3206e04 <puts>
        printf("label are ASJ and the serial number follows this.\n -->");
 32018f8:	0100c974 	movhi	r4,805
 32018fc:	21336604 	addi	r4,r4,-12904
 3201900:	3206adc0 	call	3206adc <printf>
        
        for(i=0; i<9; i++)
 3201904:	e03ffb15 	stw	zero,-20(fp)
 3201908:	00002806 	br	32019ac <get_serial_number+0xec>
        {
            serial_number[i] = getchar();
 320190c:	e43ffb17 	ldw	r16,-20(fp)
 3201910:	0080c974 	movhi	r2,805
 3201914:	10897804 	addi	r2,r2,9696
 3201918:	10800017 	ldw	r2,0(r2)
 320191c:	11000117 	ldw	r4,4(r2)
 3201920:	3205cec0 	call	3205cec <getc>
 3201924:	1007883a 	mov	r3,r2
 3201928:	e0bffd04 	addi	r2,fp,-12
 320192c:	1405883a 	add	r2,r2,r16
 3201930:	10c00005 	stb	r3,0(r2)
            putchar(serial_number[i]);
 3201934:	e0fffb17 	ldw	r3,-20(fp)
 3201938:	e0bffd04 	addi	r2,fp,-12
 320193c:	10c5883a 	add	r2,r2,r3
 3201940:	10800003 	ldbu	r2,0(r2)
 3201944:	11003fcc 	andi	r4,r2,255
 3201948:	2100201c 	xori	r4,r4,128
 320194c:	213fe004 	addi	r4,r4,-128
 3201950:	0080c974 	movhi	r2,805
 3201954:	10897804 	addi	r2,r2,9696
 3201958:	10800017 	ldw	r2,0(r2)
 320195c:	11400217 	ldw	r5,8(r2)
 3201960:	3206b540 	call	3206b54 <putc>
            
            /* Handle backspaces.  How civilized. */
            if ((serial_number[i] == 0x08) && (i >= 0)) 
 3201964:	e0fffb17 	ldw	r3,-20(fp)
 3201968:	e0bffd04 	addi	r2,fp,-12
 320196c:	10c5883a 	add	r2,r2,r3
 3201970:	10800003 	ldbu	r2,0(r2)
 3201974:	10803fcc 	andi	r2,r2,255
 3201978:	1080201c 	xori	r2,r2,128
 320197c:	10bfe004 	addi	r2,r2,-128
 3201980:	10800218 	cmpnei	r2,r2,8
 3201984:	1000061e 	bne	r2,zero,32019a0 <get_serial_number+0xe0>
 3201988:	e0bffb17 	ldw	r2,-20(fp)
 320198c:	1004803a 	cmplt	r2,r2,zero
 3201990:	1000031e 	bne	r2,zero,32019a0 <get_serial_number+0xe0>
            {
                i--;
 3201994:	e0bffb17 	ldw	r2,-20(fp)
 3201998:	10bfffc4 	addi	r2,r2,-1
 320199c:	e0bffb15 	stw	r2,-20(fp)
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
        printf("label under your Nios dev. board. The first 3 digits of the \n");
        printf("label are ASJ and the serial number follows this.\n -->");
        
        for(i=0; i<9; i++)
 32019a0:	e0bffb17 	ldw	r2,-20(fp)
 32019a4:	10800044 	addi	r2,r2,1
 32019a8:	e0bffb15 	stw	r2,-20(fp)
 32019ac:	e0bffb17 	ldw	r2,-20(fp)
 32019b0:	10800250 	cmplti	r2,r2,9
 32019b4:	103fd51e 	bne	r2,zero,320190c <get_serial_number+0x4c>
            if ((serial_number[i] == 0x08) && (i >= 0)) 
            {
                i--;
            }
        }
        printf("\n");
 32019b8:	01000284 	movi	r4,10
 32019bc:	3206d400 	call	3206d40 <putchar>
                
        for(i=0; i<9; i++)
 32019c0:	e03ffb15 	stw	zero,-20(fp)
 32019c4:	00002806 	br	3201a68 <get_serial_number+0x1a8>
        {
            if (isdigit(serial_number[i]))
 32019c8:	e0fffb17 	ldw	r3,-20(fp)
 32019cc:	e0bffd04 	addi	r2,fp,-12
 32019d0:	10c5883a 	add	r2,r2,r3
 32019d4:	10800003 	ldbu	r2,0(r2)
 32019d8:	10803fcc 	andi	r2,r2,255
 32019dc:	1080201c 	xori	r2,r2,128
 32019e0:	10bfe004 	addi	r2,r2,-128
 32019e4:	1007883a 	mov	r3,r2
 32019e8:	0080c974 	movhi	r2,805
 32019ec:	10897704 	addi	r2,r2,9692
 32019f0:	10800017 	ldw	r2,0(r2)
 32019f4:	1885883a 	add	r2,r3,r2
 32019f8:	10800003 	ldbu	r2,0(r2)
 32019fc:	10803fcc 	andi	r2,r2,255
 3201a00:	1080010c 	andi	r2,r2,4
 3201a04:	1005003a 	cmpeq	r2,r2,zero
 3201a08:	1000121e 	bne	r2,zero,3201a54 <get_serial_number+0x194>
            {
                ser_num *= 10;
 3201a0c:	e0bffc17 	ldw	r2,-16(fp)
 3201a10:	108002a4 	muli	r2,r2,10
 3201a14:	e0bffc15 	stw	r2,-16(fp)
                ser_num += serial_number[i] - '0';
 3201a18:	e0fffb17 	ldw	r3,-20(fp)
 3201a1c:	e0bffd04 	addi	r2,fp,-12
 3201a20:	10c5883a 	add	r2,r2,r3
 3201a24:	10800003 	ldbu	r2,0(r2)
 3201a28:	10c03fcc 	andi	r3,r2,255
 3201a2c:	18c0201c 	xori	r3,r3,128
 3201a30:	18ffe004 	addi	r3,r3,-128
 3201a34:	e0bffc17 	ldw	r2,-16(fp)
 3201a38:	1885883a 	add	r2,r3,r2
 3201a3c:	10bff404 	addi	r2,r2,-48
 3201a40:	e0bffc15 	stw	r2,-16(fp)
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 3201a44:	e0bffb17 	ldw	r2,-20(fp)
 3201a48:	10800044 	addi	r2,r2,1
 3201a4c:	e0bffb15 	stw	r2,-20(fp)
 3201a50:	00000506 	br	3201a68 <get_serial_number+0x1a8>
                ser_num *= 10;
                ser_num += serial_number[i] - '0';
            }
            else
            {
                ser_num = 0;
 3201a54:	e03ffc15 	stw	zero,-16(fp)
                printf("Serial number only contains decimal digits and is non-zero\n");
 3201a58:	0100c974 	movhi	r4,805
 3201a5c:	21337404 	addi	r4,r4,-12848
 3201a60:	3206e040 	call	3206e04 <puts>
                break;
 3201a64:	00000306 	br	3201a74 <get_serial_number+0x1b4>
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 3201a68:	e0bffb17 	ldw	r2,-20(fp)
 3201a6c:	10800250 	cmplti	r2,r2,9
 3201a70:	103fd51e 	bne	r2,zero,32019c8 <get_serial_number+0x108>
{
    alt_u32 ser_num = 0;
    char serial_number[9];
    int i = 0;
    
    while(!ser_num)
 3201a74:	e0bffc17 	ldw	r2,-16(fp)
 3201a78:	1005003a 	cmpeq	r2,r2,zero
 3201a7c:	103f981e 	bne	r2,zero,32018e0 <get_serial_number+0x20>
                break;
            }
        }
    }
    
    return ser_num;
 3201a80:	e0bffc17 	ldw	r2,-16(fp)
}
 3201a84:	e037883a 	mov	sp,fp
 3201a88:	dfc00217 	ldw	ra,8(sp)
 3201a8c:	df000117 	ldw	fp,4(sp)
 3201a90:	dc000017 	ldw	r16,0(sp)
 3201a94:	dec00304 	addi	sp,sp,12
 3201a98:	f800283a 	ret

03201a9c <generate_and_store_mac_addr>:
 * sections. These fail-safe static settings are compatible with previous
 * Nios Ethernet designs, and allow the "factory-safe" design to behave 
 * as expected if the last flash sector is erased.
 */
error_t generate_and_store_mac_addr()
{
 3201a9c:	deffef04 	addi	sp,sp,-68
 3201aa0:	dfc01015 	stw	ra,64(sp)
 3201aa4:	df000f15 	stw	fp,60(sp)
 3201aa8:	df000f04 	addi	fp,sp,60
    error_t error = -1;
 3201aac:	00bfffc4 	movi	r2,-1
 3201ab0:	e0bff715 	stw	r2,-36(fp)
    alt_u32 ser_num = 0;
 3201ab4:	e03ff615 	stw	zero,-40(fp)
    char flash_content[32];
    alt_flash_fd* flash_handle;
    
    printf("Can't read the MAC address from your board (this probably means\n");
 3201ab8:	0100c974 	movhi	r4,805
 3201abc:	21338304 	addi	r4,r4,-12788
 3201ac0:	3206e040 	call	3206e04 <puts>
    printf("that your flash was erased). We will assign you a MAC address and\n");
 3201ac4:	0100c974 	movhi	r4,805
 3201ac8:	21339304 	addi	r4,r4,-12724
 3201acc:	3206e040 	call	3206e04 <puts>
    printf("static network settings\n\n");
 3201ad0:	0100c974 	movhi	r4,805
 3201ad4:	2133a404 	addi	r4,r4,-12656
 3201ad8:	3206e040 	call	3206e04 <puts>
    
    ser_num = get_serial_number();
 3201adc:	32018c00 	call	32018c0 <get_serial_number>
 3201ae0:	e0bff615 	stw	r2,-40(fp)
  
    if (ser_num)
 3201ae4:	e0bff617 	ldw	r2,-40(fp)
 3201ae8:	1005003a 	cmpeq	r2,r2,zero
 3201aec:	1000581e 	bne	r2,zero,3201c50 <generate_and_store_mac_addr+0x1b4>
    {
        /* This says the image is safe */
        flash_content[0] = 0xfe;
 3201af0:	00bfff84 	movi	r2,-2
 3201af4:	e0bff805 	stb	r2,-32(fp)
        flash_content[1] = 0x5a;
 3201af8:	00801684 	movi	r2,90
 3201afc:	e0bff845 	stb	r2,-31(fp)
        flash_content[2] = 0x0;
 3201b00:	e03ff885 	stb	zero,-30(fp)
        flash_content[3] = 0x0;
 3201b04:	e03ff8c5 	stb	zero,-29(fp)
        
        /* This is the Altera Vendor ID */
        flash_content[4] = 0x0;
 3201b08:	e03ff905 	stb	zero,-28(fp)
        flash_content[5] = 0x7;
 3201b0c:	008001c4 	movi	r2,7
 3201b10:	e0bff945 	stb	r2,-27(fp)
        flash_content[6] = 0xed;
 3201b14:	00bffb44 	movi	r2,-19
 3201b18:	e0bff985 	stb	r2,-26(fp)
        
        /* Reserverd Board identifier for erase boards */
        flash_content[7] = 0xFF;
 3201b1c:	00bfffc4 	movi	r2,-1
 3201b20:	e0bff9c5 	stb	r2,-25(fp)
        flash_content[8] = (ser_num & 0xff00) >> 8;
 3201b24:	e0bff617 	ldw	r2,-40(fp)
 3201b28:	10bfc00c 	andi	r2,r2,65280
 3201b2c:	1004d23a 	srli	r2,r2,8
 3201b30:	e0bffa05 	stb	r2,-24(fp)
        flash_content[9] = ser_num & 0xff;
 3201b34:	e0bff617 	ldw	r2,-40(fp)
 3201b38:	e0bffa45 	stb	r2,-23(fp)
        
        /* Then comes a 16-bit "flags" field */
        flash_content[10] = 0xFF;
 3201b3c:	00bfffc4 	movi	r2,-1
 3201b40:	e0bffa85 	stb	r2,-22(fp)
        flash_content[11] = 0xFF;
 3201b44:	00bfffc4 	movi	r2,-1
 3201b48:	e0bffac5 	stb	r2,-21(fp)
        
        /* Then comes the static IP address */
        flash_content[12] = IPADDR0;
 3201b4c:	00bfe604 	movi	r2,-104
 3201b50:	e0bffb05 	stb	r2,-20(fp)
        flash_content[13] = IPADDR1;
 3201b54:	00800384 	movi	r2,14
 3201b58:	e0bffb45 	stb	r2,-19(fp)
        flash_content[14] = IPADDR2;
 3201b5c:	00801844 	movi	r2,97
 3201b60:	e0bffb85 	stb	r2,-18(fp)
        flash_content[15] = IPADDR3;
 3201b64:	00800144 	movi	r2,5
 3201b68:	e0bffbc5 	stb	r2,-17(fp)
        
        /* Then comes the static nameserver address */
        flash_content[16] = 0xFF;
 3201b6c:	00bfffc4 	movi	r2,-1
 3201b70:	e0bffc05 	stb	r2,-16(fp)
        flash_content[17] = 0xFF;
 3201b74:	00bfffc4 	movi	r2,-1
 3201b78:	e0bffc45 	stb	r2,-15(fp)
        flash_content[18] = 0xFF;
 3201b7c:	00bfffc4 	movi	r2,-1
 3201b80:	e0bffc85 	stb	r2,-14(fp)
        flash_content[19] = 0xFF;
 3201b84:	00bfffc4 	movi	r2,-1
 3201b88:	e0bffcc5 	stb	r2,-13(fp)
        
        /* Then comes the static subnet mask */
        flash_content[20] = MSKADDR0;
 3201b8c:	00bfffc4 	movi	r2,-1
 3201b90:	e0bffd05 	stb	r2,-12(fp)
        flash_content[21] = MSKADDR1;
 3201b94:	00bfffc4 	movi	r2,-1
 3201b98:	e0bffd45 	stb	r2,-11(fp)
        flash_content[22] = MSKADDR2;
 3201b9c:	00bfff84 	movi	r2,-2
 3201ba0:	e0bffd85 	stb	r2,-10(fp)
        flash_content[23] = MSKADDR3;
 3201ba4:	e03ffdc5 	stb	zero,-9(fp)
        
        /* Then comes the static gateway address */
        flash_content[24] = GWADDR0;
 3201ba8:	00bfe604 	movi	r2,-104
 3201bac:	e0bffe05 	stb	r2,-8(fp)
        flash_content[25] = GWADDR1;
 3201bb0:	00800384 	movi	r2,14
 3201bb4:	e0bffe45 	stb	r2,-7(fp)
        flash_content[26] = GWADDR2;
 3201bb8:	00801804 	movi	r2,96
 3201bbc:	e0bffe85 	stb	r2,-6(fp)
        flash_content[27] = GWADDR3;
 3201bc0:	00800044 	movi	r2,1
 3201bc4:	e0bffec5 	stb	r2,-5(fp)
        
        /* And finally whether to use DHCP - set all bits to be safe */
        flash_content[28] = 0xFF;
 3201bc8:	00bfffc4 	movi	r2,-1
 3201bcc:	e0bfff05 	stb	r2,-4(fp)
        flash_content[29] = 0xFF;
 3201bd0:	00bfffc4 	movi	r2,-1
 3201bd4:	e0bfff45 	stb	r2,-3(fp)
        flash_content[30] = 0xFF;
 3201bd8:	00bfffc4 	movi	r2,-1
 3201bdc:	e0bfff85 	stb	r2,-2(fp)
        flash_content[31] = 0xFF;
 3201be0:	00bfffc4 	movi	r2,-1
 3201be4:	e0bfffc5 	stb	r2,-1(fp)
        
        /* Write the MAC address to flash */
        flash_handle = alt_flash_open_dev(EXT_FLASH_NAME);
 3201be8:	0100c974 	movhi	r4,805
 3201bec:	2133ab04 	addi	r4,r4,-12628
 3201bf0:	321455c0 	call	321455c <alt_flash_open_dev>
 3201bf4:	e0bff515 	stw	r2,-44(fp)
        if (flash_handle)
 3201bf8:	e0bff517 	ldw	r2,-44(fp)
 3201bfc:	1005003a 	cmpeq	r2,r2,zero
 3201c00:	1000131e 	bne	r2,zero,3201c50 <generate_and_store_mac_addr+0x1b4>
        {
            alt_write_flash(flash_handle,
 3201c04:	d0a89317 	ldw	r2,-23988(gp)
 3201c08:	1007883a 	mov	r3,r2
 3201c0c:	e0bff517 	ldw	r2,-44(fp)
 3201c10:	e0bff115 	stw	r2,-60(fp)
 3201c14:	e0fff215 	stw	r3,-56(fp)
 3201c18:	e0bff804 	addi	r2,fp,-32
 3201c1c:	e0bff315 	stw	r2,-52(fp)
 3201c20:	00800804 	movi	r2,32
 3201c24:	e0bff415 	stw	r2,-48(fp)
                                                           alt_flash_fd* fd, 
                                                           int offset, 
                                                           const void* src_addr, 
                                                           int length )
{
  return fd->write( fd, offset, src_addr, length );
 3201c28:	e0bff117 	ldw	r2,-60(fp)
 3201c2c:	10800517 	ldw	r2,20(r2)
 3201c30:	e13ff117 	ldw	r4,-60(fp)
 3201c34:	e17ff217 	ldw	r5,-56(fp)
 3201c38:	e1bff317 	ldw	r6,-52(fp)
 3201c3c:	e1fff417 	ldw	r7,-48(fp)
 3201c40:	103ee83a 	callr	r2
                            last_flash_sector_offset,
                            flash_content,
                            32);
            alt_flash_close_dev(flash_handle);
 3201c44:	e13ff517 	ldw	r4,-44(fp)
 3201c48:	32145d80 	call	32145d8 <alt_flash_close_dev>
            error = 0;
 3201c4c:	e03ff715 	stw	zero,-36(fp)
        }
    }

    return error;    
 3201c50:	e0bff717 	ldw	r2,-36(fp)
}
 3201c54:	e037883a 	mov	sp,fp
 3201c58:	dfc00117 	ldw	ra,4(sp)
 3201c5c:	df000017 	ldw	fp,0(sp)
 3201c60:	dec00204 	addi	sp,sp,8
 3201c64:	f800283a 	ret

03201c68 <generate_mac_addr>:
 * Development Board serial number is 040800017, the corresponding ethernet 
 * number generated will be 00:07:ED:FF:8F:11.
 * 
 */
error_t generate_mac_addr(unsigned char mac_addr[6])
{
 3201c68:	defff804 	addi	sp,sp,-32
 3201c6c:	dfc00715 	stw	ra,28(sp)
 3201c70:	df000615 	stw	fp,24(sp)
 3201c74:	df000604 	addi	fp,sp,24
 3201c78:	e13fff15 	stw	r4,-4(fp)
    error_t error = -1;
 3201c7c:	00bfffc4 	movi	r2,-1
 3201c80:	e0bffe15 	stw	r2,-8(fp)
    alt_u32 ser_num = 0;
 3201c84:	e03ffd15 	stw	zero,-12(fp)
    
    printf("\nCan't read the MAC address from your board. We will assign you\n");
 3201c88:	0100c974 	movhi	r4,805
 3201c8c:	2133af04 	addi	r4,r4,-12612
 3201c90:	3206e040 	call	3206e04 <puts>
    printf("a MAC address.\n\n");
 3201c94:	0100c974 	movhi	r4,805
 3201c98:	2133bf04 	addi	r4,r4,-12548
 3201c9c:	3206e040 	call	3206e04 <puts>
    
    ser_num = get_serial_number();
 3201ca0:	32018c00 	call	32018c0 <get_serial_number>
 3201ca4:	e0bffd15 	stw	r2,-12(fp)
  
    if (ser_num)
 3201ca8:	e0bffd17 	ldw	r2,-12(fp)
 3201cac:	1005003a 	cmpeq	r2,r2,zero
 3201cb0:	1000361e 	bne	r2,zero,3201d8c <generate_mac_addr+0x124>
    {
        /* This is the Altera Vendor ID */
        mac_addr[0] = 0x0;
 3201cb4:	e0bfff17 	ldw	r2,-4(fp)
 3201cb8:	10000005 	stb	zero,0(r2)
        mac_addr[1] = 0x7;
 3201cbc:	e0bfff17 	ldw	r2,-4(fp)
 3201cc0:	10c00044 	addi	r3,r2,1
 3201cc4:	008001c4 	movi	r2,7
 3201cc8:	18800005 	stb	r2,0(r3)
        mac_addr[2] = 0xed;
 3201ccc:	e0bfff17 	ldw	r2,-4(fp)
 3201cd0:	10c00084 	addi	r3,r2,2
 3201cd4:	00bffb44 	movi	r2,-19
 3201cd8:	18800005 	stb	r2,0(r3)
        
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
 3201cdc:	e0bfff17 	ldw	r2,-4(fp)
 3201ce0:	10c000c4 	addi	r3,r2,3
 3201ce4:	00bfffc4 	movi	r2,-1
 3201ce8:	18800005 	stb	r2,0(r3)
        mac_addr[4] = (ser_num & 0xff00) >> 8;
 3201cec:	e0bfff17 	ldw	r2,-4(fp)
 3201cf0:	10c00104 	addi	r3,r2,4
 3201cf4:	e0bffd17 	ldw	r2,-12(fp)
 3201cf8:	10bfc00c 	andi	r2,r2,65280
 3201cfc:	1004d23a 	srli	r2,r2,8
 3201d00:	18800005 	stb	r2,0(r3)
        mac_addr[5] = ser_num & 0xff;
 3201d04:	e0bfff17 	ldw	r2,-4(fp)
 3201d08:	10c00144 	addi	r3,r2,5
 3201d0c:	e0bffd17 	ldw	r2,-12(fp)
 3201d10:	18800005 	stb	r2,0(r3)
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 3201d14:	e0bfff17 	ldw	r2,-4(fp)
 3201d18:	10800003 	ldbu	r2,0(r2)
 3201d1c:	11403fcc 	andi	r5,r2,255
 3201d20:	e0bfff17 	ldw	r2,-4(fp)
 3201d24:	10800044 	addi	r2,r2,1
 3201d28:	10800003 	ldbu	r2,0(r2)
 3201d2c:	11803fcc 	andi	r6,r2,255
 3201d30:	e0bfff17 	ldw	r2,-4(fp)
 3201d34:	10800084 	addi	r2,r2,2
 3201d38:	10800003 	ldbu	r2,0(r2)
 3201d3c:	11c03fcc 	andi	r7,r2,255
 3201d40:	e0bfff17 	ldw	r2,-4(fp)
 3201d44:	108000c4 	addi	r2,r2,3
 3201d48:	10800003 	ldbu	r2,0(r2)
 3201d4c:	10c03fcc 	andi	r3,r2,255
 3201d50:	e0bfff17 	ldw	r2,-4(fp)
 3201d54:	10800104 	addi	r2,r2,4
 3201d58:	10800003 	ldbu	r2,0(r2)
 3201d5c:	11003fcc 	andi	r4,r2,255
 3201d60:	e0bfff17 	ldw	r2,-4(fp)
 3201d64:	10800144 	addi	r2,r2,5
 3201d68:	10800003 	ldbu	r2,0(r2)
 3201d6c:	10803fcc 	andi	r2,r2,255
 3201d70:	d8c00015 	stw	r3,0(sp)
 3201d74:	d9000115 	stw	r4,4(sp)
 3201d78:	d8800215 	stw	r2,8(sp)
 3201d7c:	0100c974 	movhi	r4,805
 3201d80:	2133c304 	addi	r4,r4,-12532
 3201d84:	3206adc0 	call	3206adc <printf>
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
        
        error = 0;
 3201d88:	e03ffe15 	stw	zero,-8(fp)
    }
  
    return error;    
 3201d8c:	e0bffe17 	ldw	r2,-8(fp)
}
 3201d90:	e037883a 	mov	sp,fp
 3201d94:	dfc00117 	ldw	ra,4(sp)
 3201d98:	df000017 	ldw	fp,0(sp)
 3201d9c:	dec00204 	addi	sp,sp,8
 3201da0:	f800283a 	ret

03201da4 <get_board_mac_addr>:
*
* Read the MAC address in a board specific way
*
*/
error_t get_board_mac_addr(unsigned char mac_addr[6])
{
 3201da4:	defff804 	addi	sp,sp,-32
 3201da8:	dfc00715 	stw	ra,28(sp)
 3201dac:	df000615 	stw	fp,24(sp)
 3201db0:	df000604 	addi	fp,sp,24
 3201db4:	e13fff15 	stw	r4,-4(fp)
    error_t error = 0;
 3201db8:	e03ffe15 	stw	zero,-8(fp)
    alt_u32 signature;
    
    /* Get the flash sector with the MAC address. */
    error = FindLastFlashSectorOffset(&last_flash_sector_offset);
 3201dbc:	d1289304 	addi	r4,gp,-23988
 3201dc0:	3201f380 	call	3201f38 <FindLastFlashSectorOffset>
 3201dc4:	e0bffe15 	stw	r2,-8(fp)
    if (!error)
 3201dc8:	e0bffe17 	ldw	r2,-8(fp)
 3201dcc:	1004c03a 	cmpne	r2,r2,zero
 3201dd0:	1000041e 	bne	r2,zero,3201de4 <get_board_mac_addr+0x40>
        last_flash_sector = EXT_FLASH_BASE + last_flash_sector_offset;
 3201dd4:	d0a89317 	ldw	r2,-23988(gp)
 3201dd8:	00c0a034 	movhi	r3,640
 3201ddc:	10c5883a 	add	r2,r2,r3
 3201de0:	d0a89415 	stw	r2,-23984(gp)
     * valid network settings are present, indicated by a signature of 0x00005afe at 
     * the first address of the last flash sector.  This hex value is chosen as the 
     * signature since it looks like the english word "SAFE", meaning that it is 
     * safe to use these network address values.  
    */
    if (!error)
 3201de4:	e0bffe17 	ldw	r2,-8(fp)
 3201de8:	1004c03a 	cmpne	r2,r2,zero
 3201dec:	1000081e 	bne	r2,zero,3201e10 <get_board_mac_addr+0x6c>
    {
        signature = IORD_32DIRECT(last_flash_sector, 0);
 3201df0:	d0a89417 	ldw	r2,-23984(gp)
 3201df4:	10800037 	ldwio	r2,0(r2)
 3201df8:	e0bffd15 	stw	r2,-12(fp)
        if (signature != 0x00005afe)
 3201dfc:	e0bffd17 	ldw	r2,-12(fp)
 3201e00:	1096bfa0 	cmpeqi	r2,r2,23294
 3201e04:	1000021e 	bne	r2,zero,3201e10 <get_board_mac_addr+0x6c>
        {
          error = generate_and_store_mac_addr();
 3201e08:	3201a9c0 	call	3201a9c <generate_and_store_mac_addr>
 3201e0c:	e0bffe15 	stw	r2,-8(fp)
        }
    }
  
    if (!error)
 3201e10:	e0bffe17 	ldw	r2,-8(fp)
 3201e14:	1004c03a 	cmpne	r2,r2,zero
 3201e18:	1000411e 	bne	r2,zero,3201f20 <get_board_mac_addr+0x17c>
    {
        mac_addr[0] = IORD_8DIRECT(last_flash_sector, 4);
 3201e1c:	d0a89417 	ldw	r2,-23984(gp)
 3201e20:	10800104 	addi	r2,r2,4
 3201e24:	10800023 	ldbuio	r2,0(r2)
 3201e28:	1007883a 	mov	r3,r2
 3201e2c:	e0bfff17 	ldw	r2,-4(fp)
 3201e30:	10c00005 	stb	r3,0(r2)
        mac_addr[1] = IORD_8DIRECT(last_flash_sector, 5);
 3201e34:	e0bfff17 	ldw	r2,-4(fp)
 3201e38:	10c00044 	addi	r3,r2,1
 3201e3c:	d0a89417 	ldw	r2,-23984(gp)
 3201e40:	10800144 	addi	r2,r2,5
 3201e44:	10800023 	ldbuio	r2,0(r2)
 3201e48:	18800005 	stb	r2,0(r3)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
 3201e4c:	e0bfff17 	ldw	r2,-4(fp)
 3201e50:	10c00084 	addi	r3,r2,2
 3201e54:	d0a89417 	ldw	r2,-23984(gp)
 3201e58:	10800184 	addi	r2,r2,6
 3201e5c:	10800023 	ldbuio	r2,0(r2)
 3201e60:	18800005 	stb	r2,0(r3)
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
 3201e64:	e0bfff17 	ldw	r2,-4(fp)
 3201e68:	10c000c4 	addi	r3,r2,3
 3201e6c:	d0a89417 	ldw	r2,-23984(gp)
 3201e70:	108001c4 	addi	r2,r2,7
 3201e74:	10800023 	ldbuio	r2,0(r2)
 3201e78:	18800005 	stb	r2,0(r3)
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
 3201e7c:	e0bfff17 	ldw	r2,-4(fp)
 3201e80:	10c00104 	addi	r3,r2,4
 3201e84:	d0a89417 	ldw	r2,-23984(gp)
 3201e88:	10800204 	addi	r2,r2,8
 3201e8c:	10800023 	ldbuio	r2,0(r2)
 3201e90:	18800005 	stb	r2,0(r3)
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
 3201e94:	e0bfff17 	ldw	r2,-4(fp)
 3201e98:	10c00144 	addi	r3,r2,5
 3201e9c:	d0a89417 	ldw	r2,-23984(gp)
 3201ea0:	10800244 	addi	r2,r2,9
 3201ea4:	10800023 	ldbuio	r2,0(r2)
 3201ea8:	18800005 	stb	r2,0(r3)
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 3201eac:	e0bfff17 	ldw	r2,-4(fp)
 3201eb0:	10800003 	ldbu	r2,0(r2)
 3201eb4:	11403fcc 	andi	r5,r2,255
 3201eb8:	e0bfff17 	ldw	r2,-4(fp)
 3201ebc:	10800044 	addi	r2,r2,1
 3201ec0:	10800003 	ldbu	r2,0(r2)
 3201ec4:	11803fcc 	andi	r6,r2,255
 3201ec8:	e0bfff17 	ldw	r2,-4(fp)
 3201ecc:	10800084 	addi	r2,r2,2
 3201ed0:	10800003 	ldbu	r2,0(r2)
 3201ed4:	11c03fcc 	andi	r7,r2,255
 3201ed8:	e0bfff17 	ldw	r2,-4(fp)
 3201edc:	108000c4 	addi	r2,r2,3
 3201ee0:	10800003 	ldbu	r2,0(r2)
 3201ee4:	10c03fcc 	andi	r3,r2,255
 3201ee8:	e0bfff17 	ldw	r2,-4(fp)
 3201eec:	10800104 	addi	r2,r2,4
 3201ef0:	10800003 	ldbu	r2,0(r2)
 3201ef4:	11003fcc 	andi	r4,r2,255
 3201ef8:	e0bfff17 	ldw	r2,-4(fp)
 3201efc:	10800144 	addi	r2,r2,5
 3201f00:	10800003 	ldbu	r2,0(r2)
 3201f04:	10803fcc 	andi	r2,r2,255
 3201f08:	d8c00015 	stw	r3,0(sp)
 3201f0c:	d9000115 	stw	r4,4(sp)
 3201f10:	d8800215 	stw	r2,8(sp)
 3201f14:	0100c974 	movhi	r4,805
 3201f18:	2133c304 	addi	r4,r4,-12532
 3201f1c:	3206adc0 	call	3206adc <printf>
            mac_addr[4],
            mac_addr[5]);
    
    }
    
    return error;
 3201f20:	e0bffe17 	ldw	r2,-8(fp)
}
 3201f24:	e037883a 	mov	sp,fp
 3201f28:	dfc00117 	ldw	ra,4(sp)
 3201f2c:	df000017 	ldw	fp,0(sp)
 3201f30:	dec00204 	addi	sp,sp,8
 3201f34:	f800283a 	ret

03201f38 <FindLastFlashSectorOffset>:
 * in pLastFlashSectorOffset.
 */

int FindLastFlashSectorOffset(
    alt_u32                     *pLastFlashSectorOffset)
{
 3201f38:	defff304 	addi	sp,sp,-52
 3201f3c:	dfc00c15 	stw	ra,48(sp)
 3201f40:	df000b15 	stw	fp,44(sp)
 3201f44:	df000b04 	addi	fp,sp,44
 3201f48:	e13fff15 	stw	r4,-4(fp)
    flash_region                *regions;
    int                         numRegions;
    flash_region                *pLastRegion;
    int                         lastFlashSectorOffset;
    int                         n;
    int                         error = 0;
 3201f4c:	e03ff815 	stw	zero,-32(fp)

    /* Open the flash device. */
    fd = alt_flash_open_dev(EXT_FLASH_NAME);
 3201f50:	0100c974 	movhi	r4,805
 3201f54:	2133ab04 	addi	r4,r4,-12628
 3201f58:	321455c0 	call	321455c <alt_flash_open_dev>
 3201f5c:	e0bffc15 	stw	r2,-16(fp)
    if (fd <= 0)
 3201f60:	e0bffc17 	ldw	r2,-16(fp)
 3201f64:	1004c03a 	cmpne	r2,r2,zero
 3201f68:	1000021e 	bne	r2,zero,3201f74 <FindLastFlashSectorOffset+0x3c>
        error = -1;
 3201f6c:	00bfffc4 	movi	r2,-1
 3201f70:	e0bff815 	stw	r2,-32(fp)

    /* Get the flash info. */
    if (!error)
 3201f74:	e0bff817 	ldw	r2,-32(fp)
 3201f78:	1004c03a 	cmpne	r2,r2,zero
 3201f7c:	10000d1e 	bne	r2,zero,3201fb4 <FindLastFlashSectorOffset+0x7c>
 3201f80:	e0bffc17 	ldw	r2,-16(fp)
 3201f84:	e0bff515 	stw	r2,-44(fp)
 3201f88:	e0bffd04 	addi	r2,fp,-12
 3201f8c:	e0bff615 	stw	r2,-40(fp)
 3201f90:	e0bffe04 	addi	r2,fp,-8
 3201f94:	e0bff715 	stw	r2,-36(fp)
 */
static __inline__ int __attribute__ ((always_inline)) alt_get_flash_info( 
                                      alt_flash_fd* fd, flash_region** info, 
                                      int* number_of_regions)
{
  return fd->get_info( fd, info, number_of_regions);
 3201f98:	e0bff517 	ldw	r2,-44(fp)
 3201f9c:	10800717 	ldw	r2,28(r2)
 3201fa0:	e13ff517 	ldw	r4,-44(fp)
 3201fa4:	e17ff617 	ldw	r5,-40(fp)
 3201fa8:	e1bff717 	ldw	r6,-36(fp)
 3201fac:	103ee83a 	callr	r2
        error = alt_get_flash_info(fd, &regions, &numRegions);
 3201fb0:	e0bff815 	stw	r2,-32(fp)

    /* Find the last flash sector. */
    if (!error)
 3201fb4:	e0bff817 	ldw	r2,-32(fp)
 3201fb8:	1004c03a 	cmpne	r2,r2,zero
 3201fbc:	1000231e 	bne	r2,zero,320204c <FindLastFlashSectorOffset+0x114>
    {
        pLastRegion = &(regions[0]);
 3201fc0:	e0bffd17 	ldw	r2,-12(fp)
 3201fc4:	e0bffb15 	stw	r2,-20(fp)
        for (n = 1; n < numRegions; n++)
 3201fc8:	00800044 	movi	r2,1
 3201fcc:	e0bff915 	stw	r2,-28(fp)
 3201fd0:	00001206 	br	320201c <FindLastFlashSectorOffset+0xe4>
        {
            if (regions[n].offset > pLastRegion->offset)
 3201fd4:	e0bff917 	ldw	r2,-28(fp)
 3201fd8:	1004913a 	slli	r2,r2,4
 3201fdc:	1007883a 	mov	r3,r2
 3201fe0:	e0bffd17 	ldw	r2,-12(fp)
 3201fe4:	1885883a 	add	r2,r3,r2
 3201fe8:	10c00017 	ldw	r3,0(r2)
 3201fec:	e0bffb17 	ldw	r2,-20(fp)
 3201ff0:	10800017 	ldw	r2,0(r2)
 3201ff4:	10c0060e 	bge	r2,r3,3202010 <FindLastFlashSectorOffset+0xd8>
                pLastRegion = &(regions[n]);
 3201ff8:	e0bff917 	ldw	r2,-28(fp)
 3201ffc:	1004913a 	slli	r2,r2,4
 3202000:	1007883a 	mov	r3,r2
 3202004:	e0bffd17 	ldw	r2,-12(fp)
 3202008:	1885883a 	add	r2,r3,r2
 320200c:	e0bffb15 	stw	r2,-20(fp)

    /* Find the last flash sector. */
    if (!error)
    {
        pLastRegion = &(regions[0]);
        for (n = 1; n < numRegions; n++)
 3202010:	e0bff917 	ldw	r2,-28(fp)
 3202014:	10800044 	addi	r2,r2,1
 3202018:	e0bff915 	stw	r2,-28(fp)
 320201c:	e0fffe17 	ldw	r3,-8(fp)
 3202020:	e0bff917 	ldw	r2,-28(fp)
 3202024:	10ffeb16 	blt	r2,r3,3201fd4 <FindLastFlashSectorOffset+0x9c>
        {
            if (regions[n].offset > pLastRegion->offset)
                pLastRegion = &(regions[n]);
        }
        lastFlashSectorOffset =   pLastRegion->offset
 3202028:	e0bffb17 	ldw	r2,-20(fp)
 320202c:	10c00017 	ldw	r3,0(r2)
 3202030:	e0bffb17 	ldw	r2,-20(fp)
 3202034:	10800117 	ldw	r2,4(r2)
 3202038:	1887883a 	add	r3,r3,r2
 320203c:	e0bffb17 	ldw	r2,-20(fp)
 3202040:	10800317 	ldw	r2,12(r2)
 3202044:	1885c83a 	sub	r2,r3,r2
 3202048:	e0bffa15 	stw	r2,-24(fp)
                                + pLastRegion->region_size
                                - pLastRegion->block_size;
    }

    /* Return results. */
    if (!error)
 320204c:	e0bff817 	ldw	r2,-32(fp)
 3202050:	1004c03a 	cmpne	r2,r2,zero
 3202054:	1000031e 	bne	r2,zero,3202064 <FindLastFlashSectorOffset+0x12c>
        *pLastFlashSectorOffset = lastFlashSectorOffset;
 3202058:	e0fffa17 	ldw	r3,-24(fp)
 320205c:	e0bfff17 	ldw	r2,-4(fp)
 3202060:	10c00015 	stw	r3,0(r2)

    return (error);
 3202064:	e0bff817 	ldw	r2,-32(fp)
}
 3202068:	e037883a 	mov	sp,fp
 320206c:	dfc00117 	ldw	ra,4(sp)
 3202070:	df000017 	ldw	fp,0(sp)
 3202074:	dec00204 	addi	sp,sp,8
 3202078:	f800283a 	ret

0320207c <sss_reset_connection>:
 * This routine will, when called, reset our SSSConn struct's members 
 * to a reliable initial state. Note that we set our socket (FD) number to
 * -1 to easily determine whether the connection is in a "reset, ready to go" 
 * state.
 */
void sss_reset_connection(SSSConn* conn) {
 320207c:	defffd04 	addi	sp,sp,-12
 3202080:	dfc00215 	stw	ra,8(sp)
 3202084:	df000115 	stw	fp,4(sp)
 3202088:	df000104 	addi	fp,sp,4
 320208c:	e13fff15 	stw	r4,-4(fp)
	memset(conn, 0, sizeof(SSSConn));
 3202090:	e0bfff17 	ldw	r2,-4(fp)
 3202094:	1009883a 	mov	r4,r2
 3202098:	01820504 	movi	r6,2068
 320209c:	000b883a 	mov	r5,zero
 32020a0:	320694c0 	call	320694c <memset>

	conn->fd = -1;
 32020a4:	e0ffff17 	ldw	r3,-4(fp)
 32020a8:	00bfffc4 	movi	r2,-1
 32020ac:	18800115 	stw	r2,4(r3)
	conn->state = READY;
 32020b0:	e0bfff17 	ldw	r2,-4(fp)
 32020b4:	10000015 	stw	zero,0(r2)
	conn->rx_wr_pos = conn->rx_buffer;
 32020b8:	e0bfff17 	ldw	r2,-4(fp)
 32020bc:	10c00304 	addi	r3,r2,12
 32020c0:	e0bfff17 	ldw	r2,-4(fp)
 32020c4:	10c20415 	stw	r3,2064(r2)
	conn->rx_rd_pos = conn->rx_buffer;
 32020c8:	e0bfff17 	ldw	r2,-4(fp)
 32020cc:	10c00304 	addi	r3,r2,12
 32020d0:	e0bfff17 	ldw	r2,-4(fp)
 32020d4:	10c20315 	stw	r3,2060(r2)
}
 32020d8:	e037883a 	mov	sp,fp
 32020dc:	dfc00117 	ldw	ra,4(sp)
 32020e0:	df000017 	ldw	fp,0(sp)
 32020e4:	dec00204 	addi	sp,sp,8
 32020e8:	f800283a 	ret

032020ec <sss_send_menu>:
/*
 * sss_send_menu()
 * 
 * This routine will transmit the menu out to the telnet client.
 */
void sss_send_menu(SSSConn* conn) {
 32020ec:	defdfc04 	addi	sp,sp,-2064
 32020f0:	dfc20315 	stw	ra,2060(sp)
 32020f4:	df020215 	stw	fp,2056(sp)
 32020f8:	df020204 	addi	fp,sp,2056
 32020fc:	e13fff15 	stw	r4,-4(fp)
	alt_u8  tx_buf[SSS_TX_BUF_SIZE];
	alt_u8 *tx_wr_pos = tx_buf;
 3202100:	e0bdff04 	addi	r2,fp,-2052
 3202104:	e0bdfe15 	stw	r2,-2056(fp)

	tx_wr_pos += sprintf(tx_wr_pos, "===========================================\n");
 3202108:	e0bdfe17 	ldw	r2,-2056(fp)
 320210c:	00c0c974 	movhi	r3,805
 3202110:	18f3d204 	addi	r3,r3,-12472
 3202114:	1009883a 	mov	r4,r2
 3202118:	180b883a 	mov	r5,r3
 320211c:	01800b44 	movi	r6,45
 3202120:	32067cc0 	call	32067cc <memcpy>
 3202124:	e0bdfe17 	ldw	r2,-2056(fp)
 3202128:	10800b04 	addi	r2,r2,44
 320212c:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "Nios II Camera Commands Menu               \n");
 3202130:	e0bdfe17 	ldw	r2,-2056(fp)
 3202134:	00c0c974 	movhi	r3,805
 3202138:	18f3de04 	addi	r3,r3,-12424
 320213c:	1009883a 	mov	r4,r2
 3202140:	180b883a 	mov	r5,r3
 3202144:	01800b44 	movi	r6,45
 3202148:	32067cc0 	call	32067cc <memcpy>
 320214c:	e0bdfe17 	ldw	r2,-2056(fp)
 3202150:	10800b04 	addi	r2,r2,44
 3202154:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "===========================================\n");
 3202158:	e0bdfe17 	ldw	r2,-2056(fp)
 320215c:	00c0c974 	movhi	r3,805
 3202160:	18f3d204 	addi	r3,r3,-12472
 3202164:	1009883a 	mov	r4,r2
 3202168:	180b883a 	mov	r5,r3
 320216c:	01800b44 	movi	r6,45
 3202170:	32067cc0 	call	32067cc <memcpy>
 3202174:	e0bdfe17 	ldw	r2,-2056(fp)
 3202178:	10800b04 	addi	r2,r2,44
 320217c:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "                                           \n");
 3202180:	e0bdfe17 	ldw	r2,-2056(fp)
 3202184:	00c0c974 	movhi	r3,805
 3202188:	18f3ea04 	addi	r3,r3,-12376
 320218c:	1009883a 	mov	r4,r2
 3202190:	180b883a 	mov	r5,r3
 3202194:	01800b44 	movi	r6,45
 3202198:	32067cc0 	call	32067cc <memcpy>
 320219c:	e0bdfe17 	ldw	r2,-2056(fp)
 32021a0:	10800b04 	addi	r2,r2,44
 32021a4:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "r,xx: Read value of register (xx)          \n");
 32021a8:	e0bdfe17 	ldw	r2,-2056(fp)
 32021ac:	00c0c974 	movhi	r3,805
 32021b0:	18f3f604 	addi	r3,r3,-12328
 32021b4:	1009883a 	mov	r4,r2
 32021b8:	180b883a 	mov	r5,r3
 32021bc:	01800b44 	movi	r6,45
 32021c0:	32067cc0 	call	32067cc <memcpy>
 32021c4:	e0bdfe17 	ldw	r2,-2056(fp)
 32021c8:	10800b04 	addi	r2,r2,44
 32021cc:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "w,xx,yy: Write value (yy) in register (xx) \n");
 32021d0:	e0bdfe17 	ldw	r2,-2056(fp)
 32021d4:	00c0c974 	movhi	r3,805
 32021d8:	18f40204 	addi	r3,r3,-12280
 32021dc:	1009883a 	mov	r4,r2
 32021e0:	180b883a 	mov	r5,r3
 32021e4:	01800b44 	movi	r6,45
 32021e8:	32067cc0 	call	32067cc <memcpy>
 32021ec:	e0bdfe17 	ldw	r2,-2056(fp)
 32021f0:	10800b04 	addi	r2,r2,44
 32021f4:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "                                           \n");
 32021f8:	e0bdfe17 	ldw	r2,-2056(fp)
 32021fc:	00c0c974 	movhi	r3,805
 3202200:	18f3ea04 	addi	r3,r3,-12376
 3202204:	1009883a 	mov	r4,r2
 3202208:	180b883a 	mov	r5,r3
 320220c:	01800b44 	movi	r6,45
 3202210:	32067cc0 	call	32067cc <memcpy>
 3202214:	e0bdfe17 	ldw	r2,-2056(fp)
 3202218:	10800b04 	addi	r2,r2,44
 320221c:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "C: Configure camera sensor                 \n");
 3202220:	e0bdfe17 	ldw	r2,-2056(fp)
 3202224:	00c0c974 	movhi	r3,805
 3202228:	18f40e04 	addi	r3,r3,-12232
 320222c:	1009883a 	mov	r4,r2
 3202230:	180b883a 	mov	r5,r3
 3202234:	01800b44 	movi	r6,45
 3202238:	32067cc0 	call	32067cc <memcpy>
 320223c:	e0bdfe17 	ldw	r2,-2056(fp)
 3202240:	10800b04 	addi	r2,r2,44
 3202244:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "S: Start/Stop capture                      \n");
 3202248:	e0bdfe17 	ldw	r2,-2056(fp)
 320224c:	00c0c974 	movhi	r3,805
 3202250:	18f41a04 	addi	r3,r3,-12184
 3202254:	1009883a 	mov	r4,r2
 3202258:	180b883a 	mov	r5,r3
 320225c:	01800b44 	movi	r6,45
 3202260:	32067cc0 	call	32067cc <memcpy>
 3202264:	e0bdfe17 	ldw	r2,-2056(fp)
 3202268:	10800b04 	addi	r2,r2,44
 320226c:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "D: Send RGB image data                     \n");
 3202270:	e0bdfe17 	ldw	r2,-2056(fp)
 3202274:	00c0c974 	movhi	r3,805
 3202278:	18f42604 	addi	r3,r3,-12136
 320227c:	1009883a 	mov	r4,r2
 3202280:	180b883a 	mov	r5,r3
 3202284:	01800b44 	movi	r6,45
 3202288:	32067cc0 	call	32067cc <memcpy>
 320228c:	e0bdfe17 	ldw	r2,-2056(fp)
 3202290:	10800b04 	addi	r2,r2,44
 3202294:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "G: Send gray image data                    \n");
 3202298:	e0bdfe17 	ldw	r2,-2056(fp)
 320229c:	00c0c974 	movhi	r3,805
 32022a0:	18f43204 	addi	r3,r3,-12088
 32022a4:	1009883a 	mov	r4,r2
 32022a8:	180b883a 	mov	r5,r3
 32022ac:	01800b44 	movi	r6,45
 32022b0:	32067cc0 	call	32067cc <memcpy>
 32022b4:	e0bdfe17 	ldw	r2,-2056(fp)
 32022b8:	10800b04 	addi	r2,r2,44
 32022bc:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "V: VGA (live video mode)                   \n");
 32022c0:	e0bdfe17 	ldw	r2,-2056(fp)
 32022c4:	00c0c974 	movhi	r3,805
 32022c8:	18f43e04 	addi	r3,r3,-12040
 32022cc:	1009883a 	mov	r4,r2
 32022d0:	180b883a 	mov	r5,r3
 32022d4:	01800b44 	movi	r6,45
 32022d8:	32067cc0 	call	32067cc <memcpy>
 32022dc:	e0bdfe17 	ldw	r2,-2056(fp)
 32022e0:	10800b04 	addi	r2,r2,44
 32022e4:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "                                           \n");
 32022e8:	e0bdfe17 	ldw	r2,-2056(fp)
 32022ec:	00c0c974 	movhi	r3,805
 32022f0:	18f3ea04 	addi	r3,r3,-12376
 32022f4:	1009883a 	mov	r4,r2
 32022f8:	180b883a 	mov	r5,r3
 32022fc:	01800b44 	movi	r6,45
 3202300:	32067cc0 	call	32067cc <memcpy>
 3202304:	e0bdfe17 	ldw	r2,-2056(fp)
 3202308:	10800b04 	addi	r2,r2,44
 320230c:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "Q: Terminate session                       \n");
 3202310:	e0bdfe17 	ldw	r2,-2056(fp)
 3202314:	00c0c974 	movhi	r3,805
 3202318:	18f44a04 	addi	r3,r3,-11992
 320231c:	1009883a 	mov	r4,r2
 3202320:	180b883a 	mov	r5,r3
 3202324:	01800b44 	movi	r6,45
 3202328:	32067cc0 	call	32067cc <memcpy>
 320232c:	e0bdfe17 	ldw	r2,-2056(fp)
 3202330:	10800b04 	addi	r2,r2,44
 3202334:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "===========================================\n");
 3202338:	e0bdfe17 	ldw	r2,-2056(fp)
 320233c:	00c0c974 	movhi	r3,805
 3202340:	18f3d204 	addi	r3,r3,-12472
 3202344:	1009883a 	mov	r4,r2
 3202348:	180b883a 	mov	r5,r3
 320234c:	01800b44 	movi	r6,45
 3202350:	32067cc0 	call	32067cc <memcpy>
 3202354:	e0bdfe17 	ldw	r2,-2056(fp)
 3202358:	10800b04 	addi	r2,r2,44
 320235c:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "Enter your choice & press return:>\n");
 3202360:	e0bdfe17 	ldw	r2,-2056(fp)
 3202364:	00c0c974 	movhi	r3,805
 3202368:	18f45604 	addi	r3,r3,-11944
 320236c:	1009883a 	mov	r4,r2
 3202370:	180b883a 	mov	r5,r3
 3202374:	01800904 	movi	r6,36
 3202378:	32067cc0 	call	32067cc <memcpy>
 320237c:	e0bdfe17 	ldw	r2,-2056(fp)
 3202380:	108008c4 	addi	r2,r2,35
 3202384:	e0bdfe15 	stw	r2,-2056(fp)

	send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
 3202388:	e0bfff17 	ldw	r2,-4(fp)
 320238c:	11000117 	ldw	r4,4(r2)
 3202390:	e17dff04 	addi	r5,fp,-2052
 3202394:	e0fdfe17 	ldw	r3,-2056(fp)
 3202398:	e0bdff04 	addi	r2,fp,-2052
 320239c:	188dc83a 	sub	r6,r3,r2
 32023a0:	000f883a 	mov	r7,zero
 32023a4:	322eeb00 	call	322eeb0 <t_send>
}
 32023a8:	e037883a 	mov	sp,fp
 32023ac:	dfc00117 	ldw	ra,4(sp)
 32023b0:	df000017 	ldw	fp,0(sp)
 32023b4:	dec00204 	addi	sp,sp,8
 32023b8:	f800283a 	ret

032023bc <sss_exec_command>:
 * If the user wishes to quit, we set the "close" member of our SSSConn
 * struct, which will be looked at back in sss_handle_receive() when it 
 * comes time to see whether to close the connection or not.
 */

void sss_exec_command(SSSConn* conn) {
 32023bc:	defddd04 	addi	sp,sp,-2188
 32023c0:	dfc22215 	stw	ra,2184(sp)
 32023c4:	df022115 	stw	fp,2180(sp)
 32023c8:	dc022015 	stw	r16,2176(sp)
 32023cc:	df022004 	addi	fp,sp,2176
 32023d0:	e13ff915 	stw	r4,-28(fp)
	int bytes_to_process = conn->rx_wr_pos - conn->rx_rd_pos;
 32023d4:	e0bff917 	ldw	r2,-28(fp)
 32023d8:	10820417 	ldw	r2,2064(r2)
 32023dc:	1007883a 	mov	r3,r2
 32023e0:	e0bff917 	ldw	r2,-28(fp)
 32023e4:	10820317 	ldw	r2,2060(r2)
 32023e8:	1885c83a 	sub	r2,r3,r2
 32023ec:	e0bdf215 	stw	r2,-2104(fp)
	INT8U tx_buf[SSS_TX_BUF_SIZE];
	INT8U *tx_wr_pos = tx_buf;
 32023f0:	e0bdf304 	addi	r2,fp,-2100
 32023f4:	e0bdf115 	stw	r2,-2108(fp)
     * SSSSimpleSocketServerTask, since the LEDManagementTask does not
     * have access to the stack of the SSSSimpleSocketServerTask.
     */
    static INT32U SSSCommand;

    INT8U send_data = 0;
 32023f8:	e03df005 	stb	zero,-2112(fp)

    // Command parser
    char cmd;
    char reg[2];
    int data0, data1, data2, data3, data4;
    int captured = 0;
 32023fc:	e03def15 	stw	zero,-2116(fp)
    int _captured = 0;
 3202400:	e03dee15 	stw	zero,-2120(fp)

    //printf("(%i) %s", strlen(conn->rx_rd_pos), conn->rx_rd_pos);
    sscanf(conn->rx_rd_pos, "%c,%c%c,%i,%i,%i,%i,%i", &cmd, &reg[0], &reg[1],
 3202404:	e0bff917 	ldw	r2,-28(fp)
 3202408:	10820317 	ldw	r2,2060(r2)
 320240c:	1009883a 	mov	r4,r2
 3202410:	e0bff344 	addi	r2,fp,-51
 3202414:	10800044 	addi	r2,r2,1
 3202418:	e1bff304 	addi	r6,fp,-52
 320241c:	e1fff344 	addi	r7,fp,-51
 3202420:	d8800015 	stw	r2,0(sp)
 3202424:	e0bff404 	addi	r2,fp,-48
 3202428:	d8800115 	stw	r2,4(sp)
 320242c:	e0bff504 	addi	r2,fp,-44
 3202430:	d8800215 	stw	r2,8(sp)
 3202434:	e0bff604 	addi	r2,fp,-40
 3202438:	d8800315 	stw	r2,12(sp)
 320243c:	e0bff704 	addi	r2,fp,-36
 3202440:	d8800415 	stw	r2,16(sp)
 3202444:	e0bff804 	addi	r2,fp,-32
 3202448:	d8800515 	stw	r2,20(sp)
 320244c:	0140c974 	movhi	r5,805
 3202450:	29745f04 	addi	r5,r5,-11908
 3202454:	32078200 	call	3207820 <sscanf>
    	   &data0, &data1, &data2, &data3, &data4);

	bytes_to_process--;
 3202458:	e0bdf217 	ldw	r2,-2104(fp)
 320245c:	10bfffc4 	addi	r2,r2,-1
 3202460:	e0bdf215 	stw	r2,-2104(fp)
    SSSCommand = toupper(*(conn->rx_rd_pos++));
 3202464:	e0bff917 	ldw	r2,-28(fp)
 3202468:	10c20317 	ldw	r3,2060(r2)
 320246c:	18800003 	ldbu	r2,0(r3)
 3202470:	10803fcc 	andi	r2,r2,255
 3202474:	e0bded15 	stw	r2,-2124(fp)
 3202478:	18c00044 	addi	r3,r3,1
 320247c:	e0bff917 	ldw	r2,-28(fp)
 3202480:	10c20315 	stw	r3,2060(r2)
 3202484:	0080c974 	movhi	r2,805
 3202488:	10897704 	addi	r2,r2,9692
 320248c:	10c00017 	ldw	r3,0(r2)
 3202490:	e0bded17 	ldw	r2,-2124(fp)
 3202494:	1885883a 	add	r2,r3,r2
 3202498:	10800003 	ldbu	r2,0(r2)
 320249c:	10803fcc 	andi	r2,r2,255
 32024a0:	1080008c 	andi	r2,r2,2
 32024a4:	1005003a 	cmpeq	r2,r2,zero
 32024a8:	1000041e 	bne	r2,zero,32024bc <sss_exec_command+0x100>
 32024ac:	e0bded17 	ldw	r2,-2124(fp)
 32024b0:	10bff804 	addi	r2,r2,-32
 32024b4:	e0bffe15 	stw	r2,-8(fp)
 32024b8:	00000206 	br	32024c4 <sss_exec_command+0x108>
 32024bc:	e0bded17 	ldw	r2,-2124(fp)
 32024c0:	e0bffe15 	stw	r2,-8(fp)
 32024c4:	e0bffe17 	ldw	r2,-8(fp)
 32024c8:	d0a89515 	stw	r2,-23980(gp)
    while (bytes_to_process--) {
 32024cc:	00000506 	br	32024e4 <sss_exec_command+0x128>
    	*(conn->rx_rd_pos++);
 32024d0:	e0bff917 	ldw	r2,-28(fp)
 32024d4:	10820317 	ldw	r2,2060(r2)
 32024d8:	10c00044 	addi	r3,r2,1
 32024dc:	e0bff917 	ldw	r2,-28(fp)
 32024e0:	10c20315 	stw	r3,2060(r2)
    sscanf(conn->rx_rd_pos, "%c,%c%c,%i,%i,%i,%i,%i", &cmd, &reg[0], &reg[1],
    	   &data0, &data1, &data2, &data3, &data4);

	bytes_to_process--;
    SSSCommand = toupper(*(conn->rx_rd_pos++));
    while (bytes_to_process--) {
 32024e4:	e0bdf217 	ldw	r2,-2104(fp)
 32024e8:	10bfffc4 	addi	r2,r2,-1
 32024ec:	e0bdf215 	stw	r2,-2104(fp)
 32024f0:	e0bdf217 	ldw	r2,-2104(fp)
 32024f4:	10bfffd8 	cmpnei	r2,r2,-1
 32024f8:	103ff51e 	bne	r2,zero,32024d0 <sss_exec_command+0x114>
    	*(conn->rx_rd_pos++);
    }

    switch(SSSCommand) {
 32024fc:	d0a89517 	ldw	r2,-23980(gp)
 3202500:	10bfef44 	addi	r2,r2,-67
 3202504:	e0bfff15 	stw	r2,-4(fp)
 3202508:	e0ffff17 	ldw	r3,-4(fp)
 320250c:	18800568 	cmpgeui	r2,r3,21
 3202510:	10031b1e 	bne	r2,zero,3203180 <sss_exec_command+0xdc4>
 3202514:	e13fff17 	ldw	r4,-4(fp)
 3202518:	e13fff17 	ldw	r4,-4(fp)
 320251c:	2105883a 	add	r2,r4,r4
 3202520:	1087883a 	add	r3,r2,r2
 3202524:	0080c834 	movhi	r2,800
 3202528:	10894e04 	addi	r2,r2,9528
 320252c:	1885883a 	add	r2,r3,r2
 3202530:	10800017 	ldw	r2,0(r2)
 3202534:	1000683a 	jmp	r2
 3202538:	03203060 	cmpeqi	r12,zero,-32575
 320253c:	03203100 	call	320310 <OSCtxSw_SWITCH_PC+0x3202d0>
 3202540:	03203180 	call	320318 <OSCtxSw_SWITCH_PC+0x3202d8>
 3202544:	03203180 	call	320318 <OSCtxSw_SWITCH_PC+0x3202d8>
 3202548:	03203120 	cmpeqi	r12,zero,-32572
 320254c:	03203180 	call	320318 <OSCtxSw_SWITCH_PC+0x3202d8>
 3202550:	03203180 	call	320318 <OSCtxSw_SWITCH_PC+0x3202d8>
 3202554:	03203180 	call	320318 <OSCtxSw_SWITCH_PC+0x3202d8>
 3202558:	03203180 	call	320318 <OSCtxSw_SWITCH_PC+0x3202d8>
 320255c:	03203180 	call	320318 <OSCtxSw_SWITCH_PC+0x3202d8>
 3202560:	03203180 	call	320318 <OSCtxSw_SWITCH_PC+0x3202d8>
 3202564:	03203180 	call	320318 <OSCtxSw_SWITCH_PC+0x3202d8>
 3202568:	03203180 	call	320318 <OSCtxSw_SWITCH_PC+0x3202d8>
 320256c:	03203180 	call	320318 <OSCtxSw_SWITCH_PC+0x3202d8>
 3202570:	03203180 	call	320318 <OSCtxSw_SWITCH_PC+0x3202d8>
 3202574:	0320258c 	andi	r12,zero,32918
 3202578:	032030a0 	cmpeqi	r12,zero,-32574
 320257c:	03203180 	call	320318 <OSCtxSw_SWITCH_PC+0x3202d8>
 3202580:	03203180 	call	320318 <OSCtxSw_SWITCH_PC+0x3202d8>
 3202584:	03203140 	call	320314 <OSCtxSw_SWITCH_PC+0x3202d4>
 3202588:	03202ae0 	cmpeqi	r12,zero,-32597
		case CMD_READ:
			/* Reads camera image registers */
			if (reg[0] == 'i' && reg[1] == 's') { // image size (width, height)
 320258c:	e0bff343 	ldbu	r2,-51(fp)
 3202590:	10803fcc 	andi	r2,r2,255
 3202594:	1080201c 	xori	r2,r2,128
 3202598:	10bfe004 	addi	r2,r2,-128
 320259c:	10801a58 	cmpnei	r2,r2,105
 32025a0:	10000f1e 	bne	r2,zero,32025e0 <sss_exec_command+0x224>
 32025a4:	e0bff383 	ldbu	r2,-50(fp)
 32025a8:	10803fcc 	andi	r2,r2,255
 32025ac:	1080201c 	xori	r2,r2,128
 32025b0:	10bfe004 	addi	r2,r2,-128
 32025b4:	10801cd8 	cmpnei	r2,r2,115
 32025b8:	1000091e 	bne	r2,zero,32025e0 <sss_exec_command+0x224>
				tx_wr_pos += get_image_size(&camera, tx_wr_pos);
 32025bc:	e17df117 	ldw	r5,-2108(fp)
 32025c0:	0100c974 	movhi	r4,805
 32025c4:	21018a04 	addi	r4,r4,1576
 32025c8:	32010300 	call	3201030 <get_image_size>
 32025cc:	1007883a 	mov	r3,r2
 32025d0:	e0bdf117 	ldw	r2,-2108(fp)
 32025d4:	10c5883a 	add	r2,r2,r3
 32025d8:	e0bdf115 	stw	r2,-2108(fp)
    }

    switch(SSSCommand) {
		case CMD_READ:
			/* Reads camera image registers */
			if (reg[0] == 'i' && reg[1] == 's') { // image size (width, height)
 32025dc:	00013806 	br	3202ac0 <sss_exec_command+0x704>
				tx_wr_pos += get_image_size(&camera, tx_wr_pos);
			}
			else if (reg[0] == 'i' && reg[1] == 'e') { // image exposure (exposure)
 32025e0:	e0bff343 	ldbu	r2,-51(fp)
 32025e4:	10803fcc 	andi	r2,r2,255
 32025e8:	1080201c 	xori	r2,r2,128
 32025ec:	10bfe004 	addi	r2,r2,-128
 32025f0:	10801a58 	cmpnei	r2,r2,105
 32025f4:	10000f1e 	bne	r2,zero,3202634 <sss_exec_command+0x278>
 32025f8:	e0bff383 	ldbu	r2,-50(fp)
 32025fc:	10803fcc 	andi	r2,r2,255
 3202600:	1080201c 	xori	r2,r2,128
 3202604:	10bfe004 	addi	r2,r2,-128
 3202608:	10801958 	cmpnei	r2,r2,101
 320260c:	1000091e 	bne	r2,zero,3202634 <sss_exec_command+0x278>
				tx_wr_pos += get_image_exposure(&camera, tx_wr_pos);
 3202610:	e17df117 	ldw	r5,-2108(fp)
 3202614:	0100c974 	movhi	r4,805
 3202618:	21018a04 	addi	r4,r4,1576
 320261c:	32010e00 	call	32010e0 <get_image_exposure>
 3202620:	1007883a 	mov	r3,r2
 3202624:	e0bdf117 	ldw	r2,-2108(fp)
 3202628:	10c5883a 	add	r2,r2,r3
 320262c:	e0bdf115 	stw	r2,-2108(fp)
		case CMD_READ:
			/* Reads camera image registers */
			if (reg[0] == 'i' && reg[1] == 's') { // image size (width, height)
				tx_wr_pos += get_image_size(&camera, tx_wr_pos);
			}
			else if (reg[0] == 'i' && reg[1] == 'e') { // image exposure (exposure)
 3202630:	00012306 	br	3202ac0 <sss_exec_command+0x704>
				tx_wr_pos += get_image_exposure(&camera, tx_wr_pos);
			}
			else if (reg[0] == 's' && reg[1] == 'i') { // start image (start_column, start_row)
 3202634:	e0bff343 	ldbu	r2,-51(fp)
 3202638:	10803fcc 	andi	r2,r2,255
 320263c:	1080201c 	xori	r2,r2,128
 3202640:	10bfe004 	addi	r2,r2,-128
 3202644:	10801cd8 	cmpnei	r2,r2,115
 3202648:	10000f1e 	bne	r2,zero,3202688 <sss_exec_command+0x2cc>
 320264c:	e0bff383 	ldbu	r2,-50(fp)
 3202650:	10803fcc 	andi	r2,r2,255
 3202654:	1080201c 	xori	r2,r2,128
 3202658:	10bfe004 	addi	r2,r2,-128
 320265c:	10801a58 	cmpnei	r2,r2,105
 3202660:	1000091e 	bne	r2,zero,3202688 <sss_exec_command+0x2cc>
				tx_wr_pos += get_start_image(&camera, tx_wr_pos);
 3202664:	e17df117 	ldw	r5,-2108(fp)
 3202668:	0100c974 	movhi	r4,805
 320266c:	21018a04 	addi	r4,r4,1576
 3202670:	32011780 	call	3201178 <get_start_image>
 3202674:	1007883a 	mov	r3,r2
 3202678:	e0bdf117 	ldw	r2,-2108(fp)
 320267c:	10c5883a 	add	r2,r2,r3
 3202680:	e0bdf115 	stw	r2,-2108(fp)
				tx_wr_pos += get_image_size(&camera, tx_wr_pos);
			}
			else if (reg[0] == 'i' && reg[1] == 'e') { // image exposure (exposure)
				tx_wr_pos += get_image_exposure(&camera, tx_wr_pos);
			}
			else if (reg[0] == 's' && reg[1] == 'i') { // start image (start_column, start_row)
 3202684:	00010e06 	br	3202ac0 <sss_exec_command+0x704>
				tx_wr_pos += get_start_image(&camera, tx_wr_pos);
			}
			else if (reg[0] == 's' && reg[1] == 's') { // sensor size (column_size, row_size)
 3202688:	e0bff343 	ldbu	r2,-51(fp)
 320268c:	10803fcc 	andi	r2,r2,255
 3202690:	1080201c 	xori	r2,r2,128
 3202694:	10bfe004 	addi	r2,r2,-128
 3202698:	10801cd8 	cmpnei	r2,r2,115
 320269c:	10000f1e 	bne	r2,zero,32026dc <sss_exec_command+0x320>
 32026a0:	e0bff383 	ldbu	r2,-50(fp)
 32026a4:	10803fcc 	andi	r2,r2,255
 32026a8:	1080201c 	xori	r2,r2,128
 32026ac:	10bfe004 	addi	r2,r2,-128
 32026b0:	10801cd8 	cmpnei	r2,r2,115
 32026b4:	1000091e 	bne	r2,zero,32026dc <sss_exec_command+0x320>
				tx_wr_pos += get_sensor_size(&camera, tx_wr_pos);
 32026b8:	e17df117 	ldw	r5,-2108(fp)
 32026bc:	0100c974 	movhi	r4,805
 32026c0:	21018a04 	addi	r4,r4,1576
 32026c4:	32012280 	call	3201228 <get_sensor_size>
 32026c8:	1007883a 	mov	r3,r2
 32026cc:	e0bdf117 	ldw	r2,-2108(fp)
 32026d0:	10c5883a 	add	r2,r2,r3
 32026d4:	e0bdf115 	stw	r2,-2108(fp)
				tx_wr_pos += get_image_exposure(&camera, tx_wr_pos);
			}
			else if (reg[0] == 's' && reg[1] == 'i') { // start image (start_column, start_row)
				tx_wr_pos += get_start_image(&camera, tx_wr_pos);
			}
			else if (reg[0] == 's' && reg[1] == 's') { // sensor size (column_size, row_size)
 32026d8:	0000f906 	br	3202ac0 <sss_exec_command+0x704>
				tx_wr_pos += get_sensor_size(&camera, tx_wr_pos);
			}
			else if (reg[0] == 's' && reg[1] == 'm') { // sensor mode (column_mode, row_mode)
 32026dc:	e0bff343 	ldbu	r2,-51(fp)
 32026e0:	10803fcc 	andi	r2,r2,255
 32026e4:	1080201c 	xori	r2,r2,128
 32026e8:	10bfe004 	addi	r2,r2,-128
 32026ec:	10801cd8 	cmpnei	r2,r2,115
 32026f0:	10000f1e 	bne	r2,zero,3202730 <sss_exec_command+0x374>
 32026f4:	e0bff383 	ldbu	r2,-50(fp)
 32026f8:	10803fcc 	andi	r2,r2,255
 32026fc:	1080201c 	xori	r2,r2,128
 3202700:	10bfe004 	addi	r2,r2,-128
 3202704:	10801b58 	cmpnei	r2,r2,109
 3202708:	1000091e 	bne	r2,zero,3202730 <sss_exec_command+0x374>
				tx_wr_pos += get_sensor_mode(&camera, tx_wr_pos);
 320270c:	e17df117 	ldw	r5,-2108(fp)
 3202710:	0100c974 	movhi	r4,805
 3202714:	21018a04 	addi	r4,r4,1576
 3202718:	32012d80 	call	32012d8 <get_sensor_mode>
 320271c:	1007883a 	mov	r3,r2
 3202720:	e0bdf117 	ldw	r2,-2108(fp)
 3202724:	10c5883a 	add	r2,r2,r3
 3202728:	e0bdf115 	stw	r2,-2108(fp)
				tx_wr_pos += get_start_image(&camera, tx_wr_pos);
			}
			else if (reg[0] == 's' && reg[1] == 's') { // sensor size (column_size, row_size)
				tx_wr_pos += get_sensor_size(&camera, tx_wr_pos);
			}
			else if (reg[0] == 's' && reg[1] == 'm') { // sensor mode (column_mode, row_mode)
 320272c:	0000e406 	br	3202ac0 <sss_exec_command+0x704>
				tx_wr_pos += get_sensor_mode(&camera, tx_wr_pos);
			}
			/* Reads thresholds (min, max) */
			else if (reg[0] == 'r' && reg[1] == 't') {
 3202730:	e0bff343 	ldbu	r2,-51(fp)
 3202734:	10803fcc 	andi	r2,r2,255
 3202738:	1080201c 	xori	r2,r2,128
 320273c:	10bfe004 	addi	r2,r2,-128
 3202740:	10801c98 	cmpnei	r2,r2,114
 3202744:	1000191e 	bne	r2,zero,32027ac <sss_exec_command+0x3f0>
 3202748:	e0bff383 	ldbu	r2,-50(fp)
 320274c:	10803fcc 	andi	r2,r2,255
 3202750:	1080201c 	xori	r2,r2,128
 3202754:	10bfe004 	addi	r2,r2,-128
 3202758:	10801d18 	cmpnei	r2,r2,116
 320275c:	1000131e 	bne	r2,zero,32027ac <sss_exec_command+0x3f0>
				data0 = IORD_SENSOR_RED_THRESHOLD_MIN(SENSOR_BASE);
 3202760:	0080d034 	movhi	r2,832
 3202764:	10880004 	addi	r2,r2,8192
 3202768:	10800037 	ldwio	r2,0(r2)
 320276c:	e0bff415 	stw	r2,-48(fp)
				data1 = IORD_SENSOR_RED_THRESHOLD_MAX(SENSOR_BASE);
 3202770:	0080d034 	movhi	r2,832
 3202774:	10880404 	addi	r2,r2,8208
 3202778:	10800037 	ldwio	r2,0(r2)
 320277c:	e0bff515 	stw	r2,-44(fp)
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
 3202780:	e13df117 	ldw	r4,-2108(fp)
 3202784:	e1bff417 	ldw	r6,-48(fp)
 3202788:	e1fff517 	ldw	r7,-44(fp)
 320278c:	0140c974 	movhi	r5,805
 3202790:	29746504 	addi	r5,r5,-11884
 3202794:	32076bc0 	call	32076bc <sprintf>
 3202798:	1007883a 	mov	r3,r2
 320279c:	e0bdf117 	ldw	r2,-2108(fp)
 32027a0:	10c5883a 	add	r2,r2,r3
 32027a4:	e0bdf115 	stw	r2,-2108(fp)
			}
			else if (reg[0] == 's' && reg[1] == 'm') { // sensor mode (column_mode, row_mode)
				tx_wr_pos += get_sensor_mode(&camera, tx_wr_pos);
			}
			/* Reads thresholds (min, max) */
			else if (reg[0] == 'r' && reg[1] == 't') {
 32027a8:	0000c506 	br	3202ac0 <sss_exec_command+0x704>
				data0 = IORD_SENSOR_RED_THRESHOLD_MIN(SENSOR_BASE);
				data1 = IORD_SENSOR_RED_THRESHOLD_MAX(SENSOR_BASE);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			else if (reg[0] == 'g' && reg[1] == 't') {
 32027ac:	e0bff343 	ldbu	r2,-51(fp)
 32027b0:	10803fcc 	andi	r2,r2,255
 32027b4:	1080201c 	xori	r2,r2,128
 32027b8:	10bfe004 	addi	r2,r2,-128
 32027bc:	108019d8 	cmpnei	r2,r2,103
 32027c0:	1000191e 	bne	r2,zero,3202828 <sss_exec_command+0x46c>
 32027c4:	e0bff383 	ldbu	r2,-50(fp)
 32027c8:	10803fcc 	andi	r2,r2,255
 32027cc:	1080201c 	xori	r2,r2,128
 32027d0:	10bfe004 	addi	r2,r2,-128
 32027d4:	10801d18 	cmpnei	r2,r2,116
 32027d8:	1000131e 	bne	r2,zero,3202828 <sss_exec_command+0x46c>
				data0 = IORD_SENSOR_GREEN_THRESHOLD_MIN(SENSOR_BASE);
 32027dc:	0080d034 	movhi	r2,832
 32027e0:	10880804 	addi	r2,r2,8224
 32027e4:	10800037 	ldwio	r2,0(r2)
 32027e8:	e0bff415 	stw	r2,-48(fp)
				data1 = IORD_SENSOR_GREEN_THRESHOLD_MAX(SENSOR_BASE);
 32027ec:	0080d034 	movhi	r2,832
 32027f0:	10880c04 	addi	r2,r2,8240
 32027f4:	10800037 	ldwio	r2,0(r2)
 32027f8:	e0bff515 	stw	r2,-44(fp)
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
 32027fc:	e13df117 	ldw	r4,-2108(fp)
 3202800:	e1bff417 	ldw	r6,-48(fp)
 3202804:	e1fff517 	ldw	r7,-44(fp)
 3202808:	0140c974 	movhi	r5,805
 320280c:	29746504 	addi	r5,r5,-11884
 3202810:	32076bc0 	call	32076bc <sprintf>
 3202814:	1007883a 	mov	r3,r2
 3202818:	e0bdf117 	ldw	r2,-2108(fp)
 320281c:	10c5883a 	add	r2,r2,r3
 3202820:	e0bdf115 	stw	r2,-2108(fp)
			else if (reg[0] == 'r' && reg[1] == 't') {
				data0 = IORD_SENSOR_RED_THRESHOLD_MIN(SENSOR_BASE);
				data1 = IORD_SENSOR_RED_THRESHOLD_MAX(SENSOR_BASE);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			else if (reg[0] == 'g' && reg[1] == 't') {
 3202824:	0000a606 	br	3202ac0 <sss_exec_command+0x704>
				data0 = IORD_SENSOR_GREEN_THRESHOLD_MIN(SENSOR_BASE);
				data1 = IORD_SENSOR_GREEN_THRESHOLD_MAX(SENSOR_BASE);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			else if (reg[0] == 'b' && reg[1] == 't') {
 3202828:	e0bff343 	ldbu	r2,-51(fp)
 320282c:	10803fcc 	andi	r2,r2,255
 3202830:	1080201c 	xori	r2,r2,128
 3202834:	10bfe004 	addi	r2,r2,-128
 3202838:	10801898 	cmpnei	r2,r2,98
 320283c:	1000191e 	bne	r2,zero,32028a4 <sss_exec_command+0x4e8>
 3202840:	e0bff383 	ldbu	r2,-50(fp)
 3202844:	10803fcc 	andi	r2,r2,255
 3202848:	1080201c 	xori	r2,r2,128
 320284c:	10bfe004 	addi	r2,r2,-128
 3202850:	10801d18 	cmpnei	r2,r2,116
 3202854:	1000131e 	bne	r2,zero,32028a4 <sss_exec_command+0x4e8>
				data0 = IORD_SENSOR_BLUE_THRESHOLD_MIN(SENSOR_BASE);
 3202858:	0080d034 	movhi	r2,832
 320285c:	10881004 	addi	r2,r2,8256
 3202860:	10800037 	ldwio	r2,0(r2)
 3202864:	e0bff415 	stw	r2,-48(fp)
				data1 = IORD_SENSOR_BLUE_THRESHOLD_MAX(SENSOR_BASE);
 3202868:	0080d034 	movhi	r2,832
 320286c:	10881404 	addi	r2,r2,8272
 3202870:	10800037 	ldwio	r2,0(r2)
 3202874:	e0bff515 	stw	r2,-44(fp)
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
 3202878:	e13df117 	ldw	r4,-2108(fp)
 320287c:	e1bff417 	ldw	r6,-48(fp)
 3202880:	e1fff517 	ldw	r7,-44(fp)
 3202884:	0140c974 	movhi	r5,805
 3202888:	29746504 	addi	r5,r5,-11884
 320288c:	32076bc0 	call	32076bc <sprintf>
 3202890:	1007883a 	mov	r3,r2
 3202894:	e0bdf117 	ldw	r2,-2108(fp)
 3202898:	10c5883a 	add	r2,r2,r3
 320289c:	e0bdf115 	stw	r2,-2108(fp)
			else if (reg[0] == 'g' && reg[1] == 't') {
				data0 = IORD_SENSOR_GREEN_THRESHOLD_MIN(SENSOR_BASE);
				data1 = IORD_SENSOR_GREEN_THRESHOLD_MAX(SENSOR_BASE);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			else if (reg[0] == 'b' && reg[1] == 't') {
 32028a0:	00008706 	br	3202ac0 <sss_exec_command+0x704>
				data0 = IORD_SENSOR_BLUE_THRESHOLD_MIN(SENSOR_BASE);
				data1 = IORD_SENSOR_BLUE_THRESHOLD_MAX(SENSOR_BASE);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			/* Reads the number of tracker resources */
			else if (reg[0] == 't' && reg[1] == 'r') {
 32028a4:	e0bff343 	ldbu	r2,-51(fp)
 32028a8:	10803fcc 	andi	r2,r2,255
 32028ac:	1080201c 	xori	r2,r2,128
 32028b0:	10bfe004 	addi	r2,r2,-128
 32028b4:	10801d18 	cmpnei	r2,r2,116
 32028b8:	1000121e 	bne	r2,zero,3202904 <sss_exec_command+0x548>
 32028bc:	e0bff383 	ldbu	r2,-50(fp)
 32028c0:	10803fcc 	andi	r2,r2,255
 32028c4:	1080201c 	xori	r2,r2,128
 32028c8:	10bfe004 	addi	r2,r2,-128
 32028cc:	10801c98 	cmpnei	r2,r2,114
 32028d0:	10000c1e 	bne	r2,zero,3202904 <sss_exec_command+0x548>
				tx_wr_pos += sprintf(tx_wr_pos, "%i", trackers_number());
 32028d4:	e43df117 	ldw	r16,-2108(fp)
 32028d8:	320399c0 	call	320399c <trackers_number>
 32028dc:	100d883a 	mov	r6,r2
 32028e0:	8009883a 	mov	r4,r16
 32028e4:	0140c974 	movhi	r5,805
 32028e8:	29746704 	addi	r5,r5,-11876
 32028ec:	32076bc0 	call	32076bc <sprintf>
 32028f0:	1007883a 	mov	r3,r2
 32028f4:	e0bdf117 	ldw	r2,-2108(fp)
 32028f8:	10c5883a 	add	r2,r2,r3
 32028fc:	e0bdf115 	stw	r2,-2108(fp)
				data0 = IORD_SENSOR_BLUE_THRESHOLD_MIN(SENSOR_BASE);
				data1 = IORD_SENSOR_BLUE_THRESHOLD_MAX(SENSOR_BASE);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			/* Reads the number of tracker resources */
			else if (reg[0] == 't' && reg[1] == 'r') {
 3202900:	00006f06 	br	3202ac0 <sss_exec_command+0x704>
				tx_wr_pos += sprintf(tx_wr_pos, "%i", trackers_number());
			}
			/* Reads the search window of the assigned tracker (left, top, right, bottom) */
			else if (reg[0] == 's' && reg[1] == 'w') {
 3202904:	e0bff343 	ldbu	r2,-51(fp)
 3202908:	10803fcc 	andi	r2,r2,255
 320290c:	1080201c 	xori	r2,r2,128
 3202910:	10bfe004 	addi	r2,r2,-128
 3202914:	10801cd8 	cmpnei	r2,r2,115
 3202918:	10000e1e 	bne	r2,zero,3202954 <sss_exec_command+0x598>
 320291c:	e0bff383 	ldbu	r2,-50(fp)
 3202920:	10803fcc 	andi	r2,r2,255
 3202924:	1080201c 	xori	r2,r2,128
 3202928:	10bfe004 	addi	r2,r2,-128
 320292c:	10801dd8 	cmpnei	r2,r2,119
 3202930:	1000081e 	bne	r2,zero,3202954 <sss_exec_command+0x598>
				tx_wr_pos += get_search_window_of_tracker(data0, tx_wr_pos);
 3202934:	e13ff417 	ldw	r4,-48(fp)
 3202938:	e17df117 	ldw	r5,-2108(fp)
 320293c:	3203f200 	call	3203f20 <get_search_window_of_tracker>
 3202940:	1007883a 	mov	r3,r2
 3202944:	e0bdf117 	ldw	r2,-2108(fp)
 3202948:	10c5883a 	add	r2,r2,r3
 320294c:	e0bdf115 	stw	r2,-2108(fp)
			/* Reads the number of tracker resources */
			else if (reg[0] == 't' && reg[1] == 'r') {
				tx_wr_pos += sprintf(tx_wr_pos, "%i", trackers_number());
			}
			/* Reads the search window of the assigned tracker (left, top, right, bottom) */
			else if (reg[0] == 's' && reg[1] == 'w') {
 3202950:	00005b06 	br	3202ac0 <sss_exec_command+0x704>
				tx_wr_pos += get_search_window_of_tracker(data0, tx_wr_pos);
			}
			/* Reads the corners locations of the assigned tracker ((x0, y0),...,(x7,y7)) */
			else if (reg[0] == 'c' && reg[1] == 'l') {
 3202954:	e0bff343 	ldbu	r2,-51(fp)
 3202958:	10803fcc 	andi	r2,r2,255
 320295c:	1080201c 	xori	r2,r2,128
 3202960:	10bfe004 	addi	r2,r2,-128
 3202964:	108018d8 	cmpnei	r2,r2,99
 3202968:	1000161e 	bne	r2,zero,32029c4 <sss_exec_command+0x608>
 320296c:	e0bff383 	ldbu	r2,-50(fp)
 3202970:	10803fcc 	andi	r2,r2,255
 3202974:	1080201c 	xori	r2,r2,128
 3202978:	10bfe004 	addi	r2,r2,-128
 320297c:	10801b18 	cmpnei	r2,r2,108
 3202980:	1000101e 	bne	r2,zero,32029c4 <sss_exec_command+0x608>
				while (!IORD_CAMERA_CAPTURE_DONE(CAMERA_BASE)) OSTimeDly(1);
 3202984:	00000206 	br	3202990 <sss_exec_command+0x5d4>
 3202988:	01000044 	movi	r4,1
 320298c:	321cf780 	call	321cf78 <OSTimeDly>
 3202990:	0080d034 	movhi	r2,832
 3202994:	10890004 	addi	r2,r2,9216
 3202998:	10800037 	ldwio	r2,0(r2)
 320299c:	1005003a 	cmpeq	r2,r2,zero
 32029a0:	103ff91e 	bne	r2,zero,3202988 <sss_exec_command+0x5cc>
				tx_wr_pos += get_current_corners_of_tracker(data0, tx_wr_pos);
 32029a4:	e13ff417 	ldw	r4,-48(fp)
 32029a8:	e17df117 	ldw	r5,-2108(fp)
 32029ac:	3203fd40 	call	3203fd4 <get_current_corners_of_tracker>
 32029b0:	1007883a 	mov	r3,r2
 32029b4:	e0bdf117 	ldw	r2,-2108(fp)
 32029b8:	10c5883a 	add	r2,r2,r3
 32029bc:	e0bdf115 	stw	r2,-2108(fp)
			/* Reads the search window of the assigned tracker (left, top, right, bottom) */
			else if (reg[0] == 's' && reg[1] == 'w') {
				tx_wr_pos += get_search_window_of_tracker(data0, tx_wr_pos);
			}
			/* Reads the corners locations of the assigned tracker ((x0, y0),...,(x7,y7)) */
			else if (reg[0] == 'c' && reg[1] == 'l') {
 32029c0:	00003f06 	br	3202ac0 <sss_exec_command+0x704>
				while (!IORD_CAMERA_CAPTURE_DONE(CAMERA_BASE)) OSTimeDly(1);
				tx_wr_pos += get_current_corners_of_tracker(data0, tx_wr_pos);
			}
			/* Reads all search windows of activated trackers */
			else if (reg[0] == 'a' && reg[1] == 'w') {
 32029c4:	e0bff343 	ldbu	r2,-51(fp)
 32029c8:	10803fcc 	andi	r2,r2,255
 32029cc:	1080201c 	xori	r2,r2,128
 32029d0:	10bfe004 	addi	r2,r2,-128
 32029d4:	10801858 	cmpnei	r2,r2,97
 32029d8:	10000d1e 	bne	r2,zero,3202a10 <sss_exec_command+0x654>
 32029dc:	e0bff383 	ldbu	r2,-50(fp)
 32029e0:	10803fcc 	andi	r2,r2,255
 32029e4:	1080201c 	xori	r2,r2,128
 32029e8:	10bfe004 	addi	r2,r2,-128
 32029ec:	10801dd8 	cmpnei	r2,r2,119
 32029f0:	1000071e 	bne	r2,zero,3202a10 <sss_exec_command+0x654>
				//while (!IORD_CAMERA_CAPTURE_DONE(CAMERA_BASE));
				// Reads all search windows
				tx_wr_pos += get_current_windows_of_activated_trackers(tx_wr_pos);
 32029f4:	e13df117 	ldw	r4,-2108(fp)
 32029f8:	32040880 	call	3204088 <get_current_windows_of_activated_trackers>
 32029fc:	1007883a 	mov	r3,r2
 3202a00:	e0bdf117 	ldw	r2,-2108(fp)
 3202a04:	10c5883a 	add	r2,r2,r3
 3202a08:	e0bdf115 	stw	r2,-2108(fp)
			else if (reg[0] == 'c' && reg[1] == 'l') {
				while (!IORD_CAMERA_CAPTURE_DONE(CAMERA_BASE)) OSTimeDly(1);
				tx_wr_pos += get_current_corners_of_tracker(data0, tx_wr_pos);
			}
			/* Reads all search windows of activated trackers */
			else if (reg[0] == 'a' && reg[1] == 'w') {
 3202a0c:	00002c06 	br	3202ac0 <sss_exec_command+0x704>
				//while (!IORD_CAMERA_CAPTURE_DONE(CAMERA_BASE));
				// Reads all search windows
				tx_wr_pos += get_current_windows_of_activated_trackers(tx_wr_pos);
			}
			/* Reads all corners locations and captures a new frame */
			else if (reg[0] == 'a' && reg[1] == 'l') {
 3202a10:	e0bff343 	ldbu	r2,-51(fp)
 3202a14:	10803fcc 	andi	r2,r2,255
 3202a18:	1080201c 	xori	r2,r2,128
 3202a1c:	10bfe004 	addi	r2,r2,-128
 3202a20:	10801858 	cmpnei	r2,r2,97
 3202a24:	10001c1e 	bne	r2,zero,3202a98 <sss_exec_command+0x6dc>
 3202a28:	e0bff383 	ldbu	r2,-50(fp)
 3202a2c:	10803fcc 	andi	r2,r2,255
 3202a30:	1080201c 	xori	r2,r2,128
 3202a34:	10bfe004 	addi	r2,r2,-128
 3202a38:	10801b18 	cmpnei	r2,r2,108
 3202a3c:	1000161e 	bne	r2,zero,3202a98 <sss_exec_command+0x6dc>
				while (!IORD_CAMERA_CAPTURE_DONE(CAMERA_BASE)) OSTimeDly(1);
 3202a40:	00000206 	br	3202a4c <sss_exec_command+0x690>
 3202a44:	01000044 	movi	r4,1
 3202a48:	321cf780 	call	321cf78 <OSTimeDly>
 3202a4c:	0080d034 	movhi	r2,832
 3202a50:	10890004 	addi	r2,r2,9216
 3202a54:	10800037 	ldwio	r2,0(r2)
 3202a58:	1005003a 	cmpeq	r2,r2,zero
 3202a5c:	103ff91e 	bne	r2,zero,3202a44 <sss_exec_command+0x688>
				// Captures a new frame
				IOWR_CAMERA_CAPTURE_START(CAMERA_BASE);
 3202a60:	00c0d034 	movhi	r3,832
 3202a64:	18c90004 	addi	r3,r3,9216
 3202a68:	00800044 	movi	r2,1
 3202a6c:	18800035 	stwio	r2,0(r3)
				IOWR_CAMERA_CAPTURE_STOP(CAMERA_BASE);
 3202a70:	0080d034 	movhi	r2,832
 3202a74:	10890004 	addi	r2,r2,9216
 3202a78:	10000035 	stwio	zero,0(r2)
				// Reads all corners locations
				tx_wr_pos += get_current_corners_of_activated_trackers(tx_wr_pos);
 3202a7c:	e13df117 	ldw	r4,-2108(fp)
 3202a80:	32042040 	call	3204204 <get_current_corners_of_activated_trackers>
 3202a84:	1007883a 	mov	r3,r2
 3202a88:	e0bdf117 	ldw	r2,-2108(fp)
 3202a8c:	10c5883a 	add	r2,r2,r3
 3202a90:	e0bdf115 	stw	r2,-2108(fp)
				//while (!IORD_CAMERA_CAPTURE_DONE(CAMERA_BASE));
				// Reads all search windows
				tx_wr_pos += get_current_windows_of_activated_trackers(tx_wr_pos);
			}
			/* Reads all corners locations and captures a new frame */
			else if (reg[0] == 'a' && reg[1] == 'l') {
 3202a94:	00000a06 	br	3202ac0 <sss_exec_command+0x704>
				IOWR_CAMERA_CAPTURE_STOP(CAMERA_BASE);
				// Reads all corners locations
				tx_wr_pos += get_current_corners_of_activated_trackers(tx_wr_pos);
			}
			else {
				tx_wr_pos += sprintf(tx_wr_pos, "Wrong command!");
 3202a98:	e0bdf117 	ldw	r2,-2108(fp)
 3202a9c:	00c0c974 	movhi	r3,805
 3202aa0:	18f46804 	addi	r3,r3,-11872
 3202aa4:	1009883a 	mov	r4,r2
 3202aa8:	180b883a 	mov	r5,r3
 3202aac:	018003c4 	movi	r6,15
 3202ab0:	32067cc0 	call	32067cc <memcpy>
 3202ab4:	e0bdf117 	ldw	r2,-2108(fp)
 3202ab8:	10800384 	addi	r2,r2,14
 3202abc:	e0bdf115 	stw	r2,-2108(fp)
			}
			tx_wr_pos += sprintf(tx_wr_pos, "\n");
 3202ac0:	e0fdf117 	ldw	r3,-2108(fp)
 3202ac4:	00800284 	movi	r2,10
 3202ac8:	18800005 	stb	r2,0(r3)
 3202acc:	18000045 	stb	zero,1(r3)
 3202ad0:	e0bdf117 	ldw	r2,-2108(fp)
 3202ad4:	10800044 	addi	r2,r2,1
 3202ad8:	e0bdf115 	stw	r2,-2108(fp)
			break;
 3202adc:	0001ce06 	br	3203218 <sss_exec_command+0xe5c>
		case CMD_WRITE:
			/* Writes camera image registers */
			if (reg[0] == 'i' && reg[1] == 's') { // image size (width, height)
 3202ae0:	e0bff343 	ldbu	r2,-51(fp)
 3202ae4:	10803fcc 	andi	r2,r2,255
 3202ae8:	1080201c 	xori	r2,r2,128
 3202aec:	10bfe004 	addi	r2,r2,-128
 3202af0:	10801a58 	cmpnei	r2,r2,105
 3202af4:	1000111e 	bne	r2,zero,3202b3c <sss_exec_command+0x780>
 3202af8:	e0bff383 	ldbu	r2,-50(fp)
 3202afc:	10803fcc 	andi	r2,r2,255
 3202b00:	1080201c 	xori	r2,r2,128
 3202b04:	10bfe004 	addi	r2,r2,-128
 3202b08:	10801cd8 	cmpnei	r2,r2,115
 3202b0c:	10000b1e 	bne	r2,zero,3202b3c <sss_exec_command+0x780>
				tx_wr_pos += set_image_size(&camera, tx_wr_pos, data0, data1);
 3202b10:	e17df117 	ldw	r5,-2108(fp)
 3202b14:	e1bff417 	ldw	r6,-48(fp)
 3202b18:	e1fff517 	ldw	r7,-44(fp)
 3202b1c:	0100c974 	movhi	r4,805
 3202b20:	21018a04 	addi	r4,r4,1576
 3202b24:	32010880 	call	3201088 <set_image_size>
 3202b28:	1007883a 	mov	r3,r2
 3202b2c:	e0bdf117 	ldw	r2,-2108(fp)
 3202b30:	10c5883a 	add	r2,r2,r3
 3202b34:	e0bdf115 	stw	r2,-2108(fp)
			}
			tx_wr_pos += sprintf(tx_wr_pos, "\n");
			break;
		case CMD_WRITE:
			/* Writes camera image registers */
			if (reg[0] == 'i' && reg[1] == 's') { // image size (width, height)
 3202b38:	00014106 	br	3203040 <sss_exec_command+0xc84>
				tx_wr_pos += set_image_size(&camera, tx_wr_pos, data0, data1);
			}
			else if (reg[0] == 'i' && reg[1] == 'e') { // image exposure (exposure)
 3202b3c:	e0bff343 	ldbu	r2,-51(fp)
 3202b40:	10803fcc 	andi	r2,r2,255
 3202b44:	1080201c 	xori	r2,r2,128
 3202b48:	10bfe004 	addi	r2,r2,-128
 3202b4c:	10801a58 	cmpnei	r2,r2,105
 3202b50:	1000101e 	bne	r2,zero,3202b94 <sss_exec_command+0x7d8>
 3202b54:	e0bff383 	ldbu	r2,-50(fp)
 3202b58:	10803fcc 	andi	r2,r2,255
 3202b5c:	1080201c 	xori	r2,r2,128
 3202b60:	10bfe004 	addi	r2,r2,-128
 3202b64:	10801958 	cmpnei	r2,r2,101
 3202b68:	10000a1e 	bne	r2,zero,3202b94 <sss_exec_command+0x7d8>
				tx_wr_pos += set_image_exposure(&camera, tx_wr_pos, data0);
 3202b6c:	e17df117 	ldw	r5,-2108(fp)
 3202b70:	e1bff417 	ldw	r6,-48(fp)
 3202b74:	0100c974 	movhi	r4,805
 3202b78:	21018a04 	addi	r4,r4,1576
 3202b7c:	32011300 	call	3201130 <set_image_exposure>
 3202b80:	1007883a 	mov	r3,r2
 3202b84:	e0bdf117 	ldw	r2,-2108(fp)
 3202b88:	10c5883a 	add	r2,r2,r3
 3202b8c:	e0bdf115 	stw	r2,-2108(fp)
		case CMD_WRITE:
			/* Writes camera image registers */
			if (reg[0] == 'i' && reg[1] == 's') { // image size (width, height)
				tx_wr_pos += set_image_size(&camera, tx_wr_pos, data0, data1);
			}
			else if (reg[0] == 'i' && reg[1] == 'e') { // image exposure (exposure)
 3202b90:	00012b06 	br	3203040 <sss_exec_command+0xc84>
				tx_wr_pos += set_image_exposure(&camera, tx_wr_pos, data0);
			}
			else if (reg[0] == 's' && reg[1] == 'i') { // start image (start_column, start_row)
 3202b94:	e0bff343 	ldbu	r2,-51(fp)
 3202b98:	10803fcc 	andi	r2,r2,255
 3202b9c:	1080201c 	xori	r2,r2,128
 3202ba0:	10bfe004 	addi	r2,r2,-128
 3202ba4:	10801cd8 	cmpnei	r2,r2,115
 3202ba8:	1000111e 	bne	r2,zero,3202bf0 <sss_exec_command+0x834>
 3202bac:	e0bff383 	ldbu	r2,-50(fp)
 3202bb0:	10803fcc 	andi	r2,r2,255
 3202bb4:	1080201c 	xori	r2,r2,128
 3202bb8:	10bfe004 	addi	r2,r2,-128
 3202bbc:	10801a58 	cmpnei	r2,r2,105
 3202bc0:	10000b1e 	bne	r2,zero,3202bf0 <sss_exec_command+0x834>
				tx_wr_pos += set_start_image(&camera, tx_wr_pos, data0, data1);
 3202bc4:	e17df117 	ldw	r5,-2108(fp)
 3202bc8:	e1bff417 	ldw	r6,-48(fp)
 3202bcc:	e1fff517 	ldw	r7,-44(fp)
 3202bd0:	0100c974 	movhi	r4,805
 3202bd4:	21018a04 	addi	r4,r4,1576
 3202bd8:	32011d00 	call	32011d0 <set_start_image>
 3202bdc:	1007883a 	mov	r3,r2
 3202be0:	e0bdf117 	ldw	r2,-2108(fp)
 3202be4:	10c5883a 	add	r2,r2,r3
 3202be8:	e0bdf115 	stw	r2,-2108(fp)
				tx_wr_pos += set_image_size(&camera, tx_wr_pos, data0, data1);
			}
			else if (reg[0] == 'i' && reg[1] == 'e') { // image exposure (exposure)
				tx_wr_pos += set_image_exposure(&camera, tx_wr_pos, data0);
			}
			else if (reg[0] == 's' && reg[1] == 'i') { // start image (start_column, start_row)
 3202bec:	00011406 	br	3203040 <sss_exec_command+0xc84>
				tx_wr_pos += set_start_image(&camera, tx_wr_pos, data0, data1);
			}
			else if (reg[0] == 's' && reg[1] == 's'){ // sensor size (column_size, row_size)
 3202bf0:	e0bff343 	ldbu	r2,-51(fp)
 3202bf4:	10803fcc 	andi	r2,r2,255
 3202bf8:	1080201c 	xori	r2,r2,128
 3202bfc:	10bfe004 	addi	r2,r2,-128
 3202c00:	10801cd8 	cmpnei	r2,r2,115
 3202c04:	1000111e 	bne	r2,zero,3202c4c <sss_exec_command+0x890>
 3202c08:	e0bff383 	ldbu	r2,-50(fp)
 3202c0c:	10803fcc 	andi	r2,r2,255
 3202c10:	1080201c 	xori	r2,r2,128
 3202c14:	10bfe004 	addi	r2,r2,-128
 3202c18:	10801cd8 	cmpnei	r2,r2,115
 3202c1c:	10000b1e 	bne	r2,zero,3202c4c <sss_exec_command+0x890>
				tx_wr_pos += set_sensor_size(&camera, tx_wr_pos, data0, data1);
 3202c20:	e17df117 	ldw	r5,-2108(fp)
 3202c24:	e1bff417 	ldw	r6,-48(fp)
 3202c28:	e1fff517 	ldw	r7,-44(fp)
 3202c2c:	0100c974 	movhi	r4,805
 3202c30:	21018a04 	addi	r4,r4,1576
 3202c34:	32012800 	call	3201280 <set_sensor_size>
 3202c38:	1007883a 	mov	r3,r2
 3202c3c:	e0bdf117 	ldw	r2,-2108(fp)
 3202c40:	10c5883a 	add	r2,r2,r3
 3202c44:	e0bdf115 	stw	r2,-2108(fp)
				tx_wr_pos += set_image_exposure(&camera, tx_wr_pos, data0);
			}
			else if (reg[0] == 's' && reg[1] == 'i') { // start image (start_column, start_row)
				tx_wr_pos += set_start_image(&camera, tx_wr_pos, data0, data1);
			}
			else if (reg[0] == 's' && reg[1] == 's'){ // sensor size (column_size, row_size)
 3202c48:	0000fd06 	br	3203040 <sss_exec_command+0xc84>
				tx_wr_pos += set_sensor_size(&camera, tx_wr_pos, data0, data1);
			}
			else if (reg[0] == 's' && reg[1] == 'm'){ // sensor mode (column_mode, row_mode)
 3202c4c:	e0bff343 	ldbu	r2,-51(fp)
 3202c50:	10803fcc 	andi	r2,r2,255
 3202c54:	1080201c 	xori	r2,r2,128
 3202c58:	10bfe004 	addi	r2,r2,-128
 3202c5c:	10801cd8 	cmpnei	r2,r2,115
 3202c60:	1000111e 	bne	r2,zero,3202ca8 <sss_exec_command+0x8ec>
 3202c64:	e0bff383 	ldbu	r2,-50(fp)
 3202c68:	10803fcc 	andi	r2,r2,255
 3202c6c:	1080201c 	xori	r2,r2,128
 3202c70:	10bfe004 	addi	r2,r2,-128
 3202c74:	10801b58 	cmpnei	r2,r2,109
 3202c78:	10000b1e 	bne	r2,zero,3202ca8 <sss_exec_command+0x8ec>
				tx_wr_pos += set_sensor_mode(&camera, tx_wr_pos, data0, data1);
 3202c7c:	e17df117 	ldw	r5,-2108(fp)
 3202c80:	e1bff417 	ldw	r6,-48(fp)
 3202c84:	e1fff517 	ldw	r7,-44(fp)
 3202c88:	0100c974 	movhi	r4,805
 3202c8c:	21018a04 	addi	r4,r4,1576
 3202c90:	32013300 	call	3201330 <set_sensor_mode>
 3202c94:	1007883a 	mov	r3,r2
 3202c98:	e0bdf117 	ldw	r2,-2108(fp)
 3202c9c:	10c5883a 	add	r2,r2,r3
 3202ca0:	e0bdf115 	stw	r2,-2108(fp)
				tx_wr_pos += set_start_image(&camera, tx_wr_pos, data0, data1);
			}
			else if (reg[0] == 's' && reg[1] == 's'){ // sensor size (column_size, row_size)
				tx_wr_pos += set_sensor_size(&camera, tx_wr_pos, data0, data1);
			}
			else if (reg[0] == 's' && reg[1] == 'm'){ // sensor mode (column_mode, row_mode)
 3202ca4:	0000e606 	br	3203040 <sss_exec_command+0xc84>
				tx_wr_pos += set_sensor_mode(&camera, tx_wr_pos, data0, data1);
			}
			/* Writes the selected sensor output */
			else if (reg[0] == 's' && reg[1] == 'o') { //  select output
 3202ca8:	e0bff343 	ldbu	r2,-51(fp)
 3202cac:	10803fcc 	andi	r2,r2,255
 3202cb0:	1080201c 	xori	r2,r2,128
 3202cb4:	10bfe004 	addi	r2,r2,-128
 3202cb8:	10801cd8 	cmpnei	r2,r2,115
 3202cbc:	1000101e 	bne	r2,zero,3202d00 <sss_exec_command+0x944>
 3202cc0:	e0bff383 	ldbu	r2,-50(fp)
 3202cc4:	10803fcc 	andi	r2,r2,255
 3202cc8:	1080201c 	xori	r2,r2,128
 3202ccc:	10bfe004 	addi	r2,r2,-128
 3202cd0:	10801bd8 	cmpnei	r2,r2,111
 3202cd4:	10000a1e 	bne	r2,zero,3202d00 <sss_exec_command+0x944>
				tx_wr_pos += select_sensor_output(&camera, tx_wr_pos, data0);
 3202cd8:	e17df117 	ldw	r5,-2108(fp)
 3202cdc:	e1bff417 	ldw	r6,-48(fp)
 3202ce0:	0100c974 	movhi	r4,805
 3202ce4:	21018a04 	addi	r4,r4,1576
 3202ce8:	32014400 	call	3201440 <select_sensor_output>
 3202cec:	1007883a 	mov	r3,r2
 3202cf0:	e0bdf117 	ldw	r2,-2108(fp)
 3202cf4:	10c5883a 	add	r2,r2,r3
 3202cf8:	e0bdf115 	stw	r2,-2108(fp)
			}
			else if (reg[0] == 's' && reg[1] == 'm'){ // sensor mode (column_mode, row_mode)
				tx_wr_pos += set_sensor_mode(&camera, tx_wr_pos, data0, data1);
			}
			/* Writes the selected sensor output */
			else if (reg[0] == 's' && reg[1] == 'o') { //  select output
 3202cfc:	0000d006 	br	3203040 <sss_exec_command+0xc84>
				tx_wr_pos += select_sensor_output(&camera, tx_wr_pos, data0);
			}
			// TODO: Group sensor configuration functions
			/* Writes thresholds (min, max) */
			else if (reg[0] == 'r' && reg[1] == 't'){
 3202d00:	e0bff343 	ldbu	r2,-51(fp)
 3202d04:	10803fcc 	andi	r2,r2,255
 3202d08:	1080201c 	xori	r2,r2,128
 3202d0c:	10bfe004 	addi	r2,r2,-128
 3202d10:	10801c98 	cmpnei	r2,r2,114
 3202d14:	1000191e 	bne	r2,zero,3202d7c <sss_exec_command+0x9c0>
 3202d18:	e0bff383 	ldbu	r2,-50(fp)
 3202d1c:	10803fcc 	andi	r2,r2,255
 3202d20:	1080201c 	xori	r2,r2,128
 3202d24:	10bfe004 	addi	r2,r2,-128
 3202d28:	10801d18 	cmpnei	r2,r2,116
 3202d2c:	1000131e 	bne	r2,zero,3202d7c <sss_exec_command+0x9c0>
				IOWR_SENSOR_RED_THRESHOLD_MIN(SENSOR_BASE, data0);
 3202d30:	e0fff417 	ldw	r3,-48(fp)
 3202d34:	0080d034 	movhi	r2,832
 3202d38:	10880004 	addi	r2,r2,8192
 3202d3c:	10c00035 	stwio	r3,0(r2)
				IOWR_SENSOR_RED_THRESHOLD_MAX(SENSOR_BASE, data1);
 3202d40:	e0fff517 	ldw	r3,-44(fp)
 3202d44:	0080d034 	movhi	r2,832
 3202d48:	10880404 	addi	r2,r2,8208
 3202d4c:	10c00035 	stwio	r3,0(r2)
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
 3202d50:	e13df117 	ldw	r4,-2108(fp)
 3202d54:	e1bff417 	ldw	r6,-48(fp)
 3202d58:	e1fff517 	ldw	r7,-44(fp)
 3202d5c:	0140c974 	movhi	r5,805
 3202d60:	29746504 	addi	r5,r5,-11884
 3202d64:	32076bc0 	call	32076bc <sprintf>
 3202d68:	1007883a 	mov	r3,r2
 3202d6c:	e0bdf117 	ldw	r2,-2108(fp)
 3202d70:	10c5883a 	add	r2,r2,r3
 3202d74:	e0bdf115 	stw	r2,-2108(fp)
			else if (reg[0] == 's' && reg[1] == 'o') { //  select output
				tx_wr_pos += select_sensor_output(&camera, tx_wr_pos, data0);
			}
			// TODO: Group sensor configuration functions
			/* Writes thresholds (min, max) */
			else if (reg[0] == 'r' && reg[1] == 't'){
 3202d78:	0000b106 	br	3203040 <sss_exec_command+0xc84>
				IOWR_SENSOR_RED_THRESHOLD_MIN(SENSOR_BASE, data0);
				IOWR_SENSOR_RED_THRESHOLD_MAX(SENSOR_BASE, data1);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			else if (reg[0] == 'g' && reg[1] == 't'){
 3202d7c:	e0bff343 	ldbu	r2,-51(fp)
 3202d80:	10803fcc 	andi	r2,r2,255
 3202d84:	1080201c 	xori	r2,r2,128
 3202d88:	10bfe004 	addi	r2,r2,-128
 3202d8c:	108019d8 	cmpnei	r2,r2,103
 3202d90:	1000191e 	bne	r2,zero,3202df8 <sss_exec_command+0xa3c>
 3202d94:	e0bff383 	ldbu	r2,-50(fp)
 3202d98:	10803fcc 	andi	r2,r2,255
 3202d9c:	1080201c 	xori	r2,r2,128
 3202da0:	10bfe004 	addi	r2,r2,-128
 3202da4:	10801d18 	cmpnei	r2,r2,116
 3202da8:	1000131e 	bne	r2,zero,3202df8 <sss_exec_command+0xa3c>
				IOWR_SENSOR_GREEN_THRESHOLD_MIN(SENSOR_BASE, data0);
 3202dac:	e0fff417 	ldw	r3,-48(fp)
 3202db0:	0080d034 	movhi	r2,832
 3202db4:	10880804 	addi	r2,r2,8224
 3202db8:	10c00035 	stwio	r3,0(r2)
				IOWR_SENSOR_GREEN_THRESHOLD_MAX(SENSOR_BASE, data1);
 3202dbc:	e0fff517 	ldw	r3,-44(fp)
 3202dc0:	0080d034 	movhi	r2,832
 3202dc4:	10880c04 	addi	r2,r2,8240
 3202dc8:	10c00035 	stwio	r3,0(r2)
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
 3202dcc:	e13df117 	ldw	r4,-2108(fp)
 3202dd0:	e1bff417 	ldw	r6,-48(fp)
 3202dd4:	e1fff517 	ldw	r7,-44(fp)
 3202dd8:	0140c974 	movhi	r5,805
 3202ddc:	29746504 	addi	r5,r5,-11884
 3202de0:	32076bc0 	call	32076bc <sprintf>
 3202de4:	1007883a 	mov	r3,r2
 3202de8:	e0bdf117 	ldw	r2,-2108(fp)
 3202dec:	10c5883a 	add	r2,r2,r3
 3202df0:	e0bdf115 	stw	r2,-2108(fp)
			else if (reg[0] == 'r' && reg[1] == 't'){
				IOWR_SENSOR_RED_THRESHOLD_MIN(SENSOR_BASE, data0);
				IOWR_SENSOR_RED_THRESHOLD_MAX(SENSOR_BASE, data1);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			else if (reg[0] == 'g' && reg[1] == 't'){
 3202df4:	00009206 	br	3203040 <sss_exec_command+0xc84>
				IOWR_SENSOR_GREEN_THRESHOLD_MIN(SENSOR_BASE, data0);
				IOWR_SENSOR_GREEN_THRESHOLD_MAX(SENSOR_BASE, data1);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			else if (reg[0] == 'b' && reg[1] == 't'){
 3202df8:	e0bff343 	ldbu	r2,-51(fp)
 3202dfc:	10803fcc 	andi	r2,r2,255
 3202e00:	1080201c 	xori	r2,r2,128
 3202e04:	10bfe004 	addi	r2,r2,-128
 3202e08:	10801898 	cmpnei	r2,r2,98
 3202e0c:	1000191e 	bne	r2,zero,3202e74 <sss_exec_command+0xab8>
 3202e10:	e0bff383 	ldbu	r2,-50(fp)
 3202e14:	10803fcc 	andi	r2,r2,255
 3202e18:	1080201c 	xori	r2,r2,128
 3202e1c:	10bfe004 	addi	r2,r2,-128
 3202e20:	10801d18 	cmpnei	r2,r2,116
 3202e24:	1000131e 	bne	r2,zero,3202e74 <sss_exec_command+0xab8>
				IOWR_SENSOR_BLUE_THRESHOLD_MIN(SENSOR_BASE, data0);
 3202e28:	e0fff417 	ldw	r3,-48(fp)
 3202e2c:	0080d034 	movhi	r2,832
 3202e30:	10881004 	addi	r2,r2,8256
 3202e34:	10c00035 	stwio	r3,0(r2)
				IOWR_SENSOR_BLUE_THRESHOLD_MAX(SENSOR_BASE, data1);
 3202e38:	e0fff517 	ldw	r3,-44(fp)
 3202e3c:	0080d034 	movhi	r2,832
 3202e40:	10881404 	addi	r2,r2,8272
 3202e44:	10c00035 	stwio	r3,0(r2)
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
 3202e48:	e13df117 	ldw	r4,-2108(fp)
 3202e4c:	e1bff417 	ldw	r6,-48(fp)
 3202e50:	e1fff517 	ldw	r7,-44(fp)
 3202e54:	0140c974 	movhi	r5,805
 3202e58:	29746504 	addi	r5,r5,-11884
 3202e5c:	32076bc0 	call	32076bc <sprintf>
 3202e60:	1007883a 	mov	r3,r2
 3202e64:	e0bdf117 	ldw	r2,-2108(fp)
 3202e68:	10c5883a 	add	r2,r2,r3
 3202e6c:	e0bdf115 	stw	r2,-2108(fp)
			else if (reg[0] == 'g' && reg[1] == 't'){
				IOWR_SENSOR_GREEN_THRESHOLD_MIN(SENSOR_BASE, data0);
				IOWR_SENSOR_GREEN_THRESHOLD_MAX(SENSOR_BASE, data1);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			else if (reg[0] == 'b' && reg[1] == 't'){
 3202e70:	00007306 	br	3203040 <sss_exec_command+0xc84>
				IOWR_SENSOR_BLUE_THRESHOLD_MIN(SENSOR_BASE, data0);
				IOWR_SENSOR_BLUE_THRESHOLD_MAX(SENSOR_BASE, data1);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			/* Frees all tracker devices */
			else if (reg[0] == 'f' && reg[1] == 'a') {
 3202e74:	e0bff343 	ldbu	r2,-51(fp)
 3202e78:	10803fcc 	andi	r2,r2,255
 3202e7c:	1080201c 	xori	r2,r2,128
 3202e80:	10bfe004 	addi	r2,r2,-128
 3202e84:	10801998 	cmpnei	r2,r2,102
 3202e88:	10000d1e 	bne	r2,zero,3202ec0 <sss_exec_command+0xb04>
 3202e8c:	e0bff383 	ldbu	r2,-50(fp)
 3202e90:	10803fcc 	andi	r2,r2,255
 3202e94:	1080201c 	xori	r2,r2,128
 3202e98:	10bfe004 	addi	r2,r2,-128
 3202e9c:	10801858 	cmpnei	r2,r2,97
 3202ea0:	1000071e 	bne	r2,zero,3202ec0 <sss_exec_command+0xb04>
				tx_wr_pos += trackers_free(tx_wr_pos);
 3202ea4:	e13df117 	ldw	r4,-2108(fp)
 3202ea8:	32039bc0 	call	32039bc <trackers_free>
 3202eac:	1007883a 	mov	r3,r2
 3202eb0:	e0bdf117 	ldw	r2,-2108(fp)
 3202eb4:	10c5883a 	add	r2,r2,r3
 3202eb8:	e0bdf115 	stw	r2,-2108(fp)
				IOWR_SENSOR_BLUE_THRESHOLD_MIN(SENSOR_BASE, data0);
				IOWR_SENSOR_BLUE_THRESHOLD_MAX(SENSOR_BASE, data1);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			/* Frees all tracker devices */
			else if (reg[0] == 'f' && reg[1] == 'a') {
 3202ebc:	00006006 	br	3203040 <sss_exec_command+0xc84>
				tx_wr_pos += trackers_free(tx_wr_pos);
			}
			/* Activates a tracker device. */
			else if (reg[0] == 'a' && reg[1] == 't') {
 3202ec0:	e0bff343 	ldbu	r2,-51(fp)
 3202ec4:	10803fcc 	andi	r2,r2,255
 3202ec8:	1080201c 	xori	r2,r2,128
 3202ecc:	10bfe004 	addi	r2,r2,-128
 3202ed0:	10801858 	cmpnei	r2,r2,97
 3202ed4:	10000e1e 	bne	r2,zero,3202f10 <sss_exec_command+0xb54>
 3202ed8:	e0bff383 	ldbu	r2,-50(fp)
 3202edc:	10803fcc 	andi	r2,r2,255
 3202ee0:	1080201c 	xori	r2,r2,128
 3202ee4:	10bfe004 	addi	r2,r2,-128
 3202ee8:	10801d18 	cmpnei	r2,r2,116
 3202eec:	1000081e 	bne	r2,zero,3202f10 <sss_exec_command+0xb54>
				tx_wr_pos += activate_tracker(data0, tx_wr_pos);
 3202ef0:	e13ff417 	ldw	r4,-48(fp)
 3202ef4:	e17df117 	ldw	r5,-2108(fp)
 3202ef8:	3203a5c0 	call	3203a5c <activate_tracker>
 3202efc:	1007883a 	mov	r3,r2
 3202f00:	e0bdf117 	ldw	r2,-2108(fp)
 3202f04:	10c5883a 	add	r2,r2,r3
 3202f08:	e0bdf115 	stw	r2,-2108(fp)
			/* Frees all tracker devices */
			else if (reg[0] == 'f' && reg[1] == 'a') {
				tx_wr_pos += trackers_free(tx_wr_pos);
			}
			/* Activates a tracker device. */
			else if (reg[0] == 'a' && reg[1] == 't') {
 3202f0c:	00004c06 	br	3203040 <sss_exec_command+0xc84>
				tx_wr_pos += activate_tracker(data0, tx_wr_pos);
			}
			/* Disables a tracker device. */
			else if (reg[0] == 'd' && reg[1] == 't') {
 3202f10:	e0bff343 	ldbu	r2,-51(fp)
 3202f14:	10803fcc 	andi	r2,r2,255
 3202f18:	1080201c 	xori	r2,r2,128
 3202f1c:	10bfe004 	addi	r2,r2,-128
 3202f20:	10801918 	cmpnei	r2,r2,100
 3202f24:	10000e1e 	bne	r2,zero,3202f60 <sss_exec_command+0xba4>
 3202f28:	e0bff383 	ldbu	r2,-50(fp)
 3202f2c:	10803fcc 	andi	r2,r2,255
 3202f30:	1080201c 	xori	r2,r2,128
 3202f34:	10bfe004 	addi	r2,r2,-128
 3202f38:	10801d18 	cmpnei	r2,r2,116
 3202f3c:	1000081e 	bne	r2,zero,3202f60 <sss_exec_command+0xba4>
				tx_wr_pos += disable_tracker(data0, tx_wr_pos);
 3202f40:	e13ff417 	ldw	r4,-48(fp)
 3202f44:	e17df117 	ldw	r5,-2108(fp)
 3202f48:	3203bc40 	call	3203bc4 <disable_tracker>
 3202f4c:	1007883a 	mov	r3,r2
 3202f50:	e0bdf117 	ldw	r2,-2108(fp)
 3202f54:	10c5883a 	add	r2,r2,r3
 3202f58:	e0bdf115 	stw	r2,-2108(fp)
			/* Activates a tracker device. */
			else if (reg[0] == 'a' && reg[1] == 't') {
				tx_wr_pos += activate_tracker(data0, tx_wr_pos);
			}
			/* Disables a tracker device. */
			else if (reg[0] == 'd' && reg[1] == 't') {
 3202f5c:	00003806 	br	3203040 <sss_exec_command+0xc84>
				tx_wr_pos += disable_tracker(data0, tx_wr_pos);
			}
			/* Frees a tracker device. */
			else if (reg[0] == 'f' && reg[1] == 't') {
 3202f60:	e0bff343 	ldbu	r2,-51(fp)
 3202f64:	10803fcc 	andi	r2,r2,255
 3202f68:	1080201c 	xori	r2,r2,128
 3202f6c:	10bfe004 	addi	r2,r2,-128
 3202f70:	10801998 	cmpnei	r2,r2,102
 3202f74:	10000e1e 	bne	r2,zero,3202fb0 <sss_exec_command+0xbf4>
 3202f78:	e0bff383 	ldbu	r2,-50(fp)
 3202f7c:	10803fcc 	andi	r2,r2,255
 3202f80:	1080201c 	xori	r2,r2,128
 3202f84:	10bfe004 	addi	r2,r2,-128
 3202f88:	10801d18 	cmpnei	r2,r2,116
 3202f8c:	1000081e 	bne	r2,zero,3202fb0 <sss_exec_command+0xbf4>
				tx_wr_pos += free_tracker(data0, tx_wr_pos);
 3202f90:	e13ff417 	ldw	r4,-48(fp)
 3202f94:	e17df117 	ldw	r5,-2108(fp)
 3202f98:	3203c880 	call	3203c88 <free_tracker>
 3202f9c:	1007883a 	mov	r3,r2
 3202fa0:	e0bdf117 	ldw	r2,-2108(fp)
 3202fa4:	10c5883a 	add	r2,r2,r3
 3202fa8:	e0bdf115 	stw	r2,-2108(fp)
			/* Disables a tracker device. */
			else if (reg[0] == 'd' && reg[1] == 't') {
				tx_wr_pos += disable_tracker(data0, tx_wr_pos);
			}
			/* Frees a tracker device. */
			else if (reg[0] == 'f' && reg[1] == 't') {
 3202fac:	00002406 	br	3203040 <sss_exec_command+0xc84>
				tx_wr_pos += free_tracker(data0, tx_wr_pos);
			}
			/* Sets a search window for the assigned tracker device (x, y, width, height) */
			else if (reg[0] == 's' && reg[1] == 'w') {
 3202fb0:	e0bff343 	ldbu	r2,-51(fp)
 3202fb4:	10803fcc 	andi	r2,r2,255
 3202fb8:	1080201c 	xori	r2,r2,128
 3202fbc:	10bfe004 	addi	r2,r2,-128
 3202fc0:	10801cd8 	cmpnei	r2,r2,115
 3202fc4:	1000141e 	bne	r2,zero,3203018 <sss_exec_command+0xc5c>
 3202fc8:	e0bff383 	ldbu	r2,-50(fp)
 3202fcc:	10803fcc 	andi	r2,r2,255
 3202fd0:	1080201c 	xori	r2,r2,128
 3202fd4:	10bfe004 	addi	r2,r2,-128
 3202fd8:	10801dd8 	cmpnei	r2,r2,119
 3202fdc:	10000e1e 	bne	r2,zero,3203018 <sss_exec_command+0xc5c>
				tx_wr_pos += set_search_window_of_tracker(data0, tx_wr_pos, data1, data2, data3, data4);
 3202fe0:	e13ff417 	ldw	r4,-48(fp)
 3202fe4:	e17df117 	ldw	r5,-2108(fp)
 3202fe8:	e1bff517 	ldw	r6,-44(fp)
 3202fec:	e1fff617 	ldw	r7,-40(fp)
 3202ff0:	e0bff717 	ldw	r2,-36(fp)
 3202ff4:	e0fff817 	ldw	r3,-32(fp)
 3202ff8:	d8800015 	stw	r2,0(sp)
 3202ffc:	d8c00115 	stw	r3,4(sp)
 3203000:	3203d680 	call	3203d68 <set_search_window_of_tracker>
 3203004:	1007883a 	mov	r3,r2
 3203008:	e0bdf117 	ldw	r2,-2108(fp)
 320300c:	10c5883a 	add	r2,r2,r3
 3203010:	e0bdf115 	stw	r2,-2108(fp)
			/* Frees a tracker device. */
			else if (reg[0] == 'f' && reg[1] == 't') {
				tx_wr_pos += free_tracker(data0, tx_wr_pos);
			}
			/* Sets a search window for the assigned tracker device (x, y, width, height) */
			else if (reg[0] == 's' && reg[1] == 'w') {
 3203014:	00000a06 	br	3203040 <sss_exec_command+0xc84>
				tx_wr_pos += set_search_window_of_tracker(data0, tx_wr_pos, data1, data2, data3, data4);
			}
			else {
				tx_wr_pos += sprintf(tx_wr_pos, "Wrong command!");
 3203018:	e0bdf117 	ldw	r2,-2108(fp)
 320301c:	00c0c974 	movhi	r3,805
 3203020:	18f46804 	addi	r3,r3,-11872
 3203024:	1009883a 	mov	r4,r2
 3203028:	180b883a 	mov	r5,r3
 320302c:	018003c4 	movi	r6,15
 3203030:	32067cc0 	call	32067cc <memcpy>
 3203034:	e0bdf117 	ldw	r2,-2108(fp)
 3203038:	10800384 	addi	r2,r2,14
 320303c:	e0bdf115 	stw	r2,-2108(fp)
			}
			tx_wr_pos += sprintf(tx_wr_pos, "\n");
 3203040:	e0fdf117 	ldw	r3,-2108(fp)
 3203044:	00800284 	movi	r2,10
 3203048:	18800005 	stb	r2,0(r3)
 320304c:	18000045 	stb	zero,1(r3)
 3203050:	e0bdf117 	ldw	r2,-2108(fp)
 3203054:	10800044 	addi	r2,r2,1
 3203058:	e0bdf115 	stw	r2,-2108(fp)
			break;
 320305c:	00006e06 	br	3203218 <sss_exec_command+0xe5c>
		case CMD_CONFIGURE: // Reconfigures the camera sensor
			tx_wr_pos += camera_configure(&camera, tx_wr_pos);
 3203060:	e17df117 	ldw	r5,-2108(fp)
 3203064:	0100c974 	movhi	r4,805
 3203068:	21018a04 	addi	r4,r4,1576
 320306c:	32013880 	call	3201388 <camera_configure>
 3203070:	1007883a 	mov	r3,r2
 3203074:	e0bdf117 	ldw	r2,-2108(fp)
 3203078:	10c5883a 	add	r2,r2,r3
 320307c:	e0bdf115 	stw	r2,-2108(fp)
			tx_wr_pos += sprintf(tx_wr_pos, "\n");
 3203080:	e0fdf117 	ldw	r3,-2108(fp)
 3203084:	00800284 	movi	r2,10
 3203088:	18800005 	stb	r2,0(r3)
 320308c:	18000045 	stb	zero,1(r3)
 3203090:	e0bdf117 	ldw	r2,-2108(fp)
 3203094:	10800044 	addi	r2,r2,1
 3203098:	e0bdf115 	stw	r2,-2108(fp)
			break;
 320309c:	00005e06 	br	3203218 <sss_exec_command+0xe5c>
		case CMD_CAPTURE: // Captures the image data (Start/Stop)
			printf("Capturing image...\n");
 32030a0:	0100c974 	movhi	r4,805
 32030a4:	21346c04 	addi	r4,r4,-11856
 32030a8:	3206e040 	call	3206e04 <puts>
			IOWR_CAMERA_CAPTURE_START(CAMERA_BASE);
 32030ac:	00c0d034 	movhi	r3,832
 32030b0:	18c90004 	addi	r3,r3,9216
 32030b4:	00800044 	movi	r2,1
 32030b8:	18800035 	stwio	r2,0(r3)
			IOWR_CAMERA_CAPTURE_STOP(CAMERA_BASE);
 32030bc:	0080d034 	movhi	r2,832
 32030c0:	10890004 	addi	r2,r2,9216
 32030c4:	10000035 	stwio	zero,0(r2)
			//OSTimeDly(1);
			printf("Image captured\n");
 32030c8:	0100c974 	movhi	r4,805
 32030cc:	21347104 	addi	r4,r4,-11836
 32030d0:	3206e040 	call	3206e04 <puts>
			tx_wr_pos += sprintf(tx_wr_pos, "Image captured.\n");
 32030d4:	e0bdf117 	ldw	r2,-2108(fp)
 32030d8:	00c0c974 	movhi	r3,805
 32030dc:	18f47504 	addi	r3,r3,-11820
 32030e0:	1009883a 	mov	r4,r2
 32030e4:	180b883a 	mov	r5,r3
 32030e8:	01800444 	movi	r6,17
 32030ec:	32067cc0 	call	32067cc <memcpy>
 32030f0:	e0bdf117 	ldw	r2,-2108(fp)
 32030f4:	10800404 	addi	r2,r2,16
 32030f8:	e0bdf115 	stw	r2,-2108(fp)
			break;
 32030fc:	00004606 	br	3203218 <sss_exec_command+0xe5c>
		case CMD_DATA:
			// Send image data
			send_data = 1;
 3203100:	00800044 	movi	r2,1
 3203104:	e0bdf005 	stb	r2,-2112(fp)
			printf("RGB image data sending...\n");
 3203108:	0100c974 	movhi	r4,805
 320310c:	21347a04 	addi	r4,r4,-11800
 3203110:	3206e040 	call	3206e04 <puts>
			tx_wr_pos = tx_buf;
 3203114:	e0bdf304 	addi	r2,fp,-2100
 3203118:	e0bdf115 	stw	r2,-2108(fp)
			break;
 320311c:	00003e06 	br	3203218 <sss_exec_command+0xe5c>
		case CMD_GRAY:
			// Send gray image data
			send_data = 2;
 3203120:	00800084 	movi	r2,2
 3203124:	e0bdf005 	stb	r2,-2112(fp)
			printf("Gray image data sending...\n");
 3203128:	0100c974 	movhi	r4,805
 320312c:	21348104 	addi	r4,r4,-11772
 3203130:	3206e040 	call	3206e04 <puts>
			tx_wr_pos = tx_buf;
 3203134:	e0bdf304 	addi	r2,fp,-2100
 3203138:	e0bdf115 	stw	r2,-2108(fp)
			break;
 320313c:	00003606 	br	3203218 <sss_exec_command+0xe5c>
		case CMD_VGA: // Selects the VGA output
			tx_wr_pos += select_vga_output(&camera, tx_wr_pos);
 3203140:	e17df117 	ldw	r5,-2108(fp)
 3203144:	0100c974 	movhi	r4,805
 3203148:	21018a04 	addi	r4,r4,1576
 320314c:	32014e80 	call	32014e8 <select_vga_output>
 3203150:	1007883a 	mov	r3,r2
 3203154:	e0bdf117 	ldw	r2,-2108(fp)
 3203158:	10c5883a 	add	r2,r2,r3
 320315c:	e0bdf115 	stw	r2,-2108(fp)
			tx_wr_pos += sprintf(tx_wr_pos, "\n");
 3203160:	e0fdf117 	ldw	r3,-2108(fp)
 3203164:	00800284 	movi	r2,10
 3203168:	18800005 	stb	r2,0(r3)
 320316c:	18000045 	stb	zero,1(r3)
 3203170:	e0bdf117 	ldw	r2,-2108(fp)
 3203174:	10800044 	addi	r2,r2,1
 3203178:	e0bdf115 	stw	r2,-2108(fp)
			break;
 320317c:	00002606 	br	3203218 <sss_exec_command+0xe5c>
		default:
			if(SSSCommand >= ' ' && SSSCommand <= '~') {
 3203180:	d0a89517 	ldw	r2,-23980(gp)
 3203184:	10800830 	cmpltui	r2,r2,32
 3203188:	10000f1e 	bne	r2,zero,32031c8 <sss_exec_command+0xe0c>
 320318c:	d0a89517 	ldw	r2,-23980(gp)
 3203190:	10801fe8 	cmpgeui	r2,r2,127
 3203194:	10000c1e 	bne	r2,zero,32031c8 <sss_exec_command+0xe0c>
					tx_wr_pos += sprintf(tx_wr_pos,
 3203198:	e13df117 	ldw	r4,-2108(fp)
 320319c:	d0a89517 	ldw	r2,-23980(gp)
 32031a0:	11803fcc 	andi	r6,r2,255
 32031a4:	3180201c 	xori	r6,r6,128
 32031a8:	31bfe004 	addi	r6,r6,-128
 32031ac:	0140c974 	movhi	r5,805
 32031b0:	29748804 	addi	r5,r5,-11744
 32031b4:	32076bc0 	call	32076bc <sprintf>
 32031b8:	1007883a 	mov	r3,r2
 32031bc:	e0bdf117 	ldw	r2,-2108(fp)
 32031c0:	10c5883a 	add	r2,r2,r3
 32031c4:	e0bdf115 	stw	r2,-2108(fp)
							"--> Simple Socket Server Command %c.\n",
							(char)SSSCommand);
			}
			if (SSSCommand == CMD_QUIT) {
 32031c8:	d0a89517 	ldw	r2,-23980(gp)
 32031cc:	10801458 	cmpnei	r2,r2,81
 32031d0:	10000e1e 	bne	r2,zero,320320c <sss_exec_command+0xe50>
					tx_wr_pos += sprintf(tx_wr_pos, "Terminating connection.\n\n\r");
 32031d4:	e0bdf117 	ldw	r2,-2108(fp)
 32031d8:	00c0c974 	movhi	r3,805
 32031dc:	18f49204 	addi	r3,r3,-11704
 32031e0:	1009883a 	mov	r4,r2
 32031e4:	180b883a 	mov	r5,r3
 32031e8:	018006c4 	movi	r6,27
 32031ec:	32067cc0 	call	32067cc <memcpy>
 32031f0:	e0bdf117 	ldw	r2,-2108(fp)
 32031f4:	10800684 	addi	r2,r2,26
 32031f8:	e0bdf115 	stw	r2,-2108(fp)
					conn->close = 1;
 32031fc:	e0fff917 	ldw	r3,-28(fp)
 3203200:	00800044 	movi	r2,1
 3203204:	18800215 	stw	r2,8(r3)
 3203208:	00000306 	br	3203218 <sss_exec_command+0xe5c>
			}
			else {
					alt_SSSErrorHandler(error_code, 0);
 320320c:	e13df043 	ldbu	r4,-2111(fp)
 3203210:	000b883a 	mov	r5,zero
 3203214:	3200ac80 	call	3200ac8 <alt_SSSErrorHandler>
			}
			break;
    }

	// Send image data
    if (send_data) {
 3203218:	e0bdf003 	ldbu	r2,-2112(fp)
 320321c:	1005003a 	cmpeq	r2,r2,zero
 3203220:	1000921e 	bne	r2,zero,320346c <sss_exec_command+0x10b0>
    	// Waits to end of capture
		while (!IORD_CAMERA_CAPTURE_DONE(CAMERA_BASE)) OSTimeDly(1);
 3203224:	00000206 	br	3203230 <sss_exec_command+0xe74>
 3203228:	01000044 	movi	r4,1
 320322c:	321cf780 	call	321cf78 <OSTimeDly>
 3203230:	0080d034 	movhi	r2,832
 3203234:	10890004 	addi	r2,r2,9216
 3203238:	10800037 	ldwio	r2,0(r2)
 320323c:	1005003a 	cmpeq	r2,r2,zero
 3203240:	103ff91e 	bne	r2,zero,3203228 <sss_exec_command+0xe6c>

    	alt_u32 data;
		alt_u8  r, g, b;

		int WIDTH = IORD_CAMERA_WIDTH(CAMERA_BASE);
 3203244:	0080d034 	movhi	r2,832
 3203248:	10890804 	addi	r2,r2,9248
 320324c:	10800037 	ldwio	r2,0(r2)
 3203250:	e0bdea15 	stw	r2,-2136(fp)
		int HEIGHT = IORD_CAMERA_HEIGHT(CAMERA_BASE);
 3203254:	0080d034 	movhi	r2,832
 3203258:	10890a04 	addi	r2,r2,9256
 320325c:	10800037 	ldwio	r2,0(r2)
 3203260:	e0bde915 	stw	r2,-2140(fp)
		//	alt_u8 g;
		//	alt_u8 r;
		//} volatile color;

		//color *col = (color *)(&data);
		if (send_data == 1) {
 3203264:	e0bdf003 	ldbu	r2,-2112(fp)
 3203268:	10800058 	cmpnei	r2,r2,1
 320326c:	10004b1e 	bne	r2,zero,320339c <sss_exec_command+0xfe0>
			// Send RGB image

			int S = (WIDTH / 600) + 1;
 3203270:	e13dea17 	ldw	r4,-2136(fp)
 3203274:	01409604 	movi	r5,600
 3203278:	32043fc0 	call	32043fc <__divsi3>
 320327c:	10800044 	addi	r2,r2,1
 3203280:	e0bde815 	stw	r2,-2144(fp)
			int Y = HEIGHT * S;
 3203284:	e0fde917 	ldw	r3,-2140(fp)
 3203288:	e0bde817 	ldw	r2,-2144(fp)
 320328c:	1885383a 	mul	r2,r3,r2
 3203290:	e0bde715 	stw	r2,-2148(fp)
			int X = WIDTH / S;
 3203294:	e13dea17 	ldw	r4,-2136(fp)
 3203298:	e17de817 	ldw	r5,-2144(fp)
 320329c:	32043fc0 	call	32043fc <__divsi3>
 32032a0:	e0bde615 	stw	r2,-2152(fp)

			register int i;
			register int j;
			for(j = 0; j < Y; j++) {
 32032a4:	e03ffc15 	stw	zero,-16(fp)
 32032a8:	00003806 	br	320338c <sss_exec_command+0xfd0>
				for(i = 0; i < X; i++) {
 32032ac:	e03ffd15 	stw	zero,-12(fp)
 32032b0:	00002406 	br	3203344 <sss_exec_command+0xf88>
					data = IORD_CAMERA_READ_DATA(CAMERA_BASE);
 32032b4:	0080d034 	movhi	r2,832
 32032b8:	10890404 	addi	r2,r2,9232
 32032bc:	10800037 	ldwio	r2,0(r2)
 32032c0:	e0bdec15 	stw	r2,-2128(fp)
					r = data >> 16;
 32032c4:	e0bdec17 	ldw	r2,-2128(fp)
 32032c8:	1004d43a 	srli	r2,r2,16
 32032cc:	e0bdeb85 	stb	r2,-2130(fp)
					g = data >> 8;
 32032d0:	e0bdec17 	ldw	r2,-2128(fp)
 32032d4:	1004d23a 	srli	r2,r2,8
 32032d8:	e0bdeb45 	stb	r2,-2131(fp)
					b = data;
 32032dc:	e0bdec17 	ldw	r2,-2128(fp)
 32032e0:	e0bdeb05 	stb	r2,-2132(fp)
					//tx_wr_pos += sprintf(tx_wr_pos, "%c%c%c", col->r, col->g, col->b);
					tx_wr_pos += sprintf(tx_wr_pos, "%c%c%c", (char) r, (char) g, (char) b);
 32032e4:	e13df117 	ldw	r4,-2108(fp)
 32032e8:	e0bdeb83 	ldbu	r2,-2130(fp)
 32032ec:	11803fcc 	andi	r6,r2,255
 32032f0:	3180201c 	xori	r6,r6,128
 32032f4:	31bfe004 	addi	r6,r6,-128
 32032f8:	e0bdeb43 	ldbu	r2,-2131(fp)
 32032fc:	11c03fcc 	andi	r7,r2,255
 3203300:	39c0201c 	xori	r7,r7,128
 3203304:	39ffe004 	addi	r7,r7,-128
 3203308:	e0bdeb03 	ldbu	r2,-2132(fp)
 320330c:	10803fcc 	andi	r2,r2,255
 3203310:	1080201c 	xori	r2,r2,128
 3203314:	10bfe004 	addi	r2,r2,-128
 3203318:	d8800015 	stw	r2,0(sp)
 320331c:	0140c974 	movhi	r5,805
 3203320:	29749904 	addi	r5,r5,-11676
 3203324:	32076bc0 	call	32076bc <sprintf>
 3203328:	1007883a 	mov	r3,r2
 320332c:	e0bdf117 	ldw	r2,-2108(fp)
 3203330:	10c5883a 	add	r2,r2,r3
 3203334:	e0bdf115 	stw	r2,-2108(fp)
			int X = WIDTH / S;

			register int i;
			register int j;
			for(j = 0; j < Y; j++) {
				for(i = 0; i < X; i++) {
 3203338:	e0bffd17 	ldw	r2,-12(fp)
 320333c:	10800044 	addi	r2,r2,1
 3203340:	e0bffd15 	stw	r2,-12(fp)
 3203344:	e0bde617 	ldw	r2,-2152(fp)
 3203348:	e0fffd17 	ldw	r3,-12(fp)
 320334c:	18bfd916 	blt	r3,r2,32032b4 <sss_exec_command+0xef8>
					g = data >> 8;
					b = data;
					//tx_wr_pos += sprintf(tx_wr_pos, "%c%c%c", col->r, col->g, col->b);
					tx_wr_pos += sprintf(tx_wr_pos, "%c%c%c", (char) r, (char) g, (char) b);
				}
				send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
 3203350:	e0bff917 	ldw	r2,-28(fp)
 3203354:	11000117 	ldw	r4,4(r2)
 3203358:	e17df304 	addi	r5,fp,-2100
 320335c:	e0fdf117 	ldw	r3,-2108(fp)
 3203360:	e0bdf304 	addi	r2,fp,-2100
 3203364:	188dc83a 	sub	r6,r3,r2
 3203368:	000f883a 	mov	r7,zero
 320336c:	322eeb00 	call	322eeb0 <t_send>
				tx_wr_pos = tx_buf;
 3203370:	e0bdf304 	addi	r2,fp,-2100
 3203374:	e0bdf115 	stw	r2,-2108(fp)
				OSTimeDly(1);
 3203378:	01000044 	movi	r4,1
 320337c:	321cf780 	call	321cf78 <OSTimeDly>
			int Y = HEIGHT * S;
			int X = WIDTH / S;

			register int i;
			register int j;
			for(j = 0; j < Y; j++) {
 3203380:	e13ffc17 	ldw	r4,-16(fp)
 3203384:	21000044 	addi	r4,r4,1
 3203388:	e13ffc15 	stw	r4,-16(fp)
 320338c:	e0bde717 	ldw	r2,-2148(fp)
 3203390:	e0fffc17 	ldw	r3,-16(fp)
 3203394:	18bfc516 	blt	r3,r2,32032ac <sss_exec_command+0xef0>
 3203398:	00003206 	br	3203464 <sss_exec_command+0x10a8>
				send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
				tx_wr_pos = tx_buf;
				OSTimeDly(1);
			}
		}
		else if (send_data == 2) {
 320339c:	e0bdf003 	ldbu	r2,-2112(fp)
 32033a0:	10800098 	cmpnei	r2,r2,2
 32033a4:	10002f1e 	bne	r2,zero,3203464 <sss_exec_command+0x10a8>
			// Send gray image
			register int i;
			register int j;
			for(j = 0; j < HEIGHT; j++) {
 32033a8:	e03ffa15 	stw	zero,-24(fp)
 32033ac:	00002a06 	br	3203458 <sss_exec_command+0x109c>
				for(i = 0; i < WIDTH; i++) {
 32033b0:	e03ffb15 	stw	zero,-20(fp)
 32033b4:	00001606 	br	3203410 <sss_exec_command+0x1054>
					data = IORD_CAMERA_READ_DATA(CAMERA_BASE);
 32033b8:	0080d034 	movhi	r2,832
 32033bc:	10890404 	addi	r2,r2,9232
 32033c0:	10800037 	ldwio	r2,0(r2)
 32033c4:	e0bdec15 	stw	r2,-2128(fp)
					g = data >> 24;
 32033c8:	e0bdec17 	ldw	r2,-2128(fp)
 32033cc:	1004d63a 	srli	r2,r2,24
 32033d0:	e0bdeb45 	stb	r2,-2131(fp)
					tx_wr_pos += sprintf(tx_wr_pos, "%c", (char) g);
 32033d4:	e13df117 	ldw	r4,-2108(fp)
 32033d8:	e0bdeb43 	ldbu	r2,-2131(fp)
 32033dc:	11803fcc 	andi	r6,r2,255
 32033e0:	3180201c 	xori	r6,r6,128
 32033e4:	31bfe004 	addi	r6,r6,-128
 32033e8:	0140c974 	movhi	r5,805
 32033ec:	29749b04 	addi	r5,r5,-11668
 32033f0:	32076bc0 	call	32076bc <sprintf>
 32033f4:	1007883a 	mov	r3,r2
 32033f8:	e0bdf117 	ldw	r2,-2108(fp)
 32033fc:	10c5883a 	add	r2,r2,r3
 3203400:	e0bdf115 	stw	r2,-2108(fp)
		else if (send_data == 2) {
			// Send gray image
			register int i;
			register int j;
			for(j = 0; j < HEIGHT; j++) {
				for(i = 0; i < WIDTH; i++) {
 3203404:	e13ffb17 	ldw	r4,-20(fp)
 3203408:	21000044 	addi	r4,r4,1
 320340c:	e13ffb15 	stw	r4,-20(fp)
 3203410:	e0bdea17 	ldw	r2,-2136(fp)
 3203414:	e0fffb17 	ldw	r3,-20(fp)
 3203418:	18bfe716 	blt	r3,r2,32033b8 <sss_exec_command+0xffc>
					data = IORD_CAMERA_READ_DATA(CAMERA_BASE);
					g = data >> 24;
					tx_wr_pos += sprintf(tx_wr_pos, "%c", (char) g);
				}
				send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
 320341c:	e0bff917 	ldw	r2,-28(fp)
 3203420:	11000117 	ldw	r4,4(r2)
 3203424:	e17df304 	addi	r5,fp,-2100
 3203428:	e0fdf117 	ldw	r3,-2108(fp)
 320342c:	e0bdf304 	addi	r2,fp,-2100
 3203430:	188dc83a 	sub	r6,r3,r2
 3203434:	000f883a 	mov	r7,zero
 3203438:	322eeb00 	call	322eeb0 <t_send>
				tx_wr_pos = tx_buf;
 320343c:	e0bdf304 	addi	r2,fp,-2100
 3203440:	e0bdf115 	stw	r2,-2108(fp)
				OSTimeDly(1);
 3203444:	01000044 	movi	r4,1
 3203448:	321cf780 	call	321cf78 <OSTimeDly>
		}
		else if (send_data == 2) {
			// Send gray image
			register int i;
			register int j;
			for(j = 0; j < HEIGHT; j++) {
 320344c:	e13ffa17 	ldw	r4,-24(fp)
 3203450:	21000044 	addi	r4,r4,1
 3203454:	e13ffa15 	stw	r4,-24(fp)
 3203458:	e0bde917 	ldw	r2,-2140(fp)
 320345c:	e0fffa17 	ldw	r3,-24(fp)
 3203460:	18bfd316 	blt	r3,r2,32033b0 <sss_exec_command+0xff4>
				send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
				tx_wr_pos = tx_buf;
				OSTimeDly(1);
			}
		}
		send_data = 0;
 3203464:	e03df005 	stb	zero,-2112(fp)
 3203468:	00000a06 	br	3203494 <sss_exec_command+0x10d8>
    }
    else {
        // Send buffer
        send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
 320346c:	e0bff917 	ldw	r2,-28(fp)
 3203470:	11000117 	ldw	r4,4(r2)
 3203474:	e17df304 	addi	r5,fp,-2100
 3203478:	e0fdf117 	ldw	r3,-2108(fp)
 320347c:	e0bdf304 	addi	r2,fp,-2100
 3203480:	188dc83a 	sub	r6,r3,r2
 3203484:	000f883a 	mov	r7,zero
 3203488:	322eeb00 	call	322eeb0 <t_send>
        tx_wr_pos = tx_buf;
 320348c:	e0bdf304 	addi	r2,fp,-2100
 3203490:	e0bdf115 	stw	r2,-2108(fp)
    }
}
 3203494:	e037883a 	mov	sp,fp
 3203498:	dfc00217 	ldw	ra,8(sp)
 320349c:	df000117 	ldw	fp,4(sp)
 32034a0:	dc000017 	ldw	r16,0(sp)
 32034a4:	dec00304 	addi	sp,sp,12
 32034a8:	f800283a 	ret

032034ac <sss_handle_accept>:
 * connection request and call the telent_send_menu() routine to transmit
 * instructions to the user, and print out the client's IP address. Otherwise,
 * the connection is already in use, reject the incoming request by
 * immediately closing the new socket.
 */
void sss_handle_accept(int listen_socket, SSSConn* conn) {
 32034ac:	defff604 	addi	sp,sp,-40
 32034b0:	dfc00915 	stw	ra,36(sp)
 32034b4:	df000815 	stw	fp,32(sp)
 32034b8:	df000804 	addi	fp,sp,32
 32034bc:	e13ffe15 	stw	r4,-8(fp)
 32034c0:	e17fff15 	stw	r5,-4(fp)
	int	socket, len;
	struct sockaddr_in  incoming_addr;

	len = sizeof(incoming_addr);
 32034c4:	00800404 	movi	r2,16
 32034c8:	e0bff915 	stw	r2,-28(fp)

	if ((conn)->fd == -1) {
 32034cc:	e0bfff17 	ldw	r2,-4(fp)
 32034d0:	10800117 	ldw	r2,4(r2)
 32034d4:	10bfffd8 	cmpnei	r2,r2,-1
 32034d8:	1000191e 	bne	r2,zero,3203540 <sss_handle_accept+0x94>
		if((socket=accept(listen_socket, (struct sockaddr*) &incoming_addr, &len)) <0) {
 32034dc:	e17ffa04 	addi	r5,fp,-24
 32034e0:	e1bff904 	addi	r6,fp,-28
 32034e4:	e13ffe17 	ldw	r4,-8(fp)
 32034e8:	3224df80 	call	3224df8 <bsd_accept>
 32034ec:	e0bff815 	stw	r2,-32(fp)
 32034f0:	e0bff817 	ldw	r2,-32(fp)
 32034f4:	1004403a 	cmpge	r2,r2,zero
 32034f8:	1000051e 	bne	r2,zero,3203510 <sss_handle_accept+0x64>
			alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,
 32034fc:	01003fc4 	movi	r4,255
 3203500:	0140c974 	movhi	r5,805
 3203504:	29749c04 	addi	r5,r5,-11664
 3203508:	32008300 	call	3200830 <alt_NetworkErrorHandler>
 320350c:	00001206 	br	3203558 <sss_handle_accept+0xac>
					"[sss_handle_accept] accept failed");
		}
		else {
			(conn)->fd = socket;
 3203510:	e0bfff17 	ldw	r2,-4(fp)
 3203514:	e0fff817 	ldw	r3,-32(fp)
 3203518:	10c00115 	stw	r3,4(r2)
			sss_send_menu(conn);
 320351c:	e13fff17 	ldw	r4,-4(fp)
 3203520:	32020ec0 	call	32020ec <sss_send_menu>
			printf("[sss_handle_accept] accepted connection request from %s\n",
 3203524:	e13ffb17 	ldw	r4,-20(fp)
 3203528:	32255640 	call	3225564 <bsd_inet_ntoa>
 320352c:	100b883a 	mov	r5,r2
 3203530:	0100c974 	movhi	r4,805
 3203534:	2134a504 	addi	r4,r4,-11628
 3203538:	3206adc0 	call	3206adc <printf>
 320353c:	00000606 	br	3203558 <sss_handle_accept+0xac>
					inet_ntoa(incoming_addr.sin_addr));
		}
	}
	else {
		printf("[sss_handle_accept] rejected connection request from %s\n",
 3203540:	e13ffb17 	ldw	r4,-20(fp)
 3203544:	32255640 	call	3225564 <bsd_inet_ntoa>
 3203548:	100b883a 	mov	r5,r2
 320354c:	0100c974 	movhi	r4,805
 3203550:	2134b404 	addi	r4,r4,-11568
 3203554:	3206adc0 	call	3206adc <printf>
				inet_ntoa(incoming_addr.sin_addr));
	}
}
 3203558:	e037883a 	mov	sp,fp
 320355c:	dfc00117 	ldw	ra,4(sp)
 3203560:	df000017 	ldw	fp,0(sp)
 3203564:	dec00204 	addi	sp,sp,8
 3203568:	f800283a 	ret

0320356c <sss_handle_receive>:
 * and popped off from the beginning of the buffer with the 
 * sss_exec_command() routine. Aside from these, we must move incoming
 * (un-processed) data to buffer start as appropriate and keep track of 
 * associated pointers.
 */
void sss_handle_receive(SSSConn* conn) {
 320356c:	defff904 	addi	sp,sp,-28
 3203570:	dfc00615 	stw	ra,24(sp)
 3203574:	df000515 	stw	fp,20(sp)
 3203578:	df000504 	addi	fp,sp,20
 320357c:	e13ffe15 	stw	r4,-8(fp)
	int data_used = 0, rx_code = 0;
 3203580:	e03ffd15 	stw	zero,-12(fp)
 3203584:	e03ffc15 	stw	zero,-16(fp)
	INT8U *lf_addr;

	conn->rx_rd_pos = conn->rx_buffer;
 3203588:	e0bffe17 	ldw	r2,-8(fp)
 320358c:	10c00304 	addi	r3,r2,12
 3203590:	e0bffe17 	ldw	r2,-8(fp)
 3203594:	10c20315 	stw	r3,2060(r2)
	conn->rx_wr_pos = conn->rx_buffer;
 3203598:	e0bffe17 	ldw	r2,-8(fp)
 320359c:	10c00304 	addi	r3,r2,12
 32035a0:	e0bffe17 	ldw	r2,-8(fp)
 32035a4:	10c20415 	stw	r3,2064(r2)

	printf("[sss_handle_receive] processing RX data\n");
 32035a8:	0100c974 	movhi	r4,805
 32035ac:	2134c304 	addi	r4,r4,-11508
 32035b0:	3206e040 	call	3206e04 <puts>

	while(conn->state != CLOSE) {
 32035b4:	00005706 	br	3203714 <sss_handle_receive+0x1a8>
		/* Find the Carriage return which marks the end of the header
		 * and go do whatever the user wanted us to do.
		 * Or, if no newline received, then ask the socket for data.
		 */
		lf_addr = strchr(conn->rx_buffer, '\n');
 32035b8:	e0bffe17 	ldw	r2,-8(fp)
 32035bc:	10800304 	addi	r2,r2,12
 32035c0:	1009883a 	mov	r4,r2
 32035c4:	01400284 	movi	r5,10
 32035c8:	32079f00 	call	32079f0 <strchr>
 32035cc:	e0bffb15 	stw	r2,-20(fp)

		if(lf_addr) {
 32035d0:	e0bffb17 	ldw	r2,-20(fp)
 32035d4:	1005003a 	cmpeq	r2,r2,zero
 32035d8:	1000031e 	bne	r2,zero,32035e8 <sss_handle_receive+0x7c>
			sss_exec_command(conn);
 32035dc:	e13ffe17 	ldw	r4,-8(fp)
 32035e0:	32023bc0 	call	32023bc <sss_exec_command>
 32035e4:	00001c06 	br	3203658 <sss_handle_receive+0xec>
		}
		else {
			rx_code = recv(conn->fd, conn->rx_wr_pos,
 32035e8:	e0bffe17 	ldw	r2,-8(fp)
 32035ec:	11000117 	ldw	r4,4(r2)
 32035f0:	e0bffe17 	ldw	r2,-8(fp)
 32035f4:	10820417 	ldw	r2,2064(r2)
 32035f8:	100b883a 	mov	r5,r2
 32035fc:	e0bffe17 	ldw	r2,-8(fp)
 3203600:	10800304 	addi	r2,r2,12
 3203604:	1007883a 	mov	r3,r2
 3203608:	e0bffe17 	ldw	r2,-8(fp)
 320360c:	10820417 	ldw	r2,2064(r2)
 3203610:	1885c83a 	sub	r2,r3,r2
 3203614:	1181ffc4 	addi	r6,r2,2047
 3203618:	000f883a 	mov	r7,zero
 320361c:	322ea440 	call	322ea44 <t_recv>
 3203620:	e0bffc15 	stw	r2,-16(fp)
					SSS_RX_BUF_SIZE - (conn->rx_wr_pos - conn->rx_buffer) - 1, 0);

			if(rx_code > 0) {
 3203624:	e0bffc17 	ldw	r2,-16(fp)
 3203628:	10800050 	cmplti	r2,r2,1
 320362c:	10000a1e 	bne	r2,zero,3203658 <sss_handle_receive+0xec>
				conn->rx_wr_pos += rx_code;
 3203630:	e0bffe17 	ldw	r2,-8(fp)
 3203634:	10c20417 	ldw	r3,2064(r2)
 3203638:	e0bffc17 	ldw	r2,-16(fp)
 320363c:	1887883a 	add	r3,r3,r2
 3203640:	e0bffe17 	ldw	r2,-8(fp)
 3203644:	10c20415 	stw	r3,2064(r2)

				/* Zero terminate so we can use string functions */
				*(conn->rx_wr_pos + 1) = 0;
 3203648:	e0bffe17 	ldw	r2,-8(fp)
 320364c:	10820417 	ldw	r2,2064(r2)
 3203650:	10800044 	addi	r2,r2,1
 3203654:	10000005 	stb	zero,0(r2)

		/*
		 * When the quit command is received, update our connection state so that
		 * we can exit the while() loop and close the connection
		 */
		conn->state = conn->close ? CLOSE : READY;
 3203658:	e0bffe17 	ldw	r2,-8(fp)
 320365c:	10800217 	ldw	r2,8(r2)
 3203660:	1005003a 	cmpeq	r2,r2,zero
 3203664:	1000031e 	bne	r2,zero,3203674 <sss_handle_receive+0x108>
 3203668:	00800084 	movi	r2,2
 320366c:	e0bfff15 	stw	r2,-4(fp)
 3203670:	00000106 	br	3203678 <sss_handle_receive+0x10c>
 3203674:	e03fff15 	stw	zero,-4(fp)
 3203678:	e0bffe17 	ldw	r2,-8(fp)
 320367c:	e0ffff17 	ldw	r3,-4(fp)
 3203680:	10c00015 	stw	r3,0(r2)

		/* Manage buffer */
		data_used = conn->rx_rd_pos - conn->rx_buffer;
 3203684:	e0bffe17 	ldw	r2,-8(fp)
 3203688:	10820317 	ldw	r2,2060(r2)
 320368c:	1007883a 	mov	r3,r2
 3203690:	e0bffe17 	ldw	r2,-8(fp)
 3203694:	10800304 	addi	r2,r2,12
 3203698:	1885c83a 	sub	r2,r3,r2
 320369c:	e0bffd15 	stw	r2,-12(fp)
		memmove(conn->rx_buffer, conn->rx_rd_pos,
 32036a0:	e0bffe17 	ldw	r2,-8(fp)
 32036a4:	11000304 	addi	r4,r2,12
 32036a8:	e0bffe17 	ldw	r2,-8(fp)
 32036ac:	11420317 	ldw	r5,2060(r2)
 32036b0:	e0bffe17 	ldw	r2,-8(fp)
 32036b4:	10820417 	ldw	r2,2064(r2)
 32036b8:	1007883a 	mov	r3,r2
 32036bc:	e0bffe17 	ldw	r2,-8(fp)
 32036c0:	10820317 	ldw	r2,2060(r2)
 32036c4:	1885c83a 	sub	r2,r3,r2
 32036c8:	100d883a 	mov	r6,r2
 32036cc:	320686c0 	call	320686c <memmove>
				conn->rx_wr_pos - conn->rx_rd_pos);
		conn->rx_rd_pos = conn->rx_buffer;
 32036d0:	e0bffe17 	ldw	r2,-8(fp)
 32036d4:	10c00304 	addi	r3,r2,12
 32036d8:	e0bffe17 	ldw	r2,-8(fp)
 32036dc:	10c20315 	stw	r3,2060(r2)
		conn->rx_wr_pos -= data_used;
 32036e0:	e0bffe17 	ldw	r2,-8(fp)
 32036e4:	10c20417 	ldw	r3,2064(r2)
 32036e8:	e0bffd17 	ldw	r2,-12(fp)
 32036ec:	1887c83a 	sub	r3,r3,r2
 32036f0:	e0bffe17 	ldw	r2,-8(fp)
 32036f4:	10c20415 	stw	r3,2064(r2)
		memset(conn->rx_wr_pos, 0, data_used);
 32036f8:	e0bffe17 	ldw	r2,-8(fp)
 32036fc:	10820417 	ldw	r2,2064(r2)
 3203700:	e0fffd17 	ldw	r3,-12(fp)
 3203704:	1009883a 	mov	r4,r2
 3203708:	180d883a 	mov	r6,r3
 320370c:	000b883a 	mov	r5,zero
 3203710:	320694c0 	call	320694c <memset>
	conn->rx_rd_pos = conn->rx_buffer;
	conn->rx_wr_pos = conn->rx_buffer;

	printf("[sss_handle_receive] processing RX data\n");

	while(conn->state != CLOSE) {
 3203714:	e0bffe17 	ldw	r2,-8(fp)
 3203718:	10800017 	ldw	r2,0(r2)
 320371c:	10800098 	cmpnei	r2,r2,2
 3203720:	103fa51e 	bne	r2,zero,32035b8 <sss_handle_receive+0x4c>
		conn->rx_rd_pos = conn->rx_buffer;
		conn->rx_wr_pos -= data_used;
		memset(conn->rx_wr_pos, 0, data_used);
	}

	printf("[sss_handle_receive] closing connection\n");
 3203724:	0100c974 	movhi	r4,805
 3203728:	2134cd04 	addi	r4,r4,-11468
 320372c:	3206e040 	call	3206e04 <puts>
	close(conn->fd);
 3203730:	e0bffe17 	ldw	r2,-8(fp)
 3203734:	11000117 	ldw	r4,4(r2)
 3203738:	32227dc0 	call	32227dc <close>
	sss_reset_connection(conn);
 320373c:	e13ffe17 	ldw	r4,-8(fp)
 3203740:	320207c0 	call	320207c <sss_reset_connection>
}
 3203744:	e037883a 	mov	sp,fp
 3203748:	dfc00117 	ldw	ra,4(sp)
 320374c:	df000017 	ldw	fp,0(sp)
 3203750:	dec00204 	addi	sp,sp,8
 3203754:	f800283a 	ret

03203758 <SSSSimpleSocketServerTask>:
 * it perpetually waits for incoming data to either the listening socket, or
 * (if a connection is active), the sss data socket. When data arrives, 
 * the approrpriate routine is called to either accept/reject a connection 
 * request, or process incoming data.
 */
void SSSSimpleSocketServerTask() {
 3203758:	deffb604 	addi	sp,sp,-296
 320375c:	dfc04915 	stw	ra,292(sp)
 3203760:	df004815 	stw	fp,288(sp)
 3203764:	df004804 	addi	fp,sp,288
	 *
	 * The listen socket is a socket which is waiting for incoming connections.
	 * This call to listen will block (i.e. not return) until someone tries to
	 * connect to this port.
	 */
	if ((fd_listen = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
 3203768:	01000084 	movi	r4,2
 320376c:	01400044 	movi	r5,1
 3203770:	000d883a 	mov	r6,zero
 3203774:	322dc100 	call	322dc10 <t_socket>
 3203778:	e0bfba15 	stw	r2,-280(fp)
 320377c:	e0bfba17 	ldw	r2,-280(fp)
 3203780:	1004403a 	cmpge	r2,r2,zero
 3203784:	1000041e 	bne	r2,zero,3203798 <SSSSimpleSocketServerTask+0x40>
		alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE, "[sss_task] Socket creation failed");
 3203788:	01003fc4 	movi	r4,255
 320378c:	0140c974 	movhi	r5,805
 3203790:	2974d704 	addi	r5,r5,-11428
 3203794:	32008300 	call	3200830 <alt_NetworkErrorHandler>
	}

	addr.sin_family = AF_INET;
 3203798:	00800084 	movi	r2,2
 320379c:	e0bfbb0d 	sth	r2,-276(fp)
	addr.sin_port = htons(SSS_PORT);
 32037a0:	00a344c4 	movi	r2,-29421
 32037a4:	e0bfbb8d 	sth	r2,-274(fp)
	addr.sin_addr.s_addr = INADDR_ANY;
 32037a8:	e03fbc15 	stw	zero,-272(fp)
  
	if ((bind(fd_listen, (struct sockaddr *) & addr, sizeof(addr))) < 0) {
 32037ac:	e17fbb04 	addi	r5,fp,-276
 32037b0:	e13fba17 	ldw	r4,-280(fp)
 32037b4:	01800404 	movi	r6,16
 32037b8:	322dca00 	call	322dca0 <t_bind>
 32037bc:	1004403a 	cmpge	r2,r2,zero
 32037c0:	1000041e 	bne	r2,zero,32037d4 <SSSSimpleSocketServerTask+0x7c>
		alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE, "[sss_task] Bind failed");
 32037c4:	01003fc4 	movi	r4,255
 32037c8:	0140c974 	movhi	r5,805
 32037cc:	2974e004 	addi	r5,r5,-11392
 32037d0:	32008300 	call	3200830 <alt_NetworkErrorHandler>
	}

	if ((listen(fd_listen, 1)) < 0) {
 32037d4:	e13fba17 	ldw	r4,-280(fp)
 32037d8:	01400044 	movi	r5,1
 32037dc:	322de1c0 	call	322de1c <t_listen>
 32037e0:	1004403a 	cmpge	r2,r2,zero
 32037e4:	1000041e 	bne	r2,zero,32037f8 <SSSSimpleSocketServerTask+0xa0>
		alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE, "[sss_task] Listen failed");
 32037e8:	01003fc4 	movi	r4,255
 32037ec:	0140c974 	movhi	r5,805
 32037f0:	2974e604 	addi	r5,r5,-11368
 32037f4:	32008300 	call	3200830 <alt_NetworkErrorHandler>
	}

	/* At this point we have successfully created a socket which is listening
	 * on SSS_PORT for connection requests from any remote address.
	 */
	sss_reset_connection(&conn);
 32037f8:	0100c974 	movhi	r4,805
 32037fc:	21128b04 	addi	r4,r4,18988
 3203800:	320207c0 	call	320207c <sss_reset_connection>
	printf("[sss_task] Simple Socket Server listening on port %d\n", SSS_PORT);
 3203804:	0100c974 	movhi	r4,805
 3203808:	2134ed04 	addi	r4,r4,-11340
 320380c:	0144e344 	movi	r5,5005
 3203810:	3206adc0 	call	3206adc <printf>
 3203814:	00000006 	br	3203818 <SSSSimpleSocketServerTask+0xc0>
		 *
		 *   FD_ZERO  - Zero's out the sockets we're interested in
		 *   FD_SET   - Adds a socket to those we're interested in
		 *   FD_ISSET - Tests whether the chosen socket is set
		 */
		FD_ZERO(&readfds);
 3203818:	e03fbf15 	stw	zero,-260(fp)
		FD_SET(fd_listen, &readfds);
 320381c:	e17fbf04 	addi	r5,fp,-260
 3203820:	e13fba17 	ldw	r4,-280(fp)
 3203824:	32331fc0 	call	32331fc <ifd_set>
		max_socket = fd_listen + 1;
 3203828:	e0bfba17 	ldw	r2,-280(fp)
 320382c:	10800044 	addi	r2,r2,1
 3203830:	e0bfb915 	stw	r2,-284(fp)

		if (conn.fd != -1) {
 3203834:	0080c974 	movhi	r2,805
 3203838:	10928b04 	addi	r2,r2,18988
 320383c:	10800117 	ldw	r2,4(r2)
 3203840:	10bfffe0 	cmpeqi	r2,r2,-1
 3203844:	10000f1e 	bne	r2,zero,3203884 <SSSSimpleSocketServerTask+0x12c>
			FD_SET(conn.fd, &readfds);
 3203848:	0080c974 	movhi	r2,805
 320384c:	10928b04 	addi	r2,r2,18988
 3203850:	11000117 	ldw	r4,4(r2)
 3203854:	e17fbf04 	addi	r5,fp,-260
 3203858:	32331fc0 	call	32331fc <ifd_set>
			if (max_socket <= conn.fd) {
 320385c:	0080c974 	movhi	r2,805
 3203860:	10928b04 	addi	r2,r2,18988
 3203864:	10c00117 	ldw	r3,4(r2)
 3203868:	e0bfb917 	ldw	r2,-284(fp)
 320386c:	18800516 	blt	r3,r2,3203884 <SSSSimpleSocketServerTask+0x12c>
				max_socket = conn.fd + 1;
 3203870:	0080c974 	movhi	r2,805
 3203874:	10928b04 	addi	r2,r2,18988
 3203878:	10800117 	ldw	r2,4(r2)
 320387c:	10800044 	addi	r2,r2,1
 3203880:	e0bfb915 	stw	r2,-284(fp)
			}
		}

		select(max_socket, &readfds, NULL, NULL, NULL);
 3203884:	e17fbf04 	addi	r5,fp,-260
 3203888:	d8000015 	stw	zero,0(sp)
 320388c:	e13fb917 	ldw	r4,-284(fp)
 3203890:	000d883a 	mov	r6,zero
 3203894:	000f883a 	mov	r7,zero
 3203898:	32256f40 	call	32256f4 <bsd_select>
		 * independent of the listening socket we created above. This socket's
		 * descriptor is stored in conn.fd. If conn.fs is set in readfs... we have
		 * incoming data for our sss server, and we call our receiver routine
		 * to process it.
		 */
		if (FD_ISSET(fd_listen, &readfds)) {
 320389c:	e17fbf04 	addi	r5,fp,-260
 32038a0:	e13fba17 	ldw	r4,-280(fp)
 32038a4:	32332700 	call	3233270 <ifd_isset>
 32038a8:	1005003a 	cmpeq	r2,r2,zero
 32038ac:	1000051e 	bne	r2,zero,32038c4 <SSSSimpleSocketServerTask+0x16c>
			sss_handle_accept(fd_listen, &conn);
 32038b0:	e13fba17 	ldw	r4,-280(fp)
 32038b4:	0140c974 	movhi	r5,805
 32038b8:	29528b04 	addi	r5,r5,18988
 32038bc:	32034ac0 	call	32034ac <sss_handle_accept>
 32038c0:	003fd506 	br	3203818 <SSSSimpleSocketServerTask+0xc0>
		}
		else {
			if ((conn.fd != -1) && FD_ISSET(conn.fd, &readfds)) {
 32038c4:	0080c974 	movhi	r2,805
 32038c8:	10928b04 	addi	r2,r2,18988
 32038cc:	10800117 	ldw	r2,4(r2)
 32038d0:	10bfffe0 	cmpeqi	r2,r2,-1
 32038d4:	103fd01e 	bne	r2,zero,3203818 <SSSSimpleSocketServerTask+0xc0>
 32038d8:	0080c974 	movhi	r2,805
 32038dc:	10928b04 	addi	r2,r2,18988
 32038e0:	11000117 	ldw	r4,4(r2)
 32038e4:	e17fbf04 	addi	r5,fp,-260
 32038e8:	32332700 	call	3233270 <ifd_isset>
 32038ec:	1005003a 	cmpeq	r2,r2,zero
 32038f0:	103fc91e 	bne	r2,zero,3203818 <SSSSimpleSocketServerTask+0xc0>
				sss_handle_receive(&conn);
 32038f4:	0100c974 	movhi	r4,805
 32038f8:	21128b04 	addi	r4,r4,18988
 32038fc:	320356c0 	call	320356c <sss_handle_receive>
			}
		}
	}
 3203900:	003fc506 	br	3203818 <SSSSimpleSocketServerTask+0xc0>

03203904 <trackers_init>:
// Creates the trackers handlers devices
LOCATOR trackers[TRACKERS];

/* Initializes the trackers handlers. */
void trackers_init()
{
 3203904:	defffe04 	addi	sp,sp,-8
 3203908:	dfc00115 	stw	ra,4(sp)
 320390c:	df000015 	stw	fp,0(sp)
 3203910:	d839883a 	mov	fp,sp
	locator_init(&trackers[0], TRACKER(0));
 3203914:	0100c9b4 	movhi	r4,806
 3203918:	2124ba04 	addi	r4,r4,-27928
 320391c:	01404034 	movhi	r5,256
 3203920:	29414004 	addi	r5,r5,1280
 3203924:	32211440 	call	3221144 <locator_init>
	locator_init(&trackers[1], TRACKER(1));
 3203928:	0100c9b4 	movhi	r4,806
 320392c:	2124bd04 	addi	r4,r4,-27916
 3203930:	01404034 	movhi	r5,256
 3203934:	29410004 	addi	r5,r5,1024
 3203938:	32211440 	call	3221144 <locator_init>
	locator_init(&trackers[2], TRACKER(2));
 320393c:	0100c9b4 	movhi	r4,806
 3203940:	2124c004 	addi	r4,r4,-27904
 3203944:	01404034 	movhi	r5,256
 3203948:	2940c004 	addi	r5,r5,768
 320394c:	32211440 	call	3221144 <locator_init>
	locator_init(&trackers[3], TRACKER(3));
 3203950:	0100c9b4 	movhi	r4,806
 3203954:	2124c304 	addi	r4,r4,-27892
 3203958:	01404034 	movhi	r5,256
 320395c:	29408004 	addi	r5,r5,512
 3203960:	32211440 	call	3221144 <locator_init>
	locator_init(&trackers[4], TRACKER(4));
 3203964:	0100c9b4 	movhi	r4,806
 3203968:	2124c604 	addi	r4,r4,-27880
 320396c:	01404034 	movhi	r5,256
 3203970:	29404004 	addi	r5,r5,256
 3203974:	32211440 	call	3221144 <locator_init>
	locator_init(&trackers[4], TRACKER(5));
 3203978:	0100c9b4 	movhi	r4,806
 320397c:	2124c604 	addi	r4,r4,-27880
 3203980:	01404034 	movhi	r5,256
 3203984:	32211440 	call	3221144 <locator_init>
}
 3203988:	e037883a 	mov	sp,fp
 320398c:	dfc00117 	ldw	ra,4(sp)
 3203990:	df000017 	ldw	fp,0(sp)
 3203994:	dec00204 	addi	sp,sp,8
 3203998:	f800283a 	ret

0320399c <trackers_number>:

/* Gets the number of the tracker resources. */
int trackers_number()
{
 320399c:	deffff04 	addi	sp,sp,-4
 32039a0:	df000015 	stw	fp,0(sp)
 32039a4:	d839883a 	mov	fp,sp
	return TRACKERS;
 32039a8:	00800184 	movi	r2,6
}
 32039ac:	e037883a 	mov	sp,fp
 32039b0:	df000017 	ldw	fp,0(sp)
 32039b4:	dec00104 	addi	sp,sp,4
 32039b8:	f800283a 	ret

032039bc <trackers_free>:

/* Frees all tracker handlers. */
int trackers_free(char *char_buffer)
{
 32039bc:	defffc04 	addi	sp,sp,-16
 32039c0:	dfc00315 	stw	ra,12(sp)
 32039c4:	df000215 	stw	fp,8(sp)
 32039c8:	df000204 	addi	fp,sp,8
 32039cc:	e13fff15 	stw	r4,-4(fp)
	int i;
	for (i = 0; i < TRACKERS; i++) {
 32039d0:	e03ffe15 	stw	zero,-8(fp)
 32039d4:	00001106 	br	3203a1c <trackers_free+0x60>
		trackers[i].active = 0;
 32039d8:	e0bffe17 	ldw	r2,-8(fp)
 32039dc:	00c0c9b4 	movhi	r3,806
 32039e0:	18e4ba04 	addi	r3,r3,-27928
 32039e4:	10800324 	muli	r2,r2,12
 32039e8:	10c5883a 	add	r2,r2,r3
 32039ec:	10800204 	addi	r2,r2,8
 32039f0:	10000015 	stw	zero,0(r2)
		trackers[i].id = 0;
 32039f4:	e0bffe17 	ldw	r2,-8(fp)
 32039f8:	00c0c9b4 	movhi	r3,806
 32039fc:	18e4ba04 	addi	r3,r3,-27928
 3203a00:	10800324 	muli	r2,r2,12
 3203a04:	10c5883a 	add	r2,r2,r3
 3203a08:	10800104 	addi	r2,r2,4
 3203a0c:	10000015 	stw	zero,0(r2)

/* Frees all tracker handlers. */
int trackers_free(char *char_buffer)
{
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203a10:	e0bffe17 	ldw	r2,-8(fp)
 3203a14:	10800044 	addi	r2,r2,1
 3203a18:	e0bffe15 	stw	r2,-8(fp)
 3203a1c:	e0bffe17 	ldw	r2,-8(fp)
 3203a20:	10800190 	cmplti	r2,r2,6
 3203a24:	103fec1e 	bne	r2,zero,32039d8 <trackers_free+0x1c>
		trackers[i].active = 0;
		trackers[i].id = 0;
	}
	return sprintf(char_buffer, "All trackers freed.");
 3203a28:	e0bfff17 	ldw	r2,-4(fp)
 3203a2c:	00c0c974 	movhi	r3,805
 3203a30:	18f4fb04 	addi	r3,r3,-11284
 3203a34:	1009883a 	mov	r4,r2
 3203a38:	180b883a 	mov	r5,r3
 3203a3c:	01800504 	movi	r6,20
 3203a40:	32067cc0 	call	32067cc <memcpy>
 3203a44:	008004c4 	movi	r2,19
}
 3203a48:	e037883a 	mov	sp,fp
 3203a4c:	dfc00117 	ldw	ra,4(sp)
 3203a50:	df000017 	ldw	fp,0(sp)
 3203a54:	dec00204 	addi	sp,sp,8
 3203a58:	f800283a 	ret

03203a5c <activate_tracker>:

/* Activates a tracker device. */
int activate_tracker(int id, char *char_buffer)
{
 3203a5c:	defffa04 	addi	sp,sp,-24
 3203a60:	dfc00515 	stw	ra,20(sp)
 3203a64:	df000415 	stw	fp,16(sp)
 3203a68:	df000404 	addi	fp,sp,16
 3203a6c:	e13ffd15 	stw	r4,-12(fp)
 3203a70:	e17ffe15 	stw	r5,-8(fp)
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203a74:	e03ffc15 	stw	zero,-16(fp)
 3203a78:	00001b06 	br	3203ae8 <activate_tracker+0x8c>
		if (trackers[i].id == id) {
 3203a7c:	e0bffc17 	ldw	r2,-16(fp)
 3203a80:	00c0c9b4 	movhi	r3,806
 3203a84:	18e4ba04 	addi	r3,r3,-27928
 3203a88:	10800324 	muli	r2,r2,12
 3203a8c:	10c5883a 	add	r2,r2,r3
 3203a90:	10800104 	addi	r2,r2,4
 3203a94:	10c00017 	ldw	r3,0(r2)
 3203a98:	e0bffd17 	ldw	r2,-12(fp)
 3203a9c:	18800f1e 	bne	r3,r2,3203adc <activate_tracker+0x80>
			trackers[i].active = 1;
 3203aa0:	e0bffc17 	ldw	r2,-16(fp)
 3203aa4:	00c0c9b4 	movhi	r3,806
 3203aa8:	18e4ba04 	addi	r3,r3,-27928
 3203aac:	10800324 	muli	r2,r2,12
 3203ab0:	10c5883a 	add	r2,r2,r3
 3203ab4:	10c00204 	addi	r3,r2,8
 3203ab8:	00800044 	movi	r2,1
 3203abc:	18800015 	stw	r2,0(r3)
			return sprintf(char_buffer, "Id %i activated.", id);
 3203ac0:	e13ffe17 	ldw	r4,-8(fp)
 3203ac4:	0140c974 	movhi	r5,805
 3203ac8:	29750004 	addi	r5,r5,-11264
 3203acc:	e1bffd17 	ldw	r6,-12(fp)
 3203ad0:	32076bc0 	call	32076bc <sprintf>
 3203ad4:	e0bfff15 	stw	r2,-4(fp)
 3203ad8:	00003406 	br	3203bac <activate_tracker+0x150>

/* Activates a tracker device. */
int activate_tracker(int id, char *char_buffer)
{
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203adc:	e0bffc17 	ldw	r2,-16(fp)
 3203ae0:	10800044 	addi	r2,r2,1
 3203ae4:	e0bffc15 	stw	r2,-16(fp)
 3203ae8:	e0bffc17 	ldw	r2,-16(fp)
 3203aec:	10800190 	cmplti	r2,r2,6
 3203af0:	103fe21e 	bne	r2,zero,3203a7c <activate_tracker+0x20>
		if (trackers[i].id == id) {
			trackers[i].active = 1;
			return sprintf(char_buffer, "Id %i activated.", id);
		}
	}
	for (i = 0; i < TRACKERS; i++) {
 3203af4:	e03ffc15 	stw	zero,-16(fp)
 3203af8:	00002306 	br	3203b88 <activate_tracker+0x12c>
		if (trackers[i].id == 0) {
 3203afc:	e0bffc17 	ldw	r2,-16(fp)
 3203b00:	00c0c9b4 	movhi	r3,806
 3203b04:	18e4ba04 	addi	r3,r3,-27928
 3203b08:	10800324 	muli	r2,r2,12
 3203b0c:	10c5883a 	add	r2,r2,r3
 3203b10:	10800104 	addi	r2,r2,4
 3203b14:	10800017 	ldw	r2,0(r2)
 3203b18:	1004c03a 	cmpne	r2,r2,zero
 3203b1c:	1000171e 	bne	r2,zero,3203b7c <activate_tracker+0x120>
			trackers[i].id = id;
 3203b20:	e0bffc17 	ldw	r2,-16(fp)
 3203b24:	00c0c9b4 	movhi	r3,806
 3203b28:	18e4ba04 	addi	r3,r3,-27928
 3203b2c:	10800324 	muli	r2,r2,12
 3203b30:	10c5883a 	add	r2,r2,r3
 3203b34:	10c00104 	addi	r3,r2,4
 3203b38:	e0bffd17 	ldw	r2,-12(fp)
 3203b3c:	18800015 	stw	r2,0(r3)
			trackers[i].active = 1;
 3203b40:	e0bffc17 	ldw	r2,-16(fp)
 3203b44:	00c0c9b4 	movhi	r3,806
 3203b48:	18e4ba04 	addi	r3,r3,-27928
 3203b4c:	10800324 	muli	r2,r2,12
 3203b50:	10c5883a 	add	r2,r2,r3
 3203b54:	10c00204 	addi	r3,r2,8
 3203b58:	00800044 	movi	r2,1
 3203b5c:	18800015 	stw	r2,0(r3)
			return sprintf(char_buffer, "Id %i activated.", id);
 3203b60:	e13ffe17 	ldw	r4,-8(fp)
 3203b64:	0140c974 	movhi	r5,805
 3203b68:	29750004 	addi	r5,r5,-11264
 3203b6c:	e1bffd17 	ldw	r6,-12(fp)
 3203b70:	32076bc0 	call	32076bc <sprintf>
 3203b74:	e0bfff15 	stw	r2,-4(fp)
 3203b78:	00000c06 	br	3203bac <activate_tracker+0x150>
		if (trackers[i].id == id) {
			trackers[i].active = 1;
			return sprintf(char_buffer, "Id %i activated.", id);
		}
	}
	for (i = 0; i < TRACKERS; i++) {
 3203b7c:	e0bffc17 	ldw	r2,-16(fp)
 3203b80:	10800044 	addi	r2,r2,1
 3203b84:	e0bffc15 	stw	r2,-16(fp)
 3203b88:	e0bffc17 	ldw	r2,-16(fp)
 3203b8c:	10800190 	cmplti	r2,r2,6
 3203b90:	103fda1e 	bne	r2,zero,3203afc <activate_tracker+0xa0>
			trackers[i].id = id;
			trackers[i].active = 1;
			return sprintf(char_buffer, "Id %i activated.", id);
		}
	}
	return sprintf(char_buffer, "Id %i not assigned", id);
 3203b94:	e13ffe17 	ldw	r4,-8(fp)
 3203b98:	0140c974 	movhi	r5,805
 3203b9c:	29750504 	addi	r5,r5,-11244
 3203ba0:	e1bffd17 	ldw	r6,-12(fp)
 3203ba4:	32076bc0 	call	32076bc <sprintf>
 3203ba8:	e0bfff15 	stw	r2,-4(fp)
 3203bac:	e0bfff17 	ldw	r2,-4(fp)
}
 3203bb0:	e037883a 	mov	sp,fp
 3203bb4:	dfc00117 	ldw	ra,4(sp)
 3203bb8:	df000017 	ldw	fp,0(sp)
 3203bbc:	dec00204 	addi	sp,sp,8
 3203bc0:	f800283a 	ret

03203bc4 <disable_tracker>:

/* Disables a tracker device. */
int disable_tracker(int id, char *char_buffer)
{
 3203bc4:	defffa04 	addi	sp,sp,-24
 3203bc8:	dfc00515 	stw	ra,20(sp)
 3203bcc:	df000415 	stw	fp,16(sp)
 3203bd0:	df000404 	addi	fp,sp,16
 3203bd4:	e13ffd15 	stw	r4,-12(fp)
 3203bd8:	e17ffe15 	stw	r5,-8(fp)
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203bdc:	e03ffc15 	stw	zero,-16(fp)
 3203be0:	00001a06 	br	3203c4c <disable_tracker+0x88>
		if (trackers[i].id == id) {
 3203be4:	e0bffc17 	ldw	r2,-16(fp)
 3203be8:	00c0c9b4 	movhi	r3,806
 3203bec:	18e4ba04 	addi	r3,r3,-27928
 3203bf0:	10800324 	muli	r2,r2,12
 3203bf4:	10c5883a 	add	r2,r2,r3
 3203bf8:	10800104 	addi	r2,r2,4
 3203bfc:	10c00017 	ldw	r3,0(r2)
 3203c00:	e0bffd17 	ldw	r2,-12(fp)
 3203c04:	18800e1e 	bne	r3,r2,3203c40 <disable_tracker+0x7c>
			trackers[i].active = 0;
 3203c08:	e0bffc17 	ldw	r2,-16(fp)
 3203c0c:	00c0c9b4 	movhi	r3,806
 3203c10:	18e4ba04 	addi	r3,r3,-27928
 3203c14:	10800324 	muli	r2,r2,12
 3203c18:	10c5883a 	add	r2,r2,r3
 3203c1c:	10800204 	addi	r2,r2,8
 3203c20:	10000015 	stw	zero,0(r2)
			return sprintf(char_buffer, "Id %i disabled.", id);
 3203c24:	e13ffe17 	ldw	r4,-8(fp)
 3203c28:	0140c974 	movhi	r5,805
 3203c2c:	29750a04 	addi	r5,r5,-11224
 3203c30:	e1bffd17 	ldw	r6,-12(fp)
 3203c34:	32076bc0 	call	32076bc <sprintf>
 3203c38:	e0bfff15 	stw	r2,-4(fp)
 3203c3c:	00000c06 	br	3203c70 <disable_tracker+0xac>

/* Disables a tracker device. */
int disable_tracker(int id, char *char_buffer)
{
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203c40:	e0bffc17 	ldw	r2,-16(fp)
 3203c44:	10800044 	addi	r2,r2,1
 3203c48:	e0bffc15 	stw	r2,-16(fp)
 3203c4c:	e0bffc17 	ldw	r2,-16(fp)
 3203c50:	10800190 	cmplti	r2,r2,6
 3203c54:	103fe31e 	bne	r2,zero,3203be4 <disable_tracker+0x20>
		if (trackers[i].id == id) {
			trackers[i].active = 0;
			return sprintf(char_buffer, "Id %i disabled.", id);
		}
	}
	return sprintf(char_buffer, "Id %i not found.", id);
 3203c58:	e13ffe17 	ldw	r4,-8(fp)
 3203c5c:	0140c974 	movhi	r5,805
 3203c60:	29750e04 	addi	r5,r5,-11208
 3203c64:	e1bffd17 	ldw	r6,-12(fp)
 3203c68:	32076bc0 	call	32076bc <sprintf>
 3203c6c:	e0bfff15 	stw	r2,-4(fp)
 3203c70:	e0bfff17 	ldw	r2,-4(fp)
}
 3203c74:	e037883a 	mov	sp,fp
 3203c78:	dfc00117 	ldw	ra,4(sp)
 3203c7c:	df000017 	ldw	fp,0(sp)
 3203c80:	dec00204 	addi	sp,sp,8
 3203c84:	f800283a 	ret

03203c88 <free_tracker>:

/* Frees a tracker device. */
int free_tracker(int id, char *char_buffer)
{
 3203c88:	defffa04 	addi	sp,sp,-24
 3203c8c:	dfc00515 	stw	ra,20(sp)
 3203c90:	df000415 	stw	fp,16(sp)
 3203c94:	df000404 	addi	fp,sp,16
 3203c98:	e13ffd15 	stw	r4,-12(fp)
 3203c9c:	e17ffe15 	stw	r5,-8(fp)
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203ca0:	e03ffc15 	stw	zero,-16(fp)
 3203ca4:	00002106 	br	3203d2c <free_tracker+0xa4>
		if (trackers[i].id == id) {
 3203ca8:	e0bffc17 	ldw	r2,-16(fp)
 3203cac:	00c0c9b4 	movhi	r3,806
 3203cb0:	18e4ba04 	addi	r3,r3,-27928
 3203cb4:	10800324 	muli	r2,r2,12
 3203cb8:	10c5883a 	add	r2,r2,r3
 3203cbc:	10800104 	addi	r2,r2,4
 3203cc0:	10c00017 	ldw	r3,0(r2)
 3203cc4:	e0bffd17 	ldw	r2,-12(fp)
 3203cc8:	1880151e 	bne	r3,r2,3203d20 <free_tracker+0x98>
			trackers[i].active = 0;
 3203ccc:	e0bffc17 	ldw	r2,-16(fp)
 3203cd0:	00c0c9b4 	movhi	r3,806
 3203cd4:	18e4ba04 	addi	r3,r3,-27928
 3203cd8:	10800324 	muli	r2,r2,12
 3203cdc:	10c5883a 	add	r2,r2,r3
 3203ce0:	10800204 	addi	r2,r2,8
 3203ce4:	10000015 	stw	zero,0(r2)
			trackers[i].id = 0;
 3203ce8:	e0bffc17 	ldw	r2,-16(fp)
 3203cec:	00c0c9b4 	movhi	r3,806
 3203cf0:	18e4ba04 	addi	r3,r3,-27928
 3203cf4:	10800324 	muli	r2,r2,12
 3203cf8:	10c5883a 	add	r2,r2,r3
 3203cfc:	10800104 	addi	r2,r2,4
 3203d00:	10000015 	stw	zero,0(r2)
			return sprintf(char_buffer, "Id %i free.", id);
 3203d04:	e13ffe17 	ldw	r4,-8(fp)
 3203d08:	0140c974 	movhi	r5,805
 3203d0c:	29751304 	addi	r5,r5,-11188
 3203d10:	e1bffd17 	ldw	r6,-12(fp)
 3203d14:	32076bc0 	call	32076bc <sprintf>
 3203d18:	e0bfff15 	stw	r2,-4(fp)
 3203d1c:	00000c06 	br	3203d50 <free_tracker+0xc8>

/* Frees a tracker device. */
int free_tracker(int id, char *char_buffer)
{
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203d20:	e0bffc17 	ldw	r2,-16(fp)
 3203d24:	10800044 	addi	r2,r2,1
 3203d28:	e0bffc15 	stw	r2,-16(fp)
 3203d2c:	e0bffc17 	ldw	r2,-16(fp)
 3203d30:	10800190 	cmplti	r2,r2,6
 3203d34:	103fdc1e 	bne	r2,zero,3203ca8 <free_tracker+0x20>
			trackers[i].active = 0;
			trackers[i].id = 0;
			return sprintf(char_buffer, "Id %i free.", id);
		}
	}
	return sprintf(char_buffer, "Id %i not found.", id);
 3203d38:	e13ffe17 	ldw	r4,-8(fp)
 3203d3c:	0140c974 	movhi	r5,805
 3203d40:	29750e04 	addi	r5,r5,-11208
 3203d44:	e1bffd17 	ldw	r6,-12(fp)
 3203d48:	32076bc0 	call	32076bc <sprintf>
 3203d4c:	e0bfff15 	stw	r2,-4(fp)
 3203d50:	e0bfff17 	ldw	r2,-4(fp)
}
 3203d54:	e037883a 	mov	sp,fp
 3203d58:	dfc00117 	ldw	ra,4(sp)
 3203d5c:	df000017 	ldw	fp,0(sp)
 3203d60:	dec00204 	addi	sp,sp,8
 3203d64:	f800283a 	ret

03203d68 <set_search_window_of_tracker>:

/* Sets the search window of the assigned tracker device. */
int set_search_window_of_tracker(int id, char *char_buffer, int x, int y, int width, int height)
{
 3203d68:	defff604 	addi	sp,sp,-40
 3203d6c:	dfc00915 	stw	ra,36(sp)
 3203d70:	df000815 	stw	fp,32(sp)
 3203d74:	df000804 	addi	fp,sp,32
 3203d78:	e13ffb15 	stw	r4,-20(fp)
 3203d7c:	e17ffc15 	stw	r5,-16(fp)
 3203d80:	e1bffd15 	stw	r6,-12(fp)
 3203d84:	e1fffe15 	stw	r7,-8(fp)
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203d88:	e03ffa15 	stw	zero,-24(fp)
 3203d8c:	00002406 	br	3203e20 <set_search_window_of_tracker+0xb8>
		if (trackers[i].id == id) {
 3203d90:	e0bffa17 	ldw	r2,-24(fp)
 3203d94:	00c0c9b4 	movhi	r3,806
 3203d98:	18e4ba04 	addi	r3,r3,-27928
 3203d9c:	10800324 	muli	r2,r2,12
 3203da0:	10c5883a 	add	r2,r2,r3
 3203da4:	10800104 	addi	r2,r2,4
 3203da8:	10c00017 	ldw	r3,0(r2)
 3203dac:	e0bffb17 	ldw	r2,-20(fp)
 3203db0:	1880181e 	bne	r3,r2,3203e14 <set_search_window_of_tracker+0xac>
			trackers[i].active = 1;
 3203db4:	e0bffa17 	ldw	r2,-24(fp)
 3203db8:	00c0c9b4 	movhi	r3,806
 3203dbc:	18e4ba04 	addi	r3,r3,-27928
 3203dc0:	10800324 	muli	r2,r2,12
 3203dc4:	10c5883a 	add	r2,r2,r3
 3203dc8:	10c00204 	addi	r3,r2,8
 3203dcc:	00800044 	movi	r2,1
 3203dd0:	18800015 	stw	r2,0(r3)
			return set_search_window(&trackers[i], char_buffer, x, y, width, height);
 3203dd4:	e0bffa17 	ldw	r2,-24(fp)
 3203dd8:	10800324 	muli	r2,r2,12
 3203ddc:	1007883a 	mov	r3,r2
 3203de0:	0080c9b4 	movhi	r2,806
 3203de4:	10a4ba04 	addi	r2,r2,-27928
 3203de8:	1889883a 	add	r4,r3,r2
 3203dec:	e0800217 	ldw	r2,8(fp)
 3203df0:	d8800015 	stw	r2,0(sp)
 3203df4:	e0800317 	ldw	r2,12(fp)
 3203df8:	d8800115 	stw	r2,4(sp)
 3203dfc:	e17ffc17 	ldw	r5,-16(fp)
 3203e00:	e1bffd17 	ldw	r6,-12(fp)
 3203e04:	e1fffe17 	ldw	r7,-8(fp)
 3203e08:	32213480 	call	3221348 <set_search_window>
 3203e0c:	e0bfff15 	stw	r2,-4(fp)
 3203e10:	00003d06 	br	3203f08 <set_search_window_of_tracker+0x1a0>

/* Sets the search window of the assigned tracker device. */
int set_search_window_of_tracker(int id, char *char_buffer, int x, int y, int width, int height)
{
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203e14:	e0bffa17 	ldw	r2,-24(fp)
 3203e18:	10800044 	addi	r2,r2,1
 3203e1c:	e0bffa15 	stw	r2,-24(fp)
 3203e20:	e0bffa17 	ldw	r2,-24(fp)
 3203e24:	10800190 	cmplti	r2,r2,6
 3203e28:	103fd91e 	bne	r2,zero,3203d90 <set_search_window_of_tracker+0x28>
		if (trackers[i].id == id) {
			trackers[i].active = 1;
			return set_search_window(&trackers[i], char_buffer, x, y, width, height);
		}
	}
	for (i = 0; i < TRACKERS; i++) {
 3203e2c:	e03ffa15 	stw	zero,-24(fp)
 3203e30:	00002c06 	br	3203ee4 <set_search_window_of_tracker+0x17c>
		if (trackers[i].id == 0) {
 3203e34:	e0bffa17 	ldw	r2,-24(fp)
 3203e38:	00c0c9b4 	movhi	r3,806
 3203e3c:	18e4ba04 	addi	r3,r3,-27928
 3203e40:	10800324 	muli	r2,r2,12
 3203e44:	10c5883a 	add	r2,r2,r3
 3203e48:	10800104 	addi	r2,r2,4
 3203e4c:	10800017 	ldw	r2,0(r2)
 3203e50:	1004c03a 	cmpne	r2,r2,zero
 3203e54:	1000201e 	bne	r2,zero,3203ed8 <set_search_window_of_tracker+0x170>
			trackers[i].id = id;
 3203e58:	e0bffa17 	ldw	r2,-24(fp)
 3203e5c:	00c0c9b4 	movhi	r3,806
 3203e60:	18e4ba04 	addi	r3,r3,-27928
 3203e64:	10800324 	muli	r2,r2,12
 3203e68:	10c5883a 	add	r2,r2,r3
 3203e6c:	10c00104 	addi	r3,r2,4
 3203e70:	e0bffb17 	ldw	r2,-20(fp)
 3203e74:	18800015 	stw	r2,0(r3)
			trackers[i].active = 1;
 3203e78:	e0bffa17 	ldw	r2,-24(fp)
 3203e7c:	00c0c9b4 	movhi	r3,806
 3203e80:	18e4ba04 	addi	r3,r3,-27928
 3203e84:	10800324 	muli	r2,r2,12
 3203e88:	10c5883a 	add	r2,r2,r3
 3203e8c:	10c00204 	addi	r3,r2,8
 3203e90:	00800044 	movi	r2,1
 3203e94:	18800015 	stw	r2,0(r3)
			return set_search_window(&trackers[i], char_buffer, x, y, width, height);
 3203e98:	e0bffa17 	ldw	r2,-24(fp)
 3203e9c:	10800324 	muli	r2,r2,12
 3203ea0:	1007883a 	mov	r3,r2
 3203ea4:	0080c9b4 	movhi	r2,806
 3203ea8:	10a4ba04 	addi	r2,r2,-27928
 3203eac:	1889883a 	add	r4,r3,r2
 3203eb0:	e0800217 	ldw	r2,8(fp)
 3203eb4:	d8800015 	stw	r2,0(sp)
 3203eb8:	e0800317 	ldw	r2,12(fp)
 3203ebc:	d8800115 	stw	r2,4(sp)
 3203ec0:	e17ffc17 	ldw	r5,-16(fp)
 3203ec4:	e1bffd17 	ldw	r6,-12(fp)
 3203ec8:	e1fffe17 	ldw	r7,-8(fp)
 3203ecc:	32213480 	call	3221348 <set_search_window>
 3203ed0:	e0bfff15 	stw	r2,-4(fp)
 3203ed4:	00000c06 	br	3203f08 <set_search_window_of_tracker+0x1a0>
		if (trackers[i].id == id) {
			trackers[i].active = 1;
			return set_search_window(&trackers[i], char_buffer, x, y, width, height);
		}
	}
	for (i = 0; i < TRACKERS; i++) {
 3203ed8:	e0bffa17 	ldw	r2,-24(fp)
 3203edc:	10800044 	addi	r2,r2,1
 3203ee0:	e0bffa15 	stw	r2,-24(fp)
 3203ee4:	e0bffa17 	ldw	r2,-24(fp)
 3203ee8:	10800190 	cmplti	r2,r2,6
 3203eec:	103fd11e 	bne	r2,zero,3203e34 <set_search_window_of_tracker+0xcc>
			trackers[i].id = id;
			trackers[i].active = 1;
			return set_search_window(&trackers[i], char_buffer, x, y, width, height);
		}
	}
	return sprintf(char_buffer, "Id %i not assigned.", id);
 3203ef0:	e13ffc17 	ldw	r4,-16(fp)
 3203ef4:	0140c974 	movhi	r5,805
 3203ef8:	29751604 	addi	r5,r5,-11176
 3203efc:	e1bffb17 	ldw	r6,-20(fp)
 3203f00:	32076bc0 	call	32076bc <sprintf>
 3203f04:	e0bfff15 	stw	r2,-4(fp)
 3203f08:	e0bfff17 	ldw	r2,-4(fp)
}
 3203f0c:	e037883a 	mov	sp,fp
 3203f10:	dfc00117 	ldw	ra,4(sp)
 3203f14:	df000017 	ldw	fp,0(sp)
 3203f18:	dec00204 	addi	sp,sp,8
 3203f1c:	f800283a 	ret

03203f20 <get_search_window_of_tracker>:

/* Gets the search window of the assigned tracker device. */
int get_search_window_of_tracker(int id, char *char_buffer)
{
 3203f20:	defffa04 	addi	sp,sp,-24
 3203f24:	dfc00515 	stw	ra,20(sp)
 3203f28:	df000415 	stw	fp,16(sp)
 3203f2c:	df000404 	addi	fp,sp,16
 3203f30:	e13ffd15 	stw	r4,-12(fp)
 3203f34:	e17ffe15 	stw	r5,-8(fp)
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203f38:	e03ffc15 	stw	zero,-16(fp)
 3203f3c:	00001606 	br	3203f98 <get_search_window_of_tracker+0x78>
		if (trackers[i].id == id) {
 3203f40:	e0bffc17 	ldw	r2,-16(fp)
 3203f44:	00c0c9b4 	movhi	r3,806
 3203f48:	18e4ba04 	addi	r3,r3,-27928
 3203f4c:	10800324 	muli	r2,r2,12
 3203f50:	10c5883a 	add	r2,r2,r3
 3203f54:	10800104 	addi	r2,r2,4
 3203f58:	10c00017 	ldw	r3,0(r2)
 3203f5c:	e0bffd17 	ldw	r2,-12(fp)
 3203f60:	18800a1e 	bne	r3,r2,3203f8c <get_search_window_of_tracker+0x6c>
			return get_search_window(&trackers[i], char_buffer);
 3203f64:	e0bffc17 	ldw	r2,-16(fp)
 3203f68:	10800324 	muli	r2,r2,12
 3203f6c:	1007883a 	mov	r3,r2
 3203f70:	0080c9b4 	movhi	r2,806
 3203f74:	10a4ba04 	addi	r2,r2,-27928
 3203f78:	1889883a 	add	r4,r3,r2
 3203f7c:	e17ffe17 	ldw	r5,-8(fp)
 3203f80:	322144c0 	call	322144c <get_search_window>
 3203f84:	e0bfff15 	stw	r2,-4(fp)
 3203f88:	00000c06 	br	3203fbc <get_search_window_of_tracker+0x9c>

/* Gets the search window of the assigned tracker device. */
int get_search_window_of_tracker(int id, char *char_buffer)
{
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203f8c:	e0bffc17 	ldw	r2,-16(fp)
 3203f90:	10800044 	addi	r2,r2,1
 3203f94:	e0bffc15 	stw	r2,-16(fp)
 3203f98:	e0bffc17 	ldw	r2,-16(fp)
 3203f9c:	10800190 	cmplti	r2,r2,6
 3203fa0:	103fe71e 	bne	r2,zero,3203f40 <get_search_window_of_tracker+0x20>
		if (trackers[i].id == id) {
			return get_search_window(&trackers[i], char_buffer);
		}
	}
	return sprintf(char_buffer, "Id %i not found.", id);
 3203fa4:	e13ffe17 	ldw	r4,-8(fp)
 3203fa8:	0140c974 	movhi	r5,805
 3203fac:	29750e04 	addi	r5,r5,-11208
 3203fb0:	e1bffd17 	ldw	r6,-12(fp)
 3203fb4:	32076bc0 	call	32076bc <sprintf>
 3203fb8:	e0bfff15 	stw	r2,-4(fp)
 3203fbc:	e0bfff17 	ldw	r2,-4(fp)
}
 3203fc0:	e037883a 	mov	sp,fp
 3203fc4:	dfc00117 	ldw	ra,4(sp)
 3203fc8:	df000017 	ldw	fp,0(sp)
 3203fcc:	dec00204 	addi	sp,sp,8
 3203fd0:	f800283a 	ret

03203fd4 <get_current_corners_of_tracker>:

/* Gets the corners locations of the assigned tracker device. */
int get_current_corners_of_tracker(int id, char *char_buffer)
{
 3203fd4:	defffa04 	addi	sp,sp,-24
 3203fd8:	dfc00515 	stw	ra,20(sp)
 3203fdc:	df000415 	stw	fp,16(sp)
 3203fe0:	df000404 	addi	fp,sp,16
 3203fe4:	e13ffd15 	stw	r4,-12(fp)
 3203fe8:	e17ffe15 	stw	r5,-8(fp)
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203fec:	e03ffc15 	stw	zero,-16(fp)
 3203ff0:	00001606 	br	320404c <get_current_corners_of_tracker+0x78>
		if (trackers[i].id == id) {
 3203ff4:	e0bffc17 	ldw	r2,-16(fp)
 3203ff8:	00c0c9b4 	movhi	r3,806
 3203ffc:	18e4ba04 	addi	r3,r3,-27928
 3204000:	10800324 	muli	r2,r2,12
 3204004:	10c5883a 	add	r2,r2,r3
 3204008:	10800104 	addi	r2,r2,4
 320400c:	10c00017 	ldw	r3,0(r2)
 3204010:	e0bffd17 	ldw	r2,-12(fp)
 3204014:	18800a1e 	bne	r3,r2,3204040 <get_current_corners_of_tracker+0x6c>
			return get_current_corners(&trackers[i], char_buffer);
 3204018:	e0bffc17 	ldw	r2,-16(fp)
 320401c:	10800324 	muli	r2,r2,12
 3204020:	1007883a 	mov	r3,r2
 3204024:	0080c9b4 	movhi	r2,806
 3204028:	10a4ba04 	addi	r2,r2,-27928
 320402c:	1889883a 	add	r4,r3,r2
 3204030:	e17ffe17 	ldw	r5,-8(fp)
 3204034:	32211840 	call	3221184 <get_current_corners>
 3204038:	e0bfff15 	stw	r2,-4(fp)
 320403c:	00000c06 	br	3204070 <get_current_corners_of_tracker+0x9c>

/* Gets the corners locations of the assigned tracker device. */
int get_current_corners_of_tracker(int id, char *char_buffer)
{
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3204040:	e0bffc17 	ldw	r2,-16(fp)
 3204044:	10800044 	addi	r2,r2,1
 3204048:	e0bffc15 	stw	r2,-16(fp)
 320404c:	e0bffc17 	ldw	r2,-16(fp)
 3204050:	10800190 	cmplti	r2,r2,6
 3204054:	103fe71e 	bne	r2,zero,3203ff4 <get_current_corners_of_tracker+0x20>
		if (trackers[i].id == id) {
			return get_current_corners(&trackers[i], char_buffer);
		}
	}
	return sprintf(char_buffer, "Id %i not found.", id);
 3204058:	e13ffe17 	ldw	r4,-8(fp)
 320405c:	0140c974 	movhi	r5,805
 3204060:	29750e04 	addi	r5,r5,-11208
 3204064:	e1bffd17 	ldw	r6,-12(fp)
 3204068:	32076bc0 	call	32076bc <sprintf>
 320406c:	e0bfff15 	stw	r2,-4(fp)
 3204070:	e0bfff17 	ldw	r2,-4(fp)
}
 3204074:	e037883a 	mov	sp,fp
 3204078:	dfc00117 	ldw	ra,4(sp)
 320407c:	df000017 	ldw	fp,0(sp)
 3204080:	dec00204 	addi	sp,sp,8
 3204084:	f800283a 	ret

03204088 <get_current_windows_of_activated_trackers>:

/* Gets the search windows of all activated tracker devices. */
int get_current_windows_of_activated_trackers(char *char_buffer)
{
 3204088:	defffb04 	addi	sp,sp,-20
 320408c:	dfc00415 	stw	ra,16(sp)
 3204090:	df000315 	stw	fp,12(sp)
 3204094:	df000304 	addi	fp,sp,12
 3204098:	e13fff15 	stw	r4,-4(fp)
	int i;
	int nchars = 0;
 320409c:	e03ffd15 	stw	zero,-12(fp)

	nchars += sprintf(char_buffer, "{");
 32040a0:	e0ffff17 	ldw	r3,-4(fp)
 32040a4:	00801ec4 	movi	r2,123
 32040a8:	18800005 	stb	r2,0(r3)
 32040ac:	18000045 	stb	zero,1(r3)
 32040b0:	e0bffd17 	ldw	r2,-12(fp)
 32040b4:	10800044 	addi	r2,r2,1
 32040b8:	e0bffd15 	stw	r2,-12(fp)
	for (i = 0; i < TRACKERS; i++) {
 32040bc:	e03ffe15 	stw	zero,-8(fp)
 32040c0:	00003706 	br	32041a0 <get_current_windows_of_activated_trackers+0x118>
		if (trackers[i].active == 1) {
 32040c4:	e0bffe17 	ldw	r2,-8(fp)
 32040c8:	00c0c9b4 	movhi	r3,806
 32040cc:	18e4ba04 	addi	r3,r3,-27928
 32040d0:	10800324 	muli	r2,r2,12
 32040d4:	10c5883a 	add	r2,r2,r3
 32040d8:	10800204 	addi	r2,r2,8
 32040dc:	10800017 	ldw	r2,0(r2)
 32040e0:	10800058 	cmpnei	r2,r2,1
 32040e4:	10002b1e 	bne	r2,zero,3204194 <get_current_windows_of_activated_trackers+0x10c>
			nchars += sprintf(char_buffer + nchars, "'%i':", trackers[i].id);
 32040e8:	e0bffd17 	ldw	r2,-12(fp)
 32040ec:	1007883a 	mov	r3,r2
 32040f0:	e0bfff17 	ldw	r2,-4(fp)
 32040f4:	1889883a 	add	r4,r3,r2
 32040f8:	e0bffe17 	ldw	r2,-8(fp)
 32040fc:	00c0c9b4 	movhi	r3,806
 3204100:	18e4ba04 	addi	r3,r3,-27928
 3204104:	10800324 	muli	r2,r2,12
 3204108:	10c5883a 	add	r2,r2,r3
 320410c:	10800104 	addi	r2,r2,4
 3204110:	11800017 	ldw	r6,0(r2)
 3204114:	0140c974 	movhi	r5,805
 3204118:	29751b04 	addi	r5,r5,-11156
 320411c:	32076bc0 	call	32076bc <sprintf>
 3204120:	1007883a 	mov	r3,r2
 3204124:	e0bffd17 	ldw	r2,-12(fp)
 3204128:	10c5883a 	add	r2,r2,r3
 320412c:	e0bffd15 	stw	r2,-12(fp)
			nchars += get_search_window(&trackers[i], char_buffer + nchars);
 3204130:	e0bffe17 	ldw	r2,-8(fp)
 3204134:	10800324 	muli	r2,r2,12
 3204138:	1007883a 	mov	r3,r2
 320413c:	0080c9b4 	movhi	r2,806
 3204140:	10a4ba04 	addi	r2,r2,-27928
 3204144:	1889883a 	add	r4,r3,r2
 3204148:	e0bffd17 	ldw	r2,-12(fp)
 320414c:	1007883a 	mov	r3,r2
 3204150:	e0bfff17 	ldw	r2,-4(fp)
 3204154:	188b883a 	add	r5,r3,r2
 3204158:	322144c0 	call	322144c <get_search_window>
 320415c:	1007883a 	mov	r3,r2
 3204160:	e0bffd17 	ldw	r2,-12(fp)
 3204164:	10c5883a 	add	r2,r2,r3
 3204168:	e0bffd15 	stw	r2,-12(fp)
			nchars += sprintf(char_buffer + nchars, ",");
 320416c:	e0bffd17 	ldw	r2,-12(fp)
 3204170:	1007883a 	mov	r3,r2
 3204174:	e0bfff17 	ldw	r2,-4(fp)
 3204178:	1887883a 	add	r3,r3,r2
 320417c:	00800b04 	movi	r2,44
 3204180:	18800005 	stb	r2,0(r3)
 3204184:	18000045 	stb	zero,1(r3)
 3204188:	e0bffd17 	ldw	r2,-12(fp)
 320418c:	10800044 	addi	r2,r2,1
 3204190:	e0bffd15 	stw	r2,-12(fp)
{
	int i;
	int nchars = 0;

	nchars += sprintf(char_buffer, "{");
	for (i = 0; i < TRACKERS; i++) {
 3204194:	e0bffe17 	ldw	r2,-8(fp)
 3204198:	10800044 	addi	r2,r2,1
 320419c:	e0bffe15 	stw	r2,-8(fp)
 32041a0:	e0bffe17 	ldw	r2,-8(fp)
 32041a4:	10800190 	cmplti	r2,r2,6
 32041a8:	103fc61e 	bne	r2,zero,32040c4 <get_current_windows_of_activated_trackers+0x3c>
			nchars += sprintf(char_buffer + nchars, "'%i':", trackers[i].id);
			nchars += get_search_window(&trackers[i], char_buffer + nchars);
			nchars += sprintf(char_buffer + nchars, ",");
		}
	}
	if (nchars > 1) nchars--;
 32041ac:	e0bffd17 	ldw	r2,-12(fp)
 32041b0:	10800090 	cmplti	r2,r2,2
 32041b4:	1000031e 	bne	r2,zero,32041c4 <get_current_windows_of_activated_trackers+0x13c>
 32041b8:	e0bffd17 	ldw	r2,-12(fp)
 32041bc:	10bfffc4 	addi	r2,r2,-1
 32041c0:	e0bffd15 	stw	r2,-12(fp)
	nchars += sprintf(char_buffer + nchars, "}");
 32041c4:	e0bffd17 	ldw	r2,-12(fp)
 32041c8:	1007883a 	mov	r3,r2
 32041cc:	e0bfff17 	ldw	r2,-4(fp)
 32041d0:	1887883a 	add	r3,r3,r2
 32041d4:	00801f44 	movi	r2,125
 32041d8:	18800005 	stb	r2,0(r3)
 32041dc:	18000045 	stb	zero,1(r3)
 32041e0:	e0bffd17 	ldw	r2,-12(fp)
 32041e4:	10800044 	addi	r2,r2,1
 32041e8:	e0bffd15 	stw	r2,-12(fp)

	return nchars;
 32041ec:	e0bffd17 	ldw	r2,-12(fp)
}
 32041f0:	e037883a 	mov	sp,fp
 32041f4:	dfc00117 	ldw	ra,4(sp)
 32041f8:	df000017 	ldw	fp,0(sp)
 32041fc:	dec00204 	addi	sp,sp,8
 3204200:	f800283a 	ret

03204204 <get_current_corners_of_activated_trackers>:

/* Gets the corners locations of all activated tracker devices. */
int get_current_corners_of_activated_trackers(char *char_buffer)
{
 3204204:	defffb04 	addi	sp,sp,-20
 3204208:	dfc00415 	stw	ra,16(sp)
 320420c:	df000315 	stw	fp,12(sp)
 3204210:	df000304 	addi	fp,sp,12
 3204214:	e13fff15 	stw	r4,-4(fp)
	int i;
	int nchars = 0;
 3204218:	e03ffd15 	stw	zero,-12(fp)

	nchars += sprintf(char_buffer, "{");
 320421c:	e0ffff17 	ldw	r3,-4(fp)
 3204220:	00801ec4 	movi	r2,123
 3204224:	18800005 	stb	r2,0(r3)
 3204228:	18000045 	stb	zero,1(r3)
 320422c:	e0bffd17 	ldw	r2,-12(fp)
 3204230:	10800044 	addi	r2,r2,1
 3204234:	e0bffd15 	stw	r2,-12(fp)
	for (i = 0; i < TRACKERS; i++) {
 3204238:	e03ffe15 	stw	zero,-8(fp)
 320423c:	00003706 	br	320431c <get_current_corners_of_activated_trackers+0x118>
		if (trackers[i].active == 1) {
 3204240:	e0bffe17 	ldw	r2,-8(fp)
 3204244:	00c0c9b4 	movhi	r3,806
 3204248:	18e4ba04 	addi	r3,r3,-27928
 320424c:	10800324 	muli	r2,r2,12
 3204250:	10c5883a 	add	r2,r2,r3
 3204254:	10800204 	addi	r2,r2,8
 3204258:	10800017 	ldw	r2,0(r2)
 320425c:	10800058 	cmpnei	r2,r2,1
 3204260:	10002b1e 	bne	r2,zero,3204310 <get_current_corners_of_activated_trackers+0x10c>
			nchars += sprintf(char_buffer + nchars, "'%i':", trackers[i].id);
 3204264:	e0bffd17 	ldw	r2,-12(fp)
 3204268:	1007883a 	mov	r3,r2
 320426c:	e0bfff17 	ldw	r2,-4(fp)
 3204270:	1889883a 	add	r4,r3,r2
 3204274:	e0bffe17 	ldw	r2,-8(fp)
 3204278:	00c0c9b4 	movhi	r3,806
 320427c:	18e4ba04 	addi	r3,r3,-27928
 3204280:	10800324 	muli	r2,r2,12
 3204284:	10c5883a 	add	r2,r2,r3
 3204288:	10800104 	addi	r2,r2,4
 320428c:	11800017 	ldw	r6,0(r2)
 3204290:	0140c974 	movhi	r5,805
 3204294:	29751b04 	addi	r5,r5,-11156
 3204298:	32076bc0 	call	32076bc <sprintf>
 320429c:	1007883a 	mov	r3,r2
 32042a0:	e0bffd17 	ldw	r2,-12(fp)
 32042a4:	10c5883a 	add	r2,r2,r3
 32042a8:	e0bffd15 	stw	r2,-12(fp)
			nchars += get_current_corners(&trackers[i], char_buffer + nchars);
 32042ac:	e0bffe17 	ldw	r2,-8(fp)
 32042b0:	10800324 	muli	r2,r2,12
 32042b4:	1007883a 	mov	r3,r2
 32042b8:	0080c9b4 	movhi	r2,806
 32042bc:	10a4ba04 	addi	r2,r2,-27928
 32042c0:	1889883a 	add	r4,r3,r2
 32042c4:	e0bffd17 	ldw	r2,-12(fp)
 32042c8:	1007883a 	mov	r3,r2
 32042cc:	e0bfff17 	ldw	r2,-4(fp)
 32042d0:	188b883a 	add	r5,r3,r2
 32042d4:	32211840 	call	3221184 <get_current_corners>
 32042d8:	1007883a 	mov	r3,r2
 32042dc:	e0bffd17 	ldw	r2,-12(fp)
 32042e0:	10c5883a 	add	r2,r2,r3
 32042e4:	e0bffd15 	stw	r2,-12(fp)
			nchars += sprintf(char_buffer + nchars, ",");
 32042e8:	e0bffd17 	ldw	r2,-12(fp)
 32042ec:	1007883a 	mov	r3,r2
 32042f0:	e0bfff17 	ldw	r2,-4(fp)
 32042f4:	1887883a 	add	r3,r3,r2
 32042f8:	00800b04 	movi	r2,44
 32042fc:	18800005 	stb	r2,0(r3)
 3204300:	18000045 	stb	zero,1(r3)
 3204304:	e0bffd17 	ldw	r2,-12(fp)
 3204308:	10800044 	addi	r2,r2,1
 320430c:	e0bffd15 	stw	r2,-12(fp)
{
	int i;
	int nchars = 0;

	nchars += sprintf(char_buffer, "{");
	for (i = 0; i < TRACKERS; i++) {
 3204310:	e0bffe17 	ldw	r2,-8(fp)
 3204314:	10800044 	addi	r2,r2,1
 3204318:	e0bffe15 	stw	r2,-8(fp)
 320431c:	e0bffe17 	ldw	r2,-8(fp)
 3204320:	10800190 	cmplti	r2,r2,6
 3204324:	103fc61e 	bne	r2,zero,3204240 <get_current_corners_of_activated_trackers+0x3c>
			nchars += sprintf(char_buffer + nchars, "'%i':", trackers[i].id);
			nchars += get_current_corners(&trackers[i], char_buffer + nchars);
			nchars += sprintf(char_buffer + nchars, ",");
		}
	}
	if (nchars > 1) nchars--;
 3204328:	e0bffd17 	ldw	r2,-12(fp)
 320432c:	10800090 	cmplti	r2,r2,2
 3204330:	1000031e 	bne	r2,zero,3204340 <get_current_corners_of_activated_trackers+0x13c>
 3204334:	e0bffd17 	ldw	r2,-12(fp)
 3204338:	10bfffc4 	addi	r2,r2,-1
 320433c:	e0bffd15 	stw	r2,-12(fp)
	nchars += sprintf(char_buffer + nchars, "}");
 3204340:	e0bffd17 	ldw	r2,-12(fp)
 3204344:	1007883a 	mov	r3,r2
 3204348:	e0bfff17 	ldw	r2,-4(fp)
 320434c:	1887883a 	add	r3,r3,r2
 3204350:	00801f44 	movi	r2,125
 3204354:	18800005 	stb	r2,0(r3)
 3204358:	18000045 	stb	zero,1(r3)
 320435c:	e0bffd17 	ldw	r2,-12(fp)
 3204360:	10800044 	addi	r2,r2,1
 3204364:	e0bffd15 	stw	r2,-12(fp)

	return nchars;
 3204368:	e0bffd17 	ldw	r2,-12(fp)
}
 320436c:	e037883a 	mov	sp,fp
 3204370:	dfc00117 	ldw	ra,4(sp)
 3204374:	df000017 	ldw	fp,0(sp)
 3204378:	dec00204 	addi	sp,sp,8
 320437c:	f800283a 	ret

03204380 <udivmodsi4>:
 3204380:	29001b2e 	bgeu	r5,r4,32043f0 <udivmodsi4+0x70>
 3204384:	28001a16 	blt	r5,zero,32043f0 <udivmodsi4+0x70>
 3204388:	00800044 	movi	r2,1
 320438c:	0007883a 	mov	r3,zero
 3204390:	01c007c4 	movi	r7,31
 3204394:	00000306 	br	32043a4 <udivmodsi4+0x24>
 3204398:	19c01326 	beq	r3,r7,32043e8 <udivmodsi4+0x68>
 320439c:	18c00044 	addi	r3,r3,1
 32043a0:	28000416 	blt	r5,zero,32043b4 <udivmodsi4+0x34>
 32043a4:	294b883a 	add	r5,r5,r5
 32043a8:	1085883a 	add	r2,r2,r2
 32043ac:	293ffa36 	bltu	r5,r4,3204398 <udivmodsi4+0x18>
 32043b0:	10000d26 	beq	r2,zero,32043e8 <udivmodsi4+0x68>
 32043b4:	0007883a 	mov	r3,zero
 32043b8:	21400236 	bltu	r4,r5,32043c4 <udivmodsi4+0x44>
 32043bc:	2149c83a 	sub	r4,r4,r5
 32043c0:	1886b03a 	or	r3,r3,r2
 32043c4:	1004d07a 	srli	r2,r2,1
 32043c8:	280ad07a 	srli	r5,r5,1
 32043cc:	103ffa1e 	bne	r2,zero,32043b8 <udivmodsi4+0x38>
 32043d0:	30000226 	beq	r6,zero,32043dc <udivmodsi4+0x5c>
 32043d4:	2005883a 	mov	r2,r4
 32043d8:	f800283a 	ret
 32043dc:	1809883a 	mov	r4,r3
 32043e0:	2005883a 	mov	r2,r4
 32043e4:	f800283a 	ret
 32043e8:	0007883a 	mov	r3,zero
 32043ec:	003ff806 	br	32043d0 <udivmodsi4+0x50>
 32043f0:	00800044 	movi	r2,1
 32043f4:	0007883a 	mov	r3,zero
 32043f8:	003fef06 	br	32043b8 <udivmodsi4+0x38>

032043fc <__divsi3>:
 32043fc:	defffe04 	addi	sp,sp,-8
 3204400:	dc000015 	stw	r16,0(sp)
 3204404:	dfc00115 	stw	ra,4(sp)
 3204408:	0021883a 	mov	r16,zero
 320440c:	20000c16 	blt	r4,zero,3204440 <__divsi3+0x44>
 3204410:	000d883a 	mov	r6,zero
 3204414:	28000e16 	blt	r5,zero,3204450 <__divsi3+0x54>
 3204418:	32043800 	call	3204380 <udivmodsi4>
 320441c:	1007883a 	mov	r3,r2
 3204420:	8005003a 	cmpeq	r2,r16,zero
 3204424:	1000011e 	bne	r2,zero,320442c <__divsi3+0x30>
 3204428:	00c7c83a 	sub	r3,zero,r3
 320442c:	1805883a 	mov	r2,r3
 3204430:	dfc00117 	ldw	ra,4(sp)
 3204434:	dc000017 	ldw	r16,0(sp)
 3204438:	dec00204 	addi	sp,sp,8
 320443c:	f800283a 	ret
 3204440:	0109c83a 	sub	r4,zero,r4
 3204444:	04000044 	movi	r16,1
 3204448:	000d883a 	mov	r6,zero
 320444c:	283ff20e 	bge	r5,zero,3204418 <__divsi3+0x1c>
 3204450:	014bc83a 	sub	r5,zero,r5
 3204454:	8021003a 	cmpeq	r16,r16,zero
 3204458:	003fef06 	br	3204418 <__divsi3+0x1c>

0320445c <__modsi3>:
 320445c:	deffff04 	addi	sp,sp,-4
 3204460:	dfc00015 	stw	ra,0(sp)
 3204464:	01800044 	movi	r6,1
 3204468:	2807883a 	mov	r3,r5
 320446c:	20000416 	blt	r4,zero,3204480 <__modsi3+0x24>
 3204470:	28000c16 	blt	r5,zero,32044a4 <__modsi3+0x48>
 3204474:	dfc00017 	ldw	ra,0(sp)
 3204478:	dec00104 	addi	sp,sp,4
 320447c:	32043801 	jmpi	3204380 <udivmodsi4>
 3204480:	0109c83a 	sub	r4,zero,r4
 3204484:	28000b16 	blt	r5,zero,32044b4 <__modsi3+0x58>
 3204488:	180b883a 	mov	r5,r3
 320448c:	01800044 	movi	r6,1
 3204490:	32043800 	call	3204380 <udivmodsi4>
 3204494:	0085c83a 	sub	r2,zero,r2
 3204498:	dfc00017 	ldw	ra,0(sp)
 320449c:	dec00104 	addi	sp,sp,4
 32044a0:	f800283a 	ret
 32044a4:	014bc83a 	sub	r5,zero,r5
 32044a8:	dfc00017 	ldw	ra,0(sp)
 32044ac:	dec00104 	addi	sp,sp,4
 32044b0:	32043801 	jmpi	3204380 <udivmodsi4>
 32044b4:	0147c83a 	sub	r3,zero,r5
 32044b8:	003ff306 	br	3204488 <__modsi3+0x2c>

032044bc <__udivsi3>:
 32044bc:	000d883a 	mov	r6,zero
 32044c0:	32043801 	jmpi	3204380 <udivmodsi4>

032044c4 <__umodsi3>:
 32044c4:	01800044 	movi	r6,1
 32044c8:	32043801 	jmpi	3204380 <udivmodsi4>

032044cc <_fclose_r>:
 32044cc:	defffc04 	addi	sp,sp,-16
 32044d0:	dc400115 	stw	r17,4(sp)
 32044d4:	dc000015 	stw	r16,0(sp)
 32044d8:	dfc00315 	stw	ra,12(sp)
 32044dc:	dc800215 	stw	r18,8(sp)
 32044e0:	2821883a 	mov	r16,r5
 32044e4:	2023883a 	mov	r17,r4
 32044e8:	28002926 	beq	r5,zero,3204590 <_fclose_r+0xc4>
 32044ec:	32048780 	call	3204878 <__sfp_lock_acquire>
 32044f0:	88000226 	beq	r17,zero,32044fc <_fclose_r+0x30>
 32044f4:	88800e17 	ldw	r2,56(r17)
 32044f8:	10002d26 	beq	r2,zero,32045b0 <_fclose_r+0xe4>
 32044fc:	8080030f 	ldh	r2,12(r16)
 3204500:	10002226 	beq	r2,zero,320458c <_fclose_r+0xc0>
 3204504:	8809883a 	mov	r4,r17
 3204508:	800b883a 	mov	r5,r16
 320450c:	32045f00 	call	32045f0 <_fflush_r>
 3204510:	1025883a 	mov	r18,r2
 3204514:	80800b17 	ldw	r2,44(r16)
 3204518:	10000426 	beq	r2,zero,320452c <_fclose_r+0x60>
 320451c:	81400717 	ldw	r5,28(r16)
 3204520:	8809883a 	mov	r4,r17
 3204524:	103ee83a 	callr	r2
 3204528:	10002a16 	blt	r2,zero,32045d4 <_fclose_r+0x108>
 320452c:	8080030b 	ldhu	r2,12(r16)
 3204530:	1080200c 	andi	r2,r2,128
 3204534:	1000231e 	bne	r2,zero,32045c4 <_fclose_r+0xf8>
 3204538:	81400c17 	ldw	r5,48(r16)
 320453c:	28000526 	beq	r5,zero,3204554 <_fclose_r+0x88>
 3204540:	80801004 	addi	r2,r16,64
 3204544:	28800226 	beq	r5,r2,3204550 <_fclose_r+0x84>
 3204548:	8809883a 	mov	r4,r17
 320454c:	3204e0c0 	call	3204e0c <_free_r>
 3204550:	80000c15 	stw	zero,48(r16)
 3204554:	81401117 	ldw	r5,68(r16)
 3204558:	28000326 	beq	r5,zero,3204568 <_fclose_r+0x9c>
 320455c:	8809883a 	mov	r4,r17
 3204560:	3204e0c0 	call	3204e0c <_free_r>
 3204564:	80001115 	stw	zero,68(r16)
 3204568:	8000030d 	sth	zero,12(r16)
 320456c:	320487c0 	call	320487c <__sfp_lock_release>
 3204570:	9005883a 	mov	r2,r18
 3204574:	dfc00317 	ldw	ra,12(sp)
 3204578:	dc800217 	ldw	r18,8(sp)
 320457c:	dc400117 	ldw	r17,4(sp)
 3204580:	dc000017 	ldw	r16,0(sp)
 3204584:	dec00404 	addi	sp,sp,16
 3204588:	f800283a 	ret
 320458c:	320487c0 	call	320487c <__sfp_lock_release>
 3204590:	0025883a 	mov	r18,zero
 3204594:	9005883a 	mov	r2,r18
 3204598:	dfc00317 	ldw	ra,12(sp)
 320459c:	dc800217 	ldw	r18,8(sp)
 32045a0:	dc400117 	ldw	r17,4(sp)
 32045a4:	dc000017 	ldw	r16,0(sp)
 32045a8:	dec00404 	addi	sp,sp,16
 32045ac:	f800283a 	ret
 32045b0:	8809883a 	mov	r4,r17
 32045b4:	32048880 	call	3204888 <__sinit>
 32045b8:	8080030f 	ldh	r2,12(r16)
 32045bc:	103fd11e 	bne	r2,zero,3204504 <_fclose_r+0x38>
 32045c0:	003ff206 	br	320458c <_fclose_r+0xc0>
 32045c4:	81400417 	ldw	r5,16(r16)
 32045c8:	8809883a 	mov	r4,r17
 32045cc:	3204e0c0 	call	3204e0c <_free_r>
 32045d0:	003fd906 	br	3204538 <_fclose_r+0x6c>
 32045d4:	04bfffc4 	movi	r18,-1
 32045d8:	003fd406 	br	320452c <_fclose_r+0x60>

032045dc <fclose>:
 32045dc:	0080c974 	movhi	r2,805
 32045e0:	10897804 	addi	r2,r2,9696
 32045e4:	200b883a 	mov	r5,r4
 32045e8:	11000017 	ldw	r4,0(r2)
 32045ec:	32044cc1 	jmpi	32044cc <_fclose_r>

032045f0 <_fflush_r>:
 32045f0:	defffb04 	addi	sp,sp,-20
 32045f4:	dcc00315 	stw	r19,12(sp)
 32045f8:	dc800215 	stw	r18,8(sp)
 32045fc:	dfc00415 	stw	ra,16(sp)
 3204600:	dc400115 	stw	r17,4(sp)
 3204604:	dc000015 	stw	r16,0(sp)
 3204608:	2027883a 	mov	r19,r4
 320460c:	2825883a 	mov	r18,r5
 3204610:	20000226 	beq	r4,zero,320461c <_fflush_r+0x2c>
 3204614:	20800e17 	ldw	r2,56(r4)
 3204618:	10005626 	beq	r2,zero,3204774 <_fflush_r+0x184>
 320461c:	9100030b 	ldhu	r4,12(r18)
 3204620:	20ffffcc 	andi	r3,r4,65535
 3204624:	18e0001c 	xori	r3,r3,32768
 3204628:	18e00004 	addi	r3,r3,-32768
 320462c:	1880020c 	andi	r2,r3,8
 3204630:	1000261e 	bne	r2,zero,32046cc <_fflush_r+0xdc>
 3204634:	90c00117 	ldw	r3,4(r18)
 3204638:	20820014 	ori	r2,r4,2048
 320463c:	9080030d 	sth	r2,12(r18)
 3204640:	1009883a 	mov	r4,r2
 3204644:	00c0400e 	bge	zero,r3,3204748 <_fflush_r+0x158>
 3204648:	92000a17 	ldw	r8,40(r18)
 320464c:	40004026 	beq	r8,zero,3204750 <_fflush_r+0x160>
 3204650:	2084000c 	andi	r2,r4,4096
 3204654:	10005326 	beq	r2,zero,32047a4 <_fflush_r+0x1b4>
 3204658:	94001417 	ldw	r16,80(r18)
 320465c:	9080030b 	ldhu	r2,12(r18)
 3204660:	1080010c 	andi	r2,r2,4
 3204664:	1000481e 	bne	r2,zero,3204788 <_fflush_r+0x198>
 3204668:	91400717 	ldw	r5,28(r18)
 320466c:	9809883a 	mov	r4,r19
 3204670:	800d883a 	mov	r6,r16
 3204674:	000f883a 	mov	r7,zero
 3204678:	403ee83a 	callr	r8
 320467c:	8080261e 	bne	r16,r2,3204718 <_fflush_r+0x128>
 3204680:	9080030b 	ldhu	r2,12(r18)
 3204684:	91000417 	ldw	r4,16(r18)
 3204688:	90000115 	stw	zero,4(r18)
 320468c:	10bdffcc 	andi	r2,r2,63487
 3204690:	10ffffcc 	andi	r3,r2,65535
 3204694:	18c4000c 	andi	r3,r3,4096
 3204698:	9080030d 	sth	r2,12(r18)
 320469c:	91000015 	stw	r4,0(r18)
 32046a0:	18002b26 	beq	r3,zero,3204750 <_fflush_r+0x160>
 32046a4:	0007883a 	mov	r3,zero
 32046a8:	1805883a 	mov	r2,r3
 32046ac:	94001415 	stw	r16,80(r18)
 32046b0:	dfc00417 	ldw	ra,16(sp)
 32046b4:	dcc00317 	ldw	r19,12(sp)
 32046b8:	dc800217 	ldw	r18,8(sp)
 32046bc:	dc400117 	ldw	r17,4(sp)
 32046c0:	dc000017 	ldw	r16,0(sp)
 32046c4:	dec00504 	addi	sp,sp,20
 32046c8:	f800283a 	ret
 32046cc:	94400417 	ldw	r17,16(r18)
 32046d0:	88001f26 	beq	r17,zero,3204750 <_fflush_r+0x160>
 32046d4:	90800017 	ldw	r2,0(r18)
 32046d8:	18c000cc 	andi	r3,r3,3
 32046dc:	94400015 	stw	r17,0(r18)
 32046e0:	1461c83a 	sub	r16,r2,r17
 32046e4:	18002526 	beq	r3,zero,320477c <_fflush_r+0x18c>
 32046e8:	0005883a 	mov	r2,zero
 32046ec:	90800215 	stw	r2,8(r18)
 32046f0:	0400170e 	bge	zero,r16,3204750 <_fflush_r+0x160>
 32046f4:	90c00917 	ldw	r3,36(r18)
 32046f8:	91400717 	ldw	r5,28(r18)
 32046fc:	880d883a 	mov	r6,r17
 3204700:	800f883a 	mov	r7,r16
 3204704:	9809883a 	mov	r4,r19
 3204708:	183ee83a 	callr	r3
 320470c:	88a3883a 	add	r17,r17,r2
 3204710:	80a1c83a 	sub	r16,r16,r2
 3204714:	00bff616 	blt	zero,r2,32046f0 <_fflush_r+0x100>
 3204718:	9080030b 	ldhu	r2,12(r18)
 320471c:	00ffffc4 	movi	r3,-1
 3204720:	10801014 	ori	r2,r2,64
 3204724:	9080030d 	sth	r2,12(r18)
 3204728:	1805883a 	mov	r2,r3
 320472c:	dfc00417 	ldw	ra,16(sp)
 3204730:	dcc00317 	ldw	r19,12(sp)
 3204734:	dc800217 	ldw	r18,8(sp)
 3204738:	dc400117 	ldw	r17,4(sp)
 320473c:	dc000017 	ldw	r16,0(sp)
 3204740:	dec00504 	addi	sp,sp,20
 3204744:	f800283a 	ret
 3204748:	90800f17 	ldw	r2,60(r18)
 320474c:	00bfbe16 	blt	zero,r2,3204648 <_fflush_r+0x58>
 3204750:	0007883a 	mov	r3,zero
 3204754:	1805883a 	mov	r2,r3
 3204758:	dfc00417 	ldw	ra,16(sp)
 320475c:	dcc00317 	ldw	r19,12(sp)
 3204760:	dc800217 	ldw	r18,8(sp)
 3204764:	dc400117 	ldw	r17,4(sp)
 3204768:	dc000017 	ldw	r16,0(sp)
 320476c:	dec00504 	addi	sp,sp,20
 3204770:	f800283a 	ret
 3204774:	32048880 	call	3204888 <__sinit>
 3204778:	003fa806 	br	320461c <_fflush_r+0x2c>
 320477c:	90800517 	ldw	r2,20(r18)
 3204780:	90800215 	stw	r2,8(r18)
 3204784:	003fda06 	br	32046f0 <_fflush_r+0x100>
 3204788:	90800117 	ldw	r2,4(r18)
 320478c:	90c00c17 	ldw	r3,48(r18)
 3204790:	80a1c83a 	sub	r16,r16,r2
 3204794:	183fb426 	beq	r3,zero,3204668 <_fflush_r+0x78>
 3204798:	90800f17 	ldw	r2,60(r18)
 320479c:	80a1c83a 	sub	r16,r16,r2
 32047a0:	003fb106 	br	3204668 <_fflush_r+0x78>
 32047a4:	91400717 	ldw	r5,28(r18)
 32047a8:	9809883a 	mov	r4,r19
 32047ac:	000d883a 	mov	r6,zero
 32047b0:	01c00044 	movi	r7,1
 32047b4:	403ee83a 	callr	r8
 32047b8:	1021883a 	mov	r16,r2
 32047bc:	00bfffc4 	movi	r2,-1
 32047c0:	80800226 	beq	r16,r2,32047cc <_fflush_r+0x1dc>
 32047c4:	92000a17 	ldw	r8,40(r18)
 32047c8:	003fa406 	br	320465c <_fflush_r+0x6c>
 32047cc:	98c00017 	ldw	r3,0(r19)
 32047d0:	00800744 	movi	r2,29
 32047d4:	18bfde26 	beq	r3,r2,3204750 <_fflush_r+0x160>
 32047d8:	9080030b 	ldhu	r2,12(r18)
 32047dc:	8007883a 	mov	r3,r16
 32047e0:	10801014 	ori	r2,r2,64
 32047e4:	9080030d 	sth	r2,12(r18)
 32047e8:	003fcf06 	br	3204728 <_fflush_r+0x138>

032047ec <fflush>:
 32047ec:	0140c834 	movhi	r5,800
 32047f0:	29517c04 	addi	r5,r5,17904
 32047f4:	2007883a 	mov	r3,r4
 32047f8:	20000526 	beq	r4,zero,3204810 <fflush+0x24>
 32047fc:	0080c974 	movhi	r2,805
 3204800:	10897804 	addi	r2,r2,9696
 3204804:	11000017 	ldw	r4,0(r2)
 3204808:	180b883a 	mov	r5,r3
 320480c:	32045f01 	jmpi	32045f0 <_fflush_r>
 3204810:	0080c974 	movhi	r2,805
 3204814:	10897904 	addi	r2,r2,9700
 3204818:	11000017 	ldw	r4,0(r2)
 320481c:	3205a901 	jmpi	3205a90 <_fwalk_reent>

03204820 <std>:
 3204820:	0080c834 	movhi	r2,800
 3204824:	109e2904 	addi	r2,r2,30884
 3204828:	20800b15 	stw	r2,44(r4)
 320482c:	0080c834 	movhi	r2,800
 3204830:	109e6404 	addi	r2,r2,31120
 3204834:	20800815 	stw	r2,32(r4)
 3204838:	00c0c834 	movhi	r3,800
 320483c:	18de4504 	addi	r3,r3,30996
 3204840:	0080c834 	movhi	r2,800
 3204844:	109e2b04 	addi	r2,r2,30892
 3204848:	2140030d 	sth	r5,12(r4)
 320484c:	2180038d 	sth	r6,14(r4)
 3204850:	20c00915 	stw	r3,36(r4)
 3204854:	20800a15 	stw	r2,40(r4)
 3204858:	20000015 	stw	zero,0(r4)
 320485c:	20000115 	stw	zero,4(r4)
 3204860:	20000215 	stw	zero,8(r4)
 3204864:	20000415 	stw	zero,16(r4)
 3204868:	20000515 	stw	zero,20(r4)
 320486c:	20000615 	stw	zero,24(r4)
 3204870:	21000715 	stw	r4,28(r4)
 3204874:	f800283a 	ret

03204878 <__sfp_lock_acquire>:
 3204878:	f800283a 	ret

0320487c <__sfp_lock_release>:
 320487c:	f800283a 	ret

03204880 <__sinit_lock_acquire>:
 3204880:	f800283a 	ret

03204884 <__sinit_lock_release>:
 3204884:	f800283a 	ret

03204888 <__sinit>:
 3204888:	20800e17 	ldw	r2,56(r4)
 320488c:	defffd04 	addi	sp,sp,-12
 3204890:	dc400115 	stw	r17,4(sp)
 3204894:	dc000015 	stw	r16,0(sp)
 3204898:	dfc00215 	stw	ra,8(sp)
 320489c:	04400044 	movi	r17,1
 32048a0:	01400104 	movi	r5,4
 32048a4:	000d883a 	mov	r6,zero
 32048a8:	2021883a 	mov	r16,r4
 32048ac:	2200bb04 	addi	r8,r4,748
 32048b0:	200f883a 	mov	r7,r4
 32048b4:	10000526 	beq	r2,zero,32048cc <__sinit+0x44>
 32048b8:	dfc00217 	ldw	ra,8(sp)
 32048bc:	dc400117 	ldw	r17,4(sp)
 32048c0:	dc000017 	ldw	r16,0(sp)
 32048c4:	dec00304 	addi	sp,sp,12
 32048c8:	f800283a 	ret
 32048cc:	21000117 	ldw	r4,4(r4)
 32048d0:	0080c834 	movhi	r2,800
 32048d4:	10925b04 	addi	r2,r2,18796
 32048d8:	00c000c4 	movi	r3,3
 32048dc:	80800f15 	stw	r2,60(r16)
 32048e0:	80c0b915 	stw	r3,740(r16)
 32048e4:	8200ba15 	stw	r8,744(r16)
 32048e8:	84400e15 	stw	r17,56(r16)
 32048ec:	8000b815 	stw	zero,736(r16)
 32048f0:	32048200 	call	3204820 <std>
 32048f4:	81000217 	ldw	r4,8(r16)
 32048f8:	880d883a 	mov	r6,r17
 32048fc:	800f883a 	mov	r7,r16
 3204900:	01400284 	movi	r5,10
 3204904:	32048200 	call	3204820 <std>
 3204908:	81000317 	ldw	r4,12(r16)
 320490c:	800f883a 	mov	r7,r16
 3204910:	01400484 	movi	r5,18
 3204914:	01800084 	movi	r6,2
 3204918:	dfc00217 	ldw	ra,8(sp)
 320491c:	dc400117 	ldw	r17,4(sp)
 3204920:	dc000017 	ldw	r16,0(sp)
 3204924:	dec00304 	addi	sp,sp,12
 3204928:	32048201 	jmpi	3204820 <std>

0320492c <__fp_lock>:
 320492c:	0005883a 	mov	r2,zero
 3204930:	f800283a 	ret

03204934 <__fp_unlock>:
 3204934:	0005883a 	mov	r2,zero
 3204938:	f800283a 	ret

0320493c <__fp_unlock_all>:
 320493c:	0080c974 	movhi	r2,805
 3204940:	10897804 	addi	r2,r2,9696
 3204944:	11000017 	ldw	r4,0(r2)
 3204948:	0140c834 	movhi	r5,800
 320494c:	29524d04 	addi	r5,r5,18740
 3204950:	3205b581 	jmpi	3205b58 <_fwalk>

03204954 <__fp_lock_all>:
 3204954:	0080c974 	movhi	r2,805
 3204958:	10897804 	addi	r2,r2,9696
 320495c:	11000017 	ldw	r4,0(r2)
 3204960:	0140c834 	movhi	r5,800
 3204964:	29524b04 	addi	r5,r5,18732
 3204968:	3205b581 	jmpi	3205b58 <_fwalk>

0320496c <_cleanup_r>:
 320496c:	0140c834 	movhi	r5,800
 3204970:	29517704 	addi	r5,r5,17884
 3204974:	3205b581 	jmpi	3205b58 <_fwalk>

03204978 <_cleanup>:
 3204978:	0080c974 	movhi	r2,805
 320497c:	10897904 	addi	r2,r2,9700
 3204980:	11000017 	ldw	r4,0(r2)
 3204984:	320496c1 	jmpi	320496c <_cleanup_r>

03204988 <__sfmoreglue>:
 3204988:	defffc04 	addi	sp,sp,-16
 320498c:	dc400115 	stw	r17,4(sp)
 3204990:	2c401724 	muli	r17,r5,92
 3204994:	dc800215 	stw	r18,8(sp)
 3204998:	2825883a 	mov	r18,r5
 320499c:	89400304 	addi	r5,r17,12
 32049a0:	dc000015 	stw	r16,0(sp)
 32049a4:	dfc00315 	stw	ra,12(sp)
 32049a8:	3205fa80 	call	3205fa8 <_malloc_r>
 32049ac:	0021883a 	mov	r16,zero
 32049b0:	880d883a 	mov	r6,r17
 32049b4:	000b883a 	mov	r5,zero
 32049b8:	10000626 	beq	r2,zero,32049d4 <__sfmoreglue+0x4c>
 32049bc:	11000304 	addi	r4,r2,12
 32049c0:	14800115 	stw	r18,4(r2)
 32049c4:	10000015 	stw	zero,0(r2)
 32049c8:	11000215 	stw	r4,8(r2)
 32049cc:	1021883a 	mov	r16,r2
 32049d0:	320694c0 	call	320694c <memset>
 32049d4:	8005883a 	mov	r2,r16
 32049d8:	dfc00317 	ldw	ra,12(sp)
 32049dc:	dc800217 	ldw	r18,8(sp)
 32049e0:	dc400117 	ldw	r17,4(sp)
 32049e4:	dc000017 	ldw	r16,0(sp)
 32049e8:	dec00404 	addi	sp,sp,16
 32049ec:	f800283a 	ret

032049f0 <__sfp>:
 32049f0:	defffd04 	addi	sp,sp,-12
 32049f4:	0080c974 	movhi	r2,805
 32049f8:	10897904 	addi	r2,r2,9700
 32049fc:	dc000015 	stw	r16,0(sp)
 3204a00:	14000017 	ldw	r16,0(r2)
 3204a04:	dc400115 	stw	r17,4(sp)
 3204a08:	dfc00215 	stw	ra,8(sp)
 3204a0c:	80800e17 	ldw	r2,56(r16)
 3204a10:	2023883a 	mov	r17,r4
 3204a14:	10002626 	beq	r2,zero,3204ab0 <__sfp+0xc0>
 3204a18:	8400b804 	addi	r16,r16,736
 3204a1c:	80800117 	ldw	r2,4(r16)
 3204a20:	81000217 	ldw	r4,8(r16)
 3204a24:	10ffffc4 	addi	r3,r2,-1
 3204a28:	18000916 	blt	r3,zero,3204a50 <__sfp+0x60>
 3204a2c:	2080030f 	ldh	r2,12(r4)
 3204a30:	10000b26 	beq	r2,zero,3204a60 <__sfp+0x70>
 3204a34:	017fffc4 	movi	r5,-1
 3204a38:	00000206 	br	3204a44 <__sfp+0x54>
 3204a3c:	2080030f 	ldh	r2,12(r4)
 3204a40:	10000726 	beq	r2,zero,3204a60 <__sfp+0x70>
 3204a44:	18ffffc4 	addi	r3,r3,-1
 3204a48:	21001704 	addi	r4,r4,92
 3204a4c:	197ffb1e 	bne	r3,r5,3204a3c <__sfp+0x4c>
 3204a50:	80800017 	ldw	r2,0(r16)
 3204a54:	10001926 	beq	r2,zero,3204abc <__sfp+0xcc>
 3204a58:	1021883a 	mov	r16,r2
 3204a5c:	003fef06 	br	3204a1c <__sfp+0x2c>
 3204a60:	00bfffc4 	movi	r2,-1
 3204a64:	00c00044 	movi	r3,1
 3204a68:	2080038d 	sth	r2,14(r4)
 3204a6c:	20c0030d 	sth	r3,12(r4)
 3204a70:	20000015 	stw	zero,0(r4)
 3204a74:	20000215 	stw	zero,8(r4)
 3204a78:	20000115 	stw	zero,4(r4)
 3204a7c:	20000415 	stw	zero,16(r4)
 3204a80:	20000515 	stw	zero,20(r4)
 3204a84:	20000615 	stw	zero,24(r4)
 3204a88:	20000c15 	stw	zero,48(r4)
 3204a8c:	20000d15 	stw	zero,52(r4)
 3204a90:	20001115 	stw	zero,68(r4)
 3204a94:	20001215 	stw	zero,72(r4)
 3204a98:	2005883a 	mov	r2,r4
 3204a9c:	dfc00217 	ldw	ra,8(sp)
 3204aa0:	dc400117 	ldw	r17,4(sp)
 3204aa4:	dc000017 	ldw	r16,0(sp)
 3204aa8:	dec00304 	addi	sp,sp,12
 3204aac:	f800283a 	ret
 3204ab0:	8009883a 	mov	r4,r16
 3204ab4:	32048880 	call	3204888 <__sinit>
 3204ab8:	003fd706 	br	3204a18 <__sfp+0x28>
 3204abc:	8809883a 	mov	r4,r17
 3204ac0:	01400104 	movi	r5,4
 3204ac4:	32049880 	call	3204988 <__sfmoreglue>
 3204ac8:	80800015 	stw	r2,0(r16)
 3204acc:	103fe21e 	bne	r2,zero,3204a58 <__sfp+0x68>
 3204ad0:	00800304 	movi	r2,12
 3204ad4:	0009883a 	mov	r4,zero
 3204ad8:	88800015 	stw	r2,0(r17)
 3204adc:	003fee06 	br	3204a98 <__sfp+0xa8>

03204ae0 <_fopen_r>:
 3204ae0:	defffa04 	addi	sp,sp,-24
 3204ae4:	dcc00415 	stw	r19,16(sp)
 3204ae8:	2827883a 	mov	r19,r5
 3204aec:	300b883a 	mov	r5,r6
 3204af0:	d80d883a 	mov	r6,sp
 3204af4:	dc800315 	stw	r18,12(sp)
 3204af8:	dc400215 	stw	r17,8(sp)
 3204afc:	dc000115 	stw	r16,4(sp)
 3204b00:	dfc00515 	stw	ra,20(sp)
 3204b04:	2021883a 	mov	r16,r4
 3204b08:	320d3a40 	call	320d3a4 <__sflags>
 3204b0c:	1025883a 	mov	r18,r2
 3204b10:	8009883a 	mov	r4,r16
 3204b14:	0023883a 	mov	r17,zero
 3204b18:	1000081e 	bne	r2,zero,3204b3c <_fopen_r+0x5c>
 3204b1c:	8805883a 	mov	r2,r17
 3204b20:	dfc00517 	ldw	ra,20(sp)
 3204b24:	dcc00417 	ldw	r19,16(sp)
 3204b28:	dc800317 	ldw	r18,12(sp)
 3204b2c:	dc400217 	ldw	r17,8(sp)
 3204b30:	dc000117 	ldw	r16,4(sp)
 3204b34:	dec00604 	addi	sp,sp,24
 3204b38:	f800283a 	ret
 3204b3c:	32049f00 	call	32049f0 <__sfp>
 3204b40:	1023883a 	mov	r17,r2
 3204b44:	980b883a 	mov	r5,r19
 3204b48:	8009883a 	mov	r4,r16
 3204b4c:	01c06d84 	movi	r7,438
 3204b50:	103ff226 	beq	r2,zero,3204b1c <_fopen_r+0x3c>
 3204b54:	d9800017 	ldw	r6,0(sp)
 3204b58:	32069e40 	call	32069e4 <_open_r>
 3204b5c:	10001816 	blt	r2,zero,3204bc0 <_fopen_r+0xe0>
 3204b60:	00c0c834 	movhi	r3,800
 3204b64:	18de4504 	addi	r3,r3,30996
 3204b68:	923fffcc 	andi	r8,r18,65535
 3204b6c:	8880038d 	sth	r2,14(r17)
 3204b70:	0080c834 	movhi	r2,800
 3204b74:	109e6404 	addi	r2,r2,31120
 3204b78:	88800815 	stw	r2,32(r17)
 3204b7c:	88c00915 	stw	r3,36(r17)
 3204b80:	0080c834 	movhi	r2,800
 3204b84:	109e2b04 	addi	r2,r2,30892
 3204b88:	00c0c834 	movhi	r3,800
 3204b8c:	18de2904 	addi	r3,r3,30884
 3204b90:	4200400c 	andi	r8,r8,256
 3204b94:	8c80030d 	sth	r18,12(r17)
 3204b98:	8009883a 	mov	r4,r16
 3204b9c:	880b883a 	mov	r5,r17
 3204ba0:	000d883a 	mov	r6,zero
 3204ba4:	01c00084 	movi	r7,2
 3204ba8:	88800a15 	stw	r2,40(r17)
 3204bac:	88c00b15 	stw	r3,44(r17)
 3204bb0:	8c400715 	stw	r17,28(r17)
 3204bb4:	403fd926 	beq	r8,zero,3204b1c <_fopen_r+0x3c>
 3204bb8:	32051200 	call	3205120 <_fseek_r>
 3204bbc:	003fd706 	br	3204b1c <_fopen_r+0x3c>
 3204bc0:	32048780 	call	3204878 <__sfp_lock_acquire>
 3204bc4:	8800030d 	sth	zero,12(r17)
 3204bc8:	320487c0 	call	320487c <__sfp_lock_release>
 3204bcc:	0023883a 	mov	r17,zero
 3204bd0:	003fd206 	br	3204b1c <_fopen_r+0x3c>

03204bd4 <fopen>:
 3204bd4:	0180c974 	movhi	r6,805
 3204bd8:	31897804 	addi	r6,r6,9696
 3204bdc:	2007883a 	mov	r3,r4
 3204be0:	31000017 	ldw	r4,0(r6)
 3204be4:	280d883a 	mov	r6,r5
 3204be8:	180b883a 	mov	r5,r3
 3204bec:	3204ae01 	jmpi	3204ae0 <_fopen_r>

03204bf0 <fprintf>:
 3204bf0:	defffc04 	addi	sp,sp,-16
 3204bf4:	dfc00115 	stw	ra,4(sp)
 3204bf8:	d9800215 	stw	r6,8(sp)
 3204bfc:	d9c00315 	stw	r7,12(sp)
 3204c00:	d8800204 	addi	r2,sp,8
 3204c04:	100d883a 	mov	r6,r2
 3204c08:	d8800015 	stw	r2,0(sp)
 3204c0c:	320a0c40 	call	320a0c4 <__vfprintf_internal>
 3204c10:	dfc00117 	ldw	ra,4(sp)
 3204c14:	dec00404 	addi	sp,sp,16
 3204c18:	f800283a 	ret

03204c1c <_fprintf_r>:
 3204c1c:	defffd04 	addi	sp,sp,-12
 3204c20:	2807883a 	mov	r3,r5
 3204c24:	dfc00115 	stw	ra,4(sp)
 3204c28:	d9c00215 	stw	r7,8(sp)
 3204c2c:	d8800204 	addi	r2,sp,8
 3204c30:	300b883a 	mov	r5,r6
 3204c34:	1809883a 	mov	r4,r3
 3204c38:	100d883a 	mov	r6,r2
 3204c3c:	d8800015 	stw	r2,0(sp)
 3204c40:	320a0c40 	call	320a0c4 <__vfprintf_internal>
 3204c44:	dfc00117 	ldw	ra,4(sp)
 3204c48:	dec00304 	addi	sp,sp,12
 3204c4c:	f800283a 	ret

03204c50 <_fputs_r>:
 3204c50:	defff804 	addi	sp,sp,-32
 3204c54:	dc000515 	stw	r16,20(sp)
 3204c58:	2021883a 	mov	r16,r4
 3204c5c:	2809883a 	mov	r4,r5
 3204c60:	dc400615 	stw	r17,24(sp)
 3204c64:	dfc00715 	stw	ra,28(sp)
 3204c68:	3023883a 	mov	r17,r6
 3204c6c:	d9400015 	stw	r5,0(sp)
 3204c70:	32081440 	call	3208144 <strlen>
 3204c74:	00c00044 	movi	r3,1
 3204c78:	d8800115 	stw	r2,4(sp)
 3204c7c:	d8c00315 	stw	r3,12(sp)
 3204c80:	d8800415 	stw	r2,16(sp)
 3204c84:	dec00215 	stw	sp,8(sp)
 3204c88:	80000326 	beq	r16,zero,3204c98 <_fputs_r+0x48>
 3204c8c:	80800e17 	ldw	r2,56(r16)
 3204c90:	8009883a 	mov	r4,r16
 3204c94:	10000926 	beq	r2,zero,3204cbc <_fputs_r+0x6c>
 3204c98:	8009883a 	mov	r4,r16
 3204c9c:	880b883a 	mov	r5,r17
 3204ca0:	d9800204 	addi	r6,sp,8
 3204ca4:	32055f40 	call	32055f4 <__sfvwrite_r>
 3204ca8:	dfc00717 	ldw	ra,28(sp)
 3204cac:	dc400617 	ldw	r17,24(sp)
 3204cb0:	dc000517 	ldw	r16,20(sp)
 3204cb4:	dec00804 	addi	sp,sp,32
 3204cb8:	f800283a 	ret
 3204cbc:	32048880 	call	3204888 <__sinit>
 3204cc0:	003ff506 	br	3204c98 <_fputs_r+0x48>

03204cc4 <fputs>:
 3204cc4:	0180c974 	movhi	r6,805
 3204cc8:	31897804 	addi	r6,r6,9696
 3204ccc:	2007883a 	mov	r3,r4
 3204cd0:	31000017 	ldw	r4,0(r6)
 3204cd4:	280d883a 	mov	r6,r5
 3204cd8:	180b883a 	mov	r5,r3
 3204cdc:	3204c501 	jmpi	3204c50 <_fputs_r>

03204ce0 <_malloc_trim_r>:
 3204ce0:	defffb04 	addi	sp,sp,-20
 3204ce4:	dcc00315 	stw	r19,12(sp)
 3204ce8:	04c0c974 	movhi	r19,805
 3204cec:	9cc29a04 	addi	r19,r19,2664
 3204cf0:	dc800215 	stw	r18,8(sp)
 3204cf4:	dc400115 	stw	r17,4(sp)
 3204cf8:	dc000015 	stw	r16,0(sp)
 3204cfc:	2823883a 	mov	r17,r5
 3204d00:	2025883a 	mov	r18,r4
 3204d04:	dfc00415 	stw	ra,16(sp)
 3204d08:	321506c0 	call	321506c <__malloc_lock>
 3204d0c:	98800217 	ldw	r2,8(r19)
 3204d10:	9009883a 	mov	r4,r18
 3204d14:	000b883a 	mov	r5,zero
 3204d18:	10c00117 	ldw	r3,4(r2)
 3204d1c:	00bfff04 	movi	r2,-4
 3204d20:	18a0703a 	and	r16,r3,r2
 3204d24:	8463c83a 	sub	r17,r16,r17
 3204d28:	8c43fbc4 	addi	r17,r17,4079
 3204d2c:	8822d33a 	srli	r17,r17,12
 3204d30:	0083ffc4 	movi	r2,4095
 3204d34:	8c7fffc4 	addi	r17,r17,-1
 3204d38:	8822933a 	slli	r17,r17,12
 3204d3c:	1440060e 	bge	r2,r17,3204d58 <_malloc_trim_r+0x78>
 3204d40:	320764c0 	call	320764c <_sbrk_r>
 3204d44:	98c00217 	ldw	r3,8(r19)
 3204d48:	9009883a 	mov	r4,r18
 3204d4c:	044bc83a 	sub	r5,zero,r17
 3204d50:	80c7883a 	add	r3,r16,r3
 3204d54:	10c00926 	beq	r2,r3,3204d7c <_malloc_trim_r+0x9c>
 3204d58:	32151740 	call	3215174 <__malloc_unlock>
 3204d5c:	0005883a 	mov	r2,zero
 3204d60:	dfc00417 	ldw	ra,16(sp)
 3204d64:	dcc00317 	ldw	r19,12(sp)
 3204d68:	dc800217 	ldw	r18,8(sp)
 3204d6c:	dc400117 	ldw	r17,4(sp)
 3204d70:	dc000017 	ldw	r16,0(sp)
 3204d74:	dec00504 	addi	sp,sp,20
 3204d78:	f800283a 	ret
 3204d7c:	9009883a 	mov	r4,r18
 3204d80:	320764c0 	call	320764c <_sbrk_r>
 3204d84:	844dc83a 	sub	r6,r16,r17
 3204d88:	00ffffc4 	movi	r3,-1
 3204d8c:	9009883a 	mov	r4,r18
 3204d90:	000b883a 	mov	r5,zero
 3204d94:	01c0c974 	movhi	r7,805
 3204d98:	39d49004 	addi	r7,r7,21056
 3204d9c:	31800054 	ori	r6,r6,1
 3204da0:	10c00926 	beq	r2,r3,3204dc8 <_malloc_trim_r+0xe8>
 3204da4:	38800017 	ldw	r2,0(r7)
 3204da8:	98c00217 	ldw	r3,8(r19)
 3204dac:	9009883a 	mov	r4,r18
 3204db0:	1445c83a 	sub	r2,r2,r17
 3204db4:	38800015 	stw	r2,0(r7)
 3204db8:	19800115 	stw	r6,4(r3)
 3204dbc:	32151740 	call	3215174 <__malloc_unlock>
 3204dc0:	00800044 	movi	r2,1
 3204dc4:	003fe606 	br	3204d60 <_malloc_trim_r+0x80>
 3204dc8:	320764c0 	call	320764c <_sbrk_r>
 3204dcc:	99800217 	ldw	r6,8(r19)
 3204dd0:	100f883a 	mov	r7,r2
 3204dd4:	9009883a 	mov	r4,r18
 3204dd8:	1187c83a 	sub	r3,r2,r6
 3204ddc:	008003c4 	movi	r2,15
 3204de0:	19400054 	ori	r5,r3,1
 3204de4:	10ffdc0e 	bge	r2,r3,3204d58 <_malloc_trim_r+0x78>
 3204de8:	0080c974 	movhi	r2,805
 3204dec:	10897b04 	addi	r2,r2,9708
 3204df0:	10c00017 	ldw	r3,0(r2)
 3204df4:	0080c974 	movhi	r2,805
 3204df8:	10949004 	addi	r2,r2,21056
 3204dfc:	31400115 	stw	r5,4(r6)
 3204e00:	38c7c83a 	sub	r3,r7,r3
 3204e04:	10c00015 	stw	r3,0(r2)
 3204e08:	003fd306 	br	3204d58 <_malloc_trim_r+0x78>

03204e0c <_free_r>:
 3204e0c:	defffd04 	addi	sp,sp,-12
 3204e10:	dc400115 	stw	r17,4(sp)
 3204e14:	dc000015 	stw	r16,0(sp)
 3204e18:	dfc00215 	stw	ra,8(sp)
 3204e1c:	2821883a 	mov	r16,r5
 3204e20:	2023883a 	mov	r17,r4
 3204e24:	28005a26 	beq	r5,zero,3204f90 <_free_r+0x184>
 3204e28:	321506c0 	call	321506c <__malloc_lock>
 3204e2c:	823ffe04 	addi	r8,r16,-8
 3204e30:	41400117 	ldw	r5,4(r8)
 3204e34:	00bfff84 	movi	r2,-2
 3204e38:	0280c974 	movhi	r10,805
 3204e3c:	52829a04 	addi	r10,r10,2664
 3204e40:	288e703a 	and	r7,r5,r2
 3204e44:	41cd883a 	add	r6,r8,r7
 3204e48:	30c00117 	ldw	r3,4(r6)
 3204e4c:	51000217 	ldw	r4,8(r10)
 3204e50:	00bfff04 	movi	r2,-4
 3204e54:	1892703a 	and	r9,r3,r2
 3204e58:	5017883a 	mov	r11,r10
 3204e5c:	31006726 	beq	r6,r4,3204ffc <_free_r+0x1f0>
 3204e60:	2880004c 	andi	r2,r5,1
 3204e64:	1005003a 	cmpeq	r2,r2,zero
 3204e68:	32400115 	stw	r9,4(r6)
 3204e6c:	10001a1e 	bne	r2,zero,3204ed8 <_free_r+0xcc>
 3204e70:	000b883a 	mov	r5,zero
 3204e74:	3247883a 	add	r3,r6,r9
 3204e78:	18800117 	ldw	r2,4(r3)
 3204e7c:	1080004c 	andi	r2,r2,1
 3204e80:	1000231e 	bne	r2,zero,3204f10 <_free_r+0x104>
 3204e84:	280ac03a 	cmpne	r5,r5,zero
 3204e88:	3a4f883a 	add	r7,r7,r9
 3204e8c:	2800451e 	bne	r5,zero,3204fa4 <_free_r+0x198>
 3204e90:	31000217 	ldw	r4,8(r6)
 3204e94:	0080c974 	movhi	r2,805
 3204e98:	10829c04 	addi	r2,r2,2672
 3204e9c:	20807b26 	beq	r4,r2,320508c <_free_r+0x280>
 3204ea0:	30800317 	ldw	r2,12(r6)
 3204ea4:	3a07883a 	add	r3,r7,r8
 3204ea8:	19c00015 	stw	r7,0(r3)
 3204eac:	11000215 	stw	r4,8(r2)
 3204eb0:	20800315 	stw	r2,12(r4)
 3204eb4:	38800054 	ori	r2,r7,1
 3204eb8:	40800115 	stw	r2,4(r8)
 3204ebc:	28001a26 	beq	r5,zero,3204f28 <_free_r+0x11c>
 3204ec0:	8809883a 	mov	r4,r17
 3204ec4:	dfc00217 	ldw	ra,8(sp)
 3204ec8:	dc400117 	ldw	r17,4(sp)
 3204ecc:	dc000017 	ldw	r16,0(sp)
 3204ed0:	dec00304 	addi	sp,sp,12
 3204ed4:	32151741 	jmpi	3215174 <__malloc_unlock>
 3204ed8:	80bffe17 	ldw	r2,-8(r16)
 3204edc:	50c00204 	addi	r3,r10,8
 3204ee0:	4091c83a 	sub	r8,r8,r2
 3204ee4:	41000217 	ldw	r4,8(r8)
 3204ee8:	388f883a 	add	r7,r7,r2
 3204eec:	20c06126 	beq	r4,r3,3205074 <_free_r+0x268>
 3204ef0:	40800317 	ldw	r2,12(r8)
 3204ef4:	3247883a 	add	r3,r6,r9
 3204ef8:	000b883a 	mov	r5,zero
 3204efc:	11000215 	stw	r4,8(r2)
 3204f00:	20800315 	stw	r2,12(r4)
 3204f04:	18800117 	ldw	r2,4(r3)
 3204f08:	1080004c 	andi	r2,r2,1
 3204f0c:	103fdd26 	beq	r2,zero,3204e84 <_free_r+0x78>
 3204f10:	38800054 	ori	r2,r7,1
 3204f14:	3a07883a 	add	r3,r7,r8
 3204f18:	280ac03a 	cmpne	r5,r5,zero
 3204f1c:	40800115 	stw	r2,4(r8)
 3204f20:	19c00015 	stw	r7,0(r3)
 3204f24:	283fe61e 	bne	r5,zero,3204ec0 <_free_r+0xb4>
 3204f28:	00807fc4 	movi	r2,511
 3204f2c:	11c01f2e 	bgeu	r2,r7,3204fac <_free_r+0x1a0>
 3204f30:	3806d27a 	srli	r3,r7,9
 3204f34:	1800481e 	bne	r3,zero,3205058 <_free_r+0x24c>
 3204f38:	3804d0fa 	srli	r2,r7,3
 3204f3c:	100690fa 	slli	r3,r2,3
 3204f40:	1acd883a 	add	r6,r3,r11
 3204f44:	31400217 	ldw	r5,8(r6)
 3204f48:	31405926 	beq	r6,r5,32050b0 <_free_r+0x2a4>
 3204f4c:	28800117 	ldw	r2,4(r5)
 3204f50:	00ffff04 	movi	r3,-4
 3204f54:	10c4703a 	and	r2,r2,r3
 3204f58:	3880022e 	bgeu	r7,r2,3204f64 <_free_r+0x158>
 3204f5c:	29400217 	ldw	r5,8(r5)
 3204f60:	317ffa1e 	bne	r6,r5,3204f4c <_free_r+0x140>
 3204f64:	29800317 	ldw	r6,12(r5)
 3204f68:	41800315 	stw	r6,12(r8)
 3204f6c:	41400215 	stw	r5,8(r8)
 3204f70:	8809883a 	mov	r4,r17
 3204f74:	2a000315 	stw	r8,12(r5)
 3204f78:	32000215 	stw	r8,8(r6)
 3204f7c:	dfc00217 	ldw	ra,8(sp)
 3204f80:	dc400117 	ldw	r17,4(sp)
 3204f84:	dc000017 	ldw	r16,0(sp)
 3204f88:	dec00304 	addi	sp,sp,12
 3204f8c:	32151741 	jmpi	3215174 <__malloc_unlock>
 3204f90:	dfc00217 	ldw	ra,8(sp)
 3204f94:	dc400117 	ldw	r17,4(sp)
 3204f98:	dc000017 	ldw	r16,0(sp)
 3204f9c:	dec00304 	addi	sp,sp,12
 3204fa0:	f800283a 	ret
 3204fa4:	31000217 	ldw	r4,8(r6)
 3204fa8:	003fbd06 	br	3204ea0 <_free_r+0x94>
 3204fac:	3806d0fa 	srli	r3,r7,3
 3204fb0:	00800044 	movi	r2,1
 3204fb4:	51400117 	ldw	r5,4(r10)
 3204fb8:	180890fa 	slli	r4,r3,3
 3204fbc:	1807d0ba 	srai	r3,r3,2
 3204fc0:	22c9883a 	add	r4,r4,r11
 3204fc4:	21800217 	ldw	r6,8(r4)
 3204fc8:	10c4983a 	sll	r2,r2,r3
 3204fcc:	41000315 	stw	r4,12(r8)
 3204fd0:	41800215 	stw	r6,8(r8)
 3204fd4:	288ab03a 	or	r5,r5,r2
 3204fd8:	22000215 	stw	r8,8(r4)
 3204fdc:	8809883a 	mov	r4,r17
 3204fe0:	51400115 	stw	r5,4(r10)
 3204fe4:	32000315 	stw	r8,12(r6)
 3204fe8:	dfc00217 	ldw	ra,8(sp)
 3204fec:	dc400117 	ldw	r17,4(sp)
 3204ff0:	dc000017 	ldw	r16,0(sp)
 3204ff4:	dec00304 	addi	sp,sp,12
 3204ff8:	32151741 	jmpi	3215174 <__malloc_unlock>
 3204ffc:	2880004c 	andi	r2,r5,1
 3205000:	3a4d883a 	add	r6,r7,r9
 3205004:	1000071e 	bne	r2,zero,3205024 <_free_r+0x218>
 3205008:	80bffe17 	ldw	r2,-8(r16)
 320500c:	4091c83a 	sub	r8,r8,r2
 3205010:	41000317 	ldw	r4,12(r8)
 3205014:	40c00217 	ldw	r3,8(r8)
 3205018:	308d883a 	add	r6,r6,r2
 320501c:	20c00215 	stw	r3,8(r4)
 3205020:	19000315 	stw	r4,12(r3)
 3205024:	0080c974 	movhi	r2,805
 3205028:	10897a04 	addi	r2,r2,9704
 320502c:	11000017 	ldw	r4,0(r2)
 3205030:	30c00054 	ori	r3,r6,1
 3205034:	52000215 	stw	r8,8(r10)
 3205038:	40c00115 	stw	r3,4(r8)
 320503c:	313fa036 	bltu	r6,r4,3204ec0 <_free_r+0xb4>
 3205040:	0080c974 	movhi	r2,805
 3205044:	10920e04 	addi	r2,r2,18488
 3205048:	11400017 	ldw	r5,0(r2)
 320504c:	8809883a 	mov	r4,r17
 3205050:	3204ce00 	call	3204ce0 <_malloc_trim_r>
 3205054:	003f9a06 	br	3204ec0 <_free_r+0xb4>
 3205058:	00800104 	movi	r2,4
 320505c:	10c0072e 	bgeu	r2,r3,320507c <_free_r+0x270>
 3205060:	00800504 	movi	r2,20
 3205064:	10c01936 	bltu	r2,r3,32050cc <_free_r+0x2c0>
 3205068:	188016c4 	addi	r2,r3,91
 320506c:	100690fa 	slli	r3,r2,3
 3205070:	003fb306 	br	3204f40 <_free_r+0x134>
 3205074:	01400044 	movi	r5,1
 3205078:	003f7e06 	br	3204e74 <_free_r+0x68>
 320507c:	3804d1ba 	srli	r2,r7,6
 3205080:	10800e04 	addi	r2,r2,56
 3205084:	100690fa 	slli	r3,r2,3
 3205088:	003fad06 	br	3204f40 <_free_r+0x134>
 320508c:	22000315 	stw	r8,12(r4)
 3205090:	22000215 	stw	r8,8(r4)
 3205094:	3a05883a 	add	r2,r7,r8
 3205098:	38c00054 	ori	r3,r7,1
 320509c:	11c00015 	stw	r7,0(r2)
 32050a0:	41000215 	stw	r4,8(r8)
 32050a4:	40c00115 	stw	r3,4(r8)
 32050a8:	41000315 	stw	r4,12(r8)
 32050ac:	003f8406 	br	3204ec0 <_free_r+0xb4>
 32050b0:	1005d0ba 	srai	r2,r2,2
 32050b4:	00c00044 	movi	r3,1
 32050b8:	51000117 	ldw	r4,4(r10)
 32050bc:	1886983a 	sll	r3,r3,r2
 32050c0:	20c8b03a 	or	r4,r4,r3
 32050c4:	51000115 	stw	r4,4(r10)
 32050c8:	003fa706 	br	3204f68 <_free_r+0x15c>
 32050cc:	00801504 	movi	r2,84
 32050d0:	10c00436 	bltu	r2,r3,32050e4 <_free_r+0x2d8>
 32050d4:	3804d33a 	srli	r2,r7,12
 32050d8:	10801b84 	addi	r2,r2,110
 32050dc:	100690fa 	slli	r3,r2,3
 32050e0:	003f9706 	br	3204f40 <_free_r+0x134>
 32050e4:	00805504 	movi	r2,340
 32050e8:	10c00436 	bltu	r2,r3,32050fc <_free_r+0x2f0>
 32050ec:	3804d3fa 	srli	r2,r7,15
 32050f0:	10801dc4 	addi	r2,r2,119
 32050f4:	100690fa 	slli	r3,r2,3
 32050f8:	003f9106 	br	3204f40 <_free_r+0x134>
 32050fc:	00815504 	movi	r2,1364
 3205100:	10c0032e 	bgeu	r2,r3,3205110 <_free_r+0x304>
 3205104:	00801f84 	movi	r2,126
 3205108:	00c0fc04 	movi	r3,1008
 320510c:	003f8c06 	br	3204f40 <_free_r+0x134>
 3205110:	3804d4ba 	srli	r2,r7,18
 3205114:	10801f04 	addi	r2,r2,124
 3205118:	100690fa 	slli	r3,r2,3
 320511c:	003f8806 	br	3204f40 <_free_r+0x134>

03205120 <_fseek_r>:
 3205120:	deffe804 	addi	sp,sp,-96
 3205124:	dd801515 	stw	r22,84(sp)
 3205128:	dcc01215 	stw	r19,72(sp)
 320512c:	dc801115 	stw	r18,68(sp)
 3205130:	dc000f15 	stw	r16,60(sp)
 3205134:	dfc01715 	stw	ra,92(sp)
 3205138:	ddc01615 	stw	r23,88(sp)
 320513c:	dd401415 	stw	r21,80(sp)
 3205140:	dd001315 	stw	r20,76(sp)
 3205144:	dc401015 	stw	r17,64(sp)
 3205148:	2025883a 	mov	r18,r4
 320514c:	2821883a 	mov	r16,r5
 3205150:	302d883a 	mov	r22,r6
 3205154:	3827883a 	mov	r19,r7
 3205158:	20000226 	beq	r4,zero,3205164 <_fseek_r+0x44>
 320515c:	20800e17 	ldw	r2,56(r4)
 3205160:	10007826 	beq	r2,zero,3205344 <_fseek_r+0x224>
 3205164:	8080030b 	ldhu	r2,12(r16)
 3205168:	00c04204 	movi	r3,264
 320516c:	1080420c 	andi	r2,r2,264
 3205170:	10c07926 	beq	r2,r3,3205358 <_fseek_r+0x238>
 3205174:	85400a17 	ldw	r21,40(r16)
 3205178:	a800ea26 	beq	r21,zero,3205524 <_fseek_r+0x404>
 320517c:	00800044 	movi	r2,1
 3205180:	98805f26 	beq	r19,r2,3205300 <_fseek_r+0x1e0>
 3205184:	00800084 	movi	r2,2
 3205188:	98801026 	beq	r19,r2,32051cc <_fseek_r+0xac>
 320518c:	98000f26 	beq	r19,zero,32051cc <_fseek_r+0xac>
 3205190:	00800584 	movi	r2,22
 3205194:	013fffc4 	movi	r4,-1
 3205198:	90800015 	stw	r2,0(r18)
 320519c:	2005883a 	mov	r2,r4
 32051a0:	dfc01717 	ldw	ra,92(sp)
 32051a4:	ddc01617 	ldw	r23,88(sp)
 32051a8:	dd801517 	ldw	r22,84(sp)
 32051ac:	dd401417 	ldw	r21,80(sp)
 32051b0:	dd001317 	ldw	r20,76(sp)
 32051b4:	dcc01217 	ldw	r19,72(sp)
 32051b8:	dc801117 	ldw	r18,68(sp)
 32051bc:	dc401017 	ldw	r17,64(sp)
 32051c0:	dc000f17 	ldw	r16,60(sp)
 32051c4:	dec01804 	addi	sp,sp,96
 32051c8:	f800283a 	ret
 32051cc:	81800417 	ldw	r6,16(r16)
 32051d0:	0023883a 	mov	r17,zero
 32051d4:	002f883a 	mov	r23,zero
 32051d8:	3000a626 	beq	r6,zero,3205474 <_fseek_r+0x354>
 32051dc:	8100030b 	ldhu	r4,12(r16)
 32051e0:	2082068c 	andi	r2,r4,2074
 32051e4:	1000081e 	bne	r2,zero,3205208 <_fseek_r+0xe8>
 32051e8:	2081000c 	andi	r2,r4,1024
 32051ec:	10001b1e 	bne	r2,zero,320525c <_fseek_r+0x13c>
 32051f0:	0080c834 	movhi	r2,800
 32051f4:	109e2b04 	addi	r2,r2,30892
 32051f8:	a8800926 	beq	r21,r2,3205220 <_fseek_r+0x100>
 32051fc:	8080030b 	ldhu	r2,12(r16)
 3205200:	10820014 	ori	r2,r2,2048
 3205204:	8080030d 	sth	r2,12(r16)
 3205208:	9009883a 	mov	r4,r18
 320520c:	800b883a 	mov	r5,r16
 3205210:	32045f00 	call	32045f0 <_fflush_r>
 3205214:	1000a326 	beq	r2,zero,32054a4 <_fseek_r+0x384>
 3205218:	013fffc4 	movi	r4,-1
 320521c:	003fdf06 	br	320519c <_fseek_r+0x7c>
 3205220:	8140038f 	ldh	r5,14(r16)
 3205224:	283ff516 	blt	r5,zero,32051fc <_fseek_r+0xdc>
 3205228:	9009883a 	mov	r4,r18
 320522c:	d80d883a 	mov	r6,sp
 3205230:	32055800 	call	3205580 <_fstat_r>
 3205234:	103ff11e 	bne	r2,zero,32051fc <_fseek_r+0xdc>
 3205238:	d8800117 	ldw	r2,4(sp)
 320523c:	00e00014 	movui	r3,32768
 3205240:	10bc000c 	andi	r2,r2,61440
 3205244:	10ffed1e 	bne	r2,r3,32051fc <_fseek_r+0xdc>
 3205248:	80c0030b 	ldhu	r3,12(r16)
 320524c:	00810004 	movi	r2,1024
 3205250:	80801315 	stw	r2,76(r16)
 3205254:	1886b03a 	or	r3,r3,r2
 3205258:	80c0030d 	sth	r3,12(r16)
 320525c:	9800701e 	bne	r19,zero,3205420 <_fseek_r+0x300>
 3205260:	b029883a 	mov	r20,r22
 3205264:	b804c03a 	cmpne	r2,r23,zero
 3205268:	10003f1e 	bne	r2,zero,3205368 <_fseek_r+0x248>
 320526c:	8100030b 	ldhu	r4,12(r16)
 3205270:	2084000c 	andi	r2,r4,4096
 3205274:	1000a126 	beq	r2,zero,32054fc <_fseek_r+0x3dc>
 3205278:	81801417 	ldw	r6,80(r16)
 320527c:	80c00117 	ldw	r3,4(r16)
 3205280:	81400c17 	ldw	r5,48(r16)
 3205284:	30e3c83a 	sub	r17,r6,r3
 3205288:	28008026 	beq	r5,zero,320548c <_fseek_r+0x36c>
 320528c:	81c00f17 	ldw	r7,60(r16)
 3205290:	89e3c83a 	sub	r17,r17,r7
 3205294:	80800e17 	ldw	r2,56(r16)
 3205298:	81800417 	ldw	r6,16(r16)
 320529c:	88c7883a 	add	r3,r17,r3
 32052a0:	1185c83a 	sub	r2,r2,r6
 32052a4:	11cf883a 	add	r7,r2,r7
 32052a8:	1887c83a 	sub	r3,r3,r2
 32052ac:	2088000c 	andi	r2,r4,8192
 32052b0:	10003e1e 	bne	r2,zero,32053ac <_fseek_r+0x28c>
 32052b4:	a0c03d16 	blt	r20,r3,32053ac <_fseek_r+0x28c>
 32052b8:	38c5883a 	add	r2,r7,r3
 32052bc:	a0803b2e 	bgeu	r20,r2,32053ac <_fseek_r+0x28c>
 32052c0:	a0c5c83a 	sub	r2,r20,r3
 32052c4:	3887c83a 	sub	r3,r7,r2
 32052c8:	3085883a 	add	r2,r6,r2
 32052cc:	80800015 	stw	r2,0(r16)
 32052d0:	80c00115 	stw	r3,4(r16)
 32052d4:	28000526 	beq	r5,zero,32052ec <_fseek_r+0x1cc>
 32052d8:	80801004 	addi	r2,r16,64
 32052dc:	28800226 	beq	r5,r2,32052e8 <_fseek_r+0x1c8>
 32052e0:	9009883a 	mov	r4,r18
 32052e4:	3204e0c0 	call	3204e0c <_free_r>
 32052e8:	80000c15 	stw	zero,48(r16)
 32052ec:	8080030b 	ldhu	r2,12(r16)
 32052f0:	0009883a 	mov	r4,zero
 32052f4:	10bff7cc 	andi	r2,r2,65503
 32052f8:	8080030d 	sth	r2,12(r16)
 32052fc:	003fa706 	br	320519c <_fseek_r+0x7c>
 3205300:	9009883a 	mov	r4,r18
 3205304:	800b883a 	mov	r5,r16
 3205308:	32045f00 	call	32045f0 <_fflush_r>
 320530c:	8100030b 	ldhu	r4,12(r16)
 3205310:	2084000c 	andi	r2,r4,4096
 3205314:	10008726 	beq	r2,zero,3205534 <_fseek_r+0x414>
 3205318:	84401417 	ldw	r17,80(r16)
 320531c:	2080010c 	andi	r2,r4,4
 3205320:	1000171e 	bne	r2,zero,3205380 <_fseek_r+0x260>
 3205324:	2080020c 	andi	r2,r4,8
 3205328:	10003b26 	beq	r2,zero,3205418 <_fseek_r+0x2f8>
 320532c:	80800017 	ldw	r2,0(r16)
 3205330:	10003926 	beq	r2,zero,3205418 <_fseek_r+0x2f8>
 3205334:	81800417 	ldw	r6,16(r16)
 3205338:	1185c83a 	sub	r2,r2,r6
 320533c:	88a3883a 	add	r17,r17,r2
 3205340:	00001606 	br	320539c <_fseek_r+0x27c>
 3205344:	32048880 	call	3204888 <__sinit>
 3205348:	8080030b 	ldhu	r2,12(r16)
 320534c:	00c04204 	movi	r3,264
 3205350:	1080420c 	andi	r2,r2,264
 3205354:	10ff871e 	bne	r2,r3,3205174 <_fseek_r+0x54>
 3205358:	9009883a 	mov	r4,r18
 320535c:	800b883a 	mov	r5,r16
 3205360:	32045f00 	call	32045f0 <_fflush_r>
 3205364:	003f8306 	br	3205174 <_fseek_r+0x54>
 3205368:	81400c17 	ldw	r5,48(r16)
 320536c:	28004526 	beq	r5,zero,3205484 <_fseek_r+0x364>
 3205370:	8100030b 	ldhu	r4,12(r16)
 3205374:	80c00117 	ldw	r3,4(r16)
 3205378:	81c00f17 	ldw	r7,60(r16)
 320537c:	003fc506 	br	3205294 <_fseek_r+0x174>
 3205380:	80c00117 	ldw	r3,4(r16)
 3205384:	80800c17 	ldw	r2,48(r16)
 3205388:	88e3c83a 	sub	r17,r17,r3
 320538c:	10002226 	beq	r2,zero,3205418 <_fseek_r+0x2f8>
 3205390:	81c00f17 	ldw	r7,60(r16)
 3205394:	81800417 	ldw	r6,16(r16)
 3205398:	89e3c83a 	sub	r17,r17,r7
 320539c:	b46d883a 	add	r22,r22,r17
 32053a0:	0027883a 	mov	r19,zero
 32053a4:	05c00044 	movi	r23,1
 32053a8:	003f8b06 	br	32051d8 <_fseek_r+0xb8>
 32053ac:	80801317 	ldw	r2,76(r16)
 32053b0:	81400717 	ldw	r5,28(r16)
 32053b4:	9009883a 	mov	r4,r18
 32053b8:	0085c83a 	sub	r2,zero,r2
 32053bc:	a0a2703a 	and	r17,r20,r2
 32053c0:	880d883a 	mov	r6,r17
 32053c4:	000f883a 	mov	r7,zero
 32053c8:	a83ee83a 	callr	r21
 32053cc:	00ffffc4 	movi	r3,-1
 32053d0:	10ff8d26 	beq	r2,r3,3205208 <_fseek_r+0xe8>
 32053d4:	80800417 	ldw	r2,16(r16)
 32053d8:	81400c17 	ldw	r5,48(r16)
 32053dc:	80000115 	stw	zero,4(r16)
 32053e0:	80800015 	stw	r2,0(r16)
 32053e4:	28000526 	beq	r5,zero,32053fc <_fseek_r+0x2dc>
 32053e8:	80801004 	addi	r2,r16,64
 32053ec:	28800226 	beq	r5,r2,32053f8 <_fseek_r+0x2d8>
 32053f0:	9009883a 	mov	r4,r18
 32053f4:	3204e0c0 	call	3204e0c <_free_r>
 32053f8:	80000c15 	stw	zero,48(r16)
 32053fc:	8080030b 	ldhu	r2,12(r16)
 3205400:	a463c83a 	sub	r17,r20,r17
 3205404:	10bff7cc 	andi	r2,r2,65503
 3205408:	8080030d 	sth	r2,12(r16)
 320540c:	88000c1e 	bne	r17,zero,3205440 <_fseek_r+0x320>
 3205410:	0009883a 	mov	r4,zero
 3205414:	003f6106 	br	320519c <_fseek_r+0x7c>
 3205418:	81800417 	ldw	r6,16(r16)
 320541c:	003fdf06 	br	320539c <_fseek_r+0x27c>
 3205420:	8140038f 	ldh	r5,14(r16)
 3205424:	9009883a 	mov	r4,r18
 3205428:	d80d883a 	mov	r6,sp
 320542c:	32055800 	call	3205580 <_fstat_r>
 3205430:	103f751e 	bne	r2,zero,3205208 <_fseek_r+0xe8>
 3205434:	d8800417 	ldw	r2,16(sp)
 3205438:	b0a9883a 	add	r20,r22,r2
 320543c:	003f8906 	br	3205264 <_fseek_r+0x144>
 3205440:	9009883a 	mov	r4,r18
 3205444:	800b883a 	mov	r5,r16
 3205448:	320740c0 	call	320740c <__srefill_r>
 320544c:	103f6e1e 	bne	r2,zero,3205208 <_fseek_r+0xe8>
 3205450:	80c00117 	ldw	r3,4(r16)
 3205454:	1c7f6c36 	bltu	r3,r17,3205208 <_fseek_r+0xe8>
 3205458:	80800017 	ldw	r2,0(r16)
 320545c:	1c47c83a 	sub	r3,r3,r17
 3205460:	0009883a 	mov	r4,zero
 3205464:	1445883a 	add	r2,r2,r17
 3205468:	80c00115 	stw	r3,4(r16)
 320546c:	80800015 	stw	r2,0(r16)
 3205470:	003f4a06 	br	320519c <_fseek_r+0x7c>
 3205474:	9009883a 	mov	r4,r18
 3205478:	800b883a 	mov	r5,r16
 320547c:	3205e140 	call	3205e14 <__smakebuf_r>
 3205480:	003f5606 	br	32051dc <_fseek_r+0xbc>
 3205484:	8100030b 	ldhu	r4,12(r16)
 3205488:	80c00117 	ldw	r3,4(r16)
 320548c:	80800017 	ldw	r2,0(r16)
 3205490:	81800417 	ldw	r6,16(r16)
 3205494:	1185c83a 	sub	r2,r2,r6
 3205498:	10cf883a 	add	r7,r2,r3
 320549c:	8887c83a 	sub	r3,r17,r2
 32054a0:	003f8206 	br	32052ac <_fseek_r+0x18c>
 32054a4:	81400717 	ldw	r5,28(r16)
 32054a8:	b00d883a 	mov	r6,r22
 32054ac:	980f883a 	mov	r7,r19
 32054b0:	9009883a 	mov	r4,r18
 32054b4:	a83ee83a 	callr	r21
 32054b8:	00ffffc4 	movi	r3,-1
 32054bc:	10ff5626 	beq	r2,r3,3205218 <_fseek_r+0xf8>
 32054c0:	81400c17 	ldw	r5,48(r16)
 32054c4:	28000526 	beq	r5,zero,32054dc <_fseek_r+0x3bc>
 32054c8:	80801004 	addi	r2,r16,64
 32054cc:	28800226 	beq	r5,r2,32054d8 <_fseek_r+0x3b8>
 32054d0:	9009883a 	mov	r4,r18
 32054d4:	3204e0c0 	call	3204e0c <_free_r>
 32054d8:	80000c15 	stw	zero,48(r16)
 32054dc:	8080030b 	ldhu	r2,12(r16)
 32054e0:	80c00417 	ldw	r3,16(r16)
 32054e4:	0009883a 	mov	r4,zero
 32054e8:	10bdf7cc 	andi	r2,r2,63455
 32054ec:	8080030d 	sth	r2,12(r16)
 32054f0:	80c00015 	stw	r3,0(r16)
 32054f4:	80000115 	stw	zero,4(r16)
 32054f8:	003f2806 	br	320519c <_fseek_r+0x7c>
 32054fc:	81400717 	ldw	r5,28(r16)
 3205500:	000d883a 	mov	r6,zero
 3205504:	9009883a 	mov	r4,r18
 3205508:	01c00044 	movi	r7,1
 320550c:	a83ee83a 	callr	r21
 3205510:	100d883a 	mov	r6,r2
 3205514:	00bfffc4 	movi	r2,-1
 3205518:	30bf3b26 	beq	r6,r2,3205208 <_fseek_r+0xe8>
 320551c:	8100030b 	ldhu	r4,12(r16)
 3205520:	003f5606 	br	320527c <_fseek_r+0x15c>
 3205524:	00800744 	movi	r2,29
 3205528:	013fffc4 	movi	r4,-1
 320552c:	90800015 	stw	r2,0(r18)
 3205530:	003f1a06 	br	320519c <_fseek_r+0x7c>
 3205534:	81400717 	ldw	r5,28(r16)
 3205538:	980f883a 	mov	r7,r19
 320553c:	9009883a 	mov	r4,r18
 3205540:	000d883a 	mov	r6,zero
 3205544:	a83ee83a 	callr	r21
 3205548:	1023883a 	mov	r17,r2
 320554c:	00bfffc4 	movi	r2,-1
 3205550:	88bf3126 	beq	r17,r2,3205218 <_fseek_r+0xf8>
 3205554:	8100030b 	ldhu	r4,12(r16)
 3205558:	003f7006 	br	320531c <_fseek_r+0x1fc>

0320555c <fseek>:
 320555c:	0080c974 	movhi	r2,805
 3205560:	10897804 	addi	r2,r2,9696
 3205564:	2013883a 	mov	r9,r4
 3205568:	11000017 	ldw	r4,0(r2)
 320556c:	2805883a 	mov	r2,r5
 3205570:	300f883a 	mov	r7,r6
 3205574:	480b883a 	mov	r5,r9
 3205578:	100d883a 	mov	r6,r2
 320557c:	32051201 	jmpi	3205120 <_fseek_r>

03205580 <_fstat_r>:
 3205580:	defffd04 	addi	sp,sp,-12
 3205584:	dc000015 	stw	r16,0(sp)
 3205588:	0400c974 	movhi	r16,805
 320558c:	84120d04 	addi	r16,r16,18484
 3205590:	dc400115 	stw	r17,4(sp)
 3205594:	80000015 	stw	zero,0(r16)
 3205598:	2023883a 	mov	r17,r4
 320559c:	2809883a 	mov	r4,r5
 32055a0:	300b883a 	mov	r5,r6
 32055a4:	dfc00215 	stw	ra,8(sp)
 32055a8:	321462c0 	call	321462c <fstat>
 32055ac:	1007883a 	mov	r3,r2
 32055b0:	00bfffc4 	movi	r2,-1
 32055b4:	18800626 	beq	r3,r2,32055d0 <_fstat_r+0x50>
 32055b8:	1805883a 	mov	r2,r3
 32055bc:	dfc00217 	ldw	ra,8(sp)
 32055c0:	dc400117 	ldw	r17,4(sp)
 32055c4:	dc000017 	ldw	r16,0(sp)
 32055c8:	dec00304 	addi	sp,sp,12
 32055cc:	f800283a 	ret
 32055d0:	80800017 	ldw	r2,0(r16)
 32055d4:	103ff826 	beq	r2,zero,32055b8 <_fstat_r+0x38>
 32055d8:	88800015 	stw	r2,0(r17)
 32055dc:	1805883a 	mov	r2,r3
 32055e0:	dfc00217 	ldw	ra,8(sp)
 32055e4:	dc400117 	ldw	r17,4(sp)
 32055e8:	dc000017 	ldw	r16,0(sp)
 32055ec:	dec00304 	addi	sp,sp,12
 32055f0:	f800283a 	ret

032055f4 <__sfvwrite_r>:
 32055f4:	30800217 	ldw	r2,8(r6)
 32055f8:	defff504 	addi	sp,sp,-44
 32055fc:	df000915 	stw	fp,36(sp)
 3205600:	dd800715 	stw	r22,28(sp)
 3205604:	dc800315 	stw	r18,12(sp)
 3205608:	dfc00a15 	stw	ra,40(sp)
 320560c:	ddc00815 	stw	r23,32(sp)
 3205610:	dd400615 	stw	r21,24(sp)
 3205614:	dd000515 	stw	r20,20(sp)
 3205618:	dcc00415 	stw	r19,16(sp)
 320561c:	dc400215 	stw	r17,8(sp)
 3205620:	dc000115 	stw	r16,4(sp)
 3205624:	302d883a 	mov	r22,r6
 3205628:	2039883a 	mov	fp,r4
 320562c:	2825883a 	mov	r18,r5
 3205630:	10001c26 	beq	r2,zero,32056a4 <__sfvwrite_r+0xb0>
 3205634:	29c0030b 	ldhu	r7,12(r5)
 3205638:	3880020c 	andi	r2,r7,8
 320563c:	10002726 	beq	r2,zero,32056dc <__sfvwrite_r+0xe8>
 3205640:	28800417 	ldw	r2,16(r5)
 3205644:	10002526 	beq	r2,zero,32056dc <__sfvwrite_r+0xe8>
 3205648:	3880008c 	andi	r2,r7,2
 320564c:	b5400017 	ldw	r21,0(r22)
 3205650:	10002826 	beq	r2,zero,32056f4 <__sfvwrite_r+0x100>
 3205654:	0021883a 	mov	r16,zero
 3205658:	0023883a 	mov	r17,zero
 320565c:	880d883a 	mov	r6,r17
 3205660:	e009883a 	mov	r4,fp
 3205664:	00810004 	movi	r2,1024
 3205668:	80006e26 	beq	r16,zero,3205824 <__sfvwrite_r+0x230>
 320566c:	800f883a 	mov	r7,r16
 3205670:	91400717 	ldw	r5,28(r18)
 3205674:	1400012e 	bgeu	r2,r16,320567c <__sfvwrite_r+0x88>
 3205678:	100f883a 	mov	r7,r2
 320567c:	90c00917 	ldw	r3,36(r18)
 3205680:	183ee83a 	callr	r3
 3205684:	1007883a 	mov	r3,r2
 3205688:	80a1c83a 	sub	r16,r16,r2
 320568c:	88a3883a 	add	r17,r17,r2
 3205690:	00806d0e 	bge	zero,r2,3205848 <__sfvwrite_r+0x254>
 3205694:	b0800217 	ldw	r2,8(r22)
 3205698:	10c5c83a 	sub	r2,r2,r3
 320569c:	b0800215 	stw	r2,8(r22)
 32056a0:	103fee1e 	bne	r2,zero,320565c <__sfvwrite_r+0x68>
 32056a4:	0009883a 	mov	r4,zero
 32056a8:	2005883a 	mov	r2,r4
 32056ac:	dfc00a17 	ldw	ra,40(sp)
 32056b0:	df000917 	ldw	fp,36(sp)
 32056b4:	ddc00817 	ldw	r23,32(sp)
 32056b8:	dd800717 	ldw	r22,28(sp)
 32056bc:	dd400617 	ldw	r21,24(sp)
 32056c0:	dd000517 	ldw	r20,20(sp)
 32056c4:	dcc00417 	ldw	r19,16(sp)
 32056c8:	dc800317 	ldw	r18,12(sp)
 32056cc:	dc400217 	ldw	r17,8(sp)
 32056d0:	dc000117 	ldw	r16,4(sp)
 32056d4:	dec00b04 	addi	sp,sp,44
 32056d8:	f800283a 	ret
 32056dc:	320ba2c0 	call	320ba2c <__swsetup_r>
 32056e0:	1000e41e 	bne	r2,zero,3205a74 <__sfvwrite_r+0x480>
 32056e4:	91c0030b 	ldhu	r7,12(r18)
 32056e8:	b5400017 	ldw	r21,0(r22)
 32056ec:	3880008c 	andi	r2,r7,2
 32056f0:	103fd81e 	bne	r2,zero,3205654 <__sfvwrite_r+0x60>
 32056f4:	3880004c 	andi	r2,r7,1
 32056f8:	1005003a 	cmpeq	r2,r2,zero
 32056fc:	10005726 	beq	r2,zero,320585c <__sfvwrite_r+0x268>
 3205700:	0029883a 	mov	r20,zero
 3205704:	002f883a 	mov	r23,zero
 3205708:	a0004226 	beq	r20,zero,3205814 <__sfvwrite_r+0x220>
 320570c:	3880800c 	andi	r2,r7,512
 3205710:	94000217 	ldw	r16,8(r18)
 3205714:	10008b26 	beq	r2,zero,3205944 <__sfvwrite_r+0x350>
 3205718:	800d883a 	mov	r6,r16
 320571c:	a400a536 	bltu	r20,r16,32059b4 <__sfvwrite_r+0x3c0>
 3205720:	3881200c 	andi	r2,r7,1152
 3205724:	10002726 	beq	r2,zero,32057c4 <__sfvwrite_r+0x1d0>
 3205728:	90800517 	ldw	r2,20(r18)
 320572c:	92000417 	ldw	r8,16(r18)
 3205730:	91400017 	ldw	r5,0(r18)
 3205734:	1087883a 	add	r3,r2,r2
 3205738:	1887883a 	add	r3,r3,r2
 320573c:	1808d7fa 	srli	r4,r3,31
 3205740:	2a21c83a 	sub	r16,r5,r8
 3205744:	80800044 	addi	r2,r16,1
 3205748:	20c9883a 	add	r4,r4,r3
 320574c:	2027d07a 	srai	r19,r4,1
 3205750:	a085883a 	add	r2,r20,r2
 3205754:	980d883a 	mov	r6,r19
 3205758:	9880022e 	bgeu	r19,r2,3205764 <__sfvwrite_r+0x170>
 320575c:	1027883a 	mov	r19,r2
 3205760:	100d883a 	mov	r6,r2
 3205764:	3881000c 	andi	r2,r7,1024
 3205768:	1000b826 	beq	r2,zero,3205a4c <__sfvwrite_r+0x458>
 320576c:	300b883a 	mov	r5,r6
 3205770:	e009883a 	mov	r4,fp
 3205774:	3205fa80 	call	3205fa8 <_malloc_r>
 3205778:	10003126 	beq	r2,zero,3205840 <__sfvwrite_r+0x24c>
 320577c:	91400417 	ldw	r5,16(r18)
 3205780:	1009883a 	mov	r4,r2
 3205784:	800d883a 	mov	r6,r16
 3205788:	1023883a 	mov	r17,r2
 320578c:	32067cc0 	call	32067cc <memcpy>
 3205790:	90c0030b 	ldhu	r3,12(r18)
 3205794:	00beffc4 	movi	r2,-1025
 3205798:	1886703a 	and	r3,r3,r2
 320579c:	18c02014 	ori	r3,r3,128
 32057a0:	90c0030d 	sth	r3,12(r18)
 32057a4:	9c07c83a 	sub	r3,r19,r16
 32057a8:	8c05883a 	add	r2,r17,r16
 32057ac:	a00d883a 	mov	r6,r20
 32057b0:	a021883a 	mov	r16,r20
 32057b4:	90800015 	stw	r2,0(r18)
 32057b8:	90c00215 	stw	r3,8(r18)
 32057bc:	94400415 	stw	r17,16(r18)
 32057c0:	94c00515 	stw	r19,20(r18)
 32057c4:	91000017 	ldw	r4,0(r18)
 32057c8:	b80b883a 	mov	r5,r23
 32057cc:	a023883a 	mov	r17,r20
 32057d0:	320686c0 	call	320686c <memmove>
 32057d4:	90c00217 	ldw	r3,8(r18)
 32057d8:	90800017 	ldw	r2,0(r18)
 32057dc:	a027883a 	mov	r19,r20
 32057e0:	1c07c83a 	sub	r3,r3,r16
 32057e4:	1405883a 	add	r2,r2,r16
 32057e8:	90c00215 	stw	r3,8(r18)
 32057ec:	a021883a 	mov	r16,r20
 32057f0:	90800015 	stw	r2,0(r18)
 32057f4:	b0800217 	ldw	r2,8(r22)
 32057f8:	1405c83a 	sub	r2,r2,r16
 32057fc:	b0800215 	stw	r2,8(r22)
 3205800:	103fa826 	beq	r2,zero,32056a4 <__sfvwrite_r+0xb0>
 3205804:	a469c83a 	sub	r20,r20,r17
 3205808:	91c0030b 	ldhu	r7,12(r18)
 320580c:	bcef883a 	add	r23,r23,r19
 3205810:	a03fbe1e 	bne	r20,zero,320570c <__sfvwrite_r+0x118>
 3205814:	adc00017 	ldw	r23,0(r21)
 3205818:	ad000117 	ldw	r20,4(r21)
 320581c:	ad400204 	addi	r21,r21,8
 3205820:	003fb906 	br	3205708 <__sfvwrite_r+0x114>
 3205824:	ac400017 	ldw	r17,0(r21)
 3205828:	ac000117 	ldw	r16,4(r21)
 320582c:	ad400204 	addi	r21,r21,8
 3205830:	003f8a06 	br	320565c <__sfvwrite_r+0x68>
 3205834:	91400417 	ldw	r5,16(r18)
 3205838:	e009883a 	mov	r4,fp
 320583c:	3204e0c0 	call	3204e0c <_free_r>
 3205840:	00800304 	movi	r2,12
 3205844:	e0800015 	stw	r2,0(fp)
 3205848:	9080030b 	ldhu	r2,12(r18)
 320584c:	013fffc4 	movi	r4,-1
 3205850:	10801014 	ori	r2,r2,64
 3205854:	9080030d 	sth	r2,12(r18)
 3205858:	003f9306 	br	32056a8 <__sfvwrite_r+0xb4>
 320585c:	0027883a 	mov	r19,zero
 3205860:	002f883a 	mov	r23,zero
 3205864:	d8000015 	stw	zero,0(sp)
 3205868:	0029883a 	mov	r20,zero
 320586c:	98001e26 	beq	r19,zero,32058e8 <__sfvwrite_r+0x2f4>
 3205870:	d8c00017 	ldw	r3,0(sp)
 3205874:	1804c03a 	cmpne	r2,r3,zero
 3205878:	10005e26 	beq	r2,zero,32059f4 <__sfvwrite_r+0x400>
 320587c:	9821883a 	mov	r16,r19
 3205880:	a4c0012e 	bgeu	r20,r19,3205888 <__sfvwrite_r+0x294>
 3205884:	a021883a 	mov	r16,r20
 3205888:	91000017 	ldw	r4,0(r18)
 320588c:	90800417 	ldw	r2,16(r18)
 3205890:	91800217 	ldw	r6,8(r18)
 3205894:	91c00517 	ldw	r7,20(r18)
 3205898:	1100022e 	bgeu	r2,r4,32058a4 <__sfvwrite_r+0x2b0>
 320589c:	31e3883a 	add	r17,r6,r7
 32058a0:	8c001616 	blt	r17,r16,32058fc <__sfvwrite_r+0x308>
 32058a4:	81c03816 	blt	r16,r7,3205988 <__sfvwrite_r+0x394>
 32058a8:	90c00917 	ldw	r3,36(r18)
 32058ac:	91400717 	ldw	r5,28(r18)
 32058b0:	e009883a 	mov	r4,fp
 32058b4:	b80d883a 	mov	r6,r23
 32058b8:	183ee83a 	callr	r3
 32058bc:	1023883a 	mov	r17,r2
 32058c0:	00bfe10e 	bge	zero,r2,3205848 <__sfvwrite_r+0x254>
 32058c4:	a469c83a 	sub	r20,r20,r17
 32058c8:	a0001826 	beq	r20,zero,320592c <__sfvwrite_r+0x338>
 32058cc:	b0800217 	ldw	r2,8(r22)
 32058d0:	1445c83a 	sub	r2,r2,r17
 32058d4:	b0800215 	stw	r2,8(r22)
 32058d8:	103f7226 	beq	r2,zero,32056a4 <__sfvwrite_r+0xb0>
 32058dc:	9c67c83a 	sub	r19,r19,r17
 32058e0:	bc6f883a 	add	r23,r23,r17
 32058e4:	983fe21e 	bne	r19,zero,3205870 <__sfvwrite_r+0x27c>
 32058e8:	adc00017 	ldw	r23,0(r21)
 32058ec:	acc00117 	ldw	r19,4(r21)
 32058f0:	ad400204 	addi	r21,r21,8
 32058f4:	d8000015 	stw	zero,0(sp)
 32058f8:	003fdc06 	br	320586c <__sfvwrite_r+0x278>
 32058fc:	b80b883a 	mov	r5,r23
 3205900:	880d883a 	mov	r6,r17
 3205904:	320686c0 	call	320686c <memmove>
 3205908:	90c00017 	ldw	r3,0(r18)
 320590c:	e009883a 	mov	r4,fp
 3205910:	900b883a 	mov	r5,r18
 3205914:	1c47883a 	add	r3,r3,r17
 3205918:	90c00015 	stw	r3,0(r18)
 320591c:	32045f00 	call	32045f0 <_fflush_r>
 3205920:	103fc91e 	bne	r2,zero,3205848 <__sfvwrite_r+0x254>
 3205924:	a469c83a 	sub	r20,r20,r17
 3205928:	a03fe81e 	bne	r20,zero,32058cc <__sfvwrite_r+0x2d8>
 320592c:	e009883a 	mov	r4,fp
 3205930:	900b883a 	mov	r5,r18
 3205934:	32045f00 	call	32045f0 <_fflush_r>
 3205938:	103fc31e 	bne	r2,zero,3205848 <__sfvwrite_r+0x254>
 320593c:	d8000015 	stw	zero,0(sp)
 3205940:	003fe206 	br	32058cc <__sfvwrite_r+0x2d8>
 3205944:	91000017 	ldw	r4,0(r18)
 3205948:	90800417 	ldw	r2,16(r18)
 320594c:	1100022e 	bgeu	r2,r4,3205958 <__sfvwrite_r+0x364>
 3205950:	8023883a 	mov	r17,r16
 3205954:	85003136 	bltu	r16,r20,3205a1c <__sfvwrite_r+0x428>
 3205958:	91c00517 	ldw	r7,20(r18)
 320595c:	a1c01836 	bltu	r20,r7,32059c0 <__sfvwrite_r+0x3cc>
 3205960:	90c00917 	ldw	r3,36(r18)
 3205964:	91400717 	ldw	r5,28(r18)
 3205968:	e009883a 	mov	r4,fp
 320596c:	b80d883a 	mov	r6,r23
 3205970:	183ee83a 	callr	r3
 3205974:	1021883a 	mov	r16,r2
 3205978:	00bfb30e 	bge	zero,r2,3205848 <__sfvwrite_r+0x254>
 320597c:	1023883a 	mov	r17,r2
 3205980:	1027883a 	mov	r19,r2
 3205984:	003f9b06 	br	32057f4 <__sfvwrite_r+0x200>
 3205988:	b80b883a 	mov	r5,r23
 320598c:	800d883a 	mov	r6,r16
 3205990:	320686c0 	call	320686c <memmove>
 3205994:	90c00217 	ldw	r3,8(r18)
 3205998:	90800017 	ldw	r2,0(r18)
 320599c:	8023883a 	mov	r17,r16
 32059a0:	1c07c83a 	sub	r3,r3,r16
 32059a4:	1405883a 	add	r2,r2,r16
 32059a8:	90c00215 	stw	r3,8(r18)
 32059ac:	90800015 	stw	r2,0(r18)
 32059b0:	003fc406 	br	32058c4 <__sfvwrite_r+0x2d0>
 32059b4:	a00d883a 	mov	r6,r20
 32059b8:	a021883a 	mov	r16,r20
 32059bc:	003f8106 	br	32057c4 <__sfvwrite_r+0x1d0>
 32059c0:	b80b883a 	mov	r5,r23
 32059c4:	a00d883a 	mov	r6,r20
 32059c8:	320686c0 	call	320686c <memmove>
 32059cc:	90c00217 	ldw	r3,8(r18)
 32059d0:	90800017 	ldw	r2,0(r18)
 32059d4:	a021883a 	mov	r16,r20
 32059d8:	1d07c83a 	sub	r3,r3,r20
 32059dc:	1505883a 	add	r2,r2,r20
 32059e0:	a023883a 	mov	r17,r20
 32059e4:	a027883a 	mov	r19,r20
 32059e8:	90c00215 	stw	r3,8(r18)
 32059ec:	90800015 	stw	r2,0(r18)
 32059f0:	003f8006 	br	32057f4 <__sfvwrite_r+0x200>
 32059f4:	b809883a 	mov	r4,r23
 32059f8:	01400284 	movi	r5,10
 32059fc:	980d883a 	mov	r6,r19
 3205a00:	32066e80 	call	32066e8 <memchr>
 3205a04:	10001726 	beq	r2,zero,3205a64 <__sfvwrite_r+0x470>
 3205a08:	15c5c83a 	sub	r2,r2,r23
 3205a0c:	15000044 	addi	r20,r2,1
 3205a10:	00800044 	movi	r2,1
 3205a14:	d8800015 	stw	r2,0(sp)
 3205a18:	003f9806 	br	320587c <__sfvwrite_r+0x288>
 3205a1c:	b80b883a 	mov	r5,r23
 3205a20:	800d883a 	mov	r6,r16
 3205a24:	320686c0 	call	320686c <memmove>
 3205a28:	90c00017 	ldw	r3,0(r18)
 3205a2c:	e009883a 	mov	r4,fp
 3205a30:	900b883a 	mov	r5,r18
 3205a34:	1c07883a 	add	r3,r3,r16
 3205a38:	90c00015 	stw	r3,0(r18)
 3205a3c:	8027883a 	mov	r19,r16
 3205a40:	32045f00 	call	32045f0 <_fflush_r>
 3205a44:	103f6b26 	beq	r2,zero,32057f4 <__sfvwrite_r+0x200>
 3205a48:	003f7f06 	br	3205848 <__sfvwrite_r+0x254>
 3205a4c:	400b883a 	mov	r5,r8
 3205a50:	e009883a 	mov	r4,fp
 3205a54:	3206e180 	call	3206e18 <_realloc_r>
 3205a58:	103f7626 	beq	r2,zero,3205834 <__sfvwrite_r+0x240>
 3205a5c:	1023883a 	mov	r17,r2
 3205a60:	003f5006 	br	32057a4 <__sfvwrite_r+0x1b0>
 3205a64:	00c00044 	movi	r3,1
 3205a68:	9d000044 	addi	r20,r19,1
 3205a6c:	d8c00015 	stw	r3,0(sp)
 3205a70:	003f8206 	br	320587c <__sfvwrite_r+0x288>
 3205a74:	9080030b 	ldhu	r2,12(r18)
 3205a78:	00c00244 	movi	r3,9
 3205a7c:	013fffc4 	movi	r4,-1
 3205a80:	10801014 	ori	r2,r2,64
 3205a84:	9080030d 	sth	r2,12(r18)
 3205a88:	e0c00015 	stw	r3,0(fp)
 3205a8c:	003f0606 	br	32056a8 <__sfvwrite_r+0xb4>

03205a90 <_fwalk_reent>:
 3205a90:	defff704 	addi	sp,sp,-36
 3205a94:	dcc00315 	stw	r19,12(sp)
 3205a98:	24c0b804 	addi	r19,r4,736
 3205a9c:	dd800615 	stw	r22,24(sp)
 3205aa0:	dd400515 	stw	r21,20(sp)
 3205aa4:	dfc00815 	stw	ra,32(sp)
 3205aa8:	ddc00715 	stw	r23,28(sp)
 3205aac:	dd000415 	stw	r20,16(sp)
 3205ab0:	dc800215 	stw	r18,8(sp)
 3205ab4:	dc400115 	stw	r17,4(sp)
 3205ab8:	dc000015 	stw	r16,0(sp)
 3205abc:	202b883a 	mov	r21,r4
 3205ac0:	282d883a 	mov	r22,r5
 3205ac4:	32048780 	call	3204878 <__sfp_lock_acquire>
 3205ac8:	98002126 	beq	r19,zero,3205b50 <_fwalk_reent+0xc0>
 3205acc:	002f883a 	mov	r23,zero
 3205ad0:	9c800117 	ldw	r18,4(r19)
 3205ad4:	9c000217 	ldw	r16,8(r19)
 3205ad8:	90bfffc4 	addi	r2,r18,-1
 3205adc:	10000d16 	blt	r2,zero,3205b14 <_fwalk_reent+0x84>
 3205ae0:	0023883a 	mov	r17,zero
 3205ae4:	053fffc4 	movi	r20,-1
 3205ae8:	8080030f 	ldh	r2,12(r16)
 3205aec:	8c400044 	addi	r17,r17,1
 3205af0:	10000626 	beq	r2,zero,3205b0c <_fwalk_reent+0x7c>
 3205af4:	8080038f 	ldh	r2,14(r16)
 3205af8:	800b883a 	mov	r5,r16
 3205afc:	a809883a 	mov	r4,r21
 3205b00:	15000226 	beq	r2,r20,3205b0c <_fwalk_reent+0x7c>
 3205b04:	b03ee83a 	callr	r22
 3205b08:	b8aeb03a 	or	r23,r23,r2
 3205b0c:	84001704 	addi	r16,r16,92
 3205b10:	947ff51e 	bne	r18,r17,3205ae8 <_fwalk_reent+0x58>
 3205b14:	9cc00017 	ldw	r19,0(r19)
 3205b18:	983fed1e 	bne	r19,zero,3205ad0 <_fwalk_reent+0x40>
 3205b1c:	320487c0 	call	320487c <__sfp_lock_release>
 3205b20:	b805883a 	mov	r2,r23
 3205b24:	dfc00817 	ldw	ra,32(sp)
 3205b28:	ddc00717 	ldw	r23,28(sp)
 3205b2c:	dd800617 	ldw	r22,24(sp)
 3205b30:	dd400517 	ldw	r21,20(sp)
 3205b34:	dd000417 	ldw	r20,16(sp)
 3205b38:	dcc00317 	ldw	r19,12(sp)
 3205b3c:	dc800217 	ldw	r18,8(sp)
 3205b40:	dc400117 	ldw	r17,4(sp)
 3205b44:	dc000017 	ldw	r16,0(sp)
 3205b48:	dec00904 	addi	sp,sp,36
 3205b4c:	f800283a 	ret
 3205b50:	002f883a 	mov	r23,zero
 3205b54:	003ff106 	br	3205b1c <_fwalk_reent+0x8c>

03205b58 <_fwalk>:
 3205b58:	defff804 	addi	sp,sp,-32
 3205b5c:	dcc00315 	stw	r19,12(sp)
 3205b60:	24c0b804 	addi	r19,r4,736
 3205b64:	dd400515 	stw	r21,20(sp)
 3205b68:	dfc00715 	stw	ra,28(sp)
 3205b6c:	dd800615 	stw	r22,24(sp)
 3205b70:	dd000415 	stw	r20,16(sp)
 3205b74:	dc800215 	stw	r18,8(sp)
 3205b78:	dc400115 	stw	r17,4(sp)
 3205b7c:	dc000015 	stw	r16,0(sp)
 3205b80:	282b883a 	mov	r21,r5
 3205b84:	32048780 	call	3204878 <__sfp_lock_acquire>
 3205b88:	98001f26 	beq	r19,zero,3205c08 <_fwalk+0xb0>
 3205b8c:	002d883a 	mov	r22,zero
 3205b90:	9c800117 	ldw	r18,4(r19)
 3205b94:	9c000217 	ldw	r16,8(r19)
 3205b98:	90bfffc4 	addi	r2,r18,-1
 3205b9c:	10000c16 	blt	r2,zero,3205bd0 <_fwalk+0x78>
 3205ba0:	0023883a 	mov	r17,zero
 3205ba4:	053fffc4 	movi	r20,-1
 3205ba8:	8080030f 	ldh	r2,12(r16)
 3205bac:	8c400044 	addi	r17,r17,1
 3205bb0:	10000526 	beq	r2,zero,3205bc8 <_fwalk+0x70>
 3205bb4:	8080038f 	ldh	r2,14(r16)
 3205bb8:	8009883a 	mov	r4,r16
 3205bbc:	15000226 	beq	r2,r20,3205bc8 <_fwalk+0x70>
 3205bc0:	a83ee83a 	callr	r21
 3205bc4:	b0acb03a 	or	r22,r22,r2
 3205bc8:	84001704 	addi	r16,r16,92
 3205bcc:	947ff61e 	bne	r18,r17,3205ba8 <_fwalk+0x50>
 3205bd0:	9cc00017 	ldw	r19,0(r19)
 3205bd4:	983fee1e 	bne	r19,zero,3205b90 <_fwalk+0x38>
 3205bd8:	320487c0 	call	320487c <__sfp_lock_release>
 3205bdc:	b005883a 	mov	r2,r22
 3205be0:	dfc00717 	ldw	ra,28(sp)
 3205be4:	dd800617 	ldw	r22,24(sp)
 3205be8:	dd400517 	ldw	r21,20(sp)
 3205bec:	dd000417 	ldw	r20,16(sp)
 3205bf0:	dcc00317 	ldw	r19,12(sp)
 3205bf4:	dc800217 	ldw	r18,8(sp)
 3205bf8:	dc400117 	ldw	r17,4(sp)
 3205bfc:	dc000017 	ldw	r16,0(sp)
 3205c00:	dec00804 	addi	sp,sp,32
 3205c04:	f800283a 	ret
 3205c08:	002d883a 	mov	r22,zero
 3205c0c:	003ff206 	br	3205bd8 <_fwalk+0x80>

03205c10 <_fwrite_r>:
 3205c10:	defff604 	addi	sp,sp,-40
 3205c14:	dc400615 	stw	r17,24(sp)
 3205c18:	39a3383a 	mul	r17,r7,r6
 3205c1c:	00800044 	movi	r2,1
 3205c20:	dcc00815 	stw	r19,32(sp)
 3205c24:	dc800715 	stw	r18,28(sp)
 3205c28:	dc000515 	stw	r16,20(sp)
 3205c2c:	dfc00915 	stw	ra,36(sp)
 3205c30:	3825883a 	mov	r18,r7
 3205c34:	3027883a 	mov	r19,r6
 3205c38:	2021883a 	mov	r16,r4
 3205c3c:	d9400015 	stw	r5,0(sp)
 3205c40:	d8800315 	stw	r2,12(sp)
 3205c44:	dc400115 	stw	r17,4(sp)
 3205c48:	dc400415 	stw	r17,16(sp)
 3205c4c:	dec00215 	stw	sp,8(sp)
 3205c50:	20000226 	beq	r4,zero,3205c5c <_fwrite_r+0x4c>
 3205c54:	20800e17 	ldw	r2,56(r4)
 3205c58:	10001226 	beq	r2,zero,3205ca4 <_fwrite_r+0x94>
 3205c5c:	d9400a17 	ldw	r5,40(sp)
 3205c60:	8009883a 	mov	r4,r16
 3205c64:	d9800204 	addi	r6,sp,8
 3205c68:	32055f40 	call	32055f4 <__sfvwrite_r>
 3205c6c:	980b883a 	mov	r5,r19
 3205c70:	10000426 	beq	r2,zero,3205c84 <_fwrite_r+0x74>
 3205c74:	d9000417 	ldw	r4,16(sp)
 3205c78:	8909c83a 	sub	r4,r17,r4
 3205c7c:	32044bc0 	call	32044bc <__udivsi3>
 3205c80:	1025883a 	mov	r18,r2
 3205c84:	9005883a 	mov	r2,r18
 3205c88:	dfc00917 	ldw	ra,36(sp)
 3205c8c:	dcc00817 	ldw	r19,32(sp)
 3205c90:	dc800717 	ldw	r18,28(sp)
 3205c94:	dc400617 	ldw	r17,24(sp)
 3205c98:	dc000517 	ldw	r16,20(sp)
 3205c9c:	dec00a04 	addi	sp,sp,40
 3205ca0:	f800283a 	ret
 3205ca4:	32048880 	call	3204888 <__sinit>
 3205ca8:	003fec06 	br	3205c5c <_fwrite_r+0x4c>

03205cac <fwrite>:
 3205cac:	0080c974 	movhi	r2,805
 3205cb0:	10897804 	addi	r2,r2,9696
 3205cb4:	2017883a 	mov	r11,r4
 3205cb8:	11000017 	ldw	r4,0(r2)
 3205cbc:	defffe04 	addi	sp,sp,-8
 3205cc0:	3013883a 	mov	r9,r6
 3205cc4:	2805883a 	mov	r2,r5
 3205cc8:	d9c00015 	stw	r7,0(sp)
 3205ccc:	580b883a 	mov	r5,r11
 3205cd0:	100d883a 	mov	r6,r2
 3205cd4:	480f883a 	mov	r7,r9
 3205cd8:	dfc00115 	stw	ra,4(sp)
 3205cdc:	3205c100 	call	3205c10 <_fwrite_r>
 3205ce0:	dfc00117 	ldw	ra,4(sp)
 3205ce4:	dec00204 	addi	sp,sp,8
 3205ce8:	f800283a 	ret

03205cec <getc>:
 3205cec:	defffd04 	addi	sp,sp,-12
 3205cf0:	dc400115 	stw	r17,4(sp)
 3205cf4:	0440c974 	movhi	r17,805
 3205cf8:	8c497804 	addi	r17,r17,9696
 3205cfc:	88c00017 	ldw	r3,0(r17)
 3205d00:	dc000015 	stw	r16,0(sp)
 3205d04:	dfc00215 	stw	ra,8(sp)
 3205d08:	2021883a 	mov	r16,r4
 3205d0c:	18000326 	beq	r3,zero,3205d1c <getc+0x30>
 3205d10:	18800e17 	ldw	r2,56(r3)
 3205d14:	1809883a 	mov	r4,r3
 3205d18:	10000e26 	beq	r2,zero,3205d54 <getc+0x68>
 3205d1c:	80800117 	ldw	r2,4(r16)
 3205d20:	800b883a 	mov	r5,r16
 3205d24:	10bfffc4 	addi	r2,r2,-1
 3205d28:	80800115 	stw	r2,4(r16)
 3205d2c:	10000f16 	blt	r2,zero,3205d6c <getc+0x80>
 3205d30:	80c00017 	ldw	r3,0(r16)
 3205d34:	18800003 	ldbu	r2,0(r3)
 3205d38:	18c00044 	addi	r3,r3,1
 3205d3c:	80c00015 	stw	r3,0(r16)
 3205d40:	dfc00217 	ldw	ra,8(sp)
 3205d44:	dc400117 	ldw	r17,4(sp)
 3205d48:	dc000017 	ldw	r16,0(sp)
 3205d4c:	dec00304 	addi	sp,sp,12
 3205d50:	f800283a 	ret
 3205d54:	32048880 	call	3204888 <__sinit>
 3205d58:	80800117 	ldw	r2,4(r16)
 3205d5c:	800b883a 	mov	r5,r16
 3205d60:	10bfffc4 	addi	r2,r2,-1
 3205d64:	80800115 	stw	r2,4(r16)
 3205d68:	103ff10e 	bge	r2,zero,3205d30 <getc+0x44>
 3205d6c:	89000017 	ldw	r4,0(r17)
 3205d70:	dfc00217 	ldw	ra,8(sp)
 3205d74:	dc400117 	ldw	r17,4(sp)
 3205d78:	dc000017 	ldw	r16,0(sp)
 3205d7c:	dec00304 	addi	sp,sp,12
 3205d80:	32075ec1 	jmpi	32075ec <__srget_r>

03205d84 <_getc_r>:
 3205d84:	defffd04 	addi	sp,sp,-12
 3205d88:	dc400115 	stw	r17,4(sp)
 3205d8c:	dc000015 	stw	r16,0(sp)
 3205d90:	dfc00215 	stw	ra,8(sp)
 3205d94:	2021883a 	mov	r16,r4
 3205d98:	2823883a 	mov	r17,r5
 3205d9c:	20000226 	beq	r4,zero,3205da8 <_getc_r+0x24>
 3205da0:	20800e17 	ldw	r2,56(r4)
 3205da4:	10000f26 	beq	r2,zero,3205de4 <_getc_r+0x60>
 3205da8:	88800117 	ldw	r2,4(r17)
 3205dac:	8009883a 	mov	r4,r16
 3205db0:	880b883a 	mov	r5,r17
 3205db4:	10bfffc4 	addi	r2,r2,-1
 3205db8:	88800115 	stw	r2,4(r17)
 3205dbc:	10001016 	blt	r2,zero,3205e00 <_getc_r+0x7c>
 3205dc0:	88c00017 	ldw	r3,0(r17)
 3205dc4:	18800003 	ldbu	r2,0(r3)
 3205dc8:	18c00044 	addi	r3,r3,1
 3205dcc:	88c00015 	stw	r3,0(r17)
 3205dd0:	dfc00217 	ldw	ra,8(sp)
 3205dd4:	dc400117 	ldw	r17,4(sp)
 3205dd8:	dc000017 	ldw	r16,0(sp)
 3205ddc:	dec00304 	addi	sp,sp,12
 3205de0:	f800283a 	ret
 3205de4:	32048880 	call	3204888 <__sinit>
 3205de8:	88800117 	ldw	r2,4(r17)
 3205dec:	8009883a 	mov	r4,r16
 3205df0:	880b883a 	mov	r5,r17
 3205df4:	10bfffc4 	addi	r2,r2,-1
 3205df8:	88800115 	stw	r2,4(r17)
 3205dfc:	103ff00e 	bge	r2,zero,3205dc0 <_getc_r+0x3c>
 3205e00:	dfc00217 	ldw	ra,8(sp)
 3205e04:	dc400117 	ldw	r17,4(sp)
 3205e08:	dc000017 	ldw	r16,0(sp)
 3205e0c:	dec00304 	addi	sp,sp,12
 3205e10:	32075ec1 	jmpi	32075ec <__srget_r>

03205e14 <__smakebuf_r>:
 3205e14:	2880030b 	ldhu	r2,12(r5)
 3205e18:	deffed04 	addi	sp,sp,-76
 3205e1c:	dc401015 	stw	r17,64(sp)
 3205e20:	1080008c 	andi	r2,r2,2
 3205e24:	dc000f15 	stw	r16,60(sp)
 3205e28:	dfc01215 	stw	ra,72(sp)
 3205e2c:	dc801115 	stw	r18,68(sp)
 3205e30:	2821883a 	mov	r16,r5
 3205e34:	2023883a 	mov	r17,r4
 3205e38:	10000b26 	beq	r2,zero,3205e68 <__smakebuf_r+0x54>
 3205e3c:	28c010c4 	addi	r3,r5,67
 3205e40:	00800044 	movi	r2,1
 3205e44:	28800515 	stw	r2,20(r5)
 3205e48:	28c00415 	stw	r3,16(r5)
 3205e4c:	28c00015 	stw	r3,0(r5)
 3205e50:	dfc01217 	ldw	ra,72(sp)
 3205e54:	dc801117 	ldw	r18,68(sp)
 3205e58:	dc401017 	ldw	r17,64(sp)
 3205e5c:	dc000f17 	ldw	r16,60(sp)
 3205e60:	dec01304 	addi	sp,sp,76
 3205e64:	f800283a 	ret
 3205e68:	2940038f 	ldh	r5,14(r5)
 3205e6c:	28002116 	blt	r5,zero,3205ef4 <__smakebuf_r+0xe0>
 3205e70:	d80d883a 	mov	r6,sp
 3205e74:	32055800 	call	3205580 <_fstat_r>
 3205e78:	10001e16 	blt	r2,zero,3205ef4 <__smakebuf_r+0xe0>
 3205e7c:	d8800117 	ldw	r2,4(sp)
 3205e80:	00e00014 	movui	r3,32768
 3205e84:	113c000c 	andi	r4,r2,61440
 3205e88:	20c03126 	beq	r4,r3,3205f50 <__smakebuf_r+0x13c>
 3205e8c:	8080030b 	ldhu	r2,12(r16)
 3205e90:	00c80004 	movi	r3,8192
 3205e94:	10820014 	ori	r2,r2,2048
 3205e98:	8080030d 	sth	r2,12(r16)
 3205e9c:	20c01e26 	beq	r4,r3,3205f18 <__smakebuf_r+0x104>
 3205ea0:	04810004 	movi	r18,1024
 3205ea4:	8809883a 	mov	r4,r17
 3205ea8:	900b883a 	mov	r5,r18
 3205eac:	3205fa80 	call	3205fa8 <_malloc_r>
 3205eb0:	1009883a 	mov	r4,r2
 3205eb4:	10003126 	beq	r2,zero,3205f7c <__smakebuf_r+0x168>
 3205eb8:	80c0030b 	ldhu	r3,12(r16)
 3205ebc:	0080c834 	movhi	r2,800
 3205ec0:	10925b04 	addi	r2,r2,18796
 3205ec4:	88800f15 	stw	r2,60(r17)
 3205ec8:	18c02014 	ori	r3,r3,128
 3205ecc:	84800515 	stw	r18,20(r16)
 3205ed0:	80c0030d 	sth	r3,12(r16)
 3205ed4:	81000415 	stw	r4,16(r16)
 3205ed8:	81000015 	stw	r4,0(r16)
 3205edc:	dfc01217 	ldw	ra,72(sp)
 3205ee0:	dc801117 	ldw	r18,68(sp)
 3205ee4:	dc401017 	ldw	r17,64(sp)
 3205ee8:	dc000f17 	ldw	r16,60(sp)
 3205eec:	dec01304 	addi	sp,sp,76
 3205ef0:	f800283a 	ret
 3205ef4:	80c0030b 	ldhu	r3,12(r16)
 3205ef8:	1880200c 	andi	r2,r3,128
 3205efc:	10000426 	beq	r2,zero,3205f10 <__smakebuf_r+0xfc>
 3205f00:	04801004 	movi	r18,64
 3205f04:	18820014 	ori	r2,r3,2048
 3205f08:	8080030d 	sth	r2,12(r16)
 3205f0c:	003fe506 	br	3205ea4 <__smakebuf_r+0x90>
 3205f10:	04810004 	movi	r18,1024
 3205f14:	003ffb06 	br	3205f04 <__smakebuf_r+0xf0>
 3205f18:	8140038f 	ldh	r5,14(r16)
 3205f1c:	8809883a 	mov	r4,r17
 3205f20:	320d73c0 	call	320d73c <_isatty_r>
 3205f24:	103fde26 	beq	r2,zero,3205ea0 <__smakebuf_r+0x8c>
 3205f28:	8080030b 	ldhu	r2,12(r16)
 3205f2c:	80c010c4 	addi	r3,r16,67
 3205f30:	04810004 	movi	r18,1024
 3205f34:	10800054 	ori	r2,r2,1
 3205f38:	8080030d 	sth	r2,12(r16)
 3205f3c:	00800044 	movi	r2,1
 3205f40:	80c00415 	stw	r3,16(r16)
 3205f44:	80800515 	stw	r2,20(r16)
 3205f48:	80c00015 	stw	r3,0(r16)
 3205f4c:	003fd506 	br	3205ea4 <__smakebuf_r+0x90>
 3205f50:	80c00a17 	ldw	r3,40(r16)
 3205f54:	0080c834 	movhi	r2,800
 3205f58:	109e2b04 	addi	r2,r2,30892
 3205f5c:	18bfcb1e 	bne	r3,r2,3205e8c <__smakebuf_r+0x78>
 3205f60:	8080030b 	ldhu	r2,12(r16)
 3205f64:	00c10004 	movi	r3,1024
 3205f68:	1825883a 	mov	r18,r3
 3205f6c:	10c4b03a 	or	r2,r2,r3
 3205f70:	8080030d 	sth	r2,12(r16)
 3205f74:	80c01315 	stw	r3,76(r16)
 3205f78:	003fca06 	br	3205ea4 <__smakebuf_r+0x90>
 3205f7c:	8100030b 	ldhu	r4,12(r16)
 3205f80:	2080800c 	andi	r2,r4,512
 3205f84:	103fb21e 	bne	r2,zero,3205e50 <__smakebuf_r+0x3c>
 3205f88:	80c010c4 	addi	r3,r16,67
 3205f8c:	21000094 	ori	r4,r4,2
 3205f90:	00800044 	movi	r2,1
 3205f94:	80800515 	stw	r2,20(r16)
 3205f98:	8100030d 	sth	r4,12(r16)
 3205f9c:	80c00415 	stw	r3,16(r16)
 3205fa0:	80c00015 	stw	r3,0(r16)
 3205fa4:	003faa06 	br	3205e50 <__smakebuf_r+0x3c>

03205fa8 <_malloc_r>:
 3205fa8:	defff604 	addi	sp,sp,-40
 3205fac:	28c002c4 	addi	r3,r5,11
 3205fb0:	00800584 	movi	r2,22
 3205fb4:	dc800215 	stw	r18,8(sp)
 3205fb8:	dfc00915 	stw	ra,36(sp)
 3205fbc:	df000815 	stw	fp,32(sp)
 3205fc0:	ddc00715 	stw	r23,28(sp)
 3205fc4:	dd800615 	stw	r22,24(sp)
 3205fc8:	dd400515 	stw	r21,20(sp)
 3205fcc:	dd000415 	stw	r20,16(sp)
 3205fd0:	dcc00315 	stw	r19,12(sp)
 3205fd4:	dc400115 	stw	r17,4(sp)
 3205fd8:	dc000015 	stw	r16,0(sp)
 3205fdc:	2025883a 	mov	r18,r4
 3205fe0:	10c01236 	bltu	r2,r3,320602c <_malloc_r+0x84>
 3205fe4:	04400404 	movi	r17,16
 3205fe8:	8940142e 	bgeu	r17,r5,320603c <_malloc_r+0x94>
 3205fec:	00800304 	movi	r2,12
 3205ff0:	0007883a 	mov	r3,zero
 3205ff4:	90800015 	stw	r2,0(r18)
 3205ff8:	1805883a 	mov	r2,r3
 3205ffc:	dfc00917 	ldw	ra,36(sp)
 3206000:	df000817 	ldw	fp,32(sp)
 3206004:	ddc00717 	ldw	r23,28(sp)
 3206008:	dd800617 	ldw	r22,24(sp)
 320600c:	dd400517 	ldw	r21,20(sp)
 3206010:	dd000417 	ldw	r20,16(sp)
 3206014:	dcc00317 	ldw	r19,12(sp)
 3206018:	dc800217 	ldw	r18,8(sp)
 320601c:	dc400117 	ldw	r17,4(sp)
 3206020:	dc000017 	ldw	r16,0(sp)
 3206024:	dec00a04 	addi	sp,sp,40
 3206028:	f800283a 	ret
 320602c:	00bffe04 	movi	r2,-8
 3206030:	18a2703a 	and	r17,r3,r2
 3206034:	883fed16 	blt	r17,zero,3205fec <_malloc_r+0x44>
 3206038:	897fec36 	bltu	r17,r5,3205fec <_malloc_r+0x44>
 320603c:	9009883a 	mov	r4,r18
 3206040:	321506c0 	call	321506c <__malloc_lock>
 3206044:	00807dc4 	movi	r2,503
 3206048:	14402b2e 	bgeu	r2,r17,32060f8 <_malloc_r+0x150>
 320604c:	8806d27a 	srli	r3,r17,9
 3206050:	18003f1e 	bne	r3,zero,3206150 <_malloc_r+0x1a8>
 3206054:	880cd0fa 	srli	r6,r17,3
 3206058:	300490fa 	slli	r2,r6,3
 320605c:	02c0c974 	movhi	r11,805
 3206060:	5ac29a04 	addi	r11,r11,2664
 3206064:	12cb883a 	add	r5,r2,r11
 3206068:	2c000317 	ldw	r16,12(r5)
 320606c:	580f883a 	mov	r7,r11
 3206070:	2c00041e 	bne	r5,r16,3206084 <_malloc_r+0xdc>
 3206074:	00000a06 	br	32060a0 <_malloc_r+0xf8>
 3206078:	1800860e 	bge	r3,zero,3206294 <_malloc_r+0x2ec>
 320607c:	84000317 	ldw	r16,12(r16)
 3206080:	2c000726 	beq	r5,r16,32060a0 <_malloc_r+0xf8>
 3206084:	80800117 	ldw	r2,4(r16)
 3206088:	00ffff04 	movi	r3,-4
 320608c:	10c8703a 	and	r4,r2,r3
 3206090:	2447c83a 	sub	r3,r4,r17
 3206094:	008003c4 	movi	r2,15
 3206098:	10fff70e 	bge	r2,r3,3206078 <_malloc_r+0xd0>
 320609c:	31bfffc4 	addi	r6,r6,-1
 32060a0:	32400044 	addi	r9,r6,1
 32060a4:	0280c974 	movhi	r10,805
 32060a8:	52829c04 	addi	r10,r10,2672
 32060ac:	54000217 	ldw	r16,8(r10)
 32060b0:	8280a026 	beq	r16,r10,3206334 <_malloc_r+0x38c>
 32060b4:	80800117 	ldw	r2,4(r16)
 32060b8:	00ffff04 	movi	r3,-4
 32060bc:	10ca703a 	and	r5,r2,r3
 32060c0:	2c4dc83a 	sub	r6,r5,r17
 32060c4:	008003c4 	movi	r2,15
 32060c8:	11808316 	blt	r2,r6,32062d8 <_malloc_r+0x330>
 32060cc:	52800315 	stw	r10,12(r10)
 32060d0:	52800215 	stw	r10,8(r10)
 32060d4:	30002916 	blt	r6,zero,320617c <_malloc_r+0x1d4>
 32060d8:	8147883a 	add	r3,r16,r5
 32060dc:	18800117 	ldw	r2,4(r3)
 32060e0:	9009883a 	mov	r4,r18
 32060e4:	10800054 	ori	r2,r2,1
 32060e8:	18800115 	stw	r2,4(r3)
 32060ec:	32151740 	call	3215174 <__malloc_unlock>
 32060f0:	80c00204 	addi	r3,r16,8
 32060f4:	003fc006 	br	3205ff8 <_malloc_r+0x50>
 32060f8:	02c0c974 	movhi	r11,805
 32060fc:	5ac29a04 	addi	r11,r11,2664
 3206100:	8ac5883a 	add	r2,r17,r11
 3206104:	14000317 	ldw	r16,12(r2)
 3206108:	580f883a 	mov	r7,r11
 320610c:	8806d0fa 	srli	r3,r17,3
 3206110:	14006c26 	beq	r2,r16,32062c4 <_malloc_r+0x31c>
 3206114:	80c00117 	ldw	r3,4(r16)
 3206118:	00bfff04 	movi	r2,-4
 320611c:	81800317 	ldw	r6,12(r16)
 3206120:	1886703a 	and	r3,r3,r2
 3206124:	80c7883a 	add	r3,r16,r3
 3206128:	18800117 	ldw	r2,4(r3)
 320612c:	81400217 	ldw	r5,8(r16)
 3206130:	9009883a 	mov	r4,r18
 3206134:	10800054 	ori	r2,r2,1
 3206138:	18800115 	stw	r2,4(r3)
 320613c:	31400215 	stw	r5,8(r6)
 3206140:	29800315 	stw	r6,12(r5)
 3206144:	32151740 	call	3215174 <__malloc_unlock>
 3206148:	80c00204 	addi	r3,r16,8
 320614c:	003faa06 	br	3205ff8 <_malloc_r+0x50>
 3206150:	00800104 	movi	r2,4
 3206154:	10c0052e 	bgeu	r2,r3,320616c <_malloc_r+0x1c4>
 3206158:	00800504 	movi	r2,20
 320615c:	10c07836 	bltu	r2,r3,3206340 <_malloc_r+0x398>
 3206160:	198016c4 	addi	r6,r3,91
 3206164:	300490fa 	slli	r2,r6,3
 3206168:	003fbc06 	br	320605c <_malloc_r+0xb4>
 320616c:	8804d1ba 	srli	r2,r17,6
 3206170:	11800e04 	addi	r6,r2,56
 3206174:	300490fa 	slli	r2,r6,3
 3206178:	003fb806 	br	320605c <_malloc_r+0xb4>
 320617c:	00807fc4 	movi	r2,511
 3206180:	1140bb36 	bltu	r2,r5,3206470 <_malloc_r+0x4c8>
 3206184:	2806d0fa 	srli	r3,r5,3
 3206188:	573ffe04 	addi	fp,r10,-8
 320618c:	00800044 	movi	r2,1
 3206190:	180890fa 	slli	r4,r3,3
 3206194:	1807d0ba 	srai	r3,r3,2
 3206198:	e1c00117 	ldw	r7,4(fp)
 320619c:	5909883a 	add	r4,r11,r4
 32061a0:	21400217 	ldw	r5,8(r4)
 32061a4:	10c4983a 	sll	r2,r2,r3
 32061a8:	81000315 	stw	r4,12(r16)
 32061ac:	81400215 	stw	r5,8(r16)
 32061b0:	388eb03a 	or	r7,r7,r2
 32061b4:	2c000315 	stw	r16,12(r5)
 32061b8:	24000215 	stw	r16,8(r4)
 32061bc:	e1c00115 	stw	r7,4(fp)
 32061c0:	4807883a 	mov	r3,r9
 32061c4:	4800cd16 	blt	r9,zero,32064fc <_malloc_r+0x554>
 32061c8:	1807d0ba 	srai	r3,r3,2
 32061cc:	00800044 	movi	r2,1
 32061d0:	10c8983a 	sll	r4,r2,r3
 32061d4:	39004436 	bltu	r7,r4,32062e8 <_malloc_r+0x340>
 32061d8:	21c4703a 	and	r2,r4,r7
 32061dc:	10000a1e 	bne	r2,zero,3206208 <_malloc_r+0x260>
 32061e0:	2109883a 	add	r4,r4,r4
 32061e4:	00bfff04 	movi	r2,-4
 32061e8:	4884703a 	and	r2,r9,r2
 32061ec:	3906703a 	and	r3,r7,r4
 32061f0:	12400104 	addi	r9,r2,4
 32061f4:	1800041e 	bne	r3,zero,3206208 <_malloc_r+0x260>
 32061f8:	2109883a 	add	r4,r4,r4
 32061fc:	3904703a 	and	r2,r7,r4
 3206200:	4a400104 	addi	r9,r9,4
 3206204:	103ffc26 	beq	r2,zero,32061f8 <_malloc_r+0x250>
 3206208:	480490fa 	slli	r2,r9,3
 320620c:	4819883a 	mov	r12,r9
 3206210:	023fff04 	movi	r8,-4
 3206214:	589b883a 	add	r13,r11,r2
 3206218:	6807883a 	mov	r3,r13
 320621c:	014003c4 	movi	r5,15
 3206220:	1c000317 	ldw	r16,12(r3)
 3206224:	1c00041e 	bne	r3,r16,3206238 <_malloc_r+0x290>
 3206228:	0000a706 	br	32064c8 <_malloc_r+0x520>
 320622c:	3000ab0e 	bge	r6,zero,32064dc <_malloc_r+0x534>
 3206230:	84000317 	ldw	r16,12(r16)
 3206234:	1c00a426 	beq	r3,r16,32064c8 <_malloc_r+0x520>
 3206238:	80800117 	ldw	r2,4(r16)
 320623c:	1204703a 	and	r2,r2,r8
 3206240:	144dc83a 	sub	r6,r2,r17
 3206244:	29bff90e 	bge	r5,r6,320622c <_malloc_r+0x284>
 3206248:	81000317 	ldw	r4,12(r16)
 320624c:	80c00217 	ldw	r3,8(r16)
 3206250:	89400054 	ori	r5,r17,1
 3206254:	8445883a 	add	r2,r16,r17
 3206258:	20c00215 	stw	r3,8(r4)
 320625c:	19000315 	stw	r4,12(r3)
 3206260:	81400115 	stw	r5,4(r16)
 3206264:	1187883a 	add	r3,r2,r6
 3206268:	31000054 	ori	r4,r6,1
 320626c:	50800315 	stw	r2,12(r10)
 3206270:	50800215 	stw	r2,8(r10)
 3206274:	19800015 	stw	r6,0(r3)
 3206278:	11000115 	stw	r4,4(r2)
 320627c:	12800215 	stw	r10,8(r2)
 3206280:	12800315 	stw	r10,12(r2)
 3206284:	9009883a 	mov	r4,r18
 3206288:	32151740 	call	3215174 <__malloc_unlock>
 320628c:	80c00204 	addi	r3,r16,8
 3206290:	003f5906 	br	3205ff8 <_malloc_r+0x50>
 3206294:	8109883a 	add	r4,r16,r4
 3206298:	20800117 	ldw	r2,4(r4)
 320629c:	80c00217 	ldw	r3,8(r16)
 32062a0:	81400317 	ldw	r5,12(r16)
 32062a4:	10800054 	ori	r2,r2,1
 32062a8:	20800115 	stw	r2,4(r4)
 32062ac:	28c00215 	stw	r3,8(r5)
 32062b0:	19400315 	stw	r5,12(r3)
 32062b4:	9009883a 	mov	r4,r18
 32062b8:	32151740 	call	3215174 <__malloc_unlock>
 32062bc:	80c00204 	addi	r3,r16,8
 32062c0:	003f4d06 	br	3205ff8 <_malloc_r+0x50>
 32062c4:	80800204 	addi	r2,r16,8
 32062c8:	14000317 	ldw	r16,12(r2)
 32062cc:	143f911e 	bne	r2,r16,3206114 <_malloc_r+0x16c>
 32062d0:	1a400084 	addi	r9,r3,2
 32062d4:	003f7306 	br	32060a4 <_malloc_r+0xfc>
 32062d8:	88c00054 	ori	r3,r17,1
 32062dc:	8445883a 	add	r2,r16,r17
 32062e0:	80c00115 	stw	r3,4(r16)
 32062e4:	003fdf06 	br	3206264 <_malloc_r+0x2bc>
 32062e8:	e4000217 	ldw	r16,8(fp)
 32062ec:	00bfff04 	movi	r2,-4
 32062f0:	80c00117 	ldw	r3,4(r16)
 32062f4:	802d883a 	mov	r22,r16
 32062f8:	18aa703a 	and	r21,r3,r2
 32062fc:	ac401636 	bltu	r21,r17,3206358 <_malloc_r+0x3b0>
 3206300:	ac49c83a 	sub	r4,r21,r17
 3206304:	008003c4 	movi	r2,15
 3206308:	1100130e 	bge	r2,r4,3206358 <_malloc_r+0x3b0>
 320630c:	88800054 	ori	r2,r17,1
 3206310:	8447883a 	add	r3,r16,r17
 3206314:	80800115 	stw	r2,4(r16)
 3206318:	20800054 	ori	r2,r4,1
 320631c:	18800115 	stw	r2,4(r3)
 3206320:	e0c00215 	stw	r3,8(fp)
 3206324:	9009883a 	mov	r4,r18
 3206328:	32151740 	call	3215174 <__malloc_unlock>
 320632c:	80c00204 	addi	r3,r16,8
 3206330:	003f3106 	br	3205ff8 <_malloc_r+0x50>
 3206334:	39c00117 	ldw	r7,4(r7)
 3206338:	573ffe04 	addi	fp,r10,-8
 320633c:	003fa006 	br	32061c0 <_malloc_r+0x218>
 3206340:	00801504 	movi	r2,84
 3206344:	10c06736 	bltu	r2,r3,32064e4 <_malloc_r+0x53c>
 3206348:	8804d33a 	srli	r2,r17,12
 320634c:	11801b84 	addi	r6,r2,110
 3206350:	300490fa 	slli	r2,r6,3
 3206354:	003f4106 	br	320605c <_malloc_r+0xb4>
 3206358:	d0a89717 	ldw	r2,-23972(gp)
 320635c:	d0e00417 	ldw	r3,-32752(gp)
 3206360:	053fffc4 	movi	r20,-1
 3206364:	10800404 	addi	r2,r2,16
 3206368:	88a7883a 	add	r19,r17,r2
 320636c:	1d000326 	beq	r3,r20,320637c <_malloc_r+0x3d4>
 3206370:	98c3ffc4 	addi	r3,r19,4095
 3206374:	00bc0004 	movi	r2,-4096
 3206378:	18a6703a 	and	r19,r3,r2
 320637c:	9009883a 	mov	r4,r18
 3206380:	980b883a 	mov	r5,r19
 3206384:	320764c0 	call	320764c <_sbrk_r>
 3206388:	1009883a 	mov	r4,r2
 320638c:	15000426 	beq	r2,r20,32063a0 <_malloc_r+0x3f8>
 3206390:	854b883a 	add	r5,r16,r21
 3206394:	1029883a 	mov	r20,r2
 3206398:	11405a2e 	bgeu	r2,r5,3206504 <_malloc_r+0x55c>
 320639c:	87000c26 	beq	r16,fp,32063d0 <_malloc_r+0x428>
 32063a0:	e4000217 	ldw	r16,8(fp)
 32063a4:	80c00117 	ldw	r3,4(r16)
 32063a8:	00bfff04 	movi	r2,-4
 32063ac:	1884703a 	and	r2,r3,r2
 32063b0:	14400336 	bltu	r2,r17,32063c0 <_malloc_r+0x418>
 32063b4:	1449c83a 	sub	r4,r2,r17
 32063b8:	008003c4 	movi	r2,15
 32063bc:	113fd316 	blt	r2,r4,320630c <_malloc_r+0x364>
 32063c0:	9009883a 	mov	r4,r18
 32063c4:	32151740 	call	3215174 <__malloc_unlock>
 32063c8:	0007883a 	mov	r3,zero
 32063cc:	003f0a06 	br	3205ff8 <_malloc_r+0x50>
 32063d0:	05c0c974 	movhi	r23,805
 32063d4:	bdd49004 	addi	r23,r23,21056
 32063d8:	b8800017 	ldw	r2,0(r23)
 32063dc:	988d883a 	add	r6,r19,r2
 32063e0:	b9800015 	stw	r6,0(r23)
 32063e4:	d0e00417 	ldw	r3,-32752(gp)
 32063e8:	00bfffc4 	movi	r2,-1
 32063ec:	18808e26 	beq	r3,r2,3206628 <_malloc_r+0x680>
 32063f0:	2145c83a 	sub	r2,r4,r5
 32063f4:	3085883a 	add	r2,r6,r2
 32063f8:	b8800015 	stw	r2,0(r23)
 32063fc:	20c001cc 	andi	r3,r4,7
 3206400:	18005f1e 	bne	r3,zero,3206580 <_malloc_r+0x5d8>
 3206404:	000b883a 	mov	r5,zero
 3206408:	a4c5883a 	add	r2,r20,r19
 320640c:	1083ffcc 	andi	r2,r2,4095
 3206410:	00c40004 	movi	r3,4096
 3206414:	1887c83a 	sub	r3,r3,r2
 3206418:	28e7883a 	add	r19,r5,r3
 320641c:	9009883a 	mov	r4,r18
 3206420:	980b883a 	mov	r5,r19
 3206424:	320764c0 	call	320764c <_sbrk_r>
 3206428:	1007883a 	mov	r3,r2
 320642c:	00bfffc4 	movi	r2,-1
 3206430:	18807a26 	beq	r3,r2,320661c <_malloc_r+0x674>
 3206434:	1d05c83a 	sub	r2,r3,r20
 3206438:	9885883a 	add	r2,r19,r2
 320643c:	10c00054 	ori	r3,r2,1
 3206440:	b8800017 	ldw	r2,0(r23)
 3206444:	a021883a 	mov	r16,r20
 3206448:	a0c00115 	stw	r3,4(r20)
 320644c:	9885883a 	add	r2,r19,r2
 3206450:	b8800015 	stw	r2,0(r23)
 3206454:	e5000215 	stw	r20,8(fp)
 3206458:	b7003626 	beq	r22,fp,3206534 <_malloc_r+0x58c>
 320645c:	018003c4 	movi	r6,15
 3206460:	35404b36 	bltu	r6,r21,3206590 <_malloc_r+0x5e8>
 3206464:	00800044 	movi	r2,1
 3206468:	a0800115 	stw	r2,4(r20)
 320646c:	003fcd06 	br	32063a4 <_malloc_r+0x3fc>
 3206470:	2808d27a 	srli	r4,r5,9
 3206474:	2000371e 	bne	r4,zero,3206554 <_malloc_r+0x5ac>
 3206478:	2808d0fa 	srli	r4,r5,3
 320647c:	200690fa 	slli	r3,r4,3
 3206480:	1ad1883a 	add	r8,r3,r11
 3206484:	41800217 	ldw	r6,8(r8)
 3206488:	41805b26 	beq	r8,r6,32065f8 <_malloc_r+0x650>
 320648c:	30800117 	ldw	r2,4(r6)
 3206490:	00ffff04 	movi	r3,-4
 3206494:	10c4703a 	and	r2,r2,r3
 3206498:	2880022e 	bgeu	r5,r2,32064a4 <_malloc_r+0x4fc>
 320649c:	31800217 	ldw	r6,8(r6)
 32064a0:	41bffa1e 	bne	r8,r6,320648c <_malloc_r+0x4e4>
 32064a4:	32000317 	ldw	r8,12(r6)
 32064a8:	39c00117 	ldw	r7,4(r7)
 32064ac:	82000315 	stw	r8,12(r16)
 32064b0:	81800215 	stw	r6,8(r16)
 32064b4:	0700c974 	movhi	fp,805
 32064b8:	e7029a04 	addi	fp,fp,2664
 32064bc:	34000315 	stw	r16,12(r6)
 32064c0:	44000215 	stw	r16,8(r8)
 32064c4:	003f3e06 	br	32061c0 <_malloc_r+0x218>
 32064c8:	63000044 	addi	r12,r12,1
 32064cc:	608000cc 	andi	r2,r12,3
 32064d0:	10005d26 	beq	r2,zero,3206648 <_malloc_r+0x6a0>
 32064d4:	18c00204 	addi	r3,r3,8
 32064d8:	003f5106 	br	3206220 <_malloc_r+0x278>
 32064dc:	8089883a 	add	r4,r16,r2
 32064e0:	003f6d06 	br	3206298 <_malloc_r+0x2f0>
 32064e4:	00805504 	movi	r2,340
 32064e8:	10c02036 	bltu	r2,r3,320656c <_malloc_r+0x5c4>
 32064ec:	8804d3fa 	srli	r2,r17,15
 32064f0:	11801dc4 	addi	r6,r2,119
 32064f4:	300490fa 	slli	r2,r6,3
 32064f8:	003ed806 	br	320605c <_malloc_r+0xb4>
 32064fc:	48c000c4 	addi	r3,r9,3
 3206500:	003f3106 	br	32061c8 <_malloc_r+0x220>
 3206504:	05c0c974 	movhi	r23,805
 3206508:	bdd49004 	addi	r23,r23,21056
 320650c:	b8800017 	ldw	r2,0(r23)
 3206510:	988d883a 	add	r6,r19,r2
 3206514:	b9800015 	stw	r6,0(r23)
 3206518:	293fb21e 	bne	r5,r4,32063e4 <_malloc_r+0x43c>
 320651c:	2083ffcc 	andi	r2,r4,4095
 3206520:	103fb01e 	bne	r2,zero,32063e4 <_malloc_r+0x43c>
 3206524:	e4000217 	ldw	r16,8(fp)
 3206528:	9d45883a 	add	r2,r19,r21
 320652c:	10800054 	ori	r2,r2,1
 3206530:	80800115 	stw	r2,4(r16)
 3206534:	b8c00017 	ldw	r3,0(r23)
 3206538:	d0a89817 	ldw	r2,-23968(gp)
 320653c:	10c0012e 	bgeu	r2,r3,3206544 <_malloc_r+0x59c>
 3206540:	d0e89815 	stw	r3,-23968(gp)
 3206544:	d0a89917 	ldw	r2,-23964(gp)
 3206548:	10ff962e 	bgeu	r2,r3,32063a4 <_malloc_r+0x3fc>
 320654c:	d0e89915 	stw	r3,-23964(gp)
 3206550:	003f9406 	br	32063a4 <_malloc_r+0x3fc>
 3206554:	00800104 	movi	r2,4
 3206558:	11001e36 	bltu	r2,r4,32065d4 <_malloc_r+0x62c>
 320655c:	2804d1ba 	srli	r2,r5,6
 3206560:	11000e04 	addi	r4,r2,56
 3206564:	200690fa 	slli	r3,r4,3
 3206568:	003fc506 	br	3206480 <_malloc_r+0x4d8>
 320656c:	00815504 	movi	r2,1364
 3206570:	10c01d2e 	bgeu	r2,r3,32065e8 <_malloc_r+0x640>
 3206574:	01801f84 	movi	r6,126
 3206578:	0080fc04 	movi	r2,1008
 320657c:	003eb706 	br	320605c <_malloc_r+0xb4>
 3206580:	00800204 	movi	r2,8
 3206584:	10cbc83a 	sub	r5,r2,r3
 3206588:	2169883a 	add	r20,r4,r5
 320658c:	003f9e06 	br	3206408 <_malloc_r+0x460>
 3206590:	00bffe04 	movi	r2,-8
 3206594:	a93ffd04 	addi	r4,r21,-12
 3206598:	2088703a 	and	r4,r4,r2
 320659c:	b10b883a 	add	r5,r22,r4
 32065a0:	00c00144 	movi	r3,5
 32065a4:	28c00215 	stw	r3,8(r5)
 32065a8:	28c00115 	stw	r3,4(r5)
 32065ac:	b0800117 	ldw	r2,4(r22)
 32065b0:	1080004c 	andi	r2,r2,1
 32065b4:	2084b03a 	or	r2,r4,r2
 32065b8:	b0800115 	stw	r2,4(r22)
 32065bc:	313fdd2e 	bgeu	r6,r4,3206534 <_malloc_r+0x58c>
 32065c0:	b1400204 	addi	r5,r22,8
 32065c4:	9009883a 	mov	r4,r18
 32065c8:	3204e0c0 	call	3204e0c <_free_r>
 32065cc:	e4000217 	ldw	r16,8(fp)
 32065d0:	003fd806 	br	3206534 <_malloc_r+0x58c>
 32065d4:	00800504 	movi	r2,20
 32065d8:	11001536 	bltu	r2,r4,3206630 <_malloc_r+0x688>
 32065dc:	210016c4 	addi	r4,r4,91
 32065e0:	200690fa 	slli	r3,r4,3
 32065e4:	003fa606 	br	3206480 <_malloc_r+0x4d8>
 32065e8:	8804d4ba 	srli	r2,r17,18
 32065ec:	11801f04 	addi	r6,r2,124
 32065f0:	300490fa 	slli	r2,r6,3
 32065f4:	003e9906 	br	320605c <_malloc_r+0xb4>
 32065f8:	2009d0ba 	srai	r4,r4,2
 32065fc:	0140c974 	movhi	r5,805
 3206600:	29429a04 	addi	r5,r5,2664
 3206604:	00c00044 	movi	r3,1
 3206608:	28800117 	ldw	r2,4(r5)
 320660c:	1906983a 	sll	r3,r3,r4
 3206610:	10c4b03a 	or	r2,r2,r3
 3206614:	28800115 	stw	r2,4(r5)
 3206618:	003fa306 	br	32064a8 <_malloc_r+0x500>
 320661c:	0027883a 	mov	r19,zero
 3206620:	00c00044 	movi	r3,1
 3206624:	003f8606 	br	3206440 <_malloc_r+0x498>
 3206628:	d1200415 	stw	r4,-32752(gp)
 320662c:	003f7306 	br	32063fc <_malloc_r+0x454>
 3206630:	00801504 	movi	r2,84
 3206634:	11001936 	bltu	r2,r4,320669c <_malloc_r+0x6f4>
 3206638:	2804d33a 	srli	r2,r5,12
 320663c:	11001b84 	addi	r4,r2,110
 3206640:	200690fa 	slli	r3,r4,3
 3206644:	003f8e06 	br	3206480 <_malloc_r+0x4d8>
 3206648:	480b883a 	mov	r5,r9
 320664c:	6807883a 	mov	r3,r13
 3206650:	288000cc 	andi	r2,r5,3
 3206654:	18fffe04 	addi	r3,r3,-8
 3206658:	297fffc4 	addi	r5,r5,-1
 320665c:	10001526 	beq	r2,zero,32066b4 <_malloc_r+0x70c>
 3206660:	18800217 	ldw	r2,8(r3)
 3206664:	10fffa26 	beq	r2,r3,3206650 <_malloc_r+0x6a8>
 3206668:	2109883a 	add	r4,r4,r4
 320666c:	393f1e36 	bltu	r7,r4,32062e8 <_malloc_r+0x340>
 3206670:	203f1d26 	beq	r4,zero,32062e8 <_malloc_r+0x340>
 3206674:	21c4703a 	and	r2,r4,r7
 3206678:	10000226 	beq	r2,zero,3206684 <_malloc_r+0x6dc>
 320667c:	6013883a 	mov	r9,r12
 3206680:	003ee106 	br	3206208 <_malloc_r+0x260>
 3206684:	2109883a 	add	r4,r4,r4
 3206688:	3904703a 	and	r2,r7,r4
 320668c:	63000104 	addi	r12,r12,4
 3206690:	103ffc26 	beq	r2,zero,3206684 <_malloc_r+0x6dc>
 3206694:	6013883a 	mov	r9,r12
 3206698:	003edb06 	br	3206208 <_malloc_r+0x260>
 320669c:	00805504 	movi	r2,340
 32066a0:	11000836 	bltu	r2,r4,32066c4 <_malloc_r+0x71c>
 32066a4:	2804d3fa 	srli	r2,r5,15
 32066a8:	11001dc4 	addi	r4,r2,119
 32066ac:	200690fa 	slli	r3,r4,3
 32066b0:	003f7306 	br	3206480 <_malloc_r+0x4d8>
 32066b4:	0104303a 	nor	r2,zero,r4
 32066b8:	388e703a 	and	r7,r7,r2
 32066bc:	e1c00115 	stw	r7,4(fp)
 32066c0:	003fe906 	br	3206668 <_malloc_r+0x6c0>
 32066c4:	00815504 	movi	r2,1364
 32066c8:	1100032e 	bgeu	r2,r4,32066d8 <_malloc_r+0x730>
 32066cc:	01001f84 	movi	r4,126
 32066d0:	00c0fc04 	movi	r3,1008
 32066d4:	003f6a06 	br	3206480 <_malloc_r+0x4d8>
 32066d8:	2804d4ba 	srli	r2,r5,18
 32066dc:	11001f04 	addi	r4,r2,124
 32066e0:	200690fa 	slli	r3,r4,3
 32066e4:	003f6606 	br	3206480 <_malloc_r+0x4d8>

032066e8 <memchr>:
 32066e8:	008000c4 	movi	r2,3
 32066ec:	29403fcc 	andi	r5,r5,255
 32066f0:	2007883a 	mov	r3,r4
 32066f4:	1180022e 	bgeu	r2,r6,3206700 <memchr+0x18>
 32066f8:	2084703a 	and	r2,r4,r2
 32066fc:	10000b26 	beq	r2,zero,320672c <memchr+0x44>
 3206700:	313fffc4 	addi	r4,r6,-1
 3206704:	3000051e 	bne	r6,zero,320671c <memchr+0x34>
 3206708:	00002c06 	br	32067bc <memchr+0xd4>
 320670c:	213fffc4 	addi	r4,r4,-1
 3206710:	00bfffc4 	movi	r2,-1
 3206714:	18c00044 	addi	r3,r3,1
 3206718:	20802826 	beq	r4,r2,32067bc <memchr+0xd4>
 320671c:	18800003 	ldbu	r2,0(r3)
 3206720:	28bffa1e 	bne	r5,r2,320670c <memchr+0x24>
 3206724:	1805883a 	mov	r2,r3
 3206728:	f800283a 	ret
 320672c:	0011883a 	mov	r8,zero
 3206730:	0007883a 	mov	r3,zero
 3206734:	01c00104 	movi	r7,4
 3206738:	4004923a 	slli	r2,r8,8
 320673c:	18c00044 	addi	r3,r3,1
 3206740:	1151883a 	add	r8,r2,r5
 3206744:	19fffc1e 	bne	r3,r7,3206738 <memchr+0x50>
 3206748:	02bfbff4 	movhi	r10,65279
 320674c:	52bfbfc4 	addi	r10,r10,-257
 3206750:	02602074 	movhi	r9,32897
 3206754:	4a602004 	addi	r9,r9,-32640
 3206758:	02c000c4 	movi	r11,3
 320675c:	20800017 	ldw	r2,0(r4)
 3206760:	31bfff04 	addi	r6,r6,-4
 3206764:	200f883a 	mov	r7,r4
 3206768:	1204f03a 	xor	r2,r2,r8
 320676c:	1287883a 	add	r3,r2,r10
 3206770:	1a46703a 	and	r3,r3,r9
 3206774:	0084303a 	nor	r2,zero,r2
 3206778:	10c4703a 	and	r2,r2,r3
 320677c:	10000b26 	beq	r2,zero,32067ac <memchr+0xc4>
 3206780:	20800003 	ldbu	r2,0(r4)
 3206784:	28800f26 	beq	r5,r2,32067c4 <memchr+0xdc>
 3206788:	20800043 	ldbu	r2,1(r4)
 320678c:	21c00044 	addi	r7,r4,1
 3206790:	28800c26 	beq	r5,r2,32067c4 <memchr+0xdc>
 3206794:	20800083 	ldbu	r2,2(r4)
 3206798:	21c00084 	addi	r7,r4,2
 320679c:	28800926 	beq	r5,r2,32067c4 <memchr+0xdc>
 32067a0:	208000c3 	ldbu	r2,3(r4)
 32067a4:	21c000c4 	addi	r7,r4,3
 32067a8:	28800626 	beq	r5,r2,32067c4 <memchr+0xdc>
 32067ac:	21000104 	addi	r4,r4,4
 32067b0:	59bfea36 	bltu	r11,r6,320675c <memchr+0x74>
 32067b4:	2007883a 	mov	r3,r4
 32067b8:	003fd106 	br	3206700 <memchr+0x18>
 32067bc:	0005883a 	mov	r2,zero
 32067c0:	f800283a 	ret
 32067c4:	3805883a 	mov	r2,r7
 32067c8:	f800283a 	ret

032067cc <memcpy>:
 32067cc:	01c003c4 	movi	r7,15
 32067d0:	2007883a 	mov	r3,r4
 32067d4:	3980032e 	bgeu	r7,r6,32067e4 <memcpy+0x18>
 32067d8:	2904b03a 	or	r2,r5,r4
 32067dc:	108000cc 	andi	r2,r2,3
 32067e0:	10000926 	beq	r2,zero,3206808 <memcpy+0x3c>
 32067e4:	30000626 	beq	r6,zero,3206800 <memcpy+0x34>
 32067e8:	30cd883a 	add	r6,r6,r3
 32067ec:	28800003 	ldbu	r2,0(r5)
 32067f0:	29400044 	addi	r5,r5,1
 32067f4:	18800005 	stb	r2,0(r3)
 32067f8:	18c00044 	addi	r3,r3,1
 32067fc:	30fffb1e 	bne	r6,r3,32067ec <memcpy+0x20>
 3206800:	2005883a 	mov	r2,r4
 3206804:	f800283a 	ret
 3206808:	3811883a 	mov	r8,r7
 320680c:	200f883a 	mov	r7,r4
 3206810:	28c00017 	ldw	r3,0(r5)
 3206814:	31bffc04 	addi	r6,r6,-16
 3206818:	38c00015 	stw	r3,0(r7)
 320681c:	28800117 	ldw	r2,4(r5)
 3206820:	38800115 	stw	r2,4(r7)
 3206824:	28c00217 	ldw	r3,8(r5)
 3206828:	38c00215 	stw	r3,8(r7)
 320682c:	28800317 	ldw	r2,12(r5)
 3206830:	29400404 	addi	r5,r5,16
 3206834:	38800315 	stw	r2,12(r7)
 3206838:	39c00404 	addi	r7,r7,16
 320683c:	41bff436 	bltu	r8,r6,3206810 <memcpy+0x44>
 3206840:	008000c4 	movi	r2,3
 3206844:	1180072e 	bgeu	r2,r6,3206864 <memcpy+0x98>
 3206848:	1007883a 	mov	r3,r2
 320684c:	28800017 	ldw	r2,0(r5)
 3206850:	31bfff04 	addi	r6,r6,-4
 3206854:	29400104 	addi	r5,r5,4
 3206858:	38800015 	stw	r2,0(r7)
 320685c:	39c00104 	addi	r7,r7,4
 3206860:	19bffa36 	bltu	r3,r6,320684c <memcpy+0x80>
 3206864:	3807883a 	mov	r3,r7
 3206868:	003fde06 	br	32067e4 <memcpy+0x18>

0320686c <memmove>:
 320686c:	2807883a 	mov	r3,r5
 3206870:	2011883a 	mov	r8,r4
 3206874:	29000c2e 	bgeu	r5,r4,32068a8 <memmove+0x3c>
 3206878:	298f883a 	add	r7,r5,r6
 320687c:	21c00a2e 	bgeu	r4,r7,32068a8 <memmove+0x3c>
 3206880:	30000726 	beq	r6,zero,32068a0 <memmove+0x34>
 3206884:	2187883a 	add	r3,r4,r6
 3206888:	198dc83a 	sub	r6,r3,r6
 320688c:	39ffffc4 	addi	r7,r7,-1
 3206890:	38800003 	ldbu	r2,0(r7)
 3206894:	18ffffc4 	addi	r3,r3,-1
 3206898:	18800005 	stb	r2,0(r3)
 320689c:	19bffb1e 	bne	r3,r6,320688c <memmove+0x20>
 32068a0:	2005883a 	mov	r2,r4
 32068a4:	f800283a 	ret
 32068a8:	01c003c4 	movi	r7,15
 32068ac:	39800a36 	bltu	r7,r6,32068d8 <memmove+0x6c>
 32068b0:	303ffb26 	beq	r6,zero,32068a0 <memmove+0x34>
 32068b4:	400f883a 	mov	r7,r8
 32068b8:	320d883a 	add	r6,r6,r8
 32068bc:	28800003 	ldbu	r2,0(r5)
 32068c0:	29400044 	addi	r5,r5,1
 32068c4:	38800005 	stb	r2,0(r7)
 32068c8:	39c00044 	addi	r7,r7,1
 32068cc:	39bffb1e 	bne	r7,r6,32068bc <memmove+0x50>
 32068d0:	2005883a 	mov	r2,r4
 32068d4:	f800283a 	ret
 32068d8:	1904b03a 	or	r2,r3,r4
 32068dc:	108000cc 	andi	r2,r2,3
 32068e0:	103ff31e 	bne	r2,zero,32068b0 <memmove+0x44>
 32068e4:	3811883a 	mov	r8,r7
 32068e8:	180b883a 	mov	r5,r3
 32068ec:	200f883a 	mov	r7,r4
 32068f0:	28c00017 	ldw	r3,0(r5)
 32068f4:	31bffc04 	addi	r6,r6,-16
 32068f8:	38c00015 	stw	r3,0(r7)
 32068fc:	28800117 	ldw	r2,4(r5)
 3206900:	38800115 	stw	r2,4(r7)
 3206904:	28c00217 	ldw	r3,8(r5)
 3206908:	38c00215 	stw	r3,8(r7)
 320690c:	28800317 	ldw	r2,12(r5)
 3206910:	29400404 	addi	r5,r5,16
 3206914:	38800315 	stw	r2,12(r7)
 3206918:	39c00404 	addi	r7,r7,16
 320691c:	41bff436 	bltu	r8,r6,32068f0 <memmove+0x84>
 3206920:	008000c4 	movi	r2,3
 3206924:	1180072e 	bgeu	r2,r6,3206944 <memmove+0xd8>
 3206928:	1007883a 	mov	r3,r2
 320692c:	28800017 	ldw	r2,0(r5)
 3206930:	31bfff04 	addi	r6,r6,-4
 3206934:	29400104 	addi	r5,r5,4
 3206938:	38800015 	stw	r2,0(r7)
 320693c:	39c00104 	addi	r7,r7,4
 3206940:	19bffa36 	bltu	r3,r6,320692c <memmove+0xc0>
 3206944:	3811883a 	mov	r8,r7
 3206948:	003fd906 	br	32068b0 <memmove+0x44>

0320694c <memset>:
 320694c:	008000c4 	movi	r2,3
 3206950:	29403fcc 	andi	r5,r5,255
 3206954:	2007883a 	mov	r3,r4
 3206958:	1180022e 	bgeu	r2,r6,3206964 <memset+0x18>
 320695c:	2084703a 	and	r2,r4,r2
 3206960:	10000826 	beq	r2,zero,3206984 <memset+0x38>
 3206964:	30000526 	beq	r6,zero,320697c <memset+0x30>
 3206968:	2805883a 	mov	r2,r5
 320696c:	30cd883a 	add	r6,r6,r3
 3206970:	18800005 	stb	r2,0(r3)
 3206974:	18c00044 	addi	r3,r3,1
 3206978:	19bffd1e 	bne	r3,r6,3206970 <memset+0x24>
 320697c:	2005883a 	mov	r2,r4
 3206980:	f800283a 	ret
 3206984:	2804923a 	slli	r2,r5,8
 3206988:	020003c4 	movi	r8,15
 320698c:	200f883a 	mov	r7,r4
 3206990:	2884b03a 	or	r2,r5,r2
 3206994:	1006943a 	slli	r3,r2,16
 3206998:	10c6b03a 	or	r3,r2,r3
 320699c:	41800a2e 	bgeu	r8,r6,32069c8 <memset+0x7c>
 32069a0:	4005883a 	mov	r2,r8
 32069a4:	31bffc04 	addi	r6,r6,-16
 32069a8:	38c00015 	stw	r3,0(r7)
 32069ac:	38c00115 	stw	r3,4(r7)
 32069b0:	38c00215 	stw	r3,8(r7)
 32069b4:	38c00315 	stw	r3,12(r7)
 32069b8:	39c00404 	addi	r7,r7,16
 32069bc:	11bff936 	bltu	r2,r6,32069a4 <memset+0x58>
 32069c0:	008000c4 	movi	r2,3
 32069c4:	1180052e 	bgeu	r2,r6,32069dc <memset+0x90>
 32069c8:	31bfff04 	addi	r6,r6,-4
 32069cc:	008000c4 	movi	r2,3
 32069d0:	38c00015 	stw	r3,0(r7)
 32069d4:	39c00104 	addi	r7,r7,4
 32069d8:	11bffb36 	bltu	r2,r6,32069c8 <memset+0x7c>
 32069dc:	3807883a 	mov	r3,r7
 32069e0:	003fe006 	br	3206964 <memset+0x18>

032069e4 <_open_r>:
 32069e4:	defffd04 	addi	sp,sp,-12
 32069e8:	dc000015 	stw	r16,0(sp)
 32069ec:	0400c974 	movhi	r16,805
 32069f0:	84120d04 	addi	r16,r16,18484
 32069f4:	dc400115 	stw	r17,4(sp)
 32069f8:	80000015 	stw	zero,0(r16)
 32069fc:	2023883a 	mov	r17,r4
 3206a00:	2809883a 	mov	r4,r5
 3206a04:	300b883a 	mov	r5,r6
 3206a08:	380d883a 	mov	r6,r7
 3206a0c:	dfc00215 	stw	ra,8(sp)
 3206a10:	3214c600 	call	3214c60 <open>
 3206a14:	1007883a 	mov	r3,r2
 3206a18:	00bfffc4 	movi	r2,-1
 3206a1c:	18800626 	beq	r3,r2,3206a38 <_open_r+0x54>
 3206a20:	1805883a 	mov	r2,r3
 3206a24:	dfc00217 	ldw	ra,8(sp)
 3206a28:	dc400117 	ldw	r17,4(sp)
 3206a2c:	dc000017 	ldw	r16,0(sp)
 3206a30:	dec00304 	addi	sp,sp,12
 3206a34:	f800283a 	ret
 3206a38:	80800017 	ldw	r2,0(r16)
 3206a3c:	103ff826 	beq	r2,zero,3206a20 <_open_r+0x3c>
 3206a40:	88800015 	stw	r2,0(r17)
 3206a44:	1805883a 	mov	r2,r3
 3206a48:	dfc00217 	ldw	ra,8(sp)
 3206a4c:	dc400117 	ldw	r17,4(sp)
 3206a50:	dc000017 	ldw	r16,0(sp)
 3206a54:	dec00304 	addi	sp,sp,12
 3206a58:	f800283a 	ret

03206a5c <_perror_r>:
 3206a5c:	defffe04 	addi	sp,sp,-8
 3206a60:	dc000015 	stw	r16,0(sp)
 3206a64:	dfc00115 	stw	ra,4(sp)
 3206a68:	2021883a 	mov	r16,r4
 3206a6c:	28000326 	beq	r5,zero,3206a7c <_perror_r+0x20>
 3206a70:	28800007 	ldb	r2,0(r5)
 3206a74:	2809883a 	mov	r4,r5
 3206a78:	10000c1e 	bne	r2,zero,3206aac <_perror_r+0x50>
 3206a7c:	81000017 	ldw	r4,0(r16)
 3206a80:	3207ad00 	call	3207ad0 <strerror>
 3206a84:	1009883a 	mov	r4,r2
 3206a88:	10000226 	beq	r2,zero,3206a94 <_perror_r+0x38>
 3206a8c:	81400317 	ldw	r5,12(r16)
 3206a90:	3204cc40 	call	3204cc4 <fputs>
 3206a94:	81400317 	ldw	r5,12(r16)
 3206a98:	01000284 	movi	r4,10
 3206a9c:	dfc00117 	ldw	ra,4(sp)
 3206aa0:	dc000017 	ldw	r16,0(sp)
 3206aa4:	dec00204 	addi	sp,sp,8
 3206aa8:	320d4441 	jmpi	320d444 <fputc>
 3206aac:	81400317 	ldw	r5,12(r16)
 3206ab0:	3204cc40 	call	3204cc4 <fputs>
 3206ab4:	81400317 	ldw	r5,12(r16)
 3206ab8:	0100c974 	movhi	r4,805
 3206abc:	2135bf04 	addi	r4,r4,-10500
 3206ac0:	3204cc40 	call	3204cc4 <fputs>
 3206ac4:	003fed06 	br	3206a7c <_perror_r+0x20>

03206ac8 <perror>:
 3206ac8:	0080c974 	movhi	r2,805
 3206acc:	10897804 	addi	r2,r2,9696
 3206ad0:	200b883a 	mov	r5,r4
 3206ad4:	11000017 	ldw	r4,0(r2)
 3206ad8:	3206a5c1 	jmpi	3206a5c <_perror_r>

03206adc <printf>:
 3206adc:	defffb04 	addi	sp,sp,-20
 3206ae0:	dfc00115 	stw	ra,4(sp)
 3206ae4:	d9400215 	stw	r5,8(sp)
 3206ae8:	d9800315 	stw	r6,12(sp)
 3206aec:	d9c00415 	stw	r7,16(sp)
 3206af0:	0080c974 	movhi	r2,805
 3206af4:	10897804 	addi	r2,r2,9696
 3206af8:	10c00017 	ldw	r3,0(r2)
 3206afc:	200b883a 	mov	r5,r4
 3206b00:	d8800204 	addi	r2,sp,8
 3206b04:	19000217 	ldw	r4,8(r3)
 3206b08:	100d883a 	mov	r6,r2
 3206b0c:	d8800015 	stw	r2,0(sp)
 3206b10:	320a0c40 	call	320a0c4 <__vfprintf_internal>
 3206b14:	dfc00117 	ldw	ra,4(sp)
 3206b18:	dec00504 	addi	sp,sp,20
 3206b1c:	f800283a 	ret

03206b20 <_printf_r>:
 3206b20:	defffc04 	addi	sp,sp,-16
 3206b24:	dfc00115 	stw	ra,4(sp)
 3206b28:	d9800215 	stw	r6,8(sp)
 3206b2c:	d9c00315 	stw	r7,12(sp)
 3206b30:	280d883a 	mov	r6,r5
 3206b34:	21400217 	ldw	r5,8(r4)
 3206b38:	d8c00204 	addi	r3,sp,8
 3206b3c:	180f883a 	mov	r7,r3
 3206b40:	d8c00015 	stw	r3,0(sp)
 3206b44:	32082180 	call	3208218 <___vfprintf_internal_r>
 3206b48:	dfc00117 	ldw	ra,4(sp)
 3206b4c:	dec00404 	addi	sp,sp,16
 3206b50:	f800283a 	ret

03206b54 <putc>:
 3206b54:	defffc04 	addi	sp,sp,-16
 3206b58:	dc800215 	stw	r18,8(sp)
 3206b5c:	0480c974 	movhi	r18,805
 3206b60:	94897804 	addi	r18,r18,9696
 3206b64:	90c00017 	ldw	r3,0(r18)
 3206b68:	dc400115 	stw	r17,4(sp)
 3206b6c:	dc000015 	stw	r16,0(sp)
 3206b70:	dfc00315 	stw	ra,12(sp)
 3206b74:	2023883a 	mov	r17,r4
 3206b78:	2821883a 	mov	r16,r5
 3206b7c:	18000226 	beq	r3,zero,3206b88 <putc+0x34>
 3206b80:	18800e17 	ldw	r2,56(r3)
 3206b84:	10001126 	beq	r2,zero,3206bcc <putc+0x78>
 3206b88:	80800217 	ldw	r2,8(r16)
 3206b8c:	10ffffc4 	addi	r3,r2,-1
 3206b90:	80c00215 	stw	r3,8(r16)
 3206b94:	18001316 	blt	r3,zero,3206be4 <putc+0x90>
 3206b98:	80800017 	ldw	r2,0(r16)
 3206b9c:	14400005 	stb	r17,0(r2)
 3206ba0:	80c00017 	ldw	r3,0(r16)
 3206ba4:	18800044 	addi	r2,r3,1
 3206ba8:	18c00003 	ldbu	r3,0(r3)
 3206bac:	80800015 	stw	r2,0(r16)
 3206bb0:	1805883a 	mov	r2,r3
 3206bb4:	dfc00317 	ldw	ra,12(sp)
 3206bb8:	dc800217 	ldw	r18,8(sp)
 3206bbc:	dc400117 	ldw	r17,4(sp)
 3206bc0:	dc000017 	ldw	r16,0(sp)
 3206bc4:	dec00404 	addi	sp,sp,16
 3206bc8:	f800283a 	ret
 3206bcc:	1809883a 	mov	r4,r3
 3206bd0:	32048880 	call	3204888 <__sinit>
 3206bd4:	80800217 	ldw	r2,8(r16)
 3206bd8:	10ffffc4 	addi	r3,r2,-1
 3206bdc:	80c00215 	stw	r3,8(r16)
 3206be0:	183fed0e 	bge	r3,zero,3206b98 <putc+0x44>
 3206be4:	80800617 	ldw	r2,24(r16)
 3206be8:	18800f16 	blt	r3,r2,3206c28 <putc+0xd4>
 3206bec:	80800017 	ldw	r2,0(r16)
 3206bf0:	14400005 	stb	r17,0(r2)
 3206bf4:	81000017 	ldw	r4,0(r16)
 3206bf8:	00800284 	movi	r2,10
 3206bfc:	20c00003 	ldbu	r3,0(r4)
 3206c00:	18801226 	beq	r3,r2,3206c4c <putc+0xf8>
 3206c04:	20800044 	addi	r2,r4,1
 3206c08:	80800015 	stw	r2,0(r16)
 3206c0c:	1805883a 	mov	r2,r3
 3206c10:	dfc00317 	ldw	ra,12(sp)
 3206c14:	dc800217 	ldw	r18,8(sp)
 3206c18:	dc400117 	ldw	r17,4(sp)
 3206c1c:	dc000017 	ldw	r16,0(sp)
 3206c20:	dec00404 	addi	sp,sp,16
 3206c24:	f800283a 	ret
 3206c28:	91000017 	ldw	r4,0(r18)
 3206c2c:	880b883a 	mov	r5,r17
 3206c30:	800d883a 	mov	r6,r16
 3206c34:	dfc00317 	ldw	ra,12(sp)
 3206c38:	dc800217 	ldw	r18,8(sp)
 3206c3c:	dc400117 	ldw	r17,4(sp)
 3206c40:	dc000017 	ldw	r16,0(sp)
 3206c44:	dec00404 	addi	sp,sp,16
 3206c48:	320b8681 	jmpi	320b868 <__swbuf_r>
 3206c4c:	91000017 	ldw	r4,0(r18)
 3206c50:	180b883a 	mov	r5,r3
 3206c54:	003ff606 	br	3206c30 <putc+0xdc>

03206c58 <_putc_r>:
 3206c58:	defffc04 	addi	sp,sp,-16
 3206c5c:	dc400215 	stw	r17,8(sp)
 3206c60:	dc000115 	stw	r16,4(sp)
 3206c64:	dfc00315 	stw	ra,12(sp)
 3206c68:	2021883a 	mov	r16,r4
 3206c6c:	2823883a 	mov	r17,r5
 3206c70:	20000226 	beq	r4,zero,3206c7c <_putc_r+0x24>
 3206c74:	20800e17 	ldw	r2,56(r4)
 3206c78:	10001026 	beq	r2,zero,3206cbc <_putc_r+0x64>
 3206c7c:	30800217 	ldw	r2,8(r6)
 3206c80:	10ffffc4 	addi	r3,r2,-1
 3206c84:	30c00215 	stw	r3,8(r6)
 3206c88:	18001316 	blt	r3,zero,3206cd8 <_putc_r+0x80>
 3206c8c:	30800017 	ldw	r2,0(r6)
 3206c90:	14400005 	stb	r17,0(r2)
 3206c94:	30c00017 	ldw	r3,0(r6)
 3206c98:	18800044 	addi	r2,r3,1
 3206c9c:	18c00003 	ldbu	r3,0(r3)
 3206ca0:	30800015 	stw	r2,0(r6)
 3206ca4:	1805883a 	mov	r2,r3
 3206ca8:	dfc00317 	ldw	ra,12(sp)
 3206cac:	dc400217 	ldw	r17,8(sp)
 3206cb0:	dc000117 	ldw	r16,4(sp)
 3206cb4:	dec00404 	addi	sp,sp,16
 3206cb8:	f800283a 	ret
 3206cbc:	d9800015 	stw	r6,0(sp)
 3206cc0:	32048880 	call	3204888 <__sinit>
 3206cc4:	d9800017 	ldw	r6,0(sp)
 3206cc8:	30800217 	ldw	r2,8(r6)
 3206ccc:	10ffffc4 	addi	r3,r2,-1
 3206cd0:	30c00215 	stw	r3,8(r6)
 3206cd4:	183fed0e 	bge	r3,zero,3206c8c <_putc_r+0x34>
 3206cd8:	30800617 	ldw	r2,24(r6)
 3206cdc:	18800e16 	blt	r3,r2,3206d18 <_putc_r+0xc0>
 3206ce0:	30800017 	ldw	r2,0(r6)
 3206ce4:	14400005 	stb	r17,0(r2)
 3206ce8:	31000017 	ldw	r4,0(r6)
 3206cec:	00800284 	movi	r2,10
 3206cf0:	20c00003 	ldbu	r3,0(r4)
 3206cf4:	18800f26 	beq	r3,r2,3206d34 <_putc_r+0xdc>
 3206cf8:	20800044 	addi	r2,r4,1
 3206cfc:	30800015 	stw	r2,0(r6)
 3206d00:	1805883a 	mov	r2,r3
 3206d04:	dfc00317 	ldw	ra,12(sp)
 3206d08:	dc400217 	ldw	r17,8(sp)
 3206d0c:	dc000117 	ldw	r16,4(sp)
 3206d10:	dec00404 	addi	sp,sp,16
 3206d14:	f800283a 	ret
 3206d18:	8009883a 	mov	r4,r16
 3206d1c:	880b883a 	mov	r5,r17
 3206d20:	dfc00317 	ldw	ra,12(sp)
 3206d24:	dc400217 	ldw	r17,8(sp)
 3206d28:	dc000117 	ldw	r16,4(sp)
 3206d2c:	dec00404 	addi	sp,sp,16
 3206d30:	320b8681 	jmpi	320b868 <__swbuf_r>
 3206d34:	8009883a 	mov	r4,r16
 3206d38:	180b883a 	mov	r5,r3
 3206d3c:	003ff806 	br	3206d20 <_putc_r+0xc8>

03206d40 <putchar>:
 3206d40:	0080c974 	movhi	r2,805
 3206d44:	10897804 	addi	r2,r2,9696
 3206d48:	11800017 	ldw	r6,0(r2)
 3206d4c:	200b883a 	mov	r5,r4
 3206d50:	3009883a 	mov	r4,r6
 3206d54:	31800217 	ldw	r6,8(r6)
 3206d58:	3206c581 	jmpi	3206c58 <_putc_r>

03206d5c <_putchar_r>:
 3206d5c:	21800217 	ldw	r6,8(r4)
 3206d60:	3206c581 	jmpi	3206c58 <_putc_r>

03206d64 <_puts_r>:
 3206d64:	defff604 	addi	sp,sp,-40
 3206d68:	dc400715 	stw	r17,28(sp)
 3206d6c:	2023883a 	mov	r17,r4
 3206d70:	2809883a 	mov	r4,r5
 3206d74:	dfc00915 	stw	ra,36(sp)
 3206d78:	dcc00815 	stw	r19,32(sp)
 3206d7c:	2827883a 	mov	r19,r5
 3206d80:	32081440 	call	3208144 <strlen>
 3206d84:	89400217 	ldw	r5,8(r17)
 3206d88:	00c0c974 	movhi	r3,805
 3206d8c:	18f5c004 	addi	r3,r3,-10496
 3206d90:	01c00044 	movi	r7,1
 3206d94:	12000044 	addi	r8,r2,1
 3206d98:	d8c00515 	stw	r3,20(sp)
 3206d9c:	d9c00615 	stw	r7,24(sp)
 3206da0:	d8c00304 	addi	r3,sp,12
 3206da4:	01c00084 	movi	r7,2
 3206da8:	8809883a 	mov	r4,r17
 3206dac:	d80d883a 	mov	r6,sp
 3206db0:	d8c00015 	stw	r3,0(sp)
 3206db4:	dcc00315 	stw	r19,12(sp)
 3206db8:	da000215 	stw	r8,8(sp)
 3206dbc:	d9c00115 	stw	r7,4(sp)
 3206dc0:	d8800415 	stw	r2,16(sp)
 3206dc4:	32055f40 	call	32055f4 <__sfvwrite_r>
 3206dc8:	00ffffc4 	movi	r3,-1
 3206dcc:	10000626 	beq	r2,zero,3206de8 <_puts_r+0x84>
 3206dd0:	1805883a 	mov	r2,r3
 3206dd4:	dfc00917 	ldw	ra,36(sp)
 3206dd8:	dcc00817 	ldw	r19,32(sp)
 3206ddc:	dc400717 	ldw	r17,28(sp)
 3206de0:	dec00a04 	addi	sp,sp,40
 3206de4:	f800283a 	ret
 3206de8:	00c00284 	movi	r3,10
 3206dec:	1805883a 	mov	r2,r3
 3206df0:	dfc00917 	ldw	ra,36(sp)
 3206df4:	dcc00817 	ldw	r19,32(sp)
 3206df8:	dc400717 	ldw	r17,28(sp)
 3206dfc:	dec00a04 	addi	sp,sp,40
 3206e00:	f800283a 	ret

03206e04 <puts>:
 3206e04:	0080c974 	movhi	r2,805
 3206e08:	10897804 	addi	r2,r2,9696
 3206e0c:	200b883a 	mov	r5,r4
 3206e10:	11000017 	ldw	r4,0(r2)
 3206e14:	3206d641 	jmpi	3206d64 <_puts_r>

03206e18 <_realloc_r>:
 3206e18:	defff404 	addi	sp,sp,-48
 3206e1c:	dd800815 	stw	r22,32(sp)
 3206e20:	dc800415 	stw	r18,16(sp)
 3206e24:	dc400315 	stw	r17,12(sp)
 3206e28:	dfc00b15 	stw	ra,44(sp)
 3206e2c:	df000a15 	stw	fp,40(sp)
 3206e30:	ddc00915 	stw	r23,36(sp)
 3206e34:	dd400715 	stw	r21,28(sp)
 3206e38:	dd000615 	stw	r20,24(sp)
 3206e3c:	dcc00515 	stw	r19,20(sp)
 3206e40:	dc000215 	stw	r16,8(sp)
 3206e44:	2825883a 	mov	r18,r5
 3206e48:	3023883a 	mov	r17,r6
 3206e4c:	202d883a 	mov	r22,r4
 3206e50:	2800c926 	beq	r5,zero,3207178 <_realloc_r+0x360>
 3206e54:	321506c0 	call	321506c <__malloc_lock>
 3206e58:	943ffe04 	addi	r16,r18,-8
 3206e5c:	88c002c4 	addi	r3,r17,11
 3206e60:	00800584 	movi	r2,22
 3206e64:	82000117 	ldw	r8,4(r16)
 3206e68:	10c01b2e 	bgeu	r2,r3,3206ed8 <_realloc_r+0xc0>
 3206e6c:	00bffe04 	movi	r2,-8
 3206e70:	188e703a 	and	r7,r3,r2
 3206e74:	3839883a 	mov	fp,r7
 3206e78:	38001a16 	blt	r7,zero,3206ee4 <_realloc_r+0xcc>
 3206e7c:	e4401936 	bltu	fp,r17,3206ee4 <_realloc_r+0xcc>
 3206e80:	013fff04 	movi	r4,-4
 3206e84:	4126703a 	and	r19,r8,r4
 3206e88:	99c02616 	blt	r19,r7,3206f24 <_realloc_r+0x10c>
 3206e8c:	802b883a 	mov	r21,r16
 3206e90:	9829883a 	mov	r20,r19
 3206e94:	84000204 	addi	r16,r16,8
 3206e98:	a80f883a 	mov	r7,r21
 3206e9c:	a70dc83a 	sub	r6,r20,fp
 3206ea0:	008003c4 	movi	r2,15
 3206ea4:	1180c136 	bltu	r2,r6,32071ac <_realloc_r+0x394>
 3206ea8:	38800117 	ldw	r2,4(r7)
 3206eac:	a549883a 	add	r4,r20,r21
 3206eb0:	1080004c 	andi	r2,r2,1
 3206eb4:	a084b03a 	or	r2,r20,r2
 3206eb8:	38800115 	stw	r2,4(r7)
 3206ebc:	20c00117 	ldw	r3,4(r4)
 3206ec0:	18c00054 	ori	r3,r3,1
 3206ec4:	20c00115 	stw	r3,4(r4)
 3206ec8:	b009883a 	mov	r4,r22
 3206ecc:	32151740 	call	3215174 <__malloc_unlock>
 3206ed0:	8023883a 	mov	r17,r16
 3206ed4:	00000606 	br	3206ef0 <_realloc_r+0xd8>
 3206ed8:	01c00404 	movi	r7,16
 3206edc:	3839883a 	mov	fp,r7
 3206ee0:	e47fe72e 	bgeu	fp,r17,3206e80 <_realloc_r+0x68>
 3206ee4:	00800304 	movi	r2,12
 3206ee8:	0023883a 	mov	r17,zero
 3206eec:	b0800015 	stw	r2,0(r22)
 3206ef0:	8805883a 	mov	r2,r17
 3206ef4:	dfc00b17 	ldw	ra,44(sp)
 3206ef8:	df000a17 	ldw	fp,40(sp)
 3206efc:	ddc00917 	ldw	r23,36(sp)
 3206f00:	dd800817 	ldw	r22,32(sp)
 3206f04:	dd400717 	ldw	r21,28(sp)
 3206f08:	dd000617 	ldw	r20,24(sp)
 3206f0c:	dcc00517 	ldw	r19,20(sp)
 3206f10:	dc800417 	ldw	r18,16(sp)
 3206f14:	dc400317 	ldw	r17,12(sp)
 3206f18:	dc000217 	ldw	r16,8(sp)
 3206f1c:	dec00c04 	addi	sp,sp,48
 3206f20:	f800283a 	ret
 3206f24:	0080c974 	movhi	r2,805
 3206f28:	10829a04 	addi	r2,r2,2664
 3206f2c:	12400217 	ldw	r9,8(r2)
 3206f30:	84cd883a 	add	r6,r16,r19
 3206f34:	802b883a 	mov	r21,r16
 3206f38:	3240b926 	beq	r6,r9,3207220 <_realloc_r+0x408>
 3206f3c:	31400117 	ldw	r5,4(r6)
 3206f40:	00bfff84 	movi	r2,-2
 3206f44:	2884703a 	and	r2,r5,r2
 3206f48:	1185883a 	add	r2,r2,r6
 3206f4c:	10c00117 	ldw	r3,4(r2)
 3206f50:	18c0004c 	andi	r3,r3,1
 3206f54:	1807003a 	cmpeq	r3,r3,zero
 3206f58:	1800a326 	beq	r3,zero,32071e8 <_realloc_r+0x3d0>
 3206f5c:	2908703a 	and	r4,r5,r4
 3206f60:	9929883a 	add	r20,r19,r4
 3206f64:	a1c0a30e 	bge	r20,r7,32071f4 <_realloc_r+0x3dc>
 3206f68:	4080004c 	andi	r2,r8,1
 3206f6c:	1000551e 	bne	r2,zero,32070c4 <_realloc_r+0x2ac>
 3206f70:	80800017 	ldw	r2,0(r16)
 3206f74:	80afc83a 	sub	r23,r16,r2
 3206f78:	b8c00117 	ldw	r3,4(r23)
 3206f7c:	00bfff04 	movi	r2,-4
 3206f80:	1884703a 	and	r2,r3,r2
 3206f84:	30002e26 	beq	r6,zero,3207040 <_realloc_r+0x228>
 3206f88:	3240b926 	beq	r6,r9,3207270 <_realloc_r+0x458>
 3206f8c:	98a9883a 	add	r20,r19,r2
 3206f90:	2509883a 	add	r4,r4,r20
 3206f94:	d9000015 	stw	r4,0(sp)
 3206f98:	21c02a16 	blt	r4,r7,3207044 <_realloc_r+0x22c>
 3206f9c:	30800317 	ldw	r2,12(r6)
 3206fa0:	30c00217 	ldw	r3,8(r6)
 3206fa4:	01400904 	movi	r5,36
 3206fa8:	99bfff04 	addi	r6,r19,-4
 3206fac:	18800315 	stw	r2,12(r3)
 3206fb0:	10c00215 	stw	r3,8(r2)
 3206fb4:	b9000317 	ldw	r4,12(r23)
 3206fb8:	b8800217 	ldw	r2,8(r23)
 3206fbc:	b82b883a 	mov	r21,r23
 3206fc0:	bc000204 	addi	r16,r23,8
 3206fc4:	20800215 	stw	r2,8(r4)
 3206fc8:	11000315 	stw	r4,12(r2)
 3206fcc:	2980e436 	bltu	r5,r6,3207360 <_realloc_r+0x548>
 3206fd0:	008004c4 	movi	r2,19
 3206fd4:	9009883a 	mov	r4,r18
 3206fd8:	8011883a 	mov	r8,r16
 3206fdc:	11800f2e 	bgeu	r2,r6,320701c <_realloc_r+0x204>
 3206fe0:	90800017 	ldw	r2,0(r18)
 3206fe4:	ba000404 	addi	r8,r23,16
 3206fe8:	91000204 	addi	r4,r18,8
 3206fec:	b8800215 	stw	r2,8(r23)
 3206ff0:	90c00117 	ldw	r3,4(r18)
 3206ff4:	008006c4 	movi	r2,27
 3206ff8:	b8c00315 	stw	r3,12(r23)
 3206ffc:	1180072e 	bgeu	r2,r6,320701c <_realloc_r+0x204>
 3207000:	90c00217 	ldw	r3,8(r18)
 3207004:	ba000604 	addi	r8,r23,24
 3207008:	91000404 	addi	r4,r18,16
 320700c:	b8c00415 	stw	r3,16(r23)
 3207010:	90800317 	ldw	r2,12(r18)
 3207014:	b8800515 	stw	r2,20(r23)
 3207018:	3140e726 	beq	r6,r5,32073b8 <_realloc_r+0x5a0>
 320701c:	20800017 	ldw	r2,0(r4)
 3207020:	dd000017 	ldw	r20,0(sp)
 3207024:	b80f883a 	mov	r7,r23
 3207028:	40800015 	stw	r2,0(r8)
 320702c:	20c00117 	ldw	r3,4(r4)
 3207030:	40c00115 	stw	r3,4(r8)
 3207034:	20800217 	ldw	r2,8(r4)
 3207038:	40800215 	stw	r2,8(r8)
 320703c:	003f9706 	br	3206e9c <_realloc_r+0x84>
 3207040:	98a9883a 	add	r20,r19,r2
 3207044:	a1c01f16 	blt	r20,r7,32070c4 <_realloc_r+0x2ac>
 3207048:	b8c00317 	ldw	r3,12(r23)
 320704c:	b8800217 	ldw	r2,8(r23)
 3207050:	99bfff04 	addi	r6,r19,-4
 3207054:	01400904 	movi	r5,36
 3207058:	b82b883a 	mov	r21,r23
 320705c:	18800215 	stw	r2,8(r3)
 3207060:	10c00315 	stw	r3,12(r2)
 3207064:	bc000204 	addi	r16,r23,8
 3207068:	2980c336 	bltu	r5,r6,3207378 <_realloc_r+0x560>
 320706c:	008004c4 	movi	r2,19
 3207070:	9009883a 	mov	r4,r18
 3207074:	8011883a 	mov	r8,r16
 3207078:	11800f2e 	bgeu	r2,r6,32070b8 <_realloc_r+0x2a0>
 320707c:	90800017 	ldw	r2,0(r18)
 3207080:	ba000404 	addi	r8,r23,16
 3207084:	91000204 	addi	r4,r18,8
 3207088:	b8800215 	stw	r2,8(r23)
 320708c:	90c00117 	ldw	r3,4(r18)
 3207090:	008006c4 	movi	r2,27
 3207094:	b8c00315 	stw	r3,12(r23)
 3207098:	1180072e 	bgeu	r2,r6,32070b8 <_realloc_r+0x2a0>
 320709c:	90c00217 	ldw	r3,8(r18)
 32070a0:	ba000604 	addi	r8,r23,24
 32070a4:	91000404 	addi	r4,r18,16
 32070a8:	b8c00415 	stw	r3,16(r23)
 32070ac:	90800317 	ldw	r2,12(r18)
 32070b0:	b8800515 	stw	r2,20(r23)
 32070b4:	3140c726 	beq	r6,r5,32073d4 <_realloc_r+0x5bc>
 32070b8:	20800017 	ldw	r2,0(r4)
 32070bc:	b80f883a 	mov	r7,r23
 32070c0:	003fd906 	br	3207028 <_realloc_r+0x210>
 32070c4:	880b883a 	mov	r5,r17
 32070c8:	b009883a 	mov	r4,r22
 32070cc:	3205fa80 	call	3205fa8 <_malloc_r>
 32070d0:	1023883a 	mov	r17,r2
 32070d4:	10002526 	beq	r2,zero,320716c <_realloc_r+0x354>
 32070d8:	80800117 	ldw	r2,4(r16)
 32070dc:	00ffff84 	movi	r3,-2
 32070e0:	893ffe04 	addi	r4,r17,-8
 32070e4:	10c4703a 	and	r2,r2,r3
 32070e8:	8085883a 	add	r2,r16,r2
 32070ec:	20809526 	beq	r4,r2,3207344 <_realloc_r+0x52c>
 32070f0:	99bfff04 	addi	r6,r19,-4
 32070f4:	01c00904 	movi	r7,36
 32070f8:	39804536 	bltu	r7,r6,3207210 <_realloc_r+0x3f8>
 32070fc:	008004c4 	movi	r2,19
 3207100:	9009883a 	mov	r4,r18
 3207104:	880b883a 	mov	r5,r17
 3207108:	11800f2e 	bgeu	r2,r6,3207148 <_realloc_r+0x330>
 320710c:	90800017 	ldw	r2,0(r18)
 3207110:	89400204 	addi	r5,r17,8
 3207114:	91000204 	addi	r4,r18,8
 3207118:	88800015 	stw	r2,0(r17)
 320711c:	90c00117 	ldw	r3,4(r18)
 3207120:	008006c4 	movi	r2,27
 3207124:	88c00115 	stw	r3,4(r17)
 3207128:	1180072e 	bgeu	r2,r6,3207148 <_realloc_r+0x330>
 320712c:	90c00217 	ldw	r3,8(r18)
 3207130:	89400404 	addi	r5,r17,16
 3207134:	91000404 	addi	r4,r18,16
 3207138:	88c00215 	stw	r3,8(r17)
 320713c:	90800317 	ldw	r2,12(r18)
 3207140:	88800315 	stw	r2,12(r17)
 3207144:	31c09126 	beq	r6,r7,320738c <_realloc_r+0x574>
 3207148:	20800017 	ldw	r2,0(r4)
 320714c:	28800015 	stw	r2,0(r5)
 3207150:	20c00117 	ldw	r3,4(r4)
 3207154:	28c00115 	stw	r3,4(r5)
 3207158:	20800217 	ldw	r2,8(r4)
 320715c:	28800215 	stw	r2,8(r5)
 3207160:	900b883a 	mov	r5,r18
 3207164:	b009883a 	mov	r4,r22
 3207168:	3204e0c0 	call	3204e0c <_free_r>
 320716c:	b009883a 	mov	r4,r22
 3207170:	32151740 	call	3215174 <__malloc_unlock>
 3207174:	003f5e06 	br	3206ef0 <_realloc_r+0xd8>
 3207178:	300b883a 	mov	r5,r6
 320717c:	dfc00b17 	ldw	ra,44(sp)
 3207180:	df000a17 	ldw	fp,40(sp)
 3207184:	ddc00917 	ldw	r23,36(sp)
 3207188:	dd800817 	ldw	r22,32(sp)
 320718c:	dd400717 	ldw	r21,28(sp)
 3207190:	dd000617 	ldw	r20,24(sp)
 3207194:	dcc00517 	ldw	r19,20(sp)
 3207198:	dc800417 	ldw	r18,16(sp)
 320719c:	dc400317 	ldw	r17,12(sp)
 32071a0:	dc000217 	ldw	r16,8(sp)
 32071a4:	dec00c04 	addi	sp,sp,48
 32071a8:	3205fa81 	jmpi	3205fa8 <_malloc_r>
 32071ac:	38800117 	ldw	r2,4(r7)
 32071b0:	e54b883a 	add	r5,fp,r21
 32071b4:	31000054 	ori	r4,r6,1
 32071b8:	1080004c 	andi	r2,r2,1
 32071bc:	1704b03a 	or	r2,r2,fp
 32071c0:	38800115 	stw	r2,4(r7)
 32071c4:	29000115 	stw	r4,4(r5)
 32071c8:	2987883a 	add	r3,r5,r6
 32071cc:	18800117 	ldw	r2,4(r3)
 32071d0:	29400204 	addi	r5,r5,8
 32071d4:	b009883a 	mov	r4,r22
 32071d8:	10800054 	ori	r2,r2,1
 32071dc:	18800115 	stw	r2,4(r3)
 32071e0:	3204e0c0 	call	3204e0c <_free_r>
 32071e4:	003f3806 	br	3206ec8 <_realloc_r+0xb0>
 32071e8:	000d883a 	mov	r6,zero
 32071ec:	0009883a 	mov	r4,zero
 32071f0:	003f5d06 	br	3206f68 <_realloc_r+0x150>
 32071f4:	30c00217 	ldw	r3,8(r6)
 32071f8:	30800317 	ldw	r2,12(r6)
 32071fc:	800f883a 	mov	r7,r16
 3207200:	84000204 	addi	r16,r16,8
 3207204:	10c00215 	stw	r3,8(r2)
 3207208:	18800315 	stw	r2,12(r3)
 320720c:	003f2306 	br	3206e9c <_realloc_r+0x84>
 3207210:	8809883a 	mov	r4,r17
 3207214:	900b883a 	mov	r5,r18
 3207218:	320686c0 	call	320686c <memmove>
 320721c:	003fd006 	br	3207160 <_realloc_r+0x348>
 3207220:	30800117 	ldw	r2,4(r6)
 3207224:	e0c00404 	addi	r3,fp,16
 3207228:	1108703a 	and	r4,r2,r4
 320722c:	9905883a 	add	r2,r19,r4
 3207230:	10ff4d16 	blt	r2,r3,3206f68 <_realloc_r+0x150>
 3207234:	1705c83a 	sub	r2,r2,fp
 3207238:	870b883a 	add	r5,r16,fp
 320723c:	10800054 	ori	r2,r2,1
 3207240:	28800115 	stw	r2,4(r5)
 3207244:	80c00117 	ldw	r3,4(r16)
 3207248:	0080c974 	movhi	r2,805
 320724c:	10829a04 	addi	r2,r2,2664
 3207250:	b009883a 	mov	r4,r22
 3207254:	18c0004c 	andi	r3,r3,1
 3207258:	e0c6b03a 	or	r3,fp,r3
 320725c:	11400215 	stw	r5,8(r2)
 3207260:	80c00115 	stw	r3,4(r16)
 3207264:	32151740 	call	3215174 <__malloc_unlock>
 3207268:	84400204 	addi	r17,r16,8
 320726c:	003f2006 	br	3206ef0 <_realloc_r+0xd8>
 3207270:	98a9883a 	add	r20,r19,r2
 3207274:	2509883a 	add	r4,r4,r20
 3207278:	e0800404 	addi	r2,fp,16
 320727c:	d9000115 	stw	r4,4(sp)
 3207280:	20bf7016 	blt	r4,r2,3207044 <_realloc_r+0x22c>
 3207284:	b8c00317 	ldw	r3,12(r23)
 3207288:	b8800217 	ldw	r2,8(r23)
 320728c:	99bfff04 	addi	r6,r19,-4
 3207290:	01400904 	movi	r5,36
 3207294:	18800215 	stw	r2,8(r3)
 3207298:	10c00315 	stw	r3,12(r2)
 320729c:	bc400204 	addi	r17,r23,8
 32072a0:	29804136 	bltu	r5,r6,32073a8 <_realloc_r+0x590>
 32072a4:	008004c4 	movi	r2,19
 32072a8:	9009883a 	mov	r4,r18
 32072ac:	880f883a 	mov	r7,r17
 32072b0:	11800f2e 	bgeu	r2,r6,32072f0 <_realloc_r+0x4d8>
 32072b4:	90800017 	ldw	r2,0(r18)
 32072b8:	b9c00404 	addi	r7,r23,16
 32072bc:	91000204 	addi	r4,r18,8
 32072c0:	b8800215 	stw	r2,8(r23)
 32072c4:	90c00117 	ldw	r3,4(r18)
 32072c8:	008006c4 	movi	r2,27
 32072cc:	b8c00315 	stw	r3,12(r23)
 32072d0:	1180072e 	bgeu	r2,r6,32072f0 <_realloc_r+0x4d8>
 32072d4:	90c00217 	ldw	r3,8(r18)
 32072d8:	b9c00604 	addi	r7,r23,24
 32072dc:	91000404 	addi	r4,r18,16
 32072e0:	b8c00415 	stw	r3,16(r23)
 32072e4:	90800317 	ldw	r2,12(r18)
 32072e8:	b8800515 	stw	r2,20(r23)
 32072ec:	31404026 	beq	r6,r5,32073f0 <_realloc_r+0x5d8>
 32072f0:	20800017 	ldw	r2,0(r4)
 32072f4:	38800015 	stw	r2,0(r7)
 32072f8:	20c00117 	ldw	r3,4(r4)
 32072fc:	38c00115 	stw	r3,4(r7)
 3207300:	20800217 	ldw	r2,8(r4)
 3207304:	38800215 	stw	r2,8(r7)
 3207308:	d8c00117 	ldw	r3,4(sp)
 320730c:	bf0b883a 	add	r5,r23,fp
 3207310:	b009883a 	mov	r4,r22
 3207314:	1f05c83a 	sub	r2,r3,fp
 3207318:	10800054 	ori	r2,r2,1
 320731c:	28800115 	stw	r2,4(r5)
 3207320:	b8c00117 	ldw	r3,4(r23)
 3207324:	0080c974 	movhi	r2,805
 3207328:	10829a04 	addi	r2,r2,2664
 320732c:	11400215 	stw	r5,8(r2)
 3207330:	18c0004c 	andi	r3,r3,1
 3207334:	e0c6b03a 	or	r3,fp,r3
 3207338:	b8c00115 	stw	r3,4(r23)
 320733c:	32151740 	call	3215174 <__malloc_unlock>
 3207340:	003eeb06 	br	3206ef0 <_realloc_r+0xd8>
 3207344:	20800117 	ldw	r2,4(r4)
 3207348:	00ffff04 	movi	r3,-4
 320734c:	800f883a 	mov	r7,r16
 3207350:	10c4703a 	and	r2,r2,r3
 3207354:	98a9883a 	add	r20,r19,r2
 3207358:	84000204 	addi	r16,r16,8
 320735c:	003ecf06 	br	3206e9c <_realloc_r+0x84>
 3207360:	900b883a 	mov	r5,r18
 3207364:	8009883a 	mov	r4,r16
 3207368:	320686c0 	call	320686c <memmove>
 320736c:	dd000017 	ldw	r20,0(sp)
 3207370:	b80f883a 	mov	r7,r23
 3207374:	003ec906 	br	3206e9c <_realloc_r+0x84>
 3207378:	900b883a 	mov	r5,r18
 320737c:	8009883a 	mov	r4,r16
 3207380:	320686c0 	call	320686c <memmove>
 3207384:	b80f883a 	mov	r7,r23
 3207388:	003ec406 	br	3206e9c <_realloc_r+0x84>
 320738c:	90c00417 	ldw	r3,16(r18)
 3207390:	89400604 	addi	r5,r17,24
 3207394:	91000604 	addi	r4,r18,24
 3207398:	88c00415 	stw	r3,16(r17)
 320739c:	90800517 	ldw	r2,20(r18)
 32073a0:	88800515 	stw	r2,20(r17)
 32073a4:	003f6806 	br	3207148 <_realloc_r+0x330>
 32073a8:	900b883a 	mov	r5,r18
 32073ac:	8809883a 	mov	r4,r17
 32073b0:	320686c0 	call	320686c <memmove>
 32073b4:	003fd406 	br	3207308 <_realloc_r+0x4f0>
 32073b8:	90c00417 	ldw	r3,16(r18)
 32073bc:	91000604 	addi	r4,r18,24
 32073c0:	ba000804 	addi	r8,r23,32
 32073c4:	b8c00615 	stw	r3,24(r23)
 32073c8:	90800517 	ldw	r2,20(r18)
 32073cc:	b8800715 	stw	r2,28(r23)
 32073d0:	003f1206 	br	320701c <_realloc_r+0x204>
 32073d4:	90c00417 	ldw	r3,16(r18)
 32073d8:	91000604 	addi	r4,r18,24
 32073dc:	ba000804 	addi	r8,r23,32
 32073e0:	b8c00615 	stw	r3,24(r23)
 32073e4:	90800517 	ldw	r2,20(r18)
 32073e8:	b8800715 	stw	r2,28(r23)
 32073ec:	003f3206 	br	32070b8 <_realloc_r+0x2a0>
 32073f0:	90c00417 	ldw	r3,16(r18)
 32073f4:	91000604 	addi	r4,r18,24
 32073f8:	b9c00804 	addi	r7,r23,32
 32073fc:	b8c00615 	stw	r3,24(r23)
 3207400:	90800517 	ldw	r2,20(r18)
 3207404:	b8800715 	stw	r2,28(r23)
 3207408:	003fb906 	br	32072f0 <_realloc_r+0x4d8>

0320740c <__srefill_r>:
 320740c:	defffd04 	addi	sp,sp,-12
 3207410:	dc400115 	stw	r17,4(sp)
 3207414:	dc000015 	stw	r16,0(sp)
 3207418:	dfc00215 	stw	ra,8(sp)
 320741c:	2023883a 	mov	r17,r4
 3207420:	2821883a 	mov	r16,r5
 3207424:	20000226 	beq	r4,zero,3207430 <__srefill_r+0x24>
 3207428:	20800e17 	ldw	r2,56(r4)
 320742c:	10004126 	beq	r2,zero,3207534 <__srefill_r+0x128>
 3207430:	80c0030b 	ldhu	r3,12(r16)
 3207434:	80000115 	stw	zero,4(r16)
 3207438:	1880080c 	andi	r2,r3,32
 320743c:	1000361e 	bne	r2,zero,3207518 <__srefill_r+0x10c>
 3207440:	1880010c 	andi	r2,r3,4
 3207444:	1000211e 	bne	r2,zero,32074cc <__srefill_r+0xc0>
 3207448:	1880040c 	andi	r2,r3,16
 320744c:	10005026 	beq	r2,zero,3207590 <__srefill_r+0x184>
 3207450:	1880020c 	andi	r2,r3,8
 3207454:	1000541e 	bne	r2,zero,32075a8 <__srefill_r+0x19c>
 3207458:	8080030b 	ldhu	r2,12(r16)
 320745c:	10800114 	ori	r2,r2,4
 3207460:	8080030d 	sth	r2,12(r16)
 3207464:	80800417 	ldw	r2,16(r16)
 3207468:	10004526 	beq	r2,zero,3207580 <__srefill_r+0x174>
 320746c:	8080030b 	ldhu	r2,12(r16)
 3207470:	108000cc 	andi	r2,r2,3
 3207474:	1000361e 	bne	r2,zero,3207550 <__srefill_r+0x144>
 3207478:	81800417 	ldw	r6,16(r16)
 320747c:	80c00817 	ldw	r3,32(r16)
 3207480:	81400717 	ldw	r5,28(r16)
 3207484:	81c00517 	ldw	r7,20(r16)
 3207488:	8809883a 	mov	r4,r17
 320748c:	81800015 	stw	r6,0(r16)
 3207490:	183ee83a 	callr	r3
 3207494:	80c0030b 	ldhu	r3,12(r16)
 3207498:	1009883a 	mov	r4,r2
 320749c:	80800115 	stw	r2,4(r16)
 32074a0:	00b7ffc4 	movi	r2,-8193
 32074a4:	1884703a 	and	r2,r3,r2
 32074a8:	8080030d 	sth	r2,12(r16)
 32074ac:	0100230e 	bge	zero,r4,320753c <__srefill_r+0x130>
 32074b0:	0009883a 	mov	r4,zero
 32074b4:	2005883a 	mov	r2,r4
 32074b8:	dfc00217 	ldw	ra,8(sp)
 32074bc:	dc400117 	ldw	r17,4(sp)
 32074c0:	dc000017 	ldw	r16,0(sp)
 32074c4:	dec00304 	addi	sp,sp,12
 32074c8:	f800283a 	ret
 32074cc:	81400c17 	ldw	r5,48(r16)
 32074d0:	283fe426 	beq	r5,zero,3207464 <__srefill_r+0x58>
 32074d4:	80801004 	addi	r2,r16,64
 32074d8:	28800226 	beq	r5,r2,32074e4 <__srefill_r+0xd8>
 32074dc:	8809883a 	mov	r4,r17
 32074e0:	3204e0c0 	call	3204e0c <_free_r>
 32074e4:	80800f17 	ldw	r2,60(r16)
 32074e8:	80000c15 	stw	zero,48(r16)
 32074ec:	80800115 	stw	r2,4(r16)
 32074f0:	103fdc26 	beq	r2,zero,3207464 <__srefill_r+0x58>
 32074f4:	80800e17 	ldw	r2,56(r16)
 32074f8:	0009883a 	mov	r4,zero
 32074fc:	80800015 	stw	r2,0(r16)
 3207500:	2005883a 	mov	r2,r4
 3207504:	dfc00217 	ldw	ra,8(sp)
 3207508:	dc400117 	ldw	r17,4(sp)
 320750c:	dc000017 	ldw	r16,0(sp)
 3207510:	dec00304 	addi	sp,sp,12
 3207514:	f800283a 	ret
 3207518:	013fffc4 	movi	r4,-1
 320751c:	2005883a 	mov	r2,r4
 3207520:	dfc00217 	ldw	ra,8(sp)
 3207524:	dc400117 	ldw	r17,4(sp)
 3207528:	dc000017 	ldw	r16,0(sp)
 320752c:	dec00304 	addi	sp,sp,12
 3207530:	f800283a 	ret
 3207534:	32048880 	call	3204888 <__sinit>
 3207538:	003fbd06 	br	3207430 <__srefill_r+0x24>
 320753c:	20000b1e 	bne	r4,zero,320756c <__srefill_r+0x160>
 3207540:	10800814 	ori	r2,r2,32
 3207544:	013fffc4 	movi	r4,-1
 3207548:	8080030d 	sth	r2,12(r16)
 320754c:	003fd906 	br	32074b4 <__srefill_r+0xa8>
 3207550:	0080c974 	movhi	r2,805
 3207554:	10897904 	addi	r2,r2,9700
 3207558:	11000017 	ldw	r4,0(r2)
 320755c:	0140c834 	movhi	r5,800
 3207560:	295d7404 	addi	r5,r5,30160
 3207564:	3205b580 	call	3205b58 <_fwalk>
 3207568:	003fc306 	br	3207478 <__srefill_r+0x6c>
 320756c:	10801014 	ori	r2,r2,64
 3207570:	013fffc4 	movi	r4,-1
 3207574:	8080030d 	sth	r2,12(r16)
 3207578:	80000115 	stw	zero,4(r16)
 320757c:	003fcd06 	br	32074b4 <__srefill_r+0xa8>
 3207580:	8809883a 	mov	r4,r17
 3207584:	800b883a 	mov	r5,r16
 3207588:	3205e140 	call	3205e14 <__smakebuf_r>
 320758c:	003fb706 	br	320746c <__srefill_r+0x60>
 3207590:	18c01014 	ori	r3,r3,64
 3207594:	00800244 	movi	r2,9
 3207598:	013fffc4 	movi	r4,-1
 320759c:	88800015 	stw	r2,0(r17)
 32075a0:	80c0030d 	sth	r3,12(r16)
 32075a4:	003fc306 	br	32074b4 <__srefill_r+0xa8>
 32075a8:	8809883a 	mov	r4,r17
 32075ac:	800b883a 	mov	r5,r16
 32075b0:	32045f00 	call	32045f0 <_fflush_r>
 32075b4:	103fd81e 	bne	r2,zero,3207518 <__srefill_r+0x10c>
 32075b8:	8080030b 	ldhu	r2,12(r16)
 32075bc:	80000215 	stw	zero,8(r16)
 32075c0:	80000615 	stw	zero,24(r16)
 32075c4:	10bffdcc 	andi	r2,r2,65527
 32075c8:	8080030d 	sth	r2,12(r16)
 32075cc:	003fa206 	br	3207458 <__srefill_r+0x4c>

032075d0 <lflush>:
 32075d0:	20c0030b 	ldhu	r3,12(r4)
 32075d4:	01400244 	movi	r5,9
 32075d8:	0005883a 	mov	r2,zero
 32075dc:	18c0024c 	andi	r3,r3,9
 32075e0:	19400126 	beq	r3,r5,32075e8 <lflush+0x18>
 32075e4:	f800283a 	ret
 32075e8:	32047ec1 	jmpi	32047ec <fflush>

032075ec <__srget_r>:
 32075ec:	defffe04 	addi	sp,sp,-8
 32075f0:	dc000015 	stw	r16,0(sp)
 32075f4:	dfc00115 	stw	ra,4(sp)
 32075f8:	2821883a 	mov	r16,r5
 32075fc:	320740c0 	call	320740c <__srefill_r>
 3207600:	013fffc4 	movi	r4,-1
 3207604:	1000071e 	bne	r2,zero,3207624 <__srget_r+0x38>
 3207608:	80800117 	ldw	r2,4(r16)
 320760c:	81000017 	ldw	r4,0(r16)
 3207610:	10bfffc4 	addi	r2,r2,-1
 3207614:	20c00044 	addi	r3,r4,1
 3207618:	80800115 	stw	r2,4(r16)
 320761c:	21000003 	ldbu	r4,0(r4)
 3207620:	80c00015 	stw	r3,0(r16)
 3207624:	2005883a 	mov	r2,r4
 3207628:	dfc00117 	ldw	ra,4(sp)
 320762c:	dc000017 	ldw	r16,0(sp)
 3207630:	dec00204 	addi	sp,sp,8
 3207634:	f800283a 	ret

03207638 <__srget>:
 3207638:	0080c974 	movhi	r2,805
 320763c:	10897804 	addi	r2,r2,9696
 3207640:	200b883a 	mov	r5,r4
 3207644:	11000017 	ldw	r4,0(r2)
 3207648:	32075ec1 	jmpi	32075ec <__srget_r>

0320764c <_sbrk_r>:
 320764c:	defffd04 	addi	sp,sp,-12
 3207650:	dc000015 	stw	r16,0(sp)
 3207654:	0400c974 	movhi	r16,805
 3207658:	84120d04 	addi	r16,r16,18484
 320765c:	dc400115 	stw	r17,4(sp)
 3207660:	80000015 	stw	zero,0(r16)
 3207664:	2023883a 	mov	r17,r4
 3207668:	2809883a 	mov	r4,r5
 320766c:	dfc00215 	stw	ra,8(sp)
 3207670:	3214ea80 	call	3214ea8 <sbrk>
 3207674:	1007883a 	mov	r3,r2
 3207678:	00bfffc4 	movi	r2,-1
 320767c:	18800626 	beq	r3,r2,3207698 <_sbrk_r+0x4c>
 3207680:	1805883a 	mov	r2,r3
 3207684:	dfc00217 	ldw	ra,8(sp)
 3207688:	dc400117 	ldw	r17,4(sp)
 320768c:	dc000017 	ldw	r16,0(sp)
 3207690:	dec00304 	addi	sp,sp,12
 3207694:	f800283a 	ret
 3207698:	80800017 	ldw	r2,0(r16)
 320769c:	103ff826 	beq	r2,zero,3207680 <_sbrk_r+0x34>
 32076a0:	88800015 	stw	r2,0(r17)
 32076a4:	1805883a 	mov	r2,r3
 32076a8:	dfc00217 	ldw	ra,8(sp)
 32076ac:	dc400117 	ldw	r17,4(sp)
 32076b0:	dc000017 	ldw	r16,0(sp)
 32076b4:	dec00304 	addi	sp,sp,12
 32076b8:	f800283a 	ret

032076bc <sprintf>:
 32076bc:	deffe504 	addi	sp,sp,-108
 32076c0:	2013883a 	mov	r9,r4
 32076c4:	dfc01815 	stw	ra,96(sp)
 32076c8:	d9801915 	stw	r6,100(sp)
 32076cc:	d9c01a15 	stw	r7,104(sp)
 32076d0:	d8801904 	addi	r2,sp,100
 32076d4:	d8800015 	stw	r2,0(sp)
 32076d8:	0080c974 	movhi	r2,805
 32076dc:	10897804 	addi	r2,r2,9696
 32076e0:	11000017 	ldw	r4,0(r2)
 32076e4:	d9c00017 	ldw	r7,0(sp)
 32076e8:	00808204 	movi	r2,520
 32076ec:	00e00034 	movhi	r3,32768
 32076f0:	18ffffc4 	addi	r3,r3,-1
 32076f4:	280d883a 	mov	r6,r5
 32076f8:	d880040d 	sth	r2,16(sp)
 32076fc:	d9400104 	addi	r5,sp,4
 3207700:	00bfffc4 	movi	r2,-1
 3207704:	d8c00615 	stw	r3,24(sp)
 3207708:	d8c00315 	stw	r3,12(sp)
 320770c:	da400515 	stw	r9,20(sp)
 3207710:	d880048d 	sth	r2,18(sp)
 3207714:	da400115 	stw	r9,4(sp)
 3207718:	32082180 	call	3208218 <___vfprintf_internal_r>
 320771c:	d8c00117 	ldw	r3,4(sp)
 3207720:	18000005 	stb	zero,0(r3)
 3207724:	dfc01817 	ldw	ra,96(sp)
 3207728:	dec01b04 	addi	sp,sp,108
 320772c:	f800283a 	ret

03207730 <_sprintf_r>:
 3207730:	deffe604 	addi	sp,sp,-104
 3207734:	2813883a 	mov	r9,r5
 3207738:	dfc01815 	stw	ra,96(sp)
 320773c:	d9c01915 	stw	r7,100(sp)
 3207740:	d8801904 	addi	r2,sp,100
 3207744:	d8800015 	stw	r2,0(sp)
 3207748:	100f883a 	mov	r7,r2
 320774c:	00808204 	movi	r2,520
 3207750:	00e00034 	movhi	r3,32768
 3207754:	18ffffc4 	addi	r3,r3,-1
 3207758:	d880040d 	sth	r2,16(sp)
 320775c:	d9400104 	addi	r5,sp,4
 3207760:	00bfffc4 	movi	r2,-1
 3207764:	d8c00615 	stw	r3,24(sp)
 3207768:	d8c00315 	stw	r3,12(sp)
 320776c:	da400515 	stw	r9,20(sp)
 3207770:	d880048d 	sth	r2,18(sp)
 3207774:	da400115 	stw	r9,4(sp)
 3207778:	32082180 	call	3208218 <___vfprintf_internal_r>
 320777c:	d8c00117 	ldw	r3,4(sp)
 3207780:	18000005 	stb	zero,0(r3)
 3207784:	dfc01817 	ldw	ra,96(sp)
 3207788:	dec01a04 	addi	sp,sp,104
 320778c:	f800283a 	ret

03207790 <eofread>:
 3207790:	0005883a 	mov	r2,zero
 3207794:	f800283a 	ret

03207798 <_sscanf_r>:
 3207798:	deffe404 	addi	sp,sp,-112
 320779c:	dcc01915 	stw	r19,100(sp)
 32077a0:	2027883a 	mov	r19,r4
 32077a4:	dfc01a15 	stw	ra,104(sp)
 32077a8:	dc401815 	stw	r17,96(sp)
 32077ac:	d9c01b15 	stw	r7,108(sp)
 32077b0:	00808104 	movi	r2,516
 32077b4:	2809883a 	mov	r4,r5
 32077b8:	3023883a 	mov	r17,r6
 32077bc:	d9400115 	stw	r5,4(sp)
 32077c0:	d9400515 	stw	r5,20(sp)
 32077c4:	d880040d 	sth	r2,16(sp)
 32077c8:	32081440 	call	3208144 <strlen>
 32077cc:	d8c01b04 	addi	r3,sp,108
 32077d0:	d8c00015 	stw	r3,0(sp)
 32077d4:	180f883a 	mov	r7,r3
 32077d8:	023fffc4 	movi	r8,-1
 32077dc:	00c0c834 	movhi	r3,800
 32077e0:	18dde404 	addi	r3,r3,30608
 32077e4:	9809883a 	mov	r4,r19
 32077e8:	880d883a 	mov	r6,r17
 32077ec:	d9400104 	addi	r5,sp,4
 32077f0:	d8800615 	stw	r2,24(sp)
 32077f4:	d8c00915 	stw	r3,36(sp)
 32077f8:	da00048d 	sth	r8,18(sp)
 32077fc:	d8800215 	stw	r2,8(sp)
 3207800:	d8000d15 	stw	zero,52(sp)
 3207804:	d8001215 	stw	zero,72(sp)
 3207808:	320a0e80 	call	320a0e8 <__svfscanf_r>
 320780c:	dfc01a17 	ldw	ra,104(sp)
 3207810:	dcc01917 	ldw	r19,100(sp)
 3207814:	dc401817 	ldw	r17,96(sp)
 3207818:	dec01c04 	addi	sp,sp,112
 320781c:	f800283a 	ret

03207820 <sscanf>:
 3207820:	deffe404 	addi	sp,sp,-112
 3207824:	dfc01915 	stw	ra,100(sp)
 3207828:	dc401815 	stw	r17,96(sp)
 320782c:	d9801a15 	stw	r6,104(sp)
 3207830:	d9c01b15 	stw	r7,108(sp)
 3207834:	00808104 	movi	r2,516
 3207838:	2823883a 	mov	r17,r5
 320783c:	d9000515 	stw	r4,20(sp)
 3207840:	d9000115 	stw	r4,4(sp)
 3207844:	d880040d 	sth	r2,16(sp)
 3207848:	32081440 	call	3208144 <strlen>
 320784c:	d8c01a04 	addi	r3,sp,104
 3207850:	d8c00015 	stw	r3,0(sp)
 3207854:	00c0c974 	movhi	r3,805
 3207858:	18c97804 	addi	r3,r3,9696
 320785c:	19000017 	ldw	r4,0(r3)
 3207860:	d9c00017 	ldw	r7,0(sp)
 3207864:	00c0c834 	movhi	r3,800
 3207868:	18dde404 	addi	r3,r3,30608
 320786c:	023fffc4 	movi	r8,-1
 3207870:	880d883a 	mov	r6,r17
 3207874:	d9400104 	addi	r5,sp,4
 3207878:	d8800615 	stw	r2,24(sp)
 320787c:	d8c00915 	stw	r3,36(sp)
 3207880:	da00048d 	sth	r8,18(sp)
 3207884:	d8800215 	stw	r2,8(sp)
 3207888:	d8000d15 	stw	zero,52(sp)
 320788c:	d8001215 	stw	zero,72(sp)
 3207890:	320a0e80 	call	320a0e8 <__svfscanf_r>
 3207894:	dfc01917 	ldw	ra,100(sp)
 3207898:	dc401817 	ldw	r17,96(sp)
 320789c:	dec01c04 	addi	sp,sp,112
 32078a0:	f800283a 	ret

032078a4 <__sclose>:
 32078a4:	2940038f 	ldh	r5,14(r5)
 32078a8:	320bb681 	jmpi	320bb68 <_close_r>

032078ac <__sseek>:
 32078ac:	defffe04 	addi	sp,sp,-8
 32078b0:	dc000015 	stw	r16,0(sp)
 32078b4:	2821883a 	mov	r16,r5
 32078b8:	2940038f 	ldh	r5,14(r5)
 32078bc:	dfc00115 	stw	ra,4(sp)
 32078c0:	320d89c0 	call	320d89c <_lseek_r>
 32078c4:	1007883a 	mov	r3,r2
 32078c8:	00bfffc4 	movi	r2,-1
 32078cc:	18800926 	beq	r3,r2,32078f4 <__sseek+0x48>
 32078d0:	8080030b 	ldhu	r2,12(r16)
 32078d4:	80c01415 	stw	r3,80(r16)
 32078d8:	10840014 	ori	r2,r2,4096
 32078dc:	8080030d 	sth	r2,12(r16)
 32078e0:	1805883a 	mov	r2,r3
 32078e4:	dfc00117 	ldw	ra,4(sp)
 32078e8:	dc000017 	ldw	r16,0(sp)
 32078ec:	dec00204 	addi	sp,sp,8
 32078f0:	f800283a 	ret
 32078f4:	8080030b 	ldhu	r2,12(r16)
 32078f8:	10bbffcc 	andi	r2,r2,61439
 32078fc:	8080030d 	sth	r2,12(r16)
 3207900:	1805883a 	mov	r2,r3
 3207904:	dfc00117 	ldw	ra,4(sp)
 3207908:	dc000017 	ldw	r16,0(sp)
 320790c:	dec00204 	addi	sp,sp,8
 3207910:	f800283a 	ret

03207914 <__swrite>:
 3207914:	2880030b 	ldhu	r2,12(r5)
 3207918:	defffb04 	addi	sp,sp,-20
 320791c:	dcc00315 	stw	r19,12(sp)
 3207920:	1080400c 	andi	r2,r2,256
 3207924:	dc800215 	stw	r18,8(sp)
 3207928:	dc400115 	stw	r17,4(sp)
 320792c:	dc000015 	stw	r16,0(sp)
 3207930:	3027883a 	mov	r19,r6
 3207934:	3825883a 	mov	r18,r7
 3207938:	dfc00415 	stw	ra,16(sp)
 320793c:	2821883a 	mov	r16,r5
 3207940:	000d883a 	mov	r6,zero
 3207944:	01c00084 	movi	r7,2
 3207948:	2023883a 	mov	r17,r4
 320794c:	10000226 	beq	r2,zero,3207958 <__swrite+0x44>
 3207950:	2940038f 	ldh	r5,14(r5)
 3207954:	320d89c0 	call	320d89c <_lseek_r>
 3207958:	8080030b 	ldhu	r2,12(r16)
 320795c:	8140038f 	ldh	r5,14(r16)
 3207960:	8809883a 	mov	r4,r17
 3207964:	10bbffcc 	andi	r2,r2,61439
 3207968:	980d883a 	mov	r6,r19
 320796c:	900f883a 	mov	r7,r18
 3207970:	8080030d 	sth	r2,12(r16)
 3207974:	dfc00417 	ldw	ra,16(sp)
 3207978:	dcc00317 	ldw	r19,12(sp)
 320797c:	dc800217 	ldw	r18,8(sp)
 3207980:	dc400117 	ldw	r17,4(sp)
 3207984:	dc000017 	ldw	r16,0(sp)
 3207988:	dec00504 	addi	sp,sp,20
 320798c:	320b9b41 	jmpi	320b9b4 <_write_r>

03207990 <__sread>:
 3207990:	defffe04 	addi	sp,sp,-8
 3207994:	dc000015 	stw	r16,0(sp)
 3207998:	2821883a 	mov	r16,r5
 320799c:	2940038f 	ldh	r5,14(r5)
 32079a0:	dfc00115 	stw	ra,4(sp)
 32079a4:	320ea080 	call	320ea08 <_read_r>
 32079a8:	1007883a 	mov	r3,r2
 32079ac:	10000816 	blt	r2,zero,32079d0 <__sread+0x40>
 32079b0:	80801417 	ldw	r2,80(r16)
 32079b4:	10c5883a 	add	r2,r2,r3
 32079b8:	80801415 	stw	r2,80(r16)
 32079bc:	1805883a 	mov	r2,r3
 32079c0:	dfc00117 	ldw	ra,4(sp)
 32079c4:	dc000017 	ldw	r16,0(sp)
 32079c8:	dec00204 	addi	sp,sp,8
 32079cc:	f800283a 	ret
 32079d0:	8080030b 	ldhu	r2,12(r16)
 32079d4:	10bbffcc 	andi	r2,r2,61439
 32079d8:	8080030d 	sth	r2,12(r16)
 32079dc:	1805883a 	mov	r2,r3
 32079e0:	dfc00117 	ldw	ra,4(sp)
 32079e4:	dc000017 	ldw	r16,0(sp)
 32079e8:	dec00204 	addi	sp,sp,8
 32079ec:	f800283a 	ret

032079f0 <strchr>:
 32079f0:	208000cc 	andi	r2,r4,3
 32079f4:	2007883a 	mov	r3,r4
 32079f8:	1000311e 	bne	r2,zero,3207ac0 <strchr+0xd0>
 32079fc:	29c03fcc 	andi	r7,r5,255
 3207a00:	0015883a 	mov	r10,zero
 3207a04:	0007883a 	mov	r3,zero
 3207a08:	01400104 	movi	r5,4
 3207a0c:	5004923a 	slli	r2,r10,8
 3207a10:	18c00044 	addi	r3,r3,1
 3207a14:	3894b03a 	or	r10,r7,r2
 3207a18:	197ffc1e 	bne	r3,r5,3207a0c <strchr+0x1c>
 3207a1c:	200d883a 	mov	r6,r4
 3207a20:	21000017 	ldw	r4,0(r4)
 3207a24:	017fbff4 	movhi	r5,65279
 3207a28:	297fbfc4 	addi	r5,r5,-257
 3207a2c:	02202074 	movhi	r8,32897
 3207a30:	42202004 	addi	r8,r8,-32640
 3207a34:	2145883a 	add	r2,r4,r5
 3207a38:	1204703a 	and	r2,r2,r8
 3207a3c:	0106303a 	nor	r3,zero,r4
 3207a40:	10c4703a 	and	r2,r2,r3
 3207a44:	1000151e 	bne	r2,zero,3207a9c <strchr+0xac>
 3207a48:	2284f03a 	xor	r2,r4,r10
 3207a4c:	1147883a 	add	r3,r2,r5
 3207a50:	1a06703a 	and	r3,r3,r8
 3207a54:	0084303a 	nor	r2,zero,r2
 3207a58:	10c4703a 	and	r2,r2,r3
 3207a5c:	10000f1e 	bne	r2,zero,3207a9c <strchr+0xac>
 3207a60:	2813883a 	mov	r9,r5
 3207a64:	00000106 	br	3207a6c <strchr+0x7c>
 3207a68:	18000c1e 	bne	r3,zero,3207a9c <strchr+0xac>
 3207a6c:	31800104 	addi	r6,r6,4
 3207a70:	30800017 	ldw	r2,0(r6)
 3207a74:	1286f03a 	xor	r3,r2,r10
 3207a78:	124b883a 	add	r5,r2,r9
 3207a7c:	1a49883a 	add	r4,r3,r9
 3207a80:	2a0a703a 	and	r5,r5,r8
 3207a84:	0084303a 	nor	r2,zero,r2
 3207a88:	2208703a 	and	r4,r4,r8
 3207a8c:	00c6303a 	nor	r3,zero,r3
 3207a90:	1144703a 	and	r2,r2,r5
 3207a94:	1906703a 	and	r3,r3,r4
 3207a98:	103ff326 	beq	r2,zero,3207a68 <strchr+0x78>
 3207a9c:	3007883a 	mov	r3,r6
 3207aa0:	00000206 	br	3207aac <strchr+0xbc>
 3207aa4:	38800426 	beq	r7,r2,3207ab8 <strchr+0xc8>
 3207aa8:	18c00044 	addi	r3,r3,1
 3207aac:	18800003 	ldbu	r2,0(r3)
 3207ab0:	103ffc1e 	bne	r2,zero,3207aa4 <strchr+0xb4>
 3207ab4:	3800041e 	bne	r7,zero,3207ac8 <strchr+0xd8>
 3207ab8:	1805883a 	mov	r2,r3
 3207abc:	f800283a 	ret
 3207ac0:	29c03fcc 	andi	r7,r5,255
 3207ac4:	003ff906 	br	3207aac <strchr+0xbc>
 3207ac8:	0005883a 	mov	r2,zero
 3207acc:	f800283a 	ret

03207ad0 <strerror>:
 3207ad0:	deffff04 	addi	sp,sp,-4
 3207ad4:	00802184 	movi	r2,134
 3207ad8:	dfc00015 	stw	ra,0(sp)
 3207adc:	200b883a 	mov	r5,r4
 3207ae0:	11008e36 	bltu	r2,r4,3207d1c <strerror+0x24c>
 3207ae4:	2105883a 	add	r2,r4,r4
 3207ae8:	1085883a 	add	r2,r2,r2
 3207aec:	00c0c834 	movhi	r3,800
 3207af0:	18dec004 	addi	r3,r3,31488
 3207af4:	10c5883a 	add	r2,r2,r3
 3207af8:	11000017 	ldw	r4,0(r2)
 3207afc:	2000683a 	jmp	r4
 3207b00:	03207d1c 	xori	r12,zero,33268
 3207b04:	03207d54 	movui	r12,33269
 3207b08:	03207d60 	cmpeqi	r12,zero,-32267
 3207b0c:	03207d6c 	andhi	r12,zero,33269
 3207b10:	03207d78 	rdprs	r12,zero,-32267
 3207b14:	03207d84 	movi	r12,-32266
 3207b18:	03207d90 	cmplti	r12,zero,-32266
 3207b1c:	03207d9c 	xori	r12,zero,33270
 3207b20:	03207da8 	cmpgeui	r12,zero,33270
 3207b24:	03207db4 	movhi	r12,33270
 3207b28:	03207dc0 	call	3207dc <OSCtxSw_SWITCH_PC+0x32079c>
 3207b2c:	03207dcc 	andi	r12,zero,33271
 3207b30:	03207dd8 	cmpnei	r12,zero,-32265
 3207b34:	03207de4 	muli	r12,zero,-32265
 3207b38:	03207df0 	cmpltui	r12,zero,33271
 3207b3c:	03207dfc 	xorhi	r12,zero,33271
 3207b40:	03207e08 	cmpgei	r12,zero,-32264
 3207b44:	03207e14 	movui	r12,33272
 3207b48:	03207e20 	cmpeqi	r12,zero,-32264
 3207b4c:	03207e2c 	andhi	r12,zero,33272
 3207b50:	03207e38 	rdprs	r12,zero,-32264
 3207b54:	03207e44 	movi	r12,-32263
 3207b58:	03207e50 	cmplti	r12,zero,-32263
 3207b5c:	03207e5c 	xori	r12,zero,33273
 3207b60:	03207e68 	cmpgeui	r12,zero,33273
 3207b64:	03207e74 	movhi	r12,33273
 3207b68:	03207e80 	call	3207e8 <OSCtxSw_SWITCH_PC+0x3207a8>
 3207b6c:	03207e8c 	andi	r12,zero,33274
 3207b70:	03207e98 	cmpnei	r12,zero,-32262
 3207b74:	03207ea4 	muli	r12,zero,-32262
 3207b78:	03207eb0 	cmpltui	r12,zero,33274
 3207b7c:	03207ebc 	xorhi	r12,zero,33274
 3207b80:	03207ec8 	cmpgei	r12,zero,-32261
 3207b84:	03207ed4 	movui	r12,33275
 3207b88:	03207ee0 	cmpeqi	r12,zero,-32261
 3207b8c:	03207eec 	andhi	r12,zero,33275
 3207b90:	03207ef8 	rdprs	r12,zero,-32261
 3207b94:	03207d1c 	xori	r12,zero,33268
 3207b98:	03207d1c 	xori	r12,zero,33268
 3207b9c:	03207d1c 	xori	r12,zero,33268
 3207ba0:	03207d1c 	xori	r12,zero,33268
 3207ba4:	03207d1c 	xori	r12,zero,33268
 3207ba8:	03207d1c 	xori	r12,zero,33268
 3207bac:	03207d1c 	xori	r12,zero,33268
 3207bb0:	03207d1c 	xori	r12,zero,33268
 3207bb4:	03207f04 	movi	r12,-32260
 3207bb8:	03207f10 	cmplti	r12,zero,-32260
 3207bbc:	03207d1c 	xori	r12,zero,33268
 3207bc0:	03207d1c 	xori	r12,zero,33268
 3207bc4:	03207d1c 	xori	r12,zero,33268
 3207bc8:	03207d1c 	xori	r12,zero,33268
 3207bcc:	03207d1c 	xori	r12,zero,33268
 3207bd0:	03207d1c 	xori	r12,zero,33268
 3207bd4:	03207d1c 	xori	r12,zero,33268
 3207bd8:	03207d1c 	xori	r12,zero,33268
 3207bdc:	03207d1c 	xori	r12,zero,33268
 3207be0:	03207d1c 	xori	r12,zero,33268
 3207be4:	03207d1c 	xori	r12,zero,33268
 3207be8:	03207d1c 	xori	r12,zero,33268
 3207bec:	03207d1c 	xori	r12,zero,33268
 3207bf0:	03207f1c 	xori	r12,zero,33276
 3207bf4:	03207d1c 	xori	r12,zero,33268
 3207bf8:	03207f28 	cmpgeui	r12,zero,33276
 3207bfc:	03207f34 	movhi	r12,33276
 3207c00:	03207f40 	call	3207f4 <OSCtxSw_SWITCH_PC+0x3207b4>
 3207c04:	03207f4c 	andi	r12,zero,33277
 3207c08:	03207f58 	cmpnei	r12,zero,-32259
 3207c0c:	03207f64 	muli	r12,zero,-32259
 3207c10:	03207f70 	cmpltui	r12,zero,33277
 3207c14:	03207f7c 	xorhi	r12,zero,33277
 3207c18:	03207f88 	cmpgei	r12,zero,-32258
 3207c1c:	03207f94 	movui	r12,33278
 3207c20:	03207d1c 	xori	r12,zero,33268
 3207c24:	03207d1c 	xori	r12,zero,33268
 3207c28:	03207fa0 	cmpeqi	r12,zero,-32258
 3207c2c:	03207d1c 	xori	r12,zero,33268
 3207c30:	03207d1c 	xori	r12,zero,33268
 3207c34:	03207fac 	andhi	r12,zero,33278
 3207c38:	03207d1c 	xori	r12,zero,33268
 3207c3c:	03207d1c 	xori	r12,zero,33268
 3207c40:	03207d1c 	xori	r12,zero,33268
 3207c44:	03207d1c 	xori	r12,zero,33268
 3207c48:	03207d1c 	xori	r12,zero,33268
 3207c4c:	03207fb8 	rdprs	r12,zero,-32258
 3207c50:	03207fc4 	movi	r12,-32257
 3207c54:	03207fd0 	cmplti	r12,zero,-32257
 3207c58:	03207fdc 	xori	r12,zero,33279
 3207c5c:	03207fe8 	cmpgeui	r12,zero,33279
 3207c60:	03207ff4 	movhi	r12,33279
 3207c64:	03208000 	call	320800 <OSCtxSw_SWITCH_PC+0x3207c0>
 3207c68:	0320800c 	andi	r12,zero,33280
 3207c6c:	03208018 	cmpnei	r12,zero,-32256
 3207c70:	03208024 	muli	r12,zero,-32256
 3207c74:	03207d1c 	xori	r12,zero,33268
 3207c78:	03207d1c 	xori	r12,zero,33268
 3207c7c:	03208030 	cmpltui	r12,zero,33280
 3207c80:	03207d1c 	xori	r12,zero,33268
 3207c84:	03207d1c 	xori	r12,zero,33268
 3207c88:	03207d1c 	xori	r12,zero,33268
 3207c8c:	03207d1c 	xori	r12,zero,33268
 3207c90:	03207d1c 	xori	r12,zero,33268
 3207c94:	03207d1c 	xori	r12,zero,33268
 3207c98:	03207d1c 	xori	r12,zero,33268
 3207c9c:	03207d1c 	xori	r12,zero,33268
 3207ca0:	03207d1c 	xori	r12,zero,33268
 3207ca4:	0320803c 	xorhi	r12,zero,33280
 3207ca8:	03208048 	cmpgei	r12,zero,-32255
 3207cac:	03208054 	movui	r12,33281
 3207cb0:	03208060 	cmpeqi	r12,zero,-32255
 3207cb4:	0320806c 	andhi	r12,zero,33281
 3207cb8:	03208078 	rdprs	r12,zero,-32255
 3207cbc:	03208084 	movi	r12,-32254
 3207cc0:	03208090 	cmplti	r12,zero,-32254
 3207cc4:	0320809c 	xori	r12,zero,33282
 3207cc8:	032080a8 	cmpgeui	r12,zero,33282
 3207ccc:	032080b4 	movhi	r12,33282
 3207cd0:	032080c0 	call	32080c <OSCtxSw_SWITCH_PC+0x3207cc>
 3207cd4:	032080cc 	andi	r12,zero,33283
 3207cd8:	032080d8 	cmpnei	r12,zero,-32253
 3207cdc:	032080e4 	muli	r12,zero,-32253
 3207ce0:	032080f0 	cmpltui	r12,zero,33283
 3207ce4:	032080fc 	xorhi	r12,zero,33283
 3207ce8:	03208108 	cmpgei	r12,zero,-32252
 3207cec:	03208114 	movui	r12,33284
 3207cf0:	03208120 	cmpeqi	r12,zero,-32252
 3207cf4:	03207d1c 	xori	r12,zero,33268
 3207cf8:	03207d1c 	xori	r12,zero,33268
 3207cfc:	0320812c 	andhi	r12,zero,33284
 3207d00:	03208138 	rdprs	r12,zero,-32252
 3207d04:	03207d1c 	xori	r12,zero,33268
 3207d08:	03207d1c 	xori	r12,zero,33268
 3207d0c:	03207d1c 	xori	r12,zero,33268
 3207d10:	03207d1c 	xori	r12,zero,33268
 3207d14:	03207d1c 	xori	r12,zero,33268
 3207d18:	03207d48 	cmpgei	r12,zero,-32267
 3207d1c:	2809883a 	mov	r4,r5
 3207d20:	32081b80 	call	32081b8 <_user_strerror>
 3207d24:	10000326 	beq	r2,zero,3207d34 <strerror+0x264>
 3207d28:	dfc00017 	ldw	ra,0(sp)
 3207d2c:	dec00104 	addi	sp,sp,4
 3207d30:	f800283a 	ret
 3207d34:	0080c974 	movhi	r2,805
 3207d38:	10b7b904 	addi	r2,r2,-8476
 3207d3c:	dfc00017 	ldw	ra,0(sp)
 3207d40:	dec00104 	addi	sp,sp,4
 3207d44:	f800283a 	ret
 3207d48:	0080c974 	movhi	r2,805
 3207d4c:	10b67c04 	addi	r2,r2,-9744
 3207d50:	003ff506 	br	3207d28 <strerror+0x258>
 3207d54:	0080c974 	movhi	r2,805
 3207d58:	10b5cc04 	addi	r2,r2,-10448
 3207d5c:	003ff206 	br	3207d28 <strerror+0x258>
 3207d60:	0080c974 	movhi	r2,805
 3207d64:	10b5cf04 	addi	r2,r2,-10436
 3207d68:	003fef06 	br	3207d28 <strerror+0x258>
 3207d6c:	0080c974 	movhi	r2,805
 3207d70:	10b5d604 	addi	r2,r2,-10408
 3207d74:	003fec06 	br	3207d28 <strerror+0x258>
 3207d78:	0080c974 	movhi	r2,805
 3207d7c:	10b5da04 	addi	r2,r2,-10392
 3207d80:	003fe906 	br	3207d28 <strerror+0x258>
 3207d84:	0080c974 	movhi	r2,805
 3207d88:	10b5e004 	addi	r2,r2,-10368
 3207d8c:	003fe606 	br	3207d28 <strerror+0x258>
 3207d90:	0080c974 	movhi	r2,805
 3207d94:	10b5e304 	addi	r2,r2,-10356
 3207d98:	003fe306 	br	3207d28 <strerror+0x258>
 3207d9c:	0080c974 	movhi	r2,805
 3207da0:	10b5ea04 	addi	r2,r2,-10328
 3207da4:	003fe006 	br	3207d28 <strerror+0x258>
 3207da8:	0080c974 	movhi	r2,805
 3207dac:	10b5ef04 	addi	r2,r2,-10308
 3207db0:	003fdd06 	br	3207d28 <strerror+0x258>
 3207db4:	0080c974 	movhi	r2,805
 3207db8:	10b5fb04 	addi	r2,r2,-10260
 3207dbc:	003fda06 	br	3207d28 <strerror+0x258>
 3207dc0:	0080c974 	movhi	r2,805
 3207dc4:	10b5ff04 	addi	r2,r2,-10244
 3207dc8:	003fd706 	br	3207d28 <strerror+0x258>
 3207dcc:	0080c974 	movhi	r2,805
 3207dd0:	10b60a04 	addi	r2,r2,-10200
 3207dd4:	003fd406 	br	3207d28 <strerror+0x258>
 3207dd8:	0080c974 	movhi	r2,805
 3207ddc:	10b60f04 	addi	r2,r2,-10180
 3207de0:	003fd106 	br	3207d28 <strerror+0x258>
 3207de4:	0080c974 	movhi	r2,805
 3207de8:	10b61404 	addi	r2,r2,-10160
 3207dec:	003fce06 	br	3207d28 <strerror+0x258>
 3207df0:	0080c974 	movhi	r2,805
 3207df4:	10b61904 	addi	r2,r2,-10140
 3207df8:	003fcb06 	br	3207d28 <strerror+0x258>
 3207dfc:	0080c974 	movhi	r2,805
 3207e00:	10b61c04 	addi	r2,r2,-10128
 3207e04:	003fc806 	br	3207d28 <strerror+0x258>
 3207e08:	0080c974 	movhi	r2,805
 3207e0c:	10b62204 	addi	r2,r2,-10104
 3207e10:	003fc506 	br	3207d28 <strerror+0x258>
 3207e14:	0080c974 	movhi	r2,805
 3207e18:	10b62804 	addi	r2,r2,-10080
 3207e1c:	003fc206 	br	3207d28 <strerror+0x258>
 3207e20:	0080c974 	movhi	r2,805
 3207e24:	10b62b04 	addi	r2,r2,-10068
 3207e28:	003fbf06 	br	3207d28 <strerror+0x258>
 3207e2c:	0080c974 	movhi	r2,805
 3207e30:	10b63004 	addi	r2,r2,-10048
 3207e34:	003fbc06 	br	3207d28 <strerror+0x258>
 3207e38:	0080c974 	movhi	r2,805
 3207e3c:	10b63404 	addi	r2,r2,-10032
 3207e40:	003fb906 	br	3207d28 <strerror+0x258>
 3207e44:	0080c974 	movhi	r2,805
 3207e48:	10b64404 	addi	r2,r2,-9968
 3207e4c:	003fb606 	br	3207d28 <strerror+0x258>
 3207e50:	0080c974 	movhi	r2,805
 3207e54:	10b64804 	addi	r2,r2,-9952
 3207e58:	003fb306 	br	3207d28 <strerror+0x258>
 3207e5c:	0080c974 	movhi	r2,805
 3207e60:	10b65604 	addi	r2,r2,-9896
 3207e64:	003fb006 	br	3207d28 <strerror+0x258>
 3207e68:	0080c974 	movhi	r2,805
 3207e6c:	10b65e04 	addi	r2,r2,-9864
 3207e70:	003fad06 	br	3207d28 <strerror+0x258>
 3207e74:	0080c974 	movhi	r2,805
 3207e78:	10b66304 	addi	r2,r2,-9844
 3207e7c:	003faa06 	br	3207d28 <strerror+0x258>
 3207e80:	0080c974 	movhi	r2,805
 3207e84:	10b66904 	addi	r2,r2,-9820
 3207e88:	003fa706 	br	3207d28 <strerror+0x258>
 3207e8c:	0080c974 	movhi	r2,805
 3207e90:	10b66d04 	addi	r2,r2,-9804
 3207e94:	003fa406 	br	3207d28 <strerror+0x258>
 3207e98:	0080c974 	movhi	r2,805
 3207e9c:	10b67604 	addi	r2,r2,-9768
 3207ea0:	003fa106 	br	3207d28 <strerror+0x258>
 3207ea4:	0080c974 	movhi	r2,805
 3207ea8:	10b68004 	addi	r2,r2,-9728
 3207eac:	003f9e06 	br	3207d28 <strerror+0x258>
 3207eb0:	0080c974 	movhi	r2,805
 3207eb4:	10b68404 	addi	r2,r2,-9712
 3207eb8:	003f9b06 	br	3207d28 <strerror+0x258>
 3207ebc:	0080c974 	movhi	r2,805
 3207ec0:	10b68a04 	addi	r2,r2,-9688
 3207ec4:	003f9806 	br	3207d28 <strerror+0x258>
 3207ec8:	0080c974 	movhi	r2,805
 3207ecc:	10b68e04 	addi	r2,r2,-9672
 3207ed0:	003f9506 	br	3207d28 <strerror+0x258>
 3207ed4:	0080c974 	movhi	r2,805
 3207ed8:	10b69104 	addi	r2,r2,-9660
 3207edc:	003f9206 	br	3207d28 <strerror+0x258>
 3207ee0:	0080c974 	movhi	r2,805
 3207ee4:	10b69504 	addi	r2,r2,-9644
 3207ee8:	003f8f06 	br	3207d28 <strerror+0x258>
 3207eec:	0080c974 	movhi	r2,805
 3207ef0:	10b69a04 	addi	r2,r2,-9624
 3207ef4:	003f8c06 	br	3207d28 <strerror+0x258>
 3207ef8:	0080c974 	movhi	r2,805
 3207efc:	10b6a104 	addi	r2,r2,-9596
 3207f00:	003f8906 	br	3207d28 <strerror+0x258>
 3207f04:	0080c974 	movhi	r2,805
 3207f08:	10b6a604 	addi	r2,r2,-9576
 3207f0c:	003f8606 	br	3207d28 <strerror+0x258>
 3207f10:	0080c974 	movhi	r2,805
 3207f14:	10b6af04 	addi	r2,r2,-9540
 3207f18:	003f8306 	br	3207d28 <strerror+0x258>
 3207f1c:	0080c974 	movhi	r2,805
 3207f20:	10b6b104 	addi	r2,r2,-9532
 3207f24:	003f8006 	br	3207d28 <strerror+0x258>
 3207f28:	0080c974 	movhi	r2,805
 3207f2c:	10b6b504 	addi	r2,r2,-9516
 3207f30:	003f7d06 	br	3207d28 <strerror+0x258>
 3207f34:	0080c974 	movhi	r2,805
 3207f38:	10b6bb04 	addi	r2,r2,-9492
 3207f3c:	003f7a06 	br	3207d28 <strerror+0x258>
 3207f40:	0080c974 	movhi	r2,805
 3207f44:	10b6c004 	addi	r2,r2,-9472
 3207f48:	003f7706 	br	3207d28 <strerror+0x258>
 3207f4c:	0080c974 	movhi	r2,805
 3207f50:	10b6c804 	addi	r2,r2,-9440
 3207f54:	003f7406 	br	3207d28 <strerror+0x258>
 3207f58:	0080c974 	movhi	r2,805
 3207f5c:	10b6cb04 	addi	r2,r2,-9428
 3207f60:	003f7106 	br	3207d28 <strerror+0x258>
 3207f64:	0080c974 	movhi	r2,805
 3207f68:	10b6d004 	addi	r2,r2,-9408
 3207f6c:	003f6e06 	br	3207d28 <strerror+0x258>
 3207f70:	0080c974 	movhi	r2,805
 3207f74:	10b6d604 	addi	r2,r2,-9384
 3207f78:	003f6b06 	br	3207d28 <strerror+0x258>
 3207f7c:	0080c974 	movhi	r2,805
 3207f80:	10b6da04 	addi	r2,r2,-9368
 3207f84:	003f6806 	br	3207d28 <strerror+0x258>
 3207f88:	0080c974 	movhi	r2,805
 3207f8c:	10b6de04 	addi	r2,r2,-9352
 3207f90:	003f6506 	br	3207d28 <strerror+0x258>
 3207f94:	0080c974 	movhi	r2,805
 3207f98:	10b6e304 	addi	r2,r2,-9332
 3207f9c:	003f6206 	br	3207d28 <strerror+0x258>
 3207fa0:	0080c974 	movhi	r2,805
 3207fa4:	10b6ec04 	addi	r2,r2,-9296
 3207fa8:	003f5f06 	br	3207d28 <strerror+0x258>
 3207fac:	0080c974 	movhi	r2,805
 3207fb0:	10b6f104 	addi	r2,r2,-9276
 3207fb4:	003f5c06 	br	3207d28 <strerror+0x258>
 3207fb8:	0080c974 	movhi	r2,805
 3207fbc:	10b6f404 	addi	r2,r2,-9264
 3207fc0:	003f5906 	br	3207d28 <strerror+0x258>
 3207fc4:	0080c974 	movhi	r2,805
 3207fc8:	10b6fe04 	addi	r2,r2,-9224
 3207fcc:	003f5606 	br	3207d28 <strerror+0x258>
 3207fd0:	0080c974 	movhi	r2,805
 3207fd4:	10b70804 	addi	r2,r2,-9184
 3207fd8:	003f5306 	br	3207d28 <strerror+0x258>
 3207fdc:	0080c974 	movhi	r2,805
 3207fe0:	10b71004 	addi	r2,r2,-9152
 3207fe4:	003f5006 	br	3207d28 <strerror+0x258>
 3207fe8:	0080c974 	movhi	r2,805
 3207fec:	10b72004 	addi	r2,r2,-9088
 3207ff0:	003f4d06 	br	3207d28 <strerror+0x258>
 3207ff4:	0080c974 	movhi	r2,805
 3207ff8:	10b72a04 	addi	r2,r2,-9048
 3207ffc:	003f4a06 	br	3207d28 <strerror+0x258>
 3208000:	0080c974 	movhi	r2,805
 3208004:	10b73104 	addi	r2,r2,-9020
 3208008:	003f4706 	br	3207d28 <strerror+0x258>
 320800c:	0080c974 	movhi	r2,805
 3208010:	10b73504 	addi	r2,r2,-9004
 3208014:	003f4406 	br	3207d28 <strerror+0x258>
 3208018:	0080c974 	movhi	r2,805
 320801c:	10b73a04 	addi	r2,r2,-8984
 3208020:	003f4106 	br	3207d28 <strerror+0x258>
 3208024:	0080c974 	movhi	r2,805
 3208028:	10b74104 	addi	r2,r2,-8956
 320802c:	003f3e06 	br	3207d28 <strerror+0x258>
 3208030:	0080c974 	movhi	r2,805
 3208034:	10b7a104 	addi	r2,r2,-8572
 3208038:	003f3b06 	br	3207d28 <strerror+0x258>
 320803c:	0080c974 	movhi	r2,805
 3208040:	10b74704 	addi	r2,r2,-8932
 3208044:	003f3806 	br	3207d28 <strerror+0x258>
 3208048:	0080c974 	movhi	r2,805
 320804c:	10b74e04 	addi	r2,r2,-8904
 3208050:	003f3506 	br	3207d28 <strerror+0x258>
 3208054:	0080c974 	movhi	r2,805
 3208058:	10b75a04 	addi	r2,r2,-8856
 320805c:	003f3206 	br	3207d28 <strerror+0x258>
 3208060:	0080c974 	movhi	r2,805
 3208064:	10b76204 	addi	r2,r2,-8824
 3208068:	003f2f06 	br	3207d28 <strerror+0x258>
 320806c:	0080c974 	movhi	r2,805
 3208070:	10b76a04 	addi	r2,r2,-8792
 3208074:	003f2c06 	br	3207d28 <strerror+0x258>
 3208078:	0080c974 	movhi	r2,805
 320807c:	10b77004 	addi	r2,r2,-8768
 3208080:	003f2906 	br	3207d28 <strerror+0x258>
 3208084:	0080c974 	movhi	r2,805
 3208088:	10b77904 	addi	r2,r2,-8732
 320808c:	003f2606 	br	3207d28 <strerror+0x258>
 3208090:	0080c974 	movhi	r2,805
 3208094:	10b77e04 	addi	r2,r2,-8712
 3208098:	003f2306 	br	3207d28 <strerror+0x258>
 320809c:	0080c974 	movhi	r2,805
 32080a0:	10b78404 	addi	r2,r2,-8688
 32080a4:	003f2006 	br	3207d28 <strerror+0x258>
 32080a8:	0080c974 	movhi	r2,805
 32080ac:	10b6a904 	addi	r2,r2,-9564
 32080b0:	003f1d06 	br	3207d28 <strerror+0x258>
 32080b4:	0080c974 	movhi	r2,805
 32080b8:	10b64d04 	addi	r2,r2,-9932
 32080bc:	003f1a06 	br	3207d28 <strerror+0x258>
 32080c0:	0080c974 	movhi	r2,805
 32080c4:	10b5c604 	addi	r2,r2,-10472
 32080c8:	003f1706 	br	3207d28 <strerror+0x258>
 32080cc:	0080c974 	movhi	r2,805
 32080d0:	10b63804 	addi	r2,r2,-10016
 32080d4:	003f1406 	br	3207d28 <strerror+0x258>
 32080d8:	0080c974 	movhi	r2,805
 32080dc:	10b67104 	addi	r2,r2,-9788
 32080e0:	003f1106 	br	3207d28 <strerror+0x258>
 32080e4:	0080c974 	movhi	r2,805
 32080e8:	10b63c04 	addi	r2,r2,-10000
 32080ec:	003f0e06 	br	3207d28 <strerror+0x258>
 32080f0:	0080c974 	movhi	r2,805
 32080f4:	10b5f404 	addi	r2,r2,-10288
 32080f8:	003f0b06 	br	3207d28 <strerror+0x258>
 32080fc:	0080c974 	movhi	r2,805
 3208100:	10b60204 	addi	r2,r2,-10232
 3208104:	003f0806 	br	3207d28 <strerror+0x258>
 3208108:	0080c974 	movhi	r2,805
 320810c:	10b5c104 	addi	r2,r2,-10492
 3208110:	003f0506 	br	3207d28 <strerror+0x258>
 3208114:	0080c974 	movhi	r2,805
 3208118:	10b6e704 	addi	r2,r2,-9316
 320811c:	003f0206 	br	3207d28 <strerror+0x258>
 3208120:	0080c974 	movhi	r2,805
 3208124:	10b79304 	addi	r2,r2,-8628
 3208128:	003eff06 	br	3207d28 <strerror+0x258>
 320812c:	0080c974 	movhi	r2,805
 3208130:	10b79a04 	addi	r2,r2,-8600
 3208134:	003efc06 	br	3207d28 <strerror+0x258>
 3208138:	0080c974 	movhi	r2,805
 320813c:	10b78d04 	addi	r2,r2,-8652
 3208140:	003ef906 	br	3207d28 <strerror+0x258>

03208144 <strlen>:
 3208144:	208000cc 	andi	r2,r4,3
 3208148:	2011883a 	mov	r8,r4
 320814c:	1000161e 	bne	r2,zero,32081a8 <strlen+0x64>
 3208150:	20c00017 	ldw	r3,0(r4)
 3208154:	017fbff4 	movhi	r5,65279
 3208158:	297fbfc4 	addi	r5,r5,-257
 320815c:	01e02074 	movhi	r7,32897
 3208160:	39e02004 	addi	r7,r7,-32640
 3208164:	1945883a 	add	r2,r3,r5
 3208168:	11c4703a 	and	r2,r2,r7
 320816c:	00c6303a 	nor	r3,zero,r3
 3208170:	1886703a 	and	r3,r3,r2
 3208174:	18000c1e 	bne	r3,zero,32081a8 <strlen+0x64>
 3208178:	280d883a 	mov	r6,r5
 320817c:	380b883a 	mov	r5,r7
 3208180:	21000104 	addi	r4,r4,4
 3208184:	20800017 	ldw	r2,0(r4)
 3208188:	1187883a 	add	r3,r2,r6
 320818c:	1946703a 	and	r3,r3,r5
 3208190:	0084303a 	nor	r2,zero,r2
 3208194:	10c4703a 	and	r2,r2,r3
 3208198:	103ff926 	beq	r2,zero,3208180 <strlen+0x3c>
 320819c:	20800007 	ldb	r2,0(r4)
 32081a0:	10000326 	beq	r2,zero,32081b0 <strlen+0x6c>
 32081a4:	21000044 	addi	r4,r4,1
 32081a8:	20800007 	ldb	r2,0(r4)
 32081ac:	103ffd1e 	bne	r2,zero,32081a4 <strlen+0x60>
 32081b0:	2205c83a 	sub	r2,r4,r8
 32081b4:	f800283a 	ret

032081b8 <_user_strerror>:
 32081b8:	0005883a 	mov	r2,zero
 32081bc:	f800283a 	ret

032081c0 <__sprint_r>:
 32081c0:	30800217 	ldw	r2,8(r6)
 32081c4:	defffe04 	addi	sp,sp,-8
 32081c8:	dc000015 	stw	r16,0(sp)
 32081cc:	dfc00115 	stw	ra,4(sp)
 32081d0:	3021883a 	mov	r16,r6
 32081d4:	0007883a 	mov	r3,zero
 32081d8:	1000061e 	bne	r2,zero,32081f4 <__sprint_r+0x34>
 32081dc:	1805883a 	mov	r2,r3
 32081e0:	30000115 	stw	zero,4(r6)
 32081e4:	dfc00117 	ldw	ra,4(sp)
 32081e8:	dc000017 	ldw	r16,0(sp)
 32081ec:	dec00204 	addi	sp,sp,8
 32081f0:	f800283a 	ret
 32081f4:	32055f40 	call	32055f4 <__sfvwrite_r>
 32081f8:	1007883a 	mov	r3,r2
 32081fc:	1805883a 	mov	r2,r3
 3208200:	80000115 	stw	zero,4(r16)
 3208204:	80000215 	stw	zero,8(r16)
 3208208:	dfc00117 	ldw	ra,4(sp)
 320820c:	dc000017 	ldw	r16,0(sp)
 3208210:	dec00204 	addi	sp,sp,8
 3208214:	f800283a 	ret

03208218 <___vfprintf_internal_r>:
 3208218:	defea404 	addi	sp,sp,-1392
 320821c:	dd815815 	stw	r22,1376(sp)
 3208220:	dc015215 	stw	r16,1352(sp)
 3208224:	d9c15115 	stw	r7,1348(sp)
 3208228:	dfc15b15 	stw	ra,1388(sp)
 320822c:	df015a15 	stw	fp,1384(sp)
 3208230:	ddc15915 	stw	r23,1380(sp)
 3208234:	dd415715 	stw	r21,1372(sp)
 3208238:	dd015615 	stw	r20,1368(sp)
 320823c:	dcc15515 	stw	r19,1364(sp)
 3208240:	dc815415 	stw	r18,1360(sp)
 3208244:	dc415315 	stw	r17,1356(sp)
 3208248:	282d883a 	mov	r22,r5
 320824c:	3021883a 	mov	r16,r6
 3208250:	d9014f15 	stw	r4,1340(sp)
 3208254:	320d7e00 	call	320d7e0 <_localeconv_r>
 3208258:	10800017 	ldw	r2,0(r2)
 320825c:	d9c15117 	ldw	r7,1348(sp)
 3208260:	d8814915 	stw	r2,1316(sp)
 3208264:	d8814f17 	ldw	r2,1340(sp)
 3208268:	10000226 	beq	r2,zero,3208274 <___vfprintf_internal_r+0x5c>
 320826c:	10800e17 	ldw	r2,56(r2)
 3208270:	10020d26 	beq	r2,zero,3208aa8 <___vfprintf_internal_r+0x890>
 3208274:	b080030b 	ldhu	r2,12(r22)
 3208278:	1080020c 	andi	r2,r2,8
 320827c:	10020e26 	beq	r2,zero,3208ab8 <___vfprintf_internal_r+0x8a0>
 3208280:	b0800417 	ldw	r2,16(r22)
 3208284:	10020c26 	beq	r2,zero,3208ab8 <___vfprintf_internal_r+0x8a0>
 3208288:	b200030b 	ldhu	r8,12(r22)
 320828c:	00800284 	movi	r2,10
 3208290:	40c0068c 	andi	r3,r8,26
 3208294:	18802f1e 	bne	r3,r2,3208354 <___vfprintf_internal_r+0x13c>
 3208298:	b080038f 	ldh	r2,14(r22)
 320829c:	10002d16 	blt	r2,zero,3208354 <___vfprintf_internal_r+0x13c>
 32082a0:	b240038b 	ldhu	r9,14(r22)
 32082a4:	b2800717 	ldw	r10,28(r22)
 32082a8:	b2c00917 	ldw	r11,36(r22)
 32082ac:	d9014f17 	ldw	r4,1340(sp)
 32082b0:	dc402904 	addi	r17,sp,164
 32082b4:	d8804004 	addi	r2,sp,256
 32082b8:	00c10004 	movi	r3,1024
 32082bc:	423fff4c 	andi	r8,r8,65533
 32082c0:	800d883a 	mov	r6,r16
 32082c4:	880b883a 	mov	r5,r17
 32082c8:	da002c0d 	sth	r8,176(sp)
 32082cc:	da402c8d 	sth	r9,178(sp)
 32082d0:	da803015 	stw	r10,192(sp)
 32082d4:	dac03215 	stw	r11,200(sp)
 32082d8:	d8802d15 	stw	r2,180(sp)
 32082dc:	d8c02e15 	stw	r3,184(sp)
 32082e0:	d8802915 	stw	r2,164(sp)
 32082e4:	d8c02b15 	stw	r3,172(sp)
 32082e8:	d8002f15 	stw	zero,188(sp)
 32082ec:	32082180 	call	3208218 <___vfprintf_internal_r>
 32082f0:	d8814b15 	stw	r2,1324(sp)
 32082f4:	10000416 	blt	r2,zero,3208308 <___vfprintf_internal_r+0xf0>
 32082f8:	d9014f17 	ldw	r4,1340(sp)
 32082fc:	880b883a 	mov	r5,r17
 3208300:	32045f00 	call	32045f0 <_fflush_r>
 3208304:	1002321e 	bne	r2,zero,3208bd0 <___vfprintf_internal_r+0x9b8>
 3208308:	d8802c0b 	ldhu	r2,176(sp)
 320830c:	1080100c 	andi	r2,r2,64
 3208310:	10000326 	beq	r2,zero,3208320 <___vfprintf_internal_r+0x108>
 3208314:	b080030b 	ldhu	r2,12(r22)
 3208318:	10801014 	ori	r2,r2,64
 320831c:	b080030d 	sth	r2,12(r22)
 3208320:	d8814b17 	ldw	r2,1324(sp)
 3208324:	dfc15b17 	ldw	ra,1388(sp)
 3208328:	df015a17 	ldw	fp,1384(sp)
 320832c:	ddc15917 	ldw	r23,1380(sp)
 3208330:	dd815817 	ldw	r22,1376(sp)
 3208334:	dd415717 	ldw	r21,1372(sp)
 3208338:	dd015617 	ldw	r20,1368(sp)
 320833c:	dcc15517 	ldw	r19,1364(sp)
 3208340:	dc815417 	ldw	r18,1360(sp)
 3208344:	dc415317 	ldw	r17,1356(sp)
 3208348:	dc015217 	ldw	r16,1352(sp)
 320834c:	dec15c04 	addi	sp,sp,1392
 3208350:	f800283a 	ret
 3208354:	0005883a 	mov	r2,zero
 3208358:	0007883a 	mov	r3,zero
 320835c:	dd401904 	addi	r21,sp,100
 3208360:	d8814215 	stw	r2,1288(sp)
 3208364:	802f883a 	mov	r23,r16
 3208368:	d8c14315 	stw	r3,1292(sp)
 320836c:	d8014b15 	stw	zero,1324(sp)
 3208370:	d8014815 	stw	zero,1312(sp)
 3208374:	d8014415 	stw	zero,1296(sp)
 3208378:	d8014715 	stw	zero,1308(sp)
 320837c:	dd400c15 	stw	r21,48(sp)
 3208380:	d8000e15 	stw	zero,56(sp)
 3208384:	d8000d15 	stw	zero,52(sp)
 3208388:	b8800007 	ldb	r2,0(r23)
 320838c:	10001926 	beq	r2,zero,32083f4 <___vfprintf_internal_r+0x1dc>
 3208390:	00c00944 	movi	r3,37
 3208394:	10c01726 	beq	r2,r3,32083f4 <___vfprintf_internal_r+0x1dc>
 3208398:	b821883a 	mov	r16,r23
 320839c:	00000106 	br	32083a4 <___vfprintf_internal_r+0x18c>
 32083a0:	10c00326 	beq	r2,r3,32083b0 <___vfprintf_internal_r+0x198>
 32083a4:	84000044 	addi	r16,r16,1
 32083a8:	80800007 	ldb	r2,0(r16)
 32083ac:	103ffc1e 	bne	r2,zero,32083a0 <___vfprintf_internal_r+0x188>
 32083b0:	85e7c83a 	sub	r19,r16,r23
 32083b4:	98000e26 	beq	r19,zero,32083f0 <___vfprintf_internal_r+0x1d8>
 32083b8:	dc800e17 	ldw	r18,56(sp)
 32083bc:	dc400d17 	ldw	r17,52(sp)
 32083c0:	008001c4 	movi	r2,7
 32083c4:	94e5883a 	add	r18,r18,r19
 32083c8:	8c400044 	addi	r17,r17,1
 32083cc:	adc00015 	stw	r23,0(r21)
 32083d0:	dc800e15 	stw	r18,56(sp)
 32083d4:	acc00115 	stw	r19,4(r21)
 32083d8:	dc400d15 	stw	r17,52(sp)
 32083dc:	14428b16 	blt	r2,r17,3208e0c <___vfprintf_internal_r+0xbf4>
 32083e0:	ad400204 	addi	r21,r21,8
 32083e4:	d9014b17 	ldw	r4,1324(sp)
 32083e8:	24c9883a 	add	r4,r4,r19
 32083ec:	d9014b15 	stw	r4,1324(sp)
 32083f0:	802f883a 	mov	r23,r16
 32083f4:	b8800007 	ldb	r2,0(r23)
 32083f8:	10013c26 	beq	r2,zero,32088ec <___vfprintf_internal_r+0x6d4>
 32083fc:	bdc00044 	addi	r23,r23,1
 3208400:	d8000405 	stb	zero,16(sp)
 3208404:	b8c00007 	ldb	r3,0(r23)
 3208408:	04ffffc4 	movi	r19,-1
 320840c:	d8014c15 	stw	zero,1328(sp)
 3208410:	d8014a15 	stw	zero,1320(sp)
 3208414:	d8c14d15 	stw	r3,1332(sp)
 3208418:	bdc00044 	addi	r23,r23,1
 320841c:	d9414d17 	ldw	r5,1332(sp)
 3208420:	00801604 	movi	r2,88
 3208424:	28fff804 	addi	r3,r5,-32
 3208428:	10c06036 	bltu	r2,r3,32085ac <___vfprintf_internal_r+0x394>
 320842c:	18c5883a 	add	r2,r3,r3
 3208430:	1085883a 	add	r2,r2,r2
 3208434:	00c0c874 	movhi	r3,801
 3208438:	18e11204 	addi	r3,r3,-31672
 320843c:	10c5883a 	add	r2,r2,r3
 3208440:	11000017 	ldw	r4,0(r2)
 3208444:	2000683a 	jmp	r4
 3208448:	032093bc 	xorhi	r12,zero,33358
 320844c:	032085ac 	andhi	r12,zero,33302
 3208450:	032085ac 	andhi	r12,zero,33302
 3208454:	032093a8 	cmpgeui	r12,zero,33358
 3208458:	032085ac 	andhi	r12,zero,33302
 320845c:	032085ac 	andhi	r12,zero,33302
 3208460:	032085ac 	andhi	r12,zero,33302
 3208464:	032085ac 	andhi	r12,zero,33302
 3208468:	032085ac 	andhi	r12,zero,33302
 320846c:	032085ac 	andhi	r12,zero,33302
 3208470:	03209188 	cmpgei	r12,zero,-32186
 3208474:	03209398 	cmpnei	r12,zero,-32178
 3208478:	032085ac 	andhi	r12,zero,33302
 320847c:	032091a0 	cmpeqi	r12,zero,-32186
 3208480:	03209434 	movhi	r12,33360
 3208484:	032085ac 	andhi	r12,zero,33302
 3208488:	03209420 	cmpeqi	r12,zero,-32176
 320848c:	032093e8 	cmpgeui	r12,zero,33359
 3208490:	032093e8 	cmpgeui	r12,zero,33359
 3208494:	032093e8 	cmpgeui	r12,zero,33359
 3208498:	032093e8 	cmpgeui	r12,zero,33359
 320849c:	032093e8 	cmpgeui	r12,zero,33359
 32084a0:	032093e8 	cmpgeui	r12,zero,33359
 32084a4:	032093e8 	cmpgeui	r12,zero,33359
 32084a8:	032093e8 	cmpgeui	r12,zero,33359
 32084ac:	032093e8 	cmpgeui	r12,zero,33359
 32084b0:	032085ac 	andhi	r12,zero,33302
 32084b4:	032085ac 	andhi	r12,zero,33302
 32084b8:	032085ac 	andhi	r12,zero,33302
 32084bc:	032085ac 	andhi	r12,zero,33302
 32084c0:	032085ac 	andhi	r12,zero,33302
 32084c4:	032085ac 	andhi	r12,zero,33302
 32084c8:	032085ac 	andhi	r12,zero,33302
 32084cc:	032085ac 	andhi	r12,zero,33302
 32084d0:	032085ac 	andhi	r12,zero,33302
 32084d4:	032085ac 	andhi	r12,zero,33302
 32084d8:	03208c04 	movi	r12,-32208
 32084dc:	03209270 	cmpltui	r12,zero,33353
 32084e0:	032085ac 	andhi	r12,zero,33302
 32084e4:	03209270 	cmpltui	r12,zero,33353
 32084e8:	032085ac 	andhi	r12,zero,33302
 32084ec:	032085ac 	andhi	r12,zero,33302
 32084f0:	032085ac 	andhi	r12,zero,33302
 32084f4:	032085ac 	andhi	r12,zero,33302
 32084f8:	032093d4 	movui	r12,33359
 32084fc:	032085ac 	andhi	r12,zero,33302
 3208500:	032085ac 	andhi	r12,zero,33302
 3208504:	03208cb8 	rdprs	r12,zero,-32206
 3208508:	032085ac 	andhi	r12,zero,33302
 320850c:	032085ac 	andhi	r12,zero,33302
 3208510:	032085ac 	andhi	r12,zero,33302
 3208514:	032085ac 	andhi	r12,zero,33302
 3208518:	032085ac 	andhi	r12,zero,33302
 320851c:	03208d04 	movi	r12,-32204
 3208520:	032085ac 	andhi	r12,zero,33302
 3208524:	032085ac 	andhi	r12,zero,33302
 3208528:	03209324 	muli	r12,zero,-32180
 320852c:	032085ac 	andhi	r12,zero,33302
 3208530:	032085ac 	andhi	r12,zero,33302
 3208534:	032085ac 	andhi	r12,zero,33302
 3208538:	032085ac 	andhi	r12,zero,33302
 320853c:	032085ac 	andhi	r12,zero,33302
 3208540:	032085ac 	andhi	r12,zero,33302
 3208544:	032085ac 	andhi	r12,zero,33302
 3208548:	032085ac 	andhi	r12,zero,33302
 320854c:	032085ac 	andhi	r12,zero,33302
 3208550:	032085ac 	andhi	r12,zero,33302
 3208554:	032092f8 	rdprs	r12,zero,-32181
 3208558:	03208c10 	cmplti	r12,zero,-32208
 320855c:	03209270 	cmpltui	r12,zero,33353
 3208560:	03209270 	cmpltui	r12,zero,33353
 3208564:	03209270 	cmpltui	r12,zero,33353
 3208568:	0320925c 	xori	r12,zero,33353
 320856c:	03208c10 	cmplti	r12,zero,-32208
 3208570:	032085ac 	andhi	r12,zero,33302
 3208574:	032085ac 	andhi	r12,zero,33302
 3208578:	032091e4 	muli	r12,zero,-32185
 320857c:	032085ac 	andhi	r12,zero,33302
 3208580:	032091b4 	movhi	r12,33350
 3208584:	03208cc4 	movi	r12,-32205
 3208588:	03209214 	movui	r12,33352
 320858c:	03209200 	call	320920 <OSCtxSw_SWITCH_PC+0x3208e0>
 3208590:	032085ac 	andhi	r12,zero,33302
 3208594:	03209490 	cmplti	r12,zero,-32174
 3208598:	032085ac 	andhi	r12,zero,33302
 320859c:	03208d10 	cmplti	r12,zero,-32204
 32085a0:	032085ac 	andhi	r12,zero,33302
 32085a4:	032085ac 	andhi	r12,zero,33302
 32085a8:	03209388 	cmpgei	r12,zero,-32178
 32085ac:	d9014d17 	ldw	r4,1332(sp)
 32085b0:	2000ce26 	beq	r4,zero,32088ec <___vfprintf_internal_r+0x6d4>
 32085b4:	01400044 	movi	r5,1
 32085b8:	d9800f04 	addi	r6,sp,60
 32085bc:	d9c14015 	stw	r7,1280(sp)
 32085c0:	d9414515 	stw	r5,1300(sp)
 32085c4:	d9814115 	stw	r6,1284(sp)
 32085c8:	280f883a 	mov	r7,r5
 32085cc:	d9000f05 	stb	r4,60(sp)
 32085d0:	d8000405 	stb	zero,16(sp)
 32085d4:	d8014615 	stw	zero,1304(sp)
 32085d8:	d8c14c17 	ldw	r3,1328(sp)
 32085dc:	1880008c 	andi	r2,r3,2
 32085e0:	1005003a 	cmpeq	r2,r2,zero
 32085e4:	d8815015 	stw	r2,1344(sp)
 32085e8:	1000031e 	bne	r2,zero,32085f8 <___vfprintf_internal_r+0x3e0>
 32085ec:	d9014517 	ldw	r4,1300(sp)
 32085f0:	21000084 	addi	r4,r4,2
 32085f4:	d9014515 	stw	r4,1300(sp)
 32085f8:	d9414c17 	ldw	r5,1328(sp)
 32085fc:	2940210c 	andi	r5,r5,132
 3208600:	d9414e15 	stw	r5,1336(sp)
 3208604:	28002d1e 	bne	r5,zero,32086bc <___vfprintf_internal_r+0x4a4>
 3208608:	d9814a17 	ldw	r6,1320(sp)
 320860c:	d8814517 	ldw	r2,1300(sp)
 3208610:	30a1c83a 	sub	r16,r6,r2
 3208614:	0400290e 	bge	zero,r16,32086bc <___vfprintf_internal_r+0x4a4>
 3208618:	00800404 	movi	r2,16
 320861c:	1404580e 	bge	r2,r16,3209780 <___vfprintf_internal_r+0x1568>
 3208620:	dc800e17 	ldw	r18,56(sp)
 3208624:	dc400d17 	ldw	r17,52(sp)
 3208628:	1027883a 	mov	r19,r2
 320862c:	0700c974 	movhi	fp,805
 3208630:	e737c584 	addi	fp,fp,-8426
 3208634:	050001c4 	movi	r20,7
 3208638:	00000306 	br	3208648 <___vfprintf_internal_r+0x430>
 320863c:	843ffc04 	addi	r16,r16,-16
 3208640:	ad400204 	addi	r21,r21,8
 3208644:	9c00130e 	bge	r19,r16,3208694 <___vfprintf_internal_r+0x47c>
 3208648:	94800404 	addi	r18,r18,16
 320864c:	8c400044 	addi	r17,r17,1
 3208650:	af000015 	stw	fp,0(r21)
 3208654:	acc00115 	stw	r19,4(r21)
 3208658:	dc800e15 	stw	r18,56(sp)
 320865c:	dc400d15 	stw	r17,52(sp)
 3208660:	a47ff60e 	bge	r20,r17,320863c <___vfprintf_internal_r+0x424>
 3208664:	d9014f17 	ldw	r4,1340(sp)
 3208668:	b00b883a 	mov	r5,r22
 320866c:	d9800c04 	addi	r6,sp,48
 3208670:	d9c15115 	stw	r7,1348(sp)
 3208674:	32081c00 	call	32081c0 <__sprint_r>
 3208678:	d9c15117 	ldw	r7,1348(sp)
 320867c:	10009e1e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3208680:	843ffc04 	addi	r16,r16,-16
 3208684:	dc800e17 	ldw	r18,56(sp)
 3208688:	dc400d17 	ldw	r17,52(sp)
 320868c:	dd401904 	addi	r21,sp,100
 3208690:	9c3fed16 	blt	r19,r16,3208648 <___vfprintf_internal_r+0x430>
 3208694:	9425883a 	add	r18,r18,r16
 3208698:	8c400044 	addi	r17,r17,1
 320869c:	008001c4 	movi	r2,7
 32086a0:	af000015 	stw	fp,0(r21)
 32086a4:	ac000115 	stw	r16,4(r21)
 32086a8:	dc800e15 	stw	r18,56(sp)
 32086ac:	dc400d15 	stw	r17,52(sp)
 32086b0:	1441f516 	blt	r2,r17,3208e88 <___vfprintf_internal_r+0xc70>
 32086b4:	ad400204 	addi	r21,r21,8
 32086b8:	00000206 	br	32086c4 <___vfprintf_internal_r+0x4ac>
 32086bc:	dc800e17 	ldw	r18,56(sp)
 32086c0:	dc400d17 	ldw	r17,52(sp)
 32086c4:	d8800407 	ldb	r2,16(sp)
 32086c8:	10000b26 	beq	r2,zero,32086f8 <___vfprintf_internal_r+0x4e0>
 32086cc:	00800044 	movi	r2,1
 32086d0:	94800044 	addi	r18,r18,1
 32086d4:	8c400044 	addi	r17,r17,1
 32086d8:	a8800115 	stw	r2,4(r21)
 32086dc:	d8c00404 	addi	r3,sp,16
 32086e0:	008001c4 	movi	r2,7
 32086e4:	a8c00015 	stw	r3,0(r21)
 32086e8:	dc800e15 	stw	r18,56(sp)
 32086ec:	dc400d15 	stw	r17,52(sp)
 32086f0:	1441da16 	blt	r2,r17,3208e5c <___vfprintf_internal_r+0xc44>
 32086f4:	ad400204 	addi	r21,r21,8
 32086f8:	d9015017 	ldw	r4,1344(sp)
 32086fc:	20000b1e 	bne	r4,zero,320872c <___vfprintf_internal_r+0x514>
 3208700:	d8800444 	addi	r2,sp,17
 3208704:	94800084 	addi	r18,r18,2
 3208708:	8c400044 	addi	r17,r17,1
 320870c:	a8800015 	stw	r2,0(r21)
 3208710:	00c00084 	movi	r3,2
 3208714:	008001c4 	movi	r2,7
 3208718:	a8c00115 	stw	r3,4(r21)
 320871c:	dc800e15 	stw	r18,56(sp)
 3208720:	dc400d15 	stw	r17,52(sp)
 3208724:	1441c216 	blt	r2,r17,3208e30 <___vfprintf_internal_r+0xc18>
 3208728:	ad400204 	addi	r21,r21,8
 320872c:	d9414e17 	ldw	r5,1336(sp)
 3208730:	00802004 	movi	r2,128
 3208734:	2880b126 	beq	r5,r2,32089fc <___vfprintf_internal_r+0x7e4>
 3208738:	d8c14617 	ldw	r3,1304(sp)
 320873c:	19e1c83a 	sub	r16,r3,r7
 3208740:	0400260e 	bge	zero,r16,32087dc <___vfprintf_internal_r+0x5c4>
 3208744:	00800404 	movi	r2,16
 3208748:	1403c90e 	bge	r2,r16,3209670 <___vfprintf_internal_r+0x1458>
 320874c:	1027883a 	mov	r19,r2
 3208750:	0700c974 	movhi	fp,805
 3208754:	e737c184 	addi	fp,fp,-8442
 3208758:	050001c4 	movi	r20,7
 320875c:	00000306 	br	320876c <___vfprintf_internal_r+0x554>
 3208760:	843ffc04 	addi	r16,r16,-16
 3208764:	ad400204 	addi	r21,r21,8
 3208768:	9c00130e 	bge	r19,r16,32087b8 <___vfprintf_internal_r+0x5a0>
 320876c:	94800404 	addi	r18,r18,16
 3208770:	8c400044 	addi	r17,r17,1
 3208774:	af000015 	stw	fp,0(r21)
 3208778:	acc00115 	stw	r19,4(r21)
 320877c:	dc800e15 	stw	r18,56(sp)
 3208780:	dc400d15 	stw	r17,52(sp)
 3208784:	a47ff60e 	bge	r20,r17,3208760 <___vfprintf_internal_r+0x548>
 3208788:	d9014f17 	ldw	r4,1340(sp)
 320878c:	b00b883a 	mov	r5,r22
 3208790:	d9800c04 	addi	r6,sp,48
 3208794:	d9c15115 	stw	r7,1348(sp)
 3208798:	32081c00 	call	32081c0 <__sprint_r>
 320879c:	d9c15117 	ldw	r7,1348(sp)
 32087a0:	1000551e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 32087a4:	843ffc04 	addi	r16,r16,-16
 32087a8:	dc800e17 	ldw	r18,56(sp)
 32087ac:	dc400d17 	ldw	r17,52(sp)
 32087b0:	dd401904 	addi	r21,sp,100
 32087b4:	9c3fed16 	blt	r19,r16,320876c <___vfprintf_internal_r+0x554>
 32087b8:	9425883a 	add	r18,r18,r16
 32087bc:	8c400044 	addi	r17,r17,1
 32087c0:	008001c4 	movi	r2,7
 32087c4:	af000015 	stw	fp,0(r21)
 32087c8:	ac000115 	stw	r16,4(r21)
 32087cc:	dc800e15 	stw	r18,56(sp)
 32087d0:	dc400d15 	stw	r17,52(sp)
 32087d4:	14418216 	blt	r2,r17,3208de0 <___vfprintf_internal_r+0xbc8>
 32087d8:	ad400204 	addi	r21,r21,8
 32087dc:	d9014c17 	ldw	r4,1328(sp)
 32087e0:	2080400c 	andi	r2,r4,256
 32087e4:	10004a1e 	bne	r2,zero,3208910 <___vfprintf_internal_r+0x6f8>
 32087e8:	d9414117 	ldw	r5,1284(sp)
 32087ec:	91e5883a 	add	r18,r18,r7
 32087f0:	8c400044 	addi	r17,r17,1
 32087f4:	008001c4 	movi	r2,7
 32087f8:	a9400015 	stw	r5,0(r21)
 32087fc:	a9c00115 	stw	r7,4(r21)
 3208800:	dc800e15 	stw	r18,56(sp)
 3208804:	dc400d15 	stw	r17,52(sp)
 3208808:	14416716 	blt	r2,r17,3208da8 <___vfprintf_internal_r+0xb90>
 320880c:	a8c00204 	addi	r3,r21,8
 3208810:	d9814c17 	ldw	r6,1328(sp)
 3208814:	3080010c 	andi	r2,r6,4
 3208818:	10002826 	beq	r2,zero,32088bc <___vfprintf_internal_r+0x6a4>
 320881c:	d8814a17 	ldw	r2,1320(sp)
 3208820:	d9014517 	ldw	r4,1300(sp)
 3208824:	1121c83a 	sub	r16,r2,r4
 3208828:	0400240e 	bge	zero,r16,32088bc <___vfprintf_internal_r+0x6a4>
 320882c:	00800404 	movi	r2,16
 3208830:	14044f0e 	bge	r2,r16,3209970 <___vfprintf_internal_r+0x1758>
 3208834:	dc400d17 	ldw	r17,52(sp)
 3208838:	1027883a 	mov	r19,r2
 320883c:	0700c974 	movhi	fp,805
 3208840:	e737c584 	addi	fp,fp,-8426
 3208844:	050001c4 	movi	r20,7
 3208848:	00000306 	br	3208858 <___vfprintf_internal_r+0x640>
 320884c:	843ffc04 	addi	r16,r16,-16
 3208850:	18c00204 	addi	r3,r3,8
 3208854:	9c00110e 	bge	r19,r16,320889c <___vfprintf_internal_r+0x684>
 3208858:	94800404 	addi	r18,r18,16
 320885c:	8c400044 	addi	r17,r17,1
 3208860:	1f000015 	stw	fp,0(r3)
 3208864:	1cc00115 	stw	r19,4(r3)
 3208868:	dc800e15 	stw	r18,56(sp)
 320886c:	dc400d15 	stw	r17,52(sp)
 3208870:	a47ff60e 	bge	r20,r17,320884c <___vfprintf_internal_r+0x634>
 3208874:	d9014f17 	ldw	r4,1340(sp)
 3208878:	b00b883a 	mov	r5,r22
 320887c:	d9800c04 	addi	r6,sp,48
 3208880:	32081c00 	call	32081c0 <__sprint_r>
 3208884:	10001c1e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3208888:	843ffc04 	addi	r16,r16,-16
 320888c:	dc800e17 	ldw	r18,56(sp)
 3208890:	dc400d17 	ldw	r17,52(sp)
 3208894:	d8c01904 	addi	r3,sp,100
 3208898:	9c3fef16 	blt	r19,r16,3208858 <___vfprintf_internal_r+0x640>
 320889c:	9425883a 	add	r18,r18,r16
 32088a0:	8c400044 	addi	r17,r17,1
 32088a4:	008001c4 	movi	r2,7
 32088a8:	1f000015 	stw	fp,0(r3)
 32088ac:	1c000115 	stw	r16,4(r3)
 32088b0:	dc800e15 	stw	r18,56(sp)
 32088b4:	dc400d15 	stw	r17,52(sp)
 32088b8:	1440cb16 	blt	r2,r17,3208be8 <___vfprintf_internal_r+0x9d0>
 32088bc:	d8814a17 	ldw	r2,1320(sp)
 32088c0:	d9414517 	ldw	r5,1300(sp)
 32088c4:	1140010e 	bge	r2,r5,32088cc <___vfprintf_internal_r+0x6b4>
 32088c8:	2805883a 	mov	r2,r5
 32088cc:	d9814b17 	ldw	r6,1324(sp)
 32088d0:	308d883a 	add	r6,r6,r2
 32088d4:	d9814b15 	stw	r6,1324(sp)
 32088d8:	90013b1e 	bne	r18,zero,3208dc8 <___vfprintf_internal_r+0xbb0>
 32088dc:	d9c14017 	ldw	r7,1280(sp)
 32088e0:	dd401904 	addi	r21,sp,100
 32088e4:	d8000d15 	stw	zero,52(sp)
 32088e8:	003ea706 	br	3208388 <___vfprintf_internal_r+0x170>
 32088ec:	d8800e17 	ldw	r2,56(sp)
 32088f0:	10053f1e 	bne	r2,zero,3209df0 <___vfprintf_internal_r+0x1bd8>
 32088f4:	d8000d15 	stw	zero,52(sp)
 32088f8:	b080030b 	ldhu	r2,12(r22)
 32088fc:	1080100c 	andi	r2,r2,64
 3208900:	103e8726 	beq	r2,zero,3208320 <___vfprintf_internal_r+0x108>
 3208904:	00bfffc4 	movi	r2,-1
 3208908:	d8814b15 	stw	r2,1324(sp)
 320890c:	003e8406 	br	3208320 <___vfprintf_internal_r+0x108>
 3208910:	d9814d17 	ldw	r6,1332(sp)
 3208914:	00801944 	movi	r2,101
 3208918:	11806e16 	blt	r2,r6,3208ad4 <___vfprintf_internal_r+0x8bc>
 320891c:	d9414717 	ldw	r5,1308(sp)
 3208920:	00c00044 	movi	r3,1
 3208924:	1943430e 	bge	r3,r5,3209634 <___vfprintf_internal_r+0x141c>
 3208928:	d8814117 	ldw	r2,1284(sp)
 320892c:	94800044 	addi	r18,r18,1
 3208930:	8c400044 	addi	r17,r17,1
 3208934:	a8800015 	stw	r2,0(r21)
 3208938:	008001c4 	movi	r2,7
 320893c:	a8c00115 	stw	r3,4(r21)
 3208940:	dc800e15 	stw	r18,56(sp)
 3208944:	dc400d15 	stw	r17,52(sp)
 3208948:	1441ca16 	blt	r2,r17,3209074 <___vfprintf_internal_r+0xe5c>
 320894c:	a8c00204 	addi	r3,r21,8
 3208950:	d9014917 	ldw	r4,1316(sp)
 3208954:	00800044 	movi	r2,1
 3208958:	94800044 	addi	r18,r18,1
 320895c:	8c400044 	addi	r17,r17,1
 3208960:	18800115 	stw	r2,4(r3)
 3208964:	008001c4 	movi	r2,7
 3208968:	19000015 	stw	r4,0(r3)
 320896c:	dc800e15 	stw	r18,56(sp)
 3208970:	dc400d15 	stw	r17,52(sp)
 3208974:	1441b616 	blt	r2,r17,3209050 <___vfprintf_internal_r+0xe38>
 3208978:	1cc00204 	addi	r19,r3,8
 320897c:	d9014217 	ldw	r4,1288(sp)
 3208980:	d9414317 	ldw	r5,1292(sp)
 3208984:	000d883a 	mov	r6,zero
 3208988:	000f883a 	mov	r7,zero
 320898c:	321364c0 	call	321364c <__nedf2>
 3208990:	10017426 	beq	r2,zero,3208f64 <___vfprintf_internal_r+0xd4c>
 3208994:	d9414717 	ldw	r5,1308(sp)
 3208998:	d9814117 	ldw	r6,1284(sp)
 320899c:	8c400044 	addi	r17,r17,1
 32089a0:	2c85883a 	add	r2,r5,r18
 32089a4:	14bfffc4 	addi	r18,r2,-1
 32089a8:	28bfffc4 	addi	r2,r5,-1
 32089ac:	30c00044 	addi	r3,r6,1
 32089b0:	98800115 	stw	r2,4(r19)
 32089b4:	008001c4 	movi	r2,7
 32089b8:	98c00015 	stw	r3,0(r19)
 32089bc:	dc800e15 	stw	r18,56(sp)
 32089c0:	dc400d15 	stw	r17,52(sp)
 32089c4:	14418e16 	blt	r2,r17,3209000 <___vfprintf_internal_r+0xde8>
 32089c8:	9cc00204 	addi	r19,r19,8
 32089cc:	d9414817 	ldw	r5,1312(sp)
 32089d0:	d8800804 	addi	r2,sp,32
 32089d4:	8c400044 	addi	r17,r17,1
 32089d8:	9165883a 	add	r18,r18,r5
 32089dc:	98800015 	stw	r2,0(r19)
 32089e0:	008001c4 	movi	r2,7
 32089e4:	99400115 	stw	r5,4(r19)
 32089e8:	dc800e15 	stw	r18,56(sp)
 32089ec:	dc400d15 	stw	r17,52(sp)
 32089f0:	1440ed16 	blt	r2,r17,3208da8 <___vfprintf_internal_r+0xb90>
 32089f4:	98c00204 	addi	r3,r19,8
 32089f8:	003f8506 	br	3208810 <___vfprintf_internal_r+0x5f8>
 32089fc:	d9814a17 	ldw	r6,1320(sp)
 3208a00:	d8814517 	ldw	r2,1300(sp)
 3208a04:	30a1c83a 	sub	r16,r6,r2
 3208a08:	043f4b0e 	bge	zero,r16,3208738 <___vfprintf_internal_r+0x520>
 3208a0c:	00800404 	movi	r2,16
 3208a10:	1404340e 	bge	r2,r16,3209ae4 <___vfprintf_internal_r+0x18cc>
 3208a14:	1027883a 	mov	r19,r2
 3208a18:	0700c974 	movhi	fp,805
 3208a1c:	e737c184 	addi	fp,fp,-8442
 3208a20:	050001c4 	movi	r20,7
 3208a24:	00000306 	br	3208a34 <___vfprintf_internal_r+0x81c>
 3208a28:	843ffc04 	addi	r16,r16,-16
 3208a2c:	ad400204 	addi	r21,r21,8
 3208a30:	9c00130e 	bge	r19,r16,3208a80 <___vfprintf_internal_r+0x868>
 3208a34:	94800404 	addi	r18,r18,16
 3208a38:	8c400044 	addi	r17,r17,1
 3208a3c:	af000015 	stw	fp,0(r21)
 3208a40:	acc00115 	stw	r19,4(r21)
 3208a44:	dc800e15 	stw	r18,56(sp)
 3208a48:	dc400d15 	stw	r17,52(sp)
 3208a4c:	a47ff60e 	bge	r20,r17,3208a28 <___vfprintf_internal_r+0x810>
 3208a50:	d9014f17 	ldw	r4,1340(sp)
 3208a54:	b00b883a 	mov	r5,r22
 3208a58:	d9800c04 	addi	r6,sp,48
 3208a5c:	d9c15115 	stw	r7,1348(sp)
 3208a60:	32081c00 	call	32081c0 <__sprint_r>
 3208a64:	d9c15117 	ldw	r7,1348(sp)
 3208a68:	103fa31e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3208a6c:	843ffc04 	addi	r16,r16,-16
 3208a70:	dc800e17 	ldw	r18,56(sp)
 3208a74:	dc400d17 	ldw	r17,52(sp)
 3208a78:	dd401904 	addi	r21,sp,100
 3208a7c:	9c3fed16 	blt	r19,r16,3208a34 <___vfprintf_internal_r+0x81c>
 3208a80:	9425883a 	add	r18,r18,r16
 3208a84:	8c400044 	addi	r17,r17,1
 3208a88:	008001c4 	movi	r2,7
 3208a8c:	af000015 	stw	fp,0(r21)
 3208a90:	ac000115 	stw	r16,4(r21)
 3208a94:	dc800e15 	stw	r18,56(sp)
 3208a98:	dc400d15 	stw	r17,52(sp)
 3208a9c:	14416116 	blt	r2,r17,3209024 <___vfprintf_internal_r+0xe0c>
 3208aa0:	ad400204 	addi	r21,r21,8
 3208aa4:	003f2406 	br	3208738 <___vfprintf_internal_r+0x520>
 3208aa8:	d9014f17 	ldw	r4,1340(sp)
 3208aac:	32048880 	call	3204888 <__sinit>
 3208ab0:	d9c15117 	ldw	r7,1348(sp)
 3208ab4:	003def06 	br	3208274 <___vfprintf_internal_r+0x5c>
 3208ab8:	d9014f17 	ldw	r4,1340(sp)
 3208abc:	b00b883a 	mov	r5,r22
 3208ac0:	d9c15115 	stw	r7,1348(sp)
 3208ac4:	320ba2c0 	call	320ba2c <__swsetup_r>
 3208ac8:	d9c15117 	ldw	r7,1348(sp)
 3208acc:	103dee26 	beq	r2,zero,3208288 <___vfprintf_internal_r+0x70>
 3208ad0:	003f8c06 	br	3208904 <___vfprintf_internal_r+0x6ec>
 3208ad4:	d9014217 	ldw	r4,1288(sp)
 3208ad8:	d9414317 	ldw	r5,1292(sp)
 3208adc:	000d883a 	mov	r6,zero
 3208ae0:	000f883a 	mov	r7,zero
 3208ae4:	32135c40 	call	32135c4 <__eqdf2>
 3208ae8:	1000f21e 	bne	r2,zero,3208eb4 <___vfprintf_internal_r+0xc9c>
 3208aec:	0080c974 	movhi	r2,805
 3208af0:	10b7c104 	addi	r2,r2,-8444
 3208af4:	94800044 	addi	r18,r18,1
 3208af8:	8c400044 	addi	r17,r17,1
 3208afc:	a8800015 	stw	r2,0(r21)
 3208b00:	00c00044 	movi	r3,1
 3208b04:	008001c4 	movi	r2,7
 3208b08:	a8c00115 	stw	r3,4(r21)
 3208b0c:	dc800e15 	stw	r18,56(sp)
 3208b10:	dc400d15 	stw	r17,52(sp)
 3208b14:	1442fa16 	blt	r2,r17,3209700 <___vfprintf_internal_r+0x14e8>
 3208b18:	a8c00204 	addi	r3,r21,8
 3208b1c:	d8800517 	ldw	r2,20(sp)
 3208b20:	d9014717 	ldw	r4,1308(sp)
 3208b24:	11015c0e 	bge	r2,r4,3209098 <___vfprintf_internal_r+0xe80>
 3208b28:	dc400d17 	ldw	r17,52(sp)
 3208b2c:	d9814917 	ldw	r6,1316(sp)
 3208b30:	00800044 	movi	r2,1
 3208b34:	94800044 	addi	r18,r18,1
 3208b38:	8c400044 	addi	r17,r17,1
 3208b3c:	18800115 	stw	r2,4(r3)
 3208b40:	008001c4 	movi	r2,7
 3208b44:	19800015 	stw	r6,0(r3)
 3208b48:	dc800e15 	stw	r18,56(sp)
 3208b4c:	dc400d15 	stw	r17,52(sp)
 3208b50:	14431016 	blt	r2,r17,3209794 <___vfprintf_internal_r+0x157c>
 3208b54:	18c00204 	addi	r3,r3,8
 3208b58:	d8814717 	ldw	r2,1308(sp)
 3208b5c:	143fffc4 	addi	r16,r2,-1
 3208b60:	043f2b0e 	bge	zero,r16,3208810 <___vfprintf_internal_r+0x5f8>
 3208b64:	00800404 	movi	r2,16
 3208b68:	1402a20e 	bge	r2,r16,32095f4 <___vfprintf_internal_r+0x13dc>
 3208b6c:	dc400d17 	ldw	r17,52(sp)
 3208b70:	1027883a 	mov	r19,r2
 3208b74:	0700c974 	movhi	fp,805
 3208b78:	e737c184 	addi	fp,fp,-8442
 3208b7c:	050001c4 	movi	r20,7
 3208b80:	00000306 	br	3208b90 <___vfprintf_internal_r+0x978>
 3208b84:	18c00204 	addi	r3,r3,8
 3208b88:	843ffc04 	addi	r16,r16,-16
 3208b8c:	9c029c0e 	bge	r19,r16,3209600 <___vfprintf_internal_r+0x13e8>
 3208b90:	94800404 	addi	r18,r18,16
 3208b94:	8c400044 	addi	r17,r17,1
 3208b98:	1f000015 	stw	fp,0(r3)
 3208b9c:	1cc00115 	stw	r19,4(r3)
 3208ba0:	dc800e15 	stw	r18,56(sp)
 3208ba4:	dc400d15 	stw	r17,52(sp)
 3208ba8:	a47ff60e 	bge	r20,r17,3208b84 <___vfprintf_internal_r+0x96c>
 3208bac:	d9014f17 	ldw	r4,1340(sp)
 3208bb0:	b00b883a 	mov	r5,r22
 3208bb4:	d9800c04 	addi	r6,sp,48
 3208bb8:	32081c00 	call	32081c0 <__sprint_r>
 3208bbc:	103f4e1e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3208bc0:	dc800e17 	ldw	r18,56(sp)
 3208bc4:	dc400d17 	ldw	r17,52(sp)
 3208bc8:	d8c01904 	addi	r3,sp,100
 3208bcc:	003fee06 	br	3208b88 <___vfprintf_internal_r+0x970>
 3208bd0:	d8802c0b 	ldhu	r2,176(sp)
 3208bd4:	00ffffc4 	movi	r3,-1
 3208bd8:	d8c14b15 	stw	r3,1324(sp)
 3208bdc:	1080100c 	andi	r2,r2,64
 3208be0:	103dcc1e 	bne	r2,zero,3208314 <___vfprintf_internal_r+0xfc>
 3208be4:	003dce06 	br	3208320 <___vfprintf_internal_r+0x108>
 3208be8:	d9014f17 	ldw	r4,1340(sp)
 3208bec:	b00b883a 	mov	r5,r22
 3208bf0:	d9800c04 	addi	r6,sp,48
 3208bf4:	32081c00 	call	32081c0 <__sprint_r>
 3208bf8:	103f3f1e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3208bfc:	dc800e17 	ldw	r18,56(sp)
 3208c00:	003f2e06 	br	32088bc <___vfprintf_internal_r+0x6a4>
 3208c04:	d9414c17 	ldw	r5,1328(sp)
 3208c08:	29400414 	ori	r5,r5,16
 3208c0c:	d9414c15 	stw	r5,1328(sp)
 3208c10:	d9814c17 	ldw	r6,1328(sp)
 3208c14:	3080080c 	andi	r2,r6,32
 3208c18:	10014f1e 	bne	r2,zero,3209158 <___vfprintf_internal_r+0xf40>
 3208c1c:	d8c14c17 	ldw	r3,1328(sp)
 3208c20:	1880040c 	andi	r2,r3,16
 3208c24:	1002ea1e 	bne	r2,zero,32097d0 <___vfprintf_internal_r+0x15b8>
 3208c28:	d9014c17 	ldw	r4,1328(sp)
 3208c2c:	2080100c 	andi	r2,r4,64
 3208c30:	1002e726 	beq	r2,zero,32097d0 <___vfprintf_internal_r+0x15b8>
 3208c34:	3880000f 	ldh	r2,0(r7)
 3208c38:	39c00104 	addi	r7,r7,4
 3208c3c:	d9c14015 	stw	r7,1280(sp)
 3208c40:	1023d7fa 	srai	r17,r2,31
 3208c44:	1021883a 	mov	r16,r2
 3208c48:	88037216 	blt	r17,zero,3209a14 <___vfprintf_internal_r+0x17fc>
 3208c4c:	01000044 	movi	r4,1
 3208c50:	98000416 	blt	r19,zero,3208c64 <___vfprintf_internal_r+0xa4c>
 3208c54:	d8c14c17 	ldw	r3,1328(sp)
 3208c58:	00bfdfc4 	movi	r2,-129
 3208c5c:	1886703a 	and	r3,r3,r2
 3208c60:	d8c14c15 	stw	r3,1328(sp)
 3208c64:	8444b03a 	or	r2,r16,r17
 3208c68:	1002261e 	bne	r2,zero,3209504 <___vfprintf_internal_r+0x12ec>
 3208c6c:	9802251e 	bne	r19,zero,3209504 <___vfprintf_internal_r+0x12ec>
 3208c70:	20803fcc 	andi	r2,r4,255
 3208c74:	10029b26 	beq	r2,zero,32096e4 <___vfprintf_internal_r+0x14cc>
 3208c78:	d8c01904 	addi	r3,sp,100
 3208c7c:	dd000f04 	addi	r20,sp,60
 3208c80:	d8c14115 	stw	r3,1284(sp)
 3208c84:	d8c14117 	ldw	r3,1284(sp)
 3208c88:	dcc14515 	stw	r19,1300(sp)
 3208c8c:	a0c5c83a 	sub	r2,r20,r3
 3208c90:	11c00a04 	addi	r7,r2,40
 3208c94:	99c0010e 	bge	r19,r7,3208c9c <___vfprintf_internal_r+0xa84>
 3208c98:	d9c14515 	stw	r7,1300(sp)
 3208c9c:	dcc14615 	stw	r19,1304(sp)
 3208ca0:	d8800407 	ldb	r2,16(sp)
 3208ca4:	103e4c26 	beq	r2,zero,32085d8 <___vfprintf_internal_r+0x3c0>
 3208ca8:	d8814517 	ldw	r2,1300(sp)
 3208cac:	10800044 	addi	r2,r2,1
 3208cb0:	d8814515 	stw	r2,1300(sp)
 3208cb4:	003e4806 	br	32085d8 <___vfprintf_internal_r+0x3c0>
 3208cb8:	d9814c17 	ldw	r6,1328(sp)
 3208cbc:	31800414 	ori	r6,r6,16
 3208cc0:	d9814c15 	stw	r6,1328(sp)
 3208cc4:	d8c14c17 	ldw	r3,1328(sp)
 3208cc8:	1880080c 	andi	r2,r3,32
 3208ccc:	1001271e 	bne	r2,zero,320916c <___vfprintf_internal_r+0xf54>
 3208cd0:	d9414c17 	ldw	r5,1328(sp)
 3208cd4:	2880040c 	andi	r2,r5,16
 3208cd8:	1002b61e 	bne	r2,zero,32097b4 <___vfprintf_internal_r+0x159c>
 3208cdc:	d9814c17 	ldw	r6,1328(sp)
 3208ce0:	3080100c 	andi	r2,r6,64
 3208ce4:	1002b326 	beq	r2,zero,32097b4 <___vfprintf_internal_r+0x159c>
 3208ce8:	3c00000b 	ldhu	r16,0(r7)
 3208cec:	0009883a 	mov	r4,zero
 3208cf0:	39c00104 	addi	r7,r7,4
 3208cf4:	0023883a 	mov	r17,zero
 3208cf8:	d9c14015 	stw	r7,1280(sp)
 3208cfc:	d8000405 	stb	zero,16(sp)
 3208d00:	003fd306 	br	3208c50 <___vfprintf_internal_r+0xa38>
 3208d04:	d9014c17 	ldw	r4,1328(sp)
 3208d08:	21000414 	ori	r4,r4,16
 3208d0c:	d9014c15 	stw	r4,1328(sp)
 3208d10:	d9414c17 	ldw	r5,1328(sp)
 3208d14:	2880080c 	andi	r2,r5,32
 3208d18:	1001081e 	bne	r2,zero,320913c <___vfprintf_internal_r+0xf24>
 3208d1c:	d8c14c17 	ldw	r3,1328(sp)
 3208d20:	1880040c 	andi	r2,r3,16
 3208d24:	1002b01e 	bne	r2,zero,32097e8 <___vfprintf_internal_r+0x15d0>
 3208d28:	d9014c17 	ldw	r4,1328(sp)
 3208d2c:	2080100c 	andi	r2,r4,64
 3208d30:	1002ad26 	beq	r2,zero,32097e8 <___vfprintf_internal_r+0x15d0>
 3208d34:	3c00000b 	ldhu	r16,0(r7)
 3208d38:	01000044 	movi	r4,1
 3208d3c:	39c00104 	addi	r7,r7,4
 3208d40:	0023883a 	mov	r17,zero
 3208d44:	d9c14015 	stw	r7,1280(sp)
 3208d48:	d8000405 	stb	zero,16(sp)
 3208d4c:	003fc006 	br	3208c50 <___vfprintf_internal_r+0xa38>
 3208d50:	d9014f17 	ldw	r4,1340(sp)
 3208d54:	b00b883a 	mov	r5,r22
 3208d58:	d9800c04 	addi	r6,sp,48
 3208d5c:	32081c00 	call	32081c0 <__sprint_r>
 3208d60:	103ee51e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3208d64:	dc800e17 	ldw	r18,56(sp)
 3208d68:	d8c01904 	addi	r3,sp,100
 3208d6c:	d9814c17 	ldw	r6,1328(sp)
 3208d70:	3080004c 	andi	r2,r6,1
 3208d74:	1005003a 	cmpeq	r2,r2,zero
 3208d78:	103ea51e 	bne	r2,zero,3208810 <___vfprintf_internal_r+0x5f8>
 3208d7c:	00800044 	movi	r2,1
 3208d80:	dc400d17 	ldw	r17,52(sp)
 3208d84:	18800115 	stw	r2,4(r3)
 3208d88:	d8814917 	ldw	r2,1316(sp)
 3208d8c:	94800044 	addi	r18,r18,1
 3208d90:	8c400044 	addi	r17,r17,1
 3208d94:	18800015 	stw	r2,0(r3)
 3208d98:	008001c4 	movi	r2,7
 3208d9c:	dc800e15 	stw	r18,56(sp)
 3208da0:	dc400d15 	stw	r17,52(sp)
 3208da4:	14421e0e 	bge	r2,r17,3209620 <___vfprintf_internal_r+0x1408>
 3208da8:	d9014f17 	ldw	r4,1340(sp)
 3208dac:	b00b883a 	mov	r5,r22
 3208db0:	d9800c04 	addi	r6,sp,48
 3208db4:	32081c00 	call	32081c0 <__sprint_r>
 3208db8:	103ecf1e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3208dbc:	dc800e17 	ldw	r18,56(sp)
 3208dc0:	d8c01904 	addi	r3,sp,100
 3208dc4:	003e9206 	br	3208810 <___vfprintf_internal_r+0x5f8>
 3208dc8:	d9014f17 	ldw	r4,1340(sp)
 3208dcc:	b00b883a 	mov	r5,r22
 3208dd0:	d9800c04 	addi	r6,sp,48
 3208dd4:	32081c00 	call	32081c0 <__sprint_r>
 3208dd8:	103ec026 	beq	r2,zero,32088dc <___vfprintf_internal_r+0x6c4>
 3208ddc:	003ec606 	br	32088f8 <___vfprintf_internal_r+0x6e0>
 3208de0:	d9014f17 	ldw	r4,1340(sp)
 3208de4:	b00b883a 	mov	r5,r22
 3208de8:	d9800c04 	addi	r6,sp,48
 3208dec:	d9c15115 	stw	r7,1348(sp)
 3208df0:	32081c00 	call	32081c0 <__sprint_r>
 3208df4:	d9c15117 	ldw	r7,1348(sp)
 3208df8:	103ebf1e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3208dfc:	dc800e17 	ldw	r18,56(sp)
 3208e00:	dc400d17 	ldw	r17,52(sp)
 3208e04:	dd401904 	addi	r21,sp,100
 3208e08:	003e7406 	br	32087dc <___vfprintf_internal_r+0x5c4>
 3208e0c:	d9014f17 	ldw	r4,1340(sp)
 3208e10:	b00b883a 	mov	r5,r22
 3208e14:	d9800c04 	addi	r6,sp,48
 3208e18:	d9c15115 	stw	r7,1348(sp)
 3208e1c:	32081c00 	call	32081c0 <__sprint_r>
 3208e20:	d9c15117 	ldw	r7,1348(sp)
 3208e24:	103eb41e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3208e28:	dd401904 	addi	r21,sp,100
 3208e2c:	003d6d06 	br	32083e4 <___vfprintf_internal_r+0x1cc>
 3208e30:	d9014f17 	ldw	r4,1340(sp)
 3208e34:	b00b883a 	mov	r5,r22
 3208e38:	d9800c04 	addi	r6,sp,48
 3208e3c:	d9c15115 	stw	r7,1348(sp)
 3208e40:	32081c00 	call	32081c0 <__sprint_r>
 3208e44:	d9c15117 	ldw	r7,1348(sp)
 3208e48:	103eab1e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3208e4c:	dc800e17 	ldw	r18,56(sp)
 3208e50:	dc400d17 	ldw	r17,52(sp)
 3208e54:	dd401904 	addi	r21,sp,100
 3208e58:	003e3406 	br	320872c <___vfprintf_internal_r+0x514>
 3208e5c:	d9014f17 	ldw	r4,1340(sp)
 3208e60:	b00b883a 	mov	r5,r22
 3208e64:	d9800c04 	addi	r6,sp,48
 3208e68:	d9c15115 	stw	r7,1348(sp)
 3208e6c:	32081c00 	call	32081c0 <__sprint_r>
 3208e70:	d9c15117 	ldw	r7,1348(sp)
 3208e74:	103ea01e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3208e78:	dc800e17 	ldw	r18,56(sp)
 3208e7c:	dc400d17 	ldw	r17,52(sp)
 3208e80:	dd401904 	addi	r21,sp,100
 3208e84:	003e1c06 	br	32086f8 <___vfprintf_internal_r+0x4e0>
 3208e88:	d9014f17 	ldw	r4,1340(sp)
 3208e8c:	b00b883a 	mov	r5,r22
 3208e90:	d9800c04 	addi	r6,sp,48
 3208e94:	d9c15115 	stw	r7,1348(sp)
 3208e98:	32081c00 	call	32081c0 <__sprint_r>
 3208e9c:	d9c15117 	ldw	r7,1348(sp)
 3208ea0:	103e951e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3208ea4:	dc800e17 	ldw	r18,56(sp)
 3208ea8:	dc400d17 	ldw	r17,52(sp)
 3208eac:	dd401904 	addi	r21,sp,100
 3208eb0:	003e0406 	br	32086c4 <___vfprintf_internal_r+0x4ac>
 3208eb4:	d9000517 	ldw	r4,20(sp)
 3208eb8:	0102520e 	bge	zero,r4,3209804 <___vfprintf_internal_r+0x15ec>
 3208ebc:	d9814717 	ldw	r6,1308(sp)
 3208ec0:	21807a16 	blt	r4,r6,32090ac <___vfprintf_internal_r+0xe94>
 3208ec4:	d8814117 	ldw	r2,1284(sp)
 3208ec8:	91a5883a 	add	r18,r18,r6
 3208ecc:	8c400044 	addi	r17,r17,1
 3208ed0:	a8800015 	stw	r2,0(r21)
 3208ed4:	008001c4 	movi	r2,7
 3208ed8:	a9800115 	stw	r6,4(r21)
 3208edc:	dc800e15 	stw	r18,56(sp)
 3208ee0:	dc400d15 	stw	r17,52(sp)
 3208ee4:	1442f616 	blt	r2,r17,3209ac0 <___vfprintf_internal_r+0x18a8>
 3208ee8:	a8c00204 	addi	r3,r21,8
 3208eec:	d9414717 	ldw	r5,1308(sp)
 3208ef0:	2161c83a 	sub	r16,r4,r5
 3208ef4:	043f9d0e 	bge	zero,r16,3208d6c <___vfprintf_internal_r+0xb54>
 3208ef8:	00800404 	movi	r2,16
 3208efc:	1402130e 	bge	r2,r16,320974c <___vfprintf_internal_r+0x1534>
 3208f00:	dc400d17 	ldw	r17,52(sp)
 3208f04:	1027883a 	mov	r19,r2
 3208f08:	0700c974 	movhi	fp,805
 3208f0c:	e737c184 	addi	fp,fp,-8442
 3208f10:	050001c4 	movi	r20,7
 3208f14:	00000306 	br	3208f24 <___vfprintf_internal_r+0xd0c>
 3208f18:	18c00204 	addi	r3,r3,8
 3208f1c:	843ffc04 	addi	r16,r16,-16
 3208f20:	9c020d0e 	bge	r19,r16,3209758 <___vfprintf_internal_r+0x1540>
 3208f24:	94800404 	addi	r18,r18,16
 3208f28:	8c400044 	addi	r17,r17,1
 3208f2c:	1f000015 	stw	fp,0(r3)
 3208f30:	1cc00115 	stw	r19,4(r3)
 3208f34:	dc800e15 	stw	r18,56(sp)
 3208f38:	dc400d15 	stw	r17,52(sp)
 3208f3c:	a47ff60e 	bge	r20,r17,3208f18 <___vfprintf_internal_r+0xd00>
 3208f40:	d9014f17 	ldw	r4,1340(sp)
 3208f44:	b00b883a 	mov	r5,r22
 3208f48:	d9800c04 	addi	r6,sp,48
 3208f4c:	32081c00 	call	32081c0 <__sprint_r>
 3208f50:	103e691e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3208f54:	dc800e17 	ldw	r18,56(sp)
 3208f58:	dc400d17 	ldw	r17,52(sp)
 3208f5c:	d8c01904 	addi	r3,sp,100
 3208f60:	003fee06 	br	3208f1c <___vfprintf_internal_r+0xd04>
 3208f64:	d8814717 	ldw	r2,1308(sp)
 3208f68:	143fffc4 	addi	r16,r2,-1
 3208f6c:	043e970e 	bge	zero,r16,32089cc <___vfprintf_internal_r+0x7b4>
 3208f70:	00800404 	movi	r2,16
 3208f74:	1400180e 	bge	r2,r16,3208fd8 <___vfprintf_internal_r+0xdc0>
 3208f78:	1029883a 	mov	r20,r2
 3208f7c:	0700c974 	movhi	fp,805
 3208f80:	e737c184 	addi	fp,fp,-8442
 3208f84:	054001c4 	movi	r21,7
 3208f88:	00000306 	br	3208f98 <___vfprintf_internal_r+0xd80>
 3208f8c:	9cc00204 	addi	r19,r19,8
 3208f90:	843ffc04 	addi	r16,r16,-16
 3208f94:	a400120e 	bge	r20,r16,3208fe0 <___vfprintf_internal_r+0xdc8>
 3208f98:	94800404 	addi	r18,r18,16
 3208f9c:	8c400044 	addi	r17,r17,1
 3208fa0:	9f000015 	stw	fp,0(r19)
 3208fa4:	9d000115 	stw	r20,4(r19)
 3208fa8:	dc800e15 	stw	r18,56(sp)
 3208fac:	dc400d15 	stw	r17,52(sp)
 3208fb0:	ac7ff60e 	bge	r21,r17,3208f8c <___vfprintf_internal_r+0xd74>
 3208fb4:	d9014f17 	ldw	r4,1340(sp)
 3208fb8:	b00b883a 	mov	r5,r22
 3208fbc:	d9800c04 	addi	r6,sp,48
 3208fc0:	32081c00 	call	32081c0 <__sprint_r>
 3208fc4:	103e4c1e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3208fc8:	dc800e17 	ldw	r18,56(sp)
 3208fcc:	dc400d17 	ldw	r17,52(sp)
 3208fd0:	dcc01904 	addi	r19,sp,100
 3208fd4:	003fee06 	br	3208f90 <___vfprintf_internal_r+0xd78>
 3208fd8:	0700c974 	movhi	fp,805
 3208fdc:	e737c184 	addi	fp,fp,-8442
 3208fe0:	9425883a 	add	r18,r18,r16
 3208fe4:	8c400044 	addi	r17,r17,1
 3208fe8:	008001c4 	movi	r2,7
 3208fec:	9f000015 	stw	fp,0(r19)
 3208ff0:	9c000115 	stw	r16,4(r19)
 3208ff4:	dc800e15 	stw	r18,56(sp)
 3208ff8:	dc400d15 	stw	r17,52(sp)
 3208ffc:	147e720e 	bge	r2,r17,32089c8 <___vfprintf_internal_r+0x7b0>
 3209000:	d9014f17 	ldw	r4,1340(sp)
 3209004:	b00b883a 	mov	r5,r22
 3209008:	d9800c04 	addi	r6,sp,48
 320900c:	32081c00 	call	32081c0 <__sprint_r>
 3209010:	103e391e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3209014:	dc800e17 	ldw	r18,56(sp)
 3209018:	dc400d17 	ldw	r17,52(sp)
 320901c:	dcc01904 	addi	r19,sp,100
 3209020:	003e6a06 	br	32089cc <___vfprintf_internal_r+0x7b4>
 3209024:	d9014f17 	ldw	r4,1340(sp)
 3209028:	b00b883a 	mov	r5,r22
 320902c:	d9800c04 	addi	r6,sp,48
 3209030:	d9c15115 	stw	r7,1348(sp)
 3209034:	32081c00 	call	32081c0 <__sprint_r>
 3209038:	d9c15117 	ldw	r7,1348(sp)
 320903c:	103e2e1e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3209040:	dc800e17 	ldw	r18,56(sp)
 3209044:	dc400d17 	ldw	r17,52(sp)
 3209048:	dd401904 	addi	r21,sp,100
 320904c:	003dba06 	br	3208738 <___vfprintf_internal_r+0x520>
 3209050:	d9014f17 	ldw	r4,1340(sp)
 3209054:	b00b883a 	mov	r5,r22
 3209058:	d9800c04 	addi	r6,sp,48
 320905c:	32081c00 	call	32081c0 <__sprint_r>
 3209060:	103e251e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3209064:	dc800e17 	ldw	r18,56(sp)
 3209068:	dc400d17 	ldw	r17,52(sp)
 320906c:	dcc01904 	addi	r19,sp,100
 3209070:	003e4206 	br	320897c <___vfprintf_internal_r+0x764>
 3209074:	d9014f17 	ldw	r4,1340(sp)
 3209078:	b00b883a 	mov	r5,r22
 320907c:	d9800c04 	addi	r6,sp,48
 3209080:	32081c00 	call	32081c0 <__sprint_r>
 3209084:	103e1c1e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3209088:	dc800e17 	ldw	r18,56(sp)
 320908c:	dc400d17 	ldw	r17,52(sp)
 3209090:	d8c01904 	addi	r3,sp,100
 3209094:	003e2e06 	br	3208950 <___vfprintf_internal_r+0x738>
 3209098:	d9414c17 	ldw	r5,1328(sp)
 320909c:	2880004c 	andi	r2,r5,1
 32090a0:	1005003a 	cmpeq	r2,r2,zero
 32090a4:	103dda1e 	bne	r2,zero,3208810 <___vfprintf_internal_r+0x5f8>
 32090a8:	003e9f06 	br	3208b28 <___vfprintf_internal_r+0x910>
 32090ac:	d8c14117 	ldw	r3,1284(sp)
 32090b0:	9125883a 	add	r18,r18,r4
 32090b4:	8c400044 	addi	r17,r17,1
 32090b8:	008001c4 	movi	r2,7
 32090bc:	a8c00015 	stw	r3,0(r21)
 32090c0:	a9000115 	stw	r4,4(r21)
 32090c4:	dc800e15 	stw	r18,56(sp)
 32090c8:	dc400d15 	stw	r17,52(sp)
 32090cc:	14426616 	blt	r2,r17,3209a68 <___vfprintf_internal_r+0x1850>
 32090d0:	a8c00204 	addi	r3,r21,8
 32090d4:	d9414917 	ldw	r5,1316(sp)
 32090d8:	00800044 	movi	r2,1
 32090dc:	94800044 	addi	r18,r18,1
 32090e0:	8c400044 	addi	r17,r17,1
 32090e4:	18800115 	stw	r2,4(r3)
 32090e8:	008001c4 	movi	r2,7
 32090ec:	19400015 	stw	r5,0(r3)
 32090f0:	dc800e15 	stw	r18,56(sp)
 32090f4:	dc400d15 	stw	r17,52(sp)
 32090f8:	2021883a 	mov	r16,r4
 32090fc:	14425016 	blt	r2,r17,3209a40 <___vfprintf_internal_r+0x1828>
 3209100:	19400204 	addi	r5,r3,8
 3209104:	d9814717 	ldw	r6,1308(sp)
 3209108:	8c400044 	addi	r17,r17,1
 320910c:	dc400d15 	stw	r17,52(sp)
 3209110:	3107c83a 	sub	r3,r6,r4
 3209114:	d9014117 	ldw	r4,1284(sp)
 3209118:	90e5883a 	add	r18,r18,r3
 320911c:	28c00115 	stw	r3,4(r5)
 3209120:	8105883a 	add	r2,r16,r4
 3209124:	28800015 	stw	r2,0(r5)
 3209128:	008001c4 	movi	r2,7
 320912c:	dc800e15 	stw	r18,56(sp)
 3209130:	147f1d16 	blt	r2,r17,3208da8 <___vfprintf_internal_r+0xb90>
 3209134:	28c00204 	addi	r3,r5,8
 3209138:	003db506 	br	3208810 <___vfprintf_internal_r+0x5f8>
 320913c:	3c000017 	ldw	r16,0(r7)
 3209140:	3c400117 	ldw	r17,4(r7)
 3209144:	39800204 	addi	r6,r7,8
 3209148:	01000044 	movi	r4,1
 320914c:	d9814015 	stw	r6,1280(sp)
 3209150:	d8000405 	stb	zero,16(sp)
 3209154:	003ebe06 	br	3208c50 <___vfprintf_internal_r+0xa38>
 3209158:	3c000017 	ldw	r16,0(r7)
 320915c:	3c400117 	ldw	r17,4(r7)
 3209160:	38800204 	addi	r2,r7,8
 3209164:	d8814015 	stw	r2,1280(sp)
 3209168:	003eb706 	br	3208c48 <___vfprintf_internal_r+0xa30>
 320916c:	3c000017 	ldw	r16,0(r7)
 3209170:	3c400117 	ldw	r17,4(r7)
 3209174:	39000204 	addi	r4,r7,8
 3209178:	d9014015 	stw	r4,1280(sp)
 320917c:	0009883a 	mov	r4,zero
 3209180:	d8000405 	stb	zero,16(sp)
 3209184:	003eb206 	br	3208c50 <___vfprintf_internal_r+0xa38>
 3209188:	38c00017 	ldw	r3,0(r7)
 320918c:	39c00104 	addi	r7,r7,4
 3209190:	d8c14a15 	stw	r3,1320(sp)
 3209194:	1800d10e 	bge	r3,zero,32094dc <___vfprintf_internal_r+0x12c4>
 3209198:	00c7c83a 	sub	r3,zero,r3
 320919c:	d8c14a15 	stw	r3,1320(sp)
 32091a0:	d9014c17 	ldw	r4,1328(sp)
 32091a4:	b8c00007 	ldb	r3,0(r23)
 32091a8:	21000114 	ori	r4,r4,4
 32091ac:	d9014c15 	stw	r4,1328(sp)
 32091b0:	003c9806 	br	3208414 <___vfprintf_internal_r+0x1fc>
 32091b4:	d9814c17 	ldw	r6,1328(sp)
 32091b8:	3080080c 	andi	r2,r6,32
 32091bc:	1001f026 	beq	r2,zero,3209980 <___vfprintf_internal_r+0x1768>
 32091c0:	d9014b17 	ldw	r4,1324(sp)
 32091c4:	38800017 	ldw	r2,0(r7)
 32091c8:	39c00104 	addi	r7,r7,4
 32091cc:	d9c14015 	stw	r7,1280(sp)
 32091d0:	2007d7fa 	srai	r3,r4,31
 32091d4:	d9c14017 	ldw	r7,1280(sp)
 32091d8:	11000015 	stw	r4,0(r2)
 32091dc:	10c00115 	stw	r3,4(r2)
 32091e0:	003c6906 	br	3208388 <___vfprintf_internal_r+0x170>
 32091e4:	b8c00007 	ldb	r3,0(r23)
 32091e8:	00801b04 	movi	r2,108
 32091ec:	18824f26 	beq	r3,r2,3209b2c <___vfprintf_internal_r+0x1914>
 32091f0:	d9414c17 	ldw	r5,1328(sp)
 32091f4:	29400414 	ori	r5,r5,16
 32091f8:	d9414c15 	stw	r5,1328(sp)
 32091fc:	003c8506 	br	3208414 <___vfprintf_internal_r+0x1fc>
 3209200:	d9814c17 	ldw	r6,1328(sp)
 3209204:	b8c00007 	ldb	r3,0(r23)
 3209208:	31800814 	ori	r6,r6,32
 320920c:	d9814c15 	stw	r6,1328(sp)
 3209210:	003c8006 	br	3208414 <___vfprintf_internal_r+0x1fc>
 3209214:	d8814c17 	ldw	r2,1328(sp)
 3209218:	3c000017 	ldw	r16,0(r7)
 320921c:	00c01e04 	movi	r3,120
 3209220:	10800094 	ori	r2,r2,2
 3209224:	d8814c15 	stw	r2,1328(sp)
 3209228:	39c00104 	addi	r7,r7,4
 320922c:	0140c974 	movhi	r5,805
 3209230:	2977aa04 	addi	r5,r5,-8536
 3209234:	00800c04 	movi	r2,48
 3209238:	0023883a 	mov	r17,zero
 320923c:	01000084 	movi	r4,2
 3209240:	d9c14015 	stw	r7,1280(sp)
 3209244:	d8c14d15 	stw	r3,1332(sp)
 3209248:	d9414415 	stw	r5,1296(sp)
 320924c:	d8800445 	stb	r2,17(sp)
 3209250:	d8c00485 	stb	r3,18(sp)
 3209254:	d8000405 	stb	zero,16(sp)
 3209258:	003e7d06 	br	3208c50 <___vfprintf_internal_r+0xa38>
 320925c:	d8814c17 	ldw	r2,1328(sp)
 3209260:	b8c00007 	ldb	r3,0(r23)
 3209264:	10801014 	ori	r2,r2,64
 3209268:	d8814c15 	stw	r2,1328(sp)
 320926c:	003c6906 	br	3208414 <___vfprintf_internal_r+0x1fc>
 3209270:	d9414c17 	ldw	r5,1328(sp)
 3209274:	2880020c 	andi	r2,r5,8
 3209278:	1001df26 	beq	r2,zero,32099f8 <___vfprintf_internal_r+0x17e0>
 320927c:	39800017 	ldw	r6,0(r7)
 3209280:	38800204 	addi	r2,r7,8
 3209284:	d8814015 	stw	r2,1280(sp)
 3209288:	d9814215 	stw	r6,1288(sp)
 320928c:	39c00117 	ldw	r7,4(r7)
 3209290:	d9c14315 	stw	r7,1292(sp)
 3209294:	d9014217 	ldw	r4,1288(sp)
 3209298:	d9414317 	ldw	r5,1292(sp)
 320929c:	320ea800 	call	320ea80 <__isinfd>
 32092a0:	10021726 	beq	r2,zero,3209b00 <___vfprintf_internal_r+0x18e8>
 32092a4:	d9014217 	ldw	r4,1288(sp)
 32092a8:	d9414317 	ldw	r5,1292(sp)
 32092ac:	000d883a 	mov	r6,zero
 32092b0:	000f883a 	mov	r7,zero
 32092b4:	32137e40 	call	32137e4 <__ltdf2>
 32092b8:	1002ca16 	blt	r2,zero,3209de4 <___vfprintf_internal_r+0x1bcc>
 32092bc:	d9414d17 	ldw	r5,1332(sp)
 32092c0:	008011c4 	movi	r2,71
 32092c4:	11420a16 	blt	r2,r5,3209af0 <___vfprintf_internal_r+0x18d8>
 32092c8:	0180c974 	movhi	r6,805
 32092cc:	31b7af04 	addi	r6,r6,-8516
 32092d0:	d9814115 	stw	r6,1284(sp)
 32092d4:	d9014c17 	ldw	r4,1328(sp)
 32092d8:	00c000c4 	movi	r3,3
 32092dc:	00bfdfc4 	movi	r2,-129
 32092e0:	2088703a 	and	r4,r4,r2
 32092e4:	180f883a 	mov	r7,r3
 32092e8:	d8c14515 	stw	r3,1300(sp)
 32092ec:	d9014c15 	stw	r4,1328(sp)
 32092f0:	d8014615 	stw	zero,1304(sp)
 32092f4:	003e6a06 	br	3208ca0 <___vfprintf_internal_r+0xa88>
 32092f8:	38800017 	ldw	r2,0(r7)
 32092fc:	00c00044 	movi	r3,1
 3209300:	39c00104 	addi	r7,r7,4
 3209304:	d9c14015 	stw	r7,1280(sp)
 3209308:	d9000f04 	addi	r4,sp,60
 320930c:	180f883a 	mov	r7,r3
 3209310:	d8c14515 	stw	r3,1300(sp)
 3209314:	d9014115 	stw	r4,1284(sp)
 3209318:	d8800f05 	stb	r2,60(sp)
 320931c:	d8000405 	stb	zero,16(sp)
 3209320:	003cac06 	br	32085d4 <___vfprintf_internal_r+0x3bc>
 3209324:	0140c974 	movhi	r5,805
 3209328:	2977b504 	addi	r5,r5,-8492
 320932c:	d9414415 	stw	r5,1296(sp)
 3209330:	d9814c17 	ldw	r6,1328(sp)
 3209334:	3080080c 	andi	r2,r6,32
 3209338:	1000f926 	beq	r2,zero,3209720 <___vfprintf_internal_r+0x1508>
 320933c:	3c000017 	ldw	r16,0(r7)
 3209340:	3c400117 	ldw	r17,4(r7)
 3209344:	38800204 	addi	r2,r7,8
 3209348:	d8814015 	stw	r2,1280(sp)
 320934c:	d9414c17 	ldw	r5,1328(sp)
 3209350:	2880004c 	andi	r2,r5,1
 3209354:	1005003a 	cmpeq	r2,r2,zero
 3209358:	1000b31e 	bne	r2,zero,3209628 <___vfprintf_internal_r+0x1410>
 320935c:	8444b03a 	or	r2,r16,r17
 3209360:	1000b126 	beq	r2,zero,3209628 <___vfprintf_internal_r+0x1410>
 3209364:	d9814d17 	ldw	r6,1332(sp)
 3209368:	29400094 	ori	r5,r5,2
 320936c:	00800c04 	movi	r2,48
 3209370:	01000084 	movi	r4,2
 3209374:	d9414c15 	stw	r5,1328(sp)
 3209378:	d8800445 	stb	r2,17(sp)
 320937c:	d9800485 	stb	r6,18(sp)
 3209380:	d8000405 	stb	zero,16(sp)
 3209384:	003e3206 	br	3208c50 <___vfprintf_internal_r+0xa38>
 3209388:	0180c974 	movhi	r6,805
 320938c:	31b7aa04 	addi	r6,r6,-8536
 3209390:	d9814415 	stw	r6,1296(sp)
 3209394:	003fe606 	br	3209330 <___vfprintf_internal_r+0x1118>
 3209398:	00800ac4 	movi	r2,43
 320939c:	d8800405 	stb	r2,16(sp)
 32093a0:	b8c00007 	ldb	r3,0(r23)
 32093a4:	003c1b06 	br	3208414 <___vfprintf_internal_r+0x1fc>
 32093a8:	d8814c17 	ldw	r2,1328(sp)
 32093ac:	b8c00007 	ldb	r3,0(r23)
 32093b0:	10800054 	ori	r2,r2,1
 32093b4:	d8814c15 	stw	r2,1328(sp)
 32093b8:	003c1606 	br	3208414 <___vfprintf_internal_r+0x1fc>
 32093bc:	d8800407 	ldb	r2,16(sp)
 32093c0:	1000461e 	bne	r2,zero,32094dc <___vfprintf_internal_r+0x12c4>
 32093c4:	00800804 	movi	r2,32
 32093c8:	d8800405 	stb	r2,16(sp)
 32093cc:	b8c00007 	ldb	r3,0(r23)
 32093d0:	003c1006 	br	3208414 <___vfprintf_internal_r+0x1fc>
 32093d4:	d9814c17 	ldw	r6,1328(sp)
 32093d8:	b8c00007 	ldb	r3,0(r23)
 32093dc:	31800214 	ori	r6,r6,8
 32093e0:	d9814c15 	stw	r6,1328(sp)
 32093e4:	003c0b06 	br	3208414 <___vfprintf_internal_r+0x1fc>
 32093e8:	0007883a 	mov	r3,zero
 32093ec:	01000244 	movi	r4,9
 32093f0:	188002a4 	muli	r2,r3,10
 32093f4:	b8c00007 	ldb	r3,0(r23)
 32093f8:	d9814d17 	ldw	r6,1332(sp)
 32093fc:	bdc00044 	addi	r23,r23,1
 3209400:	d8c14d15 	stw	r3,1332(sp)
 3209404:	d9414d17 	ldw	r5,1332(sp)
 3209408:	3085883a 	add	r2,r6,r2
 320940c:	10fff404 	addi	r3,r2,-48
 3209410:	28bff404 	addi	r2,r5,-48
 3209414:	20bff62e 	bgeu	r4,r2,32093f0 <___vfprintf_internal_r+0x11d8>
 3209418:	d8c14a15 	stw	r3,1320(sp)
 320941c:	003bff06 	br	320841c <___vfprintf_internal_r+0x204>
 3209420:	d9414c17 	ldw	r5,1328(sp)
 3209424:	b8c00007 	ldb	r3,0(r23)
 3209428:	29402014 	ori	r5,r5,128
 320942c:	d9414c15 	stw	r5,1328(sp)
 3209430:	003bf806 	br	3208414 <___vfprintf_internal_r+0x1fc>
 3209434:	b8c00007 	ldb	r3,0(r23)
 3209438:	00800a84 	movi	r2,42
 320943c:	bdc00044 	addi	r23,r23,1
 3209440:	18831526 	beq	r3,r2,320a098 <___vfprintf_internal_r+0x1e80>
 3209444:	d8c14d15 	stw	r3,1332(sp)
 3209448:	18bff404 	addi	r2,r3,-48
 320944c:	00c00244 	movi	r3,9
 3209450:	18827836 	bltu	r3,r2,3209e34 <___vfprintf_internal_r+0x1c1c>
 3209454:	000d883a 	mov	r6,zero
 3209458:	308002a4 	muli	r2,r6,10
 320945c:	b9800007 	ldb	r6,0(r23)
 3209460:	d9414d17 	ldw	r5,1332(sp)
 3209464:	bdc00044 	addi	r23,r23,1
 3209468:	d9814d15 	stw	r6,1332(sp)
 320946c:	d9014d17 	ldw	r4,1332(sp)
 3209470:	1145883a 	add	r2,r2,r5
 3209474:	11bff404 	addi	r6,r2,-48
 3209478:	20bff404 	addi	r2,r4,-48
 320947c:	18bff62e 	bgeu	r3,r2,3209458 <___vfprintf_internal_r+0x1240>
 3209480:	3027883a 	mov	r19,r6
 3209484:	303be50e 	bge	r6,zero,320841c <___vfprintf_internal_r+0x204>
 3209488:	04ffffc4 	movi	r19,-1
 320948c:	003be306 	br	320841c <___vfprintf_internal_r+0x204>
 3209490:	d8000405 	stb	zero,16(sp)
 3209494:	39800017 	ldw	r6,0(r7)
 3209498:	39c00104 	addi	r7,r7,4
 320949c:	d9c14015 	stw	r7,1280(sp)
 32094a0:	d9814115 	stw	r6,1284(sp)
 32094a4:	3001c926 	beq	r6,zero,3209bcc <___vfprintf_internal_r+0x19b4>
 32094a8:	98000e16 	blt	r19,zero,32094e4 <___vfprintf_internal_r+0x12cc>
 32094ac:	d9014117 	ldw	r4,1284(sp)
 32094b0:	000b883a 	mov	r5,zero
 32094b4:	980d883a 	mov	r6,r19
 32094b8:	32066e80 	call	32066e8 <memchr>
 32094bc:	10025926 	beq	r2,zero,3209e24 <___vfprintf_internal_r+0x1c0c>
 32094c0:	d8c14117 	ldw	r3,1284(sp)
 32094c4:	10cfc83a 	sub	r7,r2,r3
 32094c8:	99c19e16 	blt	r19,r7,3209b44 <___vfprintf_internal_r+0x192c>
 32094cc:	d9c14515 	stw	r7,1300(sp)
 32094d0:	38000916 	blt	r7,zero,32094f8 <___vfprintf_internal_r+0x12e0>
 32094d4:	d8014615 	stw	zero,1304(sp)
 32094d8:	003df106 	br	3208ca0 <___vfprintf_internal_r+0xa88>
 32094dc:	b8c00007 	ldb	r3,0(r23)
 32094e0:	003bcc06 	br	3208414 <___vfprintf_internal_r+0x1fc>
 32094e4:	d9014117 	ldw	r4,1284(sp)
 32094e8:	32081440 	call	3208144 <strlen>
 32094ec:	d8814515 	stw	r2,1300(sp)
 32094f0:	100f883a 	mov	r7,r2
 32094f4:	103ff70e 	bge	r2,zero,32094d4 <___vfprintf_internal_r+0x12bc>
 32094f8:	d8014515 	stw	zero,1300(sp)
 32094fc:	d8014615 	stw	zero,1304(sp)
 3209500:	003de706 	br	3208ca0 <___vfprintf_internal_r+0xa88>
 3209504:	20c03fcc 	andi	r3,r4,255
 3209508:	00800044 	movi	r2,1
 320950c:	18802d26 	beq	r3,r2,32095c4 <___vfprintf_internal_r+0x13ac>
 3209510:	18800e36 	bltu	r3,r2,320954c <___vfprintf_internal_r+0x1334>
 3209514:	00800084 	movi	r2,2
 3209518:	1880fa26 	beq	r3,r2,3209904 <___vfprintf_internal_r+0x16ec>
 320951c:	0100c974 	movhi	r4,805
 3209520:	2137ba04 	addi	r4,r4,-8472
 3209524:	32081440 	call	3208144 <strlen>
 3209528:	100f883a 	mov	r7,r2
 320952c:	dcc14515 	stw	r19,1300(sp)
 3209530:	9880010e 	bge	r19,r2,3209538 <___vfprintf_internal_r+0x1320>
 3209534:	d8814515 	stw	r2,1300(sp)
 3209538:	0080c974 	movhi	r2,805
 320953c:	10b7ba04 	addi	r2,r2,-8472
 3209540:	dcc14615 	stw	r19,1304(sp)
 3209544:	d8814115 	stw	r2,1284(sp)
 3209548:	003dd506 	br	3208ca0 <___vfprintf_internal_r+0xa88>
 320954c:	d9401904 	addi	r5,sp,100
 3209550:	dd000f04 	addi	r20,sp,60
 3209554:	d9414115 	stw	r5,1284(sp)
 3209558:	880a977a 	slli	r5,r17,29
 320955c:	d9814117 	ldw	r6,1284(sp)
 3209560:	8004d0fa 	srli	r2,r16,3
 3209564:	8806d0fa 	srli	r3,r17,3
 3209568:	810001cc 	andi	r4,r16,7
 320956c:	2884b03a 	or	r2,r5,r2
 3209570:	31bfffc4 	addi	r6,r6,-1
 3209574:	21000c04 	addi	r4,r4,48
 3209578:	d9814115 	stw	r6,1284(sp)
 320957c:	10cab03a 	or	r5,r2,r3
 3209580:	31000005 	stb	r4,0(r6)
 3209584:	1021883a 	mov	r16,r2
 3209588:	1823883a 	mov	r17,r3
 320958c:	283ff21e 	bne	r5,zero,3209558 <___vfprintf_internal_r+0x1340>
 3209590:	d8c14c17 	ldw	r3,1328(sp)
 3209594:	1880004c 	andi	r2,r3,1
 3209598:	1005003a 	cmpeq	r2,r2,zero
 320959c:	103db91e 	bne	r2,zero,3208c84 <___vfprintf_internal_r+0xa6c>
 32095a0:	20803fcc 	andi	r2,r4,255
 32095a4:	1080201c 	xori	r2,r2,128
 32095a8:	10bfe004 	addi	r2,r2,-128
 32095ac:	00c00c04 	movi	r3,48
 32095b0:	10fdb426 	beq	r2,r3,3208c84 <___vfprintf_internal_r+0xa6c>
 32095b4:	31bfffc4 	addi	r6,r6,-1
 32095b8:	d9814115 	stw	r6,1284(sp)
 32095bc:	30c00005 	stb	r3,0(r6)
 32095c0:	003db006 	br	3208c84 <___vfprintf_internal_r+0xa6c>
 32095c4:	88800068 	cmpgeui	r2,r17,1
 32095c8:	10002c1e 	bne	r2,zero,320967c <___vfprintf_internal_r+0x1464>
 32095cc:	8800021e 	bne	r17,zero,32095d8 <___vfprintf_internal_r+0x13c0>
 32095d0:	00800244 	movi	r2,9
 32095d4:	14002936 	bltu	r2,r16,320967c <___vfprintf_internal_r+0x1464>
 32095d8:	d90018c4 	addi	r4,sp,99
 32095dc:	dd000f04 	addi	r20,sp,60
 32095e0:	d9014115 	stw	r4,1284(sp)
 32095e4:	d9014117 	ldw	r4,1284(sp)
 32095e8:	80800c04 	addi	r2,r16,48
 32095ec:	20800005 	stb	r2,0(r4)
 32095f0:	003da406 	br	3208c84 <___vfprintf_internal_r+0xa6c>
 32095f4:	dc400d17 	ldw	r17,52(sp)
 32095f8:	0700c974 	movhi	fp,805
 32095fc:	e737c184 	addi	fp,fp,-8442
 3209600:	9425883a 	add	r18,r18,r16
 3209604:	8c400044 	addi	r17,r17,1
 3209608:	008001c4 	movi	r2,7
 320960c:	1f000015 	stw	fp,0(r3)
 3209610:	1c000115 	stw	r16,4(r3)
 3209614:	dc800e15 	stw	r18,56(sp)
 3209618:	dc400d15 	stw	r17,52(sp)
 320961c:	147de216 	blt	r2,r17,3208da8 <___vfprintf_internal_r+0xb90>
 3209620:	18c00204 	addi	r3,r3,8
 3209624:	003c7a06 	br	3208810 <___vfprintf_internal_r+0x5f8>
 3209628:	01000084 	movi	r4,2
 320962c:	d8000405 	stb	zero,16(sp)
 3209630:	003d8706 	br	3208c50 <___vfprintf_internal_r+0xa38>
 3209634:	d9814c17 	ldw	r6,1328(sp)
 3209638:	30c4703a 	and	r2,r6,r3
 320963c:	1005003a 	cmpeq	r2,r2,zero
 3209640:	103cb926 	beq	r2,zero,3208928 <___vfprintf_internal_r+0x710>
 3209644:	d9014117 	ldw	r4,1284(sp)
 3209648:	94800044 	addi	r18,r18,1
 320964c:	8c400044 	addi	r17,r17,1
 3209650:	008001c4 	movi	r2,7
 3209654:	a9000015 	stw	r4,0(r21)
 3209658:	a8c00115 	stw	r3,4(r21)
 320965c:	dc800e15 	stw	r18,56(sp)
 3209660:	dc400d15 	stw	r17,52(sp)
 3209664:	147e6616 	blt	r2,r17,3209000 <___vfprintf_internal_r+0xde8>
 3209668:	acc00204 	addi	r19,r21,8
 320966c:	003cd706 	br	32089cc <___vfprintf_internal_r+0x7b4>
 3209670:	0700c974 	movhi	fp,805
 3209674:	e737c184 	addi	fp,fp,-8442
 3209678:	003c4f06 	br	32087b8 <___vfprintf_internal_r+0x5a0>
 320967c:	dd000f04 	addi	r20,sp,60
 3209680:	dc801904 	addi	r18,sp,100
 3209684:	8009883a 	mov	r4,r16
 3209688:	880b883a 	mov	r5,r17
 320968c:	01800284 	movi	r6,10
 3209690:	000f883a 	mov	r7,zero
 3209694:	321238c0 	call	321238c <__umoddi3>
 3209698:	12000c04 	addi	r8,r2,48
 320969c:	94bfffc4 	addi	r18,r18,-1
 32096a0:	8009883a 	mov	r4,r16
 32096a4:	880b883a 	mov	r5,r17
 32096a8:	01800284 	movi	r6,10
 32096ac:	000f883a 	mov	r7,zero
 32096b0:	92000005 	stb	r8,0(r18)
 32096b4:	3211db00 	call	3211db0 <__udivdi3>
 32096b8:	1009883a 	mov	r4,r2
 32096bc:	1021883a 	mov	r16,r2
 32096c0:	18800068 	cmpgeui	r2,r3,1
 32096c4:	1823883a 	mov	r17,r3
 32096c8:	103fee1e 	bne	r2,zero,3209684 <___vfprintf_internal_r+0x146c>
 32096cc:	1800021e 	bne	r3,zero,32096d8 <___vfprintf_internal_r+0x14c0>
 32096d0:	00800244 	movi	r2,9
 32096d4:	113feb36 	bltu	r2,r4,3209684 <___vfprintf_internal_r+0x146c>
 32096d8:	94bfffc4 	addi	r18,r18,-1
 32096dc:	dc814115 	stw	r18,1284(sp)
 32096e0:	003fc006 	br	32095e4 <___vfprintf_internal_r+0x13cc>
 32096e4:	d9014c17 	ldw	r4,1328(sp)
 32096e8:	2080004c 	andi	r2,r4,1
 32096ec:	10009a1e 	bne	r2,zero,3209958 <___vfprintf_internal_r+0x1740>
 32096f0:	d9401904 	addi	r5,sp,100
 32096f4:	dd000f04 	addi	r20,sp,60
 32096f8:	d9414115 	stw	r5,1284(sp)
 32096fc:	003d6106 	br	3208c84 <___vfprintf_internal_r+0xa6c>
 3209700:	d9014f17 	ldw	r4,1340(sp)
 3209704:	b00b883a 	mov	r5,r22
 3209708:	d9800c04 	addi	r6,sp,48
 320970c:	32081c00 	call	32081c0 <__sprint_r>
 3209710:	103c791e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3209714:	dc800e17 	ldw	r18,56(sp)
 3209718:	d8c01904 	addi	r3,sp,100
 320971c:	003cff06 	br	3208b1c <___vfprintf_internal_r+0x904>
 3209720:	d8c14c17 	ldw	r3,1328(sp)
 3209724:	1880040c 	andi	r2,r3,16
 3209728:	1000711e 	bne	r2,zero,32098f0 <___vfprintf_internal_r+0x16d8>
 320972c:	d9014c17 	ldw	r4,1328(sp)
 3209730:	2080100c 	andi	r2,r4,64
 3209734:	10006e26 	beq	r2,zero,32098f0 <___vfprintf_internal_r+0x16d8>
 3209738:	3c00000b 	ldhu	r16,0(r7)
 320973c:	0023883a 	mov	r17,zero
 3209740:	39c00104 	addi	r7,r7,4
 3209744:	d9c14015 	stw	r7,1280(sp)
 3209748:	003f0006 	br	320934c <___vfprintf_internal_r+0x1134>
 320974c:	dc400d17 	ldw	r17,52(sp)
 3209750:	0700c974 	movhi	fp,805
 3209754:	e737c184 	addi	fp,fp,-8442
 3209758:	9425883a 	add	r18,r18,r16
 320975c:	8c400044 	addi	r17,r17,1
 3209760:	008001c4 	movi	r2,7
 3209764:	1f000015 	stw	fp,0(r3)
 3209768:	1c000115 	stw	r16,4(r3)
 320976c:	dc800e15 	stw	r18,56(sp)
 3209770:	dc400d15 	stw	r17,52(sp)
 3209774:	147d7616 	blt	r2,r17,3208d50 <___vfprintf_internal_r+0xb38>
 3209778:	18c00204 	addi	r3,r3,8
 320977c:	003d7b06 	br	3208d6c <___vfprintf_internal_r+0xb54>
 3209780:	dc800e17 	ldw	r18,56(sp)
 3209784:	dc400d17 	ldw	r17,52(sp)
 3209788:	0700c974 	movhi	fp,805
 320978c:	e737c584 	addi	fp,fp,-8426
 3209790:	003bc006 	br	3208694 <___vfprintf_internal_r+0x47c>
 3209794:	d9014f17 	ldw	r4,1340(sp)
 3209798:	b00b883a 	mov	r5,r22
 320979c:	d9800c04 	addi	r6,sp,48
 32097a0:	32081c00 	call	32081c0 <__sprint_r>
 32097a4:	103c541e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 32097a8:	dc800e17 	ldw	r18,56(sp)
 32097ac:	d8c01904 	addi	r3,sp,100
 32097b0:	003ce906 	br	3208b58 <___vfprintf_internal_r+0x940>
 32097b4:	3c000017 	ldw	r16,0(r7)
 32097b8:	0009883a 	mov	r4,zero
 32097bc:	39c00104 	addi	r7,r7,4
 32097c0:	0023883a 	mov	r17,zero
 32097c4:	d9c14015 	stw	r7,1280(sp)
 32097c8:	d8000405 	stb	zero,16(sp)
 32097cc:	003d2006 	br	3208c50 <___vfprintf_internal_r+0xa38>
 32097d0:	38800017 	ldw	r2,0(r7)
 32097d4:	39c00104 	addi	r7,r7,4
 32097d8:	d9c14015 	stw	r7,1280(sp)
 32097dc:	1023d7fa 	srai	r17,r2,31
 32097e0:	1021883a 	mov	r16,r2
 32097e4:	003d1806 	br	3208c48 <___vfprintf_internal_r+0xa30>
 32097e8:	3c000017 	ldw	r16,0(r7)
 32097ec:	01000044 	movi	r4,1
 32097f0:	39c00104 	addi	r7,r7,4
 32097f4:	0023883a 	mov	r17,zero
 32097f8:	d9c14015 	stw	r7,1280(sp)
 32097fc:	d8000405 	stb	zero,16(sp)
 3209800:	003d1306 	br	3208c50 <___vfprintf_internal_r+0xa38>
 3209804:	0080c974 	movhi	r2,805
 3209808:	10b7c104 	addi	r2,r2,-8444
 320980c:	94800044 	addi	r18,r18,1
 3209810:	8c400044 	addi	r17,r17,1
 3209814:	a8800015 	stw	r2,0(r21)
 3209818:	00c00044 	movi	r3,1
 320981c:	008001c4 	movi	r2,7
 3209820:	a8c00115 	stw	r3,4(r21)
 3209824:	dc800e15 	stw	r18,56(sp)
 3209828:	dc400d15 	stw	r17,52(sp)
 320982c:	1440ca16 	blt	r2,r17,3209b58 <___vfprintf_internal_r+0x1940>
 3209830:	a8c00204 	addi	r3,r21,8
 3209834:	2000061e 	bne	r4,zero,3209850 <___vfprintf_internal_r+0x1638>
 3209838:	d9414717 	ldw	r5,1308(sp)
 320983c:	2800041e 	bne	r5,zero,3209850 <___vfprintf_internal_r+0x1638>
 3209840:	d9814c17 	ldw	r6,1328(sp)
 3209844:	3080004c 	andi	r2,r6,1
 3209848:	1005003a 	cmpeq	r2,r2,zero
 320984c:	103bf01e 	bne	r2,zero,3208810 <___vfprintf_internal_r+0x5f8>
 3209850:	00800044 	movi	r2,1
 3209854:	dc400d17 	ldw	r17,52(sp)
 3209858:	18800115 	stw	r2,4(r3)
 320985c:	d8814917 	ldw	r2,1316(sp)
 3209860:	94800044 	addi	r18,r18,1
 3209864:	8c400044 	addi	r17,r17,1
 3209868:	18800015 	stw	r2,0(r3)
 320986c:	008001c4 	movi	r2,7
 3209870:	dc800e15 	stw	r18,56(sp)
 3209874:	dc400d15 	stw	r17,52(sp)
 3209878:	1440ca16 	blt	r2,r17,3209ba4 <___vfprintf_internal_r+0x198c>
 320987c:	18c00204 	addi	r3,r3,8
 3209880:	0121c83a 	sub	r16,zero,r4
 3209884:	0400500e 	bge	zero,r16,32099c8 <___vfprintf_internal_r+0x17b0>
 3209888:	00800404 	movi	r2,16
 320988c:	1400800e 	bge	r2,r16,3209a90 <___vfprintf_internal_r+0x1878>
 3209890:	1027883a 	mov	r19,r2
 3209894:	0700c974 	movhi	fp,805
 3209898:	e737c184 	addi	fp,fp,-8442
 320989c:	050001c4 	movi	r20,7
 32098a0:	00000306 	br	32098b0 <___vfprintf_internal_r+0x1698>
 32098a4:	18c00204 	addi	r3,r3,8
 32098a8:	843ffc04 	addi	r16,r16,-16
 32098ac:	9c007a0e 	bge	r19,r16,3209a98 <___vfprintf_internal_r+0x1880>
 32098b0:	94800404 	addi	r18,r18,16
 32098b4:	8c400044 	addi	r17,r17,1
 32098b8:	1f000015 	stw	fp,0(r3)
 32098bc:	1cc00115 	stw	r19,4(r3)
 32098c0:	dc800e15 	stw	r18,56(sp)
 32098c4:	dc400d15 	stw	r17,52(sp)
 32098c8:	a47ff60e 	bge	r20,r17,32098a4 <___vfprintf_internal_r+0x168c>
 32098cc:	d9014f17 	ldw	r4,1340(sp)
 32098d0:	b00b883a 	mov	r5,r22
 32098d4:	d9800c04 	addi	r6,sp,48
 32098d8:	32081c00 	call	32081c0 <__sprint_r>
 32098dc:	103c061e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 32098e0:	dc800e17 	ldw	r18,56(sp)
 32098e4:	dc400d17 	ldw	r17,52(sp)
 32098e8:	d8c01904 	addi	r3,sp,100
 32098ec:	003fee06 	br	32098a8 <___vfprintf_internal_r+0x1690>
 32098f0:	3c000017 	ldw	r16,0(r7)
 32098f4:	0023883a 	mov	r17,zero
 32098f8:	39c00104 	addi	r7,r7,4
 32098fc:	d9c14015 	stw	r7,1280(sp)
 3209900:	003e9206 	br	320934c <___vfprintf_internal_r+0x1134>
 3209904:	d9401904 	addi	r5,sp,100
 3209908:	dd000f04 	addi	r20,sp,60
 320990c:	d9414115 	stw	r5,1284(sp)
 3209910:	d9814417 	ldw	r6,1296(sp)
 3209914:	880a973a 	slli	r5,r17,28
 3209918:	8004d13a 	srli	r2,r16,4
 320991c:	810003cc 	andi	r4,r16,15
 3209920:	3109883a 	add	r4,r6,r4
 3209924:	2884b03a 	or	r2,r5,r2
 3209928:	21400003 	ldbu	r5,0(r4)
 320992c:	d9014117 	ldw	r4,1284(sp)
 3209930:	8806d13a 	srli	r3,r17,4
 3209934:	1021883a 	mov	r16,r2
 3209938:	213fffc4 	addi	r4,r4,-1
 320993c:	d9014115 	stw	r4,1284(sp)
 3209940:	d9814117 	ldw	r6,1284(sp)
 3209944:	10c8b03a 	or	r4,r2,r3
 3209948:	1823883a 	mov	r17,r3
 320994c:	31400005 	stb	r5,0(r6)
 3209950:	203fef1e 	bne	r4,zero,3209910 <___vfprintf_internal_r+0x16f8>
 3209954:	003ccb06 	br	3208c84 <___vfprintf_internal_r+0xa6c>
 3209958:	00800c04 	movi	r2,48
 320995c:	d98018c4 	addi	r6,sp,99
 3209960:	dd000f04 	addi	r20,sp,60
 3209964:	d88018c5 	stb	r2,99(sp)
 3209968:	d9814115 	stw	r6,1284(sp)
 320996c:	003cc506 	br	3208c84 <___vfprintf_internal_r+0xa6c>
 3209970:	dc400d17 	ldw	r17,52(sp)
 3209974:	0700c974 	movhi	fp,805
 3209978:	e737c584 	addi	fp,fp,-8426
 320997c:	003bc706 	br	320889c <___vfprintf_internal_r+0x684>
 3209980:	d9414c17 	ldw	r5,1328(sp)
 3209984:	2880040c 	andi	r2,r5,16
 3209988:	10007c26 	beq	r2,zero,3209b7c <___vfprintf_internal_r+0x1964>
 320998c:	38800017 	ldw	r2,0(r7)
 3209990:	39c00104 	addi	r7,r7,4
 3209994:	d9c14015 	stw	r7,1280(sp)
 3209998:	d9814b17 	ldw	r6,1324(sp)
 320999c:	d9c14017 	ldw	r7,1280(sp)
 32099a0:	11800015 	stw	r6,0(r2)
 32099a4:	003a7806 	br	3208388 <___vfprintf_internal_r+0x170>
 32099a8:	d9014f17 	ldw	r4,1340(sp)
 32099ac:	b00b883a 	mov	r5,r22
 32099b0:	d9800c04 	addi	r6,sp,48
 32099b4:	32081c00 	call	32081c0 <__sprint_r>
 32099b8:	103bcf1e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 32099bc:	dc800e17 	ldw	r18,56(sp)
 32099c0:	dc400d17 	ldw	r17,52(sp)
 32099c4:	d8c01904 	addi	r3,sp,100
 32099c8:	d9014717 	ldw	r4,1308(sp)
 32099cc:	d9414117 	ldw	r5,1284(sp)
 32099d0:	8c400044 	addi	r17,r17,1
 32099d4:	9125883a 	add	r18,r18,r4
 32099d8:	008001c4 	movi	r2,7
 32099dc:	19400015 	stw	r5,0(r3)
 32099e0:	19000115 	stw	r4,4(r3)
 32099e4:	dc800e15 	stw	r18,56(sp)
 32099e8:	dc400d15 	stw	r17,52(sp)
 32099ec:	147cee16 	blt	r2,r17,3208da8 <___vfprintf_internal_r+0xb90>
 32099f0:	18c00204 	addi	r3,r3,8
 32099f4:	003b8606 	br	3208810 <___vfprintf_internal_r+0x5f8>
 32099f8:	38c00017 	ldw	r3,0(r7)
 32099fc:	39000204 	addi	r4,r7,8
 3209a00:	d9014015 	stw	r4,1280(sp)
 3209a04:	d8c14215 	stw	r3,1288(sp)
 3209a08:	39c00117 	ldw	r7,4(r7)
 3209a0c:	d9c14315 	stw	r7,1292(sp)
 3209a10:	003e2006 	br	3209294 <___vfprintf_internal_r+0x107c>
 3209a14:	0005883a 	mov	r2,zero
 3209a18:	1409c83a 	sub	r4,r2,r16
 3209a1c:	1105803a 	cmpltu	r2,r2,r4
 3209a20:	044bc83a 	sub	r5,zero,r17
 3209a24:	2885c83a 	sub	r2,r5,r2
 3209a28:	2021883a 	mov	r16,r4
 3209a2c:	1023883a 	mov	r17,r2
 3209a30:	01000044 	movi	r4,1
 3209a34:	00800b44 	movi	r2,45
 3209a38:	d8800405 	stb	r2,16(sp)
 3209a3c:	003c8406 	br	3208c50 <___vfprintf_internal_r+0xa38>
 3209a40:	d9014f17 	ldw	r4,1340(sp)
 3209a44:	b00b883a 	mov	r5,r22
 3209a48:	d9800c04 	addi	r6,sp,48
 3209a4c:	32081c00 	call	32081c0 <__sprint_r>
 3209a50:	103ba91e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3209a54:	dc800e17 	ldw	r18,56(sp)
 3209a58:	dc400d17 	ldw	r17,52(sp)
 3209a5c:	d9000517 	ldw	r4,20(sp)
 3209a60:	d9401904 	addi	r5,sp,100
 3209a64:	003da706 	br	3209104 <___vfprintf_internal_r+0xeec>
 3209a68:	d9014f17 	ldw	r4,1340(sp)
 3209a6c:	b00b883a 	mov	r5,r22
 3209a70:	d9800c04 	addi	r6,sp,48
 3209a74:	32081c00 	call	32081c0 <__sprint_r>
 3209a78:	103b9f1e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3209a7c:	dc800e17 	ldw	r18,56(sp)
 3209a80:	dc400d17 	ldw	r17,52(sp)
 3209a84:	d9000517 	ldw	r4,20(sp)
 3209a88:	d8c01904 	addi	r3,sp,100
 3209a8c:	003d9106 	br	32090d4 <___vfprintf_internal_r+0xebc>
 3209a90:	0700c974 	movhi	fp,805
 3209a94:	e737c184 	addi	fp,fp,-8442
 3209a98:	9425883a 	add	r18,r18,r16
 3209a9c:	8c400044 	addi	r17,r17,1
 3209aa0:	008001c4 	movi	r2,7
 3209aa4:	1f000015 	stw	fp,0(r3)
 3209aa8:	1c000115 	stw	r16,4(r3)
 3209aac:	dc800e15 	stw	r18,56(sp)
 3209ab0:	dc400d15 	stw	r17,52(sp)
 3209ab4:	147fbc16 	blt	r2,r17,32099a8 <___vfprintf_internal_r+0x1790>
 3209ab8:	18c00204 	addi	r3,r3,8
 3209abc:	003fc206 	br	32099c8 <___vfprintf_internal_r+0x17b0>
 3209ac0:	d9014f17 	ldw	r4,1340(sp)
 3209ac4:	b00b883a 	mov	r5,r22
 3209ac8:	d9800c04 	addi	r6,sp,48
 3209acc:	32081c00 	call	32081c0 <__sprint_r>
 3209ad0:	103b891e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3209ad4:	dc800e17 	ldw	r18,56(sp)
 3209ad8:	d9000517 	ldw	r4,20(sp)
 3209adc:	d8c01904 	addi	r3,sp,100
 3209ae0:	003d0206 	br	3208eec <___vfprintf_internal_r+0xcd4>
 3209ae4:	0700c974 	movhi	fp,805
 3209ae8:	e737c184 	addi	fp,fp,-8442
 3209aec:	003be406 	br	3208a80 <___vfprintf_internal_r+0x868>
 3209af0:	0080c974 	movhi	r2,805
 3209af4:	10b7b004 	addi	r2,r2,-8512
 3209af8:	d8814115 	stw	r2,1284(sp)
 3209afc:	003df506 	br	32092d4 <___vfprintf_internal_r+0x10bc>
 3209b00:	d9014217 	ldw	r4,1288(sp)
 3209b04:	d9414317 	ldw	r5,1292(sp)
 3209b08:	320eac00 	call	320eac0 <__isnand>
 3209b0c:	10003926 	beq	r2,zero,3209bf4 <___vfprintf_internal_r+0x19dc>
 3209b10:	d9414d17 	ldw	r5,1332(sp)
 3209b14:	008011c4 	movi	r2,71
 3209b18:	1140ce16 	blt	r2,r5,3209e54 <___vfprintf_internal_r+0x1c3c>
 3209b1c:	0180c974 	movhi	r6,805
 3209b20:	31b7b104 	addi	r6,r6,-8508
 3209b24:	d9814115 	stw	r6,1284(sp)
 3209b28:	003dea06 	br	32092d4 <___vfprintf_internal_r+0x10bc>
 3209b2c:	d9014c17 	ldw	r4,1328(sp)
 3209b30:	bdc00044 	addi	r23,r23,1
 3209b34:	b8c00007 	ldb	r3,0(r23)
 3209b38:	21000814 	ori	r4,r4,32
 3209b3c:	d9014c15 	stw	r4,1328(sp)
 3209b40:	003a3406 	br	3208414 <___vfprintf_internal_r+0x1fc>
 3209b44:	dcc14515 	stw	r19,1300(sp)
 3209b48:	98011016 	blt	r19,zero,3209f8c <___vfprintf_internal_r+0x1d74>
 3209b4c:	980f883a 	mov	r7,r19
 3209b50:	d8014615 	stw	zero,1304(sp)
 3209b54:	003c5206 	br	3208ca0 <___vfprintf_internal_r+0xa88>
 3209b58:	d9014f17 	ldw	r4,1340(sp)
 3209b5c:	b00b883a 	mov	r5,r22
 3209b60:	d9800c04 	addi	r6,sp,48
 3209b64:	32081c00 	call	32081c0 <__sprint_r>
 3209b68:	103b631e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3209b6c:	dc800e17 	ldw	r18,56(sp)
 3209b70:	d9000517 	ldw	r4,20(sp)
 3209b74:	d8c01904 	addi	r3,sp,100
 3209b78:	003f2e06 	br	3209834 <___vfprintf_internal_r+0x161c>
 3209b7c:	d8c14c17 	ldw	r3,1328(sp)
 3209b80:	1880100c 	andi	r2,r3,64
 3209b84:	1000a026 	beq	r2,zero,3209e08 <___vfprintf_internal_r+0x1bf0>
 3209b88:	38800017 	ldw	r2,0(r7)
 3209b8c:	39c00104 	addi	r7,r7,4
 3209b90:	d9c14015 	stw	r7,1280(sp)
 3209b94:	d9014b17 	ldw	r4,1324(sp)
 3209b98:	d9c14017 	ldw	r7,1280(sp)
 3209b9c:	1100000d 	sth	r4,0(r2)
 3209ba0:	0039f906 	br	3208388 <___vfprintf_internal_r+0x170>
 3209ba4:	d9014f17 	ldw	r4,1340(sp)
 3209ba8:	b00b883a 	mov	r5,r22
 3209bac:	d9800c04 	addi	r6,sp,48
 3209bb0:	32081c00 	call	32081c0 <__sprint_r>
 3209bb4:	103b501e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3209bb8:	dc800e17 	ldw	r18,56(sp)
 3209bbc:	dc400d17 	ldw	r17,52(sp)
 3209bc0:	d9000517 	ldw	r4,20(sp)
 3209bc4:	d8c01904 	addi	r3,sp,100
 3209bc8:	003f2d06 	br	3209880 <___vfprintf_internal_r+0x1668>
 3209bcc:	00800184 	movi	r2,6
 3209bd0:	14c09a36 	bltu	r2,r19,3209e3c <___vfprintf_internal_r+0x1c24>
 3209bd4:	dcc14515 	stw	r19,1300(sp)
 3209bd8:	9800010e 	bge	r19,zero,3209be0 <___vfprintf_internal_r+0x19c8>
 3209bdc:	d8014515 	stw	zero,1300(sp)
 3209be0:	0080c974 	movhi	r2,805
 3209be4:	10b7b304 	addi	r2,r2,-8500
 3209be8:	980f883a 	mov	r7,r19
 3209bec:	d8814115 	stw	r2,1284(sp)
 3209bf0:	003a7806 	br	32085d4 <___vfprintf_internal_r+0x3bc>
 3209bf4:	00bfffc4 	movi	r2,-1
 3209bf8:	9880e226 	beq	r19,r2,3209f84 <___vfprintf_internal_r+0x1d6c>
 3209bfc:	d9414d17 	ldw	r5,1332(sp)
 3209c00:	008019c4 	movi	r2,103
 3209c04:	2880dc26 	beq	r5,r2,3209f78 <___vfprintf_internal_r+0x1d60>
 3209c08:	008011c4 	movi	r2,71
 3209c0c:	2880da26 	beq	r5,r2,3209f78 <___vfprintf_internal_r+0x1d60>
 3209c10:	d9414c17 	ldw	r5,1328(sp)
 3209c14:	d9014317 	ldw	r4,1292(sp)
 3209c18:	d9814217 	ldw	r6,1288(sp)
 3209c1c:	29404014 	ori	r5,r5,256
 3209c20:	d9414c15 	stw	r5,1328(sp)
 3209c24:	2000cc16 	blt	r4,zero,3209f58 <___vfprintf_internal_r+0x1d40>
 3209c28:	3021883a 	mov	r16,r6
 3209c2c:	2023883a 	mov	r17,r4
 3209c30:	0039883a 	mov	fp,zero
 3209c34:	d9414d17 	ldw	r5,1332(sp)
 3209c38:	00801984 	movi	r2,102
 3209c3c:	2880b726 	beq	r5,r2,3209f1c <___vfprintf_internal_r+0x1d04>
 3209c40:	00801184 	movi	r2,70
 3209c44:	2880b526 	beq	r5,r2,3209f1c <___vfprintf_internal_r+0x1d04>
 3209c48:	00801944 	movi	r2,101
 3209c4c:	2880c826 	beq	r5,r2,3209f70 <___vfprintf_internal_r+0x1d58>
 3209c50:	00801144 	movi	r2,69
 3209c54:	2880c626 	beq	r5,r2,3209f70 <___vfprintf_internal_r+0x1d58>
 3209c58:	9829883a 	mov	r20,r19
 3209c5c:	d9014f17 	ldw	r4,1340(sp)
 3209c60:	d8800504 	addi	r2,sp,20
 3209c64:	880d883a 	mov	r6,r17
 3209c68:	d8800115 	stw	r2,4(sp)
 3209c6c:	d8c00604 	addi	r3,sp,24
 3209c70:	d8800704 	addi	r2,sp,28
 3209c74:	800b883a 	mov	r5,r16
 3209c78:	01c00084 	movi	r7,2
 3209c7c:	d8c00215 	stw	r3,8(sp)
 3209c80:	d8800315 	stw	r2,12(sp)
 3209c84:	dd000015 	stw	r20,0(sp)
 3209c88:	320bdf00 	call	320bdf0 <_dtoa_r>
 3209c8c:	d9814d17 	ldw	r6,1332(sp)
 3209c90:	d8814115 	stw	r2,1284(sp)
 3209c94:	008019c4 	movi	r2,103
 3209c98:	30809526 	beq	r6,r2,3209ef0 <___vfprintf_internal_r+0x1cd8>
 3209c9c:	d8c14d17 	ldw	r3,1332(sp)
 3209ca0:	008011c4 	movi	r2,71
 3209ca4:	18809226 	beq	r3,r2,3209ef0 <___vfprintf_internal_r+0x1cd8>
 3209ca8:	d9414117 	ldw	r5,1284(sp)
 3209cac:	d9814d17 	ldw	r6,1332(sp)
 3209cb0:	00801984 	movi	r2,102
 3209cb4:	2d25883a 	add	r18,r5,r20
 3209cb8:	30808626 	beq	r6,r2,3209ed4 <___vfprintf_internal_r+0x1cbc>
 3209cbc:	00801184 	movi	r2,70
 3209cc0:	30808426 	beq	r6,r2,3209ed4 <___vfprintf_internal_r+0x1cbc>
 3209cc4:	000d883a 	mov	r6,zero
 3209cc8:	000f883a 	mov	r7,zero
 3209ccc:	880b883a 	mov	r5,r17
 3209cd0:	8009883a 	mov	r4,r16
 3209cd4:	32135c40 	call	32135c4 <__eqdf2>
 3209cd8:	1000751e 	bne	r2,zero,3209eb0 <___vfprintf_internal_r+0x1c98>
 3209cdc:	9005883a 	mov	r2,r18
 3209ce0:	dc800715 	stw	r18,28(sp)
 3209ce4:	d9014117 	ldw	r4,1284(sp)
 3209ce8:	d9414d17 	ldw	r5,1332(sp)
 3209cec:	00c019c4 	movi	r3,103
 3209cf0:	1125c83a 	sub	r18,r2,r4
 3209cf4:	28c06826 	beq	r5,r3,3209e98 <___vfprintf_internal_r+0x1c80>
 3209cf8:	008011c4 	movi	r2,71
 3209cfc:	28806626 	beq	r5,r2,3209e98 <___vfprintf_internal_r+0x1c80>
 3209d00:	d9000517 	ldw	r4,20(sp)
 3209d04:	d8c14d17 	ldw	r3,1332(sp)
 3209d08:	00801944 	movi	r2,101
 3209d0c:	10c05516 	blt	r2,r3,3209e64 <___vfprintf_internal_r+0x1c4c>
 3209d10:	213fffc4 	addi	r4,r4,-1
 3209d14:	d9000515 	stw	r4,20(sp)
 3209d18:	d8c00805 	stb	r3,32(sp)
 3209d1c:	2021883a 	mov	r16,r4
 3209d20:	2000c116 	blt	r4,zero,320a028 <___vfprintf_internal_r+0x1e10>
 3209d24:	00800ac4 	movi	r2,43
 3209d28:	d8800845 	stb	r2,33(sp)
 3209d2c:	00800244 	movi	r2,9
 3209d30:	1400af0e 	bge	r2,r16,3209ff0 <___vfprintf_internal_r+0x1dd8>
 3209d34:	1027883a 	mov	r19,r2
 3209d38:	dc400b84 	addi	r17,sp,46
 3209d3c:	8009883a 	mov	r4,r16
 3209d40:	01400284 	movi	r5,10
 3209d44:	320445c0 	call	320445c <__modsi3>
 3209d48:	10800c04 	addi	r2,r2,48
 3209d4c:	8c7fffc4 	addi	r17,r17,-1
 3209d50:	8009883a 	mov	r4,r16
 3209d54:	01400284 	movi	r5,10
 3209d58:	88800005 	stb	r2,0(r17)
 3209d5c:	32043fc0 	call	32043fc <__divsi3>
 3209d60:	1021883a 	mov	r16,r2
 3209d64:	98bff516 	blt	r19,r2,3209d3c <___vfprintf_internal_r+0x1b24>
 3209d68:	10c00c04 	addi	r3,r2,48
 3209d6c:	d88009c4 	addi	r2,sp,39
 3209d70:	108001c4 	addi	r2,r2,7
 3209d74:	897fffc4 	addi	r5,r17,-1
 3209d78:	88ffffc5 	stb	r3,-1(r17)
 3209d7c:	2880a72e 	bgeu	r5,r2,320a01c <___vfprintf_internal_r+0x1e04>
 3209d80:	1009883a 	mov	r4,r2
 3209d84:	d9800804 	addi	r6,sp,32
 3209d88:	d8c00884 	addi	r3,sp,34
 3209d8c:	28800003 	ldbu	r2,0(r5)
 3209d90:	29400044 	addi	r5,r5,1
 3209d94:	18800005 	stb	r2,0(r3)
 3209d98:	18c00044 	addi	r3,r3,1
 3209d9c:	293ffb36 	bltu	r5,r4,3209d8c <___vfprintf_internal_r+0x1b74>
 3209da0:	1987c83a 	sub	r3,r3,r6
 3209da4:	00800044 	movi	r2,1
 3209da8:	d8c14815 	stw	r3,1312(sp)
 3209dac:	90cf883a 	add	r7,r18,r3
 3209db0:	1480960e 	bge	r2,r18,320a00c <___vfprintf_internal_r+0x1df4>
 3209db4:	39c00044 	addi	r7,r7,1
 3209db8:	d9c14515 	stw	r7,1300(sp)
 3209dbc:	38003416 	blt	r7,zero,3209e90 <___vfprintf_internal_r+0x1c78>
 3209dc0:	e0803fcc 	andi	r2,fp,255
 3209dc4:	1080201c 	xori	r2,r2,128
 3209dc8:	10bfe004 	addi	r2,r2,-128
 3209dcc:	10004e26 	beq	r2,zero,3209f08 <___vfprintf_internal_r+0x1cf0>
 3209dd0:	00800b44 	movi	r2,45
 3209dd4:	dc814715 	stw	r18,1308(sp)
 3209dd8:	d8014615 	stw	zero,1304(sp)
 3209ddc:	d8800405 	stb	r2,16(sp)
 3209de0:	003bb106 	br	3208ca8 <___vfprintf_internal_r+0xa90>
 3209de4:	00800b44 	movi	r2,45
 3209de8:	d8800405 	stb	r2,16(sp)
 3209dec:	003d3306 	br	32092bc <___vfprintf_internal_r+0x10a4>
 3209df0:	d9014f17 	ldw	r4,1340(sp)
 3209df4:	b00b883a 	mov	r5,r22
 3209df8:	d9800c04 	addi	r6,sp,48
 3209dfc:	32081c00 	call	32081c0 <__sprint_r>
 3209e00:	103abd1e 	bne	r2,zero,32088f8 <___vfprintf_internal_r+0x6e0>
 3209e04:	003abb06 	br	32088f4 <___vfprintf_internal_r+0x6dc>
 3209e08:	38800017 	ldw	r2,0(r7)
 3209e0c:	39c00104 	addi	r7,r7,4
 3209e10:	d9c14015 	stw	r7,1280(sp)
 3209e14:	d9414b17 	ldw	r5,1324(sp)
 3209e18:	d9c14017 	ldw	r7,1280(sp)
 3209e1c:	11400015 	stw	r5,0(r2)
 3209e20:	00395906 	br	3208388 <___vfprintf_internal_r+0x170>
 3209e24:	980f883a 	mov	r7,r19
 3209e28:	dcc14515 	stw	r19,1300(sp)
 3209e2c:	d8014615 	stw	zero,1304(sp)
 3209e30:	003b9b06 	br	3208ca0 <___vfprintf_internal_r+0xa88>
 3209e34:	0027883a 	mov	r19,zero
 3209e38:	00397806 	br	320841c <___vfprintf_internal_r+0x204>
 3209e3c:	00c0c974 	movhi	r3,805
 3209e40:	18f7b304 	addi	r3,r3,-8500
 3209e44:	100f883a 	mov	r7,r2
 3209e48:	d8814515 	stw	r2,1300(sp)
 3209e4c:	d8c14115 	stw	r3,1284(sp)
 3209e50:	0039e006 	br	32085d4 <___vfprintf_internal_r+0x3bc>
 3209e54:	0080c974 	movhi	r2,805
 3209e58:	10b7b204 	addi	r2,r2,-8504
 3209e5c:	d8814115 	stw	r2,1284(sp)
 3209e60:	003d1c06 	br	32092d4 <___vfprintf_internal_r+0x10bc>
 3209e64:	d9414d17 	ldw	r5,1332(sp)
 3209e68:	00801984 	movi	r2,102
 3209e6c:	28804926 	beq	r5,r2,3209f94 <___vfprintf_internal_r+0x1d7c>
 3209e70:	200f883a 	mov	r7,r4
 3209e74:	24805716 	blt	r4,r18,3209fd4 <___vfprintf_internal_r+0x1dbc>
 3209e78:	d9414c17 	ldw	r5,1328(sp)
 3209e7c:	2880004c 	andi	r2,r5,1
 3209e80:	10000126 	beq	r2,zero,3209e88 <___vfprintf_internal_r+0x1c70>
 3209e84:	21c00044 	addi	r7,r4,1
 3209e88:	d9c14515 	stw	r7,1300(sp)
 3209e8c:	383fcc0e 	bge	r7,zero,3209dc0 <___vfprintf_internal_r+0x1ba8>
 3209e90:	d8014515 	stw	zero,1300(sp)
 3209e94:	003fca06 	br	3209dc0 <___vfprintf_internal_r+0x1ba8>
 3209e98:	d9000517 	ldw	r4,20(sp)
 3209e9c:	00bfff04 	movi	r2,-4
 3209ea0:	1100480e 	bge	r2,r4,3209fc4 <___vfprintf_internal_r+0x1dac>
 3209ea4:	99004716 	blt	r19,r4,3209fc4 <___vfprintf_internal_r+0x1dac>
 3209ea8:	d8c14d15 	stw	r3,1332(sp)
 3209eac:	003ff006 	br	3209e70 <___vfprintf_internal_r+0x1c58>
 3209eb0:	d8800717 	ldw	r2,28(sp)
 3209eb4:	14bf8b2e 	bgeu	r2,r18,3209ce4 <___vfprintf_internal_r+0x1acc>
 3209eb8:	9007883a 	mov	r3,r18
 3209ebc:	01000c04 	movi	r4,48
 3209ec0:	11000005 	stb	r4,0(r2)
 3209ec4:	10800044 	addi	r2,r2,1
 3209ec8:	d8800715 	stw	r2,28(sp)
 3209ecc:	18bffc1e 	bne	r3,r2,3209ec0 <___vfprintf_internal_r+0x1ca8>
 3209ed0:	003f8406 	br	3209ce4 <___vfprintf_internal_r+0x1acc>
 3209ed4:	d8814117 	ldw	r2,1284(sp)
 3209ed8:	10c00007 	ldb	r3,0(r2)
 3209edc:	00800c04 	movi	r2,48
 3209ee0:	18805b26 	beq	r3,r2,320a050 <___vfprintf_internal_r+0x1e38>
 3209ee4:	d9000517 	ldw	r4,20(sp)
 3209ee8:	9125883a 	add	r18,r18,r4
 3209eec:	003f7506 	br	3209cc4 <___vfprintf_internal_r+0x1aac>
 3209ef0:	d9014c17 	ldw	r4,1328(sp)
 3209ef4:	2080004c 	andi	r2,r4,1
 3209ef8:	1005003a 	cmpeq	r2,r2,zero
 3209efc:	103f6a26 	beq	r2,zero,3209ca8 <___vfprintf_internal_r+0x1a90>
 3209f00:	d8800717 	ldw	r2,28(sp)
 3209f04:	003f7706 	br	3209ce4 <___vfprintf_internal_r+0x1acc>
 3209f08:	d9c14515 	stw	r7,1300(sp)
 3209f0c:	38004d16 	blt	r7,zero,320a044 <___vfprintf_internal_r+0x1e2c>
 3209f10:	dc814715 	stw	r18,1308(sp)
 3209f14:	d8014615 	stw	zero,1304(sp)
 3209f18:	003b6106 	br	3208ca0 <___vfprintf_internal_r+0xa88>
 3209f1c:	d9014f17 	ldw	r4,1340(sp)
 3209f20:	d8800504 	addi	r2,sp,20
 3209f24:	d8800115 	stw	r2,4(sp)
 3209f28:	d8c00604 	addi	r3,sp,24
 3209f2c:	d8800704 	addi	r2,sp,28
 3209f30:	800b883a 	mov	r5,r16
 3209f34:	880d883a 	mov	r6,r17
 3209f38:	01c000c4 	movi	r7,3
 3209f3c:	d8c00215 	stw	r3,8(sp)
 3209f40:	d8800315 	stw	r2,12(sp)
 3209f44:	dcc00015 	stw	r19,0(sp)
 3209f48:	9829883a 	mov	r20,r19
 3209f4c:	320bdf00 	call	320bdf0 <_dtoa_r>
 3209f50:	d8814115 	stw	r2,1284(sp)
 3209f54:	003f5106 	br	3209c9c <___vfprintf_internal_r+0x1a84>
 3209f58:	d8c14217 	ldw	r3,1288(sp)
 3209f5c:	d9014317 	ldw	r4,1292(sp)
 3209f60:	07000b44 	movi	fp,45
 3209f64:	1821883a 	mov	r16,r3
 3209f68:	2460003c 	xorhi	r17,r4,32768
 3209f6c:	003f3106 	br	3209c34 <___vfprintf_internal_r+0x1a1c>
 3209f70:	9d000044 	addi	r20,r19,1
 3209f74:	003f3906 	br	3209c5c <___vfprintf_internal_r+0x1a44>
 3209f78:	983f251e 	bne	r19,zero,3209c10 <___vfprintf_internal_r+0x19f8>
 3209f7c:	04c00044 	movi	r19,1
 3209f80:	003f2306 	br	3209c10 <___vfprintf_internal_r+0x19f8>
 3209f84:	04c00184 	movi	r19,6
 3209f88:	003f2106 	br	3209c10 <___vfprintf_internal_r+0x19f8>
 3209f8c:	d8014515 	stw	zero,1300(sp)
 3209f90:	003eee06 	br	3209b4c <___vfprintf_internal_r+0x1934>
 3209f94:	200f883a 	mov	r7,r4
 3209f98:	0100370e 	bge	zero,r4,320a078 <___vfprintf_internal_r+0x1e60>
 3209f9c:	9800031e 	bne	r19,zero,3209fac <___vfprintf_internal_r+0x1d94>
 3209fa0:	d9814c17 	ldw	r6,1328(sp)
 3209fa4:	3080004c 	andi	r2,r6,1
 3209fa8:	103fb726 	beq	r2,zero,3209e88 <___vfprintf_internal_r+0x1c70>
 3209fac:	20800044 	addi	r2,r4,1
 3209fb0:	98a7883a 	add	r19,r19,r2
 3209fb4:	dcc14515 	stw	r19,1300(sp)
 3209fb8:	980f883a 	mov	r7,r19
 3209fbc:	983f800e 	bge	r19,zero,3209dc0 <___vfprintf_internal_r+0x1ba8>
 3209fc0:	003fb306 	br	3209e90 <___vfprintf_internal_r+0x1c78>
 3209fc4:	d9814d17 	ldw	r6,1332(sp)
 3209fc8:	31bfff84 	addi	r6,r6,-2
 3209fcc:	d9814d15 	stw	r6,1332(sp)
 3209fd0:	003f4c06 	br	3209d04 <___vfprintf_internal_r+0x1aec>
 3209fd4:	0100180e 	bge	zero,r4,320a038 <___vfprintf_internal_r+0x1e20>
 3209fd8:	00800044 	movi	r2,1
 3209fdc:	1485883a 	add	r2,r2,r18
 3209fe0:	d8814515 	stw	r2,1300(sp)
 3209fe4:	100f883a 	mov	r7,r2
 3209fe8:	103f750e 	bge	r2,zero,3209dc0 <___vfprintf_internal_r+0x1ba8>
 3209fec:	003fa806 	br	3209e90 <___vfprintf_internal_r+0x1c78>
 3209ff0:	80c00c04 	addi	r3,r16,48
 3209ff4:	00800c04 	movi	r2,48
 3209ff8:	d8c008c5 	stb	r3,35(sp)
 3209ffc:	d9800804 	addi	r6,sp,32
 320a000:	d8c00904 	addi	r3,sp,36
 320a004:	d8800885 	stb	r2,34(sp)
 320a008:	003f6506 	br	3209da0 <___vfprintf_internal_r+0x1b88>
 320a00c:	d9014c17 	ldw	r4,1328(sp)
 320a010:	2084703a 	and	r2,r4,r2
 320a014:	103f9c26 	beq	r2,zero,3209e88 <___vfprintf_internal_r+0x1c70>
 320a018:	003f6606 	br	3209db4 <___vfprintf_internal_r+0x1b9c>
 320a01c:	d9800804 	addi	r6,sp,32
 320a020:	d8c00884 	addi	r3,sp,34
 320a024:	003f5e06 	br	3209da0 <___vfprintf_internal_r+0x1b88>
 320a028:	00800b44 	movi	r2,45
 320a02c:	0121c83a 	sub	r16,zero,r4
 320a030:	d8800845 	stb	r2,33(sp)
 320a034:	003f3d06 	br	3209d2c <___vfprintf_internal_r+0x1b14>
 320a038:	00800084 	movi	r2,2
 320a03c:	1105c83a 	sub	r2,r2,r4
 320a040:	003fe606 	br	3209fdc <___vfprintf_internal_r+0x1dc4>
 320a044:	d8014515 	stw	zero,1300(sp)
 320a048:	dc814715 	stw	r18,1308(sp)
 320a04c:	003fb106 	br	3209f14 <___vfprintf_internal_r+0x1cfc>
 320a050:	000d883a 	mov	r6,zero
 320a054:	000f883a 	mov	r7,zero
 320a058:	8009883a 	mov	r4,r16
 320a05c:	880b883a 	mov	r5,r17
 320a060:	321364c0 	call	321364c <__nedf2>
 320a064:	103f9f26 	beq	r2,zero,3209ee4 <___vfprintf_internal_r+0x1ccc>
 320a068:	00800044 	movi	r2,1
 320a06c:	1509c83a 	sub	r4,r2,r20
 320a070:	d9000515 	stw	r4,20(sp)
 320a074:	003f9b06 	br	3209ee4 <___vfprintf_internal_r+0x1ccc>
 320a078:	98000d1e 	bne	r19,zero,320a0b0 <___vfprintf_internal_r+0x1e98>
 320a07c:	d8c14c17 	ldw	r3,1328(sp)
 320a080:	1880004c 	andi	r2,r3,1
 320a084:	10000a1e 	bne	r2,zero,320a0b0 <___vfprintf_internal_r+0x1e98>
 320a088:	01000044 	movi	r4,1
 320a08c:	200f883a 	mov	r7,r4
 320a090:	d9014515 	stw	r4,1300(sp)
 320a094:	003f4a06 	br	3209dc0 <___vfprintf_internal_r+0x1ba8>
 320a098:	3cc00017 	ldw	r19,0(r7)
 320a09c:	39c00104 	addi	r7,r7,4
 320a0a0:	983d0e0e 	bge	r19,zero,32094dc <___vfprintf_internal_r+0x12c4>
 320a0a4:	b8c00007 	ldb	r3,0(r23)
 320a0a8:	04ffffc4 	movi	r19,-1
 320a0ac:	0038d906 	br	3208414 <___vfprintf_internal_r+0x1fc>
 320a0b0:	9cc00084 	addi	r19,r19,2
 320a0b4:	dcc14515 	stw	r19,1300(sp)
 320a0b8:	980f883a 	mov	r7,r19
 320a0bc:	983f400e 	bge	r19,zero,3209dc0 <___vfprintf_internal_r+0x1ba8>
 320a0c0:	003f7306 	br	3209e90 <___vfprintf_internal_r+0x1c78>

0320a0c4 <__vfprintf_internal>:
 320a0c4:	0080c974 	movhi	r2,805
 320a0c8:	10897804 	addi	r2,r2,9696
 320a0cc:	2013883a 	mov	r9,r4
 320a0d0:	11000017 	ldw	r4,0(r2)
 320a0d4:	2805883a 	mov	r2,r5
 320a0d8:	300f883a 	mov	r7,r6
 320a0dc:	480b883a 	mov	r5,r9
 320a0e0:	100d883a 	mov	r6,r2
 320a0e4:	32082181 	jmpi	3208218 <___vfprintf_internal_r>

0320a0e8 <__svfscanf_r>:
 320a0e8:	deff4e04 	addi	sp,sp,-712
 320a0ec:	dd80ae15 	stw	r22,696(sp)
 320a0f0:	dd00ac15 	stw	r20,688(sp)
 320a0f4:	dc40a915 	stw	r17,676(sp)
 320a0f8:	dc00a815 	stw	r16,672(sp)
 320a0fc:	dfc0b115 	stw	ra,708(sp)
 320a100:	df00b015 	stw	fp,704(sp)
 320a104:	ddc0af15 	stw	r23,700(sp)
 320a108:	dd40ad15 	stw	r21,692(sp)
 320a10c:	dcc0ab15 	stw	r19,684(sp)
 320a110:	dc80aa15 	stw	r18,680(sp)
 320a114:	202d883a 	mov	r22,r4
 320a118:	2821883a 	mov	r16,r5
 320a11c:	d9c0a415 	stw	r7,656(sp)
 320a120:	3029883a 	mov	r20,r6
 320a124:	d800a215 	stw	zero,648(sp)
 320a128:	0023883a 	mov	r17,zero
 320a12c:	d800a115 	stw	zero,644(sp)
 320a130:	d800a015 	stw	zero,640(sp)
 320a134:	a1000007 	ldb	r4,0(r20)
 320a138:	d9000115 	stw	r4,4(sp)
 320a13c:	20001f26 	beq	r4,zero,320a1bc <__svfscanf_r+0xd4>
 320a140:	0480c974 	movhi	r18,805
 320a144:	94897704 	addi	r18,r18,9692
 320a148:	91800017 	ldw	r6,0(r18)
 320a14c:	a5000044 	addi	r20,r20,1
 320a150:	3107883a 	add	r3,r6,r4
 320a154:	18800003 	ldbu	r2,0(r3)
 320a158:	1080020c 	andi	r2,r2,8
 320a15c:	10002426 	beq	r2,zero,320a1f0 <__svfscanf_r+0x108>
 320a160:	80c00117 	ldw	r3,4(r16)
 320a164:	00c00e0e 	bge	zero,r3,320a1a0 <__svfscanf_r+0xb8>
 320a168:	81400017 	ldw	r5,0(r16)
 320a16c:	90800017 	ldw	r2,0(r18)
 320a170:	28c00003 	ldbu	r3,0(r5)
 320a174:	1887883a 	add	r3,r3,r2
 320a178:	19000003 	ldbu	r4,0(r3)
 320a17c:	2100020c 	andi	r4,r4,8
 320a180:	203fec26 	beq	r4,zero,320a134 <__svfscanf_r+0x4c>
 320a184:	80c00117 	ldw	r3,4(r16)
 320a188:	29800044 	addi	r6,r5,1
 320a18c:	8c400044 	addi	r17,r17,1
 320a190:	18ffffc4 	addi	r3,r3,-1
 320a194:	81800015 	stw	r6,0(r16)
 320a198:	80c00115 	stw	r3,4(r16)
 320a19c:	00fff216 	blt	zero,r3,320a168 <__svfscanf_r+0x80>
 320a1a0:	b009883a 	mov	r4,r22
 320a1a4:	800b883a 	mov	r5,r16
 320a1a8:	320740c0 	call	320740c <__srefill_r>
 320a1ac:	103fee26 	beq	r2,zero,320a168 <__svfscanf_r+0x80>
 320a1b0:	a1000007 	ldb	r4,0(r20)
 320a1b4:	d9000115 	stw	r4,4(sp)
 320a1b8:	203fe11e 	bne	r4,zero,320a140 <__svfscanf_r+0x58>
 320a1bc:	d880a217 	ldw	r2,648(sp)
 320a1c0:	dfc0b117 	ldw	ra,708(sp)
 320a1c4:	df00b017 	ldw	fp,704(sp)
 320a1c8:	ddc0af17 	ldw	r23,700(sp)
 320a1cc:	dd80ae17 	ldw	r22,696(sp)
 320a1d0:	dd40ad17 	ldw	r21,692(sp)
 320a1d4:	dd00ac17 	ldw	r20,688(sp)
 320a1d8:	dcc0ab17 	ldw	r19,684(sp)
 320a1dc:	dc80aa17 	ldw	r18,680(sp)
 320a1e0:	dc40a917 	ldw	r17,676(sp)
 320a1e4:	dc00a817 	ldw	r16,672(sp)
 320a1e8:	dec0b204 	addi	sp,sp,712
 320a1ec:	f800283a 	ret
 320a1f0:	00800944 	movi	r2,37
 320a1f4:	20801626 	beq	r4,r2,320a250 <__svfscanf_r+0x168>
 320a1f8:	80800117 	ldw	r2,4(r16)
 320a1fc:	00800b0e 	bge	zero,r2,320a22c <__svfscanf_r+0x144>
 320a200:	81000017 	ldw	r4,0(r16)
 320a204:	a0ffffc7 	ldb	r3,-1(r20)
 320a208:	20800003 	ldbu	r2,0(r4)
 320a20c:	10ffeb1e 	bne	r2,r3,320a1bc <__svfscanf_r+0xd4>
 320a210:	80c00117 	ldw	r3,4(r16)
 320a214:	21800044 	addi	r6,r4,1
 320a218:	8c400044 	addi	r17,r17,1
 320a21c:	18ffffc4 	addi	r3,r3,-1
 320a220:	80c00115 	stw	r3,4(r16)
 320a224:	81800015 	stw	r6,0(r16)
 320a228:	003fc206 	br	320a134 <__svfscanf_r+0x4c>
 320a22c:	b009883a 	mov	r4,r22
 320a230:	800b883a 	mov	r5,r16
 320a234:	320740c0 	call	320740c <__srefill_r>
 320a238:	103ff126 	beq	r2,zero,320a200 <__svfscanf_r+0x118>
 320a23c:	d900a217 	ldw	r4,648(sp)
 320a240:	2004c91e 	bne	r4,zero,320b568 <__svfscanf_r+0x1480>
 320a244:	00bfffc4 	movi	r2,-1
 320a248:	d880a215 	stw	r2,648(sp)
 320a24c:	003fdb06 	br	320a1bc <__svfscanf_r+0xd4>
 320a250:	d800a315 	stw	zero,652(sp)
 320a254:	0027883a 	mov	r19,zero
 320a258:	a0c00003 	ldbu	r3,0(r20)
 320a25c:	00801e04 	movi	r2,120
 320a260:	a5000044 	addi	r20,r20,1
 320a264:	19403fcc 	andi	r5,r3,255
 320a268:	2940201c 	xori	r5,r5,128
 320a26c:	297fe004 	addi	r5,r5,-128
 320a270:	10c08036 	bltu	r2,r3,320a474 <__svfscanf_r+0x38c>
 320a274:	18c5883a 	add	r2,r3,r3
 320a278:	1085883a 	add	r2,r2,r2
 320a27c:	00c0c874 	movhi	r3,801
 320a280:	18e8a404 	addi	r3,r3,-23920
 320a284:	10c5883a 	add	r2,r2,r3
 320a288:	11000017 	ldw	r4,0(r2)
 320a28c:	2000683a 	jmp	r4
 320a290:	0320a244 	movi	r12,-32119
 320a294:	0320a474 	movhi	r12,33425
 320a298:	0320a474 	movhi	r12,33425
 320a29c:	0320a474 	movhi	r12,33425
 320a2a0:	0320a474 	movhi	r12,33425
 320a2a4:	0320a474 	movhi	r12,33425
 320a2a8:	0320a474 	movhi	r12,33425
 320a2ac:	0320a474 	movhi	r12,33425
 320a2b0:	0320a474 	movhi	r12,33425
 320a2b4:	0320a474 	movhi	r12,33425
 320a2b8:	0320a474 	movhi	r12,33425
 320a2bc:	0320a474 	movhi	r12,33425
 320a2c0:	0320a474 	movhi	r12,33425
 320a2c4:	0320a474 	movhi	r12,33425
 320a2c8:	0320a474 	movhi	r12,33425
 320a2cc:	0320a474 	movhi	r12,33425
 320a2d0:	0320a474 	movhi	r12,33425
 320a2d4:	0320a474 	movhi	r12,33425
 320a2d8:	0320a474 	movhi	r12,33425
 320a2dc:	0320a474 	movhi	r12,33425
 320a2e0:	0320a474 	movhi	r12,33425
 320a2e4:	0320a474 	movhi	r12,33425
 320a2e8:	0320a474 	movhi	r12,33425
 320a2ec:	0320a474 	movhi	r12,33425
 320a2f0:	0320a474 	movhi	r12,33425
 320a2f4:	0320a474 	movhi	r12,33425
 320a2f8:	0320a474 	movhi	r12,33425
 320a2fc:	0320a474 	movhi	r12,33425
 320a300:	0320a474 	movhi	r12,33425
 320a304:	0320a474 	movhi	r12,33425
 320a308:	0320a474 	movhi	r12,33425
 320a30c:	0320a474 	movhi	r12,33425
 320a310:	0320a474 	movhi	r12,33425
 320a314:	0320a474 	movhi	r12,33425
 320a318:	0320a474 	movhi	r12,33425
 320a31c:	0320a474 	movhi	r12,33425
 320a320:	0320a474 	movhi	r12,33425
 320a324:	0320a1f8 	rdprs	r12,zero,-32121
 320a328:	0320a474 	movhi	r12,33425
 320a32c:	0320a474 	movhi	r12,33425
 320a330:	0320a474 	movhi	r12,33425
 320a334:	0320a474 	movhi	r12,33425
 320a338:	0320b498 	cmpnei	r12,zero,-32046
 320a33c:	0320a474 	movhi	r12,33425
 320a340:	0320a474 	movhi	r12,33425
 320a344:	0320a474 	movhi	r12,33425
 320a348:	0320a474 	movhi	r12,33425
 320a34c:	0320a474 	movhi	r12,33425
 320a350:	0320ae94 	movui	r12,33466
 320a354:	0320ae94 	movui	r12,33466
 320a358:	0320ae94 	movui	r12,33466
 320a35c:	0320ae94 	movui	r12,33466
 320a360:	0320ae94 	movui	r12,33466
 320a364:	0320ae94 	movui	r12,33466
 320a368:	0320ae94 	movui	r12,33466
 320a36c:	0320ae94 	movui	r12,33466
 320a370:	0320ae94 	movui	r12,33466
 320a374:	0320ae94 	movui	r12,33466
 320a378:	0320a474 	movhi	r12,33425
 320a37c:	0320a474 	movhi	r12,33425
 320a380:	0320a474 	movhi	r12,33425
 320a384:	0320a474 	movhi	r12,33425
 320a388:	0320a474 	movhi	r12,33425
 320a38c:	0320a474 	movhi	r12,33425
 320a390:	0320a474 	movhi	r12,33425
 320a394:	0320a474 	movhi	r12,33425
 320a398:	0320a474 	movhi	r12,33425
 320a39c:	0320a474 	movhi	r12,33425
 320a3a0:	0320b614 	movui	r12,33496
 320a3a4:	0320b60c 	andi	r12,zero,33496
 320a3a8:	0320a474 	movhi	r12,33425
 320a3ac:	0320b60c 	andi	r12,zero,33496
 320a3b0:	0320a474 	movhi	r12,33425
 320a3b4:	0320a474 	movhi	r12,33425
 320a3b8:	0320a474 	movhi	r12,33425
 320a3bc:	0320a474 	movhi	r12,33425
 320a3c0:	0320b6a4 	muli	r12,zero,-32038
 320a3c4:	0320a474 	movhi	r12,33425
 320a3c8:	0320a474 	movhi	r12,33425
 320a3cc:	0320b65c 	xori	r12,zero,33497
 320a3d0:	0320a474 	movhi	r12,33425
 320a3d4:	0320a474 	movhi	r12,33425
 320a3d8:	0320a474 	movhi	r12,33425
 320a3dc:	0320a474 	movhi	r12,33425
 320a3e0:	0320a474 	movhi	r12,33425
 320a3e4:	0320a474 	movhi	r12,33425
 320a3e8:	0320a474 	movhi	r12,33425
 320a3ec:	0320a474 	movhi	r12,33425
 320a3f0:	0320b4a0 	cmpeqi	r12,zero,-32046
 320a3f4:	0320a474 	movhi	r12,33425
 320a3f8:	0320a474 	movhi	r12,33425
 320a3fc:	0320b640 	call	320b64 <OSCtxSw_SWITCH_PC+0x320b24>
 320a400:	0320a474 	movhi	r12,33425
 320a404:	0320a474 	movhi	r12,33425
 320a408:	0320a474 	movhi	r12,33425
 320a40c:	0320a474 	movhi	r12,33425
 320a410:	0320a474 	movhi	r12,33425
 320a414:	0320a474 	movhi	r12,33425
 320a418:	0320a474 	movhi	r12,33425
 320a41c:	0320b634 	movhi	r12,33496
 320a420:	0320b618 	cmpnei	r12,zero,-32040
 320a424:	0320b60c 	andi	r12,zero,33496
 320a428:	0320b60c 	andi	r12,zero,33496
 320a42c:	0320b60c 	andi	r12,zero,33496
 320a430:	0320b604 	movi	r12,-32040
 320a434:	0320b6f8 	rdprs	r12,zero,-32037
 320a438:	0320a474 	movhi	r12,33425
 320a43c:	0320a474 	movhi	r12,33425
 320a440:	0320b6e4 	muli	r12,zero,-32037
 320a444:	0320a474 	movhi	r12,33425
 320a448:	0320b67c 	xorhi	r12,zero,33497
 320a44c:	0320b660 	cmpeqi	r12,zero,-32039
 320a450:	0320b6b4 	movhi	r12,33498
 320a454:	0320a474 	movhi	r12,33425
 320a458:	0320a474 	movhi	r12,33425
 320a45c:	0320b6ac 	andhi	r12,zero,33498
 320a460:	0320a474 	movhi	r12,33425
 320a464:	0320a9e4 	muli	r12,zero,-32089
 320a468:	0320a474 	movhi	r12,33425
 320a46c:	0320a474 	movhi	r12,33425
 320a470:	0320b4a0 	cmpeqi	r12,zero,-32046
 320a474:	2987883a 	add	r3,r5,r6
 320a478:	18800003 	ldbu	r2,0(r3)
 320a47c:	1080004c 	andi	r2,r2,1
 320a480:	1005003a 	cmpeq	r2,r2,zero
 320a484:	10002c26 	beq	r2,zero,320a538 <__svfscanf_r+0x450>
 320a488:	0100c874 	movhi	r4,801
 320a48c:	2100b804 	addi	r4,r4,736
 320a490:	00800284 	movi	r2,10
 320a494:	d900a015 	stw	r4,640(sp)
 320a498:	054000c4 	movi	r21,3
 320a49c:	d880a115 	stw	r2,644(sp)
 320a4a0:	80c00117 	ldw	r3,4(r16)
 320a4a4:	00c14a0e 	bge	zero,r3,320a9d0 <__svfscanf_r+0x8e8>
 320a4a8:	9880100c 	andi	r2,r19,64
 320a4ac:	10001326 	beq	r2,zero,320a4fc <__svfscanf_r+0x414>
 320a4b0:	00800104 	movi	r2,4
 320a4b4:	157f1f36 	bltu	r2,r21,320a134 <__svfscanf_r+0x4c>
 320a4b8:	ad45883a 	add	r2,r21,r21
 320a4bc:	1085883a 	add	r2,r2,r2
 320a4c0:	00c0c874 	movhi	r3,801
 320a4c4:	18e93504 	addi	r3,r3,-23340
 320a4c8:	10c5883a 	add	r2,r2,r3
 320a4cc:	11000017 	ldw	r4,0(r2)
 320a4d0:	2000683a 	jmp	r4
 320a4d4:	0320a540 	call	320a54 <OSCtxSw_SWITCH_PC+0x320a14>
 320a4d8:	0320a64c 	andi	r12,zero,33433
 320a4dc:	0320a6c0 	call	320a6c <OSCtxSw_SWITCH_PC+0x320a2c>
 320a4e0:	0320a9ac 	andhi	r12,zero,33446
 320a4e4:	0320a7f8 	rdprs	r12,zero,-32097
 320a4e8:	b009883a 	mov	r4,r22
 320a4ec:	800b883a 	mov	r5,r16
 320a4f0:	320740c0 	call	320740c <__srefill_r>
 320a4f4:	103f511e 	bne	r2,zero,320a23c <__svfscanf_r+0x154>
 320a4f8:	8c400044 	addi	r17,r17,1
 320a4fc:	81400017 	ldw	r5,0(r16)
 320a500:	90800017 	ldw	r2,0(r18)
 320a504:	28c00003 	ldbu	r3,0(r5)
 320a508:	1887883a 	add	r3,r3,r2
 320a50c:	19000003 	ldbu	r4,0(r3)
 320a510:	2100020c 	andi	r4,r4,8
 320a514:	203fe626 	beq	r4,zero,320a4b0 <__svfscanf_r+0x3c8>
 320a518:	80c00117 	ldw	r3,4(r16)
 320a51c:	18ffffc4 	addi	r3,r3,-1
 320a520:	80c00115 	stw	r3,4(r16)
 320a524:	00fff00e 	bge	zero,r3,320a4e8 <__svfscanf_r+0x400>
 320a528:	29800044 	addi	r6,r5,1
 320a52c:	8c400044 	addi	r17,r17,1
 320a530:	81800015 	stw	r6,0(r16)
 320a534:	003ff106 	br	320a4fc <__svfscanf_r+0x414>
 320a538:	9cc00054 	ori	r19,r19,1
 320a53c:	003fd206 	br	320a488 <__svfscanf_r+0x3a0>
 320a540:	d8c0a317 	ldw	r3,652(sp)
 320a544:	1800021e 	bne	r3,zero,320a550 <__svfscanf_r+0x468>
 320a548:	01000044 	movi	r4,1
 320a54c:	d900a315 	stw	r4,652(sp)
 320a550:	9880004c 	andi	r2,r19,1
 320a554:	1005003a 	cmpeq	r2,r2,zero
 320a558:	1003d91e 	bne	r2,zero,320b4c0 <__svfscanf_r+0x13d8>
 320a55c:	9d40040c 	andi	r21,r19,16
 320a560:	a839003a 	cmpeq	fp,r21,zero
 320a564:	e0042526 	beq	fp,zero,320b5fc <__svfscanf_r+0x1514>
 320a568:	d880a417 	ldw	r2,656(sp)
 320a56c:	14c00017 	ldw	r19,0(r2)
 320a570:	10800104 	addi	r2,r2,4
 320a574:	d880a415 	stw	r2,656(sp)
 320a578:	d8c0a317 	ldw	r3,652(sp)
 320a57c:	18041a26 	beq	r3,zero,320b5e8 <__svfscanf_r+0x1500>
 320a580:	0100c974 	movhi	r4,805
 320a584:	21097c04 	addi	r4,r4,9712
 320a588:	20800017 	ldw	r2,0(r4)
 320a58c:	103f2b26 	beq	r2,zero,320a23c <__svfscanf_r+0x154>
 320a590:	d8804404 	addi	r2,sp,272
 320a594:	0025883a 	mov	r18,zero
 320a598:	d880a615 	stw	r2,664(sp)
 320a59c:	05ffffc4 	movi	r23,-1
 320a5a0:	80800017 	ldw	r2,0(r16)
 320a5a4:	80c00117 	ldw	r3,4(r16)
 320a5a8:	d900a617 	ldw	r4,664(sp)
 320a5ac:	12000003 	ldbu	r8,0(r2)
 320a5b0:	18ffffc4 	addi	r3,r3,-1
 320a5b4:	11800044 	addi	r6,r2,1
 320a5b8:	248f883a 	add	r7,r4,r18
 320a5bc:	80c00115 	stw	r3,4(r16)
 320a5c0:	81800015 	stw	r6,0(r16)
 320a5c4:	3a000005 	stb	r8,0(r7)
 320a5c8:	d9000204 	addi	r4,sp,8
 320a5cc:	000b883a 	mov	r5,zero
 320a5d0:	01800204 	movi	r6,8
 320a5d4:	320694c0 	call	320694c <memset>
 320a5d8:	d980a617 	ldw	r6,664(sp)
 320a5dc:	94800044 	addi	r18,r18,1
 320a5e0:	d8800204 	addi	r2,sp,8
 320a5e4:	b009883a 	mov	r4,r22
 320a5e8:	980b883a 	mov	r5,r19
 320a5ec:	900f883a 	mov	r7,r18
 320a5f0:	d8800015 	stw	r2,0(sp)
 320a5f4:	320d9140 	call	320d914 <_mbrtowc_r>
 320a5f8:	1007883a 	mov	r3,r2
 320a5fc:	15ff0f26 	beq	r2,r23,320a23c <__svfscanf_r+0x154>
 320a600:	1003f11e 	bne	r2,zero,320b5c8 <__svfscanf_r+0x14e0>
 320a604:	a800011e 	bne	r21,zero,320a60c <__svfscanf_r+0x524>
 320a608:	98000015 	stw	zero,0(r19)
 320a60c:	d8c0a317 	ldw	r3,652(sp)
 320a610:	8ca3883a 	add	r17,r17,r18
 320a614:	18ffffc4 	addi	r3,r3,-1
 320a618:	d8c0a315 	stw	r3,652(sp)
 320a61c:	e0000126 	beq	fp,zero,320a624 <__svfscanf_r+0x53c>
 320a620:	9cc00104 	addi	r19,r19,4
 320a624:	0025883a 	mov	r18,zero
 320a628:	80c00117 	ldw	r3,4(r16)
 320a62c:	00c3e90e 	bge	zero,r3,320b5d4 <__svfscanf_r+0x14ec>
 320a630:	d900a317 	ldw	r4,652(sp)
 320a634:	2003ec26 	beq	r4,zero,320b5e8 <__svfscanf_r+0x1500>
 320a638:	00c0c974 	movhi	r3,805
 320a63c:	18c97c04 	addi	r3,r3,9712
 320a640:	18800017 	ldw	r2,0(r3)
 320a644:	90bfd61e 	bne	r18,r2,320a5a0 <__svfscanf_r+0x4b8>
 320a648:	003efc06 	br	320a23c <__svfscanf_r+0x154>
 320a64c:	d880a317 	ldw	r2,652(sp)
 320a650:	1000021e 	bne	r2,zero,320a65c <__svfscanf_r+0x574>
 320a654:	00ffffc4 	movi	r3,-1
 320a658:	d8c0a315 	stw	r3,652(sp)
 320a65c:	9880040c 	andi	r2,r19,16
 320a660:	10036526 	beq	r2,zero,320b3f8 <__svfscanf_r+0x1310>
 320a664:	0027883a 	mov	r19,zero
 320a668:	dd400404 	addi	r21,sp,16
 320a66c:	81000017 	ldw	r4,0(r16)
 320a670:	20800003 	ldbu	r2,0(r4)
 320a674:	a885883a 	add	r2,r21,r2
 320a678:	10c00007 	ldb	r3,0(r2)
 320a67c:	1803be26 	beq	r3,zero,320b578 <__svfscanf_r+0x1490>
 320a680:	80c00117 	ldw	r3,4(r16)
 320a684:	21800044 	addi	r6,r4,1
 320a688:	d900a317 	ldw	r4,652(sp)
 320a68c:	18ffffc4 	addi	r3,r3,-1
 320a690:	9cc00044 	addi	r19,r19,1
 320a694:	81800015 	stw	r6,0(r16)
 320a698:	80c00115 	stw	r3,4(r16)
 320a69c:	24c3b626 	beq	r4,r19,320b578 <__svfscanf_r+0x1490>
 320a6a0:	00fff216 	blt	zero,r3,320a66c <__svfscanf_r+0x584>
 320a6a4:	b009883a 	mov	r4,r22
 320a6a8:	800b883a 	mov	r5,r16
 320a6ac:	320740c0 	call	320740c <__srefill_r>
 320a6b0:	103fee26 	beq	r2,zero,320a66c <__svfscanf_r+0x584>
 320a6b4:	983ee126 	beq	r19,zero,320a23c <__svfscanf_r+0x154>
 320a6b8:	8ce3883a 	add	r17,r17,r19
 320a6bc:	003e9d06 	br	320a134 <__svfscanf_r+0x4c>
 320a6c0:	d900a317 	ldw	r4,652(sp)
 320a6c4:	2000021e 	bne	r4,zero,320a6d0 <__svfscanf_r+0x5e8>
 320a6c8:	00bfffc4 	movi	r2,-1
 320a6cc:	d880a315 	stw	r2,652(sp)
 320a6d0:	9880004c 	andi	r2,r19,1
 320a6d4:	1005003a 	cmpeq	r2,r2,zero
 320a6d8:	1001f41e 	bne	r2,zero,320aeac <__svfscanf_r+0xdc4>
 320a6dc:	9dc0040c 	andi	r23,r19,16
 320a6e0:	b807003a 	cmpeq	r3,r23,zero
 320a6e4:	d8c0a515 	stw	r3,660(sp)
 320a6e8:	1803b21e 	bne	r3,zero,320b5b4 <__svfscanf_r+0x14cc>
 320a6ec:	dd400104 	addi	r21,sp,4
 320a6f0:	0027883a 	mov	r19,zero
 320a6f4:	073fffc4 	movi	fp,-1
 320a6f8:	81400017 	ldw	r5,0(r16)
 320a6fc:	90800017 	ldw	r2,0(r18)
 320a700:	29c00003 	ldbu	r7,0(r5)
 320a704:	38c03fcc 	andi	r3,r7,255
 320a708:	1887883a 	add	r3,r3,r2
 320a70c:	19000003 	ldbu	r4,0(r3)
 320a710:	2100020c 	andi	r4,r4,8
 320a714:	2000321e 	bne	r4,zero,320a7e0 <__svfscanf_r+0x6f8>
 320a718:	d8c0a317 	ldw	r3,652(sp)
 320a71c:	18003026 	beq	r3,zero,320a7e0 <__svfscanf_r+0x6f8>
 320a720:	0080c974 	movhi	r2,805
 320a724:	10897c04 	addi	r2,r2,9712
 320a728:	10c00017 	ldw	r3,0(r2)
 320a72c:	98fec326 	beq	r19,r3,320a23c <__svfscanf_r+0x154>
 320a730:	d8c04404 	addi	r3,sp,272
 320a734:	80800117 	ldw	r2,4(r16)
 320a738:	d8c0a615 	stw	r3,664(sp)
 320a73c:	d900a617 	ldw	r4,664(sp)
 320a740:	10ffffc4 	addi	r3,r2,-1
 320a744:	29800044 	addi	r6,r5,1
 320a748:	80c00115 	stw	r3,4(r16)
 320a74c:	24c5883a 	add	r2,r4,r19
 320a750:	81800015 	stw	r6,0(r16)
 320a754:	d9000204 	addi	r4,sp,8
 320a758:	000b883a 	mov	r5,zero
 320a75c:	01800204 	movi	r6,8
 320a760:	11c00005 	stb	r7,0(r2)
 320a764:	320694c0 	call	320694c <memset>
 320a768:	d980a617 	ldw	r6,664(sp)
 320a76c:	9cc00044 	addi	r19,r19,1
 320a770:	d8800204 	addi	r2,sp,8
 320a774:	b009883a 	mov	r4,r22
 320a778:	a80b883a 	mov	r5,r21
 320a77c:	980f883a 	mov	r7,r19
 320a780:	d8800015 	stw	r2,0(sp)
 320a784:	320d9140 	call	320d914 <_mbrtowc_r>
 320a788:	1007883a 	mov	r3,r2
 320a78c:	173eab26 	beq	r2,fp,320a23c <__svfscanf_r+0x154>
 320a790:	1003851e 	bne	r2,zero,320b5a8 <__svfscanf_r+0x14c0>
 320a794:	a8000015 	stw	zero,0(r21)
 320a798:	a9000017 	ldw	r4,0(r21)
 320a79c:	320d7ac0 	call	320d7ac <iswspace>
 320a7a0:	1003781e 	bne	r2,zero,320b584 <__svfscanf_r+0x149c>
 320a7a4:	d900a317 	ldw	r4,652(sp)
 320a7a8:	d880a517 	ldw	r2,660(sp)
 320a7ac:	8ce3883a 	add	r17,r17,r19
 320a7b0:	213fffc4 	addi	r4,r4,-1
 320a7b4:	d900a315 	stw	r4,652(sp)
 320a7b8:	10000126 	beq	r2,zero,320a7c0 <__svfscanf_r+0x6d8>
 320a7bc:	ad400104 	addi	r21,r21,4
 320a7c0:	0027883a 	mov	r19,zero
 320a7c4:	80c00117 	ldw	r3,4(r16)
 320a7c8:	00ffcb16 	blt	zero,r3,320a6f8 <__svfscanf_r+0x610>
 320a7cc:	b009883a 	mov	r4,r22
 320a7d0:	800b883a 	mov	r5,r16
 320a7d4:	320740c0 	call	320740c <__srefill_r>
 320a7d8:	103fc726 	beq	r2,zero,320a6f8 <__svfscanf_r+0x610>
 320a7dc:	983e971e 	bne	r19,zero,320a23c <__svfscanf_r+0x154>
 320a7e0:	b83e541e 	bne	r23,zero,320a134 <__svfscanf_r+0x4c>
 320a7e4:	d900a217 	ldw	r4,648(sp)
 320a7e8:	a8000015 	stw	zero,0(r21)
 320a7ec:	21000044 	addi	r4,r4,1
 320a7f0:	d900a215 	stw	r4,648(sp)
 320a7f4:	003e4f06 	br	320a134 <__svfscanf_r+0x4c>
 320a7f8:	d900a317 	ldw	r4,652(sp)
 320a7fc:	00805704 	movi	r2,348
 320a800:	20ffffc4 	addi	r3,r4,-1
 320a804:	10c1ed2e 	bgeu	r2,r3,320afbc <__svfscanf_r+0xed4>
 320a808:	00805744 	movi	r2,349
 320a80c:	21bfa8c4 	addi	r6,r4,-349
 320a810:	9d41e014 	ori	r21,r19,1920
 320a814:	d880a315 	stw	r2,652(sp)
 320a818:	d8c04404 	addi	r3,sp,272
 320a81c:	d8c0a615 	stw	r3,664(sp)
 320a820:	182f883a 	mov	r23,r3
 320a824:	d8009f15 	stw	zero,636(sp)
 320a828:	d8009e15 	stw	zero,632(sp)
 320a82c:	d8009d15 	stw	zero,628(sp)
 320a830:	d8009c15 	stw	zero,624(sp)
 320a834:	0039883a 	mov	fp,zero
 320a838:	0025883a 	mov	r18,zero
 320a83c:	80800017 	ldw	r2,0(r16)
 320a840:	11400003 	ldbu	r5,0(r2)
 320a844:	00801384 	movi	r2,78
 320a848:	28fff544 	addi	r3,r5,-43
 320a84c:	18c03fcc 	andi	r3,r3,255
 320a850:	10c07d36 	bltu	r2,r3,320aa48 <__svfscanf_r+0x960>
 320a854:	18c5883a 	add	r2,r3,r3
 320a858:	1085883a 	add	r2,r2,r2
 320a85c:	00c0c874 	movhi	r3,801
 320a860:	18ea1c04 	addi	r3,r3,-22416
 320a864:	10c5883a 	add	r2,r2,r3
 320a868:	11000017 	ldw	r4,0(r2)
 320a86c:	2000683a 	jmp	r4
 320a870:	0320aa00 	call	320aa0 <OSCtxSw_SWITCH_PC+0x320a60>
 320a874:	0320aa48 	cmpgei	r12,zero,-32087
 320a878:	0320aa00 	call	320aa0 <OSCtxSw_SWITCH_PC+0x320a60>
 320a87c:	0320ab94 	movui	r12,33454
 320a880:	0320aa48 	cmpgei	r12,zero,-32087
 320a884:	0320abcc 	andi	r12,zero,33455
 320a888:	0320ac00 	call	320ac0 <OSCtxSw_SWITCH_PC+0x320a80>
 320a88c:	0320ac00 	call	320ac0 <OSCtxSw_SWITCH_PC+0x320a80>
 320a890:	0320ac00 	call	320ac0 <OSCtxSw_SWITCH_PC+0x320a80>
 320a894:	0320ac00 	call	320ac0 <OSCtxSw_SWITCH_PC+0x320a80>
 320a898:	0320ac00 	call	320ac0 <OSCtxSw_SWITCH_PC+0x320a80>
 320a89c:	0320ac00 	call	320ac0 <OSCtxSw_SWITCH_PC+0x320a80>
 320a8a0:	0320ac00 	call	320ac0 <OSCtxSw_SWITCH_PC+0x320a80>
 320a8a4:	0320ac00 	call	320ac0 <OSCtxSw_SWITCH_PC+0x320a80>
 320a8a8:	0320ac00 	call	320ac0 <OSCtxSw_SWITCH_PC+0x320a80>
 320a8ac:	0320aa48 	cmpgei	r12,zero,-32087
 320a8b0:	0320aa48 	cmpgei	r12,zero,-32087
 320a8b4:	0320aa48 	cmpgei	r12,zero,-32087
 320a8b8:	0320aa48 	cmpgei	r12,zero,-32087
 320a8bc:	0320aa48 	cmpgei	r12,zero,-32087
 320a8c0:	0320aa48 	cmpgei	r12,zero,-32087
 320a8c4:	0320aa48 	cmpgei	r12,zero,-32087
 320a8c8:	0320ac20 	cmpeqi	r12,zero,-32080
 320a8cc:	0320aa48 	cmpgei	r12,zero,-32087
 320a8d0:	0320aa48 	cmpgei	r12,zero,-32087
 320a8d4:	0320aa48 	cmpgei	r12,zero,-32087
 320a8d8:	0320ac30 	cmpltui	r12,zero,33456
 320a8dc:	0320accc 	andi	r12,zero,33459
 320a8e0:	0320aa48 	cmpgei	r12,zero,-32087
 320a8e4:	0320aa48 	cmpgei	r12,zero,-32087
 320a8e8:	0320ace8 	cmpgeui	r12,zero,33459
 320a8ec:	0320aa48 	cmpgei	r12,zero,-32087
 320a8f0:	0320aa48 	cmpgei	r12,zero,-32087
 320a8f4:	0320aa48 	cmpgei	r12,zero,-32087
 320a8f8:	0320aa48 	cmpgei	r12,zero,-32087
 320a8fc:	0320ad14 	movui	r12,33460
 320a900:	0320aa48 	cmpgei	r12,zero,-32087
 320a904:	0320aa48 	cmpgei	r12,zero,-32087
 320a908:	0320aa48 	cmpgei	r12,zero,-32087
 320a90c:	0320aa48 	cmpgei	r12,zero,-32087
 320a910:	0320aa48 	cmpgei	r12,zero,-32087
 320a914:	0320ad68 	cmpgeui	r12,zero,33461
 320a918:	0320aa48 	cmpgei	r12,zero,-32087
 320a91c:	0320aa48 	cmpgei	r12,zero,-32087
 320a920:	0320aa48 	cmpgei	r12,zero,-32087
 320a924:	0320aa48 	cmpgei	r12,zero,-32087
 320a928:	0320ae78 	rdprs	r12,zero,-32071
 320a92c:	0320aa48 	cmpgei	r12,zero,-32087
 320a930:	0320aa48 	cmpgei	r12,zero,-32087
 320a934:	0320aa48 	cmpgei	r12,zero,-32087
 320a938:	0320aa48 	cmpgei	r12,zero,-32087
 320a93c:	0320aa48 	cmpgei	r12,zero,-32087
 320a940:	0320aa48 	cmpgei	r12,zero,-32087
 320a944:	0320aa48 	cmpgei	r12,zero,-32087
 320a948:	0320ac20 	cmpeqi	r12,zero,-32080
 320a94c:	0320aa48 	cmpgei	r12,zero,-32087
 320a950:	0320aa48 	cmpgei	r12,zero,-32087
 320a954:	0320aa48 	cmpgei	r12,zero,-32087
 320a958:	0320ac30 	cmpltui	r12,zero,33456
 320a95c:	0320accc 	andi	r12,zero,33459
 320a960:	0320aa48 	cmpgei	r12,zero,-32087
 320a964:	0320aa48 	cmpgei	r12,zero,-32087
 320a968:	0320ace8 	cmpgeui	r12,zero,33459
 320a96c:	0320aa48 	cmpgei	r12,zero,-32087
 320a970:	0320aa48 	cmpgei	r12,zero,-32087
 320a974:	0320aa48 	cmpgei	r12,zero,-32087
 320a978:	0320aa48 	cmpgei	r12,zero,-32087
 320a97c:	0320ad14 	movui	r12,33460
 320a980:	0320aa48 	cmpgei	r12,zero,-32087
 320a984:	0320aa48 	cmpgei	r12,zero,-32087
 320a988:	0320aa48 	cmpgei	r12,zero,-32087
 320a98c:	0320aa48 	cmpgei	r12,zero,-32087
 320a990:	0320aa48 	cmpgei	r12,zero,-32087
 320a994:	0320ad68 	cmpgeui	r12,zero,33461
 320a998:	0320aa48 	cmpgei	r12,zero,-32087
 320a99c:	0320aa48 	cmpgei	r12,zero,-32087
 320a9a0:	0320aa48 	cmpgei	r12,zero,-32087
 320a9a4:	0320aa48 	cmpgei	r12,zero,-32087
 320a9a8:	0320ae78 	rdprs	r12,zero,-32071
 320a9ac:	d900a317 	ldw	r4,652(sp)
 320a9b0:	00805704 	movi	r2,348
 320a9b4:	20ffffc4 	addi	r3,r4,-1
 320a9b8:	10c18c2e 	bgeu	r2,r3,320afec <__svfscanf_r+0xf04>
 320a9bc:	00805744 	movi	r2,349
 320a9c0:	257fa8c4 	addi	r21,r4,-349
 320a9c4:	9c836014 	ori	r18,r19,3456
 320a9c8:	d880a315 	stw	r2,652(sp)
 320a9cc:	0001a106 	br	320b054 <__svfscanf_r+0xf6c>
 320a9d0:	b009883a 	mov	r4,r22
 320a9d4:	800b883a 	mov	r5,r16
 320a9d8:	320740c0 	call	320740c <__srefill_r>
 320a9dc:	103eb226 	beq	r2,zero,320a4a8 <__svfscanf_r+0x3c0>
 320a9e0:	003e1606 	br	320a23c <__svfscanf_r+0x154>
 320a9e4:	01000284 	movi	r4,10
 320a9e8:	0080c874 	movhi	r2,801
 320a9ec:	10821804 	addi	r2,r2,2144
 320a9f0:	054000c4 	movi	r21,3
 320a9f4:	d900a115 	stw	r4,644(sp)
 320a9f8:	d880a015 	stw	r2,640(sp)
 320a9fc:	003ea806 	br	320a4a0 <__svfscanf_r+0x3b8>
 320aa00:	a880200c 	andi	r2,r21,128
 320aa04:	10001026 	beq	r2,zero,320aa48 <__svfscanf_r+0x960>
 320aa08:	00bfdfc4 	movi	r2,-129
 320aa0c:	a8aa703a 	and	r21,r21,r2
 320aa10:	b9400005 	stb	r5,0(r23)
 320aa14:	bdc00044 	addi	r23,r23,1
 320aa18:	80c00117 	ldw	r3,4(r16)
 320aa1c:	8c400044 	addi	r17,r17,1
 320aa20:	18bfffc4 	addi	r2,r3,-1
 320aa24:	80800115 	stw	r2,4(r16)
 320aa28:	0080610e 	bge	zero,r2,320abb0 <__svfscanf_r+0xac8>
 320aa2c:	80800017 	ldw	r2,0(r16)
 320aa30:	10800044 	addi	r2,r2,1
 320aa34:	80800015 	stw	r2,0(r16)
 320aa38:	d880a317 	ldw	r2,652(sp)
 320aa3c:	10bfffc4 	addi	r2,r2,-1
 320aa40:	d880a315 	stw	r2,652(sp)
 320aa44:	103f7d1e 	bne	r2,zero,320a83c <__svfscanf_r+0x754>
 320aa48:	d8c09e17 	ldw	r3,632(sp)
 320aa4c:	18000226 	beq	r3,zero,320aa58 <__svfscanf_r+0x970>
 320aa50:	00bfbfc4 	movi	r2,-257
 320aa54:	a8aa703a 	and	r21,r21,r2
 320aa58:	90ffffc4 	addi	r3,r18,-1
 320aa5c:	00800044 	movi	r2,1
 320aa60:	10c0cd2e 	bgeu	r2,r3,320ad98 <__svfscanf_r+0xcb0>
 320aa64:	e1003fcc 	andi	r4,fp,255
 320aa68:	2100201c 	xori	r4,r4,128
 320aa6c:	213fe004 	addi	r4,r4,-128
 320aa70:	20ffffc4 	addi	r3,r4,-1
 320aa74:	00800184 	movi	r2,6
 320aa78:	10c01736 	bltu	r2,r3,320aad8 <__svfscanf_r+0x9f0>
 320aa7c:	00c00084 	movi	r3,2
 320aa80:	1900880e 	bge	r3,r4,320aca4 <__svfscanf_r+0xbbc>
 320aa84:	008000c4 	movi	r2,3
 320aa88:	1100130e 	bge	r2,r4,320aad8 <__svfscanf_r+0x9f0>
 320aa8c:	e4ffffc4 	addi	r19,fp,-1
 320aa90:	b825883a 	mov	r18,r23
 320aa94:	94bfffc4 	addi	r18,r18,-1
 320aa98:	91400007 	ldb	r5,0(r18)
 320aa9c:	b009883a 	mov	r4,r22
 320aaa0:	800d883a 	mov	r6,r16
 320aaa4:	3210e800 	call	3210e80 <_ungetc_r>
 320aaa8:	9cffffc4 	addi	r19,r19,-1
 320aaac:	98c03fcc 	andi	r3,r19,255
 320aab0:	18c0201c 	xori	r3,r3,128
 320aab4:	18ffe004 	addi	r3,r3,-128
 320aab8:	00800084 	movi	r2,2
 320aabc:	18bff51e 	bne	r3,r2,320aa94 <__svfscanf_r+0x9ac>
 320aac0:	e0bfff04 	addi	r2,fp,-4
 320aac4:	10803fcc 	andi	r2,r2,255
 320aac8:	b887c83a 	sub	r3,r23,r2
 320aacc:	8885c83a 	sub	r2,r17,r2
 320aad0:	147fffc4 	addi	r17,r2,-1
 320aad4:	1dffffc4 	addi	r23,r3,-1
 320aad8:	a880400c 	andi	r2,r21,256
 320aadc:	10001226 	beq	r2,zero,320ab28 <__svfscanf_r+0xa40>
 320aae0:	a881000c 	andi	r2,r21,1024
 320aae4:	1000651e 	bne	r2,zero,320ac7c <__svfscanf_r+0xb94>
 320aae8:	bdffffc4 	addi	r23,r23,-1
 320aaec:	b9400007 	ldb	r5,0(r23)
 320aaf0:	00801944 	movi	r2,101
 320aaf4:	8c7fffc4 	addi	r17,r17,-1
 320aaf8:	28800826 	beq	r5,r2,320ab1c <__svfscanf_r+0xa34>
 320aafc:	00801144 	movi	r2,69
 320ab00:	28800626 	beq	r5,r2,320ab1c <__svfscanf_r+0xa34>
 320ab04:	bdffffc4 	addi	r23,r23,-1
 320ab08:	b009883a 	mov	r4,r22
 320ab0c:	800d883a 	mov	r6,r16
 320ab10:	3210e800 	call	3210e80 <_ungetc_r>
 320ab14:	b9400007 	ldb	r5,0(r23)
 320ab18:	8c7fffc4 	addi	r17,r17,-1
 320ab1c:	b009883a 	mov	r4,r22
 320ab20:	800d883a 	mov	r6,r16
 320ab24:	3210e800 	call	3210e80 <_ungetc_r>
 320ab28:	a880040c 	andi	r2,r21,16
 320ab2c:	103d811e 	bne	r2,zero,320a134 <__svfscanf_r+0x4c>
 320ab30:	a8c1800c 	andi	r3,r21,1536
 320ab34:	00810004 	movi	r2,1024
 320ab38:	b8000005 	stb	zero,0(r23)
 320ab3c:	1880bb26 	beq	r3,r2,320ae2c <__svfscanf_r+0xd44>
 320ab40:	d8809d17 	ldw	r2,628(sp)
 320ab44:	1000a61e 	bne	r2,zero,320ade0 <__svfscanf_r+0xcf8>
 320ab48:	d940a617 	ldw	r5,664(sp)
 320ab4c:	b009883a 	mov	r4,r22
 320ab50:	000d883a 	mov	r6,zero
 320ab54:	320ecbc0 	call	320ecbc <_strtod_r>
 320ab58:	a900004c 	andi	r4,r21,1
 320ab5c:	2009003a 	cmpeq	r4,r4,zero
 320ab60:	1025883a 	mov	r18,r2
 320ab64:	1827883a 	mov	r19,r3
 320ab68:	2000951e 	bne	r4,zero,320adc0 <__svfscanf_r+0xcd8>
 320ab6c:	d8c0a417 	ldw	r3,656(sp)
 320ab70:	18800017 	ldw	r2,0(r3)
 320ab74:	1d400104 	addi	r21,r3,4
 320ab78:	14c00115 	stw	r19,4(r2)
 320ab7c:	14800015 	stw	r18,0(r2)
 320ab80:	d8c0a217 	ldw	r3,648(sp)
 320ab84:	dd40a415 	stw	r21,656(sp)
 320ab88:	18c00044 	addi	r3,r3,1
 320ab8c:	d8c0a215 	stw	r3,648(sp)
 320ab90:	003d6806 	br	320a134 <__svfscanf_r+0x4c>
 320ab94:	a880800c 	andi	r2,r21,512
 320ab98:	103fab26 	beq	r2,zero,320aa48 <__svfscanf_r+0x960>
 320ab9c:	d9009e17 	ldw	r4,632(sp)
 320aba0:	00bf5fc4 	movi	r2,-641
 320aba4:	a8aa703a 	and	r21,r21,r2
 320aba8:	d9009f15 	stw	r4,636(sp)
 320abac:	003f9806 	br	320aa10 <__svfscanf_r+0x928>
 320abb0:	b009883a 	mov	r4,r22
 320abb4:	800b883a 	mov	r5,r16
 320abb8:	d980a715 	stw	r6,668(sp)
 320abbc:	320740c0 	call	320740c <__srefill_r>
 320abc0:	d980a717 	ldw	r6,668(sp)
 320abc4:	103f9c26 	beq	r2,zero,320aa38 <__svfscanf_r+0x950>
 320abc8:	003f9f06 	br	320aa48 <__svfscanf_r+0x960>
 320abcc:	a880400c 	andi	r2,r21,256
 320abd0:	10000b26 	beq	r2,zero,320ac00 <__svfscanf_r+0xb18>
 320abd4:	00bfdfc4 	movi	r2,-129
 320abd8:	a8aa703a 	and	r21,r21,r2
 320abdc:	d8809e17 	ldw	r2,632(sp)
 320abe0:	10800044 	addi	r2,r2,1
 320abe4:	d8809e15 	stw	r2,632(sp)
 320abe8:	303f8b26 	beq	r6,zero,320aa18 <__svfscanf_r+0x930>
 320abec:	d8c0a317 	ldw	r3,652(sp)
 320abf0:	31bfffc4 	addi	r6,r6,-1
 320abf4:	18c00044 	addi	r3,r3,1
 320abf8:	d8c0a315 	stw	r3,652(sp)
 320abfc:	003f8606 	br	320aa18 <__svfscanf_r+0x930>
 320ac00:	e0803fcc 	andi	r2,fp,255
 320ac04:	1080201c 	xori	r2,r2,128
 320ac08:	10bfe004 	addi	r2,r2,-128
 320ac0c:	9085883a 	add	r2,r18,r2
 320ac10:	103f8d1e 	bne	r2,zero,320aa48 <__svfscanf_r+0x960>
 320ac14:	00bf9fc4 	movi	r2,-385
 320ac18:	a8aa703a 	and	r21,r21,r2
 320ac1c:	003f7c06 	br	320aa10 <__svfscanf_r+0x928>
 320ac20:	00800044 	movi	r2,1
 320ac24:	90bf881e 	bne	r18,r2,320aa48 <__svfscanf_r+0x960>
 320ac28:	04800084 	movi	r18,2
 320ac2c:	003f7806 	br	320aa10 <__svfscanf_r+0x928>
 320ac30:	a8c1400c 	andi	r3,r21,1280
 320ac34:	00810004 	movi	r2,1024
 320ac38:	18800426 	beq	r3,r2,320ac4c <__svfscanf_r+0xb64>
 320ac3c:	a884703a 	and	r2,r21,r2
 320ac40:	103f8126 	beq	r2,zero,320aa48 <__svfscanf_r+0x960>
 320ac44:	d8809e17 	ldw	r2,632(sp)
 320ac48:	103f8326 	beq	r2,zero,320aa58 <__svfscanf_r+0x970>
 320ac4c:	a880800c 	andi	r2,r21,512
 320ac50:	1000051e 	bne	r2,zero,320ac68 <__svfscanf_r+0xb80>
 320ac54:	d8c09e17 	ldw	r3,632(sp)
 320ac58:	d9009f17 	ldw	r4,636(sp)
 320ac5c:	ddc09c15 	stw	r23,624(sp)
 320ac60:	1907c83a 	sub	r3,r3,r4
 320ac64:	d8c09d15 	stw	r3,628(sp)
 320ac68:	00be7fc4 	movi	r2,-1537
 320ac6c:	a884703a 	and	r2,r21,r2
 320ac70:	15406014 	ori	r21,r2,384
 320ac74:	d8009e15 	stw	zero,632(sp)
 320ac78:	003f6506 	br	320aa10 <__svfscanf_r+0x928>
 320ac7c:	d900a617 	ldw	r4,664(sp)
 320ac80:	25fd4e2e 	bgeu	r4,r23,320a1bc <__svfscanf_r+0xd4>
 320ac84:	bdffffc4 	addi	r23,r23,-1
 320ac88:	b9400007 	ldb	r5,0(r23)
 320ac8c:	b009883a 	mov	r4,r22
 320ac90:	800d883a 	mov	r6,r16
 320ac94:	3210e800 	call	3210e80 <_ungetc_r>
 320ac98:	d880a617 	ldw	r2,664(sp)
 320ac9c:	15fff936 	bltu	r2,r23,320ac84 <__svfscanf_r+0xb9c>
 320aca0:	003d4606 	br	320a1bc <__svfscanf_r+0xd4>
 320aca4:	d900a617 	ldw	r4,664(sp)
 320aca8:	25fd442e 	bgeu	r4,r23,320a1bc <__svfscanf_r+0xd4>
 320acac:	bdffffc4 	addi	r23,r23,-1
 320acb0:	b9400007 	ldb	r5,0(r23)
 320acb4:	b009883a 	mov	r4,r22
 320acb8:	800d883a 	mov	r6,r16
 320acbc:	3210e800 	call	3210e80 <_ungetc_r>
 320acc0:	d8c0a617 	ldw	r3,664(sp)
 320acc4:	1dfff936 	bltu	r3,r23,320acac <__svfscanf_r+0xbc4>
 320acc8:	003d3c06 	br	320a1bc <__svfscanf_r+0xd4>
 320accc:	e0c03fcc 	andi	r3,fp,255
 320acd0:	18c0201c 	xori	r3,r3,128
 320acd4:	18ffe004 	addi	r3,r3,-128
 320acd8:	00800084 	movi	r2,2
 320acdc:	18bf5a1e 	bne	r3,r2,320aa48 <__svfscanf_r+0x960>
 320ace0:	070000c4 	movi	fp,3
 320ace4:	003f4a06 	br	320aa10 <__svfscanf_r+0x928>
 320ace8:	e0c03fcc 	andi	r3,fp,255
 320acec:	18c0201c 	xori	r3,r3,128
 320acf0:	18ffe004 	addi	r3,r3,-128
 320acf4:	1800231e 	bne	r3,zero,320ad84 <__svfscanf_r+0xc9c>
 320acf8:	a8c1c00c 	andi	r3,r21,1792
 320acfc:	0081c004 	movi	r2,1792
 320ad00:	18bf511e 	bne	r3,r2,320aa48 <__svfscanf_r+0x960>
 320ad04:	00be1fc4 	movi	r2,-1921
 320ad08:	a8aa703a 	and	r21,r21,r2
 320ad0c:	07000044 	movi	fp,1
 320ad10:	003f3f06 	br	320aa10 <__svfscanf_r+0x928>
 320ad14:	9000101e 	bne	r18,zero,320ad58 <__svfscanf_r+0xc70>
 320ad18:	a8c1c00c 	andi	r3,r21,1792
 320ad1c:	0081c004 	movi	r2,1792
 320ad20:	18800926 	beq	r3,r2,320ad48 <__svfscanf_r+0xc60>
 320ad24:	e0c03fcc 	andi	r3,fp,255
 320ad28:	18c0201c 	xori	r3,r3,128
 320ad2c:	18ffe004 	addi	r3,r3,-128
 320ad30:	00800044 	movi	r2,1
 320ad34:	18800226 	beq	r3,r2,320ad40 <__svfscanf_r+0xc58>
 320ad38:	00800104 	movi	r2,4
 320ad3c:	18bf421e 	bne	r3,r2,320aa48 <__svfscanf_r+0x960>
 320ad40:	e7000044 	addi	fp,fp,1
 320ad44:	003f3206 	br	320aa10 <__svfscanf_r+0x928>
 320ad48:	00be1fc4 	movi	r2,-1921
 320ad4c:	a8aa703a 	and	r21,r21,r2
 320ad50:	04800044 	movi	r18,1
 320ad54:	003f2e06 	br	320aa10 <__svfscanf_r+0x928>
 320ad58:	00800084 	movi	r2,2
 320ad5c:	90bff11e 	bne	r18,r2,320ad24 <__svfscanf_r+0xc3c>
 320ad60:	048000c4 	movi	r18,3
 320ad64:	003f2a06 	br	320aa10 <__svfscanf_r+0x928>
 320ad68:	e0c03fcc 	andi	r3,fp,255
 320ad6c:	18c0201c 	xori	r3,r3,128
 320ad70:	18ffe004 	addi	r3,r3,-128
 320ad74:	00800184 	movi	r2,6
 320ad78:	18bf331e 	bne	r3,r2,320aa48 <__svfscanf_r+0x960>
 320ad7c:	070001c4 	movi	fp,7
 320ad80:	003f2306 	br	320aa10 <__svfscanf_r+0x928>
 320ad84:	008000c4 	movi	r2,3
 320ad88:	18bfed26 	beq	r3,r2,320ad40 <__svfscanf_r+0xc58>
 320ad8c:	00800144 	movi	r2,5
 320ad90:	18bfeb26 	beq	r3,r2,320ad40 <__svfscanf_r+0xc58>
 320ad94:	003f2c06 	br	320aa48 <__svfscanf_r+0x960>
 320ad98:	d900a617 	ldw	r4,664(sp)
 320ad9c:	25fd072e 	bgeu	r4,r23,320a1bc <__svfscanf_r+0xd4>
 320ada0:	bdffffc4 	addi	r23,r23,-1
 320ada4:	b9400007 	ldb	r5,0(r23)
 320ada8:	b009883a 	mov	r4,r22
 320adac:	800d883a 	mov	r6,r16
 320adb0:	3210e800 	call	3210e80 <_ungetc_r>
 320adb4:	d880a617 	ldw	r2,664(sp)
 320adb8:	15fff936 	bltu	r2,r23,320ada0 <__svfscanf_r+0xcb8>
 320adbc:	003cff06 	br	320a1bc <__svfscanf_r+0xd4>
 320adc0:	a880008c 	andi	r2,r21,2
 320adc4:	10002026 	beq	r2,zero,320ae48 <__svfscanf_r+0xd60>
 320adc8:	d900a417 	ldw	r4,656(sp)
 320adcc:	20800017 	ldw	r2,0(r4)
 320add0:	25400104 	addi	r21,r4,4
 320add4:	10c00115 	stw	r3,4(r2)
 320add8:	14800015 	stw	r18,0(r2)
 320addc:	003f6806 	br	320ab80 <__svfscanf_r+0xa98>
 320ade0:	d8c09c17 	ldw	r3,624(sp)
 320ade4:	b009883a 	mov	r4,r22
 320ade8:	000d883a 	mov	r6,zero
 320adec:	19400044 	addi	r5,r3,1
 320adf0:	01c00284 	movi	r7,10
 320adf4:	32102e00 	call	32102e0 <_strtol_r>
 320adf8:	d9009d17 	ldw	r4,628(sp)
 320adfc:	110dc83a 	sub	r6,r2,r4
 320ae00:	d8c0a617 	ldw	r3,664(sp)
 320ae04:	d9009c17 	ldw	r4,624(sp)
 320ae08:	188054c4 	addi	r2,r3,339
 320ae0c:	20800236 	bltu	r4,r2,320ae18 <__svfscanf_r+0xd30>
 320ae10:	18805484 	addi	r2,r3,338
 320ae14:	d8809c15 	stw	r2,624(sp)
 320ae18:	d9009c17 	ldw	r4,624(sp)
 320ae1c:	0140c974 	movhi	r5,805
 320ae20:	2977ca04 	addi	r5,r5,-8408
 320ae24:	32076bc0 	call	32076bc <sprintf>
 320ae28:	003f4706 	br	320ab48 <__svfscanf_r+0xa60>
 320ae2c:	d8c09e17 	ldw	r3,632(sp)
 320ae30:	d9009f17 	ldw	r4,636(sp)
 320ae34:	1905c83a 	sub	r2,r3,r4
 320ae38:	103f4326 	beq	r2,zero,320ab48 <__svfscanf_r+0xa60>
 320ae3c:	008dc83a 	sub	r6,zero,r2
 320ae40:	ddc09c15 	stw	r23,624(sp)
 320ae44:	003fee06 	br	320ae00 <__svfscanf_r+0xd18>
 320ae48:	d880a417 	ldw	r2,656(sp)
 320ae4c:	9009883a 	mov	r4,r18
 320ae50:	180b883a 	mov	r5,r3
 320ae54:	15c00017 	ldw	r23,0(r2)
 320ae58:	15400104 	addi	r21,r2,4
 320ae5c:	320eac00 	call	320eac0 <__isnand>
 320ae60:	10021c1e 	bne	r2,zero,320b6d4 <__svfscanf_r+0x15ec>
 320ae64:	980b883a 	mov	r5,r19
 320ae68:	9009883a 	mov	r4,r18
 320ae6c:	3213ac40 	call	3213ac4 <__truncdfsf2>
 320ae70:	b8800015 	stw	r2,0(r23)
 320ae74:	003f4206 	br	320ab80 <__svfscanf_r+0xa98>
 320ae78:	e0c03fcc 	andi	r3,fp,255
 320ae7c:	18c0201c 	xori	r3,r3,128
 320ae80:	18ffe004 	addi	r3,r3,-128
 320ae84:	008001c4 	movi	r2,7
 320ae88:	18beef1e 	bne	r3,r2,320aa48 <__svfscanf_r+0x960>
 320ae8c:	07000204 	movi	fp,8
 320ae90:	003edf06 	br	320aa10 <__svfscanf_r+0x928>
 320ae94:	d900a317 	ldw	r4,652(sp)
 320ae98:	208002a4 	muli	r2,r4,10
 320ae9c:	1145883a 	add	r2,r2,r5
 320aea0:	10bff404 	addi	r2,r2,-48
 320aea4:	d880a315 	stw	r2,652(sp)
 320aea8:	003ceb06 	br	320a258 <__svfscanf_r+0x170>
 320aeac:	9880040c 	andi	r2,r19,16
 320aeb0:	10001426 	beq	r2,zero,320af04 <__svfscanf_r+0xe1c>
 320aeb4:	0027883a 	mov	r19,zero
 320aeb8:	00000906 	br	320aee0 <__svfscanf_r+0xdf8>
 320aebc:	80c00117 	ldw	r3,4(r16)
 320aec0:	d880a317 	ldw	r2,652(sp)
 320aec4:	29800044 	addi	r6,r5,1
 320aec8:	18ffffc4 	addi	r3,r3,-1
 320aecc:	9cc00044 	addi	r19,r19,1
 320aed0:	81800015 	stw	r6,0(r16)
 320aed4:	80c00115 	stw	r3,4(r16)
 320aed8:	14fdf726 	beq	r2,r19,320a6b8 <__svfscanf_r+0x5d0>
 320aedc:	00c02c0e 	bge	zero,r3,320af90 <__svfscanf_r+0xea8>
 320aee0:	81400017 	ldw	r5,0(r16)
 320aee4:	90800017 	ldw	r2,0(r18)
 320aee8:	28c00003 	ldbu	r3,0(r5)
 320aeec:	1887883a 	add	r3,r3,r2
 320aef0:	19000003 	ldbu	r4,0(r3)
 320aef4:	2100020c 	andi	r4,r4,8
 320aef8:	203ff026 	beq	r4,zero,320aebc <__svfscanf_r+0xdd4>
 320aefc:	8ce3883a 	add	r17,r17,r19
 320af00:	003c8c06 	br	320a134 <__svfscanf_r+0x4c>
 320af04:	d8c0a417 	ldw	r3,656(sp)
 320af08:	1d400017 	ldw	r21,0(r3)
 320af0c:	a827883a 	mov	r19,r21
 320af10:	00000e06 	br	320af4c <__svfscanf_r+0xe64>
 320af14:	80800117 	ldw	r2,4(r16)
 320af18:	d900a317 	ldw	r4,652(sp)
 320af1c:	29800044 	addi	r6,r5,1
 320af20:	10ffffc4 	addi	r3,r2,-1
 320af24:	213fffc4 	addi	r4,r4,-1
 320af28:	d900a315 	stw	r4,652(sp)
 320af2c:	80c00115 	stw	r3,4(r16)
 320af30:	28800003 	ldbu	r2,0(r5)
 320af34:	98800005 	stb	r2,0(r19)
 320af38:	81800015 	stw	r6,0(r16)
 320af3c:	9cc00044 	addi	r19,r19,1
 320af40:	20000926 	beq	r4,zero,320af68 <__svfscanf_r+0xe80>
 320af44:	80800117 	ldw	r2,4(r16)
 320af48:	0080170e 	bge	zero,r2,320afa8 <__svfscanf_r+0xec0>
 320af4c:	81400017 	ldw	r5,0(r16)
 320af50:	90800017 	ldw	r2,0(r18)
 320af54:	28c00003 	ldbu	r3,0(r5)
 320af58:	1887883a 	add	r3,r3,r2
 320af5c:	19000003 	ldbu	r4,0(r3)
 320af60:	2100020c 	andi	r4,r4,8
 320af64:	203feb26 	beq	r4,zero,320af14 <__svfscanf_r+0xe2c>
 320af68:	9d45c83a 	sub	r2,r19,r21
 320af6c:	d8c0a217 	ldw	r3,648(sp)
 320af70:	88a3883a 	add	r17,r17,r2
 320af74:	d880a417 	ldw	r2,656(sp)
 320af78:	18c00044 	addi	r3,r3,1
 320af7c:	d8c0a215 	stw	r3,648(sp)
 320af80:	10800104 	addi	r2,r2,4
 320af84:	d880a415 	stw	r2,656(sp)
 320af88:	98000005 	stb	zero,0(r19)
 320af8c:	003c6906 	br	320a134 <__svfscanf_r+0x4c>
 320af90:	b009883a 	mov	r4,r22
 320af94:	800b883a 	mov	r5,r16
 320af98:	320740c0 	call	320740c <__srefill_r>
 320af9c:	103fd026 	beq	r2,zero,320aee0 <__svfscanf_r+0xdf8>
 320afa0:	8ce3883a 	add	r17,r17,r19
 320afa4:	003c6306 	br	320a134 <__svfscanf_r+0x4c>
 320afa8:	b009883a 	mov	r4,r22
 320afac:	800b883a 	mov	r5,r16
 320afb0:	320740c0 	call	320740c <__srefill_r>
 320afb4:	103fe526 	beq	r2,zero,320af4c <__svfscanf_r+0xe64>
 320afb8:	003feb06 	br	320af68 <__svfscanf_r+0xe80>
 320afbc:	d900a317 	ldw	r4,652(sp)
 320afc0:	9d41e014 	ori	r21,r19,1920
 320afc4:	2000821e 	bne	r4,zero,320b1d0 <__svfscanf_r+0x10e8>
 320afc8:	d8c04404 	addi	r3,sp,272
 320afcc:	182f883a 	mov	r23,r3
 320afd0:	0039883a 	mov	fp,zero
 320afd4:	d8c0a615 	stw	r3,664(sp)
 320afd8:	d8009c15 	stw	zero,624(sp)
 320afdc:	d8009d15 	stw	zero,628(sp)
 320afe0:	d8009f15 	stw	zero,636(sp)
 320afe4:	d8009e15 	stw	zero,632(sp)
 320afe8:	003e9e06 	br	320aa64 <__svfscanf_r+0x97c>
 320afec:	d900a317 	ldw	r4,652(sp)
 320aff0:	9c836014 	ori	r18,r19,3456
 320aff4:	2000161e 	bne	r4,zero,320b050 <__svfscanf_r+0xf68>
 320aff8:	d8804404 	addi	r2,sp,272
 320affc:	d880a615 	stw	r2,664(sp)
 320b000:	002f883a 	mov	r23,zero
 320b004:	1027883a 	mov	r19,r2
 320b008:	9080400c 	andi	r2,r18,256
 320b00c:	10000926 	beq	r2,zero,320b034 <__svfscanf_r+0xf4c>
 320b010:	d8c0a617 	ldw	r3,664(sp)
 320b014:	1cc0052e 	bgeu	r3,r19,320b02c <__svfscanf_r+0xf44>
 320b018:	9cffffc4 	addi	r19,r19,-1
 320b01c:	99400007 	ldb	r5,0(r19)
 320b020:	b009883a 	mov	r4,r22
 320b024:	800d883a 	mov	r6,r16
 320b028:	3210e800 	call	3210e80 <_ungetc_r>
 320b02c:	d900a617 	ldw	r4,664(sp)
 320b030:	24fc6226 	beq	r4,r19,320a1bc <__svfscanf_r+0xd4>
 320b034:	9080040c 	andi	r2,r18,16
 320b038:	10006726 	beq	r2,zero,320b1d8 <__svfscanf_r+0x10f0>
 320b03c:	d8c0a617 	ldw	r3,664(sp)
 320b040:	98c5c83a 	sub	r2,r19,r3
 320b044:	b885883a 	add	r2,r23,r2
 320b048:	88a3883a 	add	r17,r17,r2
 320b04c:	003c3906 	br	320a134 <__svfscanf_r+0x4c>
 320b050:	002b883a 	mov	r21,zero
 320b054:	d8c04404 	addi	r3,sp,272
 320b058:	d8c0a615 	stw	r3,664(sp)
 320b05c:	002f883a 	mov	r23,zero
 320b060:	1827883a 	mov	r19,r3
 320b064:	81800017 	ldw	r6,0(r16)
 320b068:	00c01344 	movi	r3,77
 320b06c:	31400003 	ldbu	r5,0(r6)
 320b070:	28bff544 	addi	r2,r5,-43
 320b074:	10803fcc 	andi	r2,r2,255
 320b078:	18bfe336 	bltu	r3,r2,320b008 <__svfscanf_r+0xf20>
 320b07c:	1085883a 	add	r2,r2,r2
 320b080:	1085883a 	add	r2,r2,r2
 320b084:	00c0c874 	movhi	r3,801
 320b088:	18ec2604 	addi	r3,r3,-20328
 320b08c:	10c5883a 	add	r2,r2,r3
 320b090:	11000017 	ldw	r4,0(r2)
 320b094:	2000683a 	jmp	r4
 320b098:	0320b22c 	andhi	r12,zero,33480
 320b09c:	0320b008 	cmpgei	r12,zero,-32064
 320b0a0:	0320b22c 	andhi	r12,zero,33480
 320b0a4:	0320b008 	cmpgei	r12,zero,-32064
 320b0a8:	0320b008 	cmpgei	r12,zero,-32064
 320b0ac:	0320b270 	cmpltui	r12,zero,33481
 320b0b0:	0320b36c 	andhi	r12,zero,33485
 320b0b4:	0320b36c 	andhi	r12,zero,33485
 320b0b8:	0320b36c 	andhi	r12,zero,33485
 320b0bc:	0320b36c 	andhi	r12,zero,33485
 320b0c0:	0320b36c 	andhi	r12,zero,33485
 320b0c4:	0320b36c 	andhi	r12,zero,33485
 320b0c8:	0320b36c 	andhi	r12,zero,33485
 320b0cc:	0320b394 	movui	r12,33486
 320b0d0:	0320b394 	movui	r12,33486
 320b0d4:	0320b008 	cmpgei	r12,zero,-32064
 320b0d8:	0320b008 	cmpgei	r12,zero,-32064
 320b0dc:	0320b008 	cmpgei	r12,zero,-32064
 320b0e0:	0320b008 	cmpgei	r12,zero,-32064
 320b0e4:	0320b008 	cmpgei	r12,zero,-32064
 320b0e8:	0320b008 	cmpgei	r12,zero,-32064
 320b0ec:	0320b008 	cmpgei	r12,zero,-32064
 320b0f0:	0320b3c4 	movi	r12,-32049
 320b0f4:	0320b3c4 	movi	r12,-32049
 320b0f8:	0320b3c4 	movi	r12,-32049
 320b0fc:	0320b3c4 	movi	r12,-32049
 320b100:	0320b3c4 	movi	r12,-32049
 320b104:	0320b3c4 	movi	r12,-32049
 320b108:	0320b008 	cmpgei	r12,zero,-32064
 320b10c:	0320b008 	cmpgei	r12,zero,-32064
 320b110:	0320b008 	cmpgei	r12,zero,-32064
 320b114:	0320b008 	cmpgei	r12,zero,-32064
 320b118:	0320b008 	cmpgei	r12,zero,-32064
 320b11c:	0320b008 	cmpgei	r12,zero,-32064
 320b120:	0320b008 	cmpgei	r12,zero,-32064
 320b124:	0320b008 	cmpgei	r12,zero,-32064
 320b128:	0320b008 	cmpgei	r12,zero,-32064
 320b12c:	0320b008 	cmpgei	r12,zero,-32064
 320b130:	0320b008 	cmpgei	r12,zero,-32064
 320b134:	0320b008 	cmpgei	r12,zero,-32064
 320b138:	0320b008 	cmpgei	r12,zero,-32064
 320b13c:	0320b008 	cmpgei	r12,zero,-32064
 320b140:	0320b008 	cmpgei	r12,zero,-32064
 320b144:	0320b008 	cmpgei	r12,zero,-32064
 320b148:	0320b008 	cmpgei	r12,zero,-32064
 320b14c:	0320b3d4 	movui	r12,33487
 320b150:	0320b008 	cmpgei	r12,zero,-32064
 320b154:	0320b008 	cmpgei	r12,zero,-32064
 320b158:	0320b008 	cmpgei	r12,zero,-32064
 320b15c:	0320b008 	cmpgei	r12,zero,-32064
 320b160:	0320b008 	cmpgei	r12,zero,-32064
 320b164:	0320b008 	cmpgei	r12,zero,-32064
 320b168:	0320b008 	cmpgei	r12,zero,-32064
 320b16c:	0320b008 	cmpgei	r12,zero,-32064
 320b170:	0320b3c4 	movi	r12,-32049
 320b174:	0320b3c4 	movi	r12,-32049
 320b178:	0320b3c4 	movi	r12,-32049
 320b17c:	0320b3c4 	movi	r12,-32049
 320b180:	0320b3c4 	movi	r12,-32049
 320b184:	0320b3c4 	movi	r12,-32049
 320b188:	0320b008 	cmpgei	r12,zero,-32064
 320b18c:	0320b008 	cmpgei	r12,zero,-32064
 320b190:	0320b008 	cmpgei	r12,zero,-32064
 320b194:	0320b008 	cmpgei	r12,zero,-32064
 320b198:	0320b008 	cmpgei	r12,zero,-32064
 320b19c:	0320b008 	cmpgei	r12,zero,-32064
 320b1a0:	0320b008 	cmpgei	r12,zero,-32064
 320b1a4:	0320b008 	cmpgei	r12,zero,-32064
 320b1a8:	0320b008 	cmpgei	r12,zero,-32064
 320b1ac:	0320b008 	cmpgei	r12,zero,-32064
 320b1b0:	0320b008 	cmpgei	r12,zero,-32064
 320b1b4:	0320b008 	cmpgei	r12,zero,-32064
 320b1b8:	0320b008 	cmpgei	r12,zero,-32064
 320b1bc:	0320b008 	cmpgei	r12,zero,-32064
 320b1c0:	0320b008 	cmpgei	r12,zero,-32064
 320b1c4:	0320b008 	cmpgei	r12,zero,-32064
 320b1c8:	0320b008 	cmpgei	r12,zero,-32064
 320b1cc:	0320b3d4 	movui	r12,33487
 320b1d0:	000d883a 	mov	r6,zero
 320b1d4:	003d9006 	br	320a818 <__svfscanf_r+0x730>
 320b1d8:	98000005 	stb	zero,0(r19)
 320b1dc:	d8c0a017 	ldw	r3,640(sp)
 320b1e0:	d940a617 	ldw	r5,664(sp)
 320b1e4:	d9c0a117 	ldw	r7,644(sp)
 320b1e8:	b009883a 	mov	r4,r22
 320b1ec:	000d883a 	mov	r6,zero
 320b1f0:	183ee83a 	callr	r3
 320b1f4:	1007883a 	mov	r3,r2
 320b1f8:	9080080c 	andi	r2,r18,32
 320b1fc:	10004d1e 	bne	r2,zero,320b334 <__svfscanf_r+0x124c>
 320b200:	9080010c 	andi	r2,r18,4
 320b204:	10003426 	beq	r2,zero,320b2d8 <__svfscanf_r+0x11f0>
 320b208:	d900a417 	ldw	r4,656(sp)
 320b20c:	20800017 	ldw	r2,0(r4)
 320b210:	21000104 	addi	r4,r4,4
 320b214:	d900a415 	stw	r4,656(sp)
 320b218:	10c0000d 	sth	r3,0(r2)
 320b21c:	d880a217 	ldw	r2,648(sp)
 320b220:	10800044 	addi	r2,r2,1
 320b224:	d880a215 	stw	r2,648(sp)
 320b228:	003f8406 	br	320b03c <__svfscanf_r+0xf54>
 320b22c:	9080200c 	andi	r2,r18,128
 320b230:	103f7526 	beq	r2,zero,320b008 <__svfscanf_r+0xf20>
 320b234:	00bfdfc4 	movi	r2,-129
 320b238:	90a4703a 	and	r18,r18,r2
 320b23c:	99400005 	stb	r5,0(r19)
 320b240:	9cc00044 	addi	r19,r19,1
 320b244:	80c00117 	ldw	r3,4(r16)
 320b248:	18ffffc4 	addi	r3,r3,-1
 320b24c:	80c00115 	stw	r3,4(r16)
 320b250:	00c0130e 	bge	zero,r3,320b2a0 <__svfscanf_r+0x11b8>
 320b254:	31800044 	addi	r6,r6,1
 320b258:	81800015 	stw	r6,0(r16)
 320b25c:	d880a317 	ldw	r2,652(sp)
 320b260:	10bfffc4 	addi	r2,r2,-1
 320b264:	d880a315 	stw	r2,652(sp)
 320b268:	103f7e1e 	bne	r2,zero,320b064 <__svfscanf_r+0xf7c>
 320b26c:	003f6606 	br	320b008 <__svfscanf_r+0xf20>
 320b270:	9082000c 	andi	r2,r18,2048
 320b274:	103ff126 	beq	r2,zero,320b23c <__svfscanf_r+0x1154>
 320b278:	d8c0a117 	ldw	r3,644(sp)
 320b27c:	1800031e 	bne	r3,zero,320b28c <__svfscanf_r+0x11a4>
 320b280:	01000204 	movi	r4,8
 320b284:	94808014 	ori	r18,r18,512
 320b288:	d900a115 	stw	r4,644(sp)
 320b28c:	9081000c 	andi	r2,r18,1024
 320b290:	10000826 	beq	r2,zero,320b2b4 <__svfscanf_r+0x11cc>
 320b294:	00be9fc4 	movi	r2,-1409
 320b298:	90a4703a 	and	r18,r18,r2
 320b29c:	003fe706 	br	320b23c <__svfscanf_r+0x1154>
 320b2a0:	b009883a 	mov	r4,r22
 320b2a4:	800b883a 	mov	r5,r16
 320b2a8:	320740c0 	call	320740c <__srefill_r>
 320b2ac:	103feb26 	beq	r2,zero,320b25c <__svfscanf_r+0x1174>
 320b2b0:	003f5506 	br	320b008 <__svfscanf_r+0xf20>
 320b2b4:	a8000426 	beq	r21,zero,320b2c8 <__svfscanf_r+0x11e0>
 320b2b8:	d880a317 	ldw	r2,652(sp)
 320b2bc:	ad7fffc4 	addi	r21,r21,-1
 320b2c0:	10800044 	addi	r2,r2,1
 320b2c4:	d880a315 	stw	r2,652(sp)
 320b2c8:	00bf1fc4 	movi	r2,-897
 320b2cc:	90a4703a 	and	r18,r18,r2
 320b2d0:	bdc00044 	addi	r23,r23,1
 320b2d4:	003fdb06 	br	320b244 <__svfscanf_r+0x115c>
 320b2d8:	9080004c 	andi	r2,r18,1
 320b2dc:	1005003a 	cmpeq	r2,r2,zero
 320b2e0:	10001426 	beq	r2,zero,320b334 <__svfscanf_r+0x124c>
 320b2e4:	9080008c 	andi	r2,r18,2
 320b2e8:	10001226 	beq	r2,zero,320b334 <__svfscanf_r+0x124c>
 320b2ec:	d8c0a017 	ldw	r3,640(sp)
 320b2f0:	0080c874 	movhi	r2,801
 320b2f4:	10821804 	addi	r2,r2,2144
 320b2f8:	18801426 	beq	r3,r2,320b34c <__svfscanf_r+0x1264>
 320b2fc:	d9c0a117 	ldw	r7,644(sp)
 320b300:	d940a617 	ldw	r5,664(sp)
 320b304:	000d883a 	mov	r6,zero
 320b308:	b009883a 	mov	r4,r22
 320b30c:	32105480 	call	3210548 <_strtoll_r>
 320b310:	100d883a 	mov	r6,r2
 320b314:	180f883a 	mov	r7,r3
 320b318:	d900a417 	ldw	r4,656(sp)
 320b31c:	20800017 	ldw	r2,0(r4)
 320b320:	21000104 	addi	r4,r4,4
 320b324:	d900a415 	stw	r4,656(sp)
 320b328:	11c00115 	stw	r7,4(r2)
 320b32c:	11800015 	stw	r6,0(r2)
 320b330:	003fba06 	br	320b21c <__svfscanf_r+0x1134>
 320b334:	d900a417 	ldw	r4,656(sp)
 320b338:	20800017 	ldw	r2,0(r4)
 320b33c:	21000104 	addi	r4,r4,4
 320b340:	d900a415 	stw	r4,656(sp)
 320b344:	10c00015 	stw	r3,0(r2)
 320b348:	003fb406 	br	320b21c <__svfscanf_r+0x1134>
 320b34c:	d9c0a117 	ldw	r7,644(sp)
 320b350:	d940a617 	ldw	r5,664(sp)
 320b354:	000d883a 	mov	r6,zero
 320b358:	b009883a 	mov	r4,r22
 320b35c:	3210ab40 	call	3210ab4 <_strtoull_r>
 320b360:	100d883a 	mov	r6,r2
 320b364:	180f883a 	mov	r7,r3
 320b368:	003feb06 	br	320b318 <__svfscanf_r+0x1230>
 320b36c:	d8c0a117 	ldw	r3,644(sp)
 320b370:	18c5883a 	add	r2,r3,r3
 320b374:	00c0c974 	movhi	r3,805
 320b378:	18f7cb84 	addi	r3,r3,-8402
 320b37c:	10c5883a 	add	r2,r2,r3
 320b380:	1080000f 	ldh	r2,0(r2)
 320b384:	00fd1fc4 	movi	r3,-2945
 320b388:	90e4703a 	and	r18,r18,r3
 320b38c:	d880a115 	stw	r2,644(sp)
 320b390:	003faa06 	br	320b23c <__svfscanf_r+0x1154>
 320b394:	d900a117 	ldw	r4,644(sp)
 320b398:	00c0c974 	movhi	r3,805
 320b39c:	18f7cb84 	addi	r3,r3,-8402
 320b3a0:	2105883a 	add	r2,r4,r4
 320b3a4:	10c5883a 	add	r2,r2,r3
 320b3a8:	1080000f 	ldh	r2,0(r2)
 320b3ac:	00c00204 	movi	r3,8
 320b3b0:	d880a115 	stw	r2,644(sp)
 320b3b4:	18bf140e 	bge	r3,r2,320b008 <__svfscanf_r+0xf20>
 320b3b8:	00bd1fc4 	movi	r2,-2945
 320b3bc:	90a4703a 	and	r18,r18,r2
 320b3c0:	003f9e06 	br	320b23c <__svfscanf_r+0x1154>
 320b3c4:	d8c0a117 	ldw	r3,644(sp)
 320b3c8:	00800284 	movi	r2,10
 320b3cc:	10fffa16 	blt	r2,r3,320b3b8 <__svfscanf_r+0x12d0>
 320b3d0:	003f0d06 	br	320b008 <__svfscanf_r+0xf20>
 320b3d4:	90c1800c 	andi	r3,r18,1536
 320b3d8:	00808004 	movi	r2,512
 320b3dc:	18bf0a1e 	bne	r3,r2,320b008 <__svfscanf_r+0xf20>
 320b3e0:	00bf7fc4 	movi	r2,-513
 320b3e4:	9084703a 	and	r2,r18,r2
 320b3e8:	01000404 	movi	r4,16
 320b3ec:	14814014 	ori	r18,r2,1280
 320b3f0:	d900a115 	stw	r4,644(sp)
 320b3f4:	003f9106 	br	320b23c <__svfscanf_r+0x1154>
 320b3f8:	d880a417 	ldw	r2,656(sp)
 320b3fc:	dd400404 	addi	r21,sp,16
 320b400:	14800017 	ldw	r18,0(r2)
 320b404:	9027883a 	mov	r19,r18
 320b408:	81000017 	ldw	r4,0(r16)
 320b40c:	20800003 	ldbu	r2,0(r4)
 320b410:	a885883a 	add	r2,r21,r2
 320b414:	10c00007 	ldb	r3,0(r2)
 320b418:	18001426 	beq	r3,zero,320b46c <__svfscanf_r+0x1384>
 320b41c:	d8c0a317 	ldw	r3,652(sp)
 320b420:	80800117 	ldw	r2,4(r16)
 320b424:	21800044 	addi	r6,r4,1
 320b428:	18ffffc4 	addi	r3,r3,-1
 320b42c:	d8c0a315 	stw	r3,652(sp)
 320b430:	10ffffc4 	addi	r3,r2,-1
 320b434:	80c00115 	stw	r3,4(r16)
 320b438:	20800003 	ldbu	r2,0(r4)
 320b43c:	90800005 	stb	r2,0(r18)
 320b440:	d900a317 	ldw	r4,652(sp)
 320b444:	81800015 	stw	r6,0(r16)
 320b448:	94800044 	addi	r18,r18,1
 320b44c:	20000726 	beq	r4,zero,320b46c <__svfscanf_r+0x1384>
 320b450:	80800117 	ldw	r2,4(r16)
 320b454:	00bfec16 	blt	zero,r2,320b408 <__svfscanf_r+0x1320>
 320b458:	b009883a 	mov	r4,r22
 320b45c:	800b883a 	mov	r5,r16
 320b460:	320740c0 	call	320740c <__srefill_r>
 320b464:	103fe826 	beq	r2,zero,320b408 <__svfscanf_r+0x1320>
 320b468:	9cbb7426 	beq	r19,r18,320a23c <__svfscanf_r+0x154>
 320b46c:	94e7c83a 	sub	r19,r18,r19
 320b470:	983b5226 	beq	r19,zero,320a1bc <__svfscanf_r+0xd4>
 320b474:	90000005 	stb	zero,0(r18)
 320b478:	d880a417 	ldw	r2,656(sp)
 320b47c:	d8c0a217 	ldw	r3,648(sp)
 320b480:	8ce3883a 	add	r17,r17,r19
 320b484:	10800104 	addi	r2,r2,4
 320b488:	18c00044 	addi	r3,r3,1
 320b48c:	d880a415 	stw	r2,656(sp)
 320b490:	d8c0a215 	stw	r3,648(sp)
 320b494:	003b2706 	br	320a134 <__svfscanf_r+0x4c>
 320b498:	9cc00414 	ori	r19,r19,16
 320b49c:	003b6e06 	br	320a258 <__svfscanf_r+0x170>
 320b4a0:	00c00404 	movi	r3,16
 320b4a4:	0100c874 	movhi	r4,801
 320b4a8:	21021804 	addi	r4,r4,2144
 320b4ac:	9cc08014 	ori	r19,r19,512
 320b4b0:	054000c4 	movi	r21,3
 320b4b4:	d8c0a115 	stw	r3,644(sp)
 320b4b8:	d900a015 	stw	r4,640(sp)
 320b4bc:	003bf806 	br	320a4a0 <__svfscanf_r+0x3b8>
 320b4c0:	9880040c 	andi	r2,r19,16
 320b4c4:	10001926 	beq	r2,zero,320b52c <__svfscanf_r+0x1444>
 320b4c8:	0027883a 	mov	r19,zero
 320b4cc:	00000b06 	br	320b4fc <__svfscanf_r+0x1414>
 320b4d0:	80800017 	ldw	r2,0(r16)
 320b4d4:	b009883a 	mov	r4,r22
 320b4d8:	800b883a 	mov	r5,r16
 320b4dc:	148d883a 	add	r6,r2,r18
 320b4e0:	81800015 	stw	r6,0(r16)
 320b4e4:	9ca7883a 	add	r19,r19,r18
 320b4e8:	320740c0 	call	320740c <__srefill_r>
 320b4ec:	103c711e 	bne	r2,zero,320a6b4 <__svfscanf_r+0x5cc>
 320b4f0:	d900a317 	ldw	r4,652(sp)
 320b4f4:	2489c83a 	sub	r4,r4,r18
 320b4f8:	d900a315 	stw	r4,652(sp)
 320b4fc:	84800117 	ldw	r18,4(r16)
 320b500:	d8c0a317 	ldw	r3,652(sp)
 320b504:	90fff216 	blt	r18,r3,320b4d0 <__svfscanf_r+0x13e8>
 320b508:	d900a317 	ldw	r4,652(sp)
 320b50c:	80800017 	ldw	r2,0(r16)
 320b510:	9927883a 	add	r19,r19,r4
 320b514:	9107c83a 	sub	r3,r18,r4
 320b518:	110d883a 	add	r6,r2,r4
 320b51c:	8ce3883a 	add	r17,r17,r19
 320b520:	80c00115 	stw	r3,4(r16)
 320b524:	81800015 	stw	r6,0(r16)
 320b528:	003b0206 	br	320a134 <__svfscanf_r+0x4c>
 320b52c:	d880a417 	ldw	r2,656(sp)
 320b530:	d980a317 	ldw	r6,652(sp)
 320b534:	01400044 	movi	r5,1
 320b538:	11000017 	ldw	r4,0(r2)
 320b53c:	800f883a 	mov	r7,r16
 320b540:	320d6fc0 	call	320d6fc <fread>
 320b544:	103b3d26 	beq	r2,zero,320a23c <__svfscanf_r+0x154>
 320b548:	d8c0a417 	ldw	r3,656(sp)
 320b54c:	d900a217 	ldw	r4,648(sp)
 320b550:	88a3883a 	add	r17,r17,r2
 320b554:	18c00104 	addi	r3,r3,4
 320b558:	21000044 	addi	r4,r4,1
 320b55c:	d8c0a415 	stw	r3,656(sp)
 320b560:	d900a215 	stw	r4,648(sp)
 320b564:	003af306 	br	320a134 <__svfscanf_r+0x4c>
 320b568:	8080030b 	ldhu	r2,12(r16)
 320b56c:	1080100c 	andi	r2,r2,64
 320b570:	103b1226 	beq	r2,zero,320a1bc <__svfscanf_r+0xd4>
 320b574:	003b3306 	br	320a244 <__svfscanf_r+0x15c>
 320b578:	983b1026 	beq	r19,zero,320a1bc <__svfscanf_r+0xd4>
 320b57c:	8ce3883a 	add	r17,r17,r19
 320b580:	003aec06 	br	320a134 <__svfscanf_r+0x4c>
 320b584:	983c9626 	beq	r19,zero,320a7e0 <__svfscanf_r+0x6f8>
 320b588:	9cffffc4 	addi	r19,r19,-1
 320b58c:	d8c04404 	addi	r3,sp,272
 320b590:	1cc5883a 	add	r2,r3,r19
 320b594:	11400003 	ldbu	r5,0(r2)
 320b598:	b009883a 	mov	r4,r22
 320b59c:	800d883a 	mov	r6,r16
 320b5a0:	3210e800 	call	3210e80 <_ungetc_r>
 320b5a4:	003ff706 	br	320b584 <__svfscanf_r+0x149c>
 320b5a8:	00bfff84 	movi	r2,-2
 320b5ac:	18bc7a1e 	bne	r3,r2,320a798 <__svfscanf_r+0x6b0>
 320b5b0:	003c8406 	br	320a7c4 <__svfscanf_r+0x6dc>
 320b5b4:	d900a417 	ldw	r4,656(sp)
 320b5b8:	25400017 	ldw	r21,0(r4)
 320b5bc:	21000104 	addi	r4,r4,4
 320b5c0:	d900a415 	stw	r4,656(sp)
 320b5c4:	003c4a06 	br	320a6f0 <__svfscanf_r+0x608>
 320b5c8:	00bfff84 	movi	r2,-2
 320b5cc:	18bc0f1e 	bne	r3,r2,320a60c <__svfscanf_r+0x524>
 320b5d0:	003c1506 	br	320a628 <__svfscanf_r+0x540>
 320b5d4:	b009883a 	mov	r4,r22
 320b5d8:	800b883a 	mov	r5,r16
 320b5dc:	320740c0 	call	320740c <__srefill_r>
 320b5e0:	103c1326 	beq	r2,zero,320a630 <__svfscanf_r+0x548>
 320b5e4:	903b151e 	bne	r18,zero,320a23c <__svfscanf_r+0x154>
 320b5e8:	a83ad21e 	bne	r21,zero,320a134 <__svfscanf_r+0x4c>
 320b5ec:	d880a217 	ldw	r2,648(sp)
 320b5f0:	10800044 	addi	r2,r2,1
 320b5f4:	d880a215 	stw	r2,648(sp)
 320b5f8:	003ace06 	br	320a134 <__svfscanf_r+0x4c>
 320b5fc:	0027883a 	mov	r19,zero
 320b600:	003bdd06 	br	320a578 <__svfscanf_r+0x490>
 320b604:	9cc00114 	ori	r19,r19,4
 320b608:	003b1306 	br	320a258 <__svfscanf_r+0x170>
 320b60c:	05400104 	movi	r21,4
 320b610:	003ba306 	br	320a4a0 <__svfscanf_r+0x3b8>
 320b614:	9cc00054 	ori	r19,r19,1
 320b618:	0080c874 	movhi	r2,801
 320b61c:	1080b804 	addi	r2,r2,736
 320b620:	00c00284 	movi	r3,10
 320b624:	054000c4 	movi	r21,3
 320b628:	d880a015 	stw	r2,640(sp)
 320b62c:	d8c0a115 	stw	r3,644(sp)
 320b630:	003b9b06 	br	320a4a0 <__svfscanf_r+0x3b8>
 320b634:	9cc01014 	ori	r19,r19,64
 320b638:	002b883a 	mov	r21,zero
 320b63c:	003b9806 	br	320a4a0 <__svfscanf_r+0x3b8>
 320b640:	a00b883a 	mov	r5,r20
 320b644:	d9000404 	addi	r4,sp,16
 320b648:	320eaf00 	call	320eaf0 <__sccl>
 320b64c:	1029883a 	mov	r20,r2
 320b650:	9cc01014 	ori	r19,r19,64
 320b654:	05400044 	movi	r21,1
 320b658:	003b9106 	br	320a4a0 <__svfscanf_r+0x3b8>
 320b65c:	9cc00054 	ori	r19,r19,1
 320b660:	00800204 	movi	r2,8
 320b664:	00c0c874 	movhi	r3,801
 320b668:	18c21804 	addi	r3,r3,2144
 320b66c:	054000c4 	movi	r21,3
 320b670:	d880a115 	stw	r2,644(sp)
 320b674:	d8c0a015 	stw	r3,640(sp)
 320b678:	003b8906 	br	320a4a0 <__svfscanf_r+0x3b8>
 320b67c:	9880040c 	andi	r2,r19,16
 320b680:	103aac1e 	bne	r2,zero,320a134 <__svfscanf_r+0x4c>
 320b684:	9880010c 	andi	r2,r19,4
 320b688:	10002426 	beq	r2,zero,320b71c <__svfscanf_r+0x1634>
 320b68c:	d900a417 	ldw	r4,656(sp)
 320b690:	20800017 	ldw	r2,0(r4)
 320b694:	21000104 	addi	r4,r4,4
 320b698:	d900a415 	stw	r4,656(sp)
 320b69c:	1440000d 	sth	r17,0(r2)
 320b6a0:	003aa406 	br	320a134 <__svfscanf_r+0x4c>
 320b6a4:	9cc00094 	ori	r19,r19,2
 320b6a8:	003aeb06 	br	320a258 <__svfscanf_r+0x170>
 320b6ac:	05400084 	movi	r21,2
 320b6b0:	003b7b06 	br	320a4a0 <__svfscanf_r+0x3b8>
 320b6b4:	00800404 	movi	r2,16
 320b6b8:	00c0c874 	movhi	r3,801
 320b6bc:	18c21804 	addi	r3,r3,2144
 320b6c0:	9cc08814 	ori	r19,r19,544
 320b6c4:	054000c4 	movi	r21,3
 320b6c8:	d880a115 	stw	r2,644(sp)
 320b6cc:	d8c0a015 	stw	r3,640(sp)
 320b6d0:	003b7306 	br	320a4a0 <__svfscanf_r+0x3b8>
 320b6d4:	0009883a 	mov	r4,zero
 320b6d8:	320ebb00 	call	320ebb0 <nanf>
 320b6dc:	b8800015 	stw	r2,0(r23)
 320b6e0:	003d2706 	br	320ab80 <__svfscanf_r+0xa98>
 320b6e4:	a0c00007 	ldb	r3,0(r20)
 320b6e8:	00801b04 	movi	r2,108
 320b6ec:	18800826 	beq	r3,r2,320b710 <__svfscanf_r+0x1628>
 320b6f0:	9cc00054 	ori	r19,r19,1
 320b6f4:	003ad806 	br	320a258 <__svfscanf_r+0x170>
 320b6f8:	0100c874 	movhi	r4,801
 320b6fc:	2100b804 	addi	r4,r4,736
 320b700:	054000c4 	movi	r21,3
 320b704:	d900a015 	stw	r4,640(sp)
 320b708:	d800a115 	stw	zero,644(sp)
 320b70c:	003b6406 	br	320a4a0 <__svfscanf_r+0x3b8>
 320b710:	a5000044 	addi	r20,r20,1
 320b714:	9cc00094 	ori	r19,r19,2
 320b718:	003acf06 	br	320a258 <__svfscanf_r+0x170>
 320b71c:	9880004c 	andi	r2,r19,1
 320b720:	1005003a 	cmpeq	r2,r2,zero
 320b724:	10000a26 	beq	r2,zero,320b750 <__svfscanf_r+0x1668>
 320b728:	9880008c 	andi	r2,r19,2
 320b72c:	10000826 	beq	r2,zero,320b750 <__svfscanf_r+0x1668>
 320b730:	d900a417 	ldw	r4,656(sp)
 320b734:	8807d7fa 	srai	r3,r17,31
 320b738:	20800017 	ldw	r2,0(r4)
 320b73c:	21000104 	addi	r4,r4,4
 320b740:	d900a415 	stw	r4,656(sp)
 320b744:	14400015 	stw	r17,0(r2)
 320b748:	10c00115 	stw	r3,4(r2)
 320b74c:	003a7906 	br	320a134 <__svfscanf_r+0x4c>
 320b750:	d8c0a417 	ldw	r3,656(sp)
 320b754:	18800017 	ldw	r2,0(r3)
 320b758:	18c00104 	addi	r3,r3,4
 320b75c:	d8c0a415 	stw	r3,656(sp)
 320b760:	14400015 	stw	r17,0(r2)
 320b764:	003a7306 	br	320a134 <__svfscanf_r+0x4c>

0320b768 <__svfscanf>:
 320b768:	0080c974 	movhi	r2,805
 320b76c:	10897804 	addi	r2,r2,9696
 320b770:	2013883a 	mov	r9,r4
 320b774:	11000017 	ldw	r4,0(r2)
 320b778:	2805883a 	mov	r2,r5
 320b77c:	300f883a 	mov	r7,r6
 320b780:	480b883a 	mov	r5,r9
 320b784:	100d883a 	mov	r6,r2
 320b788:	320a0e81 	jmpi	320a0e8 <__svfscanf_r>

0320b78c <_vfscanf_r>:
 320b78c:	defffb04 	addi	sp,sp,-20
 320b790:	dcc00315 	stw	r19,12(sp)
 320b794:	dc800215 	stw	r18,8(sp)
 320b798:	dc400115 	stw	r17,4(sp)
 320b79c:	dc000015 	stw	r16,0(sp)
 320b7a0:	dfc00415 	stw	ra,16(sp)
 320b7a4:	2021883a 	mov	r16,r4
 320b7a8:	2823883a 	mov	r17,r5
 320b7ac:	3025883a 	mov	r18,r6
 320b7b0:	3827883a 	mov	r19,r7
 320b7b4:	20000226 	beq	r4,zero,320b7c0 <_vfscanf_r+0x34>
 320b7b8:	20800e17 	ldw	r2,56(r4)
 320b7bc:	10000b26 	beq	r2,zero,320b7ec <_vfscanf_r+0x60>
 320b7c0:	8009883a 	mov	r4,r16
 320b7c4:	880b883a 	mov	r5,r17
 320b7c8:	900d883a 	mov	r6,r18
 320b7cc:	980f883a 	mov	r7,r19
 320b7d0:	dfc00417 	ldw	ra,16(sp)
 320b7d4:	dcc00317 	ldw	r19,12(sp)
 320b7d8:	dc800217 	ldw	r18,8(sp)
 320b7dc:	dc400117 	ldw	r17,4(sp)
 320b7e0:	dc000017 	ldw	r16,0(sp)
 320b7e4:	dec00504 	addi	sp,sp,20
 320b7e8:	320a0e81 	jmpi	320a0e8 <__svfscanf_r>
 320b7ec:	32048880 	call	3204888 <__sinit>
 320b7f0:	003ff306 	br	320b7c0 <_vfscanf_r+0x34>

0320b7f4 <vfscanf>:
 320b7f4:	defffb04 	addi	sp,sp,-20
 320b7f8:	dcc00315 	stw	r19,12(sp)
 320b7fc:	04c0c974 	movhi	r19,805
 320b800:	9cc97804 	addi	r19,r19,9696
 320b804:	98c00017 	ldw	r3,0(r19)
 320b808:	dc800215 	stw	r18,8(sp)
 320b80c:	dc400115 	stw	r17,4(sp)
 320b810:	dc000015 	stw	r16,0(sp)
 320b814:	dfc00415 	stw	ra,16(sp)
 320b818:	2021883a 	mov	r16,r4
 320b81c:	2823883a 	mov	r17,r5
 320b820:	3025883a 	mov	r18,r6
 320b824:	18000326 	beq	r3,zero,320b834 <vfscanf+0x40>
 320b828:	18800e17 	ldw	r2,56(r3)
 320b82c:	1809883a 	mov	r4,r3
 320b830:	10000b26 	beq	r2,zero,320b860 <vfscanf+0x6c>
 320b834:	99000017 	ldw	r4,0(r19)
 320b838:	800b883a 	mov	r5,r16
 320b83c:	880d883a 	mov	r6,r17
 320b840:	900f883a 	mov	r7,r18
 320b844:	dfc00417 	ldw	ra,16(sp)
 320b848:	dcc00317 	ldw	r19,12(sp)
 320b84c:	dc800217 	ldw	r18,8(sp)
 320b850:	dc400117 	ldw	r17,4(sp)
 320b854:	dc000017 	ldw	r16,0(sp)
 320b858:	dec00504 	addi	sp,sp,20
 320b85c:	320a0e81 	jmpi	320a0e8 <__svfscanf_r>
 320b860:	32048880 	call	3204888 <__sinit>
 320b864:	003ff306 	br	320b834 <vfscanf+0x40>

0320b868 <__swbuf_r>:
 320b868:	defffc04 	addi	sp,sp,-16
 320b86c:	dc400215 	stw	r17,8(sp)
 320b870:	dc000115 	stw	r16,4(sp)
 320b874:	dfc00315 	stw	ra,12(sp)
 320b878:	2023883a 	mov	r17,r4
 320b87c:	2821883a 	mov	r16,r5
 320b880:	20000226 	beq	r4,zero,320b88c <__swbuf_r+0x24>
 320b884:	20800e17 	ldw	r2,56(r4)
 320b888:	10002f26 	beq	r2,zero,320b948 <__swbuf_r+0xe0>
 320b88c:	3080030b 	ldhu	r2,12(r6)
 320b890:	30c00617 	ldw	r3,24(r6)
 320b894:	1080020c 	andi	r2,r2,8
 320b898:	30c00215 	stw	r3,8(r6)
 320b89c:	10002226 	beq	r2,zero,320b928 <__swbuf_r+0xc0>
 320b8a0:	30c00417 	ldw	r3,16(r6)
 320b8a4:	18002026 	beq	r3,zero,320b928 <__swbuf_r+0xc0>
 320b8a8:	31000017 	ldw	r4,0(r6)
 320b8ac:	30800517 	ldw	r2,20(r6)
 320b8b0:	20c7c83a 	sub	r3,r4,r3
 320b8b4:	18802f0e 	bge	r3,r2,320b974 <__swbuf_r+0x10c>
 320b8b8:	19400044 	addi	r5,r3,1
 320b8bc:	30800217 	ldw	r2,8(r6)
 320b8c0:	84003fcc 	andi	r16,r16,255
 320b8c4:	20c00044 	addi	r3,r4,1
 320b8c8:	10bfffc4 	addi	r2,r2,-1
 320b8cc:	30800215 	stw	r2,8(r6)
 320b8d0:	24000005 	stb	r16,0(r4)
 320b8d4:	30800517 	ldw	r2,20(r6)
 320b8d8:	30c00015 	stw	r3,0(r6)
 320b8dc:	11400c26 	beq	r2,r5,320b910 <__swbuf_r+0xa8>
 320b8e0:	3080030b 	ldhu	r2,12(r6)
 320b8e4:	1080004c 	andi	r2,r2,1
 320b8e8:	1005003a 	cmpeq	r2,r2,zero
 320b8ec:	10000626 	beq	r2,zero,320b908 <__swbuf_r+0xa0>
 320b8f0:	8005883a 	mov	r2,r16
 320b8f4:	dfc00317 	ldw	ra,12(sp)
 320b8f8:	dc400217 	ldw	r17,8(sp)
 320b8fc:	dc000117 	ldw	r16,4(sp)
 320b900:	dec00404 	addi	sp,sp,16
 320b904:	f800283a 	ret
 320b908:	00800284 	movi	r2,10
 320b90c:	80bff81e 	bne	r16,r2,320b8f0 <__swbuf_r+0x88>
 320b910:	8809883a 	mov	r4,r17
 320b914:	300b883a 	mov	r5,r6
 320b918:	32045f00 	call	32045f0 <_fflush_r>
 320b91c:	103ff426 	beq	r2,zero,320b8f0 <__swbuf_r+0x88>
 320b920:	043fffc4 	movi	r16,-1
 320b924:	003ff206 	br	320b8f0 <__swbuf_r+0x88>
 320b928:	300b883a 	mov	r5,r6
 320b92c:	8809883a 	mov	r4,r17
 320b930:	d9800015 	stw	r6,0(sp)
 320b934:	320ba2c0 	call	320ba2c <__swsetup_r>
 320b938:	d9800017 	ldw	r6,0(sp)
 320b93c:	1000061e 	bne	r2,zero,320b958 <__swbuf_r+0xf0>
 320b940:	30c00417 	ldw	r3,16(r6)
 320b944:	003fd806 	br	320b8a8 <__swbuf_r+0x40>
 320b948:	d9800015 	stw	r6,0(sp)
 320b94c:	32048880 	call	3204888 <__sinit>
 320b950:	d9800017 	ldw	r6,0(sp)
 320b954:	003fcd06 	br	320b88c <__swbuf_r+0x24>
 320b958:	3080030b 	ldhu	r2,12(r6)
 320b95c:	00c00244 	movi	r3,9
 320b960:	043fffc4 	movi	r16,-1
 320b964:	10801014 	ori	r2,r2,64
 320b968:	3080030d 	sth	r2,12(r6)
 320b96c:	88c00015 	stw	r3,0(r17)
 320b970:	003fdf06 	br	320b8f0 <__swbuf_r+0x88>
 320b974:	300b883a 	mov	r5,r6
 320b978:	8809883a 	mov	r4,r17
 320b97c:	d9800015 	stw	r6,0(sp)
 320b980:	32045f00 	call	32045f0 <_fflush_r>
 320b984:	d9800017 	ldw	r6,0(sp)
 320b988:	103fe51e 	bne	r2,zero,320b920 <__swbuf_r+0xb8>
 320b98c:	31000017 	ldw	r4,0(r6)
 320b990:	01400044 	movi	r5,1
 320b994:	003fc906 	br	320b8bc <__swbuf_r+0x54>

0320b998 <__swbuf>:
 320b998:	0180c974 	movhi	r6,805
 320b99c:	31897804 	addi	r6,r6,9696
 320b9a0:	2007883a 	mov	r3,r4
 320b9a4:	31000017 	ldw	r4,0(r6)
 320b9a8:	280d883a 	mov	r6,r5
 320b9ac:	180b883a 	mov	r5,r3
 320b9b0:	320b8681 	jmpi	320b868 <__swbuf_r>

0320b9b4 <_write_r>:
 320b9b4:	defffd04 	addi	sp,sp,-12
 320b9b8:	dc000015 	stw	r16,0(sp)
 320b9bc:	0400c974 	movhi	r16,805
 320b9c0:	84120d04 	addi	r16,r16,18484
 320b9c4:	dc400115 	stw	r17,4(sp)
 320b9c8:	80000015 	stw	zero,0(r16)
 320b9cc:	2023883a 	mov	r17,r4
 320b9d0:	2809883a 	mov	r4,r5
 320b9d4:	300b883a 	mov	r5,r6
 320b9d8:	380d883a 	mov	r6,r7
 320b9dc:	dfc00215 	stw	ra,8(sp)
 320b9e0:	32229ec0 	call	32229ec <write>
 320b9e4:	1007883a 	mov	r3,r2
 320b9e8:	00bfffc4 	movi	r2,-1
 320b9ec:	18800626 	beq	r3,r2,320ba08 <_write_r+0x54>
 320b9f0:	1805883a 	mov	r2,r3
 320b9f4:	dfc00217 	ldw	ra,8(sp)
 320b9f8:	dc400117 	ldw	r17,4(sp)
 320b9fc:	dc000017 	ldw	r16,0(sp)
 320ba00:	dec00304 	addi	sp,sp,12
 320ba04:	f800283a 	ret
 320ba08:	80800017 	ldw	r2,0(r16)
 320ba0c:	103ff826 	beq	r2,zero,320b9f0 <_write_r+0x3c>
 320ba10:	88800015 	stw	r2,0(r17)
 320ba14:	1805883a 	mov	r2,r3
 320ba18:	dfc00217 	ldw	ra,8(sp)
 320ba1c:	dc400117 	ldw	r17,4(sp)
 320ba20:	dc000017 	ldw	r16,0(sp)
 320ba24:	dec00304 	addi	sp,sp,12
 320ba28:	f800283a 	ret

0320ba2c <__swsetup_r>:
 320ba2c:	0080c974 	movhi	r2,805
 320ba30:	10897804 	addi	r2,r2,9696
 320ba34:	10c00017 	ldw	r3,0(r2)
 320ba38:	defffd04 	addi	sp,sp,-12
 320ba3c:	dc400115 	stw	r17,4(sp)
 320ba40:	dc000015 	stw	r16,0(sp)
 320ba44:	dfc00215 	stw	ra,8(sp)
 320ba48:	2023883a 	mov	r17,r4
 320ba4c:	2821883a 	mov	r16,r5
 320ba50:	18000226 	beq	r3,zero,320ba5c <__swsetup_r+0x30>
 320ba54:	18800e17 	ldw	r2,56(r3)
 320ba58:	10001f26 	beq	r2,zero,320bad8 <__swsetup_r+0xac>
 320ba5c:	8100030b 	ldhu	r4,12(r16)
 320ba60:	2080020c 	andi	r2,r4,8
 320ba64:	10002826 	beq	r2,zero,320bb08 <__swsetup_r+0xdc>
 320ba68:	81400417 	ldw	r5,16(r16)
 320ba6c:	28001d26 	beq	r5,zero,320bae4 <__swsetup_r+0xb8>
 320ba70:	2080004c 	andi	r2,r4,1
 320ba74:	1005003a 	cmpeq	r2,r2,zero
 320ba78:	10000b26 	beq	r2,zero,320baa8 <__swsetup_r+0x7c>
 320ba7c:	2080008c 	andi	r2,r4,2
 320ba80:	10001226 	beq	r2,zero,320bacc <__swsetup_r+0xa0>
 320ba84:	0005883a 	mov	r2,zero
 320ba88:	80800215 	stw	r2,8(r16)
 320ba8c:	28000b26 	beq	r5,zero,320babc <__swsetup_r+0x90>
 320ba90:	0005883a 	mov	r2,zero
 320ba94:	dfc00217 	ldw	ra,8(sp)
 320ba98:	dc400117 	ldw	r17,4(sp)
 320ba9c:	dc000017 	ldw	r16,0(sp)
 320baa0:	dec00304 	addi	sp,sp,12
 320baa4:	f800283a 	ret
 320baa8:	80800517 	ldw	r2,20(r16)
 320baac:	80000215 	stw	zero,8(r16)
 320bab0:	0085c83a 	sub	r2,zero,r2
 320bab4:	80800615 	stw	r2,24(r16)
 320bab8:	283ff51e 	bne	r5,zero,320ba90 <__swsetup_r+0x64>
 320babc:	2080200c 	andi	r2,r4,128
 320bac0:	103ff326 	beq	r2,zero,320ba90 <__swsetup_r+0x64>
 320bac4:	00bfffc4 	movi	r2,-1
 320bac8:	003ff206 	br	320ba94 <__swsetup_r+0x68>
 320bacc:	80800517 	ldw	r2,20(r16)
 320bad0:	80800215 	stw	r2,8(r16)
 320bad4:	003fed06 	br	320ba8c <__swsetup_r+0x60>
 320bad8:	1809883a 	mov	r4,r3
 320badc:	32048880 	call	3204888 <__sinit>
 320bae0:	003fde06 	br	320ba5c <__swsetup_r+0x30>
 320bae4:	20c0a00c 	andi	r3,r4,640
 320bae8:	00808004 	movi	r2,512
 320baec:	18bfe026 	beq	r3,r2,320ba70 <__swsetup_r+0x44>
 320baf0:	8809883a 	mov	r4,r17
 320baf4:	800b883a 	mov	r5,r16
 320baf8:	3205e140 	call	3205e14 <__smakebuf_r>
 320bafc:	8100030b 	ldhu	r4,12(r16)
 320bb00:	81400417 	ldw	r5,16(r16)
 320bb04:	003fda06 	br	320ba70 <__swsetup_r+0x44>
 320bb08:	2080040c 	andi	r2,r4,16
 320bb0c:	103fed26 	beq	r2,zero,320bac4 <__swsetup_r+0x98>
 320bb10:	2080010c 	andi	r2,r4,4
 320bb14:	10001226 	beq	r2,zero,320bb60 <__swsetup_r+0x134>
 320bb18:	81400c17 	ldw	r5,48(r16)
 320bb1c:	28000526 	beq	r5,zero,320bb34 <__swsetup_r+0x108>
 320bb20:	80801004 	addi	r2,r16,64
 320bb24:	28800226 	beq	r5,r2,320bb30 <__swsetup_r+0x104>
 320bb28:	8809883a 	mov	r4,r17
 320bb2c:	3204e0c0 	call	3204e0c <_free_r>
 320bb30:	80000c15 	stw	zero,48(r16)
 320bb34:	8080030b 	ldhu	r2,12(r16)
 320bb38:	81400417 	ldw	r5,16(r16)
 320bb3c:	80000115 	stw	zero,4(r16)
 320bb40:	10bff6cc 	andi	r2,r2,65499
 320bb44:	8080030d 	sth	r2,12(r16)
 320bb48:	81400015 	stw	r5,0(r16)
 320bb4c:	8080030b 	ldhu	r2,12(r16)
 320bb50:	10800214 	ori	r2,r2,8
 320bb54:	113fffcc 	andi	r4,r2,65535
 320bb58:	8080030d 	sth	r2,12(r16)
 320bb5c:	003fc306 	br	320ba6c <__swsetup_r+0x40>
 320bb60:	81400417 	ldw	r5,16(r16)
 320bb64:	003ff906 	br	320bb4c <__swsetup_r+0x120>

0320bb68 <_close_r>:
 320bb68:	defffd04 	addi	sp,sp,-12
 320bb6c:	dc000015 	stw	r16,0(sp)
 320bb70:	0400c974 	movhi	r16,805
 320bb74:	84120d04 	addi	r16,r16,18484
 320bb78:	dc400115 	stw	r17,4(sp)
 320bb7c:	80000015 	stw	zero,0(r16)
 320bb80:	2023883a 	mov	r17,r4
 320bb84:	2809883a 	mov	r4,r5
 320bb88:	dfc00215 	stw	ra,8(sp)
 320bb8c:	32227dc0 	call	32227dc <close>
 320bb90:	1007883a 	mov	r3,r2
 320bb94:	00bfffc4 	movi	r2,-1
 320bb98:	18800626 	beq	r3,r2,320bbb4 <_close_r+0x4c>
 320bb9c:	1805883a 	mov	r2,r3
 320bba0:	dfc00217 	ldw	ra,8(sp)
 320bba4:	dc400117 	ldw	r17,4(sp)
 320bba8:	dc000017 	ldw	r16,0(sp)
 320bbac:	dec00304 	addi	sp,sp,12
 320bbb0:	f800283a 	ret
 320bbb4:	80800017 	ldw	r2,0(r16)
 320bbb8:	103ff826 	beq	r2,zero,320bb9c <_close_r+0x34>
 320bbbc:	88800015 	stw	r2,0(r17)
 320bbc0:	1805883a 	mov	r2,r3
 320bbc4:	dfc00217 	ldw	ra,8(sp)
 320bbc8:	dc400117 	ldw	r17,4(sp)
 320bbcc:	dc000017 	ldw	r16,0(sp)
 320bbd0:	dec00304 	addi	sp,sp,12
 320bbd4:	f800283a 	ret

0320bbd8 <quorem>:
 320bbd8:	28c00417 	ldw	r3,16(r5)
 320bbdc:	20800417 	ldw	r2,16(r4)
 320bbe0:	defff604 	addi	sp,sp,-40
 320bbe4:	ddc00715 	stw	r23,28(sp)
 320bbe8:	dd400515 	stw	r21,20(sp)
 320bbec:	dfc00915 	stw	ra,36(sp)
 320bbf0:	df000815 	stw	fp,32(sp)
 320bbf4:	dd800615 	stw	r22,24(sp)
 320bbf8:	dd000415 	stw	r20,16(sp)
 320bbfc:	dcc00315 	stw	r19,12(sp)
 320bc00:	dc800215 	stw	r18,8(sp)
 320bc04:	dc400115 	stw	r17,4(sp)
 320bc08:	dc000015 	stw	r16,0(sp)
 320bc0c:	202f883a 	mov	r23,r4
 320bc10:	282b883a 	mov	r21,r5
 320bc14:	10c07416 	blt	r2,r3,320bde8 <quorem+0x210>
 320bc18:	1c7fffc4 	addi	r17,r3,-1
 320bc1c:	8c45883a 	add	r2,r17,r17
 320bc20:	1085883a 	add	r2,r2,r2
 320bc24:	2c000504 	addi	r16,r5,20
 320bc28:	24c00504 	addi	r19,r4,20
 320bc2c:	14ed883a 	add	r22,r2,r19
 320bc30:	80a5883a 	add	r18,r16,r2
 320bc34:	b7000017 	ldw	fp,0(r22)
 320bc38:	91400017 	ldw	r5,0(r18)
 320bc3c:	e009883a 	mov	r4,fp
 320bc40:	29400044 	addi	r5,r5,1
 320bc44:	32044bc0 	call	32044bc <__udivsi3>
 320bc48:	1029883a 	mov	r20,r2
 320bc4c:	10003c1e 	bne	r2,zero,320bd40 <quorem+0x168>
 320bc50:	a80b883a 	mov	r5,r21
 320bc54:	b809883a 	mov	r4,r23
 320bc58:	320db700 	call	320db70 <__mcmp>
 320bc5c:	10002b16 	blt	r2,zero,320bd0c <quorem+0x134>
 320bc60:	a5000044 	addi	r20,r20,1
 320bc64:	980f883a 	mov	r7,r19
 320bc68:	0011883a 	mov	r8,zero
 320bc6c:	0009883a 	mov	r4,zero
 320bc70:	81400017 	ldw	r5,0(r16)
 320bc74:	38c00017 	ldw	r3,0(r7)
 320bc78:	84000104 	addi	r16,r16,4
 320bc7c:	28bfffcc 	andi	r2,r5,65535
 320bc80:	2085883a 	add	r2,r4,r2
 320bc84:	11bfffcc 	andi	r6,r2,65535
 320bc88:	193fffcc 	andi	r4,r3,65535
 320bc8c:	1004d43a 	srli	r2,r2,16
 320bc90:	280ad43a 	srli	r5,r5,16
 320bc94:	2189c83a 	sub	r4,r4,r6
 320bc98:	2209883a 	add	r4,r4,r8
 320bc9c:	1806d43a 	srli	r3,r3,16
 320bca0:	288b883a 	add	r5,r5,r2
 320bca4:	200dd43a 	srai	r6,r4,16
 320bca8:	28bfffcc 	andi	r2,r5,65535
 320bcac:	1887c83a 	sub	r3,r3,r2
 320bcb0:	1987883a 	add	r3,r3,r6
 320bcb4:	3900000d 	sth	r4,0(r7)
 320bcb8:	38c0008d 	sth	r3,2(r7)
 320bcbc:	2808d43a 	srli	r4,r5,16
 320bcc0:	39c00104 	addi	r7,r7,4
 320bcc4:	1811d43a 	srai	r8,r3,16
 320bcc8:	943fe92e 	bgeu	r18,r16,320bc70 <quorem+0x98>
 320bccc:	8c45883a 	add	r2,r17,r17
 320bcd0:	1085883a 	add	r2,r2,r2
 320bcd4:	9885883a 	add	r2,r19,r2
 320bcd8:	10c00017 	ldw	r3,0(r2)
 320bcdc:	18000b1e 	bne	r3,zero,320bd0c <quorem+0x134>
 320bce0:	113fff04 	addi	r4,r2,-4
 320bce4:	9900082e 	bgeu	r19,r4,320bd08 <quorem+0x130>
 320bce8:	10bfff17 	ldw	r2,-4(r2)
 320bcec:	10000326 	beq	r2,zero,320bcfc <quorem+0x124>
 320bcf0:	00000506 	br	320bd08 <quorem+0x130>
 320bcf4:	20800017 	ldw	r2,0(r4)
 320bcf8:	1000031e 	bne	r2,zero,320bd08 <quorem+0x130>
 320bcfc:	213fff04 	addi	r4,r4,-4
 320bd00:	8c7fffc4 	addi	r17,r17,-1
 320bd04:	993ffb36 	bltu	r19,r4,320bcf4 <quorem+0x11c>
 320bd08:	bc400415 	stw	r17,16(r23)
 320bd0c:	a005883a 	mov	r2,r20
 320bd10:	dfc00917 	ldw	ra,36(sp)
 320bd14:	df000817 	ldw	fp,32(sp)
 320bd18:	ddc00717 	ldw	r23,28(sp)
 320bd1c:	dd800617 	ldw	r22,24(sp)
 320bd20:	dd400517 	ldw	r21,20(sp)
 320bd24:	dd000417 	ldw	r20,16(sp)
 320bd28:	dcc00317 	ldw	r19,12(sp)
 320bd2c:	dc800217 	ldw	r18,8(sp)
 320bd30:	dc400117 	ldw	r17,4(sp)
 320bd34:	dc000017 	ldw	r16,0(sp)
 320bd38:	dec00a04 	addi	sp,sp,40
 320bd3c:	f800283a 	ret
 320bd40:	980f883a 	mov	r7,r19
 320bd44:	8011883a 	mov	r8,r16
 320bd48:	0013883a 	mov	r9,zero
 320bd4c:	000d883a 	mov	r6,zero
 320bd50:	40c00017 	ldw	r3,0(r8)
 320bd54:	39000017 	ldw	r4,0(r7)
 320bd58:	42000104 	addi	r8,r8,4
 320bd5c:	18bfffcc 	andi	r2,r3,65535
 320bd60:	a085383a 	mul	r2,r20,r2
 320bd64:	1806d43a 	srli	r3,r3,16
 320bd68:	217fffcc 	andi	r5,r4,65535
 320bd6c:	3085883a 	add	r2,r6,r2
 320bd70:	11bfffcc 	andi	r6,r2,65535
 320bd74:	a0c7383a 	mul	r3,r20,r3
 320bd78:	1004d43a 	srli	r2,r2,16
 320bd7c:	298bc83a 	sub	r5,r5,r6
 320bd80:	2a4b883a 	add	r5,r5,r9
 320bd84:	2008d43a 	srli	r4,r4,16
 320bd88:	1887883a 	add	r3,r3,r2
 320bd8c:	280dd43a 	srai	r6,r5,16
 320bd90:	18bfffcc 	andi	r2,r3,65535
 320bd94:	2089c83a 	sub	r4,r4,r2
 320bd98:	2189883a 	add	r4,r4,r6
 320bd9c:	3900008d 	sth	r4,2(r7)
 320bda0:	3940000d 	sth	r5,0(r7)
 320bda4:	180cd43a 	srli	r6,r3,16
 320bda8:	39c00104 	addi	r7,r7,4
 320bdac:	2013d43a 	srai	r9,r4,16
 320bdb0:	923fe72e 	bgeu	r18,r8,320bd50 <quorem+0x178>
 320bdb4:	e03fa61e 	bne	fp,zero,320bc50 <quorem+0x78>
 320bdb8:	b0ffff04 	addi	r3,r22,-4
 320bdbc:	98c0082e 	bgeu	r19,r3,320bde0 <quorem+0x208>
 320bdc0:	b0bfff17 	ldw	r2,-4(r22)
 320bdc4:	10000326 	beq	r2,zero,320bdd4 <quorem+0x1fc>
 320bdc8:	00000506 	br	320bde0 <quorem+0x208>
 320bdcc:	18800017 	ldw	r2,0(r3)
 320bdd0:	1000031e 	bne	r2,zero,320bde0 <quorem+0x208>
 320bdd4:	18ffff04 	addi	r3,r3,-4
 320bdd8:	8c7fffc4 	addi	r17,r17,-1
 320bddc:	98fffb36 	bltu	r19,r3,320bdcc <quorem+0x1f4>
 320bde0:	bc400415 	stw	r17,16(r23)
 320bde4:	003f9a06 	br	320bc50 <quorem+0x78>
 320bde8:	0005883a 	mov	r2,zero
 320bdec:	003fc806 	br	320bd10 <quorem+0x138>

0320bdf0 <_dtoa_r>:
 320bdf0:	22001017 	ldw	r8,64(r4)
 320bdf4:	deffda04 	addi	sp,sp,-152
 320bdf8:	dd402115 	stw	r21,132(sp)
 320bdfc:	dd002015 	stw	r20,128(sp)
 320be00:	dc801e15 	stw	r18,120(sp)
 320be04:	dc401d15 	stw	r17,116(sp)
 320be08:	dfc02515 	stw	ra,148(sp)
 320be0c:	df002415 	stw	fp,144(sp)
 320be10:	ddc02315 	stw	r23,140(sp)
 320be14:	dd802215 	stw	r22,136(sp)
 320be18:	dcc01f15 	stw	r19,124(sp)
 320be1c:	dc001c15 	stw	r16,112(sp)
 320be20:	d9001615 	stw	r4,88(sp)
 320be24:	3023883a 	mov	r17,r6
 320be28:	2829883a 	mov	r20,r5
 320be2c:	d9c01715 	stw	r7,92(sp)
 320be30:	dc802817 	ldw	r18,160(sp)
 320be34:	302b883a 	mov	r21,r6
 320be38:	40000a26 	beq	r8,zero,320be64 <_dtoa_r+0x74>
 320be3c:	20801117 	ldw	r2,68(r4)
 320be40:	400b883a 	mov	r5,r8
 320be44:	40800115 	stw	r2,4(r8)
 320be48:	20c01117 	ldw	r3,68(r4)
 320be4c:	00800044 	movi	r2,1
 320be50:	10c4983a 	sll	r2,r2,r3
 320be54:	40800215 	stw	r2,8(r8)
 320be58:	320da140 	call	320da14 <_Bfree>
 320be5c:	d8c01617 	ldw	r3,88(sp)
 320be60:	18001015 	stw	zero,64(r3)
 320be64:	8800a316 	blt	r17,zero,320c0f4 <_dtoa_r+0x304>
 320be68:	90000015 	stw	zero,0(r18)
 320be6c:	a8dffc2c 	andhi	r3,r21,32752
 320be70:	009ffc34 	movhi	r2,32752
 320be74:	18809126 	beq	r3,r2,320c0bc <_dtoa_r+0x2cc>
 320be78:	000d883a 	mov	r6,zero
 320be7c:	000f883a 	mov	r7,zero
 320be80:	a009883a 	mov	r4,r20
 320be84:	a80b883a 	mov	r5,r21
 320be88:	dd001215 	stw	r20,72(sp)
 320be8c:	dd401315 	stw	r21,76(sp)
 320be90:	321364c0 	call	321364c <__nedf2>
 320be94:	1000171e 	bne	r2,zero,320bef4 <_dtoa_r+0x104>
 320be98:	d9802717 	ldw	r6,156(sp)
 320be9c:	00800044 	movi	r2,1
 320bea0:	30800015 	stw	r2,0(r6)
 320bea4:	d8802917 	ldw	r2,164(sp)
 320bea8:	10029b26 	beq	r2,zero,320c918 <_dtoa_r+0xb28>
 320beac:	d9002917 	ldw	r4,164(sp)
 320beb0:	0080c974 	movhi	r2,805
 320beb4:	10b7c144 	addi	r2,r2,-8443
 320beb8:	10ffffc4 	addi	r3,r2,-1
 320bebc:	20800015 	stw	r2,0(r4)
 320bec0:	1805883a 	mov	r2,r3
 320bec4:	dfc02517 	ldw	ra,148(sp)
 320bec8:	df002417 	ldw	fp,144(sp)
 320becc:	ddc02317 	ldw	r23,140(sp)
 320bed0:	dd802217 	ldw	r22,136(sp)
 320bed4:	dd402117 	ldw	r21,132(sp)
 320bed8:	dd002017 	ldw	r20,128(sp)
 320bedc:	dcc01f17 	ldw	r19,124(sp)
 320bee0:	dc801e17 	ldw	r18,120(sp)
 320bee4:	dc401d17 	ldw	r17,116(sp)
 320bee8:	dc001c17 	ldw	r16,112(sp)
 320beec:	dec02604 	addi	sp,sp,152
 320bef0:	f800283a 	ret
 320bef4:	d9001617 	ldw	r4,88(sp)
 320bef8:	d9401217 	ldw	r5,72(sp)
 320befc:	d8800104 	addi	r2,sp,4
 320bf00:	a80d883a 	mov	r6,r21
 320bf04:	d9c00204 	addi	r7,sp,8
 320bf08:	d8800015 	stw	r2,0(sp)
 320bf0c:	320e0500 	call	320e050 <__d2b>
 320bf10:	d8800715 	stw	r2,28(sp)
 320bf14:	a804d53a 	srli	r2,r21,20
 320bf18:	1101ffcc 	andi	r4,r2,2047
 320bf1c:	20008626 	beq	r4,zero,320c138 <_dtoa_r+0x348>
 320bf20:	d8c01217 	ldw	r3,72(sp)
 320bf24:	00800434 	movhi	r2,16
 320bf28:	10bfffc4 	addi	r2,r2,-1
 320bf2c:	ddc00117 	ldw	r23,4(sp)
 320bf30:	a884703a 	and	r2,r21,r2
 320bf34:	1811883a 	mov	r8,r3
 320bf38:	124ffc34 	orhi	r9,r2,16368
 320bf3c:	25bf0044 	addi	r22,r4,-1023
 320bf40:	d8000815 	stw	zero,32(sp)
 320bf44:	0005883a 	mov	r2,zero
 320bf48:	00cffe34 	movhi	r3,16376
 320bf4c:	480b883a 	mov	r5,r9
 320bf50:	4009883a 	mov	r4,r8
 320bf54:	180f883a 	mov	r7,r3
 320bf58:	100d883a 	mov	r6,r2
 320bf5c:	3212eb40 	call	3212eb4 <__subdf3>
 320bf60:	0218dbf4 	movhi	r8,25455
 320bf64:	4210d844 	addi	r8,r8,17249
 320bf68:	024ff4f4 	movhi	r9,16339
 320bf6c:	4a61e9c4 	addi	r9,r9,-30809
 320bf70:	480f883a 	mov	r7,r9
 320bf74:	400d883a 	mov	r6,r8
 320bf78:	180b883a 	mov	r5,r3
 320bf7c:	1009883a 	mov	r4,r2
 320bf80:	3212fa80 	call	3212fa8 <__muldf3>
 320bf84:	0222d874 	movhi	r8,35681
 320bf88:	42322cc4 	addi	r8,r8,-14157
 320bf8c:	024ff1f4 	movhi	r9,16327
 320bf90:	4a628a04 	addi	r9,r9,-30168
 320bf94:	480f883a 	mov	r7,r9
 320bf98:	400d883a 	mov	r6,r8
 320bf9c:	180b883a 	mov	r5,r3
 320bfa0:	1009883a 	mov	r4,r2
 320bfa4:	3212f340 	call	3212f34 <__adddf3>
 320bfa8:	b009883a 	mov	r4,r22
 320bfac:	1021883a 	mov	r16,r2
 320bfb0:	1823883a 	mov	r17,r3
 320bfb4:	32138f40 	call	32138f4 <__floatsidf>
 320bfb8:	021427f4 	movhi	r8,20639
 320bfbc:	421e7ec4 	addi	r8,r8,31227
 320bfc0:	024ff4f4 	movhi	r9,16339
 320bfc4:	4a5104c4 	addi	r9,r9,17427
 320bfc8:	480f883a 	mov	r7,r9
 320bfcc:	400d883a 	mov	r6,r8
 320bfd0:	180b883a 	mov	r5,r3
 320bfd4:	1009883a 	mov	r4,r2
 320bfd8:	3212fa80 	call	3212fa8 <__muldf3>
 320bfdc:	180f883a 	mov	r7,r3
 320bfe0:	880b883a 	mov	r5,r17
 320bfe4:	100d883a 	mov	r6,r2
 320bfe8:	8009883a 	mov	r4,r16
 320bfec:	3212f340 	call	3212f34 <__adddf3>
 320bff0:	1009883a 	mov	r4,r2
 320bff4:	180b883a 	mov	r5,r3
 320bff8:	1021883a 	mov	r16,r2
 320bffc:	1823883a 	mov	r17,r3
 320c000:	32139ec0 	call	32139ec <__fixdfsi>
 320c004:	000d883a 	mov	r6,zero
 320c008:	000f883a 	mov	r7,zero
 320c00c:	8009883a 	mov	r4,r16
 320c010:	880b883a 	mov	r5,r17
 320c014:	d8800d15 	stw	r2,52(sp)
 320c018:	32137e40 	call	32137e4 <__ltdf2>
 320c01c:	10031716 	blt	r2,zero,320cc7c <_dtoa_r+0xe8c>
 320c020:	d8c00d17 	ldw	r3,52(sp)
 320c024:	00800584 	movi	r2,22
 320c028:	10c1482e 	bgeu	r2,r3,320c54c <_dtoa_r+0x75c>
 320c02c:	01000044 	movi	r4,1
 320c030:	d9000c15 	stw	r4,48(sp)
 320c034:	bd85c83a 	sub	r2,r23,r22
 320c038:	11bfffc4 	addi	r6,r2,-1
 320c03c:	30030b16 	blt	r6,zero,320cc6c <_dtoa_r+0xe7c>
 320c040:	d9800a15 	stw	r6,40(sp)
 320c044:	d8001115 	stw	zero,68(sp)
 320c048:	d8c00d17 	ldw	r3,52(sp)
 320c04c:	1802ff16 	blt	r3,zero,320cc4c <_dtoa_r+0xe5c>
 320c050:	d9000a17 	ldw	r4,40(sp)
 320c054:	d8c00915 	stw	r3,36(sp)
 320c058:	d8001015 	stw	zero,64(sp)
 320c05c:	20c9883a 	add	r4,r4,r3
 320c060:	d9000a15 	stw	r4,40(sp)
 320c064:	d9001717 	ldw	r4,92(sp)
 320c068:	00800244 	movi	r2,9
 320c06c:	11004636 	bltu	r2,r4,320c188 <_dtoa_r+0x398>
 320c070:	00800144 	movi	r2,5
 320c074:	11020416 	blt	r2,r4,320c888 <_dtoa_r+0xa98>
 320c078:	04400044 	movi	r17,1
 320c07c:	d8c01717 	ldw	r3,92(sp)
 320c080:	00800144 	movi	r2,5
 320c084:	10c1ed36 	bltu	r2,r3,320c83c <_dtoa_r+0xa4c>
 320c088:	18c5883a 	add	r2,r3,r3
 320c08c:	1085883a 	add	r2,r2,r2
 320c090:	00c0c874 	movhi	r3,801
 320c094:	18f02904 	addi	r3,r3,-16220
 320c098:	10c5883a 	add	r2,r2,r3
 320c09c:	11000017 	ldw	r4,0(r2)
 320c0a0:	2000683a 	jmp	r4
 320c0a4:	0320c190 	cmplti	r12,zero,-31994
 320c0a8:	0320c190 	cmplti	r12,zero,-31994
 320c0ac:	0320cb90 	cmplti	r12,zero,-31954
 320c0b0:	0320cb68 	cmpgeui	r12,zero,33581
 320c0b4:	0320cbac 	andhi	r12,zero,33582
 320c0b8:	0320cbb8 	rdprs	r12,zero,-31954
 320c0bc:	d9002717 	ldw	r4,156(sp)
 320c0c0:	0089c3c4 	movi	r2,9999
 320c0c4:	20800015 	stw	r2,0(r4)
 320c0c8:	a0001026 	beq	r20,zero,320c10c <_dtoa_r+0x31c>
 320c0cc:	00c0c974 	movhi	r3,805
 320c0d0:	18f7d704 	addi	r3,r3,-8356
 320c0d4:	d9802917 	ldw	r6,164(sp)
 320c0d8:	303f7926 	beq	r6,zero,320bec0 <_dtoa_r+0xd0>
 320c0dc:	188000c7 	ldb	r2,3(r3)
 320c0e0:	190000c4 	addi	r4,r3,3
 320c0e4:	1000101e 	bne	r2,zero,320c128 <_dtoa_r+0x338>
 320c0e8:	d8802917 	ldw	r2,164(sp)
 320c0ec:	11000015 	stw	r4,0(r2)
 320c0f0:	003f7306 	br	320bec0 <_dtoa_r+0xd0>
 320c0f4:	00a00034 	movhi	r2,32768
 320c0f8:	10bfffc4 	addi	r2,r2,-1
 320c0fc:	00c00044 	movi	r3,1
 320c100:	88aa703a 	and	r21,r17,r2
 320c104:	90c00015 	stw	r3,0(r18)
 320c108:	003f5806 	br	320be6c <_dtoa_r+0x7c>
 320c10c:	00800434 	movhi	r2,16
 320c110:	10bfffc4 	addi	r2,r2,-1
 320c114:	a884703a 	and	r2,r21,r2
 320c118:	103fec1e 	bne	r2,zero,320c0cc <_dtoa_r+0x2dc>
 320c11c:	00c0c974 	movhi	r3,805
 320c120:	18f7d404 	addi	r3,r3,-8368
 320c124:	003feb06 	br	320c0d4 <_dtoa_r+0x2e4>
 320c128:	d8802917 	ldw	r2,164(sp)
 320c12c:	19000204 	addi	r4,r3,8
 320c130:	11000015 	stw	r4,0(r2)
 320c134:	003f6206 	br	320bec0 <_dtoa_r+0xd0>
 320c138:	ddc00117 	ldw	r23,4(sp)
 320c13c:	d8800217 	ldw	r2,8(sp)
 320c140:	01000804 	movi	r4,32
 320c144:	b8c10c84 	addi	r3,r23,1074
 320c148:	18a3883a 	add	r17,r3,r2
 320c14c:	2441b80e 	bge	r4,r17,320c830 <_dtoa_r+0xa40>
 320c150:	00c01004 	movi	r3,64
 320c154:	1c47c83a 	sub	r3,r3,r17
 320c158:	88bff804 	addi	r2,r17,-32
 320c15c:	a8c6983a 	sll	r3,r21,r3
 320c160:	a084d83a 	srl	r2,r20,r2
 320c164:	1888b03a 	or	r4,r3,r2
 320c168:	3213b380 	call	3213b38 <__floatunsidf>
 320c16c:	1011883a 	mov	r8,r2
 320c170:	00bf8434 	movhi	r2,65040
 320c174:	01000044 	movi	r4,1
 320c178:	10d3883a 	add	r9,r2,r3
 320c17c:	8dbef344 	addi	r22,r17,-1075
 320c180:	d9000815 	stw	r4,32(sp)
 320c184:	003f6f06 	br	320bf44 <_dtoa_r+0x154>
 320c188:	d8001715 	stw	zero,92(sp)
 320c18c:	04400044 	movi	r17,1
 320c190:	00bfffc4 	movi	r2,-1
 320c194:	00c00044 	movi	r3,1
 320c198:	d8800e15 	stw	r2,56(sp)
 320c19c:	d8002615 	stw	zero,152(sp)
 320c1a0:	d8800f15 	stw	r2,60(sp)
 320c1a4:	d8c00b15 	stw	r3,44(sp)
 320c1a8:	1021883a 	mov	r16,r2
 320c1ac:	d8801617 	ldw	r2,88(sp)
 320c1b0:	10001115 	stw	zero,68(r2)
 320c1b4:	d8801617 	ldw	r2,88(sp)
 320c1b8:	11401117 	ldw	r5,68(r2)
 320c1bc:	1009883a 	mov	r4,r2
 320c1c0:	320df940 	call	320df94 <_Balloc>
 320c1c4:	d8c01617 	ldw	r3,88(sp)
 320c1c8:	d8800515 	stw	r2,20(sp)
 320c1cc:	18801015 	stw	r2,64(r3)
 320c1d0:	00800384 	movi	r2,14
 320c1d4:	14006836 	bltu	r2,r16,320c378 <_dtoa_r+0x588>
 320c1d8:	8805003a 	cmpeq	r2,r17,zero
 320c1dc:	1000661e 	bne	r2,zero,320c378 <_dtoa_r+0x588>
 320c1e0:	d9000d17 	ldw	r4,52(sp)
 320c1e4:	0102300e 	bge	zero,r4,320caa8 <_dtoa_r+0xcb8>
 320c1e8:	208003cc 	andi	r2,r4,15
 320c1ec:	100490fa 	slli	r2,r2,3
 320c1f0:	2025d13a 	srai	r18,r4,4
 320c1f4:	00c0c974 	movhi	r3,805
 320c1f8:	18f7e804 	addi	r3,r3,-8288
 320c1fc:	10c5883a 	add	r2,r2,r3
 320c200:	90c0040c 	andi	r3,r18,16
 320c204:	14000017 	ldw	r16,0(r2)
 320c208:	14400117 	ldw	r17,4(r2)
 320c20c:	18036a1e 	bne	r3,zero,320cfb8 <_dtoa_r+0x11c8>
 320c210:	05800084 	movi	r22,2
 320c214:	90001026 	beq	r18,zero,320c258 <_dtoa_r+0x468>
 320c218:	04c0c974 	movhi	r19,805
 320c21c:	9cf81a04 	addi	r19,r19,-8088
 320c220:	9080004c 	andi	r2,r18,1
 320c224:	1005003a 	cmpeq	r2,r2,zero
 320c228:	1000081e 	bne	r2,zero,320c24c <_dtoa_r+0x45c>
 320c22c:	99800017 	ldw	r6,0(r19)
 320c230:	99c00117 	ldw	r7,4(r19)
 320c234:	880b883a 	mov	r5,r17
 320c238:	8009883a 	mov	r4,r16
 320c23c:	3212fa80 	call	3212fa8 <__muldf3>
 320c240:	1021883a 	mov	r16,r2
 320c244:	b5800044 	addi	r22,r22,1
 320c248:	1823883a 	mov	r17,r3
 320c24c:	9025d07a 	srai	r18,r18,1
 320c250:	9cc00204 	addi	r19,r19,8
 320c254:	903ff21e 	bne	r18,zero,320c220 <_dtoa_r+0x430>
 320c258:	a80b883a 	mov	r5,r21
 320c25c:	a009883a 	mov	r4,r20
 320c260:	880f883a 	mov	r7,r17
 320c264:	800d883a 	mov	r6,r16
 320c268:	321336c0 	call	321336c <__divdf3>
 320c26c:	1029883a 	mov	r20,r2
 320c270:	182b883a 	mov	r21,r3
 320c274:	d8c00c17 	ldw	r3,48(sp)
 320c278:	1805003a 	cmpeq	r2,r3,zero
 320c27c:	1000081e 	bne	r2,zero,320c2a0 <_dtoa_r+0x4b0>
 320c280:	0005883a 	mov	r2,zero
 320c284:	00cffc34 	movhi	r3,16368
 320c288:	180f883a 	mov	r7,r3
 320c28c:	a009883a 	mov	r4,r20
 320c290:	a80b883a 	mov	r5,r21
 320c294:	100d883a 	mov	r6,r2
 320c298:	32137e40 	call	32137e4 <__ltdf2>
 320c29c:	1003fe16 	blt	r2,zero,320d298 <_dtoa_r+0x14a8>
 320c2a0:	b009883a 	mov	r4,r22
 320c2a4:	32138f40 	call	32138f4 <__floatsidf>
 320c2a8:	180b883a 	mov	r5,r3
 320c2ac:	1009883a 	mov	r4,r2
 320c2b0:	a00d883a 	mov	r6,r20
 320c2b4:	a80f883a 	mov	r7,r21
 320c2b8:	3212fa80 	call	3212fa8 <__muldf3>
 320c2bc:	0011883a 	mov	r8,zero
 320c2c0:	02500734 	movhi	r9,16412
 320c2c4:	1009883a 	mov	r4,r2
 320c2c8:	180b883a 	mov	r5,r3
 320c2cc:	480f883a 	mov	r7,r9
 320c2d0:	400d883a 	mov	r6,r8
 320c2d4:	3212f340 	call	3212f34 <__adddf3>
 320c2d8:	d9000f17 	ldw	r4,60(sp)
 320c2dc:	102d883a 	mov	r22,r2
 320c2e0:	00bf3034 	movhi	r2,64704
 320c2e4:	18b9883a 	add	fp,r3,r2
 320c2e8:	e02f883a 	mov	r23,fp
 320c2ec:	20028f1e 	bne	r4,zero,320cd2c <_dtoa_r+0xf3c>
 320c2f0:	0005883a 	mov	r2,zero
 320c2f4:	00d00534 	movhi	r3,16404
 320c2f8:	a009883a 	mov	r4,r20
 320c2fc:	a80b883a 	mov	r5,r21
 320c300:	180f883a 	mov	r7,r3
 320c304:	100d883a 	mov	r6,r2
 320c308:	3212eb40 	call	3212eb4 <__subdf3>
 320c30c:	1009883a 	mov	r4,r2
 320c310:	e00f883a 	mov	r7,fp
 320c314:	180b883a 	mov	r5,r3
 320c318:	b00d883a 	mov	r6,r22
 320c31c:	1025883a 	mov	r18,r2
 320c320:	1827883a 	mov	r19,r3
 320c324:	32136d40 	call	32136d4 <__gtdf2>
 320c328:	00834f16 	blt	zero,r2,320d068 <_dtoa_r+0x1278>
 320c32c:	e0e0003c 	xorhi	r3,fp,32768
 320c330:	9009883a 	mov	r4,r18
 320c334:	980b883a 	mov	r5,r19
 320c338:	180f883a 	mov	r7,r3
 320c33c:	b00d883a 	mov	r6,r22
 320c340:	32137e40 	call	32137e4 <__ltdf2>
 320c344:	1000080e 	bge	r2,zero,320c368 <_dtoa_r+0x578>
 320c348:	0027883a 	mov	r19,zero
 320c34c:	0025883a 	mov	r18,zero
 320c350:	d8802617 	ldw	r2,152(sp)
 320c354:	df000517 	ldw	fp,20(sp)
 320c358:	d8000615 	stw	zero,24(sp)
 320c35c:	0084303a 	nor	r2,zero,r2
 320c360:	d8800d15 	stw	r2,52(sp)
 320c364:	00019b06 	br	320c9d4 <_dtoa_r+0xbe4>
 320c368:	d9801217 	ldw	r6,72(sp)
 320c36c:	d8801317 	ldw	r2,76(sp)
 320c370:	3029883a 	mov	r20,r6
 320c374:	102b883a 	mov	r21,r2
 320c378:	d8c00217 	ldw	r3,8(sp)
 320c37c:	18008516 	blt	r3,zero,320c594 <_dtoa_r+0x7a4>
 320c380:	d9000d17 	ldw	r4,52(sp)
 320c384:	00800384 	movi	r2,14
 320c388:	11008216 	blt	r2,r4,320c594 <_dtoa_r+0x7a4>
 320c38c:	200490fa 	slli	r2,r4,3
 320c390:	d9802617 	ldw	r6,152(sp)
 320c394:	00c0c974 	movhi	r3,805
 320c398:	18f7e804 	addi	r3,r3,-8288
 320c39c:	10c5883a 	add	r2,r2,r3
 320c3a0:	14800017 	ldw	r18,0(r2)
 320c3a4:	14c00117 	ldw	r19,4(r2)
 320c3a8:	30031e16 	blt	r6,zero,320d024 <_dtoa_r+0x1234>
 320c3ac:	d9000517 	ldw	r4,20(sp)
 320c3b0:	d8c00f17 	ldw	r3,60(sp)
 320c3b4:	a823883a 	mov	r17,r21
 320c3b8:	a021883a 	mov	r16,r20
 320c3bc:	192b883a 	add	r21,r3,r4
 320c3c0:	2039883a 	mov	fp,r4
 320c3c4:	00000f06 	br	320c404 <_dtoa_r+0x614>
 320c3c8:	0005883a 	mov	r2,zero
 320c3cc:	00d00934 	movhi	r3,16420
 320c3d0:	5009883a 	mov	r4,r10
 320c3d4:	580b883a 	mov	r5,r11
 320c3d8:	180f883a 	mov	r7,r3
 320c3dc:	100d883a 	mov	r6,r2
 320c3e0:	3212fa80 	call	3212fa8 <__muldf3>
 320c3e4:	180b883a 	mov	r5,r3
 320c3e8:	000d883a 	mov	r6,zero
 320c3ec:	000f883a 	mov	r7,zero
 320c3f0:	1009883a 	mov	r4,r2
 320c3f4:	1021883a 	mov	r16,r2
 320c3f8:	1823883a 	mov	r17,r3
 320c3fc:	321364c0 	call	321364c <__nedf2>
 320c400:	10004526 	beq	r2,zero,320c518 <_dtoa_r+0x728>
 320c404:	900d883a 	mov	r6,r18
 320c408:	980f883a 	mov	r7,r19
 320c40c:	8009883a 	mov	r4,r16
 320c410:	880b883a 	mov	r5,r17
 320c414:	321336c0 	call	321336c <__divdf3>
 320c418:	180b883a 	mov	r5,r3
 320c41c:	1009883a 	mov	r4,r2
 320c420:	32139ec0 	call	32139ec <__fixdfsi>
 320c424:	1009883a 	mov	r4,r2
 320c428:	1029883a 	mov	r20,r2
 320c42c:	32138f40 	call	32138f4 <__floatsidf>
 320c430:	180f883a 	mov	r7,r3
 320c434:	9009883a 	mov	r4,r18
 320c438:	980b883a 	mov	r5,r19
 320c43c:	100d883a 	mov	r6,r2
 320c440:	3212fa80 	call	3212fa8 <__muldf3>
 320c444:	180f883a 	mov	r7,r3
 320c448:	880b883a 	mov	r5,r17
 320c44c:	8009883a 	mov	r4,r16
 320c450:	100d883a 	mov	r6,r2
 320c454:	3212eb40 	call	3212eb4 <__subdf3>
 320c458:	1015883a 	mov	r10,r2
 320c45c:	a0800c04 	addi	r2,r20,48
 320c460:	e0800005 	stb	r2,0(fp)
 320c464:	e7000044 	addi	fp,fp,1
 320c468:	1817883a 	mov	r11,r3
 320c46c:	e57fd61e 	bne	fp,r21,320c3c8 <_dtoa_r+0x5d8>
 320c470:	500d883a 	mov	r6,r10
 320c474:	180f883a 	mov	r7,r3
 320c478:	5009883a 	mov	r4,r10
 320c47c:	180b883a 	mov	r5,r3
 320c480:	3212f340 	call	3212f34 <__adddf3>
 320c484:	100d883a 	mov	r6,r2
 320c488:	9009883a 	mov	r4,r18
 320c48c:	980b883a 	mov	r5,r19
 320c490:	180f883a 	mov	r7,r3
 320c494:	1021883a 	mov	r16,r2
 320c498:	1823883a 	mov	r17,r3
 320c49c:	32137e40 	call	32137e4 <__ltdf2>
 320c4a0:	10000816 	blt	r2,zero,320c4c4 <_dtoa_r+0x6d4>
 320c4a4:	980b883a 	mov	r5,r19
 320c4a8:	800d883a 	mov	r6,r16
 320c4ac:	880f883a 	mov	r7,r17
 320c4b0:	9009883a 	mov	r4,r18
 320c4b4:	32135c40 	call	32135c4 <__eqdf2>
 320c4b8:	1000171e 	bne	r2,zero,320c518 <_dtoa_r+0x728>
 320c4bc:	a080004c 	andi	r2,r20,1
 320c4c0:	10001526 	beq	r2,zero,320c518 <_dtoa_r+0x728>
 320c4c4:	d8800d17 	ldw	r2,52(sp)
 320c4c8:	d8800415 	stw	r2,16(sp)
 320c4cc:	e009883a 	mov	r4,fp
 320c4d0:	213fffc4 	addi	r4,r4,-1
 320c4d4:	20c00007 	ldb	r3,0(r4)
 320c4d8:	00800e44 	movi	r2,57
 320c4dc:	1880081e 	bne	r3,r2,320c500 <_dtoa_r+0x710>
 320c4e0:	d8800517 	ldw	r2,20(sp)
 320c4e4:	113ffa1e 	bne	r2,r4,320c4d0 <_dtoa_r+0x6e0>
 320c4e8:	d8c00417 	ldw	r3,16(sp)
 320c4ec:	d9800517 	ldw	r6,20(sp)
 320c4f0:	00800c04 	movi	r2,48
 320c4f4:	18c00044 	addi	r3,r3,1
 320c4f8:	d8c00415 	stw	r3,16(sp)
 320c4fc:	30800005 	stb	r2,0(r6)
 320c500:	20800003 	ldbu	r2,0(r4)
 320c504:	d8c00417 	ldw	r3,16(sp)
 320c508:	27000044 	addi	fp,r4,1
 320c50c:	10800044 	addi	r2,r2,1
 320c510:	d8c00d15 	stw	r3,52(sp)
 320c514:	20800005 	stb	r2,0(r4)
 320c518:	d9001617 	ldw	r4,88(sp)
 320c51c:	d9400717 	ldw	r5,28(sp)
 320c520:	320da140 	call	320da14 <_Bfree>
 320c524:	e0000005 	stb	zero,0(fp)
 320c528:	d9800d17 	ldw	r6,52(sp)
 320c52c:	d8c02717 	ldw	r3,156(sp)
 320c530:	d9002917 	ldw	r4,164(sp)
 320c534:	30800044 	addi	r2,r6,1
 320c538:	18800015 	stw	r2,0(r3)
 320c53c:	20029c26 	beq	r4,zero,320cfb0 <_dtoa_r+0x11c0>
 320c540:	d8c00517 	ldw	r3,20(sp)
 320c544:	27000015 	stw	fp,0(r4)
 320c548:	003e5d06 	br	320bec0 <_dtoa_r+0xd0>
 320c54c:	d9800d17 	ldw	r6,52(sp)
 320c550:	00c0c974 	movhi	r3,805
 320c554:	18f7e804 	addi	r3,r3,-8288
 320c558:	d9001217 	ldw	r4,72(sp)
 320c55c:	300490fa 	slli	r2,r6,3
 320c560:	d9401317 	ldw	r5,76(sp)
 320c564:	10c5883a 	add	r2,r2,r3
 320c568:	12000017 	ldw	r8,0(r2)
 320c56c:	12400117 	ldw	r9,4(r2)
 320c570:	400d883a 	mov	r6,r8
 320c574:	480f883a 	mov	r7,r9
 320c578:	32137e40 	call	32137e4 <__ltdf2>
 320c57c:	1000030e 	bge	r2,zero,320c58c <_dtoa_r+0x79c>
 320c580:	d8800d17 	ldw	r2,52(sp)
 320c584:	10bfffc4 	addi	r2,r2,-1
 320c588:	d8800d15 	stw	r2,52(sp)
 320c58c:	d8000c15 	stw	zero,48(sp)
 320c590:	003ea806 	br	320c034 <_dtoa_r+0x244>
 320c594:	d9000b17 	ldw	r4,44(sp)
 320c598:	202cc03a 	cmpne	r22,r4,zero
 320c59c:	b000c71e 	bne	r22,zero,320c8bc <_dtoa_r+0xacc>
 320c5a0:	dc001117 	ldw	r16,68(sp)
 320c5a4:	dc801017 	ldw	r18,64(sp)
 320c5a8:	0027883a 	mov	r19,zero
 320c5ac:	04000b0e 	bge	zero,r16,320c5dc <_dtoa_r+0x7ec>
 320c5b0:	d8c00a17 	ldw	r3,40(sp)
 320c5b4:	00c0090e 	bge	zero,r3,320c5dc <_dtoa_r+0x7ec>
 320c5b8:	8005883a 	mov	r2,r16
 320c5bc:	1c011316 	blt	r3,r16,320ca0c <_dtoa_r+0xc1c>
 320c5c0:	d9000a17 	ldw	r4,40(sp)
 320c5c4:	d9801117 	ldw	r6,68(sp)
 320c5c8:	80a1c83a 	sub	r16,r16,r2
 320c5cc:	2089c83a 	sub	r4,r4,r2
 320c5d0:	308dc83a 	sub	r6,r6,r2
 320c5d4:	d9000a15 	stw	r4,40(sp)
 320c5d8:	d9801115 	stw	r6,68(sp)
 320c5dc:	d8801017 	ldw	r2,64(sp)
 320c5e0:	0080150e 	bge	zero,r2,320c638 <_dtoa_r+0x848>
 320c5e4:	d8c00b17 	ldw	r3,44(sp)
 320c5e8:	1805003a 	cmpeq	r2,r3,zero
 320c5ec:	1001c91e 	bne	r2,zero,320cd14 <_dtoa_r+0xf24>
 320c5f0:	04800e0e 	bge	zero,r18,320c62c <_dtoa_r+0x83c>
 320c5f4:	d9001617 	ldw	r4,88(sp)
 320c5f8:	980b883a 	mov	r5,r19
 320c5fc:	900d883a 	mov	r6,r18
 320c600:	320e7c80 	call	320e7c8 <__pow5mult>
 320c604:	d9001617 	ldw	r4,88(sp)
 320c608:	d9800717 	ldw	r6,28(sp)
 320c60c:	100b883a 	mov	r5,r2
 320c610:	1027883a 	mov	r19,r2
 320c614:	320e4a40 	call	320e4a4 <__multiply>
 320c618:	d9001617 	ldw	r4,88(sp)
 320c61c:	d9400717 	ldw	r5,28(sp)
 320c620:	1023883a 	mov	r17,r2
 320c624:	320da140 	call	320da14 <_Bfree>
 320c628:	dc400715 	stw	r17,28(sp)
 320c62c:	d9001017 	ldw	r4,64(sp)
 320c630:	248dc83a 	sub	r6,r4,r18
 320c634:	30010e1e 	bne	r6,zero,320ca70 <_dtoa_r+0xc80>
 320c638:	d9001617 	ldw	r4,88(sp)
 320c63c:	04400044 	movi	r17,1
 320c640:	880b883a 	mov	r5,r17
 320c644:	320e68c0 	call	320e68c <__i2b>
 320c648:	d9800917 	ldw	r6,36(sp)
 320c64c:	1025883a 	mov	r18,r2
 320c650:	0180040e 	bge	zero,r6,320c664 <_dtoa_r+0x874>
 320c654:	d9001617 	ldw	r4,88(sp)
 320c658:	100b883a 	mov	r5,r2
 320c65c:	320e7c80 	call	320e7c8 <__pow5mult>
 320c660:	1025883a 	mov	r18,r2
 320c664:	d8801717 	ldw	r2,92(sp)
 320c668:	8880f30e 	bge	r17,r2,320ca38 <_dtoa_r+0xc48>
 320c66c:	0023883a 	mov	r17,zero
 320c670:	d9800917 	ldw	r6,36(sp)
 320c674:	30019e1e 	bne	r6,zero,320ccf0 <_dtoa_r+0xf00>
 320c678:	00c00044 	movi	r3,1
 320c67c:	d9000a17 	ldw	r4,40(sp)
 320c680:	20c5883a 	add	r2,r4,r3
 320c684:	10c007cc 	andi	r3,r2,31
 320c688:	1800841e 	bne	r3,zero,320c89c <_dtoa_r+0xaac>
 320c68c:	00800704 	movi	r2,28
 320c690:	d9000a17 	ldw	r4,40(sp)
 320c694:	d9801117 	ldw	r6,68(sp)
 320c698:	80a1883a 	add	r16,r16,r2
 320c69c:	2089883a 	add	r4,r4,r2
 320c6a0:	308d883a 	add	r6,r6,r2
 320c6a4:	d9000a15 	stw	r4,40(sp)
 320c6a8:	d9801115 	stw	r6,68(sp)
 320c6ac:	d8801117 	ldw	r2,68(sp)
 320c6b0:	0080050e 	bge	zero,r2,320c6c8 <_dtoa_r+0x8d8>
 320c6b4:	d9400717 	ldw	r5,28(sp)
 320c6b8:	d9001617 	ldw	r4,88(sp)
 320c6bc:	100d883a 	mov	r6,r2
 320c6c0:	320e3580 	call	320e358 <__lshift>
 320c6c4:	d8800715 	stw	r2,28(sp)
 320c6c8:	d8c00a17 	ldw	r3,40(sp)
 320c6cc:	00c0050e 	bge	zero,r3,320c6e4 <_dtoa_r+0x8f4>
 320c6d0:	d9001617 	ldw	r4,88(sp)
 320c6d4:	900b883a 	mov	r5,r18
 320c6d8:	180d883a 	mov	r6,r3
 320c6dc:	320e3580 	call	320e358 <__lshift>
 320c6e0:	1025883a 	mov	r18,r2
 320c6e4:	d9000c17 	ldw	r4,48(sp)
 320c6e8:	2005003a 	cmpeq	r2,r4,zero
 320c6ec:	10016f26 	beq	r2,zero,320ccac <_dtoa_r+0xebc>
 320c6f0:	d9000f17 	ldw	r4,60(sp)
 320c6f4:	0102170e 	bge	zero,r4,320cf54 <_dtoa_r+0x1164>
 320c6f8:	d9800b17 	ldw	r6,44(sp)
 320c6fc:	3005003a 	cmpeq	r2,r6,zero
 320c700:	1000881e 	bne	r2,zero,320c924 <_dtoa_r+0xb34>
 320c704:	0400050e 	bge	zero,r16,320c71c <_dtoa_r+0x92c>
 320c708:	d9001617 	ldw	r4,88(sp)
 320c70c:	980b883a 	mov	r5,r19
 320c710:	800d883a 	mov	r6,r16
 320c714:	320e3580 	call	320e358 <__lshift>
 320c718:	1027883a 	mov	r19,r2
 320c71c:	8804c03a 	cmpne	r2,r17,zero
 320c720:	1002541e 	bne	r2,zero,320d074 <_dtoa_r+0x1284>
 320c724:	980b883a 	mov	r5,r19
 320c728:	dd800517 	ldw	r22,20(sp)
 320c72c:	dcc00615 	stw	r19,24(sp)
 320c730:	a700004c 	andi	fp,r20,1
 320c734:	2827883a 	mov	r19,r5
 320c738:	d9000717 	ldw	r4,28(sp)
 320c73c:	900b883a 	mov	r5,r18
 320c740:	320bbd80 	call	320bbd8 <quorem>
 320c744:	d9000717 	ldw	r4,28(sp)
 320c748:	d9400617 	ldw	r5,24(sp)
 320c74c:	1023883a 	mov	r17,r2
 320c750:	8dc00c04 	addi	r23,r17,48
 320c754:	320db700 	call	320db70 <__mcmp>
 320c758:	d9001617 	ldw	r4,88(sp)
 320c75c:	900b883a 	mov	r5,r18
 320c760:	980d883a 	mov	r6,r19
 320c764:	1029883a 	mov	r20,r2
 320c768:	320e1cc0 	call	320e1cc <__mdiff>
 320c76c:	102b883a 	mov	r21,r2
 320c770:	10800317 	ldw	r2,12(r2)
 320c774:	1001281e 	bne	r2,zero,320cc18 <_dtoa_r+0xe28>
 320c778:	d9000717 	ldw	r4,28(sp)
 320c77c:	a80b883a 	mov	r5,r21
 320c780:	320db700 	call	320db70 <__mcmp>
 320c784:	d9001617 	ldw	r4,88(sp)
 320c788:	1021883a 	mov	r16,r2
 320c78c:	a80b883a 	mov	r5,r21
 320c790:	320da140 	call	320da14 <_Bfree>
 320c794:	8000041e 	bne	r16,zero,320c7a8 <_dtoa_r+0x9b8>
 320c798:	d8801717 	ldw	r2,92(sp)
 320c79c:	1000021e 	bne	r2,zero,320c7a8 <_dtoa_r+0x9b8>
 320c7a0:	e004c03a 	cmpne	r2,fp,zero
 320c7a4:	10011726 	beq	r2,zero,320cc04 <_dtoa_r+0xe14>
 320c7a8:	a0010616 	blt	r20,zero,320cbc4 <_dtoa_r+0xdd4>
 320c7ac:	a000041e 	bne	r20,zero,320c7c0 <_dtoa_r+0x9d0>
 320c7b0:	d8c01717 	ldw	r3,92(sp)
 320c7b4:	1800021e 	bne	r3,zero,320c7c0 <_dtoa_r+0x9d0>
 320c7b8:	e004c03a 	cmpne	r2,fp,zero
 320c7bc:	10010126 	beq	r2,zero,320cbc4 <_dtoa_r+0xdd4>
 320c7c0:	04023d16 	blt	zero,r16,320d0b8 <_dtoa_r+0x12c8>
 320c7c4:	b5c00005 	stb	r23,0(r22)
 320c7c8:	d9800517 	ldw	r6,20(sp)
 320c7cc:	d9000f17 	ldw	r4,60(sp)
 320c7d0:	b5800044 	addi	r22,r22,1
 320c7d4:	3105883a 	add	r2,r6,r4
 320c7d8:	b0806526 	beq	r22,r2,320c970 <_dtoa_r+0xb80>
 320c7dc:	d9400717 	ldw	r5,28(sp)
 320c7e0:	d9001617 	ldw	r4,88(sp)
 320c7e4:	01800284 	movi	r6,10
 320c7e8:	000f883a 	mov	r7,zero
 320c7ec:	320e6c80 	call	320e6c8 <__multadd>
 320c7f0:	d8800715 	stw	r2,28(sp)
 320c7f4:	d8800617 	ldw	r2,24(sp)
 320c7f8:	14c10c26 	beq	r2,r19,320cc2c <_dtoa_r+0xe3c>
 320c7fc:	d9400617 	ldw	r5,24(sp)
 320c800:	d9001617 	ldw	r4,88(sp)
 320c804:	01800284 	movi	r6,10
 320c808:	000f883a 	mov	r7,zero
 320c80c:	320e6c80 	call	320e6c8 <__multadd>
 320c810:	d9001617 	ldw	r4,88(sp)
 320c814:	980b883a 	mov	r5,r19
 320c818:	01800284 	movi	r6,10
 320c81c:	000f883a 	mov	r7,zero
 320c820:	d8800615 	stw	r2,24(sp)
 320c824:	320e6c80 	call	320e6c8 <__multadd>
 320c828:	1027883a 	mov	r19,r2
 320c82c:	003fc206 	br	320c738 <_dtoa_r+0x948>
 320c830:	2445c83a 	sub	r2,r4,r17
 320c834:	a088983a 	sll	r4,r20,r2
 320c838:	003e4b06 	br	320c168 <_dtoa_r+0x378>
 320c83c:	01bfffc4 	movi	r6,-1
 320c840:	00800044 	movi	r2,1
 320c844:	d9800e15 	stw	r6,56(sp)
 320c848:	d9800f15 	stw	r6,60(sp)
 320c84c:	d8800b15 	stw	r2,44(sp)
 320c850:	d8c01617 	ldw	r3,88(sp)
 320c854:	008005c4 	movi	r2,23
 320c858:	18001115 	stw	zero,68(r3)
 320c85c:	1580082e 	bgeu	r2,r22,320c880 <_dtoa_r+0xa90>
 320c860:	00c00104 	movi	r3,4
 320c864:	0009883a 	mov	r4,zero
 320c868:	18c7883a 	add	r3,r3,r3
 320c86c:	18800504 	addi	r2,r3,20
 320c870:	21000044 	addi	r4,r4,1
 320c874:	b0bffc2e 	bgeu	r22,r2,320c868 <_dtoa_r+0xa78>
 320c878:	d9801617 	ldw	r6,88(sp)
 320c87c:	31001115 	stw	r4,68(r6)
 320c880:	dc000f17 	ldw	r16,60(sp)
 320c884:	003e4b06 	br	320c1b4 <_dtoa_r+0x3c4>
 320c888:	d9801717 	ldw	r6,92(sp)
 320c88c:	0023883a 	mov	r17,zero
 320c890:	31bfff04 	addi	r6,r6,-4
 320c894:	d9801715 	stw	r6,92(sp)
 320c898:	003df806 	br	320c07c <_dtoa_r+0x28c>
 320c89c:	00800804 	movi	r2,32
 320c8a0:	10c9c83a 	sub	r4,r2,r3
 320c8a4:	00c00104 	movi	r3,4
 320c8a8:	19005a16 	blt	r3,r4,320ca14 <_dtoa_r+0xc24>
 320c8ac:	008000c4 	movi	r2,3
 320c8b0:	113f7e16 	blt	r2,r4,320c6ac <_dtoa_r+0x8bc>
 320c8b4:	20800704 	addi	r2,r4,28
 320c8b8:	003f7506 	br	320c690 <_dtoa_r+0x8a0>
 320c8bc:	d9801717 	ldw	r6,92(sp)
 320c8c0:	00800044 	movi	r2,1
 320c8c4:	1180a10e 	bge	r2,r6,320cb4c <_dtoa_r+0xd5c>
 320c8c8:	d9800f17 	ldw	r6,60(sp)
 320c8cc:	d8c01017 	ldw	r3,64(sp)
 320c8d0:	30bfffc4 	addi	r2,r6,-1
 320c8d4:	1881c616 	blt	r3,r2,320cff0 <_dtoa_r+0x1200>
 320c8d8:	18a5c83a 	sub	r18,r3,r2
 320c8dc:	d8800f17 	ldw	r2,60(sp)
 320c8e0:	10026216 	blt	r2,zero,320d26c <_dtoa_r+0x147c>
 320c8e4:	dc001117 	ldw	r16,68(sp)
 320c8e8:	1007883a 	mov	r3,r2
 320c8ec:	d9800a17 	ldw	r6,40(sp)
 320c8f0:	d8801117 	ldw	r2,68(sp)
 320c8f4:	d9001617 	ldw	r4,88(sp)
 320c8f8:	30cd883a 	add	r6,r6,r3
 320c8fc:	10c5883a 	add	r2,r2,r3
 320c900:	01400044 	movi	r5,1
 320c904:	d9800a15 	stw	r6,40(sp)
 320c908:	d8801115 	stw	r2,68(sp)
 320c90c:	320e68c0 	call	320e68c <__i2b>
 320c910:	1027883a 	mov	r19,r2
 320c914:	003f2506 	br	320c5ac <_dtoa_r+0x7bc>
 320c918:	00c0c974 	movhi	r3,805
 320c91c:	18f7c104 	addi	r3,r3,-8444
 320c920:	003d6706 	br	320bec0 <_dtoa_r+0xd0>
 320c924:	dd800517 	ldw	r22,20(sp)
 320c928:	04000044 	movi	r16,1
 320c92c:	00000706 	br	320c94c <_dtoa_r+0xb5c>
 320c930:	d9400717 	ldw	r5,28(sp)
 320c934:	d9001617 	ldw	r4,88(sp)
 320c938:	01800284 	movi	r6,10
 320c93c:	000f883a 	mov	r7,zero
 320c940:	320e6c80 	call	320e6c8 <__multadd>
 320c944:	d8800715 	stw	r2,28(sp)
 320c948:	84000044 	addi	r16,r16,1
 320c94c:	d9000717 	ldw	r4,28(sp)
 320c950:	900b883a 	mov	r5,r18
 320c954:	320bbd80 	call	320bbd8 <quorem>
 320c958:	15c00c04 	addi	r23,r2,48
 320c95c:	b5c00005 	stb	r23,0(r22)
 320c960:	d8c00f17 	ldw	r3,60(sp)
 320c964:	b5800044 	addi	r22,r22,1
 320c968:	80fff116 	blt	r16,r3,320c930 <_dtoa_r+0xb40>
 320c96c:	d8000615 	stw	zero,24(sp)
 320c970:	d9400717 	ldw	r5,28(sp)
 320c974:	d9001617 	ldw	r4,88(sp)
 320c978:	01800044 	movi	r6,1
 320c97c:	320e3580 	call	320e358 <__lshift>
 320c980:	1009883a 	mov	r4,r2
 320c984:	900b883a 	mov	r5,r18
 320c988:	d8800715 	stw	r2,28(sp)
 320c98c:	320db700 	call	320db70 <__mcmp>
 320c990:	00803c0e 	bge	zero,r2,320ca84 <_dtoa_r+0xc94>
 320c994:	b009883a 	mov	r4,r22
 320c998:	213fffc4 	addi	r4,r4,-1
 320c99c:	21400003 	ldbu	r5,0(r4)
 320c9a0:	00800e44 	movi	r2,57
 320c9a4:	28c03fcc 	andi	r3,r5,255
 320c9a8:	18c0201c 	xori	r3,r3,128
 320c9ac:	18ffe004 	addi	r3,r3,-128
 320c9b0:	1881981e 	bne	r3,r2,320d014 <_dtoa_r+0x1224>
 320c9b4:	d9800517 	ldw	r6,20(sp)
 320c9b8:	21bff71e 	bne	r4,r6,320c998 <_dtoa_r+0xba8>
 320c9bc:	d8800d17 	ldw	r2,52(sp)
 320c9c0:	37000044 	addi	fp,r6,1
 320c9c4:	10800044 	addi	r2,r2,1
 320c9c8:	d8800d15 	stw	r2,52(sp)
 320c9cc:	00800c44 	movi	r2,49
 320c9d0:	30800005 	stb	r2,0(r6)
 320c9d4:	d9001617 	ldw	r4,88(sp)
 320c9d8:	900b883a 	mov	r5,r18
 320c9dc:	320da140 	call	320da14 <_Bfree>
 320c9e0:	983ecd26 	beq	r19,zero,320c518 <_dtoa_r+0x728>
 320c9e4:	d8c00617 	ldw	r3,24(sp)
 320c9e8:	18000426 	beq	r3,zero,320c9fc <_dtoa_r+0xc0c>
 320c9ec:	1cc00326 	beq	r3,r19,320c9fc <_dtoa_r+0xc0c>
 320c9f0:	d9001617 	ldw	r4,88(sp)
 320c9f4:	180b883a 	mov	r5,r3
 320c9f8:	320da140 	call	320da14 <_Bfree>
 320c9fc:	d9001617 	ldw	r4,88(sp)
 320ca00:	980b883a 	mov	r5,r19
 320ca04:	320da140 	call	320da14 <_Bfree>
 320ca08:	003ec306 	br	320c518 <_dtoa_r+0x728>
 320ca0c:	1805883a 	mov	r2,r3
 320ca10:	003eeb06 	br	320c5c0 <_dtoa_r+0x7d0>
 320ca14:	d9800a17 	ldw	r6,40(sp)
 320ca18:	d8c01117 	ldw	r3,68(sp)
 320ca1c:	20bfff04 	addi	r2,r4,-4
 320ca20:	308d883a 	add	r6,r6,r2
 320ca24:	1887883a 	add	r3,r3,r2
 320ca28:	80a1883a 	add	r16,r16,r2
 320ca2c:	d9800a15 	stw	r6,40(sp)
 320ca30:	d8c01115 	stw	r3,68(sp)
 320ca34:	003f1d06 	br	320c6ac <_dtoa_r+0x8bc>
 320ca38:	a03f0c1e 	bne	r20,zero,320c66c <_dtoa_r+0x87c>
 320ca3c:	00800434 	movhi	r2,16
 320ca40:	10bfffc4 	addi	r2,r2,-1
 320ca44:	a884703a 	and	r2,r21,r2
 320ca48:	103f081e 	bne	r2,zero,320c66c <_dtoa_r+0x87c>
 320ca4c:	a89ffc2c 	andhi	r2,r21,32752
 320ca50:	103f0626 	beq	r2,zero,320c66c <_dtoa_r+0x87c>
 320ca54:	d8c01117 	ldw	r3,68(sp)
 320ca58:	d9000a17 	ldw	r4,40(sp)
 320ca5c:	18c00044 	addi	r3,r3,1
 320ca60:	21000044 	addi	r4,r4,1
 320ca64:	d8c01115 	stw	r3,68(sp)
 320ca68:	d9000a15 	stw	r4,40(sp)
 320ca6c:	003f0006 	br	320c670 <_dtoa_r+0x880>
 320ca70:	d9400717 	ldw	r5,28(sp)
 320ca74:	d9001617 	ldw	r4,88(sp)
 320ca78:	320e7c80 	call	320e7c8 <__pow5mult>
 320ca7c:	d8800715 	stw	r2,28(sp)
 320ca80:	003eed06 	br	320c638 <_dtoa_r+0x848>
 320ca84:	1000021e 	bne	r2,zero,320ca90 <_dtoa_r+0xca0>
 320ca88:	b880004c 	andi	r2,r23,1
 320ca8c:	103fc11e 	bne	r2,zero,320c994 <_dtoa_r+0xba4>
 320ca90:	b5bfffc4 	addi	r22,r22,-1
 320ca94:	b0c00007 	ldb	r3,0(r22)
 320ca98:	00800c04 	movi	r2,48
 320ca9c:	18bffc26 	beq	r3,r2,320ca90 <_dtoa_r+0xca0>
 320caa0:	b7000044 	addi	fp,r22,1
 320caa4:	003fcb06 	br	320c9d4 <_dtoa_r+0xbe4>
 320caa8:	d9800d17 	ldw	r6,52(sp)
 320caac:	018fc83a 	sub	r7,zero,r6
 320cab0:	3801f726 	beq	r7,zero,320d290 <_dtoa_r+0x14a0>
 320cab4:	398003cc 	andi	r6,r7,15
 320cab8:	300c90fa 	slli	r6,r6,3
 320cabc:	0140c974 	movhi	r5,805
 320cac0:	2977e804 	addi	r5,r5,-8288
 320cac4:	d9001217 	ldw	r4,72(sp)
 320cac8:	314d883a 	add	r6,r6,r5
 320cacc:	30c00117 	ldw	r3,4(r6)
 320cad0:	30800017 	ldw	r2,0(r6)
 320cad4:	d9401317 	ldw	r5,76(sp)
 320cad8:	3821d13a 	srai	r16,r7,4
 320cadc:	100d883a 	mov	r6,r2
 320cae0:	180f883a 	mov	r7,r3
 320cae4:	3212fa80 	call	3212fa8 <__muldf3>
 320cae8:	1011883a 	mov	r8,r2
 320caec:	1813883a 	mov	r9,r3
 320caf0:	1029883a 	mov	r20,r2
 320caf4:	182b883a 	mov	r21,r3
 320caf8:	8001e526 	beq	r16,zero,320d290 <_dtoa_r+0x14a0>
 320cafc:	05800084 	movi	r22,2
 320cb00:	0440c974 	movhi	r17,805
 320cb04:	8c781a04 	addi	r17,r17,-8088
 320cb08:	8080004c 	andi	r2,r16,1
 320cb0c:	1005003a 	cmpeq	r2,r2,zero
 320cb10:	1000081e 	bne	r2,zero,320cb34 <_dtoa_r+0xd44>
 320cb14:	89800017 	ldw	r6,0(r17)
 320cb18:	89c00117 	ldw	r7,4(r17)
 320cb1c:	480b883a 	mov	r5,r9
 320cb20:	4009883a 	mov	r4,r8
 320cb24:	3212fa80 	call	3212fa8 <__muldf3>
 320cb28:	1011883a 	mov	r8,r2
 320cb2c:	b5800044 	addi	r22,r22,1
 320cb30:	1813883a 	mov	r9,r3
 320cb34:	8021d07a 	srai	r16,r16,1
 320cb38:	8c400204 	addi	r17,r17,8
 320cb3c:	803ff21e 	bne	r16,zero,320cb08 <_dtoa_r+0xd18>
 320cb40:	4029883a 	mov	r20,r8
 320cb44:	482b883a 	mov	r21,r9
 320cb48:	003dca06 	br	320c274 <_dtoa_r+0x484>
 320cb4c:	d9000817 	ldw	r4,32(sp)
 320cb50:	2005003a 	cmpeq	r2,r4,zero
 320cb54:	1001f61e 	bne	r2,zero,320d330 <_dtoa_r+0x1540>
 320cb58:	dc001117 	ldw	r16,68(sp)
 320cb5c:	dc801017 	ldw	r18,64(sp)
 320cb60:	18c10cc4 	addi	r3,r3,1075
 320cb64:	003f6106 	br	320c8ec <_dtoa_r+0xafc>
 320cb68:	d8000b15 	stw	zero,44(sp)
 320cb6c:	d9802617 	ldw	r6,152(sp)
 320cb70:	d8c00d17 	ldw	r3,52(sp)
 320cb74:	30800044 	addi	r2,r6,1
 320cb78:	18ad883a 	add	r22,r3,r2
 320cb7c:	b13fffc4 	addi	r4,r22,-1
 320cb80:	d9000e15 	stw	r4,56(sp)
 320cb84:	0581f60e 	bge	zero,r22,320d360 <_dtoa_r+0x1570>
 320cb88:	dd800f15 	stw	r22,60(sp)
 320cb8c:	003f3006 	br	320c850 <_dtoa_r+0xa60>
 320cb90:	d8000b15 	stw	zero,44(sp)
 320cb94:	d9002617 	ldw	r4,152(sp)
 320cb98:	0101eb0e 	bge	zero,r4,320d348 <_dtoa_r+0x1558>
 320cb9c:	202d883a 	mov	r22,r4
 320cba0:	d9000e15 	stw	r4,56(sp)
 320cba4:	d9000f15 	stw	r4,60(sp)
 320cba8:	003f2906 	br	320c850 <_dtoa_r+0xa60>
 320cbac:	01800044 	movi	r6,1
 320cbb0:	d9800b15 	stw	r6,44(sp)
 320cbb4:	003ff706 	br	320cb94 <_dtoa_r+0xda4>
 320cbb8:	01000044 	movi	r4,1
 320cbbc:	d9000b15 	stw	r4,44(sp)
 320cbc0:	003fea06 	br	320cb6c <_dtoa_r+0xd7c>
 320cbc4:	04000c0e 	bge	zero,r16,320cbf8 <_dtoa_r+0xe08>
 320cbc8:	d9400717 	ldw	r5,28(sp)
 320cbcc:	d9001617 	ldw	r4,88(sp)
 320cbd0:	01800044 	movi	r6,1
 320cbd4:	320e3580 	call	320e358 <__lshift>
 320cbd8:	1009883a 	mov	r4,r2
 320cbdc:	900b883a 	mov	r5,r18
 320cbe0:	d8800715 	stw	r2,28(sp)
 320cbe4:	320db700 	call	320db70 <__mcmp>
 320cbe8:	0081e00e 	bge	zero,r2,320d36c <_dtoa_r+0x157c>
 320cbec:	bdc00044 	addi	r23,r23,1
 320cbf0:	00800e84 	movi	r2,58
 320cbf4:	b881a226 	beq	r23,r2,320d280 <_dtoa_r+0x1490>
 320cbf8:	b7000044 	addi	fp,r22,1
 320cbfc:	b5c00005 	stb	r23,0(r22)
 320cc00:	003f7406 	br	320c9d4 <_dtoa_r+0xbe4>
 320cc04:	00800e44 	movi	r2,57
 320cc08:	b8819d26 	beq	r23,r2,320d280 <_dtoa_r+0x1490>
 320cc0c:	053ffa0e 	bge	zero,r20,320cbf8 <_dtoa_r+0xe08>
 320cc10:	8dc00c44 	addi	r23,r17,49
 320cc14:	003ff806 	br	320cbf8 <_dtoa_r+0xe08>
 320cc18:	d9001617 	ldw	r4,88(sp)
 320cc1c:	a80b883a 	mov	r5,r21
 320cc20:	04000044 	movi	r16,1
 320cc24:	320da140 	call	320da14 <_Bfree>
 320cc28:	003edf06 	br	320c7a8 <_dtoa_r+0x9b8>
 320cc2c:	d9001617 	ldw	r4,88(sp)
 320cc30:	980b883a 	mov	r5,r19
 320cc34:	01800284 	movi	r6,10
 320cc38:	000f883a 	mov	r7,zero
 320cc3c:	320e6c80 	call	320e6c8 <__multadd>
 320cc40:	1027883a 	mov	r19,r2
 320cc44:	d8800615 	stw	r2,24(sp)
 320cc48:	003ebb06 	br	320c738 <_dtoa_r+0x948>
 320cc4c:	d9801117 	ldw	r6,68(sp)
 320cc50:	d8800d17 	ldw	r2,52(sp)
 320cc54:	d8000915 	stw	zero,36(sp)
 320cc58:	308dc83a 	sub	r6,r6,r2
 320cc5c:	0087c83a 	sub	r3,zero,r2
 320cc60:	d9801115 	stw	r6,68(sp)
 320cc64:	d8c01015 	stw	r3,64(sp)
 320cc68:	003cfe06 	br	320c064 <_dtoa_r+0x274>
 320cc6c:	018dc83a 	sub	r6,zero,r6
 320cc70:	d9801115 	stw	r6,68(sp)
 320cc74:	d8000a15 	stw	zero,40(sp)
 320cc78:	003cf306 	br	320c048 <_dtoa_r+0x258>
 320cc7c:	d9000d17 	ldw	r4,52(sp)
 320cc80:	32138f40 	call	32138f4 <__floatsidf>
 320cc84:	880b883a 	mov	r5,r17
 320cc88:	8009883a 	mov	r4,r16
 320cc8c:	180f883a 	mov	r7,r3
 320cc90:	100d883a 	mov	r6,r2
 320cc94:	321364c0 	call	321364c <__nedf2>
 320cc98:	103ce126 	beq	r2,zero,320c020 <_dtoa_r+0x230>
 320cc9c:	d9800d17 	ldw	r6,52(sp)
 320cca0:	31bfffc4 	addi	r6,r6,-1
 320cca4:	d9800d15 	stw	r6,52(sp)
 320cca8:	003cdd06 	br	320c020 <_dtoa_r+0x230>
 320ccac:	d9000717 	ldw	r4,28(sp)
 320ccb0:	900b883a 	mov	r5,r18
 320ccb4:	320db700 	call	320db70 <__mcmp>
 320ccb8:	103e8d0e 	bge	r2,zero,320c6f0 <_dtoa_r+0x900>
 320ccbc:	d9400717 	ldw	r5,28(sp)
 320ccc0:	d9001617 	ldw	r4,88(sp)
 320ccc4:	01800284 	movi	r6,10
 320ccc8:	000f883a 	mov	r7,zero
 320cccc:	320e6c80 	call	320e6c8 <__multadd>
 320ccd0:	d9800d17 	ldw	r6,52(sp)
 320ccd4:	d8800715 	stw	r2,28(sp)
 320ccd8:	31bfffc4 	addi	r6,r6,-1
 320ccdc:	d9800d15 	stw	r6,52(sp)
 320cce0:	b001a71e 	bne	r22,zero,320d380 <_dtoa_r+0x1590>
 320cce4:	d8800e17 	ldw	r2,56(sp)
 320cce8:	d8800f15 	stw	r2,60(sp)
 320ccec:	003e8006 	br	320c6f0 <_dtoa_r+0x900>
 320ccf0:	90800417 	ldw	r2,16(r18)
 320ccf4:	1085883a 	add	r2,r2,r2
 320ccf8:	1085883a 	add	r2,r2,r2
 320ccfc:	1485883a 	add	r2,r2,r18
 320cd00:	11000417 	ldw	r4,16(r2)
 320cd04:	320da3c0 	call	320da3c <__hi0bits>
 320cd08:	00c00804 	movi	r3,32
 320cd0c:	1887c83a 	sub	r3,r3,r2
 320cd10:	003e5a06 	br	320c67c <_dtoa_r+0x88c>
 320cd14:	d9400717 	ldw	r5,28(sp)
 320cd18:	d9801017 	ldw	r6,64(sp)
 320cd1c:	d9001617 	ldw	r4,88(sp)
 320cd20:	320e7c80 	call	320e7c8 <__pow5mult>
 320cd24:	d8800715 	stw	r2,28(sp)
 320cd28:	003e4306 	br	320c638 <_dtoa_r+0x848>
 320cd2c:	d9800f17 	ldw	r6,60(sp)
 320cd30:	d8800d17 	ldw	r2,52(sp)
 320cd34:	d9800315 	stw	r6,12(sp)
 320cd38:	d8800415 	stw	r2,16(sp)
 320cd3c:	d8c00b17 	ldw	r3,44(sp)
 320cd40:	1805003a 	cmpeq	r2,r3,zero
 320cd44:	1000e21e 	bne	r2,zero,320d0d0 <_dtoa_r+0x12e0>
 320cd48:	d9000317 	ldw	r4,12(sp)
 320cd4c:	0005883a 	mov	r2,zero
 320cd50:	00cff834 	movhi	r3,16352
 320cd54:	200c90fa 	slli	r6,r4,3
 320cd58:	0100c974 	movhi	r4,805
 320cd5c:	2137e804 	addi	r4,r4,-8288
 320cd60:	180b883a 	mov	r5,r3
 320cd64:	310d883a 	add	r6,r6,r4
 320cd68:	327fff17 	ldw	r9,-4(r6)
 320cd6c:	323ffe17 	ldw	r8,-8(r6)
 320cd70:	1009883a 	mov	r4,r2
 320cd74:	480f883a 	mov	r7,r9
 320cd78:	400d883a 	mov	r6,r8
 320cd7c:	321336c0 	call	321336c <__divdf3>
 320cd80:	180b883a 	mov	r5,r3
 320cd84:	b00d883a 	mov	r6,r22
 320cd88:	b80f883a 	mov	r7,r23
 320cd8c:	1009883a 	mov	r4,r2
 320cd90:	3212eb40 	call	3212eb4 <__subdf3>
 320cd94:	a80b883a 	mov	r5,r21
 320cd98:	a009883a 	mov	r4,r20
 320cd9c:	d8c01915 	stw	r3,100(sp)
 320cda0:	d8801815 	stw	r2,96(sp)
 320cda4:	32139ec0 	call	32139ec <__fixdfsi>
 320cda8:	1009883a 	mov	r4,r2
 320cdac:	1027883a 	mov	r19,r2
 320cdb0:	32138f40 	call	32138f4 <__floatsidf>
 320cdb4:	a80b883a 	mov	r5,r21
 320cdb8:	a009883a 	mov	r4,r20
 320cdbc:	180f883a 	mov	r7,r3
 320cdc0:	100d883a 	mov	r6,r2
 320cdc4:	3212eb40 	call	3212eb4 <__subdf3>
 320cdc8:	d9801817 	ldw	r6,96(sp)
 320cdcc:	1823883a 	mov	r17,r3
 320cdd0:	d8801415 	stw	r2,80(sp)
 320cdd4:	302d883a 	mov	r22,r6
 320cdd8:	d9800517 	ldw	r6,20(sp)
 320cddc:	9cc00c04 	addi	r19,r19,48
 320cde0:	dc401515 	stw	r17,84(sp)
 320cde4:	d8c01917 	ldw	r3,100(sp)
 320cde8:	34c00005 	stb	r19,0(r6)
 320cdec:	d8800517 	ldw	r2,20(sp)
 320cdf0:	d9401917 	ldw	r5,100(sp)
 320cdf4:	d9801417 	ldw	r6,80(sp)
 320cdf8:	b009883a 	mov	r4,r22
 320cdfc:	880f883a 	mov	r7,r17
 320ce00:	182f883a 	mov	r23,r3
 320ce04:	17000044 	addi	fp,r2,1
 320ce08:	32136d40 	call	32136d4 <__gtdf2>
 320ce0c:	00804e16 	blt	zero,r2,320cf48 <_dtoa_r+0x1158>
 320ce10:	d9801417 	ldw	r6,80(sp)
 320ce14:	0005883a 	mov	r2,zero
 320ce18:	00cffc34 	movhi	r3,16368
 320ce1c:	180b883a 	mov	r5,r3
 320ce20:	880f883a 	mov	r7,r17
 320ce24:	1009883a 	mov	r4,r2
 320ce28:	3212eb40 	call	3212eb4 <__subdf3>
 320ce2c:	d9401917 	ldw	r5,100(sp)
 320ce30:	180f883a 	mov	r7,r3
 320ce34:	b009883a 	mov	r4,r22
 320ce38:	100d883a 	mov	r6,r2
 320ce3c:	32136d40 	call	32136d4 <__gtdf2>
 320ce40:	00bda216 	blt	zero,r2,320c4cc <_dtoa_r+0x6dc>
 320ce44:	d8c00317 	ldw	r3,12(sp)
 320ce48:	00800044 	movi	r2,1
 320ce4c:	10c01216 	blt	r2,r3,320ce98 <_dtoa_r+0x10a8>
 320ce50:	003d4506 	br	320c368 <_dtoa_r+0x578>
 320ce54:	d9801417 	ldw	r6,80(sp)
 320ce58:	0005883a 	mov	r2,zero
 320ce5c:	00cffc34 	movhi	r3,16368
 320ce60:	180b883a 	mov	r5,r3
 320ce64:	880f883a 	mov	r7,r17
 320ce68:	1009883a 	mov	r4,r2
 320ce6c:	3212eb40 	call	3212eb4 <__subdf3>
 320ce70:	d9c01b17 	ldw	r7,108(sp)
 320ce74:	180b883a 	mov	r5,r3
 320ce78:	1009883a 	mov	r4,r2
 320ce7c:	b00d883a 	mov	r6,r22
 320ce80:	32137e40 	call	32137e4 <__ltdf2>
 320ce84:	103d9116 	blt	r2,zero,320c4cc <_dtoa_r+0x6dc>
 320ce88:	d9800517 	ldw	r6,20(sp)
 320ce8c:	d9000317 	ldw	r4,12(sp)
 320ce90:	3105883a 	add	r2,r6,r4
 320ce94:	e0bd3426 	beq	fp,r2,320c368 <_dtoa_r+0x578>
 320ce98:	04500934 	movhi	r17,16420
 320ce9c:	0021883a 	mov	r16,zero
 320cea0:	b80b883a 	mov	r5,r23
 320cea4:	b009883a 	mov	r4,r22
 320cea8:	800d883a 	mov	r6,r16
 320ceac:	880f883a 	mov	r7,r17
 320ceb0:	3212fa80 	call	3212fa8 <__muldf3>
 320ceb4:	d9401517 	ldw	r5,84(sp)
 320ceb8:	d9001417 	ldw	r4,80(sp)
 320cebc:	880f883a 	mov	r7,r17
 320cec0:	000d883a 	mov	r6,zero
 320cec4:	d8801a15 	stw	r2,104(sp)
 320cec8:	d8c01b15 	stw	r3,108(sp)
 320cecc:	3212fa80 	call	3212fa8 <__muldf3>
 320ced0:	180b883a 	mov	r5,r3
 320ced4:	1009883a 	mov	r4,r2
 320ced8:	1823883a 	mov	r17,r3
 320cedc:	1021883a 	mov	r16,r2
 320cee0:	32139ec0 	call	32139ec <__fixdfsi>
 320cee4:	1009883a 	mov	r4,r2
 320cee8:	102b883a 	mov	r21,r2
 320ceec:	32138f40 	call	32138f4 <__floatsidf>
 320cef0:	880b883a 	mov	r5,r17
 320cef4:	8009883a 	mov	r4,r16
 320cef8:	180f883a 	mov	r7,r3
 320cefc:	100d883a 	mov	r6,r2
 320cf00:	3212eb40 	call	3212eb4 <__subdf3>
 320cf04:	1021883a 	mov	r16,r2
 320cf08:	d9001b17 	ldw	r4,108(sp)
 320cf0c:	1823883a 	mov	r17,r3
 320cf10:	dc001415 	stw	r16,80(sp)
 320cf14:	ad400c04 	addi	r21,r21,48
 320cf18:	dc401515 	stw	r17,84(sp)
 320cf1c:	d8801a17 	ldw	r2,104(sp)
 320cf20:	e5400005 	stb	r21,0(fp)
 320cf24:	202f883a 	mov	r23,r4
 320cf28:	d9c01b17 	ldw	r7,108(sp)
 320cf2c:	d9001417 	ldw	r4,80(sp)
 320cf30:	880b883a 	mov	r5,r17
 320cf34:	100d883a 	mov	r6,r2
 320cf38:	102d883a 	mov	r22,r2
 320cf3c:	e7000044 	addi	fp,fp,1
 320cf40:	32137e40 	call	32137e4 <__ltdf2>
 320cf44:	103fc30e 	bge	r2,zero,320ce54 <_dtoa_r+0x1064>
 320cf48:	d9000417 	ldw	r4,16(sp)
 320cf4c:	d9000d15 	stw	r4,52(sp)
 320cf50:	003d7106 	br	320c518 <_dtoa_r+0x728>
 320cf54:	d9801717 	ldw	r6,92(sp)
 320cf58:	00800084 	movi	r2,2
 320cf5c:	11bde60e 	bge	r2,r6,320c6f8 <_dtoa_r+0x908>
 320cf60:	203cfb1e 	bne	r4,zero,320c350 <_dtoa_r+0x560>
 320cf64:	d9001617 	ldw	r4,88(sp)
 320cf68:	900b883a 	mov	r5,r18
 320cf6c:	01800144 	movi	r6,5
 320cf70:	000f883a 	mov	r7,zero
 320cf74:	320e6c80 	call	320e6c8 <__multadd>
 320cf78:	d9000717 	ldw	r4,28(sp)
 320cf7c:	100b883a 	mov	r5,r2
 320cf80:	1025883a 	mov	r18,r2
 320cf84:	320db700 	call	320db70 <__mcmp>
 320cf88:	00bcf10e 	bge	zero,r2,320c350 <_dtoa_r+0x560>
 320cf8c:	d8c00d17 	ldw	r3,52(sp)
 320cf90:	d9000517 	ldw	r4,20(sp)
 320cf94:	d8000615 	stw	zero,24(sp)
 320cf98:	18c00044 	addi	r3,r3,1
 320cf9c:	d8c00d15 	stw	r3,52(sp)
 320cfa0:	00800c44 	movi	r2,49
 320cfa4:	27000044 	addi	fp,r4,1
 320cfa8:	20800005 	stb	r2,0(r4)
 320cfac:	003e8906 	br	320c9d4 <_dtoa_r+0xbe4>
 320cfb0:	d8c00517 	ldw	r3,20(sp)
 320cfb4:	003bc206 	br	320bec0 <_dtoa_r+0xd0>
 320cfb8:	0180c974 	movhi	r6,805
 320cfbc:	31b81a04 	addi	r6,r6,-8088
 320cfc0:	30c00917 	ldw	r3,36(r6)
 320cfc4:	30800817 	ldw	r2,32(r6)
 320cfc8:	d9001217 	ldw	r4,72(sp)
 320cfcc:	d9401317 	ldw	r5,76(sp)
 320cfd0:	180f883a 	mov	r7,r3
 320cfd4:	100d883a 	mov	r6,r2
 320cfd8:	321336c0 	call	321336c <__divdf3>
 320cfdc:	948003cc 	andi	r18,r18,15
 320cfe0:	058000c4 	movi	r22,3
 320cfe4:	1029883a 	mov	r20,r2
 320cfe8:	182b883a 	mov	r21,r3
 320cfec:	003c8906 	br	320c214 <_dtoa_r+0x424>
 320cff0:	d9001017 	ldw	r4,64(sp)
 320cff4:	d9800917 	ldw	r6,36(sp)
 320cff8:	0025883a 	mov	r18,zero
 320cffc:	1105c83a 	sub	r2,r2,r4
 320d000:	2089883a 	add	r4,r4,r2
 320d004:	308d883a 	add	r6,r6,r2
 320d008:	d9001015 	stw	r4,64(sp)
 320d00c:	d9800915 	stw	r6,36(sp)
 320d010:	003e3206 	br	320c8dc <_dtoa_r+0xaec>
 320d014:	28800044 	addi	r2,r5,1
 320d018:	27000044 	addi	fp,r4,1
 320d01c:	20800005 	stb	r2,0(r4)
 320d020:	003e6c06 	br	320c9d4 <_dtoa_r+0xbe4>
 320d024:	d8800f17 	ldw	r2,60(sp)
 320d028:	00bce016 	blt	zero,r2,320c3ac <_dtoa_r+0x5bc>
 320d02c:	d9800f17 	ldw	r6,60(sp)
 320d030:	303cc51e 	bne	r6,zero,320c348 <_dtoa_r+0x558>
 320d034:	0005883a 	mov	r2,zero
 320d038:	00d00534 	movhi	r3,16404
 320d03c:	980b883a 	mov	r5,r19
 320d040:	180f883a 	mov	r7,r3
 320d044:	9009883a 	mov	r4,r18
 320d048:	100d883a 	mov	r6,r2
 320d04c:	3212fa80 	call	3212fa8 <__muldf3>
 320d050:	180b883a 	mov	r5,r3
 320d054:	a80f883a 	mov	r7,r21
 320d058:	1009883a 	mov	r4,r2
 320d05c:	a00d883a 	mov	r6,r20
 320d060:	321375c0 	call	321375c <__gedf2>
 320d064:	103cb80e 	bge	r2,zero,320c348 <_dtoa_r+0x558>
 320d068:	0027883a 	mov	r19,zero
 320d06c:	0025883a 	mov	r18,zero
 320d070:	003fc606 	br	320cf8c <_dtoa_r+0x119c>
 320d074:	99400117 	ldw	r5,4(r19)
 320d078:	d9001617 	ldw	r4,88(sp)
 320d07c:	320df940 	call	320df94 <_Balloc>
 320d080:	99800417 	ldw	r6,16(r19)
 320d084:	11000304 	addi	r4,r2,12
 320d088:	99400304 	addi	r5,r19,12
 320d08c:	318d883a 	add	r6,r6,r6
 320d090:	318d883a 	add	r6,r6,r6
 320d094:	31800204 	addi	r6,r6,8
 320d098:	1023883a 	mov	r17,r2
 320d09c:	32067cc0 	call	32067cc <memcpy>
 320d0a0:	d9001617 	ldw	r4,88(sp)
 320d0a4:	880b883a 	mov	r5,r17
 320d0a8:	01800044 	movi	r6,1
 320d0ac:	320e3580 	call	320e358 <__lshift>
 320d0b0:	100b883a 	mov	r5,r2
 320d0b4:	003d9c06 	br	320c728 <_dtoa_r+0x938>
 320d0b8:	00800e44 	movi	r2,57
 320d0bc:	b8807026 	beq	r23,r2,320d280 <_dtoa_r+0x1490>
 320d0c0:	b8800044 	addi	r2,r23,1
 320d0c4:	b7000044 	addi	fp,r22,1
 320d0c8:	b0800005 	stb	r2,0(r22)
 320d0cc:	003e4106 	br	320c9d4 <_dtoa_r+0xbe4>
 320d0d0:	d8800317 	ldw	r2,12(sp)
 320d0d4:	0180c974 	movhi	r6,805
 320d0d8:	31b7e804 	addi	r6,r6,-8288
 320d0dc:	b009883a 	mov	r4,r22
 320d0e0:	100e90fa 	slli	r7,r2,3
 320d0e4:	b80b883a 	mov	r5,r23
 320d0e8:	398f883a 	add	r7,r7,r6
 320d0ec:	38bffe17 	ldw	r2,-8(r7)
 320d0f0:	d9800517 	ldw	r6,20(sp)
 320d0f4:	38ffff17 	ldw	r3,-4(r7)
 320d0f8:	37000044 	addi	fp,r6,1
 320d0fc:	180f883a 	mov	r7,r3
 320d100:	100d883a 	mov	r6,r2
 320d104:	3212fa80 	call	3212fa8 <__muldf3>
 320d108:	a80b883a 	mov	r5,r21
 320d10c:	a009883a 	mov	r4,r20
 320d110:	182f883a 	mov	r23,r3
 320d114:	102d883a 	mov	r22,r2
 320d118:	32139ec0 	call	32139ec <__fixdfsi>
 320d11c:	1009883a 	mov	r4,r2
 320d120:	1027883a 	mov	r19,r2
 320d124:	32138f40 	call	32138f4 <__floatsidf>
 320d128:	a80b883a 	mov	r5,r21
 320d12c:	a009883a 	mov	r4,r20
 320d130:	180f883a 	mov	r7,r3
 320d134:	100d883a 	mov	r6,r2
 320d138:	3212eb40 	call	3212eb4 <__subdf3>
 320d13c:	180b883a 	mov	r5,r3
 320d140:	d8c00517 	ldw	r3,20(sp)
 320d144:	9cc00c04 	addi	r19,r19,48
 320d148:	1009883a 	mov	r4,r2
 320d14c:	1cc00005 	stb	r19,0(r3)
 320d150:	2021883a 	mov	r16,r4
 320d154:	d9000317 	ldw	r4,12(sp)
 320d158:	00800044 	movi	r2,1
 320d15c:	2823883a 	mov	r17,r5
 320d160:	20802226 	beq	r4,r2,320d1ec <_dtoa_r+0x13fc>
 320d164:	1029883a 	mov	r20,r2
 320d168:	0005883a 	mov	r2,zero
 320d16c:	00d00934 	movhi	r3,16420
 320d170:	180f883a 	mov	r7,r3
 320d174:	100d883a 	mov	r6,r2
 320d178:	880b883a 	mov	r5,r17
 320d17c:	8009883a 	mov	r4,r16
 320d180:	3212fa80 	call	3212fa8 <__muldf3>
 320d184:	180b883a 	mov	r5,r3
 320d188:	1009883a 	mov	r4,r2
 320d18c:	1823883a 	mov	r17,r3
 320d190:	1021883a 	mov	r16,r2
 320d194:	32139ec0 	call	32139ec <__fixdfsi>
 320d198:	1009883a 	mov	r4,r2
 320d19c:	102b883a 	mov	r21,r2
 320d1a0:	32138f40 	call	32138f4 <__floatsidf>
 320d1a4:	880b883a 	mov	r5,r17
 320d1a8:	8009883a 	mov	r4,r16
 320d1ac:	180f883a 	mov	r7,r3
 320d1b0:	100d883a 	mov	r6,r2
 320d1b4:	3212eb40 	call	3212eb4 <__subdf3>
 320d1b8:	180b883a 	mov	r5,r3
 320d1bc:	d8c00517 	ldw	r3,20(sp)
 320d1c0:	1009883a 	mov	r4,r2
 320d1c4:	ad400c04 	addi	r21,r21,48
 320d1c8:	1d05883a 	add	r2,r3,r20
 320d1cc:	15400005 	stb	r21,0(r2)
 320d1d0:	2021883a 	mov	r16,r4
 320d1d4:	d9000317 	ldw	r4,12(sp)
 320d1d8:	a5000044 	addi	r20,r20,1
 320d1dc:	2823883a 	mov	r17,r5
 320d1e0:	a13fe11e 	bne	r20,r4,320d168 <_dtoa_r+0x1378>
 320d1e4:	e505883a 	add	r2,fp,r20
 320d1e8:	173fffc4 	addi	fp,r2,-1
 320d1ec:	0025883a 	mov	r18,zero
 320d1f0:	04cff834 	movhi	r19,16352
 320d1f4:	b009883a 	mov	r4,r22
 320d1f8:	b80b883a 	mov	r5,r23
 320d1fc:	900d883a 	mov	r6,r18
 320d200:	980f883a 	mov	r7,r19
 320d204:	3212f340 	call	3212f34 <__adddf3>
 320d208:	180b883a 	mov	r5,r3
 320d20c:	1009883a 	mov	r4,r2
 320d210:	800d883a 	mov	r6,r16
 320d214:	880f883a 	mov	r7,r17
 320d218:	32137e40 	call	32137e4 <__ltdf2>
 320d21c:	103cab16 	blt	r2,zero,320c4cc <_dtoa_r+0x6dc>
 320d220:	0009883a 	mov	r4,zero
 320d224:	980b883a 	mov	r5,r19
 320d228:	b80f883a 	mov	r7,r23
 320d22c:	b00d883a 	mov	r6,r22
 320d230:	3212eb40 	call	3212eb4 <__subdf3>
 320d234:	180b883a 	mov	r5,r3
 320d238:	880f883a 	mov	r7,r17
 320d23c:	1009883a 	mov	r4,r2
 320d240:	800d883a 	mov	r6,r16
 320d244:	32136d40 	call	32136d4 <__gtdf2>
 320d248:	00bc470e 	bge	zero,r2,320c368 <_dtoa_r+0x578>
 320d24c:	00c00c04 	movi	r3,48
 320d250:	e73fffc4 	addi	fp,fp,-1
 320d254:	e0800007 	ldb	r2,0(fp)
 320d258:	10fffd26 	beq	r2,r3,320d250 <_dtoa_r+0x1460>
 320d25c:	d9800417 	ldw	r6,16(sp)
 320d260:	e7000044 	addi	fp,fp,1
 320d264:	d9800d15 	stw	r6,52(sp)
 320d268:	003cab06 	br	320c518 <_dtoa_r+0x728>
 320d26c:	d8c00f17 	ldw	r3,60(sp)
 320d270:	d9001117 	ldw	r4,68(sp)
 320d274:	20e1c83a 	sub	r16,r4,r3
 320d278:	0007883a 	mov	r3,zero
 320d27c:	003d9b06 	br	320c8ec <_dtoa_r+0xafc>
 320d280:	00800e44 	movi	r2,57
 320d284:	b0800005 	stb	r2,0(r22)
 320d288:	b5800044 	addi	r22,r22,1
 320d28c:	003dc106 	br	320c994 <_dtoa_r+0xba4>
 320d290:	05800084 	movi	r22,2
 320d294:	003bf706 	br	320c274 <_dtoa_r+0x484>
 320d298:	d9000f17 	ldw	r4,60(sp)
 320d29c:	013c000e 	bge	zero,r4,320c2a0 <_dtoa_r+0x4b0>
 320d2a0:	d9800e17 	ldw	r6,56(sp)
 320d2a4:	01bc300e 	bge	zero,r6,320c368 <_dtoa_r+0x578>
 320d2a8:	0005883a 	mov	r2,zero
 320d2ac:	00d00934 	movhi	r3,16420
 320d2b0:	a80b883a 	mov	r5,r21
 320d2b4:	180f883a 	mov	r7,r3
 320d2b8:	a009883a 	mov	r4,r20
 320d2bc:	100d883a 	mov	r6,r2
 320d2c0:	3212fa80 	call	3212fa8 <__muldf3>
 320d2c4:	b1000044 	addi	r4,r22,1
 320d2c8:	1021883a 	mov	r16,r2
 320d2cc:	1823883a 	mov	r17,r3
 320d2d0:	32138f40 	call	32138f4 <__floatsidf>
 320d2d4:	880b883a 	mov	r5,r17
 320d2d8:	8009883a 	mov	r4,r16
 320d2dc:	180f883a 	mov	r7,r3
 320d2e0:	100d883a 	mov	r6,r2
 320d2e4:	3212fa80 	call	3212fa8 <__muldf3>
 320d2e8:	0011883a 	mov	r8,zero
 320d2ec:	02500734 	movhi	r9,16412
 320d2f0:	180b883a 	mov	r5,r3
 320d2f4:	480f883a 	mov	r7,r9
 320d2f8:	1009883a 	mov	r4,r2
 320d2fc:	400d883a 	mov	r6,r8
 320d300:	3212f340 	call	3212f34 <__adddf3>
 320d304:	102d883a 	mov	r22,r2
 320d308:	00bf3034 	movhi	r2,64704
 320d30c:	10ef883a 	add	r23,r2,r3
 320d310:	d8800d17 	ldw	r2,52(sp)
 320d314:	d8c00e17 	ldw	r3,56(sp)
 320d318:	8029883a 	mov	r20,r16
 320d31c:	10bfffc4 	addi	r2,r2,-1
 320d320:	882b883a 	mov	r21,r17
 320d324:	d8800415 	stw	r2,16(sp)
 320d328:	d8c00315 	stw	r3,12(sp)
 320d32c:	003e8306 	br	320cd3c <_dtoa_r+0xf4c>
 320d330:	d8800117 	ldw	r2,4(sp)
 320d334:	dc001117 	ldw	r16,68(sp)
 320d338:	dc801017 	ldw	r18,64(sp)
 320d33c:	00c00d84 	movi	r3,54
 320d340:	1887c83a 	sub	r3,r3,r2
 320d344:	003d6906 	br	320c8ec <_dtoa_r+0xafc>
 320d348:	01800044 	movi	r6,1
 320d34c:	3021883a 	mov	r16,r6
 320d350:	d9800f15 	stw	r6,60(sp)
 320d354:	d9802615 	stw	r6,152(sp)
 320d358:	d9800e15 	stw	r6,56(sp)
 320d35c:	003b9306 	br	320c1ac <_dtoa_r+0x3bc>
 320d360:	b021883a 	mov	r16,r22
 320d364:	dd800f15 	stw	r22,60(sp)
 320d368:	003b9006 	br	320c1ac <_dtoa_r+0x3bc>
 320d36c:	103e221e 	bne	r2,zero,320cbf8 <_dtoa_r+0xe08>
 320d370:	b880004c 	andi	r2,r23,1
 320d374:	1005003a 	cmpeq	r2,r2,zero
 320d378:	103e1f1e 	bne	r2,zero,320cbf8 <_dtoa_r+0xe08>
 320d37c:	003e1b06 	br	320cbec <_dtoa_r+0xdfc>
 320d380:	d9001617 	ldw	r4,88(sp)
 320d384:	980b883a 	mov	r5,r19
 320d388:	01800284 	movi	r6,10
 320d38c:	000f883a 	mov	r7,zero
 320d390:	320e6c80 	call	320e6c8 <__multadd>
 320d394:	d8c00e17 	ldw	r3,56(sp)
 320d398:	1027883a 	mov	r19,r2
 320d39c:	d8c00f15 	stw	r3,60(sp)
 320d3a0:	003cd306 	br	320c6f0 <_dtoa_r+0x900>

0320d3a4 <__sflags>:
 320d3a4:	28c00007 	ldb	r3,0(r5)
 320d3a8:	00801c84 	movi	r2,114
 320d3ac:	18800926 	beq	r3,r2,320d3d4 <__sflags+0x30>
 320d3b0:	00801dc4 	movi	r2,119
 320d3b4:	18801426 	beq	r3,r2,320d408 <__sflags+0x64>
 320d3b8:	00801844 	movi	r2,97
 320d3bc:	18801626 	beq	r3,r2,320d418 <__sflags+0x74>
 320d3c0:	0007883a 	mov	r3,zero
 320d3c4:	00800584 	movi	r2,22
 320d3c8:	20800015 	stw	r2,0(r4)
 320d3cc:	1805883a 	mov	r2,r3
 320d3d0:	f800283a 	ret
 320d3d4:	000f883a 	mov	r7,zero
 320d3d8:	0011883a 	mov	r8,zero
 320d3dc:	00c00104 	movi	r3,4
 320d3e0:	28800047 	ldb	r2,1(r5)
 320d3e4:	10000426 	beq	r2,zero,320d3f8 <__sflags+0x54>
 320d3e8:	01000ac4 	movi	r4,43
 320d3ec:	11000e26 	beq	r2,r4,320d428 <__sflags+0x84>
 320d3f0:	28800087 	ldb	r2,2(r5)
 320d3f4:	11000c26 	beq	r2,r4,320d428 <__sflags+0x84>
 320d3f8:	3a04b03a 	or	r2,r7,r8
 320d3fc:	30800015 	stw	r2,0(r6)
 320d400:	1805883a 	mov	r2,r3
 320d404:	f800283a 	ret
 320d408:	01c00044 	movi	r7,1
 320d40c:	02018004 	movi	r8,1536
 320d410:	00c00204 	movi	r3,8
 320d414:	003ff206 	br	320d3e0 <__sflags+0x3c>
 320d418:	01c00044 	movi	r7,1
 320d41c:	02008204 	movi	r8,520
 320d420:	00c04204 	movi	r3,264
 320d424:	003fee06 	br	320d3e0 <__sflags+0x3c>
 320d428:	00bffcc4 	movi	r2,-13
 320d42c:	1884703a 	and	r2,r3,r2
 320d430:	01c00084 	movi	r7,2
 320d434:	10c00414 	ori	r3,r2,16
 320d438:	3a04b03a 	or	r2,r7,r8
 320d43c:	30800015 	stw	r2,0(r6)
 320d440:	003fef06 	br	320d400 <__sflags+0x5c>

0320d444 <fputc>:
 320d444:	defffc04 	addi	sp,sp,-16
 320d448:	dc800215 	stw	r18,8(sp)
 320d44c:	0480c974 	movhi	r18,805
 320d450:	94897804 	addi	r18,r18,9696
 320d454:	90c00017 	ldw	r3,0(r18)
 320d458:	dc400115 	stw	r17,4(sp)
 320d45c:	dc000015 	stw	r16,0(sp)
 320d460:	dfc00315 	stw	ra,12(sp)
 320d464:	2021883a 	mov	r16,r4
 320d468:	2823883a 	mov	r17,r5
 320d46c:	18000326 	beq	r3,zero,320d47c <fputc+0x38>
 320d470:	18800e17 	ldw	r2,56(r3)
 320d474:	1809883a 	mov	r4,r3
 320d478:	10000926 	beq	r2,zero,320d4a0 <fputc+0x5c>
 320d47c:	91000017 	ldw	r4,0(r18)
 320d480:	800b883a 	mov	r5,r16
 320d484:	880d883a 	mov	r6,r17
 320d488:	dfc00317 	ldw	ra,12(sp)
 320d48c:	dc800217 	ldw	r18,8(sp)
 320d490:	dc400117 	ldw	r17,4(sp)
 320d494:	dc000017 	ldw	r16,0(sp)
 320d498:	dec00404 	addi	sp,sp,16
 320d49c:	3206c581 	jmpi	3206c58 <_putc_r>
 320d4a0:	32048880 	call	3204888 <__sinit>
 320d4a4:	003ff506 	br	320d47c <fputc+0x38>

0320d4a8 <_fputc_r>:
 320d4a8:	defffc04 	addi	sp,sp,-16
 320d4ac:	dc800215 	stw	r18,8(sp)
 320d4b0:	dc400115 	stw	r17,4(sp)
 320d4b4:	dc000015 	stw	r16,0(sp)
 320d4b8:	dfc00315 	stw	ra,12(sp)
 320d4bc:	2021883a 	mov	r16,r4
 320d4c0:	2823883a 	mov	r17,r5
 320d4c4:	3025883a 	mov	r18,r6
 320d4c8:	20000226 	beq	r4,zero,320d4d4 <_fputc_r+0x2c>
 320d4cc:	20800e17 	ldw	r2,56(r4)
 320d4d0:	10000926 	beq	r2,zero,320d4f8 <_fputc_r+0x50>
 320d4d4:	8009883a 	mov	r4,r16
 320d4d8:	880b883a 	mov	r5,r17
 320d4dc:	900d883a 	mov	r6,r18
 320d4e0:	dfc00317 	ldw	ra,12(sp)
 320d4e4:	dc800217 	ldw	r18,8(sp)
 320d4e8:	dc400117 	ldw	r17,4(sp)
 320d4ec:	dc000017 	ldw	r16,0(sp)
 320d4f0:	dec00404 	addi	sp,sp,16
 320d4f4:	3206c581 	jmpi	3206c58 <_putc_r>
 320d4f8:	32048880 	call	3204888 <__sinit>
 320d4fc:	003ff506 	br	320d4d4 <_fputc_r+0x2c>

0320d500 <_fread_r>:
 320d500:	defff504 	addi	sp,sp,-44
 320d504:	ddc00815 	stw	r23,32(sp)
 320d508:	39af383a 	mul	r23,r7,r6
 320d50c:	df000915 	stw	fp,36(sp)
 320d510:	dd800715 	stw	r22,28(sp)
 320d514:	dcc00415 	stw	r19,16(sp)
 320d518:	dc000115 	stw	r16,4(sp)
 320d51c:	dfc00a15 	stw	ra,40(sp)
 320d520:	dd400615 	stw	r21,24(sp)
 320d524:	dd000515 	stw	r20,20(sp)
 320d528:	dc800315 	stw	r18,12(sp)
 320d52c:	dc400215 	stw	r17,8(sp)
 320d530:	d9800015 	stw	r6,0(sp)
 320d534:	3839883a 	mov	fp,r7
 320d538:	2821883a 	mov	r16,r5
 320d53c:	202d883a 	mov	r22,r4
 320d540:	dcc00b17 	ldw	r19,44(sp)
 320d544:	b8005926 	beq	r23,zero,320d6ac <_fread_r+0x1ac>
 320d548:	20000226 	beq	r4,zero,320d554 <_fread_r+0x54>
 320d54c:	20800e17 	ldw	r2,56(r4)
 320d550:	10005826 	beq	r2,zero,320d6b4 <_fread_r+0x1b4>
 320d554:	9c400117 	ldw	r17,4(r19)
 320d558:	88005916 	blt	r17,zero,320d6c0 <_fread_r+0x1c0>
 320d55c:	9880030b 	ldhu	r2,12(r19)
 320d560:	8029883a 	mov	r20,r16
 320d564:	1080008c 	andi	r2,r2,2
 320d568:	1000221e 	bne	r2,zero,320d5f4 <_fread_r+0xf4>
 320d56c:	b825883a 	mov	r18,r23
 320d570:	00000106 	br	320d578 <_fread_r+0x78>
 320d574:	9c400117 	ldw	r17,4(r19)
 320d578:	a009883a 	mov	r4,r20
 320d57c:	880d883a 	mov	r6,r17
 320d580:	8c80542e 	bgeu	r17,r18,320d6d4 <_fread_r+0x1d4>
 320d584:	99400017 	ldw	r5,0(r19)
 320d588:	a469883a 	add	r20,r20,r17
 320d58c:	9465c83a 	sub	r18,r18,r17
 320d590:	32067cc0 	call	32067cc <memcpy>
 320d594:	98800017 	ldw	r2,0(r19)
 320d598:	b009883a 	mov	r4,r22
 320d59c:	980b883a 	mov	r5,r19
 320d5a0:	1461883a 	add	r16,r2,r17
 320d5a4:	9c000015 	stw	r16,0(r19)
 320d5a8:	320740c0 	call	320740c <__srefill_r>
 320d5ac:	103ff126 	beq	r2,zero,320d574 <_fread_r+0x74>
 320d5b0:	d9400017 	ldw	r5,0(sp)
 320d5b4:	bc89c83a 	sub	r4,r23,r18
 320d5b8:	32044bc0 	call	32044bc <__udivsi3>
 320d5bc:	1039883a 	mov	fp,r2
 320d5c0:	e005883a 	mov	r2,fp
 320d5c4:	dfc00a17 	ldw	ra,40(sp)
 320d5c8:	df000917 	ldw	fp,36(sp)
 320d5cc:	ddc00817 	ldw	r23,32(sp)
 320d5d0:	dd800717 	ldw	r22,28(sp)
 320d5d4:	dd400617 	ldw	r21,24(sp)
 320d5d8:	dd000517 	ldw	r20,20(sp)
 320d5dc:	dcc00417 	ldw	r19,16(sp)
 320d5e0:	dc800317 	ldw	r18,12(sp)
 320d5e4:	dc400217 	ldw	r17,8(sp)
 320d5e8:	dc000117 	ldw	r16,4(sp)
 320d5ec:	dec00b04 	addi	sp,sp,44
 320d5f0:	f800283a 	ret
 320d5f4:	b825883a 	mov	r18,r23
 320d5f8:	8dc03436 	bltu	r17,r23,320d6cc <_fread_r+0x1cc>
 320d5fc:	99400017 	ldw	r5,0(r19)
 320d600:	a009883a 	mov	r4,r20
 320d604:	900d883a 	mov	r6,r18
 320d608:	32067cc0 	call	32067cc <memcpy>
 320d60c:	9c000017 	ldw	r16,0(r19)
 320d610:	98800117 	ldw	r2,4(r19)
 320d614:	99400c17 	ldw	r5,48(r19)
 320d618:	84a1883a 	add	r16,r16,r18
 320d61c:	14a3c83a 	sub	r17,r2,r18
 320d620:	a4ab883a 	add	r21,r20,r18
 320d624:	9c400115 	stw	r17,4(r19)
 320d628:	9c000015 	stw	r16,0(r19)
 320d62c:	bca9c83a 	sub	r20,r23,r18
 320d630:	28000826 	beq	r5,zero,320d654 <_fread_r+0x154>
 320d634:	a03fe226 	beq	r20,zero,320d5c0 <_fread_r+0xc0>
 320d638:	98801004 	addi	r2,r19,64
 320d63c:	28800326 	beq	r5,r2,320d64c <_fread_r+0x14c>
 320d640:	b009883a 	mov	r4,r22
 320d644:	3204e0c0 	call	3204e0c <_free_r>
 320d648:	9c000017 	ldw	r16,0(r19)
 320d64c:	98000c15 	stw	zero,48(r19)
 320d650:	00000106 	br	320d658 <_fread_r+0x158>
 320d654:	a03fda26 	beq	r20,zero,320d5c0 <_fread_r+0xc0>
 320d658:	9c800417 	ldw	r18,16(r19)
 320d65c:	9c400517 	ldw	r17,20(r19)
 320d660:	9d400015 	stw	r21,0(r19)
 320d664:	9d400415 	stw	r21,16(r19)
 320d668:	9d000515 	stw	r20,20(r19)
 320d66c:	b009883a 	mov	r4,r22
 320d670:	980b883a 	mov	r5,r19
 320d674:	320740c0 	call	320740c <__srefill_r>
 320d678:	98c00117 	ldw	r3,4(r19)
 320d67c:	9c800415 	stw	r18,16(r19)
 320d680:	9c400515 	stw	r17,20(r19)
 320d684:	a8eb883a 	add	r21,r21,r3
 320d688:	9c000015 	stw	r16,0(r19)
 320d68c:	a0e9c83a 	sub	r20,r20,r3
 320d690:	98000115 	stw	zero,4(r19)
 320d694:	103fef26 	beq	r2,zero,320d654 <_fread_r+0x154>
 320d698:	d9400017 	ldw	r5,0(sp)
 320d69c:	bd09c83a 	sub	r4,r23,r20
 320d6a0:	32044bc0 	call	32044bc <__udivsi3>
 320d6a4:	1039883a 	mov	fp,r2
 320d6a8:	003fc506 	br	320d5c0 <_fread_r+0xc0>
 320d6ac:	0039883a 	mov	fp,zero
 320d6b0:	003fc306 	br	320d5c0 <_fread_r+0xc0>
 320d6b4:	32048880 	call	3204888 <__sinit>
 320d6b8:	9c400117 	ldw	r17,4(r19)
 320d6bc:	883fa70e 	bge	r17,zero,320d55c <_fread_r+0x5c>
 320d6c0:	0023883a 	mov	r17,zero
 320d6c4:	98000115 	stw	zero,4(r19)
 320d6c8:	003fa406 	br	320d55c <_fread_r+0x5c>
 320d6cc:	8825883a 	mov	r18,r17
 320d6d0:	003fca06 	br	320d5fc <_fread_r+0xfc>
 320d6d4:	99400017 	ldw	r5,0(r19)
 320d6d8:	900d883a 	mov	r6,r18
 320d6dc:	32067cc0 	call	32067cc <memcpy>
 320d6e0:	98c00117 	ldw	r3,4(r19)
 320d6e4:	98800017 	ldw	r2,0(r19)
 320d6e8:	1c87c83a 	sub	r3,r3,r18
 320d6ec:	1485883a 	add	r2,r2,r18
 320d6f0:	98800015 	stw	r2,0(r19)
 320d6f4:	98c00115 	stw	r3,4(r19)
 320d6f8:	003fb106 	br	320d5c0 <_fread_r+0xc0>

0320d6fc <fread>:
 320d6fc:	0080c974 	movhi	r2,805
 320d700:	10897804 	addi	r2,r2,9696
 320d704:	2017883a 	mov	r11,r4
 320d708:	11000017 	ldw	r4,0(r2)
 320d70c:	defffe04 	addi	sp,sp,-8
 320d710:	3013883a 	mov	r9,r6
 320d714:	2805883a 	mov	r2,r5
 320d718:	d9c00015 	stw	r7,0(sp)
 320d71c:	580b883a 	mov	r5,r11
 320d720:	100d883a 	mov	r6,r2
 320d724:	480f883a 	mov	r7,r9
 320d728:	dfc00115 	stw	ra,4(sp)
 320d72c:	320d5000 	call	320d500 <_fread_r>
 320d730:	dfc00117 	ldw	ra,4(sp)
 320d734:	dec00204 	addi	sp,sp,8
 320d738:	f800283a 	ret

0320d73c <_isatty_r>:
 320d73c:	defffd04 	addi	sp,sp,-12
 320d740:	dc000015 	stw	r16,0(sp)
 320d744:	0400c974 	movhi	r16,805
 320d748:	84120d04 	addi	r16,r16,18484
 320d74c:	dc400115 	stw	r17,4(sp)
 320d750:	80000015 	stw	zero,0(r16)
 320d754:	2023883a 	mov	r17,r4
 320d758:	2809883a 	mov	r4,r5
 320d75c:	dfc00215 	stw	ra,8(sp)
 320d760:	32147600 	call	3214760 <isatty>
 320d764:	1007883a 	mov	r3,r2
 320d768:	00bfffc4 	movi	r2,-1
 320d76c:	18800626 	beq	r3,r2,320d788 <_isatty_r+0x4c>
 320d770:	1805883a 	mov	r2,r3
 320d774:	dfc00217 	ldw	ra,8(sp)
 320d778:	dc400117 	ldw	r17,4(sp)
 320d77c:	dc000017 	ldw	r16,0(sp)
 320d780:	dec00304 	addi	sp,sp,12
 320d784:	f800283a 	ret
 320d788:	80800017 	ldw	r2,0(r16)
 320d78c:	103ff826 	beq	r2,zero,320d770 <_isatty_r+0x34>
 320d790:	88800015 	stw	r2,0(r17)
 320d794:	1805883a 	mov	r2,r3
 320d798:	dfc00217 	ldw	ra,8(sp)
 320d79c:	dc400117 	ldw	r17,4(sp)
 320d7a0:	dc000017 	ldw	r16,0(sp)
 320d7a4:	dec00304 	addi	sp,sp,12
 320d7a8:	f800283a 	ret

0320d7ac <iswspace>:
 320d7ac:	00803fc4 	movi	r2,255
 320d7b0:	0007883a 	mov	r3,zero
 320d7b4:	11000636 	bltu	r2,r4,320d7d0 <iswspace+0x24>
 320d7b8:	0080c974 	movhi	r2,805
 320d7bc:	10897704 	addi	r2,r2,9692
 320d7c0:	10c00017 	ldw	r3,0(r2)
 320d7c4:	1907883a 	add	r3,r3,r4
 320d7c8:	18800003 	ldbu	r2,0(r3)
 320d7cc:	10c0020c 	andi	r3,r2,8
 320d7d0:	1805883a 	mov	r2,r3
 320d7d4:	f800283a 	ret

0320d7d8 <__locale_charset>:
 320d7d8:	d0a00617 	ldw	r2,-32744(gp)
 320d7dc:	f800283a 	ret

0320d7e0 <_localeconv_r>:
 320d7e0:	0080c974 	movhi	r2,805
 320d7e4:	10b7dc04 	addi	r2,r2,-8336
 320d7e8:	f800283a 	ret

0320d7ec <localeconv>:
 320d7ec:	0080c974 	movhi	r2,805
 320d7f0:	10897804 	addi	r2,r2,9696
 320d7f4:	11000017 	ldw	r4,0(r2)
 320d7f8:	320d7e01 	jmpi	320d7e0 <_localeconv_r>

0320d7fc <_setlocale_r>:
 320d7fc:	defffc04 	addi	sp,sp,-16
 320d800:	00c0c974 	movhi	r3,805
 320d804:	18f5be04 	addi	r3,r3,-10504
 320d808:	dc800215 	stw	r18,8(sp)
 320d80c:	dc400115 	stw	r17,4(sp)
 320d810:	dc000015 	stw	r16,0(sp)
 320d814:	2023883a 	mov	r17,r4
 320d818:	2825883a 	mov	r18,r5
 320d81c:	dfc00315 	stw	ra,12(sp)
 320d820:	3021883a 	mov	r16,r6
 320d824:	3009883a 	mov	r4,r6
 320d828:	180b883a 	mov	r5,r3
 320d82c:	30000926 	beq	r6,zero,320d854 <_setlocale_r+0x58>
 320d830:	320ebb80 	call	320ebb8 <strcmp>
 320d834:	8009883a 	mov	r4,r16
 320d838:	0140c974 	movhi	r5,805
 320d83c:	2977b904 	addi	r5,r5,-8476
 320d840:	10000b1e 	bne	r2,zero,320d870 <_setlocale_r+0x74>
 320d844:	8c000d15 	stw	r16,52(r17)
 320d848:	8c800c15 	stw	r18,48(r17)
 320d84c:	00c0c974 	movhi	r3,805
 320d850:	18f5be04 	addi	r3,r3,-10504
 320d854:	1805883a 	mov	r2,r3
 320d858:	dfc00317 	ldw	ra,12(sp)
 320d85c:	dc800217 	ldw	r18,8(sp)
 320d860:	dc400117 	ldw	r17,4(sp)
 320d864:	dc000017 	ldw	r16,0(sp)
 320d868:	dec00404 	addi	sp,sp,16
 320d86c:	f800283a 	ret
 320d870:	320ebb80 	call	320ebb8 <strcmp>
 320d874:	0007883a 	mov	r3,zero
 320d878:	103ff226 	beq	r2,zero,320d844 <_setlocale_r+0x48>
 320d87c:	003ff506 	br	320d854 <_setlocale_r+0x58>

0320d880 <setlocale>:
 320d880:	0180c974 	movhi	r6,805
 320d884:	31897804 	addi	r6,r6,9696
 320d888:	2007883a 	mov	r3,r4
 320d88c:	31000017 	ldw	r4,0(r6)
 320d890:	280d883a 	mov	r6,r5
 320d894:	180b883a 	mov	r5,r3
 320d898:	320d7fc1 	jmpi	320d7fc <_setlocale_r>

0320d89c <_lseek_r>:
 320d89c:	defffd04 	addi	sp,sp,-12
 320d8a0:	dc000015 	stw	r16,0(sp)
 320d8a4:	0400c974 	movhi	r16,805
 320d8a8:	84120d04 	addi	r16,r16,18484
 320d8ac:	dc400115 	stw	r17,4(sp)
 320d8b0:	80000015 	stw	zero,0(r16)
 320d8b4:	2023883a 	mov	r17,r4
 320d8b8:	2809883a 	mov	r4,r5
 320d8bc:	300b883a 	mov	r5,r6
 320d8c0:	380d883a 	mov	r6,r7
 320d8c4:	dfc00215 	stw	ra,8(sp)
 320d8c8:	321496c0 	call	321496c <lseek>
 320d8cc:	1007883a 	mov	r3,r2
 320d8d0:	00bfffc4 	movi	r2,-1
 320d8d4:	18800626 	beq	r3,r2,320d8f0 <_lseek_r+0x54>
 320d8d8:	1805883a 	mov	r2,r3
 320d8dc:	dfc00217 	ldw	ra,8(sp)
 320d8e0:	dc400117 	ldw	r17,4(sp)
 320d8e4:	dc000017 	ldw	r16,0(sp)
 320d8e8:	dec00304 	addi	sp,sp,12
 320d8ec:	f800283a 	ret
 320d8f0:	80800017 	ldw	r2,0(r16)
 320d8f4:	103ff826 	beq	r2,zero,320d8d8 <_lseek_r+0x3c>
 320d8f8:	88800015 	stw	r2,0(r17)
 320d8fc:	1805883a 	mov	r2,r3
 320d900:	dfc00217 	ldw	ra,8(sp)
 320d904:	dc400117 	ldw	r17,4(sp)
 320d908:	dc000017 	ldw	r16,0(sp)
 320d90c:	dec00304 	addi	sp,sp,12
 320d910:	f800283a 	ret

0320d914 <_mbrtowc_r>:
 320d914:	defffc04 	addi	sp,sp,-16
 320d918:	dc400215 	stw	r17,8(sp)
 320d91c:	dc000115 	stw	r16,4(sp)
 320d920:	dfc00315 	stw	ra,12(sp)
 320d924:	dc000417 	ldw	r16,16(sp)
 320d928:	2023883a 	mov	r17,r4
 320d92c:	30000f26 	beq	r6,zero,320d96c <_mbrtowc_r+0x58>
 320d930:	dc000015 	stw	r16,0(sp)
 320d934:	320d9d40 	call	320d9d4 <_mbtowc_r>
 320d938:	1007883a 	mov	r3,r2
 320d93c:	00bfffc4 	movi	r2,-1
 320d940:	1809883a 	mov	r4,r3
 320d944:	1880111e 	bne	r3,r2,320d98c <_mbrtowc_r+0x78>
 320d948:	80000015 	stw	zero,0(r16)
 320d94c:	00802284 	movi	r2,138
 320d950:	88800015 	stw	r2,0(r17)
 320d954:	2005883a 	mov	r2,r4
 320d958:	dfc00317 	ldw	ra,12(sp)
 320d95c:	dc400217 	ldw	r17,8(sp)
 320d960:	dc000117 	ldw	r16,4(sp)
 320d964:	dec00404 	addi	sp,sp,16
 320d968:	f800283a 	ret
 320d96c:	000b883a 	mov	r5,zero
 320d970:	0180c974 	movhi	r6,805
 320d974:	31b7b904 	addi	r6,r6,-8476
 320d978:	01c00044 	movi	r7,1
 320d97c:	dc000015 	stw	r16,0(sp)
 320d980:	320d9d40 	call	320d9d4 <_mbtowc_r>
 320d984:	1007883a 	mov	r3,r2
 320d988:	003fec06 	br	320d93c <_mbrtowc_r+0x28>
 320d98c:	1809883a 	mov	r4,r3
 320d990:	003ff006 	br	320d954 <_mbrtowc_r+0x40>

0320d994 <mbrtowc>:
 320d994:	0080c974 	movhi	r2,805
 320d998:	10897804 	addi	r2,r2,9696
 320d99c:	2017883a 	mov	r11,r4
 320d9a0:	11000017 	ldw	r4,0(r2)
 320d9a4:	defffe04 	addi	sp,sp,-8
 320d9a8:	3013883a 	mov	r9,r6
 320d9ac:	2805883a 	mov	r2,r5
 320d9b0:	d9c00015 	stw	r7,0(sp)
 320d9b4:	580b883a 	mov	r5,r11
 320d9b8:	100d883a 	mov	r6,r2
 320d9bc:	480f883a 	mov	r7,r9
 320d9c0:	dfc00115 	stw	ra,4(sp)
 320d9c4:	320d9140 	call	320d914 <_mbrtowc_r>
 320d9c8:	dfc00117 	ldw	ra,4(sp)
 320d9cc:	dec00204 	addi	sp,sp,8
 320d9d0:	f800283a 	ret

0320d9d4 <_mbtowc_r>:
 320d9d4:	deffff04 	addi	sp,sp,-4
 320d9d8:	0005883a 	mov	r2,zero
 320d9dc:	28000326 	beq	r5,zero,320d9ec <_mbtowc_r+0x18>
 320d9e0:	3000041e 	bne	r6,zero,320d9f4 <_mbtowc_r+0x20>
 320d9e4:	dec00104 	addi	sp,sp,4
 320d9e8:	f800283a 	ret
 320d9ec:	d80b883a 	mov	r5,sp
 320d9f0:	303ffc26 	beq	r6,zero,320d9e4 <_mbtowc_r+0x10>
 320d9f4:	00bfff84 	movi	r2,-2
 320d9f8:	383ffa26 	beq	r7,zero,320d9e4 <_mbtowc_r+0x10>
 320d9fc:	30800003 	ldbu	r2,0(r6)
 320da00:	28800015 	stw	r2,0(r5)
 320da04:	30c00003 	ldbu	r3,0(r6)
 320da08:	1804c03a 	cmpne	r2,r3,zero
 320da0c:	dec00104 	addi	sp,sp,4
 320da10:	f800283a 	ret

0320da14 <_Bfree>:
 320da14:	28000826 	beq	r5,zero,320da38 <_Bfree+0x24>
 320da18:	28800117 	ldw	r2,4(r5)
 320da1c:	21001317 	ldw	r4,76(r4)
 320da20:	1085883a 	add	r2,r2,r2
 320da24:	1085883a 	add	r2,r2,r2
 320da28:	1105883a 	add	r2,r2,r4
 320da2c:	10c00017 	ldw	r3,0(r2)
 320da30:	28c00015 	stw	r3,0(r5)
 320da34:	11400015 	stw	r5,0(r2)
 320da38:	f800283a 	ret

0320da3c <__hi0bits>:
 320da3c:	20bfffec 	andhi	r2,r4,65535
 320da40:	10001426 	beq	r2,zero,320da94 <__hi0bits+0x58>
 320da44:	0007883a 	mov	r3,zero
 320da48:	20bfc02c 	andhi	r2,r4,65280
 320da4c:	1000021e 	bne	r2,zero,320da58 <__hi0bits+0x1c>
 320da50:	2008923a 	slli	r4,r4,8
 320da54:	18c00204 	addi	r3,r3,8
 320da58:	20bc002c 	andhi	r2,r4,61440
 320da5c:	1000021e 	bne	r2,zero,320da68 <__hi0bits+0x2c>
 320da60:	2008913a 	slli	r4,r4,4
 320da64:	18c00104 	addi	r3,r3,4
 320da68:	20b0002c 	andhi	r2,r4,49152
 320da6c:	1000031e 	bne	r2,zero,320da7c <__hi0bits+0x40>
 320da70:	2105883a 	add	r2,r4,r4
 320da74:	18c00084 	addi	r3,r3,2
 320da78:	1089883a 	add	r4,r2,r2
 320da7c:	20000316 	blt	r4,zero,320da8c <__hi0bits+0x50>
 320da80:	2090002c 	andhi	r2,r4,16384
 320da84:	10000626 	beq	r2,zero,320daa0 <__hi0bits+0x64>
 320da88:	18c00044 	addi	r3,r3,1
 320da8c:	1805883a 	mov	r2,r3
 320da90:	f800283a 	ret
 320da94:	2008943a 	slli	r4,r4,16
 320da98:	00c00404 	movi	r3,16
 320da9c:	003fea06 	br	320da48 <__hi0bits+0xc>
 320daa0:	00c00804 	movi	r3,32
 320daa4:	1805883a 	mov	r2,r3
 320daa8:	f800283a 	ret

0320daac <__lo0bits>:
 320daac:	20c00017 	ldw	r3,0(r4)
 320dab0:	188001cc 	andi	r2,r3,7
 320dab4:	10000a26 	beq	r2,zero,320dae0 <__lo0bits+0x34>
 320dab8:	1880004c 	andi	r2,r3,1
 320dabc:	1005003a 	cmpeq	r2,r2,zero
 320dac0:	10002126 	beq	r2,zero,320db48 <__lo0bits+0x9c>
 320dac4:	1880008c 	andi	r2,r3,2
 320dac8:	1000251e 	bne	r2,zero,320db60 <__lo0bits+0xb4>
 320dacc:	1804d0ba 	srli	r2,r3,2
 320dad0:	01400084 	movi	r5,2
 320dad4:	20800015 	stw	r2,0(r4)
 320dad8:	2805883a 	mov	r2,r5
 320dadc:	f800283a 	ret
 320dae0:	18bfffcc 	andi	r2,r3,65535
 320dae4:	10001526 	beq	r2,zero,320db3c <__lo0bits+0x90>
 320dae8:	000b883a 	mov	r5,zero
 320daec:	18803fcc 	andi	r2,r3,255
 320daf0:	1000021e 	bne	r2,zero,320dafc <__lo0bits+0x50>
 320daf4:	1806d23a 	srli	r3,r3,8
 320daf8:	29400204 	addi	r5,r5,8
 320dafc:	188003cc 	andi	r2,r3,15
 320db00:	1000021e 	bne	r2,zero,320db0c <__lo0bits+0x60>
 320db04:	1806d13a 	srli	r3,r3,4
 320db08:	29400104 	addi	r5,r5,4
 320db0c:	188000cc 	andi	r2,r3,3
 320db10:	1000021e 	bne	r2,zero,320db1c <__lo0bits+0x70>
 320db14:	1806d0ba 	srli	r3,r3,2
 320db18:	29400084 	addi	r5,r5,2
 320db1c:	1880004c 	andi	r2,r3,1
 320db20:	1000031e 	bne	r2,zero,320db30 <__lo0bits+0x84>
 320db24:	1806d07a 	srli	r3,r3,1
 320db28:	18000a26 	beq	r3,zero,320db54 <__lo0bits+0xa8>
 320db2c:	29400044 	addi	r5,r5,1
 320db30:	2805883a 	mov	r2,r5
 320db34:	20c00015 	stw	r3,0(r4)
 320db38:	f800283a 	ret
 320db3c:	1806d43a 	srli	r3,r3,16
 320db40:	01400404 	movi	r5,16
 320db44:	003fe906 	br	320daec <__lo0bits+0x40>
 320db48:	000b883a 	mov	r5,zero
 320db4c:	2805883a 	mov	r2,r5
 320db50:	f800283a 	ret
 320db54:	01400804 	movi	r5,32
 320db58:	2805883a 	mov	r2,r5
 320db5c:	f800283a 	ret
 320db60:	1804d07a 	srli	r2,r3,1
 320db64:	01400044 	movi	r5,1
 320db68:	20800015 	stw	r2,0(r4)
 320db6c:	003fda06 	br	320dad8 <__lo0bits+0x2c>

0320db70 <__mcmp>:
 320db70:	20800417 	ldw	r2,16(r4)
 320db74:	28c00417 	ldw	r3,16(r5)
 320db78:	10cfc83a 	sub	r7,r2,r3
 320db7c:	38000c1e 	bne	r7,zero,320dbb0 <__mcmp+0x40>
 320db80:	18c5883a 	add	r2,r3,r3
 320db84:	1085883a 	add	r2,r2,r2
 320db88:	10c00504 	addi	r3,r2,20
 320db8c:	21000504 	addi	r4,r4,20
 320db90:	28cb883a 	add	r5,r5,r3
 320db94:	2085883a 	add	r2,r4,r2
 320db98:	10bfff04 	addi	r2,r2,-4
 320db9c:	297fff04 	addi	r5,r5,-4
 320dba0:	11800017 	ldw	r6,0(r2)
 320dba4:	28c00017 	ldw	r3,0(r5)
 320dba8:	30c0031e 	bne	r6,r3,320dbb8 <__mcmp+0x48>
 320dbac:	20bffa36 	bltu	r4,r2,320db98 <__mcmp+0x28>
 320dbb0:	3805883a 	mov	r2,r7
 320dbb4:	f800283a 	ret
 320dbb8:	30c00336 	bltu	r6,r3,320dbc8 <__mcmp+0x58>
 320dbbc:	01c00044 	movi	r7,1
 320dbc0:	3805883a 	mov	r2,r7
 320dbc4:	f800283a 	ret
 320dbc8:	01ffffc4 	movi	r7,-1
 320dbcc:	003ff806 	br	320dbb0 <__mcmp+0x40>

0320dbd0 <__ulp>:
 320dbd0:	295ffc2c 	andhi	r5,r5,32752
 320dbd4:	013f3034 	movhi	r4,64704
 320dbd8:	290b883a 	add	r5,r5,r4
 320dbdc:	0145c83a 	sub	r2,zero,r5
 320dbe0:	1007d53a 	srai	r3,r2,20
 320dbe4:	000d883a 	mov	r6,zero
 320dbe8:	0140040e 	bge	zero,r5,320dbfc <__ulp+0x2c>
 320dbec:	280f883a 	mov	r7,r5
 320dbf0:	3807883a 	mov	r3,r7
 320dbf4:	3005883a 	mov	r2,r6
 320dbf8:	f800283a 	ret
 320dbfc:	008004c4 	movi	r2,19
 320dc00:	193ffb04 	addi	r4,r3,-20
 320dc04:	10c00c0e 	bge	r2,r3,320dc38 <__ulp+0x68>
 320dc08:	008007c4 	movi	r2,31
 320dc0c:	1107c83a 	sub	r3,r2,r4
 320dc10:	00800784 	movi	r2,30
 320dc14:	01400044 	movi	r5,1
 320dc18:	11000216 	blt	r2,r4,320dc24 <__ulp+0x54>
 320dc1c:	00800044 	movi	r2,1
 320dc20:	10ca983a 	sll	r5,r2,r3
 320dc24:	000f883a 	mov	r7,zero
 320dc28:	280d883a 	mov	r6,r5
 320dc2c:	3807883a 	mov	r3,r7
 320dc30:	3005883a 	mov	r2,r6
 320dc34:	f800283a 	ret
 320dc38:	00800234 	movhi	r2,8
 320dc3c:	10cfd83a 	sra	r7,r2,r3
 320dc40:	000d883a 	mov	r6,zero
 320dc44:	3005883a 	mov	r2,r6
 320dc48:	3807883a 	mov	r3,r7
 320dc4c:	f800283a 	ret

0320dc50 <__b2d>:
 320dc50:	20800417 	ldw	r2,16(r4)
 320dc54:	defff904 	addi	sp,sp,-28
 320dc58:	dd000415 	stw	r20,16(sp)
 320dc5c:	1085883a 	add	r2,r2,r2
 320dc60:	25000504 	addi	r20,r4,20
 320dc64:	1085883a 	add	r2,r2,r2
 320dc68:	dc000015 	stw	r16,0(sp)
 320dc6c:	a0a1883a 	add	r16,r20,r2
 320dc70:	dd400515 	stw	r21,20(sp)
 320dc74:	857fff17 	ldw	r21,-4(r16)
 320dc78:	dc400115 	stw	r17,4(sp)
 320dc7c:	dfc00615 	stw	ra,24(sp)
 320dc80:	a809883a 	mov	r4,r21
 320dc84:	2823883a 	mov	r17,r5
 320dc88:	dcc00315 	stw	r19,12(sp)
 320dc8c:	dc800215 	stw	r18,8(sp)
 320dc90:	320da3c0 	call	320da3c <__hi0bits>
 320dc94:	100b883a 	mov	r5,r2
 320dc98:	00800804 	movi	r2,32
 320dc9c:	1145c83a 	sub	r2,r2,r5
 320dca0:	88800015 	stw	r2,0(r17)
 320dca4:	00800284 	movi	r2,10
 320dca8:	80ffff04 	addi	r3,r16,-4
 320dcac:	11401416 	blt	r2,r5,320dd00 <__b2d+0xb0>
 320dcb0:	008002c4 	movi	r2,11
 320dcb4:	1149c83a 	sub	r4,r2,r5
 320dcb8:	a0c02736 	bltu	r20,r3,320dd58 <__b2d+0x108>
 320dcbc:	000d883a 	mov	r6,zero
 320dcc0:	28800544 	addi	r2,r5,21
 320dcc4:	a906d83a 	srl	r3,r21,r4
 320dcc8:	a884983a 	sll	r2,r21,r2
 320dccc:	1ccffc34 	orhi	r19,r3,16368
 320dcd0:	11a4b03a 	or	r18,r2,r6
 320dcd4:	9005883a 	mov	r2,r18
 320dcd8:	9807883a 	mov	r3,r19
 320dcdc:	dfc00617 	ldw	ra,24(sp)
 320dce0:	dd400517 	ldw	r21,20(sp)
 320dce4:	dd000417 	ldw	r20,16(sp)
 320dce8:	dcc00317 	ldw	r19,12(sp)
 320dcec:	dc800217 	ldw	r18,8(sp)
 320dcf0:	dc400117 	ldw	r17,4(sp)
 320dcf4:	dc000017 	ldw	r16,0(sp)
 320dcf8:	dec00704 	addi	sp,sp,28
 320dcfc:	f800283a 	ret
 320dd00:	a0c00e36 	bltu	r20,r3,320dd3c <__b2d+0xec>
 320dd04:	293ffd44 	addi	r4,r5,-11
 320dd08:	000d883a 	mov	r6,zero
 320dd0c:	20000f26 	beq	r4,zero,320dd4c <__b2d+0xfc>
 320dd10:	00800804 	movi	r2,32
 320dd14:	110bc83a 	sub	r5,r2,r4
 320dd18:	a0c01236 	bltu	r20,r3,320dd64 <__b2d+0x114>
 320dd1c:	000f883a 	mov	r7,zero
 320dd20:	a904983a 	sll	r2,r21,r4
 320dd24:	3146d83a 	srl	r3,r6,r5
 320dd28:	3108983a 	sll	r4,r6,r4
 320dd2c:	108ffc34 	orhi	r2,r2,16368
 320dd30:	18a6b03a 	or	r19,r3,r2
 320dd34:	3924b03a 	or	r18,r7,r4
 320dd38:	003fe606 	br	320dcd4 <__b2d+0x84>
 320dd3c:	293ffd44 	addi	r4,r5,-11
 320dd40:	81bffe17 	ldw	r6,-8(r16)
 320dd44:	80fffe04 	addi	r3,r16,-8
 320dd48:	203ff11e 	bne	r4,zero,320dd10 <__b2d+0xc0>
 320dd4c:	accffc34 	orhi	r19,r21,16368
 320dd50:	3025883a 	mov	r18,r6
 320dd54:	003fdf06 	br	320dcd4 <__b2d+0x84>
 320dd58:	18bfff17 	ldw	r2,-4(r3)
 320dd5c:	110cd83a 	srl	r6,r2,r4
 320dd60:	003fd706 	br	320dcc0 <__b2d+0x70>
 320dd64:	18bfff17 	ldw	r2,-4(r3)
 320dd68:	114ed83a 	srl	r7,r2,r5
 320dd6c:	003fec06 	br	320dd20 <__b2d+0xd0>

0320dd70 <__ratio>:
 320dd70:	defff904 	addi	sp,sp,-28
 320dd74:	dc400215 	stw	r17,8(sp)
 320dd78:	2823883a 	mov	r17,r5
 320dd7c:	d80b883a 	mov	r5,sp
 320dd80:	dfc00615 	stw	ra,24(sp)
 320dd84:	dd000515 	stw	r20,20(sp)
 320dd88:	dcc00415 	stw	r19,16(sp)
 320dd8c:	dc800315 	stw	r18,12(sp)
 320dd90:	2025883a 	mov	r18,r4
 320dd94:	320dc500 	call	320dc50 <__b2d>
 320dd98:	8809883a 	mov	r4,r17
 320dd9c:	d9400104 	addi	r5,sp,4
 320dda0:	1027883a 	mov	r19,r2
 320dda4:	1829883a 	mov	r20,r3
 320dda8:	320dc500 	call	320dc50 <__b2d>
 320ddac:	89000417 	ldw	r4,16(r17)
 320ddb0:	91c00417 	ldw	r7,16(r18)
 320ddb4:	d9800117 	ldw	r6,4(sp)
 320ddb8:	180b883a 	mov	r5,r3
 320ddbc:	390fc83a 	sub	r7,r7,r4
 320ddc0:	1009883a 	mov	r4,r2
 320ddc4:	d8800017 	ldw	r2,0(sp)
 320ddc8:	380e917a 	slli	r7,r7,5
 320ddcc:	2011883a 	mov	r8,r4
 320ddd0:	1185c83a 	sub	r2,r2,r6
 320ddd4:	11c5883a 	add	r2,r2,r7
 320ddd8:	1006953a 	slli	r3,r2,20
 320dddc:	2813883a 	mov	r9,r5
 320dde0:	00800d0e 	bge	zero,r2,320de18 <__ratio+0xa8>
 320dde4:	1d29883a 	add	r20,r3,r20
 320dde8:	a00b883a 	mov	r5,r20
 320ddec:	480f883a 	mov	r7,r9
 320ddf0:	9809883a 	mov	r4,r19
 320ddf4:	400d883a 	mov	r6,r8
 320ddf8:	321336c0 	call	321336c <__divdf3>
 320ddfc:	dfc00617 	ldw	ra,24(sp)
 320de00:	dd000517 	ldw	r20,20(sp)
 320de04:	dcc00417 	ldw	r19,16(sp)
 320de08:	dc800317 	ldw	r18,12(sp)
 320de0c:	dc400217 	ldw	r17,8(sp)
 320de10:	dec00704 	addi	sp,sp,28
 320de14:	f800283a 	ret
 320de18:	28d3c83a 	sub	r9,r5,r3
 320de1c:	003ff206 	br	320dde8 <__ratio+0x78>

0320de20 <_mprec_log10>:
 320de20:	defffe04 	addi	sp,sp,-8
 320de24:	008005c4 	movi	r2,23
 320de28:	dc000015 	stw	r16,0(sp)
 320de2c:	dfc00115 	stw	ra,4(sp)
 320de30:	2021883a 	mov	r16,r4
 320de34:	11000c16 	blt	r2,r4,320de68 <_mprec_log10+0x48>
 320de38:	200490fa 	slli	r2,r4,3
 320de3c:	00c0c974 	movhi	r3,805
 320de40:	18f7e804 	addi	r3,r3,-8288
 320de44:	10c5883a 	add	r2,r2,r3
 320de48:	12400117 	ldw	r9,4(r2)
 320de4c:	12000017 	ldw	r8,0(r2)
 320de50:	4807883a 	mov	r3,r9
 320de54:	4005883a 	mov	r2,r8
 320de58:	dfc00117 	ldw	ra,4(sp)
 320de5c:	dc000017 	ldw	r16,0(sp)
 320de60:	dec00204 	addi	sp,sp,8
 320de64:	f800283a 	ret
 320de68:	0011883a 	mov	r8,zero
 320de6c:	024ffc34 	movhi	r9,16368
 320de70:	0005883a 	mov	r2,zero
 320de74:	00d00934 	movhi	r3,16420
 320de78:	480b883a 	mov	r5,r9
 320de7c:	4009883a 	mov	r4,r8
 320de80:	180f883a 	mov	r7,r3
 320de84:	100d883a 	mov	r6,r2
 320de88:	3212fa80 	call	3212fa8 <__muldf3>
 320de8c:	843fffc4 	addi	r16,r16,-1
 320de90:	1011883a 	mov	r8,r2
 320de94:	1813883a 	mov	r9,r3
 320de98:	803ff51e 	bne	r16,zero,320de70 <_mprec_log10+0x50>
 320de9c:	4005883a 	mov	r2,r8
 320dea0:	4807883a 	mov	r3,r9
 320dea4:	dfc00117 	ldw	ra,4(sp)
 320dea8:	dc000017 	ldw	r16,0(sp)
 320deac:	dec00204 	addi	sp,sp,8
 320deb0:	f800283a 	ret

0320deb4 <__copybits>:
 320deb4:	297fffc4 	addi	r5,r5,-1
 320deb8:	30800417 	ldw	r2,16(r6)
 320debc:	280bd17a 	srai	r5,r5,5
 320dec0:	31800504 	addi	r6,r6,20
 320dec4:	1085883a 	add	r2,r2,r2
 320dec8:	294b883a 	add	r5,r5,r5
 320decc:	294b883a 	add	r5,r5,r5
 320ded0:	1085883a 	add	r2,r2,r2
 320ded4:	290b883a 	add	r5,r5,r4
 320ded8:	3087883a 	add	r3,r6,r2
 320dedc:	29400104 	addi	r5,r5,4
 320dee0:	30c0052e 	bgeu	r6,r3,320def8 <__copybits+0x44>
 320dee4:	30800017 	ldw	r2,0(r6)
 320dee8:	31800104 	addi	r6,r6,4
 320deec:	20800015 	stw	r2,0(r4)
 320def0:	21000104 	addi	r4,r4,4
 320def4:	30fffb36 	bltu	r6,r3,320dee4 <__copybits+0x30>
 320def8:	2140032e 	bgeu	r4,r5,320df08 <__copybits+0x54>
 320defc:	20000015 	stw	zero,0(r4)
 320df00:	21000104 	addi	r4,r4,4
 320df04:	217ffd36 	bltu	r4,r5,320defc <__copybits+0x48>
 320df08:	f800283a 	ret

0320df0c <__any_on>:
 320df0c:	20800417 	ldw	r2,16(r4)
 320df10:	2807d17a 	srai	r3,r5,5
 320df14:	21000504 	addi	r4,r4,20
 320df18:	10c00d0e 	bge	r2,r3,320df50 <__any_on+0x44>
 320df1c:	1085883a 	add	r2,r2,r2
 320df20:	1085883a 	add	r2,r2,r2
 320df24:	208d883a 	add	r6,r4,r2
 320df28:	2180182e 	bgeu	r4,r6,320df8c <__any_on+0x80>
 320df2c:	30bfff17 	ldw	r2,-4(r6)
 320df30:	30ffff04 	addi	r3,r6,-4
 320df34:	1000041e 	bne	r2,zero,320df48 <__any_on+0x3c>
 320df38:	20c0142e 	bgeu	r4,r3,320df8c <__any_on+0x80>
 320df3c:	18ffff04 	addi	r3,r3,-4
 320df40:	18800017 	ldw	r2,0(r3)
 320df44:	103ffc26 	beq	r2,zero,320df38 <__any_on+0x2c>
 320df48:	00800044 	movi	r2,1
 320df4c:	f800283a 	ret
 320df50:	18800a0e 	bge	r3,r2,320df7c <__any_on+0x70>
 320df54:	294007cc 	andi	r5,r5,31
 320df58:	28000826 	beq	r5,zero,320df7c <__any_on+0x70>
 320df5c:	18c5883a 	add	r2,r3,r3
 320df60:	1085883a 	add	r2,r2,r2
 320df64:	208d883a 	add	r6,r4,r2
 320df68:	30c00017 	ldw	r3,0(r6)
 320df6c:	1944d83a 	srl	r2,r3,r5
 320df70:	1144983a 	sll	r2,r2,r5
 320df74:	18bff41e 	bne	r3,r2,320df48 <__any_on+0x3c>
 320df78:	003feb06 	br	320df28 <__any_on+0x1c>
 320df7c:	18c5883a 	add	r2,r3,r3
 320df80:	1085883a 	add	r2,r2,r2
 320df84:	208d883a 	add	r6,r4,r2
 320df88:	003fe706 	br	320df28 <__any_on+0x1c>
 320df8c:	0005883a 	mov	r2,zero
 320df90:	f800283a 	ret

0320df94 <_Balloc>:
 320df94:	20c01317 	ldw	r3,76(r4)
 320df98:	defffb04 	addi	sp,sp,-20
 320df9c:	dcc00315 	stw	r19,12(sp)
 320dfa0:	dc800215 	stw	r18,8(sp)
 320dfa4:	dfc00415 	stw	ra,16(sp)
 320dfa8:	2825883a 	mov	r18,r5
 320dfac:	dc400115 	stw	r17,4(sp)
 320dfb0:	dc000015 	stw	r16,0(sp)
 320dfb4:	2027883a 	mov	r19,r4
 320dfb8:	01800404 	movi	r6,16
 320dfbc:	01400104 	movi	r5,4
 320dfc0:	18001726 	beq	r3,zero,320e020 <_Balloc+0x8c>
 320dfc4:	01400044 	movi	r5,1
 320dfc8:	9485883a 	add	r2,r18,r18
 320dfcc:	2ca2983a 	sll	r17,r5,r18
 320dfd0:	1085883a 	add	r2,r2,r2
 320dfd4:	10c7883a 	add	r3,r2,r3
 320dfd8:	1c000017 	ldw	r16,0(r3)
 320dfdc:	8c4d883a 	add	r6,r17,r17
 320dfe0:	318d883a 	add	r6,r6,r6
 320dfe4:	9809883a 	mov	r4,r19
 320dfe8:	31800504 	addi	r6,r6,20
 320dfec:	80001226 	beq	r16,zero,320e038 <_Balloc+0xa4>
 320dff0:	80800017 	ldw	r2,0(r16)
 320dff4:	18800015 	stw	r2,0(r3)
 320dff8:	80000415 	stw	zero,16(r16)
 320dffc:	80000315 	stw	zero,12(r16)
 320e000:	8005883a 	mov	r2,r16
 320e004:	dfc00417 	ldw	ra,16(sp)
 320e008:	dcc00317 	ldw	r19,12(sp)
 320e00c:	dc800217 	ldw	r18,8(sp)
 320e010:	dc400117 	ldw	r17,4(sp)
 320e014:	dc000017 	ldw	r16,0(sp)
 320e018:	dec00504 	addi	sp,sp,20
 320e01c:	f800283a 	ret
 320e020:	32110380 	call	3211038 <_calloc_r>
 320e024:	1007883a 	mov	r3,r2
 320e028:	0021883a 	mov	r16,zero
 320e02c:	98801315 	stw	r2,76(r19)
 320e030:	103fe41e 	bne	r2,zero,320dfc4 <_Balloc+0x30>
 320e034:	003ff206 	br	320e000 <_Balloc+0x6c>
 320e038:	32110380 	call	3211038 <_calloc_r>
 320e03c:	103ff026 	beq	r2,zero,320e000 <_Balloc+0x6c>
 320e040:	1021883a 	mov	r16,r2
 320e044:	14800115 	stw	r18,4(r2)
 320e048:	14400215 	stw	r17,8(r2)
 320e04c:	003fea06 	br	320dff8 <_Balloc+0x64>

0320e050 <__d2b>:
 320e050:	defff504 	addi	sp,sp,-44
 320e054:	dcc00515 	stw	r19,20(sp)
 320e058:	04c00044 	movi	r19,1
 320e05c:	dc000215 	stw	r16,8(sp)
 320e060:	2821883a 	mov	r16,r5
 320e064:	980b883a 	mov	r5,r19
 320e068:	ddc00915 	stw	r23,36(sp)
 320e06c:	dd800815 	stw	r22,32(sp)
 320e070:	dd400715 	stw	r21,28(sp)
 320e074:	dd000615 	stw	r20,24(sp)
 320e078:	dc800415 	stw	r18,16(sp)
 320e07c:	dc400315 	stw	r17,12(sp)
 320e080:	dfc00a15 	stw	ra,40(sp)
 320e084:	3023883a 	mov	r17,r6
 320e088:	382d883a 	mov	r22,r7
 320e08c:	ddc00b17 	ldw	r23,44(sp)
 320e090:	320df940 	call	320df94 <_Balloc>
 320e094:	1025883a 	mov	r18,r2
 320e098:	00a00034 	movhi	r2,32768
 320e09c:	10bfffc4 	addi	r2,r2,-1
 320e0a0:	8888703a 	and	r4,r17,r2
 320e0a4:	202ad53a 	srli	r21,r4,20
 320e0a8:	00800434 	movhi	r2,16
 320e0ac:	10bfffc4 	addi	r2,r2,-1
 320e0b0:	8886703a 	and	r3,r17,r2
 320e0b4:	a829003a 	cmpeq	r20,r21,zero
 320e0b8:	800b883a 	mov	r5,r16
 320e0bc:	d8c00115 	stw	r3,4(sp)
 320e0c0:	94000504 	addi	r16,r18,20
 320e0c4:	a000021e 	bne	r20,zero,320e0d0 <__d2b+0x80>
 320e0c8:	18c00434 	orhi	r3,r3,16
 320e0cc:	d8c00115 	stw	r3,4(sp)
 320e0d0:	28002726 	beq	r5,zero,320e170 <__d2b+0x120>
 320e0d4:	d809883a 	mov	r4,sp
 320e0d8:	d9400015 	stw	r5,0(sp)
 320e0dc:	320daac0 	call	320daac <__lo0bits>
 320e0e0:	100d883a 	mov	r6,r2
 320e0e4:	10003526 	beq	r2,zero,320e1bc <__d2b+0x16c>
 320e0e8:	d8c00117 	ldw	r3,4(sp)
 320e0ec:	00800804 	movi	r2,32
 320e0f0:	1185c83a 	sub	r2,r2,r6
 320e0f4:	d9000017 	ldw	r4,0(sp)
 320e0f8:	1886983a 	sll	r3,r3,r2
 320e0fc:	1906b03a 	or	r3,r3,r4
 320e100:	90c00515 	stw	r3,20(r18)
 320e104:	d8c00117 	ldw	r3,4(sp)
 320e108:	1986d83a 	srl	r3,r3,r6
 320e10c:	d8c00115 	stw	r3,4(sp)
 320e110:	180b003a 	cmpeq	r5,r3,zero
 320e114:	00800084 	movi	r2,2
 320e118:	114bc83a 	sub	r5,r2,r5
 320e11c:	80c00115 	stw	r3,4(r16)
 320e120:	91400415 	stw	r5,16(r18)
 320e124:	a0001a1e 	bne	r20,zero,320e190 <__d2b+0x140>
 320e128:	3545883a 	add	r2,r6,r21
 320e12c:	10bef344 	addi	r2,r2,-1075
 320e130:	00c00d44 	movi	r3,53
 320e134:	b0800015 	stw	r2,0(r22)
 320e138:	1987c83a 	sub	r3,r3,r6
 320e13c:	b8c00015 	stw	r3,0(r23)
 320e140:	9005883a 	mov	r2,r18
 320e144:	dfc00a17 	ldw	ra,40(sp)
 320e148:	ddc00917 	ldw	r23,36(sp)
 320e14c:	dd800817 	ldw	r22,32(sp)
 320e150:	dd400717 	ldw	r21,28(sp)
 320e154:	dd000617 	ldw	r20,24(sp)
 320e158:	dcc00517 	ldw	r19,20(sp)
 320e15c:	dc800417 	ldw	r18,16(sp)
 320e160:	dc400317 	ldw	r17,12(sp)
 320e164:	dc000217 	ldw	r16,8(sp)
 320e168:	dec00b04 	addi	sp,sp,44
 320e16c:	f800283a 	ret
 320e170:	d9000104 	addi	r4,sp,4
 320e174:	320daac0 	call	320daac <__lo0bits>
 320e178:	11800804 	addi	r6,r2,32
 320e17c:	d8800117 	ldw	r2,4(sp)
 320e180:	94c00415 	stw	r19,16(r18)
 320e184:	980b883a 	mov	r5,r19
 320e188:	90800515 	stw	r2,20(r18)
 320e18c:	a03fe626 	beq	r20,zero,320e128 <__d2b+0xd8>
 320e190:	2945883a 	add	r2,r5,r5
 320e194:	1085883a 	add	r2,r2,r2
 320e198:	1405883a 	add	r2,r2,r16
 320e19c:	113fff17 	ldw	r4,-4(r2)
 320e1a0:	30fef384 	addi	r3,r6,-1074
 320e1a4:	2820917a 	slli	r16,r5,5
 320e1a8:	b0c00015 	stw	r3,0(r22)
 320e1ac:	320da3c0 	call	320da3c <__hi0bits>
 320e1b0:	80a1c83a 	sub	r16,r16,r2
 320e1b4:	bc000015 	stw	r16,0(r23)
 320e1b8:	003fe106 	br	320e140 <__d2b+0xf0>
 320e1bc:	d8800017 	ldw	r2,0(sp)
 320e1c0:	90800515 	stw	r2,20(r18)
 320e1c4:	d8c00117 	ldw	r3,4(sp)
 320e1c8:	003fd106 	br	320e110 <__d2b+0xc0>

0320e1cc <__mdiff>:
 320e1cc:	defffb04 	addi	sp,sp,-20
 320e1d0:	dc000015 	stw	r16,0(sp)
 320e1d4:	2821883a 	mov	r16,r5
 320e1d8:	dc800215 	stw	r18,8(sp)
 320e1dc:	300b883a 	mov	r5,r6
 320e1e0:	2025883a 	mov	r18,r4
 320e1e4:	8009883a 	mov	r4,r16
 320e1e8:	dc400115 	stw	r17,4(sp)
 320e1ec:	dfc00415 	stw	ra,16(sp)
 320e1f0:	dcc00315 	stw	r19,12(sp)
 320e1f4:	3023883a 	mov	r17,r6
 320e1f8:	320db700 	call	320db70 <__mcmp>
 320e1fc:	10004226 	beq	r2,zero,320e308 <__mdiff+0x13c>
 320e200:	10005016 	blt	r2,zero,320e344 <__mdiff+0x178>
 320e204:	0027883a 	mov	r19,zero
 320e208:	81400117 	ldw	r5,4(r16)
 320e20c:	9009883a 	mov	r4,r18
 320e210:	320df940 	call	320df94 <_Balloc>
 320e214:	1019883a 	mov	r12,r2
 320e218:	82800417 	ldw	r10,16(r16)
 320e21c:	88800417 	ldw	r2,16(r17)
 320e220:	81800504 	addi	r6,r16,20
 320e224:	5287883a 	add	r3,r10,r10
 320e228:	1085883a 	add	r2,r2,r2
 320e22c:	18c7883a 	add	r3,r3,r3
 320e230:	1085883a 	add	r2,r2,r2
 320e234:	8a000504 	addi	r8,r17,20
 320e238:	64c00315 	stw	r19,12(r12)
 320e23c:	30db883a 	add	r13,r6,r3
 320e240:	4097883a 	add	r11,r8,r2
 320e244:	61c00504 	addi	r7,r12,20
 320e248:	0013883a 	mov	r9,zero
 320e24c:	31000017 	ldw	r4,0(r6)
 320e250:	41400017 	ldw	r5,0(r8)
 320e254:	42000104 	addi	r8,r8,4
 320e258:	20bfffcc 	andi	r2,r4,65535
 320e25c:	28ffffcc 	andi	r3,r5,65535
 320e260:	10c5c83a 	sub	r2,r2,r3
 320e264:	1245883a 	add	r2,r2,r9
 320e268:	2008d43a 	srli	r4,r4,16
 320e26c:	280ad43a 	srli	r5,r5,16
 320e270:	1007d43a 	srai	r3,r2,16
 320e274:	3880000d 	sth	r2,0(r7)
 320e278:	2149c83a 	sub	r4,r4,r5
 320e27c:	20c9883a 	add	r4,r4,r3
 320e280:	3900008d 	sth	r4,2(r7)
 320e284:	31800104 	addi	r6,r6,4
 320e288:	39c00104 	addi	r7,r7,4
 320e28c:	2013d43a 	srai	r9,r4,16
 320e290:	42ffee36 	bltu	r8,r11,320e24c <__mdiff+0x80>
 320e294:	33400c2e 	bgeu	r6,r13,320e2c8 <__mdiff+0xfc>
 320e298:	30800017 	ldw	r2,0(r6)
 320e29c:	31800104 	addi	r6,r6,4
 320e2a0:	10ffffcc 	andi	r3,r2,65535
 320e2a4:	1a47883a 	add	r3,r3,r9
 320e2a8:	1004d43a 	srli	r2,r2,16
 320e2ac:	1809d43a 	srai	r4,r3,16
 320e2b0:	38c0000d 	sth	r3,0(r7)
 320e2b4:	1105883a 	add	r2,r2,r4
 320e2b8:	3880008d 	sth	r2,2(r7)
 320e2bc:	1013d43a 	srai	r9,r2,16
 320e2c0:	39c00104 	addi	r7,r7,4
 320e2c4:	337ff436 	bltu	r6,r13,320e298 <__mdiff+0xcc>
 320e2c8:	38bfff17 	ldw	r2,-4(r7)
 320e2cc:	38ffff04 	addi	r3,r7,-4
 320e2d0:	1000041e 	bne	r2,zero,320e2e4 <__mdiff+0x118>
 320e2d4:	18ffff04 	addi	r3,r3,-4
 320e2d8:	18800017 	ldw	r2,0(r3)
 320e2dc:	52bfffc4 	addi	r10,r10,-1
 320e2e0:	103ffc26 	beq	r2,zero,320e2d4 <__mdiff+0x108>
 320e2e4:	6005883a 	mov	r2,r12
 320e2e8:	62800415 	stw	r10,16(r12)
 320e2ec:	dfc00417 	ldw	ra,16(sp)
 320e2f0:	dcc00317 	ldw	r19,12(sp)
 320e2f4:	dc800217 	ldw	r18,8(sp)
 320e2f8:	dc400117 	ldw	r17,4(sp)
 320e2fc:	dc000017 	ldw	r16,0(sp)
 320e300:	dec00504 	addi	sp,sp,20
 320e304:	f800283a 	ret
 320e308:	9009883a 	mov	r4,r18
 320e30c:	000b883a 	mov	r5,zero
 320e310:	320df940 	call	320df94 <_Balloc>
 320e314:	1019883a 	mov	r12,r2
 320e318:	00800044 	movi	r2,1
 320e31c:	60800415 	stw	r2,16(r12)
 320e320:	6005883a 	mov	r2,r12
 320e324:	60000515 	stw	zero,20(r12)
 320e328:	dfc00417 	ldw	ra,16(sp)
 320e32c:	dcc00317 	ldw	r19,12(sp)
 320e330:	dc800217 	ldw	r18,8(sp)
 320e334:	dc400117 	ldw	r17,4(sp)
 320e338:	dc000017 	ldw	r16,0(sp)
 320e33c:	dec00504 	addi	sp,sp,20
 320e340:	f800283a 	ret
 320e344:	880d883a 	mov	r6,r17
 320e348:	04c00044 	movi	r19,1
 320e34c:	8023883a 	mov	r17,r16
 320e350:	3021883a 	mov	r16,r6
 320e354:	003fac06 	br	320e208 <__mdiff+0x3c>

0320e358 <__lshift>:
 320e358:	defff904 	addi	sp,sp,-28
 320e35c:	28800417 	ldw	r2,16(r5)
 320e360:	dc000015 	stw	r16,0(sp)
 320e364:	3021d17a 	srai	r16,r6,5
 320e368:	28c00217 	ldw	r3,8(r5)
 320e36c:	10800044 	addi	r2,r2,1
 320e370:	dc400115 	stw	r17,4(sp)
 320e374:	80a3883a 	add	r17,r16,r2
 320e378:	dd400515 	stw	r21,20(sp)
 320e37c:	dd000415 	stw	r20,16(sp)
 320e380:	dc800215 	stw	r18,8(sp)
 320e384:	dfc00615 	stw	ra,24(sp)
 320e388:	2825883a 	mov	r18,r5
 320e38c:	dcc00315 	stw	r19,12(sp)
 320e390:	3029883a 	mov	r20,r6
 320e394:	202b883a 	mov	r21,r4
 320e398:	29400117 	ldw	r5,4(r5)
 320e39c:	1c40030e 	bge	r3,r17,320e3ac <__lshift+0x54>
 320e3a0:	18c7883a 	add	r3,r3,r3
 320e3a4:	29400044 	addi	r5,r5,1
 320e3a8:	1c7ffd16 	blt	r3,r17,320e3a0 <__lshift+0x48>
 320e3ac:	a809883a 	mov	r4,r21
 320e3b0:	320df940 	call	320df94 <_Balloc>
 320e3b4:	1027883a 	mov	r19,r2
 320e3b8:	11400504 	addi	r5,r2,20
 320e3bc:	0400090e 	bge	zero,r16,320e3e4 <__lshift+0x8c>
 320e3c0:	2805883a 	mov	r2,r5
 320e3c4:	0007883a 	mov	r3,zero
 320e3c8:	18c00044 	addi	r3,r3,1
 320e3cc:	10000015 	stw	zero,0(r2)
 320e3d0:	10800104 	addi	r2,r2,4
 320e3d4:	80fffc1e 	bne	r16,r3,320e3c8 <__lshift+0x70>
 320e3d8:	8405883a 	add	r2,r16,r16
 320e3dc:	1085883a 	add	r2,r2,r2
 320e3e0:	288b883a 	add	r5,r5,r2
 320e3e4:	90800417 	ldw	r2,16(r18)
 320e3e8:	91000504 	addi	r4,r18,20
 320e3ec:	a18007cc 	andi	r6,r20,31
 320e3f0:	1085883a 	add	r2,r2,r2
 320e3f4:	1085883a 	add	r2,r2,r2
 320e3f8:	208f883a 	add	r7,r4,r2
 320e3fc:	30001e26 	beq	r6,zero,320e478 <__lshift+0x120>
 320e400:	00800804 	movi	r2,32
 320e404:	1191c83a 	sub	r8,r2,r6
 320e408:	0007883a 	mov	r3,zero
 320e40c:	20800017 	ldw	r2,0(r4)
 320e410:	1184983a 	sll	r2,r2,r6
 320e414:	1884b03a 	or	r2,r3,r2
 320e418:	28800015 	stw	r2,0(r5)
 320e41c:	20c00017 	ldw	r3,0(r4)
 320e420:	21000104 	addi	r4,r4,4
 320e424:	29400104 	addi	r5,r5,4
 320e428:	1a06d83a 	srl	r3,r3,r8
 320e42c:	21fff736 	bltu	r4,r7,320e40c <__lshift+0xb4>
 320e430:	28c00015 	stw	r3,0(r5)
 320e434:	18000126 	beq	r3,zero,320e43c <__lshift+0xe4>
 320e438:	8c400044 	addi	r17,r17,1
 320e43c:	88bfffc4 	addi	r2,r17,-1
 320e440:	98800415 	stw	r2,16(r19)
 320e444:	a809883a 	mov	r4,r21
 320e448:	900b883a 	mov	r5,r18
 320e44c:	320da140 	call	320da14 <_Bfree>
 320e450:	9805883a 	mov	r2,r19
 320e454:	dfc00617 	ldw	ra,24(sp)
 320e458:	dd400517 	ldw	r21,20(sp)
 320e45c:	dd000417 	ldw	r20,16(sp)
 320e460:	dcc00317 	ldw	r19,12(sp)
 320e464:	dc800217 	ldw	r18,8(sp)
 320e468:	dc400117 	ldw	r17,4(sp)
 320e46c:	dc000017 	ldw	r16,0(sp)
 320e470:	dec00704 	addi	sp,sp,28
 320e474:	f800283a 	ret
 320e478:	20800017 	ldw	r2,0(r4)
 320e47c:	21000104 	addi	r4,r4,4
 320e480:	28800015 	stw	r2,0(r5)
 320e484:	29400104 	addi	r5,r5,4
 320e488:	21ffec2e 	bgeu	r4,r7,320e43c <__lshift+0xe4>
 320e48c:	20800017 	ldw	r2,0(r4)
 320e490:	21000104 	addi	r4,r4,4
 320e494:	28800015 	stw	r2,0(r5)
 320e498:	29400104 	addi	r5,r5,4
 320e49c:	21fff636 	bltu	r4,r7,320e478 <__lshift+0x120>
 320e4a0:	003fe606 	br	320e43c <__lshift+0xe4>

0320e4a4 <__multiply>:
 320e4a4:	defff904 	addi	sp,sp,-28
 320e4a8:	dcc00315 	stw	r19,12(sp)
 320e4ac:	dc800215 	stw	r18,8(sp)
 320e4b0:	2cc00417 	ldw	r19,16(r5)
 320e4b4:	34800417 	ldw	r18,16(r6)
 320e4b8:	dd000415 	stw	r20,16(sp)
 320e4bc:	dc400115 	stw	r17,4(sp)
 320e4c0:	dfc00615 	stw	ra,24(sp)
 320e4c4:	dd400515 	stw	r21,20(sp)
 320e4c8:	dc000015 	stw	r16,0(sp)
 320e4cc:	2823883a 	mov	r17,r5
 320e4d0:	3029883a 	mov	r20,r6
 320e4d4:	9c80040e 	bge	r19,r18,320e4e8 <__multiply+0x44>
 320e4d8:	9027883a 	mov	r19,r18
 320e4dc:	2c800417 	ldw	r18,16(r5)
 320e4e0:	2829883a 	mov	r20,r5
 320e4e4:	3023883a 	mov	r17,r6
 320e4e8:	88800217 	ldw	r2,8(r17)
 320e4ec:	9ca1883a 	add	r16,r19,r18
 320e4f0:	89400117 	ldw	r5,4(r17)
 320e4f4:	1400010e 	bge	r2,r16,320e4fc <__multiply+0x58>
 320e4f8:	29400044 	addi	r5,r5,1
 320e4fc:	320df940 	call	320df94 <_Balloc>
 320e500:	102b883a 	mov	r21,r2
 320e504:	8405883a 	add	r2,r16,r16
 320e508:	1085883a 	add	r2,r2,r2
 320e50c:	a9000504 	addi	r4,r21,20
 320e510:	209d883a 	add	r14,r4,r2
 320e514:	2380042e 	bgeu	r4,r14,320e528 <__multiply+0x84>
 320e518:	2005883a 	mov	r2,r4
 320e51c:	10000015 	stw	zero,0(r2)
 320e520:	10800104 	addi	r2,r2,4
 320e524:	13bffd36 	bltu	r2,r14,320e51c <__multiply+0x78>
 320e528:	9485883a 	add	r2,r18,r18
 320e52c:	9cc7883a 	add	r3,r19,r19
 320e530:	a1800504 	addi	r6,r20,20
 320e534:	1085883a 	add	r2,r2,r2
 320e538:	8b400504 	addi	r13,r17,20
 320e53c:	18c7883a 	add	r3,r3,r3
 320e540:	309f883a 	add	r15,r6,r2
 320e544:	68d7883a 	add	r11,r13,r3
 320e548:	33c03b2e 	bgeu	r6,r15,320e638 <__multiply+0x194>
 320e54c:	2019883a 	mov	r12,r4
 320e550:	30800017 	ldw	r2,0(r6)
 320e554:	127fffcc 	andi	r9,r2,65535
 320e558:	48001826 	beq	r9,zero,320e5bc <__multiply+0x118>
 320e55c:	6811883a 	mov	r8,r13
 320e560:	600f883a 	mov	r7,r12
 320e564:	0015883a 	mov	r10,zero
 320e568:	40c00017 	ldw	r3,0(r8)
 320e56c:	39400017 	ldw	r5,0(r7)
 320e570:	42000104 	addi	r8,r8,4
 320e574:	193fffcc 	andi	r4,r3,65535
 320e578:	4909383a 	mul	r4,r9,r4
 320e57c:	1806d43a 	srli	r3,r3,16
 320e580:	28bfffcc 	andi	r2,r5,65535
 320e584:	5085883a 	add	r2,r10,r2
 320e588:	2089883a 	add	r4,r4,r2
 320e58c:	48c7383a 	mul	r3,r9,r3
 320e590:	280ad43a 	srli	r5,r5,16
 320e594:	2004d43a 	srli	r2,r4,16
 320e598:	3900000d 	sth	r4,0(r7)
 320e59c:	1947883a 	add	r3,r3,r5
 320e5a0:	10c5883a 	add	r2,r2,r3
 320e5a4:	3880008d 	sth	r2,2(r7)
 320e5a8:	1014d43a 	srli	r10,r2,16
 320e5ac:	39c00104 	addi	r7,r7,4
 320e5b0:	42ffed36 	bltu	r8,r11,320e568 <__multiply+0xc4>
 320e5b4:	3a800015 	stw	r10,0(r7)
 320e5b8:	30800017 	ldw	r2,0(r6)
 320e5bc:	1012d43a 	srli	r9,r2,16
 320e5c0:	48001926 	beq	r9,zero,320e628 <__multiply+0x184>
 320e5c4:	60800017 	ldw	r2,0(r12)
 320e5c8:	6811883a 	mov	r8,r13
 320e5cc:	600f883a 	mov	r7,r12
 320e5d0:	0015883a 	mov	r10,zero
 320e5d4:	100b883a 	mov	r5,r2
 320e5d8:	41000017 	ldw	r4,0(r8)
 320e5dc:	2806d43a 	srli	r3,r5,16
 320e5e0:	3880000d 	sth	r2,0(r7)
 320e5e4:	20bfffcc 	andi	r2,r4,65535
 320e5e8:	4885383a 	mul	r2,r9,r2
 320e5ec:	50c7883a 	add	r3,r10,r3
 320e5f0:	2008d43a 	srli	r4,r4,16
 320e5f4:	10c5883a 	add	r2,r2,r3
 320e5f8:	3880008d 	sth	r2,2(r7)
 320e5fc:	39c00104 	addi	r7,r7,4
 320e600:	39400017 	ldw	r5,0(r7)
 320e604:	4909383a 	mul	r4,r9,r4
 320e608:	1004d43a 	srli	r2,r2,16
 320e60c:	28ffffcc 	andi	r3,r5,65535
 320e610:	20c9883a 	add	r4,r4,r3
 320e614:	1105883a 	add	r2,r2,r4
 320e618:	42000104 	addi	r8,r8,4
 320e61c:	1014d43a 	srli	r10,r2,16
 320e620:	42ffed36 	bltu	r8,r11,320e5d8 <__multiply+0x134>
 320e624:	38800015 	stw	r2,0(r7)
 320e628:	31800104 	addi	r6,r6,4
 320e62c:	33c0022e 	bgeu	r6,r15,320e638 <__multiply+0x194>
 320e630:	63000104 	addi	r12,r12,4
 320e634:	003fc606 	br	320e550 <__multiply+0xac>
 320e638:	0400090e 	bge	zero,r16,320e660 <__multiply+0x1bc>
 320e63c:	70bfff17 	ldw	r2,-4(r14)
 320e640:	70ffff04 	addi	r3,r14,-4
 320e644:	10000326 	beq	r2,zero,320e654 <__multiply+0x1b0>
 320e648:	00000506 	br	320e660 <__multiply+0x1bc>
 320e64c:	18800017 	ldw	r2,0(r3)
 320e650:	1000031e 	bne	r2,zero,320e660 <__multiply+0x1bc>
 320e654:	843fffc4 	addi	r16,r16,-1
 320e658:	18ffff04 	addi	r3,r3,-4
 320e65c:	803ffb1e 	bne	r16,zero,320e64c <__multiply+0x1a8>
 320e660:	a805883a 	mov	r2,r21
 320e664:	ac000415 	stw	r16,16(r21)
 320e668:	dfc00617 	ldw	ra,24(sp)
 320e66c:	dd400517 	ldw	r21,20(sp)
 320e670:	dd000417 	ldw	r20,16(sp)
 320e674:	dcc00317 	ldw	r19,12(sp)
 320e678:	dc800217 	ldw	r18,8(sp)
 320e67c:	dc400117 	ldw	r17,4(sp)
 320e680:	dc000017 	ldw	r16,0(sp)
 320e684:	dec00704 	addi	sp,sp,28
 320e688:	f800283a 	ret

0320e68c <__i2b>:
 320e68c:	defffd04 	addi	sp,sp,-12
 320e690:	dc000015 	stw	r16,0(sp)
 320e694:	04000044 	movi	r16,1
 320e698:	dc800115 	stw	r18,4(sp)
 320e69c:	2825883a 	mov	r18,r5
 320e6a0:	800b883a 	mov	r5,r16
 320e6a4:	dfc00215 	stw	ra,8(sp)
 320e6a8:	320df940 	call	320df94 <_Balloc>
 320e6ac:	14000415 	stw	r16,16(r2)
 320e6b0:	14800515 	stw	r18,20(r2)
 320e6b4:	dfc00217 	ldw	ra,8(sp)
 320e6b8:	dc800117 	ldw	r18,4(sp)
 320e6bc:	dc000017 	ldw	r16,0(sp)
 320e6c0:	dec00304 	addi	sp,sp,12
 320e6c4:	f800283a 	ret

0320e6c8 <__multadd>:
 320e6c8:	defffa04 	addi	sp,sp,-24
 320e6cc:	dc800215 	stw	r18,8(sp)
 320e6d0:	2c800417 	ldw	r18,16(r5)
 320e6d4:	dd000415 	stw	r20,16(sp)
 320e6d8:	dcc00315 	stw	r19,12(sp)
 320e6dc:	dc000015 	stw	r16,0(sp)
 320e6e0:	dfc00515 	stw	ra,20(sp)
 320e6e4:	3821883a 	mov	r16,r7
 320e6e8:	dc400115 	stw	r17,4(sp)
 320e6ec:	2827883a 	mov	r19,r5
 320e6f0:	2029883a 	mov	r20,r4
 320e6f4:	2a000504 	addi	r8,r5,20
 320e6f8:	000f883a 	mov	r7,zero
 320e6fc:	40800017 	ldw	r2,0(r8)
 320e700:	39c00044 	addi	r7,r7,1
 320e704:	10ffffcc 	andi	r3,r2,65535
 320e708:	1987383a 	mul	r3,r3,r6
 320e70c:	1004d43a 	srli	r2,r2,16
 320e710:	1c07883a 	add	r3,r3,r16
 320e714:	180ad43a 	srli	r5,r3,16
 320e718:	1185383a 	mul	r2,r2,r6
 320e71c:	18ffffcc 	andi	r3,r3,65535
 320e720:	1145883a 	add	r2,r2,r5
 320e724:	1008943a 	slli	r4,r2,16
 320e728:	1020d43a 	srli	r16,r2,16
 320e72c:	20c9883a 	add	r4,r4,r3
 320e730:	41000015 	stw	r4,0(r8)
 320e734:	42000104 	addi	r8,r8,4
 320e738:	3cbff016 	blt	r7,r18,320e6fc <__multadd+0x34>
 320e73c:	80000826 	beq	r16,zero,320e760 <__multadd+0x98>
 320e740:	98800217 	ldw	r2,8(r19)
 320e744:	90800f0e 	bge	r18,r2,320e784 <__multadd+0xbc>
 320e748:	9485883a 	add	r2,r18,r18
 320e74c:	1085883a 	add	r2,r2,r2
 320e750:	14c5883a 	add	r2,r2,r19
 320e754:	90c00044 	addi	r3,r18,1
 320e758:	14000515 	stw	r16,20(r2)
 320e75c:	98c00415 	stw	r3,16(r19)
 320e760:	9805883a 	mov	r2,r19
 320e764:	dfc00517 	ldw	ra,20(sp)
 320e768:	dd000417 	ldw	r20,16(sp)
 320e76c:	dcc00317 	ldw	r19,12(sp)
 320e770:	dc800217 	ldw	r18,8(sp)
 320e774:	dc400117 	ldw	r17,4(sp)
 320e778:	dc000017 	ldw	r16,0(sp)
 320e77c:	dec00604 	addi	sp,sp,24
 320e780:	f800283a 	ret
 320e784:	99400117 	ldw	r5,4(r19)
 320e788:	a009883a 	mov	r4,r20
 320e78c:	29400044 	addi	r5,r5,1
 320e790:	320df940 	call	320df94 <_Balloc>
 320e794:	99800417 	ldw	r6,16(r19)
 320e798:	99400304 	addi	r5,r19,12
 320e79c:	11000304 	addi	r4,r2,12
 320e7a0:	318d883a 	add	r6,r6,r6
 320e7a4:	318d883a 	add	r6,r6,r6
 320e7a8:	31800204 	addi	r6,r6,8
 320e7ac:	1023883a 	mov	r17,r2
 320e7b0:	32067cc0 	call	32067cc <memcpy>
 320e7b4:	980b883a 	mov	r5,r19
 320e7b8:	a009883a 	mov	r4,r20
 320e7bc:	320da140 	call	320da14 <_Bfree>
 320e7c0:	8827883a 	mov	r19,r17
 320e7c4:	003fe006 	br	320e748 <__multadd+0x80>

0320e7c8 <__pow5mult>:
 320e7c8:	defffa04 	addi	sp,sp,-24
 320e7cc:	308000cc 	andi	r2,r6,3
 320e7d0:	dd000415 	stw	r20,16(sp)
 320e7d4:	dcc00315 	stw	r19,12(sp)
 320e7d8:	dc000015 	stw	r16,0(sp)
 320e7dc:	dfc00515 	stw	ra,20(sp)
 320e7e0:	dc800215 	stw	r18,8(sp)
 320e7e4:	dc400115 	stw	r17,4(sp)
 320e7e8:	3021883a 	mov	r16,r6
 320e7ec:	2027883a 	mov	r19,r4
 320e7f0:	2829883a 	mov	r20,r5
 320e7f4:	10002b1e 	bne	r2,zero,320e8a4 <__pow5mult+0xdc>
 320e7f8:	8025d0ba 	srai	r18,r16,2
 320e7fc:	90001b26 	beq	r18,zero,320e86c <__pow5mult+0xa4>
 320e800:	9c001217 	ldw	r16,72(r19)
 320e804:	8000081e 	bne	r16,zero,320e828 <__pow5mult+0x60>
 320e808:	00003006 	br	320e8cc <__pow5mult+0x104>
 320e80c:	800b883a 	mov	r5,r16
 320e810:	800d883a 	mov	r6,r16
 320e814:	9809883a 	mov	r4,r19
 320e818:	90001426 	beq	r18,zero,320e86c <__pow5mult+0xa4>
 320e81c:	80800017 	ldw	r2,0(r16)
 320e820:	10001b26 	beq	r2,zero,320e890 <__pow5mult+0xc8>
 320e824:	1021883a 	mov	r16,r2
 320e828:	9080004c 	andi	r2,r18,1
 320e82c:	1005003a 	cmpeq	r2,r2,zero
 320e830:	9025d07a 	srai	r18,r18,1
 320e834:	800d883a 	mov	r6,r16
 320e838:	9809883a 	mov	r4,r19
 320e83c:	a00b883a 	mov	r5,r20
 320e840:	103ff21e 	bne	r2,zero,320e80c <__pow5mult+0x44>
 320e844:	320e4a40 	call	320e4a4 <__multiply>
 320e848:	a00b883a 	mov	r5,r20
 320e84c:	9809883a 	mov	r4,r19
 320e850:	1023883a 	mov	r17,r2
 320e854:	320da140 	call	320da14 <_Bfree>
 320e858:	8829883a 	mov	r20,r17
 320e85c:	800b883a 	mov	r5,r16
 320e860:	800d883a 	mov	r6,r16
 320e864:	9809883a 	mov	r4,r19
 320e868:	903fec1e 	bne	r18,zero,320e81c <__pow5mult+0x54>
 320e86c:	a005883a 	mov	r2,r20
 320e870:	dfc00517 	ldw	ra,20(sp)
 320e874:	dd000417 	ldw	r20,16(sp)
 320e878:	dcc00317 	ldw	r19,12(sp)
 320e87c:	dc800217 	ldw	r18,8(sp)
 320e880:	dc400117 	ldw	r17,4(sp)
 320e884:	dc000017 	ldw	r16,0(sp)
 320e888:	dec00604 	addi	sp,sp,24
 320e88c:	f800283a 	ret
 320e890:	320e4a40 	call	320e4a4 <__multiply>
 320e894:	80800015 	stw	r2,0(r16)
 320e898:	1021883a 	mov	r16,r2
 320e89c:	10000015 	stw	zero,0(r2)
 320e8a0:	003fe106 	br	320e828 <__pow5mult+0x60>
 320e8a4:	1085883a 	add	r2,r2,r2
 320e8a8:	00c0c974 	movhi	r3,805
 320e8ac:	18f82e04 	addi	r3,r3,-8008
 320e8b0:	1085883a 	add	r2,r2,r2
 320e8b4:	10c5883a 	add	r2,r2,r3
 320e8b8:	11bfff17 	ldw	r6,-4(r2)
 320e8bc:	000f883a 	mov	r7,zero
 320e8c0:	320e6c80 	call	320e6c8 <__multadd>
 320e8c4:	1029883a 	mov	r20,r2
 320e8c8:	003fcb06 	br	320e7f8 <__pow5mult+0x30>
 320e8cc:	9809883a 	mov	r4,r19
 320e8d0:	01409c44 	movi	r5,625
 320e8d4:	320e68c0 	call	320e68c <__i2b>
 320e8d8:	98801215 	stw	r2,72(r19)
 320e8dc:	1021883a 	mov	r16,r2
 320e8e0:	10000015 	stw	zero,0(r2)
 320e8e4:	003fd006 	br	320e828 <__pow5mult+0x60>

0320e8e8 <__s2b>:
 320e8e8:	defff904 	addi	sp,sp,-28
 320e8ec:	dcc00315 	stw	r19,12(sp)
 320e8f0:	dc800215 	stw	r18,8(sp)
 320e8f4:	2827883a 	mov	r19,r5
 320e8f8:	2025883a 	mov	r18,r4
 320e8fc:	01400244 	movi	r5,9
 320e900:	39000204 	addi	r4,r7,8
 320e904:	dd000415 	stw	r20,16(sp)
 320e908:	dc400115 	stw	r17,4(sp)
 320e90c:	dfc00615 	stw	ra,24(sp)
 320e910:	dd400515 	stw	r21,20(sp)
 320e914:	dc000015 	stw	r16,0(sp)
 320e918:	3829883a 	mov	r20,r7
 320e91c:	3023883a 	mov	r17,r6
 320e920:	32043fc0 	call	32043fc <__divsi3>
 320e924:	00c00044 	movi	r3,1
 320e928:	1880350e 	bge	r3,r2,320ea00 <__s2b+0x118>
 320e92c:	000b883a 	mov	r5,zero
 320e930:	18c7883a 	add	r3,r3,r3
 320e934:	29400044 	addi	r5,r5,1
 320e938:	18bffd16 	blt	r3,r2,320e930 <__s2b+0x48>
 320e93c:	9009883a 	mov	r4,r18
 320e940:	320df940 	call	320df94 <_Balloc>
 320e944:	1011883a 	mov	r8,r2
 320e948:	d8800717 	ldw	r2,28(sp)
 320e94c:	00c00044 	movi	r3,1
 320e950:	01800244 	movi	r6,9
 320e954:	40800515 	stw	r2,20(r8)
 320e958:	40c00415 	stw	r3,16(r8)
 320e95c:	3440260e 	bge	r6,r17,320e9f8 <__s2b+0x110>
 320e960:	3021883a 	mov	r16,r6
 320e964:	99ab883a 	add	r21,r19,r6
 320e968:	9c05883a 	add	r2,r19,r16
 320e96c:	11c00007 	ldb	r7,0(r2)
 320e970:	400b883a 	mov	r5,r8
 320e974:	9009883a 	mov	r4,r18
 320e978:	39fff404 	addi	r7,r7,-48
 320e97c:	01800284 	movi	r6,10
 320e980:	320e6c80 	call	320e6c8 <__multadd>
 320e984:	84000044 	addi	r16,r16,1
 320e988:	1011883a 	mov	r8,r2
 320e98c:	8c3ff61e 	bne	r17,r16,320e968 <__s2b+0x80>
 320e990:	ac45883a 	add	r2,r21,r17
 320e994:	117ffe04 	addi	r5,r2,-8
 320e998:	880d883a 	mov	r6,r17
 320e99c:	35000c0e 	bge	r6,r20,320e9d0 <__s2b+0xe8>
 320e9a0:	a185c83a 	sub	r2,r20,r6
 320e9a4:	2821883a 	mov	r16,r5
 320e9a8:	28a3883a 	add	r17,r5,r2
 320e9ac:	81c00007 	ldb	r7,0(r16)
 320e9b0:	400b883a 	mov	r5,r8
 320e9b4:	9009883a 	mov	r4,r18
 320e9b8:	39fff404 	addi	r7,r7,-48
 320e9bc:	01800284 	movi	r6,10
 320e9c0:	320e6c80 	call	320e6c8 <__multadd>
 320e9c4:	84000044 	addi	r16,r16,1
 320e9c8:	1011883a 	mov	r8,r2
 320e9cc:	847ff71e 	bne	r16,r17,320e9ac <__s2b+0xc4>
 320e9d0:	4005883a 	mov	r2,r8
 320e9d4:	dfc00617 	ldw	ra,24(sp)
 320e9d8:	dd400517 	ldw	r21,20(sp)
 320e9dc:	dd000417 	ldw	r20,16(sp)
 320e9e0:	dcc00317 	ldw	r19,12(sp)
 320e9e4:	dc800217 	ldw	r18,8(sp)
 320e9e8:	dc400117 	ldw	r17,4(sp)
 320e9ec:	dc000017 	ldw	r16,0(sp)
 320e9f0:	dec00704 	addi	sp,sp,28
 320e9f4:	f800283a 	ret
 320e9f8:	99400284 	addi	r5,r19,10
 320e9fc:	003fe706 	br	320e99c <__s2b+0xb4>
 320ea00:	000b883a 	mov	r5,zero
 320ea04:	003fcd06 	br	320e93c <__s2b+0x54>

0320ea08 <_read_r>:
 320ea08:	defffd04 	addi	sp,sp,-12
 320ea0c:	dc000015 	stw	r16,0(sp)
 320ea10:	0400c974 	movhi	r16,805
 320ea14:	84120d04 	addi	r16,r16,18484
 320ea18:	dc400115 	stw	r17,4(sp)
 320ea1c:	80000015 	stw	zero,0(r16)
 320ea20:	2023883a 	mov	r17,r4
 320ea24:	2809883a 	mov	r4,r5
 320ea28:	300b883a 	mov	r5,r6
 320ea2c:	380d883a 	mov	r6,r7
 320ea30:	dfc00215 	stw	ra,8(sp)
 320ea34:	32229740 	call	3222974 <read>
 320ea38:	1007883a 	mov	r3,r2
 320ea3c:	00bfffc4 	movi	r2,-1
 320ea40:	18800626 	beq	r3,r2,320ea5c <_read_r+0x54>
 320ea44:	1805883a 	mov	r2,r3
 320ea48:	dfc00217 	ldw	ra,8(sp)
 320ea4c:	dc400117 	ldw	r17,4(sp)
 320ea50:	dc000017 	ldw	r16,0(sp)
 320ea54:	dec00304 	addi	sp,sp,12
 320ea58:	f800283a 	ret
 320ea5c:	80800017 	ldw	r2,0(r16)
 320ea60:	103ff826 	beq	r2,zero,320ea44 <_read_r+0x3c>
 320ea64:	88800015 	stw	r2,0(r17)
 320ea68:	1805883a 	mov	r2,r3
 320ea6c:	dfc00217 	ldw	ra,8(sp)
 320ea70:	dc400117 	ldw	r17,4(sp)
 320ea74:	dc000017 	ldw	r16,0(sp)
 320ea78:	dec00304 	addi	sp,sp,12
 320ea7c:	f800283a 	ret

0320ea80 <__isinfd>:
 320ea80:	200d883a 	mov	r6,r4
 320ea84:	0109c83a 	sub	r4,zero,r4
 320ea88:	2188b03a 	or	r4,r4,r6
 320ea8c:	2008d7fa 	srli	r4,r4,31
 320ea90:	00a00034 	movhi	r2,32768
 320ea94:	10bfffc4 	addi	r2,r2,-1
 320ea98:	1144703a 	and	r2,r2,r5
 320ea9c:	2088b03a 	or	r4,r4,r2
 320eaa0:	009ffc34 	movhi	r2,32752
 320eaa4:	1105c83a 	sub	r2,r2,r4
 320eaa8:	0087c83a 	sub	r3,zero,r2
 320eaac:	10c4b03a 	or	r2,r2,r3
 320eab0:	1004d7fa 	srli	r2,r2,31
 320eab4:	00c00044 	movi	r3,1
 320eab8:	1885c83a 	sub	r2,r3,r2
 320eabc:	f800283a 	ret

0320eac0 <__isnand>:
 320eac0:	200d883a 	mov	r6,r4
 320eac4:	0109c83a 	sub	r4,zero,r4
 320eac8:	2188b03a 	or	r4,r4,r6
 320eacc:	2008d7fa 	srli	r4,r4,31
 320ead0:	00a00034 	movhi	r2,32768
 320ead4:	10bfffc4 	addi	r2,r2,-1
 320ead8:	1144703a 	and	r2,r2,r5
 320eadc:	2088b03a 	or	r4,r4,r2
 320eae0:	009ffc34 	movhi	r2,32752
 320eae4:	1105c83a 	sub	r2,r2,r4
 320eae8:	1004d7fa 	srli	r2,r2,31
 320eaec:	f800283a 	ret

0320eaf0 <__sccl>:
 320eaf0:	28c00003 	ldbu	r3,0(r5)
 320eaf4:	00801784 	movi	r2,94
 320eaf8:	2a000044 	addi	r8,r5,1
 320eafc:	18802526 	beq	r3,r2,320eb94 <__sccl+0xa4>
 320eb00:	180f883a 	mov	r7,r3
 320eb04:	0013883a 	mov	r9,zero
 320eb08:	000d883a 	mov	r6,zero
 320eb0c:	0007883a 	mov	r3,zero
 320eb10:	01404004 	movi	r5,256
 320eb14:	1905883a 	add	r2,r3,r4
 320eb18:	18c00044 	addi	r3,r3,1
 320eb1c:	11800005 	stb	r6,0(r2)
 320eb20:	197ffc1e 	bne	r3,r5,320eb14 <__sccl+0x24>
 320eb24:	38000c26 	beq	r7,zero,320eb58 <__sccl+0x68>
 320eb28:	00800044 	movi	r2,1
 320eb2c:	124dc83a 	sub	r6,r2,r9
 320eb30:	3905883a 	add	r2,r7,r4
 320eb34:	11800005 	stb	r6,0(r2)
 320eb38:	41400044 	addi	r5,r8,1
 320eb3c:	02400b44 	movi	r9,45
 320eb40:	02801744 	movi	r10,93
 320eb44:	28bfffc3 	ldbu	r2,-1(r5)
 320eb48:	2811883a 	mov	r8,r5
 320eb4c:	12400726 	beq	r2,r9,320eb6c <__sccl+0x7c>
 320eb50:	12800226 	beq	r2,r10,320eb5c <__sccl+0x6c>
 320eb54:	1000031e 	bne	r2,zero,320eb64 <__sccl+0x74>
 320eb58:	423fffc4 	addi	r8,r8,-1
 320eb5c:	4005883a 	mov	r2,r8
 320eb60:	f800283a 	ret
 320eb64:	100f883a 	mov	r7,r2
 320eb68:	003ff106 	br	320eb30 <__sccl+0x40>
 320eb6c:	28c00003 	ldbu	r3,0(r5)
 320eb70:	1a800d26 	beq	r3,r10,320eba8 <__sccl+0xb8>
 320eb74:	19c00c16 	blt	r3,r7,320eba8 <__sccl+0xb8>
 320eb78:	21c5883a 	add	r2,r4,r7
 320eb7c:	39c00044 	addi	r7,r7,1
 320eb80:	11800045 	stb	r6,1(r2)
 320eb84:	10800044 	addi	r2,r2,1
 320eb88:	38fffc16 	blt	r7,r3,320eb7c <__sccl+0x8c>
 320eb8c:	29400084 	addi	r5,r5,2
 320eb90:	003fec06 	br	320eb44 <__sccl+0x54>
 320eb94:	29c00043 	ldbu	r7,1(r5)
 320eb98:	02400044 	movi	r9,1
 320eb9c:	2a000084 	addi	r8,r5,2
 320eba0:	480d883a 	mov	r6,r9
 320eba4:	003fd906 	br	320eb0c <__sccl+0x1c>
 320eba8:	01c00b44 	movi	r7,45
 320ebac:	003fe006 	br	320eb30 <__sccl+0x40>

0320ebb0 <nanf>:
 320ebb0:	009ff034 	movhi	r2,32704
 320ebb4:	f800283a 	ret

0320ebb8 <strcmp>:
 320ebb8:	2144b03a 	or	r2,r4,r5
 320ebbc:	108000cc 	andi	r2,r2,3
 320ebc0:	10001d1e 	bne	r2,zero,320ec38 <strcmp+0x80>
 320ebc4:	200f883a 	mov	r7,r4
 320ebc8:	28800017 	ldw	r2,0(r5)
 320ebcc:	21000017 	ldw	r4,0(r4)
 320ebd0:	280d883a 	mov	r6,r5
 320ebd4:	2080161e 	bne	r4,r2,320ec30 <strcmp+0x78>
 320ebd8:	023fbff4 	movhi	r8,65279
 320ebdc:	423fbfc4 	addi	r8,r8,-257
 320ebe0:	2207883a 	add	r3,r4,r8
 320ebe4:	01602074 	movhi	r5,32897
 320ebe8:	29602004 	addi	r5,r5,-32640
 320ebec:	1946703a 	and	r3,r3,r5
 320ebf0:	0104303a 	nor	r2,zero,r4
 320ebf4:	10c4703a 	and	r2,r2,r3
 320ebf8:	10001c1e 	bne	r2,zero,320ec6c <strcmp+0xb4>
 320ebfc:	4013883a 	mov	r9,r8
 320ec00:	2811883a 	mov	r8,r5
 320ec04:	00000106 	br	320ec0c <strcmp+0x54>
 320ec08:	1800181e 	bne	r3,zero,320ec6c <strcmp+0xb4>
 320ec0c:	39c00104 	addi	r7,r7,4
 320ec10:	39000017 	ldw	r4,0(r7)
 320ec14:	31800104 	addi	r6,r6,4
 320ec18:	31400017 	ldw	r5,0(r6)
 320ec1c:	2245883a 	add	r2,r4,r9
 320ec20:	1204703a 	and	r2,r2,r8
 320ec24:	0106303a 	nor	r3,zero,r4
 320ec28:	1886703a 	and	r3,r3,r2
 320ec2c:	217ff626 	beq	r4,r5,320ec08 <strcmp+0x50>
 320ec30:	3809883a 	mov	r4,r7
 320ec34:	300b883a 	mov	r5,r6
 320ec38:	20c00007 	ldb	r3,0(r4)
 320ec3c:	1800051e 	bne	r3,zero,320ec54 <strcmp+0x9c>
 320ec40:	00000606 	br	320ec5c <strcmp+0xa4>
 320ec44:	21000044 	addi	r4,r4,1
 320ec48:	20c00007 	ldb	r3,0(r4)
 320ec4c:	29400044 	addi	r5,r5,1
 320ec50:	18000226 	beq	r3,zero,320ec5c <strcmp+0xa4>
 320ec54:	28800007 	ldb	r2,0(r5)
 320ec58:	18bffa26 	beq	r3,r2,320ec44 <strcmp+0x8c>
 320ec5c:	20c00003 	ldbu	r3,0(r4)
 320ec60:	28800003 	ldbu	r2,0(r5)
 320ec64:	1885c83a 	sub	r2,r3,r2
 320ec68:	f800283a 	ret
 320ec6c:	0005883a 	mov	r2,zero
 320ec70:	f800283a 	ret

0320ec74 <match>:
 320ec74:	21800017 	ldw	r6,0(r4)
 320ec78:	01c01004 	movi	r7,64
 320ec7c:	02001684 	movi	r8,90
 320ec80:	28800007 	ldb	r2,0(r5)
 320ec84:	29400044 	addi	r5,r5,1
 320ec88:	10000826 	beq	r2,zero,320ecac <match+0x38>
 320ec8c:	31800044 	addi	r6,r6,1
 320ec90:	30c00007 	ldb	r3,0(r6)
 320ec94:	38c0020e 	bge	r7,r3,320eca0 <match+0x2c>
 320ec98:	40c00116 	blt	r8,r3,320eca0 <match+0x2c>
 320ec9c:	18c00804 	addi	r3,r3,32
 320eca0:	18bff726 	beq	r3,r2,320ec80 <match+0xc>
 320eca4:	0005883a 	mov	r2,zero
 320eca8:	f800283a 	ret
 320ecac:	30800044 	addi	r2,r6,1
 320ecb0:	20800015 	stw	r2,0(r4)
 320ecb4:	00800044 	movi	r2,1
 320ecb8:	f800283a 	ret

0320ecbc <_strtod_r>:
 320ecbc:	deffde04 	addi	sp,sp,-136
 320ecc0:	df002015 	stw	fp,128(sp)
 320ecc4:	dd401d15 	stw	r21,116(sp)
 320ecc8:	dc401915 	stw	r17,100(sp)
 320eccc:	dfc02115 	stw	ra,132(sp)
 320ecd0:	ddc01f15 	stw	r23,124(sp)
 320ecd4:	dd801e15 	stw	r22,120(sp)
 320ecd8:	dd001c15 	stw	r20,112(sp)
 320ecdc:	dcc01b15 	stw	r19,108(sp)
 320ece0:	dc801a15 	stw	r18,104(sp)
 320ece4:	dc001815 	stw	r16,96(sp)
 320ece8:	2823883a 	mov	r17,r5
 320ecec:	202b883a 	mov	r21,r4
 320ecf0:	d9801515 	stw	r6,84(sp)
 320ecf4:	d8000915 	stw	zero,36(sp)
 320ecf8:	d8000a15 	stw	zero,40(sp)
 320ecfc:	d9400415 	stw	r5,16(sp)
 320ed00:	df000904 	addi	fp,sp,36
 320ed04:	da000417 	ldw	r8,16(sp)
 320ed08:	00800b44 	movi	r2,45
 320ed0c:	40c00003 	ldbu	r3,0(r8)
 320ed10:	10c03536 	bltu	r2,r3,320ede8 <_strtod_r+0x12c>
 320ed14:	18c5883a 	add	r2,r3,r3
 320ed18:	1085883a 	add	r2,r2,r2
 320ed1c:	00c0c874 	movhi	r3,801
 320ed20:	18fb4c04 	addi	r3,r3,-4816
 320ed24:	10c5883a 	add	r2,r2,r3
 320ed28:	11000017 	ldw	r4,0(r2)
 320ed2c:	2000683a 	jmp	r4
 320ed30:	0320ef24 	muli	r12,zero,-31812
 320ed34:	0320ede8 	cmpgeui	r12,zero,33719
 320ed38:	0320ede8 	cmpgeui	r12,zero,33719
 320ed3c:	0320ede8 	cmpgeui	r12,zero,33719
 320ed40:	0320ede8 	cmpgeui	r12,zero,33719
 320ed44:	0320ede8 	cmpgeui	r12,zero,33719
 320ed48:	0320ede8 	cmpgeui	r12,zero,33719
 320ed4c:	0320ede8 	cmpgeui	r12,zero,33719
 320ed50:	0320ede8 	cmpgeui	r12,zero,33719
 320ed54:	0320f23c 	xorhi	r12,zero,33736
 320ed58:	0320f23c 	xorhi	r12,zero,33736
 320ed5c:	0320f23c 	xorhi	r12,zero,33736
 320ed60:	0320f23c 	xorhi	r12,zero,33736
 320ed64:	0320f23c 	xorhi	r12,zero,33736
 320ed68:	0320ede8 	cmpgeui	r12,zero,33719
 320ed6c:	0320ede8 	cmpgeui	r12,zero,33719
 320ed70:	0320ede8 	cmpgeui	r12,zero,33719
 320ed74:	0320ede8 	cmpgeui	r12,zero,33719
 320ed78:	0320ede8 	cmpgeui	r12,zero,33719
 320ed7c:	0320ede8 	cmpgeui	r12,zero,33719
 320ed80:	0320ede8 	cmpgeui	r12,zero,33719
 320ed84:	0320ede8 	cmpgeui	r12,zero,33719
 320ed88:	0320ede8 	cmpgeui	r12,zero,33719
 320ed8c:	0320ede8 	cmpgeui	r12,zero,33719
 320ed90:	0320ede8 	cmpgeui	r12,zero,33719
 320ed94:	0320ede8 	cmpgeui	r12,zero,33719
 320ed98:	0320ede8 	cmpgeui	r12,zero,33719
 320ed9c:	0320ede8 	cmpgeui	r12,zero,33719
 320eda0:	0320ede8 	cmpgeui	r12,zero,33719
 320eda4:	0320ede8 	cmpgeui	r12,zero,33719
 320eda8:	0320ede8 	cmpgeui	r12,zero,33719
 320edac:	0320ede8 	cmpgeui	r12,zero,33719
 320edb0:	0320f23c 	xorhi	r12,zero,33736
 320edb4:	0320ede8 	cmpgeui	r12,zero,33719
 320edb8:	0320ede8 	cmpgeui	r12,zero,33719
 320edbc:	0320ede8 	cmpgeui	r12,zero,33719
 320edc0:	0320ede8 	cmpgeui	r12,zero,33719
 320edc4:	0320ede8 	cmpgeui	r12,zero,33719
 320edc8:	0320ede8 	cmpgeui	r12,zero,33719
 320edcc:	0320ede8 	cmpgeui	r12,zero,33719
 320edd0:	0320ede8 	cmpgeui	r12,zero,33719
 320edd4:	0320ede8 	cmpgeui	r12,zero,33719
 320edd8:	0320ede8 	cmpgeui	r12,zero,33719
 320eddc:	0320f21c 	xori	r12,zero,33736
 320ede0:	0320ede8 	cmpgeui	r12,zero,33719
 320ede4:	0320f248 	cmpgei	r12,zero,-31799
 320ede8:	d8001115 	stw	zero,68(sp)
 320edec:	40c00007 	ldb	r3,0(r8)
 320edf0:	00800c04 	movi	r2,48
 320edf4:	1880d026 	beq	r3,r2,320f138 <_strtod_r+0x47c>
 320edf8:	001f883a 	mov	r15,zero
 320edfc:	41000007 	ldb	r4,0(r8)
 320ee00:	00c00bc4 	movi	r3,47
 320ee04:	402d883a 	mov	r22,r8
 320ee08:	1903470e 	bge	r3,r4,320fb28 <_strtod_r+0xe6c>
 320ee0c:	00800e44 	movi	r2,57
 320ee10:	11034516 	blt	r2,r4,320fb28 <_strtod_r+0xe6c>
 320ee14:	180f883a 	mov	r7,r3
 320ee18:	1013883a 	mov	r9,r2
 320ee1c:	4007883a 	mov	r3,r8
 320ee20:	000d883a 	mov	r6,zero
 320ee24:	0029883a 	mov	r20,zero
 320ee28:	0021883a 	mov	r16,zero
 320ee2c:	01400204 	movi	r5,8
 320ee30:	028003c4 	movi	r10,15
 320ee34:	29803116 	blt	r5,r6,320eefc <_strtod_r+0x240>
 320ee38:	a08002a4 	muli	r2,r20,10
 320ee3c:	1105883a 	add	r2,r2,r4
 320ee40:	153ff404 	addi	r20,r2,-48
 320ee44:	1a000044 	addi	r8,r3,1
 320ee48:	da000415 	stw	r8,16(sp)
 320ee4c:	41000007 	ldb	r4,0(r8)
 320ee50:	31800044 	addi	r6,r6,1
 320ee54:	4007883a 	mov	r3,r8
 320ee58:	3900010e 	bge	r7,r4,320ee60 <_strtod_r+0x1a4>
 320ee5c:	493ff50e 	bge	r9,r4,320ee34 <_strtod_r+0x178>
 320ee60:	00800b84 	movi	r2,46
 320ee64:	2080c126 	beq	r4,r2,320f16c <_strtod_r+0x4b0>
 320ee68:	3027883a 	mov	r19,r6
 320ee6c:	0025883a 	mov	r18,zero
 320ee70:	0015883a 	mov	r10,zero
 320ee74:	000f883a 	mov	r7,zero
 320ee78:	00801944 	movi	r2,101
 320ee7c:	20802426 	beq	r4,r2,320ef10 <_strtod_r+0x254>
 320ee80:	00801144 	movi	r2,69
 320ee84:	20802226 	beq	r4,r2,320ef10 <_strtod_r+0x254>
 320ee88:	9816c03a 	cmpne	r11,r19,zero
 320ee8c:	000b883a 	mov	r5,zero
 320ee90:	5800631e 	bne	r11,zero,320f020 <_strtod_r+0x364>
 320ee94:	3800c126 	beq	r7,zero,320f19c <_strtod_r+0x4e0>
 320ee98:	d8c01517 	ldw	r3,84(sp)
 320ee9c:	18000226 	beq	r3,zero,320eea8 <_strtod_r+0x1ec>
 320eea0:	d8800417 	ldw	r2,16(sp)
 320eea4:	18800015 	stw	r2,0(r3)
 320eea8:	d9001117 	ldw	r4,68(sp)
 320eeac:	2005003a 	cmpeq	r2,r4,zero
 320eeb0:	10001f1e 	bne	r2,zero,320ef30 <_strtod_r+0x274>
 320eeb4:	e0800017 	ldw	r2,0(fp)
 320eeb8:	e0c00117 	ldw	r3,4(fp)
 320eebc:	1009883a 	mov	r4,r2
 320eec0:	1960003c 	xorhi	r5,r3,32768
 320eec4:	2005883a 	mov	r2,r4
 320eec8:	2807883a 	mov	r3,r5
 320eecc:	dfc02117 	ldw	ra,132(sp)
 320eed0:	df002017 	ldw	fp,128(sp)
 320eed4:	ddc01f17 	ldw	r23,124(sp)
 320eed8:	dd801e17 	ldw	r22,120(sp)
 320eedc:	dd401d17 	ldw	r21,116(sp)
 320eee0:	dd001c17 	ldw	r20,112(sp)
 320eee4:	dcc01b17 	ldw	r19,108(sp)
 320eee8:	dc801a17 	ldw	r18,104(sp)
 320eeec:	dc401917 	ldw	r17,100(sp)
 320eef0:	dc001817 	ldw	r16,96(sp)
 320eef4:	dec02204 	addi	sp,sp,136
 320eef8:	f800283a 	ret
 320eefc:	51bfd116 	blt	r10,r6,320ee44 <_strtod_r+0x188>
 320ef00:	808002a4 	muli	r2,r16,10
 320ef04:	1105883a 	add	r2,r2,r4
 320ef08:	143ff404 	addi	r16,r2,-48
 320ef0c:	003fcd06 	br	320ee44 <_strtod_r+0x188>
 320ef10:	9816c03a 	cmpne	r11,r19,zero
 320ef14:	5800091e 	bne	r11,zero,320ef3c <_strtod_r+0x280>
 320ef18:	3800081e 	bne	r7,zero,320ef3c <_strtod_r+0x280>
 320ef1c:	7805003a 	cmpeq	r2,r15,zero
 320ef20:	10000626 	beq	r2,zero,320ef3c <_strtod_r+0x280>
 320ef24:	d8001115 	stw	zero,68(sp)
 320ef28:	dc400415 	stw	r17,16(sp)
 320ef2c:	003fda06 	br	320ee98 <_strtod_r+0x1dc>
 320ef30:	e1000017 	ldw	r4,0(fp)
 320ef34:	e1400117 	ldw	r5,4(fp)
 320ef38:	003fe206 	br	320eec4 <_strtod_r+0x208>
 320ef3c:	dc400417 	ldw	r17,16(sp)
 320ef40:	00800ac4 	movi	r2,43
 320ef44:	8a000044 	addi	r8,r17,1
 320ef48:	da000415 	stw	r8,16(sp)
 320ef4c:	88c00047 	ldb	r3,1(r17)
 320ef50:	4009883a 	mov	r4,r8
 320ef54:	1880bf26 	beq	r3,r2,320f254 <_strtod_r+0x598>
 320ef58:	00800b44 	movi	r2,45
 320ef5c:	18834526 	beq	r3,r2,320fc74 <_strtod_r+0xfb8>
 320ef60:	1809883a 	mov	r4,r3
 320ef64:	20fff404 	addi	r3,r4,-48
 320ef68:	00800244 	movi	r2,9
 320ef6c:	001d883a 	mov	r14,zero
 320ef70:	10c0bf36 	bltu	r2,r3,320f270 <_strtod_r+0x5b4>
 320ef74:	00800c04 	movi	r2,48
 320ef78:	2080061e 	bne	r4,r2,320ef94 <_strtod_r+0x2d8>
 320ef7c:	da000417 	ldw	r8,16(sp)
 320ef80:	2005883a 	mov	r2,r4
 320ef84:	42000044 	addi	r8,r8,1
 320ef88:	da000415 	stw	r8,16(sp)
 320ef8c:	41000007 	ldb	r4,0(r8)
 320ef90:	20bffc26 	beq	r4,r2,320ef84 <_strtod_r+0x2c8>
 320ef94:	20fff3c4 	addi	r3,r4,-49
 320ef98:	00800204 	movi	r2,8
 320ef9c:	10ffbb36 	bltu	r2,r3,320ee8c <_strtod_r+0x1d0>
 320efa0:	da000417 	ldw	r8,16(sp)
 320efa4:	227ff404 	addi	r9,r4,-48
 320efa8:	03000bc4 	movi	r12,47
 320efac:	4007883a 	mov	r3,r8
 320efb0:	42000044 	addi	r8,r8,1
 320efb4:	da000415 	stw	r8,16(sp)
 320efb8:	41000007 	ldb	r4,0(r8)
 320efbc:	61000d0e 	bge	r12,r4,320eff4 <_strtod_r+0x338>
 320efc0:	00800e44 	movi	r2,57
 320efc4:	11000b16 	blt	r2,r4,320eff4 <_strtod_r+0x338>
 320efc8:	601b883a 	mov	r13,r12
 320efcc:	1019883a 	mov	r12,r2
 320efd0:	00000106 	br	320efd8 <_strtod_r+0x31c>
 320efd4:	61000716 	blt	r12,r4,320eff4 <_strtod_r+0x338>
 320efd8:	488002a4 	muli	r2,r9,10
 320efdc:	42000044 	addi	r8,r8,1
 320efe0:	da000415 	stw	r8,16(sp)
 320efe4:	2085883a 	add	r2,r4,r2
 320efe8:	41000007 	ldb	r4,0(r8)
 320efec:	127ff404 	addi	r9,r2,-48
 320eff0:	693ff816 	blt	r13,r4,320efd4 <_strtod_r+0x318>
 320eff4:	40c7c83a 	sub	r3,r8,r3
 320eff8:	00800204 	movi	r2,8
 320effc:	10c2e416 	blt	r2,r3,320fb90 <_strtod_r+0xed4>
 320f000:	009387c4 	movi	r2,19999
 320f004:	480b883a 	mov	r5,r9
 320f008:	1240010e 	bge	r2,r9,320f010 <_strtod_r+0x354>
 320f00c:	100b883a 	mov	r5,r2
 320f010:	7005003a 	cmpeq	r2,r14,zero
 320f014:	103f9e1e 	bne	r2,zero,320ee90 <_strtod_r+0x1d4>
 320f018:	014bc83a 	sub	r5,zero,r5
 320f01c:	583f9d26 	beq	r11,zero,320ee94 <_strtod_r+0x1d8>
 320f020:	2a8bc83a 	sub	r5,r5,r10
 320f024:	d9400f15 	stw	r5,60(sp)
 320f028:	30007a1e 	bne	r6,zero,320f214 <_strtod_r+0x558>
 320f02c:	dcc01215 	stw	r19,72(sp)
 320f030:	00800404 	movi	r2,16
 320f034:	9825883a 	mov	r18,r19
 320f038:	14c0010e 	bge	r2,r19,320f040 <_strtod_r+0x384>
 320f03c:	1025883a 	mov	r18,r2
 320f040:	a009883a 	mov	r4,r20
 320f044:	3213b380 	call	3213b38 <__floatunsidf>
 320f048:	100f883a 	mov	r7,r2
 320f04c:	e0800015 	stw	r2,0(fp)
 320f050:	00800244 	movi	r2,9
 320f054:	e0c00115 	stw	r3,4(fp)
 320f058:	1480160e 	bge	r2,r18,320f0b4 <_strtod_r+0x3f8>
 320f05c:	900c90fa 	slli	r6,r18,3
 320f060:	0100c974 	movhi	r4,805
 320f064:	2137e804 	addi	r4,r4,-8288
 320f068:	180b883a 	mov	r5,r3
 320f06c:	310d883a 	add	r6,r6,r4
 320f070:	30ffef17 	ldw	r3,-68(r6)
 320f074:	30bfee17 	ldw	r2,-72(r6)
 320f078:	3809883a 	mov	r4,r7
 320f07c:	180f883a 	mov	r7,r3
 320f080:	100d883a 	mov	r6,r2
 320f084:	3212fa80 	call	3212fa8 <__muldf3>
 320f088:	8009883a 	mov	r4,r16
 320f08c:	1823883a 	mov	r17,r3
 320f090:	1021883a 	mov	r16,r2
 320f094:	3213b380 	call	3213b38 <__floatunsidf>
 320f098:	880b883a 	mov	r5,r17
 320f09c:	180f883a 	mov	r7,r3
 320f0a0:	8009883a 	mov	r4,r16
 320f0a4:	100d883a 	mov	r6,r2
 320f0a8:	3212f340 	call	3212f34 <__adddf3>
 320f0ac:	e0c00115 	stw	r3,4(fp)
 320f0b0:	e0800015 	stw	r2,0(fp)
 320f0b4:	010003c4 	movi	r4,15
 320f0b8:	24c09816 	blt	r4,r19,320f31c <_strtod_r+0x660>
 320f0bc:	d9800f17 	ldw	r6,60(sp)
 320f0c0:	303f7526 	beq	r6,zero,320ee98 <_strtod_r+0x1dc>
 320f0c4:	0183be0e 	bge	zero,r6,320ffc0 <_strtod_r+0x1304>
 320f0c8:	00800584 	movi	r2,22
 320f0cc:	1182b20e 	bge	r2,r6,320fb98 <_strtod_r+0xedc>
 320f0d0:	d8c00f17 	ldw	r3,60(sp)
 320f0d4:	24e3c83a 	sub	r17,r4,r19
 320f0d8:	88800584 	addi	r2,r17,22
 320f0dc:	10c08f16 	blt	r2,r3,320f31c <_strtod_r+0x660>
 320f0e0:	880890fa 	slli	r4,r17,3
 320f0e4:	0400c974 	movhi	r16,805
 320f0e8:	8437e804 	addi	r16,r16,-8288
 320f0ec:	e0800017 	ldw	r2,0(fp)
 320f0f0:	2409883a 	add	r4,r4,r16
 320f0f4:	22000017 	ldw	r8,0(r4)
 320f0f8:	22400117 	ldw	r9,4(r4)
 320f0fc:	e0c00117 	ldw	r3,4(fp)
 320f100:	1009883a 	mov	r4,r2
 320f104:	480f883a 	mov	r7,r9
 320f108:	180b883a 	mov	r5,r3
 320f10c:	400d883a 	mov	r6,r8
 320f110:	3212fa80 	call	3212fa8 <__muldf3>
 320f114:	d9000f17 	ldw	r4,60(sp)
 320f118:	180b883a 	mov	r5,r3
 320f11c:	2455c83a 	sub	r10,r4,r17
 320f120:	501490fa 	slli	r10,r10,3
 320f124:	1009883a 	mov	r4,r2
 320f128:	5415883a 	add	r10,r10,r16
 320f12c:	52000017 	ldw	r8,0(r10)
 320f130:	52400117 	ldw	r9,4(r10)
 320f134:	0002a206 	br	320fbc0 <_strtod_r+0xf04>
 320f138:	40c00047 	ldb	r3,1(r8)
 320f13c:	00801604 	movi	r2,88
 320f140:	18804e26 	beq	r3,r2,320f27c <_strtod_r+0x5c0>
 320f144:	00801e04 	movi	r2,120
 320f148:	18804c26 	beq	r3,r2,320f27c <_strtod_r+0x5c0>
 320f14c:	42000044 	addi	r8,r8,1
 320f150:	da000415 	stw	r8,16(sp)
 320f154:	40c00007 	ldb	r3,0(r8)
 320f158:	00800c04 	movi	r2,48
 320f15c:	18bffb26 	beq	r3,r2,320f14c <_strtod_r+0x490>
 320f160:	183f4d26 	beq	r3,zero,320ee98 <_strtod_r+0x1dc>
 320f164:	03c00044 	movi	r15,1
 320f168:	003f2406 	br	320edfc <_strtod_r+0x140>
 320f16c:	42000044 	addi	r8,r8,1
 320f170:	da000415 	stw	r8,16(sp)
 320f174:	19000047 	ldb	r4,1(r3)
 320f178:	3000b726 	beq	r6,zero,320f458 <_strtod_r+0x79c>
 320f17c:	3027883a 	mov	r19,r6
 320f180:	0015883a 	mov	r10,zero
 320f184:	000f883a 	mov	r7,zero
 320f188:	227ff404 	addi	r9,r4,-48
 320f18c:	00800244 	movi	r2,9
 320f190:	1242592e 	bgeu	r2,r9,320faf8 <_strtod_r+0xe3c>
 320f194:	04800044 	movi	r18,1
 320f198:	003f3706 	br	320ee78 <_strtod_r+0x1bc>
 320f19c:	7804c03a 	cmpne	r2,r15,zero
 320f1a0:	103f3d1e 	bne	r2,zero,320ee98 <_strtod_r+0x1dc>
 320f1a4:	9004c03a 	cmpne	r2,r18,zero
 320f1a8:	103f5e1e 	bne	r2,zero,320ef24 <_strtod_r+0x268>
 320f1ac:	00801384 	movi	r2,78
 320f1b0:	2083a226 	beq	r4,r2,321003c <_strtod_r+0x1380>
 320f1b4:	11039d16 	blt	r2,r4,321002c <_strtod_r+0x1370>
 320f1b8:	00801244 	movi	r2,73
 320f1bc:	20bf591e 	bne	r4,r2,320ef24 <_strtod_r+0x268>
 320f1c0:	dc000404 	addi	r16,sp,16
 320f1c4:	8009883a 	mov	r4,r16
 320f1c8:	0140c974 	movhi	r5,805
 320f1cc:	29783104 	addi	r5,r5,-7996
 320f1d0:	320ec740 	call	320ec74 <match>
 320f1d4:	103f5326 	beq	r2,zero,320ef24 <_strtod_r+0x268>
 320f1d8:	d8800417 	ldw	r2,16(sp)
 320f1dc:	8009883a 	mov	r4,r16
 320f1e0:	0140c974 	movhi	r5,805
 320f1e4:	29783204 	addi	r5,r5,-7992
 320f1e8:	123fffc4 	addi	r8,r2,-1
 320f1ec:	da000415 	stw	r8,16(sp)
 320f1f0:	320ec740 	call	320ec74 <match>
 320f1f4:	1000031e 	bne	r2,zero,320f204 <_strtod_r+0x548>
 320f1f8:	d8800417 	ldw	r2,16(sp)
 320f1fc:	12000044 	addi	r8,r2,1
 320f200:	da000415 	stw	r8,16(sp)
 320f204:	019ffc34 	movhi	r6,32752
 320f208:	e1800115 	stw	r6,4(fp)
 320f20c:	e0000015 	stw	zero,0(fp)
 320f210:	003f2106 	br	320ee98 <_strtod_r+0x1dc>
 320f214:	d9801215 	stw	r6,72(sp)
 320f218:	003f8506 	br	320f030 <_strtod_r+0x374>
 320f21c:	d8001115 	stw	zero,68(sp)
 320f220:	42000044 	addi	r8,r8,1
 320f224:	da000415 	stw	r8,16(sp)
 320f228:	40800007 	ldb	r2,0(r8)
 320f22c:	103eef1e 	bne	r2,zero,320edec <_strtod_r+0x130>
 320f230:	d8001115 	stw	zero,68(sp)
 320f234:	dc400415 	stw	r17,16(sp)
 320f238:	003f1706 	br	320ee98 <_strtod_r+0x1dc>
 320f23c:	42000044 	addi	r8,r8,1
 320f240:	da000415 	stw	r8,16(sp)
 320f244:	003eaf06 	br	320ed04 <_strtod_r+0x48>
 320f248:	00800044 	movi	r2,1
 320f24c:	d8801115 	stw	r2,68(sp)
 320f250:	003ff306 	br	320f220 <_strtod_r+0x564>
 320f254:	001d883a 	mov	r14,zero
 320f258:	42000044 	addi	r8,r8,1
 320f25c:	da000415 	stw	r8,16(sp)
 320f260:	21000047 	ldb	r4,1(r4)
 320f264:	00800244 	movi	r2,9
 320f268:	20fff404 	addi	r3,r4,-48
 320f26c:	10ff412e 	bgeu	r2,r3,320ef74 <_strtod_r+0x2b8>
 320f270:	000b883a 	mov	r5,zero
 320f274:	dc400415 	stw	r17,16(sp)
 320f278:	003f0506 	br	320ee90 <_strtod_r+0x1d4>
 320f27c:	d8c01117 	ldw	r3,68(sp)
 320f280:	0480c974 	movhi	r18,805
 320f284:	9483a404 	addi	r18,r18,3728
 320f288:	d8800504 	addi	r2,sp,20
 320f28c:	a809883a 	mov	r4,r21
 320f290:	d9400404 	addi	r5,sp,16
 320f294:	900d883a 	mov	r6,r18
 320f298:	d9c00604 	addi	r7,sp,24
 320f29c:	d8800015 	stw	r2,0(sp)
 320f2a0:	d8c00115 	stw	r3,4(sp)
 320f2a4:	32112280 	call	3211228 <__gethex>
 320f2a8:	140001cc 	andi	r16,r2,7
 320f2ac:	1027883a 	mov	r19,r2
 320f2b0:	803ef926 	beq	r16,zero,320ee98 <_strtod_r+0x1dc>
 320f2b4:	05000184 	movi	r20,6
 320f2b8:	853f1a26 	beq	r16,r20,320ef24 <_strtod_r+0x268>
 320f2bc:	d9800517 	ldw	r6,20(sp)
 320f2c0:	30000626 	beq	r6,zero,320f2dc <_strtod_r+0x620>
 320f2c4:	91400017 	ldw	r5,0(r18)
 320f2c8:	d9000d04 	addi	r4,sp,52
 320f2cc:	320deb40 	call	320deb4 <__copybits>
 320f2d0:	d9400517 	ldw	r5,20(sp)
 320f2d4:	a809883a 	mov	r4,r21
 320f2d8:	320da140 	call	320da14 <_Bfree>
 320f2dc:	d9400617 	ldw	r5,24(sp)
 320f2e0:	a4024136 	bltu	r20,r16,320fbe8 <_strtod_r+0xf2c>
 320f2e4:	8405883a 	add	r2,r16,r16
 320f2e8:	1085883a 	add	r2,r2,r2
 320f2ec:	00c0c874 	movhi	r3,801
 320f2f0:	18fcc004 	addi	r3,r3,-3328
 320f2f4:	10c5883a 	add	r2,r2,r3
 320f2f8:	11000017 	ldw	r4,0(r2)
 320f2fc:	2000683a 	jmp	r4
 320f300:	0320fc28 	cmpgeui	r12,zero,33776
 320f304:	0320fc34 	movhi	r12,33776
 320f308:	0320fbd8 	cmpnei	r12,zero,-31761
 320f30c:	0320fc00 	call	320fc0 <OSCtxSw_SWITCH_PC+0x320f80>
 320f310:	0320fc10 	cmplti	r12,zero,-31760
 320f314:	0320fc34 	movhi	r12,33776
 320f318:	0320fc28 	cmpgeui	r12,zero,33776
 320f31c:	d8c00f17 	ldw	r3,60(sp)
 320f320:	9c85c83a 	sub	r2,r19,r18
 320f324:	18a1883a 	add	r16,r3,r2
 320f328:	0402d00e 	bge	zero,r16,320fe6c <_strtod_r+0x11b0>
 320f32c:	814003cc 	andi	r5,r16,15
 320f330:	28000f26 	beq	r5,zero,320f370 <_strtod_r+0x6b4>
 320f334:	280a90fa 	slli	r5,r5,3
 320f338:	0100c974 	movhi	r4,805
 320f33c:	2137e804 	addi	r4,r4,-8288
 320f340:	e0800017 	ldw	r2,0(fp)
 320f344:	290b883a 	add	r5,r5,r4
 320f348:	2a000017 	ldw	r8,0(r5)
 320f34c:	e0c00117 	ldw	r3,4(fp)
 320f350:	2a400117 	ldw	r9,4(r5)
 320f354:	1009883a 	mov	r4,r2
 320f358:	180b883a 	mov	r5,r3
 320f35c:	480f883a 	mov	r7,r9
 320f360:	400d883a 	mov	r6,r8
 320f364:	3212fa80 	call	3212fa8 <__muldf3>
 320f368:	e0c00115 	stw	r3,4(fp)
 320f36c:	e0800015 	stw	r2,0(fp)
 320f370:	00bffc04 	movi	r2,-16
 320f374:	808c703a 	and	r6,r16,r2
 320f378:	30005b26 	beq	r6,zero,320f4e8 <_strtod_r+0x82c>
 320f37c:	00804d04 	movi	r2,308
 320f380:	1181fd16 	blt	r2,r6,320fb78 <_strtod_r+0xebc>
 320f384:	3021d13a 	srai	r16,r6,4
 320f388:	00800044 	movi	r2,1
 320f38c:	1403610e 	bge	r2,r16,3210114 <_strtod_r+0x1458>
 320f390:	102f883a 	mov	r23,r2
 320f394:	0025883a 	mov	r18,zero
 320f398:	0440c974 	movhi	r17,805
 320f39c:	8c781a04 	addi	r17,r17,-8088
 320f3a0:	8080004c 	andi	r2,r16,1
 320f3a4:	1005003a 	cmpeq	r2,r2,zero
 320f3a8:	1000091e 	bne	r2,zero,320f3d0 <_strtod_r+0x714>
 320f3ac:	e0800017 	ldw	r2,0(fp)
 320f3b0:	e0c00117 	ldw	r3,4(fp)
 320f3b4:	89800017 	ldw	r6,0(r17)
 320f3b8:	89c00117 	ldw	r7,4(r17)
 320f3bc:	180b883a 	mov	r5,r3
 320f3c0:	1009883a 	mov	r4,r2
 320f3c4:	3212fa80 	call	3212fa8 <__muldf3>
 320f3c8:	e0c00115 	stw	r3,4(fp)
 320f3cc:	e0800015 	stw	r2,0(fp)
 320f3d0:	8021d07a 	srai	r16,r16,1
 320f3d4:	94800044 	addi	r18,r18,1
 320f3d8:	8c400204 	addi	r17,r17,8
 320f3dc:	bc3ff016 	blt	r23,r16,320f3a0 <_strtod_r+0x6e4>
 320f3e0:	900e90fa 	slli	r7,r18,3
 320f3e4:	0180c974 	movhi	r6,805
 320f3e8:	31b81a04 	addi	r6,r6,-8088
 320f3ec:	e2000117 	ldw	r8,4(fp)
 320f3f0:	398f883a 	add	r7,r7,r6
 320f3f4:	38800017 	ldw	r2,0(r7)
 320f3f8:	38c00117 	ldw	r3,4(r7)
 320f3fc:	e1000017 	ldw	r4,0(fp)
 320f400:	01bf2c34 	movhi	r6,64688
 320f404:	418d883a 	add	r6,r8,r6
 320f408:	300b883a 	mov	r5,r6
 320f40c:	180f883a 	mov	r7,r3
 320f410:	100d883a 	mov	r6,r2
 320f414:	3212fa80 	call	3212fa8 <__muldf3>
 320f418:	1009883a 	mov	r4,r2
 320f41c:	180b883a 	mov	r5,r3
 320f420:	199ffc2c 	andhi	r6,r3,32752
 320f424:	009f2834 	movhi	r2,31904
 320f428:	e1000015 	stw	r4,0(fp)
 320f42c:	e1400115 	stw	r5,4(fp)
 320f430:	1181d136 	bltu	r2,r6,320fb78 <_strtod_r+0xebc>
 320f434:	009f2434 	movhi	r2,31888
 320f438:	1183202e 	bgeu	r2,r6,32100bc <_strtod_r+0x1400>
 320f43c:	d8001415 	stw	zero,80(sp)
 320f440:	019ffc34 	movhi	r6,32752
 320f444:	31bfffc4 	addi	r6,r6,-1
 320f448:	01ffffc4 	movi	r7,-1
 320f44c:	e1800115 	stw	r6,4(fp)
 320f450:	e1c00015 	stw	r7,0(fp)
 320f454:	00002506 	br	320f4ec <_strtod_r+0x830>
 320f458:	00800c04 	movi	r2,48
 320f45c:	2083151e 	bne	r4,r2,32100b4 <_strtod_r+0x13f8>
 320f460:	2005883a 	mov	r2,r4
 320f464:	000f883a 	mov	r7,zero
 320f468:	42000044 	addi	r8,r8,1
 320f46c:	da000415 	stw	r8,16(sp)
 320f470:	41000007 	ldb	r4,0(r8)
 320f474:	39c00044 	addi	r7,r7,1
 320f478:	20bffb26 	beq	r4,r2,320f468 <_strtod_r+0x7ac>
 320f47c:	20fff3c4 	addi	r3,r4,-49
 320f480:	00800204 	movi	r2,8
 320f484:	10c1b836 	bltu	r2,r3,320fb68 <_strtod_r+0xeac>
 320f488:	dd800417 	ldw	r22,16(sp)
 320f48c:	3815883a 	mov	r10,r7
 320f490:	227ff404 	addi	r9,r4,-48
 320f494:	b011883a 	mov	r8,r22
 320f498:	0027883a 	mov	r19,zero
 320f49c:	01c00044 	movi	r7,1
 320f4a0:	4801fe26 	beq	r9,zero,320fc9c <_strtod_r+0xfe0>
 320f4a4:	00800044 	movi	r2,1
 320f4a8:	51d5883a 	add	r10,r10,r7
 320f4ac:	11c31f0e 	bge	r2,r7,321012c <_strtod_r+0x1470>
 320f4b0:	1009883a 	mov	r4,r2
 320f4b4:	9807883a 	mov	r3,r19
 320f4b8:	02c00204 	movi	r11,8
 320f4bc:	03000404 	movi	r12,16
 320f4c0:	00000306 	br	320f4d0 <_strtod_r+0x814>
 320f4c4:	a50002a4 	muli	r20,r20,10
 320f4c8:	21000044 	addi	r4,r4,1
 320f4cc:	21c1eb26 	beq	r4,r7,320fc7c <_strtod_r+0xfc0>
 320f4d0:	18c00044 	addi	r3,r3,1
 320f4d4:	18bfffc4 	addi	r2,r3,-1
 320f4d8:	58bffa0e 	bge	r11,r2,320f4c4 <_strtod_r+0x808>
 320f4dc:	60fffa16 	blt	r12,r3,320f4c8 <_strtod_r+0x80c>
 320f4e0:	840002a4 	muli	r16,r16,10
 320f4e4:	003ff806 	br	320f4c8 <_strtod_r+0x80c>
 320f4e8:	d8001415 	stw	zero,80(sp)
 320f4ec:	d9801217 	ldw	r6,72(sp)
 320f4f0:	a809883a 	mov	r4,r21
 320f4f4:	b00b883a 	mov	r5,r22
 320f4f8:	980f883a 	mov	r7,r19
 320f4fc:	dd000015 	stw	r20,0(sp)
 320f500:	320e8e80 	call	320e8e8 <__s2b>
 320f504:	d9800f17 	ldw	r6,60(sp)
 320f508:	11000304 	addi	r4,r2,12
 320f50c:	d8801015 	stw	r2,64(sp)
 320f510:	300c803a 	cmplt	r6,r6,zero
 320f514:	d9001715 	stw	r4,92(sp)
 320f518:	d9801615 	stw	r6,88(sp)
 320f51c:	d8801017 	ldw	r2,64(sp)
 320f520:	a809883a 	mov	r4,r21
 320f524:	11400117 	ldw	r5,4(r2)
 320f528:	320df940 	call	320df94 <_Balloc>
 320f52c:	d8c01017 	ldw	r3,64(sp)
 320f530:	d9401717 	ldw	r5,92(sp)
 320f534:	11000304 	addi	r4,r2,12
 320f538:	19800417 	ldw	r6,16(r3)
 320f53c:	102f883a 	mov	r23,r2
 320f540:	318d883a 	add	r6,r6,r6
 320f544:	318d883a 	add	r6,r6,r6
 320f548:	31800204 	addi	r6,r6,8
 320f54c:	32067cc0 	call	32067cc <memcpy>
 320f550:	e2000017 	ldw	r8,0(fp)
 320f554:	e2400117 	ldw	r9,4(fp)
 320f558:	d9800304 	addi	r6,sp,12
 320f55c:	400b883a 	mov	r5,r8
 320f560:	a809883a 	mov	r4,r21
 320f564:	d9c00204 	addi	r7,sp,8
 320f568:	d9800015 	stw	r6,0(sp)
 320f56c:	480d883a 	mov	r6,r9
 320f570:	320e0500 	call	320e050 <__d2b>
 320f574:	a809883a 	mov	r4,r21
 320f578:	01400044 	movi	r5,1
 320f57c:	d8800515 	stw	r2,20(sp)
 320f580:	320e68c0 	call	320e68c <__i2b>
 320f584:	102d883a 	mov	r22,r2
 320f588:	d8801617 	ldw	r2,88(sp)
 320f58c:	1001051e 	bne	r2,zero,320f9a4 <_strtod_r+0xce8>
 320f590:	dd000f17 	ldw	r20,60(sp)
 320f594:	000f883a 	mov	r7,zero
 320f598:	0013883a 	mov	r9,zero
 320f59c:	a011883a 	mov	r8,r20
 320f5a0:	d8800217 	ldw	r2,8(sp)
 320f5a4:	1000fd16 	blt	r2,zero,320f99c <_strtod_r+0xce0>
 320f5a8:	388f883a 	add	r7,r7,r2
 320f5ac:	d9801417 	ldw	r6,80(sp)
 320f5b0:	d9400317 	ldw	r5,12(sp)
 320f5b4:	00ff0084 	movi	r3,-1022
 320f5b8:	1189c83a 	sub	r4,r2,r6
 320f5bc:	2145883a 	add	r2,r4,r5
 320f5c0:	10bfffc4 	addi	r2,r2,-1
 320f5c4:	10c09f0e 	bge	r2,r3,320f844 <_strtod_r+0xb88>
 320f5c8:	21810cc4 	addi	r6,r4,1075
 320f5cc:	d8c01417 	ldw	r3,80(sp)
 320f5d0:	4185883a 	add	r2,r8,r6
 320f5d4:	39a1883a 	add	r16,r7,r6
 320f5d8:	18a5883a 	add	r18,r3,r2
 320f5dc:	3807883a 	mov	r3,r7
 320f5e0:	81c0010e 	bge	r16,r7,320f5e8 <_strtod_r+0x92c>
 320f5e4:	8007883a 	mov	r3,r16
 320f5e8:	9005883a 	mov	r2,r18
 320f5ec:	1c80010e 	bge	r3,r18,320f5f4 <_strtod_r+0x938>
 320f5f0:	1805883a 	mov	r2,r3
 320f5f4:	0080e70e 	bge	zero,r2,320f994 <_strtod_r+0xcd8>
 320f5f8:	38a7c83a 	sub	r19,r7,r2
 320f5fc:	80a1c83a 	sub	r16,r16,r2
 320f600:	90a5c83a 	sub	r18,r18,r2
 320f604:	02400e0e 	bge	zero,r9,320f640 <_strtod_r+0x984>
 320f608:	480d883a 	mov	r6,r9
 320f60c:	b00b883a 	mov	r5,r22
 320f610:	a809883a 	mov	r4,r21
 320f614:	320e7c80 	call	320e7c8 <__pow5mult>
 320f618:	d9800517 	ldw	r6,20(sp)
 320f61c:	a809883a 	mov	r4,r21
 320f620:	100b883a 	mov	r5,r2
 320f624:	102d883a 	mov	r22,r2
 320f628:	320e4a40 	call	320e4a4 <__multiply>
 320f62c:	d9400517 	ldw	r5,20(sp)
 320f630:	1023883a 	mov	r17,r2
 320f634:	a809883a 	mov	r4,r21
 320f638:	320da140 	call	320da14 <_Bfree>
 320f63c:	dc400515 	stw	r17,20(sp)
 320f640:	0400050e 	bge	zero,r16,320f658 <_strtod_r+0x99c>
 320f644:	d9400517 	ldw	r5,20(sp)
 320f648:	800d883a 	mov	r6,r16
 320f64c:	a809883a 	mov	r4,r21
 320f650:	320e3580 	call	320e358 <__lshift>
 320f654:	d8800515 	stw	r2,20(sp)
 320f658:	a000741e 	bne	r20,zero,320f82c <_strtod_r+0xb70>
 320f65c:	0480050e 	bge	zero,r18,320f674 <_strtod_r+0x9b8>
 320f660:	b80b883a 	mov	r5,r23
 320f664:	900d883a 	mov	r6,r18
 320f668:	a809883a 	mov	r4,r21
 320f66c:	320e3580 	call	320e358 <__lshift>
 320f670:	102f883a 	mov	r23,r2
 320f674:	04c0050e 	bge	zero,r19,320f68c <_strtod_r+0x9d0>
 320f678:	b00b883a 	mov	r5,r22
 320f67c:	980d883a 	mov	r6,r19
 320f680:	a809883a 	mov	r4,r21
 320f684:	320e3580 	call	320e358 <__lshift>
 320f688:	102d883a 	mov	r22,r2
 320f68c:	d9400517 	ldw	r5,20(sp)
 320f690:	a809883a 	mov	r4,r21
 320f694:	b80d883a 	mov	r6,r23
 320f698:	320e1cc0 	call	320e1cc <__mdiff>
 320f69c:	11000317 	ldw	r4,12(r2)
 320f6a0:	b00b883a 	mov	r5,r22
 320f6a4:	10000315 	stw	zero,12(r2)
 320f6a8:	d9001315 	stw	r4,76(sp)
 320f6ac:	1009883a 	mov	r4,r2
 320f6b0:	1029883a 	mov	r20,r2
 320f6b4:	320db700 	call	320db70 <__mcmp>
 320f6b8:	10017c16 	blt	r2,zero,320fcac <_strtod_r+0xff0>
 320f6bc:	1001af26 	beq	r2,zero,320fd7c <_strtod_r+0x10c0>
 320f6c0:	a009883a 	mov	r4,r20
 320f6c4:	b00b883a 	mov	r5,r22
 320f6c8:	320dd700 	call	320dd70 <__ratio>
 320f6cc:	0011883a 	mov	r8,zero
 320f6d0:	02500034 	movhi	r9,16384
 320f6d4:	480f883a 	mov	r7,r9
 320f6d8:	1009883a 	mov	r4,r2
 320f6dc:	180b883a 	mov	r5,r3
 320f6e0:	400d883a 	mov	r6,r8
 320f6e4:	1021883a 	mov	r16,r2
 320f6e8:	1823883a 	mov	r17,r3
 320f6ec:	321386c0 	call	321386c <__ledf2>
 320f6f0:	00805716 	blt	zero,r2,320f850 <_strtod_r+0xb94>
 320f6f4:	d9801317 	ldw	r6,76(sp)
 320f6f8:	3025003a 	cmpeq	r18,r6,zero
 320f6fc:	90008b1e 	bne	r18,zero,320f92c <_strtod_r+0xc70>
 320f700:	008ffc34 	movhi	r2,16368
 320f704:	0021883a 	mov	r16,zero
 320f708:	1023883a 	mov	r17,r2
 320f70c:	d8000715 	stw	zero,28(sp)
 320f710:	d8800815 	stw	r2,32(sp)
 320f714:	e1c00117 	ldw	r7,4(fp)
 320f718:	009ff834 	movhi	r2,32736
 320f71c:	3cdffc2c 	andhi	r19,r7,32752
 320f720:	98805e26 	beq	r19,r2,320f89c <_strtod_r+0xbe0>
 320f724:	d8801417 	ldw	r2,80(sp)
 320f728:	10001b26 	beq	r2,zero,320f798 <_strtod_r+0xadc>
 320f72c:	0081a834 	movhi	r2,1696
 320f730:	14c01936 	bltu	r2,r19,320f798 <_strtod_r+0xadc>
 320f734:	00bff034 	movhi	r2,65472
 320f738:	00d07834 	movhi	r3,16864
 320f73c:	18ffffc4 	addi	r3,r3,-1
 320f740:	180f883a 	mov	r7,r3
 320f744:	8009883a 	mov	r4,r16
 320f748:	880b883a 	mov	r5,r17
 320f74c:	100d883a 	mov	r6,r2
 320f750:	321386c0 	call	321386c <__ledf2>
 320f754:	00800b16 	blt	zero,r2,320f784 <_strtod_r+0xac8>
 320f758:	880b883a 	mov	r5,r17
 320f75c:	8009883a 	mov	r4,r16
 320f760:	3211d0c0 	call	3211d0c <__fixunsdfsi>
 320f764:	1000df1e 	bne	r2,zero,320fae4 <_strtod_r+0xe28>
 320f768:	0021883a 	mov	r16,zero
 320f76c:	044ffc34 	movhi	r17,16368
 320f770:	9000d91e 	bne	r18,zero,320fad8 <_strtod_r+0xe1c>
 320f774:	8005883a 	mov	r2,r16
 320f778:	8807883a 	mov	r3,r17
 320f77c:	d8c00815 	stw	r3,32(sp)
 320f780:	d8800715 	stw	r2,28(sp)
 320f784:	d8800817 	ldw	r2,32(sp)
 320f788:	00c1ac34 	movhi	r3,1712
 320f78c:	14c5c83a 	sub	r2,r2,r19
 320f790:	10c5883a 	add	r2,r2,r3
 320f794:	d8800815 	stw	r2,32(sp)
 320f798:	e0800017 	ldw	r2,0(fp)
 320f79c:	e0c00117 	ldw	r3,4(fp)
 320f7a0:	1009883a 	mov	r4,r2
 320f7a4:	180b883a 	mov	r5,r3
 320f7a8:	320dbd00 	call	320dbd0 <__ulp>
 320f7ac:	d9800717 	ldw	r6,28(sp)
 320f7b0:	d9c00817 	ldw	r7,32(sp)
 320f7b4:	180b883a 	mov	r5,r3
 320f7b8:	1009883a 	mov	r4,r2
 320f7bc:	3212fa80 	call	3212fa8 <__muldf3>
 320f7c0:	e2000017 	ldw	r8,0(fp)
 320f7c4:	e2400117 	ldw	r9,4(fp)
 320f7c8:	180b883a 	mov	r5,r3
 320f7cc:	1009883a 	mov	r4,r2
 320f7d0:	480f883a 	mov	r7,r9
 320f7d4:	400d883a 	mov	r6,r8
 320f7d8:	3212f340 	call	3212f34 <__adddf3>
 320f7dc:	e0c00115 	stw	r3,4(fp)
 320f7e0:	e0800015 	stw	r2,0(fp)
 320f7e4:	d8c01417 	ldw	r3,80(sp)
 320f7e8:	e4800117 	ldw	r18,4(fp)
 320f7ec:	1800021e 	bne	r3,zero,320f7f8 <_strtod_r+0xb3c>
 320f7f0:	909ffc2c 	andhi	r2,r18,32752
 320f7f4:	98807b26 	beq	r19,r2,320f9e4 <_strtod_r+0xd28>
 320f7f8:	d9400517 	ldw	r5,20(sp)
 320f7fc:	a809883a 	mov	r4,r21
 320f800:	320da140 	call	320da14 <_Bfree>
 320f804:	a809883a 	mov	r4,r21
 320f808:	b80b883a 	mov	r5,r23
 320f80c:	320da140 	call	320da14 <_Bfree>
 320f810:	a809883a 	mov	r4,r21
 320f814:	b00b883a 	mov	r5,r22
 320f818:	320da140 	call	320da14 <_Bfree>
 320f81c:	a809883a 	mov	r4,r21
 320f820:	a00b883a 	mov	r5,r20
 320f824:	320da140 	call	320da14 <_Bfree>
 320f828:	003f3c06 	br	320f51c <_strtod_r+0x860>
 320f82c:	b80b883a 	mov	r5,r23
 320f830:	a00d883a 	mov	r6,r20
 320f834:	a809883a 	mov	r4,r21
 320f838:	320e7c80 	call	320e7c8 <__pow5mult>
 320f83c:	102f883a 	mov	r23,r2
 320f840:	003f8606 	br	320f65c <_strtod_r+0x9a0>
 320f844:	00800d84 	movi	r2,54
 320f848:	114dc83a 	sub	r6,r2,r5
 320f84c:	003f5f06 	br	320f5cc <_strtod_r+0x910>
 320f850:	0005883a 	mov	r2,zero
 320f854:	00cff834 	movhi	r3,16352
 320f858:	880b883a 	mov	r5,r17
 320f85c:	8009883a 	mov	r4,r16
 320f860:	100d883a 	mov	r6,r2
 320f864:	180f883a 	mov	r7,r3
 320f868:	3212fa80 	call	3212fa8 <__muldf3>
 320f86c:	d9801317 	ldw	r6,76(sp)
 320f870:	1021883a 	mov	r16,r2
 320f874:	1823883a 	mov	r17,r3
 320f878:	3025003a 	cmpeq	r18,r6,zero
 320f87c:	90000126 	beq	r18,zero,320f884 <_strtod_r+0xbc8>
 320f880:	18e0003c 	xorhi	r3,r3,32768
 320f884:	d8800715 	stw	r2,28(sp)
 320f888:	d8c00815 	stw	r3,32(sp)
 320f88c:	e1c00117 	ldw	r7,4(fp)
 320f890:	009ff834 	movhi	r2,32736
 320f894:	3cdffc2c 	andhi	r19,r7,32752
 320f898:	98bfa21e 	bne	r19,r2,320f724 <_strtod_r+0xa68>
 320f89c:	e1000017 	ldw	r4,0(fp)
 320f8a0:	01bf2c34 	movhi	r6,64688
 320f8a4:	398d883a 	add	r6,r7,r6
 320f8a8:	d9000b15 	stw	r4,44(sp)
 320f8ac:	d9c00c15 	stw	r7,48(sp)
 320f8b0:	300b883a 	mov	r5,r6
 320f8b4:	e1800115 	stw	r6,4(fp)
 320f8b8:	320dbd00 	call	320dbd0 <__ulp>
 320f8bc:	d9800717 	ldw	r6,28(sp)
 320f8c0:	d9c00817 	ldw	r7,32(sp)
 320f8c4:	180b883a 	mov	r5,r3
 320f8c8:	1009883a 	mov	r4,r2
 320f8cc:	3212fa80 	call	3212fa8 <__muldf3>
 320f8d0:	e2000017 	ldw	r8,0(fp)
 320f8d4:	e2400117 	ldw	r9,4(fp)
 320f8d8:	180b883a 	mov	r5,r3
 320f8dc:	1009883a 	mov	r4,r2
 320f8e0:	480f883a 	mov	r7,r9
 320f8e4:	400d883a 	mov	r6,r8
 320f8e8:	3212f340 	call	3212f34 <__adddf3>
 320f8ec:	1009883a 	mov	r4,r2
 320f8f0:	180b883a 	mov	r5,r3
 320f8f4:	009f2834 	movhi	r2,31904
 320f8f8:	10bfffc4 	addi	r2,r2,-1
 320f8fc:	18dffc2c 	andhi	r3,r3,32752
 320f900:	e1000015 	stw	r4,0(fp)
 320f904:	e1400115 	stw	r5,4(fp)
 320f908:	10c06f2e 	bgeu	r2,r3,320fac8 <_strtod_r+0xe0c>
 320f90c:	d8800c17 	ldw	r2,48(sp)
 320f910:	011ffc34 	movhi	r4,32752
 320f914:	213fffc4 	addi	r4,r4,-1
 320f918:	11007a26 	beq	r2,r4,320fb04 <_strtod_r+0xe48>
 320f91c:	01ffffc4 	movi	r7,-1
 320f920:	e1000115 	stw	r4,4(fp)
 320f924:	e1c00015 	stw	r7,0(fp)
 320f928:	003fb306 	br	320f7f8 <_strtod_r+0xb3c>
 320f92c:	e0c00017 	ldw	r3,0(fp)
 320f930:	1800221e 	bne	r3,zero,320f9bc <_strtod_r+0xd00>
 320f934:	e0800117 	ldw	r2,4(fp)
 320f938:	00c00434 	movhi	r3,16
 320f93c:	18ffffc4 	addi	r3,r3,-1
 320f940:	10c4703a 	and	r2,r2,r3
 320f944:	1000211e 	bne	r2,zero,320f9cc <_strtod_r+0xd10>
 320f948:	0005883a 	mov	r2,zero
 320f94c:	00cffc34 	movhi	r3,16368
 320f950:	180f883a 	mov	r7,r3
 320f954:	8009883a 	mov	r4,r16
 320f958:	880b883a 	mov	r5,r17
 320f95c:	100d883a 	mov	r6,r2
 320f960:	32137e40 	call	32137e4 <__ltdf2>
 320f964:	10013c16 	blt	r2,zero,320fe58 <_strtod_r+0x119c>
 320f968:	0005883a 	mov	r2,zero
 320f96c:	00cff834 	movhi	r3,16352
 320f970:	880b883a 	mov	r5,r17
 320f974:	8009883a 	mov	r4,r16
 320f978:	180f883a 	mov	r7,r3
 320f97c:	100d883a 	mov	r6,r2
 320f980:	3212fa80 	call	3212fa8 <__muldf3>
 320f984:	1823883a 	mov	r17,r3
 320f988:	1021883a 	mov	r16,r2
 320f98c:	18e0003c 	xorhi	r3,r3,32768
 320f990:	003fbc06 	br	320f884 <_strtod_r+0xbc8>
 320f994:	3827883a 	mov	r19,r7
 320f998:	003f1a06 	br	320f604 <_strtod_r+0x948>
 320f99c:	4091c83a 	sub	r8,r8,r2
 320f9a0:	003f0206 	br	320f5ac <_strtod_r+0x8f0>
 320f9a4:	d8c00f17 	ldw	r3,60(sp)
 320f9a8:	0011883a 	mov	r8,zero
 320f9ac:	0029883a 	mov	r20,zero
 320f9b0:	00d3c83a 	sub	r9,zero,r3
 320f9b4:	480f883a 	mov	r7,r9
 320f9b8:	003ef906 	br	320f5a0 <_strtod_r+0x8e4>
 320f9bc:	00800044 	movi	r2,1
 320f9c0:	1880021e 	bne	r3,r2,320f9cc <_strtod_r+0xd10>
 320f9c4:	e0800117 	ldw	r2,4(fp)
 320f9c8:	1000a526 	beq	r2,zero,320fc60 <_strtod_r+0xfa4>
 320f9cc:	00affc34 	movhi	r2,49136
 320f9d0:	0021883a 	mov	r16,zero
 320f9d4:	044ffc34 	movhi	r17,16368
 320f9d8:	d8800815 	stw	r2,32(sp)
 320f9dc:	d8000715 	stw	zero,28(sp)
 320f9e0:	003f4c06 	br	320f714 <_strtod_r+0xa58>
 320f9e4:	880b883a 	mov	r5,r17
 320f9e8:	8009883a 	mov	r4,r16
 320f9ec:	32139ec0 	call	32139ec <__fixdfsi>
 320f9f0:	1009883a 	mov	r4,r2
 320f9f4:	32138f40 	call	32138f4 <__floatsidf>
 320f9f8:	880b883a 	mov	r5,r17
 320f9fc:	8009883a 	mov	r4,r16
 320fa00:	100d883a 	mov	r6,r2
 320fa04:	180f883a 	mov	r7,r3
 320fa08:	3212eb40 	call	3212eb4 <__subdf3>
 320fa0c:	d9001317 	ldw	r4,76(sp)
 320fa10:	100b883a 	mov	r5,r2
 320fa14:	180d883a 	mov	r6,r3
 320fa18:	1021883a 	mov	r16,r2
 320fa1c:	1823883a 	mov	r17,r3
 320fa20:	2000061e 	bne	r4,zero,320fa3c <_strtod_r+0xd80>
 320fa24:	e0800017 	ldw	r2,0(fp)
 320fa28:	1000041e 	bne	r2,zero,320fa3c <_strtod_r+0xd80>
 320fa2c:	00c00434 	movhi	r3,16
 320fa30:	18ffffc4 	addi	r3,r3,-1
 320fa34:	90c4703a 	and	r2,r18,r3
 320fa38:	10004026 	beq	r2,zero,320fb3c <_strtod_r+0xe80>
 320fa3c:	00a52834 	movhi	r2,38048
 320fa40:	108d6544 	addi	r2,r2,13717
 320fa44:	00cff834 	movhi	r3,16352
 320fa48:	18ffffc4 	addi	r3,r3,-1
 320fa4c:	180f883a 	mov	r7,r3
 320fa50:	8009883a 	mov	r4,r16
 320fa54:	880b883a 	mov	r5,r17
 320fa58:	100d883a 	mov	r6,r2
 320fa5c:	32137e40 	call	32137e4 <__ltdf2>
 320fa60:	10000916 	blt	r2,zero,320fa88 <_strtod_r+0xdcc>
 320fa64:	008d6c34 	movhi	r2,13744
 320fa68:	10b94d44 	addi	r2,r2,-6859
 320fa6c:	00cff834 	movhi	r3,16352
 320fa70:	880b883a 	mov	r5,r17
 320fa74:	180f883a 	mov	r7,r3
 320fa78:	8009883a 	mov	r4,r16
 320fa7c:	100d883a 	mov	r6,r2
 320fa80:	32136d40 	call	32136d4 <__gtdf2>
 320fa84:	00bf5c0e 	bge	zero,r2,320f7f8 <_strtod_r+0xb3c>
 320fa88:	d9400517 	ldw	r5,20(sp)
 320fa8c:	a809883a 	mov	r4,r21
 320fa90:	320da140 	call	320da14 <_Bfree>
 320fa94:	a809883a 	mov	r4,r21
 320fa98:	b80b883a 	mov	r5,r23
 320fa9c:	320da140 	call	320da14 <_Bfree>
 320faa0:	a809883a 	mov	r4,r21
 320faa4:	b00b883a 	mov	r5,r22
 320faa8:	320da140 	call	320da14 <_Bfree>
 320faac:	d9401017 	ldw	r5,64(sp)
 320fab0:	a809883a 	mov	r4,r21
 320fab4:	320da140 	call	320da14 <_Bfree>
 320fab8:	a809883a 	mov	r4,r21
 320fabc:	a00b883a 	mov	r5,r20
 320fac0:	320da140 	call	320da14 <_Bfree>
 320fac4:	003cf406 	br	320ee98 <_strtod_r+0x1dc>
 320fac8:	0080d434 	movhi	r2,848
 320facc:	288d883a 	add	r6,r5,r2
 320fad0:	e1800115 	stw	r6,4(fp)
 320fad4:	003f4306 	br	320f7e4 <_strtod_r+0xb28>
 320fad8:	8005883a 	mov	r2,r16
 320fadc:	88e0003c 	xorhi	r3,r17,32768
 320fae0:	003f2606 	br	320f77c <_strtod_r+0xac0>
 320fae4:	1009883a 	mov	r4,r2
 320fae8:	3213b380 	call	3213b38 <__floatunsidf>
 320faec:	1021883a 	mov	r16,r2
 320faf0:	1823883a 	mov	r17,r3
 320faf4:	003f1e06 	br	320f770 <_strtod_r+0xab4>
 320faf8:	da000417 	ldw	r8,16(sp)
 320fafc:	39c00044 	addi	r7,r7,1
 320fb00:	003e6706 	br	320f4a0 <_strtod_r+0x7e4>
 320fb04:	d8c00b17 	ldw	r3,44(sp)
 320fb08:	00bfffc4 	movi	r2,-1
 320fb0c:	18bf831e 	bne	r3,r2,320f91c <_strtod_r+0xc60>
 320fb10:	00c00884 	movi	r3,34
 320fb14:	a8c00015 	stw	r3,0(r21)
 320fb18:	009ffc34 	movhi	r2,32752
 320fb1c:	e0800115 	stw	r2,4(fp)
 320fb20:	e0000015 	stw	zero,0(fp)
 320fb24:	003fd806 	br	320fa88 <_strtod_r+0xdcc>
 320fb28:	4007883a 	mov	r3,r8
 320fb2c:	000d883a 	mov	r6,zero
 320fb30:	0029883a 	mov	r20,zero
 320fb34:	0021883a 	mov	r16,zero
 320fb38:	003cc906 	br	320ee60 <_strtod_r+0x1a4>
 320fb3c:	00a52834 	movhi	r2,38048
 320fb40:	108d6544 	addi	r2,r2,13717
 320fb44:	00cff434 	movhi	r3,16336
 320fb48:	18ffffc4 	addi	r3,r3,-1
 320fb4c:	2809883a 	mov	r4,r5
 320fb50:	180f883a 	mov	r7,r3
 320fb54:	300b883a 	mov	r5,r6
 320fb58:	100d883a 	mov	r6,r2
 320fb5c:	32137e40 	call	32137e4 <__ltdf2>
 320fb60:	103f250e 	bge	r2,zero,320f7f8 <_strtod_r+0xb3c>
 320fb64:	003fc806 	br	320fa88 <_strtod_r+0xdcc>
 320fb68:	0027883a 	mov	r19,zero
 320fb6c:	04800044 	movi	r18,1
 320fb70:	0015883a 	mov	r10,zero
 320fb74:	003cc006 	br	320ee78 <_strtod_r+0x1bc>
 320fb78:	00800884 	movi	r2,34
 320fb7c:	a8800015 	stw	r2,0(r21)
 320fb80:	019ffc34 	movhi	r6,32752
 320fb84:	e1800115 	stw	r6,4(fp)
 320fb88:	e0000015 	stw	zero,0(fp)
 320fb8c:	003cc206 	br	320ee98 <_strtod_r+0x1dc>
 320fb90:	015387c4 	movi	r5,19999
 320fb94:	003d1e06 	br	320f010 <_strtod_r+0x354>
 320fb98:	300a90fa 	slli	r5,r6,3
 320fb9c:	e0800017 	ldw	r2,0(fp)
 320fba0:	e0c00117 	ldw	r3,4(fp)
 320fba4:	0100c974 	movhi	r4,805
 320fba8:	2137e804 	addi	r4,r4,-8288
 320fbac:	290b883a 	add	r5,r5,r4
 320fbb0:	2a000017 	ldw	r8,0(r5)
 320fbb4:	2a400117 	ldw	r9,4(r5)
 320fbb8:	1009883a 	mov	r4,r2
 320fbbc:	180b883a 	mov	r5,r3
 320fbc0:	480f883a 	mov	r7,r9
 320fbc4:	400d883a 	mov	r6,r8
 320fbc8:	3212fa80 	call	3212fa8 <__muldf3>
 320fbcc:	e0c00115 	stw	r3,4(fp)
 320fbd0:	e0800015 	stw	r2,0(fp)
 320fbd4:	003cb006 	br	320ee98 <_strtod_r+0x1dc>
 320fbd8:	d8800d17 	ldw	r2,52(sp)
 320fbdc:	e0800015 	stw	r2,0(fp)
 320fbe0:	d8c00e17 	ldw	r3,56(sp)
 320fbe4:	e0c00115 	stw	r3,4(fp)
 320fbe8:	9880020c 	andi	r2,r19,8
 320fbec:	103caa26 	beq	r2,zero,320ee98 <_strtod_r+0x1dc>
 320fbf0:	e0800117 	ldw	r2,4(fp)
 320fbf4:	10a00034 	orhi	r2,r2,32768
 320fbf8:	e0800115 	stw	r2,4(fp)
 320fbfc:	003ca606 	br	320ee98 <_strtod_r+0x1dc>
 320fc00:	009ffc34 	movhi	r2,32752
 320fc04:	e0800115 	stw	r2,4(fp)
 320fc08:	e0000015 	stw	zero,0(fp)
 320fc0c:	003ff606 	br	320fbe8 <_strtod_r+0xf2c>
 320fc10:	00a00034 	movhi	r2,32768
 320fc14:	10bfffc4 	addi	r2,r2,-1
 320fc18:	00ffffc4 	movi	r3,-1
 320fc1c:	e0800115 	stw	r2,4(fp)
 320fc20:	e0c00015 	stw	r3,0(fp)
 320fc24:	003ff006 	br	320fbe8 <_strtod_r+0xf2c>
 320fc28:	e0000115 	stw	zero,4(fp)
 320fc2c:	e0000015 	stw	zero,0(fp)
 320fc30:	003fed06 	br	320fbe8 <_strtod_r+0xf2c>
 320fc34:	d8800e17 	ldw	r2,56(sp)
 320fc38:	29010cc4 	addi	r4,r5,1075
 320fc3c:	00fffc34 	movhi	r3,65520
 320fc40:	18ffffc4 	addi	r3,r3,-1
 320fc44:	2008953a 	slli	r4,r4,20
 320fc48:	10c4703a 	and	r2,r2,r3
 320fc4c:	d8c00d17 	ldw	r3,52(sp)
 320fc50:	1104b03a 	or	r2,r2,r4
 320fc54:	e0800115 	stw	r2,4(fp)
 320fc58:	e0c00015 	stw	r3,0(fp)
 320fc5c:	003fe206 	br	320fbe8 <_strtod_r+0xf2c>
 320fc60:	00800884 	movi	r2,34
 320fc64:	a8800015 	stw	r2,0(r21)
 320fc68:	e0000015 	stw	zero,0(fp)
 320fc6c:	e0000115 	stw	zero,4(fp)
 320fc70:	003f8506 	br	320fa88 <_strtod_r+0xdcc>
 320fc74:	03800044 	movi	r14,1
 320fc78:	003d7706 	br	320f258 <_strtod_r+0x59c>
 320fc7c:	99c5883a 	add	r2,r19,r7
 320fc80:	11ffffc4 	addi	r7,r2,-1
 320fc84:	00800204 	movi	r2,8
 320fc88:	3cc00044 	addi	r19,r7,1
 320fc8c:	11c0df16 	blt	r2,r7,321000c <_strtod_r+0x1350>
 320fc90:	a08002a4 	muli	r2,r20,10
 320fc94:	000f883a 	mov	r7,zero
 320fc98:	1269883a 	add	r20,r2,r9
 320fc9c:	42000044 	addi	r8,r8,1
 320fca0:	da000415 	stw	r8,16(sp)
 320fca4:	41000007 	ldb	r4,0(r8)
 320fca8:	003d3706 	br	320f188 <_strtod_r+0x4cc>
 320fcac:	d9801317 	ldw	r6,76(sp)
 320fcb0:	3000511e 	bne	r6,zero,320fdf8 <_strtod_r+0x113c>
 320fcb4:	e0800017 	ldw	r2,0(fp)
 320fcb8:	1000d81e 	bne	r2,zero,321001c <_strtod_r+0x1360>
 320fcbc:	e0c00117 	ldw	r3,4(fp)
 320fcc0:	01000434 	movhi	r4,16
 320fcc4:	213fffc4 	addi	r4,r4,-1
 320fcc8:	1904703a 	and	r2,r3,r4
 320fccc:	1000b01e 	bne	r2,zero,320ff90 <_strtod_r+0x12d4>
 320fcd0:	18dffc2c 	andhi	r3,r3,32752
 320fcd4:	0081ac34 	movhi	r2,1712
 320fcd8:	10c1102e 	bgeu	r2,r3,321011c <_strtod_r+0x1460>
 320fcdc:	a0800517 	ldw	r2,20(r20)
 320fce0:	1000031e 	bne	r2,zero,320fcf0 <_strtod_r+0x1034>
 320fce4:	a0c00417 	ldw	r3,16(r20)
 320fce8:	00800044 	movi	r2,1
 320fcec:	10c0420e 	bge	r2,r3,320fdf8 <_strtod_r+0x113c>
 320fcf0:	a00b883a 	mov	r5,r20
 320fcf4:	a809883a 	mov	r4,r21
 320fcf8:	01800044 	movi	r6,1
 320fcfc:	320e3580 	call	320e358 <__lshift>
 320fd00:	1009883a 	mov	r4,r2
 320fd04:	b00b883a 	mov	r5,r22
 320fd08:	1029883a 	mov	r20,r2
 320fd0c:	320db700 	call	320db70 <__mcmp>
 320fd10:	0080c20e 	bge	zero,r2,321001c <_strtod_r+0x1360>
 320fd14:	e1800117 	ldw	r6,4(fp)
 320fd18:	d9001417 	ldw	r4,80(sp)
 320fd1c:	2013003a 	cmpeq	r9,r4,zero
 320fd20:	4800ef1e 	bne	r9,zero,32100e0 <_strtod_r+0x1424>
 320fd24:	30dffc2c 	andhi	r3,r6,32752
 320fd28:	0081ac34 	movhi	r2,1712
 320fd2c:	10c0ec36 	bltu	r2,r3,32100e0 <_strtod_r+0x1424>
 320fd30:	0080dc34 	movhi	r2,880
 320fd34:	10ffca2e 	bgeu	r2,r3,320fc60 <_strtod_r+0xfa4>
 320fd38:	e0800017 	ldw	r2,0(fp)
 320fd3c:	e0c00117 	ldw	r3,4(fp)
 320fd40:	020e5434 	movhi	r8,14672
 320fd44:	000d883a 	mov	r6,zero
 320fd48:	400f883a 	mov	r7,r8
 320fd4c:	180b883a 	mov	r5,r3
 320fd50:	1009883a 	mov	r4,r2
 320fd54:	da000c15 	stw	r8,48(sp)
 320fd58:	d8000b15 	stw	zero,44(sp)
 320fd5c:	3212fa80 	call	3212fa8 <__muldf3>
 320fd60:	e0800015 	stw	r2,0(fp)
 320fd64:	e0c00115 	stw	r3,4(fp)
 320fd68:	183f471e 	bne	r3,zero,320fa88 <_strtod_r+0xdcc>
 320fd6c:	103f461e 	bne	r2,zero,320fa88 <_strtod_r+0xdcc>
 320fd70:	00800884 	movi	r2,34
 320fd74:	a8800015 	stw	r2,0(r21)
 320fd78:	003f4306 	br	320fa88 <_strtod_r+0xdcc>
 320fd7c:	d8801317 	ldw	r2,76(sp)
 320fd80:	1025003a 	cmpeq	r18,r2,zero
 320fd84:	9000861e 	bne	r18,zero,320ffa0 <_strtod_r+0x12e4>
 320fd88:	e1400117 	ldw	r5,4(fp)
 320fd8c:	00c00434 	movhi	r3,16
 320fd90:	18ffffc4 	addi	r3,r3,-1
 320fd94:	28c4703a 	and	r2,r5,r3
 320fd98:	10c01b26 	beq	r2,r3,320fe08 <_strtod_r+0x114c>
 320fd9c:	e1c00017 	ldw	r7,0(fp)
 320fda0:	3880004c 	andi	r2,r7,1
 320fda4:	1005003a 	cmpeq	r2,r2,zero
 320fda8:	1000791e 	bne	r2,zero,320ff90 <_strtod_r+0x12d4>
 320fdac:	9000b126 	beq	r18,zero,3210074 <_strtod_r+0x13b8>
 320fdb0:	e4400117 	ldw	r17,4(fp)
 320fdb4:	3809883a 	mov	r4,r7
 320fdb8:	3821883a 	mov	r16,r7
 320fdbc:	880b883a 	mov	r5,r17
 320fdc0:	320dbd00 	call	320dbd0 <__ulp>
 320fdc4:	180f883a 	mov	r7,r3
 320fdc8:	880b883a 	mov	r5,r17
 320fdcc:	8009883a 	mov	r4,r16
 320fdd0:	100d883a 	mov	r6,r2
 320fdd4:	3212eb40 	call	3212eb4 <__subdf3>
 320fdd8:	1009883a 	mov	r4,r2
 320fddc:	000d883a 	mov	r6,zero
 320fde0:	000f883a 	mov	r7,zero
 320fde4:	180b883a 	mov	r5,r3
 320fde8:	e0800015 	stw	r2,0(fp)
 320fdec:	e0c00115 	stw	r3,4(fp)
 320fdf0:	321364c0 	call	321364c <__nedf2>
 320fdf4:	103f9a26 	beq	r2,zero,320fc60 <_strtod_r+0xfa4>
 320fdf8:	d9001417 	ldw	r4,80(sp)
 320fdfc:	2013003a 	cmpeq	r9,r4,zero
 320fe00:	483f211e 	bne	r9,zero,320fa88 <_strtod_r+0xdcc>
 320fe04:	003fcc06 	br	320fd38 <_strtod_r+0x107c>
 320fe08:	d9001417 	ldw	r4,80(sp)
 320fe0c:	e1c00017 	ldw	r7,0(fp)
 320fe10:	2013003a 	cmpeq	r9,r4,zero
 320fe14:	4800bd1e 	bne	r9,zero,321010c <_strtod_r+0x1450>
 320fe18:	28dffc2c 	andhi	r3,r5,32752
 320fe1c:	0081a834 	movhi	r2,1696
 320fe20:	10c0ba36 	bltu	r2,r3,321010c <_strtod_r+0x1450>
 320fe24:	1804d53a 	srli	r2,r3,20
 320fe28:	00c01ac4 	movi	r3,107
 320fe2c:	013fffc4 	movi	r4,-1
 320fe30:	1887c83a 	sub	r3,r3,r2
 320fe34:	20c4983a 	sll	r2,r4,r3
 320fe38:	11ffd91e 	bne	r2,r7,320fda0 <_strtod_r+0x10e4>
 320fe3c:	28dffc2c 	andhi	r3,r5,32752
 320fe40:	00800434 	movhi	r2,16
 320fe44:	188d883a 	add	r6,r3,r2
 320fe48:	e1800115 	stw	r6,4(fp)
 320fe4c:	e0000015 	stw	zero,0(fp)
 320fe50:	483f0d1e 	bne	r9,zero,320fa88 <_strtod_r+0xdcc>
 320fe54:	003fb806 	br	320fd38 <_strtod_r+0x107c>
 320fe58:	0021883a 	mov	r16,zero
 320fe5c:	0005883a 	mov	r2,zero
 320fe60:	044ff834 	movhi	r17,16352
 320fe64:	00eff834 	movhi	r3,49120
 320fe68:	003e8606 	br	320f884 <_strtod_r+0xbc8>
 320fe6c:	803d9e26 	beq	r16,zero,320f4e8 <_strtod_r+0x82c>
 320fe70:	0421c83a 	sub	r16,zero,r16
 320fe74:	814003cc 	andi	r5,r16,15
 320fe78:	28000f26 	beq	r5,zero,320feb8 <_strtod_r+0x11fc>
 320fe7c:	280a90fa 	slli	r5,r5,3
 320fe80:	0100c974 	movhi	r4,805
 320fe84:	2137e804 	addi	r4,r4,-8288
 320fe88:	e0800017 	ldw	r2,0(fp)
 320fe8c:	290b883a 	add	r5,r5,r4
 320fe90:	2a000017 	ldw	r8,0(r5)
 320fe94:	e0c00117 	ldw	r3,4(fp)
 320fe98:	2a400117 	ldw	r9,4(r5)
 320fe9c:	1009883a 	mov	r4,r2
 320fea0:	180b883a 	mov	r5,r3
 320fea4:	480f883a 	mov	r7,r9
 320fea8:	400d883a 	mov	r6,r8
 320feac:	321336c0 	call	321336c <__divdf3>
 320feb0:	e0c00115 	stw	r3,4(fp)
 320feb4:	e0800015 	stw	r2,0(fp)
 320feb8:	8021d13a 	srai	r16,r16,4
 320febc:	803d8a26 	beq	r16,zero,320f4e8 <_strtod_r+0x82c>
 320fec0:	008007c4 	movi	r2,31
 320fec4:	14002d16 	blt	r2,r16,320ff7c <_strtod_r+0x12c0>
 320fec8:	8080040c 	andi	r2,r16,16
 320fecc:	10009926 	beq	r2,zero,3210134 <_strtod_r+0x1478>
 320fed0:	00801a84 	movi	r2,106
 320fed4:	d8801415 	stw	r2,80(sp)
 320fed8:	0400110e 	bge	zero,r16,320ff20 <_strtod_r+0x1264>
 320fedc:	0440c974 	movhi	r17,805
 320fee0:	8c783504 	addi	r17,r17,-7980
 320fee4:	8080004c 	andi	r2,r16,1
 320fee8:	1005003a 	cmpeq	r2,r2,zero
 320feec:	1000091e 	bne	r2,zero,320ff14 <_strtod_r+0x1258>
 320fef0:	e0800017 	ldw	r2,0(fp)
 320fef4:	e0c00117 	ldw	r3,4(fp)
 320fef8:	89800017 	ldw	r6,0(r17)
 320fefc:	89c00117 	ldw	r7,4(r17)
 320ff00:	180b883a 	mov	r5,r3
 320ff04:	1009883a 	mov	r4,r2
 320ff08:	3212fa80 	call	3212fa8 <__muldf3>
 320ff0c:	e0c00115 	stw	r3,4(fp)
 320ff10:	e0800015 	stw	r2,0(fp)
 320ff14:	8021d07a 	srai	r16,r16,1
 320ff18:	8c400204 	addi	r17,r17,8
 320ff1c:	043ff116 	blt	zero,r16,320fee4 <_strtod_r+0x1228>
 320ff20:	d8c01417 	ldw	r3,80(sp)
 320ff24:	18000d26 	beq	r3,zero,320ff5c <_strtod_r+0x12a0>
 320ff28:	e1000117 	ldw	r4,4(fp)
 320ff2c:	00c01ac4 	movi	r3,107
 320ff30:	209ffc2c 	andhi	r2,r4,32752
 320ff34:	1004d53a 	srli	r2,r2,20
 320ff38:	1887c83a 	sub	r3,r3,r2
 320ff3c:	00c0070e 	bge	zero,r3,320ff5c <_strtod_r+0x12a0>
 320ff40:	008007c4 	movi	r2,31
 320ff44:	10c0900e 	bge	r2,r3,3210188 <_strtod_r+0x14cc>
 320ff48:	00800d04 	movi	r2,52
 320ff4c:	e0000015 	stw	zero,0(fp)
 320ff50:	10c0870e 	bge	r2,r3,3210170 <_strtod_r+0x14b4>
 320ff54:	0180dc34 	movhi	r6,880
 320ff58:	e1800115 	stw	r6,4(fp)
 320ff5c:	e0800017 	ldw	r2,0(fp)
 320ff60:	e0c00117 	ldw	r3,4(fp)
 320ff64:	000d883a 	mov	r6,zero
 320ff68:	000f883a 	mov	r7,zero
 320ff6c:	180b883a 	mov	r5,r3
 320ff70:	1009883a 	mov	r4,r2
 320ff74:	321364c0 	call	321364c <__nedf2>
 320ff78:	103d5c1e 	bne	r2,zero,320f4ec <_strtod_r+0x830>
 320ff7c:	00800884 	movi	r2,34
 320ff80:	a8800015 	stw	r2,0(r21)
 320ff84:	e0000015 	stw	zero,0(fp)
 320ff88:	e0000115 	stw	zero,4(fp)
 320ff8c:	003bc206 	br	320ee98 <_strtod_r+0x1dc>
 320ff90:	d8801417 	ldw	r2,80(sp)
 320ff94:	1013003a 	cmpeq	r9,r2,zero
 320ff98:	483ebb1e 	bne	r9,zero,320fa88 <_strtod_r+0xdcc>
 320ff9c:	003f6606 	br	320fd38 <_strtod_r+0x107c>
 320ffa0:	e1800117 	ldw	r6,4(fp)
 320ffa4:	00c00434 	movhi	r3,16
 320ffa8:	18ffffc4 	addi	r3,r3,-1
 320ffac:	30c4703a 	and	r2,r6,r3
 320ffb0:	103f7a1e 	bne	r2,zero,320fd9c <_strtod_r+0x10e0>
 320ffb4:	e1c00017 	ldw	r7,0(fp)
 320ffb8:	383f791e 	bne	r7,zero,320fda0 <_strtod_r+0x10e4>
 320ffbc:	003f5606 	br	320fd18 <_strtod_r+0x105c>
 320ffc0:	d9800f17 	ldw	r6,60(sp)
 320ffc4:	00bffa84 	movi	r2,-22
 320ffc8:	30bcd416 	blt	r6,r2,320f31c <_strtod_r+0x660>
 320ffcc:	317ffe24 	muli	r5,r6,-8
 320ffd0:	0100c974 	movhi	r4,805
 320ffd4:	2137e804 	addi	r4,r4,-8288
 320ffd8:	e0800017 	ldw	r2,0(fp)
 320ffdc:	290b883a 	add	r5,r5,r4
 320ffe0:	2a000017 	ldw	r8,0(r5)
 320ffe4:	e0c00117 	ldw	r3,4(fp)
 320ffe8:	2a400117 	ldw	r9,4(r5)
 320ffec:	1009883a 	mov	r4,r2
 320fff0:	180b883a 	mov	r5,r3
 320fff4:	480f883a 	mov	r7,r9
 320fff8:	400d883a 	mov	r6,r8
 320fffc:	321336c0 	call	321336c <__divdf3>
 3210000:	e0c00115 	stw	r3,4(fp)
 3210004:	e0800015 	stw	r2,0(fp)
 3210008:	003ba306 	br	320ee98 <_strtod_r+0x1dc>
 321000c:	00800404 	movi	r2,16
 3210010:	14c02f0e 	bge	r2,r19,32100d0 <_strtod_r+0x1414>
 3210014:	000f883a 	mov	r7,zero
 3210018:	003f2006 	br	320fc9c <_strtod_r+0xfe0>
 321001c:	d9801417 	ldw	r6,80(sp)
 3210020:	3013003a 	cmpeq	r9,r6,zero
 3210024:	483e981e 	bne	r9,zero,320fa88 <_strtod_r+0xdcc>
 3210028:	003f4306 	br	320fd38 <_strtod_r+0x107c>
 321002c:	00801a44 	movi	r2,105
 3210030:	20bc6326 	beq	r4,r2,320f1c0 <_strtod_r+0x504>
 3210034:	00801b84 	movi	r2,110
 3210038:	20bbba1e 	bne	r4,r2,320ef24 <_strtod_r+0x268>
 321003c:	dc000404 	addi	r16,sp,16
 3210040:	8009883a 	mov	r4,r16
 3210044:	0140c974 	movhi	r5,805
 3210048:	29783404 	addi	r5,r5,-7984
 321004c:	320ec740 	call	320ec74 <match>
 3210050:	103bb426 	beq	r2,zero,320ef24 <_strtod_r+0x268>
 3210054:	d8800417 	ldw	r2,16(sp)
 3210058:	00c00a04 	movi	r3,40
 321005c:	11000007 	ldb	r4,0(r2)
 3210060:	20c03626 	beq	r4,r3,321013c <_strtod_r+0x1480>
 3210064:	01bffe34 	movhi	r6,65528
 3210068:	e1800115 	stw	r6,4(fp)
 321006c:	e0000015 	stw	zero,0(fp)
 3210070:	003b8906 	br	320ee98 <_strtod_r+0x1dc>
 3210074:	e4400117 	ldw	r17,4(fp)
 3210078:	3809883a 	mov	r4,r7
 321007c:	3821883a 	mov	r16,r7
 3210080:	880b883a 	mov	r5,r17
 3210084:	320dbd00 	call	320dbd0 <__ulp>
 3210088:	100d883a 	mov	r6,r2
 321008c:	880b883a 	mov	r5,r17
 3210090:	180f883a 	mov	r7,r3
 3210094:	8009883a 	mov	r4,r16
 3210098:	3212f340 	call	3212f34 <__adddf3>
 321009c:	d9801417 	ldw	r6,80(sp)
 32100a0:	e0c00115 	stw	r3,4(fp)
 32100a4:	e0800015 	stw	r2,0(fp)
 32100a8:	3013003a 	cmpeq	r9,r6,zero
 32100ac:	483e761e 	bne	r9,zero,320fa88 <_strtod_r+0xdcc>
 32100b0:	003f2106 	br	320fd38 <_strtod_r+0x107c>
 32100b4:	000f883a 	mov	r7,zero
 32100b8:	003cf006 	br	320f47c <_strtod_r+0x7c0>
 32100bc:	0080d434 	movhi	r2,848
 32100c0:	188d883a 	add	r6,r3,r2
 32100c4:	d8001415 	stw	zero,80(sp)
 32100c8:	e1800115 	stw	r6,4(fp)
 32100cc:	003d0706 	br	320f4ec <_strtod_r+0x830>
 32100d0:	808002a4 	muli	r2,r16,10
 32100d4:	000f883a 	mov	r7,zero
 32100d8:	1261883a 	add	r16,r2,r9
 32100dc:	003eef06 	br	320fc9c <_strtod_r+0xfe0>
 32100e0:	309ffc2c 	andhi	r2,r6,32752
 32100e4:	00fffc34 	movhi	r3,65520
 32100e8:	10c5883a 	add	r2,r2,r3
 32100ec:	00c00434 	movhi	r3,16
 32100f0:	18ffffc4 	addi	r3,r3,-1
 32100f4:	10ccb03a 	or	r6,r2,r3
 32100f8:	01ffffc4 	movi	r7,-1
 32100fc:	e1800115 	stw	r6,4(fp)
 3210100:	e1c00015 	stw	r7,0(fp)
 3210104:	483e601e 	bne	r9,zero,320fa88 <_strtod_r+0xdcc>
 3210108:	003f0b06 	br	320fd38 <_strtod_r+0x107c>
 321010c:	00bfffc4 	movi	r2,-1
 3210110:	003f4906 	br	320fe38 <_strtod_r+0x117c>
 3210114:	0025883a 	mov	r18,zero
 3210118:	003cb106 	br	320f3e0 <_strtod_r+0x724>
 321011c:	d8c01417 	ldw	r3,80(sp)
 3210120:	1813003a 	cmpeq	r9,r3,zero
 3210124:	483e581e 	bne	r9,zero,320fa88 <_strtod_r+0xdcc>
 3210128:	003f0306 	br	320fd38 <_strtod_r+0x107c>
 321012c:	980f883a 	mov	r7,r19
 3210130:	003ed406 	br	320fc84 <_strtod_r+0xfc8>
 3210134:	d8001415 	stw	zero,80(sp)
 3210138:	003f6706 	br	320fed8 <_strtod_r+0x121c>
 321013c:	8009883a 	mov	r4,r16
 3210140:	0140c974 	movhi	r5,805
 3210144:	29439f04 	addi	r5,r5,3708
 3210148:	d9800d04 	addi	r6,sp,52
 321014c:	3211a2c0 	call	3211a2c <__hexnan>
 3210150:	00c00144 	movi	r3,5
 3210154:	10ffc31e 	bne	r2,r3,3210064 <_strtod_r+0x13a8>
 3210158:	d8800e17 	ldw	r2,56(sp)
 321015c:	d9c00d17 	ldw	r7,52(sp)
 3210160:	119ffc34 	orhi	r6,r2,32752
 3210164:	e1800115 	stw	r6,4(fp)
 3210168:	e1c00015 	stw	r7,0(fp)
 321016c:	003b4a06 	br	320ee98 <_strtod_r+0x1dc>
 3210170:	18fff804 	addi	r3,r3,-32
 3210174:	00bfffc4 	movi	r2,-1
 3210178:	10c4983a 	sll	r2,r2,r3
 321017c:	208c703a 	and	r6,r4,r2
 3210180:	e1800115 	stw	r6,4(fp)
 3210184:	003f7506 	br	320ff5c <_strtod_r+0x12a0>
 3210188:	00bfffc4 	movi	r2,-1
 321018c:	10c4983a 	sll	r2,r2,r3
 3210190:	e0c00017 	ldw	r3,0(fp)
 3210194:	188e703a 	and	r7,r3,r2
 3210198:	e1c00015 	stw	r7,0(fp)
 321019c:	003f6f06 	br	320ff5c <_strtod_r+0x12a0>

032101a0 <strtof>:
 32101a0:	defffa04 	addi	sp,sp,-24
 32101a4:	dd000415 	stw	r20,16(sp)
 32101a8:	0500c974 	movhi	r20,805
 32101ac:	a5097804 	addi	r20,r20,9696
 32101b0:	2007883a 	mov	r3,r4
 32101b4:	a1000017 	ldw	r4,0(r20)
 32101b8:	280d883a 	mov	r6,r5
 32101bc:	180b883a 	mov	r5,r3
 32101c0:	dfc00515 	stw	ra,20(sp)
 32101c4:	dcc00315 	stw	r19,12(sp)
 32101c8:	dc800215 	stw	r18,8(sp)
 32101cc:	dc400115 	stw	r17,4(sp)
 32101d0:	dc000015 	stw	r16,0(sp)
 32101d4:	320ecbc0 	call	320ecbc <_strtod_r>
 32101d8:	180b883a 	mov	r5,r3
 32101dc:	1009883a 	mov	r4,r2
 32101e0:	1823883a 	mov	r17,r3
 32101e4:	1021883a 	mov	r16,r2
 32101e8:	3213ac40 	call	3213ac4 <__truncdfsf2>
 32101ec:	1009883a 	mov	r4,r2
 32101f0:	000b883a 	mov	r5,zero
 32101f4:	1025883a 	mov	r18,r2
 32101f8:	1027883a 	mov	r19,r2
 32101fc:	321293c0 	call	321293c <__nesf2>
 3210200:	000d883a 	mov	r6,zero
 3210204:	000f883a 	mov	r7,zero
 3210208:	8009883a 	mov	r4,r16
 321020c:	880b883a 	mov	r5,r17
 3210210:	10000e1e 	bne	r2,zero,321024c <strtof+0xac>
 3210214:	321364c0 	call	321364c <__nedf2>
 3210218:	10000c26 	beq	r2,zero,321024c <strtof+0xac>
 321021c:	a0c00017 	ldw	r3,0(r20)
 3210220:	00800884 	movi	r2,34
 3210224:	18800015 	stw	r2,0(r3)
 3210228:	9805883a 	mov	r2,r19
 321022c:	dfc00517 	ldw	ra,20(sp)
 3210230:	dd000417 	ldw	r20,16(sp)
 3210234:	dcc00317 	ldw	r19,12(sp)
 3210238:	dc800217 	ldw	r18,8(sp)
 321023c:	dc400117 	ldw	r17,4(sp)
 3210240:	dc000017 	ldw	r16,0(sp)
 3210244:	dec00604 	addi	sp,sp,24
 3210248:	f800283a 	ret
 321024c:	9009883a 	mov	r4,r18
 3210250:	015fe034 	movhi	r5,32640
 3210254:	297fffc4 	addi	r5,r5,-1
 3210258:	32129b40 	call	32129b4 <__gtsf2>
 321025c:	00ffffc4 	movi	r3,-1
 3210260:	011ffc34 	movhi	r4,32752
 3210264:	213fffc4 	addi	r4,r4,-1
 3210268:	200f883a 	mov	r7,r4
 321026c:	180d883a 	mov	r6,r3
 3210270:	8009883a 	mov	r4,r16
 3210274:	880b883a 	mov	r5,r17
 3210278:	00800f16 	blt	zero,r2,32102b8 <strtof+0x118>
 321027c:	9009883a 	mov	r4,r18
 3210280:	017fe034 	movhi	r5,65408
 3210284:	297fffc4 	addi	r5,r5,-1
 3210288:	3212a2c0 	call	3212a2c <__ltsf2>
 321028c:	023fffc4 	movi	r8,-1
 3210290:	027ffc34 	movhi	r9,65520
 3210294:	4a7fffc4 	addi	r9,r9,-1
 3210298:	880b883a 	mov	r5,r17
 321029c:	480f883a 	mov	r7,r9
 32102a0:	8009883a 	mov	r4,r16
 32102a4:	400d883a 	mov	r6,r8
 32102a8:	103fdf0e 	bge	r2,zero,3210228 <strtof+0x88>
 32102ac:	32137e40 	call	32137e4 <__ltdf2>
 32102b0:	103fda0e 	bge	r2,zero,321021c <strtof+0x7c>
 32102b4:	003fdc06 	br	3210228 <strtof+0x88>
 32102b8:	32136d40 	call	32136d4 <__gtdf2>
 32102bc:	00bfd70e 	bge	zero,r2,321021c <strtof+0x7c>
 32102c0:	003fee06 	br	321027c <strtof+0xdc>

032102c4 <strtod>:
 32102c4:	0180c974 	movhi	r6,805
 32102c8:	31897804 	addi	r6,r6,9696
 32102cc:	2007883a 	mov	r3,r4
 32102d0:	31000017 	ldw	r4,0(r6)
 32102d4:	280d883a 	mov	r6,r5
 32102d8:	180b883a 	mov	r5,r3
 32102dc:	320ecbc1 	jmpi	320ecbc <_strtod_r>

032102e0 <_strtol_r>:
 32102e0:	defff304 	addi	sp,sp,-52
 32102e4:	0080c974 	movhi	r2,805
 32102e8:	10897704 	addi	r2,r2,9692
 32102ec:	dcc00615 	stw	r19,24(sp)
 32102f0:	14c00017 	ldw	r19,0(r2)
 32102f4:	ddc00a15 	stw	r23,40(sp)
 32102f8:	dc000315 	stw	r16,12(sp)
 32102fc:	dfc00c15 	stw	ra,48(sp)
 3210300:	df000b15 	stw	fp,44(sp)
 3210304:	dd800915 	stw	r22,36(sp)
 3210308:	dd400815 	stw	r21,32(sp)
 321030c:	dd000715 	stw	r20,28(sp)
 3210310:	dc800515 	stw	r18,20(sp)
 3210314:	dc400415 	stw	r17,16(sp)
 3210318:	282f883a 	mov	r23,r5
 321031c:	d9000015 	stw	r4,0(sp)
 3210320:	d9800115 	stw	r6,4(sp)
 3210324:	2821883a 	mov	r16,r5
 3210328:	84400007 	ldb	r17,0(r16)
 321032c:	84000044 	addi	r16,r16,1
 3210330:	9c47883a 	add	r3,r19,r17
 3210334:	18800003 	ldbu	r2,0(r3)
 3210338:	1080020c 	andi	r2,r2,8
 321033c:	103ffa1e 	bne	r2,zero,3210328 <_strtol_r+0x48>
 3210340:	00800b44 	movi	r2,45
 3210344:	88805c26 	beq	r17,r2,32104b8 <_strtol_r+0x1d8>
 3210348:	00800ac4 	movi	r2,43
 321034c:	88805726 	beq	r17,r2,32104ac <_strtol_r+0x1cc>
 3210350:	0039883a 	mov	fp,zero
 3210354:	3807003a 	cmpeq	r3,r7,zero
 3210358:	1800431e 	bne	r3,zero,3210468 <_strtol_r+0x188>
 321035c:	00800404 	movi	r2,16
 3210360:	38804126 	beq	r7,r2,3210468 <_strtol_r+0x188>
 3210364:	3829883a 	mov	r20,r7
 3210368:	e02cc03a 	cmpne	r22,fp,zero
 321036c:	b0004b1e 	bne	r22,zero,321049c <_strtol_r+0x1bc>
 3210370:	04a00034 	movhi	r18,32768
 3210374:	94bfffc4 	addi	r18,r18,-1
 3210378:	9009883a 	mov	r4,r18
 321037c:	a00b883a 	mov	r5,r20
 3210380:	d9c00215 	stw	r7,8(sp)
 3210384:	32044c40 	call	32044c4 <__umodsi3>
 3210388:	9009883a 	mov	r4,r18
 321038c:	a00b883a 	mov	r5,r20
 3210390:	102b883a 	mov	r21,r2
 3210394:	32044bc0 	call	32044bc <__udivsi3>
 3210398:	1011883a 	mov	r8,r2
 321039c:	9c45883a 	add	r2,r19,r17
 32103a0:	11000003 	ldbu	r4,0(r2)
 32103a4:	000b883a 	mov	r5,zero
 32103a8:	000d883a 	mov	r6,zero
 32103ac:	20c0010c 	andi	r3,r4,4
 32103b0:	d9c00217 	ldw	r7,8(sp)
 32103b4:	18000e26 	beq	r3,zero,32103f0 <_strtol_r+0x110>
 32103b8:	88fff404 	addi	r3,r17,-48
 32103bc:	19c0140e 	bge	r3,r7,3210410 <_strtol_r+0x130>
 32103c0:	30003116 	blt	r6,zero,3210488 <_strtol_r+0x1a8>
 32103c4:	41403036 	bltu	r8,r5,3210488 <_strtol_r+0x1a8>
 32103c8:	2a002e26 	beq	r5,r8,3210484 <_strtol_r+0x1a4>
 32103cc:	2d05383a 	mul	r2,r5,r20
 32103d0:	01800044 	movi	r6,1
 32103d4:	10cb883a 	add	r5,r2,r3
 32103d8:	84400007 	ldb	r17,0(r16)
 32103dc:	84000044 	addi	r16,r16,1
 32103e0:	9c45883a 	add	r2,r19,r17
 32103e4:	11000003 	ldbu	r4,0(r2)
 32103e8:	20c0010c 	andi	r3,r4,4
 32103ec:	183ff21e 	bne	r3,zero,32103b8 <_strtol_r+0xd8>
 32103f0:	208000cc 	andi	r2,r4,3
 32103f4:	10000626 	beq	r2,zero,3210410 <_strtol_r+0x130>
 32103f8:	2080004c 	andi	r2,r4,1
 32103fc:	1005003a 	cmpeq	r2,r2,zero
 3210400:	1000231e 	bne	r2,zero,3210490 <_strtol_r+0x1b0>
 3210404:	00800dc4 	movi	r2,55
 3210408:	8887c83a 	sub	r3,r17,r2
 321040c:	19ffec16 	blt	r3,r7,32103c0 <_strtol_r+0xe0>
 3210410:	30002d16 	blt	r6,zero,32104c8 <_strtol_r+0x1e8>
 3210414:	b000231e 	bne	r22,zero,32104a4 <_strtol_r+0x1c4>
 3210418:	2807883a 	mov	r3,r5
 321041c:	d8800117 	ldw	r2,4(sp)
 3210420:	10000426 	beq	r2,zero,3210434 <_strtol_r+0x154>
 3210424:	30000126 	beq	r6,zero,321042c <_strtol_r+0x14c>
 3210428:	85ffffc4 	addi	r23,r16,-1
 321042c:	d9000117 	ldw	r4,4(sp)
 3210430:	25c00015 	stw	r23,0(r4)
 3210434:	1805883a 	mov	r2,r3
 3210438:	dfc00c17 	ldw	ra,48(sp)
 321043c:	df000b17 	ldw	fp,44(sp)
 3210440:	ddc00a17 	ldw	r23,40(sp)
 3210444:	dd800917 	ldw	r22,36(sp)
 3210448:	dd400817 	ldw	r21,32(sp)
 321044c:	dd000717 	ldw	r20,28(sp)
 3210450:	dcc00617 	ldw	r19,24(sp)
 3210454:	dc800517 	ldw	r18,20(sp)
 3210458:	dc400417 	ldw	r17,16(sp)
 321045c:	dc000317 	ldw	r16,12(sp)
 3210460:	dec00d04 	addi	sp,sp,52
 3210464:	f800283a 	ret
 3210468:	00800c04 	movi	r2,48
 321046c:	88801d26 	beq	r17,r2,32104e4 <_strtol_r+0x204>
 3210470:	183fbc26 	beq	r3,zero,3210364 <_strtol_r+0x84>
 3210474:	00800c04 	movi	r2,48
 3210478:	88802726 	beq	r17,r2,3210518 <_strtol_r+0x238>
 321047c:	01c00284 	movi	r7,10
 3210480:	003fb806 	br	3210364 <_strtol_r+0x84>
 3210484:	a8ffd10e 	bge	r21,r3,32103cc <_strtol_r+0xec>
 3210488:	01bfffc4 	movi	r6,-1
 321048c:	003fd206 	br	32103d8 <_strtol_r+0xf8>
 3210490:	008015c4 	movi	r2,87
 3210494:	8887c83a 	sub	r3,r17,r2
 3210498:	003fdc06 	br	321040c <_strtol_r+0x12c>
 321049c:	04a00034 	movhi	r18,32768
 32104a0:	003fb506 	br	3210378 <_strtol_r+0x98>
 32104a4:	0147c83a 	sub	r3,zero,r5
 32104a8:	003fdc06 	br	321041c <_strtol_r+0x13c>
 32104ac:	84400007 	ldb	r17,0(r16)
 32104b0:	84000044 	addi	r16,r16,1
 32104b4:	003fa606 	br	3210350 <_strtol_r+0x70>
 32104b8:	84400007 	ldb	r17,0(r16)
 32104bc:	07000044 	movi	fp,1
 32104c0:	84000044 	addi	r16,r16,1
 32104c4:	003fa306 	br	3210354 <_strtol_r+0x74>
 32104c8:	e005003a 	cmpeq	r2,fp,zero
 32104cc:	10000f1e 	bne	r2,zero,321050c <_strtol_r+0x22c>
 32104d0:	00e00034 	movhi	r3,32768
 32104d4:	d9000017 	ldw	r4,0(sp)
 32104d8:	00800884 	movi	r2,34
 32104dc:	20800015 	stw	r2,0(r4)
 32104e0:	003fce06 	br	321041c <_strtol_r+0x13c>
 32104e4:	81000007 	ldb	r4,0(r16)
 32104e8:	00801e04 	movi	r2,120
 32104ec:	20800226 	beq	r4,r2,32104f8 <_strtol_r+0x218>
 32104f0:	00801604 	movi	r2,88
 32104f4:	20bfde1e 	bne	r4,r2,3210470 <_strtol_r+0x190>
 32104f8:	84400047 	ldb	r17,1(r16)
 32104fc:	01c00404 	movi	r7,16
 3210500:	84000084 	addi	r16,r16,2
 3210504:	3829883a 	mov	r20,r7
 3210508:	003f9706 	br	3210368 <_strtol_r+0x88>
 321050c:	00e00034 	movhi	r3,32768
 3210510:	18ffffc4 	addi	r3,r3,-1
 3210514:	003fef06 	br	32104d4 <_strtol_r+0x1f4>
 3210518:	01c00204 	movi	r7,8
 321051c:	3829883a 	mov	r20,r7
 3210520:	003f9106 	br	3210368 <_strtol_r+0x88>

03210524 <strtol>:
 3210524:	0080c974 	movhi	r2,805
 3210528:	10897804 	addi	r2,r2,9696
 321052c:	2013883a 	mov	r9,r4
 3210530:	11000017 	ldw	r4,0(r2)
 3210534:	2805883a 	mov	r2,r5
 3210538:	300f883a 	mov	r7,r6
 321053c:	480b883a 	mov	r5,r9
 3210540:	100d883a 	mov	r6,r2
 3210544:	32102e01 	jmpi	32102e0 <_strtol_r>

03210548 <_strtoll_r>:
 3210548:	defff004 	addi	sp,sp,-64
 321054c:	0080c974 	movhi	r2,805
 3210550:	10897704 	addi	r2,r2,9692
 3210554:	df000e15 	stw	fp,56(sp)
 3210558:	17000017 	ldw	fp,0(r2)
 321055c:	ddc00d15 	stw	r23,52(sp)
 3210560:	dd000a15 	stw	r20,40(sp)
 3210564:	dfc00f15 	stw	ra,60(sp)
 3210568:	dd800c15 	stw	r22,48(sp)
 321056c:	dd400b15 	stw	r21,44(sp)
 3210570:	dcc00915 	stw	r19,36(sp)
 3210574:	dc800815 	stw	r18,32(sp)
 3210578:	dc400715 	stw	r17,28(sp)
 321057c:	dc000615 	stw	r16,24(sp)
 3210580:	d9400315 	stw	r5,12(sp)
 3210584:	d9000215 	stw	r4,8(sp)
 3210588:	d9800415 	stw	r6,16(sp)
 321058c:	382f883a 	mov	r23,r7
 3210590:	2829883a 	mov	r20,r5
 3210594:	a4c00007 	ldb	r19,0(r20)
 3210598:	a5000044 	addi	r20,r20,1
 321059c:	e4c7883a 	add	r3,fp,r19
 32105a0:	18800003 	ldbu	r2,0(r3)
 32105a4:	1080020c 	andi	r2,r2,8
 32105a8:	103ffa1e 	bne	r2,zero,3210594 <_strtoll_r+0x4c>
 32105ac:	00800b44 	movi	r2,45
 32105b0:	98808826 	beq	r19,r2,32107d4 <_strtoll_r+0x28c>
 32105b4:	00800ac4 	movi	r2,43
 32105b8:	98808326 	beq	r19,r2,32107c8 <_strtoll_r+0x280>
 32105bc:	d8000115 	stw	zero,4(sp)
 32105c0:	b807003a 	cmpeq	r3,r23,zero
 32105c4:	18005f1e 	bne	r3,zero,3210744 <_strtoll_r+0x1fc>
 32105c8:	00800404 	movi	r2,16
 32105cc:	b8805d26 	beq	r23,r2,3210744 <_strtoll_r+0x1fc>
 32105d0:	b82dd7fa 	srai	r22,r23,31
 32105d4:	b82b883a 	mov	r21,r23
 32105d8:	d8c00117 	ldw	r3,4(sp)
 32105dc:	1806c03a 	cmpne	r3,r3,zero
 32105e0:	d8c00515 	stw	r3,20(sp)
 32105e4:	1800631e 	bne	r3,zero,3210774 <_strtoll_r+0x22c>
 32105e8:	043fffc4 	movi	r16,-1
 32105ec:	04600034 	movhi	r17,32768
 32105f0:	8c7fffc4 	addi	r17,r17,-1
 32105f4:	880b883a 	mov	r5,r17
 32105f8:	8009883a 	mov	r4,r16
 32105fc:	a80d883a 	mov	r6,r21
 3210600:	b00f883a 	mov	r7,r22
 3210604:	321238c0 	call	321238c <__umoddi3>
 3210608:	880b883a 	mov	r5,r17
 321060c:	8009883a 	mov	r4,r16
 3210610:	b00f883a 	mov	r7,r22
 3210614:	a80d883a 	mov	r6,r21
 3210618:	d8800015 	stw	r2,0(sp)
 321061c:	3211db00 	call	3211db0 <__udivdi3>
 3210620:	1023883a 	mov	r17,r2
 3210624:	e4c5883a 	add	r2,fp,r19
 3210628:	11000003 	ldbu	r4,0(r2)
 321062c:	1825883a 	mov	r18,r3
 3210630:	0015883a 	mov	r10,zero
 3210634:	20c0010c 	andi	r3,r4,4
 3210638:	0017883a 	mov	r11,zero
 321063c:	000f883a 	mov	r7,zero
 3210640:	18001a26 	beq	r3,zero,32106ac <_strtoll_r+0x164>
 3210644:	9c3ff404 	addi	r16,r19,-48
 3210648:	85c0200e 	bge	r16,r23,32106cc <_strtoll_r+0x184>
 321064c:	38003b16 	blt	r7,zero,321073c <_strtoll_r+0x1f4>
 3210650:	92c03a36 	bltu	r18,r11,321073c <_strtoll_r+0x1f4>
 3210654:	5c803826 	beq	r11,r18,3210738 <_strtoll_r+0x1f0>
 3210658:	54404c26 	beq	r10,r17,321078c <_strtoll_r+0x244>
 321065c:	580b883a 	mov	r5,r11
 3210660:	5009883a 	mov	r4,r10
 3210664:	a80d883a 	mov	r6,r21
 3210668:	b00f883a 	mov	r7,r22
 321066c:	3211c740 	call	3211c74 <__muldi3>
 3210670:	8013d7fa 	srai	r9,r16,31
 3210674:	100d883a 	mov	r6,r2
 3210678:	1405883a 	add	r2,r2,r16
 321067c:	118d803a 	cmpltu	r6,r2,r6
 3210680:	1a47883a 	add	r3,r3,r9
 3210684:	30cd883a 	add	r6,r6,r3
 3210688:	1015883a 	mov	r10,r2
 321068c:	3017883a 	mov	r11,r6
 3210690:	01c00044 	movi	r7,1
 3210694:	a4c00007 	ldb	r19,0(r20)
 3210698:	a5000044 	addi	r20,r20,1
 321069c:	e4c5883a 	add	r2,fp,r19
 32106a0:	11000003 	ldbu	r4,0(r2)
 32106a4:	20c0010c 	andi	r3,r4,4
 32106a8:	183fe61e 	bne	r3,zero,3210644 <_strtoll_r+0xfc>
 32106ac:	208000cc 	andi	r2,r4,3
 32106b0:	10000626 	beq	r2,zero,32106cc <_strtoll_r+0x184>
 32106b4:	2080004c 	andi	r2,r4,1
 32106b8:	1005003a 	cmpeq	r2,r2,zero
 32106bc:	1000301e 	bne	r2,zero,3210780 <_strtoll_r+0x238>
 32106c0:	02000dc4 	movi	r8,55
 32106c4:	9a21c83a 	sub	r16,r19,r8
 32106c8:	85ffe016 	blt	r16,r23,321064c <_strtoll_r+0x104>
 32106cc:	38004616 	blt	r7,zero,32107e8 <_strtoll_r+0x2a0>
 32106d0:	d8800517 	ldw	r2,20(sp)
 32106d4:	1000341e 	bne	r2,zero,32107a8 <_strtoll_r+0x260>
 32106d8:	500b883a 	mov	r5,r10
 32106dc:	580d883a 	mov	r6,r11
 32106e0:	d8c00417 	ldw	r3,16(sp)
 32106e4:	18000626 	beq	r3,zero,3210700 <_strtoll_r+0x1b8>
 32106e8:	38000226 	beq	r7,zero,32106f4 <_strtoll_r+0x1ac>
 32106ec:	a53fffc4 	addi	r20,r20,-1
 32106f0:	dd000315 	stw	r20,12(sp)
 32106f4:	d8c00317 	ldw	r3,12(sp)
 32106f8:	d8800417 	ldw	r2,16(sp)
 32106fc:	10c00015 	stw	r3,0(r2)
 3210700:	2805883a 	mov	r2,r5
 3210704:	3007883a 	mov	r3,r6
 3210708:	dfc00f17 	ldw	ra,60(sp)
 321070c:	df000e17 	ldw	fp,56(sp)
 3210710:	ddc00d17 	ldw	r23,52(sp)
 3210714:	dd800c17 	ldw	r22,48(sp)
 3210718:	dd400b17 	ldw	r21,44(sp)
 321071c:	dd000a17 	ldw	r20,40(sp)
 3210720:	dcc00917 	ldw	r19,36(sp)
 3210724:	dc800817 	ldw	r18,32(sp)
 3210728:	dc400717 	ldw	r17,28(sp)
 321072c:	dc000617 	ldw	r16,24(sp)
 3210730:	dec01004 	addi	sp,sp,64
 3210734:	f800283a 	ret
 3210738:	8abfc72e 	bgeu	r17,r10,3210658 <_strtoll_r+0x110>
 321073c:	01ffffc4 	movi	r7,-1
 3210740:	003fd406 	br	3210694 <_strtoll_r+0x14c>
 3210744:	00800c04 	movi	r2,48
 3210748:	98803226 	beq	r19,r2,3210814 <_strtoll_r+0x2cc>
 321074c:	183fa026 	beq	r3,zero,32105d0 <_strtoll_r+0x88>
 3210750:	00800c04 	movi	r2,48
 3210754:	98803e26 	beq	r19,r2,3210850 <_strtoll_r+0x308>
 3210758:	d8c00117 	ldw	r3,4(sp)
 321075c:	05c00284 	movi	r23,10
 3210760:	b82b883a 	mov	r21,r23
 3210764:	1806c03a 	cmpne	r3,r3,zero
 3210768:	002d883a 	mov	r22,zero
 321076c:	d8c00515 	stw	r3,20(sp)
 3210770:	183f9d26 	beq	r3,zero,32105e8 <_strtoll_r+0xa0>
 3210774:	0021883a 	mov	r16,zero
 3210778:	04600034 	movhi	r17,32768
 321077c:	003f9d06 	br	32105f4 <_strtoll_r+0xac>
 3210780:	020015c4 	movi	r8,87
 3210784:	9a21c83a 	sub	r16,r19,r8
 3210788:	003fcf06 	br	32106c8 <_strtoll_r+0x180>
 321078c:	5cbfb31e 	bne	r11,r18,321065c <_strtoll_r+0x114>
 3210790:	d8800017 	ldw	r2,0(sp)
 3210794:	143fb10e 	bge	r2,r16,321065c <_strtoll_r+0x114>
 3210798:	8815883a 	mov	r10,r17
 321079c:	9017883a 	mov	r11,r18
 32107a0:	01ffffc4 	movi	r7,-1
 32107a4:	003fbb06 	br	3210694 <_strtoll_r+0x14c>
 32107a8:	0009883a 	mov	r4,zero
 32107ac:	2285c83a 	sub	r2,r4,r10
 32107b0:	2089803a 	cmpltu	r4,r4,r2
 32107b4:	02c7c83a 	sub	r3,zero,r11
 32107b8:	1909c83a 	sub	r4,r3,r4
 32107bc:	100b883a 	mov	r5,r2
 32107c0:	200d883a 	mov	r6,r4
 32107c4:	003fc606 	br	32106e0 <_strtoll_r+0x198>
 32107c8:	a4c00007 	ldb	r19,0(r20)
 32107cc:	a5000044 	addi	r20,r20,1
 32107d0:	003f7a06 	br	32105bc <_strtoll_r+0x74>
 32107d4:	a4c00007 	ldb	r19,0(r20)
 32107d8:	00800044 	movi	r2,1
 32107dc:	a5000044 	addi	r20,r20,1
 32107e0:	d8800115 	stw	r2,4(sp)
 32107e4:	003f7606 	br	32105c0 <_strtoll_r+0x78>
 32107e8:	d8c00117 	ldw	r3,4(sp)
 32107ec:	1805003a 	cmpeq	r2,r3,zero
 32107f0:	1000131e 	bne	r2,zero,3210840 <_strtoll_r+0x2f8>
 32107f4:	0005883a 	mov	r2,zero
 32107f8:	00e00034 	movhi	r3,32768
 32107fc:	100b883a 	mov	r5,r2
 3210800:	180d883a 	mov	r6,r3
 3210804:	d8c00217 	ldw	r3,8(sp)
 3210808:	00800884 	movi	r2,34
 321080c:	18800015 	stw	r2,0(r3)
 3210810:	003fb306 	br	32106e0 <_strtoll_r+0x198>
 3210814:	a1000007 	ldb	r4,0(r20)
 3210818:	00801e04 	movi	r2,120
 321081c:	20800226 	beq	r4,r2,3210828 <_strtoll_r+0x2e0>
 3210820:	00801604 	movi	r2,88
 3210824:	20bfc91e 	bne	r4,r2,321074c <_strtoll_r+0x204>
 3210828:	a4c00047 	ldb	r19,1(r20)
 321082c:	05c00404 	movi	r23,16
 3210830:	b82b883a 	mov	r21,r23
 3210834:	a5000084 	addi	r20,r20,2
 3210838:	002d883a 	mov	r22,zero
 321083c:	003f6606 	br	32105d8 <_strtoll_r+0x90>
 3210840:	017fffc4 	movi	r5,-1
 3210844:	01a00034 	movhi	r6,32768
 3210848:	31bfffc4 	addi	r6,r6,-1
 321084c:	003fed06 	br	3210804 <_strtoll_r+0x2bc>
 3210850:	05c00204 	movi	r23,8
 3210854:	b82b883a 	mov	r21,r23
 3210858:	002d883a 	mov	r22,zero
 321085c:	003f5e06 	br	32105d8 <_strtoll_r+0x90>

03210860 <_strtoul_r>:
 3210860:	defff604 	addi	sp,sp,-40
 3210864:	0080c974 	movhi	r2,805
 3210868:	10897704 	addi	r2,r2,9692
 321086c:	dd000415 	stw	r20,16(sp)
 3210870:	15000017 	ldw	r20,0(r2)
 3210874:	ddc00715 	stw	r23,28(sp)
 3210878:	dd800615 	stw	r22,24(sp)
 321087c:	dd400515 	stw	r21,20(sp)
 3210880:	dc800215 	stw	r18,8(sp)
 3210884:	dc000015 	stw	r16,0(sp)
 3210888:	dfc00915 	stw	ra,36(sp)
 321088c:	df000815 	stw	fp,32(sp)
 3210890:	dcc00315 	stw	r19,12(sp)
 3210894:	dc400115 	stw	r17,4(sp)
 3210898:	282b883a 	mov	r21,r5
 321089c:	202f883a 	mov	r23,r4
 32108a0:	302d883a 	mov	r22,r6
 32108a4:	3825883a 	mov	r18,r7
 32108a8:	2821883a 	mov	r16,r5
 32108ac:	84400007 	ldb	r17,0(r16)
 32108b0:	84000044 	addi	r16,r16,1
 32108b4:	a447883a 	add	r3,r20,r17
 32108b8:	18800003 	ldbu	r2,0(r3)
 32108bc:	1080020c 	andi	r2,r2,8
 32108c0:	103ffa1e 	bne	r2,zero,32108ac <_strtoul_r+0x4c>
 32108c4:	00800b44 	movi	r2,45
 32108c8:	88805626 	beq	r17,r2,3210a24 <_strtoul_r+0x1c4>
 32108cc:	00800ac4 	movi	r2,43
 32108d0:	88805126 	beq	r17,r2,3210a18 <_strtoul_r+0x1b8>
 32108d4:	0039883a 	mov	fp,zero
 32108d8:	9007003a 	cmpeq	r3,r18,zero
 32108dc:	18003b1e 	bne	r3,zero,32109cc <_strtoul_r+0x16c>
 32108e0:	00800404 	movi	r2,16
 32108e4:	90803926 	beq	r18,r2,32109cc <_strtoul_r+0x16c>
 32108e8:	013fffc4 	movi	r4,-1
 32108ec:	900b883a 	mov	r5,r18
 32108f0:	32044bc0 	call	32044bc <__udivsi3>
 32108f4:	013fffc4 	movi	r4,-1
 32108f8:	900b883a 	mov	r5,r18
 32108fc:	1027883a 	mov	r19,r2
 3210900:	32044c40 	call	32044c4 <__umodsi3>
 3210904:	1011883a 	mov	r8,r2
 3210908:	900f883a 	mov	r7,r18
 321090c:	a445883a 	add	r2,r20,r17
 3210910:	11000003 	ldbu	r4,0(r2)
 3210914:	000b883a 	mov	r5,zero
 3210918:	000d883a 	mov	r6,zero
 321091c:	20c0010c 	andi	r3,r4,4
 3210920:	18000e26 	beq	r3,zero,321095c <_strtoul_r+0xfc>
 3210924:	88fff404 	addi	r3,r17,-48
 3210928:	1c80140e 	bge	r3,r18,321097c <_strtoul_r+0x11c>
 321092c:	30003316 	blt	r6,zero,32109fc <_strtoul_r+0x19c>
 3210930:	99403236 	bltu	r19,r5,32109fc <_strtoul_r+0x19c>
 3210934:	2cc03026 	beq	r5,r19,32109f8 <_strtoul_r+0x198>
 3210938:	29c5383a 	mul	r2,r5,r7
 321093c:	01800044 	movi	r6,1
 3210940:	10cb883a 	add	r5,r2,r3
 3210944:	84400007 	ldb	r17,0(r16)
 3210948:	84000044 	addi	r16,r16,1
 321094c:	a445883a 	add	r2,r20,r17
 3210950:	11000003 	ldbu	r4,0(r2)
 3210954:	20c0010c 	andi	r3,r4,4
 3210958:	183ff21e 	bne	r3,zero,3210924 <_strtoul_r+0xc4>
 321095c:	208000cc 	andi	r2,r4,3
 3210960:	10000626 	beq	r2,zero,321097c <_strtoul_r+0x11c>
 3210964:	2080004c 	andi	r2,r4,1
 3210968:	1005003a 	cmpeq	r2,r2,zero
 321096c:	1000251e 	bne	r2,zero,3210a04 <_strtoul_r+0x1a4>
 3210970:	00800dc4 	movi	r2,55
 3210974:	8887c83a 	sub	r3,r17,r2
 3210978:	1cbfec16 	blt	r3,r18,321092c <_strtoul_r+0xcc>
 321097c:	3000400e 	bge	r6,zero,3210a80 <_strtoul_r+0x220>
 3210980:	00800884 	movi	r2,34
 3210984:	017fffc4 	movi	r5,-1
 3210988:	b8800015 	stw	r2,0(r23)
 321098c:	b0000226 	beq	r22,zero,3210998 <_strtoul_r+0x138>
 3210990:	30001f1e 	bne	r6,zero,3210a10 <_strtoul_r+0x1b0>
 3210994:	b5400015 	stw	r21,0(r22)
 3210998:	2805883a 	mov	r2,r5
 321099c:	dfc00917 	ldw	ra,36(sp)
 32109a0:	df000817 	ldw	fp,32(sp)
 32109a4:	ddc00717 	ldw	r23,28(sp)
 32109a8:	dd800617 	ldw	r22,24(sp)
 32109ac:	dd400517 	ldw	r21,20(sp)
 32109b0:	dd000417 	ldw	r20,16(sp)
 32109b4:	dcc00317 	ldw	r19,12(sp)
 32109b8:	dc800217 	ldw	r18,8(sp)
 32109bc:	dc400117 	ldw	r17,4(sp)
 32109c0:	dc000017 	ldw	r16,0(sp)
 32109c4:	dec00a04 	addi	sp,sp,40
 32109c8:	f800283a 	ret
 32109cc:	00800c04 	movi	r2,48
 32109d0:	88801826 	beq	r17,r2,3210a34 <_strtoul_r+0x1d4>
 32109d4:	183fc426 	beq	r3,zero,32108e8 <_strtoul_r+0x88>
 32109d8:	00800c04 	movi	r2,48
 32109dc:	88802226 	beq	r17,r2,3210a68 <_strtoul_r+0x208>
 32109e0:	04800284 	movi	r18,10
 32109e4:	900f883a 	mov	r7,r18
 32109e8:	04c666b4 	movhi	r19,6554
 32109ec:	9ce66644 	addi	r19,r19,-26215
 32109f0:	02000144 	movi	r8,5
 32109f4:	003fc506 	br	321090c <_strtoul_r+0xac>
 32109f8:	40ffcf0e 	bge	r8,r3,3210938 <_strtoul_r+0xd8>
 32109fc:	01bfffc4 	movi	r6,-1
 3210a00:	003fd006 	br	3210944 <_strtoul_r+0xe4>
 3210a04:	008015c4 	movi	r2,87
 3210a08:	8887c83a 	sub	r3,r17,r2
 3210a0c:	003fda06 	br	3210978 <_strtoul_r+0x118>
 3210a10:	857fffc4 	addi	r21,r16,-1
 3210a14:	003fdf06 	br	3210994 <_strtoul_r+0x134>
 3210a18:	84400007 	ldb	r17,0(r16)
 3210a1c:	84000044 	addi	r16,r16,1
 3210a20:	003fac06 	br	32108d4 <_strtoul_r+0x74>
 3210a24:	84400007 	ldb	r17,0(r16)
 3210a28:	07000044 	movi	fp,1
 3210a2c:	84000044 	addi	r16,r16,1
 3210a30:	003fa906 	br	32108d8 <_strtoul_r+0x78>
 3210a34:	81000007 	ldb	r4,0(r16)
 3210a38:	00801e04 	movi	r2,120
 3210a3c:	20800226 	beq	r4,r2,3210a48 <_strtoul_r+0x1e8>
 3210a40:	00801604 	movi	r2,88
 3210a44:	20bfe31e 	bne	r4,r2,32109d4 <_strtoul_r+0x174>
 3210a48:	84400047 	ldb	r17,1(r16)
 3210a4c:	04800404 	movi	r18,16
 3210a50:	84000084 	addi	r16,r16,2
 3210a54:	900f883a 	mov	r7,r18
 3210a58:	04c40034 	movhi	r19,4096
 3210a5c:	9cffffc4 	addi	r19,r19,-1
 3210a60:	020003c4 	movi	r8,15
 3210a64:	003fa906 	br	321090c <_strtoul_r+0xac>
 3210a68:	04800204 	movi	r18,8
 3210a6c:	900f883a 	mov	r7,r18
 3210a70:	04c80034 	movhi	r19,8192
 3210a74:	9cffffc4 	addi	r19,r19,-1
 3210a78:	020001c4 	movi	r8,7
 3210a7c:	003fa306 	br	321090c <_strtoul_r+0xac>
 3210a80:	e005003a 	cmpeq	r2,fp,zero
 3210a84:	103fc11e 	bne	r2,zero,321098c <_strtoul_r+0x12c>
 3210a88:	014bc83a 	sub	r5,zero,r5
 3210a8c:	003fbf06 	br	321098c <_strtoul_r+0x12c>

03210a90 <strtoul>:
 3210a90:	0080c974 	movhi	r2,805
 3210a94:	10897804 	addi	r2,r2,9696
 3210a98:	2013883a 	mov	r9,r4
 3210a9c:	11000017 	ldw	r4,0(r2)
 3210aa0:	2805883a 	mov	r2,r5
 3210aa4:	300f883a 	mov	r7,r6
 3210aa8:	480b883a 	mov	r5,r9
 3210aac:	100d883a 	mov	r6,r2
 3210ab0:	32108601 	jmpi	3210860 <_strtoul_r>

03210ab4 <_strtoull_r>:
 3210ab4:	defff104 	addi	sp,sp,-60
 3210ab8:	0080c974 	movhi	r2,805
 3210abc:	10897704 	addi	r2,r2,9692
 3210ac0:	df000d15 	stw	fp,52(sp)
 3210ac4:	17000017 	ldw	fp,0(r2)
 3210ac8:	ddc00c15 	stw	r23,48(sp)
 3210acc:	dcc00815 	stw	r19,32(sp)
 3210ad0:	dfc00e15 	stw	ra,56(sp)
 3210ad4:	dd800b15 	stw	r22,44(sp)
 3210ad8:	dd400a15 	stw	r21,40(sp)
 3210adc:	dd000915 	stw	r20,36(sp)
 3210ae0:	dc800715 	stw	r18,28(sp)
 3210ae4:	dc400615 	stw	r17,24(sp)
 3210ae8:	dc000515 	stw	r16,20(sp)
 3210aec:	d9400215 	stw	r5,8(sp)
 3210af0:	d9000115 	stw	r4,4(sp)
 3210af4:	d9800315 	stw	r6,12(sp)
 3210af8:	382f883a 	mov	r23,r7
 3210afc:	2827883a 	mov	r19,r5
 3210b00:	9d000007 	ldb	r20,0(r19)
 3210b04:	9cc00044 	addi	r19,r19,1
 3210b08:	e507883a 	add	r3,fp,r20
 3210b0c:	18800003 	ldbu	r2,0(r3)
 3210b10:	1080020c 	andi	r2,r2,8
 3210b14:	103ffa1e 	bne	r2,zero,3210b00 <_strtoull_r+0x4c>
 3210b18:	00800b44 	movi	r2,45
 3210b1c:	a0807a26 	beq	r20,r2,3210d08 <_strtoull_r+0x254>
 3210b20:	00800ac4 	movi	r2,43
 3210b24:	a0807526 	beq	r20,r2,3210cfc <_strtoull_r+0x248>
 3210b28:	d8000015 	stw	zero,0(sp)
 3210b2c:	b807003a 	cmpeq	r3,r23,zero
 3210b30:	18005a1e 	bne	r3,zero,3210c9c <_strtoull_r+0x1e8>
 3210b34:	00800404 	movi	r2,16
 3210b38:	b8805826 	beq	r23,r2,3210c9c <_strtoull_r+0x1e8>
 3210b3c:	b82dd7fa 	srai	r22,r23,31
 3210b40:	043fffc4 	movi	r16,-1
 3210b44:	8009883a 	mov	r4,r16
 3210b48:	800b883a 	mov	r5,r16
 3210b4c:	b80d883a 	mov	r6,r23
 3210b50:	b00f883a 	mov	r7,r22
 3210b54:	3211db00 	call	3211db0 <__udivdi3>
 3210b58:	8009883a 	mov	r4,r16
 3210b5c:	800b883a 	mov	r5,r16
 3210b60:	b80d883a 	mov	r6,r23
 3210b64:	b00f883a 	mov	r7,r22
 3210b68:	1023883a 	mov	r17,r2
 3210b6c:	1825883a 	mov	r18,r3
 3210b70:	321238c0 	call	321238c <__umoddi3>
 3210b74:	b82b883a 	mov	r21,r23
 3210b78:	1019883a 	mov	r12,r2
 3210b7c:	e505883a 	add	r2,fp,r20
 3210b80:	11000003 	ldbu	r4,0(r2)
 3210b84:	0015883a 	mov	r10,zero
 3210b88:	0017883a 	mov	r11,zero
 3210b8c:	20c0010c 	andi	r3,r4,4
 3210b90:	000d883a 	mov	r6,zero
 3210b94:	18001c26 	beq	r3,zero,3210c08 <_strtoull_r+0x154>
 3210b98:	a43ff404 	addi	r16,r20,-48
 3210b9c:	85c0220e 	bge	r16,r23,3210c28 <_strtoull_r+0x174>
 3210ba0:	30003c16 	blt	r6,zero,3210c94 <_strtoull_r+0x1e0>
 3210ba4:	92c03b36 	bltu	r18,r11,3210c94 <_strtoull_r+0x1e0>
 3210ba8:	5c803926 	beq	r11,r18,3210c90 <_strtoull_r+0x1dc>
 3210bac:	54404c26 	beq	r10,r17,3210ce0 <_strtoull_r+0x22c>
 3210bb0:	580b883a 	mov	r5,r11
 3210bb4:	5009883a 	mov	r4,r10
 3210bb8:	a80d883a 	mov	r6,r21
 3210bbc:	b00f883a 	mov	r7,r22
 3210bc0:	db000415 	stw	r12,16(sp)
 3210bc4:	3211c740 	call	3211c74 <__muldi3>
 3210bc8:	8013d7fa 	srai	r9,r16,31
 3210bcc:	100d883a 	mov	r6,r2
 3210bd0:	1405883a 	add	r2,r2,r16
 3210bd4:	118d803a 	cmpltu	r6,r2,r6
 3210bd8:	1a47883a 	add	r3,r3,r9
 3210bdc:	db000417 	ldw	r12,16(sp)
 3210be0:	30cd883a 	add	r6,r6,r3
 3210be4:	3017883a 	mov	r11,r6
 3210be8:	1015883a 	mov	r10,r2
 3210bec:	01800044 	movi	r6,1
 3210bf0:	9d000007 	ldb	r20,0(r19)
 3210bf4:	9cc00044 	addi	r19,r19,1
 3210bf8:	e505883a 	add	r2,fp,r20
 3210bfc:	11000003 	ldbu	r4,0(r2)
 3210c00:	20c0010c 	andi	r3,r4,4
 3210c04:	183fe41e 	bne	r3,zero,3210b98 <_strtoull_r+0xe4>
 3210c08:	208000cc 	andi	r2,r4,3
 3210c0c:	10000626 	beq	r2,zero,3210c28 <_strtoull_r+0x174>
 3210c10:	2080004c 	andi	r2,r4,1
 3210c14:	1005003a 	cmpeq	r2,r2,zero
 3210c18:	10002e1e 	bne	r2,zero,3210cd4 <_strtoull_r+0x220>
 3210c1c:	02000dc4 	movi	r8,55
 3210c20:	a221c83a 	sub	r16,r20,r8
 3210c24:	85ffde16 	blt	r16,r23,3210ba0 <_strtoull_r+0xec>
 3210c28:	3000530e 	bge	r6,zero,3210d78 <_strtoull_r+0x2c4>
 3210c2c:	d8c00117 	ldw	r3,4(sp)
 3210c30:	02bfffc4 	movi	r10,-1
 3210c34:	00800884 	movi	r2,34
 3210c38:	5017883a 	mov	r11,r10
 3210c3c:	18800015 	stw	r2,0(r3)
 3210c40:	d8800317 	ldw	r2,12(sp)
 3210c44:	10000426 	beq	r2,zero,3210c58 <_strtoull_r+0x1a4>
 3210c48:	3000291e 	bne	r6,zero,3210cf0 <_strtoull_r+0x23c>
 3210c4c:	d8800217 	ldw	r2,8(sp)
 3210c50:	d8c00317 	ldw	r3,12(sp)
 3210c54:	18800015 	stw	r2,0(r3)
 3210c58:	5005883a 	mov	r2,r10
 3210c5c:	5807883a 	mov	r3,r11
 3210c60:	dfc00e17 	ldw	ra,56(sp)
 3210c64:	df000d17 	ldw	fp,52(sp)
 3210c68:	ddc00c17 	ldw	r23,48(sp)
 3210c6c:	dd800b17 	ldw	r22,44(sp)
 3210c70:	dd400a17 	ldw	r21,40(sp)
 3210c74:	dd000917 	ldw	r20,36(sp)
 3210c78:	dcc00817 	ldw	r19,32(sp)
 3210c7c:	dc800717 	ldw	r18,28(sp)
 3210c80:	dc400617 	ldw	r17,24(sp)
 3210c84:	dc000517 	ldw	r16,20(sp)
 3210c88:	dec00f04 	addi	sp,sp,60
 3210c8c:	f800283a 	ret
 3210c90:	8abfc62e 	bgeu	r17,r10,3210bac <_strtoull_r+0xf8>
 3210c94:	01bfffc4 	movi	r6,-1
 3210c98:	003fd506 	br	3210bf0 <_strtoull_r+0x13c>
 3210c9c:	00800c04 	movi	r2,48
 3210ca0:	a0801e26 	beq	r20,r2,3210d1c <_strtoull_r+0x268>
 3210ca4:	183fa526 	beq	r3,zero,3210b3c <_strtoull_r+0x88>
 3210ca8:	00800c04 	movi	r2,48
 3210cac:	a0802a26 	beq	r20,r2,3210d58 <_strtoull_r+0x2a4>
 3210cb0:	05c00284 	movi	r23,10
 3210cb4:	b82b883a 	mov	r21,r23
 3210cb8:	046666b4 	movhi	r17,39322
 3210cbc:	8c666644 	addi	r17,r17,-26215
 3210cc0:	002d883a 	mov	r22,zero
 3210cc4:	048666b4 	movhi	r18,6554
 3210cc8:	94a66644 	addi	r18,r18,-26215
 3210ccc:	03000144 	movi	r12,5
 3210cd0:	003faa06 	br	3210b7c <_strtoull_r+0xc8>
 3210cd4:	020015c4 	movi	r8,87
 3210cd8:	a221c83a 	sub	r16,r20,r8
 3210cdc:	003fd106 	br	3210c24 <_strtoull_r+0x170>
 3210ce0:	5cbfb31e 	bne	r11,r18,3210bb0 <_strtoull_r+0xfc>
 3210ce4:	643fb20e 	bge	r12,r16,3210bb0 <_strtoull_r+0xfc>
 3210ce8:	01bfffc4 	movi	r6,-1
 3210cec:	003fc006 	br	3210bf0 <_strtoull_r+0x13c>
 3210cf0:	9cffffc4 	addi	r19,r19,-1
 3210cf4:	dcc00215 	stw	r19,8(sp)
 3210cf8:	003fd406 	br	3210c4c <_strtoull_r+0x198>
 3210cfc:	9d000007 	ldb	r20,0(r19)
 3210d00:	9cc00044 	addi	r19,r19,1
 3210d04:	003f8806 	br	3210b28 <_strtoull_r+0x74>
 3210d08:	9d000007 	ldb	r20,0(r19)
 3210d0c:	00800044 	movi	r2,1
 3210d10:	9cc00044 	addi	r19,r19,1
 3210d14:	d8800015 	stw	r2,0(sp)
 3210d18:	003f8406 	br	3210b2c <_strtoull_r+0x78>
 3210d1c:	99000007 	ldb	r4,0(r19)
 3210d20:	00801e04 	movi	r2,120
 3210d24:	20800226 	beq	r4,r2,3210d30 <_strtoull_r+0x27c>
 3210d28:	00801604 	movi	r2,88
 3210d2c:	20bfdd1e 	bne	r4,r2,3210ca4 <_strtoull_r+0x1f0>
 3210d30:	9d000047 	ldb	r20,1(r19)
 3210d34:	05c00404 	movi	r23,16
 3210d38:	b82b883a 	mov	r21,r23
 3210d3c:	047fffc4 	movi	r17,-1
 3210d40:	9cc00084 	addi	r19,r19,2
 3210d44:	002d883a 	mov	r22,zero
 3210d48:	04840034 	movhi	r18,4096
 3210d4c:	94bfffc4 	addi	r18,r18,-1
 3210d50:	030003c4 	movi	r12,15
 3210d54:	003f8906 	br	3210b7c <_strtoull_r+0xc8>
 3210d58:	05c00204 	movi	r23,8
 3210d5c:	b82b883a 	mov	r21,r23
 3210d60:	047fffc4 	movi	r17,-1
 3210d64:	002d883a 	mov	r22,zero
 3210d68:	04880034 	movhi	r18,8192
 3210d6c:	94bfffc4 	addi	r18,r18,-1
 3210d70:	030001c4 	movi	r12,7
 3210d74:	003f8106 	br	3210b7c <_strtoull_r+0xc8>
 3210d78:	d8c00017 	ldw	r3,0(sp)
 3210d7c:	1805003a 	cmpeq	r2,r3,zero
 3210d80:	103faf1e 	bne	r2,zero,3210c40 <_strtoull_r+0x18c>
 3210d84:	0009883a 	mov	r4,zero
 3210d88:	2285c83a 	sub	r2,r4,r10
 3210d8c:	02c7c83a 	sub	r3,zero,r11
 3210d90:	2089803a 	cmpltu	r4,r4,r2
 3210d94:	1909c83a 	sub	r4,r3,r4
 3210d98:	1015883a 	mov	r10,r2
 3210d9c:	2017883a 	mov	r11,r4
 3210da0:	003fa706 	br	3210c40 <_strtoull_r+0x18c>

03210da4 <__submore>:
 3210da4:	defffa04 	addi	sp,sp,-24
 3210da8:	28c00c17 	ldw	r3,48(r5)
 3210dac:	dc800215 	stw	r18,8(sp)
 3210db0:	2825883a 	mov	r18,r5
 3210db4:	dc000015 	stw	r16,0(sp)
 3210db8:	90801004 	addi	r2,r18,64
 3210dbc:	04010004 	movi	r16,1024
 3210dc0:	dfc00515 	stw	ra,20(sp)
 3210dc4:	dd000415 	stw	r20,16(sp)
 3210dc8:	dcc00315 	stw	r19,12(sp)
 3210dcc:	dc400115 	stw	r17,4(sp)
 3210dd0:	800b883a 	mov	r5,r16
 3210dd4:	18801b26 	beq	r3,r2,3210e44 <__submore+0xa0>
 3210dd8:	94400d17 	ldw	r17,52(r18)
 3210ddc:	180b883a 	mov	r5,r3
 3210de0:	8c69883a 	add	r20,r17,r17
 3210de4:	a00d883a 	mov	r6,r20
 3210de8:	3206e180 	call	3206e18 <_realloc_r>
 3210dec:	1467883a 	add	r19,r2,r17
 3210df0:	1021883a 	mov	r16,r2
 3210df4:	880d883a 	mov	r6,r17
 3210df8:	9809883a 	mov	r4,r19
 3210dfc:	100b883a 	mov	r5,r2
 3210e00:	10000e26 	beq	r2,zero,3210e3c <__submore+0x98>
 3210e04:	32067cc0 	call	32067cc <memcpy>
 3210e08:	000d883a 	mov	r6,zero
 3210e0c:	95000d15 	stw	r20,52(r18)
 3210e10:	94c00015 	stw	r19,0(r18)
 3210e14:	94000c15 	stw	r16,48(r18)
 3210e18:	3005883a 	mov	r2,r6
 3210e1c:	dfc00517 	ldw	ra,20(sp)
 3210e20:	dd000417 	ldw	r20,16(sp)
 3210e24:	dcc00317 	ldw	r19,12(sp)
 3210e28:	dc800217 	ldw	r18,8(sp)
 3210e2c:	dc400117 	ldw	r17,4(sp)
 3210e30:	dc000017 	ldw	r16,0(sp)
 3210e34:	dec00604 	addi	sp,sp,24
 3210e38:	f800283a 	ret
 3210e3c:	01bfffc4 	movi	r6,-1
 3210e40:	003ff506 	br	3210e18 <__submore+0x74>
 3210e44:	3205fa80 	call	3205fa8 <_malloc_r>
 3210e48:	1009883a 	mov	r4,r2
 3210e4c:	1140ff44 	addi	r5,r2,1021
 3210e50:	000d883a 	mov	r6,zero
 3210e54:	103ff926 	beq	r2,zero,3210e3c <__submore+0x98>
 3210e58:	90801083 	ldbu	r2,66(r18)
 3210e5c:	94000d15 	stw	r16,52(r18)
 3210e60:	91000c15 	stw	r4,48(r18)
 3210e64:	28800085 	stb	r2,2(r5)
 3210e68:	90c01043 	ldbu	r3,65(r18)
 3210e6c:	28c00045 	stb	r3,1(r5)
 3210e70:	90801003 	ldbu	r2,64(r18)
 3210e74:	2080ff45 	stb	r2,1021(r4)
 3210e78:	91400015 	stw	r5,0(r18)
 3210e7c:	003fe606 	br	3210e18 <__submore+0x74>

03210e80 <_ungetc_r>:
 3210e80:	defffc04 	addi	sp,sp,-16
 3210e84:	00bfffc4 	movi	r2,-1
 3210e88:	dc400215 	stw	r17,8(sp)
 3210e8c:	dc000115 	stw	r16,4(sp)
 3210e90:	dfc00315 	stw	ra,12(sp)
 3210e94:	2821883a 	mov	r16,r5
 3210e98:	2023883a 	mov	r17,r4
 3210e9c:	28801826 	beq	r5,r2,3210f00 <_ungetc_r+0x80>
 3210ea0:	20000226 	beq	r4,zero,3210eac <_ungetc_r+0x2c>
 3210ea4:	20800e17 	ldw	r2,56(r4)
 3210ea8:	10001b26 	beq	r2,zero,3210f18 <_ungetc_r+0x98>
 3210eac:	3100030b 	ldhu	r4,12(r6)
 3210eb0:	00bff7c4 	movi	r2,-33
 3210eb4:	2084703a 	and	r2,r4,r2
 3210eb8:	117fffcc 	andi	r5,r2,65535
 3210ebc:	28c0010c 	andi	r3,r5,4
 3210ec0:	1009883a 	mov	r4,r2
 3210ec4:	3080030d 	sth	r2,12(r6)
 3210ec8:	18003526 	beq	r3,zero,3210fa0 <_ungetc_r+0x120>
 3210ecc:	30800c17 	ldw	r2,48(r6)
 3210ed0:	84003fcc 	andi	r16,r16,255
 3210ed4:	10001426 	beq	r2,zero,3210f28 <_ungetc_r+0xa8>
 3210ed8:	30c00117 	ldw	r3,4(r6)
 3210edc:	30800d17 	ldw	r2,52(r6)
 3210ee0:	1880380e 	bge	r3,r2,3210fc4 <_ungetc_r+0x144>
 3210ee4:	30c00017 	ldw	r3,0(r6)
 3210ee8:	19ffffc4 	addi	r7,r3,-1
 3210eec:	31c00015 	stw	r7,0(r6)
 3210ef0:	1c3fffc5 	stb	r16,-1(r3)
 3210ef4:	30800117 	ldw	r2,4(r6)
 3210ef8:	10800044 	addi	r2,r2,1
 3210efc:	30800115 	stw	r2,4(r6)
 3210f00:	8005883a 	mov	r2,r16
 3210f04:	dfc00317 	ldw	ra,12(sp)
 3210f08:	dc400217 	ldw	r17,8(sp)
 3210f0c:	dc000117 	ldw	r16,4(sp)
 3210f10:	dec00404 	addi	sp,sp,16
 3210f14:	f800283a 	ret
 3210f18:	d9800015 	stw	r6,0(sp)
 3210f1c:	32048880 	call	3204888 <__sinit>
 3210f20:	d9800017 	ldw	r6,0(sp)
 3210f24:	003fe106 	br	3210eac <_ungetc_r+0x2c>
 3210f28:	30800417 	ldw	r2,16(r6)
 3210f2c:	10002326 	beq	r2,zero,3210fbc <_ungetc_r+0x13c>
 3210f30:	31c00017 	ldw	r7,0(r6)
 3210f34:	11c0022e 	bgeu	r2,r7,3210f40 <_ungetc_r+0xc0>
 3210f38:	38bfffc3 	ldbu	r2,-1(r7)
 3210f3c:	80801226 	beq	r16,r2,3210f88 <_ungetc_r+0x108>
 3210f40:	30c00117 	ldw	r3,4(r6)
 3210f44:	00800044 	movi	r2,1
 3210f48:	30800115 	stw	r2,4(r6)
 3210f4c:	008000c4 	movi	r2,3
 3210f50:	31001004 	addi	r4,r6,64
 3210f54:	31401084 	addi	r5,r6,66
 3210f58:	30800d15 	stw	r2,52(r6)
 3210f5c:	8005883a 	mov	r2,r16
 3210f60:	30c00f15 	stw	r3,60(r6)
 3210f64:	31c00e15 	stw	r7,56(r6)
 3210f68:	31000c15 	stw	r4,48(r6)
 3210f6c:	31400015 	stw	r5,0(r6)
 3210f70:	34001085 	stb	r16,66(r6)
 3210f74:	dfc00317 	ldw	ra,12(sp)
 3210f78:	dc400217 	ldw	r17,8(sp)
 3210f7c:	dc000117 	ldw	r16,4(sp)
 3210f80:	dec00404 	addi	sp,sp,16
 3210f84:	f800283a 	ret
 3210f88:	30800117 	ldw	r2,4(r6)
 3210f8c:	39ffffc4 	addi	r7,r7,-1
 3210f90:	31c00015 	stw	r7,0(r6)
 3210f94:	10800044 	addi	r2,r2,1
 3210f98:	30800115 	stw	r2,4(r6)
 3210f9c:	003fd806 	br	3210f00 <_ungetc_r+0x80>
 3210fa0:	2880040c 	andi	r2,r5,16
 3210fa4:	10000d26 	beq	r2,zero,3210fdc <_ungetc_r+0x15c>
 3210fa8:	2880020c 	andi	r2,r5,8
 3210fac:	10000d1e 	bne	r2,zero,3210fe4 <_ungetc_r+0x164>
 3210fb0:	20800114 	ori	r2,r4,4
 3210fb4:	3080030d 	sth	r2,12(r6)
 3210fb8:	003fc406 	br	3210ecc <_ungetc_r+0x4c>
 3210fbc:	31c00017 	ldw	r7,0(r6)
 3210fc0:	003fdf06 	br	3210f40 <_ungetc_r+0xc0>
 3210fc4:	300b883a 	mov	r5,r6
 3210fc8:	8809883a 	mov	r4,r17
 3210fcc:	d9800015 	stw	r6,0(sp)
 3210fd0:	3210da40 	call	3210da4 <__submore>
 3210fd4:	d9800017 	ldw	r6,0(sp)
 3210fd8:	103fc226 	beq	r2,zero,3210ee4 <_ungetc_r+0x64>
 3210fdc:	043fffc4 	movi	r16,-1
 3210fe0:	003fc706 	br	3210f00 <_ungetc_r+0x80>
 3210fe4:	300b883a 	mov	r5,r6
 3210fe8:	8809883a 	mov	r4,r17
 3210fec:	d9800015 	stw	r6,0(sp)
 3210ff0:	32045f00 	call	32045f0 <_fflush_r>
 3210ff4:	d9800017 	ldw	r6,0(sp)
 3210ff8:	103ff81e 	bne	r2,zero,3210fdc <_ungetc_r+0x15c>
 3210ffc:	3100030b 	ldhu	r4,12(r6)
 3211000:	00bffdc4 	movi	r2,-9
 3211004:	30000215 	stw	zero,8(r6)
 3211008:	2084703a 	and	r2,r4,r2
 321100c:	1009883a 	mov	r4,r2
 3211010:	3080030d 	sth	r2,12(r6)
 3211014:	30000615 	stw	zero,24(r6)
 3211018:	003fe506 	br	3210fb0 <_ungetc_r+0x130>

0321101c <ungetc>:
 321101c:	0180c974 	movhi	r6,805
 3211020:	31897804 	addi	r6,r6,9696
 3211024:	2007883a 	mov	r3,r4
 3211028:	31000017 	ldw	r4,0(r6)
 321102c:	280d883a 	mov	r6,r5
 3211030:	180b883a 	mov	r5,r3
 3211034:	3210e801 	jmpi	3210e80 <_ungetc_r>

03211038 <_calloc_r>:
 3211038:	298b383a 	mul	r5,r5,r6
 321103c:	defffe04 	addi	sp,sp,-8
 3211040:	dc000015 	stw	r16,0(sp)
 3211044:	dfc00115 	stw	ra,4(sp)
 3211048:	3205fa80 	call	3205fa8 <_malloc_r>
 321104c:	1021883a 	mov	r16,r2
 3211050:	01c00904 	movi	r7,36
 3211054:	10000d26 	beq	r2,zero,321108c <_calloc_r+0x54>
 3211058:	10ffff17 	ldw	r3,-4(r2)
 321105c:	1009883a 	mov	r4,r2
 3211060:	00bfff04 	movi	r2,-4
 3211064:	1886703a 	and	r3,r3,r2
 3211068:	1887883a 	add	r3,r3,r2
 321106c:	180d883a 	mov	r6,r3
 3211070:	000b883a 	mov	r5,zero
 3211074:	38c01736 	bltu	r7,r3,32110d4 <_calloc_r+0x9c>
 3211078:	008004c4 	movi	r2,19
 321107c:	10c00836 	bltu	r2,r3,32110a0 <_calloc_r+0x68>
 3211080:	20000215 	stw	zero,8(r4)
 3211084:	20000015 	stw	zero,0(r4)
 3211088:	20000115 	stw	zero,4(r4)
 321108c:	8005883a 	mov	r2,r16
 3211090:	dfc00117 	ldw	ra,4(sp)
 3211094:	dc000017 	ldw	r16,0(sp)
 3211098:	dec00204 	addi	sp,sp,8
 321109c:	f800283a 	ret
 32110a0:	008006c4 	movi	r2,27
 32110a4:	80000015 	stw	zero,0(r16)
 32110a8:	80000115 	stw	zero,4(r16)
 32110ac:	81000204 	addi	r4,r16,8
 32110b0:	10fff32e 	bgeu	r2,r3,3211080 <_calloc_r+0x48>
 32110b4:	80000215 	stw	zero,8(r16)
 32110b8:	80000315 	stw	zero,12(r16)
 32110bc:	81000404 	addi	r4,r16,16
 32110c0:	19ffef1e 	bne	r3,r7,3211080 <_calloc_r+0x48>
 32110c4:	81000604 	addi	r4,r16,24
 32110c8:	80000415 	stw	zero,16(r16)
 32110cc:	80000515 	stw	zero,20(r16)
 32110d0:	003feb06 	br	3211080 <_calloc_r+0x48>
 32110d4:	320694c0 	call	320694c <memset>
 32110d8:	8005883a 	mov	r2,r16
 32110dc:	dfc00117 	ldw	ra,4(sp)
 32110e0:	dc000017 	ldw	r16,0(sp)
 32110e4:	dec00204 	addi	sp,sp,8
 32110e8:	f800283a 	ret

032110ec <htinit>:
 32110ec:	28800003 	ldbu	r2,0(r5)
 32110f0:	10000626 	beq	r2,zero,321110c <htinit+0x20>
 32110f4:	1105883a 	add	r2,r2,r4
 32110f8:	11800005 	stb	r6,0(r2)
 32110fc:	28800043 	ldbu	r2,1(r5)
 3211100:	31800044 	addi	r6,r6,1
 3211104:	29400044 	addi	r5,r5,1
 3211108:	103ffa1e 	bne	r2,zero,32110f4 <htinit+0x8>
 321110c:	f800283a 	ret

03211110 <__hexdig_init>:
 3211110:	defffd04 	addi	sp,sp,-12
 3211114:	dc400015 	stw	r17,0(sp)
 3211118:	0440c9b4 	movhi	r17,806
 321111c:	8c64cc04 	addi	r17,r17,-27856
 3211120:	dcc00115 	stw	r19,4(sp)
 3211124:	8809883a 	mov	r4,r17
 3211128:	04c00684 	movi	r19,26
 321112c:	0140c974 	movhi	r5,805
 3211130:	29783f04 	addi	r5,r5,-7940
 3211134:	01800404 	movi	r6,16
 3211138:	dfc00215 	stw	ra,8(sp)
 321113c:	32110ec0 	call	32110ec <htinit>
 3211140:	980d883a 	mov	r6,r19
 3211144:	8809883a 	mov	r4,r17
 3211148:	0140c974 	movhi	r5,805
 321114c:	29784204 	addi	r5,r5,-7928
 3211150:	32110ec0 	call	32110ec <htinit>
 3211154:	8809883a 	mov	r4,r17
 3211158:	980d883a 	mov	r6,r19
 321115c:	0140c974 	movhi	r5,805
 3211160:	29784404 	addi	r5,r5,-7920
 3211164:	dfc00217 	ldw	ra,8(sp)
 3211168:	dcc00117 	ldw	r19,4(sp)
 321116c:	dc400017 	ldw	r17,0(sp)
 3211170:	dec00304 	addi	sp,sp,12
 3211174:	32110ec1 	jmpi	32110ec <htinit>

03211178 <rshift>:
 3211178:	2807d17a 	srai	r3,r5,5
 321117c:	20800417 	ldw	r2,16(r4)
 3211180:	22400504 	addi	r9,r4,20
 3211184:	480f883a 	mov	r7,r9
 3211188:	1880190e 	bge	r3,r2,32111f0 <rshift+0x78>
 321118c:	1085883a 	add	r2,r2,r2
 3211190:	18c7883a 	add	r3,r3,r3
 3211194:	1085883a 	add	r2,r2,r2
 3211198:	18c7883a 	add	r3,r3,r3
 321119c:	294007cc 	andi	r5,r5,31
 32111a0:	4891883a 	add	r8,r9,r2
 32111a4:	48cd883a 	add	r6,r9,r3
 32111a8:	28001726 	beq	r5,zero,3211208 <rshift+0x90>
 32111ac:	30c00017 	ldw	r3,0(r6)
 32111b0:	00800804 	movi	r2,32
 32111b4:	31800104 	addi	r6,r6,4
 32111b8:	1155c83a 	sub	r10,r2,r5
 32111bc:	1946d83a 	srl	r3,r3,r5
 32111c0:	3200092e 	bgeu	r6,r8,32111e8 <rshift+0x70>
 32111c4:	30800017 	ldw	r2,0(r6)
 32111c8:	1284983a 	sll	r2,r2,r10
 32111cc:	10c4b03a 	or	r2,r2,r3
 32111d0:	38800015 	stw	r2,0(r7)
 32111d4:	30c00017 	ldw	r3,0(r6)
 32111d8:	31800104 	addi	r6,r6,4
 32111dc:	39c00104 	addi	r7,r7,4
 32111e0:	1946d83a 	srl	r3,r3,r5
 32111e4:	323ff736 	bltu	r6,r8,32111c4 <rshift+0x4c>
 32111e8:	38c00015 	stw	r3,0(r7)
 32111ec:	18000c1e 	bne	r3,zero,3211220 <rshift+0xa8>
 32111f0:	3a45c83a 	sub	r2,r7,r9
 32111f4:	1005d0ba 	srai	r2,r2,2
 32111f8:	20800415 	stw	r2,16(r4)
 32111fc:	1000011e 	bne	r2,zero,3211204 <rshift+0x8c>
 3211200:	20000515 	stw	zero,20(r4)
 3211204:	f800283a 	ret
 3211208:	323ff92e 	bgeu	r6,r8,32111f0 <rshift+0x78>
 321120c:	30800017 	ldw	r2,0(r6)
 3211210:	31800104 	addi	r6,r6,4
 3211214:	38800015 	stw	r2,0(r7)
 3211218:	39c00104 	addi	r7,r7,4
 321121c:	003ffa06 	br	3211208 <rshift+0x90>
 3211220:	39c00104 	addi	r7,r7,4
 3211224:	003ff206 	br	32111f0 <rshift+0x78>

03211228 <__gethex>:
 3211228:	defff304 	addi	sp,sp,-52
 321122c:	dd400815 	stw	r21,32(sp)
 3211230:	dd000715 	stw	r20,28(sp)
 3211234:	dcc00615 	stw	r19,24(sp)
 3211238:	dc400415 	stw	r17,16(sp)
 321123c:	dfc00c15 	stw	ra,48(sp)
 3211240:	df000b15 	stw	fp,44(sp)
 3211244:	ddc00a15 	stw	r23,40(sp)
 3211248:	dd800915 	stw	r22,36(sp)
 321124c:	dc800515 	stw	r18,20(sp)
 3211250:	dc000315 	stw	r16,12(sp)
 3211254:	0440c9b4 	movhi	r17,806
 3211258:	8c64cc04 	addi	r17,r17,-27856
 321125c:	88800c03 	ldbu	r2,48(r17)
 3211260:	202b883a 	mov	r21,r4
 3211264:	2827883a 	mov	r19,r5
 3211268:	3029883a 	mov	r20,r6
 321126c:	d9c00115 	stw	r7,4(sp)
 3211270:	10006e26 	beq	r2,zero,321142c <__gethex+0x204>
 3211274:	99800017 	ldw	r6,0(r19)
 3211278:	00800c04 	movi	r2,48
 321127c:	31000083 	ldbu	r4,2(r6)
 3211280:	30c00084 	addi	r3,r6,2
 3211284:	20806f1e 	bne	r4,r2,3211444 <__gethex+0x21c>
 3211288:	200b883a 	mov	r5,r4
 321128c:	3007883a 	mov	r3,r6
 3211290:	188000c3 	ldbu	r2,3(r3)
 3211294:	18c00044 	addi	r3,r3,1
 3211298:	1009883a 	mov	r4,r2
 321129c:	117ffc26 	beq	r2,r5,3211290 <__gethex+0x68>
 32112a0:	1997c83a 	sub	r11,r3,r6
 32112a4:	19400084 	addi	r5,r3,2
 32112a8:	2445883a 	add	r2,r4,r17
 32112ac:	10c00003 	ldbu	r3,0(r2)
 32112b0:	18002d26 	beq	r3,zero,3211368 <__gethex+0x140>
 32112b4:	29000003 	ldbu	r4,0(r5)
 32112b8:	2825883a 	mov	r18,r5
 32112bc:	000d883a 	mov	r6,zero
 32112c0:	0013883a 	mov	r9,zero
 32112c4:	21003fcc 	andi	r4,r4,255
 32112c8:	2445883a 	add	r2,r4,r17
 32112cc:	10c00003 	ldbu	r3,0(r2)
 32112d0:	18000526 	beq	r3,zero,32112e8 <__gethex+0xc0>
 32112d4:	29400044 	addi	r5,r5,1
 32112d8:	29000003 	ldbu	r4,0(r5)
 32112dc:	2445883a 	add	r2,r4,r17
 32112e0:	10c00003 	ldbu	r3,0(r2)
 32112e4:	183ffb1e 	bne	r3,zero,32112d4 <__gethex+0xac>
 32112e8:	00800b84 	movi	r2,46
 32112ec:	20805826 	beq	r4,r2,3211450 <__gethex+0x228>
 32112f0:	30007a26 	beq	r6,zero,32114dc <__gethex+0x2b4>
 32112f4:	2985c83a 	sub	r2,r5,r6
 32112f8:	1085883a 	add	r2,r2,r2
 32112fc:	1085883a 	add	r2,r2,r2
 3211300:	00adc83a 	sub	r22,zero,r2
 3211304:	2821883a 	mov	r16,r5
 3211308:	80c00003 	ldbu	r3,0(r16)
 321130c:	00801404 	movi	r2,80
 3211310:	18801e26 	beq	r3,r2,321138c <__gethex+0x164>
 3211314:	00801c04 	movi	r2,112
 3211318:	18801c26 	beq	r3,r2,321138c <__gethex+0x164>
 321131c:	800d883a 	mov	r6,r16
 3211320:	4805003a 	cmpeq	r2,r9,zero
 3211324:	99800015 	stw	r6,0(r19)
 3211328:	1000861e 	bne	r2,zero,3211544 <__gethex+0x31c>
 321132c:	58003d26 	beq	r11,zero,3211424 <__gethex+0x1fc>
 3211330:	0025883a 	mov	r18,zero
 3211334:	9005883a 	mov	r2,r18
 3211338:	dfc00c17 	ldw	ra,48(sp)
 321133c:	df000b17 	ldw	fp,44(sp)
 3211340:	ddc00a17 	ldw	r23,40(sp)
 3211344:	dd800917 	ldw	r22,36(sp)
 3211348:	dd400817 	ldw	r21,32(sp)
 321134c:	dd000717 	ldw	r20,28(sp)
 3211350:	dcc00617 	ldw	r19,24(sp)
 3211354:	dc800517 	ldw	r18,20(sp)
 3211358:	dc400417 	ldw	r17,16(sp)
 321135c:	dc000317 	ldw	r16,12(sp)
 3211360:	dec00d04 	addi	sp,sp,52
 3211364:	f800283a 	ret
 3211368:	00800b84 	movi	r2,46
 321136c:	20804a26 	beq	r4,r2,3211498 <__gethex+0x270>
 3211370:	2821883a 	mov	r16,r5
 3211374:	80c00003 	ldbu	r3,0(r16)
 3211378:	00801404 	movi	r2,80
 321137c:	2825883a 	mov	r18,r5
 3211380:	02400044 	movi	r9,1
 3211384:	002d883a 	mov	r22,zero
 3211388:	18bfe21e 	bne	r3,r2,3211314 <__gethex+0xec>
 321138c:	80c00043 	ldbu	r3,1(r16)
 3211390:	00800ac4 	movi	r2,43
 3211394:	81000044 	addi	r4,r16,1
 3211398:	18804a26 	beq	r3,r2,32114c4 <__gethex+0x29c>
 321139c:	00800b44 	movi	r2,45
 32113a0:	18804c26 	beq	r3,r2,32114d4 <__gethex+0x2ac>
 32113a4:	0015883a 	mov	r10,zero
 32113a8:	1c45883a 	add	r2,r3,r17
 32113ac:	10800003 	ldbu	r2,0(r2)
 32113b0:	103fda26 	beq	r2,zero,321131c <__gethex+0xf4>
 32113b4:	02000644 	movi	r8,25
 32113b8:	40bfd816 	blt	r8,r2,321131c <__gethex+0xf4>
 32113bc:	20c00043 	ldbu	r3,1(r4)
 32113c0:	11fffc04 	addi	r7,r2,-16
 32113c4:	0080c9b4 	movhi	r2,806
 32113c8:	10a4cc04 	addi	r2,r2,-27856
 32113cc:	1887883a 	add	r3,r3,r2
 32113d0:	18800003 	ldbu	r2,0(r3)
 32113d4:	21800044 	addi	r6,r4,1
 32113d8:	10000d26 	beq	r2,zero,3211410 <__gethex+0x1e8>
 32113dc:	100b883a 	mov	r5,r2
 32113e0:	4080020e 	bge	r8,r2,32113ec <__gethex+0x1c4>
 32113e4:	00000a06 	br	3211410 <__gethex+0x1e8>
 32113e8:	41000916 	blt	r8,r4,3211410 <__gethex+0x1e8>
 32113ec:	31800044 	addi	r6,r6,1
 32113f0:	30800003 	ldbu	r2,0(r6)
 32113f4:	38c002a4 	muli	r3,r7,10
 32113f8:	1445883a 	add	r2,r2,r17
 32113fc:	11000003 	ldbu	r4,0(r2)
 3211400:	1947883a 	add	r3,r3,r5
 3211404:	19fffc04 	addi	r7,r3,-16
 3211408:	200b883a 	mov	r5,r4
 321140c:	203ff61e 	bne	r4,zero,32113e8 <__gethex+0x1c0>
 3211410:	5005003a 	cmpeq	r2,r10,zero
 3211414:	1000011e 	bne	r2,zero,321141c <__gethex+0x1f4>
 3211418:	01cfc83a 	sub	r7,zero,r7
 321141c:	b1ed883a 	add	r22,r22,r7
 3211420:	003fbf06 	br	3211320 <__gethex+0xf8>
 3211424:	04800184 	movi	r18,6
 3211428:	003fc206 	br	3211334 <__gethex+0x10c>
 321142c:	32111100 	call	3211110 <__hexdig_init>
 3211430:	99800017 	ldw	r6,0(r19)
 3211434:	00800c04 	movi	r2,48
 3211438:	31000083 	ldbu	r4,2(r6)
 321143c:	30c00084 	addi	r3,r6,2
 3211440:	20bf9126 	beq	r4,r2,3211288 <__gethex+0x60>
 3211444:	180b883a 	mov	r5,r3
 3211448:	0017883a 	mov	r11,zero
 321144c:	003f9606 	br	32112a8 <__gethex+0x80>
 3211450:	303fa81e 	bne	r6,zero,32112f4 <__gethex+0xcc>
 3211454:	29400044 	addi	r5,r5,1
 3211458:	28800003 	ldbu	r2,0(r5)
 321145c:	1445883a 	add	r2,r2,r17
 3211460:	10c00003 	ldbu	r3,0(r2)
 3211464:	1800ad26 	beq	r3,zero,321171c <__gethex+0x4f4>
 3211468:	2809883a 	mov	r4,r5
 321146c:	21000044 	addi	r4,r4,1
 3211470:	20800003 	ldbu	r2,0(r4)
 3211474:	1445883a 	add	r2,r2,r17
 3211478:	10c00003 	ldbu	r3,0(r2)
 321147c:	183ffb1e 	bne	r3,zero,321146c <__gethex+0x244>
 3211480:	2145c83a 	sub	r2,r4,r5
 3211484:	1085883a 	add	r2,r2,r2
 3211488:	1085883a 	add	r2,r2,r2
 321148c:	00adc83a 	sub	r22,zero,r2
 3211490:	200b883a 	mov	r5,r4
 3211494:	003f9b06 	br	3211304 <__gethex+0xdc>
 3211498:	29000043 	ldbu	r4,1(r5)
 321149c:	0080c9b4 	movhi	r2,806
 32114a0:	10a4cc04 	addi	r2,r2,-27856
 32114a4:	2c000044 	addi	r16,r5,1
 32114a8:	2085883a 	add	r2,r4,r2
 32114ac:	10c00003 	ldbu	r3,0(r2)
 32114b0:	18000d1e 	bne	r3,zero,32114e8 <__gethex+0x2c0>
 32114b4:	2825883a 	mov	r18,r5
 32114b8:	02400044 	movi	r9,1
 32114bc:	002d883a 	mov	r22,zero
 32114c0:	003f9106 	br	3211308 <__gethex+0xe0>
 32114c4:	0015883a 	mov	r10,zero
 32114c8:	21000044 	addi	r4,r4,1
 32114cc:	20c00003 	ldbu	r3,0(r4)
 32114d0:	003fb506 	br	32113a8 <__gethex+0x180>
 32114d4:	02800044 	movi	r10,1
 32114d8:	003ffb06 	br	32114c8 <__gethex+0x2a0>
 32114dc:	2821883a 	mov	r16,r5
 32114e0:	002d883a 	mov	r22,zero
 32114e4:	003f8806 	br	3211308 <__gethex+0xe0>
 32114e8:	00800c04 	movi	r2,48
 32114ec:	20800e1e 	bne	r4,r2,3211528 <__gethex+0x300>
 32114f0:	2007883a 	mov	r3,r4
 32114f4:	800b883a 	mov	r5,r16
 32114f8:	29400044 	addi	r5,r5,1
 32114fc:	29000003 	ldbu	r4,0(r5)
 3211500:	20803fcc 	andi	r2,r4,255
 3211504:	10fffc26 	beq	r2,r3,32114f8 <__gethex+0x2d0>
 3211508:	1445883a 	add	r2,r2,r17
 321150c:	10c00003 	ldbu	r3,0(r2)
 3211510:	1800071e 	bne	r3,zero,3211530 <__gethex+0x308>
 3211514:	02c00044 	movi	r11,1
 3211518:	800d883a 	mov	r6,r16
 321151c:	2825883a 	mov	r18,r5
 3211520:	5813883a 	mov	r9,r11
 3211524:	003f6706 	br	32112c4 <__gethex+0x9c>
 3211528:	81000003 	ldbu	r4,0(r16)
 321152c:	800b883a 	mov	r5,r16
 3211530:	800d883a 	mov	r6,r16
 3211534:	2825883a 	mov	r18,r5
 3211538:	02c00044 	movi	r11,1
 321153c:	0013883a 	mov	r9,zero
 3211540:	003f6006 	br	32112c4 <__gethex+0x9c>
 3211544:	8485c83a 	sub	r2,r16,r18
 3211548:	10bfffc4 	addi	r2,r2,-1
 321154c:	00c001c4 	movi	r3,7
 3211550:	1880700e 	bge	r3,r2,3211714 <__gethex+0x4ec>
 3211554:	000b883a 	mov	r5,zero
 3211558:	1005d07a 	srai	r2,r2,1
 321155c:	29400044 	addi	r5,r5,1
 3211560:	18bffd16 	blt	r3,r2,3211558 <__gethex+0x330>
 3211564:	a809883a 	mov	r4,r21
 3211568:	320df940 	call	320df94 <_Balloc>
 321156c:	1027883a 	mov	r19,r2
 3211570:	10800504 	addi	r2,r2,20
 3211574:	d8800215 	stw	r2,8(sp)
 3211578:	9400522e 	bgeu	r18,r16,32116c4 <__gethex+0x49c>
 321157c:	da000217 	ldw	r8,8(sp)
 3211580:	800b883a 	mov	r5,r16
 3211584:	000f883a 	mov	r7,zero
 3211588:	0009883a 	mov	r4,zero
 321158c:	02400b84 	movi	r9,46
 3211590:	02800804 	movi	r10,32
 3211594:	297fffc4 	addi	r5,r5,-1
 3211598:	28c00003 	ldbu	r3,0(r5)
 321159c:	1a400826 	beq	r3,r9,32115c0 <__gethex+0x398>
 32115a0:	380d883a 	mov	r6,r7
 32115a4:	3a802726 	beq	r7,r10,3211644 <__gethex+0x41c>
 32115a8:	39c00104 	addi	r7,r7,4
 32115ac:	1c47883a 	add	r3,r3,r17
 32115b0:	18800003 	ldbu	r2,0(r3)
 32115b4:	108003cc 	andi	r2,r2,15
 32115b8:	1184983a 	sll	r2,r2,r6
 32115bc:	2088b03a 	or	r4,r4,r2
 32115c0:	917ff436 	bltu	r18,r5,3211594 <__gethex+0x36c>
 32115c4:	d8c00217 	ldw	r3,8(sp)
 32115c8:	40800104 	addi	r2,r8,4
 32115cc:	41000015 	stw	r4,0(r8)
 32115d0:	10c5c83a 	sub	r2,r2,r3
 32115d4:	1021d0ba 	srai	r16,r2,2
 32115d8:	9c000415 	stw	r16,16(r19)
 32115dc:	320da3c0 	call	320da3c <__hi0bits>
 32115e0:	8006917a 	slli	r3,r16,5
 32115e4:	a5c00017 	ldw	r23,0(r20)
 32115e8:	1885c83a 	sub	r2,r3,r2
 32115ec:	b8801c16 	blt	r23,r2,3211660 <__gethex+0x438>
 32115f0:	15c00a16 	blt	r2,r23,321161c <__gethex+0x3f4>
 32115f4:	0039883a 	mov	fp,zero
 32115f8:	a0800217 	ldw	r2,8(r20)
 32115fc:	1580340e 	bge	r2,r22,32116d0 <__gethex+0x4a8>
 3211600:	a809883a 	mov	r4,r21
 3211604:	980b883a 	mov	r5,r19
 3211608:	320da140 	call	320da14 <_Bfree>
 321160c:	d8c00d17 	ldw	r3,52(sp)
 3211610:	048028c4 	movi	r18,163
 3211614:	18000015 	stw	zero,0(r3)
 3211618:	003f4606 	br	3211334 <__gethex+0x10c>
 321161c:	b8a1c83a 	sub	r16,r23,r2
 3211620:	980b883a 	mov	r5,r19
 3211624:	a809883a 	mov	r4,r21
 3211628:	800d883a 	mov	r6,r16
 321162c:	320e3580 	call	320e358 <__lshift>
 3211630:	1027883a 	mov	r19,r2
 3211634:	b42dc83a 	sub	r22,r22,r16
 3211638:	10800504 	addi	r2,r2,20
 321163c:	d8800215 	stw	r2,8(sp)
 3211640:	003fec06 	br	32115f4 <__gethex+0x3cc>
 3211644:	41000015 	stw	r4,0(r8)
 3211648:	28c00003 	ldbu	r3,0(r5)
 321164c:	01c00104 	movi	r7,4
 3211650:	000d883a 	mov	r6,zero
 3211654:	41d1883a 	add	r8,r8,r7
 3211658:	0009883a 	mov	r4,zero
 321165c:	003fd306 	br	32115ac <__gethex+0x384>
 3211660:	15e1c83a 	sub	r16,r2,r23
 3211664:	9809883a 	mov	r4,r19
 3211668:	800b883a 	mov	r5,r16
 321166c:	320df0c0 	call	320df0c <__any_on>
 3211670:	1000061e 	bne	r2,zero,321168c <__gethex+0x464>
 3211674:	0039883a 	mov	fp,zero
 3211678:	9809883a 	mov	r4,r19
 321167c:	800b883a 	mov	r5,r16
 3211680:	32111780 	call	3211178 <rshift>
 3211684:	b42d883a 	add	r22,r22,r16
 3211688:	003fdb06 	br	32115f8 <__gethex+0x3d0>
 321168c:	817fffc4 	addi	r5,r16,-1
 3211690:	2805d17a 	srai	r2,r5,5
 3211694:	d8c00217 	ldw	r3,8(sp)
 3211698:	290007cc 	andi	r4,r5,31
 321169c:	1085883a 	add	r2,r2,r2
 32116a0:	1085883a 	add	r2,r2,r2
 32116a4:	01800044 	movi	r6,1
 32116a8:	10c5883a 	add	r2,r2,r3
 32116ac:	3108983a 	sll	r4,r6,r4
 32116b0:	10c00017 	ldw	r3,0(r2)
 32116b4:	20c8703a 	and	r4,r4,r3
 32116b8:	20001a1e 	bne	r4,zero,3211724 <__gethex+0x4fc>
 32116bc:	3039883a 	mov	fp,r6
 32116c0:	003fed06 	br	3211678 <__gethex+0x450>
 32116c4:	1011883a 	mov	r8,r2
 32116c8:	0009883a 	mov	r4,zero
 32116cc:	003fbd06 	br	32115c4 <__gethex+0x39c>
 32116d0:	a1000117 	ldw	r4,4(r20)
 32116d4:	b1001a16 	blt	r22,r4,3211740 <__gethex+0x518>
 32116d8:	04800044 	movi	r18,1
 32116dc:	e0000826 	beq	fp,zero,3211700 <__gethex+0x4d8>
 32116e0:	a1000317 	ldw	r4,12(r20)
 32116e4:	00800084 	movi	r2,2
 32116e8:	20809426 	beq	r4,r2,321193c <__gethex+0x714>
 32116ec:	008000c4 	movi	r2,3
 32116f0:	20805826 	beq	r4,r2,3211854 <__gethex+0x62c>
 32116f4:	00800044 	movi	r2,1
 32116f8:	20803f26 	beq	r4,r2,32117f8 <__gethex+0x5d0>
 32116fc:	94800414 	ori	r18,r18,16
 3211700:	d8800d17 	ldw	r2,52(sp)
 3211704:	d8c00117 	ldw	r3,4(sp)
 3211708:	14c00015 	stw	r19,0(r2)
 321170c:	1d800015 	stw	r22,0(r3)
 3211710:	003f0806 	br	3211334 <__gethex+0x10c>
 3211714:	000b883a 	mov	r5,zero
 3211718:	003f9206 	br	3211564 <__gethex+0x33c>
 321171c:	002d883a 	mov	r22,zero
 3211720:	003ef806 	br	3211304 <__gethex+0xdc>
 3211724:	3140160e 	bge	r6,r5,3211780 <__gethex+0x558>
 3211728:	9809883a 	mov	r4,r19
 321172c:	817fff84 	addi	r5,r16,-2
 3211730:	320df0c0 	call	320df0c <__any_on>
 3211734:	10001226 	beq	r2,zero,3211780 <__gethex+0x558>
 3211738:	070000c4 	movi	fp,3
 321173c:	003fce06 	br	3211678 <__gethex+0x450>
 3211740:	25a3c83a 	sub	r17,r4,r22
 3211744:	8dc01016 	blt	r17,r23,3211788 <__gethex+0x560>
 3211748:	a0c00317 	ldw	r3,12(r20)
 321174c:	00800084 	movi	r2,2
 3211750:	18809326 	beq	r3,r2,32119a0 <__gethex+0x778>
 3211754:	008000c4 	movi	r2,3
 3211758:	18808e26 	beq	r3,r2,3211994 <__gethex+0x76c>
 321175c:	00800044 	movi	r2,1
 3211760:	18807b26 	beq	r3,r2,3211950 <__gethex+0x728>
 3211764:	a809883a 	mov	r4,r21
 3211768:	980b883a 	mov	r5,r19
 321176c:	320da140 	call	320da14 <_Bfree>
 3211770:	d8c00d17 	ldw	r3,52(sp)
 3211774:	04801404 	movi	r18,80
 3211778:	18000015 	stw	zero,0(r3)
 321177c:	003eed06 	br	3211334 <__gethex+0x10c>
 3211780:	07000084 	movi	fp,2
 3211784:	003fbc06 	br	3211678 <__gethex+0x450>
 3211788:	8c3fffc4 	addi	r16,r17,-1
 321178c:	e0001426 	beq	fp,zero,32117e0 <__gethex+0x5b8>
 3211790:	07000044 	movi	fp,1
 3211794:	8005d17a 	srai	r2,r16,5
 3211798:	d8c00217 	ldw	r3,8(sp)
 321179c:	814007cc 	andi	r5,r16,31
 32117a0:	1085883a 	add	r2,r2,r2
 32117a4:	1085883a 	add	r2,r2,r2
 32117a8:	10c5883a 	add	r2,r2,r3
 32117ac:	00c00044 	movi	r3,1
 32117b0:	1946983a 	sll	r3,r3,r5
 32117b4:	11000017 	ldw	r4,0(r2)
 32117b8:	1906703a 	and	r3,r3,r4
 32117bc:	18000126 	beq	r3,zero,32117c4 <__gethex+0x59c>
 32117c0:	e7000094 	ori	fp,fp,2
 32117c4:	880b883a 	mov	r5,r17
 32117c8:	9809883a 	mov	r4,r19
 32117cc:	32111780 	call	3211178 <rshift>
 32117d0:	a5800117 	ldw	r22,4(r20)
 32117d4:	bc6fc83a 	sub	r23,r23,r17
 32117d8:	04800084 	movi	r18,2
 32117dc:	003fbf06 	br	32116dc <__gethex+0x4b4>
 32117e0:	043fec0e 	bge	zero,r16,3211794 <__gethex+0x56c>
 32117e4:	9809883a 	mov	r4,r19
 32117e8:	800b883a 	mov	r5,r16
 32117ec:	320df0c0 	call	320df0c <__any_on>
 32117f0:	1039883a 	mov	fp,r2
 32117f4:	003fe706 	br	3211794 <__gethex+0x56c>
 32117f8:	e080008c 	andi	r2,fp,2
 32117fc:	103fbf26 	beq	r2,zero,32116fc <__gethex+0x4d4>
 3211800:	d8c00217 	ldw	r3,8(sp)
 3211804:	18800017 	ldw	r2,0(r3)
 3211808:	e084b03a 	or	r2,fp,r2
 321180c:	1104703a 	and	r2,r2,r4
 3211810:	103fba26 	beq	r2,zero,32116fc <__gethex+0x4d4>
 3211814:	9c000417 	ldw	r16,16(r19)
 3211818:	d8c00217 	ldw	r3,8(sp)
 321181c:	017fffc4 	movi	r5,-1
 3211820:	8405883a 	add	r2,r16,r16
 3211824:	10b9883a 	add	fp,r2,r2
 3211828:	1f09883a 	add	r4,r3,fp
 321182c:	dc000015 	stw	r16,0(sp)
 3211830:	00000306 	br	3211840 <__gethex+0x618>
 3211834:	18000015 	stw	zero,0(r3)
 3211838:	18c00104 	addi	r3,r3,4
 321183c:	1900082e 	bgeu	r3,r4,3211860 <__gethex+0x638>
 3211840:	18800017 	ldw	r2,0(r3)
 3211844:	117ffb26 	beq	r2,r5,3211834 <__gethex+0x60c>
 3211848:	10800044 	addi	r2,r2,1
 321184c:	18800015 	stw	r2,0(r3)
 3211850:	00001f06 	br	32118d0 <__gethex+0x6a8>
 3211854:	d8800e17 	ldw	r2,56(sp)
 3211858:	103fa826 	beq	r2,zero,32116fc <__gethex+0x4d4>
 321185c:	003fed06 	br	3211814 <__gethex+0x5ec>
 3211860:	98800217 	ldw	r2,8(r19)
 3211864:	80801316 	blt	r16,r2,32118b4 <__gethex+0x68c>
 3211868:	99400117 	ldw	r5,4(r19)
 321186c:	a809883a 	mov	r4,r21
 3211870:	29400044 	addi	r5,r5,1
 3211874:	320df940 	call	320df94 <_Balloc>
 3211878:	99800417 	ldw	r6,16(r19)
 321187c:	99400304 	addi	r5,r19,12
 3211880:	11000304 	addi	r4,r2,12
 3211884:	318d883a 	add	r6,r6,r6
 3211888:	318d883a 	add	r6,r6,r6
 321188c:	31800204 	addi	r6,r6,8
 3211890:	1023883a 	mov	r17,r2
 3211894:	32067cc0 	call	32067cc <memcpy>
 3211898:	980b883a 	mov	r5,r19
 321189c:	a809883a 	mov	r4,r21
 32118a0:	320da140 	call	320da14 <_Bfree>
 32118a4:	8c000417 	ldw	r16,16(r17)
 32118a8:	88800504 	addi	r2,r17,20
 32118ac:	8827883a 	mov	r19,r17
 32118b0:	d8800215 	stw	r2,8(sp)
 32118b4:	8405883a 	add	r2,r16,r16
 32118b8:	1085883a 	add	r2,r2,r2
 32118bc:	14c5883a 	add	r2,r2,r19
 32118c0:	84000044 	addi	r16,r16,1
 32118c4:	00c00044 	movi	r3,1
 32118c8:	10c00515 	stw	r3,20(r2)
 32118cc:	9c000415 	stw	r16,16(r19)
 32118d0:	00800084 	movi	r2,2
 32118d4:	90801426 	beq	r18,r2,3211928 <__gethex+0x700>
 32118d8:	d8800017 	ldw	r2,0(sp)
 32118dc:	14000b16 	blt	r2,r16,321190c <__gethex+0x6e4>
 32118e0:	bc0007cc 	andi	r16,r23,31
 32118e4:	8000021e 	bne	r16,zero,32118f0 <__gethex+0x6c8>
 32118e8:	94800814 	ori	r18,r18,32
 32118ec:	003f8406 	br	3211700 <__gethex+0x4d8>
 32118f0:	d8c00217 	ldw	r3,8(sp)
 32118f4:	1f05883a 	add	r2,r3,fp
 32118f8:	113fff17 	ldw	r4,-4(r2)
 32118fc:	320da3c0 	call	320da3c <__hi0bits>
 3211900:	00c00804 	movi	r3,32
 3211904:	1c07c83a 	sub	r3,r3,r16
 3211908:	10fff70e 	bge	r2,r3,32118e8 <__gethex+0x6c0>
 321190c:	9809883a 	mov	r4,r19
 3211910:	01400044 	movi	r5,1
 3211914:	32111780 	call	3211178 <rshift>
 3211918:	a0800217 	ldw	r2,8(r20)
 321191c:	b5800044 	addi	r22,r22,1
 3211920:	15bf3716 	blt	r2,r22,3211600 <__gethex+0x3d8>
 3211924:	003ff006 	br	32118e8 <__gethex+0x6c0>
 3211928:	a0800017 	ldw	r2,0(r20)
 321192c:	10bfffc4 	addi	r2,r2,-1
 3211930:	b8801e26 	beq	r23,r2,32119ac <__gethex+0x784>
 3211934:	04800884 	movi	r18,34
 3211938:	003f7106 	br	3211700 <__gethex+0x4d8>
 321193c:	d8c00e17 	ldw	r3,56(sp)
 3211940:	00800044 	movi	r2,1
 3211944:	10c5c83a 	sub	r2,r2,r3
 3211948:	103f6c26 	beq	r2,zero,32116fc <__gethex+0x4d4>
 321194c:	003fb106 	br	3211814 <__gethex+0x5ec>
 3211950:	bc7f841e 	bne	r23,r17,3211764 <__gethex+0x53c>
 3211954:	1dc0050e 	bge	r3,r23,321196c <__gethex+0x744>
 3211958:	b8cbc83a 	sub	r5,r23,r3
 321195c:	9809883a 	mov	r4,r19
 3211960:	320df0c0 	call	320df0c <__any_on>
 3211964:	103f7f26 	beq	r2,zero,3211764 <__gethex+0x53c>
 3211968:	a1000117 	ldw	r4,4(r20)
 321196c:	d8800117 	ldw	r2,4(sp)
 3211970:	d8c00217 	ldw	r3,8(sp)
 3211974:	04000044 	movi	r16,1
 3211978:	11000015 	stw	r4,0(r2)
 321197c:	d8800d17 	ldw	r2,52(sp)
 3211980:	04801884 	movi	r18,98
 3211984:	1c000015 	stw	r16,0(r3)
 3211988:	14c00015 	stw	r19,0(r2)
 321198c:	9c000415 	stw	r16,16(r19)
 3211990:	003e6806 	br	3211334 <__gethex+0x10c>
 3211994:	d8c00e17 	ldw	r3,56(sp)
 3211998:	183f7226 	beq	r3,zero,3211764 <__gethex+0x53c>
 321199c:	003ff306 	br	321196c <__gethex+0x744>
 32119a0:	d8800e17 	ldw	r2,56(sp)
 32119a4:	103ff126 	beq	r2,zero,321196c <__gethex+0x744>
 32119a8:	003f6e06 	br	3211764 <__gethex+0x53c>
 32119ac:	b805d17a 	srai	r2,r23,5
 32119b0:	d8c00217 	ldw	r3,8(sp)
 32119b4:	b94007cc 	andi	r5,r23,31
 32119b8:	1085883a 	add	r2,r2,r2
 32119bc:	1085883a 	add	r2,r2,r2
 32119c0:	10c5883a 	add	r2,r2,r3
 32119c4:	00c00044 	movi	r3,1
 32119c8:	1946983a 	sll	r3,r3,r5
 32119cc:	11000017 	ldw	r4,0(r2)
 32119d0:	1906703a 	and	r3,r3,r4
 32119d4:	183fd726 	beq	r3,zero,3211934 <__gethex+0x70c>
 32119d8:	04800844 	movi	r18,33
 32119dc:	003f4806 	br	3211700 <__gethex+0x4d8>

032119e0 <L_shift>:
 32119e0:	00800204 	movi	r2,8
 32119e4:	1185c83a 	sub	r2,r2,r6
 32119e8:	1085883a 	add	r2,r2,r2
 32119ec:	21c00017 	ldw	r7,0(r4)
 32119f0:	1093883a 	add	r9,r2,r2
 32119f4:	00800804 	movi	r2,32
 32119f8:	200d883a 	mov	r6,r4
 32119fc:	1251c83a 	sub	r8,r2,r9
 3211a00:	31800104 	addi	r6,r6,4
 3211a04:	3805883a 	mov	r2,r7
 3211a08:	31c00017 	ldw	r7,0(r6)
 3211a0c:	3a08983a 	sll	r4,r7,r8
 3211a10:	3a46d83a 	srl	r3,r7,r9
 3211a14:	1104b03a 	or	r2,r2,r4
 3211a18:	180f883a 	mov	r7,r3
 3211a1c:	30bfff15 	stw	r2,-4(r6)
 3211a20:	30c00015 	stw	r3,0(r6)
 3211a24:	317ff636 	bltu	r6,r5,3211a00 <L_shift+0x20>
 3211a28:	f800283a 	ret

03211a2c <__hexnan>:
 3211a2c:	defff404 	addi	sp,sp,-48
 3211a30:	dd800815 	stw	r22,32(sp)
 3211a34:	0580c9b4 	movhi	r22,806
 3211a38:	b5a4cc04 	addi	r22,r22,-27856
 3211a3c:	b0800c03 	ldbu	r2,48(r22)
 3211a40:	dcc00515 	stw	r19,20(sp)
 3211a44:	dc000215 	stw	r16,8(sp)
 3211a48:	dfc00b15 	stw	ra,44(sp)
 3211a4c:	df000a15 	stw	fp,40(sp)
 3211a50:	ddc00915 	stw	r23,36(sp)
 3211a54:	dd400715 	stw	r21,28(sp)
 3211a58:	dd000615 	stw	r20,24(sp)
 3211a5c:	dc800415 	stw	r18,16(sp)
 3211a60:	dc400315 	stw	r17,12(sp)
 3211a64:	d9000115 	stw	r4,4(sp)
 3211a68:	2821883a 	mov	r16,r5
 3211a6c:	3027883a 	mov	r19,r6
 3211a70:	10007426 	beq	r2,zero,3211c44 <__hexnan+0x218>
 3211a74:	80c00017 	ldw	r3,0(r16)
 3211a78:	1805d17a 	srai	r2,r3,5
 3211a7c:	18c007cc 	andi	r3,r3,31
 3211a80:	1839003a 	cmpeq	fp,r3,zero
 3211a84:	1085883a 	add	r2,r2,r2
 3211a88:	1085883a 	add	r2,r2,r2
 3211a8c:	d8c00015 	stw	r3,0(sp)
 3211a90:	14c5883a 	add	r2,r2,r19
 3211a94:	e000011e 	bne	fp,zero,3211a9c <__hexnan+0x70>
 3211a98:	10800104 	addi	r2,r2,4
 3211a9c:	d8c00117 	ldw	r3,4(sp)
 3211aa0:	153fff04 	addi	r20,r2,-4
 3211aa4:	a021883a 	mov	r16,r20
 3211aa8:	1c400017 	ldw	r17,0(r3)
 3211aac:	a02b883a 	mov	r21,r20
 3211ab0:	0025883a 	mov	r18,zero
 3211ab4:	002f883a 	mov	r23,zero
 3211ab8:	000d883a 	mov	r6,zero
 3211abc:	103fff15 	stw	zero,-4(r2)
 3211ac0:	8c400044 	addi	r17,r17,1
 3211ac4:	89000003 	ldbu	r4,0(r17)
 3211ac8:	20000e26 	beq	r4,zero,3211b04 <__hexnan+0xd8>
 3211acc:	2585883a 	add	r2,r4,r22
 3211ad0:	10c00003 	ldbu	r3,0(r2)
 3211ad4:	18002e1e 	bne	r3,zero,3211b90 <__hexnan+0x164>
 3211ad8:	00800804 	movi	r2,32
 3211adc:	11005536 	bltu	r2,r4,3211c34 <__hexnan+0x208>
 3211ae0:	bcbff70e 	bge	r23,r18,3211ac0 <__hexnan+0x94>
 3211ae4:	8540022e 	bgeu	r16,r21,3211af0 <__hexnan+0xc4>
 3211ae8:	008001c4 	movi	r2,7
 3211aec:	11803c0e 	bge	r2,r6,3211be0 <__hexnan+0x1b4>
 3211af0:	9c003536 	bltu	r19,r16,3211bc8 <__hexnan+0x19c>
 3211af4:	8c400044 	addi	r17,r17,1
 3211af8:	89000003 	ldbu	r4,0(r17)
 3211afc:	01800204 	movi	r6,8
 3211b00:	203ff21e 	bne	r4,zero,3211acc <__hexnan+0xa0>
 3211b04:	90004d26 	beq	r18,zero,3211c3c <__hexnan+0x210>
 3211b08:	85404336 	bltu	r16,r21,3211c18 <__hexnan+0x1ec>
 3211b0c:	9c00382e 	bgeu	r19,r16,3211bf0 <__hexnan+0x1c4>
 3211b10:	9807883a 	mov	r3,r19
 3211b14:	80800017 	ldw	r2,0(r16)
 3211b18:	84000104 	addi	r16,r16,4
 3211b1c:	18800015 	stw	r2,0(r3)
 3211b20:	18c00104 	addi	r3,r3,4
 3211b24:	a43ffb2e 	bgeu	r20,r16,3211b14 <__hexnan+0xe8>
 3211b28:	18000015 	stw	zero,0(r3)
 3211b2c:	18c00104 	addi	r3,r3,4
 3211b30:	a0fffd2e 	bgeu	r20,r3,3211b28 <__hexnan+0xfc>
 3211b34:	a0800017 	ldw	r2,0(r20)
 3211b38:	1000071e 	bne	r2,zero,3211b58 <__hexnan+0x12c>
 3211b3c:	9d004326 	beq	r19,r20,3211c4c <__hexnan+0x220>
 3211b40:	a007883a 	mov	r3,r20
 3211b44:	00000106 	br	3211b4c <__hexnan+0x120>
 3211b48:	98c04026 	beq	r19,r3,3211c4c <__hexnan+0x220>
 3211b4c:	18ffff04 	addi	r3,r3,-4
 3211b50:	18800017 	ldw	r2,0(r3)
 3211b54:	103ffc26 	beq	r2,zero,3211b48 <__hexnan+0x11c>
 3211b58:	00c00144 	movi	r3,5
 3211b5c:	1805883a 	mov	r2,r3
 3211b60:	dfc00b17 	ldw	ra,44(sp)
 3211b64:	df000a17 	ldw	fp,40(sp)
 3211b68:	ddc00917 	ldw	r23,36(sp)
 3211b6c:	dd800817 	ldw	r22,32(sp)
 3211b70:	dd400717 	ldw	r21,28(sp)
 3211b74:	dd000617 	ldw	r20,24(sp)
 3211b78:	dcc00517 	ldw	r19,20(sp)
 3211b7c:	dc800417 	ldw	r18,16(sp)
 3211b80:	dc400317 	ldw	r17,12(sp)
 3211b84:	dc000217 	ldw	r16,8(sp)
 3211b88:	dec00c04 	addi	sp,sp,48
 3211b8c:	f800283a 	ret
 3211b90:	31800044 	addi	r6,r6,1
 3211b94:	00800204 	movi	r2,8
 3211b98:	94800044 	addi	r18,r18,1
 3211b9c:	1180040e 	bge	r2,r6,3211bb0 <__hexnan+0x184>
 3211ba0:	9c3fc72e 	bgeu	r19,r16,3211ac0 <__hexnan+0x94>
 3211ba4:	843fff04 	addi	r16,r16,-4
 3211ba8:	80000015 	stw	zero,0(r16)
 3211bac:	01800044 	movi	r6,1
 3211bb0:	80800017 	ldw	r2,0(r16)
 3211bb4:	18c003cc 	andi	r3,r3,15
 3211bb8:	1004913a 	slli	r2,r2,4
 3211bbc:	10c4b03a 	or	r2,r2,r3
 3211bc0:	80800015 	stw	r2,0(r16)
 3211bc4:	003fbe06 	br	3211ac0 <__hexnan+0x94>
 3211bc8:	843fff04 	addi	r16,r16,-4
 3211bcc:	802b883a 	mov	r21,r16
 3211bd0:	902f883a 	mov	r23,r18
 3211bd4:	000d883a 	mov	r6,zero
 3211bd8:	80000015 	stw	zero,0(r16)
 3211bdc:	003fb806 	br	3211ac0 <__hexnan+0x94>
 3211be0:	8009883a 	mov	r4,r16
 3211be4:	a80b883a 	mov	r5,r21
 3211be8:	32119e00 	call	32119e0 <L_shift>
 3211bec:	003fc006 	br	3211af0 <__hexnan+0xc4>
 3211bf0:	e03fd01e 	bne	fp,zero,3211b34 <__hexnan+0x108>
 3211bf4:	d8c00017 	ldw	r3,0(sp)
 3211bf8:	00800804 	movi	r2,32
 3211bfc:	10c5c83a 	sub	r2,r2,r3
 3211c00:	00ffffc4 	movi	r3,-1
 3211c04:	1886d83a 	srl	r3,r3,r2
 3211c08:	a0800017 	ldw	r2,0(r20)
 3211c0c:	10c4703a 	and	r2,r2,r3
 3211c10:	a0800015 	stw	r2,0(r20)
 3211c14:	003fc806 	br	3211b38 <__hexnan+0x10c>
 3211c18:	008001c4 	movi	r2,7
 3211c1c:	11bfbb16 	blt	r2,r6,3211b0c <__hexnan+0xe0>
 3211c20:	a80b883a 	mov	r5,r21
 3211c24:	8009883a 	mov	r4,r16
 3211c28:	32119e00 	call	32119e0 <L_shift>
 3211c2c:	9c3ff02e 	bgeu	r19,r16,3211bf0 <__hexnan+0x1c4>
 3211c30:	003fb706 	br	3211b10 <__hexnan+0xe4>
 3211c34:	00800a44 	movi	r2,41
 3211c38:	20800826 	beq	r4,r2,3211c5c <__hexnan+0x230>
 3211c3c:	00c00104 	movi	r3,4
 3211c40:	003fc606 	br	3211b5c <__hexnan+0x130>
 3211c44:	32111100 	call	3211110 <__hexdig_init>
 3211c48:	003f8a06 	br	3211a74 <__hexnan+0x48>
 3211c4c:	00800044 	movi	r2,1
 3211c50:	00c00144 	movi	r3,5
 3211c54:	98800015 	stw	r2,0(r19)
 3211c58:	003fc006 	br	3211b5c <__hexnan+0x130>
 3211c5c:	903ff726 	beq	r18,zero,3211c3c <__hexnan+0x210>
 3211c60:	d8c00117 	ldw	r3,4(sp)
 3211c64:	88800044 	addi	r2,r17,1
 3211c68:	18800015 	stw	r2,0(r3)
 3211c6c:	857fa72e 	bgeu	r16,r21,3211b0c <__hexnan+0xe0>
 3211c70:	003fe906 	br	3211c18 <__hexnan+0x1ec>

03211c74 <__muldi3>:
 3211c74:	2011883a 	mov	r8,r4
 3211c78:	427fffcc 	andi	r9,r8,65535
 3211c7c:	4018d43a 	srli	r12,r8,16
 3211c80:	32bfffcc 	andi	r10,r6,65535
 3211c84:	3016d43a 	srli	r11,r6,16
 3211c88:	4a85383a 	mul	r2,r9,r10
 3211c8c:	6295383a 	mul	r10,r12,r10
 3211c90:	4ad3383a 	mul	r9,r9,r11
 3211c94:	113fffcc 	andi	r4,r2,65535
 3211c98:	1004d43a 	srli	r2,r2,16
 3211c9c:	4a93883a 	add	r9,r9,r10
 3211ca0:	3807883a 	mov	r3,r7
 3211ca4:	1245883a 	add	r2,r2,r9
 3211ca8:	280f883a 	mov	r7,r5
 3211cac:	180b883a 	mov	r5,r3
 3211cb0:	1006943a 	slli	r3,r2,16
 3211cb4:	defffd04 	addi	sp,sp,-12
 3211cb8:	dc800215 	stw	r18,8(sp)
 3211cbc:	1907883a 	add	r3,r3,r4
 3211cc0:	dc400115 	stw	r17,4(sp)
 3211cc4:	dc000015 	stw	r16,0(sp)
 3211cc8:	4165383a 	mul	r18,r8,r5
 3211ccc:	31e3383a 	mul	r17,r6,r7
 3211cd0:	1012d43a 	srli	r9,r2,16
 3211cd4:	62d9383a 	mul	r12,r12,r11
 3211cd8:	181f883a 	mov	r15,r3
 3211cdc:	1280022e 	bgeu	r2,r10,3211ce8 <__muldi3+0x74>
 3211ce0:	00800074 	movhi	r2,1
 3211ce4:	6099883a 	add	r12,r12,r2
 3211ce8:	624d883a 	add	r6,r12,r9
 3211cec:	9187883a 	add	r3,r18,r6
 3211cf0:	88c7883a 	add	r3,r17,r3
 3211cf4:	7805883a 	mov	r2,r15
 3211cf8:	dc800217 	ldw	r18,8(sp)
 3211cfc:	dc400117 	ldw	r17,4(sp)
 3211d00:	dc000017 	ldw	r16,0(sp)
 3211d04:	dec00304 	addi	sp,sp,12
 3211d08:	f800283a 	ret

03211d0c <__fixunsdfsi>:
 3211d0c:	defffb04 	addi	sp,sp,-20
 3211d10:	dc400115 	stw	r17,4(sp)
 3211d14:	dc000015 	stw	r16,0(sp)
 3211d18:	04507834 	movhi	r17,16864
 3211d1c:	0021883a 	mov	r16,zero
 3211d20:	800d883a 	mov	r6,r16
 3211d24:	880f883a 	mov	r7,r17
 3211d28:	dcc00315 	stw	r19,12(sp)
 3211d2c:	dc800215 	stw	r18,8(sp)
 3211d30:	2827883a 	mov	r19,r5
 3211d34:	2025883a 	mov	r18,r4
 3211d38:	dfc00415 	stw	ra,16(sp)
 3211d3c:	321375c0 	call	321375c <__gedf2>
 3211d40:	000d883a 	mov	r6,zero
 3211d44:	880f883a 	mov	r7,r17
 3211d48:	980b883a 	mov	r5,r19
 3211d4c:	9009883a 	mov	r4,r18
 3211d50:	10000d16 	blt	r2,zero,3211d88 <__fixunsdfsi+0x7c>
 3211d54:	3212eb40 	call	3212eb4 <__subdf3>
 3211d58:	180b883a 	mov	r5,r3
 3211d5c:	1009883a 	mov	r4,r2
 3211d60:	32139ec0 	call	32139ec <__fixdfsi>
 3211d64:	00e00034 	movhi	r3,32768
 3211d68:	10c5883a 	add	r2,r2,r3
 3211d6c:	dfc00417 	ldw	ra,16(sp)
 3211d70:	dcc00317 	ldw	r19,12(sp)
 3211d74:	dc800217 	ldw	r18,8(sp)
 3211d78:	dc400117 	ldw	r17,4(sp)
 3211d7c:	dc000017 	ldw	r16,0(sp)
 3211d80:	dec00504 	addi	sp,sp,20
 3211d84:	f800283a 	ret
 3211d88:	980b883a 	mov	r5,r19
 3211d8c:	9009883a 	mov	r4,r18
 3211d90:	32139ec0 	call	32139ec <__fixdfsi>
 3211d94:	dfc00417 	ldw	ra,16(sp)
 3211d98:	dcc00317 	ldw	r19,12(sp)
 3211d9c:	dc800217 	ldw	r18,8(sp)
 3211da0:	dc400117 	ldw	r17,4(sp)
 3211da4:	dc000017 	ldw	r16,0(sp)
 3211da8:	dec00504 	addi	sp,sp,20
 3211dac:	f800283a 	ret

03211db0 <__udivdi3>:
 3211db0:	defff004 	addi	sp,sp,-64
 3211db4:	2005883a 	mov	r2,r4
 3211db8:	3011883a 	mov	r8,r6
 3211dbc:	df000e15 	stw	fp,56(sp)
 3211dc0:	dd000a15 	stw	r20,40(sp)
 3211dc4:	dc000615 	stw	r16,24(sp)
 3211dc8:	dfc00f15 	stw	ra,60(sp)
 3211dcc:	ddc00d15 	stw	r23,52(sp)
 3211dd0:	dd800c15 	stw	r22,48(sp)
 3211dd4:	dd400b15 	stw	r21,44(sp)
 3211dd8:	dcc00915 	stw	r19,36(sp)
 3211ddc:	dc800815 	stw	r18,32(sp)
 3211de0:	dc400715 	stw	r17,28(sp)
 3211de4:	4021883a 	mov	r16,r8
 3211de8:	1039883a 	mov	fp,r2
 3211dec:	2829883a 	mov	r20,r5
 3211df0:	38003b1e 	bne	r7,zero,3211ee0 <__udivdi3+0x130>
 3211df4:	2a005c36 	bltu	r5,r8,3211f68 <__udivdi3+0x1b8>
 3211df8:	4000a626 	beq	r8,zero,3212094 <__udivdi3+0x2e4>
 3211dfc:	00bfffd4 	movui	r2,65535
 3211e00:	14009e36 	bltu	r2,r16,321207c <__udivdi3+0x2cc>
 3211e04:	00803fc4 	movi	r2,255
 3211e08:	14013d36 	bltu	r2,r16,3212300 <__udivdi3+0x550>
 3211e0c:	000b883a 	mov	r5,zero
 3211e10:	0005883a 	mov	r2,zero
 3211e14:	8084d83a 	srl	r2,r16,r2
 3211e18:	0100c974 	movhi	r4,805
 3211e1c:	21384b04 	addi	r4,r4,-7892
 3211e20:	01800804 	movi	r6,32
 3211e24:	1105883a 	add	r2,r2,r4
 3211e28:	10c00003 	ldbu	r3,0(r2)
 3211e2c:	28c7883a 	add	r3,r5,r3
 3211e30:	30edc83a 	sub	r22,r6,r3
 3211e34:	b000ee1e 	bne	r22,zero,32121f0 <__udivdi3+0x440>
 3211e38:	802ad43a 	srli	r21,r16,16
 3211e3c:	00800044 	movi	r2,1
 3211e40:	a423c83a 	sub	r17,r20,r16
 3211e44:	85ffffcc 	andi	r23,r16,65535
 3211e48:	d8800315 	stw	r2,12(sp)
 3211e4c:	8809883a 	mov	r4,r17
 3211e50:	a80b883a 	mov	r5,r21
 3211e54:	32044bc0 	call	32044bc <__udivsi3>
 3211e58:	8809883a 	mov	r4,r17
 3211e5c:	a80b883a 	mov	r5,r21
 3211e60:	102d883a 	mov	r22,r2
 3211e64:	32044c40 	call	32044c4 <__umodsi3>
 3211e68:	1004943a 	slli	r2,r2,16
 3211e6c:	e006d43a 	srli	r3,fp,16
 3211e70:	bda3383a 	mul	r17,r23,r22
 3211e74:	10c4b03a 	or	r2,r2,r3
 3211e78:	1440042e 	bgeu	r2,r17,3211e8c <__udivdi3+0xdc>
 3211e7c:	1405883a 	add	r2,r2,r16
 3211e80:	b5bfffc4 	addi	r22,r22,-1
 3211e84:	14000136 	bltu	r2,r16,3211e8c <__udivdi3+0xdc>
 3211e88:	14413d36 	bltu	r2,r17,3212380 <__udivdi3+0x5d0>
 3211e8c:	1463c83a 	sub	r17,r2,r17
 3211e90:	8809883a 	mov	r4,r17
 3211e94:	a80b883a 	mov	r5,r21
 3211e98:	32044bc0 	call	32044bc <__udivsi3>
 3211e9c:	8809883a 	mov	r4,r17
 3211ea0:	a80b883a 	mov	r5,r21
 3211ea4:	1029883a 	mov	r20,r2
 3211ea8:	32044c40 	call	32044c4 <__umodsi3>
 3211eac:	1004943a 	slli	r2,r2,16
 3211eb0:	bd09383a 	mul	r4,r23,r20
 3211eb4:	e0ffffcc 	andi	r3,fp,65535
 3211eb8:	10c4b03a 	or	r2,r2,r3
 3211ebc:	1100042e 	bgeu	r2,r4,3211ed0 <__udivdi3+0x120>
 3211ec0:	8085883a 	add	r2,r16,r2
 3211ec4:	a53fffc4 	addi	r20,r20,-1
 3211ec8:	14000136 	bltu	r2,r16,3211ed0 <__udivdi3+0x120>
 3211ecc:	11012036 	bltu	r2,r4,3212350 <__udivdi3+0x5a0>
 3211ed0:	b004943a 	slli	r2,r22,16
 3211ed4:	d9000317 	ldw	r4,12(sp)
 3211ed8:	a084b03a 	or	r2,r20,r2
 3211edc:	00001506 	br	3211f34 <__udivdi3+0x184>
 3211ee0:	380d883a 	mov	r6,r7
 3211ee4:	29c06236 	bltu	r5,r7,3212070 <__udivdi3+0x2c0>
 3211ee8:	00bfffd4 	movui	r2,65535
 3211eec:	11c05a36 	bltu	r2,r7,3212058 <__udivdi3+0x2a8>
 3211ef0:	00803fc4 	movi	r2,255
 3211ef4:	11c0fc36 	bltu	r2,r7,32122e8 <__udivdi3+0x538>
 3211ef8:	000b883a 	mov	r5,zero
 3211efc:	0005883a 	mov	r2,zero
 3211f00:	3084d83a 	srl	r2,r6,r2
 3211f04:	0100c974 	movhi	r4,805
 3211f08:	21384b04 	addi	r4,r4,-7892
 3211f0c:	01c00804 	movi	r7,32
 3211f10:	1105883a 	add	r2,r2,r4
 3211f14:	10c00003 	ldbu	r3,0(r2)
 3211f18:	28c7883a 	add	r3,r5,r3
 3211f1c:	38efc83a 	sub	r23,r7,r3
 3211f20:	b800691e 	bne	r23,zero,32120c8 <__udivdi3+0x318>
 3211f24:	35000136 	bltu	r6,r20,3211f2c <__udivdi3+0x17c>
 3211f28:	e4005136 	bltu	fp,r16,3212070 <__udivdi3+0x2c0>
 3211f2c:	00800044 	movi	r2,1
 3211f30:	0009883a 	mov	r4,zero
 3211f34:	2007883a 	mov	r3,r4
 3211f38:	dfc00f17 	ldw	ra,60(sp)
 3211f3c:	df000e17 	ldw	fp,56(sp)
 3211f40:	ddc00d17 	ldw	r23,52(sp)
 3211f44:	dd800c17 	ldw	r22,48(sp)
 3211f48:	dd400b17 	ldw	r21,44(sp)
 3211f4c:	dd000a17 	ldw	r20,40(sp)
 3211f50:	dcc00917 	ldw	r19,36(sp)
 3211f54:	dc800817 	ldw	r18,32(sp)
 3211f58:	dc400717 	ldw	r17,28(sp)
 3211f5c:	dc000617 	ldw	r16,24(sp)
 3211f60:	dec01004 	addi	sp,sp,64
 3211f64:	f800283a 	ret
 3211f68:	00bfffd4 	movui	r2,65535
 3211f6c:	12005036 	bltu	r2,r8,32120b0 <__udivdi3+0x300>
 3211f70:	00803fc4 	movi	r2,255
 3211f74:	1200e836 	bltu	r2,r8,3212318 <__udivdi3+0x568>
 3211f78:	000b883a 	mov	r5,zero
 3211f7c:	0005883a 	mov	r2,zero
 3211f80:	8084d83a 	srl	r2,r16,r2
 3211f84:	0100c974 	movhi	r4,805
 3211f88:	21384b04 	addi	r4,r4,-7892
 3211f8c:	01800804 	movi	r6,32
 3211f90:	1105883a 	add	r2,r2,r4
 3211f94:	10c00003 	ldbu	r3,0(r2)
 3211f98:	28c7883a 	add	r3,r5,r3
 3211f9c:	30cbc83a 	sub	r5,r6,r3
 3211fa0:	28000626 	beq	r5,zero,3211fbc <__udivdi3+0x20c>
 3211fa4:	3145c83a 	sub	r2,r6,r5
 3211fa8:	e084d83a 	srl	r2,fp,r2
 3211fac:	a146983a 	sll	r3,r20,r5
 3211fb0:	e178983a 	sll	fp,fp,r5
 3211fb4:	8160983a 	sll	r16,r16,r5
 3211fb8:	18a8b03a 	or	r20,r3,r2
 3211fbc:	802ad43a 	srli	r21,r16,16
 3211fc0:	a009883a 	mov	r4,r20
 3211fc4:	85ffffcc 	andi	r23,r16,65535
 3211fc8:	a80b883a 	mov	r5,r21
 3211fcc:	32044bc0 	call	32044bc <__udivsi3>
 3211fd0:	a009883a 	mov	r4,r20
 3211fd4:	a80b883a 	mov	r5,r21
 3211fd8:	102d883a 	mov	r22,r2
 3211fdc:	32044c40 	call	32044c4 <__umodsi3>
 3211fe0:	1004943a 	slli	r2,r2,16
 3211fe4:	e006d43a 	srli	r3,fp,16
 3211fe8:	bda3383a 	mul	r17,r23,r22
 3211fec:	10c4b03a 	or	r2,r2,r3
 3211ff0:	1440042e 	bgeu	r2,r17,3212004 <__udivdi3+0x254>
 3211ff4:	1405883a 	add	r2,r2,r16
 3211ff8:	b5bfffc4 	addi	r22,r22,-1
 3211ffc:	14000136 	bltu	r2,r16,3212004 <__udivdi3+0x254>
 3212000:	1440d536 	bltu	r2,r17,3212358 <__udivdi3+0x5a8>
 3212004:	1463c83a 	sub	r17,r2,r17
 3212008:	8809883a 	mov	r4,r17
 321200c:	a80b883a 	mov	r5,r21
 3212010:	32044bc0 	call	32044bc <__udivsi3>
 3212014:	8809883a 	mov	r4,r17
 3212018:	a80b883a 	mov	r5,r21
 321201c:	1029883a 	mov	r20,r2
 3212020:	32044c40 	call	32044c4 <__umodsi3>
 3212024:	1004943a 	slli	r2,r2,16
 3212028:	bd09383a 	mul	r4,r23,r20
 321202c:	e0ffffcc 	andi	r3,fp,65535
 3212030:	10c4b03a 	or	r2,r2,r3
 3212034:	1100042e 	bgeu	r2,r4,3212048 <__udivdi3+0x298>
 3212038:	8085883a 	add	r2,r16,r2
 321203c:	a53fffc4 	addi	r20,r20,-1
 3212040:	14000136 	bltu	r2,r16,3212048 <__udivdi3+0x298>
 3212044:	1100c736 	bltu	r2,r4,3212364 <__udivdi3+0x5b4>
 3212048:	b004943a 	slli	r2,r22,16
 321204c:	0009883a 	mov	r4,zero
 3212050:	a084b03a 	or	r2,r20,r2
 3212054:	003fb706 	br	3211f34 <__udivdi3+0x184>
 3212058:	00804034 	movhi	r2,256
 321205c:	10bfffc4 	addi	r2,r2,-1
 3212060:	11c0a436 	bltu	r2,r7,32122f4 <__udivdi3+0x544>
 3212064:	01400404 	movi	r5,16
 3212068:	2805883a 	mov	r2,r5
 321206c:	003fa406 	br	3211f00 <__udivdi3+0x150>
 3212070:	0005883a 	mov	r2,zero
 3212074:	0009883a 	mov	r4,zero
 3212078:	003fae06 	br	3211f34 <__udivdi3+0x184>
 321207c:	00804034 	movhi	r2,256
 3212080:	10bfffc4 	addi	r2,r2,-1
 3212084:	1400a136 	bltu	r2,r16,321230c <__udivdi3+0x55c>
 3212088:	01400404 	movi	r5,16
 321208c:	2805883a 	mov	r2,r5
 3212090:	003f6006 	br	3211e14 <__udivdi3+0x64>
 3212094:	01000044 	movi	r4,1
 3212098:	000b883a 	mov	r5,zero
 321209c:	32044bc0 	call	32044bc <__udivsi3>
 32120a0:	1021883a 	mov	r16,r2
 32120a4:	00bfffd4 	movui	r2,65535
 32120a8:	143ff436 	bltu	r2,r16,321207c <__udivdi3+0x2cc>
 32120ac:	003f5506 	br	3211e04 <__udivdi3+0x54>
 32120b0:	00804034 	movhi	r2,256
 32120b4:	10bfffc4 	addi	r2,r2,-1
 32120b8:	12009a36 	bltu	r2,r8,3212324 <__udivdi3+0x574>
 32120bc:	01400404 	movi	r5,16
 32120c0:	2805883a 	mov	r2,r5
 32120c4:	003fae06 	br	3211f80 <__udivdi3+0x1d0>
 32120c8:	3dc5c83a 	sub	r2,r7,r23
 32120cc:	35c8983a 	sll	r4,r6,r23
 32120d0:	8086d83a 	srl	r3,r16,r2
 32120d4:	a0a2d83a 	srl	r17,r20,r2
 32120d8:	e084d83a 	srl	r2,fp,r2
 32120dc:	20eab03a 	or	r21,r4,r3
 32120e0:	a82cd43a 	srli	r22,r21,16
 32120e4:	a5c6983a 	sll	r3,r20,r23
 32120e8:	8809883a 	mov	r4,r17
 32120ec:	b00b883a 	mov	r5,r22
 32120f0:	1886b03a 	or	r3,r3,r2
 32120f4:	d8c00215 	stw	r3,8(sp)
 32120f8:	32044bc0 	call	32044bc <__udivsi3>
 32120fc:	8809883a 	mov	r4,r17
 3212100:	b00b883a 	mov	r5,r22
 3212104:	1029883a 	mov	r20,r2
 3212108:	32044c40 	call	32044c4 <__umodsi3>
 321210c:	a8ffffcc 	andi	r3,r21,65535
 3212110:	d8c00515 	stw	r3,20(sp)
 3212114:	d9000217 	ldw	r4,8(sp)
 3212118:	d9400517 	ldw	r5,20(sp)
 321211c:	1004943a 	slli	r2,r2,16
 3212120:	2006d43a 	srli	r3,r4,16
 3212124:	85e0983a 	sll	r16,r16,r23
 3212128:	2d23383a 	mul	r17,r5,r20
 321212c:	10c4b03a 	or	r2,r2,r3
 3212130:	dc000015 	stw	r16,0(sp)
 3212134:	1440032e 	bgeu	r2,r17,3212144 <__udivdi3+0x394>
 3212138:	1545883a 	add	r2,r2,r21
 321213c:	a53fffc4 	addi	r20,r20,-1
 3212140:	15407f2e 	bgeu	r2,r21,3212340 <__udivdi3+0x590>
 3212144:	1463c83a 	sub	r17,r2,r17
 3212148:	8809883a 	mov	r4,r17
 321214c:	b00b883a 	mov	r5,r22
 3212150:	32044bc0 	call	32044bc <__udivsi3>
 3212154:	8809883a 	mov	r4,r17
 3212158:	b00b883a 	mov	r5,r22
 321215c:	1021883a 	mov	r16,r2
 3212160:	32044c40 	call	32044c4 <__umodsi3>
 3212164:	d8c00517 	ldw	r3,20(sp)
 3212168:	d9000217 	ldw	r4,8(sp)
 321216c:	1004943a 	slli	r2,r2,16
 3212170:	1c0f383a 	mul	r7,r3,r16
 3212174:	20ffffcc 	andi	r3,r4,65535
 3212178:	10e2b03a 	or	r17,r2,r3
 321217c:	89c0032e 	bgeu	r17,r7,321218c <__udivdi3+0x3dc>
 3212180:	8d63883a 	add	r17,r17,r21
 3212184:	843fffc4 	addi	r16,r16,-1
 3212188:	8d40692e 	bgeu	r17,r21,3212330 <__udivdi3+0x580>
 321218c:	a008943a 	slli	r4,r20,16
 3212190:	d9400017 	ldw	r5,0(sp)
 3212194:	89e3c83a 	sub	r17,r17,r7
 3212198:	8110b03a 	or	r8,r16,r4
 321219c:	280cd43a 	srli	r6,r5,16
 32121a0:	28ffffcc 	andi	r3,r5,65535
 32121a4:	40bfffcc 	andi	r2,r8,65535
 32121a8:	400ad43a 	srli	r5,r8,16
 32121ac:	10d3383a 	mul	r9,r2,r3
 32121b0:	1185383a 	mul	r2,r2,r6
 32121b4:	28c7383a 	mul	r3,r5,r3
 32121b8:	4808d43a 	srli	r4,r9,16
 32121bc:	298b383a 	mul	r5,r5,r6
 32121c0:	10c5883a 	add	r2,r2,r3
 32121c4:	2089883a 	add	r4,r4,r2
 32121c8:	20c0022e 	bgeu	r4,r3,32121d4 <__udivdi3+0x424>
 32121cc:	00800074 	movhi	r2,1
 32121d0:	288b883a 	add	r5,r5,r2
 32121d4:	2004d43a 	srli	r2,r4,16
 32121d8:	288b883a 	add	r5,r5,r2
 32121dc:	89403f36 	bltu	r17,r5,32122dc <__udivdi3+0x52c>
 32121e0:	89403926 	beq	r17,r5,32122c8 <__udivdi3+0x518>
 32121e4:	4005883a 	mov	r2,r8
 32121e8:	0009883a 	mov	r4,zero
 32121ec:	003f5106 	br	3211f34 <__udivdi3+0x184>
 32121f0:	85a0983a 	sll	r16,r16,r22
 32121f4:	3585c83a 	sub	r2,r6,r22
 32121f8:	a0a2d83a 	srl	r17,r20,r2
 32121fc:	802ad43a 	srli	r21,r16,16
 3212200:	e084d83a 	srl	r2,fp,r2
 3212204:	a586983a 	sll	r3,r20,r22
 3212208:	8809883a 	mov	r4,r17
 321220c:	a80b883a 	mov	r5,r21
 3212210:	1886b03a 	or	r3,r3,r2
 3212214:	d8c00115 	stw	r3,4(sp)
 3212218:	32044bc0 	call	32044bc <__udivsi3>
 321221c:	8809883a 	mov	r4,r17
 3212220:	a80b883a 	mov	r5,r21
 3212224:	d8800415 	stw	r2,16(sp)
 3212228:	32044c40 	call	32044c4 <__umodsi3>
 321222c:	d9000117 	ldw	r4,4(sp)
 3212230:	d9400417 	ldw	r5,16(sp)
 3212234:	1004943a 	slli	r2,r2,16
 3212238:	85ffffcc 	andi	r23,r16,65535
 321223c:	2006d43a 	srli	r3,r4,16
 3212240:	b963383a 	mul	r17,r23,r5
 3212244:	10c4b03a 	or	r2,r2,r3
 3212248:	1440042e 	bgeu	r2,r17,321225c <__udivdi3+0x4ac>
 321224c:	297fffc4 	addi	r5,r5,-1
 3212250:	1405883a 	add	r2,r2,r16
 3212254:	d9400415 	stw	r5,16(sp)
 3212258:	1400442e 	bgeu	r2,r16,321236c <__udivdi3+0x5bc>
 321225c:	1463c83a 	sub	r17,r2,r17
 3212260:	8809883a 	mov	r4,r17
 3212264:	a80b883a 	mov	r5,r21
 3212268:	32044bc0 	call	32044bc <__udivsi3>
 321226c:	8809883a 	mov	r4,r17
 3212270:	a80b883a 	mov	r5,r21
 3212274:	1029883a 	mov	r20,r2
 3212278:	32044c40 	call	32044c4 <__umodsi3>
 321227c:	d9400117 	ldw	r5,4(sp)
 3212280:	1004943a 	slli	r2,r2,16
 3212284:	bd09383a 	mul	r4,r23,r20
 3212288:	28ffffcc 	andi	r3,r5,65535
 321228c:	10c6b03a 	or	r3,r2,r3
 3212290:	1900062e 	bgeu	r3,r4,32122ac <__udivdi3+0x4fc>
 3212294:	1c07883a 	add	r3,r3,r16
 3212298:	a53fffc4 	addi	r20,r20,-1
 321229c:	1c000336 	bltu	r3,r16,32122ac <__udivdi3+0x4fc>
 32122a0:	1900022e 	bgeu	r3,r4,32122ac <__udivdi3+0x4fc>
 32122a4:	a53fffc4 	addi	r20,r20,-1
 32122a8:	1c07883a 	add	r3,r3,r16
 32122ac:	d9400417 	ldw	r5,16(sp)
 32122b0:	e5b8983a 	sll	fp,fp,r22
 32122b4:	1923c83a 	sub	r17,r3,r4
 32122b8:	2804943a 	slli	r2,r5,16
 32122bc:	a0a8b03a 	or	r20,r20,r2
 32122c0:	dd000315 	stw	r20,12(sp)
 32122c4:	003ee106 	br	3211e4c <__udivdi3+0x9c>
 32122c8:	2004943a 	slli	r2,r4,16
 32122cc:	e5c8983a 	sll	r4,fp,r23
 32122d0:	48ffffcc 	andi	r3,r9,65535
 32122d4:	10c5883a 	add	r2,r2,r3
 32122d8:	20bfc22e 	bgeu	r4,r2,32121e4 <__udivdi3+0x434>
 32122dc:	40bfffc4 	addi	r2,r8,-1
 32122e0:	0009883a 	mov	r4,zero
 32122e4:	003f1306 	br	3211f34 <__udivdi3+0x184>
 32122e8:	01400204 	movi	r5,8
 32122ec:	2805883a 	mov	r2,r5
 32122f0:	003f0306 	br	3211f00 <__udivdi3+0x150>
 32122f4:	01400604 	movi	r5,24
 32122f8:	2805883a 	mov	r2,r5
 32122fc:	003f0006 	br	3211f00 <__udivdi3+0x150>
 3212300:	01400204 	movi	r5,8
 3212304:	2805883a 	mov	r2,r5
 3212308:	003ec206 	br	3211e14 <__udivdi3+0x64>
 321230c:	01400604 	movi	r5,24
 3212310:	2805883a 	mov	r2,r5
 3212314:	003ebf06 	br	3211e14 <__udivdi3+0x64>
 3212318:	01400204 	movi	r5,8
 321231c:	2805883a 	mov	r2,r5
 3212320:	003f1706 	br	3211f80 <__udivdi3+0x1d0>
 3212324:	01400604 	movi	r5,24
 3212328:	2805883a 	mov	r2,r5
 321232c:	003f1406 	br	3211f80 <__udivdi3+0x1d0>
 3212330:	89ff962e 	bgeu	r17,r7,321218c <__udivdi3+0x3dc>
 3212334:	8d63883a 	add	r17,r17,r21
 3212338:	843fffc4 	addi	r16,r16,-1
 321233c:	003f9306 	br	321218c <__udivdi3+0x3dc>
 3212340:	147f802e 	bgeu	r2,r17,3212144 <__udivdi3+0x394>
 3212344:	a53fffc4 	addi	r20,r20,-1
 3212348:	1545883a 	add	r2,r2,r21
 321234c:	003f7d06 	br	3212144 <__udivdi3+0x394>
 3212350:	a53fffc4 	addi	r20,r20,-1
 3212354:	003ede06 	br	3211ed0 <__udivdi3+0x120>
 3212358:	b5bfffc4 	addi	r22,r22,-1
 321235c:	1405883a 	add	r2,r2,r16
 3212360:	003f2806 	br	3212004 <__udivdi3+0x254>
 3212364:	a53fffc4 	addi	r20,r20,-1
 3212368:	003f3706 	br	3212048 <__udivdi3+0x298>
 321236c:	147fbb2e 	bgeu	r2,r17,321225c <__udivdi3+0x4ac>
 3212370:	297fffc4 	addi	r5,r5,-1
 3212374:	1405883a 	add	r2,r2,r16
 3212378:	d9400415 	stw	r5,16(sp)
 321237c:	003fb706 	br	321225c <__udivdi3+0x4ac>
 3212380:	b5bfffc4 	addi	r22,r22,-1
 3212384:	1405883a 	add	r2,r2,r16
 3212388:	003ec006 	br	3211e8c <__udivdi3+0xdc>

0321238c <__umoddi3>:
 321238c:	defff104 	addi	sp,sp,-60
 3212390:	dd800b15 	stw	r22,44(sp)
 3212394:	dd000915 	stw	r20,36(sp)
 3212398:	dc000515 	stw	r16,20(sp)
 321239c:	dfc00e15 	stw	ra,56(sp)
 32123a0:	df000d15 	stw	fp,52(sp)
 32123a4:	ddc00c15 	stw	r23,48(sp)
 32123a8:	dd400a15 	stw	r21,40(sp)
 32123ac:	dcc00815 	stw	r19,32(sp)
 32123b0:	dc800715 	stw	r18,28(sp)
 32123b4:	dc400615 	stw	r17,24(sp)
 32123b8:	3021883a 	mov	r16,r6
 32123bc:	202d883a 	mov	r22,r4
 32123c0:	2829883a 	mov	r20,r5
 32123c4:	38002b1e 	bne	r7,zero,3212474 <__umoddi3+0xe8>
 32123c8:	29805036 	bltu	r5,r6,321250c <__umoddi3+0x180>
 32123cc:	30008a26 	beq	r6,zero,32125f8 <__umoddi3+0x26c>
 32123d0:	00bfffd4 	movui	r2,65535
 32123d4:	14008236 	bltu	r2,r16,32125e0 <__umoddi3+0x254>
 32123d8:	00803fc4 	movi	r2,255
 32123dc:	14013636 	bltu	r2,r16,32128b8 <__umoddi3+0x52c>
 32123e0:	000b883a 	mov	r5,zero
 32123e4:	0005883a 	mov	r2,zero
 32123e8:	8084d83a 	srl	r2,r16,r2
 32123ec:	0100c974 	movhi	r4,805
 32123f0:	21384b04 	addi	r4,r4,-7892
 32123f4:	01800804 	movi	r6,32
 32123f8:	1105883a 	add	r2,r2,r4
 32123fc:	10c00003 	ldbu	r3,0(r2)
 3212400:	28c7883a 	add	r3,r5,r3
 3212404:	30efc83a 	sub	r23,r6,r3
 3212408:	b800941e 	bne	r23,zero,321265c <__umoddi3+0x2d0>
 321240c:	802ad43a 	srli	r21,r16,16
 3212410:	a423c83a 	sub	r17,r20,r16
 3212414:	0039883a 	mov	fp,zero
 3212418:	853fffcc 	andi	r20,r16,65535
 321241c:	8809883a 	mov	r4,r17
 3212420:	a80b883a 	mov	r5,r21
 3212424:	32044bc0 	call	32044bc <__udivsi3>
 3212428:	8809883a 	mov	r4,r17
 321242c:	a80b883a 	mov	r5,r21
 3212430:	a0a3383a 	mul	r17,r20,r2
 3212434:	32044c40 	call	32044c4 <__umodsi3>
 3212438:	1004943a 	slli	r2,r2,16
 321243c:	b006d43a 	srli	r3,r22,16
 3212440:	10c4b03a 	or	r2,r2,r3
 3212444:	1440032e 	bgeu	r2,r17,3212454 <__umoddi3+0xc8>
 3212448:	1405883a 	add	r2,r2,r16
 321244c:	14000136 	bltu	r2,r16,3212454 <__umoddi3+0xc8>
 3212450:	14413536 	bltu	r2,r17,3212928 <__umoddi3+0x59c>
 3212454:	1463c83a 	sub	r17,r2,r17
 3212458:	8809883a 	mov	r4,r17
 321245c:	a80b883a 	mov	r5,r21
 3212460:	32044bc0 	call	32044bc <__udivsi3>
 3212464:	8809883a 	mov	r4,r17
 3212468:	a0a3383a 	mul	r17,r20,r2
 321246c:	a80b883a 	mov	r5,r21
 3212470:	00004d06 	br	32125a8 <__umoddi3+0x21c>
 3212474:	380d883a 	mov	r6,r7
 3212478:	29c0102e 	bgeu	r5,r7,32124bc <__umoddi3+0x130>
 321247c:	2011883a 	mov	r8,r4
 3212480:	2813883a 	mov	r9,r5
 3212484:	4005883a 	mov	r2,r8
 3212488:	4807883a 	mov	r3,r9
 321248c:	dfc00e17 	ldw	ra,56(sp)
 3212490:	df000d17 	ldw	fp,52(sp)
 3212494:	ddc00c17 	ldw	r23,48(sp)
 3212498:	dd800b17 	ldw	r22,44(sp)
 321249c:	dd400a17 	ldw	r21,40(sp)
 32124a0:	dd000917 	ldw	r20,36(sp)
 32124a4:	dcc00817 	ldw	r19,32(sp)
 32124a8:	dc800717 	ldw	r18,28(sp)
 32124ac:	dc400617 	ldw	r17,24(sp)
 32124b0:	dc000517 	ldw	r16,20(sp)
 32124b4:	dec00f04 	addi	sp,sp,60
 32124b8:	f800283a 	ret
 32124bc:	00bfffd4 	movui	r2,65535
 32124c0:	11c05a36 	bltu	r2,r7,321262c <__umoddi3+0x2a0>
 32124c4:	00803fc4 	movi	r2,255
 32124c8:	11c0fe36 	bltu	r2,r7,32128c4 <__umoddi3+0x538>
 32124cc:	000b883a 	mov	r5,zero
 32124d0:	0005883a 	mov	r2,zero
 32124d4:	3084d83a 	srl	r2,r6,r2
 32124d8:	0100c974 	movhi	r4,805
 32124dc:	21384b04 	addi	r4,r4,-7892
 32124e0:	01c00804 	movi	r7,32
 32124e4:	1105883a 	add	r2,r2,r4
 32124e8:	10c00003 	ldbu	r3,0(r2)
 32124ec:	28c7883a 	add	r3,r5,r3
 32124f0:	38ebc83a 	sub	r21,r7,r3
 32124f4:	a800851e 	bne	r21,zero,321270c <__umoddi3+0x380>
 32124f8:	35005236 	bltu	r6,r20,3212644 <__umoddi3+0x2b8>
 32124fc:	b400512e 	bgeu	r22,r16,3212644 <__umoddi3+0x2b8>
 3212500:	b011883a 	mov	r8,r22
 3212504:	a013883a 	mov	r9,r20
 3212508:	003fde06 	br	3212484 <__umoddi3+0xf8>
 321250c:	00bfffd4 	movui	r2,65535
 3212510:	11804036 	bltu	r2,r6,3212614 <__umoddi3+0x288>
 3212514:	00803fc4 	movi	r2,255
 3212518:	1180ed36 	bltu	r2,r6,32128d0 <__umoddi3+0x544>
 321251c:	000b883a 	mov	r5,zero
 3212520:	0005883a 	mov	r2,zero
 3212524:	8084d83a 	srl	r2,r16,r2
 3212528:	0100c974 	movhi	r4,805
 321252c:	21384b04 	addi	r4,r4,-7892
 3212530:	01800804 	movi	r6,32
 3212534:	1105883a 	add	r2,r2,r4
 3212538:	10c00003 	ldbu	r3,0(r2)
 321253c:	28c7883a 	add	r3,r5,r3
 3212540:	30c7c83a 	sub	r3,r6,r3
 3212544:	1800bf1e 	bne	r3,zero,3212844 <__umoddi3+0x4b8>
 3212548:	0039883a 	mov	fp,zero
 321254c:	802ad43a 	srli	r21,r16,16
 3212550:	a009883a 	mov	r4,r20
 3212554:	85ffffcc 	andi	r23,r16,65535
 3212558:	a80b883a 	mov	r5,r21
 321255c:	32044bc0 	call	32044bc <__udivsi3>
 3212560:	a009883a 	mov	r4,r20
 3212564:	a80b883a 	mov	r5,r21
 3212568:	b8a3383a 	mul	r17,r23,r2
 321256c:	32044c40 	call	32044c4 <__umodsi3>
 3212570:	1004943a 	slli	r2,r2,16
 3212574:	b006d43a 	srli	r3,r22,16
 3212578:	10c4b03a 	or	r2,r2,r3
 321257c:	1440032e 	bgeu	r2,r17,321258c <__umoddi3+0x200>
 3212580:	1405883a 	add	r2,r2,r16
 3212584:	14000136 	bltu	r2,r16,321258c <__umoddi3+0x200>
 3212588:	1440e536 	bltu	r2,r17,3212920 <__umoddi3+0x594>
 321258c:	1463c83a 	sub	r17,r2,r17
 3212590:	8809883a 	mov	r4,r17
 3212594:	a80b883a 	mov	r5,r21
 3212598:	32044bc0 	call	32044bc <__udivsi3>
 321259c:	8809883a 	mov	r4,r17
 32125a0:	b8a3383a 	mul	r17,r23,r2
 32125a4:	a80b883a 	mov	r5,r21
 32125a8:	32044c40 	call	32044c4 <__umodsi3>
 32125ac:	1004943a 	slli	r2,r2,16
 32125b0:	b0ffffcc 	andi	r3,r22,65535
 32125b4:	10c4b03a 	or	r2,r2,r3
 32125b8:	1440042e 	bgeu	r2,r17,32125cc <__umoddi3+0x240>
 32125bc:	1405883a 	add	r2,r2,r16
 32125c0:	14000236 	bltu	r2,r16,32125cc <__umoddi3+0x240>
 32125c4:	1440012e 	bgeu	r2,r17,32125cc <__umoddi3+0x240>
 32125c8:	1405883a 	add	r2,r2,r16
 32125cc:	1445c83a 	sub	r2,r2,r17
 32125d0:	1724d83a 	srl	r18,r2,fp
 32125d4:	0013883a 	mov	r9,zero
 32125d8:	9011883a 	mov	r8,r18
 32125dc:	003fa906 	br	3212484 <__umoddi3+0xf8>
 32125e0:	00804034 	movhi	r2,256
 32125e4:	10bfffc4 	addi	r2,r2,-1
 32125e8:	1400b036 	bltu	r2,r16,32128ac <__umoddi3+0x520>
 32125ec:	01400404 	movi	r5,16
 32125f0:	2805883a 	mov	r2,r5
 32125f4:	003f7c06 	br	32123e8 <__umoddi3+0x5c>
 32125f8:	01000044 	movi	r4,1
 32125fc:	000b883a 	mov	r5,zero
 3212600:	32044bc0 	call	32044bc <__udivsi3>
 3212604:	1021883a 	mov	r16,r2
 3212608:	00bfffd4 	movui	r2,65535
 321260c:	143ff436 	bltu	r2,r16,32125e0 <__umoddi3+0x254>
 3212610:	003f7106 	br	32123d8 <__umoddi3+0x4c>
 3212614:	00804034 	movhi	r2,256
 3212618:	10bfffc4 	addi	r2,r2,-1
 321261c:	1180af36 	bltu	r2,r6,32128dc <__umoddi3+0x550>
 3212620:	01400404 	movi	r5,16
 3212624:	2805883a 	mov	r2,r5
 3212628:	003fbe06 	br	3212524 <__umoddi3+0x198>
 321262c:	00804034 	movhi	r2,256
 3212630:	10bfffc4 	addi	r2,r2,-1
 3212634:	11c0ac36 	bltu	r2,r7,32128e8 <__umoddi3+0x55c>
 3212638:	01400404 	movi	r5,16
 321263c:	2805883a 	mov	r2,r5
 3212640:	003fa406 	br	32124d4 <__umoddi3+0x148>
 3212644:	b409c83a 	sub	r4,r22,r16
 3212648:	b105803a 	cmpltu	r2,r22,r4
 321264c:	a187c83a 	sub	r3,r20,r6
 3212650:	18a9c83a 	sub	r20,r3,r2
 3212654:	202d883a 	mov	r22,r4
 3212658:	003fa906 	br	3212500 <__umoddi3+0x174>
 321265c:	85e0983a 	sll	r16,r16,r23
 3212660:	35c5c83a 	sub	r2,r6,r23
 3212664:	a0a2d83a 	srl	r17,r20,r2
 3212668:	802ad43a 	srli	r21,r16,16
 321266c:	b084d83a 	srl	r2,r22,r2
 3212670:	a5c6983a 	sll	r3,r20,r23
 3212674:	8809883a 	mov	r4,r17
 3212678:	a80b883a 	mov	r5,r21
 321267c:	1886b03a 	or	r3,r3,r2
 3212680:	d8c00115 	stw	r3,4(sp)
 3212684:	853fffcc 	andi	r20,r16,65535
 3212688:	32044bc0 	call	32044bc <__udivsi3>
 321268c:	8809883a 	mov	r4,r17
 3212690:	a80b883a 	mov	r5,r21
 3212694:	a0a3383a 	mul	r17,r20,r2
 3212698:	32044c40 	call	32044c4 <__umodsi3>
 321269c:	d9000117 	ldw	r4,4(sp)
 32126a0:	1004943a 	slli	r2,r2,16
 32126a4:	b839883a 	mov	fp,r23
 32126a8:	2006d43a 	srli	r3,r4,16
 32126ac:	10c4b03a 	or	r2,r2,r3
 32126b0:	1440022e 	bgeu	r2,r17,32126bc <__umoddi3+0x330>
 32126b4:	1405883a 	add	r2,r2,r16
 32126b8:	1400962e 	bgeu	r2,r16,3212914 <__umoddi3+0x588>
 32126bc:	1463c83a 	sub	r17,r2,r17
 32126c0:	8809883a 	mov	r4,r17
 32126c4:	a80b883a 	mov	r5,r21
 32126c8:	32044bc0 	call	32044bc <__udivsi3>
 32126cc:	8809883a 	mov	r4,r17
 32126d0:	a80b883a 	mov	r5,r21
 32126d4:	a0a3383a 	mul	r17,r20,r2
 32126d8:	32044c40 	call	32044c4 <__umodsi3>
 32126dc:	d9400117 	ldw	r5,4(sp)
 32126e0:	1004943a 	slli	r2,r2,16
 32126e4:	28ffffcc 	andi	r3,r5,65535
 32126e8:	10c4b03a 	or	r2,r2,r3
 32126ec:	1440042e 	bgeu	r2,r17,3212700 <__umoddi3+0x374>
 32126f0:	1405883a 	add	r2,r2,r16
 32126f4:	14000236 	bltu	r2,r16,3212700 <__umoddi3+0x374>
 32126f8:	1440012e 	bgeu	r2,r17,3212700 <__umoddi3+0x374>
 32126fc:	1405883a 	add	r2,r2,r16
 3212700:	b5ec983a 	sll	r22,r22,r23
 3212704:	1463c83a 	sub	r17,r2,r17
 3212708:	003f4406 	br	321241c <__umoddi3+0x90>
 321270c:	3d4fc83a 	sub	r7,r7,r21
 3212710:	3546983a 	sll	r3,r6,r21
 3212714:	81c4d83a 	srl	r2,r16,r7
 3212718:	a1e2d83a 	srl	r17,r20,r7
 321271c:	a54c983a 	sll	r6,r20,r21
 3212720:	18aeb03a 	or	r23,r3,r2
 3212724:	b828d43a 	srli	r20,r23,16
 3212728:	b1c4d83a 	srl	r2,r22,r7
 321272c:	8809883a 	mov	r4,r17
 3212730:	a00b883a 	mov	r5,r20
 3212734:	308cb03a 	or	r6,r6,r2
 3212738:	d9c00315 	stw	r7,12(sp)
 321273c:	d9800215 	stw	r6,8(sp)
 3212740:	32044bc0 	call	32044bc <__udivsi3>
 3212744:	8809883a 	mov	r4,r17
 3212748:	a00b883a 	mov	r5,r20
 321274c:	1039883a 	mov	fp,r2
 3212750:	32044c40 	call	32044c4 <__umodsi3>
 3212754:	b8ffffcc 	andi	r3,r23,65535
 3212758:	d8c00415 	stw	r3,16(sp)
 321275c:	d9000217 	ldw	r4,8(sp)
 3212760:	d9400417 	ldw	r5,16(sp)
 3212764:	1004943a 	slli	r2,r2,16
 3212768:	2006d43a 	srli	r3,r4,16
 321276c:	8560983a 	sll	r16,r16,r21
 3212770:	2f23383a 	mul	r17,r5,fp
 3212774:	10c4b03a 	or	r2,r2,r3
 3212778:	dc000015 	stw	r16,0(sp)
 321277c:	b56c983a 	sll	r22,r22,r21
 3212780:	1440032e 	bgeu	r2,r17,3212790 <__umoddi3+0x404>
 3212784:	15c5883a 	add	r2,r2,r23
 3212788:	e73fffc4 	addi	fp,fp,-1
 321278c:	15c05d2e 	bgeu	r2,r23,3212904 <__umoddi3+0x578>
 3212790:	1463c83a 	sub	r17,r2,r17
 3212794:	8809883a 	mov	r4,r17
 3212798:	a00b883a 	mov	r5,r20
 321279c:	32044bc0 	call	32044bc <__udivsi3>
 32127a0:	8809883a 	mov	r4,r17
 32127a4:	a00b883a 	mov	r5,r20
 32127a8:	1021883a 	mov	r16,r2
 32127ac:	32044c40 	call	32044c4 <__umodsi3>
 32127b0:	d8c00417 	ldw	r3,16(sp)
 32127b4:	d9000217 	ldw	r4,8(sp)
 32127b8:	1004943a 	slli	r2,r2,16
 32127bc:	1c23383a 	mul	r17,r3,r16
 32127c0:	20ffffcc 	andi	r3,r4,65535
 32127c4:	10ceb03a 	or	r7,r2,r3
 32127c8:	3c40032e 	bgeu	r7,r17,32127d8 <__umoddi3+0x44c>
 32127cc:	3dcf883a 	add	r7,r7,r23
 32127d0:	843fffc4 	addi	r16,r16,-1
 32127d4:	3dc0472e 	bgeu	r7,r23,32128f4 <__umoddi3+0x568>
 32127d8:	e004943a 	slli	r2,fp,16
 32127dc:	d9400017 	ldw	r5,0(sp)
 32127e0:	3c4fc83a 	sub	r7,r7,r17
 32127e4:	8084b03a 	or	r2,r16,r2
 32127e8:	28ffffcc 	andi	r3,r5,65535
 32127ec:	280cd43a 	srli	r6,r5,16
 32127f0:	100ad43a 	srli	r5,r2,16
 32127f4:	10bfffcc 	andi	r2,r2,65535
 32127f8:	10d1383a 	mul	r8,r2,r3
 32127fc:	28c7383a 	mul	r3,r5,r3
 3212800:	1185383a 	mul	r2,r2,r6
 3212804:	4008d43a 	srli	r4,r8,16
 3212808:	298b383a 	mul	r5,r5,r6
 321280c:	10c5883a 	add	r2,r2,r3
 3212810:	2089883a 	add	r4,r4,r2
 3212814:	20c0022e 	bgeu	r4,r3,3212820 <__umoddi3+0x494>
 3212818:	00800074 	movhi	r2,1
 321281c:	288b883a 	add	r5,r5,r2
 3212820:	2004d43a 	srli	r2,r4,16
 3212824:	2008943a 	slli	r4,r4,16
 3212828:	40ffffcc 	andi	r3,r8,65535
 321282c:	288b883a 	add	r5,r5,r2
 3212830:	20c9883a 	add	r4,r4,r3
 3212834:	39400b36 	bltu	r7,r5,3212864 <__umoddi3+0x4d8>
 3212838:	39403d26 	beq	r7,r5,3212930 <__umoddi3+0x5a4>
 321283c:	394bc83a 	sub	r5,r7,r5
 3212840:	00000f06 	br	3212880 <__umoddi3+0x4f4>
 3212844:	30c5c83a 	sub	r2,r6,r3
 3212848:	1839883a 	mov	fp,r3
 321284c:	b084d83a 	srl	r2,r22,r2
 3212850:	a0c6983a 	sll	r3,r20,r3
 3212854:	8720983a 	sll	r16,r16,fp
 3212858:	b72c983a 	sll	r22,r22,fp
 321285c:	18a8b03a 	or	r20,r3,r2
 3212860:	003f3a06 	br	321254c <__umoddi3+0x1c0>
 3212864:	d8c00017 	ldw	r3,0(sp)
 3212868:	20c5c83a 	sub	r2,r4,r3
 321286c:	2089803a 	cmpltu	r4,r4,r2
 3212870:	2dc7c83a 	sub	r3,r5,r23
 3212874:	1907c83a 	sub	r3,r3,r4
 3212878:	38cbc83a 	sub	r5,r7,r3
 321287c:	1009883a 	mov	r4,r2
 3212880:	b105c83a 	sub	r2,r22,r4
 3212884:	b087803a 	cmpltu	r3,r22,r2
 3212888:	28c7c83a 	sub	r3,r5,r3
 321288c:	d9400317 	ldw	r5,12(sp)
 3212890:	1544d83a 	srl	r2,r2,r21
 3212894:	1948983a 	sll	r4,r3,r5
 3212898:	1d46d83a 	srl	r3,r3,r21
 321289c:	20a4b03a 	or	r18,r4,r2
 32128a0:	9011883a 	mov	r8,r18
 32128a4:	1813883a 	mov	r9,r3
 32128a8:	003ef606 	br	3212484 <__umoddi3+0xf8>
 32128ac:	01400604 	movi	r5,24
 32128b0:	2805883a 	mov	r2,r5
 32128b4:	003ecc06 	br	32123e8 <__umoddi3+0x5c>
 32128b8:	01400204 	movi	r5,8
 32128bc:	2805883a 	mov	r2,r5
 32128c0:	003ec906 	br	32123e8 <__umoddi3+0x5c>
 32128c4:	01400204 	movi	r5,8
 32128c8:	2805883a 	mov	r2,r5
 32128cc:	003f0106 	br	32124d4 <__umoddi3+0x148>
 32128d0:	01400204 	movi	r5,8
 32128d4:	2805883a 	mov	r2,r5
 32128d8:	003f1206 	br	3212524 <__umoddi3+0x198>
 32128dc:	01400604 	movi	r5,24
 32128e0:	2805883a 	mov	r2,r5
 32128e4:	003f0f06 	br	3212524 <__umoddi3+0x198>
 32128e8:	01400604 	movi	r5,24
 32128ec:	2805883a 	mov	r2,r5
 32128f0:	003ef806 	br	32124d4 <__umoddi3+0x148>
 32128f4:	3c7fb82e 	bgeu	r7,r17,32127d8 <__umoddi3+0x44c>
 32128f8:	843fffc4 	addi	r16,r16,-1
 32128fc:	3dcf883a 	add	r7,r7,r23
 3212900:	003fb506 	br	32127d8 <__umoddi3+0x44c>
 3212904:	147fa22e 	bgeu	r2,r17,3212790 <__umoddi3+0x404>
 3212908:	e73fffc4 	addi	fp,fp,-1
 321290c:	15c5883a 	add	r2,r2,r23
 3212910:	003f9f06 	br	3212790 <__umoddi3+0x404>
 3212914:	147f692e 	bgeu	r2,r17,32126bc <__umoddi3+0x330>
 3212918:	1405883a 	add	r2,r2,r16
 321291c:	003f6706 	br	32126bc <__umoddi3+0x330>
 3212920:	1405883a 	add	r2,r2,r16
 3212924:	003f1906 	br	321258c <__umoddi3+0x200>
 3212928:	1405883a 	add	r2,r2,r16
 321292c:	003ec906 	br	3212454 <__umoddi3+0xc8>
 3212930:	b13fcc36 	bltu	r22,r4,3212864 <__umoddi3+0x4d8>
 3212934:	000b883a 	mov	r5,zero
 3212938:	003fd106 	br	3212880 <__umoddi3+0x4f4>

0321293c <__nesf2>:
 321293c:	defff304 	addi	sp,sp,-52
 3212940:	dc400b15 	stw	r17,44(sp)
 3212944:	dc400204 	addi	r17,sp,8
 3212948:	dc000a15 	stw	r16,40(sp)
 321294c:	d9000015 	stw	r4,0(sp)
 3212950:	d9400115 	stw	r5,4(sp)
 3212954:	d809883a 	mov	r4,sp
 3212958:	880b883a 	mov	r5,r17
 321295c:	dc000604 	addi	r16,sp,24
 3212960:	dfc00c15 	stw	ra,48(sp)
 3212964:	3213d4c0 	call	3213d4c <__unpack_f>
 3212968:	d9000104 	addi	r4,sp,4
 321296c:	800b883a 	mov	r5,r16
 3212970:	3213d4c0 	call	3213d4c <__unpack_f>
 3212974:	d8800217 	ldw	r2,8(sp)
 3212978:	00c00044 	movi	r3,1
 321297c:	180d883a 	mov	r6,r3
 3212980:	1880062e 	bgeu	r3,r2,321299c <__nesf2+0x60>
 3212984:	d8800617 	ldw	r2,24(sp)
 3212988:	8809883a 	mov	r4,r17
 321298c:	800b883a 	mov	r5,r16
 3212990:	1880022e 	bgeu	r3,r2,321299c <__nesf2+0x60>
 3212994:	3213e140 	call	3213e14 <__fpcmp_parts_f>
 3212998:	100d883a 	mov	r6,r2
 321299c:	3005883a 	mov	r2,r6
 32129a0:	dfc00c17 	ldw	ra,48(sp)
 32129a4:	dc400b17 	ldw	r17,44(sp)
 32129a8:	dc000a17 	ldw	r16,40(sp)
 32129ac:	dec00d04 	addi	sp,sp,52
 32129b0:	f800283a 	ret

032129b4 <__gtsf2>:
 32129b4:	defff304 	addi	sp,sp,-52
 32129b8:	dc400b15 	stw	r17,44(sp)
 32129bc:	dc400204 	addi	r17,sp,8
 32129c0:	dc000a15 	stw	r16,40(sp)
 32129c4:	d9000015 	stw	r4,0(sp)
 32129c8:	d9400115 	stw	r5,4(sp)
 32129cc:	d809883a 	mov	r4,sp
 32129d0:	880b883a 	mov	r5,r17
 32129d4:	dc000604 	addi	r16,sp,24
 32129d8:	dfc00c15 	stw	ra,48(sp)
 32129dc:	3213d4c0 	call	3213d4c <__unpack_f>
 32129e0:	d9000104 	addi	r4,sp,4
 32129e4:	800b883a 	mov	r5,r16
 32129e8:	3213d4c0 	call	3213d4c <__unpack_f>
 32129ec:	d8800217 	ldw	r2,8(sp)
 32129f0:	00c00044 	movi	r3,1
 32129f4:	01bfffc4 	movi	r6,-1
 32129f8:	1880062e 	bgeu	r3,r2,3212a14 <__gtsf2+0x60>
 32129fc:	d8800617 	ldw	r2,24(sp)
 3212a00:	8809883a 	mov	r4,r17
 3212a04:	800b883a 	mov	r5,r16
 3212a08:	1880022e 	bgeu	r3,r2,3212a14 <__gtsf2+0x60>
 3212a0c:	3213e140 	call	3213e14 <__fpcmp_parts_f>
 3212a10:	100d883a 	mov	r6,r2
 3212a14:	3005883a 	mov	r2,r6
 3212a18:	dfc00c17 	ldw	ra,48(sp)
 3212a1c:	dc400b17 	ldw	r17,44(sp)
 3212a20:	dc000a17 	ldw	r16,40(sp)
 3212a24:	dec00d04 	addi	sp,sp,52
 3212a28:	f800283a 	ret

03212a2c <__ltsf2>:
 3212a2c:	defff304 	addi	sp,sp,-52
 3212a30:	dc400b15 	stw	r17,44(sp)
 3212a34:	dc400204 	addi	r17,sp,8
 3212a38:	dc000a15 	stw	r16,40(sp)
 3212a3c:	d9000015 	stw	r4,0(sp)
 3212a40:	d9400115 	stw	r5,4(sp)
 3212a44:	d809883a 	mov	r4,sp
 3212a48:	880b883a 	mov	r5,r17
 3212a4c:	dc000604 	addi	r16,sp,24
 3212a50:	dfc00c15 	stw	ra,48(sp)
 3212a54:	3213d4c0 	call	3213d4c <__unpack_f>
 3212a58:	d9000104 	addi	r4,sp,4
 3212a5c:	800b883a 	mov	r5,r16
 3212a60:	3213d4c0 	call	3213d4c <__unpack_f>
 3212a64:	d8800217 	ldw	r2,8(sp)
 3212a68:	00c00044 	movi	r3,1
 3212a6c:	180d883a 	mov	r6,r3
 3212a70:	1880062e 	bgeu	r3,r2,3212a8c <__ltsf2+0x60>
 3212a74:	d8800617 	ldw	r2,24(sp)
 3212a78:	8809883a 	mov	r4,r17
 3212a7c:	800b883a 	mov	r5,r16
 3212a80:	1880022e 	bgeu	r3,r2,3212a8c <__ltsf2+0x60>
 3212a84:	3213e140 	call	3213e14 <__fpcmp_parts_f>
 3212a88:	100d883a 	mov	r6,r2
 3212a8c:	3005883a 	mov	r2,r6
 3212a90:	dfc00c17 	ldw	ra,48(sp)
 3212a94:	dc400b17 	ldw	r17,44(sp)
 3212a98:	dc000a17 	ldw	r16,40(sp)
 3212a9c:	dec00d04 	addi	sp,sp,52
 3212aa0:	f800283a 	ret

03212aa4 <_fpadd_parts>:
 3212aa4:	defff804 	addi	sp,sp,-32
 3212aa8:	dcc00315 	stw	r19,12(sp)
 3212aac:	2027883a 	mov	r19,r4
 3212ab0:	21000017 	ldw	r4,0(r4)
 3212ab4:	00c00044 	movi	r3,1
 3212ab8:	dd400515 	stw	r21,20(sp)
 3212abc:	dd000415 	stw	r20,16(sp)
 3212ac0:	ddc00715 	stw	r23,28(sp)
 3212ac4:	dd800615 	stw	r22,24(sp)
 3212ac8:	dc800215 	stw	r18,8(sp)
 3212acc:	dc400115 	stw	r17,4(sp)
 3212ad0:	dc000015 	stw	r16,0(sp)
 3212ad4:	282b883a 	mov	r21,r5
 3212ad8:	3029883a 	mov	r20,r6
 3212adc:	1900632e 	bgeu	r3,r4,3212c6c <_fpadd_parts+0x1c8>
 3212ae0:	28800017 	ldw	r2,0(r5)
 3212ae4:	1880812e 	bgeu	r3,r2,3212cec <_fpadd_parts+0x248>
 3212ae8:	00c00104 	movi	r3,4
 3212aec:	20c0dc26 	beq	r4,r3,3212e60 <_fpadd_parts+0x3bc>
 3212af0:	10c07e26 	beq	r2,r3,3212cec <_fpadd_parts+0x248>
 3212af4:	00c00084 	movi	r3,2
 3212af8:	10c06726 	beq	r2,r3,3212c98 <_fpadd_parts+0x1f4>
 3212afc:	20c07b26 	beq	r4,r3,3212cec <_fpadd_parts+0x248>
 3212b00:	9dc00217 	ldw	r23,8(r19)
 3212b04:	28c00217 	ldw	r3,8(r5)
 3212b08:	9c400317 	ldw	r17,12(r19)
 3212b0c:	2bc00317 	ldw	r15,12(r5)
 3212b10:	b8cdc83a 	sub	r6,r23,r3
 3212b14:	9c800417 	ldw	r18,16(r19)
 3212b18:	2c000417 	ldw	r16,16(r5)
 3212b1c:	3009883a 	mov	r4,r6
 3212b20:	30009716 	blt	r6,zero,3212d80 <_fpadd_parts+0x2dc>
 3212b24:	00800fc4 	movi	r2,63
 3212b28:	11806b16 	blt	r2,r6,3212cd8 <_fpadd_parts+0x234>
 3212b2c:	0100a40e 	bge	zero,r4,3212dc0 <_fpadd_parts+0x31c>
 3212b30:	35bff804 	addi	r22,r6,-32
 3212b34:	b000bc16 	blt	r22,zero,3212e28 <_fpadd_parts+0x384>
 3212b38:	8596d83a 	srl	r11,r16,r22
 3212b3c:	0019883a 	mov	r12,zero
 3212b40:	0013883a 	mov	r9,zero
 3212b44:	01000044 	movi	r4,1
 3212b48:	0015883a 	mov	r10,zero
 3212b4c:	b000be16 	blt	r22,zero,3212e48 <_fpadd_parts+0x3a4>
 3212b50:	2590983a 	sll	r8,r4,r22
 3212b54:	000f883a 	mov	r7,zero
 3212b58:	00bfffc4 	movi	r2,-1
 3212b5c:	3889883a 	add	r4,r7,r2
 3212b60:	408b883a 	add	r5,r8,r2
 3212b64:	21cd803a 	cmpltu	r6,r4,r7
 3212b68:	314b883a 	add	r5,r6,r5
 3212b6c:	7904703a 	and	r2,r15,r4
 3212b70:	8146703a 	and	r3,r16,r5
 3212b74:	10c4b03a 	or	r2,r2,r3
 3212b78:	10000226 	beq	r2,zero,3212b84 <_fpadd_parts+0xe0>
 3212b7c:	02400044 	movi	r9,1
 3212b80:	0015883a 	mov	r10,zero
 3212b84:	5a5eb03a 	or	r15,r11,r9
 3212b88:	62a0b03a 	or	r16,r12,r10
 3212b8c:	99400117 	ldw	r5,4(r19)
 3212b90:	a8800117 	ldw	r2,4(r21)
 3212b94:	28806e26 	beq	r5,r2,3212d50 <_fpadd_parts+0x2ac>
 3212b98:	28006626 	beq	r5,zero,3212d34 <_fpadd_parts+0x290>
 3212b9c:	7c45c83a 	sub	r2,r15,r17
 3212ba0:	7889803a 	cmpltu	r4,r15,r2
 3212ba4:	8487c83a 	sub	r3,r16,r18
 3212ba8:	1909c83a 	sub	r4,r3,r4
 3212bac:	100d883a 	mov	r6,r2
 3212bb0:	200f883a 	mov	r7,r4
 3212bb4:	38007716 	blt	r7,zero,3212d94 <_fpadd_parts+0x2f0>
 3212bb8:	a5c00215 	stw	r23,8(r20)
 3212bbc:	a1c00415 	stw	r7,16(r20)
 3212bc0:	a0000115 	stw	zero,4(r20)
 3212bc4:	a1800315 	stw	r6,12(r20)
 3212bc8:	a2000317 	ldw	r8,12(r20)
 3212bcc:	a2400417 	ldw	r9,16(r20)
 3212bd0:	00bfffc4 	movi	r2,-1
 3212bd4:	408b883a 	add	r5,r8,r2
 3212bd8:	2a09803a 	cmpltu	r4,r5,r8
 3212bdc:	488d883a 	add	r6,r9,r2
 3212be0:	01c40034 	movhi	r7,4096
 3212be4:	39ffffc4 	addi	r7,r7,-1
 3212be8:	218d883a 	add	r6,r4,r6
 3212bec:	39801736 	bltu	r7,r6,3212c4c <_fpadd_parts+0x1a8>
 3212bf0:	31c06526 	beq	r6,r7,3212d88 <_fpadd_parts+0x2e4>
 3212bf4:	a3000217 	ldw	r12,8(r20)
 3212bf8:	4209883a 	add	r4,r8,r8
 3212bfc:	00bfffc4 	movi	r2,-1
 3212c00:	220f803a 	cmpltu	r7,r4,r8
 3212c04:	4a4b883a 	add	r5,r9,r9
 3212c08:	394f883a 	add	r7,r7,r5
 3212c0c:	2095883a 	add	r10,r4,r2
 3212c10:	3897883a 	add	r11,r7,r2
 3212c14:	510d803a 	cmpltu	r6,r10,r4
 3212c18:	6099883a 	add	r12,r12,r2
 3212c1c:	32d7883a 	add	r11,r6,r11
 3212c20:	00840034 	movhi	r2,4096
 3212c24:	10bfffc4 	addi	r2,r2,-1
 3212c28:	2011883a 	mov	r8,r4
 3212c2c:	3813883a 	mov	r9,r7
 3212c30:	a1000315 	stw	r4,12(r20)
 3212c34:	a1c00415 	stw	r7,16(r20)
 3212c38:	a3000215 	stw	r12,8(r20)
 3212c3c:	12c00336 	bltu	r2,r11,3212c4c <_fpadd_parts+0x1a8>
 3212c40:	58bfed1e 	bne	r11,r2,3212bf8 <_fpadd_parts+0x154>
 3212c44:	00bfff84 	movi	r2,-2
 3212c48:	12bfeb2e 	bgeu	r2,r10,3212bf8 <_fpadd_parts+0x154>
 3212c4c:	a2800417 	ldw	r10,16(r20)
 3212c50:	008000c4 	movi	r2,3
 3212c54:	00c80034 	movhi	r3,8192
 3212c58:	18ffffc4 	addi	r3,r3,-1
 3212c5c:	a2400317 	ldw	r9,12(r20)
 3212c60:	a0800015 	stw	r2,0(r20)
 3212c64:	1a802336 	bltu	r3,r10,3212cf4 <_fpadd_parts+0x250>
 3212c68:	a027883a 	mov	r19,r20
 3212c6c:	9805883a 	mov	r2,r19
 3212c70:	ddc00717 	ldw	r23,28(sp)
 3212c74:	dd800617 	ldw	r22,24(sp)
 3212c78:	dd400517 	ldw	r21,20(sp)
 3212c7c:	dd000417 	ldw	r20,16(sp)
 3212c80:	dcc00317 	ldw	r19,12(sp)
 3212c84:	dc800217 	ldw	r18,8(sp)
 3212c88:	dc400117 	ldw	r17,4(sp)
 3212c8c:	dc000017 	ldw	r16,0(sp)
 3212c90:	dec00804 	addi	sp,sp,32
 3212c94:	f800283a 	ret
 3212c98:	20fff41e 	bne	r4,r3,3212c6c <_fpadd_parts+0x1c8>
 3212c9c:	31000015 	stw	r4,0(r6)
 3212ca0:	98800117 	ldw	r2,4(r19)
 3212ca4:	30800115 	stw	r2,4(r6)
 3212ca8:	98c00217 	ldw	r3,8(r19)
 3212cac:	30c00215 	stw	r3,8(r6)
 3212cb0:	98800317 	ldw	r2,12(r19)
 3212cb4:	30800315 	stw	r2,12(r6)
 3212cb8:	98c00417 	ldw	r3,16(r19)
 3212cbc:	30c00415 	stw	r3,16(r6)
 3212cc0:	98800117 	ldw	r2,4(r19)
 3212cc4:	28c00117 	ldw	r3,4(r5)
 3212cc8:	3027883a 	mov	r19,r6
 3212ccc:	10c4703a 	and	r2,r2,r3
 3212cd0:	30800115 	stw	r2,4(r6)
 3212cd4:	003fe506 	br	3212c6c <_fpadd_parts+0x1c8>
 3212cd8:	1dc02616 	blt	r3,r23,3212d74 <_fpadd_parts+0x2d0>
 3212cdc:	0023883a 	mov	r17,zero
 3212ce0:	182f883a 	mov	r23,r3
 3212ce4:	0025883a 	mov	r18,zero
 3212ce8:	003fa806 	br	3212b8c <_fpadd_parts+0xe8>
 3212cec:	a827883a 	mov	r19,r21
 3212cf0:	003fde06 	br	3212c6c <_fpadd_parts+0x1c8>
 3212cf4:	01800044 	movi	r6,1
 3212cf8:	500497fa 	slli	r2,r10,31
 3212cfc:	4808d07a 	srli	r4,r9,1
 3212d00:	518ad83a 	srl	r5,r10,r6
 3212d04:	a2000217 	ldw	r8,8(r20)
 3212d08:	1108b03a 	or	r4,r2,r4
 3212d0c:	0007883a 	mov	r3,zero
 3212d10:	4984703a 	and	r2,r9,r6
 3212d14:	208cb03a 	or	r6,r4,r2
 3212d18:	28ceb03a 	or	r7,r5,r3
 3212d1c:	42000044 	addi	r8,r8,1
 3212d20:	a027883a 	mov	r19,r20
 3212d24:	a1c00415 	stw	r7,16(r20)
 3212d28:	a2000215 	stw	r8,8(r20)
 3212d2c:	a1800315 	stw	r6,12(r20)
 3212d30:	003fce06 	br	3212c6c <_fpadd_parts+0x1c8>
 3212d34:	8bc5c83a 	sub	r2,r17,r15
 3212d38:	8889803a 	cmpltu	r4,r17,r2
 3212d3c:	9407c83a 	sub	r3,r18,r16
 3212d40:	1909c83a 	sub	r4,r3,r4
 3212d44:	100d883a 	mov	r6,r2
 3212d48:	200f883a 	mov	r7,r4
 3212d4c:	003f9906 	br	3212bb4 <_fpadd_parts+0x110>
 3212d50:	8bc5883a 	add	r2,r17,r15
 3212d54:	1449803a 	cmpltu	r4,r2,r17
 3212d58:	9407883a 	add	r3,r18,r16
 3212d5c:	20c9883a 	add	r4,r4,r3
 3212d60:	a1400115 	stw	r5,4(r20)
 3212d64:	a5c00215 	stw	r23,8(r20)
 3212d68:	a0800315 	stw	r2,12(r20)
 3212d6c:	a1000415 	stw	r4,16(r20)
 3212d70:	003fb606 	br	3212c4c <_fpadd_parts+0x1a8>
 3212d74:	001f883a 	mov	r15,zero
 3212d78:	0021883a 	mov	r16,zero
 3212d7c:	003f8306 	br	3212b8c <_fpadd_parts+0xe8>
 3212d80:	018dc83a 	sub	r6,zero,r6
 3212d84:	003f6706 	br	3212b24 <_fpadd_parts+0x80>
 3212d88:	00bfff84 	movi	r2,-2
 3212d8c:	117faf36 	bltu	r2,r5,3212c4c <_fpadd_parts+0x1a8>
 3212d90:	003f9806 	br	3212bf4 <_fpadd_parts+0x150>
 3212d94:	0005883a 	mov	r2,zero
 3212d98:	1189c83a 	sub	r4,r2,r6
 3212d9c:	1105803a 	cmpltu	r2,r2,r4
 3212da0:	01cbc83a 	sub	r5,zero,r7
 3212da4:	2885c83a 	sub	r2,r5,r2
 3212da8:	01800044 	movi	r6,1
 3212dac:	a1800115 	stw	r6,4(r20)
 3212db0:	a5c00215 	stw	r23,8(r20)
 3212db4:	a1000315 	stw	r4,12(r20)
 3212db8:	a0800415 	stw	r2,16(r20)
 3212dbc:	003f8206 	br	3212bc8 <_fpadd_parts+0x124>
 3212dc0:	203f7226 	beq	r4,zero,3212b8c <_fpadd_parts+0xe8>
 3212dc4:	35bff804 	addi	r22,r6,-32
 3212dc8:	b9af883a 	add	r23,r23,r6
 3212dcc:	b0003116 	blt	r22,zero,3212e94 <_fpadd_parts+0x3f0>
 3212dd0:	959ad83a 	srl	r13,r18,r22
 3212dd4:	001d883a 	mov	r14,zero
 3212dd8:	000f883a 	mov	r7,zero
 3212ddc:	01000044 	movi	r4,1
 3212de0:	0011883a 	mov	r8,zero
 3212de4:	b0002516 	blt	r22,zero,3212e7c <_fpadd_parts+0x3d8>
 3212de8:	2594983a 	sll	r10,r4,r22
 3212dec:	0013883a 	mov	r9,zero
 3212df0:	00bfffc4 	movi	r2,-1
 3212df4:	4889883a 	add	r4,r9,r2
 3212df8:	508b883a 	add	r5,r10,r2
 3212dfc:	224d803a 	cmpltu	r6,r4,r9
 3212e00:	314b883a 	add	r5,r6,r5
 3212e04:	8904703a 	and	r2,r17,r4
 3212e08:	9146703a 	and	r3,r18,r5
 3212e0c:	10c4b03a 	or	r2,r2,r3
 3212e10:	10000226 	beq	r2,zero,3212e1c <_fpadd_parts+0x378>
 3212e14:	01c00044 	movi	r7,1
 3212e18:	0011883a 	mov	r8,zero
 3212e1c:	69e2b03a 	or	r17,r13,r7
 3212e20:	7224b03a 	or	r18,r14,r8
 3212e24:	003f5906 	br	3212b8c <_fpadd_parts+0xe8>
 3212e28:	8407883a 	add	r3,r16,r16
 3212e2c:	008007c4 	movi	r2,31
 3212e30:	1185c83a 	sub	r2,r2,r6
 3212e34:	1886983a 	sll	r3,r3,r2
 3212e38:	7996d83a 	srl	r11,r15,r6
 3212e3c:	8198d83a 	srl	r12,r16,r6
 3212e40:	1ad6b03a 	or	r11,r3,r11
 3212e44:	003f3e06 	br	3212b40 <_fpadd_parts+0x9c>
 3212e48:	2006d07a 	srli	r3,r4,1
 3212e4c:	008007c4 	movi	r2,31
 3212e50:	1185c83a 	sub	r2,r2,r6
 3212e54:	1890d83a 	srl	r8,r3,r2
 3212e58:	218e983a 	sll	r7,r4,r6
 3212e5c:	003f3e06 	br	3212b58 <_fpadd_parts+0xb4>
 3212e60:	113f821e 	bne	r2,r4,3212c6c <_fpadd_parts+0x1c8>
 3212e64:	28c00117 	ldw	r3,4(r5)
 3212e68:	98800117 	ldw	r2,4(r19)
 3212e6c:	10ff7f26 	beq	r2,r3,3212c6c <_fpadd_parts+0x1c8>
 3212e70:	04c0c974 	movhi	r19,805
 3212e74:	9cf84604 	addi	r19,r19,-7912
 3212e78:	003f7c06 	br	3212c6c <_fpadd_parts+0x1c8>
 3212e7c:	2006d07a 	srli	r3,r4,1
 3212e80:	008007c4 	movi	r2,31
 3212e84:	1185c83a 	sub	r2,r2,r6
 3212e88:	1894d83a 	srl	r10,r3,r2
 3212e8c:	2192983a 	sll	r9,r4,r6
 3212e90:	003fd706 	br	3212df0 <_fpadd_parts+0x34c>
 3212e94:	9487883a 	add	r3,r18,r18
 3212e98:	008007c4 	movi	r2,31
 3212e9c:	1185c83a 	sub	r2,r2,r6
 3212ea0:	1886983a 	sll	r3,r3,r2
 3212ea4:	899ad83a 	srl	r13,r17,r6
 3212ea8:	919cd83a 	srl	r14,r18,r6
 3212eac:	1b5ab03a 	or	r13,r3,r13
 3212eb0:	003fc906 	br	3212dd8 <_fpadd_parts+0x334>

03212eb4 <__subdf3>:
 3212eb4:	deffea04 	addi	sp,sp,-88
 3212eb8:	dcc01415 	stw	r19,80(sp)
 3212ebc:	dcc00404 	addi	r19,sp,16
 3212ec0:	2011883a 	mov	r8,r4
 3212ec4:	2813883a 	mov	r9,r5
 3212ec8:	dc401315 	stw	r17,76(sp)
 3212ecc:	d809883a 	mov	r4,sp
 3212ed0:	980b883a 	mov	r5,r19
 3212ed4:	dc400904 	addi	r17,sp,36
 3212ed8:	dfc01515 	stw	ra,84(sp)
 3212edc:	da400115 	stw	r9,4(sp)
 3212ee0:	d9c00315 	stw	r7,12(sp)
 3212ee4:	da000015 	stw	r8,0(sp)
 3212ee8:	d9800215 	stw	r6,8(sp)
 3212eec:	32141fc0 	call	32141fc <__unpack_d>
 3212ef0:	d9000204 	addi	r4,sp,8
 3212ef4:	880b883a 	mov	r5,r17
 3212ef8:	32141fc0 	call	32141fc <__unpack_d>
 3212efc:	d8800a17 	ldw	r2,40(sp)
 3212f00:	880b883a 	mov	r5,r17
 3212f04:	9809883a 	mov	r4,r19
 3212f08:	d9800e04 	addi	r6,sp,56
 3212f0c:	1080005c 	xori	r2,r2,1
 3212f10:	d8800a15 	stw	r2,40(sp)
 3212f14:	3212aa40 	call	3212aa4 <_fpadd_parts>
 3212f18:	1009883a 	mov	r4,r2
 3212f1c:	3213ee80 	call	3213ee8 <__pack_d>
 3212f20:	dfc01517 	ldw	ra,84(sp)
 3212f24:	dcc01417 	ldw	r19,80(sp)
 3212f28:	dc401317 	ldw	r17,76(sp)
 3212f2c:	dec01604 	addi	sp,sp,88
 3212f30:	f800283a 	ret

03212f34 <__adddf3>:
 3212f34:	deffea04 	addi	sp,sp,-88
 3212f38:	dcc01415 	stw	r19,80(sp)
 3212f3c:	dcc00404 	addi	r19,sp,16
 3212f40:	2011883a 	mov	r8,r4
 3212f44:	2813883a 	mov	r9,r5
 3212f48:	dc401315 	stw	r17,76(sp)
 3212f4c:	d809883a 	mov	r4,sp
 3212f50:	980b883a 	mov	r5,r19
 3212f54:	dc400904 	addi	r17,sp,36
 3212f58:	dfc01515 	stw	ra,84(sp)
 3212f5c:	da400115 	stw	r9,4(sp)
 3212f60:	d9c00315 	stw	r7,12(sp)
 3212f64:	da000015 	stw	r8,0(sp)
 3212f68:	d9800215 	stw	r6,8(sp)
 3212f6c:	32141fc0 	call	32141fc <__unpack_d>
 3212f70:	d9000204 	addi	r4,sp,8
 3212f74:	880b883a 	mov	r5,r17
 3212f78:	32141fc0 	call	32141fc <__unpack_d>
 3212f7c:	d9800e04 	addi	r6,sp,56
 3212f80:	9809883a 	mov	r4,r19
 3212f84:	880b883a 	mov	r5,r17
 3212f88:	3212aa40 	call	3212aa4 <_fpadd_parts>
 3212f8c:	1009883a 	mov	r4,r2
 3212f90:	3213ee80 	call	3213ee8 <__pack_d>
 3212f94:	dfc01517 	ldw	ra,84(sp)
 3212f98:	dcc01417 	ldw	r19,80(sp)
 3212f9c:	dc401317 	ldw	r17,76(sp)
 3212fa0:	dec01604 	addi	sp,sp,88
 3212fa4:	f800283a 	ret

03212fa8 <__muldf3>:
 3212fa8:	deffe004 	addi	sp,sp,-128
 3212fac:	dc401815 	stw	r17,96(sp)
 3212fb0:	dc400404 	addi	r17,sp,16
 3212fb4:	2011883a 	mov	r8,r4
 3212fb8:	2813883a 	mov	r9,r5
 3212fbc:	dc001715 	stw	r16,92(sp)
 3212fc0:	d809883a 	mov	r4,sp
 3212fc4:	880b883a 	mov	r5,r17
 3212fc8:	dc000904 	addi	r16,sp,36
 3212fcc:	dfc01f15 	stw	ra,124(sp)
 3212fd0:	da400115 	stw	r9,4(sp)
 3212fd4:	d9c00315 	stw	r7,12(sp)
 3212fd8:	da000015 	stw	r8,0(sp)
 3212fdc:	d9800215 	stw	r6,8(sp)
 3212fe0:	ddc01e15 	stw	r23,120(sp)
 3212fe4:	dd801d15 	stw	r22,116(sp)
 3212fe8:	dd401c15 	stw	r21,112(sp)
 3212fec:	dd001b15 	stw	r20,108(sp)
 3212ff0:	dcc01a15 	stw	r19,104(sp)
 3212ff4:	dc801915 	stw	r18,100(sp)
 3212ff8:	32141fc0 	call	32141fc <__unpack_d>
 3212ffc:	d9000204 	addi	r4,sp,8
 3213000:	800b883a 	mov	r5,r16
 3213004:	32141fc0 	call	32141fc <__unpack_d>
 3213008:	d9000417 	ldw	r4,16(sp)
 321300c:	00800044 	movi	r2,1
 3213010:	1100102e 	bgeu	r2,r4,3213054 <__muldf3+0xac>
 3213014:	d8c00917 	ldw	r3,36(sp)
 3213018:	10c0062e 	bgeu	r2,r3,3213034 <__muldf3+0x8c>
 321301c:	00800104 	movi	r2,4
 3213020:	20800a26 	beq	r4,r2,321304c <__muldf3+0xa4>
 3213024:	1880cc26 	beq	r3,r2,3213358 <__muldf3+0x3b0>
 3213028:	00800084 	movi	r2,2
 321302c:	20800926 	beq	r4,r2,3213054 <__muldf3+0xac>
 3213030:	1880191e 	bne	r3,r2,3213098 <__muldf3+0xf0>
 3213034:	d8c00a17 	ldw	r3,40(sp)
 3213038:	d8800517 	ldw	r2,20(sp)
 321303c:	8009883a 	mov	r4,r16
 3213040:	10c4c03a 	cmpne	r2,r2,r3
 3213044:	d8800a15 	stw	r2,40(sp)
 3213048:	00000706 	br	3213068 <__muldf3+0xc0>
 321304c:	00800084 	movi	r2,2
 3213050:	1880c326 	beq	r3,r2,3213360 <__muldf3+0x3b8>
 3213054:	d8800517 	ldw	r2,20(sp)
 3213058:	d8c00a17 	ldw	r3,40(sp)
 321305c:	8809883a 	mov	r4,r17
 3213060:	10c4c03a 	cmpne	r2,r2,r3
 3213064:	d8800515 	stw	r2,20(sp)
 3213068:	3213ee80 	call	3213ee8 <__pack_d>
 321306c:	dfc01f17 	ldw	ra,124(sp)
 3213070:	ddc01e17 	ldw	r23,120(sp)
 3213074:	dd801d17 	ldw	r22,116(sp)
 3213078:	dd401c17 	ldw	r21,112(sp)
 321307c:	dd001b17 	ldw	r20,108(sp)
 3213080:	dcc01a17 	ldw	r19,104(sp)
 3213084:	dc801917 	ldw	r18,100(sp)
 3213088:	dc401817 	ldw	r17,96(sp)
 321308c:	dc001717 	ldw	r16,92(sp)
 3213090:	dec02004 	addi	sp,sp,128
 3213094:	f800283a 	ret
 3213098:	dd800717 	ldw	r22,28(sp)
 321309c:	dc800c17 	ldw	r18,48(sp)
 32130a0:	002b883a 	mov	r21,zero
 32130a4:	0023883a 	mov	r17,zero
 32130a8:	a80b883a 	mov	r5,r21
 32130ac:	b00d883a 	mov	r6,r22
 32130b0:	880f883a 	mov	r7,r17
 32130b4:	ddc00817 	ldw	r23,32(sp)
 32130b8:	dcc00d17 	ldw	r19,52(sp)
 32130bc:	9009883a 	mov	r4,r18
 32130c0:	3211c740 	call	3211c74 <__muldi3>
 32130c4:	001b883a 	mov	r13,zero
 32130c8:	680f883a 	mov	r7,r13
 32130cc:	b009883a 	mov	r4,r22
 32130d0:	000b883a 	mov	r5,zero
 32130d4:	980d883a 	mov	r6,r19
 32130d8:	b82d883a 	mov	r22,r23
 32130dc:	002f883a 	mov	r23,zero
 32130e0:	db401615 	stw	r13,88(sp)
 32130e4:	d8801315 	stw	r2,76(sp)
 32130e8:	d8c01415 	stw	r3,80(sp)
 32130ec:	dcc01515 	stw	r19,84(sp)
 32130f0:	3211c740 	call	3211c74 <__muldi3>
 32130f4:	b00d883a 	mov	r6,r22
 32130f8:	000b883a 	mov	r5,zero
 32130fc:	9009883a 	mov	r4,r18
 3213100:	b80f883a 	mov	r7,r23
 3213104:	1021883a 	mov	r16,r2
 3213108:	1823883a 	mov	r17,r3
 321310c:	3211c740 	call	3211c74 <__muldi3>
 3213110:	8085883a 	add	r2,r16,r2
 3213114:	140d803a 	cmpltu	r6,r2,r16
 3213118:	88c7883a 	add	r3,r17,r3
 321311c:	30cd883a 	add	r6,r6,r3
 3213120:	1029883a 	mov	r20,r2
 3213124:	302b883a 	mov	r21,r6
 3213128:	da801317 	ldw	r10,76(sp)
 321312c:	dac01417 	ldw	r11,80(sp)
 3213130:	db001517 	ldw	r12,84(sp)
 3213134:	db401617 	ldw	r13,88(sp)
 3213138:	3440612e 	bgeu	r6,r17,32132c0 <__muldf3+0x318>
 321313c:	0009883a 	mov	r4,zero
 3213140:	5105883a 	add	r2,r10,r4
 3213144:	128d803a 	cmpltu	r6,r2,r10
 3213148:	5d07883a 	add	r3,r11,r20
 321314c:	30cd883a 	add	r6,r6,r3
 3213150:	0021883a 	mov	r16,zero
 3213154:	04400044 	movi	r17,1
 3213158:	1025883a 	mov	r18,r2
 321315c:	3027883a 	mov	r19,r6
 3213160:	32c06236 	bltu	r6,r11,32132ec <__muldf3+0x344>
 3213164:	59807a26 	beq	r11,r6,3213350 <__muldf3+0x3a8>
 3213168:	680b883a 	mov	r5,r13
 321316c:	b80f883a 	mov	r7,r23
 3213170:	6009883a 	mov	r4,r12
 3213174:	b00d883a 	mov	r6,r22
 3213178:	3211c740 	call	3211c74 <__muldi3>
 321317c:	1009883a 	mov	r4,r2
 3213180:	000f883a 	mov	r7,zero
 3213184:	1545883a 	add	r2,r2,r21
 3213188:	1111803a 	cmpltu	r8,r2,r4
 321318c:	19c7883a 	add	r3,r3,r7
 3213190:	40c7883a 	add	r3,r8,r3
 3213194:	88cb883a 	add	r5,r17,r3
 3213198:	d8c00617 	ldw	r3,24(sp)
 321319c:	8089883a 	add	r4,r16,r2
 32131a0:	d8800b17 	ldw	r2,44(sp)
 32131a4:	18c00104 	addi	r3,r3,4
 32131a8:	240d803a 	cmpltu	r6,r4,r16
 32131ac:	10c7883a 	add	r3,r2,r3
 32131b0:	2013883a 	mov	r9,r4
 32131b4:	d8800a17 	ldw	r2,40(sp)
 32131b8:	d9000517 	ldw	r4,20(sp)
 32131bc:	314d883a 	add	r6,r6,r5
 32131c0:	3015883a 	mov	r10,r6
 32131c4:	2088c03a 	cmpne	r4,r4,r2
 32131c8:	00880034 	movhi	r2,8192
 32131cc:	10bfffc4 	addi	r2,r2,-1
 32131d0:	d9000f15 	stw	r4,60(sp)
 32131d4:	d8c01015 	stw	r3,64(sp)
 32131d8:	1180162e 	bgeu	r2,r6,3213234 <__muldf3+0x28c>
 32131dc:	1811883a 	mov	r8,r3
 32131e0:	101f883a 	mov	r15,r2
 32131e4:	980497fa 	slli	r2,r19,31
 32131e8:	9016d07a 	srli	r11,r18,1
 32131ec:	500697fa 	slli	r3,r10,31
 32131f0:	480cd07a 	srli	r6,r9,1
 32131f4:	500ed07a 	srli	r7,r10,1
 32131f8:	12d6b03a 	or	r11,r2,r11
 32131fc:	00800044 	movi	r2,1
 3213200:	198cb03a 	or	r6,r3,r6
 3213204:	4888703a 	and	r4,r9,r2
 3213208:	9818d07a 	srli	r12,r19,1
 321320c:	001b883a 	mov	r13,zero
 3213210:	03a00034 	movhi	r14,32768
 3213214:	3013883a 	mov	r9,r6
 3213218:	3815883a 	mov	r10,r7
 321321c:	4091883a 	add	r8,r8,r2
 3213220:	20000226 	beq	r4,zero,321322c <__muldf3+0x284>
 3213224:	5b64b03a 	or	r18,r11,r13
 3213228:	63a6b03a 	or	r19,r12,r14
 321322c:	7abfed36 	bltu	r15,r10,32131e4 <__muldf3+0x23c>
 3213230:	da001015 	stw	r8,64(sp)
 3213234:	00840034 	movhi	r2,4096
 3213238:	10bfffc4 	addi	r2,r2,-1
 321323c:	12801436 	bltu	r2,r10,3213290 <__muldf3+0x2e8>
 3213240:	da001017 	ldw	r8,64(sp)
 3213244:	101f883a 	mov	r15,r2
 3213248:	4a45883a 	add	r2,r9,r9
 321324c:	124d803a 	cmpltu	r6,r2,r9
 3213250:	5287883a 	add	r3,r10,r10
 3213254:	9497883a 	add	r11,r18,r18
 3213258:	5c8f803a 	cmpltu	r7,r11,r18
 321325c:	9cd9883a 	add	r12,r19,r19
 3213260:	01000044 	movi	r4,1
 3213264:	30cd883a 	add	r6,r6,r3
 3213268:	3b0f883a 	add	r7,r7,r12
 321326c:	423fffc4 	addi	r8,r8,-1
 3213270:	1013883a 	mov	r9,r2
 3213274:	3015883a 	mov	r10,r6
 3213278:	111ab03a 	or	r13,r2,r4
 321327c:	98003016 	blt	r19,zero,3213340 <__muldf3+0x398>
 3213280:	5825883a 	mov	r18,r11
 3213284:	3827883a 	mov	r19,r7
 3213288:	7abfef2e 	bgeu	r15,r10,3213248 <__muldf3+0x2a0>
 321328c:	da001015 	stw	r8,64(sp)
 3213290:	00803fc4 	movi	r2,255
 3213294:	488e703a 	and	r7,r9,r2
 3213298:	00802004 	movi	r2,128
 321329c:	0007883a 	mov	r3,zero
 32132a0:	0011883a 	mov	r8,zero
 32132a4:	38801826 	beq	r7,r2,3213308 <__muldf3+0x360>
 32132a8:	008000c4 	movi	r2,3
 32132ac:	d9000e04 	addi	r4,sp,56
 32132b0:	da801215 	stw	r10,72(sp)
 32132b4:	d8800e15 	stw	r2,56(sp)
 32132b8:	da401115 	stw	r9,68(sp)
 32132bc:	003f6a06 	br	3213068 <__muldf3+0xc0>
 32132c0:	89802126 	beq	r17,r6,3213348 <__muldf3+0x3a0>
 32132c4:	0009883a 	mov	r4,zero
 32132c8:	5105883a 	add	r2,r10,r4
 32132cc:	128d803a 	cmpltu	r6,r2,r10
 32132d0:	5d07883a 	add	r3,r11,r20
 32132d4:	30cd883a 	add	r6,r6,r3
 32132d8:	0021883a 	mov	r16,zero
 32132dc:	0023883a 	mov	r17,zero
 32132e0:	1025883a 	mov	r18,r2
 32132e4:	3027883a 	mov	r19,r6
 32132e8:	32ff9e2e 	bgeu	r6,r11,3213164 <__muldf3+0x1bc>
 32132ec:	00800044 	movi	r2,1
 32132f0:	8089883a 	add	r4,r16,r2
 32132f4:	240d803a 	cmpltu	r6,r4,r16
 32132f8:	344d883a 	add	r6,r6,r17
 32132fc:	2021883a 	mov	r16,r4
 3213300:	3023883a 	mov	r17,r6
 3213304:	003f9806 	br	3213168 <__muldf3+0x1c0>
 3213308:	403fe71e 	bne	r8,zero,32132a8 <__muldf3+0x300>
 321330c:	01004004 	movi	r4,256
 3213310:	4904703a 	and	r2,r9,r4
 3213314:	10c4b03a 	or	r2,r2,r3
 3213318:	103fe31e 	bne	r2,zero,32132a8 <__muldf3+0x300>
 321331c:	94c4b03a 	or	r2,r18,r19
 3213320:	103fe126 	beq	r2,zero,32132a8 <__muldf3+0x300>
 3213324:	49c5883a 	add	r2,r9,r7
 3213328:	1251803a 	cmpltu	r8,r2,r9
 321332c:	4291883a 	add	r8,r8,r10
 3213330:	013fc004 	movi	r4,-256
 3213334:	1112703a 	and	r9,r2,r4
 3213338:	4015883a 	mov	r10,r8
 321333c:	003fda06 	br	32132a8 <__muldf3+0x300>
 3213340:	6813883a 	mov	r9,r13
 3213344:	003fce06 	br	3213280 <__muldf3+0x2d8>
 3213348:	143f7c36 	bltu	r2,r16,321313c <__muldf3+0x194>
 321334c:	003fdd06 	br	32132c4 <__muldf3+0x31c>
 3213350:	12bf852e 	bgeu	r2,r10,3213168 <__muldf3+0x1c0>
 3213354:	003fe506 	br	32132ec <__muldf3+0x344>
 3213358:	00800084 	movi	r2,2
 321335c:	20bf351e 	bne	r4,r2,3213034 <__muldf3+0x8c>
 3213360:	0100c974 	movhi	r4,805
 3213364:	21384604 	addi	r4,r4,-7912
 3213368:	003f3f06 	br	3213068 <__muldf3+0xc0>

0321336c <__divdf3>:
 321336c:	deffed04 	addi	sp,sp,-76
 3213370:	dcc01115 	stw	r19,68(sp)
 3213374:	dcc00404 	addi	r19,sp,16
 3213378:	2011883a 	mov	r8,r4
 321337c:	2813883a 	mov	r9,r5
 3213380:	dc000e15 	stw	r16,56(sp)
 3213384:	d809883a 	mov	r4,sp
 3213388:	980b883a 	mov	r5,r19
 321338c:	dc000904 	addi	r16,sp,36
 3213390:	dfc01215 	stw	ra,72(sp)
 3213394:	da400115 	stw	r9,4(sp)
 3213398:	d9c00315 	stw	r7,12(sp)
 321339c:	da000015 	stw	r8,0(sp)
 32133a0:	d9800215 	stw	r6,8(sp)
 32133a4:	dc801015 	stw	r18,64(sp)
 32133a8:	dc400f15 	stw	r17,60(sp)
 32133ac:	32141fc0 	call	32141fc <__unpack_d>
 32133b0:	d9000204 	addi	r4,sp,8
 32133b4:	800b883a 	mov	r5,r16
 32133b8:	32141fc0 	call	32141fc <__unpack_d>
 32133bc:	d9000417 	ldw	r4,16(sp)
 32133c0:	00800044 	movi	r2,1
 32133c4:	11000b2e 	bgeu	r2,r4,32133f4 <__divdf3+0x88>
 32133c8:	d9400917 	ldw	r5,36(sp)
 32133cc:	1140762e 	bgeu	r2,r5,32135a8 <__divdf3+0x23c>
 32133d0:	d8800517 	ldw	r2,20(sp)
 32133d4:	d8c00a17 	ldw	r3,40(sp)
 32133d8:	01800104 	movi	r6,4
 32133dc:	10c4f03a 	xor	r2,r2,r3
 32133e0:	d8800515 	stw	r2,20(sp)
 32133e4:	21800226 	beq	r4,r6,32133f0 <__divdf3+0x84>
 32133e8:	00800084 	movi	r2,2
 32133ec:	2080141e 	bne	r4,r2,3213440 <__divdf3+0xd4>
 32133f0:	29000926 	beq	r5,r4,3213418 <__divdf3+0xac>
 32133f4:	9809883a 	mov	r4,r19
 32133f8:	3213ee80 	call	3213ee8 <__pack_d>
 32133fc:	dfc01217 	ldw	ra,72(sp)
 3213400:	dcc01117 	ldw	r19,68(sp)
 3213404:	dc801017 	ldw	r18,64(sp)
 3213408:	dc400f17 	ldw	r17,60(sp)
 321340c:	dc000e17 	ldw	r16,56(sp)
 3213410:	dec01304 	addi	sp,sp,76
 3213414:	f800283a 	ret
 3213418:	0100c974 	movhi	r4,805
 321341c:	21384604 	addi	r4,r4,-7912
 3213420:	3213ee80 	call	3213ee8 <__pack_d>
 3213424:	dfc01217 	ldw	ra,72(sp)
 3213428:	dcc01117 	ldw	r19,68(sp)
 321342c:	dc801017 	ldw	r18,64(sp)
 3213430:	dc400f17 	ldw	r17,60(sp)
 3213434:	dc000e17 	ldw	r16,56(sp)
 3213438:	dec01304 	addi	sp,sp,76
 321343c:	f800283a 	ret
 3213440:	29805b26 	beq	r5,r6,32135b0 <__divdf3+0x244>
 3213444:	28802d26 	beq	r5,r2,32134fc <__divdf3+0x190>
 3213448:	d8c00617 	ldw	r3,24(sp)
 321344c:	d8800b17 	ldw	r2,44(sp)
 3213450:	d9c00817 	ldw	r7,32(sp)
 3213454:	dc400d17 	ldw	r17,52(sp)
 3213458:	188bc83a 	sub	r5,r3,r2
 321345c:	d9800717 	ldw	r6,28(sp)
 3213460:	dc000c17 	ldw	r16,48(sp)
 3213464:	d9400615 	stw	r5,24(sp)
 3213468:	3c403836 	bltu	r7,r17,321354c <__divdf3+0x1e0>
 321346c:	89c03626 	beq	r17,r7,3213548 <__divdf3+0x1dc>
 3213470:	0015883a 	mov	r10,zero
 3213474:	001d883a 	mov	r14,zero
 3213478:	02c40034 	movhi	r11,4096
 321347c:	001f883a 	mov	r15,zero
 3213480:	003f883a 	mov	ra,zero
 3213484:	04800f44 	movi	r18,61
 3213488:	00000f06 	br	32134c8 <__divdf3+0x15c>
 321348c:	601d883a 	mov	r14,r12
 3213490:	681f883a 	mov	r15,r13
 3213494:	400d883a 	mov	r6,r8
 3213498:	100f883a 	mov	r7,r2
 321349c:	3191883a 	add	r8,r6,r6
 32134a0:	5808d07a 	srli	r4,r11,1
 32134a4:	4185803a 	cmpltu	r2,r8,r6
 32134a8:	39d3883a 	add	r9,r7,r7
 32134ac:	28c6b03a 	or	r3,r5,r3
 32134b0:	1245883a 	add	r2,r2,r9
 32134b4:	1815883a 	mov	r10,r3
 32134b8:	2017883a 	mov	r11,r4
 32134bc:	400d883a 	mov	r6,r8
 32134c0:	100f883a 	mov	r7,r2
 32134c4:	fc801726 	beq	ra,r18,3213524 <__divdf3+0x1b8>
 32134c8:	580a97fa 	slli	r5,r11,31
 32134cc:	5006d07a 	srli	r3,r10,1
 32134d0:	ffc00044 	addi	ra,ra,1
 32134d4:	3c7ff136 	bltu	r7,r17,321349c <__divdf3+0x130>
 32134d8:	3411c83a 	sub	r8,r6,r16
 32134dc:	3205803a 	cmpltu	r2,r6,r8
 32134e0:	3c53c83a 	sub	r9,r7,r17
 32134e4:	7298b03a 	or	r12,r14,r10
 32134e8:	7adab03a 	or	r13,r15,r11
 32134ec:	4885c83a 	sub	r2,r9,r2
 32134f0:	89ffe61e 	bne	r17,r7,321348c <__divdf3+0x120>
 32134f4:	343fe936 	bltu	r6,r16,321349c <__divdf3+0x130>
 32134f8:	003fe406 	br	321348c <__divdf3+0x120>
 32134fc:	9809883a 	mov	r4,r19
 3213500:	d9800415 	stw	r6,16(sp)
 3213504:	3213ee80 	call	3213ee8 <__pack_d>
 3213508:	dfc01217 	ldw	ra,72(sp)
 321350c:	dcc01117 	ldw	r19,68(sp)
 3213510:	dc801017 	ldw	r18,64(sp)
 3213514:	dc400f17 	ldw	r17,60(sp)
 3213518:	dc000e17 	ldw	r16,56(sp)
 321351c:	dec01304 	addi	sp,sp,76
 3213520:	f800283a 	ret
 3213524:	00803fc4 	movi	r2,255
 3213528:	7090703a 	and	r8,r14,r2
 321352c:	00802004 	movi	r2,128
 3213530:	0007883a 	mov	r3,zero
 3213534:	0013883a 	mov	r9,zero
 3213538:	40800d26 	beq	r8,r2,3213570 <__divdf3+0x204>
 321353c:	dbc00815 	stw	r15,32(sp)
 3213540:	db800715 	stw	r14,28(sp)
 3213544:	003fab06 	br	32133f4 <__divdf3+0x88>
 3213548:	343fc92e 	bgeu	r6,r16,3213470 <__divdf3+0x104>
 321354c:	3185883a 	add	r2,r6,r6
 3213550:	1189803a 	cmpltu	r4,r2,r6
 3213554:	39c7883a 	add	r3,r7,r7
 3213558:	20c9883a 	add	r4,r4,r3
 321355c:	297fffc4 	addi	r5,r5,-1
 3213560:	100d883a 	mov	r6,r2
 3213564:	200f883a 	mov	r7,r4
 3213568:	d9400615 	stw	r5,24(sp)
 321356c:	003fc006 	br	3213470 <__divdf3+0x104>
 3213570:	483ff21e 	bne	r9,zero,321353c <__divdf3+0x1d0>
 3213574:	01004004 	movi	r4,256
 3213578:	7104703a 	and	r2,r14,r4
 321357c:	10c4b03a 	or	r2,r2,r3
 3213580:	103fee1e 	bne	r2,zero,321353c <__divdf3+0x1d0>
 3213584:	31c4b03a 	or	r2,r6,r7
 3213588:	103fec26 	beq	r2,zero,321353c <__divdf3+0x1d0>
 321358c:	7205883a 	add	r2,r14,r8
 3213590:	1391803a 	cmpltu	r8,r2,r14
 3213594:	43d1883a 	add	r8,r8,r15
 3213598:	013fc004 	movi	r4,-256
 321359c:	111c703a 	and	r14,r2,r4
 32135a0:	401f883a 	mov	r15,r8
 32135a4:	003fe506 	br	321353c <__divdf3+0x1d0>
 32135a8:	8009883a 	mov	r4,r16
 32135ac:	003f9206 	br	32133f8 <__divdf3+0x8c>
 32135b0:	9809883a 	mov	r4,r19
 32135b4:	d8000715 	stw	zero,28(sp)
 32135b8:	d8000815 	stw	zero,32(sp)
 32135bc:	d8000615 	stw	zero,24(sp)
 32135c0:	003f8d06 	br	32133f8 <__divdf3+0x8c>

032135c4 <__eqdf2>:
 32135c4:	deffef04 	addi	sp,sp,-68
 32135c8:	dc400f15 	stw	r17,60(sp)
 32135cc:	dc400404 	addi	r17,sp,16
 32135d0:	2005883a 	mov	r2,r4
 32135d4:	2807883a 	mov	r3,r5
 32135d8:	dc000e15 	stw	r16,56(sp)
 32135dc:	d809883a 	mov	r4,sp
 32135e0:	880b883a 	mov	r5,r17
 32135e4:	dc000904 	addi	r16,sp,36
 32135e8:	d8c00115 	stw	r3,4(sp)
 32135ec:	d8800015 	stw	r2,0(sp)
 32135f0:	d9800215 	stw	r6,8(sp)
 32135f4:	dfc01015 	stw	ra,64(sp)
 32135f8:	d9c00315 	stw	r7,12(sp)
 32135fc:	32141fc0 	call	32141fc <__unpack_d>
 3213600:	d9000204 	addi	r4,sp,8
 3213604:	800b883a 	mov	r5,r16
 3213608:	32141fc0 	call	32141fc <__unpack_d>
 321360c:	d8800417 	ldw	r2,16(sp)
 3213610:	00c00044 	movi	r3,1
 3213614:	180d883a 	mov	r6,r3
 3213618:	1880062e 	bgeu	r3,r2,3213634 <__eqdf2+0x70>
 321361c:	d8800917 	ldw	r2,36(sp)
 3213620:	8809883a 	mov	r4,r17
 3213624:	800b883a 	mov	r5,r16
 3213628:	1880022e 	bgeu	r3,r2,3213634 <__eqdf2+0x70>
 321362c:	32143340 	call	3214334 <__fpcmp_parts_d>
 3213630:	100d883a 	mov	r6,r2
 3213634:	3005883a 	mov	r2,r6
 3213638:	dfc01017 	ldw	ra,64(sp)
 321363c:	dc400f17 	ldw	r17,60(sp)
 3213640:	dc000e17 	ldw	r16,56(sp)
 3213644:	dec01104 	addi	sp,sp,68
 3213648:	f800283a 	ret

0321364c <__nedf2>:
 321364c:	deffef04 	addi	sp,sp,-68
 3213650:	dc400f15 	stw	r17,60(sp)
 3213654:	dc400404 	addi	r17,sp,16
 3213658:	2005883a 	mov	r2,r4
 321365c:	2807883a 	mov	r3,r5
 3213660:	dc000e15 	stw	r16,56(sp)
 3213664:	d809883a 	mov	r4,sp
 3213668:	880b883a 	mov	r5,r17
 321366c:	dc000904 	addi	r16,sp,36
 3213670:	d8c00115 	stw	r3,4(sp)
 3213674:	d8800015 	stw	r2,0(sp)
 3213678:	d9800215 	stw	r6,8(sp)
 321367c:	dfc01015 	stw	ra,64(sp)
 3213680:	d9c00315 	stw	r7,12(sp)
 3213684:	32141fc0 	call	32141fc <__unpack_d>
 3213688:	d9000204 	addi	r4,sp,8
 321368c:	800b883a 	mov	r5,r16
 3213690:	32141fc0 	call	32141fc <__unpack_d>
 3213694:	d8800417 	ldw	r2,16(sp)
 3213698:	00c00044 	movi	r3,1
 321369c:	180d883a 	mov	r6,r3
 32136a0:	1880062e 	bgeu	r3,r2,32136bc <__nedf2+0x70>
 32136a4:	d8800917 	ldw	r2,36(sp)
 32136a8:	8809883a 	mov	r4,r17
 32136ac:	800b883a 	mov	r5,r16
 32136b0:	1880022e 	bgeu	r3,r2,32136bc <__nedf2+0x70>
 32136b4:	32143340 	call	3214334 <__fpcmp_parts_d>
 32136b8:	100d883a 	mov	r6,r2
 32136bc:	3005883a 	mov	r2,r6
 32136c0:	dfc01017 	ldw	ra,64(sp)
 32136c4:	dc400f17 	ldw	r17,60(sp)
 32136c8:	dc000e17 	ldw	r16,56(sp)
 32136cc:	dec01104 	addi	sp,sp,68
 32136d0:	f800283a 	ret

032136d4 <__gtdf2>:
 32136d4:	deffef04 	addi	sp,sp,-68
 32136d8:	dc400f15 	stw	r17,60(sp)
 32136dc:	dc400404 	addi	r17,sp,16
 32136e0:	2005883a 	mov	r2,r4
 32136e4:	2807883a 	mov	r3,r5
 32136e8:	dc000e15 	stw	r16,56(sp)
 32136ec:	d809883a 	mov	r4,sp
 32136f0:	880b883a 	mov	r5,r17
 32136f4:	dc000904 	addi	r16,sp,36
 32136f8:	d8c00115 	stw	r3,4(sp)
 32136fc:	d8800015 	stw	r2,0(sp)
 3213700:	d9800215 	stw	r6,8(sp)
 3213704:	dfc01015 	stw	ra,64(sp)
 3213708:	d9c00315 	stw	r7,12(sp)
 321370c:	32141fc0 	call	32141fc <__unpack_d>
 3213710:	d9000204 	addi	r4,sp,8
 3213714:	800b883a 	mov	r5,r16
 3213718:	32141fc0 	call	32141fc <__unpack_d>
 321371c:	d8800417 	ldw	r2,16(sp)
 3213720:	00c00044 	movi	r3,1
 3213724:	01bfffc4 	movi	r6,-1
 3213728:	1880062e 	bgeu	r3,r2,3213744 <__gtdf2+0x70>
 321372c:	d8800917 	ldw	r2,36(sp)
 3213730:	8809883a 	mov	r4,r17
 3213734:	800b883a 	mov	r5,r16
 3213738:	1880022e 	bgeu	r3,r2,3213744 <__gtdf2+0x70>
 321373c:	32143340 	call	3214334 <__fpcmp_parts_d>
 3213740:	100d883a 	mov	r6,r2
 3213744:	3005883a 	mov	r2,r6
 3213748:	dfc01017 	ldw	ra,64(sp)
 321374c:	dc400f17 	ldw	r17,60(sp)
 3213750:	dc000e17 	ldw	r16,56(sp)
 3213754:	dec01104 	addi	sp,sp,68
 3213758:	f800283a 	ret

0321375c <__gedf2>:
 321375c:	deffef04 	addi	sp,sp,-68
 3213760:	dc400f15 	stw	r17,60(sp)
 3213764:	dc400404 	addi	r17,sp,16
 3213768:	2005883a 	mov	r2,r4
 321376c:	2807883a 	mov	r3,r5
 3213770:	dc000e15 	stw	r16,56(sp)
 3213774:	d809883a 	mov	r4,sp
 3213778:	880b883a 	mov	r5,r17
 321377c:	dc000904 	addi	r16,sp,36
 3213780:	d8c00115 	stw	r3,4(sp)
 3213784:	d8800015 	stw	r2,0(sp)
 3213788:	d9800215 	stw	r6,8(sp)
 321378c:	dfc01015 	stw	ra,64(sp)
 3213790:	d9c00315 	stw	r7,12(sp)
 3213794:	32141fc0 	call	32141fc <__unpack_d>
 3213798:	d9000204 	addi	r4,sp,8
 321379c:	800b883a 	mov	r5,r16
 32137a0:	32141fc0 	call	32141fc <__unpack_d>
 32137a4:	d8800417 	ldw	r2,16(sp)
 32137a8:	00c00044 	movi	r3,1
 32137ac:	01bfffc4 	movi	r6,-1
 32137b0:	1880062e 	bgeu	r3,r2,32137cc <__gedf2+0x70>
 32137b4:	d8800917 	ldw	r2,36(sp)
 32137b8:	8809883a 	mov	r4,r17
 32137bc:	800b883a 	mov	r5,r16
 32137c0:	1880022e 	bgeu	r3,r2,32137cc <__gedf2+0x70>
 32137c4:	32143340 	call	3214334 <__fpcmp_parts_d>
 32137c8:	100d883a 	mov	r6,r2
 32137cc:	3005883a 	mov	r2,r6
 32137d0:	dfc01017 	ldw	ra,64(sp)
 32137d4:	dc400f17 	ldw	r17,60(sp)
 32137d8:	dc000e17 	ldw	r16,56(sp)
 32137dc:	dec01104 	addi	sp,sp,68
 32137e0:	f800283a 	ret

032137e4 <__ltdf2>:
 32137e4:	deffef04 	addi	sp,sp,-68
 32137e8:	dc400f15 	stw	r17,60(sp)
 32137ec:	dc400404 	addi	r17,sp,16
 32137f0:	2005883a 	mov	r2,r4
 32137f4:	2807883a 	mov	r3,r5
 32137f8:	dc000e15 	stw	r16,56(sp)
 32137fc:	d809883a 	mov	r4,sp
 3213800:	880b883a 	mov	r5,r17
 3213804:	dc000904 	addi	r16,sp,36
 3213808:	d8c00115 	stw	r3,4(sp)
 321380c:	d8800015 	stw	r2,0(sp)
 3213810:	d9800215 	stw	r6,8(sp)
 3213814:	dfc01015 	stw	ra,64(sp)
 3213818:	d9c00315 	stw	r7,12(sp)
 321381c:	32141fc0 	call	32141fc <__unpack_d>
 3213820:	d9000204 	addi	r4,sp,8
 3213824:	800b883a 	mov	r5,r16
 3213828:	32141fc0 	call	32141fc <__unpack_d>
 321382c:	d8800417 	ldw	r2,16(sp)
 3213830:	00c00044 	movi	r3,1
 3213834:	180d883a 	mov	r6,r3
 3213838:	1880062e 	bgeu	r3,r2,3213854 <__ltdf2+0x70>
 321383c:	d8800917 	ldw	r2,36(sp)
 3213840:	8809883a 	mov	r4,r17
 3213844:	800b883a 	mov	r5,r16
 3213848:	1880022e 	bgeu	r3,r2,3213854 <__ltdf2+0x70>
 321384c:	32143340 	call	3214334 <__fpcmp_parts_d>
 3213850:	100d883a 	mov	r6,r2
 3213854:	3005883a 	mov	r2,r6
 3213858:	dfc01017 	ldw	ra,64(sp)
 321385c:	dc400f17 	ldw	r17,60(sp)
 3213860:	dc000e17 	ldw	r16,56(sp)
 3213864:	dec01104 	addi	sp,sp,68
 3213868:	f800283a 	ret

0321386c <__ledf2>:
 321386c:	deffef04 	addi	sp,sp,-68
 3213870:	dc400f15 	stw	r17,60(sp)
 3213874:	dc400404 	addi	r17,sp,16
 3213878:	2005883a 	mov	r2,r4
 321387c:	2807883a 	mov	r3,r5
 3213880:	dc000e15 	stw	r16,56(sp)
 3213884:	d809883a 	mov	r4,sp
 3213888:	880b883a 	mov	r5,r17
 321388c:	dc000904 	addi	r16,sp,36
 3213890:	d8c00115 	stw	r3,4(sp)
 3213894:	d8800015 	stw	r2,0(sp)
 3213898:	d9800215 	stw	r6,8(sp)
 321389c:	dfc01015 	stw	ra,64(sp)
 32138a0:	d9c00315 	stw	r7,12(sp)
 32138a4:	32141fc0 	call	32141fc <__unpack_d>
 32138a8:	d9000204 	addi	r4,sp,8
 32138ac:	800b883a 	mov	r5,r16
 32138b0:	32141fc0 	call	32141fc <__unpack_d>
 32138b4:	d8800417 	ldw	r2,16(sp)
 32138b8:	00c00044 	movi	r3,1
 32138bc:	180d883a 	mov	r6,r3
 32138c0:	1880062e 	bgeu	r3,r2,32138dc <__ledf2+0x70>
 32138c4:	d8800917 	ldw	r2,36(sp)
 32138c8:	8809883a 	mov	r4,r17
 32138cc:	800b883a 	mov	r5,r16
 32138d0:	1880022e 	bgeu	r3,r2,32138dc <__ledf2+0x70>
 32138d4:	32143340 	call	3214334 <__fpcmp_parts_d>
 32138d8:	100d883a 	mov	r6,r2
 32138dc:	3005883a 	mov	r2,r6
 32138e0:	dfc01017 	ldw	ra,64(sp)
 32138e4:	dc400f17 	ldw	r17,60(sp)
 32138e8:	dc000e17 	ldw	r16,56(sp)
 32138ec:	dec01104 	addi	sp,sp,68
 32138f0:	f800283a 	ret

032138f4 <__floatsidf>:
 32138f4:	2006d7fa 	srli	r3,r4,31
 32138f8:	defff604 	addi	sp,sp,-40
 32138fc:	008000c4 	movi	r2,3
 3213900:	dfc00915 	stw	ra,36(sp)
 3213904:	dcc00815 	stw	r19,32(sp)
 3213908:	dc800715 	stw	r18,28(sp)
 321390c:	dc400615 	stw	r17,24(sp)
 3213910:	dc000515 	stw	r16,20(sp)
 3213914:	d8800015 	stw	r2,0(sp)
 3213918:	d8c00115 	stw	r3,4(sp)
 321391c:	20000f1e 	bne	r4,zero,321395c <__floatsidf+0x68>
 3213920:	00800084 	movi	r2,2
 3213924:	d8800015 	stw	r2,0(sp)
 3213928:	d809883a 	mov	r4,sp
 321392c:	3213ee80 	call	3213ee8 <__pack_d>
 3213930:	1009883a 	mov	r4,r2
 3213934:	180b883a 	mov	r5,r3
 3213938:	2005883a 	mov	r2,r4
 321393c:	2807883a 	mov	r3,r5
 3213940:	dfc00917 	ldw	ra,36(sp)
 3213944:	dcc00817 	ldw	r19,32(sp)
 3213948:	dc800717 	ldw	r18,28(sp)
 321394c:	dc400617 	ldw	r17,24(sp)
 3213950:	dc000517 	ldw	r16,20(sp)
 3213954:	dec00a04 	addi	sp,sp,40
 3213958:	f800283a 	ret
 321395c:	00800f04 	movi	r2,60
 3213960:	1807003a 	cmpeq	r3,r3,zero
 3213964:	d8800215 	stw	r2,8(sp)
 3213968:	18001126 	beq	r3,zero,32139b0 <__floatsidf+0xbc>
 321396c:	0027883a 	mov	r19,zero
 3213970:	2025883a 	mov	r18,r4
 3213974:	d9000315 	stw	r4,12(sp)
 3213978:	dcc00415 	stw	r19,16(sp)
 321397c:	3213ccc0 	call	3213ccc <__clzsi2>
 3213980:	11000744 	addi	r4,r2,29
 3213984:	013fe80e 	bge	zero,r4,3213928 <__floatsidf+0x34>
 3213988:	10bfff44 	addi	r2,r2,-3
 321398c:	10000c16 	blt	r2,zero,32139c0 <__floatsidf+0xcc>
 3213990:	90a2983a 	sll	r17,r18,r2
 3213994:	0021883a 	mov	r16,zero
 3213998:	d8800217 	ldw	r2,8(sp)
 321399c:	dc400415 	stw	r17,16(sp)
 32139a0:	dc000315 	stw	r16,12(sp)
 32139a4:	1105c83a 	sub	r2,r2,r4
 32139a8:	d8800215 	stw	r2,8(sp)
 32139ac:	003fde06 	br	3213928 <__floatsidf+0x34>
 32139b0:	00a00034 	movhi	r2,32768
 32139b4:	20800a26 	beq	r4,r2,32139e0 <__floatsidf+0xec>
 32139b8:	0109c83a 	sub	r4,zero,r4
 32139bc:	003feb06 	br	321396c <__floatsidf+0x78>
 32139c0:	9006d07a 	srli	r3,r18,1
 32139c4:	008007c4 	movi	r2,31
 32139c8:	1105c83a 	sub	r2,r2,r4
 32139cc:	1886d83a 	srl	r3,r3,r2
 32139d0:	9922983a 	sll	r17,r19,r4
 32139d4:	9120983a 	sll	r16,r18,r4
 32139d8:	1c62b03a 	or	r17,r3,r17
 32139dc:	003fee06 	br	3213998 <__floatsidf+0xa4>
 32139e0:	0009883a 	mov	r4,zero
 32139e4:	01707834 	movhi	r5,49632
 32139e8:	003fd306 	br	3213938 <__floatsidf+0x44>

032139ec <__fixdfsi>:
 32139ec:	defff804 	addi	sp,sp,-32
 32139f0:	2005883a 	mov	r2,r4
 32139f4:	2807883a 	mov	r3,r5
 32139f8:	d809883a 	mov	r4,sp
 32139fc:	d9400204 	addi	r5,sp,8
 3213a00:	d8c00115 	stw	r3,4(sp)
 3213a04:	d8800015 	stw	r2,0(sp)
 3213a08:	dfc00715 	stw	ra,28(sp)
 3213a0c:	32141fc0 	call	32141fc <__unpack_d>
 3213a10:	d8c00217 	ldw	r3,8(sp)
 3213a14:	00800084 	movi	r2,2
 3213a18:	1880051e 	bne	r3,r2,3213a30 <__fixdfsi+0x44>
 3213a1c:	0007883a 	mov	r3,zero
 3213a20:	1805883a 	mov	r2,r3
 3213a24:	dfc00717 	ldw	ra,28(sp)
 3213a28:	dec00804 	addi	sp,sp,32
 3213a2c:	f800283a 	ret
 3213a30:	00800044 	movi	r2,1
 3213a34:	10fff92e 	bgeu	r2,r3,3213a1c <__fixdfsi+0x30>
 3213a38:	00800104 	movi	r2,4
 3213a3c:	18800426 	beq	r3,r2,3213a50 <__fixdfsi+0x64>
 3213a40:	d8c00417 	ldw	r3,16(sp)
 3213a44:	183ff516 	blt	r3,zero,3213a1c <__fixdfsi+0x30>
 3213a48:	00800784 	movi	r2,30
 3213a4c:	10c0080e 	bge	r2,r3,3213a70 <__fixdfsi+0x84>
 3213a50:	d8800317 	ldw	r2,12(sp)
 3213a54:	1000121e 	bne	r2,zero,3213aa0 <__fixdfsi+0xb4>
 3213a58:	00e00034 	movhi	r3,32768
 3213a5c:	18ffffc4 	addi	r3,r3,-1
 3213a60:	1805883a 	mov	r2,r3
 3213a64:	dfc00717 	ldw	ra,28(sp)
 3213a68:	dec00804 	addi	sp,sp,32
 3213a6c:	f800283a 	ret
 3213a70:	00800f04 	movi	r2,60
 3213a74:	10d1c83a 	sub	r8,r2,r3
 3213a78:	40bff804 	addi	r2,r8,-32
 3213a7c:	d9800517 	ldw	r6,20(sp)
 3213a80:	d9c00617 	ldw	r7,24(sp)
 3213a84:	10000816 	blt	r2,zero,3213aa8 <__fixdfsi+0xbc>
 3213a88:	3888d83a 	srl	r4,r7,r2
 3213a8c:	d8800317 	ldw	r2,12(sp)
 3213a90:	2007883a 	mov	r3,r4
 3213a94:	103fe226 	beq	r2,zero,3213a20 <__fixdfsi+0x34>
 3213a98:	0107c83a 	sub	r3,zero,r4
 3213a9c:	003fe006 	br	3213a20 <__fixdfsi+0x34>
 3213aa0:	00e00034 	movhi	r3,32768
 3213aa4:	003fde06 	br	3213a20 <__fixdfsi+0x34>
 3213aa8:	39c7883a 	add	r3,r7,r7
 3213aac:	008007c4 	movi	r2,31
 3213ab0:	1205c83a 	sub	r2,r2,r8
 3213ab4:	1886983a 	sll	r3,r3,r2
 3213ab8:	3208d83a 	srl	r4,r6,r8
 3213abc:	1908b03a 	or	r4,r3,r4
 3213ac0:	003ff206 	br	3213a8c <__fixdfsi+0xa0>

03213ac4 <__truncdfsf2>:
 3213ac4:	defff804 	addi	sp,sp,-32
 3213ac8:	2005883a 	mov	r2,r4
 3213acc:	2807883a 	mov	r3,r5
 3213ad0:	d809883a 	mov	r4,sp
 3213ad4:	d9400204 	addi	r5,sp,8
 3213ad8:	d8c00115 	stw	r3,4(sp)
 3213adc:	d8800015 	stw	r2,0(sp)
 3213ae0:	dfc00715 	stw	ra,28(sp)
 3213ae4:	32141fc0 	call	32141fc <__unpack_d>
 3213ae8:	d9c00517 	ldw	r7,20(sp)
 3213aec:	da000617 	ldw	r8,24(sp)
 3213af0:	02d00034 	movhi	r11,16384
 3213af4:	5affffc4 	addi	r11,r11,-1
 3213af8:	3812d7ba 	srli	r9,r7,30
 3213afc:	401a90ba 	slli	r13,r8,2
 3213b00:	3ac4703a 	and	r2,r7,r11
 3213b04:	0007883a 	mov	r3,zero
 3213b08:	6a52b03a 	or	r9,r13,r9
 3213b0c:	10c4b03a 	or	r2,r2,r3
 3213b10:	d9000217 	ldw	r4,8(sp)
 3213b14:	d9400317 	ldw	r5,12(sp)
 3213b18:	d9800417 	ldw	r6,16(sp)
 3213b1c:	480f883a 	mov	r7,r9
 3213b20:	10000126 	beq	r2,zero,3213b28 <__truncdfsf2+0x64>
 3213b24:	49c00054 	ori	r7,r9,1
 3213b28:	3213ebc0 	call	3213ebc <__make_fp>
 3213b2c:	dfc00717 	ldw	ra,28(sp)
 3213b30:	dec00804 	addi	sp,sp,32
 3213b34:	f800283a 	ret

03213b38 <__floatunsidf>:
 3213b38:	defff204 	addi	sp,sp,-56
 3213b3c:	dfc00d15 	stw	ra,52(sp)
 3213b40:	ddc00c15 	stw	r23,48(sp)
 3213b44:	dd800b15 	stw	r22,44(sp)
 3213b48:	dd400a15 	stw	r21,40(sp)
 3213b4c:	dd000915 	stw	r20,36(sp)
 3213b50:	dcc00815 	stw	r19,32(sp)
 3213b54:	dc800715 	stw	r18,28(sp)
 3213b58:	dc400615 	stw	r17,24(sp)
 3213b5c:	dc000515 	stw	r16,20(sp)
 3213b60:	d8000115 	stw	zero,4(sp)
 3213b64:	20000f1e 	bne	r4,zero,3213ba4 <__floatunsidf+0x6c>
 3213b68:	00800084 	movi	r2,2
 3213b6c:	d8800015 	stw	r2,0(sp)
 3213b70:	d809883a 	mov	r4,sp
 3213b74:	3213ee80 	call	3213ee8 <__pack_d>
 3213b78:	dfc00d17 	ldw	ra,52(sp)
 3213b7c:	ddc00c17 	ldw	r23,48(sp)
 3213b80:	dd800b17 	ldw	r22,44(sp)
 3213b84:	dd400a17 	ldw	r21,40(sp)
 3213b88:	dd000917 	ldw	r20,36(sp)
 3213b8c:	dcc00817 	ldw	r19,32(sp)
 3213b90:	dc800717 	ldw	r18,28(sp)
 3213b94:	dc400617 	ldw	r17,24(sp)
 3213b98:	dc000517 	ldw	r16,20(sp)
 3213b9c:	dec00e04 	addi	sp,sp,56
 3213ba0:	f800283a 	ret
 3213ba4:	008000c4 	movi	r2,3
 3213ba8:	00c00f04 	movi	r3,60
 3213bac:	002f883a 	mov	r23,zero
 3213bb0:	202d883a 	mov	r22,r4
 3213bb4:	d8800015 	stw	r2,0(sp)
 3213bb8:	d8c00215 	stw	r3,8(sp)
 3213bbc:	d9000315 	stw	r4,12(sp)
 3213bc0:	ddc00415 	stw	r23,16(sp)
 3213bc4:	3213ccc0 	call	3213ccc <__clzsi2>
 3213bc8:	12400744 	addi	r9,r2,29
 3213bcc:	48000b16 	blt	r9,zero,3213bfc <__floatunsidf+0xc4>
 3213bd0:	483fe726 	beq	r9,zero,3213b70 <__floatunsidf+0x38>
 3213bd4:	10bfff44 	addi	r2,r2,-3
 3213bd8:	10002e16 	blt	r2,zero,3213c94 <__floatunsidf+0x15c>
 3213bdc:	b0a2983a 	sll	r17,r22,r2
 3213be0:	0021883a 	mov	r16,zero
 3213be4:	d8800217 	ldw	r2,8(sp)
 3213be8:	dc400415 	stw	r17,16(sp)
 3213bec:	dc000315 	stw	r16,12(sp)
 3213bf0:	1245c83a 	sub	r2,r2,r9
 3213bf4:	d8800215 	stw	r2,8(sp)
 3213bf8:	003fdd06 	br	3213b70 <__floatunsidf+0x38>
 3213bfc:	0255c83a 	sub	r10,zero,r9
 3213c00:	51bff804 	addi	r6,r10,-32
 3213c04:	30001b16 	blt	r6,zero,3213c74 <__floatunsidf+0x13c>
 3213c08:	b9a8d83a 	srl	r20,r23,r6
 3213c0c:	002b883a 	mov	r21,zero
 3213c10:	000f883a 	mov	r7,zero
 3213c14:	01000044 	movi	r4,1
 3213c18:	0011883a 	mov	r8,zero
 3213c1c:	30002516 	blt	r6,zero,3213cb4 <__floatunsidf+0x17c>
 3213c20:	21a6983a 	sll	r19,r4,r6
 3213c24:	0025883a 	mov	r18,zero
 3213c28:	00bfffc4 	movi	r2,-1
 3213c2c:	9089883a 	add	r4,r18,r2
 3213c30:	988b883a 	add	r5,r19,r2
 3213c34:	248d803a 	cmpltu	r6,r4,r18
 3213c38:	314b883a 	add	r5,r6,r5
 3213c3c:	b104703a 	and	r2,r22,r4
 3213c40:	b946703a 	and	r3,r23,r5
 3213c44:	10c4b03a 	or	r2,r2,r3
 3213c48:	10000226 	beq	r2,zero,3213c54 <__floatunsidf+0x11c>
 3213c4c:	01c00044 	movi	r7,1
 3213c50:	0011883a 	mov	r8,zero
 3213c54:	d9000217 	ldw	r4,8(sp)
 3213c58:	a1c4b03a 	or	r2,r20,r7
 3213c5c:	aa06b03a 	or	r3,r21,r8
 3213c60:	2249c83a 	sub	r4,r4,r9
 3213c64:	d8c00415 	stw	r3,16(sp)
 3213c68:	d9000215 	stw	r4,8(sp)
 3213c6c:	d8800315 	stw	r2,12(sp)
 3213c70:	003fbf06 	br	3213b70 <__floatunsidf+0x38>
 3213c74:	bdc7883a 	add	r3,r23,r23
 3213c78:	008007c4 	movi	r2,31
 3213c7c:	1285c83a 	sub	r2,r2,r10
 3213c80:	1886983a 	sll	r3,r3,r2
 3213c84:	b2a8d83a 	srl	r20,r22,r10
 3213c88:	baaad83a 	srl	r21,r23,r10
 3213c8c:	1d28b03a 	or	r20,r3,r20
 3213c90:	003fdf06 	br	3213c10 <__floatunsidf+0xd8>
 3213c94:	b006d07a 	srli	r3,r22,1
 3213c98:	008007c4 	movi	r2,31
 3213c9c:	1245c83a 	sub	r2,r2,r9
 3213ca0:	1886d83a 	srl	r3,r3,r2
 3213ca4:	ba62983a 	sll	r17,r23,r9
 3213ca8:	b260983a 	sll	r16,r22,r9
 3213cac:	1c62b03a 	or	r17,r3,r17
 3213cb0:	003fcc06 	br	3213be4 <__floatunsidf+0xac>
 3213cb4:	2006d07a 	srli	r3,r4,1
 3213cb8:	008007c4 	movi	r2,31
 3213cbc:	1285c83a 	sub	r2,r2,r10
 3213cc0:	18a6d83a 	srl	r19,r3,r2
 3213cc4:	22a4983a 	sll	r18,r4,r10
 3213cc8:	003fd706 	br	3213c28 <__floatunsidf+0xf0>

03213ccc <__clzsi2>:
 3213ccc:	00bfffd4 	movui	r2,65535
 3213cd0:	11000e36 	bltu	r2,r4,3213d0c <__clzsi2+0x40>
 3213cd4:	00803fc4 	movi	r2,255
 3213cd8:	01400204 	movi	r5,8
 3213cdc:	0007883a 	mov	r3,zero
 3213ce0:	11001036 	bltu	r2,r4,3213d24 <__clzsi2+0x58>
 3213ce4:	000b883a 	mov	r5,zero
 3213ce8:	20c6d83a 	srl	r3,r4,r3
 3213cec:	0080c974 	movhi	r2,805
 3213cf0:	10b84b04 	addi	r2,r2,-7892
 3213cf4:	1887883a 	add	r3,r3,r2
 3213cf8:	18800003 	ldbu	r2,0(r3)
 3213cfc:	00c00804 	movi	r3,32
 3213d00:	2885883a 	add	r2,r5,r2
 3213d04:	1885c83a 	sub	r2,r3,r2
 3213d08:	f800283a 	ret
 3213d0c:	01400404 	movi	r5,16
 3213d10:	00804034 	movhi	r2,256
 3213d14:	10bfffc4 	addi	r2,r2,-1
 3213d18:	2807883a 	mov	r3,r5
 3213d1c:	113ff22e 	bgeu	r2,r4,3213ce8 <__clzsi2+0x1c>
 3213d20:	01400604 	movi	r5,24
 3213d24:	2807883a 	mov	r3,r5
 3213d28:	20c6d83a 	srl	r3,r4,r3
 3213d2c:	0080c974 	movhi	r2,805
 3213d30:	10b84b04 	addi	r2,r2,-7892
 3213d34:	1887883a 	add	r3,r3,r2
 3213d38:	18800003 	ldbu	r2,0(r3)
 3213d3c:	00c00804 	movi	r3,32
 3213d40:	2885883a 	add	r2,r5,r2
 3213d44:	1885c83a 	sub	r2,r3,r2
 3213d48:	f800283a 	ret

03213d4c <__unpack_f>:
 3213d4c:	21800017 	ldw	r6,0(r4)
 3213d50:	00c02034 	movhi	r3,128
 3213d54:	18ffffc4 	addi	r3,r3,-1
 3213d58:	3004d5fa 	srli	r2,r6,23
 3213d5c:	3008d7fa 	srli	r4,r6,31
 3213d60:	30ce703a 	and	r7,r6,r3
 3213d64:	10c03fcc 	andi	r3,r2,255
 3213d68:	29000115 	stw	r4,4(r5)
 3213d6c:	1800131e 	bne	r3,zero,3213dbc <__unpack_f+0x70>
 3213d70:	38000f26 	beq	r7,zero,3213db0 <__unpack_f+0x64>
 3213d74:	380691fa 	slli	r3,r7,7
 3213d78:	01bfe084 	movi	r6,-126
 3213d7c:	008000c4 	movi	r2,3
 3213d80:	01100034 	movhi	r4,16384
 3213d84:	213fffc4 	addi	r4,r4,-1
 3213d88:	28800015 	stw	r2,0(r5)
 3213d8c:	29800215 	stw	r6,8(r5)
 3213d90:	20c00536 	bltu	r4,r3,3213da8 <__unpack_f+0x5c>
 3213d94:	3005883a 	mov	r2,r6
 3213d98:	18c7883a 	add	r3,r3,r3
 3213d9c:	10bfffc4 	addi	r2,r2,-1
 3213da0:	20fffd2e 	bgeu	r4,r3,3213d98 <__unpack_f+0x4c>
 3213da4:	28800215 	stw	r2,8(r5)
 3213da8:	28c00315 	stw	r3,12(r5)
 3213dac:	f800283a 	ret
 3213db0:	00800084 	movi	r2,2
 3213db4:	28800015 	stw	r2,0(r5)
 3213db8:	f800283a 	ret
 3213dbc:	00803fc4 	movi	r2,255
 3213dc0:	18800826 	beq	r3,r2,3213de4 <__unpack_f+0x98>
 3213dc4:	380491fa 	slli	r2,r7,7
 3213dc8:	18ffe044 	addi	r3,r3,-127
 3213dcc:	28c00215 	stw	r3,8(r5)
 3213dd0:	10900034 	orhi	r2,r2,16384
 3213dd4:	28800315 	stw	r2,12(r5)
 3213dd8:	008000c4 	movi	r2,3
 3213ddc:	28800015 	stw	r2,0(r5)
 3213de0:	f800283a 	ret
 3213de4:	3800031e 	bne	r7,zero,3213df4 <__unpack_f+0xa8>
 3213de8:	00800104 	movi	r2,4
 3213dec:	28800015 	stw	r2,0(r5)
 3213df0:	f800283a 	ret
 3213df4:	3080042c 	andhi	r2,r6,16
 3213df8:	10000426 	beq	r2,zero,3213e0c <__unpack_f+0xc0>
 3213dfc:	00800044 	movi	r2,1
 3213e00:	28800015 	stw	r2,0(r5)
 3213e04:	29c00315 	stw	r7,12(r5)
 3213e08:	f800283a 	ret
 3213e0c:	28000015 	stw	zero,0(r5)
 3213e10:	003ffc06 	br	3213e04 <__unpack_f+0xb8>

03213e14 <__fpcmp_parts_f>:
 3213e14:	21800017 	ldw	r6,0(r4)
 3213e18:	00c00044 	movi	r3,1
 3213e1c:	19800a2e 	bgeu	r3,r6,3213e48 <__fpcmp_parts_f+0x34>
 3213e20:	28800017 	ldw	r2,0(r5)
 3213e24:	1880082e 	bgeu	r3,r2,3213e48 <__fpcmp_parts_f+0x34>
 3213e28:	00c00104 	movi	r3,4
 3213e2c:	30c01e26 	beq	r6,r3,3213ea8 <__fpcmp_parts_f+0x94>
 3213e30:	10c01a26 	beq	r2,r3,3213e9c <__fpcmp_parts_f+0x88>
 3213e34:	00c00084 	movi	r3,2
 3213e38:	30c00526 	beq	r6,r3,3213e50 <__fpcmp_parts_f+0x3c>
 3213e3c:	10c0071e 	bne	r2,r3,3213e5c <__fpcmp_parts_f+0x48>
 3213e40:	20800117 	ldw	r2,4(r4)
 3213e44:	1000091e 	bne	r2,zero,3213e6c <__fpcmp_parts_f+0x58>
 3213e48:	00800044 	movi	r2,1
 3213e4c:	f800283a 	ret
 3213e50:	10c0121e 	bne	r2,r3,3213e9c <__fpcmp_parts_f+0x88>
 3213e54:	0005883a 	mov	r2,zero
 3213e58:	f800283a 	ret
 3213e5c:	20c00117 	ldw	r3,4(r4)
 3213e60:	28800117 	ldw	r2,4(r5)
 3213e64:	18800326 	beq	r3,r2,3213e74 <__fpcmp_parts_f+0x60>
 3213e68:	183ff726 	beq	r3,zero,3213e48 <__fpcmp_parts_f+0x34>
 3213e6c:	00bfffc4 	movi	r2,-1
 3213e70:	f800283a 	ret
 3213e74:	21800217 	ldw	r6,8(r4)
 3213e78:	28800217 	ldw	r2,8(r5)
 3213e7c:	11bffa16 	blt	r2,r6,3213e68 <__fpcmp_parts_f+0x54>
 3213e80:	30800416 	blt	r6,r2,3213e94 <__fpcmp_parts_f+0x80>
 3213e84:	21000317 	ldw	r4,12(r4)
 3213e88:	29400317 	ldw	r5,12(r5)
 3213e8c:	293ff636 	bltu	r5,r4,3213e68 <__fpcmp_parts_f+0x54>
 3213e90:	217ff02e 	bgeu	r4,r5,3213e54 <__fpcmp_parts_f+0x40>
 3213e94:	183fec1e 	bne	r3,zero,3213e48 <__fpcmp_parts_f+0x34>
 3213e98:	003ff406 	br	3213e6c <__fpcmp_parts_f+0x58>
 3213e9c:	28800117 	ldw	r2,4(r5)
 3213ea0:	103fe91e 	bne	r2,zero,3213e48 <__fpcmp_parts_f+0x34>
 3213ea4:	003ff106 	br	3213e6c <__fpcmp_parts_f+0x58>
 3213ea8:	11bfe51e 	bne	r2,r6,3213e40 <__fpcmp_parts_f+0x2c>
 3213eac:	28c00117 	ldw	r3,4(r5)
 3213eb0:	20800117 	ldw	r2,4(r4)
 3213eb4:	1885c83a 	sub	r2,r3,r2
 3213eb8:	f800283a 	ret

03213ebc <__make_fp>:
 3213ebc:	defffb04 	addi	sp,sp,-20
 3213ec0:	d9000015 	stw	r4,0(sp)
 3213ec4:	d809883a 	mov	r4,sp
 3213ec8:	dfc00415 	stw	ra,16(sp)
 3213ecc:	d9400115 	stw	r5,4(sp)
 3213ed0:	d9800215 	stw	r6,8(sp)
 3213ed4:	d9c00315 	stw	r7,12(sp)
 3213ed8:	32143fc0 	call	32143fc <__pack_f>
 3213edc:	dfc00417 	ldw	ra,16(sp)
 3213ee0:	dec00504 	addi	sp,sp,20
 3213ee4:	f800283a 	ret

03213ee8 <__pack_d>:
 3213ee8:	20c00017 	ldw	r3,0(r4)
 3213eec:	defffd04 	addi	sp,sp,-12
 3213ef0:	dc000015 	stw	r16,0(sp)
 3213ef4:	dc800215 	stw	r18,8(sp)
 3213ef8:	dc400115 	stw	r17,4(sp)
 3213efc:	00800044 	movi	r2,1
 3213f00:	22000317 	ldw	r8,12(r4)
 3213f04:	001f883a 	mov	r15,zero
 3213f08:	22400417 	ldw	r9,16(r4)
 3213f0c:	24000117 	ldw	r16,4(r4)
 3213f10:	10c0552e 	bgeu	r2,r3,3214068 <__pack_d+0x180>
 3213f14:	00800104 	movi	r2,4
 3213f18:	18804f26 	beq	r3,r2,3214058 <__pack_d+0x170>
 3213f1c:	00800084 	movi	r2,2
 3213f20:	18800226 	beq	r3,r2,3213f2c <__pack_d+0x44>
 3213f24:	4244b03a 	or	r2,r8,r9
 3213f28:	10001a1e 	bne	r2,zero,3213f94 <__pack_d+0xac>
 3213f2c:	000d883a 	mov	r6,zero
 3213f30:	000f883a 	mov	r7,zero
 3213f34:	0011883a 	mov	r8,zero
 3213f38:	00800434 	movhi	r2,16
 3213f3c:	10bfffc4 	addi	r2,r2,-1
 3213f40:	301d883a 	mov	r14,r6
 3213f44:	3884703a 	and	r2,r7,r2
 3213f48:	400a953a 	slli	r5,r8,20
 3213f4c:	79bffc2c 	andhi	r6,r15,65520
 3213f50:	308cb03a 	or	r6,r6,r2
 3213f54:	00e00434 	movhi	r3,32784
 3213f58:	18ffffc4 	addi	r3,r3,-1
 3213f5c:	800497fa 	slli	r2,r16,31
 3213f60:	30c6703a 	and	r3,r6,r3
 3213f64:	1946b03a 	or	r3,r3,r5
 3213f68:	01600034 	movhi	r5,32768
 3213f6c:	297fffc4 	addi	r5,r5,-1
 3213f70:	194a703a 	and	r5,r3,r5
 3213f74:	288ab03a 	or	r5,r5,r2
 3213f78:	2807883a 	mov	r3,r5
 3213f7c:	7005883a 	mov	r2,r14
 3213f80:	dc800217 	ldw	r18,8(sp)
 3213f84:	dc400117 	ldw	r17,4(sp)
 3213f88:	dc000017 	ldw	r16,0(sp)
 3213f8c:	dec00304 	addi	sp,sp,12
 3213f90:	f800283a 	ret
 3213f94:	21000217 	ldw	r4,8(r4)
 3213f98:	00bf0084 	movi	r2,-1022
 3213f9c:	20803f16 	blt	r4,r2,321409c <__pack_d+0x1b4>
 3213fa0:	0080ffc4 	movi	r2,1023
 3213fa4:	11002c16 	blt	r2,r4,3214058 <__pack_d+0x170>
 3213fa8:	00803fc4 	movi	r2,255
 3213fac:	408c703a 	and	r6,r8,r2
 3213fb0:	00802004 	movi	r2,128
 3213fb4:	0007883a 	mov	r3,zero
 3213fb8:	000f883a 	mov	r7,zero
 3213fbc:	2280ffc4 	addi	r10,r4,1023
 3213fc0:	30801e26 	beq	r6,r2,321403c <__pack_d+0x154>
 3213fc4:	00801fc4 	movi	r2,127
 3213fc8:	4089883a 	add	r4,r8,r2
 3213fcc:	220d803a 	cmpltu	r6,r4,r8
 3213fd0:	324d883a 	add	r6,r6,r9
 3213fd4:	2011883a 	mov	r8,r4
 3213fd8:	3013883a 	mov	r9,r6
 3213fdc:	00880034 	movhi	r2,8192
 3213fe0:	10bfffc4 	addi	r2,r2,-1
 3213fe4:	12400d36 	bltu	r2,r9,321401c <__pack_d+0x134>
 3213fe8:	4804963a 	slli	r2,r9,24
 3213fec:	400cd23a 	srli	r6,r8,8
 3213ff0:	480ed23a 	srli	r7,r9,8
 3213ff4:	013fffc4 	movi	r4,-1
 3213ff8:	118cb03a 	or	r6,r2,r6
 3213ffc:	01400434 	movhi	r5,16
 3214000:	297fffc4 	addi	r5,r5,-1
 3214004:	3104703a 	and	r2,r6,r4
 3214008:	3946703a 	and	r3,r7,r5
 321400c:	5201ffcc 	andi	r8,r10,2047
 3214010:	100d883a 	mov	r6,r2
 3214014:	180f883a 	mov	r7,r3
 3214018:	003fc706 	br	3213f38 <__pack_d+0x50>
 321401c:	480897fa 	slli	r4,r9,31
 3214020:	4004d07a 	srli	r2,r8,1
 3214024:	4806d07a 	srli	r3,r9,1
 3214028:	52800044 	addi	r10,r10,1
 321402c:	2084b03a 	or	r2,r4,r2
 3214030:	1011883a 	mov	r8,r2
 3214034:	1813883a 	mov	r9,r3
 3214038:	003feb06 	br	3213fe8 <__pack_d+0x100>
 321403c:	383fe11e 	bne	r7,zero,3213fc4 <__pack_d+0xdc>
 3214040:	01004004 	movi	r4,256
 3214044:	4104703a 	and	r2,r8,r4
 3214048:	10c4b03a 	or	r2,r2,r3
 321404c:	103fe326 	beq	r2,zero,3213fdc <__pack_d+0xf4>
 3214050:	3005883a 	mov	r2,r6
 3214054:	003fdc06 	br	3213fc8 <__pack_d+0xe0>
 3214058:	000d883a 	mov	r6,zero
 321405c:	000f883a 	mov	r7,zero
 3214060:	0201ffc4 	movi	r8,2047
 3214064:	003fb406 	br	3213f38 <__pack_d+0x50>
 3214068:	0005883a 	mov	r2,zero
 321406c:	00c00234 	movhi	r3,8
 3214070:	408cb03a 	or	r6,r8,r2
 3214074:	48ceb03a 	or	r7,r9,r3
 3214078:	013fffc4 	movi	r4,-1
 321407c:	01400434 	movhi	r5,16
 3214080:	297fffc4 	addi	r5,r5,-1
 3214084:	3104703a 	and	r2,r6,r4
 3214088:	3946703a 	and	r3,r7,r5
 321408c:	100d883a 	mov	r6,r2
 3214090:	180f883a 	mov	r7,r3
 3214094:	0201ffc4 	movi	r8,2047
 3214098:	003fa706 	br	3213f38 <__pack_d+0x50>
 321409c:	1109c83a 	sub	r4,r2,r4
 32140a0:	00800e04 	movi	r2,56
 32140a4:	11004316 	blt	r2,r4,32141b4 <__pack_d+0x2cc>
 32140a8:	21fff804 	addi	r7,r4,-32
 32140ac:	38004516 	blt	r7,zero,32141c4 <__pack_d+0x2dc>
 32140b0:	49d8d83a 	srl	r12,r9,r7
 32140b4:	001b883a 	mov	r13,zero
 32140b8:	0023883a 	mov	r17,zero
 32140bc:	01400044 	movi	r5,1
 32140c0:	0025883a 	mov	r18,zero
 32140c4:	38004716 	blt	r7,zero,32141e4 <__pack_d+0x2fc>
 32140c8:	29d6983a 	sll	r11,r5,r7
 32140cc:	0015883a 	mov	r10,zero
 32140d0:	00bfffc4 	movi	r2,-1
 32140d4:	5089883a 	add	r4,r10,r2
 32140d8:	588b883a 	add	r5,r11,r2
 32140dc:	228d803a 	cmpltu	r6,r4,r10
 32140e0:	314b883a 	add	r5,r6,r5
 32140e4:	4104703a 	and	r2,r8,r4
 32140e8:	4946703a 	and	r3,r9,r5
 32140ec:	10c4b03a 	or	r2,r2,r3
 32140f0:	10000226 	beq	r2,zero,32140fc <__pack_d+0x214>
 32140f4:	04400044 	movi	r17,1
 32140f8:	0025883a 	mov	r18,zero
 32140fc:	00803fc4 	movi	r2,255
 3214100:	644eb03a 	or	r7,r12,r17
 3214104:	3892703a 	and	r9,r7,r2
 3214108:	00802004 	movi	r2,128
 321410c:	6c90b03a 	or	r8,r13,r18
 3214110:	0015883a 	mov	r10,zero
 3214114:	48801626 	beq	r9,r2,3214170 <__pack_d+0x288>
 3214118:	01001fc4 	movi	r4,127
 321411c:	3905883a 	add	r2,r7,r4
 3214120:	11cd803a 	cmpltu	r6,r2,r7
 3214124:	320d883a 	add	r6,r6,r8
 3214128:	100f883a 	mov	r7,r2
 321412c:	00840034 	movhi	r2,4096
 3214130:	10bfffc4 	addi	r2,r2,-1
 3214134:	3011883a 	mov	r8,r6
 3214138:	0007883a 	mov	r3,zero
 321413c:	11801b36 	bltu	r2,r6,32141ac <__pack_d+0x2c4>
 3214140:	4004963a 	slli	r2,r8,24
 3214144:	3808d23a 	srli	r4,r7,8
 3214148:	400ad23a 	srli	r5,r8,8
 321414c:	1813883a 	mov	r9,r3
 3214150:	1108b03a 	or	r4,r2,r4
 3214154:	00bfffc4 	movi	r2,-1
 3214158:	00c00434 	movhi	r3,16
 321415c:	18ffffc4 	addi	r3,r3,-1
 3214160:	208c703a 	and	r6,r4,r2
 3214164:	28ce703a 	and	r7,r5,r3
 3214168:	4a01ffcc 	andi	r8,r9,2047
 321416c:	003f7206 	br	3213f38 <__pack_d+0x50>
 3214170:	503fe91e 	bne	r10,zero,3214118 <__pack_d+0x230>
 3214174:	01004004 	movi	r4,256
 3214178:	3904703a 	and	r2,r7,r4
 321417c:	0007883a 	mov	r3,zero
 3214180:	10c4b03a 	or	r2,r2,r3
 3214184:	10000626 	beq	r2,zero,32141a0 <__pack_d+0x2b8>
 3214188:	3a45883a 	add	r2,r7,r9
 321418c:	11cd803a 	cmpltu	r6,r2,r7
 3214190:	320d883a 	add	r6,r6,r8
 3214194:	100f883a 	mov	r7,r2
 3214198:	3011883a 	mov	r8,r6
 321419c:	0007883a 	mov	r3,zero
 32141a0:	00840034 	movhi	r2,4096
 32141a4:	10bfffc4 	addi	r2,r2,-1
 32141a8:	123fe52e 	bgeu	r2,r8,3214140 <__pack_d+0x258>
 32141ac:	00c00044 	movi	r3,1
 32141b0:	003fe306 	br	3214140 <__pack_d+0x258>
 32141b4:	0009883a 	mov	r4,zero
 32141b8:	0013883a 	mov	r9,zero
 32141bc:	000b883a 	mov	r5,zero
 32141c0:	003fe406 	br	3214154 <__pack_d+0x26c>
 32141c4:	4a47883a 	add	r3,r9,r9
 32141c8:	008007c4 	movi	r2,31
 32141cc:	1105c83a 	sub	r2,r2,r4
 32141d0:	1886983a 	sll	r3,r3,r2
 32141d4:	4118d83a 	srl	r12,r8,r4
 32141d8:	491ad83a 	srl	r13,r9,r4
 32141dc:	1b18b03a 	or	r12,r3,r12
 32141e0:	003fb506 	br	32140b8 <__pack_d+0x1d0>
 32141e4:	2806d07a 	srli	r3,r5,1
 32141e8:	008007c4 	movi	r2,31
 32141ec:	1105c83a 	sub	r2,r2,r4
 32141f0:	1896d83a 	srl	r11,r3,r2
 32141f4:	2914983a 	sll	r10,r5,r4
 32141f8:	003fb506 	br	32140d0 <__pack_d+0x1e8>

032141fc <__unpack_d>:
 32141fc:	20c00117 	ldw	r3,4(r4)
 3214200:	22400017 	ldw	r9,0(r4)
 3214204:	00800434 	movhi	r2,16
 3214208:	10bfffc4 	addi	r2,r2,-1
 321420c:	1808d53a 	srli	r4,r3,20
 3214210:	180cd7fa 	srli	r6,r3,31
 3214214:	1894703a 	and	r10,r3,r2
 3214218:	2201ffcc 	andi	r8,r4,2047
 321421c:	281b883a 	mov	r13,r5
 3214220:	4817883a 	mov	r11,r9
 3214224:	29800115 	stw	r6,4(r5)
 3214228:	5019883a 	mov	r12,r10
 321422c:	40001e1e 	bne	r8,zero,32142a8 <__unpack_d+0xac>
 3214230:	4a84b03a 	or	r2,r9,r10
 3214234:	10001926 	beq	r2,zero,321429c <__unpack_d+0xa0>
 3214238:	4804d63a 	srli	r2,r9,24
 321423c:	500c923a 	slli	r6,r10,8
 3214240:	013f0084 	movi	r4,-1022
 3214244:	00c40034 	movhi	r3,4096
 3214248:	18ffffc4 	addi	r3,r3,-1
 321424c:	118cb03a 	or	r6,r2,r6
 3214250:	008000c4 	movi	r2,3
 3214254:	480a923a 	slli	r5,r9,8
 3214258:	68800015 	stw	r2,0(r13)
 321425c:	69000215 	stw	r4,8(r13)
 3214260:	19800b36 	bltu	r3,r6,3214290 <__unpack_d+0x94>
 3214264:	200f883a 	mov	r7,r4
 3214268:	1811883a 	mov	r8,r3
 321426c:	2945883a 	add	r2,r5,r5
 3214270:	1149803a 	cmpltu	r4,r2,r5
 3214274:	3187883a 	add	r3,r6,r6
 3214278:	20c9883a 	add	r4,r4,r3
 321427c:	100b883a 	mov	r5,r2
 3214280:	200d883a 	mov	r6,r4
 3214284:	39ffffc4 	addi	r7,r7,-1
 3214288:	413ff82e 	bgeu	r8,r4,321426c <__unpack_d+0x70>
 321428c:	69c00215 	stw	r7,8(r13)
 3214290:	69800415 	stw	r6,16(r13)
 3214294:	69400315 	stw	r5,12(r13)
 3214298:	f800283a 	ret
 321429c:	00800084 	movi	r2,2
 32142a0:	28800015 	stw	r2,0(r5)
 32142a4:	f800283a 	ret
 32142a8:	0081ffc4 	movi	r2,2047
 32142ac:	40800f26 	beq	r8,r2,32142ec <__unpack_d+0xf0>
 32142b0:	480cd63a 	srli	r6,r9,24
 32142b4:	5006923a 	slli	r3,r10,8
 32142b8:	4804923a 	slli	r2,r9,8
 32142bc:	0009883a 	mov	r4,zero
 32142c0:	30c6b03a 	or	r3,r6,r3
 32142c4:	01440034 	movhi	r5,4096
 32142c8:	110cb03a 	or	r6,r2,r4
 32142cc:	423f0044 	addi	r8,r8,-1023
 32142d0:	194eb03a 	or	r7,r3,r5
 32142d4:	008000c4 	movi	r2,3
 32142d8:	69c00415 	stw	r7,16(r13)
 32142dc:	6a000215 	stw	r8,8(r13)
 32142e0:	68800015 	stw	r2,0(r13)
 32142e4:	69800315 	stw	r6,12(r13)
 32142e8:	f800283a 	ret
 32142ec:	4a84b03a 	or	r2,r9,r10
 32142f0:	1000031e 	bne	r2,zero,3214300 <__unpack_d+0x104>
 32142f4:	00800104 	movi	r2,4
 32142f8:	28800015 	stw	r2,0(r5)
 32142fc:	f800283a 	ret
 3214300:	0009883a 	mov	r4,zero
 3214304:	01400234 	movhi	r5,8
 3214308:	4904703a 	and	r2,r9,r4
 321430c:	5146703a 	and	r3,r10,r5
 3214310:	10c4b03a 	or	r2,r2,r3
 3214314:	10000526 	beq	r2,zero,321432c <__unpack_d+0x130>
 3214318:	00800044 	movi	r2,1
 321431c:	68800015 	stw	r2,0(r13)
 3214320:	6b000415 	stw	r12,16(r13)
 3214324:	6ac00315 	stw	r11,12(r13)
 3214328:	f800283a 	ret
 321432c:	68000015 	stw	zero,0(r13)
 3214330:	003ffb06 	br	3214320 <__unpack_d+0x124>

03214334 <__fpcmp_parts_d>:
 3214334:	21800017 	ldw	r6,0(r4)
 3214338:	00c00044 	movi	r3,1
 321433c:	19800a2e 	bgeu	r3,r6,3214368 <__fpcmp_parts_d+0x34>
 3214340:	28800017 	ldw	r2,0(r5)
 3214344:	1880082e 	bgeu	r3,r2,3214368 <__fpcmp_parts_d+0x34>
 3214348:	00c00104 	movi	r3,4
 321434c:	30c02626 	beq	r6,r3,32143e8 <__fpcmp_parts_d+0xb4>
 3214350:	10c02226 	beq	r2,r3,32143dc <__fpcmp_parts_d+0xa8>
 3214354:	00c00084 	movi	r3,2
 3214358:	30c00526 	beq	r6,r3,3214370 <__fpcmp_parts_d+0x3c>
 321435c:	10c0071e 	bne	r2,r3,321437c <__fpcmp_parts_d+0x48>
 3214360:	20800117 	ldw	r2,4(r4)
 3214364:	1000091e 	bne	r2,zero,321438c <__fpcmp_parts_d+0x58>
 3214368:	00800044 	movi	r2,1
 321436c:	f800283a 	ret
 3214370:	10c01a1e 	bne	r2,r3,32143dc <__fpcmp_parts_d+0xa8>
 3214374:	0005883a 	mov	r2,zero
 3214378:	f800283a 	ret
 321437c:	22000117 	ldw	r8,4(r4)
 3214380:	28800117 	ldw	r2,4(r5)
 3214384:	40800326 	beq	r8,r2,3214394 <__fpcmp_parts_d+0x60>
 3214388:	403ff726 	beq	r8,zero,3214368 <__fpcmp_parts_d+0x34>
 321438c:	00bfffc4 	movi	r2,-1
 3214390:	f800283a 	ret
 3214394:	20c00217 	ldw	r3,8(r4)
 3214398:	28800217 	ldw	r2,8(r5)
 321439c:	10fffa16 	blt	r2,r3,3214388 <__fpcmp_parts_d+0x54>
 32143a0:	18800916 	blt	r3,r2,32143c8 <__fpcmp_parts_d+0x94>
 32143a4:	21c00417 	ldw	r7,16(r4)
 32143a8:	28c00417 	ldw	r3,16(r5)
 32143ac:	21800317 	ldw	r6,12(r4)
 32143b0:	28800317 	ldw	r2,12(r5)
 32143b4:	19fff436 	bltu	r3,r7,3214388 <__fpcmp_parts_d+0x54>
 32143b8:	38c00526 	beq	r7,r3,32143d0 <__fpcmp_parts_d+0x9c>
 32143bc:	38c00236 	bltu	r7,r3,32143c8 <__fpcmp_parts_d+0x94>
 32143c0:	19ffec1e 	bne	r3,r7,3214374 <__fpcmp_parts_d+0x40>
 32143c4:	30bfeb2e 	bgeu	r6,r2,3214374 <__fpcmp_parts_d+0x40>
 32143c8:	403fe71e 	bne	r8,zero,3214368 <__fpcmp_parts_d+0x34>
 32143cc:	003fef06 	br	321438c <__fpcmp_parts_d+0x58>
 32143d0:	11bffa2e 	bgeu	r2,r6,32143bc <__fpcmp_parts_d+0x88>
 32143d4:	403fe426 	beq	r8,zero,3214368 <__fpcmp_parts_d+0x34>
 32143d8:	003fec06 	br	321438c <__fpcmp_parts_d+0x58>
 32143dc:	28800117 	ldw	r2,4(r5)
 32143e0:	103fe11e 	bne	r2,zero,3214368 <__fpcmp_parts_d+0x34>
 32143e4:	003fe906 	br	321438c <__fpcmp_parts_d+0x58>
 32143e8:	11bfdd1e 	bne	r2,r6,3214360 <__fpcmp_parts_d+0x2c>
 32143ec:	28c00117 	ldw	r3,4(r5)
 32143f0:	20800117 	ldw	r2,4(r4)
 32143f4:	1885c83a 	sub	r2,r3,r2
 32143f8:	f800283a 	ret

032143fc <__pack_f>:
 32143fc:	20c00017 	ldw	r3,0(r4)
 3214400:	01c00044 	movi	r7,1
 3214404:	21800317 	ldw	r6,12(r4)
 3214408:	21400117 	ldw	r5,4(r4)
 321440c:	38c02d2e 	bgeu	r7,r3,32144c4 <__pack_f+0xc8>
 3214410:	00800104 	movi	r2,4
 3214414:	18802826 	beq	r3,r2,32144b8 <__pack_f+0xbc>
 3214418:	00800084 	movi	r2,2
 321441c:	18800126 	beq	r3,r2,3214424 <__pack_f+0x28>
 3214420:	3000101e 	bne	r6,zero,3214464 <__pack_f+0x68>
 3214424:	000d883a 	mov	r6,zero
 3214428:	0007883a 	mov	r3,zero
 321442c:	19003fcc 	andi	r4,r3,255
 3214430:	200895fa 	slli	r4,r4,23
 3214434:	00c02034 	movhi	r3,128
 3214438:	18ffffc4 	addi	r3,r3,-1
 321443c:	30c6703a 	and	r3,r6,r3
 3214440:	10a0002c 	andhi	r2,r2,32768
 3214444:	10c4b03a 	or	r2,r2,r3
 3214448:	280a97fa 	slli	r5,r5,31
 321444c:	1104b03a 	or	r2,r2,r4
 3214450:	00e00034 	movhi	r3,32768
 3214454:	18ffffc4 	addi	r3,r3,-1
 3214458:	10c4703a 	and	r2,r2,r3
 321445c:	1144b03a 	or	r2,r2,r5
 3214460:	f800283a 	ret
 3214464:	21000217 	ldw	r4,8(r4)
 3214468:	00bfe084 	movi	r2,-126
 321446c:	20801b16 	blt	r4,r2,32144dc <__pack_f+0xe0>
 3214470:	00801fc4 	movi	r2,127
 3214474:	11001016 	blt	r2,r4,32144b8 <__pack_f+0xbc>
 3214478:	308e703a 	and	r7,r6,r2
 321447c:	2087883a 	add	r3,r4,r2
 3214480:	00801004 	movi	r2,64
 3214484:	38800526 	beq	r7,r2,321449c <__pack_f+0xa0>
 3214488:	31800fc4 	addi	r6,r6,63
 321448c:	30000716 	blt	r6,zero,32144ac <__pack_f+0xb0>
 3214490:	300490ba 	slli	r2,r6,2
 3214494:	100cd27a 	srli	r6,r2,9
 3214498:	003fe406 	br	321442c <__pack_f+0x30>
 321449c:	3080200c 	andi	r2,r6,128
 32144a0:	103ffa26 	beq	r2,zero,321448c <__pack_f+0x90>
 32144a4:	31cd883a 	add	r6,r6,r7
 32144a8:	003ff806 	br	321448c <__pack_f+0x90>
 32144ac:	300cd07a 	srli	r6,r6,1
 32144b0:	18c00044 	addi	r3,r3,1
 32144b4:	003ff606 	br	3214490 <__pack_f+0x94>
 32144b8:	000d883a 	mov	r6,zero
 32144bc:	00ffffc4 	movi	r3,-1
 32144c0:	003fda06 	br	321442c <__pack_f+0x30>
 32144c4:	31800434 	orhi	r6,r6,16
 32144c8:	00802034 	movhi	r2,128
 32144cc:	10bfffc4 	addi	r2,r2,-1
 32144d0:	308c703a 	and	r6,r6,r2
 32144d4:	00ffffc4 	movi	r3,-1
 32144d8:	003fd406 	br	321442c <__pack_f+0x30>
 32144dc:	1109c83a 	sub	r4,r2,r4
 32144e0:	00800644 	movi	r2,25
 32144e4:	11001216 	blt	r2,r4,3214530 <__pack_f+0x134>
 32144e8:	3904983a 	sll	r2,r7,r4
 32144ec:	3106d83a 	srl	r3,r6,r4
 32144f0:	10bfffc4 	addi	r2,r2,-1
 32144f4:	3084703a 	and	r2,r6,r2
 32144f8:	1004c03a 	cmpne	r2,r2,zero
 32144fc:	1886b03a 	or	r3,r3,r2
 3214500:	19001fcc 	andi	r4,r3,127
 3214504:	00801004 	movi	r2,64
 3214508:	20800c26 	beq	r4,r2,321453c <__pack_f+0x140>
 321450c:	18c00fc4 	addi	r3,r3,63
 3214510:	00900034 	movhi	r2,16384
 3214514:	10bfffc4 	addi	r2,r2,-1
 3214518:	180cd1fa 	srli	r6,r3,7
 321451c:	10c7803a 	cmpltu	r3,r2,r3
 3214520:	00802034 	movhi	r2,128
 3214524:	10bfffc4 	addi	r2,r2,-1
 3214528:	308c703a 	and	r6,r6,r2
 321452c:	003fbf06 	br	321442c <__pack_f+0x30>
 3214530:	0007883a 	mov	r3,zero
 3214534:	000d883a 	mov	r6,zero
 3214538:	003ff906 	br	3214520 <__pack_f+0x124>
 321453c:	1880200c 	andi	r2,r3,128
 3214540:	10000126 	beq	r2,zero,3214548 <__pack_f+0x14c>
 3214544:	1907883a 	add	r3,r3,r4
 3214548:	180cd1fa 	srli	r6,r3,7
 321454c:	00900034 	movhi	r2,16384
 3214550:	10bfffc4 	addi	r2,r2,-1
 3214554:	10c7803a 	cmpltu	r3,r2,r3
 3214558:	003ff106 	br	3214520 <__pack_f+0x124>

0321455c <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 321455c:	defffb04 	addi	sp,sp,-20
 3214560:	dfc00415 	stw	ra,16(sp)
 3214564:	df000315 	stw	fp,12(sp)
 3214568:	df000304 	addi	fp,sp,12
 321456c:	e13ffe15 	stw	r4,-8(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 3214570:	e13ffe17 	ldw	r4,-8(fp)
 3214574:	d1600704 	addi	r5,gp,-32740
 3214578:	323a4f40 	call	323a4f4 <alt_find_dev>
 321457c:	e0bffd15 	stw	r2,-12(fp)

  if ((dev) && dev->open)
 3214580:	e0bffd17 	ldw	r2,-12(fp)
 3214584:	1005003a 	cmpeq	r2,r2,zero
 3214588:	10000b1e 	bne	r2,zero,32145b8 <alt_flash_open_dev+0x5c>
 321458c:	e0bffd17 	ldw	r2,-12(fp)
 3214590:	10800317 	ldw	r2,12(r2)
 3214594:	1005003a 	cmpeq	r2,r2,zero
 3214598:	1000071e 	bne	r2,zero,32145b8 <alt_flash_open_dev+0x5c>
  {
    return dev->open(dev, name);
 321459c:	e0bffd17 	ldw	r2,-12(fp)
 32145a0:	10800317 	ldw	r2,12(r2)
 32145a4:	e13ffd17 	ldw	r4,-12(fp)
 32145a8:	e17ffe17 	ldw	r5,-8(fp)
 32145ac:	103ee83a 	callr	r2
 32145b0:	e0bfff15 	stw	r2,-4(fp)
 32145b4:	00000206 	br	32145c0 <alt_flash_open_dev+0x64>
  }

  return dev;
 32145b8:	e0bffd17 	ldw	r2,-12(fp)
 32145bc:	e0bfff15 	stw	r2,-4(fp)
 32145c0:	e0bfff17 	ldw	r2,-4(fp)
}
 32145c4:	e037883a 	mov	sp,fp
 32145c8:	dfc00117 	ldw	ra,4(sp)
 32145cc:	df000017 	ldw	fp,0(sp)
 32145d0:	dec00204 	addi	sp,sp,8
 32145d4:	f800283a 	ret

032145d8 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 32145d8:	defffd04 	addi	sp,sp,-12
 32145dc:	dfc00215 	stw	ra,8(sp)
 32145e0:	df000115 	stw	fp,4(sp)
 32145e4:	df000104 	addi	fp,sp,4
 32145e8:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 32145ec:	e0bfff17 	ldw	r2,-4(fp)
 32145f0:	1005003a 	cmpeq	r2,r2,zero
 32145f4:	1000081e 	bne	r2,zero,3214618 <alt_flash_close_dev+0x40>
 32145f8:	e0bfff17 	ldw	r2,-4(fp)
 32145fc:	10800417 	ldw	r2,16(r2)
 3214600:	1005003a 	cmpeq	r2,r2,zero
 3214604:	1000041e 	bne	r2,zero,3214618 <alt_flash_close_dev+0x40>
  {
    fd->close(fd);
 3214608:	e0bfff17 	ldw	r2,-4(fp)
 321460c:	10800417 	ldw	r2,16(r2)
 3214610:	e13fff17 	ldw	r4,-4(fp)
 3214614:	103ee83a 	callr	r2
  }
  return;
}
 3214618:	e037883a 	mov	sp,fp
 321461c:	dfc00117 	ldw	ra,4(sp)
 3214620:	df000017 	ldw	fp,0(sp)
 3214624:	dec00204 	addi	sp,sp,8
 3214628:	f800283a 	ret

0321462c <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 321462c:	defff904 	addi	sp,sp,-28
 3214630:	dfc00615 	stw	ra,24(sp)
 3214634:	df000515 	stw	fp,20(sp)
 3214638:	df000504 	addi	fp,sp,20
 321463c:	e13ffc15 	stw	r4,-16(fp)
 3214640:	e17ffd15 	stw	r5,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 3214644:	e0bffc17 	ldw	r2,-16(fp)
 3214648:	1004803a 	cmplt	r2,r2,zero
 321464c:	1000081e 	bne	r2,zero,3214670 <fstat+0x44>
 3214650:	e0bffc17 	ldw	r2,-16(fp)
 3214654:	10800324 	muli	r2,r2,12
 3214658:	1007883a 	mov	r3,r2
 321465c:	0080c974 	movhi	r2,805
 3214660:	10888304 	addi	r2,r2,8716
 3214664:	1887883a 	add	r3,r3,r2
 3214668:	e0ffff15 	stw	r3,-4(fp)
 321466c:	00000106 	br	3214674 <fstat+0x48>
 3214670:	e03fff15 	stw	zero,-4(fp)
 3214674:	e0bfff17 	ldw	r2,-4(fp)
 3214678:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 321467c:	e0bffb17 	ldw	r2,-20(fp)
 3214680:	1005003a 	cmpeq	r2,r2,zero
 3214684:	1000121e 	bne	r2,zero,32146d0 <fstat+0xa4>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 3214688:	e0bffb17 	ldw	r2,-20(fp)
 321468c:	10800017 	ldw	r2,0(r2)
 3214690:	10800817 	ldw	r2,32(r2)
 3214694:	1005003a 	cmpeq	r2,r2,zero
 3214698:	1000081e 	bne	r2,zero,32146bc <fstat+0x90>
    {
      return fd->dev->fstat(fd, st);
 321469c:	e0bffb17 	ldw	r2,-20(fp)
 32146a0:	10800017 	ldw	r2,0(r2)
 32146a4:	10800817 	ldw	r2,32(r2)
 32146a8:	e13ffb17 	ldw	r4,-20(fp)
 32146ac:	e17ffd17 	ldw	r5,-12(fp)
 32146b0:	103ee83a 	callr	r2
 32146b4:	e0bffe15 	stw	r2,-8(fp)
 32146b8:	00000b06 	br	32146e8 <fstat+0xbc>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 32146bc:	e0fffd17 	ldw	r3,-12(fp)
 32146c0:	00880004 	movi	r2,8192
 32146c4:	18800115 	stw	r2,4(r3)
      return 0;
 32146c8:	e03ffe15 	stw	zero,-8(fp)
 32146cc:	00000606 	br	32146e8 <fstat+0xbc>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 32146d0:	32147000 	call	3214700 <alt_get_errno>
 32146d4:	1007883a 	mov	r3,r2
 32146d8:	00801444 	movi	r2,81
 32146dc:	18800015 	stw	r2,0(r3)
    return -1;
 32146e0:	00bfffc4 	movi	r2,-1
 32146e4:	e0bffe15 	stw	r2,-8(fp)
 32146e8:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 32146ec:	e037883a 	mov	sp,fp
 32146f0:	dfc00117 	ldw	ra,4(sp)
 32146f4:	df000017 	ldw	fp,0(sp)
 32146f8:	dec00204 	addi	sp,sp,8
 32146fc:	f800283a 	ret

03214700 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 3214700:	defffd04 	addi	sp,sp,-12
 3214704:	dfc00215 	stw	ra,8(sp)
 3214708:	df000115 	stw	fp,4(sp)
 321470c:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 3214710:	0080c974 	movhi	r2,805
 3214714:	1089ba04 	addi	r2,r2,9960
 3214718:	10800017 	ldw	r2,0(r2)
 321471c:	1005003a 	cmpeq	r2,r2,zero
 3214720:	1000061e 	bne	r2,zero,321473c <alt_get_errno+0x3c>
 3214724:	0080c974 	movhi	r2,805
 3214728:	1089ba04 	addi	r2,r2,9960
 321472c:	10800017 	ldw	r2,0(r2)
 3214730:	103ee83a 	callr	r2
 3214734:	e0bfff15 	stw	r2,-4(fp)
 3214738:	00000306 	br	3214748 <alt_get_errno+0x48>
 321473c:	0080c974 	movhi	r2,805
 3214740:	10920d04 	addi	r2,r2,18484
 3214744:	e0bfff15 	stw	r2,-4(fp)
 3214748:	e0bfff17 	ldw	r2,-4(fp)
}
 321474c:	e037883a 	mov	sp,fp
 3214750:	dfc00117 	ldw	ra,4(sp)
 3214754:	df000017 	ldw	fp,0(sp)
 3214758:	dec00204 	addi	sp,sp,8
 321475c:	f800283a 	ret

03214760 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 3214760:	deffeb04 	addi	sp,sp,-84
 3214764:	dfc01415 	stw	ra,80(sp)
 3214768:	df001315 	stw	fp,76(sp)
 321476c:	df001304 	addi	fp,sp,76
 3214770:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 3214774:	e0bffd17 	ldw	r2,-12(fp)
 3214778:	1004803a 	cmplt	r2,r2,zero
 321477c:	1000081e 	bne	r2,zero,32147a0 <isatty+0x40>
 3214780:	e0bffd17 	ldw	r2,-12(fp)
 3214784:	10800324 	muli	r2,r2,12
 3214788:	1007883a 	mov	r3,r2
 321478c:	0080c974 	movhi	r2,805
 3214790:	10888304 	addi	r2,r2,8716
 3214794:	1887883a 	add	r3,r3,r2
 3214798:	e0ffff15 	stw	r3,-4(fp)
 321479c:	00000106 	br	32147a4 <isatty+0x44>
 32147a0:	e03fff15 	stw	zero,-4(fp)
 32147a4:	e0bfff17 	ldw	r2,-4(fp)
 32147a8:	e0bfed15 	stw	r2,-76(fp)
  
  if (fd)
 32147ac:	e0bfed17 	ldw	r2,-76(fp)
 32147b0:	1005003a 	cmpeq	r2,r2,zero
 32147b4:	10000f1e 	bne	r2,zero,32147f4 <isatty+0x94>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 32147b8:	e0bfed17 	ldw	r2,-76(fp)
 32147bc:	10800017 	ldw	r2,0(r2)
 32147c0:	10800817 	ldw	r2,32(r2)
 32147c4:	1004c03a 	cmpne	r2,r2,zero
 32147c8:	1000031e 	bne	r2,zero,32147d8 <isatty+0x78>
    {
      return 1;
 32147cc:	00800044 	movi	r2,1
 32147d0:	e0bffe15 	stw	r2,-8(fp)
 32147d4:	00000c06 	br	3214808 <isatty+0xa8>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 32147d8:	e17fee04 	addi	r5,fp,-72
 32147dc:	e13ffd17 	ldw	r4,-12(fp)
 32147e0:	321462c0 	call	321462c <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 32147e4:	e0bfef17 	ldw	r2,-68(fp)
 32147e8:	10880020 	cmpeqi	r2,r2,8192
 32147ec:	e0bffe15 	stw	r2,-8(fp)
 32147f0:	00000506 	br	3214808 <isatty+0xa8>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 32147f4:	32148200 	call	3214820 <alt_get_errno>
 32147f8:	1007883a 	mov	r3,r2
 32147fc:	00801444 	movi	r2,81
 3214800:	18800015 	stw	r2,0(r3)
    return 0;
 3214804:	e03ffe15 	stw	zero,-8(fp)
 3214808:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 321480c:	e037883a 	mov	sp,fp
 3214810:	dfc00117 	ldw	ra,4(sp)
 3214814:	df000017 	ldw	fp,0(sp)
 3214818:	dec00204 	addi	sp,sp,8
 321481c:	f800283a 	ret

03214820 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 3214820:	defffd04 	addi	sp,sp,-12
 3214824:	dfc00215 	stw	ra,8(sp)
 3214828:	df000115 	stw	fp,4(sp)
 321482c:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 3214830:	0080c974 	movhi	r2,805
 3214834:	1089ba04 	addi	r2,r2,9960
 3214838:	10800017 	ldw	r2,0(r2)
 321483c:	1005003a 	cmpeq	r2,r2,zero
 3214840:	1000061e 	bne	r2,zero,321485c <alt_get_errno+0x3c>
 3214844:	0080c974 	movhi	r2,805
 3214848:	1089ba04 	addi	r2,r2,9960
 321484c:	10800017 	ldw	r2,0(r2)
 3214850:	103ee83a 	callr	r2
 3214854:	e0bfff15 	stw	r2,-4(fp)
 3214858:	00000306 	br	3214868 <alt_get_errno+0x48>
 321485c:	0080c974 	movhi	r2,805
 3214860:	10920d04 	addi	r2,r2,18484
 3214864:	e0bfff15 	stw	r2,-4(fp)
 3214868:	e0bfff17 	ldw	r2,-4(fp)
}
 321486c:	e037883a 	mov	sp,fp
 3214870:	dfc00117 	ldw	ra,4(sp)
 3214874:	df000017 	ldw	fp,0(sp)
 3214878:	dec00204 	addi	sp,sp,8
 321487c:	f800283a 	ret

03214880 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 3214880:	defffe04 	addi	sp,sp,-8
 3214884:	dfc00115 	stw	ra,4(sp)
 3214888:	df000015 	stw	fp,0(sp)
 321488c:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 3214890:	0100c974 	movhi	r4,805
 3214894:	2109c904 	addi	r4,r4,10020
 3214898:	0140c974 	movhi	r5,805
 321489c:	29418a04 	addi	r5,r5,1576
 32148a0:	0180c974 	movhi	r6,805
 32148a4:	3189c904 	addi	r6,r6,10020
 32148a8:	32149000 	call	3214900 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 32148ac:	0100c834 	movhi	r4,800
 32148b0:	21000804 	addi	r4,r4,32
 32148b4:	0140c834 	movhi	r5,800
 32148b8:	29400804 	addi	r5,r5,32
 32148bc:	0180c834 	movhi	r6,800
 32148c0:	31807004 	addi	r6,r6,448
 32148c4:	32149000 	call	3214900 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 32148c8:	0100c974 	movhi	r4,805
 32148cc:	21301d04 	addi	r4,r4,-16268
 32148d0:	0140c974 	movhi	r5,805
 32148d4:	29701d04 	addi	r5,r5,-16268
 32148d8:	0180c974 	movhi	r6,805
 32148dc:	31818a04 	addi	r6,r6,1576
 32148e0:	32149000 	call	3214900 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 32148e4:	323a2a80 	call	323a2a8 <alt_dcache_flush_all>
  alt_icache_flush_all();
 32148e8:	323a79c0 	call	323a79c <alt_icache_flush_all>
}
 32148ec:	e037883a 	mov	sp,fp
 32148f0:	dfc00117 	ldw	ra,4(sp)
 32148f4:	df000017 	ldw	fp,0(sp)
 32148f8:	dec00204 	addi	sp,sp,8
 32148fc:	f800283a 	ret

03214900 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 3214900:	defffc04 	addi	sp,sp,-16
 3214904:	df000315 	stw	fp,12(sp)
 3214908:	df000304 	addi	fp,sp,12
 321490c:	e13ffd15 	stw	r4,-12(fp)
 3214910:	e17ffe15 	stw	r5,-8(fp)
 3214914:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 3214918:	e0fffe17 	ldw	r3,-8(fp)
 321491c:	e0bffd17 	ldw	r2,-12(fp)
 3214920:	18800e26 	beq	r3,r2,321495c <alt_load_section+0x5c>
  {
    while( to != end )
 3214924:	00000a06 	br	3214950 <alt_load_section+0x50>
    {
      *to++ = *from++;
 3214928:	e0bffd17 	ldw	r2,-12(fp)
 321492c:	10c00017 	ldw	r3,0(r2)
 3214930:	e0bffe17 	ldw	r2,-8(fp)
 3214934:	10c00015 	stw	r3,0(r2)
 3214938:	e0bffe17 	ldw	r2,-8(fp)
 321493c:	10800104 	addi	r2,r2,4
 3214940:	e0bffe15 	stw	r2,-8(fp)
 3214944:	e0bffd17 	ldw	r2,-12(fp)
 3214948:	10800104 	addi	r2,r2,4
 321494c:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 3214950:	e0fffe17 	ldw	r3,-8(fp)
 3214954:	e0bfff17 	ldw	r2,-4(fp)
 3214958:	18bff31e 	bne	r3,r2,3214928 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
 321495c:	e037883a 	mov	sp,fp
 3214960:	df000017 	ldw	fp,0(sp)
 3214964:	dec00104 	addi	sp,sp,4
 3214968:	f800283a 	ret

0321496c <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 321496c:	defff804 	addi	sp,sp,-32
 3214970:	dfc00715 	stw	ra,28(sp)
 3214974:	df000615 	stw	fp,24(sp)
 3214978:	df000604 	addi	fp,sp,24
 321497c:	e13ffc15 	stw	r4,-16(fp)
 3214980:	e17ffd15 	stw	r5,-12(fp)
 3214984:	e1bffe15 	stw	r6,-8(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 3214988:	e03ffa15 	stw	zero,-24(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 321498c:	e0bffc17 	ldw	r2,-16(fp)
 3214990:	1004803a 	cmplt	r2,r2,zero
 3214994:	1000081e 	bne	r2,zero,32149b8 <lseek+0x4c>
 3214998:	e0bffc17 	ldw	r2,-16(fp)
 321499c:	10800324 	muli	r2,r2,12
 32149a0:	1007883a 	mov	r3,r2
 32149a4:	0080c974 	movhi	r2,805
 32149a8:	10888304 	addi	r2,r2,8716
 32149ac:	1887883a 	add	r3,r3,r2
 32149b0:	e0ffff15 	stw	r3,-4(fp)
 32149b4:	00000106 	br	32149bc <lseek+0x50>
 32149b8:	e03fff15 	stw	zero,-4(fp)
 32149bc:	e0bfff17 	ldw	r2,-4(fp)
 32149c0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd) 
 32149c4:	e0bffb17 	ldw	r2,-20(fp)
 32149c8:	1005003a 	cmpeq	r2,r2,zero
 32149cc:	1000111e 	bne	r2,zero,3214a14 <lseek+0xa8>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 32149d0:	e0bffb17 	ldw	r2,-20(fp)
 32149d4:	10800017 	ldw	r2,0(r2)
 32149d8:	10800717 	ldw	r2,28(r2)
 32149dc:	1005003a 	cmpeq	r2,r2,zero
 32149e0:	1000091e 	bne	r2,zero,3214a08 <lseek+0x9c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 32149e4:	e0bffb17 	ldw	r2,-20(fp)
 32149e8:	10800017 	ldw	r2,0(r2)
 32149ec:	10800717 	ldw	r2,28(r2)
 32149f0:	e13ffb17 	ldw	r4,-20(fp)
 32149f4:	e17ffd17 	ldw	r5,-12(fp)
 32149f8:	e1bffe17 	ldw	r6,-8(fp)
 32149fc:	103ee83a 	callr	r2
 3214a00:	e0bffa15 	stw	r2,-24(fp)
 3214a04:	00000506 	br	3214a1c <lseek+0xb0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 3214a08:	00bfde84 	movi	r2,-134
 3214a0c:	e0bffa15 	stw	r2,-24(fp)
 3214a10:	00000206 	br	3214a1c <lseek+0xb0>
    }
  }
  else  
  {
    rc = -EBADFD;
 3214a14:	00bfebc4 	movi	r2,-81
 3214a18:	e0bffa15 	stw	r2,-24(fp)
  }

  if (rc < 0)
 3214a1c:	e0bffa17 	ldw	r2,-24(fp)
 3214a20:	1004403a 	cmpge	r2,r2,zero
 3214a24:	1000071e 	bne	r2,zero,3214a44 <lseek+0xd8>
  {
    ALT_ERRNO = -rc;
 3214a28:	3214a5c0 	call	3214a5c <alt_get_errno>
 3214a2c:	1007883a 	mov	r3,r2
 3214a30:	e0bffa17 	ldw	r2,-24(fp)
 3214a34:	0085c83a 	sub	r2,zero,r2
 3214a38:	18800015 	stw	r2,0(r3)
    rc = -1;
 3214a3c:	00bfffc4 	movi	r2,-1
 3214a40:	e0bffa15 	stw	r2,-24(fp)
  }

  return rc;
 3214a44:	e0bffa17 	ldw	r2,-24(fp)
}
 3214a48:	e037883a 	mov	sp,fp
 3214a4c:	dfc00117 	ldw	ra,4(sp)
 3214a50:	df000017 	ldw	fp,0(sp)
 3214a54:	dec00204 	addi	sp,sp,8
 3214a58:	f800283a 	ret

03214a5c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 3214a5c:	defffd04 	addi	sp,sp,-12
 3214a60:	dfc00215 	stw	ra,8(sp)
 3214a64:	df000115 	stw	fp,4(sp)
 3214a68:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 3214a6c:	0080c974 	movhi	r2,805
 3214a70:	1089ba04 	addi	r2,r2,9960
 3214a74:	10800017 	ldw	r2,0(r2)
 3214a78:	1005003a 	cmpeq	r2,r2,zero
 3214a7c:	1000061e 	bne	r2,zero,3214a98 <alt_get_errno+0x3c>
 3214a80:	0080c974 	movhi	r2,805
 3214a84:	1089ba04 	addi	r2,r2,9960
 3214a88:	10800017 	ldw	r2,0(r2)
 3214a8c:	103ee83a 	callr	r2
 3214a90:	e0bfff15 	stw	r2,-4(fp)
 3214a94:	00000306 	br	3214aa4 <alt_get_errno+0x48>
 3214a98:	0080c974 	movhi	r2,805
 3214a9c:	10920d04 	addi	r2,r2,18484
 3214aa0:	e0bfff15 	stw	r2,-4(fp)
 3214aa4:	e0bfff17 	ldw	r2,-4(fp)
}
 3214aa8:	e037883a 	mov	sp,fp
 3214aac:	dfc00117 	ldw	ra,4(sp)
 3214ab0:	df000017 	ldw	fp,0(sp)
 3214ab4:	dec00204 	addi	sp,sp,8
 3214ab8:	f800283a 	ret

03214abc <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 3214abc:	defffb04 	addi	sp,sp,-20
 3214ac0:	dfc00415 	stw	ra,16(sp)
 3214ac4:	df000315 	stw	fp,12(sp)
 3214ac8:	df000304 	addi	fp,sp,12
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 3214acc:	0009883a 	mov	r4,zero
 3214ad0:	321d5100 	call	321d510 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 3214ad4:	3215b6c0 	call	3215b6c <OSInit>
 3214ad8:	01000044 	movi	r4,1
 3214adc:	321aa300 	call	321aa30 <OSSemCreate>
 3214ae0:	1007883a 	mov	r3,r2
 3214ae4:	0080c974 	movhi	r2,805
 3214ae8:	10921804 	addi	r2,r2,18528
 3214aec:	10c00015 	stw	r3,0(r2)
 3214af0:	01000044 	movi	r4,1
 3214af4:	321aa300 	call	321aa30 <OSSemCreate>
 3214af8:	1007883a 	mov	r3,r2
 3214afc:	0080c974 	movhi	r2,805
 3214b00:	10921a04 	addi	r2,r2,18536
 3214b04:	10c00015 	stw	r3,0(r2)
 3214b08:	0080c974 	movhi	r2,805
 3214b0c:	10926404 	addi	r2,r2,18832
 3214b10:	e0bffd15 	stw	r2,-12(fp)
 3214b14:	00800044 	movi	r2,1
 3214b18:	e0bffe0d 	sth	r2,-8(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 3214b1c:	e13ffe0b 	ldhu	r4,-8(fp)
 3214b20:	321aa300 	call	321aa30 <OSSemCreate>
 3214b24:	1007883a 	mov	r3,r2
 3214b28:	e0bffd17 	ldw	r2,-12(fp)
 3214b2c:	10c00015 	stw	r3,0(r2)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 3214b30:	321d5440 	call	321d544 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 3214b34:	0100c974 	movhi	r4,805
 3214b38:	21388b04 	addi	r4,r4,-7636
 3214b3c:	0140c974 	movhi	r5,805
 3214b40:	29788b04 	addi	r5,r5,-7636
 3214b44:	0180c974 	movhi	r6,805
 3214b48:	31b88b04 	addi	r6,r6,-7636
 3214b4c:	323a8900 	call	323a890 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 3214b50:	323a42c0 	call	323a42c <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 3214b54:	0100c934 	movhi	r4,804
 3214b58:	21292404 	addi	r4,r4,-23408
 3214b5c:	324b8b40 	call	324b8b4 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 3214b60:	d1289d17 	ldw	r4,-23948(gp)
 3214b64:	d1689e17 	ldw	r5,-23944(gp)
 3214b68:	d1a89f17 	ldw	r6,-23940(gp)
 3214b6c:	32017800 	call	3201780 <main>
 3214b70:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 3214b74:	01000044 	movi	r4,1
 3214b78:	32227dc0 	call	32227dc <close>
  exit (result);
 3214b7c:	e13fff17 	ldw	r4,-4(fp)
 3214b80:	324b8fc0 	call	324b8fc <exit>

03214b84 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 3214b84:	defffc04 	addi	sp,sp,-16
 3214b88:	df000315 	stw	fp,12(sp)
 3214b8c:	df000304 	addi	fp,sp,12
 3214b90:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 3214b94:	e0bffe17 	ldw	r2,-8(fp)
 3214b98:	10800217 	ldw	r2,8(r2)
 3214b9c:	10d00034 	orhi	r3,r2,16384
 3214ba0:	e0bffe17 	ldw	r2,-8(fp)
 3214ba4:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 3214ba8:	e03ffd15 	stw	zero,-12(fp)
 3214bac:	00002006 	br	3214c30 <alt_file_locked+0xac>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 3214bb0:	e0bffd17 	ldw	r2,-12(fp)
 3214bb4:	00c0c974 	movhi	r3,805
 3214bb8:	18c88304 	addi	r3,r3,8716
 3214bbc:	10800324 	muli	r2,r2,12
 3214bc0:	10c5883a 	add	r2,r2,r3
 3214bc4:	10c00017 	ldw	r3,0(r2)
 3214bc8:	e0bffe17 	ldw	r2,-8(fp)
 3214bcc:	10800017 	ldw	r2,0(r2)
 3214bd0:	1880141e 	bne	r3,r2,3214c24 <alt_file_locked+0xa0>
 3214bd4:	e0bffd17 	ldw	r2,-12(fp)
 3214bd8:	00c0c974 	movhi	r3,805
 3214bdc:	18c88304 	addi	r3,r3,8716
 3214be0:	10800324 	muli	r2,r2,12
 3214be4:	10c5883a 	add	r2,r2,r3
 3214be8:	10800204 	addi	r2,r2,8
 3214bec:	10800017 	ldw	r2,0(r2)
 3214bf0:	1004403a 	cmpge	r2,r2,zero
 3214bf4:	10000b1e 	bne	r2,zero,3214c24 <alt_file_locked+0xa0>
 3214bf8:	e0bffd17 	ldw	r2,-12(fp)
 3214bfc:	10800324 	muli	r2,r2,12
 3214c00:	1007883a 	mov	r3,r2
 3214c04:	0080c974 	movhi	r2,805
 3214c08:	10888304 	addi	r2,r2,8716
 3214c0c:	1887883a 	add	r3,r3,r2
 3214c10:	e0bffe17 	ldw	r2,-8(fp)
 3214c14:	18800326 	beq	r3,r2,3214c24 <alt_file_locked+0xa0>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 3214c18:	00bffcc4 	movi	r2,-13
 3214c1c:	e0bfff15 	stw	r2,-4(fp)
 3214c20:	00000a06 	br	3214c4c <alt_file_locked+0xc8>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 3214c24:	e0bffd17 	ldw	r2,-12(fp)
 3214c28:	10800044 	addi	r2,r2,1
 3214c2c:	e0bffd15 	stw	r2,-12(fp)
 3214c30:	0080c974 	movhi	r2,805
 3214c34:	1089b904 	addi	r2,r2,9956
 3214c38:	10800017 	ldw	r2,0(r2)
 3214c3c:	1007883a 	mov	r3,r2
 3214c40:	e0bffd17 	ldw	r2,-12(fp)
 3214c44:	18bfda2e 	bgeu	r3,r2,3214bb0 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 3214c48:	e03fff15 	stw	zero,-4(fp)
 3214c4c:	e0bfff17 	ldw	r2,-4(fp)
}
 3214c50:	e037883a 	mov	sp,fp
 3214c54:	df000017 	ldw	fp,0(sp)
 3214c58:	dec00104 	addi	sp,sp,4
 3214c5c:	f800283a 	ret

03214c60 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 3214c60:	defff404 	addi	sp,sp,-48
 3214c64:	dfc00b15 	stw	ra,44(sp)
 3214c68:	df000a15 	stw	fp,40(sp)
 3214c6c:	df000a04 	addi	fp,sp,40
 3214c70:	e13ffb15 	stw	r4,-20(fp)
 3214c74:	e17ffc15 	stw	r5,-16(fp)
 3214c78:	e1bffd15 	stw	r6,-12(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 3214c7c:	00bfffc4 	movi	r2,-1
 3214c80:	e0bff815 	stw	r2,-32(fp)
  int status = -ENODEV;
 3214c84:	00bffb44 	movi	r2,-19
 3214c88:	e0bff715 	stw	r2,-36(fp)
  int isafs = 0;
 3214c8c:	e03ff615 	stw	zero,-40(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 3214c90:	e13ffb17 	ldw	r4,-20(fp)
 3214c94:	0140c974 	movhi	r5,805
 3214c98:	2949b704 	addi	r5,r5,9948
 3214c9c:	323a4f40 	call	323a4f4 <alt_find_dev>
 3214ca0:	e0bffa15 	stw	r2,-24(fp)
 3214ca4:	e0bffa17 	ldw	r2,-24(fp)
 3214ca8:	1004c03a 	cmpne	r2,r2,zero
 3214cac:	1000051e 	bne	r2,zero,3214cc4 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 3214cb0:	e13ffb17 	ldw	r4,-20(fp)
 3214cb4:	323a5880 	call	323a588 <alt_find_file>
 3214cb8:	e0bffa15 	stw	r2,-24(fp)
    isafs = 1;
 3214cbc:	00800044 	movi	r2,1
 3214cc0:	e0bff615 	stw	r2,-40(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 3214cc4:	e0bffa17 	ldw	r2,-24(fp)
 3214cc8:	1005003a 	cmpeq	r2,r2,zero
 3214ccc:	1000301e 	bne	r2,zero,3214d90 <open+0x130>
  {
    if ((index = alt_get_fd (dev)) < 0)
 3214cd0:	e13ffa17 	ldw	r4,-24(fp)
 3214cd4:	323a6a80 	call	323a6a8 <alt_get_fd>
 3214cd8:	e0bff815 	stw	r2,-32(fp)
 3214cdc:	e0bff817 	ldw	r2,-32(fp)
 3214ce0:	1004403a 	cmpge	r2,r2,zero
 3214ce4:	1000031e 	bne	r2,zero,3214cf4 <open+0x94>
    {
      status = index;
 3214ce8:	e0bff817 	ldw	r2,-32(fp)
 3214cec:	e0bff715 	stw	r2,-36(fp)
 3214cf0:	00002906 	br	3214d98 <open+0x138>
    }
    else
    {
      fd = &alt_fd_list[index];
 3214cf4:	e0bff817 	ldw	r2,-32(fp)
 3214cf8:	10800324 	muli	r2,r2,12
 3214cfc:	1007883a 	mov	r3,r2
 3214d00:	0080c974 	movhi	r2,805
 3214d04:	10888304 	addi	r2,r2,8716
 3214d08:	1885883a 	add	r2,r3,r2
 3214d0c:	e0bff915 	stw	r2,-28(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 3214d10:	e0fffc17 	ldw	r3,-16(fp)
 3214d14:	00900034 	movhi	r2,16384
 3214d18:	10bfffc4 	addi	r2,r2,-1
 3214d1c:	1886703a 	and	r3,r3,r2
 3214d20:	e0bff917 	ldw	r2,-28(fp)
 3214d24:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 3214d28:	e0bff617 	ldw	r2,-40(fp)
 3214d2c:	1004c03a 	cmpne	r2,r2,zero
 3214d30:	1000061e 	bne	r2,zero,3214d4c <open+0xec>
 3214d34:	e13ff917 	ldw	r4,-28(fp)
 3214d38:	3214b840 	call	3214b84 <alt_file_locked>
 3214d3c:	e0bff715 	stw	r2,-36(fp)
 3214d40:	e0bff717 	ldw	r2,-36(fp)
 3214d44:	1004803a 	cmplt	r2,r2,zero
 3214d48:	1000131e 	bne	r2,zero,3214d98 <open+0x138>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 3214d4c:	e0bffa17 	ldw	r2,-24(fp)
 3214d50:	10800317 	ldw	r2,12(r2)
 3214d54:	1005003a 	cmpeq	r2,r2,zero
 3214d58:	1000091e 	bne	r2,zero,3214d80 <open+0x120>
 3214d5c:	e0bffa17 	ldw	r2,-24(fp)
 3214d60:	10800317 	ldw	r2,12(r2)
 3214d64:	e13ff917 	ldw	r4,-28(fp)
 3214d68:	e17ffb17 	ldw	r5,-20(fp)
 3214d6c:	e1bffc17 	ldw	r6,-16(fp)
 3214d70:	e1fffd17 	ldw	r7,-12(fp)
 3214d74:	103ee83a 	callr	r2
 3214d78:	e0bfff15 	stw	r2,-4(fp)
 3214d7c:	00000106 	br	3214d84 <open+0x124>
 3214d80:	e03fff15 	stw	zero,-4(fp)
 3214d84:	e0bfff17 	ldw	r2,-4(fp)
 3214d88:	e0bff715 	stw	r2,-36(fp)
 3214d8c:	00000206 	br	3214d98 <open+0x138>
      }
    }
  }
  else
  {
    status = -ENODEV;
 3214d90:	00bffb44 	movi	r2,-19
 3214d94:	e0bff715 	stw	r2,-36(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 3214d98:	e0bff717 	ldw	r2,-36(fp)
 3214d9c:	1004403a 	cmpge	r2,r2,zero
 3214da0:	1000091e 	bne	r2,zero,3214dc8 <open+0x168>
  {
    alt_release_fd (index);  
 3214da4:	e13ff817 	ldw	r4,-32(fp)
 3214da8:	3214e480 	call	3214e48 <alt_release_fd>
    ALT_ERRNO = -status;
 3214dac:	3214de80 	call	3214de8 <alt_get_errno>
 3214db0:	e0fff717 	ldw	r3,-36(fp)
 3214db4:	00c7c83a 	sub	r3,zero,r3
 3214db8:	10c00015 	stw	r3,0(r2)
    return -1;
 3214dbc:	00bfffc4 	movi	r2,-1
 3214dc0:	e0bffe15 	stw	r2,-8(fp)
 3214dc4:	00000206 	br	3214dd0 <open+0x170>
  }
  
  /* return the reference upon success */

  return index;
 3214dc8:	e0bff817 	ldw	r2,-32(fp)
 3214dcc:	e0bffe15 	stw	r2,-8(fp)
 3214dd0:	e0bffe17 	ldw	r2,-8(fp)
}
 3214dd4:	e037883a 	mov	sp,fp
 3214dd8:	dfc00117 	ldw	ra,4(sp)
 3214ddc:	df000017 	ldw	fp,0(sp)
 3214de0:	dec00204 	addi	sp,sp,8
 3214de4:	f800283a 	ret

03214de8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 3214de8:	defffd04 	addi	sp,sp,-12
 3214dec:	dfc00215 	stw	ra,8(sp)
 3214df0:	df000115 	stw	fp,4(sp)
 3214df4:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 3214df8:	0080c974 	movhi	r2,805
 3214dfc:	1089ba04 	addi	r2,r2,9960
 3214e00:	10800017 	ldw	r2,0(r2)
 3214e04:	1005003a 	cmpeq	r2,r2,zero
 3214e08:	1000061e 	bne	r2,zero,3214e24 <alt_get_errno+0x3c>
 3214e0c:	0080c974 	movhi	r2,805
 3214e10:	1089ba04 	addi	r2,r2,9960
 3214e14:	10800017 	ldw	r2,0(r2)
 3214e18:	103ee83a 	callr	r2
 3214e1c:	e0bfff15 	stw	r2,-4(fp)
 3214e20:	00000306 	br	3214e30 <alt_get_errno+0x48>
 3214e24:	0080c974 	movhi	r2,805
 3214e28:	10920d04 	addi	r2,r2,18484
 3214e2c:	e0bfff15 	stw	r2,-4(fp)
 3214e30:	e0bfff17 	ldw	r2,-4(fp)
}
 3214e34:	e037883a 	mov	sp,fp
 3214e38:	dfc00117 	ldw	ra,4(sp)
 3214e3c:	df000017 	ldw	fp,0(sp)
 3214e40:	dec00204 	addi	sp,sp,8
 3214e44:	f800283a 	ret

03214e48 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 3214e48:	defffe04 	addi	sp,sp,-8
 3214e4c:	df000115 	stw	fp,4(sp)
 3214e50:	df000104 	addi	fp,sp,4
 3214e54:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 3214e58:	e0bfff17 	ldw	r2,-4(fp)
 3214e5c:	108000d0 	cmplti	r2,r2,3
 3214e60:	10000d1e 	bne	r2,zero,3214e98 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 3214e64:	e0bfff17 	ldw	r2,-4(fp)
 3214e68:	00c0c974 	movhi	r3,805
 3214e6c:	18c88304 	addi	r3,r3,8716
 3214e70:	10800324 	muli	r2,r2,12
 3214e74:	10c5883a 	add	r2,r2,r3
 3214e78:	10800204 	addi	r2,r2,8
 3214e7c:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 3214e80:	e0bfff17 	ldw	r2,-4(fp)
 3214e84:	00c0c974 	movhi	r3,805
 3214e88:	18c88304 	addi	r3,r3,8716
 3214e8c:	10800324 	muli	r2,r2,12
 3214e90:	10c5883a 	add	r2,r2,r3
 3214e94:	10000015 	stw	zero,0(r2)
  }
}
 3214e98:	e037883a 	mov	sp,fp
 3214e9c:	df000017 	ldw	fp,0(sp)
 3214ea0:	dec00104 	addi	sp,sp,4
 3214ea4:	f800283a 	ret

03214ea8 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 3214ea8:	defff804 	addi	sp,sp,-32
 3214eac:	df000715 	stw	fp,28(sp)
 3214eb0:	df000704 	addi	fp,sp,28
 3214eb4:	e13ffe15 	stw	r4,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3214eb8:	0005303a 	rdctl	r2,status
 3214ebc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3214ec0:	e0fffb17 	ldw	r3,-20(fp)
 3214ec4:	00bfff84 	movi	r2,-2
 3214ec8:	1884703a 	and	r2,r3,r2
 3214ecc:	1001703a 	wrctl	status,r2
  
  return context;
 3214ed0:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 3214ed4:	e0bffd15 	stw	r2,-12(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 3214ed8:	d0a00917 	ldw	r2,-32732(gp)
 3214edc:	10c000c4 	addi	r3,r2,3
 3214ee0:	00bfff04 	movi	r2,-4
 3214ee4:	1884703a 	and	r2,r3,r2
 3214ee8:	d0a00915 	stw	r2,-32732(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 3214eec:	d0e00917 	ldw	r3,-32732(gp)
 3214ef0:	e0bffe17 	ldw	r2,-8(fp)
 3214ef4:	1887883a 	add	r3,r3,r2
 3214ef8:	0080d034 	movhi	r2,832
 3214efc:	10800004 	addi	r2,r2,0
 3214f00:	10c0072e 	bgeu	r2,r3,3214f20 <sbrk+0x78>
 3214f04:	e0bffd17 	ldw	r2,-12(fp)
 3214f08:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3214f0c:	e0bffa17 	ldw	r2,-24(fp)
 3214f10:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 3214f14:	00bfffc4 	movi	r2,-1
 3214f18:	e0bfff15 	stw	r2,-4(fp)
 3214f1c:	00000c06 	br	3214f50 <sbrk+0xa8>
  }
#endif

  prev_heap_end = heap_end; 
 3214f20:	d0a00917 	ldw	r2,-32732(gp)
 3214f24:	e0bffc15 	stw	r2,-16(fp)
  heap_end += incr; 
 3214f28:	d0e00917 	ldw	r3,-32732(gp)
 3214f2c:	e0bffe17 	ldw	r2,-8(fp)
 3214f30:	1885883a 	add	r2,r3,r2
 3214f34:	d0a00915 	stw	r2,-32732(gp)
 3214f38:	e0bffd17 	ldw	r2,-12(fp)
 3214f3c:	e0bff915 	stw	r2,-28(fp)
 3214f40:	e0bff917 	ldw	r2,-28(fp)
 3214f44:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 3214f48:	e0bffc17 	ldw	r2,-16(fp)
 3214f4c:	e0bfff15 	stw	r2,-4(fp)
 3214f50:	e0bfff17 	ldw	r2,-4(fp)
} 
 3214f54:	e037883a 	mov	sp,fp
 3214f58:	df000017 	ldw	fp,0(sp)
 3214f5c:	dec00104 	addi	sp,sp,4
 3214f60:	f800283a 	ret

03214f64 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
 3214f64:	deffdf04 	addi	sp,sp,-132
 3214f68:	dfc02015 	stw	ra,128(sp)
 3214f6c:	df001f15 	stw	fp,124(sp)
 3214f70:	df001f04 	addi	fp,sp,124
 3214f74:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 3214f78:	e17fe204 	addi	r5,fp,-120
 3214f7c:	01003fc4 	movi	r4,255
 3214f80:	321cdb80 	call	321cdb8 <OSTaskQuery>
 3214f84:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 3214f88:	e0bffe83 	ldbu	r2,-6(fp)
 3214f8c:	10803fcc 	andi	r2,r2,255
 3214f90:	1004c03a 	cmpne	r2,r2,zero
 3214f94:	1000191e 	bne	r2,zero,3214ffc <__env_lock+0x98>
    return;

  id = tcb.OSTCBPrio;
 3214f98:	e0bfee83 	ldbu	r2,-70(fp)
 3214f9c:	10803fcc 	andi	r2,r2,255
 3214fa0:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
 3214fa4:	d128a117 	ldw	r4,-23932(gp)
 3214fa8:	e17ffd04 	addi	r5,fp,-12
 3214fac:	321b3040 	call	321b304 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
 3214fb0:	e0bffe43 	ldbu	r2,-7(fp)
 3214fb4:	10803fcc 	andi	r2,r2,255
 3214fb8:	1005003a 	cmpeq	r2,r2,zero
 3214fbc:	1000071e 	bne	r2,zero,3214fdc <__env_lock+0x78>
 3214fc0:	d0e00a17 	ldw	r3,-32728(gp)
 3214fc4:	e0bfe117 	ldw	r2,-124(fp)
 3214fc8:	10c0041e 	bne	r2,r3,3214fdc <__env_lock+0x78>
  {
    /* we do; just count the recursion */

    locks++;
 3214fcc:	d0a8a017 	ldw	r2,-23936(gp)
 3214fd0:	10800044 	addi	r2,r2,1
 3214fd4:	d0a8a015 	stw	r2,-23936(gp)
  id = tcb.OSTCBPrio;
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
  if( semdata.OSEventGrp && id == lockid ) 
 3214fd8:	00000806 	br	3214ffc <__env_lock+0x98>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
 3214fdc:	d128a117 	ldw	r4,-23932(gp)
 3214fe0:	e1bffe84 	addi	r6,fp,-6
 3214fe4:	000b883a 	mov	r5,zero
 3214fe8:	321ade40 	call	321ade4 <OSSemPend>
    locks  = 1;
 3214fec:	00800044 	movi	r2,1
 3214ff0:	d0a8a015 	stw	r2,-23936(gp)
    lockid = id;
 3214ff4:	e0bfe117 	ldw	r2,-124(fp)
 3214ff8:	d0a00a15 	stw	r2,-32728(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 3214ffc:	e037883a 	mov	sp,fp
 3215000:	dfc00117 	ldw	ra,4(sp)
 3215004:	df000017 	ldw	fp,0(sp)
 3215008:	dec00204 	addi	sp,sp,8
 321500c:	f800283a 	ret

03215010 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
 3215010:	defffd04 	addi	sp,sp,-12
 3215014:	dfc00215 	stw	ra,8(sp)
 3215018:	df000115 	stw	fp,4(sp)
 321501c:	df000104 	addi	fp,sp,4
 3215020:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
 3215024:	d0a8a017 	ldw	r2,-23936(gp)
 3215028:	1005003a 	cmpeq	r2,r2,zero
 321502c:	10000a1e 	bne	r2,zero,3215058 <__env_unlock+0x48>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
 3215030:	d0a8a017 	ldw	r2,-23936(gp)
 3215034:	10bfffc4 	addi	r2,r2,-1
 3215038:	d0a8a015 	stw	r2,-23936(gp)
 321503c:	d0a8a017 	ldw	r2,-23936(gp)
 3215040:	1004c03a 	cmpne	r2,r2,zero
 3215044:	1000041e 	bne	r2,zero,3215058 <__env_unlock+0x48>
  {
    lockid = -1;
 3215048:	00bfffc4 	movi	r2,-1
 321504c:	d0a00a15 	stw	r2,-32728(gp)
    OSSemPost( alt_envsem );
 3215050:	d128a117 	ldw	r4,-23932(gp)
 3215054:	321b1dc0 	call	321b1dc <OSSemPost>
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 3215058:	e037883a 	mov	sp,fp
 321505c:	dfc00117 	ldw	ra,4(sp)
 3215060:	df000017 	ldw	fp,0(sp)
 3215064:	dec00204 	addi	sp,sp,8
 3215068:	f800283a 	ret

0321506c <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
 321506c:	deffdb04 	addi	sp,sp,-148
 3215070:	dfc02415 	stw	ra,144(sp)
 3215074:	df002315 	stw	fp,140(sp)
 3215078:	df002304 	addi	fp,sp,140
 321507c:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3215080:	e03fe015 	stw	zero,-128(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
 3215084:	0080c974 	movhi	r2,805
 3215088:	10921b44 	addi	r2,r2,18541
 321508c:	10800003 	ldbu	r2,0(r2)
 3215090:	10803fcc 	andi	r2,r2,255
 3215094:	10800058 	cmpnei	r2,r2,1
 3215098:	1000311e 	bne	r2,zero,3215160 <__malloc_lock+0xf4>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 321509c:	e17fe204 	addi	r5,fp,-120
 32150a0:	01003fc4 	movi	r4,255
 32150a4:	321cdb80 	call	321cdb8 <OSTaskQuery>
 32150a8:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 32150ac:	e0bffe83 	ldbu	r2,-6(fp)
 32150b0:	10803fcc 	andi	r2,r2,255
 32150b4:	1004c03a 	cmpne	r2,r2,zero
 32150b8:	1000291e 	bne	r2,zero,3215160 <__malloc_lock+0xf4>
    return;

  id = tcb.OSTCBPrio;
 32150bc:	e0bfee83 	ldbu	r2,-70(fp)
 32150c0:	10803fcc 	andi	r2,r2,255
 32150c4:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
 32150c8:	d128a317 	ldw	r4,-23924(gp)
 32150cc:	e17ffd04 	addi	r5,fp,-12
 32150d0:	321b3040 	call	321b304 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32150d4:	0005303a 	rdctl	r2,status
 32150d8:	e0bfdf15 	stw	r2,-132(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32150dc:	e0ffdf17 	ldw	r3,-132(fp)
 32150e0:	00bfff84 	movi	r2,-2
 32150e4:	1884703a 	and	r2,r3,r2
 32150e8:	1001703a 	wrctl	status,r2
  
  return context;
 32150ec:	e0bfdf17 	ldw	r2,-132(fp)
  
  OS_ENTER_CRITICAL();
 32150f0:	e0bfe015 	stw	r2,-128(fp)

  if( !semdata.OSCnt && id == lockid ) 
 32150f4:	e0bffd0b 	ldhu	r2,-12(fp)
 32150f8:	10bfffcc 	andi	r2,r2,65535
 32150fc:	1004c03a 	cmpne	r2,r2,zero
 3215100:	10000b1e 	bne	r2,zero,3215130 <__malloc_lock+0xc4>
 3215104:	d0e00b17 	ldw	r3,-32724(gp)
 3215108:	e0bfe117 	ldw	r2,-124(fp)
 321510c:	10c0081e 	bne	r2,r3,3215130 <__malloc_lock+0xc4>
  {
    /* we do; just count the recursion */
    locks++;
 3215110:	d0a8a217 	ldw	r2,-23928(gp)
 3215114:	10800044 	addi	r2,r2,1
 3215118:	d0a8a215 	stw	r2,-23928(gp)
 321511c:	e0bfe017 	ldw	r2,-128(fp)
 3215120:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215124:	e0bfde17 	ldw	r2,-136(fp)
 3215128:	1001703a 	wrctl	status,r2

  OSSemQuery( alt_heapsem, &semdata );
  
  OS_ENTER_CRITICAL();

  if( !semdata.OSCnt && id == lockid ) 
 321512c:	00000c06 	br	3215160 <__malloc_lock+0xf4>
 3215130:	e0bfe017 	ldw	r2,-128(fp)
 3215134:	e0bfdd15 	stw	r2,-140(fp)
 3215138:	e0bfdd17 	ldw	r2,-140(fp)
 321513c:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
 3215140:	d128a317 	ldw	r4,-23924(gp)
 3215144:	e1bffe84 	addi	r6,fp,-6
 3215148:	000b883a 	mov	r5,zero
 321514c:	321ade40 	call	321ade4 <OSSemPend>
    locks  = 1;
 3215150:	00800044 	movi	r2,1
 3215154:	d0a8a215 	stw	r2,-23928(gp)
    lockid = id;
 3215158:	e0bfe117 	ldw	r2,-124(fp)
 321515c:	d0a00b15 	stw	r2,-32724(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 3215160:	e037883a 	mov	sp,fp
 3215164:	dfc00117 	ldw	ra,4(sp)
 3215168:	df000017 	ldw	fp,0(sp)
 321516c:	dec00204 	addi	sp,sp,8
 3215170:	f800283a 	ret

03215174 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 3215174:	defff804 	addi	sp,sp,-32
 3215178:	dfc00715 	stw	ra,28(sp)
 321517c:	df000615 	stw	fp,24(sp)
 3215180:	df000604 	addi	fp,sp,24
 3215184:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3215188:	e03ffe15 	stw	zero,-8(fp)
#endif 

  if (OSRunning != OS_TRUE)
 321518c:	0080c974 	movhi	r2,805
 3215190:	10921b44 	addi	r2,r2,18541
 3215194:	10800003 	ldbu	r2,0(r2)
 3215198:	10803fcc 	andi	r2,r2,255
 321519c:	10800058 	cmpnei	r2,r2,1
 32151a0:	1000231e 	bne	r2,zero,3215230 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32151a4:	0005303a 	rdctl	r2,status
 32151a8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32151ac:	e0fffd17 	ldw	r3,-12(fp)
 32151b0:	00bfff84 	movi	r2,-2
 32151b4:	1884703a 	and	r2,r3,r2
 32151b8:	1001703a 	wrctl	status,r2
  
  return context;
 32151bc:	e0bffd17 	ldw	r2,-12(fp)
      return;

  OS_ENTER_CRITICAL();
 32151c0:	e0bffe15 	stw	r2,-8(fp)
  if (locks == 0)
 32151c4:	d0a8a217 	ldw	r2,-23928(gp)
 32151c8:	1004c03a 	cmpne	r2,r2,zero
 32151cc:	1000051e 	bne	r2,zero,32151e4 <__malloc_unlock+0x70>
 32151d0:	e0bffe17 	ldw	r2,-8(fp)
 32151d4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 32151d8:	e0bffc17 	ldw	r2,-16(fp)
 32151dc:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
 32151e0:	00001306 	br	3215230 <__malloc_unlock+0xbc>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
 32151e4:	d0a8a217 	ldw	r2,-23928(gp)
 32151e8:	10bfffc4 	addi	r2,r2,-1
 32151ec:	d0a8a215 	stw	r2,-23928(gp)
 32151f0:	d0a8a217 	ldw	r2,-23928(gp)
 32151f4:	1004c03a 	cmpne	r2,r2,zero
 32151f8:	1000091e 	bne	r2,zero,3215220 <__malloc_unlock+0xac>
  {
    lockid = -1;
 32151fc:	00bfffc4 	movi	r2,-1
 3215200:	d0a00b15 	stw	r2,-32724(gp)
 3215204:	e0bffe17 	ldw	r2,-8(fp)
 3215208:	e0bffb15 	stw	r2,-20(fp)
 321520c:	e0bffb17 	ldw	r2,-20(fp)
 3215210:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
 3215214:	d128a317 	ldw	r4,-23924(gp)
 3215218:	321b1dc0 	call	321b1dc <OSSemPost>
 321521c:	00000406 	br	3215230 <__malloc_unlock+0xbc>
 3215220:	e0bffe17 	ldw	r2,-8(fp)
 3215224:	e0bffa15 	stw	r2,-24(fp)
 3215228:	e0bffa17 	ldw	r2,-24(fp)
 321522c:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 3215230:	e037883a 	mov	sp,fp
 3215234:	dfc00117 	ldw	ra,4(sp)
 3215238:	df000017 	ldw	fp,0(sp)
 321523c:	dec00204 	addi	sp,sp,8
 3215240:	f800283a 	ret

03215244 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 3215244:	defff604 	addi	sp,sp,-40
 3215248:	dfc00915 	stw	ra,36(sp)
 321524c:	df000815 	stw	fp,32(sp)
 3215250:	df000804 	addi	fp,sp,32
 3215254:	e13ffc15 	stw	r4,-16(fp)
 3215258:	e17ffd15 	stw	r5,-12(fp)
 321525c:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3215260:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 3215264:	e0bffe17 	ldw	r2,-8(fp)
 3215268:	1004c03a 	cmpne	r2,r2,zero
 321526c:	1000021e 	bne	r2,zero,3215278 <OSEventNameGet+0x34>
        return (0);
 3215270:	e03fff15 	stw	zero,-4(fp)
 3215274:	00003906 	br	321535c <OSEventNameGet+0x118>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 3215278:	e0bffc17 	ldw	r2,-16(fp)
 321527c:	1004c03a 	cmpne	r2,r2,zero
 3215280:	1000051e 	bne	r2,zero,3215298 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 3215284:	e0fffe17 	ldw	r3,-8(fp)
 3215288:	00800104 	movi	r2,4
 321528c:	18800005 	stb	r2,0(r3)
        return (0);
 3215290:	e03fff15 	stw	zero,-4(fp)
 3215294:	00003106 	br	321535c <OSEventNameGet+0x118>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 3215298:	e0bffd17 	ldw	r2,-12(fp)
 321529c:	1004c03a 	cmpne	r2,r2,zero
 32152a0:	1000051e 	bne	r2,zero,32152b8 <OSEventNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 32152a4:	e0fffe17 	ldw	r3,-8(fp)
 32152a8:	00800304 	movi	r2,12
 32152ac:	18800005 	stb	r2,0(r3)
        return (0);
 32152b0:	e03fff15 	stw	zero,-4(fp)
 32152b4:	00002906 	br	321535c <OSEventNameGet+0x118>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 32152b8:	d0a8b203 	ldbu	r2,-23864(gp)
 32152bc:	10803fcc 	andi	r2,r2,255
 32152c0:	1005003a 	cmpeq	r2,r2,zero
 32152c4:	1000051e 	bne	r2,zero,32152dc <OSEventNameGet+0x98>
        *perr  = OS_ERR_NAME_GET_ISR;
 32152c8:	e0fffe17 	ldw	r3,-8(fp)
 32152cc:	00800444 	movi	r2,17
 32152d0:	18800005 	stb	r2,0(r3)
        return (0);
 32152d4:	e03fff15 	stw	zero,-4(fp)
 32152d8:	00002006 	br	321535c <OSEventNameGet+0x118>
    }
    switch (pevent->OSEventType) {
 32152dc:	e0bffc17 	ldw	r2,-16(fp)
 32152e0:	10800003 	ldbu	r2,0(r2)
 32152e4:	10803fcc 	andi	r2,r2,255
 32152e8:	10bfffc4 	addi	r2,r2,-1
 32152ec:	10800128 	cmpgeui	r2,r2,4
 32152f0:	1000161e 	bne	r2,zero,321534c <OSEventNameGet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32152f4:	0005303a 	rdctl	r2,status
 32152f8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32152fc:	e0fff917 	ldw	r3,-28(fp)
 3215300:	00bfff84 	movi	r2,-2
 3215304:	1884703a 	and	r2,r3,r2
 3215308:	1001703a 	wrctl	status,r2
  
  return context;
 321530c:	e0bff917 	ldw	r2,-28(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
 3215310:	e0bffa15 	stw	r2,-24(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
 3215314:	e0bffc17 	ldw	r2,-16(fp)
 3215318:	11400384 	addi	r5,r2,14
 321531c:	e13ffd17 	ldw	r4,-12(fp)
 3215320:	3216dc80 	call	3216dc8 <OS_StrCopy>
 3215324:	e0bffb05 	stb	r2,-20(fp)
 3215328:	e0bffa17 	ldw	r2,-24(fp)
 321532c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215330:	e0bff817 	ldw	r2,-32(fp)
 3215334:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 3215338:	e0bffe17 	ldw	r2,-8(fp)
 321533c:	10000005 	stb	zero,0(r2)
    return (len);
 3215340:	e0bffb03 	ldbu	r2,-20(fp)
 3215344:	e0bfff15 	stw	r2,-4(fp)
 3215348:	00000406 	br	321535c <OSEventNameGet+0x118>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 321534c:	e0fffe17 	ldw	r3,-8(fp)
 3215350:	00800044 	movi	r2,1
 3215354:	18800005 	stb	r2,0(r3)
             return (0);
 3215358:	e03fff15 	stw	zero,-4(fp)
 321535c:	e0bfff17 	ldw	r2,-4(fp)
    OS_ENTER_CRITICAL();
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return (len);
}
 3215360:	e037883a 	mov	sp,fp
 3215364:	dfc00117 	ldw	ra,4(sp)
 3215368:	df000017 	ldw	fp,0(sp)
 321536c:	dec00204 	addi	sp,sp,8
 3215370:	f800283a 	ret

03215374 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 3215374:	defff604 	addi	sp,sp,-40
 3215378:	dfc00915 	stw	ra,36(sp)
 321537c:	df000815 	stw	fp,32(sp)
 3215380:	df000804 	addi	fp,sp,32
 3215384:	e13ffd15 	stw	r4,-12(fp)
 3215388:	e17ffe15 	stw	r5,-8(fp)
 321538c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3215390:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 3215394:	e0bfff17 	ldw	r2,-4(fp)
 3215398:	1005003a 	cmpeq	r2,r2,zero
 321539c:	1000411e 	bne	r2,zero,32154a4 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 32153a0:	e0bffd17 	ldw	r2,-12(fp)
 32153a4:	1004c03a 	cmpne	r2,r2,zero
 32153a8:	1000041e 	bne	r2,zero,32153bc <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
 32153ac:	e0ffff17 	ldw	r3,-4(fp)
 32153b0:	00800104 	movi	r2,4
 32153b4:	18800005 	stb	r2,0(r3)
        return;
 32153b8:	00003a06 	br	32154a4 <OSEventNameSet+0x130>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 32153bc:	e0bffe17 	ldw	r2,-8(fp)
 32153c0:	1004c03a 	cmpne	r2,r2,zero
 32153c4:	1000041e 	bne	r2,zero,32153d8 <OSEventNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 32153c8:	e0ffff17 	ldw	r3,-4(fp)
 32153cc:	00800304 	movi	r2,12
 32153d0:	18800005 	stb	r2,0(r3)
        return;
 32153d4:	00003306 	br	32154a4 <OSEventNameSet+0x130>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 32153d8:	d0a8b203 	ldbu	r2,-23864(gp)
 32153dc:	10803fcc 	andi	r2,r2,255
 32153e0:	1005003a 	cmpeq	r2,r2,zero
 32153e4:	1000041e 	bne	r2,zero,32153f8 <OSEventNameSet+0x84>
        *perr = OS_ERR_NAME_SET_ISR;
 32153e8:	e0ffff17 	ldw	r3,-4(fp)
 32153ec:	00800484 	movi	r2,18
 32153f0:	18800005 	stb	r2,0(r3)
        return;
 32153f4:	00002b06 	br	32154a4 <OSEventNameSet+0x130>
    }
    switch (pevent->OSEventType) {
 32153f8:	e0bffd17 	ldw	r2,-12(fp)
 32153fc:	10800003 	ldbu	r2,0(r2)
 3215400:	10803fcc 	andi	r2,r2,255
 3215404:	10bfffc4 	addi	r2,r2,-1
 3215408:	10800128 	cmpgeui	r2,r2,4
 321540c:	10000f1e 	bne	r2,zero,321544c <OSEventNameSet+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3215410:	0005303a 	rdctl	r2,status
 3215414:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3215418:	e0fffa17 	ldw	r3,-24(fp)
 321541c:	00bfff84 	movi	r2,-2
 3215420:	1884703a 	and	r2,r3,r2
 3215424:	1001703a 	wrctl	status,r2
  
  return context;
 3215428:	e0bffa17 	ldw	r2,-24(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
 321542c:	e0bffb15 	stw	r2,-20(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
 3215430:	e13ffe17 	ldw	r4,-8(fp)
 3215434:	3216e480 	call	3216e48 <OS_StrLen>
 3215438:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
 321543c:	e0bffc03 	ldbu	r2,-16(fp)
 3215440:	10800828 	cmpgeui	r2,r2,32
 3215444:	1000051e 	bne	r2,zero,321545c <OSEventNameSet+0xe8>
 3215448:	00000c06 	br	321547c <OSEventNameSet+0x108>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 321544c:	e0ffff17 	ldw	r3,-4(fp)
 3215450:	00800044 	movi	r2,1
 3215454:	18800005 	stb	r2,0(r3)
             return;
 3215458:	00001206 	br	32154a4 <OSEventNameSet+0x130>
 321545c:	e0bffb17 	ldw	r2,-20(fp)
 3215460:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215464:	e0bff917 	ldw	r2,-28(fp)
 3215468:	1001703a 	wrctl	status,r2
    }
    OS_ENTER_CRITICAL();
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
 321546c:	e0ffff17 	ldw	r3,-4(fp)
 3215470:	008002c4 	movi	r2,11
 3215474:	18800005 	stb	r2,0(r3)
        return;
 3215478:	00000a06 	br	32154a4 <OSEventNameSet+0x130>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
 321547c:	e0bffd17 	ldw	r2,-12(fp)
 3215480:	11000384 	addi	r4,r2,14
 3215484:	e17ffe17 	ldw	r5,-8(fp)
 3215488:	3216dc80 	call	3216dc8 <OS_StrCopy>
 321548c:	e0bffb17 	ldw	r2,-20(fp)
 3215490:	e0bff815 	stw	r2,-32(fp)
 3215494:	e0bff817 	ldw	r2,-32(fp)
 3215498:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 321549c:	e0bfff17 	ldw	r2,-4(fp)
 32154a0:	10000005 	stb	zero,0(r2)
}
 32154a4:	e037883a 	mov	sp,fp
 32154a8:	dfc00117 	ldw	ra,4(sp)
 32154ac:	df000017 	ldw	fp,0(sp)
 32154b0:	dec00204 	addi	sp,sp,8
 32154b4:	f800283a 	ret

032154b8 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
 32154b8:	deffe704 	addi	sp,sp,-100
 32154bc:	dfc01815 	stw	ra,96(sp)
 32154c0:	df001715 	stw	fp,92(sp)
 32154c4:	df001704 	addi	fp,sp,92
 32154c8:	e13ff615 	stw	r4,-40(fp)
 32154cc:	e17ff715 	stw	r5,-36(fp)
 32154d0:	e1bff815 	stw	r6,-32(fp)
 32154d4:	e1fff90d 	sth	r7,-28(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
 32154d8:	e03ff015 	stw	zero,-64(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
 32154dc:	e0800217 	ldw	r2,8(fp)
 32154e0:	1004c03a 	cmpne	r2,r2,zero
 32154e4:	1000021e 	bne	r2,zero,32154f0 <OSEventPendMulti+0x38>
        return (0);
 32154e8:	e03fff15 	stw	zero,-4(fp)
 32154ec:	00019906 	br	3215b54 <OSEventPendMulti+0x69c>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
 32154f0:	e0bff617 	ldw	r2,-40(fp)
 32154f4:	1004c03a 	cmpne	r2,r2,zero
 32154f8:	1000051e 	bne	r2,zero,3215510 <OSEventPendMulti+0x58>
       *perr =  OS_ERR_PEVENT_NULL;
 32154fc:	e0c00217 	ldw	r3,8(fp)
 3215500:	00800104 	movi	r2,4
 3215504:	18800005 	stb	r2,0(r3)
        return (0);
 3215508:	e03fff15 	stw	zero,-4(fp)
 321550c:	00019106 	br	3215b54 <OSEventPendMulti+0x69c>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
 3215510:	e0bff717 	ldw	r2,-36(fp)
 3215514:	1004c03a 	cmpne	r2,r2,zero
 3215518:	1000051e 	bne	r2,zero,3215530 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
 321551c:	e0c00217 	ldw	r3,8(fp)
 3215520:	00800104 	movi	r2,4
 3215524:	18800005 	stb	r2,0(r3)
        return (0);
 3215528:	e03fff15 	stw	zero,-4(fp)
 321552c:	00018906 	br	3215b54 <OSEventPendMulti+0x69c>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
 3215530:	e0bff817 	ldw	r2,-32(fp)
 3215534:	1004c03a 	cmpne	r2,r2,zero
 3215538:	1000051e 	bne	r2,zero,3215550 <OSEventPendMulti+0x98>
       *perr =  OS_ERR_PEVENT_NULL;
 321553c:	e0c00217 	ldw	r3,8(fp)
 3215540:	00800104 	movi	r2,4
 3215544:	18800005 	stb	r2,0(r3)
        return (0);
 3215548:	e03fff15 	stw	zero,-4(fp)
 321554c:	00018106 	br	3215b54 <OSEventPendMulti+0x69c>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
 3215550:	e0bff717 	ldw	r2,-36(fp)
 3215554:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
 3215558:	e0bff617 	ldw	r2,-40(fp)
 321555c:	e0bff515 	stw	r2,-44(fp)
    pevent      = *pevents;
 3215560:	e0bff517 	ldw	r2,-44(fp)
 3215564:	10800017 	ldw	r2,0(r2)
 3215568:	e0bff415 	stw	r2,-48(fp)
    while  (pevent != (OS_EVENT *)0) {
 321556c:	00001806 	br	32155d0 <OSEventPendMulti+0x118>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
 3215570:	e0bff417 	ldw	r2,-48(fp)
 3215574:	10800003 	ldbu	r2,0(r2)
 3215578:	10803fcc 	andi	r2,r2,255
 321557c:	e0bffe15 	stw	r2,-8(fp)
 3215580:	e0fffe17 	ldw	r3,-8(fp)
 3215584:	188000a0 	cmpeqi	r2,r3,2
 3215588:	10000b1e 	bne	r2,zero,32155b8 <OSEventPendMulti+0x100>
 321558c:	e0fffe17 	ldw	r3,-8(fp)
 3215590:	188000e0 	cmpeqi	r2,r3,3
 3215594:	1000081e 	bne	r2,zero,32155b8 <OSEventPendMulti+0x100>
 3215598:	e0fffe17 	ldw	r3,-8(fp)
 321559c:	18800060 	cmpeqi	r2,r3,1
 32155a0:	1000051e 	bne	r2,zero,32155b8 <OSEventPendMulti+0x100>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
 32155a4:	e0c00217 	ldw	r3,8(fp)
 32155a8:	00800044 	movi	r2,1
 32155ac:	18800005 	stb	r2,0(r3)
                 return (0);
 32155b0:	e03fff15 	stw	zero,-4(fp)
 32155b4:	00016706 	br	3215b54 <OSEventPendMulti+0x69c>
        }
        pevents++;
 32155b8:	e0bff517 	ldw	r2,-44(fp)
 32155bc:	10800104 	addi	r2,r2,4
 32155c0:	e0bff515 	stw	r2,-44(fp)
        pevent = *pevents;
 32155c4:	e0bff517 	ldw	r2,-44(fp)
 32155c8:	10800017 	ldw	r2,0(r2)
 32155cc:	e0bff415 	stw	r2,-48(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
 32155d0:	e0bff417 	ldw	r2,-48(fp)
 32155d4:	1004c03a 	cmpne	r2,r2,zero
 32155d8:	103fe51e 	bne	r2,zero,3215570 <OSEventPendMulti+0xb8>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
 32155dc:	d0a8b203 	ldbu	r2,-23864(gp)
 32155e0:	10803fcc 	andi	r2,r2,255
 32155e4:	1005003a 	cmpeq	r2,r2,zero
 32155e8:	1000051e 	bne	r2,zero,3215600 <OSEventPendMulti+0x148>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
 32155ec:	e0c00217 	ldw	r3,8(fp)
 32155f0:	00800084 	movi	r2,2
 32155f4:	18800005 	stb	r2,0(r3)
        return (0);
 32155f8:	e03fff15 	stw	zero,-4(fp)
 32155fc:	00015506 	br	3215b54 <OSEventPendMulti+0x69c>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
 3215600:	d0a8a403 	ldbu	r2,-23920(gp)
 3215604:	10803fcc 	andi	r2,r2,255
 3215608:	1005003a 	cmpeq	r2,r2,zero
 321560c:	1000051e 	bne	r2,zero,3215624 <OSEventPendMulti+0x16c>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
 3215610:	e0c00217 	ldw	r3,8(fp)
 3215614:	00800344 	movi	r2,13
 3215618:	18800005 	stb	r2,0(r3)
        return (0);
 321561c:	e03fff15 	stw	zero,-4(fp)
 3215620:	00014c06 	br	3215b54 <OSEventPendMulti+0x69c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3215624:	0005303a 	rdctl	r2,status
 3215628:	e0bfef15 	stw	r2,-68(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321562c:	e0ffef17 	ldw	r3,-68(fp)
 3215630:	00bfff84 	movi	r2,-2
 3215634:	1884703a 	and	r2,r3,r2
 3215638:	1001703a 	wrctl	status,r2
  
  return context;
 321563c:	e0bfef17 	ldw	r2,-68(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
 3215640:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
 3215644:	e03ff205 	stb	zero,-56(fp)
    events_rdy_nbr =  0;
 3215648:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
 321564c:	e03ff105 	stb	zero,-60(fp)
    pevents        =  pevents_pend;
 3215650:	e0bff617 	ldw	r2,-40(fp)
 3215654:	e0bff515 	stw	r2,-44(fp)
    pevent         = *pevents;
 3215658:	e0bff517 	ldw	r2,-44(fp)
 321565c:	10800017 	ldw	r2,0(r2)
 3215660:	e0bff415 	stw	r2,-48(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 3215664:	00008f06 	br	32158a4 <OSEventPendMulti+0x3ec>
        switch (pevent->OSEventType) {
 3215668:	e0bff417 	ldw	r2,-48(fp)
 321566c:	10800003 	ldbu	r2,0(r2)
 3215670:	10803fcc 	andi	r2,r2,255
 3215674:	e0bffd15 	stw	r2,-12(fp)
 3215678:	e0fffd17 	ldw	r3,-12(fp)
 321567c:	188000a0 	cmpeqi	r2,r3,2
 3215680:	1000441e 	bne	r2,zero,3215794 <OSEventPendMulti+0x2dc>
 3215684:	e0fffd17 	ldw	r3,-12(fp)
 3215688:	188000e0 	cmpeqi	r2,r3,3
 321568c:	1000041e 	bne	r2,zero,32156a0 <OSEventPendMulti+0x1e8>
 3215690:	e0fffd17 	ldw	r3,-12(fp)
 3215694:	18800060 	cmpeqi	r2,r3,1
 3215698:	1000211e 	bne	r2,zero,3215720 <OSEventPendMulti+0x268>
 321569c:	00006f06 	br	321585c <OSEventPendMulti+0x3a4>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
 32156a0:	e0bff417 	ldw	r2,-48(fp)
 32156a4:	1080020b 	ldhu	r2,8(r2)
 32156a8:	10bfffcc 	andi	r2,r2,65535
 32156ac:	1005003a 	cmpeq	r2,r2,zero
 32156b0:	1000171e 	bne	r2,zero,3215710 <OSEventPendMulti+0x258>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
 32156b4:	e0bff417 	ldw	r2,-48(fp)
 32156b8:	1080020b 	ldhu	r2,8(r2)
 32156bc:	10bfffc4 	addi	r2,r2,-1
 32156c0:	1007883a 	mov	r3,r2
 32156c4:	e0bff417 	ldw	r2,-48(fp)
 32156c8:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
 32156cc:	e0fff717 	ldw	r3,-36(fp)
 32156d0:	e0bff417 	ldw	r2,-48(fp)
 32156d4:	18800015 	stw	r2,0(r3)
 32156d8:	e0bff717 	ldw	r2,-36(fp)
 32156dc:	10800104 	addi	r2,r2,4
 32156e0:	e0bff715 	stw	r2,-36(fp)
                      events_rdy   =  OS_TRUE;
 32156e4:	00800044 	movi	r2,1
 32156e8:	e0bff205 	stb	r2,-56(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
 32156ec:	e0bff817 	ldw	r2,-32(fp)
 32156f0:	10000015 	stw	zero,0(r2)
 32156f4:	e0bff817 	ldw	r2,-32(fp)
 32156f8:	10800104 	addi	r2,r2,4
 32156fc:	e0bff815 	stw	r2,-32(fp)
                      events_rdy_nbr++;
 3215700:	e0bff18b 	ldhu	r2,-58(fp)
 3215704:	10800044 	addi	r2,r2,1
 3215708:	e0bff18d 	sth	r2,-58(fp)
 321570c:	00005f06 	br	321588c <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
 3215710:	e0bff103 	ldbu	r2,-60(fp)
 3215714:	10800054 	ori	r2,r2,1
 3215718:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 321571c:	00005b06 	br	321588c <OSEventPendMulti+0x3d4>
#endif

#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
 3215720:	e0bff417 	ldw	r2,-48(fp)
 3215724:	10800117 	ldw	r2,4(r2)
 3215728:	1005003a 	cmpeq	r2,r2,zero
 321572c:	1000151e 	bne	r2,zero,3215784 <OSEventPendMulti+0x2cc>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
 3215730:	e0bff417 	ldw	r2,-48(fp)
 3215734:	10c00117 	ldw	r3,4(r2)
 3215738:	e0bff817 	ldw	r2,-32(fp)
 321573c:	10c00015 	stw	r3,0(r2)
 3215740:	e0bff817 	ldw	r2,-32(fp)
 3215744:	10800104 	addi	r2,r2,4
 3215748:	e0bff815 	stw	r2,-32(fp)
                     pevent->OSEventPtr  = (void *)0;
 321574c:	e0bff417 	ldw	r2,-48(fp)
 3215750:	10000115 	stw	zero,4(r2)
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
 3215754:	e0fff717 	ldw	r3,-36(fp)
 3215758:	e0bff417 	ldw	r2,-48(fp)
 321575c:	18800015 	stw	r2,0(r3)
 3215760:	e0bff717 	ldw	r2,-36(fp)
 3215764:	10800104 	addi	r2,r2,4
 3215768:	e0bff715 	stw	r2,-36(fp)
                      events_rdy         =  OS_TRUE;
 321576c:	00800044 	movi	r2,1
 3215770:	e0bff205 	stb	r2,-56(fp)
                      events_rdy_nbr++;
 3215774:	e0bff18b 	ldhu	r2,-58(fp)
 3215778:	10800044 	addi	r2,r2,1
 321577c:	e0bff18d 	sth	r2,-58(fp)
 3215780:	00004206 	br	321588c <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
 3215784:	e0bff103 	ldbu	r2,-60(fp)
 3215788:	10800094 	ori	r2,r2,2
 321578c:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 3215790:	00003e06 	br	321588c <OSEventPendMulti+0x3d4>
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
 3215794:	e0bff417 	ldw	r2,-48(fp)
 3215798:	10800117 	ldw	r2,4(r2)
 321579c:	e0bff315 	stw	r2,-52(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
 32157a0:	e0bff317 	ldw	r2,-52(fp)
 32157a4:	1080058b 	ldhu	r2,22(r2)
 32157a8:	10bfffcc 	andi	r2,r2,65535
 32157ac:	1005003a 	cmpeq	r2,r2,zero
 32157b0:	1000261e 	bne	r2,zero,321584c <OSEventPendMulti+0x394>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
 32157b4:	e0bff317 	ldw	r2,-52(fp)
 32157b8:	11000417 	ldw	r4,16(r2)
 32157bc:	20c00017 	ldw	r3,0(r4)
 32157c0:	e0bff817 	ldw	r2,-32(fp)
 32157c4:	10c00015 	stw	r3,0(r2)
 32157c8:	e0bff817 	ldw	r2,-32(fp)
 32157cc:	10800104 	addi	r2,r2,4
 32157d0:	e0bff815 	stw	r2,-32(fp)
 32157d4:	20c00104 	addi	r3,r4,4
 32157d8:	e0bff317 	ldw	r2,-52(fp)
 32157dc:	10c00415 	stw	r3,16(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
 32157e0:	e0bff317 	ldw	r2,-52(fp)
 32157e4:	10c00417 	ldw	r3,16(r2)
 32157e8:	e0bff317 	ldw	r2,-52(fp)
 32157ec:	10800217 	ldw	r2,8(r2)
 32157f0:	1880041e 	bne	r3,r2,3215804 <OSEventPendMulti+0x34c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
 32157f4:	e0bff317 	ldw	r2,-52(fp)
 32157f8:	10c00117 	ldw	r3,4(r2)
 32157fc:	e0bff317 	ldw	r2,-52(fp)
 3215800:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
 3215804:	e0bff317 	ldw	r2,-52(fp)
 3215808:	1080058b 	ldhu	r2,22(r2)
 321580c:	10bfffc4 	addi	r2,r2,-1
 3215810:	1007883a 	mov	r3,r2
 3215814:	e0bff317 	ldw	r2,-52(fp)
 3215818:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
 321581c:	e0fff717 	ldw	r3,-36(fp)
 3215820:	e0bff417 	ldw	r2,-48(fp)
 3215824:	18800015 	stw	r2,0(r3)
 3215828:	e0bff717 	ldw	r2,-36(fp)
 321582c:	10800104 	addi	r2,r2,4
 3215830:	e0bff715 	stw	r2,-36(fp)
                      events_rdy   = OS_TRUE;
 3215834:	00800044 	movi	r2,1
 3215838:	e0bff205 	stb	r2,-56(fp)
                      events_rdy_nbr++;
 321583c:	e0bff18b 	ldhu	r2,-58(fp)
 3215840:	10800044 	addi	r2,r2,1
 3215844:	e0bff18d 	sth	r2,-58(fp)
 3215848:	00001006 	br	321588c <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
 321584c:	e0bff103 	ldbu	r2,-60(fp)
 3215850:	10800114 	ori	r2,r2,4
 3215854:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 3215858:	00000c06 	br	321588c <OSEventPendMulti+0x3d4>
 321585c:	e0bff017 	ldw	r2,-64(fp)
 3215860:	e0bfee15 	stw	r2,-72(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215864:	e0bfee17 	ldw	r2,-72(fp)
 3215868:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
 321586c:	e0bff717 	ldw	r2,-36(fp)
 3215870:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
 3215874:	e0c00217 	ldw	r3,8(fp)
 3215878:	00800044 	movi	r2,1
 321587c:	18800005 	stb	r2,0(r3)
                 return (events_rdy_nbr);
 3215880:	e0bff18b 	ldhu	r2,-58(fp)
 3215884:	e0bfff15 	stw	r2,-4(fp)
 3215888:	0000b206 	br	3215b54 <OSEventPendMulti+0x69c>
        }
        pevents++;
 321588c:	e0bff517 	ldw	r2,-44(fp)
 3215890:	10800104 	addi	r2,r2,4
 3215894:	e0bff515 	stw	r2,-44(fp)
        pevent = *pevents;
 3215898:	e0bff517 	ldw	r2,-44(fp)
 321589c:	10800017 	ldw	r2,0(r2)
 32158a0:	e0bff415 	stw	r2,-48(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 32158a4:	e0bff417 	ldw	r2,-48(fp)
 32158a8:	1004c03a 	cmpne	r2,r2,zero
 32158ac:	103f6e1e 	bne	r2,zero,3215668 <OSEventPendMulti+0x1b0>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
 32158b0:	e0bff203 	ldbu	r2,-56(fp)
 32158b4:	10800058 	cmpnei	r2,r2,1
 32158b8:	10000b1e 	bne	r2,zero,32158e8 <OSEventPendMulti+0x430>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
 32158bc:	e0bff717 	ldw	r2,-36(fp)
 32158c0:	10000015 	stw	zero,0(r2)
 32158c4:	e0bff017 	ldw	r2,-64(fp)
 32158c8:	e0bfed15 	stw	r2,-76(fp)
 32158cc:	e0bfed17 	ldw	r2,-76(fp)
 32158d0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
 32158d4:	e0800217 	ldw	r2,8(fp)
 32158d8:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
 32158dc:	e0fff18b 	ldhu	r3,-58(fp)
 32158e0:	e0ffff15 	stw	r3,-4(fp)
 32158e4:	00009b06 	br	3215b54 <OSEventPendMulti+0x69c>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
 32158e8:	d128b317 	ldw	r4,-23860(gp)
 32158ec:	d0a8b317 	ldw	r2,-23860(gp)
 32158f0:	10c00c03 	ldbu	r3,48(r2)
 32158f4:	e0bff103 	ldbu	r2,-60(fp)
 32158f8:	1884b03a 	or	r2,r3,r2
 32158fc:	1007883a 	mov	r3,r2
 3215900:	00bfe004 	movi	r2,-128
 3215904:	1884b03a 	or	r2,r3,r2
 3215908:	20800c05 	stb	r2,48(r4)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 321590c:	d0a8b317 	ldw	r2,-23860(gp)
 3215910:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
 3215914:	d0e8b317 	ldw	r3,-23860(gp)
 3215918:	e0bff90b 	ldhu	r2,-28(fp)
 321591c:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
 3215920:	e13ff617 	ldw	r4,-40(fp)
 3215924:	32164e80 	call	32164e8 <OS_EventTaskWaitMulti>
 3215928:	e0bff017 	ldw	r2,-64(fp)
 321592c:	e0bfec15 	stw	r2,-80(fp)
 3215930:	e0bfec17 	ldw	r2,-80(fp)
 3215934:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
 3215938:	3216c840 	call	3216c84 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321593c:	0005303a 	rdctl	r2,status
 3215940:	e0bfeb15 	stw	r2,-84(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3215944:	e0ffeb17 	ldw	r3,-84(fp)
 3215948:	00bfff84 	movi	r2,-2
 321594c:	1884703a 	and	r2,r3,r2
 3215950:	1001703a 	wrctl	status,r2
  
  return context;
 3215954:	e0bfeb17 	ldw	r2,-84(fp)
    OS_ENTER_CRITICAL();
 3215958:	e0bff015 	stw	r2,-64(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
 321595c:	d0a8b317 	ldw	r2,-23860(gp)
 3215960:	10800c43 	ldbu	r2,49(r2)
 3215964:	10803fcc 	andi	r2,r2,255
 3215968:	e0bffc15 	stw	r2,-16(fp)
 321596c:	e0fffc17 	ldw	r3,-16(fp)
 3215970:	1805003a 	cmpeq	r2,r3,zero
 3215974:	1000041e 	bne	r2,zero,3215988 <OSEventPendMulti+0x4d0>
 3215978:	e0fffc17 	ldw	r3,-16(fp)
 321597c:	188000a0 	cmpeqi	r2,r3,2
 3215980:	1000011e 	bne	r2,zero,3215988 <OSEventPendMulti+0x4d0>
 3215984:	00001906 	br	32159ec <OSEventPendMulti+0x534>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
 3215988:	d0a8b317 	ldw	r2,-23860(gp)
 321598c:	10800717 	ldw	r2,28(r2)
 3215990:	e0bff415 	stw	r2,-48(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
 3215994:	e0bff417 	ldw	r2,-48(fp)
 3215998:	1005003a 	cmpeq	r2,r2,zero
 321599c:	10000c1e 	bne	r2,zero,32159d0 <OSEventPendMulti+0x518>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
 32159a0:	e0fff717 	ldw	r3,-36(fp)
 32159a4:	e0bff417 	ldw	r2,-48(fp)
 32159a8:	18800015 	stw	r2,0(r3)
 32159ac:	e0bff717 	ldw	r2,-36(fp)
 32159b0:	10800104 	addi	r2,r2,4
 32159b4:	e0bff715 	stw	r2,-36(fp)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
 32159b8:	e0bff717 	ldw	r2,-36(fp)
 32159bc:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
 32159c0:	e0bff18b 	ldhu	r2,-58(fp)
 32159c4:	10800044 	addi	r2,r2,1
 32159c8:	e0bff18d 	sth	r2,-58(fp)
 32159cc:	00000a06 	br	32159f8 <OSEventPendMulti+0x540>

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
 32159d0:	d0a8b317 	ldw	r2,-23860(gp)
 32159d4:	00c00044 	movi	r3,1
 32159d8:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 32159dc:	d128b317 	ldw	r4,-23860(gp)
 32159e0:	e17ff617 	ldw	r5,-40(fp)
 32159e4:	32166f40 	call	32166f4 <OS_EventTaskRemoveMulti>
             }
			 break;
 32159e8:	00000306 	br	32159f8 <OSEventPendMulti+0x540>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 32159ec:	d128b317 	ldw	r4,-23860(gp)
 32159f0:	e17ff617 	ldw	r5,-40(fp)
 32159f4:	32166f40 	call	32166f4 <OS_EventTaskRemoveMulti>
             break;
    }

    switch (OSTCBCur->OSTCBStatPend) {
 32159f8:	d0a8b317 	ldw	r2,-23860(gp)
 32159fc:	10800c43 	ldbu	r2,49(r2)
 3215a00:	10803fcc 	andi	r2,r2,255
 3215a04:	e0bffb15 	stw	r2,-20(fp)
 3215a08:	e0fffb17 	ldw	r3,-20(fp)
 3215a0c:	1805003a 	cmpeq	r2,r3,zero
 3215a10:	1000041e 	bne	r2,zero,3215a24 <OSEventPendMulti+0x56c>
 3215a14:	e0fffb17 	ldw	r3,-20(fp)
 3215a18:	188000a0 	cmpeqi	r2,r3,2
 3215a1c:	10002c1e 	bne	r2,zero,3215ad0 <OSEventPendMulti+0x618>
 3215a20:	00003406 	br	3215af4 <OSEventPendMulti+0x63c>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
 3215a24:	e0bff417 	ldw	r2,-48(fp)
 3215a28:	10800003 	ldbu	r2,0(r2)
 3215a2c:	10803fcc 	andi	r2,r2,255
 3215a30:	e0bffa15 	stw	r2,-24(fp)
 3215a34:	e0fffa17 	ldw	r3,-24(fp)
 3215a38:	18800050 	cmplti	r2,r3,1
 3215a3c:	1000151e 	bne	r2,zero,3215a94 <OSEventPendMulti+0x5dc>
 3215a40:	e0fffa17 	ldw	r3,-24(fp)
 3215a44:	188000d0 	cmplti	r2,r3,3
 3215a48:	10000a1e 	bne	r2,zero,3215a74 <OSEventPendMulti+0x5bc>
 3215a4c:	e0fffa17 	ldw	r3,-24(fp)
 3215a50:	188000e0 	cmpeqi	r2,r3,3
 3215a54:	1000011e 	bne	r2,zero,3215a5c <OSEventPendMulti+0x5a4>
 3215a58:	00000e06 	br	3215a94 <OSEventPendMulti+0x5dc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
 3215a5c:	e0bff817 	ldw	r2,-32(fp)
 3215a60:	10000015 	stw	zero,0(r2)
 3215a64:	e0bff817 	ldw	r2,-32(fp)
 3215a68:	10800104 	addi	r2,r2,4
 3215a6c:	e0bff815 	stw	r2,-32(fp)
                      break;
 3215a70:	00001406 	br	3215ac4 <OSEventPendMulti+0x60c>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
 3215a74:	d0a8b317 	ldw	r2,-23860(gp)
 3215a78:	10c00917 	ldw	r3,36(r2)
 3215a7c:	e0bff817 	ldw	r2,-32(fp)
 3215a80:	10c00015 	stw	r3,0(r2)
 3215a84:	e0bff817 	ldw	r2,-32(fp)
 3215a88:	10800104 	addi	r2,r2,4
 3215a8c:	e0bff815 	stw	r2,-32(fp)
                      break;
 3215a90:	00000c06 	br	3215ac4 <OSEventPendMulti+0x60c>
 3215a94:	e0bff017 	ldw	r2,-64(fp)
 3215a98:	e0bfea15 	stw	r2,-88(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215a9c:	e0bfea17 	ldw	r2,-88(fp)
 3215aa0:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
 3215aa4:	e0bff717 	ldw	r2,-36(fp)
 3215aa8:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
 3215aac:	e0c00217 	ldw	r3,8(fp)
 3215ab0:	00800044 	movi	r2,1
 3215ab4:	18800005 	stb	r2,0(r3)
                      return (events_rdy_nbr);
 3215ab8:	e0bff18b 	ldhu	r2,-58(fp)
 3215abc:	e0bfff15 	stw	r2,-4(fp)
 3215ac0:	00002406 	br	3215b54 <OSEventPendMulti+0x69c>
             }
            *perr = OS_ERR_NONE;
 3215ac4:	e0800217 	ldw	r2,8(fp)
 3215ac8:	10000005 	stb	zero,0(r2)
             break;
 3215acc:	00001106 	br	3215b14 <OSEventPendMulti+0x65c>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
 3215ad0:	e0bff817 	ldw	r2,-32(fp)
 3215ad4:	10000015 	stw	zero,0(r2)
 3215ad8:	e0bff817 	ldw	r2,-32(fp)
 3215adc:	10800104 	addi	r2,r2,4
 3215ae0:	e0bff815 	stw	r2,-32(fp)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
 3215ae4:	e0c00217 	ldw	r3,8(fp)
 3215ae8:	00800384 	movi	r2,14
 3215aec:	18800005 	stb	r2,0(r3)
             break;
 3215af0:	00000806 	br	3215b14 <OSEventPendMulti+0x65c>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
 3215af4:	e0bff817 	ldw	r2,-32(fp)
 3215af8:	10000015 	stw	zero,0(r2)
 3215afc:	e0bff817 	ldw	r2,-32(fp)
 3215b00:	10800104 	addi	r2,r2,4
 3215b04:	e0bff815 	stw	r2,-32(fp)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
 3215b08:	e0c00217 	ldw	r3,8(fp)
 3215b0c:	00800284 	movi	r2,10
 3215b10:	18800005 	stb	r2,0(r3)
             break;
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
 3215b14:	d0a8b317 	ldw	r2,-23860(gp)
 3215b18:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
 3215b1c:	d0a8b317 	ldw	r2,-23860(gp)
 3215b20:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
 3215b24:	d0a8b317 	ldw	r2,-23860(gp)
 3215b28:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 3215b2c:	d0a8b317 	ldw	r2,-23860(gp)
 3215b30:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
 3215b34:	d0a8b317 	ldw	r2,-23860(gp)
 3215b38:	10000915 	stw	zero,36(r2)
 3215b3c:	e0bff017 	ldw	r2,-64(fp)
 3215b40:	e0bfe915 	stw	r2,-92(fp)
 3215b44:	e0bfe917 	ldw	r2,-92(fp)
 3215b48:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
 3215b4c:	e0fff18b 	ldhu	r3,-58(fp)
 3215b50:	e0ffff15 	stw	r3,-4(fp)
 3215b54:	e0bfff17 	ldw	r2,-4(fp)
}
 3215b58:	e037883a 	mov	sp,fp
 3215b5c:	dfc00117 	ldw	ra,4(sp)
 3215b60:	df000017 	ldw	fp,0(sp)
 3215b64:	dec00204 	addi	sp,sp,8
 3215b68:	f800283a 	ret

03215b6c <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
 3215b6c:	defffe04 	addi	sp,sp,-8
 3215b70:	dfc00115 	stw	ra,4(sp)
 3215b74:	df000015 	stw	fp,0(sp)
 3215b78:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
 3215b7c:	323b5a00 	call	323b5a0 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
 3215b80:	321693c0 	call	321693c <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
 3215b84:	32169800 	call	3216980 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
 3215b88:	3216ae40 	call	3216ae4 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
 3215b8c:	32168600 	call	3216860 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
 3215b90:	3218b940 	call	3218b94 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
 3215b94:	321956c0 	call	321956c <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
 3215b98:	321a8c40 	call	321a8c4 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
 3215b9c:	32169ec0 	call	32169ec <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
 3215ba0:	3216a680 	call	3216a68 <OS_InitTaskStat>

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
 3215ba4:	323b5bc0 	call	323b5bc <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
 3215ba8:	321736c0 	call	321736c <OSDebugInit>
#endif
}
 3215bac:	e037883a 	mov	sp,fp
 3215bb0:	dfc00117 	ldw	ra,4(sp)
 3215bb4:	df000017 	ldw	fp,0(sp)
 3215bb8:	dec00204 	addi	sp,sp,8
 3215bbc:	f800283a 	ret

03215bc0 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
 3215bc0:	defffc04 	addi	sp,sp,-16
 3215bc4:	df000315 	stw	fp,12(sp)
 3215bc8:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 3215bcc:	e03fff15 	stw	zero,-4(fp)
#endif

    if (OSRunning == OS_TRUE) {
 3215bd0:	d0a8a443 	ldbu	r2,-23919(gp)
 3215bd4:	10803fcc 	andi	r2,r2,255
 3215bd8:	10800058 	cmpnei	r2,r2,1
 3215bdc:	1000131e 	bne	r2,zero,3215c2c <OSIntEnter+0x6c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3215be0:	0005303a 	rdctl	r2,status
 3215be4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3215be8:	e0fffe17 	ldw	r3,-8(fp)
 3215bec:	00bfff84 	movi	r2,-2
 3215bf0:	1884703a 	and	r2,r3,r2
 3215bf4:	1001703a 	wrctl	status,r2
  
  return context;
 3215bf8:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 3215bfc:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting < 255u) {
 3215c00:	d0a8b203 	ldbu	r2,-23864(gp)
 3215c04:	10803fcc 	andi	r2,r2,255
 3215c08:	10803fe0 	cmpeqi	r2,r2,255
 3215c0c:	1000031e 	bne	r2,zero,3215c1c <OSIntEnter+0x5c>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
 3215c10:	d0a8b203 	ldbu	r2,-23864(gp)
 3215c14:	10800044 	addi	r2,r2,1
 3215c18:	d0a8b205 	stb	r2,-23864(gp)
 3215c1c:	e0bfff17 	ldw	r2,-4(fp)
 3215c20:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215c24:	e0bffd17 	ldw	r2,-12(fp)
 3215c28:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
    }
}
 3215c2c:	e037883a 	mov	sp,fp
 3215c30:	df000017 	ldw	fp,0(sp)
 3215c34:	dec00104 	addi	sp,sp,4
 3215c38:	f800283a 	ret

03215c3c <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
 3215c3c:	defffb04 	addi	sp,sp,-20
 3215c40:	dfc00415 	stw	ra,16(sp)
 3215c44:	df000315 	stw	fp,12(sp)
 3215c48:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 3215c4c:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {
 3215c50:	d0a8a443 	ldbu	r2,-23919(gp)
 3215c54:	10803fcc 	andi	r2,r2,255
 3215c58:	10800058 	cmpnei	r2,r2,1
 3215c5c:	1000321e 	bne	r2,zero,3215d28 <OSIntExit+0xec>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3215c60:	0005303a 	rdctl	r2,status
 3215c64:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3215c68:	e0fffe17 	ldw	r3,-8(fp)
 3215c6c:	00bfff84 	movi	r2,-2
 3215c70:	1884703a 	and	r2,r3,r2
 3215c74:	1001703a 	wrctl	status,r2
  
  return context;
 3215c78:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 3215c7c:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
 3215c80:	d0a8b203 	ldbu	r2,-23864(gp)
 3215c84:	10803fcc 	andi	r2,r2,255
 3215c88:	1005003a 	cmpeq	r2,r2,zero
 3215c8c:	1000031e 	bne	r2,zero,3215c9c <OSIntExit+0x60>
            OSIntNesting--;
 3215c90:	d0a8b203 	ldbu	r2,-23864(gp)
 3215c94:	10bfffc4 	addi	r2,r2,-1
 3215c98:	d0a8b205 	stb	r2,-23864(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
 3215c9c:	d0a8b203 	ldbu	r2,-23864(gp)
 3215ca0:	10803fcc 	andi	r2,r2,255
 3215ca4:	1004c03a 	cmpne	r2,r2,zero
 3215ca8:	10001b1e 	bne	r2,zero,3215d18 <OSIntExit+0xdc>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
 3215cac:	d0a8a403 	ldbu	r2,-23920(gp)
 3215cb0:	10803fcc 	andi	r2,r2,255
 3215cb4:	1004c03a 	cmpne	r2,r2,zero
 3215cb8:	1000171e 	bne	r2,zero,3215d18 <OSIntExit+0xdc>
                OS_SchedNew();
 3215cbc:	3216d580 	call	3216d58 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
 3215cc0:	d0a8a603 	ldbu	r2,-23912(gp)
 3215cc4:	d0e8a643 	ldbu	r3,-23911(gp)
 3215cc8:	11003fcc 	andi	r4,r2,255
 3215ccc:	18803fcc 	andi	r2,r3,255
 3215cd0:	20801126 	beq	r4,r2,3215d18 <OSIntExit+0xdc>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
 3215cd4:	d0a8a603 	ldbu	r2,-23912(gp)
 3215cd8:	10803fcc 	andi	r2,r2,255
 3215cdc:	00c0c9b4 	movhi	r3,806
 3215ce0:	18f18004 	addi	r3,r3,-14848
 3215ce4:	1085883a 	add	r2,r2,r2
 3215ce8:	1085883a 	add	r2,r2,r2
 3215cec:	10c5883a 	add	r2,r2,r3
 3215cf0:	10800017 	ldw	r2,0(r2)
 3215cf4:	d0a8ae15 	stw	r2,-23880(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
 3215cf8:	d0e8ae17 	ldw	r3,-23880(gp)
 3215cfc:	18800e17 	ldw	r2,56(r3)
 3215d00:	10800044 	addi	r2,r2,1
 3215d04:	18800e15 	stw	r2,56(r3)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
 3215d08:	d0a8a917 	ldw	r2,-23900(gp)
 3215d0c:	10800044 	addi	r2,r2,1
 3215d10:	d0a8a915 	stw	r2,-23900(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
 3215d14:	323b1200 	call	323b120 <OSCtxSw>
 3215d18:	e0bfff17 	ldw	r2,-4(fp)
 3215d1c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215d20:	e0bffd17 	ldw	r2,-12(fp)
 3215d24:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 3215d28:	e037883a 	mov	sp,fp
 3215d2c:	dfc00117 	ldw	ra,4(sp)
 3215d30:	df000017 	ldw	fp,0(sp)
 3215d34:	dec00204 	addi	sp,sp,8
 3215d38:	f800283a 	ret

03215d3c <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
 3215d3c:	defffc04 	addi	sp,sp,-16
 3215d40:	df000315 	stw	fp,12(sp)
 3215d44:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3215d48:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
 3215d4c:	d0a8a443 	ldbu	r2,-23919(gp)
 3215d50:	10803fcc 	andi	r2,r2,255
 3215d54:	10800058 	cmpnei	r2,r2,1
 3215d58:	1000171e 	bne	r2,zero,3215db8 <OSSchedLock+0x7c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3215d5c:	0005303a 	rdctl	r2,status
 3215d60:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3215d64:	e0fffe17 	ldw	r3,-8(fp)
 3215d68:	00bfff84 	movi	r2,-2
 3215d6c:	1884703a 	and	r2,r3,r2
 3215d70:	1001703a 	wrctl	status,r2
  
  return context;
 3215d74:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 3215d78:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
 3215d7c:	d0a8b203 	ldbu	r2,-23864(gp)
 3215d80:	10803fcc 	andi	r2,r2,255
 3215d84:	1004c03a 	cmpne	r2,r2,zero
 3215d88:	1000071e 	bne	r2,zero,3215da8 <OSSchedLock+0x6c>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
 3215d8c:	d0a8a403 	ldbu	r2,-23920(gp)
 3215d90:	10803fcc 	andi	r2,r2,255
 3215d94:	10803fe0 	cmpeqi	r2,r2,255
 3215d98:	1000031e 	bne	r2,zero,3215da8 <OSSchedLock+0x6c>
                OSLockNesting++;                 /* Increment lock nesting level                       */
 3215d9c:	d0a8a403 	ldbu	r2,-23920(gp)
 3215da0:	10800044 	addi	r2,r2,1
 3215da4:	d0a8a405 	stb	r2,-23920(gp)
 3215da8:	e0bfff17 	ldw	r2,-4(fp)
 3215dac:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215db0:	e0bffd17 	ldw	r2,-12(fp)
 3215db4:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 3215db8:	e037883a 	mov	sp,fp
 3215dbc:	df000017 	ldw	fp,0(sp)
 3215dc0:	dec00104 	addi	sp,sp,4
 3215dc4:	f800283a 	ret

03215dc8 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
 3215dc8:	defff804 	addi	sp,sp,-32
 3215dcc:	dfc00715 	stw	ra,28(sp)
 3215dd0:	df000615 	stw	fp,24(sp)
 3215dd4:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 3215dd8:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
 3215ddc:	d0a8a443 	ldbu	r2,-23919(gp)
 3215de0:	10803fcc 	andi	r2,r2,255
 3215de4:	10800058 	cmpnei	r2,r2,1
 3215de8:	10002b1e 	bne	r2,zero,3215e98 <OSSchedUnlock+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3215dec:	0005303a 	rdctl	r2,status
 3215df0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3215df4:	e0fffe17 	ldw	r3,-8(fp)
 3215df8:	00bfff84 	movi	r2,-2
 3215dfc:	1884703a 	and	r2,r3,r2
 3215e00:	1001703a 	wrctl	status,r2
  
  return context;
 3215e04:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 3215e08:	e0bfff15 	stw	r2,-4(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
 3215e0c:	d0a8a403 	ldbu	r2,-23920(gp)
 3215e10:	10803fcc 	andi	r2,r2,255
 3215e14:	1005003a 	cmpeq	r2,r2,zero
 3215e18:	10001b1e 	bne	r2,zero,3215e88 <OSSchedUnlock+0xc0>
            OSLockNesting--;                               /* Decrement lock nesting level             */
 3215e1c:	d0a8a403 	ldbu	r2,-23920(gp)
 3215e20:	10bfffc4 	addi	r2,r2,-1
 3215e24:	d0a8a405 	stb	r2,-23920(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
 3215e28:	d0a8a403 	ldbu	r2,-23920(gp)
 3215e2c:	10803fcc 	andi	r2,r2,255
 3215e30:	1004c03a 	cmpne	r2,r2,zero
 3215e34:	10000f1e 	bne	r2,zero,3215e74 <OSSchedUnlock+0xac>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
 3215e38:	d0a8b203 	ldbu	r2,-23864(gp)
 3215e3c:	10803fcc 	andi	r2,r2,255
 3215e40:	1004c03a 	cmpne	r2,r2,zero
 3215e44:	1000061e 	bne	r2,zero,3215e60 <OSSchedUnlock+0x98>
 3215e48:	e0bfff17 	ldw	r2,-4(fp)
 3215e4c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215e50:	e0bffd17 	ldw	r2,-12(fp)
 3215e54:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
 3215e58:	3216c840 	call	3216c84 <OS_Sched>
 3215e5c:	00000e06 	br	3215e98 <OSSchedUnlock+0xd0>
 3215e60:	e0bfff17 	ldw	r2,-4(fp)
 3215e64:	e0bffc15 	stw	r2,-16(fp)
 3215e68:	e0bffc17 	ldw	r2,-16(fp)
 3215e6c:	1001703a 	wrctl	status,r2
 3215e70:	00000906 	br	3215e98 <OSSchedUnlock+0xd0>
 3215e74:	e0bfff17 	ldw	r2,-4(fp)
 3215e78:	e0bffb15 	stw	r2,-20(fp)
 3215e7c:	e0bffb17 	ldw	r2,-20(fp)
 3215e80:	1001703a 	wrctl	status,r2
 3215e84:	00000406 	br	3215e98 <OSSchedUnlock+0xd0>
 3215e88:	e0bfff17 	ldw	r2,-4(fp)
 3215e8c:	e0bffa15 	stw	r2,-24(fp)
 3215e90:	e0bffa17 	ldw	r2,-24(fp)
 3215e94:	1001703a 	wrctl	status,r2
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
 3215e98:	e037883a 	mov	sp,fp
 3215e9c:	dfc00117 	ldw	ra,4(sp)
 3215ea0:	df000017 	ldw	fp,0(sp)
 3215ea4:	dec00204 	addi	sp,sp,8
 3215ea8:	f800283a 	ret

03215eac <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
 3215eac:	defffe04 	addi	sp,sp,-8
 3215eb0:	dfc00115 	stw	ra,4(sp)
 3215eb4:	df000015 	stw	fp,0(sp)
 3215eb8:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
 3215ebc:	d0a8a443 	ldbu	r2,-23919(gp)
 3215ec0:	10803fcc 	andi	r2,r2,255
 3215ec4:	1004c03a 	cmpne	r2,r2,zero
 3215ec8:	10000f1e 	bne	r2,zero,3215f08 <OSStart+0x5c>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
 3215ecc:	3216d580 	call	3216d58 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
 3215ed0:	d0a8a603 	ldbu	r2,-23912(gp)
 3215ed4:	d0a8a645 	stb	r2,-23911(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
 3215ed8:	d0a8a603 	ldbu	r2,-23912(gp)
 3215edc:	10803fcc 	andi	r2,r2,255
 3215ee0:	00c0c9b4 	movhi	r3,806
 3215ee4:	18f18004 	addi	r3,r3,-14848
 3215ee8:	1085883a 	add	r2,r2,r2
 3215eec:	1085883a 	add	r2,r2,r2
 3215ef0:	10c5883a 	add	r2,r2,r3
 3215ef4:	10800017 	ldw	r2,0(r2)
 3215ef8:	d0a8ae15 	stw	r2,-23880(gp)
        OSTCBCur      = OSTCBHighRdy;
 3215efc:	d0a8ae17 	ldw	r2,-23880(gp)
 3215f00:	d0a8b315 	stw	r2,-23860(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
 3215f04:	323b1ac0 	call	323b1ac <OSStartHighRdy>
    }
}
 3215f08:	e037883a 	mov	sp,fp
 3215f0c:	dfc00117 	ldw	ra,4(sp)
 3215f10:	df000017 	ldw	fp,0(sp)
 3215f14:	dec00204 	addi	sp,sp,8
 3215f18:	f800283a 	ret

03215f1c <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
 3215f1c:	defff904 	addi	sp,sp,-28
 3215f20:	dfc00615 	stw	ra,24(sp)
 3215f24:	df000515 	stw	fp,20(sp)
 3215f28:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3215f2c:	e03fff15 	stw	zero,-4(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
 3215f30:	01000084 	movi	r4,2
 3215f34:	321cf780 	call	321cf78 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3215f38:	0005303a 	rdctl	r2,status
 3215f3c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3215f40:	e0fffe17 	ldw	r3,-8(fp)
 3215f44:	00bfff84 	movi	r2,-2
 3215f48:	1884703a 	and	r2,r3,r2
 3215f4c:	1001703a 	wrctl	status,r2
  
  return context;
 3215f50:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
 3215f54:	e0bfff15 	stw	r2,-4(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
 3215f58:	d028a515 	stw	zero,-23916(gp)
 3215f5c:	e0bfff17 	ldw	r2,-4(fp)
 3215f60:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215f64:	e0bffd17 	ldw	r2,-12(fp)
 3215f68:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
 3215f6c:	01001904 	movi	r4,100
 3215f70:	321cf780 	call	321cf78 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3215f74:	0005303a 	rdctl	r2,status
 3215f78:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3215f7c:	e0fffc17 	ldw	r3,-16(fp)
 3215f80:	00bfff84 	movi	r2,-2
 3215f84:	1884703a 	and	r2,r3,r2
 3215f88:	1001703a 	wrctl	status,r2
  
  return context;
 3215f8c:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
 3215f90:	e0bfff15 	stw	r2,-4(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
 3215f94:	d0a8a517 	ldw	r2,-23916(gp)
 3215f98:	d0a8aa15 	stw	r2,-23896(gp)
    OSStatRdy    = OS_TRUE;
 3215f9c:	00800044 	movi	r2,1
 3215fa0:	d0a8b605 	stb	r2,-23848(gp)
 3215fa4:	e0bfff17 	ldw	r2,-4(fp)
 3215fa8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215fac:	e0bffb17 	ldw	r2,-20(fp)
 3215fb0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 3215fb4:	e037883a 	mov	sp,fp
 3215fb8:	dfc00117 	ldw	ra,4(sp)
 3215fbc:	df000017 	ldw	fp,0(sp)
 3215fc0:	dec00204 	addi	sp,sp,8
 3215fc4:	f800283a 	ret

03215fc8 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
 3215fc8:	defff604 	addi	sp,sp,-40
 3215fcc:	dfc00915 	stw	ra,36(sp)
 3215fd0:	df000815 	stw	fp,32(sp)
 3215fd4:	df000804 	addi	fp,sp,32
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 3215fd8:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
 3215fdc:	323b5780 	call	323b578 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3215fe0:	0005303a 	rdctl	r2,status
 3215fe4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3215fe8:	e0fffb17 	ldw	r3,-20(fp)
 3215fec:	00bfff84 	movi	r2,-2
 3215ff0:	1884703a 	and	r2,r3,r2
 3215ff4:	1001703a 	wrctl	status,r2
  
  return context;
 3215ff8:	e0bffb17 	ldw	r2,-20(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
 3215ffc:	e0bffc15 	stw	r2,-16(fp)
    OSTime++;
 3216000:	d0a8b417 	ldw	r2,-23856(gp)
 3216004:	10800044 	addi	r2,r2,1
 3216008:	d0a8b415 	stw	r2,-23856(gp)
 321600c:	e0bffc17 	ldw	r2,-16(fp)
 3216010:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3216014:	e0bffa17 	ldw	r2,-24(fp)
 3216018:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
 321601c:	d0a8a443 	ldbu	r2,-23919(gp)
 3216020:	10803fcc 	andi	r2,r2,255
 3216024:	10800058 	cmpnei	r2,r2,1
 3216028:	1000721e 	bne	r2,zero,32161f4 <OSTimeTick+0x22c>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
 321602c:	d0a8a803 	ldbu	r2,-23904(gp)
 3216030:	10803fcc 	andi	r2,r2,255
 3216034:	e0bfff15 	stw	r2,-4(fp)
 3216038:	e0ffff17 	ldw	r3,-4(fp)
 321603c:	18800060 	cmpeqi	r2,r3,1
 3216040:	10000a1e 	bne	r2,zero,321606c <OSTimeTick+0xa4>
 3216044:	e0ffff17 	ldw	r3,-4(fp)
 3216048:	188000a0 	cmpeqi	r2,r3,2
 321604c:	1000091e 	bne	r2,zero,3216074 <OSTimeTick+0xac>
 3216050:	e0ffff17 	ldw	r3,-4(fp)
 3216054:	1805003a 	cmpeq	r2,r3,zero
 3216058:	1000011e 	bne	r2,zero,3216060 <OSTimeTick+0x98>
 321605c:	00000a06 	br	3216088 <OSTimeTick+0xc0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
 3216060:	00800044 	movi	r2,1
 3216064:	e0bffd05 	stb	r2,-12(fp)
                 break;
 3216068:	00000a06 	br	3216094 <OSTimeTick+0xcc>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
 321606c:	e03ffd05 	stb	zero,-12(fp)
                 break;
 3216070:	00000806 	br	3216094 <OSTimeTick+0xcc>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
 3216074:	00800044 	movi	r2,1
 3216078:	e0bffd05 	stb	r2,-12(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
 321607c:	00800044 	movi	r2,1
 3216080:	d0a8a805 	stb	r2,-23904(gp)
                 break;
 3216084:	00000306 	br	3216094 <OSTimeTick+0xcc>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
 3216088:	00800044 	movi	r2,1
 321608c:	e0bffd05 	stb	r2,-12(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
 3216090:	d028a805 	stb	zero,-23904(gp)
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
 3216094:	e0bffd03 	ldbu	r2,-12(fp)
 3216098:	1005003a 	cmpeq	r2,r2,zero
 321609c:	1000551e 	bne	r2,zero,32161f4 <OSTimeTick+0x22c>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
 32160a0:	d0a8a717 	ldw	r2,-23908(gp)
 32160a4:	e0bffe15 	stw	r2,-8(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 32160a8:	00004d06 	br	32161e0 <OSTimeTick+0x218>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32160ac:	0005303a 	rdctl	r2,status
 32160b0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32160b4:	e0fff917 	ldw	r3,-28(fp)
 32160b8:	00bfff84 	movi	r2,-2
 32160bc:	1884703a 	and	r2,r3,r2
 32160c0:	1001703a 	wrctl	status,r2
  
  return context;
 32160c4:	e0bff917 	ldw	r2,-28(fp)
            OS_ENTER_CRITICAL();
 32160c8:	e0bffc15 	stw	r2,-16(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
 32160cc:	e0bffe17 	ldw	r2,-8(fp)
 32160d0:	10800b8b 	ldhu	r2,46(r2)
 32160d4:	10bfffcc 	andi	r2,r2,65535
 32160d8:	1005003a 	cmpeq	r2,r2,zero
 32160dc:	1000391e 	bne	r2,zero,32161c4 <OSTimeTick+0x1fc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
 32160e0:	e0bffe17 	ldw	r2,-8(fp)
 32160e4:	10800b8b 	ldhu	r2,46(r2)
 32160e8:	10bfffc4 	addi	r2,r2,-1
 32160ec:	1007883a 	mov	r3,r2
 32160f0:	e0bffe17 	ldw	r2,-8(fp)
 32160f4:	10c00b8d 	sth	r3,46(r2)
 32160f8:	e0bffe17 	ldw	r2,-8(fp)
 32160fc:	10800b8b 	ldhu	r2,46(r2)
 3216100:	10bfffcc 	andi	r2,r2,65535
 3216104:	1004c03a 	cmpne	r2,r2,zero
 3216108:	10002e1e 	bne	r2,zero,32161c4 <OSTimeTick+0x1fc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 321610c:	e0bffe17 	ldw	r2,-8(fp)
 3216110:	10800c03 	ldbu	r2,48(r2)
 3216114:	10803fcc 	andi	r2,r2,255
 3216118:	10800dcc 	andi	r2,r2,55
 321611c:	1005003a 	cmpeq	r2,r2,zero
 3216120:	10000b1e 	bne	r2,zero,3216150 <OSTimeTick+0x188>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
 3216124:	e0bffe17 	ldw	r2,-8(fp)
 3216128:	10c00c03 	ldbu	r3,48(r2)
 321612c:	00bff204 	movi	r2,-56
 3216130:	1884703a 	and	r2,r3,r2
 3216134:	1007883a 	mov	r3,r2
 3216138:	e0bffe17 	ldw	r2,-8(fp)
 321613c:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
 3216140:	e0fffe17 	ldw	r3,-8(fp)
 3216144:	00800044 	movi	r2,1
 3216148:	18800c45 	stb	r2,49(r3)
 321614c:	00000206 	br	3216158 <OSTimeTick+0x190>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 3216150:	e0bffe17 	ldw	r2,-8(fp)
 3216154:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
 3216158:	e0bffe17 	ldw	r2,-8(fp)
 321615c:	10800c03 	ldbu	r2,48(r2)
 3216160:	10803fcc 	andi	r2,r2,255
 3216164:	1080020c 	andi	r2,r2,8
 3216168:	1004c03a 	cmpne	r2,r2,zero
 321616c:	1000151e 	bne	r2,zero,32161c4 <OSTimeTick+0x1fc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
 3216170:	e0bffe17 	ldw	r2,-8(fp)
 3216174:	10c00d83 	ldbu	r3,54(r2)
 3216178:	d0a8b003 	ldbu	r2,-23872(gp)
 321617c:	1884b03a 	or	r2,r3,r2
 3216180:	d0a8b005 	stb	r2,-23872(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 3216184:	e0bffe17 	ldw	r2,-8(fp)
 3216188:	10800d03 	ldbu	r2,52(r2)
 321618c:	11003fcc 	andi	r4,r2,255
 3216190:	e0bffe17 	ldw	r2,-8(fp)
 3216194:	10800d03 	ldbu	r2,52(r2)
 3216198:	10c03fcc 	andi	r3,r2,255
 321619c:	d0a8b044 	addi	r2,gp,-23871
 32161a0:	1885883a 	add	r2,r3,r2
 32161a4:	10c00003 	ldbu	r3,0(r2)
 32161a8:	e0bffe17 	ldw	r2,-8(fp)
 32161ac:	10800d43 	ldbu	r2,53(r2)
 32161b0:	1884b03a 	or	r2,r3,r2
 32161b4:	1007883a 	mov	r3,r2
 32161b8:	d0a8b044 	addi	r2,gp,-23871
 32161bc:	2085883a 	add	r2,r4,r2
 32161c0:	10c00005 	stb	r3,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
 32161c4:	e0bffe17 	ldw	r2,-8(fp)
 32161c8:	10800517 	ldw	r2,20(r2)
 32161cc:	e0bffe15 	stw	r2,-8(fp)
 32161d0:	e0bffc17 	ldw	r2,-16(fp)
 32161d4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 32161d8:	e0bff817 	ldw	r2,-32(fp)
 32161dc:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 32161e0:	e0bffe17 	ldw	r2,-8(fp)
 32161e4:	10800c83 	ldbu	r2,50(r2)
 32161e8:	10803fcc 	andi	r2,r2,255
 32161ec:	10800518 	cmpnei	r2,r2,20
 32161f0:	103fae1e 	bne	r2,zero,32160ac <OSTimeTick+0xe4>
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
 32161f4:	e037883a 	mov	sp,fp
 32161f8:	dfc00117 	ldw	ra,4(sp)
 32161fc:	df000017 	ldw	fp,0(sp)
 3216200:	dec00204 	addi	sp,sp,8
 3216204:	f800283a 	ret

03216208 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
 3216208:	deffff04 	addi	sp,sp,-4
 321620c:	df000015 	stw	fp,0(sp)
 3216210:	d839883a 	mov	fp,sp
    return (OS_VERSION);
 3216214:	00804784 	movi	r2,286
}
 3216218:	e037883a 	mov	sp,fp
 321621c:	df000017 	ldw	fp,0(sp)
 3216220:	dec00104 	addi	sp,sp,4
 3216224:	f800283a 	ret

03216228 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
 3216228:	deffff04 	addi	sp,sp,-4
 321622c:	df000015 	stw	fp,0(sp)
 3216230:	d839883a 	mov	fp,sp
}
 3216234:	e037883a 	mov	sp,fp
 3216238:	df000017 	ldw	fp,0(sp)
 321623c:	dec00104 	addi	sp,sp,4
 3216240:	f800283a 	ret

03216244 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
 3216244:	defff804 	addi	sp,sp,-32
 3216248:	dfc00715 	stw	ra,28(sp)
 321624c:	df000615 	stw	fp,24(sp)
 3216250:	df000604 	addi	fp,sp,24
 3216254:	e13ffc15 	stw	r4,-16(fp)
 3216258:	e17ffd15 	stw	r5,-12(fp)
 321625c:	e1bffe05 	stb	r6,-8(fp)
 3216260:	e1ffff05 	stb	r7,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
 3216264:	e0bffc17 	ldw	r2,-16(fp)
 3216268:	10800283 	ldbu	r2,10(r2)
 321626c:	10c03fcc 	andi	r3,r2,255
 3216270:	0080c974 	movhi	r2,805
 3216274:	10b88f04 	addi	r2,r2,-7620
 3216278:	10c5883a 	add	r2,r2,r3
 321627c:	10800003 	ldbu	r2,0(r2)
 3216280:	e0bffa85 	stb	r2,-22(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
 3216284:	e0fffa83 	ldbu	r3,-22(fp)
 3216288:	e0bffc17 	ldw	r2,-16(fp)
 321628c:	1885883a 	add	r2,r3,r2
 3216290:	10800204 	addi	r2,r2,8
 3216294:	108000c3 	ldbu	r2,3(r2)
 3216298:	10c03fcc 	andi	r3,r2,255
 321629c:	0080c974 	movhi	r2,805
 32162a0:	10b88f04 	addi	r2,r2,-7620
 32162a4:	10c5883a 	add	r2,r2,r3
 32162a8:	10800003 	ldbu	r2,0(r2)
 32162ac:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
 32162b0:	e0bffa83 	ldbu	r2,-22(fp)
 32162b4:	100490fa 	slli	r2,r2,3
 32162b8:	1007883a 	mov	r3,r2
 32162bc:	e0bffa43 	ldbu	r2,-23(fp)
 32162c0:	1885883a 	add	r2,r3,r2
 32162c4:	e0bffa05 	stb	r2,-24(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
 32162c8:	e0bffa03 	ldbu	r2,-24(fp)
 32162cc:	00c0c9b4 	movhi	r3,806
 32162d0:	18f18004 	addi	r3,r3,-14848
 32162d4:	1085883a 	add	r2,r2,r2
 32162d8:	1085883a 	add	r2,r2,r2
 32162dc:	10c5883a 	add	r2,r2,r3
 32162e0:	10800017 	ldw	r2,0(r2)
 32162e4:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
 32162e8:	e0bffb17 	ldw	r2,-20(fp)
 32162ec:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
 32162f0:	e0fffb17 	ldw	r3,-20(fp)
 32162f4:	e0bffd17 	ldw	r2,-12(fp)
 32162f8:	18800915 	stw	r2,36(r3)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
 32162fc:	e0bffb17 	ldw	r2,-20(fp)
 3216300:	10800c03 	ldbu	r2,48(r2)
 3216304:	1007883a 	mov	r3,r2
 3216308:	e0bffe03 	ldbu	r2,-8(fp)
 321630c:	0084303a 	nor	r2,zero,r2
 3216310:	1884703a 	and	r2,r3,r2
 3216314:	1007883a 	mov	r3,r2
 3216318:	e0bffb17 	ldw	r2,-20(fp)
 321631c:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
 3216320:	e0fffb17 	ldw	r3,-20(fp)
 3216324:	e0bfff03 	ldbu	r2,-4(fp)
 3216328:	18800c45 	stb	r2,49(r3)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
 321632c:	e0bffb17 	ldw	r2,-20(fp)
 3216330:	10800c03 	ldbu	r2,48(r2)
 3216334:	10803fcc 	andi	r2,r2,255
 3216338:	1080020c 	andi	r2,r2,8
 321633c:	1004c03a 	cmpne	r2,r2,zero
 3216340:	1000111e 	bne	r2,zero,3216388 <OS_EventTaskRdy+0x144>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
 3216344:	e0bffb17 	ldw	r2,-20(fp)
 3216348:	10c00d83 	ldbu	r3,54(r2)
 321634c:	d0a8b003 	ldbu	r2,-23872(gp)
 3216350:	1884b03a 	or	r2,r3,r2
 3216354:	d0a8b005 	stb	r2,-23872(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
 3216358:	e13ffa83 	ldbu	r4,-22(fp)
 321635c:	e0fffa83 	ldbu	r3,-22(fp)
 3216360:	d0a8b044 	addi	r2,gp,-23871
 3216364:	1885883a 	add	r2,r3,r2
 3216368:	10c00003 	ldbu	r3,0(r2)
 321636c:	e0bffb17 	ldw	r2,-20(fp)
 3216370:	10800d43 	ldbu	r2,53(r2)
 3216374:	1884b03a 	or	r2,r3,r2
 3216378:	1007883a 	mov	r3,r2
 321637c:	d0a8b044 	addi	r2,gp,-23871
 3216380:	2085883a 	add	r2,r4,r2
 3216384:	10c00005 	stb	r3,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
 3216388:	e13ffb17 	ldw	r4,-20(fp)
 321638c:	e17ffc17 	ldw	r5,-16(fp)
 3216390:	321663c0 	call	321663c <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
 3216394:	e0bffb17 	ldw	r2,-20(fp)
 3216398:	10800817 	ldw	r2,32(r2)
 321639c:	1005003a 	cmpeq	r2,r2,zero
 32163a0:	1000071e 	bne	r2,zero,32163c0 <OS_EventTaskRdy+0x17c>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 32163a4:	e0bffb17 	ldw	r2,-20(fp)
 32163a8:	11400817 	ldw	r5,32(r2)
 32163ac:	e13ffb17 	ldw	r4,-20(fp)
 32163b0:	32166f40 	call	32166f4 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
 32163b4:	e0fffb17 	ldw	r3,-20(fp)
 32163b8:	e0bffc17 	ldw	r2,-16(fp)
 32163bc:	18800715 	stw	r2,28(r3)
    }
#endif

    return (prio);
 32163c0:	e0bffa03 	ldbu	r2,-24(fp)
}
 32163c4:	e037883a 	mov	sp,fp
 32163c8:	dfc00117 	ldw	ra,4(sp)
 32163cc:	df000017 	ldw	fp,0(sp)
 32163d0:	dec00204 	addi	sp,sp,8
 32163d4:	f800283a 	ret

032163d8 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
 32163d8:	defffd04 	addi	sp,sp,-12
 32163dc:	df000215 	stw	fp,8(sp)
 32163e0:	df000204 	addi	fp,sp,8
 32163e4:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
 32163e8:	d0e8b317 	ldw	r3,-23860(gp)
 32163ec:	e0bfff17 	ldw	r2,-4(fp)
 32163f0:	18800715 	stw	r2,28(r3)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
 32163f4:	d0a8b317 	ldw	r2,-23860(gp)
 32163f8:	10800d03 	ldbu	r2,52(r2)
 32163fc:	11003fcc 	andi	r4,r2,255
 3216400:	d0a8b317 	ldw	r2,-23860(gp)
 3216404:	10800d03 	ldbu	r2,52(r2)
 3216408:	10c03fcc 	andi	r3,r2,255
 321640c:	e0bfff17 	ldw	r2,-4(fp)
 3216410:	1885883a 	add	r2,r3,r2
 3216414:	10800204 	addi	r2,r2,8
 3216418:	10c000c3 	ldbu	r3,3(r2)
 321641c:	d0a8b317 	ldw	r2,-23860(gp)
 3216420:	10800d43 	ldbu	r2,53(r2)
 3216424:	1884b03a 	or	r2,r3,r2
 3216428:	1007883a 	mov	r3,r2
 321642c:	e0bfff17 	ldw	r2,-4(fp)
 3216430:	2085883a 	add	r2,r4,r2
 3216434:	10800204 	addi	r2,r2,8
 3216438:	10c000c5 	stb	r3,3(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 321643c:	e0bfff17 	ldw	r2,-4(fp)
 3216440:	10c00283 	ldbu	r3,10(r2)
 3216444:	d0a8b317 	ldw	r2,-23860(gp)
 3216448:	10800d83 	ldbu	r2,54(r2)
 321644c:	1884b03a 	or	r2,r3,r2
 3216450:	1007883a 	mov	r3,r2
 3216454:	e0bfff17 	ldw	r2,-4(fp)
 3216458:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 321645c:	d0a8b317 	ldw	r2,-23860(gp)
 3216460:	10800d03 	ldbu	r2,52(r2)
 3216464:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 3216468:	e13ffe03 	ldbu	r4,-8(fp)
 321646c:	e0fffe03 	ldbu	r3,-8(fp)
 3216470:	d0a8b044 	addi	r2,gp,-23871
 3216474:	1885883a 	add	r2,r3,r2
 3216478:	10800003 	ldbu	r2,0(r2)
 321647c:	1007883a 	mov	r3,r2
 3216480:	d0a8b317 	ldw	r2,-23860(gp)
 3216484:	10800d43 	ldbu	r2,53(r2)
 3216488:	0084303a 	nor	r2,zero,r2
 321648c:	1884703a 	and	r2,r3,r2
 3216490:	1007883a 	mov	r3,r2
 3216494:	d0a8b044 	addi	r2,gp,-23871
 3216498:	2085883a 	add	r2,r4,r2
 321649c:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 32164a0:	e0fffe03 	ldbu	r3,-8(fp)
 32164a4:	d0a8b044 	addi	r2,gp,-23871
 32164a8:	1885883a 	add	r2,r3,r2
 32164ac:	10800003 	ldbu	r2,0(r2)
 32164b0:	10803fcc 	andi	r2,r2,255
 32164b4:	1004c03a 	cmpne	r2,r2,zero
 32164b8:	1000071e 	bne	r2,zero,32164d8 <OS_EventTaskWait+0x100>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 32164bc:	d0a8b317 	ldw	r2,-23860(gp)
 32164c0:	10800d83 	ldbu	r2,54(r2)
 32164c4:	0084303a 	nor	r2,zero,r2
 32164c8:	1007883a 	mov	r3,r2
 32164cc:	d0a8b003 	ldbu	r2,-23872(gp)
 32164d0:	1884703a 	and	r2,r3,r2
 32164d4:	d0a8b005 	stb	r2,-23872(gp)
    }
}
 32164d8:	e037883a 	mov	sp,fp
 32164dc:	df000017 	ldw	fp,0(sp)
 32164e0:	dec00104 	addi	sp,sp,4
 32164e4:	f800283a 	ret

032164e8 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
 32164e8:	defffb04 	addi	sp,sp,-20
 32164ec:	df000415 	stw	fp,16(sp)
 32164f0:	df000404 	addi	fp,sp,16
 32164f4:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
 32164f8:	d0a8b317 	ldw	r2,-23860(gp)
 32164fc:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
 3216500:	d0e8b317 	ldw	r3,-23860(gp)
 3216504:	e0bfff17 	ldw	r2,-4(fp)
 3216508:	18800815 	stw	r2,32(r3)

    pevents =  pevents_wait;
 321650c:	e0bfff17 	ldw	r2,-4(fp)
 3216510:	e0bffe15 	stw	r2,-8(fp)
    pevent  = *pevents;
 3216514:	e0bffe17 	ldw	r2,-8(fp)
 3216518:	10800017 	ldw	r2,0(r2)
 321651c:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 3216520:	00002006 	br	32165a4 <OS_EventTaskWaitMulti+0xbc>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
 3216524:	d0a8b317 	ldw	r2,-23860(gp)
 3216528:	10800d03 	ldbu	r2,52(r2)
 321652c:	11003fcc 	andi	r4,r2,255
 3216530:	d0a8b317 	ldw	r2,-23860(gp)
 3216534:	10800d03 	ldbu	r2,52(r2)
 3216538:	10c03fcc 	andi	r3,r2,255
 321653c:	e0bffd17 	ldw	r2,-12(fp)
 3216540:	1885883a 	add	r2,r3,r2
 3216544:	10800204 	addi	r2,r2,8
 3216548:	10c000c3 	ldbu	r3,3(r2)
 321654c:	d0a8b317 	ldw	r2,-23860(gp)
 3216550:	10800d43 	ldbu	r2,53(r2)
 3216554:	1884b03a 	or	r2,r3,r2
 3216558:	1007883a 	mov	r3,r2
 321655c:	e0bffd17 	ldw	r2,-12(fp)
 3216560:	2085883a 	add	r2,r4,r2
 3216564:	10800204 	addi	r2,r2,8
 3216568:	10c000c5 	stb	r3,3(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 321656c:	e0bffd17 	ldw	r2,-12(fp)
 3216570:	10c00283 	ldbu	r3,10(r2)
 3216574:	d0a8b317 	ldw	r2,-23860(gp)
 3216578:	10800d83 	ldbu	r2,54(r2)
 321657c:	1884b03a 	or	r2,r3,r2
 3216580:	1007883a 	mov	r3,r2
 3216584:	e0bffd17 	ldw	r2,-12(fp)
 3216588:	10c00285 	stb	r3,10(r2)
        pevents++;
 321658c:	e0bffe17 	ldw	r2,-8(fp)
 3216590:	10800104 	addi	r2,r2,4
 3216594:	e0bffe15 	stw	r2,-8(fp)
        pevent = *pevents;
 3216598:	e0bffe17 	ldw	r2,-8(fp)
 321659c:	10800017 	ldw	r2,0(r2)
 32165a0:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 32165a4:	e0bffd17 	ldw	r2,-12(fp)
 32165a8:	1004c03a 	cmpne	r2,r2,zero
 32165ac:	103fdd1e 	bne	r2,zero,3216524 <OS_EventTaskWaitMulti+0x3c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 32165b0:	d0a8b317 	ldw	r2,-23860(gp)
 32165b4:	10800d03 	ldbu	r2,52(r2)
 32165b8:	e0bffc05 	stb	r2,-16(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 32165bc:	e13ffc03 	ldbu	r4,-16(fp)
 32165c0:	e0fffc03 	ldbu	r3,-16(fp)
 32165c4:	d0a8b044 	addi	r2,gp,-23871
 32165c8:	1885883a 	add	r2,r3,r2
 32165cc:	10800003 	ldbu	r2,0(r2)
 32165d0:	1007883a 	mov	r3,r2
 32165d4:	d0a8b317 	ldw	r2,-23860(gp)
 32165d8:	10800d43 	ldbu	r2,53(r2)
 32165dc:	0084303a 	nor	r2,zero,r2
 32165e0:	1884703a 	and	r2,r3,r2
 32165e4:	1007883a 	mov	r3,r2
 32165e8:	d0a8b044 	addi	r2,gp,-23871
 32165ec:	2085883a 	add	r2,r4,r2
 32165f0:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 32165f4:	e0fffc03 	ldbu	r3,-16(fp)
 32165f8:	d0a8b044 	addi	r2,gp,-23871
 32165fc:	1885883a 	add	r2,r3,r2
 3216600:	10800003 	ldbu	r2,0(r2)
 3216604:	10803fcc 	andi	r2,r2,255
 3216608:	1004c03a 	cmpne	r2,r2,zero
 321660c:	1000071e 	bne	r2,zero,321662c <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 3216610:	d0a8b317 	ldw	r2,-23860(gp)
 3216614:	10800d83 	ldbu	r2,54(r2)
 3216618:	0084303a 	nor	r2,zero,r2
 321661c:	1007883a 	mov	r3,r2
 3216620:	d0a8b003 	ldbu	r2,-23872(gp)
 3216624:	1884703a 	and	r2,r3,r2
 3216628:	d0a8b005 	stb	r2,-23872(gp)
    }
}
 321662c:	e037883a 	mov	sp,fp
 3216630:	df000017 	ldw	fp,0(sp)
 3216634:	dec00104 	addi	sp,sp,4
 3216638:	f800283a 	ret

0321663c <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
 321663c:	defffc04 	addi	sp,sp,-16
 3216640:	df000315 	stw	fp,12(sp)
 3216644:	df000304 	addi	fp,sp,12
 3216648:	e13ffe15 	stw	r4,-8(fp)
 321664c:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
 3216650:	e0bffe17 	ldw	r2,-8(fp)
 3216654:	10800d03 	ldbu	r2,52(r2)
 3216658:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
 321665c:	e13ffd03 	ldbu	r4,-12(fp)
 3216660:	e0fffd03 	ldbu	r3,-12(fp)
 3216664:	e0bfff17 	ldw	r2,-4(fp)
 3216668:	1885883a 	add	r2,r3,r2
 321666c:	10800204 	addi	r2,r2,8
 3216670:	108000c3 	ldbu	r2,3(r2)
 3216674:	1007883a 	mov	r3,r2
 3216678:	e0bffe17 	ldw	r2,-8(fp)
 321667c:	10800d43 	ldbu	r2,53(r2)
 3216680:	0084303a 	nor	r2,zero,r2
 3216684:	1884703a 	and	r2,r3,r2
 3216688:	1007883a 	mov	r3,r2
 321668c:	e0bfff17 	ldw	r2,-4(fp)
 3216690:	2085883a 	add	r2,r4,r2
 3216694:	10800204 	addi	r2,r2,8
 3216698:	10c000c5 	stb	r3,3(r2)
    if (pevent->OSEventTbl[y] == 0) {
 321669c:	e0fffd03 	ldbu	r3,-12(fp)
 32166a0:	e0bfff17 	ldw	r2,-4(fp)
 32166a4:	1885883a 	add	r2,r3,r2
 32166a8:	10800204 	addi	r2,r2,8
 32166ac:	108000c3 	ldbu	r2,3(r2)
 32166b0:	10803fcc 	andi	r2,r2,255
 32166b4:	1004c03a 	cmpne	r2,r2,zero
 32166b8:	10000a1e 	bne	r2,zero,32166e4 <OS_EventTaskRemove+0xa8>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
 32166bc:	e0bfff17 	ldw	r2,-4(fp)
 32166c0:	10800283 	ldbu	r2,10(r2)
 32166c4:	1007883a 	mov	r3,r2
 32166c8:	e0bffe17 	ldw	r2,-8(fp)
 32166cc:	10800d83 	ldbu	r2,54(r2)
 32166d0:	0084303a 	nor	r2,zero,r2
 32166d4:	1884703a 	and	r2,r3,r2
 32166d8:	1007883a 	mov	r3,r2
 32166dc:	e0bfff17 	ldw	r2,-4(fp)
 32166e0:	10c00285 	stb	r3,10(r2)
    }
}
 32166e4:	e037883a 	mov	sp,fp
 32166e8:	df000017 	ldw	fp,0(sp)
 32166ec:	dec00104 	addi	sp,sp,4
 32166f0:	f800283a 	ret

032166f4 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
 32166f4:	defffa04 	addi	sp,sp,-24
 32166f8:	df000515 	stw	fp,20(sp)
 32166fc:	df000504 	addi	fp,sp,20
 3216700:	e13ffe15 	stw	r4,-8(fp)
 3216704:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
 3216708:	e0bffe17 	ldw	r2,-8(fp)
 321670c:	10800d03 	ldbu	r2,52(r2)
 3216710:	e0bffb85 	stb	r2,-18(fp)
    bity    =  ptcb->OSTCBBitY;
 3216714:	e0bffe17 	ldw	r2,-8(fp)
 3216718:	10800d83 	ldbu	r2,54(r2)
 321671c:	e0bffb45 	stb	r2,-19(fp)
    bitx    =  ptcb->OSTCBBitX;
 3216720:	e0bffe17 	ldw	r2,-8(fp)
 3216724:	10800d43 	ldbu	r2,53(r2)
 3216728:	e0bffb05 	stb	r2,-20(fp)
    pevents =  pevents_multi;
 321672c:	e0bfff17 	ldw	r2,-4(fp)
 3216730:	e0bffd15 	stw	r2,-12(fp)
    pevent  = *pevents;
 3216734:	e0bffd17 	ldw	r2,-12(fp)
 3216738:	10800017 	ldw	r2,0(r2)
 321673c:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 3216740:	00002606 	br	32167dc <OS_EventTaskRemoveMulti+0xe8>
        pevent->OSEventTbl[y]  &= ~bitx;
 3216744:	e13ffb83 	ldbu	r4,-18(fp)
 3216748:	e0fffb83 	ldbu	r3,-18(fp)
 321674c:	e0bffc17 	ldw	r2,-16(fp)
 3216750:	1885883a 	add	r2,r3,r2
 3216754:	10800204 	addi	r2,r2,8
 3216758:	108000c3 	ldbu	r2,3(r2)
 321675c:	1007883a 	mov	r3,r2
 3216760:	e0bffb03 	ldbu	r2,-20(fp)
 3216764:	0084303a 	nor	r2,zero,r2
 3216768:	1884703a 	and	r2,r3,r2
 321676c:	1007883a 	mov	r3,r2
 3216770:	e0bffc17 	ldw	r2,-16(fp)
 3216774:	2085883a 	add	r2,r4,r2
 3216778:	10800204 	addi	r2,r2,8
 321677c:	10c000c5 	stb	r3,3(r2)
        if (pevent->OSEventTbl[y] == 0) {
 3216780:	e0fffb83 	ldbu	r3,-18(fp)
 3216784:	e0bffc17 	ldw	r2,-16(fp)
 3216788:	1885883a 	add	r2,r3,r2
 321678c:	10800204 	addi	r2,r2,8
 3216790:	108000c3 	ldbu	r2,3(r2)
 3216794:	10803fcc 	andi	r2,r2,255
 3216798:	1004c03a 	cmpne	r2,r2,zero
 321679c:	1000091e 	bne	r2,zero,32167c4 <OS_EventTaskRemoveMulti+0xd0>
            pevent->OSEventGrp &= ~bity;
 32167a0:	e0bffc17 	ldw	r2,-16(fp)
 32167a4:	10800283 	ldbu	r2,10(r2)
 32167a8:	1007883a 	mov	r3,r2
 32167ac:	e0bffb43 	ldbu	r2,-19(fp)
 32167b0:	0084303a 	nor	r2,zero,r2
 32167b4:	1884703a 	and	r2,r3,r2
 32167b8:	1007883a 	mov	r3,r2
 32167bc:	e0bffc17 	ldw	r2,-16(fp)
 32167c0:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
 32167c4:	e0bffd17 	ldw	r2,-12(fp)
 32167c8:	10800104 	addi	r2,r2,4
 32167cc:	e0bffd15 	stw	r2,-12(fp)
        pevent = *pevents;
 32167d0:	e0bffd17 	ldw	r2,-12(fp)
 32167d4:	10800017 	ldw	r2,0(r2)
 32167d8:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 32167dc:	e0bffc17 	ldw	r2,-16(fp)
 32167e0:	1004c03a 	cmpne	r2,r2,zero
 32167e4:	103fd71e 	bne	r2,zero,3216744 <OS_EventTaskRemoveMulti+0x50>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
 32167e8:	e037883a 	mov	sp,fp
 32167ec:	df000017 	ldw	fp,0(sp)
 32167f0:	dec00104 	addi	sp,sp,4
 32167f4:	f800283a 	ret

032167f8 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
 32167f8:	defffc04 	addi	sp,sp,-16
 32167fc:	df000315 	stw	fp,12(sp)
 3216800:	df000304 	addi	fp,sp,12
 3216804:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
 3216808:	e0bfff17 	ldw	r2,-4(fp)
 321680c:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
 3216810:	e0bfff17 	ldw	r2,-4(fp)
 3216814:	108002c4 	addi	r2,r2,11
 3216818:	e0bffe15 	stw	r2,-8(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 321681c:	e03ffd05 	stb	zero,-12(fp)
 3216820:	00000806 	br	3216844 <OS_EventWaitListInit+0x4c>
        *ptbl++ = 0;
 3216824:	e0bffe17 	ldw	r2,-8(fp)
 3216828:	10000005 	stb	zero,0(r2)
 321682c:	e0bffe17 	ldw	r2,-8(fp)
 3216830:	10800044 	addi	r2,r2,1
 3216834:	e0bffe15 	stw	r2,-8(fp)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 3216838:	e0bffd03 	ldbu	r2,-12(fp)
 321683c:	10800044 	addi	r2,r2,1
 3216840:	e0bffd05 	stb	r2,-12(fp)
 3216844:	e0bffd03 	ldbu	r2,-12(fp)
 3216848:	108000f0 	cmpltui	r2,r2,3
 321684c:	103ff51e 	bne	r2,zero,3216824 <OS_EventWaitListInit+0x2c>
        *ptbl++ = 0;
    }
}
 3216850:	e037883a 	mov	sp,fp
 3216854:	df000017 	ldw	fp,0(sp)
 3216858:	dec00104 	addi	sp,sp,4
 321685c:	f800283a 	ret

03216860 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
 3216860:	defffb04 	addi	sp,sp,-20
 3216864:	dfc00415 	stw	ra,16(sp)
 3216868:	df000315 	stw	fp,12(sp)
 321686c:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
 3216870:	0100c9b4 	movhi	r4,806
 3216874:	212d6c04 	addi	r4,r4,-19024
 3216878:	0142d004 	movi	r5,2880
 321687c:	3216bc40 	call	3216bc4 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
 3216880:	0080c9b4 	movhi	r2,806
 3216884:	10ad6c04 	addi	r2,r2,-19024
 3216888:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
 321688c:	0080c9b4 	movhi	r2,806
 3216890:	10ad7804 	addi	r2,r2,-18976
 3216894:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 3216898:	e03fff0d 	sth	zero,-4(fp)
 321689c:	00001306 	br	32168ec <OS_InitEventList+0x8c>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
 32168a0:	e0bffe17 	ldw	r2,-8(fp)
 32168a4:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
 32168a8:	e0fffe17 	ldw	r3,-8(fp)
 32168ac:	e0bffd17 	ldw	r2,-12(fp)
 32168b0:	18800115 	stw	r2,4(r3)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
 32168b4:	e0fffe17 	ldw	r3,-8(fp)
 32168b8:	00800fc4 	movi	r2,63
 32168bc:	18800385 	stb	r2,14(r3)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
 32168c0:	e0bffe17 	ldw	r2,-8(fp)
 32168c4:	100003c5 	stb	zero,15(r2)
#endif
        pevent1++;
 32168c8:	e0bffe17 	ldw	r2,-8(fp)
 32168cc:	10800c04 	addi	r2,r2,48
 32168d0:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
 32168d4:	e0bffd17 	ldw	r2,-12(fp)
 32168d8:	10800c04 	addi	r2,r2,48
 32168dc:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 32168e0:	e0bfff0b 	ldhu	r2,-4(fp)
 32168e4:	10800044 	addi	r2,r2,1
 32168e8:	e0bfff0d 	sth	r2,-4(fp)
 32168ec:	e0bfff0b 	ldhu	r2,-4(fp)
 32168f0:	10800ef0 	cmpltui	r2,r2,59
 32168f4:	103fea1e 	bne	r2,zero,32168a0 <OS_InitEventList+0x40>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
 32168f8:	e0bffe17 	ldw	r2,-8(fp)
 32168fc:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
 3216900:	e0bffe17 	ldw	r2,-8(fp)
 3216904:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
 3216908:	e0fffe17 	ldw	r3,-8(fp)
 321690c:	00800fc4 	movi	r2,63
 3216910:	18800385 	stb	r2,14(r3)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
 3216914:	e0bffe17 	ldw	r2,-8(fp)
 3216918:	100003c5 	stb	zero,15(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
 321691c:	0080c9b4 	movhi	r2,806
 3216920:	10ad6c04 	addi	r2,r2,-19024
 3216924:	d0a8b115 	stw	r2,-23868(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
 3216928:	e037883a 	mov	sp,fp
 321692c:	dfc00117 	ldw	ra,4(sp)
 3216930:	df000017 	ldw	fp,0(sp)
 3216934:	dec00204 	addi	sp,sp,8
 3216938:	f800283a 	ret

0321693c <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
 321693c:	deffff04 	addi	sp,sp,-4
 3216940:	df000015 	stw	fp,0(sp)
 3216944:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
 3216948:	d028b415 	stw	zero,-23856(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
 321694c:	d028b205 	stb	zero,-23864(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
 3216950:	d028a405 	stb	zero,-23920(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
 3216954:	d028ac45 	stb	zero,-23887(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
 3216958:	d028a445 	stb	zero,-23919(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
 321695c:	d028a915 	stw	zero,-23900(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
 3216960:	d028a515 	stw	zero,-23916(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
 3216964:	d028b715 	stw	zero,-23844(gp)
    OSIdleCtrMax  = 0L;
 3216968:	d028aa15 	stw	zero,-23896(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
 321696c:	d028b605 	stb	zero,-23848(gp)
#endif
}
 3216970:	e037883a 	mov	sp,fp
 3216974:	df000017 	ldw	fp,0(sp)
 3216978:	dec00104 	addi	sp,sp,4
 321697c:	f800283a 	ret

03216980 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
 3216980:	defffd04 	addi	sp,sp,-12
 3216984:	df000215 	stw	fp,8(sp)
 3216988:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
 321698c:	d028b005 	stb	zero,-23872(gp)
    prdytbl       = &OSRdyTbl[0];
 3216990:	d0a8b044 	addi	r2,gp,-23871
 3216994:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 3216998:	e03fff05 	stb	zero,-4(fp)
 321699c:	00000806 	br	32169c0 <OS_InitRdyList+0x40>
        *prdytbl++ = 0;
 32169a0:	e0bffe17 	ldw	r2,-8(fp)
 32169a4:	10000005 	stb	zero,0(r2)
 32169a8:	e0bffe17 	ldw	r2,-8(fp)
 32169ac:	10800044 	addi	r2,r2,1
 32169b0:	e0bffe15 	stw	r2,-8(fp)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 32169b4:	e0bfff03 	ldbu	r2,-4(fp)
 32169b8:	10800044 	addi	r2,r2,1
 32169bc:	e0bfff05 	stb	r2,-4(fp)
 32169c0:	e0bfff03 	ldbu	r2,-4(fp)
 32169c4:	108000f0 	cmpltui	r2,r2,3
 32169c8:	103ff51e 	bne	r2,zero,32169a0 <OS_InitRdyList+0x20>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
 32169cc:	d028a645 	stb	zero,-23911(gp)
    OSPrioHighRdy = 0;
 32169d0:	d028a605 	stb	zero,-23912(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
 32169d4:	d028ae15 	stw	zero,-23880(gp)
    OSTCBCur      = (OS_TCB *)0;
 32169d8:	d028b315 	stw	zero,-23860(gp)
}
 32169dc:	e037883a 	mov	sp,fp
 32169e0:	df000017 	ldw	fp,0(sp)
 32169e4:	dec00104 	addi	sp,sp,4
 32169e8:	f800283a 	ret

032169ec <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
 32169ec:	defff804 	addi	sp,sp,-32
 32169f0:	dfc00715 	stw	ra,28(sp)
 32169f4:	df000615 	stw	fp,24(sp)
 32169f8:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
 32169fc:	0180c9b4 	movhi	r6,806
 3216a00:	31ad6b04 	addi	r6,r6,-19028
 3216a04:	00bfffd4 	movui	r2,65535
 3216a08:	d8800015 	stw	r2,0(sp)
 3216a0c:	0080c9b4 	movhi	r2,806
 3216a10:	10ab6c04 	addi	r2,r2,-21072
 3216a14:	d8800115 	stw	r2,4(sp)
 3216a18:	00808004 	movi	r2,512
 3216a1c:	d8800215 	stw	r2,8(sp)
 3216a20:	d8000315 	stw	zero,12(sp)
 3216a24:	008000c4 	movi	r2,3
 3216a28:	d8800415 	stw	r2,16(sp)
 3216a2c:	0100c874 	movhi	r4,801
 3216a30:	211ba804 	addi	r4,r4,28320
 3216a34:	000b883a 	mov	r5,zero
 3216a38:	01c00504 	movi	r7,20
 3216a3c:	321bc800 	call	321bc80 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
 3216a40:	0140c974 	movhi	r5,805
 3216a44:	2978cf04 	addi	r5,r5,-7364
 3216a48:	01000504 	movi	r4,20
 3216a4c:	e1bfff04 	addi	r6,fp,-4
 3216a50:	321c5b40 	call	321c5b4 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
 3216a54:	e037883a 	mov	sp,fp
 3216a58:	dfc00117 	ldw	ra,4(sp)
 3216a5c:	df000017 	ldw	fp,0(sp)
 3216a60:	dec00204 	addi	sp,sp,8
 3216a64:	f800283a 	ret

03216a68 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
 3216a68:	defff804 	addi	sp,sp,-32
 3216a6c:	dfc00715 	stw	ra,28(sp)
 3216a70:	df000615 	stw	fp,24(sp)
 3216a74:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
 3216a78:	0180c9b4 	movhi	r6,806
 3216a7c:	31aaf304 	addi	r6,r6,-21556
 3216a80:	00bfff94 	movui	r2,65534
 3216a84:	d8800015 	stw	r2,0(sp)
 3216a88:	0080c9b4 	movhi	r2,806
 3216a8c:	10a8f404 	addi	r2,r2,-23600
 3216a90:	d8800115 	stw	r2,4(sp)
 3216a94:	00808004 	movi	r2,512
 3216a98:	d8800215 	stw	r2,8(sp)
 3216a9c:	d8000315 	stw	zero,12(sp)
 3216aa0:	008000c4 	movi	r2,3
 3216aa4:	d8800415 	stw	r2,16(sp)
 3216aa8:	0100c874 	movhi	r4,801
 3216aac:	211bbf04 	addi	r4,r4,28412
 3216ab0:	000b883a 	mov	r5,zero
 3216ab4:	01c004c4 	movi	r7,19
 3216ab8:	321bc800 	call	321bc80 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
 3216abc:	0140c974 	movhi	r5,805
 3216ac0:	2978d304 	addi	r5,r5,-7348
 3216ac4:	010004c4 	movi	r4,19
 3216ac8:	e1bfff04 	addi	r6,fp,-4
 3216acc:	321c5b40 	call	321c5b4 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
 3216ad0:	e037883a 	mov	sp,fp
 3216ad4:	dfc00117 	ldw	ra,4(sp)
 3216ad8:	df000017 	ldw	fp,0(sp)
 3216adc:	dec00204 	addi	sp,sp,8
 3216ae0:	f800283a 	ret

03216ae4 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
 3216ae4:	defffb04 	addi	sp,sp,-20
 3216ae8:	dfc00415 	stw	ra,16(sp)
 3216aec:	df000315 	stw	fp,12(sp)
 3216af0:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
 3216af4:	0100c9b4 	movhi	r4,806
 3216af8:	21303c04 	addi	r4,r4,-16144
 3216afc:	01414404 	movi	r5,1296
 3216b00:	3216bc40 	call	3216bc4 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
 3216b04:	0100c9b4 	movhi	r4,806
 3216b08:	21318004 	addi	r4,r4,-14848
 3216b0c:	01401504 	movi	r5,84
 3216b10:	3216bc40 	call	3216bc4 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
 3216b14:	0080c9b4 	movhi	r2,806
 3216b18:	10b03c04 	addi	r2,r2,-16144
 3216b1c:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
 3216b20:	0080c9b4 	movhi	r2,806
 3216b24:	10b05704 	addi	r2,r2,-16036
 3216b28:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 3216b2c:	e03fff05 	stb	zero,-4(fp)
 3216b30:	00001106 	br	3216b78 <OS_InitTCBList+0x94>
        ptcb1->OSTCBNext = ptcb2;
 3216b34:	e0fffe17 	ldw	r3,-8(fp)
 3216b38:	e0bffd17 	ldw	r2,-12(fp)
 3216b3c:	18800515 	stw	r2,20(r3)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
 3216b40:	e0fffe17 	ldw	r3,-8(fp)
 3216b44:	00800fc4 	movi	r2,63
 3216b48:	18801305 	stb	r2,76(r3)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 3216b4c:	e0bffe17 	ldw	r2,-8(fp)
 3216b50:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
 3216b54:	e0bffe17 	ldw	r2,-8(fp)
 3216b58:	10801b04 	addi	r2,r2,108
 3216b5c:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
 3216b60:	e0bffd17 	ldw	r2,-12(fp)
 3216b64:	10801b04 	addi	r2,r2,108
 3216b68:	e0bffd15 	stw	r2,-12(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 3216b6c:	e0bfff03 	ldbu	r2,-4(fp)
 3216b70:	10800044 	addi	r2,r2,1
 3216b74:	e0bfff05 	stb	r2,-4(fp)
 3216b78:	e0bfff03 	ldbu	r2,-4(fp)
 3216b7c:	108002f0 	cmpltui	r2,r2,11
 3216b80:	103fec1e 	bne	r2,zero,3216b34 <OS_InitTCBList+0x50>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
 3216b84:	e0bffe17 	ldw	r2,-8(fp)
 3216b88:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
 3216b8c:	e0fffe17 	ldw	r3,-8(fp)
 3216b90:	00800fc4 	movi	r2,63
 3216b94:	18801305 	stb	r2,76(r3)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 3216b98:	e0bffe17 	ldw	r2,-8(fp)
 3216b9c:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
 3216ba0:	d028a715 	stw	zero,-23908(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
 3216ba4:	0080c9b4 	movhi	r2,806
 3216ba8:	10b03c04 	addi	r2,r2,-16144
 3216bac:	d0a8ab15 	stw	r2,-23892(gp)
}
 3216bb0:	e037883a 	mov	sp,fp
 3216bb4:	dfc00117 	ldw	ra,4(sp)
 3216bb8:	df000017 	ldw	fp,0(sp)
 3216bbc:	dec00204 	addi	sp,sp,8
 3216bc0:	f800283a 	ret

03216bc4 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
 3216bc4:	defffd04 	addi	sp,sp,-12
 3216bc8:	df000215 	stw	fp,8(sp)
 3216bcc:	df000204 	addi	fp,sp,8
 3216bd0:	e13ffe15 	stw	r4,-8(fp)
 3216bd4:	e17fff0d 	sth	r5,-4(fp)
    while (size > 0) {
 3216bd8:	00000806 	br	3216bfc <OS_MemClr+0x38>
        *pdest++ = (INT8U)0;
 3216bdc:	e0bffe17 	ldw	r2,-8(fp)
 3216be0:	10000005 	stb	zero,0(r2)
 3216be4:	e0bffe17 	ldw	r2,-8(fp)
 3216be8:	10800044 	addi	r2,r2,1
 3216bec:	e0bffe15 	stw	r2,-8(fp)
        size--;
 3216bf0:	e0bfff0b 	ldhu	r2,-4(fp)
 3216bf4:	10bfffc4 	addi	r2,r2,-1
 3216bf8:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
 3216bfc:	e0bfff0b 	ldhu	r2,-4(fp)
 3216c00:	1004c03a 	cmpne	r2,r2,zero
 3216c04:	103ff51e 	bne	r2,zero,3216bdc <OS_MemClr+0x18>
        *pdest++ = (INT8U)0;
        size--;
    }
}
 3216c08:	e037883a 	mov	sp,fp
 3216c0c:	df000017 	ldw	fp,0(sp)
 3216c10:	dec00104 	addi	sp,sp,4
 3216c14:	f800283a 	ret

03216c18 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
 3216c18:	defffc04 	addi	sp,sp,-16
 3216c1c:	df000315 	stw	fp,12(sp)
 3216c20:	df000304 	addi	fp,sp,12
 3216c24:	e13ffd15 	stw	r4,-12(fp)
 3216c28:	e17ffe15 	stw	r5,-8(fp)
 3216c2c:	e1bfff0d 	sth	r6,-4(fp)
    while (size > 0) {
 3216c30:	00000d06 	br	3216c68 <OS_MemCopy+0x50>
        *pdest++ = *psrc++;
 3216c34:	e0bffe17 	ldw	r2,-8(fp)
 3216c38:	10c00003 	ldbu	r3,0(r2)
 3216c3c:	e0bffd17 	ldw	r2,-12(fp)
 3216c40:	10c00005 	stb	r3,0(r2)
 3216c44:	e0bffd17 	ldw	r2,-12(fp)
 3216c48:	10800044 	addi	r2,r2,1
 3216c4c:	e0bffd15 	stw	r2,-12(fp)
 3216c50:	e0bffe17 	ldw	r2,-8(fp)
 3216c54:	10800044 	addi	r2,r2,1
 3216c58:	e0bffe15 	stw	r2,-8(fp)
        size--;
 3216c5c:	e0bfff0b 	ldhu	r2,-4(fp)
 3216c60:	10bfffc4 	addi	r2,r2,-1
 3216c64:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
 3216c68:	e0bfff0b 	ldhu	r2,-4(fp)
 3216c6c:	1004c03a 	cmpne	r2,r2,zero
 3216c70:	103ff01e 	bne	r2,zero,3216c34 <OS_MemCopy+0x1c>
        *pdest++ = *psrc++;
        size--;
    }
}
 3216c74:	e037883a 	mov	sp,fp
 3216c78:	df000017 	ldw	fp,0(sp)
 3216c7c:	dec00104 	addi	sp,sp,4
 3216c80:	f800283a 	ret

03216c84 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
 3216c84:	defffb04 	addi	sp,sp,-20
 3216c88:	dfc00415 	stw	ra,16(sp)
 3216c8c:	df000315 	stw	fp,12(sp)
 3216c90:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 3216c94:	e03fff15 	stw	zero,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3216c98:	0005303a 	rdctl	r2,status
 3216c9c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3216ca0:	e0fffe17 	ldw	r3,-8(fp)
 3216ca4:	00bfff84 	movi	r2,-2
 3216ca8:	1884703a 	and	r2,r3,r2
 3216cac:	1001703a 	wrctl	status,r2
  
  return context;
 3216cb0:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 3216cb4:	e0bfff15 	stw	r2,-4(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
 3216cb8:	d0a8b203 	ldbu	r2,-23864(gp)
 3216cbc:	10803fcc 	andi	r2,r2,255
 3216cc0:	1004c03a 	cmpne	r2,r2,zero
 3216cc4:	10001b1e 	bne	r2,zero,3216d34 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
 3216cc8:	d0a8a403 	ldbu	r2,-23920(gp)
 3216ccc:	10803fcc 	andi	r2,r2,255
 3216cd0:	1004c03a 	cmpne	r2,r2,zero
 3216cd4:	1000171e 	bne	r2,zero,3216d34 <OS_Sched+0xb0>
            OS_SchedNew();
 3216cd8:	3216d580 	call	3216d58 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
 3216cdc:	d0a8a603 	ldbu	r2,-23912(gp)
 3216ce0:	d0e8a643 	ldbu	r3,-23911(gp)
 3216ce4:	11003fcc 	andi	r4,r2,255
 3216ce8:	18803fcc 	andi	r2,r3,255
 3216cec:	20801126 	beq	r4,r2,3216d34 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
 3216cf0:	d0a8a603 	ldbu	r2,-23912(gp)
 3216cf4:	10803fcc 	andi	r2,r2,255
 3216cf8:	00c0c9b4 	movhi	r3,806
 3216cfc:	18f18004 	addi	r3,r3,-14848
 3216d00:	1085883a 	add	r2,r2,r2
 3216d04:	1085883a 	add	r2,r2,r2
 3216d08:	10c5883a 	add	r2,r2,r3
 3216d0c:	10800017 	ldw	r2,0(r2)
 3216d10:	d0a8ae15 	stw	r2,-23880(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
 3216d14:	d0e8ae17 	ldw	r3,-23880(gp)
 3216d18:	18800e17 	ldw	r2,56(r3)
 3216d1c:	10800044 	addi	r2,r2,1
 3216d20:	18800e15 	stw	r2,56(r3)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
 3216d24:	d0a8a917 	ldw	r2,-23900(gp)
 3216d28:	10800044 	addi	r2,r2,1
 3216d2c:	d0a8a915 	stw	r2,-23900(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
 3216d30:	323b1200 	call	323b120 <OSCtxSw>
 3216d34:	e0bfff17 	ldw	r2,-4(fp)
 3216d38:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3216d3c:	e0bffd17 	ldw	r2,-12(fp)
 3216d40:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
 3216d44:	e037883a 	mov	sp,fp
 3216d48:	dfc00117 	ldw	ra,4(sp)
 3216d4c:	df000017 	ldw	fp,0(sp)
 3216d50:	dec00204 	addi	sp,sp,8
 3216d54:	f800283a 	ret

03216d58 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
 3216d58:	defffe04 	addi	sp,sp,-8
 3216d5c:	df000115 	stw	fp,4(sp)
 3216d60:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
 3216d64:	d0a8b003 	ldbu	r2,-23872(gp)
 3216d68:	10c03fcc 	andi	r3,r2,255
 3216d6c:	0080c974 	movhi	r2,805
 3216d70:	10b88f04 	addi	r2,r2,-7620
 3216d74:	10c5883a 	add	r2,r2,r3
 3216d78:	10800003 	ldbu	r2,0(r2)
 3216d7c:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
 3216d80:	e0bfff03 	ldbu	r2,-4(fp)
 3216d84:	100490fa 	slli	r2,r2,3
 3216d88:	1009883a 	mov	r4,r2
 3216d8c:	e0ffff03 	ldbu	r3,-4(fp)
 3216d90:	d0a8b044 	addi	r2,gp,-23871
 3216d94:	1885883a 	add	r2,r3,r2
 3216d98:	10800003 	ldbu	r2,0(r2)
 3216d9c:	10c03fcc 	andi	r3,r2,255
 3216da0:	0080c974 	movhi	r2,805
 3216da4:	10b88f04 	addi	r2,r2,-7620
 3216da8:	10c5883a 	add	r2,r2,r3
 3216dac:	10800003 	ldbu	r2,0(r2)
 3216db0:	2085883a 	add	r2,r4,r2
 3216db4:	d0a8a605 	stb	r2,-23912(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
 3216db8:	e037883a 	mov	sp,fp
 3216dbc:	df000017 	ldw	fp,0(sp)
 3216dc0:	dec00104 	addi	sp,sp,4
 3216dc4:	f800283a 	ret

03216dc8 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
 3216dc8:	defffc04 	addi	sp,sp,-16
 3216dcc:	df000315 	stw	fp,12(sp)
 3216dd0:	df000304 	addi	fp,sp,12
 3216dd4:	e13ffe15 	stw	r4,-8(fp)
 3216dd8:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
 3216ddc:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
 3216de0:	00000d06 	br	3216e18 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
 3216de4:	e0bfff17 	ldw	r2,-4(fp)
 3216de8:	10c00003 	ldbu	r3,0(r2)
 3216dec:	e0bffe17 	ldw	r2,-8(fp)
 3216df0:	10c00005 	stb	r3,0(r2)
 3216df4:	e0bffe17 	ldw	r2,-8(fp)
 3216df8:	10800044 	addi	r2,r2,1
 3216dfc:	e0bffe15 	stw	r2,-8(fp)
 3216e00:	e0bfff17 	ldw	r2,-4(fp)
 3216e04:	10800044 	addi	r2,r2,1
 3216e08:	e0bfff15 	stw	r2,-4(fp)
        len++;
 3216e0c:	e0bffd03 	ldbu	r2,-12(fp)
 3216e10:	10800044 	addi	r2,r2,1
 3216e14:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 3216e18:	e0bfff17 	ldw	r2,-4(fp)
 3216e1c:	10800003 	ldbu	r2,0(r2)
 3216e20:	10803fcc 	andi	r2,r2,255
 3216e24:	1004c03a 	cmpne	r2,r2,zero
 3216e28:	103fee1e 	bne	r2,zero,3216de4 <OS_StrCopy+0x1c>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
 3216e2c:	e0bffe17 	ldw	r2,-8(fp)
 3216e30:	10000005 	stb	zero,0(r2)
    return (len);
 3216e34:	e0bffd03 	ldbu	r2,-12(fp)
}
 3216e38:	e037883a 	mov	sp,fp
 3216e3c:	df000017 	ldw	fp,0(sp)
 3216e40:	dec00104 	addi	sp,sp,4
 3216e44:	f800283a 	ret

03216e48 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
 3216e48:	defffd04 	addi	sp,sp,-12
 3216e4c:	df000215 	stw	fp,8(sp)
 3216e50:	df000204 	addi	fp,sp,8
 3216e54:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
 3216e58:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
 3216e5c:	00000606 	br	3216e78 <OS_StrLen+0x30>
        psrc++;
 3216e60:	e0bfff17 	ldw	r2,-4(fp)
 3216e64:	10800044 	addi	r2,r2,1
 3216e68:	e0bfff15 	stw	r2,-4(fp)
        len++;
 3216e6c:	e0bffe03 	ldbu	r2,-8(fp)
 3216e70:	10800044 	addi	r2,r2,1
 3216e74:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 3216e78:	e0bfff17 	ldw	r2,-4(fp)
 3216e7c:	10800003 	ldbu	r2,0(r2)
 3216e80:	10803fcc 	andi	r2,r2,255
 3216e84:	1004c03a 	cmpne	r2,r2,zero
 3216e88:	103ff51e 	bne	r2,zero,3216e60 <OS_StrLen+0x18>
        psrc++;
        len++;
    }
    return (len);
 3216e8c:	e0bffe03 	ldbu	r2,-8(fp)
}
 3216e90:	e037883a 	mov	sp,fp
 3216e94:	df000017 	ldw	fp,0(sp)
 3216e98:	dec00104 	addi	sp,sp,4
 3216e9c:	f800283a 	ret

03216ea0 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
 3216ea0:	defffa04 	addi	sp,sp,-24
 3216ea4:	dfc00515 	stw	ra,20(sp)
 3216ea8:	df000415 	stw	fp,16(sp)
 3216eac:	df000404 	addi	fp,sp,16
 3216eb0:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3216eb4:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3216eb8:	0005303a 	rdctl	r2,status
 3216ebc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3216ec0:	e0fffd17 	ldw	r3,-12(fp)
 3216ec4:	00bfff84 	movi	r2,-2
 3216ec8:	1884703a 	and	r2,r3,r2
 3216ecc:	1001703a 	wrctl	status,r2
  
  return context;
 3216ed0:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
 3216ed4:	e0bffe15 	stw	r2,-8(fp)
        OSIdleCtr++;
 3216ed8:	d0a8a517 	ldw	r2,-23916(gp)
 3216edc:	10800044 	addi	r2,r2,1
 3216ee0:	d0a8a515 	stw	r2,-23916(gp)
 3216ee4:	e0bffe17 	ldw	r2,-8(fp)
 3216ee8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3216eec:	e0bffc17 	ldw	r2,-16(fp)
 3216ef0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
 3216ef4:	323b5d80 	call	323b5d8 <OSTaskIdleHook>
    }
 3216ef8:	003fef06 	br	3216eb8 <OS_TaskIdle+0x18>

03216efc <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
 3216efc:	defffa04 	addi	sp,sp,-24
 3216f00:	dfc00515 	stw	ra,20(sp)
 3216f04:	df000415 	stw	fp,16(sp)
 3216f08:	df000404 	addi	fp,sp,16
 3216f0c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3216f10:	e03ffe15 	stw	zero,-8(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 3216f14:	00000206 	br	3216f20 <OS_TaskStat+0x24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
 3216f18:	01003204 	movi	r4,200
 3216f1c:	321cf780 	call	321cf78 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 3216f20:	d0a8b603 	ldbu	r2,-23848(gp)
 3216f24:	10803fcc 	andi	r2,r2,255
 3216f28:	1005003a 	cmpeq	r2,r2,zero
 3216f2c:	103ffa1e 	bne	r2,zero,3216f18 <OS_TaskStat+0x1c>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
 3216f30:	d128aa17 	ldw	r4,-23896(gp)
 3216f34:	01401904 	movi	r5,100
 3216f38:	32044bc0 	call	32044bc <__udivsi3>
 3216f3c:	d0a8aa15 	stw	r2,-23896(gp)
    if (OSIdleCtrMax == 0L) {
 3216f40:	d0a8aa17 	ldw	r2,-23896(gp)
 3216f44:	1004c03a 	cmpne	r2,r2,zero
 3216f48:	1000031e 	bne	r2,zero,3216f58 <OS_TaskStat+0x5c>
        OSCPUUsage = 0;
 3216f4c:	d028ac05 	stb	zero,-23888(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
 3216f50:	01003fc4 	movi	r4,255
 3216f54:	321cb8c0 	call	321cb8c <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3216f58:	0005303a 	rdctl	r2,status
 3216f5c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3216f60:	e0fffd17 	ldw	r3,-12(fp)
 3216f64:	00bfff84 	movi	r2,-2
 3216f68:	1884703a 	and	r2,r3,r2
 3216f6c:	1001703a 	wrctl	status,r2
  
  return context;
 3216f70:	e0bffd17 	ldw	r2,-12(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
 3216f74:	e0bffe15 	stw	r2,-8(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
 3216f78:	d0a8a517 	ldw	r2,-23916(gp)
 3216f7c:	d0a8b715 	stw	r2,-23844(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
 3216f80:	d028a515 	stw	zero,-23916(gp)
 3216f84:	e0bffe17 	ldw	r2,-8(fp)
 3216f88:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3216f8c:	e0bffc17 	ldw	r2,-16(fp)
 3216f90:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
 3216f94:	d128b717 	ldw	r4,-23844(gp)
 3216f98:	d168aa17 	ldw	r5,-23896(gp)
 3216f9c:	32044bc0 	call	32044bc <__udivsi3>
 3216fa0:	1007883a 	mov	r3,r2
 3216fa4:	00801904 	movi	r2,100
 3216fa8:	10c5c83a 	sub	r2,r2,r3
 3216fac:	d0a8ac05 	stb	r2,-23888(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
 3216fb0:	323b55c0 	call	323b55c <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
 3216fb4:	3216fc40 	call	3216fc4 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
 3216fb8:	01001904 	movi	r4,100
 3216fbc:	321cf780 	call	321cf78 <OSTimeDly>
    }
 3216fc0:	003fe506 	br	3216f58 <OS_TaskStat+0x5c>

03216fc4 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
 3216fc4:	defffa04 	addi	sp,sp,-24
 3216fc8:	dfc00515 	stw	ra,20(sp)
 3216fcc:	df000415 	stw	fp,16(sp)
 3216fd0:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 3216fd4:	e03ffc05 	stb	zero,-16(fp)
 3216fd8:	00002406 	br	321706c <OS_TaskStatStkChk+0xa8>
        err = OSTaskStkChk(prio, &stk_data);
 3216fdc:	e13ffc03 	ldbu	r4,-16(fp)
 3216fe0:	e17ffe04 	addi	r5,fp,-8
 3216fe4:	321c9900 	call	321c990 <OSTaskStkChk>
 3216fe8:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
 3216fec:	e0bffc43 	ldbu	r2,-15(fp)
 3216ff0:	1004c03a 	cmpne	r2,r2,zero
 3216ff4:	10001a1e 	bne	r2,zero,3217060 <OS_TaskStatStkChk+0x9c>
            ptcb = OSTCBPrioTbl[prio];
 3216ff8:	e0bffc03 	ldbu	r2,-16(fp)
 3216ffc:	00c0c9b4 	movhi	r3,806
 3217000:	18f18004 	addi	r3,r3,-14848
 3217004:	1085883a 	add	r2,r2,r2
 3217008:	1085883a 	add	r2,r2,r2
 321700c:	10c5883a 	add	r2,r2,r3
 3217010:	10800017 	ldw	r2,0(r2)
 3217014:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
 3217018:	e0bffd17 	ldw	r2,-12(fp)
 321701c:	1005003a 	cmpeq	r2,r2,zero
 3217020:	10000f1e 	bne	r2,zero,3217060 <OS_TaskStatStkChk+0x9c>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
 3217024:	e0bffd17 	ldw	r2,-12(fp)
 3217028:	10800060 	cmpeqi	r2,r2,1
 321702c:	10000c1e 	bne	r2,zero,3217060 <OS_TaskStatStkChk+0x9c>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
 3217030:	e0bffd17 	ldw	r2,-12(fp)
 3217034:	10c00217 	ldw	r3,8(r2)
 3217038:	e0bffd17 	ldw	r2,-12(fp)
 321703c:	10800317 	ldw	r2,12(r2)
 3217040:	1085883a 	add	r2,r2,r2
 3217044:	1085883a 	add	r2,r2,r2
 3217048:	1887883a 	add	r3,r3,r2
 321704c:	e0bffd17 	ldw	r2,-12(fp)
 3217050:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
 3217054:	e0ffff17 	ldw	r3,-4(fp)
 3217058:	e0bffd17 	ldw	r2,-12(fp)
 321705c:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 3217060:	e0bffc03 	ldbu	r2,-16(fp)
 3217064:	10800044 	addi	r2,r2,1
 3217068:	e0bffc05 	stb	r2,-16(fp)
 321706c:	e0bffc03 	ldbu	r2,-16(fp)
 3217070:	10800570 	cmpltui	r2,r2,21
 3217074:	103fd91e 	bne	r2,zero,3216fdc <OS_TaskStatStkChk+0x18>
#endif
                }
            }
        }
    }
}
 3217078:	e037883a 	mov	sp,fp
 321707c:	dfc00117 	ldw	ra,4(sp)
 3217080:	df000017 	ldw	fp,0(sp)
 3217084:	dec00204 	addi	sp,sp,8
 3217088:	f800283a 	ret

0321708c <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
 321708c:	defff104 	addi	sp,sp,-60
 3217090:	dfc00e15 	stw	ra,56(sp)
 3217094:	df000d15 	stw	fp,52(sp)
 3217098:	df000d04 	addi	fp,sp,52
 321709c:	e17ffb15 	stw	r5,-20(fp)
 32170a0:	e1bffc15 	stw	r6,-16(fp)
 32170a4:	e0800417 	ldw	r2,16(fp)
 32170a8:	e13ffa05 	stb	r4,-24(fp)
 32170ac:	e1fffd0d 	sth	r7,-12(fp)
 32170b0:	e0bffe0d 	sth	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 32170b4:	e03ff815 	stw	zero,-32(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32170b8:	0005303a 	rdctl	r2,status
 32170bc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32170c0:	e0fff717 	ldw	r3,-36(fp)
 32170c4:	00bfff84 	movi	r2,-2
 32170c8:	1884703a 	and	r2,r3,r2
 32170cc:	1001703a 	wrctl	status,r2
  
  return context;
 32170d0:	e0bff717 	ldw	r2,-36(fp)
#endif



    OS_ENTER_CRITICAL();
 32170d4:	e0bff815 	stw	r2,-32(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
 32170d8:	d0a8ab17 	ldw	r2,-23892(gp)
 32170dc:	e0bff915 	stw	r2,-28(fp)
    if (ptcb != (OS_TCB *)0) {
 32170e0:	e0bff917 	ldw	r2,-28(fp)
 32170e4:	1005003a 	cmpeq	r2,r2,zero
 32170e8:	1000941e 	bne	r2,zero,321733c <OS_TCBInit+0x2b0>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
 32170ec:	e0bff917 	ldw	r2,-28(fp)
 32170f0:	10800517 	ldw	r2,20(r2)
 32170f4:	d0a8ab15 	stw	r2,-23892(gp)
 32170f8:	e0bff817 	ldw	r2,-32(fp)
 32170fc:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3217100:	e0bff617 	ldw	r2,-40(fp)
 3217104:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
 3217108:	e0fff917 	ldw	r3,-28(fp)
 321710c:	e0bffb17 	ldw	r2,-20(fp)
 3217110:	18800015 	stw	r2,0(r3)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
 3217114:	e0fff917 	ldw	r3,-28(fp)
 3217118:	e0bffa03 	ldbu	r2,-24(fp)
 321711c:	18800c85 	stb	r2,50(r3)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
 3217120:	e0bff917 	ldw	r2,-28(fp)
 3217124:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
 3217128:	e0bff917 	ldw	r2,-28(fp)
 321712c:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
 3217130:	e0bff917 	ldw	r2,-28(fp)
 3217134:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
 3217138:	e0fff917 	ldw	r3,-28(fp)
 321713c:	e0800317 	ldw	r2,12(fp)
 3217140:	18800115 	stw	r2,4(r3)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
 3217144:	e0fff917 	ldw	r3,-28(fp)
 3217148:	e0800217 	ldw	r2,8(fp)
 321714c:	18800315 	stw	r2,12(r3)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
 3217150:	e0fff917 	ldw	r3,-28(fp)
 3217154:	e0bffc17 	ldw	r2,-16(fp)
 3217158:	18800215 	stw	r2,8(r3)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
 321715c:	e0fff917 	ldw	r3,-28(fp)
 3217160:	e0bffe0b 	ldhu	r2,-8(fp)
 3217164:	1880040d 	sth	r2,16(r3)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
 3217168:	e0fff917 	ldw	r3,-28(fp)
 321716c:	e0bffd0b 	ldhu	r2,-12(fp)
 3217170:	1880048d 	sth	r2,18(r3)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
 3217174:	e0bff917 	ldw	r2,-28(fp)
 3217178:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
 321717c:	e0bffa03 	ldbu	r2,-24(fp)
 3217180:	1004d0fa 	srli	r2,r2,3
 3217184:	1007883a 	mov	r3,r2
 3217188:	e0bff917 	ldw	r2,-28(fp)
 321718c:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
 3217190:	e0bffa03 	ldbu	r2,-24(fp)
 3217194:	108001cc 	andi	r2,r2,7
 3217198:	1007883a 	mov	r3,r2
 321719c:	e0bff917 	ldw	r2,-28(fp)
 32171a0:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
 32171a4:	e0bff917 	ldw	r2,-28(fp)
 32171a8:	10800d03 	ldbu	r2,52(r2)
 32171ac:	10c03fcc 	andi	r3,r2,255
 32171b0:	00800044 	movi	r2,1
 32171b4:	10c4983a 	sll	r2,r2,r3
 32171b8:	1007883a 	mov	r3,r2
 32171bc:	e0bff917 	ldw	r2,-28(fp)
 32171c0:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
 32171c4:	e0bff917 	ldw	r2,-28(fp)
 32171c8:	10800cc3 	ldbu	r2,51(r2)
 32171cc:	10c03fcc 	andi	r3,r2,255
 32171d0:	00800044 	movi	r2,1
 32171d4:	10c4983a 	sll	r2,r2,r3
 32171d8:	1007883a 	mov	r3,r2
 32171dc:	e0bff917 	ldw	r2,-28(fp)
 32171e0:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
 32171e4:	e0bff917 	ldw	r2,-28(fp)
 32171e8:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
 32171ec:	e0bff917 	ldw	r2,-28(fp)
 32171f0:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
 32171f4:	e0bff917 	ldw	r2,-28(fp)
 32171f8:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
 32171fc:	e0bff917 	ldw	r2,-28(fp)
 3217200:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
 3217204:	e0bff917 	ldw	r2,-28(fp)
 3217208:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
 321720c:	e0bff917 	ldw	r2,-28(fp)
 3217210:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
 3217214:	e0bff917 	ldw	r2,-28(fp)
 3217218:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
 321721c:	e0bff917 	ldw	r2,-28(fp)
 3217220:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
 3217224:	e0bff917 	ldw	r2,-28(fp)
 3217228:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
 321722c:	e0fff917 	ldw	r3,-28(fp)
 3217230:	00800fc4 	movi	r2,63
 3217234:	18801305 	stb	r2,76(r3)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 3217238:	e0bff917 	ldw	r2,-28(fp)
 321723c:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
 3217240:	e13ff917 	ldw	r4,-28(fp)
 3217244:	323b5f40 	call	323b5f4 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
 3217248:	e13ff917 	ldw	r4,-28(fp)
 321724c:	323b5000 	call	323b500 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3217250:	0005303a 	rdctl	r2,status
 3217254:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3217258:	e0fff517 	ldw	r3,-44(fp)
 321725c:	00bfff84 	movi	r2,-2
 3217260:	1884703a 	and	r2,r3,r2
 3217264:	1001703a 	wrctl	status,r2
  
  return context;
 3217268:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
 321726c:	e0bff815 	stw	r2,-32(fp)
        OSTCBPrioTbl[prio] = ptcb;
 3217270:	e0bffa03 	ldbu	r2,-24(fp)
 3217274:	00c0c9b4 	movhi	r3,806
 3217278:	18f18004 	addi	r3,r3,-14848
 321727c:	1085883a 	add	r2,r2,r2
 3217280:	1085883a 	add	r2,r2,r2
 3217284:	10c7883a 	add	r3,r2,r3
 3217288:	e0bff917 	ldw	r2,-28(fp)
 321728c:	18800015 	stw	r2,0(r3)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
 3217290:	d0e8a717 	ldw	r3,-23908(gp)
 3217294:	e0bff917 	ldw	r2,-28(fp)
 3217298:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
 321729c:	e0bff917 	ldw	r2,-28(fp)
 32172a0:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
 32172a4:	d0a8a717 	ldw	r2,-23908(gp)
 32172a8:	1005003a 	cmpeq	r2,r2,zero
 32172ac:	1000031e 	bne	r2,zero,32172bc <OS_TCBInit+0x230>
            OSTCBList->OSTCBPrev = ptcb;
 32172b0:	d0e8a717 	ldw	r3,-23908(gp)
 32172b4:	e0bff917 	ldw	r2,-28(fp)
 32172b8:	18800615 	stw	r2,24(r3)
        }
        OSTCBList               = ptcb;
 32172bc:	e0bff917 	ldw	r2,-28(fp)
 32172c0:	d0a8a715 	stw	r2,-23908(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
 32172c4:	e0bff917 	ldw	r2,-28(fp)
 32172c8:	10c00d83 	ldbu	r3,54(r2)
 32172cc:	d0a8b003 	ldbu	r2,-23872(gp)
 32172d0:	1884b03a 	or	r2,r3,r2
 32172d4:	d0a8b005 	stb	r2,-23872(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 32172d8:	e0bff917 	ldw	r2,-28(fp)
 32172dc:	10800d03 	ldbu	r2,52(r2)
 32172e0:	11003fcc 	andi	r4,r2,255
 32172e4:	e0bff917 	ldw	r2,-28(fp)
 32172e8:	10800d03 	ldbu	r2,52(r2)
 32172ec:	10c03fcc 	andi	r3,r2,255
 32172f0:	d0a8b044 	addi	r2,gp,-23871
 32172f4:	1885883a 	add	r2,r3,r2
 32172f8:	10c00003 	ldbu	r3,0(r2)
 32172fc:	e0bff917 	ldw	r2,-28(fp)
 3217300:	10800d43 	ldbu	r2,53(r2)
 3217304:	1884b03a 	or	r2,r3,r2
 3217308:	1007883a 	mov	r3,r2
 321730c:	d0a8b044 	addi	r2,gp,-23871
 3217310:	2085883a 	add	r2,r4,r2
 3217314:	10c00005 	stb	r3,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
 3217318:	d0a8ac43 	ldbu	r2,-23887(gp)
 321731c:	10800044 	addi	r2,r2,1
 3217320:	d0a8ac45 	stb	r2,-23887(gp)
 3217324:	e0bff817 	ldw	r2,-32(fp)
 3217328:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321732c:	e0bff417 	ldw	r2,-48(fp)
 3217330:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 3217334:	e03fff15 	stw	zero,-4(fp)
 3217338:	00000606 	br	3217354 <OS_TCBInit+0x2c8>
 321733c:	e0bff817 	ldw	r2,-32(fp)
 3217340:	e0bff315 	stw	r2,-52(fp)
 3217344:	e0bff317 	ldw	r2,-52(fp)
 3217348:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
 321734c:	00801084 	movi	r2,66
 3217350:	e0bfff15 	stw	r2,-4(fp)
 3217354:	e0bfff17 	ldw	r2,-4(fp)
}
 3217358:	e037883a 	mov	sp,fp
 321735c:	dfc00117 	ldw	ra,4(sp)
 3217360:	df000017 	ldw	fp,0(sp)
 3217364:	dec00204 	addi	sp,sp,8
 3217368:	f800283a 	ret

0321736c <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
 321736c:	defffe04 	addi	sp,sp,-8
 3217370:	df000115 	stw	fp,4(sp)
 3217374:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
 3217378:	d0a00c04 	addi	r2,gp,-32720
 321737c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
 3217380:	d0a00d04 	addi	r2,gp,-32716
 3217384:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
 3217388:	d0a00e84 	addi	r2,gp,-32710
 321738c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
 3217390:	d0a00f04 	addi	r2,gp,-32708
 3217394:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
 3217398:	d0a00e04 	addi	r2,gp,-32712
 321739c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
 32173a0:	d0a00f84 	addi	r2,gp,-32706
 32173a4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
 32173a8:	d0a01004 	addi	r2,gp,-32704
 32173ac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
 32173b0:	d0a01084 	addi	r2,gp,-32702
 32173b4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
 32173b8:	d0a01104 	addi	r2,gp,-32700
 32173bc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
 32173c0:	d0a01184 	addi	r2,gp,-32698
 32173c4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
 32173c8:	d0a01204 	addi	r2,gp,-32696
 32173cc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
 32173d0:	d0a01284 	addi	r2,gp,-32694
 32173d4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
 32173d8:	d0a01304 	addi	r2,gp,-32692
 32173dc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
 32173e0:	d0a01384 	addi	r2,gp,-32690
 32173e4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
 32173e8:	d0a01404 	addi	r2,gp,-32688
 32173ec:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
 32173f0:	d0a01484 	addi	r2,gp,-32686
 32173f4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
 32173f8:	d0a01504 	addi	r2,gp,-32684
 32173fc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
 3217400:	d0a01584 	addi	r2,gp,-32682
 3217404:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
 3217408:	d0a01604 	addi	r2,gp,-32680
 321740c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
 3217410:	d0a01684 	addi	r2,gp,-32678
 3217414:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
 3217418:	d0a01704 	addi	r2,gp,-32676
 321741c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
 3217420:	d0a01784 	addi	r2,gp,-32674
 3217424:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
 3217428:	d0a01804 	addi	r2,gp,-32672
 321742c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
 3217430:	d0a01884 	addi	r2,gp,-32670
 3217434:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
 3217438:	d0a01904 	addi	r2,gp,-32668
 321743c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
 3217440:	d0a01984 	addi	r2,gp,-32666
 3217444:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
 3217448:	d0a01a04 	addi	r2,gp,-32664
 321744c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
 3217450:	d0a01a84 	addi	r2,gp,-32662
 3217454:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
 3217458:	d0a01b04 	addi	r2,gp,-32660
 321745c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
 3217460:	d0a01b84 	addi	r2,gp,-32658
 3217464:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
 3217468:	d0a01c04 	addi	r2,gp,-32656
 321746c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
 3217470:	d0a01c84 	addi	r2,gp,-32654
 3217474:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
 3217478:	d0a01d04 	addi	r2,gp,-32652
 321747c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
 3217480:	d0a01d84 	addi	r2,gp,-32650
 3217484:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
 3217488:	d0a01e04 	addi	r2,gp,-32648
 321748c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
 3217490:	d0a01e84 	addi	r2,gp,-32646
 3217494:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
 3217498:	d0a01f04 	addi	r2,gp,-32644
 321749c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
 32174a0:	d0a01f84 	addi	r2,gp,-32642
 32174a4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
 32174a8:	d0a02004 	addi	r2,gp,-32640
 32174ac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
 32174b0:	d0a02084 	addi	r2,gp,-32638
 32174b4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
 32174b8:	d0a02104 	addi	r2,gp,-32636
 32174bc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
 32174c0:	d0a02184 	addi	r2,gp,-32634
 32174c4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
 32174c8:	d0a02204 	addi	r2,gp,-32632
 32174cc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
 32174d0:	d0a02284 	addi	r2,gp,-32630
 32174d4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
    ptemp = (void *)&OSTmrWheelTblSize;
#endif

    ptemp = (void *)&OSVersionNbr;
 32174d8:	d0a02304 	addi	r2,gp,-32628
 32174dc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
 32174e0:	d0a02804 	addi	r2,gp,-32608
 32174e4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
 32174e8:	e037883a 	mov	sp,fp
 32174ec:	df000017 	ldw	fp,0(sp)
 32174f0:	dec00104 	addi	sp,sp,4
 32174f4:	f800283a 	ret

032174f8 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
 32174f8:	defff104 	addi	sp,sp,-60
 32174fc:	df000e15 	stw	fp,56(sp)
 3217500:	df000e04 	addi	fp,sp,56
 3217504:	e13ffa15 	stw	r4,-24(fp)
 3217508:	e1fffd15 	stw	r7,-12(fp)
 321750c:	e17ffb0d 	sth	r5,-20(fp)
 3217510:	e1bffc05 	stb	r6,-16(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 3217514:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 3217518:	e0bffd17 	ldw	r2,-12(fp)
 321751c:	1004c03a 	cmpne	r2,r2,zero
 3217520:	1000021e 	bne	r2,zero,321752c <OSFlagAccept+0x34>
        return ((OS_FLAGS)0);
 3217524:	e03fff15 	stw	zero,-4(fp)
 3217528:	0000bb06 	br	3217818 <OSFlagAccept+0x320>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 321752c:	e0bffa17 	ldw	r2,-24(fp)
 3217530:	1004c03a 	cmpne	r2,r2,zero
 3217534:	1000051e 	bne	r2,zero,321754c <OSFlagAccept+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 3217538:	e0fffd17 	ldw	r3,-12(fp)
 321753c:	00801b84 	movi	r2,110
 3217540:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 3217544:	e03fff15 	stw	zero,-4(fp)
 3217548:	0000b306 	br	3217818 <OSFlagAccept+0x320>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 321754c:	e0bffa17 	ldw	r2,-24(fp)
 3217550:	10800003 	ldbu	r2,0(r2)
 3217554:	10803fcc 	andi	r2,r2,255
 3217558:	10800160 	cmpeqi	r2,r2,5
 321755c:	1000051e 	bne	r2,zero,3217574 <OSFlagAccept+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 3217560:	e0fffd17 	ldw	r3,-12(fp)
 3217564:	00800044 	movi	r2,1
 3217568:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 321756c:	e03fff15 	stw	zero,-4(fp)
 3217570:	0000a906 	br	3217818 <OSFlagAccept+0x320>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 3217574:	e0fffc03 	ldbu	r3,-16(fp)
 3217578:	00bfe004 	movi	r2,-128
 321757c:	1884703a 	and	r2,r3,r2
 3217580:	e0bff945 	stb	r2,-27(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
 3217584:	e0bff943 	ldbu	r2,-27(fp)
 3217588:	1005003a 	cmpeq	r2,r2,zero
 321758c:	1000061e 	bne	r2,zero,32175a8 <OSFlagAccept+0xb0>
        wait_type &= ~OS_FLAG_CONSUME;
 3217590:	e0bffc03 	ldbu	r2,-16(fp)
 3217594:	10801fcc 	andi	r2,r2,127
 3217598:	e0bffc05 	stb	r2,-16(fp)
        consume    = OS_TRUE;
 321759c:	00800044 	movi	r2,1
 32175a0:	e0bff905 	stb	r2,-28(fp)
 32175a4:	00000106 	br	32175ac <OSFlagAccept+0xb4>
    } else {
        consume    = OS_FALSE;
 32175a8:	e03ff905 	stb	zero,-28(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
 32175ac:	e0bffd17 	ldw	r2,-12(fp)
 32175b0:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32175b4:	0005303a 	rdctl	r2,status
 32175b8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32175bc:	e0fff717 	ldw	r3,-36(fp)
 32175c0:	00bfff84 	movi	r2,-2
 32175c4:	1884703a 	and	r2,r3,r2
 32175c8:	1001703a 	wrctl	status,r2
  
  return context;
 32175cc:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 32175d0:	e0bff815 	stw	r2,-32(fp)
    switch (wait_type) {
 32175d4:	e0bffc03 	ldbu	r2,-16(fp)
 32175d8:	e0bffe15 	stw	r2,-8(fp)
 32175dc:	e0fffe17 	ldw	r3,-8(fp)
 32175e0:	18800060 	cmpeqi	r2,r3,1
 32175e4:	1000651e 	bne	r2,zero,321777c <OSFlagAccept+0x284>
 32175e8:	e0fffe17 	ldw	r3,-8(fp)
 32175ec:	18800088 	cmpgei	r2,r3,2
 32175f0:	1000041e 	bne	r2,zero,3217604 <OSFlagAccept+0x10c>
 32175f4:	e0fffe17 	ldw	r3,-8(fp)
 32175f8:	1805003a 	cmpeq	r2,r3,zero
 32175fc:	1000421e 	bne	r2,zero,3217708 <OSFlagAccept+0x210>
 3217600:	00007b06 	br	32177f0 <OSFlagAccept+0x2f8>
 3217604:	e0fffe17 	ldw	r3,-8(fp)
 3217608:	188000a0 	cmpeqi	r2,r3,2
 321760c:	1000041e 	bne	r2,zero,3217620 <OSFlagAccept+0x128>
 3217610:	e0fffe17 	ldw	r3,-8(fp)
 3217614:	188000e0 	cmpeqi	r2,r3,3
 3217618:	10001e1e 	bne	r2,zero,3217694 <OSFlagAccept+0x19c>
 321761c:	00007406 	br	32177f0 <OSFlagAccept+0x2f8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 3217620:	e0bffa17 	ldw	r2,-24(fp)
 3217624:	10c0020b 	ldhu	r3,8(r2)
 3217628:	e0bffb0b 	ldhu	r2,-20(fp)
 321762c:	1884703a 	and	r2,r3,r2
 3217630:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 3217634:	e0fff98b 	ldhu	r3,-26(fp)
 3217638:	e0bffb0b 	ldhu	r2,-20(fp)
 321763c:	18800d1e 	bne	r3,r2,3217674 <OSFlagAccept+0x17c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 3217640:	e0bff903 	ldbu	r2,-28(fp)
 3217644:	10800058 	cmpnei	r2,r2,1
 3217648:	10000d1e 	bne	r2,zero,3217680 <OSFlagAccept+0x188>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 321764c:	e0bffa17 	ldw	r2,-24(fp)
 3217650:	1080020b 	ldhu	r2,8(r2)
 3217654:	1007883a 	mov	r3,r2
 3217658:	e0bff98b 	ldhu	r2,-26(fp)
 321765c:	0084303a 	nor	r2,zero,r2
 3217660:	1884703a 	and	r2,r3,r2
 3217664:	1007883a 	mov	r3,r2
 3217668:	e0bffa17 	ldw	r2,-24(fp)
 321766c:	10c0020d 	sth	r3,8(r2)
 3217670:	00000306 	br	3217680 <OSFlagAccept+0x188>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 3217674:	e0fffd17 	ldw	r3,-12(fp)
 3217678:	00801c04 	movi	r2,112
 321767c:	18800005 	stb	r2,0(r3)
 3217680:	e0bff817 	ldw	r2,-32(fp)
 3217684:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3217688:	e0bff617 	ldw	r2,-40(fp)
 321768c:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 3217690:	00005f06 	br	3217810 <OSFlagAccept+0x318>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 3217694:	e0bffa17 	ldw	r2,-24(fp)
 3217698:	10c0020b 	ldhu	r3,8(r2)
 321769c:	e0bffb0b 	ldhu	r2,-20(fp)
 32176a0:	1884703a 	and	r2,r3,r2
 32176a4:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 32176a8:	e0bff98b 	ldhu	r2,-26(fp)
 32176ac:	1005003a 	cmpeq	r2,r2,zero
 32176b0:	10000d1e 	bne	r2,zero,32176e8 <OSFlagAccept+0x1f0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 32176b4:	e0bff903 	ldbu	r2,-28(fp)
 32176b8:	10800058 	cmpnei	r2,r2,1
 32176bc:	10000d1e 	bne	r2,zero,32176f4 <OSFlagAccept+0x1fc>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 32176c0:	e0bffa17 	ldw	r2,-24(fp)
 32176c4:	1080020b 	ldhu	r2,8(r2)
 32176c8:	1007883a 	mov	r3,r2
 32176cc:	e0bff98b 	ldhu	r2,-26(fp)
 32176d0:	0084303a 	nor	r2,zero,r2
 32176d4:	1884703a 	and	r2,r3,r2
 32176d8:	1007883a 	mov	r3,r2
 32176dc:	e0bffa17 	ldw	r2,-24(fp)
 32176e0:	10c0020d 	sth	r3,8(r2)
 32176e4:	00000306 	br	32176f4 <OSFlagAccept+0x1fc>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 32176e8:	e0fffd17 	ldw	r3,-12(fp)
 32176ec:	00801c04 	movi	r2,112
 32176f0:	18800005 	stb	r2,0(r3)
 32176f4:	e0bff817 	ldw	r2,-32(fp)
 32176f8:	e0bff515 	stw	r2,-44(fp)
 32176fc:	e0bff517 	ldw	r2,-44(fp)
 3217700:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 3217704:	00004206 	br	3217810 <OSFlagAccept+0x318>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 3217708:	e0bffa17 	ldw	r2,-24(fp)
 321770c:	1080020b 	ldhu	r2,8(r2)
 3217710:	0084303a 	nor	r2,zero,r2
 3217714:	1007883a 	mov	r3,r2
 3217718:	e0bffb0b 	ldhu	r2,-20(fp)
 321771c:	1884703a 	and	r2,r3,r2
 3217720:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 3217724:	e0fff98b 	ldhu	r3,-26(fp)
 3217728:	e0bffb0b 	ldhu	r2,-20(fp)
 321772c:	18800b1e 	bne	r3,r2,321775c <OSFlagAccept+0x264>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 3217730:	e0bff903 	ldbu	r2,-28(fp)
 3217734:	10800058 	cmpnei	r2,r2,1
 3217738:	10000b1e 	bne	r2,zero,3217768 <OSFlagAccept+0x270>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 321773c:	e0bffa17 	ldw	r2,-24(fp)
 3217740:	10c0020b 	ldhu	r3,8(r2)
 3217744:	e0bff98b 	ldhu	r2,-26(fp)
 3217748:	1884b03a 	or	r2,r3,r2
 321774c:	1007883a 	mov	r3,r2
 3217750:	e0bffa17 	ldw	r2,-24(fp)
 3217754:	10c0020d 	sth	r3,8(r2)
 3217758:	00000306 	br	3217768 <OSFlagAccept+0x270>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 321775c:	e0fffd17 	ldw	r3,-12(fp)
 3217760:	00801c04 	movi	r2,112
 3217764:	18800005 	stb	r2,0(r3)
 3217768:	e0bff817 	ldw	r2,-32(fp)
 321776c:	e0bff415 	stw	r2,-48(fp)
 3217770:	e0bff417 	ldw	r2,-48(fp)
 3217774:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 3217778:	00002506 	br	3217810 <OSFlagAccept+0x318>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 321777c:	e0bffa17 	ldw	r2,-24(fp)
 3217780:	1080020b 	ldhu	r2,8(r2)
 3217784:	0084303a 	nor	r2,zero,r2
 3217788:	1007883a 	mov	r3,r2
 321778c:	e0bffb0b 	ldhu	r2,-20(fp)
 3217790:	1884703a 	and	r2,r3,r2
 3217794:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 3217798:	e0bff98b 	ldhu	r2,-26(fp)
 321779c:	1005003a 	cmpeq	r2,r2,zero
 32177a0:	10000b1e 	bne	r2,zero,32177d0 <OSFlagAccept+0x2d8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 32177a4:	e0bff903 	ldbu	r2,-28(fp)
 32177a8:	10800058 	cmpnei	r2,r2,1
 32177ac:	10000b1e 	bne	r2,zero,32177dc <OSFlagAccept+0x2e4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 32177b0:	e0bffa17 	ldw	r2,-24(fp)
 32177b4:	10c0020b 	ldhu	r3,8(r2)
 32177b8:	e0bff98b 	ldhu	r2,-26(fp)
 32177bc:	1884b03a 	or	r2,r3,r2
 32177c0:	1007883a 	mov	r3,r2
 32177c4:	e0bffa17 	ldw	r2,-24(fp)
 32177c8:	10c0020d 	sth	r3,8(r2)
 32177cc:	00000306 	br	32177dc <OSFlagAccept+0x2e4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 32177d0:	e0fffd17 	ldw	r3,-12(fp)
 32177d4:	00801c04 	movi	r2,112
 32177d8:	18800005 	stb	r2,0(r3)
 32177dc:	e0bff817 	ldw	r2,-32(fp)
 32177e0:	e0bff315 	stw	r2,-52(fp)
 32177e4:	e0bff317 	ldw	r2,-52(fp)
 32177e8:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 32177ec:	00000806 	br	3217810 <OSFlagAccept+0x318>
 32177f0:	e0bff817 	ldw	r2,-32(fp)
 32177f4:	e0bff215 	stw	r2,-56(fp)
 32177f8:	e0bff217 	ldw	r2,-56(fp)
 32177fc:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 3217800:	e03ff98d 	sth	zero,-26(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
 3217804:	e0fffd17 	ldw	r3,-12(fp)
 3217808:	00801bc4 	movi	r2,111
 321780c:	18800005 	stb	r2,0(r3)
             break;
    }
    return (flags_rdy);
 3217810:	e0bff98b 	ldhu	r2,-26(fp)
 3217814:	e0bfff15 	stw	r2,-4(fp)
 3217818:	e0bfff17 	ldw	r2,-4(fp)
}
 321781c:	e037883a 	mov	sp,fp
 3217820:	df000017 	ldw	fp,0(sp)
 3217824:	dec00104 	addi	sp,sp,4
 3217828:	f800283a 	ret

0321782c <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
 321782c:	defff704 	addi	sp,sp,-36
 3217830:	df000815 	stw	fp,32(sp)
 3217834:	df000804 	addi	fp,sp,32
 3217838:	e17ffe15 	stw	r5,-8(fp)
 321783c:	e13ffd0d 	sth	r4,-12(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
 3217840:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
 3217844:	e0bffe17 	ldw	r2,-8(fp)
 3217848:	1004c03a 	cmpne	r2,r2,zero
 321784c:	1000021e 	bne	r2,zero,3217858 <OSFlagCreate+0x2c>
        return ((OS_FLAG_GRP *)0);
 3217850:	e03fff15 	stw	zero,-4(fp)
 3217854:	00003f06 	br	3217954 <OSFlagCreate+0x128>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
 3217858:	0080c974 	movhi	r2,805
 321785c:	10922904 	addi	r2,r2,18596
 3217860:	10800003 	ldbu	r2,0(r2)
 3217864:	10803fcc 	andi	r2,r2,255
 3217868:	1005003a 	cmpeq	r2,r2,zero
 321786c:	1000051e 	bne	r2,zero,3217884 <OSFlagCreate+0x58>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
 3217870:	e0fffe17 	ldw	r3,-8(fp)
 3217874:	00800404 	movi	r2,16
 3217878:	18800005 	stb	r2,0(r3)
        return ((OS_FLAG_GRP *)0);
 321787c:	e03fff15 	stw	zero,-4(fp)
 3217880:	00003406 	br	3217954 <OSFlagCreate+0x128>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3217884:	0005303a 	rdctl	r2,status
 3217888:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321788c:	e0fffa17 	ldw	r3,-24(fp)
 3217890:	00bfff84 	movi	r2,-2
 3217894:	1884703a 	and	r2,r3,r2
 3217898:	1001703a 	wrctl	status,r2
  
  return context;
 321789c:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 32178a0:	e0bffb15 	stw	r2,-20(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
 32178a4:	0080c974 	movhi	r2,805
 32178a8:	10922c04 	addi	r2,r2,18608
 32178ac:	10800017 	ldw	r2,0(r2)
 32178b0:	e0bffc15 	stw	r2,-16(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
 32178b4:	e0bffc17 	ldw	r2,-16(fp)
 32178b8:	1005003a 	cmpeq	r2,r2,zero
 32178bc:	10001c1e 	bne	r2,zero,3217930 <OSFlagCreate+0x104>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
 32178c0:	0080c974 	movhi	r2,805
 32178c4:	10922c04 	addi	r2,r2,18608
 32178c8:	10800017 	ldw	r2,0(r2)
 32178cc:	10800117 	ldw	r2,4(r2)
 32178d0:	1007883a 	mov	r3,r2
 32178d4:	0080c974 	movhi	r2,805
 32178d8:	10922c04 	addi	r2,r2,18608
 32178dc:	10c00015 	stw	r3,0(r2)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
 32178e0:	e0fffc17 	ldw	r3,-16(fp)
 32178e4:	00800144 	movi	r2,5
 32178e8:	18800005 	stb	r2,0(r3)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
 32178ec:	e0fffc17 	ldw	r3,-16(fp)
 32178f0:	e0bffd0b 	ldhu	r2,-12(fp)
 32178f4:	1880020d 	sth	r2,8(r3)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
 32178f8:	e0bffc17 	ldw	r2,-16(fp)
 32178fc:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
 3217900:	e0fffc17 	ldw	r3,-16(fp)
 3217904:	00800fc4 	movi	r2,63
 3217908:	18800285 	stb	r2,10(r3)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 321790c:	e0bffc17 	ldw	r2,-16(fp)
 3217910:	100002c5 	stb	zero,11(r2)
 3217914:	e0bffb17 	ldw	r2,-20(fp)
 3217918:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321791c:	e0bff917 	ldw	r2,-28(fp)
 3217920:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
 3217924:	e0bffe17 	ldw	r2,-8(fp)
 3217928:	10000005 	stb	zero,0(r2)
 321792c:	00000706 	br	321794c <OSFlagCreate+0x120>
 3217930:	e0bffb17 	ldw	r2,-20(fp)
 3217934:	e0bff815 	stw	r2,-32(fp)
 3217938:	e0bff817 	ldw	r2,-32(fp)
 321793c:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
 3217940:	e0fffe17 	ldw	r3,-8(fp)
 3217944:	00801c84 	movi	r2,114
 3217948:	18800005 	stb	r2,0(r3)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
 321794c:	e0bffc17 	ldw	r2,-16(fp)
 3217950:	e0bfff15 	stw	r2,-4(fp)
 3217954:	e0bfff17 	ldw	r2,-4(fp)
}
 3217958:	e037883a 	mov	sp,fp
 321795c:	df000017 	ldw	fp,0(sp)
 3217960:	dec00104 	addi	sp,sp,4
 3217964:	f800283a 	ret

03217968 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
 3217968:	defff004 	addi	sp,sp,-64
 321796c:	dfc00f15 	stw	ra,60(sp)
 3217970:	df000e15 	stw	fp,56(sp)
 3217974:	df000e04 	addi	fp,sp,56
 3217978:	e13ffb15 	stw	r4,-20(fp)
 321797c:	e1bffd15 	stw	r6,-12(fp)
 3217980:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 3217984:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 3217988:	e0bffd17 	ldw	r2,-12(fp)
 321798c:	1004c03a 	cmpne	r2,r2,zero
 3217990:	1000031e 	bne	r2,zero,32179a0 <OSFlagDel+0x38>
        return (pgrp);
 3217994:	e0bffb17 	ldw	r2,-20(fp)
 3217998:	e0bfff15 	stw	r2,-4(fp)
 321799c:	00009606 	br	3217bf8 <OSFlagDel+0x290>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 32179a0:	e0bffb17 	ldw	r2,-20(fp)
 32179a4:	1004c03a 	cmpne	r2,r2,zero
 32179a8:	1000061e 	bne	r2,zero,32179c4 <OSFlagDel+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 32179ac:	e0fffd17 	ldw	r3,-12(fp)
 32179b0:	00801b84 	movi	r2,110
 32179b4:	18800005 	stb	r2,0(r3)
        return (pgrp);
 32179b8:	e0fffb17 	ldw	r3,-20(fp)
 32179bc:	e0ffff15 	stw	r3,-4(fp)
 32179c0:	00008d06 	br	3217bf8 <OSFlagDel+0x290>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 32179c4:	0080c974 	movhi	r2,805
 32179c8:	10922904 	addi	r2,r2,18596
 32179cc:	10800003 	ldbu	r2,0(r2)
 32179d0:	10803fcc 	andi	r2,r2,255
 32179d4:	1005003a 	cmpeq	r2,r2,zero
 32179d8:	1000061e 	bne	r2,zero,32179f4 <OSFlagDel+0x8c>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 32179dc:	e0fffd17 	ldw	r3,-12(fp)
 32179e0:	008003c4 	movi	r2,15
 32179e4:	18800005 	stb	r2,0(r3)
        return (pgrp);
 32179e8:	e0bffb17 	ldw	r2,-20(fp)
 32179ec:	e0bfff15 	stw	r2,-4(fp)
 32179f0:	00008106 	br	3217bf8 <OSFlagDel+0x290>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
 32179f4:	e0bffb17 	ldw	r2,-20(fp)
 32179f8:	10800003 	ldbu	r2,0(r2)
 32179fc:	10803fcc 	andi	r2,r2,255
 3217a00:	10800160 	cmpeqi	r2,r2,5
 3217a04:	1000061e 	bne	r2,zero,3217a20 <OSFlagDel+0xb8>
        *perr = OS_ERR_EVENT_TYPE;
 3217a08:	e0fffd17 	ldw	r3,-12(fp)
 3217a0c:	00800044 	movi	r2,1
 3217a10:	18800005 	stb	r2,0(r3)
        return (pgrp);
 3217a14:	e0fffb17 	ldw	r3,-20(fp)
 3217a18:	e0ffff15 	stw	r3,-4(fp)
 3217a1c:	00007606 	br	3217bf8 <OSFlagDel+0x290>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3217a20:	0005303a 	rdctl	r2,status
 3217a24:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3217a28:	e0fff617 	ldw	r3,-40(fp)
 3217a2c:	00bfff84 	movi	r2,-2
 3217a30:	1884703a 	and	r2,r3,r2
 3217a34:	1001703a 	wrctl	status,r2
  
  return context;
 3217a38:	e0bff617 	ldw	r2,-40(fp)
    }
    OS_ENTER_CRITICAL();
 3217a3c:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
 3217a40:	e0bffb17 	ldw	r2,-20(fp)
 3217a44:	10800117 	ldw	r2,4(r2)
 3217a48:	1005003a 	cmpeq	r2,r2,zero
 3217a4c:	1000031e 	bne	r2,zero,3217a5c <OSFlagDel+0xf4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 3217a50:	00800044 	movi	r2,1
 3217a54:	e0bffa05 	stb	r2,-24(fp)
 3217a58:	00000106 	br	3217a60 <OSFlagDel+0xf8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 3217a5c:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 3217a60:	e0bffc03 	ldbu	r2,-16(fp)
 3217a64:	e0bffe15 	stw	r2,-8(fp)
 3217a68:	e0fffe17 	ldw	r3,-8(fp)
 3217a6c:	1805003a 	cmpeq	r2,r3,zero
 3217a70:	1000041e 	bne	r2,zero,3217a84 <OSFlagDel+0x11c>
 3217a74:	e0fffe17 	ldw	r3,-8(fp)
 3217a78:	18800060 	cmpeqi	r2,r3,1
 3217a7c:	1000281e 	bne	r2,zero,3217b20 <OSFlagDel+0x1b8>
 3217a80:	00005206 	br	3217bcc <OSFlagDel+0x264>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
 3217a84:	e0bffa03 	ldbu	r2,-24(fp)
 3217a88:	1004c03a 	cmpne	r2,r2,zero
 3217a8c:	10001a1e 	bne	r2,zero,3217af8 <OSFlagDel+0x190>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
 3217a90:	e0fffb17 	ldw	r3,-20(fp)
 3217a94:	00800fc4 	movi	r2,63
 3217a98:	18800285 	stb	r2,10(r3)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 3217a9c:	e0bffb17 	ldw	r2,-20(fp)
 3217aa0:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 3217aa4:	e0bffb17 	ldw	r2,-20(fp)
 3217aa8:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
 3217aac:	0080c974 	movhi	r2,805
 3217ab0:	10922c04 	addi	r2,r2,18608
 3217ab4:	10c00017 	ldw	r3,0(r2)
 3217ab8:	e0bffb17 	ldw	r2,-20(fp)
 3217abc:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
 3217ac0:	e0bffb17 	ldw	r2,-20(fp)
 3217ac4:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
 3217ac8:	00c0c974 	movhi	r3,805
 3217acc:	18d22c04 	addi	r3,r3,18608
 3217ad0:	e0bffb17 	ldw	r2,-20(fp)
 3217ad4:	18800015 	stw	r2,0(r3)
 3217ad8:	e0bff717 	ldw	r2,-36(fp)
 3217adc:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3217ae0:	e0bff517 	ldw	r2,-44(fp)
 3217ae4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
 3217ae8:	e0bffd17 	ldw	r2,-12(fp)
 3217aec:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
 3217af0:	e03ff815 	stw	zero,-32(fp)
 3217af4:	00003e06 	br	3217bf0 <OSFlagDel+0x288>
 3217af8:	e0bff717 	ldw	r2,-36(fp)
 3217afc:	e0bff415 	stw	r2,-48(fp)
 3217b00:	e0bff417 	ldw	r2,-48(fp)
 3217b04:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
 3217b08:	e0fffd17 	ldw	r3,-12(fp)
 3217b0c:	00801244 	movi	r2,73
 3217b10:	18800005 	stb	r2,0(r3)
                 pgrp_return          = pgrp;
 3217b14:	e0bffb17 	ldw	r2,-20(fp)
 3217b18:	e0bff815 	stw	r2,-32(fp)
             }
             break;
 3217b1c:	00003406 	br	3217bf0 <OSFlagDel+0x288>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 3217b20:	e0bffb17 	ldw	r2,-20(fp)
 3217b24:	10800117 	ldw	r2,4(r2)
 3217b28:	e0bff915 	stw	r2,-28(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 3217b2c:	00000606 	br	3217b48 <OSFlagDel+0x1e0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
 3217b30:	e13ff917 	ldw	r4,-28(fp)
 3217b34:	000b883a 	mov	r5,zero
 3217b38:	3218c780 	call	3218c78 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 3217b3c:	e0bff917 	ldw	r2,-28(fp)
 3217b40:	10800017 	ldw	r2,0(r2)
 3217b44:	e0bff915 	stw	r2,-28(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 3217b48:	e0bff917 	ldw	r2,-28(fp)
 3217b4c:	1004c03a 	cmpne	r2,r2,zero
 3217b50:	103ff71e 	bne	r2,zero,3217b30 <OSFlagDel+0x1c8>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
 3217b54:	e0fffb17 	ldw	r3,-20(fp)
 3217b58:	00800fc4 	movi	r2,63
 3217b5c:	18800285 	stb	r2,10(r3)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 3217b60:	e0bffb17 	ldw	r2,-20(fp)
 3217b64:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 3217b68:	e0bffb17 	ldw	r2,-20(fp)
 3217b6c:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
 3217b70:	0080c974 	movhi	r2,805
 3217b74:	10922c04 	addi	r2,r2,18608
 3217b78:	10c00017 	ldw	r3,0(r2)
 3217b7c:	e0bffb17 	ldw	r2,-20(fp)
 3217b80:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
 3217b84:	e0bffb17 	ldw	r2,-20(fp)
 3217b88:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
 3217b8c:	00c0c974 	movhi	r3,805
 3217b90:	18d22c04 	addi	r3,r3,18608
 3217b94:	e0bffb17 	ldw	r2,-20(fp)
 3217b98:	18800015 	stw	r2,0(r3)
 3217b9c:	e0bff717 	ldw	r2,-36(fp)
 3217ba0:	e0bff315 	stw	r2,-52(fp)
 3217ba4:	e0bff317 	ldw	r2,-52(fp)
 3217ba8:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 3217bac:	e0bffa03 	ldbu	r2,-24(fp)
 3217bb0:	10800058 	cmpnei	r2,r2,1
 3217bb4:	1000011e 	bne	r2,zero,3217bbc <OSFlagDel+0x254>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 3217bb8:	3216c840 	call	3216c84 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
 3217bbc:	e0bffd17 	ldw	r2,-12(fp)
 3217bc0:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
 3217bc4:	e03ff815 	stw	zero,-32(fp)
             break;
 3217bc8:	00000906 	br	3217bf0 <OSFlagDel+0x288>
 3217bcc:	e0bff717 	ldw	r2,-36(fp)
 3217bd0:	e0bff215 	stw	r2,-56(fp)
 3217bd4:	e0bff217 	ldw	r2,-56(fp)
 3217bd8:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
 3217bdc:	e0fffd17 	ldw	r3,-12(fp)
 3217be0:	008001c4 	movi	r2,7
 3217be4:	18800005 	stb	r2,0(r3)
             pgrp_return          = pgrp;
 3217be8:	e0bffb17 	ldw	r2,-20(fp)
 3217bec:	e0bff815 	stw	r2,-32(fp)
             break;
    }
    return (pgrp_return);
 3217bf0:	e0bff817 	ldw	r2,-32(fp)
 3217bf4:	e0bfff15 	stw	r2,-4(fp)
 3217bf8:	e0bfff17 	ldw	r2,-4(fp)
}
 3217bfc:	e037883a 	mov	sp,fp
 3217c00:	dfc00117 	ldw	ra,4(sp)
 3217c04:	df000017 	ldw	fp,0(sp)
 3217c08:	dec00204 	addi	sp,sp,8
 3217c0c:	f800283a 	ret

03217c10 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 3217c10:	defff504 	addi	sp,sp,-44
 3217c14:	dfc00a15 	stw	ra,40(sp)
 3217c18:	df000915 	stw	fp,36(sp)
 3217c1c:	df000904 	addi	fp,sp,36
 3217c20:	e13ffc15 	stw	r4,-16(fp)
 3217c24:	e17ffd15 	stw	r5,-12(fp)
 3217c28:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3217c2c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 3217c30:	e0bffe17 	ldw	r2,-8(fp)
 3217c34:	1004c03a 	cmpne	r2,r2,zero
 3217c38:	1000021e 	bne	r2,zero,3217c44 <OSFlagNameGet+0x34>
        return (0);
 3217c3c:	e03fff15 	stw	zero,-4(fp)
 3217c40:	00003e06 	br	3217d3c <OSFlagNameGet+0x12c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 3217c44:	e0bffc17 	ldw	r2,-16(fp)
 3217c48:	1004c03a 	cmpne	r2,r2,zero
 3217c4c:	1000051e 	bne	r2,zero,3217c64 <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 3217c50:	e0fffe17 	ldw	r3,-8(fp)
 3217c54:	00801b84 	movi	r2,110
 3217c58:	18800005 	stb	r2,0(r3)
        return (0);
 3217c5c:	e03fff15 	stw	zero,-4(fp)
 3217c60:	00003606 	br	3217d3c <OSFlagNameGet+0x12c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 3217c64:	e0bffd17 	ldw	r2,-12(fp)
 3217c68:	1004c03a 	cmpne	r2,r2,zero
 3217c6c:	1000051e 	bne	r2,zero,3217c84 <OSFlagNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 3217c70:	e0fffe17 	ldw	r3,-8(fp)
 3217c74:	00800304 	movi	r2,12
 3217c78:	18800005 	stb	r2,0(r3)
        return (0);
 3217c7c:	e03fff15 	stw	zero,-4(fp)
 3217c80:	00002e06 	br	3217d3c <OSFlagNameGet+0x12c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 3217c84:	0080c974 	movhi	r2,805
 3217c88:	10922904 	addi	r2,r2,18596
 3217c8c:	10800003 	ldbu	r2,0(r2)
 3217c90:	10803fcc 	andi	r2,r2,255
 3217c94:	1005003a 	cmpeq	r2,r2,zero
 3217c98:	1000051e 	bne	r2,zero,3217cb0 <OSFlagNameGet+0xa0>
        *perr = OS_ERR_NAME_GET_ISR;
 3217c9c:	e0fffe17 	ldw	r3,-8(fp)
 3217ca0:	00800444 	movi	r2,17
 3217ca4:	18800005 	stb	r2,0(r3)
        return (0);
 3217ca8:	e03fff15 	stw	zero,-4(fp)
 3217cac:	00002306 	br	3217d3c <OSFlagNameGet+0x12c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3217cb0:	0005303a 	rdctl	r2,status
 3217cb4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3217cb8:	e0fff917 	ldw	r3,-28(fp)
 3217cbc:	00bfff84 	movi	r2,-2
 3217cc0:	1884703a 	and	r2,r3,r2
 3217cc4:	1001703a 	wrctl	status,r2
  
  return context;
 3217cc8:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 3217ccc:	e0bffa15 	stw	r2,-24(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 3217cd0:	e0bffc17 	ldw	r2,-16(fp)
 3217cd4:	10800003 	ldbu	r2,0(r2)
 3217cd8:	10803fcc 	andi	r2,r2,255
 3217cdc:	10800160 	cmpeqi	r2,r2,5
 3217ce0:	1000091e 	bne	r2,zero,3217d08 <OSFlagNameGet+0xf8>
 3217ce4:	e0bffa17 	ldw	r2,-24(fp)
 3217ce8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3217cec:	e0bff817 	ldw	r2,-32(fp)
 3217cf0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 3217cf4:	e0fffe17 	ldw	r3,-8(fp)
 3217cf8:	00800044 	movi	r2,1
 3217cfc:	18800005 	stb	r2,0(r3)
        return (0);
 3217d00:	e03fff15 	stw	zero,-4(fp)
 3217d04:	00000d06 	br	3217d3c <OSFlagNameGet+0x12c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
 3217d08:	e0bffc17 	ldw	r2,-16(fp)
 3217d0c:	11400284 	addi	r5,r2,10
 3217d10:	e13ffd17 	ldw	r4,-12(fp)
 3217d14:	3216dc80 	call	3216dc8 <OS_StrCopy>
 3217d18:	e0bffb05 	stb	r2,-20(fp)
 3217d1c:	e0bffa17 	ldw	r2,-24(fp)
 3217d20:	e0bff715 	stw	r2,-36(fp)
 3217d24:	e0bff717 	ldw	r2,-36(fp)
 3217d28:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 3217d2c:	e0bffe17 	ldw	r2,-8(fp)
 3217d30:	10000005 	stb	zero,0(r2)
    return (len);
 3217d34:	e0bffb03 	ldbu	r2,-20(fp)
 3217d38:	e0bfff15 	stw	r2,-4(fp)
 3217d3c:	e0bfff17 	ldw	r2,-4(fp)
}
 3217d40:	e037883a 	mov	sp,fp
 3217d44:	dfc00117 	ldw	ra,4(sp)
 3217d48:	df000017 	ldw	fp,0(sp)
 3217d4c:	dec00204 	addi	sp,sp,8
 3217d50:	f800283a 	ret

03217d54 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 3217d54:	defff504 	addi	sp,sp,-44
 3217d58:	dfc00a15 	stw	ra,40(sp)
 3217d5c:	df000915 	stw	fp,36(sp)
 3217d60:	df000904 	addi	fp,sp,36
 3217d64:	e13ffd15 	stw	r4,-12(fp)
 3217d68:	e17ffe15 	stw	r5,-8(fp)
 3217d6c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3217d70:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 3217d74:	e0bfff17 	ldw	r2,-4(fp)
 3217d78:	1005003a 	cmpeq	r2,r2,zero
 3217d7c:	1000451e 	bne	r2,zero,3217e94 <OSFlagNameSet+0x140>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 3217d80:	e0bffd17 	ldw	r2,-12(fp)
 3217d84:	1004c03a 	cmpne	r2,r2,zero
 3217d88:	1000041e 	bne	r2,zero,3217d9c <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 3217d8c:	e0ffff17 	ldw	r3,-4(fp)
 3217d90:	00801b84 	movi	r2,110
 3217d94:	18800005 	stb	r2,0(r3)
        return;
 3217d98:	00003e06 	br	3217e94 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 3217d9c:	e0bffe17 	ldw	r2,-8(fp)
 3217da0:	1004c03a 	cmpne	r2,r2,zero
 3217da4:	1000041e 	bne	r2,zero,3217db8 <OSFlagNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 3217da8:	e0ffff17 	ldw	r3,-4(fp)
 3217dac:	00800304 	movi	r2,12
 3217db0:	18800005 	stb	r2,0(r3)
        return;
 3217db4:	00003706 	br	3217e94 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 3217db8:	0080c974 	movhi	r2,805
 3217dbc:	10922904 	addi	r2,r2,18596
 3217dc0:	10800003 	ldbu	r2,0(r2)
 3217dc4:	10803fcc 	andi	r2,r2,255
 3217dc8:	1005003a 	cmpeq	r2,r2,zero
 3217dcc:	1000041e 	bne	r2,zero,3217de0 <OSFlagNameSet+0x8c>
        *perr = OS_ERR_NAME_SET_ISR;
 3217dd0:	e0ffff17 	ldw	r3,-4(fp)
 3217dd4:	00800484 	movi	r2,18
 3217dd8:	18800005 	stb	r2,0(r3)
        return;
 3217ddc:	00002d06 	br	3217e94 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3217de0:	0005303a 	rdctl	r2,status
 3217de4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3217de8:	e0fffa17 	ldw	r3,-24(fp)
 3217dec:	00bfff84 	movi	r2,-2
 3217df0:	1884703a 	and	r2,r3,r2
 3217df4:	1001703a 	wrctl	status,r2
  
  return context;
 3217df8:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 3217dfc:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 3217e00:	e0bffd17 	ldw	r2,-12(fp)
 3217e04:	10800003 	ldbu	r2,0(r2)
 3217e08:	10803fcc 	andi	r2,r2,255
 3217e0c:	10800160 	cmpeqi	r2,r2,5
 3217e10:	1000081e 	bne	r2,zero,3217e34 <OSFlagNameSet+0xe0>
 3217e14:	e0bffb17 	ldw	r2,-20(fp)
 3217e18:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3217e1c:	e0bff917 	ldw	r2,-28(fp)
 3217e20:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 3217e24:	e0ffff17 	ldw	r3,-4(fp)
 3217e28:	00800044 	movi	r2,1
 3217e2c:	18800005 	stb	r2,0(r3)
        return;
 3217e30:	00001806 	br	3217e94 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 3217e34:	e13ffe17 	ldw	r4,-8(fp)
 3217e38:	3216e480 	call	3216e48 <OS_StrLen>
 3217e3c:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
 3217e40:	e0bffc03 	ldbu	r2,-16(fp)
 3217e44:	10800830 	cmpltui	r2,r2,32
 3217e48:	1000081e 	bne	r2,zero,3217e6c <OSFlagNameSet+0x118>
 3217e4c:	e0bffb17 	ldw	r2,-20(fp)
 3217e50:	e0bff815 	stw	r2,-32(fp)
 3217e54:	e0bff817 	ldw	r2,-32(fp)
 3217e58:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
 3217e5c:	e0ffff17 	ldw	r3,-4(fp)
 3217e60:	00801cc4 	movi	r2,115
 3217e64:	18800005 	stb	r2,0(r3)
        return;
 3217e68:	00000a06 	br	3217e94 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
 3217e6c:	e0bffd17 	ldw	r2,-12(fp)
 3217e70:	11000284 	addi	r4,r2,10
 3217e74:	e17ffe17 	ldw	r5,-8(fp)
 3217e78:	3216dc80 	call	3216dc8 <OS_StrCopy>
 3217e7c:	e0bffb17 	ldw	r2,-20(fp)
 3217e80:	e0bff715 	stw	r2,-36(fp)
 3217e84:	e0bff717 	ldw	r2,-36(fp)
 3217e88:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 3217e8c:	e0bfff17 	ldw	r2,-4(fp)
 3217e90:	10000005 	stb	zero,0(r2)
    return;
}
 3217e94:	e037883a 	mov	sp,fp
 3217e98:	dfc00117 	ldw	ra,4(sp)
 3217e9c:	df000017 	ldw	fp,0(sp)
 3217ea0:	dec00204 	addi	sp,sp,8
 3217ea4:	f800283a 	ret

03217ea8 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
 3217ea8:	deffe004 	addi	sp,sp,-128
 3217eac:	dfc01f15 	stw	ra,124(sp)
 3217eb0:	df001e15 	stw	fp,120(sp)
 3217eb4:	df001e04 	addi	fp,sp,120
 3217eb8:	e13ff915 	stw	r4,-28(fp)
 3217ebc:	e17ffa0d 	sth	r5,-24(fp)
 3217ec0:	e1bffb05 	stb	r6,-20(fp)
 3217ec4:	e1fffc0d 	sth	r7,-16(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 3217ec8:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 3217ecc:	e0800217 	ldw	r2,8(fp)
 3217ed0:	1004c03a 	cmpne	r2,r2,zero
 3217ed4:	1000021e 	bne	r2,zero,3217ee0 <OSFlagPend+0x38>
        return ((OS_FLAGS)0);
 3217ed8:	e03fff15 	stw	zero,-4(fp)
 3217edc:	00017d06 	br	32184d4 <OSFlagPend+0x62c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 3217ee0:	e0bff917 	ldw	r2,-28(fp)
 3217ee4:	1004c03a 	cmpne	r2,r2,zero
 3217ee8:	1000051e 	bne	r2,zero,3217f00 <OSFlagPend+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 3217eec:	e0c00217 	ldw	r3,8(fp)
 3217ef0:	00801b84 	movi	r2,110
 3217ef4:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 3217ef8:	e03fff15 	stw	zero,-4(fp)
 3217efc:	00017506 	br	32184d4 <OSFlagPend+0x62c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 3217f00:	0080c974 	movhi	r2,805
 3217f04:	10922904 	addi	r2,r2,18596
 3217f08:	10800003 	ldbu	r2,0(r2)
 3217f0c:	10803fcc 	andi	r2,r2,255
 3217f10:	1005003a 	cmpeq	r2,r2,zero
 3217f14:	1000051e 	bne	r2,zero,3217f2c <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
 3217f18:	e0c00217 	ldw	r3,8(fp)
 3217f1c:	00800084 	movi	r2,2
 3217f20:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 3217f24:	e03fff15 	stw	zero,-4(fp)
 3217f28:	00016a06 	br	32184d4 <OSFlagPend+0x62c>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
 3217f2c:	0080c974 	movhi	r2,805
 3217f30:	10921b04 	addi	r2,r2,18540
 3217f34:	10800003 	ldbu	r2,0(r2)
 3217f38:	10803fcc 	andi	r2,r2,255
 3217f3c:	1005003a 	cmpeq	r2,r2,zero
 3217f40:	1000051e 	bne	r2,zero,3217f58 <OSFlagPend+0xb0>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
 3217f44:	e0c00217 	ldw	r3,8(fp)
 3217f48:	00800344 	movi	r2,13
 3217f4c:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 3217f50:	e03fff15 	stw	zero,-4(fp)
 3217f54:	00015f06 	br	32184d4 <OSFlagPend+0x62c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 3217f58:	e0bff917 	ldw	r2,-28(fp)
 3217f5c:	10800003 	ldbu	r2,0(r2)
 3217f60:	10803fcc 	andi	r2,r2,255
 3217f64:	10800160 	cmpeqi	r2,r2,5
 3217f68:	1000051e 	bne	r2,zero,3217f80 <OSFlagPend+0xd8>
        *perr = OS_ERR_EVENT_TYPE;
 3217f6c:	e0c00217 	ldw	r3,8(fp)
 3217f70:	00800044 	movi	r2,1
 3217f74:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 3217f78:	e03fff15 	stw	zero,-4(fp)
 3217f7c:	00015506 	br	32184d4 <OSFlagPend+0x62c>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 3217f80:	e0fffb03 	ldbu	r3,-20(fp)
 3217f84:	00bfe004 	movi	r2,-128
 3217f88:	1884703a 	and	r2,r3,r2
 3217f8c:	e0bff285 	stb	r2,-54(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
 3217f90:	e0bff283 	ldbu	r2,-54(fp)
 3217f94:	1005003a 	cmpeq	r2,r2,zero
 3217f98:	1000071e 	bne	r2,zero,3217fb8 <OSFlagPend+0x110>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
 3217f9c:	00c01fc4 	movi	r3,127
 3217fa0:	e0bffb03 	ldbu	r2,-20(fp)
 3217fa4:	10c4703a 	and	r2,r2,r3
 3217fa8:	e0bffb05 	stb	r2,-20(fp)
        consume    = OS_TRUE;
 3217fac:	00800044 	movi	r2,1
 3217fb0:	e0bff205 	stb	r2,-56(fp)
 3217fb4:	00000106 	br	3217fbc <OSFlagPend+0x114>
    } else {
        consume    = OS_FALSE;
 3217fb8:	e03ff205 	stb	zero,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3217fbc:	0005303a 	rdctl	r2,status
 3217fc0:	e0bff015 	stw	r2,-64(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3217fc4:	e0fff017 	ldw	r3,-64(fp)
 3217fc8:	00bfff84 	movi	r2,-2
 3217fcc:	1884703a 	and	r2,r3,r2
 3217fd0:	1001703a 	wrctl	status,r2
  
  return context;
 3217fd4:	e0bff017 	ldw	r2,-64(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 3217fd8:	e0bff115 	stw	r2,-60(fp)
    switch (wait_type) {
 3217fdc:	e0bffb03 	ldbu	r2,-20(fp)
 3217fe0:	e0bffe15 	stw	r2,-8(fp)
 3217fe4:	e0fffe17 	ldw	r3,-8(fp)
 3217fe8:	18800060 	cmpeqi	r2,r3,1
 3217fec:	1000981e 	bne	r2,zero,3218250 <OSFlagPend+0x3a8>
 3217ff0:	e0fffe17 	ldw	r3,-8(fp)
 3217ff4:	18800088 	cmpgei	r2,r3,2
 3217ff8:	1000041e 	bne	r2,zero,321800c <OSFlagPend+0x164>
 3217ffc:	e0fffe17 	ldw	r3,-8(fp)
 3218000:	1805003a 	cmpeq	r2,r3,zero
 3218004:	1000641e 	bne	r2,zero,3218198 <OSFlagPend+0x2f0>
 3218008:	0000bf06 	br	3218308 <OSFlagPend+0x460>
 321800c:	e0fffe17 	ldw	r3,-8(fp)
 3218010:	188000a0 	cmpeqi	r2,r3,2
 3218014:	1000041e 	bne	r2,zero,3218028 <OSFlagPend+0x180>
 3218018:	e0fffe17 	ldw	r3,-8(fp)
 321801c:	188000e0 	cmpeqi	r2,r3,3
 3218020:	10002f1e 	bne	r2,zero,32180e0 <OSFlagPend+0x238>
 3218024:	0000b806 	br	3218308 <OSFlagPend+0x460>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
 3218028:	e0bff917 	ldw	r2,-28(fp)
 321802c:	10c0020b 	ldhu	r3,8(r2)
 3218030:	e0bffa0b 	ldhu	r2,-24(fp)
 3218034:	1884703a 	and	r2,r3,r2
 3218038:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 321803c:	e0fff30b 	ldhu	r3,-52(fp)
 3218040:	e0bffa0b 	ldhu	r2,-24(fp)
 3218044:	18801a1e 	bne	r3,r2,32180b0 <OSFlagPend+0x208>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 3218048:	e0bff203 	ldbu	r2,-56(fp)
 321804c:	10800058 	cmpnei	r2,r2,1
 3218050:	1000091e 	bne	r2,zero,3218078 <OSFlagPend+0x1d0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 3218054:	e0bff917 	ldw	r2,-28(fp)
 3218058:	1080020b 	ldhu	r2,8(r2)
 321805c:	1007883a 	mov	r3,r2
 3218060:	e0bff30b 	ldhu	r2,-52(fp)
 3218064:	0084303a 	nor	r2,zero,r2
 3218068:	1884703a 	and	r2,r3,r2
 321806c:	1007883a 	mov	r3,r2
 3218070:	e0bff917 	ldw	r2,-28(fp)
 3218074:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 3218078:	0080c974 	movhi	r2,805
 321807c:	10922a04 	addi	r2,r2,18600
 3218080:	10c00017 	ldw	r3,0(r2)
 3218084:	e0bff30b 	ldhu	r2,-52(fp)
 3218088:	18800b0d 	sth	r2,44(r3)
 321808c:	e0bff117 	ldw	r2,-60(fp)
 3218090:	e0bfef15 	stw	r2,-68(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3218094:	e0bfef17 	ldw	r2,-68(fp)
 3218098:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 321809c:	e0800217 	ldw	r2,8(fp)
 32180a0:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 32180a4:	e0bff30b 	ldhu	r2,-52(fp)
 32180a8:	e0bfff15 	stw	r2,-4(fp)
 32180ac:	00010906 	br	32184d4 <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 32180b0:	e1bffa0b 	ldhu	r6,-24(fp)
 32180b4:	e1fffb03 	ldbu	r7,-20(fp)
 32180b8:	e0bffc0b 	ldhu	r2,-16(fp)
 32180bc:	e17ff404 	addi	r5,fp,-48
 32180c0:	d8800015 	stw	r2,0(sp)
 32180c4:	e13ff917 	ldw	r4,-28(fp)
 32180c8:	32189d00 	call	32189d0 <OS_FlagBlock>
 32180cc:	e0bff117 	ldw	r2,-60(fp)
 32180d0:	e0bfee15 	stw	r2,-72(fp)
 32180d4:	e0bfee17 	ldw	r2,-72(fp)
 32180d8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 32180dc:	00009506 	br	3218334 <OSFlagPend+0x48c>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
 32180e0:	e0bff917 	ldw	r2,-28(fp)
 32180e4:	10c0020b 	ldhu	r3,8(r2)
 32180e8:	e0bffa0b 	ldhu	r2,-24(fp)
 32180ec:	1884703a 	and	r2,r3,r2
 32180f0:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 32180f4:	e0bff30b 	ldhu	r2,-52(fp)
 32180f8:	1005003a 	cmpeq	r2,r2,zero
 32180fc:	10001a1e 	bne	r2,zero,3218168 <OSFlagPend+0x2c0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 3218100:	e0bff203 	ldbu	r2,-56(fp)
 3218104:	10800058 	cmpnei	r2,r2,1
 3218108:	1000091e 	bne	r2,zero,3218130 <OSFlagPend+0x288>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 321810c:	e0bff917 	ldw	r2,-28(fp)
 3218110:	1080020b 	ldhu	r2,8(r2)
 3218114:	1007883a 	mov	r3,r2
 3218118:	e0bff30b 	ldhu	r2,-52(fp)
 321811c:	0084303a 	nor	r2,zero,r2
 3218120:	1884703a 	and	r2,r3,r2
 3218124:	1007883a 	mov	r3,r2
 3218128:	e0bff917 	ldw	r2,-28(fp)
 321812c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 3218130:	0080c974 	movhi	r2,805
 3218134:	10922a04 	addi	r2,r2,18600
 3218138:	10c00017 	ldw	r3,0(r2)
 321813c:	e0bff30b 	ldhu	r2,-52(fp)
 3218140:	18800b0d 	sth	r2,44(r3)
 3218144:	e0bff117 	ldw	r2,-60(fp)
 3218148:	e0bfed15 	stw	r2,-76(fp)
 321814c:	e0bfed17 	ldw	r2,-76(fp)
 3218150:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 3218154:	e0800217 	ldw	r2,8(fp)
 3218158:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 321815c:	e0fff30b 	ldhu	r3,-52(fp)
 3218160:	e0ffff15 	stw	r3,-4(fp)
 3218164:	0000db06 	br	32184d4 <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 3218168:	e1bffa0b 	ldhu	r6,-24(fp)
 321816c:	e1fffb03 	ldbu	r7,-20(fp)
 3218170:	e0bffc0b 	ldhu	r2,-16(fp)
 3218174:	e17ff404 	addi	r5,fp,-48
 3218178:	d8800015 	stw	r2,0(sp)
 321817c:	e13ff917 	ldw	r4,-28(fp)
 3218180:	32189d00 	call	32189d0 <OS_FlagBlock>
 3218184:	e0bff117 	ldw	r2,-60(fp)
 3218188:	e0bfec15 	stw	r2,-80(fp)
 321818c:	e0bfec17 	ldw	r2,-80(fp)
 3218190:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 3218194:	00006706 	br	3218334 <OSFlagPend+0x48c>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 3218198:	e0bff917 	ldw	r2,-28(fp)
 321819c:	1080020b 	ldhu	r2,8(r2)
 32181a0:	0084303a 	nor	r2,zero,r2
 32181a4:	1007883a 	mov	r3,r2
 32181a8:	e0bffa0b 	ldhu	r2,-24(fp)
 32181ac:	1884703a 	and	r2,r3,r2
 32181b0:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 32181b4:	e0fff30b 	ldhu	r3,-52(fp)
 32181b8:	e0bffa0b 	ldhu	r2,-24(fp)
 32181bc:	1880181e 	bne	r3,r2,3218220 <OSFlagPend+0x378>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 32181c0:	e0bff203 	ldbu	r2,-56(fp)
 32181c4:	10800058 	cmpnei	r2,r2,1
 32181c8:	1000071e 	bne	r2,zero,32181e8 <OSFlagPend+0x340>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 32181cc:	e0bff917 	ldw	r2,-28(fp)
 32181d0:	10c0020b 	ldhu	r3,8(r2)
 32181d4:	e0bff30b 	ldhu	r2,-52(fp)
 32181d8:	1884b03a 	or	r2,r3,r2
 32181dc:	1007883a 	mov	r3,r2
 32181e0:	e0bff917 	ldw	r2,-28(fp)
 32181e4:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 32181e8:	0080c974 	movhi	r2,805
 32181ec:	10922a04 	addi	r2,r2,18600
 32181f0:	10c00017 	ldw	r3,0(r2)
 32181f4:	e0bff30b 	ldhu	r2,-52(fp)
 32181f8:	18800b0d 	sth	r2,44(r3)
 32181fc:	e0bff117 	ldw	r2,-60(fp)
 3218200:	e0bfeb15 	stw	r2,-84(fp)
 3218204:	e0bfeb17 	ldw	r2,-84(fp)
 3218208:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 321820c:	e0800217 	ldw	r2,8(fp)
 3218210:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 3218214:	e0bff30b 	ldhu	r2,-52(fp)
 3218218:	e0bfff15 	stw	r2,-4(fp)
 321821c:	0000ad06 	br	32184d4 <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 3218220:	e1bffa0b 	ldhu	r6,-24(fp)
 3218224:	e1fffb03 	ldbu	r7,-20(fp)
 3218228:	e0bffc0b 	ldhu	r2,-16(fp)
 321822c:	e17ff404 	addi	r5,fp,-48
 3218230:	d8800015 	stw	r2,0(sp)
 3218234:	e13ff917 	ldw	r4,-28(fp)
 3218238:	32189d00 	call	32189d0 <OS_FlagBlock>
 321823c:	e0bff117 	ldw	r2,-60(fp)
 3218240:	e0bfea15 	stw	r2,-88(fp)
 3218244:	e0bfea17 	ldw	r2,-88(fp)
 3218248:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 321824c:	00003906 	br	3218334 <OSFlagPend+0x48c>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 3218250:	e0bff917 	ldw	r2,-28(fp)
 3218254:	1080020b 	ldhu	r2,8(r2)
 3218258:	0084303a 	nor	r2,zero,r2
 321825c:	1007883a 	mov	r3,r2
 3218260:	e0bffa0b 	ldhu	r2,-24(fp)
 3218264:	1884703a 	and	r2,r3,r2
 3218268:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 321826c:	e0bff30b 	ldhu	r2,-52(fp)
 3218270:	1005003a 	cmpeq	r2,r2,zero
 3218274:	1000181e 	bne	r2,zero,32182d8 <OSFlagPend+0x430>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 3218278:	e0bff203 	ldbu	r2,-56(fp)
 321827c:	10800058 	cmpnei	r2,r2,1
 3218280:	1000071e 	bne	r2,zero,32182a0 <OSFlagPend+0x3f8>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 3218284:	e0bff917 	ldw	r2,-28(fp)
 3218288:	10c0020b 	ldhu	r3,8(r2)
 321828c:	e0bff30b 	ldhu	r2,-52(fp)
 3218290:	1884b03a 	or	r2,r3,r2
 3218294:	1007883a 	mov	r3,r2
 3218298:	e0bff917 	ldw	r2,-28(fp)
 321829c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 32182a0:	0080c974 	movhi	r2,805
 32182a4:	10922a04 	addi	r2,r2,18600
 32182a8:	10c00017 	ldw	r3,0(r2)
 32182ac:	e0bff30b 	ldhu	r2,-52(fp)
 32182b0:	18800b0d 	sth	r2,44(r3)
 32182b4:	e0bff117 	ldw	r2,-60(fp)
 32182b8:	e0bfe915 	stw	r2,-92(fp)
 32182bc:	e0bfe917 	ldw	r2,-92(fp)
 32182c0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 32182c4:	e0800217 	ldw	r2,8(fp)
 32182c8:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 32182cc:	e0fff30b 	ldhu	r3,-52(fp)
 32182d0:	e0ffff15 	stw	r3,-4(fp)
 32182d4:	00007f06 	br	32184d4 <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 32182d8:	e1bffa0b 	ldhu	r6,-24(fp)
 32182dc:	e1fffb03 	ldbu	r7,-20(fp)
 32182e0:	e0bffc0b 	ldhu	r2,-16(fp)
 32182e4:	e17ff404 	addi	r5,fp,-48
 32182e8:	d8800015 	stw	r2,0(sp)
 32182ec:	e13ff917 	ldw	r4,-28(fp)
 32182f0:	32189d00 	call	32189d0 <OS_FlagBlock>
 32182f4:	e0bff117 	ldw	r2,-60(fp)
 32182f8:	e0bfe815 	stw	r2,-96(fp)
 32182fc:	e0bfe817 	ldw	r2,-96(fp)
 3218300:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 3218304:	00000b06 	br	3218334 <OSFlagPend+0x48c>
 3218308:	e0bff117 	ldw	r2,-60(fp)
 321830c:	e0bfe715 	stw	r2,-100(fp)
 3218310:	e0bfe717 	ldw	r2,-100(fp)
 3218314:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 3218318:	e03ff30d 	sth	zero,-52(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
 321831c:	e0c00217 	ldw	r3,8(fp)
 3218320:	00801bc4 	movi	r2,111
 3218324:	18800005 	stb	r2,0(r3)
             return (flags_rdy);
 3218328:	e0bff30b 	ldhu	r2,-52(fp)
 321832c:	e0bfff15 	stw	r2,-4(fp)
 3218330:	00006806 	br	32184d4 <OSFlagPend+0x62c>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
 3218334:	3216c840 	call	3216c84 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3218338:	0005303a 	rdctl	r2,status
 321833c:	e0bfe615 	stw	r2,-104(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3218340:	e0ffe617 	ldw	r3,-104(fp)
 3218344:	00bfff84 	movi	r2,-2
 3218348:	1884703a 	and	r2,r3,r2
 321834c:	1001703a 	wrctl	status,r2
  
  return context;
 3218350:	e0bfe617 	ldw	r2,-104(fp)
    OS_ENTER_CRITICAL();
 3218354:	e0bff115 	stw	r2,-60(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
 3218358:	0080c974 	movhi	r2,805
 321835c:	10922a04 	addi	r2,r2,18600
 3218360:	10800017 	ldw	r2,0(r2)
 3218364:	10800c43 	ldbu	r2,49(r2)
 3218368:	10803fcc 	andi	r2,r2,255
 321836c:	1005003a 	cmpeq	r2,r2,zero
 3218370:	1000221e 	bne	r2,zero,32183fc <OSFlagPend+0x554>
        pend_stat                = OSTCBCur->OSTCBStatPend;
 3218374:	0080c974 	movhi	r2,805
 3218378:	10922a04 	addi	r2,r2,18600
 321837c:	10800017 	ldw	r2,0(r2)
 3218380:	10800c43 	ldbu	r2,49(r2)
 3218384:	e0bff245 	stb	r2,-55(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 3218388:	0080c974 	movhi	r2,805
 321838c:	10922a04 	addi	r2,r2,18600
 3218390:	10800017 	ldw	r2,0(r2)
 3218394:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
 3218398:	e13ff404 	addi	r4,fp,-48
 321839c:	3218d880 	call	3218d88 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
 32183a0:	0080c974 	movhi	r2,805
 32183a4:	10922a04 	addi	r2,r2,18600
 32183a8:	10800017 	ldw	r2,0(r2)
 32183ac:	10000c05 	stb	zero,48(r2)
 32183b0:	e0bff117 	ldw	r2,-60(fp)
 32183b4:	e0bfe515 	stw	r2,-108(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 32183b8:	e0bfe517 	ldw	r2,-108(fp)
 32183bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
 32183c0:	e03ff30d 	sth	zero,-52(fp)
        switch (pend_stat) {
 32183c4:	e0bff243 	ldbu	r2,-55(fp)
 32183c8:	108000a0 	cmpeqi	r2,r2,2
 32183cc:	1000011e 	bne	r2,zero,32183d4 <OSFlagPend+0x52c>
 32183d0:	00000406 	br	32183e4 <OSFlagPend+0x53c>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
 32183d4:	e0c00217 	ldw	r3,8(fp)
 32183d8:	00800384 	movi	r2,14
 32183dc:	18800005 	stb	r2,0(r3)
                 break;
 32183e0:	00000306 	br	32183f0 <OSFlagPend+0x548>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
 32183e4:	e0c00217 	ldw	r3,8(fp)
 32183e8:	00800284 	movi	r2,10
 32183ec:	18800005 	stb	r2,0(r3)
                 break;
        }
        return (flags_rdy);
 32183f0:	e0fff30b 	ldhu	r3,-52(fp)
 32183f4:	e0ffff15 	stw	r3,-4(fp)
 32183f8:	00003606 	br	32184d4 <OSFlagPend+0x62c>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
 32183fc:	0080c974 	movhi	r2,805
 3218400:	10922a04 	addi	r2,r2,18600
 3218404:	10800017 	ldw	r2,0(r2)
 3218408:	10800b0b 	ldhu	r2,44(r2)
 321840c:	e0bff30d 	sth	r2,-52(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
 3218410:	e0bff203 	ldbu	r2,-56(fp)
 3218414:	10800058 	cmpnei	r2,r2,1
 3218418:	1000261e 	bne	r2,zero,32184b4 <OSFlagPend+0x60c>
        switch (wait_type) {
 321841c:	e0bffb03 	ldbu	r2,-20(fp)
 3218420:	e0bffd15 	stw	r2,-12(fp)
 3218424:	e0fffd17 	ldw	r3,-12(fp)
 3218428:	1804803a 	cmplt	r2,r3,zero
 321842c:	1000181e 	bne	r2,zero,3218490 <OSFlagPend+0x5e8>
 3218430:	e0fffd17 	ldw	r3,-12(fp)
 3218434:	18800090 	cmplti	r2,r3,2
 3218438:	10000d1e 	bne	r2,zero,3218470 <OSFlagPend+0x5c8>
 321843c:	e0fffd17 	ldw	r3,-12(fp)
 3218440:	18800108 	cmpgei	r2,r3,4
 3218444:	1000121e 	bne	r2,zero,3218490 <OSFlagPend+0x5e8>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
 3218448:	e0bff917 	ldw	r2,-28(fp)
 321844c:	1080020b 	ldhu	r2,8(r2)
 3218450:	1007883a 	mov	r3,r2
 3218454:	e0bff30b 	ldhu	r2,-52(fp)
 3218458:	0084303a 	nor	r2,zero,r2
 321845c:	1884703a 	and	r2,r3,r2
 3218460:	1007883a 	mov	r3,r2
 3218464:	e0bff917 	ldw	r2,-28(fp)
 3218468:	10c0020d 	sth	r3,8(r2)
                 break;
 321846c:	00001106 	br	32184b4 <OSFlagPend+0x60c>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
 3218470:	e0bff917 	ldw	r2,-28(fp)
 3218474:	10c0020b 	ldhu	r3,8(r2)
 3218478:	e0bff30b 	ldhu	r2,-52(fp)
 321847c:	1884b03a 	or	r2,r3,r2
 3218480:	1007883a 	mov	r3,r2
 3218484:	e0bff917 	ldw	r2,-28(fp)
 3218488:	10c0020d 	sth	r3,8(r2)
                 break;
 321848c:	00000906 	br	32184b4 <OSFlagPend+0x60c>
 3218490:	e0bff117 	ldw	r2,-60(fp)
 3218494:	e0bfe415 	stw	r2,-112(fp)
 3218498:	e0bfe417 	ldw	r2,-112(fp)
 321849c:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 32184a0:	e0c00217 	ldw	r3,8(fp)
 32184a4:	00801bc4 	movi	r2,111
 32184a8:	18800005 	stb	r2,0(r3)
                 return ((OS_FLAGS)0);
 32184ac:	e03fff15 	stw	zero,-4(fp)
 32184b0:	00000806 	br	32184d4 <OSFlagPend+0x62c>
 32184b4:	e0bff117 	ldw	r2,-60(fp)
 32184b8:	e0bfe315 	stw	r2,-116(fp)
 32184bc:	e0bfe317 	ldw	r2,-116(fp)
 32184c0:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
 32184c4:	e0800217 	ldw	r2,8(fp)
 32184c8:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
 32184cc:	e0bff30b 	ldhu	r2,-52(fp)
 32184d0:	e0bfff15 	stw	r2,-4(fp)
 32184d4:	e0bfff17 	ldw	r2,-4(fp)
}
 32184d8:	e037883a 	mov	sp,fp
 32184dc:	dfc00117 	ldw	ra,4(sp)
 32184e0:	df000017 	ldw	fp,0(sp)
 32184e4:	dec00204 	addi	sp,sp,8
 32184e8:	f800283a 	ret

032184ec <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
 32184ec:	defffb04 	addi	sp,sp,-20
 32184f0:	df000415 	stw	fp,16(sp)
 32184f4:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 32184f8:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32184fc:	0005303a 	rdctl	r2,status
 3218500:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3218504:	e0fffd17 	ldw	r3,-12(fp)
 3218508:	00bfff84 	movi	r2,-2
 321850c:	1884703a 	and	r2,r3,r2
 3218510:	1001703a 	wrctl	status,r2
  
  return context;
 3218514:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 3218518:	e0bffe15 	stw	r2,-8(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
 321851c:	0080c974 	movhi	r2,805
 3218520:	10922a04 	addi	r2,r2,18600
 3218524:	10800017 	ldw	r2,0(r2)
 3218528:	10800b0b 	ldhu	r2,44(r2)
 321852c:	e0bfff0d 	sth	r2,-4(fp)
 3218530:	e0bffe17 	ldw	r2,-8(fp)
 3218534:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3218538:	e0bffc17 	ldw	r2,-16(fp)
 321853c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
 3218540:	e0bfff0b 	ldhu	r2,-4(fp)
}
 3218544:	e037883a 	mov	sp,fp
 3218548:	df000017 	ldw	fp,0(sp)
 321854c:	dec00104 	addi	sp,sp,4
 3218550:	f800283a 	ret

03218554 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
 3218554:	deffed04 	addi	sp,sp,-76
 3218558:	dfc01215 	stw	ra,72(sp)
 321855c:	df001115 	stw	fp,68(sp)
 3218560:	df001104 	addi	fp,sp,68
 3218564:	e13ff915 	stw	r4,-28(fp)
 3218568:	e1fffc15 	stw	r7,-16(fp)
 321856c:	e17ffa0d 	sth	r5,-24(fp)
 3218570:	e1bffb05 	stb	r6,-20(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
 3218574:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 3218578:	e0bffc17 	ldw	r2,-16(fp)
 321857c:	1004c03a 	cmpne	r2,r2,zero
 3218580:	1000021e 	bne	r2,zero,321858c <OSFlagPost+0x38>
        return ((OS_FLAGS)0);
 3218584:	e03fff15 	stw	zero,-4(fp)
 3218588:	0000d606 	br	32188e4 <OSFlagPost+0x390>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
 321858c:	e0bff917 	ldw	r2,-28(fp)
 3218590:	1004c03a 	cmpne	r2,r2,zero
 3218594:	1000051e 	bne	r2,zero,32185ac <OSFlagPost+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 3218598:	e0fffc17 	ldw	r3,-16(fp)
 321859c:	00801b84 	movi	r2,110
 32185a0:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 32185a4:	e03fff15 	stw	zero,-4(fp)
 32185a8:	0000ce06 	br	32188e4 <OSFlagPost+0x390>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
 32185ac:	e0bff917 	ldw	r2,-28(fp)
 32185b0:	10800003 	ldbu	r2,0(r2)
 32185b4:	10803fcc 	andi	r2,r2,255
 32185b8:	10800160 	cmpeqi	r2,r2,5
 32185bc:	1000051e 	bne	r2,zero,32185d4 <OSFlagPost+0x80>
        *perr = OS_ERR_EVENT_TYPE;
 32185c0:	e0fffc17 	ldw	r3,-16(fp)
 32185c4:	00800044 	movi	r2,1
 32185c8:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 32185cc:	e03fff15 	stw	zero,-4(fp)
 32185d0:	0000c406 	br	32188e4 <OSFlagPost+0x390>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32185d4:	0005303a 	rdctl	r2,status
 32185d8:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32185dc:	e0fff417 	ldw	r3,-48(fp)
 32185e0:	00bfff84 	movi	r2,-2
 32185e4:	1884703a 	and	r2,r3,r2
 32185e8:	1001703a 	wrctl	status,r2
  
  return context;
 32185ec:	e0bff417 	ldw	r2,-48(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 32185f0:	e0bff515 	stw	r2,-44(fp)
    switch (opt) {
 32185f4:	e0bffb03 	ldbu	r2,-20(fp)
 32185f8:	e0bffe15 	stw	r2,-8(fp)
 32185fc:	e0fffe17 	ldw	r3,-8(fp)
 3218600:	1805003a 	cmpeq	r2,r3,zero
 3218604:	1000041e 	bne	r2,zero,3218618 <OSFlagPost+0xc4>
 3218608:	e0fffe17 	ldw	r3,-8(fp)
 321860c:	18800060 	cmpeqi	r2,r3,1
 3218610:	10000b1e 	bne	r2,zero,3218640 <OSFlagPost+0xec>
 3218614:	00001206 	br	3218660 <OSFlagPost+0x10c>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
 3218618:	e0bff917 	ldw	r2,-28(fp)
 321861c:	1080020b 	ldhu	r2,8(r2)
 3218620:	1007883a 	mov	r3,r2
 3218624:	e0bffa0b 	ldhu	r2,-24(fp)
 3218628:	0084303a 	nor	r2,zero,r2
 321862c:	1884703a 	and	r2,r3,r2
 3218630:	1007883a 	mov	r3,r2
 3218634:	e0bff917 	ldw	r2,-28(fp)
 3218638:	10c0020d 	sth	r3,8(r2)
             break;
 321863c:	00001106 	br	3218684 <OSFlagPost+0x130>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
 3218640:	e0bff917 	ldw	r2,-28(fp)
 3218644:	10c0020b 	ldhu	r3,8(r2)
 3218648:	e0bffa0b 	ldhu	r2,-24(fp)
 321864c:	1884b03a 	or	r2,r3,r2
 3218650:	1007883a 	mov	r3,r2
 3218654:	e0bff917 	ldw	r2,-28(fp)
 3218658:	10c0020d 	sth	r3,8(r2)
             break;
 321865c:	00000906 	br	3218684 <OSFlagPost+0x130>
 3218660:	e0bff517 	ldw	r2,-44(fp)
 3218664:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3218668:	e0bff317 	ldw	r2,-52(fp)
 321866c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
 3218670:	e0fffc17 	ldw	r3,-16(fp)
 3218674:	00801c44 	movi	r2,113
 3218678:	18800005 	stb	r2,0(r3)
             return ((OS_FLAGS)0);
 321867c:	e03fff15 	stw	zero,-4(fp)
 3218680:	00009806 	br	32188e4 <OSFlagPost+0x390>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
 3218684:	e03ff785 	stb	zero,-34(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 3218688:	e0bff917 	ldw	r2,-28(fp)
 321868c:	10800117 	ldw	r2,4(r2)
 3218690:	e0bff815 	stw	r2,-32(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 3218694:	00007506 	br	321886c <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
 3218698:	e0bff817 	ldw	r2,-32(fp)
 321869c:	10800483 	ldbu	r2,18(r2)
 32186a0:	10803fcc 	andi	r2,r2,255
 32186a4:	e0bffd15 	stw	r2,-12(fp)
 32186a8:	e0fffd17 	ldw	r3,-12(fp)
 32186ac:	18800060 	cmpeqi	r2,r3,1
 32186b0:	10004d1e 	bne	r2,zero,32187e8 <OSFlagPost+0x294>
 32186b4:	e0fffd17 	ldw	r3,-12(fp)
 32186b8:	18800088 	cmpgei	r2,r3,2
 32186bc:	1000041e 	bne	r2,zero,32186d0 <OSFlagPost+0x17c>
 32186c0:	e0fffd17 	ldw	r3,-12(fp)
 32186c4:	1805003a 	cmpeq	r2,r3,zero
 32186c8:	1000301e 	bne	r2,zero,321878c <OSFlagPost+0x238>
 32186cc:	00005b06 	br	321883c <OSFlagPost+0x2e8>
 32186d0:	e0fffd17 	ldw	r3,-12(fp)
 32186d4:	188000a0 	cmpeqi	r2,r3,2
 32186d8:	1000041e 	bne	r2,zero,32186ec <OSFlagPost+0x198>
 32186dc:	e0fffd17 	ldw	r3,-12(fp)
 32186e0:	188000e0 	cmpeqi	r2,r3,3
 32186e4:	1000161e 	bne	r2,zero,3218740 <OSFlagPost+0x1ec>
 32186e8:	00005406 	br	321883c <OSFlagPost+0x2e8>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 32186ec:	e0bff917 	ldw	r2,-28(fp)
 32186f0:	10c0020b 	ldhu	r3,8(r2)
 32186f4:	e0bff817 	ldw	r2,-32(fp)
 32186f8:	1080040b 	ldhu	r2,16(r2)
 32186fc:	1884703a 	and	r2,r3,r2
 3218700:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 3218704:	e0bff817 	ldw	r2,-32(fp)
 3218708:	1080040b 	ldhu	r2,16(r2)
 321870c:	10ffffcc 	andi	r3,r2,65535
 3218710:	e0bff68b 	ldhu	r2,-38(fp)
 3218714:	1880521e 	bne	r3,r2,3218860 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 3218718:	e17ff68b 	ldhu	r5,-38(fp)
 321871c:	e13ff817 	ldw	r4,-32(fp)
 3218720:	3218c780 	call	3218c78 <OS_FlagTaskRdy>
 3218724:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 3218728:	e0bff603 	ldbu	r2,-40(fp)
 321872c:	10800058 	cmpnei	r2,r2,1
 3218730:	10004b1e 	bne	r2,zero,3218860 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 3218734:	00800044 	movi	r2,1
 3218738:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 321873c:	00004806 	br	3218860 <OSFlagPost+0x30c>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 3218740:	e0bff917 	ldw	r2,-28(fp)
 3218744:	10c0020b 	ldhu	r3,8(r2)
 3218748:	e0bff817 	ldw	r2,-32(fp)
 321874c:	1080040b 	ldhu	r2,16(r2)
 3218750:	1884703a 	and	r2,r3,r2
 3218754:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 3218758:	e0bff68b 	ldhu	r2,-38(fp)
 321875c:	1005003a 	cmpeq	r2,r2,zero
 3218760:	10003f1e 	bne	r2,zero,3218860 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 3218764:	e17ff68b 	ldhu	r5,-38(fp)
 3218768:	e13ff817 	ldw	r4,-32(fp)
 321876c:	3218c780 	call	3218c78 <OS_FlagTaskRdy>
 3218770:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 3218774:	e0bff603 	ldbu	r2,-40(fp)
 3218778:	10800058 	cmpnei	r2,r2,1
 321877c:	1000381e 	bne	r2,zero,3218860 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 3218780:	00800044 	movi	r2,1
 3218784:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 3218788:	00003506 	br	3218860 <OSFlagPost+0x30c>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 321878c:	e0bff917 	ldw	r2,-28(fp)
 3218790:	1080020b 	ldhu	r2,8(r2)
 3218794:	0084303a 	nor	r2,zero,r2
 3218798:	1007883a 	mov	r3,r2
 321879c:	e0bff817 	ldw	r2,-32(fp)
 32187a0:	1080040b 	ldhu	r2,16(r2)
 32187a4:	1884703a 	and	r2,r3,r2
 32187a8:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 32187ac:	e0bff817 	ldw	r2,-32(fp)
 32187b0:	1080040b 	ldhu	r2,16(r2)
 32187b4:	10ffffcc 	andi	r3,r2,65535
 32187b8:	e0bff68b 	ldhu	r2,-38(fp)
 32187bc:	1880281e 	bne	r3,r2,3218860 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 32187c0:	e17ff68b 	ldhu	r5,-38(fp)
 32187c4:	e13ff817 	ldw	r4,-32(fp)
 32187c8:	3218c780 	call	3218c78 <OS_FlagTaskRdy>
 32187cc:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 32187d0:	e0bff603 	ldbu	r2,-40(fp)
 32187d4:	10800058 	cmpnei	r2,r2,1
 32187d8:	1000211e 	bne	r2,zero,3218860 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 32187dc:	00800044 	movi	r2,1
 32187e0:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 32187e4:	00001e06 	br	3218860 <OSFlagPost+0x30c>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 32187e8:	e0bff917 	ldw	r2,-28(fp)
 32187ec:	1080020b 	ldhu	r2,8(r2)
 32187f0:	0084303a 	nor	r2,zero,r2
 32187f4:	1007883a 	mov	r3,r2
 32187f8:	e0bff817 	ldw	r2,-32(fp)
 32187fc:	1080040b 	ldhu	r2,16(r2)
 3218800:	1884703a 	and	r2,r3,r2
 3218804:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 3218808:	e0bff68b 	ldhu	r2,-38(fp)
 321880c:	1005003a 	cmpeq	r2,r2,zero
 3218810:	1000131e 	bne	r2,zero,3218860 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 3218814:	e17ff68b 	ldhu	r5,-38(fp)
 3218818:	e13ff817 	ldw	r4,-32(fp)
 321881c:	3218c780 	call	3218c78 <OS_FlagTaskRdy>
 3218820:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 3218824:	e0bff603 	ldbu	r2,-40(fp)
 3218828:	10800058 	cmpnei	r2,r2,1
 321882c:	10000c1e 	bne	r2,zero,3218860 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 3218830:	00800044 	movi	r2,1
 3218834:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 3218838:	00000906 	br	3218860 <OSFlagPost+0x30c>
 321883c:	e0bff517 	ldw	r2,-44(fp)
 3218840:	e0bff215 	stw	r2,-56(fp)
 3218844:	e0bff217 	ldw	r2,-56(fp)
 3218848:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 321884c:	e0fffc17 	ldw	r3,-16(fp)
 3218850:	00801bc4 	movi	r2,111
 3218854:	18800005 	stb	r2,0(r3)
                 return ((OS_FLAGS)0);
 3218858:	e03fff15 	stw	zero,-4(fp)
 321885c:	00002106 	br	32188e4 <OSFlagPost+0x390>
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
 3218860:	e0bff817 	ldw	r2,-32(fp)
 3218864:	10800017 	ldw	r2,0(r2)
 3218868:	e0bff815 	stw	r2,-32(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 321886c:	e0bff817 	ldw	r2,-32(fp)
 3218870:	1004c03a 	cmpne	r2,r2,zero
 3218874:	103f881e 	bne	r2,zero,3218698 <OSFlagPost+0x144>
 3218878:	e0bff517 	ldw	r2,-44(fp)
 321887c:	e0bff115 	stw	r2,-60(fp)
 3218880:	e0bff117 	ldw	r2,-60(fp)
 3218884:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
 3218888:	e0bff783 	ldbu	r2,-34(fp)
 321888c:	10800058 	cmpnei	r2,r2,1
 3218890:	1000011e 	bne	r2,zero,3218898 <OSFlagPost+0x344>
        OS_Sched();
 3218894:	3216c840 	call	3216c84 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3218898:	0005303a 	rdctl	r2,status
 321889c:	e0bff015 	stw	r2,-64(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32188a0:	e0fff017 	ldw	r3,-64(fp)
 32188a4:	00bfff84 	movi	r2,-2
 32188a8:	1884703a 	and	r2,r3,r2
 32188ac:	1001703a 	wrctl	status,r2
  
  return context;
 32188b0:	e0bff017 	ldw	r2,-64(fp)
    }
    OS_ENTER_CRITICAL();
 32188b4:	e0bff515 	stw	r2,-44(fp)
    flags_cur = pgrp->OSFlagFlags;
 32188b8:	e0bff917 	ldw	r2,-28(fp)
 32188bc:	1080020b 	ldhu	r2,8(r2)
 32188c0:	e0bff70d 	sth	r2,-36(fp)
 32188c4:	e0bff517 	ldw	r2,-44(fp)
 32188c8:	e0bfef15 	stw	r2,-68(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 32188cc:	e0bfef17 	ldw	r2,-68(fp)
 32188d0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
 32188d4:	e0bffc17 	ldw	r2,-16(fp)
 32188d8:	10000005 	stb	zero,0(r2)
    return (flags_cur);
 32188dc:	e0bff70b 	ldhu	r2,-36(fp)
 32188e0:	e0bfff15 	stw	r2,-4(fp)
 32188e4:	e0bfff17 	ldw	r2,-4(fp)
}
 32188e8:	e037883a 	mov	sp,fp
 32188ec:	dfc00117 	ldw	ra,4(sp)
 32188f0:	df000017 	ldw	fp,0(sp)
 32188f4:	dec00204 	addi	sp,sp,8
 32188f8:	f800283a 	ret

032188fc <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
 32188fc:	defff804 	addi	sp,sp,-32
 3218900:	df000715 	stw	fp,28(sp)
 3218904:	df000704 	addi	fp,sp,28
 3218908:	e13ffd15 	stw	r4,-12(fp)
 321890c:	e17ffe15 	stw	r5,-8(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
 3218910:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
 3218914:	e0bffe17 	ldw	r2,-8(fp)
 3218918:	1004c03a 	cmpne	r2,r2,zero
 321891c:	1000021e 	bne	r2,zero,3218928 <OSFlagQuery+0x2c>
        return ((OS_FLAGS)0);
 3218920:	e03fff15 	stw	zero,-4(fp)
 3218924:	00002506 	br	32189bc <OSFlagQuery+0xc0>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
 3218928:	e0bffd17 	ldw	r2,-12(fp)
 321892c:	1004c03a 	cmpne	r2,r2,zero
 3218930:	1000051e 	bne	r2,zero,3218948 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 3218934:	e0fffe17 	ldw	r3,-8(fp)
 3218938:	00801b84 	movi	r2,110
 321893c:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 3218940:	e03fff15 	stw	zero,-4(fp)
 3218944:	00001d06 	br	32189bc <OSFlagQuery+0xc0>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
 3218948:	e0bffd17 	ldw	r2,-12(fp)
 321894c:	10800003 	ldbu	r2,0(r2)
 3218950:	10803fcc 	andi	r2,r2,255
 3218954:	10800160 	cmpeqi	r2,r2,5
 3218958:	1000051e 	bne	r2,zero,3218970 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
 321895c:	e0fffe17 	ldw	r3,-8(fp)
 3218960:	00800044 	movi	r2,1
 3218964:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 3218968:	e03fff15 	stw	zero,-4(fp)
 321896c:	00001306 	br	32189bc <OSFlagQuery+0xc0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3218970:	0005303a 	rdctl	r2,status
 3218974:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3218978:	e0fffa17 	ldw	r3,-24(fp)
 321897c:	00bfff84 	movi	r2,-2
 3218980:	1884703a 	and	r2,r3,r2
 3218984:	1001703a 	wrctl	status,r2
  
  return context;
 3218988:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 321898c:	e0bffb15 	stw	r2,-20(fp)
    flags = pgrp->OSFlagFlags;
 3218990:	e0bffd17 	ldw	r2,-12(fp)
 3218994:	1080020b 	ldhu	r2,8(r2)
 3218998:	e0bffc0d 	sth	r2,-16(fp)
 321899c:	e0bffb17 	ldw	r2,-20(fp)
 32189a0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 32189a4:	e0bff917 	ldw	r2,-28(fp)
 32189a8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 32189ac:	e0bffe17 	ldw	r2,-8(fp)
 32189b0:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
 32189b4:	e0bffc0b 	ldhu	r2,-16(fp)
 32189b8:	e0bfff15 	stw	r2,-4(fp)
 32189bc:	e0bfff17 	ldw	r2,-4(fp)
}
 32189c0:	e037883a 	mov	sp,fp
 32189c4:	df000017 	ldw	fp,0(sp)
 32189c8:	dec00104 	addi	sp,sp,4
 32189cc:	f800283a 	ret

032189d0 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
 32189d0:	defff804 	addi	sp,sp,-32
 32189d4:	df000715 	stw	fp,28(sp)
 32189d8:	df000704 	addi	fp,sp,28
 32189dc:	e13ffb15 	stw	r4,-20(fp)
 32189e0:	e17ffc15 	stw	r5,-16(fp)
 32189e4:	e0800117 	ldw	r2,4(fp)
 32189e8:	e1bffd0d 	sth	r6,-12(fp)
 32189ec:	e1fffe05 	stb	r7,-8(fp)
 32189f0:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
 32189f4:	0080c974 	movhi	r2,805
 32189f8:	10922a04 	addi	r2,r2,18600
 32189fc:	10c00017 	ldw	r3,0(r2)
 3218a00:	0080c974 	movhi	r2,805
 3218a04:	10922a04 	addi	r2,r2,18600
 3218a08:	10800017 	ldw	r2,0(r2)
 3218a0c:	10800c03 	ldbu	r2,48(r2)
 3218a10:	10800814 	ori	r2,r2,32
 3218a14:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
 3218a18:	0080c974 	movhi	r2,805
 3218a1c:	10922a04 	addi	r2,r2,18600
 3218a20:	10800017 	ldw	r2,0(r2)
 3218a24:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
 3218a28:	0080c974 	movhi	r2,805
 3218a2c:	10922a04 	addi	r2,r2,18600
 3218a30:	10c00017 	ldw	r3,0(r2)
 3218a34:	e0bfff0b 	ldhu	r2,-4(fp)
 3218a38:	18800b8d 	sth	r2,46(r3)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
 3218a3c:	0080c974 	movhi	r2,805
 3218a40:	10922a04 	addi	r2,r2,18600
 3218a44:	10c00017 	ldw	r3,0(r2)
 3218a48:	e0bffc17 	ldw	r2,-16(fp)
 3218a4c:	18800a15 	stw	r2,40(r3)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
 3218a50:	e0fffc17 	ldw	r3,-16(fp)
 3218a54:	e0bffd0b 	ldhu	r2,-12(fp)
 3218a58:	1880040d 	sth	r2,16(r3)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
 3218a5c:	e0fffc17 	ldw	r3,-16(fp)
 3218a60:	e0bffe03 	ldbu	r2,-8(fp)
 3218a64:	18800485 	stb	r2,18(r3)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
 3218a68:	0080c974 	movhi	r2,805
 3218a6c:	10922a04 	addi	r2,r2,18600
 3218a70:	10c00017 	ldw	r3,0(r2)
 3218a74:	e0bffc17 	ldw	r2,-16(fp)
 3218a78:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
 3218a7c:	e0bffb17 	ldw	r2,-20(fp)
 3218a80:	10c00117 	ldw	r3,4(r2)
 3218a84:	e0bffc17 	ldw	r2,-16(fp)
 3218a88:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
 3218a8c:	e0bffc17 	ldw	r2,-16(fp)
 3218a90:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
 3218a94:	e0fffc17 	ldw	r3,-16(fp)
 3218a98:	e0bffb17 	ldw	r2,-20(fp)
 3218a9c:	18800315 	stw	r2,12(r3)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 3218aa0:	e0bffb17 	ldw	r2,-20(fp)
 3218aa4:	10800117 	ldw	r2,4(r2)
 3218aa8:	e0bffa15 	stw	r2,-24(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
 3218aac:	e0bffa17 	ldw	r2,-24(fp)
 3218ab0:	1005003a 	cmpeq	r2,r2,zero
 3218ab4:	1000031e 	bne	r2,zero,3218ac4 <OS_FlagBlock+0xf4>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
 3218ab8:	e0fffa17 	ldw	r3,-24(fp)
 3218abc:	e0bffc17 	ldw	r2,-16(fp)
 3218ac0:	18800115 	stw	r2,4(r3)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
 3218ac4:	e0fffb17 	ldw	r3,-20(fp)
 3218ac8:	e0bffc17 	ldw	r2,-16(fp)
 3218acc:	18800115 	stw	r2,4(r3)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
 3218ad0:	0080c974 	movhi	r2,805
 3218ad4:	10922a04 	addi	r2,r2,18600
 3218ad8:	10800017 	ldw	r2,0(r2)
 3218adc:	10800d03 	ldbu	r2,52(r2)
 3218ae0:	e0bff905 	stb	r2,-28(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 3218ae4:	e13ff903 	ldbu	r4,-28(fp)
 3218ae8:	e0fff903 	ldbu	r3,-28(fp)
 3218aec:	0080c974 	movhi	r2,805
 3218af0:	10922744 	addi	r2,r2,18589
 3218af4:	10c5883a 	add	r2,r2,r3
 3218af8:	10800003 	ldbu	r2,0(r2)
 3218afc:	1007883a 	mov	r3,r2
 3218b00:	0080c974 	movhi	r2,805
 3218b04:	10922a04 	addi	r2,r2,18600
 3218b08:	10800017 	ldw	r2,0(r2)
 3218b0c:	10800d43 	ldbu	r2,53(r2)
 3218b10:	0084303a 	nor	r2,zero,r2
 3218b14:	1884703a 	and	r2,r3,r2
 3218b18:	1007883a 	mov	r3,r2
 3218b1c:	0080c974 	movhi	r2,805
 3218b20:	10922744 	addi	r2,r2,18589
 3218b24:	1105883a 	add	r2,r2,r4
 3218b28:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0x00) {
 3218b2c:	e0fff903 	ldbu	r3,-28(fp)
 3218b30:	0080c974 	movhi	r2,805
 3218b34:	10922744 	addi	r2,r2,18589
 3218b38:	10c5883a 	add	r2,r2,r3
 3218b3c:	10800003 	ldbu	r2,0(r2)
 3218b40:	10803fcc 	andi	r2,r2,255
 3218b44:	1004c03a 	cmpne	r2,r2,zero
 3218b48:	10000e1e 	bne	r2,zero,3218b84 <OS_FlagBlock+0x1b4>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 3218b4c:	0080c974 	movhi	r2,805
 3218b50:	10922a04 	addi	r2,r2,18600
 3218b54:	10800017 	ldw	r2,0(r2)
 3218b58:	10800d83 	ldbu	r2,54(r2)
 3218b5c:	0084303a 	nor	r2,zero,r2
 3218b60:	1007883a 	mov	r3,r2
 3218b64:	0080c974 	movhi	r2,805
 3218b68:	10922704 	addi	r2,r2,18588
 3218b6c:	10800003 	ldbu	r2,0(r2)
 3218b70:	1884703a 	and	r2,r3,r2
 3218b74:	1007883a 	mov	r3,r2
 3218b78:	0080c974 	movhi	r2,805
 3218b7c:	10922704 	addi	r2,r2,18588
 3218b80:	10c00005 	stb	r3,0(r2)
    }
}
 3218b84:	e037883a 	mov	sp,fp
 3218b88:	df000017 	ldw	fp,0(sp)
 3218b8c:	dec00104 	addi	sp,sp,4
 3218b90:	f800283a 	ret

03218b94 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
 3218b94:	defffb04 	addi	sp,sp,-20
 3218b98:	dfc00415 	stw	ra,16(sp)
 3218b9c:	df000315 	stw	fp,12(sp)
 3218ba0:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
 3218ba4:	0100c9b4 	movhi	r4,806
 3218ba8:	21250c04 	addi	r4,r4,-27600
 3218bac:	0140dc04 	movi	r5,880
 3218bb0:	3216bc40 	call	3216bc4 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
 3218bb4:	0080c9b4 	movhi	r2,806
 3218bb8:	10a50c04 	addi	r2,r2,-27600
 3218bbc:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
 3218bc0:	0080c9b4 	movhi	r2,806
 3218bc4:	10a51704 	addi	r2,r2,-27556
 3218bc8:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 3218bcc:	e03fff0d 	sth	zero,-4(fp)
 3218bd0:	00001306 	br	3218c20 <OS_FlagInit+0x8c>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 3218bd4:	e0bffe17 	ldw	r2,-8(fp)
 3218bd8:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
 3218bdc:	e0fffe17 	ldw	r3,-8(fp)
 3218be0:	e0bffd17 	ldw	r2,-12(fp)
 3218be4:	18800115 	stw	r2,4(r3)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
 3218be8:	e0fffe17 	ldw	r3,-8(fp)
 3218bec:	00800fc4 	movi	r2,63
 3218bf0:	18800285 	stb	r2,10(r3)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 3218bf4:	e0bffe17 	ldw	r2,-8(fp)
 3218bf8:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
 3218bfc:	e0bffe17 	ldw	r2,-8(fp)
 3218c00:	10800b04 	addi	r2,r2,44
 3218c04:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
 3218c08:	e0bffd17 	ldw	r2,-12(fp)
 3218c0c:	10800b04 	addi	r2,r2,44
 3218c10:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 3218c14:	e0bfff0b 	ldhu	r2,-4(fp)
 3218c18:	10800044 	addi	r2,r2,1
 3218c1c:	e0bfff0d 	sth	r2,-4(fp)
 3218c20:	e0bfff0b 	ldhu	r2,-4(fp)
 3218c24:	108004f0 	cmpltui	r2,r2,19
 3218c28:	103fea1e 	bne	r2,zero,3218bd4 <OS_FlagInit+0x40>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 3218c2c:	e0bffe17 	ldw	r2,-8(fp)
 3218c30:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
 3218c34:	e0bffe17 	ldw	r2,-8(fp)
 3218c38:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
 3218c3c:	e0fffe17 	ldw	r3,-8(fp)
 3218c40:	00800fc4 	movi	r2,63
 3218c44:	18800285 	stb	r2,10(r3)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 3218c48:	e0bffe17 	ldw	r2,-8(fp)
 3218c4c:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
 3218c50:	00c0c974 	movhi	r3,805
 3218c54:	18d22c04 	addi	r3,r3,18608
 3218c58:	0080c9b4 	movhi	r2,806
 3218c5c:	10a50c04 	addi	r2,r2,-27600
 3218c60:	18800015 	stw	r2,0(r3)
#endif
}
 3218c64:	e037883a 	mov	sp,fp
 3218c68:	dfc00117 	ldw	ra,4(sp)
 3218c6c:	df000017 	ldw	fp,0(sp)
 3218c70:	dec00204 	addi	sp,sp,8
 3218c74:	f800283a 	ret

03218c78 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
 3218c78:	defffa04 	addi	sp,sp,-24
 3218c7c:	dfc00515 	stw	ra,20(sp)
 3218c80:	df000415 	stw	fp,16(sp)
 3218c84:	df000404 	addi	fp,sp,16
 3218c88:	e13ffe15 	stw	r4,-8(fp)
 3218c8c:	e17fff0d 	sth	r5,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
 3218c90:	e0bffe17 	ldw	r2,-8(fp)
 3218c94:	10800217 	ldw	r2,8(r2)
 3218c98:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
 3218c9c:	e0bffd17 	ldw	r2,-12(fp)
 3218ca0:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
 3218ca4:	e0fffd17 	ldw	r3,-12(fp)
 3218ca8:	e0bfff0b 	ldhu	r2,-4(fp)
 3218cac:	18800b0d 	sth	r2,44(r3)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
 3218cb0:	e0bffd17 	ldw	r2,-12(fp)
 3218cb4:	10c00c03 	ldbu	r3,48(r2)
 3218cb8:	00bff7c4 	movi	r2,-33
 3218cbc:	1884703a 	and	r2,r3,r2
 3218cc0:	1007883a 	mov	r3,r2
 3218cc4:	e0bffd17 	ldw	r2,-12(fp)
 3218cc8:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
 3218ccc:	e0bffd17 	ldw	r2,-12(fp)
 3218cd0:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
 3218cd4:	e0bffd17 	ldw	r2,-12(fp)
 3218cd8:	10800c03 	ldbu	r2,48(r2)
 3218cdc:	10803fcc 	andi	r2,r2,255
 3218ce0:	1004c03a 	cmpne	r2,r2,zero
 3218ce4:	10001f1e 	bne	r2,zero,3218d64 <OS_FlagTaskRdy+0xec>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
 3218ce8:	e0bffd17 	ldw	r2,-12(fp)
 3218cec:	10c00d83 	ldbu	r3,54(r2)
 3218cf0:	0080c974 	movhi	r2,805
 3218cf4:	10922704 	addi	r2,r2,18588
 3218cf8:	10800003 	ldbu	r2,0(r2)
 3218cfc:	1884b03a 	or	r2,r3,r2
 3218d00:	1007883a 	mov	r3,r2
 3218d04:	0080c974 	movhi	r2,805
 3218d08:	10922704 	addi	r2,r2,18588
 3218d0c:	10c00005 	stb	r3,0(r2)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 3218d10:	e0bffd17 	ldw	r2,-12(fp)
 3218d14:	10800d03 	ldbu	r2,52(r2)
 3218d18:	11003fcc 	andi	r4,r2,255
 3218d1c:	e0bffd17 	ldw	r2,-12(fp)
 3218d20:	10800d03 	ldbu	r2,52(r2)
 3218d24:	10c03fcc 	andi	r3,r2,255
 3218d28:	0080c974 	movhi	r2,805
 3218d2c:	10922744 	addi	r2,r2,18589
 3218d30:	10c5883a 	add	r2,r2,r3
 3218d34:	10c00003 	ldbu	r3,0(r2)
 3218d38:	e0bffd17 	ldw	r2,-12(fp)
 3218d3c:	10800d43 	ldbu	r2,53(r2)
 3218d40:	1884b03a 	or	r2,r3,r2
 3218d44:	1007883a 	mov	r3,r2
 3218d48:	0080c974 	movhi	r2,805
 3218d4c:	10922744 	addi	r2,r2,18589
 3218d50:	1105883a 	add	r2,r2,r4
 3218d54:	10c00005 	stb	r3,0(r2)
        sched                   = OS_TRUE;
 3218d58:	00800044 	movi	r2,1
 3218d5c:	e0bffc05 	stb	r2,-16(fp)
 3218d60:	00000106 	br	3218d68 <OS_FlagTaskRdy+0xf0>
    } else {
        sched                   = OS_FALSE;
 3218d64:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
 3218d68:	e13ffe17 	ldw	r4,-8(fp)
 3218d6c:	3218d880 	call	3218d88 <OS_FlagUnlink>
    return (sched);
 3218d70:	e0bffc03 	ldbu	r2,-16(fp)
}
 3218d74:	e037883a 	mov	sp,fp
 3218d78:	dfc00117 	ldw	ra,4(sp)
 3218d7c:	df000017 	ldw	fp,0(sp)
 3218d80:	dec00204 	addi	sp,sp,8
 3218d84:	f800283a 	ret

03218d88 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
 3218d88:	defffa04 	addi	sp,sp,-24
 3218d8c:	df000515 	stw	fp,20(sp)
 3218d90:	df000504 	addi	fp,sp,20
 3218d94:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
 3218d98:	e0bfff17 	ldw	r2,-4(fp)
 3218d9c:	10800117 	ldw	r2,4(r2)
 3218da0:	e0bffc15 	stw	r2,-16(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 3218da4:	e0bfff17 	ldw	r2,-4(fp)
 3218da8:	10800017 	ldw	r2,0(r2)
 3218dac:	e0bffb15 	stw	r2,-20(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
 3218db0:	e0bffc17 	ldw	r2,-16(fp)
 3218db4:	1004c03a 	cmpne	r2,r2,zero
 3218db8:	10000c1e 	bne	r2,zero,3218dec <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
 3218dbc:	e0bfff17 	ldw	r2,-4(fp)
 3218dc0:	10800317 	ldw	r2,12(r2)
 3218dc4:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
 3218dc8:	e0fffd17 	ldw	r3,-12(fp)
 3218dcc:	e0bffb17 	ldw	r2,-20(fp)
 3218dd0:	18800115 	stw	r2,4(r3)
        if (pnode_next != (OS_FLAG_NODE *)0) {
 3218dd4:	e0bffb17 	ldw	r2,-20(fp)
 3218dd8:	1005003a 	cmpeq	r2,r2,zero
 3218ddc:	10000c1e 	bne	r2,zero,3218e10 <OS_FlagUnlink+0x88>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
 3218de0:	e0bffb17 	ldw	r2,-20(fp)
 3218de4:	10000115 	stw	zero,4(r2)
 3218de8:	00000906 	br	3218e10 <OS_FlagUnlink+0x88>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
 3218dec:	e0fffc17 	ldw	r3,-16(fp)
 3218df0:	e0bffb17 	ldw	r2,-20(fp)
 3218df4:	18800015 	stw	r2,0(r3)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
 3218df8:	e0bffb17 	ldw	r2,-20(fp)
 3218dfc:	1005003a 	cmpeq	r2,r2,zero
 3218e00:	1000031e 	bne	r2,zero,3218e10 <OS_FlagUnlink+0x88>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
 3218e04:	e0fffb17 	ldw	r3,-20(fp)
 3218e08:	e0bffc17 	ldw	r2,-16(fp)
 3218e0c:	18800115 	stw	r2,4(r3)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
 3218e10:	e0bfff17 	ldw	r2,-4(fp)
 3218e14:	10800217 	ldw	r2,8(r2)
 3218e18:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
 3218e1c:	e0bffe17 	ldw	r2,-8(fp)
 3218e20:	10000a15 	stw	zero,40(r2)
#endif
}
 3218e24:	e037883a 	mov	sp,fp
 3218e28:	df000017 	ldw	fp,0(sp)
 3218e2c:	dec00104 	addi	sp,sp,4
 3218e30:	f800283a 	ret

03218e34 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
 3218e34:	defff304 	addi	sp,sp,-52
 3218e38:	df000c15 	stw	fp,48(sp)
 3218e3c:	df000c04 	addi	fp,sp,48
 3218e40:	e13ffb15 	stw	r4,-20(fp)
 3218e44:	e17ffc15 	stw	r5,-16(fp)
 3218e48:	e1bffd15 	stw	r6,-12(fp)
 3218e4c:	e1fffe15 	stw	r7,-8(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 3218e50:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 3218e54:	e0bffe17 	ldw	r2,-8(fp)
 3218e58:	1004c03a 	cmpne	r2,r2,zero
 3218e5c:	1000021e 	bne	r2,zero,3218e68 <OSMemCreate+0x34>
        return ((OS_MEM *)0);
 3218e60:	e03fff15 	stw	zero,-4(fp)
 3218e64:	00007506 	br	321903c <OSMemCreate+0x208>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
 3218e68:	e0bffb17 	ldw	r2,-20(fp)
 3218e6c:	1004c03a 	cmpne	r2,r2,zero
 3218e70:	1000051e 	bne	r2,zero,3218e88 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 3218e74:	e0fffe17 	ldw	r3,-8(fp)
 3218e78:	00801884 	movi	r2,98
 3218e7c:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 3218e80:	e03fff15 	stw	zero,-4(fp)
 3218e84:	00006d06 	br	321903c <OSMemCreate+0x208>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
 3218e88:	e0bffb17 	ldw	r2,-20(fp)
 3218e8c:	108000cc 	andi	r2,r2,3
 3218e90:	1005003a 	cmpeq	r2,r2,zero
 3218e94:	1000051e 	bne	r2,zero,3218eac <OSMemCreate+0x78>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 3218e98:	e0fffe17 	ldw	r3,-8(fp)
 3218e9c:	00801884 	movi	r2,98
 3218ea0:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 3218ea4:	e03fff15 	stw	zero,-4(fp)
 3218ea8:	00006406 	br	321903c <OSMemCreate+0x208>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
 3218eac:	e0bffc17 	ldw	r2,-16(fp)
 3218eb0:	108000a8 	cmpgeui	r2,r2,2
 3218eb4:	1000051e 	bne	r2,zero,3218ecc <OSMemCreate+0x98>
        *perr = OS_ERR_MEM_INVALID_BLKS;
 3218eb8:	e0fffe17 	ldw	r3,-8(fp)
 3218ebc:	008016c4 	movi	r2,91
 3218ec0:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 3218ec4:	e03fff15 	stw	zero,-4(fp)
 3218ec8:	00005c06 	br	321903c <OSMemCreate+0x208>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
 3218ecc:	e0bffd17 	ldw	r2,-12(fp)
 3218ed0:	10800128 	cmpgeui	r2,r2,4
 3218ed4:	1000051e 	bne	r2,zero,3218eec <OSMemCreate+0xb8>
        *perr = OS_ERR_MEM_INVALID_SIZE;
 3218ed8:	e0fffe17 	ldw	r3,-8(fp)
 3218edc:	00801704 	movi	r2,92
 3218ee0:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 3218ee4:	e03fff15 	stw	zero,-4(fp)
 3218ee8:	00005406 	br	321903c <OSMemCreate+0x208>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3218eec:	0005303a 	rdctl	r2,status
 3218ef0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3218ef4:	e0fff517 	ldw	r3,-44(fp)
 3218ef8:	00bfff84 	movi	r2,-2
 3218efc:	1884703a 	and	r2,r3,r2
 3218f00:	1001703a 	wrctl	status,r2
  
  return context;
 3218f04:	e0bff517 	ldw	r2,-44(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 3218f08:	e0bff615 	stw	r2,-40(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
 3218f0c:	0080c974 	movhi	r2,805
 3218f10:	10922404 	addi	r2,r2,18576
 3218f14:	10800017 	ldw	r2,0(r2)
 3218f18:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
 3218f1c:	0080c974 	movhi	r2,805
 3218f20:	10922404 	addi	r2,r2,18576
 3218f24:	10800017 	ldw	r2,0(r2)
 3218f28:	1005003a 	cmpeq	r2,r2,zero
 3218f2c:	1000081e 	bne	r2,zero,3218f50 <OSMemCreate+0x11c>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
 3218f30:	0080c974 	movhi	r2,805
 3218f34:	10922404 	addi	r2,r2,18576
 3218f38:	10800017 	ldw	r2,0(r2)
 3218f3c:	10800117 	ldw	r2,4(r2)
 3218f40:	1007883a 	mov	r3,r2
 3218f44:	0080c974 	movhi	r2,805
 3218f48:	10922404 	addi	r2,r2,18576
 3218f4c:	10c00015 	stw	r3,0(r2)
 3218f50:	e0bff617 	ldw	r2,-40(fp)
 3218f54:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3218f58:	e0bff417 	ldw	r2,-48(fp)
 3218f5c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
 3218f60:	e0bffa17 	ldw	r2,-24(fp)
 3218f64:	1004c03a 	cmpne	r2,r2,zero
 3218f68:	1000051e 	bne	r2,zero,3218f80 <OSMemCreate+0x14c>
        *perr = OS_ERR_MEM_INVALID_PART;
 3218f6c:	e0fffe17 	ldw	r3,-8(fp)
 3218f70:	00801684 	movi	r2,90
 3218f74:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 3218f78:	e03fff15 	stw	zero,-4(fp)
 3218f7c:	00002f06 	br	321903c <OSMemCreate+0x208>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
 3218f80:	e0bffb17 	ldw	r2,-20(fp)
 3218f84:	e0bff815 	stw	r2,-32(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
 3218f88:	e0bffb17 	ldw	r2,-20(fp)
 3218f8c:	1007883a 	mov	r3,r2
 3218f90:	e0bffd17 	ldw	r2,-12(fp)
 3218f94:	1885883a 	add	r2,r3,r2
 3218f98:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < (nblks - 1); i++) {
 3218f9c:	e03ff715 	stw	zero,-36(fp)
 3218fa0:	00000d06 	br	3218fd8 <OSMemCreate+0x1a4>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
 3218fa4:	e0fff817 	ldw	r3,-32(fp)
 3218fa8:	e0bff917 	ldw	r2,-28(fp)
 3218fac:	18800015 	stw	r2,0(r3)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
 3218fb0:	e0bff917 	ldw	r2,-28(fp)
 3218fb4:	e0bff815 	stw	r2,-32(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
 3218fb8:	e0bff917 	ldw	r2,-28(fp)
 3218fbc:	1007883a 	mov	r3,r2
 3218fc0:	e0bffd17 	ldw	r2,-12(fp)
 3218fc4:	1885883a 	add	r2,r3,r2
 3218fc8:	e0bff915 	stw	r2,-28(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
 3218fcc:	e0bff717 	ldw	r2,-36(fp)
 3218fd0:	10800044 	addi	r2,r2,1
 3218fd4:	e0bff715 	stw	r2,-36(fp)
 3218fd8:	e0bffc17 	ldw	r2,-16(fp)
 3218fdc:	10ffffc4 	addi	r3,r2,-1
 3218fe0:	e0bff717 	ldw	r2,-36(fp)
 3218fe4:	10ffef36 	bltu	r2,r3,3218fa4 <OSMemCreate+0x170>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
 3218fe8:	e0bff817 	ldw	r2,-32(fp)
 3218fec:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
 3218ff0:	e0fffa17 	ldw	r3,-24(fp)
 3218ff4:	e0bffb17 	ldw	r2,-20(fp)
 3218ff8:	18800015 	stw	r2,0(r3)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
 3218ffc:	e0fffa17 	ldw	r3,-24(fp)
 3219000:	e0bffb17 	ldw	r2,-20(fp)
 3219004:	18800115 	stw	r2,4(r3)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
 3219008:	e0fffa17 	ldw	r3,-24(fp)
 321900c:	e0bffc17 	ldw	r2,-16(fp)
 3219010:	18800415 	stw	r2,16(r3)
    pmem->OSMemNBlks    = nblks;
 3219014:	e0fffa17 	ldw	r3,-24(fp)
 3219018:	e0bffc17 	ldw	r2,-16(fp)
 321901c:	18800315 	stw	r2,12(r3)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
 3219020:	e0fffa17 	ldw	r3,-24(fp)
 3219024:	e0bffd17 	ldw	r2,-12(fp)
 3219028:	18800215 	stw	r2,8(r3)
    *perr               = OS_ERR_NONE;
 321902c:	e0bffe17 	ldw	r2,-8(fp)
 3219030:	10000005 	stb	zero,0(r2)
    return (pmem);
 3219034:	e0bffa17 	ldw	r2,-24(fp)
 3219038:	e0bfff15 	stw	r2,-4(fp)
 321903c:	e0bfff17 	ldw	r2,-4(fp)
}
 3219040:	e037883a 	mov	sp,fp
 3219044:	df000017 	ldw	fp,0(sp)
 3219048:	dec00104 	addi	sp,sp,4
 321904c:	f800283a 	ret

03219050 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
 3219050:	defff704 	addi	sp,sp,-36
 3219054:	df000815 	stw	fp,32(sp)
 3219058:	df000804 	addi	fp,sp,32
 321905c:	e13ffd15 	stw	r4,-12(fp)
 3219060:	e17ffe15 	stw	r5,-8(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 3219064:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 3219068:	e0bffe17 	ldw	r2,-8(fp)
 321906c:	1004c03a 	cmpne	r2,r2,zero
 3219070:	1000021e 	bne	r2,zero,321907c <OSMemGet+0x2c>
        return ((void *)0);
 3219074:	e03fff15 	stw	zero,-4(fp)
 3219078:	00003106 	br	3219140 <OSMemGet+0xf0>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
 321907c:	e0bffd17 	ldw	r2,-12(fp)
 3219080:	1004c03a 	cmpne	r2,r2,zero
 3219084:	1000051e 	bne	r2,zero,321909c <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 3219088:	e0fffe17 	ldw	r3,-8(fp)
 321908c:	00801804 	movi	r2,96
 3219090:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 3219094:	e03fff15 	stw	zero,-4(fp)
 3219098:	00002906 	br	3219140 <OSMemGet+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321909c:	0005303a 	rdctl	r2,status
 32190a0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32190a4:	e0fffa17 	ldw	r3,-24(fp)
 32190a8:	00bfff84 	movi	r2,-2
 32190ac:	1884703a 	and	r2,r3,r2
 32190b0:	1001703a 	wrctl	status,r2
  
  return context;
 32190b4:	e0bffa17 	ldw	r2,-24(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 32190b8:	e0bffb15 	stw	r2,-20(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
 32190bc:	e0bffd17 	ldw	r2,-12(fp)
 32190c0:	10800417 	ldw	r2,16(r2)
 32190c4:	1005003a 	cmpeq	r2,r2,zero
 32190c8:	1000151e 	bne	r2,zero,3219120 <OSMemGet+0xd0>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
 32190cc:	e0bffd17 	ldw	r2,-12(fp)
 32190d0:	10800117 	ldw	r2,4(r2)
 32190d4:	e0bffc15 	stw	r2,-16(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
 32190d8:	e0bffc17 	ldw	r2,-16(fp)
 32190dc:	10c00017 	ldw	r3,0(r2)
 32190e0:	e0bffd17 	ldw	r2,-12(fp)
 32190e4:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
 32190e8:	e0bffd17 	ldw	r2,-12(fp)
 32190ec:	10800417 	ldw	r2,16(r2)
 32190f0:	10ffffc4 	addi	r3,r2,-1
 32190f4:	e0bffd17 	ldw	r2,-12(fp)
 32190f8:	10c00415 	stw	r3,16(r2)
 32190fc:	e0bffb17 	ldw	r2,-20(fp)
 3219100:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3219104:	e0bff917 	ldw	r2,-28(fp)
 3219108:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
 321910c:	e0bffe17 	ldw	r2,-8(fp)
 3219110:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
 3219114:	e0bffc17 	ldw	r2,-16(fp)
 3219118:	e0bfff15 	stw	r2,-4(fp)
 321911c:	00000806 	br	3219140 <OSMemGet+0xf0>
 3219120:	e0bffb17 	ldw	r2,-20(fp)
 3219124:	e0bff815 	stw	r2,-32(fp)
 3219128:	e0bff817 	ldw	r2,-32(fp)
 321912c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
 3219130:	e0fffe17 	ldw	r3,-8(fp)
 3219134:	00801744 	movi	r2,93
 3219138:	18800005 	stb	r2,0(r3)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
 321913c:	e03fff15 	stw	zero,-4(fp)
 3219140:	e0bfff17 	ldw	r2,-4(fp)
}
 3219144:	e037883a 	mov	sp,fp
 3219148:	df000017 	ldw	fp,0(sp)
 321914c:	dec00104 	addi	sp,sp,4
 3219150:	f800283a 	ret

03219154 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 3219154:	defff604 	addi	sp,sp,-40
 3219158:	dfc00915 	stw	ra,36(sp)
 321915c:	df000815 	stw	fp,32(sp)
 3219160:	df000804 	addi	fp,sp,32
 3219164:	e13ffc15 	stw	r4,-16(fp)
 3219168:	e17ffd15 	stw	r5,-12(fp)
 321916c:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3219170:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 3219174:	e0bffe17 	ldw	r2,-8(fp)
 3219178:	1004c03a 	cmpne	r2,r2,zero
 321917c:	1000021e 	bne	r2,zero,3219188 <OSMemNameGet+0x34>
        return (0);
 3219180:	e03fff15 	stw	zero,-4(fp)
 3219184:	00003006 	br	3219248 <OSMemNameGet+0xf4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 3219188:	e0bffc17 	ldw	r2,-16(fp)
 321918c:	1004c03a 	cmpne	r2,r2,zero
 3219190:	1000051e 	bne	r2,zero,32191a8 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 3219194:	e0fffe17 	ldw	r3,-8(fp)
 3219198:	00801804 	movi	r2,96
 321919c:	18800005 	stb	r2,0(r3)
        return (0);
 32191a0:	e03fff15 	stw	zero,-4(fp)
 32191a4:	00002806 	br	3219248 <OSMemNameGet+0xf4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 32191a8:	e0bffd17 	ldw	r2,-12(fp)
 32191ac:	1004c03a 	cmpne	r2,r2,zero
 32191b0:	1000051e 	bne	r2,zero,32191c8 <OSMemNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 32191b4:	e0fffe17 	ldw	r3,-8(fp)
 32191b8:	00800304 	movi	r2,12
 32191bc:	18800005 	stb	r2,0(r3)
        return (0);
 32191c0:	e03fff15 	stw	zero,-4(fp)
 32191c4:	00002006 	br	3219248 <OSMemNameGet+0xf4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 32191c8:	0080c974 	movhi	r2,805
 32191cc:	10922904 	addi	r2,r2,18596
 32191d0:	10800003 	ldbu	r2,0(r2)
 32191d4:	10803fcc 	andi	r2,r2,255
 32191d8:	1005003a 	cmpeq	r2,r2,zero
 32191dc:	1000051e 	bne	r2,zero,32191f4 <OSMemNameGet+0xa0>
        *perr = OS_ERR_NAME_GET_ISR;
 32191e0:	e0fffe17 	ldw	r3,-8(fp)
 32191e4:	00800444 	movi	r2,17
 32191e8:	18800005 	stb	r2,0(r3)
        return (0);
 32191ec:	e03fff15 	stw	zero,-4(fp)
 32191f0:	00001506 	br	3219248 <OSMemNameGet+0xf4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32191f4:	0005303a 	rdctl	r2,status
 32191f8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32191fc:	e0fff917 	ldw	r3,-28(fp)
 3219200:	00bfff84 	movi	r2,-2
 3219204:	1884703a 	and	r2,r3,r2
 3219208:	1001703a 	wrctl	status,r2
  
  return context;
 321920c:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 3219210:	e0bffa15 	stw	r2,-24(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
 3219214:	e0bffc17 	ldw	r2,-16(fp)
 3219218:	11400504 	addi	r5,r2,20
 321921c:	e13ffd17 	ldw	r4,-12(fp)
 3219220:	3216dc80 	call	3216dc8 <OS_StrCopy>
 3219224:	e0bffb05 	stb	r2,-20(fp)
 3219228:	e0bffa17 	ldw	r2,-24(fp)
 321922c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3219230:	e0bff817 	ldw	r2,-32(fp)
 3219234:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 3219238:	e0bffe17 	ldw	r2,-8(fp)
 321923c:	10000005 	stb	zero,0(r2)
    return (len);
 3219240:	e0bffb03 	ldbu	r2,-20(fp)
 3219244:	e0bfff15 	stw	r2,-4(fp)
 3219248:	e0bfff17 	ldw	r2,-4(fp)
}
 321924c:	e037883a 	mov	sp,fp
 3219250:	dfc00117 	ldw	ra,4(sp)
 3219254:	df000017 	ldw	fp,0(sp)
 3219258:	dec00204 	addi	sp,sp,8
 321925c:	f800283a 	ret

03219260 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 3219260:	defff604 	addi	sp,sp,-40
 3219264:	dfc00915 	stw	ra,36(sp)
 3219268:	df000815 	stw	fp,32(sp)
 321926c:	df000804 	addi	fp,sp,32
 3219270:	e13ffd15 	stw	r4,-12(fp)
 3219274:	e17ffe15 	stw	r5,-8(fp)
 3219278:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 321927c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 3219280:	e0bfff17 	ldw	r2,-4(fp)
 3219284:	1005003a 	cmpeq	r2,r2,zero
 3219288:	1000381e 	bne	r2,zero,321936c <OSMemNameSet+0x10c>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 321928c:	e0bffd17 	ldw	r2,-12(fp)
 3219290:	1004c03a 	cmpne	r2,r2,zero
 3219294:	1000041e 	bne	r2,zero,32192a8 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 3219298:	e0ffff17 	ldw	r3,-4(fp)
 321929c:	00801804 	movi	r2,96
 32192a0:	18800005 	stb	r2,0(r3)
        return;
 32192a4:	00003106 	br	321936c <OSMemNameSet+0x10c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 32192a8:	e0bffe17 	ldw	r2,-8(fp)
 32192ac:	1004c03a 	cmpne	r2,r2,zero
 32192b0:	1000041e 	bne	r2,zero,32192c4 <OSMemNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 32192b4:	e0ffff17 	ldw	r3,-4(fp)
 32192b8:	00800304 	movi	r2,12
 32192bc:	18800005 	stb	r2,0(r3)
        return;
 32192c0:	00002a06 	br	321936c <OSMemNameSet+0x10c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 32192c4:	0080c974 	movhi	r2,805
 32192c8:	10922904 	addi	r2,r2,18596
 32192cc:	10800003 	ldbu	r2,0(r2)
 32192d0:	10803fcc 	andi	r2,r2,255
 32192d4:	1005003a 	cmpeq	r2,r2,zero
 32192d8:	1000041e 	bne	r2,zero,32192ec <OSMemNameSet+0x8c>
        *perr = OS_ERR_NAME_SET_ISR;
 32192dc:	e0ffff17 	ldw	r3,-4(fp)
 32192e0:	00800484 	movi	r2,18
 32192e4:	18800005 	stb	r2,0(r3)
        return;
 32192e8:	00002006 	br	321936c <OSMemNameSet+0x10c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32192ec:	0005303a 	rdctl	r2,status
 32192f0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32192f4:	e0fffa17 	ldw	r3,-24(fp)
 32192f8:	00bfff84 	movi	r2,-2
 32192fc:	1884703a 	and	r2,r3,r2
 3219300:	1001703a 	wrctl	status,r2
  
  return context;
 3219304:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 3219308:	e0bffb15 	stw	r2,-20(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 321930c:	e13ffe17 	ldw	r4,-8(fp)
 3219310:	3216e480 	call	3216e48 <OS_StrLen>
 3219314:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
 3219318:	e0bffc03 	ldbu	r2,-16(fp)
 321931c:	10800830 	cmpltui	r2,r2,32
 3219320:	1000081e 	bne	r2,zero,3219344 <OSMemNameSet+0xe4>
 3219324:	e0bffb17 	ldw	r2,-20(fp)
 3219328:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321932c:	e0bff917 	ldw	r2,-28(fp)
 3219330:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
 3219334:	e0ffff17 	ldw	r3,-4(fp)
 3219338:	008018c4 	movi	r2,99
 321933c:	18800005 	stb	r2,0(r3)
        return;
 3219340:	00000a06 	br	321936c <OSMemNameSet+0x10c>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
 3219344:	e0bffd17 	ldw	r2,-12(fp)
 3219348:	11000504 	addi	r4,r2,20
 321934c:	e17ffe17 	ldw	r5,-8(fp)
 3219350:	3216dc80 	call	3216dc8 <OS_StrCopy>
 3219354:	e0bffb17 	ldw	r2,-20(fp)
 3219358:	e0bff815 	stw	r2,-32(fp)
 321935c:	e0bff817 	ldw	r2,-32(fp)
 3219360:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 3219364:	e0bfff17 	ldw	r2,-4(fp)
 3219368:	10000005 	stb	zero,0(r2)
}
 321936c:	e037883a 	mov	sp,fp
 3219370:	dfc00117 	ldw	ra,4(sp)
 3219374:	df000017 	ldw	fp,0(sp)
 3219378:	dec00204 	addi	sp,sp,8
 321937c:	f800283a 	ret

03219380 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
 3219380:	defff804 	addi	sp,sp,-32
 3219384:	df000715 	stw	fp,28(sp)
 3219388:	df000704 	addi	fp,sp,28
 321938c:	e13ffd15 	stw	r4,-12(fp)
 3219390:	e17ffe15 	stw	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3219394:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 3219398:	e0bffd17 	ldw	r2,-12(fp)
 321939c:	1004c03a 	cmpne	r2,r2,zero
 32193a0:	1000031e 	bne	r2,zero,32193b0 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
 32193a4:	00801804 	movi	r2,96
 32193a8:	e0bfff15 	stw	r2,-4(fp)
 32193ac:	00002b06 	br	321945c <OSMemPut+0xdc>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
 32193b0:	e0bffe17 	ldw	r2,-8(fp)
 32193b4:	1004c03a 	cmpne	r2,r2,zero
 32193b8:	1000031e 	bne	r2,zero,32193c8 <OSMemPut+0x48>
        return (OS_ERR_MEM_INVALID_PBLK);
 32193bc:	008017c4 	movi	r2,95
 32193c0:	e0bfff15 	stw	r2,-4(fp)
 32193c4:	00002506 	br	321945c <OSMemPut+0xdc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32193c8:	0005303a 	rdctl	r2,status
 32193cc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32193d0:	e0fffb17 	ldw	r3,-20(fp)
 32193d4:	00bfff84 	movi	r2,-2
 32193d8:	1884703a 	and	r2,r3,r2
 32193dc:	1001703a 	wrctl	status,r2
  
  return context;
 32193e0:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 32193e4:	e0bffc15 	stw	r2,-16(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
 32193e8:	e0bffd17 	ldw	r2,-12(fp)
 32193ec:	10c00417 	ldw	r3,16(r2)
 32193f0:	e0bffd17 	ldw	r2,-12(fp)
 32193f4:	10800317 	ldw	r2,12(r2)
 32193f8:	18800736 	bltu	r3,r2,3219418 <OSMemPut+0x98>
 32193fc:	e0bffc17 	ldw	r2,-16(fp)
 3219400:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3219404:	e0bffa17 	ldw	r2,-24(fp)
 3219408:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
 321940c:	00801784 	movi	r2,94
 3219410:	e0bfff15 	stw	r2,-4(fp)
 3219414:	00001106 	br	321945c <OSMemPut+0xdc>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
 3219418:	e0fffe17 	ldw	r3,-8(fp)
 321941c:	e0bffd17 	ldw	r2,-12(fp)
 3219420:	10800117 	ldw	r2,4(r2)
 3219424:	18800015 	stw	r2,0(r3)
    pmem->OSMemFreeList = pblk;
 3219428:	e0fffd17 	ldw	r3,-12(fp)
 321942c:	e0bffe17 	ldw	r2,-8(fp)
 3219430:	18800115 	stw	r2,4(r3)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
 3219434:	e0bffd17 	ldw	r2,-12(fp)
 3219438:	10800417 	ldw	r2,16(r2)
 321943c:	10c00044 	addi	r3,r2,1
 3219440:	e0bffd17 	ldw	r2,-12(fp)
 3219444:	10c00415 	stw	r3,16(r2)
 3219448:	e0bffc17 	ldw	r2,-16(fp)
 321944c:	e0bff915 	stw	r2,-28(fp)
 3219450:	e0bff917 	ldw	r2,-28(fp)
 3219454:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
 3219458:	e03fff15 	stw	zero,-4(fp)
 321945c:	e0bfff17 	ldw	r2,-4(fp)
}
 3219460:	e037883a 	mov	sp,fp
 3219464:	df000017 	ldw	fp,0(sp)
 3219468:	dec00104 	addi	sp,sp,4
 321946c:	f800283a 	ret

03219470 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
 3219470:	defff904 	addi	sp,sp,-28
 3219474:	df000615 	stw	fp,24(sp)
 3219478:	df000604 	addi	fp,sp,24
 321947c:	e13ffd15 	stw	r4,-12(fp)
 3219480:	e17ffe15 	stw	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3219484:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 3219488:	e0bffd17 	ldw	r2,-12(fp)
 321948c:	1004c03a 	cmpne	r2,r2,zero
 3219490:	1000031e 	bne	r2,zero,32194a0 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
 3219494:	00801804 	movi	r2,96
 3219498:	e0bfff15 	stw	r2,-4(fp)
 321949c:	00002e06 	br	3219558 <OSMemQuery+0xe8>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
 32194a0:	e0bffe17 	ldw	r2,-8(fp)
 32194a4:	1004c03a 	cmpne	r2,r2,zero
 32194a8:	1000031e 	bne	r2,zero,32194b8 <OSMemQuery+0x48>
        return (OS_ERR_MEM_INVALID_PDATA);
 32194ac:	00801844 	movi	r2,97
 32194b0:	e0bfff15 	stw	r2,-4(fp)
 32194b4:	00002806 	br	3219558 <OSMemQuery+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32194b8:	0005303a 	rdctl	r2,status
 32194bc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32194c0:	e0fffb17 	ldw	r3,-20(fp)
 32194c4:	00bfff84 	movi	r2,-2
 32194c8:	1884703a 	and	r2,r3,r2
 32194cc:	1001703a 	wrctl	status,r2
  
  return context;
 32194d0:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 32194d4:	e0bffc15 	stw	r2,-16(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
 32194d8:	e0bffd17 	ldw	r2,-12(fp)
 32194dc:	10c00017 	ldw	r3,0(r2)
 32194e0:	e0bffe17 	ldw	r2,-8(fp)
 32194e4:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
 32194e8:	e0bffd17 	ldw	r2,-12(fp)
 32194ec:	10c00117 	ldw	r3,4(r2)
 32194f0:	e0bffe17 	ldw	r2,-8(fp)
 32194f4:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
 32194f8:	e0bffd17 	ldw	r2,-12(fp)
 32194fc:	10c00217 	ldw	r3,8(r2)
 3219500:	e0bffe17 	ldw	r2,-8(fp)
 3219504:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
 3219508:	e0bffd17 	ldw	r2,-12(fp)
 321950c:	10c00317 	ldw	r3,12(r2)
 3219510:	e0bffe17 	ldw	r2,-8(fp)
 3219514:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
 3219518:	e0bffd17 	ldw	r2,-12(fp)
 321951c:	10c00417 	ldw	r3,16(r2)
 3219520:	e0bffe17 	ldw	r2,-8(fp)
 3219524:	10c00415 	stw	r3,16(r2)
 3219528:	e0bffc17 	ldw	r2,-16(fp)
 321952c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3219530:	e0bffa17 	ldw	r2,-24(fp)
 3219534:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
 3219538:	e0bffe17 	ldw	r2,-8(fp)
 321953c:	10c00317 	ldw	r3,12(r2)
 3219540:	e0bffe17 	ldw	r2,-8(fp)
 3219544:	10800417 	ldw	r2,16(r2)
 3219548:	1887c83a 	sub	r3,r3,r2
 321954c:	e0bffe17 	ldw	r2,-8(fp)
 3219550:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
 3219554:	e03fff15 	stw	zero,-4(fp)
 3219558:	e0bfff17 	ldw	r2,-4(fp)
}
 321955c:	e037883a 	mov	sp,fp
 3219560:	df000017 	ldw	fp,0(sp)
 3219564:	dec00104 	addi	sp,sp,4
 3219568:	f800283a 	ret

0321956c <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
 321956c:	defffc04 	addi	sp,sp,-16
 3219570:	dfc00315 	stw	ra,12(sp)
 3219574:	df000215 	stw	fp,8(sp)
 3219578:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
 321957c:	0100c9b4 	movhi	r4,806
 3219580:	2125e804 	addi	r4,r4,-26720
 3219584:	01430c04 	movi	r5,3120
 3219588:	3216bc40 	call	3216bc4 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
 321958c:	0080c9b4 	movhi	r2,806
 3219590:	10a5e804 	addi	r2,r2,-26720
 3219594:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 3219598:	e03ffe0d 	sth	zero,-8(fp)
 321959c:	00001306 	br	32195ec <OS_MemInit+0x80>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
 32195a0:	e0bffe0b 	ldhu	r2,-8(fp)
 32195a4:	10800d24 	muli	r2,r2,52
 32195a8:	1007883a 	mov	r3,r2
 32195ac:	0080c9b4 	movhi	r2,806
 32195b0:	10a5f504 	addi	r2,r2,-26668
 32195b4:	1887883a 	add	r3,r3,r2
 32195b8:	e0bfff17 	ldw	r2,-4(fp)
 32195bc:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
 32195c0:	e0ffff17 	ldw	r3,-4(fp)
 32195c4:	00800fc4 	movi	r2,63
 32195c8:	18800505 	stb	r2,20(r3)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
 32195cc:	e0bfff17 	ldw	r2,-4(fp)
 32195d0:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
 32195d4:	e0bfff17 	ldw	r2,-4(fp)
 32195d8:	10800d04 	addi	r2,r2,52
 32195dc:	e0bfff15 	stw	r2,-4(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 32195e0:	e0bffe0b 	ldhu	r2,-8(fp)
 32195e4:	10800044 	addi	r2,r2,1
 32195e8:	e0bffe0d 	sth	r2,-8(fp)
 32195ec:	e0bffe0b 	ldhu	r2,-8(fp)
 32195f0:	10800ef0 	cmpltui	r2,r2,59
 32195f4:	103fea1e 	bne	r2,zero,32195a0 <OS_MemInit+0x34>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
 32195f8:	e0bfff17 	ldw	r2,-4(fp)
 32195fc:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
 3219600:	e0ffff17 	ldw	r3,-4(fp)
 3219604:	00800fc4 	movi	r2,63
 3219608:	18800505 	stb	r2,20(r3)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
 321960c:	e0bfff17 	ldw	r2,-4(fp)
 3219610:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
 3219614:	00c0c974 	movhi	r3,805
 3219618:	18d22404 	addi	r3,r3,18576
 321961c:	0080c9b4 	movhi	r2,806
 3219620:	10a5e804 	addi	r2,r2,-26720
 3219624:	18800015 	stw	r2,0(r3)
#endif
}
 3219628:	e037883a 	mov	sp,fp
 321962c:	dfc00117 	ldw	ra,4(sp)
 3219630:	df000017 	ldw	fp,0(sp)
 3219634:	dec00204 	addi	sp,sp,8
 3219638:	f800283a 	ret

0321963c <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
 321963c:	defff704 	addi	sp,sp,-36
 3219640:	df000815 	stw	fp,32(sp)
 3219644:	df000804 	addi	fp,sp,32
 3219648:	e13ffd15 	stw	r4,-12(fp)
 321964c:	e17ffe15 	stw	r5,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3219650:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 3219654:	e0bffe17 	ldw	r2,-8(fp)
 3219658:	1004c03a 	cmpne	r2,r2,zero
 321965c:	1000021e 	bne	r2,zero,3219668 <OSQAccept+0x2c>
        return ((void *)0);
 3219660:	e03fff15 	stw	zero,-4(fp)
 3219664:	00004506 	br	321977c <OSQAccept+0x140>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 3219668:	e0bffd17 	ldw	r2,-12(fp)
 321966c:	1004c03a 	cmpne	r2,r2,zero
 3219670:	1000051e 	bne	r2,zero,3219688 <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
 3219674:	e0fffe17 	ldw	r3,-8(fp)
 3219678:	00800104 	movi	r2,4
 321967c:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 3219680:	e03fff15 	stw	zero,-4(fp)
 3219684:	00003d06 	br	321977c <OSQAccept+0x140>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 3219688:	e0bffd17 	ldw	r2,-12(fp)
 321968c:	10800003 	ldbu	r2,0(r2)
 3219690:	10803fcc 	andi	r2,r2,255
 3219694:	108000a0 	cmpeqi	r2,r2,2
 3219698:	1000051e 	bne	r2,zero,32196b0 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
 321969c:	e0fffe17 	ldw	r3,-8(fp)
 32196a0:	00800044 	movi	r2,1
 32196a4:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 32196a8:	e03fff15 	stw	zero,-4(fp)
 32196ac:	00003306 	br	321977c <OSQAccept+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32196b0:	0005303a 	rdctl	r2,status
 32196b4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32196b8:	e0fff917 	ldw	r3,-28(fp)
 32196bc:	00bfff84 	movi	r2,-2
 32196c0:	1884703a 	and	r2,r3,r2
 32196c4:	1001703a 	wrctl	status,r2
  
  return context;
 32196c8:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 32196cc:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 32196d0:	e0bffd17 	ldw	r2,-12(fp)
 32196d4:	10800117 	ldw	r2,4(r2)
 32196d8:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 32196dc:	e0bffb17 	ldw	r2,-20(fp)
 32196e0:	1080058b 	ldhu	r2,22(r2)
 32196e4:	10bfffcc 	andi	r2,r2,65535
 32196e8:	1005003a 	cmpeq	r2,r2,zero
 32196ec:	1000191e 	bne	r2,zero,3219754 <OSQAccept+0x118>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 32196f0:	e0bffb17 	ldw	r2,-20(fp)
 32196f4:	10c00417 	ldw	r3,16(r2)
 32196f8:	18800017 	ldw	r2,0(r3)
 32196fc:	e0bffc15 	stw	r2,-16(fp)
 3219700:	18c00104 	addi	r3,r3,4
 3219704:	e0bffb17 	ldw	r2,-20(fp)
 3219708:	10c00415 	stw	r3,16(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 321970c:	e0bffb17 	ldw	r2,-20(fp)
 3219710:	1080058b 	ldhu	r2,22(r2)
 3219714:	10bfffc4 	addi	r2,r2,-1
 3219718:	1007883a 	mov	r3,r2
 321971c:	e0bffb17 	ldw	r2,-20(fp)
 3219720:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 3219724:	e0bffb17 	ldw	r2,-20(fp)
 3219728:	10c00417 	ldw	r3,16(r2)
 321972c:	e0bffb17 	ldw	r2,-20(fp)
 3219730:	10800217 	ldw	r2,8(r2)
 3219734:	1880041e 	bne	r3,r2,3219748 <OSQAccept+0x10c>
            pq->OSQOut = pq->OSQStart;
 3219738:	e0bffb17 	ldw	r2,-20(fp)
 321973c:	10c00117 	ldw	r3,4(r2)
 3219740:	e0bffb17 	ldw	r2,-20(fp)
 3219744:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
 3219748:	e0bffe17 	ldw	r2,-8(fp)
 321974c:	10000005 	stb	zero,0(r2)
 3219750:	00000406 	br	3219764 <OSQAccept+0x128>
    } else {
        *perr = OS_ERR_Q_EMPTY;
 3219754:	e0fffe17 	ldw	r3,-8(fp)
 3219758:	008007c4 	movi	r2,31
 321975c:	18800005 	stb	r2,0(r3)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
 3219760:	e03ffc15 	stw	zero,-16(fp)
 3219764:	e0bffa17 	ldw	r2,-24(fp)
 3219768:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321976c:	e0bff817 	ldw	r2,-32(fp)
 3219770:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
 3219774:	e0bffc17 	ldw	r2,-16(fp)
 3219778:	e0bfff15 	stw	r2,-4(fp)
 321977c:	e0bfff17 	ldw	r2,-4(fp)
}
 3219780:	e037883a 	mov	sp,fp
 3219784:	df000017 	ldw	fp,0(sp)
 3219788:	dec00104 	addi	sp,sp,4
 321978c:	f800283a 	ret

03219790 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
 3219790:	defff304 	addi	sp,sp,-52
 3219794:	dfc00c15 	stw	ra,48(sp)
 3219798:	df000b15 	stw	fp,44(sp)
 321979c:	df000b04 	addi	fp,sp,44
 32197a0:	e13ffd15 	stw	r4,-12(fp)
 32197a4:	e17ffe0d 	sth	r5,-8(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 32197a8:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 32197ac:	0080c974 	movhi	r2,805
 32197b0:	10922904 	addi	r2,r2,18596
 32197b4:	10800003 	ldbu	r2,0(r2)
 32197b8:	10803fcc 	andi	r2,r2,255
 32197bc:	1005003a 	cmpeq	r2,r2,zero
 32197c0:	1000021e 	bne	r2,zero,32197cc <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 32197c4:	e03fff15 	stw	zero,-4(fp)
 32197c8:	00007006 	br	321998c <OSQCreate+0x1fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32197cc:	0005303a 	rdctl	r2,status
 32197d0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32197d4:	e0fff917 	ldw	r3,-28(fp)
 32197d8:	00bfff84 	movi	r2,-2
 32197dc:	1884703a 	and	r2,r3,r2
 32197e0:	1001703a 	wrctl	status,r2
  
  return context;
 32197e4:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 32197e8:	e0bffa15 	stw	r2,-24(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
 32197ec:	0080c974 	movhi	r2,805
 32197f0:	10922804 	addi	r2,r2,18592
 32197f4:	10800017 	ldw	r2,0(r2)
 32197f8:	e0bffc15 	stw	r2,-16(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 32197fc:	0080c974 	movhi	r2,805
 3219800:	10922804 	addi	r2,r2,18592
 3219804:	10800017 	ldw	r2,0(r2)
 3219808:	1005003a 	cmpeq	r2,r2,zero
 321980c:	1000081e 	bne	r2,zero,3219830 <OSQCreate+0xa0>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 3219810:	0080c974 	movhi	r2,805
 3219814:	10922804 	addi	r2,r2,18592
 3219818:	10800017 	ldw	r2,0(r2)
 321981c:	10800117 	ldw	r2,4(r2)
 3219820:	1007883a 	mov	r3,r2
 3219824:	0080c974 	movhi	r2,805
 3219828:	10922804 	addi	r2,r2,18592
 321982c:	10c00015 	stw	r3,0(r2)
 3219830:	e0bffa17 	ldw	r2,-24(fp)
 3219834:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3219838:	e0bff817 	ldw	r2,-32(fp)
 321983c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
 3219840:	e0bffc17 	ldw	r2,-16(fp)
 3219844:	1005003a 	cmpeq	r2,r2,zero
 3219848:	10004e1e 	bne	r2,zero,3219984 <OSQCreate+0x1f4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321984c:	0005303a 	rdctl	r2,status
 3219850:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3219854:	e0fff717 	ldw	r3,-36(fp)
 3219858:	00bfff84 	movi	r2,-2
 321985c:	1884703a 	and	r2,r3,r2
 3219860:	1001703a 	wrctl	status,r2
  
  return context;
 3219864:	e0bff717 	ldw	r2,-36(fp)
        OS_ENTER_CRITICAL();
 3219868:	e0bffa15 	stw	r2,-24(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
 321986c:	0080c974 	movhi	r2,805
 3219870:	10922604 	addi	r2,r2,18584
 3219874:	10800017 	ldw	r2,0(r2)
 3219878:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
 321987c:	e0bffb17 	ldw	r2,-20(fp)
 3219880:	1005003a 	cmpeq	r2,r2,zero
 3219884:	1000311e 	bne	r2,zero,321994c <OSQCreate+0x1bc>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
 3219888:	0080c974 	movhi	r2,805
 321988c:	10922604 	addi	r2,r2,18584
 3219890:	10800017 	ldw	r2,0(r2)
 3219894:	10c00017 	ldw	r3,0(r2)
 3219898:	0080c974 	movhi	r2,805
 321989c:	10922604 	addi	r2,r2,18584
 32198a0:	10c00015 	stw	r3,0(r2)
 32198a4:	e0bffa17 	ldw	r2,-24(fp)
 32198a8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 32198ac:	e0bff617 	ldw	r2,-40(fp)
 32198b0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
 32198b4:	e0fffb17 	ldw	r3,-20(fp)
 32198b8:	e0bffd17 	ldw	r2,-12(fp)
 32198bc:	18800115 	stw	r2,4(r3)
            pq->OSQEnd             = &start[size];
 32198c0:	e0bffe0b 	ldhu	r2,-8(fp)
 32198c4:	1085883a 	add	r2,r2,r2
 32198c8:	1085883a 	add	r2,r2,r2
 32198cc:	1007883a 	mov	r3,r2
 32198d0:	e0bffd17 	ldw	r2,-12(fp)
 32198d4:	1887883a 	add	r3,r3,r2
 32198d8:	e0bffb17 	ldw	r2,-20(fp)
 32198dc:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
 32198e0:	e0fffb17 	ldw	r3,-20(fp)
 32198e4:	e0bffd17 	ldw	r2,-12(fp)
 32198e8:	18800315 	stw	r2,12(r3)
            pq->OSQOut             = start;
 32198ec:	e0fffb17 	ldw	r3,-20(fp)
 32198f0:	e0bffd17 	ldw	r2,-12(fp)
 32198f4:	18800415 	stw	r2,16(r3)
            pq->OSQSize            = size;
 32198f8:	e0fffb17 	ldw	r3,-20(fp)
 32198fc:	e0bffe0b 	ldhu	r2,-8(fp)
 3219900:	1880050d 	sth	r2,20(r3)
            pq->OSQEntries         = 0;
 3219904:	e0bffb17 	ldw	r2,-20(fp)
 3219908:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
 321990c:	e0fffc17 	ldw	r3,-16(fp)
 3219910:	00800084 	movi	r2,2
 3219914:	18800005 	stb	r2,0(r3)
            pevent->OSEventCnt     = 0;
 3219918:	e0bffc17 	ldw	r2,-16(fp)
 321991c:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
 3219920:	e0fffc17 	ldw	r3,-16(fp)
 3219924:	e0bffb17 	ldw	r2,-20(fp)
 3219928:	18800115 	stw	r2,4(r3)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
 321992c:	e0fffc17 	ldw	r3,-16(fp)
 3219930:	00800fc4 	movi	r2,63
 3219934:	18800385 	stb	r2,14(r3)
            pevent->OSEventName[1] = OS_ASCII_NUL;
 3219938:	e0bffc17 	ldw	r2,-16(fp)
 321993c:	100003c5 	stb	zero,15(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
 3219940:	e13ffc17 	ldw	r4,-16(fp)
 3219944:	32167f80 	call	32167f8 <OS_EventWaitListInit>
 3219948:	00000e06 	br	3219984 <OSQCreate+0x1f4>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
 321994c:	0080c974 	movhi	r2,805
 3219950:	10922804 	addi	r2,r2,18592
 3219954:	10c00017 	ldw	r3,0(r2)
 3219958:	e0bffc17 	ldw	r2,-16(fp)
 321995c:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
 3219960:	00c0c974 	movhi	r3,805
 3219964:	18d22804 	addi	r3,r3,18592
 3219968:	e0bffc17 	ldw	r2,-16(fp)
 321996c:	18800015 	stw	r2,0(r3)
 3219970:	e0bffa17 	ldw	r2,-24(fp)
 3219974:	e0bff515 	stw	r2,-44(fp)
 3219978:	e0bff517 	ldw	r2,-44(fp)
 321997c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
 3219980:	e03ffc15 	stw	zero,-16(fp)
        }
    }
    return (pevent);
 3219984:	e0bffc17 	ldw	r2,-16(fp)
 3219988:	e0bfff15 	stw	r2,-4(fp)
 321998c:	e0bfff17 	ldw	r2,-4(fp)
}
 3219990:	e037883a 	mov	sp,fp
 3219994:	dfc00117 	ldw	ra,4(sp)
 3219998:	df000017 	ldw	fp,0(sp)
 321999c:	dec00204 	addi	sp,sp,8
 32199a0:	f800283a 	ret

032199a4 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 32199a4:	defff004 	addi	sp,sp,-64
 32199a8:	dfc00f15 	stw	ra,60(sp)
 32199ac:	df000e15 	stw	fp,56(sp)
 32199b0:	df000e04 	addi	fp,sp,56
 32199b4:	e13ffb15 	stw	r4,-20(fp)
 32199b8:	e1bffd15 	stw	r6,-12(fp)
 32199bc:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 32199c0:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 32199c4:	e0bffd17 	ldw	r2,-12(fp)
 32199c8:	1004c03a 	cmpne	r2,r2,zero
 32199cc:	1000031e 	bne	r2,zero,32199dc <OSQDel+0x38>
        return (pevent);
 32199d0:	e0bffb17 	ldw	r2,-20(fp)
 32199d4:	e0bfff15 	stw	r2,-4(fp)
 32199d8:	0000ac06 	br	3219c8c <OSQDel+0x2e8>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 32199dc:	e0bffb17 	ldw	r2,-20(fp)
 32199e0:	1004c03a 	cmpne	r2,r2,zero
 32199e4:	1000061e 	bne	r2,zero,3219a00 <OSQDel+0x5c>
        *perr = OS_ERR_PEVENT_NULL;
 32199e8:	e0fffd17 	ldw	r3,-12(fp)
 32199ec:	00800104 	movi	r2,4
 32199f0:	18800005 	stb	r2,0(r3)
        return (pevent);
 32199f4:	e0fffb17 	ldw	r3,-20(fp)
 32199f8:	e0ffff15 	stw	r3,-4(fp)
 32199fc:	0000a306 	br	3219c8c <OSQDel+0x2e8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 3219a00:	e0bffb17 	ldw	r2,-20(fp)
 3219a04:	10800003 	ldbu	r2,0(r2)
 3219a08:	10803fcc 	andi	r2,r2,255
 3219a0c:	108000a0 	cmpeqi	r2,r2,2
 3219a10:	1000061e 	bne	r2,zero,3219a2c <OSQDel+0x88>
        *perr = OS_ERR_EVENT_TYPE;
 3219a14:	e0fffd17 	ldw	r3,-12(fp)
 3219a18:	00800044 	movi	r2,1
 3219a1c:	18800005 	stb	r2,0(r3)
        return (pevent);
 3219a20:	e0bffb17 	ldw	r2,-20(fp)
 3219a24:	e0bfff15 	stw	r2,-4(fp)
 3219a28:	00009806 	br	3219c8c <OSQDel+0x2e8>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 3219a2c:	0080c974 	movhi	r2,805
 3219a30:	10922904 	addi	r2,r2,18596
 3219a34:	10800003 	ldbu	r2,0(r2)
 3219a38:	10803fcc 	andi	r2,r2,255
 3219a3c:	1005003a 	cmpeq	r2,r2,zero
 3219a40:	1000061e 	bne	r2,zero,3219a5c <OSQDel+0xb8>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 3219a44:	e0fffd17 	ldw	r3,-12(fp)
 3219a48:	008003c4 	movi	r2,15
 3219a4c:	18800005 	stb	r2,0(r3)
        return (pevent);
 3219a50:	e0fffb17 	ldw	r3,-20(fp)
 3219a54:	e0ffff15 	stw	r3,-4(fp)
 3219a58:	00008c06 	br	3219c8c <OSQDel+0x2e8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3219a5c:	0005303a 	rdctl	r2,status
 3219a60:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3219a64:	e0fff617 	ldw	r3,-40(fp)
 3219a68:	00bfff84 	movi	r2,-2
 3219a6c:	1884703a 	and	r2,r3,r2
 3219a70:	1001703a 	wrctl	status,r2
  
  return context;
 3219a74:	e0bff617 	ldw	r2,-40(fp)
    }
    OS_ENTER_CRITICAL();
 3219a78:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
 3219a7c:	e0bffb17 	ldw	r2,-20(fp)
 3219a80:	10800283 	ldbu	r2,10(r2)
 3219a84:	10803fcc 	andi	r2,r2,255
 3219a88:	1005003a 	cmpeq	r2,r2,zero
 3219a8c:	1000031e 	bne	r2,zero,3219a9c <OSQDel+0xf8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 3219a90:	00800044 	movi	r2,1
 3219a94:	e0bffa05 	stb	r2,-24(fp)
 3219a98:	00000106 	br	3219aa0 <OSQDel+0xfc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 3219a9c:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 3219aa0:	e0bffc03 	ldbu	r2,-16(fp)
 3219aa4:	e0bffe15 	stw	r2,-8(fp)
 3219aa8:	e0fffe17 	ldw	r3,-8(fp)
 3219aac:	1805003a 	cmpeq	r2,r3,zero
 3219ab0:	1000041e 	bne	r2,zero,3219ac4 <OSQDel+0x120>
 3219ab4:	e0fffe17 	ldw	r3,-8(fp)
 3219ab8:	18800060 	cmpeqi	r2,r3,1
 3219abc:	1000391e 	bne	r2,zero,3219ba4 <OSQDel+0x200>
 3219ac0:	00006706 	br	3219c60 <OSQDel+0x2bc>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
 3219ac4:	e0bffa03 	ldbu	r2,-24(fp)
 3219ac8:	1004c03a 	cmpne	r2,r2,zero
 3219acc:	1000261e 	bne	r2,zero,3219b68 <OSQDel+0x1c4>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 3219ad0:	e0fffb17 	ldw	r3,-20(fp)
 3219ad4:	00800fc4 	movi	r2,63
 3219ad8:	18800385 	stb	r2,14(r3)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 3219adc:	e0bffb17 	ldw	r2,-20(fp)
 3219ae0:	100003c5 	stb	zero,15(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
 3219ae4:	e0bffb17 	ldw	r2,-20(fp)
 3219ae8:	10800117 	ldw	r2,4(r2)
 3219aec:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
 3219af0:	0080c974 	movhi	r2,805
 3219af4:	10922604 	addi	r2,r2,18584
 3219af8:	10c00017 	ldw	r3,0(r2)
 3219afc:	e0bff817 	ldw	r2,-32(fp)
 3219b00:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
 3219b04:	00c0c974 	movhi	r3,805
 3219b08:	18d22604 	addi	r3,r3,18584
 3219b0c:	e0bff817 	ldw	r2,-32(fp)
 3219b10:	18800015 	stw	r2,0(r3)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 3219b14:	e0bffb17 	ldw	r2,-20(fp)
 3219b18:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 3219b1c:	0080c974 	movhi	r2,805
 3219b20:	10922804 	addi	r2,r2,18592
 3219b24:	10c00017 	ldw	r3,0(r2)
 3219b28:	e0bffb17 	ldw	r2,-20(fp)
 3219b2c:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 3219b30:	e0bffb17 	ldw	r2,-20(fp)
 3219b34:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 3219b38:	00c0c974 	movhi	r3,805
 3219b3c:	18d22804 	addi	r3,r3,18592
 3219b40:	e0bffb17 	ldw	r2,-20(fp)
 3219b44:	18800015 	stw	r2,0(r3)
 3219b48:	e0bff717 	ldw	r2,-36(fp)
 3219b4c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3219b50:	e0bff517 	ldw	r2,-44(fp)
 3219b54:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 3219b58:	e0bffd17 	ldw	r2,-12(fp)
 3219b5c:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
 3219b60:	e03ff915 	stw	zero,-28(fp)
 3219b64:	00004706 	br	3219c84 <OSQDel+0x2e0>
 3219b68:	e0bff717 	ldw	r2,-36(fp)
 3219b6c:	e0bff415 	stw	r2,-48(fp)
 3219b70:	e0bff417 	ldw	r2,-48(fp)
 3219b74:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 3219b78:	e0fffd17 	ldw	r3,-12(fp)
 3219b7c:	00801244 	movi	r2,73
 3219b80:	18800005 	stb	r2,0(r3)
                 pevent_return          = pevent;
 3219b84:	e0bffb17 	ldw	r2,-20(fp)
 3219b88:	e0bff915 	stw	r2,-28(fp)
             }
             break;
 3219b8c:	00003d06 	br	3219c84 <OSQDel+0x2e0>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
 3219b90:	e13ffb17 	ldw	r4,-20(fp)
 3219b94:	000b883a 	mov	r5,zero
 3219b98:	01800104 	movi	r6,4
 3219b9c:	000f883a 	mov	r7,zero
 3219ba0:	32162440 	call	3216244 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
 3219ba4:	e0bffb17 	ldw	r2,-20(fp)
 3219ba8:	10800283 	ldbu	r2,10(r2)
 3219bac:	10803fcc 	andi	r2,r2,255
 3219bb0:	1004c03a 	cmpne	r2,r2,zero
 3219bb4:	103ff61e 	bne	r2,zero,3219b90 <OSQDel+0x1ec>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 3219bb8:	e0fffb17 	ldw	r3,-20(fp)
 3219bbc:	00800fc4 	movi	r2,63
 3219bc0:	18800385 	stb	r2,14(r3)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 3219bc4:	e0bffb17 	ldw	r2,-20(fp)
 3219bc8:	100003c5 	stb	zero,15(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
 3219bcc:	e0bffb17 	ldw	r2,-20(fp)
 3219bd0:	10800117 	ldw	r2,4(r2)
 3219bd4:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
 3219bd8:	0080c974 	movhi	r2,805
 3219bdc:	10922604 	addi	r2,r2,18584
 3219be0:	10c00017 	ldw	r3,0(r2)
 3219be4:	e0bff817 	ldw	r2,-32(fp)
 3219be8:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
 3219bec:	00c0c974 	movhi	r3,805
 3219bf0:	18d22604 	addi	r3,r3,18584
 3219bf4:	e0bff817 	ldw	r2,-32(fp)
 3219bf8:	18800015 	stw	r2,0(r3)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 3219bfc:	e0bffb17 	ldw	r2,-20(fp)
 3219c00:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 3219c04:	0080c974 	movhi	r2,805
 3219c08:	10922804 	addi	r2,r2,18592
 3219c0c:	10c00017 	ldw	r3,0(r2)
 3219c10:	e0bffb17 	ldw	r2,-20(fp)
 3219c14:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 3219c18:	e0bffb17 	ldw	r2,-20(fp)
 3219c1c:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 3219c20:	00c0c974 	movhi	r3,805
 3219c24:	18d22804 	addi	r3,r3,18592
 3219c28:	e0bffb17 	ldw	r2,-20(fp)
 3219c2c:	18800015 	stw	r2,0(r3)
 3219c30:	e0bff717 	ldw	r2,-36(fp)
 3219c34:	e0bff315 	stw	r2,-52(fp)
 3219c38:	e0bff317 	ldw	r2,-52(fp)
 3219c3c:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 3219c40:	e0bffa03 	ldbu	r2,-24(fp)
 3219c44:	10800058 	cmpnei	r2,r2,1
 3219c48:	1000011e 	bne	r2,zero,3219c50 <OSQDel+0x2ac>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 3219c4c:	3216c840 	call	3216c84 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 3219c50:	e0bffd17 	ldw	r2,-12(fp)
 3219c54:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
 3219c58:	e03ff915 	stw	zero,-28(fp)
             break;
 3219c5c:	00000906 	br	3219c84 <OSQDel+0x2e0>
 3219c60:	e0bff717 	ldw	r2,-36(fp)
 3219c64:	e0bff215 	stw	r2,-56(fp)
 3219c68:	e0bff217 	ldw	r2,-56(fp)
 3219c6c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 3219c70:	e0fffd17 	ldw	r3,-12(fp)
 3219c74:	008001c4 	movi	r2,7
 3219c78:	18800005 	stb	r2,0(r3)
             pevent_return          = pevent;
 3219c7c:	e0bffb17 	ldw	r2,-20(fp)
 3219c80:	e0bff915 	stw	r2,-28(fp)
             break;
    }
    return (pevent_return);
 3219c84:	e0bff917 	ldw	r2,-28(fp)
 3219c88:	e0bfff15 	stw	r2,-4(fp)
 3219c8c:	e0bfff17 	ldw	r2,-4(fp)
}
 3219c90:	e037883a 	mov	sp,fp
 3219c94:	dfc00117 	ldw	ra,4(sp)
 3219c98:	df000017 	ldw	fp,0(sp)
 3219c9c:	dec00204 	addi	sp,sp,8
 3219ca0:	f800283a 	ret

03219ca4 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
 3219ca4:	defff904 	addi	sp,sp,-28
 3219ca8:	df000615 	stw	fp,24(sp)
 3219cac:	df000604 	addi	fp,sp,24
 3219cb0:	e13ffe15 	stw	r4,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 3219cb4:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 3219cb8:	e0bffe17 	ldw	r2,-8(fp)
 3219cbc:	1004c03a 	cmpne	r2,r2,zero
 3219cc0:	1000031e 	bne	r2,zero,3219cd0 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
 3219cc4:	00800104 	movi	r2,4
 3219cc8:	e0bfff15 	stw	r2,-4(fp)
 3219ccc:	00002206 	br	3219d58 <OSQFlush+0xb4>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 3219cd0:	e0bffe17 	ldw	r2,-8(fp)
 3219cd4:	10800003 	ldbu	r2,0(r2)
 3219cd8:	10803fcc 	andi	r2,r2,255
 3219cdc:	108000a0 	cmpeqi	r2,r2,2
 3219ce0:	1000031e 	bne	r2,zero,3219cf0 <OSQFlush+0x4c>
        return (OS_ERR_EVENT_TYPE);
 3219ce4:	00800044 	movi	r2,1
 3219ce8:	e0bfff15 	stw	r2,-4(fp)
 3219cec:	00001a06 	br	3219d58 <OSQFlush+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3219cf0:	0005303a 	rdctl	r2,status
 3219cf4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3219cf8:	e0fffb17 	ldw	r3,-20(fp)
 3219cfc:	00bfff84 	movi	r2,-2
 3219d00:	1884703a 	and	r2,r3,r2
 3219d04:	1001703a 	wrctl	status,r2
  
  return context;
 3219d08:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 3219d0c:	e0bffc15 	stw	r2,-16(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
 3219d10:	e0bffe17 	ldw	r2,-8(fp)
 3219d14:	10800117 	ldw	r2,4(r2)
 3219d18:	e0bffd15 	stw	r2,-12(fp)
    pq->OSQIn      = pq->OSQStart;
 3219d1c:	e0bffd17 	ldw	r2,-12(fp)
 3219d20:	10c00117 	ldw	r3,4(r2)
 3219d24:	e0bffd17 	ldw	r2,-12(fp)
 3219d28:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
 3219d2c:	e0bffd17 	ldw	r2,-12(fp)
 3219d30:	10c00117 	ldw	r3,4(r2)
 3219d34:	e0bffd17 	ldw	r2,-12(fp)
 3219d38:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
 3219d3c:	e0bffd17 	ldw	r2,-12(fp)
 3219d40:	1000058d 	sth	zero,22(r2)
 3219d44:	e0bffc17 	ldw	r2,-16(fp)
 3219d48:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3219d4c:	e0bffa17 	ldw	r2,-24(fp)
 3219d50:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 3219d54:	e03fff15 	stw	zero,-4(fp)
 3219d58:	e0bfff17 	ldw	r2,-4(fp)
}
 3219d5c:	e037883a 	mov	sp,fp
 3219d60:	df000017 	ldw	fp,0(sp)
 3219d64:	dec00104 	addi	sp,sp,4
 3219d68:	f800283a 	ret

03219d6c <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 3219d6c:	defff104 	addi	sp,sp,-60
 3219d70:	dfc00e15 	stw	ra,56(sp)
 3219d74:	df000d15 	stw	fp,52(sp)
 3219d78:	df000d04 	addi	fp,sp,52
 3219d7c:	e13ffb15 	stw	r4,-20(fp)
 3219d80:	e1bffd15 	stw	r6,-12(fp)
 3219d84:	e17ffc0d 	sth	r5,-16(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3219d88:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 3219d8c:	e0bffd17 	ldw	r2,-12(fp)
 3219d90:	1004c03a 	cmpne	r2,r2,zero
 3219d94:	1000021e 	bne	r2,zero,3219da0 <OSQPend+0x34>
        return ((void *)0);
 3219d98:	e03fff15 	stw	zero,-4(fp)
 3219d9c:	0000b506 	br	321a074 <OSQPend+0x308>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 3219da0:	e0bffb17 	ldw	r2,-20(fp)
 3219da4:	1004c03a 	cmpne	r2,r2,zero
 3219da8:	1000051e 	bne	r2,zero,3219dc0 <OSQPend+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 3219dac:	e0fffd17 	ldw	r3,-12(fp)
 3219db0:	00800104 	movi	r2,4
 3219db4:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 3219db8:	e03fff15 	stw	zero,-4(fp)
 3219dbc:	0000ad06 	br	321a074 <OSQPend+0x308>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 3219dc0:	e0bffb17 	ldw	r2,-20(fp)
 3219dc4:	10800003 	ldbu	r2,0(r2)
 3219dc8:	10803fcc 	andi	r2,r2,255
 3219dcc:	108000a0 	cmpeqi	r2,r2,2
 3219dd0:	1000051e 	bne	r2,zero,3219de8 <OSQPend+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 3219dd4:	e0fffd17 	ldw	r3,-12(fp)
 3219dd8:	00800044 	movi	r2,1
 3219ddc:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 3219de0:	e03fff15 	stw	zero,-4(fp)
 3219de4:	0000a306 	br	321a074 <OSQPend+0x308>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 3219de8:	0080c974 	movhi	r2,805
 3219dec:	10922904 	addi	r2,r2,18596
 3219df0:	10800003 	ldbu	r2,0(r2)
 3219df4:	10803fcc 	andi	r2,r2,255
 3219df8:	1005003a 	cmpeq	r2,r2,zero
 3219dfc:	1000051e 	bne	r2,zero,3219e14 <OSQPend+0xa8>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
 3219e00:	e0fffd17 	ldw	r3,-12(fp)
 3219e04:	00800084 	movi	r2,2
 3219e08:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 3219e0c:	e03fff15 	stw	zero,-4(fp)
 3219e10:	00009806 	br	321a074 <OSQPend+0x308>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
 3219e14:	0080c974 	movhi	r2,805
 3219e18:	10921b04 	addi	r2,r2,18540
 3219e1c:	10800003 	ldbu	r2,0(r2)
 3219e20:	10803fcc 	andi	r2,r2,255
 3219e24:	1005003a 	cmpeq	r2,r2,zero
 3219e28:	1000051e 	bne	r2,zero,3219e40 <OSQPend+0xd4>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
 3219e2c:	e0fffd17 	ldw	r3,-12(fp)
 3219e30:	00800344 	movi	r2,13
 3219e34:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 3219e38:	e03fff15 	stw	zero,-4(fp)
 3219e3c:	00008d06 	br	321a074 <OSQPend+0x308>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3219e40:	0005303a 	rdctl	r2,status
 3219e44:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3219e48:	e0fff717 	ldw	r3,-36(fp)
 3219e4c:	00bfff84 	movi	r2,-2
 3219e50:	1884703a 	and	r2,r3,r2
 3219e54:	1001703a 	wrctl	status,r2
  
  return context;
 3219e58:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 3219e5c:	e0bff815 	stw	r2,-32(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 3219e60:	e0bffb17 	ldw	r2,-20(fp)
 3219e64:	10800117 	ldw	r2,4(r2)
 3219e68:	e0bff915 	stw	r2,-28(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 3219e6c:	e0bff917 	ldw	r2,-28(fp)
 3219e70:	1080058b 	ldhu	r2,22(r2)
 3219e74:	10bfffcc 	andi	r2,r2,65535
 3219e78:	1005003a 	cmpeq	r2,r2,zero
 3219e7c:	10001f1e 	bne	r2,zero,3219efc <OSQPend+0x190>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 3219e80:	e0bff917 	ldw	r2,-28(fp)
 3219e84:	10c00417 	ldw	r3,16(r2)
 3219e88:	18800017 	ldw	r2,0(r3)
 3219e8c:	e0bffa15 	stw	r2,-24(fp)
 3219e90:	18c00104 	addi	r3,r3,4
 3219e94:	e0bff917 	ldw	r2,-28(fp)
 3219e98:	10c00415 	stw	r3,16(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 3219e9c:	e0bff917 	ldw	r2,-28(fp)
 3219ea0:	1080058b 	ldhu	r2,22(r2)
 3219ea4:	10bfffc4 	addi	r2,r2,-1
 3219ea8:	1007883a 	mov	r3,r2
 3219eac:	e0bff917 	ldw	r2,-28(fp)
 3219eb0:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 3219eb4:	e0bff917 	ldw	r2,-28(fp)
 3219eb8:	10c00417 	ldw	r3,16(r2)
 3219ebc:	e0bff917 	ldw	r2,-28(fp)
 3219ec0:	10800217 	ldw	r2,8(r2)
 3219ec4:	1880041e 	bne	r3,r2,3219ed8 <OSQPend+0x16c>
            pq->OSQOut = pq->OSQStart;
 3219ec8:	e0bff917 	ldw	r2,-28(fp)
 3219ecc:	10c00117 	ldw	r3,4(r2)
 3219ed0:	e0bff917 	ldw	r2,-28(fp)
 3219ed4:	10c00415 	stw	r3,16(r2)
 3219ed8:	e0bff817 	ldw	r2,-32(fp)
 3219edc:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3219ee0:	e0bff617 	ldw	r2,-40(fp)
 3219ee4:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 3219ee8:	e0bffd17 	ldw	r2,-12(fp)
 3219eec:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
 3219ef0:	e0bffa17 	ldw	r2,-24(fp)
 3219ef4:	e0bfff15 	stw	r2,-4(fp)
 3219ef8:	00005e06 	br	321a074 <OSQPend+0x308>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
 3219efc:	0080c974 	movhi	r2,805
 3219f00:	10922a04 	addi	r2,r2,18600
 3219f04:	10c00017 	ldw	r3,0(r2)
 3219f08:	0080c974 	movhi	r2,805
 3219f0c:	10922a04 	addi	r2,r2,18600
 3219f10:	10800017 	ldw	r2,0(r2)
 3219f14:	10800c03 	ldbu	r2,48(r2)
 3219f18:	10800114 	ori	r2,r2,4
 3219f1c:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 3219f20:	0080c974 	movhi	r2,805
 3219f24:	10922a04 	addi	r2,r2,18600
 3219f28:	10800017 	ldw	r2,0(r2)
 3219f2c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
 3219f30:	0080c974 	movhi	r2,805
 3219f34:	10922a04 	addi	r2,r2,18600
 3219f38:	10c00017 	ldw	r3,0(r2)
 3219f3c:	e0bffc0b 	ldhu	r2,-16(fp)
 3219f40:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
 3219f44:	e13ffb17 	ldw	r4,-20(fp)
 3219f48:	32163d80 	call	32163d8 <OS_EventTaskWait>
 3219f4c:	e0bff817 	ldw	r2,-32(fp)
 3219f50:	e0bff515 	stw	r2,-44(fp)
 3219f54:	e0bff517 	ldw	r2,-44(fp)
 3219f58:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
 3219f5c:	3216c840 	call	3216c84 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3219f60:	0005303a 	rdctl	r2,status
 3219f64:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3219f68:	e0fff417 	ldw	r3,-48(fp)
 3219f6c:	00bfff84 	movi	r2,-2
 3219f70:	1884703a 	and	r2,r3,r2
 3219f74:	1001703a 	wrctl	status,r2
  
  return context;
 3219f78:	e0bff417 	ldw	r2,-48(fp)
    OS_ENTER_CRITICAL();
 3219f7c:	e0bff815 	stw	r2,-32(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 3219f80:	0080c974 	movhi	r2,805
 3219f84:	10922a04 	addi	r2,r2,18600
 3219f88:	10800017 	ldw	r2,0(r2)
 3219f8c:	10800c43 	ldbu	r2,49(r2)
 3219f90:	10803fcc 	andi	r2,r2,255
 3219f94:	e0bffe15 	stw	r2,-8(fp)
 3219f98:	e0fffe17 	ldw	r3,-8(fp)
 3219f9c:	1805003a 	cmpeq	r2,r3,zero
 3219fa0:	1000041e 	bne	r2,zero,3219fb4 <OSQPend+0x248>
 3219fa4:	e0fffe17 	ldw	r3,-8(fp)
 3219fa8:	188000a0 	cmpeqi	r2,r3,2
 3219fac:	1000091e 	bne	r2,zero,3219fd4 <OSQPend+0x268>
 3219fb0:	00000d06 	br	3219fe8 <OSQPend+0x27c>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
 3219fb4:	0080c974 	movhi	r2,805
 3219fb8:	10922a04 	addi	r2,r2,18600
 3219fbc:	10800017 	ldw	r2,0(r2)
 3219fc0:	10800917 	ldw	r2,36(r2)
 3219fc4:	e0bffa15 	stw	r2,-24(fp)
            *perr =  OS_ERR_NONE;
 3219fc8:	e0bffd17 	ldw	r2,-12(fp)
 3219fcc:	10000005 	stb	zero,0(r2)
             break;
 3219fd0:	00000e06 	br	321a00c <OSQPend+0x2a0>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
 3219fd4:	e03ffa15 	stw	zero,-24(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 3219fd8:	e0fffd17 	ldw	r3,-12(fp)
 3219fdc:	00800384 	movi	r2,14
 3219fe0:	18800005 	stb	r2,0(r3)
             break;
 3219fe4:	00000906 	br	321a00c <OSQPend+0x2a0>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
 3219fe8:	0080c974 	movhi	r2,805
 3219fec:	10922a04 	addi	r2,r2,18600
 3219ff0:	11000017 	ldw	r4,0(r2)
 3219ff4:	e17ffb17 	ldw	r5,-20(fp)
 3219ff8:	321663c0 	call	321663c <OS_EventTaskRemove>
             pmsg = (void *)0;
 3219ffc:	e03ffa15 	stw	zero,-24(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 321a000:	e0fffd17 	ldw	r3,-12(fp)
 321a004:	00800284 	movi	r2,10
 321a008:	18800005 	stb	r2,0(r3)
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 321a00c:	0080c974 	movhi	r2,805
 321a010:	10922a04 	addi	r2,r2,18600
 321a014:	10800017 	ldw	r2,0(r2)
 321a018:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 321a01c:	0080c974 	movhi	r2,805
 321a020:	10922a04 	addi	r2,r2,18600
 321a024:	10800017 	ldw	r2,0(r2)
 321a028:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 321a02c:	0080c974 	movhi	r2,805
 321a030:	10922a04 	addi	r2,r2,18600
 321a034:	10800017 	ldw	r2,0(r2)
 321a038:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 321a03c:	0080c974 	movhi	r2,805
 321a040:	10922a04 	addi	r2,r2,18600
 321a044:	10800017 	ldw	r2,0(r2)
 321a048:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
 321a04c:	0080c974 	movhi	r2,805
 321a050:	10922a04 	addi	r2,r2,18600
 321a054:	10800017 	ldw	r2,0(r2)
 321a058:	10000915 	stw	zero,36(r2)
 321a05c:	e0bff817 	ldw	r2,-32(fp)
 321a060:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321a064:	e0bff317 	ldw	r2,-52(fp)
 321a068:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
 321a06c:	e0bffa17 	ldw	r2,-24(fp)
 321a070:	e0bfff15 	stw	r2,-4(fp)
 321a074:	e0bfff17 	ldw	r2,-4(fp)
}
 321a078:	e037883a 	mov	sp,fp
 321a07c:	dfc00117 	ldw	ra,4(sp)
 321a080:	df000017 	ldw	fp,0(sp)
 321a084:	dec00204 	addi	sp,sp,8
 321a088:	f800283a 	ret

0321a08c <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 321a08c:	defff504 	addi	sp,sp,-44
 321a090:	dfc00a15 	stw	ra,40(sp)
 321a094:	df000915 	stw	fp,36(sp)
 321a098:	df000904 	addi	fp,sp,36
 321a09c:	e13ffc15 	stw	r4,-16(fp)
 321a0a0:	e1bffe15 	stw	r6,-8(fp)
 321a0a4:	e17ffd05 	stb	r5,-12(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 321a0a8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 321a0ac:	e0bffe17 	ldw	r2,-8(fp)
 321a0b0:	1004c03a 	cmpne	r2,r2,zero
 321a0b4:	1000021e 	bne	r2,zero,321a0c0 <OSQPendAbort+0x34>
        return (0);
 321a0b8:	e03fff15 	stw	zero,-4(fp)
 321a0bc:	00004c06 	br	321a1f0 <OSQPendAbort+0x164>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 321a0c0:	e0bffc17 	ldw	r2,-16(fp)
 321a0c4:	1004c03a 	cmpne	r2,r2,zero
 321a0c8:	1000051e 	bne	r2,zero,321a0e0 <OSQPendAbort+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 321a0cc:	e0fffe17 	ldw	r3,-8(fp)
 321a0d0:	00800104 	movi	r2,4
 321a0d4:	18800005 	stb	r2,0(r3)
        return (0);
 321a0d8:	e03fff15 	stw	zero,-4(fp)
 321a0dc:	00004406 	br	321a1f0 <OSQPendAbort+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 321a0e0:	e0bffc17 	ldw	r2,-16(fp)
 321a0e4:	10800003 	ldbu	r2,0(r2)
 321a0e8:	10803fcc 	andi	r2,r2,255
 321a0ec:	108000a0 	cmpeqi	r2,r2,2
 321a0f0:	1000051e 	bne	r2,zero,321a108 <OSQPendAbort+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 321a0f4:	e0fffe17 	ldw	r3,-8(fp)
 321a0f8:	00800044 	movi	r2,1
 321a0fc:	18800005 	stb	r2,0(r3)
        return (0);
 321a100:	e03fff15 	stw	zero,-4(fp)
 321a104:	00003a06 	br	321a1f0 <OSQPendAbort+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321a108:	0005303a 	rdctl	r2,status
 321a10c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321a110:	e0fff917 	ldw	r3,-28(fp)
 321a114:	00bfff84 	movi	r2,-2
 321a118:	1884703a 	and	r2,r3,r2
 321a11c:	1001703a 	wrctl	status,r2
  
  return context;
 321a120:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 321a124:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
 321a128:	e0bffc17 	ldw	r2,-16(fp)
 321a12c:	10800283 	ldbu	r2,10(r2)
 321a130:	10803fcc 	andi	r2,r2,255
 321a134:	1005003a 	cmpeq	r2,r2,zero
 321a138:	1000261e 	bne	r2,zero,321a1d4 <OSQPendAbort+0x148>
        nbr_tasks = 0;
 321a13c:	e03ffb05 	stb	zero,-20(fp)
        switch (opt) {
 321a140:	e0bffd03 	ldbu	r2,-12(fp)
 321a144:	10800060 	cmpeqi	r2,r2,1
 321a148:	1000091e 	bne	r2,zero,321a170 <OSQPendAbort+0xe4>
 321a14c:	00000e06 	br	321a188 <OSQPendAbort+0xfc>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 321a150:	e13ffc17 	ldw	r4,-16(fp)
 321a154:	000b883a 	mov	r5,zero
 321a158:	01800104 	movi	r6,4
 321a15c:	01c00084 	movi	r7,2
 321a160:	32162440 	call	3216244 <OS_EventTaskRdy>
                     nbr_tasks++;
 321a164:	e0bffb03 	ldbu	r2,-20(fp)
 321a168:	10800044 	addi	r2,r2,1
 321a16c:	e0bffb05 	stb	r2,-20(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 321a170:	e0bffc17 	ldw	r2,-16(fp)
 321a174:	10800283 	ldbu	r2,10(r2)
 321a178:	10803fcc 	andi	r2,r2,255
 321a17c:	1004c03a 	cmpne	r2,r2,zero
 321a180:	103ff31e 	bne	r2,zero,321a150 <OSQPendAbort+0xc4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 321a184:	00000806 	br	321a1a8 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 321a188:	e13ffc17 	ldw	r4,-16(fp)
 321a18c:	000b883a 	mov	r5,zero
 321a190:	01800104 	movi	r6,4
 321a194:	01c00084 	movi	r7,2
 321a198:	32162440 	call	3216244 <OS_EventTaskRdy>
                 nbr_tasks++;
 321a19c:	e0bffb03 	ldbu	r2,-20(fp)
 321a1a0:	10800044 	addi	r2,r2,1
 321a1a4:	e0bffb05 	stb	r2,-20(fp)
 321a1a8:	e0bffa17 	ldw	r2,-24(fp)
 321a1ac:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321a1b0:	e0bff817 	ldw	r2,-32(fp)
 321a1b4:	1001703a 	wrctl	status,r2
                 break;
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
 321a1b8:	3216c840 	call	3216c84 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 321a1bc:	e0fffe17 	ldw	r3,-8(fp)
 321a1c0:	00800384 	movi	r2,14
 321a1c4:	18800005 	stb	r2,0(r3)
        return (nbr_tasks);
 321a1c8:	e0bffb03 	ldbu	r2,-20(fp)
 321a1cc:	e0bfff15 	stw	r2,-4(fp)
 321a1d0:	00000706 	br	321a1f0 <OSQPendAbort+0x164>
 321a1d4:	e0bffa17 	ldw	r2,-24(fp)
 321a1d8:	e0bff715 	stw	r2,-36(fp)
 321a1dc:	e0bff717 	ldw	r2,-36(fp)
 321a1e0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 321a1e4:	e0bffe17 	ldw	r2,-8(fp)
 321a1e8:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
 321a1ec:	e03fff15 	stw	zero,-4(fp)
 321a1f0:	e0bfff17 	ldw	r2,-4(fp)
}
 321a1f4:	e037883a 	mov	sp,fp
 321a1f8:	dfc00117 	ldw	ra,4(sp)
 321a1fc:	df000017 	ldw	fp,0(sp)
 321a200:	dec00204 	addi	sp,sp,8
 321a204:	f800283a 	ret

0321a208 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
 321a208:	defff504 	addi	sp,sp,-44
 321a20c:	dfc00a15 	stw	ra,40(sp)
 321a210:	df000915 	stw	fp,36(sp)
 321a214:	df000904 	addi	fp,sp,36
 321a218:	e13ffd15 	stw	r4,-12(fp)
 321a21c:	e17ffe15 	stw	r5,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 321a220:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 321a224:	e0bffd17 	ldw	r2,-12(fp)
 321a228:	1004c03a 	cmpne	r2,r2,zero
 321a22c:	1000031e 	bne	r2,zero,321a23c <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
 321a230:	00800104 	movi	r2,4
 321a234:	e0bfff15 	stw	r2,-4(fp)
 321a238:	00004d06 	br	321a370 <OSQPost+0x168>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 321a23c:	e0bffd17 	ldw	r2,-12(fp)
 321a240:	10800003 	ldbu	r2,0(r2)
 321a244:	10803fcc 	andi	r2,r2,255
 321a248:	108000a0 	cmpeqi	r2,r2,2
 321a24c:	1000031e 	bne	r2,zero,321a25c <OSQPost+0x54>
        return (OS_ERR_EVENT_TYPE);
 321a250:	00800044 	movi	r2,1
 321a254:	e0bfff15 	stw	r2,-4(fp)
 321a258:	00004506 	br	321a370 <OSQPost+0x168>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321a25c:	0005303a 	rdctl	r2,status
 321a260:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321a264:	e0fffa17 	ldw	r3,-24(fp)
 321a268:	00bfff84 	movi	r2,-2
 321a26c:	1884703a 	and	r2,r3,r2
 321a270:	1001703a 	wrctl	status,r2
  
  return context;
 321a274:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 321a278:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
 321a27c:	e0bffd17 	ldw	r2,-12(fp)
 321a280:	10800283 	ldbu	r2,10(r2)
 321a284:	10803fcc 	andi	r2,r2,255
 321a288:	1005003a 	cmpeq	r2,r2,zero
 321a28c:	10000c1e 	bne	r2,zero,321a2c0 <OSQPost+0xb8>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 321a290:	e13ffd17 	ldw	r4,-12(fp)
 321a294:	e17ffe17 	ldw	r5,-8(fp)
 321a298:	01800104 	movi	r6,4
 321a29c:	000f883a 	mov	r7,zero
 321a2a0:	32162440 	call	3216244 <OS_EventTaskRdy>
 321a2a4:	e0bffb17 	ldw	r2,-20(fp)
 321a2a8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321a2ac:	e0bff917 	ldw	r2,-28(fp)
 321a2b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
 321a2b4:	3216c840 	call	3216c84 <OS_Sched>
        return (OS_ERR_NONE);
 321a2b8:	e03fff15 	stw	zero,-4(fp)
 321a2bc:	00002c06 	br	321a370 <OSQPost+0x168>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
 321a2c0:	e0bffd17 	ldw	r2,-12(fp)
 321a2c4:	10800117 	ldw	r2,4(r2)
 321a2c8:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
 321a2cc:	e0bffc17 	ldw	r2,-16(fp)
 321a2d0:	10c0058b 	ldhu	r3,22(r2)
 321a2d4:	e0bffc17 	ldw	r2,-16(fp)
 321a2d8:	1080050b 	ldhu	r2,20(r2)
 321a2dc:	18ffffcc 	andi	r3,r3,65535
 321a2e0:	10bfffcc 	andi	r2,r2,65535
 321a2e4:	18800736 	bltu	r3,r2,321a304 <OSQPost+0xfc>
 321a2e8:	e0bffb17 	ldw	r2,-20(fp)
 321a2ec:	e0bff815 	stw	r2,-32(fp)
 321a2f0:	e0bff817 	ldw	r2,-32(fp)
 321a2f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 321a2f8:	00800784 	movi	r2,30
 321a2fc:	e0bfff15 	stw	r2,-4(fp)
 321a300:	00001b06 	br	321a370 <OSQPost+0x168>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
 321a304:	e0bffc17 	ldw	r2,-16(fp)
 321a308:	10c00317 	ldw	r3,12(r2)
 321a30c:	e0bffe17 	ldw	r2,-8(fp)
 321a310:	18800015 	stw	r2,0(r3)
 321a314:	18c00104 	addi	r3,r3,4
 321a318:	e0bffc17 	ldw	r2,-16(fp)
 321a31c:	10c00315 	stw	r3,12(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
 321a320:	e0bffc17 	ldw	r2,-16(fp)
 321a324:	1080058b 	ldhu	r2,22(r2)
 321a328:	10800044 	addi	r2,r2,1
 321a32c:	1007883a 	mov	r3,r2
 321a330:	e0bffc17 	ldw	r2,-16(fp)
 321a334:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
 321a338:	e0bffc17 	ldw	r2,-16(fp)
 321a33c:	10c00317 	ldw	r3,12(r2)
 321a340:	e0bffc17 	ldw	r2,-16(fp)
 321a344:	10800217 	ldw	r2,8(r2)
 321a348:	1880041e 	bne	r3,r2,321a35c <OSQPost+0x154>
        pq->OSQIn = pq->OSQStart;
 321a34c:	e0bffc17 	ldw	r2,-16(fp)
 321a350:	10c00117 	ldw	r3,4(r2)
 321a354:	e0bffc17 	ldw	r2,-16(fp)
 321a358:	10c00315 	stw	r3,12(r2)
 321a35c:	e0bffb17 	ldw	r2,-20(fp)
 321a360:	e0bff715 	stw	r2,-36(fp)
 321a364:	e0bff717 	ldw	r2,-36(fp)
 321a368:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 321a36c:	e03fff15 	stw	zero,-4(fp)
 321a370:	e0bfff17 	ldw	r2,-4(fp)
}
 321a374:	e037883a 	mov	sp,fp
 321a378:	dfc00117 	ldw	ra,4(sp)
 321a37c:	df000017 	ldw	fp,0(sp)
 321a380:	dec00204 	addi	sp,sp,8
 321a384:	f800283a 	ret

0321a388 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
 321a388:	defff504 	addi	sp,sp,-44
 321a38c:	dfc00a15 	stw	ra,40(sp)
 321a390:	df000915 	stw	fp,36(sp)
 321a394:	df000904 	addi	fp,sp,36
 321a398:	e13ffd15 	stw	r4,-12(fp)
 321a39c:	e17ffe15 	stw	r5,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 321a3a0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 321a3a4:	e0bffd17 	ldw	r2,-12(fp)
 321a3a8:	1004c03a 	cmpne	r2,r2,zero
 321a3ac:	1000031e 	bne	r2,zero,321a3bc <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
 321a3b0:	00800104 	movi	r2,4
 321a3b4:	e0bfff15 	stw	r2,-4(fp)
 321a3b8:	00004f06 	br	321a4f8 <OSQPostFront+0x170>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 321a3bc:	e0bffd17 	ldw	r2,-12(fp)
 321a3c0:	10800003 	ldbu	r2,0(r2)
 321a3c4:	10803fcc 	andi	r2,r2,255
 321a3c8:	108000a0 	cmpeqi	r2,r2,2
 321a3cc:	1000031e 	bne	r2,zero,321a3dc <OSQPostFront+0x54>
        return (OS_ERR_EVENT_TYPE);
 321a3d0:	00800044 	movi	r2,1
 321a3d4:	e0bfff15 	stw	r2,-4(fp)
 321a3d8:	00004706 	br	321a4f8 <OSQPostFront+0x170>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321a3dc:	0005303a 	rdctl	r2,status
 321a3e0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321a3e4:	e0fffa17 	ldw	r3,-24(fp)
 321a3e8:	00bfff84 	movi	r2,-2
 321a3ec:	1884703a 	and	r2,r3,r2
 321a3f0:	1001703a 	wrctl	status,r2
  
  return context;
 321a3f4:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 321a3f8:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
 321a3fc:	e0bffd17 	ldw	r2,-12(fp)
 321a400:	10800283 	ldbu	r2,10(r2)
 321a404:	10803fcc 	andi	r2,r2,255
 321a408:	1005003a 	cmpeq	r2,r2,zero
 321a40c:	10000c1e 	bne	r2,zero,321a440 <OSQPostFront+0xb8>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 321a410:	e13ffd17 	ldw	r4,-12(fp)
 321a414:	e17ffe17 	ldw	r5,-8(fp)
 321a418:	01800104 	movi	r6,4
 321a41c:	000f883a 	mov	r7,zero
 321a420:	32162440 	call	3216244 <OS_EventTaskRdy>
 321a424:	e0bffb17 	ldw	r2,-20(fp)
 321a428:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321a42c:	e0bff917 	ldw	r2,-28(fp)
 321a430:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
 321a434:	3216c840 	call	3216c84 <OS_Sched>
        return (OS_ERR_NONE);
 321a438:	e03fff15 	stw	zero,-4(fp)
 321a43c:	00002e06 	br	321a4f8 <OSQPostFront+0x170>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 321a440:	e0bffd17 	ldw	r2,-12(fp)
 321a444:	10800117 	ldw	r2,4(r2)
 321a448:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 321a44c:	e0bffc17 	ldw	r2,-16(fp)
 321a450:	10c0058b 	ldhu	r3,22(r2)
 321a454:	e0bffc17 	ldw	r2,-16(fp)
 321a458:	1080050b 	ldhu	r2,20(r2)
 321a45c:	18ffffcc 	andi	r3,r3,65535
 321a460:	10bfffcc 	andi	r2,r2,65535
 321a464:	18800736 	bltu	r3,r2,321a484 <OSQPostFront+0xfc>
 321a468:	e0bffb17 	ldw	r2,-20(fp)
 321a46c:	e0bff815 	stw	r2,-32(fp)
 321a470:	e0bff817 	ldw	r2,-32(fp)
 321a474:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 321a478:	00800784 	movi	r2,30
 321a47c:	e0bfff15 	stw	r2,-4(fp)
 321a480:	00001d06 	br	321a4f8 <OSQPostFront+0x170>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
 321a484:	e0bffc17 	ldw	r2,-16(fp)
 321a488:	10c00417 	ldw	r3,16(r2)
 321a48c:	e0bffc17 	ldw	r2,-16(fp)
 321a490:	10800117 	ldw	r2,4(r2)
 321a494:	1880041e 	bne	r3,r2,321a4a8 <OSQPostFront+0x120>
        pq->OSQOut = pq->OSQEnd;
 321a498:	e0bffc17 	ldw	r2,-16(fp)
 321a49c:	10c00217 	ldw	r3,8(r2)
 321a4a0:	e0bffc17 	ldw	r2,-16(fp)
 321a4a4:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
 321a4a8:	e0bffc17 	ldw	r2,-16(fp)
 321a4ac:	10800417 	ldw	r2,16(r2)
 321a4b0:	10ffff04 	addi	r3,r2,-4
 321a4b4:	e0bffc17 	ldw	r2,-16(fp)
 321a4b8:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
 321a4bc:	e0bffc17 	ldw	r2,-16(fp)
 321a4c0:	10c00417 	ldw	r3,16(r2)
 321a4c4:	e0bffe17 	ldw	r2,-8(fp)
 321a4c8:	18800015 	stw	r2,0(r3)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 321a4cc:	e0bffc17 	ldw	r2,-16(fp)
 321a4d0:	1080058b 	ldhu	r2,22(r2)
 321a4d4:	10800044 	addi	r2,r2,1
 321a4d8:	1007883a 	mov	r3,r2
 321a4dc:	e0bffc17 	ldw	r2,-16(fp)
 321a4e0:	10c0058d 	sth	r3,22(r2)
 321a4e4:	e0bffb17 	ldw	r2,-20(fp)
 321a4e8:	e0bff715 	stw	r2,-36(fp)
 321a4ec:	e0bff717 	ldw	r2,-36(fp)
 321a4f0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 321a4f4:	e03fff15 	stw	zero,-4(fp)
 321a4f8:	e0bfff17 	ldw	r2,-4(fp)
}
 321a4fc:	e037883a 	mov	sp,fp
 321a500:	dfc00117 	ldw	ra,4(sp)
 321a504:	df000017 	ldw	fp,0(sp)
 321a508:	dec00204 	addi	sp,sp,8
 321a50c:	f800283a 	ret

0321a510 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
 321a510:	defff404 	addi	sp,sp,-48
 321a514:	dfc00b15 	stw	ra,44(sp)
 321a518:	df000a15 	stw	fp,40(sp)
 321a51c:	df000a04 	addi	fp,sp,40
 321a520:	e13ffc15 	stw	r4,-16(fp)
 321a524:	e17ffd15 	stw	r5,-12(fp)
 321a528:	e1bffe05 	stb	r6,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 321a52c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 321a530:	e0bffc17 	ldw	r2,-16(fp)
 321a534:	1004c03a 	cmpne	r2,r2,zero
 321a538:	1000031e 	bne	r2,zero,321a548 <OSQPostOpt+0x38>
        return (OS_ERR_PEVENT_NULL);
 321a53c:	00800104 	movi	r2,4
 321a540:	e0bfff15 	stw	r2,-4(fp)
 321a544:	00007906 	br	321a72c <OSQPostOpt+0x21c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 321a548:	e0bffc17 	ldw	r2,-16(fp)
 321a54c:	10800003 	ldbu	r2,0(r2)
 321a550:	10803fcc 	andi	r2,r2,255
 321a554:	108000a0 	cmpeqi	r2,r2,2
 321a558:	1000031e 	bne	r2,zero,321a568 <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
 321a55c:	00800044 	movi	r2,1
 321a560:	e0bfff15 	stw	r2,-4(fp)
 321a564:	00007106 	br	321a72c <OSQPostOpt+0x21c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321a568:	0005303a 	rdctl	r2,status
 321a56c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321a570:	e0fff917 	ldw	r3,-28(fp)
 321a574:	00bfff84 	movi	r2,-2
 321a578:	1884703a 	and	r2,r3,r2
 321a57c:	1001703a 	wrctl	status,r2
  
  return context;
 321a580:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 321a584:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
 321a588:	e0bffc17 	ldw	r2,-16(fp)
 321a58c:	10800283 	ldbu	r2,10(r2)
 321a590:	10803fcc 	andi	r2,r2,255
 321a594:	1005003a 	cmpeq	r2,r2,zero
 321a598:	1000211e 	bne	r2,zero,321a620 <OSQPostOpt+0x110>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
 321a59c:	e0bffe03 	ldbu	r2,-8(fp)
 321a5a0:	1080004c 	andi	r2,r2,1
 321a5a4:	10803fcc 	andi	r2,r2,255
 321a5a8:	1005003a 	cmpeq	r2,r2,zero
 321a5ac:	10000c1e 	bne	r2,zero,321a5e0 <OSQPostOpt+0xd0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 321a5b0:	00000506 	br	321a5c8 <OSQPostOpt+0xb8>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 321a5b4:	e13ffc17 	ldw	r4,-16(fp)
 321a5b8:	e17ffd17 	ldw	r5,-12(fp)
 321a5bc:	01800104 	movi	r6,4
 321a5c0:	000f883a 	mov	r7,zero
 321a5c4:	32162440 	call	3216244 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 321a5c8:	e0bffc17 	ldw	r2,-16(fp)
 321a5cc:	10800283 	ldbu	r2,10(r2)
 321a5d0:	10803fcc 	andi	r2,r2,255
 321a5d4:	1004c03a 	cmpne	r2,r2,zero
 321a5d8:	103ff61e 	bne	r2,zero,321a5b4 <OSQPostOpt+0xa4>
 321a5dc:	00000506 	br	321a5f4 <OSQPostOpt+0xe4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 321a5e0:	e13ffc17 	ldw	r4,-16(fp)
 321a5e4:	e17ffd17 	ldw	r5,-12(fp)
 321a5e8:	01800104 	movi	r6,4
 321a5ec:	000f883a 	mov	r7,zero
 321a5f0:	32162440 	call	3216244 <OS_EventTaskRdy>
 321a5f4:	e0bffa17 	ldw	r2,-24(fp)
 321a5f8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321a5fc:	e0bff817 	ldw	r2,-32(fp)
 321a600:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
 321a604:	e0bffe03 	ldbu	r2,-8(fp)
 321a608:	1080010c 	andi	r2,r2,4
 321a60c:	1004c03a 	cmpne	r2,r2,zero
 321a610:	1000011e 	bne	r2,zero,321a618 <OSQPostOpt+0x108>
            OS_Sched();                               /* Find highest priority task ready to run       */
 321a614:	3216c840 	call	3216c84 <OS_Sched>
        }
        return (OS_ERR_NONE);
 321a618:	e03fff15 	stw	zero,-4(fp)
 321a61c:	00004306 	br	321a72c <OSQPostOpt+0x21c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 321a620:	e0bffc17 	ldw	r2,-16(fp)
 321a624:	10800117 	ldw	r2,4(r2)
 321a628:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 321a62c:	e0bffb17 	ldw	r2,-20(fp)
 321a630:	10c0058b 	ldhu	r3,22(r2)
 321a634:	e0bffb17 	ldw	r2,-20(fp)
 321a638:	1080050b 	ldhu	r2,20(r2)
 321a63c:	18ffffcc 	andi	r3,r3,65535
 321a640:	10bfffcc 	andi	r2,r2,65535
 321a644:	18800736 	bltu	r3,r2,321a664 <OSQPostOpt+0x154>
 321a648:	e0bffa17 	ldw	r2,-24(fp)
 321a64c:	e0bff715 	stw	r2,-36(fp)
 321a650:	e0bff717 	ldw	r2,-36(fp)
 321a654:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 321a658:	00800784 	movi	r2,30
 321a65c:	e0bfff15 	stw	r2,-4(fp)
 321a660:	00003206 	br	321a72c <OSQPostOpt+0x21c>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
 321a664:	e0bffe03 	ldbu	r2,-8(fp)
 321a668:	1080008c 	andi	r2,r2,2
 321a66c:	1005003a 	cmpeq	r2,r2,zero
 321a670:	1000131e 	bne	r2,zero,321a6c0 <OSQPostOpt+0x1b0>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
 321a674:	e0bffb17 	ldw	r2,-20(fp)
 321a678:	10c00417 	ldw	r3,16(r2)
 321a67c:	e0bffb17 	ldw	r2,-20(fp)
 321a680:	10800117 	ldw	r2,4(r2)
 321a684:	1880041e 	bne	r3,r2,321a698 <OSQPostOpt+0x188>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
 321a688:	e0bffb17 	ldw	r2,-20(fp)
 321a68c:	10c00217 	ldw	r3,8(r2)
 321a690:	e0bffb17 	ldw	r2,-20(fp)
 321a694:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
 321a698:	e0bffb17 	ldw	r2,-20(fp)
 321a69c:	10800417 	ldw	r2,16(r2)
 321a6a0:	10ffff04 	addi	r3,r2,-4
 321a6a4:	e0bffb17 	ldw	r2,-20(fp)
 321a6a8:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
 321a6ac:	e0bffb17 	ldw	r2,-20(fp)
 321a6b0:	10c00417 	ldw	r3,16(r2)
 321a6b4:	e0bffd17 	ldw	r2,-12(fp)
 321a6b8:	18800015 	stw	r2,0(r3)
 321a6bc:	00001006 	br	321a700 <OSQPostOpt+0x1f0>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
 321a6c0:	e0bffb17 	ldw	r2,-20(fp)
 321a6c4:	10c00317 	ldw	r3,12(r2)
 321a6c8:	e0bffd17 	ldw	r2,-12(fp)
 321a6cc:	18800015 	stw	r2,0(r3)
 321a6d0:	18c00104 	addi	r3,r3,4
 321a6d4:	e0bffb17 	ldw	r2,-20(fp)
 321a6d8:	10c00315 	stw	r3,12(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
 321a6dc:	e0bffb17 	ldw	r2,-20(fp)
 321a6e0:	10c00317 	ldw	r3,12(r2)
 321a6e4:	e0bffb17 	ldw	r2,-20(fp)
 321a6e8:	10800217 	ldw	r2,8(r2)
 321a6ec:	1880041e 	bne	r3,r2,321a700 <OSQPostOpt+0x1f0>
            pq->OSQIn = pq->OSQStart;
 321a6f0:	e0bffb17 	ldw	r2,-20(fp)
 321a6f4:	10c00117 	ldw	r3,4(r2)
 321a6f8:	e0bffb17 	ldw	r2,-20(fp)
 321a6fc:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 321a700:	e0bffb17 	ldw	r2,-20(fp)
 321a704:	1080058b 	ldhu	r2,22(r2)
 321a708:	10800044 	addi	r2,r2,1
 321a70c:	1007883a 	mov	r3,r2
 321a710:	e0bffb17 	ldw	r2,-20(fp)
 321a714:	10c0058d 	sth	r3,22(r2)
 321a718:	e0bffa17 	ldw	r2,-24(fp)
 321a71c:	e0bff615 	stw	r2,-40(fp)
 321a720:	e0bff617 	ldw	r2,-40(fp)
 321a724:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 321a728:	e03fff15 	stw	zero,-4(fp)
 321a72c:	e0bfff17 	ldw	r2,-4(fp)
}
 321a730:	e037883a 	mov	sp,fp
 321a734:	dfc00117 	ldw	ra,4(sp)
 321a738:	df000017 	ldw	fp,0(sp)
 321a73c:	dec00204 	addi	sp,sp,8
 321a740:	f800283a 	ret

0321a744 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
 321a744:	defff504 	addi	sp,sp,-44
 321a748:	df000a15 	stw	fp,40(sp)
 321a74c:	df000a04 	addi	fp,sp,40
 321a750:	e13ffd15 	stw	r4,-12(fp)
 321a754:	e17ffe15 	stw	r5,-8(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 321a758:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 321a75c:	e0bffd17 	ldw	r2,-12(fp)
 321a760:	1004c03a 	cmpne	r2,r2,zero
 321a764:	1000031e 	bne	r2,zero,321a774 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
 321a768:	00800104 	movi	r2,4
 321a76c:	e0bfff15 	stw	r2,-4(fp)
 321a770:	00004f06 	br	321a8b0 <OSQQuery+0x16c>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
 321a774:	e0bffe17 	ldw	r2,-8(fp)
 321a778:	1004c03a 	cmpne	r2,r2,zero
 321a77c:	1000031e 	bne	r2,zero,321a78c <OSQQuery+0x48>
        return (OS_ERR_PDATA_NULL);
 321a780:	00800244 	movi	r2,9
 321a784:	e0bfff15 	stw	r2,-4(fp)
 321a788:	00004906 	br	321a8b0 <OSQQuery+0x16c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 321a78c:	e0bffd17 	ldw	r2,-12(fp)
 321a790:	10800003 	ldbu	r2,0(r2)
 321a794:	10803fcc 	andi	r2,r2,255
 321a798:	108000a0 	cmpeqi	r2,r2,2
 321a79c:	1000031e 	bne	r2,zero,321a7ac <OSQQuery+0x68>
        return (OS_ERR_EVENT_TYPE);
 321a7a0:	00800044 	movi	r2,1
 321a7a4:	e0bfff15 	stw	r2,-4(fp)
 321a7a8:	00004106 	br	321a8b0 <OSQQuery+0x16c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321a7ac:	0005303a 	rdctl	r2,status
 321a7b0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321a7b4:	e0fff717 	ldw	r3,-36(fp)
 321a7b8:	00bfff84 	movi	r2,-2
 321a7bc:	1884703a 	and	r2,r3,r2
 321a7c0:	1001703a 	wrctl	status,r2
  
  return context;
 321a7c4:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 321a7c8:	e0bff815 	stw	r2,-32(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
 321a7cc:	e0bffd17 	ldw	r2,-12(fp)
 321a7d0:	10c00283 	ldbu	r3,10(r2)
 321a7d4:	e0bffe17 	ldw	r2,-8(fp)
 321a7d8:	10c002c5 	stb	r3,11(r2)
    psrc                 = &pevent->OSEventTbl[0];
 321a7dc:	e0bffd17 	ldw	r2,-12(fp)
 321a7e0:	108002c4 	addi	r2,r2,11
 321a7e4:	e0bffa15 	stw	r2,-24(fp)
    pdest                = &p_q_data->OSEventTbl[0];
 321a7e8:	e0bffe17 	ldw	r2,-8(fp)
 321a7ec:	10800204 	addi	r2,r2,8
 321a7f0:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 321a7f4:	e03ffb05 	stb	zero,-20(fp)
 321a7f8:	00000d06 	br	321a830 <OSQQuery+0xec>
        *pdest++ = *psrc++;
 321a7fc:	e0bffa17 	ldw	r2,-24(fp)
 321a800:	10c00003 	ldbu	r3,0(r2)
 321a804:	e0bff917 	ldw	r2,-28(fp)
 321a808:	10c00005 	stb	r3,0(r2)
 321a80c:	e0bff917 	ldw	r2,-28(fp)
 321a810:	10800044 	addi	r2,r2,1
 321a814:	e0bff915 	stw	r2,-28(fp)
 321a818:	e0bffa17 	ldw	r2,-24(fp)
 321a81c:	10800044 	addi	r2,r2,1
 321a820:	e0bffa15 	stw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 321a824:	e0bffb03 	ldbu	r2,-20(fp)
 321a828:	10800044 	addi	r2,r2,1
 321a82c:	e0bffb05 	stb	r2,-20(fp)
 321a830:	e0bffb03 	ldbu	r2,-20(fp)
 321a834:	108000f0 	cmpltui	r2,r2,3
 321a838:	103ff01e 	bne	r2,zero,321a7fc <OSQQuery+0xb8>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
 321a83c:	e0bffd17 	ldw	r2,-12(fp)
 321a840:	10800117 	ldw	r2,4(r2)
 321a844:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
 321a848:	e0bffc17 	ldw	r2,-16(fp)
 321a84c:	1080058b 	ldhu	r2,22(r2)
 321a850:	10bfffcc 	andi	r2,r2,65535
 321a854:	1005003a 	cmpeq	r2,r2,zero
 321a858:	1000061e 	bne	r2,zero,321a874 <OSQQuery+0x130>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
 321a85c:	e0bffc17 	ldw	r2,-16(fp)
 321a860:	10800417 	ldw	r2,16(r2)
 321a864:	10c00017 	ldw	r3,0(r2)
 321a868:	e0bffe17 	ldw	r2,-8(fp)
 321a86c:	10c00015 	stw	r3,0(r2)
 321a870:	00000206 	br	321a87c <OSQQuery+0x138>
    } else {
        p_q_data->OSMsg = (void *)0;
 321a874:	e0bffe17 	ldw	r2,-8(fp)
 321a878:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
 321a87c:	e0bffc17 	ldw	r2,-16(fp)
 321a880:	10c0058b 	ldhu	r3,22(r2)
 321a884:	e0bffe17 	ldw	r2,-8(fp)
 321a888:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
 321a88c:	e0bffc17 	ldw	r2,-16(fp)
 321a890:	10c0050b 	ldhu	r3,20(r2)
 321a894:	e0bffe17 	ldw	r2,-8(fp)
 321a898:	10c0018d 	sth	r3,6(r2)
 321a89c:	e0bff817 	ldw	r2,-32(fp)
 321a8a0:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321a8a4:	e0bff617 	ldw	r2,-40(fp)
 321a8a8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 321a8ac:	e03fff15 	stw	zero,-4(fp)
 321a8b0:	e0bfff17 	ldw	r2,-4(fp)
}
 321a8b4:	e037883a 	mov	sp,fp
 321a8b8:	df000017 	ldw	fp,0(sp)
 321a8bc:	dec00104 	addi	sp,sp,4
 321a8c0:	f800283a 	ret

0321a8c4 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
 321a8c4:	defffb04 	addi	sp,sp,-20
 321a8c8:	dfc00415 	stw	ra,16(sp)
 321a8cc:	df000315 	stw	fp,12(sp)
 321a8d0:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
 321a8d4:	0100c9b4 	movhi	r4,806
 321a8d8:	212af404 	addi	r4,r4,-21552
 321a8dc:	01407804 	movi	r5,480
 321a8e0:	3216bc40 	call	3216bc4 <OS_MemClr>
    pq1 = &OSQTbl[0];
 321a8e4:	0080c9b4 	movhi	r2,806
 321a8e8:	10aaf404 	addi	r2,r2,-21552
 321a8ec:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
 321a8f0:	0080c9b4 	movhi	r2,806
 321a8f4:	10aafa04 	addi	r2,r2,-21528
 321a8f8:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 321a8fc:	e03fff0d 	sth	zero,-4(fp)
 321a900:	00000c06 	br	321a934 <OS_QInit+0x70>
        pq1->OSQPtr = pq2;
 321a904:	e0fffe17 	ldw	r3,-8(fp)
 321a908:	e0bffd17 	ldw	r2,-12(fp)
 321a90c:	18800015 	stw	r2,0(r3)
        pq1++;
 321a910:	e0bffe17 	ldw	r2,-8(fp)
 321a914:	10800604 	addi	r2,r2,24
 321a918:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
 321a91c:	e0bffd17 	ldw	r2,-12(fp)
 321a920:	10800604 	addi	r2,r2,24
 321a924:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 321a928:	e0bfff0b 	ldhu	r2,-4(fp)
 321a92c:	10800044 	addi	r2,r2,1
 321a930:	e0bfff0d 	sth	r2,-4(fp)
 321a934:	e0bfff0b 	ldhu	r2,-4(fp)
 321a938:	108004f0 	cmpltui	r2,r2,19
 321a93c:	103ff11e 	bne	r2,zero,321a904 <OS_QInit+0x40>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
 321a940:	e0bffe17 	ldw	r2,-8(fp)
 321a944:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
 321a948:	00c0c974 	movhi	r3,805
 321a94c:	18d22604 	addi	r3,r3,18584
 321a950:	0080c9b4 	movhi	r2,806
 321a954:	10aaf404 	addi	r2,r2,-21552
 321a958:	18800015 	stw	r2,0(r3)
#endif
}
 321a95c:	e037883a 	mov	sp,fp
 321a960:	dfc00117 	ldw	ra,4(sp)
 321a964:	df000017 	ldw	fp,0(sp)
 321a968:	dec00204 	addi	sp,sp,8
 321a96c:	f800283a 	ret

0321a970 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
 321a970:	defff904 	addi	sp,sp,-28
 321a974:	df000615 	stw	fp,24(sp)
 321a978:	df000604 	addi	fp,sp,24
 321a97c:	e13ffe15 	stw	r4,-8(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 321a980:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 321a984:	e0bffe17 	ldw	r2,-8(fp)
 321a988:	1004c03a 	cmpne	r2,r2,zero
 321a98c:	1000021e 	bne	r2,zero,321a998 <OSSemAccept+0x28>
        return (0);
 321a990:	e03fff15 	stw	zero,-4(fp)
 321a994:	00002106 	br	321aa1c <OSSemAccept+0xac>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 321a998:	e0bffe17 	ldw	r2,-8(fp)
 321a99c:	10800003 	ldbu	r2,0(r2)
 321a9a0:	10803fcc 	andi	r2,r2,255
 321a9a4:	108000e0 	cmpeqi	r2,r2,3
 321a9a8:	1000021e 	bne	r2,zero,321a9b4 <OSSemAccept+0x44>
        return (0);
 321a9ac:	e03fff15 	stw	zero,-4(fp)
 321a9b0:	00001a06 	br	321aa1c <OSSemAccept+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321a9b4:	0005303a 	rdctl	r2,status
 321a9b8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321a9bc:	e0fffb17 	ldw	r3,-20(fp)
 321a9c0:	00bfff84 	movi	r2,-2
 321a9c4:	1884703a 	and	r2,r3,r2
 321a9c8:	1001703a 	wrctl	status,r2
  
  return context;
 321a9cc:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 321a9d0:	e0bffc15 	stw	r2,-16(fp)
    cnt = pevent->OSEventCnt;
 321a9d4:	e0bffe17 	ldw	r2,-8(fp)
 321a9d8:	1080020b 	ldhu	r2,8(r2)
 321a9dc:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
 321a9e0:	e0bffd0b 	ldhu	r2,-12(fp)
 321a9e4:	1005003a 	cmpeq	r2,r2,zero
 321a9e8:	1000061e 	bne	r2,zero,321aa04 <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
 321a9ec:	e0bffe17 	ldw	r2,-8(fp)
 321a9f0:	1080020b 	ldhu	r2,8(r2)
 321a9f4:	10bfffc4 	addi	r2,r2,-1
 321a9f8:	1007883a 	mov	r3,r2
 321a9fc:	e0bffe17 	ldw	r2,-8(fp)
 321aa00:	10c0020d 	sth	r3,8(r2)
 321aa04:	e0bffc17 	ldw	r2,-16(fp)
 321aa08:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321aa0c:	e0bffa17 	ldw	r2,-24(fp)
 321aa10:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
 321aa14:	e0bffd0b 	ldhu	r2,-12(fp)
 321aa18:	e0bfff15 	stw	r2,-4(fp)
 321aa1c:	e0bfff17 	ldw	r2,-4(fp)
}
 321aa20:	e037883a 	mov	sp,fp
 321aa24:	df000017 	ldw	fp,0(sp)
 321aa28:	dec00104 	addi	sp,sp,4
 321aa2c:	f800283a 	ret

0321aa30 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
 321aa30:	defff804 	addi	sp,sp,-32
 321aa34:	dfc00715 	stw	ra,28(sp)
 321aa38:	df000615 	stw	fp,24(sp)
 321aa3c:	df000604 	addi	fp,sp,24
 321aa40:	e13ffe0d 	sth	r4,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 321aa44:	e03ffc15 	stw	zero,-16(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 321aa48:	0080c974 	movhi	r2,805
 321aa4c:	10922904 	addi	r2,r2,18596
 321aa50:	10800003 	ldbu	r2,0(r2)
 321aa54:	10803fcc 	andi	r2,r2,255
 321aa58:	1005003a 	cmpeq	r2,r2,zero
 321aa5c:	1000021e 	bne	r2,zero,321aa68 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
 321aa60:	e03fff15 	stw	zero,-4(fp)
 321aa64:	00003106 	br	321ab2c <OSSemCreate+0xfc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321aa68:	0005303a 	rdctl	r2,status
 321aa6c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321aa70:	e0fffb17 	ldw	r3,-20(fp)
 321aa74:	00bfff84 	movi	r2,-2
 321aa78:	1884703a 	and	r2,r3,r2
 321aa7c:	1001703a 	wrctl	status,r2
  
  return context;
 321aa80:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 321aa84:	e0bffc15 	stw	r2,-16(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
 321aa88:	0080c974 	movhi	r2,805
 321aa8c:	10922804 	addi	r2,r2,18592
 321aa90:	10800017 	ldw	r2,0(r2)
 321aa94:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
 321aa98:	0080c974 	movhi	r2,805
 321aa9c:	10922804 	addi	r2,r2,18592
 321aaa0:	10800017 	ldw	r2,0(r2)
 321aaa4:	1005003a 	cmpeq	r2,r2,zero
 321aaa8:	1000081e 	bne	r2,zero,321aacc <OSSemCreate+0x9c>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 321aaac:	0080c974 	movhi	r2,805
 321aab0:	10922804 	addi	r2,r2,18592
 321aab4:	10800017 	ldw	r2,0(r2)
 321aab8:	10800117 	ldw	r2,4(r2)
 321aabc:	1007883a 	mov	r3,r2
 321aac0:	0080c974 	movhi	r2,805
 321aac4:	10922804 	addi	r2,r2,18592
 321aac8:	10c00015 	stw	r3,0(r2)
 321aacc:	e0bffc17 	ldw	r2,-16(fp)
 321aad0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321aad4:	e0bffa17 	ldw	r2,-24(fp)
 321aad8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
 321aadc:	e0bffd17 	ldw	r2,-12(fp)
 321aae0:	1005003a 	cmpeq	r2,r2,zero
 321aae4:	10000f1e 	bne	r2,zero,321ab24 <OSSemCreate+0xf4>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
 321aae8:	e0fffd17 	ldw	r3,-12(fp)
 321aaec:	008000c4 	movi	r2,3
 321aaf0:	18800005 	stb	r2,0(r3)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
 321aaf4:	e0fffd17 	ldw	r3,-12(fp)
 321aaf8:	e0bffe0b 	ldhu	r2,-8(fp)
 321aafc:	1880020d 	sth	r2,8(r3)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
 321ab00:	e0bffd17 	ldw	r2,-12(fp)
 321ab04:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
 321ab08:	e0fffd17 	ldw	r3,-12(fp)
 321ab0c:	00800fc4 	movi	r2,63
 321ab10:	18800385 	stb	r2,14(r3)
        pevent->OSEventName[1] = OS_ASCII_NUL;
 321ab14:	e0bffd17 	ldw	r2,-12(fp)
 321ab18:	100003c5 	stb	zero,15(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
 321ab1c:	e13ffd17 	ldw	r4,-12(fp)
 321ab20:	32167f80 	call	32167f8 <OS_EventWaitListInit>
    }
    return (pevent);
 321ab24:	e0bffd17 	ldw	r2,-12(fp)
 321ab28:	e0bfff15 	stw	r2,-4(fp)
 321ab2c:	e0bfff17 	ldw	r2,-4(fp)
}
 321ab30:	e037883a 	mov	sp,fp
 321ab34:	dfc00117 	ldw	ra,4(sp)
 321ab38:	df000017 	ldw	fp,0(sp)
 321ab3c:	dec00204 	addi	sp,sp,8
 321ab40:	f800283a 	ret

0321ab44 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 321ab44:	defff104 	addi	sp,sp,-60
 321ab48:	dfc00e15 	stw	ra,56(sp)
 321ab4c:	df000d15 	stw	fp,52(sp)
 321ab50:	df000d04 	addi	fp,sp,52
 321ab54:	e13ffb15 	stw	r4,-20(fp)
 321ab58:	e1bffd15 	stw	r6,-12(fp)
 321ab5c:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 321ab60:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 321ab64:	e0bffd17 	ldw	r2,-12(fp)
 321ab68:	1004c03a 	cmpne	r2,r2,zero
 321ab6c:	1000031e 	bne	r2,zero,321ab7c <OSSemDel+0x38>
        return (pevent);
 321ab70:	e0bffb17 	ldw	r2,-20(fp)
 321ab74:	e0bfff15 	stw	r2,-4(fp)
 321ab78:	00009406 	br	321adcc <OSSemDel+0x288>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 321ab7c:	e0bffb17 	ldw	r2,-20(fp)
 321ab80:	1004c03a 	cmpne	r2,r2,zero
 321ab84:	1000061e 	bne	r2,zero,321aba0 <OSSemDel+0x5c>
        *perr = OS_ERR_PEVENT_NULL;
 321ab88:	e0fffd17 	ldw	r3,-12(fp)
 321ab8c:	00800104 	movi	r2,4
 321ab90:	18800005 	stb	r2,0(r3)
        return (pevent);
 321ab94:	e0fffb17 	ldw	r3,-20(fp)
 321ab98:	e0ffff15 	stw	r3,-4(fp)
 321ab9c:	00008b06 	br	321adcc <OSSemDel+0x288>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 321aba0:	e0bffb17 	ldw	r2,-20(fp)
 321aba4:	10800003 	ldbu	r2,0(r2)
 321aba8:	10803fcc 	andi	r2,r2,255
 321abac:	108000e0 	cmpeqi	r2,r2,3
 321abb0:	1000061e 	bne	r2,zero,321abcc <OSSemDel+0x88>
        *perr = OS_ERR_EVENT_TYPE;
 321abb4:	e0fffd17 	ldw	r3,-12(fp)
 321abb8:	00800044 	movi	r2,1
 321abbc:	18800005 	stb	r2,0(r3)
        return (pevent);
 321abc0:	e0bffb17 	ldw	r2,-20(fp)
 321abc4:	e0bfff15 	stw	r2,-4(fp)
 321abc8:	00008006 	br	321adcc <OSSemDel+0x288>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 321abcc:	0080c974 	movhi	r2,805
 321abd0:	10922904 	addi	r2,r2,18596
 321abd4:	10800003 	ldbu	r2,0(r2)
 321abd8:	10803fcc 	andi	r2,r2,255
 321abdc:	1005003a 	cmpeq	r2,r2,zero
 321abe0:	1000061e 	bne	r2,zero,321abfc <OSSemDel+0xb8>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 321abe4:	e0fffd17 	ldw	r3,-12(fp)
 321abe8:	008003c4 	movi	r2,15
 321abec:	18800005 	stb	r2,0(r3)
        return (pevent);
 321abf0:	e0fffb17 	ldw	r3,-20(fp)
 321abf4:	e0ffff15 	stw	r3,-4(fp)
 321abf8:	00007406 	br	321adcc <OSSemDel+0x288>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321abfc:	0005303a 	rdctl	r2,status
 321ac00:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321ac04:	e0fff717 	ldw	r3,-36(fp)
 321ac08:	00bfff84 	movi	r2,-2
 321ac0c:	1884703a 	and	r2,r3,r2
 321ac10:	1001703a 	wrctl	status,r2
  
  return context;
 321ac14:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 321ac18:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
 321ac1c:	e0bffb17 	ldw	r2,-20(fp)
 321ac20:	10800283 	ldbu	r2,10(r2)
 321ac24:	10803fcc 	andi	r2,r2,255
 321ac28:	1005003a 	cmpeq	r2,r2,zero
 321ac2c:	1000031e 	bne	r2,zero,321ac3c <OSSemDel+0xf8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 321ac30:	00800044 	movi	r2,1
 321ac34:	e0bffa05 	stb	r2,-24(fp)
 321ac38:	00000106 	br	321ac40 <OSSemDel+0xfc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 321ac3c:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 321ac40:	e0bffc03 	ldbu	r2,-16(fp)
 321ac44:	e0bffe15 	stw	r2,-8(fp)
 321ac48:	e0fffe17 	ldw	r3,-8(fp)
 321ac4c:	1805003a 	cmpeq	r2,r3,zero
 321ac50:	1000041e 	bne	r2,zero,321ac64 <OSSemDel+0x120>
 321ac54:	e0fffe17 	ldw	r3,-8(fp)
 321ac58:	18800060 	cmpeqi	r2,r3,1
 321ac5c:	10002d1e 	bne	r2,zero,321ad14 <OSSemDel+0x1d0>
 321ac60:	00004f06 	br	321ada0 <OSSemDel+0x25c>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
 321ac64:	e0bffa03 	ldbu	r2,-24(fp)
 321ac68:	1004c03a 	cmpne	r2,r2,zero
 321ac6c:	10001a1e 	bne	r2,zero,321acd8 <OSSemDel+0x194>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 321ac70:	e0fffb17 	ldw	r3,-20(fp)
 321ac74:	00800fc4 	movi	r2,63
 321ac78:	18800385 	stb	r2,14(r3)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 321ac7c:	e0bffb17 	ldw	r2,-20(fp)
 321ac80:	100003c5 	stb	zero,15(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 321ac84:	e0bffb17 	ldw	r2,-20(fp)
 321ac88:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 321ac8c:	0080c974 	movhi	r2,805
 321ac90:	10922804 	addi	r2,r2,18592
 321ac94:	10c00017 	ldw	r3,0(r2)
 321ac98:	e0bffb17 	ldw	r2,-20(fp)
 321ac9c:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 321aca0:	e0bffb17 	ldw	r2,-20(fp)
 321aca4:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 321aca8:	00c0c974 	movhi	r3,805
 321acac:	18d22804 	addi	r3,r3,18592
 321acb0:	e0bffb17 	ldw	r2,-20(fp)
 321acb4:	18800015 	stw	r2,0(r3)
 321acb8:	e0bff817 	ldw	r2,-32(fp)
 321acbc:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321acc0:	e0bff617 	ldw	r2,-40(fp)
 321acc4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 321acc8:	e0bffd17 	ldw	r2,-12(fp)
 321accc:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
 321acd0:	e03ff915 	stw	zero,-28(fp)
 321acd4:	00003b06 	br	321adc4 <OSSemDel+0x280>
 321acd8:	e0bff817 	ldw	r2,-32(fp)
 321acdc:	e0bff515 	stw	r2,-44(fp)
 321ace0:	e0bff517 	ldw	r2,-44(fp)
 321ace4:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 321ace8:	e0fffd17 	ldw	r3,-12(fp)
 321acec:	00801244 	movi	r2,73
 321acf0:	18800005 	stb	r2,0(r3)
                 pevent_return          = pevent;
 321acf4:	e0bffb17 	ldw	r2,-20(fp)
 321acf8:	e0bff915 	stw	r2,-28(fp)
             }
             break;
 321acfc:	00003106 	br	321adc4 <OSSemDel+0x280>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 321ad00:	e13ffb17 	ldw	r4,-20(fp)
 321ad04:	000b883a 	mov	r5,zero
 321ad08:	01800044 	movi	r6,1
 321ad0c:	000f883a 	mov	r7,zero
 321ad10:	32162440 	call	3216244 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
 321ad14:	e0bffb17 	ldw	r2,-20(fp)
 321ad18:	10800283 	ldbu	r2,10(r2)
 321ad1c:	10803fcc 	andi	r2,r2,255
 321ad20:	1004c03a 	cmpne	r2,r2,zero
 321ad24:	103ff61e 	bne	r2,zero,321ad00 <OSSemDel+0x1bc>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 321ad28:	e0fffb17 	ldw	r3,-20(fp)
 321ad2c:	00800fc4 	movi	r2,63
 321ad30:	18800385 	stb	r2,14(r3)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 321ad34:	e0bffb17 	ldw	r2,-20(fp)
 321ad38:	100003c5 	stb	zero,15(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 321ad3c:	e0bffb17 	ldw	r2,-20(fp)
 321ad40:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 321ad44:	0080c974 	movhi	r2,805
 321ad48:	10922804 	addi	r2,r2,18592
 321ad4c:	10c00017 	ldw	r3,0(r2)
 321ad50:	e0bffb17 	ldw	r2,-20(fp)
 321ad54:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 321ad58:	e0bffb17 	ldw	r2,-20(fp)
 321ad5c:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 321ad60:	00c0c974 	movhi	r3,805
 321ad64:	18d22804 	addi	r3,r3,18592
 321ad68:	e0bffb17 	ldw	r2,-20(fp)
 321ad6c:	18800015 	stw	r2,0(r3)
 321ad70:	e0bff817 	ldw	r2,-32(fp)
 321ad74:	e0bff415 	stw	r2,-48(fp)
 321ad78:	e0bff417 	ldw	r2,-48(fp)
 321ad7c:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 321ad80:	e0bffa03 	ldbu	r2,-24(fp)
 321ad84:	10800058 	cmpnei	r2,r2,1
 321ad88:	1000011e 	bne	r2,zero,321ad90 <OSSemDel+0x24c>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 321ad8c:	3216c840 	call	3216c84 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 321ad90:	e0bffd17 	ldw	r2,-12(fp)
 321ad94:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
 321ad98:	e03ff915 	stw	zero,-28(fp)
             break;
 321ad9c:	00000906 	br	321adc4 <OSSemDel+0x280>
 321ada0:	e0bff817 	ldw	r2,-32(fp)
 321ada4:	e0bff315 	stw	r2,-52(fp)
 321ada8:	e0bff317 	ldw	r2,-52(fp)
 321adac:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 321adb0:	e0fffd17 	ldw	r3,-12(fp)
 321adb4:	008001c4 	movi	r2,7
 321adb8:	18800005 	stb	r2,0(r3)
             pevent_return          = pevent;
 321adbc:	e0bffb17 	ldw	r2,-20(fp)
 321adc0:	e0bff915 	stw	r2,-28(fp)
             break;
    }
    return (pevent_return);
 321adc4:	e0bff917 	ldw	r2,-28(fp)
 321adc8:	e0bfff15 	stw	r2,-4(fp)
 321adcc:	e0bfff17 	ldw	r2,-4(fp)
}
 321add0:	e037883a 	mov	sp,fp
 321add4:	dfc00117 	ldw	ra,4(sp)
 321add8:	df000017 	ldw	fp,0(sp)
 321addc:	dec00204 	addi	sp,sp,8
 321ade0:	f800283a 	ret

0321ade4 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 321ade4:	defff404 	addi	sp,sp,-48
 321ade8:	dfc00b15 	stw	ra,44(sp)
 321adec:	df000a15 	stw	fp,40(sp)
 321adf0:	df000a04 	addi	fp,sp,40
 321adf4:	e13ffc15 	stw	r4,-16(fp)
 321adf8:	e1bffe15 	stw	r6,-8(fp)
 321adfc:	e17ffd0d 	sth	r5,-12(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 321ae00:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 321ae04:	e0bffe17 	ldw	r2,-8(fp)
 321ae08:	1005003a 	cmpeq	r2,r2,zero
 321ae0c:	10008f1e 	bne	r2,zero,321b04c <OSSemPend+0x268>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 321ae10:	e0bffc17 	ldw	r2,-16(fp)
 321ae14:	1004c03a 	cmpne	r2,r2,zero
 321ae18:	1000041e 	bne	r2,zero,321ae2c <OSSemPend+0x48>
        *perr = OS_ERR_PEVENT_NULL;
 321ae1c:	e0fffe17 	ldw	r3,-8(fp)
 321ae20:	00800104 	movi	r2,4
 321ae24:	18800005 	stb	r2,0(r3)
        return;
 321ae28:	00008806 	br	321b04c <OSSemPend+0x268>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 321ae2c:	e0bffc17 	ldw	r2,-16(fp)
 321ae30:	10800003 	ldbu	r2,0(r2)
 321ae34:	10803fcc 	andi	r2,r2,255
 321ae38:	108000e0 	cmpeqi	r2,r2,3
 321ae3c:	1000041e 	bne	r2,zero,321ae50 <OSSemPend+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 321ae40:	e0fffe17 	ldw	r3,-8(fp)
 321ae44:	00800044 	movi	r2,1
 321ae48:	18800005 	stb	r2,0(r3)
        return;
 321ae4c:	00007f06 	br	321b04c <OSSemPend+0x268>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 321ae50:	0080c974 	movhi	r2,805
 321ae54:	10922904 	addi	r2,r2,18596
 321ae58:	10800003 	ldbu	r2,0(r2)
 321ae5c:	10803fcc 	andi	r2,r2,255
 321ae60:	1005003a 	cmpeq	r2,r2,zero
 321ae64:	1000041e 	bne	r2,zero,321ae78 <OSSemPend+0x94>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
 321ae68:	e0fffe17 	ldw	r3,-8(fp)
 321ae6c:	00800084 	movi	r2,2
 321ae70:	18800005 	stb	r2,0(r3)
        return;
 321ae74:	00007506 	br	321b04c <OSSemPend+0x268>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
 321ae78:	0080c974 	movhi	r2,805
 321ae7c:	10921b04 	addi	r2,r2,18540
 321ae80:	10800003 	ldbu	r2,0(r2)
 321ae84:	10803fcc 	andi	r2,r2,255
 321ae88:	1005003a 	cmpeq	r2,r2,zero
 321ae8c:	1000041e 	bne	r2,zero,321aea0 <OSSemPend+0xbc>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
 321ae90:	e0fffe17 	ldw	r3,-8(fp)
 321ae94:	00800344 	movi	r2,13
 321ae98:	18800005 	stb	r2,0(r3)
        return;
 321ae9c:	00006b06 	br	321b04c <OSSemPend+0x268>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321aea0:	0005303a 	rdctl	r2,status
 321aea4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321aea8:	e0fffa17 	ldw	r3,-24(fp)
 321aeac:	00bfff84 	movi	r2,-2
 321aeb0:	1884703a 	and	r2,r3,r2
 321aeb4:	1001703a 	wrctl	status,r2
  
  return context;
 321aeb8:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 321aebc:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
 321aec0:	e0bffc17 	ldw	r2,-16(fp)
 321aec4:	1080020b 	ldhu	r2,8(r2)
 321aec8:	10bfffcc 	andi	r2,r2,65535
 321aecc:	1005003a 	cmpeq	r2,r2,zero
 321aed0:	10000d1e 	bne	r2,zero,321af08 <OSSemPend+0x124>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
 321aed4:	e0bffc17 	ldw	r2,-16(fp)
 321aed8:	1080020b 	ldhu	r2,8(r2)
 321aedc:	10bfffc4 	addi	r2,r2,-1
 321aee0:	1007883a 	mov	r3,r2
 321aee4:	e0bffc17 	ldw	r2,-16(fp)
 321aee8:	10c0020d 	sth	r3,8(r2)
 321aeec:	e0bffb17 	ldw	r2,-20(fp)
 321aef0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321aef4:	e0bff917 	ldw	r2,-28(fp)
 321aef8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 321aefc:	e0bffe17 	ldw	r2,-8(fp)
 321af00:	10000005 	stb	zero,0(r2)
        return;
 321af04:	00005106 	br	321b04c <OSSemPend+0x268>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
 321af08:	0080c974 	movhi	r2,805
 321af0c:	10922a04 	addi	r2,r2,18600
 321af10:	10c00017 	ldw	r3,0(r2)
 321af14:	0080c974 	movhi	r2,805
 321af18:	10922a04 	addi	r2,r2,18600
 321af1c:	10800017 	ldw	r2,0(r2)
 321af20:	10800c03 	ldbu	r2,48(r2)
 321af24:	10800054 	ori	r2,r2,1
 321af28:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 321af2c:	0080c974 	movhi	r2,805
 321af30:	10922a04 	addi	r2,r2,18600
 321af34:	10800017 	ldw	r2,0(r2)
 321af38:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
 321af3c:	0080c974 	movhi	r2,805
 321af40:	10922a04 	addi	r2,r2,18600
 321af44:	10c00017 	ldw	r3,0(r2)
 321af48:	e0bffd0b 	ldhu	r2,-12(fp)
 321af4c:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 321af50:	e13ffc17 	ldw	r4,-16(fp)
 321af54:	32163d80 	call	32163d8 <OS_EventTaskWait>
 321af58:	e0bffb17 	ldw	r2,-20(fp)
 321af5c:	e0bff815 	stw	r2,-32(fp)
 321af60:	e0bff817 	ldw	r2,-32(fp)
 321af64:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
 321af68:	3216c840 	call	3216c84 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321af6c:	0005303a 	rdctl	r2,status
 321af70:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321af74:	e0fff717 	ldw	r3,-36(fp)
 321af78:	00bfff84 	movi	r2,-2
 321af7c:	1884703a 	and	r2,r3,r2
 321af80:	1001703a 	wrctl	status,r2
  
  return context;
 321af84:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 321af88:	e0bffb15 	stw	r2,-20(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 321af8c:	0080c974 	movhi	r2,805
 321af90:	10922a04 	addi	r2,r2,18600
 321af94:	10800017 	ldw	r2,0(r2)
 321af98:	10800c43 	ldbu	r2,49(r2)
 321af9c:	10803fcc 	andi	r2,r2,255
 321afa0:	e0bfff15 	stw	r2,-4(fp)
 321afa4:	e0ffff17 	ldw	r3,-4(fp)
 321afa8:	1805003a 	cmpeq	r2,r3,zero
 321afac:	1000041e 	bne	r2,zero,321afc0 <OSSemPend+0x1dc>
 321afb0:	e0ffff17 	ldw	r3,-4(fp)
 321afb4:	188000a0 	cmpeqi	r2,r3,2
 321afb8:	1000041e 	bne	r2,zero,321afcc <OSSemPend+0x1e8>
 321afbc:	00000706 	br	321afdc <OSSemPend+0x1f8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
 321afc0:	e0bffe17 	ldw	r2,-8(fp)
 321afc4:	10000005 	stb	zero,0(r2)
             break;
 321afc8:	00000c06 	br	321affc <OSSemPend+0x218>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 321afcc:	e0fffe17 	ldw	r3,-8(fp)
 321afd0:	00800384 	movi	r2,14
 321afd4:	18800005 	stb	r2,0(r3)
             break;
 321afd8:	00000806 	br	321affc <OSSemPend+0x218>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
 321afdc:	0080c974 	movhi	r2,805
 321afe0:	10922a04 	addi	r2,r2,18600
 321afe4:	11000017 	ldw	r4,0(r2)
 321afe8:	e17ffc17 	ldw	r5,-16(fp)
 321afec:	321663c0 	call	321663c <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 321aff0:	e0fffe17 	ldw	r3,-8(fp)
 321aff4:	00800284 	movi	r2,10
 321aff8:	18800005 	stb	r2,0(r3)
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 321affc:	0080c974 	movhi	r2,805
 321b000:	10922a04 	addi	r2,r2,18600
 321b004:	10800017 	ldw	r2,0(r2)
 321b008:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 321b00c:	0080c974 	movhi	r2,805
 321b010:	10922a04 	addi	r2,r2,18600
 321b014:	10800017 	ldw	r2,0(r2)
 321b018:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 321b01c:	0080c974 	movhi	r2,805
 321b020:	10922a04 	addi	r2,r2,18600
 321b024:	10800017 	ldw	r2,0(r2)
 321b028:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 321b02c:	0080c974 	movhi	r2,805
 321b030:	10922a04 	addi	r2,r2,18600
 321b034:	10800017 	ldw	r2,0(r2)
 321b038:	10000815 	stw	zero,32(r2)
 321b03c:	e0bffb17 	ldw	r2,-20(fp)
 321b040:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321b044:	e0bff617 	ldw	r2,-40(fp)
 321b048:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
}
 321b04c:	e037883a 	mov	sp,fp
 321b050:	dfc00117 	ldw	ra,4(sp)
 321b054:	df000017 	ldw	fp,0(sp)
 321b058:	dec00204 	addi	sp,sp,8
 321b05c:	f800283a 	ret

0321b060 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 321b060:	defff504 	addi	sp,sp,-44
 321b064:	dfc00a15 	stw	ra,40(sp)
 321b068:	df000915 	stw	fp,36(sp)
 321b06c:	df000904 	addi	fp,sp,36
 321b070:	e13ffc15 	stw	r4,-16(fp)
 321b074:	e1bffe15 	stw	r6,-8(fp)
 321b078:	e17ffd05 	stb	r5,-12(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 321b07c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 321b080:	e0bffe17 	ldw	r2,-8(fp)
 321b084:	1004c03a 	cmpne	r2,r2,zero
 321b088:	1000021e 	bne	r2,zero,321b094 <OSSemPendAbort+0x34>
        return (0);
 321b08c:	e03fff15 	stw	zero,-4(fp)
 321b090:	00004c06 	br	321b1c4 <OSSemPendAbort+0x164>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 321b094:	e0bffc17 	ldw	r2,-16(fp)
 321b098:	1004c03a 	cmpne	r2,r2,zero
 321b09c:	1000051e 	bne	r2,zero,321b0b4 <OSSemPendAbort+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 321b0a0:	e0fffe17 	ldw	r3,-8(fp)
 321b0a4:	00800104 	movi	r2,4
 321b0a8:	18800005 	stb	r2,0(r3)
        return (0);
 321b0ac:	e03fff15 	stw	zero,-4(fp)
 321b0b0:	00004406 	br	321b1c4 <OSSemPendAbort+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 321b0b4:	e0bffc17 	ldw	r2,-16(fp)
 321b0b8:	10800003 	ldbu	r2,0(r2)
 321b0bc:	10803fcc 	andi	r2,r2,255
 321b0c0:	108000e0 	cmpeqi	r2,r2,3
 321b0c4:	1000051e 	bne	r2,zero,321b0dc <OSSemPendAbort+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 321b0c8:	e0fffe17 	ldw	r3,-8(fp)
 321b0cc:	00800044 	movi	r2,1
 321b0d0:	18800005 	stb	r2,0(r3)
        return (0);
 321b0d4:	e03fff15 	stw	zero,-4(fp)
 321b0d8:	00003a06 	br	321b1c4 <OSSemPendAbort+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321b0dc:	0005303a 	rdctl	r2,status
 321b0e0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321b0e4:	e0fff917 	ldw	r3,-28(fp)
 321b0e8:	00bfff84 	movi	r2,-2
 321b0ec:	1884703a 	and	r2,r3,r2
 321b0f0:	1001703a 	wrctl	status,r2
  
  return context;
 321b0f4:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 321b0f8:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
 321b0fc:	e0bffc17 	ldw	r2,-16(fp)
 321b100:	10800283 	ldbu	r2,10(r2)
 321b104:	10803fcc 	andi	r2,r2,255
 321b108:	1005003a 	cmpeq	r2,r2,zero
 321b10c:	1000261e 	bne	r2,zero,321b1a8 <OSSemPendAbort+0x148>
        nbr_tasks = 0;
 321b110:	e03ffb05 	stb	zero,-20(fp)
        switch (opt) {
 321b114:	e0bffd03 	ldbu	r2,-12(fp)
 321b118:	10800060 	cmpeqi	r2,r2,1
 321b11c:	1000091e 	bne	r2,zero,321b144 <OSSemPendAbort+0xe4>
 321b120:	00000e06 	br	321b15c <OSSemPendAbort+0xfc>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 321b124:	e13ffc17 	ldw	r4,-16(fp)
 321b128:	000b883a 	mov	r5,zero
 321b12c:	01800044 	movi	r6,1
 321b130:	01c00084 	movi	r7,2
 321b134:	32162440 	call	3216244 <OS_EventTaskRdy>
                     nbr_tasks++;
 321b138:	e0bffb03 	ldbu	r2,-20(fp)
 321b13c:	10800044 	addi	r2,r2,1
 321b140:	e0bffb05 	stb	r2,-20(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 321b144:	e0bffc17 	ldw	r2,-16(fp)
 321b148:	10800283 	ldbu	r2,10(r2)
 321b14c:	10803fcc 	andi	r2,r2,255
 321b150:	1004c03a 	cmpne	r2,r2,zero
 321b154:	103ff31e 	bne	r2,zero,321b124 <OSSemPendAbort+0xc4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 321b158:	00000806 	br	321b17c <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 321b15c:	e13ffc17 	ldw	r4,-16(fp)
 321b160:	000b883a 	mov	r5,zero
 321b164:	01800044 	movi	r6,1
 321b168:	01c00084 	movi	r7,2
 321b16c:	32162440 	call	3216244 <OS_EventTaskRdy>
                 nbr_tasks++;
 321b170:	e0bffb03 	ldbu	r2,-20(fp)
 321b174:	10800044 	addi	r2,r2,1
 321b178:	e0bffb05 	stb	r2,-20(fp)
 321b17c:	e0bffa17 	ldw	r2,-24(fp)
 321b180:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321b184:	e0bff817 	ldw	r2,-32(fp)
 321b188:	1001703a 	wrctl	status,r2
                 break;
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 321b18c:	3216c840 	call	3216c84 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 321b190:	e0fffe17 	ldw	r3,-8(fp)
 321b194:	00800384 	movi	r2,14
 321b198:	18800005 	stb	r2,0(r3)
        return (nbr_tasks);
 321b19c:	e0bffb03 	ldbu	r2,-20(fp)
 321b1a0:	e0bfff15 	stw	r2,-4(fp)
 321b1a4:	00000706 	br	321b1c4 <OSSemPendAbort+0x164>
 321b1a8:	e0bffa17 	ldw	r2,-24(fp)
 321b1ac:	e0bff715 	stw	r2,-36(fp)
 321b1b0:	e0bff717 	ldw	r2,-36(fp)
 321b1b4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 321b1b8:	e0bffe17 	ldw	r2,-8(fp)
 321b1bc:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
 321b1c0:	e03fff15 	stw	zero,-4(fp)
 321b1c4:	e0bfff17 	ldw	r2,-4(fp)
}
 321b1c8:	e037883a 	mov	sp,fp
 321b1cc:	dfc00117 	ldw	ra,4(sp)
 321b1d0:	df000017 	ldw	fp,0(sp)
 321b1d4:	dec00204 	addi	sp,sp,8
 321b1d8:	f800283a 	ret

0321b1dc <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
 321b1dc:	defff704 	addi	sp,sp,-36
 321b1e0:	dfc00815 	stw	ra,32(sp)
 321b1e4:	df000715 	stw	fp,28(sp)
 321b1e8:	df000704 	addi	fp,sp,28
 321b1ec:	e13ffe15 	stw	r4,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 321b1f0:	e03ffd15 	stw	zero,-12(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 321b1f4:	e0bffe17 	ldw	r2,-8(fp)
 321b1f8:	1004c03a 	cmpne	r2,r2,zero
 321b1fc:	1000031e 	bne	r2,zero,321b20c <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
 321b200:	00800104 	movi	r2,4
 321b204:	e0bfff15 	stw	r2,-4(fp)
 321b208:	00003806 	br	321b2ec <OSSemPost+0x110>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 321b20c:	e0bffe17 	ldw	r2,-8(fp)
 321b210:	10800003 	ldbu	r2,0(r2)
 321b214:	10803fcc 	andi	r2,r2,255
 321b218:	108000e0 	cmpeqi	r2,r2,3
 321b21c:	1000031e 	bne	r2,zero,321b22c <OSSemPost+0x50>
        return (OS_ERR_EVENT_TYPE);
 321b220:	00800044 	movi	r2,1
 321b224:	e0bfff15 	stw	r2,-4(fp)
 321b228:	00003006 	br	321b2ec <OSSemPost+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321b22c:	0005303a 	rdctl	r2,status
 321b230:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321b234:	e0fffc17 	ldw	r3,-16(fp)
 321b238:	00bfff84 	movi	r2,-2
 321b23c:	1884703a 	and	r2,r3,r2
 321b240:	1001703a 	wrctl	status,r2
  
  return context;
 321b244:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 321b248:	e0bffd15 	stw	r2,-12(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
 321b24c:	e0bffe17 	ldw	r2,-8(fp)
 321b250:	10800283 	ldbu	r2,10(r2)
 321b254:	10803fcc 	andi	r2,r2,255
 321b258:	1005003a 	cmpeq	r2,r2,zero
 321b25c:	10000c1e 	bne	r2,zero,321b290 <OSSemPost+0xb4>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 321b260:	e13ffe17 	ldw	r4,-8(fp)
 321b264:	000b883a 	mov	r5,zero
 321b268:	01800044 	movi	r6,1
 321b26c:	000f883a 	mov	r7,zero
 321b270:	32162440 	call	3216244 <OS_EventTaskRdy>
 321b274:	e0bffd17 	ldw	r2,-12(fp)
 321b278:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321b27c:	e0bffb17 	ldw	r2,-20(fp)
 321b280:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 321b284:	3216c840 	call	3216c84 <OS_Sched>
        return (OS_ERR_NONE);
 321b288:	e03fff15 	stw	zero,-4(fp)
 321b28c:	00001706 	br	321b2ec <OSSemPost+0x110>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
 321b290:	e0bffe17 	ldw	r2,-8(fp)
 321b294:	1080020b 	ldhu	r2,8(r2)
 321b298:	10ffffcc 	andi	r3,r2,65535
 321b29c:	00bfffd4 	movui	r2,65535
 321b2a0:	18800c26 	beq	r3,r2,321b2d4 <OSSemPost+0xf8>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
 321b2a4:	e0bffe17 	ldw	r2,-8(fp)
 321b2a8:	1080020b 	ldhu	r2,8(r2)
 321b2ac:	10800044 	addi	r2,r2,1
 321b2b0:	1007883a 	mov	r3,r2
 321b2b4:	e0bffe17 	ldw	r2,-8(fp)
 321b2b8:	10c0020d 	sth	r3,8(r2)
 321b2bc:	e0bffd17 	ldw	r2,-12(fp)
 321b2c0:	e0bffa15 	stw	r2,-24(fp)
 321b2c4:	e0bffa17 	ldw	r2,-24(fp)
 321b2c8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 321b2cc:	e03fff15 	stw	zero,-4(fp)
 321b2d0:	00000606 	br	321b2ec <OSSemPost+0x110>
 321b2d4:	e0bffd17 	ldw	r2,-12(fp)
 321b2d8:	e0bff915 	stw	r2,-28(fp)
 321b2dc:	e0bff917 	ldw	r2,-28(fp)
 321b2e0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
 321b2e4:	00800c84 	movi	r2,50
 321b2e8:	e0bfff15 	stw	r2,-4(fp)
 321b2ec:	e0bfff17 	ldw	r2,-4(fp)
}
 321b2f0:	e037883a 	mov	sp,fp
 321b2f4:	dfc00117 	ldw	ra,4(sp)
 321b2f8:	df000017 	ldw	fp,0(sp)
 321b2fc:	dec00204 	addi	sp,sp,8
 321b300:	f800283a 	ret

0321b304 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
 321b304:	defff604 	addi	sp,sp,-40
 321b308:	df000915 	stw	fp,36(sp)
 321b30c:	df000904 	addi	fp,sp,36
 321b310:	e13ffd15 	stw	r4,-12(fp)
 321b314:	e17ffe15 	stw	r5,-8(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 321b318:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 321b31c:	e0bffd17 	ldw	r2,-12(fp)
 321b320:	1004c03a 	cmpne	r2,r2,zero
 321b324:	1000031e 	bne	r2,zero,321b334 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
 321b328:	00800104 	movi	r2,4
 321b32c:	e0bfff15 	stw	r2,-4(fp)
 321b330:	00003b06 	br	321b420 <OSSemQuery+0x11c>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
 321b334:	e0bffe17 	ldw	r2,-8(fp)
 321b338:	1004c03a 	cmpne	r2,r2,zero
 321b33c:	1000031e 	bne	r2,zero,321b34c <OSSemQuery+0x48>
        return (OS_ERR_PDATA_NULL);
 321b340:	00800244 	movi	r2,9
 321b344:	e0bfff15 	stw	r2,-4(fp)
 321b348:	00003506 	br	321b420 <OSSemQuery+0x11c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 321b34c:	e0bffd17 	ldw	r2,-12(fp)
 321b350:	10800003 	ldbu	r2,0(r2)
 321b354:	10803fcc 	andi	r2,r2,255
 321b358:	108000e0 	cmpeqi	r2,r2,3
 321b35c:	1000031e 	bne	r2,zero,321b36c <OSSemQuery+0x68>
        return (OS_ERR_EVENT_TYPE);
 321b360:	00800044 	movi	r2,1
 321b364:	e0bfff15 	stw	r2,-4(fp)
 321b368:	00002d06 	br	321b420 <OSSemQuery+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321b36c:	0005303a 	rdctl	r2,status
 321b370:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321b374:	e0fff817 	ldw	r3,-32(fp)
 321b378:	00bfff84 	movi	r2,-2
 321b37c:	1884703a 	and	r2,r3,r2
 321b380:	1001703a 	wrctl	status,r2
  
  return context;
 321b384:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 321b388:	e0bff915 	stw	r2,-28(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
 321b38c:	e0bffd17 	ldw	r2,-12(fp)
 321b390:	10c00283 	ldbu	r3,10(r2)
 321b394:	e0bffe17 	ldw	r2,-8(fp)
 321b398:	10c00145 	stb	r3,5(r2)
    psrc                   = &pevent->OSEventTbl[0];
 321b39c:	e0bffd17 	ldw	r2,-12(fp)
 321b3a0:	108002c4 	addi	r2,r2,11
 321b3a4:	e0bffc15 	stw	r2,-16(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
 321b3a8:	e0bffe17 	ldw	r2,-8(fp)
 321b3ac:	10800084 	addi	r2,r2,2
 321b3b0:	e0bffb15 	stw	r2,-20(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 321b3b4:	e03ffa05 	stb	zero,-24(fp)
 321b3b8:	00000d06 	br	321b3f0 <OSSemQuery+0xec>
        *pdest++ = *psrc++;
 321b3bc:	e0bffc17 	ldw	r2,-16(fp)
 321b3c0:	10c00003 	ldbu	r3,0(r2)
 321b3c4:	e0bffb17 	ldw	r2,-20(fp)
 321b3c8:	10c00005 	stb	r3,0(r2)
 321b3cc:	e0bffb17 	ldw	r2,-20(fp)
 321b3d0:	10800044 	addi	r2,r2,1
 321b3d4:	e0bffb15 	stw	r2,-20(fp)
 321b3d8:	e0bffc17 	ldw	r2,-16(fp)
 321b3dc:	10800044 	addi	r2,r2,1
 321b3e0:	e0bffc15 	stw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 321b3e4:	e0bffa03 	ldbu	r2,-24(fp)
 321b3e8:	10800044 	addi	r2,r2,1
 321b3ec:	e0bffa05 	stb	r2,-24(fp)
 321b3f0:	e0bffa03 	ldbu	r2,-24(fp)
 321b3f4:	108000f0 	cmpltui	r2,r2,3
 321b3f8:	103ff01e 	bne	r2,zero,321b3bc <OSSemQuery+0xb8>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
 321b3fc:	e0bffd17 	ldw	r2,-12(fp)
 321b400:	10c0020b 	ldhu	r3,8(r2)
 321b404:	e0bffe17 	ldw	r2,-8(fp)
 321b408:	10c0000d 	sth	r3,0(r2)
 321b40c:	e0bff917 	ldw	r2,-28(fp)
 321b410:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321b414:	e0bff717 	ldw	r2,-36(fp)
 321b418:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 321b41c:	e03fff15 	stw	zero,-4(fp)
 321b420:	e0bfff17 	ldw	r2,-4(fp)
}
 321b424:	e037883a 	mov	sp,fp
 321b428:	df000017 	ldw	fp,0(sp)
 321b42c:	dec00104 	addi	sp,sp,4
 321b430:	f800283a 	ret

0321b434 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
 321b434:	defff904 	addi	sp,sp,-28
 321b438:	df000615 	stw	fp,24(sp)
 321b43c:	df000604 	addi	fp,sp,24
 321b440:	e13ffd15 	stw	r4,-12(fp)
 321b444:	e1bfff15 	stw	r6,-4(fp)
 321b448:	e17ffe0d 	sth	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 321b44c:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 321b450:	e0bfff17 	ldw	r2,-4(fp)
 321b454:	1005003a 	cmpeq	r2,r2,zero
 321b458:	1000331e 	bne	r2,zero,321b528 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 321b45c:	e0bffd17 	ldw	r2,-12(fp)
 321b460:	1004c03a 	cmpne	r2,r2,zero
 321b464:	1000041e 	bne	r2,zero,321b478 <OSSemSet+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 321b468:	e0ffff17 	ldw	r3,-4(fp)
 321b46c:	00800104 	movi	r2,4
 321b470:	18800005 	stb	r2,0(r3)
        return;
 321b474:	00002c06 	br	321b528 <OSSemSet+0xf4>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 321b478:	e0bffd17 	ldw	r2,-12(fp)
 321b47c:	10800003 	ldbu	r2,0(r2)
 321b480:	10803fcc 	andi	r2,r2,255
 321b484:	108000e0 	cmpeqi	r2,r2,3
 321b488:	1000041e 	bne	r2,zero,321b49c <OSSemSet+0x68>
        *perr = OS_ERR_EVENT_TYPE;
 321b48c:	e0ffff17 	ldw	r3,-4(fp)
 321b490:	00800044 	movi	r2,1
 321b494:	18800005 	stb	r2,0(r3)
        return;
 321b498:	00002306 	br	321b528 <OSSemSet+0xf4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321b49c:	0005303a 	rdctl	r2,status
 321b4a0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321b4a4:	e0fffb17 	ldw	r3,-20(fp)
 321b4a8:	00bfff84 	movi	r2,-2
 321b4ac:	1884703a 	and	r2,r3,r2
 321b4b0:	1001703a 	wrctl	status,r2
  
  return context;
 321b4b4:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 321b4b8:	e0bffc15 	stw	r2,-16(fp)
    *perr = OS_ERR_NONE;
 321b4bc:	e0bfff17 	ldw	r2,-4(fp)
 321b4c0:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
 321b4c4:	e0bffd17 	ldw	r2,-12(fp)
 321b4c8:	1080020b 	ldhu	r2,8(r2)
 321b4cc:	10bfffcc 	andi	r2,r2,65535
 321b4d0:	1005003a 	cmpeq	r2,r2,zero
 321b4d4:	1000041e 	bne	r2,zero,321b4e8 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
 321b4d8:	e0fffd17 	ldw	r3,-12(fp)
 321b4dc:	e0bffe0b 	ldhu	r2,-8(fp)
 321b4e0:	1880020d 	sth	r2,8(r3)
 321b4e4:	00000c06 	br	321b518 <OSSemSet+0xe4>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
 321b4e8:	e0bffd17 	ldw	r2,-12(fp)
 321b4ec:	10800283 	ldbu	r2,10(r2)
 321b4f0:	10803fcc 	andi	r2,r2,255
 321b4f4:	1004c03a 	cmpne	r2,r2,zero
 321b4f8:	1000041e 	bne	r2,zero,321b50c <OSSemSet+0xd8>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
 321b4fc:	e0fffd17 	ldw	r3,-12(fp)
 321b500:	e0bffe0b 	ldhu	r2,-8(fp)
 321b504:	1880020d 	sth	r2,8(r3)
 321b508:	00000306 	br	321b518 <OSSemSet+0xe4>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
 321b50c:	e0ffff17 	ldw	r3,-4(fp)
 321b510:	00801244 	movi	r2,73
 321b514:	18800005 	stb	r2,0(r3)
 321b518:	e0bffc17 	ldw	r2,-16(fp)
 321b51c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321b520:	e0bffa17 	ldw	r2,-24(fp)
 321b524:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
}
 321b528:	e037883a 	mov	sp,fp
 321b52c:	df000017 	ldw	fp,0(sp)
 321b530:	dec00104 	addi	sp,sp,4
 321b534:	f800283a 	ret

0321b538 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
 321b538:	defff004 	addi	sp,sp,-64
 321b53c:	dfc00f15 	stw	ra,60(sp)
 321b540:	df000e15 	stw	fp,56(sp)
 321b544:	df000e04 	addi	fp,sp,56
 321b548:	e13ffd05 	stb	r4,-12(fp)
 321b54c:	e17ffe05 	stb	r5,-8(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
 321b550:	e03ff715 	stw	zero,-36(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
 321b554:	e0bffd03 	ldbu	r2,-12(fp)
 321b558:	10800530 	cmpltui	r2,r2,20
 321b55c:	1000061e 	bne	r2,zero,321b578 <OSTaskChangePrio+0x40>
        if (oldprio != OS_PRIO_SELF) {
 321b560:	e0bffd03 	ldbu	r2,-12(fp)
 321b564:	10803fe0 	cmpeqi	r2,r2,255
 321b568:	1000031e 	bne	r2,zero,321b578 <OSTaskChangePrio+0x40>
            return (OS_ERR_PRIO_INVALID);
 321b56c:	00800a84 	movi	r2,42
 321b570:	e0bfff15 	stw	r2,-4(fp)
 321b574:	00014706 	br	321ba94 <OSTaskChangePrio+0x55c>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
 321b578:	e0bffe03 	ldbu	r2,-8(fp)
 321b57c:	10800530 	cmpltui	r2,r2,20
 321b580:	1000031e 	bne	r2,zero,321b590 <OSTaskChangePrio+0x58>
        return (OS_ERR_PRIO_INVALID);
 321b584:	00800a84 	movi	r2,42
 321b588:	e0bfff15 	stw	r2,-4(fp)
 321b58c:	00014106 	br	321ba94 <OSTaskChangePrio+0x55c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321b590:	0005303a 	rdctl	r2,status
 321b594:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321b598:	e0fff617 	ldw	r3,-40(fp)
 321b59c:	00bfff84 	movi	r2,-2
 321b5a0:	1884703a 	and	r2,r3,r2
 321b5a4:	1001703a 	wrctl	status,r2
  
  return context;
 321b5a8:	e0bff617 	ldw	r2,-40(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 321b5ac:	e0bff715 	stw	r2,-36(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
 321b5b0:	e0bffe03 	ldbu	r2,-8(fp)
 321b5b4:	00c0c9b4 	movhi	r3,806
 321b5b8:	18f18004 	addi	r3,r3,-14848
 321b5bc:	1085883a 	add	r2,r2,r2
 321b5c0:	1085883a 	add	r2,r2,r2
 321b5c4:	10c5883a 	add	r2,r2,r3
 321b5c8:	10800017 	ldw	r2,0(r2)
 321b5cc:	1005003a 	cmpeq	r2,r2,zero
 321b5d0:	1000071e 	bne	r2,zero,321b5f0 <OSTaskChangePrio+0xb8>
 321b5d4:	e0bff717 	ldw	r2,-36(fp)
 321b5d8:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321b5dc:	e0bff517 	ldw	r2,-44(fp)
 321b5e0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
 321b5e4:	00800a04 	movi	r2,40
 321b5e8:	e0bfff15 	stw	r2,-4(fp)
 321b5ec:	00012906 	br	321ba94 <OSTaskChangePrio+0x55c>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
 321b5f0:	e0bffd03 	ldbu	r2,-12(fp)
 321b5f4:	10803fd8 	cmpnei	r2,r2,255
 321b5f8:	1000051e 	bne	r2,zero,321b610 <OSTaskChangePrio+0xd8>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
 321b5fc:	0080c974 	movhi	r2,805
 321b600:	10922a04 	addi	r2,r2,18600
 321b604:	10800017 	ldw	r2,0(r2)
 321b608:	10800c83 	ldbu	r2,50(r2)
 321b60c:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
 321b610:	e0bffd03 	ldbu	r2,-12(fp)
 321b614:	00c0c9b4 	movhi	r3,806
 321b618:	18f18004 	addi	r3,r3,-14848
 321b61c:	1085883a 	add	r2,r2,r2
 321b620:	1085883a 	add	r2,r2,r2
 321b624:	10c5883a 	add	r2,r2,r3
 321b628:	10800017 	ldw	r2,0(r2)
 321b62c:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
 321b630:	e0bffa17 	ldw	r2,-24(fp)
 321b634:	1004c03a 	cmpne	r2,r2,zero
 321b638:	1000071e 	bne	r2,zero,321b658 <OSTaskChangePrio+0x120>
 321b63c:	e0bff717 	ldw	r2,-36(fp)
 321b640:	e0bff415 	stw	r2,-48(fp)
 321b644:	e0bff417 	ldw	r2,-48(fp)
 321b648:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
 321b64c:	00800a44 	movi	r2,41
 321b650:	e0bfff15 	stw	r2,-4(fp)
 321b654:	00010f06 	br	321ba94 <OSTaskChangePrio+0x55c>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
 321b658:	e0bffa17 	ldw	r2,-24(fp)
 321b65c:	10800058 	cmpnei	r2,r2,1
 321b660:	1000071e 	bne	r2,zero,321b680 <OSTaskChangePrio+0x148>
 321b664:	e0bff717 	ldw	r2,-36(fp)
 321b668:	e0bff315 	stw	r2,-52(fp)
 321b66c:	e0bff317 	ldw	r2,-52(fp)
 321b670:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
 321b674:	008010c4 	movi	r2,67
 321b678:	e0bfff15 	stw	r2,-4(fp)
 321b67c:	00010506 	br	321ba94 <OSTaskChangePrio+0x55c>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
 321b680:	e0bffe03 	ldbu	r2,-8(fp)
 321b684:	1004d0fa 	srli	r2,r2,3
 321b688:	e0bff985 	stb	r2,-26(fp)
    x_new                 = (INT8U)(newprio & 0x07);
 321b68c:	e0bffe03 	ldbu	r2,-8(fp)
 321b690:	108001cc 	andi	r2,r2,7
 321b694:	e0bff945 	stb	r2,-27(fp)
    bity_new              = (INT8U)(1 << y_new);
 321b698:	e0fff983 	ldbu	r3,-26(fp)
 321b69c:	00800044 	movi	r2,1
 321b6a0:	10c4983a 	sll	r2,r2,r3
 321b6a4:	e0bff8c5 	stb	r2,-29(fp)
    bitx_new              = (INT8U)(1 << x_new);
 321b6a8:	e0fff943 	ldbu	r3,-27(fp)
 321b6ac:	00800044 	movi	r2,1
 321b6b0:	10c4983a 	sll	r2,r2,r3
 321b6b4:	e0bff885 	stb	r2,-30(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
 321b6b8:	e0bffd03 	ldbu	r2,-12(fp)
 321b6bc:	00c0c9b4 	movhi	r3,806
 321b6c0:	18f18004 	addi	r3,r3,-14848
 321b6c4:	1085883a 	add	r2,r2,r2
 321b6c8:	1085883a 	add	r2,r2,r2
 321b6cc:	10c5883a 	add	r2,r2,r3
 321b6d0:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
 321b6d4:	e0bffe03 	ldbu	r2,-8(fp)
 321b6d8:	00c0c9b4 	movhi	r3,806
 321b6dc:	18f18004 	addi	r3,r3,-14848
 321b6e0:	1085883a 	add	r2,r2,r2
 321b6e4:	1085883a 	add	r2,r2,r2
 321b6e8:	10c7883a 	add	r3,r2,r3
 321b6ec:	e0bffa17 	ldw	r2,-24(fp)
 321b6f0:	18800015 	stw	r2,0(r3)
    y_old                 =  ptcb->OSTCBY;
 321b6f4:	e0bffa17 	ldw	r2,-24(fp)
 321b6f8:	10800d03 	ldbu	r2,52(r2)
 321b6fc:	e0bff905 	stb	r2,-28(fp)
    bity_old              =  ptcb->OSTCBBitY;
 321b700:	e0bffa17 	ldw	r2,-24(fp)
 321b704:	10800d83 	ldbu	r2,54(r2)
 321b708:	e0bff845 	stb	r2,-31(fp)
    bitx_old              =  ptcb->OSTCBBitX;
 321b70c:	e0bffa17 	ldw	r2,-24(fp)
 321b710:	10800d43 	ldbu	r2,53(r2)
 321b714:	e0bff805 	stb	r2,-32(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
 321b718:	e0fff903 	ldbu	r3,-28(fp)
 321b71c:	0080c974 	movhi	r2,805
 321b720:	10922744 	addi	r2,r2,18589
 321b724:	10c5883a 	add	r2,r2,r3
 321b728:	10c00003 	ldbu	r3,0(r2)
 321b72c:	e0bff803 	ldbu	r2,-32(fp)
 321b730:	1884703a 	and	r2,r3,r2
 321b734:	10803fcc 	andi	r2,r2,255
 321b738:	1005003a 	cmpeq	r2,r2,zero
 321b73c:	1000381e 	bne	r2,zero,321b820 <OSTaskChangePrio+0x2e8>
         OSRdyTbl[y_old] &= ~bitx_old;
 321b740:	e13ff903 	ldbu	r4,-28(fp)
 321b744:	e0fff903 	ldbu	r3,-28(fp)
 321b748:	0080c974 	movhi	r2,805
 321b74c:	10922744 	addi	r2,r2,18589
 321b750:	10c5883a 	add	r2,r2,r3
 321b754:	10800003 	ldbu	r2,0(r2)
 321b758:	1007883a 	mov	r3,r2
 321b75c:	e0bff803 	ldbu	r2,-32(fp)
 321b760:	0084303a 	nor	r2,zero,r2
 321b764:	1884703a 	and	r2,r3,r2
 321b768:	1007883a 	mov	r3,r2
 321b76c:	0080c974 	movhi	r2,805
 321b770:	10922744 	addi	r2,r2,18589
 321b774:	1105883a 	add	r2,r2,r4
 321b778:	10c00005 	stb	r3,0(r2)
         if (OSRdyTbl[y_old] == 0) {
 321b77c:	e0fff903 	ldbu	r3,-28(fp)
 321b780:	0080c974 	movhi	r2,805
 321b784:	10922744 	addi	r2,r2,18589
 321b788:	10c5883a 	add	r2,r2,r3
 321b78c:	10800003 	ldbu	r2,0(r2)
 321b790:	10803fcc 	andi	r2,r2,255
 321b794:	1004c03a 	cmpne	r2,r2,zero
 321b798:	10000b1e 	bne	r2,zero,321b7c8 <OSTaskChangePrio+0x290>
             OSRdyGrp &= ~bity_old;
 321b79c:	e0bff843 	ldbu	r2,-31(fp)
 321b7a0:	0084303a 	nor	r2,zero,r2
 321b7a4:	1007883a 	mov	r3,r2
 321b7a8:	0080c974 	movhi	r2,805
 321b7ac:	10922704 	addi	r2,r2,18588
 321b7b0:	10800003 	ldbu	r2,0(r2)
 321b7b4:	1884703a 	and	r2,r3,r2
 321b7b8:	1007883a 	mov	r3,r2
 321b7bc:	0080c974 	movhi	r2,805
 321b7c0:	10922704 	addi	r2,r2,18588
 321b7c4:	10c00005 	stb	r3,0(r2)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
 321b7c8:	0080c974 	movhi	r2,805
 321b7cc:	10922704 	addi	r2,r2,18588
 321b7d0:	10c00003 	ldbu	r3,0(r2)
 321b7d4:	e0bff8c3 	ldbu	r2,-29(fp)
 321b7d8:	1884b03a 	or	r2,r3,r2
 321b7dc:	1007883a 	mov	r3,r2
 321b7e0:	0080c974 	movhi	r2,805
 321b7e4:	10922704 	addi	r2,r2,18588
 321b7e8:	10c00005 	stb	r3,0(r2)
         OSRdyTbl[y_new] |= bitx_new;
 321b7ec:	e13ff983 	ldbu	r4,-26(fp)
 321b7f0:	e0fff983 	ldbu	r3,-26(fp)
 321b7f4:	0080c974 	movhi	r2,805
 321b7f8:	10922744 	addi	r2,r2,18589
 321b7fc:	10c5883a 	add	r2,r2,r3
 321b800:	10c00003 	ldbu	r3,0(r2)
 321b804:	e0bff883 	ldbu	r2,-30(fp)
 321b808:	1884b03a 	or	r2,r3,r2
 321b80c:	1007883a 	mov	r3,r2
 321b810:	0080c974 	movhi	r2,805
 321b814:	10922744 	addi	r2,r2,18589
 321b818:	1105883a 	add	r2,r2,r4
 321b81c:	10c00005 	stb	r3,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
 321b820:	e0bffa17 	ldw	r2,-24(fp)
 321b824:	10800717 	ldw	r2,28(r2)
 321b828:	e0bffc15 	stw	r2,-16(fp)
    if (pevent != (OS_EVENT *)0) {
 321b82c:	e0bffc17 	ldw	r2,-16(fp)
 321b830:	1005003a 	cmpeq	r2,r2,zero
 321b834:	1000341e 	bne	r2,zero,321b908 <OSTaskChangePrio+0x3d0>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
 321b838:	e13ff903 	ldbu	r4,-28(fp)
 321b83c:	e0fff903 	ldbu	r3,-28(fp)
 321b840:	e0bffc17 	ldw	r2,-16(fp)
 321b844:	1885883a 	add	r2,r3,r2
 321b848:	10800204 	addi	r2,r2,8
 321b84c:	108000c3 	ldbu	r2,3(r2)
 321b850:	1007883a 	mov	r3,r2
 321b854:	e0bff803 	ldbu	r2,-32(fp)
 321b858:	0084303a 	nor	r2,zero,r2
 321b85c:	1884703a 	and	r2,r3,r2
 321b860:	1007883a 	mov	r3,r2
 321b864:	e0bffc17 	ldw	r2,-16(fp)
 321b868:	2085883a 	add	r2,r4,r2
 321b86c:	10800204 	addi	r2,r2,8
 321b870:	10c000c5 	stb	r3,3(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
 321b874:	e0fff903 	ldbu	r3,-28(fp)
 321b878:	e0bffc17 	ldw	r2,-16(fp)
 321b87c:	1885883a 	add	r2,r3,r2
 321b880:	10800204 	addi	r2,r2,8
 321b884:	108000c3 	ldbu	r2,3(r2)
 321b888:	10803fcc 	andi	r2,r2,255
 321b88c:	1004c03a 	cmpne	r2,r2,zero
 321b890:	1000091e 	bne	r2,zero,321b8b8 <OSTaskChangePrio+0x380>
            pevent->OSEventGrp    &= ~bity_old;
 321b894:	e0bffc17 	ldw	r2,-16(fp)
 321b898:	10800283 	ldbu	r2,10(r2)
 321b89c:	1007883a 	mov	r3,r2
 321b8a0:	e0bff843 	ldbu	r2,-31(fp)
 321b8a4:	0084303a 	nor	r2,zero,r2
 321b8a8:	1884703a 	and	r2,r3,r2
 321b8ac:	1007883a 	mov	r3,r2
 321b8b0:	e0bffc17 	ldw	r2,-16(fp)
 321b8b4:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
 321b8b8:	e0bffc17 	ldw	r2,-16(fp)
 321b8bc:	10c00283 	ldbu	r3,10(r2)
 321b8c0:	e0bff8c3 	ldbu	r2,-29(fp)
 321b8c4:	1884b03a 	or	r2,r3,r2
 321b8c8:	1007883a 	mov	r3,r2
 321b8cc:	e0bffc17 	ldw	r2,-16(fp)
 321b8d0:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
 321b8d4:	e13ff983 	ldbu	r4,-26(fp)
 321b8d8:	e0fff983 	ldbu	r3,-26(fp)
 321b8dc:	e0bffc17 	ldw	r2,-16(fp)
 321b8e0:	1885883a 	add	r2,r3,r2
 321b8e4:	10800204 	addi	r2,r2,8
 321b8e8:	10c000c3 	ldbu	r3,3(r2)
 321b8ec:	e0bff883 	ldbu	r2,-30(fp)
 321b8f0:	1884b03a 	or	r2,r3,r2
 321b8f4:	1007883a 	mov	r3,r2
 321b8f8:	e0bffc17 	ldw	r2,-16(fp)
 321b8fc:	2085883a 	add	r2,r4,r2
 321b900:	10800204 	addi	r2,r2,8
 321b904:	10c000c5 	stb	r3,3(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
 321b908:	e0bffa17 	ldw	r2,-24(fp)
 321b90c:	10800817 	ldw	r2,32(r2)
 321b910:	1005003a 	cmpeq	r2,r2,zero
 321b914:	1000441e 	bne	r2,zero,321ba28 <OSTaskChangePrio+0x4f0>
        pevents =  ptcb->OSTCBEventMultiPtr;
 321b918:	e0bffa17 	ldw	r2,-24(fp)
 321b91c:	10800817 	ldw	r2,32(r2)
 321b920:	e0bffb15 	stw	r2,-20(fp)
        pevent  = *pevents;
 321b924:	e0bffb17 	ldw	r2,-20(fp)
 321b928:	10800017 	ldw	r2,0(r2)
 321b92c:	e0bffc15 	stw	r2,-16(fp)
        while (pevent != (OS_EVENT *)0) {
 321b930:	00003a06 	br	321ba1c <OSTaskChangePrio+0x4e4>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
 321b934:	e13ff903 	ldbu	r4,-28(fp)
 321b938:	e0fff903 	ldbu	r3,-28(fp)
 321b93c:	e0bffc17 	ldw	r2,-16(fp)
 321b940:	1885883a 	add	r2,r3,r2
 321b944:	10800204 	addi	r2,r2,8
 321b948:	108000c3 	ldbu	r2,3(r2)
 321b94c:	1007883a 	mov	r3,r2
 321b950:	e0bff803 	ldbu	r2,-32(fp)
 321b954:	0084303a 	nor	r2,zero,r2
 321b958:	1884703a 	and	r2,r3,r2
 321b95c:	1007883a 	mov	r3,r2
 321b960:	e0bffc17 	ldw	r2,-16(fp)
 321b964:	2085883a 	add	r2,r4,r2
 321b968:	10800204 	addi	r2,r2,8
 321b96c:	10c000c5 	stb	r3,3(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
 321b970:	e0fff903 	ldbu	r3,-28(fp)
 321b974:	e0bffc17 	ldw	r2,-16(fp)
 321b978:	1885883a 	add	r2,r3,r2
 321b97c:	10800204 	addi	r2,r2,8
 321b980:	108000c3 	ldbu	r2,3(r2)
 321b984:	10803fcc 	andi	r2,r2,255
 321b988:	1004c03a 	cmpne	r2,r2,zero
 321b98c:	1000091e 	bne	r2,zero,321b9b4 <OSTaskChangePrio+0x47c>
                pevent->OSEventGrp    &= ~bity_old;
 321b990:	e0bffc17 	ldw	r2,-16(fp)
 321b994:	10800283 	ldbu	r2,10(r2)
 321b998:	1007883a 	mov	r3,r2
 321b99c:	e0bff843 	ldbu	r2,-31(fp)
 321b9a0:	0084303a 	nor	r2,zero,r2
 321b9a4:	1884703a 	and	r2,r3,r2
 321b9a8:	1007883a 	mov	r3,r2
 321b9ac:	e0bffc17 	ldw	r2,-16(fp)
 321b9b0:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
 321b9b4:	e0bffc17 	ldw	r2,-16(fp)
 321b9b8:	10c00283 	ldbu	r3,10(r2)
 321b9bc:	e0bff8c3 	ldbu	r2,-29(fp)
 321b9c0:	1884b03a 	or	r2,r3,r2
 321b9c4:	1007883a 	mov	r3,r2
 321b9c8:	e0bffc17 	ldw	r2,-16(fp)
 321b9cc:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
 321b9d0:	e13ff983 	ldbu	r4,-26(fp)
 321b9d4:	e0fff983 	ldbu	r3,-26(fp)
 321b9d8:	e0bffc17 	ldw	r2,-16(fp)
 321b9dc:	1885883a 	add	r2,r3,r2
 321b9e0:	10800204 	addi	r2,r2,8
 321b9e4:	10c000c3 	ldbu	r3,3(r2)
 321b9e8:	e0bff883 	ldbu	r2,-30(fp)
 321b9ec:	1884b03a 	or	r2,r3,r2
 321b9f0:	1007883a 	mov	r3,r2
 321b9f4:	e0bffc17 	ldw	r2,-16(fp)
 321b9f8:	2085883a 	add	r2,r4,r2
 321b9fc:	10800204 	addi	r2,r2,8
 321ba00:	10c000c5 	stb	r3,3(r2)
            pevents++;
 321ba04:	e0bffb17 	ldw	r2,-20(fp)
 321ba08:	10800104 	addi	r2,r2,4
 321ba0c:	e0bffb15 	stw	r2,-20(fp)
            pevent                     = *pevents;
 321ba10:	e0bffb17 	ldw	r2,-20(fp)
 321ba14:	10800017 	ldw	r2,0(r2)
 321ba18:	e0bffc15 	stw	r2,-16(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
 321ba1c:	e0bffc17 	ldw	r2,-16(fp)
 321ba20:	1004c03a 	cmpne	r2,r2,zero
 321ba24:	103fc31e 	bne	r2,zero,321b934 <OSTaskChangePrio+0x3fc>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
 321ba28:	e0fffa17 	ldw	r3,-24(fp)
 321ba2c:	e0bffe03 	ldbu	r2,-8(fp)
 321ba30:	18800c85 	stb	r2,50(r3)
    ptcb->OSTCBY    = y_new;
 321ba34:	e0fffa17 	ldw	r3,-24(fp)
 321ba38:	e0bff983 	ldbu	r2,-26(fp)
 321ba3c:	18800d05 	stb	r2,52(r3)
    ptcb->OSTCBX    = x_new;
 321ba40:	e0fffa17 	ldw	r3,-24(fp)
 321ba44:	e0bff943 	ldbu	r2,-27(fp)
 321ba48:	18800cc5 	stb	r2,51(r3)
    ptcb->OSTCBBitY = bity_new;
 321ba4c:	e0fffa17 	ldw	r3,-24(fp)
 321ba50:	e0bff8c3 	ldbu	r2,-29(fp)
 321ba54:	18800d85 	stb	r2,54(r3)
    ptcb->OSTCBBitX = bitx_new;
 321ba58:	e0fffa17 	ldw	r3,-24(fp)
 321ba5c:	e0bff883 	ldbu	r2,-30(fp)
 321ba60:	18800d45 	stb	r2,53(r3)
 321ba64:	e0bff717 	ldw	r2,-36(fp)
 321ba68:	e0bff215 	stw	r2,-56(fp)
 321ba6c:	e0bff217 	ldw	r2,-56(fp)
 321ba70:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 321ba74:	0080c974 	movhi	r2,805
 321ba78:	10921b44 	addi	r2,r2,18541
 321ba7c:	10800003 	ldbu	r2,0(r2)
 321ba80:	10803fcc 	andi	r2,r2,255
 321ba84:	10800058 	cmpnei	r2,r2,1
 321ba88:	1000011e 	bne	r2,zero,321ba90 <OSTaskChangePrio+0x558>
        OS_Sched();                                         /* Find new highest priority task          */
 321ba8c:	3216c840 	call	3216c84 <OS_Sched>
    }
    return (OS_ERR_NONE);
 321ba90:	e03fff15 	stw	zero,-4(fp)
 321ba94:	e0bfff17 	ldw	r2,-4(fp)
}
 321ba98:	e037883a 	mov	sp,fp
 321ba9c:	dfc00117 	ldw	ra,4(sp)
 321baa0:	df000017 	ldw	fp,0(sp)
 321baa4:	dec00204 	addi	sp,sp,8
 321baa8:	f800283a 	ret

0321baac <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
 321baac:	deffed04 	addi	sp,sp,-76
 321bab0:	dfc01215 	stw	ra,72(sp)
 321bab4:	df001115 	stw	fp,68(sp)
 321bab8:	df001104 	addi	fp,sp,68
 321babc:	e13ffb15 	stw	r4,-20(fp)
 321bac0:	e17ffc15 	stw	r5,-16(fp)
 321bac4:	e1bffd15 	stw	r6,-12(fp)
 321bac8:	e1fffe05 	stb	r7,-8(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 321bacc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 321bad0:	e0bffe03 	ldbu	r2,-8(fp)
 321bad4:	10800570 	cmpltui	r2,r2,21
 321bad8:	1000031e 	bne	r2,zero,321bae8 <OSTaskCreate+0x3c>
        return (OS_ERR_PRIO_INVALID);
 321badc:	00800a84 	movi	r2,42
 321bae0:	e0bfff15 	stw	r2,-4(fp)
 321bae4:	00006006 	br	321bc68 <OSTaskCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321bae8:	0005303a 	rdctl	r2,status
 321baec:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321baf0:	e0fff717 	ldw	r3,-36(fp)
 321baf4:	00bfff84 	movi	r2,-2
 321baf8:	1884703a 	and	r2,r3,r2
 321bafc:	1001703a 	wrctl	status,r2
  
  return context;
 321bb00:	e0bff717 	ldw	r2,-36(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 321bb04:	e0bff815 	stw	r2,-32(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 321bb08:	0080c974 	movhi	r2,805
 321bb0c:	10922904 	addi	r2,r2,18596
 321bb10:	10800003 	ldbu	r2,0(r2)
 321bb14:	10803fcc 	andi	r2,r2,255
 321bb18:	1005003a 	cmpeq	r2,r2,zero
 321bb1c:	1000071e 	bne	r2,zero,321bb3c <OSTaskCreate+0x90>
 321bb20:	e0bff817 	ldw	r2,-32(fp)
 321bb24:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321bb28:	e0bff617 	ldw	r2,-40(fp)
 321bb2c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 321bb30:	00800f04 	movi	r2,60
 321bb34:	e0bfff15 	stw	r2,-4(fp)
 321bb38:	00004b06 	br	321bc68 <OSTaskCreate+0x1bc>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 321bb3c:	e0bffe03 	ldbu	r2,-8(fp)
 321bb40:	00c0c9b4 	movhi	r3,806
 321bb44:	18f18004 	addi	r3,r3,-14848
 321bb48:	1085883a 	add	r2,r2,r2
 321bb4c:	1085883a 	add	r2,r2,r2
 321bb50:	10c5883a 	add	r2,r2,r3
 321bb54:	10800017 	ldw	r2,0(r2)
 321bb58:	1004c03a 	cmpne	r2,r2,zero
 321bb5c:	10003c1e 	bne	r2,zero,321bc50 <OSTaskCreate+0x1a4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 321bb60:	e0bffe03 	ldbu	r2,-8(fp)
 321bb64:	00c0c9b4 	movhi	r3,806
 321bb68:	18f18004 	addi	r3,r3,-14848
 321bb6c:	1085883a 	add	r2,r2,r2
 321bb70:	1085883a 	add	r2,r2,r2
 321bb74:	10c7883a 	add	r3,r2,r3
 321bb78:	00800044 	movi	r2,1
 321bb7c:	18800015 	stw	r2,0(r3)
 321bb80:	e0bff817 	ldw	r2,-32(fp)
 321bb84:	e0bff515 	stw	r2,-44(fp)
 321bb88:	e0bff517 	ldw	r2,-44(fp)
 321bb8c:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
 321bb90:	e13ffb17 	ldw	r4,-20(fp)
 321bb94:	e17ffc17 	ldw	r5,-16(fp)
 321bb98:	e1bffd17 	ldw	r6,-12(fp)
 321bb9c:	000f883a 	mov	r7,zero
 321bba0:	323b1f00 	call	323b1f0 <OSTaskStkInit>
 321bba4:	e0bffa15 	stw	r2,-24(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
 321bba8:	e13ffe03 	ldbu	r4,-8(fp)
 321bbac:	d8000015 	stw	zero,0(sp)
 321bbb0:	d8000115 	stw	zero,4(sp)
 321bbb4:	d8000215 	stw	zero,8(sp)
 321bbb8:	e17ffa17 	ldw	r5,-24(fp)
 321bbbc:	000d883a 	mov	r6,zero
 321bbc0:	000f883a 	mov	r7,zero
 321bbc4:	321708c0 	call	321708c <OS_TCBInit>
 321bbc8:	e0bff905 	stb	r2,-28(fp)
        if (err == OS_ERR_NONE) {
 321bbcc:	e0bff903 	ldbu	r2,-28(fp)
 321bbd0:	1004c03a 	cmpne	r2,r2,zero
 321bbd4:	1000081e 	bne	r2,zero,321bbf8 <OSTaskCreate+0x14c>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
 321bbd8:	0080c974 	movhi	r2,805
 321bbdc:	10921b44 	addi	r2,r2,18541
 321bbe0:	10800003 	ldbu	r2,0(r2)
 321bbe4:	10803fcc 	andi	r2,r2,255
 321bbe8:	10800058 	cmpnei	r2,r2,1
 321bbec:	1000151e 	bne	r2,zero,321bc44 <OSTaskCreate+0x198>
                OS_Sched();
 321bbf0:	3216c840 	call	3216c84 <OS_Sched>
 321bbf4:	00001306 	br	321bc44 <OSTaskCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321bbf8:	0005303a 	rdctl	r2,status
 321bbfc:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321bc00:	e0fff417 	ldw	r3,-48(fp)
 321bc04:	00bfff84 	movi	r2,-2
 321bc08:	1884703a 	and	r2,r3,r2
 321bc0c:	1001703a 	wrctl	status,r2
  
  return context;
 321bc10:	e0bff417 	ldw	r2,-48(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 321bc14:	e0bff815 	stw	r2,-32(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
 321bc18:	e0bffe03 	ldbu	r2,-8(fp)
 321bc1c:	00c0c9b4 	movhi	r3,806
 321bc20:	18f18004 	addi	r3,r3,-14848
 321bc24:	1085883a 	add	r2,r2,r2
 321bc28:	1085883a 	add	r2,r2,r2
 321bc2c:	10c5883a 	add	r2,r2,r3
 321bc30:	10000015 	stw	zero,0(r2)
 321bc34:	e0bff817 	ldw	r2,-32(fp)
 321bc38:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321bc3c:	e0bff317 	ldw	r2,-52(fp)
 321bc40:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 321bc44:	e0bff903 	ldbu	r2,-28(fp)
 321bc48:	e0bfff15 	stw	r2,-4(fp)
 321bc4c:	00000606 	br	321bc68 <OSTaskCreate+0x1bc>
 321bc50:	e0bff817 	ldw	r2,-32(fp)
 321bc54:	e0bff215 	stw	r2,-56(fp)
 321bc58:	e0bff217 	ldw	r2,-56(fp)
 321bc5c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 321bc60:	00800a04 	movi	r2,40
 321bc64:	e0bfff15 	stw	r2,-4(fp)
 321bc68:	e0bfff17 	ldw	r2,-4(fp)
}
 321bc6c:	e037883a 	mov	sp,fp
 321bc70:	dfc00117 	ldw	ra,4(sp)
 321bc74:	df000017 	ldw	fp,0(sp)
 321bc78:	dec00204 	addi	sp,sp,8
 321bc7c:	f800283a 	ret

0321bc80 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
 321bc80:	deffeb04 	addi	sp,sp,-84
 321bc84:	dfc01415 	stw	ra,80(sp)
 321bc88:	df001315 	stw	fp,76(sp)
 321bc8c:	df001304 	addi	fp,sp,76
 321bc90:	e13ff915 	stw	r4,-28(fp)
 321bc94:	e17ffa15 	stw	r5,-24(fp)
 321bc98:	e1bffb15 	stw	r6,-20(fp)
 321bc9c:	e0800217 	ldw	r2,8(fp)
 321bca0:	e0c00617 	ldw	r3,24(fp)
 321bca4:	e1fffc05 	stb	r7,-16(fp)
 321bca8:	e0bffd0d 	sth	r2,-12(fp)
 321bcac:	e0fffe0d 	sth	r3,-8(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 321bcb0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 321bcb4:	e0bffc03 	ldbu	r2,-16(fp)
 321bcb8:	10800570 	cmpltui	r2,r2,21
 321bcbc:	1000031e 	bne	r2,zero,321bccc <OSTaskCreateExt+0x4c>
        return (OS_ERR_PRIO_INVALID);
 321bcc0:	00800a84 	movi	r2,42
 321bcc4:	e0bfff15 	stw	r2,-4(fp)
 321bcc8:	00006706 	br	321be68 <OSTaskCreateExt+0x1e8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321bccc:	0005303a 	rdctl	r2,status
 321bcd0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321bcd4:	e0fff517 	ldw	r3,-44(fp)
 321bcd8:	00bfff84 	movi	r2,-2
 321bcdc:	1884703a 	and	r2,r3,r2
 321bce0:	1001703a 	wrctl	status,r2
  
  return context;
 321bce4:	e0bff517 	ldw	r2,-44(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 321bce8:	e0bff615 	stw	r2,-40(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 321bcec:	0080c974 	movhi	r2,805
 321bcf0:	10922904 	addi	r2,r2,18596
 321bcf4:	10800003 	ldbu	r2,0(r2)
 321bcf8:	10803fcc 	andi	r2,r2,255
 321bcfc:	1005003a 	cmpeq	r2,r2,zero
 321bd00:	1000071e 	bne	r2,zero,321bd20 <OSTaskCreateExt+0xa0>
 321bd04:	e0bff617 	ldw	r2,-40(fp)
 321bd08:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321bd0c:	e0bff417 	ldw	r2,-48(fp)
 321bd10:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 321bd14:	00800f04 	movi	r2,60
 321bd18:	e0bfff15 	stw	r2,-4(fp)
 321bd1c:	00005206 	br	321be68 <OSTaskCreateExt+0x1e8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 321bd20:	e0bffc03 	ldbu	r2,-16(fp)
 321bd24:	00c0c9b4 	movhi	r3,806
 321bd28:	18f18004 	addi	r3,r3,-14848
 321bd2c:	1085883a 	add	r2,r2,r2
 321bd30:	1085883a 	add	r2,r2,r2
 321bd34:	10c5883a 	add	r2,r2,r3
 321bd38:	10800017 	ldw	r2,0(r2)
 321bd3c:	1004c03a 	cmpne	r2,r2,zero
 321bd40:	1000431e 	bne	r2,zero,321be50 <OSTaskCreateExt+0x1d0>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 321bd44:	e0bffc03 	ldbu	r2,-16(fp)
 321bd48:	00c0c9b4 	movhi	r3,806
 321bd4c:	18f18004 	addi	r3,r3,-14848
 321bd50:	1085883a 	add	r2,r2,r2
 321bd54:	1085883a 	add	r2,r2,r2
 321bd58:	10c7883a 	add	r3,r2,r3
 321bd5c:	00800044 	movi	r2,1
 321bd60:	18800015 	stw	r2,0(r3)
 321bd64:	e0bff617 	ldw	r2,-40(fp)
 321bd68:	e0bff315 	stw	r2,-52(fp)
 321bd6c:	e0bff317 	ldw	r2,-52(fp)
 321bd70:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
 321bd74:	e1bffe0b 	ldhu	r6,-8(fp)
 321bd78:	e1000317 	ldw	r4,12(fp)
 321bd7c:	e1400417 	ldw	r5,16(fp)
 321bd80:	321cefc0 	call	321cefc <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
 321bd84:	e1fffe0b 	ldhu	r7,-8(fp)
 321bd88:	e13ff917 	ldw	r4,-28(fp)
 321bd8c:	e17ffa17 	ldw	r5,-24(fp)
 321bd90:	e1bffb17 	ldw	r6,-20(fp)
 321bd94:	323b1f00 	call	323b1f0 <OSTaskStkInit>
 321bd98:	e0bff815 	stw	r2,-32(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
 321bd9c:	e13ffc03 	ldbu	r4,-16(fp)
 321bda0:	e1fffd0b 	ldhu	r7,-12(fp)
 321bda4:	e0fffe0b 	ldhu	r3,-8(fp)
 321bda8:	e0800417 	ldw	r2,16(fp)
 321bdac:	d8800015 	stw	r2,0(sp)
 321bdb0:	e0800517 	ldw	r2,20(fp)
 321bdb4:	d8800115 	stw	r2,4(sp)
 321bdb8:	d8c00215 	stw	r3,8(sp)
 321bdbc:	e17ff817 	ldw	r5,-32(fp)
 321bdc0:	e1800317 	ldw	r6,12(fp)
 321bdc4:	321708c0 	call	321708c <OS_TCBInit>
 321bdc8:	e0bff705 	stb	r2,-36(fp)
        if (err == OS_ERR_NONE) {
 321bdcc:	e0bff703 	ldbu	r2,-36(fp)
 321bdd0:	1004c03a 	cmpne	r2,r2,zero
 321bdd4:	1000081e 	bne	r2,zero,321bdf8 <OSTaskCreateExt+0x178>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
 321bdd8:	0080c974 	movhi	r2,805
 321bddc:	10921b44 	addi	r2,r2,18541
 321bde0:	10800003 	ldbu	r2,0(r2)
 321bde4:	10803fcc 	andi	r2,r2,255
 321bde8:	10800058 	cmpnei	r2,r2,1
 321bdec:	1000151e 	bne	r2,zero,321be44 <OSTaskCreateExt+0x1c4>
                OS_Sched();
 321bdf0:	3216c840 	call	3216c84 <OS_Sched>
 321bdf4:	00001306 	br	321be44 <OSTaskCreateExt+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321bdf8:	0005303a 	rdctl	r2,status
 321bdfc:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321be00:	e0fff217 	ldw	r3,-56(fp)
 321be04:	00bfff84 	movi	r2,-2
 321be08:	1884703a 	and	r2,r3,r2
 321be0c:	1001703a 	wrctl	status,r2
  
  return context;
 321be10:	e0bff217 	ldw	r2,-56(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 321be14:	e0bff615 	stw	r2,-40(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
 321be18:	e0bffc03 	ldbu	r2,-16(fp)
 321be1c:	00c0c9b4 	movhi	r3,806
 321be20:	18f18004 	addi	r3,r3,-14848
 321be24:	1085883a 	add	r2,r2,r2
 321be28:	1085883a 	add	r2,r2,r2
 321be2c:	10c5883a 	add	r2,r2,r3
 321be30:	10000015 	stw	zero,0(r2)
 321be34:	e0bff617 	ldw	r2,-40(fp)
 321be38:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321be3c:	e0bff117 	ldw	r2,-60(fp)
 321be40:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 321be44:	e0bff703 	ldbu	r2,-36(fp)
 321be48:	e0bfff15 	stw	r2,-4(fp)
 321be4c:	00000606 	br	321be68 <OSTaskCreateExt+0x1e8>
 321be50:	e0bff617 	ldw	r2,-40(fp)
 321be54:	e0bff015 	stw	r2,-64(fp)
 321be58:	e0bff017 	ldw	r2,-64(fp)
 321be5c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 321be60:	00800a04 	movi	r2,40
 321be64:	e0bfff15 	stw	r2,-4(fp)
 321be68:	e0bfff17 	ldw	r2,-4(fp)
}
 321be6c:	e037883a 	mov	sp,fp
 321be70:	dfc00117 	ldw	ra,4(sp)
 321be74:	df000017 	ldw	fp,0(sp)
 321be78:	dec00204 	addi	sp,sp,8
 321be7c:	f800283a 	ret

0321be80 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
 321be80:	defff304 	addi	sp,sp,-52
 321be84:	dfc00c15 	stw	ra,48(sp)
 321be88:	df000b15 	stw	fp,44(sp)
 321be8c:	df000b04 	addi	fp,sp,44
 321be90:	e13ffe05 	stb	r4,-8(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
 321be94:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
 321be98:	0080c974 	movhi	r2,805
 321be9c:	10922904 	addi	r2,r2,18596
 321bea0:	10800003 	ldbu	r2,0(r2)
 321bea4:	10803fcc 	andi	r2,r2,255
 321bea8:	1005003a 	cmpeq	r2,r2,zero
 321beac:	1000031e 	bne	r2,zero,321bebc <OSTaskDel+0x3c>
        return (OS_ERR_TASK_DEL_ISR);
 321beb0:	00801004 	movi	r2,64
 321beb4:	e0bfff15 	stw	r2,-4(fp)
 321beb8:	0000ee06 	br	321c274 <OSTaskDel+0x3f4>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
 321bebc:	e0bffe03 	ldbu	r2,-8(fp)
 321bec0:	10800518 	cmpnei	r2,r2,20
 321bec4:	1000031e 	bne	r2,zero,321bed4 <OSTaskDel+0x54>
        return (OS_ERR_TASK_DEL_IDLE);
 321bec8:	00800f84 	movi	r2,62
 321becc:	e0bfff15 	stw	r2,-4(fp)
 321bed0:	0000e806 	br	321c274 <OSTaskDel+0x3f4>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
 321bed4:	e0bffe03 	ldbu	r2,-8(fp)
 321bed8:	10800530 	cmpltui	r2,r2,20
 321bedc:	1000061e 	bne	r2,zero,321bef8 <OSTaskDel+0x78>
        if (prio != OS_PRIO_SELF) {
 321bee0:	e0bffe03 	ldbu	r2,-8(fp)
 321bee4:	10803fe0 	cmpeqi	r2,r2,255
 321bee8:	1000031e 	bne	r2,zero,321bef8 <OSTaskDel+0x78>
            return (OS_ERR_PRIO_INVALID);
 321beec:	00800a84 	movi	r2,42
 321bef0:	e0bfff15 	stw	r2,-4(fp)
 321bef4:	0000df06 	br	321c274 <OSTaskDel+0x3f4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321bef8:	0005303a 	rdctl	r2,status
 321befc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321bf00:	e0fffa17 	ldw	r3,-24(fp)
 321bf04:	00bfff84 	movi	r2,-2
 321bf08:	1884703a 	and	r2,r3,r2
 321bf0c:	1001703a 	wrctl	status,r2
  
  return context;
 321bf10:	e0bffa17 	ldw	r2,-24(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
 321bf14:	e0bffb15 	stw	r2,-20(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
 321bf18:	e0bffe03 	ldbu	r2,-8(fp)
 321bf1c:	10803fd8 	cmpnei	r2,r2,255
 321bf20:	1000051e 	bne	r2,zero,321bf38 <OSTaskDel+0xb8>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
 321bf24:	0080c974 	movhi	r2,805
 321bf28:	10922a04 	addi	r2,r2,18600
 321bf2c:	10800017 	ldw	r2,0(r2)
 321bf30:	10800c83 	ldbu	r2,50(r2)
 321bf34:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 321bf38:	e0bffe03 	ldbu	r2,-8(fp)
 321bf3c:	00c0c9b4 	movhi	r3,806
 321bf40:	18f18004 	addi	r3,r3,-14848
 321bf44:	1085883a 	add	r2,r2,r2
 321bf48:	1085883a 	add	r2,r2,r2
 321bf4c:	10c5883a 	add	r2,r2,r3
 321bf50:	10800017 	ldw	r2,0(r2)
 321bf54:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
 321bf58:	e0bffc17 	ldw	r2,-16(fp)
 321bf5c:	1004c03a 	cmpne	r2,r2,zero
 321bf60:	1000071e 	bne	r2,zero,321bf80 <OSTaskDel+0x100>
 321bf64:	e0bffb17 	ldw	r2,-20(fp)
 321bf68:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321bf6c:	e0bff917 	ldw	r2,-28(fp)
 321bf70:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 321bf74:	008010c4 	movi	r2,67
 321bf78:	e0bfff15 	stw	r2,-4(fp)
 321bf7c:	0000bd06 	br	321c274 <OSTaskDel+0x3f4>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
 321bf80:	e0bffc17 	ldw	r2,-16(fp)
 321bf84:	10800058 	cmpnei	r2,r2,1
 321bf88:	1000071e 	bne	r2,zero,321bfa8 <OSTaskDel+0x128>
 321bf8c:	e0bffb17 	ldw	r2,-20(fp)
 321bf90:	e0bff815 	stw	r2,-32(fp)
 321bf94:	e0bff817 	ldw	r2,-32(fp)
 321bf98:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 321bf9c:	00800f44 	movi	r2,61
 321bfa0:	e0bfff15 	stw	r2,-4(fp)
 321bfa4:	0000b306 	br	321c274 <OSTaskDel+0x3f4>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
 321bfa8:	e0bffc17 	ldw	r2,-16(fp)
 321bfac:	10800d03 	ldbu	r2,52(r2)
 321bfb0:	11003fcc 	andi	r4,r2,255
 321bfb4:	e0bffc17 	ldw	r2,-16(fp)
 321bfb8:	10800d03 	ldbu	r2,52(r2)
 321bfbc:	10c03fcc 	andi	r3,r2,255
 321bfc0:	0080c974 	movhi	r2,805
 321bfc4:	10922744 	addi	r2,r2,18589
 321bfc8:	10c5883a 	add	r2,r2,r3
 321bfcc:	10800003 	ldbu	r2,0(r2)
 321bfd0:	1007883a 	mov	r3,r2
 321bfd4:	e0bffc17 	ldw	r2,-16(fp)
 321bfd8:	10800d43 	ldbu	r2,53(r2)
 321bfdc:	0084303a 	nor	r2,zero,r2
 321bfe0:	1884703a 	and	r2,r3,r2
 321bfe4:	1007883a 	mov	r3,r2
 321bfe8:	0080c974 	movhi	r2,805
 321bfec:	10922744 	addi	r2,r2,18589
 321bff0:	1105883a 	add	r2,r2,r4
 321bff4:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
 321bff8:	e0bffc17 	ldw	r2,-16(fp)
 321bffc:	10800d03 	ldbu	r2,52(r2)
 321c000:	10c03fcc 	andi	r3,r2,255
 321c004:	0080c974 	movhi	r2,805
 321c008:	10922744 	addi	r2,r2,18589
 321c00c:	10c5883a 	add	r2,r2,r3
 321c010:	10800003 	ldbu	r2,0(r2)
 321c014:	10803fcc 	andi	r2,r2,255
 321c018:	1004c03a 	cmpne	r2,r2,zero
 321c01c:	10000c1e 	bne	r2,zero,321c050 <OSTaskDel+0x1d0>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
 321c020:	e0bffc17 	ldw	r2,-16(fp)
 321c024:	10800d83 	ldbu	r2,54(r2)
 321c028:	0084303a 	nor	r2,zero,r2
 321c02c:	1007883a 	mov	r3,r2
 321c030:	0080c974 	movhi	r2,805
 321c034:	10922704 	addi	r2,r2,18588
 321c038:	10800003 	ldbu	r2,0(r2)
 321c03c:	1884703a 	and	r2,r3,r2
 321c040:	1007883a 	mov	r3,r2
 321c044:	0080c974 	movhi	r2,805
 321c048:	10922704 	addi	r2,r2,18588
 321c04c:	10c00005 	stb	r3,0(r2)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
 321c050:	e0bffc17 	ldw	r2,-16(fp)
 321c054:	10800717 	ldw	r2,28(r2)
 321c058:	1005003a 	cmpeq	r2,r2,zero
 321c05c:	1000041e 	bne	r2,zero,321c070 <OSTaskDel+0x1f0>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
 321c060:	e0bffc17 	ldw	r2,-16(fp)
 321c064:	11400717 	ldw	r5,28(r2)
 321c068:	e13ffc17 	ldw	r4,-16(fp)
 321c06c:	321663c0 	call	321663c <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
 321c070:	e0bffc17 	ldw	r2,-16(fp)
 321c074:	10800817 	ldw	r2,32(r2)
 321c078:	1005003a 	cmpeq	r2,r2,zero
 321c07c:	1000041e 	bne	r2,zero,321c090 <OSTaskDel+0x210>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 321c080:	e0bffc17 	ldw	r2,-16(fp)
 321c084:	11400817 	ldw	r5,32(r2)
 321c088:	e13ffc17 	ldw	r4,-16(fp)
 321c08c:	32166f40 	call	32166f4 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
 321c090:	e0bffc17 	ldw	r2,-16(fp)
 321c094:	10800a17 	ldw	r2,40(r2)
 321c098:	e0bffd15 	stw	r2,-12(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
 321c09c:	e0bffd17 	ldw	r2,-12(fp)
 321c0a0:	1005003a 	cmpeq	r2,r2,zero
 321c0a4:	1000021e 	bne	r2,zero,321c0b0 <OSTaskDel+0x230>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
 321c0a8:	e13ffd17 	ldw	r4,-12(fp)
 321c0ac:	3218d880 	call	3218d88 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
 321c0b0:	e0bffc17 	ldw	r2,-16(fp)
 321c0b4:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
 321c0b8:	e0bffc17 	ldw	r2,-16(fp)
 321c0bc:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 321c0c0:	e0bffc17 	ldw	r2,-16(fp)
 321c0c4:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
 321c0c8:	0080c974 	movhi	r2,805
 321c0cc:	10921b04 	addi	r2,r2,18540
 321c0d0:	10800003 	ldbu	r2,0(r2)
 321c0d4:	10803fcc 	andi	r2,r2,255
 321c0d8:	10803fe0 	cmpeqi	r2,r2,255
 321c0dc:	1000081e 	bne	r2,zero,321c100 <OSTaskDel+0x280>
        OSLockNesting++;
 321c0e0:	0080c974 	movhi	r2,805
 321c0e4:	10921b04 	addi	r2,r2,18540
 321c0e8:	10800003 	ldbu	r2,0(r2)
 321c0ec:	10800044 	addi	r2,r2,1
 321c0f0:	1007883a 	mov	r3,r2
 321c0f4:	0080c974 	movhi	r2,805
 321c0f8:	10921b04 	addi	r2,r2,18540
 321c0fc:	10c00005 	stb	r3,0(r2)
 321c100:	e0bffb17 	ldw	r2,-20(fp)
 321c104:	e0bff715 	stw	r2,-36(fp)
 321c108:	e0bff717 	ldw	r2,-36(fp)
 321c10c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
 321c110:	32162280 	call	3216228 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321c114:	0005303a 	rdctl	r2,status
 321c118:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321c11c:	e0fff617 	ldw	r3,-40(fp)
 321c120:	00bfff84 	movi	r2,-2
 321c124:	1884703a 	and	r2,r3,r2
 321c128:	1001703a 	wrctl	status,r2
  
  return context;
 321c12c:	e0bff617 	ldw	r2,-40(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
 321c130:	e0bffb15 	stw	r2,-20(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
 321c134:	0080c974 	movhi	r2,805
 321c138:	10921b04 	addi	r2,r2,18540
 321c13c:	10800003 	ldbu	r2,0(r2)
 321c140:	10803fcc 	andi	r2,r2,255
 321c144:	1005003a 	cmpeq	r2,r2,zero
 321c148:	1000081e 	bne	r2,zero,321c16c <OSTaskDel+0x2ec>
        OSLockNesting--;
 321c14c:	0080c974 	movhi	r2,805
 321c150:	10921b04 	addi	r2,r2,18540
 321c154:	10800003 	ldbu	r2,0(r2)
 321c158:	10bfffc4 	addi	r2,r2,-1
 321c15c:	1007883a 	mov	r3,r2
 321c160:	0080c974 	movhi	r2,805
 321c164:	10921b04 	addi	r2,r2,18540
 321c168:	10c00005 	stb	r3,0(r2)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
 321c16c:	e13ffc17 	ldw	r4,-16(fp)
 321c170:	323b5200 	call	323b520 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
 321c174:	0080c974 	movhi	r2,805
 321c178:	10922344 	addi	r2,r2,18573
 321c17c:	10800003 	ldbu	r2,0(r2)
 321c180:	10bfffc4 	addi	r2,r2,-1
 321c184:	1007883a 	mov	r3,r2
 321c188:	0080c974 	movhi	r2,805
 321c18c:	10922344 	addi	r2,r2,18573
 321c190:	10c00005 	stb	r3,0(r2)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
 321c194:	e0bffe03 	ldbu	r2,-8(fp)
 321c198:	00c0c9b4 	movhi	r3,806
 321c19c:	18f18004 	addi	r3,r3,-14848
 321c1a0:	1085883a 	add	r2,r2,r2
 321c1a4:	1085883a 	add	r2,r2,r2
 321c1a8:	10c5883a 	add	r2,r2,r3
 321c1ac:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
 321c1b0:	e0bffc17 	ldw	r2,-16(fp)
 321c1b4:	10800617 	ldw	r2,24(r2)
 321c1b8:	1004c03a 	cmpne	r2,r2,zero
 321c1bc:	1000091e 	bne	r2,zero,321c1e4 <OSTaskDel+0x364>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
 321c1c0:	e0bffc17 	ldw	r2,-16(fp)
 321c1c4:	10800517 	ldw	r2,20(r2)
 321c1c8:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
 321c1cc:	e0bffc17 	ldw	r2,-16(fp)
 321c1d0:	10c00517 	ldw	r3,20(r2)
 321c1d4:	0080c974 	movhi	r2,805
 321c1d8:	10921e04 	addi	r2,r2,18552
 321c1dc:	10c00015 	stw	r3,0(r2)
 321c1e0:	00000a06 	br	321c20c <OSTaskDel+0x38c>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
 321c1e4:	e0bffc17 	ldw	r2,-16(fp)
 321c1e8:	10c00617 	ldw	r3,24(r2)
 321c1ec:	e0bffc17 	ldw	r2,-16(fp)
 321c1f0:	10800517 	ldw	r2,20(r2)
 321c1f4:	18800515 	stw	r2,20(r3)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
 321c1f8:	e0bffc17 	ldw	r2,-16(fp)
 321c1fc:	10c00517 	ldw	r3,20(r2)
 321c200:	e0bffc17 	ldw	r2,-16(fp)
 321c204:	10800617 	ldw	r2,24(r2)
 321c208:	18800615 	stw	r2,24(r3)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
 321c20c:	0080c974 	movhi	r2,805
 321c210:	10922204 	addi	r2,r2,18568
 321c214:	10c00017 	ldw	r3,0(r2)
 321c218:	e0bffc17 	ldw	r2,-16(fp)
 321c21c:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
 321c220:	00c0c974 	movhi	r3,805
 321c224:	18d22204 	addi	r3,r3,18568
 321c228:	e0bffc17 	ldw	r2,-16(fp)
 321c22c:	18800015 	stw	r2,0(r3)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
 321c230:	e0fffc17 	ldw	r3,-16(fp)
 321c234:	00800fc4 	movi	r2,63
 321c238:	18801305 	stb	r2,76(r3)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 321c23c:	e0bffc17 	ldw	r2,-16(fp)
 321c240:	10001345 	stb	zero,77(r2)
 321c244:	e0bffb17 	ldw	r2,-20(fp)
 321c248:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321c24c:	e0bff517 	ldw	r2,-44(fp)
 321c250:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 321c254:	0080c974 	movhi	r2,805
 321c258:	10921b44 	addi	r2,r2,18541
 321c25c:	10800003 	ldbu	r2,0(r2)
 321c260:	10803fcc 	andi	r2,r2,255
 321c264:	10800058 	cmpnei	r2,r2,1
 321c268:	1000011e 	bne	r2,zero,321c270 <OSTaskDel+0x3f0>
        OS_Sched();                                     /* Find new highest priority task              */
 321c26c:	3216c840 	call	3216c84 <OS_Sched>
    }
    return (OS_ERR_NONE);
 321c270:	e03fff15 	stw	zero,-4(fp)
 321c274:	e0bfff17 	ldw	r2,-4(fp)
}
 321c278:	e037883a 	mov	sp,fp
 321c27c:	dfc00117 	ldw	ra,4(sp)
 321c280:	df000017 	ldw	fp,0(sp)
 321c284:	dec00204 	addi	sp,sp,8
 321c288:	f800283a 	ret

0321c28c <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
 321c28c:	defff404 	addi	sp,sp,-48
 321c290:	df000b15 	stw	fp,44(sp)
 321c294:	df000b04 	addi	fp,sp,44
 321c298:	e13ffe05 	stb	r4,-8(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 321c29c:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
 321c2a0:	e0bffe03 	ldbu	r2,-8(fp)
 321c2a4:	10800518 	cmpnei	r2,r2,20
 321c2a8:	1000031e 	bne	r2,zero,321c2b8 <OSTaskDelReq+0x2c>
        return (OS_ERR_TASK_DEL_IDLE);
 321c2ac:	00800f84 	movi	r2,62
 321c2b0:	e0bfff15 	stw	r2,-4(fp)
 321c2b4:	00004c06 	br	321c3e8 <OSTaskDelReq+0x15c>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 321c2b8:	e0bffe03 	ldbu	r2,-8(fp)
 321c2bc:	10800530 	cmpltui	r2,r2,20
 321c2c0:	1000061e 	bne	r2,zero,321c2dc <OSTaskDelReq+0x50>
        if (prio != OS_PRIO_SELF) {
 321c2c4:	e0bffe03 	ldbu	r2,-8(fp)
 321c2c8:	10803fe0 	cmpeqi	r2,r2,255
 321c2cc:	1000031e 	bne	r2,zero,321c2dc <OSTaskDelReq+0x50>
            return (OS_ERR_PRIO_INVALID);
 321c2d0:	00800a84 	movi	r2,42
 321c2d4:	e0bfff15 	stw	r2,-4(fp)
 321c2d8:	00004306 	br	321c3e8 <OSTaskDelReq+0x15c>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
 321c2dc:	e0bffe03 	ldbu	r2,-8(fp)
 321c2e0:	10803fd8 	cmpnei	r2,r2,255
 321c2e4:	1000141e 	bne	r2,zero,321c338 <OSTaskDelReq+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321c2e8:	0005303a 	rdctl	r2,status
 321c2ec:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321c2f0:	e0fffa17 	ldw	r3,-24(fp)
 321c2f4:	00bfff84 	movi	r2,-2
 321c2f8:	1884703a 	and	r2,r3,r2
 321c2fc:	1001703a 	wrctl	status,r2
  
  return context;
 321c300:	e0bffa17 	ldw	r2,-24(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
 321c304:	e0bffb15 	stw	r2,-20(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
 321c308:	0080c974 	movhi	r2,805
 321c30c:	10922a04 	addi	r2,r2,18600
 321c310:	10800017 	ldw	r2,0(r2)
 321c314:	10800dc3 	ldbu	r2,55(r2)
 321c318:	e0bffd05 	stb	r2,-12(fp)
 321c31c:	e0bffb17 	ldw	r2,-20(fp)
 321c320:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321c324:	e0bff917 	ldw	r2,-28(fp)
 321c328:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
 321c32c:	e0bffd03 	ldbu	r2,-12(fp)
 321c330:	e0bfff15 	stw	r2,-4(fp)
 321c334:	00002c06 	br	321c3e8 <OSTaskDelReq+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321c338:	0005303a 	rdctl	r2,status
 321c33c:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321c340:	e0fff817 	ldw	r3,-32(fp)
 321c344:	00bfff84 	movi	r2,-2
 321c348:	1884703a 	and	r2,r3,r2
 321c34c:	1001703a 	wrctl	status,r2
  
  return context;
 321c350:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 321c354:	e0bffb15 	stw	r2,-20(fp)
    ptcb = OSTCBPrioTbl[prio];
 321c358:	e0bffe03 	ldbu	r2,-8(fp)
 321c35c:	00c0c9b4 	movhi	r3,806
 321c360:	18f18004 	addi	r3,r3,-14848
 321c364:	1085883a 	add	r2,r2,r2
 321c368:	1085883a 	add	r2,r2,r2
 321c36c:	10c5883a 	add	r2,r2,r3
 321c370:	10800017 	ldw	r2,0(r2)
 321c374:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
 321c378:	e0bffc17 	ldw	r2,-16(fp)
 321c37c:	1004c03a 	cmpne	r2,r2,zero
 321c380:	1000071e 	bne	r2,zero,321c3a0 <OSTaskDelReq+0x114>
 321c384:	e0bffb17 	ldw	r2,-20(fp)
 321c388:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321c38c:	e0bff717 	ldw	r2,-36(fp)
 321c390:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
 321c394:	008010c4 	movi	r2,67
 321c398:	e0bfff15 	stw	r2,-4(fp)
 321c39c:	00001206 	br	321c3e8 <OSTaskDelReq+0x15c>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
 321c3a0:	e0bffc17 	ldw	r2,-16(fp)
 321c3a4:	10800058 	cmpnei	r2,r2,1
 321c3a8:	1000071e 	bne	r2,zero,321c3c8 <OSTaskDelReq+0x13c>
 321c3ac:	e0bffb17 	ldw	r2,-20(fp)
 321c3b0:	e0bff615 	stw	r2,-40(fp)
 321c3b4:	e0bff617 	ldw	r2,-40(fp)
 321c3b8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 321c3bc:	00800f44 	movi	r2,61
 321c3c0:	e0bfff15 	stw	r2,-4(fp)
 321c3c4:	00000806 	br	321c3e8 <OSTaskDelReq+0x15c>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
 321c3c8:	e0fffc17 	ldw	r3,-16(fp)
 321c3cc:	00800fc4 	movi	r2,63
 321c3d0:	18800dc5 	stb	r2,55(r3)
 321c3d4:	e0bffb17 	ldw	r2,-20(fp)
 321c3d8:	e0bff515 	stw	r2,-44(fp)
 321c3dc:	e0bff517 	ldw	r2,-44(fp)
 321c3e0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 321c3e4:	e03fff15 	stw	zero,-4(fp)
 321c3e8:	e0bfff17 	ldw	r2,-4(fp)
}
 321c3ec:	e037883a 	mov	sp,fp
 321c3f0:	df000017 	ldw	fp,0(sp)
 321c3f4:	dec00104 	addi	sp,sp,4
 321c3f8:	f800283a 	ret

0321c3fc <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
 321c3fc:	defff304 	addi	sp,sp,-52
 321c400:	dfc00c15 	stw	ra,48(sp)
 321c404:	df000b15 	stw	fp,44(sp)
 321c408:	df000b04 	addi	fp,sp,44
 321c40c:	e17ffd15 	stw	r5,-12(fp)
 321c410:	e1bffe15 	stw	r6,-8(fp)
 321c414:	e13ffc05 	stb	r4,-16(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
 321c418:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
 321c41c:	e0bffe17 	ldw	r2,-8(fp)
 321c420:	1004c03a 	cmpne	r2,r2,zero
 321c424:	1000021e 	bne	r2,zero,321c430 <OSTaskNameGet+0x34>
        return (0);
 321c428:	e03fff15 	stw	zero,-4(fp)
 321c42c:	00005b06 	br	321c59c <OSTaskNameGet+0x1a0>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
 321c430:	e0bffc03 	ldbu	r2,-16(fp)
 321c434:	10800570 	cmpltui	r2,r2,21
 321c438:	1000081e 	bne	r2,zero,321c45c <OSTaskNameGet+0x60>
        if (prio != OS_PRIO_SELF) {
 321c43c:	e0bffc03 	ldbu	r2,-16(fp)
 321c440:	10803fe0 	cmpeqi	r2,r2,255
 321c444:	1000051e 	bne	r2,zero,321c45c <OSTaskNameGet+0x60>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
 321c448:	e0fffe17 	ldw	r3,-8(fp)
 321c44c:	00800a84 	movi	r2,42
 321c450:	18800005 	stb	r2,0(r3)
            return (0);
 321c454:	e03fff15 	stw	zero,-4(fp)
 321c458:	00005006 	br	321c59c <OSTaskNameGet+0x1a0>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
 321c45c:	e0bffd17 	ldw	r2,-12(fp)
 321c460:	1004c03a 	cmpne	r2,r2,zero
 321c464:	1000051e 	bne	r2,zero,321c47c <OSTaskNameGet+0x80>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
 321c468:	e0fffe17 	ldw	r3,-8(fp)
 321c46c:	00800304 	movi	r2,12
 321c470:	18800005 	stb	r2,0(r3)
        return (0);
 321c474:	e03fff15 	stw	zero,-4(fp)
 321c478:	00004806 	br	321c59c <OSTaskNameGet+0x1a0>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
 321c47c:	0080c974 	movhi	r2,805
 321c480:	10922904 	addi	r2,r2,18596
 321c484:	10800003 	ldbu	r2,0(r2)
 321c488:	10803fcc 	andi	r2,r2,255
 321c48c:	1005003a 	cmpeq	r2,r2,zero
 321c490:	1000051e 	bne	r2,zero,321c4a8 <OSTaskNameGet+0xac>
        *perr = OS_ERR_NAME_GET_ISR;
 321c494:	e0fffe17 	ldw	r3,-8(fp)
 321c498:	00800444 	movi	r2,17
 321c49c:	18800005 	stb	r2,0(r3)
        return (0);
 321c4a0:	e03fff15 	stw	zero,-4(fp)
 321c4a4:	00003d06 	br	321c59c <OSTaskNameGet+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321c4a8:	0005303a 	rdctl	r2,status
 321c4ac:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321c4b0:	e0fff817 	ldw	r3,-32(fp)
 321c4b4:	00bfff84 	movi	r2,-2
 321c4b8:	1884703a 	and	r2,r3,r2
 321c4bc:	1001703a 	wrctl	status,r2
  
  return context;
 321c4c0:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 321c4c4:	e0bff915 	stw	r2,-28(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
 321c4c8:	e0bffc03 	ldbu	r2,-16(fp)
 321c4cc:	10803fd8 	cmpnei	r2,r2,255
 321c4d0:	1000051e 	bne	r2,zero,321c4e8 <OSTaskNameGet+0xec>
        prio = OSTCBCur->OSTCBPrio;
 321c4d4:	0080c974 	movhi	r2,805
 321c4d8:	10922a04 	addi	r2,r2,18600
 321c4dc:	10800017 	ldw	r2,0(r2)
 321c4e0:	10800c83 	ldbu	r2,50(r2)
 321c4e4:	e0bffc05 	stb	r2,-16(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 321c4e8:	e0bffc03 	ldbu	r2,-16(fp)
 321c4ec:	00c0c9b4 	movhi	r3,806
 321c4f0:	18f18004 	addi	r3,r3,-14848
 321c4f4:	1085883a 	add	r2,r2,r2
 321c4f8:	1085883a 	add	r2,r2,r2
 321c4fc:	10c5883a 	add	r2,r2,r3
 321c500:	10800017 	ldw	r2,0(r2)
 321c504:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
 321c508:	e0bffb17 	ldw	r2,-20(fp)
 321c50c:	1004c03a 	cmpne	r2,r2,zero
 321c510:	1000091e 	bne	r2,zero,321c538 <OSTaskNameGet+0x13c>
 321c514:	e0bff917 	ldw	r2,-28(fp)
 321c518:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321c51c:	e0bff717 	ldw	r2,-36(fp)
 321c520:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
 321c524:	e0fffe17 	ldw	r3,-8(fp)
 321c528:	008010c4 	movi	r2,67
 321c52c:	18800005 	stb	r2,0(r3)
        return (0);
 321c530:	e03fff15 	stw	zero,-4(fp)
 321c534:	00001906 	br	321c59c <OSTaskNameGet+0x1a0>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
 321c538:	e0bffb17 	ldw	r2,-20(fp)
 321c53c:	10800058 	cmpnei	r2,r2,1
 321c540:	1000091e 	bne	r2,zero,321c568 <OSTaskNameGet+0x16c>
 321c544:	e0bff917 	ldw	r2,-28(fp)
 321c548:	e0bff615 	stw	r2,-40(fp)
 321c54c:	e0bff617 	ldw	r2,-40(fp)
 321c550:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
 321c554:	e0fffe17 	ldw	r3,-8(fp)
 321c558:	008010c4 	movi	r2,67
 321c55c:	18800005 	stb	r2,0(r3)
        return (0);
 321c560:	e03fff15 	stw	zero,-4(fp)
 321c564:	00000d06 	br	321c59c <OSTaskNameGet+0x1a0>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
 321c568:	e0bffb17 	ldw	r2,-20(fp)
 321c56c:	11401304 	addi	r5,r2,76
 321c570:	e13ffd17 	ldw	r4,-12(fp)
 321c574:	3216dc80 	call	3216dc8 <OS_StrCopy>
 321c578:	e0bffa05 	stb	r2,-24(fp)
 321c57c:	e0bff917 	ldw	r2,-28(fp)
 321c580:	e0bff515 	stw	r2,-44(fp)
 321c584:	e0bff517 	ldw	r2,-44(fp)
 321c588:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 321c58c:	e0bffe17 	ldw	r2,-8(fp)
 321c590:	10000005 	stb	zero,0(r2)
    return (len);
 321c594:	e0bffa03 	ldbu	r2,-24(fp)
 321c598:	e0bfff15 	stw	r2,-4(fp)
 321c59c:	e0bfff17 	ldw	r2,-4(fp)
}
 321c5a0:	e037883a 	mov	sp,fp
 321c5a4:	dfc00117 	ldw	ra,4(sp)
 321c5a8:	df000017 	ldw	fp,0(sp)
 321c5ac:	dec00204 	addi	sp,sp,8
 321c5b0:	f800283a 	ret

0321c5b4 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
 321c5b4:	defff304 	addi	sp,sp,-52
 321c5b8:	dfc00c15 	stw	ra,48(sp)
 321c5bc:	df000b15 	stw	fp,44(sp)
 321c5c0:	df000b04 	addi	fp,sp,44
 321c5c4:	e17ffe15 	stw	r5,-8(fp)
 321c5c8:	e1bfff15 	stw	r6,-4(fp)
 321c5cc:	e13ffd05 	stb	r4,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 321c5d0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 321c5d4:	e0bfff17 	ldw	r2,-4(fp)
 321c5d8:	1005003a 	cmpeq	r2,r2,zero
 321c5dc:	1000611e 	bne	r2,zero,321c764 <OSTaskNameSet+0x1b0>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
 321c5e0:	e0bffd03 	ldbu	r2,-12(fp)
 321c5e4:	10800570 	cmpltui	r2,r2,21
 321c5e8:	1000071e 	bne	r2,zero,321c608 <OSTaskNameSet+0x54>
        if (prio != OS_PRIO_SELF) {
 321c5ec:	e0bffd03 	ldbu	r2,-12(fp)
 321c5f0:	10803fe0 	cmpeqi	r2,r2,255
 321c5f4:	1000041e 	bne	r2,zero,321c608 <OSTaskNameSet+0x54>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
 321c5f8:	e0ffff17 	ldw	r3,-4(fp)
 321c5fc:	00800a84 	movi	r2,42
 321c600:	18800005 	stb	r2,0(r3)
            return;
 321c604:	00005706 	br	321c764 <OSTaskNameSet+0x1b0>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
 321c608:	e0bffe17 	ldw	r2,-8(fp)
 321c60c:	1004c03a 	cmpne	r2,r2,zero
 321c610:	1000041e 	bne	r2,zero,321c624 <OSTaskNameSet+0x70>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
 321c614:	e0ffff17 	ldw	r3,-4(fp)
 321c618:	00800304 	movi	r2,12
 321c61c:	18800005 	stb	r2,0(r3)
        return;
 321c620:	00005006 	br	321c764 <OSTaskNameSet+0x1b0>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
 321c624:	0080c974 	movhi	r2,805
 321c628:	10922904 	addi	r2,r2,18596
 321c62c:	10800003 	ldbu	r2,0(r2)
 321c630:	10803fcc 	andi	r2,r2,255
 321c634:	1005003a 	cmpeq	r2,r2,zero
 321c638:	1000041e 	bne	r2,zero,321c64c <OSTaskNameSet+0x98>
        *perr = OS_ERR_NAME_SET_ISR;
 321c63c:	e0ffff17 	ldw	r3,-4(fp)
 321c640:	00800484 	movi	r2,18
 321c644:	18800005 	stb	r2,0(r3)
        return;
 321c648:	00004606 	br	321c764 <OSTaskNameSet+0x1b0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321c64c:	0005303a 	rdctl	r2,status
 321c650:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321c654:	e0fff917 	ldw	r3,-28(fp)
 321c658:	00bfff84 	movi	r2,-2
 321c65c:	1884703a 	and	r2,r3,r2
 321c660:	1001703a 	wrctl	status,r2
  
  return context;
 321c664:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 321c668:	e0bffa15 	stw	r2,-24(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
 321c66c:	e0bffd03 	ldbu	r2,-12(fp)
 321c670:	10803fd8 	cmpnei	r2,r2,255
 321c674:	1000051e 	bne	r2,zero,321c68c <OSTaskNameSet+0xd8>
        prio = OSTCBCur->OSTCBPrio;
 321c678:	0080c974 	movhi	r2,805
 321c67c:	10922a04 	addi	r2,r2,18600
 321c680:	10800017 	ldw	r2,0(r2)
 321c684:	10800c83 	ldbu	r2,50(r2)
 321c688:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 321c68c:	e0bffd03 	ldbu	r2,-12(fp)
 321c690:	00c0c9b4 	movhi	r3,806
 321c694:	18f18004 	addi	r3,r3,-14848
 321c698:	1085883a 	add	r2,r2,r2
 321c69c:	1085883a 	add	r2,r2,r2
 321c6a0:	10c5883a 	add	r2,r2,r3
 321c6a4:	10800017 	ldw	r2,0(r2)
 321c6a8:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
 321c6ac:	e0bffb17 	ldw	r2,-20(fp)
 321c6b0:	1004c03a 	cmpne	r2,r2,zero
 321c6b4:	1000081e 	bne	r2,zero,321c6d8 <OSTaskNameSet+0x124>
 321c6b8:	e0bffa17 	ldw	r2,-24(fp)
 321c6bc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321c6c0:	e0bff817 	ldw	r2,-32(fp)
 321c6c4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
 321c6c8:	e0ffff17 	ldw	r3,-4(fp)
 321c6cc:	008010c4 	movi	r2,67
 321c6d0:	18800005 	stb	r2,0(r3)
        return;
 321c6d4:	00002306 	br	321c764 <OSTaskNameSet+0x1b0>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
 321c6d8:	e0bffb17 	ldw	r2,-20(fp)
 321c6dc:	10800058 	cmpnei	r2,r2,1
 321c6e0:	1000081e 	bne	r2,zero,321c704 <OSTaskNameSet+0x150>
 321c6e4:	e0bffa17 	ldw	r2,-24(fp)
 321c6e8:	e0bff715 	stw	r2,-36(fp)
 321c6ec:	e0bff717 	ldw	r2,-36(fp)
 321c6f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
 321c6f4:	e0ffff17 	ldw	r3,-4(fp)
 321c6f8:	008010c4 	movi	r2,67
 321c6fc:	18800005 	stb	r2,0(r3)
        return;
 321c700:	00001806 	br	321c764 <OSTaskNameSet+0x1b0>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
 321c704:	e13ffe17 	ldw	r4,-8(fp)
 321c708:	3216e480 	call	3216e48 <OS_StrLen>
 321c70c:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
 321c710:	e0bffc03 	ldbu	r2,-16(fp)
 321c714:	10800830 	cmpltui	r2,r2,32
 321c718:	1000081e 	bne	r2,zero,321c73c <OSTaskNameSet+0x188>
 321c71c:	e0bffa17 	ldw	r2,-24(fp)
 321c720:	e0bff615 	stw	r2,-40(fp)
 321c724:	e0bff617 	ldw	r2,-40(fp)
 321c728:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
 321c72c:	e0ffff17 	ldw	r3,-4(fp)
 321c730:	00801044 	movi	r2,65
 321c734:	18800005 	stb	r2,0(r3)
        return;
 321c738:	00000a06 	br	321c764 <OSTaskNameSet+0x1b0>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
 321c73c:	e0bffb17 	ldw	r2,-20(fp)
 321c740:	11001304 	addi	r4,r2,76
 321c744:	e17ffe17 	ldw	r5,-8(fp)
 321c748:	3216dc80 	call	3216dc8 <OS_StrCopy>
 321c74c:	e0bffa17 	ldw	r2,-24(fp)
 321c750:	e0bff515 	stw	r2,-44(fp)
 321c754:	e0bff517 	ldw	r2,-44(fp)
 321c758:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 321c75c:	e0bfff17 	ldw	r2,-4(fp)
 321c760:	10000005 	stb	zero,0(r2)
}
 321c764:	e037883a 	mov	sp,fp
 321c768:	dfc00117 	ldw	ra,4(sp)
 321c76c:	df000017 	ldw	fp,0(sp)
 321c770:	dec00204 	addi	sp,sp,8
 321c774:	f800283a 	ret

0321c778 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
 321c778:	defff304 	addi	sp,sp,-52
 321c77c:	dfc00c15 	stw	ra,48(sp)
 321c780:	df000b15 	stw	fp,44(sp)
 321c784:	df000b04 	addi	fp,sp,44
 321c788:	e13ffe05 	stb	r4,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 321c78c:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
 321c790:	e0bffe03 	ldbu	r2,-8(fp)
 321c794:	10800530 	cmpltui	r2,r2,20
 321c798:	1000031e 	bne	r2,zero,321c7a8 <OSTaskResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 321c79c:	00800a84 	movi	r2,42
 321c7a0:	e0bfff15 	stw	r2,-4(fp)
 321c7a4:	00007406 	br	321c978 <OSTaskResume+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321c7a8:	0005303a 	rdctl	r2,status
 321c7ac:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321c7b0:	e0fffb17 	ldw	r3,-20(fp)
 321c7b4:	00bfff84 	movi	r2,-2
 321c7b8:	1884703a 	and	r2,r3,r2
 321c7bc:	1001703a 	wrctl	status,r2
  
  return context;
 321c7c0:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 321c7c4:	e0bffc15 	stw	r2,-16(fp)
    ptcb = OSTCBPrioTbl[prio];
 321c7c8:	e0bffe03 	ldbu	r2,-8(fp)
 321c7cc:	00c0c9b4 	movhi	r3,806
 321c7d0:	18f18004 	addi	r3,r3,-14848
 321c7d4:	1085883a 	add	r2,r2,r2
 321c7d8:	1085883a 	add	r2,r2,r2
 321c7dc:	10c5883a 	add	r2,r2,r3
 321c7e0:	10800017 	ldw	r2,0(r2)
 321c7e4:	e0bffd15 	stw	r2,-12(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
 321c7e8:	e0bffd17 	ldw	r2,-12(fp)
 321c7ec:	1004c03a 	cmpne	r2,r2,zero
 321c7f0:	1000071e 	bne	r2,zero,321c810 <OSTaskResume+0x98>
 321c7f4:	e0bffc17 	ldw	r2,-16(fp)
 321c7f8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321c7fc:	e0bffa17 	ldw	r2,-24(fp)
 321c800:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
 321c804:	00801184 	movi	r2,70
 321c808:	e0bfff15 	stw	r2,-4(fp)
 321c80c:	00005a06 	br	321c978 <OSTaskResume+0x200>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
 321c810:	e0bffd17 	ldw	r2,-12(fp)
 321c814:	10800058 	cmpnei	r2,r2,1
 321c818:	1000071e 	bne	r2,zero,321c838 <OSTaskResume+0xc0>
 321c81c:	e0bffc17 	ldw	r2,-16(fp)
 321c820:	e0bff915 	stw	r2,-28(fp)
 321c824:	e0bff917 	ldw	r2,-28(fp)
 321c828:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 321c82c:	008010c4 	movi	r2,67
 321c830:	e0bfff15 	stw	r2,-4(fp)
 321c834:	00005006 	br	321c978 <OSTaskResume+0x200>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
 321c838:	e0bffd17 	ldw	r2,-12(fp)
 321c83c:	10800c03 	ldbu	r2,48(r2)
 321c840:	10803fcc 	andi	r2,r2,255
 321c844:	1080020c 	andi	r2,r2,8
 321c848:	1005003a 	cmpeq	r2,r2,zero
 321c84c:	1000441e 	bne	r2,zero,321c960 <OSTaskResume+0x1e8>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
 321c850:	e0bffd17 	ldw	r2,-12(fp)
 321c854:	10c00c03 	ldbu	r3,48(r2)
 321c858:	00bffdc4 	movi	r2,-9
 321c85c:	1884703a 	and	r2,r3,r2
 321c860:	1007883a 	mov	r3,r2
 321c864:	e0bffd17 	ldw	r2,-12(fp)
 321c868:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
 321c86c:	e0bffd17 	ldw	r2,-12(fp)
 321c870:	10800c03 	ldbu	r2,48(r2)
 321c874:	10803fcc 	andi	r2,r2,255
 321c878:	1004c03a 	cmpne	r2,r2,zero
 321c87c:	1000321e 	bne	r2,zero,321c948 <OSTaskResume+0x1d0>
            if (ptcb->OSTCBDly == 0) {
 321c880:	e0bffd17 	ldw	r2,-12(fp)
 321c884:	10800b8b 	ldhu	r2,46(r2)
 321c888:	10bfffcc 	andi	r2,r2,65535
 321c88c:	1004c03a 	cmpne	r2,r2,zero
 321c890:	1000281e 	bne	r2,zero,321c934 <OSTaskResume+0x1bc>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
 321c894:	e0bffd17 	ldw	r2,-12(fp)
 321c898:	10c00d83 	ldbu	r3,54(r2)
 321c89c:	0080c974 	movhi	r2,805
 321c8a0:	10922704 	addi	r2,r2,18588
 321c8a4:	10800003 	ldbu	r2,0(r2)
 321c8a8:	1884b03a 	or	r2,r3,r2
 321c8ac:	1007883a 	mov	r3,r2
 321c8b0:	0080c974 	movhi	r2,805
 321c8b4:	10922704 	addi	r2,r2,18588
 321c8b8:	10c00005 	stb	r3,0(r2)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 321c8bc:	e0bffd17 	ldw	r2,-12(fp)
 321c8c0:	10800d03 	ldbu	r2,52(r2)
 321c8c4:	11003fcc 	andi	r4,r2,255
 321c8c8:	e0bffd17 	ldw	r2,-12(fp)
 321c8cc:	10800d03 	ldbu	r2,52(r2)
 321c8d0:	10c03fcc 	andi	r3,r2,255
 321c8d4:	0080c974 	movhi	r2,805
 321c8d8:	10922744 	addi	r2,r2,18589
 321c8dc:	10c5883a 	add	r2,r2,r3
 321c8e0:	10c00003 	ldbu	r3,0(r2)
 321c8e4:	e0bffd17 	ldw	r2,-12(fp)
 321c8e8:	10800d43 	ldbu	r2,53(r2)
 321c8ec:	1884b03a 	or	r2,r3,r2
 321c8f0:	1007883a 	mov	r3,r2
 321c8f4:	0080c974 	movhi	r2,805
 321c8f8:	10922744 	addi	r2,r2,18589
 321c8fc:	1105883a 	add	r2,r2,r4
 321c900:	10c00005 	stb	r3,0(r2)
 321c904:	e0bffc17 	ldw	r2,-16(fp)
 321c908:	e0bff815 	stw	r2,-32(fp)
 321c90c:	e0bff817 	ldw	r2,-32(fp)
 321c910:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
 321c914:	0080c974 	movhi	r2,805
 321c918:	10921b44 	addi	r2,r2,18541
 321c91c:	10800003 	ldbu	r2,0(r2)
 321c920:	10803fcc 	andi	r2,r2,255
 321c924:	10800058 	cmpnei	r2,r2,1
 321c928:	10000b1e 	bne	r2,zero,321c958 <OSTaskResume+0x1e0>
                    OS_Sched();                               /* Find new highest priority task        */
 321c92c:	3216c840 	call	3216c84 <OS_Sched>
 321c930:	00000906 	br	321c958 <OSTaskResume+0x1e0>
 321c934:	e0bffc17 	ldw	r2,-16(fp)
 321c938:	e0bff715 	stw	r2,-36(fp)
 321c93c:	e0bff717 	ldw	r2,-36(fp)
 321c940:	1001703a 	wrctl	status,r2
 321c944:	00000406 	br	321c958 <OSTaskResume+0x1e0>
 321c948:	e0bffc17 	ldw	r2,-16(fp)
 321c94c:	e0bff615 	stw	r2,-40(fp)
 321c950:	e0bff617 	ldw	r2,-40(fp)
 321c954:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
 321c958:	e03fff15 	stw	zero,-4(fp)
 321c95c:	00000606 	br	321c978 <OSTaskResume+0x200>
 321c960:	e0bffc17 	ldw	r2,-16(fp)
 321c964:	e0bff515 	stw	r2,-44(fp)
 321c968:	e0bff517 	ldw	r2,-44(fp)
 321c96c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
 321c970:	00801104 	movi	r2,68
 321c974:	e0bfff15 	stw	r2,-4(fp)
 321c978:	e0bfff17 	ldw	r2,-4(fp)
}
 321c97c:	e037883a 	mov	sp,fp
 321c980:	dfc00117 	ldw	ra,4(sp)
 321c984:	df000017 	ldw	fp,0(sp)
 321c988:	dec00204 	addi	sp,sp,8
 321c98c:	f800283a 	ret

0321c990 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
 321c990:	defff204 	addi	sp,sp,-56
 321c994:	df000d15 	stw	fp,52(sp)
 321c998:	df000d04 	addi	fp,sp,52
 321c99c:	e17ffe15 	stw	r5,-8(fp)
 321c9a0:	e13ffd05 	stb	r4,-12(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 321c9a4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
 321c9a8:	e0bffd03 	ldbu	r2,-12(fp)
 321c9ac:	10800570 	cmpltui	r2,r2,21
 321c9b0:	1000061e 	bne	r2,zero,321c9cc <OSTaskStkChk+0x3c>
        if (prio != OS_PRIO_SELF) {
 321c9b4:	e0bffd03 	ldbu	r2,-12(fp)
 321c9b8:	10803fe0 	cmpeqi	r2,r2,255
 321c9bc:	1000031e 	bne	r2,zero,321c9cc <OSTaskStkChk+0x3c>
            return (OS_ERR_PRIO_INVALID);
 321c9c0:	00800a84 	movi	r2,42
 321c9c4:	e0bfff15 	stw	r2,-4(fp)
 321c9c8:	00006b06 	br	321cb78 <OSTaskStkChk+0x1e8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
 321c9cc:	e0bffe17 	ldw	r2,-8(fp)
 321c9d0:	1004c03a 	cmpne	r2,r2,zero
 321c9d4:	1000031e 	bne	r2,zero,321c9e4 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
 321c9d8:	00800244 	movi	r2,9
 321c9dc:	e0bfff15 	stw	r2,-4(fp)
 321c9e0:	00006506 	br	321cb78 <OSTaskStkChk+0x1e8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
 321c9e4:	e0bffe17 	ldw	r2,-8(fp)
 321c9e8:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
 321c9ec:	e0bffe17 	ldw	r2,-8(fp)
 321c9f0:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321c9f4:	0005303a 	rdctl	r2,status
 321c9f8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321c9fc:	e0fff717 	ldw	r3,-36(fp)
 321ca00:	00bfff84 	movi	r2,-2
 321ca04:	1884703a 	and	r2,r3,r2
 321ca08:	1001703a 	wrctl	status,r2
  
  return context;
 321ca0c:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 321ca10:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
 321ca14:	e0bffd03 	ldbu	r2,-12(fp)
 321ca18:	10803fd8 	cmpnei	r2,r2,255
 321ca1c:	1000051e 	bne	r2,zero,321ca34 <OSTaskStkChk+0xa4>
        prio = OSTCBCur->OSTCBPrio;
 321ca20:	0080c974 	movhi	r2,805
 321ca24:	10922a04 	addi	r2,r2,18600
 321ca28:	10800017 	ldw	r2,0(r2)
 321ca2c:	10800c83 	ldbu	r2,50(r2)
 321ca30:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 321ca34:	e0bffd03 	ldbu	r2,-12(fp)
 321ca38:	00c0c9b4 	movhi	r3,806
 321ca3c:	18f18004 	addi	r3,r3,-14848
 321ca40:	1085883a 	add	r2,r2,r2
 321ca44:	1085883a 	add	r2,r2,r2
 321ca48:	10c5883a 	add	r2,r2,r3
 321ca4c:	10800017 	ldw	r2,0(r2)
 321ca50:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
 321ca54:	e0bffc17 	ldw	r2,-16(fp)
 321ca58:	1004c03a 	cmpne	r2,r2,zero
 321ca5c:	1000071e 	bne	r2,zero,321ca7c <OSTaskStkChk+0xec>
 321ca60:	e0bff817 	ldw	r2,-32(fp)
 321ca64:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321ca68:	e0bff617 	ldw	r2,-40(fp)
 321ca6c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 321ca70:	008010c4 	movi	r2,67
 321ca74:	e0bfff15 	stw	r2,-4(fp)
 321ca78:	00003f06 	br	321cb78 <OSTaskStkChk+0x1e8>
    }
    if (ptcb == OS_TCB_RESERVED) {
 321ca7c:	e0bffc17 	ldw	r2,-16(fp)
 321ca80:	10800058 	cmpnei	r2,r2,1
 321ca84:	1000071e 	bne	r2,zero,321caa4 <OSTaskStkChk+0x114>
 321ca88:	e0bff817 	ldw	r2,-32(fp)
 321ca8c:	e0bff515 	stw	r2,-44(fp)
 321ca90:	e0bff517 	ldw	r2,-44(fp)
 321ca94:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 321ca98:	008010c4 	movi	r2,67
 321ca9c:	e0bfff15 	stw	r2,-4(fp)
 321caa0:	00003506 	br	321cb78 <OSTaskStkChk+0x1e8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
 321caa4:	e0bffc17 	ldw	r2,-16(fp)
 321caa8:	1080040b 	ldhu	r2,16(r2)
 321caac:	10bfffcc 	andi	r2,r2,65535
 321cab0:	1080004c 	andi	r2,r2,1
 321cab4:	1004c03a 	cmpne	r2,r2,zero
 321cab8:	1000071e 	bne	r2,zero,321cad8 <OSTaskStkChk+0x148>
 321cabc:	e0bff817 	ldw	r2,-32(fp)
 321cac0:	e0bff415 	stw	r2,-48(fp)
 321cac4:	e0bff417 	ldw	r2,-48(fp)
 321cac8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
 321cacc:	00801144 	movi	r2,69
 321cad0:	e0bfff15 	stw	r2,-4(fp)
 321cad4:	00002806 	br	321cb78 <OSTaskStkChk+0x1e8>
    }
    nfree = 0;
 321cad8:	e03ffa15 	stw	zero,-24(fp)
    size  = ptcb->OSTCBStkSize;
 321cadc:	e0bffc17 	ldw	r2,-16(fp)
 321cae0:	10800317 	ldw	r2,12(r2)
 321cae4:	e0bff915 	stw	r2,-28(fp)
    pchk  = ptcb->OSTCBStkBottom;
 321cae8:	e0bffc17 	ldw	r2,-16(fp)
 321caec:	10800217 	ldw	r2,8(r2)
 321caf0:	e0bffb15 	stw	r2,-20(fp)
 321caf4:	e0bff817 	ldw	r2,-32(fp)
 321caf8:	e0bff315 	stw	r2,-52(fp)
 321cafc:	e0bff317 	ldw	r2,-52(fp)
 321cb00:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 321cb04:	00000306 	br	321cb14 <OSTaskStkChk+0x184>
        nfree++;
 321cb08:	e0bffa17 	ldw	r2,-24(fp)
 321cb0c:	10800044 	addi	r2,r2,1
 321cb10:	e0bffa15 	stw	r2,-24(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 321cb14:	e0bffb17 	ldw	r2,-20(fp)
 321cb18:	10800017 	ldw	r2,0(r2)
 321cb1c:	1005003a 	cmpeq	r2,r2,zero
 321cb20:	1007883a 	mov	r3,r2
 321cb24:	e0bffb17 	ldw	r2,-20(fp)
 321cb28:	10800104 	addi	r2,r2,4
 321cb2c:	e0bffb15 	stw	r2,-20(fp)
 321cb30:	18803fcc 	andi	r2,r3,255
 321cb34:	1004c03a 	cmpne	r2,r2,zero
 321cb38:	103ff31e 	bne	r2,zero,321cb08 <OSTaskStkChk+0x178>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
 321cb3c:	e0bffa17 	ldw	r2,-24(fp)
 321cb40:	1085883a 	add	r2,r2,r2
 321cb44:	1085883a 	add	r2,r2,r2
 321cb48:	1007883a 	mov	r3,r2
 321cb4c:	e0bffe17 	ldw	r2,-8(fp)
 321cb50:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
 321cb54:	e0fff917 	ldw	r3,-28(fp)
 321cb58:	e0bffa17 	ldw	r2,-24(fp)
 321cb5c:	1885c83a 	sub	r2,r3,r2
 321cb60:	1085883a 	add	r2,r2,r2
 321cb64:	1085883a 	add	r2,r2,r2
 321cb68:	1007883a 	mov	r3,r2
 321cb6c:	e0bffe17 	ldw	r2,-8(fp)
 321cb70:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
 321cb74:	e03fff15 	stw	zero,-4(fp)
 321cb78:	e0bfff17 	ldw	r2,-4(fp)
}
 321cb7c:	e037883a 	mov	sp,fp
 321cb80:	df000017 	ldw	fp,0(sp)
 321cb84:	dec00104 	addi	sp,sp,4
 321cb88:	f800283a 	ret

0321cb8c <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
 321cb8c:	defff404 	addi	sp,sp,-48
 321cb90:	dfc00b15 	stw	ra,44(sp)
 321cb94:	df000a15 	stw	fp,40(sp)
 321cb98:	df000a04 	addi	fp,sp,40
 321cb9c:	e13ffe05 	stb	r4,-8(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 321cba0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
 321cba4:	e0bffe03 	ldbu	r2,-8(fp)
 321cba8:	10800518 	cmpnei	r2,r2,20
 321cbac:	1000031e 	bne	r2,zero,321cbbc <OSTaskSuspend+0x30>
        return (OS_ERR_TASK_SUSPEND_IDLE);
 321cbb0:	008011c4 	movi	r2,71
 321cbb4:	e0bfff15 	stw	r2,-4(fp)
 321cbb8:	00007906 	br	321cda0 <OSTaskSuspend+0x214>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 321cbbc:	e0bffe03 	ldbu	r2,-8(fp)
 321cbc0:	10800530 	cmpltui	r2,r2,20
 321cbc4:	1000061e 	bne	r2,zero,321cbe0 <OSTaskSuspend+0x54>
        if (prio != OS_PRIO_SELF) {
 321cbc8:	e0bffe03 	ldbu	r2,-8(fp)
 321cbcc:	10803fe0 	cmpeqi	r2,r2,255
 321cbd0:	1000031e 	bne	r2,zero,321cbe0 <OSTaskSuspend+0x54>
            return (OS_ERR_PRIO_INVALID);
 321cbd4:	00800a84 	movi	r2,42
 321cbd8:	e0bfff15 	stw	r2,-4(fp)
 321cbdc:	00007006 	br	321cda0 <OSTaskSuspend+0x214>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321cbe0:	0005303a 	rdctl	r2,status
 321cbe4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321cbe8:	e0fff917 	ldw	r3,-28(fp)
 321cbec:	00bfff84 	movi	r2,-2
 321cbf0:	1884703a 	and	r2,r3,r2
 321cbf4:	1001703a 	wrctl	status,r2
  
  return context;
 321cbf8:	e0bff917 	ldw	r2,-28(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
 321cbfc:	e0bffa15 	stw	r2,-24(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
 321cc00:	e0bffe03 	ldbu	r2,-8(fp)
 321cc04:	10803fd8 	cmpnei	r2,r2,255
 321cc08:	1000081e 	bne	r2,zero,321cc2c <OSTaskSuspend+0xa0>
        prio = OSTCBCur->OSTCBPrio;
 321cc0c:	0080c974 	movhi	r2,805
 321cc10:	10922a04 	addi	r2,r2,18600
 321cc14:	10800017 	ldw	r2,0(r2)
 321cc18:	10800c83 	ldbu	r2,50(r2)
 321cc1c:	e0bffe05 	stb	r2,-8(fp)
        self = OS_TRUE;
 321cc20:	00800044 	movi	r2,1
 321cc24:	e0bffd05 	stb	r2,-12(fp)
 321cc28:	00000b06 	br	321cc58 <OSTaskSuspend+0xcc>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
 321cc2c:	0080c974 	movhi	r2,805
 321cc30:	10922a04 	addi	r2,r2,18600
 321cc34:	10800017 	ldw	r2,0(r2)
 321cc38:	10800c83 	ldbu	r2,50(r2)
 321cc3c:	10c03fcc 	andi	r3,r2,255
 321cc40:	e0bffe03 	ldbu	r2,-8(fp)
 321cc44:	1880031e 	bne	r3,r2,321cc54 <OSTaskSuspend+0xc8>
        self = OS_TRUE;
 321cc48:	00800044 	movi	r2,1
 321cc4c:	e0bffd05 	stb	r2,-12(fp)
 321cc50:	00000106 	br	321cc58 <OSTaskSuspend+0xcc>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
 321cc54:	e03ffd05 	stb	zero,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 321cc58:	e0bffe03 	ldbu	r2,-8(fp)
 321cc5c:	00c0c9b4 	movhi	r3,806
 321cc60:	18f18004 	addi	r3,r3,-14848
 321cc64:	1085883a 	add	r2,r2,r2
 321cc68:	1085883a 	add	r2,r2,r2
 321cc6c:	10c5883a 	add	r2,r2,r3
 321cc70:	10800017 	ldw	r2,0(r2)
 321cc74:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
 321cc78:	e0bffc17 	ldw	r2,-16(fp)
 321cc7c:	1004c03a 	cmpne	r2,r2,zero
 321cc80:	1000071e 	bne	r2,zero,321cca0 <OSTaskSuspend+0x114>
 321cc84:	e0bffa17 	ldw	r2,-24(fp)
 321cc88:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321cc8c:	e0bff817 	ldw	r2,-32(fp)
 321cc90:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
 321cc94:	00801204 	movi	r2,72
 321cc98:	e0bfff15 	stw	r2,-4(fp)
 321cc9c:	00004006 	br	321cda0 <OSTaskSuspend+0x214>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
 321cca0:	e0bffc17 	ldw	r2,-16(fp)
 321cca4:	10800058 	cmpnei	r2,r2,1
 321cca8:	1000071e 	bne	r2,zero,321ccc8 <OSTaskSuspend+0x13c>
 321ccac:	e0bffa17 	ldw	r2,-24(fp)
 321ccb0:	e0bff715 	stw	r2,-36(fp)
 321ccb4:	e0bff717 	ldw	r2,-36(fp)
 321ccb8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 321ccbc:	008010c4 	movi	r2,67
 321ccc0:	e0bfff15 	stw	r2,-4(fp)
 321ccc4:	00003606 	br	321cda0 <OSTaskSuspend+0x214>
    }
    y            = ptcb->OSTCBY;
 321ccc8:	e0bffc17 	ldw	r2,-16(fp)
 321cccc:	10800d03 	ldbu	r2,52(r2)
 321ccd0:	e0bffb05 	stb	r2,-20(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
 321ccd4:	e13ffb03 	ldbu	r4,-20(fp)
 321ccd8:	e0fffb03 	ldbu	r3,-20(fp)
 321ccdc:	0080c974 	movhi	r2,805
 321cce0:	10922744 	addi	r2,r2,18589
 321cce4:	10c5883a 	add	r2,r2,r3
 321cce8:	10800003 	ldbu	r2,0(r2)
 321ccec:	1007883a 	mov	r3,r2
 321ccf0:	e0bffc17 	ldw	r2,-16(fp)
 321ccf4:	10800d43 	ldbu	r2,53(r2)
 321ccf8:	0084303a 	nor	r2,zero,r2
 321ccfc:	1884703a 	and	r2,r3,r2
 321cd00:	1007883a 	mov	r3,r2
 321cd04:	0080c974 	movhi	r2,805
 321cd08:	10922744 	addi	r2,r2,18589
 321cd0c:	1105883a 	add	r2,r2,r4
 321cd10:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 321cd14:	e0fffb03 	ldbu	r3,-20(fp)
 321cd18:	0080c974 	movhi	r2,805
 321cd1c:	10922744 	addi	r2,r2,18589
 321cd20:	10c5883a 	add	r2,r2,r3
 321cd24:	10800003 	ldbu	r2,0(r2)
 321cd28:	10803fcc 	andi	r2,r2,255
 321cd2c:	1004c03a 	cmpne	r2,r2,zero
 321cd30:	10000c1e 	bne	r2,zero,321cd64 <OSTaskSuspend+0x1d8>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
 321cd34:	e0bffc17 	ldw	r2,-16(fp)
 321cd38:	10800d83 	ldbu	r2,54(r2)
 321cd3c:	0084303a 	nor	r2,zero,r2
 321cd40:	1007883a 	mov	r3,r2
 321cd44:	0080c974 	movhi	r2,805
 321cd48:	10922704 	addi	r2,r2,18588
 321cd4c:	10800003 	ldbu	r2,0(r2)
 321cd50:	1884703a 	and	r2,r3,r2
 321cd54:	1007883a 	mov	r3,r2
 321cd58:	0080c974 	movhi	r2,805
 321cd5c:	10922704 	addi	r2,r2,18588
 321cd60:	10c00005 	stb	r3,0(r2)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
 321cd64:	e0bffc17 	ldw	r2,-16(fp)
 321cd68:	10800c03 	ldbu	r2,48(r2)
 321cd6c:	10800214 	ori	r2,r2,8
 321cd70:	1007883a 	mov	r3,r2
 321cd74:	e0bffc17 	ldw	r2,-16(fp)
 321cd78:	10c00c05 	stb	r3,48(r2)
 321cd7c:	e0bffa17 	ldw	r2,-24(fp)
 321cd80:	e0bff615 	stw	r2,-40(fp)
 321cd84:	e0bff617 	ldw	r2,-40(fp)
 321cd88:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
 321cd8c:	e0bffd03 	ldbu	r2,-12(fp)
 321cd90:	10800058 	cmpnei	r2,r2,1
 321cd94:	1000011e 	bne	r2,zero,321cd9c <OSTaskSuspend+0x210>
        OS_Sched();                                             /* Find new highest priority task      */
 321cd98:	3216c840 	call	3216c84 <OS_Sched>
    }
    return (OS_ERR_NONE);
 321cd9c:	e03fff15 	stw	zero,-4(fp)
 321cda0:	e0bfff17 	ldw	r2,-4(fp)
}
 321cda4:	e037883a 	mov	sp,fp
 321cda8:	dfc00117 	ldw	ra,4(sp)
 321cdac:	df000017 	ldw	fp,0(sp)
 321cdb0:	dec00204 	addi	sp,sp,8
 321cdb4:	f800283a 	ret

0321cdb8 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
 321cdb8:	defff504 	addi	sp,sp,-44
 321cdbc:	dfc00a15 	stw	ra,40(sp)
 321cdc0:	df000915 	stw	fp,36(sp)
 321cdc4:	df000904 	addi	fp,sp,36
 321cdc8:	e17ffe15 	stw	r5,-8(fp)
 321cdcc:	e13ffd05 	stb	r4,-12(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 321cdd0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
 321cdd4:	e0bffd03 	ldbu	r2,-12(fp)
 321cdd8:	10800570 	cmpltui	r2,r2,21
 321cddc:	1000061e 	bne	r2,zero,321cdf8 <OSTaskQuery+0x40>
        if (prio != OS_PRIO_SELF) {
 321cde0:	e0bffd03 	ldbu	r2,-12(fp)
 321cde4:	10803fe0 	cmpeqi	r2,r2,255
 321cde8:	1000031e 	bne	r2,zero,321cdf8 <OSTaskQuery+0x40>
            return (OS_ERR_PRIO_INVALID);
 321cdec:	00800a84 	movi	r2,42
 321cdf0:	e0bfff15 	stw	r2,-4(fp)
 321cdf4:	00003b06 	br	321cee4 <OSTaskQuery+0x12c>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
 321cdf8:	e0bffe17 	ldw	r2,-8(fp)
 321cdfc:	1004c03a 	cmpne	r2,r2,zero
 321ce00:	1000031e 	bne	r2,zero,321ce10 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
 321ce04:	00800244 	movi	r2,9
 321ce08:	e0bfff15 	stw	r2,-4(fp)
 321ce0c:	00003506 	br	321cee4 <OSTaskQuery+0x12c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321ce10:	0005303a 	rdctl	r2,status
 321ce14:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321ce18:	e0fffa17 	ldw	r3,-24(fp)
 321ce1c:	00bfff84 	movi	r2,-2
 321ce20:	1884703a 	and	r2,r3,r2
 321ce24:	1001703a 	wrctl	status,r2
  
  return context;
 321ce28:	e0bffa17 	ldw	r2,-24(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 321ce2c:	e0bffb15 	stw	r2,-20(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
 321ce30:	e0bffd03 	ldbu	r2,-12(fp)
 321ce34:	10803fd8 	cmpnei	r2,r2,255
 321ce38:	1000051e 	bne	r2,zero,321ce50 <OSTaskQuery+0x98>
        prio = OSTCBCur->OSTCBPrio;
 321ce3c:	0080c974 	movhi	r2,805
 321ce40:	10922a04 	addi	r2,r2,18600
 321ce44:	10800017 	ldw	r2,0(r2)
 321ce48:	10800c83 	ldbu	r2,50(r2)
 321ce4c:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 321ce50:	e0bffd03 	ldbu	r2,-12(fp)
 321ce54:	00c0c9b4 	movhi	r3,806
 321ce58:	18f18004 	addi	r3,r3,-14848
 321ce5c:	1085883a 	add	r2,r2,r2
 321ce60:	1085883a 	add	r2,r2,r2
 321ce64:	10c5883a 	add	r2,r2,r3
 321ce68:	10800017 	ldw	r2,0(r2)
 321ce6c:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
 321ce70:	e0bffc17 	ldw	r2,-16(fp)
 321ce74:	1004c03a 	cmpne	r2,r2,zero
 321ce78:	1000071e 	bne	r2,zero,321ce98 <OSTaskQuery+0xe0>
 321ce7c:	e0bffb17 	ldw	r2,-20(fp)
 321ce80:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321ce84:	e0bff917 	ldw	r2,-28(fp)
 321ce88:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
 321ce8c:	00800a44 	movi	r2,41
 321ce90:	e0bfff15 	stw	r2,-4(fp)
 321ce94:	00001306 	br	321cee4 <OSTaskQuery+0x12c>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
 321ce98:	e0bffc17 	ldw	r2,-16(fp)
 321ce9c:	10800058 	cmpnei	r2,r2,1
 321cea0:	1000071e 	bne	r2,zero,321cec0 <OSTaskQuery+0x108>
 321cea4:	e0bffb17 	ldw	r2,-20(fp)
 321cea8:	e0bff815 	stw	r2,-32(fp)
 321ceac:	e0bff817 	ldw	r2,-32(fp)
 321ceb0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 321ceb4:	008010c4 	movi	r2,67
 321ceb8:	e0bfff15 	stw	r2,-4(fp)
 321cebc:	00000906 	br	321cee4 <OSTaskQuery+0x12c>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
 321cec0:	e13ffe17 	ldw	r4,-8(fp)
 321cec4:	e17ffc17 	ldw	r5,-16(fp)
 321cec8:	01801b04 	movi	r6,108
 321cecc:	3216c180 	call	3216c18 <OS_MemCopy>
 321ced0:	e0bffb17 	ldw	r2,-20(fp)
 321ced4:	e0bff715 	stw	r2,-36(fp)
 321ced8:	e0bff717 	ldw	r2,-36(fp)
 321cedc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 321cee0:	e03fff15 	stw	zero,-4(fp)
 321cee4:	e0bfff17 	ldw	r2,-4(fp)
}
 321cee8:	e037883a 	mov	sp,fp
 321ceec:	dfc00117 	ldw	ra,4(sp)
 321cef0:	df000017 	ldw	fp,0(sp)
 321cef4:	dec00204 	addi	sp,sp,8
 321cef8:	f800283a 	ret

0321cefc <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
 321cefc:	defffc04 	addi	sp,sp,-16
 321cf00:	df000315 	stw	fp,12(sp)
 321cf04:	df000304 	addi	fp,sp,12
 321cf08:	e13ffd15 	stw	r4,-12(fp)
 321cf0c:	e17ffe15 	stw	r5,-8(fp)
 321cf10:	e1bfff0d 	sth	r6,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
 321cf14:	e0bfff0b 	ldhu	r2,-4(fp)
 321cf18:	1080004c 	andi	r2,r2,1
 321cf1c:	10803fcc 	andi	r2,r2,255
 321cf20:	1005003a 	cmpeq	r2,r2,zero
 321cf24:	1000101e 	bne	r2,zero,321cf68 <OS_TaskStkClr+0x6c>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
 321cf28:	e0bfff0b 	ldhu	r2,-4(fp)
 321cf2c:	1080008c 	andi	r2,r2,2
 321cf30:	1005003a 	cmpeq	r2,r2,zero
 321cf34:	10000c1e 	bne	r2,zero,321cf68 <OS_TaskStkClr+0x6c>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 321cf38:	00000806 	br	321cf5c <OS_TaskStkClr+0x60>
                size--;
 321cf3c:	e0bffe17 	ldw	r2,-8(fp)
 321cf40:	10bfffc4 	addi	r2,r2,-1
 321cf44:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
 321cf48:	e0bffd17 	ldw	r2,-12(fp)
 321cf4c:	10000015 	stw	zero,0(r2)
 321cf50:	e0bffd17 	ldw	r2,-12(fp)
 321cf54:	10800104 	addi	r2,r2,4
 321cf58:	e0bffd15 	stw	r2,-12(fp)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 321cf5c:	e0bffe17 	ldw	r2,-8(fp)
 321cf60:	1004c03a 	cmpne	r2,r2,zero
 321cf64:	103ff51e 	bne	r2,zero,321cf3c <OS_TaskStkClr+0x40>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
 321cf68:	e037883a 	mov	sp,fp
 321cf6c:	df000017 	ldw	fp,0(sp)
 321cf70:	dec00104 	addi	sp,sp,4
 321cf74:	f800283a 	ret

0321cf78 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
 321cf78:	defff904 	addi	sp,sp,-28
 321cf7c:	dfc00615 	stw	ra,24(sp)
 321cf80:	df000515 	stw	fp,20(sp)
 321cf84:	df000504 	addi	fp,sp,20
 321cf88:	e13fff0d 	sth	r4,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 321cf8c:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 321cf90:	0080c974 	movhi	r2,805
 321cf94:	10922904 	addi	r2,r2,18596
 321cf98:	10800003 	ldbu	r2,0(r2)
 321cf9c:	10803fcc 	andi	r2,r2,255
 321cfa0:	1004c03a 	cmpne	r2,r2,zero
 321cfa4:	1000421e 	bne	r2,zero,321d0b0 <OSTimeDly+0x138>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
 321cfa8:	e0bfff0b 	ldhu	r2,-4(fp)
 321cfac:	1005003a 	cmpeq	r2,r2,zero
 321cfb0:	10003f1e 	bne	r2,zero,321d0b0 <OSTimeDly+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321cfb4:	0005303a 	rdctl	r2,status
 321cfb8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321cfbc:	e0fffc17 	ldw	r3,-16(fp)
 321cfc0:	00bfff84 	movi	r2,-2
 321cfc4:	1884703a 	and	r2,r3,r2
 321cfc8:	1001703a 	wrctl	status,r2
  
  return context;
 321cfcc:	e0bffc17 	ldw	r2,-16(fp)
        OS_ENTER_CRITICAL();
 321cfd0:	e0bffd15 	stw	r2,-12(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
 321cfd4:	0080c974 	movhi	r2,805
 321cfd8:	10922a04 	addi	r2,r2,18600
 321cfdc:	10800017 	ldw	r2,0(r2)
 321cfe0:	10800d03 	ldbu	r2,52(r2)
 321cfe4:	e0bffe05 	stb	r2,-8(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 321cfe8:	e13ffe03 	ldbu	r4,-8(fp)
 321cfec:	e0fffe03 	ldbu	r3,-8(fp)
 321cff0:	0080c974 	movhi	r2,805
 321cff4:	10922744 	addi	r2,r2,18589
 321cff8:	10c5883a 	add	r2,r2,r3
 321cffc:	10800003 	ldbu	r2,0(r2)
 321d000:	1007883a 	mov	r3,r2
 321d004:	0080c974 	movhi	r2,805
 321d008:	10922a04 	addi	r2,r2,18600
 321d00c:	10800017 	ldw	r2,0(r2)
 321d010:	10800d43 	ldbu	r2,53(r2)
 321d014:	0084303a 	nor	r2,zero,r2
 321d018:	1884703a 	and	r2,r3,r2
 321d01c:	1007883a 	mov	r3,r2
 321d020:	0080c974 	movhi	r2,805
 321d024:	10922744 	addi	r2,r2,18589
 321d028:	1105883a 	add	r2,r2,r4
 321d02c:	10c00005 	stb	r3,0(r2)
        if (OSRdyTbl[y] == 0) {
 321d030:	e0fffe03 	ldbu	r3,-8(fp)
 321d034:	0080c974 	movhi	r2,805
 321d038:	10922744 	addi	r2,r2,18589
 321d03c:	10c5883a 	add	r2,r2,r3
 321d040:	10800003 	ldbu	r2,0(r2)
 321d044:	10803fcc 	andi	r2,r2,255
 321d048:	1004c03a 	cmpne	r2,r2,zero
 321d04c:	10000e1e 	bne	r2,zero,321d088 <OSTimeDly+0x110>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 321d050:	0080c974 	movhi	r2,805
 321d054:	10922a04 	addi	r2,r2,18600
 321d058:	10800017 	ldw	r2,0(r2)
 321d05c:	10800d83 	ldbu	r2,54(r2)
 321d060:	0084303a 	nor	r2,zero,r2
 321d064:	1007883a 	mov	r3,r2
 321d068:	0080c974 	movhi	r2,805
 321d06c:	10922704 	addi	r2,r2,18588
 321d070:	10800003 	ldbu	r2,0(r2)
 321d074:	1884703a 	and	r2,r3,r2
 321d078:	1007883a 	mov	r3,r2
 321d07c:	0080c974 	movhi	r2,805
 321d080:	10922704 	addi	r2,r2,18588
 321d084:	10c00005 	stb	r3,0(r2)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
 321d088:	0080c974 	movhi	r2,805
 321d08c:	10922a04 	addi	r2,r2,18600
 321d090:	10c00017 	ldw	r3,0(r2)
 321d094:	e0bfff0b 	ldhu	r2,-4(fp)
 321d098:	18800b8d 	sth	r2,46(r3)
 321d09c:	e0bffd17 	ldw	r2,-12(fp)
 321d0a0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321d0a4:	e0bffb17 	ldw	r2,-20(fp)
 321d0a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
 321d0ac:	3216c840 	call	3216c84 <OS_Sched>
    }
}
 321d0b0:	e037883a 	mov	sp,fp
 321d0b4:	dfc00117 	ldw	ra,4(sp)
 321d0b8:	df000017 	ldw	fp,0(sp)
 321d0bc:	dec00204 	addi	sp,sp,8
 321d0c0:	f800283a 	ret

0321d0c4 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
 321d0c4:	defff604 	addi	sp,sp,-40
 321d0c8:	dfc00915 	stw	ra,36(sp)
 321d0cc:	df000815 	stw	fp,32(sp)
 321d0d0:	dc000715 	stw	r16,28(sp)
 321d0d4:	df000704 	addi	fp,sp,28
 321d0d8:	e13ffb05 	stb	r4,-20(fp)
 321d0dc:	e17ffc05 	stb	r5,-16(fp)
 321d0e0:	e1bffd05 	stb	r6,-12(fp)
 321d0e4:	e1fffe0d 	sth	r7,-8(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 321d0e8:	0080c974 	movhi	r2,805
 321d0ec:	10922904 	addi	r2,r2,18596
 321d0f0:	10800003 	ldbu	r2,0(r2)
 321d0f4:	10803fcc 	andi	r2,r2,255
 321d0f8:	1005003a 	cmpeq	r2,r2,zero
 321d0fc:	1000031e 	bne	r2,zero,321d10c <OSTimeDlyHMSM+0x48>
        return (OS_ERR_TIME_DLY_ISR);
 321d100:	00801544 	movi	r2,85
 321d104:	e0bfff15 	stw	r2,-4(fp)
 321d108:	00004406 	br	321d21c <OSTimeDlyHMSM+0x158>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
 321d10c:	e0bffb03 	ldbu	r2,-20(fp)
 321d110:	1004c03a 	cmpne	r2,r2,zero
 321d114:	10000c1e 	bne	r2,zero,321d148 <OSTimeDlyHMSM+0x84>
        if (minutes == 0) {
 321d118:	e0bffc03 	ldbu	r2,-16(fp)
 321d11c:	1004c03a 	cmpne	r2,r2,zero
 321d120:	1000091e 	bne	r2,zero,321d148 <OSTimeDlyHMSM+0x84>
            if (seconds == 0) {
 321d124:	e0bffd03 	ldbu	r2,-12(fp)
 321d128:	1004c03a 	cmpne	r2,r2,zero
 321d12c:	1000061e 	bne	r2,zero,321d148 <OSTimeDlyHMSM+0x84>
                if (ms == 0) {
 321d130:	e0bffe0b 	ldhu	r2,-8(fp)
 321d134:	1004c03a 	cmpne	r2,r2,zero
 321d138:	1000031e 	bne	r2,zero,321d148 <OSTimeDlyHMSM+0x84>
                    return (OS_ERR_TIME_ZERO_DLY);
 321d13c:	00801504 	movi	r2,84
 321d140:	e0bfff15 	stw	r2,-4(fp)
 321d144:	00003506 	br	321d21c <OSTimeDlyHMSM+0x158>
                }
            }
        }
    }
    if (minutes > 59) {
 321d148:	e0bffc03 	ldbu	r2,-16(fp)
 321d14c:	10800f30 	cmpltui	r2,r2,60
 321d150:	1000031e 	bne	r2,zero,321d160 <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
 321d154:	00801444 	movi	r2,81
 321d158:	e0bfff15 	stw	r2,-4(fp)
 321d15c:	00002f06 	br	321d21c <OSTimeDlyHMSM+0x158>
    }
    if (seconds > 59) {
 321d160:	e0bffd03 	ldbu	r2,-12(fp)
 321d164:	10800f30 	cmpltui	r2,r2,60
 321d168:	1000031e 	bne	r2,zero,321d178 <OSTimeDlyHMSM+0xb4>
        return (OS_ERR_TIME_INVALID_SECONDS);
 321d16c:	00801484 	movi	r2,82
 321d170:	e0bfff15 	stw	r2,-4(fp)
 321d174:	00002906 	br	321d21c <OSTimeDlyHMSM+0x158>
    }
    if (ms > 999) {
 321d178:	e0bffe0b 	ldhu	r2,-8(fp)
 321d17c:	1080fa30 	cmpltui	r2,r2,1000
 321d180:	1000031e 	bne	r2,zero,321d190 <OSTimeDlyHMSM+0xcc>
        return (OS_ERR_TIME_INVALID_MS);
 321d184:	008014c4 	movi	r2,83
 321d188:	e0bfff15 	stw	r2,-4(fp)
 321d18c:	00002306 	br	321d21c <OSTimeDlyHMSM+0x158>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 321d190:	e0bffb03 	ldbu	r2,-20(fp)
 321d194:	10c38424 	muli	r3,r2,3600
 321d198:	e0bffc03 	ldbu	r2,-16(fp)
 321d19c:	10800f24 	muli	r2,r2,60
 321d1a0:	1887883a 	add	r3,r3,r2
 321d1a4:	e0bffd03 	ldbu	r2,-12(fp)
 321d1a8:	1885883a 	add	r2,r3,r2
 321d1ac:	1400fa24 	muli	r16,r2,1000
 321d1b0:	e0bffe0b 	ldhu	r2,-8(fp)
 321d1b4:	1100fa24 	muli	r4,r2,1000
 321d1b8:	0140fa04 	movi	r5,1000
 321d1bc:	32044bc0 	call	32044bc <__udivsi3>
 321d1c0:	8085883a 	add	r2,r16,r2
 321d1c4:	e0bffa15 	stw	r2,-24(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
 321d1c8:	e0bffa17 	ldw	r2,-24(fp)
 321d1cc:	1004d43a 	srli	r2,r2,16
 321d1d0:	e0bff90d 	sth	r2,-28(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
 321d1d4:	e0bffa17 	ldw	r2,-24(fp)
 321d1d8:	10bfffcc 	andi	r2,r2,65535
 321d1dc:	e0bffa15 	stw	r2,-24(fp)
    OSTimeDly((INT16U)ticks);
 321d1e0:	e0bffa17 	ldw	r2,-24(fp)
 321d1e4:	113fffcc 	andi	r4,r2,65535
 321d1e8:	321cf780 	call	321cf78 <OSTimeDly>
    while (loops > 0) {
 321d1ec:	00000706 	br	321d20c <OSTimeDlyHMSM+0x148>
        OSTimeDly((INT16U)32768u);
 321d1f0:	01200014 	movui	r4,32768
 321d1f4:	321cf780 	call	321cf78 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
 321d1f8:	01200014 	movui	r4,32768
 321d1fc:	321cf780 	call	321cf78 <OSTimeDly>
        loops--;
 321d200:	e0bff90b 	ldhu	r2,-28(fp)
 321d204:	10bfffc4 	addi	r2,r2,-1
 321d208:	e0bff90d 	sth	r2,-28(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
 321d20c:	e0bff90b 	ldhu	r2,-28(fp)
 321d210:	1004c03a 	cmpne	r2,r2,zero
 321d214:	103ff61e 	bne	r2,zero,321d1f0 <OSTimeDlyHMSM+0x12c>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
 321d218:	e03fff15 	stw	zero,-4(fp)
 321d21c:	e0bfff17 	ldw	r2,-4(fp)
}
 321d220:	e037883a 	mov	sp,fp
 321d224:	dfc00217 	ldw	ra,8(sp)
 321d228:	df000117 	ldw	fp,4(sp)
 321d22c:	dc000017 	ldw	r16,0(sp)
 321d230:	dec00304 	addi	sp,sp,12
 321d234:	f800283a 	ret

0321d238 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
 321d238:	defff404 	addi	sp,sp,-48
 321d23c:	dfc00b15 	stw	ra,44(sp)
 321d240:	df000a15 	stw	fp,40(sp)
 321d244:	df000a04 	addi	fp,sp,40
 321d248:	e13ffe05 	stb	r4,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 321d24c:	e03ffc15 	stw	zero,-16(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
 321d250:	e0bffe03 	ldbu	r2,-8(fp)
 321d254:	10800530 	cmpltui	r2,r2,20
 321d258:	1000031e 	bne	r2,zero,321d268 <OSTimeDlyResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 321d25c:	00800a84 	movi	r2,42
 321d260:	e0bfff15 	stw	r2,-4(fp)
 321d264:	00007206 	br	321d430 <OSTimeDlyResume+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321d268:	0005303a 	rdctl	r2,status
 321d26c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321d270:	e0fffb17 	ldw	r3,-20(fp)
 321d274:	00bfff84 	movi	r2,-2
 321d278:	1884703a 	and	r2,r3,r2
 321d27c:	1001703a 	wrctl	status,r2
  
  return context;
 321d280:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 321d284:	e0bffc15 	stw	r2,-16(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
 321d288:	e0bffe03 	ldbu	r2,-8(fp)
 321d28c:	00c0c9b4 	movhi	r3,806
 321d290:	18f18004 	addi	r3,r3,-14848
 321d294:	1085883a 	add	r2,r2,r2
 321d298:	1085883a 	add	r2,r2,r2
 321d29c:	10c5883a 	add	r2,r2,r3
 321d2a0:	10800017 	ldw	r2,0(r2)
 321d2a4:	e0bffd15 	stw	r2,-12(fp)
    if (ptcb == (OS_TCB *)0) {
 321d2a8:	e0bffd17 	ldw	r2,-12(fp)
 321d2ac:	1004c03a 	cmpne	r2,r2,zero
 321d2b0:	1000071e 	bne	r2,zero,321d2d0 <OSTimeDlyResume+0x98>
 321d2b4:	e0bffc17 	ldw	r2,-16(fp)
 321d2b8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321d2bc:	e0bffa17 	ldw	r2,-24(fp)
 321d2c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 321d2c4:	008010c4 	movi	r2,67
 321d2c8:	e0bfff15 	stw	r2,-4(fp)
 321d2cc:	00005806 	br	321d430 <OSTimeDlyResume+0x1f8>
    }
    if (ptcb == OS_TCB_RESERVED) {
 321d2d0:	e0bffd17 	ldw	r2,-12(fp)
 321d2d4:	10800058 	cmpnei	r2,r2,1
 321d2d8:	1000071e 	bne	r2,zero,321d2f8 <OSTimeDlyResume+0xc0>
 321d2dc:	e0bffc17 	ldw	r2,-16(fp)
 321d2e0:	e0bff915 	stw	r2,-28(fp)
 321d2e4:	e0bff917 	ldw	r2,-28(fp)
 321d2e8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 321d2ec:	008010c4 	movi	r2,67
 321d2f0:	e0bfff15 	stw	r2,-4(fp)
 321d2f4:	00004e06 	br	321d430 <OSTimeDlyResume+0x1f8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
 321d2f8:	e0bffd17 	ldw	r2,-12(fp)
 321d2fc:	10800b8b 	ldhu	r2,46(r2)
 321d300:	10bfffcc 	andi	r2,r2,65535
 321d304:	1004c03a 	cmpne	r2,r2,zero
 321d308:	1000071e 	bne	r2,zero,321d328 <OSTimeDlyResume+0xf0>
 321d30c:	e0bffc17 	ldw	r2,-16(fp)
 321d310:	e0bff815 	stw	r2,-32(fp)
 321d314:	e0bff817 	ldw	r2,-32(fp)
 321d318:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
 321d31c:	00801404 	movi	r2,80
 321d320:	e0bfff15 	stw	r2,-4(fp)
 321d324:	00004206 	br	321d430 <OSTimeDlyResume+0x1f8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
 321d328:	e0bffd17 	ldw	r2,-12(fp)
 321d32c:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 321d330:	e0bffd17 	ldw	r2,-12(fp)
 321d334:	10800c03 	ldbu	r2,48(r2)
 321d338:	10803fcc 	andi	r2,r2,255
 321d33c:	10800dcc 	andi	r2,r2,55
 321d340:	1005003a 	cmpeq	r2,r2,zero
 321d344:	10000b1e 	bne	r2,zero,321d374 <OSTimeDlyResume+0x13c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
 321d348:	e0bffd17 	ldw	r2,-12(fp)
 321d34c:	10c00c03 	ldbu	r3,48(r2)
 321d350:	00bff204 	movi	r2,-56
 321d354:	1884703a 	and	r2,r3,r2
 321d358:	1007883a 	mov	r3,r2
 321d35c:	e0bffd17 	ldw	r2,-12(fp)
 321d360:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
 321d364:	e0fffd17 	ldw	r3,-12(fp)
 321d368:	00800044 	movi	r2,1
 321d36c:	18800c45 	stb	r2,49(r3)
 321d370:	00000206 	br	321d37c <OSTimeDlyResume+0x144>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
 321d374:	e0bffd17 	ldw	r2,-12(fp)
 321d378:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
 321d37c:	e0bffd17 	ldw	r2,-12(fp)
 321d380:	10800c03 	ldbu	r2,48(r2)
 321d384:	10803fcc 	andi	r2,r2,255
 321d388:	1080020c 	andi	r2,r2,8
 321d38c:	1004c03a 	cmpne	r2,r2,zero
 321d390:	1000221e 	bne	r2,zero,321d41c <OSTimeDlyResume+0x1e4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
 321d394:	e0bffd17 	ldw	r2,-12(fp)
 321d398:	10c00d83 	ldbu	r3,54(r2)
 321d39c:	0080c974 	movhi	r2,805
 321d3a0:	10922704 	addi	r2,r2,18588
 321d3a4:	10800003 	ldbu	r2,0(r2)
 321d3a8:	1884b03a 	or	r2,r3,r2
 321d3ac:	1007883a 	mov	r3,r2
 321d3b0:	0080c974 	movhi	r2,805
 321d3b4:	10922704 	addi	r2,r2,18588
 321d3b8:	10c00005 	stb	r3,0(r2)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 321d3bc:	e0bffd17 	ldw	r2,-12(fp)
 321d3c0:	10800d03 	ldbu	r2,52(r2)
 321d3c4:	11003fcc 	andi	r4,r2,255
 321d3c8:	e0bffd17 	ldw	r2,-12(fp)
 321d3cc:	10800d03 	ldbu	r2,52(r2)
 321d3d0:	10c03fcc 	andi	r3,r2,255
 321d3d4:	0080c974 	movhi	r2,805
 321d3d8:	10922744 	addi	r2,r2,18589
 321d3dc:	10c5883a 	add	r2,r2,r3
 321d3e0:	10c00003 	ldbu	r3,0(r2)
 321d3e4:	e0bffd17 	ldw	r2,-12(fp)
 321d3e8:	10800d43 	ldbu	r2,53(r2)
 321d3ec:	1884b03a 	or	r2,r3,r2
 321d3f0:	1007883a 	mov	r3,r2
 321d3f4:	0080c974 	movhi	r2,805
 321d3f8:	10922744 	addi	r2,r2,18589
 321d3fc:	1105883a 	add	r2,r2,r4
 321d400:	10c00005 	stb	r3,0(r2)
 321d404:	e0bffc17 	ldw	r2,-16(fp)
 321d408:	e0bff715 	stw	r2,-36(fp)
 321d40c:	e0bff717 	ldw	r2,-36(fp)
 321d410:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
 321d414:	3216c840 	call	3216c84 <OS_Sched>
 321d418:	00000406 	br	321d42c <OSTimeDlyResume+0x1f4>
 321d41c:	e0bffc17 	ldw	r2,-16(fp)
 321d420:	e0bff615 	stw	r2,-40(fp)
 321d424:	e0bff617 	ldw	r2,-40(fp)
 321d428:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
 321d42c:	e03fff15 	stw	zero,-4(fp)
 321d430:	e0bfff17 	ldw	r2,-4(fp)
}
 321d434:	e037883a 	mov	sp,fp
 321d438:	dfc00117 	ldw	ra,4(sp)
 321d43c:	df000017 	ldw	fp,0(sp)
 321d440:	dec00204 	addi	sp,sp,8
 321d444:	f800283a 	ret

0321d448 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
 321d448:	defffb04 	addi	sp,sp,-20
 321d44c:	df000415 	stw	fp,16(sp)
 321d450:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 321d454:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321d458:	0005303a 	rdctl	r2,status
 321d45c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321d460:	e0fffd17 	ldw	r3,-12(fp)
 321d464:	00bfff84 	movi	r2,-2
 321d468:	1884703a 	and	r2,r3,r2
 321d46c:	1001703a 	wrctl	status,r2
  
  return context;
 321d470:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 321d474:	e0bffe15 	stw	r2,-8(fp)
    ticks = OSTime;
 321d478:	0080c974 	movhi	r2,805
 321d47c:	10922b04 	addi	r2,r2,18604
 321d480:	10800017 	ldw	r2,0(r2)
 321d484:	e0bfff15 	stw	r2,-4(fp)
 321d488:	e0bffe17 	ldw	r2,-8(fp)
 321d48c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321d490:	e0bffc17 	ldw	r2,-16(fp)
 321d494:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
 321d498:	e0bfff17 	ldw	r2,-4(fp)
}
 321d49c:	e037883a 	mov	sp,fp
 321d4a0:	df000017 	ldw	fp,0(sp)
 321d4a4:	dec00104 	addi	sp,sp,4
 321d4a8:	f800283a 	ret

0321d4ac <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
 321d4ac:	defffb04 	addi	sp,sp,-20
 321d4b0:	df000415 	stw	fp,16(sp)
 321d4b4:	df000404 	addi	fp,sp,16
 321d4b8:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 321d4bc:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321d4c0:	0005303a 	rdctl	r2,status
 321d4c4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321d4c8:	e0fffd17 	ldw	r3,-12(fp)
 321d4cc:	00bfff84 	movi	r2,-2
 321d4d0:	1884703a 	and	r2,r3,r2
 321d4d4:	1001703a 	wrctl	status,r2
  
  return context;
 321d4d8:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 321d4dc:	e0bffe15 	stw	r2,-8(fp)
    OSTime = ticks;
 321d4e0:	00c0c974 	movhi	r3,805
 321d4e4:	18d22b04 	addi	r3,r3,18604
 321d4e8:	e0bfff17 	ldw	r2,-4(fp)
 321d4ec:	18800015 	stw	r2,0(r3)
 321d4f0:	e0bffe17 	ldw	r2,-8(fp)
 321d4f4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321d4f8:	e0bffc17 	ldw	r2,-16(fp)
 321d4fc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 321d500:	e037883a 	mov	sp,fp
 321d504:	df000017 	ldw	fp,0(sp)
 321d508:	dec00104 	addi	sp,sp,4
 321d50c:	f800283a 	ret

0321d510 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 321d510:	defffd04 	addi	sp,sp,-12
 321d514:	dfc00215 	stw	ra,8(sp)
 321d518:	df000115 	stw	fp,4(sp)
 321d51c:	df000104 	addi	fp,sp,4
 321d520:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_IRQ_INIT ( CPU, cpu);
 321d524:	323b1000 	call	323b100 <altera_nios2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 321d528:	00800044 	movi	r2,1
 321d52c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 321d530:	e037883a 	mov	sp,fp
 321d534:	dfc00117 	ldw	ra,4(sp)
 321d538:	df000017 	ldw	fp,0(sp)
 321d53c:	dec00204 	addi	sp,sp,8
 321d540:	f800283a 	ret

0321d544 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 321d544:	defffc04 	addi	sp,sp,-16
 321d548:	dfc00315 	stw	ra,12(sp)
 321d54c:	df000215 	stw	fp,8(sp)
 321d550:	df000204 	addi	fp,sp,8
    ALTERA_AVALON_TIMER_INIT ( TIMER, timer);
 321d554:	01004034 	movhi	r4,256
 321d558:	21018004 	addi	r4,r4,1536
 321d55c:	000b883a 	mov	r5,zero
 321d560:	01800044 	movi	r6,1
 321d564:	01c0fa04 	movi	r7,1000
 321d568:	32210bc0 	call	32210bc <alt_avalon_timer_sc_init>
    ALTERA_AVALON_CFI_FLASH_INIT ( EXT_FLASH, ext_flash);
 321d56c:	0100c974 	movhi	r4,805
 321d570:	2103a904 	addi	r4,r4,3748
 321d574:	321d64c0 	call	321d64c <alt_flash_cfi_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
 321d578:	0100c974 	movhi	r4,805
 321d57c:	2103e904 	addi	r4,r4,4004
 321d580:	000b883a 	mov	r5,zero
 321d584:	000d883a 	mov	r6,zero
 321d588:	321f4a40 	call	321f4a4 <altera_avalon_jtag_uart_init>
 321d58c:	0100c974 	movhi	r4,805
 321d590:	2103df04 	addi	r4,r4,3964
 321d594:	321d6140 	call	321d614 <alt_dev_reg>
    ALTERA_AVALON_LCD_16207_INIT ( LCD, lcd);
 321d598:	0100c974 	movhi	r4,805
 321d59c:	21080404 	addi	r4,r4,8208
 321d5a0:	3220e8c0 	call	3220e8c <altera_avalon_lcd_16207_init>
 321d5a4:	0100c974 	movhi	r4,805
 321d5a8:	2107fa04 	addi	r4,r4,8168
 321d5ac:	321d6140 	call	321d614 <alt_dev_reg>
 321d5b0:	0080c974 	movhi	r2,805
 321d5b4:	1089a104 	addi	r2,r2,9860
 321d5b8:	e0bffe15 	stw	r2,-8(fp)
 321d5bc:	0080c974 	movhi	r2,805
 321d5c0:	10884304 	addi	r2,r2,8460
 321d5c4:	e0bfff15 	stw	r2,-4(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 321d5c8:	e0ffff17 	ldw	r3,-4(fp)
 321d5cc:	e0bffe17 	ldw	r2,-8(fp)
 321d5d0:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 321d5d4:	e0bffe17 	ldw	r2,-8(fp)
 321d5d8:	10c00017 	ldw	r3,0(r2)
 321d5dc:	e0bfff17 	ldw	r2,-4(fp)
 321d5e0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 321d5e4:	e0bffe17 	ldw	r2,-8(fp)
 321d5e8:	10c00017 	ldw	r3,0(r2)
 321d5ec:	e0bfff17 	ldw	r2,-4(fp)
 321d5f0:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 321d5f4:	e0fffe17 	ldw	r3,-8(fp)
 321d5f8:	e0bfff17 	ldw	r2,-4(fp)
 321d5fc:	18800015 	stw	r2,0(r3)
    ALTERA_AVALON_SYSID_INIT ( SYSID, sysid);
    ETH_OCM_INIT ( ETH_OCM_0, eth_ocm_0);
}
 321d600:	e037883a 	mov	sp,fp
 321d604:	dfc00117 	ldw	ra,4(sp)
 321d608:	df000017 	ldw	fp,0(sp)
 321d60c:	dec00204 	addi	sp,sp,8
 321d610:	f800283a 	ret

0321d614 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 321d614:	defffd04 	addi	sp,sp,-12
 321d618:	dfc00215 	stw	ra,8(sp)
 321d61c:	df000115 	stw	fp,4(sp)
 321d620:	df000104 	addi	fp,sp,4
 321d624:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 321d628:	e13fff17 	ldw	r4,-4(fp)
 321d62c:	0140c974 	movhi	r5,805
 321d630:	2949b704 	addi	r5,r5,9948
 321d634:	323a3180 	call	323a318 <alt_dev_llist_insert>
}
 321d638:	e037883a 	mov	sp,fp
 321d63c:	dfc00117 	ldw	ra,4(sp)
 321d640:	df000017 	ldw	fp,0(sp)
 321d644:	dec00204 	addi	sp,sp,8
 321d648:	f800283a 	ret

0321d64c <alt_flash_cfi_init>:
 * Read the CFI table and fill out the alt_flash_cfi_dev structure with all the 
 * information we need to program the flash.
 * 
 */
int alt_flash_cfi_init( alt_flash_cfi_dev* flash  )
{
 321d64c:	defffc04 	addi	sp,sp,-16
 321d650:	dfc00315 	stw	ra,12(sp)
 321d654:	df000215 	stw	fp,8(sp)
 321d658:	df000204 	addi	fp,sp,8
 321d65c:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 321d660:	e03ffe15 	stw	zero,-8(fp)
 
  ret_code = alt_read_cfi_width( flash );
 321d664:	e13fff17 	ldw	r4,-4(fp)
 321d668:	321ead40 	call	321ead4 <alt_read_cfi_width>
 321d66c:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 321d670:	e0bffe17 	ldw	r2,-8(fp)
 321d674:	1004c03a 	cmpne	r2,r2,zero
 321d678:	1000031e 	bne	r2,zero,321d688 <alt_flash_cfi_init+0x3c>
    ret_code = alt_set_flash_width_func( flash );
 321d67c:	e13fff17 	ldw	r4,-4(fp)
 321d680:	321e24c0 	call	321e24c <alt_set_flash_width_func>
 321d684:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 321d688:	e0bffe17 	ldw	r2,-8(fp)
 321d68c:	1004c03a 	cmpne	r2,r2,zero
 321d690:	1000031e 	bne	r2,zero,321d6a0 <alt_flash_cfi_init+0x54>
    ret_code = alt_read_cfi_table( flash );
 321d694:	e13fff17 	ldw	r4,-4(fp)
 321d698:	321e5540 	call	321e554 <alt_read_cfi_table>
 321d69c:	e0bffe15 	stw	r2,-8(fp)

  if (!ret_code) 
 321d6a0:	e0bffe17 	ldw	r2,-8(fp)
 321d6a4:	1004c03a 	cmpne	r2,r2,zero
 321d6a8:	1000031e 	bne	r2,zero,321d6b8 <alt_flash_cfi_init+0x6c>
    ret_code = alt_set_flash_algorithm_func( flash);
 321d6ac:	e13fff17 	ldw	r4,-4(fp)
 321d6b0:	321e42c0 	call	321e42c <alt_set_flash_algorithm_func>
 321d6b4:	e0bffe15 	stw	r2,-8(fp)

  /*
  *  Register this device as a valid flash device type
  */ 
  if (!ret_code)
 321d6b8:	e0bffe17 	ldw	r2,-8(fp)
 321d6bc:	1004c03a 	cmpne	r2,r2,zero
 321d6c0:	1000031e 	bne	r2,zero,321d6d0 <alt_flash_cfi_init+0x84>
    ret_code = alt_flash_device_register(&(flash->dev));
 321d6c4:	e13fff17 	ldw	r4,-4(fp)
 321d6c8:	321d6e80 	call	321d6e8 <alt_flash_device_register>
 321d6cc:	e0bffe15 	stw	r2,-8(fp)
 
  return ret_code;
 321d6d0:	e0bffe17 	ldw	r2,-8(fp)
}
 321d6d4:	e037883a 	mov	sp,fp
 321d6d8:	dfc00117 	ldw	ra,4(sp)
 321d6dc:	df000017 	ldw	fp,0(sp)
 321d6e0:	dec00204 	addi	sp,sp,8
 321d6e4:	f800283a 	ret

0321d6e8 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
 321d6e8:	defffd04 	addi	sp,sp,-12
 321d6ec:	dfc00215 	stw	ra,8(sp)
 321d6f0:	df000115 	stw	fp,4(sp)
 321d6f4:	df000104 	addi	fp,sp,4
 321d6f8:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
 321d6fc:	e13fff17 	ldw	r4,-4(fp)
 321d700:	0140c974 	movhi	r5,805
 321d704:	29497e04 	addi	r5,r5,9720
 321d708:	323a3180 	call	323a318 <alt_dev_llist_insert>
}
 321d70c:	e037883a 	mov	sp,fp
 321d710:	dfc00117 	ldw	ra,4(sp)
 321d714:	df000017 	ldw	fp,0(sp)
 321d718:	dec00204 	addi	sp,sp,8
 321d71c:	f800283a 	ret

0321d720 <alt_flash_cfi_write>:
 * large buffer to tie up in our programming library, when not all users will 
 * want that functionality.
 */
 int alt_flash_cfi_write( alt_flash_dev* flash_info, int offset, 
                          const void* src_addr, int length )
 {
 321d720:	deffef04 	addi	sp,sp,-68
 321d724:	dfc01015 	stw	ra,64(sp)
 321d728:	df000f15 	stw	fp,60(sp)
 321d72c:	df000f04 	addi	fp,sp,60
 321d730:	e13ffa15 	stw	r4,-24(fp)
 321d734:	e17ffb15 	stw	r5,-20(fp)
 321d738:	e1bffc15 	stw	r6,-16(fp)
 321d73c:	e1fffd15 	stw	r7,-12(fp)
  int         ret_code = 0;
 321d740:	e03ff915 	stw	zero,-28(fp)
  int         i,j;
  int         data_to_write;
  int         full_length = length;
 321d744:	e0bffd17 	ldw	r2,-12(fp)
 321d748:	e0bff515 	stw	r2,-44(fp)
  int         current_offset;
  int         start_offset = offset;
 321d74c:	e0bffb17 	ldw	r2,-20(fp)
 321d750:	e0bff315 	stw	r2,-52(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 321d754:	e0bffa17 	ldw	r2,-24(fp)
 321d758:	e0bff215 	stw	r2,-56(fp)

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 321d75c:	e03ff815 	stw	zero,-32(fp)
 321d760:	00008e06 	br	321d99c <alt_flash_cfi_write+0x27c>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash->dev.region_info[i].offset) &&
 321d764:	e0bff817 	ldw	r2,-32(fp)
 321d768:	e0fff217 	ldw	r3,-56(fp)
 321d76c:	1004913a 	slli	r2,r2,4
 321d770:	10c5883a 	add	r2,r2,r3
 321d774:	10800d04 	addi	r2,r2,52
 321d778:	10c00017 	ldw	r3,0(r2)
 321d77c:	e0bffb17 	ldw	r2,-20(fp)
 321d780:	10c08316 	blt	r2,r3,321d990 <alt_flash_cfi_write+0x270>
 321d784:	e0bff817 	ldw	r2,-32(fp)
 321d788:	e0fff217 	ldw	r3,-56(fp)
 321d78c:	1004913a 	slli	r2,r2,4
 321d790:	10c5883a 	add	r2,r2,r3
 321d794:	10800d04 	addi	r2,r2,52
 321d798:	11000017 	ldw	r4,0(r2)
 321d79c:	e0bff817 	ldw	r2,-32(fp)
 321d7a0:	e0fff217 	ldw	r3,-56(fp)
 321d7a4:	1004913a 	slli	r2,r2,4
 321d7a8:	10c5883a 	add	r2,r2,r3
 321d7ac:	10800e04 	addi	r2,r2,56
 321d7b0:	10800017 	ldw	r2,0(r2)
 321d7b4:	2087883a 	add	r3,r4,r2
 321d7b8:	e0bffb17 	ldw	r2,-20(fp)
 321d7bc:	10c0740e 	bge	r2,r3,321d990 <alt_flash_cfi_write+0x270>
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;
 321d7c0:	e0bff817 	ldw	r2,-32(fp)
 321d7c4:	e0fff217 	ldw	r3,-56(fp)
 321d7c8:	1004913a 	slli	r2,r2,4
 321d7cc:	10c5883a 	add	r2,r2,r3
 321d7d0:	10800d04 	addi	r2,r2,52
 321d7d4:	10800017 	ldw	r2,0(r2)
 321d7d8:	e0bff415 	stw	r2,-48(fp)

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 321d7dc:	e03ff715 	stw	zero,-36(fp)
 321d7e0:	00006306 	br	321d970 <alt_flash_cfi_write+0x250>
      {
        if ((offset >= current_offset ) && 
 321d7e4:	e0fffb17 	ldw	r3,-20(fp)
 321d7e8:	e0bff417 	ldw	r2,-48(fp)
 321d7ec:	18805416 	blt	r3,r2,321d940 <alt_flash_cfi_write+0x220>
 321d7f0:	e0bff817 	ldw	r2,-32(fp)
 321d7f4:	e0fff217 	ldw	r3,-56(fp)
 321d7f8:	1004913a 	slli	r2,r2,4
 321d7fc:	10c5883a 	add	r2,r2,r3
 321d800:	10801004 	addi	r2,r2,64
 321d804:	10c00017 	ldw	r3,0(r2)
 321d808:	e0bff417 	ldw	r2,-48(fp)
 321d80c:	1887883a 	add	r3,r3,r2
 321d810:	e0bffb17 	ldw	r2,-20(fp)
 321d814:	10c04a0e 	bge	r2,r3,321d940 <alt_flash_cfi_write+0x220>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash->dev.region_info[i].block_size 
 321d818:	e0bff817 	ldw	r2,-32(fp)
 321d81c:	e0fff217 	ldw	r3,-56(fp)
 321d820:	1004913a 	slli	r2,r2,4
 321d824:	10c5883a 	add	r2,r2,r3
 321d828:	10801004 	addi	r2,r2,64
 321d82c:	10c00017 	ldw	r3,0(r2)
 321d830:	e0bff417 	ldw	r2,-48(fp)
 321d834:	1887883a 	add	r3,r3,r2
 321d838:	e0bffb17 	ldw	r2,-20(fp)
 321d83c:	1885c83a 	sub	r2,r3,r2
 321d840:	e0bff615 	stw	r2,-40(fp)
                            - offset); 
          data_to_write = MIN(data_to_write, length);
 321d844:	e0bff617 	ldw	r2,-40(fp)
 321d848:	e0bfff15 	stw	r2,-4(fp)
 321d84c:	e0fffd17 	ldw	r3,-12(fp)
 321d850:	e0fffe15 	stw	r3,-8(fp)
 321d854:	e0bfff17 	ldw	r2,-4(fp)
 321d858:	e0fffe17 	ldw	r3,-8(fp)
 321d85c:	10c0020e 	bge	r2,r3,321d868 <alt_flash_cfi_write+0x148>
 321d860:	e0bfff17 	ldw	r2,-4(fp)
 321d864:	e0bffe15 	stw	r2,-8(fp)
 321d868:	e0fffe17 	ldw	r3,-8(fp)
 321d86c:	e0fff615 	stw	r3,-40(fp)
          if(memcmp(src_addr, 
 321d870:	e0bff217 	ldw	r2,-56(fp)
 321d874:	10800a17 	ldw	r2,40(r2)
 321d878:	1007883a 	mov	r3,r2
 321d87c:	e0bffb17 	ldw	r2,-20(fp)
 321d880:	188b883a 	add	r5,r3,r2
 321d884:	e1bff617 	ldw	r6,-40(fp)
 321d888:	e13ffc17 	ldw	r4,-16(fp)
 321d88c:	324b95c0 	call	324b95c <memcmp>
 321d890:	1005003a 	cmpeq	r2,r2,zero
 321d894:	1000131e 	bne	r2,zero,321d8e4 <alt_flash_cfi_write+0x1c4>
                    (alt_u8*)flash->dev.base_addr+offset,
                    data_to_write))
          {
            ret_code = (*flash->dev.erase_block)( &flash->dev, current_offset);
 321d898:	e0bff217 	ldw	r2,-56(fp)
 321d89c:	10800817 	ldw	r2,32(r2)
 321d8a0:	e13ff217 	ldw	r4,-56(fp)
 321d8a4:	e17ff417 	ldw	r5,-48(fp)
 321d8a8:	103ee83a 	callr	r2
 321d8ac:	e0bff915 	stw	r2,-28(fp)

            if (!ret_code)
 321d8b0:	e0bff917 	ldw	r2,-28(fp)
 321d8b4:	1004c03a 	cmpne	r2,r2,zero
 321d8b8:	10000a1e 	bne	r2,zero,321d8e4 <alt_flash_cfi_write+0x1c4>
            {
              ret_code = (*flash->dev.write_block)( 
 321d8bc:	e0bff217 	ldw	r2,-56(fp)
 321d8c0:	10c00917 	ldw	r3,36(r2)
 321d8c4:	e13ff217 	ldw	r4,-56(fp)
 321d8c8:	e0bff617 	ldw	r2,-40(fp)
 321d8cc:	d8800015 	stw	r2,0(sp)
 321d8d0:	e17ff417 	ldw	r5,-48(fp)
 321d8d4:	e1bffb17 	ldw	r6,-20(fp)
 321d8d8:	e1fffc17 	ldw	r7,-16(fp)
 321d8dc:	183ee83a 	callr	r3
 321d8e0:	e0bff915 	stw	r2,-28(fp)
                                                  data_to_write);
            }
          }    
    
          /* Was this the last block? */    
          if ((length == data_to_write) || ret_code)
 321d8e4:	e0fffd17 	ldw	r3,-12(fp)
 321d8e8:	e0bff617 	ldw	r2,-40(fp)
 321d8ec:	18802f26 	beq	r3,r2,321d9ac <alt_flash_cfi_write+0x28c>
 321d8f0:	e0bff917 	ldw	r2,-28(fp)
 321d8f4:	1004c03a 	cmpne	r2,r2,zero
 321d8f8:	10002c1e 	bne	r2,zero,321d9ac <alt_flash_cfi_write+0x28c>
          {
            goto finished;
          }
          
          length -= data_to_write;
 321d8fc:	e0fffd17 	ldw	r3,-12(fp)
 321d900:	e0bff617 	ldw	r2,-40(fp)
 321d904:	1885c83a 	sub	r2,r3,r2
 321d908:	e0bffd15 	stw	r2,-12(fp)
          offset = current_offset + flash->dev.region_info[i].block_size;
 321d90c:	e0bff817 	ldw	r2,-32(fp)
 321d910:	e0fff217 	ldw	r3,-56(fp)
 321d914:	1004913a 	slli	r2,r2,4
 321d918:	10c5883a 	add	r2,r2,r3
 321d91c:	10801004 	addi	r2,r2,64
 321d920:	10c00017 	ldw	r3,0(r2)
 321d924:	e0bff417 	ldw	r2,-48(fp)
 321d928:	1885883a 	add	r2,r3,r2
 321d92c:	e0bffb15 	stw	r2,-20(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
 321d930:	e0fffc17 	ldw	r3,-16(fp)
 321d934:	e0bff617 	ldw	r2,-40(fp)
 321d938:	1885883a 	add	r2,r3,r2
 321d93c:	e0bffc15 	stw	r2,-16(fp)
        }
        current_offset += flash->dev.region_info[i].block_size;
 321d940:	e0bff817 	ldw	r2,-32(fp)
 321d944:	e0fff217 	ldw	r3,-56(fp)
 321d948:	1004913a 	slli	r2,r2,4
 321d94c:	10c5883a 	add	r2,r2,r3
 321d950:	10801004 	addi	r2,r2,64
 321d954:	10c00017 	ldw	r3,0(r2)
 321d958:	e0bff417 	ldw	r2,-48(fp)
 321d95c:	10c5883a 	add	r2,r2,r3
 321d960:	e0bff415 	stw	r2,-48(fp)
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 321d964:	e0bff717 	ldw	r2,-36(fp)
 321d968:	10800044 	addi	r2,r2,1
 321d96c:	e0bff715 	stw	r2,-36(fp)
 321d970:	e0bff817 	ldw	r2,-32(fp)
 321d974:	e0fff217 	ldw	r3,-56(fp)
 321d978:	1004913a 	slli	r2,r2,4
 321d97c:	10c5883a 	add	r2,r2,r3
 321d980:	10800f04 	addi	r2,r2,60
 321d984:	10c00017 	ldw	r3,0(r2)
 321d988:	e0bff717 	ldw	r2,-36(fp)
 321d98c:	10ff9516 	blt	r2,r3,321d7e4 <alt_flash_cfi_write+0xc4>
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 321d990:	e0bff817 	ldw	r2,-32(fp)
 321d994:	10800044 	addi	r2,r2,1
 321d998:	e0bff815 	stw	r2,-32(fp)
 321d99c:	e0bff217 	ldw	r2,-56(fp)
 321d9a0:	10c00c17 	ldw	r3,48(r2)
 321d9a4:	e0bff817 	ldw	r2,-32(fp)
 321d9a8:	10ff6e16 	blt	r2,r3,321d764 <alt_flash_cfi_write+0x44>
      }     
    } 
  }
finished:    

  alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
 321d9ac:	e0bff217 	ldw	r2,-56(fp)
 321d9b0:	10800a17 	ldw	r2,40(r2)
 321d9b4:	1007883a 	mov	r3,r2
 321d9b8:	e0bff317 	ldw	r2,-52(fp)
 321d9bc:	1889883a 	add	r4,r3,r2
 321d9c0:	e17ff517 	ldw	r5,-44(fp)
 321d9c4:	323a2300 	call	323a230 <alt_dcache_flush>
  return ret_code;
 321d9c8:	e0bff917 	ldw	r2,-28(fp)
}
 321d9cc:	e037883a 	mov	sp,fp
 321d9d0:	dfc00117 	ldw	ra,4(sp)
 321d9d4:	df000017 	ldw	fp,0(sp)
 321d9d8:	dec00204 	addi	sp,sp,8
 321d9dc:	f800283a 	ret

0321d9e0 <alt_flash_cfi_get_info>:
 * 
 *  Pass the table of erase blocks to the user
 */
int alt_flash_cfi_get_info( alt_flash_fd* fd, flash_region** info, 
                            int* number_of_regions)
{
 321d9e0:	defffa04 	addi	sp,sp,-24
 321d9e4:	df000515 	stw	fp,20(sp)
 321d9e8:	df000504 	addi	fp,sp,20
 321d9ec:	e13ffd15 	stw	r4,-12(fp)
 321d9f0:	e17ffe15 	stw	r5,-8(fp)
 321d9f4:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 321d9f8:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_dev* flash = (alt_flash_dev*)fd;
 321d9fc:	e0bffd17 	ldw	r2,-12(fp)
 321da00:	e0bffb15 	stw	r2,-20(fp)

  *number_of_regions = flash->number_of_regions;
 321da04:	e0bffb17 	ldw	r2,-20(fp)
 321da08:	10c00c17 	ldw	r3,48(r2)
 321da0c:	e0bfff17 	ldw	r2,-4(fp)
 321da10:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
 321da14:	e0bffb17 	ldw	r2,-20(fp)
 321da18:	10800c17 	ldw	r2,48(r2)
 321da1c:	1004c03a 	cmpne	r2,r2,zero
 321da20:	1000031e 	bne	r2,zero,321da30 <alt_flash_cfi_get_info+0x50>
  {
    ret_code = -EIO;
 321da24:	00bffec4 	movi	r2,-5
 321da28:	e0bffc15 	stw	r2,-16(fp)
 321da2c:	00000b06 	br	321da5c <alt_flash_cfi_get_info+0x7c>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 321da30:	e0bffb17 	ldw	r2,-20(fp)
 321da34:	10800c17 	ldw	r2,48(r2)
 321da38:	10800250 	cmplti	r2,r2,9
 321da3c:	1000031e 	bne	r2,zero,321da4c <alt_flash_cfi_get_info+0x6c>
  {
    ret_code = -ENOMEM;
 321da40:	00bffd04 	movi	r2,-12
 321da44:	e0bffc15 	stw	r2,-16(fp)
 321da48:	00000406 	br	321da5c <alt_flash_cfi_get_info+0x7c>
  }
  else
  {
    *info = &flash->region_info[0];
 321da4c:	e0bffb17 	ldw	r2,-20(fp)
 321da50:	10c00d04 	addi	r3,r2,52
 321da54:	e0bffe17 	ldw	r2,-8(fp)
 321da58:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
 321da5c:	e0bffc17 	ldw	r2,-16(fp)
}
 321da60:	e037883a 	mov	sp,fp
 321da64:	df000017 	ldw	fp,0(sp)
 321da68:	dec00104 	addi	sp,sp,4
 321da6c:	f800283a 	ret

0321da70 <alt_flash_cfi_read>:
 *  Read from an area in flash, you could use memcopy yourself
 *  for these flash types, but we're trying to be generic and future proof
 */
int alt_flash_cfi_read( alt_flash_dev* flash_info, int offset, 
                        void* dest_addr, int length )
{
 321da70:	defff904 	addi	sp,sp,-28
 321da74:	dfc00615 	stw	ra,24(sp)
 321da78:	df000515 	stw	fp,20(sp)
 321da7c:	df000504 	addi	fp,sp,20
 321da80:	e13ffc15 	stw	r4,-16(fp)
 321da84:	e17ffd15 	stw	r5,-12(fp)
 321da88:	e1bffe15 	stw	r6,-8(fp)
 321da8c:	e1ffff15 	stw	r7,-4(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 321da90:	e0bffc17 	ldw	r2,-16(fp)
 321da94:	e0bffb15 	stw	r2,-20(fp)
  memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
 321da98:	e0bffb17 	ldw	r2,-20(fp)
 321da9c:	10800a17 	ldw	r2,40(r2)
 321daa0:	1007883a 	mov	r3,r2
 321daa4:	e0bffd17 	ldw	r2,-12(fp)
 321daa8:	1887883a 	add	r3,r3,r2
 321daac:	e1bfff17 	ldw	r6,-4(fp)
 321dab0:	e0bffe17 	ldw	r2,-8(fp)
 321dab4:	1009883a 	mov	r4,r2
 321dab8:	180b883a 	mov	r5,r3
 321dabc:	32067cc0 	call	32067cc <memcpy>
  return 0;
 321dac0:	0005883a 	mov	r2,zero
}
 321dac4:	e037883a 	mov	sp,fp
 321dac8:	dfc00117 	ldw	ra,4(sp)
 321dacc:	df000017 	ldw	fp,0(sp)
 321dad0:	dec00204 	addi	sp,sp,8
 321dad4:	f800283a 	ret

0321dad8 <alt_write_value_to_flash>:
* It writes the largest word size that the flash can support
* so if it's an 8 bit flash it writes bytes
* 16 bit half word etc.
*/
void alt_write_value_to_flash(alt_flash_cfi_dev* flash, int offset, const alt_u8* src_addr)
{
 321dad8:	defffa04 	addi	sp,sp,-24
 321dadc:	df000515 	stw	fp,20(sp)
 321dae0:	df000504 	addi	fp,sp,20
 321dae4:	e13ffd15 	stw	r4,-12(fp)
 321dae8:	e17ffe15 	stw	r5,-8(fp)
 321daec:	e1bfff15 	stw	r6,-4(fp)
  alt_u16 half_word_value;
  alt_u32 word_value;

  if (flash->mode_width == 1)
 321daf0:	e0bffd17 	ldw	r2,-12(fp)
 321daf4:	10802e17 	ldw	r2,184(r2)
 321daf8:	10800058 	cmpnei	r2,r2,1
 321dafc:	10000b1e 	bne	r2,zero,321db2c <alt_write_value_to_flash+0x54>
  {
    IOWR_8DIRECT(flash->dev.base_addr, offset, *src_addr);
 321db00:	e0bffd17 	ldw	r2,-12(fp)
 321db04:	10800a17 	ldw	r2,40(r2)
 321db08:	1007883a 	mov	r3,r2
 321db0c:	e0bffe17 	ldw	r2,-8(fp)
 321db10:	1889883a 	add	r4,r3,r2
 321db14:	e0bfff17 	ldw	r2,-4(fp)
 321db18:	10800003 	ldbu	r2,0(r2)
 321db1c:	10c03fcc 	andi	r3,r2,255
 321db20:	2005883a 	mov	r2,r4
 321db24:	10c00025 	stbio	r3,0(r2)
 321db28:	00004006 	br	321dc2c <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 2)
 321db2c:	e0bffd17 	ldw	r2,-12(fp)
 321db30:	10802e17 	ldw	r2,184(r2)
 321db34:	10800098 	cmpnei	r2,r2,2
 321db38:	1000151e 	bne	r2,zero,321db90 <alt_write_value_to_flash+0xb8>
  {
    half_word_value = (alt_u16)(*src_addr);
 321db3c:	e0bfff17 	ldw	r2,-4(fp)
 321db40:	10800003 	ldbu	r2,0(r2)
 321db44:	10803fcc 	andi	r2,r2,255
 321db48:	e0bffc0d 	sth	r2,-16(fp)
    half_word_value |= (alt_u16)(*(src_addr + 1)) << 8;
 321db4c:	e0bfff17 	ldw	r2,-4(fp)
 321db50:	10800044 	addi	r2,r2,1
 321db54:	10800003 	ldbu	r2,0(r2)
 321db58:	10803fcc 	andi	r2,r2,255
 321db5c:	1004923a 	slli	r2,r2,8
 321db60:	1007883a 	mov	r3,r2
 321db64:	e0bffc0b 	ldhu	r2,-16(fp)
 321db68:	1884b03a 	or	r2,r3,r2
 321db6c:	e0bffc0d 	sth	r2,-16(fp)
    IOWR_16DIRECT(flash->dev.base_addr, offset, half_word_value);
 321db70:	e0bffd17 	ldw	r2,-12(fp)
 321db74:	10800a17 	ldw	r2,40(r2)
 321db78:	1007883a 	mov	r3,r2
 321db7c:	e0bffe17 	ldw	r2,-8(fp)
 321db80:	1885883a 	add	r2,r3,r2
 321db84:	e0fffc0b 	ldhu	r3,-16(fp)
 321db88:	10c0002d 	sthio	r3,0(r2)
 321db8c:	00002706 	br	321dc2c <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 4)
 321db90:	e0bffd17 	ldw	r2,-12(fp)
 321db94:	10802e17 	ldw	r2,184(r2)
 321db98:	10800118 	cmpnei	r2,r2,4
 321db9c:	1000231e 	bne	r2,zero,321dc2c <alt_write_value_to_flash+0x154>
  {
    word_value = (alt_u32)(*src_addr);
 321dba0:	e0bfff17 	ldw	r2,-4(fp)
 321dba4:	10800003 	ldbu	r2,0(r2)
 321dba8:	10803fcc 	andi	r2,r2,255
 321dbac:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 1)) << 8);
 321dbb0:	e0bfff17 	ldw	r2,-4(fp)
 321dbb4:	10800044 	addi	r2,r2,1
 321dbb8:	10800003 	ldbu	r2,0(r2)
 321dbbc:	10803fcc 	andi	r2,r2,255
 321dbc0:	1006923a 	slli	r3,r2,8
 321dbc4:	e0bffb17 	ldw	r2,-20(fp)
 321dbc8:	10c4b03a 	or	r2,r2,r3
 321dbcc:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 2)) << 16);
 321dbd0:	e0bfff17 	ldw	r2,-4(fp)
 321dbd4:	10800084 	addi	r2,r2,2
 321dbd8:	10800003 	ldbu	r2,0(r2)
 321dbdc:	10803fcc 	andi	r2,r2,255
 321dbe0:	1006943a 	slli	r3,r2,16
 321dbe4:	e0bffb17 	ldw	r2,-20(fp)
 321dbe8:	10c4b03a 	or	r2,r2,r3
 321dbec:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 3)) << 24);
 321dbf0:	e0bfff17 	ldw	r2,-4(fp)
 321dbf4:	108000c4 	addi	r2,r2,3
 321dbf8:	10800003 	ldbu	r2,0(r2)
 321dbfc:	10803fcc 	andi	r2,r2,255
 321dc00:	1006963a 	slli	r3,r2,24
 321dc04:	e0bffb17 	ldw	r2,-20(fp)
 321dc08:	10c4b03a 	or	r2,r2,r3
 321dc0c:	e0bffb15 	stw	r2,-20(fp)
    IOWR_32DIRECT(flash->dev.base_addr, offset, word_value);
 321dc10:	e0bffd17 	ldw	r2,-12(fp)
 321dc14:	10800a17 	ldw	r2,40(r2)
 321dc18:	1007883a 	mov	r3,r2
 321dc1c:	e0bffe17 	ldw	r2,-8(fp)
 321dc20:	1885883a 	add	r2,r3,r2
 321dc24:	e0fffb17 	ldw	r3,-20(fp)
 321dc28:	10c00035 	stwio	r3,0(r2)
  }

  return;
}
 321dc2c:	e037883a 	mov	sp,fp
 321dc30:	df000017 	ldw	fp,0(sp)
 321dc34:	dec00104 	addi	sp,sp,4
 321dc38:	f800283a 	ret

0321dc3c <alt_flash_program_block>:
*/
int alt_flash_program_block(  alt_flash_cfi_dev* flash, const int offset, 
                        const alt_u8* src_addr, 
                        const int length,
                        alt_program_word_fn program_word_func)
{
 321dc3c:	defff304 	addi	sp,sp,-52
 321dc40:	dfc00c15 	stw	ra,48(sp)
 321dc44:	df000b15 	stw	fp,44(sp)
 321dc48:	df000b04 	addi	fp,sp,44
 321dc4c:	e13ffc15 	stw	r4,-16(fp)
 321dc50:	e17ffd15 	stw	r5,-12(fp)
 321dc54:	e1bffe15 	stw	r6,-8(fp)
 321dc58:	e1ffff15 	stw	r7,-4(fp)
  int     ret_code = 0;
 321dc5c:	e03ffa15 	stw	zero,-24(fp)

  /*
   * First take care of any writes which are on none native boundaries
   * as far as the flash is concerned.
   */
  bytes_to_preserve = ((int)((alt_u8*)flash->dev.base_addr + offset) % 
 321dc60:	e0bffc17 	ldw	r2,-16(fp)
 321dc64:	10800a17 	ldw	r2,40(r2)
 321dc68:	1007883a 	mov	r3,r2
 321dc6c:	e0bffd17 	ldw	r2,-12(fp)
 321dc70:	1885883a 	add	r2,r3,r2
 321dc74:	1009883a 	mov	r4,r2
 321dc78:	e0bffc17 	ldw	r2,-16(fp)
 321dc7c:	11402e17 	ldw	r5,184(r2)
 321dc80:	320445c0 	call	320445c <__modsi3>
 321dc84:	e0bff915 	stw	r2,-28(fp)
                      flash->mode_width);
  if ( bytes_to_preserve != 0)
 321dc88:	e0bff917 	ldw	r2,-28(fp)
 321dc8c:	1005003a 	cmpeq	r2,r2,zero
 321dc90:	10003a1e 	bne	r2,zero,321dd7c <alt_flash_program_block+0x140>
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
 321dc94:	e0bffc17 	ldw	r2,-16(fp)
 321dc98:	10c02e17 	ldw	r3,184(r2)
 321dc9c:	e0bff917 	ldw	r2,-28(fp)
 321dca0:	1885c83a 	sub	r2,r3,r2
 321dca4:	e0bff815 	stw	r2,-32(fp)
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 321dca8:	e03ff615 	stw	zero,-40(fp)
 321dcac:	00001206 	br	321dcf8 <alt_flash_program_block+0xbc>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
 321dcb0:	e17ff617 	ldw	r5,-40(fp)
 321dcb4:	e0bffc17 	ldw	r2,-16(fp)
 321dcb8:	10800a17 	ldw	r2,40(r2)
 321dcbc:	1009883a 	mov	r4,r2
 321dcc0:	e0fffd17 	ldw	r3,-12(fp)
 321dcc4:	e0bff917 	ldw	r2,-28(fp)
 321dcc8:	1887c83a 	sub	r3,r3,r2
 321dccc:	e0bff617 	ldw	r2,-40(fp)
 321dcd0:	1885883a 	add	r2,r3,r2
 321dcd4:	2085883a 	add	r2,r4,r2
 321dcd8:	10800023 	ldbuio	r2,0(r2)
 321dcdc:	1007883a 	mov	r3,r2
 321dce0:	e0bffb04 	addi	r2,fp,-20
 321dce4:	1145883a 	add	r2,r2,r5
 321dce8:	10c00005 	stb	r3,0(r2)
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 321dcec:	e0bff617 	ldw	r2,-40(fp)
 321dcf0:	10800044 	addi	r2,r2,1
 321dcf4:	e0bff615 	stw	r2,-40(fp)
 321dcf8:	e0fff617 	ldw	r3,-40(fp)
 321dcfc:	e0bff917 	ldw	r2,-28(fp)
 321dd00:	18bfeb16 	blt	r3,r2,321dcb0 <alt_flash_program_block+0x74>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 321dd04:	e03ff615 	stw	zero,-40(fp)
 321dd08:	00000e06 	br	321dd44 <alt_flash_program_block+0x108>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
 321dd0c:	e0fff917 	ldw	r3,-28(fp)
 321dd10:	e0bff617 	ldw	r2,-40(fp)
 321dd14:	1889883a 	add	r4,r3,r2
 321dd18:	e0bff617 	ldw	r2,-40(fp)
 321dd1c:	1007883a 	mov	r3,r2
 321dd20:	e0bffe17 	ldw	r2,-8(fp)
 321dd24:	1885883a 	add	r2,r3,r2
 321dd28:	10c00003 	ldbu	r3,0(r2)
 321dd2c:	e0bffb04 	addi	r2,fp,-20
 321dd30:	1105883a 	add	r2,r2,r4
 321dd34:	10c00005 	stb	r3,0(r2)
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 321dd38:	e0bff617 	ldw	r2,-40(fp)
 321dd3c:	10800044 	addi	r2,r2,1
 321dd40:	e0bff615 	stw	r2,-40(fp)
 321dd44:	e0fff617 	ldw	r3,-40(fp)
 321dd48:	e0bff817 	ldw	r2,-32(fp)
 321dd4c:	18bfef16 	blt	r3,r2,321dd0c <alt_flash_program_block+0xd0>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
    }
    
    ret_code = (*program_word_func)(flash, offset-bytes_to_preserve, unaligned);
 321dd50:	e0fffd17 	ldw	r3,-12(fp)
 321dd54:	e0bff917 	ldw	r2,-28(fp)
 321dd58:	188bc83a 	sub	r5,r3,r2
 321dd5c:	e1bffb04 	addi	r6,fp,-20
 321dd60:	e0800217 	ldw	r2,8(fp)
 321dd64:	e13ffc17 	ldw	r4,-16(fp)
 321dd68:	103ee83a 	callr	r2
 321dd6c:	e0bffa15 	stw	r2,-24(fp)
    i = unaligned_bytes;
 321dd70:	e0bff817 	ldw	r2,-32(fp)
 321dd74:	e0bff615 	stw	r2,-40(fp)
 321dd78:	00000106 	br	321dd80 <alt_flash_program_block+0x144>
  }
  else
  {
    i = 0;
 321dd7c:	e03ff615 	stw	zero,-40(fp)
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
 321dd80:	e0fffd17 	ldw	r3,-12(fp)
 321dd84:	e0bfff17 	ldw	r2,-4(fp)
 321dd88:	1889883a 	add	r4,r3,r2
 321dd8c:	e0bffc17 	ldw	r2,-16(fp)
 321dd90:	11402e17 	ldw	r5,184(r2)
 321dd94:	320445c0 	call	320445c <__modsi3>
 321dd98:	e0bff715 	stw	r2,-36(fp)
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 321dd9c:	00001006 	br	321dde0 <alt_flash_program_block+0x1a4>
  {
    ret_code = (*program_word_func)(flash, offset+i, src_addr+i);
 321dda0:	e0fffd17 	ldw	r3,-12(fp)
 321dda4:	e0bff617 	ldw	r2,-40(fp)
 321dda8:	188b883a 	add	r5,r3,r2
 321ddac:	e0bff617 	ldw	r2,-40(fp)
 321ddb0:	1007883a 	mov	r3,r2
 321ddb4:	e0bffe17 	ldw	r2,-8(fp)
 321ddb8:	188d883a 	add	r6,r3,r2
 321ddbc:	e0800217 	ldw	r2,8(fp)
 321ddc0:	e13ffc17 	ldw	r4,-16(fp)
 321ddc4:	103ee83a 	callr	r2
 321ddc8:	e0bffa15 	stw	r2,-24(fp)
    i += flash->mode_width;     
 321ddcc:	e0bffc17 	ldw	r2,-16(fp)
 321ddd0:	10c02e17 	ldw	r3,184(r2)
 321ddd4:	e0bff617 	ldw	r2,-40(fp)
 321ddd8:	10c5883a 	add	r2,r2,r3
 321dddc:	e0bff615 	stw	r2,-40(fp)
  {
    i = 0;
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 321dde0:	e0bffa17 	ldw	r2,-24(fp)
 321dde4:	1004c03a 	cmpne	r2,r2,zero
 321dde8:	1000051e 	bne	r2,zero,321de00 <alt_flash_program_block+0x1c4>
 321ddec:	e0ffff17 	ldw	r3,-4(fp)
 321ddf0:	e0bff717 	ldw	r2,-36(fp)
 321ddf4:	1887c83a 	sub	r3,r3,r2
 321ddf8:	e0bff617 	ldw	r2,-40(fp)
 321ddfc:	10ffe816 	blt	r2,r3,321dda0 <alt_flash_program_block+0x164>

  /*
   * Now take care of any writes at the end of the buffer which are on none 
   * native boundaries as far as the flash is concerned.
   */
  if (unaligned_end_bytes && !ret_code)
 321de00:	e0bff717 	ldw	r2,-36(fp)
 321de04:	1005003a 	cmpeq	r2,r2,zero
 321de08:	10003c1e 	bne	r2,zero,321defc <alt_flash_program_block+0x2c0>
 321de0c:	e0bffa17 	ldw	r2,-24(fp)
 321de10:	1004c03a 	cmpne	r2,r2,zero
 321de14:	1000391e 	bne	r2,zero,321defc <alt_flash_program_block+0x2c0>
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
 321de18:	e0bffc17 	ldw	r2,-16(fp)
 321de1c:	10c02e17 	ldw	r3,184(r2)
 321de20:	e0bff717 	ldw	r2,-36(fp)
 321de24:	1885c83a 	sub	r2,r3,r2
 321de28:	e0bff915 	stw	r2,-28(fp)
    
    for (j=0;j<unaligned_end_bytes;j++)
 321de2c:	e03ff515 	stw	zero,-44(fp)
 321de30:	00000e06 	br	321de6c <alt_flash_program_block+0x230>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
 321de34:	e13ff517 	ldw	r4,-44(fp)
 321de38:	e0bff617 	ldw	r2,-40(fp)
 321de3c:	1007883a 	mov	r3,r2
 321de40:	e0bffe17 	ldw	r2,-8(fp)
 321de44:	1887883a 	add	r3,r3,r2
 321de48:	e0bff517 	ldw	r2,-44(fp)
 321de4c:	1885883a 	add	r2,r3,r2
 321de50:	10c00003 	ldbu	r3,0(r2)
 321de54:	e0bffb04 	addi	r2,fp,-20
 321de58:	1105883a 	add	r2,r2,r4
 321de5c:	10c00005 	stb	r3,0(r2)
   */
  if (unaligned_end_bytes && !ret_code)
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
    
    for (j=0;j<unaligned_end_bytes;j++)
 321de60:	e0bff517 	ldw	r2,-44(fp)
 321de64:	10800044 	addi	r2,r2,1
 321de68:	e0bff515 	stw	r2,-44(fp)
 321de6c:	e0fff517 	ldw	r3,-44(fp)
 321de70:	e0bff717 	ldw	r2,-36(fp)
 321de74:	18bfef16 	blt	r3,r2,321de34 <alt_flash_program_block+0x1f8>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 321de78:	e03ff515 	stw	zero,-44(fp)
 321de7c:	00001406 	br	321ded0 <alt_flash_program_block+0x294>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
 321de80:	e0fff717 	ldw	r3,-36(fp)
 321de84:	e0bff517 	ldw	r2,-44(fp)
 321de88:	188b883a 	add	r5,r3,r2
 321de8c:	e0bffc17 	ldw	r2,-16(fp)
 321de90:	10800a17 	ldw	r2,40(r2)
 321de94:	1009883a 	mov	r4,r2
 321de98:	e0fffd17 	ldw	r3,-12(fp)
 321de9c:	e0bfff17 	ldw	r2,-4(fp)
 321dea0:	1887883a 	add	r3,r3,r2
 321dea4:	e0bff517 	ldw	r2,-44(fp)
 321dea8:	1885883a 	add	r2,r3,r2
 321deac:	2085883a 	add	r2,r4,r2
 321deb0:	10800023 	ldbuio	r2,0(r2)
 321deb4:	1007883a 	mov	r3,r2
 321deb8:	e0bffb04 	addi	r2,fp,-20
 321debc:	1145883a 	add	r2,r2,r5
 321dec0:	10c00005 	stb	r3,0(r2)
    for (j=0;j<unaligned_end_bytes;j++)
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 321dec4:	e0bff517 	ldw	r2,-44(fp)
 321dec8:	10800044 	addi	r2,r2,1
 321decc:	e0bff515 	stw	r2,-44(fp)
 321ded0:	e0fff517 	ldw	r3,-44(fp)
 321ded4:	e0bff917 	ldw	r2,-28(fp)
 321ded8:	18bfe916 	blt	r3,r2,321de80 <alt_flash_program_block+0x244>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
                                                      offset+length+j);
    }

    ret_code = (*program_word_func)(flash, offset+i, unaligned);      
 321dedc:	e0fffd17 	ldw	r3,-12(fp)
 321dee0:	e0bff617 	ldw	r2,-40(fp)
 321dee4:	188b883a 	add	r5,r3,r2
 321dee8:	e1bffb04 	addi	r6,fp,-20
 321deec:	e0800217 	ldw	r2,8(fp)
 321def0:	e13ffc17 	ldw	r4,-16(fp)
 321def4:	103ee83a 	callr	r2
 321def8:	e0bffa15 	stw	r2,-24(fp)
  }

  return ret_code;
 321defc:	e0bffa17 	ldw	r2,-24(fp)
}
 321df00:	e037883a 	mov	sp,fp
 321df04:	dfc00117 	ldw	ra,4(sp)
 321df08:	df000017 	ldw	fp,0(sp)
 321df0c:	dec00204 	addi	sp,sp,8
 321df10:	f800283a 	ret

0321df14 <alt_read_query_entry_8bit>:

/*
 *  Read an 8 bit value from the CFI query table in flash
 */
alt_u8 alt_read_query_entry_8bit( alt_flash_cfi_dev* flash, int address)
{
 321df14:	defffd04 	addi	sp,sp,-12
 321df18:	df000215 	stw	fp,8(sp)
 321df1c:	df000204 	addi	fp,sp,8
 321df20:	e13ffe15 	stw	r4,-8(fp)
 321df24:	e17fff15 	stw	r5,-4(fp)
  return IORD_8DIRECT((alt_u8*)flash->dev.base_addr, address);
 321df28:	e0bffe17 	ldw	r2,-8(fp)
 321df2c:	10800a17 	ldw	r2,40(r2)
 321df30:	1007883a 	mov	r3,r2
 321df34:	e0bfff17 	ldw	r2,-4(fp)
 321df38:	1885883a 	add	r2,r3,r2
 321df3c:	10800023 	ldbuio	r2,0(r2)
 321df40:	10803fcc 	andi	r2,r2,255
}
 321df44:	e037883a 	mov	sp,fp
 321df48:	df000017 	ldw	fp,0(sp)
 321df4c:	dec00104 	addi	sp,sp,4
 321df50:	f800283a 	ret

0321df54 <alt_read_query_entry_16bit>:

alt_u8 alt_read_query_entry_16bit( alt_flash_cfi_dev* flash, int address)
{
 321df54:	defffd04 	addi	sp,sp,-12
 321df58:	df000215 	stw	fp,8(sp)
 321df5c:	df000204 	addi	fp,sp,8
 321df60:	e13ffe15 	stw	r4,-8(fp)
 321df64:	e17fff15 	stw	r5,-4(fp)
  return (IORD_16DIRECT((alt_u8*)flash->dev.base_addr, address*2) & 0xff);
 321df68:	e0bffe17 	ldw	r2,-8(fp)
 321df6c:	10800a17 	ldw	r2,40(r2)
 321df70:	1007883a 	mov	r3,r2
 321df74:	e0bfff17 	ldw	r2,-4(fp)
 321df78:	1085883a 	add	r2,r2,r2
 321df7c:	1885883a 	add	r2,r3,r2
 321df80:	1080002b 	ldhuio	r2,0(r2)
 321df84:	10803fcc 	andi	r2,r2,255
}
 321df88:	e037883a 	mov	sp,fp
 321df8c:	df000017 	ldw	fp,0(sp)
 321df90:	dec00104 	addi	sp,sp,4
 321df94:	f800283a 	ret

0321df98 <alt_read_query_entry_32bit>:

alt_u8 alt_read_query_entry_32bit( alt_flash_cfi_dev* flash, int address)
{
 321df98:	defffd04 	addi	sp,sp,-12
 321df9c:	df000215 	stw	fp,8(sp)
 321dfa0:	df000204 	addi	fp,sp,8
 321dfa4:	e13ffe15 	stw	r4,-8(fp)
 321dfa8:	e17fff15 	stw	r5,-4(fp)
  return (IORD_32DIRECT((alt_u8*)flash->dev.base_addr, address*4) & 0xff);
 321dfac:	e0bffe17 	ldw	r2,-8(fp)
 321dfb0:	10800a17 	ldw	r2,40(r2)
 321dfb4:	1007883a 	mov	r3,r2
 321dfb8:	e0bfff17 	ldw	r2,-4(fp)
 321dfbc:	1085883a 	add	r2,r2,r2
 321dfc0:	1085883a 	add	r2,r2,r2
 321dfc4:	1885883a 	add	r2,r3,r2
 321dfc8:	10800037 	ldwio	r2,0(r2)
 321dfcc:	10803fcc 	andi	r2,r2,255
}
 321dfd0:	e037883a 	mov	sp,fp
 321dfd4:	df000017 	ldw	fp,0(sp)
 321dfd8:	dec00104 	addi	sp,sp,4
 321dfdc:	f800283a 	ret

0321dfe0 <alt_write_flash_command_8bit_device_8bit_mode>:

/*
 * Write an 8 bit command to a flash
 */
void alt_write_flash_command_8bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 321dfe0:	defffc04 	addi	sp,sp,-16
 321dfe4:	df000315 	stw	fp,12(sp)
 321dfe8:	df000304 	addi	fp,sp,12
 321dfec:	e13ffd15 	stw	r4,-12(fp)
 321dff0:	e17ffe15 	stw	r5,-8(fp)
 321dff4:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset, value);
 321dff8:	e0fffd17 	ldw	r3,-12(fp)
 321dffc:	e0bffe17 	ldw	r2,-8(fp)
 321e000:	1885883a 	add	r2,r3,r2
 321e004:	e0ffff03 	ldbu	r3,-4(fp)
 321e008:	10c00025 	stbio	r3,0(r2)
  return;
}
 321e00c:	e037883a 	mov	sp,fp
 321e010:	df000017 	ldw	fp,0(sp)
 321e014:	dec00104 	addi	sp,sp,4
 321e018:	f800283a 	ret

0321e01c <alt_write_flash_command_16bit_device_8bit_mode>:

void alt_write_flash_command_16bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 321e01c:	defffc04 	addi	sp,sp,-16
 321e020:	df000315 	stw	fp,12(sp)
 321e024:	df000304 	addi	fp,sp,12
 321e028:	e13ffd15 	stw	r4,-12(fp)
 321e02c:	e17ffe15 	stw	r5,-8(fp)
 321e030:	e1bfff05 	stb	r6,-4(fp)
  if (offset % 2)
 321e034:	e0bffe17 	ldw	r2,-8(fp)
 321e038:	1080004c 	andi	r2,r2,1
 321e03c:	10803fcc 	andi	r2,r2,255
 321e040:	1005003a 	cmpeq	r2,r2,zero
 321e044:	1000081e 	bne	r2,zero,321e068 <alt_write_flash_command_16bit_device_8bit_mode+0x4c>
  {
    IOWR_8DIRECT(base_addr, offset*2, value);
 321e048:	e0bffe17 	ldw	r2,-8(fp)
 321e04c:	1085883a 	add	r2,r2,r2
 321e050:	1007883a 	mov	r3,r2
 321e054:	e0bffd17 	ldw	r2,-12(fp)
 321e058:	1885883a 	add	r2,r3,r2
 321e05c:	e0ffff03 	ldbu	r3,-4(fp)
 321e060:	10c00025 	stbio	r3,0(r2)
 321e064:	00000806 	br	321e088 <alt_write_flash_command_16bit_device_8bit_mode+0x6c>
  }
  else
  {
    IOWR_8DIRECT(base_addr, (offset*2)+1, value);
 321e068:	e0bffe17 	ldw	r2,-8(fp)
 321e06c:	1085883a 	add	r2,r2,r2
 321e070:	1007883a 	mov	r3,r2
 321e074:	e0bffd17 	ldw	r2,-12(fp)
 321e078:	1885883a 	add	r2,r3,r2
 321e07c:	10800044 	addi	r2,r2,1
 321e080:	e0ffff03 	ldbu	r3,-4(fp)
 321e084:	10c00025 	stbio	r3,0(r2)
  }
  return;
}
 321e088:	e037883a 	mov	sp,fp
 321e08c:	df000017 	ldw	fp,0(sp)
 321e090:	dec00104 	addi	sp,sp,4
 321e094:	f800283a 	ret

0321e098 <alt_write_flash_command_32bit_device_8bit_mode>:

void alt_write_flash_command_32bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 321e098:	defffc04 	addi	sp,sp,-16
 321e09c:	df000315 	stw	fp,12(sp)
 321e0a0:	df000304 	addi	fp,sp,12
 321e0a4:	e13ffd15 	stw	r4,-12(fp)
 321e0a8:	e17ffe15 	stw	r5,-8(fp)
 321e0ac:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset*4, value);
 321e0b0:	e0bffe17 	ldw	r2,-8(fp)
 321e0b4:	1085883a 	add	r2,r2,r2
 321e0b8:	1085883a 	add	r2,r2,r2
 321e0bc:	1007883a 	mov	r3,r2
 321e0c0:	e0bffd17 	ldw	r2,-12(fp)
 321e0c4:	1885883a 	add	r2,r3,r2
 321e0c8:	e0ffff03 	ldbu	r3,-4(fp)
 321e0cc:	10c00025 	stbio	r3,0(r2)
  return;
}
 321e0d0:	e037883a 	mov	sp,fp
 321e0d4:	df000017 	ldw	fp,0(sp)
 321e0d8:	dec00104 	addi	sp,sp,4
 321e0dc:	f800283a 	ret

0321e0e0 <alt_write_flash_command_16bit_device_16bit_mode>:

void alt_write_flash_command_16bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 321e0e0:	defffc04 	addi	sp,sp,-16
 321e0e4:	df000315 	stw	fp,12(sp)
 321e0e8:	df000304 	addi	fp,sp,12
 321e0ec:	e13ffd15 	stw	r4,-12(fp)
 321e0f0:	e17ffe15 	stw	r5,-8(fp)
 321e0f4:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*2, ((alt_u16)value)& 0x00ff);
 321e0f8:	e0bffe17 	ldw	r2,-8(fp)
 321e0fc:	1085883a 	add	r2,r2,r2
 321e100:	1007883a 	mov	r3,r2
 321e104:	e0bffd17 	ldw	r2,-12(fp)
 321e108:	1885883a 	add	r2,r3,r2
 321e10c:	e0ffff03 	ldbu	r3,-4(fp)
 321e110:	10c0002d 	sthio	r3,0(r2)
  return;
}
 321e114:	e037883a 	mov	sp,fp
 321e118:	df000017 	ldw	fp,0(sp)
 321e11c:	dec00104 	addi	sp,sp,4
 321e120:	f800283a 	ret

0321e124 <alt_write_flash_command_32bit_device_16bit_mode>:

void alt_write_flash_command_32bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 321e124:	defffc04 	addi	sp,sp,-16
 321e128:	df000315 	stw	fp,12(sp)
 321e12c:	df000304 	addi	fp,sp,12
 321e130:	e13ffd15 	stw	r4,-12(fp)
 321e134:	e17ffe15 	stw	r5,-8(fp)
 321e138:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*4, ((alt_u16)value)& 0x00ff);
 321e13c:	e0bffe17 	ldw	r2,-8(fp)
 321e140:	1085883a 	add	r2,r2,r2
 321e144:	1085883a 	add	r2,r2,r2
 321e148:	1007883a 	mov	r3,r2
 321e14c:	e0bffd17 	ldw	r2,-12(fp)
 321e150:	1885883a 	add	r2,r3,r2
 321e154:	e0ffff03 	ldbu	r3,-4(fp)
 321e158:	10c0002d 	sthio	r3,0(r2)
  return;
}
 321e15c:	e037883a 	mov	sp,fp
 321e160:	df000017 	ldw	fp,0(sp)
 321e164:	dec00104 	addi	sp,sp,4
 321e168:	f800283a 	ret

0321e16c <alt_write_flash_command_32bit_device_32bit_mode>:

void alt_write_flash_command_32bit_device_32bit_mode( void* base_addr, int offset, alt_u8 value)
{
 321e16c:	defffc04 	addi	sp,sp,-16
 321e170:	df000315 	stw	fp,12(sp)
 321e174:	df000304 	addi	fp,sp,12
 321e178:	e13ffd15 	stw	r4,-12(fp)
 321e17c:	e17ffe15 	stw	r5,-8(fp)
 321e180:	e1bfff05 	stb	r6,-4(fp)
  IOWR_32DIRECT(base_addr, offset*4, ((alt_u32)value)& 0x000000ff);
 321e184:	e0bffe17 	ldw	r2,-8(fp)
 321e188:	1085883a 	add	r2,r2,r2
 321e18c:	1085883a 	add	r2,r2,r2
 321e190:	1007883a 	mov	r3,r2
 321e194:	e0bffd17 	ldw	r2,-12(fp)
 321e198:	1885883a 	add	r2,r3,r2
 321e19c:	e0ffff03 	ldbu	r3,-4(fp)
 321e1a0:	10c00035 	stwio	r3,0(r2)
  return;
}
 321e1a4:	e037883a 	mov	sp,fp
 321e1a8:	df000017 	ldw	fp,0(sp)
 321e1ac:	dec00104 	addi	sp,sp,4
 321e1b0:	f800283a 	ret

0321e1b4 <alt_write_native_8bit>:

/*
 * Write the value passed to the flash
 */
void alt_write_native_8bit( void* address, alt_u32 value)
{
 321e1b4:	defffd04 	addi	sp,sp,-12
 321e1b8:	df000215 	stw	fp,8(sp)
 321e1bc:	df000204 	addi	fp,sp,8
 321e1c0:	e13ffe15 	stw	r4,-8(fp)
 321e1c4:	e17fff15 	stw	r5,-4(fp)
  IOWR_8DIRECT(address, 0, (alt_u8)(value&0xff));
 321e1c8:	e0bfff17 	ldw	r2,-4(fp)
 321e1cc:	10c03fcc 	andi	r3,r2,255
 321e1d0:	e0bffe17 	ldw	r2,-8(fp)
 321e1d4:	10c00025 	stbio	r3,0(r2)
  return;
}
 321e1d8:	e037883a 	mov	sp,fp
 321e1dc:	df000017 	ldw	fp,0(sp)
 321e1e0:	dec00104 	addi	sp,sp,4
 321e1e4:	f800283a 	ret

0321e1e8 <alt_write_native_16bit>:

void alt_write_native_16bit( void* address, alt_u32 value)
{
 321e1e8:	defffd04 	addi	sp,sp,-12
 321e1ec:	df000215 	stw	fp,8(sp)
 321e1f0:	df000204 	addi	fp,sp,8
 321e1f4:	e13ffe15 	stw	r4,-8(fp)
 321e1f8:	e17fff15 	stw	r5,-4(fp)
  IOWR_16DIRECT(address, 0, ((alt_u16)value)& 0xffff);
 321e1fc:	e0bfff17 	ldw	r2,-4(fp)
 321e200:	10ffffcc 	andi	r3,r2,65535
 321e204:	e0bffe17 	ldw	r2,-8(fp)
 321e208:	10c0002d 	sthio	r3,0(r2)
  return;
}
 321e20c:	e037883a 	mov	sp,fp
 321e210:	df000017 	ldw	fp,0(sp)
 321e214:	dec00104 	addi	sp,sp,4
 321e218:	f800283a 	ret

0321e21c <alt_write_native_32bit>:

void alt_write_native_32bit( void* address, alt_u32 value)
{
 321e21c:	defffd04 	addi	sp,sp,-12
 321e220:	df000215 	stw	fp,8(sp)
 321e224:	df000204 	addi	fp,sp,8
 321e228:	e13ffe15 	stw	r4,-8(fp)
 321e22c:	e17fff15 	stw	r5,-4(fp)
  IOWR_32DIRECT(address, 0, value);
 321e230:	e0ffff17 	ldw	r3,-4(fp)
 321e234:	e0bffe17 	ldw	r2,-8(fp)
 321e238:	10c00035 	stwio	r3,0(r2)
  return;
}
 321e23c:	e037883a 	mov	sp,fp
 321e240:	df000017 	ldw	fp,0(sp)
 321e244:	dec00104 	addi	sp,sp,4
 321e248:	f800283a 	ret

0321e24c <alt_set_flash_width_func>:
 * 
 * Setup the function pointers for writing a byte to the flash for the width
 * of the device
 */
int alt_set_flash_width_func( alt_flash_cfi_dev* flash)
{ 
 321e24c:	defffb04 	addi	sp,sp,-20
 321e250:	df000415 	stw	fp,16(sp)
 321e254:	df000404 	addi	fp,sp,16
 321e258:	e13ffd15 	stw	r4,-12(fp)
  int ret_code = 0;
 321e25c:	e03ffc15 	stw	zero,-16(fp)
  
  switch(flash->mode_width)
 321e260:	e0bffd17 	ldw	r2,-12(fp)
 321e264:	10802e17 	ldw	r2,184(r2)
 321e268:	e0bfff15 	stw	r2,-4(fp)
 321e26c:	e0ffff17 	ldw	r3,-4(fp)
 321e270:	188000a0 	cmpeqi	r2,r3,2
 321e274:	1000261e 	bne	r2,zero,321e310 <alt_set_flash_width_func+0xc4>
 321e278:	e0ffff17 	ldw	r3,-4(fp)
 321e27c:	18800120 	cmpeqi	r2,r3,4
 321e280:	1000391e 	bne	r2,zero,321e368 <alt_set_flash_width_func+0x11c>
 321e284:	e0ffff17 	ldw	r3,-4(fp)
 321e288:	18800060 	cmpeqi	r2,r3,1
 321e28c:	1000011e 	bne	r2,zero,321e294 <alt_set_flash_width_func+0x48>
 321e290:	00003e06 	br	321e38c <alt_set_flash_width_func+0x140>
  {
    case 1:
    {
      flash->write_native = alt_write_native_8bit;
 321e294:	e0fffd17 	ldw	r3,-12(fp)
 321e298:	0080c8b4 	movhi	r2,802
 321e29c:	10b86d04 	addi	r2,r2,-7756
 321e2a0:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 1)
 321e2a4:	e0bffd17 	ldw	r2,-12(fp)
 321e2a8:	10802f17 	ldw	r2,188(r2)
 321e2ac:	10800058 	cmpnei	r2,r2,1
 321e2b0:	1000051e 	bne	r2,zero,321e2c8 <alt_set_flash_width_func+0x7c>
      {
        flash->write_command = alt_write_flash_command_8bit_device_8bit_mode;
 321e2b4:	e0fffd17 	ldw	r3,-12(fp)
 321e2b8:	0080c8b4 	movhi	r2,802
 321e2bc:	10b7f804 	addi	r2,r2,-8224
 321e2c0:	18803315 	stw	r2,204(r3)
 321e2c4:	00003306 	br	321e394 <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 2)
 321e2c8:	e0bffd17 	ldw	r2,-12(fp)
 321e2cc:	10802f17 	ldw	r2,188(r2)
 321e2d0:	10800098 	cmpnei	r2,r2,2
 321e2d4:	1000051e 	bne	r2,zero,321e2ec <alt_set_flash_width_func+0xa0>
      {
        flash->write_command = alt_write_flash_command_16bit_device_8bit_mode;
 321e2d8:	e0fffd17 	ldw	r3,-12(fp)
 321e2dc:	0080c8b4 	movhi	r2,802
 321e2e0:	10b80704 	addi	r2,r2,-8164
 321e2e4:	18803315 	stw	r2,204(r3)
 321e2e8:	00002a06 	br	321e394 <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 321e2ec:	e0bffd17 	ldw	r2,-12(fp)
 321e2f0:	10802f17 	ldw	r2,188(r2)
 321e2f4:	10800118 	cmpnei	r2,r2,4
 321e2f8:	1000261e 	bne	r2,zero,321e394 <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_8bit_mode;
 321e2fc:	e0fffd17 	ldw	r3,-12(fp)
 321e300:	0080c8b4 	movhi	r2,802
 321e304:	10b82604 	addi	r2,r2,-8040
 321e308:	18803315 	stw	r2,204(r3)
      }
      break;
 321e30c:	00002106 	br	321e394 <alt_set_flash_width_func+0x148>
    }
    case 2:
    {
      flash->write_native = alt_write_native_16bit;
 321e310:	e0fffd17 	ldw	r3,-12(fp)
 321e314:	0080c8b4 	movhi	r2,802
 321e318:	10b87a04 	addi	r2,r2,-7704
 321e31c:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 2)
 321e320:	e0bffd17 	ldw	r2,-12(fp)
 321e324:	10802f17 	ldw	r2,188(r2)
 321e328:	10800098 	cmpnei	r2,r2,2
 321e32c:	1000051e 	bne	r2,zero,321e344 <alt_set_flash_width_func+0xf8>
      {
        flash->write_command = alt_write_flash_command_16bit_device_16bit_mode;
 321e330:	e0fffd17 	ldw	r3,-12(fp)
 321e334:	0080c8b4 	movhi	r2,802
 321e338:	10b83804 	addi	r2,r2,-7968
 321e33c:	18803315 	stw	r2,204(r3)
 321e340:	00001406 	br	321e394 <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 321e344:	e0bffd17 	ldw	r2,-12(fp)
 321e348:	10802f17 	ldw	r2,188(r2)
 321e34c:	10800118 	cmpnei	r2,r2,4
 321e350:	1000101e 	bne	r2,zero,321e394 <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_16bit_mode;
 321e354:	e0fffd17 	ldw	r3,-12(fp)
 321e358:	0080c8b4 	movhi	r2,802
 321e35c:	10b84904 	addi	r2,r2,-7900
 321e360:	18803315 	stw	r2,204(r3)
      }

      break;
 321e364:	00000b06 	br	321e394 <alt_set_flash_width_func+0x148>
    }
    case 4:
    {
      flash->write_native = alt_write_native_32bit;
 321e368:	e0fffd17 	ldw	r3,-12(fp)
 321e36c:	0080c8b4 	movhi	r2,802
 321e370:	10b88704 	addi	r2,r2,-7652
 321e374:	18803515 	stw	r2,212(r3)
      flash->write_command = alt_write_flash_command_32bit_device_32bit_mode;
 321e378:	e0fffd17 	ldw	r3,-12(fp)
 321e37c:	0080c8b4 	movhi	r2,802
 321e380:	10b85b04 	addi	r2,r2,-7828
 321e384:	18803315 	stw	r2,204(r3)
      break;
 321e388:	00000206 	br	321e394 <alt_set_flash_width_func+0x148>
    }
    default:
    {
      ret_code = -EACCES;
 321e38c:	00bffcc4 	movi	r2,-13
 321e390:	e0bffc15 	stw	r2,-16(fp)
    }
  }

  if (!ret_code)
 321e394:	e0bffc17 	ldw	r2,-16(fp)
 321e398:	1004c03a 	cmpne	r2,r2,zero
 321e39c:	10001e1e 	bne	r2,zero,321e418 <alt_set_flash_width_func+0x1cc>
  {
    switch(flash->device_width)
 321e3a0:	e0bffd17 	ldw	r2,-12(fp)
 321e3a4:	10802f17 	ldw	r2,188(r2)
 321e3a8:	e0bffe15 	stw	r2,-8(fp)
 321e3ac:	e0fffe17 	ldw	r3,-8(fp)
 321e3b0:	188000a0 	cmpeqi	r2,r3,2
 321e3b4:	10000c1e 	bne	r2,zero,321e3e8 <alt_set_flash_width_func+0x19c>
 321e3b8:	e0fffe17 	ldw	r3,-8(fp)
 321e3bc:	18800120 	cmpeqi	r2,r3,4
 321e3c0:	10000e1e 	bne	r2,zero,321e3fc <alt_set_flash_width_func+0x1b0>
 321e3c4:	e0fffe17 	ldw	r3,-8(fp)
 321e3c8:	18800060 	cmpeqi	r2,r3,1
 321e3cc:	1000011e 	bne	r2,zero,321e3d4 <alt_set_flash_width_func+0x188>
 321e3d0:	00000f06 	br	321e410 <alt_set_flash_width_func+0x1c4>
    {
      case 1:
      {
        flash->read_query = alt_read_query_entry_8bit;
 321e3d4:	e0fffd17 	ldw	r3,-12(fp)
 321e3d8:	0080c8b4 	movhi	r2,802
 321e3dc:	10b7c504 	addi	r2,r2,-8428
 321e3e0:	18803415 	stw	r2,208(r3)
        break;
 321e3e4:	00000c06 	br	321e418 <alt_set_flash_width_func+0x1cc>
      }
      case 2:
      {
        flash->read_query = alt_read_query_entry_16bit;
 321e3e8:	e0fffd17 	ldw	r3,-12(fp)
 321e3ec:	0080c8b4 	movhi	r2,802
 321e3f0:	10b7d504 	addi	r2,r2,-8364
 321e3f4:	18803415 	stw	r2,208(r3)
        break;
 321e3f8:	00000706 	br	321e418 <alt_set_flash_width_func+0x1cc>
      }
      case 4:
      {
        flash->read_query = alt_read_query_entry_32bit;
 321e3fc:	e0fffd17 	ldw	r3,-12(fp)
 321e400:	0080c8b4 	movhi	r2,802
 321e404:	10b7e604 	addi	r2,r2,-8296
 321e408:	18803415 	stw	r2,208(r3)
        break;
 321e40c:	00000206 	br	321e418 <alt_set_flash_width_func+0x1cc>
      }
      default:
      {
        ret_code = -EACCES;
 321e410:	00bffcc4 	movi	r2,-13
 321e414:	e0bffc15 	stw	r2,-16(fp)
      }
    }
  }

  return ret_code;
 321e418:	e0bffc17 	ldw	r2,-16(fp)
}
 321e41c:	e037883a 	mov	sp,fp
 321e420:	df000017 	ldw	fp,0(sp)
 321e424:	dec00104 	addi	sp,sp,4
 321e428:	f800283a 	ret

0321e42c <alt_set_flash_algorithm_func>:
 * 
 * Setup the function pointers to the functions for this algorithm
 * 
 */
int alt_set_flash_algorithm_func( alt_flash_cfi_dev* flash)
{
 321e42c:	defffc04 	addi	sp,sp,-16
 321e430:	df000315 	stw	fp,12(sp)
 321e434:	df000304 	addi	fp,sp,12
 321e438:	e13ffe15 	stw	r4,-8(fp)
  int ret_code = 0;
 321e43c:	e03ffd15 	stw	zero,-12(fp)
 
  switch(flash->algorithm)
 321e440:	e0bffe17 	ldw	r2,-8(fp)
 321e444:	10802d17 	ldw	r2,180(r2)
 321e448:	e0bfff15 	stw	r2,-4(fp)
 321e44c:	e0ffff17 	ldw	r3,-4(fp)
 321e450:	188000a0 	cmpeqi	r2,r3,2
 321e454:	1000071e 	bne	r2,zero,321e474 <alt_set_flash_algorithm_func+0x48>
 321e458:	e0ffff17 	ldw	r3,-4(fp)
 321e45c:	188000e0 	cmpeqi	r2,r3,3
 321e460:	10000d1e 	bne	r2,zero,321e498 <alt_set_flash_algorithm_func+0x6c>
 321e464:	e0ffff17 	ldw	r3,-4(fp)
 321e468:	18800060 	cmpeqi	r2,r3,1
 321e46c:	10000a1e 	bne	r2,zero,321e498 <alt_set_flash_algorithm_func+0x6c>
 321e470:	00001206 	br	321e4bc <alt_set_flash_algorithm_func+0x90>
  {
    case CFI_ALG_AMD:
    {
      flash->dev.erase_block = alt_erase_block_amd;
 321e474:	e0fffe17 	ldw	r3,-8(fp)
 321e478:	0080c934 	movhi	r2,804
 321e47c:	10ad9f04 	addi	r2,r2,-18820
 321e480:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_amd;
 321e484:	e0fffe17 	ldw	r3,-8(fp)
 321e488:	0080c934 	movhi	r2,804
 321e48c:	10ad8504 	addi	r2,r2,-18924
 321e490:	18800915 	stw	r2,36(r3)
      break;
 321e494:	00000b06 	br	321e4c4 <alt_set_flash_algorithm_func+0x98>
    }
    case CFI_ALG_INTEL:
    case CFI_ALG_INTEL_STRATA:
    {
      flash->dev.erase_block = alt_erase_block_intel;
 321e498:	e0fffe17 	ldw	r3,-8(fp)
 321e49c:	0080c934 	movhi	r2,804
 321e4a0:	10aebe04 	addi	r2,r2,-17672
 321e4a4:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_intel;
 321e4a8:	e0fffe17 	ldw	r3,-8(fp)
 321e4ac:	0080c934 	movhi	r2,804
 321e4b0:	10ae9d04 	addi	r2,r2,-17804
 321e4b4:	18800915 	stw	r2,36(r3)
      break;
 321e4b8:	00000206 	br	321e4c4 <alt_set_flash_algorithm_func+0x98>
    }
    default:
    {
      ret_code = -EIO;
 321e4bc:	00bffec4 	movi	r2,-5
 321e4c0:	e0bffd15 	stw	r2,-12(fp)
    }
  } 
  return ret_code;  
 321e4c4:	e0bffd17 	ldw	r2,-12(fp)
}
 321e4c8:	e037883a 	mov	sp,fp
 321e4cc:	df000017 	ldw	fp,0(sp)
 321e4d0:	dec00104 	addi	sp,sp,4
 321e4d4:	f800283a 	ret

0321e4d8 <alt_read_16bit_query_entry>:
 * read_16bit_query_entry
 * 
 * Read a 16 bit entry from the CFI Query table
 */
static alt_u16 alt_read_16bit_query_entry(alt_flash_cfi_dev* flash, int address)
{
 321e4d8:	defffb04 	addi	sp,sp,-20
 321e4dc:	dfc00415 	stw	ra,16(sp)
 321e4e0:	df000315 	stw	fp,12(sp)
 321e4e4:	df000304 	addi	fp,sp,12
 321e4e8:	e13ffe15 	stw	r4,-8(fp)
 321e4ec:	e17fff15 	stw	r5,-4(fp)
  alt_u16 ret_code;

  ret_code = (*flash->read_query)( flash, address);
 321e4f0:	e0bffe17 	ldw	r2,-8(fp)
 321e4f4:	10803417 	ldw	r2,208(r2)
 321e4f8:	e13ffe17 	ldw	r4,-8(fp)
 321e4fc:	e17fff17 	ldw	r5,-4(fp)
 321e500:	103ee83a 	callr	r2
 321e504:	10803fcc 	andi	r2,r2,255
 321e508:	e0bffd0d 	sth	r2,-12(fp)
  ret_code |= (((int)(*flash->read_query)(flash, address+1)) << 8);                   
 321e50c:	e0bffe17 	ldw	r2,-8(fp)
 321e510:	10c03417 	ldw	r3,208(r2)
 321e514:	e0bfff17 	ldw	r2,-4(fp)
 321e518:	11400044 	addi	r5,r2,1
 321e51c:	e13ffe17 	ldw	r4,-8(fp)
 321e520:	183ee83a 	callr	r3
 321e524:	10803fcc 	andi	r2,r2,255
 321e528:	1004923a 	slli	r2,r2,8
 321e52c:	1007883a 	mov	r3,r2
 321e530:	e0bffd0b 	ldhu	r2,-12(fp)
 321e534:	1884b03a 	or	r2,r3,r2
 321e538:	e0bffd0d 	sth	r2,-12(fp)

  return ret_code;
 321e53c:	e0bffd0b 	ldhu	r2,-12(fp)
}
 321e540:	e037883a 	mov	sp,fp
 321e544:	dfc00117 	ldw	ra,4(sp)
 321e548:	df000017 	ldw	fp,0(sp)
 321e54c:	dec00204 	addi	sp,sp,8
 321e550:	f800283a 	ret

0321e554 <alt_read_cfi_table>:
 * read_cfi_table
 * 
 * Read the CFI Table
 */
int alt_read_cfi_table(alt_flash_cfi_dev* flash)
{
 321e554:	defff204 	addi	sp,sp,-56
 321e558:	dfc00d15 	stw	ra,52(sp)
 321e55c:	df000c15 	stw	fp,48(sp)
 321e560:	dc000b15 	stw	r16,44(sp)
 321e564:	df000b04 	addi	fp,sp,44
 321e568:	e13fff15 	stw	r4,-4(fp)
  int   i,j;
  int   device_size;
  int   ret_code = 0;
 321e56c:	e03ffb15 	stw	zero,-20(fp)
  int   size = 0;
 321e570:	e03ffa15 	stw	zero,-24(fp)
  int   swap;
  int   typical_timeout;
  int   max_timeout;
  int   offset = 0;
 321e574:	e03ff615 	stw	zero,-40(fp)
   
  /*
  * Check that the Primary Vendor Specific table
  * starts with the letters PRI                                                         
  */
  ret_code = alt_check_primary_table(flash);
 321e578:	e13fff17 	ldw	r4,-4(fp)
 321e57c:	321f2800 	call	321f280 <alt_check_primary_table>
 321e580:	e0bffb15 	stw	r2,-20(fp)

  if (!ret_code)
 321e584:	e0bffb17 	ldw	r2,-20(fp)
 321e588:	1004c03a 	cmpne	r2,r2,zero
 321e58c:	10014a1e 	bne	r2,zero,321eab8 <alt_read_cfi_table+0x564>
  {
    flash->algorithm = (*flash->read_query)(flash, 0x13);
 321e590:	e0bfff17 	ldw	r2,-4(fp)
 321e594:	10803417 	ldw	r2,208(r2)
 321e598:	e13fff17 	ldw	r4,-4(fp)
 321e59c:	014004c4 	movi	r5,19
 321e5a0:	103ee83a 	callr	r2
 321e5a4:	10c03fcc 	andi	r3,r2,255
 321e5a8:	e0bfff17 	ldw	r2,-4(fp)
 321e5ac:	10c02d15 	stw	r3,180(r2)
  
    /* 
     * Let's read the write timeout values from the flash 
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
 321e5b0:	e0bfff17 	ldw	r2,-4(fp)
 321e5b4:	10803417 	ldw	r2,208(r2)
 321e5b8:	e13fff17 	ldw	r4,-4(fp)
 321e5bc:	014007c4 	movi	r5,31
 321e5c0:	103ee83a 	callr	r2
 321e5c4:	10803fcc 	andi	r2,r2,255
 321e5c8:	e0bff815 	stw	r2,-32(fp)
    max_timeout = (*flash->read_query)( flash, 0x23);
 321e5cc:	e0bfff17 	ldw	r2,-4(fp)
 321e5d0:	10803417 	ldw	r2,208(r2)
 321e5d4:	e13fff17 	ldw	r4,-4(fp)
 321e5d8:	014008c4 	movi	r5,35
 321e5dc:	103ee83a 	callr	r2
 321e5e0:	10803fcc 	andi	r2,r2,255
 321e5e4:	e0bff715 	stw	r2,-36(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 321e5e8:	e0bff817 	ldw	r2,-32(fp)
 321e5ec:	1005003a 	cmpeq	r2,r2,zero
 321e5f0:	1000031e 	bne	r2,zero,321e600 <alt_read_cfi_table+0xac>
 321e5f4:	e0bff717 	ldw	r2,-36(fp)
 321e5f8:	1004c03a 	cmpne	r2,r2,zero
 321e5fc:	1000041e 	bne	r2,zero,321e610 <alt_read_cfi_table+0xbc>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
 321e600:	e0ffff17 	ldw	r3,-4(fp)
 321e604:	0080fa04 	movi	r2,1000
 321e608:	18803015 	stw	r2,192(r3)
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
    max_timeout = (*flash->read_query)( flash, 0x23);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 321e60c:	00000706 	br	321e62c <alt_read_cfi_table+0xd8>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
    }
    else
    {
      flash->write_timeout = (1 << typical_timeout) * (1 << max_timeout);
 321e610:	00c00044 	movi	r3,1
 321e614:	e0bff817 	ldw	r2,-32(fp)
 321e618:	1886983a 	sll	r3,r3,r2
 321e61c:	e0bff717 	ldw	r2,-36(fp)
 321e620:	1886983a 	sll	r3,r3,r2
 321e624:	e0bfff17 	ldw	r2,-4(fp)
 321e628:	10c03015 	stw	r3,192(r2)
    }
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
 321e62c:	e0bfff17 	ldw	r2,-4(fp)
 321e630:	10803417 	ldw	r2,208(r2)
 321e634:	e13fff17 	ldw	r4,-4(fp)
 321e638:	01400844 	movi	r5,33
 321e63c:	103ee83a 	callr	r2
 321e640:	10803fcc 	andi	r2,r2,255
 321e644:	e0bff815 	stw	r2,-32(fp)
    max_timeout = (*flash->read_query)( flash, 0x25);
 321e648:	e0bfff17 	ldw	r2,-4(fp)
 321e64c:	10803417 	ldw	r2,208(r2)
 321e650:	e13fff17 	ldw	r4,-4(fp)
 321e654:	01400944 	movi	r5,37
 321e658:	103ee83a 	callr	r2
 321e65c:	10803fcc 	andi	r2,r2,255
 321e660:	e0bff715 	stw	r2,-36(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 321e664:	e0bff817 	ldw	r2,-32(fp)
 321e668:	1005003a 	cmpeq	r2,r2,zero
 321e66c:	1000031e 	bne	r2,zero,321e67c <alt_read_cfi_table+0x128>
 321e670:	e0bff717 	ldw	r2,-36(fp)
 321e674:	1004c03a 	cmpne	r2,r2,zero
 321e678:	1000051e 	bne	r2,zero,321e690 <alt_read_cfi_table+0x13c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
 321e67c:	e0ffff17 	ldw	r3,-4(fp)
 321e680:	00804c74 	movhi	r2,305
 321e684:	108b4004 	addi	r2,r2,11520
 321e688:	18803115 	stw	r2,196(r3)
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
    max_timeout = (*flash->read_query)( flash, 0x25);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 321e68c:	00000806 	br	321e6b0 <alt_read_cfi_table+0x15c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
    }
    else
    {
      flash->erase_timeout = (1 << typical_timeout) * (1 << max_timeout) * 1000;
 321e690:	00c00044 	movi	r3,1
 321e694:	e0bff817 	ldw	r2,-32(fp)
 321e698:	1886983a 	sll	r3,r3,r2
 321e69c:	e0bff717 	ldw	r2,-36(fp)
 321e6a0:	1884983a 	sll	r2,r3,r2
 321e6a4:	10c0fa24 	muli	r3,r2,1000
 321e6a8:	e0bfff17 	ldw	r2,-4(fp)
 321e6ac:	10c03115 	stw	r3,196(r2)
    }
   
    device_size = 0x1 << (*flash->read_query)( flash, 0x27);
 321e6b0:	e0bfff17 	ldw	r2,-4(fp)
 321e6b4:	10803417 	ldw	r2,208(r2)
 321e6b8:	e13fff17 	ldw	r4,-4(fp)
 321e6bc:	014009c4 	movi	r5,39
 321e6c0:	103ee83a 	callr	r2
 321e6c4:	10c03fcc 	andi	r3,r2,255
 321e6c8:	00800044 	movi	r2,1
 321e6cc:	10c4983a 	sll	r2,r2,r3
 321e6d0:	e0bffc15 	stw	r2,-16(fp)
  
    flash->dev.number_of_regions = (*flash->read_query)(flash, 0x2c);
 321e6d4:	e0bfff17 	ldw	r2,-4(fp)
 321e6d8:	10803417 	ldw	r2,208(r2)
 321e6dc:	e13fff17 	ldw	r4,-4(fp)
 321e6e0:	01400b04 	movi	r5,44
 321e6e4:	103ee83a 	callr	r2
 321e6e8:	10c03fcc 	andi	r3,r2,255
 321e6ec:	e0bfff17 	ldw	r2,-4(fp)
 321e6f0:	10c00c15 	stw	r3,48(r2)
    
    if (flash->dev.number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 321e6f4:	e0bfff17 	ldw	r2,-4(fp)
 321e6f8:	10800c17 	ldw	r2,48(r2)
 321e6fc:	10800250 	cmplti	r2,r2,9
 321e700:	1000031e 	bne	r2,zero,321e710 <alt_read_cfi_table+0x1bc>
    {
      ret_code = -ENOMEM;
 321e704:	00bffd04 	movi	r2,-12
 321e708:	e0bffb15 	stw	r2,-20(fp)
 321e70c:	00005e06 	br	321e888 <alt_read_cfi_table+0x334>
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 321e710:	e03ffe15 	stw	zero,-8(fp)
 321e714:	00005306 	br	321e864 <alt_read_cfi_table+0x310>
      {
        flash->dev.region_info[i].number_of_blocks =  alt_read_16bit_query_entry( 
 321e718:	e43ffe17 	ldw	r16,-8(fp)
 321e71c:	e0bffe17 	ldw	r2,-8(fp)
 321e720:	1085883a 	add	r2,r2,r2
 321e724:	1085883a 	add	r2,r2,r2
 321e728:	11400b44 	addi	r5,r2,45
 321e72c:	e13fff17 	ldw	r4,-4(fp)
 321e730:	321e4d80 	call	321e4d8 <alt_read_16bit_query_entry>
 321e734:	113fffcc 	andi	r4,r2,65535
 321e738:	e0ffff17 	ldw	r3,-4(fp)
 321e73c:	8004913a 	slli	r2,r16,4
 321e740:	10c5883a 	add	r2,r2,r3
 321e744:	10800f04 	addi	r2,r2,60
 321e748:	11000015 	stw	r4,0(r2)
                                                            flash,
                                                            (0x2D+i*4));
        flash->dev.region_info[i].number_of_blocks += 1; 
 321e74c:	e17ffe17 	ldw	r5,-8(fp)
 321e750:	e0bffe17 	ldw	r2,-8(fp)
 321e754:	e0ffff17 	ldw	r3,-4(fp)
 321e758:	1004913a 	slli	r2,r2,4
 321e75c:	10c5883a 	add	r2,r2,r3
 321e760:	10800f04 	addi	r2,r2,60
 321e764:	10800017 	ldw	r2,0(r2)
 321e768:	11000044 	addi	r4,r2,1
 321e76c:	e0ffff17 	ldw	r3,-4(fp)
 321e770:	2804913a 	slli	r2,r5,4
 321e774:	10c5883a 	add	r2,r2,r3
 321e778:	10800f04 	addi	r2,r2,60
 321e77c:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].block_size =  alt_read_16bit_query_entry( flash, 
 321e780:	e43ffe17 	ldw	r16,-8(fp)
 321e784:	e0bffe17 	ldw	r2,-8(fp)
 321e788:	1085883a 	add	r2,r2,r2
 321e78c:	1085883a 	add	r2,r2,r2
 321e790:	11400bc4 	addi	r5,r2,47
 321e794:	e13fff17 	ldw	r4,-4(fp)
 321e798:	321e4d80 	call	321e4d8 <alt_read_16bit_query_entry>
 321e79c:	113fffcc 	andi	r4,r2,65535
 321e7a0:	e0ffff17 	ldw	r3,-4(fp)
 321e7a4:	8004913a 	slli	r2,r16,4
 321e7a8:	10c5883a 	add	r2,r2,r3
 321e7ac:	10801004 	addi	r2,r2,64
 321e7b0:	11000015 	stw	r4,0(r2)
                                                              (0x2F+i*4));
        flash->dev.region_info[i].block_size *= 256;
 321e7b4:	e17ffe17 	ldw	r5,-8(fp)
 321e7b8:	e0bffe17 	ldw	r2,-8(fp)
 321e7bc:	e0ffff17 	ldw	r3,-4(fp)
 321e7c0:	1004913a 	slli	r2,r2,4
 321e7c4:	10c5883a 	add	r2,r2,r3
 321e7c8:	10801004 	addi	r2,r2,64
 321e7cc:	10800017 	ldw	r2,0(r2)
 321e7d0:	1008923a 	slli	r4,r2,8
 321e7d4:	e0ffff17 	ldw	r3,-4(fp)
 321e7d8:	2804913a 	slli	r2,r5,4
 321e7dc:	10c5883a 	add	r2,r2,r3
 321e7e0:	10801004 	addi	r2,r2,64
 321e7e4:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].region_size = 
 321e7e8:	e17ffe17 	ldw	r5,-8(fp)
 321e7ec:	e0bffe17 	ldw	r2,-8(fp)
 321e7f0:	e0ffff17 	ldw	r3,-4(fp)
 321e7f4:	1004913a 	slli	r2,r2,4
 321e7f8:	10c5883a 	add	r2,r2,r3
 321e7fc:	10800f04 	addi	r2,r2,60
 321e800:	11000017 	ldw	r4,0(r2)
 321e804:	e0bffe17 	ldw	r2,-8(fp)
 321e808:	e0ffff17 	ldw	r3,-4(fp)
 321e80c:	1004913a 	slli	r2,r2,4
 321e810:	10c5883a 	add	r2,r2,r3
 321e814:	10801004 	addi	r2,r2,64
 321e818:	10800017 	ldw	r2,0(r2)
 321e81c:	2089383a 	mul	r4,r4,r2
 321e820:	e0ffff17 	ldw	r3,-4(fp)
 321e824:	2804913a 	slli	r2,r5,4
 321e828:	10c5883a 	add	r2,r2,r3
 321e82c:	10800e04 	addi	r2,r2,56
 321e830:	11000015 	stw	r4,0(r2)
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
 321e834:	e0bffe17 	ldw	r2,-8(fp)
 321e838:	e0ffff17 	ldw	r3,-4(fp)
 321e83c:	1004913a 	slli	r2,r2,4
 321e840:	10c5883a 	add	r2,r2,r3
 321e844:	10800e04 	addi	r2,r2,56
 321e848:	10c00017 	ldw	r3,0(r2)
 321e84c:	e0bffa17 	ldw	r2,-24(fp)
 321e850:	10c5883a 	add	r2,r2,r3
 321e854:	e0bffa15 	stw	r2,-24(fp)
    {
      ret_code = -ENOMEM;
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 321e858:	e0bffe17 	ldw	r2,-8(fp)
 321e85c:	10800044 	addi	r2,r2,1
 321e860:	e0bffe15 	stw	r2,-8(fp)
 321e864:	e0bfff17 	ldw	r2,-4(fp)
 321e868:	10c00c17 	ldw	r3,48(r2)
 321e86c:	e0bffe17 	ldw	r2,-8(fp)
 321e870:	10ffa916 	blt	r2,r3,321e718 <alt_read_cfi_table+0x1c4>
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
      }
       
      if (size != device_size)
 321e874:	e0fffa17 	ldw	r3,-24(fp)
 321e878:	e0bffc17 	ldw	r2,-16(fp)
 321e87c:	18800226 	beq	r3,r2,321e888 <alt_read_cfi_table+0x334>
      {
        ret_code = -ENODEV;
 321e880:	00bffb44 	movi	r2,-19
 321e884:	e0bffb15 	stw	r2,-20(fp)
      }
    }
    
    boot_mode = (*flash->read_query)( flash, flash->primary_address + 0xf);
 321e888:	e0bfff17 	ldw	r2,-4(fp)
 321e88c:	10c03417 	ldw	r3,208(r2)
 321e890:	e0bfff17 	ldw	r2,-4(fp)
 321e894:	10803217 	ldw	r2,200(r2)
 321e898:	114003c4 	addi	r5,r2,15
 321e89c:	e13fff17 	ldw	r4,-4(fp)
 321e8a0:	183ee83a 	callr	r3
 321e8a4:	e0bff505 	stb	r2,-44(fp)
     * Intel Flash parts describe the sections in the order they appear
     * for AMD they just put all the small ones first then the bigger ones
     * So if it's a top boot part we have to reverse the order of the sectors
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
 321e8a8:	e0bfff17 	ldw	r2,-4(fp)
 321e8ac:	10802d17 	ldw	r2,180(r2)
 321e8b0:	10800098 	cmpnei	r2,r2,2
 321e8b4:	1000601e 	bne	r2,zero,321ea38 <alt_read_cfi_table+0x4e4>
 321e8b8:	e0bff503 	ldbu	r2,-44(fp)
 321e8bc:	108000d8 	cmpnei	r2,r2,3
 321e8c0:	10005d1e 	bne	r2,zero,321ea38 <alt_read_cfi_table+0x4e4>
    {
      for(i=flash->dev.number_of_regions-1, j=0;
 321e8c4:	e0bfff17 	ldw	r2,-4(fp)
 321e8c8:	10800c17 	ldw	r2,48(r2)
 321e8cc:	10bfffc4 	addi	r2,r2,-1
 321e8d0:	e0bffe15 	stw	r2,-8(fp)
 321e8d4:	e03ffd15 	stw	zero,-12(fp)
          j<=i;i--,j++)
 321e8d8:	00005406 	br	321ea2c <alt_read_cfi_table+0x4d8>
      {
        swap = flash->dev.region_info[i].region_size;
 321e8dc:	e0bffe17 	ldw	r2,-8(fp)
 321e8e0:	e0ffff17 	ldw	r3,-4(fp)
 321e8e4:	1004913a 	slli	r2,r2,4
 321e8e8:	10c5883a 	add	r2,r2,r3
 321e8ec:	10800e04 	addi	r2,r2,56
 321e8f0:	10800017 	ldw	r2,0(r2)
 321e8f4:	e0bff915 	stw	r2,-28(fp)
        flash->dev.region_info[i].region_size =  
 321e8f8:	e17ffe17 	ldw	r5,-8(fp)
 321e8fc:	e0bffd17 	ldw	r2,-12(fp)
 321e900:	e0ffff17 	ldw	r3,-4(fp)
 321e904:	1004913a 	slli	r2,r2,4
 321e908:	10c5883a 	add	r2,r2,r3
 321e90c:	10800e04 	addi	r2,r2,56
 321e910:	11000017 	ldw	r4,0(r2)
 321e914:	e0ffff17 	ldw	r3,-4(fp)
 321e918:	2804913a 	slli	r2,r5,4
 321e91c:	10c5883a 	add	r2,r2,r3
 321e920:	10800e04 	addi	r2,r2,56
 321e924:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].region_size;
        flash->dev.region_info[j].region_size = swap;
 321e928:	e0bffd17 	ldw	r2,-12(fp)
 321e92c:	e0ffff17 	ldw	r3,-4(fp)
 321e930:	1004913a 	slli	r2,r2,4
 321e934:	10c5883a 	add	r2,r2,r3
 321e938:	10c00e04 	addi	r3,r2,56
 321e93c:	e0bff917 	ldw	r2,-28(fp)
 321e940:	18800015 	stw	r2,0(r3)

        swap = flash->dev.region_info[i].block_size;
 321e944:	e0bffe17 	ldw	r2,-8(fp)
 321e948:	e0ffff17 	ldw	r3,-4(fp)
 321e94c:	1004913a 	slli	r2,r2,4
 321e950:	10c5883a 	add	r2,r2,r3
 321e954:	10801004 	addi	r2,r2,64
 321e958:	10800017 	ldw	r2,0(r2)
 321e95c:	e0bff915 	stw	r2,-28(fp)
        flash->dev.region_info[i].block_size =  
 321e960:	e17ffe17 	ldw	r5,-8(fp)
 321e964:	e0bffd17 	ldw	r2,-12(fp)
 321e968:	e0ffff17 	ldw	r3,-4(fp)
 321e96c:	1004913a 	slli	r2,r2,4
 321e970:	10c5883a 	add	r2,r2,r3
 321e974:	10801004 	addi	r2,r2,64
 321e978:	11000017 	ldw	r4,0(r2)
 321e97c:	e0ffff17 	ldw	r3,-4(fp)
 321e980:	2804913a 	slli	r2,r5,4
 321e984:	10c5883a 	add	r2,r2,r3
 321e988:	10801004 	addi	r2,r2,64
 321e98c:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].block_size;
        flash->dev.region_info[j].block_size = swap;
 321e990:	e0bffd17 	ldw	r2,-12(fp)
 321e994:	e0ffff17 	ldw	r3,-4(fp)
 321e998:	1004913a 	slli	r2,r2,4
 321e99c:	10c5883a 	add	r2,r2,r3
 321e9a0:	10c01004 	addi	r3,r2,64
 321e9a4:	e0bff917 	ldw	r2,-28(fp)
 321e9a8:	18800015 	stw	r2,0(r3)
 
        swap = flash->dev.region_info[i].number_of_blocks;
 321e9ac:	e0bffe17 	ldw	r2,-8(fp)
 321e9b0:	e0ffff17 	ldw	r3,-4(fp)
 321e9b4:	1004913a 	slli	r2,r2,4
 321e9b8:	10c5883a 	add	r2,r2,r3
 321e9bc:	10800f04 	addi	r2,r2,60
 321e9c0:	10800017 	ldw	r2,0(r2)
 321e9c4:	e0bff915 	stw	r2,-28(fp)
        flash->dev.region_info[i].number_of_blocks =  
 321e9c8:	e17ffe17 	ldw	r5,-8(fp)
 321e9cc:	e0bffd17 	ldw	r2,-12(fp)
 321e9d0:	e0ffff17 	ldw	r3,-4(fp)
 321e9d4:	1004913a 	slli	r2,r2,4
 321e9d8:	10c5883a 	add	r2,r2,r3
 321e9dc:	10800f04 	addi	r2,r2,60
 321e9e0:	11000017 	ldw	r4,0(r2)
 321e9e4:	e0ffff17 	ldw	r3,-4(fp)
 321e9e8:	2804913a 	slli	r2,r5,4
 321e9ec:	10c5883a 	add	r2,r2,r3
 321e9f0:	10800f04 	addi	r2,r2,60
 321e9f4:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].number_of_blocks;
        flash->dev.region_info[j].number_of_blocks = swap;
 321e9f8:	e0bffd17 	ldw	r2,-12(fp)
 321e9fc:	e0ffff17 	ldw	r3,-4(fp)
 321ea00:	1004913a 	slli	r2,r2,4
 321ea04:	10c5883a 	add	r2,r2,r3
 321ea08:	10c00f04 	addi	r3,r2,60
 321ea0c:	e0bff917 	ldw	r2,-28(fp)
 321ea10:	18800015 	stw	r2,0(r3)
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
    {
      for(i=flash->dev.number_of_regions-1, j=0;
          j<=i;i--,j++)
 321ea14:	e0bffe17 	ldw	r2,-8(fp)
 321ea18:	10bfffc4 	addi	r2,r2,-1
 321ea1c:	e0bffe15 	stw	r2,-8(fp)
 321ea20:	e0bffd17 	ldw	r2,-12(fp)
 321ea24:	10800044 	addi	r2,r2,1
 321ea28:	e0bffd15 	stw	r2,-12(fp)
 321ea2c:	e0fffd17 	ldw	r3,-12(fp)
 321ea30:	e0bffe17 	ldw	r2,-8(fp)
 321ea34:	10ffa90e 	bge	r2,r3,321e8dc <alt_read_cfi_table+0x388>
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 321ea38:	e03ffe15 	stw	zero,-8(fp)
 321ea3c:	00001306 	br	321ea8c <alt_read_cfi_table+0x538>
    {
      flash->dev.region_info[i].offset = offset;
 321ea40:	e0bffe17 	ldw	r2,-8(fp)
 321ea44:	e0ffff17 	ldw	r3,-4(fp)
 321ea48:	1004913a 	slli	r2,r2,4
 321ea4c:	10c5883a 	add	r2,r2,r3
 321ea50:	10c00d04 	addi	r3,r2,52
 321ea54:	e0bff617 	ldw	r2,-40(fp)
 321ea58:	18800015 	stw	r2,0(r3)
      offset += flash->dev.region_info[i].region_size;
 321ea5c:	e0bffe17 	ldw	r2,-8(fp)
 321ea60:	e0ffff17 	ldw	r3,-4(fp)
 321ea64:	1004913a 	slli	r2,r2,4
 321ea68:	10c5883a 	add	r2,r2,r3
 321ea6c:	10800e04 	addi	r2,r2,56
 321ea70:	10c00017 	ldw	r3,0(r2)
 321ea74:	e0bff617 	ldw	r2,-40(fp)
 321ea78:	10c5883a 	add	r2,r2,r3
 321ea7c:	e0bff615 	stw	r2,-40(fp)
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 321ea80:	e0bffe17 	ldw	r2,-8(fp)
 321ea84:	10800044 	addi	r2,r2,1
 321ea88:	e0bffe15 	stw	r2,-8(fp)
 321ea8c:	e0bfff17 	ldw	r2,-4(fp)
 321ea90:	10c00c17 	ldw	r3,48(r2)
 321ea94:	e0bffe17 	ldw	r2,-8(fp)
 321ea98:	10ffe916 	blt	r2,r3,321ea40 <alt_read_cfi_table+0x4ec>
    {
      flash->dev.region_info[i].offset = offset;
      offset += flash->dev.region_info[i].region_size;
    }
    
    (*flash->write_command)(flash->dev.base_addr, 
 321ea9c:	e0bfff17 	ldw	r2,-4(fp)
 321eaa0:	10c03317 	ldw	r3,204(r2)
 321eaa4:	e0bfff17 	ldw	r2,-4(fp)
 321eaa8:	11000a17 	ldw	r4,40(r2)
 321eaac:	01401544 	movi	r5,85
 321eab0:	01803fc4 	movi	r6,255
 321eab4:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_MODE);
  }  

  return ret_code;
 321eab8:	e0bffb17 	ldw	r2,-20(fp)
}
 321eabc:	e037883a 	mov	sp,fp
 321eac0:	dfc00217 	ldw	ra,8(sp)
 321eac4:	df000117 	ldw	fp,4(sp)
 321eac8:	dc000017 	ldw	r16,0(sp)
 321eacc:	dec00304 	addi	sp,sp,12
 321ead0:	f800283a 	ret

0321ead4 <alt_read_cfi_width>:
 * 
 * Work out the width of the device we're talking to and sanity check that we  
 * can read the CFI and the Primary Vendor specific Table
 */
int alt_read_cfi_width(alt_flash_cfi_dev* flash)
{
 321ead4:	defff704 	addi	sp,sp,-36
 321ead8:	dfc00815 	stw	ra,32(sp)
 321eadc:	df000715 	stw	fp,28(sp)
 321eae0:	df000704 	addi	fp,sp,28
 321eae4:	e13fff15 	stw	r4,-4(fp)
  int i;
  alt_u8 byte_id[12];
  alt_u16 iface;
  int ret_code = 0;
 321eae8:	e03ff915 	stw	zero,-28(fp)

  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 321eaec:	e0bfff17 	ldw	r2,-4(fp)
 321eaf0:	11000a17 	ldw	r4,40(r2)
 321eaf4:	01401544 	movi	r5,85
 321eaf8:	01802604 	movi	r6,152
 321eafc:	321dfe00 	call	321dfe0 <alt_write_flash_command_8bit_device_8bit_mode>

  for(i=0;i<3;i++)
 321eb00:	e03ffb15 	stw	zero,-20(fp)
 321eb04:	00000f06 	br	321eb44 <alt_read_cfi_width+0x70>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
 321eb08:	e13ffb17 	ldw	r4,-20(fp)
 321eb0c:	e0bfff17 	ldw	r2,-4(fp)
 321eb10:	10800a17 	ldw	r2,40(r2)
 321eb14:	1007883a 	mov	r3,r2
 321eb18:	e0bffb17 	ldw	r2,-20(fp)
 321eb1c:	1885883a 	add	r2,r3,r2
 321eb20:	10800404 	addi	r2,r2,16
 321eb24:	10800023 	ldbuio	r2,0(r2)
 321eb28:	1007883a 	mov	r3,r2
 321eb2c:	e0bffc04 	addi	r2,fp,-16
 321eb30:	1105883a 	add	r2,r2,r4
 321eb34:	10c00005 	stb	r3,0(r2)
  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);

  for(i=0;i<3;i++)
 321eb38:	e0bffb17 	ldw	r2,-20(fp)
 321eb3c:	10800044 	addi	r2,r2,1
 321eb40:	e0bffb15 	stw	r2,-20(fp)
 321eb44:	e0bffb17 	ldw	r2,-20(fp)
 321eb48:	108000d0 	cmplti	r2,r2,3
 321eb4c:	103fee1e 	bne	r2,zero,321eb08 <alt_read_cfi_width+0x34>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 321eb50:	e0bffc03 	ldbu	r2,-16(fp)
 321eb54:	10803fcc 	andi	r2,r2,255
 321eb58:	10801458 	cmpnei	r2,r2,81
 321eb5c:	10001d1e 	bne	r2,zero,321ebd4 <alt_read_cfi_width+0x100>
 321eb60:	e0bffc43 	ldbu	r2,-15(fp)
 321eb64:	10803fcc 	andi	r2,r2,255
 321eb68:	10801498 	cmpnei	r2,r2,82
 321eb6c:	1000191e 	bne	r2,zero,321ebd4 <alt_read_cfi_width+0x100>
 321eb70:	e0bffc83 	ldbu	r2,-14(fp)
 321eb74:	10803fcc 	andi	r2,r2,255
 321eb78:	10801658 	cmpnei	r2,r2,89
 321eb7c:	1000151e 	bne	r2,zero,321ebd4 <alt_read_cfi_width+0x100>
      (byte_id[1] == 'R') &&
      (byte_id[2] == 'Y'))
  {
    flash->mode_width = 1;
 321eb80:	e0ffff17 	ldw	r3,-4(fp)
 321eb84:	00800044 	movi	r2,1
 321eb88:	18802e15 	stw	r2,184(r3)
    flash->device_width = 1; 
 321eb8c:	e0ffff17 	ldw	r3,-4(fp)
 321eb90:	00800044 	movi	r2,1
 321eb94:	18802f15 	stw	r2,188(r3)
    iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR);
 321eb98:	e0bfff17 	ldw	r2,-4(fp)
 321eb9c:	10800a17 	ldw	r2,40(r2)
 321eba0:	10800a04 	addi	r2,r2,40
 321eba4:	1080002b 	ldhuio	r2,0(r2)
 321eba8:	e0bffa0d 	sth	r2,-24(fp)
    iface += 1;
 321ebac:	e0bffa0b 	ldhu	r2,-24(fp)
 321ebb0:	10800044 	addi	r2,r2,1
 321ebb4:	e0bffa0d 	sth	r2,-24(fp)
    if (!(iface & 0x1))
 321ebb8:	e0bffa0b 	ldhu	r2,-24(fp)
 321ebbc:	1080004c 	andi	r2,r2,1
 321ebc0:	1004c03a 	cmpne	r2,r2,zero
 321ebc4:	1001a81e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
    {
      ret_code = -ENODEV;
 321ebc8:	00bffb44 	movi	r2,-19
 321ebcc:	e0bff915 	stw	r2,-28(fp)
  for(i=0;i<3;i++)
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 321ebd0:	0001a506 	br	321f268 <alt_read_cfi_width+0x794>
  else
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 321ebd4:	e0bfff17 	ldw	r2,-4(fp)
 321ebd8:	11000a17 	ldw	r4,40(r2)
 321ebdc:	01401544 	movi	r5,85
 321ebe0:	01802604 	movi	r6,152
 321ebe4:	321e01c0 	call	321e01c <alt_write_flash_command_16bit_device_8bit_mode>
    for(i=0;i<6;i++)
 321ebe8:	e03ffb15 	stw	zero,-20(fp)
 321ebec:	00000f06 	br	321ec2c <alt_read_cfi_width+0x158>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 321ebf0:	e13ffb17 	ldw	r4,-20(fp)
 321ebf4:	e0bfff17 	ldw	r2,-4(fp)
 321ebf8:	10800a17 	ldw	r2,40(r2)
 321ebfc:	1007883a 	mov	r3,r2
 321ec00:	e0bffb17 	ldw	r2,-20(fp)
 321ec04:	1885883a 	add	r2,r3,r2
 321ec08:	10800804 	addi	r2,r2,32
 321ec0c:	10800023 	ldbuio	r2,0(r2)
 321ec10:	1007883a 	mov	r3,r2
 321ec14:	e0bffc04 	addi	r2,fp,-16
 321ec18:	1105883a 	add	r2,r2,r4
 321ec1c:	10c00005 	stb	r3,0(r2)
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
    for(i=0;i<6;i++)
 321ec20:	e0bffb17 	ldw	r2,-20(fp)
 321ec24:	10800044 	addi	r2,r2,1
 321ec28:	e0bffb15 	stw	r2,-20(fp)
 321ec2c:	e0bffb17 	ldw	r2,-20(fp)
 321ec30:	10800190 	cmplti	r2,r2,6
 321ec34:	103fee1e 	bne	r2,zero,321ebf0 <alt_read_cfi_width+0x11c>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 321ec38:	e0bffc03 	ldbu	r2,-16(fp)
 321ec3c:	10803fcc 	andi	r2,r2,255
 321ec40:	10801458 	cmpnei	r2,r2,81
 321ec44:	1000291e 	bne	r2,zero,321ecec <alt_read_cfi_width+0x218>
 321ec48:	e0bffc43 	ldbu	r2,-15(fp)
 321ec4c:	10803fcc 	andi	r2,r2,255
 321ec50:	10801458 	cmpnei	r2,r2,81
 321ec54:	1000251e 	bne	r2,zero,321ecec <alt_read_cfi_width+0x218>
 321ec58:	e0bffc83 	ldbu	r2,-14(fp)
 321ec5c:	10803fcc 	andi	r2,r2,255
 321ec60:	10801498 	cmpnei	r2,r2,82
 321ec64:	1000211e 	bne	r2,zero,321ecec <alt_read_cfi_width+0x218>
 321ec68:	e0bffcc3 	ldbu	r2,-13(fp)
 321ec6c:	10803fcc 	andi	r2,r2,255
 321ec70:	10801498 	cmpnei	r2,r2,82
 321ec74:	10001d1e 	bne	r2,zero,321ecec <alt_read_cfi_width+0x218>
 321ec78:	e0bffd03 	ldbu	r2,-12(fp)
 321ec7c:	10803fcc 	andi	r2,r2,255
 321ec80:	10801658 	cmpnei	r2,r2,89
 321ec84:	1000191e 	bne	r2,zero,321ecec <alt_read_cfi_width+0x218>
 321ec88:	e0bffd43 	ldbu	r2,-11(fp)
 321ec8c:	10803fcc 	andi	r2,r2,255
 321ec90:	10801658 	cmpnei	r2,r2,89
 321ec94:	1000151e 	bne	r2,zero,321ecec <alt_read_cfi_width+0x218>
        (byte_id[2] == 'R') &&
        (byte_id[3] == 'R') && 
        (byte_id[4] == 'Y') && 
        (byte_id[5] == 'Y'))
    {
      flash->mode_width = 1;
 321ec98:	e0ffff17 	ldw	r3,-4(fp)
 321ec9c:	00800044 	movi	r2,1
 321eca0:	18802e15 	stw	r2,184(r3)
      flash->device_width = 2; 
 321eca4:	e0ffff17 	ldw	r3,-4(fp)
 321eca8:	00800084 	movi	r2,2
 321ecac:	18802f15 	stw	r2,188(r3)
      iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 321ecb0:	e0bfff17 	ldw	r2,-4(fp)
 321ecb4:	10800a17 	ldw	r2,40(r2)
 321ecb8:	10801404 	addi	r2,r2,80
 321ecbc:	1080002b 	ldhuio	r2,0(r2)
 321ecc0:	e0bffa0d 	sth	r2,-24(fp)
      iface += 1;
 321ecc4:	e0bffa0b 	ldhu	r2,-24(fp)
 321ecc8:	10800044 	addi	r2,r2,1
 321eccc:	e0bffa0d 	sth	r2,-24(fp)
      if (!(iface & 0x1))
 321ecd0:	e0bffa0b 	ldhu	r2,-24(fp)
 321ecd4:	1080004c 	andi	r2,r2,1
 321ecd8:	1004c03a 	cmpne	r2,r2,zero
 321ecdc:	1001621e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
      {
        ret_code = -ENODEV;
 321ece0:	00bffb44 	movi	r2,-19
 321ece4:	e0bff915 	stw	r2,-28(fp)
    for(i=0;i<6;i++)
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 321ece8:	00015f06 	br	321f268 <alt_read_cfi_width+0x794>
    else
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 321ecec:	e0bfff17 	ldw	r2,-4(fp)
 321ecf0:	11000a17 	ldw	r4,40(r2)
 321ecf4:	01401544 	movi	r5,85
 321ecf8:	01802604 	movi	r6,152
 321ecfc:	321e0e00 	call	321e0e0 <alt_write_flash_command_16bit_device_16bit_mode>
      for(i=0;i<6;i++)
 321ed00:	e03ffb15 	stw	zero,-20(fp)
 321ed04:	00000f06 	br	321ed44 <alt_read_cfi_width+0x270>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 321ed08:	e13ffb17 	ldw	r4,-20(fp)
 321ed0c:	e0bfff17 	ldw	r2,-4(fp)
 321ed10:	10800a17 	ldw	r2,40(r2)
 321ed14:	1007883a 	mov	r3,r2
 321ed18:	e0bffb17 	ldw	r2,-20(fp)
 321ed1c:	1885883a 	add	r2,r3,r2
 321ed20:	10800804 	addi	r2,r2,32
 321ed24:	10800023 	ldbuio	r2,0(r2)
 321ed28:	1007883a 	mov	r3,r2
 321ed2c:	e0bffc04 	addi	r2,fp,-16
 321ed30:	1105883a 	add	r2,r2,r4
 321ed34:	10c00005 	stb	r3,0(r2)
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
      for(i=0;i<6;i++)
 321ed38:	e0bffb17 	ldw	r2,-20(fp)
 321ed3c:	10800044 	addi	r2,r2,1
 321ed40:	e0bffb15 	stw	r2,-20(fp)
 321ed44:	e0bffb17 	ldw	r2,-20(fp)
 321ed48:	10800190 	cmplti	r2,r2,6
 321ed4c:	103fee1e 	bne	r2,zero,321ed08 <alt_read_cfi_width+0x234>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 321ed50:	e0bffc03 	ldbu	r2,-16(fp)
 321ed54:	10803fcc 	andi	r2,r2,255
 321ed58:	10801458 	cmpnei	r2,r2,81
 321ed5c:	1000291e 	bne	r2,zero,321ee04 <alt_read_cfi_width+0x330>
 321ed60:	e0bffc43 	ldbu	r2,-15(fp)
 321ed64:	10803fcc 	andi	r2,r2,255
 321ed68:	1004c03a 	cmpne	r2,r2,zero
 321ed6c:	1000251e 	bne	r2,zero,321ee04 <alt_read_cfi_width+0x330>
 321ed70:	e0bffc83 	ldbu	r2,-14(fp)
 321ed74:	10803fcc 	andi	r2,r2,255
 321ed78:	10801498 	cmpnei	r2,r2,82
 321ed7c:	1000211e 	bne	r2,zero,321ee04 <alt_read_cfi_width+0x330>
 321ed80:	e0bffcc3 	ldbu	r2,-13(fp)
 321ed84:	10803fcc 	andi	r2,r2,255
 321ed88:	1004c03a 	cmpne	r2,r2,zero
 321ed8c:	10001d1e 	bne	r2,zero,321ee04 <alt_read_cfi_width+0x330>
 321ed90:	e0bffd03 	ldbu	r2,-12(fp)
 321ed94:	10803fcc 	andi	r2,r2,255
 321ed98:	10801658 	cmpnei	r2,r2,89
 321ed9c:	1000191e 	bne	r2,zero,321ee04 <alt_read_cfi_width+0x330>
 321eda0:	e0bffd43 	ldbu	r2,-11(fp)
 321eda4:	10803fcc 	andi	r2,r2,255
 321eda8:	1004c03a 	cmpne	r2,r2,zero
 321edac:	1000151e 	bne	r2,zero,321ee04 <alt_read_cfi_width+0x330>
          (byte_id[2] == 'R') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'Y') && 
          (byte_id[5] == '\0'))
      {
        flash->mode_width = 2;
 321edb0:	e0ffff17 	ldw	r3,-4(fp)
 321edb4:	00800084 	movi	r2,2
 321edb8:	18802e15 	stw	r2,184(r3)
        flash->device_width = 2; 
 321edbc:	e0ffff17 	ldw	r3,-4(fp)
 321edc0:	00800084 	movi	r2,2
 321edc4:	18802f15 	stw	r2,188(r3)
        iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 321edc8:	e0bfff17 	ldw	r2,-4(fp)
 321edcc:	10800a17 	ldw	r2,40(r2)
 321edd0:	10801404 	addi	r2,r2,80
 321edd4:	1080002b 	ldhuio	r2,0(r2)
 321edd8:	e0bffa0d 	sth	r2,-24(fp)
        iface += 1;
 321eddc:	e0bffa0b 	ldhu	r2,-24(fp)
 321ede0:	10800044 	addi	r2,r2,1
 321ede4:	e0bffa0d 	sth	r2,-24(fp)
        if (!(iface & 0x2))
 321ede8:	e0bffa0b 	ldhu	r2,-24(fp)
 321edec:	1080008c 	andi	r2,r2,2
 321edf0:	1004c03a 	cmpne	r2,r2,zero
 321edf4:	10011c1e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
        {
          ret_code = -ENODEV;
 321edf8:	00bffb44 	movi	r2,-19
 321edfc:	e0bff915 	stw	r2,-28(fp)
      for(i=0;i<6;i++)
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 321ee00:	00011906 	br	321f268 <alt_read_cfi_width+0x794>
      else
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 321ee04:	e0bfff17 	ldw	r2,-4(fp)
 321ee08:	11000a17 	ldw	r4,40(r2)
 321ee0c:	01401544 	movi	r5,85
 321ee10:	01802604 	movi	r6,152
 321ee14:	321e16c0 	call	321e16c <alt_write_flash_command_32bit_device_32bit_mode>
        for(i=0;i<12;i++)
 321ee18:	e03ffb15 	stw	zero,-20(fp)
 321ee1c:	00000f06 	br	321ee5c <alt_read_cfi_width+0x388>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 321ee20:	e13ffb17 	ldw	r4,-20(fp)
 321ee24:	e0bfff17 	ldw	r2,-4(fp)
 321ee28:	10800a17 	ldw	r2,40(r2)
 321ee2c:	1007883a 	mov	r3,r2
 321ee30:	e0bffb17 	ldw	r2,-20(fp)
 321ee34:	1885883a 	add	r2,r3,r2
 321ee38:	10801004 	addi	r2,r2,64
 321ee3c:	10800023 	ldbuio	r2,0(r2)
 321ee40:	1007883a 	mov	r3,r2
 321ee44:	e0bffc04 	addi	r2,fp,-16
 321ee48:	1105883a 	add	r2,r2,r4
 321ee4c:	10c00005 	stb	r3,0(r2)
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
        for(i=0;i<12;i++)
 321ee50:	e0bffb17 	ldw	r2,-20(fp)
 321ee54:	10800044 	addi	r2,r2,1
 321ee58:	e0bffb15 	stw	r2,-20(fp)
 321ee5c:	e0bffb17 	ldw	r2,-20(fp)
 321ee60:	10800310 	cmplti	r2,r2,12
 321ee64:	103fee1e 	bne	r2,zero,321ee20 <alt_read_cfi_width+0x34c>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 321ee68:	e0bffc03 	ldbu	r2,-16(fp)
 321ee6c:	10803fcc 	andi	r2,r2,255
 321ee70:	10801458 	cmpnei	r2,r2,81
 321ee74:	1000411e 	bne	r2,zero,321ef7c <alt_read_cfi_width+0x4a8>
 321ee78:	e0bffc43 	ldbu	r2,-15(fp)
 321ee7c:	10803fcc 	andi	r2,r2,255
 321ee80:	1004c03a 	cmpne	r2,r2,zero
 321ee84:	10003d1e 	bne	r2,zero,321ef7c <alt_read_cfi_width+0x4a8>
 321ee88:	e0bffc83 	ldbu	r2,-14(fp)
 321ee8c:	10803fcc 	andi	r2,r2,255
 321ee90:	1004c03a 	cmpne	r2,r2,zero
 321ee94:	1000391e 	bne	r2,zero,321ef7c <alt_read_cfi_width+0x4a8>
 321ee98:	e0bffcc3 	ldbu	r2,-13(fp)
 321ee9c:	10803fcc 	andi	r2,r2,255
 321eea0:	1004c03a 	cmpne	r2,r2,zero
 321eea4:	1000351e 	bne	r2,zero,321ef7c <alt_read_cfi_width+0x4a8>
 321eea8:	e0bffd03 	ldbu	r2,-12(fp)
 321eeac:	10803fcc 	andi	r2,r2,255
 321eeb0:	10801498 	cmpnei	r2,r2,82
 321eeb4:	1000311e 	bne	r2,zero,321ef7c <alt_read_cfi_width+0x4a8>
 321eeb8:	e0bffd43 	ldbu	r2,-11(fp)
 321eebc:	10803fcc 	andi	r2,r2,255
 321eec0:	1004c03a 	cmpne	r2,r2,zero
 321eec4:	10002d1e 	bne	r2,zero,321ef7c <alt_read_cfi_width+0x4a8>
 321eec8:	e0bffd83 	ldbu	r2,-10(fp)
 321eecc:	10803fcc 	andi	r2,r2,255
 321eed0:	1004c03a 	cmpne	r2,r2,zero
 321eed4:	1000291e 	bne	r2,zero,321ef7c <alt_read_cfi_width+0x4a8>
 321eed8:	e0bffdc3 	ldbu	r2,-9(fp)
 321eedc:	10803fcc 	andi	r2,r2,255
 321eee0:	1004c03a 	cmpne	r2,r2,zero
 321eee4:	1000251e 	bne	r2,zero,321ef7c <alt_read_cfi_width+0x4a8>
 321eee8:	e0bffe03 	ldbu	r2,-8(fp)
 321eeec:	10803fcc 	andi	r2,r2,255
 321eef0:	10801658 	cmpnei	r2,r2,89
 321eef4:	1000211e 	bne	r2,zero,321ef7c <alt_read_cfi_width+0x4a8>
 321eef8:	e0bffe43 	ldbu	r2,-7(fp)
 321eefc:	10803fcc 	andi	r2,r2,255
 321ef00:	1004c03a 	cmpne	r2,r2,zero
 321ef04:	10001d1e 	bne	r2,zero,321ef7c <alt_read_cfi_width+0x4a8>
 321ef08:	e0bffe83 	ldbu	r2,-6(fp)
 321ef0c:	10803fcc 	andi	r2,r2,255
 321ef10:	1004c03a 	cmpne	r2,r2,zero
 321ef14:	1000191e 	bne	r2,zero,321ef7c <alt_read_cfi_width+0x4a8>
 321ef18:	e0bffec3 	ldbu	r2,-5(fp)
 321ef1c:	10803fcc 	andi	r2,r2,255
 321ef20:	1004c03a 	cmpne	r2,r2,zero
 321ef24:	1000151e 	bne	r2,zero,321ef7c <alt_read_cfi_width+0x4a8>
          (byte_id[8] == 'Y') && 
          (byte_id[9] == '\0') && 
          (byte_id[10] == '\0') && 
          (byte_id[11] == '\0'))
        {
          flash->mode_width = 4;
 321ef28:	e0ffff17 	ldw	r3,-4(fp)
 321ef2c:	00800104 	movi	r2,4
 321ef30:	18802e15 	stw	r2,184(r3)
          flash->device_width = 4; 
 321ef34:	e0ffff17 	ldw	r3,-4(fp)
 321ef38:	00800104 	movi	r2,4
 321ef3c:	18802f15 	stw	r2,188(r3)
          iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 321ef40:	e0bfff17 	ldw	r2,-4(fp)
 321ef44:	10800a17 	ldw	r2,40(r2)
 321ef48:	10802804 	addi	r2,r2,160
 321ef4c:	10800037 	ldwio	r2,0(r2)
 321ef50:	e0bffa0d 	sth	r2,-24(fp)
          iface += 1;
 321ef54:	e0bffa0b 	ldhu	r2,-24(fp)
 321ef58:	10800044 	addi	r2,r2,1
 321ef5c:	e0bffa0d 	sth	r2,-24(fp)
          if (!(iface & 0x4))
 321ef60:	e0bffa0b 	ldhu	r2,-24(fp)
 321ef64:	1080010c 	andi	r2,r2,4
 321ef68:	1004c03a 	cmpne	r2,r2,zero
 321ef6c:	1000be1e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
          {
            ret_code = -ENODEV;
 321ef70:	00bffb44 	movi	r2,-19
 321ef74:	e0bff915 	stw	r2,-28(fp)
        for(i=0;i<12;i++)
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 321ef78:	0000bb06 	br	321f268 <alt_read_cfi_width+0x794>
        else
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 321ef7c:	e0bfff17 	ldw	r2,-4(fp)
 321ef80:	11000a17 	ldw	r4,40(r2)
 321ef84:	01401544 	movi	r5,85
 321ef88:	01802604 	movi	r6,152
 321ef8c:	321e1240 	call	321e124 <alt_write_flash_command_32bit_device_16bit_mode>
          for(i=0;i<12;i++)
 321ef90:	e03ffb15 	stw	zero,-20(fp)
 321ef94:	00000f06 	br	321efd4 <alt_read_cfi_width+0x500>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 321ef98:	e13ffb17 	ldw	r4,-20(fp)
 321ef9c:	e0bfff17 	ldw	r2,-4(fp)
 321efa0:	10800a17 	ldw	r2,40(r2)
 321efa4:	1007883a 	mov	r3,r2
 321efa8:	e0bffb17 	ldw	r2,-20(fp)
 321efac:	1885883a 	add	r2,r3,r2
 321efb0:	10801004 	addi	r2,r2,64
 321efb4:	10800023 	ldbuio	r2,0(r2)
 321efb8:	1007883a 	mov	r3,r2
 321efbc:	e0bffc04 	addi	r2,fp,-16
 321efc0:	1105883a 	add	r2,r2,r4
 321efc4:	10c00005 	stb	r3,0(r2)
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
          for(i=0;i<12;i++)
 321efc8:	e0bffb17 	ldw	r2,-20(fp)
 321efcc:	10800044 	addi	r2,r2,1
 321efd0:	e0bffb15 	stw	r2,-20(fp)
 321efd4:	e0bffb17 	ldw	r2,-20(fp)
 321efd8:	10800310 	cmplti	r2,r2,12
 321efdc:	103fee1e 	bne	r2,zero,321ef98 <alt_read_cfi_width+0x4c4>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 321efe0:	e0bffc03 	ldbu	r2,-16(fp)
 321efe4:	10803fcc 	andi	r2,r2,255
 321efe8:	10801458 	cmpnei	r2,r2,81
 321efec:	1000411e 	bne	r2,zero,321f0f4 <alt_read_cfi_width+0x620>
 321eff0:	e0bffc43 	ldbu	r2,-15(fp)
 321eff4:	10803fcc 	andi	r2,r2,255
 321eff8:	1004c03a 	cmpne	r2,r2,zero
 321effc:	10003d1e 	bne	r2,zero,321f0f4 <alt_read_cfi_width+0x620>
 321f000:	e0bffc83 	ldbu	r2,-14(fp)
 321f004:	10803fcc 	andi	r2,r2,255
 321f008:	10801458 	cmpnei	r2,r2,81
 321f00c:	1000391e 	bne	r2,zero,321f0f4 <alt_read_cfi_width+0x620>
 321f010:	e0bffcc3 	ldbu	r2,-13(fp)
 321f014:	10803fcc 	andi	r2,r2,255
 321f018:	1004c03a 	cmpne	r2,r2,zero
 321f01c:	1000351e 	bne	r2,zero,321f0f4 <alt_read_cfi_width+0x620>
 321f020:	e0bffd03 	ldbu	r2,-12(fp)
 321f024:	10803fcc 	andi	r2,r2,255
 321f028:	10801498 	cmpnei	r2,r2,82
 321f02c:	1000311e 	bne	r2,zero,321f0f4 <alt_read_cfi_width+0x620>
 321f030:	e0bffd43 	ldbu	r2,-11(fp)
 321f034:	10803fcc 	andi	r2,r2,255
 321f038:	1004c03a 	cmpne	r2,r2,zero
 321f03c:	10002d1e 	bne	r2,zero,321f0f4 <alt_read_cfi_width+0x620>
 321f040:	e0bffd83 	ldbu	r2,-10(fp)
 321f044:	10803fcc 	andi	r2,r2,255
 321f048:	10801498 	cmpnei	r2,r2,82
 321f04c:	1000291e 	bne	r2,zero,321f0f4 <alt_read_cfi_width+0x620>
 321f050:	e0bffdc3 	ldbu	r2,-9(fp)
 321f054:	10803fcc 	andi	r2,r2,255
 321f058:	1004c03a 	cmpne	r2,r2,zero
 321f05c:	1000251e 	bne	r2,zero,321f0f4 <alt_read_cfi_width+0x620>
 321f060:	e0bffe03 	ldbu	r2,-8(fp)
 321f064:	10803fcc 	andi	r2,r2,255
 321f068:	10801658 	cmpnei	r2,r2,89
 321f06c:	1000211e 	bne	r2,zero,321f0f4 <alt_read_cfi_width+0x620>
 321f070:	e0bffe43 	ldbu	r2,-7(fp)
 321f074:	10803fcc 	andi	r2,r2,255
 321f078:	1004c03a 	cmpne	r2,r2,zero
 321f07c:	10001d1e 	bne	r2,zero,321f0f4 <alt_read_cfi_width+0x620>
 321f080:	e0bffe83 	ldbu	r2,-6(fp)
 321f084:	10803fcc 	andi	r2,r2,255
 321f088:	10801658 	cmpnei	r2,r2,89
 321f08c:	1000191e 	bne	r2,zero,321f0f4 <alt_read_cfi_width+0x620>
 321f090:	e0bffec3 	ldbu	r2,-5(fp)
 321f094:	10803fcc 	andi	r2,r2,255
 321f098:	1004c03a 	cmpne	r2,r2,zero
 321f09c:	1000151e 	bne	r2,zero,321f0f4 <alt_read_cfi_width+0x620>
              (byte_id[8] == 'Y') &&
              (byte_id[9] == '\0') &&
              (byte_id[10] == 'Y') &&
              (byte_id[11] == '\0'))
          {
            flash->mode_width = 2;
 321f0a0:	e0ffff17 	ldw	r3,-4(fp)
 321f0a4:	00800084 	movi	r2,2
 321f0a8:	18802e15 	stw	r2,184(r3)
            flash->device_width = 4; 
 321f0ac:	e0ffff17 	ldw	r3,-4(fp)
 321f0b0:	00800104 	movi	r2,4
 321f0b4:	18802f15 	stw	r2,188(r3)
            iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 321f0b8:	e0bfff17 	ldw	r2,-4(fp)
 321f0bc:	10800a17 	ldw	r2,40(r2)
 321f0c0:	10802804 	addi	r2,r2,160
 321f0c4:	10800037 	ldwio	r2,0(r2)
 321f0c8:	e0bffa0d 	sth	r2,-24(fp)
            iface += 1;
 321f0cc:	e0bffa0b 	ldhu	r2,-24(fp)
 321f0d0:	10800044 	addi	r2,r2,1
 321f0d4:	e0bffa0d 	sth	r2,-24(fp)
            if (!(iface & 0x4))
 321f0d8:	e0bffa0b 	ldhu	r2,-24(fp)
 321f0dc:	1080010c 	andi	r2,r2,4
 321f0e0:	1004c03a 	cmpne	r2,r2,zero
 321f0e4:	1000601e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
            {
              ret_code = -ENODEV;
 321f0e8:	00bffb44 	movi	r2,-19
 321f0ec:	e0bff915 	stw	r2,-28(fp)
          for(i=0;i<12;i++)
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 321f0f0:	00005d06 	br	321f268 <alt_read_cfi_width+0x794>
          else
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 321f0f4:	e0bfff17 	ldw	r2,-4(fp)
 321f0f8:	11000a17 	ldw	r4,40(r2)
 321f0fc:	01401544 	movi	r5,85
 321f100:	01802604 	movi	r6,152
 321f104:	321e0980 	call	321e098 <alt_write_flash_command_32bit_device_8bit_mode>
            for(i=0;i<12;i++)
 321f108:	e03ffb15 	stw	zero,-20(fp)
 321f10c:	00000f06 	br	321f14c <alt_read_cfi_width+0x678>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 321f110:	e13ffb17 	ldw	r4,-20(fp)
 321f114:	e0bfff17 	ldw	r2,-4(fp)
 321f118:	10800a17 	ldw	r2,40(r2)
 321f11c:	1007883a 	mov	r3,r2
 321f120:	e0bffb17 	ldw	r2,-20(fp)
 321f124:	1885883a 	add	r2,r3,r2
 321f128:	10801004 	addi	r2,r2,64
 321f12c:	10800023 	ldbuio	r2,0(r2)
 321f130:	1007883a 	mov	r3,r2
 321f134:	e0bffc04 	addi	r2,fp,-16
 321f138:	1105883a 	add	r2,r2,r4
 321f13c:	10c00005 	stb	r3,0(r2)
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
            for(i=0;i<12;i++)
 321f140:	e0bffb17 	ldw	r2,-20(fp)
 321f144:	10800044 	addi	r2,r2,1
 321f148:	e0bffb15 	stw	r2,-20(fp)
 321f14c:	e0bffb17 	ldw	r2,-20(fp)
 321f150:	10800310 	cmplti	r2,r2,12
 321f154:	103fee1e 	bne	r2,zero,321f110 <alt_read_cfi_width+0x63c>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
 321f158:	e0bffc03 	ldbu	r2,-16(fp)
 321f15c:	10803fcc 	andi	r2,r2,255
 321f160:	10801458 	cmpnei	r2,r2,81
 321f164:	1000401e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
 321f168:	e0bffc43 	ldbu	r2,-15(fp)
 321f16c:	10803fcc 	andi	r2,r2,255
 321f170:	10801458 	cmpnei	r2,r2,81
 321f174:	10003c1e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
 321f178:	e0bffc83 	ldbu	r2,-14(fp)
 321f17c:	10803fcc 	andi	r2,r2,255
 321f180:	10801458 	cmpnei	r2,r2,81
 321f184:	1000381e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
 321f188:	e0bffcc3 	ldbu	r2,-13(fp)
 321f18c:	10803fcc 	andi	r2,r2,255
 321f190:	10801458 	cmpnei	r2,r2,81
 321f194:	1000341e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
 321f198:	e0bffd03 	ldbu	r2,-12(fp)
 321f19c:	10803fcc 	andi	r2,r2,255
 321f1a0:	10801498 	cmpnei	r2,r2,82
 321f1a4:	1000301e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
 321f1a8:	e0bffd43 	ldbu	r2,-11(fp)
 321f1ac:	10803fcc 	andi	r2,r2,255
 321f1b0:	10801498 	cmpnei	r2,r2,82
 321f1b4:	10002c1e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
 321f1b8:	e0bffd83 	ldbu	r2,-10(fp)
 321f1bc:	10803fcc 	andi	r2,r2,255
 321f1c0:	10801498 	cmpnei	r2,r2,82
 321f1c4:	1000281e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
 321f1c8:	e0bffdc3 	ldbu	r2,-9(fp)
 321f1cc:	10803fcc 	andi	r2,r2,255
 321f1d0:	10801498 	cmpnei	r2,r2,82
 321f1d4:	1000241e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
 321f1d8:	e0bffe03 	ldbu	r2,-8(fp)
 321f1dc:	10803fcc 	andi	r2,r2,255
 321f1e0:	10801658 	cmpnei	r2,r2,89
 321f1e4:	1000201e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
 321f1e8:	e0bffe43 	ldbu	r2,-7(fp)
 321f1ec:	10803fcc 	andi	r2,r2,255
 321f1f0:	10801658 	cmpnei	r2,r2,89
 321f1f4:	10001c1e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
 321f1f8:	e0bffe83 	ldbu	r2,-6(fp)
 321f1fc:	10803fcc 	andi	r2,r2,255
 321f200:	10801658 	cmpnei	r2,r2,89
 321f204:	1000181e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
 321f208:	e0bffec3 	ldbu	r2,-5(fp)
 321f20c:	10803fcc 	andi	r2,r2,255
 321f210:	10801658 	cmpnei	r2,r2,89
 321f214:	1000141e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
                (byte_id[8] == 'Y') && 
                (byte_id[9] == 'Y') && 
                (byte_id[10] == 'Y') && 
                (byte_id[11] == 'Y'))
            {
              flash->mode_width = 1;
 321f218:	e0ffff17 	ldw	r3,-4(fp)
 321f21c:	00800044 	movi	r2,1
 321f220:	18802e15 	stw	r2,184(r3)
              flash->device_width = 4; 
 321f224:	e0ffff17 	ldw	r3,-4(fp)
 321f228:	00800104 	movi	r2,4
 321f22c:	18802f15 	stw	r2,188(r3)
              iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 321f230:	e0bfff17 	ldw	r2,-4(fp)
 321f234:	10800a17 	ldw	r2,40(r2)
 321f238:	10802804 	addi	r2,r2,160
 321f23c:	10800037 	ldwio	r2,0(r2)
 321f240:	e0bffa0d 	sth	r2,-24(fp)
              iface += 1;
 321f244:	e0bffa0b 	ldhu	r2,-24(fp)
 321f248:	10800044 	addi	r2,r2,1
 321f24c:	e0bffa0d 	sth	r2,-24(fp)
              if (!(iface & 0x4))
 321f250:	e0bffa0b 	ldhu	r2,-24(fp)
 321f254:	1080010c 	andi	r2,r2,4
 321f258:	1004c03a 	cmpne	r2,r2,zero
 321f25c:	1000021e 	bne	r2,zero,321f268 <alt_read_cfi_width+0x794>
              {
                ret_code = -ENODEV;
 321f260:	00bffb44 	movi	r2,-19
 321f264:	e0bff915 	stw	r2,-28(fp)
        }
      }
    }
  }
  
  return ret_code;
 321f268:	e0bff917 	ldw	r2,-28(fp)
}
 321f26c:	e037883a 	mov	sp,fp
 321f270:	dfc00117 	ldw	ra,4(sp)
 321f274:	df000017 	ldw	fp,0(sp)
 321f278:	dec00204 	addi	sp,sp,8
 321f27c:	f800283a 	ret

0321f280 <alt_check_primary_table>:
 * 
 * Check that the primary Vendor table starts with the 
 * correct pattern
 */
int alt_check_primary_table(alt_flash_cfi_dev* flash)
{
 321f280:	defff904 	addi	sp,sp,-28
 321f284:	dfc00615 	stw	ra,24(sp)
 321f288:	df000515 	stw	fp,20(sp)
 321f28c:	dc000415 	stw	r16,16(sp)
 321f290:	df000404 	addi	fp,sp,16
 321f294:	e13fff15 	stw	r4,-4(fp)
  int i;
  int ret_code = 0;
 321f298:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
 321f29c:	e13fff17 	ldw	r4,-4(fp)
 321f2a0:	01400544 	movi	r5,21
 321f2a4:	321e4d80 	call	321e4d8 <alt_read_16bit_query_entry>
 321f2a8:	10ffffcc 	andi	r3,r2,65535
 321f2ac:	e0bfff17 	ldw	r2,-4(fp)
 321f2b0:	10c03215 	stw	r3,200(r2)
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 321f2b4:	e03ffd15 	stw	zero,-12(fp)
 321f2b8:	00001006 	br	321f2fc <alt_check_primary_table+0x7c>
  {
    primary_query_string[i] = 
 321f2bc:	e43ffd17 	ldw	r16,-12(fp)
 321f2c0:	e0bfff17 	ldw	r2,-4(fp)
 321f2c4:	11803417 	ldw	r6,208(r2)
 321f2c8:	e0bfff17 	ldw	r2,-4(fp)
 321f2cc:	10c03217 	ldw	r3,200(r2)
 321f2d0:	e0bffd17 	ldw	r2,-12(fp)
 321f2d4:	188b883a 	add	r5,r3,r2
 321f2d8:	e13fff17 	ldw	r4,-4(fp)
 321f2dc:	303ee83a 	callr	r6
 321f2e0:	1007883a 	mov	r3,r2
 321f2e4:	e0bffe04 	addi	r2,fp,-8
 321f2e8:	1405883a 	add	r2,r2,r16
 321f2ec:	10c00005 	stb	r3,0(r2)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 321f2f0:	e0bffd17 	ldw	r2,-12(fp)
 321f2f4:	10800044 	addi	r2,r2,1
 321f2f8:	e0bffd15 	stw	r2,-12(fp)
 321f2fc:	e0bffd17 	ldw	r2,-12(fp)
 321f300:	108000d0 	cmplti	r2,r2,3
 321f304:	103fed1e 	bne	r2,zero,321f2bc <alt_check_primary_table+0x3c>
  {
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
  }
    
  if ((primary_query_string[0] != 'P') ||
 321f308:	e0bffe03 	ldbu	r2,-8(fp)
 321f30c:	10803fcc 	andi	r2,r2,255
 321f310:	10801418 	cmpnei	r2,r2,80
 321f314:	1000081e 	bne	r2,zero,321f338 <alt_check_primary_table+0xb8>
 321f318:	e0bffe43 	ldbu	r2,-7(fp)
 321f31c:	10803fcc 	andi	r2,r2,255
 321f320:	10801498 	cmpnei	r2,r2,82
 321f324:	1000041e 	bne	r2,zero,321f338 <alt_check_primary_table+0xb8>
 321f328:	e0bffe83 	ldbu	r2,-6(fp)
 321f32c:	10803fcc 	andi	r2,r2,255
 321f330:	10801260 	cmpeqi	r2,r2,73
 321f334:	1000021e 	bne	r2,zero,321f340 <alt_check_primary_table+0xc0>
      (primary_query_string[1] != 'R') ||
      (primary_query_string[2] != 'I'))
  {
    ret_code = -ENODEV;
 321f338:	00bffb44 	movi	r2,-19
 321f33c:	e0bffc15 	stw	r2,-16(fp)
  }
  
  return ret_code;
 321f340:	e0bffc17 	ldw	r2,-16(fp)
}
 321f344:	e037883a 	mov	sp,fp
 321f348:	dfc00217 	ldw	ra,8(sp)
 321f34c:	df000117 	ldw	fp,4(sp)
 321f350:	dc000017 	ldw	r16,0(sp)
 321f354:	dec00304 	addi	sp,sp,12
 321f358:	f800283a 	ret

0321f35c <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 321f35c:	defffa04 	addi	sp,sp,-24
 321f360:	dfc00515 	stw	ra,20(sp)
 321f364:	df000415 	stw	fp,16(sp)
 321f368:	df000404 	addi	fp,sp,16
 321f36c:	e13ffd15 	stw	r4,-12(fp)
 321f370:	e17ffe15 	stw	r5,-8(fp)
 321f374:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 321f378:	e0bffd17 	ldw	r2,-12(fp)
 321f37c:	10800017 	ldw	r2,0(r2)
 321f380:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 321f384:	e0bffc17 	ldw	r2,-16(fp)
 321f388:	11000a04 	addi	r4,r2,40
 321f38c:	e0bffd17 	ldw	r2,-12(fp)
 321f390:	11c00217 	ldw	r7,8(r2)
 321f394:	e17ffe17 	ldw	r5,-8(fp)
 321f398:	e1bfff17 	ldw	r6,-4(fp)
 321f39c:	321fb180 	call	321fb18 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 321f3a0:	e037883a 	mov	sp,fp
 321f3a4:	dfc00117 	ldw	ra,4(sp)
 321f3a8:	df000017 	ldw	fp,0(sp)
 321f3ac:	dec00204 	addi	sp,sp,8
 321f3b0:	f800283a 	ret

0321f3b4 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 321f3b4:	defffa04 	addi	sp,sp,-24
 321f3b8:	dfc00515 	stw	ra,20(sp)
 321f3bc:	df000415 	stw	fp,16(sp)
 321f3c0:	df000404 	addi	fp,sp,16
 321f3c4:	e13ffd15 	stw	r4,-12(fp)
 321f3c8:	e17ffe15 	stw	r5,-8(fp)
 321f3cc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 321f3d0:	e0bffd17 	ldw	r2,-12(fp)
 321f3d4:	10800017 	ldw	r2,0(r2)
 321f3d8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 321f3dc:	e0bffc17 	ldw	r2,-16(fp)
 321f3e0:	11000a04 	addi	r4,r2,40
 321f3e4:	e0bffd17 	ldw	r2,-12(fp)
 321f3e8:	11c00217 	ldw	r7,8(r2)
 321f3ec:	e17ffe17 	ldw	r5,-8(fp)
 321f3f0:	e1bfff17 	ldw	r6,-4(fp)
 321f3f4:	321fdd80 	call	321fdd8 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 321f3f8:	e037883a 	mov	sp,fp
 321f3fc:	dfc00117 	ldw	ra,4(sp)
 321f400:	df000017 	ldw	fp,0(sp)
 321f404:	dec00204 	addi	sp,sp,8
 321f408:	f800283a 	ret

0321f40c <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 321f40c:	defffc04 	addi	sp,sp,-16
 321f410:	dfc00315 	stw	ra,12(sp)
 321f414:	df000215 	stw	fp,8(sp)
 321f418:	df000204 	addi	fp,sp,8
 321f41c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 321f420:	e0bfff17 	ldw	r2,-4(fp)
 321f424:	10800017 	ldw	r2,0(r2)
 321f428:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 321f42c:	e0bffe17 	ldw	r2,-8(fp)
 321f430:	11000a04 	addi	r4,r2,40
 321f434:	e0bfff17 	ldw	r2,-4(fp)
 321f438:	11400217 	ldw	r5,8(r2)
 321f43c:	321f9b00 	call	321f9b0 <altera_avalon_jtag_uart_close>
}
 321f440:	e037883a 	mov	sp,fp
 321f444:	dfc00117 	ldw	ra,4(sp)
 321f448:	df000017 	ldw	fp,0(sp)
 321f44c:	dec00204 	addi	sp,sp,8
 321f450:	f800283a 	ret

0321f454 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 321f454:	defffa04 	addi	sp,sp,-24
 321f458:	dfc00515 	stw	ra,20(sp)
 321f45c:	df000415 	stw	fp,16(sp)
 321f460:	df000404 	addi	fp,sp,16
 321f464:	e13ffd15 	stw	r4,-12(fp)
 321f468:	e17ffe15 	stw	r5,-8(fp)
 321f46c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 321f470:	e0bffd17 	ldw	r2,-12(fp)
 321f474:	10800017 	ldw	r2,0(r2)
 321f478:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 321f47c:	e0bffc17 	ldw	r2,-16(fp)
 321f480:	11000a04 	addi	r4,r2,40
 321f484:	e17ffe17 	ldw	r5,-8(fp)
 321f488:	e1bfff17 	ldw	r6,-4(fp)
 321f48c:	321fa240 	call	321fa24 <altera_avalon_jtag_uart_ioctl>
}
 321f490:	e037883a 	mov	sp,fp
 321f494:	dfc00117 	ldw	ra,4(sp)
 321f498:	df000017 	ldw	fp,0(sp)
 321f49c:	dec00204 	addi	sp,sp,8
 321f4a0:	f800283a 	ret

0321f4a4 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 321f4a4:	defff504 	addi	sp,sp,-44
 321f4a8:	dfc00a15 	stw	ra,40(sp)
 321f4ac:	df000915 	stw	fp,36(sp)
 321f4b0:	df000904 	addi	fp,sp,36
 321f4b4:	e13ffd15 	stw	r4,-12(fp)
 321f4b8:	e17ffe15 	stw	r5,-8(fp)
 321f4bc:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
 321f4c0:	e0bffd17 	ldw	r2,-12(fp)
 321f4c4:	10800c04 	addi	r2,r2,48
 321f4c8:	e0bffb15 	stw	r2,-20(fp)
 321f4cc:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
 321f4d0:	e13ffc0b 	ldhu	r4,-16(fp)
 321f4d4:	e17ffc84 	addi	r5,fp,-14
 321f4d8:	321782c0 	call	321782c <OSFlagCreate>
 321f4dc:	1007883a 	mov	r3,r2
 321f4e0:	e0bffb17 	ldw	r2,-20(fp)
 321f4e4:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
 321f4e8:	e0bffd17 	ldw	r2,-12(fp)
 321f4ec:	10800a04 	addi	r2,r2,40
 321f4f0:	e0bff915 	stw	r2,-28(fp)
 321f4f4:	00800044 	movi	r2,1
 321f4f8:	e0bffa0d 	sth	r2,-24(fp)
 321f4fc:	e13ffa0b 	ldhu	r4,-24(fp)
 321f500:	321aa300 	call	321aa30 <OSSemCreate>
 321f504:	1007883a 	mov	r3,r2
 321f508:	e0bff917 	ldw	r2,-28(fp)
 321f50c:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
 321f510:	e0bffd17 	ldw	r2,-12(fp)
 321f514:	10800b04 	addi	r2,r2,44
 321f518:	e0bff715 	stw	r2,-36(fp)
 321f51c:	00800044 	movi	r2,1
 321f520:	e0bff80d 	sth	r2,-32(fp)
 321f524:	e13ff80b 	ldhu	r4,-32(fp)
 321f528:	321aa300 	call	321aa30 <OSSemCreate>
 321f52c:	1007883a 	mov	r3,r2
 321f530:	e0bff717 	ldw	r2,-36(fp)
 321f534:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 321f538:	e0fffd17 	ldw	r3,-12(fp)
 321f53c:	00800044 	movi	r2,1
 321f540:	18800815 	stw	r2,32(r3)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 321f544:	e0bffd17 	ldw	r2,-12(fp)
 321f548:	10800017 	ldw	r2,0(r2)
 321f54c:	11000104 	addi	r4,r2,4
 321f550:	e0bffd17 	ldw	r2,-12(fp)
 321f554:	10800817 	ldw	r2,32(r2)
 321f558:	1007883a 	mov	r3,r2
 321f55c:	2005883a 	mov	r2,r4
 321f560:	10c00035 	stwio	r3,0(r2)
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
                      sp, NULL);
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
 321f564:	e13fff17 	ldw	r4,-4(fp)
 321f568:	e17ffd17 	ldw	r5,-12(fp)
 321f56c:	0180c8b4 	movhi	r6,802
 321f570:	31bd7504 	addi	r6,r6,-2604
 321f574:	323a9080 	call	323a908 <alt_irq_register>
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 321f578:	e0bffd17 	ldw	r2,-12(fp)
 321f57c:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 321f580:	e0bffd17 	ldw	r2,-12(fp)
 321f584:	11000204 	addi	r4,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 321f588:	0080c974 	movhi	r2,805
 321f58c:	10926604 	addi	r2,r2,18840
 321f590:	10800017 	ldw	r2,0(r2)
 321f594:	100b883a 	mov	r5,r2
 321f598:	0180c8b4 	movhi	r6,802
 321f59c:	31be2704 	addi	r6,r6,-1892
 321f5a0:	e1fffd17 	ldw	r7,-12(fp)
 321f5a4:	3239f800 	call	3239f80 <alt_alarm_start>
 321f5a8:	1004403a 	cmpge	r2,r2,zero
 321f5ac:	1000041e 	bne	r2,zero,321f5c0 <altera_avalon_jtag_uart_init+0x11c>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 321f5b0:	e0fffd17 	ldw	r3,-12(fp)
 321f5b4:	00a00034 	movhi	r2,32768
 321f5b8:	10bfffc4 	addi	r2,r2,-1
 321f5bc:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 321f5c0:	e037883a 	mov	sp,fp
 321f5c4:	dfc00117 	ldw	ra,4(sp)
 321f5c8:	df000017 	ldw	fp,0(sp)
 321f5cc:	dec00204 	addi	sp,sp,8
 321f5d0:	f800283a 	ret

0321f5d4 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 321f5d4:	defff104 	addi	sp,sp,-60
 321f5d8:	dfc00e15 	stw	ra,56(sp)
 321f5dc:	df000d15 	stw	fp,52(sp)
 321f5e0:	df000d04 	addi	fp,sp,52
 321f5e4:	e13ffe15 	stw	r4,-8(fp)
 321f5e8:	e17fff15 	stw	r5,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 321f5ec:	e0bffe17 	ldw	r2,-8(fp)
 321f5f0:	e0bffc15 	stw	r2,-16(fp)
  unsigned int base = sp->base;
 321f5f4:	e0bffc17 	ldw	r2,-16(fp)
 321f5f8:	10800017 	ldw	r2,0(r2)
 321f5fc:	e0bffb15 	stw	r2,-20(fp)
 321f600:	00000006 	br	321f604 <altera_avalon_jtag_uart_irq+0x30>
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 321f604:	e0bffb17 	ldw	r2,-20(fp)
 321f608:	10800104 	addi	r2,r2,4
 321f60c:	10800037 	ldwio	r2,0(r2)
 321f610:	e0bffa15 	stw	r2,-24(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 321f614:	e0bffa17 	ldw	r2,-24(fp)
 321f618:	1080c00c 	andi	r2,r2,768
 321f61c:	1005003a 	cmpeq	r2,r2,zero
 321f620:	1000991e 	bne	r2,zero,321f888 <altera_avalon_jtag_uart_irq+0x2b4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 321f624:	e0bffa17 	ldw	r2,-24(fp)
 321f628:	1080400c 	andi	r2,r2,256
 321f62c:	1005003a 	cmpeq	r2,r2,zero
 321f630:	1000481e 	bne	r2,zero,321f754 <altera_avalon_jtag_uart_irq+0x180>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 321f634:	00800074 	movhi	r2,1
 321f638:	e0bff915 	stw	r2,-28(fp)
 321f63c:	00000006 	br	321f640 <altera_avalon_jtag_uart_irq+0x6c>
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 321f640:	e0bffc17 	ldw	r2,-16(fp)
 321f644:	10800d17 	ldw	r2,52(r2)
 321f648:	10800044 	addi	r2,r2,1
 321f64c:	1081ffcc 	andi	r2,r2,2047
 321f650:	e0bff815 	stw	r2,-32(fp)
        if (next == sp->rx_out)
 321f654:	e0bffc17 	ldw	r2,-16(fp)
 321f658:	10c00e17 	ldw	r3,56(r2)
 321f65c:	e0bff817 	ldw	r2,-32(fp)
 321f660:	18802826 	beq	r3,r2,321f704 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 321f664:	e0bffb17 	ldw	r2,-20(fp)
 321f668:	10800037 	ldwio	r2,0(r2)
 321f66c:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 321f670:	e0bff917 	ldw	r2,-28(fp)
 321f674:	10a0000c 	andi	r2,r2,32768
 321f678:	1005003a 	cmpeq	r2,r2,zero
 321f67c:	1000211e 	bne	r2,zero,321f704 <altera_avalon_jtag_uart_irq+0x130>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 321f680:	e0bffc17 	ldw	r2,-16(fp)
 321f684:	10c00d17 	ldw	r3,52(r2)
 321f688:	e0bff917 	ldw	r2,-28(fp)
 321f68c:	1009883a 	mov	r4,r2
 321f690:	e0bffc17 	ldw	r2,-16(fp)
 321f694:	1885883a 	add	r2,r3,r2
 321f698:	10801104 	addi	r2,r2,68
 321f69c:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 321f6a0:	e0bffc17 	ldw	r2,-16(fp)
 321f6a4:	10800d17 	ldw	r2,52(r2)
 321f6a8:	10800044 	addi	r2,r2,1
 321f6ac:	10c1ffcc 	andi	r3,r2,2047
 321f6b0:	e0bffc17 	ldw	r2,-16(fp)
 321f6b4:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
 321f6b8:	e0bffc17 	ldw	r2,-16(fp)
 321f6bc:	10800c17 	ldw	r2,48(r2)
 321f6c0:	e0bff515 	stw	r2,-44(fp)
 321f6c4:	00800044 	movi	r2,1
 321f6c8:	e0bff60d 	sth	r2,-40(fp)
 321f6cc:	00800044 	movi	r2,1
 321f6d0:	e0bff685 	stb	r2,-38(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 321f6d4:	0080c974 	movhi	r2,805
 321f6d8:	10921b44 	addi	r2,r2,18541
 321f6dc:	10800003 	ldbu	r2,0(r2)
 321f6e0:	10803fcc 	andi	r2,r2,255
 321f6e4:	1005003a 	cmpeq	r2,r2,zero
 321f6e8:	103fd51e 	bne	r2,zero,321f640 <altera_avalon_jtag_uart_irq+0x6c>
  {
    OSFlagPost (group, flags, opt, &err);
 321f6ec:	e17ff60b 	ldhu	r5,-40(fp)
 321f6f0:	e1bff683 	ldbu	r6,-38(fp)
 321f6f4:	e1fffd04 	addi	r7,fp,-12
 321f6f8:	e13ff517 	ldw	r4,-44(fp)
 321f6fc:	32185540 	call	3218554 <OSFlagPost>
    return err;
 321f700:	003fcf06 	br	321f640 <altera_avalon_jtag_uart_irq+0x6c>
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 321f704:	e0bff917 	ldw	r2,-28(fp)
 321f708:	10bfffec 	andhi	r2,r2,65535
 321f70c:	1005003a 	cmpeq	r2,r2,zero
 321f710:	1000101e 	bne	r2,zero,321f754 <altera_avalon_jtag_uart_irq+0x180>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 321f714:	e0bffc17 	ldw	r2,-16(fp)
 321f718:	10c00817 	ldw	r3,32(r2)
 321f71c:	00bfff84 	movi	r2,-2
 321f720:	1886703a 	and	r3,r3,r2
 321f724:	e0bffc17 	ldw	r2,-16(fp)
 321f728:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 321f72c:	e0bffb17 	ldw	r2,-20(fp)
 321f730:	11000104 	addi	r4,r2,4
 321f734:	e0bffc17 	ldw	r2,-16(fp)
 321f738:	10800817 	ldw	r2,32(r2)
 321f73c:	1007883a 	mov	r3,r2
 321f740:	2005883a 	mov	r2,r4
 321f744:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 321f748:	e0bffb17 	ldw	r2,-20(fp)
 321f74c:	10800104 	addi	r2,r2,4
 321f750:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 321f754:	e0bffa17 	ldw	r2,-24(fp)
 321f758:	1080800c 	andi	r2,r2,512
 321f75c:	1005003a 	cmpeq	r2,r2,zero
 321f760:	103fa81e 	bne	r2,zero,321f604 <altera_avalon_jtag_uart_irq+0x30>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 321f764:	e0bffa17 	ldw	r2,-24(fp)
 321f768:	10bfffec 	andhi	r2,r2,65535
 321f76c:	1004d43a 	srli	r2,r2,16
 321f770:	e0bff715 	stw	r2,-36(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 321f774:	00002706 	br	321f814 <altera_avalon_jtag_uart_irq+0x240>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 321f778:	e13ffb17 	ldw	r4,-20(fp)
 321f77c:	e0bffc17 	ldw	r2,-16(fp)
 321f780:	10c01017 	ldw	r3,64(r2)
 321f784:	e0bffc17 	ldw	r2,-16(fp)
 321f788:	1885883a 	add	r2,r3,r2
 321f78c:	10821104 	addi	r2,r2,2116
 321f790:	10800003 	ldbu	r2,0(r2)
 321f794:	10c03fcc 	andi	r3,r2,255
 321f798:	18c0201c 	xori	r3,r3,128
 321f79c:	18ffe004 	addi	r3,r3,-128
 321f7a0:	2005883a 	mov	r2,r4
 321f7a4:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 321f7a8:	e0bffc17 	ldw	r2,-16(fp)
 321f7ac:	10801017 	ldw	r2,64(r2)
 321f7b0:	10800044 	addi	r2,r2,1
 321f7b4:	10c1ffcc 	andi	r3,r2,2047
 321f7b8:	e0bffc17 	ldw	r2,-16(fp)
 321f7bc:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
 321f7c0:	e0bffc17 	ldw	r2,-16(fp)
 321f7c4:	10800c17 	ldw	r2,48(r2)
 321f7c8:	e0bff315 	stw	r2,-52(fp)
 321f7cc:	00800084 	movi	r2,2
 321f7d0:	e0bff40d 	sth	r2,-48(fp)
 321f7d4:	00800044 	movi	r2,1
 321f7d8:	e0bff485 	stb	r2,-46(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 321f7dc:	0080c974 	movhi	r2,805
 321f7e0:	10921b44 	addi	r2,r2,18541
 321f7e4:	10800003 	ldbu	r2,0(r2)
 321f7e8:	10803fcc 	andi	r2,r2,255
 321f7ec:	1005003a 	cmpeq	r2,r2,zero
 321f7f0:	1000051e 	bne	r2,zero,321f808 <altera_avalon_jtag_uart_irq+0x234>
  {
    OSFlagPost (group, flags, opt, &err);
 321f7f4:	e17ff40b 	ldhu	r5,-48(fp)
 321f7f8:	e1bff483 	ldbu	r6,-46(fp)
 321f7fc:	e1fffd44 	addi	r7,fp,-11
 321f800:	e13ff317 	ldw	r4,-52(fp)
 321f804:	32185540 	call	3218554 <OSFlagPost>

        space--;
 321f808:	e0bff717 	ldw	r2,-36(fp)
 321f80c:	10bfffc4 	addi	r2,r2,-1
 321f810:	e0bff715 	stw	r2,-36(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 321f814:	e0bff717 	ldw	r2,-36(fp)
 321f818:	1005003a 	cmpeq	r2,r2,zero
 321f81c:	1000051e 	bne	r2,zero,321f834 <altera_avalon_jtag_uart_irq+0x260>
 321f820:	e0bffc17 	ldw	r2,-16(fp)
 321f824:	10c01017 	ldw	r3,64(r2)
 321f828:	e0bffc17 	ldw	r2,-16(fp)
 321f82c:	10800f17 	ldw	r2,60(r2)
 321f830:	18bfd11e 	bne	r3,r2,321f778 <altera_avalon_jtag_uart_irq+0x1a4>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 321f834:	e0bff717 	ldw	r2,-36(fp)
 321f838:	1005003a 	cmpeq	r2,r2,zero
 321f83c:	103f711e 	bne	r2,zero,321f604 <altera_avalon_jtag_uart_irq+0x30>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 321f840:	e0bffc17 	ldw	r2,-16(fp)
 321f844:	10c00817 	ldw	r3,32(r2)
 321f848:	00bfff44 	movi	r2,-3
 321f84c:	1886703a 	and	r3,r3,r2
 321f850:	e0bffc17 	ldw	r2,-16(fp)
 321f854:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 321f858:	e0bffc17 	ldw	r2,-16(fp)
 321f85c:	10800017 	ldw	r2,0(r2)
 321f860:	11000104 	addi	r4,r2,4
 321f864:	e0bffc17 	ldw	r2,-16(fp)
 321f868:	10800817 	ldw	r2,32(r2)
 321f86c:	1007883a 	mov	r3,r2
 321f870:	2005883a 	mov	r2,r4
 321f874:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 321f878:	e0bffb17 	ldw	r2,-20(fp)
 321f87c:	10800104 	addi	r2,r2,4
 321f880:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 321f884:	003f5f06 	br	321f604 <altera_avalon_jtag_uart_irq+0x30>
}
 321f888:	e037883a 	mov	sp,fp
 321f88c:	dfc00117 	ldw	ra,4(sp)
 321f890:	df000017 	ldw	fp,0(sp)
 321f894:	dec00204 	addi	sp,sp,8
 321f898:	f800283a 	ret

0321f89c <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 321f89c:	defff804 	addi	sp,sp,-32
 321f8a0:	dfc00715 	stw	ra,28(sp)
 321f8a4:	df000615 	stw	fp,24(sp)
 321f8a8:	df000604 	addi	fp,sp,24
 321f8ac:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 321f8b0:	e0bfff17 	ldw	r2,-4(fp)
 321f8b4:	e0bffd15 	stw	r2,-12(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 321f8b8:	e0bffd17 	ldw	r2,-12(fp)
 321f8bc:	10800017 	ldw	r2,0(r2)
 321f8c0:	10800104 	addi	r2,r2,4
 321f8c4:	10800037 	ldwio	r2,0(r2)
 321f8c8:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 321f8cc:	e0bffc17 	ldw	r2,-16(fp)
 321f8d0:	1081000c 	andi	r2,r2,1024
 321f8d4:	1005003a 	cmpeq	r2,r2,zero
 321f8d8:	10000c1e 	bne	r2,zero,321f90c <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 321f8dc:	e0bffd17 	ldw	r2,-12(fp)
 321f8e0:	10800017 	ldw	r2,0(r2)
 321f8e4:	11000104 	addi	r4,r2,4
 321f8e8:	e0bffd17 	ldw	r2,-12(fp)
 321f8ec:	10800817 	ldw	r2,32(r2)
 321f8f0:	10810014 	ori	r2,r2,1024
 321f8f4:	1007883a 	mov	r3,r2
 321f8f8:	2005883a 	mov	r2,r4
 321f8fc:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
 321f900:	e0bffd17 	ldw	r2,-12(fp)
 321f904:	10000915 	stw	zero,36(r2)
 321f908:	00002106 	br	321f990 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 321f90c:	e0bffd17 	ldw	r2,-12(fp)
 321f910:	10c00917 	ldw	r3,36(r2)
 321f914:	00a00034 	movhi	r2,32768
 321f918:	10bfff04 	addi	r2,r2,-4
 321f91c:	10c01c36 	bltu	r2,r3,321f990 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
 321f920:	e0bffd17 	ldw	r2,-12(fp)
 321f924:	10800917 	ldw	r2,36(r2)
 321f928:	10c00044 	addi	r3,r2,1
 321f92c:	e0bffd17 	ldw	r2,-12(fp)
 321f930:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
 321f934:	e0bffd17 	ldw	r2,-12(fp)
 321f938:	10c00917 	ldw	r3,36(r2)
 321f93c:	e0bffd17 	ldw	r2,-12(fp)
 321f940:	10800117 	ldw	r2,4(r2)
 321f944:	18801236 	bltu	r3,r2,321f990 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
 321f948:	e0bffd17 	ldw	r2,-12(fp)
 321f94c:	10800c17 	ldw	r2,48(r2)
 321f950:	e0bffa15 	stw	r2,-24(fp)
 321f954:	00800104 	movi	r2,4
 321f958:	e0bffb0d 	sth	r2,-20(fp)
 321f95c:	00800044 	movi	r2,1
 321f960:	e0bffb85 	stb	r2,-18(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 321f964:	0080c974 	movhi	r2,805
 321f968:	10921b44 	addi	r2,r2,18541
 321f96c:	10800003 	ldbu	r2,0(r2)
 321f970:	10803fcc 	andi	r2,r2,255
 321f974:	1005003a 	cmpeq	r2,r2,zero
 321f978:	1000051e 	bne	r2,zero,321f990 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
 321f97c:	e17ffb0b 	ldhu	r5,-20(fp)
 321f980:	e1bffb83 	ldbu	r6,-18(fp)
 321f984:	e1fffe04 	addi	r7,fp,-8
 321f988:	e13ffa17 	ldw	r4,-24(fp)
 321f98c:	32185540 	call	3218554 <OSFlagPost>
 321f990:	0080c974 	movhi	r2,805
 321f994:	10926604 	addi	r2,r2,18840
 321f998:	10800017 	ldw	r2,0(r2)
    }
  }

  return alt_ticks_per_second();
}
 321f99c:	e037883a 	mov	sp,fp
 321f9a0:	dfc00117 	ldw	ra,4(sp)
 321f9a4:	df000017 	ldw	fp,0(sp)
 321f9a8:	dec00204 	addi	sp,sp,8
 321f9ac:	f800283a 	ret

0321f9b0 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 321f9b0:	defffc04 	addi	sp,sp,-16
 321f9b4:	df000315 	stw	fp,12(sp)
 321f9b8:	df000304 	addi	fp,sp,12
 321f9bc:	e13ffd15 	stw	r4,-12(fp)
 321f9c0:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 321f9c4:	00000706 	br	321f9e4 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
 321f9c8:	e0bffe17 	ldw	r2,-8(fp)
 321f9cc:	1090000c 	andi	r2,r2,16384
 321f9d0:	1005003a 	cmpeq	r2,r2,zero
 321f9d4:	1000031e 	bne	r2,zero,321f9e4 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
 321f9d8:	00bffd44 	movi	r2,-11
 321f9dc:	e0bfff15 	stw	r2,-4(fp)
 321f9e0:	00000b06 	br	321fa10 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 321f9e4:	e0bffd17 	ldw	r2,-12(fp)
 321f9e8:	10c01017 	ldw	r3,64(r2)
 321f9ec:	e0bffd17 	ldw	r2,-12(fp)
 321f9f0:	10800f17 	ldw	r2,60(r2)
 321f9f4:	18800526 	beq	r3,r2,321fa0c <altera_avalon_jtag_uart_close+0x5c>
 321f9f8:	e0bffd17 	ldw	r2,-12(fp)
 321f9fc:	10c00917 	ldw	r3,36(r2)
 321fa00:	e0bffd17 	ldw	r2,-12(fp)
 321fa04:	10800117 	ldw	r2,4(r2)
 321fa08:	18bfef36 	bltu	r3,r2,321f9c8 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 321fa0c:	e03fff15 	stw	zero,-4(fp)
 321fa10:	e0bfff17 	ldw	r2,-4(fp)
}
 321fa14:	e037883a 	mov	sp,fp
 321fa18:	df000017 	ldw	fp,0(sp)
 321fa1c:	dec00104 	addi	sp,sp,4
 321fa20:	f800283a 	ret

0321fa24 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 321fa24:	defff804 	addi	sp,sp,-32
 321fa28:	df000715 	stw	fp,28(sp)
 321fa2c:	df000704 	addi	fp,sp,28
 321fa30:	e13ffb15 	stw	r4,-20(fp)
 321fa34:	e17ffc15 	stw	r5,-16(fp)
 321fa38:	e1bffd15 	stw	r6,-12(fp)
  int rc = -ENOTTY;
 321fa3c:	00bff9c4 	movi	r2,-25
 321fa40:	e0bffa15 	stw	r2,-24(fp)

  switch (req)
 321fa44:	e0bffc17 	ldw	r2,-16(fp)
 321fa48:	e0bfff15 	stw	r2,-4(fp)
 321fa4c:	e0ffff17 	ldw	r3,-4(fp)
 321fa50:	189a8060 	cmpeqi	r2,r3,27137
 321fa54:	1000041e 	bne	r2,zero,321fa68 <altera_avalon_jtag_uart_ioctl+0x44>
 321fa58:	e0ffff17 	ldw	r3,-4(fp)
 321fa5c:	189a80a0 	cmpeqi	r2,r3,27138
 321fa60:	10001b1e 	bne	r2,zero,321fad0 <altera_avalon_jtag_uart_ioctl+0xac>
 321fa64:	00002706 	br	321fb04 <altera_avalon_jtag_uart_ioctl+0xe0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 321fa68:	e0bffb17 	ldw	r2,-20(fp)
 321fa6c:	10c00117 	ldw	r3,4(r2)
 321fa70:	00a00034 	movhi	r2,32768
 321fa74:	10bfffc4 	addi	r2,r2,-1
 321fa78:	18802226 	beq	r3,r2,321fb04 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
 321fa7c:	e0bffd17 	ldw	r2,-12(fp)
 321fa80:	10800017 	ldw	r2,0(r2)
 321fa84:	e0bff915 	stw	r2,-28(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 321fa88:	e0bff917 	ldw	r2,-28(fp)
 321fa8c:	10800090 	cmplti	r2,r2,2
 321fa90:	1000071e 	bne	r2,zero,321fab0 <altera_avalon_jtag_uart_ioctl+0x8c>
 321fa94:	e0fff917 	ldw	r3,-28(fp)
 321fa98:	00a00034 	movhi	r2,32768
 321fa9c:	10bfffc4 	addi	r2,r2,-1
 321faa0:	18800326 	beq	r3,r2,321fab0 <altera_avalon_jtag_uart_ioctl+0x8c>
 321faa4:	e0bff917 	ldw	r2,-28(fp)
 321faa8:	e0bffe15 	stw	r2,-8(fp)
 321faac:	00000306 	br	321fabc <altera_avalon_jtag_uart_ioctl+0x98>
 321fab0:	00e00034 	movhi	r3,32768
 321fab4:	18ffff84 	addi	r3,r3,-2
 321fab8:	e0fffe15 	stw	r3,-8(fp)
 321fabc:	e0bffb17 	ldw	r2,-20(fp)
 321fac0:	e0fffe17 	ldw	r3,-8(fp)
 321fac4:	10c00115 	stw	r3,4(r2)
      rc = 0;
 321fac8:	e03ffa15 	stw	zero,-24(fp)
    }
    break;
 321facc:	00000d06 	br	321fb04 <altera_avalon_jtag_uart_ioctl+0xe0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 321fad0:	e0bffb17 	ldw	r2,-20(fp)
 321fad4:	10c00117 	ldw	r3,4(r2)
 321fad8:	00a00034 	movhi	r2,32768
 321fadc:	10bfffc4 	addi	r2,r2,-1
 321fae0:	18800826 	beq	r3,r2,321fb04 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 321fae4:	e13ffd17 	ldw	r4,-12(fp)
 321fae8:	e0bffb17 	ldw	r2,-20(fp)
 321faec:	10c00917 	ldw	r3,36(r2)
 321faf0:	e0bffb17 	ldw	r2,-20(fp)
 321faf4:	10800117 	ldw	r2,4(r2)
 321faf8:	1885803a 	cmpltu	r2,r3,r2
 321fafc:	20800015 	stw	r2,0(r4)
      rc = 0;
 321fb00:	e03ffa15 	stw	zero,-24(fp)

  default:
    break;
  }

  return rc;
 321fb04:	e0bffa17 	ldw	r2,-24(fp)
}
 321fb08:	e037883a 	mov	sp,fp
 321fb0c:	df000017 	ldw	fp,0(sp)
 321fb10:	dec00104 	addi	sp,sp,4
 321fb14:	f800283a 	ret

0321fb18 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 321fb18:	deffeb04 	addi	sp,sp,-84
 321fb1c:	dfc01415 	stw	ra,80(sp)
 321fb20:	df001315 	stw	fp,76(sp)
 321fb24:	df001304 	addi	fp,sp,76
 321fb28:	e13ffb15 	stw	r4,-20(fp)
 321fb2c:	e17ffc15 	stw	r5,-16(fp)
 321fb30:	e1bffd15 	stw	r6,-12(fp)
 321fb34:	e1fffe15 	stw	r7,-8(fp)
  char * ptr = buffer;
 321fb38:	e0bffc17 	ldw	r2,-16(fp)
 321fb3c:	e0bff915 	stw	r2,-28(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
 321fb40:	e0bffb17 	ldw	r2,-20(fp)
 321fb44:	10800a17 	ldw	r2,40(r2)
 321fb48:	e0bff315 	stw	r2,-52(fp)
 321fb4c:	e03ff40d 	sth	zero,-48(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 321fb50:	e17ff40b 	ldhu	r5,-48(fp)
 321fb54:	e1bffa44 	addi	r6,fp,-23
 321fb58:	e13ff317 	ldw	r4,-52(fp)
 321fb5c:	321ade40 	call	321ade4 <OSSemPend>

  while (space > 0)
 321fb60:	00006406 	br	321fcf4 <altera_avalon_jtag_uart_read+0x1dc>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 321fb64:	e0bffb17 	ldw	r2,-20(fp)
 321fb68:	10800d17 	ldw	r2,52(r2)
 321fb6c:	e0bff615 	stw	r2,-40(fp)
      out = sp->rx_out;
 321fb70:	e0bffb17 	ldw	r2,-20(fp)
 321fb74:	10800e17 	ldw	r2,56(r2)
 321fb78:	e0bff515 	stw	r2,-44(fp)

      if (in >= out)
 321fb7c:	e0fff617 	ldw	r3,-40(fp)
 321fb80:	e0bff517 	ldw	r2,-44(fp)
 321fb84:	18800536 	bltu	r3,r2,321fb9c <altera_avalon_jtag_uart_read+0x84>
        n = in - out;
 321fb88:	e0bff617 	ldw	r2,-40(fp)
 321fb8c:	e0fff517 	ldw	r3,-44(fp)
 321fb90:	10c5c83a 	sub	r2,r2,r3
 321fb94:	e0bff715 	stw	r2,-36(fp)
 321fb98:	00000406 	br	321fbac <altera_avalon_jtag_uart_read+0x94>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 321fb9c:	00820004 	movi	r2,2048
 321fba0:	e0fff517 	ldw	r3,-44(fp)
 321fba4:	10c5c83a 	sub	r2,r2,r3
 321fba8:	e0bff715 	stw	r2,-36(fp)

      if (n == 0)
 321fbac:	e0bff717 	ldw	r2,-36(fp)
 321fbb0:	1005003a 	cmpeq	r2,r2,zero
 321fbb4:	10001f1e 	bne	r2,zero,321fc34 <altera_avalon_jtag_uart_read+0x11c>
        break; /* No more data available */

      if (n > space)
 321fbb8:	e0fffd17 	ldw	r3,-12(fp)
 321fbbc:	e0bff717 	ldw	r2,-36(fp)
 321fbc0:	1880022e 	bgeu	r3,r2,321fbcc <altera_avalon_jtag_uart_read+0xb4>
        n = space;
 321fbc4:	e0bffd17 	ldw	r2,-12(fp)
 321fbc8:	e0bff715 	stw	r2,-36(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 321fbcc:	e0bffb17 	ldw	r2,-20(fp)
 321fbd0:	10c01104 	addi	r3,r2,68
 321fbd4:	e0bff517 	ldw	r2,-44(fp)
 321fbd8:	1887883a 	add	r3,r3,r2
 321fbdc:	e0bff917 	ldw	r2,-28(fp)
 321fbe0:	1009883a 	mov	r4,r2
 321fbe4:	180b883a 	mov	r5,r3
 321fbe8:	e1bff717 	ldw	r6,-36(fp)
 321fbec:	32067cc0 	call	32067cc <memcpy>
      ptr   += n;
 321fbf0:	e0fff717 	ldw	r3,-36(fp)
 321fbf4:	e0bff917 	ldw	r2,-28(fp)
 321fbf8:	10c5883a 	add	r2,r2,r3
 321fbfc:	e0bff915 	stw	r2,-28(fp)
      space -= n;
 321fc00:	e0fffd17 	ldw	r3,-12(fp)
 321fc04:	e0bff717 	ldw	r2,-36(fp)
 321fc08:	1885c83a 	sub	r2,r3,r2
 321fc0c:	e0bffd15 	stw	r2,-12(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 321fc10:	e0fff517 	ldw	r3,-44(fp)
 321fc14:	e0bff717 	ldw	r2,-36(fp)
 321fc18:	1885883a 	add	r2,r3,r2
 321fc1c:	10c1ffcc 	andi	r3,r2,2047
 321fc20:	e0bffb17 	ldw	r2,-20(fp)
 321fc24:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
 321fc28:	e0bffd17 	ldw	r2,-12(fp)
 321fc2c:	10800048 	cmpgei	r2,r2,1
 321fc30:	103fcc1e 	bne	r2,zero,321fb64 <altera_avalon_jtag_uart_read+0x4c>

    /* If we read any data then return it */
    if (ptr != buffer)
 321fc34:	e0fff917 	ldw	r3,-28(fp)
 321fc38:	e0bffc17 	ldw	r2,-16(fp)
 321fc3c:	1880301e 	bne	r3,r2,321fd00 <altera_avalon_jtag_uart_read+0x1e8>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 321fc40:	e0bffe17 	ldw	r2,-8(fp)
 321fc44:	1090000c 	andi	r2,r2,16384
 321fc48:	1004c03a 	cmpne	r2,r2,zero
 321fc4c:	10002c1e 	bne	r2,zero,321fd00 <altera_avalon_jtag_uart_read+0x1e8>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
 321fc50:	0080c974 	movhi	r2,805
 321fc54:	10921b44 	addi	r2,r2,18541
 321fc58:	10800003 	ldbu	r2,0(r2)
 321fc5c:	10803fcc 	andi	r2,r2,255
 321fc60:	10800058 	cmpnei	r2,r2,1
 321fc64:	1000161e 	bne	r2,zero,321fcc0 <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
 321fc68:	e0bffb17 	ldw	r2,-20(fp)
 321fc6c:	10800c17 	ldw	r2,48(r2)
 321fc70:	e0bff015 	stw	r2,-64(fp)
 321fc74:	00800144 	movi	r2,5
 321fc78:	e0bff10d 	sth	r2,-60(fp)
 321fc7c:	00bfe0c4 	movi	r2,-125
 321fc80:	e0bff185 	stb	r2,-58(fp)
 321fc84:	e03ff20d 	sth	zero,-56(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 321fc88:	0080c974 	movhi	r2,805
 321fc8c:	10921b44 	addi	r2,r2,18541
 321fc90:	10800003 	ldbu	r2,0(r2)
 321fc94:	10803fcc 	andi	r2,r2,255
 321fc98:	1005003a 	cmpeq	r2,r2,zero
 321fc9c:	1000111e 	bne	r2,zero,321fce4 <altera_avalon_jtag_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 321fca0:	e17ff10b 	ldhu	r5,-60(fp)
 321fca4:	e1bff183 	ldbu	r6,-58(fp)
 321fca8:	e1fff20b 	ldhu	r7,-56(fp)
 321fcac:	e0bffa04 	addi	r2,fp,-24
 321fcb0:	d8800015 	stw	r2,0(sp)
 321fcb4:	e13ff017 	ldw	r4,-64(fp)
 321fcb8:	3217ea80 	call	3217ea8 <OSFlagPend>
    return err;
 321fcbc:	00000906 	br	321fce4 <altera_avalon_jtag_uart_read+0x1cc>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 321fcc0:	e0bffb17 	ldw	r2,-20(fp)
 321fcc4:	10c00d17 	ldw	r3,52(r2)
 321fcc8:	e0bff617 	ldw	r2,-40(fp)
 321fccc:	1880051e 	bne	r3,r2,321fce4 <altera_avalon_jtag_uart_read+0x1cc>
 321fcd0:	e0bffb17 	ldw	r2,-20(fp)
 321fcd4:	10c00917 	ldw	r3,36(r2)
 321fcd8:	e0bffb17 	ldw	r2,-20(fp)
 321fcdc:	10800117 	ldw	r2,4(r2)
 321fce0:	18bff736 	bltu	r3,r2,321fcc0 <altera_avalon_jtag_uart_read+0x1a8>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 321fce4:	e0bffb17 	ldw	r2,-20(fp)
 321fce8:	10c00d17 	ldw	r3,52(r2)
 321fcec:	e0bff617 	ldw	r2,-40(fp)
 321fcf0:	18800326 	beq	r3,r2,321fd00 <altera_avalon_jtag_uart_read+0x1e8>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 321fcf4:	e0bffd17 	ldw	r2,-12(fp)
 321fcf8:	10800048 	cmpgei	r2,r2,1
 321fcfc:	103f991e 	bne	r2,zero,321fb64 <altera_avalon_jtag_uart_read+0x4c>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 321fd00:	e0bffb17 	ldw	r2,-20(fp)
 321fd04:	11000a17 	ldw	r4,40(r2)
 321fd08:	321b1dc0 	call	321b1dc <OSSemPost>

  if (ptr != buffer)
 321fd0c:	e0fff917 	ldw	r3,-28(fp)
 321fd10:	e0bffc17 	ldw	r2,-16(fp)
 321fd14:	18801926 	beq	r3,r2,321fd7c <altera_avalon_jtag_uart_read+0x264>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321fd18:	0005303a 	rdctl	r2,status
 321fd1c:	e0bfef15 	stw	r2,-68(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321fd20:	e0ffef17 	ldw	r3,-68(fp)
 321fd24:	00bfff84 	movi	r2,-2
 321fd28:	1884703a 	and	r2,r3,r2
 321fd2c:	1001703a 	wrctl	status,r2
  
  return context;
 321fd30:	e0bfef17 	ldw	r2,-68(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 321fd34:	e0bff815 	stw	r2,-32(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 321fd38:	e0bffb17 	ldw	r2,-20(fp)
 321fd3c:	10800817 	ldw	r2,32(r2)
 321fd40:	10c00054 	ori	r3,r2,1
 321fd44:	e0bffb17 	ldw	r2,-20(fp)
 321fd48:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 321fd4c:	e0bffb17 	ldw	r2,-20(fp)
 321fd50:	10800017 	ldw	r2,0(r2)
 321fd54:	11000104 	addi	r4,r2,4
 321fd58:	e0bffb17 	ldw	r2,-20(fp)
 321fd5c:	10800817 	ldw	r2,32(r2)
 321fd60:	1007883a 	mov	r3,r2
 321fd64:	2005883a 	mov	r2,r4
 321fd68:	10c00035 	stwio	r3,0(r2)
 321fd6c:	e0bff817 	ldw	r2,-32(fp)
 321fd70:	e0bfee15 	stw	r2,-72(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321fd74:	e0bfee17 	ldw	r2,-72(fp)
 321fd78:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 321fd7c:	e0fff917 	ldw	r3,-28(fp)
 321fd80:	e0bffc17 	ldw	r2,-16(fp)
 321fd84:	18800526 	beq	r3,r2,321fd9c <altera_avalon_jtag_uart_read+0x284>
    return ptr - buffer;
 321fd88:	e0fff917 	ldw	r3,-28(fp)
 321fd8c:	e0bffc17 	ldw	r2,-16(fp)
 321fd90:	1887c83a 	sub	r3,r3,r2
 321fd94:	e0ffff15 	stw	r3,-4(fp)
 321fd98:	00000906 	br	321fdc0 <altera_avalon_jtag_uart_read+0x2a8>
  else if (flags & O_NONBLOCK)
 321fd9c:	e0bffe17 	ldw	r2,-8(fp)
 321fda0:	1090000c 	andi	r2,r2,16384
 321fda4:	1005003a 	cmpeq	r2,r2,zero
 321fda8:	1000031e 	bne	r2,zero,321fdb8 <altera_avalon_jtag_uart_read+0x2a0>
    return -EWOULDBLOCK;
 321fdac:	00bffd44 	movi	r2,-11
 321fdb0:	e0bfff15 	stw	r2,-4(fp)
 321fdb4:	00000206 	br	321fdc0 <altera_avalon_jtag_uart_read+0x2a8>
  else
    return -EIO;
 321fdb8:	00bffec4 	movi	r2,-5
 321fdbc:	e0bfff15 	stw	r2,-4(fp)
 321fdc0:	e0bfff17 	ldw	r2,-4(fp)
}
 321fdc4:	e037883a 	mov	sp,fp
 321fdc8:	dfc00117 	ldw	ra,4(sp)
 321fdcc:	df000017 	ldw	fp,0(sp)
 321fdd0:	dec00204 	addi	sp,sp,8
 321fdd4:	f800283a 	ret

0321fdd8 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 321fdd8:	deffeb04 	addi	sp,sp,-84
 321fddc:	dfc01415 	stw	ra,80(sp)
 321fde0:	df001315 	stw	fp,76(sp)
 321fde4:	df001304 	addi	fp,sp,76
 321fde8:	e13ffb15 	stw	r4,-20(fp)
 321fdec:	e17ffc15 	stw	r5,-16(fp)
 321fdf0:	e1bffd15 	stw	r6,-12(fp)
 321fdf4:	e1fffe15 	stw	r7,-8(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 321fdf8:	e03ff815 	stw	zero,-32(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 321fdfc:	e0bffc17 	ldw	r2,-16(fp)
 321fe00:	e0bff515 	stw	r2,-44(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
 321fe04:	e0bffb17 	ldw	r2,-20(fp)
 321fe08:	10800b17 	ldw	r2,44(r2)
 321fe0c:	e0bff315 	stw	r2,-52(fp)
 321fe10:	e03ff40d 	sth	zero,-48(fp)
 321fe14:	e17ff40b 	ldhu	r5,-48(fp)
 321fe18:	e1bffa04 	addi	r6,fp,-24
 321fe1c:	e13ff317 	ldw	r4,-52(fp)
 321fe20:	321ade40 	call	321ade4 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 321fe24:	00003a06 	br	321ff10 <altera_avalon_jtag_uart_write+0x138>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 321fe28:	e0bffb17 	ldw	r2,-20(fp)
 321fe2c:	10800f17 	ldw	r2,60(r2)
 321fe30:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
 321fe34:	e0bffb17 	ldw	r2,-20(fp)
 321fe38:	10801017 	ldw	r2,64(r2)
 321fe3c:	e0bff815 	stw	r2,-32(fp)

      if (in < out)
 321fe40:	e0fff917 	ldw	r3,-28(fp)
 321fe44:	e0bff817 	ldw	r2,-32(fp)
 321fe48:	1880062e 	bgeu	r3,r2,321fe64 <altera_avalon_jtag_uart_write+0x8c>
        n = out - 1 - in;
 321fe4c:	e0fff817 	ldw	r3,-32(fp)
 321fe50:	e0bff917 	ldw	r2,-28(fp)
 321fe54:	1885c83a 	sub	r2,r3,r2
 321fe58:	10bfffc4 	addi	r2,r2,-1
 321fe5c:	e0bff715 	stw	r2,-36(fp)
 321fe60:	00000c06 	br	321fe94 <altera_avalon_jtag_uart_write+0xbc>
      else if (out > 0)
 321fe64:	e0bff817 	ldw	r2,-32(fp)
 321fe68:	1005003a 	cmpeq	r2,r2,zero
 321fe6c:	1000051e 	bne	r2,zero,321fe84 <altera_avalon_jtag_uart_write+0xac>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 321fe70:	00820004 	movi	r2,2048
 321fe74:	e0fff917 	ldw	r3,-28(fp)
 321fe78:	10c5c83a 	sub	r2,r2,r3
 321fe7c:	e0bff715 	stw	r2,-36(fp)
 321fe80:	00000406 	br	321fe94 <altera_avalon_jtag_uart_write+0xbc>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 321fe84:	0081ffc4 	movi	r2,2047
 321fe88:	e0fff917 	ldw	r3,-28(fp)
 321fe8c:	10c5c83a 	sub	r2,r2,r3
 321fe90:	e0bff715 	stw	r2,-36(fp)

      if (n == 0)
 321fe94:	e0bff717 	ldw	r2,-36(fp)
 321fe98:	1005003a 	cmpeq	r2,r2,zero
 321fe9c:	10001f1e 	bne	r2,zero,321ff1c <altera_avalon_jtag_uart_write+0x144>
        break;

      if (n > count)
 321fea0:	e0fffd17 	ldw	r3,-12(fp)
 321fea4:	e0bff717 	ldw	r2,-36(fp)
 321fea8:	1880022e 	bgeu	r3,r2,321feb4 <altera_avalon_jtag_uart_write+0xdc>
        n = count;
 321feac:	e0bffd17 	ldw	r2,-12(fp)
 321feb0:	e0bff715 	stw	r2,-36(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 321feb4:	e0bffb17 	ldw	r2,-20(fp)
 321feb8:	10c21104 	addi	r3,r2,2116
 321febc:	e0bff917 	ldw	r2,-28(fp)
 321fec0:	1885883a 	add	r2,r3,r2
 321fec4:	e0fffc17 	ldw	r3,-16(fp)
 321fec8:	1009883a 	mov	r4,r2
 321fecc:	180b883a 	mov	r5,r3
 321fed0:	e1bff717 	ldw	r6,-36(fp)
 321fed4:	32067cc0 	call	32067cc <memcpy>
      ptr   += n;
 321fed8:	e0fff717 	ldw	r3,-36(fp)
 321fedc:	e0bffc17 	ldw	r2,-16(fp)
 321fee0:	10c5883a 	add	r2,r2,r3
 321fee4:	e0bffc15 	stw	r2,-16(fp)
      count -= n;
 321fee8:	e0fffd17 	ldw	r3,-12(fp)
 321feec:	e0bff717 	ldw	r2,-36(fp)
 321fef0:	1885c83a 	sub	r2,r3,r2
 321fef4:	e0bffd15 	stw	r2,-12(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 321fef8:	e0fff917 	ldw	r3,-28(fp)
 321fefc:	e0bff717 	ldw	r2,-36(fp)
 321ff00:	1885883a 	add	r2,r3,r2
 321ff04:	10c1ffcc 	andi	r3,r2,2047
 321ff08:	e0bffb17 	ldw	r2,-20(fp)
 321ff0c:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 321ff10:	e0bffd17 	ldw	r2,-12(fp)
 321ff14:	10800048 	cmpgei	r2,r2,1
 321ff18:	103fc31e 	bne	r2,zero,321fe28 <altera_avalon_jtag_uart_write+0x50>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321ff1c:	0005303a 	rdctl	r2,status
 321ff20:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321ff24:	e0fff217 	ldw	r3,-56(fp)
 321ff28:	00bfff84 	movi	r2,-2
 321ff2c:	1884703a 	and	r2,r3,r2
 321ff30:	1001703a 	wrctl	status,r2
  
  return context;
 321ff34:	e0bff217 	ldw	r2,-56(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 321ff38:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 321ff3c:	e0bffb17 	ldw	r2,-20(fp)
 321ff40:	10800817 	ldw	r2,32(r2)
 321ff44:	10c00094 	ori	r3,r2,2
 321ff48:	e0bffb17 	ldw	r2,-20(fp)
 321ff4c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 321ff50:	e0bffb17 	ldw	r2,-20(fp)
 321ff54:	10800017 	ldw	r2,0(r2)
 321ff58:	11000104 	addi	r4,r2,4
 321ff5c:	e0bffb17 	ldw	r2,-20(fp)
 321ff60:	10800817 	ldw	r2,32(r2)
 321ff64:	1007883a 	mov	r3,r2
 321ff68:	2005883a 	mov	r2,r4
 321ff6c:	10c00035 	stwio	r3,0(r2)
 321ff70:	e0bff617 	ldw	r2,-40(fp)
 321ff74:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321ff78:	e0bff117 	ldw	r2,-60(fp)
 321ff7c:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 321ff80:	e0bffd17 	ldw	r2,-12(fp)
 321ff84:	10800050 	cmplti	r2,r2,1
 321ff88:	10002d1e 	bne	r2,zero,3220040 <altera_avalon_jtag_uart_write+0x268>
    {
      if (flags & O_NONBLOCK)
 321ff8c:	e0bffe17 	ldw	r2,-8(fp)
 321ff90:	1090000c 	andi	r2,r2,16384
 321ff94:	1004c03a 	cmpne	r2,r2,zero
 321ff98:	10002c1e 	bne	r2,zero,322004c <altera_avalon_jtag_uart_write+0x274>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
 321ff9c:	0080c974 	movhi	r2,805
 321ffa0:	10921b44 	addi	r2,r2,18541
 321ffa4:	10800003 	ldbu	r2,0(r2)
 321ffa8:	10803fcc 	andi	r2,r2,255
 321ffac:	10800058 	cmpnei	r2,r2,1
 321ffb0:	1000161e 	bne	r2,zero,322000c <altera_avalon_jtag_uart_write+0x234>
         * When running in a multi-threaded mode, we pend on the write event
         * flag set or the timeout flag in the isr. This avoids wasting CPU
         * cycles waiting in this thread, when we could be doing something
         * more profitable elsewhere.
         */
        ALT_FLAG_PEND (sp->events,
 321ffb4:	e0bffb17 	ldw	r2,-20(fp)
 321ffb8:	10800c17 	ldw	r2,48(r2)
 321ffbc:	e0bfee15 	stw	r2,-72(fp)
 321ffc0:	00800184 	movi	r2,6
 321ffc4:	e0bfef0d 	sth	r2,-68(fp)
 321ffc8:	00bfe0c4 	movi	r2,-125
 321ffcc:	e0bfef85 	stb	r2,-66(fp)
 321ffd0:	e03ff00d 	sth	zero,-64(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 321ffd4:	0080c974 	movhi	r2,805
 321ffd8:	10921b44 	addi	r2,r2,18541
 321ffdc:	10800003 	ldbu	r2,0(r2)
 321ffe0:	10803fcc 	andi	r2,r2,255
 321ffe4:	1005003a 	cmpeq	r2,r2,zero
 321ffe8:	1000111e 	bne	r2,zero,3220030 <altera_avalon_jtag_uart_write+0x258>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 321ffec:	e17fef0b 	ldhu	r5,-68(fp)
 321fff0:	e1bfef83 	ldbu	r6,-66(fp)
 321fff4:	e1fff00b 	ldhu	r7,-64(fp)
 321fff8:	e0bffa44 	addi	r2,fp,-23
 321fffc:	d8800015 	stw	r2,0(sp)
 3220000:	e13fee17 	ldw	r4,-72(fp)
 3220004:	3217ea80 	call	3217ea8 <OSFlagPend>
    return err;
 3220008:	00000906 	br	3220030 <altera_avalon_jtag_uart_write+0x258>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 322000c:	e0bffb17 	ldw	r2,-20(fp)
 3220010:	10c01017 	ldw	r3,64(r2)
 3220014:	e0bff817 	ldw	r2,-32(fp)
 3220018:	1880051e 	bne	r3,r2,3220030 <altera_avalon_jtag_uart_write+0x258>
 322001c:	e0bffb17 	ldw	r2,-20(fp)
 3220020:	10c00917 	ldw	r3,36(r2)
 3220024:	e0bffb17 	ldw	r2,-20(fp)
 3220028:	10800117 	ldw	r2,4(r2)
 322002c:	18bff736 	bltu	r3,r2,322000c <altera_avalon_jtag_uart_write+0x234>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
 3220030:	e0bffb17 	ldw	r2,-20(fp)
 3220034:	10c01017 	ldw	r3,64(r2)
 3220038:	e0bff817 	ldw	r2,-32(fp)
 322003c:	18800326 	beq	r3,r2,322004c <altera_avalon_jtag_uart_write+0x274>
        break;
    }
  }
  while (count > 0);
 3220040:	e0bffd17 	ldw	r2,-12(fp)
 3220044:	10800048 	cmpgei	r2,r2,1
 3220048:	103fb11e 	bne	r2,zero,321ff10 <altera_avalon_jtag_uart_write+0x138>

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
 322004c:	e0bffb17 	ldw	r2,-20(fp)
 3220050:	11000b17 	ldw	r4,44(r2)
 3220054:	321b1dc0 	call	321b1dc <OSSemPost>

  if (ptr != start)
 3220058:	e0fffc17 	ldw	r3,-16(fp)
 322005c:	e0bff517 	ldw	r2,-44(fp)
 3220060:	18800526 	beq	r3,r2,3220078 <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
 3220064:	e0fffc17 	ldw	r3,-16(fp)
 3220068:	e0bff517 	ldw	r2,-44(fp)
 322006c:	1887c83a 	sub	r3,r3,r2
 3220070:	e0ffff15 	stw	r3,-4(fp)
 3220074:	00000906 	br	322009c <altera_avalon_jtag_uart_write+0x2c4>
  else if (flags & O_NONBLOCK)
 3220078:	e0bffe17 	ldw	r2,-8(fp)
 322007c:	1090000c 	andi	r2,r2,16384
 3220080:	1005003a 	cmpeq	r2,r2,zero
 3220084:	1000031e 	bne	r2,zero,3220094 <altera_avalon_jtag_uart_write+0x2bc>
    return -EWOULDBLOCK;
 3220088:	00bffd44 	movi	r2,-11
 322008c:	e0bfff15 	stw	r2,-4(fp)
 3220090:	00000206 	br	322009c <altera_avalon_jtag_uart_write+0x2c4>
  else
    return -EIO; /* Host not connected */
 3220094:	00bffec4 	movi	r2,-5
 3220098:	e0bfff15 	stw	r2,-4(fp)
 322009c:	e0bfff17 	ldw	r2,-4(fp)
}
 32200a0:	e037883a 	mov	sp,fp
 32200a4:	dfc00117 	ldw	ra,4(sp)
 32200a8:	df000017 	ldw	fp,0(sp)
 32200ac:	dec00204 	addi	sp,sp,8
 32200b0:	f800283a 	ret

032200b4 <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(altera_avalon_lcd_16207_state* sp, 
  unsigned char command)
{
 32200b4:	defffa04 	addi	sp,sp,-24
 32200b8:	dfc00515 	stw	ra,20(sp)
 32200bc:	df000415 	stw	fp,16(sp)
 32200c0:	df000404 	addi	fp,sp,16
 32200c4:	e13ffe15 	stw	r4,-8(fp)
 32200c8:	e17fff05 	stb	r5,-4(fp)
  unsigned int base = sp->base;
 32200cc:	e0bffe17 	ldw	r2,-8(fp)
 32200d0:	10800017 	ldw	r2,0(r2)
 32200d4:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 32200d8:	008003f4 	movhi	r2,15
 32200dc:	10909004 	addi	r2,r2,16960
 32200e0:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 32200e4:	e0bffe17 	ldw	r2,-8(fp)
 32200e8:	10800803 	ldbu	r2,32(r2)
 32200ec:	10803fcc 	andi	r2,r2,255
 32200f0:	1080201c 	xori	r2,r2,128
 32200f4:	10bfe004 	addi	r2,r2,-128
 32200f8:	1004c03a 	cmpne	r2,r2,zero
 32200fc:	1000161e 	bne	r2,zero,3220158 <lcd_write_command+0xa4>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 3220100:	00000a06 	br	322012c <lcd_write_command+0x78>
    if (--i == 0)
 3220104:	e0bffc17 	ldw	r2,-16(fp)
 3220108:	10bfffc4 	addi	r2,r2,-1
 322010c:	e0bffc15 	stw	r2,-16(fp)
 3220110:	e0bffc17 	ldw	r2,-16(fp)
 3220114:	1004c03a 	cmpne	r2,r2,zero
 3220118:	1000041e 	bne	r2,zero,322012c <lcd_write_command+0x78>
    {
      sp->broken = 1;
 322011c:	e0fffe17 	ldw	r3,-8(fp)
 3220120:	00800044 	movi	r2,1
 3220124:	18800805 	stb	r2,32(r3)
      return;
 3220128:	00000b06 	br	3220158 <lcd_write_command+0xa4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 322012c:	e0bffd17 	ldw	r2,-12(fp)
 3220130:	10800104 	addi	r2,r2,4
 3220134:	10800037 	ldwio	r2,0(r2)
 3220138:	1080200c 	andi	r2,r2,128
 322013c:	1004c03a 	cmpne	r2,r2,zero
 3220140:	103ff01e 	bne	r2,zero,3220104 <lcd_write_command+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 3220144:	01001904 	movi	r4,100
 3220148:	323ae680 	call	323ae68 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
 322014c:	e0bffd17 	ldw	r2,-12(fp)
 3220150:	e0ffff03 	ldbu	r3,-4(fp)
 3220154:	10c00035 	stwio	r3,0(r2)
}
 3220158:	e037883a 	mov	sp,fp
 322015c:	dfc00117 	ldw	ra,4(sp)
 3220160:	df000017 	ldw	fp,0(sp)
 3220164:	dec00204 	addi	sp,sp,8
 3220168:	f800283a 	ret

0322016c <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(altera_avalon_lcd_16207_state* sp, 
  unsigned char data)
{
 322016c:	defffa04 	addi	sp,sp,-24
 3220170:	dfc00515 	stw	ra,20(sp)
 3220174:	df000415 	stw	fp,16(sp)
 3220178:	df000404 	addi	fp,sp,16
 322017c:	e13ffe15 	stw	r4,-8(fp)
 3220180:	e17fff05 	stb	r5,-4(fp)
  unsigned int base = sp->base;
 3220184:	e0bffe17 	ldw	r2,-8(fp)
 3220188:	10800017 	ldw	r2,0(r2)
 322018c:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 3220190:	008003f4 	movhi	r2,15
 3220194:	10909004 	addi	r2,r2,16960
 3220198:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 322019c:	e0bffe17 	ldw	r2,-8(fp)
 32201a0:	10800803 	ldbu	r2,32(r2)
 32201a4:	10803fcc 	andi	r2,r2,255
 32201a8:	1080201c 	xori	r2,r2,128
 32201ac:	10bfe004 	addi	r2,r2,-128
 32201b0:	1004c03a 	cmpne	r2,r2,zero
 32201b4:	10001d1e 	bne	r2,zero,322022c <lcd_write_data+0xc0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 32201b8:	00000a06 	br	32201e4 <lcd_write_data+0x78>
    if (--i == 0)
 32201bc:	e0bffc17 	ldw	r2,-16(fp)
 32201c0:	10bfffc4 	addi	r2,r2,-1
 32201c4:	e0bffc15 	stw	r2,-16(fp)
 32201c8:	e0bffc17 	ldw	r2,-16(fp)
 32201cc:	1004c03a 	cmpne	r2,r2,zero
 32201d0:	1000041e 	bne	r2,zero,32201e4 <lcd_write_data+0x78>
    {
      sp->broken = 1;
 32201d4:	e0fffe17 	ldw	r3,-8(fp)
 32201d8:	00800044 	movi	r2,1
 32201dc:	18800805 	stb	r2,32(r3)
      return;
 32201e0:	00001206 	br	322022c <lcd_write_data+0xc0>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 32201e4:	e0bffd17 	ldw	r2,-12(fp)
 32201e8:	10800104 	addi	r2,r2,4
 32201ec:	10800037 	ldwio	r2,0(r2)
 32201f0:	1080200c 	andi	r2,r2,128
 32201f4:	1004c03a 	cmpne	r2,r2,zero
 32201f8:	103ff01e 	bne	r2,zero,32201bc <lcd_write_data+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 32201fc:	01001904 	movi	r4,100
 3220200:	323ae680 	call	323ae68 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);
 3220204:	e0bffd17 	ldw	r2,-12(fp)
 3220208:	10800204 	addi	r2,r2,8
 322020c:	e0ffff03 	ldbu	r3,-4(fp)
 3220210:	10c00035 	stwio	r3,0(r2)

  sp->address++;
 3220214:	e0bffe17 	ldw	r2,-8(fp)
 3220218:	108008c3 	ldbu	r2,35(r2)
 322021c:	10800044 	addi	r2,r2,1
 3220220:	1007883a 	mov	r3,r2
 3220224:	e0bffe17 	ldw	r2,-8(fp)
 3220228:	10c008c5 	stb	r3,35(r2)
}
 322022c:	e037883a 	mov	sp,fp
 3220230:	dfc00117 	ldw	ra,4(sp)
 3220234:	df000017 	ldw	fp,0(sp)
 3220238:	dec00204 	addi	sp,sp,8
 322023c:	f800283a 	ret

03220240 <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(altera_avalon_lcd_16207_state* sp)
{
 3220240:	defffc04 	addi	sp,sp,-16
 3220244:	dfc00315 	stw	ra,12(sp)
 3220248:	df000215 	stw	fp,8(sp)
 322024c:	df000204 	addi	fp,sp,8
 3220250:	e13fff15 	stw	r4,-4(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
 3220254:	e13fff17 	ldw	r4,-4(fp)
 3220258:	01400044 	movi	r5,1
 322025c:	32200b40 	call	32200b4 <lcd_write_command>

  sp->x = 0;
 3220260:	e0bfff17 	ldw	r2,-4(fp)
 3220264:	10000845 	stb	zero,33(r2)
  sp->y = 0;
 3220268:	e0bfff17 	ldw	r2,-4(fp)
 322026c:	10000885 	stb	zero,34(r2)
  sp->address = 0;
 3220270:	e0bfff17 	ldw	r2,-4(fp)
 3220274:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 3220278:	e03ffe15 	stw	zero,-8(fp)
 322027c:	00001906 	br	32202e4 <lcd_clear_screen+0xa4>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
 3220280:	e0bffe17 	ldw	r2,-8(fp)
 3220284:	108018e4 	muli	r2,r2,99
 3220288:	10c01004 	addi	r3,r2,64
 322028c:	e0bfff17 	ldw	r2,-4(fp)
 3220290:	1889883a 	add	r4,r3,r2
 3220294:	01400804 	movi	r5,32
 3220298:	01801444 	movi	r6,81
 322029c:	320694c0 	call	320694c <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
 32202a0:	e0bffe17 	ldw	r2,-8(fp)
 32202a4:	108018e4 	muli	r2,r2,99
 32202a8:	10c00c04 	addi	r3,r2,48
 32202ac:	e0bfff17 	ldw	r2,-4(fp)
 32202b0:	1889883a 	add	r4,r3,r2
 32202b4:	01400804 	movi	r5,32
 32202b8:	01800404 	movi	r6,16
 32202bc:	320694c0 	call	320694c <memset>
    sp->line[y].width = 0;
 32202c0:	e0bffe17 	ldw	r2,-8(fp)
 32202c4:	e0ffff17 	ldw	r3,-4(fp)
 32202c8:	108018e4 	muli	r2,r2,99
 32202cc:	10c5883a 	add	r2,r2,r3
 32202d0:	10802404 	addi	r2,r2,144
 32202d4:	10000045 	stb	zero,1(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 32202d8:	e0bffe17 	ldw	r2,-8(fp)
 32202dc:	10800044 	addi	r2,r2,1
 32202e0:	e0bffe15 	stw	r2,-8(fp)
 32202e4:	e0bffe17 	ldw	r2,-8(fp)
 32202e8:	10800090 	cmplti	r2,r2,2
 32202ec:	103fe41e 	bne	r2,zero,3220280 <lcd_clear_screen+0x40>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
 32202f0:	e037883a 	mov	sp,fp
 32202f4:	dfc00117 	ldw	ra,4(sp)
 32202f8:	df000017 	ldw	fp,0(sp)
 32202fc:	dec00204 	addi	sp,sp,8
 3220300:	f800283a 	ret

03220304 <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(altera_avalon_lcd_16207_state* sp)
{
 3220304:	defff604 	addi	sp,sp,-40
 3220308:	dfc00915 	stw	ra,36(sp)
 322030c:	df000815 	stw	fp,32(sp)
 3220310:	dc000715 	stw	r16,28(sp)
 3220314:	df000704 	addi	fp,sp,28
 3220318:	e13fff15 	stw	r4,-4(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
 322031c:	e0bfff17 	ldw	r2,-4(fp)
 3220320:	10800943 	ldbu	r2,37(r2)
 3220324:	10803fcc 	andi	r2,r2,255
 3220328:	1080201c 	xori	r2,r2,128
 322032c:	10bfe004 	addi	r2,r2,-128
 3220330:	e0bffc15 	stw	r2,-16(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 3220334:	e03ffe15 	stw	zero,-8(fp)
 3220338:	00006406 	br	32204cc <lcd_repaint_screen+0x1c8>
  {
    int width  = sp->line[y].width;
 322033c:	e0bffe17 	ldw	r2,-8(fp)
 3220340:	e0ffff17 	ldw	r3,-4(fp)
 3220344:	108018e4 	muli	r2,r2,99
 3220348:	10c5883a 	add	r2,r2,r3
 322034c:	10802404 	addi	r2,r2,144
 3220350:	10800043 	ldbu	r2,1(r2)
 3220354:	10803fcc 	andi	r2,r2,255
 3220358:	1080201c 	xori	r2,r2,128
 322035c:	10bfe004 	addi	r2,r2,-128
 3220360:	e0bffb15 	stw	r2,-20(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
 3220364:	e0bffe17 	ldw	r2,-8(fp)
 3220368:	e0ffff17 	ldw	r3,-4(fp)
 322036c:	108018e4 	muli	r2,r2,99
 3220370:	10c5883a 	add	r2,r2,r3
 3220374:	10802404 	addi	r2,r2,144
 3220378:	10800083 	ldbu	r2,2(r2)
 322037c:	10c03fcc 	andi	r3,r2,255
 3220380:	e0bffc17 	ldw	r2,-16(fp)
 3220384:	1885383a 	mul	r2,r3,r2
 3220388:	1005d23a 	srai	r2,r2,8
 322038c:	e0bffa15 	stw	r2,-24(fp)
    if (offset >= width)
 3220390:	e0fffa17 	ldw	r3,-24(fp)
 3220394:	e0bffb17 	ldw	r2,-20(fp)
 3220398:	18800116 	blt	r3,r2,32203a0 <lcd_repaint_screen+0x9c>
      offset = 0;
 322039c:	e03ffa15 	stw	zero,-24(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 32203a0:	e03ffd15 	stw	zero,-12(fp)
 32203a4:	00004306 	br	32204b4 <lcd_repaint_screen+0x1b0>
    {
      char c = sp->line[y].data[(x + offset) % width];
 32203a8:	e43ffe17 	ldw	r16,-8(fp)
 32203ac:	e0fffd17 	ldw	r3,-12(fp)
 32203b0:	e0bffa17 	ldw	r2,-24(fp)
 32203b4:	1889883a 	add	r4,r3,r2
 32203b8:	e17ffb17 	ldw	r5,-20(fp)
 32203bc:	320445c0 	call	320445c <__modsi3>
 32203c0:	1009883a 	mov	r4,r2
 32203c4:	e0ffff17 	ldw	r3,-4(fp)
 32203c8:	808018e4 	muli	r2,r16,99
 32203cc:	10c5883a 	add	r2,r2,r3
 32203d0:	1105883a 	add	r2,r2,r4
 32203d4:	10801004 	addi	r2,r2,64
 32203d8:	10800003 	ldbu	r2,0(r2)
 32203dc:	e0bff945 	stb	r2,-27(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
 32203e0:	e0bffe17 	ldw	r2,-8(fp)
 32203e4:	e13ffd17 	ldw	r4,-12(fp)
 32203e8:	e0ffff17 	ldw	r3,-4(fp)
 32203ec:	108018e4 	muli	r2,r2,99
 32203f0:	10c5883a 	add	r2,r2,r3
 32203f4:	1105883a 	add	r2,r2,r4
 32203f8:	10800c04 	addi	r2,r2,48
 32203fc:	10800003 	ldbu	r2,0(r2)
 3220400:	10c03fcc 	andi	r3,r2,255
 3220404:	18c0201c 	xori	r3,r3,128
 3220408:	18ffe004 	addi	r3,r3,-128
 322040c:	e0bff947 	ldb	r2,-27(fp)
 3220410:	18802526 	beq	r3,r2,32204a8 <lcd_repaint_screen+0x1a4>
      {
        unsigned char address = x + colstart[y];
 3220414:	e0fffe17 	ldw	r3,-8(fp)
 3220418:	d0a02904 	addi	r2,gp,-32604
 322041c:	1885883a 	add	r2,r3,r2
 3220420:	10800003 	ldbu	r2,0(r2)
 3220424:	1007883a 	mov	r3,r2
 3220428:	e0bffd17 	ldw	r2,-12(fp)
 322042c:	1885883a 	add	r2,r3,r2
 3220430:	e0bff905 	stb	r2,-28(fp)

        if (address != sp->address)
 3220434:	e0fff903 	ldbu	r3,-28(fp)
 3220438:	e0bfff17 	ldw	r2,-4(fp)
 322043c:	108008c3 	ldbu	r2,35(r2)
 3220440:	10803fcc 	andi	r2,r2,255
 3220444:	1080201c 	xori	r2,r2,128
 3220448:	10bfe004 	addi	r2,r2,-128
 322044c:	18800926 	beq	r3,r2,3220474 <lcd_repaint_screen+0x170>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
 3220450:	e0fff903 	ldbu	r3,-28(fp)
 3220454:	00bfe004 	movi	r2,-128
 3220458:	1884b03a 	or	r2,r3,r2
 322045c:	11403fcc 	andi	r5,r2,255
 3220460:	e13fff17 	ldw	r4,-4(fp)
 3220464:	32200b40 	call	32200b4 <lcd_write_command>
          sp->address = address;
 3220468:	e0fff903 	ldbu	r3,-28(fp)
 322046c:	e0bfff17 	ldw	r2,-4(fp)
 3220470:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
 3220474:	e0bff943 	ldbu	r2,-27(fp)
 3220478:	11403fcc 	andi	r5,r2,255
 322047c:	e13fff17 	ldw	r4,-4(fp)
 3220480:	322016c0 	call	322016c <lcd_write_data>
        sp->line[y].visible[x] = c;
 3220484:	e0bffe17 	ldw	r2,-8(fp)
 3220488:	e13ffd17 	ldw	r4,-12(fp)
 322048c:	e0ffff17 	ldw	r3,-4(fp)
 3220490:	108018e4 	muli	r2,r2,99
 3220494:	10c5883a 	add	r2,r2,r3
 3220498:	1105883a 	add	r2,r2,r4
 322049c:	10c00c04 	addi	r3,r2,48
 32204a0:	e0bff943 	ldbu	r2,-27(fp)
 32204a4:	18800005 	stb	r2,0(r3)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 32204a8:	e0bffd17 	ldw	r2,-12(fp)
 32204ac:	10800044 	addi	r2,r2,1
 32204b0:	e0bffd15 	stw	r2,-12(fp)
 32204b4:	e0bffd17 	ldw	r2,-12(fp)
 32204b8:	10800410 	cmplti	r2,r2,16
 32204bc:	103fba1e 	bne	r2,zero,32203a8 <lcd_repaint_screen+0xa4>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 32204c0:	e0bffe17 	ldw	r2,-8(fp)
 32204c4:	10800044 	addi	r2,r2,1
 32204c8:	e0bffe15 	stw	r2,-8(fp)
 32204cc:	e0bffe17 	ldw	r2,-8(fp)
 32204d0:	10800090 	cmplti	r2,r2,2
 32204d4:	103f991e 	bne	r2,zero,322033c <lcd_repaint_screen+0x38>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
 32204d8:	e037883a 	mov	sp,fp
 32204dc:	dfc00217 	ldw	ra,8(sp)
 32204e0:	df000117 	ldw	fp,4(sp)
 32204e4:	dc000017 	ldw	r16,0(sp)
 32204e8:	dec00304 	addi	sp,sp,12
 32204ec:	f800283a 	ret

032204f0 <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
 32204f0:	defffc04 	addi	sp,sp,-16
 32204f4:	dfc00315 	stw	ra,12(sp)
 32204f8:	df000215 	stw	fp,8(sp)
 32204fc:	df000204 	addi	fp,sp,8
 3220500:	e13fff15 	stw	r4,-4(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 3220504:	e03ffe15 	stw	zero,-8(fp)
 3220508:	00001d06 	br	3220580 <lcd_scroll_up+0x90>
  {
    if (y < ALT_LCD_HEIGHT-1)
 322050c:	e0bffe17 	ldw	r2,-8(fp)
 3220510:	10800048 	cmpgei	r2,r2,1
 3220514:	10000f1e 	bne	r2,zero,3220554 <lcd_scroll_up+0x64>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
 3220518:	e0bffe17 	ldw	r2,-8(fp)
 322051c:	108018e4 	muli	r2,r2,99
 3220520:	10c01004 	addi	r3,r2,64
 3220524:	e0bfff17 	ldw	r2,-4(fp)
 3220528:	1889883a 	add	r4,r3,r2
 322052c:	e0bffe17 	ldw	r2,-8(fp)
 3220530:	10800044 	addi	r2,r2,1
 3220534:	108018e4 	muli	r2,r2,99
 3220538:	10c01004 	addi	r3,r2,64
 322053c:	e0bfff17 	ldw	r2,-4(fp)
 3220540:	1885883a 	add	r2,r3,r2
 3220544:	100b883a 	mov	r5,r2
 3220548:	01801404 	movi	r6,80
 322054c:	32067cc0 	call	32067cc <memcpy>
 3220550:	00000806 	br	3220574 <lcd_scroll_up+0x84>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
 3220554:	e0bffe17 	ldw	r2,-8(fp)
 3220558:	108018e4 	muli	r2,r2,99
 322055c:	10c01004 	addi	r3,r2,64
 3220560:	e0bfff17 	ldw	r2,-4(fp)
 3220564:	1889883a 	add	r4,r3,r2
 3220568:	01400804 	movi	r5,32
 322056c:	01801404 	movi	r6,80
 3220570:	320694c0 	call	320694c <memset>

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 3220574:	e0bffe17 	ldw	r2,-8(fp)
 3220578:	10800044 	addi	r2,r2,1
 322057c:	e0bffe15 	stw	r2,-8(fp)
 3220580:	e0bffe17 	ldw	r2,-8(fp)
 3220584:	10800090 	cmplti	r2,r2,2
 3220588:	103fe01e 	bne	r2,zero,322050c <lcd_scroll_up+0x1c>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
 322058c:	e0bfff17 	ldw	r2,-4(fp)
 3220590:	10800883 	ldbu	r2,34(r2)
 3220594:	10bfffc4 	addi	r2,r2,-1
 3220598:	1007883a 	mov	r3,r2
 322059c:	e0bfff17 	ldw	r2,-4(fp)
 32205a0:	10c00885 	stb	r3,34(r2)
}
 32205a4:	e037883a 	mov	sp,fp
 32205a8:	dfc00117 	ldw	ra,4(sp)
 32205ac:	df000017 	ldw	fp,0(sp)
 32205b0:	dec00204 	addi	sp,sp,8
 32205b4:	f800283a 	ret

032205b8 <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(altera_avalon_lcd_16207_state* sp, char c)
{
 32205b8:	defff804 	addi	sp,sp,-32
 32205bc:	dfc00715 	stw	ra,28(sp)
 32205c0:	df000615 	stw	fp,24(sp)
 32205c4:	df000604 	addi	fp,sp,24
 32205c8:	e13ffd15 	stw	r4,-12(fp)
 32205cc:	e17ffe05 	stb	r5,-8(fp)
  int parm1 = 0, parm2 = 0;
 32205d0:	e03ffc15 	stw	zero,-16(fp)
 32205d4:	e03ffb15 	stw	zero,-20(fp)

  if (sp->escape[0] == '[')
 32205d8:	e0bffd17 	ldw	r2,-12(fp)
 32205dc:	10800a03 	ldbu	r2,40(r2)
 32205e0:	10803fcc 	andi	r2,r2,255
 32205e4:	1080201c 	xori	r2,r2,128
 32205e8:	10bfe004 	addi	r2,r2,-128
 32205ec:	108016d8 	cmpnei	r2,r2,91
 32205f0:	1000491e 	bne	r2,zero,3220718 <lcd_handle_escape+0x160>
  {
    char * ptr = sp->escape+1;
 32205f4:	e0bffd17 	ldw	r2,-12(fp)
 32205f8:	10800a04 	addi	r2,r2,40
 32205fc:	10800044 	addi	r2,r2,1
 3220600:	e0bffa15 	stw	r2,-24(fp)
    while (isdigit(*ptr))
 3220604:	00000d06 	br	322063c <lcd_handle_escape+0x84>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
 3220608:	e0bffc17 	ldw	r2,-16(fp)
 322060c:	10c002a4 	muli	r3,r2,10
 3220610:	e0bffa17 	ldw	r2,-24(fp)
 3220614:	10800003 	ldbu	r2,0(r2)
 3220618:	10803fcc 	andi	r2,r2,255
 322061c:	1080201c 	xori	r2,r2,128
 3220620:	10bfe004 	addi	r2,r2,-128
 3220624:	1885883a 	add	r2,r3,r2
 3220628:	10bff404 	addi	r2,r2,-48
 322062c:	e0bffc15 	stw	r2,-16(fp)
 3220630:	e0bffa17 	ldw	r2,-24(fp)
 3220634:	10800044 	addi	r2,r2,1
 3220638:	e0bffa15 	stw	r2,-24(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
 322063c:	e0bffa17 	ldw	r2,-24(fp)
 3220640:	10800003 	ldbu	r2,0(r2)
 3220644:	10803fcc 	andi	r2,r2,255
 3220648:	1080201c 	xori	r2,r2,128
 322064c:	10bfe004 	addi	r2,r2,-128
 3220650:	1007883a 	mov	r3,r2
 3220654:	0080c974 	movhi	r2,805
 3220658:	10897704 	addi	r2,r2,9692
 322065c:	10800017 	ldw	r2,0(r2)
 3220660:	1885883a 	add	r2,r3,r2
 3220664:	10800003 	ldbu	r2,0(r2)
 3220668:	10803fcc 	andi	r2,r2,255
 322066c:	1080010c 	andi	r2,r2,4
 3220670:	1004c03a 	cmpne	r2,r2,zero
 3220674:	103fe41e 	bne	r2,zero,3220608 <lcd_handle_escape+0x50>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
 3220678:	e0bffa17 	ldw	r2,-24(fp)
 322067c:	10800003 	ldbu	r2,0(r2)
 3220680:	10803fcc 	andi	r2,r2,255
 3220684:	1080201c 	xori	r2,r2,128
 3220688:	10bfe004 	addi	r2,r2,-128
 322068c:	10800ed8 	cmpnei	r2,r2,59
 3220690:	1000231e 	bne	r2,zero,3220720 <lcd_handle_escape+0x168>
    {
      ptr++;
 3220694:	e0bffa17 	ldw	r2,-24(fp)
 3220698:	10800044 	addi	r2,r2,1
 322069c:	e0bffa15 	stw	r2,-24(fp)
      while (isdigit(*ptr))
 32206a0:	00000d06 	br	32206d8 <lcd_handle_escape+0x120>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
 32206a4:	e0bffb17 	ldw	r2,-20(fp)
 32206a8:	10c002a4 	muli	r3,r2,10
 32206ac:	e0bffa17 	ldw	r2,-24(fp)
 32206b0:	10800003 	ldbu	r2,0(r2)
 32206b4:	10803fcc 	andi	r2,r2,255
 32206b8:	1080201c 	xori	r2,r2,128
 32206bc:	10bfe004 	addi	r2,r2,-128
 32206c0:	1885883a 	add	r2,r3,r2
 32206c4:	10bff404 	addi	r2,r2,-48
 32206c8:	e0bffb15 	stw	r2,-20(fp)
 32206cc:	e0bffa17 	ldw	r2,-24(fp)
 32206d0:	10800044 	addi	r2,r2,1
 32206d4:	e0bffa15 	stw	r2,-24(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
 32206d8:	e0bffa17 	ldw	r2,-24(fp)
 32206dc:	10800003 	ldbu	r2,0(r2)
 32206e0:	10803fcc 	andi	r2,r2,255
 32206e4:	1080201c 	xori	r2,r2,128
 32206e8:	10bfe004 	addi	r2,r2,-128
 32206ec:	1007883a 	mov	r3,r2
 32206f0:	0080c974 	movhi	r2,805
 32206f4:	10897704 	addi	r2,r2,9692
 32206f8:	10800017 	ldw	r2,0(r2)
 32206fc:	1885883a 	add	r2,r3,r2
 3220700:	10800003 	ldbu	r2,0(r2)
 3220704:	10803fcc 	andi	r2,r2,255
 3220708:	1080010c 	andi	r2,r2,4
 322070c:	1004c03a 	cmpne	r2,r2,zero
 3220710:	103fe41e 	bne	r2,zero,32206a4 <lcd_handle_escape+0xec>
 3220714:	00000206 	br	3220720 <lcd_handle_escape+0x168>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
 3220718:	00bfffc4 	movi	r2,-1
 322071c:	e0bffc15 	stw	r2,-16(fp)

  switch (c)
 3220720:	e0bffe07 	ldb	r2,-8(fp)
 3220724:	e0bfff15 	stw	r2,-4(fp)
 3220728:	e0ffff17 	ldw	r3,-4(fp)
 322072c:	188012a0 	cmpeqi	r2,r3,74
 3220730:	10002f1e 	bne	r2,zero,32207f0 <lcd_handle_escape+0x238>
 3220734:	e0ffff17 	ldw	r3,-4(fp)
 3220738:	188012c8 	cmpgei	r2,r3,75
 322073c:	1000041e 	bne	r2,zero,3220750 <lcd_handle_escape+0x198>
 3220740:	e0ffff17 	ldw	r3,-4(fp)
 3220744:	18801220 	cmpeqi	r2,r3,72
 3220748:	1000081e 	bne	r2,zero,322076c <lcd_handle_escape+0x1b4>
 322074c:	00004906 	br	3220874 <lcd_handle_escape+0x2bc>
 3220750:	e0ffff17 	ldw	r3,-4(fp)
 3220754:	188012e0 	cmpeqi	r2,r3,75
 3220758:	10002b1e 	bne	r2,zero,3220808 <lcd_handle_escape+0x250>
 322075c:	e0ffff17 	ldw	r3,-4(fp)
 3220760:	188019a0 	cmpeqi	r2,r3,102
 3220764:	1000011e 	bne	r2,zero,322076c <lcd_handle_escape+0x1b4>
 3220768:	00004206 	br	3220874 <lcd_handle_escape+0x2bc>
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
 322076c:	e0bffb17 	ldw	r2,-20(fp)
 3220770:	10800050 	cmplti	r2,r2,1
 3220774:	1000051e 	bne	r2,zero,322078c <lcd_handle_escape+0x1d4>
      sp->x = parm2 - 1;
 3220778:	e0bffb17 	ldw	r2,-20(fp)
 322077c:	10bfffc4 	addi	r2,r2,-1
 3220780:	1007883a 	mov	r3,r2
 3220784:	e0bffd17 	ldw	r2,-12(fp)
 3220788:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
 322078c:	e0bffc17 	ldw	r2,-16(fp)
 3220790:	10800050 	cmplti	r2,r2,1
 3220794:	1000371e 	bne	r2,zero,3220874 <lcd_handle_escape+0x2bc>
    {
      sp->y = parm1 - 1;
 3220798:	e0bffc17 	ldw	r2,-16(fp)
 322079c:	10bfffc4 	addi	r2,r2,-1
 32207a0:	1007883a 	mov	r3,r2
 32207a4:	e0bffd17 	ldw	r2,-12(fp)
 32207a8:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
 32207ac:	e0bffd17 	ldw	r2,-12(fp)
 32207b0:	10800883 	ldbu	r2,34(r2)
 32207b4:	10803fcc 	andi	r2,r2,255
 32207b8:	10800170 	cmpltui	r2,r2,5
 32207bc:	1000061e 	bne	r2,zero,32207d8 <lcd_handle_escape+0x220>
        sp->y = ALT_LCD_HEIGHT * 2;
 32207c0:	e0fffd17 	ldw	r3,-12(fp)
 32207c4:	00800104 	movi	r2,4
 32207c8:	18800885 	stb	r2,34(r3)
      while (sp->y > ALT_LCD_HEIGHT)
 32207cc:	00000206 	br	32207d8 <lcd_handle_escape+0x220>
        lcd_scroll_up(sp);
 32207d0:	e13ffd17 	ldw	r4,-12(fp)
 32207d4:	32204f00 	call	32204f0 <lcd_scroll_up>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
 32207d8:	e0bffd17 	ldw	r2,-12(fp)
 32207dc:	10800883 	ldbu	r2,34(r2)
 32207e0:	10803fcc 	andi	r2,r2,255
 32207e4:	108000e8 	cmpgeui	r2,r2,3
 32207e8:	103ff91e 	bne	r2,zero,32207d0 <lcd_handle_escape+0x218>
        lcd_scroll_up(sp);
    }
    break;
 32207ec:	00002106 	br	3220874 <lcd_handle_escape+0x2bc>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
 32207f0:	e0bffc17 	ldw	r2,-16(fp)
 32207f4:	10800098 	cmpnei	r2,r2,2
 32207f8:	10001e1e 	bne	r2,zero,3220874 <lcd_handle_escape+0x2bc>
      lcd_clear_screen(sp);
 32207fc:	e13ffd17 	ldw	r4,-12(fp)
 3220800:	32202400 	call	3220240 <lcd_clear_screen>
    break;
 3220804:	00001b06 	br	3220874 <lcd_handle_escape+0x2bc>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
 3220808:	e0bffc17 	ldw	r2,-16(fp)
 322080c:	10800048 	cmpgei	r2,r2,1
 3220810:	1000181e 	bne	r2,zero,3220874 <lcd_handle_escape+0x2bc>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 3220814:	e0bffd17 	ldw	r2,-12(fp)
 3220818:	10800843 	ldbu	r2,33(r2)
 322081c:	10803fcc 	andi	r2,r2,255
 3220820:	10801428 	cmpgeui	r2,r2,80
 3220824:	1000131e 	bne	r2,zero,3220874 <lcd_handle_escape+0x2bc>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
 3220828:	e0bffd17 	ldw	r2,-12(fp)
 322082c:	10800883 	ldbu	r2,34(r2)
 3220830:	10803fcc 	andi	r2,r2,255
 3220834:	108018e4 	muli	r2,r2,99
 3220838:	10c01004 	addi	r3,r2,64
 322083c:	e0bffd17 	ldw	r2,-12(fp)
 3220840:	1887883a 	add	r3,r3,r2
 3220844:	e0bffd17 	ldw	r2,-12(fp)
 3220848:	10800843 	ldbu	r2,33(r2)
 322084c:	10803fcc 	andi	r2,r2,255
 3220850:	1889883a 	add	r4,r3,r2
 3220854:	e0bffd17 	ldw	r2,-12(fp)
 3220858:	10800843 	ldbu	r2,33(r2)
 322085c:	10c03fcc 	andi	r3,r2,255
 3220860:	00801404 	movi	r2,80
 3220864:	10c5c83a 	sub	r2,r2,r3
 3220868:	100d883a 	mov	r6,r2
 322086c:	01400804 	movi	r5,32
 3220870:	320694c0 	call	320694c <memset>
    }
    break;
  }
}
 3220874:	e037883a 	mov	sp,fp
 3220878:	dfc00117 	ldw	ra,4(sp)
 322087c:	df000017 	ldw	fp,0(sp)
 3220880:	dec00204 	addi	sp,sp,8
 3220884:	f800283a 	ret

03220888 <altera_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp, 
  const char* ptr, int len, int flags)
{
 3220888:	deffef04 	addi	sp,sp,-68
 322088c:	dfc01015 	stw	ra,64(sp)
 3220890:	df000f15 	stw	fp,60(sp)
 3220894:	dc000e15 	stw	r16,56(sp)
 3220898:	df000e04 	addi	fp,sp,56
 322089c:	e13ffc15 	stw	r4,-16(fp)
 32208a0:	e17ffd15 	stw	r5,-12(fp)
 32208a4:	e1bffe15 	stw	r6,-8(fp)
 32208a8:	e1ffff15 	stw	r7,-4(fp)
  const char* end = ptr + len;
 32208ac:	e0bffe17 	ldw	r2,-8(fp)
 32208b0:	1007883a 	mov	r3,r2
 32208b4:	e0bffd17 	ldw	r2,-12(fp)
 32208b8:	10c5883a 	add	r2,r2,r3
 32208bc:	e0bffa15 	stw	r2,-24(fp)

  /* When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
 32208c0:	e0bffc17 	ldw	r2,-16(fp)
 32208c4:	10803e17 	ldw	r2,248(r2)
 32208c8:	e0bff215 	stw	r2,-56(fp)
 32208cc:	e03ff30d 	sth	zero,-52(fp)
 32208d0:	e17ff30b 	ldhu	r5,-52(fp)
 32208d4:	e1bffb04 	addi	r6,fp,-20
 32208d8:	e13ff217 	ldw	r4,-56(fp)
 32208dc:	321ade40 	call	321ade4 <OSSemPend>

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
 32208e0:	e0fffc17 	ldw	r3,-16(fp)
 32208e4:	00800044 	movi	r2,1
 32208e8:	188009c5 	stb	r2,39(r3)

  for ( ; ptr < end ; ptr++)
 32208ec:	0000a206 	br	3220b78 <altera_avalon_lcd_16207_write+0x2f0>
  {
    char c = *ptr;
 32208f0:	e0bffd17 	ldw	r2,-12(fp)
 32208f4:	10800003 	ldbu	r2,0(r2)
 32208f8:	e0bff705 	stb	r2,-36(fp)

    if (sp->esccount >= 0)
 32208fc:	e0bffc17 	ldw	r2,-16(fp)
 3220900:	10800903 	ldbu	r2,36(r2)
 3220904:	10803fcc 	andi	r2,r2,255
 3220908:	1080201c 	xori	r2,r2,128
 322090c:	10bfe004 	addi	r2,r2,-128
 3220910:	1004803a 	cmplt	r2,r2,zero
 3220914:	10003b1e 	bne	r2,zero,3220a04 <altera_avalon_lcd_16207_write+0x17c>
    {
      unsigned int esccount = sp->esccount;
 3220918:	e0bffc17 	ldw	r2,-16(fp)
 322091c:	10800903 	ldbu	r2,36(r2)
 3220920:	10803fcc 	andi	r2,r2,255
 3220924:	1080201c 	xori	r2,r2,128
 3220928:	10bfe004 	addi	r2,r2,-128
 322092c:	e0bff615 	stw	r2,-40(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 3220930:	e0bff617 	ldw	r2,-40(fp)
 3220934:	1004c03a 	cmpne	r2,r2,zero
 3220938:	1000031e 	bne	r2,zero,3220948 <altera_avalon_lcd_16207_write+0xc0>
 322093c:	e0bff707 	ldb	r2,-36(fp)
 3220940:	108016d8 	cmpnei	r2,r2,91
 3220944:	1000111e 	bne	r2,zero,322098c <altera_avalon_lcd_16207_write+0x104>
 3220948:	e0bff617 	ldw	r2,-40(fp)
 322094c:	1005003a 	cmpeq	r2,r2,zero
 3220950:	10001a1e 	bne	r2,zero,32209bc <altera_avalon_lcd_16207_write+0x134>
 3220954:	e0bff707 	ldb	r2,-36(fp)
 3220958:	1007883a 	mov	r3,r2
 322095c:	0080c974 	movhi	r2,805
 3220960:	10897704 	addi	r2,r2,9692
 3220964:	10800017 	ldw	r2,0(r2)
 3220968:	1885883a 	add	r2,r3,r2
 322096c:	10800003 	ldbu	r2,0(r2)
 3220970:	10803fcc 	andi	r2,r2,255
 3220974:	1080010c 	andi	r2,r2,4
 3220978:	1004c03a 	cmpne	r2,r2,zero
 322097c:	10000f1e 	bne	r2,zero,32209bc <altera_avalon_lcd_16207_write+0x134>
 3220980:	e0bff707 	ldb	r2,-36(fp)
 3220984:	10800ee0 	cmpeqi	r2,r2,59
 3220988:	10000c1e 	bne	r2,zero,32209bc <altera_avalon_lcd_16207_write+0x134>
          (esccount > 0 && !isdigit(c) && c != ';'))
      {
        sp->escape[esccount] = 0;
 322098c:	e0fff617 	ldw	r3,-40(fp)
 3220990:	e0bffc17 	ldw	r2,-16(fp)
 3220994:	1885883a 	add	r2,r3,r2
 3220998:	10800a04 	addi	r2,r2,40
 322099c:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
 32209a0:	e17ff707 	ldb	r5,-36(fp)
 32209a4:	e13ffc17 	ldw	r4,-16(fp)
 32209a8:	32205b80 	call	32205b8 <lcd_handle_escape>

        sp->esccount = -1;
 32209ac:	e0fffc17 	ldw	r3,-16(fp)
 32209b0:	00bfffc4 	movi	r2,-1
 32209b4:	18800905 	stb	r2,36(r3)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 32209b8:	00006c06 	br	3220b6c <altera_avalon_lcd_16207_write+0x2e4>

        lcd_handle_escape(sp, c);

        sp->esccount = -1;
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
 32209bc:	e0bffc17 	ldw	r2,-16(fp)
 32209c0:	10800903 	ldbu	r2,36(r2)
 32209c4:	10803fcc 	andi	r2,r2,255
 32209c8:	108001e8 	cmpgeui	r2,r2,7
 32209cc:	1000671e 	bne	r2,zero,3220b6c <altera_avalon_lcd_16207_write+0x2e4>
      {
        sp->escape[esccount] = c;
 32209d0:	e0fff617 	ldw	r3,-40(fp)
 32209d4:	e0bffc17 	ldw	r2,-16(fp)
 32209d8:	1885883a 	add	r2,r3,r2
 32209dc:	10c00a04 	addi	r3,r2,40
 32209e0:	e0bff703 	ldbu	r2,-36(fp)
 32209e4:	18800005 	stb	r2,0(r3)
        sp->esccount++;
 32209e8:	e0bffc17 	ldw	r2,-16(fp)
 32209ec:	10800903 	ldbu	r2,36(r2)
 32209f0:	10800044 	addi	r2,r2,1
 32209f4:	1007883a 	mov	r3,r2
 32209f8:	e0bffc17 	ldw	r2,-16(fp)
 32209fc:	10c00905 	stb	r3,36(r2)
 3220a00:	00005a06 	br	3220b6c <altera_avalon_lcd_16207_write+0x2e4>
      }
    }
    else if (c == 27) /* ESC */
 3220a04:	e0bff707 	ldb	r2,-36(fp)
 3220a08:	108006d8 	cmpnei	r2,r2,27
 3220a0c:	1000031e 	bne	r2,zero,3220a1c <altera_avalon_lcd_16207_write+0x194>
    {
      sp->esccount = 0;
 3220a10:	e0bffc17 	ldw	r2,-16(fp)
 3220a14:	10000905 	stb	zero,36(r2)
 3220a18:	00005406 	br	3220b6c <altera_avalon_lcd_16207_write+0x2e4>
    }
    else if (c == '\r')
 3220a1c:	e0bff707 	ldb	r2,-36(fp)
 3220a20:	10800358 	cmpnei	r2,r2,13
 3220a24:	1000031e 	bne	r2,zero,3220a34 <altera_avalon_lcd_16207_write+0x1ac>
    {
      sp->x = 0;
 3220a28:	e0bffc17 	ldw	r2,-16(fp)
 3220a2c:	10000845 	stb	zero,33(r2)
 3220a30:	00004e06 	br	3220b6c <altera_avalon_lcd_16207_write+0x2e4>
    }
    else if (c == '\n')
 3220a34:	e0bff707 	ldb	r2,-36(fp)
 3220a38:	10800298 	cmpnei	r2,r2,10
 3220a3c:	1000101e 	bne	r2,zero,3220a80 <altera_avalon_lcd_16207_write+0x1f8>
    {
      sp->x = 0;
 3220a40:	e0bffc17 	ldw	r2,-16(fp)
 3220a44:	10000845 	stb	zero,33(r2)
      sp->y++;
 3220a48:	e0bffc17 	ldw	r2,-16(fp)
 3220a4c:	10800883 	ldbu	r2,34(r2)
 3220a50:	10800044 	addi	r2,r2,1
 3220a54:	1007883a 	mov	r3,r2
 3220a58:	e0bffc17 	ldw	r2,-16(fp)
 3220a5c:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
 3220a60:	e0bffc17 	ldw	r2,-16(fp)
 3220a64:	10800883 	ldbu	r2,34(r2)
 3220a68:	10803fcc 	andi	r2,r2,255
 3220a6c:	108000f0 	cmpltui	r2,r2,3
 3220a70:	10003e1e 	bne	r2,zero,3220b6c <altera_avalon_lcd_16207_write+0x2e4>
        lcd_scroll_up(sp);
 3220a74:	e13ffc17 	ldw	r4,-16(fp)
 3220a78:	32204f00 	call	32204f0 <lcd_scroll_up>
 3220a7c:	00003b06 	br	3220b6c <altera_avalon_lcd_16207_write+0x2e4>
    }
    else if (c == '\b')
 3220a80:	e0bff707 	ldb	r2,-36(fp)
 3220a84:	10800218 	cmpnei	r2,r2,8
 3220a88:	10000c1e 	bne	r2,zero,3220abc <altera_avalon_lcd_16207_write+0x234>
    {
      if (sp->x > 0)
 3220a8c:	e0bffc17 	ldw	r2,-16(fp)
 3220a90:	10800843 	ldbu	r2,33(r2)
 3220a94:	10803fcc 	andi	r2,r2,255
 3220a98:	1005003a 	cmpeq	r2,r2,zero
 3220a9c:	1000331e 	bne	r2,zero,3220b6c <altera_avalon_lcd_16207_write+0x2e4>
        sp->x--;
 3220aa0:	e0bffc17 	ldw	r2,-16(fp)
 3220aa4:	10800843 	ldbu	r2,33(r2)
 3220aa8:	10bfffc4 	addi	r2,r2,-1
 3220aac:	1007883a 	mov	r3,r2
 3220ab0:	e0bffc17 	ldw	r2,-16(fp)
 3220ab4:	10c00845 	stb	r3,33(r2)
 3220ab8:	00002c06 	br	3220b6c <altera_avalon_lcd_16207_write+0x2e4>
    }
    else if (isprint(c))
 3220abc:	e0bff707 	ldb	r2,-36(fp)
 3220ac0:	1007883a 	mov	r3,r2
 3220ac4:	0080c974 	movhi	r2,805
 3220ac8:	10897704 	addi	r2,r2,9692
 3220acc:	10800017 	ldw	r2,0(r2)
 3220ad0:	1885883a 	add	r2,r3,r2
 3220ad4:	10800003 	ldbu	r2,0(r2)
 3220ad8:	10803fcc 	andi	r2,r2,255
 3220adc:	1080201c 	xori	r2,r2,128
 3220ae0:	10bfe004 	addi	r2,r2,-128
 3220ae4:	108025cc 	andi	r2,r2,151
 3220ae8:	1005003a 	cmpeq	r2,r2,zero
 3220aec:	10001f1e 	bne	r2,zero,3220b6c <altera_avalon_lcd_16207_write+0x2e4>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
 3220af0:	e0bffc17 	ldw	r2,-16(fp)
 3220af4:	10800883 	ldbu	r2,34(r2)
 3220af8:	10803fcc 	andi	r2,r2,255
 3220afc:	108000b0 	cmpltui	r2,r2,2
 3220b00:	1000021e 	bne	r2,zero,3220b0c <altera_avalon_lcd_16207_write+0x284>
        lcd_scroll_up(sp);
 3220b04:	e13ffc17 	ldw	r4,-16(fp)
 3220b08:	32204f00 	call	32204f0 <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 3220b0c:	e0bffc17 	ldw	r2,-16(fp)
 3220b10:	10800843 	ldbu	r2,33(r2)
 3220b14:	10803fcc 	andi	r2,r2,255
 3220b18:	10801428 	cmpgeui	r2,r2,80
 3220b1c:	10000d1e 	bne	r2,zero,3220b54 <altera_avalon_lcd_16207_write+0x2cc>
        sp->line[sp->y].data[sp->x] = c;
 3220b20:	e0bffc17 	ldw	r2,-16(fp)
 3220b24:	10800883 	ldbu	r2,34(r2)
 3220b28:	11003fcc 	andi	r4,r2,255
 3220b2c:	e0bffc17 	ldw	r2,-16(fp)
 3220b30:	10800843 	ldbu	r2,33(r2)
 3220b34:	11403fcc 	andi	r5,r2,255
 3220b38:	e0fffc17 	ldw	r3,-16(fp)
 3220b3c:	208018e4 	muli	r2,r4,99
 3220b40:	10c5883a 	add	r2,r2,r3
 3220b44:	1145883a 	add	r2,r2,r5
 3220b48:	10c01004 	addi	r3,r2,64
 3220b4c:	e0bff703 	ldbu	r2,-36(fp)
 3220b50:	18800005 	stb	r2,0(r3)

      sp->x++;
 3220b54:	e0bffc17 	ldw	r2,-16(fp)
 3220b58:	10800843 	ldbu	r2,33(r2)
 3220b5c:	10800044 	addi	r2,r2,1
 3220b60:	1007883a 	mov	r3,r2
 3220b64:	e0bffc17 	ldw	r2,-16(fp)
 3220b68:	10c00845 	stb	r3,33(r2)

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
 3220b6c:	e0bffd17 	ldw	r2,-12(fp)
 3220b70:	10800044 	addi	r2,r2,1
 3220b74:	e0bffd15 	stw	r2,-12(fp)
 3220b78:	e0fffd17 	ldw	r3,-12(fp)
 3220b7c:	e0bffa17 	ldw	r2,-24(fp)
 3220b80:	18bf5b36 	bltu	r3,r2,32208f0 <altera_avalon_lcd_16207_write+0x68>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
 3220b84:	00800404 	movi	r2,16
 3220b88:	e0bff815 	stw	r2,-32(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 3220b8c:	e03ff915 	stw	zero,-28(fp)
 3220b90:	00003606 	br	3220c6c <altera_avalon_lcd_16207_write+0x3e4>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 3220b94:	00801404 	movi	r2,80
 3220b98:	e0bff515 	stw	r2,-44(fp)
 3220b9c:	00001106 	br	3220be4 <altera_avalon_lcd_16207_write+0x35c>
      if (sp->line[y].data[width-1] != ' ')
 3220ba0:	e13ff917 	ldw	r4,-28(fp)
 3220ba4:	e0bff517 	ldw	r2,-44(fp)
 3220ba8:	117fffc4 	addi	r5,r2,-1
 3220bac:	e0fffc17 	ldw	r3,-16(fp)
 3220bb0:	208018e4 	muli	r2,r4,99
 3220bb4:	10c5883a 	add	r2,r2,r3
 3220bb8:	1145883a 	add	r2,r2,r5
 3220bbc:	10801004 	addi	r2,r2,64
 3220bc0:	10800003 	ldbu	r2,0(r2)
 3220bc4:	10803fcc 	andi	r2,r2,255
 3220bc8:	1080201c 	xori	r2,r2,128
 3220bcc:	10bfe004 	addi	r2,r2,-128
 3220bd0:	10800818 	cmpnei	r2,r2,32
 3220bd4:	1000061e 	bne	r2,zero,3220bf0 <altera_avalon_lcd_16207_write+0x368>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 3220bd8:	e0bff517 	ldw	r2,-44(fp)
 3220bdc:	10bfffc4 	addi	r2,r2,-1
 3220be0:	e0bff515 	stw	r2,-44(fp)
 3220be4:	e0bff517 	ldw	r2,-44(fp)
 3220be8:	10800048 	cmpgei	r2,r2,1
 3220bec:	103fec1e 	bne	r2,zero,3220ba0 <altera_avalon_lcd_16207_write+0x318>

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
 3220bf0:	e0bff517 	ldw	r2,-44(fp)
 3220bf4:	10800448 	cmpgei	r2,r2,17
 3220bf8:	1000031e 	bne	r2,zero,3220c08 <altera_avalon_lcd_16207_write+0x380>
      width = ALT_LCD_WIDTH;
 3220bfc:	00800404 	movi	r2,16
 3220c00:	e0bff515 	stw	r2,-44(fp)
 3220c04:	00000306 	br	3220c14 <altera_avalon_lcd_16207_write+0x38c>
    else
      width++;
 3220c08:	e0bff517 	ldw	r2,-44(fp)
 3220c0c:	10800044 	addi	r2,r2,1
 3220c10:	e0bff515 	stw	r2,-44(fp)

    sp->line[y].width = width;
 3220c14:	e13ff917 	ldw	r4,-28(fp)
 3220c18:	e0bff517 	ldw	r2,-44(fp)
 3220c1c:	100b883a 	mov	r5,r2
 3220c20:	e0fffc17 	ldw	r3,-16(fp)
 3220c24:	208018e4 	muli	r2,r4,99
 3220c28:	10c5883a 	add	r2,r2,r3
 3220c2c:	10802404 	addi	r2,r2,144
 3220c30:	11400045 	stb	r5,1(r2)
    if (widthmax < width)
 3220c34:	e0fff817 	ldw	r3,-32(fp)
 3220c38:	e0bff517 	ldw	r2,-44(fp)
 3220c3c:	1880020e 	bge	r3,r2,3220c48 <altera_avalon_lcd_16207_write+0x3c0>
      widthmax = width;
 3220c40:	e0bff517 	ldw	r2,-44(fp)
 3220c44:	e0bff815 	stw	r2,-32(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
 3220c48:	e0bff917 	ldw	r2,-28(fp)
 3220c4c:	e0fffc17 	ldw	r3,-16(fp)
 3220c50:	108018e4 	muli	r2,r2,99
 3220c54:	10c5883a 	add	r2,r2,r3
 3220c58:	10802404 	addi	r2,r2,144
 3220c5c:	10000085 	stb	zero,2(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 3220c60:	e0bff917 	ldw	r2,-28(fp)
 3220c64:	10800044 	addi	r2,r2,1
 3220c68:	e0bff915 	stw	r2,-28(fp)
 3220c6c:	e0bff917 	ldw	r2,-28(fp)
 3220c70:	10800090 	cmplti	r2,r2,2
 3220c74:	103fc71e 	bne	r2,zero,3220b94 <altera_avalon_lcd_16207_write+0x30c>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
 3220c78:	e0bff817 	ldw	r2,-32(fp)
 3220c7c:	10800448 	cmpgei	r2,r2,17
 3220c80:	1000031e 	bne	r2,zero,3220c90 <altera_avalon_lcd_16207_write+0x408>
    sp->scrollmax = 0;
 3220c84:	e0bffc17 	ldw	r2,-16(fp)
 3220c88:	10000985 	stb	zero,38(r2)
 3220c8c:	00002d06 	br	3220d44 <altera_avalon_lcd_16207_write+0x4bc>
  else
  {
    widthmax *= 2;
 3220c90:	e0bff817 	ldw	r2,-32(fp)
 3220c94:	1085883a 	add	r2,r2,r2
 3220c98:	e0bff815 	stw	r2,-32(fp)
    sp->scrollmax = widthmax;
 3220c9c:	e0bff817 	ldw	r2,-32(fp)
 3220ca0:	1007883a 	mov	r3,r2
 3220ca4:	e0bffc17 	ldw	r2,-16(fp)
 3220ca8:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 3220cac:	e03ff915 	stw	zero,-28(fp)
 3220cb0:	00002106 	br	3220d38 <altera_avalon_lcd_16207_write+0x4b0>
      if (sp->line[y].width > ALT_LCD_WIDTH)
 3220cb4:	e0bff917 	ldw	r2,-28(fp)
 3220cb8:	e0fffc17 	ldw	r3,-16(fp)
 3220cbc:	108018e4 	muli	r2,r2,99
 3220cc0:	10c5883a 	add	r2,r2,r3
 3220cc4:	10802404 	addi	r2,r2,144
 3220cc8:	10800043 	ldbu	r2,1(r2)
 3220ccc:	10803fcc 	andi	r2,r2,255
 3220cd0:	1080201c 	xori	r2,r2,128
 3220cd4:	10bfe004 	addi	r2,r2,-128
 3220cd8:	10800450 	cmplti	r2,r2,17
 3220cdc:	1000131e 	bne	r2,zero,3220d2c <altera_avalon_lcd_16207_write+0x4a4>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
 3220ce0:	e43ff917 	ldw	r16,-28(fp)
 3220ce4:	e0bff917 	ldw	r2,-28(fp)
 3220ce8:	e0fffc17 	ldw	r3,-16(fp)
 3220cec:	108018e4 	muli	r2,r2,99
 3220cf0:	10c5883a 	add	r2,r2,r3
 3220cf4:	10802404 	addi	r2,r2,144
 3220cf8:	10800043 	ldbu	r2,1(r2)
 3220cfc:	10803fcc 	andi	r2,r2,255
 3220d00:	1080201c 	xori	r2,r2,128
 3220d04:	10bfe004 	addi	r2,r2,-128
 3220d08:	1008923a 	slli	r4,r2,8
 3220d0c:	e17ff817 	ldw	r5,-32(fp)
 3220d10:	32043fc0 	call	32043fc <__divsi3>
 3220d14:	1009883a 	mov	r4,r2
 3220d18:	e0fffc17 	ldw	r3,-16(fp)
 3220d1c:	808018e4 	muli	r2,r16,99
 3220d20:	10c5883a 	add	r2,r2,r3
 3220d24:	10802404 	addi	r2,r2,144
 3220d28:	11000085 	stb	r4,2(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 3220d2c:	e0bff917 	ldw	r2,-28(fp)
 3220d30:	10800044 	addi	r2,r2,1
 3220d34:	e0bff915 	stw	r2,-28(fp)
 3220d38:	e0bff917 	ldw	r2,-28(fp)
 3220d3c:	10800090 	cmplti	r2,r2,2
 3220d40:	103fdc1e 	bne	r2,zero,3220cb4 <altera_avalon_lcd_16207_write+0x42c>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
 3220d44:	e0bffc17 	ldw	r2,-16(fp)
 3220d48:	10800943 	ldbu	r2,37(r2)
 3220d4c:	10803fcc 	andi	r2,r2,255
 3220d50:	1080201c 	xori	r2,r2,128
 3220d54:	10bfe004 	addi	r2,r2,-128
 3220d58:	e0bff415 	stw	r2,-48(fp)

    lcd_repaint_screen(sp);
 3220d5c:	e13ffc17 	ldw	r4,-16(fp)
 3220d60:	32203040 	call	3220304 <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
 3220d64:	e0bffc17 	ldw	r2,-16(fp)
 3220d68:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
 3220d6c:	e0bffc17 	ldw	r2,-16(fp)
 3220d70:	10800943 	ldbu	r2,37(r2)
 3220d74:	10c03fcc 	andi	r3,r2,255
 3220d78:	18c0201c 	xori	r3,r3,128
 3220d7c:	18ffe004 	addi	r3,r3,-128
 3220d80:	e0bff417 	ldw	r2,-48(fp)
 3220d84:	18800426 	beq	r3,r2,3220d98 <altera_avalon_lcd_16207_write+0x510>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
 3220d88:	e0fffc17 	ldw	r3,-16(fp)
 3220d8c:	00800044 	movi	r2,1
 3220d90:	188009c5 	stb	r2,39(r3)
  }
 3220d94:	003feb06 	br	3220d44 <altera_avalon_lcd_16207_write+0x4bc>

  /* Now that access to the display is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
 3220d98:	e0bffc17 	ldw	r2,-16(fp)
 3220d9c:	11003e17 	ldw	r4,248(r2)
 3220da0:	321b1dc0 	call	321b1dc <OSSemPost>

  return len;
 3220da4:	e0bffe17 	ldw	r2,-8(fp)
}
 3220da8:	e037883a 	mov	sp,fp
 3220dac:	dfc00217 	ldw	ra,8(sp)
 3220db0:	df000117 	ldw	fp,4(sp)
 3220db4:	dc000017 	ldw	r16,0(sp)
 3220db8:	dec00304 	addi	sp,sp,12
 3220dbc:	f800283a 	ret

03220dc0 <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context) 
{
 3220dc0:	defffc04 	addi	sp,sp,-16
 3220dc4:	dfc00315 	stw	ra,12(sp)
 3220dc8:	df000215 	stw	fp,8(sp)
 3220dcc:	df000204 	addi	fp,sp,8
 3220dd0:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_lcd_16207_state* sp = (altera_avalon_lcd_16207_state*)context;
 3220dd4:	e0bfff17 	ldw	r2,-4(fp)
 3220dd8:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
 3220ddc:	e0bffe17 	ldw	r2,-8(fp)
 3220de0:	10800943 	ldbu	r2,37(r2)
 3220de4:	10803fcc 	andi	r2,r2,255
 3220de8:	1080201c 	xori	r2,r2,128
 3220dec:	10bfe004 	addi	r2,r2,-128
 3220df0:	10c00044 	addi	r3,r2,1
 3220df4:	e0bffe17 	ldw	r2,-8(fp)
 3220df8:	10800983 	ldbu	r2,38(r2)
 3220dfc:	10803fcc 	andi	r2,r2,255
 3220e00:	1080201c 	xori	r2,r2,128
 3220e04:	10bfe004 	addi	r2,r2,-128
 3220e08:	18800316 	blt	r3,r2,3220e18 <alt_lcd_16207_timeout+0x58>
    sp->scrollpos = 0;
 3220e0c:	e0bffe17 	ldw	r2,-8(fp)
 3220e10:	10000945 	stb	zero,37(r2)
 3220e14:	00000606 	br	3220e30 <alt_lcd_16207_timeout+0x70>
  else
    sp->scrollpos = sp->scrollpos + 1;
 3220e18:	e0bffe17 	ldw	r2,-8(fp)
 3220e1c:	10800943 	ldbu	r2,37(r2)
 3220e20:	10800044 	addi	r2,r2,1
 3220e24:	1007883a 	mov	r3,r2
 3220e28:	e0bffe17 	ldw	r2,-8(fp)
 3220e2c:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
 3220e30:	e0bffe17 	ldw	r2,-8(fp)
 3220e34:	10800983 	ldbu	r2,38(r2)
 3220e38:	10803fcc 	andi	r2,r2,255
 3220e3c:	1080201c 	xori	r2,r2,128
 3220e40:	10bfe004 	addi	r2,r2,-128
 3220e44:	10800050 	cmplti	r2,r2,1
 3220e48:	1000091e 	bne	r2,zero,3220e70 <alt_lcd_16207_timeout+0xb0>
 3220e4c:	e0bffe17 	ldw	r2,-8(fp)
 3220e50:	108009c3 	ldbu	r2,39(r2)
 3220e54:	10803fcc 	andi	r2,r2,255
 3220e58:	1080201c 	xori	r2,r2,128
 3220e5c:	10bfe004 	addi	r2,r2,-128
 3220e60:	1004c03a 	cmpne	r2,r2,zero
 3220e64:	1000021e 	bne	r2,zero,3220e70 <alt_lcd_16207_timeout+0xb0>
    lcd_repaint_screen(sp);
 3220e68:	e13ffe17 	ldw	r4,-8(fp)
 3220e6c:	32203040 	call	3220304 <lcd_repaint_screen>

  return sp->period;
 3220e70:	e0bffe17 	ldw	r2,-8(fp)
 3220e74:	10800717 	ldw	r2,28(r2)
}
 3220e78:	e037883a 	mov	sp,fp
 3220e7c:	dfc00117 	ldw	ra,4(sp)
 3220e80:	df000017 	ldw	fp,0(sp)
 3220e84:	dec00204 	addi	sp,sp,8
 3220e88:	f800283a 	ret

03220e8c <altera_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void altera_avalon_lcd_16207_init(altera_avalon_lcd_16207_state* sp)
{
 3220e8c:	defffa04 	addi	sp,sp,-24
 3220e90:	dfc00515 	stw	ra,20(sp)
 3220e94:	df000415 	stw	fp,16(sp)
 3220e98:	df000404 	addi	fp,sp,16
 3220e9c:	e13fff15 	stw	r4,-4(fp)
  unsigned int base = sp->base;
 3220ea0:	e0bfff17 	ldw	r2,-4(fp)
 3220ea4:	10800017 	ldw	r2,0(r2)
 3220ea8:	e0bffe15 	stw	r2,-8(fp)

  /* Mark the device as functional */
  sp->broken = 0;
 3220eac:	e0bfff17 	ldw	r2,-4(fp)
 3220eb0:	10000805 	stb	zero,32(r2)

  ALT_SEM_CREATE (&sp->write_lock, 1);
 3220eb4:	e0bfff17 	ldw	r2,-4(fp)
 3220eb8:	10803e04 	addi	r2,r2,248
 3220ebc:	e0bffc15 	stw	r2,-16(fp)
 3220ec0:	00800044 	movi	r2,1
 3220ec4:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 3220ec8:	e13ffd0b 	ldhu	r4,-12(fp)
 3220ecc:	321aa300 	call	321aa30 <OSSemCreate>
 3220ed0:	1007883a 	mov	r3,r2
 3220ed4:	e0bffc17 	ldw	r2,-16(fp)
 3220ed8:	10c00015 	stw	r3,0(r2)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
 3220edc:	010ea604 	movi	r4,15000
 3220ee0:	323ae680 	call	323ae68 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 3220ee4:	e0bffe17 	ldw	r2,-8(fp)
 3220ee8:	1007883a 	mov	r3,r2
 3220eec:	00800c04 	movi	r2,48
 3220ef0:	18800035 	stwio	r2,0(r3)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);  
 3220ef4:	01040104 	movi	r4,4100
 3220ef8:	323ae680 	call	323ae68 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 3220efc:	e0bffe17 	ldw	r2,-8(fp)
 3220f00:	1007883a 	mov	r3,r2
 3220f04:	00800c04 	movi	r2,48
 3220f08:	18800035 	stwio	r2,0(r3)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
 3220f0c:	0100fa04 	movi	r4,1000
 3220f10:	323ae680 	call	323ae68 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 3220f14:	e0bffe17 	ldw	r2,-8(fp)
 3220f18:	1007883a 	mov	r3,r2
 3220f1c:	00800c04 	movi	r2,48
 3220f20:	18800035 	stwio	r2,0(r3)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
 3220f24:	e13fff17 	ldw	r4,-4(fp)
 3220f28:	01400e04 	movi	r5,56
 3220f2c:	32200b40 	call	32200b4 <lcd_write_command>
  
  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
 3220f30:	e13fff17 	ldw	r4,-4(fp)
 3220f34:	01400204 	movi	r5,8
 3220f38:	32200b40 	call	32200b4 <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
 3220f3c:	e13fff17 	ldw	r4,-4(fp)
 3220f40:	32202400 	call	3220240 <lcd_clear_screen>
  
  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
 3220f44:	e13fff17 	ldw	r4,-4(fp)
 3220f48:	01400184 	movi	r5,6
 3220f4c:	32200b40 	call	32200b4 <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
 3220f50:	e13fff17 	ldw	r4,-4(fp)
 3220f54:	01400304 	movi	r5,12
 3220f58:	32200b40 	call	32200b4 <lcd_write_command>

  sp->esccount = -1;
 3220f5c:	e0ffff17 	ldw	r3,-4(fp)
 3220f60:	00bfffc4 	movi	r2,-1
 3220f64:	18800905 	stb	r2,36(r3)
  memset(sp->escape, 0, sizeof(sp->escape));
 3220f68:	e0bfff17 	ldw	r2,-4(fp)
 3220f6c:	11000a04 	addi	r4,r2,40
 3220f70:	000b883a 	mov	r5,zero
 3220f74:	01800204 	movi	r6,8
 3220f78:	320694c0 	call	320694c <memset>

  sp->scrollpos = 0;
 3220f7c:	e0bfff17 	ldw	r2,-4(fp)
 3220f80:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
 3220f84:	e0bfff17 	ldw	r2,-4(fp)
 3220f88:	10000985 	stb	zero,38(r2)
  sp->active = 0;
 3220f8c:	e0bfff17 	ldw	r2,-4(fp)
 3220f90:	100009c5 	stb	zero,39(r2)
 3220f94:	0080c974 	movhi	r2,805
 3220f98:	10926604 	addi	r2,r2,18840
 3220f9c:	10800017 	ldw	r2,0(r2)
 3220fa0:	1009883a 	mov	r4,r2

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
 3220fa4:	01400284 	movi	r5,10
 3220fa8:	32044bc0 	call	32044bc <__udivsi3>
 3220fac:	1007883a 	mov	r3,r2
 3220fb0:	e0bfff17 	ldw	r2,-4(fp)
 3220fb4:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
 3220fb8:	e0bfff17 	ldw	r2,-4(fp)
 3220fbc:	11000104 	addi	r4,r2,4
 3220fc0:	e0bfff17 	ldw	r2,-4(fp)
 3220fc4:	10800717 	ldw	r2,28(r2)
 3220fc8:	100b883a 	mov	r5,r2
 3220fcc:	0180c8b4 	movhi	r6,802
 3220fd0:	31837004 	addi	r6,r6,3520
 3220fd4:	e1ffff17 	ldw	r7,-4(fp)
 3220fd8:	3239f800 	call	3239f80 <alt_alarm_start>
}
 3220fdc:	e037883a 	mov	sp,fp
 3220fe0:	dfc00117 	ldw	ra,4(sp)
 3220fe4:	df000017 	ldw	fp,0(sp)
 3220fe8:	dec00204 	addi	sp,sp,8
 3220fec:	f800283a 	ret

03220ff0 <altera_avalon_lcd_16207_write_fd>:
extern int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp,
  const char* ptr, int count, int flags);

int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
 3220ff0:	defffa04 	addi	sp,sp,-24
 3220ff4:	dfc00515 	stw	ra,20(sp)
 3220ff8:	df000415 	stw	fp,16(sp)
 3220ffc:	df000404 	addi	fp,sp,16
 3221000:	e13ffd15 	stw	r4,-12(fp)
 3221004:	e17ffe15 	stw	r5,-8(fp)
 3221008:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 
 322100c:	e0bffd17 	ldw	r2,-12(fp)
 3221010:	10800017 	ldw	r2,0(r2)
 3221014:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
 3221018:	e0bffc17 	ldw	r2,-16(fp)
 322101c:	11000a04 	addi	r4,r2,40
 3221020:	e0bffd17 	ldw	r2,-12(fp)
 3221024:	11c00217 	ldw	r7,8(r2)
 3221028:	e17ffe17 	ldw	r5,-8(fp)
 322102c:	e1bfff17 	ldw	r6,-4(fp)
 3221030:	32208880 	call	3220888 <altera_avalon_lcd_16207_write>
      fd->fd_flags);
}
 3221034:	e037883a 	mov	sp,fp
 3221038:	dfc00117 	ldw	ra,4(sp)
 322103c:	df000017 	ldw	fp,0(sp)
 3221040:	dec00204 	addi	sp,sp,8
 3221044:	f800283a 	ret

03221048 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 3221048:	defff904 	addi	sp,sp,-28
 322104c:	dfc00615 	stw	ra,24(sp)
 3221050:	df000515 	stw	fp,20(sp)
 3221054:	df000504 	addi	fp,sp,20
 3221058:	e13ffe15 	stw	r4,-8(fp)
 322105c:	e17fff15 	stw	r5,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 3221060:	e0bffe17 	ldw	r2,-8(fp)
 3221064:	10000035 	stwio	zero,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 3221068:	e0bffe17 	ldw	r2,-8(fp)
 322106c:	10800104 	addi	r2,r2,4
 3221070:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3221074:	0005303a 	rdctl	r2,status
 3221078:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 322107c:	e0fffc17 	ldw	r3,-16(fp)
 3221080:	00bfff84 	movi	r2,-2
 3221084:	1884703a 	and	r2,r3,r2
 3221088:	1001703a 	wrctl	status,r2
  
  return context;
 322108c:	e0bffc17 	ldw	r2,-16(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 3221090:	e0bffd15 	stw	r2,-12(fp)
  alt_tick ();
 3221094:	323ad580 	call	323ad58 <alt_tick>
 3221098:	e0bffd17 	ldw	r2,-12(fp)
 322109c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 32210a0:	e0bffb17 	ldw	r2,-20(fp)
 32210a4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 32210a8:	e037883a 	mov	sp,fp
 32210ac:	dfc00117 	ldw	ra,4(sp)
 32210b0:	df000017 	ldw	fp,0(sp)
 32210b4:	dec00204 	addi	sp,sp,8
 32210b8:	f800283a 	ret

032210bc <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 32210bc:	defff904 	addi	sp,sp,-28
 32210c0:	dfc00615 	stw	ra,24(sp)
 32210c4:	df000515 	stw	fp,20(sp)
 32210c8:	df000504 	addi	fp,sp,20
 32210cc:	e13ffc15 	stw	r4,-16(fp)
 32210d0:	e17ffd15 	stw	r5,-12(fp)
 32210d4:	e1bffe15 	stw	r6,-8(fp)
 32210d8:	e1ffff15 	stw	r7,-4(fp)
 32210dc:	e0bfff17 	ldw	r2,-4(fp)
 32210e0:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 32210e4:	0080c974 	movhi	r2,805
 32210e8:	10926604 	addi	r2,r2,18840
 32210ec:	10800017 	ldw	r2,0(r2)
 32210f0:	1004c03a 	cmpne	r2,r2,zero
 32210f4:	1000041e 	bne	r2,zero,3221108 <alt_avalon_timer_sc_init+0x4c>
  {
    _alt_tick_rate = nticks;
 32210f8:	00c0c974 	movhi	r3,805
 32210fc:	18d26604 	addi	r3,r3,18840
 3221100:	e0bffb17 	ldw	r2,-20(fp)
 3221104:	18800015 	stw	r2,0(r3)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 3221108:	e0bffc17 	ldw	r2,-16(fp)
 322110c:	10800104 	addi	r2,r2,4
 3221110:	1007883a 	mov	r3,r2
 3221114:	008001c4 	movi	r2,7
 3221118:	18800035 	stwio	r2,0(r3)
  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
 322111c:	e13ffe17 	ldw	r4,-8(fp)
 3221120:	e17ffc17 	ldw	r5,-16(fp)
 3221124:	0180c8b4 	movhi	r6,802
 3221128:	31841204 	addi	r6,r6,4168
 322112c:	323a9080 	call	323a908 <alt_irq_register>
#endif  
}
 3221130:	e037883a 	mov	sp,fp
 3221134:	dfc00117 	ldw	ra,4(sp)
 3221138:	df000017 	ldw	fp,0(sp)
 322113c:	dec00204 	addi	sp,sp,8
 3221140:	f800283a 	ret

03221144 <locator_init>:
#include <stdio.h>

#include "avalon_locator.h"

void locator_init(LOCATOR *sp, void *base)
{
 3221144:	defffd04 	addi	sp,sp,-12
 3221148:	df000215 	stw	fp,8(sp)
 322114c:	df000204 	addi	fp,sp,8
 3221150:	e13ffe15 	stw	r4,-8(fp)
 3221154:	e17fff15 	stw	r5,-4(fp)
	sp->base = base;
 3221158:	e0fffe17 	ldw	r3,-8(fp)
 322115c:	e0bfff17 	ldw	r2,-4(fp)
 3221160:	18800015 	stw	r2,0(r3)
	sp->id = 0;
 3221164:	e0bffe17 	ldw	r2,-8(fp)
 3221168:	10000115 	stw	zero,4(r2)
	sp->active = 0;
 322116c:	e0bffe17 	ldw	r2,-8(fp)
 3221170:	10000215 	stw	zero,8(r2)
}
 3221174:	e037883a 	mov	sp,fp
 3221178:	df000017 	ldw	fp,0(sp)
 322117c:	dec00104 	addi	sp,sp,4
 3221180:	f800283a 	ret

03221184 <get_current_corners>:

/* Gets the current corners list of the identified peripheral. */
int get_current_corners(LOCATOR *sp, char *char_buffer)
{
 3221184:	deffeb04 	addi	sp,sp,-84
 3221188:	dfc01415 	stw	ra,80(sp)
 322118c:	df001315 	stw	fp,76(sp)
 3221190:	dc401215 	stw	r17,72(sp)
 3221194:	dc001115 	stw	r16,68(sp)
 3221198:	df001104 	addi	fp,sp,68
 322119c:	e13ffe15 	stw	r4,-8(fp)
 32211a0:	e17fff15 	stw	r5,-4(fp)
	int nchars = 0;
 32211a4:	e03ffd15 	stw	zero,-12(fp)

	if (sp->active) {
 32211a8:	e0bffe17 	ldw	r2,-8(fp)
 32211ac:	10800217 	ldw	r2,8(r2)
 32211b0:	1005003a 	cmpeq	r2,r2,zero
 32211b4:	1000541e 	bne	r2,zero,3221308 <get_current_corners+0x184>
		nchars = sprintf(char_buffer,
 32211b8:	e0bffe17 	ldw	r2,-8(fp)
 32211bc:	10800017 	ldw	r2,0(r2)
 32211c0:	10800c04 	addi	r2,r2,48
 32211c4:	11800037 	ldwio	r6,0(r2)
 32211c8:	e0bffe17 	ldw	r2,-8(fp)
 32211cc:	10800017 	ldw	r2,0(r2)
 32211d0:	10800e04 	addi	r2,r2,56
 32211d4:	11c00037 	ldwio	r7,0(r2)
 32211d8:	e0bffe17 	ldw	r2,-8(fp)
 32211dc:	10800017 	ldw	r2,0(r2)
 32211e0:	10801004 	addi	r2,r2,64
 32211e4:	10c00037 	ldwio	r3,0(r2)
 32211e8:	e0bffe17 	ldw	r2,-8(fp)
 32211ec:	10800017 	ldw	r2,0(r2)
 32211f0:	10801204 	addi	r2,r2,72
 32211f4:	11000037 	ldwio	r4,0(r2)
 32211f8:	e0bffe17 	ldw	r2,-8(fp)
 32211fc:	10800017 	ldw	r2,0(r2)
 3221200:	10801404 	addi	r2,r2,80
 3221204:	11400037 	ldwio	r5,0(r2)
 3221208:	e0bffe17 	ldw	r2,-8(fp)
 322120c:	10800017 	ldw	r2,0(r2)
 3221210:	10801604 	addi	r2,r2,88
 3221214:	12000037 	ldwio	r8,0(r2)
 3221218:	e0bffe17 	ldw	r2,-8(fp)
 322121c:	10800017 	ldw	r2,0(r2)
 3221220:	10801804 	addi	r2,r2,96
 3221224:	12400037 	ldwio	r9,0(r2)
 3221228:	e0bffe17 	ldw	r2,-8(fp)
 322122c:	10800017 	ldw	r2,0(r2)
 3221230:	10801a04 	addi	r2,r2,104
 3221234:	12800037 	ldwio	r10,0(r2)
 3221238:	e0bffe17 	ldw	r2,-8(fp)
 322123c:	10800017 	ldw	r2,0(r2)
 3221240:	10801c04 	addi	r2,r2,112
 3221244:	12c00037 	ldwio	r11,0(r2)
 3221248:	e0bffe17 	ldw	r2,-8(fp)
 322124c:	10800017 	ldw	r2,0(r2)
 3221250:	10801e04 	addi	r2,r2,120
 3221254:	13000037 	ldwio	r12,0(r2)
 3221258:	e0bffe17 	ldw	r2,-8(fp)
 322125c:	10800017 	ldw	r2,0(r2)
 3221260:	10802004 	addi	r2,r2,128
 3221264:	13400037 	ldwio	r13,0(r2)
 3221268:	e0bffe17 	ldw	r2,-8(fp)
 322126c:	10800017 	ldw	r2,0(r2)
 3221270:	10802204 	addi	r2,r2,136
 3221274:	13800037 	ldwio	r14,0(r2)
 3221278:	e0bffe17 	ldw	r2,-8(fp)
 322127c:	10800017 	ldw	r2,0(r2)
 3221280:	10802404 	addi	r2,r2,144
 3221284:	13c00037 	ldwio	r15,0(r2)
 3221288:	e0bffe17 	ldw	r2,-8(fp)
 322128c:	10800017 	ldw	r2,0(r2)
 3221290:	10802604 	addi	r2,r2,152
 3221294:	14000037 	ldwio	r16,0(r2)
 3221298:	e0bffe17 	ldw	r2,-8(fp)
 322129c:	10800017 	ldw	r2,0(r2)
 32212a0:	10802804 	addi	r2,r2,160
 32212a4:	14400037 	ldwio	r17,0(r2)
 32212a8:	e0bffe17 	ldw	r2,-8(fp)
 32212ac:	10800017 	ldw	r2,0(r2)
 32212b0:	10802a04 	addi	r2,r2,168
 32212b4:	10800037 	ldwio	r2,0(r2)
 32212b8:	d8c00015 	stw	r3,0(sp)
 32212bc:	d9000115 	stw	r4,4(sp)
 32212c0:	d9400215 	stw	r5,8(sp)
 32212c4:	da000315 	stw	r8,12(sp)
 32212c8:	da400415 	stw	r9,16(sp)
 32212cc:	da800515 	stw	r10,20(sp)
 32212d0:	dac00615 	stw	r11,24(sp)
 32212d4:	db000715 	stw	r12,28(sp)
 32212d8:	db400815 	stw	r13,32(sp)
 32212dc:	db800915 	stw	r14,36(sp)
 32212e0:	dbc00a15 	stw	r15,40(sp)
 32212e4:	dc000b15 	stw	r16,44(sp)
 32212e8:	dc400c15 	stw	r17,48(sp)
 32212ec:	d8800d15 	stw	r2,52(sp)
 32212f0:	e13fff17 	ldw	r4,-4(fp)
 32212f4:	0140c974 	movhi	r5,805
 32212f8:	2978e604 	addi	r5,r5,-7272
 32212fc:	32076bc0 	call	32076bc <sprintf>
 3221300:	e0bffd15 	stw	r2,-12(fp)
 3221304:	00000806 	br	3221328 <get_current_corners+0x1a4>
		     	         IORD_LOCATION_P6_X(sp->base), IORD_LOCATION_P6_Y(sp->base),
		     	         IORD_LOCATION_P7_X(sp->base), IORD_LOCATION_P7_Y(sp->base),
		     	         IORD_LOCATION_P8_X(sp->base), IORD_LOCATION_P8_Y(sp->base));
	}
	else {
		nchars = sprintf(char_buffer, "()");
 3221308:	e0ffff17 	ldw	r3,-4(fp)
 322130c:	00800a04 	movi	r2,40
 3221310:	18800005 	stb	r2,0(r3)
 3221314:	00800a44 	movi	r2,41
 3221318:	18800045 	stb	r2,1(r3)
 322131c:	18000085 	stb	zero,2(r3)
 3221320:	00800084 	movi	r2,2
 3221324:	e0bffd15 	stw	r2,-12(fp)
	}

	return nchars;
 3221328:	e0bffd17 	ldw	r2,-12(fp)
}
 322132c:	e037883a 	mov	sp,fp
 3221330:	dfc00317 	ldw	ra,12(sp)
 3221334:	df000217 	ldw	fp,8(sp)
 3221338:	dc400117 	ldw	r17,4(sp)
 322133c:	dc000017 	ldw	r16,0(sp)
 3221340:	dec00404 	addi	sp,sp,16
 3221344:	f800283a 	ret

03221348 <set_search_window>:

/* Sets the search window of the locator device. */
int set_search_window(LOCATOR *sp, char *char_buffer, int x, int y, int width, int height)
{
 3221348:	defff704 	addi	sp,sp,-36
 322134c:	dfc00815 	stw	ra,32(sp)
 3221350:	df000715 	stw	fp,28(sp)
 3221354:	df000704 	addi	fp,sp,28
 3221358:	e13ffc15 	stw	r4,-16(fp)
 322135c:	e17ffd15 	stw	r5,-12(fp)
 3221360:	e1bffe15 	stw	r6,-8(fp)
 3221364:	e1ffff15 	stw	r7,-4(fp)
	IOWR_LOCATOR_X(sp->base, x);
 3221368:	e0bffc17 	ldw	r2,-16(fp)
 322136c:	10800017 	ldw	r2,0(r2)
 3221370:	10800404 	addi	r2,r2,16
 3221374:	1007883a 	mov	r3,r2
 3221378:	e0bffe17 	ldw	r2,-8(fp)
 322137c:	18800035 	stwio	r2,0(r3)
	IOWR_LOCATOR_Y(sp->base, y);
 3221380:	e0bffc17 	ldw	r2,-16(fp)
 3221384:	10800017 	ldw	r2,0(r2)
 3221388:	10800604 	addi	r2,r2,24
 322138c:	1007883a 	mov	r3,r2
 3221390:	e0bfff17 	ldw	r2,-4(fp)
 3221394:	18800035 	stwio	r2,0(r3)
	IOWR_LOCATOR_WIDTH(sp->base, width);
 3221398:	e0bffc17 	ldw	r2,-16(fp)
 322139c:	10800017 	ldw	r2,0(r2)
 32213a0:	10800804 	addi	r2,r2,32
 32213a4:	1007883a 	mov	r3,r2
 32213a8:	e0800217 	ldw	r2,8(fp)
 32213ac:	18800035 	stwio	r2,0(r3)
	IOWR_LOCATOR_HEIGHT(sp->base, height);
 32213b0:	e0bffc17 	ldw	r2,-16(fp)
 32213b4:	10800017 	ldw	r2,0(r2)
 32213b8:	10800a04 	addi	r2,r2,40
 32213bc:	1007883a 	mov	r3,r2
 32213c0:	e0800317 	ldw	r2,12(fp)
 32213c4:	18800035 	stwio	r2,0(r3)
	IOWR_LOCATOR_SW(sp->base, 1);
 32213c8:	e0bffc17 	ldw	r2,-16(fp)
 32213cc:	10800017 	ldw	r2,0(r2)
 32213d0:	10800304 	addi	r2,r2,12
 32213d4:	1007883a 	mov	r3,r2
 32213d8:	00800044 	movi	r2,1
 32213dc:	18800035 	stwio	r2,0(r3)
	IOWR_LOCATOR_SW(sp->base, 0);
 32213e0:	e0bffc17 	ldw	r2,-16(fp)
 32213e4:	10800017 	ldw	r2,0(r2)
 32213e8:	10800304 	addi	r2,r2,12
 32213ec:	10000035 	stwio	zero,0(r2)
	IOWR_LOCATOR_ENABLE(sp->base);
 32213f0:	e0bffc17 	ldw	r2,-16(fp)
 32213f4:	10800017 	ldw	r2,0(r2)
 32213f8:	1007883a 	mov	r3,r2
 32213fc:	00800044 	movi	r2,1
 3221400:	18800035 	stwio	r2,0(r3)

	int nchars = 0;
 3221404:	e03ffb15 	stw	zero,-20(fp)
	nchars = sprintf(char_buffer, "(%i,%i,%i,%i)", x, y, width, height);
 3221408:	e0800217 	ldw	r2,8(fp)
 322140c:	d8800015 	stw	r2,0(sp)
 3221410:	e0800317 	ldw	r2,12(fp)
 3221414:	d8800115 	stw	r2,4(sp)
 3221418:	e13ffd17 	ldw	r4,-12(fp)
 322141c:	0140c974 	movhi	r5,805
 3221420:	2978f704 	addi	r5,r5,-7204
 3221424:	e1bffe17 	ldw	r6,-8(fp)
 3221428:	e1ffff17 	ldw	r7,-4(fp)
 322142c:	32076bc0 	call	32076bc <sprintf>
 3221430:	e0bffb15 	stw	r2,-20(fp)
	return nchars;
 3221434:	e0bffb17 	ldw	r2,-20(fp)
}
 3221438:	e037883a 	mov	sp,fp
 322143c:	dfc00117 	ldw	ra,4(sp)
 3221440:	df000017 	ldw	fp,0(sp)
 3221444:	dec00204 	addi	sp,sp,8
 3221448:	f800283a 	ret

0322144c <get_search_window>:

/* Gets the search window of the locator device. */
int get_search_window(LOCATOR *sp, char *char_buffer)
{
 322144c:	defff504 	addi	sp,sp,-44
 3221450:	dfc00a15 	stw	ra,40(sp)
 3221454:	df000915 	stw	fp,36(sp)
 3221458:	df000904 	addi	fp,sp,36
 322145c:	e13ffe15 	stw	r4,-8(fp)
 3221460:	e17fff15 	stw	r5,-4(fp)
	int x = IORD_LOCATOR_X(sp->base);
 3221464:	e0bffe17 	ldw	r2,-8(fp)
 3221468:	10800017 	ldw	r2,0(r2)
 322146c:	10800404 	addi	r2,r2,16
 3221470:	10800037 	ldwio	r2,0(r2)
 3221474:	e0bffd15 	stw	r2,-12(fp)
	int y = IORD_LOCATOR_Y(sp->base);
 3221478:	e0bffe17 	ldw	r2,-8(fp)
 322147c:	10800017 	ldw	r2,0(r2)
 3221480:	10800604 	addi	r2,r2,24
 3221484:	10800037 	ldwio	r2,0(r2)
 3221488:	e0bffc15 	stw	r2,-16(fp)
	int width = IORD_LOCATOR_WIDTH(sp->base);
 322148c:	e0bffe17 	ldw	r2,-8(fp)
 3221490:	10800017 	ldw	r2,0(r2)
 3221494:	10800804 	addi	r2,r2,32
 3221498:	10800037 	ldwio	r2,0(r2)
 322149c:	e0bffb15 	stw	r2,-20(fp)
	int height = IORD_LOCATOR_HEIGHT(sp->base);
 32214a0:	e0bffe17 	ldw	r2,-8(fp)
 32214a4:	10800017 	ldw	r2,0(r2)
 32214a8:	10800a04 	addi	r2,r2,40
 32214ac:	10800037 	ldwio	r2,0(r2)
 32214b0:	e0bffa15 	stw	r2,-24(fp)

	int nchars = 0;
 32214b4:	e03ff915 	stw	zero,-28(fp)
	nchars = sprintf(char_buffer, "((%i,%i),(%i,%i))", x, y, width, height);
 32214b8:	e0bffb17 	ldw	r2,-20(fp)
 32214bc:	d8800015 	stw	r2,0(sp)
 32214c0:	e0bffa17 	ldw	r2,-24(fp)
 32214c4:	d8800115 	stw	r2,4(sp)
 32214c8:	e13fff17 	ldw	r4,-4(fp)
 32214cc:	0140c974 	movhi	r5,805
 32214d0:	2978fb04 	addi	r5,r5,-7188
 32214d4:	e1bffd17 	ldw	r6,-12(fp)
 32214d8:	e1fffc17 	ldw	r7,-16(fp)
 32214dc:	32076bc0 	call	32076bc <sprintf>
 32214e0:	e0bff915 	stw	r2,-28(fp)

	return nchars;
 32214e4:	e0bff917 	ldw	r2,-28(fp)
}
 32214e8:	e037883a 	mov	sp,fp
 32214ec:	dfc00117 	ldw	ra,4(sp)
 32214f0:	df000017 	ldw	fp,0(sp)
 32214f4:	dec00204 	addi	sp,sp,8
 32214f8:	f800283a 	ret

032214fc <eth_ocm_prep>:
 * Prepare ethernet MAC.
 *
 * @param ins_dev   Pointer to associated alt_iniche_dev struct
 * @return
 */
error_t eth_ocm_prep(alt_iniche_dev *ins_dev){
 32214fc:	defff904 	addi	sp,sp,-28
 3221500:	dfc00615 	stw	ra,24(sp)
 3221504:	df000515 	stw	fp,20(sp)
 3221508:	dc000415 	stw	r16,16(sp)
 322150c:	df000404 	addi	fp,sp,16
 3221510:	e13fff15 	stw	r4,-4(fp)
    NET ifp;
    int index;
    eth_ocm_dev *dev;

    index = ins_dev->if_num;
 3221514:	e0bfff17 	ldw	r2,-4(fp)
 3221518:	10800517 	ldw	r2,20(r2)
 322151c:	e0bffd15 	stw	r2,-12(fp)
    dev = (eth_ocm_dev *)ins_dev;
 3221520:	e0bfff17 	ldw	r2,-4(fp)
 3221524:	e0bffc15 	stw	r2,-16(fp)
    //Status message
    dprintf("eth_ocm_prep\n");
    #endif // if ETH_OCM_DBG_LVL

    //create eth_ocm_info struct
    dev->info = (eth_ocm_info *)malloc(sizeof(eth_ocm_info));
 3221528:	01001004 	movi	r4,64
 322152c:	324b9480 	call	324b948 <malloc>
 3221530:	1007883a 	mov	r3,r2
 3221534:	e0bffc17 	ldw	r2,-16(fp)
 3221538:	10c01115 	stw	r3,68(r2)
    dev->info->sem = 0; //initialize semaphore
 322153c:	e0bffc17 	ldw	r2,-16(fp)
 3221540:	10801117 	ldw	r2,68(r2)
 3221544:	10000305 	stb	zero,12(r2)
    dev->info->rx_pkts = (PACKET *)(malloc(sizeof(PACKET) * ETH_OCM_RX_DESC_COUNT));
 3221548:	e0bffc17 	ldw	r2,-16(fp)
 322154c:	14001117 	ldw	r16,68(r2)
 3221550:	01000104 	movi	r4,4
 3221554:	324b9480 	call	324b948 <malloc>
 3221558:	80800415 	stw	r2,16(r16)


    ifp = nets[index];
 322155c:	e0bffd17 	ldw	r2,-12(fp)
 3221560:	00c0c9b4 	movhi	r3,806
 3221564:	18f25a04 	addi	r3,r3,-13976
 3221568:	1085883a 	add	r2,r2,r2
 322156c:	1085883a 	add	r2,r2,r2
 3221570:	10c5883a 	add	r2,r2,r3
 3221574:	10800017 	ldw	r2,0(r2)
 3221578:	e0bffe15 	stw	r2,-8(fp)
    ifp->n_mib->ifAdminStatus = ETH_OCM_STATUS_DOWN;    
 322157c:	e0bffe17 	ldw	r2,-8(fp)
 3221580:	10c02717 	ldw	r3,156(r2)
 3221584:	00800084 	movi	r2,2
 3221588:	18800615 	stw	r2,24(r3)
    ifp->n_mib->ifOperStatus =  ETH_OCM_STATUS_DOWN;
 322158c:	e0bffe17 	ldw	r2,-8(fp)
 3221590:	10c02717 	ldw	r3,156(r2)
 3221594:	00800084 	movi	r2,2
 3221598:	18800715 	stw	r2,28(r3)
    ifp->n_mib->ifLastChange =  cticks * (100/TPS);     //timestamp
 322159c:	e0bffe17 	ldw	r2,-8(fp)
 32215a0:	10802717 	ldw	r2,156(r2)
 32215a4:	10000815 	stw	zero,32(r2)
    ifp->n_mib->ifPhysAddress = (u_char*)dev->info->mac_addr;
 32215a8:	e0bffe17 	ldw	r2,-8(fp)
 32215ac:	10c02717 	ldw	r3,156(r2)
 32215b0:	e0bffc17 	ldw	r2,-16(fp)
 32215b4:	10801117 	ldw	r2,68(r2)
 32215b8:	18800515 	stw	r2,20(r3)
    ifp->n_mib->ifDescr =       (u_char*)"Opencores 10/100 ethernet MAC";
 32215bc:	e0bffe17 	ldw	r2,-8(fp)
 32215c0:	10c02717 	ldw	r3,156(r2)
 32215c4:	0080c974 	movhi	r2,805
 32215c8:	10b90004 	addi	r2,r2,-7168
 32215cc:	18800115 	stw	r2,4(r3)
    ifp->n_lnh =                ETHHDR_SIZE;            /* ethernet header size. */
 32215d0:	e0fffe17 	ldw	r3,-8(fp)
 32215d4:	00800404 	movi	r2,16
 32215d8:	18800815 	stw	r2,32(r3)
    ifp->n_hal =                ETH_OCM_MAC_ADDR_LEN;   /* MAC address length */
 32215dc:	e0fffe17 	ldw	r3,-8(fp)
 32215e0:	00800184 	movi	r2,6
 32215e4:	18801115 	stw	r2,68(r3)
    ifp->n_mib->ifType =        ETHERNET;               /* device type */
 32215e8:	e0bffe17 	ldw	r2,-8(fp)
 32215ec:	10c02717 	ldw	r3,156(r2)
 32215f0:	00800184 	movi	r2,6
 32215f4:	18800215 	stw	r2,8(r3)
    ifp->n_mtu =                ETH_OCM_MAX_MTU;        /* max frame size */
 32215f8:	e0fffe17 	ldw	r3,-8(fp)
 32215fc:	00817b84 	movi	r2,1518
 3221600:	18800915 	stw	r2,36(r3)

    /* install our hardware driver routines */
    ifp->n_init =       eth_ocm_init;
 3221604:	e0fffe17 	ldw	r3,-8(fp)
 3221608:	0080c8b4 	movhi	r2,802
 322160c:	1085ae04 	addi	r2,r2,5816
 3221610:	18800215 	stw	r2,8(r3)
    #ifndef ETH_OCM_SYNC_TX
    ifp->pkt_send =     eth_ocm_pkt_send;
 3221614:	e0fffe17 	ldw	r3,-8(fp)
 3221618:	0080c8b4 	movhi	r2,802
 322161c:	10869304 	addi	r2,r2,6732
 3221620:	18800415 	stw	r2,16(r3)
    ifp->raw_send =     NULL;
 3221624:	e0bffe17 	ldw	r2,-8(fp)
 3221628:	10000315 	stw	zero,12(r2)
    #else
    ifp->pkt_send =     NULL;
    ifp->raw_send =     eth_ocm_raw_send;
    #endif // ifndef ETH_OCM_SYNC_TX
    ifp->n_close =      eth_ocm_close;
 322162c:	e0fffe17 	ldw	r3,-8(fp)
 3221630:	0080c8b4 	movhi	r2,802
 3221634:	1089bd04 	addi	r2,r2,9972
 3221638:	18800515 	stw	r2,20(r3)
    ifp->n_stats =      eth_ocm_stats;
 322163c:	e0fffe17 	ldw	r3,-8(fp)
 3221640:	0080c8b4 	movhi	r2,802
 3221644:	10896204 	addi	r2,r2,9608
 3221648:	18800715 	stw	r2,28(r3)

#ifdef IP_V6
      ifp->n_flags |= (NF_NBPROT | NF_IPV6);
#else
      ifp->n_flags |= NF_NBPROT;
 322164c:	e0bffe17 	ldw	r2,-8(fp)
 3221650:	10802a17 	ldw	r2,168(r2)
 3221654:	10c00214 	ori	r3,r2,8
 3221658:	e0bffe17 	ldw	r2,-8(fp)
 322165c:	10c02a15 	stw	r3,168(r2)
#endif

    /* set cross-pointers between iface and eth_ocm structs */
    dev->info->netp = ifp;
 3221660:	e0bffc17 	ldw	r2,-16(fp)
 3221664:	10c01117 	ldw	r3,68(r2)
 3221668:	e0bffe17 	ldw	r2,-8(fp)
 322166c:	18800215 	stw	r2,8(r3)
    ifp->n_local = (void*)(dev);
 3221670:	e0fffe17 	ldw	r3,-8(fp)
 3221674:	e0bffc17 	ldw	r2,-16(fp)
 3221678:	18802815 	stw	r2,160(r3)

    /* get the MAC address. */
    get_mac_addr(ifp, dev->info->mac_addr);
 322167c:	e0bffc17 	ldw	r2,-16(fp)
 3221680:	10801117 	ldw	r2,68(r2)
 3221684:	100b883a 	mov	r5,r2
 3221688:	e13ffe17 	ldw	r4,-8(fp)
 322168c:	32017fc0 	call	32017fc <get_mac_addr>

    index++;
 3221690:	e0bffd17 	ldw	r2,-12(fp)
 3221694:	10800044 	addi	r2,r2,1
 3221698:	e0bffd15 	stw	r2,-12(fp)
    return index;
 322169c:	e0bffd17 	ldw	r2,-12(fp)
}
 32216a0:	e037883a 	mov	sp,fp
 32216a4:	dfc00217 	ldw	ra,8(sp)
 32216a8:	df000117 	ldw	fp,4(sp)
 32216ac:	dc000017 	ldw	r16,0(sp)
 32216b0:	dec00304 	addi	sp,sp,12
 32216b4:	f800283a 	ret

032216b8 <eth_ocm_init>:
/**
 * Initializes the Opencores ethernet MAC. Called by InterNiche stack
 *
 * @param 
 */
int eth_ocm_init(int iface){
 32216b8:	defff604 	addi	sp,sp,-40
 32216bc:	dfc00915 	stw	ra,36(sp)
 32216c0:	df000815 	stw	fp,32(sp)
 32216c4:	df000804 	addi	fp,sp,32
 32216c8:	e13fff15 	stw	r4,-4(fp)
    int status = SUCCESS;
 32216cc:	e03ffe15 	stw	zero,-8(fp)

    #if (ETH_OCM_DBG_LVL >= 1)
    dprintf("[eth_ocm_init]\n");
    #endif
    //get the ifp first
    ifp = nets[iface];
 32216d0:	e0bfff17 	ldw	r2,-4(fp)
 32216d4:	00c0c9b4 	movhi	r3,806
 32216d8:	18f25a04 	addi	r3,r3,-13976
 32216dc:	1085883a 	add	r2,r2,r2
 32216e0:	1085883a 	add	r2,r2,r2
 32216e4:	10c5883a 	add	r2,r2,r3
 32216e8:	10800017 	ldw	r2,0(r2)
 32216ec:	e0bffb15 	stw	r2,-20(fp)
    //now get the info pointer
    dev = (eth_ocm_dev *)ifp->n_local;
 32216f0:	e0bffb17 	ldw	r2,-20(fp)
 32216f4:	10802817 	ldw	r2,160(r2)
 32216f8:	e0bffa15 	stw	r2,-24(fp)
    info = dev->info;
 32216fc:	e0bffa17 	ldw	r2,-24(fp)
 3221700:	10801117 	ldw	r2,68(r2)
 3221704:	e0bff915 	stw	r2,-28(fp)
    regs = dev->regs;
 3221708:	e0bffa17 	ldw	r2,-24(fp)
 322170c:	10800a17 	ldw	r2,40(r2)
 3221710:	e0bff815 	stw	r2,-32(fp)

    //Reset Descriptors (supposedly this can be done while in reset)
    for(temp=ETH_OCM_DESC_START;temp<ETH_OCM_DESC_END;temp++)
 3221714:	00804004 	movi	r2,256
 3221718:	e0bffc15 	stw	r2,-16(fp)
 322171c:	00000b06 	br	322174c <eth_ocm_init+0x94>
        IOWR(dev->base, temp, 0);
 3221720:	e0bffa17 	ldw	r2,-24(fp)
 3221724:	10800717 	ldw	r2,28(r2)
 3221728:	1007883a 	mov	r3,r2
 322172c:	e0bffc17 	ldw	r2,-16(fp)
 3221730:	1085883a 	add	r2,r2,r2
 3221734:	1085883a 	add	r2,r2,r2
 3221738:	1885883a 	add	r2,r3,r2
 322173c:	10000035 	stwio	zero,0(r2)
    dev = (eth_ocm_dev *)ifp->n_local;
    info = dev->info;
    regs = dev->regs;

    //Reset Descriptors (supposedly this can be done while in reset)
    for(temp=ETH_OCM_DESC_START;temp<ETH_OCM_DESC_END;temp++)
 3221740:	e0bffc17 	ldw	r2,-16(fp)
 3221744:	10800044 	addi	r2,r2,1
 3221748:	e0bffc15 	stw	r2,-16(fp)
 322174c:	e0bffc17 	ldw	r2,-16(fp)
 3221750:	10807fd0 	cmplti	r2,r2,511
 3221754:	103ff21e 	bne	r2,zero,3221720 <eth_ocm_init+0x68>
        IOWR(dev->base, temp, 0);

    //Let's disable the MAC until everything else is set up
    regs->moder = 0;
 3221758:	e0bff817 	ldw	r2,-32(fp)
 322175c:	10000015 	stw	zero,0(r2)

    //Determine the number of RX descriptors
    regs->tx_bd_num = ETH_OCM_TX_DESC_COUNT; //Set TX descriptor count in MAC    
 3221760:	e0fff817 	ldw	r3,-32(fp)
 3221764:	00800044 	movi	r2,1
 3221768:	18800815 	stw	r2,32(r3)
    info->cur_tx_desc = 0;
 322176c:	e0bff917 	ldw	r2,-28(fp)
 3221770:	10000345 	stb	zero,13(r2)
    info->cur_rx_desc = 0;
 3221774:	e0bff917 	ldw	r2,-28(fp)
 3221778:	10000385 	stb	zero,14(r2)
    #ifndef ETH_OCM_SYNC_TX
    info->next_tx_desc = 0;
 322177c:	e0bff917 	ldw	r2,-28(fp)
 3221780:	10000f05 	stb	zero,60(r2)
    info->next_tx_desc_rdy = 1;
 3221784:	e0fff917 	ldw	r3,-28(fp)
 3221788:	00800044 	movi	r2,1
 322178c:	18800f45 	stb	r2,61(r3)
    //Initialize queues
    dev->info->tosend.q_head = dev->info->tosend.q_tail = NULL;
 3221790:	e0bffa17 	ldw	r2,-24(fp)
 3221794:	10c01117 	ldw	r3,68(r2)
 3221798:	e0bffa17 	ldw	r2,-24(fp)
 322179c:	10801117 	ldw	r2,68(r2)
 32217a0:	10000615 	stw	zero,24(r2)
 32217a4:	10800617 	ldw	r2,24(r2)
 32217a8:	18800515 	stw	r2,20(r3)
    dev->info->tosend.q_max = dev->info->tosend.q_min = dev->info->tosend.q_len = 0;
 32217ac:	e0bffa17 	ldw	r2,-24(fp)
 32217b0:	11001117 	ldw	r4,68(r2)
 32217b4:	e0bffa17 	ldw	r2,-24(fp)
 32217b8:	10c01117 	ldw	r3,68(r2)
 32217bc:	e0bffa17 	ldw	r2,-24(fp)
 32217c0:	10801117 	ldw	r2,68(r2)
 32217c4:	10000715 	stw	zero,28(r2)
 32217c8:	10800717 	ldw	r2,28(r2)
 32217cc:	18800915 	stw	r2,36(r3)
 32217d0:	18800917 	ldw	r2,36(r3)
 32217d4:	20800815 	stw	r2,32(r4)
    dev->info->sending.q_head = dev->info->sending.q_tail = NULL;
 32217d8:	e0bffa17 	ldw	r2,-24(fp)
 32217dc:	10c01117 	ldw	r3,68(r2)
 32217e0:	e0bffa17 	ldw	r2,-24(fp)
 32217e4:	10801117 	ldw	r2,68(r2)
 32217e8:	10000b15 	stw	zero,44(r2)
 32217ec:	10800b17 	ldw	r2,44(r2)
 32217f0:	18800a15 	stw	r2,40(r3)
    dev->info->sending.q_max = dev->info->sending.q_min = dev->info->sending.q_len = 0;
 32217f4:	e0bffa17 	ldw	r2,-24(fp)
 32217f8:	11001117 	ldw	r4,68(r2)
 32217fc:	e0bffa17 	ldw	r2,-24(fp)
 3221800:	10c01117 	ldw	r3,68(r2)
 3221804:	e0bffa17 	ldw	r2,-24(fp)
 3221808:	10801117 	ldw	r2,68(r2)
 322180c:	10000c15 	stw	zero,48(r2)
 3221810:	10800c17 	ldw	r2,48(r2)
 3221814:	18800e15 	stw	r2,56(r3)
 3221818:	18800e17 	ldw	r2,56(r3)
 322181c:	20800d15 	stw	r2,52(r4)
    #endif

    /* perform any necessary PHY setup */
    //Let's set the MDIO interface up to run at 4MHz.
    temp = dev->clk_div;
 3221820:	e0bffa17 	ldw	r2,-24(fp)
 3221824:	10800917 	ldw	r2,36(r2)
 3221828:	e0bffc15 	stw	r2,-16(fp)
    if(temp < 2)
 322182c:	e0bffc17 	ldw	r2,-16(fp)
 3221830:	10800088 	cmpgei	r2,r2,2
 3221834:	1000021e 	bne	r2,zero,3221840 <eth_ocm_init+0x188>
        temp = 2;
 3221838:	00800084 	movi	r2,2
 322183c:	e0bffc15 	stw	r2,-16(fp)
    temp += 1;
 3221840:	e0bffc17 	ldw	r2,-16(fp)
 3221844:	10800044 	addi	r2,r2,1
 3221848:	e0bffc15 	stw	r2,-16(fp)
    temp &= 0xFFFFFFFE;   //only even numbers allowed
 322184c:	e0fffc17 	ldw	r3,-16(fp)
 3221850:	00bfff84 	movi	r2,-2
 3221854:	1884703a 	and	r2,r3,r2
 3221858:	e0bffc15 	stw	r2,-16(fp)
    regs->miimoder = temp;
 322185c:	e0fffc17 	ldw	r3,-16(fp)
 3221860:	e0bff817 	ldw	r2,-32(fp)
 3221864:	10c00a15 	stw	r3,40(r2)
    regs->miicommand = 0;
 3221868:	e0bff817 	ldw	r2,-32(fp)
 322186c:	10000b15 	stw	zero,44(r2)
    //Find out if we should run in duplex or not
    duplex = eth_ocm_phy_init(dev);
 3221870:	e13ffa17 	ldw	r4,-24(fp)
 3221874:	323c1400 	call	323c140 <eth_ocm_phy_init>
 3221878:	e0bffd15 	stw	r2,-12(fp)

    if(duplex)
 322187c:	e0bffd17 	ldw	r2,-12(fp)
 3221880:	1005003a 	cmpeq	r2,r2,zero
 3221884:	1000021e 	bne	r2,zero,3221890 <eth_ocm_init+0x1d8>
        duplex = ETH_OCM_MODER_FULLD_MSK;
 3221888:	00810004 	movi	r2,1024
 322188c:	e0bffd15 	stw	r2,-12(fp)

    // Configure MAC options
    // Interrupt sources
    regs->int_mask = ETH_OCM_DEFAULT_INTERRUPT_MASK; //Interrupt on receive
 3221890:	e0fff817 	ldw	r3,-32(fp)
 3221894:	008007c4 	movi	r2,31
 3221898:	18800215 	stw	r2,8(r3)
    // Clear any existing interrupts
    regs->int_source = 0xFFFFFFFF;
 322189c:	e0fff817 	ldw	r3,-32(fp)
 32218a0:	00bfffc4 	movi	r2,-1
 32218a4:	18800115 	stw	r2,4(r3)

    // Inter-packet gap 
    if(duplex)
 32218a8:	e0bffd17 	ldw	r2,-12(fp)
 32218ac:	1005003a 	cmpeq	r2,r2,zero
 32218b0:	1000041e 	bne	r2,zero,32218c4 <eth_ocm_init+0x20c>
        regs->ipgt = ETH_OCM_FULL_DUPLEX_IPGT; 
 32218b4:	e0fff817 	ldw	r3,-32(fp)
 32218b8:	00800544 	movi	r2,21
 32218bc:	18800315 	stw	r2,12(r3)
 32218c0:	00000306 	br	32218d0 <eth_ocm_init+0x218>
    else
        regs->ipgt = ETH_OCM_HALF_DUPLEX_IPGT;
 32218c4:	e0fff817 	ldw	r3,-32(fp)
 32218c8:	00800484 	movi	r2,18
 32218cc:	18800315 	stw	r2,12(r3)

    //Let's set the defaults just because they've bitten us before
    regs->ipgr2     = 0x0000000C;
 32218d0:	e0fff817 	ldw	r3,-32(fp)
 32218d4:	00800304 	movi	r2,12
 32218d8:	18800515 	stw	r2,20(r3)
    regs->ipgr2     = 0x00000012;
 32218dc:	e0fff817 	ldw	r3,-32(fp)
 32218e0:	00800484 	movi	r2,18
 32218e4:	18800515 	stw	r2,20(r3)
    regs->packetlen = 0x00400600;  //Min and Max frame sizes
 32218e8:	e0fff817 	ldw	r3,-32(fp)
 32218ec:	00801034 	movhi	r2,64
 32218f0:	10818004 	addi	r2,r2,1536
 32218f4:	18800615 	stw	r2,24(r3)
    regs->collconf  = 0x000F003F;
 32218f8:	e0fff817 	ldw	r3,-32(fp)
 32218fc:	008003f4 	movhi	r2,15
 3221900:	10800fc4 	addi	r2,r2,63
 3221904:	18800715 	stw	r2,28(r3)
    regs->ctrlmoder = 0x00000000;
 3221908:	e0bff817 	ldw	r2,-32(fp)
 322190c:	10000915 	stw	zero,36(r2)
            "%02x:%02x:%02x:%02x:%02x:%02x\n",
            info->mac_addr[0],info->mac_addr[1],info->mac_addr[2],
            info->mac_addr[3],info->mac_addr[4],info->mac_addr[5]);
    #endif // if ETH_OCM_DBG_LVL
    //Configure the MAC address
    regs->mac_addr0 =
 3221910:	e0bff917 	ldw	r2,-28(fp)
 3221914:	10800143 	ldbu	r2,5(r2)
 3221918:	10c03fcc 	andi	r3,r2,255
 322191c:	e0bff917 	ldw	r2,-28(fp)
 3221920:	10800103 	ldbu	r2,4(r2)
 3221924:	10803fcc 	andi	r2,r2,255
 3221928:	1004923a 	slli	r2,r2,8
 322192c:	1886b03a 	or	r3,r3,r2
 3221930:	e0bff917 	ldw	r2,-28(fp)
 3221934:	108000c3 	ldbu	r2,3(r2)
 3221938:	10803fcc 	andi	r2,r2,255
 322193c:	1004943a 	slli	r2,r2,16
 3221940:	1886b03a 	or	r3,r3,r2
 3221944:	e0bff917 	ldw	r2,-28(fp)
 3221948:	10800083 	ldbu	r2,2(r2)
 322194c:	10803fcc 	andi	r2,r2,255
 3221950:	1004963a 	slli	r2,r2,24
 3221954:	1884b03a 	or	r2,r3,r2
 3221958:	1007883a 	mov	r3,r2
 322195c:	e0bff817 	ldw	r2,-32(fp)
 3221960:	10c01015 	stw	r3,64(r2)
            ( ((int)info->mac_addr[5])         |
             (((int)info->mac_addr[4]) << 8)   |
             (((int)info->mac_addr[3]) << 16)  |
             (((int)info->mac_addr[2]) << 24)  );

    regs->mac_addr1 =
 3221964:	e0bff917 	ldw	r2,-28(fp)
 3221968:	10800043 	ldbu	r2,1(r2)
 322196c:	10c03fcc 	andi	r3,r2,255
 3221970:	e0bff917 	ldw	r2,-28(fp)
 3221974:	10800003 	ldbu	r2,0(r2)
 3221978:	10803fcc 	andi	r2,r2,255
 322197c:	1004923a 	slli	r2,r2,8
 3221980:	1884b03a 	or	r2,r3,r2
 3221984:	1007883a 	mov	r3,r2
 3221988:	e0bff817 	ldw	r2,-32(fp)
 322198c:	10c01115 	stw	r3,68(r2)
            ( ((int)((unsigned char)info->mac_addr[1]))         |
             (((int)((unsigned char)info->mac_addr[0])) << 8)   );


    //Enable MAC
    regs->moder = (
 3221990:	e0bffd17 	ldw	r2,-12(fp)
 3221994:	10a800d4 	ori	r2,r2,40963
 3221998:	1007883a 	mov	r3,r2
 322199c:	e0bff817 	ldw	r2,-32(fp)
 32219a0:	10c00015 	stw	r3,0(r2)
    #if (ETH_OCM_DBG_LVL >= 1)
    dprintf("\nOpencores MAC post-init: MODER = 0x%08x\n", (int)regs->moder);
    #endif // if ETH_OCM_DBG

   /* status = UP */
   nets[iface]->n_mib->ifAdminStatus = ETH_OCM_STATUS_UP;
 32219a4:	e0bfff17 	ldw	r2,-4(fp)
 32219a8:	00c0c9b4 	movhi	r3,806
 32219ac:	18f25a04 	addi	r3,r3,-13976
 32219b0:	1085883a 	add	r2,r2,r2
 32219b4:	1085883a 	add	r2,r2,r2
 32219b8:	10c5883a 	add	r2,r2,r3
 32219bc:	10800017 	ldw	r2,0(r2)
 32219c0:	10c02717 	ldw	r3,156(r2)
 32219c4:	00800044 	movi	r2,1
 32219c8:	18800615 	stw	r2,24(r3)
   nets[iface]->n_mib->ifOperStatus = ETH_OCM_STATUS_UP;
 32219cc:	e0bfff17 	ldw	r2,-4(fp)
 32219d0:	00c0c9b4 	movhi	r3,806
 32219d4:	18f25a04 	addi	r3,r3,-13976
 32219d8:	1085883a 	add	r2,r2,r2
 32219dc:	1085883a 	add	r2,r2,r2
 32219e0:	10c5883a 	add	r2,r2,r3
 32219e4:	10800017 	ldw	r2,0(r2)
 32219e8:	10c02717 	ldw	r3,156(r2)
 32219ec:	00800044 	movi	r2,1
 32219f0:	18800715 	stw	r2,28(r3)

   //register ISR interrupt handler
   temp = alt_irq_register(dev->irq, dev, eth_ocm_isr);
 32219f4:	e0bffa17 	ldw	r2,-24(fp)
 32219f8:	10800b03 	ldbu	r2,44(r2)
 32219fc:	11003fcc 	andi	r4,r2,255
 3221a00:	e17ffa17 	ldw	r5,-24(fp)
 3221a04:	0180c8b4 	movhi	r6,802
 3221a08:	3187d704 	addi	r6,r6,8028
 3221a0c:	323a9080 	call	323a908 <alt_irq_register>
 3221a10:	e0bffc15 	stw	r2,-16(fp)
   if(temp)
 3221a14:	e0bffc17 	ldw	r2,-16(fp)
 3221a18:	1005003a 	cmpeq	r2,r2,zero
 3221a1c:	1000031e 	bne	r2,zero,3221a2c <eth_ocm_init+0x374>
       dprintf("[eth_ocm_init] Failed to register RX ISR\n");
 3221a20:	0100c974 	movhi	r4,805
 3221a24:	21390804 	addi	r4,r4,-7136
 3221a28:	3206e040 	call	3206e04 <puts>
   //Setup the first read transfer
   eth_ocm_read_init(dev);
 3221a2c:	e13ffa17 	ldw	r4,-24(fp)
 3221a30:	32220500 	call	3222050 <eth_ocm_read_init>

   return status;   //MAC is ready to rock and roll
 3221a34:	e0bffe17 	ldw	r2,-8(fp)
}
 3221a38:	e037883a 	mov	sp,fp
 3221a3c:	dfc00117 	ldw	ra,4(sp)
 3221a40:	df000017 	ldw	fp,0(sp)
 3221a44:	dec00204 	addi	sp,sp,8
 3221a48:	f800283a 	ret

03221a4c <eth_ocm_pkt_send>:
//End of eth_ocm_init function


#ifndef ETH_OCM_SYNC_TX
int eth_ocm_pkt_send(PACKET pkt){
 3221a4c:	defff604 	addi	sp,sp,-40
 3221a50:	dfc00915 	stw	ra,36(sp)
 3221a54:	df000815 	stw	fp,32(sp)
 3221a58:	df000804 	addi	fp,sp,32
 3221a5c:	e13fff15 	stw	r4,-4(fp)
    int result;
#ifdef UCOS_II
    int cpu_sr;
#endif

    dev = (eth_ocm_dev *)pkt->net->n_local;
 3221a60:	e0bfff17 	ldw	r2,-4(fp)
 3221a64:	10800617 	ldw	r2,24(r2)
 3221a68:	10802817 	ldw	r2,160(r2)
 3221a6c:	e0bffe15 	stw	r2,-8(fp)
    info = dev->info;
 3221a70:	e0bffe17 	ldw	r2,-8(fp)
 3221a74:	10801117 	ldw	r2,68(r2)
 3221a78:	e0bffd15 	stw	r2,-12(fp)
    regs = dev->regs;
 3221a7c:	e0bffe17 	ldw	r2,-8(fp)
 3221a80:	10800a17 	ldw	r2,40(r2)
 3221a84:	e0bffc15 	stw	r2,-16(fp)
    result = SUCCESS;
 3221a88:	e03ffb15 	stw	zero,-20(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3221a8c:	0005303a 	rdctl	r2,status
 3221a90:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3221a94:	e0fff917 	ldw	r3,-28(fp)
 3221a98:	00bfff84 	movi	r2,-2
 3221a9c:	1884703a 	and	r2,r3,r2
 3221aa0:	1001703a 	wrctl	status,r2
  
  return context;
 3221aa4:	e0bff917 	ldw	r2,-28(fp)

    OS_ENTER_CRITICAL();    //disable interrupts
 3221aa8:	e0bffa15 	stw	r2,-24(fp)

    putq(&info->tosend, (qp)pkt);
 3221aac:	e0bffd17 	ldw	r2,-12(fp)
 3221ab0:	11000504 	addi	r4,r2,20
 3221ab4:	e17fff17 	ldw	r5,-4(fp)
 3221ab8:	322a51c0 	call	322a51c <putq>
    eth_ocm_tx_isr(dev);
 3221abc:	e13ffe17 	ldw	r4,-8(fp)
 3221ac0:	3221ca00 	call	3221ca0 <eth_ocm_tx_isr>
 3221ac4:	e0bffa17 	ldw	r2,-24(fp)
 3221ac8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3221acc:	e0bff817 	ldw	r2,-32(fp)
 3221ad0:	1001703a 	wrctl	status,r2
        putq(&info->tosend, (qp)pkt);
    }
    */

    OS_EXIT_CRITICAL();     //reenable interrupts
    return SUCCESS;
 3221ad4:	0005883a 	mov	r2,zero
}
 3221ad8:	e037883a 	mov	sp,fp
 3221adc:	dfc00117 	ldw	ra,4(sp)
 3221ae0:	df000017 	ldw	fp,0(sp)
 3221ae4:	dec00204 	addi	sp,sp,8
 3221ae8:	f800283a 	ret

03221aec <eth_ocm_low_send>:
 *  @param data
 *  @param data_bytes
 *
 *  @return 0 if Successful, negative otherwise
 */
int eth_ocm_low_send(NET net, char *data, unsigned data_bytes){
 3221aec:	defff404 	addi	sp,sp,-48
 3221af0:	dfc00b15 	stw	ra,44(sp)
 3221af4:	df000a15 	stw	fp,40(sp)
 3221af8:	df000a04 	addi	fp,sp,40
 3221afc:	e13ffc15 	stw	r4,-16(fp)
 3221b00:	e17ffd15 	stw	r5,-12(fp)
 3221b04:	e1bffe15 	stw	r6,-8(fp)
    eth_ocm_dev *dev;
    eth_ocm_info *info;
    eth_ocm_regs *regs;
    alt_u8 *buf;

    dev = (eth_ocm_dev *)net->n_local;
 3221b08:	e0bffc17 	ldw	r2,-16(fp)
 3221b0c:	10802817 	ldw	r2,160(r2)
 3221b10:	e0bff915 	stw	r2,-28(fp)
    info = dev->info;
 3221b14:	e0bff917 	ldw	r2,-28(fp)
 3221b18:	10801117 	ldw	r2,68(r2)
 3221b1c:	e0bff815 	stw	r2,-32(fp)
    regs = dev->regs;
 3221b20:	e0bff917 	ldw	r2,-28(fp)
 3221b24:	10800a17 	ldw	r2,40(r2)
 3221b28:	e0bff715 	stw	r2,-36(fp)
    len = data_bytes - ETHHDR_BIAS;
 3221b2c:	e0bffe17 	ldw	r2,-8(fp)
 3221b30:	10bfff84 	addi	r2,r2,-2
 3221b34:	e0bffa15 	stw	r2,-24(fp)
    result = SUCCESS;
 3221b38:	e03ffb15 	stw	zero,-20(fp)

    //Check to see if someone is nesting send calls (BAD!)
    if(info->sem){
 3221b3c:	e0bff817 	ldw	r2,-32(fp)
 3221b40:	10800303 	ldbu	r2,12(r2)
 3221b44:	10803fcc 	andi	r2,r2,255
 3221b48:	1005003a 	cmpeq	r2,r2,zero
 3221b4c:	1000061e 	bne	r2,zero,3221b68 <eth_ocm_low_send+0x7c>
       dprintf("[eth_ocm_low_send] ERROR: Nested low send call\n");
 3221b50:	0100c974 	movhi	r4,805
 3221b54:	21391304 	addi	r4,r4,-7092
 3221b58:	3206e040 	call	3206e04 <puts>
       return ENP_RESOURCE;
 3221b5c:	00bffa84 	movi	r2,-22
 3221b60:	e0bfff15 	stw	r2,-4(fp)
 3221b64:	00004806 	br	3221c88 <eth_ocm_low_send+0x19c>
    }
    //Grab the semaphore
    info->sem = 1;
 3221b68:	e0fff817 	ldw	r3,-32(fp)
 3221b6c:	00800044 	movi	r2,1
 3221b70:	18800305 	stb	r2,12(r3)
    // clear bit-31 before passing it to SGDMA Driver
    buf = (alt_u8 *)alt_remap_cached( (volatile void *)data, 4);
 3221b74:	e13ffd17 	ldw	r4,-12(fp)
 3221b78:	01400104 	movi	r5,4
 3221b7c:	323ac480 	call	323ac48 <alt_remap_cached>
 3221b80:	e0bff615 	stw	r2,-40(fp)
    //advance the pointer beyond the header bias
    buf = (alt_u8 *)((unsigned int)buf + ETHHDR_BIAS);
 3221b84:	e0bff617 	ldw	r2,-40(fp)
 3221b88:	10800084 	addi	r2,r2,2
 3221b8c:	e0bff615 	stw	r2,-40(fp)

    //Some error checks first
    if(len < ETH_OCM_MIN_MTU)
 3221b90:	e0bffa17 	ldw	r2,-24(fp)
 3221b94:	10800128 	cmpgeui	r2,r2,4
 3221b98:	1000021e 	bne	r2,zero,3221ba4 <eth_ocm_low_send+0xb8>
        result = -1;        //packet too small
 3221b9c:	00bfffc4 	movi	r2,-1
 3221ba0:	e0bffb15 	stw	r2,-20(fp)
    if(len > ETH_OCM_MAX_MTU)
 3221ba4:	e0bffa17 	ldw	r2,-24(fp)
 3221ba8:	10817bf0 	cmpltui	r2,r2,1519
 3221bac:	1000021e 	bne	r2,zero,3221bb8 <eth_ocm_low_send+0xcc>
        result = -EFBIG;    //packet too big
 3221bb0:	00bff944 	movi	r2,-27
 3221bb4:	e0bffb15 	stw	r2,-20(fp)
    if(regs->txdescs[info->next_tx_desc].ctrl & ETH_OCM_TXDESC_READY_MSK)
 3221bb8:	e0bff817 	ldw	r2,-32(fp)
 3221bbc:	10800f03 	ldbu	r2,60(r2)
 3221bc0:	10803fcc 	andi	r2,r2,255
 3221bc4:	e0fff717 	ldw	r3,-36(fp)
 3221bc8:	100490fa 	slli	r2,r2,3
 3221bcc:	10c5883a 	add	r2,r2,r3
 3221bd0:	10810004 	addi	r2,r2,1024
 3221bd4:	10800017 	ldw	r2,0(r2)
 3221bd8:	10a0000c 	andi	r2,r2,32768
 3221bdc:	1005003a 	cmpeq	r2,r2,zero
 3221be0:	1000021e 	bne	r2,zero,3221bec <eth_ocm_low_send+0x100>
        result = -EBUSY;    //DMA not available
 3221be4:	00bffc04 	movi	r2,-16
 3221be8:	e0bffb15 	stw	r2,-20(fp)

    if(result == SUCCESS){
 3221bec:	e0bffb17 	ldw	r2,-20(fp)
 3221bf0:	1004c03a 	cmpne	r2,r2,zero
 3221bf4:	1000201e 	bne	r2,zero,3221c78 <eth_ocm_low_send+0x18c>
        //Write pointer to descriptor
        regs->txdescs[info->next_tx_desc].ptr = (unsigned int)buf;
 3221bf8:	e0bff817 	ldw	r2,-32(fp)
 3221bfc:	10800f03 	ldbu	r2,60(r2)
 3221c00:	11003fcc 	andi	r4,r2,255
 3221c04:	e0bff617 	ldw	r2,-40(fp)
 3221c08:	100b883a 	mov	r5,r2
 3221c0c:	e0fff717 	ldw	r3,-36(fp)
 3221c10:	200490fa 	slli	r2,r4,3
 3221c14:	10c5883a 	add	r2,r2,r3
 3221c18:	10810104 	addi	r2,r2,1028
 3221c1c:	11400015 	stw	r5,0(r2)
        //Write length and setup transfer
        result = ((len << ETH_OCM_TXDESC_LEN_OFST)  |
 3221c20:	e0bffa17 	ldw	r2,-24(fp)
 3221c24:	1004943a 	slli	r2,r2,16
 3221c28:	10b60014 	ori	r2,r2,55296
 3221c2c:	e0bffb15 	stw	r2,-20(fp)
                 ETH_OCM_TXDESC_READY_MSK           |
                 ETH_OCM_TXDESC_IRQ_MSK             |
                 ETH_OCM_TXDESC_PAD_MSK             |
                 ETH_OCM_TXDESC_CRC_MSK);
        //See if wrap flag should be set
        if(info->next_tx_desc == (ETH_OCM_TX_DESC_COUNT - 1))
 3221c30:	e0bff817 	ldw	r2,-32(fp)
 3221c34:	10800f03 	ldbu	r2,60(r2)
 3221c38:	10803fcc 	andi	r2,r2,255
 3221c3c:	1004c03a 	cmpne	r2,r2,zero
 3221c40:	1000031e 	bne	r2,zero,3221c50 <eth_ocm_low_send+0x164>
            result |= ETH_OCM_TXDESC_WRAP_MSK;
 3221c44:	e0bffb17 	ldw	r2,-20(fp)
 3221c48:	10880014 	ori	r2,r2,8192
 3221c4c:	e0bffb15 	stw	r2,-20(fp)
        //Write descriptor
        regs->txdescs[info->next_tx_desc].ctrl = result;
 3221c50:	e0bff817 	ldw	r2,-32(fp)
 3221c54:	10800f03 	ldbu	r2,60(r2)
 3221c58:	10803fcc 	andi	r2,r2,255
 3221c5c:	e13ffb17 	ldw	r4,-20(fp)
 3221c60:	e0fff717 	ldw	r3,-36(fp)
 3221c64:	100490fa 	slli	r2,r2,3
 3221c68:	10c5883a 	add	r2,r2,r3
 3221c6c:	10810004 	addi	r2,r2,1024
 3221c70:	11000015 	stw	r4,0(r2)
        #if (ETH_OCM_DBG_LVL >= 5)
            dprintf("[eth_ocm_low_send] Sent packet with descriptor 0x%08x\n", result);
        #endif
        result = SUCCESS;
 3221c74:	e03ffb15 	stw	zero,-20(fp)
    }

    info->sem = 0;
 3221c78:	e0bff817 	ldw	r2,-32(fp)
 3221c7c:	10000305 	stb	zero,12(r2)
    return result;
 3221c80:	e0bffb17 	ldw	r2,-20(fp)
 3221c84:	e0bfff15 	stw	r2,-4(fp)
 3221c88:	e0bfff17 	ldw	r2,-4(fp)
}
 3221c8c:	e037883a 	mov	sp,fp
 3221c90:	dfc00117 	ldw	ra,4(sp)
 3221c94:	df000017 	ldw	fp,0(sp)
 3221c98:	dec00204 	addi	sp,sp,8
 3221c9c:	f800283a 	ret

03221ca0 <eth_ocm_tx_isr>:

void    eth_ocm_tx_isr(eth_ocm_dev *dev){
 3221ca0:	defff904 	addi	sp,sp,-28
 3221ca4:	dfc00615 	stw	ra,24(sp)
 3221ca8:	df000515 	stw	fp,20(sp)
 3221cac:	df000504 	addi	fp,sp,20
 3221cb0:	e13fff15 	stw	r4,-4(fp)
    eth_ocm_info *info;
    eth_ocm_regs *regs;
    int result;
    PACKET pkt;

    info = dev->info;
 3221cb4:	e0bfff17 	ldw	r2,-4(fp)
 3221cb8:	10801117 	ldw	r2,68(r2)
 3221cbc:	e0bffe15 	stw	r2,-8(fp)
    regs = dev->regs;
 3221cc0:	e0bfff17 	ldw	r2,-4(fp)
 3221cc4:	10800a17 	ldw	r2,40(r2)
 3221cc8:	e0bffd15 	stw	r2,-12(fp)

    //First we need to process all finished descriptors
    while(  info->sending.q_len>0 
 3221ccc:	00003c06 	br	3221dc0 <eth_ocm_tx_isr+0x120>
            && ((info->cur_tx_desc != info->next_tx_desc) || !info->next_tx_desc_rdy)
            && !(regs->txdescs[info->cur_tx_desc].ctrl & ETH_OCM_TXDESC_READY_MSK)){ 
    
        //Get the packet
        pkt = (PACKET)getq(&info->sending);
 3221cd0:	e0bffe17 	ldw	r2,-8(fp)
 3221cd4:	11000a04 	addi	r4,r2,40
 3221cd8:	322a4540 	call	322a454 <getq>
 3221cdc:	e0bffb15 	stw	r2,-20(fp)

        //Get transmit result from descriptor
        result = regs->txdescs[info->cur_tx_desc].ctrl;
 3221ce0:	e0bffe17 	ldw	r2,-8(fp)
 3221ce4:	10800343 	ldbu	r2,13(r2)
 3221ce8:	10803fcc 	andi	r2,r2,255
 3221cec:	e0fffd17 	ldw	r3,-12(fp)
 3221cf0:	100490fa 	slli	r2,r2,3
 3221cf4:	10c5883a 	add	r2,r2,r3
 3221cf8:	10810004 	addi	r2,r2,1024
 3221cfc:	10800017 	ldw	r2,0(r2)
 3221d00:	e0bffc15 	stw	r2,-16(fp)

        //Check for errors
        if(result & 
 3221d04:	e0bffc17 	ldw	r2,-16(fp)
 3221d08:	1080434c 	andi	r2,r2,269
 3221d0c:	1005003a 	cmpeq	r2,r2,zero
 3221d10:	1000071e 	bne	r2,zero,3221d30 <eth_ocm_tx_isr+0x90>
            ETH_OCM_TXDESC_LC_MSK       |
            ETH_OCM_TXDESC_CS_MSK)){
            #if (ETH_OCM_DBG_LVL >= 2)
            dprintf("[eth_ocm_tx_isr] Transmit error 0x%x\n", result);
            #endif // if ETH_OCM_DBG_LVL
            pkt->net->n_mib->ifOutDiscards++; //increment TX discard counter
 3221d14:	e0bffb17 	ldw	r2,-20(fp)
 3221d18:	10800617 	ldw	r2,24(r2)
 3221d1c:	10c02717 	ldw	r3,156(r2)
 3221d20:	18801217 	ldw	r2,72(r3)
 3221d24:	10800044 	addi	r2,r2,1
 3221d28:	18801215 	stw	r2,72(r3)
 3221d2c:	00001206 	br	3221d78 <eth_ocm_tx_isr+0xd8>
        else{
            #if (ETH_OCM_DBG_LVL >= 5)
            if(result & ETH_OCM_TXDESC_RTRY_MSK)
                dprintf("[eth_ocm_tx_isr] Transmit retries: %d\n", (result & ETH_OCM_TXDESC_RTRY_MSK)>>ETH_OCM_TXDESC_RTRY_OFST);
            #endif
            pkt->net->n_mib->ifOutOctets += pkt->nb_plen;
 3221d30:	e0bffb17 	ldw	r2,-20(fp)
 3221d34:	10800617 	ldw	r2,24(r2)
 3221d38:	11002717 	ldw	r4,156(r2)
 3221d3c:	e0bffb17 	ldw	r2,-20(fp)
 3221d40:	10800617 	ldw	r2,24(r2)
 3221d44:	10802717 	ldw	r2,156(r2)
 3221d48:	10c00f17 	ldw	r3,60(r2)
 3221d4c:	e0bffb17 	ldw	r2,-20(fp)
 3221d50:	10800417 	ldw	r2,16(r2)
 3221d54:	1885883a 	add	r2,r3,r2
 3221d58:	20800f15 	stw	r2,60(r4)
            pkt->net->n_mib->ifOutUcastPkts++;
 3221d5c:	e0bffb17 	ldw	r2,-20(fp)
 3221d60:	10800617 	ldw	r2,24(r2)
 3221d64:	10c02717 	ldw	r3,156(r2)
 3221d68:	18801017 	ldw	r2,64(r3)
 3221d6c:	10800044 	addi	r2,r2,1
 3221d70:	18801015 	stw	r2,64(r3)
            result = 0;
 3221d74:	e03ffc15 	stw	zero,-16(fp)
        }

        //free the packet
        pk_free(pkt);
 3221d78:	e13ffb17 	ldw	r4,-20(fp)
 3221d7c:	322a2dc0 	call	322a2dc <pk_free>

        //Increment the current descriptor pointer
        info->cur_tx_desc++;
 3221d80:	e0bffe17 	ldw	r2,-8(fp)
 3221d84:	10800343 	ldbu	r2,13(r2)
 3221d88:	10800044 	addi	r2,r2,1
 3221d8c:	1007883a 	mov	r3,r2
 3221d90:	e0bffe17 	ldw	r2,-8(fp)
 3221d94:	10c00345 	stb	r3,13(r2)
        if(info->cur_tx_desc == ETH_OCM_TX_DESC_COUNT)
 3221d98:	e0bffe17 	ldw	r2,-8(fp)
 3221d9c:	10800343 	ldbu	r2,13(r2)
 3221da0:	10803fcc 	andi	r2,r2,255
 3221da4:	10800058 	cmpnei	r2,r2,1
 3221da8:	1000021e 	bne	r2,zero,3221db4 <eth_ocm_tx_isr+0x114>
            info->cur_tx_desc = 0;
 3221dac:	e0bffe17 	ldw	r2,-8(fp)
 3221db0:	10000345 	stb	zero,13(r2)
        //Whatever the next descriptor is it's ready now
        info->next_tx_desc_rdy = 1;
 3221db4:	e0fffe17 	ldw	r3,-8(fp)
 3221db8:	00800044 	movi	r2,1
 3221dbc:	18800f45 	stb	r2,61(r3)

    info = dev->info;
    regs = dev->regs;

    //First we need to process all finished descriptors
    while(  info->sending.q_len>0 
 3221dc0:	e0bffe17 	ldw	r2,-8(fp)
 3221dc4:	10800c17 	ldw	r2,48(r2)
 3221dc8:	10800050 	cmplti	r2,r2,1
 3221dcc:	10004a1e 	bne	r2,zero,3221ef8 <eth_ocm_tx_isr+0x258>
 3221dd0:	e0bffe17 	ldw	r2,-8(fp)
 3221dd4:	10c00343 	ldbu	r3,13(r2)
 3221dd8:	e0bffe17 	ldw	r2,-8(fp)
 3221ddc:	10800f03 	ldbu	r2,60(r2)
 3221de0:	18c03fcc 	andi	r3,r3,255
 3221de4:	10803fcc 	andi	r2,r2,255
 3221de8:	1880051e 	bne	r3,r2,3221e00 <eth_ocm_tx_isr+0x160>
 3221dec:	e0bffe17 	ldw	r2,-8(fp)
 3221df0:	10800f43 	ldbu	r2,61(r2)
 3221df4:	10803fcc 	andi	r2,r2,255
 3221df8:	1004c03a 	cmpne	r2,r2,zero
 3221dfc:	10003e1e 	bne	r2,zero,3221ef8 <eth_ocm_tx_isr+0x258>
 3221e00:	e0bffe17 	ldw	r2,-8(fp)
 3221e04:	10800343 	ldbu	r2,13(r2)
 3221e08:	10803fcc 	andi	r2,r2,255
 3221e0c:	e0fffd17 	ldw	r3,-12(fp)
 3221e10:	100490fa 	slli	r2,r2,3
 3221e14:	10c5883a 	add	r2,r2,r3
 3221e18:	10810004 	addi	r2,r2,1024
 3221e1c:	10800017 	ldw	r2,0(r2)
 3221e20:	10a0000c 	andi	r2,r2,32768
 3221e24:	1005003a 	cmpeq	r2,r2,zero
 3221e28:	103fa91e 	bne	r2,zero,3221cd0 <eth_ocm_tx_isr+0x30>
        //Whatever the next descriptor is it's ready now
        info->next_tx_desc_rdy = 1;
    }

    //Now we can send any queued packets
    while( info->next_tx_desc_rdy
 3221e2c:	00003206 	br	3221ef8 <eth_ocm_tx_isr+0x258>
            && info->tosend.q_len>0
            && !(regs->txdescs[info->next_tx_desc].ctrl & ETH_OCM_TXDESC_READY_MSK) ){

        //Get the packet to be send
        pkt = (PACKET)getq(&info->tosend);
 3221e30:	e0bffe17 	ldw	r2,-8(fp)
 3221e34:	11000504 	addi	r4,r2,20
 3221e38:	322a4540 	call	322a454 <getq>
 3221e3c:	e0bffb15 	stw	r2,-20(fp)

        result = eth_ocm_low_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 3221e40:	e0bffb17 	ldw	r2,-20(fp)
 3221e44:	11000617 	ldw	r4,24(r2)
 3221e48:	e0bffb17 	ldw	r2,-20(fp)
 3221e4c:	11400317 	ldw	r5,12(r2)
 3221e50:	e0bffb17 	ldw	r2,-20(fp)
 3221e54:	11800417 	ldw	r6,16(r2)
 3221e58:	3221aec0 	call	3221aec <eth_ocm_low_send>
 3221e5c:	e0bffc15 	stw	r2,-16(fp)
        //If setup failed, free the packet and move on.
        if(result != SUCCESS){
 3221e60:	e0bffc17 	ldw	r2,-16(fp)
 3221e64:	1005003a 	cmpeq	r2,r2,zero
 3221e68:	1000091e 	bne	r2,zero,3221e90 <eth_ocm_tx_isr+0x1f0>
            pkt->net->n_mib->ifOutDiscards++;
 3221e6c:	e0bffb17 	ldw	r2,-20(fp)
 3221e70:	10800617 	ldw	r2,24(r2)
 3221e74:	10c02717 	ldw	r3,156(r2)
 3221e78:	18801217 	ldw	r2,72(r3)
 3221e7c:	10800044 	addi	r2,r2,1
 3221e80:	18801215 	stw	r2,72(r3)
            pk_free(pkt);
 3221e84:	e13ffb17 	ldw	r4,-20(fp)
 3221e88:	322a2dc0 	call	322a2dc <pk_free>
 3221e8c:	00001a06 	br	3221ef8 <eth_ocm_tx_isr+0x258>
        }
        else{ //Transfer was successfully setup
            info->next_tx_desc++;
 3221e90:	e0bffe17 	ldw	r2,-8(fp)
 3221e94:	10800f03 	ldbu	r2,60(r2)
 3221e98:	10800044 	addi	r2,r2,1
 3221e9c:	1007883a 	mov	r3,r2
 3221ea0:	e0bffe17 	ldw	r2,-8(fp)
 3221ea4:	10c00f05 	stb	r3,60(r2)
            if(info->next_tx_desc == ETH_OCM_TX_DESC_COUNT)
 3221ea8:	e0bffe17 	ldw	r2,-8(fp)
 3221eac:	10800f03 	ldbu	r2,60(r2)
 3221eb0:	10803fcc 	andi	r2,r2,255
 3221eb4:	10800058 	cmpnei	r2,r2,1
 3221eb8:	1000021e 	bne	r2,zero,3221ec4 <eth_ocm_tx_isr+0x224>
                info->next_tx_desc = 0;
 3221ebc:	e0bffe17 	ldw	r2,-8(fp)
 3221ec0:	10000f05 	stb	zero,60(r2)
            //See if all descriptor are in use
            if(info->next_tx_desc == info->cur_tx_desc)
 3221ec4:	e0bffe17 	ldw	r2,-8(fp)
 3221ec8:	10c00f03 	ldbu	r3,60(r2)
 3221ecc:	e0bffe17 	ldw	r2,-8(fp)
 3221ed0:	10800343 	ldbu	r2,13(r2)
 3221ed4:	18c03fcc 	andi	r3,r3,255
 3221ed8:	10803fcc 	andi	r2,r2,255
 3221edc:	1880021e 	bne	r3,r2,3221ee8 <eth_ocm_tx_isr+0x248>
                info->next_tx_desc_rdy = 0;
 3221ee0:	e0bffe17 	ldw	r2,-8(fp)
 3221ee4:	10000f45 	stb	zero,61(r2)
            //Put the packet in the sending queue
            putq(&info->sending, (qp)pkt);
 3221ee8:	e0bffe17 	ldw	r2,-8(fp)
 3221eec:	11000a04 	addi	r4,r2,40
 3221ef0:	e17ffb17 	ldw	r5,-20(fp)
 3221ef4:	322a51c0 	call	322a51c <putq>
        //Whatever the next descriptor is it's ready now
        info->next_tx_desc_rdy = 1;
    }

    //Now we can send any queued packets
    while( info->next_tx_desc_rdy
 3221ef8:	e0bffe17 	ldw	r2,-8(fp)
 3221efc:	10800f43 	ldbu	r2,61(r2)
 3221f00:	10803fcc 	andi	r2,r2,255
 3221f04:	1005003a 	cmpeq	r2,r2,zero
 3221f08:	10000f1e 	bne	r2,zero,3221f48 <eth_ocm_tx_isr+0x2a8>
 3221f0c:	e0bffe17 	ldw	r2,-8(fp)
 3221f10:	10800717 	ldw	r2,28(r2)
 3221f14:	10800050 	cmplti	r2,r2,1
 3221f18:	10000b1e 	bne	r2,zero,3221f48 <eth_ocm_tx_isr+0x2a8>
 3221f1c:	e0bffe17 	ldw	r2,-8(fp)
 3221f20:	10800f03 	ldbu	r2,60(r2)
 3221f24:	10803fcc 	andi	r2,r2,255
 3221f28:	e0fffd17 	ldw	r3,-12(fp)
 3221f2c:	100490fa 	slli	r2,r2,3
 3221f30:	10c5883a 	add	r2,r2,r3
 3221f34:	10810004 	addi	r2,r2,1024
 3221f38:	10800017 	ldw	r2,0(r2)
 3221f3c:	10a0000c 	andi	r2,r2,32768
 3221f40:	1005003a 	cmpeq	r2,r2,zero
 3221f44:	103fba1e 	bne	r2,zero,3221e30 <eth_ocm_tx_isr+0x190>
                info->next_tx_desc_rdy = 0;
            //Put the packet in the sending queue
            putq(&info->sending, (qp)pkt);
        }
    }
}
 3221f48:	e037883a 	mov	sp,fp
 3221f4c:	dfc00117 	ldw	ra,4(sp)
 3221f50:	df000017 	ldw	fp,0(sp)
 3221f54:	dec00204 	addi	sp,sp,8
 3221f58:	f800283a 	ret

03221f5c <eth_ocm_isr>:
 * Receive ISR (interrupt service routine)
 *
 * @param  context  - context of the Opencores MAC instance
 * @param  id       - IRQ number 
 */
void eth_ocm_isr(void *context, alt_u32 id){
 3221f5c:	defff904 	addi	sp,sp,-28
 3221f60:	dfc00615 	stw	ra,24(sp)
 3221f64:	df000515 	stw	fp,20(sp)
 3221f68:	df000504 	addi	fp,sp,20
 3221f6c:	e13ffe15 	stw	r4,-8(fp)
 3221f70:	e17fff15 	stw	r5,-4(fp)
    eth_ocm_dev *dev;
    eth_ocm_regs *regs;
    int result;

    dev = (eth_ocm_dev *)context;
 3221f74:	e0bffe17 	ldw	r2,-8(fp)
 3221f78:	e0bffd15 	stw	r2,-12(fp)
    regs = dev->regs;
 3221f7c:	e0bffd17 	ldw	r2,-12(fp)
 3221f80:	10800a17 	ldw	r2,40(r2)
 3221f84:	e0bffc15 	stw	r2,-16(fp)

    //Read the interrupt source
    result = regs->int_source;
 3221f88:	e0bffc17 	ldw	r2,-16(fp)
 3221f8c:	10800117 	ldw	r2,4(r2)
 3221f90:	e0bffb15 	stw	r2,-20(fp)
    while(result){
 3221f94:	00002606 	br	3222030 <eth_ocm_isr+0xd4>
        //Clear interrupt flags immediately. Only clear the ones that
        //have been set. We do this in case another one has occured since
        //we read it.
        regs->int_source = result;  //clear interrupts
 3221f98:	e0fffb17 	ldw	r3,-20(fp)
 3221f9c:	e0bffc17 	ldw	r2,-16(fp)
 3221fa0:	10c00115 	stw	r3,4(r2)

        //Check for receive flags
        if(result & (ETH_OCM_INT_MASK_RXB_MSK | ETH_OCM_INT_MASK_RXE_MSK)){
 3221fa4:	e0bffb17 	ldw	r2,-20(fp)
 3221fa8:	1080030c 	andi	r2,r2,12
 3221fac:	1005003a 	cmpeq	r2,r2,zero
 3221fb0:	10000b1e 	bne	r2,zero,3221fe0 <eth_ocm_isr+0x84>
            //Call the receive function. This will set up a new transfer
            eth_ocm_rx_isr(dev);
 3221fb4:	e13ffd17 	ldw	r4,-12(fp)
 3221fb8:	322222c0 	call	322222c <eth_ocm_rx_isr>
            //Check to see if there is something in the stack's received queue
            if ((rcvdq.q_len) > 0){
 3221fbc:	0080c9b4 	movhi	r2,806
 3221fc0:	10b19504 	addi	r2,r2,-14764
 3221fc4:	10800217 	ldw	r2,8(r2)
 3221fc8:	10800050 	cmplti	r2,r2,1
 3221fcc:	1000041e 	bne	r2,zero,3221fe0 <eth_ocm_isr+0x84>
                SignalPktDemux(); 
 3221fd0:	0080c974 	movhi	r2,805
 3221fd4:	10925904 	addi	r2,r2,18788
 3221fd8:	11000017 	ldw	r4,0(r2)
 3221fdc:	321b1dc0 	call	321b1dc <OSSemPost>
            }
        }
       
        //Check for busy flag
        if(result & ETH_OCM_INT_MASK_BUSY_MSK){
 3221fe0:	e0bffb17 	ldw	r2,-20(fp)
 3221fe4:	1080040c 	andi	r2,r2,16
 3221fe8:	1005003a 	cmpeq	r2,r2,zero
 3221fec:	1000071e 	bne	r2,zero,322200c <eth_ocm_isr+0xb0>
        #if (ETH_OCM_DBG_LVL >= 3)        
            dprintf("Frame dropped: too busy to receive\n");
        #endif
            dev->info->netp->n_mib->ifInDiscards++;
 3221ff0:	e0bffd17 	ldw	r2,-12(fp)
 3221ff4:	10801117 	ldw	r2,68(r2)
 3221ff8:	10800217 	ldw	r2,8(r2)
 3221ffc:	10c02717 	ldw	r3,156(r2)
 3222000:	18800c17 	ldw	r2,48(r3)
 3222004:	10800044 	addi	r2,r2,1
 3222008:	18800c15 	stw	r2,48(r3)
        }

        #ifndef ETH_OCM_SYNC_TX
        //Check for transmit flags
        if(result & (ETH_OCM_INT_MASK_TXE_MSK | ETH_OCM_INT_MASK_TXB_MSK)){
 322200c:	e0bffb17 	ldw	r2,-20(fp)
 3222010:	108000cc 	andi	r2,r2,3
 3222014:	1005003a 	cmpeq	r2,r2,zero
 3222018:	1000021e 	bne	r2,zero,3222024 <eth_ocm_isr+0xc8>
            eth_ocm_tx_isr(dev);
 322201c:	e13ffd17 	ldw	r4,-12(fp)
 3222020:	3221ca00 	call	3221ca0 <eth_ocm_tx_isr>
        }
        #endif //ifndef ETH_OCM_SYNC_TX


        //See if any interrupts have been set
        result = regs->int_source;
 3222024:	e0bffc17 	ldw	r2,-16(fp)
 3222028:	10800117 	ldw	r2,4(r2)
 322202c:	e0bffb15 	stw	r2,-20(fp)
    dev = (eth_ocm_dev *)context;
    regs = dev->regs;

    //Read the interrupt source
    result = regs->int_source;
    while(result){
 3222030:	e0bffb17 	ldw	r2,-20(fp)
 3222034:	1004c03a 	cmpne	r2,r2,zero
 3222038:	103fd71e 	bne	r2,zero,3221f98 <eth_ocm_isr+0x3c>


        //See if any interrupts have been set
        result = regs->int_source;
    }
}
 322203c:	e037883a 	mov	sp,fp
 3222040:	dfc00117 	ldw	ra,4(sp)
 3222044:	df000017 	ldw	fp,0(sp)
 3222048:	dec00204 	addi	sp,sp,8
 322204c:	f800283a 	ret

03222050 <eth_ocm_read_init>:


/**
 *  Set up the first receive transfer
 */
static int eth_ocm_read_init(eth_ocm_dev *dev){
 3222050:	defff504 	addi	sp,sp,-44
 3222054:	dfc00a15 	stw	ra,40(sp)
 3222058:	df000915 	stw	fp,36(sp)
 322205c:	dc000815 	stw	r16,32(sp)
 3222060:	df000804 	addi	fp,sp,32
 3222064:	e13ffe15 	stw	r4,-8(fp)
    alt_u8 *buf_ptr;
    PACKET *pkts;
    alt_u32 temp;
    int i;

    info = dev->info;
 3222068:	e0bffe17 	ldw	r2,-8(fp)
 322206c:	10801117 	ldw	r2,68(r2)
 3222070:	e0bffd15 	stw	r2,-12(fp)
    regs = dev->regs;
 3222074:	e0bffe17 	ldw	r2,-8(fp)
 3222078:	10800a17 	ldw	r2,40(r2)
 322207c:	e0bffc15 	stw	r2,-16(fp)
    pkts = info->rx_pkts;
 3222080:	e0bffd17 	ldw	r2,-12(fp)
 3222084:	10800417 	ldw	r2,16(r2)
 3222088:	e0bffa15 	stw	r2,-24(fp)


    //allocate a packet for every descriptor
    for(i=0;i<ETH_OCM_RX_DESC_COUNT;i++){
 322208c:	e03ff815 	stw	zero,-32(fp)
 3222090:	00005b06 	br	3222200 <eth_ocm_read_init+0x1b0>
        pkts[i] = pk_alloc(ETH_OCM_BUF_ALLOC_SIZE);
 3222094:	e0bff817 	ldw	r2,-32(fp)
 3222098:	1085883a 	add	r2,r2,r2
 322209c:	1085883a 	add	r2,r2,r2
 32220a0:	1007883a 	mov	r3,r2
 32220a4:	e0bffa17 	ldw	r2,-24(fp)
 32220a8:	18a1883a 	add	r16,r3,r2
 32220ac:	01018004 	movi	r4,1536
 32220b0:	3229f480 	call	3229f48 <pk_alloc>
 32220b4:	80800015 	stw	r2,0(r16)
        if (!pkts[i]){  // couldn't get a free buffer for rx 
 32220b8:	e0bff817 	ldw	r2,-32(fp)
 32220bc:	1085883a 	add	r2,r2,r2
 32220c0:	1085883a 	add	r2,r2,r2
 32220c4:	1007883a 	mov	r3,r2
 32220c8:	e0bffa17 	ldw	r2,-24(fp)
 32220cc:	1885883a 	add	r2,r3,r2
 32220d0:	10800017 	ldw	r2,0(r2)
 32220d4:	1004c03a 	cmpne	r2,r2,zero
 32220d8:	1000061e 	bne	r2,zero,32220f4 <eth_ocm_read_init+0xa4>
            dprintf("[eth_ocm_read_init] Fatal error: Unable to allocte ETH_OCM_RX_DESC_COUNT buffers\n");
 32220dc:	0100c974 	movhi	r4,805
 32220e0:	21391f04 	addi	r4,r4,-7044
 32220e4:	3206e040 	call	3206e04 <puts>
            return ENP_NOBUFFER;
 32220e8:	00bffac4 	movi	r2,-21
 32220ec:	e0bfff15 	stw	r2,-4(fp)
 32220f0:	00004706 	br	3222210 <eth_ocm_read_init+0x1c0>
        }

        // ensure bit-31 of pkt_array[i]->nb_buff is clear before passing
        buf_ptr = (alt_u8*)alt_remap_cached ((volatile void*) pkts[i]->nb_buff, 4);
 32220f4:	e0bff817 	ldw	r2,-32(fp)
 32220f8:	1085883a 	add	r2,r2,r2
 32220fc:	1085883a 	add	r2,r2,r2
 3222100:	1007883a 	mov	r3,r2
 3222104:	e0bffa17 	ldw	r2,-24(fp)
 3222108:	1885883a 	add	r2,r3,r2
 322210c:	10800017 	ldw	r2,0(r2)
 3222110:	11000117 	ldw	r4,4(r2)
 3222114:	01400104 	movi	r5,4
 3222118:	323ac480 	call	323ac48 <alt_remap_cached>
 322211c:	e0bffb15 	stw	r2,-20(fp)
        //shift the actual write location over by ETHHDR_BIAS (see ipport.h)
        buf_ptr = (alt_u8*)(((unsigned int)buf_ptr) + ETHHDR_BIAS);
 3222120:	e0bffb17 	ldw	r2,-20(fp)
 3222124:	10800084 	addi	r2,r2,2
 3222128:	e0bffb15 	stw	r2,-20(fp)

        if(!(regs->rxdescs[i].ctrl & ETH_OCM_RXDESC_EMPTY_MSK)){
 322212c:	e0bff817 	ldw	r2,-32(fp)
 3222130:	e0fffc17 	ldw	r3,-16(fp)
 3222134:	100490fa 	slli	r2,r2,3
 3222138:	10c5883a 	add	r2,r2,r3
 322213c:	10810204 	addi	r2,r2,1032
 3222140:	10800017 	ldw	r2,0(r2)
 3222144:	10a0000c 	andi	r2,r2,32768
 3222148:	1004c03a 	cmpne	r2,r2,zero
 322214c:	10001b1e 	bne	r2,zero,32221bc <eth_ocm_read_init+0x16c>
            //Write pointer
            regs->rxdescs[i].ptr = (alt_u32)buf_ptr;
 3222150:	e13ff817 	ldw	r4,-32(fp)
 3222154:	e0bffb17 	ldw	r2,-20(fp)
 3222158:	100b883a 	mov	r5,r2
 322215c:	e0fffc17 	ldw	r3,-16(fp)
 3222160:	200490fa 	slli	r2,r4,3
 3222164:	10c5883a 	add	r2,r2,r3
 3222168:	10810304 	addi	r2,r2,1036
 322216c:	11400015 	stw	r5,0(r2)
            //Write the control register to start the transfer
            temp = ETH_OCM_RXDESC_EMPTY_MSK | ETH_OCM_RXDESC_IRQ_MSK;
 3222170:	00b00014 	movui	r2,49152
 3222174:	e0bff915 	stw	r2,-28(fp)
            if(i == (ETH_OCM_RX_DESC_COUNT - 1))
 3222178:	e0bff817 	ldw	r2,-32(fp)
 322217c:	1004c03a 	cmpne	r2,r2,zero
 3222180:	1000031e 	bne	r2,zero,3222190 <eth_ocm_read_init+0x140>
                temp |= ETH_OCM_RXDESC_WRAP_MSK;
 3222184:	e0bff917 	ldw	r2,-28(fp)
 3222188:	10880014 	ori	r2,r2,8192
 322218c:	e0bff915 	stw	r2,-28(fp)
            regs->rxdescs[i].ctrl = temp; 
 3222190:	e0bff817 	ldw	r2,-32(fp)
 3222194:	e0fffc17 	ldw	r3,-16(fp)
 3222198:	100490fa 	slli	r2,r2,3
 322219c:	10c5883a 	add	r2,r2,r3
 32221a0:	10c10204 	addi	r3,r2,1032
 32221a4:	e0bff917 	ldw	r2,-28(fp)
 32221a8:	18800015 	stw	r2,0(r3)
    regs = dev->regs;
    pkts = info->rx_pkts;


    //allocate a packet for every descriptor
    for(i=0;i<ETH_OCM_RX_DESC_COUNT;i++){
 32221ac:	e0bff817 	ldw	r2,-32(fp)
 32221b0:	10800044 	addi	r2,r2,1
 32221b4:	e0bff815 	stw	r2,-32(fp)
 32221b8:	00001106 	br	3222200 <eth_ocm_read_init+0x1b0>
            if(i == (ETH_OCM_RX_DESC_COUNT - 1))
                temp |= ETH_OCM_RXDESC_WRAP_MSK;
            regs->rxdescs[i].ctrl = temp; 
        }
        else{
            dprintf("[eth_ocm_read_init] Fatal error: RX descriptor unavailable.\n");
 32221bc:	0100c974 	movhi	r4,805
 32221c0:	21393404 	addi	r4,r4,-6960
 32221c4:	3206e040 	call	3206e04 <puts>
            dprintf("[eth_ocm_read_init] Descriptor %u = 0x%08x\n", i, (int)regs->rxdescs[i].ctrl);
 32221c8:	e0bff817 	ldw	r2,-32(fp)
 32221cc:	e0fffc17 	ldw	r3,-16(fp)
 32221d0:	100490fa 	slli	r2,r2,3
 32221d4:	10c5883a 	add	r2,r2,r3
 32221d8:	10810204 	addi	r2,r2,1032
 32221dc:	10800017 	ldw	r2,0(r2)
 32221e0:	100d883a 	mov	r6,r2
 32221e4:	0100c974 	movhi	r4,805
 32221e8:	21394304 	addi	r4,r4,-6900
 32221ec:	e17ff817 	ldw	r5,-32(fp)
 32221f0:	3206adc0 	call	3206adc <printf>
            return ENP_RESOURCE;
 32221f4:	00bffa84 	movi	r2,-22
 32221f8:	e0bfff15 	stw	r2,-4(fp)
 32221fc:	00000406 	br	3222210 <eth_ocm_read_init+0x1c0>
    regs = dev->regs;
    pkts = info->rx_pkts;


    //allocate a packet for every descriptor
    for(i=0;i<ETH_OCM_RX_DESC_COUNT;i++){
 3222200:	e0bff817 	ldw	r2,-32(fp)
 3222204:	10800050 	cmplti	r2,r2,1
 3222208:	103fa21e 	bne	r2,zero,3222094 <eth_ocm_read_init+0x44>
            dprintf("[eth_ocm_read_init] Descriptor %u = 0x%08x\n", i, (int)regs->rxdescs[i].ctrl);
            return ENP_RESOURCE;
        }
    }

    return SUCCESS;
 322220c:	e03fff15 	stw	zero,-4(fp)
 3222210:	e0bfff17 	ldw	r2,-4(fp)
}
 3222214:	e037883a 	mov	sp,fp
 3222218:	dfc00217 	ldw	ra,8(sp)
 322221c:	df000117 	ldw	fp,4(sp)
 3222220:	dc000017 	ldw	r16,0(sp)
 3222224:	dec00304 	addi	sp,sp,12
 3222228:	f800283a 	ret

0322222c <eth_ocm_rx_isr>:
 * Schedules another RX transfer
 *
 * @return SUCCESS on success
 */
static int eth_ocm_rx_isr(eth_ocm_dev *dev)
{
 322222c:	defff404 	addi	sp,sp,-48
 3222230:	dfc00b15 	stw	ra,44(sp)
 3222234:	df000a15 	stw	fp,40(sp)
 3222238:	df000a04 	addi	fp,sp,40
 322223c:	e13fff15 	stw	r4,-4(fp)
    alt_u8 cur;
    PACKET pkt;
    PACKET *pkts;
    alt_u8 *buf_ptr;

    info = dev->info;
 3222240:	e0bfff17 	ldw	r2,-4(fp)
 3222244:	10801117 	ldw	r2,68(r2)
 3222248:	e0bffe15 	stw	r2,-8(fp)
    regs = dev->regs;
 322224c:	e0bfff17 	ldw	r2,-4(fp)
 3222250:	10800a17 	ldw	r2,40(r2)
 3222254:	e0bffd15 	stw	r2,-12(fp)
    pkts = info->rx_pkts;
 3222258:	e0bffe17 	ldw	r2,-8(fp)
 322225c:	10800417 	ldw	r2,16(r2)
 3222260:	e0bff715 	stw	r2,-36(fp)
    cur = info->cur_rx_desc;
 3222264:	e0bffe17 	ldw	r2,-8(fp)
 3222268:	10800383 	ldbu	r2,14(r2)
 322226c:	e0bff905 	stb	r2,-28(fp)

    stat = regs->rxdescs[cur].ctrl;
 3222270:	e0bff903 	ldbu	r2,-28(fp)
 3222274:	e0fffd17 	ldw	r3,-12(fp)
 3222278:	100490fa 	slli	r2,r2,3
 322227c:	10c5883a 	add	r2,r2,r3
 3222280:	10810204 	addi	r2,r2,1032
 3222284:	10800017 	ldw	r2,0(r2)
 3222288:	e0bffa15 	stw	r2,-24(fp)

    //We'll process as many descriptors as are ready
    while(!(stat & ETH_OCM_RXDESC_EMPTY_MSK)){
 322228c:	0000b106 	br	3222554 <eth_ocm_rx_isr+0x328>

        #if (ETH_OCM_DBG_LVL >= 5)
        dprintf("[eth_ocm_rx_isr] Received packet with status 0x%08x\n",stat);
        #endif // if ETH_OCM_DBG_LVL

        pklen = stat & ETH_OCM_RXDESC_LEN_MSK;
 3222290:	e0bffa17 	ldw	r2,-24(fp)
 3222294:	10bfffec 	andhi	r2,r2,65535
 3222298:	e0bffb15 	stw	r2,-20(fp)
        pklen = pklen >> ETH_OCM_RXDESC_LEN_OFST;
 322229c:	e0bffb17 	ldw	r2,-20(fp)
 32222a0:	1005d43a 	srai	r2,r2,16
 32222a4:	e0bffb15 	stw	r2,-20(fp)

        //Increment received byte count
        info->netp->n_mib->ifInOctets += (u_long)pklen;
 32222a8:	e0bffe17 	ldw	r2,-8(fp)
 32222ac:	10800217 	ldw	r2,8(r2)
 32222b0:	11002717 	ldw	r4,156(r2)
 32222b4:	e0bffe17 	ldw	r2,-8(fp)
 32222b8:	10800217 	ldw	r2,8(r2)
 32222bc:	10802717 	ldw	r2,156(r2)
 32222c0:	10c00917 	ldw	r3,36(r2)
 32222c4:	e0bffb17 	ldw	r2,-20(fp)
 32222c8:	1885883a 	add	r2,r3,r2
 32222cc:	20800915 	stw	r2,36(r4)

        pkts[cur]->nb_prot = pkts[cur]->nb_buff + ETHHDR_SIZE;
 32222d0:	e0bff903 	ldbu	r2,-28(fp)
 32222d4:	1085883a 	add	r2,r2,r2
 32222d8:	1085883a 	add	r2,r2,r2
 32222dc:	1007883a 	mov	r3,r2
 32222e0:	e0bff717 	ldw	r2,-36(fp)
 32222e4:	1885883a 	add	r2,r3,r2
 32222e8:	11000017 	ldw	r4,0(r2)
 32222ec:	e0bff903 	ldbu	r2,-28(fp)
 32222f0:	1085883a 	add	r2,r2,r2
 32222f4:	1085883a 	add	r2,r2,r2
 32222f8:	1007883a 	mov	r3,r2
 32222fc:	e0bff717 	ldw	r2,-36(fp)
 3222300:	1885883a 	add	r2,r3,r2
 3222304:	10800017 	ldw	r2,0(r2)
 3222308:	10800117 	ldw	r2,4(r2)
 322230c:	10800404 	addi	r2,r2,16
 3222310:	20800315 	stw	r2,12(r4)
        pkts[cur]->nb_plen = pklen - (14 + 4); //Packet length minus (header + CRC)
 3222314:	e0bff903 	ldbu	r2,-28(fp)
 3222318:	1085883a 	add	r2,r2,r2
 322231c:	1085883a 	add	r2,r2,r2
 3222320:	1007883a 	mov	r3,r2
 3222324:	e0bff717 	ldw	r2,-36(fp)
 3222328:	1885883a 	add	r2,r3,r2
 322232c:	10c00017 	ldw	r3,0(r2)
 3222330:	e0bffb17 	ldw	r2,-20(fp)
 3222334:	10bffb84 	addi	r2,r2,-18
 3222338:	18800415 	stw	r2,16(r3)
        pkts[cur]->nb_tstamp = cticks;
 322233c:	e0bff903 	ldbu	r2,-28(fp)
 3222340:	1085883a 	add	r2,r2,r2
 3222344:	1085883a 	add	r2,r2,r2
 3222348:	1007883a 	mov	r3,r2
 322234c:	e0bff717 	ldw	r2,-36(fp)
 3222350:	1885883a 	add	r2,r3,r2
 3222354:	10c00017 	ldw	r3,0(r2)
 3222358:	0080c974 	movhi	r2,805
 322235c:	10925604 	addi	r2,r2,18776
 3222360:	10800017 	ldw	r2,0(r2)
 3222364:	18800515 	stw	r2,20(r3)
        pkts[cur]->net = info->netp;
 3222368:	e0bff903 	ldbu	r2,-28(fp)
 322236c:	1085883a 	add	r2,r2,r2
 3222370:	1085883a 	add	r2,r2,r2
 3222374:	1007883a 	mov	r3,r2
 3222378:	e0bff717 	ldw	r2,-36(fp)
 322237c:	1885883a 	add	r2,r3,r2
 3222380:	10c00017 	ldw	r3,0(r2)
 3222384:	e0bffe17 	ldw	r2,-8(fp)
 3222388:	10800217 	ldw	r2,8(r2)
 322238c:	18800615 	stw	r2,24(r3)

        // set packet type for demux routine
        eth = (struct ethhdr *)(pkts[cur]->nb_buff + ETHHDR_BIAS);
 3222390:	e0bff903 	ldbu	r2,-28(fp)
 3222394:	1085883a 	add	r2,r2,r2
 3222398:	1085883a 	add	r2,r2,r2
 322239c:	1007883a 	mov	r3,r2
 32223a0:	e0bff717 	ldw	r2,-36(fp)
 32223a4:	1885883a 	add	r2,r3,r2
 32223a8:	10800017 	ldw	r2,0(r2)
 32223ac:	10800117 	ldw	r2,4(r2)
 32223b0:	10800084 	addi	r2,r2,2
 32223b4:	e0bffc15 	stw	r2,-16(fp)
        pkts[cur]->type = eth->e_type;
 32223b8:	e0bff903 	ldbu	r2,-28(fp)
 32223bc:	1085883a 	add	r2,r2,r2
 32223c0:	1085883a 	add	r2,r2,r2
 32223c4:	1007883a 	mov	r3,r2
 32223c8:	e0bff717 	ldw	r2,-36(fp)
 32223cc:	1885883a 	add	r2,r3,r2
 32223d0:	10c00017 	ldw	r3,0(r2)
 32223d4:	e0bffc17 	ldw	r2,-16(fp)
 32223d8:	1080030b 	ldhu	r2,12(r2)
 32223dc:	1880080d 	sth	r2,32(r3)

        if (!(stat & ETH_OCM_RXDESC_ERROR_MSK)){
 32223e0:	e0bffa17 	ldw	r2,-24(fp)
 32223e4:	10801fcc 	andi	r2,r2,127
 32223e8:	1004c03a 	cmpne	r2,r2,zero
 32223ec:	1000201e 	bne	r2,zero,3222470 <eth_ocm_rx_isr+0x244>
            pkt = pk_alloc(ETH_OCM_BUF_ALLOC_SIZE);
 32223f0:	01018004 	movi	r4,1536
 32223f4:	3229f480 	call	3229f48 <pk_alloc>
 32223f8:	e0bff815 	stw	r2,-32(fp)
            if (!pkt){  // couldn't get a free buffer for rx 
 32223fc:	e0bff817 	ldw	r2,-32(fp)
 3222400:	1004c03a 	cmpne	r2,r2,zero
 3222404:	1000071e 	bne	r2,zero,3222424 <eth_ocm_rx_isr+0x1f8>
              #if (ETH_OCM_DBG_LVL >= 4)
              dprintf("[eth_ocm_rx_isr] No free RX buffers (Swamping the NicheStack)\n");
              #endif // if ETH_OCM_DBG_LVL
              info->netp->n_mib->ifInDiscards++;
 3222408:	e0bffe17 	ldw	r2,-8(fp)
 322240c:	10800217 	ldw	r2,8(r2)
 3222410:	10c02717 	ldw	r3,156(r2)
 3222414:	18800c17 	ldw	r2,48(r3)
 3222418:	10800044 	addi	r2,r2,1
 322241c:	18800c15 	stw	r2,48(r3)
 3222420:	00001906 	br	3222488 <eth_ocm_rx_isr+0x25c>
            }
            else{
              putq(&rcvdq, pkts[cur]);
 3222424:	e0bff903 	ldbu	r2,-28(fp)
 3222428:	1085883a 	add	r2,r2,r2
 322242c:	1085883a 	add	r2,r2,r2
 3222430:	1007883a 	mov	r3,r2
 3222434:	e0bff717 	ldw	r2,-36(fp)
 3222438:	1885883a 	add	r2,r3,r2
 322243c:	11400017 	ldw	r5,0(r2)
 3222440:	0100c9b4 	movhi	r4,806
 3222444:	21319504 	addi	r4,r4,-14764
 3222448:	322a51c0 	call	322a51c <putq>
              pkts[cur] = pkt;
 322244c:	e0bff903 	ldbu	r2,-28(fp)
 3222450:	1085883a 	add	r2,r2,r2
 3222454:	1085883a 	add	r2,r2,r2
 3222458:	1007883a 	mov	r3,r2
 322245c:	e0bff717 	ldw	r2,-36(fp)
 3222460:	1887883a 	add	r3,r3,r2
 3222464:	e0bff817 	ldw	r2,-32(fp)
 3222468:	18800015 	stw	r2,0(r3)
 322246c:	00000606 	br	3222488 <eth_ocm_rx_isr+0x25c>
        }
        else{
            #if (ETH_OCM_DBG_LVL >= 3)
            dprintf("[eth_ocm_rx_isr] Frame discarded due to errors: 0x%08x!\n", (unsigned)stat);
            #endif // if ETH_OCM_DBG_LVL
            info->netp->n_mib->ifInDiscards++;
 3222470:	e0bffe17 	ldw	r2,-8(fp)
 3222474:	10800217 	ldw	r2,8(r2)
 3222478:	10c02717 	ldw	r3,156(r2)
 322247c:	18800c17 	ldw	r2,48(r3)
 3222480:	10800044 	addi	r2,r2,1
 3222484:	18800c15 	stw	r2,48(r3)
        }

        // ensure bit-31 of pkt_array[]->nb_buff is clear before passing
        // to DMA Driver
        buf_ptr = (alt_u8*)alt_remap_cached ((volatile void*) pkts[cur]->nb_buff, 4);
 3222488:	e0bff903 	ldbu	r2,-28(fp)
 322248c:	1085883a 	add	r2,r2,r2
 3222490:	1085883a 	add	r2,r2,r2
 3222494:	1007883a 	mov	r3,r2
 3222498:	e0bff717 	ldw	r2,-36(fp)
 322249c:	1885883a 	add	r2,r3,r2
 32224a0:	10800017 	ldw	r2,0(r2)
 32224a4:	11000117 	ldw	r4,4(r2)
 32224a8:	01400104 	movi	r5,4
 32224ac:	323ac480 	call	323ac48 <alt_remap_cached>
 32224b0:	e0bff615 	stw	r2,-40(fp)
        //shift the actual write location over by ETHHDR_BIAS (see ipport.h)
        buf_ptr = (alt_u8*)((unsigned int)buf_ptr + ETHHDR_BIAS);
 32224b4:	e0bff617 	ldw	r2,-40(fp)
 32224b8:	10800084 	addi	r2,r2,2
 32224bc:	e0bff615 	stw	r2,-40(fp)

        //Write pointer
        regs->rxdescs[cur].ptr = (unsigned int)buf_ptr; 
 32224c0:	e13ff903 	ldbu	r4,-28(fp)
 32224c4:	e0bff617 	ldw	r2,-40(fp)
 32224c8:	100b883a 	mov	r5,r2
 32224cc:	e0fffd17 	ldw	r3,-12(fp)
 32224d0:	200490fa 	slli	r2,r4,3
 32224d4:	10c5883a 	add	r2,r2,r3
 32224d8:	10810304 	addi	r2,r2,1036
 32224dc:	11400015 	stw	r5,0(r2)
        //Write the control register to start the transfer
        stat = ETH_OCM_RXDESC_EMPTY_MSK | ETH_OCM_RXDESC_IRQ_MSK;
 32224e0:	00b00014 	movui	r2,49152
 32224e4:	e0bffa15 	stw	r2,-24(fp)
        if(cur == (ETH_OCM_RX_DESC_COUNT - 1))
 32224e8:	e0bff903 	ldbu	r2,-28(fp)
 32224ec:	1004c03a 	cmpne	r2,r2,zero
 32224f0:	1000031e 	bne	r2,zero,3222500 <eth_ocm_rx_isr+0x2d4>
            stat |= ETH_OCM_RXDESC_WRAP_MSK;
 32224f4:	e0bffa17 	ldw	r2,-24(fp)
 32224f8:	10880014 	ori	r2,r2,8192
 32224fc:	e0bffa15 	stw	r2,-24(fp)
        regs->rxdescs[cur].ctrl = stat;
 3222500:	e0bff903 	ldbu	r2,-28(fp)
 3222504:	e0fffd17 	ldw	r3,-12(fp)
 3222508:	100490fa 	slli	r2,r2,3
 322250c:	10c5883a 	add	r2,r2,r3
 3222510:	10c10204 	addi	r3,r2,1032
 3222514:	e0bffa17 	ldw	r2,-24(fp)
 3222518:	18800015 	stw	r2,0(r3)
        
        //increment current descriptor counter
        cur++;
 322251c:	e0bff903 	ldbu	r2,-28(fp)
 3222520:	10800044 	addi	r2,r2,1
 3222524:	e0bff905 	stb	r2,-28(fp)
        if(cur == ETH_OCM_RX_DESC_COUNT)
 3222528:	e0bff903 	ldbu	r2,-28(fp)
 322252c:	10800058 	cmpnei	r2,r2,1
 3222530:	1000011e 	bne	r2,zero,3222538 <eth_ocm_rx_isr+0x30c>
            cur = 0;
 3222534:	e03ff905 	stb	zero,-28(fp)
        //get new descriptors status
        stat = regs->rxdescs[cur].ctrl;
 3222538:	e0bff903 	ldbu	r2,-28(fp)
 322253c:	e0fffd17 	ldw	r3,-12(fp)
 3222540:	100490fa 	slli	r2,r2,3
 3222544:	10c5883a 	add	r2,r2,r3
 3222548:	10810204 	addi	r2,r2,1032
 322254c:	10800017 	ldw	r2,0(r2)
 3222550:	e0bffa15 	stw	r2,-24(fp)
    cur = info->cur_rx_desc;

    stat = regs->rxdescs[cur].ctrl;

    //We'll process as many descriptors as are ready
    while(!(stat & ETH_OCM_RXDESC_EMPTY_MSK)){
 3222554:	e0bffa17 	ldw	r2,-24(fp)
 3222558:	10a0000c 	andi	r2,r2,32768
 322255c:	1005003a 	cmpeq	r2,r2,zero
 3222560:	103f4b1e 	bne	r2,zero,3222290 <eth_ocm_rx_isr+0x64>
        if(cur == ETH_OCM_RX_DESC_COUNT)
            cur = 0;
        //get new descriptors status
        stat = regs->rxdescs[cur].ctrl;
    }
    info->cur_rx_desc = cur;        
 3222564:	e0fffe17 	ldw	r3,-8(fp)
 3222568:	e0bff903 	ldbu	r2,-28(fp)
 322256c:	18800385 	stb	r2,14(r3)

    return SUCCESS;
 3222570:	0005883a 	mov	r2,zero
}
 3222574:	e037883a 	mov	sp,fp
 3222578:	dfc00117 	ldw	ra,4(sp)
 322257c:	df000017 	ldw	fp,0(sp)
 3222580:	dec00204 	addi	sp,sp,8
 3222584:	f800283a 	ret

03222588 <eth_ocm_stats>:

void eth_ocm_stats(void *pio, int iface) {
 3222588:	defff804 	addi	sp,sp,-32
 322258c:	dfc00715 	stw	ra,28(sp)
 3222590:	df000615 	stw	fp,24(sp)
 3222594:	df000604 	addi	fp,sp,24
 3222598:	e13ffe15 	stw	r4,-8(fp)
 322259c:	e17fff15 	stw	r5,-4(fp)
    eth_ocm_dev *dev;
    eth_ocm_regs *regs;
    int i;

    //get the ifp first
    ifp = nets[iface];
 32225a0:	e0bfff17 	ldw	r2,-4(fp)
 32225a4:	00c0c9b4 	movhi	r3,806
 32225a8:	18f25a04 	addi	r3,r3,-13976
 32225ac:	1085883a 	add	r2,r2,r2
 32225b0:	1085883a 	add	r2,r2,r2
 32225b4:	10c5883a 	add	r2,r2,r3
 32225b8:	10800017 	ldw	r2,0(r2)
 32225bc:	e0bffd15 	stw	r2,-12(fp)
    dev = (eth_ocm_dev *)ifp->n_local;
 32225c0:	e0bffd17 	ldw	r2,-12(fp)
 32225c4:	10802817 	ldw	r2,160(r2)
 32225c8:	e0bffc15 	stw	r2,-16(fp)
    regs = dev->regs;
 32225cc:	e0bffc17 	ldw	r2,-16(fp)
 32225d0:	10800a17 	ldw	r2,40(r2)
 32225d4:	e0bffb15 	stw	r2,-20(fp)

    #ifndef ETH_OCM_SYNC_TX
    ns_printf(pio, "ToSend queue: max:%d, current:%d\n", 
 32225d8:	e0bffc17 	ldw	r2,-16(fp)
 32225dc:	10801117 	ldw	r2,68(r2)
 32225e0:	11800817 	ldw	r6,32(r2)
 32225e4:	e0bffc17 	ldw	r2,-16(fp)
 32225e8:	10801117 	ldw	r2,68(r2)
 32225ec:	11c00717 	ldw	r7,28(r2)
 32225f0:	e13ffe17 	ldw	r4,-8(fp)
 32225f4:	0140c974 	movhi	r5,805
 32225f8:	29794e04 	addi	r5,r5,-6856
 32225fc:	32260180 	call	3226018 <ns_printf>
            dev->info->tosend.q_max,
            dev->info->tosend.q_len);

    ns_printf(pio, "Sendng queue: max:%d, current:%d\n", 
 3222600:	e0bffc17 	ldw	r2,-16(fp)
 3222604:	10801117 	ldw	r2,68(r2)
 3222608:	11800d17 	ldw	r6,52(r2)
 322260c:	e0bffc17 	ldw	r2,-16(fp)
 3222610:	10801117 	ldw	r2,68(r2)
 3222614:	11c00c17 	ldw	r7,48(r2)
 3222618:	e13ffe17 	ldw	r4,-8(fp)
 322261c:	0140c974 	movhi	r5,805
 3222620:	29795704 	addi	r5,r5,-6820
 3222624:	32260180 	call	3226018 <ns_printf>
            dev->info->sending.q_max,
            dev->info->sending.q_len);
    #endif //ifndef ETH_OCM_SYNC_TX

    ns_printf(pio, "TX Descriptor status:\n");
 3222628:	e13ffe17 	ldw	r4,-8(fp)
 322262c:	0140c974 	movhi	r5,805
 3222630:	29796004 	addi	r5,r5,-6784
 3222634:	32260180 	call	3226018 <ns_printf>
    for(i=0;i<ETH_OCM_TX_DESC_COUNT;i++){
 3222638:	e03ffa15 	stw	zero,-24(fp)
 322263c:	00000e06 	br	3222678 <eth_ocm_stats+0xf0>
        ns_printf(pio,"     %3d: 0x%08x\n", i, regs->txdescs[i].ctrl);
 3222640:	e0bffa17 	ldw	r2,-24(fp)
 3222644:	e0fffb17 	ldw	r3,-20(fp)
 3222648:	100490fa 	slli	r2,r2,3
 322264c:	10c5883a 	add	r2,r2,r3
 3222650:	10810004 	addi	r2,r2,1024
 3222654:	11c00017 	ldw	r7,0(r2)
 3222658:	e13ffe17 	ldw	r4,-8(fp)
 322265c:	0140c974 	movhi	r5,805
 3222660:	29796604 	addi	r5,r5,-6760
 3222664:	e1bffa17 	ldw	r6,-24(fp)
 3222668:	32260180 	call	3226018 <ns_printf>
            dev->info->sending.q_max,
            dev->info->sending.q_len);
    #endif //ifndef ETH_OCM_SYNC_TX

    ns_printf(pio, "TX Descriptor status:\n");
    for(i=0;i<ETH_OCM_TX_DESC_COUNT;i++){
 322266c:	e0bffa17 	ldw	r2,-24(fp)
 3222670:	10800044 	addi	r2,r2,1
 3222674:	e0bffa15 	stw	r2,-24(fp)
 3222678:	e0bffa17 	ldw	r2,-24(fp)
 322267c:	10800050 	cmplti	r2,r2,1
 3222680:	103fef1e 	bne	r2,zero,3222640 <eth_ocm_stats+0xb8>
        ns_printf(pio,"     %3d: 0x%08x\n", i, regs->txdescs[i].ctrl);
    }

    ns_printf(pio, "RX Descriptor status:\n");
 3222684:	e13ffe17 	ldw	r4,-8(fp)
 3222688:	0140c974 	movhi	r5,805
 322268c:	29796b04 	addi	r5,r5,-6740
 3222690:	32260180 	call	3226018 <ns_printf>
    for(i=0;i<ETH_OCM_RX_DESC_COUNT;i++){
 3222694:	e03ffa15 	stw	zero,-24(fp)
 3222698:	00000e06 	br	32226d4 <eth_ocm_stats+0x14c>
        ns_printf(pio,"     %3d: 0x%08x\n", i, regs->rxdescs[i].ctrl);
 322269c:	e0bffa17 	ldw	r2,-24(fp)
 32226a0:	e0fffb17 	ldw	r3,-20(fp)
 32226a4:	100490fa 	slli	r2,r2,3
 32226a8:	10c5883a 	add	r2,r2,r3
 32226ac:	10810204 	addi	r2,r2,1032
 32226b0:	11c00017 	ldw	r7,0(r2)
 32226b4:	e13ffe17 	ldw	r4,-8(fp)
 32226b8:	0140c974 	movhi	r5,805
 32226bc:	29796604 	addi	r5,r5,-6760
 32226c0:	e1bffa17 	ldw	r6,-24(fp)
 32226c4:	32260180 	call	3226018 <ns_printf>
    for(i=0;i<ETH_OCM_TX_DESC_COUNT;i++){
        ns_printf(pio,"     %3d: 0x%08x\n", i, regs->txdescs[i].ctrl);
    }

    ns_printf(pio, "RX Descriptor status:\n");
    for(i=0;i<ETH_OCM_RX_DESC_COUNT;i++){
 32226c8:	e0bffa17 	ldw	r2,-24(fp)
 32226cc:	10800044 	addi	r2,r2,1
 32226d0:	e0bffa15 	stw	r2,-24(fp)
 32226d4:	e0bffa17 	ldw	r2,-24(fp)
 32226d8:	10800050 	cmplti	r2,r2,1
 32226dc:	103fef1e 	bne	r2,zero,322269c <eth_ocm_stats+0x114>
        ns_printf(pio,"     %3d: 0x%08x\n", i, regs->rxdescs[i].ctrl);
    }


}
 32226e0:	e037883a 	mov	sp,fp
 32226e4:	dfc00117 	ldw	ra,4(sp)
 32226e8:	df000017 	ldw	fp,0(sp)
 32226ec:	dec00204 	addi	sp,sp,8
 32226f0:	f800283a 	ret

032226f4 <eth_ocm_close>:
 *
 * @param  iface    index of the NET interface associated with the Opencores MAC.
 * @return SUCCESS
 */
int eth_ocm_close(int iface)
{
 32226f4:	defff904 	addi	sp,sp,-28
 32226f8:	dfc00615 	stw	ra,24(sp)
 32226fc:	df000515 	stw	fp,20(sp)
 3222700:	df000504 	addi	fp,sp,20
 3222704:	e13ffe15 	stw	r4,-8(fp)
  int err;
  NET ifp;
  eth_ocm_dev *dev;

  /* status = down */
  ifp = nets[iface];
 3222708:	e0bffe17 	ldw	r2,-8(fp)
 322270c:	00c0c9b4 	movhi	r3,806
 3222710:	18f25a04 	addi	r3,r3,-13976
 3222714:	1085883a 	add	r2,r2,r2
 3222718:	1085883a 	add	r2,r2,r2
 322271c:	10c5883a 	add	r2,r2,r3
 3222720:	10800017 	ldw	r2,0(r2)
 3222724:	e0bffc15 	stw	r2,-16(fp)
  dev = (eth_ocm_dev *)ifp->n_local;
 3222728:	e0bffc17 	ldw	r2,-16(fp)
 322272c:	10802817 	ldw	r2,160(r2)
 3222730:	e0bffb15 	stw	r2,-20(fp)

  ifp->n_mib->ifAdminStatus = ETH_OCM_STATUS_DOWN;
 3222734:	e0bffc17 	ldw	r2,-16(fp)
 3222738:	10c02717 	ldw	r3,156(r2)
 322273c:	00800084 	movi	r2,2
 3222740:	18800615 	stw	r2,24(r3)

  /* disable the interrupt in the OS*/
  err = alt_irq_register (dev->irq, 0, NULL);
 3222744:	e0bffb17 	ldw	r2,-20(fp)
 3222748:	10800b03 	ldbu	r2,44(r2)
 322274c:	11003fcc 	andi	r4,r2,255
 3222750:	000b883a 	mov	r5,zero
 3222754:	000d883a 	mov	r6,zero
 3222758:	323a9080 	call	323a908 <alt_irq_register>
 322275c:	e0bffd15 	stw	r2,-12(fp)
  if (err){
 3222760:	e0bffd17 	ldw	r2,-12(fp)
 3222764:	1005003a 	cmpeq	r2,r2,zero
 3222768:	1000071e 	bne	r2,zero,3222788 <eth_ocm_close+0x94>
    dprintf("[eth_ocm_close] Could not unregister interrupt, error = %d\n",err);
 322276c:	0100c974 	movhi	r4,805
 3222770:	21397104 	addi	r4,r4,-6716
 3222774:	e17ffd17 	ldw	r5,-12(fp)
 3222778:	3206adc0 	call	3206adc <printf>
    return err;
 322277c:	e0bffd17 	ldw	r2,-12(fp)
 3222780:	e0bfff15 	stw	r2,-4(fp)
 3222784:	00000f06 	br	32227c4 <eth_ocm_close+0xd0>
  }

  // Shut down the MAC
  IOWR_ETH_OCM_MODER(dev->base, 0);
 3222788:	e0bffb17 	ldw	r2,-20(fp)
 322278c:	10800717 	ldw	r2,28(r2)
 3222790:	10000035 	stwio	zero,0(r2)

  /* status = down */
  ifp->n_mib->ifOperStatus = ETH_OCM_STATUS_DOWN;
 3222794:	e0bffc17 	ldw	r2,-16(fp)
 3222798:	10c02717 	ldw	r3,156(r2)
 322279c:	00800084 	movi	r2,2
 32227a0:	18800715 	stw	r2,28(r3)
  //deallocate memory for the eth_ocm_info struct allocated in eth_ocm_prep
  free(dev->info->rx_pkts);
 32227a4:	e0bffb17 	ldw	r2,-20(fp)
 32227a8:	10801117 	ldw	r2,68(r2)
 32227ac:	11000417 	ldw	r4,16(r2)
 32227b0:	324b9340 	call	324b934 <free>
  free(dev->info);
 32227b4:	e0bffb17 	ldw	r2,-20(fp)
 32227b8:	11001117 	ldw	r4,68(r2)
 32227bc:	324b9340 	call	324b934 <free>

  return SUCCESS;
 32227c0:	e03fff15 	stw	zero,-4(fp)
 32227c4:	e0bfff17 	ldw	r2,-4(fp)
}
 32227c8:	e037883a 	mov	sp,fp
 32227cc:	dfc00117 	ldw	ra,4(sp)
 32227d0:	df000017 	ldw	fp,0(sp)
 32227d4:	dec00204 	addi	sp,sp,8
 32227d8:	f800283a 	ret

032227dc <close>:
 * (for files and device drivers) or the InterNiche soclose() function for
 * sockets.
 */
 
int close (int fd)
{
 32227dc:	defffc04 	addi	sp,sp,-16
 32227e0:	dfc00315 	stw	ra,12(sp)
 32227e4:	df000215 	stw	fp,8(sp)
 32227e8:	df000204 	addi	fp,sp,8
 32227ec:	e13ffe15 	stw	r4,-8(fp)
  return (fd < ALT_MAX_FD) ? alt_close (fd) : t_socketclose ((long) fd);
 32227f0:	e0bffe17 	ldw	r2,-8(fp)
 32227f4:	10800808 	cmpgei	r2,r2,32
 32227f8:	1000041e 	bne	r2,zero,322280c <close+0x30>
 32227fc:	e13ffe17 	ldw	r4,-8(fp)
 3222800:	323a0d40 	call	323a0d4 <alt_close>
 3222804:	e0bfff15 	stw	r2,-4(fp)
 3222808:	00000306 	br	3222818 <close+0x3c>
 322280c:	e13ffe17 	ldw	r4,-8(fp)
 3222810:	322f1bc0 	call	322f1bc <t_socketclose>
 3222814:	e0bfff15 	stw	r2,-4(fp)
 3222818:	e0bfff17 	ldw	r2,-4(fp)
}
 322281c:	e037883a 	mov	sp,fp
 3222820:	dfc00117 	ldw	ra,4(sp)
 3222824:	df000017 	ldw	fp,0(sp)
 3222828:	dec00204 	addi	sp,sp,8
 322282c:	f800283a 	ret

03222830 <iniche_devices_init>:
 * total number of interfaces after initialization.
 */

int iniche_devices_init(
    int                         if_count)
{
 3222830:	defff504 	addi	sp,sp,-44
 3222834:	dfc00a15 	stw	ra,40(sp)
 3222838:	df000915 	stw	fp,36(sp)
 322283c:	df000904 	addi	fp,sp,36
 3222840:	e13fff15 	stw	r4,-4(fp)
                                netmask,
                                gw;
    int                         use_dhcp;

    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
 3222844:	d0a02a17 	ldw	r2,-32600(gp)
 3222848:	e0bffa15 	stw	r2,-24(fp)
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));
 322284c:	d0a02a04 	addi	r2,gp,-32600
 3222850:	e0bff915 	stw	r2,-28(fp)

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 3222854:	00003e06 	br	3222950 <iniche_devices_init+0x120>
    {
        /* Initialize the InterNiche device data record. */
        p_dev->p_driver_data = p_dev;
 3222858:	e0fffa17 	ldw	r3,-24(fp)
 322285c:	e0bffa17 	ldw	r2,-24(fp)
 3222860:	18800415 	stw	r2,16(r3)
        p_dev->if_num = if_count;
 3222864:	e0fffa17 	ldw	r3,-24(fp)
 3222868:	e0bfff17 	ldw	r2,-4(fp)
 322286c:	18800515 	stw	r2,20(r3)
        p_dev->p_net = nets[p_dev->if_num];
 3222870:	e0bffa17 	ldw	r2,-24(fp)
 3222874:	10800517 	ldw	r2,20(r2)
 3222878:	00c0c9b4 	movhi	r3,806
 322287c:	18f25a04 	addi	r3,r3,-13976
 3222880:	1085883a 	add	r2,r2,r2
 3222884:	1085883a 	add	r2,r2,r2
 3222888:	10c5883a 	add	r2,r2,r3
 322288c:	10c00017 	ldw	r3,0(r2)
 3222890:	e0bffa17 	ldw	r2,-24(fp)
 3222894:	10c00615 	stw	r3,24(r2)

        /* Perform device specific initialization. */
        (*(p_dev->init_func))(p_dev);
 3222898:	e0bffa17 	ldw	r2,-24(fp)
 322289c:	10800317 	ldw	r2,12(r2)
 32228a0:	e13ffa17 	ldw	r4,-24(fp)
 32228a4:	103ee83a 	callr	r2

        /* Get the interface IP address. */
        p_net = p_dev->p_net;
 32228a8:	e0bffa17 	ldw	r2,-24(fp)
 32228ac:	10800617 	ldw	r2,24(r2)
 32228b0:	e0bff815 	stw	r2,-32(fp)
                
        if (get_ip_addr(p_dev, &ipaddr, &netmask, &gw, &use_dhcp))
 32228b4:	e17ffb04 	addi	r5,fp,-20
 32228b8:	e1bffc04 	addi	r6,fp,-16
 32228bc:	e1fffd04 	addi	r7,fp,-12
 32228c0:	e0bffe04 	addi	r2,fp,-8
 32228c4:	d8800015 	stw	r2,0(sp)
 32228c8:	e13ffa17 	ldw	r4,-24(fp)
 32228cc:	32018540 	call	3201854 <get_ip_addr>
 32228d0:	1005003a 	cmpeq	r2,r2,zero
 32228d4:	1000181e 	bne	r2,zero,3222938 <iniche_devices_init+0x108>
            /* 
             * OR in the DHCP flag, if enabled. This will allow any
             * application-specific flag setting in get_ip_addr(), such 
             * as enabling AUTOIP, to occur 
             */
            if (use_dhcp) {
 32228d8:	e0bffe17 	ldw	r2,-8(fp)
 32228dc:	1005003a 	cmpeq	r2,r2,zero
 32228e0:	1000051e 	bne	r2,zero,32228f8 <iniche_devices_init+0xc8>
                p_net->n_flags |= NF_DHCPC;
 32228e4:	e0bff817 	ldw	r2,-32(fp)
 32228e8:	10802a17 	ldw	r2,168(r2)
 32228ec:	10c04014 	ori	r3,r2,256
 32228f0:	e0bff817 	ldw	r2,-32(fp)
 32228f4:	10c02a15 	stw	r3,168(r2)
            }
#endif
            p_net->n_ipaddr = ipaddr;
 32228f8:	e0fffb17 	ldw	r3,-20(fp)
 32228fc:	e0bff817 	ldw	r2,-32(fp)
 3222900:	10c00a15 	stw	r3,40(r2)
            p_net->snmask = netmask;
 3222904:	e0fffc17 	ldw	r3,-16(fp)
 3222908:	e0bff817 	ldw	r2,-32(fp)
 322290c:	10c00c15 	stw	r3,48(r2)
            p_net->n_defgw = gw;
 3222910:	e0fffd17 	ldw	r3,-12(fp)
 3222914:	e0bff817 	ldw	r2,-32(fp)
 3222918:	10c00d15 	stw	r3,52(r2)
#ifdef IP_MULTICAST
	    p_net->n_mcastlist = mcastlist;
 322291c:	e0fff817 	ldw	r3,-32(fp)
 3222920:	0080c934 	movhi	r2,804
 3222924:	10b21a04 	addi	r2,r2,-14232
 3222928:	18802b15 	stw	r2,172(r3)
#if defined (IGMP_V1) || defined (IGMP_V2)
            p_net->igmp_oper_mode = IGMP_MODE_DEFAULT;
 322292c:	e0fff817 	ldw	r3,-32(fp)
 3222930:	00800084 	movi	r2,2
 3222934:	18802f05 	stb	r2,188(r3)
#endif  /* IGMPv1 or IGMPv2 */
#endif  /* IP_MULTICAST */
        }

        /* Initialize next device. */
        if_count++;
 3222938:	e0bfff17 	ldw	r2,-4(fp)
 322293c:	10800044 	addi	r2,r2,1
 3222940:	e0bfff15 	stw	r2,-4(fp)
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
 3222944:	e0bffa17 	ldw	r2,-24(fp)
 3222948:	10800017 	ldw	r2,0(r2)
 322294c:	e0bffa15 	stw	r2,-24(fp)
    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 3222950:	e0fffa17 	ldw	r3,-24(fp)
 3222954:	e0bff917 	ldw	r2,-28(fp)
 3222958:	18bfbf1e 	bne	r3,r2,3222858 <iniche_devices_init+0x28>
        /* Initialize next device. */
        if_count++;
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
    }

    return (if_count);
 322295c:	e0bfff17 	ldw	r2,-4(fp)
}
 3222960:	e037883a 	mov	sp,fp
 3222964:	dfc00117 	ldw	ra,4(sp)
 3222968:	df000017 	ldw	fp,0(sp)
 322296c:	dec00204 	addi	sp,sp,8
 3222970:	f800283a 	ret

03222974 <read>:
 * (for files and device drivers) or the InterNiche recvfrom() function for
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
 3222974:	defff804 	addi	sp,sp,-32
 3222978:	dfc00715 	stw	ra,28(sp)
 322297c:	df000615 	stw	fp,24(sp)
 3222980:	df000604 	addi	fp,sp,24
 3222984:	e13ffc15 	stw	r4,-16(fp)
 3222988:	e17ffd15 	stw	r5,-12(fp)
 322298c:	e1bffe15 	stw	r6,-8(fp)
  return (fd < ALT_MAX_FD) ? alt_read (fd, ptr, len)
 3222990:	e0bffc17 	ldw	r2,-16(fp)
 3222994:	10800808 	cmpgei	r2,r2,32
 3222998:	1000061e 	bne	r2,zero,32229b4 <read+0x40>
 322299c:	e13ffc17 	ldw	r4,-16(fp)
 32229a0:	e17ffd17 	ldw	r5,-12(fp)
 32229a4:	e1bffe17 	ldw	r6,-8(fp)
 32229a8:	323aac80 	call	323aac8 <alt_read>
 32229ac:	e0bfff15 	stw	r2,-4(fp)
 32229b0:	00000806 	br	32229d4 <read+0x60>
 32229b4:	e1bffe17 	ldw	r6,-8(fp)
 32229b8:	d8000015 	stw	zero,0(sp)
 32229bc:	d8000115 	stw	zero,4(sp)
 32229c0:	e13ffc17 	ldw	r4,-16(fp)
 32229c4:	e17ffd17 	ldw	r5,-12(fp)
 32229c8:	000f883a 	mov	r7,zero
 32229cc:	32255940 	call	3225594 <bsd_recvfrom>
 32229d0:	e0bfff15 	stw	r2,-4(fp)
 32229d4:	e0bfff17 	ldw	r2,-4(fp)
                           : recvfrom(fd, ptr, len, 0, NULL, NULL);
}
 32229d8:	e037883a 	mov	sp,fp
 32229dc:	dfc00117 	ldw	ra,4(sp)
 32229e0:	df000017 	ldw	fp,0(sp)
 32229e4:	dec00204 	addi	sp,sp,8
 32229e8:	f800283a 	ret

032229ec <write>:
 * This implementation vectors requests to either the HAL alt_write() function 
 * (for files and device drivers) or the InterNiche send() function for sockets.
 */

int write (int fd, const void *ptr, size_t len)
{
 32229ec:	defffa04 	addi	sp,sp,-24
 32229f0:	dfc00515 	stw	ra,20(sp)
 32229f4:	df000415 	stw	fp,16(sp)
 32229f8:	df000404 	addi	fp,sp,16
 32229fc:	e13ffc15 	stw	r4,-16(fp)
 3222a00:	e17ffd15 	stw	r5,-12(fp)
 3222a04:	e1bffe15 	stw	r6,-8(fp)
  if (fd < ALT_MAX_FD)
 3222a08:	e0bffc17 	ldw	r2,-16(fp)
 3222a0c:	10800808 	cmpgei	r2,r2,32
 3222a10:	1000061e 	bne	r2,zero,3222a2c <write+0x40>
  {
    return alt_write (fd, ptr, len);
 3222a14:	e13ffc17 	ldw	r4,-16(fp)
 3222a18:	e17ffd17 	ldw	r5,-12(fp)
 3222a1c:	e1bffe17 	ldw	r6,-8(fp)
 3222a20:	323af800 	call	323af80 <alt_write>
 3222a24:	e0bfff15 	stw	r2,-4(fp)
 3222a28:	00000606 	br	3222a44 <write+0x58>
  }
  else
  { 
    return send (fd, (void*) ptr, len, 0);
 3222a2c:	e17ffd17 	ldw	r5,-12(fp)
 3222a30:	e1bffe17 	ldw	r6,-8(fp)
 3222a34:	e13ffc17 	ldw	r4,-16(fp)
 3222a38:	000f883a 	mov	r7,zero
 3222a3c:	322eeb00 	call	322eeb0 <t_send>
 3222a40:	e0bfff15 	stw	r2,-4(fp)
 3222a44:	e0bfff17 	ldw	r2,-4(fp)
  }  
}
 3222a48:	e037883a 	mov	sp,fp
 3222a4c:	dfc00117 	ldw	ra,4(sp)
 3222a50:	df000017 	ldw	fp,0(sp)
 3222a54:	dec00204 	addi	sp,sp,8
 3222a58:	f800283a 	ret

03222a5c <Netinit>:
 * a non-zero error code
 */

int
Netinit()
{
 3222a5c:	defff704 	addi	sp,sp,-36
 3222a60:	dfc00815 	stw	ra,32(sp)
 3222a64:	df000715 	stw	fp,28(sp)
 3222a68:	df000704 	addi	fp,sp,28
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 3222a6c:	e03ffa15 	stw	zero,-24(fp)
 3222a70:	00005806 	br	3222bd4 <Netinit+0x178>
   {
      /* sanity check on mtu, et.al. We added this because earlier 
       * drivers were sloppy about setting them, but new
       * logic depends on these sizes.
       */
      if (nets[i]->n_mib->ifType == ETHERNET)   /* ethernet? */
 3222a74:	e0bffa17 	ldw	r2,-24(fp)
 3222a78:	00c0c9b4 	movhi	r3,806
 3222a7c:	18f25a04 	addi	r3,r3,-13976
 3222a80:	1085883a 	add	r2,r2,r2
 3222a84:	1085883a 	add	r2,r2,r2
 3222a88:	10c5883a 	add	r2,r2,r3
 3222a8c:	10800017 	ldw	r2,0(r2)
 3222a90:	10802717 	ldw	r2,156(r2)
 3222a94:	10800217 	ldw	r2,8(r2)
 3222a98:	10800198 	cmpnei	r2,r2,6
 3222a9c:	1000261e 	bne	r2,zero,3222b38 <Netinit+0xdc>
      {
         if (nets[i]->n_mtu == 0)   /* let device code override */
 3222aa0:	e0bffa17 	ldw	r2,-24(fp)
 3222aa4:	00c0c9b4 	movhi	r3,806
 3222aa8:	18f25a04 	addi	r3,r3,-13976
 3222aac:	1085883a 	add	r2,r2,r2
 3222ab0:	1085883a 	add	r2,r2,r2
 3222ab4:	10c5883a 	add	r2,r2,r3
 3222ab8:	10800017 	ldw	r2,0(r2)
 3222abc:	10800917 	ldw	r2,36(r2)
 3222ac0:	1004c03a 	cmpne	r2,r2,zero
 3222ac4:	1000091e 	bne	r2,zero,3222aec <Netinit+0x90>
            nets[i]->n_mtu = 1514;
 3222ac8:	e0bffa17 	ldw	r2,-24(fp)
 3222acc:	00c0c9b4 	movhi	r3,806
 3222ad0:	18f25a04 	addi	r3,r3,-13976
 3222ad4:	1085883a 	add	r2,r2,r2
 3222ad8:	1085883a 	add	r2,r2,r2
 3222adc:	10c5883a 	add	r2,r2,r3
 3222ae0:	10c00017 	ldw	r3,0(r2)
 3222ae4:	00817a84 	movi	r2,1514
 3222ae8:	18800915 	stw	r2,36(r3)

         if (nets[i]->n_lnh == 0)
 3222aec:	e0bffa17 	ldw	r2,-24(fp)
 3222af0:	00c0c9b4 	movhi	r3,806
 3222af4:	18f25a04 	addi	r3,r3,-13976
 3222af8:	1085883a 	add	r2,r2,r2
 3222afc:	1085883a 	add	r2,r2,r2
 3222b00:	10c5883a 	add	r2,r2,r3
 3222b04:	10800017 	ldw	r2,0(r2)
 3222b08:	10800817 	ldw	r2,32(r2)
 3222b0c:	1004c03a 	cmpne	r2,r2,zero
 3222b10:	1000091e 	bne	r2,zero,3222b38 <Netinit+0xdc>
         {
#ifdef IEEE_802_3
            nets[i]->n_lnh = ETHHDR_SIZE + sizeof(struct snap_hdr);
#else
            nets[i]->n_lnh = ETHHDR_SIZE;
 3222b14:	e0bffa17 	ldw	r2,-24(fp)
 3222b18:	00c0c9b4 	movhi	r3,806
 3222b1c:	18f25a04 	addi	r3,r3,-13976
 3222b20:	1085883a 	add	r2,r2,r2
 3222b24:	1085883a 	add	r2,r2,r2
 3222b28:	10c5883a 	add	r2,r2,r3
 3222b2c:	10c00017 	ldw	r3,0(r2)
 3222b30:	00800404 	movi	r2,16
 3222b34:	18800815 	stw	r2,32(r3)
      {
         continue;
      }
#endif   /* IP_V6 */

      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
 3222b38:	e0bffa17 	ldw	r2,-24(fp)
 3222b3c:	00c0c9b4 	movhi	r3,806
 3222b40:	18f25a04 	addi	r3,r3,-13976
 3222b44:	1085883a 	add	r2,r2,r2
 3222b48:	1085883a 	add	r2,r2,r2
 3222b4c:	10c5883a 	add	r2,r2,r3
 3222b50:	10800017 	ldw	r2,0(r2)
 3222b54:	10800817 	ldw	r2,32(r2)
 3222b58:	d0e8b817 	ldw	r3,-23840(gp)
 3222b5c:	e0ffff15 	stw	r3,-4(fp)
 3222b60:	e0bffe15 	stw	r2,-8(fp)
 3222b64:	e0bffe17 	ldw	r2,-8(fp)
 3222b68:	e0ffff17 	ldw	r3,-4(fp)
 3222b6c:	10c0020e 	bge	r2,r3,3222b78 <Netinit+0x11c>
 3222b70:	e0bfff17 	ldw	r2,-4(fp)
 3222b74:	e0bffe15 	stw	r2,-8(fp)
 3222b78:	e0fffe17 	ldw	r3,-8(fp)
 3222b7c:	d0e8b815 	stw	r3,-23840(gp)
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
 3222b80:	e0bffa17 	ldw	r2,-24(fp)
 3222b84:	00c0c9b4 	movhi	r3,806
 3222b88:	18f25a04 	addi	r3,r3,-13976
 3222b8c:	1085883a 	add	r2,r2,r2
 3222b90:	1085883a 	add	r2,r2,r2
 3222b94:	10c5883a 	add	r2,r2,r3
 3222b98:	10800017 	ldw	r2,0(r2)
 3222b9c:	10800917 	ldw	r2,36(r2)
 3222ba0:	d0e8b917 	ldw	r3,-23836(gp)
 3222ba4:	e0fffd15 	stw	r3,-12(fp)
 3222ba8:	e0bffc15 	stw	r2,-16(fp)
 3222bac:	e0bffc17 	ldw	r2,-16(fp)
 3222bb0:	e0fffd17 	ldw	r3,-12(fp)
 3222bb4:	10c0020e 	bge	r2,r3,3222bc0 <Netinit+0x164>
 3222bb8:	e0bffd17 	ldw	r2,-12(fp)
 3222bbc:	e0bffc15 	stw	r2,-16(fp)
 3222bc0:	e0fffc17 	ldw	r3,-16(fp)
 3222bc4:	d0e8b915 	stw	r3,-23836(gp)
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 3222bc8:	e0bffa17 	ldw	r2,-24(fp)
 3222bcc:	10800044 	addi	r2,r2,1
 3222bd0:	e0bffa15 	stw	r2,-24(fp)
 3222bd4:	0080c974 	movhi	r2,805
 3222bd8:	10923204 	addi	r2,r2,18632
 3222bdc:	10800017 	ldw	r2,0(r2)
 3222be0:	1007883a 	mov	r3,r2
 3222be4:	e0bffa17 	ldw	r2,-24(fp)
 3222be8:	10ffa216 	blt	r2,r3,3222a74 <Netinit+0x18>
      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
   }

   /* set up the received packet queue */
   rcvdq.q_head = rcvdq.q_tail = NULL;
 3222bec:	0080c9b4 	movhi	r2,806
 3222bf0:	10b19504 	addi	r2,r2,-14764
 3222bf4:	10000115 	stw	zero,4(r2)
 3222bf8:	0080c9b4 	movhi	r2,806
 3222bfc:	10b19504 	addi	r2,r2,-14764
 3222c00:	10c00117 	ldw	r3,4(r2)
 3222c04:	0080c9b4 	movhi	r2,806
 3222c08:	10b19504 	addi	r2,r2,-14764
 3222c0c:	10c00015 	stw	r3,0(r2)
   rcvdq.q_max = rcvdq.q_min = rcvdq.q_len = 0;
 3222c10:	0080c9b4 	movhi	r2,806
 3222c14:	10b19504 	addi	r2,r2,-14764
 3222c18:	10000215 	stw	zero,8(r2)
 3222c1c:	0080c9b4 	movhi	r2,806
 3222c20:	10b19504 	addi	r2,r2,-14764
 3222c24:	10c00217 	ldw	r3,8(r2)
 3222c28:	0080c9b4 	movhi	r2,806
 3222c2c:	10b19504 	addi	r2,r2,-14764
 3222c30:	10c00415 	stw	r3,16(r2)
 3222c34:	0080c9b4 	movhi	r2,806
 3222c38:	10b19504 	addi	r2,r2,-14764
 3222c3c:	10c00417 	ldw	r3,16(r2)
 3222c40:	0080c9b4 	movhi	r2,806
 3222c44:	10b19504 	addi	r2,r2,-14764
 3222c48:	10c00315 	stw	r3,12(r2)

   /* initialize freeq */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 3222c4c:	01000084 	movi	r4,2
 3222c50:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   e = pk_init();
 3222c54:	3229cb80 	call	3229cb8 <pk_init>
 3222c58:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3222c5c:	01000084 	movi	r4,2
 3222c60:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   if (e)   /* report error (memory ran out?) */
 3222c64:	e0bff917 	ldw	r2,-28(fp)
 3222c68:	1005003a 	cmpeq	r2,r2,zero
 3222c6c:	1000031e 	bne	r2,zero,3222c7c <Netinit+0x220>
      return e;
 3222c70:	e0bff917 	ldw	r2,-28(fp)
 3222c74:	e0bffb15 	stw	r2,-20(fp)
 3222c78:	00010506 	br	3223090 <Netinit+0x634>

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */
 3222c7c:	0100c8b4 	movhi	r4,802
 3222c80:	210c8204 	addi	r4,r4,12808
 3222c84:	3223c1c0 	call	3223c1c <exit_hook>

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 3222c88:	e03ffa15 	stw	zero,-24(fp)
 3222c8c:	0000f906 	br	3223074 <Netinit+0x618>
   {
      if (nets[i]->n_init != NULL)  /* If iface has init routine... */
 3222c90:	e0bffa17 	ldw	r2,-24(fp)
 3222c94:	00c0c9b4 	movhi	r3,806
 3222c98:	18f25a04 	addi	r3,r3,-13976
 3222c9c:	1085883a 	add	r2,r2,r2
 3222ca0:	1085883a 	add	r2,r2,r2
 3222ca4:	10c5883a 	add	r2,r2,r3
 3222ca8:	10800017 	ldw	r2,0(r2)
 3222cac:	10800217 	ldw	r2,8(r2)
 3222cb0:	1005003a 	cmpeq	r2,r2,zero
 3222cb4:	1000931e 	bne	r2,zero,3222f04 <Netinit+0x4a8>
      {
         if ((e = (*nets[i]->n_init)(i)) != 0)  /* call init routine */
 3222cb8:	e0bffa17 	ldw	r2,-24(fp)
 3222cbc:	00c0c9b4 	movhi	r3,806
 3222cc0:	18f25a04 	addi	r3,r3,-13976
 3222cc4:	1085883a 	add	r2,r2,r2
 3222cc8:	1085883a 	add	r2,r2,r2
 3222ccc:	10c5883a 	add	r2,r2,r3
 3222cd0:	10800017 	ldw	r2,0(r2)
 3222cd4:	10800217 	ldw	r2,8(r2)
 3222cd8:	e13ffa17 	ldw	r4,-24(fp)
 3222cdc:	103ee83a 	callr	r2
 3222ce0:	e0bff915 	stw	r2,-28(fp)
 3222ce4:	e0bff917 	ldw	r2,-28(fp)
 3222ce8:	1005003a 	cmpeq	r2,r2,zero
 3222cec:	1000101e 	bne	r2,zero,3222d30 <Netinit+0x2d4>
         {
            dprintf("init error %d on net[%d]\n", e, i);
 3222cf0:	0100c974 	movhi	r4,805
 3222cf4:	21398004 	addi	r4,r4,-6656
 3222cf8:	e17ff917 	ldw	r5,-28(fp)
 3222cfc:	e1bffa17 	ldw	r6,-24(fp)
 3222d00:	3206adc0 	call	3206adc <printf>
            nets[i]->n_mib->ifOperStatus = NI_DOWN;
 3222d04:	e0bffa17 	ldw	r2,-24(fp)
 3222d08:	00c0c9b4 	movhi	r3,806
 3222d0c:	18f25a04 	addi	r3,r3,-13976
 3222d10:	1085883a 	add	r2,r2,r2
 3222d14:	1085883a 	add	r2,r2,r2
 3222d18:	10c5883a 	add	r2,r2,r3
 3222d1c:	10800017 	ldw	r2,0(r2)
 3222d20:	10c02717 	ldw	r3,156(r2)
 3222d24:	00800084 	movi	r2,2
 3222d28:	18800715 	stw	r2,28(r3)
            continue;   /* ignore ifaces which fail */
 3222d2c:	0000ce06 	br	3223068 <Netinit+0x60c>
         }
         /* If interface is ethernet, set bcast flag bit. This
          * should really be done by the init routine, but we handle it
          * here to support MAC drivers which predate the flags field.
          */
         if(nets[i]->n_mib->ifType == ETHERNET)
 3222d30:	e0bffa17 	ldw	r2,-24(fp)
 3222d34:	00c0c9b4 	movhi	r3,806
 3222d38:	18f25a04 	addi	r3,r3,-13976
 3222d3c:	1085883a 	add	r2,r2,r2
 3222d40:	1085883a 	add	r2,r2,r2
 3222d44:	10c5883a 	add	r2,r2,r3
 3222d48:	10800017 	ldw	r2,0(r2)
 3222d4c:	10802717 	ldw	r2,156(r2)
 3222d50:	10800217 	ldw	r2,8(r2)
 3222d54:	10800198 	cmpnei	r2,r2,6
 3222d58:	1000111e 	bne	r2,zero,3222da0 <Netinit+0x344>
            nets[i]->n_flags |= NF_BCAST;
 3222d5c:	e0bffa17 	ldw	r2,-24(fp)
 3222d60:	00c0c9b4 	movhi	r3,806
 3222d64:	18f25a04 	addi	r3,r3,-13976
 3222d68:	1085883a 	add	r2,r2,r2
 3222d6c:	1085883a 	add	r2,r2,r2
 3222d70:	10c5883a 	add	r2,r2,r3
 3222d74:	11000017 	ldw	r4,0(r2)
 3222d78:	e0bffa17 	ldw	r2,-24(fp)
 3222d7c:	00c0c9b4 	movhi	r3,806
 3222d80:	18f25a04 	addi	r3,r3,-13976
 3222d84:	1085883a 	add	r2,r2,r2
 3222d88:	1085883a 	add	r2,r2,r2
 3222d8c:	10c5883a 	add	r2,r2,r3
 3222d90:	10800017 	ldw	r2,0(r2)
 3222d94:	10802a17 	ldw	r2,168(r2)
 3222d98:	10800054 	ori	r2,r2,1
 3222d9c:	20802a15 	stw	r2,168(r4)

         /* set ifAdminStatus in case init() routine forgot to. IfOperStatus
          * is not nessecarily up at this point, as in the case of a modem which
          * is now in autoanswer mode.
          */
         nets[i]->n_mib->ifAdminStatus = NI_UP;
 3222da0:	e0bffa17 	ldw	r2,-24(fp)
 3222da4:	00c0c9b4 	movhi	r3,806
 3222da8:	18f25a04 	addi	r3,r3,-13976
 3222dac:	1085883a 	add	r2,r2,r2
 3222db0:	1085883a 	add	r2,r2,r2
 3222db4:	10c5883a 	add	r2,r2,r3
 3222db8:	10800017 	ldw	r2,0(r2)
 3222dbc:	10c02717 	ldw	r3,156(r2)
 3222dc0:	00800044 	movi	r2,1
 3222dc4:	18800615 	stw	r2,24(r3)

         /* assign default names to unnamed ifaces */
         if(nets[i]->name[0] == 0)     /* no name set by prep or init */
 3222dc8:	e0bffa17 	ldw	r2,-24(fp)
 3222dcc:	00c0c9b4 	movhi	r3,806
 3222dd0:	18f25a04 	addi	r3,r3,-13976
 3222dd4:	1085883a 	add	r2,r2,r2
 3222dd8:	1085883a 	add	r2,r2,r2
 3222ddc:	10c5883a 	add	r2,r2,r3
 3222de0:	10800017 	ldw	r2,0(r2)
 3222de4:	10800103 	ldbu	r2,4(r2)
 3222de8:	10803fcc 	andi	r2,r2,255
 3222dec:	1080201c 	xori	r2,r2,128
 3222df0:	10bfe004 	addi	r2,r2,-128
 3222df4:	1004c03a 	cmpne	r2,r2,zero
 3222df8:	1000421e 	bne	r2,zero,3222f04 <Netinit+0x4a8>
         {
            if(nets[i]->n_mib->ifType == ETHERNET)
 3222dfc:	e0bffa17 	ldw	r2,-24(fp)
 3222e00:	00c0c9b4 	movhi	r3,806
 3222e04:	18f25a04 	addi	r3,r3,-13976
 3222e08:	1085883a 	add	r2,r2,r2
 3222e0c:	1085883a 	add	r2,r2,r2
 3222e10:	10c5883a 	add	r2,r2,r3
 3222e14:	10800017 	ldw	r2,0(r2)
 3222e18:	10802717 	ldw	r2,156(r2)
 3222e1c:	10800217 	ldw	r2,8(r2)
 3222e20:	10800198 	cmpnei	r2,r2,6
 3222e24:	1000131e 	bne	r2,zero,3222e74 <Netinit+0x418>
            {
               nets[i]->name[0] = 'e';    /* "et1", "et2", etc. */
 3222e28:	e0bffa17 	ldw	r2,-24(fp)
 3222e2c:	00c0c9b4 	movhi	r3,806
 3222e30:	18f25a04 	addi	r3,r3,-13976
 3222e34:	1085883a 	add	r2,r2,r2
 3222e38:	1085883a 	add	r2,r2,r2
 3222e3c:	10c5883a 	add	r2,r2,r3
 3222e40:	10c00017 	ldw	r3,0(r2)
 3222e44:	00801944 	movi	r2,101
 3222e48:	18800105 	stb	r2,4(r3)
               nets[i]->name[1] = 't';
 3222e4c:	e0bffa17 	ldw	r2,-24(fp)
 3222e50:	00c0c9b4 	movhi	r3,806
 3222e54:	18f25a04 	addi	r3,r3,-13976
 3222e58:	1085883a 	add	r2,r2,r2
 3222e5c:	1085883a 	add	r2,r2,r2
 3222e60:	10c5883a 	add	r2,r2,r3
 3222e64:	10c00017 	ldw	r3,0(r2)
 3222e68:	00801d04 	movi	r2,116
 3222e6c:	18800145 	stb	r2,5(r3)
 3222e70:	00001206 	br	3222ebc <Netinit+0x460>
            }
            else
            {
               nets[i]->name[0] = 'i';    /* "if1", "if2", etc. */
 3222e74:	e0bffa17 	ldw	r2,-24(fp)
 3222e78:	00c0c9b4 	movhi	r3,806
 3222e7c:	18f25a04 	addi	r3,r3,-13976
 3222e80:	1085883a 	add	r2,r2,r2
 3222e84:	1085883a 	add	r2,r2,r2
 3222e88:	10c5883a 	add	r2,r2,r3
 3222e8c:	10c00017 	ldw	r3,0(r2)
 3222e90:	00801a44 	movi	r2,105
 3222e94:	18800105 	stb	r2,4(r3)
               nets[i]->name[1] = 'f';
 3222e98:	e0bffa17 	ldw	r2,-24(fp)
 3222e9c:	00c0c9b4 	movhi	r3,806
 3222ea0:	18f25a04 	addi	r3,r3,-13976
 3222ea4:	1085883a 	add	r2,r2,r2
 3222ea8:	1085883a 	add	r2,r2,r2
 3222eac:	10c5883a 	add	r2,r2,r3
 3222eb0:	10c00017 	ldw	r3,0(r2)
 3222eb4:	00801984 	movi	r2,102
 3222eb8:	18800145 	stb	r2,5(r3)
            }
            nets[i]->name[2] = (char)(i + '1');
 3222ebc:	e0bffa17 	ldw	r2,-24(fp)
 3222ec0:	00c0c9b4 	movhi	r3,806
 3222ec4:	18f25a04 	addi	r3,r3,-13976
 3222ec8:	1085883a 	add	r2,r2,r2
 3222ecc:	1085883a 	add	r2,r2,r2
 3222ed0:	10c5883a 	add	r2,r2,r3
 3222ed4:	10c00017 	ldw	r3,0(r2)
 3222ed8:	e0bffa17 	ldw	r2,-24(fp)
 3222edc:	10800c44 	addi	r2,r2,49
 3222ee0:	18800185 	stb	r2,6(r3)
            nets[i]->name[3] = '\0';
 3222ee4:	e0bffa17 	ldw	r2,-24(fp)
 3222ee8:	00c0c9b4 	movhi	r3,806
 3222eec:	18f25a04 	addi	r3,r3,-13976
 3222ef0:	1085883a 	add	r2,r2,r2
 3222ef4:	1085883a 	add	r2,r2,r2
 3222ef8:	10c5883a 	add	r2,r2,r3
 3222efc:	10800017 	ldw	r2,0(r2)
 3222f00:	100001c5 	stb	zero,7(r2)
         }
      }
      /* check on subnet routing - if no mask then make one */
      fixup_subnet_mask(i);      /* make mask for this net */
 3222f04:	e13ffa17 	ldw	r4,-24(fp)
 3222f08:	32230a80 	call	32230a8 <fixup_subnet_mask>

      /* build broadcast addresses */
      if(nets[i]->n_ipaddr != 0)
 3222f0c:	e0bffa17 	ldw	r2,-24(fp)
 3222f10:	00c0c9b4 	movhi	r3,806
 3222f14:	18f25a04 	addi	r3,r3,-13976
 3222f18:	1085883a 	add	r2,r2,r2
 3222f1c:	1085883a 	add	r2,r2,r2
 3222f20:	10c5883a 	add	r2,r2,r3
 3222f24:	10800017 	ldw	r2,0(r2)
 3222f28:	10800a17 	ldw	r2,40(r2)
 3222f2c:	1005003a 	cmpeq	r2,r2,zero
 3222f30:	10004d1e 	bne	r2,zero,3223068 <Netinit+0x60c>
      {
         nets[i]->n_netbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 3222f34:	e0bffa17 	ldw	r2,-24(fp)
 3222f38:	00c0c9b4 	movhi	r3,806
 3222f3c:	18f25a04 	addi	r3,r3,-13976
 3222f40:	1085883a 	add	r2,r2,r2
 3222f44:	1085883a 	add	r2,r2,r2
 3222f48:	10c5883a 	add	r2,r2,r3
 3222f4c:	11400017 	ldw	r5,0(r2)
 3222f50:	e0bffa17 	ldw	r2,-24(fp)
 3222f54:	00c0c9b4 	movhi	r3,806
 3222f58:	18f25a04 	addi	r3,r3,-13976
 3222f5c:	1085883a 	add	r2,r2,r2
 3222f60:	1085883a 	add	r2,r2,r2
 3222f64:	10c5883a 	add	r2,r2,r3
 3222f68:	10800017 	ldw	r2,0(r2)
 3222f6c:	11000a17 	ldw	r4,40(r2)
 3222f70:	e0bffa17 	ldw	r2,-24(fp)
 3222f74:	00c0c9b4 	movhi	r3,806
 3222f78:	18f25a04 	addi	r3,r3,-13976
 3222f7c:	1085883a 	add	r2,r2,r2
 3222f80:	1085883a 	add	r2,r2,r2
 3222f84:	10c5883a 	add	r2,r2,r3
 3222f88:	10800017 	ldw	r2,0(r2)
 3222f8c:	10800c17 	ldw	r2,48(r2)
 3222f90:	0084303a 	nor	r2,zero,r2
 3222f94:	2084b03a 	or	r2,r4,r2
 3222f98:	28800e15 	stw	r2,56(r5)
         nets[i]->n_netbr42 = nets[i]->n_ipaddr & nets[i]->snmask;
 3222f9c:	e0bffa17 	ldw	r2,-24(fp)
 3222fa0:	00c0c9b4 	movhi	r3,806
 3222fa4:	18f25a04 	addi	r3,r3,-13976
 3222fa8:	1085883a 	add	r2,r2,r2
 3222fac:	1085883a 	add	r2,r2,r2
 3222fb0:	10c5883a 	add	r2,r2,r3
 3222fb4:	11400017 	ldw	r5,0(r2)
 3222fb8:	e0bffa17 	ldw	r2,-24(fp)
 3222fbc:	00c0c9b4 	movhi	r3,806
 3222fc0:	18f25a04 	addi	r3,r3,-13976
 3222fc4:	1085883a 	add	r2,r2,r2
 3222fc8:	1085883a 	add	r2,r2,r2
 3222fcc:	10c5883a 	add	r2,r2,r3
 3222fd0:	10800017 	ldw	r2,0(r2)
 3222fd4:	11000a17 	ldw	r4,40(r2)
 3222fd8:	e0bffa17 	ldw	r2,-24(fp)
 3222fdc:	00c0c9b4 	movhi	r3,806
 3222fe0:	18f25a04 	addi	r3,r3,-13976
 3222fe4:	1085883a 	add	r2,r2,r2
 3222fe8:	1085883a 	add	r2,r2,r2
 3222fec:	10c5883a 	add	r2,r2,r3
 3222ff0:	10800017 	ldw	r2,0(r2)
 3222ff4:	10800c17 	ldw	r2,48(r2)
 3222ff8:	2084703a 	and	r2,r4,r2
 3222ffc:	28800f15 	stw	r2,60(r5)
         nets[i]->n_subnetbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 3223000:	e0bffa17 	ldw	r2,-24(fp)
 3223004:	00c0c9b4 	movhi	r3,806
 3223008:	18f25a04 	addi	r3,r3,-13976
 322300c:	1085883a 	add	r2,r2,r2
 3223010:	1085883a 	add	r2,r2,r2
 3223014:	10c5883a 	add	r2,r2,r3
 3223018:	11400017 	ldw	r5,0(r2)
 322301c:	e0bffa17 	ldw	r2,-24(fp)
 3223020:	00c0c9b4 	movhi	r3,806
 3223024:	18f25a04 	addi	r3,r3,-13976
 3223028:	1085883a 	add	r2,r2,r2
 322302c:	1085883a 	add	r2,r2,r2
 3223030:	10c5883a 	add	r2,r2,r3
 3223034:	10800017 	ldw	r2,0(r2)
 3223038:	11000a17 	ldw	r4,40(r2)
 322303c:	e0bffa17 	ldw	r2,-24(fp)
 3223040:	00c0c9b4 	movhi	r3,806
 3223044:	18f25a04 	addi	r3,r3,-13976
 3223048:	1085883a 	add	r2,r2,r2
 322304c:	1085883a 	add	r2,r2,r2
 3223050:	10c5883a 	add	r2,r2,r3
 3223054:	10800017 	ldw	r2,0(r2)
 3223058:	10800c17 	ldw	r2,48(r2)
 322305c:	0084303a 	nor	r2,zero,r2
 3223060:	2084b03a 	or	r2,r4,r2
 3223064:	28801015 	stw	r2,64(r5)

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 3223068:	e0bffa17 	ldw	r2,-24(fp)
 322306c:	10800044 	addi	r2,r2,1
 3223070:	e0bffa15 	stw	r2,-24(fp)
 3223074:	0080c974 	movhi	r2,805
 3223078:	10923204 	addi	r2,r2,18632
 322307c:	10800017 	ldw	r2,0(r2)
 3223080:	1007883a 	mov	r3,r2
 3223084:	e0bffa17 	ldw	r2,-24(fp)
 3223088:	10ff0116 	blt	r2,r3,3222c90 <Netinit+0x234>
#if defined(DYNAMIC_IFACES) && defined(IN_MENUS)
   /* Install dynamic iface menu */
   install_menu(&dynif_menu[0]);
#endif /* DYNAMIC_IFACES && IN_MENUS */

   return(0);
 322308c:	e03ffb15 	stw	zero,-20(fp)
 3223090:	e0bffb17 	ldw	r2,-20(fp)
}
 3223094:	e037883a 	mov	sp,fp
 3223098:	dfc00117 	ldw	ra,4(sp)
 322309c:	df000017 	ldw	fp,0(sp)
 32230a0:	dec00204 	addi	sp,sp,8
 32230a4:	f800283a 	ret

032230a8 <fixup_subnet_mask>:
 * RETURNS: 
 */

void
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
 32230a8:	defffc04 	addi	sp,sp,-16
 32230ac:	dfc00315 	stw	ra,12(sp)
 32230b0:	df000215 	stw	fp,8(sp)
 32230b4:	df000204 	addi	fp,sp,8
 32230b8:	e13fff15 	stw	r4,-4(fp)
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
 32230bc:	e0bfff17 	ldw	r2,-4(fp)
 32230c0:	00c0c9b4 	movhi	r3,806
 32230c4:	18f25a04 	addi	r3,r3,-13976
 32230c8:	1085883a 	add	r2,r2,r2
 32230cc:	1085883a 	add	r2,r2,r2
 32230d0:	10c5883a 	add	r2,r2,r3
 32230d4:	10800017 	ldw	r2,0(r2)
 32230d8:	10800c17 	ldw	r2,48(r2)
 32230dc:	1004c03a 	cmpne	r2,r2,zero
 32230e0:	1000441e 	bne	r2,zero,32231f4 <fixup_subnet_mask+0x14c>
      return;

   /* things depending on IP address class: */
   if ((nets[netnum]->n_ipaddr & AMASK) == AADDR)
 32230e4:	e0bfff17 	ldw	r2,-4(fp)
 32230e8:	00c0c9b4 	movhi	r3,806
 32230ec:	18f25a04 	addi	r3,r3,-13976
 32230f0:	1085883a 	add	r2,r2,r2
 32230f4:	1085883a 	add	r2,r2,r2
 32230f8:	10c5883a 	add	r2,r2,r3
 32230fc:	10800017 	ldw	r2,0(r2)
 3223100:	10800a17 	ldw	r2,40(r2)
 3223104:	1080200c 	andi	r2,r2,128
 3223108:	1004c03a 	cmpne	r2,r2,zero
 322310c:	1000031e 	bne	r2,zero,322311c <fixup_subnet_mask+0x74>
      smask = 0xFF000000L;
 3223110:	00bfc034 	movhi	r2,65280
 3223114:	e0bffe15 	stw	r2,-8(fp)
 3223118:	00001f06 	br	3223198 <fixup_subnet_mask+0xf0>
   else if((nets[netnum]->n_ipaddr & BMASK) == BADDR)
 322311c:	e0bfff17 	ldw	r2,-4(fp)
 3223120:	00c0c9b4 	movhi	r3,806
 3223124:	18f25a04 	addi	r3,r3,-13976
 3223128:	1085883a 	add	r2,r2,r2
 322312c:	1085883a 	add	r2,r2,r2
 3223130:	10c5883a 	add	r2,r2,r3
 3223134:	10800017 	ldw	r2,0(r2)
 3223138:	10800a17 	ldw	r2,40(r2)
 322313c:	1080300c 	andi	r2,r2,192
 3223140:	10802018 	cmpnei	r2,r2,128
 3223144:	1000031e 	bne	r2,zero,3223154 <fixup_subnet_mask+0xac>
      smask = 0xFFFF0000L;
 3223148:	00bffff4 	movhi	r2,65535
 322314c:	e0bffe15 	stw	r2,-8(fp)
 3223150:	00001106 	br	3223198 <fixup_subnet_mask+0xf0>
   else if((nets[netnum]->n_ipaddr & CMASK) == CADDR)
 3223154:	e0bfff17 	ldw	r2,-4(fp)
 3223158:	00c0c9b4 	movhi	r3,806
 322315c:	18f25a04 	addi	r3,r3,-13976
 3223160:	1085883a 	add	r2,r2,r2
 3223164:	1085883a 	add	r2,r2,r2
 3223168:	10c5883a 	add	r2,r2,r3
 322316c:	10800017 	ldw	r2,0(r2)
 3223170:	10800a17 	ldw	r2,40(r2)
 3223174:	1080380c 	andi	r2,r2,224
 3223178:	10803018 	cmpnei	r2,r2,192
 322317c:	1000031e 	bne	r2,zero,322318c <fixup_subnet_mask+0xe4>
      smask = 0xFFFFFF00L;
 3223180:	00bfc004 	movi	r2,-256
 3223184:	e0bffe15 	stw	r2,-8(fp)
 3223188:	00000306 	br	3223198 <fixup_subnet_mask+0xf0>
   else
   {
      dtrap();    /* bad logic or setup values */
 322318c:	322ab8c0 	call	322ab8c <dtrap>
      smask = 0xFFFFFF00L;
 3223190:	00bfc004 	movi	r2,-256
 3223194:	e0bffe15 	stw	r2,-8(fp)
   }
   nets[netnum]->snmask = htonl(smask);
 3223198:	e0bfff17 	ldw	r2,-4(fp)
 322319c:	00c0c9b4 	movhi	r3,806
 32231a0:	18f25a04 	addi	r3,r3,-13976
 32231a4:	1085883a 	add	r2,r2,r2
 32231a8:	1085883a 	add	r2,r2,r2
 32231ac:	10c5883a 	add	r2,r2,r3
 32231b0:	11000017 	ldw	r4,0(r2)
 32231b4:	e0bffe17 	ldw	r2,-8(fp)
 32231b8:	1004d63a 	srli	r2,r2,24
 32231bc:	10c03fcc 	andi	r3,r2,255
 32231c0:	e0bffe17 	ldw	r2,-8(fp)
 32231c4:	1004d23a 	srli	r2,r2,8
 32231c8:	10bfc00c 	andi	r2,r2,65280
 32231cc:	1886b03a 	or	r3,r3,r2
 32231d0:	e0bffe17 	ldw	r2,-8(fp)
 32231d4:	10bfc00c 	andi	r2,r2,65280
 32231d8:	1004923a 	slli	r2,r2,8
 32231dc:	1886b03a 	or	r3,r3,r2
 32231e0:	e0bffe17 	ldw	r2,-8(fp)
 32231e4:	10803fcc 	andi	r2,r2,255
 32231e8:	1004963a 	slli	r2,r2,24
 32231ec:	1884b03a 	or	r2,r3,r2
 32231f0:	20800c15 	stw	r2,48(r4)
}
 32231f4:	e037883a 	mov	sp,fp
 32231f8:	dfc00117 	ldw	ra,4(sp)
 32231fc:	df000017 	ldw	fp,0(sp)
 3223200:	dec00204 	addi	sp,sp,8
 3223204:	f800283a 	ret

03223208 <netclose>:
 * RETURNS: 
 */

void
netclose()
{
 3223208:	defffc04 	addi	sp,sp,-16
 322320c:	dfc00315 	stw	ra,12(sp)
 3223210:	df000215 	stw	fp,8(sp)
 3223214:	df000204 	addi	fp,sp,8
   NET ifp;
   int index = 0;
 3223218:	e03ffe15 	stw	zero,-8(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
 322321c:	d0a8ba17 	ldw	r2,-23832(gp)
 3223220:	1080010c 	andi	r2,r2,4
 3223224:	1005003a 	cmpeq	r2,r2,zero
 3223228:	1000031e 	bne	r2,zero,3223238 <netclose+0x30>
 322322c:	0100c974 	movhi	r4,805
 3223230:	21398704 	addi	r4,r4,-6628
 3223234:	3206e040 	call	3206e04 <puts>
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 3223238:	0080c9b4 	movhi	r2,806
 322323c:	10b45b04 	addi	r2,r2,-11924
 3223240:	10800017 	ldw	r2,0(r2)
 3223244:	e0bfff15 	stw	r2,-4(fp)
 3223248:	00002106 	br	32232d0 <netclose+0xc8>
   {
      if (ifp->n_close)
 322324c:	e0bfff17 	ldw	r2,-4(fp)
 3223250:	10800517 	ldw	r2,20(r2)
 3223254:	1005003a 	cmpeq	r2,r2,zero
 3223258:	10000e1e 	bne	r2,zero,3223294 <netclose+0x8c>
      {
         dprintf("netclose: closing iface %s\n", ifp->n_mib->ifDescr);
 322325c:	e0bfff17 	ldw	r2,-4(fp)
 3223260:	10802717 	ldw	r2,156(r2)
 3223264:	11400117 	ldw	r5,4(r2)
 3223268:	0100c974 	movhi	r4,805
 322326c:	21398c04 	addi	r4,r4,-6608
 3223270:	3206adc0 	call	3206adc <printf>
         (*(ifp->n_close))(index++);
 3223274:	e0bfff17 	ldw	r2,-4(fp)
 3223278:	10c00517 	ldw	r3,20(r2)
 322327c:	e13ffe17 	ldw	r4,-8(fp)
 3223280:	e0bffe17 	ldw	r2,-8(fp)
 3223284:	10800044 	addi	r2,r2,1
 3223288:	e0bffe15 	stw	r2,-8(fp)
 322328c:	183ee83a 	callr	r3
 3223290:	00000c06 	br	32232c4 <netclose+0xbc>
      }
      else
      {
#ifdef NPDEBUG
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
 3223294:	d0a8ba17 	ldw	r2,-23832(gp)
 3223298:	1080010c 	andi	r2,r2,4
 322329c:	1005003a 	cmpeq	r2,r2,zero
 32232a0:	1000051e 	bne	r2,zero,32232b8 <netclose+0xb0>
 32232a4:	e0bfff17 	ldw	r2,-4(fp)
 32232a8:	11400104 	addi	r5,r2,4
 32232ac:	0100c974 	movhi	r4,805
 32232b0:	21399304 	addi	r4,r4,-6580
 32232b4:	3206adc0 	call	3206adc <printf>
#endif
         index++;
 32232b8:	e0bffe17 	ldw	r2,-8(fp)
 32232bc:	10800044 	addi	r2,r2,1
 32232c0:	e0bffe15 	stw	r2,-8(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 32232c4:	e0bfff17 	ldw	r2,-4(fp)
 32232c8:	10800017 	ldw	r2,0(r2)
 32232cc:	e0bfff15 	stw	r2,-4(fp)
 32232d0:	e0bfff17 	ldw	r2,-4(fp)
 32232d4:	1004c03a 	cmpne	r2,r2,zero
 32232d8:	103fdc1e 	bne	r2,zero,322324c <netclose+0x44>
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
#endif
         index++;
      }
   }
}
 32232dc:	e037883a 	mov	sp,fp
 32232e0:	dfc00117 	ldw	ra,4(sp)
 32232e4:	df000017 	ldw	fp,0(sp)
 32232e8:	dec00204 	addi	sp,sp,8
 32232ec:	f800283a 	ret

032232f0 <pktdemux>:
 * RETURNS: void
 */

void
pktdemux()
{
 32232f0:	defff804 	addi	sp,sp,-32
 32232f4:	dfc00715 	stw	ra,28(sp)
 32232f8:	df000615 	stw	fp,24(sp)
 32232fc:	df000604 	addi	fp,sp,24
   NET      ifc;                /* interface packet came from */
   IFMIB    mib;
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */
 3223300:	e03ffb15 	stw	zero,-20(fp)

   while (rcvdq.q_len)
 3223304:	0000e506 	br	322369c <pktdemux+0x3ac>
   {
      /* If we are low on free packets, don't hog CPU cycles */
      if (pkts++ > bigfreeq.q_len)
 3223308:	0080c9b4 	movhi	r2,806
 322330c:	10b30104 	addi	r2,r2,-13308
 3223310:	10c00217 	ldw	r3,8(r2)
 3223314:	e0bffb17 	ldw	r2,-20(fp)
 3223318:	1884803a 	cmplt	r2,r3,r2
 322331c:	1007883a 	mov	r3,r2
 3223320:	e0bffb17 	ldw	r2,-20(fp)
 3223324:	10800044 	addi	r2,r2,1
 3223328:	e0bffb15 	stw	r2,-20(fp)
 322332c:	18803fcc 	andi	r2,r3,255
 3223330:	1005003a 	cmpeq	r2,r2,zero
 3223334:	1000021e 	bne	r2,zero,3223340 <pktdemux+0x50>
      {
#ifdef SUPERLOOP
         return;        /* don't hog stack on superloop */
#else    /* SUPERLOOP */
         tk_yield(); /* let application tasks process received packets */
 3223338:	3226a780 	call	3226a78 <tk_yield>
         pkts = 0;   /* reset counter */
 322333c:	e03ffb15 	stw	zero,-20(fp)
#endif   /* SUPERLOOP else */
      }

      /* If we get receive interupt from the net during this
      lock, the MAC driver needs to wait or reschedule */
      LOCK_NET_RESOURCE(RXQ_RESID);
 3223340:	01000044 	movi	r4,1
 3223344:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pkt = (PACKET)q_deq(&rcvdq);
 3223348:	0100c9b4 	movhi	r4,806
 322334c:	21319504 	addi	r4,r4,-14764
 3223350:	322a4540 	call	322a454 <getq>
 3223354:	e0bffe15 	stw	r2,-8(fp)
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 3223358:	01000044 	movi	r4,1
 322335c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      if (!pkt) panic("pktdemux: got null pkt");
 3223360:	e0bffe17 	ldw	r2,-8(fp)
 3223364:	1004c03a 	cmpne	r2,r2,zero
 3223368:	1000031e 	bne	r2,zero,3223378 <pktdemux+0x88>
 322336c:	0100c974 	movhi	r4,805
 3223370:	21399a04 	addi	r4,r4,-6552
 3223374:	3225df00 	call	3225df0 <panic>
      ifc = pkt->net;
 3223378:	e0bffe17 	ldw	r2,-8(fp)
 322337c:	10800617 	ldw	r2,24(r2)
 3223380:	e0bffd15 	stw	r2,-12(fp)

      mib = ifc->n_mib;
 3223384:	e0bffd17 	ldw	r2,-12(fp)
 3223388:	10802717 	ldw	r2,156(r2)
 322338c:	e0bffc15 	stw	r2,-16(fp)
      /* maintain mib stats for unicast and broadcast */
      if (isbcast(ifc, (u_char*)pkt->nb_buff + ETHHDR_BIAS))
 3223390:	e0bffe17 	ldw	r2,-8(fp)
 3223394:	10800117 	ldw	r2,4(r2)
 3223398:	11400084 	addi	r5,r2,2
 322339c:	e13ffd17 	ldw	r4,-12(fp)
 32233a0:	323e3dc0 	call	323e3dc <isbcast>
 32233a4:	1005003a 	cmpeq	r2,r2,zero
 32233a8:	1000061e 	bne	r2,zero,32233c4 <pktdemux+0xd4>
         mib->ifInNUcastPkts++;
 32233ac:	e0bffc17 	ldw	r2,-16(fp)
 32233b0:	10800b17 	ldw	r2,44(r2)
 32233b4:	10c00044 	addi	r3,r2,1
 32233b8:	e0bffc17 	ldw	r2,-16(fp)
 32233bc:	10c00b15 	stw	r3,44(r2)
 32233c0:	00000506 	br	32233d8 <pktdemux+0xe8>
      else
         mib->ifInUcastPkts++;
 32233c4:	e0bffc17 	ldw	r2,-16(fp)
 32233c8:	10800a17 	ldw	r2,40(r2)
 32233cc:	10c00044 	addi	r3,r2,1
 32233d0:	e0bffc17 	ldw	r2,-16(fp)
 32233d4:	10c00a15 	stw	r3,40(r2)

      if(mib->ifAdminStatus == NI_DOWN)
 32233d8:	e0bffc17 	ldw	r2,-16(fp)
 32233dc:	10800617 	ldw	r2,24(r2)
 32233e0:	10800098 	cmpnei	r2,r2,2
 32233e4:	10000c1e 	bne	r2,zero,3223418 <pktdemux+0x128>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 32233e8:	01000084 	movi	r4,2
 32233ec:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pk_free(pkt);  /* dump packet from downed interface */
 32233f0:	e13ffe17 	ldw	r4,-8(fp)
 32233f4:	322a2dc0 	call	322a2dc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32233f8:	01000084 	movi	r4,2
 32233fc:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         mib->ifInDiscards++;
 3223400:	e0bffc17 	ldw	r2,-16(fp)
 3223404:	10800c17 	ldw	r2,48(r2)
 3223408:	10c00044 	addi	r3,r2,1
 322340c:	e0bffc17 	ldw	r2,-16(fp)
 3223410:	10c00c15 	stw	r3,48(r2)
         continue;      /* next packet */
 3223414:	0000a106 	br	322369c <pktdemux+0x3ac>
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 3223418:	e0bffe17 	ldw	r2,-8(fp)
 322341c:	10800117 	ldw	r2,4(r2)
 3223420:	10bfff04 	addi	r2,r2,-4
 3223424:	10800003 	ldbu	r2,0(r2)
 3223428:	10803fcc 	andi	r2,r2,255
 322342c:	1080201c 	xori	r2,r2,128
 3223430:	10bfe004 	addi	r2,r2,-128
 3223434:	10801358 	cmpnei	r2,r2,77
 3223438:	10000b1e 	bne	r2,zero,3223468 <pktdemux+0x178>
 322343c:	e0bffe17 	ldw	r2,-8(fp)
 3223440:	10c00117 	ldw	r3,4(r2)
 3223444:	e0bffe17 	ldw	r2,-8(fp)
 3223448:	10800217 	ldw	r2,8(r2)
 322344c:	1885883a 	add	r2,r3,r2
 3223450:	10800003 	ldbu	r2,0(r2)
 3223454:	10803fcc 	andi	r2,r2,255
 3223458:	1080201c 	xori	r2,r2,128
 322345c:	10bfe004 	addi	r2,r2,-128
 3223460:	10801360 	cmpeqi	r2,r2,77
 3223464:	1000041e 	bne	r2,zero,3223478 <pktdemux+0x188>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
      {
         dtrap();
 3223468:	322ab8c0 	call	322ab8c <dtrap>
         panic("pktdemux: corrupt pkt");
 322346c:	0100c974 	movhi	r4,805
 3223470:	2139a004 	addi	r4,r4,-6528
 3223474:	3225df00 	call	3225df0 <panic>
         }
      }
#endif   /* LOSSY_IO */

      /* see if driver set pkt->nb_prot and pkt->type */
      if((ifc->n_flags & NF_NBPROT) == 0)
 3223478:	e0bffd17 	ldw	r2,-12(fp)
 322347c:	10802a17 	ldw	r2,168(r2)
 3223480:	1080020c 	andi	r2,r2,8
 3223484:	1004c03a 	cmpne	r2,r2,zero
 3223488:	10004d1e 	bne	r2,zero,32235c0 <pktdemux+0x2d0>
          * probably the right thing to do, but because of this historic
          * inconsistency we don't try to fix it here - the longer size
          * turns out to be harmless since the IP layer fixes the size
          * based on the IP header length field.
          */
         switch(ifc->n_mib->ifType)
 322348c:	e0bffd17 	ldw	r2,-12(fp)
 3223490:	10802717 	ldw	r2,156(r2)
 3223494:	10800217 	ldw	r2,8(r2)
 3223498:	108001a0 	cmpeqi	r2,r2,6
 322349c:	1000011e 	bne	r2,zero,32234a4 <pktdemux+0x1b4>
 32234a0:	00003a06 	br	322358c <pktdemux+0x29c>
         {
         case ETHERNET:
            /* get pointer to ethernet header */
            eth = (pkt->nb_buff + ETHHDR_BIAS);
 32234a4:	e0bffe17 	ldw	r2,-8(fp)
 32234a8:	10800117 	ldw	r2,4(r2)
 32234ac:	10800084 	addi	r2,r2,2
 32234b0:	e0bffa15 	stw	r2,-24(fp)
            {
               pkt->type = htons((unshort)ET_TYPE_GET(eth));
               pkt->nb_prot = pkt->nb_buff + ETHHDR_SIZE;
            }
#else
            pkt->type = htons((unshort)ET_TYPE_GET(eth));
 32234b4:	e0bffa17 	ldw	r2,-24(fp)
 32234b8:	10800304 	addi	r2,r2,12
 32234bc:	10800003 	ldbu	r2,0(r2)
 32234c0:	10803fcc 	andi	r2,r2,255
 32234c4:	1080201c 	xori	r2,r2,128
 32234c8:	10bfe004 	addi	r2,r2,-128
 32234cc:	1004923a 	slli	r2,r2,8
 32234d0:	1007883a 	mov	r3,r2
 32234d4:	e0bffa17 	ldw	r2,-24(fp)
 32234d8:	10800344 	addi	r2,r2,13
 32234dc:	10800003 	ldbu	r2,0(r2)
 32234e0:	10803fcc 	andi	r2,r2,255
 32234e4:	1080201c 	xori	r2,r2,128
 32234e8:	10bfe004 	addi	r2,r2,-128
 32234ec:	10803fcc 	andi	r2,r2,255
 32234f0:	1885883a 	add	r2,r3,r2
 32234f4:	10bfffcc 	andi	r2,r2,65535
 32234f8:	1004d23a 	srli	r2,r2,8
 32234fc:	10803fcc 	andi	r2,r2,255
 3223500:	1009883a 	mov	r4,r2
 3223504:	e0bffa17 	ldw	r2,-24(fp)
 3223508:	10800304 	addi	r2,r2,12
 322350c:	10800003 	ldbu	r2,0(r2)
 3223510:	10803fcc 	andi	r2,r2,255
 3223514:	1080201c 	xori	r2,r2,128
 3223518:	10bfe004 	addi	r2,r2,-128
 322351c:	1004923a 	slli	r2,r2,8
 3223520:	1007883a 	mov	r3,r2
 3223524:	e0bffa17 	ldw	r2,-24(fp)
 3223528:	10800344 	addi	r2,r2,13
 322352c:	10800003 	ldbu	r2,0(r2)
 3223530:	10803fcc 	andi	r2,r2,255
 3223534:	1080201c 	xori	r2,r2,128
 3223538:	10bfe004 	addi	r2,r2,-128
 322353c:	10803fcc 	andi	r2,r2,255
 3223540:	1885883a 	add	r2,r3,r2
 3223544:	10bfffcc 	andi	r2,r2,65535
 3223548:	1004923a 	slli	r2,r2,8
 322354c:	1007883a 	mov	r3,r2
 3223550:	00bfc004 	movi	r2,-256
 3223554:	1884703a 	and	r2,r3,r2
 3223558:	2084b03a 	or	r2,r4,r2
 322355c:	1007883a 	mov	r3,r2
 3223560:	e0bffe17 	ldw	r2,-8(fp)
 3223564:	10c0080d 	sth	r3,32(r2)
            pkt->nb_prot = pkt->nb_buff + pkt->net->n_lnh;
 3223568:	e0bffe17 	ldw	r2,-8(fp)
 322356c:	10c00117 	ldw	r3,4(r2)
 3223570:	e0bffe17 	ldw	r2,-8(fp)
 3223574:	10800617 	ldw	r2,24(r2)
 3223578:	10800817 	ldw	r2,32(r2)
 322357c:	1887883a 	add	r3,r3,r2
 3223580:	e0bffe17 	ldw	r2,-8(fp)
 3223584:	10c00315 	stw	r3,12(r2)
#endif   /* IEEE_802_3 */
            break;
 3223588:	00000d06 	br	32235c0 <pktdemux+0x2d0>
         case PPPOE:
            /* do not change type yet, for PPPoE */
            break;
#endif   /* USE_PPPOE */
         default:    /* driver bug? */
            dprintf("pktdemux: bad Iface type %ld\n",ifc->n_mib->ifType);
 322358c:	e0bffd17 	ldw	r2,-12(fp)
 3223590:	10802717 	ldw	r2,156(r2)
 3223594:	11400217 	ldw	r5,8(r2)
 3223598:	0100c974 	movhi	r4,805
 322359c:	2139a604 	addi	r4,r4,-6504
 32235a0:	3206adc0 	call	3206adc <printf>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 32235a4:	01000084 	movi	r4,2
 32235a8:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
            pk_free(pkt);
 32235ac:	e13ffe17 	ldw	r4,-8(fp)
 32235b0:	322a2dc0 	call	322a2dc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32235b4:	01000084 	movi	r4,2
 32235b8:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
            continue;
 32235bc:	00003706 	br	322369c <pktdemux+0x3ac>
         }
      }

      /* pkt->nb_prot and pkt->type are now set. pass pkt to upper layer */
      switch(pkt->type)
 32235c0:	e0bffe17 	ldw	r2,-8(fp)
 32235c4:	1080080b 	ldhu	r2,32(r2)
 32235c8:	10bfffcc 	andi	r2,r2,65535
 32235cc:	e0bfff15 	stw	r2,-4(fp)
 32235d0:	e0ffff17 	ldw	r3,-4(fp)
 32235d4:	18800220 	cmpeqi	r2,r3,8
 32235d8:	1000041e 	bne	r2,zero,32235ec <pktdemux+0x2fc>
 32235dc:	e0ffff17 	ldw	r3,-4(fp)
 32235e0:	18818220 	cmpeqi	r2,r3,1544
 32235e4:	1000081e 	bne	r2,zero,3223608 <pktdemux+0x318>
 32235e8:	00000e06 	br	3223624 <pktdemux+0x334>
      {
      case IPTP:     /* IP type */
         LOCK_NET_RESOURCE(NET_RESID);
 32235ec:	0009883a 	mov	r4,zero
 32235f0:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
#ifdef SHARED_IPADDRS
         add_share_route(pkt);
#endif /* SHARED_IPADDRS */
#ifdef IP_V4
         ip_rcv(pkt);
 32235f4:	e13ffe17 	ldw	r4,-8(fp)
 32235f8:	32426300 	call	3242630 <ip_rcv>
            /* don't care, it's IPv4 */
            LOCK_NET_RESOURCE(FREEQ_RESID);
            pk_free(pkt);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif
		UNLOCK_NET_RESOURCE(NET_RESID);
 32235fc:	0009883a 	mov	r4,zero
 3223600:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         break;
 3223604:	00002506 	br	322369c <pktdemux+0x3ac>
#ifdef INCLUDE_ARP
      case ARPTP:       /* ARP type */
         LOCK_NET_RESOURCE(NET_RESID);
 3223608:	0009883a 	mov	r4,zero
 322360c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         arprcv(pkt);
 3223610:	e13ffe17 	ldw	r4,-8(fp)
 3223614:	323db6c0 	call	323db6c <arprcv>
         UNLOCK_NET_RESOURCE(NET_RESID);
 3223618:	0009883a 	mov	r4,zero
 322361c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         break;
 3223620:	00001e06 	br	322369c <pktdemux+0x3ac>
         UNLOCK_NET_RESOURCE(NET_RESID);
         break;
#endif
      default:
#ifdef NPDEBUG
         if (NDEBUG & UPCTRACE)
 3223624:	d0a8ba17 	ldw	r2,-23832(gp)
 3223628:	1081000c 	andi	r2,r2,1024
 322362c:	1005003a 	cmpeq	r2,r2,zero
 3223630:	10000f1e 	bne	r2,zero,3223670 <pktdemux+0x380>
            dprintf("pktdemux: bad pkt type 0x%04x\n", ntohs(pkt->type));
 3223634:	e0bffe17 	ldw	r2,-8(fp)
 3223638:	1080080b 	ldhu	r2,32(r2)
 322363c:	10bfffcc 	andi	r2,r2,65535
 3223640:	1004d23a 	srli	r2,r2,8
 3223644:	10bfffcc 	andi	r2,r2,65535
 3223648:	10c03fcc 	andi	r3,r2,255
 322364c:	e0bffe17 	ldw	r2,-8(fp)
 3223650:	1080080b 	ldhu	r2,32(r2)
 3223654:	10bfffcc 	andi	r2,r2,65535
 3223658:	1004923a 	slli	r2,r2,8
 322365c:	10bfc00c 	andi	r2,r2,65280
 3223660:	188ab03a 	or	r5,r3,r2
 3223664:	0100c974 	movhi	r4,805
 3223668:	2139ae04 	addi	r4,r4,-6472
 322366c:	3206adc0 	call	3206adc <printf>
#endif   /* NPDEBUG */
         ifc->n_mib->ifInUnknownProtos++;
 3223670:	e0bffd17 	ldw	r2,-12(fp)
 3223674:	10c02717 	ldw	r3,156(r2)
 3223678:	18800e17 	ldw	r2,56(r3)
 322367c:	10800044 	addi	r2,r2,1
 3223680:	18800e15 	stw	r2,56(r3)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 3223684:	01000084 	movi	r4,2
 3223688:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pk_free(pkt);           /* return to free buffer */
 322368c:	e13ffe17 	ldw	r4,-8(fp)
 3223690:	322a2dc0 	call	322a2dc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3223694:	01000084 	movi	r4,2
 3223698:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */

   while (rcvdq.q_len)
 322369c:	0080c9b4 	movhi	r2,806
 32236a0:	10b19504 	addi	r2,r2,-14764
 32236a4:	10800217 	ldw	r2,8(r2)
 32236a8:	1004c03a 	cmpne	r2,r2,zero
 32236ac:	103f161e 	bne	r2,zero,3223308 <pktdemux+0x18>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         break;
      }
      continue;
   }
}
 32236b0:	e037883a 	mov	sp,fp
 32236b4:	dfc00117 	ldw	ra,4(sp)
 32236b8:	df000017 	ldw	fp,0(sp)
 32236bc:	dec00204 	addi	sp,sp,8
 32236c0:	f800283a 	ret

032236c4 <c_older>:
 * RETURNS: the older of the two passed tick counts
 */

u_long
c_older(u_long ct1, u_long ct2)
{
 32236c4:	defffc04 	addi	sp,sp,-16
 32236c8:	df000315 	stw	fp,12(sp)
 32236cc:	df000304 	addi	fp,sp,12
 32236d0:	e13ffd15 	stw	r4,-12(fp)
 32236d4:	e17ffe15 	stw	r5,-8(fp)

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 32236d8:	0080c974 	movhi	r2,805
 32236dc:	10925604 	addi	r2,r2,18776
 32236e0:	10800017 	ldw	r2,0(r2)
 32236e4:	1004403a 	cmpge	r2,r2,zero
 32236e8:	1000141e 	bne	r2,zero,322373c <c_older+0x78>
 32236ec:	0080c974 	movhi	r2,805
 32236f0:	10925604 	addi	r2,r2,18776
 32236f4:	10c00017 	ldw	r3,0(r2)
 32236f8:	e0bffd17 	ldw	r2,-12(fp)
 32236fc:	18800536 	bltu	r3,r2,3223714 <c_older+0x50>
 3223700:	0080c974 	movhi	r2,805
 3223704:	10925604 	addi	r2,r2,18776
 3223708:	10c00017 	ldw	r3,0(r2)
 322370c:	e0bffe17 	ldw	r2,-8(fp)
 3223710:	18800a2e 	bgeu	r3,r2,322373c <c_older+0x78>
 3223714:	0080c974 	movhi	r2,805
 3223718:	10925604 	addi	r2,r2,18776
 322371c:	10c00017 	ldw	r3,0(r2)
 3223720:	e0bffd17 	ldw	r2,-12(fp)
 3223724:	10c00e36 	bltu	r2,r3,3223760 <c_older+0x9c>
 3223728:	0080c974 	movhi	r2,805
 322372c:	10925604 	addi	r2,r2,18776
 3223730:	10c00017 	ldw	r3,0(r2)
 3223734:	e0bffe17 	ldw	r2,-8(fp)
 3223738:	10c00936 	bltu	r2,r3,3223760 <c_older+0x9c>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
   {
      if (ct1 < ct2)
 322373c:	e0fffd17 	ldw	r3,-12(fp)
 3223740:	e0bffe17 	ldw	r2,-8(fp)
 3223744:	1880032e 	bgeu	r3,r2,3223754 <c_older+0x90>
         return(ct1);      /* then smaller is oldest */
 3223748:	e0bffd17 	ldw	r2,-12(fp)
 322374c:	e0bfff15 	stw	r2,-4(fp)
 3223750:	00000b06 	br	3223780 <c_older+0xbc>
      else 
         return(ct2);
 3223754:	e0bffe17 	ldw	r2,-8(fp)
 3223758:	e0bfff15 	stw	r2,-4(fp)
 322375c:	00000806 	br	3223780 <c_older+0xbc>
   }

   /* else one is less than cticks, and one is greater.
   the larger value is then the oldest */
   if (ct1 >= ct2)
 3223760:	e0fffd17 	ldw	r3,-12(fp)
 3223764:	e0bffe17 	ldw	r2,-8(fp)
 3223768:	18800336 	bltu	r3,r2,3223778 <c_older+0xb4>
      return(ct1);
 322376c:	e0bffd17 	ldw	r2,-12(fp)
 3223770:	e0bfff15 	stw	r2,-4(fp)
 3223774:	00000206 	br	3223780 <c_older+0xbc>
   else
      return(ct2);
 3223778:	e0bffe17 	ldw	r2,-8(fp)
 322377c:	e0bfff15 	stw	r2,-4(fp)
 3223780:	e0bfff17 	ldw	r2,-4(fp)
}
 3223784:	e037883a 	mov	sp,fp
 3223788:	df000017 	ldw	fp,0(sp)
 322378c:	dec00104 	addi	sp,sp,4
 3223790:	f800283a 	ret

03223794 <ip2mac>:
 */

int
ip2mac(PACKET pkt,         /* the packet itself, all set but for dest MAC address */
   ip_addr  dest_ip)    /* the IP host or gateway to get MAC addr for */
{
 3223794:	defffa04 	addi	sp,sp,-24
 3223798:	dfc00515 	stw	ra,20(sp)
 322379c:	df000415 	stw	fp,16(sp)
 32237a0:	df000404 	addi	fp,sp,16
 32237a4:	e13ffd15 	stw	r4,-12(fp)
 32237a8:	e17ffe15 	stw	r5,-8(fp)
   IFMIB ifmib = pkt->net->n_mib;   /* mib info for this interface */
 32237ac:	e0bffd17 	ldw	r2,-12(fp)
 32237b0:	10800617 	ldw	r2,24(r2)
 32237b4:	10802717 	ldw	r2,156(r2)
 32237b8:	e0bffc15 	stw	r2,-16(fp)

   /* Always punt if iface ifAdminStatus is DOWN. ifOperStatus may 
    * be down too, but our packet may be the event required to bring 
    * it up - so don't worry about ifOperStatus here.
    */
   if(ifmib->ifAdminStatus == NI_DOWN)
 32237bc:	e0bffc17 	ldw	r2,-16(fp)
 32237c0:	10800617 	ldw	r2,24(r2)
 32237c4:	10800098 	cmpnei	r2,r2,2
 32237c8:	1000091e 	bne	r2,zero,32237f0 <ip2mac+0x5c>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 32237cc:	01000084 	movi	r4,2
 32237d0:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(pkt);
 32237d4:	e13ffd17 	ldw	r4,-12(fp)
 32237d8:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32237dc:	01000084 	movi	r4,2
 32237e0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return(ENP_NO_ROUTE);
 32237e4:	00bff7c4 	movi	r2,-33
 32237e8:	e0bfff15 	stw	r2,-4(fp)
 32237ec:	00004c06 	br	3223920 <ip2mac+0x18c>
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 32237f0:	e0bffd17 	ldw	r2,-12(fp)
 32237f4:	10800617 	ldw	r2,24(r2)
 32237f8:	10800817 	ldw	r2,32(r2)
 32237fc:	1005003a 	cmpeq	r2,r2,zero
 3223800:	1000081e 	bne	r2,zero,3223824 <ip2mac+0x90>
 3223804:	e0bffc17 	ldw	r2,-16(fp)
 3223808:	10800217 	ldw	r2,8(r2)
 322380c:	108005e0 	cmpeqi	r2,r2,23
 3223810:	1000041e 	bne	r2,zero,3223824 <ip2mac+0x90>
 3223814:	e0bffc17 	ldw	r2,-16(fp)
 3223818:	10800217 	ldw	r2,8(r2)
 322381c:	10800718 	cmpnei	r2,r2,28
 3223820:	1000291e 	bne	r2,zero,32238c8 <ip2mac+0x134>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
       (ifmib->ifType == SLIP))
   {
      ifmib->ifOutUcastPkts++;   /* maintain MIB counters */
 3223824:	e0bffc17 	ldw	r2,-16(fp)
 3223828:	10801017 	ldw	r2,64(r2)
 322382c:	10c00044 	addi	r3,r2,1
 3223830:	e0bffc17 	ldw	r2,-16(fp)
 3223834:	10c01015 	stw	r3,64(r2)
      ifmib->ifOutOctets += pkt->nb_plen;
 3223838:	e0bffc17 	ldw	r2,-16(fp)
 322383c:	10c00f17 	ldw	r3,60(r2)
 3223840:	e0bffd17 	ldw	r2,-12(fp)
 3223844:	10800417 	ldw	r2,16(r2)
 3223848:	1887883a 	add	r3,r3,r2
 322384c:	e0bffc17 	ldw	r2,-16(fp)
 3223850:	10c00f15 	stw	r3,60(r2)

      /* send packet on media */
      if (pkt->net->pkt_send) /* favor using packet send */
 3223854:	e0bffd17 	ldw	r2,-12(fp)
 3223858:	10800617 	ldw	r2,24(r2)
 322385c:	10800417 	ldw	r2,16(r2)
 3223860:	1005003a 	cmpeq	r2,r2,zero
 3223864:	1000061e 	bne	r2,zero,3223880 <ip2mac+0xec>
         pkt->net->pkt_send(pkt);   /* pkt will be freed by MAC code */
 3223868:	e0bffd17 	ldw	r2,-12(fp)
 322386c:	10800617 	ldw	r2,24(r2)
 3223870:	10800417 	ldw	r2,16(r2)
 3223874:	e13ffd17 	ldw	r4,-12(fp)
 3223878:	103ee83a 	callr	r2
 322387c:	00001006 	br	32238c0 <ip2mac+0x12c>
      else  /* no packet send; try raw send */
      {
         pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 3223880:	e0bffd17 	ldw	r2,-12(fp)
 3223884:	10800617 	ldw	r2,24(r2)
 3223888:	10c00317 	ldw	r3,12(r2)
 322388c:	e0bffd17 	ldw	r2,-12(fp)
 3223890:	11000617 	ldw	r4,24(r2)
 3223894:	e0bffd17 	ldw	r2,-12(fp)
 3223898:	11400317 	ldw	r5,12(r2)
 322389c:	e0bffd17 	ldw	r2,-12(fp)
 32238a0:	11800417 	ldw	r6,16(r2)
 32238a4:	183ee83a 	callr	r3
         LOCK_NET_RESOURCE(FREEQ_RESID);
 32238a8:	01000084 	movi	r4,2
 32238ac:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pk_free(pkt);
 32238b0:	e13ffd17 	ldw	r4,-12(fp)
 32238b4:	322a2dc0 	call	322a2dc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32238b8:	01000084 	movi	r4,2
 32238bc:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      }
      return(SUCCESS);
 32238c0:	e03fff15 	stw	zero,-4(fp)
 32238c4:	00001606 	br	3223920 <ip2mac+0x18c>
   }

   /* don't allow unicast sends if NIC iface has no IP address. This
    * is to prevent DHCP clients from sending prior to assignment.
    */
   if (pkt->net->n_ipaddr == 0L)
 32238c8:	e0bffd17 	ldw	r2,-12(fp)
 32238cc:	10800617 	ldw	r2,24(r2)
 32238d0:	10800a17 	ldw	r2,40(r2)
 32238d4:	1004c03a 	cmpne	r2,r2,zero
 32238d8:	10000d1e 	bne	r2,zero,3223910 <ip2mac+0x17c>
   {
      if (pkt->fhost != 0xFFFFFFFF) /* check for broadcast packet */
 32238dc:	e0bffd17 	ldw	r2,-12(fp)
 32238e0:	10800717 	ldw	r2,28(r2)
 32238e4:	10bfffe0 	cmpeqi	r2,r2,-1
 32238e8:	1000091e 	bne	r2,zero,3223910 <ip2mac+0x17c>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 32238ec:	01000084 	movi	r4,2
 32238f0:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pk_free(pkt);
 32238f4:	e13ffd17 	ldw	r4,-12(fp)
 32238f8:	322a2dc0 	call	322a2dc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32238fc:	01000084 	movi	r4,2
 3223900:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         return ENP_SENDERR;
 3223904:	00bff884 	movi	r2,-30
 3223908:	e0bfff15 	stw	r2,-4(fp)
 322390c:	00000406 	br	3223920 <ip2mac+0x18c>
      }
   }

#ifdef INCLUDE_ARP   /* must be ethernet or token ring */
   return(send_via_arp(pkt, dest_ip));
 3223910:	e13ffd17 	ldw	r4,-12(fp)
 3223914:	e17ffe17 	ldw	r5,-8(fp)
 3223918:	323ddcc0 	call	323ddcc <send_via_arp>
 322391c:	e0bfff15 	stw	r2,-4(fp)
 3223920:	e0bfff17 	ldw	r2,-4(fp)
#else
   dtrap();    /* Bad option combination? */
   return ENP_NO_IFACE; /* sent to unknown interface type */
#endif   /* INCLUDE_ARP */
}
 3223924:	e037883a 	mov	sp,fp
 3223928:	dfc00117 	ldw	ra,4(sp)
 322392c:	df000017 	ldw	fp,0(sp)
 3223930:	dec00204 	addi	sp,sp,8
 3223934:	f800283a 	ret

03223938 <ip_startup>:
 * RETURNS: returns NULL if OK, or text of an error message 
 */

char *   
ip_startup()
{
 3223938:	defffb04 	addi	sp,sp,-20
 322393c:	dfc00415 	stw	ra,16(sp)
 3223940:	df000315 	stw	fp,12(sp)
 3223944:	df000304 	addi	fp,sp,12
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 3223948:	e03ffd15 	stw	zero,-12(fp)
 322394c:	00002a06 	br	32239f8 <ip_startup+0xc0>
   {
      nets[i] = &netstatic[i];   /* set up array of pointers */
 3223950:	e13ffd17 	ldw	r4,-12(fp)
 3223954:	e0bffd17 	ldw	r2,-12(fp)
 3223958:	10803024 	muli	r2,r2,192
 322395c:	1007883a 	mov	r3,r2
 3223960:	0080c9b4 	movhi	r2,806
 3223964:	10b19a04 	addi	r2,r2,-14744
 3223968:	188b883a 	add	r5,r3,r2
 322396c:	00c0c9b4 	movhi	r3,806
 3223970:	18f25a04 	addi	r3,r3,-13976
 3223974:	2105883a 	add	r2,r4,r4
 3223978:	1085883a 	add	r2,r2,r2
 322397c:	10c5883a 	add	r2,r2,r3
 3223980:	11400015 	stw	r5,0(r2)
      nets[i]->n_mib = &nets[i]->mib;   /* set mib pointer */
 3223984:	e0bffd17 	ldw	r2,-12(fp)
 3223988:	00c0c9b4 	movhi	r3,806
 322398c:	18f25a04 	addi	r3,r3,-13976
 3223990:	1085883a 	add	r2,r2,r2
 3223994:	1085883a 	add	r2,r2,r2
 3223998:	10c5883a 	add	r2,r2,r3
 322399c:	11000017 	ldw	r4,0(r2)
 32239a0:	e0bffd17 	ldw	r2,-12(fp)
 32239a4:	00c0c9b4 	movhi	r3,806
 32239a8:	18f25a04 	addi	r3,r3,-13976
 32239ac:	1085883a 	add	r2,r2,r2
 32239b0:	1085883a 	add	r2,r2,r2
 32239b4:	10c5883a 	add	r2,r2,r3
 32239b8:	10800017 	ldw	r2,0(r2)
 32239bc:	10801204 	addi	r2,r2,72
 32239c0:	20802715 	stw	r2,156(r4)

      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
 32239c4:	e0bffd17 	ldw	r2,-12(fp)
 32239c8:	00c0c9b4 	movhi	r3,806
 32239cc:	18f25a04 	addi	r3,r3,-13976
 32239d0:	1085883a 	add	r2,r2,r2
 32239d4:	1085883a 	add	r2,r2,r2
 32239d8:	10c5883a 	add	r2,r2,r3
 32239dc:	11400017 	ldw	r5,0(r2)
 32239e0:	0100c9b4 	movhi	r4,806
 32239e4:	21345b04 	addi	r4,r4,-11924
 32239e8:	322a51c0 	call	322a51c <putq>
{
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 32239ec:	e0bffd17 	ldw	r2,-12(fp)
 32239f0:	10800044 	addi	r2,r2,1
 32239f4:	e0bffd15 	stw	r2,-12(fp)
 32239f8:	e0bffd17 	ldw	r2,-12(fp)
 32239fc:	10800110 	cmplti	r2,r2,4
 3223a00:	103fd31e 	bne	r2,zero,3223950 <ip_startup+0x18>
      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
   }

   /* call port routine to locate and init network interfaces. */
   ifNumber = (unsigned)prep_ifaces(ifNumber);
 3223a04:	d0a8bb17 	ldw	r2,-23828(gp)
 3223a08:	1009883a 	mov	r4,r2
 3223a0c:	324375c0 	call	324375c <prep_ifaces>
 3223a10:	d0a8bb15 	stw	r2,-23828(gp)

   if (ifNumber < 1)    /* no static interfaces? */
 3223a14:	d0a8bb17 	ldw	r2,-23828(gp)
 3223a18:	1004c03a 	cmpne	r2,r2,zero
 3223a1c:	1000041e 	bne	r2,zero,3223a30 <ip_startup+0xf8>
#ifdef DYNAMIC_IFACES
      /* print a debug message and hope user knows what he's doing */
      dprintf("unable to find any working interfaces");
#else /* static ifaces only */
      /* no static and no dynamic interfaces is probably a bug... */
      return("unable to find any working interfaces");
 3223a20:	0080c974 	movhi	r2,805
 3223a24:	10b9bf04 	addi	r2,r2,-6404
 3223a28:	e0bfff15 	stw	r2,-4(fp)
 3223a2c:	00007506 	br	3223c04 <ip_startup+0x2cc>
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 3223a30:	d0a8bb17 	ldw	r2,-23828(gp)
 3223a34:	e0bffd15 	stw	r2,-12(fp)
 3223a38:	00001506 	br	3223a90 <ip_startup+0x158>
   {
      qdel(&netlist, (qp)nets[i]);  /* remove from queue */
 3223a3c:	e0bffd17 	ldw	r2,-12(fp)
 3223a40:	00c0c9b4 	movhi	r3,806
 3223a44:	18f25a04 	addi	r3,r3,-13976
 3223a48:	1085883a 	add	r2,r2,r2
 3223a4c:	1085883a 	add	r2,r2,r2
 3223a50:	10c5883a 	add	r2,r2,r3
 3223a54:	10800017 	ldw	r2,0(r2)
 3223a58:	100b883a 	mov	r5,r2
 3223a5c:	0100c9b4 	movhi	r4,806
 3223a60:	21345b04 	addi	r4,r4,-11924
 3223a64:	322a5cc0 	call	322a5cc <qdel>
      nets[i] = NULL;               /* remove from array */
 3223a68:	e0bffd17 	ldw	r2,-12(fp)
 3223a6c:	00c0c9b4 	movhi	r3,806
 3223a70:	18f25a04 	addi	r3,r3,-13976
 3223a74:	1085883a 	add	r2,r2,r2
 3223a78:	1085883a 	add	r2,r2,r2
 3223a7c:	10c5883a 	add	r2,r2,r3
 3223a80:	10000015 	stw	zero,0(r2)
      return("unable to find any working interfaces");
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 3223a84:	e0bffd17 	ldw	r2,-12(fp)
 3223a88:	10800044 	addi	r2,r2,1
 3223a8c:	e0bffd15 	stw	r2,-12(fp)
 3223a90:	e0bffd17 	ldw	r2,-12(fp)
 3223a94:	10800110 	cmplti	r2,r2,4
 3223a98:	103fe81e 	bne	r2,zero,3223a3c <ip_startup+0x104>
   /* The sequence of events when initing the net & interface systems 
    * is very important. Be very carefull about altering the order of 
    * the following statements. 
    */
   /* once these are done, we should call ip_exit before quiting IP */
   clock_init();           /* start clock system */
 3223a9c:	322acc80 	call	322acc8 <clock_init>
   exit_hook(clock_c);
 3223aa0:	0100c8f4 	movhi	r4,803
 3223aa4:	212b4104 	addi	r4,r4,-21244
 3223aa8:	3223c1c0 	call	3223c1c <exit_hook>

   e = Netinit();    /* start net interface(s) */
 3223aac:	3222a5c0 	call	3222a5c <Netinit>
 3223ab0:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 3223ab4:	e0bffe17 	ldw	r2,-8(fp)
 3223ab8:	1005003a 	cmpeq	r2,r2,zero
 3223abc:	1000041e 	bne	r2,zero,3223ad0 <ip_startup+0x198>
   {
      return("unable to initialize net");
 3223ac0:	0080c974 	movhi	r2,805
 3223ac4:	10b9c904 	addi	r2,r2,-6364
 3223ac8:	e0bfff15 	stw	r2,-4(fp)
 3223acc:	00004d06 	br	3223c04 <ip_startup+0x2cc>
   }

#ifdef INCLUDE_ARP
   e = etainit();          /* startup ARP layer */
 3223ad0:	323ceb80 	call	323ceb8 <etainit>
 3223ad4:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 3223ad8:	e0bffe17 	ldw	r2,-8(fp)
 3223adc:	1005003a 	cmpeq	r2,r2,zero
 3223ae0:	1000051e 	bne	r2,zero,3223af8 <ip_startup+0x1c0>
   {
      ip_exit();
 3223ae4:	3223c880 	call	3223c88 <ip_exit>
      return("unable to initialize arp");
 3223ae8:	0080c974 	movhi	r2,805
 3223aec:	10b9d004 	addi	r2,r2,-6336
 3223af0:	e0bfff15 	stw	r2,-4(fp)
 3223af4:	00004306 	br	3223c04 <ip_startup+0x2cc>
   }
#endif

#ifdef IP_V4
   e = ip_init();       /* start up IP layer */
 3223af8:	323e5f00 	call	323e5f0 <ip_init>
 3223afc:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 3223b00:	e0bffe17 	ldw	r2,-8(fp)
 3223b04:	1005003a 	cmpeq	r2,r2,zero
 3223b08:	1000051e 	bne	r2,zero,3223b20 <ip_startup+0x1e8>
   {
      ip_exit();
 3223b0c:	3223c880 	call	3223c88 <ip_exit>
      return("unable to initialize IP");
 3223b10:	0080c974 	movhi	r2,805
 3223b14:	10b9d704 	addi	r2,r2,-6308
 3223b18:	e0bfff15 	stw	r2,-4(fp)
 3223b1c:	00003906 	br	3223c04 <ip_startup+0x2cc>

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Join the All hosts group on every interface that IP multicast is
    * supported
    */
   e = igmp_init();         /* Initialize igmp */
 3223b20:	3223de80 	call	3223de8 <igmp_init>
 3223b24:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 3223b28:	e0bffe17 	ldw	r2,-8(fp)
 3223b2c:	1005003a 	cmpeq	r2,r2,zero
 3223b30:	1000041e 	bne	r2,zero,3223b44 <ip_startup+0x20c>
   {
      ip_exit();
 3223b34:	3223c880 	call	3223c88 <ip_exit>
      return(ipmcfail_str);
 3223b38:	d0a02c17 	ldw	r2,-32592(gp)
 3223b3c:	e0bfff15 	stw	r2,-4(fp)
 3223b40:	00003006 	br	3223c04 <ip_startup+0x2cc>
   }

   for (i = 0; i < (int)ifNumber; i++)
 3223b44:	e03ffd15 	stw	zero,-12(fp)
 3223b48:	00001e06 	br	3223bc4 <ip_startup+0x28c>
   {
      if (nets[i]->n_mcastlist != NULL)
 3223b4c:	e0bffd17 	ldw	r2,-12(fp)
 3223b50:	00c0c9b4 	movhi	r3,806
 3223b54:	18f25a04 	addi	r3,r3,-13976
 3223b58:	1085883a 	add	r2,r2,r2
 3223b5c:	1085883a 	add	r2,r2,r2
 3223b60:	10c5883a 	add	r2,r2,r3
 3223b64:	10800017 	ldw	r2,0(r2)
 3223b68:	10802b17 	ldw	r2,172(r2)
 3223b6c:	1005003a 	cmpeq	r2,r2,zero
 3223b70:	1000111e 	bne	r2,zero,3223bb8 <ip_startup+0x280>
         if ((in_addmulti(&igmp_all_hosts_group, nets[i], 4) == NULL))
 3223b74:	e0bffd17 	ldw	r2,-12(fp)
 3223b78:	00c0c9b4 	movhi	r3,806
 3223b7c:	18f25a04 	addi	r3,r3,-13976
 3223b80:	1085883a 	add	r2,r2,r2
 3223b84:	1085883a 	add	r2,r2,r2
 3223b88:	10c5883a 	add	r2,r2,r3
 3223b8c:	11400017 	ldw	r5,0(r2)
 3223b90:	0100c974 	movhi	r4,805
 3223b94:	21123604 	addi	r4,r4,18648
 3223b98:	01800104 	movi	r6,4
 3223b9c:	324346c0 	call	324346c <in_addmulti>
 3223ba0:	1004c03a 	cmpne	r2,r2,zero
 3223ba4:	1000041e 	bne	r2,zero,3223bb8 <ip_startup+0x280>
      {
         ip_exit();
 3223ba8:	3223c880 	call	3223c88 <ip_exit>
         return(ipmcfail_str);
 3223bac:	d0a02c17 	ldw	r2,-32592(gp)
 3223bb0:	e0bfff15 	stw	r2,-4(fp)
 3223bb4:	00001306 	br	3223c04 <ip_startup+0x2cc>
   {
      ip_exit();
      return(ipmcfail_str);
   }

   for (i = 0; i < (int)ifNumber; i++)
 3223bb8:	e0bffd17 	ldw	r2,-12(fp)
 3223bbc:	10800044 	addi	r2,r2,1
 3223bc0:	e0bffd15 	stw	r2,-12(fp)
 3223bc4:	d0a8bb17 	ldw	r2,-23828(gp)
 3223bc8:	1007883a 	mov	r3,r2
 3223bcc:	e0bffd17 	ldw	r2,-12(fp)
 3223bd0:	10ffde16 	blt	r2,r3,3223b4c <ip_startup+0x214>
      }
   }
#endif /* IP_MULTICAST and (IGMPv1 or IGMPv2) */   

#ifdef INCLUDE_TCP
   e = tcpinit();
 3223bd4:	32392140 	call	3239214 <tcpinit>
 3223bd8:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 3223bdc:	e0bffe17 	ldw	r2,-8(fp)
 3223be0:	1005003a 	cmpeq	r2,r2,zero
 3223be4:	1000051e 	bne	r2,zero,3223bfc <ip_startup+0x2c4>
   {
      ip_exit();
 3223be8:	3223c880 	call	3223c88 <ip_exit>
      return("unable to initialize TCP");
 3223bec:	0080c974 	movhi	r2,805
 3223bf0:	10b9dd04 	addi	r2,r2,-6284
 3223bf4:	e0bfff15 	stw	r2,-4(fp)
 3223bf8:	00000206 	br	3223c04 <ip_startup+0x2cc>
   /* setup event map for (UDP and TCP) socket library's events (such as 
    * those used by tcp_sleep () and tcp_wakeup ()).  These events either 
    * map into operating system primitives such as events or semaphores, 
    * or into task suspend and task resume mechanisms.
    */
   evtmap_setup ();
 3223bfc:	32438180 	call	3243818 <evtmap_setup>
      return("unable to initialize IP Filter table");
   else
      exit_hook(ipf_cleanup);
#endif

   return(NULL);     /* we got through with no errors */
 3223c00:	e03fff15 	stw	zero,-4(fp)
 3223c04:	e0bfff17 	ldw	r2,-4(fp)
}
 3223c08:	e037883a 	mov	sp,fp
 3223c0c:	dfc00117 	ldw	ra,4(sp)
 3223c10:	df000017 	ldw	fp,0(sp)
 3223c14:	dec00204 	addi	sp,sp,8
 3223c18:	f800283a 	ret

03223c1c <exit_hook>:
 * RETURNS: 
 */

void
exit_hook(void (*func)(void))
{
 3223c1c:	defffd04 	addi	sp,sp,-12
 3223c20:	dfc00215 	stw	ra,8(sp)
 3223c24:	df000115 	stw	fp,4(sp)
 3223c28:	df000104 	addi	fp,sp,4
 3223c2c:	e13fff15 	stw	r4,-4(fp)
   if (nclosers >= (NUMCLOSERS-1))
 3223c30:	d0a8bc17 	ldw	r2,-23824(gp)
 3223c34:	10800390 	cmplti	r2,r2,14
 3223c38:	1000031e 	bne	r2,zero,3223c48 <exit_hook+0x2c>
      panic("exit_hook");
 3223c3c:	0100c974 	movhi	r4,805
 3223c40:	2139e404 	addi	r4,r4,-6256
 3223c44:	3225df00 	call	3225df0 <panic>

   closers[++nclosers] = func;
 3223c48:	d0a8bc17 	ldw	r2,-23824(gp)
 3223c4c:	10800044 	addi	r2,r2,1
 3223c50:	d0a8bc15 	stw	r2,-23824(gp)
 3223c54:	d0a8bc17 	ldw	r2,-23824(gp)
 3223c58:	00c0c974 	movhi	r3,805
 3223c5c:	18d49a04 	addi	r3,r3,21096
 3223c60:	1085883a 	add	r2,r2,r2
 3223c64:	1085883a 	add	r2,r2,r2
 3223c68:	10c7883a 	add	r3,r2,r3
 3223c6c:	e0bfff17 	ldw	r2,-4(fp)
 3223c70:	18800015 	stw	r2,0(r3)
}
 3223c74:	e037883a 	mov	sp,fp
 3223c78:	dfc00117 	ldw	ra,4(sp)
 3223c7c:	df000017 	ldw	fp,0(sp)
 3223c80:	dec00204 	addi	sp,sp,8
 3223c84:	f800283a 	ret

03223c88 <ip_exit>:
 * RETURNS: void
 */

void
ip_exit()
{
 3223c88:	defffd04 	addi	sp,sp,-12
 3223c8c:	dfc00215 	stw	ra,8(sp)
 3223c90:	df000115 	stw	fp,4(sp)
 3223c94:	df000104 	addi	fp,sp,4
   int   n;

   for (n=nclosers; n; n--)
 3223c98:	d0a8bc17 	ldw	r2,-23824(gp)
 3223c9c:	e0bfff15 	stw	r2,-4(fp)
 3223ca0:	00002506 	br	3223d38 <ip_exit+0xb0>
   {
#ifdef NPDEBUG
      dprintf("ip_exit: calling func %p\n", closers[n]);
 3223ca4:	e0bfff17 	ldw	r2,-4(fp)
 3223ca8:	00c0c974 	movhi	r3,805
 3223cac:	18d49a04 	addi	r3,r3,21096
 3223cb0:	1085883a 	add	r2,r2,r2
 3223cb4:	1085883a 	add	r2,r2,r2
 3223cb8:	10c5883a 	add	r2,r2,r3
 3223cbc:	11400017 	ldw	r5,0(r2)
 3223cc0:	0100c974 	movhi	r4,805
 3223cc4:	2139e704 	addi	r4,r4,-6244
 3223cc8:	3206adc0 	call	3206adc <printf>
#endif
      if(closers[n])
 3223ccc:	e0bfff17 	ldw	r2,-4(fp)
 3223cd0:	00c0c974 	movhi	r3,805
 3223cd4:	18d49a04 	addi	r3,r3,21096
 3223cd8:	1085883a 	add	r2,r2,r2
 3223cdc:	1085883a 	add	r2,r2,r2
 3223ce0:	10c5883a 	add	r2,r2,r3
 3223ce4:	10800017 	ldw	r2,0(r2)
 3223ce8:	1005003a 	cmpeq	r2,r2,zero
 3223cec:	10000f1e 	bne	r2,zero,3223d2c <ip_exit+0xa4>
      {
         (*closers[n])();
 3223cf0:	e0bfff17 	ldw	r2,-4(fp)
 3223cf4:	00c0c974 	movhi	r3,805
 3223cf8:	18d49a04 	addi	r3,r3,21096
 3223cfc:	1085883a 	add	r2,r2,r2
 3223d00:	1085883a 	add	r2,r2,r2
 3223d04:	10c5883a 	add	r2,r2,r3
 3223d08:	10800017 	ldw	r2,0(r2)
 3223d0c:	103ee83a 	callr	r2
         closers[n] = NULL;
 3223d10:	e0bfff17 	ldw	r2,-4(fp)
 3223d14:	00c0c974 	movhi	r3,805
 3223d18:	18d49a04 	addi	r3,r3,21096
 3223d1c:	1085883a 	add	r2,r2,r2
 3223d20:	1085883a 	add	r2,r2,r2
 3223d24:	10c5883a 	add	r2,r2,r3
 3223d28:	10000015 	stw	zero,0(r2)
void
ip_exit()
{
   int   n;

   for (n=nclosers; n; n--)
 3223d2c:	e0bfff17 	ldw	r2,-4(fp)
 3223d30:	10bfffc4 	addi	r2,r2,-1
 3223d34:	e0bfff15 	stw	r2,-4(fp)
 3223d38:	e0bfff17 	ldw	r2,-4(fp)
 3223d3c:	1004c03a 	cmpne	r2,r2,zero
 3223d40:	103fd81e 	bne	r2,zero,3223ca4 <ip_exit+0x1c>
      {
         (*closers[n])();
         closers[n] = NULL;
      }
   }
}
 3223d44:	e037883a 	mov	sp,fp
 3223d48:	dfc00117 	ldw	ra,4(sp)
 3223d4c:	df000017 	ldw	fp,0(sp)
 3223d50:	dec00204 	addi	sp,sp,8
 3223d54:	f800283a 	ret

03223d58 <if_netnumber>:
 * RETURNS: net index for passed net pointer
 */

int
if_netnumber(NET nptr)
{
 3223d58:	defffa04 	addi	sp,sp,-24
 3223d5c:	dfc00515 	stw	ra,20(sp)
 3223d60:	df000415 	stw	fp,16(sp)
 3223d64:	df000404 	addi	fp,sp,16
 3223d68:	e13ffe15 	stw	r4,-8(fp)
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 3223d6c:	0080c9b4 	movhi	r2,806
 3223d70:	10b45b04 	addi	r2,r2,-11924
 3223d74:	10800017 	ldw	r2,0(r2)
 3223d78:	e0bffc15 	stw	r2,-16(fp)
 3223d7c:	e03ffd15 	stw	zero,-12(fp)
 3223d80:	00000c06 	br	3223db4 <if_netnumber+0x5c>
   {
      if(ifp == nptr)
 3223d84:	e0fffc17 	ldw	r3,-16(fp)
 3223d88:	e0bffe17 	ldw	r2,-8(fp)
 3223d8c:	1880031e 	bne	r3,r2,3223d9c <if_netnumber+0x44>
        return (int)i;
 3223d90:	e0bffd17 	ldw	r2,-12(fp)
 3223d94:	e0bfff15 	stw	r2,-4(fp)
 3223d98:	00000d06 	br	3223dd0 <if_netnumber+0x78>
if_netnumber(NET nptr)
{
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 3223d9c:	e0bffc17 	ldw	r2,-16(fp)
 3223da0:	10800017 	ldw	r2,0(r2)
 3223da4:	e0bffc15 	stw	r2,-16(fp)
 3223da8:	e0bffd17 	ldw	r2,-12(fp)
 3223dac:	10800044 	addi	r2,r2,1
 3223db0:	e0bffd15 	stw	r2,-12(fp)
 3223db4:	e0bffc17 	ldw	r2,-16(fp)
 3223db8:	1004c03a 	cmpne	r2,r2,zero
 3223dbc:	103ff11e 	bne	r2,zero,3223d84 <if_netnumber+0x2c>
   {
      if(ifp == nptr)
        return (int)i;
   }

   panic("bad net ptr");
 3223dc0:	0100c974 	movhi	r4,805
 3223dc4:	2139ee04 	addi	r4,r4,-6216
 3223dc8:	3225df00 	call	3225df0 <panic>
   return 0;
 3223dcc:	e03fff15 	stw	zero,-4(fp)
 3223dd0:	e0bfff17 	ldw	r2,-4(fp)
}
 3223dd4:	e037883a 	mov	sp,fp
 3223dd8:	dfc00117 	ldw	ra,4(sp)
 3223ddc:	df000017 	ldw	fp,0(sp)
 3223de0:	dec00204 	addi	sp,sp,8
 3223de4:	f800283a 	ret

03223de8 <igmp_init>:
 *
 * OUTPUT: None.
 */

int igmp_init(void)
{
 3223de8:	defffe04 	addi	sp,sp,-8
 3223dec:	df000115 	stw	fp,4(sp)
 3223df0:	df000104 	addi	fp,sp,4
   NET ifp;

   /*
    * To avoid byte-swapping the same value over and over again.
    */
   igmp_all_hosts_group = htonl(INADDR_ALLHOSTS_GROUP);
 3223df4:	00804034 	movhi	r2,256
 3223df8:	10803804 	addi	r2,r2,224
 3223dfc:	d0a8bf15 	stw	r2,-23812(gp)
   igmp_all_rtrs_group = htonl(INADDR_ALLRTRS_GROUP);
 3223e00:	00808034 	movhi	r2,512
 3223e04:	10803804 	addi	r2,r2,224
 3223e08:	d0a8c015 	stw	r2,-23808(gp)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 3223e0c:	0080c9b4 	movhi	r2,806
 3223e10:	10b45b04 	addi	r2,r2,-11924
 3223e14:	10800017 	ldw	r2,0(r2)
 3223e18:	e0bfff15 	stw	r2,-4(fp)
 3223e1c:	00001006 	br	3223e60 <igmp_init+0x78>
   {
      if (ifp->igmp_oper_mode == IGMP_MODE_V1)
 3223e20:	e0bfff17 	ldw	r2,-4(fp)
 3223e24:	10802f03 	ldbu	r2,188(r2)
 3223e28:	10803fcc 	andi	r2,r2,255
 3223e2c:	10800058 	cmpnei	r2,r2,1
 3223e30:	1000041e 	bne	r2,zero,3223e44 <igmp_init+0x5c>
      {
         ifp->igmpv1_rtr_present = 1;
 3223e34:	e0ffff17 	ldw	r3,-4(fp)
 3223e38:	00800044 	movi	r2,1
 3223e3c:	18802d05 	stb	r2,180(r3)
 3223e40:	00000406 	br	3223e54 <igmp_init+0x6c>
      }
      else
      {
         ifp->igmpv1_rtr_present = 0;
 3223e44:	e0bfff17 	ldw	r2,-4(fp)
 3223e48:	10002d05 	stb	zero,180(r2)
         /* not really required, only referred to if IGMPv1 router is 
          * "present" */
         ifp->igmpv1_query_rcvd_time = 0;
 3223e4c:	e0bfff17 	ldw	r2,-4(fp)
 3223e50:	10002e15 	stw	zero,184(r2)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 3223e54:	e0bfff17 	ldw	r2,-4(fp)
 3223e58:	10800017 	ldw	r2,0(r2)
 3223e5c:	e0bfff15 	stw	r2,-4(fp)
 3223e60:	e0bfff17 	ldw	r2,-4(fp)
 3223e64:	1004c03a 	cmpne	r2,r2,zero
 3223e68:	103fed1e 	bne	r2,zero,3223e20 <igmp_init+0x38>
   }

   /*
    * Call igmp_fasttimo PR_FASTHZ (5) times per second
    */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 3223e6c:	0080c974 	movhi	r2,805
 3223e70:	10925604 	addi	r2,r2,18776
 3223e74:	10800017 	ldw	r2,0(r2)
 3223e78:	10803204 	addi	r2,r2,200
 3223e7c:	d0a8be15 	stw	r2,-23816(gp)

   /* there are no timers running initially */
   igmp_timers_are_running = 0;
 3223e80:	d028bd15 	stw	zero,-23820(gp)

   return IGMP_OK;
 3223e84:	0005883a 	mov	r2,zero
}
 3223e88:	e037883a 	mov	sp,fp
 3223e8c:	df000017 	ldw	fp,0(sp)
 3223e90:	dec00104 	addi	sp,sp,4
 3223e94:	f800283a 	ret

03223e98 <igmp_input>:
 * returned if the operating mode is not correctly configured
 * to a valid IGMP operating mode.
 */

int igmp_input (PACKET p)
{
 3223e98:	defff904 	addi	sp,sp,-28
 3223e9c:	dfc00615 	stw	ra,24(sp)
 3223ea0:	df000515 	stw	fp,20(sp)
 3223ea4:	df000504 	addi	fp,sp,20
 3223ea8:	e13ffd15 	stw	r4,-12(fp)
   u_char mode;
   int rc;
     
   ++igmpstats.igmp_total_rcvd;
 3223eac:	0080c9b4 	movhi	r2,806
 3223eb0:	10b25e04 	addi	r2,r2,-13960
 3223eb4:	10800017 	ldw	r2,0(r2)
 3223eb8:	10c00044 	addi	r3,r2,1
 3223ebc:	0080c9b4 	movhi	r2,806
 3223ec0:	10b25e04 	addi	r2,r2,-13960
 3223ec4:	10c00015 	stw	r3,0(r2)
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 3223ec8:	e13ffd17 	ldw	r4,-12(fp)
 3223ecc:	32246bc0 	call	32246bc <igmp_validate>
 3223ed0:	e0bffb15 	stw	r2,-20(fp)
 3223ed4:	e0bffb17 	ldw	r2,-20(fp)
 3223ed8:	1004c03a 	cmpne	r2,r2,zero
 3223edc:	10001e1e 	bne	r2,zero,3223f58 <igmp_input+0xc0>

   /* determine the operating mode for IGMP on the ingress link */
   mode = p->net->igmp_oper_mode;
 3223ee0:	e0bffd17 	ldw	r2,-12(fp)
 3223ee4:	10800617 	ldw	r2,24(r2)
 3223ee8:	10802f03 	ldbu	r2,188(r2)
 3223eec:	e0bffc05 	stb	r2,-16(fp)
   
   /* feed packet to IGMPv1 or IGMPv2 code based on the operating
    * mode of the ingress link */
   switch (mode)
 3223ef0:	e0bffc03 	ldbu	r2,-16(fp)
 3223ef4:	e0bfff15 	stw	r2,-4(fp)
 3223ef8:	e0ffff17 	ldw	r3,-4(fp)
 3223efc:	18800060 	cmpeqi	r2,r3,1
 3223f00:	1000041e 	bne	r2,zero,3223f14 <igmp_input+0x7c>
 3223f04:	e0ffff17 	ldw	r3,-4(fp)
 3223f08:	188000a0 	cmpeqi	r2,r3,2
 3223f0c:	1000051e 	bne	r2,zero,3223f24 <igmp_input+0x8c>
 3223f10:	00000806 	br	3223f34 <igmp_input+0x9c>
   {
#ifdef IGMP_V1   
      case IGMP_MODE_V1:   
         return (igmpv1_input (p)); 
 3223f14:	e13ffd17 	ldw	r4,-12(fp)
 3223f18:	32452bc0 	call	32452bc <igmpv1_input>
 3223f1c:	e0bffe15 	stw	r2,-8(fp)
 3223f20:	00001506 	br	3223f78 <igmp_input+0xe0>
#endif
#ifdef IGMP_V2         
      case IGMP_MODE_V2:       
         return (igmpv2_input (p));
 3223f24:	e13ffd17 	ldw	r4,-12(fp)
 3223f28:	32455a40 	call	32455a4 <igmpv2_input>
 3223f2c:	e0bffe15 	stw	r2,-8(fp)
 3223f30:	00001106 	br	3223f78 <igmp_input+0xe0>
#endif
      default:
         ++igmpstats.igmp_bad_oper_mode;     
 3223f34:	0080c9b4 	movhi	r2,806
 3223f38:	10b25e04 	addi	r2,r2,-13960
 3223f3c:	10800d17 	ldw	r2,52(r2)
 3223f40:	10c00044 	addi	r3,r2,1
 3223f44:	0080c9b4 	movhi	r2,806
 3223f48:	10b25e04 	addi	r2,r2,-13960
 3223f4c:	10c00d15 	stw	r3,52(r2)
         rc = IGMP_ERR;
 3223f50:	00bfffc4 	movi	r2,-1
 3223f54:	e0bffb15 	stw	r2,-20(fp)
         break;
   }
   
end:   
   /* return packet buffer back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 3223f58:	01000084 	movi	r4,2
 3223f5c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   pk_free(p);
 3223f60:	e13ffd17 	ldw	r4,-12(fp)
 3223f64:	322a2dc0 	call	322a2dc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3223f68:	01000084 	movi	r4,2
 3223f6c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      
   return rc;
 3223f70:	e0bffb17 	ldw	r2,-20(fp)
 3223f74:	e0bffe15 	stw	r2,-8(fp)
 3223f78:	e0bffe17 	ldw	r2,-8(fp)
}
 3223f7c:	e037883a 	mov	sp,fp
 3223f80:	dfc00117 	ldw	ra,4(sp)
 3223f84:	df000017 	ldw	fp,0(sp)
 3223f88:	dec00204 	addi	sp,sp,8
 3223f8c:	f800283a 	ret

03223f90 <igmp_fasttimo>:
 *
 * OUTPUT: None.
 */

void igmp_fasttimo (void)
{
 3223f90:	defffc04 	addi	sp,sp,-16
 3223f94:	dfc00315 	stw	ra,12(sp)
 3223f98:	df000215 	stw	fp,8(sp)
 3223f9c:	df000204 	addi	fp,sp,8
   struct in_multi * inm;
   NET ifp;
     
   LOCK_NET_RESOURCE (NET_RESID);
 3223fa0:	0009883a 	mov	r4,zero
 3223fa4:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   
   /*
    * Quick check to see if any work needs to be done, in order
    * to minimize the overhead of fasttimo processing.
    */
   if (!igmp_timers_are_running)
 3223fa8:	d0a8bd17 	ldw	r2,-23820(gp)
 3223fac:	1004c03a 	cmpne	r2,r2,zero
 3223fb0:	1000031e 	bne	r2,zero,3223fc0 <igmp_fasttimo+0x30>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
 3223fb4:	0009883a 	mov	r4,zero
 3223fb8:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return;
 3223fbc:	00005606 	br	3224118 <igmp_fasttimo+0x188>
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3223fc0:	0080c9b4 	movhi	r2,806
 3223fc4:	10b45b04 	addi	r2,r2,-11924
 3223fc8:	10800017 	ldw	r2,0(r2)
 3223fcc:	e0bffe15 	stw	r2,-8(fp)
 3223fd0:	00004706 	br	32240f0 <igmp_fasttimo+0x160>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 3223fd4:	e0bffe17 	ldw	r2,-8(fp)
 3223fd8:	10802c17 	ldw	r2,176(r2)
 3223fdc:	e0bfff15 	stw	r2,-4(fp)
 3223fe0:	00003d06 	br	32240d8 <igmp_fasttimo+0x148>
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
 3223fe4:	e0bfff17 	ldw	r2,-4(fp)
 3223fe8:	10800017 	ldw	r2,0(r2)
 3223fec:	1005003a 	cmpeq	r2,r2,zero
 3223ff0:	1000361e 	bne	r2,zero,32240cc <igmp_fasttimo+0x13c>
               continue;

         if (inm->inm_timer == 0)   /* timer not set */
 3223ff4:	e0bfff17 	ldw	r2,-4(fp)
 3223ff8:	10800317 	ldw	r2,12(r2)
 3223ffc:	1005003a 	cmpeq	r2,r2,zero
 3224000:	1000321e 	bne	r2,zero,32240cc <igmp_fasttimo+0x13c>
         {
            /* do nothing */
         }
         else if (--inm->inm_timer == 0)  /* timer expired */
 3224004:	e0bfff17 	ldw	r2,-4(fp)
 3224008:	10800317 	ldw	r2,12(r2)
 322400c:	10ffffc4 	addi	r3,r2,-1
 3224010:	e0bfff17 	ldw	r2,-4(fp)
 3224014:	10c00315 	stw	r3,12(r2)
 3224018:	e0bfff17 	ldw	r2,-4(fp)
 322401c:	10800317 	ldw	r2,12(r2)
 3224020:	1004c03a 	cmpne	r2,r2,zero
 3224024:	1000291e 	bne	r2,zero,32240cc <igmp_fasttimo+0x13c>
         {
            /* send membership report in appropriate format */
            if (ifp->igmpv1_rtr_present)
 3224028:	e0bffe17 	ldw	r2,-8(fp)
 322402c:	10802d03 	ldbu	r2,180(r2)
 3224030:	10803fcc 	andi	r2,r2,255
 3224034:	1005003a 	cmpeq	r2,r2,zero
 3224038:	1000041e 	bne	r2,zero,322404c <igmp_fasttimo+0xbc>
            {
               /* always true for IGMPv1, may be true for IGMPv2 */
               igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 322403c:	01000484 	movi	r4,18
 3224040:	e17fff17 	ldw	r5,-4(fp)
 3224044:	322412c0 	call	322412c <igmp_send>
 3224048:	00000306 	br	3224058 <igmp_fasttimo+0xc8>
            }
            else
            {
               igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 322404c:	01000584 	movi	r4,22
 3224050:	e17fff17 	ldw	r5,-4(fp)
 3224054:	322412c0 	call	322412c <igmp_send>

            /* for IGMPv2, indicate that we were the last to send 
             * a Report for this multicast group (relevant for 
             * IGMPv2 only).  also check to see if we should mark 
             * the IGMPv1 router as "absent". */
            if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 3224058:	e0bffe17 	ldw	r2,-8(fp)
 322405c:	10802f03 	ldbu	r2,188(r2)
 3224060:	10803fcc 	andi	r2,r2,255
 3224064:	10800098 	cmpnei	r2,r2,2
 3224068:	1000151e 	bne	r2,zero,32240c0 <igmp_fasttimo+0x130>
            {
               inm->last2send_report = IGMP_TRUE;
 322406c:	e0ffff17 	ldw	r3,-4(fp)
 3224070:	00800044 	movi	r2,1
 3224074:	18800405 	stb	r2,16(r3)
               
               if (ifp->igmpv1_rtr_present)
 3224078:	e0bffe17 	ldw	r2,-8(fp)
 322407c:	10802d03 	ldbu	r2,180(r2)
 3224080:	10803fcc 	andi	r2,r2,255
 3224084:	1005003a 	cmpeq	r2,r2,zero
 3224088:	10000d1e 	bne	r2,zero,32240c0 <igmp_fasttimo+0x130>
               {
                  if (cticks > (ifp->igmpv1_query_rcvd_time + (IGMPv1_RTR_PRESENT_TMO * TPS)))
 322408c:	e0bffe17 	ldw	r2,-8(fp)
 3224090:	10c02e17 	ldw	r3,184(r2)
 3224094:	008001b4 	movhi	r2,6
 3224098:	1086a004 	addi	r2,r2,6784
 322409c:	1887883a 	add	r3,r3,r2
 32240a0:	0080c974 	movhi	r2,805
 32240a4:	10925604 	addi	r2,r2,18776
 32240a8:	10800017 	ldw	r2,0(r2)
 32240ac:	1880042e 	bgeu	r3,r2,32240c0 <igmp_fasttimo+0x130>
                     /* we haven't heard from the IGMPv1 router for a duration
                      * greater than or equal to Version 1 Router Present Timeout 
                      * (400 seconds), and will now update the igmpv1_rtr_present 
                      * variable to reflect that.
                      */
                     ifp->igmpv1_rtr_present = IGMP_FALSE;
 32240b0:	e0bffe17 	ldw	r2,-8(fp)
 32240b4:	10002d05 	stb	zero,180(r2)
                     ifp->igmpv1_query_rcvd_time = 0;
 32240b8:	e0bffe17 	ldw	r2,-8(fp)
 32240bc:	10002e15 	stw	zero,184(r2)
                  }
               }  
            }

            /* decrement the count of running IGMP timers */
            --igmp_timers_are_running;
 32240c0:	d0a8bd17 	ldw	r2,-23820(gp)
 32240c4:	10bfffc4 	addi	r2,r2,-1
 32240c8:	d0a8bd15 	stw	r2,-23820(gp)
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 32240cc:	e0bfff17 	ldw	r2,-4(fp)
 32240d0:	10800517 	ldw	r2,20(r2)
 32240d4:	e0bfff15 	stw	r2,-4(fp)
 32240d8:	e0bfff17 	ldw	r2,-4(fp)
 32240dc:	1004c03a 	cmpne	r2,r2,zero
 32240e0:	103fc01e 	bne	r2,zero,3223fe4 <igmp_fasttimo+0x54>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 32240e4:	e0bffe17 	ldw	r2,-8(fp)
 32240e8:	10800017 	ldw	r2,0(r2)
 32240ec:	e0bffe15 	stw	r2,-8(fp)
 32240f0:	e0bffe17 	ldw	r2,-8(fp)
 32240f4:	1004c03a 	cmpne	r2,r2,zero
 32240f8:	103fb61e 	bne	r2,zero,3223fd4 <igmp_fasttimo+0x44>
      }     
   }

   /* Setup time for the next call into igmp_fasttimo ()
    * (200 ms later). */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 32240fc:	0080c974 	movhi	r2,805
 3224100:	10925604 	addi	r2,r2,18776
 3224104:	10800017 	ldw	r2,0(r2)
 3224108:	10803204 	addi	r2,r2,200
 322410c:	d0a8be15 	stw	r2,-23816(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 3224110:	0009883a 	mov	r4,zero
 3224114:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   
   return;
}
 3224118:	e037883a 	mov	sp,fp
 322411c:	dfc00117 	ldw	ra,4(sp)
 3224120:	df000017 	ldw	fp,0(sp)
 3224124:	dec00204 	addi	sp,sp,8
 3224128:	f800283a 	ret

0322412c <igmp_send>:
 *
 * OUTPUT: None.
 */

void igmp_send (u_char type, struct in_multi * inm)
{
 322412c:	deffdd04 	addi	sp,sp,-140
 3224130:	dfc02215 	stw	ra,136(sp)
 3224134:	df002115 	stw	fp,132(sp)
 3224138:	df002104 	addi	fp,sp,132
 322413c:	e17fff15 	stw	r5,-4(fp)
 3224140:	e13ffe05 	stb	r4,-8(fp)
   struct ip_moptions * imop;
   struct ip_moptions simo;
   struct ip * pip;
   int i;
   u_char * tmpp;
   u_char opts [2] = {IP_RTR_ALERT_OPT, EOL_OPT};
 3224144:	00800504 	movi	r2,20
 3224148:	e0bffd05 	stb	r2,-12(fp)
 322414c:	e03ffd45 	stb	zero,-11(fp)
   u_char reqd_len;

   /* compute length of buffer required for outgoing packet.
    * also account for the length of the IP Router Alert 
    * option, if required. */   
   reqd_len = MaxLnh + sizeof (struct ip) + sizeof (struct igmp);
 3224150:	0080c974 	movhi	r2,805
 3224154:	10922f04 	addi	r2,r2,18620
 3224158:	10800017 	ldw	r2,0(r2)
 322415c:	10800704 	addi	r2,r2,28
 3224160:	e0bfdf05 	stb	r2,-132(fp)
   if ((type == IGMPv2_LEAVE_GROUP) || 
 3224164:	e0bffe03 	ldbu	r2,-8(fp)
 3224168:	108005e0 	cmpeqi	r2,r2,23
 322416c:	1000031e 	bne	r2,zero,322417c <igmp_send+0x50>
 3224170:	e0bffe03 	ldbu	r2,-8(fp)
 3224174:	10800598 	cmpnei	r2,r2,22
 3224178:	1000031e 	bne	r2,zero,3224188 <igmp_send+0x5c>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      reqd_len += IP_RTR_ALERT_OPT_SIZE;
 322417c:	e0bfdf03 	ldbu	r2,-132(fp)
 3224180:	10800104 	addi	r2,r2,4
 3224184:	e0bfdf05 	stb	r2,-132(fp)
   }

   /* obtain a packet to send the IGMP message */
   LOCK_NET_RESOURCE (FREEQ_RESID);
 3224188:	01000084 	movi	r4,2
 322418c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   p = pk_alloc (reqd_len);
 3224190:	e13fdf03 	ldbu	r4,-132(fp)
 3224194:	3229f480 	call	3229f48 <pk_alloc>
 3224198:	e0bfe615 	stw	r2,-104(fp)
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 322419c:	01000084 	movi	r4,2
 32241a0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   
   /* log an error and return if the allocation fails */   
   if (!p)
 32241a4:	e0bfe617 	ldw	r2,-104(fp)
 32241a8:	1004c03a 	cmpne	r2,r2,zero
 32241ac:	1000081e 	bne	r2,zero,32241d0 <igmp_send+0xa4>
   {
      ++igmpstats.igmp_pkt_alloc_fail;
 32241b0:	0080c9b4 	movhi	r2,806
 32241b4:	10b25e04 	addi	r2,r2,-13960
 32241b8:	10800c17 	ldw	r2,48(r2)
 32241bc:	10c00044 	addi	r3,r2,1
 32241c0:	0080c9b4 	movhi	r2,806
 32241c4:	10b25e04 	addi	r2,r2,-13960
 32241c8:	10c00c15 	stw	r3,48(r2)
      return;
 32241cc:	00007c06 	br	32243c0 <igmp_send+0x294>
   }

   /* Need to fill in the source and destination ip addresses */
   pip = (struct ip *) p->nb_prot;
 32241d0:	e0bfe617 	ldw	r2,-104(fp)
 32241d4:	10800317 	ldw	r2,12(r2)
 32241d8:	e0bfe315 	stw	r2,-116(fp)
   pip->ip_src = inm->inm_netp->n_ipaddr;
 32241dc:	e0bfff17 	ldw	r2,-4(fp)
 32241e0:	10800117 	ldw	r2,4(r2)
 32241e4:	10c00a17 	ldw	r3,40(r2)
 32241e8:	e0bfe317 	ldw	r2,-116(fp)
 32241ec:	10c00315 	stw	r3,12(r2)
   /* Leave Group messages are sent to the all-routers multicast group */
   if (type == IGMPv2_LEAVE_GROUP)
 32241f0:	e0bffe03 	ldbu	r2,-8(fp)
 32241f4:	108005d8 	cmpnei	r2,r2,23
 32241f8:	1000041e 	bne	r2,zero,322420c <igmp_send+0xe0>
   {
      /* igmp_all_rtrs_group is already in network byte order */
      pip->ip_dest = igmp_all_rtrs_group;
 32241fc:	d0e8c017 	ldw	r3,-23808(gp)
 3224200:	e0bfe317 	ldw	r2,-116(fp)
 3224204:	10c00415 	stw	r3,16(r2)
 3224208:	00000406 	br	322421c <igmp_send+0xf0>
   }
   else
      pip->ip_dest = inm->inm_addr;
 322420c:	e0bfff17 	ldw	r2,-4(fp)
 3224210:	10c00017 	ldw	r3,0(r2)
 3224214:	e0bfe317 	ldw	r2,-116(fp)
 3224218:	10c00415 	stw	r3,16(r2)
   
   p->fhost = pip->ip_dest;
 322421c:	e0bfe317 	ldw	r2,-116(fp)
 3224220:	10c00417 	ldw	r3,16(r2)
 3224224:	e0bfe617 	ldw	r2,-104(fp)
 3224228:	10c00715 	stw	r3,28(r2)

   tmpp = (((u_char *) p->nb_prot) + sizeof (struct ip));
 322422c:	e0bfe617 	ldw	r2,-104(fp)
 3224230:	10800317 	ldw	r2,12(r2)
 3224234:	10800504 	addi	r2,r2,20
 3224238:	e0bfe115 	stw	r2,-124(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 322423c:	e0bffe03 	ldbu	r2,-8(fp)
 3224240:	108005e0 	cmpeqi	r2,r2,23
 3224244:	1000031e 	bne	r2,zero,3224254 <igmp_send+0x128>
 3224248:	e0bffe03 	ldbu	r2,-8(fp)
 322424c:	10800598 	cmpnei	r2,r2,22
 3224250:	1000061e 	bne	r2,zero,322426c <igmp_send+0x140>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      /* provide space for ip_write2 () to write option-related data */
      tmpp += IP_RTR_ALERT_OPT_SIZE;
 3224254:	e0bfe117 	ldw	r2,-124(fp)
 3224258:	10800104 	addi	r2,r2,4
 322425c:	e0bfe115 	stw	r2,-124(fp)
      optp = &(opts [0]); /* one option (IP Router Alert) */
 3224260:	e0bffd04 	addi	r2,fp,-12
 3224264:	e0bfe015 	stw	r2,-128(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 3224268:	00000306 	br	3224278 <igmp_send+0x14c>
      tmpp += IP_RTR_ALERT_OPT_SIZE;
      optp = &(opts [0]); /* one option (IP Router Alert) */
   }
   /* outgoing packet does not require any options */
   else 
      optp = &(opts [1]);
 322426c:	e0bffd04 	addi	r2,fp,-12
 3224270:	10800044 	addi	r2,r2,1
 3224274:	e0bfe015 	stw	r2,-128(fp)
   /* point to the start of the IGMP header */
   igmp = (struct igmp *) tmpp;
 3224278:	e0bfe117 	ldw	r2,-124(fp)
 322427c:	e0bfe515 	stw	r2,-108(fp)
   
   igmp->igmp_type = type;
 3224280:	e0ffe517 	ldw	r3,-108(fp)
 3224284:	e0bffe03 	ldbu	r2,-8(fp)
 3224288:	18800005 	stb	r2,0(r3)
   igmp->igmp_code = 0;
 322428c:	e0bfe517 	ldw	r2,-108(fp)
 3224290:	10000045 	stb	zero,1(r2)
   
   /* all messages (Report or Leave) have Group Address field 
    * set to the group being reported or left */
   igmp->igmp_group = inm->inm_addr;
 3224294:	e0bfff17 	ldw	r2,-4(fp)
 3224298:	10c00017 	ldw	r3,0(r2)
 322429c:	e0bfe517 	ldw	r2,-108(fp)
 32242a0:	10c00115 	stw	r3,4(r2)
   igmp->igmp_cksum = 0;
 32242a4:	e0bfe517 	ldw	r2,-108(fp)
 32242a8:	1000008d 	sth	zero,2(r2)
   igmp->igmp_cksum = ~cksum((void*)igmp, IGMP_MINLEN>>1);
 32242ac:	e13fe517 	ldw	r4,-108(fp)
 32242b0:	01400104 	movi	r5,4
 32242b4:	32259f80 	call	32259f8 <cksum>
 32242b8:	0084303a 	nor	r2,zero,r2
 32242bc:	1007883a 	mov	r3,r2
 32242c0:	e0bfe517 	ldw	r2,-108(fp)
 32242c4:	10c0008d 	sth	r3,2(r2)

   imop = &simo;
 32242c8:	e0bfe704 	addi	r2,fp,-100
 32242cc:	e0bfe415 	stw	r2,-112(fp)
   MEMSET(imop, 0, sizeof(simo));
 32242d0:	e0bfe417 	ldw	r2,-112(fp)
 32242d4:	1009883a 	mov	r4,r2
 32242d8:	01801604 	movi	r6,88
 32242dc:	000b883a 	mov	r5,zero
 32242e0:	320694c0 	call	320694c <memset>
   imop->imo_multicast_netp = inm->inm_netp;
 32242e4:	e0bfff17 	ldw	r2,-4(fp)
 32242e8:	10c00117 	ldw	r3,4(r2)
 32242ec:	e0bfe417 	ldw	r2,-112(fp)
 32242f0:	10c00015 	stw	r3,0(r2)
   imop->imo_multicast_ttl = 1;
 32242f4:	e0ffe417 	ldw	r3,-112(fp)
 32242f8:	00800044 	movi	r2,1
 32242fc:	18800105 	stb	r2,4(r3)
   /* we do not want our own reports to be looped back */
   imop->imo_multicast_loop = 0;
 3224300:	e0bfe417 	ldw	r2,-112(fp)
 3224304:	10000145 	stb	zero,5(r2)

   /* set nb_prot to point to the beginning of the IGMP data,
    * and nb_plen to the length of the IGMP data, and attach
    * the multicast options structure to the outgoing packet */
   p->nb_prot = (char *) tmpp;
 3224308:	e0ffe117 	ldw	r3,-124(fp)
 322430c:	e0bfe617 	ldw	r2,-104(fp)
 3224310:	10c00315 	stw	r3,12(r2)
   p->nb_plen = sizeof(struct igmp);
 3224314:	e0ffe617 	ldw	r3,-104(fp)
 3224318:	00800204 	movi	r2,8
 322431c:	18800415 	stw	r2,16(r3)
   p->imo = imop;
 3224320:	e0ffe617 	ldw	r3,-104(fp)
 3224324:	e0bfe417 	ldw	r2,-112(fp)
 3224328:	18800b15 	stw	r2,44(r3)
   
   i = ip_write2 (IGMP_PROT, p, optp);
 322432c:	01000084 	movi	r4,2
 3224330:	e17fe617 	ldw	r5,-104(fp)
 3224334:	e1bfe017 	ldw	r6,-128(fp)
 3224338:	323f2580 	call	323f258 <ip_write2>
 322433c:	e0bfe215 	stw	r2,-120(fp)

   if (type == IGMPv2_LEAVE_GROUP)
 3224340:	e0bffe03 	ldbu	r2,-8(fp)
 3224344:	108005d8 	cmpnei	r2,r2,23
 3224348:	1000081e 	bne	r2,zero,322436c <igmp_send+0x240>
      ++igmpstats.igmpv2mode_v2_leave_msgs_sent;
 322434c:	0080c9b4 	movhi	r2,806
 3224350:	10b25e04 	addi	r2,r2,-13960
 3224354:	10801717 	ldw	r2,92(r2)
 3224358:	10c00044 	addi	r3,r2,1
 322435c:	0080c9b4 	movhi	r2,806
 3224360:	10b25e04 	addi	r2,r2,-13960
 3224364:	10c01715 	stw	r3,92(r2)
 3224368:	00001506 	br	32243c0 <igmp_send+0x294>
   else if (type == IGMPv2_MEMBERSHIP_REPORT)
 322436c:	e0bffe03 	ldbu	r2,-8(fp)
 3224370:	10800598 	cmpnei	r2,r2,22
 3224374:	1000081e 	bne	r2,zero,3224398 <igmp_send+0x26c>
      ++igmpstats.igmpv2mode_v2_reports_sent;
 3224378:	0080c9b4 	movhi	r2,806
 322437c:	10b25e04 	addi	r2,r2,-13960
 3224380:	10801817 	ldw	r2,96(r2)
 3224384:	10c00044 	addi	r3,r2,1
 3224388:	0080c9b4 	movhi	r2,806
 322438c:	10b25e04 	addi	r2,r2,-13960
 3224390:	10c01815 	stw	r3,96(r2)
 3224394:	00000a06 	br	32243c0 <igmp_send+0x294>
   else if (type == IGMP_HOST_MEMBERSHIP_REPORT)
 3224398:	e0bffe03 	ldbu	r2,-8(fp)
 322439c:	10800498 	cmpnei	r2,r2,18
 32243a0:	1000071e 	bne	r2,zero,32243c0 <igmp_send+0x294>
      ++igmpstats.igmp_v1_reports_sent;
 32243a4:	0080c9b4 	movhi	r2,806
 32243a8:	10b25e04 	addi	r2,r2,-13960
 32243ac:	10801617 	ldw	r2,88(r2)
 32243b0:	10c00044 	addi	r3,r2,1
 32243b4:	0080c9b4 	movhi	r2,806
 32243b8:	10b25e04 	addi	r2,r2,-13960
 32243bc:	10c01615 	stw	r3,88(r2)
}
 32243c0:	e037883a 	mov	sp,fp
 32243c4:	dfc00117 	ldw	ra,4(sp)
 32243c8:	df000017 	ldw	fp,0(sp)
 32243cc:	dec00204 	addi	sp,sp,8
 32243d0:	f800283a 	ret

032243d4 <igmp_joingroup>:
 *
 * OUTPUT: None.
 */
 
void igmp_joingroup(struct in_multi * inm)
{
 32243d4:	defffc04 	addi	sp,sp,-16
 32243d8:	dfc00315 	stw	ra,12(sp)
 32243dc:	df000215 	stw	fp,8(sp)
 32243e0:	df000204 	addi	fp,sp,8
 32243e4:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   /* extract the network interface to which this multicast
    * address is "attached" */
   ifp = inm->inm_netp;
 32243e8:	e0bfff17 	ldw	r2,-4(fp)
 32243ec:	10800117 	ldw	r2,4(r2)
 32243f0:	e0bffe15 	stw	r2,-8(fp)

   if (inm->inm_addr == igmp_all_hosts_group)
 32243f4:	e0bfff17 	ldw	r2,-4(fp)
 32243f8:	10c00017 	ldw	r3,0(r2)
 32243fc:	d0a8bf17 	ldw	r2,-23812(gp)
 3224400:	1880031e 	bne	r3,r2,3224410 <igmp_joingroup+0x3c>
   {
      inm->inm_timer = 0;
 3224404:	e0bfff17 	ldw	r2,-4(fp)
 3224408:	10000315 	stw	zero,12(r2)
 322440c:	00008706 	br	322462c <igmp_joingroup+0x258>
   }
   else 
   {
      /* send unsolicited membership report in appropriate format */
      if (ifp->igmpv1_rtr_present)
 3224410:	e0bffe17 	ldw	r2,-8(fp)
 3224414:	10802d03 	ldbu	r2,180(r2)
 3224418:	10803fcc 	andi	r2,r2,255
 322441c:	1005003a 	cmpeq	r2,r2,zero
 3224420:	10003c1e 	bne	r2,zero,3224514 <igmp_joingroup+0x140>
      {
         /* always true for IGMPv1, may be true for IGMPv2 */
         igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 3224424:	01000484 	movi	r4,18
 3224428:	e17fff17 	ldw	r5,-4(fp)
 322442c:	322412c0 	call	322412c <igmp_send>
         /* set a delay timer (with a duration of 
          * IGMP_MAX_HOST_REPORT_DELAY) for a second unsolicited report */
         inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 3224430:	0080c9b4 	movhi	r2,806
 3224434:	10b46004 	addi	r2,r2,-11904
 3224438:	11000217 	ldw	r4,8(r2)
 322443c:	0080c9b4 	movhi	r2,806
 3224440:	10b25a04 	addi	r2,r2,-13976
 3224444:	10800017 	ldw	r2,0(r2)
 3224448:	10800a17 	ldw	r2,40(r2)
 322444c:	1004d63a 	srli	r2,r2,24
 3224450:	10c03fcc 	andi	r3,r2,255
 3224454:	0080c9b4 	movhi	r2,806
 3224458:	10b25a04 	addi	r2,r2,-13976
 322445c:	10800017 	ldw	r2,0(r2)
 3224460:	10800a17 	ldw	r2,40(r2)
 3224464:	1004d23a 	srli	r2,r2,8
 3224468:	10bfc00c 	andi	r2,r2,65280
 322446c:	1886b03a 	or	r3,r3,r2
 3224470:	0080c9b4 	movhi	r2,806
 3224474:	10b25a04 	addi	r2,r2,-13976
 3224478:	10800017 	ldw	r2,0(r2)
 322447c:	10800a17 	ldw	r2,40(r2)
 3224480:	10bfc00c 	andi	r2,r2,65280
 3224484:	1004923a 	slli	r2,r2,8
 3224488:	1886b03a 	or	r3,r3,r2
 322448c:	0080c9b4 	movhi	r2,806
 3224490:	10b25a04 	addi	r2,r2,-13976
 3224494:	10800017 	ldw	r2,0(r2)
 3224498:	10800a17 	ldw	r2,40(r2)
 322449c:	10803fcc 	andi	r2,r2,255
 32244a0:	1004963a 	slli	r2,r2,24
 32244a4:	1884b03a 	or	r2,r3,r2
 32244a8:	2089883a 	add	r4,r4,r2
 32244ac:	e0bfff17 	ldw	r2,-4(fp)
 32244b0:	10800017 	ldw	r2,0(r2)
 32244b4:	1004d63a 	srli	r2,r2,24
 32244b8:	10c03fcc 	andi	r3,r2,255
 32244bc:	e0bfff17 	ldw	r2,-4(fp)
 32244c0:	10800017 	ldw	r2,0(r2)
 32244c4:	1004d23a 	srli	r2,r2,8
 32244c8:	10bfc00c 	andi	r2,r2,65280
 32244cc:	1886b03a 	or	r3,r3,r2
 32244d0:	e0bfff17 	ldw	r2,-4(fp)
 32244d4:	10800017 	ldw	r2,0(r2)
 32244d8:	10bfc00c 	andi	r2,r2,65280
 32244dc:	1004923a 	slli	r2,r2,8
 32244e0:	1886b03a 	or	r3,r3,r2
 32244e4:	e0bfff17 	ldw	r2,-4(fp)
 32244e8:	10800017 	ldw	r2,0(r2)
 32244ec:	10803fcc 	andi	r2,r2,255
 32244f0:	1004963a 	slli	r2,r2,24
 32244f4:	1884b03a 	or	r2,r3,r2
 32244f8:	2089883a 	add	r4,r4,r2
 32244fc:	01400c84 	movi	r5,50
 3224500:	32044c40 	call	32044c4 <__umodsi3>
 3224504:	10c00044 	addi	r3,r2,1
 3224508:	e0bfff17 	ldw	r2,-4(fp)
 322450c:	10c00315 	stw	r3,12(r2)
 3224510:	00003b06 	br	3224600 <igmp_joingroup+0x22c>
      }
      else
      {
         igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 3224514:	01000584 	movi	r4,22
 3224518:	e17fff17 	ldw	r5,-4(fp)
 322451c:	322412c0 	call	322412c <igmp_send>
         /* the delay time duration is the Unsolicited Report Interval */
         inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY ((UNSOLIC_RPT_INTERVAL * PR_FASTHZ), inm->inm_addr);
 3224520:	0080c9b4 	movhi	r2,806
 3224524:	10b46004 	addi	r2,r2,-11904
 3224528:	11000217 	ldw	r4,8(r2)
 322452c:	0080c9b4 	movhi	r2,806
 3224530:	10b25a04 	addi	r2,r2,-13976
 3224534:	10800017 	ldw	r2,0(r2)
 3224538:	10800a17 	ldw	r2,40(r2)
 322453c:	1004d63a 	srli	r2,r2,24
 3224540:	10c03fcc 	andi	r3,r2,255
 3224544:	0080c9b4 	movhi	r2,806
 3224548:	10b25a04 	addi	r2,r2,-13976
 322454c:	10800017 	ldw	r2,0(r2)
 3224550:	10800a17 	ldw	r2,40(r2)
 3224554:	1004d23a 	srli	r2,r2,8
 3224558:	10bfc00c 	andi	r2,r2,65280
 322455c:	1886b03a 	or	r3,r3,r2
 3224560:	0080c9b4 	movhi	r2,806
 3224564:	10b25a04 	addi	r2,r2,-13976
 3224568:	10800017 	ldw	r2,0(r2)
 322456c:	10800a17 	ldw	r2,40(r2)
 3224570:	10bfc00c 	andi	r2,r2,65280
 3224574:	1004923a 	slli	r2,r2,8
 3224578:	1886b03a 	or	r3,r3,r2
 322457c:	0080c9b4 	movhi	r2,806
 3224580:	10b25a04 	addi	r2,r2,-13976
 3224584:	10800017 	ldw	r2,0(r2)
 3224588:	10800a17 	ldw	r2,40(r2)
 322458c:	10803fcc 	andi	r2,r2,255
 3224590:	1004963a 	slli	r2,r2,24
 3224594:	1884b03a 	or	r2,r3,r2
 3224598:	2089883a 	add	r4,r4,r2
 322459c:	e0bfff17 	ldw	r2,-4(fp)
 32245a0:	10800017 	ldw	r2,0(r2)
 32245a4:	1004d63a 	srli	r2,r2,24
 32245a8:	10c03fcc 	andi	r3,r2,255
 32245ac:	e0bfff17 	ldw	r2,-4(fp)
 32245b0:	10800017 	ldw	r2,0(r2)
 32245b4:	1004d23a 	srli	r2,r2,8
 32245b8:	10bfc00c 	andi	r2,r2,65280
 32245bc:	1886b03a 	or	r3,r3,r2
 32245c0:	e0bfff17 	ldw	r2,-4(fp)
 32245c4:	10800017 	ldw	r2,0(r2)
 32245c8:	10bfc00c 	andi	r2,r2,65280
 32245cc:	1004923a 	slli	r2,r2,8
 32245d0:	1886b03a 	or	r3,r3,r2
 32245d4:	e0bfff17 	ldw	r2,-4(fp)
 32245d8:	10800017 	ldw	r2,0(r2)
 32245dc:	10803fcc 	andi	r2,r2,255
 32245e0:	1004963a 	slli	r2,r2,24
 32245e4:	1884b03a 	or	r2,r3,r2
 32245e8:	2089883a 	add	r4,r4,r2
 32245ec:	01400c84 	movi	r5,50
 32245f0:	32044c40 	call	32044c4 <__umodsi3>
 32245f4:	10c00044 	addi	r3,r2,1
 32245f8:	e0bfff17 	ldw	r2,-4(fp)
 32245fc:	10c00315 	stw	r3,12(r2)
      }
      
      /* for IGMPv2, indicate that we were the last to send 
       * a Report for this multicast group (relevant for 
       * IGMPv2 only). */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 3224600:	e0bffe17 	ldw	r2,-8(fp)
 3224604:	10802f03 	ldbu	r2,188(r2)
 3224608:	10803fcc 	andi	r2,r2,255
 322460c:	10800098 	cmpnei	r2,r2,2
 3224610:	1000031e 	bne	r2,zero,3224620 <igmp_joingroup+0x24c>
      {
         inm->last2send_report = IGMP_TRUE;
 3224614:	e0ffff17 	ldw	r3,-4(fp)
 3224618:	00800044 	movi	r2,1
 322461c:	18800405 	stb	r2,16(r3)
      }

      ++igmp_timers_are_running;
 3224620:	d0a8bd17 	ldw	r2,-23820(gp)
 3224624:	10800044 	addi	r2,r2,1
 3224628:	d0a8bd15 	stw	r2,-23820(gp)
   }
   
   return;
}     
 322462c:	e037883a 	mov	sp,fp
 3224630:	dfc00117 	ldw	ra,4(sp)
 3224634:	df000017 	ldw	fp,0(sp)
 3224638:	dec00204 	addi	sp,sp,8
 322463c:	f800283a 	ret

03224640 <igmp_leavegroup>:
 *
 * OUTPUT: None.
 */

void igmp_leavegroup (struct in_multi * inm)
{
 3224640:	defffc04 	addi	sp,sp,-16
 3224644:	dfc00315 	stw	ra,12(sp)
 3224648:	df000215 	stw	fp,8(sp)
 322464c:	df000204 	addi	fp,sp,8
 3224650:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = inm->inm_netp;
 3224654:	e0bfff17 	ldw	r2,-4(fp)
 3224658:	10800117 	ldw	r2,4(r2)
 322465c:	e0bffe15 	stw	r2,-8(fp)

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 3224660:	e0bffe17 	ldw	r2,-8(fp)
 3224664:	10802f03 	ldbu	r2,188(r2)
 3224668:	10803fcc 	andi	r2,r2,255
 322466c:	10800098 	cmpnei	r2,r2,2
 3224670:	10000d1e 	bne	r2,zero,32246a8 <igmp_leavegroup+0x68>
 3224674:	e0bffe17 	ldw	r2,-8(fp)
 3224678:	10802d03 	ldbu	r2,180(r2)
 322467c:	10803fcc 	andi	r2,r2,255
 3224680:	1004c03a 	cmpne	r2,r2,zero
 3224684:	1000081e 	bne	r2,zero,32246a8 <igmp_leavegroup+0x68>
       !ifp->igmpv1_rtr_present)
   {
      if (inm->last2send_report == IGMP_TRUE)
 3224688:	e0bfff17 	ldw	r2,-4(fp)
 322468c:	10800403 	ldbu	r2,16(r2)
 3224690:	10803fcc 	andi	r2,r2,255
 3224694:	10800058 	cmpnei	r2,r2,1
 3224698:	1000031e 	bne	r2,zero,32246a8 <igmp_leavegroup+0x68>
         igmp_send (IGMPv2_LEAVE_GROUP, inm);
 322469c:	010005c4 	movi	r4,23
 32246a0:	e17fff17 	ldw	r5,-4(fp)
 32246a4:	322412c0 	call	322412c <igmp_send>
   }
   
   return;
}
 32246a8:	e037883a 	mov	sp,fp
 32246ac:	dfc00117 	ldw	ra,4(sp)
 32246b0:	df000017 	ldw	fp,0(sp)
 32246b4:	dec00204 	addi	sp,sp,8
 32246b8:	f800283a 	ret

032246bc <igmp_validate>:
 *         validation fails; otherwise, it returns
 *         IGMP_OK.
 */

int igmp_validate (PACKET p)
{
 32246bc:	defff504 	addi	sp,sp,-44
 32246c0:	dfc00a15 	stw	ra,40(sp)
 32246c4:	df000915 	stw	fp,36(sp)
 32246c8:	df000904 	addi	fp,sp,36
 32246cc:	e13ffe15 	stw	r4,-8(fp)
   u_short xsum;  
   u_char type;
   ip_addr mcgrp_addr;
   u_char resp_time;

   pip = ip_head (p);
 32246d0:	e0bffe17 	ldw	r2,-8(fp)
 32246d4:	10800317 	ldw	r2,12(r2)
 32246d8:	e0bffd15 	stw	r2,-12(fp)

   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */
   igmplen = p->nb_plen - ip_hlen (pip);
 32246dc:	e0bffe17 	ldw	r2,-8(fp)
 32246e0:	10c00417 	ldw	r3,16(r2)
 32246e4:	e0bffd17 	ldw	r2,-12(fp)
 32246e8:	10800003 	ldbu	r2,0(r2)
 32246ec:	10803fcc 	andi	r2,r2,255
 32246f0:	108003cc 	andi	r2,r2,15
 32246f4:	1085883a 	add	r2,r2,r2
 32246f8:	1085883a 	add	r2,r2,r2
 32246fc:	1885c83a 	sub	r2,r3,r2
 3224700:	e0bffc15 	stw	r2,-16(fp)

   /* validate length (IGMP_MINLEN is 8 bytes) */
   if (igmplen != IGMP_MINLEN) 
 3224704:	e0bffc17 	ldw	r2,-16(fp)
 3224708:	10800220 	cmpeqi	r2,r2,8
 322470c:	10000a1e 	bne	r2,zero,3224738 <igmp_validate+0x7c>
   {
      ++igmpstats.igmp_badlen_rcvd;
 3224710:	0080c9b4 	movhi	r2,806
 3224714:	10b25e04 	addi	r2,r2,-13960
 3224718:	10800a17 	ldw	r2,40(r2)
 322471c:	10c00044 	addi	r3,r2,1
 3224720:	0080c9b4 	movhi	r2,806
 3224724:	10b25e04 	addi	r2,r2,-13960
 3224728:	10c00a15 	stw	r3,40(r2)
      return ENP_BAD_HEADER;
 322472c:	00bff804 	movi	r2,-32
 3224730:	e0bfff15 	stw	r2,-4(fp)
 3224734:	0000b206 	br	3224a00 <igmp_validate+0x344>
   }

   /* validate checksum */
   igmp = (struct igmp *) (ip_data (pip));
 3224738:	e0bffd17 	ldw	r2,-12(fp)
 322473c:	10800003 	ldbu	r2,0(r2)
 3224740:	10803fcc 	andi	r2,r2,255
 3224744:	108003cc 	andi	r2,r2,15
 3224748:	1085883a 	add	r2,r2,r2
 322474c:	1085883a 	add	r2,r2,r2
 3224750:	1007883a 	mov	r3,r2
 3224754:	e0bffd17 	ldw	r2,-12(fp)
 3224758:	1885883a 	add	r2,r3,r2
 322475c:	e0bffb15 	stw	r2,-20(fp)
   osum = igmp->igmp_cksum;
 3224760:	e0bffb17 	ldw	r2,-20(fp)
 3224764:	1080008b 	ldhu	r2,2(r2)
 3224768:	e0bffa0d 	sth	r2,-24(fp)
   igmp->igmp_cksum = 0;
 322476c:	e0bffb17 	ldw	r2,-20(fp)
 3224770:	1000008d 	sth	zero,2(r2)
   xsum = ~cksum(igmp, igmplen>>1);
 3224774:	e0bffc17 	ldw	r2,-16(fp)
 3224778:	1005d07a 	srai	r2,r2,1
 322477c:	100b883a 	mov	r5,r2
 3224780:	e13ffb17 	ldw	r4,-20(fp)
 3224784:	32259f80 	call	32259f8 <cksum>
 3224788:	0084303a 	nor	r2,zero,r2
 322478c:	e0bff98d 	sth	r2,-26(fp)
   if (xsum != osum)
 3224790:	e0fff98b 	ldhu	r3,-26(fp)
 3224794:	e0bffa0b 	ldhu	r2,-24(fp)
 3224798:	18800d26 	beq	r3,r2,32247d0 <igmp_validate+0x114>
   {
      igmp->igmp_cksum = osum;
 322479c:	e0fffb17 	ldw	r3,-20(fp)
 32247a0:	e0bffa0b 	ldhu	r2,-24(fp)
 32247a4:	1880008d 	sth	r2,2(r3)
      ++igmpstats.igmp_badsum_rcvd;
 32247a8:	0080c9b4 	movhi	r2,806
 32247ac:	10b25e04 	addi	r2,r2,-13960
 32247b0:	10800b17 	ldw	r2,44(r2)
 32247b4:	10c00044 	addi	r3,r2,1
 32247b8:	0080c9b4 	movhi	r2,806
 32247bc:	10b25e04 	addi	r2,r2,-13960
 32247c0:	10c00b15 	stw	r3,44(r2)
      return ENP_BAD_HEADER;
 32247c4:	00bff804 	movi	r2,-32
 32247c8:	e0bfff15 	stw	r2,-4(fp)
 32247cc:	00008c06 	br	3224a00 <igmp_validate+0x344>
   }
   
   /* extract the IGMP packet type, Group Address, and Max Response Time 
    * (unused for IGMPv1) fields from received packet */
   type = igmp->igmp_type;
 32247d0:	e0bffb17 	ldw	r2,-20(fp)
 32247d4:	10800003 	ldbu	r2,0(r2)
 32247d8:	e0bff905 	stb	r2,-28(fp)
   mcgrp_addr = ntohl(igmp->igmp_group); 
 32247dc:	e0bffb17 	ldw	r2,-20(fp)
 32247e0:	10800117 	ldw	r2,4(r2)
 32247e4:	1004d63a 	srli	r2,r2,24
 32247e8:	10c03fcc 	andi	r3,r2,255
 32247ec:	e0bffb17 	ldw	r2,-20(fp)
 32247f0:	10800117 	ldw	r2,4(r2)
 32247f4:	1004d23a 	srli	r2,r2,8
 32247f8:	10bfc00c 	andi	r2,r2,65280
 32247fc:	1886b03a 	or	r3,r3,r2
 3224800:	e0bffb17 	ldw	r2,-20(fp)
 3224804:	10800117 	ldw	r2,4(r2)
 3224808:	10bfc00c 	andi	r2,r2,65280
 322480c:	1004923a 	slli	r2,r2,8
 3224810:	1886b03a 	or	r3,r3,r2
 3224814:	e0bffb17 	ldw	r2,-20(fp)
 3224818:	10800117 	ldw	r2,4(r2)
 322481c:	10803fcc 	andi	r2,r2,255
 3224820:	1004963a 	slli	r2,r2,24
 3224824:	1884b03a 	or	r2,r3,r2
 3224828:	e0bff815 	stw	r2,-32(fp)
   resp_time = igmp->igmp_code;
 322482c:	e0bffb17 	ldw	r2,-20(fp)
 3224830:	10800043 	ldbu	r2,1(r2)
 3224834:	e0bff705 	stb	r2,-36(fp)
      
   if (type == IGMP_HOST_MEMBERSHIP_QUERY)
 3224838:	e0bff903 	ldbu	r2,-28(fp)
 322483c:	10800458 	cmpnei	r2,r2,17
 3224840:	1000381e 	bne	r2,zero,3224924 <igmp_validate+0x268>
   {
      if ((resp_time == 0) || /* IGMPv1 Query */
 3224844:	e0bff703 	ldbu	r2,-36(fp)
 3224848:	1005003a 	cmpeq	r2,r2,zero
 322484c:	1000061e 	bne	r2,zero,3224868 <igmp_validate+0x1ac>
 3224850:	e0bff703 	ldbu	r2,-36(fp)
 3224854:	1005003a 	cmpeq	r2,r2,zero
 3224858:	1000111e 	bne	r2,zero,32248a0 <igmp_validate+0x1e4>
 322485c:	e0bff817 	ldw	r2,-32(fp)
 3224860:	1004c03a 	cmpne	r2,r2,zero
 3224864:	10000e1e 	bne	r2,zero,32248a0 <igmp_validate+0x1e4>
          ((resp_time > 0) && (mcgrp_addr == 0))) /* IGMPv2 General Query */     
      {
         /* if this is a IGMPv1 Host Membership Query or a IGMPv2 
          * General Query, it must be addressed to the all-hosts 
          * group */
         if (pip->ip_dest != igmp_all_hosts_group) 
 3224868:	e0bffd17 	ldw	r2,-12(fp)
 322486c:	10c00417 	ldw	r3,16(r2)
 3224870:	d0a8bf17 	ldw	r2,-23812(gp)
 3224874:	18800a26 	beq	r3,r2,32248a0 <igmp_validate+0x1e4>
         {
            ++igmpstats.igmp_bad_queries_rcvd;
 3224878:	0080c9b4 	movhi	r2,806
 322487c:	10b25e04 	addi	r2,r2,-13960
 3224880:	10800e17 	ldw	r2,56(r2)
 3224884:	10c00044 	addi	r3,r2,1
 3224888:	0080c9b4 	movhi	r2,806
 322488c:	10b25e04 	addi	r2,r2,-13960
 3224890:	10c00e15 	stw	r3,56(r2)
            return ENP_BAD_HEADER;
 3224894:	00bff804 	movi	r2,-32
 3224898:	e0bfff15 	stw	r2,-4(fp)
 322489c:	00005806 	br	3224a00 <igmp_validate+0x344>
         }     
      }
      
      if ((resp_time > 0) && (mcgrp_addr != 0))
 32248a0:	e0bff703 	ldbu	r2,-36(fp)
 32248a4:	1005003a 	cmpeq	r2,r2,zero
 32248a8:	10001e1e 	bne	r2,zero,3224924 <igmp_validate+0x268>
 32248ac:	e0bff817 	ldw	r2,-32(fp)
 32248b0:	1005003a 	cmpeq	r2,r2,zero
 32248b4:	10001b1e 	bne	r2,zero,3224924 <igmp_validate+0x268>
      {
         /* this is a IGMPv2 Group-Specific Query. */
         if (p->net->igmp_oper_mode == IGMP_MODE_V1)
 32248b8:	e0bffe17 	ldw	r2,-8(fp)
 32248bc:	10800617 	ldw	r2,24(r2)
 32248c0:	10802f03 	ldbu	r2,188(r2)
 32248c4:	10803fcc 	andi	r2,r2,255
 32248c8:	10800058 	cmpnei	r2,r2,1
 32248cc:	1000031e 	bne	r2,zero,32248dc <igmp_validate+0x220>
         {
            /* IGMPv1 code does not understand a IGMPv2 Group-
             * Specific Query */
            return ENP_BAD_HEADER; 
 32248d0:	00bff804 	movi	r2,-32
 32248d4:	e0bfff15 	stw	r2,-4(fp)
 32248d8:	00004906 	br	3224a00 <igmp_validate+0x344>
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 32248dc:	e0bff817 	ldw	r2,-32(fp)
 32248e0:	10fc002c 	andhi	r3,r2,61440
 32248e4:	00b80034 	movhi	r2,57344
 32248e8:	1880041e 	bne	r3,r2,32248fc <igmp_validate+0x240>
 32248ec:	e0bffb17 	ldw	r2,-20(fp)
 32248f0:	10c00117 	ldw	r3,4(r2)
 32248f4:	d0a8bf17 	ldw	r2,-23812(gp)
 32248f8:	18800a1e 	bne	r3,r2,3224924 <igmp_validate+0x268>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
         {
            ++igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd;
 32248fc:	0080c9b4 	movhi	r2,806
 3224900:	10b25e04 	addi	r2,r2,-13960
 3224904:	10801117 	ldw	r2,68(r2)
 3224908:	10c00044 	addi	r3,r2,1
 322490c:	0080c9b4 	movhi	r2,806
 3224910:	10b25e04 	addi	r2,r2,-13960
 3224914:	10c01115 	stw	r3,68(r2)
            /* caller will free received packet */
            return ENP_BAD_HEADER;
 3224918:	00bff804 	movi	r2,-32
 322491c:	e0bfff15 	stw	r2,-4(fp)
 3224920:	00003706 	br	3224a00 <igmp_validate+0x344>
   
   /* check to ensure that a received IGMPv1 or v2 Report has the 
    * same IP host group address in its IP destination field and 
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
 3224924:	e0bff903 	ldbu	r2,-28(fp)
 3224928:	108004a0 	cmpeqi	r2,r2,18
 322492c:	1000031e 	bne	r2,zero,322493c <igmp_validate+0x280>
 3224930:	e0bff903 	ldbu	r2,-28(fp)
 3224934:	10800598 	cmpnei	r2,r2,22
 3224938:	1000131e 	bne	r2,zero,3224988 <igmp_validate+0x2cc>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 322493c:	e0bffb17 	ldw	r2,-20(fp)
 3224940:	10c00117 	ldw	r3,4(r2)
 3224944:	e0bffd17 	ldw	r2,-12(fp)
 3224948:	10800417 	ldw	r2,16(r2)
 322494c:	1880041e 	bne	r3,r2,3224960 <igmp_validate+0x2a4>
 3224950:	e0bff817 	ldw	r2,-32(fp)
 3224954:	10fc002c 	andhi	r3,r2,61440
 3224958:	00b80034 	movhi	r2,57344
 322495c:	18800a26 	beq	r3,r2,3224988 <igmp_validate+0x2cc>
          (!IN_MULTICAST(mcgrp_addr)))
      {
         ++igmpstats.igmp_bad_reports_rcvd;
 3224960:	0080c9b4 	movhi	r2,806
 3224964:	10b25e04 	addi	r2,r2,-13960
 3224968:	10800f17 	ldw	r2,60(r2)
 322496c:	10c00044 	addi	r3,r2,1
 3224970:	0080c9b4 	movhi	r2,806
 3224974:	10b25e04 	addi	r2,r2,-13960
 3224978:	10c00f15 	stw	r3,60(r2)
         return ENP_BAD_HEADER;    
 322497c:	00bff804 	movi	r2,-32
 3224980:	e0bfff15 	stw	r2,-4(fp)
 3224984:	00001e06 	br	3224a00 <igmp_validate+0x344>

    * Version 1 Host Membership Reports and Version 1 Host Membership Query
    * packets will not be checked for the IP Router Alert option.
    */
#ifdef IGMP_V2    
   if ((type == IGMPv2_LEAVE_GROUP) || 
 3224988:	e0bff903 	ldbu	r2,-28(fp)
 322498c:	108005e0 	cmpeqi	r2,r2,23
 3224990:	10000b1e 	bne	r2,zero,32249c0 <igmp_validate+0x304>
 3224994:	e0bff903 	ldbu	r2,-28(fp)
 3224998:	108005a0 	cmpeqi	r2,r2,22
 322499c:	1000081e 	bne	r2,zero,32249c0 <igmp_validate+0x304>
 32249a0:	e0bff903 	ldbu	r2,-28(fp)
 32249a4:	10800458 	cmpnei	r2,r2,17
 32249a8:	1000141e 	bne	r2,zero,32249fc <igmp_validate+0x340>
 32249ac:	e0bffb17 	ldw	r2,-20(fp)
 32249b0:	10800043 	ldbu	r2,1(r2)
 32249b4:	10803fcc 	andi	r2,r2,255
 32249b8:	1005003a 	cmpeq	r2,r2,zero
 32249bc:	10000f1e 	bne	r2,zero,32249fc <igmp_validate+0x340>
       (type == IGMPv2_MEMBERSHIP_REPORT) ||
       ((type == IGMP_HOST_MEMBERSHIP_QUERY) && (igmp->igmp_code > 0)))
       
   {
      if (!igmpv2_chk4_rtr_alert_opt (pip))
 32249c0:	e13ffd17 	ldw	r4,-12(fp)
 32249c4:	3245bf40 	call	3245bf4 <igmpv2_chk4_rtr_alert_opt>
 32249c8:	10803fcc 	andi	r2,r2,255
 32249cc:	1004c03a 	cmpne	r2,r2,zero
 32249d0:	10000a1e 	bne	r2,zero,32249fc <igmp_validate+0x340>
      { 
         ++igmpstats.igmpv2mode_v2_rtr_alert_missing;
 32249d4:	0080c9b4 	movhi	r2,806
 32249d8:	10b25e04 	addi	r2,r2,-13960
 32249dc:	10801417 	ldw	r2,80(r2)
 32249e0:	10c00044 	addi	r3,r2,1
 32249e4:	0080c9b4 	movhi	r2,806
 32249e8:	10b25e04 	addi	r2,r2,-13960
 32249ec:	10c01415 	stw	r3,80(r2)
         return ENP_BAD_HEADER;
 32249f0:	00bff804 	movi	r2,-32
 32249f4:	e0bfff15 	stw	r2,-4(fp)
 32249f8:	00000106 	br	3224a00 <igmp_validate+0x344>
      }
   }
#endif   

   /* validation successful */
   return IGMP_OK;
 32249fc:	e03fff15 	stw	zero,-4(fp)
 3224a00:	e0bfff17 	ldw	r2,-4(fp)
}
 3224a04:	e037883a 	mov	sp,fp
 3224a08:	dfc00117 	ldw	ra,4(sp)
 3224a0c:	df000017 	ldw	fp,0(sp)
 3224a10:	dec00204 	addi	sp,sp,8
 3224a14:	f800283a 	ret

03224a18 <igmp_print_stats>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */
   
int igmp_print_stats (void * pio)
{  
 3224a18:	defff504 	addi	sp,sp,-44
 3224a1c:	dfc00a15 	stw	ra,40(sp)
 3224a20:	df000915 	stw	fp,36(sp)
 3224a24:	df000904 	addi	fp,sp,36
 3224a28:	e13ffa15 	stw	r4,-24(fp)
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3224a2c:	0080c9b4 	movhi	r2,806
 3224a30:	10b45b04 	addi	r2,r2,-11924
 3224a34:	10800017 	ldw	r2,0(r2)
 3224a38:	e0bff915 	stw	r2,-28(fp)
 3224a3c:	00004506 	br	3224b54 <igmp_print_stats+0x13c>
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 3224a40:	e0bff917 	ldw	r2,-28(fp)
 3224a44:	10800104 	addi	r2,r2,4
 3224a48:	e0bfff15 	stw	r2,-4(fp)
 3224a4c:	e0bff917 	ldw	r2,-28(fp)
 3224a50:	10802f03 	ldbu	r2,188(r2)
 3224a54:	10803fcc 	andi	r2,r2,255
 3224a58:	e0bffe15 	stw	r2,-8(fp)
 3224a5c:	e0bff917 	ldw	r2,-28(fp)
 3224a60:	10802f03 	ldbu	r2,188(r2)
 3224a64:	10803fcc 	andi	r2,r2,255
 3224a68:	10800058 	cmpnei	r2,r2,1
 3224a6c:	1000041e 	bne	r2,zero,3224a80 <igmp_print_stats+0x68>
 3224a70:	0080c974 	movhi	r2,805
 3224a74:	10b9f104 	addi	r2,r2,-6204
 3224a78:	e0bffd15 	stw	r2,-12(fp)
 3224a7c:	00000306 	br	3224a8c <igmp_print_stats+0x74>
 3224a80:	0080c974 	movhi	r2,805
 3224a84:	10b9f204 	addi	r2,r2,-6200
 3224a88:	e0bffd15 	stw	r2,-12(fp)
 3224a8c:	e0bffd17 	ldw	r2,-12(fp)
 3224a90:	d8800015 	stw	r2,0(sp)
 3224a94:	e13ffa17 	ldw	r4,-24(fp)
 3224a98:	0140c974 	movhi	r5,805
 3224a9c:	2979f304 	addi	r5,r5,-6196
 3224aa0:	e1bfff17 	ldw	r6,-4(fp)
 3224aa4:	e1fffe17 	ldw	r7,-8(fp)
 3224aa8:	32260180 	call	3226018 <ns_printf>
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 3224aac:	e0bff917 	ldw	r2,-28(fp)
 3224ab0:	10802f03 	ldbu	r2,188(r2)
 3224ab4:	10803fcc 	andi	r2,r2,255
 3224ab8:	10800098 	cmpnei	r2,r2,2
 3224abc:	10001e1e 	bne	r2,zero,3224b38 <igmp_print_stats+0x120>
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 3224ac0:	e0bff917 	ldw	r2,-28(fp)
 3224ac4:	10802d03 	ldbu	r2,180(r2)
 3224ac8:	10803fcc 	andi	r2,r2,255
 3224acc:	e0bffc15 	stw	r2,-16(fp)
 3224ad0:	e0bff917 	ldw	r2,-28(fp)
 3224ad4:	10802d03 	ldbu	r2,180(r2)
 3224ad8:	10803fcc 	andi	r2,r2,255
 3224adc:	10800058 	cmpnei	r2,r2,1
 3224ae0:	1000041e 	bne	r2,zero,3224af4 <igmp_print_stats+0xdc>
 3224ae4:	0080c974 	movhi	r2,805
 3224ae8:	10b9f804 	addi	r2,r2,-6176
 3224aec:	e0bffb15 	stw	r2,-20(fp)
 3224af0:	00000306 	br	3224b00 <igmp_print_stats+0xe8>
 3224af4:	0080c974 	movhi	r2,805
 3224af8:	10b9fa04 	addi	r2,r2,-6168
 3224afc:	e0bffb15 	stw	r2,-20(fp)
 3224b00:	e0bff917 	ldw	r2,-28(fp)
 3224b04:	10c02e17 	ldw	r3,184(r2)
 3224b08:	0080c974 	movhi	r2,805
 3224b0c:	10925604 	addi	r2,r2,18776
 3224b10:	10800017 	ldw	r2,0(r2)
 3224b14:	d8c00015 	stw	r3,0(sp)
 3224b18:	d8800115 	stw	r2,4(sp)
 3224b1c:	e13ffa17 	ldw	r4,-24(fp)
 3224b20:	0140c974 	movhi	r5,805
 3224b24:	2979fc04 	addi	r5,r5,-6160
 3224b28:	e1bffc17 	ldw	r6,-16(fp)
 3224b2c:	e1fffb17 	ldw	r7,-20(fp)
 3224b30:	32260180 	call	3226018 <ns_printf>
 3224b34:	00000406 	br	3224b48 <igmp_print_stats+0x130>
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
                    ifp->igmpv1_query_rcvd_time,
                    cticks);
      }
      else ns_printf (pio, "\n");
 3224b38:	e13ffa17 	ldw	r4,-24(fp)
 3224b3c:	0140c974 	movhi	r5,805
 3224b40:	297a0704 	addi	r5,r5,-6116
 3224b44:	32260180 	call	3226018 <ns_printf>
   
int igmp_print_stats (void * pio)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3224b48:	e0bff917 	ldw	r2,-28(fp)
 3224b4c:	10800017 	ldw	r2,0(r2)
 3224b50:	e0bff915 	stw	r2,-28(fp)
 3224b54:	e0bff917 	ldw	r2,-28(fp)
 3224b58:	1004c03a 	cmpne	r2,r2,zero
 3224b5c:	103fb81e 	bne	r2,zero,3224a40 <igmp_print_stats+0x28>
      }
      else ns_printf (pio, "\n");
   }   

   /* rx and timer statistics */
   ns_printf (pio, "[Rx ] IGMP messages rcvd: %lu, timers running: %lu\n", igmpstats.igmp_total_rcvd, igmp_timers_are_running);
 3224b60:	0080c9b4 	movhi	r2,806
 3224b64:	10b25e04 	addi	r2,r2,-13960
 3224b68:	11800017 	ldw	r6,0(r2)
 3224b6c:	d1e8bd17 	ldw	r7,-23820(gp)
 3224b70:	e13ffa17 	ldw	r4,-24(fp)
 3224b74:	0140c974 	movhi	r5,805
 3224b78:	297a0804 	addi	r5,r5,-6112
 3224b7c:	32260180 	call	3226018 <ns_printf>
   
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v1-mode links): %lu\n", igmpstats.igmpv1mode_v1_queries_rcvd);
 3224b80:	0080c9b4 	movhi	r2,806
 3224b84:	10b25e04 	addi	r2,r2,-13960
 3224b88:	11800117 	ldw	r6,4(r2)
 3224b8c:	e13ffa17 	ldw	r4,-24(fp)
 3224b90:	0140c974 	movhi	r5,805
 3224b94:	297a1504 	addi	r5,r5,-6060
 3224b98:	32260180 	call	3226018 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Reports rcvd: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd);
 3224b9c:	0080c9b4 	movhi	r2,806
 3224ba0:	10b25e04 	addi	r2,r2,-13960
 3224ba4:	11800217 	ldw	r6,8(r2)
 3224ba8:	e13ffa17 	ldw	r4,-24(fp)
 3224bac:	0140c974 	movhi	r5,805
 3224bb0:	297a2604 	addi	r5,r5,-5992
 3224bb4:	32260180 	call	3226018 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer);
 3224bb8:	0080c9b4 	movhi	r2,806
 3224bbc:	10b25e04 	addi	r2,r2,-13960
 3224bc0:	11800317 	ldw	r6,12(r2)
 3224bc4:	e13ffa17 	ldw	r4,-24(fp)
 3224bc8:	0140c974 	movhi	r5,805
 3224bcc:	297a3204 	addi	r5,r5,-5944
 3224bd0:	32260180 	call	3226018 <ns_printf>
      
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v2-mode links): %lu\n", igmpstats.igmpv2mode_v1_queries_rcvd);
 3224bd4:	0080c9b4 	movhi	r2,806
 3224bd8:	10b25e04 	addi	r2,r2,-13960
 3224bdc:	11800417 	ldw	r6,16(r2)
 3224be0:	e13ffa17 	ldw	r4,-24(fp)
 3224be4:	0140c974 	movhi	r5,805
 3224be8:	297a4504 	addi	r5,r5,-5868
 3224bec:	32260180 	call	3226018 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 General Queries rcvd: %lu, Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_general_queries_rcvd, igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd);
 3224bf0:	0080c9b4 	movhi	r2,806
 3224bf4:	10b25e04 	addi	r2,r2,-13960
 3224bf8:	11800517 	ldw	r6,20(r2)
 3224bfc:	0080c9b4 	movhi	r2,806
 3224c00:	10b25e04 	addi	r2,r2,-13960
 3224c04:	11c00617 	ldw	r7,24(r2)
 3224c08:	e13ffa17 	ldw	r4,-24(fp)
 3224c0c:	0140c974 	movhi	r5,805
 3224c10:	297a5604 	addi	r5,r5,-5800
 3224c14:	32260180 	call	3226018 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer);   
 3224c18:	0080c9b4 	movhi	r2,806
 3224c1c:	10b25e04 	addi	r2,r2,-13960
 3224c20:	11800717 	ldw	r6,28(r2)
 3224c24:	e13ffa17 	ldw	r4,-24(fp)
 3224c28:	0140c974 	movhi	r5,805
 3224c2c:	297a3204 	addi	r5,r5,-5944
 3224c30:	32260180 	call	3226018 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd with no local timer: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_no_timer);
 3224c34:	0080c9b4 	movhi	r2,806
 3224c38:	10b25e04 	addi	r2,r2,-13960
 3224c3c:	11800817 	ldw	r6,32(r2)
 3224c40:	e13ffa17 	ldw	r4,-24(fp)
 3224c44:	0140c974 	movhi	r5,805
 3224c48:	297a6904 	addi	r5,r5,-5724
 3224c4c:	32260180 	call	3226018 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 Leave Group messages rcvd: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_rcvd);
 3224c50:	0080c9b4 	movhi	r2,806
 3224c54:	10b25e04 	addi	r2,r2,-13960
 3224c58:	11800917 	ldw	r6,36(r2)
 3224c5c:	e13ffa17 	ldw	r4,-24(fp)
 3224c60:	0140c974 	movhi	r5,805
 3224c64:	297a7a04 	addi	r5,r5,-5656
 3224c68:	32260180 	call	3226018 <ns_printf>
   
   /* tx statistics */
   ns_printf (pio, "[Tx ] IGMPv2 Leave Group messages sent: %lu, Membership Reports sent: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_sent, igmpstats.igmpv2mode_v2_reports_sent);
 3224c6c:	0080c9b4 	movhi	r2,806
 3224c70:	10b25e04 	addi	r2,r2,-13960
 3224c74:	11801717 	ldw	r6,92(r2)
 3224c78:	0080c9b4 	movhi	r2,806
 3224c7c:	10b25e04 	addi	r2,r2,-13960
 3224c80:	11c01817 	ldw	r7,96(r2)
 3224c84:	e13ffa17 	ldw	r4,-24(fp)
 3224c88:	0140c974 	movhi	r5,805
 3224c8c:	297a8604 	addi	r5,r5,-5608
 3224c90:	32260180 	call	3226018 <ns_printf>
   ns_printf (pio, "[Tx ] IGMPv1 Host Membership Reports sent: %lu\n", igmpstats.igmp_v1_reports_sent);
 3224c94:	0080c9b4 	movhi	r2,806
 3224c98:	10b25e04 	addi	r2,r2,-13960
 3224c9c:	11801617 	ldw	r6,88(r2)
 3224ca0:	e13ffa17 	ldw	r4,-24(fp)
 3224ca4:	0140c974 	movhi	r5,805
 3224ca8:	297a9904 	addi	r5,r5,-5532
 3224cac:	32260180 	call	3226018 <ns_printf>

   /* error statistics */
   ns_printf (pio, "[Err] IGMP packets rcvd with bad length: %lu\n", igmpstats.igmp_badlen_rcvd);
 3224cb0:	0080c9b4 	movhi	r2,806
 3224cb4:	10b25e04 	addi	r2,r2,-13960
 3224cb8:	11800a17 	ldw	r6,40(r2)
 3224cbc:	e13ffa17 	ldw	r4,-24(fp)
 3224cc0:	0140c974 	movhi	r5,805
 3224cc4:	297aa504 	addi	r5,r5,-5484
 3224cc8:	32260180 	call	3226018 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets rcvd with bad checksum: %lu\n", igmpstats.igmp_badsum_rcvd);
 3224ccc:	0080c9b4 	movhi	r2,806
 3224cd0:	10b25e04 	addi	r2,r2,-13960
 3224cd4:	11800b17 	ldw	r6,44(r2)
 3224cd8:	e13ffa17 	ldw	r4,-24(fp)
 3224cdc:	0140c974 	movhi	r5,805
 3224ce0:	297ab104 	addi	r5,r5,-5436
 3224ce4:	32260180 	call	3226018 <ns_printf>
   ns_printf (pio, "[Err] Packet buffer allocation failures: %lu, Bad IGMP Oper Mode config: %lu\n",igmpstats.igmp_pkt_alloc_fail, igmpstats.igmp_bad_oper_mode);
 3224ce8:	0080c9b4 	movhi	r2,806
 3224cec:	10b25e04 	addi	r2,r2,-13960
 3224cf0:	11800c17 	ldw	r6,48(r2)
 3224cf4:	0080c9b4 	movhi	r2,806
 3224cf8:	10b25e04 	addi	r2,r2,-13960
 3224cfc:	11c00d17 	ldw	r7,52(r2)
 3224d00:	e13ffa17 	ldw	r4,-24(fp)
 3224d04:	0140c974 	movhi	r5,805
 3224d08:	297abd04 	addi	r5,r5,-5388
 3224d0c:	32260180 	call	3226018 <ns_printf>
   ns_printf (pio, "[Err] Bad IGMP Queries rcvd: %lu, Bad IGMP Reports rcvd: %lu\n", igmpstats.igmp_bad_queries_rcvd, igmpstats.igmp_bad_reports_rcvd); 
 3224d10:	0080c9b4 	movhi	r2,806
 3224d14:	10b25e04 	addi	r2,r2,-13960
 3224d18:	11800e17 	ldw	r6,56(r2)
 3224d1c:	0080c9b4 	movhi	r2,806
 3224d20:	10b25e04 	addi	r2,r2,-13960
 3224d24:	11c00f17 	ldw	r7,60(r2)
 3224d28:	e13ffa17 	ldw	r4,-24(fp)
 3224d2c:	0140c974 	movhi	r5,805
 3224d30:	297ad104 	addi	r5,r5,-5308
 3224d34:	32260180 	call	3226018 <ns_printf>
   ns_printf (pio, "[Err] Bad IGMPv2 Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd);
 3224d38:	0080c9b4 	movhi	r2,806
 3224d3c:	10b25e04 	addi	r2,r2,-13960
 3224d40:	11801117 	ldw	r6,68(r2)
 3224d44:	e13ffa17 	ldw	r4,-24(fp)
 3224d48:	0140c974 	movhi	r5,805
 3224d4c:	297ae104 	addi	r5,r5,-5244
 3224d50:	32260180 	call	3226018 <ns_printf>
   ns_printf (pio, "[Err] IGMPv2 Group-Specific Queries rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd);
 3224d54:	0080c9b4 	movhi	r2,806
 3224d58:	10b25e04 	addi	r2,r2,-13960
 3224d5c:	11801217 	ldw	r6,72(r2)
 3224d60:	e13ffa17 	ldw	r4,-24(fp)
 3224d64:	0140c974 	movhi	r5,805
 3224d68:	297aee04 	addi	r5,r5,-5192
 3224d6c:	32260180 	call	3226018 <ns_printf>
   ns_printf (pio, "[Err] IGMP Membership Reports rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd);
 3224d70:	0080c9b4 	movhi	r2,806
 3224d74:	10b25e04 	addi	r2,r2,-13960
 3224d78:	11801317 	ldw	r6,76(r2)
 3224d7c:	e13ffa17 	ldw	r4,-24(fp)
 3224d80:	0140c974 	movhi	r5,805
 3224d84:	297b0104 	addi	r5,r5,-5116
 3224d88:	32260180 	call	3226018 <ns_printf>
   ns_printf (pio, "[Err] Number of IGMPv2 messages rcvd without Router Alert option: %lu\n", igmpstats.igmpv2mode_v2_rtr_alert_missing); 
 3224d8c:	0080c9b4 	movhi	r2,806
 3224d90:	10b25e04 	addi	r2,r2,-13960
 3224d94:	11801417 	ldw	r6,80(r2)
 3224d98:	e13ffa17 	ldw	r4,-24(fp)
 3224d9c:	0140c974 	movhi	r5,805
 3224da0:	297b1204 	addi	r5,r5,-5048
 3224da4:	32260180 	call	3226018 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v1-mode links: %lu\n", igmpstats.igmpv1mode_unknown_pkttype);
 3224da8:	0080c9b4 	movhi	r2,806
 3224dac:	10b25e04 	addi	r2,r2,-13960
 3224db0:	11801017 	ldw	r6,64(r2)
 3224db4:	e13ffa17 	ldw	r4,-24(fp)
 3224db8:	0140c974 	movhi	r5,805
 3224dbc:	297b2404 	addi	r5,r5,-4976
 3224dc0:	32260180 	call	3226018 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v2-mode links: %lu\n", igmpstats.igmpv2mode_unknown_pkttype);
 3224dc4:	0080c9b4 	movhi	r2,806
 3224dc8:	10b25e04 	addi	r2,r2,-13960
 3224dcc:	11801517 	ldw	r6,84(r2)
 3224dd0:	e13ffa17 	ldw	r4,-24(fp)
 3224dd4:	0140c974 	movhi	r5,805
 3224dd8:	297b3404 	addi	r5,r5,-4912
 3224ddc:	32260180 	call	3226018 <ns_printf>
   
   return IGMP_OK;
 3224de0:	0005883a 	mov	r2,zero
}
 3224de4:	e037883a 	mov	sp,fp
 3224de8:	dfc00117 	ldw	ra,4(sp)
 3224dec:	df000017 	ldw	fp,0(sp)
 3224df0:	dec00204 	addi	sp,sp,8
 3224df4:	f800283a 	ret

03224df8 <bsd_accept>:
 *          The error is available via bsd_errno(s).
 */
BSD_SOCKET
bsd_accept(BSD_SOCKET s,
           struct sockaddr * addr, int * addrlen)
{
 3224df8:	defff304 	addi	sp,sp,-52
 3224dfc:	dfc00c15 	stw	ra,48(sp)
 3224e00:	df000b15 	stw	fp,44(sp)
 3224e04:	df000b04 	addi	fp,sp,44
 3224e08:	e13ffc15 	stw	r4,-16(fp)
 3224e0c:	e17ffd15 	stw	r5,-12(fp)
 3224e10:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr laddr;
   long lret;

   so = LONG2SO(s);
 3224e14:	e0bffc17 	ldw	r2,-16(fp)
 3224e18:	10bff804 	addi	r2,r2,-32
 3224e1c:	1085883a 	add	r2,r2,r2
 3224e20:	1085883a 	add	r2,r2,r2
 3224e24:	e0bff715 	stw	r2,-36(fp)
   SOC_CHECK(so);
 3224e28:	0080c9b4 	movhi	r2,806
 3224e2c:	10b39704 	addi	r2,r2,-12708
 3224e30:	e0bff515 	stw	r2,-44(fp)
 3224e34:	00000606 	br	3224e50 <bsd_accept+0x58>
 3224e38:	e0fff517 	ldw	r3,-44(fp)
 3224e3c:	e0bff717 	ldw	r2,-36(fp)
 3224e40:	18800626 	beq	r3,r2,3224e5c <bsd_accept+0x64>
 3224e44:	e0bff517 	ldw	r2,-44(fp)
 3224e48:	10800017 	ldw	r2,0(r2)
 3224e4c:	e0bff515 	stw	r2,-44(fp)
 3224e50:	e0bff517 	ldw	r2,-44(fp)
 3224e54:	1004c03a 	cmpne	r2,r2,zero
 3224e58:	103ff71e 	bne	r2,zero,3224e38 <bsd_accept+0x40>
 3224e5c:	e0fff517 	ldw	r3,-44(fp)
 3224e60:	e0bff717 	ldw	r2,-36(fp)
 3224e64:	18800426 	beq	r3,r2,3224e78 <bsd_accept+0x80>
 3224e68:	322ab8c0 	call	322ab8c <dtrap>
 3224e6c:	00bfffc4 	movi	r2,-1
 3224e70:	e0bfff15 	stw	r2,-4(fp)
 3224e74:	00002806 	br	3224f18 <bsd_accept+0x120>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (addr != NULL)
 3224e78:	e0bffd17 	ldw	r2,-12(fp)
 3224e7c:	1005003a 	cmpeq	r2,r2,zero
 3224e80:	1000091e 	bne	r2,zero,3224ea8 <bsd_accept+0xb0>
   {
      if (addrlen == 0)
 3224e84:	e0bffe17 	ldw	r2,-8(fp)
 3224e88:	1004c03a 	cmpne	r2,r2,zero
 3224e8c:	1000061e 	bne	r2,zero,3224ea8 <bsd_accept+0xb0>
      {
         so->so_error = EFAULT;
 3224e90:	e0fff717 	ldw	r3,-36(fp)
 3224e94:	00800384 	movi	r2,14
 3224e98:	18800615 	stw	r2,24(r3)
         return -1;
 3224e9c:	00bfffc4 	movi	r2,-1
 3224ea0:	e0bfff15 	stw	r2,-4(fp)
 3224ea4:	00001c06 	br	3224f18 <bsd_accept+0x120>
      }
   }

   lret = t_accept(s, &laddr, addrlen);
 3224ea8:	e17ff804 	addi	r5,fp,-32
 3224eac:	e13ffc17 	ldw	r4,-16(fp)
 3224eb0:	e1bffe17 	ldw	r6,-8(fp)
 3224eb4:	322df000 	call	322df00 <t_accept>
 3224eb8:	e0bff615 	stw	r2,-40(fp)
    * address: copy the peer's address back into the buffer, but limit
    * the copy to the lesser of the buffer's length and sizeof(struct
    * sockaddr_in), which is all that t_accept() can return as a peer
    * address.  
    */
   if ((lret != -1) && (addr != NULL))
 3224ebc:	e0bff617 	ldw	r2,-40(fp)
 3224ec0:	10bfffe0 	cmpeqi	r2,r2,-1
 3224ec4:	1000121e 	bne	r2,zero,3224f10 <bsd_accept+0x118>
 3224ec8:	e0bffd17 	ldw	r2,-12(fp)
 3224ecc:	1005003a 	cmpeq	r2,r2,zero
 3224ed0:	10000f1e 	bne	r2,zero,3224f10 <bsd_accept+0x118>
   {
      if (*addrlen > sizeof(struct sockaddr_in))
 3224ed4:	e0bffe17 	ldw	r2,-8(fp)
 3224ed8:	10800017 	ldw	r2,0(r2)
 3224edc:	10800470 	cmpltui	r2,r2,17
 3224ee0:	1000031e 	bne	r2,zero,3224ef0 <bsd_accept+0xf8>
         *addrlen = sizeof(struct sockaddr_in);
 3224ee4:	e0fffe17 	ldw	r3,-8(fp)
 3224ee8:	00800404 	movi	r2,16
 3224eec:	18800015 	stw	r2,0(r3)
      MEMCPY(addr, &laddr, *addrlen);
 3224ef0:	e0bffe17 	ldw	r2,-8(fp)
 3224ef4:	10800017 	ldw	r2,0(r2)
 3224ef8:	100d883a 	mov	r6,r2
 3224efc:	e0bffd17 	ldw	r2,-12(fp)
 3224f00:	e0fff804 	addi	r3,fp,-32
 3224f04:	1009883a 	mov	r4,r2
 3224f08:	180b883a 	mov	r5,r3
 3224f0c:	32067cc0 	call	32067cc <memcpy>
   }

   return lret;
 3224f10:	e0bff617 	ldw	r2,-40(fp)
 3224f14:	e0bfff15 	stw	r2,-4(fp)
 3224f18:	e0bfff17 	ldw	r2,-4(fp)
}
 3224f1c:	e037883a 	mov	sp,fp
 3224f20:	dfc00117 	ldw	ra,4(sp)
 3224f24:	df000017 	ldw	fp,0(sp)
 3224f28:	dec00204 	addi	sp,sp,8
 3224f2c:	f800283a 	ret

03224f30 <bsd_getpeername>:
 *          available via bsd_errno(s).
 */
int
bsd_getpeername(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 3224f30:	defff204 	addi	sp,sp,-56
 3224f34:	dfc00d15 	stw	ra,52(sp)
 3224f38:	df000c15 	stw	fp,48(sp)
 3224f3c:	df000c04 	addi	fp,sp,48
 3224f40:	e13ffc15 	stw	r4,-16(fp)
 3224f44:	e17ffd15 	stw	r5,-12(fp)
 3224f48:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 3224f4c:	e0bffc17 	ldw	r2,-16(fp)
 3224f50:	10bff804 	addi	r2,r2,-32
 3224f54:	1085883a 	add	r2,r2,r2
 3224f58:	1085883a 	add	r2,r2,r2
 3224f5c:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 3224f60:	0080c9b4 	movhi	r2,806
 3224f64:	10b39704 	addi	r2,r2,-12708
 3224f68:	e0bff415 	stw	r2,-48(fp)
 3224f6c:	00000606 	br	3224f88 <bsd_getpeername+0x58>
 3224f70:	e0fff417 	ldw	r3,-48(fp)
 3224f74:	e0bff617 	ldw	r2,-40(fp)
 3224f78:	18800626 	beq	r3,r2,3224f94 <bsd_getpeername+0x64>
 3224f7c:	e0bff417 	ldw	r2,-48(fp)
 3224f80:	10800017 	ldw	r2,0(r2)
 3224f84:	e0bff415 	stw	r2,-48(fp)
 3224f88:	e0bff417 	ldw	r2,-48(fp)
 3224f8c:	1004c03a 	cmpne	r2,r2,zero
 3224f90:	103ff71e 	bne	r2,zero,3224f70 <bsd_getpeername+0x40>
 3224f94:	e0fff417 	ldw	r3,-48(fp)
 3224f98:	e0bff617 	ldw	r2,-40(fp)
 3224f9c:	18800426 	beq	r3,r2,3224fb0 <bsd_getpeername+0x80>
 3224fa0:	322ab8c0 	call	322ab8c <dtrap>
 3224fa4:	00bfffc4 	movi	r2,-1
 3224fa8:	e0bfff15 	stw	r2,-4(fp)
 3224fac:	00002506 	br	3225044 <bsd_getpeername+0x114>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 3224fb0:	e0bffe17 	ldw	r2,-8(fp)
 3224fb4:	1004c03a 	cmpne	r2,r2,zero
 3224fb8:	1000061e 	bne	r2,zero,3224fd4 <bsd_getpeername+0xa4>
   {
      so->so_error = EFAULT;
 3224fbc:	e0fff617 	ldw	r3,-40(fp)
 3224fc0:	00800384 	movi	r2,14
 3224fc4:	18800615 	stw	r2,24(r3)
      return -1;
 3224fc8:	00bfffc4 	movi	r2,-1
 3224fcc:	e0bfff15 	stw	r2,-4(fp)
 3224fd0:	00001c06 	br	3225044 <bsd_getpeername+0x114>
   }
   lnamelen = *namelen;
 3224fd4:	e0bffe17 	ldw	r2,-8(fp)
 3224fd8:	10800017 	ldw	r2,0(r2)
 3224fdc:	e0bffb15 	stw	r2,-20(fp)

   lret = t_getpeername(s, &lname, &lnamelen);
 3224fe0:	e17ff704 	addi	r5,fp,-36
 3224fe4:	e1bffb04 	addi	r6,fp,-20
 3224fe8:	e13ffc17 	ldw	r4,-16(fp)
 3224fec:	322e4400 	call	322e440 <t_getpeername>
 3224ff0:	e0bff515 	stw	r2,-44(fp)
    * t_getpeername() can return as a peer address, and pass the
    * copied length back to the caller.  
    * For IPV6 addresses, or for dual IPV4/IPV6 stack, 
    * the max size is sizeof(struct sockaddr_in6)
    */
   if (lret != -1)
 3224ff4:	e0bff517 	ldw	r2,-44(fp)
 3224ff8:	10bfffe0 	cmpeqi	r2,r2,-1
 3224ffc:	10000f1e 	bne	r2,zero,322503c <bsd_getpeername+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 3225000:	e0bffb17 	ldw	r2,-20(fp)
 3225004:	10800470 	cmpltui	r2,r2,17
 3225008:	1000021e 	bne	r2,zero,3225014 <bsd_getpeername+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 322500c:	00800404 	movi	r2,16
 3225010:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(name, &lname, lnamelen);
 3225014:	e0bffb17 	ldw	r2,-20(fp)
 3225018:	100d883a 	mov	r6,r2
 322501c:	e0bffd17 	ldw	r2,-12(fp)
 3225020:	e0fff704 	addi	r3,fp,-36
 3225024:	1009883a 	mov	r4,r2
 3225028:	180b883a 	mov	r5,r3
 322502c:	32067cc0 	call	32067cc <memcpy>
      *namelen = lnamelen;
 3225030:	e0fffb17 	ldw	r3,-20(fp)
 3225034:	e0bffe17 	ldw	r2,-8(fp)
 3225038:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 322503c:	e0bff517 	ldw	r2,-44(fp)
 3225040:	e0bfff15 	stw	r2,-4(fp)
 3225044:	e0bfff17 	ldw	r2,-4(fp)
}
 3225048:	e037883a 	mov	sp,fp
 322504c:	dfc00117 	ldw	ra,4(sp)
 3225050:	df000017 	ldw	fp,0(sp)
 3225054:	dec00204 	addi	sp,sp,8
 3225058:	f800283a 	ret

0322505c <bsd_getsockname>:
 *          available via bsd_errno(s).
 */
int
bsd_getsockname(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 322505c:	defff204 	addi	sp,sp,-56
 3225060:	dfc00d15 	stw	ra,52(sp)
 3225064:	df000c15 	stw	fp,48(sp)
 3225068:	df000c04 	addi	fp,sp,48
 322506c:	e13ffc15 	stw	r4,-16(fp)
 3225070:	e17ffd15 	stw	r5,-12(fp)
 3225074:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 3225078:	e0bffc17 	ldw	r2,-16(fp)
 322507c:	10bff804 	addi	r2,r2,-32
 3225080:	1085883a 	add	r2,r2,r2
 3225084:	1085883a 	add	r2,r2,r2
 3225088:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 322508c:	0080c9b4 	movhi	r2,806
 3225090:	10b39704 	addi	r2,r2,-12708
 3225094:	e0bff415 	stw	r2,-48(fp)
 3225098:	00000606 	br	32250b4 <bsd_getsockname+0x58>
 322509c:	e0fff417 	ldw	r3,-48(fp)
 32250a0:	e0bff617 	ldw	r2,-40(fp)
 32250a4:	18800626 	beq	r3,r2,32250c0 <bsd_getsockname+0x64>
 32250a8:	e0bff417 	ldw	r2,-48(fp)
 32250ac:	10800017 	ldw	r2,0(r2)
 32250b0:	e0bff415 	stw	r2,-48(fp)
 32250b4:	e0bff417 	ldw	r2,-48(fp)
 32250b8:	1004c03a 	cmpne	r2,r2,zero
 32250bc:	103ff71e 	bne	r2,zero,322509c <bsd_getsockname+0x40>
 32250c0:	e0fff417 	ldw	r3,-48(fp)
 32250c4:	e0bff617 	ldw	r2,-40(fp)
 32250c8:	18800426 	beq	r3,r2,32250dc <bsd_getsockname+0x80>
 32250cc:	322ab8c0 	call	322ab8c <dtrap>
 32250d0:	00bfffc4 	movi	r2,-1
 32250d4:	e0bfff15 	stw	r2,-4(fp)
 32250d8:	00002506 	br	3225170 <bsd_getsockname+0x114>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 32250dc:	e0bffe17 	ldw	r2,-8(fp)
 32250e0:	1004c03a 	cmpne	r2,r2,zero
 32250e4:	1000061e 	bne	r2,zero,3225100 <bsd_getsockname+0xa4>
   {
      so->so_error = EFAULT;
 32250e8:	e0fff617 	ldw	r3,-40(fp)
 32250ec:	00800384 	movi	r2,14
 32250f0:	18800615 	stw	r2,24(r3)
      return -1;
 32250f4:	00bfffc4 	movi	r2,-1
 32250f8:	e0bfff15 	stw	r2,-4(fp)
 32250fc:	00001c06 	br	3225170 <bsd_getsockname+0x114>
   }
   lnamelen = *namelen;
 3225100:	e0bffe17 	ldw	r2,-8(fp)
 3225104:	10800017 	ldw	r2,0(r2)
 3225108:	e0bffb15 	stw	r2,-20(fp)

   lret = t_getsockname(s, &lname, &lnamelen);
 322510c:	e17ff704 	addi	r5,fp,-36
 3225110:	e1bffb04 	addi	r6,fp,-20
 3225114:	e13ffc17 	ldw	r4,-16(fp)
 3225118:	322e4840 	call	322e484 <t_getsockname>
 322511c:	e0bff515 	stw	r2,-44(fp)
    * copied length back to the caller.  
    * For IPV6 addresses, or for a dual IPV4/IPV6 stack, 
    * the max size copied is sizeof(struct sockaddr_in6)
    *
    */
   if (lret != -1)
 3225120:	e0bff517 	ldw	r2,-44(fp)
 3225124:	10bfffe0 	cmpeqi	r2,r2,-1
 3225128:	10000f1e 	bne	r2,zero,3225168 <bsd_getsockname+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 322512c:	e0bffb17 	ldw	r2,-20(fp)
 3225130:	10800470 	cmpltui	r2,r2,17
 3225134:	1000021e 	bne	r2,zero,3225140 <bsd_getsockname+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 3225138:	00800404 	movi	r2,16
 322513c:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);
#endif
      MEMCPY(name, &lname, lnamelen);
 3225140:	e0bffb17 	ldw	r2,-20(fp)
 3225144:	100d883a 	mov	r6,r2
 3225148:	e0bffd17 	ldw	r2,-12(fp)
 322514c:	e0fff704 	addi	r3,fp,-36
 3225150:	1009883a 	mov	r4,r2
 3225154:	180b883a 	mov	r5,r3
 3225158:	32067cc0 	call	32067cc <memcpy>
      *namelen = lnamelen;
 322515c:	e0fffb17 	ldw	r3,-20(fp)
 3225160:	e0bffe17 	ldw	r2,-8(fp)
 3225164:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 3225168:	e0bff517 	ldw	r2,-44(fp)
 322516c:	e0bfff15 	stw	r2,-4(fp)
 3225170:	e0bfff17 	ldw	r2,-4(fp)
}
 3225174:	e037883a 	mov	sp,fp
 3225178:	dfc00117 	ldw	ra,4(sp)
 322517c:	df000017 	ldw	fp,0(sp)
 3225180:	dec00204 	addi	sp,sp,8
 3225184:	f800283a 	ret

03225188 <bsd_i_sockoptlen>:
 * RETURNS: minimum length of the named socket option, in bytes
 */
int 
bsd_i_sockoptlen(int level,
                 int name)
{
 3225188:	defffb04 	addi	sp,sp,-20
 322518c:	df000415 	stw	fp,16(sp)
 3225190:	df000404 	addi	fp,sp,16
 3225194:	e13ffc15 	stw	r4,-16(fp)
 3225198:	e17ffd15 	stw	r5,-12(fp)
   USE_ARG(level);

   switch (name)
 322519c:	e0bffd17 	ldw	r2,-12(fp)
 32251a0:	e0bfff15 	stw	r2,-4(fp)
 32251a4:	e0ffff17 	ldw	r3,-4(fp)
 32251a8:	18802020 	cmpeqi	r2,r3,128
 32251ac:	1000491e 	bne	r2,zero,32252d4 <bsd_i_sockoptlen+0x14c>
 32251b0:	e0ffff17 	ldw	r3,-4(fp)
 32251b4:	18802048 	cmpgei	r2,r3,129
 32251b8:	1000251e 	bne	r2,zero,3225250 <bsd_i_sockoptlen+0xc8>
 32251bc:	e0ffff17 	ldw	r3,-4(fp)
 32251c0:	18800308 	cmpgei	r2,r3,12
 32251c4:	1000141e 	bne	r2,zero,3225218 <bsd_i_sockoptlen+0x90>
 32251c8:	e0ffff17 	ldw	r3,-4(fp)
 32251cc:	18800288 	cmpgei	r2,r3,10
 32251d0:	10004c1e 	bne	r2,zero,3225304 <bsd_i_sockoptlen+0x17c>
 32251d4:	e0ffff17 	ldw	r3,-4(fp)
 32251d8:	18800120 	cmpeqi	r2,r3,4
 32251dc:	1000431e 	bne	r2,zero,32252ec <bsd_i_sockoptlen+0x164>
 32251e0:	e0ffff17 	ldw	r3,-4(fp)
 32251e4:	18800148 	cmpgei	r2,r3,5
 32251e8:	1000041e 	bne	r2,zero,32251fc <bsd_i_sockoptlen+0x74>
 32251ec:	e0ffff17 	ldw	r3,-4(fp)
 32251f0:	188000e0 	cmpeqi	r2,r3,3
 32251f4:	1000491e 	bne	r2,zero,322531c <bsd_i_sockoptlen+0x194>
 32251f8:	00004b06 	br	3225328 <bsd_i_sockoptlen+0x1a0>
 32251fc:	e0ffff17 	ldw	r3,-4(fp)
 3225200:	18800220 	cmpeqi	r2,r3,8
 3225204:	1000391e 	bne	r2,zero,32252ec <bsd_i_sockoptlen+0x164>
 3225208:	e0ffff17 	ldw	r3,-4(fp)
 322520c:	18800260 	cmpeqi	r2,r3,9
 3225210:	1000391e 	bne	r2,zero,32252f8 <bsd_i_sockoptlen+0x170>
 3225214:	00004406 	br	3225328 <bsd_i_sockoptlen+0x1a0>
 3225218:	e0ffff17 	ldw	r3,-4(fp)
 322521c:	18800420 	cmpeqi	r2,r3,16
 3225220:	1000321e 	bne	r2,zero,32252ec <bsd_i_sockoptlen+0x164>
 3225224:	e0ffff17 	ldw	r3,-4(fp)
 3225228:	18800448 	cmpgei	r2,r3,17
 322522c:	1000041e 	bne	r2,zero,3225240 <bsd_i_sockoptlen+0xb8>
 3225230:	e0ffff17 	ldw	r3,-4(fp)
 3225234:	18800388 	cmpgei	r2,r3,14
 3225238:	10003b1e 	bne	r2,zero,3225328 <bsd_i_sockoptlen+0x1a0>
 322523c:	00003406 	br	3225310 <bsd_i_sockoptlen+0x188>
 3225240:	e0ffff17 	ldw	r3,-4(fp)
 3225244:	18800820 	cmpeqi	r2,r3,32
 3225248:	1000281e 	bne	r2,zero,32252ec <bsd_i_sockoptlen+0x164>
 322524c:	00003606 	br	3225328 <bsd_i_sockoptlen+0x1a0>
 3225250:	e0ffff17 	ldw	r3,-4(fp)
 3225254:	188401c8 	cmpgei	r2,r3,4103
 3225258:	10000e1e 	bne	r2,zero,3225294 <bsd_i_sockoptlen+0x10c>
 322525c:	e0ffff17 	ldw	r3,-4(fp)
 3225260:	18840148 	cmpgei	r2,r3,4101
 3225264:	10001e1e 	bne	r2,zero,32252e0 <bsd_i_sockoptlen+0x158>
 3225268:	e0ffff17 	ldw	r3,-4(fp)
 322526c:	18804020 	cmpeqi	r2,r3,256
 3225270:	10001e1e 	bne	r2,zero,32252ec <bsd_i_sockoptlen+0x164>
 3225274:	e0ffff17 	ldw	r3,-4(fp)
 3225278:	18804010 	cmplti	r2,r3,256
 322527c:	10002a1e 	bne	r2,zero,3225328 <bsd_i_sockoptlen+0x1a0>
 3225280:	e0ffff17 	ldw	r3,-4(fp)
 3225284:	18bbffc4 	addi	r2,r3,-4097
 3225288:	108000a8 	cmpgeui	r2,r2,2
 322528c:	1000261e 	bne	r2,zero,3225328 <bsd_i_sockoptlen+0x1a0>
 3225290:	00001606 	br	32252ec <bsd_i_sockoptlen+0x164>
 3225294:	e0ffff17 	ldw	r3,-4(fp)
 3225298:	18840588 	cmpgei	r2,r3,4118
 322529c:	1000071e 	bne	r2,zero,32252bc <bsd_i_sockoptlen+0x134>
 32252a0:	e0ffff17 	ldw	r3,-4(fp)
 32252a4:	18840508 	cmpgei	r2,r3,4116
 32252a8:	1000081e 	bne	r2,zero,32252cc <bsd_i_sockoptlen+0x144>
 32252ac:	e0ffff17 	ldw	r3,-4(fp)
 32252b0:	18840248 	cmpgei	r2,r3,4105
 32252b4:	10001c1e 	bne	r2,zero,3225328 <bsd_i_sockoptlen+0x1a0>
 32252b8:	00000c06 	br	32252ec <bsd_i_sockoptlen+0x164>
 32252bc:	e0ffff17 	ldw	r3,-4(fp)
 32252c0:	188405a0 	cmpeqi	r2,r3,4118
 32252c4:	1000091e 	bne	r2,zero,32252ec <bsd_i_sockoptlen+0x164>
 32252c8:	00001706 	br	3225328 <bsd_i_sockoptlen+0x1a0>
   {
   case SO_BIO:
   case SO_NBIO:
      /* these don't use an option value */
      return 0;
 32252cc:	e03ffe15 	stw	zero,-8(fp)
 32252d0:	00001606 	br	322532c <bsd_i_sockoptlen+0x1a4>
   case SO_LINGER:
      /* this option is a struct linger */
      return sizeof(struct linger);
 32252d4:	00800204 	movi	r2,8
 32252d8:	e0bffe15 	stw	r2,-8(fp)
 32252dc:	00001306 	br	322532c <bsd_i_sockoptlen+0x1a4>
   case SO_RCVTIMEO:
   case SO_SNDTIMEO:
      /* these options are type short */
      return sizeof(short);
 32252e0:	00c00084 	movi	r3,2
 32252e4:	e0fffe15 	stw	r3,-8(fp)
 32252e8:	00001006 	br	322532c <bsd_i_sockoptlen+0x1a4>
   case SO_RCVBUF:
   case SO_NONBLOCK:
   case SO_ERROR:
   case SO_TYPE:
      /* these options are type int */
      return sizeof(int);
 32252ec:	00800104 	movi	r2,4
 32252f0:	e0bffe15 	stw	r2,-8(fp)
 32252f4:	00000d06 	br	322532c <bsd_i_sockoptlen+0x1a4>
      return sizeof(int (*)());
#endif /* TCP_ZEROCOPY */
#ifdef IP_MULTICAST
   case IP_MULTICAST_IF:
      /* this option is type ip_addr */
      return sizeof(ip_addr);
 32252f8:	00c00104 	movi	r3,4
 32252fc:	e0fffe15 	stw	r3,-8(fp)
 3225300:	00000a06 	br	322532c <bsd_i_sockoptlen+0x1a4>
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      /* these options are type u_char */
      return sizeof(u_char);
 3225304:	00800044 	movi	r2,1
 3225308:	e0bffe15 	stw	r2,-8(fp)
 322530c:	00000706 	br	322532c <bsd_i_sockoptlen+0x1a4>
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      /* these options are struct ip_mreq */
      return sizeof(struct ip_mreq);
 3225310:	00c00204 	movi	r3,8
 3225314:	e0fffe15 	stw	r3,-8(fp)
 3225318:	00000406 	br	322532c <bsd_i_sockoptlen+0x1a4>
 * IP_TTL_OPT == SOREUSEADDR. This causes a build erro
 * due to duplicate cases. Removing this one. They both
 * return the same value (sizeof(int)).
 */
  // case IP_TTL_OPT:
      return sizeof(int);
 322531c:	00800104 	movi	r2,4
 3225320:	e0bffe15 	stw	r2,-8(fp)
 3225324:	00000106 	br	322532c <bsd_i_sockoptlen+0x1a4>
   default:
      /* we don't know what type these options are */
      return 0;
 3225328:	e03ffe15 	stw	zero,-8(fp)
 322532c:	e0bffe17 	ldw	r2,-8(fp)
   }
   
}
 3225330:	e037883a 	mov	sp,fp
 3225334:	df000017 	ldw	fp,0(sp)
 3225338:	dec00104 	addi	sp,sp,4
 322533c:	f800283a 	ret

03225340 <bsd_getsockopt>:
int
bsd_getsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int * optlen)
{
 3225340:	defff404 	addi	sp,sp,-48
 3225344:	dfc00b15 	stw	ra,44(sp)
 3225348:	df000a15 	stw	fp,40(sp)
 322534c:	df000a04 	addi	fp,sp,40
 3225350:	e13ffb15 	stw	r4,-20(fp)
 3225354:	e17ffc15 	stw	r5,-16(fp)
 3225358:	e1bffd15 	stw	r6,-12(fp)
 322535c:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;
   int loptlen;
   int e;

   so = LONG2SO(s);
 3225360:	e0bffb17 	ldw	r2,-20(fp)
 3225364:	10bff804 	addi	r2,r2,-32
 3225368:	1085883a 	add	r2,r2,r2
 322536c:	1085883a 	add	r2,r2,r2
 3225370:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 3225374:	0080c9b4 	movhi	r2,806
 3225378:	10b39704 	addi	r2,r2,-12708
 322537c:	e0bff715 	stw	r2,-36(fp)
 3225380:	00000606 	br	322539c <bsd_getsockopt+0x5c>
 3225384:	e0fff717 	ldw	r3,-36(fp)
 3225388:	e0bffa17 	ldw	r2,-24(fp)
 322538c:	18800626 	beq	r3,r2,32253a8 <bsd_getsockopt+0x68>
 3225390:	e0bff717 	ldw	r2,-36(fp)
 3225394:	10800017 	ldw	r2,0(r2)
 3225398:	e0bff715 	stw	r2,-36(fp)
 322539c:	e0bff717 	ldw	r2,-36(fp)
 32253a0:	1004c03a 	cmpne	r2,r2,zero
 32253a4:	103ff71e 	bne	r2,zero,3225384 <bsd_getsockopt+0x44>
 32253a8:	e0fff717 	ldw	r3,-36(fp)
 32253ac:	e0bffa17 	ldw	r2,-24(fp)
 32253b0:	18800426 	beq	r3,r2,32253c4 <bsd_getsockopt+0x84>
 32253b4:	322ab8c0 	call	322ab8c <dtrap>
 32253b8:	00bfffc4 	movi	r2,-1
 32253bc:	e0bfff15 	stw	r2,-4(fp)
 32253c0:	00002106 	br	3225448 <bsd_getsockopt+0x108>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   loptlen = bsd_i_sockoptlen(level, name);
 32253c4:	e13ffc17 	ldw	r4,-16(fp)
 32253c8:	e17ffd17 	ldw	r5,-12(fp)
 32253cc:	32251880 	call	3225188 <bsd_i_sockoptlen>
 32253d0:	e0bff915 	stw	r2,-28(fp)
   if ((optlen == NULL) || (*optlen < loptlen))
 32253d4:	e0800217 	ldw	r2,8(fp)
 32253d8:	1005003a 	cmpeq	r2,r2,zero
 32253dc:	1000041e 	bne	r2,zero,32253f0 <bsd_getsockopt+0xb0>
 32253e0:	e0800217 	ldw	r2,8(fp)
 32253e4:	10c00017 	ldw	r3,0(r2)
 32253e8:	e0bff917 	ldw	r2,-28(fp)
 32253ec:	1880060e 	bge	r3,r2,3225408 <bsd_getsockopt+0xc8>
   {
      so->so_error = EFAULT;
 32253f0:	e0fffa17 	ldw	r3,-24(fp)
 32253f4:	00800384 	movi	r2,14
 32253f8:	18800615 	stw	r2,24(r3)
      return -1;
 32253fc:	00bfffc4 	movi	r2,-1
 3225400:	e0bfff15 	stw	r2,-4(fp)
 3225404:	00001006 	br	3225448 <bsd_getsockopt+0x108>
   }

   e = t_getsockopt(s, level, name, opt, loptlen);
 3225408:	e0bff917 	ldw	r2,-28(fp)
 322540c:	d8800015 	stw	r2,0(sp)
 3225410:	e13ffb17 	ldw	r4,-20(fp)
 3225414:	e17ffc17 	ldw	r5,-16(fp)
 3225418:	e1bffd17 	ldw	r6,-12(fp)
 322541c:	e1fffe17 	ldw	r7,-8(fp)
 3225420:	322e8a00 	call	322e8a0 <t_getsockopt>
 3225424:	e0bff815 	stw	r2,-32(fp)

   /* if it worked, copy the option length back for the caller's use */
   if (e == 0)
 3225428:	e0bff817 	ldw	r2,-32(fp)
 322542c:	1004c03a 	cmpne	r2,r2,zero
 3225430:	1000031e 	bne	r2,zero,3225440 <bsd_getsockopt+0x100>
   {
      *optlen = loptlen;
 3225434:	e0c00217 	ldw	r3,8(fp)
 3225438:	e0bff917 	ldw	r2,-28(fp)
 322543c:	18800015 	stw	r2,0(r3)
   }

   return e;
 3225440:	e0bff817 	ldw	r2,-32(fp)
 3225444:	e0bfff15 	stw	r2,-4(fp)
 3225448:	e0bfff17 	ldw	r2,-4(fp)
   
}
 322544c:	e037883a 	mov	sp,fp
 3225450:	dfc00117 	ldw	ra,4(sp)
 3225454:	df000017 	ldw	fp,0(sp)
 3225458:	dec00204 	addi	sp,sp,8
 322545c:	f800283a 	ret

03225460 <bsd_ioctl>:
 *          available via bsd_errno(s).
 */
int
bsd_ioctl(BSD_SOCKET s, 
          unsigned long request, ...)
{
 3225460:	defff404 	addi	sp,sp,-48
 3225464:	dfc00915 	stw	ra,36(sp)
 3225468:	df000815 	stw	fp,32(sp)
 322546c:	df000804 	addi	fp,sp,32
 3225470:	e13ffd15 	stw	r4,-12(fp)
 3225474:	e1800215 	stw	r6,8(fp)
 3225478:	e1c00315 	stw	r7,12(fp)
 322547c:	e17ffe15 	stw	r5,-8(fp)
   struct socket * so;
   va_list argptr;
   int iarg;

   so = LONG2SO(s);
 3225480:	e0bffd17 	ldw	r2,-12(fp)
 3225484:	10bff804 	addi	r2,r2,-32
 3225488:	1085883a 	add	r2,r2,r2
 322548c:	1085883a 	add	r2,r2,r2
 3225490:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 3225494:	0080c9b4 	movhi	r2,806
 3225498:	10b39704 	addi	r2,r2,-12708
 322549c:	e0bff915 	stw	r2,-28(fp)
 32254a0:	00000606 	br	32254bc <bsd_ioctl+0x5c>
 32254a4:	e0fff917 	ldw	r3,-28(fp)
 32254a8:	e0bffa17 	ldw	r2,-24(fp)
 32254ac:	18800626 	beq	r3,r2,32254c8 <bsd_ioctl+0x68>
 32254b0:	e0bff917 	ldw	r2,-28(fp)
 32254b4:	10800017 	ldw	r2,0(r2)
 32254b8:	e0bff915 	stw	r2,-28(fp)
 32254bc:	e0bff917 	ldw	r2,-28(fp)
 32254c0:	1004c03a 	cmpne	r2,r2,zero
 32254c4:	103ff71e 	bne	r2,zero,32254a4 <bsd_ioctl+0x44>
 32254c8:	e0fff917 	ldw	r3,-28(fp)
 32254cc:	e0bffa17 	ldw	r2,-24(fp)
 32254d0:	18800426 	beq	r3,r2,32254e4 <bsd_ioctl+0x84>
 32254d4:	322ab8c0 	call	322ab8c <dtrap>
 32254d8:	00bfffc4 	movi	r2,-1
 32254dc:	e0bfff15 	stw	r2,-4(fp)
 32254e0:	00001a06 	br	322554c <bsd_ioctl+0xec>

   va_start(argptr, request);
 32254e4:	e0800204 	addi	r2,fp,8
 32254e8:	e0bffb15 	stw	r2,-20(fp)

   switch (request)
 32254ec:	e0bffe17 	ldw	r2,-8(fp)
 32254f0:	108405a0 	cmpeqi	r2,r2,4118
 32254f4:	1000011e 	bne	r2,zero,32254fc <bsd_ioctl+0x9c>
 32254f8:	00000f06 	br	3225538 <bsd_ioctl+0xd8>
   {
   case FIONBIO:
      iarg = va_arg(argptr, int);
 32254fc:	e0fffb17 	ldw	r3,-20(fp)
 3225500:	18800104 	addi	r2,r3,4
 3225504:	e0bffb15 	stw	r2,-20(fp)
 3225508:	1805883a 	mov	r2,r3
 322550c:	10800017 	ldw	r2,0(r2)
 3225510:	e0bffc15 	stw	r2,-16(fp)
      va_end(argptr);
      return t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, &iarg, sizeof(iarg));
 3225514:	e1fffc04 	addi	r7,fp,-16
 3225518:	00800104 	movi	r2,4
 322551c:	d8800015 	stw	r2,0(sp)
 3225520:	e13ffd17 	ldw	r4,-12(fp)
 3225524:	017fffc4 	movi	r5,-1
 3225528:	01840584 	movi	r6,4118
 322552c:	322e6c40 	call	322e6c4 <t_setsockopt>
 3225530:	e0bfff15 	stw	r2,-4(fp)
 3225534:	00000506 	br	322554c <bsd_ioctl+0xec>
   default:
      so->so_error = EINVAL;
 3225538:	e0fffa17 	ldw	r3,-24(fp)
 322553c:	00800584 	movi	r2,22
 3225540:	18800615 	stw	r2,24(r3)
      return -1;
 3225544:	00bfffc4 	movi	r2,-1
 3225548:	e0bfff15 	stw	r2,-4(fp)
 322554c:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 3225550:	e037883a 	mov	sp,fp
 3225554:	dfc00117 	ldw	ra,4(sp)
 3225558:	df000017 	ldw	fp,0(sp)
 322555c:	dec00404 	addi	sp,sp,16
 3225560:	f800283a 	ret

03225564 <bsd_inet_ntoa>:
 * RETURNS: pointer to null-terminated string containing dotted-decimal
 *          printable representation of in
 */
char *
bsd_inet_ntoa(struct in_addr in)
{
 3225564:	defffd04 	addi	sp,sp,-12
 3225568:	dfc00215 	stw	ra,8(sp)
 322556c:	df000115 	stw	fp,4(sp)
 3225570:	df000104 	addi	fp,sp,4
 3225574:	e13fff15 	stw	r4,-4(fp)
   return print_ipad(in.s_addr);
 3225578:	e13fff17 	ldw	r4,-4(fp)
 322557c:	3225c500 	call	3225c50 <print_ipad>
}
 3225580:	e037883a 	mov	sp,fp
 3225584:	dfc00117 	ldw	ra,4(sp)
 3225588:	df000017 	ldw	fp,0(sp)
 322558c:	dec00204 	addi	sp,sp,8
 3225590:	f800283a 	ret

03225594 <bsd_recvfrom>:
bsd_recvfrom(BSD_SOCKET s,
             void * buf,
             BSD_SIZE_T len,
             int flags,
             struct sockaddr * from, int * fromlen)
{
 3225594:	deffef04 	addi	sp,sp,-68
 3225598:	dfc01015 	stw	ra,64(sp)
 322559c:	df000f15 	stw	fp,60(sp)
 32255a0:	df000f04 	addi	fp,sp,60
 32255a4:	e13ffb15 	stw	r4,-20(fp)
 32255a8:	e17ffc15 	stw	r5,-16(fp)
 32255ac:	e1bffd15 	stw	r6,-12(fp)
 32255b0:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;
   struct sockaddr lfrom;
   int lfromlen = 0;
 32255b4:	e03ffa15 	stw	zero,-24(fp)
   int lret;

   so = LONG2SO(s);
 32255b8:	e0bffb17 	ldw	r2,-20(fp)
 32255bc:	10bff804 	addi	r2,r2,-32
 32255c0:	1085883a 	add	r2,r2,r2
 32255c4:	1085883a 	add	r2,r2,r2
 32255c8:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 32255cc:	0080c9b4 	movhi	r2,806
 32255d0:	10b39704 	addi	r2,r2,-12708
 32255d4:	e0bff315 	stw	r2,-52(fp)
 32255d8:	00000606 	br	32255f4 <bsd_recvfrom+0x60>
 32255dc:	e0fff317 	ldw	r3,-52(fp)
 32255e0:	e0bff517 	ldw	r2,-44(fp)
 32255e4:	18800626 	beq	r3,r2,3225600 <bsd_recvfrom+0x6c>
 32255e8:	e0bff317 	ldw	r2,-52(fp)
 32255ec:	10800017 	ldw	r2,0(r2)
 32255f0:	e0bff315 	stw	r2,-52(fp)
 32255f4:	e0bff317 	ldw	r2,-52(fp)
 32255f8:	1004c03a 	cmpne	r2,r2,zero
 32255fc:	103ff71e 	bne	r2,zero,32255dc <bsd_recvfrom+0x48>
 3225600:	e0fff317 	ldw	r3,-52(fp)
 3225604:	e0bff517 	ldw	r2,-44(fp)
 3225608:	18800426 	beq	r3,r2,322561c <bsd_recvfrom+0x88>
 322560c:	322ab8c0 	call	322ab8c <dtrap>
 3225610:	00bfffc4 	movi	r2,-1
 3225614:	e0bfff15 	stw	r2,-4(fp)
 3225618:	00003006 	br	32256dc <bsd_recvfrom+0x148>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (from != NULL)
 322561c:	e0800217 	ldw	r2,8(fp)
 3225620:	1005003a 	cmpeq	r2,r2,zero
 3225624:	10000c1e 	bne	r2,zero,3225658 <bsd_recvfrom+0xc4>
   {
      if (fromlen == NULL)
 3225628:	e0800317 	ldw	r2,12(fp)
 322562c:	1004c03a 	cmpne	r2,r2,zero
 3225630:	1000061e 	bne	r2,zero,322564c <bsd_recvfrom+0xb8>
      {
         so->so_error = EFAULT;
 3225634:	e0fff517 	ldw	r3,-44(fp)
 3225638:	00800384 	movi	r2,14
 322563c:	18800615 	stw	r2,24(r3)
         return -1;
 3225640:	00bfffc4 	movi	r2,-1
 3225644:	e0bfff15 	stw	r2,-4(fp)
 3225648:	00002406 	br	32256dc <bsd_recvfrom+0x148>
      }
      lfromlen = *fromlen;
 322564c:	e0800317 	ldw	r2,12(fp)
 3225650:	10800017 	ldw	r2,0(r2)
 3225654:	e0bffa15 	stw	r2,-24(fp)
   }

   lret = t_recvfrom(s, (char *)buf, len, flags, &lfrom, &lfromlen );
 3225658:	e17ffc17 	ldw	r5,-16(fp)
 322565c:	e0bff604 	addi	r2,fp,-40
 3225660:	d8800015 	stw	r2,0(sp)
 3225664:	e0bffa04 	addi	r2,fp,-24
 3225668:	d8800115 	stw	r2,4(sp)
 322566c:	e13ffb17 	ldw	r4,-20(fp)
 3225670:	e1bffd17 	ldw	r6,-12(fp)
 3225674:	e1fffe17 	ldw	r7,-8(fp)
 3225678:	322eb340 	call	322eb34 <t_recvfrom>
 322567c:	e0bff415 	stw	r2,-48(fp)
    * sockaddr_in), which is all that t_recvfrom() can return as a peer
    * name.
    * For IPV6 addresses or dual IPV4/IPV6 stack, the max size copied
    * is sizeof(struct sockaddr_in6)
    */
   if ((lret != -1) && (from != NULL))
 3225680:	e0bff417 	ldw	r2,-48(fp)
 3225684:	10bfffe0 	cmpeqi	r2,r2,-1
 3225688:	1000121e 	bne	r2,zero,32256d4 <bsd_recvfrom+0x140>
 322568c:	e0800217 	ldw	r2,8(fp)
 3225690:	1005003a 	cmpeq	r2,r2,zero
 3225694:	10000f1e 	bne	r2,zero,32256d4 <bsd_recvfrom+0x140>
   {
#ifndef IP_V6
      if (lfromlen > sizeof(struct sockaddr_in))
 3225698:	e0bffa17 	ldw	r2,-24(fp)
 322569c:	10800470 	cmpltui	r2,r2,17
 32256a0:	1000021e 	bne	r2,zero,32256ac <bsd_recvfrom+0x118>
         lfromlen = sizeof(struct sockaddr_in);
 32256a4:	00800404 	movi	r2,16
 32256a8:	e0bffa15 	stw	r2,-24(fp)
#else
      if (lfromlen > sizeof(struct sockaddr_in6))
         lfromlen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(from, &lfrom, lfromlen);
 32256ac:	e0bffa17 	ldw	r2,-24(fp)
 32256b0:	100d883a 	mov	r6,r2
 32256b4:	e0800217 	ldw	r2,8(fp)
 32256b8:	e0fff604 	addi	r3,fp,-40
 32256bc:	1009883a 	mov	r4,r2
 32256c0:	180b883a 	mov	r5,r3
 32256c4:	32067cc0 	call	32067cc <memcpy>
      *fromlen = lfromlen;
 32256c8:	e0fffa17 	ldw	r3,-24(fp)
 32256cc:	e0800317 	ldw	r2,12(fp)
 32256d0:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 32256d4:	e0bff417 	ldw	r2,-48(fp)
 32256d8:	e0bfff15 	stw	r2,-4(fp)
 32256dc:	e0bfff17 	ldw	r2,-4(fp)
}
 32256e0:	e037883a 	mov	sp,fp
 32256e4:	dfc00117 	ldw	ra,4(sp)
 32256e8:	df000017 	ldw	fp,0(sp)
 32256ec:	dec00204 	addi	sp,sp,8
 32256f0:	f800283a 	ret

032256f4 <bsd_select>:
bsd_select(int nfds,
           fd_set * readfds,
           fd_set * writefds,
           fd_set * exceptfds,
           BSD_TIMEVAL_T * timeout)
{
 32256f4:	defff804 	addi	sp,sp,-32
 32256f8:	dfc00715 	stw	ra,28(sp)
 32256fc:	df000615 	stw	fp,24(sp)
 3225700:	df000604 	addi	fp,sp,24
 3225704:	e13ffc15 	stw	r4,-16(fp)
 3225708:	e17ffd15 	stw	r5,-12(fp)
 322570c:	e1bffe15 	stw	r6,-8(fp)
 3225710:	e1ffff15 	stw	r7,-4(fp)
   long ltv;    /* timeout expressed in ticks */
   long tps;    /* local copy of TPS */

   USE_ARG(nfds);

   if (timeout != NULL)
 3225714:	e0800217 	ldw	r2,8(fp)
 3225718:	1005003a 	cmpeq	r2,r2,zero
 322571c:	1000431e 	bne	r2,zero,322582c <bsd_select+0x138>
       * million (i.e. any number of microseconds up to one second).
       * So we scale tv_usec from microseconds to something reasonable
       * based on TPS, multiply it by TPS, then scale it the rest of
       * the way to ticks-per-second.
       */
      tps = TPS;
 3225720:	0080fa04 	movi	r2,1000
 3225724:	e0bffa15 	stw	r2,-24(fp)
      if (tps >= 1000)
 3225728:	e0bffa17 	ldw	r2,-24(fp)
 322572c:	1080fa10 	cmplti	r2,r2,1000
 3225730:	10000c1e 	bne	r2,zero,3225764 <bsd_select+0x70>
      {
         ltv = (((timeout->tv_usec + 50) / 100) * tps) / 10000;
 3225734:	e0800217 	ldw	r2,8(fp)
 3225738:	10800117 	ldw	r2,4(r2)
 322573c:	11000c84 	addi	r4,r2,50
 3225740:	01401904 	movi	r5,100
 3225744:	32043fc0 	call	32043fc <__divsi3>
 3225748:	1007883a 	mov	r3,r2
 322574c:	e0bffa17 	ldw	r2,-24(fp)
 3225750:	1889383a 	mul	r4,r3,r2
 3225754:	0149c404 	movi	r5,10000
 3225758:	32043fc0 	call	32043fc <__divsi3>
 322575c:	e0bffb15 	stw	r2,-20(fp)
 3225760:	00002b06 	br	3225810 <bsd_select+0x11c>
      }
      else if (tps >= 100)
 3225764:	e0bffa17 	ldw	r2,-24(fp)
 3225768:	10801910 	cmplti	r2,r2,100
 322576c:	10000c1e 	bne	r2,zero,32257a0 <bsd_select+0xac>
      {
         ltv = (((timeout->tv_usec + 500) / 1000) * tps) / 1000;
 3225770:	e0800217 	ldw	r2,8(fp)
 3225774:	10800117 	ldw	r2,4(r2)
 3225778:	11007d04 	addi	r4,r2,500
 322577c:	0140fa04 	movi	r5,1000
 3225780:	32043fc0 	call	32043fc <__divsi3>
 3225784:	1007883a 	mov	r3,r2
 3225788:	e0bffa17 	ldw	r2,-24(fp)
 322578c:	1889383a 	mul	r4,r3,r2
 3225790:	0140fa04 	movi	r5,1000
 3225794:	32043fc0 	call	32043fc <__divsi3>
 3225798:	e0bffb15 	stw	r2,-20(fp)
 322579c:	00001c06 	br	3225810 <bsd_select+0x11c>
      }
      else if (tps >= 10)
 32257a0:	e0bffa17 	ldw	r2,-24(fp)
 32257a4:	10800290 	cmplti	r2,r2,10
 32257a8:	10000c1e 	bne	r2,zero,32257dc <bsd_select+0xe8>
      {
         ltv = (((timeout->tv_usec + 5000) / 10000) * tps) / 100;
 32257ac:	e0800217 	ldw	r2,8(fp)
 32257b0:	10800117 	ldw	r2,4(r2)
 32257b4:	1104e204 	addi	r4,r2,5000
 32257b8:	0149c404 	movi	r5,10000
 32257bc:	32043fc0 	call	32043fc <__divsi3>
 32257c0:	1007883a 	mov	r3,r2
 32257c4:	e0bffa17 	ldw	r2,-24(fp)
 32257c8:	1889383a 	mul	r4,r3,r2
 32257cc:	01401904 	movi	r5,100
 32257d0:	32043fc0 	call	32043fc <__divsi3>
 32257d4:	e0bffb15 	stw	r2,-20(fp)
 32257d8:	00000d06 	br	3225810 <bsd_select+0x11c>
      }
      else
      {
         ltv = (((timeout->tv_usec + 50000) / 100000) * tps) / 10;
 32257dc:	e0800217 	ldw	r2,8(fp)
 32257e0:	10c00117 	ldw	r3,4(r2)
 32257e4:	00b0d414 	movui	r2,50000
 32257e8:	1889883a 	add	r4,r3,r2
 32257ec:	014000b4 	movhi	r5,2
 32257f0:	2961a804 	addi	r5,r5,-31072
 32257f4:	32043fc0 	call	32043fc <__divsi3>
 32257f8:	1007883a 	mov	r3,r2
 32257fc:	e0bffa17 	ldw	r2,-24(fp)
 3225800:	1889383a 	mul	r4,r3,r2
 3225804:	01400284 	movi	r5,10
 3225808:	32043fc0 	call	32043fc <__divsi3>
 322580c:	e0bffb15 	stw	r2,-20(fp)
      }
      ltv += (timeout->tv_sec * TPS);
 3225810:	e0800217 	ldw	r2,8(fp)
 3225814:	10800017 	ldw	r2,0(r2)
 3225818:	10c0fa24 	muli	r3,r2,1000
 322581c:	e0bffb17 	ldw	r2,-20(fp)
 3225820:	1885883a 	add	r2,r3,r2
 3225824:	e0bffb15 	stw	r2,-20(fp)
 3225828:	00000206 	br	3225834 <bsd_select+0x140>
   }
   else {
      /*
       * NULL timeout: wait indefinitely in t_select()
       */
      ltv = -1;
 322582c:	00bfffc4 	movi	r2,-1
 3225830:	e0bffb15 	stw	r2,-20(fp)
   }

   return (t_select(readfds, writefds, exceptfds, ltv));
 3225834:	e13ffd17 	ldw	r4,-12(fp)
 3225838:	e17ffe17 	ldw	r5,-8(fp)
 322583c:	e1bfff17 	ldw	r6,-4(fp)
 3225840:	e1fffb17 	ldw	r7,-20(fp)
 3225844:	3232a4c0 	call	3232a4c <t_select>
}
 3225848:	e037883a 	mov	sp,fp
 322584c:	dfc00117 	ldw	ra,4(sp)
 3225850:	df000017 	ldw	fp,0(sp)
 3225854:	dec00204 	addi	sp,sp,8
 3225858:	f800283a 	ret

0322585c <bsd_setsockopt>:
int 
bsd_setsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int optlen)
{
 322585c:	defff604 	addi	sp,sp,-40
 3225860:	dfc00915 	stw	ra,36(sp)
 3225864:	df000815 	stw	fp,32(sp)
 3225868:	df000804 	addi	fp,sp,32
 322586c:	e13ffb15 	stw	r4,-20(fp)
 3225870:	e17ffc15 	stw	r5,-16(fp)
 3225874:	e1bffd15 	stw	r6,-12(fp)
 3225878:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;

   so = LONG2SO(s);
 322587c:	e0bffb17 	ldw	r2,-20(fp)
 3225880:	10bff804 	addi	r2,r2,-32
 3225884:	1085883a 	add	r2,r2,r2
 3225888:	1085883a 	add	r2,r2,r2
 322588c:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 3225890:	0080c9b4 	movhi	r2,806
 3225894:	10b39704 	addi	r2,r2,-12708
 3225898:	e0bff915 	stw	r2,-28(fp)
 322589c:	00000606 	br	32258b8 <bsd_setsockopt+0x5c>
 32258a0:	e0fff917 	ldw	r3,-28(fp)
 32258a4:	e0bffa17 	ldw	r2,-24(fp)
 32258a8:	18800626 	beq	r3,r2,32258c4 <bsd_setsockopt+0x68>
 32258ac:	e0bff917 	ldw	r2,-28(fp)
 32258b0:	10800017 	ldw	r2,0(r2)
 32258b4:	e0bff915 	stw	r2,-28(fp)
 32258b8:	e0bff917 	ldw	r2,-28(fp)
 32258bc:	1004c03a 	cmpne	r2,r2,zero
 32258c0:	103ff71e 	bne	r2,zero,32258a0 <bsd_setsockopt+0x44>
 32258c4:	e0fff917 	ldw	r3,-28(fp)
 32258c8:	e0bffa17 	ldw	r2,-24(fp)
 32258cc:	18800426 	beq	r3,r2,32258e0 <bsd_setsockopt+0x84>
 32258d0:	322ab8c0 	call	322ab8c <dtrap>
 32258d4:	00bfffc4 	movi	r2,-1
 32258d8:	e0bfff15 	stw	r2,-4(fp)
 32258dc:	00001406 	br	3225930 <bsd_setsockopt+0xd4>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   if (optlen < bsd_i_sockoptlen(level, name))
 32258e0:	e13ffc17 	ldw	r4,-16(fp)
 32258e4:	e17ffd17 	ldw	r5,-12(fp)
 32258e8:	32251880 	call	3225188 <bsd_i_sockoptlen>
 32258ec:	1007883a 	mov	r3,r2
 32258f0:	e0800217 	ldw	r2,8(fp)
 32258f4:	10c0060e 	bge	r2,r3,3225910 <bsd_setsockopt+0xb4>
   {
      so->so_error = EFAULT;
 32258f8:	e0fffa17 	ldw	r3,-24(fp)
 32258fc:	00800384 	movi	r2,14
 3225900:	18800615 	stw	r2,24(r3)
      return -1;
 3225904:	00bfffc4 	movi	r2,-1
 3225908:	e0bfff15 	stw	r2,-4(fp)
 322590c:	00000806 	br	3225930 <bsd_setsockopt+0xd4>
   }

   return t_setsockopt(s, level, name, opt, optlen);
 3225910:	e0800217 	ldw	r2,8(fp)
 3225914:	d8800015 	stw	r2,0(sp)
 3225918:	e13ffb17 	ldw	r4,-20(fp)
 322591c:	e17ffc17 	ldw	r5,-16(fp)
 3225920:	e1bffd17 	ldw	r6,-12(fp)
 3225924:	e1fffe17 	ldw	r7,-8(fp)
 3225928:	322e6c40 	call	322e6c4 <t_setsockopt>
 322592c:	e0bfff15 	stw	r2,-4(fp)
 3225930:	e0bfff17 	ldw	r2,-4(fp)
}
 3225934:	e037883a 	mov	sp,fp
 3225938:	dfc00117 	ldw	ra,4(sp)
 322593c:	df000017 	ldw	fp,0(sp)
 3225940:	dec00204 	addi	sp,sp,8
 3225944:	f800283a 	ret

03225948 <ccksum>:
 * be done in 16-bit chunks.
 */

unsigned short
ccksum (void *ptr, unsigned words)
{
 3225948:	defffa04 	addi	sp,sp,-24
 322594c:	df000515 	stw	fp,20(sp)
 3225950:	df000504 	addi	fp,sp,20
 3225954:	e13ffe15 	stw	r4,-8(fp)
 3225958:	e17fff15 	stw	r5,-4(fp)
   unsigned short *addr = (unsigned short *)ptr;
 322595c:	e0bffe17 	ldw	r2,-8(fp)
 3225960:	e0bffd15 	stw	r2,-12(fp)
   unsigned long sum = 0;
 3225964:	e03ffc15 	stw	zero,-16(fp)
   int count = (int)words;
 3225968:	e0bfff17 	ldw	r2,-4(fp)
 322596c:	e0bffb15 	stw	r2,-20(fp)

   while (--count >= 0)
 3225970:	00000906 	br	3225998 <ccksum+0x50>
   {
      /*  This is the inner loop */
      sum += *addr++;
 3225974:	e0bffd17 	ldw	r2,-12(fp)
 3225978:	1080000b 	ldhu	r2,0(r2)
 322597c:	10ffffcc 	andi	r3,r2,65535
 3225980:	e0bffc17 	ldw	r2,-16(fp)
 3225984:	10c5883a 	add	r2,r2,r3
 3225988:	e0bffc15 	stw	r2,-16(fp)
 322598c:	e0bffd17 	ldw	r2,-12(fp)
 3225990:	10800084 	addi	r2,r2,2
 3225994:	e0bffd15 	stw	r2,-12(fp)
{
   unsigned short *addr = (unsigned short *)ptr;
   unsigned long sum = 0;
   int count = (int)words;

   while (--count >= 0)
 3225998:	e0bffb17 	ldw	r2,-20(fp)
 322599c:	10bfffc4 	addi	r2,r2,-1
 32259a0:	e0bffb15 	stw	r2,-20(fp)
 32259a4:	e0bffb17 	ldw	r2,-20(fp)
 32259a8:	1004403a 	cmpge	r2,r2,zero
 32259ac:	103ff11e 	bne	r2,zero,3225974 <ccksum+0x2c>
      /*  This is the inner loop */
      sum += *addr++;
   }

   /*  Fold 32-bit sum to 16 bits */
   sum = (sum & 0xffff) + (sum >> 16);
 32259b0:	e0bffc17 	ldw	r2,-16(fp)
 32259b4:	10ffffcc 	andi	r3,r2,65535
 32259b8:	e0bffc17 	ldw	r2,-16(fp)
 32259bc:	1004d43a 	srli	r2,r2,16
 32259c0:	1885883a 	add	r2,r3,r2
 32259c4:	e0bffc15 	stw	r2,-16(fp)
   sum = (sum & 0xffff) + (sum >> 16);
 32259c8:	e0bffc17 	ldw	r2,-16(fp)
 32259cc:	10ffffcc 	andi	r3,r2,65535
 32259d0:	e0bffc17 	ldw	r2,-16(fp)
 32259d4:	1004d43a 	srli	r2,r2,16
 32259d8:	1885883a 	add	r2,r3,r2
 32259dc:	e0bffc15 	stw	r2,-16(fp)

   /* checksum = ~sum; *//* removed for MIT IP stack */
   return ((unsigned short)sum);
 32259e0:	e0bffc17 	ldw	r2,-16(fp)
 32259e4:	10bfffcc 	andi	r2,r2,65535
}
 32259e8:	e037883a 	mov	sp,fp
 32259ec:	df000017 	ldw	fp,0(sp)
 32259f0:	dec00104 	addi	sp,sp,4
 32259f4:	f800283a 	ret

032259f8 <cksum>:
 *    3 = user-supplied alternate implementation
 */

unsigned short
cksum (void *ptr, unsigned count)
{
 32259f8:	defffb04 	addi	sp,sp,-20
 32259fc:	dfc00415 	stw	ra,16(sp)
 3225a00:	df000315 	stw	fp,12(sp)
 3225a04:	df000304 	addi	fp,sp,12
 3225a08:	e13ffd15 	stw	r4,-12(fp)
 3225a0c:	e17ffe15 	stw	r5,-8(fp)
   switch (cksum_select)
 3225a10:	d0a02d17 	ldw	r2,-32588(gp)
 3225a14:	108000a0 	cmpeqi	r2,r2,2
 3225a18:	1000061e 	bne	r2,zero,3225a34 <cksum+0x3c>
   {
      case 1:
      default:
         return (ccksum(ptr, count));
 3225a1c:	e13ffd17 	ldw	r4,-12(fp)
 3225a20:	e17ffe17 	ldw	r5,-8(fp)
 3225a24:	32259480 	call	3225948 <ccksum>
 3225a28:	10bfffcc 	andi	r2,r2,65535
 3225a2c:	e0bfff15 	stw	r2,-4(fp)
 3225a30:	00000506 	br	3225a48 <cksum+0x50>
 #ifndef C_CHECKSUM
      case 2:
         return (asm_cksum(ptr, count));
 3225a34:	e13ffd17 	ldw	r4,-12(fp)
 3225a38:	e17ffe17 	ldw	r5,-8(fp)
 3225a3c:	322a9f80 	call	322a9f8 <asm_cksum>
 3225a40:	10bfffcc 	andi	r2,r2,65535
 3225a44:	e0bfff15 	stw	r2,-4(fp)
 3225a48:	e0bfff17 	ldw	r2,-4(fp)
#else
#endif
         return (alt_cksum(ptr, count));
#endif
   }
}
 3225a4c:	e037883a 	mov	sp,fp
 3225a50:	dfc00117 	ldw	ra,4(sp)
 3225a54:	df000017 	ldw	fp,0(sp)
 3225a58:	dec00204 	addi	sp,sp,8
 3225a5c:	f800283a 	ret

03225a60 <do_trap>:
 * RETURNS: 0
 */

int
do_trap(void)
{
 3225a60:	defffe04 	addi	sp,sp,-8
 3225a64:	dfc00115 	stw	ra,4(sp)
 3225a68:	df000015 	stw	fp,0(sp)
 3225a6c:	d839883a 	mov	fp,sp
   dtrap();
 3225a70:	322ab8c0 	call	322ab8c <dtrap>
   return 0;
 3225a74:	0005883a 	mov	r2,zero
}
 3225a78:	e037883a 	mov	sp,fp
 3225a7c:	dfc00117 	ldw	ra,4(sp)
 3225a80:	df000017 	ldw	fp,0(sp)
 3225a84:	dec00204 	addi	sp,sp,8
 3225a88:	f800283a 	ret

03225a8c <nextarg>:
 * RETURNS:  pointer to next arg in string 
 */

char *   
nextarg(char * argp)
{
 3225a8c:	defffe04 	addi	sp,sp,-8
 3225a90:	df000115 	stw	fp,4(sp)
 3225a94:	df000104 	addi	fp,sp,4
 3225a98:	e13fff15 	stw	r4,-4(fp)
   while (*argp > ' ')argp++; /* scan past current arg */
 3225a9c:	00000306 	br	3225aac <nextarg+0x20>
 3225aa0:	e0bfff17 	ldw	r2,-4(fp)
 3225aa4:	10800044 	addi	r2,r2,1
 3225aa8:	e0bfff15 	stw	r2,-4(fp)
 3225aac:	e0bfff17 	ldw	r2,-4(fp)
 3225ab0:	10800003 	ldbu	r2,0(r2)
 3225ab4:	10803fcc 	andi	r2,r2,255
 3225ab8:	1080201c 	xori	r2,r2,128
 3225abc:	10bfe004 	addi	r2,r2,-128
 3225ac0:	10800848 	cmpgei	r2,r2,33
 3225ac4:	103ff61e 	bne	r2,zero,3225aa0 <nextarg+0x14>
      while (*argp == ' ')argp++;   /* scan past spaces */
 3225ac8:	00000306 	br	3225ad8 <nextarg+0x4c>
 3225acc:	e0bfff17 	ldw	r2,-4(fp)
 3225ad0:	10800044 	addi	r2,r2,1
 3225ad4:	e0bfff15 	stw	r2,-4(fp)
 3225ad8:	e0bfff17 	ldw	r2,-4(fp)
 3225adc:	10800003 	ldbu	r2,0(r2)
 3225ae0:	10803fcc 	andi	r2,r2,255
 3225ae4:	1080201c 	xori	r2,r2,128
 3225ae8:	10bfe004 	addi	r2,r2,-128
 3225aec:	10800820 	cmpeqi	r2,r2,32
 3225af0:	103ff61e 	bne	r2,zero,3225acc <nextarg+0x40>
      return (argp);
 3225af4:	e0bfff17 	ldw	r2,-4(fp)
}
 3225af8:	e037883a 	mov	sp,fp
 3225afc:	df000017 	ldw	fp,0(sp)
 3225b00:	dec00104 	addi	sp,sp,4
 3225b04:	f800283a 	ret

03225b08 <hexdump>:

#define  HEX_BYTES_PER_LINE   16

void
hexdump(void * pio, void * buffer, unsigned len)
{
 3225b08:	defff704 	addi	sp,sp,-36
 3225b0c:	dfc00815 	stw	ra,32(sp)
 3225b10:	df000715 	stw	fp,28(sp)
 3225b14:	df000704 	addi	fp,sp,28
 3225b18:	e13ffc15 	stw	r4,-16(fp)
 3225b1c:	e17ffd15 	stw	r5,-12(fp)
 3225b20:	e1bffe15 	stw	r6,-8(fp)
   u_char * data  =  (u_char *)buffer;
 3225b24:	e0bffd17 	ldw	r2,-12(fp)
 3225b28:	e0bffb15 	stw	r2,-20(fp)
   unsigned int count;
   char  c;

   while (len)
 3225b2c:	00004006 	br	3225c30 <hexdump+0x128>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 3225b30:	e03ffa15 	stw	zero,-24(fp)
 3225b34:	00000c06 	br	3225b68 <hexdump+0x60>
         ns_printf(pio, "%02x ", *(data + count));
 3225b38:	e0fffa17 	ldw	r3,-24(fp)
 3225b3c:	e0bffb17 	ldw	r2,-20(fp)
 3225b40:	1885883a 	add	r2,r3,r2
 3225b44:	10800003 	ldbu	r2,0(r2)
 3225b48:	11803fcc 	andi	r6,r2,255
 3225b4c:	e13ffc17 	ldw	r4,-16(fp)
 3225b50:	0140c974 	movhi	r5,805
 3225b54:	297b4404 	addi	r5,r5,-4848
 3225b58:	32260180 	call	3226018 <ns_printf>
   char  c;

   while (len)
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 3225b5c:	e0bffa17 	ldw	r2,-24(fp)
 3225b60:	10800044 	addi	r2,r2,1
 3225b64:	e0bffa15 	stw	r2,-24(fp)
 3225b68:	e0bffa17 	ldw	r2,-24(fp)
 3225b6c:	10800428 	cmpgeui	r2,r2,16
 3225b70:	1000031e 	bne	r2,zero,3225b80 <hexdump+0x78>
 3225b74:	e0fffa17 	ldw	r3,-24(fp)
 3225b78:	e0bffe17 	ldw	r2,-8(fp)
 3225b7c:	18bfee36 	bltu	r3,r2,3225b38 <hexdump+0x30>
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 3225b80:	e03ffa15 	stw	zero,-24(fp)
 3225b84:	00001806 	br	3225be8 <hexdump+0xe0>
      {
         c = *(data + count);
 3225b88:	e0fffa17 	ldw	r3,-24(fp)
 3225b8c:	e0bffb17 	ldw	r2,-20(fp)
 3225b90:	1885883a 	add	r2,r3,r2
 3225b94:	10800003 	ldbu	r2,0(r2)
 3225b98:	e0bff905 	stb	r2,-28(fp)
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
 3225b9c:	e0bff907 	ldb	r2,-28(fp)
 3225ba0:	10800810 	cmplti	r2,r2,32
 3225ba4:	1000061e 	bne	r2,zero,3225bc0 <hexdump+0xb8>
 3225ba8:	e0bff907 	ldb	r2,-28(fp)
 3225bac:	10801fe0 	cmpeqi	r2,r2,127
 3225bb0:	1000031e 	bne	r2,zero,3225bc0 <hexdump+0xb8>
 3225bb4:	e0bff907 	ldb	r2,-28(fp)
 3225bb8:	e0bfff15 	stw	r2,-4(fp)
 3225bbc:	00000206 	br	3225bc8 <hexdump+0xc0>
 3225bc0:	00800b84 	movi	r2,46
 3225bc4:	e0bfff15 	stw	r2,-4(fp)
 3225bc8:	e13ffc17 	ldw	r4,-16(fp)
 3225bcc:	0140c974 	movhi	r5,805
 3225bd0:	297b4604 	addi	r5,r5,-4840
 3225bd4:	e1bfff17 	ldw	r6,-4(fp)
 3225bd8:	32260180 	call	3226018 <ns_printf>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 3225bdc:	e0bffa17 	ldw	r2,-24(fp)
 3225be0:	10800044 	addi	r2,r2,1
 3225be4:	e0bffa15 	stw	r2,-24(fp)
 3225be8:	e0bffa17 	ldw	r2,-24(fp)
 3225bec:	10800428 	cmpgeui	r2,r2,16
 3225bf0:	1000031e 	bne	r2,zero,3225c00 <hexdump+0xf8>
 3225bf4:	e0fffa17 	ldw	r3,-24(fp)
 3225bf8:	e0bffe17 	ldw	r2,-8(fp)
 3225bfc:	18bfe236 	bltu	r3,r2,3225b88 <hexdump+0x80>
      {
         c = *(data + count);
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
      }
      ns_printf(pio,"\n");
 3225c00:	e13ffc17 	ldw	r4,-16(fp)
 3225c04:	0140c974 	movhi	r5,805
 3225c08:	297b4704 	addi	r5,r5,-4836
 3225c0c:	32260180 	call	3226018 <ns_printf>
      len -= count;
 3225c10:	e0fffe17 	ldw	r3,-8(fp)
 3225c14:	e0bffa17 	ldw	r2,-24(fp)
 3225c18:	1885c83a 	sub	r2,r3,r2
 3225c1c:	e0bffe15 	stw	r2,-8(fp)
      data += count;
 3225c20:	e0fffa17 	ldw	r3,-24(fp)
 3225c24:	e0bffb17 	ldw	r2,-20(fp)
 3225c28:	10c5883a 	add	r2,r2,r3
 3225c2c:	e0bffb15 	stw	r2,-20(fp)
{
   u_char * data  =  (u_char *)buffer;
   unsigned int count;
   char  c;

   while (len)
 3225c30:	e0bffe17 	ldw	r2,-8(fp)
 3225c34:	1004c03a 	cmpne	r2,r2,zero
 3225c38:	103fbd1e 	bne	r2,zero,3225b30 <hexdump+0x28>
      }
      ns_printf(pio,"\n");
      len -= count;
      data += count;
   }
}
 3225c3c:	e037883a 	mov	sp,fp
 3225c40:	dfc00117 	ldw	ra,4(sp)
 3225c44:	df000017 	ldw	fp,0(sp)
 3225c48:	dec00204 	addi	sp,sp,8
 3225c4c:	f800283a 	ret

03225c50 <print_ipad>:

char     ipreturn[18];     /* buffer for return */

char *   
print_ipad(unsigned long ipaddr)
{
 3225c50:	defffa04 	addi	sp,sp,-24
 3225c54:	dfc00515 	stw	ra,20(sp)
 3225c58:	df000415 	stw	fp,16(sp)
 3225c5c:	df000404 	addi	fp,sp,16
 3225c60:	e13fff15 	stw	r4,-4(fp)
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
 3225c64:	e0bfff17 	ldw	r2,-4(fp)
 3225c68:	e0bffe15 	stw	r2,-8(fp)
   sprintf(ipreturn, "%u.%u.%u.%u", 
 3225c6c:	e0bffe03 	ldbu	r2,-8(fp)
 3225c70:	11803fcc 	andi	r6,r2,255
 3225c74:	e0bffe43 	ldbu	r2,-7(fp)
 3225c78:	11c03fcc 	andi	r7,r2,255
 3225c7c:	e0bffe83 	ldbu	r2,-6(fp)
 3225c80:	10c03fcc 	andi	r3,r2,255
 3225c84:	e0bffec3 	ldbu	r2,-5(fp)
 3225c88:	10803fcc 	andi	r2,r2,255
 3225c8c:	d8c00015 	stw	r3,0(sp)
 3225c90:	d8800115 	stw	r2,4(sp)
 3225c94:	0100c9b4 	movhi	r4,806
 3225c98:	21327b84 	addi	r4,r4,-13842
 3225c9c:	0140c974 	movhi	r5,805
 3225ca0:	297b4804 	addi	r5,r5,-4832
 3225ca4:	32076bc0 	call	32076bc <sprintf>
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);

   return ipreturn;
 3225ca8:	0080c9b4 	movhi	r2,806
 3225cac:	10b27b84 	addi	r2,r2,-13842
}
 3225cb0:	e037883a 	mov	sp,fp
 3225cb4:	dfc00117 	ldw	ra,4(sp)
 3225cb8:	df000017 	ldw	fp,0(sp)
 3225cbc:	dec00204 	addi	sp,sp,8
 3225cc0:	f800283a 	ret

03225cc4 <print_uptime>:

static char tistring[24];     /* buffer for return */

char *   
print_uptime(unsigned long timetick)
{
 3225cc4:	defff804 	addi	sp,sp,-32
 3225cc8:	dfc00715 	stw	ra,28(sp)
 3225ccc:	df000615 	stw	fp,24(sp)
 3225cd0:	df000604 	addi	fp,sp,24
 3225cd4:	e13fff15 	stw	r4,-4(fp)
   unsigned seconds, minutes, hours;

   timetick = timetick/100;   /* turn timetick into seconds */
 3225cd8:	e13fff17 	ldw	r4,-4(fp)
 3225cdc:	01401904 	movi	r5,100
 3225ce0:	32044bc0 	call	32044bc <__udivsi3>
 3225ce4:	e0bfff15 	stw	r2,-4(fp)
   seconds = (unsigned)(timetick%60);
 3225ce8:	e13fff17 	ldw	r4,-4(fp)
 3225cec:	01400f04 	movi	r5,60
 3225cf0:	32044c40 	call	32044c4 <__umodsi3>
 3225cf4:	e0bffe15 	stw	r2,-8(fp)
   timetick = timetick/60;    /* turn timetick into minutes */
 3225cf8:	e13fff17 	ldw	r4,-4(fp)
 3225cfc:	01400f04 	movi	r5,60
 3225d00:	32044bc0 	call	32044bc <__udivsi3>
 3225d04:	e0bfff15 	stw	r2,-4(fp)
   minutes = (unsigned)(timetick%60);
 3225d08:	e13fff17 	ldw	r4,-4(fp)
 3225d0c:	01400f04 	movi	r5,60
 3225d10:	32044c40 	call	32044c4 <__umodsi3>
 3225d14:	e0bffd15 	stw	r2,-12(fp)
   timetick = timetick/60;    /* turn timetick into hours */
 3225d18:	e13fff17 	ldw	r4,-4(fp)
 3225d1c:	01400f04 	movi	r5,60
 3225d20:	32044bc0 	call	32044bc <__udivsi3>
 3225d24:	e0bfff15 	stw	r2,-4(fp)
   hours = (unsigned)(timetick%24);
 3225d28:	e13fff17 	ldw	r4,-4(fp)
 3225d2c:	01400604 	movi	r5,24
 3225d30:	32044c40 	call	32044c4 <__umodsi3>
 3225d34:	e0bffc15 	stw	r2,-16(fp)
   timetick = timetick/24;    /* turn timetick into days */
 3225d38:	e13fff17 	ldw	r4,-4(fp)
 3225d3c:	01400604 	movi	r5,24
 3225d40:	32044bc0 	call	32044bc <__udivsi3>
 3225d44:	e0bfff15 	stw	r2,-4(fp)

   if (timetick)  /* Is there a whole number of days? */
 3225d48:	e0bfff17 	ldw	r2,-4(fp)
 3225d4c:	1005003a 	cmpeq	r2,r2,zero
 3225d50:	10000c1e 	bne	r2,zero,3225d84 <print_uptime+0xc0>
      sprintf(tistring, "%ld days, %dh:%dm:%ds", 
 3225d54:	e0bffd17 	ldw	r2,-12(fp)
 3225d58:	d8800015 	stw	r2,0(sp)
 3225d5c:	e0bffe17 	ldw	r2,-8(fp)
 3225d60:	d8800115 	stw	r2,4(sp)
 3225d64:	0100c974 	movhi	r4,805
 3225d68:	2114a904 	addi	r4,r4,21156
 3225d6c:	0140c974 	movhi	r5,805
 3225d70:	297b4b04 	addi	r5,r5,-4820
 3225d74:	e1bfff17 	ldw	r6,-4(fp)
 3225d78:	e1fffc17 	ldw	r7,-16(fp)
 3225d7c:	32076bc0 	call	32076bc <sprintf>
 3225d80:	00001406 	br	3225dd4 <print_uptime+0x110>
    timetick, hours, minutes, seconds);
   else if (hours)
 3225d84:	e0bffc17 	ldw	r2,-16(fp)
 3225d88:	1005003a 	cmpeq	r2,r2,zero
 3225d8c:	10000a1e 	bne	r2,zero,3225db8 <print_uptime+0xf4>
      sprintf(tistring, "%d hours, %dm:%ds", hours, minutes, seconds);
 3225d90:	e0bffe17 	ldw	r2,-8(fp)
 3225d94:	d8800015 	stw	r2,0(sp)
 3225d98:	0100c974 	movhi	r4,805
 3225d9c:	2114a904 	addi	r4,r4,21156
 3225da0:	0140c974 	movhi	r5,805
 3225da4:	297b5104 	addi	r5,r5,-4796
 3225da8:	e1bffc17 	ldw	r6,-16(fp)
 3225dac:	e1fffd17 	ldw	r7,-12(fp)
 3225db0:	32076bc0 	call	32076bc <sprintf>
 3225db4:	00000706 	br	3225dd4 <print_uptime+0x110>
   else
      sprintf(tistring, "%d minutes, %d sec.", minutes, seconds);
 3225db8:	0100c974 	movhi	r4,805
 3225dbc:	2114a904 	addi	r4,r4,21156
 3225dc0:	0140c974 	movhi	r5,805
 3225dc4:	297b5604 	addi	r5,r5,-4776
 3225dc8:	e1bffd17 	ldw	r6,-12(fp)
 3225dcc:	e1fffe17 	ldw	r7,-8(fp)
 3225dd0:	32076bc0 	call	32076bc <sprintf>
   return tistring;
 3225dd4:	0080c974 	movhi	r2,805
 3225dd8:	1094a904 	addi	r2,r2,21156
}
 3225ddc:	e037883a 	mov	sp,fp
 3225de0:	dfc00117 	ldw	ra,4(sp)
 3225de4:	df000017 	ldw	fp,0(sp)
 3225de8:	dec00204 	addi	sp,sp,8
 3225dec:	f800283a 	ret

03225df0 <panic>:
/* allow to be ifdeffed out on systems which already have a panic */
#ifndef PANIC_ALREADY

void
panic(char * msg)
{
 3225df0:	defffd04 	addi	sp,sp,-12
 3225df4:	dfc00215 	stw	ra,8(sp)
 3225df8:	df000115 	stw	fp,4(sp)
 3225dfc:	df000104 	addi	fp,sp,4
 3225e00:	e13fff15 	stw	r4,-4(fp)
   dprintf("panic: %s\n", msg);
 3225e04:	0100c974 	movhi	r4,805
 3225e08:	213b5b04 	addi	r4,r4,-4756
 3225e0c:	e17fff17 	ldw	r5,-4(fp)
 3225e10:	3206adc0 	call	3206adc <printf>
   dtrap();                   /* try to hook debugger */
 3225e14:	322ab8c0 	call	322ab8c <dtrap>
   netexit(1);                /* try to clean up */
 3225e18:	01000044 	movi	r4,1
 3225e1c:	32437f00 	call	32437f0 <netexit>
}
 3225e20:	e037883a 	mov	sp,fp
 3225e24:	dfc00117 	ldw	ra,4(sp)
 3225e28:	df000017 	ldw	fp,0(sp)
 3225e2c:	dec00204 	addi	sp,sp,8
 3225e30:	f800283a 	ret

03225e34 <print_eth>:

char     eth_prt_buf[18];  /* buffer for return */

char *   
print_eth(char * addr, char spacer)
{
 3225e34:	defffb04 	addi	sp,sp,-20
 3225e38:	df000415 	stw	fp,16(sp)
 3225e3c:	df000404 	addi	fp,sp,16
 3225e40:	e13ffe15 	stw	r4,-8(fp)
 3225e44:	e17fff05 	stb	r5,-4(fp)
   int   i;
   char *   out   =  eth_prt_buf;
 3225e48:	0080c9b4 	movhi	r2,806
 3225e4c:	10b27704 	addi	r2,r2,-13860
 3225e50:	e0bffc15 	stw	r2,-16(fp)

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 3225e54:	e03ffd15 	stw	zero,-12(fp)
 3225e58:	00004406 	br	3225f6c <print_eth+0x138>
   {
      /* high nibble */
      *out = (char)(((*addr >> 4) & 0x0f) + 0x30);
 3225e5c:	e0bffe17 	ldw	r2,-8(fp)
 3225e60:	10800003 	ldbu	r2,0(r2)
 3225e64:	10803fcc 	andi	r2,r2,255
 3225e68:	1080201c 	xori	r2,r2,128
 3225e6c:	10bfe004 	addi	r2,r2,-128
 3225e70:	1005d13a 	srai	r2,r2,4
 3225e74:	108003cc 	andi	r2,r2,15
 3225e78:	10800c04 	addi	r2,r2,48
 3225e7c:	1007883a 	mov	r3,r2
 3225e80:	e0bffc17 	ldw	r2,-16(fp)
 3225e84:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 3225e88:	e0bffc17 	ldw	r2,-16(fp)
 3225e8c:	10800003 	ldbu	r2,0(r2)
 3225e90:	10803fcc 	andi	r2,r2,255
 3225e94:	1080201c 	xori	r2,r2,128
 3225e98:	10bfe004 	addi	r2,r2,-128
 3225e9c:	10800e90 	cmplti	r2,r2,58
 3225ea0:	1000061e 	bne	r2,zero,3225ebc <print_eth+0x88>
         (*out) += 7;
 3225ea4:	e0bffc17 	ldw	r2,-16(fp)
 3225ea8:	10800003 	ldbu	r2,0(r2)
 3225eac:	108001c4 	addi	r2,r2,7
 3225eb0:	1007883a 	mov	r3,r2
 3225eb4:	e0bffc17 	ldw	r2,-16(fp)
 3225eb8:	10c00005 	stb	r3,0(r2)
      out++;
 3225ebc:	e0bffc17 	ldw	r2,-16(fp)
 3225ec0:	10800044 	addi	r2,r2,1
 3225ec4:	e0bffc15 	stw	r2,-16(fp)

      /* low nibble */
      *out = (char)((*addr & 0x0f) + 0x30);  /* low nibble to digit */
 3225ec8:	e0bffe17 	ldw	r2,-8(fp)
 3225ecc:	10800003 	ldbu	r2,0(r2)
 3225ed0:	108003cc 	andi	r2,r2,15
 3225ed4:	10800c04 	addi	r2,r2,48
 3225ed8:	1007883a 	mov	r3,r2
 3225edc:	e0bffc17 	ldw	r2,-16(fp)
 3225ee0:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 3225ee4:	e0bffc17 	ldw	r2,-16(fp)
 3225ee8:	10800003 	ldbu	r2,0(r2)
 3225eec:	10803fcc 	andi	r2,r2,255
 3225ef0:	1080201c 	xori	r2,r2,128
 3225ef4:	10bfe004 	addi	r2,r2,-128
 3225ef8:	10800e90 	cmplti	r2,r2,58
 3225efc:	1000061e 	bne	r2,zero,3225f18 <print_eth+0xe4>
         (*out) += 7;   /* eg 0x3a -> 0x41 ('A') */
 3225f00:	e0bffc17 	ldw	r2,-16(fp)
 3225f04:	10800003 	ldbu	r2,0(r2)
 3225f08:	108001c4 	addi	r2,r2,7
 3225f0c:	1007883a 	mov	r3,r2
 3225f10:	e0bffc17 	ldw	r2,-16(fp)
 3225f14:	10c00005 	stb	r3,0(r2)
      out++;
 3225f18:	e0bffc17 	ldw	r2,-16(fp)
 3225f1c:	10800044 	addi	r2,r2,1
 3225f20:	e0bffc15 	stw	r2,-16(fp)

      /* optional spacer character */
      if (spacer && i < 5)
 3225f24:	e0bfff07 	ldb	r2,-4(fp)
 3225f28:	1005003a 	cmpeq	r2,r2,zero
 3225f2c:	1000091e 	bne	r2,zero,3225f54 <print_eth+0x120>
 3225f30:	e0bffd17 	ldw	r2,-12(fp)
 3225f34:	10800148 	cmpgei	r2,r2,5
 3225f38:	1000061e 	bne	r2,zero,3225f54 <print_eth+0x120>
         *out++ = spacer;
 3225f3c:	e0fffc17 	ldw	r3,-16(fp)
 3225f40:	e0bfff03 	ldbu	r2,-4(fp)
 3225f44:	18800005 	stb	r2,0(r3)
 3225f48:	e0bffc17 	ldw	r2,-16(fp)
 3225f4c:	10800044 	addi	r2,r2,1
 3225f50:	e0bffc15 	stw	r2,-16(fp)
      addr++;
 3225f54:	e0bffe17 	ldw	r2,-8(fp)
 3225f58:	10800044 	addi	r2,r2,1
 3225f5c:	e0bffe15 	stw	r2,-8(fp)
{
   int   i;
   char *   out   =  eth_prt_buf;

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 3225f60:	e0bffd17 	ldw	r2,-12(fp)
 3225f64:	10800044 	addi	r2,r2,1
 3225f68:	e0bffd15 	stw	r2,-12(fp)
 3225f6c:	e0bffd17 	ldw	r2,-12(fp)
 3225f70:	10800190 	cmplti	r2,r2,6
 3225f74:	103fb91e 	bne	r2,zero,3225e5c <print_eth+0x28>
      /* optional spacer character */
      if (spacer && i < 5)
         *out++ = spacer;
      addr++;
   }
   *out = 0;
 3225f78:	e0bffc17 	ldw	r2,-16(fp)
 3225f7c:	10000005 	stb	zero,0(r2)
   return eth_prt_buf;
 3225f80:	0080c9b4 	movhi	r2,806
 3225f84:	10b27704 	addi	r2,r2,-13860
}
 3225f88:	e037883a 	mov	sp,fp
 3225f8c:	df000017 	ldw	fp,0(sp)
 3225f90:	dec00104 	addi	sp,sp,4
 3225f94:	f800283a 	ret

03225f98 <uslash>:
 * RETURNS:  pointer to formatted text
 */

char *   
uslash(char * path)
{
 3225f98:	defffd04 	addi	sp,sp,-12
 3225f9c:	df000215 	stw	fp,8(sp)
 3225fa0:	df000204 	addi	fp,sp,8
 3225fa4:	e13fff15 	stw	r4,-4(fp)
   char *   cp;

   for (cp = path; *cp; cp++)
 3225fa8:	e0bfff17 	ldw	r2,-4(fp)
 3225fac:	e0bffe15 	stw	r2,-8(fp)
 3225fb0:	00000d06 	br	3225fe8 <uslash+0x50>
      if (*cp == '\\')
 3225fb4:	e0bffe17 	ldw	r2,-8(fp)
 3225fb8:	10800003 	ldbu	r2,0(r2)
 3225fbc:	10803fcc 	andi	r2,r2,255
 3225fc0:	1080201c 	xori	r2,r2,128
 3225fc4:	10bfe004 	addi	r2,r2,-128
 3225fc8:	10801718 	cmpnei	r2,r2,92
 3225fcc:	1000031e 	bne	r2,zero,3225fdc <uslash+0x44>
      *cp = '/';
 3225fd0:	e0fffe17 	ldw	r3,-8(fp)
 3225fd4:	00800bc4 	movi	r2,47
 3225fd8:	18800005 	stb	r2,0(r3)
char *   
uslash(char * path)
{
   char *   cp;

   for (cp = path; *cp; cp++)
 3225fdc:	e0bffe17 	ldw	r2,-8(fp)
 3225fe0:	10800044 	addi	r2,r2,1
 3225fe4:	e0bffe15 	stw	r2,-8(fp)
 3225fe8:	e0bffe17 	ldw	r2,-8(fp)
 3225fec:	10800003 	ldbu	r2,0(r2)
 3225ff0:	10803fcc 	andi	r2,r2,255
 3225ff4:	1080201c 	xori	r2,r2,128
 3225ff8:	10bfe004 	addi	r2,r2,-128
 3225ffc:	1004c03a 	cmpne	r2,r2,zero
 3226000:	103fec1e 	bne	r2,zero,3225fb4 <uslash+0x1c>
      if (*cp == '\\')
      *cp = '/';
   return path;
 3226004:	e0bfff17 	ldw	r2,-4(fp)
}
 3226008:	e037883a 	mov	sp,fp
 322600c:	df000017 	ldw	fp,0(sp)
 3226010:	dec00104 	addi	sp,sp,4
 3226014:	f800283a 	ret

03226018 <ns_printf>:
 */
#ifndef ns_printf

int 
ns_printf(void * vio, char * format, ...)
{
 3226018:	defff204 	addi	sp,sp,-56
 322601c:	dfc00b15 	stw	ra,44(sp)
 3226020:	df000a15 	stw	fp,40(sp)
 3226024:	dc400915 	stw	r17,36(sp)
 3226028:	dc000815 	stw	r16,32(sp)
 322602c:	df000804 	addi	fp,sp,32
 3226030:	e13ffd15 	stw	r4,-12(fp)
 3226034:	e1800415 	stw	r6,16(fp)
 3226038:	e1c00515 	stw	r7,20(fp)
 322603c:	e17ffe15 	stw	r5,-8(fp)
   char *   outbuf=NULL;
 3226040:	e03ffb15 	stw	zero,-20(fp)
   int   ret_value   ;
   int   buf_size =  MAXIOSIZE   ;
 3226044:	00802704 	movi	r2,156
 3226048:	e0bff915 	stw	r2,-28(fp)
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 322604c:	e0bffd17 	ldw	r2,-12(fp)
 3226050:	e0bff815 	stw	r2,-32(fp)
   int * next_arg=(int *)  &format;
   next_arg +=  sizeof(char *)/sizeof(int) ;
#endif   /* NATIVE_PRINTF || PRINTF_STRING */

   /* a NULL pio means just dump the output to stdout */
   if (pio == NULL)
 3226054:	e0bff817 	ldw	r2,-32(fp)
 3226058:	1004c03a 	cmpne	r2,r2,zero
 322605c:	1000091e 	bne	r2,zero,3226084 <ns_printf+0x6c>
   {
#ifdef NATIVE_PRINTF
      /* use the target system's ANSI routines */
      va_start(argList,format);
 3226060:	e0800404 	addi	r2,fp,16
 3226064:	e0bffc15 	stw	r2,-16(fp)
      ret_value = vprintf(format,argList);
 3226068:	e17ffc17 	ldw	r5,-16(fp)
 322606c:	e13ffe17 	ldw	r4,-8(fp)
 3226070:	324bc1c0 	call	324bc1c <vprintf>
 3226074:	e0bffa15 	stw	r2,-24(fp)
      va_end(argList);
      return ret_value;
 3226078:	e0bffa17 	ldw	r2,-24(fp)
 322607c:	e0bfff15 	stw	r2,-4(fp)
 3226080:	00003e06 	br	322617c <ns_printf+0x164>
      return strlen(format);
#endif   /* NATIVE_PRINTF */
   }

   /* Check if the output function is set */
   if (pio->out == NULL)
 3226084:	e0bff817 	ldw	r2,-32(fp)
 3226088:	10800117 	ldw	r2,4(r2)
 322608c:	1004c03a 	cmpne	r2,r2,zero
 3226090:	1000031e 	bne	r2,zero,32260a0 <ns_printf+0x88>
   {
      /* Programming mistake. Output function not set. */
      return -1;
 3226094:	00bfffc4 	movi	r2,-1
 3226098:	e0bfff15 	stw	r2,-4(fp)
 322609c:	00003706 	br	322617c <ns_printf+0x164>

   /* Allocate memory for the output string 
    * If the format string is greater than MAXIOSIZE, then
    * we surely need to allocate a bigger block
    */
   ret_value = strlen(format); 
 32260a0:	e13ffe17 	ldw	r4,-8(fp)
 32260a4:	32081440 	call	3208144 <strlen>
 32260a8:	e0bffa15 	stw	r2,-24(fp)
   if (ret_value >= MAXIOSIZE)
 32260ac:	e0bffa17 	ldw	r2,-24(fp)
 32260b0:	10802710 	cmplti	r2,r2,156
 32260b4:	1000041e 	bne	r2,zero,32260c8 <ns_printf+0xb0>
   {
      buf_size += ret_value ;
 32260b8:	e0bff917 	ldw	r2,-28(fp)
 32260bc:	e0fffa17 	ldw	r3,-24(fp)
 32260c0:	10c5883a 	add	r2,r2,r3
 32260c4:	e0bff915 	stw	r2,-28(fp)
   }

   outbuf=(char *)npalloc(buf_size); 
 32260c8:	e13ff917 	ldw	r4,-28(fp)
 32260cc:	322b5d00 	call	322b5d0 <npalloc>
 32260d0:	e0bffb15 	stw	r2,-20(fp)

   if (outbuf == NULL)
 32260d4:	e0bffb17 	ldw	r2,-20(fp)
 32260d8:	1004c03a 	cmpne	r2,r2,zero
 32260dc:	1000031e 	bne	r2,zero,32260ec <ns_printf+0xd4>
   {
      return -2;
 32260e0:	00bfff84 	movi	r2,-2
 32260e4:	e0bfff15 	stw	r2,-4(fp)
 32260e8:	00002406 	br	322617c <ns_printf+0x164>

   /* Now populate the output string */

#ifdef NATIVE_PRINTF
   /* use the target system's ANSI routines */
   va_start(argList,format);
 32260ec:	e0800404 	addi	r2,fp,16
 32260f0:	e0bffc15 	stw	r2,-16(fp)
   ret_value = vsprintf(outbuf,format,argList);
 32260f4:	e1bffc17 	ldw	r6,-16(fp)
 32260f8:	e13ffb17 	ldw	r4,-20(fp)
 32260fc:	e17ffe17 	ldw	r5,-8(fp)
 3226100:	324bc8c0 	call	324bc8c <vsprintf>
 3226104:	e0bffa15 	stw	r2,-24(fp)
#endif   /* PRINTF_STDARG */
#endif   /* NATIVE_PRINTF */

#ifdef NATIVE_PRINTF
   /* Check if we have overwritten the output buffer */
   if ((int)strlen(outbuf) > buf_size)
 3226108:	e13ffb17 	ldw	r4,-20(fp)
 322610c:	32081440 	call	3208144 <strlen>
 3226110:	1007883a 	mov	r3,r2
 3226114:	e0bff917 	ldw	r2,-28(fp)
 3226118:	10c0080e 	bge	r2,r3,322613c <ns_printf+0x124>
       */
      /* Yes , we have overwritten. Truncate the output string.
       * Some memory in the heap has been corrupted, but it is too
       * late to rectify.
       */
      panic("ns_printf:Buffer overflow");
 322611c:	0100c974 	movhi	r4,805
 3226120:	213b5e04 	addi	r4,r4,-4744
 3226124:	3225df00 	call	3225df0 <panic>
      outbuf[buf_size-1]=0;   /* Null terminate the string */
 3226128:	e0fff917 	ldw	r3,-28(fp)
 322612c:	e0bffb17 	ldw	r2,-20(fp)
 3226130:	1885883a 	add	r2,r3,r2
 3226134:	10bfffc4 	addi	r2,r2,-1
 3226138:	10000005 	stb	zero,0(r2)
   }
#endif

   ret_value =(pio->out)(pio->id,outbuf,strlen(outbuf)) ;
 322613c:	e0bff817 	ldw	r2,-32(fp)
 3226140:	14400117 	ldw	r17,4(r2)
 3226144:	e0bff817 	ldw	r2,-32(fp)
 3226148:	14000217 	ldw	r16,8(r2)
 322614c:	e13ffb17 	ldw	r4,-20(fp)
 3226150:	32081440 	call	3208144 <strlen>
 3226154:	100d883a 	mov	r6,r2
 3226158:	8009883a 	mov	r4,r16
 322615c:	e17ffb17 	ldw	r5,-20(fp)
 3226160:	883ee83a 	callr	r17
 3226164:	e0bffa15 	stw	r2,-24(fp)

   /* Free memory for the output string */
   npfree(outbuf); 
 3226168:	e13ffb17 	ldw	r4,-20(fp)
 322616c:	322b6c40 	call	322b6c4 <npfree>

   /* since ns_printf() can get called repeatedly down in the bowels 
    * of a single command interpretting function, spin tk_yield() so 
    * that some packets get a chance to get received 
    */
   tk_yield();
 3226170:	3226a780 	call	3226a78 <tk_yield>

   return ret_value ;
 3226174:	e0bffa17 	ldw	r2,-24(fp)
 3226178:	e0bfff15 	stw	r2,-4(fp)
 322617c:	e0bfff17 	ldw	r2,-4(fp)
}
 3226180:	e037883a 	mov	sp,fp
 3226184:	dfc00317 	ldw	ra,12(sp)
 3226188:	df000217 	ldw	fp,8(sp)
 322618c:	dc400117 	ldw	r17,4(sp)
 3226190:	dc000017 	ldw	r16,0(sp)
 3226194:	dec00604 	addi	sp,sp,24
 3226198:	f800283a 	ret

0322619c <std_out>:
 *
 * RETURNS: Number of bytes send to standard output. 
 */

int std_out(long s, char * buf, int len)
{
 322619c:	defffb04 	addi	sp,sp,-20
 32261a0:	dfc00415 	stw	ra,16(sp)
 32261a4:	df000315 	stw	fp,12(sp)
 32261a8:	df000304 	addi	fp,sp,12
 32261ac:	e13ffd15 	stw	r4,-12(fp)
 32261b0:	e17ffe15 	stw	r5,-8(fp)
 32261b4:	e1bfff15 	stw	r6,-4(fp)
   /* puts(buf); - This does newline expansion return 
    * write(0,buf,len); - This doesn't printf(buf); - This has 
    * problems when printf format strings (eg %s) is part of data. 
    */
   printf("%s",buf);
 32261b8:	0100c974 	movhi	r4,805
 32261bc:	213b6504 	addi	r4,r4,-4716
 32261c0:	e17ffe17 	ldw	r5,-8(fp)
 32261c4:	3206adc0 	call	3206adc <printf>
   USE_ARG(s);
   return len;
 32261c8:	e0bfff17 	ldw	r2,-4(fp)
}
 32261cc:	e037883a 	mov	sp,fp
 32261d0:	dfc00117 	ldw	ra,4(sp)
 32261d4:	df000017 	ldw	fp,0(sp)
 32261d8:	dec00204 	addi	sp,sp,8
 32261dc:	f800283a 	ret

032261e0 <con_page>:
 * RETURNS: 1 if we got a break, 0 to keep printing
 */

int
con_page(void * vio, int lines)
{
 32261e0:	defff904 	addi	sp,sp,-28
 32261e4:	dfc00615 	stw	ra,24(sp)
 32261e8:	df000515 	stw	fp,20(sp)
 32261ec:	df000504 	addi	fp,sp,20
 32261f0:	e13ffd15 	stw	r4,-12(fp)
 32261f4:	e17ffe15 	stw	r5,-8(fp)
   int   ch;
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 32261f8:	e0bffd17 	ldw	r2,-12(fp)
 32261fc:	e0bffb15 	stw	r2,-20(fp)

   if (lines % 20 == 0)   /* Time to get user input */
 3226200:	e13ffe17 	ldw	r4,-8(fp)
 3226204:	01400504 	movi	r5,20
 3226208:	320445c0 	call	320445c <__modsi3>
 322620c:	1004c03a 	cmpne	r2,r2,zero
 3226210:	1000281e 	bne	r2,zero,32262b4 <con_page+0xd4>
   {
      if (pio && pio->getch)   /*if i/p func is supplied*/
 3226214:	e0bffb17 	ldw	r2,-20(fp)
 3226218:	1005003a 	cmpeq	r2,r2,zero
 322621c:	1000251e 	bne	r2,zero,32262b4 <con_page+0xd4>
 3226220:	e0bffb17 	ldw	r2,-20(fp)
 3226224:	10800317 	ldw	r2,12(r2)
 3226228:	1005003a 	cmpeq	r2,r2,zero
 322622c:	1000211e 	bne	r2,zero,32262b4 <con_page+0xd4>
      {
         ns_printf(pio,"....press any key for more (ESC to break)....");
 3226230:	e13ffb17 	ldw	r4,-20(fp)
 3226234:	0140c974 	movhi	r5,805
 3226238:	297b6604 	addi	r5,r5,-4712
 322623c:	32260180 	call	3226018 <ns_printf>

         do 
         {
            ch = (pio->getch)(pio->id);
 3226240:	e0bffb17 	ldw	r2,-20(fp)
 3226244:	10c00317 	ldw	r3,12(r2)
 3226248:	e0bffb17 	ldw	r2,-20(fp)
 322624c:	11000217 	ldw	r4,8(r2)
 3226250:	183ee83a 	callr	r3
 3226254:	e0bffc15 	stw	r2,-16(fp)
            if (ch == 0)
 3226258:	e0bffc17 	ldw	r2,-16(fp)
 322625c:	1004c03a 	cmpne	r2,r2,zero
 3226260:	1000011e 	bne	r2,zero,3226268 <con_page+0x88>
               tk_yield();    /* Give timeslice to other processes */
 3226264:	3226a780 	call	3226a78 <tk_yield>
         } while (ch == 0) ;
 3226268:	e0bffc17 	ldw	r2,-16(fp)
 322626c:	1005003a 	cmpeq	r2,r2,zero
 3226270:	103ff31e 	bne	r2,zero,3226240 <con_page+0x60>

            /* if there is fatal error, we don't want to do any I/O */
         if (ch == -1)   /* fatal error */
 3226274:	e0bffc17 	ldw	r2,-16(fp)
 3226278:	10bfffd8 	cmpnei	r2,r2,-1
 322627c:	1000031e 	bne	r2,zero,322628c <con_page+0xac>
            return 1 ;
 3226280:	00800044 	movi	r2,1
 3226284:	e0bfff15 	stw	r2,-4(fp)
 3226288:	00000b06 	br	32262b8 <con_page+0xd8>

         ns_printf(pio,"\n");
 322628c:	e13ffb17 	ldw	r4,-20(fp)
 3226290:	0140c974 	movhi	r5,805
 3226294:	297b4704 	addi	r5,r5,-4836
 3226298:	32260180 	call	3226018 <ns_printf>
         if (ch == 27)   /* ESC key pressed */
 322629c:	e0bffc17 	ldw	r2,-16(fp)
 32262a0:	108006d8 	cmpnei	r2,r2,27
 32262a4:	1000031e 	bne	r2,zero,32262b4 <con_page+0xd4>
            return 1 ;
 32262a8:	00800044 	movi	r2,1
 32262ac:	e0bfff15 	stw	r2,-4(fp)
 32262b0:	00000106 	br	32262b8 <con_page+0xd8>
      }
   }
   return  0;
 32262b4:	e03fff15 	stw	zero,-4(fp)
 32262b8:	e0bfff17 	ldw	r2,-4(fp)
}
 32262bc:	e037883a 	mov	sp,fp
 32262c0:	dfc00117 	ldw	ra,4(sp)
 32262c4:	df000017 	ldw	fp,0(sp)
 32262c8:	dec00204 	addi	sp,sp,8
 32262cc:	f800283a 	ret

032262d0 <parse_args>:

char **parse_args(char *buf, int argc, int *pargc_index)
{
 32262d0:	defff604 	addi	sp,sp,-40
 32262d4:	dfc00915 	stw	ra,36(sp)
 32262d8:	df000815 	stw	fp,32(sp)
 32262dc:	df000804 	addi	fp,sp,32
 32262e0:	e13ffc15 	stw	r4,-16(fp)
 32262e4:	e17ffd15 	stw	r5,-12(fp)
 32262e8:	e1bffe15 	stw	r6,-8(fp)
   /* This routine assumes buf is a null terminated string */
   int i;
   int len;
   char *bp = buf;
 32262ec:	e0bffc17 	ldw	r2,-16(fp)
 32262f0:	e0bff915 	stw	r2,-28(fp)
   char **pargv = NULL;
 32262f4:	e03ff815 	stw	zero,-32(fp)
   *pargc_index = 0;
 32262f8:	e0bffe17 	ldw	r2,-8(fp)
 32262fc:	10000015 	stw	zero,0(r2)
   if (buf == NULL)
 3226300:	e0bffc17 	ldw	r2,-16(fp)
 3226304:	1004c03a 	cmpne	r2,r2,zero
 3226308:	1000021e 	bne	r2,zero,3226314 <parse_args+0x44>
   {
      return (NULL);
 322630c:	e03fff15 	stw	zero,-4(fp)
 3226310:	00007406 	br	32264e4 <parse_args+0x214>
   }
   len = strlen(buf);
 3226314:	e13ffc17 	ldw	r4,-16(fp)
 3226318:	32081440 	call	3208144 <strlen>
 322631c:	e0bffa15 	stw	r2,-24(fp)
   if (len <= 0)
 3226320:	e0bffa17 	ldw	r2,-24(fp)
 3226324:	10800048 	cmpgei	r2,r2,1
 3226328:	1000021e 	bne	r2,zero,3226334 <parse_args+0x64>
   {
      return (NULL);
 322632c:	e03fff15 	stw	zero,-4(fp)
 3226330:	00006c06 	br	32264e4 <parse_args+0x214>
   }
   pargv = (char **) npalloc(argc * sizeof(char *));
 3226334:	e0bffd17 	ldw	r2,-12(fp)
 3226338:	1085883a 	add	r2,r2,r2
 322633c:	1085883a 	add	r2,r2,r2
 3226340:	1009883a 	mov	r4,r2
 3226344:	322b5d00 	call	322b5d0 <npalloc>
 3226348:	e0bff815 	stw	r2,-32(fp)
   if (pargv == NULL)
 322634c:	e0bff817 	ldw	r2,-32(fp)
 3226350:	1004c03a 	cmpne	r2,r2,zero
 3226354:	1000051e 	bne	r2,zero,322636c <parse_args+0x9c>
   {
      return (NULL);
 3226358:	e03fff15 	stw	zero,-4(fp)
 322635c:	00006106 	br	32264e4 <parse_args+0x214>
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
 3226360:	e0bff917 	ldw	r2,-28(fp)
 3226364:	10800044 	addi	r2,r2,1
 3226368:	e0bff915 	stw	r2,-28(fp)
   if (pargv == NULL)
   {
      return (NULL);
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
 322636c:	e0bff917 	ldw	r2,-28(fp)
 3226370:	10800003 	ldbu	r2,0(r2)
 3226374:	10803fcc 	andi	r2,r2,255
 3226378:	1080201c 	xori	r2,r2,128
 322637c:	10bfe004 	addi	r2,r2,-128
 3226380:	10800820 	cmpeqi	r2,r2,32
 3226384:	103ff61e 	bne	r2,zero,3226360 <parse_args+0x90>
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 3226388:	00003206 	br	3226454 <parse_args+0x184>
   {
      pargv[(*pargc_index)] = bp;
 322638c:	e0bffe17 	ldw	r2,-8(fp)
 3226390:	10800017 	ldw	r2,0(r2)
 3226394:	1085883a 	add	r2,r2,r2
 3226398:	1085883a 	add	r2,r2,r2
 322639c:	1007883a 	mov	r3,r2
 32263a0:	e0bff817 	ldw	r2,-32(fp)
 32263a4:	1887883a 	add	r3,r3,r2
 32263a8:	e0bff917 	ldw	r2,-28(fp)
 32263ac:	18800015 	stw	r2,0(r3)
      (*pargc_index)++;
 32263b0:	e0bffe17 	ldw	r2,-8(fp)
 32263b4:	10800017 	ldw	r2,0(r2)
 32263b8:	10c00044 	addi	r3,r2,1
 32263bc:	e0bffe17 	ldw	r2,-8(fp)
 32263c0:	10c00015 	stw	r3,0(r2)
      while (*bp != ' ' && *bp != '\0')
 32263c4:	00000306 	br	32263d4 <parse_args+0x104>
      {
         bp++; 
 32263c8:	e0bff917 	ldw	r2,-28(fp)
 32263cc:	10800044 	addi	r2,r2,1
 32263d0:	e0bff915 	stw	r2,-28(fp)
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
   {
      pargv[(*pargc_index)] = bp;
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
 32263d4:	e0bff917 	ldw	r2,-28(fp)
 32263d8:	10800003 	ldbu	r2,0(r2)
 32263dc:	10803fcc 	andi	r2,r2,255
 32263e0:	1080201c 	xori	r2,r2,128
 32263e4:	10bfe004 	addi	r2,r2,-128
 32263e8:	10800820 	cmpeqi	r2,r2,32
 32263ec:	10000b1e 	bne	r2,zero,322641c <parse_args+0x14c>
 32263f0:	e0bff917 	ldw	r2,-28(fp)
 32263f4:	10800003 	ldbu	r2,0(r2)
 32263f8:	10803fcc 	andi	r2,r2,255
 32263fc:	1080201c 	xori	r2,r2,128
 3226400:	10bfe004 	addi	r2,r2,-128
 3226404:	1004c03a 	cmpne	r2,r2,zero
 3226408:	103fef1e 	bne	r2,zero,32263c8 <parse_args+0xf8>
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 322640c:	00000306 	br	322641c <parse_args+0x14c>
      {
         bp++; 
 3226410:	e0bff917 	ldw	r2,-28(fp)
 3226414:	10800044 	addi	r2,r2,1
 3226418:	e0bff915 	stw	r2,-28(fp)
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 322641c:	e0bff917 	ldw	r2,-28(fp)
 3226420:	10800003 	ldbu	r2,0(r2)
 3226424:	10803fcc 	andi	r2,r2,255
 3226428:	1080201c 	xori	r2,r2,128
 322642c:	10bfe004 	addi	r2,r2,-128
 3226430:	10800818 	cmpnei	r2,r2,32
 3226434:	1000071e 	bne	r2,zero,3226454 <parse_args+0x184>
 3226438:	e0bff917 	ldw	r2,-28(fp)
 322643c:	10800003 	ldbu	r2,0(r2)
 3226440:	10803fcc 	andi	r2,r2,255
 3226444:	1080201c 	xori	r2,r2,128
 3226448:	10bfe004 	addi	r2,r2,-128
 322644c:	1004c03a 	cmpne	r2,r2,zero
 3226450:	103fef1e 	bne	r2,zero,3226410 <parse_args+0x140>
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 3226454:	e0bff917 	ldw	r2,-28(fp)
 3226458:	10800003 	ldbu	r2,0(r2)
 322645c:	10803fcc 	andi	r2,r2,255
 3226460:	1080201c 	xori	r2,r2,128
 3226464:	10bfe004 	addi	r2,r2,-128
 3226468:	1005003a 	cmpeq	r2,r2,zero
 322646c:	1000041e 	bne	r2,zero,3226480 <parse_args+0x1b0>
 3226470:	e0bffe17 	ldw	r2,-8(fp)
 3226474:	10c00017 	ldw	r3,0(r2)
 3226478:	e0bffd17 	ldw	r2,-12(fp)
 322647c:	18bfc316 	blt	r3,r2,322638c <parse_args+0xbc>
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 3226480:	e03ffb15 	stw	zero,-20(fp)
 3226484:	00001206 	br	32264d0 <parse_args+0x200>
   {
      if (buf[i] == ' ')
 3226488:	e0bffb17 	ldw	r2,-20(fp)
 322648c:	1007883a 	mov	r3,r2
 3226490:	e0bffc17 	ldw	r2,-16(fp)
 3226494:	1885883a 	add	r2,r3,r2
 3226498:	10800003 	ldbu	r2,0(r2)
 322649c:	10803fcc 	andi	r2,r2,255
 32264a0:	1080201c 	xori	r2,r2,128
 32264a4:	10bfe004 	addi	r2,r2,-128
 32264a8:	10800818 	cmpnei	r2,r2,32
 32264ac:	1000051e 	bne	r2,zero,32264c4 <parse_args+0x1f4>
         buf[i] = '\0';
 32264b0:	e0bffb17 	ldw	r2,-20(fp)
 32264b4:	1007883a 	mov	r3,r2
 32264b8:	e0bffc17 	ldw	r2,-16(fp)
 32264bc:	1885883a 	add	r2,r3,r2
 32264c0:	10000005 	stb	zero,0(r2)
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 32264c4:	e0bffb17 	ldw	r2,-20(fp)
 32264c8:	10800044 	addi	r2,r2,1
 32264cc:	e0bffb15 	stw	r2,-20(fp)
 32264d0:	e0fffb17 	ldw	r3,-20(fp)
 32264d4:	e0bffa17 	ldw	r2,-24(fp)
 32264d8:	18bfeb16 	blt	r3,r2,3226488 <parse_args+0x1b8>
   {
      printf("pargv[%d] = %s\n", i, pargv[i]);
   }
#endif

   return (pargv);
 32264dc:	e0bff817 	ldw	r2,-32(fp)
 32264e0:	e0bfff15 	stw	r2,-4(fp)
 32264e4:	e0bfff17 	ldw	r2,-4(fp)
}
 32264e8:	e037883a 	mov	sp,fp
 32264ec:	dfc00117 	ldw	ra,4(sp)
 32264f0:	df000017 	ldw	fp,0(sp)
 32264f4:	dec00204 	addi	sp,sp,8
 32264f8:	f800283a 	ret

032264fc <netmain>:
 * RETURNS: 
 */

int
netmain(void)
{
 32264fc:	defffb04 	addi	sp,sp,-20
 3226500:	dfc00415 	stw	ra,16(sp)
 3226504:	df000315 	stw	fp,12(sp)
 3226508:	df000304 	addi	fp,sp,12
   int   i;
   int   e;

   iniche_net_ready = FALSE;
 322650c:	d028c315 	stw	zero,-23796(gp)

   e = prep_modules();
 3226510:	323c88c0 	call	323c88c <prep_modules>
 3226514:	e0bffd15 	stw	r2,-12(fp)

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 3226518:	e03ffe15 	stw	zero,-8(fp)
 322651c:	00001c06 	br	3226590 <netmain+0x94>
   {
      e = TK_NEWTASK(&nettasks[i]);
 3226520:	e0bffe17 	ldw	r2,-8(fp)
 3226524:	10800624 	muli	r2,r2,24
 3226528:	1007883a 	mov	r3,r2
 322652c:	0080c974 	movhi	r2,805
 3226530:	10885504 	addi	r2,r2,8532
 3226534:	1889883a 	add	r4,r3,r2
 3226538:	322af740 	call	322af74 <TK_NEWTASK>
 322653c:	e0bffd15 	stw	r2,-12(fp)
      if (e != 0)
 3226540:	e0bffd17 	ldw	r2,-12(fp)
 3226544:	1005003a 	cmpeq	r2,r2,zero
 3226548:	10000e1e 	bne	r2,zero,3226584 <netmain+0x88>
      {
         dprintf("task create error\n");
 322654c:	0100c974 	movhi	r4,805
 3226550:	213b7804 	addi	r4,r4,-4640
 3226554:	3206e040 	call	3206e04 <puts>
         panic((char *)&nettasks[i].name);
 3226558:	e0bffe17 	ldw	r2,-8(fp)
 322655c:	10800624 	muli	r2,r2,24
 3226560:	10c00104 	addi	r3,r2,4
 3226564:	0080c974 	movhi	r2,805
 3226568:	10885504 	addi	r2,r2,8532
 322656c:	1885883a 	add	r2,r3,r2
 3226570:	1009883a 	mov	r4,r2
 3226574:	3225df00 	call	3225df0 <panic>
         return -1;  /* compiler warnings */
 3226578:	00bfffc4 	movi	r2,-1
 322657c:	e0bfff15 	stw	r2,-4(fp)
 3226580:	00001506 	br	32265d8 <netmain+0xdc>
   iniche_net_ready = FALSE;

   e = prep_modules();

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 3226584:	e0bffe17 	ldw	r2,-8(fp)
 3226588:	10800044 	addi	r2,r2,1
 322658c:	e0bffe15 	stw	r2,-8(fp)
 3226590:	d0e02e17 	ldw	r3,-32584(gp)
 3226594:	e0bffe17 	ldw	r2,-8(fp)
 3226598:	10ffe116 	blt	r2,r3,3226520 <netmain+0x24>
         panic((char *)&nettasks[i].name);
         return -1;  /* compiler warnings */
      }
   }
   
   e = create_apptasks();
 322659c:	323cd640 	call	323cd64 <create_apptasks>
 32265a0:	e0bffd15 	stw	r2,-12(fp)
   if (e != 0) 
 32265a4:	e0bffd17 	ldw	r2,-12(fp)
 32265a8:	1005003a 	cmpeq	r2,r2,zero
 32265ac:	1000091e 	bne	r2,zero,32265d4 <netmain+0xd8>
   {
      dprintf("task create error\n");
 32265b0:	0100c974 	movhi	r4,805
 32265b4:	213b7804 	addi	r4,r4,-4640
 32265b8:	3206e040 	call	3206e04 <puts>
      panic("netmain");
 32265bc:	0100c974 	movhi	r4,805
 32265c0:	213b7d04 	addi	r4,r4,-4620
 32265c4:	3225df00 	call	3225df0 <panic>
      return -1;  /* compiler warnings */
 32265c8:	00bfffc4 	movi	r2,-1
 32265cc:	e0bfff15 	stw	r2,-4(fp)
 32265d0:	00000106 	br	32265d8 <netmain+0xdc>
#ifdef MAIN_TASK_IS_NET
   tk_netmain(TK_NETMAINPARM);
   panic("net task return");
   return -1;
#else
   return 0;
 32265d4:	e03fff15 	stw	zero,-4(fp)
 32265d8:	e0bfff17 	ldw	r2,-4(fp)
#endif
#endif   /* NO_INET_STACK */
}
 32265dc:	e037883a 	mov	sp,fp
 32265e0:	dfc00117 	ldw	ra,4(sp)
 32265e4:	df000017 	ldw	fp,0(sp)
 32265e8:	dec00204 	addi	sp,sp,8
 32265ec:	f800283a 	ret

032265f0 <tk_netmain>:
 * RETURNS: n/a
 */

#ifndef NO_INET_STACK
TK_ENTRY(tk_netmain)
{
 32265f0:	defffc04 	addi	sp,sp,-16
 32265f4:	dfc00315 	stw	ra,12(sp)
 32265f8:	df000215 	stw	fp,8(sp)
 32265fc:	df000204 	addi	fp,sp,8
 3226600:	e13fff15 	stw	r4,-4(fp)
   netmain_init(); /* initialize all modules */
 3226604:	323c5100 	call	323c510 <netmain_init>

   iniche_net_ready = TRUE;    /* let the other threads spin */
 3226608:	00800044 	movi	r2,1
 322660c:	d0a8c315 	stw	r2,-23796(gp)
 3226610:	00000006 	br	3226614 <tk_netmain+0x24>

   for (;;)
   {
      TK_NETRX_BLOCK();
 3226614:	0080c974 	movhi	r2,805
 3226618:	10925904 	addi	r2,r2,18788
 322661c:	11000017 	ldw	r4,0(r2)
 3226620:	0140fa04 	movi	r5,1000
 3226624:	e1bffe04 	addi	r6,fp,-8
 3226628:	321ade40 	call	321ade4 <OSSemPend>
 322662c:	e0bffe03 	ldbu	r2,-8(fp)
 3226630:	10803fcc 	andi	r2,r2,255
 3226634:	1005003a 	cmpeq	r2,r2,zero
 3226638:	1000051e 	bne	r2,zero,3226650 <tk_netmain+0x60>
 322663c:	e0bffe03 	ldbu	r2,-8(fp)
 3226640:	10803fcc 	andi	r2,r2,255
 3226644:	108002a0 	cmpeqi	r2,r2,10
 3226648:	1000011e 	bne	r2,zero,3226650 <tk_netmain+0x60>
 322664c:	322ab8c0 	call	322ab8c <dtrap>
      netmain_wakes++;  /* count wakeups */
 3226650:	d0a8c117 	ldw	r2,-23804(gp)
 3226654:	10800044 	addi	r2,r2,1
 3226658:	d0a8c115 	stw	r2,-23804(gp)

      /* see if there's newly received network packets */
      if (rcvdq.q_len)
 322665c:	0080c9b4 	movhi	r2,806
 3226660:	10b19504 	addi	r2,r2,-14764
 3226664:	10800217 	ldw	r2,8(r2)
 3226668:	1005003a 	cmpeq	r2,r2,zero
 322666c:	103fe91e 	bne	r2,zero,3226614 <tk_netmain+0x24>
         pktdemux();
 3226670:	32232f00 	call	32232f0 <pktdemux>
       * vital to a clean shutdown 
       */
#ifdef USE_LCD
      update_display();
#endif
   }
 3226674:	003fe706 	br	3226614 <tk_netmain+0x24>

03226678 <tk_nettick>:
extern   int dhc_second(void);
#endif

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
 3226678:	defffd04 	addi	sp,sp,-12
 322667c:	dfc00215 	stw	ra,8(sp)
 3226680:	df000115 	stw	fp,4(sp)
 3226684:	df000104 	addi	fp,sp,4
 3226688:	e13fff15 	stw	r4,-4(fp)
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 322668c:	00000306 	br	322669c <tk_nettick+0x24>
       * request and then we receive a NAK. At this point the DHCP
       * client is reset to INIT state and dhc_second() needs to be
       * run to restart it.
       */
#ifdef DHCP_CLIENT
      dhc_second();
 3226690:	32291e40 	call	32291e4 <dhc_second>
#endif
      TK_SLEEP(1);
 3226694:	01000084 	movi	r4,2
 3226698:	321cf780 	call	321cf78 <OSTimeDly>

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 322669c:	d0a8c317 	ldw	r2,-23796(gp)
 32266a0:	1005003a 	cmpeq	r2,r2,zero
 32266a4:	103ffa1e 	bne	r2,zero,3226690 <tk_nettick+0x18>
      TK_SLEEP(1);
   }

   for (;;)
   {
      TK_SLEEP(SYS_SHORT_SLEEP);
 32266a8:	01000084 	movi	r4,2
 32266ac:	321cf780 	call	321cf78 <OSTimeDly>
      nettick_wakes++;  /* count wakeups */
 32266b0:	d0a8c217 	ldw	r2,-23800(gp)
 32266b4:	10800044 	addi	r2,r2,1
 32266b8:	d0a8c215 	stw	r2,-23800(gp)
      inet_timer();  /* let various timeouts occur */
 32266bc:	323c8e40 	call	323c8e4 <inet_timer>
      /* do not kill timers on net_system_exit. They may be
       * vital to a clean shutdown 
       */
   }
 32266c0:	003ff906 	br	32266a8 <tk_nettick+0x30>

032266c4 <TK_OSTimeDly>:
u_char   TK_OSTaskQuery(void);



void TK_OSTimeDly(void)
{
 32266c4:	defffe04 	addi	sp,sp,-8
 32266c8:	dfc00115 	stw	ra,4(sp)
 32266cc:	df000015 	stw	fp,0(sp)
 32266d0:	d839883a 	mov	fp,sp
   OSTimeDly(2);
 32266d4:	01000084 	movi	r4,2
 32266d8:	321cf780 	call	321cf78 <OSTimeDly>
}
 32266dc:	e037883a 	mov	sp,fp
 32266e0:	dfc00117 	ldw	ra,4(sp)
 32266e4:	df000017 	ldw	fp,0(sp)
 32266e8:	dec00204 	addi	sp,sp,8
 32266ec:	f800283a 	ret

032266f0 <TK_OSTaskResume>:



void TK_OSTaskResume(u_char * Id)
{
 32266f0:	defffc04 	addi	sp,sp,-16
 32266f4:	dfc00315 	stw	ra,12(sp)
 32266f8:	df000215 	stw	fp,8(sp)
 32266fc:	df000204 	addi	fp,sp,8
 3226700:	e13fff15 	stw	r4,-4(fp)
INT8U err;

   err = OSTaskResume(*Id);
 3226704:	e0bfff17 	ldw	r2,-4(fp)
 3226708:	10800003 	ldbu	r2,0(r2)
 322670c:	11003fcc 	andi	r4,r2,255
 3226710:	321c7780 	call	321c778 <OSTaskResume>
 3226714:	e0bffe05 	stb	r2,-8(fp)
   
#ifdef NPDEBUG
   if ((err != OS_NO_ERR) && (err != OS_TASK_NOT_SUSPENDED))
 3226718:	e0bffe03 	ldbu	r2,-8(fp)
 322671c:	1005003a 	cmpeq	r2,r2,zero
 3226720:	10000a1e 	bne	r2,zero,322674c <TK_OSTaskResume+0x5c>
 3226724:	e0bffe03 	ldbu	r2,-8(fp)
 3226728:	10801120 	cmpeqi	r2,r2,68
 322672c:	1000071e 	bne	r2,zero,322674c <TK_OSTaskResume+0x5c>
   {
      dprintf("ChronOS API call failure, to Resume Suspended Task!\n");
 3226730:	0100c974 	movhi	r4,805
 3226734:	213b7f04 	addi	r4,r4,-4612
 3226738:	3206e040 	call	3206e04 <puts>
      dtrap();
 322673c:	322ab8c0 	call	322ab8c <dtrap>
      panic("TK_OSTaskResume");      
 3226740:	0100c974 	movhi	r4,805
 3226744:	213b8c04 	addi	r4,r4,-4560
 3226748:	3225df00 	call	3225df0 <panic>
   }
#endif
}
 322674c:	e037883a 	mov	sp,fp
 3226750:	dfc00117 	ldw	ra,4(sp)
 3226754:	df000017 	ldw	fp,0(sp)
 3226758:	dec00204 	addi	sp,sp,8
 322675c:	f800283a 	ret

03226760 <tcp_sleep>:
 *
 * RETURN: none
 */
void
tcp_sleep(void * event)
{
 3226760:	defffb04 	addi	sp,sp,-20
 3226764:	dfc00415 	stw	ra,16(sp)
 3226768:	df000315 	stw	fp,12(sp)
 322676c:	df000304 	addi	fp,sp,12
 3226770:	e13fff15 	stw	r4,-4(fp)
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 3226774:	e03ffd15 	stw	zero,-12(fp)
 3226778:	00005006 	br	32268bc <tcp_sleep+0x15c>
   {
      if (global_TCPwakeup_set[i].soc_event == NULL)
 322677c:	e0bffd17 	ldw	r2,-12(fp)
 3226780:	00c0c9b4 	movhi	r3,806
 3226784:	18f34504 	addi	r3,r3,-13036
 3226788:	10800324 	muli	r2,r2,12
 322678c:	10c5883a 	add	r2,r2,r3
 3226790:	10800104 	addi	r2,r2,4
 3226794:	10800017 	ldw	r2,0(r2)
 3226798:	1004c03a 	cmpne	r2,r2,zero
 322679c:	1000441e 	bne	r2,zero,32268b0 <tcp_sleep+0x150>
      {
         global_TCPwakeup_set[i].soc_event = event;
 32267a0:	e0bffd17 	ldw	r2,-12(fp)
 32267a4:	00c0c9b4 	movhi	r3,806
 32267a8:	18f34504 	addi	r3,r3,-13036
 32267ac:	10800324 	muli	r2,r2,12
 32267b0:	10c5883a 	add	r2,r2,r3
 32267b4:	10c00104 	addi	r3,r2,4
 32267b8:	e0bfff17 	ldw	r2,-4(fp)
 32267bc:	18800015 	stw	r2,0(r3)
         global_TCPwakeup_set[i].ctick = cticks;
 32267c0:	e13ffd17 	ldw	r4,-12(fp)
 32267c4:	0080c974 	movhi	r2,805
 32267c8:	10925604 	addi	r2,r2,18776
 32267cc:	11400017 	ldw	r5,0(r2)
 32267d0:	00c0c9b4 	movhi	r3,806
 32267d4:	18f34504 	addi	r3,r3,-13036
 32267d8:	20800324 	muli	r2,r4,12
 32267dc:	10c5883a 	add	r2,r2,r3
 32267e0:	11400015 	stw	r5,0(r2)
         if (i > global_TCPwakeup_setIndx)
 32267e4:	0080c974 	movhi	r2,805
 32267e8:	10925504 	addi	r2,r2,18772
 32267ec:	10c00017 	ldw	r3,0(r2)
 32267f0:	e0bffd17 	ldw	r2,-12(fp)
 32267f4:	1880040e 	bge	r3,r2,3226808 <tcp_sleep+0xa8>
            global_TCPwakeup_setIndx = i;
 32267f8:	00c0c974 	movhi	r3,805
 32267fc:	18d25504 	addi	r3,r3,18772
 3226800:	e0bffd17 	ldw	r2,-12(fp)
 3226804:	18800015 	stw	r2,0(r3)

         tcp_sleep_count++;
 3226808:	0080c974 	movhi	r2,805
 322680c:	10925104 	addi	r2,r2,18756
 3226810:	10800017 	ldw	r2,0(r2)
 3226814:	10c00044 	addi	r3,r2,1
 3226818:	0080c974 	movhi	r2,805
 322681c:	10925104 	addi	r2,r2,18756
 3226820:	10c00015 	stw	r3,0(r2)

         /* Give up the lock before going to sleep. This can
          * potentially cause a context switch to the task
          * signaling the event.
          */
         UNLOCK_NET_RESOURCE(NET_RESID);
 3226824:	0009883a 	mov	r4,zero
 3226828:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

         /* don't wait forever in case we miss the event */
         OSSemPend(global_TCPwakeup_set[i].semaphore, TPS, &err);
 322682c:	e0bffd17 	ldw	r2,-12(fp)
 3226830:	00c0c9b4 	movhi	r3,806
 3226834:	18f34504 	addi	r3,r3,-13036
 3226838:	10800324 	muli	r2,r2,12
 322683c:	10c5883a 	add	r2,r2,r3
 3226840:	10800204 	addi	r2,r2,8
 3226844:	11000017 	ldw	r4,0(r2)
 3226848:	e1bffe04 	addi	r6,fp,-8
 322684c:	0140fa04 	movi	r5,1000
 3226850:	321ade40 	call	321ade4 <OSSemPend>
         if (err == 10)
 3226854:	e0bffe03 	ldbu	r2,-8(fp)
 3226858:	10803fcc 	andi	r2,r2,255
 322685c:	10800298 	cmpnei	r2,r2,10
 3226860:	1000101e 	bne	r2,zero,32268a4 <tcp_sleep+0x144>
         {
            ++tcp_sleep_timeout;
 3226864:	d0a8c517 	ldw	r2,-23788(gp)
 3226868:	10800044 	addi	r2,r2,1
 322686c:	d0a8c515 	stw	r2,-23788(gp)

            /* clear the entry */
            global_TCPwakeup_set[i].ctick = 0;
 3226870:	e0bffd17 	ldw	r2,-12(fp)
 3226874:	00c0c9b4 	movhi	r3,806
 3226878:	18f34504 	addi	r3,r3,-13036
 322687c:	10800324 	muli	r2,r2,12
 3226880:	10c5883a 	add	r2,r2,r3
 3226884:	10000015 	stw	zero,0(r2)
            global_TCPwakeup_set[i].soc_event = NULL;
 3226888:	e0bffd17 	ldw	r2,-12(fp)
 322688c:	00c0c9b4 	movhi	r3,806
 3226890:	18f34504 	addi	r3,r3,-13036
 3226894:	10800324 	muli	r2,r2,12
 3226898:	10c5883a 	add	r2,r2,r3
 322689c:	10800104 	addi	r2,r2,4
 32268a0:	10000015 	stw	zero,0(r2)
         }

         /* Regain the lock */
         LOCK_NET_RESOURCE(NET_RESID);
 32268a4:	0009883a 	mov	r4,zero
 32268a8:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         return;
 32268ac:	00000f06 	br	32268ec <tcp_sleep+0x18c>
tcp_sleep(void * event)
{
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 32268b0:	e0bffd17 	ldw	r2,-12(fp)
 32268b4:	10800044 	addi	r2,r2,1
 32268b8:	e0bffd15 	stw	r2,-12(fp)
 32268bc:	e0bffd17 	ldw	r2,-12(fp)
 32268c0:	10800510 	cmplti	r2,r2,20
 32268c4:	103fad1e 	bne	r2,zero,322677c <tcp_sleep+0x1c>

   /* The table is full. Try calling TK_YIELD() and hope for the best.
    * The user should increase the size of the table.
    * We'll record the max index for debugging purposes.
    */
   global_TCPwakeup_setIndx = i;
 32268c8:	00c0c974 	movhi	r3,805
 32268cc:	18d25504 	addi	r3,r3,18772
 32268d0:	e0bffd17 	ldw	r2,-12(fp)
 32268d4:	18800015 	stw	r2,0(r3)

   UNLOCK_NET_RESOURCE(NET_RESID);
 32268d8:	0009883a 	mov	r4,zero
 32268dc:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   TK_YIELD();
 32268e0:	3226a780 	call	3226a78 <tk_yield>
   LOCK_NET_RESOURCE(NET_RESID);
 32268e4:	0009883a 	mov	r4,zero
 32268e8:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
}
 32268ec:	e037883a 	mov	sp,fp
 32268f0:	dfc00117 	ldw	ra,4(sp)
 32268f4:	df000017 	ldw	fp,0(sp)
 32268f8:	dec00204 	addi	sp,sp,8
 32268fc:	f800283a 	ret

03226900 <tcp_wakeup>:
 *
 * RETURN: none
 */
void
tcp_wakeup(void *event)
{
 3226900:	defffc04 	addi	sp,sp,-16
 3226904:	dfc00315 	stw	ra,12(sp)
 3226908:	df000215 	stw	fp,8(sp)
 322690c:	df000204 	addi	fp,sp,8
 3226910:	e13fff15 	stw	r4,-4(fp)
   int i;

   OSSchedLock();
 3226914:	3215d3c0 	call	3215d3c <OSSchedLock>

   for (i = 0; i < GLOBWAKE_SZ; i++)
 3226918:	e03ffe15 	stw	zero,-8(fp)
 322691c:	00003006 	br	32269e0 <tcp_wakeup+0xe0>
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 3226920:	e0bffe17 	ldw	r2,-8(fp)
 3226924:	00c0c9b4 	movhi	r3,806
 3226928:	18f34504 	addi	r3,r3,-13036
 322692c:	10800324 	muli	r2,r2,12
 3226930:	10c5883a 	add	r2,r2,r3
 3226934:	10800017 	ldw	r2,0(r2)
 3226938:	1005003a 	cmpeq	r2,r2,zero
 322693c:	1000251e 	bne	r2,zero,32269d4 <tcp_wakeup+0xd4>
 3226940:	e0bffe17 	ldw	r2,-8(fp)
 3226944:	00c0c9b4 	movhi	r3,806
 3226948:	18f34504 	addi	r3,r3,-13036
 322694c:	10800324 	muli	r2,r2,12
 3226950:	10c5883a 	add	r2,r2,r3
 3226954:	10800104 	addi	r2,r2,4
 3226958:	10c00017 	ldw	r3,0(r2)
 322695c:	e0bfff17 	ldw	r2,-4(fp)
 3226960:	18801c1e 	bne	r3,r2,32269d4 <tcp_wakeup+0xd4>
          (global_TCPwakeup_set[i].soc_event == event))
      {
         /* signal the event */
         OSSemPost(global_TCPwakeup_set[i].semaphore);
 3226964:	e0bffe17 	ldw	r2,-8(fp)
 3226968:	00c0c9b4 	movhi	r3,806
 322696c:	18f34504 	addi	r3,r3,-13036
 3226970:	10800324 	muli	r2,r2,12
 3226974:	10c5883a 	add	r2,r2,r3
 3226978:	10800204 	addi	r2,r2,8
 322697c:	11000017 	ldw	r4,0(r2)
 3226980:	321b1dc0 	call	321b1dc <OSSemPost>

         /* clear the entry */
         global_TCPwakeup_set[i].ctick = 0;
 3226984:	e0bffe17 	ldw	r2,-8(fp)
 3226988:	00c0c9b4 	movhi	r3,806
 322698c:	18f34504 	addi	r3,r3,-13036
 3226990:	10800324 	muli	r2,r2,12
 3226994:	10c5883a 	add	r2,r2,r3
 3226998:	10000015 	stw	zero,0(r2)
         global_TCPwakeup_set[i].soc_event = NULL;
 322699c:	e0bffe17 	ldw	r2,-8(fp)
 32269a0:	00c0c9b4 	movhi	r3,806
 32269a4:	18f34504 	addi	r3,r3,-13036
 32269a8:	10800324 	muli	r2,r2,12
 32269ac:	10c5883a 	add	r2,r2,r3
 32269b0:	10800104 	addi	r2,r2,4
 32269b4:	10000015 	stw	zero,0(r2)

         tcp_wakeup_count++;
 32269b8:	0080c974 	movhi	r2,805
 32269bc:	10925204 	addi	r2,r2,18760
 32269c0:	10800017 	ldw	r2,0(r2)
 32269c4:	10c00044 	addi	r3,r2,1
 32269c8:	0080c974 	movhi	r2,805
 32269cc:	10925204 	addi	r2,r2,18760
 32269d0:	10c00015 	stw	r3,0(r2)
{
   int i;

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
 32269d4:	e0bffe17 	ldw	r2,-8(fp)
 32269d8:	10800044 	addi	r2,r2,1
 32269dc:	e0bffe15 	stw	r2,-8(fp)
 32269e0:	e0bffe17 	ldw	r2,-8(fp)
 32269e4:	10800510 	cmplti	r2,r2,20
 32269e8:	103fcd1e 	bne	r2,zero,3226920 <tcp_wakeup+0x20>

         tcp_wakeup_count++;
      }
   }

   OSSchedUnlock();
 32269ec:	3215dc80 	call	3215dc8 <OSSchedUnlock>
}
 32269f0:	e037883a 	mov	sp,fp
 32269f4:	dfc00117 	ldw	ra,4(sp)
 32269f8:	df000017 	ldw	fp,0(sp)
 32269fc:	dec00204 	addi	sp,sp,8
 3226a00:	f800283a 	ret

03226a04 <TK_OSTaskQuery>:



u_char TK_OSTaskQuery(void)
{
 3226a04:	deffe104 	addi	sp,sp,-124
 3226a08:	dfc01e15 	stw	ra,120(sp)
 3226a0c:	df001d15 	stw	fp,116(sp)
 3226a10:	df001d04 	addi	fp,sp,116
   OS_TCB task_data;
   INT8U err, task_prio;

   err = OSTaskQuery(OS_PRIO_SELF, &task_data);
 3226a14:	e17fe404 	addi	r5,fp,-112
 3226a18:	01003fc4 	movi	r4,255
 3226a1c:	321cdb80 	call	321cdb8 <OSTaskQuery>
 3226a20:	e0bfe345 	stb	r2,-115(fp)

   if (err == OS_NO_ERR)
 3226a24:	e0bfe343 	ldbu	r2,-115(fp)
 3226a28:	1004c03a 	cmpne	r2,r2,zero
 3226a2c:	1000051e 	bne	r2,zero,3226a44 <TK_OSTaskQuery+0x40>
   {
      task_prio = task_data.OSTCBPrio;
 3226a30:	e0bff083 	ldbu	r2,-62(fp)
 3226a34:	e0bfe305 	stb	r2,-116(fp)
      dprintf("ChronOS API call failure, unable to identify task!");
      panic("TK_OSTaskQuery");
      return 0;
   }
   
   return task_prio;
 3226a38:	e0bfe303 	ldbu	r2,-116(fp)
 3226a3c:	e0bfff15 	stw	r2,-4(fp)
 3226a40:	00000706 	br	3226a60 <TK_OSTaskQuery+0x5c>
   {
      task_prio = task_data.OSTCBPrio;
   }
   else
   {
      dprintf("ChronOS API call failure, unable to identify task!");
 3226a44:	0100c974 	movhi	r4,805
 3226a48:	213b9004 	addi	r4,r4,-4544
 3226a4c:	3206adc0 	call	3206adc <printf>
      panic("TK_OSTaskQuery");
 3226a50:	0100c974 	movhi	r4,805
 3226a54:	213b9d04 	addi	r4,r4,-4492
 3226a58:	3225df00 	call	3225df0 <panic>
      return 0;
 3226a5c:	e03fff15 	stw	zero,-4(fp)
 3226a60:	e0bfff17 	ldw	r2,-4(fp)
   }
   
   return task_prio;
}
 3226a64:	e037883a 	mov	sp,fp
 3226a68:	dfc00117 	ldw	ra,4(sp)
 3226a6c:	df000017 	ldw	fp,0(sp)
 3226a70:	dec00204 	addi	sp,sp,8
 3226a74:	f800283a 	ret

03226a78 <tk_yield>:



void
tk_yield(void)
{
 3226a78:	defffe04 	addi	sp,sp,-8
 3226a7c:	dfc00115 	stw	ra,4(sp)
 3226a80:	df000015 	stw	fp,0(sp)
 3226a84:	d839883a 	mov	fp,sp
   /* To ensure cycles to the lower priority tasks we should really
    * delay by two ticks, but that really hurts performance on some
    * long-tick targets. One tick works better overall....
    */
   OSTimeDly(1);
 3226a88:	01000044 	movi	r4,1
 3226a8c:	321cf780 	call	321cf78 <OSTimeDly>
}
 3226a90:	e037883a 	mov	sp,fp
 3226a94:	dfc00117 	ldw	ra,4(sp)
 3226a98:	df000017 	ldw	fp,0(sp)
 3226a9c:	dec00204 	addi	sp,sp,8
 3226aa0:	f800283a 	ret

03226aa4 <tk_stats>:
extern struct inet_taskinfo * nettask;
extern int num_net_tasks;

int
tk_stats(void * pio)
{
 3226aa4:	deffef04 	addi	sp,sp,-68
 3226aa8:	dfc01015 	stw	ra,64(sp)
 3226aac:	df000f15 	stw	fp,60(sp)
 3226ab0:	df000f04 	addi	fp,sp,60
 3226ab4:	e13fff15 	stw	r4,-4(fp)
   int      stackuse;
   char     name[OS_TASK_NAME_SIZE+1];
   INT8U    err;
   

   ns_printf(pio, "ChronOS RTOS stats:\n");
 3226ab8:	e13fff17 	ldw	r4,-4(fp)
 3226abc:	0140c974 	movhi	r5,805
 3226ac0:	297ba104 	addi	r5,r5,-4476
 3226ac4:	32260180 	call	3226018 <ns_printf>

#ifdef NO_INICHE_EXTENSIONS
   ns_printf(pio, "Context switches; Delay:  %lu\n",
 3226ac8:	0080c974 	movhi	r2,805
 3226acc:	10922004 	addi	r2,r2,18560
 3226ad0:	11800017 	ldw	r6,0(r2)
 3226ad4:	e13fff17 	ldw	r4,-4(fp)
 3226ad8:	0140c974 	movhi	r5,805
 3226adc:	297ba704 	addi	r5,r5,-4452
 3226ae0:	32260180 	call	3226018 <ns_printf>
#else
   ns_printf(pio, "Context switches; Delay:  %lu, Interrupt: %lu\n",
      OSCtxSwCtr, OSCtxIntCtr);
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");
 3226ae4:	e13fff17 	ldw	r4,-4(fp)
 3226ae8:	0140c974 	movhi	r5,805
 3226aec:	297baf04 	addi	r5,r5,-4420
 3226af0:	32260180 	call	3226018 <ns_printf>

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 3226af4:	e03ff515 	stw	zero,-44(fp)
 3226af8:	00005106 	br	3226c40 <tk_stats+0x19c>
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
 3226afc:	e0bff517 	ldw	r2,-44(fp)
 3226b00:	00c0c9b4 	movhi	r3,806
 3226b04:	18f18004 	addi	r3,r3,-14848
 3226b08:	1085883a 	add	r2,r2,r2
 3226b0c:	1085883a 	add	r2,r2,r2
 3226b10:	10c5883a 	add	r2,r2,r3
 3226b14:	10800017 	ldw	r2,0(r2)
 3226b18:	e0bff415 	stw	r2,-48(fp)
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
 3226b1c:	e0bff417 	ldw	r2,-48(fp)
 3226b20:	1005003a 	cmpeq	r2,r2,zero
 3226b24:	1000431e 	bne	r2,zero,3226c34 <tk_stats+0x190>
 3226b28:	e0bff417 	ldw	r2,-48(fp)
 3226b2c:	10800060 	cmpeqi	r2,r2,1
 3226b30:	1000401e 	bne	r2,zero,3226c34 <tk_stats+0x190>
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);
 3226b34:	e0bff417 	ldw	r2,-48(fp)
 3226b38:	10800c83 	ldbu	r2,50(r2)
 3226b3c:	11003fcc 	andi	r4,r2,255
 3226b40:	e17ff604 	addi	r5,fp,-40
 3226b44:	e1bffe44 	addi	r6,fp,-7
 3226b48:	321c3fc0 	call	321c3fc <OSTaskNameGet>

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 3226b4c:	e0bff417 	ldw	r2,-48(fp)
 3226b50:	10800c83 	ldbu	r2,50(r2)
 3226b54:	11c03fcc 	andi	r7,r2,255
 3226b58:	e0bff417 	ldw	r2,-48(fp)
 3226b5c:	10800c03 	ldbu	r2,48(r2)
 3226b60:	10803fcc 	andi	r2,r2,255
 3226b64:	e1bff604 	addi	r6,fp,-40
 3226b68:	d8800015 	stw	r2,0(sp)
 3226b6c:	e13fff17 	ldw	r4,-4(fp)
 3226b70:	0140c974 	movhi	r5,805
 3226b74:	297bbf04 	addi	r5,r5,-4356
 3226b78:	32260180 	call	3226018 <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 3226b7c:	e0bff417 	ldw	r2,-48(fp)
 3226b80:	10800217 	ldw	r2,8(r2)
 3226b84:	1005003a 	cmpeq	r2,r2,zero
 3226b88:	1000261e 	bne	r2,zero,3226c24 <tk_stats+0x180>
 3226b8c:	e0bff417 	ldw	r2,-48(fp)
 3226b90:	10800317 	ldw	r2,12(r2)
 3226b94:	1005003a 	cmpeq	r2,r2,zero
 3226b98:	1000221e 	bne	r2,zero,3226c24 <tk_stats+0x180>
      {
         sp = tcb->OSTCBStkBottom + 1;
 3226b9c:	e0bff417 	ldw	r2,-48(fp)
 3226ba0:	10800217 	ldw	r2,8(r2)
 3226ba4:	10800104 	addi	r2,r2,4
 3226ba8:	e0bff315 	stw	r2,-52(fp)
         while(*sp == 0)
 3226bac:	00000306 	br	3226bbc <tk_stats+0x118>
            sp++;
 3226bb0:	e0bff317 	ldw	r2,-52(fp)
 3226bb4:	10800104 	addi	r2,r2,4
 3226bb8:	e0bff315 	stw	r2,-52(fp)
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
      {
         sp = tcb->OSTCBStkBottom + 1;
         while(*sp == 0)
 3226bbc:	e0bff317 	ldw	r2,-52(fp)
 3226bc0:	10800017 	ldw	r2,0(r2)
 3226bc4:	1005003a 	cmpeq	r2,r2,zero
 3226bc8:	103ff91e 	bne	r2,zero,3226bb0 <tk_stats+0x10c>
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
 3226bcc:	e0bff417 	ldw	r2,-48(fp)
 3226bd0:	11000317 	ldw	r4,12(r2)
 3226bd4:	e0fff317 	ldw	r3,-52(fp)
 3226bd8:	e0bff417 	ldw	r2,-48(fp)
 3226bdc:	10800217 	ldw	r2,8(r2)
 3226be0:	1885c83a 	sub	r2,r3,r2
 3226be4:	1005d0ba 	srai	r2,r2,2
 3226be8:	2085c83a 	sub	r2,r4,r2
 3226bec:	1085883a 	add	r2,r2,r2
 3226bf0:	1085883a 	add	r2,r2,r2
 3226bf4:	e0bff215 	stw	r2,-56(fp)
         ns_printf(pio, "%6d,      %6d\n",
 3226bf8:	e0bff417 	ldw	r2,-48(fp)
 3226bfc:	10800317 	ldw	r2,12(r2)
 3226c00:	1085883a 	add	r2,r2,r2
 3226c04:	1085883a 	add	r2,r2,r2
 3226c08:	100d883a 	mov	r6,r2
 3226c0c:	e13fff17 	ldw	r4,-4(fp)
 3226c10:	0140c974 	movhi	r5,805
 3226c14:	297bc704 	addi	r5,r5,-4324
 3226c18:	e1fff217 	ldw	r7,-56(fp)
 3226c1c:	32260180 	call	3226018 <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 3226c20:	00000406 	br	3226c34 <tk_stats+0x190>
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
      }
      else
#endif
      {
         ns_printf(pio, "No stack data\n");
 3226c24:	e13fff17 	ldw	r4,-4(fp)
 3226c28:	0140c974 	movhi	r5,805
 3226c2c:	297bcb04 	addi	r5,r5,-4308
 3226c30:	32260180 	call	3226018 <ns_printf>
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 3226c34:	e0bff517 	ldw	r2,-44(fp)
 3226c38:	10800044 	addi	r2,r2,1
 3226c3c:	e0bff515 	stw	r2,-44(fp)
 3226c40:	e0bff517 	ldw	r2,-44(fp)
 3226c44:	10800550 	cmplti	r2,r2,21
 3226c48:	103fac1e 	bne	r2,zero,3226afc <tk_stats+0x58>
      {
         ns_printf(pio, "No stack data\n");
      }
   }

   ns_printf(pio, "tcp_sleep_count = %lu, tcp_wakeup_count = %lu\n",
 3226c4c:	0080c974 	movhi	r2,805
 3226c50:	10925104 	addi	r2,r2,18756
 3226c54:	11800017 	ldw	r6,0(r2)
 3226c58:	0080c974 	movhi	r2,805
 3226c5c:	10925204 	addi	r2,r2,18760
 3226c60:	11c00017 	ldw	r7,0(r2)
 3226c64:	e13fff17 	ldw	r4,-4(fp)
 3226c68:	0140c974 	movhi	r5,805
 3226c6c:	297bcf04 	addi	r5,r5,-4292
 3226c70:	32260180 	call	3226018 <ns_printf>
                  tcp_sleep_count, tcp_wakeup_count);
   ns_printf(pio, "global_TCPwakeup_setIndx = %d, tcp_sleep_timeout = %lu\n",
 3226c74:	0080c974 	movhi	r2,805
 3226c78:	10925504 	addi	r2,r2,18772
 3226c7c:	11800017 	ldw	r6,0(r2)
 3226c80:	d1e8c517 	ldw	r7,-23788(gp)
 3226c84:	e13fff17 	ldw	r4,-4(fp)
 3226c88:	0140c974 	movhi	r5,805
 3226c8c:	297bdb04 	addi	r5,r5,-4244
 3226c90:	32260180 	call	3226018 <ns_printf>
                  global_TCPwakeup_setIndx, tcp_sleep_timeout);

   return 0;
 3226c94:	0005883a 	mov	r2,zero
}
 3226c98:	e037883a 	mov	sp,fp
 3226c9c:	dfc00117 	ldw	ra,4(sp)
 3226ca0:	df000017 	ldw	fp,0(sp)
 3226ca4:	dec00204 	addi	sp,sp,8
 3226ca8:	f800283a 	ret

03226cac <dhc_get_srv_ipaddr>:
 * RETURNS: 
 */

ip_addr 
dhc_get_srv_ipaddr(u_char *options /* after magic cookie */) 
{
 3226cac:	defffa04 	addi	sp,sp,-24
 3226cb0:	dfc00515 	stw	ra,20(sp)
 3226cb4:	df000415 	stw	fp,16(sp)
 3226cb8:	df000404 	addi	fp,sp,16
 3226cbc:	e13fff15 	stw	r4,-4(fp)
    u_char * opts;
    u_char   optlen;
   ip_addr srv_ipaddr = 0;
 3226cc0:	e03ffc15 	stw	zero,-16(fp)

   if ((opts = find_opt(DHOP_SERVER, options)) != NULL) 
 3226cc4:	01000d84 	movi	r4,54
 3226cc8:	e17fff17 	ldw	r5,-4(fp)
 3226ccc:	3229bec0 	call	3229bec <find_opt>
 3226cd0:	e0bffe15 	stw	r2,-8(fp)
 3226cd4:	e0bffe17 	ldw	r2,-8(fp)
 3226cd8:	1005003a 	cmpeq	r2,r2,zero
 3226cdc:	1000111e 	bne	r2,zero,3226d24 <dhc_get_srv_ipaddr+0x78>
   {
      opts++;
 3226ce0:	e0bffe17 	ldw	r2,-8(fp)
 3226ce4:	10800044 	addi	r2,r2,1
 3226ce8:	e0bffe15 	stw	r2,-8(fp)
      optlen = *opts;
 3226cec:	e0bffe17 	ldw	r2,-8(fp)
 3226cf0:	10800003 	ldbu	r2,0(r2)
 3226cf4:	e0bffd05 	stb	r2,-12(fp)
      opts++;
 3226cf8:	e0bffe17 	ldw	r2,-8(fp)
 3226cfc:	10800044 	addi	r2,r2,1
 3226d00:	e0bffe15 	stw	r2,-8(fp)
      srv_ipaddr = dh_getlong(opts);
 3226d04:	e13ffe17 	ldw	r4,-8(fp)
 3226d08:	3228e5c0 	call	3228e5c <dh_getlong>
 3226d0c:	e0bffc15 	stw	r2,-16(fp)
      opts += optlen;
 3226d10:	e0bffd03 	ldbu	r2,-12(fp)
 3226d14:	1007883a 	mov	r3,r2
 3226d18:	e0bffe17 	ldw	r2,-8(fp)
 3226d1c:	10c5883a 	add	r2,r2,r3
 3226d20:	e0bffe15 	stw	r2,-8(fp)
   }

   return (srv_ipaddr);
 3226d24:	e0bffc17 	ldw	r2,-16(fp)
} 
 3226d28:	e037883a 	mov	sp,fp
 3226d2c:	dfc00117 	ldw	ra,4(sp)
 3226d30:	df000017 	ldw	fp,0(sp)
 3226d34:	dec00204 	addi	sp,sp,8
 3226d38:	f800283a 	ret

03226d3c <dhc_init>:
 * RETURNS: Returns 0 if OK, else negative error code from net.h file 
 */

int
dhc_init(void)
{
 3226d3c:	defffb04 	addi	sp,sp,-20
 3226d40:	dfc00415 	stw	ra,16(sp)
 3226d44:	df000315 	stw	fp,12(sp)
 3226d48:	df000304 	addi	fp,sp,12
   int   i;

   /* open UDP connection to receive incoming DHCP replys */
   dhc_conn = udp_open(0L,    /* wildcard foriegn host */
 3226d4c:	00bfff44 	movi	r2,-3
 3226d50:	d8800015 	stw	r2,0(sp)
 3226d54:	0009883a 	mov	r4,zero
 3226d58:	014010c4 	movi	r5,67
 3226d5c:	01801104 	movi	r6,68
 3226d60:	01c0c8b4 	movhi	r7,802
 3226d64:	39db8f04 	addi	r7,r7,28220
 3226d68:	322a6dc0 	call	322a6dc <udp_open>
 3226d6c:	d0a8c615 	stw	r2,-23784(gp)
      BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT,
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
 3226d70:	d0a8c617 	ldw	r2,-23784(gp)
 3226d74:	1004c03a 	cmpne	r2,r2,zero
 3226d78:	1000031e 	bne	r2,zero,3226d88 <dhc_init+0x4c>
      return ENP_RESOURCE;
 3226d7c:	00bffa84 	movi	r2,-22
 3226d80:	e0bfff15 	stw	r2,-4(fp)
 3226d84:	00001606 	br	3226de0 <dhc_init+0xa4>

   for (i = 0; i < MAXNETS; i++)
 3226d88:	e03ffe15 	stw	zero,-8(fp)
 3226d8c:	00001006 	br	3226dd0 <dhc_init+0x94>
   {
      dhc_states[i].state = DHCS_UNUSED;
 3226d90:	e0bffe17 	ldw	r2,-8(fp)
 3226d94:	00c0c9b4 	movhi	r3,806
 3226d98:	18f28004 	addi	r3,r3,-13824
 3226d9c:	10800f24 	muli	r2,r2,60
 3226da0:	10c5883a 	add	r2,r2,r3
 3226da4:	10000015 	stw	zero,0(r2)
      dhc_states[i].tries = 0;
 3226da8:	e0bffe17 	ldw	r2,-8(fp)
 3226dac:	00c0c9b4 	movhi	r3,806
 3226db0:	18f28004 	addi	r3,r3,-13824
 3226db4:	10800f24 	muli	r2,r2,60
 3226db8:	10c5883a 	add	r2,r2,r3
 3226dbc:	10800104 	addi	r2,r2,4
 3226dc0:	10000015 	stw	zero,0(r2)
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
      return ENP_RESOURCE;

   for (i = 0; i < MAXNETS; i++)
 3226dc4:	e0bffe17 	ldw	r2,-8(fp)
 3226dc8:	10800044 	addi	r2,r2,1
 3226dcc:	e0bffe15 	stw	r2,-8(fp)
 3226dd0:	e0bffe17 	ldw	r2,-8(fp)
 3226dd4:	10800110 	cmplti	r2,r2,4
 3226dd8:	103fed1e 	bne	r2,zero,3226d90 <dhc_init+0x54>
   {
      dhc_states[i].state = DHCS_UNUSED;
      dhc_states[i].tries = 0;
   }

   return 0;
 3226ddc:	e03fff15 	stw	zero,-4(fp)
 3226de0:	e0bfff17 	ldw	r2,-4(fp)
}
 3226de4:	e037883a 	mov	sp,fp
 3226de8:	dfc00117 	ldw	ra,4(sp)
 3226dec:	df000017 	ldw	fp,0(sp)
 3226df0:	dec00204 	addi	sp,sp,8
 3226df4:	f800283a 	ret

03226df8 <dhc_set_callback>:
 * RETURNS: 
 */

void
dhc_set_callback(int iface, int (*routine)(int,int) )
{
 3226df8:	defffd04 	addi	sp,sp,-12
 3226dfc:	df000215 	stw	fp,8(sp)
 3226e00:	df000204 	addi	fp,sp,8
 3226e04:	e13ffe15 	stw	r4,-8(fp)
 3226e08:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].callback = routine;
 3226e0c:	e0bffe17 	ldw	r2,-8(fp)
 3226e10:	00c0c9b4 	movhi	r3,806
 3226e14:	18f28004 	addi	r3,r3,-13824
 3226e18:	10800f24 	muli	r2,r2,60
 3226e1c:	10c5883a 	add	r2,r2,r3
 3226e20:	10c00e04 	addi	r3,r2,56
 3226e24:	e0bfff17 	ldw	r2,-4(fp)
 3226e28:	18800015 	stw	r2,0(r3)
}
 3226e2c:	e037883a 	mov	sp,fp
 3226e30:	df000017 	ldw	fp,0(sp)
 3226e34:	dec00104 	addi	sp,sp,4
 3226e38:	f800283a 	ret

03226e3c <dhc_upcall>:
 * returned
 */

int
dhc_upcall(PACKET pkt, void * data)
{
 3226e3c:	defff204 	addi	sp,sp,-56
 3226e40:	dfc00d15 	stw	ra,52(sp)
 3226e44:	df000c15 	stw	fp,48(sp)
 3226e48:	dc000b15 	stw	r16,44(sp)
 3226e4c:	df000b04 	addi	fp,sp,44
 3226e50:	e13ffb15 	stw	r4,-20(fp)
 3226e54:	e17ffc15 	stw	r5,-16(fp)
   struct bootp * bp;
   int      len      =  pkt->nb_plen;  /* len of UDP data - the bootp/dhcp struct */
 3226e58:	e0bffb17 	ldw	r2,-20(fp)
 3226e5c:	10800417 	ldw	r2,16(r2)
 3226e60:	e0bff915 	stw	r2,-28(fp)
   int      dhcptype =  0;    /* DHCP type - not valid if bootp */
 3226e64:	e03ff815 	stw	zero,-32(fp)
   int      e;
   int      iface;
   u_char * opts;          /* scratch options pointer */

   if (data != DHCPDATA)
 3226e68:	e0bffc17 	ldw	r2,-16(fp)
 3226e6c:	10bfff60 	cmpeqi	r2,r2,-3
 3226e70:	1000041e 	bne	r2,zero,3226e84 <dhc_upcall+0x48>
   {
      dtrap();
 3226e74:	322ab8c0 	call	322ab8c <dtrap>
      return ENP_LOGIC;    /* internal logic error */
 3226e78:	00bffd44 	movi	r2,-11
 3226e7c:	e0bffe15 	stw	r2,-8(fp)
 3226e80:	0001f306 	br	3227650 <dhc_upcall+0x814>
   }

   /* punt if packet didn't come in a net we sent on */
   iface = net_num(pkt->net);
 3226e84:	e0bffb17 	ldw	r2,-20(fp)
 3226e88:	11000617 	ldw	r4,24(r2)
 3226e8c:	3223d580 	call	3223d58 <if_netnumber>
 3226e90:	e0bff615 	stw	r2,-40(fp)
   if (dhc_states[iface].state == DHCS_UNUSED)
 3226e94:	e0bff617 	ldw	r2,-40(fp)
 3226e98:	00c0c9b4 	movhi	r3,806
 3226e9c:	18f28004 	addi	r3,r3,-13824
 3226ea0:	10800f24 	muli	r2,r2,60
 3226ea4:	10c5883a 	add	r2,r2,r3
 3226ea8:	10800017 	ldw	r2,0(r2)
 3226eac:	1004c03a 	cmpne	r2,r2,zero
 3226eb0:	1000031e 	bne	r2,zero,3226ec0 <dhc_upcall+0x84>
      return ENP_NOT_MINE;
 3226eb4:	00c00084 	movi	r3,2
 3226eb8:	e0fffe15 	stw	r3,-8(fp)
 3226ebc:	0001e406 	br	3227650 <dhc_upcall+0x814>

   bp = (struct bootp *)pkt->nb_prot;
 3226ec0:	e0bffb17 	ldw	r2,-20(fp)
 3226ec4:	10800317 	ldw	r2,12(r2)
 3226ec8:	e0bffa15 	stw	r2,-24(fp)

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
 3226ecc:	e0bff917 	ldw	r2,-28(fp)
 3226ed0:	10803b30 	cmpltui	r2,r2,236
 3226ed4:	10000b1e 	bne	r2,zero,3226f04 <dhc_upcall+0xc8>
 3226ed8:	e0bffa17 	ldw	r2,-24(fp)
 3226edc:	10800003 	ldbu	r2,0(r2)
 3226ee0:	10803fcc 	andi	r2,r2,255
 3226ee4:	10800098 	cmpnei	r2,r2,2
 3226ee8:	1000061e 	bne	r2,zero,3226f04 <dhc_upcall+0xc8>
 3226eec:	e0bffa17 	ldw	r2,-24(fp)
 3226ef0:	10803b04 	addi	r2,r2,236
 3226ef4:	10c00017 	ldw	r3,0(r2)
 3226ef8:	0098d534 	movhi	r2,25428
 3226efc:	10a098c4 	addi	r2,r2,-32157
 3226f00:	18800726 	beq	r3,r2,3226f20 <dhc_upcall+0xe4>
       (bp->op != BOOTREPLY) ||
       (*(u_long*)(&bp->options) != RFC1084_MAGIC_COOKIE))
   {
      dtrap();
 3226f04:	322ab8c0 	call	322ab8c <dtrap>
      dsc_errors++;
 3226f08:	d0a8c717 	ldw	r2,-23780(gp)
 3226f0c:	10800044 	addi	r2,r2,1
 3226f10:	d0a8c715 	stw	r2,-23780(gp)
      return ENP_NOT_MINE;
 3226f14:	01000084 	movi	r4,2
 3226f18:	e13ffe15 	stw	r4,-8(fp)
 3226f1c:	0001cc06 	br	3227650 <dhc_upcall+0x814>
   }

   /* punt offers or replys which are not for me */
   if(MEMCMP(bp->chaddr, pkt->net->mib.ifPhysAddress, pkt->net->n_hal))
 3226f20:	e0bffa17 	ldw	r2,-24(fp)
 3226f24:	11000704 	addi	r4,r2,28
 3226f28:	e0bffb17 	ldw	r2,-20(fp)
 3226f2c:	10800617 	ldw	r2,24(r2)
 3226f30:	11401717 	ldw	r5,92(r2)
 3226f34:	e0bffb17 	ldw	r2,-20(fp)
 3226f38:	10800617 	ldw	r2,24(r2)
 3226f3c:	11801117 	ldw	r6,68(r2)
 3226f40:	324b95c0 	call	324b95c <memcmp>
 3226f44:	1005003a 	cmpeq	r2,r2,zero
 3226f48:	1000031e 	bne	r2,zero,3226f58 <dhc_upcall+0x11c>
      return ENP_NOT_MINE;    /* not an error, just ignore it */
 3226f4c:	00800084 	movi	r2,2
 3226f50:	e0bffe15 	stw	r2,-8(fp)
 3226f54:	0001be06 	br	3227650 <dhc_upcall+0x814>

   /* see if it's full DHCP or plain bootp by looking for dhcp type option */
   opts = find_opt(DHOP_TYPE ,&bp->options[4]);
 3226f58:	e0bffa17 	ldw	r2,-24(fp)
 3226f5c:	10803b04 	addi	r2,r2,236
 3226f60:	11400104 	addi	r5,r2,4
 3226f64:	01000d44 	movi	r4,53
 3226f68:	3229bec0 	call	3229bec <find_opt>
 3226f6c:	e0bff515 	stw	r2,-44(fp)
   if (opts && *opts == DHOP_TYPE)
 3226f70:	e0bff517 	ldw	r2,-44(fp)
 3226f74:	1005003a 	cmpeq	r2,r2,zero
 3226f78:	1000101e 	bne	r2,zero,3226fbc <dhc_upcall+0x180>
 3226f7c:	e0bff517 	ldw	r2,-44(fp)
 3226f80:	10800003 	ldbu	r2,0(r2)
 3226f84:	10803fcc 	andi	r2,r2,255
 3226f88:	10800d58 	cmpnei	r2,r2,53
 3226f8c:	10000b1e 	bne	r2,zero,3226fbc <dhc_upcall+0x180>
   {
      dhcptype = *(opts+2);
 3226f90:	e0bff517 	ldw	r2,-44(fp)
 3226f94:	10800084 	addi	r2,r2,2
 3226f98:	10800003 	ldbu	r2,0(r2)
 3226f9c:	10803fcc 	andi	r2,r2,255
 3226fa0:	e0bff815 	stw	r2,-32(fp)
      bp->op |= ISDHCP;       /* tag packet for isdhcp() macro */
 3226fa4:	e0bffa17 	ldw	r2,-24(fp)
 3226fa8:	10800003 	ldbu	r2,0(r2)
 3226fac:	10800114 	ori	r2,r2,4
 3226fb0:	1007883a 	mov	r3,r2
 3226fb4:	e0bffa17 	ldw	r2,-24(fp)
 3226fb8:	10c00005 	stb	r3,0(r2)
   }

   if (isdhcp(bp))
 3226fbc:	e0bffa17 	ldw	r2,-24(fp)
 3226fc0:	10800003 	ldbu	r2,0(r2)
 3226fc4:	10803fcc 	andi	r2,r2,255
 3226fc8:	1080010c 	andi	r2,r2,4
 3226fcc:	1005003a 	cmpeq	r2,r2,zero
 3226fd0:	10017e1e 	bne	r2,zero,32275cc <dhc_upcall+0x790>
   {
      switch (dhcptype)
 3226fd4:	e0fff817 	ldw	r3,-32(fp)
 3226fd8:	e0ffff15 	stw	r3,-4(fp)
 3226fdc:	e13fff17 	ldw	r4,-4(fp)
 3226fe0:	20800148 	cmpgei	r2,r4,5
 3226fe4:	1000071e 	bne	r2,zero,3227004 <dhc_upcall+0x1c8>
 3226fe8:	e0ffff17 	ldw	r3,-4(fp)
 3226fec:	188000c8 	cmpgei	r2,r3,3
 3226ff0:	1000081e 	bne	r2,zero,3227014 <dhc_upcall+0x1d8>
 3226ff4:	e13fff17 	ldw	r4,-4(fp)
 3226ff8:	20800060 	cmpeqi	r2,r4,1
 3226ffc:	1000051e 	bne	r2,zero,3227014 <dhc_upcall+0x1d8>
 3227000:	00000a06 	br	322702c <dhc_upcall+0x1f0>
 3227004:	e0ffff17 	ldw	r3,-4(fp)
 3227008:	188001e0 	cmpeqi	r2,r3,7
 322700c:	1000011e 	bne	r2,zero,3227014 <dhc_upcall+0x1d8>
 3227010:	00000606 	br	322702c <dhc_upcall+0x1f0>
      {
      case DHCP_DISCOVER:
      case DHCP_REQUEST:
      case DHCP_DECLINE:
      case DHCP_RELEASE:
         dsc_errors++;     /* these should only be upcalled to a server */
 3227014:	d0a8c717 	ldw	r2,-23780(gp)
 3227018:	10800044 	addi	r2,r2,1
 322701c:	d0a8c715 	stw	r2,-23780(gp)
         return ENP_NOT_MINE;
 3227020:	01000084 	movi	r4,2
 3227024:	e13ffe15 	stw	r4,-8(fp)
 3227028:	00018906 	br	3227650 <dhc_upcall+0x814>
      }

      switch (dhc_states[iface].state)
 322702c:	e0bff617 	ldw	r2,-40(fp)
 3227030:	00c0c9b4 	movhi	r3,806
 3227034:	18f28004 	addi	r3,r3,-13824
 3227038:	10800f24 	muli	r2,r2,60
 322703c:	10c5883a 	add	r2,r2,r3
 3227040:	10800017 	ldw	r2,0(r2)
 3227044:	e0bffd15 	stw	r2,-12(fp)
 3227048:	e0fffd17 	ldw	r3,-12(fp)
 322704c:	18800268 	cmpgeui	r2,r3,9
 3227050:	1001541e 	bne	r2,zero,32275a4 <dhc_upcall+0x768>
 3227054:	e13ffd17 	ldw	r4,-12(fp)
 3227058:	e13ffd17 	ldw	r4,-12(fp)
 322705c:	2105883a 	add	r2,r4,r4
 3227060:	1087883a 	add	r3,r2,r2
 3227064:	0080c8b4 	movhi	r2,802
 3227068:	109c1e04 	addi	r2,r2,28792
 322706c:	1885883a 	add	r2,r3,r2
 3227070:	10800017 	ldw	r2,0(r2)
 3227074:	1000683a 	jmp	r2
 3227078:	032275a4 	muli	r12,zero,-30250
 322707c:	0322709c 	xori	r12,zero,35266
 3227080:	0322709c 	xori	r12,zero,35266
 3227084:	032272f0 	cmpltui	r12,zero,35275
 3227088:	032270b4 	movhi	r12,35266
 322708c:	03227238 	rdprs	r12,zero,-30264
 3227090:	0322709c 	xori	r12,zero,35266
 3227094:	03227238 	rdprs	r12,zero,-30264
 3227098:	03227238 	rdprs	r12,zero,-30264
      case DHCS_INITREBOOT:
         /* How can we receive any response when we never sent one */
      case DHCS_BOUND:
         /* If there are multiple DHCP Servers, and one of them is slow
            in responding, we might get OFFER pkts when are in BOUND state */
         dsc_errors++;     /* these should only be upcalled to a server */
 322709c:	d0a8c717 	ldw	r2,-23780(gp)
 32270a0:	10800044 	addi	r2,r2,1
 32270a4:	d0a8c715 	stw	r2,-23780(gp)
         return ENP_NOT_MINE;
 32270a8:	00800084 	movi	r2,2
 32270ac:	e0bffe15 	stw	r2,-8(fp)
 32270b0:	00016706 	br	3227650 <dhc_upcall+0x814>
      case DHCS_SELECTING:
         /* We will respond to the first offer packet that we receive ) */
         if ( dhcptype == DHCP_OFFER ) /* got offer back from server */
 32270b4:	e0bff817 	ldw	r2,-32(fp)
 32270b8:	10800098 	cmpnei	r2,r2,2
 32270bc:	1000521e 	bne	r2,zero,3227208 <dhc_upcall+0x3cc>
         {
            dsc_offers++;
 32270c0:	d0a8c917 	ldw	r2,-23772(gp)
 32270c4:	10800044 	addi	r2,r2,1
 32270c8:	d0a8c915 	stw	r2,-23772(gp)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]);
 32270cc:	e43ff617 	ldw	r16,-40(fp)
 32270d0:	e0bffa17 	ldw	r2,-24(fp)
 32270d4:	10803b04 	addi	r2,r2,236
 32270d8:	11000104 	addi	r4,r2,4
 32270dc:	3226cac0 	call	3226cac <dhc_get_srv_ipaddr>
 32270e0:	1009883a 	mov	r4,r2
 32270e4:	00c0c9b4 	movhi	r3,806
 32270e8:	18f28004 	addi	r3,r3,-13824
 32270ec:	80800f24 	muli	r2,r16,60
 32270f0:	10c5883a 	add	r2,r2,r3
 32270f4:	10800d04 	addi	r2,r2,52
 32270f8:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 32270fc:	e0bff617 	ldw	r2,-40(fp)
 3227100:	00c0c9b4 	movhi	r3,806
 3227104:	18f28004 	addi	r3,r3,-13824
 3227108:	10800f24 	muli	r2,r2,60
 322710c:	10c5883a 	add	r2,r2,r3
 3227110:	10800d04 	addi	r2,r2,52
 3227114:	10800017 	ldw	r2,0(r2)
 3227118:	1004c03a 	cmpne	r2,r2,zero
 322711c:	10000d1e 	bne	r2,zero,3227154 <dhc_upcall+0x318>
            {
               dtrap(); /* didn't receive server-identifier option */
 3227120:	322ab8c0 	call	322ab8c <dtrap>
               dsc_errors++;
 3227124:	d0a8c717 	ldw	r2,-23780(gp)
 3227128:	10800044 	addi	r2,r2,1
 322712c:	d0a8c715 	stw	r2,-23780(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 3227130:	e13ff617 	ldw	r4,-40(fp)
 3227134:	e0bffb17 	ldw	r2,-20(fp)
 3227138:	11400717 	ldw	r5,28(r2)
 322713c:	00c0c9b4 	movhi	r3,806
 3227140:	18f28004 	addi	r3,r3,-13824
 3227144:	20800f24 	muli	r2,r4,60
 3227148:	10c5883a 	add	r2,r2,r3
 322714c:	10800d04 	addi	r2,r2,52
 3227150:	11400015 	stw	r5,0(r2)
            }

            if (bp->hops)
 3227154:	e0bffa17 	ldw	r2,-24(fp)
 3227158:	108000c3 	ldbu	r2,3(r2)
 322715c:	10803fcc 	andi	r2,r2,255
 3227160:	1005003a 	cmpeq	r2,r2,zero
 3227164:	10000a1e 	bne	r2,zero,3227190 <dhc_upcall+0x354>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 3227168:	e13ff617 	ldw	r4,-40(fp)
 322716c:	e0bffb17 	ldw	r2,-20(fp)
 3227170:	11400717 	ldw	r5,28(r2)
 3227174:	00c0c9b4 	movhi	r3,806
 3227178:	18f28004 	addi	r3,r3,-13824
 322717c:	20800f24 	muli	r2,r4,60
 3227180:	10c5883a 	add	r2,r2,r3
 3227184:	10800c04 	addi	r2,r2,48
 3227188:	11400015 	stw	r5,0(r2)
 322718c:	00000706 	br	32271ac <dhc_upcall+0x370>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 3227190:	e0bff617 	ldw	r2,-40(fp)
 3227194:	00c0c9b4 	movhi	r3,806
 3227198:	18f28004 	addi	r3,r3,-13824
 322719c:	10800f24 	muli	r2,r2,60
 32271a0:	10c5883a 	add	r2,r2,r3
 32271a4:	10800c04 	addi	r2,r2,48
 32271a8:	10000015 	stw	zero,0(r2)

            e = dhc_rx_offer(iface,bp,pkt->nb_plen);     /* send request */
 32271ac:	e0bffb17 	ldw	r2,-20(fp)
 32271b0:	11800417 	ldw	r6,16(r2)
 32271b4:	e13ff617 	ldw	r4,-40(fp)
 32271b8:	e17ffa17 	ldw	r5,-24(fp)
 32271bc:	3227da00 	call	3227da0 <dhc_rx_offer>
 32271c0:	e0bff715 	stw	r2,-36(fp)
            if (e)
 32271c4:	e0bff717 	ldw	r2,-36(fp)
 32271c8:	1005003a 	cmpeq	r2,r2,zero
 32271cc:	10000a1e 	bne	r2,zero,32271f8 <dhc_upcall+0x3bc>
            {
               dsc_errors++;
 32271d0:	d0a8c717 	ldw	r2,-23780(gp)
 32271d4:	10800044 	addi	r2,r2,1
 32271d8:	d0a8c715 	stw	r2,-23780(gp)
               dhc_set_state(iface,DHCS_INIT);
 32271dc:	e13ff617 	ldw	r4,-40(fp)
 32271e0:	01400044 	movi	r5,1
 32271e4:	3229b3c0 	call	3229b3c <dhc_set_state>
               dtrap();
 32271e8:	322ab8c0 	call	322ab8c <dtrap>
               return ENP_NOT_MINE;
 32271ec:	00c00084 	movi	r3,2
 32271f0:	e0fffe15 	stw	r3,-8(fp)
 32271f4:	00011606 	br	3227650 <dhc_upcall+0x814>
            }
            else
               dhc_set_state(iface,DHCS_REQUESTING);
 32271f8:	e13ff617 	ldw	r4,-40(fp)
 32271fc:	01400144 	movi	r5,5
 3227200:	3229b3c0 	call	3229b3c <dhc_set_state>
            dsc_errors++;
            if ( dhcptype == DHCP_NAK ) 
               dsc_naks++;
            return ENP_NOT_MINE;
         }
         break;
 3227204:	00010f06 	br	3227644 <dhc_upcall+0x808>
             * Report an error and remain in SELECTING state, so that 
             * an OFFER packet from another DHCP server can be 
             * accepted. If we timeout waiting for a OFFER packet, 
             * then dhc_second() will transition to DHCS_INIT state. 
             */
            dsc_errors++;
 3227208:	d0a8c717 	ldw	r2,-23780(gp)
 322720c:	10800044 	addi	r2,r2,1
 3227210:	d0a8c715 	stw	r2,-23780(gp)
            if ( dhcptype == DHCP_NAK ) 
 3227214:	e0bff817 	ldw	r2,-32(fp)
 3227218:	10800198 	cmpnei	r2,r2,6
 322721c:	1000031e 	bne	r2,zero,322722c <dhc_upcall+0x3f0>
               dsc_naks++;
 3227220:	d0a8cf17 	ldw	r2,-23748(gp)
 3227224:	10800044 	addi	r2,r2,1
 3227228:	d0a8cf15 	stw	r2,-23748(gp)
            return ENP_NOT_MINE;
 322722c:	01000084 	movi	r4,2
 3227230:	e13ffe15 	stw	r4,-8(fp)
 3227234:	00010606 	br	3227650 <dhc_upcall+0x814>
      case DHCS_RENEWING:
         /* If the ACK/NACK is not from the same server which sent 
          * the OFFER packet, then discard it. in DHCS_REBOOTING 
          * state, srv_ipaddr is 0. Hence don't check in that state 
          */
         if ( dhc_states[iface].srv_ipaddr != 
 3227238:	e0bff617 	ldw	r2,-40(fp)
 322723c:	00c0c9b4 	movhi	r3,806
 3227240:	18f28004 	addi	r3,r3,-13824
 3227244:	10800f24 	muli	r2,r2,60
 3227248:	10c5883a 	add	r2,r2,r3
 322724c:	10800d04 	addi	r2,r2,52
 3227250:	14000017 	ldw	r16,0(r2)
 3227254:	e0bffa17 	ldw	r2,-24(fp)
 3227258:	10803b04 	addi	r2,r2,236
 322725c:	11000104 	addi	r4,r2,4
 3227260:	3226cac0 	call	3226cac <dhc_get_srv_ipaddr>
 3227264:	80800626 	beq	r16,r2,3227280 <dhc_upcall+0x444>
             dhc_get_srv_ipaddr(&bp->options[4]) )
         {
            dsc_errors++;
 3227268:	d0a8c717 	ldw	r2,-23780(gp)
 322726c:	10800044 	addi	r2,r2,1
 3227270:	d0a8c715 	stw	r2,-23780(gp)
            return ENP_NOT_MINE;
 3227274:	00800084 	movi	r2,2
 3227278:	e0bffe15 	stw	r2,-8(fp)
 322727c:	0000f406 	br	3227650 <dhc_upcall+0x814>
         }
         if (dhc_states[iface].rly_ipaddr &&
 3227280:	e0bff617 	ldw	r2,-40(fp)
 3227284:	00c0c9b4 	movhi	r3,806
 3227288:	18f28004 	addi	r3,r3,-13824
 322728c:	10800f24 	muli	r2,r2,60
 3227290:	10c5883a 	add	r2,r2,r3
 3227294:	10800c04 	addi	r2,r2,48
 3227298:	10800017 	ldw	r2,0(r2)
 322729c:	1005003a 	cmpeq	r2,r2,zero
 32272a0:	1000131e 	bne	r2,zero,32272f0 <dhc_upcall+0x4b4>
 32272a4:	e0bff617 	ldw	r2,-40(fp)
 32272a8:	00c0c9b4 	movhi	r3,806
 32272ac:	18f28004 	addi	r3,r3,-13824
 32272b0:	10800f24 	muli	r2,r2,60
 32272b4:	10c5883a 	add	r2,r2,r3
 32272b8:	10800c04 	addi	r2,r2,48
 32272bc:	10c00017 	ldw	r3,0(r2)
 32272c0:	e0bffb17 	ldw	r2,-20(fp)
 32272c4:	10800717 	ldw	r2,28(r2)
 32272c8:	18800926 	beq	r3,r2,32272f0 <dhc_upcall+0x4b4>
            (dhc_states[iface].rly_ipaddr != pkt->fhost))
         {
            dsc_rlyerrs++;
 32272cc:	d0a8d217 	ldw	r2,-23736(gp)
 32272d0:	10800044 	addi	r2,r2,1
 32272d4:	d0a8d215 	stw	r2,-23736(gp)
            dsc_errors++;
 32272d8:	d0a8c717 	ldw	r2,-23780(gp)
 32272dc:	10800044 	addi	r2,r2,1
 32272e0:	d0a8c715 	stw	r2,-23780(gp)
            return ENP_NOT_MINE;
 32272e4:	00c00084 	movi	r3,2
 32272e8:	e0fffe15 	stw	r3,-8(fp)
 32272ec:	0000d806 	br	3227650 <dhc_upcall+0x814>
         }
      case DHCS_REBOOTING:
         if ( dhcptype == DHCP_ACK )   /* Server OKed our request */
 32272f0:	e0bff817 	ldw	r2,-32(fp)
 32272f4:	10800158 	cmpnei	r2,r2,5
 32272f8:	1000891e 	bne	r2,zero,3227520 <dhc_upcall+0x6e4>
         {
            dsc_acks++;
 32272fc:	d0a8cb17 	ldw	r2,-23764(gp)
 3227300:	10800044 	addi	r2,r2,1
 3227304:	d0a8cb15 	stw	r2,-23764(gp)
            dhc_extract_opts(iface,&bp->options[4]);
 3227308:	e0bffa17 	ldw	r2,-24(fp)
 322730c:	10803b04 	addi	r2,r2,236
 3227310:	11400104 	addi	r5,r2,4
 3227314:	e13ff617 	ldw	r4,-40(fp)
 3227318:	3228f280 	call	3228f28 <dhc_extract_opts>
            if ( dhc_states[iface].lease == DHC_INFINITY )
 322731c:	e0bff617 	ldw	r2,-40(fp)
 3227320:	00c0c9b4 	movhi	r3,806
 3227324:	18f28004 	addi	r3,r3,-13824
 3227328:	10800f24 	muli	r2,r2,60
 322732c:	10c5883a 	add	r2,r2,r3
 3227330:	10800504 	addi	r2,r2,20
 3227334:	10800017 	ldw	r2,0(r2)
 3227338:	10bfffd8 	cmpnei	r2,r2,-1
 322733c:	1000111e 	bne	r2,zero,3227384 <dhc_upcall+0x548>
            {
               dhc_states[iface].t1 = DHC_INFINITY ;
 3227340:	e0bff617 	ldw	r2,-40(fp)
 3227344:	00c0c9b4 	movhi	r3,806
 3227348:	18f28004 	addi	r3,r3,-13824
 322734c:	10800f24 	muli	r2,r2,60
 3227350:	10c5883a 	add	r2,r2,r3
 3227354:	10c00604 	addi	r3,r2,24
 3227358:	00bfffc4 	movi	r2,-1
 322735c:	18800015 	stw	r2,0(r3)
               dhc_states[iface].t2 = DHC_INFINITY ;
 3227360:	e0bff617 	ldw	r2,-40(fp)
 3227364:	00c0c9b4 	movhi	r3,806
 3227368:	18f28004 	addi	r3,r3,-13824
 322736c:	10800f24 	muli	r2,r2,60
 3227370:	10c5883a 	add	r2,r2,r3
 3227374:	10c00704 	addi	r3,r2,28
 3227378:	00bfffc4 	movi	r2,-1
 322737c:	18800015 	stw	r2,0(r3)
 3227380:	00001f06 	br	3227400 <dhc_upcall+0x5c4>
            }
            else
            {
               dhc_states[iface].t1 = dhc_states[iface].lease/2     ;
 3227384:	e17ff617 	ldw	r5,-40(fp)
 3227388:	e0bff617 	ldw	r2,-40(fp)
 322738c:	00c0c9b4 	movhi	r3,806
 3227390:	18f28004 	addi	r3,r3,-13824
 3227394:	10800f24 	muli	r2,r2,60
 3227398:	10c5883a 	add	r2,r2,r3
 322739c:	10800504 	addi	r2,r2,20
 32273a0:	10800017 	ldw	r2,0(r2)
 32273a4:	1008d07a 	srli	r4,r2,1
 32273a8:	00c0c9b4 	movhi	r3,806
 32273ac:	18f28004 	addi	r3,r3,-13824
 32273b0:	28800f24 	muli	r2,r5,60
 32273b4:	10c5883a 	add	r2,r2,r3
 32273b8:	10800604 	addi	r2,r2,24
 32273bc:	11000015 	stw	r4,0(r2)
               dhc_states[iface].t2 = (dhc_states[iface].lease/8)*7 ;
 32273c0:	e17ff617 	ldw	r5,-40(fp)
 32273c4:	e0bff617 	ldw	r2,-40(fp)
 32273c8:	00c0c9b4 	movhi	r3,806
 32273cc:	18f28004 	addi	r3,r3,-13824
 32273d0:	10800f24 	muli	r2,r2,60
 32273d4:	10c5883a 	add	r2,r2,r3
 32273d8:	10800504 	addi	r2,r2,20
 32273dc:	10800017 	ldw	r2,0(r2)
 32273e0:	1004d0fa 	srli	r2,r2,3
 32273e4:	110001e4 	muli	r4,r2,7
 32273e8:	00c0c9b4 	movhi	r3,806
 32273ec:	18f28004 	addi	r3,r3,-13824
 32273f0:	28800f24 	muli	r2,r5,60
 32273f4:	10c5883a 	add	r2,r2,r3
 32273f8:	10800704 	addi	r2,r2,28
 32273fc:	11000015 	stw	r4,0(r2)
            }
            dhc_states[iface].lease_start = cticks;   /* to calc lease expiry */
 3227400:	e13ff617 	ldw	r4,-40(fp)
 3227404:	0080c974 	movhi	r2,805
 3227408:	10925604 	addi	r2,r2,18776
 322740c:	11400017 	ldw	r5,0(r2)
 3227410:	00c0c9b4 	movhi	r3,806
 3227414:	18f28004 	addi	r3,r3,-13824
 3227418:	20800f24 	muli	r2,r4,60
 322741c:	10c5883a 	add	r2,r2,r3
 3227420:	10800804 	addi	r2,r2,32
 3227424:	11400015 	stw	r5,0(r2)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]); 
 3227428:	e43ff617 	ldw	r16,-40(fp)
 322742c:	e0bffa17 	ldw	r2,-24(fp)
 3227430:	10803b04 	addi	r2,r2,236
 3227434:	11000104 	addi	r4,r2,4
 3227438:	3226cac0 	call	3226cac <dhc_get_srv_ipaddr>
 322743c:	1009883a 	mov	r4,r2
 3227440:	00c0c9b4 	movhi	r3,806
 3227444:	18f28004 	addi	r3,r3,-13824
 3227448:	80800f24 	muli	r2,r16,60
 322744c:	10c5883a 	add	r2,r2,r3
 3227450:	10800d04 	addi	r2,r2,52
 3227454:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 3227458:	e0bff617 	ldw	r2,-40(fp)
 322745c:	00c0c9b4 	movhi	r3,806
 3227460:	18f28004 	addi	r3,r3,-13824
 3227464:	10800f24 	muli	r2,r2,60
 3227468:	10c5883a 	add	r2,r2,r3
 322746c:	10800d04 	addi	r2,r2,52
 3227470:	10800017 	ldw	r2,0(r2)
 3227474:	1004c03a 	cmpne	r2,r2,zero
 3227478:	10000d1e 	bne	r2,zero,32274b0 <dhc_upcall+0x674>
            {
               dtrap(); /* didn't receive server-identifier option */
 322747c:	322ab8c0 	call	322ab8c <dtrap>
               dsc_errors++;
 3227480:	d0a8c717 	ldw	r2,-23780(gp)
 3227484:	10800044 	addi	r2,r2,1
 3227488:	d0a8c715 	stw	r2,-23780(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 322748c:	e13ff617 	ldw	r4,-40(fp)
 3227490:	e0bffb17 	ldw	r2,-20(fp)
 3227494:	11400717 	ldw	r5,28(r2)
 3227498:	00c0c9b4 	movhi	r3,806
 322749c:	18f28004 	addi	r3,r3,-13824
 32274a0:	20800f24 	muli	r2,r4,60
 32274a4:	10c5883a 	add	r2,r2,r3
 32274a8:	10800d04 	addi	r2,r2,52
 32274ac:	11400015 	stw	r5,0(r2)
            }
            if (bp->hops)
 32274b0:	e0bffa17 	ldw	r2,-24(fp)
 32274b4:	108000c3 	ldbu	r2,3(r2)
 32274b8:	10803fcc 	andi	r2,r2,255
 32274bc:	1005003a 	cmpeq	r2,r2,zero
 32274c0:	10000a1e 	bne	r2,zero,32274ec <dhc_upcall+0x6b0>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 32274c4:	e13ff617 	ldw	r4,-40(fp)
 32274c8:	e0bffb17 	ldw	r2,-20(fp)
 32274cc:	11400717 	ldw	r5,28(r2)
 32274d0:	00c0c9b4 	movhi	r3,806
 32274d4:	18f28004 	addi	r3,r3,-13824
 32274d8:	20800f24 	muli	r2,r4,60
 32274dc:	10c5883a 	add	r2,r2,r3
 32274e0:	10800c04 	addi	r2,r2,48
 32274e4:	11400015 	stw	r5,0(r2)
 32274e8:	00000706 	br	3227508 <dhc_upcall+0x6cc>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 32274ec:	e0bff617 	ldw	r2,-40(fp)
 32274f0:	00c0c9b4 	movhi	r3,806
 32274f4:	18f28004 	addi	r3,r3,-13824
 32274f8:	10800f24 	muli	r2,r2,60
 32274fc:	10c5883a 	add	r2,r2,r3
 3227500:	10800c04 	addi	r2,r2,48
 3227504:	10000015 	stw	zero,0(r2)

            dhc_setip(iface);
 3227508:	e13ff617 	ldw	r4,-40(fp)
 322750c:	32289e00 	call	32289e0 <dhc_setip>
            dhc_set_state(iface,DHCS_BOUND);
 3227510:	e13ff617 	ldw	r4,-40(fp)
 3227514:	01400184 	movi	r5,6
 3227518:	3229b3c0 	call	3229b3c <dhc_set_state>
 322751c:	00004906 	br	3227644 <dhc_upcall+0x808>
         }
         else if ( dhcptype == DHCP_NAK ) /* Server denied our request */
 3227520:	e0bff817 	ldw	r2,-32(fp)
 3227524:	10800198 	cmpnei	r2,r2,6
 3227528:	1000071e 	bne	r2,zero,3227548 <dhc_upcall+0x70c>
         {
            dhc_set_state(iface,DHCS_INIT);
 322752c:	e13ff617 	ldw	r4,-40(fp)
 3227530:	01400044 	movi	r5,1
 3227534:	3229b3c0 	call	3229b3c <dhc_set_state>
            dsc_naks++;
 3227538:	d0a8cf17 	ldw	r2,-23748(gp)
 322753c:	10800044 	addi	r2,r2,1
 3227540:	d0a8cf15 	stw	r2,-23748(gp)
 3227544:	00003f06 	br	3227644 <dhc_upcall+0x808>
         {
            /* In REQUESTING state, we might receive a retransmitted
             * OFFER, which we should discard, but it's not an error,
             * so we log it.
             */
            if ((dhc_states[iface].state == DHCS_REQUESTING) &&
 3227548:	e0bff617 	ldw	r2,-40(fp)
 322754c:	00c0c9b4 	movhi	r3,806
 3227550:	18f28004 	addi	r3,r3,-13824
 3227554:	10800f24 	muli	r2,r2,60
 3227558:	10c5883a 	add	r2,r2,r3
 322755c:	10800017 	ldw	r2,0(r2)
 3227560:	10800158 	cmpnei	r2,r2,5
 3227564:	1000091e 	bne	r2,zero,322758c <dhc_upcall+0x750>
 3227568:	e0bff817 	ldw	r2,-32(fp)
 322756c:	10800098 	cmpnei	r2,r2,2
 3227570:	1000061e 	bne	r2,zero,322758c <dhc_upcall+0x750>
                (dhcptype == DHCP_OFFER))
            {
               dsc_offers++;
 3227574:	d0a8c917 	ldw	r2,-23772(gp)
 3227578:	10800044 	addi	r2,r2,1
 322757c:	d0a8c915 	stw	r2,-23772(gp)
               return ENP_NOT_MINE;
 3227580:	01000084 	movi	r4,2
 3227584:	e13ffe15 	stw	r4,-8(fp)
 3227588:	00003106 	br	3227650 <dhc_upcall+0x814>
             * only receive ACK or NAK, and in REQUESTING state we
             * should only receive ACK or NAK or OFFER; these are
             * accounted for above, so we log whatever this is as an
             * error and discard it with no change to our state.
             */
            dsc_errors++;
 322758c:	d0a8c717 	ldw	r2,-23780(gp)
 3227590:	10800044 	addi	r2,r2,1
 3227594:	d0a8c715 	stw	r2,-23780(gp)
            return ENP_NOT_MINE;
 3227598:	00800084 	movi	r2,2
 322759c:	e0bffe15 	stw	r2,-8(fp)
 32275a0:	00002b06 	br	3227650 <dhc_upcall+0x814>
         }
         break;
      default:    /* bad state */
         dtrap();
 32275a4:	322ab8c0 	call	322ab8c <dtrap>
         dhc_set_state(iface,DHCS_INIT);
 32275a8:	e13ff617 	ldw	r4,-40(fp)
 32275ac:	01400044 	movi	r5,1
 32275b0:	3229b3c0 	call	3229b3c <dhc_set_state>
         dsc_errors++;
 32275b4:	d0a8c717 	ldw	r2,-23780(gp)
 32275b8:	10800044 	addi	r2,r2,1
 32275bc:	d0a8c715 	stw	r2,-23780(gp)
         return -1;
 32275c0:	00ffffc4 	movi	r3,-1
 32275c4:	e0fffe15 	stw	r3,-8(fp)
 32275c8:	00002106 	br	3227650 <dhc_upcall+0x814>
      }
   }
   else     /* plain bootp reply */
   {
      dsc_bpreplys++;
 32275cc:	d0a8cc17 	ldw	r2,-23760(gp)
 32275d0:	10800044 	addi	r2,r2,1
 32275d4:	d0a8cc15 	stw	r2,-23760(gp)
      dhc_extract_opts(iface,&bp->options[4]);
 32275d8:	e0bffa17 	ldw	r2,-24(fp)
 32275dc:	10803b04 	addi	r2,r2,236
 32275e0:	11400104 	addi	r5,r2,4
 32275e4:	e13ff617 	ldw	r4,-40(fp)
 32275e8:	3228f280 	call	3228f28 <dhc_extract_opts>
      dhc_states[iface].ipaddr = bp->yiaddr;
 32275ec:	e13ff617 	ldw	r4,-40(fp)
 32275f0:	e0bffa17 	ldw	r2,-24(fp)
 32275f4:	11400417 	ldw	r5,16(r2)
 32275f8:	00c0c9b4 	movhi	r3,806
 32275fc:	18f28004 	addi	r3,r3,-13824
 3227600:	20800f24 	muli	r2,r4,60
 3227604:	10c5883a 	add	r2,r2,r3
 3227608:	10800904 	addi	r2,r2,36
 322760c:	11400015 	stw	r5,0(r2)
      dhc_setip(iface);
 3227610:	e13ff617 	ldw	r4,-40(fp)
 3227614:	32289e00 	call	32289e0 <dhc_setip>

      /* Set values so that DHCP State Machine remains happy */
      dhc_set_state(iface,DHCS_BOUND);
 3227618:	e13ff617 	ldw	r4,-40(fp)
 322761c:	01400184 	movi	r5,6
 3227620:	3229b3c0 	call	3229b3c <dhc_set_state>
      dhc_states[iface].t1    = DHC_INFINITY ;
 3227624:	e0bff617 	ldw	r2,-40(fp)
 3227628:	00c0c9b4 	movhi	r3,806
 322762c:	18f28004 	addi	r3,r3,-13824
 3227630:	10800f24 	muli	r2,r2,60
 3227634:	10c5883a 	add	r2,r2,r3
 3227638:	10c00604 	addi	r3,r2,24
 322763c:	00bfffc4 	movi	r2,-1
 3227640:	18800015 	stw	r2,0(r3)
   }

   udp_free(pkt);
 3227644:	e13ffb17 	ldw	r4,-20(fp)
 3227648:	324527c0 	call	324527c <udp_free>
   return 0;
 322764c:	e03ffe15 	stw	zero,-8(fp)
 3227650:	e0bffe17 	ldw	r2,-8(fp)
}
 3227654:	e037883a 	mov	sp,fp
 3227658:	dfc00217 	ldw	ra,8(sp)
 322765c:	df000117 	ldw	fp,4(sp)
 3227660:	dc000017 	ldw	r16,0(sp)
 3227664:	dec00304 	addi	sp,sp,12
 3227668:	f800283a 	ret

0322766c <dhc_buildheader>:
 * RETURNS: Returns 0 on success, else an ENP_ error code. 
 */

int
dhc_buildheader(int iface, struct bootp * outbp)
{
 322766c:	defff804 	addi	sp,sp,-32
 3227670:	dfc00715 	stw	ra,28(sp)
 3227674:	df000615 	stw	fp,24(sp)
 3227678:	df000604 	addi	fp,sp,24
 322767c:	e13ffb15 	stw	r4,-20(fp)
 3227680:	e17ffc15 	stw	r5,-16(fp)
   int   addrlen;    /* length of hardware address */

   MEMSET(outbp, 0, sizeof(struct bootp));   /* most of this is 0 anyway */
 3227684:	e0bffc17 	ldw	r2,-16(fp)
 3227688:	1009883a 	mov	r4,r2
 322768c:	01804b04 	movi	r6,300
 3227690:	000b883a 	mov	r5,zero
 3227694:	320694c0 	call	320694c <memset>
   outbp->op = BOOTREQUEST;
 3227698:	e0fffc17 	ldw	r3,-16(fp)
 322769c:	00800044 	movi	r2,1
 32276a0:	18800005 	stb	r2,0(r3)

   /* map SNMPish hardware types into bootp types */
   switch (nets[iface]->n_mib->ifType)
 32276a4:	e0bffb17 	ldw	r2,-20(fp)
 32276a8:	00c0c9b4 	movhi	r3,806
 32276ac:	18f25a04 	addi	r3,r3,-13976
 32276b0:	1085883a 	add	r2,r2,r2
 32276b4:	1085883a 	add	r2,r2,r2
 32276b8:	10c5883a 	add	r2,r2,r3
 32276bc:	10800017 	ldw	r2,0(r2)
 32276c0:	10802717 	ldw	r2,156(r2)
 32276c4:	10800217 	ldw	r2,8(r2)
 32276c8:	e0bfff15 	stw	r2,-4(fp)
 32276cc:	e0ffff17 	ldw	r3,-4(fp)
 32276d0:	188005e0 	cmpeqi	r2,r3,23
 32276d4:	10000b1e 	bne	r2,zero,3227704 <dhc_buildheader+0x98>
 32276d8:	e0ffff17 	ldw	r3,-4(fp)
 32276dc:	18800720 	cmpeqi	r2,r3,28
 32276e0:	1000081e 	bne	r2,zero,3227704 <dhc_buildheader+0x98>
 32276e4:	e0ffff17 	ldw	r3,-4(fp)
 32276e8:	188001a0 	cmpeqi	r2,r3,6
 32276ec:	1000011e 	bne	r2,zero,32276f4 <dhc_buildheader+0x88>
 32276f0:	00000806 	br	3227714 <dhc_buildheader+0xa8>
   {
   case ETHERNET:       /* ETHERNET defined in net.h */
      outbp->htype = ETHHWTYPE;  /* defined in dhcp.h */
 32276f4:	e0fffc17 	ldw	r3,-16(fp)
 32276f8:	00800044 	movi	r2,1
 32276fc:	18800045 	stb	r2,1(r3)
   break;
 3227700:	00000806 	br	3227724 <dhc_buildheader+0xb8>
   case PPP:
   case SLIP:
      outbp->htype = LINEHWTYPE;    /* line type for PPP or SLIP */
 3227704:	e0fffc17 	ldw	r3,-16(fp)
 3227708:	00800504 	movi	r2,20
 322770c:	18800045 	stb	r2,1(r3)
   break;
 3227710:	00000406 	br	3227724 <dhc_buildheader+0xb8>
      default:
      dtrap();
 3227714:	322ab8c0 	call	322ab8c <dtrap>
      return ENP_LOGIC;             /* this shouldn't happen */
 3227718:	00bffd44 	movi	r2,-11
 322771c:	e0bffe15 	stw	r2,-8(fp)
 3227720:	00005306 	br	3227870 <dhc_buildheader+0x204>
   }

   addrlen = min(16, nets[iface]->n_hal);
 3227724:	e0bffb17 	ldw	r2,-20(fp)
 3227728:	00c0c9b4 	movhi	r3,806
 322772c:	18f25a04 	addi	r3,r3,-13976
 3227730:	1085883a 	add	r2,r2,r2
 3227734:	1085883a 	add	r2,r2,r2
 3227738:	10c5883a 	add	r2,r2,r3
 322773c:	10800017 	ldw	r2,0(r2)
 3227740:	10801117 	ldw	r2,68(r2)
 3227744:	e0bffd15 	stw	r2,-12(fp)
 3227748:	e0fffd17 	ldw	r3,-12(fp)
 322774c:	18800470 	cmpltui	r2,r3,17
 3227750:	1000021e 	bne	r2,zero,322775c <dhc_buildheader+0xf0>
 3227754:	00800404 	movi	r2,16
 3227758:	e0bffd15 	stw	r2,-12(fp)
 322775c:	e0fffd17 	ldw	r3,-12(fp)
 3227760:	e0fffa15 	stw	r3,-24(fp)
   outbp->hlen = (u_char)addrlen;
 3227764:	e0bffa17 	ldw	r2,-24(fp)
 3227768:	1007883a 	mov	r3,r2
 322776c:	e0bffc17 	ldw	r2,-16(fp)
 3227770:	10c00085 	stb	r3,2(r2)
   outbp->hops = 0;
 3227774:	e0bffc17 	ldw	r2,-16(fp)
 3227778:	100000c5 	stb	zero,3(r2)
   if(dhc_states[iface].state == DHCS_RENEWING) 
 322777c:	e0bffb17 	ldw	r2,-20(fp)
 3227780:	00c0c9b4 	movhi	r3,806
 3227784:	18f28004 	addi	r3,r3,-13824
 3227788:	10800f24 	muli	r2,r2,60
 322778c:	10c5883a 	add	r2,r2,r3
 3227790:	10800017 	ldw	r2,0(r2)
 3227794:	108001d8 	cmpnei	r2,r2,7
 3227798:	1000031e 	bne	r2,zero,32277a8 <dhc_buildheader+0x13c>
      outbp->flags = 0; /* Renewing needs unicast */
 322779c:	e0bffc17 	ldw	r2,-16(fp)
 32277a0:	1000028d 	sth	zero,10(r2)
 32277a4:	00000306 	br	32277b4 <dhc_buildheader+0x148>
   else
      outbp->flags = htons(DHC_BCASTFLAG); /* Othwise broadcast */
 32277a8:	e0fffc17 	ldw	r3,-16(fp)
 32277ac:	00802004 	movi	r2,128
 32277b0:	1880028d 	sth	r2,10(r3)
   outbp->xid = dhc_states[iface].xid;
 32277b4:	e0bffb17 	ldw	r2,-20(fp)
 32277b8:	00c0c9b4 	movhi	r3,806
 32277bc:	18f28004 	addi	r3,r3,-13824
 32277c0:	10800f24 	muli	r2,r2,60
 32277c4:	10c5883a 	add	r2,r2,r3
 32277c8:	10800204 	addi	r2,r2,8
 32277cc:	10c00017 	ldw	r3,0(r2)
 32277d0:	e0bffc17 	ldw	r2,-16(fp)
 32277d4:	10c00115 	stw	r3,4(r2)
   outbp->secs = dhc_states[iface].secs;
 32277d8:	e0bffb17 	ldw	r2,-20(fp)
 32277dc:	00c0c9b4 	movhi	r3,806
 32277e0:	18f28004 	addi	r3,r3,-13824
 32277e4:	10800f24 	muli	r2,r2,60
 32277e8:	10c5883a 	add	r2,r2,r3
 32277ec:	10800304 	addi	r2,r2,12
 32277f0:	10c0000b 	ldhu	r3,0(r2)
 32277f4:	e0bffc17 	ldw	r2,-16(fp)
 32277f8:	10c0020d 	sth	r3,8(r2)
#ifdef NPDEBUG
   /* make sure net[] has a MAC address, even if length is zero */
   if(nets[iface]->mib.ifPhysAddress == NULL)
 32277fc:	e0bffb17 	ldw	r2,-20(fp)
 3227800:	00c0c9b4 	movhi	r3,806
 3227804:	18f25a04 	addi	r3,r3,-13976
 3227808:	1085883a 	add	r2,r2,r2
 322780c:	1085883a 	add	r2,r2,r2
 3227810:	10c5883a 	add	r2,r2,r3
 3227814:	10800017 	ldw	r2,0(r2)
 3227818:	10801717 	ldw	r2,92(r2)
 322781c:	1004c03a 	cmpne	r2,r2,zero
 3227820:	1000041e 	bne	r2,zero,3227834 <dhc_buildheader+0x1c8>
   {
      dtrap();
 3227824:	322ab8c0 	call	322ab8c <dtrap>
      return ENP_LOGIC;
 3227828:	00bffd44 	movi	r2,-11
 322782c:	e0bffe15 	stw	r2,-8(fp)
 3227830:	00000f06 	br	3227870 <dhc_buildheader+0x204>
   }
#endif
   MEMCPY(outbp->chaddr, nets[iface]->mib.ifPhysAddress, addrlen);
 3227834:	e0bffc17 	ldw	r2,-16(fp)
 3227838:	11000704 	addi	r4,r2,28
 322783c:	e0bffb17 	ldw	r2,-20(fp)
 3227840:	00c0c9b4 	movhi	r3,806
 3227844:	18f25a04 	addi	r3,r3,-13976
 3227848:	1085883a 	add	r2,r2,r2
 322784c:	1085883a 	add	r2,r2,r2
 3227850:	10c5883a 	add	r2,r2,r3
 3227854:	10800017 	ldw	r2,0(r2)
 3227858:	10801717 	ldw	r2,92(r2)
 322785c:	e0fffa17 	ldw	r3,-24(fp)
 3227860:	100b883a 	mov	r5,r2
 3227864:	180d883a 	mov	r6,r3
 3227868:	32067cc0 	call	32067cc <memcpy>

   /* return success */
   return 0;
 322786c:	e03ffe15 	stw	zero,-8(fp)
 3227870:	e0bffe17 	ldw	r2,-8(fp)
}
 3227874:	e037883a 	mov	sp,fp
 3227878:	dfc00117 	ldw	ra,4(sp)
 322787c:	df000017 	ldw	fp,0(sp)
 3227880:	dec00204 	addi	sp,sp,8
 3227884:	f800283a 	ret

03227888 <dhc_discover>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_discover(int iface)
{
 3227888:	defff404 	addi	sp,sp,-48
 322788c:	dfc00b15 	stw	ra,44(sp)
 3227890:	df000a15 	stw	fp,40(sp)
 3227894:	dc000915 	stw	r16,36(sp)
 3227898:	df000904 	addi	fp,sp,36
 322789c:	e13ffe15 	stw	r4,-8(fp)
   u_char * opts;       /* scratch pointer to DHCP options field */
   long     leasetime;
   int      e;

   /* get a UDP packet buffer for DHCP sending */
   pkt = udp_alloc(sizeof(struct bootp), 0);
 32278a0:	01004b04 	movi	r4,300
 32278a4:	000b883a 	mov	r5,zero
 32278a8:	32451900 	call	3245190 <udp_alloc>
 32278ac:	e0bffb15 	stw	r2,-20(fp)
   if (!pkt) 
 32278b0:	e0bffb17 	ldw	r2,-20(fp)
 32278b4:	1004c03a 	cmpne	r2,r2,zero
 32278b8:	1000031e 	bne	r2,zero,32278c8 <dhc_discover+0x40>
      return ENP_NOMEM;
 32278bc:	00bffb04 	movi	r2,-20
 32278c0:	e0bfff15 	stw	r2,-4(fp)
 32278c4:	00012f06 	br	3227d84 <dhc_discover+0x4fc>
   pkt->nb_plen = sizeof(struct bootp);
 32278c8:	e0fffb17 	ldw	r3,-20(fp)
 32278cc:	00804b04 	movi	r2,300
 32278d0:	18800415 	stw	r2,16(r3)

   /* start a new DHCP transaction */
   dhc_states[iface].xid = xids++;
 32278d4:	e0bffe17 	ldw	r2,-8(fp)
 32278d8:	d1202f17 	ldw	r4,-32580(gp)
 32278dc:	200b883a 	mov	r5,r4
 32278e0:	00c0c9b4 	movhi	r3,806
 32278e4:	18f28004 	addi	r3,r3,-13824
 32278e8:	10800f24 	muli	r2,r2,60
 32278ec:	10c5883a 	add	r2,r2,r3
 32278f0:	10800204 	addi	r2,r2,8
 32278f4:	11400015 	stw	r5,0(r2)
 32278f8:	20800044 	addi	r2,r4,1
 32278fc:	d0a02f15 	stw	r2,-32580(gp)
   dhc_states[iface].secs = (unsigned short)(sysuptime()/100L);
 3227900:	e43ffe17 	ldw	r16,-8(fp)
 3227904:	323c7e00 	call	323c7e0 <sysuptime>
 3227908:	1009883a 	mov	r4,r2
 322790c:	01401904 	movi	r5,100
 3227910:	32044bc0 	call	32044bc <__udivsi3>
 3227914:	1009883a 	mov	r4,r2
 3227918:	00c0c9b4 	movhi	r3,806
 322791c:	18f28004 	addi	r3,r3,-13824
 3227920:	80800f24 	muli	r2,r16,60
 3227924:	10c5883a 	add	r2,r2,r3
 3227928:	10800304 	addi	r2,r2,12
 322792c:	1100000d 	sth	r4,0(r2)

   /* set up DHCP/BOOTP header in buffer */
   outbp = (struct bootp *)pkt->nb_prot;     /* overlay bootp struct on buffer */
 3227930:	e0bffb17 	ldw	r2,-20(fp)
 3227934:	10800317 	ldw	r2,12(r2)
 3227938:	e0bffa15 	stw	r2,-24(fp)
   e = dhc_buildheader(iface,outbp);
 322793c:	e13ffe17 	ldw	r4,-8(fp)
 3227940:	e17ffa17 	ldw	r5,-24(fp)
 3227944:	322766c0 	call	322766c <dhc_buildheader>
 3227948:	e0bff815 	stw	r2,-32(fp)
   if (e)
 322794c:	e0bff817 	ldw	r2,-32(fp)
 3227950:	1005003a 	cmpeq	r2,r2,zero
 3227954:	1000031e 	bne	r2,zero,3227964 <dhc_discover+0xdc>
      return e;
 3227958:	e0bff817 	ldw	r2,-32(fp)
 322795c:	e0bfff15 	stw	r2,-4(fp)
 3227960:	00010806 	br	3227d84 <dhc_discover+0x4fc>

   /* and turn it into a DHCP DISCOVER packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 3227964:	e0bffa17 	ldw	r2,-24(fp)
 3227968:	10803b04 	addi	r2,r2,236
 322796c:	1007883a 	mov	r3,r2
 3227970:	0098d534 	movhi	r2,25428
 3227974:	10a098c4 	addi	r2,r2,-32157
 3227978:	18800015 	stw	r2,0(r3)
   opts = &outbp->options[4];    /* encode options after cookie */
 322797c:	e0bffa17 	ldw	r2,-24(fp)
 3227980:	10803b04 	addi	r2,r2,236
 3227984:	10800104 	addi	r2,r2,4
 3227988:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHOP_TYPE;
 322798c:	e0fff917 	ldw	r3,-28(fp)
 3227990:	00800d44 	movi	r2,53
 3227994:	18800005 	stb	r2,0(r3)
 3227998:	e0bff917 	ldw	r2,-28(fp)
 322799c:	10800044 	addi	r2,r2,1
 32279a0:	e0bff915 	stw	r2,-28(fp)
   *opts++ = 1;   /* length of option field */
 32279a4:	e0fff917 	ldw	r3,-28(fp)
 32279a8:	00800044 	movi	r2,1
 32279ac:	18800005 	stb	r2,0(r3)
 32279b0:	e0bff917 	ldw	r2,-28(fp)
 32279b4:	10800044 	addi	r2,r2,1
 32279b8:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHCP_DISCOVER;
 32279bc:	e0fff917 	ldw	r3,-28(fp)
 32279c0:	00800044 	movi	r2,1
 32279c4:	18800005 	stb	r2,0(r3)
 32279c8:	e0bff917 	ldw	r2,-28(fp)
 32279cc:	10800044 	addi	r2,r2,1
 32279d0:	e0bff915 	stw	r2,-28(fp)
   leasetime = -1L ;    /* ask for infinite lease */
 32279d4:	00bfffc4 	movi	r2,-1
 32279d8:	e0bffc15 	stw	r2,-16(fp)
   PUT_IP_OPT(opts, DHOP_LEASE, leasetime);
 32279dc:	e0fff917 	ldw	r3,-28(fp)
 32279e0:	00800cc4 	movi	r2,51
 32279e4:	18800005 	stb	r2,0(r3)
 32279e8:	e0bff917 	ldw	r2,-28(fp)
 32279ec:	10800044 	addi	r2,r2,1
 32279f0:	e0bff915 	stw	r2,-28(fp)
 32279f4:	e0fff917 	ldw	r3,-28(fp)
 32279f8:	00800104 	movi	r2,4
 32279fc:	18800005 	stb	r2,0(r3)
 3227a00:	e0bff917 	ldw	r2,-28(fp)
 3227a04:	10800044 	addi	r2,r2,1
 3227a08:	e0bff915 	stw	r2,-28(fp)
 3227a0c:	e0bff917 	ldw	r2,-28(fp)
 3227a10:	10c000c4 	addi	r3,r2,3
 3227a14:	e0bffc04 	addi	r2,fp,-16
 3227a18:	10800003 	ldbu	r2,0(r2)
 3227a1c:	18800005 	stb	r2,0(r3)
 3227a20:	e0bff917 	ldw	r2,-28(fp)
 3227a24:	10c00084 	addi	r3,r2,2
 3227a28:	e0bffc04 	addi	r2,fp,-16
 3227a2c:	10800044 	addi	r2,r2,1
 3227a30:	10800003 	ldbu	r2,0(r2)
 3227a34:	18800005 	stb	r2,0(r3)
 3227a38:	e0bff917 	ldw	r2,-28(fp)
 3227a3c:	10c00044 	addi	r3,r2,1
 3227a40:	e0bffc04 	addi	r2,fp,-16
 3227a44:	10800084 	addi	r2,r2,2
 3227a48:	10800003 	ldbu	r2,0(r2)
 3227a4c:	18800005 	stb	r2,0(r3)
 3227a50:	e0bffc04 	addi	r2,fp,-16
 3227a54:	108000c4 	addi	r2,r2,3
 3227a58:	10800003 	ldbu	r2,0(r2)
 3227a5c:	1007883a 	mov	r3,r2
 3227a60:	e0bff917 	ldw	r2,-28(fp)
 3227a64:	10c00005 	stb	r3,0(r2)
 3227a68:	e0bff917 	ldw	r2,-28(fp)
 3227a6c:	10800104 	addi	r2,r2,4
 3227a70:	e0bff915 	stw	r2,-28(fp)

   /* if we already have an IP address, try to get it from the server */
   if (nets[iface]->n_ipaddr != 0)
 3227a74:	e0bffe17 	ldw	r2,-8(fp)
 3227a78:	00c0c9b4 	movhi	r3,806
 3227a7c:	18f25a04 	addi	r3,r3,-13976
 3227a80:	1085883a 	add	r2,r2,r2
 3227a84:	1085883a 	add	r2,r2,r2
 3227a88:	10c5883a 	add	r2,r2,r3
 3227a8c:	10800017 	ldw	r2,0(r2)
 3227a90:	10800a17 	ldw	r2,40(r2)
 3227a94:	1005003a 	cmpeq	r2,r2,zero
 3227a98:	1000521e 	bne	r2,zero,3227be4 <dhc_discover+0x35c>
   {
      ip_addr my_ip = htonl(nets[iface]->n_ipaddr);
 3227a9c:	e0bffe17 	ldw	r2,-8(fp)
 3227aa0:	00c0c9b4 	movhi	r3,806
 3227aa4:	18f25a04 	addi	r3,r3,-13976
 3227aa8:	1085883a 	add	r2,r2,r2
 3227aac:	1085883a 	add	r2,r2,r2
 3227ab0:	10c5883a 	add	r2,r2,r3
 3227ab4:	10800017 	ldw	r2,0(r2)
 3227ab8:	10800a17 	ldw	r2,40(r2)
 3227abc:	1004d63a 	srli	r2,r2,24
 3227ac0:	11003fcc 	andi	r4,r2,255
 3227ac4:	e0bffe17 	ldw	r2,-8(fp)
 3227ac8:	00c0c9b4 	movhi	r3,806
 3227acc:	18f25a04 	addi	r3,r3,-13976
 3227ad0:	1085883a 	add	r2,r2,r2
 3227ad4:	1085883a 	add	r2,r2,r2
 3227ad8:	10c5883a 	add	r2,r2,r3
 3227adc:	10800017 	ldw	r2,0(r2)
 3227ae0:	10800a17 	ldw	r2,40(r2)
 3227ae4:	1004d23a 	srli	r2,r2,8
 3227ae8:	10bfc00c 	andi	r2,r2,65280
 3227aec:	2088b03a 	or	r4,r4,r2
 3227af0:	e0bffe17 	ldw	r2,-8(fp)
 3227af4:	00c0c9b4 	movhi	r3,806
 3227af8:	18f25a04 	addi	r3,r3,-13976
 3227afc:	1085883a 	add	r2,r2,r2
 3227b00:	1085883a 	add	r2,r2,r2
 3227b04:	10c5883a 	add	r2,r2,r3
 3227b08:	10800017 	ldw	r2,0(r2)
 3227b0c:	10800a17 	ldw	r2,40(r2)
 3227b10:	10bfc00c 	andi	r2,r2,65280
 3227b14:	1004923a 	slli	r2,r2,8
 3227b18:	2088b03a 	or	r4,r4,r2
 3227b1c:	e0bffe17 	ldw	r2,-8(fp)
 3227b20:	00c0c9b4 	movhi	r3,806
 3227b24:	18f25a04 	addi	r3,r3,-13976
 3227b28:	1085883a 	add	r2,r2,r2
 3227b2c:	1085883a 	add	r2,r2,r2
 3227b30:	10c5883a 	add	r2,r2,r3
 3227b34:	10800017 	ldw	r2,0(r2)
 3227b38:	10800a17 	ldw	r2,40(r2)
 3227b3c:	10803fcc 	andi	r2,r2,255
 3227b40:	1004963a 	slli	r2,r2,24
 3227b44:	2084b03a 	or	r2,r4,r2
 3227b48:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, my_ip);
 3227b4c:	e0fff917 	ldw	r3,-28(fp)
 3227b50:	00800c84 	movi	r2,50
 3227b54:	18800005 	stb	r2,0(r3)
 3227b58:	e0bff917 	ldw	r2,-28(fp)
 3227b5c:	10800044 	addi	r2,r2,1
 3227b60:	e0bff915 	stw	r2,-28(fp)
 3227b64:	e0fff917 	ldw	r3,-28(fp)
 3227b68:	00800104 	movi	r2,4
 3227b6c:	18800005 	stb	r2,0(r3)
 3227b70:	e0bff917 	ldw	r2,-28(fp)
 3227b74:	10800044 	addi	r2,r2,1
 3227b78:	e0bff915 	stw	r2,-28(fp)
 3227b7c:	e0bff917 	ldw	r2,-28(fp)
 3227b80:	10c000c4 	addi	r3,r2,3
 3227b84:	e0bffd04 	addi	r2,fp,-12
 3227b88:	10800003 	ldbu	r2,0(r2)
 3227b8c:	18800005 	stb	r2,0(r3)
 3227b90:	e0bff917 	ldw	r2,-28(fp)
 3227b94:	10c00084 	addi	r3,r2,2
 3227b98:	e0bffd04 	addi	r2,fp,-12
 3227b9c:	10800044 	addi	r2,r2,1
 3227ba0:	10800003 	ldbu	r2,0(r2)
 3227ba4:	18800005 	stb	r2,0(r3)
 3227ba8:	e0bff917 	ldw	r2,-28(fp)
 3227bac:	10c00044 	addi	r3,r2,1
 3227bb0:	e0bffd04 	addi	r2,fp,-12
 3227bb4:	10800084 	addi	r2,r2,2
 3227bb8:	10800003 	ldbu	r2,0(r2)
 3227bbc:	18800005 	stb	r2,0(r3)
 3227bc0:	e0bffd04 	addi	r2,fp,-12
 3227bc4:	108000c4 	addi	r2,r2,3
 3227bc8:	10800003 	ldbu	r2,0(r2)
 3227bcc:	1007883a 	mov	r3,r2
 3227bd0:	e0bff917 	ldw	r2,-28(fp)
 3227bd4:	10c00005 	stb	r3,0(r2)
 3227bd8:	e0bff917 	ldw	r2,-28(fp)
 3227bdc:	10800104 	addi	r2,r2,4
 3227be0:	e0bff915 	stw	r2,-28(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 3227be4:	d0a03117 	ldw	r2,-32572(gp)
 3227be8:	10800050 	cmplti	r2,r2,1
 3227bec:	10001e1e 	bne	r2,zero,3227c68 <dhc_discover+0x3e0>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 3227bf0:	e0fff917 	ldw	r3,-28(fp)
 3227bf4:	00800dc4 	movi	r2,55
 3227bf8:	18800005 	stb	r2,0(r3)
 3227bfc:	e0bff917 	ldw	r2,-28(fp)
 3227c00:	10800044 	addi	r2,r2,1
 3227c04:	e0bff915 	stw	r2,-28(fp)
      *opts++ = (u_char)reqlist_len ;
 3227c08:	d0a03117 	ldw	r2,-32572(gp)
 3227c0c:	1007883a 	mov	r3,r2
 3227c10:	e0bff917 	ldw	r2,-28(fp)
 3227c14:	10c00005 	stb	r3,0(r2)
 3227c18:	e0bff917 	ldw	r2,-28(fp)
 3227c1c:	10800044 	addi	r2,r2,1
 3227c20:	e0bff915 	stw	r2,-28(fp)

      for (i=0 ; i < reqlist_len ; i++ )
 3227c24:	e03ff715 	stw	zero,-36(fp)
 3227c28:	00000c06 	br	3227c5c <dhc_discover+0x3d4>
         *opts++ = reqlist[i];
 3227c2c:	e0fff717 	ldw	r3,-36(fp)
 3227c30:	d0a03004 	addi	r2,gp,-32576
 3227c34:	1885883a 	add	r2,r3,r2
 3227c38:	10c00003 	ldbu	r3,0(r2)
 3227c3c:	e0bff917 	ldw	r2,-28(fp)
 3227c40:	10c00005 	stb	r3,0(r2)
 3227c44:	e0bff917 	ldw	r2,-28(fp)
 3227c48:	10800044 	addi	r2,r2,1
 3227c4c:	e0bff915 	stw	r2,-28(fp)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 3227c50:	e0bff717 	ldw	r2,-36(fp)
 3227c54:	10800044 	addi	r2,r2,1
 3227c58:	e0bff715 	stw	r2,-36(fp)
 3227c5c:	d0e03117 	ldw	r3,-32572(gp)
 3227c60:	e0bff717 	ldw	r2,-36(fp)
 3227c64:	10fff116 	blt	r2,r3,3227c2c <dhc_discover+0x3a4>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   *opts++ = DHOP_END;
 3227c68:	e0fff917 	ldw	r3,-28(fp)
 3227c6c:	00bfffc4 	movi	r2,-1
 3227c70:	18800005 	stb	r2,0(r3)
 3227c74:	e0bff917 	ldw	r2,-28(fp)
 3227c78:	10800044 	addi	r2,r2,1
 3227c7c:	e0bff915 	stw	r2,-28(fp)

   /* last_tick needs to be set in case we are doing a retry. It 
    * prevents dhc_second from calling us to do another retry while 
    * we are stuck 
    */
   dhc_states[iface].last_tick = cticks;
 3227c80:	e13ffe17 	ldw	r4,-8(fp)
 3227c84:	0080c974 	movhi	r2,805
 3227c88:	10925604 	addi	r2,r2,18776
 3227c8c:	11400017 	ldw	r5,0(r2)
 3227c90:	00c0c9b4 	movhi	r3,806
 3227c94:	18f28004 	addi	r3,r3,-13824
 3227c98:	20800f24 	muli	r2,r4,60
 3227c9c:	10c5883a 	add	r2,r2,r3
 3227ca0:	10800404 	addi	r2,r2,16
 3227ca4:	11400015 	stw	r5,0(r2)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast discovery request */
 3227ca8:	e0fffb17 	ldw	r3,-20(fp)
 3227cac:	00bfffc4 	movi	r2,-1
 3227cb0:	18800715 	stw	r2,28(r3)
   pkt->net = nets[iface];    /* send out caller spec'ed net */
 3227cb4:	e0bffe17 	ldw	r2,-8(fp)
 3227cb8:	00c0c9b4 	movhi	r3,806
 3227cbc:	18f25a04 	addi	r3,r3,-13976
 3227cc0:	1085883a 	add	r2,r2,r2
 3227cc4:	1085883a 	add	r2,r2,r2
 3227cc8:	10c5883a 	add	r2,r2,r3
 3227ccc:	10c00017 	ldw	r3,0(r2)
 3227cd0:	e0bffb17 	ldw	r2,-20(fp)
 3227cd4:	10c00615 	stw	r3,24(r2)

   /* we need to change the DHCP state before sending to avoid a 
    * race condition with the expected reply 
    */
   if (dhc_states[iface].state != DHCS_SELECTING)
 3227cd8:	e0bffe17 	ldw	r2,-8(fp)
 3227cdc:	00c0c9b4 	movhi	r3,806
 3227ce0:	18f28004 	addi	r3,r3,-13824
 3227ce4:	10800f24 	muli	r2,r2,60
 3227ce8:	10c5883a 	add	r2,r2,r3
 3227cec:	10800017 	ldw	r2,0(r2)
 3227cf0:	10800120 	cmpeqi	r2,r2,4
 3227cf4:	1000031e 	bne	r2,zero,3227d04 <dhc_discover+0x47c>
      dhc_set_state(iface, DHCS_SELECTING);
 3227cf8:	e13ffe17 	ldw	r4,-8(fp)
 3227cfc:	01400104 	movi	r5,4
 3227d00:	3229b3c0 	call	3229b3c <dhc_set_state>

   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 3227d04:	010010c4 	movi	r4,67
 3227d08:	01401104 	movi	r5,68
 3227d0c:	e1bffb17 	ldw	r6,-20(fp)
 3227d10:	3244cd80 	call	3244cd8 <udp_send>
   dsc_discovers++;
 3227d14:	d0a8c817 	ldw	r2,-23776(gp)
 3227d18:	10800044 	addi	r2,r2,1
 3227d1c:	d0a8c815 	stw	r2,-23776(gp)

   /* state info is the same even if udp_send() failed */
   dhc_states[iface].last_tick = cticks;     /* set this again, post udp_send */
 3227d20:	e13ffe17 	ldw	r4,-8(fp)
 3227d24:	0080c974 	movhi	r2,805
 3227d28:	10925604 	addi	r2,r2,18776
 3227d2c:	11400017 	ldw	r5,0(r2)
 3227d30:	00c0c9b4 	movhi	r3,806
 3227d34:	18f28004 	addi	r3,r3,-13824
 3227d38:	20800f24 	muli	r2,r4,60
 3227d3c:	10c5883a 	add	r2,r2,r3
 3227d40:	10800404 	addi	r2,r2,16
 3227d44:	11400015 	stw	r5,0(r2)
   dhc_states[iface].tries++;
 3227d48:	e17ffe17 	ldw	r5,-8(fp)
 3227d4c:	00c0c9b4 	movhi	r3,806
 3227d50:	18f28004 	addi	r3,r3,-13824
 3227d54:	28800f24 	muli	r2,r5,60
 3227d58:	10c5883a 	add	r2,r2,r3
 3227d5c:	10800104 	addi	r2,r2,4
 3227d60:	10800017 	ldw	r2,0(r2)
 3227d64:	11000044 	addi	r4,r2,1
 3227d68:	00c0c9b4 	movhi	r3,806
 3227d6c:	18f28004 	addi	r3,r3,-13824
 3227d70:	28800f24 	muli	r2,r5,60
 3227d74:	10c5883a 	add	r2,r2,r3
 3227d78:	10800104 	addi	r2,r2,4
 3227d7c:	11000015 	stw	r4,0(r2)

   return 0;
 3227d80:	e03fff15 	stw	zero,-4(fp)
 3227d84:	e0bfff17 	ldw	r2,-4(fp)
}
 3227d88:	e037883a 	mov	sp,fp
 3227d8c:	dfc00217 	ldw	ra,8(sp)
 3227d90:	df000117 	ldw	fp,4(sp)
 3227d94:	dc000017 	ldw	r16,0(sp)
 3227d98:	dec00304 	addi	sp,sp,12
 3227d9c:	f800283a 	ret

03227da0 <dhc_rx_offer>:
 * RETURNS: 0 if OK, else ENP_ error
 */

int
dhc_rx_offer(int iface, struct bootp * bp, unsigned bplen)
{
 3227da0:	defff804 	addi	sp,sp,-32
 3227da4:	dfc00715 	stw	ra,28(sp)
 3227da8:	df000615 	stw	fp,24(sp)
 3227dac:	df000604 	addi	fp,sp,24
 3227db0:	e13ffc15 	stw	r4,-16(fp)
 3227db4:	e17ffd15 	stw	r5,-12(fp)
 3227db8:	e1bffe15 	stw	r6,-8(fp)
   u_char * opts;
   int   e;

   if (dhc_states[iface].xid != bp->xid)
 3227dbc:	e0bffc17 	ldw	r2,-16(fp)
 3227dc0:	00c0c9b4 	movhi	r3,806
 3227dc4:	18f28004 	addi	r3,r3,-13824
 3227dc8:	10800f24 	muli	r2,r2,60
 3227dcc:	10c5883a 	add	r2,r2,r3
 3227dd0:	10800204 	addi	r2,r2,8
 3227dd4:	10c00017 	ldw	r3,0(r2)
 3227dd8:	e0bffd17 	ldw	r2,-12(fp)
 3227ddc:	10800117 	ldw	r2,4(r2)
 3227de0:	18800326 	beq	r3,r2,3227df0 <dhc_rx_offer+0x50>
      return ENP_NOT_MINE;
 3227de4:	00800084 	movi	r2,2
 3227de8:	e0bfff15 	stw	r2,-4(fp)
 3227dec:	00002706 	br	3227e8c <dhc_rx_offer+0xec>

   opts = &bp->options[4];    /* examine options after cookie */
 3227df0:	e0bffd17 	ldw	r2,-12(fp)
 3227df4:	10803b04 	addi	r2,r2,236
 3227df8:	10800104 	addi	r2,r2,4
 3227dfc:	e0bffb15 	stw	r2,-20(fp)
   e = dhc_extract_opts(iface,opts);
 3227e00:	e13ffc17 	ldw	r4,-16(fp)
 3227e04:	e17ffb17 	ldw	r5,-20(fp)
 3227e08:	3228f280 	call	3228f28 <dhc_extract_opts>
 3227e0c:	e0bffa15 	stw	r2,-24(fp)
   if (e)   /* parse error? */
 3227e10:	e0bffa17 	ldw	r2,-24(fp)
 3227e14:	1005003a 	cmpeq	r2,r2,zero
 3227e18:	1000041e 	bne	r2,zero,3227e2c <dhc_rx_offer+0x8c>
   {
      dtrap();
 3227e1c:	322ab8c0 	call	322ab8c <dtrap>
      return e;
 3227e20:	e0bffa17 	ldw	r2,-24(fp)
 3227e24:	e0bfff15 	stw	r2,-4(fp)
 3227e28:	00001806 	br	3227e8c <dhc_rx_offer+0xec>
   }
   if (!bp->yiaddr)  /* require an IP address */
 3227e2c:	e0bffd17 	ldw	r2,-12(fp)
 3227e30:	10800417 	ldw	r2,16(r2)
 3227e34:	1004c03a 	cmpne	r2,r2,zero
 3227e38:	1000071e 	bne	r2,zero,3227e58 <dhc_rx_offer+0xb8>
   {
      dhc_decline(iface,bp, bplen);
 3227e3c:	e13ffc17 	ldw	r4,-16(fp)
 3227e40:	e17ffd17 	ldw	r5,-12(fp)
 3227e44:	e1bffe17 	ldw	r6,-8(fp)
 3227e48:	3228d440 	call	3228d44 <dhc_decline>
      return ENP_NOT_MINE;
 3227e4c:	00800084 	movi	r2,2
 3227e50:	e0bfff15 	stw	r2,-4(fp)
 3227e54:	00000d06 	br	3227e8c <dhc_rx_offer+0xec>
   }
   dhc_states[iface].ipaddr = bp->yiaddr;
 3227e58:	e13ffc17 	ldw	r4,-16(fp)
 3227e5c:	e0bffd17 	ldw	r2,-12(fp)
 3227e60:	11400417 	ldw	r5,16(r2)
 3227e64:	00c0c9b4 	movhi	r3,806
 3227e68:	18f28004 	addi	r3,r3,-13824
 3227e6c:	20800f24 	muli	r2,r4,60
 3227e70:	10c5883a 	add	r2,r2,r3
 3227e74:	10800904 	addi	r2,r2,36
 3227e78:	11400015 	stw	r5,0(r2)

   /* if we got here, we must like the offer -- send a DHCP REQUEST */
   return (dhc_request(iface,FALSE));
 3227e7c:	e13ffc17 	ldw	r4,-16(fp)
 3227e80:	000b883a 	mov	r5,zero
 3227e84:	3227ea40 	call	3227ea4 <dhc_request>
 3227e88:	e0bfff15 	stw	r2,-4(fp)
 3227e8c:	e0bfff17 	ldw	r2,-4(fp)
}
 3227e90:	e037883a 	mov	sp,fp
 3227e94:	dfc00117 	ldw	ra,4(sp)
 3227e98:	df000017 	ldw	fp,0(sp)
 3227e9c:	dec00204 	addi	sp,sp,8
 3227ea0:	f800283a 	ret

03227ea4 <dhc_request>:
 * RETURNS:  Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_request(int iface,int xid_flag)
{
 3227ea4:	defff304 	addi	sp,sp,-52
 3227ea8:	dfc00c15 	stw	ra,48(sp)
 3227eac:	df000b15 	stw	fp,44(sp)
 3227eb0:	df000b04 	addi	fp,sp,44
 3227eb4:	e13ffd15 	stw	r4,-12(fp)
 3227eb8:	e17ffe15 	stw	r5,-8(fp)
   u_char  *   opts; /* scratch pointer to DHCP options field */
   ip_addr opt_ip;      /* IP address temporary */
   int      e;       /* error holder */

   /* get a UDP packet buffer for sending DHCP request */
   pkt = udp_alloc(sizeof(struct bootp) + DHCP_OPTSIZE - BOOTP_OPTSIZE, 0);
 3227ebc:	01008904 	movi	r4,548
 3227ec0:	000b883a 	mov	r5,zero
 3227ec4:	32451900 	call	3245190 <udp_alloc>
 3227ec8:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 3227ecc:	e0bffa17 	ldw	r2,-24(fp)
 3227ed0:	1004c03a 	cmpne	r2,r2,zero
 3227ed4:	1000031e 	bne	r2,zero,3227ee4 <dhc_request+0x40>
      return ENP_NOMEM;
 3227ed8:	00bffb04 	movi	r2,-20
 3227edc:	e0bfff15 	stw	r2,-4(fp)
 3227ee0:	0002b906 	br	32289c8 <dhc_request+0xb24>
   pkt->nb_plen = sizeof(struct bootp) - BOOTP_OPTSIZE;
 3227ee4:	e0fffa17 	ldw	r3,-24(fp)
 3227ee8:	00803b04 	movi	r2,236
 3227eec:	18800415 	stw	r2,16(r3)

   if ( xid_flag == TRUE )
 3227ef0:	e0bffe17 	ldw	r2,-8(fp)
 3227ef4:	10800058 	cmpnei	r2,r2,1
 3227ef8:	1000121e 	bne	r2,zero,3227f44 <dhc_request+0xa0>
   {
      dhc_states[iface].xid  = xids++;
 3227efc:	e0bffd17 	ldw	r2,-12(fp)
 3227f00:	d1202f17 	ldw	r4,-32580(gp)
 3227f04:	200b883a 	mov	r5,r4
 3227f08:	00c0c9b4 	movhi	r3,806
 3227f0c:	18f28004 	addi	r3,r3,-13824
 3227f10:	10800f24 	muli	r2,r2,60
 3227f14:	10c5883a 	add	r2,r2,r3
 3227f18:	10800204 	addi	r2,r2,8
 3227f1c:	11400015 	stw	r5,0(r2)
 3227f20:	20800044 	addi	r2,r4,1
 3227f24:	d0a02f15 	stw	r2,-32580(gp)
      dhc_states[iface].secs = 0;
 3227f28:	e0bffd17 	ldw	r2,-12(fp)
 3227f2c:	00c0c9b4 	movhi	r3,806
 3227f30:	18f28004 	addi	r3,r3,-13824
 3227f34:	10800f24 	muli	r2,r2,60
 3227f38:	10c5883a 	add	r2,r2,r3
 3227f3c:	10800304 	addi	r2,r2,12
 3227f40:	1000000d 	sth	zero,0(r2)
   }

   /* build a BOOTP request header */
   outbp = (struct bootp *)pkt->nb_prot;
 3227f44:	e0bffa17 	ldw	r2,-24(fp)
 3227f48:	10800317 	ldw	r2,12(r2)
 3227f4c:	e0bffb15 	stw	r2,-20(fp)
   e     = dhc_buildheader(iface,outbp);
 3227f50:	e13ffd17 	ldw	r4,-12(fp)
 3227f54:	e17ffb17 	ldw	r5,-20(fp)
 3227f58:	322766c0 	call	322766c <dhc_buildheader>
 3227f5c:	e0bff815 	stw	r2,-32(fp)
   if (e)
 3227f60:	e0bff817 	ldw	r2,-32(fp)
 3227f64:	1005003a 	cmpeq	r2,r2,zero
 3227f68:	1000031e 	bne	r2,zero,3227f78 <dhc_request+0xd4>
      return e;
 3227f6c:	e0bff817 	ldw	r2,-32(fp)
 3227f70:	e0bfff15 	stw	r2,-4(fp)
 3227f74:	00029406 	br	32289c8 <dhc_request+0xb24>

   /* turn it into a DHCP REQUEST packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 3227f78:	e0bffb17 	ldw	r2,-20(fp)
 3227f7c:	10803b04 	addi	r2,r2,236
 3227f80:	1007883a 	mov	r3,r2
 3227f84:	0098d534 	movhi	r2,25428
 3227f88:	10a098c4 	addi	r2,r2,-32157
 3227f8c:	18800015 	stw	r2,0(r3)
   opts    = &outbp->options[4];    /* encode options after cookie */
 3227f90:	e0bffb17 	ldw	r2,-20(fp)
 3227f94:	10803b04 	addi	r2,r2,236
 3227f98:	10800104 	addi	r2,r2,4
 3227f9c:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHOP_TYPE;
 3227fa0:	e0fff917 	ldw	r3,-28(fp)
 3227fa4:	00800d44 	movi	r2,53
 3227fa8:	18800005 	stb	r2,0(r3)
 3227fac:	e0bff917 	ldw	r2,-28(fp)
 3227fb0:	10800044 	addi	r2,r2,1
 3227fb4:	e0bff915 	stw	r2,-28(fp)
   *opts++ = 1;   /* length of option field */
 3227fb8:	e0fff917 	ldw	r3,-28(fp)
 3227fbc:	00800044 	movi	r2,1
 3227fc0:	18800005 	stb	r2,0(r3)
 3227fc4:	e0bff917 	ldw	r2,-28(fp)
 3227fc8:	10800044 	addi	r2,r2,1
 3227fcc:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHCP_REQUEST;
 3227fd0:	e0fff917 	ldw	r3,-28(fp)
 3227fd4:	008000c4 	movi	r2,3
 3227fd8:	18800005 	stb	r2,0(r3)
 3227fdc:	e0bff917 	ldw	r2,-28(fp)
 3227fe0:	10800044 	addi	r2,r2,1
 3227fe4:	e0bff915 	stw	r2,-28(fp)

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 3227fe8:	e0bffd17 	ldw	r2,-12(fp)
 3227fec:	00c0c9b4 	movhi	r3,806
 3227ff0:	18f28004 	addi	r3,r3,-13824
 3227ff4:	10800f24 	muli	r2,r2,60
 3227ff8:	10c5883a 	add	r2,r2,r3
 3227ffc:	10800017 	ldw	r2,0(r2)
 3228000:	10800120 	cmpeqi	r2,r2,4
 3228004:	1000181e 	bne	r2,zero,3228068 <dhc_request+0x1c4>
 3228008:	e0bffd17 	ldw	r2,-12(fp)
 322800c:	00c0c9b4 	movhi	r3,806
 3228010:	18f28004 	addi	r3,r3,-13824
 3228014:	10800f24 	muli	r2,r2,60
 3228018:	10c5883a 	add	r2,r2,r3
 322801c:	10800017 	ldw	r2,0(r2)
 3228020:	10800160 	cmpeqi	r2,r2,5
 3228024:	1000101e 	bne	r2,zero,3228068 <dhc_request+0x1c4>
 3228028:	e0bffd17 	ldw	r2,-12(fp)
 322802c:	00c0c9b4 	movhi	r3,806
 3228030:	18f28004 	addi	r3,r3,-13824
 3228034:	10800f24 	muli	r2,r2,60
 3228038:	10c5883a 	add	r2,r2,r3
 322803c:	10800017 	ldw	r2,0(r2)
 3228040:	108000e0 	cmpeqi	r2,r2,3
 3228044:	1000081e 	bne	r2,zero,3228068 <dhc_request+0x1c4>
 3228048:	e0bffd17 	ldw	r2,-12(fp)
 322804c:	00c0c9b4 	movhi	r3,806
 3228050:	18f28004 	addi	r3,r3,-13824
 3228054:	10800f24 	muli	r2,r2,60
 3228058:	10c5883a 	add	r2,r2,r3
 322805c:	10800017 	ldw	r2,0(r2)
 3228060:	10800098 	cmpnei	r2,r2,2
 3228064:	10004e1e 	bne	r2,zero,32281a0 <dhc_request+0x2fc>
       (dhc_states[iface].state == DHCS_REQUESTING) ||
       (dhc_states[iface].state == DHCS_REBOOTING) ||
       (dhc_states[iface].state == DHCS_INITREBOOT))
   {
      opt_ip = ntohl(dhc_states[iface].ipaddr);
 3228068:	e0bffd17 	ldw	r2,-12(fp)
 322806c:	00c0c9b4 	movhi	r3,806
 3228070:	18f28004 	addi	r3,r3,-13824
 3228074:	10800f24 	muli	r2,r2,60
 3228078:	10c5883a 	add	r2,r2,r3
 322807c:	10800904 	addi	r2,r2,36
 3228080:	10800017 	ldw	r2,0(r2)
 3228084:	1004d63a 	srli	r2,r2,24
 3228088:	11003fcc 	andi	r4,r2,255
 322808c:	e0bffd17 	ldw	r2,-12(fp)
 3228090:	00c0c9b4 	movhi	r3,806
 3228094:	18f28004 	addi	r3,r3,-13824
 3228098:	10800f24 	muli	r2,r2,60
 322809c:	10c5883a 	add	r2,r2,r3
 32280a0:	10800904 	addi	r2,r2,36
 32280a4:	10800017 	ldw	r2,0(r2)
 32280a8:	1004d23a 	srli	r2,r2,8
 32280ac:	10bfc00c 	andi	r2,r2,65280
 32280b0:	2088b03a 	or	r4,r4,r2
 32280b4:	e0bffd17 	ldw	r2,-12(fp)
 32280b8:	00c0c9b4 	movhi	r3,806
 32280bc:	18f28004 	addi	r3,r3,-13824
 32280c0:	10800f24 	muli	r2,r2,60
 32280c4:	10c5883a 	add	r2,r2,r3
 32280c8:	10800904 	addi	r2,r2,36
 32280cc:	10800017 	ldw	r2,0(r2)
 32280d0:	10bfc00c 	andi	r2,r2,65280
 32280d4:	1004923a 	slli	r2,r2,8
 32280d8:	2088b03a 	or	r4,r4,r2
 32280dc:	e0bffd17 	ldw	r2,-12(fp)
 32280e0:	00c0c9b4 	movhi	r3,806
 32280e4:	18f28004 	addi	r3,r3,-13824
 32280e8:	10800f24 	muli	r2,r2,60
 32280ec:	10c5883a 	add	r2,r2,r3
 32280f0:	10800904 	addi	r2,r2,36
 32280f4:	10800017 	ldw	r2,0(r2)
 32280f8:	10803fcc 	andi	r2,r2,255
 32280fc:	1004963a 	slli	r2,r2,24
 3228100:	2084b03a 	or	r2,r4,r2
 3228104:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, opt_ip);
 3228108:	e0fff917 	ldw	r3,-28(fp)
 322810c:	00800c84 	movi	r2,50
 3228110:	18800005 	stb	r2,0(r3)
 3228114:	e0bff917 	ldw	r2,-28(fp)
 3228118:	10800044 	addi	r2,r2,1
 322811c:	e0bff915 	stw	r2,-28(fp)
 3228120:	e0fff917 	ldw	r3,-28(fp)
 3228124:	00800104 	movi	r2,4
 3228128:	18800005 	stb	r2,0(r3)
 322812c:	e0bff917 	ldw	r2,-28(fp)
 3228130:	10800044 	addi	r2,r2,1
 3228134:	e0bff915 	stw	r2,-28(fp)
 3228138:	e0bff917 	ldw	r2,-28(fp)
 322813c:	10c000c4 	addi	r3,r2,3
 3228140:	e0bffc04 	addi	r2,fp,-16
 3228144:	10800003 	ldbu	r2,0(r2)
 3228148:	18800005 	stb	r2,0(r3)
 322814c:	e0bff917 	ldw	r2,-28(fp)
 3228150:	10c00084 	addi	r3,r2,2
 3228154:	e0bffc04 	addi	r2,fp,-16
 3228158:	10800044 	addi	r2,r2,1
 322815c:	10800003 	ldbu	r2,0(r2)
 3228160:	18800005 	stb	r2,0(r3)
 3228164:	e0bff917 	ldw	r2,-28(fp)
 3228168:	10c00044 	addi	r3,r2,1
 322816c:	e0bffc04 	addi	r2,fp,-16
 3228170:	10800084 	addi	r2,r2,2
 3228174:	10800003 	ldbu	r2,0(r2)
 3228178:	18800005 	stb	r2,0(r3)
 322817c:	e0bffc04 	addi	r2,fp,-16
 3228180:	108000c4 	addi	r2,r2,3
 3228184:	10800003 	ldbu	r2,0(r2)
 3228188:	1007883a 	mov	r3,r2
 322818c:	e0bff917 	ldw	r2,-28(fp)
 3228190:	10c00005 	stb	r3,0(r2)
 3228194:	e0bff917 	ldw	r2,-28(fp)
 3228198:	10800104 	addi	r2,r2,4
 322819c:	e0bff915 	stw	r2,-28(fp)
   }
   if (dhc_states[iface].snmask)
 32281a0:	e0bffd17 	ldw	r2,-12(fp)
 32281a4:	00c0c9b4 	movhi	r3,806
 32281a8:	18f28004 	addi	r3,r3,-13824
 32281ac:	10800f24 	muli	r2,r2,60
 32281b0:	10c5883a 	add	r2,r2,r3
 32281b4:	10800a04 	addi	r2,r2,40
 32281b8:	10800017 	ldw	r2,0(r2)
 32281bc:	1005003a 	cmpeq	r2,r2,zero
 32281c0:	10004e1e 	bne	r2,zero,32282fc <dhc_request+0x458>
   {
      opt_ip = ntohl(dhc_states[iface].snmask);
 32281c4:	e0bffd17 	ldw	r2,-12(fp)
 32281c8:	00c0c9b4 	movhi	r3,806
 32281cc:	18f28004 	addi	r3,r3,-13824
 32281d0:	10800f24 	muli	r2,r2,60
 32281d4:	10c5883a 	add	r2,r2,r3
 32281d8:	10800a04 	addi	r2,r2,40
 32281dc:	10800017 	ldw	r2,0(r2)
 32281e0:	1004d63a 	srli	r2,r2,24
 32281e4:	11003fcc 	andi	r4,r2,255
 32281e8:	e0bffd17 	ldw	r2,-12(fp)
 32281ec:	00c0c9b4 	movhi	r3,806
 32281f0:	18f28004 	addi	r3,r3,-13824
 32281f4:	10800f24 	muli	r2,r2,60
 32281f8:	10c5883a 	add	r2,r2,r3
 32281fc:	10800a04 	addi	r2,r2,40
 3228200:	10800017 	ldw	r2,0(r2)
 3228204:	1004d23a 	srli	r2,r2,8
 3228208:	10bfc00c 	andi	r2,r2,65280
 322820c:	2088b03a 	or	r4,r4,r2
 3228210:	e0bffd17 	ldw	r2,-12(fp)
 3228214:	00c0c9b4 	movhi	r3,806
 3228218:	18f28004 	addi	r3,r3,-13824
 322821c:	10800f24 	muli	r2,r2,60
 3228220:	10c5883a 	add	r2,r2,r3
 3228224:	10800a04 	addi	r2,r2,40
 3228228:	10800017 	ldw	r2,0(r2)
 322822c:	10bfc00c 	andi	r2,r2,65280
 3228230:	1004923a 	slli	r2,r2,8
 3228234:	2088b03a 	or	r4,r4,r2
 3228238:	e0bffd17 	ldw	r2,-12(fp)
 322823c:	00c0c9b4 	movhi	r3,806
 3228240:	18f28004 	addi	r3,r3,-13824
 3228244:	10800f24 	muli	r2,r2,60
 3228248:	10c5883a 	add	r2,r2,r3
 322824c:	10800a04 	addi	r2,r2,40
 3228250:	10800017 	ldw	r2,0(r2)
 3228254:	10803fcc 	andi	r2,r2,255
 3228258:	1004963a 	slli	r2,r2,24
 322825c:	2084b03a 	or	r2,r4,r2
 3228260:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_SNMASK, opt_ip);
 3228264:	e0fff917 	ldw	r3,-28(fp)
 3228268:	00800044 	movi	r2,1
 322826c:	18800005 	stb	r2,0(r3)
 3228270:	e0bff917 	ldw	r2,-28(fp)
 3228274:	10800044 	addi	r2,r2,1
 3228278:	e0bff915 	stw	r2,-28(fp)
 322827c:	e0fff917 	ldw	r3,-28(fp)
 3228280:	00800104 	movi	r2,4
 3228284:	18800005 	stb	r2,0(r3)
 3228288:	e0bff917 	ldw	r2,-28(fp)
 322828c:	10800044 	addi	r2,r2,1
 3228290:	e0bff915 	stw	r2,-28(fp)
 3228294:	e0bff917 	ldw	r2,-28(fp)
 3228298:	10c000c4 	addi	r3,r2,3
 322829c:	e0bffc04 	addi	r2,fp,-16
 32282a0:	10800003 	ldbu	r2,0(r2)
 32282a4:	18800005 	stb	r2,0(r3)
 32282a8:	e0bff917 	ldw	r2,-28(fp)
 32282ac:	10c00084 	addi	r3,r2,2
 32282b0:	e0bffc04 	addi	r2,fp,-16
 32282b4:	10800044 	addi	r2,r2,1
 32282b8:	10800003 	ldbu	r2,0(r2)
 32282bc:	18800005 	stb	r2,0(r3)
 32282c0:	e0bff917 	ldw	r2,-28(fp)
 32282c4:	10c00044 	addi	r3,r2,1
 32282c8:	e0bffc04 	addi	r2,fp,-16
 32282cc:	10800084 	addi	r2,r2,2
 32282d0:	10800003 	ldbu	r2,0(r2)
 32282d4:	18800005 	stb	r2,0(r3)
 32282d8:	e0bffc04 	addi	r2,fp,-16
 32282dc:	108000c4 	addi	r2,r2,3
 32282e0:	10800003 	ldbu	r2,0(r2)
 32282e4:	1007883a 	mov	r3,r2
 32282e8:	e0bff917 	ldw	r2,-28(fp)
 32282ec:	10c00005 	stb	r3,0(r2)
 32282f0:	e0bff917 	ldw	r2,-28(fp)
 32282f4:	10800104 	addi	r2,r2,4
 32282f8:	e0bff915 	stw	r2,-28(fp)
   }
   if (dhc_states[iface].defgw)
 32282fc:	e0bffd17 	ldw	r2,-12(fp)
 3228300:	00c0c9b4 	movhi	r3,806
 3228304:	18f28004 	addi	r3,r3,-13824
 3228308:	10800f24 	muli	r2,r2,60
 322830c:	10c5883a 	add	r2,r2,r3
 3228310:	10800b04 	addi	r2,r2,44
 3228314:	10800017 	ldw	r2,0(r2)
 3228318:	1005003a 	cmpeq	r2,r2,zero
 322831c:	10004e1e 	bne	r2,zero,3228458 <dhc_request+0x5b4>
   {
      opt_ip = ntohl(dhc_states[iface].defgw);
 3228320:	e0bffd17 	ldw	r2,-12(fp)
 3228324:	00c0c9b4 	movhi	r3,806
 3228328:	18f28004 	addi	r3,r3,-13824
 322832c:	10800f24 	muli	r2,r2,60
 3228330:	10c5883a 	add	r2,r2,r3
 3228334:	10800b04 	addi	r2,r2,44
 3228338:	10800017 	ldw	r2,0(r2)
 322833c:	1004d63a 	srli	r2,r2,24
 3228340:	11003fcc 	andi	r4,r2,255
 3228344:	e0bffd17 	ldw	r2,-12(fp)
 3228348:	00c0c9b4 	movhi	r3,806
 322834c:	18f28004 	addi	r3,r3,-13824
 3228350:	10800f24 	muli	r2,r2,60
 3228354:	10c5883a 	add	r2,r2,r3
 3228358:	10800b04 	addi	r2,r2,44
 322835c:	10800017 	ldw	r2,0(r2)
 3228360:	1004d23a 	srli	r2,r2,8
 3228364:	10bfc00c 	andi	r2,r2,65280
 3228368:	2088b03a 	or	r4,r4,r2
 322836c:	e0bffd17 	ldw	r2,-12(fp)
 3228370:	00c0c9b4 	movhi	r3,806
 3228374:	18f28004 	addi	r3,r3,-13824
 3228378:	10800f24 	muli	r2,r2,60
 322837c:	10c5883a 	add	r2,r2,r3
 3228380:	10800b04 	addi	r2,r2,44
 3228384:	10800017 	ldw	r2,0(r2)
 3228388:	10bfc00c 	andi	r2,r2,65280
 322838c:	1004923a 	slli	r2,r2,8
 3228390:	2088b03a 	or	r4,r4,r2
 3228394:	e0bffd17 	ldw	r2,-12(fp)
 3228398:	00c0c9b4 	movhi	r3,806
 322839c:	18f28004 	addi	r3,r3,-13824
 32283a0:	10800f24 	muli	r2,r2,60
 32283a4:	10c5883a 	add	r2,r2,r3
 32283a8:	10800b04 	addi	r2,r2,44
 32283ac:	10800017 	ldw	r2,0(r2)
 32283b0:	10803fcc 	andi	r2,r2,255
 32283b4:	1004963a 	slli	r2,r2,24
 32283b8:	2084b03a 	or	r2,r4,r2
 32283bc:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_ROUTER, opt_ip);
 32283c0:	e0fff917 	ldw	r3,-28(fp)
 32283c4:	008000c4 	movi	r2,3
 32283c8:	18800005 	stb	r2,0(r3)
 32283cc:	e0bff917 	ldw	r2,-28(fp)
 32283d0:	10800044 	addi	r2,r2,1
 32283d4:	e0bff915 	stw	r2,-28(fp)
 32283d8:	e0fff917 	ldw	r3,-28(fp)
 32283dc:	00800104 	movi	r2,4
 32283e0:	18800005 	stb	r2,0(r3)
 32283e4:	e0bff917 	ldw	r2,-28(fp)
 32283e8:	10800044 	addi	r2,r2,1
 32283ec:	e0bff915 	stw	r2,-28(fp)
 32283f0:	e0bff917 	ldw	r2,-28(fp)
 32283f4:	10c000c4 	addi	r3,r2,3
 32283f8:	e0bffc04 	addi	r2,fp,-16
 32283fc:	10800003 	ldbu	r2,0(r2)
 3228400:	18800005 	stb	r2,0(r3)
 3228404:	e0bff917 	ldw	r2,-28(fp)
 3228408:	10c00084 	addi	r3,r2,2
 322840c:	e0bffc04 	addi	r2,fp,-16
 3228410:	10800044 	addi	r2,r2,1
 3228414:	10800003 	ldbu	r2,0(r2)
 3228418:	18800005 	stb	r2,0(r3)
 322841c:	e0bff917 	ldw	r2,-28(fp)
 3228420:	10c00044 	addi	r3,r2,1
 3228424:	e0bffc04 	addi	r2,fp,-16
 3228428:	10800084 	addi	r2,r2,2
 322842c:	10800003 	ldbu	r2,0(r2)
 3228430:	18800005 	stb	r2,0(r3)
 3228434:	e0bffc04 	addi	r2,fp,-16
 3228438:	108000c4 	addi	r2,r2,3
 322843c:	10800003 	ldbu	r2,0(r2)
 3228440:	1007883a 	mov	r3,r2
 3228444:	e0bff917 	ldw	r2,-28(fp)
 3228448:	10c00005 	stb	r3,0(r2)
 322844c:	e0bff917 	ldw	r2,-28(fp)
 3228450:	10800104 	addi	r2,r2,4
 3228454:	e0bff915 	stw	r2,-28(fp)
         }
      }
   }
#endif

   if (dhc_states[iface].lease)
 3228458:	e0bffd17 	ldw	r2,-12(fp)
 322845c:	00c0c9b4 	movhi	r3,806
 3228460:	18f28004 	addi	r3,r3,-13824
 3228464:	10800f24 	muli	r2,r2,60
 3228468:	10c5883a 	add	r2,r2,r3
 322846c:	10800504 	addi	r2,r2,20
 3228470:	10800017 	ldw	r2,0(r2)
 3228474:	1005003a 	cmpeq	r2,r2,zero
 3228478:	10003a1e 	bne	r2,zero,3228564 <dhc_request+0x6c0>
   {
      PUT_IP_OPT(opts, DHOP_LEASE, dhc_states[iface].lease);
 322847c:	e0fff917 	ldw	r3,-28(fp)
 3228480:	00800cc4 	movi	r2,51
 3228484:	18800005 	stb	r2,0(r3)
 3228488:	e0bff917 	ldw	r2,-28(fp)
 322848c:	10800044 	addi	r2,r2,1
 3228490:	e0bff915 	stw	r2,-28(fp)
 3228494:	e0fff917 	ldw	r3,-28(fp)
 3228498:	00800104 	movi	r2,4
 322849c:	18800005 	stb	r2,0(r3)
 32284a0:	e0bff917 	ldw	r2,-28(fp)
 32284a4:	10800044 	addi	r2,r2,1
 32284a8:	e0bff915 	stw	r2,-28(fp)
 32284ac:	e0bff917 	ldw	r2,-28(fp)
 32284b0:	110000c4 	addi	r4,r2,3
 32284b4:	e0bffd17 	ldw	r2,-12(fp)
 32284b8:	10800f24 	muli	r2,r2,60
 32284bc:	10c00504 	addi	r3,r2,20
 32284c0:	0080c9b4 	movhi	r2,806
 32284c4:	10b28004 	addi	r2,r2,-13824
 32284c8:	1885883a 	add	r2,r3,r2
 32284cc:	10800003 	ldbu	r2,0(r2)
 32284d0:	20800005 	stb	r2,0(r4)
 32284d4:	e0bff917 	ldw	r2,-28(fp)
 32284d8:	11000084 	addi	r4,r2,2
 32284dc:	e0bffd17 	ldw	r2,-12(fp)
 32284e0:	10800f24 	muli	r2,r2,60
 32284e4:	10c00504 	addi	r3,r2,20
 32284e8:	0080c9b4 	movhi	r2,806
 32284ec:	10b28004 	addi	r2,r2,-13824
 32284f0:	1885883a 	add	r2,r3,r2
 32284f4:	10800044 	addi	r2,r2,1
 32284f8:	10800003 	ldbu	r2,0(r2)
 32284fc:	20800005 	stb	r2,0(r4)
 3228500:	e0bff917 	ldw	r2,-28(fp)
 3228504:	11000044 	addi	r4,r2,1
 3228508:	e0bffd17 	ldw	r2,-12(fp)
 322850c:	10800f24 	muli	r2,r2,60
 3228510:	10c00504 	addi	r3,r2,20
 3228514:	0080c9b4 	movhi	r2,806
 3228518:	10b28004 	addi	r2,r2,-13824
 322851c:	1885883a 	add	r2,r3,r2
 3228520:	10800084 	addi	r2,r2,2
 3228524:	10800003 	ldbu	r2,0(r2)
 3228528:	20800005 	stb	r2,0(r4)
 322852c:	e0bffd17 	ldw	r2,-12(fp)
 3228530:	10800f24 	muli	r2,r2,60
 3228534:	10c00504 	addi	r3,r2,20
 3228538:	0080c9b4 	movhi	r2,806
 322853c:	10b28004 	addi	r2,r2,-13824
 3228540:	1885883a 	add	r2,r3,r2
 3228544:	108000c4 	addi	r2,r2,3
 3228548:	10800003 	ldbu	r2,0(r2)
 322854c:	1007883a 	mov	r3,r2
 3228550:	e0bff917 	ldw	r2,-28(fp)
 3228554:	10c00005 	stb	r3,0(r2)
 3228558:	e0bff917 	ldw	r2,-28(fp)
 322855c:	10800104 	addi	r2,r2,4
 3228560:	e0bff915 	stw	r2,-28(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 3228564:	d0a03117 	ldw	r2,-32572(gp)
 3228568:	10800050 	cmplti	r2,r2,1
 322856c:	10001e1e 	bne	r2,zero,32285e8 <dhc_request+0x744>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 3228570:	e0fff917 	ldw	r3,-28(fp)
 3228574:	00800dc4 	movi	r2,55
 3228578:	18800005 	stb	r2,0(r3)
 322857c:	e0bff917 	ldw	r2,-28(fp)
 3228580:	10800044 	addi	r2,r2,1
 3228584:	e0bff915 	stw	r2,-28(fp)
      *opts++ = (u_char)reqlist_len ;
 3228588:	d0a03117 	ldw	r2,-32572(gp)
 322858c:	1007883a 	mov	r3,r2
 3228590:	e0bff917 	ldw	r2,-28(fp)
 3228594:	10c00005 	stb	r3,0(r2)
 3228598:	e0bff917 	ldw	r2,-28(fp)
 322859c:	10800044 	addi	r2,r2,1
 32285a0:	e0bff915 	stw	r2,-28(fp)

      for (i=0 ; i < reqlist_len ; i++ )
 32285a4:	e03ff715 	stw	zero,-36(fp)
 32285a8:	00000c06 	br	32285dc <dhc_request+0x738>
         *opts++ = reqlist[i];
 32285ac:	e0fff717 	ldw	r3,-36(fp)
 32285b0:	d0a03004 	addi	r2,gp,-32576
 32285b4:	1885883a 	add	r2,r3,r2
 32285b8:	10c00003 	ldbu	r3,0(r2)
 32285bc:	e0bff917 	ldw	r2,-28(fp)
 32285c0:	10c00005 	stb	r3,0(r2)
 32285c4:	e0bff917 	ldw	r2,-28(fp)
 32285c8:	10800044 	addi	r2,r2,1
 32285cc:	e0bff915 	stw	r2,-28(fp)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 32285d0:	e0bff717 	ldw	r2,-36(fp)
 32285d4:	10800044 	addi	r2,r2,1
 32285d8:	e0bff715 	stw	r2,-36(fp)
 32285dc:	d0e03117 	ldw	r3,-32572(gp)
 32285e0:	e0bff717 	ldw	r2,-36(fp)
 32285e4:	10fff116 	blt	r2,r3,32285ac <dhc_request+0x708>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   /* only set client IP address (ours) when renewing or rebinding */
   if ((dhc_states[iface].state == DHCS_RENEWING)
 32285e8:	e0bffd17 	ldw	r2,-12(fp)
 32285ec:	00c0c9b4 	movhi	r3,806
 32285f0:	18f28004 	addi	r3,r3,-13824
 32285f4:	10800f24 	muli	r2,r2,60
 32285f8:	10c5883a 	add	r2,r2,r3
 32285fc:	10800017 	ldw	r2,0(r2)
 3228600:	108001e0 	cmpeqi	r2,r2,7
 3228604:	1000081e 	bne	r2,zero,3228628 <dhc_request+0x784>
 3228608:	e0bffd17 	ldw	r2,-12(fp)
 322860c:	00c0c9b4 	movhi	r3,806
 3228610:	18f28004 	addi	r3,r3,-13824
 3228614:	10800f24 	muli	r2,r2,60
 3228618:	10c5883a 	add	r2,r2,r3
 322861c:	10800017 	ldw	r2,0(r2)
 3228620:	10800218 	cmpnei	r2,r2,8
 3228624:	10000a1e 	bne	r2,zero,3228650 <dhc_request+0x7ac>
       || (dhc_states[iface].state == DHCS_REBINDING))
   {
      outbp->ciaddr = nets[iface]->n_ipaddr;
 3228628:	e0bffd17 	ldw	r2,-12(fp)
 322862c:	00c0c9b4 	movhi	r3,806
 3228630:	18f25a04 	addi	r3,r3,-13976
 3228634:	1085883a 	add	r2,r2,r2
 3228638:	1085883a 	add	r2,r2,r2
 322863c:	10c5883a 	add	r2,r2,r3
 3228640:	10800017 	ldw	r2,0(r2)
 3228644:	10c00a17 	ldw	r3,40(r2)
 3228648:	e0bffb17 	ldw	r2,-20(fp)
 322864c:	10c00315 	stw	r3,12(r2)
    * "Client inserts the address of the selected server in 'server 
    * identifier'. . . ." RFC 951, p. 4 definition of 'siaddr' is 
    * "server IP address; returned in bootreply by server." 
    */
   /* Only include server identifier option when selecting a server. */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 3228650:	e0bffd17 	ldw	r2,-12(fp)
 3228654:	00c0c9b4 	movhi	r3,806
 3228658:	18f28004 	addi	r3,r3,-13824
 322865c:	10800f24 	muli	r2,r2,60
 3228660:	10c5883a 	add	r2,r2,r3
 3228664:	10800017 	ldw	r2,0(r2)
 3228668:	10800120 	cmpeqi	r2,r2,4
 322866c:	1000081e 	bne	r2,zero,3228690 <dhc_request+0x7ec>
 3228670:	e0bffd17 	ldw	r2,-12(fp)
 3228674:	00c0c9b4 	movhi	r3,806
 3228678:	18f28004 	addi	r3,r3,-13824
 322867c:	10800f24 	muli	r2,r2,60
 3228680:	10c5883a 	add	r2,r2,r3
 3228684:	10800017 	ldw	r2,0(r2)
 3228688:	10800158 	cmpnei	r2,r2,5
 322868c:	10004e1e 	bne	r2,zero,32287c8 <dhc_request+0x924>
       (dhc_states[iface].state == DHCS_REQUESTING))
   {
      opt_ip = ntohl(dhc_states[iface].srv_ipaddr);
 3228690:	e0bffd17 	ldw	r2,-12(fp)
 3228694:	00c0c9b4 	movhi	r3,806
 3228698:	18f28004 	addi	r3,r3,-13824
 322869c:	10800f24 	muli	r2,r2,60
 32286a0:	10c5883a 	add	r2,r2,r3
 32286a4:	10800d04 	addi	r2,r2,52
 32286a8:	10800017 	ldw	r2,0(r2)
 32286ac:	1004d63a 	srli	r2,r2,24
 32286b0:	11003fcc 	andi	r4,r2,255
 32286b4:	e0bffd17 	ldw	r2,-12(fp)
 32286b8:	00c0c9b4 	movhi	r3,806
 32286bc:	18f28004 	addi	r3,r3,-13824
 32286c0:	10800f24 	muli	r2,r2,60
 32286c4:	10c5883a 	add	r2,r2,r3
 32286c8:	10800d04 	addi	r2,r2,52
 32286cc:	10800017 	ldw	r2,0(r2)
 32286d0:	1004d23a 	srli	r2,r2,8
 32286d4:	10bfc00c 	andi	r2,r2,65280
 32286d8:	2088b03a 	or	r4,r4,r2
 32286dc:	e0bffd17 	ldw	r2,-12(fp)
 32286e0:	00c0c9b4 	movhi	r3,806
 32286e4:	18f28004 	addi	r3,r3,-13824
 32286e8:	10800f24 	muli	r2,r2,60
 32286ec:	10c5883a 	add	r2,r2,r3
 32286f0:	10800d04 	addi	r2,r2,52
 32286f4:	10800017 	ldw	r2,0(r2)
 32286f8:	10bfc00c 	andi	r2,r2,65280
 32286fc:	1004923a 	slli	r2,r2,8
 3228700:	2088b03a 	or	r4,r4,r2
 3228704:	e0bffd17 	ldw	r2,-12(fp)
 3228708:	00c0c9b4 	movhi	r3,806
 322870c:	18f28004 	addi	r3,r3,-13824
 3228710:	10800f24 	muli	r2,r2,60
 3228714:	10c5883a 	add	r2,r2,r3
 3228718:	10800d04 	addi	r2,r2,52
 322871c:	10800017 	ldw	r2,0(r2)
 3228720:	10803fcc 	andi	r2,r2,255
 3228724:	1004963a 	slli	r2,r2,24
 3228728:	2084b03a 	or	r2,r4,r2
 322872c:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_SERVER, opt_ip);
 3228730:	e0fff917 	ldw	r3,-28(fp)
 3228734:	00800d84 	movi	r2,54
 3228738:	18800005 	stb	r2,0(r3)
 322873c:	e0bff917 	ldw	r2,-28(fp)
 3228740:	10800044 	addi	r2,r2,1
 3228744:	e0bff915 	stw	r2,-28(fp)
 3228748:	e0fff917 	ldw	r3,-28(fp)
 322874c:	00800104 	movi	r2,4
 3228750:	18800005 	stb	r2,0(r3)
 3228754:	e0bff917 	ldw	r2,-28(fp)
 3228758:	10800044 	addi	r2,r2,1
 322875c:	e0bff915 	stw	r2,-28(fp)
 3228760:	e0bff917 	ldw	r2,-28(fp)
 3228764:	10c000c4 	addi	r3,r2,3
 3228768:	e0bffc04 	addi	r2,fp,-16
 322876c:	10800003 	ldbu	r2,0(r2)
 3228770:	18800005 	stb	r2,0(r3)
 3228774:	e0bff917 	ldw	r2,-28(fp)
 3228778:	10c00084 	addi	r3,r2,2
 322877c:	e0bffc04 	addi	r2,fp,-16
 3228780:	10800044 	addi	r2,r2,1
 3228784:	10800003 	ldbu	r2,0(r2)
 3228788:	18800005 	stb	r2,0(r3)
 322878c:	e0bff917 	ldw	r2,-28(fp)
 3228790:	10c00044 	addi	r3,r2,1
 3228794:	e0bffc04 	addi	r2,fp,-16
 3228798:	10800084 	addi	r2,r2,2
 322879c:	10800003 	ldbu	r2,0(r2)
 32287a0:	18800005 	stb	r2,0(r3)
 32287a4:	e0bffc04 	addi	r2,fp,-16
 32287a8:	108000c4 	addi	r2,r2,3
 32287ac:	10800003 	ldbu	r2,0(r2)
 32287b0:	1007883a 	mov	r3,r2
 32287b4:	e0bff917 	ldw	r2,-28(fp)
 32287b8:	10c00005 	stb	r3,0(r2)
 32287bc:	e0bff917 	ldw	r2,-28(fp)
 32287c0:	10800104 	addi	r2,r2,4
 32287c4:	e0bff915 	stw	r2,-28(fp)
   /* add hostname (code 12) */
   PUT_STRING_OPT(opts, 12, dhc_hostname()); 
#endif /* USE_AUTOIP */

   /* Client Fully Qualified Domain Name */
   PUT_STRING_OPT(opts, 81, DC_DOMAINNAME); 
 32287c8:	e0fff917 	ldw	r3,-28(fp)
 32287cc:	00801444 	movi	r2,81
 32287d0:	18800005 	stb	r2,0(r3)
 32287d4:	e0bff917 	ldw	r2,-28(fp)
 32287d8:	10800044 	addi	r2,r2,1
 32287dc:	e0bff915 	stw	r2,-28(fp)
 32287e0:	00800184 	movi	r2,6
 32287e4:	e0bff615 	stw	r2,-40(fp)
 32287e8:	e0bff617 	ldw	r2,-40(fp)
 32287ec:	1007883a 	mov	r3,r2
 32287f0:	e0bff917 	ldw	r2,-28(fp)
 32287f4:	10c00005 	stb	r3,0(r2)
 32287f8:	e0bff917 	ldw	r2,-28(fp)
 32287fc:	10800044 	addi	r2,r2,1
 3228800:	e0bff915 	stw	r2,-28(fp)
 3228804:	e13ff917 	ldw	r4,-28(fp)
 3228808:	e1bff617 	ldw	r6,-40(fp)
 322880c:	0140c974 	movhi	r5,805
 3228810:	297be904 	addi	r5,r5,-4188
 3228814:	324bb4c0 	call	324bb4c <strncpy>
 3228818:	e0bff617 	ldw	r2,-40(fp)
 322881c:	1007883a 	mov	r3,r2
 3228820:	e0bff917 	ldw	r2,-28(fp)
 3228824:	10c5883a 	add	r2,r2,r3
 3228828:	e0bff915 	stw	r2,-28(fp)
   /* Vendor Class Identifier */
   PUT_STRING_OPT(opts, 60, name); 
 322882c:	e0fff917 	ldw	r3,-28(fp)
 3228830:	00800f04 	movi	r2,60
 3228834:	18800005 	stb	r2,0(r3)
 3228838:	e0bff917 	ldw	r2,-28(fp)
 322883c:	10800044 	addi	r2,r2,1
 3228840:	e0bff915 	stw	r2,-28(fp)
 3228844:	0080c974 	movhi	r2,805
 3228848:	1089be04 	addi	r2,r2,9976
 322884c:	11000017 	ldw	r4,0(r2)
 3228850:	32081440 	call	3208144 <strlen>
 3228854:	e0bff515 	stw	r2,-44(fp)
 3228858:	e0bff517 	ldw	r2,-44(fp)
 322885c:	1007883a 	mov	r3,r2
 3228860:	e0bff917 	ldw	r2,-28(fp)
 3228864:	10c00005 	stb	r3,0(r2)
 3228868:	e0bff917 	ldw	r2,-28(fp)
 322886c:	10800044 	addi	r2,r2,1
 3228870:	e0bff915 	stw	r2,-28(fp)
 3228874:	e13ff917 	ldw	r4,-28(fp)
 3228878:	0080c974 	movhi	r2,805
 322887c:	1089be04 	addi	r2,r2,9976
 3228880:	11400017 	ldw	r5,0(r2)
 3228884:	e1bff517 	ldw	r6,-44(fp)
 3228888:	324bb4c0 	call	324bb4c <strncpy>
 322888c:	e0bff517 	ldw	r2,-44(fp)
 3228890:	1007883a 	mov	r3,r2
 3228894:	e0bff917 	ldw	r2,-28(fp)
 3228898:	10c5883a 	add	r2,r2,r3
 322889c:	e0bff915 	stw	r2,-28(fp)

   *opts++ = DHOP_END;  /* Mark the end of options */
 32288a0:	e0fff917 	ldw	r3,-28(fp)
 32288a4:	00bfffc4 	movi	r2,-1
 32288a8:	18800005 	stb	r2,0(r3)
 32288ac:	e0bff917 	ldw	r2,-28(fp)
 32288b0:	10800044 	addi	r2,r2,1
 32288b4:	e0bff915 	stw	r2,-28(fp)

   /* figure out whether to send via unicast or broadcast */
   if (dhc_states[iface].state == DHCS_RENEWING)
 32288b8:	e0bffd17 	ldw	r2,-12(fp)
 32288bc:	00c0c9b4 	movhi	r3,806
 32288c0:	18f28004 	addi	r3,r3,-13824
 32288c4:	10800f24 	muli	r2,r2,60
 32288c8:	10c5883a 	add	r2,r2,r3
 32288cc:	10800017 	ldw	r2,0(r2)
 32288d0:	108001d8 	cmpnei	r2,r2,7
 32288d4:	10000a1e 	bne	r2,zero,3228900 <dhc_request+0xa5c>
   {
      pkt->fhost = dhc_states[iface].srv_ipaddr;
 32288d8:	e0bffd17 	ldw	r2,-12(fp)
 32288dc:	00c0c9b4 	movhi	r3,806
 32288e0:	18f28004 	addi	r3,r3,-13824
 32288e4:	10800f24 	muli	r2,r2,60
 32288e8:	10c5883a 	add	r2,r2,r3
 32288ec:	10800d04 	addi	r2,r2,52
 32288f0:	10c00017 	ldw	r3,0(r2)
 32288f4:	e0bffa17 	ldw	r2,-24(fp)
 32288f8:	10c00715 	stw	r3,28(r2)
 32288fc:	00000306 	br	322890c <dhc_request+0xa68>
   }
   else
   {
      pkt->fhost = 0xFFFFFFFF;   /* broadcast request */
 3228900:	e0fffa17 	ldw	r3,-24(fp)
 3228904:	00bfffc4 	movi	r2,-1
 3228908:	18800715 	stw	r2,28(r3)
   }

   pkt->net = nets[iface];    /* send out caller spec'ed net */
 322890c:	e0bffd17 	ldw	r2,-12(fp)
 3228910:	00c0c9b4 	movhi	r3,806
 3228914:	18f25a04 	addi	r3,r3,-13976
 3228918:	1085883a 	add	r2,r2,r2
 322891c:	1085883a 	add	r2,r2,r2
 3228920:	10c5883a 	add	r2,r2,r3
 3228924:	10c00017 	ldw	r3,0(r2)
 3228928:	e0bffa17 	ldw	r2,-24(fp)
 322892c:	10c00615 	stw	r3,24(r2)
   pkt->nb_plen = (char *)opts - (char *)outbp;
 3228930:	e0fff917 	ldw	r3,-28(fp)
 3228934:	e0bffb17 	ldw	r2,-20(fp)
 3228938:	1885c83a 	sub	r2,r3,r2
 322893c:	1007883a 	mov	r3,r2
 3228940:	e0bffa17 	ldw	r2,-24(fp)
 3228944:	10c00415 	stw	r3,16(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 3228948:	010010c4 	movi	r4,67
 322894c:	01401104 	movi	r5,68
 3228950:	e1bffa17 	ldw	r6,-24(fp)
 3228954:	3244cd80 	call	3244cd8 <udp_send>
   dsc_requests++;
 3228958:	d0a8ca17 	ldw	r2,-23768(gp)
 322895c:	10800044 	addi	r2,r2,1
 3228960:	d0a8ca15 	stw	r2,-23768(gp)

   dhc_states[iface].last_tick = cticks;
 3228964:	e13ffd17 	ldw	r4,-12(fp)
 3228968:	0080c974 	movhi	r2,805
 322896c:	10925604 	addi	r2,r2,18776
 3228970:	11400017 	ldw	r5,0(r2)
 3228974:	00c0c9b4 	movhi	r3,806
 3228978:	18f28004 	addi	r3,r3,-13824
 322897c:	20800f24 	muli	r2,r4,60
 3228980:	10c5883a 	add	r2,r2,r3
 3228984:	10800404 	addi	r2,r2,16
 3228988:	11400015 	stw	r5,0(r2)
   dhc_states[iface].tries++;
 322898c:	e17ffd17 	ldw	r5,-12(fp)
 3228990:	00c0c9b4 	movhi	r3,806
 3228994:	18f28004 	addi	r3,r3,-13824
 3228998:	28800f24 	muli	r2,r5,60
 322899c:	10c5883a 	add	r2,r2,r3
 32289a0:	10800104 	addi	r2,r2,4
 32289a4:	10800017 	ldw	r2,0(r2)
 32289a8:	11000044 	addi	r4,r2,1
 32289ac:	00c0c9b4 	movhi	r3,806
 32289b0:	18f28004 	addi	r3,r3,-13824
 32289b4:	28800f24 	muli	r2,r5,60
 32289b8:	10c5883a 	add	r2,r2,r3
 32289bc:	10800104 	addi	r2,r2,4
 32289c0:	11000015 	stw	r4,0(r2)

   return 0;   /* return OK code */
 32289c4:	e03fff15 	stw	zero,-4(fp)
 32289c8:	e0bfff17 	ldw	r2,-4(fp)
}
 32289cc:	e037883a 	mov	sp,fp
 32289d0:	dfc00117 	ldw	ra,4(sp)
 32289d4:	df000017 	ldw	fp,0(sp)
 32289d8:	dec00204 	addi	sp,sp,8
 32289dc:	f800283a 	ret

032289e0 <dhc_setip>:
 * RETURNS: Returns 0 if ok, else non-zero ENP error.
 */

int
dhc_setip(int iface)
{
 32289e0:	defffd04 	addi	sp,sp,-12
 32289e4:	dfc00215 	stw	ra,8(sp)
 32289e8:	df000115 	stw	fp,4(sp)
 32289ec:	df000104 	addi	fp,sp,4
 32289f0:	e13fff15 	stw	r4,-4(fp)
   nets[iface]->n_ipaddr = dhc_states[iface].ipaddr;
 32289f4:	e0bfff17 	ldw	r2,-4(fp)
 32289f8:	00c0c9b4 	movhi	r3,806
 32289fc:	18f25a04 	addi	r3,r3,-13976
 3228a00:	1085883a 	add	r2,r2,r2
 3228a04:	1085883a 	add	r2,r2,r2
 3228a08:	10c5883a 	add	r2,r2,r3
 3228a0c:	11000017 	ldw	r4,0(r2)
 3228a10:	e0bfff17 	ldw	r2,-4(fp)
 3228a14:	00c0c9b4 	movhi	r3,806
 3228a18:	18f28004 	addi	r3,r3,-13824
 3228a1c:	10800f24 	muli	r2,r2,60
 3228a20:	10c5883a 	add	r2,r2,r3
 3228a24:	10800904 	addi	r2,r2,36
 3228a28:	10800017 	ldw	r2,0(r2)
 3228a2c:	20800a15 	stw	r2,40(r4)
   nets[iface]->snmask   = dhc_states[iface].snmask;
 3228a30:	e0bfff17 	ldw	r2,-4(fp)
 3228a34:	00c0c9b4 	movhi	r3,806
 3228a38:	18f25a04 	addi	r3,r3,-13976
 3228a3c:	1085883a 	add	r2,r2,r2
 3228a40:	1085883a 	add	r2,r2,r2
 3228a44:	10c5883a 	add	r2,r2,r3
 3228a48:	11000017 	ldw	r4,0(r2)
 3228a4c:	e0bfff17 	ldw	r2,-4(fp)
 3228a50:	00c0c9b4 	movhi	r3,806
 3228a54:	18f28004 	addi	r3,r3,-13824
 3228a58:	10800f24 	muli	r2,r2,60
 3228a5c:	10c5883a 	add	r2,r2,r3
 3228a60:	10800a04 	addi	r2,r2,40
 3228a64:	10800017 	ldw	r2,0(r2)
 3228a68:	20800c15 	stw	r2,48(r4)
   nets[iface]->n_defgw  = dhc_states[iface].defgw;
 3228a6c:	e0bfff17 	ldw	r2,-4(fp)
 3228a70:	00c0c9b4 	movhi	r3,806
 3228a74:	18f25a04 	addi	r3,r3,-13976
 3228a78:	1085883a 	add	r2,r2,r2
 3228a7c:	1085883a 	add	r2,r2,r2
 3228a80:	10c5883a 	add	r2,r2,r3
 3228a84:	11000017 	ldw	r4,0(r2)
 3228a88:	e0bfff17 	ldw	r2,-4(fp)
 3228a8c:	00c0c9b4 	movhi	r3,806
 3228a90:	18f28004 	addi	r3,r3,-13824
 3228a94:	10800f24 	muli	r2,r2,60
 3228a98:	10c5883a 	add	r2,r2,r3
 3228a9c:	10800b04 	addi	r2,r2,44
 3228aa0:	10800017 	ldw	r2,0(r2)
 3228aa4:	20800d15 	stw	r2,52(r4)

   if ( nets[iface]->snmask == 0 )
 3228aa8:	e0bfff17 	ldw	r2,-4(fp)
 3228aac:	00c0c9b4 	movhi	r3,806
 3228ab0:	18f25a04 	addi	r3,r3,-13976
 3228ab4:	1085883a 	add	r2,r2,r2
 3228ab8:	1085883a 	add	r2,r2,r2
 3228abc:	10c5883a 	add	r2,r2,r3
 3228ac0:	10800017 	ldw	r2,0(r2)
 3228ac4:	10800c17 	ldw	r2,48(r2)
 3228ac8:	1004c03a 	cmpne	r2,r2,zero
 3228acc:	1000111e 	bne	r2,zero,3228b14 <dhc_setip+0x134>
   {
      fixup_subnet_mask(iface);
 3228ad0:	e13fff17 	ldw	r4,-4(fp)
 3228ad4:	32230a80 	call	32230a8 <fixup_subnet_mask>
      dhc_states[iface].snmask = nets[iface]->snmask; 
 3228ad8:	e17fff17 	ldw	r5,-4(fp)
 3228adc:	e0bfff17 	ldw	r2,-4(fp)
 3228ae0:	00c0c9b4 	movhi	r3,806
 3228ae4:	18f25a04 	addi	r3,r3,-13976
 3228ae8:	1085883a 	add	r2,r2,r2
 3228aec:	1085883a 	add	r2,r2,r2
 3228af0:	10c5883a 	add	r2,r2,r3
 3228af4:	10800017 	ldw	r2,0(r2)
 3228af8:	11000c17 	ldw	r4,48(r2)
 3228afc:	00c0c9b4 	movhi	r3,806
 3228b00:	18f28004 	addi	r3,r3,-13824
 3228b04:	28800f24 	muli	r2,r5,60
 3228b08:	10c5883a 	add	r2,r2,r3
 3228b0c:	10800a04 	addi	r2,r2,40
 3228b10:	11000015 	stw	r4,0(r2)
   }

   /* fixup broadcast addresses */
   nets[iface]->n_netbr    = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 3228b14:	e0bfff17 	ldw	r2,-4(fp)
 3228b18:	00c0c9b4 	movhi	r3,806
 3228b1c:	18f25a04 	addi	r3,r3,-13976
 3228b20:	1085883a 	add	r2,r2,r2
 3228b24:	1085883a 	add	r2,r2,r2
 3228b28:	10c5883a 	add	r2,r2,r3
 3228b2c:	11400017 	ldw	r5,0(r2)
 3228b30:	e0bfff17 	ldw	r2,-4(fp)
 3228b34:	00c0c9b4 	movhi	r3,806
 3228b38:	18f25a04 	addi	r3,r3,-13976
 3228b3c:	1085883a 	add	r2,r2,r2
 3228b40:	1085883a 	add	r2,r2,r2
 3228b44:	10c5883a 	add	r2,r2,r3
 3228b48:	10800017 	ldw	r2,0(r2)
 3228b4c:	11000a17 	ldw	r4,40(r2)
 3228b50:	e0bfff17 	ldw	r2,-4(fp)
 3228b54:	00c0c9b4 	movhi	r3,806
 3228b58:	18f25a04 	addi	r3,r3,-13976
 3228b5c:	1085883a 	add	r2,r2,r2
 3228b60:	1085883a 	add	r2,r2,r2
 3228b64:	10c5883a 	add	r2,r2,r3
 3228b68:	10800017 	ldw	r2,0(r2)
 3228b6c:	10800c17 	ldw	r2,48(r2)
 3228b70:	0084303a 	nor	r2,zero,r2
 3228b74:	2084b03a 	or	r2,r4,r2
 3228b78:	28800e15 	stw	r2,56(r5)
   nets[iface]->n_netbr42  = nets[iface]->n_ipaddr &  nets[iface]->snmask;
 3228b7c:	e0bfff17 	ldw	r2,-4(fp)
 3228b80:	00c0c9b4 	movhi	r3,806
 3228b84:	18f25a04 	addi	r3,r3,-13976
 3228b88:	1085883a 	add	r2,r2,r2
 3228b8c:	1085883a 	add	r2,r2,r2
 3228b90:	10c5883a 	add	r2,r2,r3
 3228b94:	11400017 	ldw	r5,0(r2)
 3228b98:	e0bfff17 	ldw	r2,-4(fp)
 3228b9c:	00c0c9b4 	movhi	r3,806
 3228ba0:	18f25a04 	addi	r3,r3,-13976
 3228ba4:	1085883a 	add	r2,r2,r2
 3228ba8:	1085883a 	add	r2,r2,r2
 3228bac:	10c5883a 	add	r2,r2,r3
 3228bb0:	10800017 	ldw	r2,0(r2)
 3228bb4:	11000a17 	ldw	r4,40(r2)
 3228bb8:	e0bfff17 	ldw	r2,-4(fp)
 3228bbc:	00c0c9b4 	movhi	r3,806
 3228bc0:	18f25a04 	addi	r3,r3,-13976
 3228bc4:	1085883a 	add	r2,r2,r2
 3228bc8:	1085883a 	add	r2,r2,r2
 3228bcc:	10c5883a 	add	r2,r2,r3
 3228bd0:	10800017 	ldw	r2,0(r2)
 3228bd4:	10800c17 	ldw	r2,48(r2)
 3228bd8:	2084703a 	and	r2,r4,r2
 3228bdc:	28800f15 	stw	r2,60(r5)
   nets[iface]->n_subnetbr = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 3228be0:	e0bfff17 	ldw	r2,-4(fp)
 3228be4:	00c0c9b4 	movhi	r3,806
 3228be8:	18f25a04 	addi	r3,r3,-13976
 3228bec:	1085883a 	add	r2,r2,r2
 3228bf0:	1085883a 	add	r2,r2,r2
 3228bf4:	10c5883a 	add	r2,r2,r3
 3228bf8:	11400017 	ldw	r5,0(r2)
 3228bfc:	e0bfff17 	ldw	r2,-4(fp)
 3228c00:	00c0c9b4 	movhi	r3,806
 3228c04:	18f25a04 	addi	r3,r3,-13976
 3228c08:	1085883a 	add	r2,r2,r2
 3228c0c:	1085883a 	add	r2,r2,r2
 3228c10:	10c5883a 	add	r2,r2,r3
 3228c14:	10800017 	ldw	r2,0(r2)
 3228c18:	11000a17 	ldw	r4,40(r2)
 3228c1c:	e0bfff17 	ldw	r2,-4(fp)
 3228c20:	00c0c9b4 	movhi	r3,806
 3228c24:	18f25a04 	addi	r3,r3,-13976
 3228c28:	1085883a 	add	r2,r2,r2
 3228c2c:	1085883a 	add	r2,r2,r2
 3228c30:	10c5883a 	add	r2,r2,r3
 3228c34:	10800017 	ldw	r2,0(r2)
 3228c38:	10800c17 	ldw	r2,48(r2)
 3228c3c:	0084303a 	nor	r2,zero,r2
 3228c40:	2084b03a 	or	r2,r4,r2
 3228c44:	28801015 	stw	r2,64(r5)

   return 0;   /* return OK code */
 3228c48:	0005883a 	mov	r2,zero
}
 3228c4c:	e037883a 	mov	sp,fp
 3228c50:	dfc00117 	ldw	ra,4(sp)
 3228c54:	df000017 	ldw	fp,0(sp)
 3228c58:	dec00204 	addi	sp,sp,8
 3228c5c:	f800283a 	ret

03228c60 <dhc_resetip>:
 * RETURNS: Returns 0 if ok, else non-zero error. 
 */

int
dhc_resetip(int iface)
{
 3228c60:	defffe04 	addi	sp,sp,-8
 3228c64:	df000115 	stw	fp,4(sp)
 3228c68:	df000104 	addi	fp,sp,4
 3228c6c:	e13fff15 	stw	r4,-4(fp)
   /* reset the ipaddress */
   nets[iface]->n_ipaddr = 0;
 3228c70:	e0bfff17 	ldw	r2,-4(fp)
 3228c74:	00c0c9b4 	movhi	r3,806
 3228c78:	18f25a04 	addi	r3,r3,-13976
 3228c7c:	1085883a 	add	r2,r2,r2
 3228c80:	1085883a 	add	r2,r2,r2
 3228c84:	10c5883a 	add	r2,r2,r3
 3228c88:	10800017 	ldw	r2,0(r2)
 3228c8c:	10000a15 	stw	zero,40(r2)
   nets[iface]->snmask   = 0;
 3228c90:	e0bfff17 	ldw	r2,-4(fp)
 3228c94:	00c0c9b4 	movhi	r3,806
 3228c98:	18f25a04 	addi	r3,r3,-13976
 3228c9c:	1085883a 	add	r2,r2,r2
 3228ca0:	1085883a 	add	r2,r2,r2
 3228ca4:	10c5883a 	add	r2,r2,r3
 3228ca8:	10800017 	ldw	r2,0(r2)
 3228cac:	10000c15 	stw	zero,48(r2)
   nets[iface]->n_defgw  = 0;
 3228cb0:	e0bfff17 	ldw	r2,-4(fp)
 3228cb4:	00c0c9b4 	movhi	r3,806
 3228cb8:	18f25a04 	addi	r3,r3,-13976
 3228cbc:	1085883a 	add	r2,r2,r2
 3228cc0:	1085883a 	add	r2,r2,r2
 3228cc4:	10c5883a 	add	r2,r2,r3
 3228cc8:	10800017 	ldw	r2,0(r2)
 3228ccc:	10000d15 	stw	zero,52(r2)

   /* reset the broadcast addresses */
   nets[iface]->n_netbr    = 0;
 3228cd0:	e0bfff17 	ldw	r2,-4(fp)
 3228cd4:	00c0c9b4 	movhi	r3,806
 3228cd8:	18f25a04 	addi	r3,r3,-13976
 3228cdc:	1085883a 	add	r2,r2,r2
 3228ce0:	1085883a 	add	r2,r2,r2
 3228ce4:	10c5883a 	add	r2,r2,r3
 3228ce8:	10800017 	ldw	r2,0(r2)
 3228cec:	10000e15 	stw	zero,56(r2)
   nets[iface]->n_netbr42  = 0;
 3228cf0:	e0bfff17 	ldw	r2,-4(fp)
 3228cf4:	00c0c9b4 	movhi	r3,806
 3228cf8:	18f25a04 	addi	r3,r3,-13976
 3228cfc:	1085883a 	add	r2,r2,r2
 3228d00:	1085883a 	add	r2,r2,r2
 3228d04:	10c5883a 	add	r2,r2,r3
 3228d08:	10800017 	ldw	r2,0(r2)
 3228d0c:	10000f15 	stw	zero,60(r2)
   nets[iface]->n_subnetbr = 0;
 3228d10:	e0bfff17 	ldw	r2,-4(fp)
 3228d14:	00c0c9b4 	movhi	r3,806
 3228d18:	18f25a04 	addi	r3,r3,-13976
 3228d1c:	1085883a 	add	r2,r2,r2
 3228d20:	1085883a 	add	r2,r2,r2
 3228d24:	10c5883a 	add	r2,r2,r3
 3228d28:	10800017 	ldw	r2,0(r2)
 3228d2c:	10001015 	stw	zero,64(r2)

   return 0;   /* return OK code */
 3228d30:	0005883a 	mov	r2,zero
}
 3228d34:	e037883a 	mov	sp,fp
 3228d38:	df000017 	ldw	fp,0(sp)
 3228d3c:	dec00104 	addi	sp,sp,4
 3228d40:	f800283a 	ret

03228d44 <dhc_decline>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_decline(int iface,struct bootp * bp, unsigned bplen)
{
 3228d44:	defff704 	addi	sp,sp,-36
 3228d48:	dfc00815 	stw	ra,32(sp)
 3228d4c:	df000715 	stw	fp,28(sp)
 3228d50:	df000704 	addi	fp,sp,28
 3228d54:	e13ffc15 	stw	r4,-16(fp)
 3228d58:	e17ffd15 	stw	r5,-12(fp)
 3228d5c:	e1bffe15 	stw	r6,-8(fp)
   struct bootp * outbp;
   PACKET pkt;
   u_char * opts;    /* scratch pointer to DHCP options field */

   /* get a UDP packet buffer for sending DHCP */
   pkt = udp_alloc(bplen, 0);
 3228d60:	e13ffe17 	ldw	r4,-8(fp)
 3228d64:	000b883a 	mov	r5,zero
 3228d68:	32451900 	call	3245190 <udp_alloc>
 3228d6c:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 3228d70:	e0bffa17 	ldw	r2,-24(fp)
 3228d74:	1004c03a 	cmpne	r2,r2,zero
 3228d78:	1000031e 	bne	r2,zero,3228d88 <dhc_decline+0x44>
      return ENP_NOMEM;
 3228d7c:	00bffb04 	movi	r2,-20
 3228d80:	e0bfff15 	stw	r2,-4(fp)
 3228d84:	00002f06 	br	3228e44 <dhc_decline+0x100>
   pkt->nb_plen = bplen;
 3228d88:	e0fffa17 	ldw	r3,-24(fp)
 3228d8c:	e0bffe17 	ldw	r2,-8(fp)
 3228d90:	18800415 	stw	r2,16(r3)

   outbp = (struct bootp *)pkt->nb_prot;
 3228d94:	e0bffa17 	ldw	r2,-24(fp)
 3228d98:	10800317 	ldw	r2,12(r2)
 3228d9c:	e0bffb15 	stw	r2,-20(fp)
   MEMCPY(outbp, bp, bplen);
 3228da0:	e0bffb17 	ldw	r2,-20(fp)
 3228da4:	e0fffd17 	ldw	r3,-12(fp)
 3228da8:	1009883a 	mov	r4,r2
 3228dac:	180b883a 	mov	r5,r3
 3228db0:	e1bffe17 	ldw	r6,-8(fp)
 3228db4:	32067cc0 	call	32067cc <memcpy>
   outbp->op = BOOTREQUEST;
 3228db8:	e0fffb17 	ldw	r3,-20(fp)
 3228dbc:	00800044 	movi	r2,1
 3228dc0:	18800005 	stb	r2,0(r3)

   /* find DHCP TYPE option so we can overwrite it */   
   opts = find_opt(DHOP_TYPE, &outbp->options[4]);
 3228dc4:	e0bffb17 	ldw	r2,-20(fp)
 3228dc8:	10803b04 	addi	r2,r2,236
 3228dcc:	11400104 	addi	r5,r2,4
 3228dd0:	01000d44 	movi	r4,53
 3228dd4:	3229bec0 	call	3229bec <find_opt>
 3228dd8:	e0bff915 	stw	r2,-28(fp)
   opts += 2;     /* point to actual op code */
 3228ddc:	e0bff917 	ldw	r2,-28(fp)
 3228de0:	10800084 	addi	r2,r2,2
 3228de4:	e0bff915 	stw	r2,-28(fp)
   *opts = DHCP_DECLINE;   /* overwrite op code */
 3228de8:	e0fff917 	ldw	r3,-28(fp)
 3228dec:	00800104 	movi	r2,4
 3228df0:	18800005 	stb	r2,0(r3)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast decline pkt */
 3228df4:	e0fffa17 	ldw	r3,-24(fp)
 3228df8:	00bfffc4 	movi	r2,-1
 3228dfc:	18800715 	stw	r2,28(r3)
   pkt->net = nets[iface];    /* send out caller speced net */
 3228e00:	e0bffc17 	ldw	r2,-16(fp)
 3228e04:	00c0c9b4 	movhi	r3,806
 3228e08:	18f25a04 	addi	r3,r3,-13976
 3228e0c:	1085883a 	add	r2,r2,r2
 3228e10:	1085883a 	add	r2,r2,r2
 3228e14:	10c5883a 	add	r2,r2,r3
 3228e18:	10c00017 	ldw	r3,0(r2)
 3228e1c:	e0bffa17 	ldw	r2,-24(fp)
 3228e20:	10c00615 	stw	r3,24(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 3228e24:	010010c4 	movi	r4,67
 3228e28:	01401104 	movi	r5,68
 3228e2c:	e1bffa17 	ldw	r6,-24(fp)
 3228e30:	3244cd80 	call	3244cd8 <udp_send>
   dsc_declines++;   /* count declines sent */
 3228e34:	d0a8cd17 	ldw	r2,-23756(gp)
 3228e38:	10800044 	addi	r2,r2,1
 3228e3c:	d0a8cd15 	stw	r2,-23756(gp)
   return 0;
 3228e40:	e03fff15 	stw	zero,-4(fp)
 3228e44:	e0bfff17 	ldw	r2,-4(fp)
}
 3228e48:	e037883a 	mov	sp,fp
 3228e4c:	dfc00117 	ldw	ra,4(sp)
 3228e50:	df000017 	ldw	fp,0(sp)
 3228e54:	dec00204 	addi	sp,sp,8
 3228e58:	f800283a 	ret

03228e5c <dh_getlong>:
 *
 * RETURNS: the extracted 32 bit value
 */

static   long dh_getlong( u_char *ptr )
{
 3228e5c:	defffc04 	addi	sp,sp,-16
 3228e60:	df000315 	stw	fp,12(sp)
 3228e64:	df000304 	addi	fp,sp,12
 3228e68:	e13fff15 	stw	r4,-4(fp)
     long  v;
     u_char * p2 =  (u_char *)&v;
 3228e6c:	e0bffe04 	addi	r2,fp,-8
 3228e70:	e0bffd15 	stw	r2,-12(fp)

   *p2++ = *ptr++;
 3228e74:	e0bfff17 	ldw	r2,-4(fp)
 3228e78:	10c00003 	ldbu	r3,0(r2)
 3228e7c:	e0bffd17 	ldw	r2,-12(fp)
 3228e80:	10c00005 	stb	r3,0(r2)
 3228e84:	e0bffd17 	ldw	r2,-12(fp)
 3228e88:	10800044 	addi	r2,r2,1
 3228e8c:	e0bffd15 	stw	r2,-12(fp)
 3228e90:	e0bfff17 	ldw	r2,-4(fp)
 3228e94:	10800044 	addi	r2,r2,1
 3228e98:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 3228e9c:	e0bfff17 	ldw	r2,-4(fp)
 3228ea0:	10c00003 	ldbu	r3,0(r2)
 3228ea4:	e0bffd17 	ldw	r2,-12(fp)
 3228ea8:	10c00005 	stb	r3,0(r2)
 3228eac:	e0bffd17 	ldw	r2,-12(fp)
 3228eb0:	10800044 	addi	r2,r2,1
 3228eb4:	e0bffd15 	stw	r2,-12(fp)
 3228eb8:	e0bfff17 	ldw	r2,-4(fp)
 3228ebc:	10800044 	addi	r2,r2,1
 3228ec0:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 3228ec4:	e0bfff17 	ldw	r2,-4(fp)
 3228ec8:	10c00003 	ldbu	r3,0(r2)
 3228ecc:	e0bffd17 	ldw	r2,-12(fp)
 3228ed0:	10c00005 	stb	r3,0(r2)
 3228ed4:	e0bffd17 	ldw	r2,-12(fp)
 3228ed8:	10800044 	addi	r2,r2,1
 3228edc:	e0bffd15 	stw	r2,-12(fp)
 3228ee0:	e0bfff17 	ldw	r2,-4(fp)
 3228ee4:	10800044 	addi	r2,r2,1
 3228ee8:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 3228eec:	e0bfff17 	ldw	r2,-4(fp)
 3228ef0:	10c00003 	ldbu	r3,0(r2)
 3228ef4:	e0bffd17 	ldw	r2,-12(fp)
 3228ef8:	10c00005 	stb	r3,0(r2)
 3228efc:	e0bffd17 	ldw	r2,-12(fp)
 3228f00:	10800044 	addi	r2,r2,1
 3228f04:	e0bffd15 	stw	r2,-12(fp)
 3228f08:	e0bfff17 	ldw	r2,-4(fp)
 3228f0c:	10800044 	addi	r2,r2,1
 3228f10:	e0bfff15 	stw	r2,-4(fp)

   return v;
 3228f14:	e0bffe17 	ldw	r2,-8(fp)
}
 3228f18:	e037883a 	mov	sp,fp
 3228f1c:	df000017 	ldw	fp,0(sp)
 3228f20:	dec00104 	addi	sp,sp,4
 3228f24:	f800283a 	ret

03228f28 <dhc_extract_opts>:
 * of the options passed were filled in with good values. 
 */

int
dhc_extract_opts(int iface, u_char *opts)
{
 3228f28:	defff604 	addi	sp,sp,-40
 3228f2c:	dfc00915 	stw	ra,36(sp)
 3228f30:	df000815 	stw	fp,32(sp)
 3228f34:	dc400715 	stw	r17,28(sp)
 3228f38:	dc000615 	stw	r16,24(sp)
 3228f3c:	df000604 	addi	fp,sp,24
 3228f40:	e13ffc15 	stw	r4,-16(fp)
 3228f44:	e17ffd15 	stw	r5,-12(fp)
   u_char *end = opts + DHCP_OPTSIZE;  /* limit scope of search */
 3228f48:	e0bffd17 	ldw	r2,-12(fp)
 3228f4c:	10804e04 	addi	r2,r2,312
 3228f50:	e0bffb15 	stw	r2,-20(fp)
   u_char optlen;

   /* first, clear the options */
   dhc_states[iface].snmask = 0; 
 3228f54:	e0bffc17 	ldw	r2,-16(fp)
 3228f58:	00c0c9b4 	movhi	r3,806
 3228f5c:	18f28004 	addi	r3,r3,-13824
 3228f60:	10800f24 	muli	r2,r2,60
 3228f64:	10c5883a 	add	r2,r2,r3
 3228f68:	10800a04 	addi	r2,r2,40
 3228f6c:	10000015 	stw	zero,0(r2)
   dhc_states[iface].defgw = 0; 
 3228f70:	e0bffc17 	ldw	r2,-16(fp)
 3228f74:	00c0c9b4 	movhi	r3,806
 3228f78:	18f28004 	addi	r3,r3,-13824
 3228f7c:	10800f24 	muli	r2,r2,60
 3228f80:	10c5883a 	add	r2,r2,r3
 3228f84:	10800b04 	addi	r2,r2,44
 3228f88:	10000015 	stw	zero,0(r2)
   dhc_states[iface].lease = 0; 
 3228f8c:	e0bffc17 	ldw	r2,-16(fp)
 3228f90:	00c0c9b4 	movhi	r3,806
 3228f94:	18f28004 	addi	r3,r3,-13824
 3228f98:	10800f24 	muli	r2,r2,60
 3228f9c:	10c5883a 	add	r2,r2,r3
 3228fa0:	10800504 	addi	r2,r2,20
 3228fa4:	10000015 	stw	zero,0(r2)
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 3228fa8:	00008006 	br	32291ac <dhc_extract_opts+0x284>
   {
      switch (*opts++)
 3228fac:	e0bffd17 	ldw	r2,-12(fp)
 3228fb0:	10800003 	ldbu	r2,0(r2)
 3228fb4:	10803fcc 	andi	r2,r2,255
 3228fb8:	e0bfff15 	stw	r2,-4(fp)
 3228fbc:	e0bffd17 	ldw	r2,-12(fp)
 3228fc0:	10800044 	addi	r2,r2,1
 3228fc4:	e0bffd15 	stw	r2,-12(fp)
 3228fc8:	e0ffff17 	ldw	r3,-4(fp)
 3228fcc:	188000e0 	cmpeqi	r2,r3,3
 3228fd0:	1000271e 	bne	r2,zero,3229070 <dhc_extract_opts+0x148>
 3228fd4:	e0ffff17 	ldw	r3,-4(fp)
 3228fd8:	18800108 	cmpgei	r2,r3,4
 3228fdc:	1000071e 	bne	r2,zero,3228ffc <dhc_extract_opts+0xd4>
 3228fe0:	e0ffff17 	ldw	r3,-4(fp)
 3228fe4:	1805003a 	cmpeq	r2,r3,zero
 3228fe8:	1000701e 	bne	r2,zero,32291ac <dhc_extract_opts+0x284>
 3228fec:	e0ffff17 	ldw	r3,-4(fp)
 3228ff0:	18800060 	cmpeqi	r2,r3,1
 3228ff4:	10000d1e 	bne	r2,zero,322902c <dhc_extract_opts+0x104>
 3228ff8:	00006406 	br	322918c <dhc_extract_opts+0x264>
 3228ffc:	e0ffff17 	ldw	r3,-4(fp)
 3229000:	18800ce0 	cmpeqi	r2,r3,51
 3229004:	1000331e 	bne	r2,zero,32290d4 <dhc_extract_opts+0x1ac>
 3229008:	e0ffff17 	ldw	r3,-4(fp)
 322900c:	18803fe0 	cmpeqi	r2,r3,255
 3229010:	1000041e 	bne	r2,zero,3229024 <dhc_extract_opts+0xfc>
 3229014:	e0ffff17 	ldw	r3,-4(fp)
 3229018:	188001a0 	cmpeqi	r2,r3,6
 322901c:	10004f1e 	bne	r2,zero,322915c <dhc_extract_opts+0x234>
 3229020:	00005a06 	br	322918c <dhc_extract_opts+0x264>
      {
      case DHOP_PAD:
         break;
      case DHOP_END:
         return 0;   /* only good exit point */
 3229024:	e03ffe15 	stw	zero,-8(fp)
 3229028:	00006606 	br	32291c4 <dhc_extract_opts+0x29c>
      case DHOP_SNMASK:
         opts++;
 322902c:	e0bffd17 	ldw	r2,-12(fp)
 3229030:	10800044 	addi	r2,r2,1
 3229034:	e0bffd15 	stw	r2,-12(fp)
         dhc_states[iface].snmask = dh_getlong(opts);
 3229038:	e43ffc17 	ldw	r16,-16(fp)
 322903c:	e13ffd17 	ldw	r4,-12(fp)
 3229040:	3228e5c0 	call	3228e5c <dh_getlong>
 3229044:	1009883a 	mov	r4,r2
 3229048:	00c0c9b4 	movhi	r3,806
 322904c:	18f28004 	addi	r3,r3,-13824
 3229050:	80800f24 	muli	r2,r16,60
 3229054:	10c5883a 	add	r2,r2,r3
 3229058:	10800a04 	addi	r2,r2,40
 322905c:	11000015 	stw	r4,0(r2)
         opts += 4;
 3229060:	e0bffd17 	ldw	r2,-12(fp)
 3229064:	10800104 	addi	r2,r2,4
 3229068:	e0bffd15 	stw	r2,-12(fp)
         break;
 322906c:	00004f06 	br	32291ac <dhc_extract_opts+0x284>
      case DHOP_ROUTER:
         optlen = *opts++;
 3229070:	e0bffd17 	ldw	r2,-12(fp)
 3229074:	10800003 	ldbu	r2,0(r2)
 3229078:	e0bffa05 	stb	r2,-24(fp)
 322907c:	e0bffd17 	ldw	r2,-12(fp)
 3229080:	10800044 	addi	r2,r2,1
 3229084:	e0bffd15 	stw	r2,-12(fp)
         if (optlen >= 4)
 3229088:	e0bffa03 	ldbu	r2,-24(fp)
 322908c:	10800130 	cmpltui	r2,r2,4
 3229090:	10000a1e 	bne	r2,zero,32290bc <dhc_extract_opts+0x194>
            dhc_states[iface].defgw = dh_getlong(opts);
 3229094:	e43ffc17 	ldw	r16,-16(fp)
 3229098:	e13ffd17 	ldw	r4,-12(fp)
 322909c:	3228e5c0 	call	3228e5c <dh_getlong>
 32290a0:	1009883a 	mov	r4,r2
 32290a4:	00c0c9b4 	movhi	r3,806
 32290a8:	18f28004 	addi	r3,r3,-13824
 32290ac:	80800f24 	muli	r2,r16,60
 32290b0:	10c5883a 	add	r2,r2,r3
 32290b4:	10800b04 	addi	r2,r2,44
 32290b8:	11000015 	stw	r4,0(r2)
         opts += optlen;
 32290bc:	e0bffa03 	ldbu	r2,-24(fp)
 32290c0:	1007883a 	mov	r3,r2
 32290c4:	e0bffd17 	ldw	r2,-12(fp)
 32290c8:	10c5883a 	add	r2,r2,r3
 32290cc:	e0bffd15 	stw	r2,-12(fp)
         break;
 32290d0:	00003606 	br	32291ac <dhc_extract_opts+0x284>
      case DHOP_LEASE:
         opts++;
 32290d4:	e0bffd17 	ldw	r2,-12(fp)
 32290d8:	10800044 	addi	r2,r2,1
 32290dc:	e0bffd15 	stw	r2,-12(fp)
         dhc_states[iface].lease = htonl(dh_getlong(opts));
 32290e0:	e47ffc17 	ldw	r17,-16(fp)
 32290e4:	e13ffd17 	ldw	r4,-12(fp)
 32290e8:	3228e5c0 	call	3228e5c <dh_getlong>
 32290ec:	1005d63a 	srai	r2,r2,24
 32290f0:	14003fcc 	andi	r16,r2,255
 32290f4:	e13ffd17 	ldw	r4,-12(fp)
 32290f8:	3228e5c0 	call	3228e5c <dh_getlong>
 32290fc:	1005d23a 	srai	r2,r2,8
 3229100:	10bfc00c 	andi	r2,r2,65280
 3229104:	80a0b03a 	or	r16,r16,r2
 3229108:	e13ffd17 	ldw	r4,-12(fp)
 322910c:	3228e5c0 	call	3228e5c <dh_getlong>
 3229110:	10bfc00c 	andi	r2,r2,65280
 3229114:	1004923a 	slli	r2,r2,8
 3229118:	80a0b03a 	or	r16,r16,r2
 322911c:	e13ffd17 	ldw	r4,-12(fp)
 3229120:	3228e5c0 	call	3228e5c <dh_getlong>
 3229124:	10803fcc 	andi	r2,r2,255
 3229128:	1004963a 	slli	r2,r2,24
 322912c:	8084b03a 	or	r2,r16,r2
 3229130:	1009883a 	mov	r4,r2
 3229134:	00c0c9b4 	movhi	r3,806
 3229138:	18f28004 	addi	r3,r3,-13824
 322913c:	88800f24 	muli	r2,r17,60
 3229140:	10c5883a 	add	r2,r2,r3
 3229144:	10800504 	addi	r2,r2,20
 3229148:	11000015 	stw	r4,0(r2)
         opts += 4;
 322914c:	e0bffd17 	ldw	r2,-12(fp)
 3229150:	10800104 	addi	r2,r2,4
 3229154:	e0bffd15 	stw	r2,-12(fp)
         break;
 3229158:	00001406 	br	32291ac <dhc_extract_opts+0x284>
      case DHOP_DNSRV:
         optlen = *opts++;
 322915c:	e0bffd17 	ldw	r2,-12(fp)
 3229160:	10800003 	ldbu	r2,0(r2)
 3229164:	e0bffa05 	stb	r2,-24(fp)
 3229168:	e0bffd17 	ldw	r2,-12(fp)
 322916c:	10800044 	addi	r2,r2,1
 3229170:	e0bffd15 	stw	r2,-12(fp)
               opts += 4;
               i++;
            }
         }
#endif   /* DHC_MAXDNSRVS */
         opts += optlen;
 3229174:	e0bffa03 	ldbu	r2,-24(fp)
 3229178:	1007883a 	mov	r3,r2
 322917c:	e0bffd17 	ldw	r2,-12(fp)
 3229180:	10c5883a 	add	r2,r2,r3
 3229184:	e0bffd15 	stw	r2,-12(fp)
         break;
 3229188:	00000806 	br	32291ac <dhc_extract_opts+0x284>
      default:
         opts += ((*opts) + 1);
 322918c:	e0bffd17 	ldw	r2,-12(fp)
 3229190:	10800003 	ldbu	r2,0(r2)
 3229194:	10803fcc 	andi	r2,r2,255
 3229198:	1007883a 	mov	r3,r2
 322919c:	e0bffd17 	ldw	r2,-12(fp)
 32291a0:	1885883a 	add	r2,r3,r2
 32291a4:	10800044 	addi	r2,r2,1
 32291a8:	e0bffd15 	stw	r2,-12(fp)
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 32291ac:	e0fffd17 	ldw	r3,-12(fp)
 32291b0:	e0bffb17 	ldw	r2,-20(fp)
 32291b4:	10ff7d2e 	bgeu	r2,r3,3228fac <dhc_extract_opts+0x84>
      default:
         opts += ((*opts) + 1);
         break;
      }
   }
   dtrap();
 32291b8:	322ab8c0 	call	322ab8c <dtrap>
   return -1;
 32291bc:	00bfffc4 	movi	r2,-1
 32291c0:	e0bffe15 	stw	r2,-8(fp)
 32291c4:	e0bffe17 	ldw	r2,-8(fp)
}
 32291c8:	e037883a 	mov	sp,fp
 32291cc:	dfc00317 	ldw	ra,12(sp)
 32291d0:	df000217 	ldw	fp,8(sp)
 32291d4:	dc400117 	ldw	r17,4(sp)
 32291d8:	dc000017 	ldw	r16,0(sp)
 32291dc:	dec00404 	addi	sp,sp,16
 32291e0:	f800283a 	ret

032291e4 <dhc_second>:
 * RETURNS: Returns 0 or ENP_ error code 
 */

int
dhc_second(void)
{
 32291e4:	defff704 	addi	sp,sp,-36
 32291e8:	dfc00815 	stw	ra,32(sp)
 32291ec:	df000715 	stw	fp,28(sp)
 32291f0:	df000704 	addi	fp,sp,28
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 32291f4:	e03ffc15 	stw	zero,-16(fp)
 32291f8:	00015706 	br	3229758 <dhc_second+0x574>
   {
      switch (dhc_states[iface].state)
 32291fc:	e0bffc17 	ldw	r2,-16(fp)
 3229200:	00c0c9b4 	movhi	r3,806
 3229204:	18f28004 	addi	r3,r3,-13824
 3229208:	10800f24 	muli	r2,r2,60
 322920c:	10c5883a 	add	r2,r2,r3
 3229210:	10800017 	ldw	r2,0(r2)
 3229214:	e0bfff15 	stw	r2,-4(fp)
 3229218:	e0ffff17 	ldw	r3,-4(fp)
 322921c:	18800268 	cmpgeui	r2,r3,9
 3229220:	10014a1e 	bne	r2,zero,322974c <dhc_second+0x568>
 3229224:	e13fff17 	ldw	r4,-4(fp)
 3229228:	e13fff17 	ldw	r4,-4(fp)
 322922c:	2105883a 	add	r2,r4,r4
 3229230:	1087883a 	add	r3,r2,r2
 3229234:	0080c8f4 	movhi	r2,803
 3229238:	10a49204 	addi	r2,r2,-28088
 322923c:	1885883a 	add	r2,r3,r2
 3229240:	10800017 	ldw	r2,0(r2)
 3229244:	1000683a 	jmp	r2
 3229248:	0322974c 	andi	r12,zero,35421
 322924c:	0322926c 	andhi	r12,zero,35401
 3229250:	032292a4 	muli	r12,zero,-30134
 3229254:	032292dc 	xori	r12,zero,35403
 3229258:	032292dc 	xori	r12,zero,35403
 322925c:	032292dc 	xori	r12,zero,35403
 3229260:	03229540 	call	322954 <OSCtxSw_SWITCH_PC+0x322914>
 3229264:	032295f8 	rdprs	r12,zero,-30121
 3229268:	0322940c 	andi	r12,zero,35408
      {
      case DHCS_INIT:         /* Send a discover packet */
         e = dhc_discover(iface);
 322926c:	e13ffc17 	ldw	r4,-16(fp)
 3229270:	32278880 	call	3227888 <dhc_discover>
 3229274:	e0bffa15 	stw	r2,-24(fp)
         /* Error while sending a discover packet */
         if (e)
 3229278:	e0bffa17 	ldw	r2,-24(fp)
 322927c:	1005003a 	cmpeq	r2,r2,zero
 3229280:	1000041e 	bne	r2,zero,3229294 <dhc_second+0xb0>
         {
            dtrap();
 3229284:	322ab8c0 	call	322ab8c <dtrap>
            return e;
 3229288:	e0bffa17 	ldw	r2,-24(fp)
 322928c:	e0bffe15 	stw	r2,-8(fp)
 3229290:	00013506 	br	3229768 <dhc_second+0x584>
         }
         dhc_set_state(iface,DHCS_SELECTING);
 3229294:	e13ffc17 	ldw	r4,-16(fp)
 3229298:	01400104 	movi	r5,4
 322929c:	3229b3c0 	call	3229b3c <dhc_set_state>
         break;
 32292a0:	00012a06 	br	322974c <dhc_second+0x568>
      case DHCS_INITREBOOT:   /* Send a request packet */
         e = dhc_reclaim(iface);
 32292a4:	e13ffc17 	ldw	r4,-16(fp)
 32292a8:	32298080 	call	3229808 <dhc_reclaim>
 32292ac:	e0bffa15 	stw	r2,-24(fp)
         if (e)
 32292b0:	e0bffa17 	ldw	r2,-24(fp)
 32292b4:	1005003a 	cmpeq	r2,r2,zero
 32292b8:	1000041e 	bne	r2,zero,32292cc <dhc_second+0xe8>
         {
            dtrap();
 32292bc:	322ab8c0 	call	322ab8c <dtrap>
            return e;
 32292c0:	e0fffa17 	ldw	r3,-24(fp)
 32292c4:	e0fffe15 	stw	r3,-8(fp)
 32292c8:	00012706 	br	3229768 <dhc_second+0x584>
         }
         dhc_set_state(iface,DHCS_REBOOTING);
 32292cc:	e13ffc17 	ldw	r4,-16(fp)
 32292d0:	014000c4 	movi	r5,3
 32292d4:	3229b3c0 	call	3229b3c <dhc_set_state>
         break;
 32292d8:	00011c06 	br	322974c <dhc_second+0x568>
         /* Send discover packet on timeout */
      case DHCS_REBOOTING:
      case DHCS_REQUESTING:
         /* Discovery timeout = DHC_RETRY_TMO secs * (2 ** retries), max 64 */

         tries = dhc_states[iface].tries ;
 32292dc:	e0bffc17 	ldw	r2,-16(fp)
 32292e0:	00c0c9b4 	movhi	r3,806
 32292e4:	18f28004 	addi	r3,r3,-13824
 32292e8:	10800f24 	muli	r2,r2,60
 32292ec:	10c5883a 	add	r2,r2,r3
 32292f0:	10800104 	addi	r2,r2,4
 32292f4:	10800017 	ldw	r2,0(r2)
 32292f8:	e0bffb15 	stw	r2,-20(fp)

         /* Set the exponential count */
         if ( tries >= DHC_MAX_TRIES) 
 32292fc:	e0bffb17 	ldw	r2,-20(fp)
 3229300:	10800110 	cmplti	r2,r2,4
 3229304:	1000021e 	bne	r2,zero,3229310 <dhc_second+0x12c>
            tries= DHC_MAX_TRIES;
 3229308:	00800104 	movi	r2,4
 322930c:	e0bffb15 	stw	r2,-20(fp)
         if ( cticks > (dhc_states[iface].last_tick + 
 3229310:	e0bffc17 	ldw	r2,-16(fp)
 3229314:	00c0c9b4 	movhi	r3,806
 3229318:	18f28004 	addi	r3,r3,-13824
 322931c:	10800f24 	muli	r2,r2,60
 3229320:	10c5883a 	add	r2,r2,r3
 3229324:	10800404 	addi	r2,r2,16
 3229328:	11000017 	ldw	r4,0(r2)
 322932c:	00c3e804 	movi	r3,4000
 3229330:	e0bffb17 	ldw	r2,-20(fp)
 3229334:	1884983a 	sll	r2,r3,r2
 3229338:	2087883a 	add	r3,r4,r2
 322933c:	0080c974 	movhi	r2,805
 3229340:	10925604 	addi	r2,r2,18776
 3229344:	10800017 	ldw	r2,0(r2)
 3229348:	18801c2e 	bgeu	r3,r2,32293bc <dhc_second+0x1d8>
             (((u_long) (DHC_RETRY_TMO*TPS)) << tries ) ) )
         {
            /* Timeout while waiting for a OFFER/ACK/NAK. Retransmit */
            switch(dhc_states[iface].state)
 322934c:	e0bffc17 	ldw	r2,-16(fp)
 3229350:	00c0c9b4 	movhi	r3,806
 3229354:	18f28004 	addi	r3,r3,-13824
 3229358:	10800f24 	muli	r2,r2,60
 322935c:	10c5883a 	add	r2,r2,r3
 3229360:	10800017 	ldw	r2,0(r2)
 3229364:	e0bffd15 	stw	r2,-12(fp)
 3229368:	e13ffd17 	ldw	r4,-12(fp)
 322936c:	20800120 	cmpeqi	r2,r4,4
 3229370:	1000071e 	bne	r2,zero,3229390 <dhc_second+0x1ac>
 3229374:	e0fffd17 	ldw	r3,-12(fp)
 3229378:	18800160 	cmpeqi	r2,r3,5
 322937c:	1000071e 	bne	r2,zero,322939c <dhc_second+0x1b8>
 3229380:	e13ffd17 	ldw	r4,-12(fp)
 3229384:	208000e0 	cmpeqi	r2,r4,3
 3229388:	1000081e 	bne	r2,zero,32293ac <dhc_second+0x1c8>
 322938c:	00000a06 	br	32293b8 <dhc_second+0x1d4>
            {
            case DHCS_SELECTING:
               dhc_discover(iface);
 3229390:	e13ffc17 	ldw	r4,-16(fp)
 3229394:	32278880 	call	3227888 <dhc_discover>
               break;
 3229398:	00000806 	br	32293bc <dhc_second+0x1d8>
            case DHCS_REQUESTING:
               dhc_request(iface,FALSE);
 322939c:	e13ffc17 	ldw	r4,-16(fp)
 32293a0:	000b883a 	mov	r5,zero
 32293a4:	3227ea40 	call	3227ea4 <dhc_request>
               break;
 32293a8:	00000406 	br	32293bc <dhc_second+0x1d8>
            case DHCS_REBOOTING:
               dhc_reclaim(iface);
 32293ac:	e13ffc17 	ldw	r4,-16(fp)
 32293b0:	32298080 	call	3229808 <dhc_reclaim>
               break;
 32293b4:	00000106 	br	32293bc <dhc_second+0x1d8>
            default:
               dtrap(); /* bogus state */
 32293b8:	322ab8c0 	call	322ab8c <dtrap>
               break;
            }
         }
         if ( tries == DHC_MAX_TRIES && 
 32293bc:	e0bffb17 	ldw	r2,-20(fp)
 32293c0:	10800118 	cmpnei	r2,r2,4
 32293c4:	1000e11e 	bne	r2,zero,322974c <dhc_second+0x568>
 32293c8:	e0bffc17 	ldw	r2,-16(fp)
 32293cc:	00c0c9b4 	movhi	r3,806
 32293d0:	18f28004 	addi	r3,r3,-13824
 32293d4:	10800f24 	muli	r2,r2,60
 32293d8:	10c5883a 	add	r2,r2,r3
 32293dc:	10800017 	ldw	r2,0(r2)
 32293e0:	10800120 	cmpeqi	r2,r2,4
 32293e4:	1000d91e 	bne	r2,zero,322974c <dhc_second+0x568>
             (dhc_states[iface].state !=DHCS_SELECTING) )
         {
            /* We have tried enough. Restart from INIT state */
            dhc_set_state(iface,DHCS_RESTARTING);
 32293e8:	e13ffc17 	ldw	r4,-16(fp)
 32293ec:	01400244 	movi	r5,9
 32293f0:	3229b3c0 	call	3229b3c <dhc_set_state>
            dhc_resetip(iface);
 32293f4:	e13ffc17 	ldw	r4,-16(fp)
 32293f8:	3228c600 	call	3228c60 <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 32293fc:	e13ffc17 	ldw	r4,-16(fp)
 3229400:	01400044 	movi	r5,1
 3229404:	3229b3c0 	call	3229b3c <dhc_set_state>
         }
         break;
 3229408:	0000d006 	br	322974c <dhc_second+0x568>
      case DHCS_REBINDING:
         /* Check for timeout. Retry if we didn't get a ACK/NAK response. */

         if ( (dhc_states[iface].lease*TPS+dhc_states[iface].lease_start) > cticks )
 322940c:	e0bffc17 	ldw	r2,-16(fp)
 3229410:	00c0c9b4 	movhi	r3,806
 3229414:	18f28004 	addi	r3,r3,-13824
 3229418:	10800f24 	muli	r2,r2,60
 322941c:	10c5883a 	add	r2,r2,r3
 3229420:	10800504 	addi	r2,r2,20
 3229424:	10800017 	ldw	r2,0(r2)
 3229428:	1100fa24 	muli	r4,r2,1000
 322942c:	e0bffc17 	ldw	r2,-16(fp)
 3229430:	00c0c9b4 	movhi	r3,806
 3229434:	18f28004 	addi	r3,r3,-13824
 3229438:	10800f24 	muli	r2,r2,60
 322943c:	10c5883a 	add	r2,r2,r3
 3229440:	10800804 	addi	r2,r2,32
 3229444:	10800017 	ldw	r2,0(r2)
 3229448:	2087883a 	add	r3,r4,r2
 322944c:	0080c974 	movhi	r2,805
 3229450:	10925604 	addi	r2,r2,18776
 3229454:	10800017 	ldw	r2,0(r2)
 3229458:	10c0302e 	bgeu	r2,r3,322951c <dhc_second+0x338>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 322945c:	e0bffc17 	ldw	r2,-16(fp)
 3229460:	00c0c9b4 	movhi	r3,806
 3229464:	18f28004 	addi	r3,r3,-13824
 3229468:	10800f24 	muli	r2,r2,60
 322946c:	10c5883a 	add	r2,r2,r3
 3229470:	10800804 	addi	r2,r2,32
 3229474:	11000017 	ldw	r4,0(r2)
 3229478:	e0bffc17 	ldw	r2,-16(fp)
 322947c:	00c0c9b4 	movhi	r3,806
 3229480:	18f28004 	addi	r3,r3,-13824
 3229484:	10800f24 	muli	r2,r2,60
 3229488:	10c5883a 	add	r2,r2,r3
 322948c:	10800504 	addi	r2,r2,20
 3229490:	10800017 	ldw	r2,0(r2)
 3229494:	1080fa24 	muli	r2,r2,1000
 3229498:	2089883a 	add	r4,r4,r2
 322949c:	e0bffc17 	ldw	r2,-16(fp)
 32294a0:	00c0c9b4 	movhi	r3,806
 32294a4:	18f28004 	addi	r3,r3,-13824
 32294a8:	10800f24 	muli	r2,r2,60
 32294ac:	10c5883a 	add	r2,r2,r3
 32294b0:	10800404 	addi	r2,r2,16
 32294b4:	10800017 	ldw	r2,0(r2)
 32294b8:	2085c83a 	sub	r2,r4,r2
 32294bc:	1004d07a 	srli	r2,r2,1
 32294c0:	e0bff915 	stw	r2,-28(fp)
             dhc_states[iface].lease*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 32294c4:	e0fff917 	ldw	r3,-28(fp)
 32294c8:	00ba97d4 	movui	r2,59999
 32294cc:	10c00236 	bltu	r2,r3,32294d8 <dhc_second+0x2f4>
               half_time = 60*TPS;
 32294d0:	00ba9814 	movui	r2,60000
 32294d4:	e0bff915 	stw	r2,-28(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 32294d8:	e0bffc17 	ldw	r2,-16(fp)
 32294dc:	00c0c9b4 	movhi	r3,806
 32294e0:	18f28004 	addi	r3,r3,-13824
 32294e4:	10800f24 	muli	r2,r2,60
 32294e8:	10c5883a 	add	r2,r2,r3
 32294ec:	10800404 	addi	r2,r2,16
 32294f0:	10c00017 	ldw	r3,0(r2)
 32294f4:	e0bff917 	ldw	r2,-28(fp)
 32294f8:	1887883a 	add	r3,r3,r2
 32294fc:	0080c974 	movhi	r2,805
 3229500:	10925604 	addi	r2,r2,18776
 3229504:	10800017 	ldw	r2,0(r2)
 3229508:	1880902e 	bgeu	r3,r2,322974c <dhc_second+0x568>
            {
               dhc_request(iface,FALSE);
 322950c:	e13ffc17 	ldw	r4,-16(fp)
 3229510:	000b883a 	mov	r5,zero
 3229514:	3227ea40 	call	3227ea4 <dhc_request>
 3229518:	00008c06 	br	322974c <dhc_second+0x568>
            }
         }
         else
         {
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
 322951c:	e13ffc17 	ldw	r4,-16(fp)
 3229520:	01400244 	movi	r5,9
 3229524:	3229b3c0 	call	3229b3c <dhc_set_state>
            dhc_resetip(iface);
 3229528:	e13ffc17 	ldw	r4,-16(fp)
 322952c:	3228c600 	call	3228c60 <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 3229530:	e13ffc17 	ldw	r4,-16(fp)
 3229534:	01400044 	movi	r5,1
 3229538:	3229b3c0 	call	3229b3c <dhc_set_state>
         }
         break;
 322953c:	00008306 	br	322974c <dhc_second+0x568>

      case DHCS_BOUND:
         /* Test for lease expiry. The RENEW timer. */
         if ( (dhc_states[iface].t1 != DHC_INFINITY) &&
 3229540:	e0bffc17 	ldw	r2,-16(fp)
 3229544:	00c0c9b4 	movhi	r3,806
 3229548:	18f28004 	addi	r3,r3,-13824
 322954c:	10800f24 	muli	r2,r2,60
 3229550:	10c5883a 	add	r2,r2,r3
 3229554:	10800604 	addi	r2,r2,24
 3229558:	10800017 	ldw	r2,0(r2)
 322955c:	10bfffe0 	cmpeqi	r2,r2,-1
 3229560:	10007a1e 	bne	r2,zero,322974c <dhc_second+0x568>
 3229564:	e0bffc17 	ldw	r2,-16(fp)
 3229568:	00c0c9b4 	movhi	r3,806
 322956c:	18f28004 	addi	r3,r3,-13824
 3229570:	10800f24 	muli	r2,r2,60
 3229574:	10c5883a 	add	r2,r2,r3
 3229578:	10800604 	addi	r2,r2,24
 322957c:	10800017 	ldw	r2,0(r2)
 3229580:	1100fa24 	muli	r4,r2,1000
 3229584:	e0bffc17 	ldw	r2,-16(fp)
 3229588:	00c0c9b4 	movhi	r3,806
 322958c:	18f28004 	addi	r3,r3,-13824
 3229590:	10800f24 	muli	r2,r2,60
 3229594:	10c5883a 	add	r2,r2,r3
 3229598:	10800804 	addi	r2,r2,32
 322959c:	10800017 	ldw	r2,0(r2)
 32295a0:	2087883a 	add	r3,r4,r2
 32295a4:	0080c974 	movhi	r2,805
 32295a8:	10925604 	addi	r2,r2,18776
 32295ac:	10800017 	ldw	r2,0(r2)
 32295b0:	1880662e 	bgeu	r3,r2,322974c <dhc_second+0x568>
             (((dhc_states[iface].t1*TPS)+dhc_states[iface].lease_start) < cticks ) )
         {
            /* Time to renew. Send a UNICAST to the DHCP server */
            dhc_set_state(iface,DHCS_RENEWING);
 32295b4:	e13ffc17 	ldw	r4,-16(fp)
 32295b8:	014001c4 	movi	r5,7
 32295bc:	3229b3c0 	call	3229b3c <dhc_set_state>
            e = dhc_reclaim(iface); /* unicast */ 
 32295c0:	e13ffc17 	ldw	r4,-16(fp)
 32295c4:	32298080 	call	3229808 <dhc_reclaim>
 32295c8:	e0bffa15 	stw	r2,-24(fp)
            if (e)
 32295cc:	e0bffa17 	ldw	r2,-24(fp)
 32295d0:	1005003a 	cmpeq	r2,r2,zero
 32295d4:	1000041e 	bne	r2,zero,32295e8 <dhc_second+0x404>
            {
               dtrap();
 32295d8:	322ab8c0 	call	322ab8c <dtrap>
               return e;
 32295dc:	e0bffa17 	ldw	r2,-24(fp)
 32295e0:	e0bffe15 	stw	r2,-8(fp)
 32295e4:	00006006 	br	3229768 <dhc_second+0x584>
            }
            dsc_renew++;
 32295e8:	d0a8d017 	ldw	r2,-23744(gp)
 32295ec:	10800044 	addi	r2,r2,1
 32295f0:	d0a8d015 	stw	r2,-23744(gp)
         }
         break;
 32295f4:	00005506 	br	322974c <dhc_second+0x568>
      case DHCS_RENEWING:
         /* Test for lease expiry. The REBIND timer. */
         if ( (dhc_states[iface].t2*TPS+dhc_states[iface].lease_start) > cticks )
 32295f8:	e0bffc17 	ldw	r2,-16(fp)
 32295fc:	00c0c9b4 	movhi	r3,806
 3229600:	18f28004 	addi	r3,r3,-13824
 3229604:	10800f24 	muli	r2,r2,60
 3229608:	10c5883a 	add	r2,r2,r3
 322960c:	10800704 	addi	r2,r2,28
 3229610:	10800017 	ldw	r2,0(r2)
 3229614:	1100fa24 	muli	r4,r2,1000
 3229618:	e0bffc17 	ldw	r2,-16(fp)
 322961c:	00c0c9b4 	movhi	r3,806
 3229620:	18f28004 	addi	r3,r3,-13824
 3229624:	10800f24 	muli	r2,r2,60
 3229628:	10c5883a 	add	r2,r2,r3
 322962c:	10800804 	addi	r2,r2,32
 3229630:	10800017 	ldw	r2,0(r2)
 3229634:	2087883a 	add	r3,r4,r2
 3229638:	0080c974 	movhi	r2,805
 322963c:	10925604 	addi	r2,r2,18776
 3229640:	10800017 	ldw	r2,0(r2)
 3229644:	10c0302e 	bgeu	r2,r3,3229708 <dhc_second+0x524>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 3229648:	e0bffc17 	ldw	r2,-16(fp)
 322964c:	00c0c9b4 	movhi	r3,806
 3229650:	18f28004 	addi	r3,r3,-13824
 3229654:	10800f24 	muli	r2,r2,60
 3229658:	10c5883a 	add	r2,r2,r3
 322965c:	10800804 	addi	r2,r2,32
 3229660:	11000017 	ldw	r4,0(r2)
 3229664:	e0bffc17 	ldw	r2,-16(fp)
 3229668:	00c0c9b4 	movhi	r3,806
 322966c:	18f28004 	addi	r3,r3,-13824
 3229670:	10800f24 	muli	r2,r2,60
 3229674:	10c5883a 	add	r2,r2,r3
 3229678:	10800704 	addi	r2,r2,28
 322967c:	10800017 	ldw	r2,0(r2)
 3229680:	1080fa24 	muli	r2,r2,1000
 3229684:	2089883a 	add	r4,r4,r2
 3229688:	e0bffc17 	ldw	r2,-16(fp)
 322968c:	00c0c9b4 	movhi	r3,806
 3229690:	18f28004 	addi	r3,r3,-13824
 3229694:	10800f24 	muli	r2,r2,60
 3229698:	10c5883a 	add	r2,r2,r3
 322969c:	10800404 	addi	r2,r2,16
 32296a0:	10800017 	ldw	r2,0(r2)
 32296a4:	2085c83a 	sub	r2,r4,r2
 32296a8:	1004d07a 	srli	r2,r2,1
 32296ac:	e0bff915 	stw	r2,-28(fp)
             dhc_states[iface].t2*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 32296b0:	e0fff917 	ldw	r3,-28(fp)
 32296b4:	00ba97d4 	movui	r2,59999
 32296b8:	10c00236 	bltu	r2,r3,32296c4 <dhc_second+0x4e0>
               half_time = 60*TPS;
 32296bc:	00ba9814 	movui	r2,60000
 32296c0:	e0bff915 	stw	r2,-28(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 32296c4:	e0bffc17 	ldw	r2,-16(fp)
 32296c8:	00c0c9b4 	movhi	r3,806
 32296cc:	18f28004 	addi	r3,r3,-13824
 32296d0:	10800f24 	muli	r2,r2,60
 32296d4:	10c5883a 	add	r2,r2,r3
 32296d8:	10800404 	addi	r2,r2,16
 32296dc:	10c00017 	ldw	r3,0(r2)
 32296e0:	e0bff917 	ldw	r2,-28(fp)
 32296e4:	1887883a 	add	r3,r3,r2
 32296e8:	0080c974 	movhi	r2,805
 32296ec:	10925604 	addi	r2,r2,18776
 32296f0:	10800017 	ldw	r2,0(r2)
 32296f4:	1880152e 	bgeu	r3,r2,322974c <dhc_second+0x568>
            {
               dhc_request(iface,FALSE);
 32296f8:	e13ffc17 	ldw	r4,-16(fp)
 32296fc:	000b883a 	mov	r5,zero
 3229700:	3227ea40 	call	3227ea4 <dhc_request>
 3229704:	00001106 	br	322974c <dhc_second+0x568>
         {
            /* No Response has come from the Server that assigned our 
             * IP. Hence send a broadcast packet to see if we can 
             * lease this IP from some other server 
             */
            dhc_set_state(iface,DHCS_REBINDING);
 3229708:	e13ffc17 	ldw	r4,-16(fp)
 322970c:	01400204 	movi	r5,8
 3229710:	3229b3c0 	call	3229b3c <dhc_set_state>
            e = dhc_request(iface,TRUE);  /* broadcast */
 3229714:	e13ffc17 	ldw	r4,-16(fp)
 3229718:	01400044 	movi	r5,1
 322971c:	3227ea40 	call	3227ea4 <dhc_request>
 3229720:	e0bffa15 	stw	r2,-24(fp)
            if (e)
 3229724:	e0bffa17 	ldw	r2,-24(fp)
 3229728:	1005003a 	cmpeq	r2,r2,zero
 322972c:	1000041e 	bne	r2,zero,3229740 <dhc_second+0x55c>
            {
               dtrap();
 3229730:	322ab8c0 	call	322ab8c <dtrap>
               return e;
 3229734:	e0fffa17 	ldw	r3,-24(fp)
 3229738:	e0fffe15 	stw	r3,-8(fp)
 322973c:	00000a06 	br	3229768 <dhc_second+0x584>
            }
            dsc_rebind++;
 3229740:	d0a8d117 	ldw	r2,-23740(gp)
 3229744:	10800044 	addi	r2,r2,1
 3229748:	d0a8d115 	stw	r2,-23740(gp)
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 322974c:	e0bffc17 	ldw	r2,-16(fp)
 3229750:	10800044 	addi	r2,r2,1
 3229754:	e0bffc15 	stw	r2,-16(fp)
 3229758:	e0bffc17 	ldw	r2,-16(fp)
 322975c:	10800110 	cmplti	r2,r2,4
 3229760:	103ea61e 	bne	r2,zero,32291fc <dhc_second+0x18>
      case DHCS_UNUSED:
      default:
         continue;
      }
   }
   return 0;
 3229764:	e03ffe15 	stw	zero,-8(fp)
 3229768:	e0bffe17 	ldw	r2,-8(fp)
}
 322976c:	e037883a 	mov	sp,fp
 3229770:	dfc00117 	ldw	ra,4(sp)
 3229774:	df000017 	ldw	fp,0(sp)
 3229778:	dec00204 	addi	sp,sp,8
 322977c:	f800283a 	ret

03229780 <dhc_halt>:
 * RETURNS: void
 */

void
dhc_halt(int iface)
{
 3229780:	defffd04 	addi	sp,sp,-12
 3229784:	dfc00215 	stw	ra,8(sp)
 3229788:	df000115 	stw	fp,4(sp)
 322978c:	df000104 	addi	fp,sp,4
 3229790:	e13fff15 	stw	r4,-4(fp)
   if (iface < 0 || iface > MAXNETS)
 3229794:	e0bfff17 	ldw	r2,-4(fp)
 3229798:	1004803a 	cmplt	r2,r2,zero
 322979c:	1000031e 	bne	r2,zero,32297ac <dhc_halt+0x2c>
 32297a0:	e0bfff17 	ldw	r2,-4(fp)
 32297a4:	10800150 	cmplti	r2,r2,5
 32297a8:	1000021e 	bne	r2,zero,32297b4 <dhc_halt+0x34>
   {
      dtrap();
 32297ac:	322ab8c0 	call	322ab8c <dtrap>
      return;
 32297b0:	00001006 	br	32297f4 <dhc_halt+0x74>
   }
   /* clear dhc_states entry - (kills retrys) */
   MEMSET(&dhc_states[iface], 0, sizeof(struct dhc_state));
 32297b4:	e0bfff17 	ldw	r2,-4(fp)
 32297b8:	10800f24 	muli	r2,r2,60
 32297bc:	1007883a 	mov	r3,r2
 32297c0:	0080c9b4 	movhi	r2,806
 32297c4:	10b28004 	addi	r2,r2,-13824
 32297c8:	1885883a 	add	r2,r3,r2
 32297cc:	1009883a 	mov	r4,r2
 32297d0:	01800f04 	movi	r6,60
 32297d4:	000b883a 	mov	r5,zero
 32297d8:	320694c0 	call	320694c <memset>
   dhc_states[iface].state = DHCS_UNUSED;
 32297dc:	e0bfff17 	ldw	r2,-4(fp)
 32297e0:	00c0c9b4 	movhi	r3,806
 32297e4:	18f28004 	addi	r3,r3,-13824
 32297e8:	10800f24 	muli	r2,r2,60
 32297ec:	10c5883a 	add	r2,r2,r3
 32297f0:	10000015 	stw	zero,0(r2)
}
 32297f4:	e037883a 	mov	sp,fp
 32297f8:	dfc00117 	ldw	ra,4(sp)
 32297fc:	df000017 	ldw	fp,0(sp)
 3229800:	dec00204 	addi	sp,sp,8
 3229804:	f800283a 	ret

03229808 <dhc_reclaim>:
 * RETURNS: Returns 0 if DHCP request was sent OK, else non-zero error. 
 */

int   
dhc_reclaim(int iface)
{
 3229808:	defffb04 	addi	sp,sp,-20
 322980c:	dfc00415 	stw	ra,16(sp)
 3229810:	df000315 	stw	fp,12(sp)
 3229814:	df000304 	addi	fp,sp,12
 3229818:	e13ffe15 	stw	r4,-8(fp)
   /* punt if IP address is not set */
   if (nets[iface]->n_ipaddr == 0L)
 322981c:	e0bffe17 	ldw	r2,-8(fp)
 3229820:	00c0c9b4 	movhi	r3,806
 3229824:	18f25a04 	addi	r3,r3,-13976
 3229828:	1085883a 	add	r2,r2,r2
 322982c:	1085883a 	add	r2,r2,r2
 3229830:	10c5883a 	add	r2,r2,r3
 3229834:	10800017 	ldw	r2,0(r2)
 3229838:	10800a17 	ldw	r2,40(r2)
 322983c:	1004c03a 	cmpne	r2,r2,zero
 3229840:	1000041e 	bne	r2,zero,3229854 <dhc_reclaim+0x4c>
   {
      dtrap();    /* programming bug? */
 3229844:	322ab8c0 	call	322ab8c <dtrap>
      return ENP_LOGIC;
 3229848:	00bffd44 	movi	r2,-11
 322984c:	e0bfff15 	stw	r2,-4(fp)
 3229850:	00005b06 	br	32299c0 <dhc_reclaim+0x1b8>
   }

   dhc_states[iface].ipaddr = nets[iface]->n_ipaddr;
 3229854:	e17ffe17 	ldw	r5,-8(fp)
 3229858:	e0bffe17 	ldw	r2,-8(fp)
 322985c:	00c0c9b4 	movhi	r3,806
 3229860:	18f25a04 	addi	r3,r3,-13976
 3229864:	1085883a 	add	r2,r2,r2
 3229868:	1085883a 	add	r2,r2,r2
 322986c:	10c5883a 	add	r2,r2,r3
 3229870:	10800017 	ldw	r2,0(r2)
 3229874:	11000a17 	ldw	r4,40(r2)
 3229878:	00c0c9b4 	movhi	r3,806
 322987c:	18f28004 	addi	r3,r3,-13824
 3229880:	28800f24 	muli	r2,r5,60
 3229884:	10c5883a 	add	r2,r2,r3
 3229888:	10800904 	addi	r2,r2,36
 322988c:	11000015 	stw	r4,0(r2)
   dhc_states[iface].snmask = nets[iface]->snmask;
 3229890:	e17ffe17 	ldw	r5,-8(fp)
 3229894:	e0bffe17 	ldw	r2,-8(fp)
 3229898:	00c0c9b4 	movhi	r3,806
 322989c:	18f25a04 	addi	r3,r3,-13976
 32298a0:	1085883a 	add	r2,r2,r2
 32298a4:	1085883a 	add	r2,r2,r2
 32298a8:	10c5883a 	add	r2,r2,r3
 32298ac:	10800017 	ldw	r2,0(r2)
 32298b0:	11000c17 	ldw	r4,48(r2)
 32298b4:	00c0c9b4 	movhi	r3,806
 32298b8:	18f28004 	addi	r3,r3,-13824
 32298bc:	28800f24 	muli	r2,r5,60
 32298c0:	10c5883a 	add	r2,r2,r3
 32298c4:	10800a04 	addi	r2,r2,40
 32298c8:	11000015 	stw	r4,0(r2)
   dhc_states[iface].defgw  = nets[iface]->n_defgw;
 32298cc:	e17ffe17 	ldw	r5,-8(fp)
 32298d0:	e0bffe17 	ldw	r2,-8(fp)
 32298d4:	00c0c9b4 	movhi	r3,806
 32298d8:	18f25a04 	addi	r3,r3,-13976
 32298dc:	1085883a 	add	r2,r2,r2
 32298e0:	1085883a 	add	r2,r2,r2
 32298e4:	10c5883a 	add	r2,r2,r3
 32298e8:	10800017 	ldw	r2,0(r2)
 32298ec:	11000d17 	ldw	r4,52(r2)
 32298f0:	00c0c9b4 	movhi	r3,806
 32298f4:	18f28004 	addi	r3,r3,-13824
 32298f8:	28800f24 	muli	r2,r5,60
 32298fc:	10c5883a 	add	r2,r2,r3
 3229900:	10800b04 	addi	r2,r2,44
 3229904:	11000015 	stw	r4,0(r2)

#ifdef IP_ROUTING
   /* If the DHCP Server is on other network, route the request
    * from the same DHCP relay agent. To do that, add a route.
    */
   if (dhc_states[iface].rly_ipaddr)
 3229908:	e0bffe17 	ldw	r2,-8(fp)
 322990c:	00c0c9b4 	movhi	r3,806
 3229910:	18f28004 	addi	r3,r3,-13824
 3229914:	10800f24 	muli	r2,r2,60
 3229918:	10c5883a 	add	r2,r2,r3
 322991c:	10800c04 	addi	r2,r2,48
 3229920:	10800017 	ldw	r2,0(r2)
 3229924:	1005003a 	cmpeq	r2,r2,zero
 3229928:	1000211e 	bne	r2,zero,32299b0 <dhc_reclaim+0x1a8>
   {
      if (dhc_states[iface].srv_ipaddr)
 322992c:	e0bffe17 	ldw	r2,-8(fp)
 3229930:	00c0c9b4 	movhi	r3,806
 3229934:	18f28004 	addi	r3,r3,-13824
 3229938:	10800f24 	muli	r2,r2,60
 322993c:	10c5883a 	add	r2,r2,r3
 3229940:	10800d04 	addi	r2,r2,52
 3229944:	10800017 	ldw	r2,0(r2)
 3229948:	1005003a 	cmpeq	r2,r2,zero
 322994c:	1000171e 	bne	r2,zero,32299ac <dhc_reclaim+0x1a4>
      {
         /* yes, earlier negotiation was done via a relay agent */
         if ( !add_route(dhc_states[iface].srv_ipaddr, 0xFFFFFFFF,
 3229950:	e0bffe17 	ldw	r2,-8(fp)
 3229954:	00c0c9b4 	movhi	r3,806
 3229958:	18f28004 	addi	r3,r3,-13824
 322995c:	10800f24 	muli	r2,r2,60
 3229960:	10c5883a 	add	r2,r2,r3
 3229964:	10800d04 	addi	r2,r2,52
 3229968:	11000017 	ldw	r4,0(r2)
 322996c:	e0bffe17 	ldw	r2,-8(fp)
 3229970:	00c0c9b4 	movhi	r3,806
 3229974:	18f28004 	addi	r3,r3,-13824
 3229978:	10800f24 	muli	r2,r2,60
 322997c:	10c5883a 	add	r2,r2,r3
 3229980:	10800c04 	addi	r2,r2,48
 3229984:	11800017 	ldw	r6,0(r2)
 3229988:	00800084 	movi	r2,2
 322998c:	d8800015 	stw	r2,0(sp)
 3229990:	017fffc4 	movi	r5,-1
 3229994:	e1fffe17 	ldw	r7,-8(fp)
 3229998:	3243f140 	call	3243f14 <add_route>
 322999c:	1004c03a 	cmpne	r2,r2,zero
 32299a0:	1000031e 	bne	r2,zero,32299b0 <dhc_reclaim+0x1a8>
             dhc_states[iface].rly_ipaddr, iface, IPRP_LOCAL))
         {
            /* route was not added. check this case */
            dtrap(); 
 32299a4:	322ab8c0 	call	322ab8c <dtrap>
 32299a8:	00000106 	br	32299b0 <dhc_reclaim+0x1a8>
      else
      {
         /* DHCP relay IP address is set, but DHCP Server IP address is
          * not set ! How can this happen ?
          */
         dtrap();
 32299ac:	322ab8c0 	call	322ab8c <dtrap>
      }
   }
#endif  /* IP_ROUTING */

   /* send the request */
   return(dhc_request(iface,TRUE));  
 32299b0:	e13ffe17 	ldw	r4,-8(fp)
 32299b4:	01400044 	movi	r5,1
 32299b8:	3227ea40 	call	3227ea4 <dhc_request>
 32299bc:	e0bfff15 	stw	r2,-4(fp)
 32299c0:	e0bfff17 	ldw	r2,-4(fp)
}
 32299c4:	e037883a 	mov	sp,fp
 32299c8:	dfc00117 	ldw	ra,4(sp)
 32299cc:	df000017 	ldw	fp,0(sp)
 32299d0:	dec00204 	addi	sp,sp,8
 32299d4:	f800283a 	ret

032299d8 <dhc_state_init>:
 * RETURNS: void
 */

void 
dhc_state_init(int iface, int init_flag)
{
 32299d8:	defffa04 	addi	sp,sp,-24
 32299dc:	dfc00515 	stw	ra,20(sp)
 32299e0:	df000415 	stw	fp,16(sp)
 32299e4:	df000404 	addi	fp,sp,16
 32299e8:	e13ffd15 	stw	r4,-12(fp)
 32299ec:	e17ffe15 	stw	r5,-8(fp)
   int state = (init_flag == TRUE) ? DHCS_INIT : DHCS_INITREBOOT;
 32299f0:	e0bffe17 	ldw	r2,-8(fp)
 32299f4:	10800058 	cmpnei	r2,r2,1
 32299f8:	1000031e 	bne	r2,zero,3229a08 <dhc_state_init+0x30>
 32299fc:	00800044 	movi	r2,1
 3229a00:	e0bfff15 	stw	r2,-4(fp)
 3229a04:	00000206 	br	3229a10 <dhc_state_init+0x38>
 3229a08:	00800084 	movi	r2,2
 3229a0c:	e0bfff15 	stw	r2,-4(fp)
 3229a10:	e0bfff17 	ldw	r2,-4(fp)
 3229a14:	e0bffc15 	stw	r2,-16(fp)
   
   dhc_set_state(iface, state);
 3229a18:	e13ffd17 	ldw	r4,-12(fp)
 3229a1c:	e17ffc17 	ldw	r5,-16(fp)
 3229a20:	3229b3c0 	call	3229b3c <dhc_set_state>
}
 3229a24:	e037883a 	mov	sp,fp
 3229a28:	dfc00117 	ldw	ra,4(sp)
 3229a2c:	df000017 	ldw	fp,0(sp)
 3229a30:	dec00204 	addi	sp,sp,8
 3229a34:	f800283a 	ret

03229a38 <dhc_alldone>:
 * otherwise. 
 */

int 
dhc_alldone(void)
{
 3229a38:	defffd04 	addi	sp,sp,-12
 3229a3c:	df000215 	stw	fp,8(sp)
 3229a40:	df000204 	addi	fp,sp,8
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 3229a44:	e03ffe15 	stw	zero,-8(fp)
 3229a48:	00001506 	br	3229aa0 <dhc_alldone+0x68>
   {
      if ( ( dhc_states[i].state == DHCS_UNUSED ) || 
 3229a4c:	e0bffe17 	ldw	r2,-8(fp)
 3229a50:	00c0c9b4 	movhi	r3,806
 3229a54:	18f28004 	addi	r3,r3,-13824
 3229a58:	10800f24 	muli	r2,r2,60
 3229a5c:	10c5883a 	add	r2,r2,r3
 3229a60:	10800017 	ldw	r2,0(r2)
 3229a64:	1005003a 	cmpeq	r2,r2,zero
 3229a68:	10000a1e 	bne	r2,zero,3229a94 <dhc_alldone+0x5c>
 3229a6c:	e0bffe17 	ldw	r2,-8(fp)
 3229a70:	00c0c9b4 	movhi	r3,806
 3229a74:	18f28004 	addi	r3,r3,-13824
 3229a78:	10800f24 	muli	r2,r2,60
 3229a7c:	10c5883a 	add	r2,r2,r3
 3229a80:	10800017 	ldw	r2,0(r2)
 3229a84:	108001a0 	cmpeqi	r2,r2,6
 3229a88:	1000021e 	bne	r2,zero,3229a94 <dhc_alldone+0x5c>
      {
         continue ;
      }
      else
      {
         return FALSE ;
 3229a8c:	e03fff15 	stw	zero,-4(fp)
 3229a90:	00000806 	br	3229ab4 <dhc_alldone+0x7c>

int 
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 3229a94:	e0bffe17 	ldw	r2,-8(fp)
 3229a98:	10800044 	addi	r2,r2,1
 3229a9c:	e0bffe15 	stw	r2,-8(fp)
 3229aa0:	e0bffe17 	ldw	r2,-8(fp)
 3229aa4:	10800110 	cmplti	r2,r2,4
 3229aa8:	103fe81e 	bne	r2,zero,3229a4c <dhc_alldone+0x14>
      else
      {
         return FALSE ;
      }
   }
   return TRUE ;
 3229aac:	00800044 	movi	r2,1
 3229ab0:	e0bfff15 	stw	r2,-4(fp)
 3229ab4:	e0bfff17 	ldw	r2,-4(fp)
}
 3229ab8:	e037883a 	mov	sp,fp
 3229abc:	df000017 	ldw	fp,0(sp)
 3229ac0:	dec00104 	addi	sp,sp,4
 3229ac4:	f800283a 	ret

03229ac8 <dhc_ifacedone>:
 * RETURNS: 
 */

int 
dhc_ifacedone(int iface)
{
 3229ac8:	defffd04 	addi	sp,sp,-12
 3229acc:	df000215 	stw	fp,8(sp)
 3229ad0:	df000204 	addi	fp,sp,8
 3229ad4:	e13ffe15 	stw	r4,-8(fp)
   if ( ( dhc_states[iface].state == DHCS_UNUSED ) || 
 3229ad8:	e0bffe17 	ldw	r2,-8(fp)
 3229adc:	00c0c9b4 	movhi	r3,806
 3229ae0:	18f28004 	addi	r3,r3,-13824
 3229ae4:	10800f24 	muli	r2,r2,60
 3229ae8:	10c5883a 	add	r2,r2,r3
 3229aec:	10800017 	ldw	r2,0(r2)
 3229af0:	1005003a 	cmpeq	r2,r2,zero
 3229af4:	1000081e 	bne	r2,zero,3229b18 <dhc_ifacedone+0x50>
 3229af8:	e0bffe17 	ldw	r2,-8(fp)
 3229afc:	00c0c9b4 	movhi	r3,806
 3229b00:	18f28004 	addi	r3,r3,-13824
 3229b04:	10800f24 	muli	r2,r2,60
 3229b08:	10c5883a 	add	r2,r2,r3
 3229b0c:	10800017 	ldw	r2,0(r2)
 3229b10:	10800198 	cmpnei	r2,r2,6
 3229b14:	1000031e 	bne	r2,zero,3229b24 <dhc_ifacedone+0x5c>
       ( dhc_states[iface].state == DHCS_BOUND  )  )
   {
      return TRUE ;
 3229b18:	00800044 	movi	r2,1
 3229b1c:	e0bfff15 	stw	r2,-4(fp)
 3229b20:	00000106 	br	3229b28 <dhc_ifacedone+0x60>
   }
   else
   {
      return FALSE ;
 3229b24:	e03fff15 	stw	zero,-4(fp)
 3229b28:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 3229b2c:	e037883a 	mov	sp,fp
 3229b30:	df000017 	ldw	fp,0(sp)
 3229b34:	dec00104 	addi	sp,sp,4
 3229b38:	f800283a 	ret

03229b3c <dhc_set_state>:
 *
 * RETURNS: 
 */

void dhc_set_state(int iface, int state)
{
 3229b3c:	defffc04 	addi	sp,sp,-16
 3229b40:	dfc00315 	stw	ra,12(sp)
 3229b44:	df000215 	stw	fp,8(sp)
 3229b48:	df000204 	addi	fp,sp,8
 3229b4c:	e13ffe15 	stw	r4,-8(fp)
 3229b50:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].state = state; /* Set the new state */
 3229b54:	e0bffe17 	ldw	r2,-8(fp)
 3229b58:	e13fff17 	ldw	r4,-4(fp)
 3229b5c:	00c0c9b4 	movhi	r3,806
 3229b60:	18f28004 	addi	r3,r3,-13824
 3229b64:	10800f24 	muli	r2,r2,60
 3229b68:	10c5883a 	add	r2,r2,r3
 3229b6c:	11000015 	stw	r4,0(r2)
   dhc_states[iface].tries = 0;     /* Reset the number of tries */
 3229b70:	e0bffe17 	ldw	r2,-8(fp)
 3229b74:	00c0c9b4 	movhi	r3,806
 3229b78:	18f28004 	addi	r3,r3,-13824
 3229b7c:	10800f24 	muli	r2,r2,60
 3229b80:	10c5883a 	add	r2,r2,r3
 3229b84:	10800104 	addi	r2,r2,4
 3229b88:	10000015 	stw	zero,0(r2)

   /* If callback is set, call it */
   if (dhc_states[iface].callback)
 3229b8c:	e0bffe17 	ldw	r2,-8(fp)
 3229b90:	00c0c9b4 	movhi	r3,806
 3229b94:	18f28004 	addi	r3,r3,-13824
 3229b98:	10800f24 	muli	r2,r2,60
 3229b9c:	10c5883a 	add	r2,r2,r3
 3229ba0:	10800e04 	addi	r2,r2,56
 3229ba4:	10800017 	ldw	r2,0(r2)
 3229ba8:	1005003a 	cmpeq	r2,r2,zero
 3229bac:	10000a1e 	bne	r2,zero,3229bd8 <dhc_set_state+0x9c>
      dhc_states[iface].callback(iface,state);
 3229bb0:	e0bffe17 	ldw	r2,-8(fp)
 3229bb4:	00c0c9b4 	movhi	r3,806
 3229bb8:	18f28004 	addi	r3,r3,-13824
 3229bbc:	10800f24 	muli	r2,r2,60
 3229bc0:	10c5883a 	add	r2,r2,r3
 3229bc4:	10800e04 	addi	r2,r2,56
 3229bc8:	10800017 	ldw	r2,0(r2)
 3229bcc:	e13ffe17 	ldw	r4,-8(fp)
 3229bd0:	e17fff17 	ldw	r5,-4(fp)
 3229bd4:	103ee83a 	callr	r2
}
 3229bd8:	e037883a 	mov	sp,fp
 3229bdc:	dfc00117 	ldw	ra,4(sp)
 3229be0:	df000017 	ldw	fp,0(sp)
 3229be4:	dec00204 	addi	sp,sp,8
 3229be8:	f800283a 	ret

03229bec <find_opt>:
 * RETURNS:  Return pointer to that code if found, NULL if not found.
 */

u_char * 
find_opt(u_char opcode, u_char * opts)
{
 3229bec:	defffb04 	addi	sp,sp,-20
 3229bf0:	df000415 	stw	fp,16(sp)
 3229bf4:	df000404 	addi	fp,sp,16
 3229bf8:	e17ffe15 	stw	r5,-8(fp)
 3229bfc:	e13ffd05 	stb	r4,-12(fp)
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */
 3229c00:	e0bffe17 	ldw	r2,-8(fp)
 3229c04:	10804e04 	addi	r2,r2,312
 3229c08:	e0bffc15 	stw	r2,-16(fp)

   while (opts < end)
 3229c0c:	00002106 	br	3229c94 <find_opt+0xa8>
   {
      if (*opts == opcode) /* found it */
 3229c10:	e0bffe17 	ldw	r2,-8(fp)
 3229c14:	10800003 	ldbu	r2,0(r2)
 3229c18:	10c03fcc 	andi	r3,r2,255
 3229c1c:	e0bffd03 	ldbu	r2,-12(fp)
 3229c20:	1880031e 	bne	r3,r2,3229c30 <find_opt+0x44>
         return opts;
 3229c24:	e0bffe17 	ldw	r2,-8(fp)
 3229c28:	e0bfff15 	stw	r2,-4(fp)
 3229c2c:	00001d06 	br	3229ca4 <find_opt+0xb8>
      if (*opts == DHOP_END)  /* end of options; opcode not found */
 3229c30:	e0bffe17 	ldw	r2,-8(fp)
 3229c34:	10800003 	ldbu	r2,0(r2)
 3229c38:	10803fcc 	andi	r2,r2,255
 3229c3c:	10803fd8 	cmpnei	r2,r2,255
 3229c40:	1000021e 	bne	r2,zero,3229c4c <find_opt+0x60>
         return NULL;
 3229c44:	e03fff15 	stw	zero,-4(fp)
 3229c48:	00001606 	br	3229ca4 <find_opt+0xb8>
      if (*opts == DHOP_PAD)  /* PAD has only 1 byte */
 3229c4c:	e0bffe17 	ldw	r2,-8(fp)
 3229c50:	10800003 	ldbu	r2,0(r2)
 3229c54:	10803fcc 	andi	r2,r2,255
 3229c58:	1004c03a 	cmpne	r2,r2,zero
 3229c5c:	1000041e 	bne	r2,zero,3229c70 <find_opt+0x84>
         opts++;
 3229c60:	e0bffe17 	ldw	r2,-8(fp)
 3229c64:	10800044 	addi	r2,r2,1
 3229c68:	e0bffe15 	stw	r2,-8(fp)
 3229c6c:	00000906 	br	3229c94 <find_opt+0xa8>
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
 3229c70:	e0bffe17 	ldw	r2,-8(fp)
 3229c74:	10800044 	addi	r2,r2,1
 3229c78:	10800003 	ldbu	r2,0(r2)
 3229c7c:	10803fcc 	andi	r2,r2,255
 3229c80:	1007883a 	mov	r3,r2
 3229c84:	e0bffe17 	ldw	r2,-8(fp)
 3229c88:	1885883a 	add	r2,r3,r2
 3229c8c:	10800084 	addi	r2,r2,2
 3229c90:	e0bffe15 	stw	r2,-8(fp)
u_char * 
find_opt(u_char opcode, u_char * opts)
{
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */

   while (opts < end)
 3229c94:	e0fffe17 	ldw	r3,-8(fp)
 3229c98:	e0bffc17 	ldw	r2,-16(fp)
 3229c9c:	18bfdc36 	bltu	r3,r2,3229c10 <find_opt+0x24>
         opts++;
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
   }
   /* no DHOP_END option?? */
   return NULL;
 3229ca0:	e03fff15 	stw	zero,-4(fp)
 3229ca4:	e0bfff17 	ldw	r2,-4(fp)
}
 3229ca8:	e037883a 	mov	sp,fp
 3229cac:	df000017 	ldw	fp,0(sp)
 3229cb0:	dec00104 	addi	sp,sp,4
 3229cb4:	f800283a 	ret

03229cb8 <pk_init>:
 * for a PACKET buffer or a data buffer fails, or if there is an inconsistency
 * between (bigbufs + lilbufs) and MAXPACKETS) it returns -1. 
 */

int pk_init (void)
{
 3229cb8:	defff704 	addi	sp,sp,-36
 3229cbc:	dfc00815 	stw	ra,32(sp)
 3229cc0:	df000715 	stw	fp,28(sp)
 3229cc4:	df000704 	addi	fp,sp,28
   PACKET packet;
   unsigned i;
   unsigned numpkts = bigbufs + lilbufs;
 3229cc8:	d0a03417 	ldw	r2,-32560(gp)
 3229ccc:	d0e03217 	ldw	r3,-32568(gp)
 3229cd0:	10c5883a 	add	r2,r2,r3
 3229cd4:	e0bffc15 	stw	r2,-16(fp)
   u_char align_req;
   
#ifdef ALIGN_BUFS
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
 3229cd8:	e03ffb05 	stb	zero,-20(fp)
#endif

   for (i = 0; i < numpkts; i++)
 3229cdc:	e03ffd15 	stw	zero,-12(fp)
 3229ce0:	00007e06 	br	3229edc <pk_init+0x224>
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
 3229ce4:	01000d04 	movi	r4,52
 3229ce8:	322b5d00 	call	322b5d0 <npalloc>
 3229cec:	e0bffe15 	stw	r2,-8(fp)
      if (packet == NULL)
 3229cf0:	e0bffe17 	ldw	r2,-8(fp)
 3229cf4:	1005003a 	cmpeq	r2,r2,zero
 3229cf8:	1000871e 	bne	r2,zero,3229f18 <pk_init+0x260>
         goto no_pkt_buf;

#ifdef NPDEBUG
      if (i >= MAXPACKETS)
 3229cfc:	e0bffd17 	ldw	r2,-12(fp)
 3229d00:	10800f30 	cmpltui	r2,r2,60
 3229d04:	1000061e 	bne	r2,zero,3229d20 <pk_init+0x68>
      {
         dprintf("pk_init: bad define\n");
 3229d08:	0100c974 	movhi	r4,805
 3229d0c:	213beb04 	addi	r4,r4,-4180
 3229d10:	3206e040 	call	3206e04 <puts>
         return -1;
 3229d14:	00bfffc4 	movi	r2,-1
 3229d18:	e0bfff15 	stw	r2,-4(fp)
 3229d1c:	00008406 	br	3229f30 <pk_init+0x278>
      }
      pktlog[i] = packet;     /* save for debugging */
 3229d20:	e0bffd17 	ldw	r2,-12(fp)
 3229d24:	00c0c9b4 	movhi	r3,806
 3229d28:	18f2c504 	addi	r3,r3,-13548
 3229d2c:	1085883a 	add	r2,r2,r2
 3229d30:	1085883a 	add	r2,r2,r2
 3229d34:	10c7883a 	add	r3,r2,r3
 3229d38:	e0bffe17 	ldw	r2,-8(fp)
 3229d3c:	18800015 	stw	r2,0(r3)
#endif

      packet->nb_tstamp = 0L;
 3229d40:	e0bffe17 	ldw	r2,-8(fp)
 3229d44:	10000515 	stw	zero,20(r2)

      if (i < bigbufs)
 3229d48:	d0e03417 	ldw	r3,-32560(gp)
 3229d4c:	e0bffd17 	ldw	r2,-12(fp)
 3229d50:	10c0302e 	bgeu	r2,r3,3229e14 <pk_init+0x15c>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
 3229d54:	d0a03517 	ldw	r2,-32556(gp)
 3229d58:	11000144 	addi	r4,r2,5
 3229d5c:	322b77c0 	call	322b77c <ncpalloc>
 3229d60:	1007883a 	mov	r3,r2
 3229d64:	e0bffe17 	ldw	r2,-8(fp)
 3229d68:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 3229d6c:	e0bffe17 	ldw	r2,-8(fp)
 3229d70:	10800117 	ldw	r2,4(r2)
 3229d74:	1005003a 	cmpeq	r2,r2,zero
 3229d78:	1000671e 	bne	r2,zero,3229f18 <pk_init+0x260>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 3229d7c:	e03ffa15 	stw	zero,-24(fp)
 3229d80:	00000906 	br	3229da8 <pk_init+0xf0>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 3229d84:	e0bffe17 	ldw	r2,-8(fp)
 3229d88:	10c00117 	ldw	r3,4(r2)
 3229d8c:	e0bffa17 	ldw	r2,-24(fp)
 3229d90:	1887883a 	add	r3,r3,r2
 3229d94:	00801344 	movi	r2,77
 3229d98:	18800005 	stb	r2,0(r3)
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 3229d9c:	e0bffa17 	ldw	r2,-24(fp)
 3229da0:	10800044 	addi	r2,r2,1
 3229da4:	e0bffa15 	stw	r2,-24(fp)
 3229da8:	e0bffa17 	ldw	r2,-24(fp)
 3229dac:	10800110 	cmplti	r2,r2,4
 3229db0:	103ff41e 	bne	r2,zero,3229d84 <pk_init+0xcc>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + bigbufsiz + ALIGN_TYPE) = 'M';
 3229db4:	e0bffe17 	ldw	r2,-8(fp)
 3229db8:	10c00117 	ldw	r3,4(r2)
 3229dbc:	d0a03517 	ldw	r2,-32556(gp)
 3229dc0:	1885883a 	add	r2,r3,r2
 3229dc4:	10c00104 	addi	r3,r2,4
 3229dc8:	00801344 	movi	r2,77
 3229dcc:	18800005 	stb	r2,0(r3)
            packet->nb_buff += ALIGN_TYPE;   /* bump buf past MMs */
 3229dd0:	e0bffe17 	ldw	r2,-8(fp)
 3229dd4:	10800117 	ldw	r2,4(r2)
 3229dd8:	10c00104 	addi	r3,r2,4
 3229ddc:	e0bffe17 	ldw	r2,-8(fp)
 3229de0:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 3229de4:	e0bffe17 	ldw	r2,-8(fp)
 3229de8:	10800117 	ldw	r2,4(r2)
 3229dec:	1005003a 	cmpeq	r2,r2,zero
 3229df0:	1000491e 	bne	r2,zero,3229f18 <pk_init+0x260>
            goto no_pkt_buf;
         packet->nb_blen = bigbufsiz;
 3229df4:	d0e03517 	ldw	r3,-32556(gp)
 3229df8:	e0bffe17 	ldw	r2,-8(fp)
 3229dfc:	10c00215 	stw	r3,8(r2)
         q_add(&bigfreeq, packet);        /* save it in big pkt free queue */
 3229e00:	0100c9b4 	movhi	r4,806
 3229e04:	21330104 	addi	r4,r4,-13308
 3229e08:	e17ffe17 	ldw	r5,-8(fp)
 3229e0c:	322a51c0 	call	322a51c <putq>
 3229e10:	00002f06 	br	3229ed0 <pk_init+0x218>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
 3229e14:	d0a03317 	ldw	r2,-32564(gp)
 3229e18:	11000144 	addi	r4,r2,5
 3229e1c:	322b77c0 	call	322b77c <ncpalloc>
 3229e20:	1007883a 	mov	r3,r2
 3229e24:	e0bffe17 	ldw	r2,-8(fp)
 3229e28:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 3229e2c:	e0bffe17 	ldw	r2,-8(fp)
 3229e30:	10800117 	ldw	r2,4(r2)
 3229e34:	1005003a 	cmpeq	r2,r2,zero
 3229e38:	1000371e 	bne	r2,zero,3229f18 <pk_init+0x260>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 3229e3c:	e03ff915 	stw	zero,-28(fp)
 3229e40:	00000906 	br	3229e68 <pk_init+0x1b0>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 3229e44:	e0bffe17 	ldw	r2,-8(fp)
 3229e48:	10c00117 	ldw	r3,4(r2)
 3229e4c:	e0bff917 	ldw	r2,-28(fp)
 3229e50:	1887883a 	add	r3,r3,r2
 3229e54:	00801344 	movi	r2,77
 3229e58:	18800005 	stb	r2,0(r3)
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 3229e5c:	e0bff917 	ldw	r2,-28(fp)
 3229e60:	10800044 	addi	r2,r2,1
 3229e64:	e0bff915 	stw	r2,-28(fp)
 3229e68:	e0bff917 	ldw	r2,-28(fp)
 3229e6c:	10800110 	cmplti	r2,r2,4
 3229e70:	103ff41e 	bne	r2,zero,3229e44 <pk_init+0x18c>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + lilbufsiz + ALIGN_TYPE) = 'M';
 3229e74:	e0bffe17 	ldw	r2,-8(fp)
 3229e78:	10c00117 	ldw	r3,4(r2)
 3229e7c:	d0a03317 	ldw	r2,-32564(gp)
 3229e80:	1885883a 	add	r2,r3,r2
 3229e84:	10c00104 	addi	r3,r2,4
 3229e88:	00801344 	movi	r2,77
 3229e8c:	18800005 	stb	r2,0(r3)
            packet->nb_buff += ALIGN_TYPE;
 3229e90:	e0bffe17 	ldw	r2,-8(fp)
 3229e94:	10800117 	ldw	r2,4(r2)
 3229e98:	10c00104 	addi	r3,r2,4
 3229e9c:	e0bffe17 	ldw	r2,-8(fp)
 3229ea0:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 3229ea4:	e0bffe17 	ldw	r2,-8(fp)
 3229ea8:	10800117 	ldw	r2,4(r2)
 3229eac:	1005003a 	cmpeq	r2,r2,zero
 3229eb0:	1000191e 	bne	r2,zero,3229f18 <pk_init+0x260>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
 3229eb4:	d0e03317 	ldw	r3,-32564(gp)
 3229eb8:	e0bffe17 	ldw	r2,-8(fp)
 3229ebc:	10c00215 	stw	r3,8(r2)
         q_add(&lilfreeq, packet);        /* save it in little free queue */
 3229ec0:	0100c9b4 	movhi	r4,806
 3229ec4:	2132bc04 	addi	r4,r4,-13584
 3229ec8:	e17ffe17 	ldw	r5,-8(fp)
 3229ecc:	322a51c0 	call	322a51c <putq>
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
#endif

   for (i = 0; i < numpkts; i++)
 3229ed0:	e0bffd17 	ldw	r2,-12(fp)
 3229ed4:	10800044 	addi	r2,r2,1
 3229ed8:	e0bffd15 	stw	r2,-12(fp)
 3229edc:	e0fffd17 	ldw	r3,-12(fp)
 3229ee0:	e0bffc17 	ldw	r2,-16(fp)
 3229ee4:	18bf7f36 	bltu	r3,r2,3229ce4 <pk_init+0x2c>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
         q_add(&lilfreeq, packet);        /* save it in little free queue */
      }
   }
   bigfreeq.q_min = bigbufs;
 3229ee8:	d0a03417 	ldw	r2,-32560(gp)
 3229eec:	1007883a 	mov	r3,r2
 3229ef0:	0080c9b4 	movhi	r2,806
 3229ef4:	10b30104 	addi	r2,r2,-13308
 3229ef8:	10c00415 	stw	r3,16(r2)
   lilfreeq.q_min = lilbufs;
 3229efc:	d0a03217 	ldw	r2,-32568(gp)
 3229f00:	1007883a 	mov	r3,r2
 3229f04:	0080c9b4 	movhi	r2,806
 3229f08:	10b2bc04 	addi	r2,r2,-13584
 3229f0c:	10c00415 	stw	r3,16(r2)
   heap_curr_mem_hi_watermark = 0;
   /* set the heap's access type to blocking */
   heap_type = HEAP_ACCESS_BLOCKING;
#endif

   return 0;
 3229f10:	e03fff15 	stw	zero,-4(fp)
 3229f14:	00000606 	br	3229f30 <pk_init+0x278>

no_pkt_buf:
#ifdef NPDEBUG
   dprintf("Netinit: calloc failed getting buffer %d\n", i);
 3229f18:	0100c974 	movhi	r4,805
 3229f1c:	213bf004 	addi	r4,r4,-4160
 3229f20:	e17ffd17 	ldw	r5,-12(fp)
 3229f24:	3206adc0 	call	3206adc <printf>
#endif
   return(-1);
 3229f28:	00bfffc4 	movi	r2,-1
 3229f2c:	e0bfff15 	stw	r2,-4(fp)
 3229f30:	e0bfff17 	ldw	r2,-4(fp)
}
 3229f34:	e037883a 	mov	sp,fp
 3229f38:	dfc00117 	ldw	ra,4(sp)
 3229f3c:	df000017 	ldw	fp,0(sp)
 3229f40:	dec00204 	addi	sp,sp,8
 3229f44:	f800283a 	ret

03229f48 <pk_alloc>:
 * OUTPUT: 0 if the request cannot be satisfied, or a pointer to the struct
 * netbuf structure that corresponds to the just allocated data buffer.
 */

PACKET pk_alloc(unsigned len)
{
 3229f48:	defffb04 	addi	sp,sp,-20
 3229f4c:	dfc00415 	stw	ra,16(sp)
 3229f50:	df000315 	stw	fp,12(sp)
 3229f54:	df000304 	addi	fp,sp,12
 3229f58:	e13ffe15 	stw	r4,-8(fp)
   PACKET p;

   if (len > bigbufsiz) /* caller wants oversize buffer? */
 3229f5c:	d0e03517 	ldw	r3,-32556(gp)
 3229f60:	e0bffe17 	ldw	r2,-8(fp)
 3229f64:	1880022e 	bgeu	r3,r2,3229f70 <pk_alloc+0x28>
   {
#ifdef HEAPBUFS
      if ((p = pk_alloc_heapbuf (len)) == NULL)
         return NULL;
#else
      return(NULL);
 3229f68:	e03fff15 	stw	zero,-4(fp)
 3229f6c:	00002706 	br	322a00c <pk_alloc+0xc4>
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 3229f70:	d0e03317 	ldw	r3,-32564(gp)
 3229f74:	e0bffe17 	ldw	r2,-8(fp)
 3229f78:	18800536 	bltu	r3,r2,3229f90 <pk_alloc+0x48>
 3229f7c:	0080c9b4 	movhi	r2,806
 3229f80:	10b2bc04 	addi	r2,r2,-13584
 3229f84:	10800217 	ldw	r2,8(r2)
 3229f88:	1004c03a 	cmpne	r2,r2,zero
 3229f8c:	1000051e 	bne	r2,zero,3229fa4 <pk_alloc+0x5c>
         p = (PACKET)getq(&bigfreeq);
 3229f90:	0100c9b4 	movhi	r4,806
 3229f94:	21330104 	addi	r4,r4,-13308
 3229f98:	322a4540 	call	322a454 <getq>
 3229f9c:	e0bffd15 	stw	r2,-12(fp)
      return(NULL);
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 3229fa0:	00000406 	br	3229fb4 <pk_alloc+0x6c>
         p = (PACKET)getq(&bigfreeq);
      else
         p = (PACKET)getq(&lilfreeq);
 3229fa4:	0100c9b4 	movhi	r4,806
 3229fa8:	2132bc04 	addi	r4,r4,-13584
 3229fac:	322a4540 	call	322a454 <getq>
 3229fb0:	e0bffd15 	stw	r2,-12(fp)

      if (!p)
 3229fb4:	e0bffd17 	ldw	r2,-12(fp)
 3229fb8:	1004c03a 	cmpne	r2,r2,zero
 3229fbc:	1000021e 	bne	r2,zero,3229fc8 <pk_alloc+0x80>
         return NULL;
 3229fc0:	e03fff15 	stw	zero,-4(fp)
 3229fc4:	00001106 	br	322a00c <pk_alloc+0xc4>
   }

   p->nb_prot = p->nb_buff + MaxLnh;   /* point past biggest mac header */
 3229fc8:	e0bffd17 	ldw	r2,-12(fp)
 3229fcc:	10c00117 	ldw	r3,4(r2)
 3229fd0:	0080c974 	movhi	r2,805
 3229fd4:	10922f04 	addi	r2,r2,18620
 3229fd8:	10800017 	ldw	r2,0(r2)
 3229fdc:	1887883a 	add	r3,r3,r2
 3229fe0:	e0bffd17 	ldw	r2,-12(fp)
 3229fe4:	10c00315 	stw	r3,12(r2)
   p->nb_plen = 0;   /* no protocol data there yet */
 3229fe8:	e0bffd17 	ldw	r2,-12(fp)
 3229fec:	10000415 	stw	zero,16(r2)
   p->net = NULL;
 3229ff0:	e0bffd17 	ldw	r2,-12(fp)
 3229ff4:	10000615 	stw	zero,24(r2)
   p->nexthop = NULL;      /* no next hop  */
   p->nb_pmtu = 1240;      /* Set minimum IPv6 Path MTU */
#endif   /* IP_V6 */
#endif /* LINKED_PKTS */

   p->inuse = 1;  /* initially buffer in use by 1 user */
 3229ff8:	e0fffd17 	ldw	r3,-12(fp)
 3229ffc:	00800044 	movi	r2,1
 322a000:	18800915 	stw	r2,36(r3)

   /* note that 'type' and 'fhost' fields are not set in pk_alloc () */
   return(p);
 322a004:	e0bffd17 	ldw	r2,-12(fp)
 322a008:	e0bfff15 	stw	r2,-4(fp)
 322a00c:	e0bfff17 	ldw	r2,-4(fp)
}
 322a010:	e037883a 	mov	sp,fp
 322a014:	dfc00117 	ldw	ra,4(sp)
 322a018:	df000017 	ldw	fp,0(sp)
 322a01c:	dec00204 	addi	sp,sp,8
 322a020:	f800283a 	ret

0322a024 <pk_validate>:
 * OUTPUT: 0 if the buffer being freed was successfully validated, or
 * -1 if the validation failed.
 */

int pk_validate(PACKET pkt)   /* check if pk_free() can free the pkt */
{
 322a024:	defffa04 	addi	sp,sp,-24
 322a028:	dfc00515 	stw	ra,20(sp)
 322a02c:	df000415 	stw	fp,16(sp)
 322a030:	df000404 	addi	fp,sp,16
 322a034:	e13ffe15 	stw	r4,-8(fp)
   /* If packet link is non-zero, then this packet is
    * part of a chain and deleted this packet would break
    * the chain and cause memory leak for subsequent pkts.
    * Note that heapbufs do not use the 'next' field at all.
    */
   if ((pkt->next) && (pkt->inuse >= 1))
 322a038:	e0bffe17 	ldw	r2,-8(fp)
 322a03c:	10800017 	ldw	r2,0(r2)
 322a040:	1005003a 	cmpeq	r2,r2,zero
 322a044:	1000101e 	bne	r2,zero,322a088 <pk_validate+0x64>
 322a048:	e0bffe17 	ldw	r2,-8(fp)
 322a04c:	10800917 	ldw	r2,36(r2)
 322a050:	1005003a 	cmpeq	r2,r2,zero
 322a054:	10000c1e 	bne	r2,zero,322a088 <pk_validate+0x64>
   {
      INCR_SHARED_VAR (memestats, INCONSISTENT_LOCATION_ERR, 1);   
 322a058:	322ad8c0 	call	322ad8c <irq_Mask>
 322a05c:	0080c9b4 	movhi	r2,806
 322a060:	10b2c104 	addi	r2,r2,-13564
 322a064:	10800317 	ldw	r2,12(r2)
 322a068:	10c00044 	addi	r3,r2,1
 322a06c:	0080c9b4 	movhi	r2,806
 322a070:	10b2c104 	addi	r2,r2,-13564
 322a074:	10c00315 	stw	r3,12(r2)
 322a078:	322ade80 	call	322ade8 <irq_Unmask>
      return -1;
 322a07c:	00bfffc4 	movi	r2,-1
 322a080:	e0bfff15 	stw	r2,-4(fp)
 322a084:	00008f06 	br	322a2c4 <pk_validate+0x2a0>
   }
   else  
#endif /* HEAPBUFS */
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
 322a088:	e0bffe17 	ldw	r2,-8(fp)
 322a08c:	10c00217 	ldw	r3,8(r2)
 322a090:	d0a03517 	ldw	r2,-32556(gp)
 322a094:	1880221e 	bne	r3,r2,322a120 <pk_validate+0xfc>
      {
         ENTER_CRIT_SECTION(&bigfreeq);
 322a098:	322ad8c0 	call	322ad8c <irq_Mask>
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 322a09c:	0080c9b4 	movhi	r2,806
 322a0a0:	10b30104 	addi	r2,r2,-13308
 322a0a4:	10800017 	ldw	r2,0(r2)
 322a0a8:	e0bffd15 	stw	r2,-12(fp)
 322a0ac:	00001706 	br	322a10c <pk_validate+0xe8>
            if (p == pkt)
 322a0b0:	e0fffd17 	ldw	r3,-12(fp)
 322a0b4:	e0bffe17 	ldw	r2,-8(fp)
 322a0b8:	1880111e 	bne	r3,r2,322a100 <pk_validate+0xdc>
            {
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
 322a0bc:	0100c974 	movhi	r4,805
 322a0c0:	213bfb04 	addi	r4,r4,-4116
 322a0c4:	e17ffe17 	ldw	r5,-8(fp)
 322a0c8:	3206adc0 	call	3206adc <printf>
               EXIT_CRIT_SECTION(&bigfreeq);
 322a0cc:	322ade80 	call	322ade8 <irq_Unmask>
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 322a0d0:	322ad8c0 	call	322ad8c <irq_Mask>
 322a0d4:	0080c9b4 	movhi	r2,806
 322a0d8:	10b2c104 	addi	r2,r2,-13564
 322a0dc:	10800217 	ldw	r2,8(r2)
 322a0e0:	10c00044 	addi	r3,r2,1
 322a0e4:	0080c9b4 	movhi	r2,806
 322a0e8:	10b2c104 	addi	r2,r2,-13564
 322a0ec:	10c00215 	stw	r3,8(r2)
 322a0f0:	322ade80 	call	322ade8 <irq_Unmask>
               return -1;
 322a0f4:	00bfffc4 	movi	r2,-1
 322a0f8:	e0bfff15 	stw	r2,-4(fp)
 322a0fc:	00007106 	br	322a2c4 <pk_validate+0x2a0>
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
      {
         ENTER_CRIT_SECTION(&bigfreeq);
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 322a100:	e0bffd17 	ldw	r2,-12(fp)
 322a104:	10800017 	ldw	r2,0(r2)
 322a108:	e0bffd15 	stw	r2,-12(fp)
 322a10c:	e0bffd17 	ldw	r2,-12(fp)
 322a110:	1004c03a 	cmpne	r2,r2,zero
 322a114:	103fe61e 	bne	r2,zero,322a0b0 <pk_validate+0x8c>
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
               EXIT_CRIT_SECTION(&bigfreeq);
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
               return -1;
            }
         EXIT_CRIT_SECTION(&bigfreeq);
 322a118:	322ade80 	call	322ade8 <irq_Unmask>
 322a11c:	00003206 	br	322a1e8 <pk_validate+0x1c4>
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
 322a120:	e0bffe17 	ldw	r2,-8(fp)
 322a124:	10c00217 	ldw	r3,8(r2)
 322a128:	d0a03317 	ldw	r2,-32564(gp)
 322a12c:	1880221e 	bne	r3,r2,322a1b8 <pk_validate+0x194>
      {
         ENTER_CRIT_SECTION(&lilfreeq);
 322a130:	322ad8c0 	call	322ad8c <irq_Mask>
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 322a134:	0080c9b4 	movhi	r2,806
 322a138:	10b2bc04 	addi	r2,r2,-13584
 322a13c:	10800017 	ldw	r2,0(r2)
 322a140:	e0bffd15 	stw	r2,-12(fp)
 322a144:	00001706 	br	322a1a4 <pk_validate+0x180>
            if (p == pkt)
 322a148:	e0fffd17 	ldw	r3,-12(fp)
 322a14c:	e0bffe17 	ldw	r2,-8(fp)
 322a150:	1880111e 	bne	r3,r2,322a198 <pk_validate+0x174>
         {
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
 322a154:	0100c974 	movhi	r4,805
 322a158:	213c0504 	addi	r4,r4,-4076
 322a15c:	e17ffe17 	ldw	r5,-8(fp)
 322a160:	3206adc0 	call	3206adc <printf>
            EXIT_CRIT_SECTION(&lilfreeq);
 322a164:	322ade80 	call	322ade8 <irq_Unmask>
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 322a168:	322ad8c0 	call	322ad8c <irq_Mask>
 322a16c:	0080c9b4 	movhi	r2,806
 322a170:	10b2c104 	addi	r2,r2,-13564
 322a174:	10800217 	ldw	r2,8(r2)
 322a178:	10c00044 	addi	r3,r2,1
 322a17c:	0080c9b4 	movhi	r2,806
 322a180:	10b2c104 	addi	r2,r2,-13564
 322a184:	10c00215 	stw	r3,8(r2)
 322a188:	322ade80 	call	322ade8 <irq_Unmask>
            return -1;
 322a18c:	00bfffc4 	movi	r2,-1
 322a190:	e0bfff15 	stw	r2,-4(fp)
 322a194:	00004b06 	br	322a2c4 <pk_validate+0x2a0>
         EXIT_CRIT_SECTION(&bigfreeq);
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
      {
         ENTER_CRIT_SECTION(&lilfreeq);
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 322a198:	e0bffd17 	ldw	r2,-12(fp)
 322a19c:	10800017 	ldw	r2,0(r2)
 322a1a0:	e0bffd15 	stw	r2,-12(fp)
 322a1a4:	e0bffd17 	ldw	r2,-12(fp)
 322a1a8:	1004c03a 	cmpne	r2,r2,zero
 322a1ac:	103fe61e 	bne	r2,zero,322a148 <pk_validate+0x124>
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
            EXIT_CRIT_SECTION(&lilfreeq);
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
            return -1;
         }
         EXIT_CRIT_SECTION(&lilfreeq);
 322a1b0:	322ade80 	call	322ade8 <irq_Unmask>
 322a1b4:	00000c06 	br	322a1e8 <pk_validate+0x1c4>
      }
      else
      {
         /* log an error */
         INCR_SHARED_VAR (memestats, BAD_REGULAR_BUF_LEN_ERR, 1);
 322a1b8:	322ad8c0 	call	322ad8c <irq_Mask>
 322a1bc:	0080c9b4 	movhi	r2,806
 322a1c0:	10b2c104 	addi	r2,r2,-13564
 322a1c4:	10800017 	ldw	r2,0(r2)
 322a1c8:	10c00044 	addi	r3,r2,1
 322a1cc:	0080c9b4 	movhi	r2,806
 322a1d0:	10b2c104 	addi	r2,r2,-13564
 322a1d4:	10c00015 	stw	r3,0(r2)
 322a1d8:	322ade80 	call	322ade8 <irq_Unmask>
         return -1;
 322a1dc:	00bfffc4 	movi	r2,-1
 322a1e0:	e0bfff15 	stw	r2,-4(fp)
 322a1e4:	00003706 	br	322a2c4 <pk_validate+0x2a0>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 322a1e8:	00800104 	movi	r2,4
 322a1ec:	e0bffc15 	stw	r2,-16(fp)
 322a1f0:	00001906 	br	322a258 <pk_validate+0x234>
   {
      if (*(pkt->nb_buff - j) != 'M')
 322a1f4:	e0bffe17 	ldw	r2,-8(fp)
 322a1f8:	10c00117 	ldw	r3,4(r2)
 322a1fc:	e0bffc17 	ldw	r2,-16(fp)
 322a200:	1885c83a 	sub	r2,r3,r2
 322a204:	10800003 	ldbu	r2,0(r2)
 322a208:	10803fcc 	andi	r2,r2,255
 322a20c:	1080201c 	xori	r2,r2,128
 322a210:	10bfe004 	addi	r2,r2,-128
 322a214:	10801360 	cmpeqi	r2,r2,77
 322a218:	10000c1e 	bne	r2,zero,322a24c <pk_validate+0x228>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 322a21c:	322ad8c0 	call	322ad8c <irq_Mask>
 322a220:	0080c9b4 	movhi	r2,806
 322a224:	10b2c104 	addi	r2,r2,-13564
 322a228:	10800117 	ldw	r2,4(r2)
 322a22c:	10c00044 	addi	r3,r2,1
 322a230:	0080c9b4 	movhi	r2,806
 322a234:	10b2c104 	addi	r2,r2,-13564
 322a238:	10c00115 	stw	r3,4(r2)
 322a23c:	322ade80 	call	322ade8 <irq_Unmask>
         return -1;
 322a240:	00bfffc4 	movi	r2,-1
 322a244:	e0bfff15 	stw	r2,-4(fp)
 322a248:	00001e06 	br	322a2c4 <pk_validate+0x2a0>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 322a24c:	e0bffc17 	ldw	r2,-16(fp)
 322a250:	10bfffc4 	addi	r2,r2,-1
 322a254:	e0bffc15 	stw	r2,-16(fp)
 322a258:	e0bffc17 	ldw	r2,-16(fp)
 322a25c:	10800048 	cmpgei	r2,r2,1
 322a260:	103fe41e 	bne	r2,zero,322a1f4 <pk_validate+0x1d0>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
         return -1;
      }
   }
   if (*(pkt->nb_buff + pkt->nb_blen) != 'M')
 322a264:	e0bffe17 	ldw	r2,-8(fp)
 322a268:	10c00117 	ldw	r3,4(r2)
 322a26c:	e0bffe17 	ldw	r2,-8(fp)
 322a270:	10800217 	ldw	r2,8(r2)
 322a274:	1885883a 	add	r2,r3,r2
 322a278:	10800003 	ldbu	r2,0(r2)
 322a27c:	10803fcc 	andi	r2,r2,255
 322a280:	1080201c 	xori	r2,r2,128
 322a284:	10bfe004 	addi	r2,r2,-128
 322a288:	10801360 	cmpeqi	r2,r2,77
 322a28c:	10000c1e 	bne	r2,zero,322a2c0 <pk_validate+0x29c>
   {
      INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 322a290:	322ad8c0 	call	322ad8c <irq_Mask>
 322a294:	0080c9b4 	movhi	r2,806
 322a298:	10b2c104 	addi	r2,r2,-13564
 322a29c:	10800117 	ldw	r2,4(r2)
 322a2a0:	10c00044 	addi	r3,r2,1
 322a2a4:	0080c9b4 	movhi	r2,806
 322a2a8:	10b2c104 	addi	r2,r2,-13564
 322a2ac:	10c00115 	stw	r3,4(r2)
 322a2b0:	322ade80 	call	322ade8 <irq_Unmask>
      return -1;
 322a2b4:	00bfffc4 	movi	r2,-1
 322a2b8:	e0bfff15 	stw	r2,-4(fp)
 322a2bc:	00000106 	br	322a2c4 <pk_validate+0x2a0>
   }
#endif /* NPDEBUG */

   return 0;
 322a2c0:	e03fff15 	stw	zero,-4(fp)
 322a2c4:	e0bfff17 	ldw	r2,-4(fp)
}
 322a2c8:	e037883a 	mov	sp,fp
 322a2cc:	dfc00117 	ldw	ra,4(sp)
 322a2d0:	df000017 	ldw	fp,0(sp)
 322a2d4:	dec00204 	addi	sp,sp,8
 322a2d8:	f800283a 	ret

0322a2dc <pk_free>:
 *
 * OUTPUT: None.
 */

void pk_free(PACKET pkt)   /* PACKET to place in free queue */
{
 322a2dc:	defffc04 	addi	sp,sp,-16
 322a2e0:	dfc00315 	stw	ra,12(sp)
 322a2e4:	df000215 	stw	fp,8(sp)
 322a2e8:	df000204 	addi	fp,sp,8
 322a2ec:	e13fff15 	stw	r4,-4(fp)
      PACKET pknext;
      pknext = pkt->pk_next;
#endif /* LINKED_PKTS */

      /* validate the pkt before freeing */
      e = pk_validate(pkt);
 322a2f0:	e13fff17 	ldw	r4,-4(fp)
 322a2f4:	322a0240 	call	322a024 <pk_validate>
 322a2f8:	e0bffe15 	stw	r2,-8(fp)
      if (e)
 322a2fc:	e0bffe17 	ldw	r2,-8(fp)
 322a300:	1004c03a 	cmpne	r2,r2,zero
 322a304:	10001b1e 	bne	r2,zero,322a374 <pk_free+0x98>
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
 322a308:	e0bfff17 	ldw	r2,-4(fp)
 322a30c:	10c00917 	ldw	r3,36(r2)
 322a310:	188000a8 	cmpgeui	r2,r3,2
 322a314:	1009883a 	mov	r4,r2
 322a318:	18ffffc4 	addi	r3,r3,-1
 322a31c:	e0bfff17 	ldw	r2,-4(fp)
 322a320:	10c00915 	stw	r3,36(r2)
 322a324:	20803fcc 	andi	r2,r4,255
 322a328:	1004c03a 	cmpne	r2,r2,zero
 322a32c:	1000111e 	bne	r2,zero,322a374 <pk_free+0x98>
         pk_free_heapbuf (pkt);
      }
      else 
#endif /* HEAPBUFS */
      {
         if (pkt->nb_blen == bigbufsiz)
 322a330:	e0bfff17 	ldw	r2,-4(fp)
 322a334:	10c00217 	ldw	r3,8(r2)
 322a338:	d0a03517 	ldw	r2,-32556(gp)
 322a33c:	1880051e 	bne	r3,r2,322a354 <pk_free+0x78>
            q_add(&bigfreeq, (qp)pkt);
 322a340:	e17fff17 	ldw	r5,-4(fp)
 322a344:	0100c9b4 	movhi	r4,806
 322a348:	21330104 	addi	r4,r4,-13308
 322a34c:	322a51c0 	call	322a51c <putq>
 322a350:	00000806 	br	322a374 <pk_free+0x98>
         else if (pkt->nb_blen == lilbufsiz)
 322a354:	e0bfff17 	ldw	r2,-4(fp)
 322a358:	10c00217 	ldw	r3,8(r2)
 322a35c:	d0a03317 	ldw	r2,-32564(gp)
 322a360:	1880041e 	bne	r3,r2,322a374 <pk_free+0x98>
            q_add(&lilfreeq, (qp)pkt);
 322a364:	e17fff17 	ldw	r5,-4(fp)
 322a368:	0100c9b4 	movhi	r4,806
 322a36c:	2132bc04 	addi	r4,r4,-13584
 322a370:	322a51c0 	call	322a51c <putq>
#ifdef LINKED_PKTS
      pkt = pknext;
   }
#endif 

}
 322a374:	e037883a 	mov	sp,fp
 322a378:	dfc00117 	ldw	ra,4(sp)
 322a37c:	df000017 	ldw	fp,0(sp)
 322a380:	dec00204 	addi	sp,sp,8
 322a384:	f800283a 	ret

0322a388 <pk_get_max_intrsafe_buf_len>:
 *
 * OUTPUT: This function always returns the length of a big buffer (bigbufsiz).
 */

unsigned pk_get_max_intrsafe_buf_len(void)
{
 322a388:	deffff04 	addi	sp,sp,-4
 322a38c:	df000015 	stw	fp,0(sp)
 322a390:	d839883a 	mov	fp,sp
   return bigbufsiz;
 322a394:	d0a03517 	ldw	r2,-32556(gp)
}
 322a398:	e037883a 	mov	sp,fp
 322a39c:	df000017 	ldw	fp,0(sp)
 322a3a0:	dec00104 	addi	sp,sp,4
 322a3a4:	f800283a 	ret

0322a3a8 <dump_buf_estats>:
 *
 * OUTPUT: This function always returns 0.
 */

int dump_buf_estats (void * pio)
{
 322a3a8:	defff904 	addi	sp,sp,-28
 322a3ac:	dfc00615 	stw	ra,24(sp)
 322a3b0:	df000515 	stw	fp,20(sp)
 322a3b4:	df000504 	addi	fp,sp,20
 322a3b8:	e13fff15 	stw	r4,-4(fp)
   u_long mlocal [MEMERR_NUM_STATS];

   LOCK_NET_RESOURCE(FREEQ_RESID);
 322a3bc:	01000084 	movi	r4,2
 322a3c0:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   ENTER_CRIT_SECTION(&memestats);
 322a3c4:	322ad8c0 	call	322ad8c <irq_Mask>
   MEMCPY (&mlocal, &memestats, sizeof(memestats));
 322a3c8:	00c0c9b4 	movhi	r3,806
 322a3cc:	18f2c104 	addi	r3,r3,-13564
 322a3d0:	18800017 	ldw	r2,0(r3)
 322a3d4:	e0bffb15 	stw	r2,-20(fp)
 322a3d8:	18800117 	ldw	r2,4(r3)
 322a3dc:	e0bffc15 	stw	r2,-16(fp)
 322a3e0:	18800217 	ldw	r2,8(r3)
 322a3e4:	e0bffd15 	stw	r2,-12(fp)
 322a3e8:	18800317 	ldw	r2,12(r3)
 322a3ec:	e0bffe15 	stw	r2,-8(fp)
   EXIT_CRIT_SECTION(&memestats);
 322a3f0:	322ade80 	call	322ade8 <irq_Unmask>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322a3f4:	01000084 	movi	r4,2
 322a3f8:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   ns_printf(pio, "Regular buffer error statistics:\n");
 322a3fc:	e13fff17 	ldw	r4,-4(fp)
 322a400:	0140c974 	movhi	r5,805
 322a404:	297c0f04 	addi	r5,r5,-4036
 322a408:	32260180 	call	3226018 <ns_printf>
   ns_printf(pio, "Bad buffer length %lu, Guard band violations %lu\n",mlocal[BAD_REGULAR_BUF_LEN_ERR],mlocal[GUARD_BAND_VIOLATED_ERR]);
 322a40c:	e1bffb17 	ldw	r6,-20(fp)
 322a410:	e1fffc17 	ldw	r7,-16(fp)
 322a414:	e13fff17 	ldw	r4,-4(fp)
 322a418:	0140c974 	movhi	r5,805
 322a41c:	297c1804 	addi	r5,r5,-4000
 322a420:	32260180 	call	3226018 <ns_printf>
   ns_printf(pio, "Multiple frees %lu, Inconsistent location %lu\n",mlocal[MULTIPLE_FREE_ERR],mlocal[INCONSISTENT_LOCATION_ERR]);
 322a424:	e1bffd17 	ldw	r6,-12(fp)
 322a428:	e1fffe17 	ldw	r7,-8(fp)
 322a42c:	e13fff17 	ldw	r4,-4(fp)
 322a430:	0140c974 	movhi	r5,805
 322a434:	297c2504 	addi	r5,r5,-3948
 322a438:	32260180 	call	3226018 <ns_printf>

   return 0;
 322a43c:	0005883a 	mov	r2,zero
}
 322a440:	e037883a 	mov	sp,fp
 322a444:	dfc00117 	ldw	ra,4(sp)
 322a448:	df000017 	ldw	fp,0(sp)
 322a44c:	dec00204 	addi	sp,sp,8
 322a450:	f800283a 	ret

0322a454 <getq>:
 * RETURNS: pointer to the first element if any, or 0 if the queue is empty.
 */

void*
getq(queue * q)
{
 322a454:	defffb04 	addi	sp,sp,-20
 322a458:	dfc00415 	stw	ra,16(sp)
 322a45c:	df000315 	stw	fp,12(sp)
 322a460:	df000304 	addi	fp,sp,12
 322a464:	e13ffe15 	stw	r4,-8(fp)
   q_elt   temp;        /* temp for result */


   ENTER_CRIT_SECTION(q);     /* shut off ints, save old state */   
 322a468:	322ad8c0 	call	322ad8c <irq_Mask>

   LOCKNET_CHECK(q);          /* make sure queue is protected */

   if ((temp = q->q_head) == 0)  /* queue empty? */
 322a46c:	e0bffe17 	ldw	r2,-8(fp)
 322a470:	10800017 	ldw	r2,0(r2)
 322a474:	e0bffd15 	stw	r2,-12(fp)
 322a478:	e0bffd17 	ldw	r2,-12(fp)
 322a47c:	1004c03a 	cmpne	r2,r2,zero
 322a480:	1000031e 	bne	r2,zero,322a490 <getq+0x3c>
   {
      EXIT_CRIT_SECTION(q);
 322a484:	322ade80 	call	322ade8 <irq_Unmask>
      return (0);             /* yes, show none */
 322a488:	e03fff15 	stw	zero,-4(fp)
 322a48c:	00001d06 	br	322a504 <getq+0xb0>
   }

   q->q_head = temp->qe_next; /* else unlink */
 322a490:	e0bffd17 	ldw	r2,-12(fp)
 322a494:	10c00017 	ldw	r3,0(r2)
 322a498:	e0bffe17 	ldw	r2,-8(fp)
 322a49c:	10c00015 	stw	r3,0(r2)
   temp->qe_next = 0;         /* avoid dangling pointers */
 322a4a0:	e0bffd17 	ldw	r2,-12(fp)
 322a4a4:	10000015 	stw	zero,0(r2)
   if (q->q_head == 0)        /* queue empty? */
 322a4a8:	e0bffe17 	ldw	r2,-8(fp)
 322a4ac:	10800017 	ldw	r2,0(r2)
 322a4b0:	1004c03a 	cmpne	r2,r2,zero
 322a4b4:	1000021e 	bne	r2,zero,322a4c0 <getq+0x6c>
      q->q_tail = 0;          /* yes, update tail pointer too */
 322a4b8:	e0bffe17 	ldw	r2,-8(fp)
 322a4bc:	10000115 	stw	zero,4(r2)
   q->q_len--;                /* update queue length */
 322a4c0:	e0bffe17 	ldw	r2,-8(fp)
 322a4c4:	10800217 	ldw	r2,8(r2)
 322a4c8:	10ffffc4 	addi	r3,r2,-1
 322a4cc:	e0bffe17 	ldw	r2,-8(fp)
 322a4d0:	10c00215 	stw	r3,8(r2)
   if (q->q_len < q->q_min)
 322a4d4:	e0bffe17 	ldw	r2,-8(fp)
 322a4d8:	10c00217 	ldw	r3,8(r2)
 322a4dc:	e0bffe17 	ldw	r2,-8(fp)
 322a4e0:	10800417 	ldw	r2,16(r2)
 322a4e4:	1880040e 	bge	r3,r2,322a4f8 <getq+0xa4>
      q->q_min = q->q_len;
 322a4e8:	e0bffe17 	ldw	r2,-8(fp)
 322a4ec:	10c00217 	ldw	r3,8(r2)
 322a4f0:	e0bffe17 	ldw	r2,-8(fp)
 322a4f4:	10c00415 	stw	r3,16(r2)

   QUEUE_CHECK(q);         /* make sure queue is not corrupted */

   EXIT_CRIT_SECTION(q);   /* restore caller's int state */
 322a4f8:	322ade80 	call	322ade8 <irq_Unmask>

   return ((void*)temp);
 322a4fc:	e0bffd17 	ldw	r2,-12(fp)
 322a500:	e0bfff15 	stw	r2,-4(fp)
 322a504:	e0bfff17 	ldw	r2,-4(fp)
}
 322a508:	e037883a 	mov	sp,fp
 322a50c:	dfc00117 	ldw	ra,4(sp)
 322a510:	df000017 	ldw	fp,0(sp)
 322a514:	dec00204 	addi	sp,sp,8
 322a518:	f800283a 	ret

0322a51c <putq>:

void
putq(
   queue   *   q,       /* the queue */
   void *   elt)        /* element to delete */
{
 322a51c:	defffc04 	addi	sp,sp,-16
 322a520:	dfc00315 	stw	ra,12(sp)
 322a524:	df000215 	stw	fp,8(sp)
 322a528:	df000204 	addi	fp,sp,8
 322a52c:	e13ffe15 	stw	r4,-8(fp)
 322a530:	e17fff15 	stw	r5,-4(fp)
   ENTER_CRIT_SECTION(q);
 322a534:	322ad8c0 	call	322ad8c <irq_Mask>
   LOCKNET_CHECK(q);       /* make sure queue is protected */
   q_addt(q, (qp)elt);     /* use macro to do work */
 322a538:	e0bfff17 	ldw	r2,-4(fp)
 322a53c:	10000015 	stw	zero,0(r2)
 322a540:	e0bffe17 	ldw	r2,-8(fp)
 322a544:	10800017 	ldw	r2,0(r2)
 322a548:	1004c03a 	cmpne	r2,r2,zero
 322a54c:	1000041e 	bne	r2,zero,322a560 <putq+0x44>
 322a550:	e0ffff17 	ldw	r3,-4(fp)
 322a554:	e0bffe17 	ldw	r2,-8(fp)
 322a558:	10c00015 	stw	r3,0(r2)
 322a55c:	00000406 	br	322a570 <putq+0x54>
 322a560:	e0bffe17 	ldw	r2,-8(fp)
 322a564:	10c00117 	ldw	r3,4(r2)
 322a568:	e0bfff17 	ldw	r2,-4(fp)
 322a56c:	18800015 	stw	r2,0(r3)
 322a570:	e0ffff17 	ldw	r3,-4(fp)
 322a574:	e0bffe17 	ldw	r2,-8(fp)
 322a578:	10c00115 	stw	r3,4(r2)
 322a57c:	e0bffe17 	ldw	r2,-8(fp)
 322a580:	10800217 	ldw	r2,8(r2)
 322a584:	10c00044 	addi	r3,r2,1
 322a588:	e0bffe17 	ldw	r2,-8(fp)
 322a58c:	10c00215 	stw	r3,8(r2)
 322a590:	e0bffe17 	ldw	r2,-8(fp)
 322a594:	10c00217 	ldw	r3,8(r2)
 322a598:	e0bffe17 	ldw	r2,-8(fp)
 322a59c:	10800317 	ldw	r2,12(r2)
 322a5a0:	10c0040e 	bge	r2,r3,322a5b4 <putq+0x98>
 322a5a4:	e0bffe17 	ldw	r2,-8(fp)
 322a5a8:	10c00217 	ldw	r3,8(r2)
 322a5ac:	e0bffe17 	ldw	r2,-8(fp)
 322a5b0:	10c00315 	stw	r3,12(r2)
   QUEUE_CHECK(q);         /* make sure queue is not corrupted */
   EXIT_CRIT_SECTION(q);   /* restore int state */
 322a5b4:	322ade80 	call	322ade8 <irq_Unmask>
}
 322a5b8:	e037883a 	mov	sp,fp
 322a5bc:	dfc00117 	ldw	ra,4(sp)
 322a5c0:	df000017 	ldw	fp,0(sp)
 322a5c4:	dec00204 	addi	sp,sp,8
 322a5c8:	f800283a 	ret

0322a5cc <qdel>:
 * RETURNS: Return pointer to queue member if found, else NULL. 
 */

qp
qdel(queue * q, void * elt)
{
 322a5cc:	defff904 	addi	sp,sp,-28
 322a5d0:	dfc00615 	stw	ra,24(sp)
 322a5d4:	df000515 	stw	fp,20(sp)
 322a5d8:	df000504 	addi	fp,sp,20
 322a5dc:	e13ffd15 	stw	r4,-12(fp)
 322a5e0:	e17ffe15 	stw	r5,-8(fp)
   qp qptr;
   qp qlast;

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
 322a5e4:	322ad8c0 	call	322ad8c <irq_Mask>
   qptr = q->q_head;
 322a5e8:	e0bffd17 	ldw	r2,-12(fp)
 322a5ec:	10800017 	ldw	r2,0(r2)
 322a5f0:	e0bffc15 	stw	r2,-16(fp)
   qlast = NULL;
 322a5f4:	e03ffb15 	stw	zero,-20(fp)
   while (qptr)
 322a5f8:	00002d06 	br	322a6b0 <qdel+0xe4>
   {
      if (qptr == (qp)elt)
 322a5fc:	e0fffe17 	ldw	r3,-8(fp)
 322a600:	e0bffc17 	ldw	r2,-16(fp)
 322a604:	10c0251e 	bne	r2,r3,322a69c <qdel+0xd0>
      {
         /* found our item; dequeue it */
         if (qlast)
 322a608:	e0bffb17 	ldw	r2,-20(fp)
 322a60c:	1005003a 	cmpeq	r2,r2,zero
 322a610:	1000051e 	bne	r2,zero,322a628 <qdel+0x5c>
            qlast->qe_next = qptr->qe_next;
 322a614:	e0bffc17 	ldw	r2,-16(fp)
 322a618:	10c00017 	ldw	r3,0(r2)
 322a61c:	e0bffb17 	ldw	r2,-20(fp)
 322a620:	10c00015 	stw	r3,0(r2)
 322a624:	00000406 	br	322a638 <qdel+0x6c>
         else     /* item was at head of queqe */
            q->q_head = qptr->qe_next;
 322a628:	e0bffc17 	ldw	r2,-16(fp)
 322a62c:	10c00017 	ldw	r3,0(r2)
 322a630:	e0bffd17 	ldw	r2,-12(fp)
 322a634:	10c00015 	stw	r3,0(r2)

         /* fix queue tail pointer if needed */
         if (q->q_tail == (qp)elt)
 322a638:	e0bffd17 	ldw	r2,-12(fp)
 322a63c:	10c00117 	ldw	r3,4(r2)
 322a640:	e0bffe17 	ldw	r2,-8(fp)
 322a644:	1880031e 	bne	r3,r2,322a654 <qdel+0x88>
            q->q_tail = qlast;
 322a648:	e0fffd17 	ldw	r3,-12(fp)
 322a64c:	e0bffb17 	ldw	r2,-20(fp)
 322a650:	18800115 	stw	r2,4(r3)

         /* fix queue counters */
         q->q_len--;
 322a654:	e0bffd17 	ldw	r2,-12(fp)
 322a658:	10800217 	ldw	r2,8(r2)
 322a65c:	10ffffc4 	addi	r3,r2,-1
 322a660:	e0bffd17 	ldw	r2,-12(fp)
 322a664:	10c00215 	stw	r3,8(r2)
         if (q->q_len < q->q_min)
 322a668:	e0bffd17 	ldw	r2,-12(fp)
 322a66c:	10c00217 	ldw	r3,8(r2)
 322a670:	e0bffd17 	ldw	r2,-12(fp)
 322a674:	10800417 	ldw	r2,16(r2)
 322a678:	1880040e 	bge	r3,r2,322a68c <qdel+0xc0>
            q->q_min = q->q_len;
 322a67c:	e0bffd17 	ldw	r2,-12(fp)
 322a680:	10c00217 	ldw	r3,8(r2)
 322a684:	e0bffd17 	ldw	r2,-12(fp)
 322a688:	10c00415 	stw	r3,16(r2)
         EXIT_CRIT_SECTION(q);   /* restore int state */
 322a68c:	322ade80 	call	322ade8 <irq_Unmask>
         return (qp)elt;   /* success exit point */
 322a690:	e0bffe17 	ldw	r2,-8(fp)
 322a694:	e0bfff15 	stw	r2,-4(fp)
 322a698:	00000a06 	br	322a6c4 <qdel+0xf8>
      }
      qlast = qptr;
 322a69c:	e0bffc17 	ldw	r2,-16(fp)
 322a6a0:	e0bffb15 	stw	r2,-20(fp)
      qptr = qptr->qe_next;
 322a6a4:	e0bffc17 	ldw	r2,-16(fp)
 322a6a8:	10800017 	ldw	r2,0(r2)
 322a6ac:	e0bffc15 	stw	r2,-16(fp)

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
   qptr = q->q_head;
   qlast = NULL;
   while (qptr)
 322a6b0:	e0bffc17 	ldw	r2,-16(fp)
 322a6b4:	1004c03a 	cmpne	r2,r2,zero
 322a6b8:	103fd01e 	bne	r2,zero,322a5fc <qdel+0x30>
         return (qp)elt;   /* success exit point */
      }
      qlast = qptr;
      qptr = qptr->qe_next;
   }
   EXIT_CRIT_SECTION(q);   /* restore int state */
 322a6bc:	322ade80 	call	322ade8 <irq_Unmask>
   return NULL;   /* item not found in queue */
 322a6c0:	e03fff15 	stw	zero,-4(fp)
 322a6c4:	e0bfff17 	ldw	r2,-4(fp)
}
 322a6c8:	e037883a 	mov	sp,fp
 322a6cc:	dfc00117 	ldw	ra,4(sp)
 322a6d0:	df000017 	ldw	fp,0(sp)
 322a6d4:	dec00204 	addi	sp,sp,8
 322a6d8:	f800283a 	ret

0322a6dc <udp_open>:
   ip_addr  fhost,      /* foreign host, 0L for any */
   unshort  fsock,      /* foreign socket, 0 for any */
   unshort  lsock,      /* local socket */
   int (*handler)(PACKET, void*),   /* rcv upcall */
   void *   data)       /* random data, returned on upcalls to aid demuxing */
{
 322a6dc:	defff304 	addi	sp,sp,-52
 322a6e0:	dfc00c15 	stw	ra,48(sp)
 322a6e4:	df000b15 	stw	fp,44(sp)
 322a6e8:	df000b04 	addi	fp,sp,44
 322a6ec:	e13ffb15 	stw	r4,-20(fp)
 322a6f0:	e1fffe15 	stw	r7,-8(fp)
 322a6f4:	e17ffc0d 	sth	r5,-16(fp)
 322a6f8:	e1bffd0d 	sth	r6,-12(fp)
/*
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
 322a6fc:	0080c974 	movhi	r2,805
 322a700:	10923104 	addi	r2,r2,18628
 322a704:	10800017 	ldw	r2,0(r2)
 322a708:	1080010c 	andi	r2,r2,4
 322a70c:	1005003a 	cmpeq	r2,r2,zero
 322a710:	1000171e 	bne	r2,zero,322a770 <udp_open+0x94>
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 322a714:	e0bffb17 	ldw	r2,-20(fp)
 322a718:	11803fcc 	andi	r6,r2,255
 322a71c:	e0bffb17 	ldw	r2,-20(fp)
 322a720:	1004d23a 	srli	r2,r2,8
 322a724:	11c03fcc 	andi	r7,r2,255
 322a728:	e0bffb17 	ldw	r2,-20(fp)
 322a72c:	1004d43a 	srli	r2,r2,16
 322a730:	12003fcc 	andi	r8,r2,255
 322a734:	e0bffb17 	ldw	r2,-20(fp)
 322a738:	1006d63a 	srli	r3,r2,24
 322a73c:	e13ffd0b 	ldhu	r4,-12(fp)
 322a740:	e17ffc0b 	ldhu	r5,-16(fp)
 322a744:	e0800217 	ldw	r2,8(fp)
 322a748:	d8c00015 	stw	r3,0(sp)
 322a74c:	d9000115 	stw	r4,4(sp)
 322a750:	d9400215 	stw	r5,8(sp)
 322a754:	d8800315 	stw	r2,12(sp)
 322a758:	0100c974 	movhi	r4,805
 322a75c:	213c3104 	addi	r4,r4,-3900
 322a760:	300b883a 	mov	r5,r6
 322a764:	380d883a 	mov	r6,r7
 322a768:	400f883a 	mov	r7,r8
 322a76c:	3206adc0 	call	3206adc <printf>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 322a770:	0009883a 	mov	r4,zero
 322a774:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   ocon = NULL;
 322a778:	e03ff915 	stw	zero,-28(fp)
   for (con = firstudp; con; con = con->u_next)
 322a77c:	d0a8d317 	ldw	r2,-23732(gp)
 322a780:	e0bffa15 	stw	r2,-24(fp)
 322a784:	00002406 	br	322a818 <udp_open+0x13c>
   {
      ocon = con;       /* remember last con in list */
 322a788:	e0bffa17 	ldw	r2,-24(fp)
 322a78c:	e0bff915 	stw	r2,-28(fp)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 322a790:	e0bffa17 	ldw	r2,-24(fp)
 322a794:	1080018b 	ldhu	r2,6(r2)
 322a798:	10ffffcc 	andi	r3,r2,65535
 322a79c:	e0bffd0b 	ldhu	r2,-12(fp)
 322a7a0:	18801a1e 	bne	r3,r2,322a80c <udp_open+0x130>
 322a7a4:	e0bffa17 	ldw	r2,-24(fp)
 322a7a8:	1080020b 	ldhu	r2,8(r2)
 322a7ac:	10ffffcc 	andi	r3,r2,65535
 322a7b0:	e0bffc0b 	ldhu	r2,-16(fp)
 322a7b4:	1880151e 	bne	r3,r2,322a80c <udp_open+0x130>
 322a7b8:	e0bffa17 	ldw	r2,-24(fp)
 322a7bc:	10800317 	ldw	r2,12(r2)
 322a7c0:	1004c03a 	cmpne	r2,r2,zero
 322a7c4:	1000111e 	bne	r2,zero,322a80c <udp_open+0x130>
 322a7c8:	e0bffa17 	ldw	r2,-24(fp)
 322a7cc:	10c00417 	ldw	r3,16(r2)
 322a7d0:	e0bffb17 	ldw	r2,-20(fp)
 322a7d4:	18800d1e 	bne	r3,r2,322a80c <udp_open+0x130>
          con->u_lhost == 0 && con->u_fhost == fhost)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (INFOMSG|PROTERR))
 322a7d8:	0080c974 	movhi	r2,805
 322a7dc:	10923104 	addi	r2,r2,18628
 322a7e0:	10800017 	ldw	r2,0(r2)
 322a7e4:	1080050c 	andi	r2,r2,20
 322a7e8:	1005003a 	cmpeq	r2,r2,zero
 322a7ec:	1000031e 	bne	r2,zero,322a7fc <udp_open+0x120>
            dprintf("UDP: Connection already exists.\n");
 322a7f0:	0100c974 	movhi	r4,805
 322a7f4:	213c4004 	addi	r4,r4,-3840
 322a7f8:	3206e040 	call	3206e04 <puts>
#endif
         UNLOCK_NET_RESOURCE(NET_RESID);
 322a7fc:	0009883a 	mov	r4,zero
 322a800:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         return(NULL);
 322a804:	e03fff15 	stw	zero,-4(fp)
 322a808:	00003c06 	br	322a8fc <udp_open+0x220>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
   ocon = NULL;
   for (con = firstudp; con; con = con->u_next)
 322a80c:	e0bffa17 	ldw	r2,-24(fp)
 322a810:	10800017 	ldw	r2,0(r2)
 322a814:	e0bffa15 	stw	r2,-24(fp)
 322a818:	e0bffa17 	ldw	r2,-24(fp)
 322a81c:	1004c03a 	cmpne	r2,r2,zero
 322a820:	103fd91e 	bne	r2,zero,322a788 <udp_open+0xac>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return(NULL);
      }
   }

   con = (UDPCONN)UC_ALLOC(sizeof(struct udp_conn));
 322a824:	01000804 	movi	r4,32
 322a828:	322b5d00 	call	322b5d0 <npalloc>
 322a82c:	e0bffa15 	stw	r2,-24(fp)
   if (con == 0)
 322a830:	e0bffa17 	ldw	r2,-24(fp)
 322a834:	1004c03a 	cmpne	r2,r2,zero
 322a838:	10000d1e 	bne	r2,zero,322a870 <udp_open+0x194>
   {
#ifdef   NPDEBUG
      if (NDEBUG & INFOMSG)
 322a83c:	0080c974 	movhi	r2,805
 322a840:	10923104 	addi	r2,r2,18628
 322a844:	10800017 	ldw	r2,0(r2)
 322a848:	1080010c 	andi	r2,r2,4
 322a84c:	1005003a 	cmpeq	r2,r2,zero
 322a850:	1000031e 	bne	r2,zero,322a860 <udp_open+0x184>
         dprintf("UDP: Couldn't allocate conn storage.\n");
 322a854:	0100c974 	movhi	r4,805
 322a858:	213c4804 	addi	r4,r4,-3808
 322a85c:	3206e040 	call	3206e04 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 322a860:	0009883a 	mov	r4,zero
 322a864:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return(NULL);
 322a868:	e03fff15 	stw	zero,-4(fp)
 322a86c:	00002306 	br	322a8fc <udp_open+0x220>
   }

   if (ocon)   /* ocon is end of list */
 322a870:	e0bff917 	ldw	r2,-28(fp)
 322a874:	1005003a 	cmpeq	r2,r2,zero
 322a878:	1000041e 	bne	r2,zero,322a88c <udp_open+0x1b0>
      ocon->u_next = con;  /* add new connection to end */
 322a87c:	e0fff917 	ldw	r3,-28(fp)
 322a880:	e0bffa17 	ldw	r2,-24(fp)
 322a884:	18800015 	stw	r2,0(r3)
 322a888:	00000206 	br	322a894 <udp_open+0x1b8>
   else  /* no list, start one */
      firstudp = con;
 322a88c:	e0bffa17 	ldw	r2,-24(fp)
 322a890:	d0a8d315 	stw	r2,-23732(gp)

   con->u_next = 0;
 322a894:	e0bffa17 	ldw	r2,-24(fp)
 322a898:	10000015 	stw	zero,0(r2)

   con->u_lport = lsock;      /* fill in connection info */
 322a89c:	e0fffa17 	ldw	r3,-24(fp)
 322a8a0:	e0bffd0b 	ldhu	r2,-12(fp)
 322a8a4:	1880018d 	sth	r2,6(r3)
   con->u_fport = fsock;
 322a8a8:	e0fffa17 	ldw	r3,-24(fp)
 322a8ac:	e0bffc0b 	ldhu	r2,-16(fp)
 322a8b0:	1880020d 	sth	r2,8(r3)
   con->u_lhost = 0;
 322a8b4:	e0bffa17 	ldw	r2,-24(fp)
 322a8b8:	10000315 	stw	zero,12(r2)
   con->u_fhost = fhost;
 322a8bc:	e0fffa17 	ldw	r3,-24(fp)
 322a8c0:	e0bffb17 	ldw	r2,-20(fp)
 322a8c4:	18800415 	stw	r2,16(r3)
   con->u_rcv   = handler;
 322a8c8:	e0fffa17 	ldw	r3,-24(fp)
 322a8cc:	e0bffe17 	ldw	r2,-8(fp)
 322a8d0:	18800515 	stw	r2,20(r3)
   con->u_data  = data;
 322a8d4:	e0fffa17 	ldw	r3,-24(fp)
 322a8d8:	e0800217 	ldw	r2,8(fp)
 322a8dc:	18800615 	stw	r2,24(r3)
   con->u_flags = UDPCF_V4;
 322a8e0:	e0fffa17 	ldw	r3,-24(fp)
 322a8e4:	00800044 	movi	r2,1
 322a8e8:	1880010d 	sth	r2,4(r3)

   UNLOCK_NET_RESOURCE(NET_RESID);
 322a8ec:	0009883a 	mov	r4,zero
 322a8f0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   return(con);
 322a8f4:	e0bffa17 	ldw	r2,-24(fp)
 322a8f8:	e0bfff15 	stw	r2,-4(fp)
 322a8fc:	e0bfff17 	ldw	r2,-4(fp)
}
 322a900:	e037883a 	mov	sp,fp
 322a904:	dfc00117 	ldw	ra,4(sp)
 322a908:	df000017 	ldw	fp,0(sp)
 322a90c:	dec00204 	addi	sp,sp,8
 322a910:	f800283a 	ret

0322a914 <udp_close>:
 * RETURNS: void
 */

void
udp_close(UDPCONN con)
{
 322a914:	defffb04 	addi	sp,sp,-20
 322a918:	dfc00415 	stw	ra,16(sp)
 322a91c:	df000315 	stw	fp,12(sp)
 322a920:	df000304 	addi	fp,sp,12
 322a924:	e13fff15 	stw	r4,-4(fp)
   UDPCONN pcon;
   UDPCONN lcon;

#ifdef NPDEBUG
   if ((con == NULL) || (firstudp == NULL))
 322a928:	e0bfff17 	ldw	r2,-4(fp)
 322a92c:	1005003a 	cmpeq	r2,r2,zero
 322a930:	1000031e 	bne	r2,zero,322a940 <udp_close+0x2c>
 322a934:	d0a8d317 	ldw	r2,-23732(gp)
 322a938:	1004c03a 	cmpne	r2,r2,zero
 322a93c:	1000021e 	bne	r2,zero,322a948 <udp_close+0x34>
   {
      dtrap(); /* bad programming! */
 322a940:	322ab8c0 	call	322ab8c <dtrap>
      return;
 322a944:	00002706 	br	322a9e4 <udp_close+0xd0>
   }
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 322a948:	0009883a 	mov	r4,zero
 322a94c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
 322a950:	e03ffd15 	stw	zero,-12(fp)
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 322a954:	d0a8d317 	ldw	r2,-23732(gp)
 322a958:	e0bffe15 	stw	r2,-8(fp)
 322a95c:	00000806 	br	322a980 <udp_close+0x6c>
   {
      if (pcon == con)  /* found connection to delete */
 322a960:	e0fffe17 	ldw	r3,-8(fp)
 322a964:	e0bfff17 	ldw	r2,-4(fp)
 322a968:	18800826 	beq	r3,r2,322a98c <udp_close+0x78>
      break;
      lcon = pcon;   /* remember last connection */
 322a96c:	e0bffe17 	ldw	r2,-8(fp)
 322a970:	e0bffd15 	stw	r2,-12(fp)
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 322a974:	e0bffe17 	ldw	r2,-8(fp)
 322a978:	10800017 	ldw	r2,0(r2)
 322a97c:	e0bffe15 	stw	r2,-8(fp)
 322a980:	e0bffe17 	ldw	r2,-8(fp)
 322a984:	1004c03a 	cmpne	r2,r2,zero
 322a988:	103ff51e 	bne	r2,zero,322a960 <udp_close+0x4c>
      if (pcon == con)  /* found connection to delete */
      break;
      lcon = pcon;   /* remember last connection */
   }

   if (!pcon)
 322a98c:	e0bffe17 	ldw	r2,-8(fp)
 322a990:	1004c03a 	cmpne	r2,r2,zero
 322a994:	1000041e 	bne	r2,zero,322a9a8 <udp_close+0x94>
   {
      dtrap(); /* prog error - connenction not in list */
 322a998:	322ab8c0 	call	322ab8c <dtrap>
      UNLOCK_NET_RESOURCE(NET_RESID);
 322a99c:	0009883a 	mov	r4,zero
 322a9a0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return;
 322a9a4:	00000f06 	br	322a9e4 <udp_close+0xd0>
   }

   if (lcon)   /* in con is not head of list */
 322a9a8:	e0bffd17 	ldw	r2,-12(fp)
 322a9ac:	1005003a 	cmpeq	r2,r2,zero
 322a9b0:	1000051e 	bne	r2,zero,322a9c8 <udp_close+0xb4>
      lcon->u_next = con->u_next;   /* unlink */
 322a9b4:	e0bfff17 	ldw	r2,-4(fp)
 322a9b8:	10c00017 	ldw	r3,0(r2)
 322a9bc:	e0bffd17 	ldw	r2,-12(fp)
 322a9c0:	10c00015 	stw	r3,0(r2)
 322a9c4:	00000306 	br	322a9d4 <udp_close+0xc0>
   else
      firstudp = con->u_next; /* remove from head */
 322a9c8:	e0bfff17 	ldw	r2,-4(fp)
 322a9cc:	10800017 	ldw	r2,0(r2)
 322a9d0:	d0a8d315 	stw	r2,-23732(gp)

   UC_FREE(con);  /* free memory for structure */
 322a9d4:	e13fff17 	ldw	r4,-4(fp)
 322a9d8:	322b6c40 	call	322b6c4 <npfree>
   UNLOCK_NET_RESOURCE(NET_RESID);
 322a9dc:	0009883a 	mov	r4,zero
 322a9e0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
}
 322a9e4:	e037883a 	mov	sp,fp
 322a9e8:	dfc00117 	ldw	ra,4(sp)
 322a9ec:	df000017 	ldw	fp,0(sp)
 322a9f0:	dec00204 	addi	sp,sp,8
 322a9f4:	f800283a 	ret

0322a9f8 <asm_cksum>:
      .text

      .global	  asm_cksum

asm_cksum:
      mov   r2, zero		       /* accumulator = 0 */
 322a9f8:	0005883a 	mov	r2,zero
      ble   r5, zero, done	       /* count <= 0 ? */
 322a9fc:	0140620e 	bge	zero,r5,322ab88 <done>

      mov   r6, zero		       /* carry accumulator */
 322aa00:	000d883a 	mov	r6,zero

      andi  r3, r4, 2		       /* ptr 32-bit aligned? */
 322aa04:	20c0008c 	andi	r3,r4,2
      beq   r3, zero, asm1
 322aa08:	18000326 	beq	r3,zero,322aa18 <asm1>
      ldhu  r2, (r4)		       /* no - process first 16-bits */
 322aa0c:	2080000b 	ldhu	r2,0(r4)
      addi  r4, r4, 2
 322aa10:	21000084 	addi	r4,r4,2
      subi  r5, r5, 1
 322aa14:	297fffc4 	addi	r5,r5,-1

0322aa18 <asm1>:
 322aa18:	02c0c8f4 	movhi	r11,803
/*
 * adjust ptr by ((count/2) mod 16) * 4 bytes
 * jump to location: loop0 - (count/2 mod 16) * 4 instructions
 */
asm1:
      movia r11, loop0
 322aa1c:	5aead104 	addi	r11,r11,-21692
      andi  r9, r5, 1		       /* r9 = last halfword flag */
 322aa20:	2a40004c 	andi	r9,r5,1
      srai  r5, r5, 1		       /* count = number of words */
 322aa24:	280bd07a 	srai	r5,r5,1
      andi  r10, r5, 0xf	       /* modulo 16 */
 322aa28:	2a8003cc 	andi	r10,r5,15
      slli  r10, r10, 2		       /*      * 4 bytes per word */
 322aa2c:	501490ba 	slli	r10,r10,2
      add   r4, r10, r4		       /* adjust ptr */
 322aa30:	5109883a 	add	r4,r10,r4
      slli  r10, r10, 2		       /*      * 4 instructions per 4 bytes */
 322aa34:	501490ba 	slli	r10,r10,2
      sub   r11, r11, r10
 322aa38:	5a97c83a 	sub	r11,r11,r10
      jmp   r11
 322aa3c:	5800683a 	jmp	r11

0322aa40 <loop>:
      
loop:
      addi  r4, r4, 64		       /* increment data pointer */
 322aa40:	21001004 	addi	r4,r4,64

      ldw   r7, -64(r4)
 322aa44:	21fff017 	ldw	r7,-64(r4)
      add   r2, r7, r2
 322aa48:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322aa4c:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322aa50:	418d883a 	add	r6,r8,r6

      ldw   r7, -60(r4)
 322aa54:	21fff117 	ldw	r7,-60(r4)
      add   r2, r7, r2
 322aa58:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322aa5c:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322aa60:	418d883a 	add	r6,r8,r6

      ldw   r7, -56(r4)
 322aa64:	21fff217 	ldw	r7,-56(r4)
      add   r2, r7, r2
 322aa68:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322aa6c:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322aa70:	418d883a 	add	r6,r8,r6

      ldw   r7, -52(r4)
 322aa74:	21fff317 	ldw	r7,-52(r4)
      add   r2, r7, r2
 322aa78:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322aa7c:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322aa80:	418d883a 	add	r6,r8,r6

      ldw   r7, -48(r4)
 322aa84:	21fff417 	ldw	r7,-48(r4)
      add   r2, r7, r2
 322aa88:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322aa8c:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322aa90:	418d883a 	add	r6,r8,r6

      ldw   r7, -44(r4)
 322aa94:	21fff517 	ldw	r7,-44(r4)
      add   r2, r7, r2
 322aa98:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322aa9c:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322aaa0:	418d883a 	add	r6,r8,r6

      ldw   r7, -40(r4)
 322aaa4:	21fff617 	ldw	r7,-40(r4)
      add   r2, r7, r2
 322aaa8:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322aaac:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322aab0:	418d883a 	add	r6,r8,r6

      ldw   r7, -36(r4)
 322aab4:	21fff717 	ldw	r7,-36(r4)
      add   r2, r7, r2
 322aab8:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322aabc:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322aac0:	418d883a 	add	r6,r8,r6

      ldw   r7, -32(r4)
 322aac4:	21fff817 	ldw	r7,-32(r4)
      add   r2, r7, r2
 322aac8:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322aacc:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322aad0:	418d883a 	add	r6,r8,r6

      ldw   r7, -28(r4)
 322aad4:	21fff917 	ldw	r7,-28(r4)
      add   r2, r7, r2
 322aad8:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322aadc:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322aae0:	418d883a 	add	r6,r8,r6

      ldw   r7, -24(r4)
 322aae4:	21fffa17 	ldw	r7,-24(r4)
      add   r2, r7, r2
 322aae8:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322aaec:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322aaf0:	418d883a 	add	r6,r8,r6

      ldw   r7, -20(r4)
 322aaf4:	21fffb17 	ldw	r7,-20(r4)
      add   r2, r7, r2
 322aaf8:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322aafc:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322ab00:	418d883a 	add	r6,r8,r6

      ldw   r7, -16(r4)
 322ab04:	21fffc17 	ldw	r7,-16(r4)
      add   r2, r7, r2
 322ab08:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322ab0c:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322ab10:	418d883a 	add	r6,r8,r6

      ldw   r7, -12(r4)
 322ab14:	21fffd17 	ldw	r7,-12(r4)
      add   r2, r7, r2
 322ab18:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322ab1c:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322ab20:	418d883a 	add	r6,r8,r6

      ldw   r7, -8(r4)
 322ab24:	21fffe17 	ldw	r7,-8(r4)
      add   r2, r7, r2
 322ab28:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322ab2c:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322ab30:	418d883a 	add	r6,r8,r6

      ldw   r7, -4(r4)
 322ab34:	21ffff17 	ldw	r7,-4(r4)
      add   r2, r7, r2
 322ab38:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322ab3c:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322ab40:	418d883a 	add	r6,r8,r6

0322ab44 <loop0>:
loop0:
      subi  r5, r5, 16
 322ab44:	297ffc04 	addi	r5,r5,-16
      bge   r5, zero, loop
 322ab48:	283fbd0e 	bge	r5,zero,322aa40 <loop>
/*
 * process last halfword (if any)
 */
      beq   r9, zero, fold
 322ab4c:	48000426 	beq	r9,zero,322ab60 <fold>
      ldhu  r7, 0(r4)
 322ab50:	21c0000b 	ldhu	r7,0(r4)
      add   r2, r7, r2
 322ab54:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322ab58:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322ab5c:	418d883a 	add	r6,r8,r6

0322ab60 <fold>:
      
fold:
      srli  r7, r2, 16
 322ab60:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 322ab64:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add the upper and lower halfwords */
 322ab68:	3885883a 	add	r2,r7,r2
      add   r2, r6, r2		    /* add the carries */
 322ab6c:	3085883a 	add	r2,r6,r2
/* the accumulator is 18 bits */
      srli  r7, r2, 16
 322ab70:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 322ab74:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add 2 carry bits to lower halfword */
 322ab78:	3885883a 	add	r2,r7,r2
/* the accumulator is 17 bits */
      srli  r7, r2, 16
 322ab7c:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 322ab80:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add carry to lower halfword */
 322ab84:	3885883a 	add	r2,r7,r2

0322ab88 <done>:

done:
      ret			    		/* r2 = 16-bit checksum */
 322ab88:	f800283a 	ret

0322ab8c <dtrap>:
void irq_Unmask(void);

/* dtrap() - function to trap to debugger */
void
dtrap(void)
{
 322ab8c:	defffe04 	addi	sp,sp,-8
 322ab90:	dfc00115 	stw	ra,4(sp)
 322ab94:	df000015 	stw	fp,0(sp)
 322ab98:	d839883a 	mov	fp,sp
   printf("dtrap - needs breakpoint\n");
 322ab9c:	0100c974 	movhi	r4,805
 322aba0:	213c5204 	addi	r4,r4,-3768
 322aba4:	3206e040 	call	3206e04 <puts>
}
 322aba8:	e037883a 	mov	sp,fp
 322abac:	dfc00117 	ldw	ra,4(sp)
 322abb0:	df000017 	ldw	fp,0(sp)
 322abb4:	dec00204 	addi	sp,sp,8
 322abb8:	f800283a 	ret

0322abbc <kbhit>:

int
kbhit()
{
 322abbc:	defffc04 	addi	sp,sp,-16
 322abc0:	dfc00315 	stw	ra,12(sp)
 322abc4:	df000215 	stw	fp,8(sp)
 322abc8:	df000204 	addi	fp,sp,8
   static int kbd_init = 0;
   int   kb;
   
   if (!kbd_init)
 322abcc:	d0a8d417 	ldw	r2,-23728(gp)
 322abd0:	1004c03a 	cmpne	r2,r2,zero
 322abd4:	10000c1e 	bne	r2,zero,322ac08 <kbhit+0x4c>
      /* we really should read the flags, OR in O_NONBLOCK, and write
       * the flags back to STDIN, but the NIOS-II/HAL implementation
       * will only let us modify O_NONBLOCK and O_APPEND, so we'll
       * just write the new flag value.
       */
      if (fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK) != 0)
 322abd8:	0009883a 	mov	r4,zero
 322abdc:	01400104 	movi	r5,4
 322abe0:	01900004 	movi	r6,16384
 322abe4:	323ce080 	call	323ce08 <fcntl>
 322abe8:	1005003a 	cmpeq	r2,r2,zero
 322abec:	1000041e 	bne	r2,zero,322ac00 <kbhit+0x44>
      {
         printf("F_SETFL failed.\n");
 322abf0:	0100c974 	movhi	r4,805
 322abf4:	213c5904 	addi	r4,r4,-3740
 322abf8:	3206e040 	call	3206e04 <puts>
         dtrap();
 322abfc:	322ab8c0 	call	322ab8c <dtrap>
      }
      kbd_init = 1; 
 322ac00:	00800044 	movi	r2,1
 322ac04:	d0a8d415 	stw	r2,-23728(gp)
   }

   /* we have to do a read to see if there is a character available.
    * we save the character, if there was one, to be read later. */
   if (kb_last == EOF)
 322ac08:	d0a03617 	ldw	r2,-32552(gp)
 322ac0c:	10bfffd8 	cmpnei	r2,r2,-1
 322ac10:	10000d1e 	bne	r2,zero,322ac48 <kbhit+0x8c>
   {
      kb = getchar();
 322ac14:	0080c974 	movhi	r2,805
 322ac18:	10897804 	addi	r2,r2,9696
 322ac1c:	10800017 	ldw	r2,0(r2)
 322ac20:	11000117 	ldw	r4,4(r2)
 322ac24:	3205cec0 	call	3205cec <getc>
 322ac28:	e0bffe15 	stw	r2,-8(fp)
      if (kb < 0)       /* any error means no character present */
 322ac2c:	e0bffe17 	ldw	r2,-8(fp)
 322ac30:	1004403a 	cmpge	r2,r2,zero
 322ac34:	1000021e 	bne	r2,zero,322ac40 <kbhit+0x84>
         return (FALSE);
 322ac38:	e03fff15 	stw	zero,-4(fp)
 322ac3c:	00000406 	br	322ac50 <kbhit+0x94>
         
      /* there was a character, and we read it. */
      kb_last = kb;
 322ac40:	e0bffe17 	ldw	r2,-8(fp)
 322ac44:	d0a03615 	stw	r2,-32552(gp)
   }

   return (TRUE);
 322ac48:	00800044 	movi	r2,1
 322ac4c:	e0bfff15 	stw	r2,-4(fp)
 322ac50:	e0bfff17 	ldw	r2,-4(fp)
}
 322ac54:	e037883a 	mov	sp,fp
 322ac58:	dfc00117 	ldw	ra,4(sp)
 322ac5c:	df000017 	ldw	fp,0(sp)
 322ac60:	dec00204 	addi	sp,sp,8
 322ac64:	f800283a 	ret

0322ac68 <getch>:

int 
getch()
{
 322ac68:	defffd04 	addi	sp,sp,-12
 322ac6c:	dfc00215 	stw	ra,8(sp)
 322ac70:	df000115 	stw	fp,4(sp)
 322ac74:	df000104 	addi	fp,sp,4
int chr;

   if(kb_last != EOF)
 322ac78:	d0a03617 	ldw	r2,-32552(gp)
 322ac7c:	10bfffe0 	cmpeqi	r2,r2,-1
 322ac80:	1000051e 	bne	r2,zero,322ac98 <getch+0x30>
   {
      chr = kb_last;
 322ac84:	d0a03617 	ldw	r2,-32552(gp)
 322ac88:	e0bfff15 	stw	r2,-4(fp)
      kb_last = EOF;
 322ac8c:	00bfffc4 	movi	r2,-1
 322ac90:	d0a03615 	stw	r2,-32552(gp)
 322ac94:	00000606 	br	322acb0 <getch+0x48>
   }
   else
      chr = getchar();
 322ac98:	0080c974 	movhi	r2,805
 322ac9c:	10897804 	addi	r2,r2,9696
 322aca0:	10800017 	ldw	r2,0(r2)
 322aca4:	11000117 	ldw	r4,4(r2)
 322aca8:	3205cec0 	call	3205cec <getc>
 322acac:	e0bfff15 	stw	r2,-4(fp)

   return chr;
 322acb0:	e0bfff17 	ldw	r2,-4(fp)
}
 322acb4:	e037883a 	mov	sp,fp
 322acb8:	dfc00117 	ldw	ra,4(sp)
 322acbc:	df000017 	ldw	fp,0(sp)
 322acc0:	dec00204 	addi	sp,sp,8
 322acc4:	f800283a 	ret

0322acc8 <clock_init>:
int OS_TPS;
int cticks_factor;
int cticks_initialized = 0;

void clock_init(void)
{
 322acc8:	deffff04 	addi	sp,sp,-4
 322accc:	df000015 	stw	fp,0(sp)
 322acd0:	d839883a 	mov	fp,sp
   OS_TPS = OS_TICKS_PER_SEC;
 322acd4:	0080fa04 	movi	r2,1000
 322acd8:	d0a8d915 	stw	r2,-23708(gp)
   cticks_factor = 0;
 322acdc:	d028d815 	stw	zero,-23712(gp)
   cticks = 0;
 322ace0:	0080c974 	movhi	r2,805
 322ace4:	10925604 	addi	r2,r2,18776
 322ace8:	10000015 	stw	zero,0(r2)
   cticks_initialized = 1;
 322acec:	00800044 	movi	r2,1
 322acf0:	d0a8d515 	stw	r2,-23724(gp)
}
 322acf4:	e037883a 	mov	sp,fp
 322acf8:	df000017 	ldw	fp,0(sp)
 322acfc:	dec00104 	addi	sp,sp,4
 322ad00:	f800283a 	ret

0322ad04 <clock_c>:

/* undo effects of clock_init (i.e. restore ISR vector) 
 * NO OP since using RTOS's timer.
 */
void clock_c(void)
{
 322ad04:	deffff04 	addi	sp,sp,-4
 322ad08:	df000015 	stw	fp,0(sp)
 322ad0c:	d839883a 	mov	fp,sp
   /* null */ ;
}
 322ad10:	e037883a 	mov	sp,fp
 322ad14:	df000017 	ldw	fp,0(sp)
 322ad18:	dec00104 	addi	sp,sp,4
 322ad1c:	f800283a 	ret

0322ad20 <cticks_hook>:
 * Use the uCOS-II/Altera HAL BSP's timer and scale cticks as per TPS.
 */

void
cticks_hook(void)
{
 322ad20:	deffff04 	addi	sp,sp,-4
 322ad24:	df000015 	stw	fp,0(sp)
 322ad28:	d839883a 	mov	fp,sp
   if (cticks_initialized) 
 322ad2c:	d0a8d517 	ldw	r2,-23724(gp)
 322ad30:	1005003a 	cmpeq	r2,r2,zero
 322ad34:	1000111e 	bne	r2,zero,322ad7c <cticks_hook+0x5c>
   {
      cticks_factor += TPS;
 322ad38:	d0a8d817 	ldw	r2,-23712(gp)
 322ad3c:	1080fa04 	addi	r2,r2,1000
 322ad40:	d0a8d815 	stw	r2,-23712(gp)
      if (cticks_factor >= OS_TPS)
 322ad44:	d0e8d817 	ldw	r3,-23712(gp)
 322ad48:	d0a8d917 	ldw	r2,-23708(gp)
 322ad4c:	18800b16 	blt	r3,r2,322ad7c <cticks_hook+0x5c>
      {
         cticks++;
 322ad50:	0080c974 	movhi	r2,805
 322ad54:	10925604 	addi	r2,r2,18776
 322ad58:	10800017 	ldw	r2,0(r2)
 322ad5c:	10c00044 	addi	r3,r2,1
 322ad60:	0080c974 	movhi	r2,805
 322ad64:	10925604 	addi	r2,r2,18776
 322ad68:	10c00015 	stw	r3,0(r2)
         cticks_factor -= OS_TPS;
 322ad6c:	d0e8d817 	ldw	r3,-23712(gp)
 322ad70:	d0a8d917 	ldw	r2,-23708(gp)
 322ad74:	1885c83a 	sub	r2,r3,r2
 322ad78:	d0a8d815 	stw	r2,-23712(gp)
#ifdef USE_LCD
         update_display();
#endif
      }
   }
}
 322ad7c:	e037883a 	mov	sp,fp
 322ad80:	df000017 	ldw	fp,0(sp)
 322ad84:	dec00104 	addi	sp,sp,4
 322ad88:	f800283a 	ret

0322ad8c <irq_Mask>:
 * ENTER_CRIT_SECTION() and enable them in EXIT_CRIT_SECTION()
 * because calls to ENTER_CRIT_SECTION() can be nested."
 */
void
irq_Mask(void)
{
 322ad8c:	defffd04 	addi	sp,sp,-12
 322ad90:	df000215 	stw	fp,8(sp)
 322ad94:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 322ad98:	0005303a 	rdctl	r2,status
 322ad9c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 322ada0:	e0fffe17 	ldw	r3,-8(fp)
 322ada4:	00bfff84 	movi	r2,-2
 322ada8:	1884703a 	and	r2,r3,r2
 322adac:	1001703a 	wrctl	status,r2
  
  return context;
 322adb0:	e0bffe17 	ldw	r2,-8(fp)
   alt_irq_context  local_cpu_statusreg;

   local_cpu_statusreg = alt_irq_disable_all();
 322adb4:	e0bfff15 	stw	r2,-4(fp)
	
   if (++irq_level == 1)
 322adb8:	d0a8d617 	ldw	r2,-23720(gp)
 322adbc:	10800044 	addi	r2,r2,1
 322adc0:	d0a8d615 	stw	r2,-23720(gp)
 322adc4:	d0a8d617 	ldw	r2,-23720(gp)
 322adc8:	10800058 	cmpnei	r2,r2,1
 322adcc:	1000021e 	bne	r2,zero,322add8 <irq_Mask+0x4c>
   {
      cpu_statusreg = local_cpu_statusreg;
 322add0:	e0bfff17 	ldw	r2,-4(fp)
 322add4:	d0a8d715 	stw	r2,-23716(gp)
   }
}
 322add8:	e037883a 	mov	sp,fp
 322addc:	df000017 	ldw	fp,0(sp)
 322ade0:	dec00104 	addi	sp,sp,4
 322ade4:	f800283a 	ret

0322ade8 <irq_Unmask>:


/* Re-Enable Interrupts */
void
irq_Unmask(void)
{
 322ade8:	defffe04 	addi	sp,sp,-8
 322adec:	df000115 	stw	fp,4(sp)
 322adf0:	df000104 	addi	fp,sp,4
   if (--irq_level == 0)
 322adf4:	d0a8d617 	ldw	r2,-23720(gp)
 322adf8:	10bfffc4 	addi	r2,r2,-1
 322adfc:	d0a8d615 	stw	r2,-23720(gp)
 322ae00:	d0a8d617 	ldw	r2,-23720(gp)
 322ae04:	1004c03a 	cmpne	r2,r2,zero
 322ae08:	1000041e 	bne	r2,zero,322ae1c <irq_Unmask+0x34>
   {
      alt_irq_enable_all(cpu_statusreg);
 322ae0c:	d0a8d717 	ldw	r2,-23716(gp)
 322ae10:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 322ae14:	e0bfff17 	ldw	r2,-4(fp)
 322ae18:	1001703a 	wrctl	status,r2
   }
}
 322ae1c:	e037883a 	mov	sp,fp
 322ae20:	df000017 	ldw	fp,0(sp)
 322ae24:	dec00104 	addi	sp,sp,4
 322ae28:	f800283a 	ret

0322ae2c <LOCK_NET_RESOURCE>:
extern void irq_Mask(void);
extern void irq_Unmask(void);

void
LOCK_NET_RESOURCE(int resid)
{
 322ae2c:	defffb04 	addi	sp,sp,-20
 322ae30:	dfc00415 	stw	ra,16(sp)
 322ae34:	df000315 	stw	fp,12(sp)
 322ae38:	df000304 	addi	fp,sp,12
 322ae3c:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 322ae40:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 322ae44:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 322ae48:	e0bfff17 	ldw	r2,-4(fp)
 322ae4c:	1004803a 	cmplt	r2,r2,zero
 322ae50:	1000201e 	bne	r2,zero,322aed4 <LOCK_NET_RESOURCE+0xa8>
 322ae54:	e0bfff17 	ldw	r2,-4(fp)
 322ae58:	10800408 	cmpgei	r2,r2,16
 322ae5c:	10001d1e 	bne	r2,zero,322aed4 <LOCK_NET_RESOURCE+0xa8>
   {
      do
      {
         OSSemPend(resid_semaphore[resid], 0, &error);
 322ae60:	e0bfff17 	ldw	r2,-4(fp)
 322ae64:	00c0c9b4 	movhi	r3,806
 322ae68:	18f38104 	addi	r3,r3,-12796
 322ae6c:	1085883a 	add	r2,r2,r2
 322ae70:	1085883a 	add	r2,r2,r2
 322ae74:	10c5883a 	add	r2,r2,r3
 322ae78:	11000017 	ldw	r4,0(r2)
 322ae7c:	e1bffe04 	addi	r6,fp,-8
 322ae80:	000b883a 	mov	r5,zero
 322ae84:	321ade40 	call	321ade4 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 322ae88:	e0bffe03 	ldbu	r2,-8(fp)
 322ae8c:	10803fcc 	andi	r2,r2,255
 322ae90:	10800298 	cmpnei	r2,r2,10
 322ae94:	10000a1e 	bne	r2,zero,322aec0 <LOCK_NET_RESOURCE+0x94>
 322ae98:	e0bffd17 	ldw	r2,-12(fp)
 322ae9c:	10800044 	addi	r2,r2,1
 322aea0:	e0bffd15 	stw	r2,-12(fp)
 322aea4:	e0bffd17 	ldw	r2,-12(fp)
 322aea8:	1080fa50 	cmplti	r2,r2,1001
 322aeac:	1000041e 	bne	r2,zero,322aec0 <LOCK_NET_RESOURCE+0x94>
         {
            panic("lock NET");   /* fatal */
 322aeb0:	0100c974 	movhi	r4,805
 322aeb4:	213c5d04 	addi	r4,r4,-3724
 322aeb8:	3225df00 	call	3225df0 <panic>
            return;
 322aebc:	00000606 	br	322aed8 <LOCK_NET_RESOURCE+0xac>
         }
      } while (error == 10);
 322aec0:	e0bffe03 	ldbu	r2,-8(fp)
 322aec4:	10803fcc 	andi	r2,r2,255
 322aec8:	108002a0 	cmpeqi	r2,r2,10
 322aecc:	103fe41e 	bne	r2,zero,322ae60 <LOCK_NET_RESOURCE+0x34>
LOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;
   int   errct = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 322aed0:	00000106 	br	322aed8 <LOCK_NET_RESOURCE+0xac>
            return;
         }
      } while (error == 10);
   }
   else
      dtrap();
 322aed4:	322ab8c0 	call	322ab8c <dtrap>
}
 322aed8:	e037883a 	mov	sp,fp
 322aedc:	dfc00117 	ldw	ra,4(sp)
 322aee0:	df000017 	ldw	fp,0(sp)
 322aee4:	dec00204 	addi	sp,sp,8
 322aee8:	f800283a 	ret

0322aeec <UNLOCK_NET_RESOURCE>:

void
UNLOCK_NET_RESOURCE(int resid)
{
 322aeec:	defffc04 	addi	sp,sp,-16
 322aef0:	dfc00315 	stw	ra,12(sp)
 322aef4:	df000215 	stw	fp,8(sp)
 322aef8:	df000204 	addi	fp,sp,8
 322aefc:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 322af00:	e03ffe05 	stb	zero,-8(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 322af04:	e0bfff17 	ldw	r2,-4(fp)
 322af08:	1004803a 	cmplt	r2,r2,zero
 322af0c:	1000131e 	bne	r2,zero,322af5c <UNLOCK_NET_RESOURCE+0x70>
 322af10:	e0bfff17 	ldw	r2,-4(fp)
 322af14:	10800408 	cmpgei	r2,r2,16
 322af18:	1000101e 	bne	r2,zero,322af5c <UNLOCK_NET_RESOURCE+0x70>
   {
      error = OSSemPost(resid_semaphore[resid]);
 322af1c:	e0bfff17 	ldw	r2,-4(fp)
 322af20:	00c0c9b4 	movhi	r3,806
 322af24:	18f38104 	addi	r3,r3,-12796
 322af28:	1085883a 	add	r2,r2,r2
 322af2c:	1085883a 	add	r2,r2,r2
 322af30:	10c5883a 	add	r2,r2,r3
 322af34:	11000017 	ldw	r4,0(r2)
 322af38:	321b1dc0 	call	321b1dc <OSSemPost>
 322af3c:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 322af40:	e0bffe03 	ldbu	r2,-8(fp)
 322af44:	1005003a 	cmpeq	r2,r2,zero
 322af48:	1000051e 	bne	r2,zero,322af60 <UNLOCK_NET_RESOURCE+0x74>
      {
         panic("unlock NET");
 322af4c:	0100c974 	movhi	r4,805
 322af50:	213c6004 	addi	r4,r4,-3712
 322af54:	3225df00 	call	3225df0 <panic>
void
UNLOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 322af58:	00000106 	br	322af60 <UNLOCK_NET_RESOURCE+0x74>
      {
         panic("unlock NET");
      }
   }
   else
      dtrap();
 322af5c:	322ab8c0 	call	322ab8c <dtrap>
}
 322af60:	e037883a 	mov	sp,fp
 322af64:	dfc00117 	ldw	ra,4(sp)
 322af68:	df000017 	ldw	fp,0(sp)
 322af6c:	dec00204 	addi	sp,sp,8
 322af70:	f800283a 	ret

0322af74 <TK_NEWTASK>:
extern long     nettick_wakes;


int
TK_NEWTASK(struct inet_taskinfo * nettask)
{
 322af74:	deffed04 	addi	sp,sp,-76
 322af78:	dfc01215 	stw	ra,72(sp)
 322af7c:	df001115 	stw	fp,68(sp)
 322af80:	df001104 	addi	fp,sp,68
 322af84:	e13ffe15 	stw	r4,-8(fp)
   INT8U    error;
   OS_STK * stack;

   stack = (OS_STK*)npalloc(nettask->stacksize);
 322af88:	e0bffe17 	ldw	r2,-8(fp)
 322af8c:	10800417 	ldw	r2,16(r2)
 322af90:	1009883a 	mov	r4,r2
 322af94:	322b5d00 	call	322b5d0 <npalloc>
 322af98:	e0bff415 	stw	r2,-48(fp)
   if(!stack)
 322af9c:	e0bff417 	ldw	r2,-48(fp)
 322afa0:	1004c03a 	cmpne	r2,r2,zero
 322afa4:	1000031e 	bne	r2,zero,322afb4 <TK_NEWTASK+0x40>
      panic("stack alloc");
 322afa8:	0100c974 	movhi	r4,805
 322afac:	213c6304 	addi	r4,r4,-3700
 322afb0:	3225df00 	call	3225df0 <panic>

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 322afb4:	e0bffe17 	ldw	r2,-8(fp)
 322afb8:	11400217 	ldw	r5,8(r2)
 322afbc:	e0bffe17 	ldw	r2,-8(fp)
 322afc0:	10800417 	ldw	r2,16(r2)
 322afc4:	1004d0ba 	srli	r2,r2,2
 322afc8:	1085883a 	add	r2,r2,r2
 322afcc:	1085883a 	add	r2,r2,r2
 322afd0:	1007883a 	mov	r3,r2
 322afd4:	e0bff417 	ldw	r2,-48(fp)
 322afd8:	1885883a 	add	r2,r3,r2
 322afdc:	11bfff04 	addi	r6,r2,-4
 322afe0:	e0bffe17 	ldw	r2,-8(fp)
 322afe4:	10800317 	ldw	r2,12(r2)
 322afe8:	11c03fcc 	andi	r7,r2,255
 322afec:	e0bffe17 	ldw	r2,-8(fp)
 322aff0:	10800317 	ldw	r2,12(r2)
 322aff4:	10ffffcc 	andi	r3,r2,65535
 322aff8:	e0bffe17 	ldw	r2,-8(fp)
 322affc:	10800417 	ldw	r2,16(r2)
 322b000:	1008d0ba 	srli	r4,r2,2
 322b004:	d8c00015 	stw	r3,0(sp)
 322b008:	e0bff417 	ldw	r2,-48(fp)
 322b00c:	d8800115 	stw	r2,4(sp)
 322b010:	d9000215 	stw	r4,8(sp)
 322b014:	d8000315 	stw	zero,12(sp)
 322b018:	008000c4 	movi	r2,3
 322b01c:	d8800415 	stw	r2,16(sp)
 322b020:	2809883a 	mov	r4,r5
 322b024:	000b883a 	mov	r5,zero
 322b028:	321bc800 	call	321bc80 <OSTaskCreateExt>
 322b02c:	e0bff505 	stb	r2,-44(fp)
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority);
#endif
   /* If we go here, then there's another task using our priority */
   /* Tell the user and exit with an error */
   if (error == OS_PRIO_EXIST)
 322b030:	e0bff503 	ldbu	r2,-44(fp)
 322b034:	10803fcc 	andi	r2,r2,255
 322b038:	10800a18 	cmpnei	r2,r2,40
 322b03c:	1000161e 	bne	r2,zero,322b098 <TK_NEWTASK+0x124>
   { 
     char curr_task[OS_TASK_NAME_SIZE];
     INT8U err;
     OSTaskNameGet(nettask->priority, curr_task, &err);
 322b040:	e0bffe17 	ldw	r2,-8(fp)
 322b044:	10800317 	ldw	r2,12(r2)
 322b048:	11003fcc 	andi	r4,r2,255
 322b04c:	e17ff584 	addi	r5,fp,-42
 322b050:	e1bff544 	addi	r6,fp,-43
 322b054:	321c3fc0 	call	321c3fc <OSTaskNameGet>
     curr_task[OS_TASK_NAME_SIZE-1]=0;
 322b058:	e03ffd45 	stb	zero,-11(fp)
    
     printf("Priority requested for task \"%s\" (Prio:%d) conflicts with "\
 322b05c:	e0bffe17 	ldw	r2,-8(fp)
 322b060:	11400117 	ldw	r5,4(r2)
 322b064:	e0bffe17 	ldw	r2,-8(fp)
 322b068:	11800317 	ldw	r6,12(r2)
 322b06c:	e0bffe17 	ldw	r2,-8(fp)
 322b070:	10800317 	ldw	r2,12(r2)
 322b074:	e1fff584 	addi	r7,fp,-42
 322b078:	d8800015 	stw	r2,0(sp)
 322b07c:	0100c974 	movhi	r4,805
 322b080:	213c6604 	addi	r4,r4,-3688
 322b084:	3206adc0 	call	3206adc <printf>
            "already running task \"%s\" (Prio: %d)\n",
             nettask->name, nettask->priority, curr_task, nettask->priority);
             
     printf("You may wish to check your task priority settings in "\
 322b088:	0100c974 	movhi	r4,805
 322b08c:	213c7e04 	addi	r4,r4,-3592
 322b090:	3206e040 	call	3206e04 <puts>
 322b094:	00001e06 	br	322b110 <TK_NEWTASK+0x19c>
            "\"<bsp path>\\iniche\\src\\h\\nios2\\ipport.h\" against "\
            "the priority settings in your application and recompile.\n\n");
   }
   else if (error == OS_PRIO_INVALID)
 322b098:	e0bff503 	ldbu	r2,-44(fp)
 322b09c:	10803fcc 	andi	r2,r2,255
 322b0a0:	10800a98 	cmpnei	r2,r2,42
 322b0a4:	10000c1e 	bne	r2,zero,322b0d8 <TK_NEWTASK+0x164>
   {
     printf("Priority requested for task \"%s\" (Prio:%d) exceeds "\
 322b0a8:	e0bffe17 	ldw	r2,-8(fp)
 322b0ac:	11400117 	ldw	r5,4(r2)
 322b0b0:	e0bffe17 	ldw	r2,-8(fp)
 322b0b4:	11800317 	ldw	r6,12(r2)
 322b0b8:	0100c974 	movhi	r4,805
 322b0bc:	213ca604 	addi	r4,r4,-3432
 322b0c0:	01c00504 	movi	r7,20
 322b0c4:	3206adc0 	call	3206adc <printf>
            "available priority levels in the system (OS_LOWEST_PRIO = %d)\n\n",
             nettask->name, nettask->priority, OS_LOWEST_PRIO);
             
     printf("Please modify the tasks priority level, or modify the "\
 322b0c8:	0100c974 	movhi	r4,805
 322b0cc:	213cc304 	addi	r4,r4,-3316
 322b0d0:	3206e040 	call	3206e04 <puts>
 322b0d4:	00000e06 	br	322b110 <TK_NEWTASK+0x19c>
            "\"Lowest assignable priority\" setting in the MicroC/OS-II "\
            "component\n");
   }
   else if (error != OS_NO_ERR)
 322b0d8:	e0bff503 	ldbu	r2,-44(fp)
 322b0dc:	10803fcc 	andi	r2,r2,255
 322b0e0:	1005003a 	cmpeq	r2,r2,zero
 322b0e4:	10000a1e 	bne	r2,zero,322b110 <TK_NEWTASK+0x19c>
   {                          /* All other errors are fatal */
      printf("Task create error /(MicroC/OS-II error code:%d/) on %s\n",
 322b0e8:	e0bff503 	ldbu	r2,-44(fp)
 322b0ec:	11403fcc 	andi	r5,r2,255
 322b0f0:	e0bffe17 	ldw	r2,-8(fp)
 322b0f4:	11800117 	ldw	r6,4(r2)
 322b0f8:	0100c974 	movhi	r4,805
 322b0fc:	213ce204 	addi	r4,r4,-3192
 322b100:	3206adc0 	call	3206adc <printf>
             error, nettask->name);
      return (-1);
 322b104:	00bfffc4 	movi	r2,-1
 322b108:	e0bfff15 	stw	r2,-4(fp)
 322b10c:	00001806 	br	322b170 <TK_NEWTASK+0x1fc>
   }

   /* Include the task name, so that uc/osII (os aware) debuggers can
    * display it.
    */
   OSTaskNameSet(nettask->priority, &nettask->name[0], &error);
 322b110:	e0bffe17 	ldw	r2,-8(fp)
 322b114:	10800317 	ldw	r2,12(r2)
 322b118:	11003fcc 	andi	r4,r2,255
 322b11c:	e0bffe17 	ldw	r2,-8(fp)
 322b120:	10800117 	ldw	r2,4(r2)
 322b124:	100b883a 	mov	r5,r2
 322b128:	e1bff504 	addi	r6,fp,-44
 322b12c:	321c5b40 	call	321c5b4 <OSTaskNameSet>

   nettask->stackbase = (char*)stack;
 322b130:	e0fff417 	ldw	r3,-48(fp)
 322b134:	e0bffe17 	ldw	r2,-8(fp)
 322b138:	10c00515 	stw	r3,20(r2)
   *nettask->tk_ptr = (INT8U)nettask->priority;  
 322b13c:	e0bffe17 	ldw	r2,-8(fp)
 322b140:	10c00017 	ldw	r3,0(r2)
 322b144:	e0bffe17 	ldw	r2,-8(fp)
 322b148:	10800317 	ldw	r2,12(r2)
 322b14c:	18800005 	stb	r2,0(r3)

   printf("Created \"%s\" task (Prio: %d)\n",
 322b150:	e0bffe17 	ldw	r2,-8(fp)
 322b154:	11400117 	ldw	r5,4(r2)
 322b158:	e0bffe17 	ldw	r2,-8(fp)
 322b15c:	11800317 	ldw	r6,12(r2)
 322b160:	0100c974 	movhi	r4,805
 322b164:	213cf004 	addi	r4,r4,-3136
 322b168:	3206adc0 	call	3206adc <printf>
         (char *)nettask->name, nettask->priority);

   return (0);
 322b16c:	e03fff15 	stw	zero,-4(fp)
 322b170:	e0bfff17 	ldw	r2,-4(fp)
}
 322b174:	e037883a 	mov	sp,fp
 322b178:	dfc00117 	ldw	ra,4(sp)
 322b17c:	df000017 	ldw	fp,0(sp)
 322b180:	dec00204 	addi	sp,sp,8
 322b184:	f800283a 	ret

0322b188 <wait_app_sem>:
 * event (e.g., configuration inputs from user, initiation of a new session,
 * or a periodic timeout notification.
 */
void
wait_app_sem(unsigned long semid)
{
 322b188:	defffb04 	addi	sp,sp,-20
 322b18c:	dfc00415 	stw	ra,16(sp)
 322b190:	df000315 	stw	fp,12(sp)
 322b194:	df000304 	addi	fp,sp,12
 322b198:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 322b19c:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 322b1a0:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= semid) && (semid <= MAX_SEMID))
 322b1a4:	e0bfff17 	ldw	r2,-4(fp)
 322b1a8:	108001a8 	cmpgeui	r2,r2,6
 322b1ac:	10001d1e 	bne	r2,zero,322b224 <wait_app_sem+0x9c>
   {
      do
      {
         OSSemPend(app_semaphore[semid], 0, &error);
 322b1b0:	e0bfff17 	ldw	r2,-4(fp)
 322b1b4:	00c0c9b4 	movhi	r3,806
 322b1b8:	18f39104 	addi	r3,r3,-12732
 322b1bc:	1085883a 	add	r2,r2,r2
 322b1c0:	1085883a 	add	r2,r2,r2
 322b1c4:	10c5883a 	add	r2,r2,r3
 322b1c8:	11000017 	ldw	r4,0(r2)
 322b1cc:	e1bffe04 	addi	r6,fp,-8
 322b1d0:	000b883a 	mov	r5,zero
 322b1d4:	321ade40 	call	321ade4 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 322b1d8:	e0bffe03 	ldbu	r2,-8(fp)
 322b1dc:	10803fcc 	andi	r2,r2,255
 322b1e0:	10800298 	cmpnei	r2,r2,10
 322b1e4:	10000a1e 	bne	r2,zero,322b210 <wait_app_sem+0x88>
 322b1e8:	e0bffd17 	ldw	r2,-12(fp)
 322b1ec:	10800044 	addi	r2,r2,1
 322b1f0:	e0bffd15 	stw	r2,-12(fp)
 322b1f4:	e0bffd17 	ldw	r2,-12(fp)
 322b1f8:	1080fa50 	cmplti	r2,r2,1001
 322b1fc:	1000041e 	bne	r2,zero,322b210 <wait_app_sem+0x88>
         {
            panic("lock NET");   /* fatal */
 322b200:	0100c974 	movhi	r4,805
 322b204:	213c5d04 	addi	r4,r4,-3724
 322b208:	3225df00 	call	3225df0 <panic>
            return;
 322b20c:	00000606 	br	322b228 <wait_app_sem+0xa0>
         }
      } while (error == 10);
 322b210:	e0bffe03 	ldbu	r2,-8(fp)
 322b214:	10803fcc 	andi	r2,r2,255
 322b218:	108002a0 	cmpeqi	r2,r2,10
 322b21c:	103fe41e 	bne	r2,zero,322b1b0 <wait_app_sem+0x28>
 322b220:	00000106 	br	322b228 <wait_app_sem+0xa0>
   }
   else
      dtrap();
 322b224:	322ab8c0 	call	322ab8c <dtrap>
}
 322b228:	e037883a 	mov	sp,fp
 322b22c:	dfc00117 	ldw	ra,4(sp)
 322b230:	df000017 	ldw	fp,0(sp)
 322b234:	dec00204 	addi	sp,sp,8
 322b238:	f800283a 	ret

0322b23c <post_app_sem>:
 * notification. It signals the corresponding application event.
 */

void
post_app_sem(unsigned long semid)
{
 322b23c:	defffc04 	addi	sp,sp,-16
 322b240:	dfc00315 	stw	ra,12(sp)
 322b244:	df000215 	stw	fp,8(sp)
 322b248:	df000204 	addi	fp,sp,8
 322b24c:	e13fff15 	stw	r4,-4(fp)
   INT8U error;

   if ((0 <= semid) && (semid <= MAX_SEMID))
 322b250:	e0bfff17 	ldw	r2,-4(fp)
 322b254:	108001a8 	cmpgeui	r2,r2,6
 322b258:	1000101e 	bne	r2,zero,322b29c <post_app_sem+0x60>
   {
      error = OSSemPost(app_semaphore[semid]);
 322b25c:	e0bfff17 	ldw	r2,-4(fp)
 322b260:	00c0c9b4 	movhi	r3,806
 322b264:	18f39104 	addi	r3,r3,-12732
 322b268:	1085883a 	add	r2,r2,r2
 322b26c:	1085883a 	add	r2,r2,r2
 322b270:	10c5883a 	add	r2,r2,r3
 322b274:	11000017 	ldw	r4,0(r2)
 322b278:	321b1dc0 	call	321b1dc <OSSemPost>
 322b27c:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 322b280:	e0bffe03 	ldbu	r2,-8(fp)
 322b284:	1005003a 	cmpeq	r2,r2,zero
 322b288:	1000051e 	bne	r2,zero,322b2a0 <post_app_sem+0x64>
      {
         panic("unlock NET");
 322b28c:	0100c974 	movhi	r4,805
 322b290:	213c6004 	addi	r4,r4,-3712
 322b294:	3225df00 	call	3225df0 <panic>
 322b298:	00000106 	br	322b2a0 <post_app_sem+0x64>
      }
   }
   else
      dtrap();
 322b29c:	322ab8c0 	call	322ab8c <dtrap>
}
 322b2a0:	e037883a 	mov	sp,fp
 322b2a4:	dfc00117 	ldw	ra,4(sp)
 322b2a8:	df000017 	ldw	fp,0(sp)
 322b2ac:	dec00204 	addi	sp,sp,8
 322b2b0:	f800283a 	ret

0322b2b4 <alt_iniche_init>:
#ifndef SUPERLOOP

extern OS_EVENT *resid_semaphore[MAX_RESID+1];

void alt_iniche_init(void)
{
 322b2b4:	defffc04 	addi	sp,sp,-16
 322b2b8:	dfc00315 	stw	ra,12(sp)
 322b2bc:	df000215 	stw	fp,8(sp)
 322b2c0:	dc000115 	stw	r16,4(sp)
 322b2c4:	df000104 	addi	fp,sp,4
   int i;

   /* initialize the npalloc() heap semaphore */
   mheap_sem_ptr = OSSemCreate(1);
 322b2c8:	01000044 	movi	r4,1
 322b2cc:	321aa300 	call	321aa30 <OSSemCreate>
 322b2d0:	d0a8e115 	stw	r2,-23676(gp)
   if (!mheap_sem_ptr)
 322b2d4:	d0a8e117 	ldw	r2,-23676(gp)
 322b2d8:	1004c03a 	cmpne	r2,r2,zero
 322b2dc:	1000031e 	bne	r2,zero,322b2ec <alt_iniche_init+0x38>
      panic("mheap_sem_ptr create err"); 
 322b2e0:	0100c974 	movhi	r4,805
 322b2e4:	213cf804 	addi	r4,r4,-3104
 322b2e8:	3225df00 	call	3225df0 <panic>

   rcvdq_sem_ptr = OSSemCreate(0);
 322b2ec:	0009883a 	mov	r4,zero
 322b2f0:	321aa300 	call	321aa30 <OSSemCreate>
 322b2f4:	d0a8e215 	stw	r2,-23672(gp)
   if (!rcvdq_sem_ptr)
 322b2f8:	d0a8e217 	ldw	r2,-23672(gp)
 322b2fc:	1004c03a 	cmpne	r2,r2,zero
 322b300:	1000031e 	bne	r2,zero,322b310 <alt_iniche_init+0x5c>
      panic("rcvdq_sem_ptr create err"); 
 322b304:	0100c974 	movhi	r4,805
 322b308:	213cff04 	addi	r4,r4,-3076
 322b30c:	3225df00 	call	3225df0 <panic>

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 322b310:	e03fff15 	stw	zero,-4(fp)
 322b314:	00001906 	br	322b37c <alt_iniche_init+0xc8>
   {
      resid_semaphore[i] = OSSemCreate(1);
 322b318:	e43fff17 	ldw	r16,-4(fp)
 322b31c:	01000044 	movi	r4,1
 322b320:	321aa300 	call	321aa30 <OSSemCreate>
 322b324:	1009883a 	mov	r4,r2
 322b328:	00c0c9b4 	movhi	r3,806
 322b32c:	18f38104 	addi	r3,r3,-12796
 322b330:	8405883a 	add	r2,r16,r16
 322b334:	1085883a 	add	r2,r2,r2
 322b338:	10c5883a 	add	r2,r2,r3
 322b33c:	11000015 	stw	r4,0(r2)
      if (!resid_semaphore[i])
 322b340:	e0bfff17 	ldw	r2,-4(fp)
 322b344:	00c0c9b4 	movhi	r3,806
 322b348:	18f38104 	addi	r3,r3,-12796
 322b34c:	1085883a 	add	r2,r2,r2
 322b350:	1085883a 	add	r2,r2,r2
 322b354:	10c5883a 	add	r2,r2,r3
 322b358:	10800017 	ldw	r2,0(r2)
 322b35c:	1004c03a 	cmpne	r2,r2,zero
 322b360:	1000031e 	bne	r2,zero,322b370 <alt_iniche_init+0xbc>
         panic("resid_semaphore create err");  
 322b364:	0100c974 	movhi	r4,805
 322b368:	213d0604 	addi	r4,r4,-3048
 322b36c:	3225df00 	call	3225df0 <panic>
   rcvdq_sem_ptr = OSSemCreate(0);
   if (!rcvdq_sem_ptr)
      panic("rcvdq_sem_ptr create err"); 

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 322b370:	e0bfff17 	ldw	r2,-4(fp)
 322b374:	10800044 	addi	r2,r2,1
 322b378:	e0bfff15 	stw	r2,-4(fp)
 322b37c:	e0bfff17 	ldw	r2,-4(fp)
 322b380:	10800410 	cmplti	r2,r2,16
 322b384:	103fe41e 	bne	r2,zero,322b318 <alt_iniche_init+0x64>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 322b388:	e03fff15 	stw	zero,-4(fp)
 322b38c:	00001906 	br	322b3f4 <alt_iniche_init+0x140>
   {
      app_semaphore[i] = OSSemCreate(1);
 322b390:	e43fff17 	ldw	r16,-4(fp)
 322b394:	01000044 	movi	r4,1
 322b398:	321aa300 	call	321aa30 <OSSemCreate>
 322b39c:	1009883a 	mov	r4,r2
 322b3a0:	00c0c9b4 	movhi	r3,806
 322b3a4:	18f39104 	addi	r3,r3,-12732
 322b3a8:	8405883a 	add	r2,r16,r16
 322b3ac:	1085883a 	add	r2,r2,r2
 322b3b0:	10c5883a 	add	r2,r2,r3
 322b3b4:	11000015 	stw	r4,0(r2)
      if (!app_semaphore[i])
 322b3b8:	e0bfff17 	ldw	r2,-4(fp)
 322b3bc:	00c0c9b4 	movhi	r3,806
 322b3c0:	18f39104 	addi	r3,r3,-12732
 322b3c4:	1085883a 	add	r2,r2,r2
 322b3c8:	1085883a 	add	r2,r2,r2
 322b3cc:	10c5883a 	add	r2,r2,r3
 322b3d0:	10800017 	ldw	r2,0(r2)
 322b3d4:	1004c03a 	cmpne	r2,r2,zero
 322b3d8:	1000031e 	bne	r2,zero,322b3e8 <alt_iniche_init+0x134>
         panic("app_semaphore create err");  
 322b3dc:	0100c974 	movhi	r4,805
 322b3e0:	213d0d04 	addi	r4,r4,-3020
 322b3e4:	3225df00 	call	3225df0 <panic>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 322b3e8:	e0bfff17 	ldw	r2,-4(fp)
 322b3ec:	10800044 	addi	r2,r2,1
 322b3f0:	e0bfff15 	stw	r2,-4(fp)
 322b3f4:	e0bfff17 	ldw	r2,-4(fp)
 322b3f8:	10800190 	cmplti	r2,r2,6
 322b3fc:	103fe41e 	bne	r2,zero,322b390 <alt_iniche_init+0xdc>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 322b400:	e03fff15 	stw	zero,-4(fp)
 322b404:	00002606 	br	322b4a0 <alt_iniche_init+0x1ec>
   {
      global_TCPwakeup_set[i].ctick = 0;
 322b408:	e0bfff17 	ldw	r2,-4(fp)
 322b40c:	00c0c9b4 	movhi	r3,806
 322b410:	18f34504 	addi	r3,r3,-13036
 322b414:	10800324 	muli	r2,r2,12
 322b418:	10c5883a 	add	r2,r2,r3
 322b41c:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].soc_event = NULL;
 322b420:	e0bfff17 	ldw	r2,-4(fp)
 322b424:	00c0c9b4 	movhi	r3,806
 322b428:	18f34504 	addi	r3,r3,-13036
 322b42c:	10800324 	muli	r2,r2,12
 322b430:	10c5883a 	add	r2,r2,r3
 322b434:	10800104 	addi	r2,r2,4
 322b438:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
 322b43c:	e43fff17 	ldw	r16,-4(fp)
 322b440:	0009883a 	mov	r4,zero
 322b444:	321aa300 	call	321aa30 <OSSemCreate>
 322b448:	1009883a 	mov	r4,r2
 322b44c:	00c0c9b4 	movhi	r3,806
 322b450:	18f34504 	addi	r3,r3,-13036
 322b454:	80800324 	muli	r2,r16,12
 322b458:	10c5883a 	add	r2,r2,r3
 322b45c:	10800204 	addi	r2,r2,8
 322b460:	11000015 	stw	r4,0(r2)
      if (!global_TCPwakeup_set[i].semaphore)
 322b464:	e0bfff17 	ldw	r2,-4(fp)
 322b468:	00c0c9b4 	movhi	r3,806
 322b46c:	18f34504 	addi	r3,r3,-13036
 322b470:	10800324 	muli	r2,r2,12
 322b474:	10c5883a 	add	r2,r2,r3
 322b478:	10800204 	addi	r2,r2,8
 322b47c:	10800017 	ldw	r2,0(r2)
 322b480:	1004c03a 	cmpne	r2,r2,zero
 322b484:	1000031e 	bne	r2,zero,322b494 <alt_iniche_init+0x1e0>
         panic("globwake_semaphore create err");  
 322b488:	0100c974 	movhi	r4,805
 322b48c:	213d1404 	addi	r4,r4,-2992
 322b490:	3225df00 	call	3225df0 <panic>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 322b494:	e0bfff17 	ldw	r2,-4(fp)
 322b498:	10800044 	addi	r2,r2,1
 322b49c:	e0bfff15 	stw	r2,-4(fp)
 322b4a0:	e0bfff17 	ldw	r2,-4(fp)
 322b4a4:	10800510 	cmplti	r2,r2,20
 322b4a8:	103fd71e 	bne	r2,zero,322b408 <alt_iniche_init+0x154>
      global_TCPwakeup_set[i].soc_event = NULL;
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
      if (!global_TCPwakeup_set[i].semaphore)
         panic("globwake_semaphore create err");  
   }
   global_TCPwakeup_setIndx = 0;
 322b4ac:	0080c974 	movhi	r2,805
 322b4b0:	10925504 	addi	r2,r2,18772
 322b4b4:	10000015 	stw	zero,0(r2)
#endif  /* TCPWAKE_RTOS */
}
 322b4b8:	e037883a 	mov	sp,fp
 322b4bc:	dfc00217 	ldw	ra,8(sp)
 322b4c0:	df000117 	ldw	fp,4(sp)
 322b4c4:	dc000017 	ldw	r16,0(sp)
 322b4c8:	dec00304 	addi	sp,sp,12
 322b4cc:	f800283a 	ret

0322b4d0 <pre_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
pre_task_setup()
{
 322b4d0:	deffff04 	addi	sp,sp,-4
 322b4d4:	df000015 	stw	fp,0(sp)
 322b4d8:	d839883a 	mov	fp,sp
   write_leds(0);
   write_7seg_raw(0x0000);
#endif

   /* preset buffer counts; may be overridden from command line */
   bigbufs = MAXBIGPKTS;
 322b4dc:	00c0c974 	movhi	r3,805
 322b4e0:	18c9ab04 	addi	r3,r3,9900
 322b4e4:	00800784 	movi	r2,30
 322b4e8:	18800015 	stw	r2,0(r3)
   lilbufs = MAXLILPKTS;
 322b4ec:	00c0c974 	movhi	r3,805
 322b4f0:	18c9a904 	addi	r3,r3,9892
 322b4f4:	00800784 	movi	r2,30
 322b4f8:	18800015 	stw	r2,0(r3)
   bigbufsiz = BIGBUFSIZE;
 322b4fc:	00c0c974 	movhi	r3,805
 322b500:	18c9ac04 	addi	r3,r3,9904
 322b504:	00818004 	movi	r2,1536
 322b508:	18800015 	stw	r2,0(r3)
   lilbufsiz = LILBUFSIZE;
 322b50c:	00c0c974 	movhi	r3,805
 322b510:	18c9aa04 	addi	r3,r3,9896
 322b514:	00802004 	movi	r2,128
 322b518:	18800015 	stw	r2,0(r3)

   /* Install callback to prep_armintcp from prep_ifaces() */
   port_prep = prep_armintcp;
 322b51c:	00c0c974 	movhi	r3,805
 322b520:	18d27804 	addi	r3,r3,18912
 322b524:	0080c8f4 	movhi	r2,803
 322b528:	10ad5904 	addi	r2,r2,-19100
 322b52c:	18800015 	stw	r2,0(r3)
#endif   /* NOTDEF */

#endif   /* USE_PPP */


   return NULL;
 322b530:	0005883a 	mov	r2,zero
}
 322b534:	e037883a 	mov	sp,fp
 322b538:	df000017 	ldw	fp,0(sp)
 322b53c:	dec00104 	addi	sp,sp,4
 322b540:	f800283a 	ret

0322b544 <post_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
post_task_setup()
{
 322b544:	deffff04 	addi	sp,sp,-4
 322b548:	df000015 	stw	fp,0(sp)
 322b54c:	d839883a 	mov	fp,sp
   return NULL;
 322b550:	0005883a 	mov	r2,zero
}
 322b554:	e037883a 	mov	sp,fp
 322b558:	df000017 	ldw	fp,0(sp)
 322b55c:	dec00104 	addi	sp,sp,4
 322b560:	f800283a 	ret

0322b564 <prep_armintcp>:

#endif  /* INCLUDE_NVPARMS */

int 
prep_armintcp(int ifaces_found)
{
 322b564:	defffd04 	addi	sp,sp,-12
 322b568:	dfc00215 	stw	ra,8(sp)
 322b56c:	df000115 	stw	fp,4(sp)
 322b570:	df000104 	addi	fp,sp,4
 322b574:	e13fff15 	stw	r4,-4(fp)
 * Call iniche_devices_init, in alt_iniche_dev.c, 
 * to step through all devices and all their respective
 * low-level initialization routines.
 */
#ifdef ALT_INICHE
   ifaces_found = iniche_devices_init(ifaces_found);
 322b578:	e13fff17 	ldw	r4,-4(fp)
 322b57c:	32228300 	call	3222830 <iniche_devices_init>
 322b580:	e0bfff15 	stw	r2,-4(fp)

#ifdef USE_SLIP
   ifaces_found = prep_slip(ifaces_found);
#endif

   return ifaces_found;
 322b584:	e0bfff17 	ldw	r2,-4(fp)
}
 322b588:	e037883a 	mov	sp,fp
 322b58c:	dfc00117 	ldw	ra,4(sp)
 322b590:	df000017 	ldw	fp,0(sp)
 322b594:	dec00204 	addi	sp,sp,8
 322b598:	f800283a 	ret

0322b59c <calloc2>:
 * There is already a function called calloc1() in memio.c,
 * hence use a different function name.
 */
char * 
calloc2(unsigned size)
{
 322b59c:	defffd04 	addi	sp,sp,-12
 322b5a0:	dfc00215 	stw	ra,8(sp)
 322b5a4:	df000115 	stw	fp,4(sp)
 322b5a8:	df000104 	addi	fp,sp,4
 322b5ac:	e13fff15 	stw	r4,-4(fp)
   return (calloc(1,size));
 322b5b0:	01000044 	movi	r4,1
 322b5b4:	e17fff17 	ldw	r5,-4(fp)
 322b5b8:	324b8e00 	call	324b8e0 <calloc>
}
 322b5bc:	e037883a 	mov	sp,fp
 322b5c0:	dfc00117 	ldw	ra,4(sp)
 322b5c4:	df000017 	ldw	fp,0(sp)
 322b5c8:	dec00204 	addi	sp,sp,8
 322b5cc:	f800283a 	ret

0322b5d0 <npalloc>:


char *
npalloc(unsigned size)
{
 322b5d0:	defff904 	addi	sp,sp,-28
 322b5d4:	dfc00615 	stw	ra,24(sp)
 322b5d8:	df000515 	stw	fp,20(sp)
 322b5dc:	df000504 	addi	fp,sp,20
 322b5e0:	e13ffe15 	stw	r4,-8(fp)
#ifdef UCOS_II
   INT8U err;
#endif

#ifdef UCOS_II
   OSSemPend(mheap_sem_ptr, 0, &err);
 322b5e4:	d128e117 	ldw	r4,-23676(gp)
 322b5e8:	e1bffd04 	addi	r6,fp,-12
 322b5ec:	000b883a 	mov	r5,zero
 322b5f0:	321ade40 	call	321ade4 <OSSemPend>
   if(err)
 322b5f4:	e0bffd03 	ldbu	r2,-12(fp)
 322b5f8:	10803fcc 	andi	r2,r2,255
 322b5fc:	1005003a 	cmpeq	r2,r2,zero
 322b600:	1000181e 	bne	r2,zero,322b664 <npalloc+0x94>
   {
      int errct = 0;
 322b604:	e03ffb15 	stw	zero,-20(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 322b608:	00001206 	br	322b654 <npalloc+0x84>
      {
         if(errct++ > 1000)
 322b60c:	e0bffb17 	ldw	r2,-20(fp)
 322b610:	1080fa48 	cmpgei	r2,r2,1001
 322b614:	1007883a 	mov	r3,r2
 322b618:	e0bffb17 	ldw	r2,-20(fp)
 322b61c:	10800044 	addi	r2,r2,1
 322b620:	e0bffb15 	stw	r2,-20(fp)
 322b624:	18803fcc 	andi	r2,r3,255
 322b628:	1005003a 	cmpeq	r2,r2,zero
 322b62c:	1000051e 	bne	r2,zero,322b644 <npalloc+0x74>
         {
            panic("npalloc");    /* fatal? */
 322b630:	0100c974 	movhi	r4,805
 322b634:	213d1c04 	addi	r4,r4,-2960
 322b638:	3225df00 	call	3225df0 <panic>
            return NULL;
 322b63c:	e03fff15 	stw	zero,-4(fp)
 322b640:	00001a06 	br	322b6ac <npalloc+0xdc>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 322b644:	d128e117 	ldw	r4,-23676(gp)
 322b648:	e1bffd04 	addi	r6,fp,-12
 322b64c:	000b883a 	mov	r5,zero
 322b650:	321ade40 	call	321ade4 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 322b654:	e0bffd03 	ldbu	r2,-12(fp)
 322b658:	10803fcc 	andi	r2,r2,255
 322b65c:	108002a0 	cmpeqi	r2,r2,10
 322b660:	103fea1e 	bne	r2,zero,322b60c <npalloc+0x3c>
#endif

#ifdef   MEM_WRAPPERS
   ptr = wrap_alloc(size, calloc2);
#else
   ptr = calloc2(size);
 322b664:	e13ffe17 	ldw	r4,-8(fp)
 322b668:	322b59c0 	call	322b59c <calloc2>
 322b66c:	e0bffc15 	stw	r2,-16(fp)
#endif

#ifdef UCOS_II 
   err = OSSemPost(mheap_sem_ptr);
 322b670:	d128e117 	ldw	r4,-23676(gp)
 322b674:	321b1dc0 	call	321b1dc <OSSemPost>
 322b678:	e0bffd05 	stb	r2,-12(fp)
#endif
   
   if(!ptr)
 322b67c:	e0bffc17 	ldw	r2,-16(fp)
 322b680:	1004c03a 	cmpne	r2,r2,zero
 322b684:	1000021e 	bne	r2,zero,322b690 <npalloc+0xc0>
      return NULL;
 322b688:	e03fff15 	stw	zero,-4(fp)
 322b68c:	00000706 	br	322b6ac <npalloc+0xdc>

   MEMSET(ptr, 0, size);
 322b690:	e0bffc17 	ldw	r2,-16(fp)
 322b694:	1009883a 	mov	r4,r2
 322b698:	e1bffe17 	ldw	r6,-8(fp)
 322b69c:	000b883a 	mov	r5,zero
 322b6a0:	320694c0 	call	320694c <memset>
   return ptr;      
 322b6a4:	e0bffc17 	ldw	r2,-16(fp)
 322b6a8:	e0bfff15 	stw	r2,-4(fp)
 322b6ac:	e0bfff17 	ldw	r2,-4(fp)
}
 322b6b0:	e037883a 	mov	sp,fp
 322b6b4:	dfc00117 	ldw	ra,4(sp)
 322b6b8:	df000017 	ldw	fp,0(sp)
 322b6bc:	dec00204 	addi	sp,sp,8
 322b6c0:	f800283a 	ret

0322b6c4 <npfree>:

void
npfree(void * ptr)
{
 322b6c4:	defffb04 	addi	sp,sp,-20
 322b6c8:	dfc00415 	stw	ra,16(sp)
 322b6cc:	df000315 	stw	fp,12(sp)
 322b6d0:	df000304 	addi	fp,sp,12
 322b6d4:	e13fff15 	stw	r4,-4(fp)
#ifdef UCOS_II
   INT8U err;

   OSSemPend(mheap_sem_ptr, 0, &err);
 322b6d8:	d128e117 	ldw	r4,-23676(gp)
 322b6dc:	e1bffe04 	addi	r6,fp,-8
 322b6e0:	000b883a 	mov	r5,zero
 322b6e4:	321ade40 	call	321ade4 <OSSemPend>
   if (err)
 322b6e8:	e0bffe03 	ldbu	r2,-8(fp)
 322b6ec:	10803fcc 	andi	r2,r2,255
 322b6f0:	1005003a 	cmpeq	r2,r2,zero
 322b6f4:	1000171e 	bne	r2,zero,322b754 <npfree+0x90>
   {
      int errct = 0;
 322b6f8:	e03ffd15 	stw	zero,-12(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 322b6fc:	00001106 	br	322b744 <npfree+0x80>
      {
         if (errct++ > 1000)
 322b700:	e0bffd17 	ldw	r2,-12(fp)
 322b704:	1080fa48 	cmpgei	r2,r2,1001
 322b708:	1007883a 	mov	r3,r2
 322b70c:	e0bffd17 	ldw	r2,-12(fp)
 322b710:	10800044 	addi	r2,r2,1
 322b714:	e0bffd15 	stw	r2,-12(fp)
 322b718:	18803fcc 	andi	r2,r3,255
 322b71c:	1005003a 	cmpeq	r2,r2,zero
 322b720:	1000041e 	bne	r2,zero,322b734 <npfree+0x70>
         {
            panic("npfree");    /* fatal? */
 322b724:	0100c974 	movhi	r4,805
 322b728:	213d1e04 	addi	r4,r4,-2952
 322b72c:	3225df00 	call	3225df0 <panic>
            return;
 322b730:	00000d06 	br	322b768 <npfree+0xa4>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 322b734:	d128e117 	ldw	r4,-23676(gp)
 322b738:	e1bffe04 	addi	r6,fp,-8
 322b73c:	000b883a 	mov	r5,zero
 322b740:	321ade40 	call	321ade4 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 322b744:	e0bffe03 	ldbu	r2,-8(fp)
 322b748:	10803fcc 	andi	r2,r2,255
 322b74c:	108002a0 	cmpeqi	r2,r2,10
 322b750:	103feb1e 	bne	r2,zero,322b700 <npfree+0x3c>
   }
   
#ifdef   MEM_WRAPPERS
   wrap_free((char*)ptr, free);
#else
   free(ptr);
 322b754:	e13fff17 	ldw	r4,-4(fp)
 322b758:	324b9340 	call	324b934 <free>
#endif

   err = OSSemPost(mheap_sem_ptr);
 322b75c:	d128e117 	ldw	r4,-23676(gp)
 322b760:	321b1dc0 	call	321b1dc <OSSemPost>
 322b764:	e0bffe05 	stb	r2,-8(fp)
 */
   free(ptr);
#endif
#endif

}
 322b768:	e037883a 	mov	sp,fp
 322b76c:	dfc00117 	ldw	ra,4(sp)
 322b770:	df000017 	ldw	fp,0(sp)
 322b774:	dec00204 	addi	sp,sp,8
 322b778:	f800283a 	ret

0322b77c <ncpalloc>:
 * contains macro definitions that assign specific memory
 * allocation calls to these routines.
 */
#ifdef ALT_INICHE
char * ncpalloc(unsigned size)
{
 322b77c:	defffc04 	addi	sp,sp,-16
 322b780:	dfc00315 	stw	ra,12(sp)
 322b784:	df000215 	stw	fp,8(sp)
 322b788:	df000204 	addi	fp,sp,8
 322b78c:	e13fff15 	stw	r4,-4(fp)
   char *ptr = npalloc(size);
 322b790:	e13fff17 	ldw	r4,-4(fp)
 322b794:	322b5d00 	call	322b5d0 <npalloc>
 322b798:	e0bffe15 	stw	r2,-8(fp)

   if(ptr) {
 322b79c:	e0bffe17 	ldw	r2,-8(fp)
 322b7a0:	1005003a 	cmpeq	r2,r2,zero
 322b7a4:	1000041e 	bne	r2,zero,322b7b8 <ncpalloc+0x3c>
      ptr = (char *) alt_remap_uncached(ptr, size);
 322b7a8:	e13ffe17 	ldw	r4,-8(fp)
 322b7ac:	e17fff17 	ldw	r5,-4(fp)
 322b7b0:	323ac800 	call	323ac80 <alt_remap_uncached>
 322b7b4:	e0bffe15 	stw	r2,-8(fp)
   }

   return ptr;
 322b7b8:	e0bffe17 	ldw	r2,-8(fp)
}
 322b7bc:	e037883a 	mov	sp,fp
 322b7c0:	dfc00117 	ldw	ra,4(sp)
 322b7c4:	df000017 	ldw	fp,0(sp)
 322b7c8:	dec00204 	addi	sp,sp,8
 322b7cc:	f800283a 	ret

0322b7d0 <ncpfree>:

void ncpfree(void *ptr)
{
 322b7d0:	defffd04 	addi	sp,sp,-12
 322b7d4:	dfc00215 	stw	ra,8(sp)
 322b7d8:	df000115 	stw	fp,4(sp)
 322b7dc:	df000104 	addi	fp,sp,4
 322b7e0:	e13fff15 	stw	r4,-4(fp)
   if(ptr) {
 322b7e4:	e0bfff17 	ldw	r2,-4(fp)
 322b7e8:	1005003a 	cmpeq	r2,r2,zero
 322b7ec:	1000061e 	bne	r2,zero,322b808 <ncpfree+0x38>
      ptr = alt_remap_cached(ptr, sizeof(ptr));
 322b7f0:	e13fff17 	ldw	r4,-4(fp)
 322b7f4:	01400104 	movi	r5,4
 322b7f8:	323ac480 	call	323ac48 <alt_remap_cached>
 322b7fc:	e0bfff15 	stw	r2,-4(fp)
      npfree(ptr);
 322b800:	e13fff17 	ldw	r4,-4(fp)
 322b804:	322b6c40 	call	322b6c4 <npfree>
   }
}
 322b808:	e037883a 	mov	sp,fp
 322b80c:	dfc00117 	ldw	ra,4(sp)
 322b810:	df000017 	ldw	fp,0(sp)
 322b814:	dec00204 	addi	sp,sp,8
 322b818:	f800283a 	ret

0322b81c <pffindtype>:
 * RETURNS: 
 */

struct protosw *  
pffindtype(int domain, int type)
{
 322b81c:	defffb04 	addi	sp,sp,-20
 322b820:	dfc00415 	stw	ra,16(sp)
 322b824:	df000315 	stw	fp,12(sp)
 322b828:	df000304 	addi	fp,sp,12
 322b82c:	e13ffd15 	stw	r4,-12(fp)
 322b830:	e17ffe15 	stw	r5,-8(fp)

   /* check that the passed domain is vaid for the build */
   if (domain != AF_INET)
 322b834:	e0bffd17 	ldw	r2,-12(fp)
 322b838:	108000a0 	cmpeqi	r2,r2,2
 322b83c:	1000031e 	bne	r2,zero,322b84c <pffindtype+0x30>
   {
#ifdef IP_V6
      if(domain != AF_INET6)
#endif
      {
         dtrap();    /* programming error */
 322b840:	322ab8c0 	call	322ab8c <dtrap>
         return NULL;
 322b844:	e03fff15 	stw	zero,-4(fp)
 322b848:	00001606 	br	322b8a4 <pffindtype+0x88>
      }
   }

   if (type == SOCK_STREAM)
 322b84c:	e0bffe17 	ldw	r2,-8(fp)
 322b850:	10800058 	cmpnei	r2,r2,1
 322b854:	1000041e 	bne	r2,zero,322b868 <pffindtype+0x4c>
      return &tcp_protosw;
 322b858:	0080c974 	movhi	r2,805
 322b85c:	10886104 	addi	r2,r2,8580
 322b860:	e0bfff15 	stw	r2,-4(fp)
 322b864:	00000f06 	br	322b8a4 <pffindtype+0x88>
#ifdef UDP_SOCKETS
   else if(type == SOCK_DGRAM)
 322b868:	e0bffe17 	ldw	r2,-8(fp)
 322b86c:	10800098 	cmpnei	r2,r2,2
 322b870:	1000041e 	bne	r2,zero,322b884 <pffindtype+0x68>
      return &udp_protosw;
 322b874:	0080c974 	movhi	r2,805
 322b878:	10886704 	addi	r2,r2,8604
 322b87c:	e0bfff15 	stw	r2,-4(fp)
 322b880:	00000806 	br	322b8a4 <pffindtype+0x88>
#endif   /* UDP_SOCKETS */
#ifdef IP_RAW
   else if(type == SOCK_RAW)
 322b884:	e0bffe17 	ldw	r2,-8(fp)
 322b888:	108000d8 	cmpnei	r2,r2,3
 322b88c:	1000041e 	bne	r2,zero,322b8a0 <pffindtype+0x84>
      return &rawip_protosw;
 322b890:	0080c974 	movhi	r2,805
 322b894:	10886d04 	addi	r2,r2,8628
 322b898:	e0bfff15 	stw	r2,-4(fp)
 322b89c:	00000106 	br	322b8a4 <pffindtype+0x88>
#endif  /* IP_RAW */
   else
      return NULL;
 322b8a0:	e03fff15 	stw	zero,-4(fp)
 322b8a4:	e0bfff17 	ldw	r2,-4(fp)
}
 322b8a8:	e037883a 	mov	sp,fp
 322b8ac:	dfc00117 	ldw	ra,4(sp)
 322b8b0:	df000017 	ldw	fp,0(sp)
 322b8b4:	dec00204 	addi	sp,sp,8
 322b8b8:	f800283a 	ret

0322b8bc <pffindproto>:
 * RETURNS: 
 */

struct protosw *  
pffindproto(int domain, int protocol, int type)
{
 322b8bc:	defff904 	addi	sp,sp,-28
 322b8c0:	dfc00615 	stw	ra,24(sp)
 322b8c4:	df000515 	stw	fp,20(sp)
 322b8c8:	df000504 	addi	fp,sp,20
 322b8cc:	e13ffb15 	stw	r4,-20(fp)
 322b8d0:	e17ffc15 	stw	r5,-16(fp)
 322b8d4:	e1bffd15 	stw	r6,-12(fp)
#ifdef IP_RAW
   if (type == SOCK_RAW)
 322b8d8:	e0bffd17 	ldw	r2,-12(fp)
 322b8dc:	108000d8 	cmpnei	r2,r2,3
 322b8e0:	1000051e 	bne	r2,zero,322b8f8 <pffindproto+0x3c>
      return(pffindtype(domain, type));
 322b8e4:	e13ffb17 	ldw	r4,-20(fp)
 322b8e8:	e17ffd17 	ldw	r5,-12(fp)
 322b8ec:	322b81c0 	call	322b81c <pffindtype>
 322b8f0:	e0bffe15 	stw	r2,-8(fp)
 322b8f4:	00001f06 	br	322b974 <pffindproto+0xb8>
#endif

   switch (protocol)
 322b8f8:	e0bffc17 	ldw	r2,-16(fp)
 322b8fc:	e0bfff15 	stw	r2,-4(fp)
 322b900:	e0ffff17 	ldw	r3,-4(fp)
 322b904:	188001a0 	cmpeqi	r2,r3,6
 322b908:	1000071e 	bne	r2,zero,322b928 <pffindproto+0x6c>
 322b90c:	e0ffff17 	ldw	r3,-4(fp)
 322b910:	18800460 	cmpeqi	r2,r3,17
 322b914:	10000a1e 	bne	r2,zero,322b940 <pffindproto+0x84>
 322b918:	e0ffff17 	ldw	r3,-4(fp)
 322b91c:	1805003a 	cmpeq	r2,r3,zero
 322b920:	1000101e 	bne	r2,zero,322b964 <pffindproto+0xa8>
 322b924:	00000c06 	br	322b958 <pffindproto+0x9c>
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
 322b928:	e0bffd17 	ldw	r2,-12(fp)
 322b92c:	10800060 	cmpeqi	r2,r2,1
 322b930:	10000c1e 	bne	r2,zero,322b964 <pffindproto+0xa8>
         break;
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
 322b934:	322ab8c0 	call	322ab8c <dtrap>
      return NULL;
 322b938:	e03ffe15 	stw	zero,-8(fp)
 322b93c:	00000d06 	br	322b974 <pffindproto+0xb8>
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
 322b940:	e0bffd17 	ldw	r2,-12(fp)
 322b944:	108000a0 	cmpeqi	r2,r2,2
 322b948:	1000061e 	bne	r2,zero,322b964 <pffindproto+0xa8>
         break;
      /* IPPROTO_UDP protocol on non-SOCK_DGRAM type socket */
      dtrap();
 322b94c:	322ab8c0 	call	322ab8c <dtrap>
      return NULL;
 322b950:	e03ffe15 	stw	zero,-8(fp)
 322b954:	00000706 	br	322b974 <pffindproto+0xb8>
   case 0:
      /* let protocol default based on socket type */
      break;
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
 322b958:	322ab8c0 	call	322ab8c <dtrap>
      return NULL;
 322b95c:	e03ffe15 	stw	zero,-8(fp)
 322b960:	00000406 	br	322b974 <pffindproto+0xb8>
   }
   return(pffindtype(domain, type));   /* map to findtype */
 322b964:	e13ffb17 	ldw	r4,-20(fp)
 322b968:	e17ffd17 	ldw	r5,-12(fp)
 322b96c:	322b81c0 	call	322b81c <pffindtype>
 322b970:	e0bffe15 	stw	r2,-8(fp)
 322b974:	e0bffe17 	ldw	r2,-8(fp)
}
 322b978:	e037883a 	mov	sp,fp
 322b97c:	dfc00117 	ldw	ra,4(sp)
 322b980:	df000017 	ldw	fp,0(sp)
 322b984:	dec00204 	addi	sp,sp,8
 322b988:	f800283a 	ret

0322b98c <m_getnbuf>:
 * RETURNS: 
 */

struct mbuf *  
m_getnbuf(int type, int len)
{
 322b98c:	defff904 	addi	sp,sp,-28
 322b990:	dfc00615 	stw	ra,24(sp)
 322b994:	df000515 	stw	fp,20(sp)
 322b998:	df000504 	addi	fp,sp,20
 322b99c:	e13ffd15 	stw	r4,-12(fp)
 322b9a0:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m;
   PACKET pkt = NULL;
 322b9a4:	e03ffb15 	stw	zero,-20(fp)

#ifdef NPDEBUG
   if (type < MT_RXDATA || type > MT_IFADDR)
 322b9a8:	e0bffd17 	ldw	r2,-12(fp)
 322b9ac:	10800050 	cmplti	r2,r2,1
 322b9b0:	1000031e 	bne	r2,zero,322b9c0 <m_getnbuf+0x34>
 322b9b4:	e0bffd17 	ldw	r2,-12(fp)
 322b9b8:	10800390 	cmplti	r2,r2,14
 322b9bc:	1000011e 	bne	r2,zero,322b9c4 <m_getnbuf+0x38>
   {
      dtrap(); /* is this OK? */
 322b9c0:	322ab8c0 	call	322ab8c <dtrap>
   }
#endif

   /* if caller has data (len >= 0), we need to allocate 
    * a packet buffer; else all we need is the mbuf */
   if (len != 0)
 322b9c4:	e0bffe17 	ldw	r2,-8(fp)
 322b9c8:	1005003a 	cmpeq	r2,r2,zero
 322b9cc:	10000e1e 	bne	r2,zero,322ba08 <m_getnbuf+0x7c>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 322b9d0:	01000084 	movi	r4,2
 322b9d4:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pkt = pk_alloc(len + HDRSLEN);
 322b9d8:	e0bffe17 	ldw	r2,-8(fp)
 322b9dc:	10800e04 	addi	r2,r2,56
 322b9e0:	1009883a 	mov	r4,r2
 322b9e4:	3229f480 	call	3229f48 <pk_alloc>
 322b9e8:	e0bffb15 	stw	r2,-20(fp)

      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322b9ec:	01000084 	movi	r4,2
 322b9f0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      if (!pkt)
 322b9f4:	e0bffb17 	ldw	r2,-20(fp)
 322b9f8:	1004c03a 	cmpne	r2,r2,zero
 322b9fc:	1000021e 	bne	r2,zero,322ba08 <m_getnbuf+0x7c>
         return NULL;
 322ba00:	e03fff15 	stw	zero,-4(fp)
 322ba04:	00004506 	br	322bb1c <m_getnbuf+0x190>
   }

   m = (struct mbuf *)getq(&mfreeq);
 322ba08:	0100c9b4 	movhi	r4,806
 322ba0c:	2133b004 	addi	r4,r4,-12608
 322ba10:	322a4540 	call	322a454 <getq>
 322ba14:	e0bffc15 	stw	r2,-16(fp)
   if (!m)
 322ba18:	e0bffc17 	ldw	r2,-16(fp)
 322ba1c:	1004c03a 	cmpne	r2,r2,zero
 322ba20:	10000b1e 	bne	r2,zero,322ba50 <m_getnbuf+0xc4>
   {
      if (pkt) 
 322ba24:	e0bffb17 	ldw	r2,-20(fp)
 322ba28:	1005003a 	cmpeq	r2,r2,zero
 322ba2c:	1000061e 	bne	r2,zero,322ba48 <m_getnbuf+0xbc>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 322ba30:	01000084 	movi	r4,2
 322ba34:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pk_free(pkt);
 322ba38:	e13ffb17 	ldw	r4,-20(fp)
 322ba3c:	322a2dc0 	call	322a2dc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322ba40:	01000084 	movi	r4,2
 322ba44:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      }
      return NULL;
 322ba48:	e03fff15 	stw	zero,-4(fp)
 322ba4c:	00003306 	br	322bb1c <m_getnbuf+0x190>
   }
   m->m_type = type;
 322ba50:	e0fffc17 	ldw	r3,-16(fp)
 322ba54:	e0bffd17 	ldw	r2,-12(fp)
 322ba58:	18800815 	stw	r2,32(r3)
   if (len == 0)
 322ba5c:	e0bffe17 	ldw	r2,-8(fp)
 322ba60:	1004c03a 	cmpne	r2,r2,zero
 322ba64:	1000071e 	bne	r2,zero,322ba84 <m_getnbuf+0xf8>
   {
      m->pkt = NULL;
 322ba68:	e0bffc17 	ldw	r2,-16(fp)
 322ba6c:	10000115 	stw	zero,4(r2)
      m->m_base = NULL;    /* caller better fill these in! */
 322ba70:	e0bffc17 	ldw	r2,-16(fp)
 322ba74:	10000415 	stw	zero,16(r2)
      m->m_memsz = 0;
 322ba78:	e0bffc17 	ldw	r2,-16(fp)
 322ba7c:	10000515 	stw	zero,20(r2)
 322ba80:	00001506 	br	322bad8 <m_getnbuf+0x14c>
   }
   else
   {
      m->pkt = pkt;
 322ba84:	e0fffc17 	ldw	r3,-16(fp)
 322ba88:	e0bffb17 	ldw	r2,-20(fp)
 322ba8c:	18800115 	stw	r2,4(r3)
      /* set m_data to the part where tcp data should go */
      m->m_base = m->m_data = pkt->nb_prot = pkt->nb_buff + HDRSLEN;
 322ba90:	e0bffb17 	ldw	r2,-20(fp)
 322ba94:	10800117 	ldw	r2,4(r2)
 322ba98:	10c00e04 	addi	r3,r2,56
 322ba9c:	e0bffb17 	ldw	r2,-20(fp)
 322baa0:	10c00315 	stw	r3,12(r2)
 322baa4:	e0bffb17 	ldw	r2,-20(fp)
 322baa8:	10c00317 	ldw	r3,12(r2)
 322baac:	e0bffc17 	ldw	r2,-16(fp)
 322bab0:	10c00315 	stw	r3,12(r2)
 322bab4:	e0bffc17 	ldw	r2,-16(fp)
 322bab8:	10c00317 	ldw	r3,12(r2)
 322babc:	e0bffc17 	ldw	r2,-16(fp)
 322bac0:	10c00415 	stw	r3,16(r2)
      m->m_memsz = pkt->nb_blen - HDRSLEN;
 322bac4:	e0bffb17 	ldw	r2,-20(fp)
 322bac8:	10800217 	ldw	r2,8(r2)
 322bacc:	10fff204 	addi	r3,r2,-56
 322bad0:	e0bffc17 	ldw	r2,-16(fp)
 322bad4:	10c00515 	stw	r3,20(r2)
   }
   m->m_len = 0;
 322bad8:	e0bffc17 	ldw	r2,-16(fp)
 322badc:	10000215 	stw	zero,8(r2)
   m->m_next = m->m_act = NULL;
 322bae0:	e0bffc17 	ldw	r2,-16(fp)
 322bae4:	10000715 	stw	zero,28(r2)
 322bae8:	e0bffc17 	ldw	r2,-16(fp)
 322baec:	10c00717 	ldw	r3,28(r2)
 322baf0:	e0bffc17 	ldw	r2,-16(fp)
 322baf4:	10c00615 	stw	r3,24(r2)
   mbstat.allocs++;        /* maintain local statistics */
 322baf8:	d0a8e517 	ldw	r2,-23660(gp)
 322bafc:	10800044 	addi	r2,r2,1
 322bb00:	d0a8e515 	stw	r2,-23660(gp)
   putq(&mbufq, (qp)m);
 322bb04:	e17ffc17 	ldw	r5,-16(fp)
 322bb08:	0100c9b4 	movhi	r4,806
 322bb0c:	2133ab04 	addi	r4,r4,-12628
 322bb10:	322a51c0 	call	322a51c <putq>
   return m;
 322bb14:	e0bffc17 	ldw	r2,-16(fp)
 322bb18:	e0bfff15 	stw	r2,-4(fp)
 322bb1c:	e0bfff17 	ldw	r2,-4(fp)
}
 322bb20:	e037883a 	mov	sp,fp
 322bb24:	dfc00117 	ldw	ra,4(sp)
 322bb28:	df000017 	ldw	fp,0(sp)
 322bb2c:	dec00204 	addi	sp,sp,8
 322bb30:	f800283a 	ret

0322bb34 <m_free>:
 */


struct mbuf *  
m_free(struct mbuf * m)
{
 322bb34:	defffb04 	addi	sp,sp,-20
 322bb38:	dfc00415 	stw	ra,16(sp)
 322bb3c:	df000315 	stw	fp,12(sp)
 322bb40:	df000304 	addi	fp,sp,12
 322bb44:	e13ffe15 	stw	r4,-8(fp)
   struct mbuf *  nextptr;

#ifdef NPDEBUG
   if (mbufq.q_len < 1)
 322bb48:	0080c9b4 	movhi	r2,806
 322bb4c:	10b3ab04 	addi	r2,r2,-12628
 322bb50:	10800217 	ldw	r2,8(r2)
 322bb54:	10800048 	cmpgei	r2,r2,1
 322bb58:	1000031e 	bne	r2,zero,322bb68 <m_free+0x34>
      panic("mfree: q_len");
 322bb5c:	0100c974 	movhi	r4,805
 322bb60:	213d2004 	addi	r4,r4,-2944
 322bb64:	3225df00 	call	3225df0 <panic>

   if (m->m_type < MT_RXDATA || m->m_type > MT_IFADDR)
 322bb68:	e0bffe17 	ldw	r2,-8(fp)
 322bb6c:	10800817 	ldw	r2,32(r2)
 322bb70:	10800050 	cmplti	r2,r2,1
 322bb74:	1000041e 	bne	r2,zero,322bb88 <m_free+0x54>
 322bb78:	e0bffe17 	ldw	r2,-8(fp)
 322bb7c:	10800817 	ldw	r2,32(r2)
 322bb80:	10800390 	cmplti	r2,r2,14
 322bb84:	10000c1e 	bne	r2,zero,322bbb8 <m_free+0x84>
   {
      if (m->m_type == MT_FREE)
 322bb88:	e0bffe17 	ldw	r2,-8(fp)
 322bb8c:	10800817 	ldw	r2,32(r2)
 322bb90:	1004c03a 	cmpne	r2,r2,zero
 322bb94:	1000051e 	bne	r2,zero,322bbac <m_free+0x78>
      {
         dtrap(); /* debug double free of mbuf by tcp_in() */
 322bb98:	322ab8c0 	call	322ab8c <dtrap>
         return m->m_next; /* seems harmless, though.... */
 322bb9c:	e0bffe17 	ldw	r2,-8(fp)
 322bba0:	10800617 	ldw	r2,24(r2)
 322bba4:	e0bfff15 	stw	r2,-4(fp)
 322bba8:	00002906 	br	322bc50 <m_free+0x11c>
      }
      else
         panic("m_free: type");
 322bbac:	0100c974 	movhi	r4,805
 322bbb0:	213d2404 	addi	r4,r4,-2928
 322bbb4:	3225df00 	call	3225df0 <panic>
   }
#endif   /* NPDEBUG */

   nextptr = m->m_next;    /* remember value to return */
 322bbb8:	e0bffe17 	ldw	r2,-8(fp)
 322bbbc:	10800617 	ldw	r2,24(r2)
 322bbc0:	e0bffd15 	stw	r2,-12(fp)

   if (qdel(&mbufq, m) == NULL)
 322bbc4:	0100c9b4 	movhi	r4,806
 322bbc8:	2133ab04 	addi	r4,r4,-12628
 322bbcc:	e17ffe17 	ldw	r5,-8(fp)
 322bbd0:	322a5cc0 	call	322a5cc <qdel>
 322bbd4:	1004c03a 	cmpne	r2,r2,zero
 322bbd8:	1000031e 	bne	r2,zero,322bbe8 <m_free+0xb4>
      panic("m_free: missing");
 322bbdc:	0100c974 	movhi	r4,805
 322bbe0:	213d2804 	addi	r4,r4,-2912
 322bbe4:	3225df00 	call	3225df0 <panic>

   m->m_type = MT_FREE;    /* this may seem silly, but helps error checking */
 322bbe8:	e0bffe17 	ldw	r2,-8(fp)
 322bbec:	10000815 	stw	zero,32(r2)

   if (m->pkt)
 322bbf0:	e0bffe17 	ldw	r2,-8(fp)
 322bbf4:	10800117 	ldw	r2,4(r2)
 322bbf8:	1005003a 	cmpeq	r2,r2,zero
 322bbfc:	1000071e 	bne	r2,zero,322bc1c <m_free+0xe8>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 322bc00:	01000084 	movi	r4,2
 322bc04:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(m->pkt);     /* free up the netport buffer */
 322bc08:	e0bffe17 	ldw	r2,-8(fp)
 322bc0c:	11000117 	ldw	r4,4(r2)
 322bc10:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322bc14:	01000084 	movi	r4,2
 322bc18:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   }
   mbstat.frees++;
 322bc1c:	0080c974 	movhi	r2,805
 322bc20:	10925d04 	addi	r2,r2,18804
 322bc24:	10800017 	ldw	r2,0(r2)
 322bc28:	10c00044 	addi	r3,r2,1
 322bc2c:	0080c974 	movhi	r2,805
 322bc30:	10925d04 	addi	r2,r2,18804
 322bc34:	10c00015 	stw	r3,0(r2)
   putq(&mfreeq, (qp)m);
 322bc38:	e17ffe17 	ldw	r5,-8(fp)
 322bc3c:	0100c9b4 	movhi	r4,806
 322bc40:	2133b004 	addi	r4,r4,-12608
 322bc44:	322a51c0 	call	322a51c <putq>
   return nextptr;
 322bc48:	e0bffd17 	ldw	r2,-12(fp)
 322bc4c:	e0bfff15 	stw	r2,-4(fp)
 322bc50:	e0bfff17 	ldw	r2,-4(fp)
}
 322bc54:	e037883a 	mov	sp,fp
 322bc58:	dfc00117 	ldw	ra,4(sp)
 322bc5c:	df000017 	ldw	fp,0(sp)
 322bc60:	dec00204 	addi	sp,sp,8
 322bc64:	f800283a 	ret

0322bc68 <m_freem>:
 * RETURNS: 
 */

void
m_freem(struct mbuf * m)
{
 322bc68:	defffd04 	addi	sp,sp,-12
 322bc6c:	dfc00215 	stw	ra,8(sp)
 322bc70:	df000115 	stw	fp,4(sp)
 322bc74:	df000104 	addi	fp,sp,4
 322bc78:	e13fff15 	stw	r4,-4(fp)
   while (m != NULL)
 322bc7c:	00000306 	br	322bc8c <m_freem+0x24>
      m = m_free(m);
 322bc80:	e13fff17 	ldw	r4,-4(fp)
 322bc84:	322bb340 	call	322bb34 <m_free>
 322bc88:	e0bfff15 	stw	r2,-4(fp)
 */

void
m_freem(struct mbuf * m)
{
   while (m != NULL)
 322bc8c:	e0bfff17 	ldw	r2,-4(fp)
 322bc90:	1004c03a 	cmpne	r2,r2,zero
 322bc94:	103ffa1e 	bne	r2,zero,322bc80 <m_freem+0x18>
      m = m_free(m);
}
 322bc98:	e037883a 	mov	sp,fp
 322bc9c:	dfc00117 	ldw	ra,4(sp)
 322bca0:	df000017 	ldw	fp,0(sp)
 322bca4:	dec00204 	addi	sp,sp,8
 322bca8:	f800283a 	ret

0322bcac <m_copy>:
 * RETURNS: 
 */

struct mbuf *  
m_copy(struct mbuf * m, int off, int len)
{
 322bcac:	defff404 	addi	sp,sp,-48
 322bcb0:	dfc00b15 	stw	ra,44(sp)
 322bcb4:	df000a15 	stw	fp,40(sp)
 322bcb8:	df000a04 	addi	fp,sp,40
 322bcbc:	e13ffa15 	stw	r4,-24(fp)
 322bcc0:	e17ffb15 	stw	r5,-20(fp)
 322bcc4:	e1bffc15 	stw	r6,-16(fp)
   struct mbuf *  nb, * head, *  tail;
   int   tocopy;

   if (len == 0)  /* nothing to do */
 322bcc8:	e0bffc17 	ldw	r2,-16(fp)
 322bccc:	1004c03a 	cmpne	r2,r2,zero
 322bcd0:	1000021e 	bne	r2,zero,322bcdc <m_copy+0x30>
      return NULL;
 322bcd4:	e03ffd15 	stw	zero,-12(fp)
 322bcd8:	0000b706 	br	322bfb8 <m_copy+0x30c>

#ifdef NPDEBUG
   /* sanity test parms */
   if (off < 0 || (len < 0 && len != M_COPYALL))
 322bcdc:	e0bffb17 	ldw	r2,-20(fp)
 322bce0:	1004803a 	cmplt	r2,r2,zero
 322bce4:	1000061e 	bne	r2,zero,322bd00 <m_copy+0x54>
 322bce8:	e0bffc17 	ldw	r2,-16(fp)
 322bcec:	1004403a 	cmpge	r2,r2,zero
 322bcf0:	1000191e 	bne	r2,zero,322bd58 <m_copy+0xac>
 322bcf4:	e0bffc17 	ldw	r2,-16(fp)
 322bcf8:	10bfffe0 	cmpeqi	r2,r2,-1
 322bcfc:	1000161e 	bne	r2,zero,322bd58 <m_copy+0xac>
   {
      dtrap();
 322bd00:	322ab8c0 	call	322ab8c <dtrap>
      return NULL;
 322bd04:	e03ffd15 	stw	zero,-12(fp)
 322bd08:	0000ab06 	br	322bfb8 <m_copy+0x30c>
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
   {
      if (!m)
 322bd0c:	e0bffa17 	ldw	r2,-24(fp)
 322bd10:	1004c03a 	cmpne	r2,r2,zero
 322bd14:	1000031e 	bne	r2,zero,322bd24 <m_copy+0x78>
      {
         dtrap();
 322bd18:	322ab8c0 	call	322ab8c <dtrap>
         return NULL;
 322bd1c:	e03ffd15 	stw	zero,-12(fp)
 322bd20:	0000a506 	br	322bfb8 <m_copy+0x30c>
      }
      if (off < (int)m->m_len)
 322bd24:	e0bffa17 	ldw	r2,-24(fp)
 322bd28:	10800217 	ldw	r2,8(r2)
 322bd2c:	1007883a 	mov	r3,r2
 322bd30:	e0bffb17 	ldw	r2,-20(fp)
 322bd34:	10c00b16 	blt	r2,r3,322bd64 <m_copy+0xb8>
         break;
      off -= m->m_len;
 322bd38:	e0fffb17 	ldw	r3,-20(fp)
 322bd3c:	e0bffa17 	ldw	r2,-24(fp)
 322bd40:	10800217 	ldw	r2,8(r2)
 322bd44:	1885c83a 	sub	r2,r3,r2
 322bd48:	e0bffb15 	stw	r2,-20(fp)
      m = m->m_next;
 322bd4c:	e0bffa17 	ldw	r2,-24(fp)
 322bd50:	10800617 	ldw	r2,24(r2)
 322bd54:	e0bffa15 	stw	r2,-24(fp)
      return NULL;
   }
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
 322bd58:	e0bffb17 	ldw	r2,-20(fp)
 322bd5c:	10800048 	cmpgei	r2,r2,1
 322bd60:	103fea1e 	bne	r2,zero,322bd0c <m_copy+0x60>
         break;
      off -= m->m_len;
      m = m->m_next;
   }

   head = tail = NULL;
 322bd64:	e03ff715 	stw	zero,-36(fp)
 322bd68:	e0bff717 	ldw	r2,-36(fp)
 322bd6c:	e0bff815 	stw	r2,-32(fp)

   while (len > 0)
 322bd70:	00008806 	br	322bf94 <m_copy+0x2e8>
   {
      if (m == NULL) /* at end of queue? */
 322bd74:	e0bffa17 	ldw	r2,-24(fp)
 322bd78:	1004c03a 	cmpne	r2,r2,zero
 322bd7c:	1000051e 	bne	r2,zero,322bd94 <m_copy+0xe8>
      {
         panic("m_copy: bad len");
 322bd80:	0100c974 	movhi	r4,805
 322bd84:	213d2c04 	addi	r4,r4,-2896
 322bd88:	3225df00 	call	3225df0 <panic>
         return NULL;
 322bd8c:	e03ffd15 	stw	zero,-12(fp)
 322bd90:	00008906 	br	322bfb8 <m_copy+0x30c>
      }
      tocopy = (int)MIN(len, (int)(m->m_len - off));
 322bd94:	e0bffa17 	ldw	r2,-24(fp)
 322bd98:	10c00217 	ldw	r3,8(r2)
 322bd9c:	e0bffb17 	ldw	r2,-20(fp)
 322bda0:	1885c83a 	sub	r2,r3,r2
 322bda4:	e0fffc17 	ldw	r3,-16(fp)
 322bda8:	e0ffff15 	stw	r3,-4(fp)
 322bdac:	e0bffe15 	stw	r2,-8(fp)
 322bdb0:	e0bfff17 	ldw	r2,-4(fp)
 322bdb4:	e0fffe17 	ldw	r3,-8(fp)
 322bdb8:	10c0020e 	bge	r2,r3,322bdc4 <m_copy+0x118>
 322bdbc:	e0bfff17 	ldw	r2,-4(fp)
 322bdc0:	e0bffe15 	stw	r2,-8(fp)
 322bdc4:	e0fffe17 	ldw	r3,-8(fp)
 322bdc8:	e0fff615 	stw	r3,-40(fp)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 322bdcc:	e0bffb17 	ldw	r2,-20(fp)
 322bdd0:	108000cc 	andi	r2,r2,3
 322bdd4:	1004c03a 	cmpne	r2,r2,zero
 322bdd8:	1000051e 	bne	r2,zero,322bdf0 <m_copy+0x144>
 322bddc:	e0bffa17 	ldw	r2,-24(fp)
 322bde0:	10800117 	ldw	r2,4(r2)
 322bde4:	10800917 	ldw	r2,36(r2)
 322bde8:	10800060 	cmpeqi	r2,r2,1
 322bdec:	1000251e 	bne	r2,zero,322be84 <m_copy+0x1d8>
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
 322bdf0:	e0bffa17 	ldw	r2,-24(fp)
 322bdf4:	11000817 	ldw	r4,32(r2)
 322bdf8:	e17ff617 	ldw	r5,-40(fp)
 322bdfc:	322b98c0 	call	322b98c <m_getnbuf>
 322be00:	e0bff915 	stw	r2,-28(fp)
 322be04:	e0bff917 	ldw	r2,-28(fp)
 322be08:	1005003a 	cmpeq	r2,r2,zero
 322be0c:	1000671e 	bne	r2,zero,322bfac <m_copy+0x300>
            goto nospace;
         MEMCPY(nb->m_data, m->m_data+off, tocopy);
 322be10:	e0bff917 	ldw	r2,-28(fp)
 322be14:	11000317 	ldw	r4,12(r2)
 322be18:	e0bffa17 	ldw	r2,-24(fp)
 322be1c:	10c00317 	ldw	r3,12(r2)
 322be20:	e0bffb17 	ldw	r2,-20(fp)
 322be24:	1885883a 	add	r2,r3,r2
 322be28:	e0fff617 	ldw	r3,-40(fp)
 322be2c:	100b883a 	mov	r5,r2
 322be30:	180d883a 	mov	r6,r3
 322be34:	32067cc0 	call	32067cc <memcpy>
         nb->m_len = tocopy;  /* set length of data we just moved into new mbuf */
 322be38:	e0fff617 	ldw	r3,-40(fp)
 322be3c:	e0bff917 	ldw	r2,-28(fp)
 322be40:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mcopies++;
 322be44:	0080c9b4 	movhi	r2,806
 322be48:	10b3ca04 	addi	r2,r2,-12504
 322be4c:	10802e17 	ldw	r2,184(r2)
 322be50:	10c00044 	addi	r3,r2,1
 322be54:	0080c9b4 	movhi	r2,806
 322be58:	10b3ca04 	addi	r2,r2,-12504
 322be5c:	10c02e15 	stw	r3,184(r2)
         tcpstat.tcps_mcopiedbytes += tocopy;
 322be60:	0080c9b4 	movhi	r2,806
 322be64:	10b3ca04 	addi	r2,r2,-12504
 322be68:	10c03017 	ldw	r3,192(r2)
 322be6c:	e0bff617 	ldw	r2,-40(fp)
 322be70:	1887883a 	add	r3,r3,r2
 322be74:	0080c9b4 	movhi	r2,806
 322be78:	10b3ca04 	addi	r2,r2,-12504
 322be7c:	10c03015 	stw	r3,192(r2)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 322be80:	00003106 	br	322bf48 <m_copy+0x29c>
      {
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
 322be84:	e0bffa17 	ldw	r2,-24(fp)
 322be88:	11000817 	ldw	r4,32(r2)
 322be8c:	000b883a 	mov	r5,zero
 322be90:	322b98c0 	call	322b98c <m_getnbuf>
 322be94:	e0bff915 	stw	r2,-28(fp)
 322be98:	e0bff917 	ldw	r2,-28(fp)
 322be9c:	1005003a 	cmpeq	r2,r2,zero
 322bea0:	1000421e 	bne	r2,zero,322bfac <m_copy+0x300>
            goto nospace;

         m->pkt->inuse++;     /* bump pkt use count to clone it */
 322bea4:	e0bffa17 	ldw	r2,-24(fp)
 322bea8:	10c00117 	ldw	r3,4(r2)
 322beac:	18800917 	ldw	r2,36(r3)
 322beb0:	10800044 	addi	r2,r2,1
 322beb4:	18800915 	stw	r2,36(r3)

         /* set up new mbuf with pointers to cloned packet */
         nb->pkt = m->pkt;
 322beb8:	e0bffa17 	ldw	r2,-24(fp)
 322bebc:	10c00117 	ldw	r3,4(r2)
 322bec0:	e0bff917 	ldw	r2,-28(fp)
 322bec4:	10c00115 	stw	r3,4(r2)
         nb->m_base = m->m_base;
 322bec8:	e0bffa17 	ldw	r2,-24(fp)
 322becc:	10c00417 	ldw	r3,16(r2)
 322bed0:	e0bff917 	ldw	r2,-28(fp)
 322bed4:	10c00415 	stw	r3,16(r2)
         nb->m_memsz = m->m_memsz;
 322bed8:	e0bffa17 	ldw	r2,-24(fp)
 322bedc:	10c00517 	ldw	r3,20(r2)
 322bee0:	e0bff917 	ldw	r2,-28(fp)
 322bee4:	10c00515 	stw	r3,20(r2)
         nb->m_data = m->m_data + off;
 322bee8:	e0bffa17 	ldw	r2,-24(fp)
 322beec:	10c00317 	ldw	r3,12(r2)
 322bef0:	e0bffb17 	ldw	r2,-20(fp)
 322bef4:	1887883a 	add	r3,r3,r2
 322bef8:	e0bff917 	ldw	r2,-28(fp)
 322befc:	10c00315 	stw	r3,12(r2)
         nb->m_len = tocopy;
 322bf00:	e0fff617 	ldw	r3,-40(fp)
 322bf04:	e0bff917 	ldw	r2,-28(fp)
 322bf08:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mclones++;
 322bf0c:	0080c9b4 	movhi	r2,806
 322bf10:	10b3ca04 	addi	r2,r2,-12504
 322bf14:	10802f17 	ldw	r2,188(r2)
 322bf18:	10c00044 	addi	r3,r2,1
 322bf1c:	0080c9b4 	movhi	r2,806
 322bf20:	10b3ca04 	addi	r2,r2,-12504
 322bf24:	10c02f15 	stw	r3,188(r2)
         tcpstat.tcps_mclonedbytes += tocopy;
 322bf28:	0080c9b4 	movhi	r2,806
 322bf2c:	10b3ca04 	addi	r2,r2,-12504
 322bf30:	10c03117 	ldw	r3,196(r2)
 322bf34:	e0bff617 	ldw	r2,-40(fp)
 322bf38:	1887883a 	add	r3,r3,r2
 322bf3c:	0080c9b4 	movhi	r2,806
 322bf40:	10b3ca04 	addi	r2,r2,-12504
 322bf44:	10c03115 	stw	r3,196(r2)
      }

      len -= tocopy;
 322bf48:	e0fffc17 	ldw	r3,-16(fp)
 322bf4c:	e0bff617 	ldw	r2,-40(fp)
 322bf50:	1885c83a 	sub	r2,r3,r2
 322bf54:	e0bffc15 	stw	r2,-16(fp)
      off = 0;
 322bf58:	e03ffb15 	stw	zero,-20(fp)
      if (tail)      /* head & tail are set by first pass thru loop */
 322bf5c:	e0bff717 	ldw	r2,-36(fp)
 322bf60:	1005003a 	cmpeq	r2,r2,zero
 322bf64:	1000041e 	bne	r2,zero,322bf78 <m_copy+0x2cc>
         tail->m_next = nb;
 322bf68:	e0fff717 	ldw	r3,-36(fp)
 322bf6c:	e0bff917 	ldw	r2,-28(fp)
 322bf70:	18800615 	stw	r2,24(r3)
 322bf74:	00000206 	br	322bf80 <m_copy+0x2d4>
      else
         head = nb;
 322bf78:	e0bff917 	ldw	r2,-28(fp)
 322bf7c:	e0bff815 	stw	r2,-32(fp)
      tail = nb;     /* always make new mbuf the tail */
 322bf80:	e0bff917 	ldw	r2,-28(fp)
 322bf84:	e0bff715 	stw	r2,-36(fp)
      m = m->m_next;
 322bf88:	e0bffa17 	ldw	r2,-24(fp)
 322bf8c:	10800617 	ldw	r2,24(r2)
 322bf90:	e0bffa15 	stw	r2,-24(fp)
      m = m->m_next;
   }

   head = tail = NULL;

   while (len > 0)
 322bf94:	e0bffc17 	ldw	r2,-16(fp)
 322bf98:	10800048 	cmpgei	r2,r2,1
 322bf9c:	103f751e 	bne	r2,zero,322bd74 <m_copy+0xc8>
      tail = nb;     /* always make new mbuf the tail */
      m = m->m_next;

   }

   return head;
 322bfa0:	e0bff817 	ldw	r2,-32(fp)
 322bfa4:	e0bffd15 	stw	r2,-12(fp)
 322bfa8:	00000306 	br	322bfb8 <m_copy+0x30c>

nospace:
   m_freem (head);
 322bfac:	e13ff817 	ldw	r4,-32(fp)
 322bfb0:	322bc680 	call	322bc68 <m_freem>
   return NULL;
 322bfb4:	e03ffd15 	stw	zero,-12(fp)
 322bfb8:	e0bffd17 	ldw	r2,-12(fp)
}
 322bfbc:	e037883a 	mov	sp,fp
 322bfc0:	dfc00117 	ldw	ra,4(sp)
 322bfc4:	df000017 	ldw	fp,0(sp)
 322bfc8:	dec00204 	addi	sp,sp,8
 322bfcc:	f800283a 	ret

0322bfd0 <m_adj>:
 * RETURNS: 
 */

void
m_adj(struct mbuf * mp, int len)
{
 322bfd0:	defffb04 	addi	sp,sp,-20
 322bfd4:	df000415 	stw	fp,16(sp)
 322bfd8:	df000404 	addi	fp,sp,16
 322bfdc:	e13ffe15 	stw	r4,-8(fp)
 322bfe0:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
 322bfe4:	e0bffe17 	ldw	r2,-8(fp)
 322bfe8:	e0bffd15 	stw	r2,-12(fp)
 322bfec:	e0bffd17 	ldw	r2,-12(fp)
 322bff0:	1005003a 	cmpeq	r2,r2,zero
 322bff4:	1000661e 	bne	r2,zero,322c190 <m_adj+0x1c0>
      return;

   if (len >= 0) 
 322bff8:	e0bfff17 	ldw	r2,-4(fp)
 322bffc:	1004803a 	cmplt	r2,r2,zero
 322c000:	1000241e 	bne	r2,zero,322c094 <m_adj+0xc4>
   {
      while (m != NULL && len > 0) 
 322c004:	00001c06 	br	322c078 <m_adj+0xa8>
      {
         if (m->m_len <= (unsigned)len)
 322c008:	e0bffd17 	ldw	r2,-12(fp)
 322c00c:	10c00217 	ldw	r3,8(r2)
 322c010:	e0bfff17 	ldw	r2,-4(fp)
 322c014:	10c00b36 	bltu	r2,r3,322c044 <m_adj+0x74>
         {
            len -= m->m_len;
 322c018:	e0ffff17 	ldw	r3,-4(fp)
 322c01c:	e0bffd17 	ldw	r2,-12(fp)
 322c020:	10800217 	ldw	r2,8(r2)
 322c024:	1885c83a 	sub	r2,r3,r2
 322c028:	e0bfff15 	stw	r2,-4(fp)
            m->m_len = 0;
 322c02c:	e0bffd17 	ldw	r2,-12(fp)
 322c030:	10000215 	stw	zero,8(r2)
            m = m->m_next;
 322c034:	e0bffd17 	ldw	r2,-12(fp)
 322c038:	10800617 	ldw	r2,24(r2)
 322c03c:	e0bffd15 	stw	r2,-12(fp)
 322c040:	00000d06 	br	322c078 <m_adj+0xa8>
         }
         else
         {
            m->m_len -= len;
 322c044:	e0bffd17 	ldw	r2,-12(fp)
 322c048:	10c00217 	ldw	r3,8(r2)
 322c04c:	e0bfff17 	ldw	r2,-4(fp)
 322c050:	1887c83a 	sub	r3,r3,r2
 322c054:	e0bffd17 	ldw	r2,-12(fp)
 322c058:	10c00215 	stw	r3,8(r2)
            m->m_data += len;
 322c05c:	e0bffd17 	ldw	r2,-12(fp)
 322c060:	10c00317 	ldw	r3,12(r2)
 322c064:	e0bfff17 	ldw	r2,-4(fp)
 322c068:	1887883a 	add	r3,r3,r2
 322c06c:	e0bffd17 	ldw	r2,-12(fp)
 322c070:	10c00315 	stw	r3,12(r2)
            break;
 322c074:	00004606 	br	322c190 <m_adj+0x1c0>
   if ((m = mp) == NULL)
      return;

   if (len >= 0) 
   {
      while (m != NULL && len > 0) 
 322c078:	e0bffd17 	ldw	r2,-12(fp)
 322c07c:	1005003a 	cmpeq	r2,r2,zero
 322c080:	1000431e 	bne	r2,zero,322c190 <m_adj+0x1c0>
 322c084:	e0bfff17 	ldw	r2,-4(fp)
 322c088:	10800048 	cmpgei	r2,r2,1
 322c08c:	103fde1e 	bne	r2,zero,322c008 <m_adj+0x38>
 322c090:	00003f06 	br	322c190 <m_adj+0x1c0>
       * calculating its length and finding the last mbuf.
       * If the adjustment only affects this mbuf, then just
       * adjust and return.  Otherwise, rescan and truncate
       * after the remaining size.
       */
      len = -len;
 322c094:	e0bfff17 	ldw	r2,-4(fp)
 322c098:	0085c83a 	sub	r2,zero,r2
 322c09c:	e0bfff15 	stw	r2,-4(fp)
      count = 0;
 322c0a0:	e03ffc15 	stw	zero,-16(fp)
      for (;;) 
      {
         count += m->m_len;
 322c0a4:	e0bffd17 	ldw	r2,-12(fp)
 322c0a8:	10c00217 	ldw	r3,8(r2)
 322c0ac:	e0bffc17 	ldw	r2,-16(fp)
 322c0b0:	1885883a 	add	r2,r3,r2
 322c0b4:	e0bffc15 	stw	r2,-16(fp)
         if (m->m_next == (struct mbuf *)0)
 322c0b8:	e0bffd17 	ldw	r2,-12(fp)
 322c0bc:	10800617 	ldw	r2,24(r2)
 322c0c0:	1005003a 	cmpeq	r2,r2,zero
 322c0c4:	1000041e 	bne	r2,zero,322c0d8 <m_adj+0x108>
            break;
         m = m->m_next;
 322c0c8:	e0bffd17 	ldw	r2,-12(fp)
 322c0cc:	10800617 	ldw	r2,24(r2)
 322c0d0:	e0bffd15 	stw	r2,-12(fp)
      }
 322c0d4:	003ff306 	br	322c0a4 <m_adj+0xd4>
      if (m->m_len >= (unsigned)len)
 322c0d8:	e0bffd17 	ldw	r2,-12(fp)
 322c0dc:	10c00217 	ldw	r3,8(r2)
 322c0e0:	e0bfff17 	ldw	r2,-4(fp)
 322c0e4:	18800736 	bltu	r3,r2,322c104 <m_adj+0x134>
      {
         m->m_len -= len;
 322c0e8:	e0bffd17 	ldw	r2,-12(fp)
 322c0ec:	10c00217 	ldw	r3,8(r2)
 322c0f0:	e0bfff17 	ldw	r2,-4(fp)
 322c0f4:	1887c83a 	sub	r3,r3,r2
 322c0f8:	e0bffd17 	ldw	r2,-12(fp)
 322c0fc:	10c00215 	stw	r3,8(r2)
         return;
 322c100:	00002306 	br	322c190 <m_adj+0x1c0>
      }
      count -= len;
 322c104:	e0fffc17 	ldw	r3,-16(fp)
 322c108:	e0bfff17 	ldw	r2,-4(fp)
 322c10c:	1885c83a 	sub	r2,r3,r2
 322c110:	e0bffc15 	stw	r2,-16(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 322c114:	e0bffe17 	ldw	r2,-8(fp)
 322c118:	e0bffd15 	stw	r2,-12(fp)
 322c11c:	00001006 	br	322c160 <m_adj+0x190>
      {
         if (m->m_len >= (unsigned)count)
 322c120:	e0bffd17 	ldw	r2,-12(fp)
 322c124:	10c00217 	ldw	r3,8(r2)
 322c128:	e0bffc17 	ldw	r2,-16(fp)
 322c12c:	18800436 	bltu	r3,r2,322c140 <m_adj+0x170>
         {
            m->m_len = count;
 322c130:	e0fffc17 	ldw	r3,-16(fp)
 322c134:	e0bffd17 	ldw	r2,-12(fp)
 322c138:	10c00215 	stw	r3,8(r2)
            break;
 322c13c:	00000e06 	br	322c178 <m_adj+0x1a8>
         }
         count -= m->m_len;
 322c140:	e0fffc17 	ldw	r3,-16(fp)
 322c144:	e0bffd17 	ldw	r2,-12(fp)
 322c148:	10800217 	ldw	r2,8(r2)
 322c14c:	1885c83a 	sub	r2,r3,r2
 322c150:	e0bffc15 	stw	r2,-16(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 322c154:	e0bffd17 	ldw	r2,-12(fp)
 322c158:	10800617 	ldw	r2,24(r2)
 322c15c:	e0bffd15 	stw	r2,-12(fp)
 322c160:	e0bffd17 	ldw	r2,-12(fp)
 322c164:	1004c03a 	cmpne	r2,r2,zero
 322c168:	103fed1e 	bne	r2,zero,322c120 <m_adj+0x150>
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 322c16c:	00000206 	br	322c178 <m_adj+0x1a8>
         m->m_len = 0;
 322c170:	e0bffd17 	ldw	r2,-12(fp)
 322c174:	10000215 	stw	zero,8(r2)
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 322c178:	e0bffd17 	ldw	r2,-12(fp)
 322c17c:	10800617 	ldw	r2,24(r2)
 322c180:	e0bffd15 	stw	r2,-12(fp)
 322c184:	e0bffd17 	ldw	r2,-12(fp)
 322c188:	1004c03a 	cmpne	r2,r2,zero
 322c18c:	103ff81e 	bne	r2,zero,322c170 <m_adj+0x1a0>
         m->m_len = 0;
   }
}
 322c190:	e037883a 	mov	sp,fp
 322c194:	df000017 	ldw	fp,0(sp)
 322c198:	dec00104 	addi	sp,sp,4
 322c19c:	f800283a 	ret

0322c1a0 <mbuf_len>:
 * RETURNS: 
 */

int
mbuf_len (struct mbuf * m)
{
 322c1a0:	defffd04 	addi	sp,sp,-12
 322c1a4:	df000215 	stw	fp,8(sp)
 322c1a8:	df000204 	addi	fp,sp,8
 322c1ac:	e13fff15 	stw	r4,-4(fp)
   int   len   =  0;
 322c1b0:	e03ffe15 	stw	zero,-8(fp)

   while (m)
 322c1b4:	00000806 	br	322c1d8 <mbuf_len+0x38>
   {
      len += m->m_len;
 322c1b8:	e0bfff17 	ldw	r2,-4(fp)
 322c1bc:	10c00217 	ldw	r3,8(r2)
 322c1c0:	e0bffe17 	ldw	r2,-8(fp)
 322c1c4:	1885883a 	add	r2,r3,r2
 322c1c8:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 322c1cc:	e0bfff17 	ldw	r2,-4(fp)
 322c1d0:	10800617 	ldw	r2,24(r2)
 322c1d4:	e0bfff15 	stw	r2,-4(fp)
int
mbuf_len (struct mbuf * m)
{
   int   len   =  0;

   while (m)
 322c1d8:	e0bfff17 	ldw	r2,-4(fp)
 322c1dc:	1004c03a 	cmpne	r2,r2,zero
 322c1e0:	103ff51e 	bne	r2,zero,322c1b8 <mbuf_len+0x18>
   {
      len += m->m_len;
      m = m->m_next;
   }
   return len;
 322c1e4:	e0bffe17 	ldw	r2,-8(fp)
}
 322c1e8:	e037883a 	mov	sp,fp
 322c1ec:	df000017 	ldw	fp,0(sp)
 322c1f0:	dec00104 	addi	sp,sp,4
 322c1f4:	f800283a 	ret

0322c1f8 <dtom>:
 * RETURNS: 
 */

struct mbuf *  
dtom(void * data)
{
 322c1f8:	defffa04 	addi	sp,sp,-24
 322c1fc:	dfc00515 	stw	ra,20(sp)
 322c200:	df000415 	stw	fp,16(sp)
 322c204:	df000404 	addi	fp,sp,16
 322c208:	e13ffe15 	stw	r4,-8(fp)
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 322c20c:	0080c9b4 	movhi	r2,806
 322c210:	10b3ab04 	addi	r2,r2,-12628
 322c214:	10800017 	ldw	r2,0(r2)
 322c218:	e0bffd15 	stw	r2,-12(fp)
 322c21c:	00001306 	br	322c26c <dtom+0x74>
   {
      m = (struct mbuf *)qptr;
 322c220:	e0bffd17 	ldw	r2,-12(fp)
 322c224:	e0bffc15 	stw	r2,-16(fp)

      if (IN_RANGE(m->m_base, m->m_memsz, (char*)data))
 322c228:	e0bffc17 	ldw	r2,-16(fp)
 322c22c:	10c00417 	ldw	r3,16(r2)
 322c230:	e0bffe17 	ldw	r2,-8(fp)
 322c234:	10c00a36 	bltu	r2,r3,322c260 <dtom+0x68>
 322c238:	e0bffc17 	ldw	r2,-16(fp)
 322c23c:	10c00417 	ldw	r3,16(r2)
 322c240:	e0bffc17 	ldw	r2,-16(fp)
 322c244:	10800517 	ldw	r2,20(r2)
 322c248:	1887883a 	add	r3,r3,r2
 322c24c:	e0bffe17 	ldw	r2,-8(fp)
 322c250:	10c0032e 	bgeu	r2,r3,322c260 <dtom+0x68>
         return (struct mbuf *)qptr;
 322c254:	e0bffd17 	ldw	r2,-12(fp)
 322c258:	e0bfff15 	stw	r2,-4(fp)
 322c25c:	00000a06 	br	322c288 <dtom+0x90>
dtom(void * data)
{
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 322c260:	e0bffd17 	ldw	r2,-12(fp)
 322c264:	10800017 	ldw	r2,0(r2)
 322c268:	e0bffd15 	stw	r2,-12(fp)
 322c26c:	e0bffd17 	ldw	r2,-12(fp)
 322c270:	1004c03a 	cmpne	r2,r2,zero
 322c274:	103fea1e 	bne	r2,zero,322c220 <dtom+0x28>
      else
         continue;

   }

   panic("dtom");    /* data not found in any "in use" mbuf */
 322c278:	0100c974 	movhi	r4,805
 322c27c:	213d3004 	addi	r4,r4,-2880
 322c280:	3225df00 	call	3225df0 <panic>
   return NULL;
 322c284:	e03fff15 	stw	zero,-4(fp)
 322c288:	e0bfff17 	ldw	r2,-4(fp)
}
 322c28c:	e037883a 	mov	sp,fp
 322c290:	dfc00117 	ldw	ra,4(sp)
 322c294:	df000017 	ldw	fp,0(sp)
 322c298:	dec00204 	addi	sp,sp,8
 322c29c:	f800283a 	ret

0322c2a0 <remque>:
};


void
remque (void * arg)
{
 322c2a0:	defffd04 	addi	sp,sp,-12
 322c2a4:	df000215 	stw	fp,8(sp)
 322c2a8:	df000204 	addi	fp,sp,8
 322c2ac:	e13fff15 	stw	r4,-4(fp)
   struct bsdq *  old;

   old = (struct bsdq *)arg;
 322c2b0:	e0bfff17 	ldw	r2,-4(fp)
 322c2b4:	e0bffe15 	stw	r2,-8(fp)
   if (!old->prev) return;
 322c2b8:	e0bffe17 	ldw	r2,-8(fp)
 322c2bc:	10800117 	ldw	r2,4(r2)
 322c2c0:	1005003a 	cmpeq	r2,r2,zero
 322c2c4:	10000e1e 	bne	r2,zero,322c300 <remque+0x60>
      old->prev->next = old->next;
 322c2c8:	e0bffe17 	ldw	r2,-8(fp)
 322c2cc:	10c00117 	ldw	r3,4(r2)
 322c2d0:	e0bffe17 	ldw	r2,-8(fp)
 322c2d4:	10800017 	ldw	r2,0(r2)
 322c2d8:	18800015 	stw	r2,0(r3)
   if (old->next)
 322c2dc:	e0bffe17 	ldw	r2,-8(fp)
 322c2e0:	10800017 	ldw	r2,0(r2)
 322c2e4:	1005003a 	cmpeq	r2,r2,zero
 322c2e8:	1000051e 	bne	r2,zero,322c300 <remque+0x60>
      old->next->prev = old->prev;
 322c2ec:	e0bffe17 	ldw	r2,-8(fp)
 322c2f0:	10c00017 	ldw	r3,0(r2)
 322c2f4:	e0bffe17 	ldw	r2,-8(fp)
 322c2f8:	10800117 	ldw	r2,4(r2)
 322c2fc:	18800115 	stw	r2,4(r3)
}
 322c300:	e037883a 	mov	sp,fp
 322c304:	df000017 	ldw	fp,0(sp)
 322c308:	dec00104 	addi	sp,sp,4
 322c30c:	f800283a 	ret

0322c310 <insque>:
 * RETURNS: 
 */

void
insque(void * n, void * p)
{
 322c310:	defffb04 	addi	sp,sp,-20
 322c314:	df000415 	stw	fp,16(sp)
 322c318:	df000404 	addi	fp,sp,16
 322c31c:	e13ffe15 	stw	r4,-8(fp)
 322c320:	e17fff15 	stw	r5,-4(fp)
   struct bsdq *  newe, *  prev;

   newe = (struct bsdq *)n;
 322c324:	e0bffe17 	ldw	r2,-8(fp)
 322c328:	e0bffd15 	stw	r2,-12(fp)
   prev = (struct bsdq *)p;
 322c32c:	e0bfff17 	ldw	r2,-4(fp)
 322c330:	e0bffc15 	stw	r2,-16(fp)
   newe->next = prev->next;
 322c334:	e0bffc17 	ldw	r2,-16(fp)
 322c338:	10c00017 	ldw	r3,0(r2)
 322c33c:	e0bffd17 	ldw	r2,-12(fp)
 322c340:	10c00015 	stw	r3,0(r2)
   newe->prev = prev;
 322c344:	e0fffd17 	ldw	r3,-12(fp)
 322c348:	e0bffc17 	ldw	r2,-16(fp)
 322c34c:	18800115 	stw	r2,4(r3)
   prev->next = newe;
 322c350:	e0fffc17 	ldw	r3,-16(fp)
 322c354:	e0bffd17 	ldw	r2,-12(fp)
 322c358:	18800015 	stw	r2,0(r3)
   if (newe->next)
 322c35c:	e0bffd17 	ldw	r2,-12(fp)
 322c360:	10800017 	ldw	r2,0(r2)
 322c364:	1005003a 	cmpeq	r2,r2,zero
 322c368:	1000041e 	bne	r2,zero,322c37c <insque+0x6c>
      newe->next->prev = newe;
 322c36c:	e0bffd17 	ldw	r2,-12(fp)
 322c370:	10c00017 	ldw	r3,0(r2)
 322c374:	e0bffd17 	ldw	r2,-12(fp)
 322c378:	18800115 	stw	r2,4(r3)
}
 322c37c:	e037883a 	mov	sp,fp
 322c380:	df000017 	ldw	fp,0(sp)
 322c384:	dec00104 	addi	sp,sp,4
 322c388:	f800283a 	ret

0322c38c <nptcp_init>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
nptcp_init()
{
 322c38c:	defffb04 	addi	sp,sp,-20
 322c390:	dfc00415 	stw	ra,16(sp)
 322c394:	df000315 	stw	fp,12(sp)
 322c398:	df000304 	addi	fp,sp,12
    * buffers, soreceive() can't complete and the packet buffers stay 
    * on the queue, so we allocate 3 extra mbufs in the hope that 
    * this will allow soreceive() to complete and free up the packet 
    * buffers. yes, its kind of an ugly hack and 3 is a wild guess.
    */
   unsigned bufcount = (lilbufs + bigbufs) * 2 + 3;
 322c39c:	0080c974 	movhi	r2,805
 322c3a0:	1089a904 	addi	r2,r2,9892
 322c3a4:	10c00017 	ldw	r3,0(r2)
 322c3a8:	0080c974 	movhi	r2,805
 322c3ac:	1089ab04 	addi	r2,r2,9900
 322c3b0:	10800017 	ldw	r2,0(r2)
 322c3b4:	1885883a 	add	r2,r3,r2
 322c3b8:	1085883a 	add	r2,r2,r2
 322c3bc:	108000c4 	addi	r2,r2,3
 322c3c0:	e0bffe15 	stw	r2,-8(fp)
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
 322c3c4:	0080c9b4 	movhi	r2,806
 322c3c8:	10b39704 	addi	r2,r2,-12708
 322c3cc:	10000015 	stw	zero,0(r2)
 322c3d0:	10000115 	stw	zero,4(r2)
 322c3d4:	10000215 	stw	zero,8(r2)
 322c3d8:	10000315 	stw	zero,12(r2)
 322c3dc:	10000415 	stw	zero,16(r2)
   MEMSET(&mbufq, 0, sizeof(mbufq));
 322c3e0:	0080c9b4 	movhi	r2,806
 322c3e4:	10b3ab04 	addi	r2,r2,-12628
 322c3e8:	10000015 	stw	zero,0(r2)
 322c3ec:	10000115 	stw	zero,4(r2)
 322c3f0:	10000215 	stw	zero,8(r2)
 322c3f4:	10000315 	stw	zero,12(r2)
 322c3f8:	10000415 	stw	zero,16(r2)
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
 322c3fc:	0080c9b4 	movhi	r2,806
 322c400:	10b3b004 	addi	r2,r2,-12608
 322c404:	10000015 	stw	zero,0(r2)
 322c408:	10000115 	stw	zero,4(r2)
 322c40c:	10000215 	stw	zero,8(r2)
 322c410:	10000315 	stw	zero,12(r2)
 322c414:	10000415 	stw	zero,16(r2)
   for (i = 0; i < (int)bufcount; i++)
 322c418:	e03fff15 	stw	zero,-4(fp)
 322c41c:	00001606 	br	322c478 <nptcp_init+0xec>
   {
      m = MBU_ALLOC(sizeof(struct mbuf));
 322c420:	01000904 	movi	r4,36
 322c424:	322b5d00 	call	322b5d0 <npalloc>
 322c428:	e0bffd15 	stw	r2,-12(fp)
      if (!m)  /* malloc error, bail out */
 322c42c:	e0bffd17 	ldw	r2,-12(fp)
 322c430:	1004c03a 	cmpne	r2,r2,zero
 322c434:	1000031e 	bne	r2,zero,322c444 <nptcp_init+0xb8>
         panic("tcpinit");
 322c438:	0100c974 	movhi	r4,805
 322c43c:	213d3204 	addi	r4,r4,-2872
 322c440:	3225df00 	call	3225df0 <panic>
      m->m_type = MT_FREE;
 322c444:	e0bffd17 	ldw	r2,-12(fp)
 322c448:	10000815 	stw	zero,32(r2)
      m->m_len = 0;
 322c44c:	e0bffd17 	ldw	r2,-12(fp)
 322c450:	10000215 	stw	zero,8(r2)
      m->m_data = NULL;
 322c454:	e0bffd17 	ldw	r2,-12(fp)
 322c458:	10000315 	stw	zero,12(r2)
      putq(&mfreeq, (qp)m);
 322c45c:	e17ffd17 	ldw	r5,-12(fp)
 322c460:	0100c9b4 	movhi	r4,806
 322c464:	2133b004 	addi	r4,r4,-12608
 322c468:	322a51c0 	call	322a51c <putq>
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
   MEMSET(&mbufq, 0, sizeof(mbufq));
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
   for (i = 0; i < (int)bufcount; i++)
 322c46c:	e0bfff17 	ldw	r2,-4(fp)
 322c470:	10800044 	addi	r2,r2,1
 322c474:	e0bfff15 	stw	r2,-4(fp)
 322c478:	e0fffe17 	ldw	r3,-8(fp)
 322c47c:	e0bfff17 	ldw	r2,-4(fp)
 322c480:	10ffe716 	blt	r2,r3,322c420 <nptcp_init+0x94>
      m->m_type = MT_FREE;
      m->m_len = 0;
      m->m_data = NULL;
      putq(&mfreeq, (qp)m);
   }
   mfreeq.q_min = (int)bufcount;   /* this should match q_max and q_len */
 322c484:	e0fffe17 	ldw	r3,-8(fp)
 322c488:	0080c9b4 	movhi	r2,806
 322c48c:	10b3b004 	addi	r2,r2,-12608
 322c490:	10c00415 	stw	r3,16(r2)
   tcpmib.tcpRtoAlgorithm = 4;     /* Van Jacobson's algorithm */
   tcpmib.tcpRtoMin = TCPTV_MIN * 1000;      /* PR_SLOWHZ */
   tcpmib.tcpRtoMax = TCPTV_REXMTMAX * 1000; /* PR_SLOWHZ */
#endif

   tcp_init();    /* call the BSD init in tcp_usr.c */
 322c494:	32376a80 	call	32376a8 <tcp_init>

#ifdef TCP_MENUS
   install_menu(&tcpmenu[0]);
#endif   /* IN_MENUS */

   return 0;   /* good return */
 322c498:	0005883a 	mov	r2,zero
}
 322c49c:	e037883a 	mov	sp,fp
 322c4a0:	dfc00117 	ldw	ra,4(sp)
 322c4a4:	df000017 	ldw	fp,0(sp)
 322c4a8:	dec00204 	addi	sp,sp,8
 322c4ac:	f800283a 	ret

0322c4b0 <tcp_rcv>:

#ifdef IP_V4
 
int
tcp_rcv(PACKET pkt)     /* NOTE: pkt has nb_prot pointing to IP header */
{
 322c4b0:	defff804 	addi	sp,sp,-32
 322c4b4:	dfc00715 	stw	ra,28(sp)
 322c4b8:	df000615 	stw	fp,24(sp)
 322c4bc:	df000604 	addi	fp,sp,24
 322c4c0:	e13ffe15 	stw	r4,-8(fp)

   /* For TCP, the netport IP layer is modified to set nb_prot to the 
    * start of the IP header (not TCP). We need to do some further
    * mods which the BSD code expects:
    */
   bip = (struct ip *)pkt->nb_prot;    /* get ip header */
 322c4c4:	e0bffe17 	ldw	r2,-8(fp)
 322c4c8:	10800317 	ldw	r2,12(r2)
 322c4cc:	e0bffc15 	stw	r2,-16(fp)
   len = ntohs(bip->ip_len);  /* get length in local endian */
 322c4d0:	e0bffc17 	ldw	r2,-16(fp)
 322c4d4:	1080008b 	ldhu	r2,2(r2)
 322c4d8:	10bfffcc 	andi	r2,r2,65535
 322c4dc:	1004d23a 	srli	r2,r2,8
 322c4e0:	10803fcc 	andi	r2,r2,255
 322c4e4:	1009883a 	mov	r4,r2
 322c4e8:	e0bffc17 	ldw	r2,-16(fp)
 322c4ec:	1080008b 	ldhu	r2,2(r2)
 322c4f0:	10bfffcc 	andi	r2,r2,65535
 322c4f4:	1004923a 	slli	r2,r2,8
 322c4f8:	1007883a 	mov	r3,r2
 322c4fc:	00bfc004 	movi	r2,-256
 322c500:	1884703a 	and	r2,r3,r2
 322c504:	2084b03a 	or	r2,r4,r2
 322c508:	e0bffa0d 	sth	r2,-24(fp)

   /* verify checksum of received packet */

   tcpp = (struct tcphdr *)ip_data(bip);
 322c50c:	e0bffc17 	ldw	r2,-16(fp)
 322c510:	10800003 	ldbu	r2,0(r2)
 322c514:	10803fcc 	andi	r2,r2,255
 322c518:	108003cc 	andi	r2,r2,15
 322c51c:	1085883a 	add	r2,r2,r2
 322c520:	1085883a 	add	r2,r2,r2
 322c524:	1007883a 	mov	r3,r2
 322c528:	e0bffc17 	ldw	r2,-16(fp)
 322c52c:	1885883a 	add	r2,r3,r2
 322c530:	e0bffb15 	stw	r2,-20(fp)
   if (tcp_cksum(bip) != tcpp->th_sum)
 322c534:	e13ffc17 	ldw	r4,-16(fp)
 322c538:	3247cb40 	call	3247cb4 <tcp_cksum>
 322c53c:	1007883a 	mov	r3,r2
 322c540:	e0bffb17 	ldw	r2,-20(fp)
 322c544:	1080040b 	ldhu	r2,16(r2)
 322c548:	18ffffcc 	andi	r3,r3,65535
 322c54c:	10bfffcc 	andi	r2,r2,65535
 322c550:	18801726 	beq	r3,r2,322c5b0 <tcp_rcv+0x100>
   {
      TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 322c554:	0080c9b4 	movhi	r2,806
 322c558:	10b39c04 	addi	r2,r2,-12688
 322c55c:	10800d17 	ldw	r2,52(r2)
 322c560:	10c00044 	addi	r3,r2,1
 322c564:	0080c9b4 	movhi	r2,806
 322c568:	10b39c04 	addi	r2,r2,-12688
 322c56c:	10c00d15 	stw	r3,52(r2)
      tcpstat.tcps_rcvbadsum++;  /* keep BSD stats */
 322c570:	0080c9b4 	movhi	r2,806
 322c574:	10b3ca04 	addi	r2,r2,-12504
 322c578:	10801c17 	ldw	r2,112(r2)
 322c57c:	10c00044 	addi	r3,r2,1
 322c580:	0080c9b4 	movhi	r2,806
 322c584:	10b3ca04 	addi	r2,r2,-12504
 322c588:	10c01c15 	stw	r3,112(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 322c58c:	01000084 	movi	r4,2
 322c590:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(pkt);  /* punt packet */
 322c594:	e13ffe17 	ldw	r4,-8(fp)
 322c598:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322c59c:	01000084 	movi	r4,2
 322c5a0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 322c5a4:	00bff804 	movi	r2,-32
 322c5a8:	e0bfff15 	stw	r2,-4(fp)
 322c5ac:	00003506 	br	322c684 <tcp_rcv+0x1d4>
   }

   m_in = m_getnbuf(MT_RXDATA, 0);
 322c5b0:	01000044 	movi	r4,1
 322c5b4:	000b883a 	mov	r5,zero
 322c5b8:	322b98c0 	call	322b98c <m_getnbuf>
 322c5bc:	e0bffd15 	stw	r2,-12(fp)
   if (!m_in){
 322c5c0:	e0bffd17 	ldw	r2,-12(fp)
 322c5c4:	1004c03a 	cmpne	r2,r2,zero
 322c5c8:	1000091e 	bne	r2,zero,322c5f0 <tcp_rcv+0x140>
      LOCK_NET_RESOURCE(FREEQ_RESID);
 322c5cc:	01000084 	movi	r4,2
 322c5d0:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(pkt);
 322c5d4:	e13ffe17 	ldw	r4,-8(fp)
 322c5d8:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322c5dc:	01000084 	movi	r4,2
 322c5e0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;  
 322c5e4:	00bffa84 	movi	r2,-22
 322c5e8:	e0bfff15 	stw	r2,-4(fp)
 322c5ec:	00002506 	br	322c684 <tcp_rcv+0x1d4>
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);      /* measure time in TCP */

   /* subtract IP header length from total IP packet length */
   len -= ((unshort)(bip->ip_ver_ihl & 0x0f) << 2);
 322c5f0:	e0bffc17 	ldw	r2,-16(fp)
 322c5f4:	10800003 	ldbu	r2,0(r2)
 322c5f8:	10803fcc 	andi	r2,r2,255
 322c5fc:	108003cc 	andi	r2,r2,15
 322c600:	1085883a 	add	r2,r2,r2
 322c604:	1085883a 	add	r2,r2,r2
 322c608:	1007883a 	mov	r3,r2
 322c60c:	e0bffa0b 	ldhu	r2,-24(fp)
 322c610:	10c5c83a 	sub	r2,r2,r3
 322c614:	e0bffa0d 	sth	r2,-24(fp)
   bip->ip_len = len;   /* put TCP length in struct for TCP code to use */
 322c618:	e0fffc17 	ldw	r3,-16(fp)
 322c61c:	e0bffa0b 	ldhu	r2,-24(fp)
 322c620:	1880008d 	sth	r2,2(r3)

   /* set mbuf to point to start of IP header (not TCP) */
   m_in->pkt = pkt;
 322c624:	e0fffd17 	ldw	r3,-12(fp)
 322c628:	e0bffe17 	ldw	r2,-8(fp)
 322c62c:	18800115 	stw	r2,4(r3)
   m_in->m_data = pkt->nb_prot;
 322c630:	e0bffe17 	ldw	r2,-8(fp)
 322c634:	10c00317 	ldw	r3,12(r2)
 322c638:	e0bffd17 	ldw	r2,-12(fp)
 322c63c:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 322c640:	e0bffe17 	ldw	r2,-8(fp)
 322c644:	10c00417 	ldw	r3,16(r2)
 322c648:	e0bffd17 	ldw	r2,-12(fp)
 322c64c:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;     /* ??? */
 322c650:	e0bffe17 	ldw	r2,-8(fp)
 322c654:	10c00117 	ldw	r3,4(r2)
 322c658:	e0bffd17 	ldw	r2,-12(fp)
 322c65c:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;    /* ??? */
 322c660:	e0bffe17 	ldw	r2,-8(fp)
 322c664:	10c00217 	ldw	r3,8(r2)
 322c668:	e0bffd17 	ldw	r2,-12(fp)
 322c66c:	10c00515 	stw	r3,20(r2)

   tcp_input(m_in, pkt->net);
 322c670:	e0bffe17 	ldw	r2,-8(fp)
 322c674:	11400617 	ldw	r5,24(r2)
 322c678:	e13ffd17 	ldw	r4,-12(fp)
 322c67c:	32337680 	call	3233768 <tcp_input>

   IN_PROFILER(PF_TCP, PF_EXIT);      /* measure time in TCP */

   return 0;
 322c680:	e03fff15 	stw	zero,-4(fp)
 322c684:	e0bfff17 	ldw	r2,-4(fp)
}
 322c688:	e037883a 	mov	sp,fp
 322c68c:	dfc00117 	ldw	ra,4(sp)
 322c690:	df000017 	ldw	fp,0(sp)
 322c694:	dec00204 	addi	sp,sp,8
 322c698:	f800283a 	ret

0322c69c <ip_output>:
 * RETURNS: 
 */

int
ip_output(struct mbuf * data, struct   ip_socopts * so_optsPack) /* mbuf chain with data to send */
{
 322c69c:	defff304 	addi	sp,sp,-52
 322c6a0:	dfc00c15 	stw	ra,48(sp)
 322c6a4:	df000b15 	stw	fp,44(sp)
 322c6a8:	df000b04 	addi	fp,sp,44
 322c6ac:	e13ffd15 	stw	r4,-12(fp)
 322c6b0:	e17ffe15 	stw	r5,-8(fp)
    * little copying as possible. Typically the mbufs will be either 
    * 1) a single mbuf with iptcp header info only (e.g.tcp ACK 
    * packet), or 2) iptcp header with data mbuf chained to it, or 3) 
    * #2) with a tiny option data mbuf between header and data. 
    */
   if ((data->m_next))
 322c6b4:	e0bffd17 	ldw	r2,-12(fp)
 322c6b8:	10800617 	ldw	r2,24(r2)
 322c6bc:	1005003a 	cmpeq	r2,r2,zero
 322c6c0:	1001101e 	bne	r2,zero,322cb04 <ip_output+0x468>
   {
      m1 = data;
 322c6c4:	e0bffd17 	ldw	r2,-12(fp)
 322c6c8:	e0bff915 	stw	r2,-28(fp)
      m2 = data->m_next;
 322c6cc:	e0bffd17 	ldw	r2,-12(fp)
 322c6d0:	10800617 	ldw	r2,24(r2)
 322c6d4:	e0bff815 	stw	r2,-32(fp)

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 322c6d8:	00003406 	br	322c7ac <ip_output+0x110>
      {
         pkt = m1->pkt;
 322c6dc:	e0bff917 	ldw	r2,-28(fp)
 322c6e0:	10800117 	ldw	r2,4(r2)
 322c6e4:	e0bffa15 	stw	r2,-24(fp)
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 322c6e8:	e0bffa17 	ldw	r2,-24(fp)
 322c6ec:	10c00117 	ldw	r3,4(r2)
 322c6f0:	e0bffa17 	ldw	r2,-24(fp)
 322c6f4:	10800217 	ldw	r2,8(r2)
 322c6f8:	1889883a 	add	r4,r3,r2
 322c6fc:	e0bff917 	ldw	r2,-28(fp)
 322c700:	10c00317 	ldw	r3,12(r2)
 322c704:	e0bff917 	ldw	r2,-28(fp)
 322c708:	10800217 	ldw	r2,8(r2)
 322c70c:	1887883a 	add	r3,r3,r2
 322c710:	e0bff817 	ldw	r2,-32(fp)
 322c714:	10800217 	ldw	r2,8(r2)
 322c718:	1885883a 	add	r2,r3,r2
 322c71c:	1100822e 	bgeu	r2,r4,322c928 <ip_output+0x28c>
             (m1->m_data + m1->m_len + m2->m_len))
         {
            MEMCPY((m1->m_data + m1->m_len), m2->m_data, m2->m_len);
 322c720:	e0bff917 	ldw	r2,-28(fp)
 322c724:	10c00317 	ldw	r3,12(r2)
 322c728:	e0bff917 	ldw	r2,-28(fp)
 322c72c:	10800217 	ldw	r2,8(r2)
 322c730:	1887883a 	add	r3,r3,r2
 322c734:	e0bff817 	ldw	r2,-32(fp)
 322c738:	11400317 	ldw	r5,12(r2)
 322c73c:	e0bff817 	ldw	r2,-32(fp)
 322c740:	10800217 	ldw	r2,8(r2)
 322c744:	1809883a 	mov	r4,r3
 322c748:	100d883a 	mov	r6,r2
 322c74c:	32067cc0 	call	32067cc <memcpy>
            m1->m_len += m2->m_len;
 322c750:	e0bff917 	ldw	r2,-28(fp)
 322c754:	10c00217 	ldw	r3,8(r2)
 322c758:	e0bff817 	ldw	r2,-32(fp)
 322c75c:	10800217 	ldw	r2,8(r2)
 322c760:	1887883a 	add	r3,r3,r2
 322c764:	e0bff917 	ldw	r2,-28(fp)
 322c768:	10c00215 	stw	r3,8(r2)
            m1->m_next = m2->m_next;
 322c76c:	e0bff817 	ldw	r2,-32(fp)
 322c770:	10c00617 	ldw	r3,24(r2)
 322c774:	e0bff917 	ldw	r2,-28(fp)
 322c778:	10c00615 	stw	r3,24(r2)
            m_free(m2);    /* free this m2.... */
 322c77c:	e13ff817 	ldw	r4,-32(fp)
 322c780:	322bb340 	call	322bb34 <m_free>
            m2 = m1->m_next;  /* ...and thread the next one */
 322c784:	e0bff917 	ldw	r2,-28(fp)
 322c788:	10800617 	ldw	r2,24(r2)
 322c78c:	e0bff815 	stw	r2,-32(fp)
            tcpstat.tcps_oappends++;
 322c790:	0080c9b4 	movhi	r2,806
 322c794:	10b3ca04 	addi	r2,r2,-12504
 322c798:	10803317 	ldw	r2,204(r2)
 322c79c:	10c00044 	addi	r3,r2,1
 322c7a0:	0080c9b4 	movhi	r2,806
 322c7a4:	10b3ca04 	addi	r2,r2,-12504
 322c7a8:	10c03315 	stw	r3,204(r2)
   {
      m1 = data;
      m2 = data->m_next;

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 322c7ac:	e0bff817 	ldw	r2,-32(fp)
 322c7b0:	1005003a 	cmpeq	r2,r2,zero
 322c7b4:	10005c1e 	bne	r2,zero,322c928 <ip_output+0x28c>
 322c7b8:	e0bff817 	ldw	r2,-32(fp)
 322c7bc:	10800217 	ldw	r2,8(r2)
 322c7c0:	108002b0 	cmpltui	r2,r2,10
 322c7c4:	103fc51e 	bne	r2,zero,322c6dc <ip_output+0x40>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 322c7c8:	00005706 	br	322c928 <ip_output+0x28c>
      {
         /* try prepending m1 to m2, first see if it fits: */
         e = m2->m_data - m2->pkt->nb_buff;  /* e is prepend space */
 322c7cc:	e0bff817 	ldw	r2,-32(fp)
 322c7d0:	10800317 	ldw	r2,12(r2)
 322c7d4:	1007883a 	mov	r3,r2
 322c7d8:	e0bff817 	ldw	r2,-32(fp)
 322c7dc:	10800117 	ldw	r2,4(r2)
 322c7e0:	10800117 	ldw	r2,4(r2)
 322c7e4:	1885c83a 	sub	r2,r3,r2
 322c7e8:	e0bff615 	stw	r2,-40(fp)
         if (e < MaxLnh)
 322c7ec:	0080c974 	movhi	r2,805
 322c7f0:	10922f04 	addi	r2,r2,18620
 322c7f4:	10c00017 	ldw	r3,0(r2)
 322c7f8:	e0bff617 	ldw	r2,-40(fp)
 322c7fc:	10c00a0e 	bge	r2,r3,322c828 <ip_output+0x18c>
         { 
#ifdef NPDEBUG
            dprintf("nptcp: MaxLnh:%d, e:%d\n", MaxLnh, e);
 322c800:	0080c974 	movhi	r2,805
 322c804:	10922f04 	addi	r2,r2,18620
 322c808:	11400017 	ldw	r5,0(r2)
 322c80c:	0100c974 	movhi	r4,805
 322c810:	213d3404 	addi	r4,r4,-2864
 322c814:	e1bff617 	ldw	r6,-40(fp)
 322c818:	3206adc0 	call	3206adc <printf>
#endif
            panic("tcp_out:mbuf-nbuf");   /* sanity check */
 322c81c:	0100c974 	movhi	r4,805
 322c820:	213d3a04 	addi	r4,r4,-2840
 322c824:	3225df00 	call	3225df0 <panic>
         }

         if ((m1->m_len < (unsigned)(e - MaxLnh))  /* leave room for MAC */
 322c828:	e0bff917 	ldw	r2,-28(fp)
 322c82c:	11000217 	ldw	r4,8(r2)
 322c830:	0080c974 	movhi	r2,805
 322c834:	10922f04 	addi	r2,r2,18620
 322c838:	10c00017 	ldw	r3,0(r2)
 322c83c:	e0bff617 	ldw	r2,-40(fp)
 322c840:	10c5c83a 	sub	r2,r2,r3
 322c844:	20803b2e 	bgeu	r4,r2,322c934 <ip_output+0x298>
 322c848:	e0bff917 	ldw	r2,-28(fp)
 322c84c:	10800217 	ldw	r2,8(r2)
 322c850:	108000cc 	andi	r2,r2,3
 322c854:	1004c03a 	cmpne	r2,r2,zero
 322c858:	1000361e 	bne	r2,zero,322c934 <ip_output+0x298>
 322c85c:	e0bff817 	ldw	r2,-32(fp)
 322c860:	10800317 	ldw	r2,12(r2)
 322c864:	1007883a 	mov	r3,r2
 322c868:	e0bff817 	ldw	r2,-32(fp)
 322c86c:	10800117 	ldw	r2,4(r2)
 322c870:	10800117 	ldw	r2,4(r2)
 322c874:	1885c83a 	sub	r2,r3,r2
 322c878:	10800e18 	cmpnei	r2,r2,56
 322c87c:	10002d1e 	bne	r2,zero,322c934 <ip_output+0x298>
             && ((m1->m_len & (ALIGN_TYPE - 1)) == 0)  /* and stay aligned */
             && ((m2->m_data - m2->pkt->nb_buff) == HDRSLEN))   /* be at start */
         {
            MEMCPY((m2->m_data - m1->m_len), m1->m_data, m1->m_len);
 322c880:	e0bff817 	ldw	r2,-32(fp)
 322c884:	10c00317 	ldw	r3,12(r2)
 322c888:	e0bff917 	ldw	r2,-28(fp)
 322c88c:	10800217 	ldw	r2,8(r2)
 322c890:	1887c83a 	sub	r3,r3,r2
 322c894:	e0bff917 	ldw	r2,-28(fp)
 322c898:	11400317 	ldw	r5,12(r2)
 322c89c:	e0bff917 	ldw	r2,-28(fp)
 322c8a0:	10800217 	ldw	r2,8(r2)
 322c8a4:	1809883a 	mov	r4,r3
 322c8a8:	100d883a 	mov	r6,r2
 322c8ac:	32067cc0 	call	32067cc <memcpy>
            m2->m_data -= m1->m_len;   /* fix target to reflect prepend */
 322c8b0:	e0bff817 	ldw	r2,-32(fp)
 322c8b4:	10c00317 	ldw	r3,12(r2)
 322c8b8:	e0bff917 	ldw	r2,-28(fp)
 322c8bc:	10800217 	ldw	r2,8(r2)
 322c8c0:	1887c83a 	sub	r3,r3,r2
 322c8c4:	e0bff817 	ldw	r2,-32(fp)
 322c8c8:	10c00315 	stw	r3,12(r2)
            m2->m_len += m1->m_len;
 322c8cc:	e0bff817 	ldw	r2,-32(fp)
 322c8d0:	10c00217 	ldw	r3,8(r2)
 322c8d4:	e0bff917 	ldw	r2,-28(fp)
 322c8d8:	10800217 	ldw	r2,8(r2)
 322c8dc:	1887883a 	add	r3,r3,r2
 322c8e0:	e0bff817 	ldw	r2,-32(fp)
 322c8e4:	10c00215 	stw	r3,8(r2)
            m_free(m1);    /* free head (copied) mbuf */
 322c8e8:	e13ff917 	ldw	r4,-28(fp)
 322c8ec:	322bb340 	call	322bb34 <m_free>
            data = m1 = m2;   /* move other mbufs up the chain */
 322c8f0:	e0bff817 	ldw	r2,-32(fp)
 322c8f4:	e0bff915 	stw	r2,-28(fp)
 322c8f8:	e0bff917 	ldw	r2,-28(fp)
 322c8fc:	e0bffd15 	stw	r2,-12(fp)
            m2 = m2->m_next;  /* loop to while(m2) test */
 322c900:	e0bff817 	ldw	r2,-32(fp)
 322c904:	10800617 	ldw	r2,24(r2)
 322c908:	e0bff815 	stw	r2,-32(fp)
            tcpstat.tcps_oprepends++;
 322c90c:	0080c9b4 	movhi	r2,806
 322c910:	10b3ca04 	addi	r2,r2,-12504
 322c914:	10803217 	ldw	r2,200(r2)
 322c918:	10c00044 	addi	r3,r2,1
 322c91c:	0080c9b4 	movhi	r2,806
 322c920:	10b3ca04 	addi	r2,r2,-12504
 322c924:	10c03215 	stw	r3,200(r2)
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 322c928:	e0bff817 	ldw	r2,-32(fp)
 322c92c:	1004c03a 	cmpne	r2,r2,zero
 322c930:	103fa61e 	bne	r2,zero,322c7cc <ip_output+0x130>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      if (m2)  /* If all else fails, brute force copy: */
 322c934:	e0bff817 	ldw	r2,-32(fp)
 322c938:	1005003a 	cmpeq	r2,r2,zero
 322c93c:	1000711e 	bne	r2,zero,322cb04 <ip_output+0x468>
      {
         total = 0;
 322c940:	e03ff515 	stw	zero,-44(fp)
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 322c944:	e0bff917 	ldw	r2,-28(fp)
 322c948:	e0bff715 	stw	r2,-36(fp)
 322c94c:	00000806 	br	322c970 <ip_output+0x2d4>
            total += mtmp->m_len;
 322c950:	e0bff717 	ldw	r2,-36(fp)
 322c954:	10c00217 	ldw	r3,8(r2)
 322c958:	e0bff517 	ldw	r2,-44(fp)
 322c95c:	1885883a 	add	r2,r3,r2
 322c960:	e0bff515 	stw	r2,-44(fp)
      }

      if (m2)  /* If all else fails, brute force copy: */
      {
         total = 0;
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 322c964:	e0bff717 	ldw	r2,-36(fp)
 322c968:	10800617 	ldw	r2,24(r2)
 322c96c:	e0bff715 	stw	r2,-36(fp)
 322c970:	e0bff717 	ldw	r2,-36(fp)
 322c974:	1004c03a 	cmpne	r2,r2,zero
 322c978:	103ff51e 	bne	r2,zero,322c950 <ip_output+0x2b4>
            total += mtmp->m_len;
         LOCK_NET_RESOURCE(FREEQ_RESID);
 322c97c:	01000084 	movi	r4,2
 322c980:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pkt = pk_alloc(total + HDRSLEN);
 322c984:	e0bff517 	ldw	r2,-44(fp)
 322c988:	10800e04 	addi	r2,r2,56
 322c98c:	1009883a 	mov	r4,r2
 322c990:	3229f480 	call	3229f48 <pk_alloc>
 322c994:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322c998:	01000084 	movi	r4,2
 322c99c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         if (!pkt)
 322c9a0:	e0bffa17 	ldw	r2,-24(fp)
 322c9a4:	1004c03a 	cmpne	r2,r2,zero
 322c9a8:	1000031e 	bne	r2,zero,322c9b8 <ip_output+0x31c>
            return ENOBUFS;
 322c9ac:	00801a44 	movi	r2,105
 322c9b0:	e0bfff15 	stw	r2,-4(fp)
 322c9b4:	0000b106 	br	322cc7c <ip_output+0x5e0>
         pkt->nb_prot = pkt->nb_buff + MaxLnh;
 322c9b8:	e0bffa17 	ldw	r2,-24(fp)
 322c9bc:	10c00117 	ldw	r3,4(r2)
 322c9c0:	0080c974 	movhi	r2,805
 322c9c4:	10922f04 	addi	r2,r2,18620
 322c9c8:	10800017 	ldw	r2,0(r2)
 322c9cc:	1887883a 	add	r3,r3,r2
 322c9d0:	e0bffa17 	ldw	r2,-24(fp)
 322c9d4:	10c00315 	stw	r3,12(r2)

         mtmp = m1;
 322c9d8:	e0bff917 	ldw	r2,-28(fp)
 322c9dc:	e0bff715 	stw	r2,-36(fp)
         while (mtmp)
 322c9e0:	00002806 	br	322ca84 <ip_output+0x3e8>
         {
            MEMCPY(pkt->nb_prot, mtmp->m_data, mtmp->m_len);
 322c9e4:	e0bffa17 	ldw	r2,-24(fp)
 322c9e8:	10c00317 	ldw	r3,12(r2)
 322c9ec:	e0bff717 	ldw	r2,-36(fp)
 322c9f0:	11400317 	ldw	r5,12(r2)
 322c9f4:	e0bff717 	ldw	r2,-36(fp)
 322c9f8:	10800217 	ldw	r2,8(r2)
 322c9fc:	1809883a 	mov	r4,r3
 322ca00:	100d883a 	mov	r6,r2
 322ca04:	32067cc0 	call	32067cc <memcpy>
            pkt->nb_prot += mtmp->m_len;
 322ca08:	e0bffa17 	ldw	r2,-24(fp)
 322ca0c:	10c00317 	ldw	r3,12(r2)
 322ca10:	e0bff717 	ldw	r2,-36(fp)
 322ca14:	10800217 	ldw	r2,8(r2)
 322ca18:	1887883a 	add	r3,r3,r2
 322ca1c:	e0bffa17 	ldw	r2,-24(fp)
 322ca20:	10c00315 	stw	r3,12(r2)
            pkt->nb_plen += mtmp->m_len;
 322ca24:	e0bffa17 	ldw	r2,-24(fp)
 322ca28:	10c00417 	ldw	r3,16(r2)
 322ca2c:	e0bff717 	ldw	r2,-36(fp)
 322ca30:	10800217 	ldw	r2,8(r2)
 322ca34:	1887883a 	add	r3,r3,r2
 322ca38:	e0bffa17 	ldw	r2,-24(fp)
 322ca3c:	10c00415 	stw	r3,16(r2)
            m2 = mtmp;
 322ca40:	e0bff717 	ldw	r2,-36(fp)
 322ca44:	e0bff815 	stw	r2,-32(fp)
            mtmp = mtmp->m_next;
 322ca48:	e0bff717 	ldw	r2,-36(fp)
 322ca4c:	10800617 	ldw	r2,24(r2)
 322ca50:	e0bff715 	stw	r2,-36(fp)
            if (m2 != data)   /* save original head */
 322ca54:	e0fff817 	ldw	r3,-32(fp)
 322ca58:	e0bffd17 	ldw	r2,-12(fp)
 322ca5c:	18800226 	beq	r3,r2,322ca68 <ip_output+0x3cc>
               m_free(m2);
 322ca60:	e13ff817 	ldw	r4,-32(fp)
 322ca64:	322bb340 	call	322bb34 <m_free>
            tcpstat.tcps_ocopies++;
 322ca68:	0080c9b4 	movhi	r2,806
 322ca6c:	10b3ca04 	addi	r2,r2,-12504
 322ca70:	10803417 	ldw	r2,208(r2)
 322ca74:	10c00044 	addi	r3,r2,1
 322ca78:	0080c9b4 	movhi	r2,806
 322ca7c:	10b3ca04 	addi	r2,r2,-12504
 322ca80:	10c03415 	stw	r3,208(r2)
         if (!pkt)
            return ENOBUFS;
         pkt->nb_prot = pkt->nb_buff + MaxLnh;

         mtmp = m1;
         while (mtmp)
 322ca84:	e0bff717 	ldw	r2,-36(fp)
 322ca88:	1004c03a 	cmpne	r2,r2,zero
 322ca8c:	103fd51e 	bne	r2,zero,322c9e4 <ip_output+0x348>
            mtmp = mtmp->m_next;
            if (m2 != data)   /* save original head */
               m_free(m2);
            tcpstat.tcps_ocopies++;
         }
         pkt->nb_prot -= total;     /* fix data pointer */
 322ca90:	e0bffa17 	ldw	r2,-24(fp)
 322ca94:	10c00317 	ldw	r3,12(r2)
 322ca98:	e0bff517 	ldw	r2,-44(fp)
 322ca9c:	1887c83a 	sub	r3,r3,r2
 322caa0:	e0bffa17 	ldw	r2,-24(fp)
 322caa4:	10c00315 	stw	r3,12(r2)

         /* release the original mbufs packet install the new one */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 322caa8:	01000084 	movi	r4,2
 322caac:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pk_free(data->pkt);
 322cab0:	e0bffd17 	ldw	r2,-12(fp)
 322cab4:	11000117 	ldw	r4,4(r2)
 322cab8:	322a2dc0 	call	322a2dc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322cabc:	01000084 	movi	r4,2
 322cac0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         data->pkt = pkt;
 322cac4:	e0fffd17 	ldw	r3,-12(fp)
 322cac8:	e0bffa17 	ldw	r2,-24(fp)
 322cacc:	18800115 	stw	r2,4(r3)
         data->m_len = pkt->nb_plen;
 322cad0:	e0bffa17 	ldw	r2,-24(fp)
 322cad4:	10c00417 	ldw	r3,16(r2)
 322cad8:	e0bffd17 	ldw	r2,-12(fp)
 322cadc:	10c00215 	stw	r3,8(r2)
         data->m_next = NULL;
 322cae0:	e0bffd17 	ldw	r2,-12(fp)
 322cae4:	10000615 	stw	zero,24(r2)
         data->m_data = pkt->nb_prot;
 322cae8:	e0bffa17 	ldw	r2,-24(fp)
 322caec:	10c00317 	ldw	r3,12(r2)
 322caf0:	e0bffd17 	ldw	r2,-12(fp)
 322caf4:	10c00315 	stw	r3,12(r2)
         data->m_len = total;
 322caf8:	e0fff517 	ldw	r3,-44(fp)
 322cafc:	e0bffd17 	ldw	r2,-12(fp)
 322cb00:	10c00215 	stw	r3,8(r2)
      }
   }

   if ((data->m_data < (data->pkt->nb_buff + MaxLnh)))
 322cb04:	e0bffd17 	ldw	r2,-12(fp)
 322cb08:	11000317 	ldw	r4,12(r2)
 322cb0c:	e0bffd17 	ldw	r2,-12(fp)
 322cb10:	10800117 	ldw	r2,4(r2)
 322cb14:	10c00117 	ldw	r3,4(r2)
 322cb18:	0080c974 	movhi	r2,805
 322cb1c:	10922f04 	addi	r2,r2,18620
 322cb20:	10800017 	ldw	r2,0(r2)
 322cb24:	1885883a 	add	r2,r3,r2
 322cb28:	2080032e 	bgeu	r4,r2,322cb38 <ip_output+0x49c>
      panic("ip_output: overflow");
 322cb2c:	0100c974 	movhi	r4,805
 322cb30:	213d3f04 	addi	r4,r4,-2820
 322cb34:	3225df00 	call	3225df0 <panic>

   pkt = data->pkt;
 322cb38:	e0bffd17 	ldw	r2,-12(fp)
 322cb3c:	10800117 	ldw	r2,4(r2)
 322cb40:	e0bffa15 	stw	r2,-24(fp)

   /* do we have options? */
   if (so_optsPack)
 322cb44:	e0bffe17 	ldw	r2,-8(fp)
 322cb48:	1005003a 	cmpeq	r2,r2,zero
 322cb4c:	1000031e 	bne	r2,zero,322cb5c <ip_output+0x4c0>
	   pkt->soxopts = so_optsPack;   /* yup */
 322cb50:	e0fffa17 	ldw	r3,-24(fp)
 322cb54:	e0bffe17 	ldw	r2,-8(fp)
 322cb58:	18800c15 	stw	r2,48(r3)
      panic("ip_output: no so_optsPack for the IPv6 scope");     
   }
#endif

   /* fill in dest host for IP layer */
   bip = (struct ip *)data->m_data;
 322cb5c:	e0bffd17 	ldw	r2,-12(fp)
 322cb60:	10800317 	ldw	r2,12(r2)
 322cb64:	e0bffc15 	stw	r2,-16(fp)
   pkt->fhost = bip->ip_dest;
 322cb68:	e0bffc17 	ldw	r2,-16(fp)
 322cb6c:	10c00417 	ldw	r3,16(r2)
 322cb70:	e0bffa17 	ldw	r2,-24(fp)
 322cb74:	10c00715 	stw	r3,28(r2)

   /* make enough IP header for cksum calculation */
   bip->ip_ver_ihl = 0x45;
 322cb78:	e0fffc17 	ldw	r3,-16(fp)
 322cb7c:	00801144 	movi	r2,69
 322cb80:	18800005 	stb	r2,0(r3)
   bip->ip_len = htons(bip->ip_len);   /* make net endian for calculation */
 322cb84:	e0bffc17 	ldw	r2,-16(fp)
 322cb88:	1080008b 	ldhu	r2,2(r2)
 322cb8c:	10bfffcc 	andi	r2,r2,65535
 322cb90:	1004d23a 	srli	r2,r2,8
 322cb94:	10803fcc 	andi	r2,r2,255
 322cb98:	1009883a 	mov	r4,r2
 322cb9c:	e0bffc17 	ldw	r2,-16(fp)
 322cba0:	1080008b 	ldhu	r2,2(r2)
 322cba4:	10bfffcc 	andi	r2,r2,65535
 322cba8:	1004923a 	slli	r2,r2,8
 322cbac:	1007883a 	mov	r3,r2
 322cbb0:	00bfc004 	movi	r2,-256
 322cbb4:	1884703a 	and	r2,r3,r2
 322cbb8:	2084b03a 	or	r2,r4,r2
 322cbbc:	1007883a 	mov	r3,r2
 322cbc0:	e0bffc17 	ldw	r2,-16(fp)
 322cbc4:	10c0008d 	sth	r3,2(r2)
   tcpp = (struct tcphdr *)ip_data(bip);
 322cbc8:	e0bffc17 	ldw	r2,-16(fp)
 322cbcc:	10800003 	ldbu	r2,0(r2)
 322cbd0:	10803fcc 	andi	r2,r2,255
 322cbd4:	108003cc 	andi	r2,r2,15
 322cbd8:	1085883a 	add	r2,r2,r2
 322cbdc:	1085883a 	add	r2,r2,r2
 322cbe0:	1007883a 	mov	r3,r2
 322cbe4:	e0bffc17 	ldw	r2,-16(fp)
 322cbe8:	1885883a 	add	r2,r3,r2
 322cbec:	e0bffb15 	stw	r2,-20(fp)
#ifdef CSUM_DEMO
   if (!(tcpp->th_flags & TH_SYN))
   tcpp->th_flags |= TH_PUSH;     /* force the PSH flag in TCP hdr */
#endif
   tcpp->th_sum = tcp_cksum(bip);
 322cbf0:	e13ffc17 	ldw	r4,-16(fp)
 322cbf4:	3247cb40 	call	3247cb4 <tcp_cksum>
 322cbf8:	1007883a 	mov	r3,r2
 322cbfc:	e0bffb17 	ldw	r2,-20(fp)
 322cc00:	10c0040d 	sth	r3,16(r2)

   pkt->nb_prot = (char*)(bip + 1);    /* point past IP header */
 322cc04:	e0bffc17 	ldw	r2,-16(fp)
 322cc08:	10800504 	addi	r2,r2,20
 322cc0c:	1007883a 	mov	r3,r2
 322cc10:	e0bffa17 	ldw	r2,-24(fp)
 322cc14:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen = data->m_len - sizeof(struct ip);
 322cc18:	e0bffd17 	ldw	r2,-12(fp)
 322cc1c:	10800217 	ldw	r2,8(r2)
 322cc20:	10fffb04 	addi	r3,r2,-20
 322cc24:	e0bffa17 	ldw	r2,-24(fp)
 322cc28:	10c00415 	stw	r3,16(r2)

   e = ip_write(IPPROTO_TCP, pkt);
 322cc2c:	01000184 	movi	r4,6
 322cc30:	e17ffa17 	ldw	r5,-24(fp)
 322cc34:	323f0100 	call	323f010 <ip_write>
 322cc38:	e0bff615 	stw	r2,-40(fp)

   /* ip_write() is now responsable for data->pkt, so... */
   data->pkt = NULL;
 322cc3c:	e0bffd17 	ldw	r2,-12(fp)
 322cc40:	10000115 	stw	zero,4(r2)
   m_freem(data);
 322cc44:	e13ffd17 	ldw	r4,-12(fp)
 322cc48:	322bc680 	call	322bc68 <m_freem>

   if (e < 0)
 322cc4c:	e0bff617 	ldw	r2,-40(fp)
 322cc50:	1004403a 	cmpge	r2,r2,zero
 322cc54:	1000081e 	bne	r2,zero,322cc78 <ip_output+0x5dc>
   {
      /* don't report dropped sends, it causes socket applications to 
      bail when a TCP retry will fix the problem */
      if (e == SEND_DROPPED)
 322cc58:	e0bff617 	ldw	r2,-40(fp)
 322cc5c:	10bffa98 	cmpnei	r2,r2,-22
 322cc60:	1000021e 	bne	r2,zero,322cc6c <ip_output+0x5d0>
         return 0;
 322cc64:	e03fff15 	stw	zero,-4(fp)
 322cc68:	00000406 	br	322cc7c <ip_output+0x5e0>
      return e;
 322cc6c:	e0bff617 	ldw	r2,-40(fp)
 322cc70:	e0bfff15 	stw	r2,-4(fp)
 322cc74:	00000106 	br	322cc7c <ip_output+0x5e0>
   }
   else
      return 0;
 322cc78:	e03fff15 	stw	zero,-4(fp)
 322cc7c:	e0bfff17 	ldw	r2,-4(fp)
}
 322cc80:	e037883a 	mov	sp,fp
 322cc84:	dfc00117 	ldw	ra,4(sp)
 322cc88:	df000017 	ldw	fp,0(sp)
 322cc8c:	dec00204 	addi	sp,sp,8
 322cc90:	f800283a 	ret

0322cc94 <in_broadcast>:
 * RETURNS: TRUE if broadcast, else FALSE
 */

int
in_broadcast(u_long ipaddr)   /* passed in net endian */
{
 322cc94:	defffd04 	addi	sp,sp,-12
 322cc98:	df000215 	stw	fp,8(sp)
 322cc9c:	df000204 	addi	fp,sp,8
 322cca0:	e13ffe15 	stw	r4,-8(fp)
   if (ipaddr == 0xffffffff)
 322cca4:	e0bffe17 	ldw	r2,-8(fp)
 322cca8:	10bfffd8 	cmpnei	r2,r2,-1
 322ccac:	1000031e 	bne	r2,zero,322ccbc <in_broadcast+0x28>
      return TRUE;
 322ccb0:	00800044 	movi	r2,1
 322ccb4:	e0bfff15 	stw	r2,-4(fp)
 322ccb8:	00000106 	br	322ccc0 <in_broadcast+0x2c>

   return FALSE;
 322ccbc:	e03fff15 	stw	zero,-4(fp)
 322ccc0:	e0bfff17 	ldw	r2,-4(fp)
}
 322ccc4:	e037883a 	mov	sp,fp
 322ccc8:	df000017 	ldw	fp,0(sp)
 322cccc:	dec00104 	addi	sp,sp,4
 322ccd0:	f800283a 	ret

0322ccd4 <np_stripoptions>:
 * RETURNS: void
 */

void
np_stripoptions(struct ip * ti, struct mbuf * m)
{
 322ccd4:	defffb04 	addi	sp,sp,-20
 322ccd8:	dfc00415 	stw	ra,16(sp)
 322ccdc:	df000315 	stw	fp,12(sp)
 322cce0:	df000304 	addi	fp,sp,12
 322cce4:	e13ffe15 	stw	r4,-8(fp)
 322cce8:	e17fff15 	stw	r5,-4(fp)
   int   ihlen;

   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;
 322ccec:	e0bffe17 	ldw	r2,-8(fp)
 322ccf0:	10800003 	ldbu	r2,0(r2)
 322ccf4:	10803fcc 	andi	r2,r2,255
 322ccf8:	108003cc 	andi	r2,r2,15
 322ccfc:	1085883a 	add	r2,r2,r2
 322cd00:	1085883a 	add	r2,r2,r2
 322cd04:	e0bffd15 	stw	r2,-12(fp)

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
 322cd08:	e0bffd17 	ldw	r2,-12(fp)
 322cd0c:	10800550 	cmplti	r2,r2,21
 322cd10:	1000251e 	bne	r2,zero,322cda8 <np_stripoptions+0xd4>
      return;

   /* figure out how much to strip: we want to keep the 20-octet IP header */
   ihlen -= 20;
 322cd14:	e0bffd17 	ldw	r2,-12(fp)
 322cd18:	10bffb04 	addi	r2,r2,-20
 322cd1c:	e0bffd15 	stw	r2,-12(fp)

   /* remove the stripped options from the IP datagram length */
   ti->ip_len -= ihlen;
 322cd20:	e0bffe17 	ldw	r2,-8(fp)
 322cd24:	10c0008b 	ldhu	r3,2(r2)
 322cd28:	e0bffd17 	ldw	r2,-12(fp)
 322cd2c:	1885c83a 	sub	r2,r3,r2
 322cd30:	1007883a 	mov	r3,r2
 322cd34:	e0bffe17 	ldw	r2,-8(fp)
 322cd38:	10c0008d 	sth	r3,2(r2)

   /* and from the IP header length (which will be 5*4 octets long) */
   ti->ip_ver_ihl = (ti->ip_ver_ihl & 0xf0) | 5;
 322cd3c:	e0bffe17 	ldw	r2,-8(fp)
 322cd40:	10800003 	ldbu	r2,0(r2)
 322cd44:	1007883a 	mov	r3,r2
 322cd48:	00bffc04 	movi	r2,-16
 322cd4c:	1884703a 	and	r2,r3,r2
 322cd50:	10800154 	ori	r2,r2,5
 322cd54:	1007883a 	mov	r3,r2
 322cd58:	e0bffe17 	ldw	r2,-8(fp)
 322cd5c:	10c00005 	stb	r3,0(r2)

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
 322cd60:	e0fffe17 	ldw	r3,-8(fp)
 322cd64:	e0bffd17 	ldw	r2,-12(fp)
 322cd68:	1889883a 	add	r4,r3,r2
 322cd6c:	e17ffe17 	ldw	r5,-8(fp)
 322cd70:	01800504 	movi	r6,20
 322cd74:	320686c0 	call	320686c <memmove>
   m->m_len -= ihlen;
 322cd78:	e0bfff17 	ldw	r2,-4(fp)
 322cd7c:	10c00217 	ldw	r3,8(r2)
 322cd80:	e0bffd17 	ldw	r2,-12(fp)
 322cd84:	1887c83a 	sub	r3,r3,r2
 322cd88:	e0bfff17 	ldw	r2,-4(fp)
 322cd8c:	10c00215 	stw	r3,8(r2)
   m->m_data += ihlen;
 322cd90:	e0bfff17 	ldw	r2,-4(fp)
 322cd94:	10c00317 	ldw	r3,12(r2)
 322cd98:	e0bffd17 	ldw	r2,-12(fp)
 322cd9c:	1887883a 	add	r3,r3,r2
 322cda0:	e0bfff17 	ldw	r2,-4(fp)
 322cda4:	10c00315 	stw	r3,12(r2)
}
 322cda8:	e037883a 	mov	sp,fp
 322cdac:	dfc00117 	ldw	ra,4(sp)
 322cdb0:	df000017 	ldw	fp,0(sp)
 322cdb4:	dec00204 	addi	sp,sp,8
 322cdb8:	f800283a 	ret

0322cdbc <so_icmpdu>:
 * RETURNS: 
 */

void
so_icmpdu(PACKET p, struct destun * pdp)
{
 322cdbc:	defff304 	addi	sp,sp,-52
 322cdc0:	dfc00c15 	stw	ra,48(sp)
 322cdc4:	df000b15 	stw	fp,44(sp)
 322cdc8:	df000b04 	addi	fp,sp,44
 322cdcc:	e13ffe15 	stw	r4,-8(fp)
 322cdd0:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;
   struct socket *   so;
   struct tcpcb * tp;

   /* extract information about packet which generated DU */
   fhost = htonl(pdp->dip.ip_dest);
 322cdd4:	e0bfff17 	ldw	r2,-4(fp)
 322cdd8:	10800617 	ldw	r2,24(r2)
 322cddc:	1004d63a 	srli	r2,r2,24
 322cde0:	10c03fcc 	andi	r3,r2,255
 322cde4:	e0bfff17 	ldw	r2,-4(fp)
 322cde8:	10800617 	ldw	r2,24(r2)
 322cdec:	1004d23a 	srli	r2,r2,8
 322cdf0:	10bfc00c 	andi	r2,r2,65280
 322cdf4:	1886b03a 	or	r3,r3,r2
 322cdf8:	e0bfff17 	ldw	r2,-4(fp)
 322cdfc:	10800617 	ldw	r2,24(r2)
 322ce00:	10bfc00c 	andi	r2,r2,65280
 322ce04:	1004923a 	slli	r2,r2,8
 322ce08:	1886b03a 	or	r3,r3,r2
 322ce0c:	e0bfff17 	ldw	r2,-4(fp)
 322ce10:	10800617 	ldw	r2,24(r2)
 322ce14:	10803fcc 	andi	r2,r2,255
 322ce18:	1004963a 	slli	r2,r2,24
 322ce1c:	1884b03a 	or	r2,r3,r2
 322ce20:	e0bffc15 	stw	r2,-16(fp)
   lhost = htonl(pdp->dip.ip_src);
 322ce24:	e0bfff17 	ldw	r2,-4(fp)
 322ce28:	10800517 	ldw	r2,20(r2)
 322ce2c:	1004d63a 	srli	r2,r2,24
 322ce30:	10c03fcc 	andi	r3,r2,255
 322ce34:	e0bfff17 	ldw	r2,-4(fp)
 322ce38:	10800517 	ldw	r2,20(r2)
 322ce3c:	1004d23a 	srli	r2,r2,8
 322ce40:	10bfc00c 	andi	r2,r2,65280
 322ce44:	1886b03a 	or	r3,r3,r2
 322ce48:	e0bfff17 	ldw	r2,-4(fp)
 322ce4c:	10800517 	ldw	r2,20(r2)
 322ce50:	10bfc00c 	andi	r2,r2,65280
 322ce54:	1004923a 	slli	r2,r2,8
 322ce58:	1886b03a 	or	r3,r3,r2
 322ce5c:	e0bfff17 	ldw	r2,-4(fp)
 322ce60:	10800517 	ldw	r2,20(r2)
 322ce64:	10803fcc 	andi	r2,r2,255
 322ce68:	1004963a 	slli	r2,r2,24
 322ce6c:	1884b03a 	or	r2,r3,r2
 322ce70:	e0bffd15 	stw	r2,-12(fp)
   lport = htons(*(unshort*)(&pdp->ddata[0]));
 322ce74:	e0bfff17 	ldw	r2,-4(fp)
 322ce78:	10800704 	addi	r2,r2,28
 322ce7c:	1080000b 	ldhu	r2,0(r2)
 322ce80:	10bfffcc 	andi	r2,r2,65535
 322ce84:	1004d23a 	srli	r2,r2,8
 322ce88:	10803fcc 	andi	r2,r2,255
 322ce8c:	1009883a 	mov	r4,r2
 322ce90:	e0bfff17 	ldw	r2,-4(fp)
 322ce94:	10800704 	addi	r2,r2,28
 322ce98:	1080000b 	ldhu	r2,0(r2)
 322ce9c:	10bfffcc 	andi	r2,r2,65535
 322cea0:	1004923a 	slli	r2,r2,8
 322cea4:	1007883a 	mov	r3,r2
 322cea8:	00bfc004 	movi	r2,-256
 322ceac:	1884703a 	and	r2,r3,r2
 322ceb0:	2084b03a 	or	r2,r4,r2
 322ceb4:	e0bffb0d 	sth	r2,-20(fp)
   fport = htons(*(unshort*)(&pdp->ddata[2]));
 322ceb8:	e0bfff17 	ldw	r2,-4(fp)
 322cebc:	10800704 	addi	r2,r2,28
 322cec0:	10800084 	addi	r2,r2,2
 322cec4:	1080000b 	ldhu	r2,0(r2)
 322cec8:	10bfffcc 	andi	r2,r2,65535
 322cecc:	1004d23a 	srli	r2,r2,8
 322ced0:	10803fcc 	andi	r2,r2,255
 322ced4:	1009883a 	mov	r4,r2
 322ced8:	e0bfff17 	ldw	r2,-4(fp)
 322cedc:	10800704 	addi	r2,r2,28
 322cee0:	10800084 	addi	r2,r2,2
 322cee4:	1080000b 	ldhu	r2,0(r2)
 322cee8:	10bfffcc 	andi	r2,r2,65535
 322ceec:	1004923a 	slli	r2,r2,8
 322cef0:	1007883a 	mov	r3,r2
 322cef4:	00bfc004 	movi	r2,-256
 322cef8:	1884703a 	and	r2,r3,r2
 322cefc:	2084b03a 	or	r2,r4,r2
 322cf00:	e0bffb8d 	sth	r2,-18(fp)
#ifndef IP_PMTU
   /* if it's a datagram-too-big message, ignore it -- As the
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
 322cf04:	e0bfff17 	ldw	r2,-4(fp)
 322cf08:	10800043 	ldbu	r2,1(r2)
 322cf0c:	10803fcc 	andi	r2,r2,255
 322cf10:	1080201c 	xori	r2,r2,128
 322cf14:	10bfe004 	addi	r2,r2,-128
 322cf18:	10800120 	cmpeqi	r2,r2,4
 322cf1c:	1000721e 	bne	r2,zero,322d0e8 <so_icmpdu+0x32c>
       goto done;
    }
#endif   /* IP_PMTU */

   /* if it's a TCP connection, clean it up */
   if (pdp->dip.ip_prot == TCPTP)
 322cf20:	e0bfff17 	ldw	r2,-4(fp)
 322cf24:	10800443 	ldbu	r2,17(r2)
 322cf28:	10803fcc 	andi	r2,r2,255
 322cf2c:	10800198 	cmpnei	r2,r2,6
 322cf30:	1000241e 	bne	r2,zero,322cfc4 <so_icmpdu+0x208>
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
 322cf34:	e1bffb8b 	ldhu	r6,-18(fp)
 322cf38:	e0bffb0b 	ldhu	r2,-20(fp)
 322cf3c:	d8800015 	stw	r2,0(sp)
 322cf40:	00800044 	movi	r2,1
 322cf44:	d8800115 	stw	r2,4(sp)
 322cf48:	0100c9b4 	movhi	r4,806
 322cf4c:	2133bf04 	addi	r4,r4,-12548
 322cf50:	e17ffc17 	ldw	r5,-16(fp)
 322cf54:	e1fffd17 	ldw	r7,-12(fp)
 322cf58:	32485240 	call	3248524 <in_pcblookup>
 322cf5c:	e0bffa15 	stw	r2,-24(fp)
      if (inp == 0)
 322cf60:	e0bffa17 	ldw	r2,-24(fp)
 322cf64:	1005003a 	cmpeq	r2,r2,zero
 322cf68:	10005f1e 	bne	r2,zero,322d0e8 <so_icmpdu+0x32c>
         goto done;
      so = inp->inp_socket;
 322cf6c:	e0bffa17 	ldw	r2,-24(fp)
 322cf70:	10800817 	ldw	r2,32(r2)
 322cf74:	e0bff915 	stw	r2,-28(fp)
      if (so == 0)
 322cf78:	e0bff917 	ldw	r2,-28(fp)
 322cf7c:	1005003a 	cmpeq	r2,r2,zero
 322cf80:	1000591e 	bne	r2,zero,322d0e8 <so_icmpdu+0x32c>
         goto done;
      tp = intotcpcb(inp);
 322cf84:	e0bffa17 	ldw	r2,-24(fp)
 322cf88:	10800917 	ldw	r2,36(r2)
 322cf8c:	e0bff815 	stw	r2,-32(fp)
      if (tp)
 322cf90:	e0bff817 	ldw	r2,-32(fp)
 322cf94:	1005003a 	cmpeq	r2,r2,zero
 322cf98:	1000061e 	bne	r2,zero,322cfb4 <so_icmpdu+0x1f8>
      {
         if (tp->t_state <= TCPS_LISTEN)
 322cf9c:	e0bff817 	ldw	r2,-32(fp)
 322cfa0:	10800217 	ldw	r2,8(r2)
 322cfa4:	10800090 	cmplti	r2,r2,2
 322cfa8:	10004f1e 	bne	r2,zero,322d0e8 <so_icmpdu+0x32c>
               goto done;
        }
   }
#endif

         tcp_close(tp);
 322cfac:	e13ff817 	ldw	r4,-32(fp)
 322cfb0:	3237e640 	call	3237e64 <tcp_close>
      }
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 322cfb4:	e0fff917 	ldw	r3,-28(fp)
 322cfb8:	00801bc4 	movi	r2,111
 322cfbc:	18800615 	stw	r2,24(r3)
 322cfc0:	00004906 	br	322d0e8 <so_icmpdu+0x32c>
   }   
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
 322cfc4:	e0bfff17 	ldw	r2,-4(fp)
 322cfc8:	10800443 	ldbu	r2,17(r2)
 322cfcc:	10803fcc 	andi	r2,r2,255
 322cfd0:	10800458 	cmpnei	r2,r2,17
 322cfd4:	1000441e 	bne	r2,zero,322d0e8 <so_icmpdu+0x32c>
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 322cfd8:	0080c974 	movhi	r2,805
 322cfdc:	10924a04 	addi	r2,r2,18728
 322cfe0:	10800017 	ldw	r2,0(r2)
 322cfe4:	e0bff715 	stw	r2,-36(fp)
 322cfe8:	00002406 	br	322d07c <so_icmpdu+0x2c0>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 322cfec:	e0bff717 	ldw	r2,-36(fp)
 322cff0:	1080020b 	ldhu	r2,8(r2)
 322cff4:	10ffffcc 	andi	r3,r2,65535
 322cff8:	e0bffb8b 	ldhu	r2,-18(fp)
 322cffc:	18800526 	beq	r3,r2,322d014 <so_icmpdu+0x258>
 322d000:	e0bff717 	ldw	r2,-36(fp)
 322d004:	1080020b 	ldhu	r2,8(r2)
 322d008:	10bfffcc 	andi	r2,r2,65535
 322d00c:	1004c03a 	cmpne	r2,r2,zero
 322d010:	1000171e 	bne	r2,zero,322d070 <so_icmpdu+0x2b4>
 322d014:	e0bff717 	ldw	r2,-36(fp)
 322d018:	11000417 	ldw	r4,16(r2)
 322d01c:	e0bffc17 	ldw	r2,-16(fp)
 322d020:	1004d63a 	srli	r2,r2,24
 322d024:	10c03fcc 	andi	r3,r2,255
 322d028:	e0bffc17 	ldw	r2,-16(fp)
 322d02c:	1004d23a 	srli	r2,r2,8
 322d030:	10bfc00c 	andi	r2,r2,65280
 322d034:	1886b03a 	or	r3,r3,r2
 322d038:	e0bffc17 	ldw	r2,-16(fp)
 322d03c:	10bfc00c 	andi	r2,r2,65280
 322d040:	1004923a 	slli	r2,r2,8
 322d044:	1886b03a 	or	r3,r3,r2
 322d048:	e0bffc17 	ldw	r2,-16(fp)
 322d04c:	10803fcc 	andi	r2,r2,255
 322d050:	1004963a 	slli	r2,r2,24
 322d054:	1884b03a 	or	r2,r3,r2
 322d058:	2080051e 	bne	r4,r2,322d070 <so_icmpdu+0x2b4>
 322d05c:	e0bff717 	ldw	r2,-36(fp)
 322d060:	1080018b 	ldhu	r2,6(r2)
 322d064:	10ffffcc 	andi	r3,r2,65535
 322d068:	e0bffb0b 	ldhu	r2,-20(fp)
 322d06c:	18800626 	beq	r3,r2,322d088 <so_icmpdu+0x2cc>
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 322d070:	e0bff717 	ldw	r2,-36(fp)
 322d074:	10800017 	ldw	r2,0(r2)
 322d078:	e0bff715 	stw	r2,-36(fp)
 322d07c:	e0bff717 	ldw	r2,-36(fp)
 322d080:	1004c03a 	cmpne	r2,r2,zero
 322d084:	103fd91e 	bne	r2,zero,322cfec <so_icmpdu+0x230>
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
         }
      if (!tmp) 
 322d088:	e0bff717 	ldw	r2,-36(fp)
 322d08c:	1005003a 	cmpeq	r2,r2,zero
 322d090:	1000151e 	bne	r2,zero,322d0e8 <so_icmpdu+0x32c>
         goto done;
      so = (struct socket *)tmp->u_data;
 322d094:	e0bff717 	ldw	r2,-36(fp)
 322d098:	10800617 	ldw	r2,24(r2)
 322d09c:	e0bff915 	stw	r2,-28(fp)
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
 322d0a0:	e0bff917 	ldw	r2,-28(fp)
 322d0a4:	10800983 	ldbu	r2,38(r2)
 322d0a8:	10803fcc 	andi	r2,r2,255
 322d0ac:	1080201c 	xori	r2,r2,128
 322d0b0:	10bfe004 	addi	r2,r2,-128
 322d0b4:	10800098 	cmpnei	r2,r2,2
 322d0b8:	10000b1e 	bne	r2,zero,322d0e8 <so_icmpdu+0x32c>
         goto done;
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 322d0bc:	e0fff917 	ldw	r3,-28(fp)
 322d0c0:	00801bc4 	movi	r2,111
 322d0c4:	18800615 	stw	r2,24(r3)
      /* do a select() notify on socket here */
      sorwakeup(so);
 322d0c8:	e0bff917 	ldw	r2,-28(fp)
 322d0cc:	11400a04 	addi	r5,r2,40
 322d0d0:	e13ff917 	ldw	r4,-28(fp)
 322d0d4:	3231f0c0 	call	3231f0c <sbwakeup>
      sowwakeup(so);
 322d0d8:	e0bff917 	ldw	r2,-28(fp)
 322d0dc:	11401204 	addi	r5,r2,72
 322d0e0:	e13ff917 	ldw	r4,-28(fp)
 322d0e4:	3231f0c0 	call	3231f0c <sbwakeup>
   if (pdp->dcode == DSTFRAG)
      pmtucache_set(pdp->dip.ip_dest, htons(pdp->dno2));
#endif   /* IP_PMTU */

done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
 322d0e8:	01000084 	movi	r4,2
 322d0ec:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   pk_free(p); /* done with original packet */
 322d0f0:	e13ffe17 	ldw	r4,-8(fp)
 322d0f4:	322a2dc0 	call	322a2dc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322d0f8:	01000084 	movi	r4,2
 322d0fc:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   return;
}
 322d100:	e037883a 	mov	sp,fp
 322d104:	dfc00117 	ldw	ra,4(sp)
 322d108:	df000017 	ldw	fp,0(sp)
 322d10c:	dec00204 	addi	sp,sp,8
 322d110:	f800283a 	ret

0322d114 <tcp_tick>:
unsigned long nextslow = 0L;     /* next slow tcp timer time */
static int in_tcptick = 0;       /* reentry gaurd */

void
tcp_tick()
{
 322d114:	defffe04 	addi	sp,sp,-8
 322d118:	dfc00115 	stw	ra,4(sp)
 322d11c:	df000015 	stw	fp,0(sp)
 322d120:	d839883a 	mov	fp,sp
   /* guard against re-entry */
   if (in_tcptick)
 322d124:	d0a8e417 	ldw	r2,-23664(gp)
 322d128:	1004c03a 	cmpne	r2,r2,zero
 322d12c:	1000151e 	bne	r2,zero,322d184 <tcp_tick+0x70>
      return;
   in_tcptick++;
 322d130:	d0a8e417 	ldw	r2,-23664(gp)
 322d134:	10800044 	addi	r2,r2,1
 322d138:	d0a8e415 	stw	r2,-23664(gp)

   LOCK_NET_RESOURCE(NET_RESID);
 322d13c:	0009883a 	mov	r4,zero
 322d140:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>

   if (cticks >= nextslow) /* time to do it again */
 322d144:	0080c974 	movhi	r2,805
 322d148:	10925604 	addi	r2,r2,18776
 322d14c:	10c00017 	ldw	r3,0(r2)
 322d150:	d0a8e317 	ldw	r2,-23668(gp)
 322d154:	18800636 	bltu	r3,r2,322d170 <tcp_tick+0x5c>
   {
      tcp_slowtimo();      /* call routine in BSD tcp_timr.c */
 322d158:	32380900 	call	3238090 <tcp_slowtimo>
#ifdef CSUM_DEMO
      nextslow = cticks + (TPS/5);  /* another 200 ms */
#else
      nextslow = cticks + (TPS/2);  /* another 500 ms */
 322d15c:	0080c974 	movhi	r2,805
 322d160:	10925604 	addi	r2,r2,18776
 322d164:	10800017 	ldw	r2,0(r2)
 322d168:	10807d04 	addi	r2,r2,500
 322d16c:	d0a8e315 	stw	r2,-23668(gp)

#ifdef DO_DELAY_ACKS
   tcp_fasttimo();
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);
 322d170:	0009883a 	mov	r4,zero
 322d174:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   in_tcptick--;
 322d178:	d0a8e417 	ldw	r2,-23664(gp)
 322d17c:	10bfffc4 	addi	r2,r2,-1
 322d180:	d0a8e415 	stw	r2,-23664(gp)
}
 322d184:	e037883a 	mov	sp,fp
 322d188:	dfc00117 	ldw	ra,4(sp)
 322d18c:	df000017 	ldw	fp,0(sp)
 322d190:	dec00204 	addi	sp,sp,8
 322d194:	f800283a 	ret

0322d198 <rawip_lookup>:
 *          or NULL if no matching raw IP endpoint is found.
 */

struct ipraw_ep *
rawip_lookup(struct socket * so)
{
 322d198:	defffc04 	addi	sp,sp,-16
 322d19c:	df000315 	stw	fp,12(sp)
 322d1a0:	df000304 	addi	fp,sp,12
 322d1a4:	e13ffe15 	stw	r4,-8(fp)
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 322d1a8:	0080c974 	movhi	r2,805
 322d1ac:	10927d04 	addi	r2,r2,18932
 322d1b0:	10800017 	ldw	r2,0(r2)
 322d1b4:	e0bffd15 	stw	r2,-12(fp)
 322d1b8:	00000a06 	br	322d1e4 <rawip_lookup+0x4c>
      if (tmp->ipr_data == (void*)so)
 322d1bc:	e0bffd17 	ldw	r2,-12(fp)
 322d1c0:	10c00417 	ldw	r3,16(r2)
 322d1c4:	e0bffe17 	ldw	r2,-8(fp)
 322d1c8:	1880031e 	bne	r3,r2,322d1d8 <rawip_lookup+0x40>
      return (tmp);
 322d1cc:	e0bffd17 	ldw	r2,-12(fp)
 322d1d0:	e0bfff15 	stw	r2,-4(fp)
 322d1d4:	00000706 	br	322d1f4 <rawip_lookup+0x5c>
struct ipraw_ep *
rawip_lookup(struct socket * so)
{
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 322d1d8:	e0bffd17 	ldw	r2,-12(fp)
 322d1dc:	10800017 	ldw	r2,0(r2)
 322d1e0:	e0bffd15 	stw	r2,-12(fp)
 322d1e4:	e0bffd17 	ldw	r2,-12(fp)
 322d1e8:	1004c03a 	cmpne	r2,r2,zero
 322d1ec:	103ff31e 	bne	r2,zero,322d1bc <rawip_lookup+0x24>
      if (tmp->ipr_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 322d1f0:	e03fff15 	stw	zero,-4(fp)
 322d1f4:	e0bfff17 	ldw	r2,-4(fp)
}
 322d1f8:	e037883a 	mov	sp,fp
 322d1fc:	df000017 	ldw	fp,0(sp)
 322d200:	dec00104 	addi	sp,sp,4
 322d204:	f800283a 	ret

0322d208 <rawip_soinput>:
 *          indicates that the packet has not been accepted.
 */

int
rawip_soinput(PACKET pkt, void * so_ptr)
{
 322d208:	defff404 	addi	sp,sp,-48
 322d20c:	dfc00b15 	stw	ra,44(sp)
 322d210:	df000a15 	stw	fp,40(sp)
 322d214:	df000a04 	addi	fp,sp,40
 322d218:	e13ffd15 	stw	r4,-12(fp)
 322d21c:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 322d220:	e0bffe17 	ldw	r2,-8(fp)
 322d224:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;

   LOCK_NET_RESOURCE(NET_RESID); 
 322d228:	0009883a 	mov	r4,zero
 322d22c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 322d230:	e0bff717 	ldw	r2,-36(fp)
 322d234:	10c00a17 	ldw	r3,40(r2)
 322d238:	e0bffd17 	ldw	r2,-12(fp)
 322d23c:	10800417 	ldw	r2,16(r2)
 322d240:	1887883a 	add	r3,r3,r2
 322d244:	e0bff717 	ldw	r2,-36(fp)
 322d248:	10800b17 	ldw	r2,44(r2)
 322d24c:	18800536 	bltu	r3,r2,322d264 <rawip_soinput+0x5c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 322d250:	0009883a 	mov	r4,zero
 322d254:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 322d258:	00801a44 	movi	r2,105
 322d25c:	e0bfff15 	stw	r2,-4(fp)
 322d260:	00005806 	br	322d3c4 <rawip_soinput+0x1bc>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 322d264:	01000044 	movi	r4,1
 322d268:	000b883a 	mov	r5,zero
 322d26c:	322b98c0 	call	322b98c <m_getnbuf>
 322d270:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 322d274:	e0bff817 	ldw	r2,-32(fp)
 322d278:	1004c03a 	cmpne	r2,r2,zero
 322d27c:	1000051e 	bne	r2,zero,322d294 <rawip_soinput+0x8c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 322d280:	0009883a 	mov	r4,zero
 322d284:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 322d288:	00801a44 	movi	r2,105
 322d28c:	e0bfff15 	stw	r2,-4(fp)
 322d290:	00004c06 	br	322d3c4 <rawip_soinput+0x1bc>
   }

   /* set data mbuf to point to start of IP header */
   m_in->pkt = pkt;
 322d294:	e0fff817 	ldw	r3,-32(fp)
 322d298:	e0bffd17 	ldw	r2,-12(fp)
 322d29c:	18800115 	stw	r2,4(r3)
   m_in->m_base = pkt->nb_buff;
 322d2a0:	e0bffd17 	ldw	r2,-12(fp)
 322d2a4:	10c00117 	ldw	r3,4(r2)
 322d2a8:	e0bff817 	ldw	r2,-32(fp)
 322d2ac:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 322d2b0:	e0bffd17 	ldw	r2,-12(fp)
 322d2b4:	10c00217 	ldw	r3,8(r2)
 322d2b8:	e0bff817 	ldw	r2,-32(fp)
 322d2bc:	10c00515 	stw	r3,20(r2)
   m_in->m_data = pkt->nb_prot;
 322d2c0:	e0bffd17 	ldw	r2,-12(fp)
 322d2c4:	10c00317 	ldw	r3,12(r2)
 322d2c8:	e0bff817 	ldw	r2,-32(fp)
 322d2cc:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 322d2d0:	e0bffd17 	ldw	r2,-12(fp)
 322d2d4:	10c00417 	ldw	r3,16(r2)
 322d2d8:	e0bff817 	ldw	r2,-32(fp)
 322d2dc:	10c00215 	stw	r3,8(r2)

   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
 322d2e0:	e0bff717 	ldw	r2,-36(fp)
 322d2e4:	10800417 	ldw	r2,16(r2)
 322d2e8:	1088000c 	andi	r2,r2,8192
 322d2ec:	1004c03a 	cmpne	r2,r2,zero
 322d2f0:	1000141e 	bne	r2,zero,322d344 <rawip_soinput+0x13c>
   {
      unsigned int ihl = 
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
 322d2f4:	e0bffd17 	ldw	r2,-12(fp)
 322d2f8:	10800317 	ldw	r2,12(r2)
 322d2fc:	10800003 	ldbu	r2,0(r2)
 322d300:	10803fcc 	andi	r2,r2,255
 322d304:	108003cc 	andi	r2,r2,15
 322d308:	1085883a 	add	r2,r2,r2
 322d30c:	1085883a 	add	r2,r2,r2
 322d310:	e0bff615 	stw	r2,-40(fp)
      m_in->m_data += ihl;
 322d314:	e0bff817 	ldw	r2,-32(fp)
 322d318:	10c00317 	ldw	r3,12(r2)
 322d31c:	e0bff617 	ldw	r2,-40(fp)
 322d320:	1887883a 	add	r3,r3,r2
 322d324:	e0bff817 	ldw	r2,-32(fp)
 322d328:	10c00315 	stw	r3,12(r2)
      m_in->m_len -= ihl;
 322d32c:	e0bff817 	ldw	r2,-32(fp)
 322d330:	10c00217 	ldw	r3,8(r2)
 322d334:	e0bff617 	ldw	r2,-40(fp)
 322d338:	1887c83a 	sub	r3,r3,r2
 322d33c:	e0bff817 	ldw	r2,-32(fp)
 322d340:	10c00215 	stw	r3,8(r2)
   }

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 322d344:	e0bffd17 	ldw	r2,-12(fp)
 322d348:	10800717 	ldw	r2,28(r2)
 322d34c:	e0bffa15 	stw	r2,-24(fp)
   sin.sin_port = 0;
 322d350:	e03ff98d 	sth	zero,-26(fp)
   sin.sin_family = AF_INET;
 322d354:	00800084 	movi	r2,2
 322d358:	e0bff90d 	sth	r2,-28(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 322d35c:	e0bff717 	ldw	r2,-36(fp)
 322d360:	11000a04 	addi	r4,r2,40
 322d364:	e17ff904 	addi	r5,fp,-28
 322d368:	e1bff817 	ldw	r6,-32(fp)
 322d36c:	32322580 	call	3232258 <sbappendaddr>
 322d370:	1004c03a 	cmpne	r2,r2,zero
 322d374:	1000091e 	bne	r2,zero,322d39c <rawip_soinput+0x194>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       * underlying stack
       */
      m_in->pkt = NULL;
 322d378:	e0bff817 	ldw	r2,-32(fp)
 322d37c:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 322d380:	e13ff817 	ldw	r4,-32(fp)
 322d384:	322bb340 	call	322bb34 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 322d388:	0009883a 	mov	r4,zero
 322d38c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 322d390:	00801a44 	movi	r2,105
 322d394:	e0bfff15 	stw	r2,-4(fp)
 322d398:	00000a06 	br	322d3c4 <rawip_soinput+0x1bc>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 322d39c:	e0bff717 	ldw	r2,-36(fp)
 322d3a0:	11000a04 	addi	r4,r2,40
 322d3a4:	32269000 	call	3226900 <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 322d3a8:	e0bff717 	ldw	r2,-36(fp)
 322d3ac:	11400a04 	addi	r5,r2,40
 322d3b0:	e13ff717 	ldw	r4,-36(fp)
 322d3b4:	3231f0c0 	call	3231f0c <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 322d3b8:	0009883a 	mov	r4,zero
 322d3bc:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   return 0;
 322d3c0:	e03fff15 	stw	zero,-4(fp)
 322d3c4:	e0bfff17 	ldw	r2,-4(fp)
}
 322d3c8:	e037883a 	mov	sp,fp
 322d3cc:	dfc00117 	ldw	ra,4(sp)
 322d3d0:	df000017 	ldw	fp,0(sp)
 322d3d4:	dec00204 	addi	sp,sp,8
 322d3d8:	f800283a 	ret

0322d3dc <rawip_usrreq>:

int
rawip_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 322d3dc:	deffee04 	addi	sp,sp,-72
 322d3e0:	dfc01115 	stw	ra,68(sp)
 322d3e4:	df001015 	stw	fp,64(sp)
 322d3e8:	dc000f15 	stw	r16,60(sp)
 322d3ec:	df000f04 	addi	fp,sp,60
 322d3f0:	e13ffc15 	stw	r4,-16(fp)
 322d3f4:	e17ffd15 	stw	r5,-12(fp)
 322d3f8:	e1bffe15 	stw	r6,-8(fp)
   u_char prot;
   struct ip * pip;
   int   req;
   NET   ifp;     /* ptr to network interface structure */

   req = so->so_req;    /* get request from socket struct */
 322d3fc:	e0bffc17 	ldw	r2,-16(fp)
 322d400:	10800717 	ldw	r2,28(r2)
 322d404:	e0bff315 	stw	r2,-52(fp)

   switch (req) 
 322d408:	e0bff317 	ldw	r2,-52(fp)
 322d40c:	10800468 	cmpgeui	r2,r2,17
 322d410:	1001e31e 	bne	r2,zero,322dba0 <rawip_usrreq+0x7c4>
 322d414:	e0bff317 	ldw	r2,-52(fp)
 322d418:	1085883a 	add	r2,r2,r2
 322d41c:	1087883a 	add	r3,r2,r2
 322d420:	0080c8f4 	movhi	r2,803
 322d424:	10b50d04 	addi	r2,r2,-11212
 322d428:	1885883a 	add	r2,r3,r2
 322d42c:	10800017 	ldw	r2,0(r2)
 322d430:	1000683a 	jmp	r2
 322d434:	0322d478 	rdprs	r12,zero,-29871
 322d438:	0322d500 	call	322d50 <OSCtxSw_SWITCH_PC+0x322d10>
 322d43c:	0322d544 	movi	r12,-29867
 322d440:	0322dba0 	cmpeqi	r12,zero,-29842
 322d444:	0322d544 	movi	r12,-29867
 322d448:	0322dba0 	cmpeqi	r12,zero,-29842
 322d44c:	0322db94 	movui	r12,35694
 322d450:	0322dba0 	cmpeqi	r12,zero,-29842
 322d454:	0322db94 	movui	r12,35694
 322d458:	0322d6f8 	rdprs	r12,zero,-29861
 322d45c:	0322dba0 	cmpeqi	r12,zero,-29842
 322d460:	0322dba0 	cmpeqi	r12,zero,-29842
 322d464:	0322dba0 	cmpeqi	r12,zero,-29842
 322d468:	0322dba0 	cmpeqi	r12,zero,-29842
 322d46c:	0322dba0 	cmpeqi	r12,zero,-29842
 322d470:	0322dae8 	cmpgeui	r12,zero,35691
 322d474:	0322dae8 	cmpgeui	r12,zero,35691
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
 322d478:	e0bffc17 	ldw	r2,-16(fp)
 322d47c:	10800417 	ldw	r2,16(r2)
 322d480:	1108000c 	andi	r4,r2,8192
 322d484:	3243d340 	call	3243d34 <ip_raw_maxalloc>
 322d488:	1007883a 	mov	r3,r2
 322d48c:	e0bffc17 	ldw	r2,-16(fp)
 322d490:	10c01315 	stw	r3,76(r2)
 322d494:	e0bffc17 	ldw	r2,-16(fp)
 322d498:	10c01317 	ldw	r3,76(r2)
 322d49c:	e0bffc17 	ldw	r2,-16(fp)
 322d4a0:	10c00b15 	stw	r3,44(r2)
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
      /* make a raw IP endpoint */
      prot = (u_char)(MBUF2LONG(nam));
 322d4a4:	e0bffe17 	ldw	r2,-8(fp)
 322d4a8:	e0bff505 	stb	r2,-44(fp)
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 322d4ac:	0009883a 	mov	r4,zero
 322d4b0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      ep = ip_raw_open(prot, 0L, 0L, rawip_soinput, so);
 322d4b4:	e13ff503 	ldbu	r4,-44(fp)
 322d4b8:	e0bffc17 	ldw	r2,-16(fp)
 322d4bc:	d8800015 	stw	r2,0(sp)
 322d4c0:	000b883a 	mov	r5,zero
 322d4c4:	000d883a 	mov	r6,zero
 322d4c8:	01c0c8f4 	movhi	r7,803
 322d4cc:	39f48204 	addi	r7,r7,-11768
 322d4d0:	32438400 	call	3243840 <ip_raw_open>
 322d4d4:	e0bff815 	stw	r2,-32(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 322d4d8:	0009883a 	mov	r4,zero
 322d4dc:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      if (!ep)
 322d4e0:	e0bff817 	ldw	r2,-32(fp)
 322d4e4:	1004c03a 	cmpne	r2,r2,zero
 322d4e8:	1000031e 	bne	r2,zero,322d4f8 <rawip_usrreq+0x11c>
         return(EINVAL);
 322d4ec:	00800584 	movi	r2,22
 322d4f0:	e0bfff15 	stw	r2,-4(fp)
 322d4f4:	0001ac06 	br	322dba8 <rawip_usrreq+0x7cc>
      return 0;
 322d4f8:	e03fff15 	stw	zero,-4(fp)
 322d4fc:	0001aa06 	br	322dba8 <rawip_usrreq+0x7cc>
   case PRU_DETACH:
      /* delete the raw IP endpoint */
      ep = rawip_lookup(so);
 322d500:	e13ffc17 	ldw	r4,-16(fp)
 322d504:	322d1980 	call	322d198 <rawip_lookup>
 322d508:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 322d50c:	e0bff817 	ldw	r2,-32(fp)
 322d510:	1004c03a 	cmpne	r2,r2,zero
 322d514:	1000031e 	bne	r2,zero,322d524 <rawip_usrreq+0x148>
         return(EINVAL);
 322d518:	00800584 	movi	r2,22
 322d51c:	e0bfff15 	stw	r2,-4(fp)
 322d520:	0001a106 	br	322dba8 <rawip_usrreq+0x7cc>
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 322d524:	0009883a 	mov	r4,zero
 322d528:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      ip_raw_close(ep);
 322d52c:	e13ff817 	ldw	r4,-32(fp)
 322d530:	32439300 	call	3243930 <ip_raw_close>
      LOCK_NET_RESOURCE(NET_RESID);
 322d534:	0009883a 	mov	r4,zero
 322d538:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      return 0;
 322d53c:	e03fff15 	stw	zero,-4(fp)
 322d540:	00019906 	br	322dba8 <rawip_usrreq+0x7cc>
       * a default address for sending
       */
      /* fall through to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 322d544:	e0bffe17 	ldw	r2,-8(fp)
 322d548:	1004c03a 	cmpne	r2,r2,zero
 322d54c:	1000031e 	bne	r2,zero,322d55c <rawip_usrreq+0x180>
         return(EINVAL);
 322d550:	00800584 	movi	r2,22
 322d554:	e0bfff15 	stw	r2,-4(fp)
 322d558:	00019306 	br	322dba8 <rawip_usrreq+0x7cc>
      sin = mtod(nam, struct sockaddr_in *);
 322d55c:	e0bffe17 	ldw	r2,-8(fp)
 322d560:	10800317 	ldw	r2,12(r2)
 322d564:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 322d568:	e0bff917 	ldw	r2,-28(fp)
 322d56c:	1004c03a 	cmpne	r2,r2,zero
 322d570:	1000031e 	bne	r2,zero,322d580 <rawip_usrreq+0x1a4>
         return(EINVAL);
 322d574:	00800584 	movi	r2,22
 322d578:	e0bfff15 	stw	r2,-4(fp)
 322d57c:	00018a06 	br	322dba8 <rawip_usrreq+0x7cc>
      if (nam->m_len != sizeof (*sin))
 322d580:	e0bffe17 	ldw	r2,-8(fp)
 322d584:	10800217 	ldw	r2,8(r2)
 322d588:	10800420 	cmpeqi	r2,r2,16
 322d58c:	1000031e 	bne	r2,zero,322d59c <rawip_usrreq+0x1c0>
         return(EINVAL);
 322d590:	00800584 	movi	r2,22
 322d594:	e0bfff15 	stw	r2,-4(fp)
 322d598:	00018306 	br	322dba8 <rawip_usrreq+0x7cc>
      ep = rawip_lookup(so);
 322d59c:	e13ffc17 	ldw	r4,-16(fp)
 322d5a0:	322d1980 	call	322d198 <rawip_lookup>
 322d5a4:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 322d5a8:	e0bff817 	ldw	r2,-32(fp)
 322d5ac:	1004c03a 	cmpne	r2,r2,zero
 322d5b0:	1000031e 	bne	r2,zero,322d5c0 <rawip_usrreq+0x1e4>
         return(EINVAL);
 322d5b4:	00800584 	movi	r2,22
 322d5b8:	e0bfff15 	stw	r2,-4(fp)
 322d5bc:	00017a06 	br	322dba8 <rawip_usrreq+0x7cc>
      if (req == PRU_BIND)
 322d5c0:	e0bff317 	ldw	r2,-52(fp)
 322d5c4:	10800098 	cmpnei	r2,r2,2
 322d5c8:	1000221e 	bne	r2,zero,322d654 <rawip_usrreq+0x278>
          * if the caller-supplied address is INADDR_ANY,
          * don't bind to a specific address; else, 
          * make sure the caller-supplied address is
          * an interface IP address and if so, bind to that
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 322d5cc:	e0bff917 	ldw	r2,-28(fp)
 322d5d0:	10800117 	ldw	r2,4(r2)
 322d5d4:	1004c03a 	cmpne	r2,r2,zero
 322d5d8:	1000021e 	bne	r2,zero,322d5e4 <rawip_usrreq+0x208>
         {
            lhost = 0L;
 322d5dc:	e03ff615 	stw	zero,-40(fp)
 322d5e0:	00001806 	br	322d644 <rawip_usrreq+0x268>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
 322d5e4:	e0bff917 	ldw	r2,-28(fp)
 322d5e8:	10800117 	ldw	r2,4(r2)
 322d5ec:	e0bff615 	stw	r2,-40(fp)
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 322d5f0:	0080c9b4 	movhi	r2,806
 322d5f4:	10b45b04 	addi	r2,r2,-11924
 322d5f8:	10800017 	ldw	r2,0(r2)
 322d5fc:	e0bff215 	stw	r2,-56(fp)
 322d600:	00000706 	br	322d620 <rawip_usrreq+0x244>
               if (ifp->n_ipaddr == lhost)
 322d604:	e0bff217 	ldw	r2,-56(fp)
 322d608:	10c00a17 	ldw	r3,40(r2)
 322d60c:	e0bff617 	ldw	r2,-40(fp)
 322d610:	18800626 	beq	r3,r2,322d62c <rawip_usrreq+0x250>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 322d614:	e0bff217 	ldw	r2,-56(fp)
 322d618:	10800017 	ldw	r2,0(r2)
 322d61c:	e0bff215 	stw	r2,-56(fp)
 322d620:	e0bff217 	ldw	r2,-56(fp)
 322d624:	1004c03a 	cmpne	r2,r2,zero
 322d628:	103ff61e 	bne	r2,zero,322d604 <rawip_usrreq+0x228>
               if (ifp->n_ipaddr == lhost)
                  break;
            if (ifp == NULL)
 322d62c:	e0bff217 	ldw	r2,-56(fp)
 322d630:	1004c03a 	cmpne	r2,r2,zero
 322d634:	1000031e 	bne	r2,zero,322d644 <rawip_usrreq+0x268>
               return(EADDRNOTAVAIL);
 322d638:	00801f44 	movi	r2,125
 322d63c:	e0bfff15 	stw	r2,-4(fp)
 322d640:	00015906 	br	322dba8 <rawip_usrreq+0x7cc>
         }

         /* bind the endpoint */
         ep->ipr_laddr = lhost;
 322d644:	e0fff817 	ldw	r3,-32(fp)
 322d648:	e0bff617 	ldw	r2,-40(fp)
 322d64c:	18800115 	stw	r2,4(r3)
 322d650:	00002706 	br	322d6f0 <rawip_usrreq+0x314>
          *
          * if the caller-supplied address is INADDR_ANY,
          * use the wildcard address; else, use the caller-
          * supplied address
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 322d654:	e0bff917 	ldw	r2,-28(fp)
 322d658:	10800117 	ldw	r2,4(r2)
 322d65c:	1004c03a 	cmpne	r2,r2,zero
 322d660:	1000021e 	bne	r2,zero,322d66c <rawip_usrreq+0x290>
            fhost = 0L;
 322d664:	e03ff715 	stw	zero,-36(fp)
 322d668:	00000306 	br	322d678 <rawip_usrreq+0x29c>
         else
            fhost = sin->sin_addr.s_addr;
 322d66c:	e0bff917 	ldw	r2,-28(fp)
 322d670:	10800117 	ldw	r2,4(r2)
 322d674:	e0bff715 	stw	r2,-36(fp)
         /* connect the IP endpoint */
         ep->ipr_faddr = fhost;
 322d678:	e0fff817 	ldw	r3,-32(fp)
 322d67c:	e0bff717 	ldw	r2,-36(fp)
 322d680:	18800215 	stw	r2,8(r3)
         /* mark the socket as connected or disconnected, as appropriate */
         if (fhost != 0L) {
 322d684:	e0bff717 	ldw	r2,-36(fp)
 322d688:	1005003a 	cmpeq	r2,r2,zero
 322d68c:	10000e1e 	bne	r2,zero,322d6c8 <rawip_usrreq+0x2ec>
            so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 322d690:	e0bffc17 	ldw	r2,-16(fp)
 322d694:	10c0088b 	ldhu	r3,34(r2)
 322d698:	00bffcc4 	movi	r2,-13
 322d69c:	1884703a 	and	r2,r3,r2
 322d6a0:	1007883a 	mov	r3,r2
 322d6a4:	e0bffc17 	ldw	r2,-16(fp)
 322d6a8:	10c0088d 	sth	r3,34(r2)
            so->so_state |= SS_ISCONNECTED;
 322d6ac:	e0bffc17 	ldw	r2,-16(fp)
 322d6b0:	1080088b 	ldhu	r2,34(r2)
 322d6b4:	10800094 	ori	r2,r2,2
 322d6b8:	1007883a 	mov	r3,r2
 322d6bc:	e0bffc17 	ldw	r2,-16(fp)
 322d6c0:	10c0088d 	sth	r3,34(r2)
 322d6c4:	00000706 	br	322d6e4 <rawip_usrreq+0x308>
         }
         else
         {
            so->so_state &= ~SS_ISCONNECTED;
 322d6c8:	e0bffc17 	ldw	r2,-16(fp)
 322d6cc:	10c0088b 	ldhu	r3,34(r2)
 322d6d0:	00bfff44 	movi	r2,-3
 322d6d4:	1884703a 	and	r2,r3,r2
 322d6d8:	1007883a 	mov	r3,r2
 322d6dc:	e0bffc17 	ldw	r2,-16(fp)
 322d6e0:	10c0088d 	sth	r3,34(r2)
         }
         /* since socket was in listen state, packets may be queued */
         sbflush(&so->so_rcv);   /* dump these now */
 322d6e4:	e0bffc17 	ldw	r2,-16(fp)
 322d6e8:	11000a04 	addi	r4,r2,40
 322d6ec:	32326480 	call	3232648 <sbflush>
      }
      return 0;
 322d6f0:	e03fff15 	stw	zero,-4(fp)
 322d6f4:	00012c06 	br	322dba8 <rawip_usrreq+0x7cc>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 322d6f8:	e0bffd17 	ldw	r2,-12(fp)
 322d6fc:	1004c03a 	cmpne	r2,r2,zero
 322d700:	1000031e 	bne	r2,zero,322d710 <rawip_usrreq+0x334>
         return(EINVAL);
 322d704:	00800584 	movi	r2,22
 322d708:	e0bfff15 	stw	r2,-4(fp)
 322d70c:	00012606 	br	322dba8 <rawip_usrreq+0x7cc>

      ep = rawip_lookup(so);
 322d710:	e13ffc17 	ldw	r4,-16(fp)
 322d714:	322d1980 	call	322d198 <rawip_lookup>
 322d718:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 322d71c:	e0bff817 	ldw	r2,-32(fp)
 322d720:	1004c03a 	cmpne	r2,r2,zero
 322d724:	1000051e 	bne	r2,zero,322d73c <rawip_usrreq+0x360>
      {
         m_free(m);
 322d728:	e13ffd17 	ldw	r4,-12(fp)
 322d72c:	322bb340 	call	322bb34 <m_free>
         /* may be bogus socket, but more likely the connection may 
         have closed due to ICMP dest unreachable from other side. */
         return(ECONNREFUSED);
 322d730:	00801bc4 	movi	r2,111
 322d734:	e0bfff15 	stw	r2,-4(fp)
 322d738:	00011b06 	br	322dba8 <rawip_usrreq+0x7cc>
      }

      if (nam == NULL)  /* no sendto() info passed, must be send() */
 322d73c:	e0bffe17 	ldw	r2,-8(fp)
 322d740:	1004c03a 	cmpne	r2,r2,zero
 322d744:	10000d1e 	bne	r2,zero,322d77c <rawip_usrreq+0x3a0>
      {
         if (!(so->so_state & SS_ISCONNECTED))
 322d748:	e0bffc17 	ldw	r2,-16(fp)
 322d74c:	1080088b 	ldhu	r2,34(r2)
 322d750:	10bfffcc 	andi	r2,r2,65535
 322d754:	1080008c 	andi	r2,r2,2
 322d758:	1004c03a 	cmpne	r2,r2,zero
 322d75c:	1000031e 	bne	r2,zero,322d76c <rawip_usrreq+0x390>
            return (ENOTCONN);
 322d760:	00802004 	movi	r2,128
 322d764:	e0bfff15 	stw	r2,-4(fp)
 322d768:	00010f06 	br	322dba8 <rawip_usrreq+0x7cc>
         fhost = ep->ipr_faddr;
 322d76c:	e0bff817 	ldw	r2,-32(fp)
 322d770:	10800217 	ldw	r2,8(r2)
 322d774:	e0bff715 	stw	r2,-36(fp)
 322d778:	00001706 	br	322d7d8 <rawip_usrreq+0x3fc>
      }
      else 
      {
         if (so->so_state & SS_ISCONNECTED)
 322d77c:	e0bffc17 	ldw	r2,-16(fp)
 322d780:	1080088b 	ldhu	r2,34(r2)
 322d784:	10bfffcc 	andi	r2,r2,65535
 322d788:	1080008c 	andi	r2,r2,2
 322d78c:	1005003a 	cmpeq	r2,r2,zero
 322d790:	1000031e 	bne	r2,zero,322d7a0 <rawip_usrreq+0x3c4>
            return (EISCONN);
 322d794:	00801fc4 	movi	r2,127
 322d798:	e0bfff15 	stw	r2,-4(fp)
 322d79c:	00010206 	br	322dba8 <rawip_usrreq+0x7cc>
         if (nam->m_len != sizeof (*sin))
 322d7a0:	e0bffe17 	ldw	r2,-8(fp)
 322d7a4:	10800217 	ldw	r2,8(r2)
 322d7a8:	10800420 	cmpeqi	r2,r2,16
 322d7ac:	1000041e 	bne	r2,zero,322d7c0 <rawip_usrreq+0x3e4>
         {
            dtrap();
 322d7b0:	322ab8c0 	call	322ab8c <dtrap>
            return (EINVAL);
 322d7b4:	00800584 	movi	r2,22
 322d7b8:	e0bfff15 	stw	r2,-4(fp)
 322d7bc:	0000fa06 	br	322dba8 <rawip_usrreq+0x7cc>
         }
         sin = mtod(nam, struct sockaddr_in *);
 322d7c0:	e0bffe17 	ldw	r2,-8(fp)
 322d7c4:	10800317 	ldw	r2,12(r2)
 322d7c8:	e0bff915 	stw	r2,-28(fp)
         fhost = sin->sin_addr.s_addr;
 322d7cc:	e0bff917 	ldw	r2,-28(fp)
 322d7d0:	10800117 	ldw	r2,4(r2)
 322d7d4:	e0bff715 	stw	r2,-36(fp)

      /* since our pkt->nb_buff size is tied to max packet size, we 
       * assume our raw IP datagrams are always in one mbuf and that the 
       * mbuf -- but check anyway
       */
      if (m->m_len > (unsigned)ip_raw_maxalloc(so->so_options & SO_HDRINCL))
 322d7d8:	e0bffd17 	ldw	r2,-12(fp)
 322d7dc:	14000217 	ldw	r16,8(r2)
 322d7e0:	e0bffc17 	ldw	r2,-16(fp)
 322d7e4:	10800417 	ldw	r2,16(r2)
 322d7e8:	1108000c 	andi	r4,r2,8192
 322d7ec:	3243d340 	call	3243d34 <ip_raw_maxalloc>
 322d7f0:	1400042e 	bgeu	r2,r16,322d804 <rawip_usrreq+0x428>
      {
         dtrap(); /* should never happen */
 322d7f4:	322ab8c0 	call	322ab8c <dtrap>
         return EMSGSIZE;  /* try to recover */
 322d7f8:	00801e84 	movi	r2,122
 322d7fc:	e0bfff15 	stw	r2,-4(fp)
 322d800:	0000e906 	br	322dba8 <rawip_usrreq+0x7cc>
      }
      /* get a packet buffer for send */
      pkt = ip_raw_alloc(m->m_len, so->so_options & SO_HDRINCL);
 322d804:	e0bffd17 	ldw	r2,-12(fp)
 322d808:	10800217 	ldw	r2,8(r2)
 322d80c:	1009883a 	mov	r4,r2
 322d810:	e0bffc17 	ldw	r2,-16(fp)
 322d814:	10800417 	ldw	r2,16(r2)
 322d818:	1148000c 	andi	r5,r2,8192
 322d81c:	3243c280 	call	3243c28 <ip_raw_alloc>
 322d820:	e0bffa15 	stw	r2,-24(fp)
      if (!pkt)
 322d824:	e0bffa17 	ldw	r2,-24(fp)
 322d828:	1004c03a 	cmpne	r2,r2,zero
 322d82c:	1000051e 	bne	r2,zero,322d844 <rawip_usrreq+0x468>
      {
         m_free(m);
 322d830:	e13ffd17 	ldw	r4,-12(fp)
 322d834:	322bb340 	call	322bb34 <m_free>
         return ENOBUFS;   /* report buffer shortages */
 322d838:	00801a44 	movi	r2,105
 322d83c:	e0bfff15 	stw	r2,-4(fp)
 322d840:	0000d906 	br	322dba8 <rawip_usrreq+0x7cc>
      }
      MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 322d844:	e0bffa17 	ldw	r2,-24(fp)
 322d848:	10c00317 	ldw	r3,12(r2)
 322d84c:	e0bffd17 	ldw	r2,-12(fp)
 322d850:	11400317 	ldw	r5,12(r2)
 322d854:	e0bffd17 	ldw	r2,-12(fp)
 322d858:	10800217 	ldw	r2,8(r2)
 322d85c:	1809883a 	mov	r4,r3
 322d860:	100d883a 	mov	r6,r2
 322d864:	32067cc0 	call	32067cc <memcpy>
      pkt->nb_plen = m->m_len;
 322d868:	e0bffd17 	ldw	r2,-12(fp)
 322d86c:	10c00217 	ldw	r3,8(r2)
 322d870:	e0bffa17 	ldw	r2,-24(fp)
 322d874:	10c00415 	stw	r3,16(r2)
      /* finished with mbuf, free it now */
      m_free(m);
 322d878:	e13ffd17 	ldw	r4,-12(fp)
 322d87c:	322bb340 	call	322bb34 <m_free>
      pkt->fhost = fhost;
 322d880:	e0fffa17 	ldw	r3,-24(fp)
 322d884:	e0bff717 	ldw	r2,-36(fp)
 322d888:	18800715 	stw	r2,28(r3)
       * is up; if (after all that) we don't have an interface then we
       * fail with error EADDRNOTAVAIL; and finally, if we're built
       * for a single-homed configuration where there's only one
       * interface, we might as well use it, so we do.  
       */
      if (fhost == 0xffffffff)
 322d88c:	e0bff717 	ldw	r2,-36(fp)
 322d890:	10bfffd8 	cmpnei	r2,r2,-1
 322d894:	10004f1e 	bne	r2,zero,322d9d4 <rawip_usrreq+0x5f8>
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
 322d898:	e0bff817 	ldw	r2,-32(fp)
 322d89c:	10800117 	ldw	r2,4(r2)
 322d8a0:	1005003a 	cmpeq	r2,r2,zero
 322d8a4:	1000111e 	bne	r2,zero,322d8ec <rawip_usrreq+0x510>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 322d8a8:	0080c9b4 	movhi	r2,806
 322d8ac:	10b45b04 	addi	r2,r2,-11924
 322d8b0:	10800017 	ldw	r2,0(r2)
 322d8b4:	e0bff215 	stw	r2,-56(fp)
 322d8b8:	00000806 	br	322d8dc <rawip_usrreq+0x500>
               if (ifp->n_ipaddr == ep->ipr_laddr)
 322d8bc:	e0bff217 	ldw	r2,-56(fp)
 322d8c0:	10c00a17 	ldw	r3,40(r2)
 322d8c4:	e0bff817 	ldw	r2,-32(fp)
 322d8c8:	10800117 	ldw	r2,4(r2)
 322d8cc:	18802126 	beq	r3,r2,322d954 <rawip_usrreq+0x578>
      if (fhost == 0xffffffff)
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 322d8d0:	e0bff217 	ldw	r2,-56(fp)
 322d8d4:	10800017 	ldw	r2,0(r2)
 322d8d8:	e0bff215 	stw	r2,-56(fp)
 322d8dc:	e0bff217 	ldw	r2,-56(fp)
 322d8e0:	1004c03a 	cmpne	r2,r2,zero
 322d8e4:	103ff51e 	bne	r2,zero,322d8bc <rawip_usrreq+0x4e0>
 322d8e8:	00001a06 	br	322d954 <rawip_usrreq+0x578>
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 322d8ec:	0080c9b4 	movhi	r2,806
 322d8f0:	10b45b04 	addi	r2,r2,-11924
 322d8f4:	10800017 	ldw	r2,0(r2)
 322d8f8:	e0bff215 	stw	r2,-56(fp)
 322d8fc:	00001206 	br	322d948 <rawip_usrreq+0x56c>
               if ((ifp->n_flags & NF_BCAST) &&
 322d900:	e0bff217 	ldw	r2,-56(fp)
 322d904:	10802a17 	ldw	r2,168(r2)
 322d908:	1080004c 	andi	r2,r2,1
 322d90c:	10803fcc 	andi	r2,r2,255
 322d910:	1005003a 	cmpeq	r2,r2,zero
 322d914:	1000091e 	bne	r2,zero,322d93c <rawip_usrreq+0x560>
 322d918:	e0bff217 	ldw	r2,-56(fp)
 322d91c:	10802717 	ldw	r2,156(r2)
 322d920:	1005003a 	cmpeq	r2,r2,zero
 322d924:	1000051e 	bne	r2,zero,322d93c <rawip_usrreq+0x560>
 322d928:	e0bff217 	ldw	r2,-56(fp)
 322d92c:	10802717 	ldw	r2,156(r2)
 322d930:	10800617 	ldw	r2,24(r2)
 322d934:	10800060 	cmpeqi	r2,r2,1
 322d938:	1000061e 	bne	r2,zero,322d954 <rawip_usrreq+0x578>
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 322d93c:	e0bff217 	ldw	r2,-56(fp)
 322d940:	10800017 	ldw	r2,0(r2)
 322d944:	e0bff215 	stw	r2,-56(fp)
 322d948:	e0bff217 	ldw	r2,-56(fp)
 322d94c:	1004c03a 	cmpne	r2,r2,zero
 322d950:	103feb1e 	bne	r2,zero,322d900 <rawip_usrreq+0x524>
               if ((ifp->n_flags & NF_BCAST) &&
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
 322d954:	e0bff217 	ldw	r2,-56(fp)
 322d958:	1004c03a 	cmpne	r2,r2,zero
 322d95c:	10001a1e 	bne	r2,zero,322d9c8 <rawip_usrreq+0x5ec>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 322d960:	0080c9b4 	movhi	r2,806
 322d964:	10b45b04 	addi	r2,r2,-11924
 322d968:	10800017 	ldw	r2,0(r2)
 322d96c:	e0bff215 	stw	r2,-56(fp)
 322d970:	00000c06 	br	322d9a4 <rawip_usrreq+0x5c8>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 322d974:	e0bff217 	ldw	r2,-56(fp)
 322d978:	10802717 	ldw	r2,156(r2)
 322d97c:	1005003a 	cmpeq	r2,r2,zero
 322d980:	1000051e 	bne	r2,zero,322d998 <rawip_usrreq+0x5bc>
 322d984:	e0bff217 	ldw	r2,-56(fp)
 322d988:	10802717 	ldw	r2,156(r2)
 322d98c:	10800617 	ldw	r2,24(r2)
 322d990:	10800060 	cmpeqi	r2,r2,1
 322d994:	1000061e 	bne	r2,zero,322d9b0 <rawip_usrreq+0x5d4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 322d998:	e0bff217 	ldw	r2,-56(fp)
 322d99c:	10800017 	ldw	r2,0(r2)
 322d9a0:	e0bff215 	stw	r2,-56(fp)
 322d9a4:	e0bff217 	ldw	r2,-56(fp)
 322d9a8:	1004c03a 	cmpne	r2,r2,zero
 322d9ac:	103ff11e 	bne	r2,zero,322d974 <rawip_usrreq+0x598>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
            if (ifp == NULL)
 322d9b0:	e0bff217 	ldw	r2,-56(fp)
 322d9b4:	1004c03a 	cmpne	r2,r2,zero
 322d9b8:	1000031e 	bne	r2,zero,322d9c8 <rawip_usrreq+0x5ec>
               return(EADDRNOTAVAIL);
 322d9bc:	00801f44 	movi	r2,125
 322d9c0:	e0bfff15 	stw	r2,-4(fp)
 322d9c4:	00007806 	br	322dba8 <rawip_usrreq+0x7cc>
         }
         pkt->net = ifp;
 322d9c8:	e0fffa17 	ldw	r3,-24(fp)
 322d9cc:	e0bff217 	ldw	r2,-56(fp)
 322d9d0:	18800615 	stw	r2,24(r3)
#ifdef IP_MULTICAST

      /* If the socket has an IP moptions structure for multicast options,
       * place a pointer to this structure in the PACKET structure.
       */
      if (so->inp_moptions)
 322d9d4:	e0bffc17 	ldw	r2,-16(fp)
 322d9d8:	10800317 	ldw	r2,12(r2)
 322d9dc:	1005003a 	cmpeq	r2,r2,zero
 322d9e0:	1000041e 	bne	r2,zero,322d9f4 <rawip_usrreq+0x618>
         pkt->imo = so->inp_moptions;
 322d9e4:	e0bffc17 	ldw	r2,-16(fp)
 322d9e8:	10c00317 	ldw	r3,12(r2)
 322d9ec:	e0bffa17 	ldw	r2,-24(fp)
 322d9f0:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

      if (so->so_options & SO_HDRINCL)
 322d9f4:	e0bffc17 	ldw	r2,-16(fp)
 322d9f8:	10800417 	ldw	r2,16(r2)
 322d9fc:	1088000c 	andi	r2,r2,8192
 322da00:	1005003a 	cmpeq	r2,r2,zero
 322da04:	1000081e 	bne	r2,zero,322da28 <rawip_usrreq+0x64c>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 322da08:	0009883a 	mov	r4,zero
 322da0c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         e = ip_raw_write(pkt);
 322da10:	e13ffa17 	ldw	r4,-24(fp)
 322da14:	323f6080 	call	323f608 <ip_raw_write>
 322da18:	e0bffb15 	stw	r2,-20(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 322da1c:	0009883a 	mov	r4,zero
 322da20:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
 322da24:	00002806 	br	322dac8 <rawip_usrreq+0x6ec>
      }
      else
      {
         pip = (struct ip *)(pkt->nb_prot - IPHSIZ);
 322da28:	e0bffa17 	ldw	r2,-24(fp)
 322da2c:	10800317 	ldw	r2,12(r2)
 322da30:	10bffb04 	addi	r2,r2,-20
 322da34:	e0bff415 	stw	r2,-48(fp)
         if (ep->ipr_laddr)
 322da38:	e0bff817 	ldw	r2,-32(fp)
 322da3c:	10800117 	ldw	r2,4(r2)
 322da40:	1005003a 	cmpeq	r2,r2,zero
 322da44:	1000051e 	bne	r2,zero,322da5c <rawip_usrreq+0x680>
            pip->ip_src = ep->ipr_laddr;
 322da48:	e0bff817 	ldw	r2,-32(fp)
 322da4c:	10c00117 	ldw	r3,4(r2)
 322da50:	e0bff417 	ldw	r2,-48(fp)
 322da54:	10c00315 	stw	r3,12(r2)
 322da58:	00000e06 	br	322da94 <rawip_usrreq+0x6b8>
         else
         {
            if (fhost == 0xffffffff)
 322da5c:	e0bff717 	ldw	r2,-36(fp)
 322da60:	10bfffd8 	cmpnei	r2,r2,-1
 322da64:	1000061e 	bne	r2,zero,322da80 <rawip_usrreq+0x6a4>
               pip->ip_src = pkt->net->n_ipaddr;
 322da68:	e0bffa17 	ldw	r2,-24(fp)
 322da6c:	10800617 	ldw	r2,24(r2)
 322da70:	10c00a17 	ldw	r3,40(r2)
 322da74:	e0bff417 	ldw	r2,-48(fp)
 322da78:	10c00315 	stw	r3,12(r2)
 322da7c:	00000506 	br	322da94 <rawip_usrreq+0x6b8>
            else
               pip->ip_src = ip_mymach(fhost);
 322da80:	e13ff717 	ldw	r4,-36(fp)
 322da84:	324018c0 	call	324018c <ip_mymach>
 322da88:	1007883a 	mov	r3,r2
 322da8c:	e0bff417 	ldw	r2,-48(fp)
 322da90:	10c00315 	stw	r3,12(r2)
         }
         pip->ip_dest = fhost;
 322da94:	e0fff417 	ldw	r3,-48(fp)
 322da98:	e0bff717 	ldw	r2,-36(fp)
 322da9c:	18800415 	stw	r2,16(r3)
         UNLOCK_NET_RESOURCE(NET_RESID);
 322daa0:	0009883a 	mov	r4,zero
 322daa4:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         e = ip_write(ep->ipr_prot, pkt);
 322daa8:	e0bff817 	ldw	r2,-32(fp)
 322daac:	10800503 	ldbu	r2,20(r2)
 322dab0:	11003fcc 	andi	r4,r2,255
 322dab4:	e17ffa17 	ldw	r5,-24(fp)
 322dab8:	323f0100 	call	323f010 <ip_write>
 322dabc:	e0bffb15 	stw	r2,-20(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 322dac0:	0009883a 	mov	r4,zero
 322dac4:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      }         
      if (e < 0) 
 322dac8:	e0bffb17 	ldw	r2,-20(fp)
 322dacc:	1004403a 	cmpge	r2,r2,zero
 322dad0:	1000031e 	bne	r2,zero,322dae0 <rawip_usrreq+0x704>
         return(e);
 322dad4:	e0bffb17 	ldw	r2,-20(fp)
 322dad8:	e0bfff15 	stw	r2,-4(fp)
 322dadc:	00003206 	br	322dba8 <rawip_usrreq+0x7cc>
      return 0;
 322dae0:	e03fff15 	stw	zero,-4(fp)
 322dae4:	00003006 	br	322dba8 <rawip_usrreq+0x7cc>
   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 322dae8:	e0bffe17 	ldw	r2,-8(fp)
 322daec:	1004c03a 	cmpne	r2,r2,zero
 322daf0:	1000031e 	bne	r2,zero,322db00 <rawip_usrreq+0x724>
         return(EINVAL);
 322daf4:	00800584 	movi	r2,22
 322daf8:	e0bfff15 	stw	r2,-4(fp)
 322dafc:	00002a06 	br	322dba8 <rawip_usrreq+0x7cc>
      sin = mtod(nam, struct sockaddr_in *);
 322db00:	e0bffe17 	ldw	r2,-8(fp)
 322db04:	10800317 	ldw	r2,12(r2)
 322db08:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 322db0c:	e0bff917 	ldw	r2,-28(fp)
 322db10:	1004c03a 	cmpne	r2,r2,zero
 322db14:	1000031e 	bne	r2,zero,322db24 <rawip_usrreq+0x748>
         return(EINVAL);
 322db18:	00800584 	movi	r2,22
 322db1c:	e0bfff15 	stw	r2,-4(fp)
 322db20:	00002106 	br	322dba8 <rawip_usrreq+0x7cc>
      ep = rawip_lookup(so);
 322db24:	e13ffc17 	ldw	r4,-16(fp)
 322db28:	322d1980 	call	322d198 <rawip_lookup>
 322db2c:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 322db30:	e0bff817 	ldw	r2,-32(fp)
 322db34:	1004c03a 	cmpne	r2,r2,zero
 322db38:	1000031e 	bne	r2,zero,322db48 <rawip_usrreq+0x76c>
         return(EINVAL);
 322db3c:	00800584 	movi	r2,22
 322db40:	e0bfff15 	stw	r2,-4(fp)
 322db44:	00001806 	br	322dba8 <rawip_usrreq+0x7cc>
      sin->sin_port = 0;
 322db48:	e0bff917 	ldw	r2,-28(fp)
 322db4c:	1000008d 	sth	zero,2(r2)
      nam->m_len = sizeof(*sin);
 322db50:	e0fffe17 	ldw	r3,-8(fp)
 322db54:	00800404 	movi	r2,16
 322db58:	18800215 	stw	r2,8(r3)
      if (req == PRU_SOCKADDR)
 322db5c:	e0bff317 	ldw	r2,-52(fp)
 322db60:	108003d8 	cmpnei	r2,r2,15
 322db64:	1000051e 	bne	r2,zero,322db7c <rawip_usrreq+0x7a0>
      {
         sin->sin_addr.s_addr = ep->ipr_laddr;
 322db68:	e0bff817 	ldw	r2,-32(fp)
 322db6c:	10c00117 	ldw	r3,4(r2)
 322db70:	e0bff917 	ldw	r2,-28(fp)
 322db74:	10c00115 	stw	r3,4(r2)
 322db78:	00000406 	br	322db8c <rawip_usrreq+0x7b0>
      }
      else /* PRU_PEERADDR */
      {
         sin->sin_addr.s_addr = ep->ipr_faddr;
 322db7c:	e0bff817 	ldw	r2,-32(fp)
 322db80:	10c00217 	ldw	r3,8(r2)
 322db84:	e0bff917 	ldw	r2,-28(fp)
 322db88:	10c00115 	stw	r3,4(r2)
      }
      return 0;
 322db8c:	e03fff15 	stw	zero,-4(fp)
 322db90:	00000506 	br	322dba8 <rawip_usrreq+0x7cc>
   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 322db94:	322ab8c0 	call	322ab8c <dtrap>
      return 0;
 322db98:	e03fff15 	stw	zero,-4(fp)
 322db9c:	00000206 	br	322dba8 <rawip_usrreq+0x7cc>
   case PRU_LISTEN:     /* don't support these for raw IP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 322dba0:	008017c4 	movi	r2,95
 322dba4:	e0bfff15 	stw	r2,-4(fp)
 322dba8:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 322dbac:	e037883a 	mov	sp,fp
 322dbb0:	dfc00217 	ldw	ra,8(sp)
 322dbb4:	df000117 	ldw	fp,4(sp)
 322dbb8:	dc000017 	ldw	r16,0(sp)
 322dbbc:	dec00304 	addi	sp,sp,12
 322dbc0:	f800283a 	ret

0322dbc4 <DOMAIN_CHECK>:
 */

#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
 322dbc4:	defffc04 	addi	sp,sp,-16
 322dbc8:	dfc00315 	stw	ra,12(sp)
 322dbcc:	df000215 	stw	fp,8(sp)
 322dbd0:	df000204 	addi	fp,sp,8
 322dbd4:	e13ffe15 	stw	r4,-8(fp)
 322dbd8:	e17fff15 	stw	r5,-4(fp)
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 322dbdc:	e0bffe17 	ldw	r2,-8(fp)
 322dbe0:	10800517 	ldw	r2,20(r2)
 322dbe4:	10800098 	cmpnei	r2,r2,2
 322dbe8:	1000041e 	bne	r2,zero,322dbfc <DOMAIN_CHECK+0x38>
 322dbec:	e0bfff17 	ldw	r2,-4(fp)
 322dbf0:	10800428 	cmpgeui	r2,r2,16
 322dbf4:	1000011e 	bne	r2,zero,322dbfc <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
   {
      dtrap(); /* programmer passed wrong structure */
 322dbf8:	322ab8c0 	call	322ab8c <dtrap>
      (size != sizeof(struct sockaddr_in6)))
   {
      dtrap(); /* programmer passed wrong structure */
   }
#endif   /* IP_V6 */
}
 322dbfc:	e037883a 	mov	sp,fp
 322dc00:	dfc00117 	ldw	ra,4(sp)
 322dc04:	df000017 	ldw	fp,0(sp)
 322dc08:	dec00204 	addi	sp,sp,8
 322dc0c:	f800283a 	ret

0322dc10 <t_socket>:

long
t_socket(int family, 
   int   type, 
   int   proto)
{
 322dc10:	defff904 	addi	sp,sp,-28
 322dc14:	dfc00615 	stw	ra,24(sp)
 322dc18:	df000515 	stw	fp,20(sp)
 322dc1c:	df000504 	addi	fp,sp,20
 322dc20:	e13ffc15 	stw	r4,-16(fp)
 322dc24:	e17ffd15 	stw	r5,-12(fp)
 322dc28:	e1bffe15 	stw	r6,-8(fp)
   struct socket *   so;

   INET_TRACE (INETM_SOCKET, ("SOCK:sock:family %d, typ %d, proto %d\n",
    family, type, proto));
   LOCK_NET_RESOURCE(NET_RESID);
 322dc2c:	0009883a 	mov	r4,zero
 322dc30:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   if ((so = socreate (family, type, proto)) == NULL) 
 322dc34:	e13ffc17 	ldw	r4,-16(fp)
 322dc38:	e17ffd17 	ldw	r5,-12(fp)
 322dc3c:	e1bffe17 	ldw	r6,-8(fp)
 322dc40:	322f3c00 	call	322f3c0 <socreate>
 322dc44:	e0bffb15 	stw	r2,-20(fp)
 322dc48:	e0bffb17 	ldw	r2,-20(fp)
 322dc4c:	1004c03a 	cmpne	r2,r2,zero
 322dc50:	1000051e 	bne	r2,zero,322dc68 <t_socket+0x58>
   {  /* can't really return error info since no socket.... */
      UNLOCK_NET_RESOURCE(NET_RESID);
 322dc54:	0009883a 	mov	r4,zero
 322dc58:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 322dc5c:	00bfffc4 	movi	r2,-1
 322dc60:	e0bfff15 	stw	r2,-4(fp)
 322dc64:	00000806 	br	322dc88 <t_socket+0x78>
   }
   SOC_RANGE(so);
   so->so_error = 0;
 322dc68:	e0bffb17 	ldw	r2,-20(fp)
 322dc6c:	10000615 	stw	zero,24(r2)
   UNLOCK_NET_RESOURCE(NET_RESID);
 322dc70:	0009883a 	mov	r4,zero
 322dc74:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   return SO2LONG(so);
 322dc78:	e0bffb17 	ldw	r2,-20(fp)
 322dc7c:	1004d0ba 	srli	r2,r2,2
 322dc80:	10800804 	addi	r2,r2,32
 322dc84:	e0bfff15 	stw	r2,-4(fp)
 322dc88:	e0bfff17 	ldw	r2,-4(fp)
}
 322dc8c:	e037883a 	mov	sp,fp
 322dc90:	dfc00117 	ldw	ra,4(sp)
 322dc94:	df000017 	ldw	fp,0(sp)
 322dc98:	dec00204 	addi	sp,sp,8
 322dc9c:	f800283a 	ret

0322dca0 <t_bind>:

int
t_bind (long s, 
   struct sockaddr * addr,
   int addrlen)
{
 322dca0:	defff104 	addi	sp,sp,-60
 322dca4:	dfc00e15 	stw	ra,56(sp)
 322dca8:	df000d15 	stw	fp,52(sp)
 322dcac:	df000d04 	addi	fp,sp,52
 322dcb0:	e13ffc15 	stw	r4,-16(fp)
 322dcb4:	e17ffd15 	stw	r5,-12(fp)
 322dcb8:	e1bffe15 	stw	r6,-8(fp)
   struct sockaddr   sa;
   struct sockaddr * sap;
   struct socket *   so;
   int               err;

   so = LONG2SO(s);  /* convert long to socket */
 322dcbc:	e0bffc17 	ldw	r2,-16(fp)
 322dcc0:	10bff804 	addi	r2,r2,-32
 322dcc4:	1085883a 	add	r2,r2,r2
 322dcc8:	1085883a 	add	r2,r2,r2
 322dccc:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 322dcd0:	0080c9b4 	movhi	r2,806
 322dcd4:	10b39704 	addi	r2,r2,-12708
 322dcd8:	e0bff315 	stw	r2,-52(fp)
 322dcdc:	00000606 	br	322dcf8 <t_bind+0x58>
 322dce0:	e0fff317 	ldw	r3,-52(fp)
 322dce4:	e0bff517 	ldw	r2,-44(fp)
 322dce8:	18800626 	beq	r3,r2,322dd04 <t_bind+0x64>
 322dcec:	e0bff317 	ldw	r2,-52(fp)
 322dcf0:	10800017 	ldw	r2,0(r2)
 322dcf4:	e0bff315 	stw	r2,-52(fp)
 322dcf8:	e0bff317 	ldw	r2,-52(fp)
 322dcfc:	1004c03a 	cmpne	r2,r2,zero
 322dd00:	103ff71e 	bne	r2,zero,322dce0 <t_bind+0x40>
 322dd04:	e0fff317 	ldw	r3,-52(fp)
 322dd08:	e0bff517 	ldw	r2,-44(fp)
 322dd0c:	18800426 	beq	r3,r2,322dd20 <t_bind+0x80>
 322dd10:	322ab8c0 	call	322ab8c <dtrap>
 322dd14:	00bfffc4 	movi	r2,-1
 322dd18:	e0bfff15 	stw	r2,-4(fp)
 322dd1c:	00003906 	br	322de04 <t_bind+0x164>
   DOMAIN_CHECK(so, addrlen);
 322dd20:	e13ff517 	ldw	r4,-44(fp)
 322dd24:	e17ffe17 	ldw	r5,-8(fp)
 322dd28:	322dbc40 	call	322dbc4 <DOMAIN_CHECK>

   so->so_error = 0;
 322dd2c:	e0bff517 	ldw	r2,-44(fp)
 322dd30:	10000615 	stw	zero,24(r2)
   if (addr == (struct sockaddr *)NULL) 
 322dd34:	e0bffd17 	ldw	r2,-12(fp)
 322dd38:	1004c03a 	cmpne	r2,r2,zero
 322dd3c:	10000d1e 	bne	r2,zero,322dd74 <t_bind+0xd4>
   {
      MEMSET ((void *)&sa, 0, sizeof(sa));
 322dd40:	e0bff804 	addi	r2,fp,-32
 322dd44:	10000015 	stw	zero,0(r2)
 322dd48:	10000115 	stw	zero,4(r2)
 322dd4c:	10000215 	stw	zero,8(r2)
 322dd50:	10000315 	stw	zero,12(r2)
      addrlen = sizeof(sa);
 322dd54:	00800404 	movi	r2,16
 322dd58:	e0bffe15 	stw	r2,-8(fp)
      sa.sa_family = so->so_domain;
 322dd5c:	e0bff517 	ldw	r2,-44(fp)
 322dd60:	10800517 	ldw	r2,20(r2)
 322dd64:	e0bff80d 	sth	r2,-32(fp)
      sap = &sa;
 322dd68:	e0bff804 	addi	r2,fp,-32
 322dd6c:	e0bff615 	stw	r2,-40(fp)
 322dd70:	00000206 	br	322dd7c <t_bind+0xdc>
   } else
      sap = addr;
 322dd74:	e0bffd17 	ldw	r2,-12(fp)
 322dd78:	e0bff615 	stw	r2,-40(fp)

   if ((nam = sockargs (sap, addrlen, MT_SONAME)) == NULL) 
 322dd7c:	e13ff617 	ldw	r4,-40(fp)
 322dd80:	e17ffe17 	ldw	r5,-8(fp)
 322dd84:	01800244 	movi	r6,9
 322dd88:	322f28c0 	call	322f28c <sockargs>
 322dd8c:	e0bff715 	stw	r2,-36(fp)
 322dd90:	e0bff717 	ldw	r2,-36(fp)
 322dd94:	1004c03a 	cmpne	r2,r2,zero
 322dd98:	1000061e 	bne	r2,zero,322ddb4 <t_bind+0x114>
   {
      so->so_error = ENOMEM;
 322dd9c:	e0fff517 	ldw	r3,-44(fp)
 322dda0:	00800304 	movi	r2,12
 322dda4:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322dda8:	00bfffc4 	movi	r2,-1
 322ddac:	e0bfff15 	stw	r2,-4(fp)
 322ddb0:	00001406 	br	322de04 <t_bind+0x164>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 322ddb4:	0009883a 	mov	r4,zero
 322ddb8:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   err = sobind (so, nam);
 322ddbc:	e13ff517 	ldw	r4,-44(fp)
 322ddc0:	e17ff717 	ldw	r5,-36(fp)
 322ddc4:	322f58c0 	call	322f58c <sobind>
 322ddc8:	e0bff415 	stw	r2,-48(fp)
   m_freem(nam);
 322ddcc:	e13ff717 	ldw	r4,-36(fp)
 322ddd0:	322bc680 	call	322bc68 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 322ddd4:	0009883a 	mov	r4,zero
 322ddd8:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   if (err) 
 322dddc:	e0bff417 	ldw	r2,-48(fp)
 322dde0:	1005003a 	cmpeq	r2,r2,zero
 322dde4:	1000061e 	bne	r2,zero,322de00 <t_bind+0x160>
   {
      so->so_error = err;
 322dde8:	e0fff517 	ldw	r3,-44(fp)
 322ddec:	e0bff417 	ldw	r2,-48(fp)
 322ddf0:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322ddf4:	00bfffc4 	movi	r2,-1
 322ddf8:	e0bfff15 	stw	r2,-4(fp)
 322ddfc:	00000106 	br	322de04 <t_bind+0x164>
   }
   return 0;
 322de00:	e03fff15 	stw	zero,-4(fp)
 322de04:	e0bfff17 	ldw	r2,-4(fp)
}
 322de08:	e037883a 	mov	sp,fp
 322de0c:	dfc00117 	ldw	ra,4(sp)
 322de10:	df000017 	ldw	fp,0(sp)
 322de14:	dec00204 	addi	sp,sp,8
 322de18:	f800283a 	ret

0322de1c <t_listen>:
 */

int
t_listen(long s, 
   int   backlog)
{
 322de1c:	defff804 	addi	sp,sp,-32
 322de20:	dfc00715 	stw	ra,28(sp)
 322de24:	df000615 	stw	fp,24(sp)
 322de28:	df000604 	addi	fp,sp,24
 322de2c:	e13ffd15 	stw	r4,-12(fp)
 322de30:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);  /* convert long to socket */
 322de34:	e0bffd17 	ldw	r2,-12(fp)
 322de38:	10bff804 	addi	r2,r2,-32
 322de3c:	1085883a 	add	r2,r2,r2
 322de40:	1085883a 	add	r2,r2,r2
 322de44:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 322de48:	0080c9b4 	movhi	r2,806
 322de4c:	10b39704 	addi	r2,r2,-12708
 322de50:	e0bffa15 	stw	r2,-24(fp)
 322de54:	00000606 	br	322de70 <t_listen+0x54>
 322de58:	e0fffa17 	ldw	r3,-24(fp)
 322de5c:	e0bffc17 	ldw	r2,-16(fp)
 322de60:	18800626 	beq	r3,r2,322de7c <t_listen+0x60>
 322de64:	e0bffa17 	ldw	r2,-24(fp)
 322de68:	10800017 	ldw	r2,0(r2)
 322de6c:	e0bffa15 	stw	r2,-24(fp)
 322de70:	e0bffa17 	ldw	r2,-24(fp)
 322de74:	1004c03a 	cmpne	r2,r2,zero
 322de78:	103ff71e 	bne	r2,zero,322de58 <t_listen+0x3c>
 322de7c:	e0fffa17 	ldw	r3,-24(fp)
 322de80:	e0bffc17 	ldw	r2,-16(fp)
 322de84:	18800426 	beq	r3,r2,322de98 <t_listen+0x7c>
 322de88:	322ab8c0 	call	322ab8c <dtrap>
 322de8c:	00bfffc4 	movi	r2,-1
 322de90:	e0bfff15 	stw	r2,-4(fp)
 322de94:	00001406 	br	322dee8 <t_listen+0xcc>
   so->so_error = 0;
 322de98:	e0bffc17 	ldw	r2,-16(fp)
 322de9c:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("SOCK:listen:qlen %d\n", backlog));

   LOCK_NET_RESOURCE(NET_RESID);
 322dea0:	0009883a 	mov	r4,zero
 322dea4:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   err = solisten (so, backlog);
 322dea8:	e13ffc17 	ldw	r4,-16(fp)
 322deac:	e17ffe17 	ldw	r5,-8(fp)
 322deb0:	322f5e80 	call	322f5e8 <solisten>
 322deb4:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 322deb8:	0009883a 	mov	r4,zero
 322debc:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 322dec0:	e0bffb17 	ldw	r2,-20(fp)
 322dec4:	1005003a 	cmpeq	r2,r2,zero
 322dec8:	1000061e 	bne	r2,zero,322dee4 <t_listen+0xc8>
   {
      so->so_error = err;
 322decc:	e0fffc17 	ldw	r3,-16(fp)
 322ded0:	e0bffb17 	ldw	r2,-20(fp)
 322ded4:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322ded8:	00bfffc4 	movi	r2,-1
 322dedc:	e0bfff15 	stw	r2,-4(fp)
 322dee0:	00000106 	br	322dee8 <t_listen+0xcc>
   }
   return 0;
 322dee4:	e03fff15 	stw	zero,-4(fp)
 322dee8:	e0bfff17 	ldw	r2,-4(fp)
}
 322deec:	e037883a 	mov	sp,fp
 322def0:	dfc00117 	ldw	ra,4(sp)
 322def4:	df000017 	ldw	fp,0(sp)
 322def8:	dec00204 	addi	sp,sp,8
 322defc:	f800283a 	ret

0322df00 <t_accept>:

long
t_accept(long s, 
   struct sockaddr * addr,
   int * addrlen)
{
 322df00:	defff604 	addi	sp,sp,-40
 322df04:	dfc00915 	stw	ra,36(sp)
 322df08:	df000815 	stw	fp,32(sp)
 322df0c:	df000804 	addi	fp,sp,32
 322df10:	e13ffc15 	stw	r4,-16(fp)
 322df14:	e17ffd15 	stw	r5,-12(fp)
 322df18:	e1bffe15 	stw	r6,-8(fp)
   char logbuf[10];
#endif
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 322df1c:	e0bffc17 	ldw	r2,-16(fp)
 322df20:	10bff804 	addi	r2,r2,-32
 322df24:	1085883a 	add	r2,r2,r2
 322df28:	1085883a 	add	r2,r2,r2
 322df2c:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 322df30:	0080c9b4 	movhi	r2,806
 322df34:	10b39704 	addi	r2,r2,-12708
 322df38:	e0bff915 	stw	r2,-28(fp)
 322df3c:	00000606 	br	322df58 <t_accept+0x58>
 322df40:	e0fff917 	ldw	r3,-28(fp)
 322df44:	e0bffb17 	ldw	r2,-20(fp)
 322df48:	18800626 	beq	r3,r2,322df64 <t_accept+0x64>
 322df4c:	e0bff917 	ldw	r2,-28(fp)
 322df50:	10800017 	ldw	r2,0(r2)
 322df54:	e0bff915 	stw	r2,-28(fp)
 322df58:	e0bff917 	ldw	r2,-28(fp)
 322df5c:	1004c03a 	cmpne	r2,r2,zero
 322df60:	103ff71e 	bne	r2,zero,322df40 <t_accept+0x40>
 322df64:	e0fff917 	ldw	r3,-28(fp)
 322df68:	e0bffb17 	ldw	r2,-20(fp)
 322df6c:	18800426 	beq	r3,r2,322df80 <t_accept+0x80>
 322df70:	322ab8c0 	call	322ab8c <dtrap>
 322df74:	00bfffc4 	movi	r2,-1
 322df78:	e0bfff15 	stw	r2,-4(fp)
 322df7c:	00008006 	br	322e180 <t_accept+0x280>
   DOMAIN_CHECK(so, *addrlen);
 322df80:	e0bffe17 	ldw	r2,-8(fp)
 322df84:	11400017 	ldw	r5,0(r2)
 322df88:	e13ffb17 	ldw	r4,-20(fp)
 322df8c:	322dbc40 	call	322dbc4 <DOMAIN_CHECK>

   so->so_error = 0;
 322df90:	e0bffb17 	ldw	r2,-20(fp)
 322df94:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
      ("INET:accept:so %x so_qlen %d so_state %x\n", so, so->so_qlen, so->so_state));
   if ((so->so_options & SO_ACCEPTCONN) == 0)
 322df98:	e0bffb17 	ldw	r2,-20(fp)
 322df9c:	10800417 	ldw	r2,16(r2)
 322dfa0:	1080008c 	andi	r2,r2,2
 322dfa4:	1004c03a 	cmpne	r2,r2,zero
 322dfa8:	1000061e 	bne	r2,zero,322dfc4 <t_accept+0xc4>
   {
      so->so_error = EINVAL;
 322dfac:	e0fffb17 	ldw	r3,-20(fp)
 322dfb0:	00800584 	movi	r2,22
 322dfb4:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 322dfb8:	00bfffc4 	movi	r2,-1
 322dfbc:	e0bfff15 	stw	r2,-4(fp)
 322dfc0:	00006f06 	br	322e180 <t_accept+0x280>
   }
   if ((so->so_state & SS_NBIO) && so->so_qlen == 0)
 322dfc4:	e0bffb17 	ldw	r2,-20(fp)
 322dfc8:	1080088b 	ldhu	r2,34(r2)
 322dfcc:	10bfffcc 	andi	r2,r2,65535
 322dfd0:	1080400c 	andi	r2,r2,256
 322dfd4:	1005003a 	cmpeq	r2,r2,zero
 322dfd8:	10000d1e 	bne	r2,zero,322e010 <t_accept+0x110>
 322dfdc:	e0bffb17 	ldw	r2,-20(fp)
 322dfe0:	10801e43 	ldbu	r2,121(r2)
 322dfe4:	10803fcc 	andi	r2,r2,255
 322dfe8:	1080201c 	xori	r2,r2,128
 322dfec:	10bfe004 	addi	r2,r2,-128
 322dff0:	1004c03a 	cmpne	r2,r2,zero
 322dff4:	1000061e 	bne	r2,zero,322e010 <t_accept+0x110>
   {
      so->so_error = EWOULDBLOCK;
 322dff8:	e0fffb17 	ldw	r3,-20(fp)
 322dffc:	008002c4 	movi	r2,11
 322e000:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 322e004:	00bfffc4 	movi	r2,-1
 322e008:	e0bfff15 	stw	r2,-4(fp)
 322e00c:	00005c06 	br	322e180 <t_accept+0x280>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 322e010:	0009883a 	mov	r4,zero
 322e014:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   while (so->so_qlen == 0 && so->so_error == 0)
 322e018:	00001206 	br	322e064 <t_accept+0x164>
   {
      if (so->so_state & SS_CANTRCVMORE)
 322e01c:	e0bffb17 	ldw	r2,-20(fp)
 322e020:	1080088b 	ldhu	r2,34(r2)
 322e024:	10bfffcc 	andi	r2,r2,65535
 322e028:	1080080c 	andi	r2,r2,32
 322e02c:	1005003a 	cmpeq	r2,r2,zero
 322e030:	1000081e 	bne	r2,zero,322e054 <t_accept+0x154>
      {
         so->so_error = ECONNABORTED;
 322e034:	e0fffb17 	ldw	r3,-20(fp)
 322e038:	00801c44 	movi	r2,113
 322e03c:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE(NET_RESID);
 322e040:	0009883a 	mov	r4,zero
 322e044:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 322e048:	00bfffc4 	movi	r2,-1
 322e04c:	e0bfff15 	stw	r2,-4(fp)
 322e050:	00004b06 	br	322e180 <t_accept+0x280>
      }
      tcp_sleep ((char *)&so->so_timeo);
 322e054:	e0bffb17 	ldw	r2,-20(fp)
 322e058:	10800904 	addi	r2,r2,36
 322e05c:	1009883a 	mov	r4,r2
 322e060:	32267600 	call	3226760 <tcp_sleep>
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
   }
   LOCK_NET_RESOURCE(NET_RESID);
   while (so->so_qlen == 0 && so->so_error == 0)
 322e064:	e0bffb17 	ldw	r2,-20(fp)
 322e068:	10801e43 	ldbu	r2,121(r2)
 322e06c:	10803fcc 	andi	r2,r2,255
 322e070:	1080201c 	xori	r2,r2,128
 322e074:	10bfe004 	addi	r2,r2,-128
 322e078:	1004c03a 	cmpne	r2,r2,zero
 322e07c:	1000041e 	bne	r2,zero,322e090 <t_accept+0x190>
 322e080:	e0bffb17 	ldw	r2,-20(fp)
 322e084:	10800617 	ldw	r2,24(r2)
 322e088:	1005003a 	cmpeq	r2,r2,zero
 322e08c:	103fe31e 	bne	r2,zero,322e01c <t_accept+0x11c>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return SOCKET_ERROR;
      }
      tcp_sleep ((char *)&so->so_timeo);
   }
   if (so->so_error)
 322e090:	e0bffb17 	ldw	r2,-20(fp)
 322e094:	10800617 	ldw	r2,24(r2)
 322e098:	1005003a 	cmpeq	r2,r2,zero
 322e09c:	1000051e 	bne	r2,zero,322e0b4 <t_accept+0x1b4>
   {
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 322e0a0:	0009883a 	mov	r4,zero
 322e0a4:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 322e0a8:	00bfffc4 	movi	r2,-1
 322e0ac:	e0bfff15 	stw	r2,-4(fp)
 322e0b0:	00003306 	br	322e180 <t_accept+0x280>
   }
   nam = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 322e0b4:	01000244 	movi	r4,9
 322e0b8:	01400404 	movi	r5,16
 322e0bc:	322b98c0 	call	322b98c <m_getnbuf>
 322e0c0:	e0bffa15 	stw	r2,-24(fp)
   if (nam == NULL) 
 322e0c4:	e0bffa17 	ldw	r2,-24(fp)
 322e0c8:	1004c03a 	cmpne	r2,r2,zero
 322e0cc:	1000081e 	bne	r2,zero,322e0f0 <t_accept+0x1f0>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 322e0d0:	0009883a 	mov	r4,zero
 322e0d4:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      so->so_error = ENOMEM;
 322e0d8:	e0fffb17 	ldw	r3,-20(fp)
 322e0dc:	00800304 	movi	r2,12
 322e0e0:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 322e0e4:	00bfffc4 	movi	r2,-1
 322e0e8:	e0bfff15 	stw	r2,-4(fp)
 322e0ec:	00002406 	br	322e180 <t_accept+0x280>
   }
   { 
      struct socket *aso = so->so_q;
 322e0f0:	e0bffb17 	ldw	r2,-20(fp)
 322e0f4:	10801d17 	ldw	r2,116(r2)
 322e0f8:	e0bff815 	stw	r2,-32(fp)
      if (soqremque (aso, 1) == 0)
 322e0fc:	e13ff817 	ldw	r4,-32(fp)
 322e100:	01400044 	movi	r5,1
 322e104:	3231cac0 	call	3231cac <soqremque>
 322e108:	1004c03a 	cmpne	r2,r2,zero
 322e10c:	1000031e 	bne	r2,zero,322e11c <t_accept+0x21c>
         panic("accept");
 322e110:	0100c974 	movhi	r4,805
 322e114:	213d4404 	addi	r4,r4,-2800
 322e118:	3225df00 	call	3225df0 <panic>
      so = aso;
 322e11c:	e0bff817 	ldw	r2,-32(fp)
 322e120:	e0bffb15 	stw	r2,-20(fp)
   }
   (void)soaccept (so, nam);
 322e124:	e13ffb17 	ldw	r4,-20(fp)
 322e128:	e17ffa17 	ldw	r5,-24(fp)
 322e12c:	322fb4c0 	call	322fb4c <soaccept>
      INET_TRACE (INETM_SOCKET, ("INET:accept:done so %lx port %d addr %lx\n",
       so, sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_INET */
   /* return the addressing info in the passed structure */
   if (addr != NULL)
 322e130:	e0bffd17 	ldw	r2,-12(fp)
 322e134:	1005003a 	cmpeq	r2,r2,zero
 322e138:	1000091e 	bne	r2,zero,322e160 <t_accept+0x260>
      MEMCPY(addr, nam->m_data, *addrlen);
 322e13c:	e0bffa17 	ldw	r2,-24(fp)
 322e140:	11400317 	ldw	r5,12(r2)
 322e144:	e0bffe17 	ldw	r2,-8(fp)
 322e148:	10800017 	ldw	r2,0(r2)
 322e14c:	1007883a 	mov	r3,r2
 322e150:	e0bffd17 	ldw	r2,-12(fp)
 322e154:	1009883a 	mov	r4,r2
 322e158:	180d883a 	mov	r6,r3
 322e15c:	32067cc0 	call	32067cc <memcpy>
   m_freem (nam);
 322e160:	e13ffa17 	ldw	r4,-24(fp)
 322e164:	322bc680 	call	322bc68 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 322e168:	0009883a 	mov	r4,zero
 322e16c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   SOC_RANGE(so);
   return SO2LONG(so);
 322e170:	e0bffb17 	ldw	r2,-20(fp)
 322e174:	1004d0ba 	srli	r2,r2,2
 322e178:	10800804 	addi	r2,r2,32
 322e17c:	e0bfff15 	stw	r2,-4(fp)
 322e180:	e0bfff17 	ldw	r2,-4(fp)
}
 322e184:	e037883a 	mov	sp,fp
 322e188:	dfc00117 	ldw	ra,4(sp)
 322e18c:	df000017 	ldw	fp,0(sp)
 322e190:	dec00204 	addi	sp,sp,8
 322e194:	f800283a 	ret

0322e198 <t_connect>:

int
t_connect(long s, 
   struct sockaddr * addr,
   int   addrlen)
{
 322e198:	defff704 	addi	sp,sp,-36
 322e19c:	dfc00815 	stw	ra,32(sp)
 322e1a0:	df000715 	stw	fp,28(sp)
 322e1a4:	df000704 	addi	fp,sp,28
 322e1a8:	e13ffc15 	stw	r4,-16(fp)
 322e1ac:	e17ffd15 	stw	r5,-12(fp)
 322e1b0:	e1bffe15 	stw	r6,-8(fp)
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 322e1b4:	e0bffc17 	ldw	r2,-16(fp)
 322e1b8:	10bff804 	addi	r2,r2,-32
 322e1bc:	1085883a 	add	r2,r2,r2
 322e1c0:	1085883a 	add	r2,r2,r2
 322e1c4:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 322e1c8:	0080c9b4 	movhi	r2,806
 322e1cc:	10b39704 	addi	r2,r2,-12708
 322e1d0:	e0bff915 	stw	r2,-28(fp)
 322e1d4:	00000606 	br	322e1f0 <t_connect+0x58>
 322e1d8:	e0fff917 	ldw	r3,-28(fp)
 322e1dc:	e0bffb17 	ldw	r2,-20(fp)
 322e1e0:	18800626 	beq	r3,r2,322e1fc <t_connect+0x64>
 322e1e4:	e0bff917 	ldw	r2,-28(fp)
 322e1e8:	10800017 	ldw	r2,0(r2)
 322e1ec:	e0bff915 	stw	r2,-28(fp)
 322e1f0:	e0bff917 	ldw	r2,-28(fp)
 322e1f4:	1004c03a 	cmpne	r2,r2,zero
 322e1f8:	103ff71e 	bne	r2,zero,322e1d8 <t_connect+0x40>
 322e1fc:	e0fff917 	ldw	r3,-28(fp)
 322e200:	e0bffb17 	ldw	r2,-20(fp)
 322e204:	18800426 	beq	r3,r2,322e218 <t_connect+0x80>
 322e208:	322ab8c0 	call	322ab8c <dtrap>
 322e20c:	00bfffc4 	movi	r2,-1
 322e210:	e0bfff15 	stw	r2,-4(fp)
 322e214:	00008406 	br	322e428 <t_connect+0x290>
   DOMAIN_CHECK(so, addrlen);
 322e218:	e13ffb17 	ldw	r4,-20(fp)
 322e21c:	e17ffe17 	ldw	r5,-8(fp)
 322e220:	322dbc40 	call	322dbc4 <DOMAIN_CHECK>

#ifdef NB_CONNECT
   /* need to test non blocking connect bits in case this is a 
      poll of a previous request */
   if (so->so_state & SS_NBIO)
 322e224:	e0bffb17 	ldw	r2,-20(fp)
 322e228:	1080088b 	ldhu	r2,34(r2)
 322e22c:	10bfffcc 	andi	r2,r2,65535
 322e230:	1080400c 	andi	r2,r2,256
 322e234:	1005003a 	cmpeq	r2,r2,zero
 322e238:	10002a1e 	bne	r2,zero,322e2e4 <t_connect+0x14c>
   {
      if (so->so_state & SS_ISCONNECTING) /* still trying */
 322e23c:	e0bffb17 	ldw	r2,-20(fp)
 322e240:	1080088b 	ldhu	r2,34(r2)
 322e244:	10bfffcc 	andi	r2,r2,65535
 322e248:	1080010c 	andi	r2,r2,4
 322e24c:	1005003a 	cmpeq	r2,r2,zero
 322e250:	1000061e 	bne	r2,zero,322e26c <t_connect+0xd4>
      {
         so->so_error = EINPROGRESS;
 322e254:	e0fffb17 	ldw	r3,-20(fp)
 322e258:	00801dc4 	movi	r2,119
 322e25c:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 322e260:	00bfffc4 	movi	r2,-1
 322e264:	e0bfff15 	stw	r2,-4(fp)
 322e268:	00006f06 	br	322e428 <t_connect+0x290>
      }
      if (so->so_state & SS_ISCONNECTED)  /* connected OK */
 322e26c:	e0bffb17 	ldw	r2,-20(fp)
 322e270:	1080088b 	ldhu	r2,34(r2)
 322e274:	10bfffcc 	andi	r2,r2,65535
 322e278:	1080008c 	andi	r2,r2,2
 322e27c:	1005003a 	cmpeq	r2,r2,zero
 322e280:	1000041e 	bne	r2,zero,322e294 <t_connect+0xfc>
      {
         so->so_error = 0;
 322e284:	e0bffb17 	ldw	r2,-20(fp)
 322e288:	10000615 	stw	zero,24(r2)
         return 0;
 322e28c:	e03fff15 	stw	zero,-4(fp)
 322e290:	00006506 	br	322e428 <t_connect+0x290>
      }
      if (so->so_state & SS_WASCONNECTING)
 322e294:	e0bffb17 	ldw	r2,-20(fp)
 322e298:	1080088b 	ldhu	r2,34(r2)
 322e29c:	10bfffcc 	andi	r2,r2,65535
 322e2a0:	1088000c 	andi	r2,r2,8192
 322e2a4:	1005003a 	cmpeq	r2,r2,zero
 322e2a8:	10000e1e 	bne	r2,zero,322e2e4 <t_connect+0x14c>
      {
         so->so_state &= ~SS_WASCONNECTING;
 322e2ac:	e0bffb17 	ldw	r2,-20(fp)
 322e2b0:	10c0088b 	ldhu	r3,34(r2)
 322e2b4:	00b7ffc4 	movi	r2,-8193
 322e2b8:	1884703a 	and	r2,r3,r2
 322e2bc:	1007883a 	mov	r3,r2
 322e2c0:	e0bffb17 	ldw	r2,-20(fp)
 322e2c4:	10c0088d 	sth	r3,34(r2)
         if (so->so_error) /* connect error - maybe timeout */
 322e2c8:	e0bffb17 	ldw	r2,-20(fp)
 322e2cc:	10800617 	ldw	r2,24(r2)
 322e2d0:	1005003a 	cmpeq	r2,r2,zero
 322e2d4:	1000031e 	bne	r2,zero,322e2e4 <t_connect+0x14c>
            return SOCKET_ERROR;
 322e2d8:	00bfffc4 	movi	r2,-1
 322e2dc:	e0bfff15 	stw	r2,-4(fp)
 322e2e0:	00005106 	br	322e428 <t_connect+0x290>
      }
   }
#endif   /*  NB_CONNECT */

   so->so_error = 0;
 322e2e4:	e0bffb17 	ldw	r2,-20(fp)
 322e2e8:	10000615 	stw	zero,24(r2)

   if ((nam = sockargs (addr, addrlen, MT_SONAME))
 322e2ec:	e13ffd17 	ldw	r4,-12(fp)
 322e2f0:	e17ffe17 	ldw	r5,-8(fp)
 322e2f4:	01800244 	movi	r6,9
 322e2f8:	322f28c0 	call	322f28c <sockargs>
 322e2fc:	e0bffa15 	stw	r2,-24(fp)
 322e300:	e0bffa17 	ldw	r2,-24(fp)
 322e304:	1004c03a 	cmpne	r2,r2,zero
 322e308:	1000061e 	bne	r2,zero,322e324 <t_connect+0x18c>
       == NULL)
   {
      so->so_error = ENOMEM;
 322e30c:	e0fffb17 	ldw	r3,-20(fp)
 322e310:	00800304 	movi	r2,12
 322e314:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322e318:	00bfffc4 	movi	r2,-1
 322e31c:	e0bfff15 	stw	r2,-4(fp)
 322e320:	00004106 	br	322e428 <t_connect+0x290>
      INET_TRACE (INETM_SOCKET, ("INET: connect, port %d addr %lx\n",
       sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 322e324:	0009883a 	mov	r4,zero
 322e328:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   if ((so->so_error = soconnect (so, nam)) != 0)
 322e32c:	e13ffb17 	ldw	r4,-20(fp)
 322e330:	e17ffa17 	ldw	r5,-24(fp)
 322e334:	322fbe80 	call	322fbe8 <soconnect>
 322e338:	1007883a 	mov	r3,r2
 322e33c:	e0bffb17 	ldw	r2,-20(fp)
 322e340:	10c00615 	stw	r3,24(r2)
 322e344:	e0bffb17 	ldw	r2,-20(fp)
 322e348:	10800617 	ldw	r2,24(r2)
 322e34c:	1004c03a 	cmpne	r2,r2,zero
 322e350:	10001e1e 	bne	r2,zero,322e3cc <t_connect+0x234>
      goto bad;

#ifdef NB_CONNECT
   /* need to test non blocking connect bits after soconnect() call */
   if ((so->so_state & SS_NBIO)&& (so->so_state & SS_ISCONNECTING))
 322e354:	e0bffb17 	ldw	r2,-20(fp)
 322e358:	1080088b 	ldhu	r2,34(r2)
 322e35c:	10bfffcc 	andi	r2,r2,65535
 322e360:	1080400c 	andi	r2,r2,256
 322e364:	1005003a 	cmpeq	r2,r2,zero
 322e368:	10000e1e 	bne	r2,zero,322e3a4 <t_connect+0x20c>
 322e36c:	e0bffb17 	ldw	r2,-20(fp)
 322e370:	1080088b 	ldhu	r2,34(r2)
 322e374:	10bfffcc 	andi	r2,r2,65535
 322e378:	1080010c 	andi	r2,r2,4
 322e37c:	1005003a 	cmpeq	r2,r2,zero
 322e380:	1000081e 	bne	r2,zero,322e3a4 <t_connect+0x20c>
   {
      so->so_error = EINPROGRESS;
 322e384:	e0fffb17 	ldw	r3,-20(fp)
 322e388:	00801dc4 	movi	r2,119
 322e38c:	18800615 	stw	r2,24(r3)
      goto bad;
 322e390:	00000e06 	br	322e3cc <t_connect+0x234>
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
 322e394:	e0bffb17 	ldw	r2,-20(fp)
 322e398:	10800904 	addi	r2,r2,36
 322e39c:	1009883a 	mov	r4,r2
 322e3a0:	32267600 	call	3226760 <tcp_sleep>
   }
#endif   /*  NB_CONNECT */
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
 322e3a4:	e0bffb17 	ldw	r2,-20(fp)
 322e3a8:	1080088b 	ldhu	r2,34(r2)
 322e3ac:	10bfffcc 	andi	r2,r2,65535
 322e3b0:	1080010c 	andi	r2,r2,4
 322e3b4:	1005003a 	cmpeq	r2,r2,zero
 322e3b8:	1000041e 	bne	r2,zero,322e3cc <t_connect+0x234>
 322e3bc:	e0bffb17 	ldw	r2,-20(fp)
 322e3c0:	10800617 	ldw	r2,24(r2)
 322e3c4:	1005003a 	cmpeq	r2,r2,zero
 322e3c8:	103ff21e 	bne	r2,zero,322e394 <t_connect+0x1fc>
   {
      tcp_sleep ((char *)&so->so_timeo);
   }
bad:
   if (so->so_error != EINPROGRESS)
 322e3cc:	e0bffb17 	ldw	r2,-20(fp)
 322e3d0:	10800617 	ldw	r2,24(r2)
 322e3d4:	10801de0 	cmpeqi	r2,r2,119
 322e3d8:	1000071e 	bne	r2,zero,322e3f8 <t_connect+0x260>
      so->so_state &= ~(SS_ISCONNECTING|SS_WASCONNECTING);
 322e3dc:	e0bffb17 	ldw	r2,-20(fp)
 322e3e0:	10c0088b 	ldhu	r3,34(r2)
 322e3e4:	00b7fec4 	movi	r2,-8197
 322e3e8:	1884703a 	and	r2,r3,r2
 322e3ec:	1007883a 	mov	r3,r2
 322e3f0:	e0bffb17 	ldw	r2,-20(fp)
 322e3f4:	10c0088d 	sth	r3,34(r2)
   m_freem (nam);
 322e3f8:	e13ffa17 	ldw	r4,-24(fp)
 322e3fc:	322bc680 	call	322bc68 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 322e400:	0009883a 	mov	r4,zero
 322e404:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   if (so->so_error)
 322e408:	e0bffb17 	ldw	r2,-20(fp)
 322e40c:	10800617 	ldw	r2,24(r2)
 322e410:	1005003a 	cmpeq	r2,r2,zero
 322e414:	1000031e 	bne	r2,zero,322e424 <t_connect+0x28c>
   {
/*      printf("t_connect(): so_error = %d\n", so->so_error);*/
      return SOCKET_ERROR;
 322e418:	00bfffc4 	movi	r2,-1
 322e41c:	e0bfff15 	stw	r2,-4(fp)
 322e420:	00000106 	br	322e428 <t_connect+0x290>

   }
      return 0;
 322e424:	e03fff15 	stw	zero,-4(fp)
 322e428:	e0bfff17 	ldw	r2,-4(fp)
}
 322e42c:	e037883a 	mov	sp,fp
 322e430:	dfc00117 	ldw	ra,4(sp)
 322e434:	df000017 	ldw	fp,0(sp)
 322e438:	dec00204 	addi	sp,sp,8
 322e43c:	f800283a 	ret

0322e440 <t_getpeername>:
 * RETURNS: 
 */

int
t_getpeername(long s, struct sockaddr * addr, int * addrlen)
{
 322e440:	defffb04 	addi	sp,sp,-20
 322e444:	dfc00415 	stw	ra,16(sp)
 322e448:	df000315 	stw	fp,12(sp)
 322e44c:	df000304 	addi	fp,sp,12
 322e450:	e13ffd15 	stw	r4,-12(fp)
 322e454:	e17ffe15 	stw	r5,-8(fp)
 322e458:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_PEERADDR));
 322e45c:	e13ffd17 	ldw	r4,-12(fp)
 322e460:	e17ffe17 	ldw	r5,-8(fp)
 322e464:	e1bfff17 	ldw	r6,-4(fp)
 322e468:	01c00404 	movi	r7,16
 322e46c:	322e4c80 	call	322e4c8 <t_getname>
}
 322e470:	e037883a 	mov	sp,fp
 322e474:	dfc00117 	ldw	ra,4(sp)
 322e478:	df000017 	ldw	fp,0(sp)
 322e47c:	dec00204 	addi	sp,sp,8
 322e480:	f800283a 	ret

0322e484 <t_getsockname>:
 * RETURNS: 
 */

int 
t_getsockname(long s, struct sockaddr * addr, int * addrlen)
{
 322e484:	defffb04 	addi	sp,sp,-20
 322e488:	dfc00415 	stw	ra,16(sp)
 322e48c:	df000315 	stw	fp,12(sp)
 322e490:	df000304 	addi	fp,sp,12
 322e494:	e13ffd15 	stw	r4,-12(fp)
 322e498:	e17ffe15 	stw	r5,-8(fp)
 322e49c:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_SOCKADDR));
 322e4a0:	e13ffd17 	ldw	r4,-12(fp)
 322e4a4:	e17ffe17 	ldw	r5,-8(fp)
 322e4a8:	e1bfff17 	ldw	r6,-4(fp)
 322e4ac:	01c003c4 	movi	r7,15
 322e4b0:	322e4c80 	call	322e4c8 <t_getname>
}
 322e4b4:	e037883a 	mov	sp,fp
 322e4b8:	dfc00117 	ldw	ra,4(sp)
 322e4bc:	df000017 	ldw	fp,0(sp)
 322e4c0:	dec00204 	addi	sp,sp,8
 322e4c4:	f800283a 	ret

0322e4c8 <t_getname>:
 * RETURNS: 
 */

static int
t_getname(long s, struct sockaddr * addr, int * addrlen, int opcode)
{
 322e4c8:	defff504 	addi	sp,sp,-44
 322e4cc:	dfc00a15 	stw	ra,40(sp)
 322e4d0:	df000915 	stw	fp,36(sp)
 322e4d4:	df000904 	addi	fp,sp,36
 322e4d8:	e13ffb15 	stw	r4,-20(fp)
 322e4dc:	e17ffc15 	stw	r5,-16(fp)
 322e4e0:	e1bffd15 	stw	r6,-12(fp)
 322e4e4:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   struct mbuf *  m;
   int   err;

   so = LONG2SO(s);
 322e4e8:	e0bffb17 	ldw	r2,-20(fp)
 322e4ec:	10bff804 	addi	r2,r2,-32
 322e4f0:	1085883a 	add	r2,r2,r2
 322e4f4:	1085883a 	add	r2,r2,r2
 322e4f8:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 322e4fc:	0080c9b4 	movhi	r2,806
 322e500:	10b39704 	addi	r2,r2,-12708
 322e504:	e0bff715 	stw	r2,-36(fp)
 322e508:	00000606 	br	322e524 <t_getname+0x5c>
 322e50c:	e0fff717 	ldw	r3,-36(fp)
 322e510:	e0bffa17 	ldw	r2,-24(fp)
 322e514:	18800626 	beq	r3,r2,322e530 <t_getname+0x68>
 322e518:	e0bff717 	ldw	r2,-36(fp)
 322e51c:	10800017 	ldw	r2,0(r2)
 322e520:	e0bff715 	stw	r2,-36(fp)
 322e524:	e0bff717 	ldw	r2,-36(fp)
 322e528:	1004c03a 	cmpne	r2,r2,zero
 322e52c:	103ff71e 	bne	r2,zero,322e50c <t_getname+0x44>
 322e530:	e0fff717 	ldw	r3,-36(fp)
 322e534:	e0bffa17 	ldw	r2,-24(fp)
 322e538:	18800426 	beq	r3,r2,322e54c <t_getname+0x84>
 322e53c:	322ab8c0 	call	322ab8c <dtrap>
 322e540:	00bfffc4 	movi	r2,-1
 322e544:	e0bfff15 	stw	r2,-4(fp)
 322e548:	00005806 	br	322e6ac <t_getname+0x1e4>

   so->so_error = 0;
 322e54c:	e0bffa17 	ldw	r2,-24(fp)
 322e550:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:get[sock|peer]name so %x\n", so));
   if((opcode == PRU_PEERADDR) && (so->so_state & SS_ISCONNECTED) == 0)
 322e554:	e0bffe17 	ldw	r2,-8(fp)
 322e558:	10800418 	cmpnei	r2,r2,16
 322e55c:	10000c1e 	bne	r2,zero,322e590 <t_getname+0xc8>
 322e560:	e0bffa17 	ldw	r2,-24(fp)
 322e564:	1080088b 	ldhu	r2,34(r2)
 322e568:	10bfffcc 	andi	r2,r2,65535
 322e56c:	1080008c 	andi	r2,r2,2
 322e570:	1004c03a 	cmpne	r2,r2,zero
 322e574:	1000061e 	bne	r2,zero,322e590 <t_getname+0xc8>
   {
      so->so_error = ENOTCONN;
 322e578:	e0fffa17 	ldw	r3,-24(fp)
 322e57c:	00802004 	movi	r2,128
 322e580:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322e584:	00bfffc4 	movi	r2,-1
 322e588:	e0bfff15 	stw	r2,-4(fp)
 322e58c:	00004706 	br	322e6ac <t_getname+0x1e4>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 322e590:	0009883a 	mov	r4,zero
 322e594:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 322e598:	01000244 	movi	r4,9
 322e59c:	01400404 	movi	r5,16
 322e5a0:	322b98c0 	call	322b98c <m_getnbuf>
 322e5a4:	e0bff915 	stw	r2,-28(fp)
   if (m == NULL) 
 322e5a8:	e0bff917 	ldw	r2,-28(fp)
 322e5ac:	1004c03a 	cmpne	r2,r2,zero
 322e5b0:	1000081e 	bne	r2,zero,322e5d4 <t_getname+0x10c>
   {
      so->so_error = ENOMEM;
 322e5b4:	e0fffa17 	ldw	r3,-24(fp)
 322e5b8:	00800304 	movi	r2,12
 322e5bc:	18800615 	stw	r2,24(r3)
      UNLOCK_NET_RESOURCE(NET_RESID);
 322e5c0:	0009883a 	mov	r4,zero
 322e5c4:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 322e5c8:	00bfffc4 	movi	r2,-1
 322e5cc:	e0bfff15 	stw	r2,-4(fp)
 322e5d0:	00003606 	br	322e6ac <t_getname+0x1e4>
   }
   so->so_req = opcode;
 322e5d4:	e0fffa17 	ldw	r3,-24(fp)
 322e5d8:	e0bffe17 	ldw	r2,-8(fp)
 322e5dc:	18800715 	stw	r2,28(r3)
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
 322e5e0:	e0bffa17 	ldw	r2,-24(fp)
 322e5e4:	10800217 	ldw	r2,8(r2)
 322e5e8:	10800317 	ldw	r2,12(r2)
 322e5ec:	e13ffa17 	ldw	r4,-24(fp)
 322e5f0:	000b883a 	mov	r5,zero
 322e5f4:	e1bff917 	ldw	r6,-28(fp)
 322e5f8:	103ee83a 	callr	r2
 322e5fc:	e0bff815 	stw	r2,-32(fp)
 322e600:	e0bff817 	ldw	r2,-32(fp)
 322e604:	1004c03a 	cmpne	r2,r2,zero
 322e608:	10001a1e 	bne	r2,zero,322e674 <t_getname+0x1ac>
      goto bad;

#ifdef IP_V4
   if(so->so_domain == AF_INET)
 322e60c:	e0bffa17 	ldw	r2,-24(fp)
 322e610:	10800517 	ldw	r2,20(r2)
 322e614:	10800098 	cmpnei	r2,r2,2
 322e618:	1000161e 	bne	r2,zero,322e674 <t_getname+0x1ac>
   {
      if(*addrlen < sizeof(struct sockaddr_in))
 322e61c:	e0bffd17 	ldw	r2,-12(fp)
 322e620:	10800017 	ldw	r2,0(r2)
 322e624:	10800428 	cmpgeui	r2,r2,16
 322e628:	1000081e 	bne	r2,zero,322e64c <t_getname+0x184>
      {
         dtrap();    /* programming error */
 322e62c:	322ab8c0 	call	322ab8c <dtrap>
         m_freem(m);
 322e630:	e13ff917 	ldw	r4,-28(fp)
 322e634:	322bc680 	call	322bc68 <m_freem>
         UNLOCK_NET_RESOURCE(NET_RESID);
 322e638:	0009883a 	mov	r4,zero
 322e63c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         return EINVAL;
 322e640:	00800584 	movi	r2,22
 322e644:	e0bfff15 	stw	r2,-4(fp)
 322e648:	00001806 	br	322e6ac <t_getname+0x1e4>
      }
      MEMCPY(addr, m->m_data, sizeof(struct sockaddr_in));
 322e64c:	e0bff917 	ldw	r2,-28(fp)
 322e650:	10c00317 	ldw	r3,12(r2)
 322e654:	e0bffc17 	ldw	r2,-16(fp)
 322e658:	1009883a 	mov	r4,r2
 322e65c:	180b883a 	mov	r5,r3
 322e660:	01800404 	movi	r6,16
 322e664:	32067cc0 	call	32067cc <memcpy>
      *addrlen = sizeof(struct sockaddr_in);
 322e668:	e0fffd17 	ldw	r3,-12(fp)
 322e66c:	00800404 	movi	r2,16
 322e670:	18800015 	stw	r2,0(r3)
   }
#endif   /* IP_V6 */


bad:
   m_freem(m);
 322e674:	e13ff917 	ldw	r4,-28(fp)
 322e678:	322bc680 	call	322bc68 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 322e67c:	0009883a 	mov	r4,zero
 322e680:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   if (err) 
 322e684:	e0bff817 	ldw	r2,-32(fp)
 322e688:	1005003a 	cmpeq	r2,r2,zero
 322e68c:	1000061e 	bne	r2,zero,322e6a8 <t_getname+0x1e0>
   {
      so->so_error = err;
 322e690:	e0fffa17 	ldw	r3,-24(fp)
 322e694:	e0bff817 	ldw	r2,-32(fp)
 322e698:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322e69c:	00bfffc4 	movi	r2,-1
 322e6a0:	e0bfff15 	stw	r2,-4(fp)
 322e6a4:	00000106 	br	322e6ac <t_getname+0x1e4>
   }
   return 0;
 322e6a8:	e03fff15 	stw	zero,-4(fp)
 322e6ac:	e0bfff17 	ldw	r2,-4(fp)
}
 322e6b0:	e037883a 	mov	sp,fp
 322e6b4:	dfc00117 	ldw	ra,4(sp)
 322e6b8:	df000017 	ldw	fp,0(sp)
 322e6bc:	dec00204 	addi	sp,sp,8
 322e6c0:	f800283a 	ret

0322e6c4 <t_setsockopt>:
t_setsockopt(long s,
   int   level,
   int   name,
   void * arg,
   int arglen)
{
 322e6c4:	defff604 	addi	sp,sp,-40
 322e6c8:	dfc00915 	stw	ra,36(sp)
 322e6cc:	df000815 	stw	fp,32(sp)
 322e6d0:	df000804 	addi	fp,sp,32
 322e6d4:	e13ffb15 	stw	r4,-20(fp)
 322e6d8:	e17ffc15 	stw	r5,-16(fp)
 322e6dc:	e1bffd15 	stw	r6,-12(fp)
 322e6e0:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 322e6e4:	e0bffb17 	ldw	r2,-20(fp)
 322e6e8:	10bff804 	addi	r2,r2,-32
 322e6ec:	1085883a 	add	r2,r2,r2
 322e6f0:	1085883a 	add	r2,r2,r2
 322e6f4:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 322e6f8:	0080c9b4 	movhi	r2,806
 322e6fc:	10b39704 	addi	r2,r2,-12708
 322e700:	e0bff815 	stw	r2,-32(fp)
 322e704:	00000606 	br	322e720 <t_setsockopt+0x5c>
 322e708:	e0fff817 	ldw	r3,-32(fp)
 322e70c:	e0bffa17 	ldw	r2,-24(fp)
 322e710:	18800626 	beq	r3,r2,322e72c <t_setsockopt+0x68>
 322e714:	e0bff817 	ldw	r2,-32(fp)
 322e718:	10800017 	ldw	r2,0(r2)
 322e71c:	e0bff815 	stw	r2,-32(fp)
 322e720:	e0bff817 	ldw	r2,-32(fp)
 322e724:	1004c03a 	cmpne	r2,r2,zero
 322e728:	103ff71e 	bne	r2,zero,322e708 <t_setsockopt+0x44>
 322e72c:	e0fff817 	ldw	r3,-32(fp)
 322e730:	e0bffa17 	ldw	r2,-24(fp)
 322e734:	18800426 	beq	r3,r2,322e748 <t_setsockopt+0x84>
 322e738:	322ab8c0 	call	322ab8c <dtrap>
 322e73c:	00bfffc4 	movi	r2,-1
 322e740:	e0bfff15 	stw	r2,-4(fp)
 322e744:	00005006 	br	322e888 <t_setsockopt+0x1c4>
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 322e748:	0009883a 	mov	r4,zero
 322e74c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>

   so->so_error = 0;
 322e750:	e0bffa17 	ldw	r2,-24(fp)
 322e754:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
    ("INET: setsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 322e758:	e0bffc17 	ldw	r2,-16(fp)
 322e75c:	10800060 	cmpeqi	r2,r2,1
 322e760:	1000101e 	bne	r2,zero,322e7a4 <t_setsockopt+0xe0>
   {
      if ((err = sosetopt (so, name, arg)) != 0) 
 322e764:	e13ffa17 	ldw	r4,-24(fp)
 322e768:	e17ffd17 	ldw	r5,-12(fp)
 322e76c:	e1bffe17 	ldw	r6,-8(fp)
 322e770:	3230cf00 	call	3230cf0 <sosetopt>
 322e774:	e0bff915 	stw	r2,-28(fp)
 322e778:	e0bff917 	ldw	r2,-28(fp)
 322e77c:	1005003a 	cmpeq	r2,r2,zero
 322e780:	10003e1e 	bne	r2,zero,322e87c <t_setsockopt+0x1b8>
      {
         so->so_error = err;
 322e784:	e0fffa17 	ldw	r3,-24(fp)
 322e788:	e0bff917 	ldw	r2,-28(fp)
 322e78c:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE (NET_RESID);
 322e790:	0009883a 	mov	r4,zero
 322e794:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 322e798:	00bfffc4 	movi	r2,-1
 322e79c:	e0bfff15 	stw	r2,-4(fp)
 322e7a0:	00003906 	br	322e888 <t_setsockopt+0x1c4>
   {
   /* level 1 options are for the IP packet level.
    * the info is carried in the socket CB, then put 
    * into the PACKET.
    */
      if (!so->so_optsPack)
 322e7a4:	e0bffa17 	ldw	r2,-24(fp)
 322e7a8:	10801f17 	ldw	r2,124(r2)
 322e7ac:	1004c03a 	cmpne	r2,r2,zero
 322e7b0:	1000111e 	bne	r2,zero,322e7f8 <t_setsockopt+0x134>
      {
         so->so_optsPack = (struct ip_socopts *) SOCOPT_ALLOC (sizeof(struct ip_socopts *));
 322e7b4:	01000104 	movi	r4,4
 322e7b8:	322b5d00 	call	322b5d0 <npalloc>
 322e7bc:	1007883a 	mov	r3,r2
 322e7c0:	e0bffa17 	ldw	r2,-24(fp)
 322e7c4:	10c01f15 	stw	r3,124(r2)
         if (!so->so_optsPack) 
 322e7c8:	e0bffa17 	ldw	r2,-24(fp)
 322e7cc:	10801f17 	ldw	r2,124(r2)
 322e7d0:	1004c03a 	cmpne	r2,r2,zero
 322e7d4:	1000081e 	bne	r2,zero,322e7f8 <t_setsockopt+0x134>
         {
            so->so_error = ENOMEM;
 322e7d8:	e0fffa17 	ldw	r3,-24(fp)
 322e7dc:	00800304 	movi	r2,12
 322e7e0:	18800615 	stw	r2,24(r3)
            UNLOCK_NET_RESOURCE (NET_RESID);
 322e7e4:	0009883a 	mov	r4,zero
 322e7e8:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
            return SOCKET_ERROR;
 322e7ec:	00bfffc4 	movi	r2,-1
 322e7f0:	e0bfff15 	stw	r2,-4(fp)
 322e7f4:	00002406 	br	322e888 <t_setsockopt+0x1c4>
         }
      }
      
      if (name == IP_TTL_OPT)
 322e7f8:	e0bffd17 	ldw	r2,-12(fp)
 322e7fc:	10800118 	cmpnei	r2,r2,4
 322e800:	1000061e 	bne	r2,zero,322e81c <t_setsockopt+0x158>
         so->so_optsPack->ip_ttl = (u_char)(*(int *)arg);
 322e804:	e0bffa17 	ldw	r2,-24(fp)
 322e808:	10c01f17 	ldw	r3,124(r2)
 322e80c:	e0bffe17 	ldw	r2,-8(fp)
 322e810:	10800017 	ldw	r2,0(r2)
 322e814:	18800045 	stb	r2,1(r3)
 322e818:	00001806 	br	322e87c <t_setsockopt+0x1b8>
      else
      if (name == IP_TOS)
 322e81c:	e0bffd17 	ldw	r2,-12(fp)
 322e820:	108000d8 	cmpnei	r2,r2,3
 322e824:	1000061e 	bne	r2,zero,322e840 <t_setsockopt+0x17c>
         so->so_optsPack->ip_tos = (u_char)(*(int *)arg);
 322e828:	e0bffa17 	ldw	r2,-24(fp)
 322e82c:	10c01f17 	ldw	r3,124(r2)
 322e830:	e0bffe17 	ldw	r2,-8(fp)
 322e834:	10800017 	ldw	r2,0(r2)
 322e838:	18800005 	stb	r2,0(r3)
 322e83c:	00000f06 	br	322e87c <t_setsockopt+0x1b8>
	   else
	   if (name == IP_SCOPEID)
 322e840:	e0bffd17 	ldw	r2,-12(fp)
 322e844:	10800398 	cmpnei	r2,r2,14
 322e848:	1000071e 	bne	r2,zero,322e868 <t_setsockopt+0x1a4>
            so->so_optsPack->ip_scopeid = (u_char)(*(u_int *)arg);
 322e84c:	e0bffa17 	ldw	r2,-24(fp)
 322e850:	10c01f17 	ldw	r3,124(r2)
 322e854:	e0bffe17 	ldw	r2,-8(fp)
 322e858:	10800017 	ldw	r2,0(r2)
 322e85c:	10803fcc 	andi	r2,r2,255
 322e860:	18800115 	stw	r2,4(r3)
 322e864:	00000506 	br	322e87c <t_setsockopt+0x1b8>
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 322e868:	0009883a 	mov	r4,zero
 322e86c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 322e870:	00bfffc4 	movi	r2,-1
 322e874:	e0bfff15 	stw	r2,-4(fp)
 322e878:	00000306 	br	322e888 <t_setsockopt+0x1c4>
      }   
   }

   UNLOCK_NET_RESOURCE (NET_RESID);
 322e87c:	0009883a 	mov	r4,zero
 322e880:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   return 0;
 322e884:	e03fff15 	stw	zero,-4(fp)
 322e888:	e0bfff17 	ldw	r2,-4(fp)
}
 322e88c:	e037883a 	mov	sp,fp
 322e890:	dfc00117 	ldw	ra,4(sp)
 322e894:	df000017 	ldw	fp,0(sp)
 322e898:	dec00204 	addi	sp,sp,8
 322e89c:	f800283a 	ret

0322e8a0 <t_getsockopt>:
   int   level,
   int   name,
   void *   arg,
   int   arglen)

{
 322e8a0:	defff604 	addi	sp,sp,-40
 322e8a4:	dfc00915 	stw	ra,36(sp)
 322e8a8:	df000815 	stw	fp,32(sp)
 322e8ac:	df000804 	addi	fp,sp,32
 322e8b0:	e13ffb15 	stw	r4,-20(fp)
 322e8b4:	e17ffc15 	stw	r5,-16(fp)
 322e8b8:	e1bffd15 	stw	r6,-12(fp)
 322e8bc:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 322e8c0:	e0bffb17 	ldw	r2,-20(fp)
 322e8c4:	10bff804 	addi	r2,r2,-32
 322e8c8:	1085883a 	add	r2,r2,r2
 322e8cc:	1085883a 	add	r2,r2,r2
 322e8d0:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 322e8d4:	0080c9b4 	movhi	r2,806
 322e8d8:	10b39704 	addi	r2,r2,-12708
 322e8dc:	e0bff815 	stw	r2,-32(fp)
 322e8e0:	00000606 	br	322e8fc <t_getsockopt+0x5c>
 322e8e4:	e0fff817 	ldw	r3,-32(fp)
 322e8e8:	e0bffa17 	ldw	r2,-24(fp)
 322e8ec:	18800626 	beq	r3,r2,322e908 <t_getsockopt+0x68>
 322e8f0:	e0bff817 	ldw	r2,-32(fp)
 322e8f4:	10800017 	ldw	r2,0(r2)
 322e8f8:	e0bff815 	stw	r2,-32(fp)
 322e8fc:	e0bff817 	ldw	r2,-32(fp)
 322e900:	1004c03a 	cmpne	r2,r2,zero
 322e904:	103ff71e 	bne	r2,zero,322e8e4 <t_getsockopt+0x44>
 322e908:	e0fff817 	ldw	r3,-32(fp)
 322e90c:	e0bffa17 	ldw	r2,-24(fp)
 322e910:	18800426 	beq	r3,r2,322e924 <t_getsockopt+0x84>
 322e914:	322ab8c0 	call	322ab8c <dtrap>
 322e918:	00bfffc4 	movi	r2,-1
 322e91c:	e0bfff15 	stw	r2,-4(fp)
 322e920:	00004206 	br	322ea2c <t_getsockopt+0x18c>
   USE_ARG(level);
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 322e924:	0009883a 	mov	r4,zero
 322e928:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   INET_TRACE (INETM_SOCKET,
    ("INET: getsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 322e92c:	e0bffc17 	ldw	r2,-16(fp)
 322e930:	10800060 	cmpeqi	r2,r2,1
 322e934:	1000101e 	bne	r2,zero,322e978 <t_getsockopt+0xd8>
   {
      if ((err = sogetopt (so, name, arg)) != 0) 
 322e938:	e13ffa17 	ldw	r4,-24(fp)
 322e93c:	e17ffd17 	ldw	r5,-12(fp)
 322e940:	e1bffe17 	ldw	r6,-8(fp)
 322e944:	32311b00 	call	32311b0 <sogetopt>
 322e948:	e0bff915 	stw	r2,-28(fp)
 322e94c:	e0bff917 	ldw	r2,-28(fp)
 322e950:	1005003a 	cmpeq	r2,r2,zero
 322e954:	1000301e 	bne	r2,zero,322ea18 <t_getsockopt+0x178>
      {
         so->so_error = err;
 322e958:	e0fffa17 	ldw	r3,-24(fp)
 322e95c:	e0bff917 	ldw	r2,-28(fp)
 322e960:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE (NET_RESID);
 322e964:	0009883a 	mov	r4,zero
 322e968:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 322e96c:	00bfffc4 	movi	r2,-1
 322e970:	e0bfff15 	stw	r2,-4(fp)
 322e974:	00002d06 	br	322ea2c <t_getsockopt+0x18c>
   {
      /* level 1 options are for the IP packet level.
       * the info is carried in the socket CB, then put 
       * into the PACKET.
       */
      if (name == IP_TTL_OPT)
 322e978:	e0bffd17 	ldw	r2,-12(fp)
 322e97c:	10800118 	cmpnei	r2,r2,4
 322e980:	10000f1e 	bne	r2,zero,322e9c0 <t_getsockopt+0x120>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TTL;
 322e984:	e0bffa17 	ldw	r2,-24(fp)
 322e988:	10801f17 	ldw	r2,124(r2)
 322e98c:	1004c03a 	cmpne	r2,r2,zero
 322e990:	1000041e 	bne	r2,zero,322e9a4 <t_getsockopt+0x104>
 322e994:	e0fffe17 	ldw	r3,-8(fp)
 322e998:	00801004 	movi	r2,64
 322e99c:	18800015 	stw	r2,0(r3)
 322e9a0:	00001d06 	br	322ea18 <t_getsockopt+0x178>
         else *(int *)arg = (int)so->so_optsPack->ip_ttl;
 322e9a4:	e0fffe17 	ldw	r3,-8(fp)
 322e9a8:	e0bffa17 	ldw	r2,-24(fp)
 322e9ac:	10801f17 	ldw	r2,124(r2)
 322e9b0:	10800043 	ldbu	r2,1(r2)
 322e9b4:	10803fcc 	andi	r2,r2,255
 322e9b8:	18800015 	stw	r2,0(r3)
 322e9bc:	00001606 	br	322ea18 <t_getsockopt+0x178>
      }
      else if (name == IP_TOS)
 322e9c0:	e0bffd17 	ldw	r2,-12(fp)
 322e9c4:	108000d8 	cmpnei	r2,r2,3
 322e9c8:	10000e1e 	bne	r2,zero,322ea04 <t_getsockopt+0x164>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TOS_DEFVAL;
 322e9cc:	e0bffa17 	ldw	r2,-24(fp)
 322e9d0:	10801f17 	ldw	r2,124(r2)
 322e9d4:	1004c03a 	cmpne	r2,r2,zero
 322e9d8:	1000031e 	bne	r2,zero,322e9e8 <t_getsockopt+0x148>
 322e9dc:	e0bffe17 	ldw	r2,-8(fp)
 322e9e0:	10000015 	stw	zero,0(r2)
 322e9e4:	00000c06 	br	322ea18 <t_getsockopt+0x178>
         else *(int *)arg = (int)so->so_optsPack->ip_tos;
 322e9e8:	e0fffe17 	ldw	r3,-8(fp)
 322e9ec:	e0bffa17 	ldw	r2,-24(fp)
 322e9f0:	10801f17 	ldw	r2,124(r2)
 322e9f4:	10800003 	ldbu	r2,0(r2)
 322e9f8:	10803fcc 	andi	r2,r2,255
 322e9fc:	18800015 	stw	r2,0(r3)
 322ea00:	00000506 	br	322ea18 <t_getsockopt+0x178>
      }
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 322ea04:	0009883a 	mov	r4,zero
 322ea08:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 322ea0c:	00bfffc4 	movi	r2,-1
 322ea10:	e0bfff15 	stw	r2,-4(fp)
 322ea14:	00000506 	br	322ea2c <t_getsockopt+0x18c>
      }
   }   
   so->so_error = 0;
 322ea18:	e0bffa17 	ldw	r2,-24(fp)
 322ea1c:	10000615 	stw	zero,24(r2)

   UNLOCK_NET_RESOURCE (NET_RESID);
 322ea20:	0009883a 	mov	r4,zero
 322ea24:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   return 0;
 322ea28:	e03fff15 	stw	zero,-4(fp)
 322ea2c:	e0bfff17 	ldw	r2,-4(fp)
}
 322ea30:	e037883a 	mov	sp,fp
 322ea34:	dfc00117 	ldw	ra,4(sp)
 322ea38:	df000017 	ldw	fp,0(sp)
 322ea3c:	dec00204 	addi	sp,sp,8
 322ea40:	f800283a 	ret

0322ea44 <t_recv>:
int
t_recv (long s, 
   char *   buf,
   int   len, 
   int   flag)
{
 322ea44:	defff504 	addi	sp,sp,-44
 322ea48:	dfc00a15 	stw	ra,40(sp)
 322ea4c:	df000915 	stw	fp,36(sp)
 322ea50:	df000904 	addi	fp,sp,36
 322ea54:	e13ffb15 	stw	r4,-20(fp)
 322ea58:	e17ffc15 	stw	r5,-16(fp)
 322ea5c:	e1bffd15 	stw	r6,-12(fp)
 322ea60:	e1fffe15 	stw	r7,-8(fp)
#ifdef SOCKDEBUG
   char logbuf[10];
#endif
   struct socket *   so;
   int   err;
   int   sendlen = len;
 322ea64:	e0bffd17 	ldw	r2,-12(fp)
 322ea68:	e0bff815 	stw	r2,-32(fp)

   so = LONG2SO(s);
 322ea6c:	e0bffb17 	ldw	r2,-20(fp)
 322ea70:	10bff804 	addi	r2,r2,-32
 322ea74:	1085883a 	add	r2,r2,r2
 322ea78:	1085883a 	add	r2,r2,r2
 322ea7c:	e0bffa15 	stw	r2,-24(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 322ea80:	e0bffa17 	ldw	r2,-24(fp)
 322ea84:	1080088b 	ldhu	r2,34(r2)
 322ea88:	10bfffcc 	andi	r2,r2,65535
 322ea8c:	1080038c 	andi	r2,r2,14
 322ea90:	108000a0 	cmpeqi	r2,r2,2
 322ea94:	1000061e 	bne	r2,zero,322eab0 <t_recv+0x6c>
   {
      so->so_error = EPIPE;
 322ea98:	e0fffa17 	ldw	r3,-24(fp)
 322ea9c:	00800804 	movi	r2,32
 322eaa0:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 322eaa4:	00bfffc4 	movi	r2,-1
 322eaa8:	e0bfff15 	stw	r2,-4(fp)
 322eaac:	00001b06 	br	322eb1c <t_recv+0xd8>
   }
   so->so_error = 0;
 322eab0:	e0bffa17 	ldw	r2,-24(fp)
 322eab4:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 322eab8:	0009883a 	mov	r4,zero
 322eabc:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   IN_PROFILER(PF_TCP, PF_ENTRY);        /* measure time in TCP */
   INET_TRACE (INETM_IO, ("INET:recv: so %x, len %d\n", so, len));
   err = soreceive(so, NULL, buf, &len, flag);
 322eac0:	e1fffd04 	addi	r7,fp,-12
 322eac4:	e0bffe17 	ldw	r2,-8(fp)
 322eac8:	d8800015 	stw	r2,0(sp)
 322eacc:	e13ffa17 	ldw	r4,-24(fp)
 322ead0:	000b883a 	mov	r5,zero
 322ead4:	e1bffc17 	ldw	r6,-16(fp)
 322ead8:	32303640 	call	3230364 <soreceive>
 322eadc:	e0bff915 	stw	r2,-28(fp)
   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   UNLOCK_NET_RESOURCE(NET_RESID);
 322eae0:	0009883a 	mov	r4,zero
 322eae4:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   if(err)
 322eae8:	e0bff917 	ldw	r2,-28(fp)
 322eaec:	1005003a 	cmpeq	r2,r2,zero
 322eaf0:	1000061e 	bne	r2,zero,322eb0c <t_recv+0xc8>
   {
      so->so_error = err;
 322eaf4:	e0fffa17 	ldw	r3,-24(fp)
 322eaf8:	e0bff917 	ldw	r2,-28(fp)
 322eafc:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 322eb00:	00bfffc4 	movi	r2,-1
 322eb04:	e0bfff15 	stw	r2,-4(fp)
 322eb08:	00000406 	br	322eb1c <t_recv+0xd8>
   }

   /* return bytes we sent - the amount we wanted to send minus
    * the amount left in the buffer.
    */
   return (sendlen - len);
 322eb0c:	e0fffd17 	ldw	r3,-12(fp)
 322eb10:	e0bff817 	ldw	r2,-32(fp)
 322eb14:	10c5c83a 	sub	r2,r2,r3
 322eb18:	e0bfff15 	stw	r2,-4(fp)
 322eb1c:	e0bfff17 	ldw	r2,-4(fp)
}
 322eb20:	e037883a 	mov	sp,fp
 322eb24:	dfc00117 	ldw	ra,4(sp)
 322eb28:	df000017 	ldw	fp,0(sp)
 322eb2c:	dec00204 	addi	sp,sp,8
 322eb30:	f800283a 	ret

0322eb34 <t_recvfrom>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * from,
   int * fromlen)
{
 322eb34:	defff304 	addi	sp,sp,-52
 322eb38:	dfc00c15 	stw	ra,48(sp)
 322eb3c:	df000b15 	stw	fp,44(sp)
 322eb40:	df000b04 	addi	fp,sp,44
 322eb44:	e13ffb15 	stw	r4,-20(fp)
 322eb48:	e17ffc15 	stw	r5,-16(fp)
 322eb4c:	e1bffd15 	stw	r6,-12(fp)
 322eb50:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   struct mbuf *     sender = NULL;
 322eb54:	e03ffa15 	stw	zero,-24(fp)
   int   err;
   int   sendlen = len;
 322eb58:	e0bffd17 	ldw	r2,-12(fp)
 322eb5c:	e0bff715 	stw	r2,-36(fp)

   so = LONG2SO(s);
 322eb60:	e0bffb17 	ldw	r2,-20(fp)
 322eb64:	10bff804 	addi	r2,r2,-32
 322eb68:	1085883a 	add	r2,r2,r2
 322eb6c:	1085883a 	add	r2,r2,r2
 322eb70:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 322eb74:	0080c9b4 	movhi	r2,806
 322eb78:	10b39704 	addi	r2,r2,-12708
 322eb7c:	e0bff615 	stw	r2,-40(fp)
 322eb80:	00000606 	br	322eb9c <t_recvfrom+0x68>
 322eb84:	e0fff617 	ldw	r3,-40(fp)
 322eb88:	e0bff917 	ldw	r2,-28(fp)
 322eb8c:	18800626 	beq	r3,r2,322eba8 <t_recvfrom+0x74>
 322eb90:	e0bff617 	ldw	r2,-40(fp)
 322eb94:	10800017 	ldw	r2,0(r2)
 322eb98:	e0bff615 	stw	r2,-40(fp)
 322eb9c:	e0bff617 	ldw	r2,-40(fp)
 322eba0:	1004c03a 	cmpne	r2,r2,zero
 322eba4:	103ff71e 	bne	r2,zero,322eb84 <t_recvfrom+0x50>
 322eba8:	e0fff617 	ldw	r3,-40(fp)
 322ebac:	e0bff917 	ldw	r2,-28(fp)
 322ebb0:	18800426 	beq	r3,r2,322ebc4 <t_recvfrom+0x90>
 322ebb4:	322ab8c0 	call	322ab8c <dtrap>
 322ebb8:	00bfffc4 	movi	r2,-1
 322ebbc:	e0bfff15 	stw	r2,-4(fp)
 322ebc0:	00002a06 	br	322ec6c <t_recvfrom+0x138>
   so->so_error = 0;
 322ebc4:	e0bff917 	ldw	r2,-28(fp)
 322ebc8:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 322ebcc:	0009883a 	mov	r4,zero
 322ebd0:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>

   err = soreceive(so, &sender, buf, &len, flags);
 322ebd4:	e17ffa04 	addi	r5,fp,-24
 322ebd8:	e1fffd04 	addi	r7,fp,-12
 322ebdc:	e0bffe17 	ldw	r2,-8(fp)
 322ebe0:	d8800015 	stw	r2,0(sp)
 322ebe4:	e13ff917 	ldw	r4,-28(fp)
 322ebe8:	e1bffc17 	ldw	r6,-16(fp)
 322ebec:	32303640 	call	3230364 <soreceive>
 322ebf0:	e0bff815 	stw	r2,-32(fp)

   /* copy sender info from mbuf to sockaddr */
   if (sender)
 322ebf4:	e0bffa17 	ldw	r2,-24(fp)
 322ebf8:	1005003a 	cmpeq	r2,r2,zero
 322ebfc:	10000c1e 	bne	r2,zero,322ec30 <t_recvfrom+0xfc>
   {
      MEMCPY(from, (mtod(sender, struct sockaddr *)), *fromlen );
 322ec00:	e0bffa17 	ldw	r2,-24(fp)
 322ec04:	10800317 	ldw	r2,12(r2)
 322ec08:	100b883a 	mov	r5,r2
 322ec0c:	e0800317 	ldw	r2,12(fp)
 322ec10:	10800017 	ldw	r2,0(r2)
 322ec14:	1007883a 	mov	r3,r2
 322ec18:	e0800217 	ldw	r2,8(fp)
 322ec1c:	1009883a 	mov	r4,r2
 322ec20:	180d883a 	mov	r6,r3
 322ec24:	32067cc0 	call	32067cc <memcpy>
      m_freem (sender);
 322ec28:	e13ffa17 	ldw	r4,-24(fp)
 322ec2c:	322bc680 	call	322bc68 <m_freem>
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 322ec30:	0009883a 	mov	r4,zero
 322ec34:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   if(err)
 322ec38:	e0bff817 	ldw	r2,-32(fp)
 322ec3c:	1005003a 	cmpeq	r2,r2,zero
 322ec40:	1000061e 	bne	r2,zero,322ec5c <t_recvfrom+0x128>
   {
      so->so_error = err;
 322ec44:	e0fff917 	ldw	r3,-28(fp)
 322ec48:	e0bff817 	ldw	r2,-32(fp)
 322ec4c:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322ec50:	00bfffc4 	movi	r2,-1
 322ec54:	e0bfff15 	stw	r2,-4(fp)
 322ec58:	00000406 	br	322ec6c <t_recvfrom+0x138>
   }

   /* OK return: amount of data actually sent */
   return (sendlen - len);
 322ec5c:	e0fffd17 	ldw	r3,-12(fp)
 322ec60:	e0bff717 	ldw	r2,-36(fp)
 322ec64:	10c5c83a 	sub	r2,r2,r3
 322ec68:	e0bfff15 	stw	r2,-4(fp)
 322ec6c:	e0bfff17 	ldw	r2,-4(fp)
}
 322ec70:	e037883a 	mov	sp,fp
 322ec74:	dfc00117 	ldw	ra,4(sp)
 322ec78:	df000017 	ldw	fp,0(sp)
 322ec7c:	dec00204 	addi	sp,sp,8
 322ec80:	f800283a 	ret

0322ec84 <t_sendto>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * to,
   int   tolen)
{
 322ec84:	defff204 	addi	sp,sp,-56
 322ec88:	dfc00d15 	stw	ra,52(sp)
 322ec8c:	df000c15 	stw	fp,48(sp)
 322ec90:	df000c04 	addi	fp,sp,48
 322ec94:	e13ffa15 	stw	r4,-24(fp)
 322ec98:	e17ffb15 	stw	r5,-20(fp)
 322ec9c:	e1bffc15 	stw	r6,-16(fp)
 322eca0:	e1fffd15 	stw	r7,-12(fp)
   struct socket *   so;
   int   sendlen;
   int   err;
   struct mbuf *     name;

   so = LONG2SO(s);
 322eca4:	e0bffa17 	ldw	r2,-24(fp)
 322eca8:	10bff804 	addi	r2,r2,-32
 322ecac:	1085883a 	add	r2,r2,r2
 322ecb0:	1085883a 	add	r2,r2,r2
 322ecb4:	e0bff815 	stw	r2,-32(fp)
   SOC_CHECK(so);
 322ecb8:	0080c9b4 	movhi	r2,806
 322ecbc:	10b39704 	addi	r2,r2,-12708
 322ecc0:	e0bff515 	stw	r2,-44(fp)
 322ecc4:	00000606 	br	322ece0 <t_sendto+0x5c>
 322ecc8:	e0fff517 	ldw	r3,-44(fp)
 322eccc:	e0bff817 	ldw	r2,-32(fp)
 322ecd0:	18800626 	beq	r3,r2,322ecec <t_sendto+0x68>
 322ecd4:	e0bff517 	ldw	r2,-44(fp)
 322ecd8:	10800017 	ldw	r2,0(r2)
 322ecdc:	e0bff515 	stw	r2,-44(fp)
 322ece0:	e0bff517 	ldw	r2,-44(fp)
 322ece4:	1004c03a 	cmpne	r2,r2,zero
 322ece8:	103ff71e 	bne	r2,zero,322ecc8 <t_sendto+0x44>
 322ecec:	e0fff517 	ldw	r3,-44(fp)
 322ecf0:	e0bff817 	ldw	r2,-32(fp)
 322ecf4:	18800426 	beq	r3,r2,322ed08 <t_sendto+0x84>
 322ecf8:	322ab8c0 	call	322ab8c <dtrap>
 322ecfc:	00bfffc4 	movi	r2,-1
 322ed00:	e0bfff15 	stw	r2,-4(fp)
 322ed04:	00006406 	br	322ee98 <t_sendto+0x214>
   so->so_error = 0;
 322ed08:	e0bff817 	ldw	r2,-32(fp)
 322ed0c:	10000615 	stw	zero,24(r2)

   switch (so->so_type)
 322ed10:	e0bff817 	ldw	r2,-32(fp)
 322ed14:	10800983 	ldbu	r2,38(r2)
 322ed18:	10803fcc 	andi	r2,r2,255
 322ed1c:	1080201c 	xori	r2,r2,128
 322ed20:	10bfe004 	addi	r2,r2,-128
 322ed24:	e0bffe15 	stw	r2,-8(fp)
 322ed28:	e0fffe17 	ldw	r3,-8(fp)
 322ed2c:	188000a0 	cmpeqi	r2,r3,2
 322ed30:	10000e1e 	bne	r2,zero,322ed6c <t_sendto+0xe8>
 322ed34:	e0fffe17 	ldw	r3,-8(fp)
 322ed38:	188000e0 	cmpeqi	r2,r3,3
 322ed3c:	10000e1e 	bne	r2,zero,322ed78 <t_sendto+0xf4>
 322ed40:	e0fffe17 	ldw	r3,-8(fp)
 322ed44:	18800060 	cmpeqi	r2,r3,1
 322ed48:	1000011e 	bne	r2,zero,322ed50 <t_sendto+0xcc>
 322ed4c:	00001006 	br	322ed90 <t_sendto+0x10c>
   {
   case SOCK_STREAM:
      /* this is a stream socket, so pass this request through
       * t_send() for its large-send support.
       */
      return t_send(s, buf, len, flags);
 322ed50:	e13ffa17 	ldw	r4,-24(fp)
 322ed54:	e17ffb17 	ldw	r5,-20(fp)
 322ed58:	e1bffc17 	ldw	r6,-16(fp)
 322ed5c:	e1fffd17 	ldw	r7,-12(fp)
 322ed60:	322eeb00 	call	322eeb0 <t_send>
 322ed64:	e0bfff15 	stw	r2,-4(fp)
 322ed68:	00004b06 	br	322ee98 <t_sendto+0x214>
      /*NOTREACHED*/
   case SOCK_DGRAM:
      /* datagram (UDP) socket -- prepare to check length */
      sendlen = udp_maxalloc();
 322ed6c:	32452500 	call	3245250 <udp_maxalloc>
 322ed70:	e0bff915 	stw	r2,-28(fp)
      break;
 322ed74:	00000d06 	br	322edac <t_sendto+0x128>
#ifdef IP_RAW
   case SOCK_RAW:
      /* raw socket -- prepare to check length */
      sendlen = ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 322ed78:	e0bff817 	ldw	r2,-32(fp)
 322ed7c:	10800417 	ldw	r2,16(r2)
 322ed80:	1108000c 	andi	r4,r2,8192
 322ed84:	3243d340 	call	3243d34 <ip_raw_maxalloc>
 322ed88:	e0bff915 	stw	r2,-28(fp)
      break;
 322ed8c:	00000706 	br	322edac <t_sendto+0x128>
#endif /* IP_RAW */
   default:
      /* socket has unknown type */
      dtrap();
 322ed90:	322ab8c0 	call	322ab8c <dtrap>
      so->so_error = EFAULT;
 322ed94:	e0fff817 	ldw	r3,-32(fp)
 322ed98:	00800384 	movi	r2,14
 322ed9c:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322eda0:	00bfffc4 	movi	r2,-1
 322eda4:	e0bfff15 	stw	r2,-4(fp)
 322eda8:	00003b06 	br	322ee98 <t_sendto+0x214>
   /* fall through for non-stream sockets: SOCK_DGRAM (UDP) and
    * SOCK_RAW (raw IP)
    */

   /* check length against underlying stack's maximum */
   if (len > sendlen)
 322edac:	e0fff917 	ldw	r3,-28(fp)
 322edb0:	e0bffc17 	ldw	r2,-16(fp)
 322edb4:	1880060e 	bge	r3,r2,322edd0 <t_sendto+0x14c>
   {
      so->so_error = EMSGSIZE;
 322edb8:	e0fff817 	ldw	r3,-32(fp)
 322edbc:	00801e84 	movi	r2,122
 322edc0:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322edc4:	00ffffc4 	movi	r3,-1
 322edc8:	e0ffff15 	stw	r3,-4(fp)
 322edcc:	00003206 	br	322ee98 <t_sendto+0x214>
   /* if a sockaddr was passed, wrap it in an mbuf and pas it into the
    * bowels of the BSD code; else assume this is a bound UDP socket
    * and this call came from t_send() below.
    */

   if (to)  /* sockaddr was passed */
 322edd0:	e0800217 	ldw	r2,8(fp)
 322edd4:	1005003a 	cmpeq	r2,r2,zero
 322edd8:	10000e1e 	bne	r2,zero,322ee14 <t_sendto+0x190>
   {
      name = sockargs(to, tolen, MT_SONAME);
 322eddc:	e1000217 	ldw	r4,8(fp)
 322ede0:	e1400317 	ldw	r5,12(fp)
 322ede4:	01800244 	movi	r6,9
 322ede8:	322f28c0 	call	322f28c <sockargs>
 322edec:	e0bff615 	stw	r2,-40(fp)
      if(name == NULL)
 322edf0:	e0bff617 	ldw	r2,-40(fp)
 322edf4:	1004c03a 	cmpne	r2,r2,zero
 322edf8:	1000071e 	bne	r2,zero,322ee18 <t_sendto+0x194>
      {
         so->so_error = ENOMEM;
 322edfc:	e0fff817 	ldw	r3,-32(fp)
 322ee00:	00800304 	movi	r2,12
 322ee04:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 322ee08:	00bfffc4 	movi	r2,-1
 322ee0c:	e0bfff15 	stw	r2,-4(fp)
 322ee10:	00002106 	br	322ee98 <t_sendto+0x214>
      }
   }
   else     /* hope user called bind() first... */
      name = NULL;
 322ee14:	e03ff615 	stw	zero,-40(fp)
   
   sendlen = len;
 322ee18:	e0bffc17 	ldw	r2,-16(fp)
 322ee1c:	e0bff915 	stw	r2,-28(fp)

   LOCK_NET_RESOURCE(NET_RESID);
 322ee20:	0009883a 	mov	r4,zero
 322ee24:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>

   err = sosend (so, name, buf, &sendlen, flags);
 322ee28:	e1fff904 	addi	r7,fp,-28
 322ee2c:	e0bffd17 	ldw	r2,-12(fp)
 322ee30:	d8800015 	stw	r2,0(sp)
 322ee34:	e13ff817 	ldw	r4,-32(fp)
 322ee38:	e17ff617 	ldw	r5,-40(fp)
 322ee3c:	e1bffb17 	ldw	r6,-20(fp)
 322ee40:	322fd5c0 	call	322fd5c <sosend>
 322ee44:	e0bff715 	stw	r2,-36(fp)

   if (name)
 322ee48:	e0bff617 	ldw	r2,-40(fp)
 322ee4c:	1005003a 	cmpeq	r2,r2,zero
 322ee50:	1000021e 	bne	r2,zero,322ee5c <t_sendto+0x1d8>
      m_freem(name);
 322ee54:	e13ff617 	ldw	r4,-40(fp)
 322ee58:	322bc680 	call	322bc68 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 322ee5c:	0009883a 	mov	r4,zero
 322ee60:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   if (err != 0)
 322ee64:	e0bff717 	ldw	r2,-36(fp)
 322ee68:	1005003a 	cmpeq	r2,r2,zero
 322ee6c:	1000061e 	bne	r2,zero,322ee88 <t_sendto+0x204>
   {
      so->so_error = err;
 322ee70:	e0fff817 	ldw	r3,-32(fp)
 322ee74:	e0bff717 	ldw	r2,-36(fp)
 322ee78:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322ee7c:	00ffffc4 	movi	r3,-1
 322ee80:	e0ffff15 	stw	r3,-4(fp)
 322ee84:	00000406 	br	322ee98 <t_sendto+0x214>
   }

   return (len - sendlen);
 322ee88:	e0fff917 	ldw	r3,-28(fp)
 322ee8c:	e0bffc17 	ldw	r2,-16(fp)
 322ee90:	10c5c83a 	sub	r2,r2,r3
 322ee94:	e0bfff15 	stw	r2,-4(fp)
 322ee98:	e0bfff17 	ldw	r2,-4(fp)
}
 322ee9c:	e037883a 	mov	sp,fp
 322eea0:	dfc00117 	ldw	ra,4(sp)
 322eea4:	df000017 	ldw	fp,0(sp)
 322eea8:	dec00204 	addi	sp,sp,8
 322eeac:	f800283a 	ret

0322eeb0 <t_send>:
int
t_send(long s, 
   char *   buf,
   int      len, 
   int      flags)
{
 322eeb0:	defff004 	addi	sp,sp,-64
 322eeb4:	dfc00f15 	stw	ra,60(sp)
 322eeb8:	df000e15 	stw	fp,56(sp)
 322eebc:	df000e04 	addi	fp,sp,56
 322eec0:	e13ffb15 	stw	r4,-20(fp)
 322eec4:	e17ffc15 	stw	r5,-16(fp)
 322eec8:	e1bffd15 	stw	r6,-12(fp)
 322eecc:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   e;       /* error holder */
   int   total_sent  =  0;
 322eed0:	e03ff715 	stw	zero,-36(fp)
   int   maxpkt;
   int   sendlen;
   int   sent;

   so = LONG2SO(s);
 322eed4:	e0bffb17 	ldw	r2,-20(fp)
 322eed8:	10bff804 	addi	r2,r2,-32
 322eedc:	1085883a 	add	r2,r2,r2
 322eee0:	1085883a 	add	r2,r2,r2
 322eee4:	e0bff915 	stw	r2,-28(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 322eee8:	e0bff917 	ldw	r2,-28(fp)
 322eeec:	1080088b 	ldhu	r2,34(r2)
 322eef0:	10bfffcc 	andi	r2,r2,65535
 322eef4:	1080038c 	andi	r2,r2,14
 322eef8:	108000a0 	cmpeqi	r2,r2,2
 322eefc:	1000061e 	bne	r2,zero,322ef18 <t_send+0x68>
   {
      so->so_error = EPIPE;
 322ef00:	e0fff917 	ldw	r3,-28(fp)
 322ef04:	00800804 	movi	r2,32
 322ef08:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322ef0c:	00bfffc4 	movi	r2,-1
 322ef10:	e0bfff15 	stw	r2,-4(fp)
 322ef14:	00006a06 	br	322f0c0 <t_send+0x210>
   }
   so->so_error = 0;
 322ef18:	e0bff917 	ldw	r2,-28(fp)
 322ef1c:	10000615 	stw	zero,24(r2)

   /* If this is not a stream socket, assume it is bound and pass to
    * t_sendto() with a null sockaddr
    */
   if (so->so_type != SOCK_STREAM)
 322ef20:	e0bff917 	ldw	r2,-28(fp)
 322ef24:	10800983 	ldbu	r2,38(r2)
 322ef28:	10803fcc 	andi	r2,r2,255
 322ef2c:	1080201c 	xori	r2,r2,128
 322ef30:	10bfe004 	addi	r2,r2,-128
 322ef34:	10800060 	cmpeqi	r2,r2,1
 322ef38:	1000091e 	bne	r2,zero,322ef60 <t_send+0xb0>
      return(t_sendto(s, buf, len, flags, NULL, 0));
 322ef3c:	d8000015 	stw	zero,0(sp)
 322ef40:	d8000115 	stw	zero,4(sp)
 322ef44:	e13ffb17 	ldw	r4,-20(fp)
 322ef48:	e17ffc17 	ldw	r5,-16(fp)
 322ef4c:	e1bffd17 	ldw	r6,-12(fp)
 322ef50:	e1fffe17 	ldw	r7,-8(fp)
 322ef54:	322ec840 	call	322ec84 <t_sendto>
 322ef58:	e0bfff15 	stw	r2,-4(fp)
 322ef5c:	00005806 	br	322f0c0 <t_send+0x210>

   maxpkt = TCP_MSS;
 322ef60:	00816d04 	movi	r2,1460
 322ef64:	e0bff615 	stw	r2,-40(fp)
   if(so->so_pcb)
 322ef68:	e0bff917 	ldw	r2,-28(fp)
 322ef6c:	10800117 	ldw	r2,4(r2)
 322ef70:	1005003a 	cmpeq	r2,r2,zero
 322ef74:	10004d1e 	bne	r2,zero,322f0ac <t_send+0x1fc>
   { 
      struct tcpcb * tp;
      tp = intotcpcb(so->so_pcb);   /* get tcp structure with mss */
 322ef78:	e0bff917 	ldw	r2,-28(fp)
 322ef7c:	10800117 	ldw	r2,4(r2)
 322ef80:	10800917 	ldw	r2,36(r2)
 322ef84:	e0bff415 	stw	r2,-48(fp)
      if(tp->t_maxseg)              /* Make sure it's set */
 322ef88:	e0bff417 	ldw	r2,-48(fp)
 322ef8c:	10800a0b 	ldhu	r2,40(r2)
 322ef90:	10bfffcc 	andi	r2,r2,65535
 322ef94:	1005003a 	cmpeq	r2,r2,zero
 322ef98:	1000441e 	bne	r2,zero,322f0ac <t_send+0x1fc>
         maxpkt = tp->t_maxseg;
 322ef9c:	e0bff417 	ldw	r2,-48(fp)
 322efa0:	10800a0b 	ldhu	r2,40(r2)
 322efa4:	10bfffcc 	andi	r2,r2,65535
 322efa8:	e0bff615 	stw	r2,-40(fp)
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 322efac:	00003f06 	br	322f0ac <t_send+0x1fc>
   {
      if (len > maxpkt)
 322efb0:	e0fffd17 	ldw	r3,-12(fp)
 322efb4:	e0bff617 	ldw	r2,-40(fp)
 322efb8:	10c0030e 	bge	r2,r3,322efc8 <t_send+0x118>
         sendlen = maxpkt;  /* take biggest block we can */
 322efbc:	e0bff617 	ldw	r2,-40(fp)
 322efc0:	e0bffa15 	stw	r2,-24(fp)
 322efc4:	00000206 	br	322efd0 <t_send+0x120>
      else
         sendlen = len;
 322efc8:	e0bffd17 	ldw	r2,-12(fp)
 322efcc:	e0bffa15 	stw	r2,-24(fp)
      sent = sendlen;
 322efd0:	e0bffa17 	ldw	r2,-24(fp)
 322efd4:	e0bff515 	stw	r2,-44(fp)

      LOCK_NET_RESOURCE(NET_RESID);
 322efd8:	0009883a 	mov	r4,zero
 322efdc:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      e = sosend (so, NULL, buf, &sendlen, flags);
 322efe0:	e1fffa04 	addi	r7,fp,-24
 322efe4:	e0bffe17 	ldw	r2,-8(fp)
 322efe8:	d8800015 	stw	r2,0(sp)
 322efec:	e13ff917 	ldw	r4,-28(fp)
 322eff0:	000b883a 	mov	r5,zero
 322eff4:	e1bffc17 	ldw	r6,-16(fp)
 322eff8:	322fd5c0 	call	322fd5c <sosend>
 322effc:	e0bff815 	stw	r2,-32(fp)
      UNLOCK_NET_RESOURCE(NET_RESID);
 322f000:	0009883a 	mov	r4,zero
 322f004:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
 
      if (e != 0)  /* sock_sendit failed? */
 322f008:	e0bff817 	ldw	r2,-32(fp)
 322f00c:	1005003a 	cmpeq	r2,r2,zero
 322f010:	1000121e 	bne	r2,zero,322f05c <t_send+0x1ac>
      {
         /* if we simply ran out of bufs, report back to caller. */
         if ((e == ENOBUFS) || (e == EWOULDBLOCK))
 322f014:	e0bff817 	ldw	r2,-32(fp)
 322f018:	10801a60 	cmpeqi	r2,r2,105
 322f01c:	1000031e 	bne	r2,zero,322f02c <t_send+0x17c>
 322f020:	e0bff817 	ldw	r2,-32(fp)
 322f024:	108002d8 	cmpnei	r2,r2,11
 322f028:	1000061e 	bne	r2,zero,322f044 <t_send+0x194>
            /* if we actually sent something before running out
             * of buffers, report what we sent; 
             * else, report the error and let the application 
             * retry the call later
             */
            if (total_sent != 0)
 322f02c:	e0bff717 	ldw	r2,-36(fp)
 322f030:	1005003a 	cmpeq	r2,r2,zero
 322f034:	1000031e 	bne	r2,zero,322f044 <t_send+0x194>
            {
               so->so_error = 0;
 322f038:	e0bff917 	ldw	r2,-28(fp)
 322f03c:	10000615 	stw	zero,24(r2)
               break;      /* break out of while(len) loop */
 322f040:	00001d06 	br	322f0b8 <t_send+0x208>
            }
         }
         so->so_error = e;
 322f044:	e0fff917 	ldw	r3,-28(fp)
 322f048:	e0bff817 	ldw	r2,-32(fp)
 322f04c:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 322f050:	00bfffc4 	movi	r2,-1
 322f054:	e0bfff15 	stw	r2,-4(fp)
 322f058:	00001906 	br	322f0c0 <t_send+0x210>
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
 322f05c:	e0bffa17 	ldw	r2,-24(fp)
 322f060:	1004c03a 	cmpne	r2,r2,zero
 322f064:	1000141e 	bne	r2,zero,322f0b8 <t_send+0x208>
         break;         /* break out of while(len) loop */

      /* adjust numbers & pointers, and go do next send loop */
      sent -= sendlen;        /* subtract anything that didn't get sent */
 322f068:	e0fffa17 	ldw	r3,-24(fp)
 322f06c:	e0bff517 	ldw	r2,-44(fp)
 322f070:	10c5c83a 	sub	r2,r2,r3
 322f074:	e0bff515 	stw	r2,-44(fp)
      buf += sent;
 322f078:	e0bff517 	ldw	r2,-44(fp)
 322f07c:	1007883a 	mov	r3,r2
 322f080:	e0bffc17 	ldw	r2,-16(fp)
 322f084:	10c5883a 	add	r2,r2,r3
 322f088:	e0bffc15 	stw	r2,-16(fp)
      len -= sent;
 322f08c:	e0fffd17 	ldw	r3,-12(fp)
 322f090:	e0bff517 	ldw	r2,-44(fp)
 322f094:	1885c83a 	sub	r2,r3,r2
 322f098:	e0bffd15 	stw	r2,-12(fp)
      total_sent += sent;
 322f09c:	e0fff717 	ldw	r3,-36(fp)
 322f0a0:	e0bff517 	ldw	r2,-44(fp)
 322f0a4:	1885883a 	add	r2,r3,r2
 322f0a8:	e0bff715 	stw	r2,-36(fp)
         maxpkt = tp->t_maxseg;
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 322f0ac:	e0bffd17 	ldw	r2,-12(fp)
 322f0b0:	1004c03a 	cmpne	r2,r2,zero
 322f0b4:	103fbe1e 	bne	r2,zero,322efb0 <t_send+0x100>
      len -= sent;
      total_sent += sent;
   }

   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   return total_sent;
 322f0b8:	e0bff717 	ldw	r2,-36(fp)
 322f0bc:	e0bfff15 	stw	r2,-4(fp)
 322f0c0:	e0bfff17 	ldw	r2,-4(fp)
}
 322f0c4:	e037883a 	mov	sp,fp
 322f0c8:	dfc00117 	ldw	ra,4(sp)
 322f0cc:	df000017 	ldw	fp,0(sp)
 322f0d0:	dec00204 	addi	sp,sp,8
 322f0d4:	f800283a 	ret

0322f0d8 <t_shutdown>:
 * RETURNS: 
 */

int
t_shutdown(long s, int   how)
{
 322f0d8:	defff804 	addi	sp,sp,-32
 322f0dc:	dfc00715 	stw	ra,28(sp)
 322f0e0:	df000615 	stw	fp,24(sp)
 322f0e4:	df000604 	addi	fp,sp,24
 322f0e8:	e13ffd15 	stw	r4,-12(fp)
 322f0ec:	e17ffe15 	stw	r5,-8(fp)
   struct socket *so;
   int   err;

   so = LONG2SO(s);
 322f0f0:	e0bffd17 	ldw	r2,-12(fp)
 322f0f4:	10bff804 	addi	r2,r2,-32
 322f0f8:	1085883a 	add	r2,r2,r2
 322f0fc:	1085883a 	add	r2,r2,r2
 322f100:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 322f104:	0080c9b4 	movhi	r2,806
 322f108:	10b39704 	addi	r2,r2,-12708
 322f10c:	e0bffa15 	stw	r2,-24(fp)
 322f110:	00000606 	br	322f12c <t_shutdown+0x54>
 322f114:	e0fffa17 	ldw	r3,-24(fp)
 322f118:	e0bffc17 	ldw	r2,-16(fp)
 322f11c:	18800626 	beq	r3,r2,322f138 <t_shutdown+0x60>
 322f120:	e0bffa17 	ldw	r2,-24(fp)
 322f124:	10800017 	ldw	r2,0(r2)
 322f128:	e0bffa15 	stw	r2,-24(fp)
 322f12c:	e0bffa17 	ldw	r2,-24(fp)
 322f130:	1004c03a 	cmpne	r2,r2,zero
 322f134:	103ff71e 	bne	r2,zero,322f114 <t_shutdown+0x3c>
 322f138:	e0fffa17 	ldw	r3,-24(fp)
 322f13c:	e0bffc17 	ldw	r2,-16(fp)
 322f140:	18800426 	beq	r3,r2,322f154 <t_shutdown+0x7c>
 322f144:	322ab8c0 	call	322ab8c <dtrap>
 322f148:	00bfffc4 	movi	r2,-1
 322f14c:	e0bfff15 	stw	r2,-4(fp)
 322f150:	00001406 	br	322f1a4 <t_shutdown+0xcc>
   so->so_error = 0;
 322f154:	e0bffc17 	ldw	r2,-16(fp)
 322f158:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:shutdown so %x how %d\n", so, how));

   LOCK_NET_RESOURCE(NET_RESID);
 322f15c:	0009883a 	mov	r4,zero
 322f160:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   err = soshutdown(so, how);
 322f164:	e13ffc17 	ldw	r4,-16(fp)
 322f168:	e17ffe17 	ldw	r5,-8(fp)
 322f16c:	3230b480 	call	3230b48 <soshutdown>
 322f170:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 322f174:	0009883a 	mov	r4,zero
 322f178:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   if (err != 0)
 322f17c:	e0bffb17 	ldw	r2,-20(fp)
 322f180:	1005003a 	cmpeq	r2,r2,zero
 322f184:	1000061e 	bne	r2,zero,322f1a0 <t_shutdown+0xc8>
   {
      so->so_error = err;
 322f188:	e0fffc17 	ldw	r3,-16(fp)
 322f18c:	e0bffb17 	ldw	r2,-20(fp)
 322f190:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322f194:	00bfffc4 	movi	r2,-1
 322f198:	e0bfff15 	stw	r2,-4(fp)
 322f19c:	00000106 	br	322f1a4 <t_shutdown+0xcc>
   }
   return 0;
 322f1a0:	e03fff15 	stw	zero,-4(fp)
 322f1a4:	e0bfff17 	ldw	r2,-4(fp)
}
 322f1a8:	e037883a 	mov	sp,fp
 322f1ac:	dfc00117 	ldw	ra,4(sp)
 322f1b0:	df000017 	ldw	fp,0(sp)
 322f1b4:	dec00204 	addi	sp,sp,8
 322f1b8:	f800283a 	ret

0322f1bc <t_socketclose>:
 * RETURNS: 
 */

int
t_socketclose(long s)
{
 322f1bc:	defff904 	addi	sp,sp,-28
 322f1c0:	dfc00615 	stw	ra,24(sp)
 322f1c4:	df000515 	stw	fp,20(sp)
 322f1c8:	df000504 	addi	fp,sp,20
 322f1cc:	e13ffe15 	stw	r4,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 322f1d0:	e0bffe17 	ldw	r2,-8(fp)
 322f1d4:	10bff804 	addi	r2,r2,-32
 322f1d8:	1085883a 	add	r2,r2,r2
 322f1dc:	1085883a 	add	r2,r2,r2
 322f1e0:	e0bffd15 	stw	r2,-12(fp)
   SOC_CHECK(so);
 322f1e4:	0080c9b4 	movhi	r2,806
 322f1e8:	10b39704 	addi	r2,r2,-12708
 322f1ec:	e0bffb15 	stw	r2,-20(fp)
 322f1f0:	00000606 	br	322f20c <t_socketclose+0x50>
 322f1f4:	e0fffb17 	ldw	r3,-20(fp)
 322f1f8:	e0bffd17 	ldw	r2,-12(fp)
 322f1fc:	18800626 	beq	r3,r2,322f218 <t_socketclose+0x5c>
 322f200:	e0bffb17 	ldw	r2,-20(fp)
 322f204:	10800017 	ldw	r2,0(r2)
 322f208:	e0bffb15 	stw	r2,-20(fp)
 322f20c:	e0bffb17 	ldw	r2,-20(fp)
 322f210:	1004c03a 	cmpne	r2,r2,zero
 322f214:	103ff71e 	bne	r2,zero,322f1f4 <t_socketclose+0x38>
 322f218:	e0fffb17 	ldw	r3,-20(fp)
 322f21c:	e0bffd17 	ldw	r2,-12(fp)
 322f220:	18800426 	beq	r3,r2,322f234 <t_socketclose+0x78>
 322f224:	322ab8c0 	call	322ab8c <dtrap>
 322f228:	00bfffc4 	movi	r2,-1
 322f22c:	e0bfff15 	stw	r2,-4(fp)
 322f230:	00001006 	br	322f274 <t_socketclose+0xb8>
   so->so_error = 0;
 322f234:	e0bffd17 	ldw	r2,-12(fp)
 322f238:	10000615 	stw	zero,24(r2)
   INET_TRACE ((INETM_CLOSE|INETM_SOCKET), ("INET:close, so %lx\n",so));

   LOCK_NET_RESOURCE(NET_RESID);
 322f23c:	0009883a 	mov	r4,zero
 322f240:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   err = soclose(so);
 322f244:	e13ffd17 	ldw	r4,-12(fp)
 322f248:	322f8080 	call	322f808 <soclose>
 322f24c:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 322f250:	0009883a 	mov	r4,zero
 322f254:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 322f258:	e0bffc17 	ldw	r2,-16(fp)
 322f25c:	1005003a 	cmpeq	r2,r2,zero
 322f260:	1000031e 	bne	r2,zero,322f270 <t_socketclose+0xb4>
   {
      /* do not do the following assignment since the socket structure
         addressed by so has been freed by this point, jharan 12-10-98 */
      /*      so->so_error = err;   */
      return SOCKET_ERROR;
 322f264:	00bfffc4 	movi	r2,-1
 322f268:	e0bfff15 	stw	r2,-4(fp)
 322f26c:	00000106 	br	322f274 <t_socketclose+0xb8>
   }
   return 0;
 322f270:	e03fff15 	stw	zero,-4(fp)
 322f274:	e0bfff17 	ldw	r2,-4(fp)
}
 322f278:	e037883a 	mov	sp,fp
 322f27c:	dfc00117 	ldw	ra,4(sp)
 322f280:	df000017 	ldw	fp,0(sp)
 322f284:	dec00204 	addi	sp,sp,8
 322f288:	f800283a 	ret

0322f28c <sockargs>:

static struct mbuf  * 
sockargs (void * arg, 
   int   arglen, 
   int   type)
{
 322f28c:	defff904 	addi	sp,sp,-28
 322f290:	dfc00615 	stw	ra,24(sp)
 322f294:	df000515 	stw	fp,20(sp)
 322f298:	df000504 	addi	fp,sp,20
 322f29c:	e13ffc15 	stw	r4,-16(fp)
 322f2a0:	e17ffd15 	stw	r5,-12(fp)
 322f2a4:	e1bffe15 	stw	r6,-8(fp)
   struct mbuf *  m;

   LOCK_NET_RESOURCE(NET_RESID);    /* protect mfreeq */
 322f2a8:	0009883a 	mov	r4,zero
 322f2ac:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   m = m_getwithdata (type, arglen);
 322f2b0:	e13ffe17 	ldw	r4,-8(fp)
 322f2b4:	e17ffd17 	ldw	r5,-12(fp)
 322f2b8:	322b98c0 	call	322b98c <m_getnbuf>
 322f2bc:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 322f2c0:	0009883a 	mov	r4,zero
 322f2c4:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   if (m == NULL)
 322f2c8:	e0bffb17 	ldw	r2,-20(fp)
 322f2cc:	1004c03a 	cmpne	r2,r2,zero
 322f2d0:	1000021e 	bne	r2,zero,322f2dc <sockargs+0x50>
      return NULL;
 322f2d4:	e03fff15 	stw	zero,-4(fp)
 322f2d8:	00000c06 	br	322f30c <sockargs+0x80>
   m->m_len = arglen;
 322f2dc:	e0fffd17 	ldw	r3,-12(fp)
 322f2e0:	e0bffb17 	ldw	r2,-20(fp)
 322f2e4:	10c00215 	stw	r3,8(r2)
   MEMCPY(mtod (m, char *), arg, arglen);
 322f2e8:	e0bffb17 	ldw	r2,-20(fp)
 322f2ec:	10c00317 	ldw	r3,12(r2)
 322f2f0:	e1bffd17 	ldw	r6,-12(fp)
 322f2f4:	e0bffc17 	ldw	r2,-16(fp)
 322f2f8:	1809883a 	mov	r4,r3
 322f2fc:	100b883a 	mov	r5,r2
 322f300:	32067cc0 	call	32067cc <memcpy>
   return m;
 322f304:	e0bffb17 	ldw	r2,-20(fp)
 322f308:	e0bfff15 	stw	r2,-4(fp)
 322f30c:	e0bfff17 	ldw	r2,-4(fp)
}
 322f310:	e037883a 	mov	sp,fp
 322f314:	dfc00117 	ldw	ra,4(sp)
 322f318:	df000017 	ldw	fp,0(sp)
 322f31c:	dec00204 	addi	sp,sp,8
 322f320:	f800283a 	ret

0322f324 <t_errno>:
 *                            ENOTSOCK if socket not found
 */

int
t_errno(long s)
{
 322f324:	defffa04 	addi	sp,sp,-24
 322f328:	dfc00515 	stw	ra,20(sp)
 322f32c:	df000415 	stw	fp,16(sp)
 322f330:	df000404 	addi	fp,sp,16
 322f334:	e13fff15 	stw	r4,-4(fp)
   struct socket *so = LONG2SO(s);
 322f338:	e0bfff17 	ldw	r2,-4(fp)
 322f33c:	10bff804 	addi	r2,r2,-32
 322f340:	1085883a 	add	r2,r2,r2
 322f344:	1085883a 	add	r2,r2,r2
 322f348:	e0bffe15 	stw	r2,-8(fp)
   struct socket *tmp;
   int errcode = ENOTSOCK;
 322f34c:	00801b04 	movi	r2,108
 322f350:	e0bffc15 	stw	r2,-16(fp)

   LOCK_NET_RESOURCE(NET_RESID);    /* protect soq */
 322f354:	0009883a 	mov	r4,zero
 322f358:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 322f35c:	0080c9b4 	movhi	r2,806
 322f360:	10b39704 	addi	r2,r2,-12708
 322f364:	e0bffd15 	stw	r2,-12(fp)
 322f368:	00000a06 	br	322f394 <t_errno+0x70>
   {
      if (tmp == so)  /* found socket, return error */
 322f36c:	e0fffd17 	ldw	r3,-12(fp)
 322f370:	e0bffe17 	ldw	r2,-8(fp)
 322f374:	1880041e 	bne	r3,r2,322f388 <t_errno+0x64>
      {
         errcode = so->so_error;
 322f378:	e0bffe17 	ldw	r2,-8(fp)
 322f37c:	10800617 	ldw	r2,24(r2)
 322f380:	e0bffc15 	stw	r2,-16(fp)
         break;
 322f384:	00000606 	br	322f3a0 <t_errno+0x7c>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 322f388:	e0bffd17 	ldw	r2,-12(fp)
 322f38c:	10800017 	ldw	r2,0(r2)
 322f390:	e0bffd15 	stw	r2,-12(fp)
 322f394:	e0bffd17 	ldw	r2,-12(fp)
 322f398:	1004c03a 	cmpne	r2,r2,zero
 322f39c:	103ff31e 	bne	r2,zero,322f36c <t_errno+0x48>
         errcode = so->so_error;
         break;
      }
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 322f3a0:	0009883a 	mov	r4,zero
 322f3a4:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   return errcode;
 322f3a8:	e0bffc17 	ldw	r2,-16(fp)
}
 322f3ac:	e037883a 	mov	sp,fp
 322f3b0:	dfc00117 	ldw	ra,4(sp)
 322f3b4:	df000017 	ldw	fp,0(sp)
 322f3b8:	dec00204 	addi	sp,sp,8
 322f3bc:	f800283a 	ret

0322f3c0 <socreate>:
 * RETURNS: 
 */

struct socket *   
socreate (int dom, int type, int proto)
{
 322f3c0:	defff604 	addi	sp,sp,-40
 322f3c4:	dfc00915 	stw	ra,36(sp)
 322f3c8:	df000815 	stw	fp,32(sp)
 322f3cc:	df000804 	addi	fp,sp,32
 322f3d0:	e13ffc15 	stw	r4,-16(fp)
 322f3d4:	e17ffd15 	stw	r5,-12(fp)
 322f3d8:	e1bffe15 	stw	r6,-8(fp)
   struct protosw *prp;
   struct socket *so;
   int   error;
   int rc;

   if (proto)
 322f3dc:	e0bffe17 	ldw	r2,-8(fp)
 322f3e0:	1005003a 	cmpeq	r2,r2,zero
 322f3e4:	1000061e 	bne	r2,zero,322f400 <socreate+0x40>
      prp = pffindproto(dom, proto, type);
 322f3e8:	e13ffc17 	ldw	r4,-16(fp)
 322f3ec:	e17ffe17 	ldw	r5,-8(fp)
 322f3f0:	e1bffd17 	ldw	r6,-12(fp)
 322f3f4:	322b8bc0 	call	322b8bc <pffindproto>
 322f3f8:	e0bffb15 	stw	r2,-20(fp)
 322f3fc:	00000406 	br	322f410 <socreate+0x50>
   else
      prp = pffindtype(dom, type);
 322f400:	e13ffc17 	ldw	r4,-16(fp)
 322f404:	e17ffd17 	ldw	r5,-12(fp)
 322f408:	322b81c0 	call	322b81c <pffindtype>
 322f40c:	e0bffb15 	stw	r2,-20(fp)
   if (prp == 0)
 322f410:	e0bffb17 	ldw	r2,-20(fp)
 322f414:	1004c03a 	cmpne	r2,r2,zero
 322f418:	1000021e 	bne	r2,zero,322f424 <socreate+0x64>
      return NULL;
 322f41c:	e03fff15 	stw	zero,-4(fp)
 322f420:	00005406 	br	322f574 <socreate+0x1b4>
   if (prp->pr_type != type)
 322f424:	e0bffb17 	ldw	r2,-20(fp)
 322f428:	1080000b 	ldhu	r2,0(r2)
 322f42c:	10ffffcc 	andi	r3,r2,65535
 322f430:	18e0001c 	xori	r3,r3,32768
 322f434:	18e00004 	addi	r3,r3,-32768
 322f438:	e0bffd17 	ldw	r2,-12(fp)
 322f43c:	18800226 	beq	r3,r2,322f448 <socreate+0x88>
      return NULL;
 322f440:	e03fff15 	stw	zero,-4(fp)
 322f444:	00004b06 	br	322f574 <socreate+0x1b4>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 322f448:	01002104 	movi	r4,132
 322f44c:	322b5d00 	call	322b5d0 <npalloc>
 322f450:	e0bffa15 	stw	r2,-24(fp)
 322f454:	e0bffa17 	ldw	r2,-24(fp)
 322f458:	1004c03a 	cmpne	r2,r2,zero
 322f45c:	1000021e 	bne	r2,zero,322f468 <socreate+0xa8>
      return NULL;
 322f460:	e03fff15 	stw	zero,-4(fp)
 322f464:	00004306 	br	322f574 <socreate+0x1b4>
   so->next = NULL;
 322f468:	e0bffa17 	ldw	r2,-24(fp)
 322f46c:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);
 322f470:	e17ffa17 	ldw	r5,-24(fp)
 322f474:	0100c9b4 	movhi	r4,806
 322f478:	21339704 	addi	r4,r4,-12708
 322f47c:	322a51c0 	call	322a51c <putq>

   so->so_options = socket_defaults;
 322f480:	d0a0380b 	ldhu	r2,-32544(gp)
 322f484:	10ffffcc 	andi	r3,r2,65535
 322f488:	e0bffa17 	ldw	r2,-24(fp)
 322f48c:	10c00415 	stw	r3,16(r2)
   so->so_domain = dom;
 322f490:	e0fffa17 	ldw	r3,-24(fp)
 322f494:	e0bffc17 	ldw	r2,-16(fp)
 322f498:	18800515 	stw	r2,20(r3)
   so->so_state = 0;
 322f49c:	e0bffa17 	ldw	r2,-24(fp)
 322f4a0:	1000088d 	sth	zero,34(r2)
   so->so_type = (char)type;
 322f4a4:	e0bffd17 	ldw	r2,-12(fp)
 322f4a8:	1007883a 	mov	r3,r2
 322f4ac:	e0bffa17 	ldw	r2,-24(fp)
 322f4b0:	10c00985 	stb	r3,38(r2)
   so->so_proto = prp;
 322f4b4:	e0fffa17 	ldw	r3,-24(fp)
 322f4b8:	e0bffb17 	ldw	r2,-20(fp)
 322f4bc:	18800215 	stw	r2,8(r3)

#ifdef IP_MULTICAST
   so->inp_moptions = NULL;
 322f4c0:	e0bffa17 	ldw	r2,-24(fp)
 322f4c4:	10000315 	stw	zero,12(r2)
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
 322f4c8:	e0bffa17 	ldw	r2,-24(fp)
 322f4cc:	10000715 	stw	zero,28(r2)
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
 322f4d0:	e0bffb17 	ldw	r2,-20(fp)
 322f4d4:	10800317 	ldw	r2,12(r2)
 322f4d8:	e1bffe17 	ldw	r6,-8(fp)
 322f4dc:	e13ffa17 	ldw	r4,-24(fp)
 322f4e0:	000b883a 	mov	r5,zero
 322f4e4:	103ee83a 	callr	r2
 322f4e8:	e0bff915 	stw	r2,-28(fp)
   if (error) goto bad;
 322f4ec:	e0bff917 	ldw	r2,-28(fp)
 322f4f0:	1004c03a 	cmpne	r2,r2,zero
 322f4f4:	10000f1e 	bne	r2,zero,322f534 <socreate+0x174>

   if (so_evtmap)
 322f4f8:	0080c974 	movhi	r2,805
 322f4fc:	10927c04 	addi	r2,r2,18928
 322f500:	10800003 	ldbu	r2,0(r2)
 322f504:	10803fcc 	andi	r2,r2,255
 322f508:	1005003a 	cmpeq	r2,r2,zero
 322f50c:	1000171e 	bne	r2,zero,322f56c <socreate+0x1ac>
   {                       
      rc = (*so_evtmap_create) (so);
 322f510:	0080c974 	movhi	r2,805
 322f514:	10927a04 	addi	r2,r2,18920
 322f518:	10800017 	ldw	r2,0(r2)
 322f51c:	e13ffa17 	ldw	r4,-24(fp)
 322f520:	103ee83a 	callr	r2
 322f524:	e0bff815 	stw	r2,-32(fp)
      if (rc != 0)
 322f528:	e0bff817 	ldw	r2,-32(fp)
 322f52c:	1005003a 	cmpeq	r2,r2,zero
 322f530:	10000a1e 	bne	r2,zero,322f55c <socreate+0x19c>
      {
bad:   
         so->so_state |= SS_NOFDREF;
 322f534:	e0bffa17 	ldw	r2,-24(fp)
 322f538:	1080088b 	ldhu	r2,34(r2)
 322f53c:	10800054 	ori	r2,r2,1
 322f540:	1007883a 	mov	r3,r2
 322f544:	e0bffa17 	ldw	r2,-24(fp)
 322f548:	10c0088d 	sth	r3,34(r2)
         sofree (so);
 322f54c:	e13ffa17 	ldw	r4,-24(fp)
 322f550:	322f6d80 	call	322f6d8 <sofree>
         return NULL;   
 322f554:	e03fff15 	stw	zero,-4(fp)
 322f558:	00000606 	br	322f574 <socreate+0x1b4>
      /*
       * Altera Niche Stack Nios port modification:
       * Remove (void *) cast since -> owner is now TK_OBJECT
       * to fix build warning.
       */
      so->owner = TK_THIS;
 322f55c:	3226a040 	call	3226a04 <TK_OSTaskQuery>
 322f560:	1007883a 	mov	r3,r2
 322f564:	e0bffa17 	ldw	r2,-24(fp)
 322f568:	10c02005 	stb	r3,128(r2)
   }

   return so;
 322f56c:	e0bffa17 	ldw	r2,-24(fp)
 322f570:	e0bfff15 	stw	r2,-4(fp)
 322f574:	e0bfff17 	ldw	r2,-4(fp)
}
 322f578:	e037883a 	mov	sp,fp
 322f57c:	dfc00117 	ldw	ra,4(sp)
 322f580:	df000017 	ldw	fp,0(sp)
 322f584:	dec00204 	addi	sp,sp,8
 322f588:	f800283a 	ret

0322f58c <sobind>:
 */

int
sobind(struct socket * so, 
   struct mbuf *  nam)
{
 322f58c:	defffb04 	addi	sp,sp,-20
 322f590:	dfc00415 	stw	ra,16(sp)
 322f594:	df000315 	stw	fp,12(sp)
 322f598:	df000304 	addi	fp,sp,12
 322f59c:	e13ffe15 	stw	r4,-8(fp)
 322f5a0:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_BIND;
 322f5a4:	e0fffe17 	ldw	r3,-8(fp)
 322f5a8:	00800084 	movi	r2,2
 322f5ac:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 322f5b0:	e0bffe17 	ldw	r2,-8(fp)
 322f5b4:	10800217 	ldw	r2,8(r2)
 322f5b8:	10800317 	ldw	r2,12(r2)
 322f5bc:	e13ffe17 	ldw	r4,-8(fp)
 322f5c0:	000b883a 	mov	r5,zero
 322f5c4:	e1bfff17 	ldw	r6,-4(fp)
 322f5c8:	103ee83a 	callr	r2
 322f5cc:	e0bffd15 	stw	r2,-12(fp)
   return (error);
 322f5d0:	e0bffd17 	ldw	r2,-12(fp)
}
 322f5d4:	e037883a 	mov	sp,fp
 322f5d8:	dfc00117 	ldw	ra,4(sp)
 322f5dc:	df000017 	ldw	fp,0(sp)
 322f5e0:	dec00204 	addi	sp,sp,8
 322f5e4:	f800283a 	ret

0322f5e8 <solisten>:
 */

int
solisten(struct socket * so, 
   int   backlog)
{
 322f5e8:	defff904 	addi	sp,sp,-28
 322f5ec:	dfc00615 	stw	ra,24(sp)
 322f5f0:	df000515 	stw	fp,20(sp)
 322f5f4:	df000504 	addi	fp,sp,20
 322f5f8:	e13ffc15 	stw	r4,-16(fp)
 322f5fc:	e17ffd15 	stw	r5,-12(fp)
   int   error;

   so->so_req = PRU_LISTEN;
 322f600:	e0fffc17 	ldw	r3,-16(fp)
 322f604:	008000c4 	movi	r2,3
 322f608:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so,
 322f60c:	e0bffc17 	ldw	r2,-16(fp)
 322f610:	10800217 	ldw	r2,8(r2)
 322f614:	10800317 	ldw	r2,12(r2)
 322f618:	e13ffc17 	ldw	r4,-16(fp)
 322f61c:	000b883a 	mov	r5,zero
 322f620:	000d883a 	mov	r6,zero
 322f624:	103ee83a 	callr	r2
 322f628:	e0bffb15 	stw	r2,-20(fp)
    (struct mbuf *)0, (struct mbuf *)0);
   if (error) 
 322f62c:	e0bffb17 	ldw	r2,-20(fp)
 322f630:	1005003a 	cmpeq	r2,r2,zero
 322f634:	1000031e 	bne	r2,zero,322f644 <solisten+0x5c>
   {
      return (error);
 322f638:	e0bffb17 	ldw	r2,-20(fp)
 322f63c:	e0bfff15 	stw	r2,-4(fp)
 322f640:	00001f06 	br	322f6c0 <solisten+0xd8>
   }
   if (so->so_q == 0) 
 322f644:	e0bffc17 	ldw	r2,-16(fp)
 322f648:	10801d17 	ldw	r2,116(r2)
 322f64c:	1004c03a 	cmpne	r2,r2,zero
 322f650:	10000b1e 	bne	r2,zero,322f680 <solisten+0x98>
   {
      so->so_q = so;
 322f654:	e0fffc17 	ldw	r3,-16(fp)
 322f658:	e0bffc17 	ldw	r2,-16(fp)
 322f65c:	18801d15 	stw	r2,116(r3)
      so->so_q0 = so;
 322f660:	e0fffc17 	ldw	r3,-16(fp)
 322f664:	e0bffc17 	ldw	r2,-16(fp)
 322f668:	18801c15 	stw	r2,112(r3)
      so->so_options |= SO_ACCEPTCONN;
 322f66c:	e0bffc17 	ldw	r2,-16(fp)
 322f670:	10800417 	ldw	r2,16(r2)
 322f674:	10c00094 	ori	r3,r2,2
 322f678:	e0bffc17 	ldw	r2,-16(fp)
 322f67c:	10c00415 	stw	r3,16(r2)
   }
   if (backlog < 0)
 322f680:	e0bffd17 	ldw	r2,-12(fp)
 322f684:	1004403a 	cmpge	r2,r2,zero
 322f688:	1000011e 	bne	r2,zero,322f690 <solisten+0xa8>
      backlog = 0;
 322f68c:	e03ffd15 	stw	zero,-12(fp)
   so->so_qlimit = (char)MIN(backlog, SOMAXCONN);
 322f690:	e0fffd17 	ldw	r3,-12(fp)
 322f694:	e0fffe15 	stw	r3,-8(fp)
 322f698:	e0fffe17 	ldw	r3,-8(fp)
 322f69c:	18800190 	cmplti	r2,r3,6
 322f6a0:	1000021e 	bne	r2,zero,322f6ac <solisten+0xc4>
 322f6a4:	00800144 	movi	r2,5
 322f6a8:	e0bffe15 	stw	r2,-8(fp)
 322f6ac:	e0bffe17 	ldw	r2,-8(fp)
 322f6b0:	1007883a 	mov	r3,r2
 322f6b4:	e0bffc17 	ldw	r2,-16(fp)
 322f6b8:	10c01e85 	stb	r3,122(r2)
   return 0;
 322f6bc:	e03fff15 	stw	zero,-4(fp)
 322f6c0:	e0bfff17 	ldw	r2,-4(fp)
}
 322f6c4:	e037883a 	mov	sp,fp
 322f6c8:	dfc00117 	ldw	ra,4(sp)
 322f6cc:	df000017 	ldw	fp,0(sp)
 322f6d0:	dec00204 	addi	sp,sp,8
 322f6d4:	f800283a 	ret

0322f6d8 <sofree>:
 * RETURNS: 
 */

void
sofree(struct socket * so)
{
 322f6d8:	defffd04 	addi	sp,sp,-12
 322f6dc:	dfc00215 	stw	ra,8(sp)
 322f6e0:	df000115 	stw	fp,4(sp)
 322f6e4:	df000104 	addi	fp,sp,4
 322f6e8:	e13fff15 	stw	r4,-4(fp)
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
 322f6ec:	e0bfff17 	ldw	r2,-4(fp)
 322f6f0:	10800117 	ldw	r2,4(r2)
 322f6f4:	1004c03a 	cmpne	r2,r2,zero
 322f6f8:	10003e1e 	bne	r2,zero,322f7f4 <sofree+0x11c>
 322f6fc:	e0bfff17 	ldw	r2,-4(fp)
 322f700:	1080088b 	ldhu	r2,34(r2)
 322f704:	10bfffcc 	andi	r2,r2,65535
 322f708:	1080004c 	andi	r2,r2,1
 322f70c:	1004c03a 	cmpne	r2,r2,zero
 322f710:	1000011e 	bne	r2,zero,322f718 <sofree+0x40>
      return;
 322f714:	00003706 	br	322f7f4 <sofree+0x11c>
   if (so->so_head) 
 322f718:	e0bfff17 	ldw	r2,-4(fp)
 322f71c:	10801b17 	ldw	r2,108(r2)
 322f720:	1005003a 	cmpeq	r2,r2,zero
 322f724:	10000f1e 	bne	r2,zero,322f764 <sofree+0x8c>
   {
      if (!soqremque(so, 0) && !soqremque(so, 1))
 322f728:	e13fff17 	ldw	r4,-4(fp)
 322f72c:	000b883a 	mov	r5,zero
 322f730:	3231cac0 	call	3231cac <soqremque>
 322f734:	1004c03a 	cmpne	r2,r2,zero
 322f738:	1000081e 	bne	r2,zero,322f75c <sofree+0x84>
 322f73c:	e13fff17 	ldw	r4,-4(fp)
 322f740:	01400044 	movi	r5,1
 322f744:	3231cac0 	call	3231cac <soqremque>
 322f748:	1004c03a 	cmpne	r2,r2,zero
 322f74c:	1000031e 	bne	r2,zero,322f75c <sofree+0x84>
         panic("sofree");
 322f750:	0100c974 	movhi	r4,805
 322f754:	213d4604 	addi	r4,r4,-2792
 322f758:	3225df00 	call	3225df0 <panic>
      so->so_head = 0;
 322f75c:	e0bfff17 	ldw	r2,-4(fp)
 322f760:	10001b15 	stw	zero,108(r2)
   }
   sbrelease(&so->so_snd);
 322f764:	e0bfff17 	ldw	r2,-4(fp)
 322f768:	11001204 	addi	r4,r2,72
 322f76c:	32320880 	call	3232088 <sbrelease>
   sorflush(so);
 322f770:	e13fff17 	ldw	r4,-4(fp)
 322f774:	3230bf00 	call	3230bf0 <sorflush>
      _socket_free_entry (so);
#endif   /* SAVE_SOCK_ENDPOINTS */

#ifdef IP_MULTICAST
   /* multicast opts? */
   if (so->inp_moptions)
 322f778:	e0bfff17 	ldw	r2,-4(fp)
 322f77c:	10800317 	ldw	r2,12(r2)
 322f780:	1005003a 	cmpeq	r2,r2,zero
 322f784:	1000031e 	bne	r2,zero,322f794 <sofree+0xbc>
	   ip_freemoptions(so->inp_moptions);
 322f788:	e0bfff17 	ldw	r2,-4(fp)
 322f78c:	11000317 	ldw	r4,12(r2)
 322f790:	32465dc0 	call	32465dc <ip_freemoptions>
#endif   /* IP_MULTICAST */

   /* IP_TOS opts? */
   if (so->so_optsPack)
 322f794:	e0bfff17 	ldw	r2,-4(fp)
 322f798:	10801f17 	ldw	r2,124(r2)
 322f79c:	1005003a 	cmpeq	r2,r2,zero
 322f7a0:	1000031e 	bne	r2,zero,322f7b0 <sofree+0xd8>
      SOCOPT_FREE(so->so_optsPack);
 322f7a4:	e0bfff17 	ldw	r2,-4(fp)
 322f7a8:	11001f17 	ldw	r4,124(r2)
 322f7ac:	322b6c40 	call	322b6c4 <npfree>
	   
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 322f7b0:	0100c9b4 	movhi	r4,806
 322f7b4:	21339704 	addi	r4,r4,-12708
 322f7b8:	e17fff17 	ldw	r5,-4(fp)
 322f7bc:	322a5cc0 	call	322a5cc <qdel>
   
   if (so_evtmap)  
 322f7c0:	0080c974 	movhi	r2,805
 322f7c4:	10927c04 	addi	r2,r2,18928
 322f7c8:	10800003 	ldbu	r2,0(r2)
 322f7cc:	10803fcc 	andi	r2,r2,255
 322f7d0:	1005003a 	cmpeq	r2,r2,zero
 322f7d4:	1000051e 	bne	r2,zero,322f7ec <sofree+0x114>
      (*so_evtmap_delete) (so);
 322f7d8:	0080c974 	movhi	r2,805
 322f7dc:	10927b04 	addi	r2,r2,18924
 322f7e0:	10800017 	ldw	r2,0(r2)
 322f7e4:	e13fff17 	ldw	r4,-4(fp)
 322f7e8:	103ee83a 	callr	r2
   
   SOC_FREE(so);
 322f7ec:	e13fff17 	ldw	r4,-4(fp)
 322f7f0:	322b6c40 	call	322b6c4 <npfree>
}
 322f7f4:	e037883a 	mov	sp,fp
 322f7f8:	dfc00117 	ldw	ra,4(sp)
 322f7fc:	df000017 	ldw	fp,0(sp)
 322f800:	dec00204 	addi	sp,sp,8
 322f804:	f800283a 	ret

0322f808 <soclose>:
 * RETURNS: 
 */

int
soclose(struct socket * so)
{
 322f808:	defff804 	addi	sp,sp,-32
 322f80c:	dfc00715 	stw	ra,28(sp)
 322f810:	df000615 	stw	fp,24(sp)
 322f814:	df000604 	addi	fp,sp,24
 322f818:	e13ffe15 	stw	r4,-8(fp)
   int   error =  0;
 322f81c:	e03ffd15 	stw	zero,-12(fp)
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 322f820:	0080c9b4 	movhi	r2,806
 322f824:	10b39704 	addi	r2,r2,-12708
 322f828:	10800017 	ldw	r2,0(r2)
 322f82c:	e0bffc15 	stw	r2,-16(fp)
 322f830:	00000606 	br	322f84c <soclose+0x44>
   {
      if (so == tmpso)
 322f834:	e0fffe17 	ldw	r3,-8(fp)
 322f838:	e0bffc17 	ldw	r2,-16(fp)
 322f83c:	18800626 	beq	r3,r2,322f858 <soclose+0x50>
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 322f840:	e0bffc17 	ldw	r2,-16(fp)
 322f844:	10800017 	ldw	r2,0(r2)
 322f848:	e0bffc15 	stw	r2,-16(fp)
 322f84c:	e0bffc17 	ldw	r2,-16(fp)
 322f850:	1004c03a 	cmpne	r2,r2,zero
 322f854:	103ff71e 	bne	r2,zero,322f834 <soclose+0x2c>
   {
      if (so == tmpso)
         break;
   }
   if ( tmpso == NULL)
 322f858:	e0bffc17 	ldw	r2,-16(fp)
 322f85c:	1004c03a 	cmpne	r2,r2,zero
 322f860:	1000031e 	bne	r2,zero,322f870 <soclose+0x68>
      return EINVAL;
 322f864:	00800584 	movi	r2,22
 322f868:	e0bfff15 	stw	r2,-4(fp)
 322f86c:	00009d06 	br	322fae4 <soclose+0x2dc>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
 322f870:	e0bffe17 	ldw	r2,-8(fp)
 322f874:	10800417 	ldw	r2,16(r2)
 322f878:	1080008c 	andi	r2,r2,2
 322f87c:	1005003a 	cmpeq	r2,r2,zero
 322f880:	1000101e 	bne	r2,zero,322f8c4 <soclose+0xbc>
   {
      while (so->so_q0 != so)
 322f884:	00000306 	br	322f894 <soclose+0x8c>
         (void) soabort(so->so_q0);
 322f888:	e0bffe17 	ldw	r2,-8(fp)
 322f88c:	11001c17 	ldw	r4,112(r2)
 322f890:	322fafc0 	call	322fafc <soabort>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
 322f894:	e0bffe17 	ldw	r2,-8(fp)
 322f898:	10c01c17 	ldw	r3,112(r2)
 322f89c:	e0bffe17 	ldw	r2,-8(fp)
 322f8a0:	18bff91e 	bne	r3,r2,322f888 <soclose+0x80>
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 322f8a4:	00000306 	br	322f8b4 <soclose+0xac>
         (void) soabort(so->so_q);
 322f8a8:	e0bffe17 	ldw	r2,-8(fp)
 322f8ac:	11001d17 	ldw	r4,116(r2)
 322f8b0:	322fafc0 	call	322fafc <soabort>
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 322f8b4:	e0bffe17 	ldw	r2,-8(fp)
 322f8b8:	10c01d17 	ldw	r3,116(r2)
 322f8bc:	e0bffe17 	ldw	r2,-8(fp)
 322f8c0:	18bff91e 	bne	r3,r2,322f8a8 <soclose+0xa0>
         (void) soabort(so->so_q);
   }
   /* for datagram-oriented sockets, dispense with further tests */
   if (so->so_type != SOCK_STREAM)
 322f8c4:	e0bffe17 	ldw	r2,-8(fp)
 322f8c8:	10800983 	ldbu	r2,38(r2)
 322f8cc:	10803fcc 	andi	r2,r2,255
 322f8d0:	1080201c 	xori	r2,r2,128
 322f8d4:	10bfe004 	addi	r2,r2,-128
 322f8d8:	10800060 	cmpeqi	r2,r2,1
 322f8dc:	10000c1e 	bne	r2,zero,322f910 <soclose+0x108>
   { 
      so->so_req = PRU_DETACH;
 322f8e0:	e0fffe17 	ldw	r3,-8(fp)
 322f8e4:	00800044 	movi	r2,1
 322f8e8:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so,
 322f8ec:	e0bffe17 	ldw	r2,-8(fp)
 322f8f0:	10800217 	ldw	r2,8(r2)
 322f8f4:	10800317 	ldw	r2,12(r2)
 322f8f8:	e13ffe17 	ldw	r4,-8(fp)
 322f8fc:	000b883a 	mov	r5,zero
 322f900:	000d883a 	mov	r6,zero
 322f904:	103ee83a 	callr	r2
 322f908:	e0bffd15 	stw	r2,-12(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
 322f90c:	00006306 	br	322fa9c <soclose+0x294>
   }

   if (so->so_pcb == 0)
 322f910:	e0bffe17 	ldw	r2,-8(fp)
 322f914:	10800117 	ldw	r2,4(r2)
 322f918:	1005003a 	cmpeq	r2,r2,zero
 322f91c:	10005f1e 	bne	r2,zero,322fa9c <soclose+0x294>
      goto discard;
   if (so->so_state & SS_ISCONNECTED) 
 322f920:	e0bffe17 	ldw	r2,-8(fp)
 322f924:	1080088b 	ldhu	r2,34(r2)
 322f928:	10bfffcc 	andi	r2,r2,65535
 322f92c:	1080008c 	andi	r2,r2,2
 322f930:	1005003a 	cmpeq	r2,r2,zero
 322f934:	1000451e 	bne	r2,zero,322fa4c <soclose+0x244>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
 322f938:	e0bffe17 	ldw	r2,-8(fp)
 322f93c:	1080088b 	ldhu	r2,34(r2)
 322f940:	10bfffcc 	andi	r2,r2,65535
 322f944:	1080020c 	andi	r2,r2,8
 322f948:	1004c03a 	cmpne	r2,r2,zero
 322f94c:	1000061e 	bne	r2,zero,322f968 <soclose+0x160>
      {
         error = sodisconnect(so);
 322f950:	e13ffe17 	ldw	r4,-8(fp)
 322f954:	322fcbc0 	call	322fcbc <sodisconnect>
 322f958:	e0bffd15 	stw	r2,-12(fp)
         if (error)
 322f95c:	e0bffd17 	ldw	r2,-12(fp)
 322f960:	1004c03a 	cmpne	r2,r2,zero
 322f964:	1000391e 	bne	r2,zero,322fa4c <soclose+0x244>
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
 322f968:	e0bffe17 	ldw	r2,-8(fp)
 322f96c:	10800417 	ldw	r2,16(r2)
 322f970:	1080200c 	andi	r2,r2,128
 322f974:	1005003a 	cmpeq	r2,r2,zero
 322f978:	1000281e 	bne	r2,zero,322fa1c <soclose+0x214>
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 322f97c:	e0bffe17 	ldw	r2,-8(fp)
 322f980:	1080088b 	ldhu	r2,34(r2)
 322f984:	10bfffcc 	andi	r2,r2,65535
 322f988:	1080020c 	andi	r2,r2,8
 322f98c:	1005003a 	cmpeq	r2,r2,zero
 322f990:	1000061e 	bne	r2,zero,322f9ac <soclose+0x1a4>
 322f994:	e0bffe17 	ldw	r2,-8(fp)
 322f998:	1080088b 	ldhu	r2,34(r2)
 322f99c:	10bfffcc 	andi	r2,r2,65535
 322f9a0:	1080400c 	andi	r2,r2,256
 322f9a4:	1004c03a 	cmpne	r2,r2,zero
 322f9a8:	1000281e 	bne	r2,zero,322fa4c <soclose+0x244>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
 322f9ac:	e0bffe17 	ldw	r2,-8(fp)
 322f9b0:	1080080b 	ldhu	r2,32(r2)
 322f9b4:	10bfffcc 	andi	r2,r2,65535
 322f9b8:	10a0001c 	xori	r2,r2,32768
 322f9bc:	10a00004 	addi	r2,r2,-32768
 322f9c0:	10c0fa24 	muli	r3,r2,1000
 322f9c4:	0080c974 	movhi	r2,805
 322f9c8:	10925604 	addi	r2,r2,18776
 322f9cc:	10800017 	ldw	r2,0(r2)
 322f9d0:	1885883a 	add	r2,r3,r2
 322f9d4:	e0bffb15 	stw	r2,-20(fp)
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 322f9d8:	00000406 	br	322f9ec <soclose+0x1e4>
         {
            tcp_sleep((char *)&so->so_timeo);
 322f9dc:	e0bffe17 	ldw	r2,-8(fp)
 322f9e0:	10800904 	addi	r2,r2,36
 322f9e4:	1009883a 	mov	r4,r2
 322f9e8:	32267600 	call	3226760 <tcp_sleep>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 322f9ec:	e0bffe17 	ldw	r2,-8(fp)
 322f9f0:	1080088b 	ldhu	r2,34(r2)
 322f9f4:	10bfffcc 	andi	r2,r2,65535
 322f9f8:	1080008c 	andi	r2,r2,2
 322f9fc:	1005003a 	cmpeq	r2,r2,zero
 322fa00:	1000121e 	bne	r2,zero,322fa4c <soclose+0x244>
 322fa04:	0080c974 	movhi	r2,805
 322fa08:	10925604 	addi	r2,r2,18776
 322fa0c:	10c00017 	ldw	r3,0(r2)
 322fa10:	e0bffb17 	ldw	r2,-20(fp)
 322fa14:	18bff136 	bltu	r3,r2,322f9dc <soclose+0x1d4>
 322fa18:	00000c06 	br	322fa4c <soclose+0x244>
      {
         /* If socket still has send data just return now, leaving the 
          * socket intact so the data can be sent. Socket should be cleaned
          * up later by timers.
          */
         if(so->so_snd.sb_cc)
 322fa1c:	e0bffe17 	ldw	r2,-8(fp)
 322fa20:	10801217 	ldw	r2,72(r2)
 322fa24:	1005003a 	cmpeq	r2,r2,zero
 322fa28:	1000081e 	bne	r2,zero,322fa4c <soclose+0x244>
         {
            so->so_state |= SS_NOFDREF;   /* mark as OK to close */
 322fa2c:	e0bffe17 	ldw	r2,-8(fp)
 322fa30:	1080088b 	ldhu	r2,34(r2)
 322fa34:	10800054 	ori	r2,r2,1
 322fa38:	1007883a 	mov	r3,r2
 322fa3c:	e0bffe17 	ldw	r2,-8(fp)
 322fa40:	10c0088d 	sth	r3,34(r2)
            return 0;
 322fa44:	e03fff15 	stw	zero,-4(fp)
 322fa48:	00002606 	br	322fae4 <soclose+0x2dc>
         }
      }
   }
drop:
   if (so->so_pcb) 
 322fa4c:	e0bffe17 	ldw	r2,-8(fp)
 322fa50:	10800117 	ldw	r2,4(r2)
 322fa54:	1005003a 	cmpeq	r2,r2,zero
 322fa58:	1000101e 	bne	r2,zero,322fa9c <soclose+0x294>
   {
      int   error2;
      so->so_req = PRU_DETACH;
 322fa5c:	e0fffe17 	ldw	r3,-8(fp)
 322fa60:	00800044 	movi	r2,1
 322fa64:	18800715 	stw	r2,28(r3)
      error2 = (*so->so_proto->pr_usrreq)(so,
 322fa68:	e0bffe17 	ldw	r2,-8(fp)
 322fa6c:	10800217 	ldw	r2,8(r2)
 322fa70:	10800317 	ldw	r2,12(r2)
 322fa74:	e13ffe17 	ldw	r4,-8(fp)
 322fa78:	000b883a 	mov	r5,zero
 322fa7c:	000d883a 	mov	r6,zero
 322fa80:	103ee83a 	callr	r2
 322fa84:	e0bffa15 	stw	r2,-24(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
 322fa88:	e0bffd17 	ldw	r2,-12(fp)
 322fa8c:	1004c03a 	cmpne	r2,r2,zero
 322fa90:	1000021e 	bne	r2,zero,322fa9c <soclose+0x294>
         error = error2;
 322fa94:	e0bffa17 	ldw	r2,-24(fp)
 322fa98:	e0bffd15 	stw	r2,-12(fp)
   }
discard:
   if (so->so_state & SS_NOFDREF)
 322fa9c:	e0bffe17 	ldw	r2,-8(fp)
 322faa0:	1080088b 	ldhu	r2,34(r2)
 322faa4:	10bfffcc 	andi	r2,r2,65535
 322faa8:	1080004c 	andi	r2,r2,1
 322faac:	10803fcc 	andi	r2,r2,255
 322fab0:	1005003a 	cmpeq	r2,r2,zero
 322fab4:	1000011e 	bne	r2,zero,322fabc <soclose+0x2b4>
   {
      /* panic("soclose");  - non-fatal - degrade to dtrap() for now */
      dtrap();
 322fab8:	322ab8c0 	call	322ab8c <dtrap>
   }
   so->so_state |= SS_NOFDREF;
 322fabc:	e0bffe17 	ldw	r2,-8(fp)
 322fac0:	1080088b 	ldhu	r2,34(r2)
 322fac4:	10800054 	ori	r2,r2,1
 322fac8:	1007883a 	mov	r3,r2
 322facc:	e0bffe17 	ldw	r2,-8(fp)
 322fad0:	10c0088d 	sth	r3,34(r2)
   sofree(so);
 322fad4:	e13ffe17 	ldw	r4,-8(fp)
 322fad8:	322f6d80 	call	322f6d8 <sofree>
   return (error);
 322fadc:	e0bffd17 	ldw	r2,-12(fp)
 322fae0:	e0bfff15 	stw	r2,-4(fp)
 322fae4:	e0bfff17 	ldw	r2,-4(fp)
}
 322fae8:	e037883a 	mov	sp,fp
 322faec:	dfc00117 	ldw	ra,4(sp)
 322faf0:	df000017 	ldw	fp,0(sp)
 322faf4:	dec00204 	addi	sp,sp,8
 322faf8:	f800283a 	ret

0322fafc <soabort>:
 * RETURNS: 
 */

int
soabort(struct socket * so)
{
 322fafc:	defffd04 	addi	sp,sp,-12
 322fb00:	dfc00215 	stw	ra,8(sp)
 322fb04:	df000115 	stw	fp,4(sp)
 322fb08:	df000104 	addi	fp,sp,4
 322fb0c:	e13fff15 	stw	r4,-4(fp)
   so->so_req = PRU_ABORT;
 322fb10:	e0ffff17 	ldw	r3,-4(fp)
 322fb14:	00800284 	movi	r2,10
 322fb18:	18800715 	stw	r2,28(r3)
   return(*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 322fb1c:	e0bfff17 	ldw	r2,-4(fp)
 322fb20:	10800217 	ldw	r2,8(r2)
 322fb24:	10800317 	ldw	r2,12(r2)
 322fb28:	e13fff17 	ldw	r4,-4(fp)
 322fb2c:	000b883a 	mov	r5,zero
 322fb30:	000d883a 	mov	r6,zero
 322fb34:	103ee83a 	callr	r2
}
 322fb38:	e037883a 	mov	sp,fp
 322fb3c:	dfc00117 	ldw	ra,4(sp)
 322fb40:	df000017 	ldw	fp,0(sp)
 322fb44:	dec00204 	addi	sp,sp,8
 322fb48:	f800283a 	ret

0322fb4c <soaccept>:
 */

int
soaccept(struct socket * so, 
   struct mbuf *  nam)
{
 322fb4c:	defffb04 	addi	sp,sp,-20
 322fb50:	dfc00415 	stw	ra,16(sp)
 322fb54:	df000315 	stw	fp,12(sp)
 322fb58:	df000304 	addi	fp,sp,12
 322fb5c:	e13ffe15 	stw	r4,-8(fp)
 322fb60:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if ((so->so_state & SS_NOFDREF) == 0)
 322fb64:	e0bffe17 	ldw	r2,-8(fp)
 322fb68:	1080088b 	ldhu	r2,34(r2)
 322fb6c:	10bfffcc 	andi	r2,r2,65535
 322fb70:	1080004c 	andi	r2,r2,1
 322fb74:	1004c03a 	cmpne	r2,r2,zero
 322fb78:	1000031e 	bne	r2,zero,322fb88 <soaccept+0x3c>
      panic("soaccept");
 322fb7c:	0100c974 	movhi	r4,805
 322fb80:	213d4804 	addi	r4,r4,-2784
 322fb84:	3225df00 	call	3225df0 <panic>
   so->so_state &= ~SS_NOFDREF;
 322fb88:	e0bffe17 	ldw	r2,-8(fp)
 322fb8c:	10c0088b 	ldhu	r3,34(r2)
 322fb90:	00bfff84 	movi	r2,-2
 322fb94:	1884703a 	and	r2,r3,r2
 322fb98:	1007883a 	mov	r3,r2
 322fb9c:	e0bffe17 	ldw	r2,-8(fp)
 322fba0:	10c0088d 	sth	r3,34(r2)
   so->so_req = PRU_ACCEPT;
 322fba4:	e0fffe17 	ldw	r3,-8(fp)
 322fba8:	00800144 	movi	r2,5
 322fbac:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 322fbb0:	e0bffe17 	ldw	r2,-8(fp)
 322fbb4:	10800217 	ldw	r2,8(r2)
 322fbb8:	10800317 	ldw	r2,12(r2)
 322fbbc:	e13ffe17 	ldw	r4,-8(fp)
 322fbc0:	000b883a 	mov	r5,zero
 322fbc4:	e1bfff17 	ldw	r6,-4(fp)
 322fbc8:	103ee83a 	callr	r2
 322fbcc:	e0bffd15 	stw	r2,-12(fp)

   return (error);
 322fbd0:	e0bffd17 	ldw	r2,-12(fp)
}
 322fbd4:	e037883a 	mov	sp,fp
 322fbd8:	dfc00117 	ldw	ra,4(sp)
 322fbdc:	df000017 	ldw	fp,0(sp)
 322fbe0:	dec00204 	addi	sp,sp,8
 322fbe4:	f800283a 	ret

0322fbe8 <soconnect>:
 */

int
soconnect(struct socket * so, 
   struct mbuf *  nam)
{
 322fbe8:	defffa04 	addi	sp,sp,-24
 322fbec:	dfc00515 	stw	ra,20(sp)
 322fbf0:	df000415 	stw	fp,16(sp)
 322fbf4:	df000404 	addi	fp,sp,16
 322fbf8:	e13ffd15 	stw	r4,-12(fp)
 322fbfc:	e17ffe15 	stw	r5,-8(fp)
   int   error;

   if (so->so_options & SO_ACCEPTCONN)
 322fc00:	e0bffd17 	ldw	r2,-12(fp)
 322fc04:	10800417 	ldw	r2,16(r2)
 322fc08:	1080008c 	andi	r2,r2,2
 322fc0c:	1005003a 	cmpeq	r2,r2,zero
 322fc10:	1000031e 	bne	r2,zero,322fc20 <soconnect+0x38>
      return (EOPNOTSUPP);
 322fc14:	008017c4 	movi	r2,95
 322fc18:	e0bfff15 	stw	r2,-4(fp)
 322fc1c:	00002106 	br	322fca4 <soconnect+0xbc>
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 322fc20:	e0bffd17 	ldw	r2,-12(fp)
 322fc24:	1080088b 	ldhu	r2,34(r2)
 322fc28:	10bfffcc 	andi	r2,r2,65535
 322fc2c:	1080018c 	andi	r2,r2,6
 322fc30:	1005003a 	cmpeq	r2,r2,zero
 322fc34:	10000e1e 	bne	r2,zero,322fc70 <soconnect+0x88>
 322fc38:	e0bffd17 	ldw	r2,-12(fp)
 322fc3c:	10800217 	ldw	r2,8(r2)
 322fc40:	1080010b 	ldhu	r2,4(r2)
 322fc44:	10bfffcc 	andi	r2,r2,65535
 322fc48:	1080010c 	andi	r2,r2,4
 322fc4c:	1004c03a 	cmpne	r2,r2,zero
 322fc50:	1000041e 	bne	r2,zero,322fc64 <soconnect+0x7c>
 322fc54:	e13ffd17 	ldw	r4,-12(fp)
 322fc58:	322fcbc0 	call	322fcbc <sodisconnect>
 322fc5c:	1005003a 	cmpeq	r2,r2,zero
 322fc60:	1000031e 	bne	r2,zero,322fc70 <soconnect+0x88>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
       (sodisconnect(so) != 0)))
   {
      error = EISCONN;
 322fc64:	00801fc4 	movi	r2,127
 322fc68:	e0bffc15 	stw	r2,-16(fp)
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 322fc6c:	00000b06 	br	322fc9c <soconnect+0xb4>
   {
      error = EISCONN;
   }
   else
   {
      so->so_req = PRU_CONNECT;
 322fc70:	e0fffd17 	ldw	r3,-12(fp)
 322fc74:	00800104 	movi	r2,4
 322fc78:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 322fc7c:	e0bffd17 	ldw	r2,-12(fp)
 322fc80:	10800217 	ldw	r2,8(r2)
 322fc84:	10800317 	ldw	r2,12(r2)
 322fc88:	e13ffd17 	ldw	r4,-12(fp)
 322fc8c:	000b883a 	mov	r5,zero
 322fc90:	e1bffe17 	ldw	r6,-8(fp)
 322fc94:	103ee83a 	callr	r2
 322fc98:	e0bffc15 	stw	r2,-16(fp)
   }
   return error;
 322fc9c:	e0bffc17 	ldw	r2,-16(fp)
 322fca0:	e0bfff15 	stw	r2,-4(fp)
 322fca4:	e0bfff17 	ldw	r2,-4(fp)
}
 322fca8:	e037883a 	mov	sp,fp
 322fcac:	dfc00117 	ldw	ra,4(sp)
 322fcb0:	df000017 	ldw	fp,0(sp)
 322fcb4:	dec00204 	addi	sp,sp,8
 322fcb8:	f800283a 	ret

0322fcbc <sodisconnect>:
 * RETURNS: 
 */

int
sodisconnect(struct socket * so)
{
 322fcbc:	defffc04 	addi	sp,sp,-16
 322fcc0:	dfc00315 	stw	ra,12(sp)
 322fcc4:	df000215 	stw	fp,8(sp)
 322fcc8:	df000204 	addi	fp,sp,8
 322fccc:	e13fff15 	stw	r4,-4(fp)
   int   error;

   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sodisconnect, so %lx so_state %x\n", so, so->so_state));

   if ((so->so_state & SS_ISCONNECTED) == 0) 
 322fcd0:	e0bfff17 	ldw	r2,-4(fp)
 322fcd4:	1080088b 	ldhu	r2,34(r2)
 322fcd8:	10bfffcc 	andi	r2,r2,65535
 322fcdc:	1080008c 	andi	r2,r2,2
 322fce0:	1004c03a 	cmpne	r2,r2,zero
 322fce4:	1000031e 	bne	r2,zero,322fcf4 <sodisconnect+0x38>
   {
      error = ENOTCONN;
 322fce8:	00802004 	movi	r2,128
 322fcec:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 322fcf0:	00001406 	br	322fd44 <sodisconnect+0x88>
   }
   if (so->so_state & SS_ISDISCONNECTING) 
 322fcf4:	e0bfff17 	ldw	r2,-4(fp)
 322fcf8:	1080088b 	ldhu	r2,34(r2)
 322fcfc:	10bfffcc 	andi	r2,r2,65535
 322fd00:	1080020c 	andi	r2,r2,8
 322fd04:	1005003a 	cmpeq	r2,r2,zero
 322fd08:	1000031e 	bne	r2,zero,322fd18 <sodisconnect+0x5c>
   {
      error = EALREADY;
 322fd0c:	00801e04 	movi	r2,120
 322fd10:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 322fd14:	00000b06 	br	322fd44 <sodisconnect+0x88>
   }
   so->so_req = PRU_DISCONNECT;
 322fd18:	e0ffff17 	ldw	r3,-4(fp)
 322fd1c:	00800184 	movi	r2,6
 322fd20:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 322fd24:	e0bfff17 	ldw	r2,-4(fp)
 322fd28:	10800217 	ldw	r2,8(r2)
 322fd2c:	10800317 	ldw	r2,12(r2)
 322fd30:	e13fff17 	ldw	r4,-4(fp)
 322fd34:	000b883a 	mov	r5,zero
 322fd38:	000d883a 	mov	r6,zero
 322fd3c:	103ee83a 	callr	r2
 322fd40:	e0bffe15 	stw	r2,-8(fp)

bad:
   return (error);
 322fd44:	e0bffe17 	ldw	r2,-8(fp)
}
 322fd48:	e037883a 	mov	sp,fp
 322fd4c:	dfc00117 	ldw	ra,4(sp)
 322fd50:	df000017 	ldw	fp,0(sp)
 322fd54:	dec00204 	addi	sp,sp,8
 322fd58:	f800283a 	ret

0322fd5c <sosend>:
sosend(struct socket *so, 
       struct mbuf *nam,      /* sockaddr, if UDP socket, NULL if TCP */
       char  *data,           /* data to send */
       int   *data_length,    /* IN/OUT  length of (remaining) data */
       int   flags)
{
 322fd5c:	deffee04 	addi	sp,sp,-72
 322fd60:	dfc01115 	stw	ra,68(sp)
 322fd64:	df001015 	stw	fp,64(sp)
 322fd68:	df001004 	addi	fp,sp,64
 322fd6c:	e13ff815 	stw	r4,-32(fp)
 322fd70:	e17ff915 	stw	r5,-28(fp)
 322fd74:	e1bffa15 	stw	r6,-24(fp)
 322fd78:	e1fffb15 	stw	r7,-20(fp)
   struct mbuf *head = (struct mbuf *)NULL;
 322fd7c:	e03ff715 	stw	zero,-36(fp)
   struct mbuf *m;
   int   space;
   int   resid;
   int   len;
   int   error = 0;
 322fd80:	e03ff215 	stw	zero,-56(fp)
   int   dontroute;
   int   first = 1;
 322fd84:	00800044 	movi	r2,1
 322fd88:	e0bff015 	stw	r2,-64(fp)

   resid = *data_length;
 322fd8c:	e0bffb17 	ldw	r2,-20(fp)
 322fd90:	10800017 	ldw	r2,0(r2)
 322fd94:	e0bff415 	stw	r2,-48(fp)
    * However, space must be signed, as it might be less than 0
    * if we over-committed, and we must use a signed comparison
    * of space and resid.  On the other hand, a negative resid
    * causes us to loop sending 0-length segments to the protocol.
    */
   if (resid < 0)
 322fd98:	e0bff417 	ldw	r2,-48(fp)
 322fd9c:	1004403a 	cmpge	r2,r2,zero
 322fda0:	1000031e 	bne	r2,zero,322fdb0 <sosend+0x54>
      return (EINVAL);
 322fda4:	00800584 	movi	r2,22
 322fda8:	e0bfff15 	stw	r2,-4(fp)
 322fdac:	00016706 	br	323034c <sosend+0x5f0>

   INET_TRACE (INETM_IO, ("INET:sosend: so %lx resid %d sb_hiwat %d so_state %x\n",
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
 322fdb0:	e0bff817 	ldw	r2,-32(fp)
 322fdb4:	10800217 	ldw	r2,8(r2)
 322fdb8:	1080010b 	ldhu	r2,4(r2)
 322fdbc:	10bfffcc 	andi	r2,r2,65535
 322fdc0:	1080004c 	andi	r2,r2,1
 322fdc4:	10803fcc 	andi	r2,r2,255
 322fdc8:	1005003a 	cmpeq	r2,r2,zero
 322fdcc:	1000081e 	bne	r2,zero,322fdf0 <sosend+0x94>
 322fdd0:	e0bff817 	ldw	r2,-32(fp)
 322fdd4:	10801317 	ldw	r2,76(r2)
 322fdd8:	1007883a 	mov	r3,r2
 322fddc:	e0bff417 	ldw	r2,-48(fp)
 322fde0:	1880030e 	bge	r3,r2,322fdf0 <sosend+0x94>
      return (EMSGSIZE);
 322fde4:	00c01e84 	movi	r3,122
 322fde8:	e0ffff15 	stw	r3,-4(fp)
 322fdec:	00015706 	br	323034c <sosend+0x5f0>

   dontroute = (flags & MSG_DONTROUTE) &&
 322fdf0:	e0800217 	ldw	r2,8(fp)
 322fdf4:	1080010c 	andi	r2,r2,4
 322fdf8:	1005003a 	cmpeq	r2,r2,zero
 322fdfc:	1000111e 	bne	r2,zero,322fe44 <sosend+0xe8>
 322fe00:	e0bff817 	ldw	r2,-32(fp)
 322fe04:	10800417 	ldw	r2,16(r2)
 322fe08:	1080040c 	andi	r2,r2,16
 322fe0c:	1004c03a 	cmpne	r2,r2,zero
 322fe10:	10000c1e 	bne	r2,zero,322fe44 <sosend+0xe8>
 322fe14:	e0bff817 	ldw	r2,-32(fp)
 322fe18:	10800217 	ldw	r2,8(r2)
 322fe1c:	1080010b 	ldhu	r2,4(r2)
 322fe20:	10bfffcc 	andi	r2,r2,65535
 322fe24:	1080004c 	andi	r2,r2,1
 322fe28:	1080005c 	xori	r2,r2,1
 322fe2c:	10803fcc 	andi	r2,r2,255
 322fe30:	1004c03a 	cmpne	r2,r2,zero
 322fe34:	1000031e 	bne	r2,zero,322fe44 <sosend+0xe8>
 322fe38:	00800044 	movi	r2,1
 322fe3c:	e0bffe15 	stw	r2,-8(fp)
 322fe40:	00000106 	br	322fe48 <sosend+0xec>
 322fe44:	e03ffe15 	stw	zero,-8(fp)
 322fe48:	e0fffe17 	ldw	r3,-8(fp)
 322fe4c:	e0fff115 	stw	r3,-60(fp)
               (so->so_proto->pr_flags & PR_ATOMIC);

#define     snderr(errno)     {  error =  errno;   goto  release; }

restart:
   sblock(&so->so_snd);
 322fe50:	00000406 	br	322fe64 <sosend+0x108>
 322fe54:	e0bff817 	ldw	r2,-32(fp)
 322fe58:	10801904 	addi	r2,r2,100
 322fe5c:	1009883a 	mov	r4,r2
 322fe60:	32267600 	call	3226760 <tcp_sleep>
 322fe64:	e0bff817 	ldw	r2,-32(fp)
 322fe68:	1080190b 	ldhu	r2,100(r2)
 322fe6c:	10bfffcc 	andi	r2,r2,65535
 322fe70:	1080004c 	andi	r2,r2,1
 322fe74:	10803fcc 	andi	r2,r2,255
 322fe78:	1004c03a 	cmpne	r2,r2,zero
 322fe7c:	103ff51e 	bne	r2,zero,322fe54 <sosend+0xf8>
 322fe80:	e0bff817 	ldw	r2,-32(fp)
 322fe84:	1080190b 	ldhu	r2,100(r2)
 322fe88:	10800054 	ori	r2,r2,1
 322fe8c:	1007883a 	mov	r3,r2
 322fe90:	e0bff817 	ldw	r2,-32(fp)
 322fe94:	10c0190d 	sth	r3,100(r2)
   do 
   {
      if (so->so_error) 
 322fe98:	e0bff817 	ldw	r2,-32(fp)
 322fe9c:	10800617 	ldw	r2,24(r2)
 322fea0:	1005003a 	cmpeq	r2,r2,zero
 322fea4:	1000061e 	bne	r2,zero,322fec0 <sosend+0x164>
      {
         error = so->so_error;
 322fea8:	e0bff817 	ldw	r2,-32(fp)
 322feac:	10800617 	ldw	r2,24(r2)
 322feb0:	e0bff215 	stw	r2,-56(fp)
         so->so_error = 0;          /* ??? */
 322feb4:	e0bff817 	ldw	r2,-32(fp)
 322feb8:	10000615 	stw	zero,24(r2)
         goto release;
 322febc:	00011106 	br	3230304 <sosend+0x5a8>
      }
      if (so->so_state & SS_CANTSENDMORE)
 322fec0:	e0bff817 	ldw	r2,-32(fp)
 322fec4:	1080088b 	ldhu	r2,34(r2)
 322fec8:	10bfffcc 	andi	r2,r2,65535
 322fecc:	1080040c 	andi	r2,r2,16
 322fed0:	1005003a 	cmpeq	r2,r2,zero
 322fed4:	1000031e 	bne	r2,zero,322fee4 <sosend+0x188>
         snderr(EPIPE);
 322fed8:	00800804 	movi	r2,32
 322fedc:	e0bff215 	stw	r2,-56(fp)
 322fee0:	00010806 	br	3230304 <sosend+0x5a8>
      if ((so->so_state & SS_ISCONNECTED) == 0) 
 322fee4:	e0bff817 	ldw	r2,-32(fp)
 322fee8:	1080088b 	ldhu	r2,34(r2)
 322feec:	10bfffcc 	andi	r2,r2,65535
 322fef0:	1080008c 	andi	r2,r2,2
 322fef4:	1004c03a 	cmpne	r2,r2,zero
 322fef8:	1000101e 	bne	r2,zero,322ff3c <sosend+0x1e0>
      {
         if (so->so_proto->pr_flags & PR_CONNREQUIRED)
 322fefc:	e0bff817 	ldw	r2,-32(fp)
 322ff00:	10800217 	ldw	r2,8(r2)
 322ff04:	1080010b 	ldhu	r2,4(r2)
 322ff08:	10bfffcc 	andi	r2,r2,65535
 322ff0c:	1080010c 	andi	r2,r2,4
 322ff10:	1005003a 	cmpeq	r2,r2,zero
 322ff14:	1000031e 	bne	r2,zero,322ff24 <sosend+0x1c8>
            snderr(ENOTCONN);
 322ff18:	00802004 	movi	r2,128
 322ff1c:	e0bff215 	stw	r2,-56(fp)
 322ff20:	0000f806 	br	3230304 <sosend+0x5a8>
         if (nam == 0)
 322ff24:	e0bff917 	ldw	r2,-28(fp)
 322ff28:	1004c03a 	cmpne	r2,r2,zero
 322ff2c:	1000031e 	bne	r2,zero,322ff3c <sosend+0x1e0>
            snderr(EDESTADDRREQ);
 322ff30:	00801e44 	movi	r2,121
 322ff34:	e0bff215 	stw	r2,-56(fp)
 322ff38:	0000f206 	br	3230304 <sosend+0x5a8>
      }
      if (flags & MSG_OOB)
 322ff3c:	e0800217 	ldw	r2,8(fp)
 322ff40:	1080004c 	andi	r2,r2,1
 322ff44:	10803fcc 	andi	r2,r2,255
 322ff48:	1005003a 	cmpeq	r2,r2,zero
 322ff4c:	1000031e 	bne	r2,zero,322ff5c <sosend+0x200>
         space = 1024;
 322ff50:	00810004 	movi	r2,1024
 322ff54:	e0bff515 	stw	r2,-44(fp)
 322ff58:	00005106 	br	32300a0 <sosend+0x344>
      else 
      {
         space = (int)sbspace(&so->so_snd);
 322ff5c:	e0bff817 	ldw	r2,-32(fp)
 322ff60:	10801317 	ldw	r2,76(r2)
 322ff64:	1007883a 	mov	r3,r2
 322ff68:	e0bff817 	ldw	r2,-32(fp)
 322ff6c:	10801217 	ldw	r2,72(r2)
 322ff70:	1885c83a 	sub	r2,r3,r2
 322ff74:	1004803a 	cmplt	r2,r2,zero
 322ff78:	1000071e 	bne	r2,zero,322ff98 <sosend+0x23c>
 322ff7c:	e0bff817 	ldw	r2,-32(fp)
 322ff80:	10c01317 	ldw	r3,76(r2)
 322ff84:	e0bff817 	ldw	r2,-32(fp)
 322ff88:	10801217 	ldw	r2,72(r2)
 322ff8c:	1885c83a 	sub	r2,r3,r2
 322ff90:	e0bffd15 	stw	r2,-12(fp)
 322ff94:	00000106 	br	322ff9c <sosend+0x240>
 322ff98:	e03ffd15 	stw	zero,-12(fp)
 322ff9c:	e0bffd17 	ldw	r2,-12(fp)
 322ffa0:	e0bff515 	stw	r2,-44(fp)
         if ((sosendallatonce(so) && (space < resid)) ||
 322ffa4:	e0bff817 	ldw	r2,-32(fp)
 322ffa8:	10800217 	ldw	r2,8(r2)
 322ffac:	1080010b 	ldhu	r2,4(r2)
 322ffb0:	10bfffcc 	andi	r2,r2,65535
 322ffb4:	1080004c 	andi	r2,r2,1
 322ffb8:	1080005c 	xori	r2,r2,1
 322ffbc:	10803fcc 	andi	r2,r2,255
 322ffc0:	1004c03a 	cmpne	r2,r2,zero
 322ffc4:	1000031e 	bne	r2,zero,322ffd4 <sosend+0x278>
 322ffc8:	e0fff517 	ldw	r3,-44(fp)
 322ffcc:	e0bff417 	ldw	r2,-48(fp)
 322ffd0:	18801416 	blt	r3,r2,3230024 <sosend+0x2c8>
 322ffd4:	e0bff417 	ldw	r2,-48(fp)
 322ffd8:	10815e10 	cmplti	r2,r2,1400
 322ffdc:	1000301e 	bne	r2,zero,32300a0 <sosend+0x344>
 322ffe0:	e0bff517 	ldw	r2,-44(fp)
 322ffe4:	10815e08 	cmpgei	r2,r2,1400
 322ffe8:	10002d1e 	bne	r2,zero,32300a0 <sosend+0x344>
 322ffec:	e0bff817 	ldw	r2,-32(fp)
 322fff0:	10801217 	ldw	r2,72(r2)
 322fff4:	10815e30 	cmpltui	r2,r2,1400
 322fff8:	1000291e 	bne	r2,zero,32300a0 <sosend+0x344>
 322fffc:	e0bff817 	ldw	r2,-32(fp)
 3230000:	1080088b 	ldhu	r2,34(r2)
 3230004:	10bfffcc 	andi	r2,r2,65535
 3230008:	1080400c 	andi	r2,r2,256
 323000c:	1004c03a 	cmpne	r2,r2,zero
 3230010:	1000231e 	bne	r2,zero,32300a0 <sosend+0x344>
 3230014:	e0800217 	ldw	r2,8(fp)
 3230018:	1080080c 	andi	r2,r2,32
 323001c:	1004c03a 	cmpne	r2,r2,zero
 3230020:	10001f1e 	bne	r2,zero,32300a0 <sosend+0x344>
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
              ((flags & MSG_DONTWAIT) == 0)))
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 3230024:	e0bff817 	ldw	r2,-32(fp)
 3230028:	1080088b 	ldhu	r2,34(r2)
 323002c:	10bfffcc 	andi	r2,r2,65535
 3230030:	1080400c 	andi	r2,r2,256
 3230034:	1004c03a 	cmpne	r2,r2,zero
 3230038:	1000041e 	bne	r2,zero,323004c <sosend+0x2f0>
 323003c:	e0800217 	ldw	r2,8(fp)
 3230040:	1080080c 	andi	r2,r2,32
 3230044:	1005003a 	cmpeq	r2,r2,zero
 3230048:	1000061e 	bne	r2,zero,3230064 <sosend+0x308>
            {
               if (first)
 323004c:	e0bff017 	ldw	r2,-64(fp)
 3230050:	1005003a 	cmpeq	r2,r2,zero
 3230054:	1000ab1e 	bne	r2,zero,3230304 <sosend+0x5a8>
                  error = EWOULDBLOCK;
 3230058:	008002c4 	movi	r2,11
 323005c:	e0bff215 	stw	r2,-56(fp)
               goto release;
 3230060:	0000a806 	br	3230304 <sosend+0x5a8>
            }
            sbunlock(&so->so_snd);
 3230064:	e0bff817 	ldw	r2,-32(fp)
 3230068:	10c0190b 	ldhu	r3,100(r2)
 323006c:	00bfff84 	movi	r2,-2
 3230070:	1884703a 	and	r2,r3,r2
 3230074:	1007883a 	mov	r3,r2
 3230078:	e0bff817 	ldw	r2,-32(fp)
 323007c:	10c0190d 	sth	r3,100(r2)
 3230080:	e0bff817 	ldw	r2,-32(fp)
 3230084:	10801904 	addi	r2,r2,100
 3230088:	1009883a 	mov	r4,r2
 323008c:	32269000 	call	3226900 <tcp_wakeup>
            sbwait(&so->so_snd);
 3230090:	e0bff817 	ldw	r2,-32(fp)
 3230094:	11001204 	addi	r4,r2,72
 3230098:	3231ea40 	call	3231ea4 <sbwait>
            goto restart;
 323009c:	003f7106 	br	322fe64 <sosend+0x108>
         }
      }
      if ( space <= 0 ) 
 32300a0:	e0bff517 	ldw	r2,-44(fp)
 32300a4:	10800048 	cmpgei	r2,r2,1
 32300a8:	1000651e 	bne	r2,zero,3230240 <sosend+0x4e4>
      {
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 32300ac:	e0bff817 	ldw	r2,-32(fp)
 32300b0:	1080088b 	ldhu	r2,34(r2)
 32300b4:	10bfffcc 	andi	r2,r2,65535
 32300b8:	1080400c 	andi	r2,r2,256
 32300bc:	1004c03a 	cmpne	r2,r2,zero
 32300c0:	1000041e 	bne	r2,zero,32300d4 <sosend+0x378>
 32300c4:	e0800217 	ldw	r2,8(fp)
 32300c8:	1080080c 	andi	r2,r2,32
 32300cc:	1005003a 	cmpeq	r2,r2,zero
 32300d0:	1000061e 	bne	r2,zero,32300ec <sosend+0x390>
         {
            if (first)     /* report first error */
 32300d4:	e0bff017 	ldw	r2,-64(fp)
 32300d8:	1005003a 	cmpeq	r2,r2,zero
 32300dc:	1000891e 	bne	r2,zero,3230304 <sosend+0x5a8>
               error = EWOULDBLOCK;
 32300e0:	008002c4 	movi	r2,11
 32300e4:	e0bff215 	stw	r2,-56(fp)
            goto release;
 32300e8:	00008606 	br	3230304 <sosend+0x5a8>
         }
         /* If blocking socket, let someone else run */
         sbunlock(&so->so_snd);
 32300ec:	e0bff817 	ldw	r2,-32(fp)
 32300f0:	10c0190b 	ldhu	r3,100(r2)
 32300f4:	00bfff84 	movi	r2,-2
 32300f8:	1884703a 	and	r2,r3,r2
 32300fc:	1007883a 	mov	r3,r2
 3230100:	e0bff817 	ldw	r2,-32(fp)
 3230104:	10c0190d 	sth	r3,100(r2)
 3230108:	e0bff817 	ldw	r2,-32(fp)
 323010c:	10801904 	addi	r2,r2,100
 3230110:	1009883a 	mov	r4,r2
 3230114:	32269000 	call	3226900 <tcp_wakeup>
         sbwait(&so->so_snd);
 3230118:	e0bff817 	ldw	r2,-32(fp)
 323011c:	11001204 	addi	r4,r2,72
 3230120:	3231ea40 	call	3231ea4 <sbwait>
         goto restart;
 3230124:	003f4f06 	br	322fe64 <sosend+0x108>
      }

      while (space > 0) 
      {
         len = resid;
 3230128:	e0bff417 	ldw	r2,-48(fp)
 323012c:	e0bff315 	stw	r2,-52(fp)
         if ( so->so_type == SOCK_STREAM )
 3230130:	e0bff817 	ldw	r2,-32(fp)
 3230134:	10800983 	ldbu	r2,38(r2)
 3230138:	10803fcc 	andi	r2,r2,255
 323013c:	1080201c 	xori	r2,r2,128
 3230140:	10bfe004 	addi	r2,r2,-128
 3230144:	10800058 	cmpnei	r2,r2,1
 3230148:	1000181e 	bne	r2,zero,32301ac <sosend+0x450>
         {
            m = m_getwithdata(MT_TXDATA, len);
 323014c:	01000084 	movi	r4,2
 3230150:	e17ff317 	ldw	r5,-52(fp)
 3230154:	322b98c0 	call	322b98c <m_getnbuf>
 3230158:	e0bff615 	stw	r2,-40(fp)
            if (!m)   
 323015c:	e0bff617 	ldw	r2,-40(fp)
 3230160:	1004c03a 	cmpne	r2,r2,zero
 3230164:	1000031e 	bne	r2,zero,3230174 <sosend+0x418>
               snderr(ENOBUFS);
 3230168:	00801a44 	movi	r2,105
 323016c:	e0bff215 	stw	r2,-56(fp)
 3230170:	00006406 	br	3230304 <sosend+0x5a8>
            MEMCPY(m->m_data, data, len);
 3230174:	e0bff617 	ldw	r2,-40(fp)
 3230178:	10c00317 	ldw	r3,12(r2)
 323017c:	e1bff317 	ldw	r6,-52(fp)
 3230180:	e0bffa17 	ldw	r2,-24(fp)
 3230184:	1809883a 	mov	r4,r3
 3230188:	100b883a 	mov	r5,r2
 323018c:	32067cc0 	call	32067cc <memcpy>
            so->so_snd.sb_flags |= SB_MBCOMP;   /* allow compression */
 3230190:	e0bff817 	ldw	r2,-32(fp)
 3230194:	1080190b 	ldhu	r2,100(r2)
 3230198:	10802014 	ori	r2,r2,128
 323019c:	1007883a 	mov	r3,r2
 32301a0:	e0bff817 	ldw	r2,-32(fp)
 32301a4:	10c0190d 	sth	r3,100(r2)
 32301a8:	00000706 	br	32301c8 <sosend+0x46c>
         }
         else
         {
            m = m_get (M_WAIT, MT_TXDATA);
 32301ac:	01000084 	movi	r4,2
 32301b0:	000b883a 	mov	r5,zero
 32301b4:	322b98c0 	call	322b98c <m_getnbuf>
 32301b8:	e0bff615 	stw	r2,-40(fp)
            m->m_data = data;
 32301bc:	e0fff617 	ldw	r3,-40(fp)
 32301c0:	e0bffa17 	ldw	r2,-24(fp)
 32301c4:	18800315 	stw	r2,12(r3)
         }
         INET_TRACE (INETM_IO,
          ("sosend:got %d bytes so %lx mlen %d, off %d mtod %x\n",
             len, so, m->m_len, m->m_off, mtod (m, caddr_t)));

         *data_length -= len;
 32301c8:	e0bffb17 	ldw	r2,-20(fp)
 32301cc:	10c00017 	ldw	r3,0(r2)
 32301d0:	e0bff317 	ldw	r2,-52(fp)
 32301d4:	1887c83a 	sub	r3,r3,r2
 32301d8:	e0bffb17 	ldw	r2,-20(fp)
 32301dc:	10c00015 	stw	r3,0(r2)
         resid -= len;
 32301e0:	e0fff417 	ldw	r3,-48(fp)
 32301e4:	e0bff317 	ldw	r2,-52(fp)
 32301e8:	1885c83a 	sub	r2,r3,r2
 32301ec:	e0bff415 	stw	r2,-48(fp)
         data += len;
 32301f0:	e0bff317 	ldw	r2,-52(fp)
 32301f4:	1007883a 	mov	r3,r2
 32301f8:	e0bffa17 	ldw	r2,-24(fp)
 32301fc:	10c5883a 	add	r2,r2,r3
 3230200:	e0bffa15 	stw	r2,-24(fp)
         m->m_len = len;
 3230204:	e0fff317 	ldw	r3,-52(fp)
 3230208:	e0bff617 	ldw	r2,-40(fp)
 323020c:	10c00215 	stw	r3,8(r2)
         if (head == (struct mbuf *)NULL)
 3230210:	e0bff717 	ldw	r2,-36(fp)
 3230214:	1004c03a 	cmpne	r2,r2,zero
 3230218:	1000021e 	bne	r2,zero,3230224 <sosend+0x4c8>
            head = m;
 323021c:	e0bff617 	ldw	r2,-40(fp)
 3230220:	e0bff715 	stw	r2,-36(fp)
         if (error)
 3230224:	e0bff217 	ldw	r2,-56(fp)
 3230228:	1004c03a 	cmpne	r2,r2,zero
 323022c:	1000351e 	bne	r2,zero,3230304 <sosend+0x5a8>
            goto release;
         if (*data_length <= 0)
 3230230:	e0bffb17 	ldw	r2,-20(fp)
 3230234:	10800017 	ldw	r2,0(r2)
 3230238:	10800050 	cmplti	r2,r2,1
 323023c:	1000031e 	bne	r2,zero,323024c <sosend+0x4f0>
         sbunlock(&so->so_snd);
         sbwait(&so->so_snd);
         goto restart;
      }

      while (space > 0) 
 3230240:	e0bff517 	ldw	r2,-44(fp)
 3230244:	10800048 	cmpgei	r2,r2,1
 3230248:	103fb71e 	bne	r2,zero,3230128 <sosend+0x3cc>
            goto release;
         if (*data_length <= 0)
            break;
      }

      if (dontroute)
 323024c:	e0bff117 	ldw	r2,-60(fp)
 3230250:	1005003a 	cmpeq	r2,r2,zero
 3230254:	1000051e 	bne	r2,zero,323026c <sosend+0x510>
         so->so_options |= SO_DONTROUTE;
 3230258:	e0bff817 	ldw	r2,-32(fp)
 323025c:	10800417 	ldw	r2,16(r2)
 3230260:	10c00414 	ori	r3,r2,16
 3230264:	e0bff817 	ldw	r2,-32(fp)
 3230268:	10c00415 	stw	r3,16(r2)

      so->so_req = (flags & MSG_OOB) ? PRU_SENDOOB : PRU_SEND;
 323026c:	e0800217 	ldw	r2,8(fp)
 3230270:	1080004c 	andi	r2,r2,1
 3230274:	10803fcc 	andi	r2,r2,255
 3230278:	1005003a 	cmpeq	r2,r2,zero
 323027c:	1000031e 	bne	r2,zero,323028c <sosend+0x530>
 3230280:	00c00384 	movi	r3,14
 3230284:	e0fffc15 	stw	r3,-16(fp)
 3230288:	00000206 	br	3230294 <sosend+0x538>
 323028c:	00800244 	movi	r2,9
 3230290:	e0bffc15 	stw	r2,-16(fp)
 3230294:	e0bff817 	ldw	r2,-32(fp)
 3230298:	e0fffc17 	ldw	r3,-16(fp)
 323029c:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so, head, nam);
 32302a0:	e0bff817 	ldw	r2,-32(fp)
 32302a4:	10800217 	ldw	r2,8(r2)
 32302a8:	10800317 	ldw	r2,12(r2)
 32302ac:	e13ff817 	ldw	r4,-32(fp)
 32302b0:	e17ff717 	ldw	r5,-36(fp)
 32302b4:	e1bff917 	ldw	r6,-28(fp)
 32302b8:	103ee83a 	callr	r2
 32302bc:	e0bff215 	stw	r2,-56(fp)

      if (dontroute)
 32302c0:	e0bff117 	ldw	r2,-60(fp)
 32302c4:	1005003a 	cmpeq	r2,r2,zero
 32302c8:	1000061e 	bne	r2,zero,32302e4 <sosend+0x588>
         so->so_options &= ~SO_DONTROUTE;
 32302cc:	e0bff817 	ldw	r2,-32(fp)
 32302d0:	10c00417 	ldw	r3,16(r2)
 32302d4:	00bffbc4 	movi	r2,-17
 32302d8:	1886703a 	and	r3,r3,r2
 32302dc:	e0bff817 	ldw	r2,-32(fp)
 32302e0:	10c00415 	stw	r3,16(r2)

      head = (struct mbuf *)NULL;
 32302e4:	e03ff715 	stw	zero,-36(fp)
      first = 0;
 32302e8:	e03ff015 	stw	zero,-64(fp)
   } while ((resid != 0) && (error == 0));
 32302ec:	e0bff417 	ldw	r2,-48(fp)
 32302f0:	1005003a 	cmpeq	r2,r2,zero
 32302f4:	1000031e 	bne	r2,zero,3230304 <sosend+0x5a8>
 32302f8:	e0bff217 	ldw	r2,-56(fp)
 32302fc:	1005003a 	cmpeq	r2,r2,zero
 3230300:	103ee51e 	bne	r2,zero,322fe98 <sosend+0x13c>

release:
   sbunlock(&so->so_snd);  
 3230304:	e0bff817 	ldw	r2,-32(fp)
 3230308:	10c0190b 	ldhu	r3,100(r2)
 323030c:	00bfff84 	movi	r2,-2
 3230310:	1884703a 	and	r2,r3,r2
 3230314:	1007883a 	mov	r3,r2
 3230318:	e0bff817 	ldw	r2,-32(fp)
 323031c:	10c0190d 	sth	r3,100(r2)
 3230320:	e0bff817 	ldw	r2,-32(fp)
 3230324:	10801904 	addi	r2,r2,100
 3230328:	1009883a 	mov	r4,r2
 323032c:	32269000 	call	3226900 <tcp_wakeup>
   if (head)
 3230330:	e0bff717 	ldw	r2,-36(fp)
 3230334:	1005003a 	cmpeq	r2,r2,zero
 3230338:	1000021e 	bne	r2,zero,3230344 <sosend+0x5e8>
      m_freem(head);
 323033c:	e13ff717 	ldw	r4,-36(fp)
 3230340:	322bc680 	call	322bc68 <m_freem>
   return error;
 3230344:	e0bff217 	ldw	r2,-56(fp)
 3230348:	e0bfff15 	stw	r2,-4(fp)
 323034c:	e0bfff17 	ldw	r2,-4(fp)
}
 3230350:	e037883a 	mov	sp,fp
 3230354:	dfc00117 	ldw	ra,4(sp)
 3230358:	df000017 	ldw	fp,0(sp)
 323035c:	dec00204 	addi	sp,sp,8
 3230360:	f800283a 	ret

03230364 <soreceive>:
soreceive(struct socket * so, 
   struct mbuf **aname,
   char * data,
   int * datalen,
   int   flags)
{
 3230364:	defff104 	addi	sp,sp,-60
 3230368:	dfc00e15 	stw	ra,56(sp)
 323036c:	df000d15 	stw	fp,52(sp)
 3230370:	df000d04 	addi	fp,sp,52
 3230374:	e13ffb15 	stw	r4,-20(fp)
 3230378:	e17ffc15 	stw	r5,-16(fp)
 323037c:	e1bffd15 	stw	r6,-12(fp)
 3230380:	e1fffe15 	stw	r7,-8(fp)
   struct mbuf *  m;
   int   len;
   int   error =  0;
 3230384:	e03ff815 	stw	zero,-32(fp)
   int   offset;
   struct protosw *  pr =  so->so_proto;
 3230388:	e0bffb17 	ldw	r2,-20(fp)
 323038c:	10800217 	ldw	r2,8(r2)
 3230390:	e0bff615 	stw	r2,-40(fp)
   struct mbuf *  nextrecord;
   int   moff;
   int   lflags;

   if (aname)
 3230394:	e0bffc17 	ldw	r2,-16(fp)
 3230398:	1005003a 	cmpeq	r2,r2,zero
 323039c:	1000021e 	bne	r2,zero,32303a8 <soreceive+0x44>
      *aname = 0;
 32303a0:	e0bffc17 	ldw	r2,-16(fp)
 32303a4:	10000015 	stw	zero,0(r2)
   if (flags & MSG_OOB) 
 32303a8:	e0800217 	ldw	r2,8(fp)
 32303ac:	1080004c 	andi	r2,r2,1
 32303b0:	10803fcc 	andi	r2,r2,255
 32303b4:	1005003a 	cmpeq	r2,r2,zero
 32303b8:	10004d1e 	bne	r2,zero,32304f0 <soreceive+0x18c>
   {
      m = m_get (M_WAIT, MT_RXDATA);
 32303bc:	01000044 	movi	r4,1
 32303c0:	000b883a 	mov	r5,zero
 32303c4:	322b98c0 	call	322b98c <m_getnbuf>
 32303c8:	e0bffa15 	stw	r2,-24(fp)
      if (m == NULL)
 32303cc:	e0bffa17 	ldw	r2,-24(fp)
 32303d0:	1004c03a 	cmpne	r2,r2,zero
 32303d4:	1000031e 	bne	r2,zero,32303e4 <soreceive+0x80>
         return ENOBUFS;
 32303d8:	00801a44 	movi	r2,105
 32303dc:	e0bfff15 	stw	r2,-4(fp)
 32303e0:	0001d306 	br	3230b30 <soreceive+0x7cc>
      lflags = flags & MSG_PEEK;
 32303e4:	e0800217 	ldw	r2,8(fp)
 32303e8:	1080008c 	andi	r2,r2,2
 32303ec:	e0bff315 	stw	r2,-52(fp)

      so->so_req = PRU_RCVOOB;
 32303f0:	e0fffb17 	ldw	r3,-20(fp)
 32303f4:	00800344 	movi	r2,13
 32303f8:	18800715 	stw	r2,28(r3)
      error = (*pr->pr_usrreq)(so, m, LONG2MBUF((long)lflags));
 32303fc:	e0bff617 	ldw	r2,-40(fp)
 3230400:	10800317 	ldw	r2,12(r2)
 3230404:	e1bff317 	ldw	r6,-52(fp)
 3230408:	e13ffb17 	ldw	r4,-20(fp)
 323040c:	e17ffa17 	ldw	r5,-24(fp)
 3230410:	103ee83a 	callr	r2
 3230414:	e0bff815 	stw	r2,-32(fp)
      if (error == 0)
 3230418:	e0bff817 	ldw	r2,-32(fp)
 323041c:	1004c03a 	cmpne	r2,r2,zero
 3230420:	1000271e 	bne	r2,zero,32304c0 <soreceive+0x15c>
      {
         do 
         {
            len = *datalen;
 3230424:	e0bffe17 	ldw	r2,-8(fp)
 3230428:	10800017 	ldw	r2,0(r2)
 323042c:	e0bff915 	stw	r2,-28(fp)
            if (len > (int)m->m_len)
 3230430:	e0bffa17 	ldw	r2,-24(fp)
 3230434:	10800217 	ldw	r2,8(r2)
 3230438:	1007883a 	mov	r3,r2
 323043c:	e0bff917 	ldw	r2,-28(fp)
 3230440:	1880030e 	bge	r3,r2,3230450 <soreceive+0xec>
               len = m->m_len;
 3230444:	e0bffa17 	ldw	r2,-24(fp)
 3230448:	10800217 	ldw	r2,8(r2)
 323044c:	e0bff915 	stw	r2,-28(fp)

            MEMCPY(data, mtod(m, char*), len);
 3230450:	e0bffa17 	ldw	r2,-24(fp)
 3230454:	10c00317 	ldw	r3,12(r2)
 3230458:	e1bff917 	ldw	r6,-28(fp)
 323045c:	e0bffd17 	ldw	r2,-12(fp)
 3230460:	1009883a 	mov	r4,r2
 3230464:	180b883a 	mov	r5,r3
 3230468:	32067cc0 	call	32067cc <memcpy>
            data += len;
 323046c:	e0bff917 	ldw	r2,-28(fp)
 3230470:	1007883a 	mov	r3,r2
 3230474:	e0bffd17 	ldw	r2,-12(fp)
 3230478:	10c5883a 	add	r2,r2,r3
 323047c:	e0bffd15 	stw	r2,-12(fp)
            *datalen = len;
 3230480:	e0fffe17 	ldw	r3,-8(fp)
 3230484:	e0bff917 	ldw	r2,-28(fp)
 3230488:	18800015 	stw	r2,0(r3)
            m = m_free(m);
 323048c:	e13ffa17 	ldw	r4,-24(fp)
 3230490:	322bb340 	call	322bb34 <m_free>
 3230494:	e0bffa15 	stw	r2,-24(fp)
         } while (*datalen && (error == 0) && m);
 3230498:	e0bffe17 	ldw	r2,-8(fp)
 323049c:	10800017 	ldw	r2,0(r2)
 32304a0:	1005003a 	cmpeq	r2,r2,zero
 32304a4:	1000061e 	bne	r2,zero,32304c0 <soreceive+0x15c>
 32304a8:	e0bff817 	ldw	r2,-32(fp)
 32304ac:	1004c03a 	cmpne	r2,r2,zero
 32304b0:	1000031e 	bne	r2,zero,32304c0 <soreceive+0x15c>
 32304b4:	e0bffa17 	ldw	r2,-24(fp)
 32304b8:	1004c03a 	cmpne	r2,r2,zero
 32304bc:	103fd91e 	bne	r2,zero,3230424 <soreceive+0xc0>
      }

      if (m)
 32304c0:	e0bffa17 	ldw	r2,-24(fp)
 32304c4:	1005003a 	cmpeq	r2,r2,zero
 32304c8:	1000021e 	bne	r2,zero,32304d4 <soreceive+0x170>
         m_freem(m);
 32304cc:	e13ffa17 	ldw	r4,-24(fp)
 32304d0:	322bc680 	call	322bc68 <m_freem>
      return (error);
 32304d4:	e0bff817 	ldw	r2,-32(fp)
 32304d8:	e0bfff15 	stw	r2,-4(fp)
 32304dc:	00019406 	br	3230b30 <soreceive+0x7cc>
   }

restart:
   sblock (&so->so_rcv);
 32304e0:	e0bffb17 	ldw	r2,-20(fp)
 32304e4:	10801104 	addi	r2,r2,68
 32304e8:	1009883a 	mov	r4,r2
 32304ec:	32267600 	call	3226760 <tcp_sleep>
 32304f0:	e0bffb17 	ldw	r2,-20(fp)
 32304f4:	1080110b 	ldhu	r2,68(r2)
 32304f8:	10bfffcc 	andi	r2,r2,65535
 32304fc:	1080004c 	andi	r2,r2,1
 3230500:	10803fcc 	andi	r2,r2,255
 3230504:	1004c03a 	cmpne	r2,r2,zero
 3230508:	103ff51e 	bne	r2,zero,32304e0 <soreceive+0x17c>
 323050c:	e0bffb17 	ldw	r2,-20(fp)
 3230510:	1080110b 	ldhu	r2,68(r2)
 3230514:	10800054 	ori	r2,r2,1
 3230518:	1007883a 	mov	r3,r2
 323051c:	e0bffb17 	ldw	r2,-20(fp)
 3230520:	10c0110d 	sth	r3,68(r2)
   INET_TRACE (INETM_IO,
    ("INET:soreceive sbcc %d soerror %d so_state %d *datalen %d\n",
    so->so_rcv.sb_cc, so->so_error, so->so_state, *datalen));

   /* If no data is ready, see if we should wait or return */
   if (so->so_rcv.sb_cc == 0) 
 3230524:	e0bffb17 	ldw	r2,-20(fp)
 3230528:	10800a17 	ldw	r2,40(r2)
 323052c:	1004c03a 	cmpne	r2,r2,zero
 3230530:	1000401e 	bne	r2,zero,3230634 <soreceive+0x2d0>
   {
      if (so->so_error) 
 3230534:	e0bffb17 	ldw	r2,-20(fp)
 3230538:	10800617 	ldw	r2,24(r2)
 323053c:	1005003a 	cmpeq	r2,r2,zero
 3230540:	1000061e 	bne	r2,zero,323055c <soreceive+0x1f8>
      {
         error = so->so_error;
 3230544:	e0bffb17 	ldw	r2,-20(fp)
 3230548:	10800617 	ldw	r2,24(r2)
 323054c:	e0bff815 	stw	r2,-32(fp)
         so->so_error = 0;
 3230550:	e0bffb17 	ldw	r2,-20(fp)
 3230554:	10000615 	stw	zero,24(r2)
         goto release;
 3230558:	00016806 	br	3230afc <soreceive+0x798>
      }
      if (so->so_state & SS_CANTRCVMORE)
 323055c:	e0bffb17 	ldw	r2,-20(fp)
 3230560:	1080088b 	ldhu	r2,34(r2)
 3230564:	10bfffcc 	andi	r2,r2,65535
 3230568:	1080080c 	andi	r2,r2,32
 323056c:	1004c03a 	cmpne	r2,r2,zero
 3230570:	1001621e 	bne	r2,zero,3230afc <soreceive+0x798>
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 3230574:	e0bffb17 	ldw	r2,-20(fp)
 3230578:	1080088b 	ldhu	r2,34(r2)
 323057c:	10bfffcc 	andi	r2,r2,65535
 3230580:	1080008c 	andi	r2,r2,2
 3230584:	1004c03a 	cmpne	r2,r2,zero
 3230588:	10000a1e 	bne	r2,zero,32305b4 <soreceive+0x250>
 323058c:	e0bffb17 	ldw	r2,-20(fp)
 3230590:	10800217 	ldw	r2,8(r2)
 3230594:	1080010b 	ldhu	r2,4(r2)
 3230598:	10bfffcc 	andi	r2,r2,65535
 323059c:	1080010c 	andi	r2,r2,4
 32305a0:	1005003a 	cmpeq	r2,r2,zero
 32305a4:	1000031e 	bne	r2,zero,32305b4 <soreceive+0x250>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
      {
         error = ENOTCONN;
 32305a8:	00802004 	movi	r2,128
 32305ac:	e0bff815 	stw	r2,-32(fp)
         goto release;
 32305b0:	00015206 	br	3230afc <soreceive+0x798>
      }
      if (*datalen == 0)
 32305b4:	e0bffe17 	ldw	r2,-8(fp)
 32305b8:	10800017 	ldw	r2,0(r2)
 32305bc:	1005003a 	cmpeq	r2,r2,zero
 32305c0:	10014e1e 	bne	r2,zero,3230afc <soreceive+0x798>
         goto release;
      if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT)) 
 32305c4:	e0bffb17 	ldw	r2,-20(fp)
 32305c8:	1080088b 	ldhu	r2,34(r2)
 32305cc:	10bfffcc 	andi	r2,r2,65535
 32305d0:	1080400c 	andi	r2,r2,256
 32305d4:	1004c03a 	cmpne	r2,r2,zero
 32305d8:	1000041e 	bne	r2,zero,32305ec <soreceive+0x288>
 32305dc:	e0800217 	ldw	r2,8(fp)
 32305e0:	1080080c 	andi	r2,r2,32
 32305e4:	1005003a 	cmpeq	r2,r2,zero
 32305e8:	1000031e 	bne	r2,zero,32305f8 <soreceive+0x294>
      {
         error = EWOULDBLOCK;
 32305ec:	008002c4 	movi	r2,11
 32305f0:	e0bff815 	stw	r2,-32(fp)
         goto release;
 32305f4:	00014106 	br	3230afc <soreceive+0x798>
      }
      sbunlock(&so->so_rcv);
 32305f8:	e0bffb17 	ldw	r2,-20(fp)
 32305fc:	10c0110b 	ldhu	r3,68(r2)
 3230600:	00bfff84 	movi	r2,-2
 3230604:	1884703a 	and	r2,r3,r2
 3230608:	1007883a 	mov	r3,r2
 323060c:	e0bffb17 	ldw	r2,-20(fp)
 3230610:	10c0110d 	sth	r3,68(r2)
 3230614:	e0bffb17 	ldw	r2,-20(fp)
 3230618:	10801104 	addi	r2,r2,68
 323061c:	1009883a 	mov	r4,r2
 3230620:	32269000 	call	3226900 <tcp_wakeup>
      sbwait(&so->so_rcv);
 3230624:	e0bffb17 	ldw	r2,-20(fp)
 3230628:	11000a04 	addi	r4,r2,40
 323062c:	3231ea40 	call	3231ea4 <sbwait>
      goto restart;
 3230630:	003faf06 	br	32304f0 <soreceive+0x18c>
   }
   m = so->so_rcv.sb_mb;
 3230634:	e0bffb17 	ldw	r2,-20(fp)
 3230638:	10801017 	ldw	r2,64(r2)
 323063c:	e0bffa15 	stw	r2,-24(fp)
   if (m == 0)
 3230640:	e0bffa17 	ldw	r2,-24(fp)
 3230644:	1004c03a 	cmpne	r2,r2,zero
 3230648:	1000031e 	bne	r2,zero,3230658 <soreceive+0x2f4>
      panic("sorecv 1");
 323064c:	0100c974 	movhi	r4,805
 3230650:	213d4b04 	addi	r4,r4,-2772
 3230654:	3225df00 	call	3225df0 <panic>
   nextrecord = m->m_act;
 3230658:	e0bffa17 	ldw	r2,-24(fp)
 323065c:	10800717 	ldw	r2,28(r2)
 3230660:	e0bff515 	stw	r2,-44(fp)
   if (pr->pr_flags & PR_ADDR) 
 3230664:	e0bff617 	ldw	r2,-40(fp)
 3230668:	1080010b 	ldhu	r2,4(r2)
 323066c:	10bfffcc 	andi	r2,r2,65535
 3230670:	1080008c 	andi	r2,r2,2
 3230674:	1005003a 	cmpeq	r2,r2,zero
 3230678:	1000451e 	bne	r2,zero,3230790 <soreceive+0x42c>
   {
      if (m->m_type != MT_SONAME) 
 323067c:	e0bffa17 	ldw	r2,-24(fp)
 3230680:	10800817 	ldw	r2,32(r2)
 3230684:	10800260 	cmpeqi	r2,r2,9
 3230688:	1000081e 	bne	r2,zero,32306ac <soreceive+0x348>
      {
         dprintf ("sorecv:type %d not nam", m->m_type);
 323068c:	e0bffa17 	ldw	r2,-24(fp)
 3230690:	11400817 	ldw	r5,32(r2)
 3230694:	0100c974 	movhi	r4,805
 3230698:	213d4e04 	addi	r4,r4,-2760
 323069c:	3206adc0 	call	3206adc <printf>
         panic("sorecv 2");
 32306a0:	0100c974 	movhi	r4,805
 32306a4:	213d5404 	addi	r4,r4,-2736
 32306a8:	3225df00 	call	3225df0 <panic>
      }
      if (flags & MSG_PEEK) 
 32306ac:	e0800217 	ldw	r2,8(fp)
 32306b0:	1080008c 	andi	r2,r2,2
 32306b4:	1005003a 	cmpeq	r2,r2,zero
 32306b8:	1000101e 	bne	r2,zero,32306fc <soreceive+0x398>
      {
         if (aname)
 32306bc:	e0bffc17 	ldw	r2,-16(fp)
 32306c0:	1005003a 	cmpeq	r2,r2,zero
 32306c4:	1000091e 	bne	r2,zero,32306ec <soreceive+0x388>
            *aname = m_copy (m, 0, m->m_len);
 32306c8:	e0bffa17 	ldw	r2,-24(fp)
 32306cc:	10800217 	ldw	r2,8(r2)
 32306d0:	100d883a 	mov	r6,r2
 32306d4:	e13ffa17 	ldw	r4,-24(fp)
 32306d8:	000b883a 	mov	r5,zero
 32306dc:	322bcac0 	call	322bcac <m_copy>
 32306e0:	1007883a 	mov	r3,r2
 32306e4:	e0bffc17 	ldw	r2,-16(fp)
 32306e8:	10c00015 	stw	r3,0(r2)
         m = m->m_next;
 32306ec:	e0bffa17 	ldw	r2,-24(fp)
 32306f0:	10800617 	ldw	r2,24(r2)
 32306f4:	e0bffa15 	stw	r2,-24(fp)
 32306f8:	00002506 	br	3230790 <soreceive+0x42c>
      } else 
      {
         sbfree (&so->so_rcv, m);
 32306fc:	e0bffb17 	ldw	r2,-20(fp)
 3230700:	10c00a17 	ldw	r3,40(r2)
 3230704:	e0bffa17 	ldw	r2,-24(fp)
 3230708:	10800217 	ldw	r2,8(r2)
 323070c:	1887c83a 	sub	r3,r3,r2
 3230710:	e0bffb17 	ldw	r2,-20(fp)
 3230714:	10c00a15 	stw	r3,40(r2)
         if (aname) 
 3230718:	e0bffc17 	ldw	r2,-16(fp)
 323071c:	1005003a 	cmpeq	r2,r2,zero
 3230720:	10000d1e 	bne	r2,zero,3230758 <soreceive+0x3f4>
         {
            *aname = m;
 3230724:	e0fffc17 	ldw	r3,-16(fp)
 3230728:	e0bffa17 	ldw	r2,-24(fp)
 323072c:	18800015 	stw	r2,0(r3)
            m = m->m_next;
 3230730:	e0bffa17 	ldw	r2,-24(fp)
 3230734:	10800617 	ldw	r2,24(r2)
 3230738:	e0bffa15 	stw	r2,-24(fp)
            (*aname)->m_next = 0;
 323073c:	e0bffc17 	ldw	r2,-16(fp)
 3230740:	10800017 	ldw	r2,0(r2)
 3230744:	10000615 	stw	zero,24(r2)
            so->so_rcv.sb_mb = m;
 3230748:	e0fffb17 	ldw	r3,-20(fp)
 323074c:	e0bffa17 	ldw	r2,-24(fp)
 3230750:	18801015 	stw	r2,64(r3)
 3230754:	00000806 	br	3230778 <soreceive+0x414>
         } else 
         {
            MFREE(m, so->so_rcv.sb_mb);
 3230758:	e13ffa17 	ldw	r4,-24(fp)
 323075c:	322bb340 	call	322bb34 <m_free>
 3230760:	1007883a 	mov	r3,r2
 3230764:	e0bffb17 	ldw	r2,-20(fp)
 3230768:	10c01015 	stw	r3,64(r2)
            m = so->so_rcv.sb_mb;
 323076c:	e0bffb17 	ldw	r2,-20(fp)
 3230770:	10801017 	ldw	r2,64(r2)
 3230774:	e0bffa15 	stw	r2,-24(fp)
         }
         if (m)
 3230778:	e0bffa17 	ldw	r2,-24(fp)
 323077c:	1005003a 	cmpeq	r2,r2,zero
 3230780:	1000031e 	bne	r2,zero,3230790 <soreceive+0x42c>
            m->m_act = nextrecord;
 3230784:	e0fffa17 	ldw	r3,-24(fp)
 3230788:	e0bff517 	ldw	r2,-44(fp)
 323078c:	18800715 	stw	r2,28(r3)
      }
   }
   moff = 0;
 3230790:	e03ff415 	stw	zero,-48(fp)
   offset = 0;
 3230794:	e03ff715 	stw	zero,-36(fp)
   while (m && (*datalen > 0) && (error == 0))
 3230798:	0000a606 	br	3230a34 <soreceive+0x6d0>
   {
      if (m->m_type != MT_RXDATA && m->m_type != MT_HEADER)
 323079c:	e0bffa17 	ldw	r2,-24(fp)
 32307a0:	10800817 	ldw	r2,32(r2)
 32307a4:	10800060 	cmpeqi	r2,r2,1
 32307a8:	1000071e 	bne	r2,zero,32307c8 <soreceive+0x464>
 32307ac:	e0bffa17 	ldw	r2,-24(fp)
 32307b0:	10800817 	ldw	r2,32(r2)
 32307b4:	108000e0 	cmpeqi	r2,r2,3
 32307b8:	1000031e 	bne	r2,zero,32307c8 <soreceive+0x464>
         panic("sorecv 3");
 32307bc:	0100c974 	movhi	r4,805
 32307c0:	213d5704 	addi	r4,r4,-2724
 32307c4:	3225df00 	call	3225df0 <panic>
      len = *datalen;
 32307c8:	e0bffe17 	ldw	r2,-8(fp)
 32307cc:	10800017 	ldw	r2,0(r2)
 32307d0:	e0bff915 	stw	r2,-28(fp)
      so->so_state &= ~SS_RCVATMARK;
 32307d4:	e0bffb17 	ldw	r2,-20(fp)
 32307d8:	10c0088b 	ldhu	r3,34(r2)
 32307dc:	00bfefc4 	movi	r2,-65
 32307e0:	1884703a 	and	r2,r3,r2
 32307e4:	1007883a 	mov	r3,r2
 32307e8:	e0bffb17 	ldw	r2,-20(fp)
 32307ec:	10c0088d 	sth	r3,34(r2)
      if (so->so_oobmark && (len > (int)(so->so_oobmark - offset)))
 32307f0:	e0bffb17 	ldw	r2,-20(fp)
 32307f4:	10801a17 	ldw	r2,104(r2)
 32307f8:	1005003a 	cmpeq	r2,r2,zero
 32307fc:	10000c1e 	bne	r2,zero,3230830 <soreceive+0x4cc>
 3230800:	e0bffb17 	ldw	r2,-20(fp)
 3230804:	10c01a17 	ldw	r3,104(r2)
 3230808:	e0bff717 	ldw	r2,-36(fp)
 323080c:	1885c83a 	sub	r2,r3,r2
 3230810:	1007883a 	mov	r3,r2
 3230814:	e0bff917 	ldw	r2,-28(fp)
 3230818:	1880050e 	bge	r3,r2,3230830 <soreceive+0x4cc>
         len = (int)(so->so_oobmark - offset);
 323081c:	e0bffb17 	ldw	r2,-20(fp)
 3230820:	10c01a17 	ldw	r3,104(r2)
 3230824:	e0bff717 	ldw	r2,-36(fp)
 3230828:	1885c83a 	sub	r2,r3,r2
 323082c:	e0bff915 	stw	r2,-28(fp)
      if (len > (int)(m->m_len - moff))
 3230830:	e0bffa17 	ldw	r2,-24(fp)
 3230834:	10c00217 	ldw	r3,8(r2)
 3230838:	e0bff417 	ldw	r2,-48(fp)
 323083c:	1885c83a 	sub	r2,r3,r2
 3230840:	1007883a 	mov	r3,r2
 3230844:	e0bff917 	ldw	r2,-28(fp)
 3230848:	1880050e 	bge	r3,r2,3230860 <soreceive+0x4fc>
         len = m->m_len - moff;
 323084c:	e0bffa17 	ldw	r2,-24(fp)
 3230850:	10c00217 	ldw	r3,8(r2)
 3230854:	e0bff417 	ldw	r2,-48(fp)
 3230858:	1885c83a 	sub	r2,r3,r2
 323085c:	e0bff915 	stw	r2,-28(fp)
       * it points to next record) when we drop priority;
       * we must note any additions to the sockbuf when we
       * block interrupts again.
       */

      MEMCPY(data, (mtod(m, char *) + moff), len);
 3230860:	e0bffa17 	ldw	r2,-24(fp)
 3230864:	10c00317 	ldw	r3,12(r2)
 3230868:	e0bff417 	ldw	r2,-48(fp)
 323086c:	1887883a 	add	r3,r3,r2
 3230870:	e1bff917 	ldw	r6,-28(fp)
 3230874:	e0bffd17 	ldw	r2,-12(fp)
 3230878:	1009883a 	mov	r4,r2
 323087c:	180b883a 	mov	r5,r3
 3230880:	32067cc0 	call	32067cc <memcpy>
      data += len;
 3230884:	e0bff917 	ldw	r2,-28(fp)
 3230888:	1007883a 	mov	r3,r2
 323088c:	e0bffd17 	ldw	r2,-12(fp)
 3230890:	10c5883a 	add	r2,r2,r3
 3230894:	e0bffd15 	stw	r2,-12(fp)
      *datalen -= len;
 3230898:	e0bffe17 	ldw	r2,-8(fp)
 323089c:	10c00017 	ldw	r3,0(r2)
 32308a0:	e0bff917 	ldw	r2,-28(fp)
 32308a4:	1887c83a 	sub	r3,r3,r2
 32308a8:	e0bffe17 	ldw	r2,-8(fp)
 32308ac:	10c00015 	stw	r3,0(r2)

      if (len == (int)(m->m_len - moff))
 32308b0:	e0bffa17 	ldw	r2,-24(fp)
 32308b4:	10c00217 	ldw	r3,8(r2)
 32308b8:	e0bff417 	ldw	r2,-48(fp)
 32308bc:	1885c83a 	sub	r2,r3,r2
 32308c0:	1007883a 	mov	r3,r2
 32308c4:	e0bff917 	ldw	r2,-28(fp)
 32308c8:	1880221e 	bne	r3,r2,3230954 <soreceive+0x5f0>
      {
         if (flags & MSG_PEEK) 
 32308cc:	e0800217 	ldw	r2,8(fp)
 32308d0:	1080008c 	andi	r2,r2,2
 32308d4:	1005003a 	cmpeq	r2,r2,zero
 32308d8:	1000051e 	bne	r2,zero,32308f0 <soreceive+0x58c>
         {
            m = m->m_next;
 32308dc:	e0bffa17 	ldw	r2,-24(fp)
 32308e0:	10800617 	ldw	r2,24(r2)
 32308e4:	e0bffa15 	stw	r2,-24(fp)
            moff = 0;
 32308e8:	e03ff415 	stw	zero,-48(fp)
 32308ec:	00003406 	br	32309c0 <soreceive+0x65c>
         } else 
         {
            nextrecord = m->m_act;
 32308f0:	e0bffa17 	ldw	r2,-24(fp)
 32308f4:	10800717 	ldw	r2,28(r2)
 32308f8:	e0bff515 	stw	r2,-44(fp)
            sbfree(&so->so_rcv, m);
 32308fc:	e0bffb17 	ldw	r2,-20(fp)
 3230900:	10c00a17 	ldw	r3,40(r2)
 3230904:	e0bffa17 	ldw	r2,-24(fp)
 3230908:	10800217 	ldw	r2,8(r2)
 323090c:	1887c83a 	sub	r3,r3,r2
 3230910:	e0bffb17 	ldw	r2,-20(fp)
 3230914:	10c00a15 	stw	r3,40(r2)
            {
               MFREE(m, so->so_rcv.sb_mb);
 3230918:	e13ffa17 	ldw	r4,-24(fp)
 323091c:	322bb340 	call	322bb34 <m_free>
 3230920:	1007883a 	mov	r3,r2
 3230924:	e0bffb17 	ldw	r2,-20(fp)
 3230928:	10c01015 	stw	r3,64(r2)
               m = so->so_rcv.sb_mb;
 323092c:	e0bffb17 	ldw	r2,-20(fp)
 3230930:	10801017 	ldw	r2,64(r2)
 3230934:	e0bffa15 	stw	r2,-24(fp)
            }
            if (m)
 3230938:	e0bffa17 	ldw	r2,-24(fp)
 323093c:	1005003a 	cmpeq	r2,r2,zero
 3230940:	10001f1e 	bne	r2,zero,32309c0 <soreceive+0x65c>
               m->m_act = nextrecord;
 3230944:	e0fffa17 	ldw	r3,-24(fp)
 3230948:	e0bff517 	ldw	r2,-44(fp)
 323094c:	18800715 	stw	r2,28(r3)
 3230950:	00001b06 	br	32309c0 <soreceive+0x65c>
         }
      } else 
      {
         if (flags & MSG_PEEK)
 3230954:	e0800217 	ldw	r2,8(fp)
 3230958:	1080008c 	andi	r2,r2,2
 323095c:	1005003a 	cmpeq	r2,r2,zero
 3230960:	1000051e 	bne	r2,zero,3230978 <soreceive+0x614>
            moff += len;
 3230964:	e0bff417 	ldw	r2,-48(fp)
 3230968:	e0fff917 	ldw	r3,-28(fp)
 323096c:	10c5883a 	add	r2,r2,r3
 3230970:	e0bff415 	stw	r2,-48(fp)
 3230974:	00001206 	br	32309c0 <soreceive+0x65c>
         else 
         {
            m->m_data += len;
 3230978:	e0bffa17 	ldw	r2,-24(fp)
 323097c:	10c00317 	ldw	r3,12(r2)
 3230980:	e0bff917 	ldw	r2,-28(fp)
 3230984:	1887883a 	add	r3,r3,r2
 3230988:	e0bffa17 	ldw	r2,-24(fp)
 323098c:	10c00315 	stw	r3,12(r2)
            m->m_len -= len;
 3230990:	e0bffa17 	ldw	r2,-24(fp)
 3230994:	10c00217 	ldw	r3,8(r2)
 3230998:	e0bff917 	ldw	r2,-28(fp)
 323099c:	1887c83a 	sub	r3,r3,r2
 32309a0:	e0bffa17 	ldw	r2,-24(fp)
 32309a4:	10c00215 	stw	r3,8(r2)
            so->so_rcv.sb_cc -= len;
 32309a8:	e0bffb17 	ldw	r2,-20(fp)
 32309ac:	10c00a17 	ldw	r3,40(r2)
 32309b0:	e0bff917 	ldw	r2,-28(fp)
 32309b4:	1887c83a 	sub	r3,r3,r2
 32309b8:	e0bffb17 	ldw	r2,-20(fp)
 32309bc:	10c00a15 	stw	r3,40(r2)
         }
      }
      if (so->so_oobmark) 
 32309c0:	e0bffb17 	ldw	r2,-20(fp)
 32309c4:	10801a17 	ldw	r2,104(r2)
 32309c8:	1005003a 	cmpeq	r2,r2,zero
 32309cc:	1000191e 	bne	r2,zero,3230a34 <soreceive+0x6d0>
      {
         if ((flags & MSG_PEEK) == 0) 
 32309d0:	e0800217 	ldw	r2,8(fp)
 32309d4:	1080008c 	andi	r2,r2,2
 32309d8:	1004c03a 	cmpne	r2,r2,zero
 32309dc:	1000111e 	bne	r2,zero,3230a24 <soreceive+0x6c0>
         {
            so->so_oobmark -= len;
 32309e0:	e0bffb17 	ldw	r2,-20(fp)
 32309e4:	10c01a17 	ldw	r3,104(r2)
 32309e8:	e0bff917 	ldw	r2,-28(fp)
 32309ec:	1887c83a 	sub	r3,r3,r2
 32309f0:	e0bffb17 	ldw	r2,-20(fp)
 32309f4:	10c01a15 	stw	r3,104(r2)
            if (so->so_oobmark == 0) 
 32309f8:	e0bffb17 	ldw	r2,-20(fp)
 32309fc:	10801a17 	ldw	r2,104(r2)
 3230a00:	1004c03a 	cmpne	r2,r2,zero
 3230a04:	10000b1e 	bne	r2,zero,3230a34 <soreceive+0x6d0>
            {
               so->so_state |= SS_RCVATMARK;
 3230a08:	e0bffb17 	ldw	r2,-20(fp)
 3230a0c:	1080088b 	ldhu	r2,34(r2)
 3230a10:	10801014 	ori	r2,r2,64
 3230a14:	1007883a 	mov	r3,r2
 3230a18:	e0bffb17 	ldw	r2,-20(fp)
 3230a1c:	10c0088d 	sth	r3,34(r2)
               break;
 3230a20:	00000e06 	br	3230a5c <soreceive+0x6f8>
            }
         } else
            offset += len;
 3230a24:	e0bff717 	ldw	r2,-36(fp)
 3230a28:	e0fff917 	ldw	r3,-28(fp)
 3230a2c:	10c5883a 	add	r2,r2,r3
 3230a30:	e0bff715 	stw	r2,-36(fp)
            m->m_act = nextrecord;
      }
   }
   moff = 0;
   offset = 0;
   while (m && (*datalen > 0) && (error == 0))
 3230a34:	e0bffa17 	ldw	r2,-24(fp)
 3230a38:	1005003a 	cmpeq	r2,r2,zero
 3230a3c:	1000071e 	bne	r2,zero,3230a5c <soreceive+0x6f8>
 3230a40:	e0bffe17 	ldw	r2,-8(fp)
 3230a44:	10800017 	ldw	r2,0(r2)
 3230a48:	10800050 	cmplti	r2,r2,1
 3230a4c:	1000031e 	bne	r2,zero,3230a5c <soreceive+0x6f8>
 3230a50:	e0bff817 	ldw	r2,-32(fp)
 3230a54:	1005003a 	cmpeq	r2,r2,zero
 3230a58:	103f501e 	bne	r2,zero,323079c <soreceive+0x438>
         } else
            offset += len;
      }
   }

   if ((flags & MSG_PEEK) == 0) 
 3230a5c:	e0800217 	ldw	r2,8(fp)
 3230a60:	1080008c 	andi	r2,r2,2
 3230a64:	1004c03a 	cmpne	r2,r2,zero
 3230a68:	1000241e 	bne	r2,zero,3230afc <soreceive+0x798>
   {
      if (m == 0)
 3230a6c:	e0bffa17 	ldw	r2,-24(fp)
 3230a70:	1004c03a 	cmpne	r2,r2,zero
 3230a74:	1000041e 	bne	r2,zero,3230a88 <soreceive+0x724>
         so->so_rcv.sb_mb = nextrecord;
 3230a78:	e0fffb17 	ldw	r3,-20(fp)
 3230a7c:	e0bff517 	ldw	r2,-44(fp)
 3230a80:	18801015 	stw	r2,64(r3)
 3230a84:	00000a06 	br	3230ab0 <soreceive+0x74c>
      else if (pr->pr_flags & PR_ATOMIC)
 3230a88:	e0bff617 	ldw	r2,-40(fp)
 3230a8c:	1080010b 	ldhu	r2,4(r2)
 3230a90:	10bfffcc 	andi	r2,r2,65535
 3230a94:	1080004c 	andi	r2,r2,1
 3230a98:	10803fcc 	andi	r2,r2,255
 3230a9c:	1005003a 	cmpeq	r2,r2,zero
 3230aa0:	1000031e 	bne	r2,zero,3230ab0 <soreceive+0x74c>
         (void) sbdroprecord(&so->so_rcv);
 3230aa4:	e0bffb17 	ldw	r2,-20(fp)
 3230aa8:	11000a04 	addi	r4,r2,40
 3230aac:	32329b80 	call	32329b8 <sbdroprecord>
      if (pr->pr_flags & PR_WANTRCVD && so->so_pcb)
 3230ab0:	e0bff617 	ldw	r2,-40(fp)
 3230ab4:	1080010b 	ldhu	r2,4(r2)
 3230ab8:	10bfffcc 	andi	r2,r2,65535
 3230abc:	1080020c 	andi	r2,r2,8
 3230ac0:	1005003a 	cmpeq	r2,r2,zero
 3230ac4:	10000d1e 	bne	r2,zero,3230afc <soreceive+0x798>
 3230ac8:	e0bffb17 	ldw	r2,-20(fp)
 3230acc:	10800117 	ldw	r2,4(r2)
 3230ad0:	1005003a 	cmpeq	r2,r2,zero
 3230ad4:	1000091e 	bne	r2,zero,3230afc <soreceive+0x798>
      {
         so->so_req = PRU_RCVD;
 3230ad8:	e0fffb17 	ldw	r3,-20(fp)
 3230adc:	00800204 	movi	r2,8
 3230ae0:	18800715 	stw	r2,28(r3)
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
 3230ae4:	e0bff617 	ldw	r2,-40(fp)
 3230ae8:	10800317 	ldw	r2,12(r2)
 3230aec:	e13ffb17 	ldw	r4,-20(fp)
 3230af0:	000b883a 	mov	r5,zero
 3230af4:	000d883a 	mov	r6,zero
 3230af8:	103ee83a 	callr	r2
          (struct mbuf *)0);
      }
   }
release:
   sbunlock(&so->so_rcv);
 3230afc:	e0bffb17 	ldw	r2,-20(fp)
 3230b00:	10c0110b 	ldhu	r3,68(r2)
 3230b04:	00bfff84 	movi	r2,-2
 3230b08:	1884703a 	and	r2,r3,r2
 3230b0c:	1007883a 	mov	r3,r2
 3230b10:	e0bffb17 	ldw	r2,-20(fp)
 3230b14:	10c0110d 	sth	r3,68(r2)
 3230b18:	e0bffb17 	ldw	r2,-20(fp)
 3230b1c:	10801104 	addi	r2,r2,68
 3230b20:	1009883a 	mov	r4,r2
 3230b24:	32269000 	call	3226900 <tcp_wakeup>
   return (error);
 3230b28:	e0bff817 	ldw	r2,-32(fp)
 3230b2c:	e0bfff15 	stw	r2,-4(fp)
 3230b30:	e0bfff17 	ldw	r2,-4(fp)
}
 3230b34:	e037883a 	mov	sp,fp
 3230b38:	dfc00117 	ldw	ra,4(sp)
 3230b3c:	df000017 	ldw	fp,0(sp)
 3230b40:	dec00204 	addi	sp,sp,8
 3230b44:	f800283a 	ret

03230b48 <soshutdown>:
 *
 * RETURNS: int               0 if successful, else error code
 */
int
soshutdown(struct socket *so, int how)
{
 3230b48:	defffb04 	addi	sp,sp,-20
 3230b4c:	dfc00415 	stw	ra,16(sp)
 3230b50:	df000315 	stw	fp,12(sp)
 3230b54:	df000304 	addi	fp,sp,12
 3230b58:	e13ffd15 	stw	r4,-12(fp)
 3230b5c:	e17ffe15 	stw	r5,-8(fp)
   how++;   /* convert 0,1,2 into 1,2,3 */
 3230b60:	e0bffe17 	ldw	r2,-8(fp)
 3230b64:	10800044 	addi	r2,r2,1
 3230b68:	e0bffe15 	stw	r2,-8(fp)
   if (how & 1)   /* caller wanted READ or BOTH */
 3230b6c:	e0bffe17 	ldw	r2,-8(fp)
 3230b70:	1080004c 	andi	r2,r2,1
 3230b74:	10803fcc 	andi	r2,r2,255
 3230b78:	1005003a 	cmpeq	r2,r2,zero
 3230b7c:	1000021e 	bne	r2,zero,3230b88 <soshutdown+0x40>
      sorflush(so);
 3230b80:	e13ffd17 	ldw	r4,-12(fp)
 3230b84:	3230bf00 	call	3230bf0 <sorflush>

   if (how & 2)   /* caller wanted WRITE or BOTH */
 3230b88:	e0bffe17 	ldw	r2,-8(fp)
 3230b8c:	1080008c 	andi	r2,r2,2
 3230b90:	1005003a 	cmpeq	r2,r2,zero
 3230b94:	10000f1e 	bne	r2,zero,3230bd4 <soshutdown+0x8c>
   {
      sbflush(&so->so_snd); /* flush the socket send queue */
 3230b98:	e0bffd17 	ldw	r2,-12(fp)
 3230b9c:	11001204 	addi	r4,r2,72
 3230ba0:	32326480 	call	3232648 <sbflush>
      so->so_req = PRU_SHUTDOWN;
 3230ba4:	e0fffd17 	ldw	r3,-12(fp)
 3230ba8:	008001c4 	movi	r2,7
 3230bac:	18800715 	stw	r2,28(r3)
      return ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0));
 3230bb0:	e0bffd17 	ldw	r2,-12(fp)
 3230bb4:	10800217 	ldw	r2,8(r2)
 3230bb8:	10800317 	ldw	r2,12(r2)
 3230bbc:	e13ffd17 	ldw	r4,-12(fp)
 3230bc0:	000b883a 	mov	r5,zero
 3230bc4:	000d883a 	mov	r6,zero
 3230bc8:	103ee83a 	callr	r2
 3230bcc:	e0bfff15 	stw	r2,-4(fp)
 3230bd0:	00000106 	br	3230bd8 <soshutdown+0x90>
   }

   return 0;
 3230bd4:	e03fff15 	stw	zero,-4(fp)
 3230bd8:	e0bfff17 	ldw	r2,-4(fp)
}
 3230bdc:	e037883a 	mov	sp,fp
 3230be0:	dfc00117 	ldw	ra,4(sp)
 3230be4:	df000017 	ldw	fp,0(sp)
 3230be8:	dec00204 	addi	sp,sp,8
 3230bec:	f800283a 	ret

03230bf0 <sorflush>:
 * socket receive buffer is discarded. Wakeup any processes waiting
 * on the socket.
 */
void
sorflush(struct socket * so)
{
 3230bf0:	defffb04 	addi	sp,sp,-20
 3230bf4:	dfc00415 	stw	ra,16(sp)
 3230bf8:	df000315 	stw	fp,12(sp)
 3230bfc:	df000304 	addi	fp,sp,12
 3230c00:	e13fff15 	stw	r4,-4(fp)
   struct sockbuf *sb =  &so->so_rcv;
 3230c04:	e0bfff17 	ldw	r2,-4(fp)
 3230c08:	10800a04 	addi	r2,r2,40
 3230c0c:	e0bffe15 	stw	r2,-8(fp)
   int   s;

   sblock(sb);
 3230c10:	00000406 	br	3230c24 <sorflush+0x34>
 3230c14:	e0bffe17 	ldw	r2,-8(fp)
 3230c18:	10800704 	addi	r2,r2,28
 3230c1c:	1009883a 	mov	r4,r2
 3230c20:	32267600 	call	3226760 <tcp_sleep>
 3230c24:	e0bffe17 	ldw	r2,-8(fp)
 3230c28:	1080070b 	ldhu	r2,28(r2)
 3230c2c:	10bfffcc 	andi	r2,r2,65535
 3230c30:	1080004c 	andi	r2,r2,1
 3230c34:	10803fcc 	andi	r2,r2,255
 3230c38:	1004c03a 	cmpne	r2,r2,zero
 3230c3c:	103ff51e 	bne	r2,zero,3230c14 <sorflush+0x24>
 3230c40:	e0bffe17 	ldw	r2,-8(fp)
 3230c44:	1080070b 	ldhu	r2,28(r2)
 3230c48:	10800054 	ori	r2,r2,1
 3230c4c:	1007883a 	mov	r3,r2
 3230c50:	e0bffe17 	ldw	r2,-8(fp)
 3230c54:	10c0070d 	sth	r3,28(r2)
   socantrcvmore(so);
 3230c58:	e13fff17 	ldw	r4,-4(fp)
 3230c5c:	3231e1c0 	call	3231e1c <socantrcvmore>
   sbunlock(sb);
 3230c60:	e0bffe17 	ldw	r2,-8(fp)
 3230c64:	10c0070b 	ldhu	r3,28(r2)
 3230c68:	00bfff84 	movi	r2,-2
 3230c6c:	1884703a 	and	r2,r3,r2
 3230c70:	1007883a 	mov	r3,r2
 3230c74:	e0bffe17 	ldw	r2,-8(fp)
 3230c78:	10c0070d 	sth	r3,28(r2)
 3230c7c:	e0bffe17 	ldw	r2,-8(fp)
 3230c80:	10800704 	addi	r2,r2,28
 3230c84:	1009883a 	mov	r4,r2
 3230c88:	32269000 	call	3226900 <tcp_wakeup>
   sbrelease(sb);
 3230c8c:	e13ffe17 	ldw	r4,-8(fp)
 3230c90:	32320880 	call	3232088 <sbrelease>
   MEMSET((char *)sb, 0, sizeof (*sb));
 3230c94:	e0bffe17 	ldw	r2,-8(fp)
 3230c98:	1009883a 	mov	r4,r2
 3230c9c:	01800804 	movi	r6,32
 3230ca0:	000b883a 	mov	r5,zero
 3230ca4:	320694c0 	call	320694c <memset>
   s = so->so_error;
 3230ca8:	e0bfff17 	ldw	r2,-4(fp)
 3230cac:	10800617 	ldw	r2,24(r2)
 3230cb0:	e0bffd15 	stw	r2,-12(fp)
   so->so_error = ESHUTDOWN;
 3230cb4:	e0ffff17 	ldw	r3,-4(fp)
 3230cb8:	00801b84 	movi	r2,110
 3230cbc:	18800615 	stw	r2,24(r3)
   sorwakeup(so);
 3230cc0:	e0bfff17 	ldw	r2,-4(fp)
 3230cc4:	11400a04 	addi	r5,r2,40
 3230cc8:	e13fff17 	ldw	r4,-4(fp)
 3230ccc:	3231f0c0 	call	3231f0c <sbwakeup>
   so->so_error = s;
 3230cd0:	e0ffff17 	ldw	r3,-4(fp)
 3230cd4:	e0bffd17 	ldw	r2,-12(fp)
 3230cd8:	18800615 	stw	r2,24(r3)
}
 3230cdc:	e037883a 	mov	sp,fp
 3230ce0:	dfc00117 	ldw	ra,4(sp)
 3230ce4:	df000017 	ldw	fp,0(sp)
 3230ce8:	dec00204 	addi	sp,sp,8
 3230cec:	f800283a 	ret

03230cf0 <sosetopt>:

int
sosetopt(struct socket * so, 
   int   optname,
   void *   arg)
{
 3230cf0:	defff404 	addi	sp,sp,-48
 3230cf4:	dfc00b15 	stw	ra,44(sp)
 3230cf8:	df000a15 	stw	fp,40(sp)
 3230cfc:	df000a04 	addi	fp,sp,40
 3230d00:	e13ffb15 	stw	r4,-20(fp)
 3230d04:	e17ffc15 	stw	r5,-16(fp)
 3230d08:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 3230d0c:	e03ffa15 	stw	zero,-24(fp)

   switch (optname) 
 3230d10:	e0bffc17 	ldw	r2,-16(fp)
 3230d14:	e0bfff15 	stw	r2,-4(fp)
 3230d18:	e0ffff17 	ldw	r3,-4(fp)
 3230d1c:	18808020 	cmpeqi	r2,r3,512
 3230d20:	1000521e 	bne	r2,zero,3230e6c <sosetopt+0x17c>
 3230d24:	e0ffff17 	ldw	r3,-4(fp)
 3230d28:	18808048 	cmpgei	r2,r3,513
 3230d2c:	1000211e 	bne	r2,zero,3230db4 <sosetopt+0xc4>
 3230d30:	e0ffff17 	ldw	r3,-4(fp)
 3230d34:	18800388 	cmpgei	r2,r3,14
 3230d38:	10000d1e 	bne	r2,zero,3230d70 <sosetopt+0x80>
 3230d3c:	e0ffff17 	ldw	r3,-4(fp)
 3230d40:	18800248 	cmpgei	r2,r3,9
 3230d44:	10009d1e 	bne	r2,zero,3230fbc <sosetopt+0x2cc>
 3230d48:	e0ffff17 	ldw	r3,-4(fp)
 3230d4c:	18800120 	cmpeqi	r2,r3,4
 3230d50:	1000461e 	bne	r2,zero,3230e6c <sosetopt+0x17c>
 3230d54:	e0ffff17 	ldw	r3,-4(fp)
 3230d58:	18800220 	cmpeqi	r2,r3,8
 3230d5c:	1000431e 	bne	r2,zero,3230e6c <sosetopt+0x17c>
 3230d60:	e0ffff17 	ldw	r3,-4(fp)
 3230d64:	188000a0 	cmpeqi	r2,r3,2
 3230d68:	10009a1e 	bne	r2,zero,3230fd4 <sosetopt+0x2e4>
 3230d6c:	00010806 	br	3231190 <sosetopt+0x4a0>
 3230d70:	e0ffff17 	ldw	r3,-4(fp)
 3230d74:	18800820 	cmpeqi	r2,r3,32
 3230d78:	10003c1e 	bne	r2,zero,3230e6c <sosetopt+0x17c>
 3230d7c:	e0ffff17 	ldw	r3,-4(fp)
 3230d80:	18800848 	cmpgei	r2,r3,33
 3230d84:	1000041e 	bne	r2,zero,3230d98 <sosetopt+0xa8>
 3230d88:	e0ffff17 	ldw	r3,-4(fp)
 3230d8c:	18800420 	cmpeqi	r2,r3,16
 3230d90:	1000361e 	bne	r2,zero,3230e6c <sosetopt+0x17c>
 3230d94:	0000fe06 	br	3231190 <sosetopt+0x4a0>
 3230d98:	e0ffff17 	ldw	r3,-4(fp)
 3230d9c:	18802020 	cmpeqi	r2,r3,128
 3230da0:	10002d1e 	bne	r2,zero,3230e58 <sosetopt+0x168>
 3230da4:	e0ffff17 	ldw	r3,-4(fp)
 3230da8:	18804020 	cmpeqi	r2,r3,256
 3230dac:	10002f1e 	bne	r2,zero,3230e6c <sosetopt+0x17c>
 3230db0:	0000f706 	br	3231190 <sosetopt+0x4a0>
 3230db4:	e0ffff17 	ldw	r3,-4(fp)
 3230db8:	18840520 	cmpeqi	r2,r3,4116
 3230dbc:	1000571e 	bne	r2,zero,3230f1c <sosetopt+0x22c>
 3230dc0:	e0ffff17 	ldw	r3,-4(fp)
 3230dc4:	18840548 	cmpgei	r2,r3,4117
 3230dc8:	10000f1e 	bne	r2,zero,3230e08 <sosetopt+0x118>
 3230dcc:	e0ffff17 	ldw	r3,-4(fp)
 3230dd0:	188401a0 	cmpeqi	r2,r3,4102
 3230dd4:	10004c1e 	bne	r2,zero,3230f08 <sosetopt+0x218>
 3230dd8:	e0ffff17 	ldw	r3,-4(fp)
 3230ddc:	188401c8 	cmpgei	r2,r3,4103
 3230de0:	1000051e 	bne	r2,zero,3230df8 <sosetopt+0x108>
 3230de4:	e0ffff17 	ldw	r3,-4(fp)
 3230de8:	18bbffc4 	addi	r2,r3,-4097
 3230dec:	108000a8 	cmpgeui	r2,r2,2
 3230df0:	1000e71e 	bne	r2,zero,3231190 <sosetopt+0x4a0>
 3230df4:	00003006 	br	3230eb8 <sosetopt+0x1c8>
 3230df8:	e0ffff17 	ldw	r3,-4(fp)
 3230dfc:	18840420 	cmpeqi	r2,r3,4112
 3230e00:	1000ba1e 	bne	r2,zero,32310ec <sosetopt+0x3fc>
 3230e04:	0000e206 	br	3231190 <sosetopt+0x4a0>
 3230e08:	e0ffff17 	ldw	r3,-4(fp)
 3230e0c:	188800e0 	cmpeqi	r2,r3,8195
 3230e10:	1000b61e 	bne	r2,zero,32310ec <sosetopt+0x3fc>
 3230e14:	e0ffff17 	ldw	r3,-4(fp)
 3230e18:	18880108 	cmpgei	r2,r3,8196
 3230e1c:	1000071e 	bne	r2,zero,3230e3c <sosetopt+0x14c>
 3230e20:	e0ffff17 	ldw	r3,-4(fp)
 3230e24:	18840560 	cmpeqi	r2,r3,4117
 3230e28:	1000431e 	bne	r2,zero,3230f38 <sosetopt+0x248>
 3230e2c:	e0ffff17 	ldw	r3,-4(fp)
 3230e30:	188405a0 	cmpeqi	r2,r3,4118
 3230e34:	1000481e 	bne	r2,zero,3230f58 <sosetopt+0x268>
 3230e38:	0000d506 	br	3231190 <sosetopt+0x4a0>
 3230e3c:	e0ffff17 	ldw	r3,-4(fp)
 3230e40:	18880120 	cmpeqi	r2,r3,8196
 3230e44:	10007a1e 	bne	r2,zero,3231030 <sosetopt+0x340>
 3230e48:	e0ffff17 	ldw	r3,-4(fp)
 3230e4c:	18900020 	cmpeqi	r2,r3,16384
 3230e50:	1000061e 	bne	r2,zero,3230e6c <sosetopt+0x17c>
 3230e54:	0000ce06 	br	3231190 <sosetopt+0x4a0>
   {
   case SO_LINGER:
      so->so_linger = (short)((struct linger *)arg)->l_linger;
 3230e58:	e0bffd17 	ldw	r2,-12(fp)
 3230e5c:	10800117 	ldw	r2,4(r2)
 3230e60:	1007883a 	mov	r3,r2
 3230e64:	e0bffb17 	ldw	r2,-20(fp)
 3230e68:	10c0080d 	sth	r3,32(r2)
   case SO_TCPSACK:
   case SO_NOSLOWSTART:
#ifdef SUPPORT_SO_FULLMSS
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
 3230e6c:	e0bffd17 	ldw	r2,-12(fp)
 3230e70:	10800017 	ldw	r2,0(r2)
 3230e74:	1005003a 	cmpeq	r2,r2,zero
 3230e78:	1000071e 	bne	r2,zero,3230e98 <sosetopt+0x1a8>
         so->so_options |= optname;
 3230e7c:	e0bffb17 	ldw	r2,-20(fp)
 3230e80:	10c00417 	ldw	r3,16(r2)
 3230e84:	e0bffc17 	ldw	r2,-16(fp)
 3230e88:	1886b03a 	or	r3,r3,r2
 3230e8c:	e0bffb17 	ldw	r2,-20(fp)
 3230e90:	10c00415 	stw	r3,16(r2)
 3230e94:	0000c006 	br	3231198 <sosetopt+0x4a8>
      else
         so->so_options &= ~optname;
 3230e98:	e0bffb17 	ldw	r2,-20(fp)
 3230e9c:	10c00417 	ldw	r3,16(r2)
 3230ea0:	e0bffc17 	ldw	r2,-16(fp)
 3230ea4:	0084303a 	nor	r2,zero,r2
 3230ea8:	1886703a 	and	r3,r3,r2
 3230eac:	e0bffb17 	ldw	r2,-20(fp)
 3230eb0:	10c00415 	stw	r3,16(r2)
      break;
 3230eb4:	0000b806 	br	3231198 <sosetopt+0x4a8>
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 3230eb8:	e0bffc17 	ldw	r2,-16(fp)
 3230ebc:	10840058 	cmpnei	r2,r2,4097
 3230ec0:	1000041e 	bne	r2,zero,3230ed4 <sosetopt+0x1e4>
 3230ec4:	e0bffb17 	ldw	r2,-20(fp)
 3230ec8:	10801204 	addi	r2,r2,72
 3230ecc:	e0bffe15 	stw	r2,-8(fp)
 3230ed0:	00000306 	br	3230ee0 <sosetopt+0x1f0>
 3230ed4:	e0bffb17 	ldw	r2,-20(fp)
 3230ed8:	10800a04 	addi	r2,r2,40
 3230edc:	e0bffe15 	stw	r2,-8(fp)
 3230ee0:	e0bffd17 	ldw	r2,-12(fp)
 3230ee4:	10800017 	ldw	r2,0(r2)
 3230ee8:	100b883a 	mov	r5,r2
 3230eec:	e13ffe17 	ldw	r4,-8(fp)
 3230ef0:	32320280 	call	3232028 <sbreserve>
 3230ef4:	1004c03a 	cmpne	r2,r2,zero
 3230ef8:	1000a71e 	bne	r2,zero,3231198 <sosetopt+0x4a8>
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
 3230efc:	00801a44 	movi	r2,105
 3230f00:	e0bffa15 	stw	r2,-24(fp)
         goto bad;
 3230f04:	0000a406 	br	3231198 <sosetopt+0x4a8>
      }
      break;

   case SO_RCVTIMEO:
      so->so_rcv.sb_timeo = *(short *)arg;
 3230f08:	e0bffd17 	ldw	r2,-12(fp)
 3230f0c:	10c0000b 	ldhu	r3,0(r2)
 3230f10:	e0bffb17 	ldw	r2,-20(fp)
 3230f14:	10c0118d 	sth	r3,70(r2)
      break;
 3230f18:	00009f06 	br	3231198 <sosetopt+0x4a8>

   case SO_NBIO:     /* set socket into NON-blocking mode */
      so->so_state |= SS_NBIO;
 3230f1c:	e0bffb17 	ldw	r2,-20(fp)
 3230f20:	1080088b 	ldhu	r2,34(r2)
 3230f24:	10804014 	ori	r2,r2,256
 3230f28:	1007883a 	mov	r3,r2
 3230f2c:	e0bffb17 	ldw	r2,-20(fp)
 3230f30:	10c0088d 	sth	r3,34(r2)
      break;
 3230f34:	00009806 	br	3231198 <sosetopt+0x4a8>

   case SO_BIO:   /* set socket into blocking mode */
      so->so_state &= ~SS_NBIO;
 3230f38:	e0bffb17 	ldw	r2,-20(fp)
 3230f3c:	10c0088b 	ldhu	r3,34(r2)
 3230f40:	00bfbfc4 	movi	r2,-257
 3230f44:	1884703a 	and	r2,r3,r2
 3230f48:	1007883a 	mov	r3,r2
 3230f4c:	e0bffb17 	ldw	r2,-20(fp)
 3230f50:	10c0088d 	sth	r3,34(r2)
      break;
 3230f54:	00009006 	br	3231198 <sosetopt+0x4a8>

   case SO_NONBLOCK:    /* set blocking mode according to arg */
      /* sanity check the arg parameter */
      if (!arg)
 3230f58:	e0bffd17 	ldw	r2,-12(fp)
 3230f5c:	1004c03a 	cmpne	r2,r2,zero
 3230f60:	1000031e 	bne	r2,zero,3230f70 <sosetopt+0x280>
      {
         error = ENP_PARAM;
 3230f64:	00bffd84 	movi	r2,-10
 3230f68:	e0bffa15 	stw	r2,-24(fp)
         break;
 3230f6c:	00008a06 	br	3231198 <sosetopt+0x4a8>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 3230f70:	e0bffd17 	ldw	r2,-12(fp)
 3230f74:	10800017 	ldw	r2,0(r2)
 3230f78:	1005003a 	cmpeq	r2,r2,zero
 3230f7c:	1000071e 	bne	r2,zero,3230f9c <sosetopt+0x2ac>
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
 3230f80:	e0bffb17 	ldw	r2,-20(fp)
 3230f84:	1080088b 	ldhu	r2,34(r2)
 3230f88:	10804014 	ori	r2,r2,256
 3230f8c:	1007883a 	mov	r3,r2
 3230f90:	e0bffb17 	ldw	r2,-20(fp)
 3230f94:	10c0088d 	sth	r3,34(r2)
 3230f98:	00007f06 	br	3231198 <sosetopt+0x4a8>
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
 3230f9c:	e0bffb17 	ldw	r2,-20(fp)
 3230fa0:	10c0088b 	ldhu	r3,34(r2)
 3230fa4:	00bfbfc4 	movi	r2,-257
 3230fa8:	1884703a 	and	r2,r3,r2
 3230fac:	1007883a 	mov	r3,r2
 3230fb0:	e0bffb17 	ldw	r2,-20(fp)
 3230fb4:	10c0088d 	sth	r3,34(r2)
      break;
 3230fb8:	00007706 	br	3231198 <sosetopt+0x4a8>
   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      error = ip_setmoptions(optname, so, arg);
 3230fbc:	e13ffc17 	ldw	r4,-16(fp)
 3230fc0:	e17ffb17 	ldw	r5,-20(fp)
 3230fc4:	e1bffd17 	ldw	r6,-12(fp)
 3230fc8:	3245eac0 	call	3245eac <ip_setmoptions>
 3230fcc:	e0bffa15 	stw	r2,-24(fp)
      break;
 3230fd0:	00007106 	br	3231198 <sosetopt+0x4a8>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 3230fd4:	e0bffd17 	ldw	r2,-12(fp)
 3230fd8:	1004c03a 	cmpne	r2,r2,zero
 3230fdc:	1000031e 	bne	r2,zero,3230fec <sosetopt+0x2fc>
      {
         error = ENP_PARAM;
 3230fe0:	00bffd84 	movi	r2,-10
 3230fe4:	e0bffa15 	stw	r2,-24(fp)
         break;
 3230fe8:	00006b06 	br	3231198 <sosetopt+0x4a8>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
 3230fec:	e0bffd17 	ldw	r2,-12(fp)
 3230ff0:	10800017 	ldw	r2,0(r2)
 3230ff4:	1005003a 	cmpeq	r2,r2,zero
 3230ff8:	1000061e 	bne	r2,zero,3231014 <sosetopt+0x324>
         so->so_options |= SO_HDRINCL;
 3230ffc:	e0bffb17 	ldw	r2,-20(fp)
 3231000:	10800417 	ldw	r2,16(r2)
 3231004:	10c80014 	ori	r3,r2,8192
 3231008:	e0bffb17 	ldw	r2,-20(fp)
 323100c:	10c00415 	stw	r3,16(r2)
 3231010:	00006106 	br	3231198 <sosetopt+0x4a8>
      else
         so->so_options &= ~SO_HDRINCL;
 3231014:	e0bffb17 	ldw	r2,-20(fp)
 3231018:	10c00417 	ldw	r3,16(r2)
 323101c:	00b7ffc4 	movi	r2,-8193
 3231020:	1886703a 	and	r3,r3,r2
 3231024:	e0bffb17 	ldw	r2,-20(fp)
 3231028:	10c00415 	stw	r3,16(r2)
      break;
 323102c:	00005a06 	br	3231198 <sosetopt+0x4a8>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 3231030:	e0bffb17 	ldw	r2,-20(fp)
 3231034:	10800983 	ldbu	r2,38(r2)
 3231038:	10803fcc 	andi	r2,r2,255
 323103c:	1080201c 	xori	r2,r2,128
 3231040:	10bfe004 	addi	r2,r2,-128
 3231044:	10800060 	cmpeqi	r2,r2,1
 3231048:	1000031e 	bne	r2,zero,3231058 <sosetopt+0x368>
      {
         error = EINVAL;
 323104c:	00800584 	movi	r2,22
 3231050:	e0bffa15 	stw	r2,-24(fp)
         break;
 3231054:	00005006 	br	3231198 <sosetopt+0x4a8>
      }
      inp = (struct inpcb *)(so->so_pcb);
 3231058:	e0bffb17 	ldw	r2,-20(fp)
 323105c:	10800117 	ldw	r2,4(r2)
 3231060:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 3231064:	e0bff917 	ldw	r2,-28(fp)
 3231068:	10800917 	ldw	r2,36(r2)
 323106c:	e0bff815 	stw	r2,-32(fp)
      if(!tp)
 3231070:	e0bff817 	ldw	r2,-32(fp)
 3231074:	1004c03a 	cmpne	r2,r2,zero
 3231078:	1000031e 	bne	r2,zero,3231088 <sosetopt+0x398>
      {
         error = ENOTCONN;
 323107c:	00802004 	movi	r2,128
 3231080:	e0bffa15 	stw	r2,-24(fp)
         break;
 3231084:	00004406 	br	3231198 <sosetopt+0x4a8>
      }
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 3231088:	e0bffd17 	ldw	r2,-12(fp)
 323108c:	1004c03a 	cmpne	r2,r2,zero
 3231090:	1000031e 	bne	r2,zero,32310a0 <sosetopt+0x3b0>
      {
         error = ENP_PARAM;
 3231094:	00bffd84 	movi	r2,-10
 3231098:	e0bffa15 	stw	r2,-24(fp)
         break;
 323109c:	00003e06 	br	3231198 <sosetopt+0x4a8>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 32310a0:	e0bffd17 	ldw	r2,-12(fp)
 32310a4:	10800017 	ldw	r2,0(r2)
 32310a8:	1005003a 	cmpeq	r2,r2,zero
 32310ac:	1000071e 	bne	r2,zero,32310cc <sosetopt+0x3dc>
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
 32310b0:	e0bff817 	ldw	r2,-32(fp)
 32310b4:	10800b0b 	ldhu	r2,44(r2)
 32310b8:	10800114 	ori	r2,r2,4
 32310bc:	1007883a 	mov	r3,r2
 32310c0:	e0bff817 	ldw	r2,-32(fp)
 32310c4:	10c00b0d 	sth	r3,44(r2)
 32310c8:	00003306 	br	3231198 <sosetopt+0x4a8>
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */
 32310cc:	e0bff817 	ldw	r2,-32(fp)
 32310d0:	10c00b0b 	ldhu	r3,44(r2)
 32310d4:	00bffec4 	movi	r2,-5
 32310d8:	1884703a 	and	r2,r3,r2
 32310dc:	1007883a 	mov	r3,r2
 32310e0:	e0bff817 	ldw	r2,-32(fp)
 32310e4:	10c00b0d 	sth	r3,44(r2)

      break;
 32310e8:	00002b06 	br	3231198 <sosetopt+0x4a8>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 32310ec:	e0bffb17 	ldw	r2,-20(fp)
 32310f0:	10800983 	ldbu	r2,38(r2)
 32310f4:	10803fcc 	andi	r2,r2,255
 32310f8:	1080201c 	xori	r2,r2,128
 32310fc:	10bfe004 	addi	r2,r2,-128
 3231100:	10800060 	cmpeqi	r2,r2,1
 3231104:	1000031e 	bne	r2,zero,3231114 <sosetopt+0x424>
      {
         error = EINVAL;
 3231108:	00800584 	movi	r2,22
 323110c:	e0bffa15 	stw	r2,-24(fp)
         break;
 3231110:	00002106 	br	3231198 <sosetopt+0x4a8>
      }
      inp = (struct inpcb *)(so->so_pcb);
 3231114:	e0bffb17 	ldw	r2,-20(fp)
 3231118:	10800117 	ldw	r2,4(r2)
 323111c:	e0bff715 	stw	r2,-36(fp)
      tp = intotcpcb(inp);
 3231120:	e0bff717 	ldw	r2,-36(fp)
 3231124:	10800917 	ldw	r2,36(r2)
 3231128:	e0bff615 	stw	r2,-40(fp)
      if(!tp)
 323112c:	e0bff617 	ldw	r2,-40(fp)
 3231130:	1004c03a 	cmpne	r2,r2,zero
 3231134:	1000031e 	bne	r2,zero,3231144 <sosetopt+0x454>
      {
         error = ENOTCONN;
 3231138:	00802004 	movi	r2,128
 323113c:	e0bffa15 	stw	r2,-24(fp)
         break;
 3231140:	00001506 	br	3231198 <sosetopt+0x4a8>
      }
      if (tp->t_state != TCPS_CLOSED)
 3231144:	e0bff617 	ldw	r2,-40(fp)
 3231148:	10800217 	ldw	r2,8(r2)
 323114c:	1005003a 	cmpeq	r2,r2,zero
 3231150:	1000031e 	bne	r2,zero,3231160 <sosetopt+0x470>
      {
         error = EINVAL;
 3231154:	00800584 	movi	r2,22
 3231158:	e0bffa15 	stw	r2,-24(fp)
         break;
 323115c:	00000e06 	br	3231198 <sosetopt+0x4a8>
      }
      tp->t_maxseg = *(int*)(arg);    /* set TCP MSS */
 3231160:	e0bffd17 	ldw	r2,-12(fp)
 3231164:	10800017 	ldw	r2,0(r2)
 3231168:	1007883a 	mov	r3,r2
 323116c:	e0bff617 	ldw	r2,-40(fp)
 3231170:	10c00a0d 	sth	r3,40(r2)
      tp->t_flags |= TF_MAXSEG;   /* mark as user set max seg */
 3231174:	e0bff617 	ldw	r2,-40(fp)
 3231178:	10800b0b 	ldhu	r2,44(r2)
 323117c:	10810014 	ori	r2,r2,1024
 3231180:	1007883a 	mov	r3,r2
 3231184:	e0bff617 	ldw	r2,-40(fp)
 3231188:	10c00b0d 	sth	r3,44(r2)
      break;
 323118c:	00000206 	br	3231198 <sosetopt+0x4a8>
   }
   default:
      error = ENOPROTOOPT;
 3231190:	00801b44 	movi	r2,109
 3231194:	e0bffa15 	stw	r2,-24(fp)
      break;
   }
bad:
   return (error);
 3231198:	e0bffa17 	ldw	r2,-24(fp)
}
 323119c:	e037883a 	mov	sp,fp
 32311a0:	dfc00117 	ldw	ra,4(sp)
 32311a4:	df000017 	ldw	fp,0(sp)
 32311a8:	dec00204 	addi	sp,sp,8
 32311ac:	f800283a 	ret

032311b0 <sogetopt>:

int
sogetopt(struct socket * so, 
   int   optname,
   void *   val)
{
 32311b0:	defff304 	addi	sp,sp,-52
 32311b4:	dfc00c15 	stw	ra,48(sp)
 32311b8:	df000b15 	stw	fp,44(sp)
 32311bc:	df000b04 	addi	fp,sp,44
 32311c0:	e13ffb15 	stw	r4,-20(fp)
 32311c4:	e17ffc15 	stw	r5,-16(fp)
 32311c8:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 32311cc:	e03ffa15 	stw	zero,-24(fp)

   /* sanity check the val parameter */
   if (!val)
 32311d0:	e0bffd17 	ldw	r2,-12(fp)
 32311d4:	1004c03a 	cmpne	r2,r2,zero
 32311d8:	1000031e 	bne	r2,zero,32311e8 <sogetopt+0x38>
   {
      return ENP_PARAM;
 32311dc:	00bffd84 	movi	r2,-10
 32311e0:	e0bffe15 	stw	r2,-8(fp)
 32311e4:	00013c06 	br	32316d8 <sogetopt+0x528>
   }

   switch (optname) 
 32311e8:	e0fffc17 	ldw	r3,-16(fp)
 32311ec:	e0ffff15 	stw	r3,-4(fp)
 32311f0:	e0ffff17 	ldw	r3,-4(fp)
 32311f4:	188400e0 	cmpeqi	r2,r3,4099
 32311f8:	10008f1e 	bne	r2,zero,3231438 <sogetopt+0x288>
 32311fc:	e0ffff17 	ldw	r3,-4(fp)
 3231200:	18840108 	cmpgei	r2,r3,4100
 3231204:	10002e1e 	bne	r2,zero,32312c0 <sogetopt+0x110>
 3231208:	e0ffff17 	ldw	r3,-4(fp)
 323120c:	18800420 	cmpeqi	r2,r3,16
 3231210:	1000821e 	bne	r2,zero,323141c <sogetopt+0x26c>
 3231214:	e0ffff17 	ldw	r3,-4(fp)
 3231218:	18800448 	cmpgei	r2,r3,17
 323121c:	1000111e 	bne	r2,zero,3231264 <sogetopt+0xb4>
 3231220:	e0ffff17 	ldw	r3,-4(fp)
 3231224:	18800220 	cmpeqi	r2,r3,8
 3231228:	10007c1e 	bne	r2,zero,323141c <sogetopt+0x26c>
 323122c:	e0ffff17 	ldw	r3,-4(fp)
 3231230:	18800248 	cmpgei	r2,r3,9
 3231234:	1000071e 	bne	r2,zero,3231254 <sogetopt+0xa4>
 3231238:	e0ffff17 	ldw	r3,-4(fp)
 323123c:	188000a0 	cmpeqi	r2,r3,2
 3231240:	1000eb1e 	bne	r2,zero,32315f0 <sogetopt+0x440>
 3231244:	e0ffff17 	ldw	r3,-4(fp)
 3231248:	18800120 	cmpeqi	r2,r3,4
 323124c:	1000731e 	bne	r2,zero,323141c <sogetopt+0x26c>
 3231250:	00011c06 	br	32316c4 <sogetopt+0x514>
 3231254:	e0ffff17 	ldw	r3,-4(fp)
 3231258:	18800308 	cmpgei	r2,r3,12
 323125c:	1001191e 	bne	r2,zero,32316c4 <sogetopt+0x514>
 3231260:	0000dd06 	br	32315d8 <sogetopt+0x428>
 3231264:	e0ffff17 	ldw	r3,-4(fp)
 3231268:	18804020 	cmpeqi	r2,r3,256
 323126c:	10006b1e 	bne	r2,zero,323141c <sogetopt+0x26c>
 3231270:	e0ffff17 	ldw	r3,-4(fp)
 3231274:	18804048 	cmpgei	r2,r3,257
 3231278:	1000071e 	bne	r2,zero,3231298 <sogetopt+0xe8>
 323127c:	e0ffff17 	ldw	r3,-4(fp)
 3231280:	18800820 	cmpeqi	r2,r3,32
 3231284:	1000651e 	bne	r2,zero,323141c <sogetopt+0x26c>
 3231288:	e0ffff17 	ldw	r3,-4(fp)
 323128c:	18802020 	cmpeqi	r2,r3,128
 3231290:	1000531e 	bne	r2,zero,32313e0 <sogetopt+0x230>
 3231294:	00010b06 	br	32316c4 <sogetopt+0x514>
 3231298:	e0ffff17 	ldw	r3,-4(fp)
 323129c:	18840060 	cmpeqi	r2,r3,4097
 32312a0:	10006f1e 	bne	r2,zero,3231460 <sogetopt+0x2b0>
 32312a4:	e0ffff17 	ldw	r3,-4(fp)
 32312a8:	18840088 	cmpgei	r2,r3,4098
 32312ac:	1000711e 	bne	r2,zero,3231474 <sogetopt+0x2c4>
 32312b0:	e0ffff17 	ldw	r3,-4(fp)
 32312b4:	18808020 	cmpeqi	r2,r3,512
 32312b8:	1000581e 	bne	r2,zero,323141c <sogetopt+0x26c>
 32312bc:	00010106 	br	32316c4 <sogetopt+0x514>
 32312c0:	e0ffff17 	ldw	r3,-4(fp)
 32312c4:	18840420 	cmpeqi	r2,r3,4112
 32312c8:	1000881e 	bne	r2,zero,32314ec <sogetopt+0x33c>
 32312cc:	e0ffff17 	ldw	r3,-4(fp)
 32312d0:	18840448 	cmpgei	r2,r3,4113
 32312d4:	1000171e 	bne	r2,zero,3231334 <sogetopt+0x184>
 32312d8:	e0ffff17 	ldw	r3,-4(fp)
 32312dc:	188401a0 	cmpeqi	r2,r3,4102
 32312e0:	1000a31e 	bne	r2,zero,3231570 <sogetopt+0x3c0>
 32312e4:	e0ffff17 	ldw	r3,-4(fp)
 32312e8:	188401c8 	cmpgei	r2,r3,4103
 32312ec:	1000071e 	bne	r2,zero,323130c <sogetopt+0x15c>
 32312f0:	e0ffff17 	ldw	r3,-4(fp)
 32312f4:	18840120 	cmpeqi	r2,r3,4100
 32312f8:	1000541e 	bne	r2,zero,323144c <sogetopt+0x29c>
 32312fc:	e0ffff17 	ldw	r3,-4(fp)
 3231300:	18840160 	cmpeqi	r2,r3,4101
 3231304:	1000951e 	bne	r2,zero,323155c <sogetopt+0x3ac>
 3231308:	0000ee06 	br	32316c4 <sogetopt+0x514>
 323130c:	e0ffff17 	ldw	r3,-4(fp)
 3231310:	18840220 	cmpeqi	r2,r3,4104
 3231314:	1000661e 	bne	r2,zero,32314b0 <sogetopt+0x300>
 3231318:	e0ffff17 	ldw	r3,-4(fp)
 323131c:	18840210 	cmplti	r2,r3,4104
 3231320:	10006b1e 	bne	r2,zero,32314d0 <sogetopt+0x320>
 3231324:	e0ffff17 	ldw	r3,-4(fp)
 3231328:	18840260 	cmpeqi	r2,r3,4105
 323132c:	1000951e 	bne	r2,zero,3231584 <sogetopt+0x3d4>
 3231330:	0000e406 	br	32316c4 <sogetopt+0x514>
 3231334:	e0ffff17 	ldw	r3,-4(fp)
 3231338:	188404e0 	cmpeqi	r2,r3,4115
 323133c:	1000141e 	bne	r2,zero,3231390 <sogetopt+0x1e0>
 3231340:	e0ffff17 	ldw	r3,-4(fp)
 3231344:	18840508 	cmpgei	r2,r3,4116
 3231348:	1000071e 	bne	r2,zero,3231368 <sogetopt+0x1b8>
 323134c:	e0ffff17 	ldw	r3,-4(fp)
 3231350:	18840460 	cmpeqi	r2,r3,4113
 3231354:	10004c1e 	bne	r2,zero,3231488 <sogetopt+0x2d8>
 3231358:	e0ffff17 	ldw	r3,-4(fp)
 323135c:	188404a0 	cmpeqi	r2,r3,4114
 3231360:	10004e1e 	bne	r2,zero,323149c <sogetopt+0x2ec>
 3231364:	0000d706 	br	32316c4 <sogetopt+0x514>
 3231368:	e0ffff17 	ldw	r3,-4(fp)
 323136c:	188800e0 	cmpeqi	r2,r3,8195
 3231370:	10005e1e 	bne	r2,zero,32314ec <sogetopt+0x33c>
 3231374:	e0ffff17 	ldw	r3,-4(fp)
 3231378:	18880120 	cmpeqi	r2,r3,8196
 323137c:	1000a81e 	bne	r2,zero,3231620 <sogetopt+0x470>
 3231380:	e0ffff17 	ldw	r3,-4(fp)
 3231384:	188405a0 	cmpeqi	r2,r3,4118
 3231388:	1000861e 	bne	r2,zero,32315a4 <sogetopt+0x3f4>
 323138c:	0000cd06 	br	32316c4 <sogetopt+0x514>
   {
   case SO_MYADDR:
      /* Get my IP address. */
      if (so->so_state & SS_ISCONNECTED)
 3231390:	e0bffb17 	ldw	r2,-20(fp)
 3231394:	1080088b 	ldhu	r2,34(r2)
 3231398:	10bfffcc 	andi	r2,r2,65535
 323139c:	1080008c 	andi	r2,r2,2
 32313a0:	1005003a 	cmpeq	r2,r2,zero
 32313a4:	1000071e 	bne	r2,zero,32313c4 <sogetopt+0x214>
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
 32313a8:	e0fffd17 	ldw	r3,-12(fp)
 32313ac:	e0bffb17 	ldw	r2,-20(fp)
 32313b0:	10800117 	ldw	r2,4(r2)
 32313b4:	10800a17 	ldw	r2,40(r2)
 32313b8:	10800a17 	ldw	r2,40(r2)
 32313bc:	18800015 	stw	r2,0(r3)
 32313c0:	0000c306 	br	32316d0 <sogetopt+0x520>
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
 32313c4:	e0fffd17 	ldw	r3,-12(fp)
 32313c8:	0080c9b4 	movhi	r2,806
 32313cc:	10b25a04 	addi	r2,r2,-13976
 32313d0:	10800017 	ldw	r2,0(r2)
 32313d4:	10800a17 	ldw	r2,40(r2)
 32313d8:	18800015 	stw	r2,0(r3)
      break;
 32313dc:	0000bc06 	br	32316d0 <sogetopt+0x520>
   case SO_LINGER:
      {
         struct linger *   l  =  (struct  linger *)val;
 32313e0:	e0bffd17 	ldw	r2,-12(fp)
 32313e4:	e0bff915 	stw	r2,-28(fp)
         l->l_onoff = so->so_options & SO_LINGER;
 32313e8:	e0bffb17 	ldw	r2,-20(fp)
 32313ec:	10800417 	ldw	r2,16(r2)
 32313f0:	10c0200c 	andi	r3,r2,128
 32313f4:	e0bff917 	ldw	r2,-28(fp)
 32313f8:	10c00015 	stw	r3,0(r2)
         l->l_linger = so->so_linger;
 32313fc:	e0bffb17 	ldw	r2,-20(fp)
 3231400:	1080080b 	ldhu	r2,32(r2)
 3231404:	10ffffcc 	andi	r3,r2,65535
 3231408:	18e0001c 	xori	r3,r3,32768
 323140c:	18e00004 	addi	r3,r3,-32768
 3231410:	e0bff917 	ldw	r2,-28(fp)
 3231414:	10c00115 	stw	r3,4(r2)
      }
      break;
 3231418:	0000ad06 	br	32316d0 <sogetopt+0x520>
   case SO_OOBINLINE:
   case SO_DONTROUTE:
   case SO_REUSEADDR:
   case SO_BROADCAST:
   case SO_TCPSACK:
      *(int *)val = so->so_options & optname;
 323141c:	e13ffd17 	ldw	r4,-12(fp)
 3231420:	e0bffb17 	ldw	r2,-20(fp)
 3231424:	10c00417 	ldw	r3,16(r2)
 3231428:	e0bffc17 	ldw	r2,-16(fp)
 323142c:	1884703a 	and	r2,r3,r2
 3231430:	20800015 	stw	r2,0(r4)
      break;
 3231434:	0000a606 	br	32316d0 <sogetopt+0x520>

   case SO_SNDLOWAT:
      *(int *)val = (int)so->so_snd.sb_lowat;
 3231438:	e0fffd17 	ldw	r3,-12(fp)
 323143c:	e0bffb17 	ldw	r2,-20(fp)
 3231440:	10801617 	ldw	r2,88(r2)
 3231444:	18800015 	stw	r2,0(r3)
      break;
 3231448:	0000a106 	br	32316d0 <sogetopt+0x520>

   case SO_RCVLOWAT:
      *(int *)val = (int)so->so_rcv.sb_lowat;
 323144c:	e0fffd17 	ldw	r3,-12(fp)
 3231450:	e0bffb17 	ldw	r2,-20(fp)
 3231454:	10800e17 	ldw	r2,56(r2)
 3231458:	18800015 	stw	r2,0(r3)
      break;
 323145c:	00009c06 	br	32316d0 <sogetopt+0x520>

   case SO_SNDBUF:
      *(int *)val = (int)so->so_snd.sb_hiwat;
 3231460:	e0fffd17 	ldw	r3,-12(fp)
 3231464:	e0bffb17 	ldw	r2,-20(fp)
 3231468:	10801317 	ldw	r2,76(r2)
 323146c:	18800015 	stw	r2,0(r3)
      break;
 3231470:	00009706 	br	32316d0 <sogetopt+0x520>

   case SO_RCVBUF:
      *(int *)val = (int)so->so_rcv.sb_hiwat;
 3231474:	e0fffd17 	ldw	r3,-12(fp)
 3231478:	e0bffb17 	ldw	r2,-20(fp)
 323147c:	10800b17 	ldw	r2,44(r2)
 3231480:	18800015 	stw	r2,0(r3)
      break;
 3231484:	00009206 	br	32316d0 <sogetopt+0x520>

   case SO_RXDATA:   /* added, JB */
      *(int *)val = (int)so->so_rcv.sb_cc;
 3231488:	e0fffd17 	ldw	r3,-12(fp)
 323148c:	e0bffb17 	ldw	r2,-20(fp)
 3231490:	10800a17 	ldw	r2,40(r2)
 3231494:	18800015 	stw	r2,0(r3)
      break;
 3231498:	00008d06 	br	32316d0 <sogetopt+0x520>

   case SO_TXDATA:   /* added for rel 1.8 */
      *(int *)val = (int)so->so_snd.sb_cc;
 323149c:	e0fffd17 	ldw	r3,-12(fp)
 32314a0:	e0bffb17 	ldw	r2,-20(fp)
 32314a4:	10801217 	ldw	r2,72(r2)
 32314a8:	18800015 	stw	r2,0(r3)
      break;
 32314ac:	00008806 	br	32316d0 <sogetopt+0x520>

   case SO_TYPE:
      *(int *)val = so->so_type;
 32314b0:	e0fffd17 	ldw	r3,-12(fp)
 32314b4:	e0bffb17 	ldw	r2,-20(fp)
 32314b8:	10800983 	ldbu	r2,38(r2)
 32314bc:	10803fcc 	andi	r2,r2,255
 32314c0:	1080201c 	xori	r2,r2,128
 32314c4:	10bfe004 	addi	r2,r2,-128
 32314c8:	18800015 	stw	r2,0(r3)
      break;
 32314cc:	00008006 	br	32316d0 <sogetopt+0x520>

   case SO_ERROR:
      *(int *)val = so->so_error;
 32314d0:	e0fffd17 	ldw	r3,-12(fp)
 32314d4:	e0bffb17 	ldw	r2,-20(fp)
 32314d8:	10800617 	ldw	r2,24(r2)
 32314dc:	18800015 	stw	r2,0(r3)
      so->so_error = 0;
 32314e0:	e0bffb17 	ldw	r2,-20(fp)
 32314e4:	10000615 	stw	zero,24(r2)
      break;
 32314e8:	00007906 	br	32316d0 <sogetopt+0x520>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 32314ec:	e0bffb17 	ldw	r2,-20(fp)
 32314f0:	10800983 	ldbu	r2,38(r2)
 32314f4:	10803fcc 	andi	r2,r2,255
 32314f8:	1080201c 	xori	r2,r2,128
 32314fc:	10bfe004 	addi	r2,r2,-128
 3231500:	10800060 	cmpeqi	r2,r2,1
 3231504:	1000031e 	bne	r2,zero,3231514 <sogetopt+0x364>
      {
         error = EINVAL;
 3231508:	00800584 	movi	r2,22
 323150c:	e0bffa15 	stw	r2,-24(fp)
         break;
 3231510:	00006f06 	br	32316d0 <sogetopt+0x520>
      }
      inp = (struct inpcb *)(so->so_pcb);
 3231514:	e0bffb17 	ldw	r2,-20(fp)
 3231518:	10800117 	ldw	r2,4(r2)
 323151c:	e0bff815 	stw	r2,-32(fp)
      tp = intotcpcb(inp);
 3231520:	e0bff817 	ldw	r2,-32(fp)
 3231524:	10800917 	ldw	r2,36(r2)
 3231528:	e0bff715 	stw	r2,-36(fp)
      if(!tp)
 323152c:	e0bff717 	ldw	r2,-36(fp)
 3231530:	1004c03a 	cmpne	r2,r2,zero
 3231534:	1000031e 	bne	r2,zero,3231544 <sogetopt+0x394>
      {
         error = ENOTCONN;
 3231538:	00802004 	movi	r2,128
 323153c:	e0bffa15 	stw	r2,-24(fp)
         break;
 3231540:	00006306 	br	32316d0 <sogetopt+0x520>
      }
      *(int *)val = tp->t_maxseg;     /* Fill in TCP MSS for current socket */
 3231544:	e0fffd17 	ldw	r3,-12(fp)
 3231548:	e0bff717 	ldw	r2,-36(fp)
 323154c:	10800a0b 	ldhu	r2,40(r2)
 3231550:	10bfffcc 	andi	r2,r2,65535
 3231554:	18800015 	stw	r2,0(r3)
      break;
 3231558:	00005d06 	br	32316d0 <sogetopt+0x520>
   }
 
   case SO_SNDTIMEO:
      *(short*)val = so->so_snd.sb_timeo;
 323155c:	e0bffd17 	ldw	r2,-12(fp)
 3231560:	e0fffb17 	ldw	r3,-20(fp)
 3231564:	18c0198b 	ldhu	r3,102(r3)
 3231568:	10c0000d 	sth	r3,0(r2)
      break;
 323156c:	00005806 	br	32316d0 <sogetopt+0x520>

   case SO_RCVTIMEO:
      *(short*)val = so->so_rcv.sb_timeo;
 3231570:	e0bffd17 	ldw	r2,-12(fp)
 3231574:	e0fffb17 	ldw	r3,-20(fp)
 3231578:	18c0118b 	ldhu	r3,70(r3)
 323157c:	10c0000d 	sth	r3,0(r2)
      break;
 3231580:	00005306 	br	32316d0 <sogetopt+0x520>

   case SO_HOPCNT:
      *(int *)val = so->so_hopcnt;
 3231584:	e0fffd17 	ldw	r3,-12(fp)
 3231588:	e0bffb17 	ldw	r2,-20(fp)
 323158c:	108009c3 	ldbu	r2,39(r2)
 3231590:	10803fcc 	andi	r2,r2,255
 3231594:	1080201c 	xori	r2,r2,128
 3231598:	10bfe004 	addi	r2,r2,-128
 323159c:	18800015 	stw	r2,0(r3)
      break;
 32315a0:	00004b06 	br	32316d0 <sogetopt+0x520>

   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
 32315a4:	e0bffb17 	ldw	r2,-20(fp)
 32315a8:	1080088b 	ldhu	r2,34(r2)
 32315ac:	10bfffcc 	andi	r2,r2,65535
 32315b0:	1080400c 	andi	r2,r2,256
 32315b4:	1005003a 	cmpeq	r2,r2,zero
 32315b8:	1000041e 	bne	r2,zero,32315cc <sogetopt+0x41c>
         *(int *)val = 1;   /* return 1 in val */
 32315bc:	e0fffd17 	ldw	r3,-12(fp)
 32315c0:	00800044 	movi	r2,1
 32315c4:	18800015 	stw	r2,0(r3)
 32315c8:	00004106 	br	32316d0 <sogetopt+0x520>
      else
         *(int *)val = 0;     /* return 0 in val */
 32315cc:	e0bffd17 	ldw	r2,-12(fp)
 32315d0:	10000015 	stw	zero,0(r2)
      break;
 32315d4:	00003e06 	br	32316d0 <sogetopt+0x520>
#ifdef IP_MULTICAST

   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      error = ip_getmoptions(optname, so, val);
 32315d8:	e13ffc17 	ldw	r4,-16(fp)
 32315dc:	e17ffb17 	ldw	r5,-20(fp)
 32315e0:	e1bffd17 	ldw	r6,-12(fp)
 32315e4:	324649c0 	call	324649c <ip_getmoptions>
 32315e8:	e0bffa15 	stw	r2,-24(fp)
      break;
 32315ec:	00003806 	br	32316d0 <sogetopt+0x520>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
 32315f0:	e0bffb17 	ldw	r2,-20(fp)
 32315f4:	10800417 	ldw	r2,16(r2)
 32315f8:	1088000c 	andi	r2,r2,8192
 32315fc:	1005003a 	cmpeq	r2,r2,zero
 3231600:	1000041e 	bne	r2,zero,3231614 <sogetopt+0x464>
         *(int *)val = 1;
 3231604:	e0fffd17 	ldw	r3,-12(fp)
 3231608:	00800044 	movi	r2,1
 323160c:	18800015 	stw	r2,0(r3)
 3231610:	00002f06 	br	32316d0 <sogetopt+0x520>
      else
         *(int *)val = 0;
 3231614:	e0bffd17 	ldw	r2,-12(fp)
 3231618:	10000015 	stw	zero,0(r2)
      break;
 323161c:	00002c06 	br	32316d0 <sogetopt+0x520>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 3231620:	e0bffb17 	ldw	r2,-20(fp)
 3231624:	10800983 	ldbu	r2,38(r2)
 3231628:	10803fcc 	andi	r2,r2,255
 323162c:	1080201c 	xori	r2,r2,128
 3231630:	10bfe004 	addi	r2,r2,-128
 3231634:	10800060 	cmpeqi	r2,r2,1
 3231638:	1000031e 	bne	r2,zero,3231648 <sogetopt+0x498>
      {
         error = EINVAL;
 323163c:	00800584 	movi	r2,22
 3231640:	e0bffa15 	stw	r2,-24(fp)
         break;
 3231644:	00002206 	br	32316d0 <sogetopt+0x520>
      }
      inp = (struct inpcb *)(so->so_pcb);
 3231648:	e0bffb17 	ldw	r2,-20(fp)
 323164c:	10800117 	ldw	r2,4(r2)
 3231650:	e0bff615 	stw	r2,-40(fp)
      tp = intotcpcb(inp);
 3231654:	e0bff617 	ldw	r2,-40(fp)
 3231658:	10800917 	ldw	r2,36(r2)
 323165c:	e0bff515 	stw	r2,-44(fp)
      if (!tp)
 3231660:	e0bff517 	ldw	r2,-44(fp)
 3231664:	1004c03a 	cmpne	r2,r2,zero
 3231668:	1000031e 	bne	r2,zero,3231678 <sogetopt+0x4c8>
      {
         error = ENOTCONN;
 323166c:	00802004 	movi	r2,128
 3231670:	e0bffa15 	stw	r2,-24(fp)
         break;
 3231674:	00001606 	br	32316d0 <sogetopt+0x520>
      }
      /* try to make sure that the argument pointer is valid */
      if (val == NULL)
 3231678:	e0bffd17 	ldw	r2,-12(fp)
 323167c:	1004c03a 	cmpne	r2,r2,zero
 3231680:	1000031e 	bne	r2,zero,3231690 <sogetopt+0x4e0>
      {
         error = ENP_PARAM;
 3231684:	00bffd84 	movi	r2,-10
 3231688:	e0bffa15 	stw	r2,-24(fp)
         break;
 323168c:	00001006 	br	32316d0 <sogetopt+0x520>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
 3231690:	e0bff517 	ldw	r2,-44(fp)
 3231694:	10800b0b 	ldhu	r2,44(r2)
 3231698:	10bfffcc 	andi	r2,r2,65535
 323169c:	1080010c 	andi	r2,r2,4
 32316a0:	1005003a 	cmpeq	r2,r2,zero
 32316a4:	1000041e 	bne	r2,zero,32316b8 <sogetopt+0x508>
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
 32316a8:	e0fffd17 	ldw	r3,-12(fp)
 32316ac:	00800044 	movi	r2,1
 32316b0:	18800015 	stw	r2,0(r3)
 32316b4:	00000606 	br	32316d0 <sogetopt+0x520>
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */
 32316b8:	e0bffd17 	ldw	r2,-12(fp)
 32316bc:	10000015 	stw	zero,0(r2)

      break;
 32316c0:	00000306 	br	32316d0 <sogetopt+0x520>
   }

   default:
      return ENOPROTOOPT;
 32316c4:	00801b44 	movi	r2,109
 32316c8:	e0bffe15 	stw	r2,-8(fp)
 32316cc:	00000206 	br	32316d8 <sogetopt+0x528>
   }
   return error;     /* no error */
 32316d0:	e0fffa17 	ldw	r3,-24(fp)
 32316d4:	e0fffe15 	stw	r3,-8(fp)
 32316d8:	e0bffe17 	ldw	r2,-8(fp)
}
 32316dc:	e037883a 	mov	sp,fp
 32316e0:	dfc00117 	ldw	ra,4(sp)
 32316e4:	df000017 	ldw	fp,0(sp)
 32316e8:	dec00204 	addi	sp,sp,8
 32316ec:	f800283a 	ret

032316f0 <sohasoutofband>:
 * RETURNS: 
 */

void
sohasoutofband(struct socket * so)
{
 32316f0:	defffd04 	addi	sp,sp,-12
 32316f4:	dfc00215 	stw	ra,8(sp)
 32316f8:	df000115 	stw	fp,4(sp)
 32316fc:	df000104 	addi	fp,sp,4
 3231700:	e13fff15 	stw	r4,-4(fp)
   so->so_error = EHAVEOOB;   /* WILL be picked up by the socket */
 3231704:	e0ffff17 	ldw	r3,-4(fp)
 3231708:	00803644 	movi	r2,217
 323170c:	18800615 	stw	r2,24(r3)
   sorwakeup (so);
 3231710:	e0bfff17 	ldw	r2,-4(fp)
 3231714:	11400a04 	addi	r5,r2,40
 3231718:	e13fff17 	ldw	r4,-4(fp)
 323171c:	3231f0c0 	call	3231f0c <sbwakeup>
}
 3231720:	e037883a 	mov	sp,fp
 3231724:	dfc00117 	ldw	ra,4(sp)
 3231728:	df000017 	ldw	fp,0(sp)
 323172c:	dec00204 	addi	sp,sp,8
 3231730:	f800283a 	ret

03231734 <soisconnecting>:
 * RETURNS: 
 */

void
soisconnecting(struct socket * so)
{
 3231734:	defffd04 	addi	sp,sp,-12
 3231738:	dfc00215 	stw	ra,8(sp)
 323173c:	df000115 	stw	fp,4(sp)
 3231740:	df000104 	addi	fp,sp,4
 3231744:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~(SS_ISCONNECTED|SS_ISDISCONNECTING);
 3231748:	e0bfff17 	ldw	r2,-4(fp)
 323174c:	10c0088b 	ldhu	r3,34(r2)
 3231750:	00bffd44 	movi	r2,-11
 3231754:	1884703a 	and	r2,r3,r2
 3231758:	1007883a 	mov	r3,r2
 323175c:	e0bfff17 	ldw	r2,-4(fp)
 3231760:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTING;
 3231764:	e0bfff17 	ldw	r2,-4(fp)
 3231768:	1080088b 	ldhu	r2,34(r2)
 323176c:	10800114 	ori	r2,r2,4
 3231770:	1007883a 	mov	r3,r2
 3231774:	e0bfff17 	ldw	r2,-4(fp)
 3231778:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 323177c:	e0bfff17 	ldw	r2,-4(fp)
 3231780:	10800904 	addi	r2,r2,36
 3231784:	1009883a 	mov	r4,r2
 3231788:	32269000 	call	3226900 <tcp_wakeup>
}
 323178c:	e037883a 	mov	sp,fp
 3231790:	dfc00117 	ldw	ra,4(sp)
 3231794:	df000017 	ldw	fp,0(sp)
 3231798:	dec00204 	addi	sp,sp,8
 323179c:	f800283a 	ret

032317a0 <soisconnected>:
 * RETURNS: 
 */

void
soisconnected(struct socket * so)
{
 32317a0:	defffc04 	addi	sp,sp,-16
 32317a4:	dfc00315 	stw	ra,12(sp)
 32317a8:	df000215 	stw	fp,8(sp)
 32317ac:	df000204 	addi	fp,sp,8
 32317b0:	e13fff15 	stw	r4,-4(fp)
   struct socket *   head  =  so->so_head;
 32317b4:	e0bfff17 	ldw	r2,-4(fp)
 32317b8:	10801b17 	ldw	r2,108(r2)
 32317bc:	e0bffe15 	stw	r2,-8(fp)

   if (head) 
 32317c0:	e0bffe17 	ldw	r2,-8(fp)
 32317c4:	1005003a 	cmpeq	r2,r2,zero
 32317c8:	1000141e 	bne	r2,zero,323181c <soisconnected+0x7c>
   {
      if (soqremque(so, 0) == 0)
 32317cc:	e13fff17 	ldw	r4,-4(fp)
 32317d0:	000b883a 	mov	r5,zero
 32317d4:	3231cac0 	call	3231cac <soqremque>
 32317d8:	1004c03a 	cmpne	r2,r2,zero
 32317dc:	1000031e 	bne	r2,zero,32317ec <soisconnected+0x4c>
         panic("soisconnected");
 32317e0:	0100c974 	movhi	r4,805
 32317e4:	213d5a04 	addi	r4,r4,-2712
 32317e8:	3225df00 	call	3225df0 <panic>
      soqinsque(head, so, 1);
 32317ec:	e13ffe17 	ldw	r4,-8(fp)
 32317f0:	e17fff17 	ldw	r5,-4(fp)
 32317f4:	01800044 	movi	r6,1
 32317f8:	3231c000 	call	3231c00 <soqinsque>
      sorwakeup(head);
 32317fc:	e0bffe17 	ldw	r2,-8(fp)
 3231800:	11400a04 	addi	r5,r2,40
 3231804:	e13ffe17 	ldw	r4,-8(fp)
 3231808:	3231f0c0 	call	3231f0c <sbwakeup>
      tcp_wakeup ((char *)&head->so_timeo);
 323180c:	e0bffe17 	ldw	r2,-8(fp)
 3231810:	10800904 	addi	r2,r2,36
 3231814:	1009883a 	mov	r4,r2
 3231818:	32269000 	call	3226900 <tcp_wakeup>
   }

   so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 323181c:	e0bfff17 	ldw	r2,-4(fp)
 3231820:	10c0088b 	ldhu	r3,34(r2)
 3231824:	00bffcc4 	movi	r2,-13
 3231828:	1884703a 	and	r2,r3,r2
 323182c:	1007883a 	mov	r3,r2
 3231830:	e0bfff17 	ldw	r2,-4(fp)
 3231834:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTED;
 3231838:	e0bfff17 	ldw	r2,-4(fp)
 323183c:	1080088b 	ldhu	r2,34(r2)
 3231840:	10800094 	ori	r2,r2,2
 3231844:	1007883a 	mov	r3,r2
 3231848:	e0bfff17 	ldw	r2,-4(fp)
 323184c:	10c0088d 	sth	r3,34(r2)
   so->so_error = 0;
 3231850:	e0bfff17 	ldw	r2,-4(fp)
 3231854:	10000615 	stw	zero,24(r2)
   tcp_wakeup  ((char *)&so->so_timeo);
 3231858:	e0bfff17 	ldw	r2,-4(fp)
 323185c:	10800904 	addi	r2,r2,36
 3231860:	1009883a 	mov	r4,r2
 3231864:	32269000 	call	3226900 <tcp_wakeup>
   sorwakeup (so);
 3231868:	e0bfff17 	ldw	r2,-4(fp)
 323186c:	11400a04 	addi	r5,r2,40
 3231870:	e13fff17 	ldw	r4,-4(fp)
 3231874:	3231f0c0 	call	3231f0c <sbwakeup>
   sowwakeup (so);
 3231878:	e0bfff17 	ldw	r2,-4(fp)
 323187c:	11401204 	addi	r5,r2,72
 3231880:	e13fff17 	ldw	r4,-4(fp)
 3231884:	3231f0c0 	call	3231f0c <sbwakeup>
}
 3231888:	e037883a 	mov	sp,fp
 323188c:	dfc00117 	ldw	ra,4(sp)
 3231890:	df000017 	ldw	fp,0(sp)
 3231894:	dec00204 	addi	sp,sp,8
 3231898:	f800283a 	ret

0323189c <soisdisconnecting>:
 * RETURNS: 
 */

void
soisdisconnecting(struct socket * so)
{
 323189c:	defffd04 	addi	sp,sp,-12
 32318a0:	dfc00215 	stw	ra,8(sp)
 32318a4:	df000115 	stw	fp,4(sp)
 32318a8:	df000104 	addi	fp,sp,4
 32318ac:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~SS_ISCONNECTING;
 32318b0:	e0bfff17 	ldw	r2,-4(fp)
 32318b4:	10c0088b 	ldhu	r3,34(r2)
 32318b8:	00bffec4 	movi	r2,-5
 32318bc:	1884703a 	and	r2,r3,r2
 32318c0:	1007883a 	mov	r3,r2
 32318c4:	e0bfff17 	ldw	r2,-4(fp)
 32318c8:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_ISDISCONNECTING|SS_CANTRCVMORE|SS_CANTSENDMORE);
 32318cc:	e0bfff17 	ldw	r2,-4(fp)
 32318d0:	1080088b 	ldhu	r2,34(r2)
 32318d4:	10800e14 	ori	r2,r2,56
 32318d8:	1007883a 	mov	r3,r2
 32318dc:	e0bfff17 	ldw	r2,-4(fp)
 32318e0:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup  ((char *)&so->so_timeo);   
 32318e4:	e0bfff17 	ldw	r2,-4(fp)
 32318e8:	10800904 	addi	r2,r2,36
 32318ec:	1009883a 	mov	r4,r2
 32318f0:	32269000 	call	3226900 <tcp_wakeup>
   sowwakeup (so);
 32318f4:	e0bfff17 	ldw	r2,-4(fp)
 32318f8:	11401204 	addi	r5,r2,72
 32318fc:	e13fff17 	ldw	r4,-4(fp)
 3231900:	3231f0c0 	call	3231f0c <sbwakeup>
   sorwakeup (so);
 3231904:	e0bfff17 	ldw	r2,-4(fp)
 3231908:	11400a04 	addi	r5,r2,40
 323190c:	e13fff17 	ldw	r4,-4(fp)
 3231910:	3231f0c0 	call	3231f0c <sbwakeup>
}
 3231914:	e037883a 	mov	sp,fp
 3231918:	dfc00117 	ldw	ra,4(sp)
 323191c:	df000017 	ldw	fp,0(sp)
 3231920:	dec00204 	addi	sp,sp,8
 3231924:	f800283a 	ret

03231928 <soisdisconnected>:
 * RETURNS: 
 */

void
soisdisconnected(struct socket * so)
{
 3231928:	defffd04 	addi	sp,sp,-12
 323192c:	dfc00215 	stw	ra,8(sp)
 3231930:	df000115 	stw	fp,4(sp)
 3231934:	df000104 	addi	fp,sp,4
 3231938:	e13fff15 	stw	r4,-4(fp)
   if (so->so_state & SS_ISCONNECTING)
 323193c:	e0bfff17 	ldw	r2,-4(fp)
 3231940:	1080088b 	ldhu	r2,34(r2)
 3231944:	10bfffcc 	andi	r2,r2,65535
 3231948:	1080010c 	andi	r2,r2,4
 323194c:	1005003a 	cmpeq	r2,r2,zero
 3231950:	1000061e 	bne	r2,zero,323196c <soisdisconnected+0x44>
      so->so_state |= SS_WASCONNECTING;
 3231954:	e0bfff17 	ldw	r2,-4(fp)
 3231958:	1080088b 	ldhu	r2,34(r2)
 323195c:	10880014 	ori	r2,r2,8192
 3231960:	1007883a 	mov	r3,r2
 3231964:	e0bfff17 	ldw	r2,-4(fp)
 3231968:	10c0088d 	sth	r3,34(r2)
   so->so_state &= ~(SS_ISCONNECTING|SS_ISCONNECTED|SS_ISDISCONNECTING);
 323196c:	e0bfff17 	ldw	r2,-4(fp)
 3231970:	10c0088b 	ldhu	r3,34(r2)
 3231974:	00bffc44 	movi	r2,-15
 3231978:	1884703a 	and	r2,r3,r2
 323197c:	1007883a 	mov	r3,r2
 3231980:	e0bfff17 	ldw	r2,-4(fp)
 3231984:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_CANTRCVMORE|SS_CANTSENDMORE);
 3231988:	e0bfff17 	ldw	r2,-4(fp)
 323198c:	1080088b 	ldhu	r2,34(r2)
 3231990:	10800c14 	ori	r2,r2,48
 3231994:	1007883a 	mov	r3,r2
 3231998:	e0bfff17 	ldw	r2,-4(fp)
 323199c:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 32319a0:	e0bfff17 	ldw	r2,-4(fp)
 32319a4:	10800904 	addi	r2,r2,36
 32319a8:	1009883a 	mov	r4,r2
 32319ac:	32269000 	call	3226900 <tcp_wakeup>
   sowwakeup (so);
 32319b0:	e0bfff17 	ldw	r2,-4(fp)
 32319b4:	11401204 	addi	r5,r2,72
 32319b8:	e13fff17 	ldw	r4,-4(fp)
 32319bc:	3231f0c0 	call	3231f0c <sbwakeup>
   sorwakeup (so);
 32319c0:	e0bfff17 	ldw	r2,-4(fp)
 32319c4:	11400a04 	addi	r5,r2,40
 32319c8:	e13fff17 	ldw	r4,-4(fp)
 32319cc:	3231f0c0 	call	3231f0c <sbwakeup>
}
 32319d0:	e037883a 	mov	sp,fp
 32319d4:	dfc00117 	ldw	ra,4(sp)
 32319d8:	df000017 	ldw	fp,0(sp)
 32319dc:	dec00204 	addi	sp,sp,8
 32319e0:	f800283a 	ret

032319e4 <sonewconn>:
 * RETURNS: 
 */

struct socket *   
sonewconn(struct socket * head)
{
 32319e4:	defffa04 	addi	sp,sp,-24
 32319e8:	dfc00515 	stw	ra,20(sp)
 32319ec:	df000415 	stw	fp,16(sp)
 32319f0:	df000404 	addi	fp,sp,16
 32319f4:	e13ffe15 	stw	r4,-8(fp)
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
 32319f8:	e0bffe17 	ldw	r2,-8(fp)
 32319fc:	10801e43 	ldbu	r2,121(r2)
 3231a00:	10c03fcc 	andi	r3,r2,255
 3231a04:	18c0201c 	xori	r3,r3,128
 3231a08:	18ffe004 	addi	r3,r3,-128
 3231a0c:	e0bffe17 	ldw	r2,-8(fp)
 3231a10:	10801e03 	ldbu	r2,120(r2)
 3231a14:	10803fcc 	andi	r2,r2,255
 3231a18:	1080201c 	xori	r2,r2,128
 3231a1c:	10bfe004 	addi	r2,r2,-128
 3231a20:	1889883a 	add	r4,r3,r2
 3231a24:	e0bffe17 	ldw	r2,-8(fp)
 3231a28:	10801e83 	ldbu	r2,122(r2)
 3231a2c:	10c03fcc 	andi	r3,r2,255
 3231a30:	18c0201c 	xori	r3,r3,128
 3231a34:	18ffe004 	addi	r3,r3,-128
 3231a38:	1805883a 	mov	r2,r3
 3231a3c:	1085883a 	add	r2,r2,r2
 3231a40:	10c7883a 	add	r3,r2,r3
 3231a44:	1804d7fa 	srli	r2,r3,31
 3231a48:	10c5883a 	add	r2,r2,r3
 3231a4c:	1005d07a 	srai	r2,r2,1
 3231a50:	11006416 	blt	r2,r4,3231be4 <sonewconn+0x200>
      goto bad;
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 3231a54:	01002104 	movi	r4,132
 3231a58:	322b5d00 	call	322b5d0 <npalloc>
 3231a5c:	e0bffd15 	stw	r2,-12(fp)
 3231a60:	e0bffd17 	ldw	r2,-12(fp)
 3231a64:	1005003a 	cmpeq	r2,r2,zero
 3231a68:	10005e1e 	bne	r2,zero,3231be4 <sonewconn+0x200>
      goto bad;
   so->next = NULL;
 3231a6c:	e0bffd17 	ldw	r2,-12(fp)
 3231a70:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);      /* Place newly created socket in a queue */
 3231a74:	e17ffd17 	ldw	r5,-12(fp)
 3231a78:	0100c9b4 	movhi	r4,806
 3231a7c:	21339704 	addi	r4,r4,-12708
 3231a80:	322a51c0 	call	322a51c <putq>
   so->so_type = head->so_type;
 3231a84:	e0bffe17 	ldw	r2,-8(fp)
 3231a88:	10c00983 	ldbu	r3,38(r2)
 3231a8c:	e0bffd17 	ldw	r2,-12(fp)
 3231a90:	10c00985 	stb	r3,38(r2)
   so->so_options = head->so_options &~ (unshort)SO_ACCEPTCONN;
 3231a94:	e0bffe17 	ldw	r2,-8(fp)
 3231a98:	10c00417 	ldw	r3,16(r2)
 3231a9c:	00bfff44 	movi	r2,-3
 3231aa0:	1886703a 	and	r3,r3,r2
 3231aa4:	e0bffd17 	ldw	r2,-12(fp)
 3231aa8:	10c00415 	stw	r3,16(r2)
   so->so_linger = head->so_linger;
 3231aac:	e0bffe17 	ldw	r2,-8(fp)
 3231ab0:	10c0080b 	ldhu	r3,32(r2)
 3231ab4:	e0bffd17 	ldw	r2,-12(fp)
 3231ab8:	10c0080d 	sth	r3,32(r2)
   so->so_state = head->so_state | (unshort)SS_NOFDREF;
 3231abc:	e0bffe17 	ldw	r2,-8(fp)
 3231ac0:	1080088b 	ldhu	r2,34(r2)
 3231ac4:	10800054 	ori	r2,r2,1
 3231ac8:	1007883a 	mov	r3,r2
 3231acc:	e0bffd17 	ldw	r2,-12(fp)
 3231ad0:	10c0088d 	sth	r3,34(r2)
   so->so_proto = head->so_proto;
 3231ad4:	e0bffe17 	ldw	r2,-8(fp)
 3231ad8:	10c00217 	ldw	r3,8(r2)
 3231adc:	e0bffd17 	ldw	r2,-12(fp)
 3231ae0:	10c00215 	stw	r3,8(r2)
   so->so_timeo = head->so_timeo;
 3231ae4:	e0bffe17 	ldw	r2,-8(fp)
 3231ae8:	10c0090b 	ldhu	r3,36(r2)
 3231aec:	e0bffd17 	ldw	r2,-12(fp)
 3231af0:	10c0090d 	sth	r3,36(r2)
   so->so_rcv.sb_hiwat = (u_int)tcp_recvspace;
 3231af4:	0080c974 	movhi	r2,805
 3231af8:	1089b404 	addi	r2,r2,9936
 3231afc:	10c00017 	ldw	r3,0(r2)
 3231b00:	e0bffd17 	ldw	r2,-12(fp)
 3231b04:	10c00b15 	stw	r3,44(r2)
   so->so_snd.sb_hiwat = (u_int)tcp_sendspace;
 3231b08:	0080c974 	movhi	r2,805
 3231b0c:	1089b304 	addi	r2,r2,9932
 3231b10:	10c00017 	ldw	r3,0(r2)
 3231b14:	e0bffd17 	ldw	r2,-12(fp)
 3231b18:	10c01315 	stw	r3,76(r2)
   soqinsque (head, so, 0);
 3231b1c:	e13ffe17 	ldw	r4,-8(fp)
 3231b20:	e17ffd17 	ldw	r5,-12(fp)
 3231b24:	000d883a 	mov	r6,zero
 3231b28:	3231c000 	call	3231c00 <soqinsque>
   so->so_req = PRU_ATTACH;
 3231b2c:	e0bffd17 	ldw	r2,-12(fp)
 3231b30:	10000715 	stw	zero,28(r2)
   so->so_domain = head->so_domain;
 3231b34:	e0bffe17 	ldw	r2,-8(fp)
 3231b38:	10c00517 	ldw	r3,20(r2)
 3231b3c:	e0bffd17 	ldw	r2,-12(fp)
 3231b40:	10c00515 	stw	r3,20(r2)

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
 3231b44:	e0bffd17 	ldw	r2,-12(fp)
 3231b48:	10800217 	ldw	r2,8(r2)
 3231b4c:	10800317 	ldw	r2,12(r2)
 3231b50:	e13ffd17 	ldw	r4,-12(fp)
 3231b54:	000b883a 	mov	r5,zero
 3231b58:	000d883a 	mov	r6,zero
 3231b5c:	103ee83a 	callr	r2
 3231b60:	1004c03a 	cmpne	r2,r2,zero
 3231b64:	1000161e 	bne	r2,zero,3231bc0 <sonewconn+0x1dc>
      goto bad2;
   if (so_evtmap)
 3231b68:	0080c974 	movhi	r2,805
 3231b6c:	10927c04 	addi	r2,r2,18928
 3231b70:	10800003 	ldbu	r2,0(r2)
 3231b74:	10803fcc 	andi	r2,r2,255
 3231b78:	1005003a 	cmpeq	r2,r2,zero
 3231b7c:	10000d1e 	bne	r2,zero,3231bb4 <sonewconn+0x1d0>
   {
      rc = (*so_evtmap_create) (so);                       
 3231b80:	0080c974 	movhi	r2,805
 3231b84:	10927a04 	addi	r2,r2,18920
 3231b88:	10800017 	ldw	r2,0(r2)
 3231b8c:	e13ffd17 	ldw	r4,-12(fp)
 3231b90:	103ee83a 	callr	r2
 3231b94:	e0bffc15 	stw	r2,-16(fp)
      if (rc != 0) goto bad2;
 3231b98:	e0bffc17 	ldw	r2,-16(fp)
 3231b9c:	1004c03a 	cmpne	r2,r2,zero
 3231ba0:	1000071e 	bne	r2,zero,3231bc0 <sonewconn+0x1dc>
      so->owner = head->owner;
 3231ba4:	e0bffe17 	ldw	r2,-8(fp)
 3231ba8:	10c02003 	ldbu	r3,128(r2)
 3231bac:	e0bffd17 	ldw	r2,-12(fp)
 3231bb0:	10c02005 	stb	r3,128(r2)
   }
   return (so);
 3231bb4:	e0bffd17 	ldw	r2,-12(fp)
 3231bb8:	e0bfff15 	stw	r2,-4(fp)
 3231bbc:	00000a06 	br	3231be8 <sonewconn+0x204>
   
bad2:
   (void) soqremque (so, 0);
 3231bc0:	e13ffd17 	ldw	r4,-12(fp)
 3231bc4:	000b883a 	mov	r5,zero
 3231bc8:	3231cac0 	call	3231cac <soqremque>
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 3231bcc:	0100c9b4 	movhi	r4,806
 3231bd0:	21339704 	addi	r4,r4,-12708
 3231bd4:	e17ffd17 	ldw	r5,-12(fp)
 3231bd8:	322a5cc0 	call	322a5cc <qdel>
   SOC_FREE(so);  /* Free the socket structure */
 3231bdc:	e13ffd17 	ldw	r4,-12(fp)
 3231be0:	322b6c40 	call	322b6c4 <npfree>
bad:
   return ((struct socket *)0);
 3231be4:	e03fff15 	stw	zero,-4(fp)
 3231be8:	e0bfff17 	ldw	r2,-4(fp)
}
 3231bec:	e037883a 	mov	sp,fp
 3231bf0:	dfc00117 	ldw	ra,4(sp)
 3231bf4:	df000017 	ldw	fp,0(sp)
 3231bf8:	dec00204 	addi	sp,sp,8
 3231bfc:	f800283a 	ret

03231c00 <soqinsque>:

void
soqinsque(struct socket * head, 
   struct socket *   so,
   int   q)
{
 3231c00:	defffc04 	addi	sp,sp,-16
 3231c04:	df000315 	stw	fp,12(sp)
 3231c08:	df000304 	addi	fp,sp,12
 3231c0c:	e13ffd15 	stw	r4,-12(fp)
 3231c10:	e17ffe15 	stw	r5,-8(fp)
 3231c14:	e1bfff15 	stw	r6,-4(fp)
   so->so_head = head;
 3231c18:	e0fffe17 	ldw	r3,-8(fp)
 3231c1c:	e0bffd17 	ldw	r2,-12(fp)
 3231c20:	18801b15 	stw	r2,108(r3)
   if (q == 0) 
 3231c24:	e0bfff17 	ldw	r2,-4(fp)
 3231c28:	1004c03a 	cmpne	r2,r2,zero
 3231c2c:	10000e1e 	bne	r2,zero,3231c68 <soqinsque+0x68>
   {
      head->so_q0len++;
 3231c30:	e0bffd17 	ldw	r2,-12(fp)
 3231c34:	10801e03 	ldbu	r2,120(r2)
 3231c38:	10800044 	addi	r2,r2,1
 3231c3c:	1007883a 	mov	r3,r2
 3231c40:	e0bffd17 	ldw	r2,-12(fp)
 3231c44:	10c01e05 	stb	r3,120(r2)
      so->so_q0 = head->so_q0;
 3231c48:	e0bffd17 	ldw	r2,-12(fp)
 3231c4c:	10c01c17 	ldw	r3,112(r2)
 3231c50:	e0bffe17 	ldw	r2,-8(fp)
 3231c54:	10c01c15 	stw	r3,112(r2)
      head->so_q0 = so;
 3231c58:	e0fffd17 	ldw	r3,-12(fp)
 3231c5c:	e0bffe17 	ldw	r2,-8(fp)
 3231c60:	18801c15 	stw	r2,112(r3)
 3231c64:	00000d06 	br	3231c9c <soqinsque+0x9c>
   } else 
   {
      head->so_qlen++;
 3231c68:	e0bffd17 	ldw	r2,-12(fp)
 3231c6c:	10801e43 	ldbu	r2,121(r2)
 3231c70:	10800044 	addi	r2,r2,1
 3231c74:	1007883a 	mov	r3,r2
 3231c78:	e0bffd17 	ldw	r2,-12(fp)
 3231c7c:	10c01e45 	stb	r3,121(r2)
      so->so_q = head->so_q;
 3231c80:	e0bffd17 	ldw	r2,-12(fp)
 3231c84:	10c01d17 	ldw	r3,116(r2)
 3231c88:	e0bffe17 	ldw	r2,-8(fp)
 3231c8c:	10c01d15 	stw	r3,116(r2)
      head->so_q = so;
 3231c90:	e0fffd17 	ldw	r3,-12(fp)
 3231c94:	e0bffe17 	ldw	r2,-8(fp)
 3231c98:	18801d15 	stw	r2,116(r3)
   }
}
 3231c9c:	e037883a 	mov	sp,fp
 3231ca0:	df000017 	ldw	fp,0(sp)
 3231ca4:	dec00104 	addi	sp,sp,4
 3231ca8:	f800283a 	ret

03231cac <soqremque>:
 * RETURNS: 
 */

int
soqremque(struct socket * so, int q)
{
 3231cac:	defff804 	addi	sp,sp,-32
 3231cb0:	df000715 	stw	fp,28(sp)
 3231cb4:	df000704 	addi	fp,sp,28
 3231cb8:	e13ffc15 	stw	r4,-16(fp)
 3231cbc:	e17ffd15 	stw	r5,-12(fp)
   struct socket *   head, *  prev, *  next;

   head = so->so_head;
 3231cc0:	e0bffc17 	ldw	r2,-16(fp)
 3231cc4:	10801b17 	ldw	r2,108(r2)
 3231cc8:	e0bffb15 	stw	r2,-20(fp)
   prev = head;
 3231ccc:	e0bffb17 	ldw	r2,-20(fp)
 3231cd0:	e0bffa15 	stw	r2,-24(fp)
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
 3231cd4:	e0bffd17 	ldw	r2,-12(fp)
 3231cd8:	1005003a 	cmpeq	r2,r2,zero
 3231cdc:	1000041e 	bne	r2,zero,3231cf0 <soqremque+0x44>
 3231ce0:	e0bffa17 	ldw	r2,-24(fp)
 3231ce4:	10801d17 	ldw	r2,116(r2)
 3231ce8:	e0bfff15 	stw	r2,-4(fp)
 3231cec:	00000306 	br	3231cfc <soqremque+0x50>
 3231cf0:	e0bffa17 	ldw	r2,-24(fp)
 3231cf4:	10801c17 	ldw	r2,112(r2)
 3231cf8:	e0bfff15 	stw	r2,-4(fp)
 3231cfc:	e0bfff17 	ldw	r2,-4(fp)
 3231d00:	e0bff915 	stw	r2,-28(fp)
      if (next == so)
 3231d04:	e0fff917 	ldw	r3,-28(fp)
 3231d08:	e0bffc17 	ldw	r2,-16(fp)
 3231d0c:	18800826 	beq	r3,r2,3231d30 <soqremque+0x84>
         break;
      if (next == head)
 3231d10:	e0fff917 	ldw	r3,-28(fp)
 3231d14:	e0bffb17 	ldw	r2,-20(fp)
 3231d18:	1880021e 	bne	r3,r2,3231d24 <soqremque+0x78>
         return (0);
 3231d1c:	e03ffe15 	stw	zero,-8(fp)
 3231d20:	00002506 	br	3231db8 <soqremque+0x10c>
      prev = next;
 3231d24:	e0bff917 	ldw	r2,-28(fp)
 3231d28:	e0bffa15 	stw	r2,-24(fp)
   }
 3231d2c:	003fe906 	br	3231cd4 <soqremque+0x28>
   if (q == 0) 
 3231d30:	e0bffd17 	ldw	r2,-12(fp)
 3231d34:	1004c03a 	cmpne	r2,r2,zero
 3231d38:	10000b1e 	bne	r2,zero,3231d68 <soqremque+0xbc>
   {
      prev->so_q0 = next->so_q0;
 3231d3c:	e0bff917 	ldw	r2,-28(fp)
 3231d40:	10c01c17 	ldw	r3,112(r2)
 3231d44:	e0bffa17 	ldw	r2,-24(fp)
 3231d48:	10c01c15 	stw	r3,112(r2)
      head->so_q0len--;
 3231d4c:	e0bffb17 	ldw	r2,-20(fp)
 3231d50:	10801e03 	ldbu	r2,120(r2)
 3231d54:	10bfffc4 	addi	r2,r2,-1
 3231d58:	1007883a 	mov	r3,r2
 3231d5c:	e0bffb17 	ldw	r2,-20(fp)
 3231d60:	10c01e05 	stb	r3,120(r2)
 3231d64:	00000a06 	br	3231d90 <soqremque+0xe4>
   } else 
   {
      prev->so_q = next->so_q;
 3231d68:	e0bff917 	ldw	r2,-28(fp)
 3231d6c:	10c01d17 	ldw	r3,116(r2)
 3231d70:	e0bffa17 	ldw	r2,-24(fp)
 3231d74:	10c01d15 	stw	r3,116(r2)
      head->so_qlen--;
 3231d78:	e0bffb17 	ldw	r2,-20(fp)
 3231d7c:	10801e43 	ldbu	r2,121(r2)
 3231d80:	10bfffc4 	addi	r2,r2,-1
 3231d84:	1007883a 	mov	r3,r2
 3231d88:	e0bffb17 	ldw	r2,-20(fp)
 3231d8c:	10c01e45 	stb	r3,121(r2)
   }
   next->so_q0 = next->so_q = 0;
 3231d90:	e0bff917 	ldw	r2,-28(fp)
 3231d94:	10001d15 	stw	zero,116(r2)
 3231d98:	e0bff917 	ldw	r2,-28(fp)
 3231d9c:	10c01d17 	ldw	r3,116(r2)
 3231da0:	e0bff917 	ldw	r2,-28(fp)
 3231da4:	10c01c15 	stw	r3,112(r2)
   next->so_head = 0;
 3231da8:	e0bff917 	ldw	r2,-28(fp)
 3231dac:	10001b15 	stw	zero,108(r2)
   return 1;
 3231db0:	00800044 	movi	r2,1
 3231db4:	e0bffe15 	stw	r2,-8(fp)
 3231db8:	e0bffe17 	ldw	r2,-8(fp)
}
 3231dbc:	e037883a 	mov	sp,fp
 3231dc0:	df000017 	ldw	fp,0(sp)
 3231dc4:	dec00104 	addi	sp,sp,4
 3231dc8:	f800283a 	ret

03231dcc <socantsendmore>:
 * RETURNS: 
 */

void
socantsendmore(struct socket * so)
{
 3231dcc:	defffd04 	addi	sp,sp,-12
 3231dd0:	dfc00215 	stw	ra,8(sp)
 3231dd4:	df000115 	stw	fp,4(sp)
 3231dd8:	df000104 	addi	fp,sp,4
 3231ddc:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTSENDMORE;
 3231de0:	e0bfff17 	ldw	r2,-4(fp)
 3231de4:	1080088b 	ldhu	r2,34(r2)
 3231de8:	10800414 	ori	r2,r2,16
 3231dec:	1007883a 	mov	r3,r2
 3231df0:	e0bfff17 	ldw	r2,-4(fp)
 3231df4:	10c0088d 	sth	r3,34(r2)
   sowwakeup(so);
 3231df8:	e0bfff17 	ldw	r2,-4(fp)
 3231dfc:	11401204 	addi	r5,r2,72
 3231e00:	e13fff17 	ldw	r4,-4(fp)
 3231e04:	3231f0c0 	call	3231f0c <sbwakeup>
}
 3231e08:	e037883a 	mov	sp,fp
 3231e0c:	dfc00117 	ldw	ra,4(sp)
 3231e10:	df000017 	ldw	fp,0(sp)
 3231e14:	dec00204 	addi	sp,sp,8
 3231e18:	f800283a 	ret

03231e1c <socantrcvmore>:
 * RETURNS: 
 */

void
socantrcvmore(struct socket * so)
{
 3231e1c:	defffd04 	addi	sp,sp,-12
 3231e20:	dfc00215 	stw	ra,8(sp)
 3231e24:	df000115 	stw	fp,4(sp)
 3231e28:	df000104 	addi	fp,sp,4
 3231e2c:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTRCVMORE;
 3231e30:	e0bfff17 	ldw	r2,-4(fp)
 3231e34:	1080088b 	ldhu	r2,34(r2)
 3231e38:	10800814 	ori	r2,r2,32
 3231e3c:	1007883a 	mov	r3,r2
 3231e40:	e0bfff17 	ldw	r2,-4(fp)
 3231e44:	10c0088d 	sth	r3,34(r2)
   sorwakeup(so);
 3231e48:	e0bfff17 	ldw	r2,-4(fp)
 3231e4c:	11400a04 	addi	r5,r2,40
 3231e50:	e13fff17 	ldw	r4,-4(fp)
 3231e54:	3231f0c0 	call	3231f0c <sbwakeup>
}
 3231e58:	e037883a 	mov	sp,fp
 3231e5c:	dfc00117 	ldw	ra,4(sp)
 3231e60:	df000017 	ldw	fp,0(sp)
 3231e64:	dec00204 	addi	sp,sp,8
 3231e68:	f800283a 	ret

03231e6c <sbselqueue>:
 * RETURNS: 
 */

void
sbselqueue(struct sockbuf * sb)
{
 3231e6c:	defffe04 	addi	sp,sp,-8
 3231e70:	df000115 	stw	fp,4(sp)
 3231e74:	df000104 	addi	fp,sp,4
 3231e78:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_SEL;
 3231e7c:	e0bfff17 	ldw	r2,-4(fp)
 3231e80:	1080070b 	ldhu	r2,28(r2)
 3231e84:	10800214 	ori	r2,r2,8
 3231e88:	1007883a 	mov	r3,r2
 3231e8c:	e0bfff17 	ldw	r2,-4(fp)
 3231e90:	10c0070d 	sth	r3,28(r2)
}
 3231e94:	e037883a 	mov	sp,fp
 3231e98:	df000017 	ldw	fp,0(sp)
 3231e9c:	dec00104 	addi	sp,sp,4
 3231ea0:	f800283a 	ret

03231ea4 <sbwait>:
 * RETURNS: 
 */

void
sbwait(struct sockbuf * sb)
{
 3231ea4:	defffd04 	addi	sp,sp,-12
 3231ea8:	dfc00215 	stw	ra,8(sp)
 3231eac:	df000115 	stw	fp,4(sp)
 3231eb0:	df000104 	addi	fp,sp,4
 3231eb4:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_WAIT;
 3231eb8:	e0bfff17 	ldw	r2,-4(fp)
 3231ebc:	1080070b 	ldhu	r2,28(r2)
 3231ec0:	10800114 	ori	r2,r2,4
 3231ec4:	1007883a 	mov	r3,r2
 3231ec8:	e0bfff17 	ldw	r2,-4(fp)
 3231ecc:	10c0070d 	sth	r3,28(r2)
   tcp_sleep ((char *)&sb->sb_cc);
 3231ed0:	e0bfff17 	ldw	r2,-4(fp)
 3231ed4:	1009883a 	mov	r4,r2
 3231ed8:	32267600 	call	3226760 <tcp_sleep>
   sb->sb_flags &= ~SB_WAIT;
 3231edc:	e0bfff17 	ldw	r2,-4(fp)
 3231ee0:	10c0070b 	ldhu	r3,28(r2)
 3231ee4:	00bffec4 	movi	r2,-5
 3231ee8:	1884703a 	and	r2,r3,r2
 3231eec:	1007883a 	mov	r3,r2
 3231ef0:	e0bfff17 	ldw	r2,-4(fp)
 3231ef4:	10c0070d 	sth	r3,28(r2)
}
 3231ef8:	e037883a 	mov	sp,fp
 3231efc:	dfc00117 	ldw	ra,4(sp)
 3231f00:	df000017 	ldw	fp,0(sp)
 3231f04:	dec00204 	addi	sp,sp,8
 3231f08:	f800283a 	ret

03231f0c <sbwakeup>:
 * RETURNS: 
 */

void
sbwakeup(struct socket * so, struct sockbuf * sb)
{
 3231f0c:	defffc04 	addi	sp,sp,-16
 3231f10:	dfc00315 	stw	ra,12(sp)
 3231f14:	df000215 	stw	fp,8(sp)
 3231f18:	df000204 	addi	fp,sp,8
 3231f1c:	e13ffe15 	stw	r4,-8(fp)
 3231f20:	e17fff15 	stw	r5,-4(fp)
   if (sb->sb_flags & SB_SEL) 
 3231f24:	e0bfff17 	ldw	r2,-4(fp)
 3231f28:	1080070b 	ldhu	r2,28(r2)
 3231f2c:	10bfffcc 	andi	r2,r2,65535
 3231f30:	1080020c 	andi	r2,r2,8
 3231f34:	1005003a 	cmpeq	r2,r2,zero
 3231f38:	10000d1e 	bne	r2,zero,3231f70 <sbwakeup+0x64>
   {
      select_wait = 0;
 3231f3c:	0080c974 	movhi	r2,805
 3231f40:	10925e04 	addi	r2,r2,18808
 3231f44:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
      tcp_wakeup ((char *)&select_wait);
 3231f48:	0100c974 	movhi	r4,805
 3231f4c:	21125e04 	addi	r4,r4,18808
 3231f50:	32269000 	call	3226900 <tcp_wakeup>
#else
      tcp_wakeup2 (so->owner);
#endif      
      sb->sb_flags &= ~SB_SEL;
 3231f54:	e0bfff17 	ldw	r2,-4(fp)
 3231f58:	10c0070b 	ldhu	r3,28(r2)
 3231f5c:	00bffdc4 	movi	r2,-9
 3231f60:	1884703a 	and	r2,r3,r2
 3231f64:	1007883a 	mov	r3,r2
 3231f68:	e0bfff17 	ldw	r2,-4(fp)
 3231f6c:	10c0070d 	sth	r3,28(r2)
#ifdef SOCK_WAKEALWAYS  /* Always wake the socket? */
   /* Systems Like Green Hills Integrity RTOS, need to process socket
      input even if looks like no one is blocked on the socket */
   tcp_wakeup ((char *)&sb->sb_cc); /* signal wake on socket */
#else /* older BSD style code - only call tcp_wakeup if blocked */
   if (sb->sb_flags & SB_WAIT)   /* is sockbuf's WAIT flag set? */
 3231f70:	e0bfff17 	ldw	r2,-4(fp)
 3231f74:	1080070b 	ldhu	r2,28(r2)
 3231f78:	10bfffcc 	andi	r2,r2,65535
 3231f7c:	1080010c 	andi	r2,r2,4
 3231f80:	1005003a 	cmpeq	r2,r2,zero
 3231f84:	1000031e 	bne	r2,zero,3231f94 <sbwakeup+0x88>
   {
      tcp_wakeup ((char *)&sb->sb_cc);   /* call port wakeup routine */
 3231f88:	e0bfff17 	ldw	r2,-4(fp)
 3231f8c:	1009883a 	mov	r4,r2
 3231f90:	32269000 	call	3226900 <tcp_wakeup>
   }
#endif   /* SOCK_WAKEALWAYS */
}
 3231f94:	e037883a 	mov	sp,fp
 3231f98:	dfc00117 	ldw	ra,4(sp)
 3231f9c:	df000017 	ldw	fp,0(sp)
 3231fa0:	dec00204 	addi	sp,sp,8
 3231fa4:	f800283a 	ret

03231fa8 <soreserve>:

int
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
 3231fa8:	defffa04 	addi	sp,sp,-24
 3231fac:	dfc00515 	stw	ra,20(sp)
 3231fb0:	df000415 	stw	fp,16(sp)
 3231fb4:	df000404 	addi	fp,sp,16
 3231fb8:	e13ffc15 	stw	r4,-16(fp)
 3231fbc:	e17ffd15 	stw	r5,-12(fp)
 3231fc0:	e1bffe15 	stw	r6,-8(fp)
   if (sbreserve(&so->so_snd, sndcc) == 0)
 3231fc4:	e0bffc17 	ldw	r2,-16(fp)
 3231fc8:	11001204 	addi	r4,r2,72
 3231fcc:	e17ffd17 	ldw	r5,-12(fp)
 3231fd0:	32320280 	call	3232028 <sbreserve>
 3231fd4:	1005003a 	cmpeq	r2,r2,zero
 3231fd8:	10000b1e 	bne	r2,zero,3232008 <soreserve+0x60>
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
 3231fdc:	e0bffc17 	ldw	r2,-16(fp)
 3231fe0:	11000a04 	addi	r4,r2,40
 3231fe4:	e17ffe17 	ldw	r5,-8(fp)
 3231fe8:	32320280 	call	3232028 <sbreserve>
 3231fec:	1005003a 	cmpeq	r2,r2,zero
 3231ff0:	1000021e 	bne	r2,zero,3231ffc <soreserve+0x54>
      goto bad2;
   return (0);
 3231ff4:	e03fff15 	stw	zero,-4(fp)
 3231ff8:	00000506 	br	3232010 <soreserve+0x68>
bad2:
   sbrelease(&so->so_snd);
 3231ffc:	e0bffc17 	ldw	r2,-16(fp)
 3232000:	11001204 	addi	r4,r2,72
 3232004:	32320880 	call	3232088 <sbrelease>
bad:
   return (ENOBUFS);
 3232008:	00801a44 	movi	r2,105
 323200c:	e0bfff15 	stw	r2,-4(fp)
 3232010:	e0bfff17 	ldw	r2,-4(fp)
}
 3232014:	e037883a 	mov	sp,fp
 3232018:	dfc00117 	ldw	ra,4(sp)
 323201c:	df000017 	ldw	fp,0(sp)
 3232020:	dec00204 	addi	sp,sp,8
 3232024:	f800283a 	ret

03232028 <sbreserve>:
 * RETURNS: 
 */

int
sbreserve(struct sockbuf * sb, u_long cc)
{
 3232028:	defffc04 	addi	sp,sp,-16
 323202c:	df000315 	stw	fp,12(sp)
 3232030:	df000304 	addi	fp,sp,12
 3232034:	e13ffd15 	stw	r4,-12(fp)
 3232038:	e17ffe15 	stw	r5,-8(fp)
#ifdef COMPILER_32BIT
   if (cc > (u_long)SB_MAX * CLBYTES / (2 * MSIZE + CLBYTES))
      return (0);
#endif
   sb->sb_hiwat = cc;
 323203c:	e0fffd17 	ldw	r3,-12(fp)
 3232040:	e0bffe17 	ldw	r2,-8(fp)
 3232044:	18800115 	stw	r2,4(r3)
   sb->sb_mbmax = MIN(cc * 2, SB_MAX);
 3232048:	e0bffe17 	ldw	r2,-8(fp)
 323204c:	1085883a 	add	r2,r2,r2
 3232050:	e0bfff15 	stw	r2,-4(fp)
 3232054:	e0ffff17 	ldw	r3,-4(fp)
 3232058:	18900070 	cmpltui	r2,r3,16385
 323205c:	1000021e 	bne	r2,zero,3232068 <sbreserve+0x40>
 3232060:	00900004 	movi	r2,16384
 3232064:	e0bfff15 	stw	r2,-4(fp)
 3232068:	e0bffd17 	ldw	r2,-12(fp)
 323206c:	e0ffff17 	ldw	r3,-4(fp)
 3232070:	10c00315 	stw	r3,12(r2)
   return (1);
 3232074:	00800044 	movi	r2,1
}
 3232078:	e037883a 	mov	sp,fp
 323207c:	df000017 	ldw	fp,0(sp)
 3232080:	dec00104 	addi	sp,sp,4
 3232084:	f800283a 	ret

03232088 <sbrelease>:
 * RETURNS: 
 */

void
sbrelease(struct sockbuf * sb)
{
 3232088:	defffd04 	addi	sp,sp,-12
 323208c:	dfc00215 	stw	ra,8(sp)
 3232090:	df000115 	stw	fp,4(sp)
 3232094:	df000104 	addi	fp,sp,4
 3232098:	e13fff15 	stw	r4,-4(fp)
   sbflush(sb);
 323209c:	e13fff17 	ldw	r4,-4(fp)
 32320a0:	32326480 	call	3232648 <sbflush>
   sb->sb_hiwat = sb->sb_mbmax = 0;
 32320a4:	e0bfff17 	ldw	r2,-4(fp)
 32320a8:	10000315 	stw	zero,12(r2)
 32320ac:	e0bfff17 	ldw	r2,-4(fp)
 32320b0:	10c00317 	ldw	r3,12(r2)
 32320b4:	e0bfff17 	ldw	r2,-4(fp)
 32320b8:	10c00115 	stw	r3,4(r2)
}
 32320bc:	e037883a 	mov	sp,fp
 32320c0:	dfc00117 	ldw	ra,4(sp)
 32320c4:	df000017 	ldw	fp,0(sp)
 32320c8:	dec00204 	addi	sp,sp,8
 32320cc:	f800283a 	ret

032320d0 <sbappend>:
 * RETURNS: 
 */

void
sbappend(struct sockbuf * sb, struct mbuf * m)
{
 32320d0:	defffb04 	addi	sp,sp,-20
 32320d4:	dfc00415 	stw	ra,16(sp)
 32320d8:	df000315 	stw	fp,12(sp)
 32320dc:	df000304 	addi	fp,sp,12
 32320e0:	e13ffe15 	stw	r4,-8(fp)
 32320e4:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  n;

   if (m == 0)
 32320e8:	e0bfff17 	ldw	r2,-4(fp)
 32320ec:	1005003a 	cmpeq	r2,r2,zero
 32320f0:	10001c1e 	bne	r2,zero,3232164 <sbappend+0x94>
      return;
   ENTER_CRIT_SECTION(sb);
 32320f4:	322ad8c0 	call	322ad8c <irq_Mask>
   if ((n = sb->sb_mb) != NULL) 
 32320f8:	e0bffe17 	ldw	r2,-8(fp)
 32320fc:	10800617 	ldw	r2,24(r2)
 3232100:	e0bffd15 	stw	r2,-12(fp)
 3232104:	e0bffd17 	ldw	r2,-12(fp)
 3232108:	1005003a 	cmpeq	r2,r2,zero
 323210c:	1000101e 	bne	r2,zero,3232150 <sbappend+0x80>
   {
      while (n->m_act)
 3232110:	00000306 	br	3232120 <sbappend+0x50>
         n = n->m_act;
 3232114:	e0bffd17 	ldw	r2,-12(fp)
 3232118:	10800717 	ldw	r2,28(r2)
 323211c:	e0bffd15 	stw	r2,-12(fp)
   if (m == 0)
      return;
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 3232120:	e0bffd17 	ldw	r2,-12(fp)
 3232124:	10800717 	ldw	r2,28(r2)
 3232128:	1004c03a 	cmpne	r2,r2,zero
 323212c:	103ff91e 	bne	r2,zero,3232114 <sbappend+0x44>
         n = n->m_act;
      while (n->m_next)
 3232130:	00000306 	br	3232140 <sbappend+0x70>
         n = n->m_next;
 3232134:	e0bffd17 	ldw	r2,-12(fp)
 3232138:	10800617 	ldw	r2,24(r2)
 323213c:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
         n = n->m_act;
      while (n->m_next)
 3232140:	e0bffd17 	ldw	r2,-12(fp)
 3232144:	10800617 	ldw	r2,24(r2)
 3232148:	1004c03a 	cmpne	r2,r2,zero
 323214c:	103ff91e 	bne	r2,zero,3232134 <sbappend+0x64>
         n = n->m_next;
   }
   sbcompress(sb, m, n);
 3232150:	e13ffe17 	ldw	r4,-8(fp)
 3232154:	e17fff17 	ldw	r5,-4(fp)
 3232158:	e1bffd17 	ldw	r6,-12(fp)
 323215c:	32324600 	call	3232460 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 3232160:	322ade80 	call	322ade8 <irq_Unmask>
}
 3232164:	e037883a 	mov	sp,fp
 3232168:	dfc00117 	ldw	ra,4(sp)
 323216c:	df000017 	ldw	fp,0(sp)
 3232170:	dec00204 	addi	sp,sp,8
 3232174:	f800283a 	ret

03232178 <sbappendrecord>:
 */

void
sbappendrecord(struct sockbuf * sb, 
   struct mbuf *  m0)
{
 3232178:	defffb04 	addi	sp,sp,-20
 323217c:	dfc00415 	stw	ra,16(sp)
 3232180:	df000315 	stw	fp,12(sp)
 3232184:	df000304 	addi	fp,sp,12
 3232188:	e13ffe15 	stw	r4,-8(fp)
 323218c:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;

   if (m0 == 0)
 3232190:	e0bfff17 	ldw	r2,-4(fp)
 3232194:	1005003a 	cmpeq	r2,r2,zero
 3232198:	10002a1e 	bne	r2,zero,3232244 <sbappendrecord+0xcc>
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
 323219c:	322ad8c0 	call	322ad8c <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 32321a0:	e0bffe17 	ldw	r2,-8(fp)
 32321a4:	10800617 	ldw	r2,24(r2)
 32321a8:	e0bffd15 	stw	r2,-12(fp)
 32321ac:	e0bffd17 	ldw	r2,-12(fp)
 32321b0:	1005003a 	cmpeq	r2,r2,zero
 32321b4:	1000081e 	bne	r2,zero,32321d8 <sbappendrecord+0x60>
      while (m->m_act)
 32321b8:	00000306 	br	32321c8 <sbappendrecord+0x50>
      m = m->m_act;
 32321bc:	e0bffd17 	ldw	r2,-12(fp)
 32321c0:	10800717 	ldw	r2,28(r2)
 32321c4:	e0bffd15 	stw	r2,-12(fp)

   if (m0 == 0)
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
   if ((m = sb->sb_mb) != NULL)
      while (m->m_act)
 32321c8:	e0bffd17 	ldw	r2,-12(fp)
 32321cc:	10800717 	ldw	r2,28(r2)
 32321d0:	1004c03a 	cmpne	r2,r2,zero
 32321d4:	103ff91e 	bne	r2,zero,32321bc <sbappendrecord+0x44>
      m = m->m_act;
   /*
    * Put the first mbuf on the queue.
    * Note this permits zero length records.
    */
   sballoc(sb, m0);
 32321d8:	e0bffe17 	ldw	r2,-8(fp)
 32321dc:	10c00017 	ldw	r3,0(r2)
 32321e0:	e0bfff17 	ldw	r2,-4(fp)
 32321e4:	10800217 	ldw	r2,8(r2)
 32321e8:	1887883a 	add	r3,r3,r2
 32321ec:	e0bffe17 	ldw	r2,-8(fp)
 32321f0:	10c00015 	stw	r3,0(r2)
   if (m)
 32321f4:	e0bffd17 	ldw	r2,-12(fp)
 32321f8:	1005003a 	cmpeq	r2,r2,zero
 32321fc:	1000041e 	bne	r2,zero,3232210 <sbappendrecord+0x98>
      m->m_act = m0;
 3232200:	e0fffd17 	ldw	r3,-12(fp)
 3232204:	e0bfff17 	ldw	r2,-4(fp)
 3232208:	18800715 	stw	r2,28(r3)
 323220c:	00000306 	br	323221c <sbappendrecord+0xa4>
   else
      sb->sb_mb = m0;
 3232210:	e0fffe17 	ldw	r3,-8(fp)
 3232214:	e0bfff17 	ldw	r2,-4(fp)
 3232218:	18800615 	stw	r2,24(r3)
   m = m0->m_next;
 323221c:	e0bfff17 	ldw	r2,-4(fp)
 3232220:	10800617 	ldw	r2,24(r2)
 3232224:	e0bffd15 	stw	r2,-12(fp)
   m0->m_next = 0;
 3232228:	e0bfff17 	ldw	r2,-4(fp)
 323222c:	10000615 	stw	zero,24(r2)
   sbcompress(sb, m, m0);
 3232230:	e13ffe17 	ldw	r4,-8(fp)
 3232234:	e17ffd17 	ldw	r5,-12(fp)
 3232238:	e1bfff17 	ldw	r6,-4(fp)
 323223c:	32324600 	call	3232460 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 3232240:	322ade80 	call	322ade8 <irq_Unmask>
}
 3232244:	e037883a 	mov	sp,fp
 3232248:	dfc00117 	ldw	ra,4(sp)
 323224c:	df000017 	ldw	fp,0(sp)
 3232250:	dec00204 	addi	sp,sp,8
 3232254:	f800283a 	ret

03232258 <sbappendaddr>:

int
sbappendaddr(struct sockbuf * sb, 
   struct sockaddr * asa,
   struct mbuf *  m0)
{
 3232258:	defff604 	addi	sp,sp,-40
 323225c:	dfc00915 	stw	ra,36(sp)
 3232260:	df000815 	stw	fp,32(sp)
 3232264:	df000804 	addi	fp,sp,32
 3232268:	e13ffb15 	stw	r4,-20(fp)
 323226c:	e17ffc15 	stw	r5,-16(fp)
 3232270:	e1bffd15 	stw	r6,-12(fp)
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);
 3232274:	00800404 	movi	r2,16
 3232278:	e0bff815 	stw	r2,-32(fp)

   ENTER_CRIT_SECTION(sb);
 323227c:	322ad8c0 	call	322ad8c <irq_Mask>
   for (m = m0; m; m = m->m_next)
 3232280:	e0bffd17 	ldw	r2,-12(fp)
 3232284:	e0bffa15 	stw	r2,-24(fp)
 3232288:	00000806 	br	32322ac <sbappendaddr+0x54>
      space += m->m_len;
 323228c:	e0bffa17 	ldw	r2,-24(fp)
 3232290:	10c00217 	ldw	r3,8(r2)
 3232294:	e0bff817 	ldw	r2,-32(fp)
 3232298:	1885883a 	add	r2,r3,r2
 323229c:	e0bff815 	stw	r2,-32(fp)
{
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);

   ENTER_CRIT_SECTION(sb);
   for (m = m0; m; m = m->m_next)
 32322a0:	e0bffa17 	ldw	r2,-24(fp)
 32322a4:	10800617 	ldw	r2,24(r2)
 32322a8:	e0bffa15 	stw	r2,-24(fp)
 32322ac:	e0bffa17 	ldw	r2,-24(fp)
 32322b0:	1004c03a 	cmpne	r2,r2,zero
 32322b4:	103ff51e 	bne	r2,zero,323228c <sbappendaddr+0x34>
      space += m->m_len;
   if (space > (int)sbspace(sb))
 32322b8:	e0bffb17 	ldw	r2,-20(fp)
 32322bc:	10800117 	ldw	r2,4(r2)
 32322c0:	1007883a 	mov	r3,r2
 32322c4:	e0bffb17 	ldw	r2,-20(fp)
 32322c8:	10800017 	ldw	r2,0(r2)
 32322cc:	1885c83a 	sub	r2,r3,r2
 32322d0:	1004803a 	cmplt	r2,r2,zero
 32322d4:	1000071e 	bne	r2,zero,32322f4 <sbappendaddr+0x9c>
 32322d8:	e0bffb17 	ldw	r2,-20(fp)
 32322dc:	10c00117 	ldw	r3,4(r2)
 32322e0:	e0bffb17 	ldw	r2,-20(fp)
 32322e4:	10800017 	ldw	r2,0(r2)
 32322e8:	1885c83a 	sub	r2,r3,r2
 32322ec:	e0bfff15 	stw	r2,-4(fp)
 32322f0:	00000106 	br	32322f8 <sbappendaddr+0xa0>
 32322f4:	e03fff15 	stw	zero,-4(fp)
 32322f8:	e0bff817 	ldw	r2,-32(fp)
 32322fc:	e0ffff17 	ldw	r3,-4(fp)
 3232300:	1880030e 	bge	r3,r2,3232310 <sbappendaddr+0xb8>
   {
      EXIT_CRIT_SECTION(sb);
 3232304:	322ade80 	call	322ade8 <irq_Unmask>
      return (0);
 3232308:	e03ffe15 	stw	zero,-8(fp)
 323230c:	00004e06 	br	3232448 <sbappendaddr+0x1f0>
   }
   if ((m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr))) == NULL)
 3232310:	01000244 	movi	r4,9
 3232314:	01400404 	movi	r5,16
 3232318:	322b98c0 	call	322b98c <m_getnbuf>
 323231c:	e0bffa15 	stw	r2,-24(fp)
 3232320:	e0bffa17 	ldw	r2,-24(fp)
 3232324:	1004c03a 	cmpne	r2,r2,zero
 3232328:	1000031e 	bne	r2,zero,3232338 <sbappendaddr+0xe0>
   {
      EXIT_CRIT_SECTION(sb);
 323232c:	322ade80 	call	322ade8 <irq_Unmask>
      return 0;
 3232330:	e03ffe15 	stw	zero,-8(fp)
 3232334:	00004406 	br	3232448 <sbappendaddr+0x1f0>
   }
   *mtod(m, struct sockaddr *) = *asa;
 3232338:	e0bffa17 	ldw	r2,-24(fp)
 323233c:	10800317 	ldw	r2,12(r2)
 3232340:	1009883a 	mov	r4,r2
 3232344:	e0fffc17 	ldw	r3,-16(fp)
 3232348:	1880000b 	ldhu	r2,0(r3)
 323234c:	2080000d 	sth	r2,0(r4)
 3232350:	1880008b 	ldhu	r2,2(r3)
 3232354:	2080008d 	sth	r2,2(r4)
 3232358:	1880010b 	ldhu	r2,4(r3)
 323235c:	2080010d 	sth	r2,4(r4)
 3232360:	1880018b 	ldhu	r2,6(r3)
 3232364:	2080018d 	sth	r2,6(r4)
 3232368:	1880020b 	ldhu	r2,8(r3)
 323236c:	2080020d 	sth	r2,8(r4)
 3232370:	1880028b 	ldhu	r2,10(r3)
 3232374:	2080028d 	sth	r2,10(r4)
 3232378:	1880030b 	ldhu	r2,12(r3)
 323237c:	2080030d 	sth	r2,12(r4)
 3232380:	1880038b 	ldhu	r2,14(r3)
 3232384:	2080038d 	sth	r2,14(r4)
   m->m_len = sizeof (*asa);
 3232388:	e0fffa17 	ldw	r3,-24(fp)
 323238c:	00800404 	movi	r2,16
 3232390:	18800215 	stw	r2,8(r3)
   sballoc (sb, m);
 3232394:	e0bffb17 	ldw	r2,-20(fp)
 3232398:	10c00017 	ldw	r3,0(r2)
 323239c:	e0bffa17 	ldw	r2,-24(fp)
 32323a0:	10800217 	ldw	r2,8(r2)
 32323a4:	1887883a 	add	r3,r3,r2
 32323a8:	e0bffb17 	ldw	r2,-20(fp)
 32323ac:	10c00015 	stw	r3,0(r2)
   if ((n = sb->sb_mb) != NULL) 
 32323b0:	e0bffb17 	ldw	r2,-20(fp)
 32323b4:	10800617 	ldw	r2,24(r2)
 32323b8:	e0bff915 	stw	r2,-28(fp)
 32323bc:	e0bff917 	ldw	r2,-28(fp)
 32323c0:	1005003a 	cmpeq	r2,r2,zero
 32323c4:	10000c1e 	bne	r2,zero,32323f8 <sbappendaddr+0x1a0>
   {
      while (n->m_act)
 32323c8:	00000306 	br	32323d8 <sbappendaddr+0x180>
         n = n->m_act;
 32323cc:	e0bff917 	ldw	r2,-28(fp)
 32323d0:	10800717 	ldw	r2,28(r2)
 32323d4:	e0bff915 	stw	r2,-28(fp)
   *mtod(m, struct sockaddr *) = *asa;
   m->m_len = sizeof (*asa);
   sballoc (sb, m);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 32323d8:	e0bff917 	ldw	r2,-28(fp)
 32323dc:	10800717 	ldw	r2,28(r2)
 32323e0:	1004c03a 	cmpne	r2,r2,zero
 32323e4:	103ff91e 	bne	r2,zero,32323cc <sbappendaddr+0x174>
         n = n->m_act;
      n->m_act = m;
 32323e8:	e0fff917 	ldw	r3,-28(fp)
 32323ec:	e0bffa17 	ldw	r2,-24(fp)
 32323f0:	18800715 	stw	r2,28(r3)
 32323f4:	00000306 	br	3232404 <sbappendaddr+0x1ac>
   } else
      sb->sb_mb = m;
 32323f8:	e0fffb17 	ldw	r3,-20(fp)
 32323fc:	e0bffa17 	ldw	r2,-24(fp)
 3232400:	18800615 	stw	r2,24(r3)
   if (m->m_next)
 3232404:	e0bffa17 	ldw	r2,-24(fp)
 3232408:	10800617 	ldw	r2,24(r2)
 323240c:	1005003a 	cmpeq	r2,r2,zero
 3232410:	1000031e 	bne	r2,zero,3232420 <sbappendaddr+0x1c8>
      m = m->m_next;
 3232414:	e0bffa17 	ldw	r2,-24(fp)
 3232418:	10800617 	ldw	r2,24(r2)
 323241c:	e0bffa15 	stw	r2,-24(fp)
   if (m0)
 3232420:	e0bffd17 	ldw	r2,-12(fp)
 3232424:	1005003a 	cmpeq	r2,r2,zero
 3232428:	1000041e 	bne	r2,zero,323243c <sbappendaddr+0x1e4>
      sbcompress(sb, m0, m);
 323242c:	e13ffb17 	ldw	r4,-20(fp)
 3232430:	e17ffd17 	ldw	r5,-12(fp)
 3232434:	e1bffa17 	ldw	r6,-24(fp)
 3232438:	32324600 	call	3232460 <sbcompress>

   EXIT_CRIT_SECTION(sb);
 323243c:	322ade80 	call	322ade8 <irq_Unmask>
   return (1);
 3232440:	00800044 	movi	r2,1
 3232444:	e0bffe15 	stw	r2,-8(fp)
 3232448:	e0bffe17 	ldw	r2,-8(fp)
}
 323244c:	e037883a 	mov	sp,fp
 3232450:	dfc00117 	ldw	ra,4(sp)
 3232454:	df000017 	ldw	fp,0(sp)
 3232458:	dec00204 	addi	sp,sp,8
 323245c:	f800283a 	ret

03232460 <sbcompress>:

void
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{
 3232460:	defffb04 	addi	sp,sp,-20
 3232464:	dfc00415 	stw	ra,16(sp)
 3232468:	df000315 	stw	fp,12(sp)
 323246c:	df000304 	addi	fp,sp,12
 3232470:	e13ffd15 	stw	r4,-12(fp)
 3232474:	e17ffe15 	stw	r5,-8(fp)
 3232478:	e1bfff15 	stw	r6,-4(fp)

   while (m) 
 323247c:	00006a06 	br	3232628 <sbcompress+0x1c8>
   {
      if (m->m_len == 0) 
 3232480:	e0bffe17 	ldw	r2,-8(fp)
 3232484:	10800217 	ldw	r2,8(r2)
 3232488:	1004c03a 	cmpne	r2,r2,zero
 323248c:	1000041e 	bne	r2,zero,32324a0 <sbcompress+0x40>
      {
         m = m_free(m);
 3232490:	e13ffe17 	ldw	r4,-8(fp)
 3232494:	322bb340 	call	322bb34 <m_free>
 3232498:	e0bffe15 	stw	r2,-8(fp)
         continue;
 323249c:	00006206 	br	3232628 <sbcompress+0x1c8>
      }
      if (m->m_type != MT_RXDATA && 
 32324a0:	e0bffe17 	ldw	r2,-8(fp)
 32324a4:	10800817 	ldw	r2,32(r2)
 32324a8:	10800060 	cmpeqi	r2,r2,1
 32324ac:	1000101e 	bne	r2,zero,32324f0 <sbcompress+0x90>
 32324b0:	e0bffe17 	ldw	r2,-8(fp)
 32324b4:	10800817 	ldw	r2,32(r2)
 32324b8:	108000a0 	cmpeqi	r2,r2,2
 32324bc:	10000c1e 	bne	r2,zero,32324f0 <sbcompress+0x90>
 32324c0:	e0bffe17 	ldw	r2,-8(fp)
 32324c4:	10800817 	ldw	r2,32(r2)
 32324c8:	10800260 	cmpeqi	r2,r2,9
 32324cc:	1000081e 	bne	r2,zero,32324f0 <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
          m->m_type != MT_SONAME) 
      {
         dprintf ("sbcomp:bad type %d\n", m->m_type);
 32324d0:	e0bffe17 	ldw	r2,-8(fp)
 32324d4:	11400817 	ldw	r5,32(r2)
 32324d8:	0100c974 	movhi	r4,805
 32324dc:	213d5e04 	addi	r4,r4,-2696
 32324e0:	3206adc0 	call	3206adc <printf>
         panic ("sbcomp:bad");
 32324e4:	0100c974 	movhi	r4,805
 32324e8:	213d6304 	addi	r4,r4,-2676
 32324ec:	3225df00 	call	3225df0 <panic>
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 32324f0:	e0bfff17 	ldw	r2,-4(fp)
 32324f4:	1005003a 	cmpeq	r2,r2,zero
 32324f8:	1000331e 	bne	r2,zero,32325c8 <sbcompress+0x168>
 32324fc:	e0bffd17 	ldw	r2,-12(fp)
 3232500:	1080070b 	ldhu	r2,28(r2)
 3232504:	10bfffcc 	andi	r2,r2,65535
 3232508:	1080200c 	andi	r2,r2,128
 323250c:	1005003a 	cmpeq	r2,r2,zero
 3232510:	10002d1e 	bne	r2,zero,32325c8 <sbcompress+0x168>
 3232514:	e0bfff17 	ldw	r2,-4(fp)
 3232518:	10c00217 	ldw	r3,8(r2)
 323251c:	e0bffe17 	ldw	r2,-8(fp)
 3232520:	10800217 	ldw	r2,8(r2)
 3232524:	188b883a 	add	r5,r3,r2
 3232528:	e0bfff17 	ldw	r2,-4(fp)
 323252c:	11000517 	ldw	r4,20(r2)
 3232530:	e0bfff17 	ldw	r2,-4(fp)
 3232534:	10800317 	ldw	r2,12(r2)
 3232538:	1007883a 	mov	r3,r2
 323253c:	e0bfff17 	ldw	r2,-4(fp)
 3232540:	10800417 	ldw	r2,16(r2)
 3232544:	1885c83a 	sub	r2,r3,r2
 3232548:	2085c83a 	sub	r2,r4,r2
 323254c:	28801e2e 	bgeu	r5,r2,32325c8 <sbcompress+0x168>
          ((n->m_len + m->m_len) <
          n->m_memsz - (n->m_data - n->m_base) ) ) 
      {
         MEMCPY(n->m_data+n->m_len, m->m_data, m->m_len);
 3232550:	e0bfff17 	ldw	r2,-4(fp)
 3232554:	10c00317 	ldw	r3,12(r2)
 3232558:	e0bfff17 	ldw	r2,-4(fp)
 323255c:	10800217 	ldw	r2,8(r2)
 3232560:	1887883a 	add	r3,r3,r2
 3232564:	e0bffe17 	ldw	r2,-8(fp)
 3232568:	11400317 	ldw	r5,12(r2)
 323256c:	e0bffe17 	ldw	r2,-8(fp)
 3232570:	10800217 	ldw	r2,8(r2)
 3232574:	1809883a 	mov	r4,r3
 3232578:	100d883a 	mov	r6,r2
 323257c:	32067cc0 	call	32067cc <memcpy>
         sballoc(sb, m);
 3232580:	e0bffd17 	ldw	r2,-12(fp)
 3232584:	10c00017 	ldw	r3,0(r2)
 3232588:	e0bffe17 	ldw	r2,-8(fp)
 323258c:	10800217 	ldw	r2,8(r2)
 3232590:	1887883a 	add	r3,r3,r2
 3232594:	e0bffd17 	ldw	r2,-12(fp)
 3232598:	10c00015 	stw	r3,0(r2)
         n->m_len += m->m_len;
 323259c:	e0bfff17 	ldw	r2,-4(fp)
 32325a0:	10c00217 	ldw	r3,8(r2)
 32325a4:	e0bffe17 	ldw	r2,-8(fp)
 32325a8:	10800217 	ldw	r2,8(r2)
 32325ac:	1887883a 	add	r3,r3,r2
 32325b0:	e0bfff17 	ldw	r2,-4(fp)
 32325b4:	10c00215 	stw	r3,8(r2)
         m = m_free(m);
 32325b8:	e13ffe17 	ldw	r4,-8(fp)
 32325bc:	322bb340 	call	322bb34 <m_free>
 32325c0:	e0bffe15 	stw	r2,-8(fp)
         continue;
 32325c4:	00001806 	br	3232628 <sbcompress+0x1c8>
      }
      sballoc(sb, m);
 32325c8:	e0bffd17 	ldw	r2,-12(fp)
 32325cc:	10c00017 	ldw	r3,0(r2)
 32325d0:	e0bffe17 	ldw	r2,-8(fp)
 32325d4:	10800217 	ldw	r2,8(r2)
 32325d8:	1887883a 	add	r3,r3,r2
 32325dc:	e0bffd17 	ldw	r2,-12(fp)
 32325e0:	10c00015 	stw	r3,0(r2)
      if (n)
 32325e4:	e0bfff17 	ldw	r2,-4(fp)
 32325e8:	1005003a 	cmpeq	r2,r2,zero
 32325ec:	1000041e 	bne	r2,zero,3232600 <sbcompress+0x1a0>
         n->m_next = m;
 32325f0:	e0ffff17 	ldw	r3,-4(fp)
 32325f4:	e0bffe17 	ldw	r2,-8(fp)
 32325f8:	18800615 	stw	r2,24(r3)
 32325fc:	00000306 	br	323260c <sbcompress+0x1ac>
      else
         sb->sb_mb = m;
 3232600:	e0fffd17 	ldw	r3,-12(fp)
 3232604:	e0bffe17 	ldw	r2,-8(fp)
 3232608:	18800615 	stw	r2,24(r3)
      n = m;
 323260c:	e0bffe17 	ldw	r2,-8(fp)
 3232610:	e0bfff15 	stw	r2,-4(fp)
      m = m->m_next;
 3232614:	e0bffe17 	ldw	r2,-8(fp)
 3232618:	10800617 	ldw	r2,24(r2)
 323261c:	e0bffe15 	stw	r2,-8(fp)
      n->m_next = 0;
 3232620:	e0bfff17 	ldw	r2,-4(fp)
 3232624:	10000615 	stw	zero,24(r2)
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{

   while (m) 
 3232628:	e0bffe17 	ldw	r2,-8(fp)
 323262c:	1004c03a 	cmpne	r2,r2,zero
 3232630:	103f931e 	bne	r2,zero,3232480 <sbcompress+0x20>
         sb->sb_mb = m;
      n = m;
      m = m->m_next;
      n->m_next = 0;
   }
}
 3232634:	e037883a 	mov	sp,fp
 3232638:	dfc00117 	ldw	ra,4(sp)
 323263c:	df000017 	ldw	fp,0(sp)
 3232640:	dec00204 	addi	sp,sp,8
 3232644:	f800283a 	ret

03232648 <sbflush>:
 * RETURNS: 
 */

void
sbflush(struct sockbuf * sb)
{
 3232648:	defffd04 	addi	sp,sp,-12
 323264c:	dfc00215 	stw	ra,8(sp)
 3232650:	df000115 	stw	fp,4(sp)
 3232654:	df000104 	addi	fp,sp,4
 3232658:	e13fff15 	stw	r4,-4(fp)
   ENTER_CRIT_SECTION(sb);
 323265c:	322ad8c0 	call	322ad8c <irq_Mask>
   if (sb->sb_flags & SB_LOCK)
 3232660:	e0bfff17 	ldw	r2,-4(fp)
 3232664:	1080070b 	ldhu	r2,28(r2)
 3232668:	10bfffcc 	andi	r2,r2,65535
 323266c:	1080004c 	andi	r2,r2,1
 3232670:	10803fcc 	andi	r2,r2,255
 3232674:	1005003a 	cmpeq	r2,r2,zero
 3232678:	1000091e 	bne	r2,zero,32326a0 <sbflush+0x58>
      panic("sbflush");
 323267c:	0100c974 	movhi	r4,805
 3232680:	213d6604 	addi	r4,r4,-2664
 3232684:	3225df00 	call	3225df0 <panic>
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 3232688:	00000506 	br	32326a0 <sbflush+0x58>
      sbdrop (sb, (int)sb->sb_cc);
 323268c:	e0bfff17 	ldw	r2,-4(fp)
 3232690:	10800017 	ldw	r2,0(r2)
 3232694:	100b883a 	mov	r5,r2
 3232698:	e13fff17 	ldw	r4,-4(fp)
 323269c:	32326d80 	call	32326d8 <sbdrop>
sbflush(struct sockbuf * sb)
{
   ENTER_CRIT_SECTION(sb);
   if (sb->sb_flags & SB_LOCK)
      panic("sbflush");
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 32326a0:	e0bfff17 	ldw	r2,-4(fp)
 32326a4:	10800217 	ldw	r2,8(r2)
 32326a8:	1004c03a 	cmpne	r2,r2,zero
 32326ac:	103ff71e 	bne	r2,zero,323268c <sbflush+0x44>
 32326b0:	e0bfff17 	ldw	r2,-4(fp)
 32326b4:	10800017 	ldw	r2,0(r2)
 32326b8:	1004c03a 	cmpne	r2,r2,zero
 32326bc:	103ff31e 	bne	r2,zero,323268c <sbflush+0x44>
      sbdrop (sb, (int)sb->sb_cc);
   EXIT_CRIT_SECTION(sb);
 32326c0:	322ade80 	call	322ade8 <irq_Unmask>
}
 32326c4:	e037883a 	mov	sp,fp
 32326c8:	dfc00117 	ldw	ra,4(sp)
 32326cc:	df000017 	ldw	fp,0(sp)
 32326d0:	dec00204 	addi	sp,sp,8
 32326d4:	f800283a 	ret

032326d8 <sbdrop>:
 * RETURNS: 
 */

void
sbdrop(struct sockbuf * sb, int len)
{
 32326d8:	defff904 	addi	sp,sp,-28
 32326dc:	dfc00615 	stw	ra,24(sp)
 32326e0:	df000515 	stw	fp,20(sp)
 32326e4:	df000504 	addi	fp,sp,20
 32326e8:	e13ffe15 	stw	r4,-8(fp)
 32326ec:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m, *  mn;
   struct mbuf *  next;

   ENTER_CRIT_SECTION(sb);
 32326f0:	322ad8c0 	call	322ad8c <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 32326f4:	e0bffe17 	ldw	r2,-8(fp)
 32326f8:	10800617 	ldw	r2,24(r2)
 32326fc:	e0bffd15 	stw	r2,-12(fp)
 3232700:	e0bffd17 	ldw	r2,-12(fp)
 3232704:	1005003a 	cmpeq	r2,r2,zero
 3232708:	1000041e 	bne	r2,zero,323271c <sbdrop+0x44>
      next = m->m_act;
 323270c:	e0bffd17 	ldw	r2,-12(fp)
 3232710:	10800717 	ldw	r2,28(r2)
 3232714:	e0bffb15 	stw	r2,-20(fp)
 3232718:	00003906 	br	3232800 <sbdrop+0x128>
   else
      next = NULL;
 323271c:	e03ffb15 	stw	zero,-20(fp)
   while (len > 0) 
 3232720:	00003706 	br	3232800 <sbdrop+0x128>
   {
      if (m == 0) 
 3232724:	e0bffd17 	ldw	r2,-12(fp)
 3232728:	1004c03a 	cmpne	r2,r2,zero
 323272c:	10000c1e 	bne	r2,zero,3232760 <sbdrop+0x88>
      {
         if (next == 0)
 3232730:	e0bffb17 	ldw	r2,-20(fp)
 3232734:	1004c03a 	cmpne	r2,r2,zero
 3232738:	1000031e 	bne	r2,zero,3232748 <sbdrop+0x70>
            panic("sbdrop");
 323273c:	0100c974 	movhi	r4,805
 3232740:	213d6804 	addi	r4,r4,-2656
 3232744:	3225df00 	call	3225df0 <panic>
         m = next;
 3232748:	e0bffb17 	ldw	r2,-20(fp)
 323274c:	e0bffd15 	stw	r2,-12(fp)
         next = m->m_act;
 3232750:	e0bffd17 	ldw	r2,-12(fp)
 3232754:	10800717 	ldw	r2,28(r2)
 3232758:	e0bffb15 	stw	r2,-20(fp)
         continue;
 323275c:	00002806 	br	3232800 <sbdrop+0x128>
      }
      if (m->m_len > (unsigned)len) 
 3232760:	e0bffd17 	ldw	r2,-12(fp)
 3232764:	10c00217 	ldw	r3,8(r2)
 3232768:	e0bfff17 	ldw	r2,-4(fp)
 323276c:	10c0132e 	bgeu	r2,r3,32327bc <sbdrop+0xe4>
      {
         m->m_len -= len;
 3232770:	e0bffd17 	ldw	r2,-12(fp)
 3232774:	10c00217 	ldw	r3,8(r2)
 3232778:	e0bfff17 	ldw	r2,-4(fp)
 323277c:	1887c83a 	sub	r3,r3,r2
 3232780:	e0bffd17 	ldw	r2,-12(fp)
 3232784:	10c00215 	stw	r3,8(r2)
         m->m_data += len;
 3232788:	e0bffd17 	ldw	r2,-12(fp)
 323278c:	10c00317 	ldw	r3,12(r2)
 3232790:	e0bfff17 	ldw	r2,-4(fp)
 3232794:	1887883a 	add	r3,r3,r2
 3232798:	e0bffd17 	ldw	r2,-12(fp)
 323279c:	10c00315 	stw	r3,12(r2)
         sb->sb_cc -= len;
 32327a0:	e0bffe17 	ldw	r2,-8(fp)
 32327a4:	10c00017 	ldw	r3,0(r2)
 32327a8:	e0bfff17 	ldw	r2,-4(fp)
 32327ac:	1887c83a 	sub	r3,r3,r2
 32327b0:	e0bffe17 	ldw	r2,-8(fp)
 32327b4:	10c00015 	stw	r3,0(r2)
         break;
 32327b8:	00002106 	br	3232840 <sbdrop+0x168>
      }
      len -= m->m_len;
 32327bc:	e0ffff17 	ldw	r3,-4(fp)
 32327c0:	e0bffd17 	ldw	r2,-12(fp)
 32327c4:	10800217 	ldw	r2,8(r2)
 32327c8:	1885c83a 	sub	r2,r3,r2
 32327cc:	e0bfff15 	stw	r2,-4(fp)
      sbfree (sb, m);
 32327d0:	e0bffe17 	ldw	r2,-8(fp)
 32327d4:	10c00017 	ldw	r3,0(r2)
 32327d8:	e0bffd17 	ldw	r2,-12(fp)
 32327dc:	10800217 	ldw	r2,8(r2)
 32327e0:	1887c83a 	sub	r3,r3,r2
 32327e4:	e0bffe17 	ldw	r2,-8(fp)
 32327e8:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 32327ec:	e13ffd17 	ldw	r4,-12(fp)
 32327f0:	322bb340 	call	322bb34 <m_free>
 32327f4:	e0bffc15 	stw	r2,-16(fp)
      m = mn;
 32327f8:	e0bffc17 	ldw	r2,-16(fp)
 32327fc:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((m = sb->sb_mb) != NULL)
      next = m->m_act;
   else
      next = NULL;
   while (len > 0) 
 3232800:	e0bfff17 	ldw	r2,-4(fp)
 3232804:	10800048 	cmpgei	r2,r2,1
 3232808:	103fc61e 	bne	r2,zero,3232724 <sbdrop+0x4c>
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 323280c:	00000c06 	br	3232840 <sbdrop+0x168>
   {
      sbfree(sb, m);
 3232810:	e0bffe17 	ldw	r2,-8(fp)
 3232814:	10c00017 	ldw	r3,0(r2)
 3232818:	e0bffd17 	ldw	r2,-12(fp)
 323281c:	10800217 	ldw	r2,8(r2)
 3232820:	1887c83a 	sub	r3,r3,r2
 3232824:	e0bffe17 	ldw	r2,-8(fp)
 3232828:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 323282c:	e13ffd17 	ldw	r4,-12(fp)
 3232830:	322bb340 	call	322bb34 <m_free>
 3232834:	e0bffc15 	stw	r2,-16(fp)
      m = mn;
 3232838:	e0bffc17 	ldw	r2,-16(fp)
 323283c:	e0bffd15 	stw	r2,-12(fp)
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 3232840:	e0bffd17 	ldw	r2,-12(fp)
 3232844:	1005003a 	cmpeq	r2,r2,zero
 3232848:	1000041e 	bne	r2,zero,323285c <sbdrop+0x184>
 323284c:	e0bffd17 	ldw	r2,-12(fp)
 3232850:	10800217 	ldw	r2,8(r2)
 3232854:	1005003a 	cmpeq	r2,r2,zero
 3232858:	103fed1e 	bne	r2,zero,3232810 <sbdrop+0x138>
   {
      sbfree(sb, m);
      MFREE(m, mn);
      m = mn;
   }
   if (m) 
 323285c:	e0bffd17 	ldw	r2,-12(fp)
 3232860:	1005003a 	cmpeq	r2,r2,zero
 3232864:	1000071e 	bne	r2,zero,3232884 <sbdrop+0x1ac>
   {
      sb->sb_mb = m;
 3232868:	e0fffe17 	ldw	r3,-8(fp)
 323286c:	e0bffd17 	ldw	r2,-12(fp)
 3232870:	18800615 	stw	r2,24(r3)
      m->m_act = next;
 3232874:	e0fffd17 	ldw	r3,-12(fp)
 3232878:	e0bffb17 	ldw	r2,-20(fp)
 323287c:	18800715 	stw	r2,28(r3)
 3232880:	00000306 	br	3232890 <sbdrop+0x1b8>
   } else
      sb->sb_mb = next;
 3232884:	e0fffe17 	ldw	r3,-8(fp)
 3232888:	e0bffb17 	ldw	r2,-20(fp)
 323288c:	18800615 	stw	r2,24(r3)
   EXIT_CRIT_SECTION(sb);
 3232890:	322ade80 	call	322ade8 <irq_Unmask>
}
 3232894:	e037883a 	mov	sp,fp
 3232898:	dfc00117 	ldw	ra,4(sp)
 323289c:	df000017 	ldw	fp,0(sp)
 32328a0:	dec00204 	addi	sp,sp,8
 32328a4:	f800283a 	ret

032328a8 <sbdropend>:
 * RETURNS: 
 */

void
sbdropend(struct sockbuf * sb, struct mbuf * m)
{
 32328a8:	defff904 	addi	sp,sp,-28
 32328ac:	dfc00615 	stw	ra,24(sp)
 32328b0:	df000515 	stw	fp,20(sp)
 32328b4:	df000504 	addi	fp,sp,20
 32328b8:	e13ffe15 	stw	r4,-8(fp)
 32328bc:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  nmb, *   pmb;
   int   len;
   ENTER_CRIT_SECTION(sb);
 32328c0:	322ad8c0 	call	322ad8c <irq_Mask>
   len = mbuf_len(m);
 32328c4:	e13fff17 	ldw	r4,-4(fp)
 32328c8:	322c1a00 	call	322c1a0 <mbuf_len>
 32328cc:	e0bffb15 	stw	r2,-20(fp)
   if (len > 0)
 32328d0:	e0bffb17 	ldw	r2,-20(fp)
 32328d4:	10800050 	cmplti	r2,r2,1
 32328d8:	1000051e 	bne	r2,zero,32328f0 <sbdropend+0x48>
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
 32328dc:	e0bffe17 	ldw	r2,-8(fp)
 32328e0:	11000617 	ldw	r4,24(r2)
 32328e4:	e0bffb17 	ldw	r2,-20(fp)
 32328e8:	008bc83a 	sub	r5,zero,r2
 32328ec:	322bfd00 	call	322bfd0 <m_adj>
   nmb = sb->sb_mb;
 32328f0:	e0bffe17 	ldw	r2,-8(fp)
 32328f4:	10800617 	ldw	r2,24(r2)
 32328f8:	e0bffd15 	stw	r2,-12(fp)
   pmb = NULL;
 32328fc:	e03ffc15 	stw	zero,-16(fp)
   if (sb->sb_mb->m_len == 0)
 3232900:	e0bffe17 	ldw	r2,-8(fp)
 3232904:	10800617 	ldw	r2,24(r2)
 3232908:	10800217 	ldw	r2,8(r2)
 323290c:	1004c03a 	cmpne	r2,r2,zero
 3232910:	1000081e 	bne	r2,zero,3232934 <sbdropend+0x8c>
      sb->sb_mb = NULL;
 3232914:	e0bffe17 	ldw	r2,-8(fp)
 3232918:	10000615 	stw	zero,24(r2)
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 323291c:	00000506 	br	3232934 <sbdropend+0x8c>
   {
      pmb = nmb;  /* Remember previous */
 3232920:	e0bffd17 	ldw	r2,-12(fp)
 3232924:	e0bffc15 	stw	r2,-16(fp)
      nmb = nmb->m_next;    
 3232928:	e0bffd17 	ldw	r2,-12(fp)
 323292c:	10800617 	ldw	r2,24(r2)
 3232930:	e0bffd15 	stw	r2,-12(fp)
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
   nmb = sb->sb_mb;
   pmb = NULL;
   if (sb->sb_mb->m_len == 0)
      sb->sb_mb = NULL;
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 3232934:	e0bffd17 	ldw	r2,-12(fp)
 3232938:	1005003a 	cmpeq	r2,r2,zero
 323293c:	1000041e 	bne	r2,zero,3232950 <sbdropend+0xa8>
 3232940:	e0bffd17 	ldw	r2,-12(fp)
 3232944:	10800217 	ldw	r2,8(r2)
 3232948:	1004c03a 	cmpne	r2,r2,zero
 323294c:	103ff41e 	bne	r2,zero,3232920 <sbdropend+0x78>
   {
      pmb = nmb;  /* Remember previous */
      nmb = nmb->m_next;    
   }
   if (nmb && (nmb->m_len == 0)) /* Assume once 0 len found, all the rest */
 3232950:	e0bffd17 	ldw	r2,-12(fp)
 3232954:	1005003a 	cmpeq	r2,r2,zero
 3232958:	10000b1e 	bne	r2,zero,3232988 <sbdropend+0xe0>
 323295c:	e0bffd17 	ldw	r2,-12(fp)
 3232960:	10800217 	ldw	r2,8(r2)
 3232964:	1004c03a 	cmpne	r2,r2,zero
 3232968:	1000071e 	bne	r2,zero,3232988 <sbdropend+0xe0>
   {                             /* are zeroes */ 
      if (pmb != NULL)
 323296c:	e0bffc17 	ldw	r2,-16(fp)
 3232970:	1005003a 	cmpeq	r2,r2,zero
 3232974:	1000021e 	bne	r2,zero,3232980 <sbdropend+0xd8>
         pmb->m_next = NULL;
 3232978:	e0bffc17 	ldw	r2,-16(fp)
 323297c:	10000615 	stw	zero,24(r2)
      m_freem(nmb);            
 3232980:	e13ffd17 	ldw	r4,-12(fp)
 3232984:	322bc680 	call	322bc68 <m_freem>
   }
   sb->sb_cc -= len;       /* Do a sbfree using the len */
 3232988:	e0bffe17 	ldw	r2,-8(fp)
 323298c:	10c00017 	ldw	r3,0(r2)
 3232990:	e0bffb17 	ldw	r2,-20(fp)
 3232994:	1887c83a 	sub	r3,r3,r2
 3232998:	e0bffe17 	ldw	r2,-8(fp)
 323299c:	10c00015 	stw	r3,0(r2)
   EXIT_CRIT_SECTION(sb);
 32329a0:	322ade80 	call	322ade8 <irq_Unmask>
}
 32329a4:	e037883a 	mov	sp,fp
 32329a8:	dfc00117 	ldw	ra,4(sp)
 32329ac:	df000017 	ldw	fp,0(sp)
 32329b0:	dec00204 	addi	sp,sp,8
 32329b4:	f800283a 	ret

032329b8 <sbdroprecord>:
 * RETURNS: 
 */

void
sbdroprecord(struct sockbuf * sb)
{
 32329b8:	defffb04 	addi	sp,sp,-20
 32329bc:	dfc00415 	stw	ra,16(sp)
 32329c0:	df000315 	stw	fp,12(sp)
 32329c4:	df000304 	addi	fp,sp,12
 32329c8:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  m, *  mn;

   ENTER_CRIT_SECTION(sb);
 32329cc:	322ad8c0 	call	322ad8c <irq_Mask>
   m = sb->sb_mb;
 32329d0:	e0bfff17 	ldw	r2,-4(fp)
 32329d4:	10800617 	ldw	r2,24(r2)
 32329d8:	e0bffe15 	stw	r2,-8(fp)
   if (m)
 32329dc:	e0bffe17 	ldw	r2,-8(fp)
 32329e0:	1005003a 	cmpeq	r2,r2,zero
 32329e4:	1000131e 	bne	r2,zero,3232a34 <sbdroprecord+0x7c>
   {  sb->sb_mb = m->m_act;
 32329e8:	e0bffe17 	ldw	r2,-8(fp)
 32329ec:	10c00717 	ldw	r3,28(r2)
 32329f0:	e0bfff17 	ldw	r2,-4(fp)
 32329f4:	10c00615 	stw	r3,24(r2)
      do 
      {  sbfree(sb, m);
 32329f8:	e0bfff17 	ldw	r2,-4(fp)
 32329fc:	10c00017 	ldw	r3,0(r2)
 3232a00:	e0bffe17 	ldw	r2,-8(fp)
 3232a04:	10800217 	ldw	r2,8(r2)
 3232a08:	1887c83a 	sub	r3,r3,r2
 3232a0c:	e0bfff17 	ldw	r2,-4(fp)
 3232a10:	10c00015 	stw	r3,0(r2)
         MFREE(m, mn);
 3232a14:	e13ffe17 	ldw	r4,-8(fp)
 3232a18:	322bb340 	call	322bb34 <m_free>
 3232a1c:	e0bffd15 	stw	r2,-12(fp)
      } while ((m = mn) != NULL);
 3232a20:	e0bffd17 	ldw	r2,-12(fp)
 3232a24:	e0bffe15 	stw	r2,-8(fp)
 3232a28:	e0bffe17 	ldw	r2,-8(fp)
 3232a2c:	1004c03a 	cmpne	r2,r2,zero
 3232a30:	103ff11e 	bne	r2,zero,32329f8 <sbdroprecord+0x40>
         }
   EXIT_CRIT_SECTION(sb);
 3232a34:	322ade80 	call	322ade8 <irq_Unmask>
}
 3232a38:	e037883a 	mov	sp,fp
 3232a3c:	dfc00117 	ldw	ra,4(sp)
 3232a40:	df000017 	ldw	fp,0(sp)
 3232a44:	dec00204 	addi	sp,sp,8
 3232a48:	f800283a 	ret

03232a4c <t_select>:
int
t_select(fd_set * in,   /* lists of sockets to watch */
   fd_set * out,
   fd_set * ex,
   long  tv)   /* ticks to wait */
{
 3232a4c:	defe7204 	addi	sp,sp,-1592
 3232a50:	dfc18d15 	stw	ra,1588(sp)
 3232a54:	df018c15 	stw	fp,1584(sp)
 3232a58:	df018c04 	addi	fp,sp,1584
 3232a5c:	e13ffc15 	stw	r4,-16(fp)
 3232a60:	e17ffd15 	stw	r5,-12(fp)
 3232a64:	e1bffe15 	stw	r6,-8(fp)
 3232a68:	e1ffff15 	stw	r7,-4(fp)
   fd_set obits[3], ibits [3];
   u_long   tmo;
   int   retval   =  0;
 3232a6c:	e03e7415 	stw	zero,-1584(fp)

   MEMSET(&obits, 0, sizeof(obits));
 3232a70:	e0be7604 	addi	r2,fp,-1576
 3232a74:	1009883a 	mov	r4,r2
 3232a78:	0180c304 	movi	r6,780
 3232a7c:	000b883a 	mov	r5,zero
 3232a80:	320694c0 	call	320694c <memset>
   MEMSET(&ibits, 0, sizeof(ibits));
 3232a84:	e0bf3904 	addi	r2,fp,-796
 3232a88:	1009883a 	mov	r4,r2
 3232a8c:	0180c304 	movi	r6,780
 3232a90:	000b883a 	mov	r5,zero
 3232a94:	320694c0 	call	320694c <memset>

   if (in)
 3232a98:	e0bffc17 	ldw	r2,-16(fp)
 3232a9c:	1005003a 	cmpeq	r2,r2,zero
 3232aa0:	1000061e 	bne	r2,zero,3232abc <t_select+0x70>
      MEMCPY(&ibits[0], in, sizeof(fd_set));
 3232aa4:	e0bf3904 	addi	r2,fp,-796
 3232aa8:	e0fffc17 	ldw	r3,-16(fp)
 3232aac:	1009883a 	mov	r4,r2
 3232ab0:	180b883a 	mov	r5,r3
 3232ab4:	01804104 	movi	r6,260
 3232ab8:	32067cc0 	call	32067cc <memcpy>
   if (out)
 3232abc:	e0bffd17 	ldw	r2,-12(fp)
 3232ac0:	1005003a 	cmpeq	r2,r2,zero
 3232ac4:	1000071e 	bne	r2,zero,3232ae4 <t_select+0x98>
      MEMCPY(&ibits[1], out, sizeof(fd_set));
 3232ac8:	e0bf3904 	addi	r2,fp,-796
 3232acc:	10804104 	addi	r2,r2,260
 3232ad0:	e0fffd17 	ldw	r3,-12(fp)
 3232ad4:	1009883a 	mov	r4,r2
 3232ad8:	180b883a 	mov	r5,r3
 3232adc:	01804104 	movi	r6,260
 3232ae0:	32067cc0 	call	32067cc <memcpy>
   if (ex)
 3232ae4:	e0bffe17 	ldw	r2,-8(fp)
 3232ae8:	1005003a 	cmpeq	r2,r2,zero
 3232aec:	1000071e 	bne	r2,zero,3232b0c <t_select+0xc0>
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
 3232af0:	e0bf3904 	addi	r2,fp,-796
 3232af4:	10808204 	addi	r2,r2,520
 3232af8:	e0fffe17 	ldw	r3,-8(fp)
 3232afc:	1009883a 	mov	r4,r2
 3232b00:	180b883a 	mov	r5,r3
 3232b04:	01804104 	movi	r6,260
 3232b08:	32067cc0 	call	32067cc <memcpy>
   tmo = cticks + tv;
 3232b0c:	0080c974 	movhi	r2,805
 3232b10:	10925604 	addi	r2,r2,18776
 3232b14:	10c00017 	ldw	r3,0(r2)
 3232b18:	e0bfff17 	ldw	r2,-4(fp)
 3232b1c:	1885883a 	add	r2,r3,r2
 3232b20:	e0be7515 	stw	r2,-1580(fp)

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 3232b24:	e0bf3917 	ldw	r2,-796(fp)
 3232b28:	1004c03a 	cmpne	r2,r2,zero
 3232b2c:	10000e1e 	bne	r2,zero,3232b68 <t_select+0x11c>
 3232b30:	e0bf7a17 	ldw	r2,-536(fp)
 3232b34:	1004c03a 	cmpne	r2,r2,zero
 3232b38:	10000b1e 	bne	r2,zero,3232b68 <t_select+0x11c>
 3232b3c:	e0bfbb17 	ldw	r2,-276(fp)
 3232b40:	1004c03a 	cmpne	r2,r2,zero
 3232b44:	1000081e 	bne	r2,zero,3232b68 <t_select+0x11c>
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 3232b48:	e0bfff17 	ldw	r2,-4(fp)
 3232b4c:	10800050 	cmplti	r2,r2,1
 3232b50:	1000201e 	bne	r2,zero,3232bd4 <t_select+0x188>
         while (tmo > cticks)
         {
            tk_yield();
         }
#else
         TK_SLEEP(tv);
 3232b54:	e0bfff17 	ldw	r2,-4(fp)
 3232b58:	10800044 	addi	r2,r2,1
 3232b5c:	113fffcc 	andi	r4,r2,65535
 3232b60:	321cf780 	call	321cf78 <OSTimeDly>
   if (ex)
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
   tmo = cticks + tv;

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 3232b64:	00001b06 	br	3232bd4 <t_select+0x188>

      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
 3232b68:	0009883a 	mov	r4,zero
 3232b6c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      while ((retval = sock_selscan(ibits, obits)) == 0)
 3232b70:	00000f06 	br	3232bb0 <t_select+0x164>
      {
         if (tv != -1L) 
 3232b74:	e0bfff17 	ldw	r2,-4(fp)
 3232b78:	10bfffe0 	cmpeqi	r2,r2,-1
 3232b7c:	1000051e 	bne	r2,zero,3232b94 <t_select+0x148>
         {
            if (tmo <= cticks)
 3232b80:	0080c974 	movhi	r2,805
 3232b84:	10925604 	addi	r2,r2,18776
 3232b88:	10c00017 	ldw	r3,0(r2)
 3232b8c:	e0be7517 	ldw	r2,-1580(fp)
 3232b90:	18800e2e 	bgeu	r3,r2,3232bcc <t_select+0x180>
               break;
         }
         select_wait = 1;
 3232b94:	00c0c974 	movhi	r3,805
 3232b98:	18d25e04 	addi	r3,r3,18808
 3232b9c:	00800044 	movi	r2,1
 3232ba0:	1880000d 	sth	r2,0(r3)
         tcp_sleep (&select_wait);
 3232ba4:	0100c974 	movhi	r4,805
 3232ba8:	21125e04 	addi	r4,r4,18808
 3232bac:	32267600 	call	3226760 <tcp_sleep>
      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
      while ((retval = sock_selscan(ibits, obits)) == 0)
 3232bb0:	e13f3904 	addi	r4,fp,-796
 3232bb4:	e17e7604 	addi	r5,fp,-1576
 3232bb8:	3232c6c0 	call	3232c6c <sock_selscan>
 3232bbc:	e0be7415 	stw	r2,-1584(fp)
 3232bc0:	e0be7417 	ldw	r2,-1584(fp)
 3232bc4:	1005003a 	cmpeq	r2,r2,zero
 3232bc8:	103fea1e 	bne	r2,zero,3232b74 <t_select+0x128>
               break;
         }
         select_wait = 1;
         tcp_sleep (&select_wait);
      }
      UNLOCK_NET_RESOURCE(NET_RESID);
 3232bcc:	0009883a 	mov	r4,zero
 3232bd0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   }

   if (retval >= 0)
 3232bd4:	e0be7417 	ldw	r2,-1584(fp)
 3232bd8:	1004803a 	cmplt	r2,r2,zero
 3232bdc:	10001d1e 	bne	r2,zero,3232c54 <t_select+0x208>
   {
      if (in)
 3232be0:	e0bffc17 	ldw	r2,-16(fp)
 3232be4:	1005003a 	cmpeq	r2,r2,zero
 3232be8:	1000061e 	bne	r2,zero,3232c04 <t_select+0x1b8>
         MEMCPY(in, &obits[0], sizeof(fd_set));
 3232bec:	e0bffc17 	ldw	r2,-16(fp)
 3232bf0:	e0fe7604 	addi	r3,fp,-1576
 3232bf4:	1009883a 	mov	r4,r2
 3232bf8:	180b883a 	mov	r5,r3
 3232bfc:	01804104 	movi	r6,260
 3232c00:	32067cc0 	call	32067cc <memcpy>
      if (out)
 3232c04:	e0bffd17 	ldw	r2,-12(fp)
 3232c08:	1005003a 	cmpeq	r2,r2,zero
 3232c0c:	1000071e 	bne	r2,zero,3232c2c <t_select+0x1e0>
         MEMCPY(out, &obits[1], sizeof(fd_set));
 3232c10:	e0be7604 	addi	r2,fp,-1576
 3232c14:	10c04104 	addi	r3,r2,260
 3232c18:	e0bffd17 	ldw	r2,-12(fp)
 3232c1c:	1009883a 	mov	r4,r2
 3232c20:	180b883a 	mov	r5,r3
 3232c24:	01804104 	movi	r6,260
 3232c28:	32067cc0 	call	32067cc <memcpy>
      if (ex)
 3232c2c:	e0bffe17 	ldw	r2,-8(fp)
 3232c30:	1005003a 	cmpeq	r2,r2,zero
 3232c34:	1000071e 	bne	r2,zero,3232c54 <t_select+0x208>
         MEMCPY(ex, &obits[2], sizeof(fd_set));
 3232c38:	e0be7604 	addi	r2,fp,-1576
 3232c3c:	10c08204 	addi	r3,r2,520
 3232c40:	e0bffe17 	ldw	r2,-8(fp)
 3232c44:	1009883a 	mov	r4,r2
 3232c48:	180b883a 	mov	r5,r3
 3232c4c:	01804104 	movi	r6,260
 3232c50:	32067cc0 	call	32067cc <memcpy>
   }
   return retval;
 3232c54:	e0be7417 	ldw	r2,-1584(fp)
}
 3232c58:	e037883a 	mov	sp,fp
 3232c5c:	dfc00117 	ldw	ra,4(sp)
 3232c60:	df000017 	ldw	fp,0(sp)
 3232c64:	dec00204 	addi	sp,sp,8
 3232c68:	f800283a 	ret

03232c6c <sock_selscan>:
 * RETURNS: 
 */

int
sock_selscan(fd_set * ibits, fd_set * obits)
{
 3232c6c:	defff504 	addi	sp,sp,-44
 3232c70:	dfc00a15 	stw	ra,40(sp)
 3232c74:	df000915 	stw	fp,36(sp)
 3232c78:	df000904 	addi	fp,sp,36
 3232c7c:	e13ffd15 	stw	r4,-12(fp)
 3232c80:	e17ffe15 	stw	r5,-8(fp)
   fd_set *in, *out;
   int   which;
   int   sock;
   int   flag  =  0;
 3232c84:	e03ff815 	stw	zero,-32(fp)
   int   num_sel  =  0;
 3232c88:	e03ff715 	stw	zero,-36(fp)

   for (which = 0; which < 3; which++)
 3232c8c:	e03ffa15 	stw	zero,-24(fp)
 3232c90:	00004306 	br	3232da0 <sock_selscan+0x134>
   {
      switch (which)
 3232c94:	e0bffa17 	ldw	r2,-24(fp)
 3232c98:	e0bfff15 	stw	r2,-4(fp)
 3232c9c:	e0ffff17 	ldw	r3,-4(fp)
 3232ca0:	18800060 	cmpeqi	r2,r3,1
 3232ca4:	10000a1e 	bne	r2,zero,3232cd0 <sock_selscan+0x64>
 3232ca8:	e0ffff17 	ldw	r3,-4(fp)
 3232cac:	188000a0 	cmpeqi	r2,r3,2
 3232cb0:	10000a1e 	bne	r2,zero,3232cdc <sock_selscan+0x70>
 3232cb4:	e0ffff17 	ldw	r3,-4(fp)
 3232cb8:	1805003a 	cmpeq	r2,r3,zero
 3232cbc:	1000011e 	bne	r2,zero,3232cc4 <sock_selscan+0x58>
 3232cc0:	00000706 	br	3232ce0 <sock_selscan+0x74>
      {
      case 0:
         flag = SOREAD; break;
 3232cc4:	00800044 	movi	r2,1
 3232cc8:	e0bff815 	stw	r2,-32(fp)
 3232ccc:	00000406 	br	3232ce0 <sock_selscan+0x74>

      case 1:
         flag = SOWRITE; break;
 3232cd0:	00800084 	movi	r2,2
 3232cd4:	e0bff815 	stw	r2,-32(fp)
 3232cd8:	00000106 	br	3232ce0 <sock_selscan+0x74>

      case 2:
         flag = 0; break;
 3232cdc:	e03ff815 	stw	zero,-32(fp)
      }
      in = &ibits [which];
 3232ce0:	e0bffa17 	ldw	r2,-24(fp)
 3232ce4:	10804124 	muli	r2,r2,260
 3232ce8:	1007883a 	mov	r3,r2
 3232cec:	e0bffd17 	ldw	r2,-12(fp)
 3232cf0:	1885883a 	add	r2,r3,r2
 3232cf4:	e0bffc15 	stw	r2,-16(fp)
      out = &obits [which];
 3232cf8:	e0bffa17 	ldw	r2,-24(fp)
 3232cfc:	10804124 	muli	r2,r2,260
 3232d00:	1007883a 	mov	r3,r2
 3232d04:	e0bffe17 	ldw	r2,-8(fp)
 3232d08:	1885883a 	add	r2,r3,r2
 3232d0c:	e0bffb15 	stw	r2,-20(fp)
      for (sock = 0; sock < (int)in->fd_count; sock++)
 3232d10:	e03ff915 	stw	zero,-28(fp)
 3232d14:	00001a06 	br	3232d80 <sock_selscan+0x114>
      {
         if (sock_select (in->fd_array[sock], flag))
 3232d18:	e0bff917 	ldw	r2,-28(fp)
 3232d1c:	e0fffc17 	ldw	r3,-16(fp)
 3232d20:	1085883a 	add	r2,r2,r2
 3232d24:	1085883a 	add	r2,r2,r2
 3232d28:	10c5883a 	add	r2,r2,r3
 3232d2c:	10800104 	addi	r2,r2,4
 3232d30:	11000017 	ldw	r4,0(r2)
 3232d34:	e17ff817 	ldw	r5,-32(fp)
 3232d38:	3232dc40 	call	3232dc4 <sock_select>
 3232d3c:	1005003a 	cmpeq	r2,r2,zero
 3232d40:	10000c1e 	bne	r2,zero,3232d74 <sock_selscan+0x108>
         {
            FD_SET(in->fd_array[sock], out);
 3232d44:	e0bff917 	ldw	r2,-28(fp)
 3232d48:	e0fffc17 	ldw	r3,-16(fp)
 3232d4c:	1085883a 	add	r2,r2,r2
 3232d50:	1085883a 	add	r2,r2,r2
 3232d54:	10c5883a 	add	r2,r2,r3
 3232d58:	10800104 	addi	r2,r2,4
 3232d5c:	11000017 	ldw	r4,0(r2)
 3232d60:	e17ffb17 	ldw	r5,-20(fp)
 3232d64:	32331fc0 	call	32331fc <ifd_set>
            num_sel++;
 3232d68:	e0bff717 	ldw	r2,-36(fp)
 3232d6c:	10800044 	addi	r2,r2,1
 3232d70:	e0bff715 	stw	r2,-36(fp)
      case 2:
         flag = 0; break;
      }
      in = &ibits [which];
      out = &obits [which];
      for (sock = 0; sock < (int)in->fd_count; sock++)
 3232d74:	e0bff917 	ldw	r2,-28(fp)
 3232d78:	10800044 	addi	r2,r2,1
 3232d7c:	e0bff915 	stw	r2,-28(fp)
 3232d80:	e0bffc17 	ldw	r2,-16(fp)
 3232d84:	10800017 	ldw	r2,0(r2)
 3232d88:	1007883a 	mov	r3,r2
 3232d8c:	e0bff917 	ldw	r2,-28(fp)
 3232d90:	10ffe116 	blt	r2,r3,3232d18 <sock_selscan+0xac>
   int   which;
   int   sock;
   int   flag  =  0;
   int   num_sel  =  0;

   for (which = 0; which < 3; which++)
 3232d94:	e0bffa17 	ldw	r2,-24(fp)
 3232d98:	10800044 	addi	r2,r2,1
 3232d9c:	e0bffa15 	stw	r2,-24(fp)
 3232da0:	e0bffa17 	ldw	r2,-24(fp)
 3232da4:	108000d0 	cmplti	r2,r2,3
 3232da8:	103fba1e 	bne	r2,zero,3232c94 <sock_selscan+0x28>
            FD_SET(in->fd_array[sock], out);
            num_sel++;
         }
      }
   }
   return num_sel;
 3232dac:	e0bff717 	ldw	r2,-36(fp)
}
 3232db0:	e037883a 	mov	sp,fp
 3232db4:	dfc00117 	ldw	ra,4(sp)
 3232db8:	df000017 	ldw	fp,0(sp)
 3232dbc:	dec00204 	addi	sp,sp,8
 3232dc0:	f800283a 	ret

03232dc4 <sock_select>:
 * RETURNS: 
 */

int
sock_select(long sock, int flag)
{
 3232dc4:	defff904 	addi	sp,sp,-28
 3232dc8:	dfc00615 	stw	ra,24(sp)
 3232dcc:	df000515 	stw	fp,20(sp)
 3232dd0:	df000504 	addi	fp,sp,20
 3232dd4:	e13ffd15 	stw	r4,-12(fp)
 3232dd8:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so;
   int   ready =  0;
 3232ddc:	e03ffb15 	stw	zero,-20(fp)

   so = LONG2SO(sock);
 3232de0:	e0bffd17 	ldw	r2,-12(fp)
 3232de4:	10bff804 	addi	r2,r2,-32
 3232de8:	1085883a 	add	r2,r2,r2
 3232dec:	1085883a 	add	r2,r2,r2
 3232df0:	e0bffc15 	stw	r2,-16(fp)

   switch (flag) 
 3232df4:	e0bffe17 	ldw	r2,-8(fp)
 3232df8:	e0bfff15 	stw	r2,-4(fp)
 3232dfc:	e0ffff17 	ldw	r3,-4(fp)
 3232e00:	18800060 	cmpeqi	r2,r3,1
 3232e04:	1000071e 	bne	r2,zero,3232e24 <sock_select+0x60>
 3232e08:	e0ffff17 	ldw	r3,-4(fp)
 3232e0c:	188000a0 	cmpeqi	r2,r3,2
 3232e10:	1000251e 	bne	r2,zero,3232ea8 <sock_select+0xe4>
 3232e14:	e0ffff17 	ldw	r3,-4(fp)
 3232e18:	1805003a 	cmpeq	r2,r3,zero
 3232e1c:	1000491e 	bne	r2,zero,3232f44 <sock_select+0x180>
 3232e20:	00006706 	br	3232fc0 <sock_select+0x1fc>
   {
   case SOREAD:
      /* can we read something from so? */
      if (so->so_rcv.sb_cc)
 3232e24:	e0bffc17 	ldw	r2,-16(fp)
 3232e28:	10800a17 	ldw	r2,40(r2)
 3232e2c:	1005003a 	cmpeq	r2,r2,zero
 3232e30:	1000031e 	bne	r2,zero,3232e40 <sock_select+0x7c>
      {
         ready = 1;
 3232e34:	00800044 	movi	r2,1
 3232e38:	e0bffb15 	stw	r2,-20(fp)
         break;
 3232e3c:	00006006 	br	3232fc0 <sock_select+0x1fc>
      }
      if (so->so_state & SS_CANTRCVMORE)
 3232e40:	e0bffc17 	ldw	r2,-16(fp)
 3232e44:	1080088b 	ldhu	r2,34(r2)
 3232e48:	10bfffcc 	andi	r2,r2,65535
 3232e4c:	1080080c 	andi	r2,r2,32
 3232e50:	1005003a 	cmpeq	r2,r2,zero
 3232e54:	1000031e 	bne	r2,zero,3232e64 <sock_select+0xa0>
      {  ready = 1;
 3232e58:	00800044 	movi	r2,1
 3232e5c:	e0bffb15 	stw	r2,-20(fp)
         break;
 3232e60:	00005706 	br	3232fc0 <sock_select+0x1fc>
      }
      if (so->so_qlen)  /* attach is ready */
 3232e64:	e0bffc17 	ldw	r2,-16(fp)
 3232e68:	10801e43 	ldbu	r2,121(r2)
 3232e6c:	10803fcc 	andi	r2,r2,255
 3232e70:	1080201c 	xori	r2,r2,128
 3232e74:	10bfe004 	addi	r2,r2,-128
 3232e78:	1005003a 	cmpeq	r2,r2,zero
 3232e7c:	1000031e 	bne	r2,zero,3232e8c <sock_select+0xc8>
      {
         ready = 1;
 3232e80:	00800044 	movi	r2,1
 3232e84:	e0bffb15 	stw	r2,-20(fp)
         break;
 3232e88:	00004d06 	br	3232fc0 <sock_select+0x1fc>
         }
      }
#endif   /* TCP_ZEROCOPY */

      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
 3232e8c:	e0bffc17 	ldw	r2,-16(fp)
 3232e90:	1080110b 	ldhu	r2,68(r2)
 3232e94:	10800214 	ori	r2,r2,8
 3232e98:	1007883a 	mov	r3,r2
 3232e9c:	e0bffc17 	ldw	r2,-16(fp)
 3232ea0:	10c0110d 	sth	r3,68(r2)
      break;
 3232ea4:	00004606 	br	3232fc0 <sock_select+0x1fc>

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 3232ea8:	e0bffc17 	ldw	r2,-16(fp)
 3232eac:	10801317 	ldw	r2,76(r2)
 3232eb0:	1007883a 	mov	r3,r2
 3232eb4:	e0bffc17 	ldw	r2,-16(fp)
 3232eb8:	10801217 	ldw	r2,72(r2)
 3232ebc:	1885c83a 	sub	r2,r3,r2
 3232ec0:	1004803a 	cmplt	r2,r2,zero
 3232ec4:	10001b1e 	bne	r2,zero,3232f34 <sock_select+0x170>
 3232ec8:	e0bffc17 	ldw	r2,-16(fp)
 3232ecc:	10c01317 	ldw	r3,76(r2)
 3232ed0:	e0bffc17 	ldw	r2,-16(fp)
 3232ed4:	10801217 	ldw	r2,72(r2)
 3232ed8:	18801626 	beq	r3,r2,3232f34 <sock_select+0x170>
 3232edc:	e0bffc17 	ldw	r2,-16(fp)
 3232ee0:	1080088b 	ldhu	r2,34(r2)
 3232ee4:	10bfffcc 	andi	r2,r2,65535
 3232ee8:	1080008c 	andi	r2,r2,2
 3232eec:	1004c03a 	cmpne	r2,r2,zero
 3232ef0:	10000d1e 	bne	r2,zero,3232f28 <sock_select+0x164>
 3232ef4:	e0bffc17 	ldw	r2,-16(fp)
 3232ef8:	10800217 	ldw	r2,8(r2)
 3232efc:	1080010b 	ldhu	r2,4(r2)
 3232f00:	10bfffcc 	andi	r2,r2,65535
 3232f04:	1080010c 	andi	r2,r2,4
 3232f08:	1005003a 	cmpeq	r2,r2,zero
 3232f0c:	1000061e 	bne	r2,zero,3232f28 <sock_select+0x164>
 3232f10:	e0bffc17 	ldw	r2,-16(fp)
 3232f14:	1080088b 	ldhu	r2,34(r2)
 3232f18:	10bfffcc 	andi	r2,r2,65535
 3232f1c:	1080040c 	andi	r2,r2,16
 3232f20:	1005003a 	cmpeq	r2,r2,zero
 3232f24:	1000031e 	bne	r2,zero,3232f34 <sock_select+0x170>
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
           ((so)->so_state & SS_CANTSENDMORE)))
      {
         ready = 1;
 3232f28:	00800044 	movi	r2,1
 3232f2c:	e0bffb15 	stw	r2,-20(fp)
         break;
 3232f30:	00002306 	br	3232fc0 <sock_select+0x1fc>
      }
      sbselqueue (&so->so_snd);
 3232f34:	e0bffc17 	ldw	r2,-16(fp)
 3232f38:	11001204 	addi	r4,r2,72
 3232f3c:	3231e6c0 	call	3231e6c <sbselqueue>
      break;
 3232f40:	00001f06 	br	3232fc0 <sock_select+0x1fc>

   case 0:
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
 3232f44:	e0bffc17 	ldw	r2,-16(fp)
 3232f48:	10801a17 	ldw	r2,104(r2)
 3232f4c:	1004c03a 	cmpne	r2,r2,zero
 3232f50:	1000061e 	bne	r2,zero,3232f6c <sock_select+0x1a8>
 3232f54:	e0bffc17 	ldw	r2,-16(fp)
 3232f58:	1080088b 	ldhu	r2,34(r2)
 3232f5c:	10bfffcc 	andi	r2,r2,65535
 3232f60:	1080100c 	andi	r2,r2,64
 3232f64:	1005003a 	cmpeq	r2,r2,zero
 3232f68:	1000031e 	bne	r2,zero,3232f78 <sock_select+0x1b4>
      {
         ready = 1;
 3232f6c:	00800044 	movi	r2,1
 3232f70:	e0bffb15 	stw	r2,-20(fp)
         break;
 3232f74:	00001206 	br	3232fc0 <sock_select+0x1fc>
      }
      if (so->so_error &&
 3232f78:	e0bffc17 	ldw	r2,-16(fp)
 3232f7c:	10800617 	ldw	r2,24(r2)
 3232f80:	1005003a 	cmpeq	r2,r2,zero
 3232f84:	10000b1e 	bne	r2,zero,3232fb4 <sock_select+0x1f0>
 3232f88:	e0bffc17 	ldw	r2,-16(fp)
 3232f8c:	10800617 	ldw	r2,24(r2)
 3232f90:	10801de0 	cmpeqi	r2,r2,119
 3232f94:	1000071e 	bne	r2,zero,3232fb4 <sock_select+0x1f0>
 3232f98:	e0bffc17 	ldw	r2,-16(fp)
 3232f9c:	10800617 	ldw	r2,24(r2)
 3232fa0:	108002e0 	cmpeqi	r2,r2,11
 3232fa4:	1000031e 	bne	r2,zero,3232fb4 <sock_select+0x1f0>
          (so->so_error != EINPROGRESS) &&
          (so->so_error != EWOULDBLOCK))
      {
         ready = 1;
 3232fa8:	00800044 	movi	r2,1
 3232fac:	e0bffb15 	stw	r2,-20(fp)
         break;
 3232fb0:	00000306 	br	3232fc0 <sock_select+0x1fc>
      }
      sbselqueue(&so->so_rcv);
 3232fb4:	e0bffc17 	ldw	r2,-16(fp)
 3232fb8:	11000a04 	addi	r4,r2,40
 3232fbc:	3231e6c0 	call	3231e6c <sbselqueue>
      break;
   }

   return ready;
 3232fc0:	e0bffb17 	ldw	r2,-20(fp)
}
 3232fc4:	e037883a 	mov	sp,fp
 3232fc8:	dfc00117 	ldw	ra,4(sp)
 3232fcc:	df000017 	ldw	fp,0(sp)
 3232fd0:	dec00204 	addi	sp,sp,8
 3232fd4:	f800283a 	ret

03232fd8 <in_pcbnotify>:
void
in_pcbnotify(struct inpcb * head, 
   struct in_addr *  dst,
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
 3232fd8:	defff804 	addi	sp,sp,-32
 3232fdc:	dfc00715 	stw	ra,28(sp)
 3232fe0:	df000615 	stw	fp,24(sp)
 3232fe4:	df000604 	addi	fp,sp,24
 3232fe8:	e13ffc15 	stw	r4,-16(fp)
 3232fec:	e17ffd15 	stw	r5,-12(fp)
 3232ff0:	e1bffe15 	stw	r6,-8(fp)
 3232ff4:	e1ffff15 	stw	r7,-4(fp)
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 3232ff8:	e0bffc17 	ldw	r2,-16(fp)
 3232ffc:	10800017 	ldw	r2,0(r2)
 3233000:	e0bffb15 	stw	r2,-20(fp)
 3233004:	00001f06 	br	3233084 <in_pcbnotify+0xac>
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 3233008:	e0bffb17 	ldw	r2,-20(fp)
 323300c:	10c00317 	ldw	r3,12(r2)
 3233010:	e0bffd17 	ldw	r2,-12(fp)
 3233014:	10800017 	ldw	r2,0(r2)
 3233018:	1880041e 	bne	r3,r2,323302c <in_pcbnotify+0x54>
 323301c:	e0bffb17 	ldw	r2,-20(fp)
 3233020:	10800817 	ldw	r2,32(r2)
 3233024:	1004c03a 	cmpne	r2,r2,zero
 3233028:	1000041e 	bne	r2,zero,323303c <in_pcbnotify+0x64>
          inp->inp_socket == 0) 
      {
         inp = inp->inp_next;
 323302c:	e0bffb17 	ldw	r2,-20(fp)
 3233030:	10800017 	ldw	r2,0(r2)
 3233034:	e0bffb15 	stw	r2,-20(fp)
         continue;
 3233038:	00001206 	br	3233084 <in_pcbnotify+0xac>
      }
      if (errnum) 
 323303c:	e0bffe17 	ldw	r2,-8(fp)
 3233040:	1005003a 	cmpeq	r2,r2,zero
 3233044:	1000041e 	bne	r2,zero,3233058 <in_pcbnotify+0x80>
         inp->inp_socket->so_error = errnum;
 3233048:	e0bffb17 	ldw	r2,-20(fp)
 323304c:	10c00817 	ldw	r3,32(r2)
 3233050:	e0bffe17 	ldw	r2,-8(fp)
 3233054:	18800615 	stw	r2,24(r3)
      oinp = inp;
 3233058:	e0bffb17 	ldw	r2,-20(fp)
 323305c:	e0bffa15 	stw	r2,-24(fp)
      inp = inp->inp_next;
 3233060:	e0bffb17 	ldw	r2,-20(fp)
 3233064:	10800017 	ldw	r2,0(r2)
 3233068:	e0bffb15 	stw	r2,-20(fp)
      if (notify)
 323306c:	e0bfff17 	ldw	r2,-4(fp)
 3233070:	1005003a 	cmpeq	r2,r2,zero
 3233074:	1000031e 	bne	r2,zero,3233084 <in_pcbnotify+0xac>
         (*notify)(oinp);
 3233078:	e0bfff17 	ldw	r2,-4(fp)
 323307c:	e13ffa17 	ldw	r4,-24(fp)
 3233080:	103ee83a 	callr	r2
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 3233084:	e0fffb17 	ldw	r3,-20(fp)
 3233088:	e0bffc17 	ldw	r2,-16(fp)
 323308c:	18bfde1e 	bne	r3,r2,3233008 <in_pcbnotify+0x30>
      oinp = inp;
      inp = inp->inp_next;
      if (notify)
         (*notify)(oinp);
   }
}
 3233090:	e037883a 	mov	sp,fp
 3233094:	dfc00117 	ldw	ra,4(sp)
 3233098:	df000017 	ldw	fp,0(sp)
 323309c:	dec00204 	addi	sp,sp,8
 32330a0:	f800283a 	ret

032330a4 <tcp_notify>:
 * RETURNS: 
 */

void
tcp_notify(struct inpcb * inp)
{
 32330a4:	defffd04 	addi	sp,sp,-12
 32330a8:	dfc00215 	stw	ra,8(sp)
 32330ac:	df000115 	stw	fp,4(sp)
 32330b0:	df000104 	addi	fp,sp,4
 32330b4:	e13fff15 	stw	r4,-4(fp)
   tcp_wakeup(&inp->inp_socket->so_timeo);
 32330b8:	e0bfff17 	ldw	r2,-4(fp)
 32330bc:	10800817 	ldw	r2,32(r2)
 32330c0:	11000904 	addi	r4,r2,36
 32330c4:	32269000 	call	3226900 <tcp_wakeup>
   sorwakeup(inp->inp_socket);
 32330c8:	e0bfff17 	ldw	r2,-4(fp)
 32330cc:	11000817 	ldw	r4,32(r2)
 32330d0:	e0bfff17 	ldw	r2,-4(fp)
 32330d4:	10800817 	ldw	r2,32(r2)
 32330d8:	11400a04 	addi	r5,r2,40
 32330dc:	3231f0c0 	call	3231f0c <sbwakeup>
   sowwakeup(inp->inp_socket);
 32330e0:	e0bfff17 	ldw	r2,-4(fp)
 32330e4:	11000817 	ldw	r4,32(r2)
 32330e8:	e0bfff17 	ldw	r2,-4(fp)
 32330ec:	10800817 	ldw	r2,32(r2)
 32330f0:	11401204 	addi	r5,r2,72
 32330f4:	3231f0c0 	call	3231f0c <sbwakeup>
}
 32330f8:	e037883a 	mov	sp,fp
 32330fc:	dfc00117 	ldw	ra,4(sp)
 3233100:	df000017 	ldw	fp,0(sp)
 3233104:	dec00204 	addi	sp,sp,8
 3233108:	f800283a 	ret

0323310c <ifd_clr>:
 * compacts the fd_set.
 */

void
ifd_clr(long sock, fd_set *set)
{
 323310c:	defffb04 	addi	sp,sp,-20
 3233110:	dfc00415 	stw	ra,16(sp)
 3233114:	df000315 	stw	fp,12(sp)
 3233118:	df000304 	addi	fp,sp,12
 323311c:	e13ffe15 	stw	r4,-8(fp)
 3233120:	e17fff15 	stw	r5,-4(fp)
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 3233124:	e03ffd15 	stw	zero,-12(fp)
 3233128:	00002a06 	br	32331d4 <ifd_clr+0xc8>
   {
      if (set->fd_array[i] == sock)
 323312c:	e0bffd17 	ldw	r2,-12(fp)
 3233130:	e0ffff17 	ldw	r3,-4(fp)
 3233134:	1085883a 	add	r2,r2,r2
 3233138:	1085883a 	add	r2,r2,r2
 323313c:	10c5883a 	add	r2,r2,r3
 3233140:	10800104 	addi	r2,r2,4
 3233144:	10c00017 	ldw	r3,0(r2)
 3233148:	e0bffe17 	ldw	r2,-8(fp)
 323314c:	18801e1e 	bne	r3,r2,32331c8 <ifd_clr+0xbc>
      {
         while (i + 1 < set->fd_count)
 3233150:	00001206 	br	323319c <ifd_clr+0x90>
         {
            set->fd_array[i] = set->fd_array[i + 1];
 3233154:	e13ffd17 	ldw	r4,-12(fp)
 3233158:	e0bffd17 	ldw	r2,-12(fp)
 323315c:	10800044 	addi	r2,r2,1
 3233160:	e0ffff17 	ldw	r3,-4(fp)
 3233164:	1085883a 	add	r2,r2,r2
 3233168:	1085883a 	add	r2,r2,r2
 323316c:	10c5883a 	add	r2,r2,r3
 3233170:	10800104 	addi	r2,r2,4
 3233174:	11400017 	ldw	r5,0(r2)
 3233178:	e0ffff17 	ldw	r3,-4(fp)
 323317c:	2105883a 	add	r2,r4,r4
 3233180:	1085883a 	add	r2,r2,r2
 3233184:	10c5883a 	add	r2,r2,r3
 3233188:	10800104 	addi	r2,r2,4
 323318c:	11400015 	stw	r5,0(r2)
            i++;
 3233190:	e0bffd17 	ldw	r2,-12(fp)
 3233194:	10800044 	addi	r2,r2,1
 3233198:	e0bffd15 	stw	r2,-12(fp)

   for (i = 0; i < set->fd_count ; i++) 
   {
      if (set->fd_array[i] == sock)
      {
         while (i + 1 < set->fd_count)
 323319c:	e0bffd17 	ldw	r2,-12(fp)
 32331a0:	10c00044 	addi	r3,r2,1
 32331a4:	e0bfff17 	ldw	r2,-4(fp)
 32331a8:	10800017 	ldw	r2,0(r2)
 32331ac:	18bfe936 	bltu	r3,r2,3233154 <ifd_clr+0x48>
         {
            set->fd_array[i] = set->fd_array[i + 1];
            i++;
         }
         set->fd_count--;
 32331b0:	e0bfff17 	ldw	r2,-4(fp)
 32331b4:	10800017 	ldw	r2,0(r2)
 32331b8:	10ffffc4 	addi	r3,r2,-1
 32331bc:	e0bfff17 	ldw	r2,-4(fp)
 32331c0:	10c00015 	stw	r3,0(r2)
         return;
 32331c4:	00000806 	br	32331e8 <ifd_clr+0xdc>
void
ifd_clr(long sock, fd_set *set)
{
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 32331c8:	e0bffd17 	ldw	r2,-12(fp)
 32331cc:	10800044 	addi	r2,r2,1
 32331d0:	e0bffd15 	stw	r2,-12(fp)
 32331d4:	e0bfff17 	ldw	r2,-4(fp)
 32331d8:	10c00017 	ldw	r3,0(r2)
 32331dc:	e0bffd17 	ldw	r2,-12(fp)
 32331e0:	10ffd236 	bltu	r2,r3,323312c <ifd_clr+0x20>
         return;
      }
   }

#ifdef NPDEBUG
   dtrap(); /* socket wasn't found in array */
 32331e4:	322ab8c0 	call	322ab8c <dtrap>
#endif
}
 32331e8:	e037883a 	mov	sp,fp
 32331ec:	dfc00117 	ldw	ra,4(sp)
 32331f0:	df000017 	ldw	fp,0(sp)
 32331f4:	dec00204 	addi	sp,sp,8
 32331f8:	f800283a 	ret

032331fc <ifd_set>:
 * called if the fd_set structure is already full.
 */

void
ifd_set(long sock, fd_set *set)
{
 32331fc:	defffc04 	addi	sp,sp,-16
 3233200:	dfc00315 	stw	ra,12(sp)
 3233204:	df000215 	stw	fp,8(sp)
 3233208:	df000204 	addi	fp,sp,8
 323320c:	e13ffe15 	stw	r4,-8(fp)
 3233210:	e17fff15 	stw	r5,-4(fp)
   if (set->fd_count < FD_SETSIZE)
 3233214:	e0bfff17 	ldw	r2,-4(fp)
 3233218:	10800017 	ldw	r2,0(r2)
 323321c:	10801028 	cmpgeui	r2,r2,64
 3233220:	10000d1e 	bne	r2,zero,3233258 <ifd_set+0x5c>
      set->fd_array[set->fd_count++] = sock;
 3233224:	e0bfff17 	ldw	r2,-4(fp)
 3233228:	10c00017 	ldw	r3,0(r2)
 323322c:	e13fff17 	ldw	r4,-4(fp)
 3233230:	18c5883a 	add	r2,r3,r3
 3233234:	1085883a 	add	r2,r2,r2
 3233238:	1105883a 	add	r2,r2,r4
 323323c:	11000104 	addi	r4,r2,4
 3233240:	e0bffe17 	ldw	r2,-8(fp)
 3233244:	20800015 	stw	r2,0(r4)
 3233248:	18c00044 	addi	r3,r3,1
 323324c:	e0bfff17 	ldw	r2,-4(fp)
 3233250:	10c00015 	stw	r3,0(r2)
 3233254:	00000106 	br	323325c <ifd_set+0x60>
#ifdef NPDEBUG
   else
      dtrap();
 3233258:	322ab8c0 	call	322ab8c <dtrap>
#endif
}
 323325c:	e037883a 	mov	sp,fp
 3233260:	dfc00117 	ldw	ra,4(sp)
 3233264:	df000017 	ldw	fp,0(sp)
 3233268:	dec00204 	addi	sp,sp,8
 323326c:	f800283a 	ret

03233270 <ifd_isset>:
 * Tests if a socket is a member of a file descriptor set.
 */

int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
 3233270:	defffb04 	addi	sp,sp,-20
 3233274:	df000415 	stw	fp,16(sp)
 3233278:	df000404 	addi	fp,sp,16
 323327c:	e13ffd15 	stw	r4,-12(fp)
 3233280:	e17ffe15 	stw	r5,-8(fp)
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 3233284:	e03ffc15 	stw	zero,-16(fp)
 3233288:	00000f06 	br	32332c8 <ifd_isset+0x58>
   {
      if (set->fd_array[i] == sock)
 323328c:	e0bffc17 	ldw	r2,-16(fp)
 3233290:	e0fffe17 	ldw	r3,-8(fp)
 3233294:	1085883a 	add	r2,r2,r2
 3233298:	1085883a 	add	r2,r2,r2
 323329c:	10c5883a 	add	r2,r2,r3
 32332a0:	10800104 	addi	r2,r2,4
 32332a4:	10c00017 	ldw	r3,0(r2)
 32332a8:	e0bffd17 	ldw	r2,-12(fp)
 32332ac:	1880031e 	bne	r3,r2,32332bc <ifd_isset+0x4c>
         return TRUE;
 32332b0:	00800044 	movi	r2,1
 32332b4:	e0bfff15 	stw	r2,-4(fp)
 32332b8:	00000806 	br	32332dc <ifd_isset+0x6c>
int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 32332bc:	e0bffc17 	ldw	r2,-16(fp)
 32332c0:	10800044 	addi	r2,r2,1
 32332c4:	e0bffc15 	stw	r2,-16(fp)
 32332c8:	e0bffe17 	ldw	r2,-8(fp)
 32332cc:	10c00017 	ldw	r3,0(r2)
 32332d0:	e0bffc17 	ldw	r2,-16(fp)
 32332d4:	10ffed36 	bltu	r2,r3,323328c <ifd_isset+0x1c>
   {
      if (set->fd_array[i] == sock)
         return TRUE;
   }
   return FALSE;
 32332d8:	e03fff15 	stw	zero,-4(fp)
 32332dc:	e0bfff17 	ldw	r2,-4(fp)
}
 32332e0:	e037883a 	mov	sp,fp
 32332e4:	df000017 	ldw	fp,0(sp)
 32332e8:	dec00104 	addi	sp,sp,4
 32332ec:	f800283a 	ret

032332f0 <ifd_get>:
 * NOTE: This is not part of the original FD_XXX() functionality.
 */

long
ifd_get(unsigned i, fd_set *set)
{
 32332f0:	defffb04 	addi	sp,sp,-20
 32332f4:	dfc00415 	stw	ra,16(sp)
 32332f8:	df000315 	stw	fp,12(sp)
 32332fc:	df000304 	addi	fp,sp,12
 3233300:	e13ffd15 	stw	r4,-12(fp)
 3233304:	e17ffe15 	stw	r5,-8(fp)
   if (i < set->fd_count)
 3233308:	e0bffe17 	ldw	r2,-8(fp)
 323330c:	10c00017 	ldw	r3,0(r2)
 3233310:	e0bffd17 	ldw	r2,-12(fp)
 3233314:	10c0092e 	bgeu	r2,r3,323333c <ifd_get+0x4c>
      return set->fd_array[i];
 3233318:	e0bffd17 	ldw	r2,-12(fp)
 323331c:	e0fffe17 	ldw	r3,-8(fp)
 3233320:	1085883a 	add	r2,r2,r2
 3233324:	1085883a 	add	r2,r2,r2
 3233328:	10c5883a 	add	r2,r2,r3
 323332c:	10800104 	addi	r2,r2,4
 3233330:	10800017 	ldw	r2,0(r2)
 3233334:	e0bfff15 	stw	r2,-4(fp)
 3233338:	00000306 	br	3233348 <ifd_get+0x58>
   else
   {
#ifdef NPDEBUG
      dtrap();
 323333c:	322ab8c0 	call	322ab8c <dtrap>
#endif
      return INVALID_SOCKET;
 3233340:	00bfffc4 	movi	r2,-1
 3233344:	e0bfff15 	stw	r2,-4(fp)
 3233348:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 323334c:	e037883a 	mov	sp,fp
 3233350:	dfc00117 	ldw	ra,4(sp)
 3233354:	df000017 	ldw	fp,0(sp)
 3233358:	dec00204 	addi	sp,sp,8
 323335c:	f800283a 	ret

03233360 <tcp_reass>:

int
tcp_reass(struct tcpcb * tp, 
   struct tcpiphdr * ti,
   struct mbuf *  ti_mbuf)
{
 3233360:	defff404 	addi	sp,sp,-48
 3233364:	dfc00b15 	stw	ra,44(sp)
 3233368:	df000a15 	stw	fp,40(sp)
 323336c:	df000a04 	addi	fp,sp,40
 3233370:	e13ffc15 	stw	r4,-16(fp)
 3233374:	e17ffd15 	stw	r5,-12(fp)
 3233378:	e1bffe15 	stw	r6,-8(fp)
   struct tcpiphdr * q;
   struct socket *   so =  tp->t_inpcb->inp_socket;
 323337c:	e0bffc17 	ldw	r2,-16(fp)
 3233380:	10800d17 	ldw	r2,52(r2)
 3233384:	10800817 	ldw	r2,32(r2)
 3233388:	e0bffa15 	stw	r2,-24(fp)

   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
 323338c:	e0bffd17 	ldw	r2,-12(fp)
 3233390:	1005003a 	cmpeq	r2,r2,zero
 3233394:	10009c1e 	bne	r2,zero,3233608 <tcp_reass+0x2a8>
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 3233398:	e0bffc17 	ldw	r2,-16(fp)
 323339c:	10800017 	ldw	r2,0(r2)
 32333a0:	e0bffb15 	stw	r2,-20(fp)
 32333a4:	00000a06 	br	32333d0 <tcp_reass+0x70>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
 32333a8:	e0bffb17 	ldw	r2,-20(fp)
 32333ac:	10c00617 	ldw	r3,24(r2)
 32333b0:	e0bffd17 	ldw	r2,-12(fp)
 32333b4:	10800617 	ldw	r2,24(r2)
 32333b8:	1885c83a 	sub	r2,r3,r2
 32333bc:	10800048 	cmpgei	r2,r2,1
 32333c0:	1000061e 	bne	r2,zero,32333dc <tcp_reass+0x7c>

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
       q = (struct tcpiphdr *)q->ti_next)
 32333c4:	e0bffb17 	ldw	r2,-20(fp)
 32333c8:	10800017 	ldw	r2,0(r2)
 32333cc:	e0bffb15 	stw	r2,-20(fp)
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 32333d0:	e0fffc17 	ldw	r3,-16(fp)
 32333d4:	e0bffb17 	ldw	r2,-20(fp)
 32333d8:	10fff31e 	bne	r2,r3,32333a8 <tcp_reass+0x48>
   /*
    * If there is a preceding segment, it may provide some of
    * our data already.  If so, drop the data from the incoming
    * segment.  If it provides all of our data, drop us.
    */
   if ((struct tcpiphdr *)q->ti_prev != (struct tcpiphdr *)tp) 
 32333dc:	e0bffb17 	ldw	r2,-20(fp)
 32333e0:	10800117 	ldw	r2,4(r2)
 32333e4:	1007883a 	mov	r3,r2
 32333e8:	e0bffc17 	ldw	r2,-16(fp)
 32333ec:	18803c26 	beq	r3,r2,32334e0 <tcp_reass+0x180>
   {
      long  i;
      q = (struct tcpiphdr *)q->ti_prev;
 32333f0:	e0bffb17 	ldw	r2,-20(fp)
 32333f4:	10800117 	ldw	r2,4(r2)
 32333f8:	e0bffb15 	stw	r2,-20(fp)
      /* conversion to int (in i) handles seq wraparound */
      i = q->ti_seq + q->ti_len - ti->ti_seq;
 32333fc:	e0bffb17 	ldw	r2,-20(fp)
 3233400:	10c00617 	ldw	r3,24(r2)
 3233404:	e0bffb17 	ldw	r2,-20(fp)
 3233408:	1080028b 	ldhu	r2,10(r2)
 323340c:	10bfffcc 	andi	r2,r2,65535
 3233410:	1887883a 	add	r3,r3,r2
 3233414:	e0bffd17 	ldw	r2,-12(fp)
 3233418:	10800617 	ldw	r2,24(r2)
 323341c:	1885c83a 	sub	r2,r3,r2
 3233420:	e0bff715 	stw	r2,-36(fp)
      if (i > 0) 
 3233424:	e0bff717 	ldw	r2,-36(fp)
 3233428:	10800050 	cmplti	r2,r2,1
 323342c:	1000291e 	bne	r2,zero,32334d4 <tcp_reass+0x174>
      {
         if (i >= (long)ti->ti_len) 
 3233430:	e0bffd17 	ldw	r2,-12(fp)
 3233434:	1080028b 	ldhu	r2,10(r2)
 3233438:	10ffffcc 	andi	r3,r2,65535
 323343c:	e0bff717 	ldw	r2,-36(fp)
 3233440:	10c01416 	blt	r2,r3,3233494 <tcp_reass+0x134>
         {
            tcpstat.tcps_rcvduppack++;
 3233444:	0080c9b4 	movhi	r2,806
 3233448:	10b3ca04 	addi	r2,r2,-12504
 323344c:	10801f17 	ldw	r2,124(r2)
 3233450:	10c00044 	addi	r3,r2,1
 3233454:	0080c9b4 	movhi	r2,806
 3233458:	10b3ca04 	addi	r2,r2,-12504
 323345c:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
 3233460:	0080c9b4 	movhi	r2,806
 3233464:	10b3ca04 	addi	r2,r2,-12504
 3233468:	10c02017 	ldw	r3,128(r2)
 323346c:	e0bffd17 	ldw	r2,-12(fp)
 3233470:	1080028b 	ldhu	r2,10(r2)
 3233474:	10bfffcc 	andi	r2,r2,65535
 3233478:	1887883a 	add	r3,r3,r2
 323347c:	0080c9b4 	movhi	r2,806
 3233480:	10b3ca04 	addi	r2,r2,-12504
 3233484:	10c02015 	stw	r3,128(r2)
            GOTO_DROP;
 3233488:	008025c4 	movi	r2,151
 323348c:	d0a8e915 	stw	r2,-23644(gp)
 3233490:	0000ac06 	br	3233744 <tcp_reass+0x3e4>
         }
         m_adj (ti_mbuf, (int)i);
 3233494:	e13ffe17 	ldw	r4,-8(fp)
 3233498:	e17ff717 	ldw	r5,-36(fp)
 323349c:	322bfd00 	call	322bfd0 <m_adj>
         ti->ti_len -= (short)i;
 32334a0:	e0bffd17 	ldw	r2,-12(fp)
 32334a4:	10c0028b 	ldhu	r3,10(r2)
 32334a8:	e0bff717 	ldw	r2,-36(fp)
 32334ac:	1885c83a 	sub	r2,r3,r2
 32334b0:	1007883a 	mov	r3,r2
 32334b4:	e0bffd17 	ldw	r2,-12(fp)
 32334b8:	10c0028d 	sth	r3,10(r2)
         ti->ti_seq += (tcp_seq)i;
 32334bc:	e0bffd17 	ldw	r2,-12(fp)
 32334c0:	10c00617 	ldw	r3,24(r2)
 32334c4:	e0bff717 	ldw	r2,-36(fp)
 32334c8:	1887883a 	add	r3,r3,r2
 32334cc:	e0bffd17 	ldw	r2,-12(fp)
 32334d0:	10c00615 	stw	r3,24(r2)
      }
      q = (struct tcpiphdr *)(q->ti_next);
 32334d4:	e0bffb17 	ldw	r2,-20(fp)
 32334d8:	10800017 	ldw	r2,0(r2)
 32334dc:	e0bffb15 	stw	r2,-20(fp)
   }
   tcpstat.tcps_rcvoopack++;
 32334e0:	0080c9b4 	movhi	r2,806
 32334e4:	10b3ca04 	addi	r2,r2,-12504
 32334e8:	10802317 	ldw	r2,140(r2)
 32334ec:	10c00044 	addi	r3,r2,1
 32334f0:	0080c9b4 	movhi	r2,806
 32334f4:	10b3ca04 	addi	r2,r2,-12504
 32334f8:	10c02315 	stw	r3,140(r2)
   tcpstat.tcps_rcvoobyte += ti->ti_len;
 32334fc:	0080c9b4 	movhi	r2,806
 3233500:	10b3ca04 	addi	r2,r2,-12504
 3233504:	10c02417 	ldw	r3,144(r2)
 3233508:	e0bffd17 	ldw	r2,-12(fp)
 323350c:	1080028b 	ldhu	r2,10(r2)
 3233510:	10bfffcc 	andi	r2,r2,65535
 3233514:	1887883a 	add	r3,r3,r2
 3233518:	0080c9b4 	movhi	r2,806
 323351c:	10b3ca04 	addi	r2,r2,-12504
 3233520:	10c02415 	stw	r3,144(r2)

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 3233524:	00003106 	br	32335ec <tcp_reass+0x28c>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
 3233528:	e0bffd17 	ldw	r2,-12(fp)
 323352c:	10c00617 	ldw	r3,24(r2)
 3233530:	e0bffd17 	ldw	r2,-12(fp)
 3233534:	1080028b 	ldhu	r2,10(r2)
 3233538:	10bfffcc 	andi	r2,r2,65535
 323353c:	1887883a 	add	r3,r3,r2
 3233540:	e0bffb17 	ldw	r2,-20(fp)
 3233544:	10800617 	ldw	r2,24(r2)
 3233548:	1885c83a 	sub	r2,r3,r2
 323354c:	e0bff615 	stw	r2,-40(fp)
      if (i <= 0)
 3233550:	e0bff617 	ldw	r2,-40(fp)
 3233554:	10800050 	cmplti	r2,r2,1
 3233558:	1000271e 	bne	r2,zero,32335f8 <tcp_reass+0x298>
         break;
      if (i < (int)(q->ti_len))
 323355c:	e0bffb17 	ldw	r2,-20(fp)
 3233560:	1080028b 	ldhu	r2,10(r2)
 3233564:	10ffffcc 	andi	r3,r2,65535
 3233568:	e0bff617 	ldw	r2,-40(fp)
 323356c:	10c0130e 	bge	r2,r3,32335bc <tcp_reass+0x25c>
      {
         q->ti_seq += i;
 3233570:	e0bffb17 	ldw	r2,-20(fp)
 3233574:	10c00617 	ldw	r3,24(r2)
 3233578:	e0bff617 	ldw	r2,-40(fp)
 323357c:	1887883a 	add	r3,r3,r2
 3233580:	e0bffb17 	ldw	r2,-20(fp)
 3233584:	10c00615 	stw	r3,24(r2)
         q->ti_len -= (u_short)i;
 3233588:	e0bffb17 	ldw	r2,-20(fp)
 323358c:	10c0028b 	ldhu	r3,10(r2)
 3233590:	e0bff617 	ldw	r2,-40(fp)
 3233594:	1885c83a 	sub	r2,r3,r2
 3233598:	1007883a 	mov	r3,r2
 323359c:	e0bffb17 	ldw	r2,-20(fp)
 32335a0:	10c0028d 	sth	r3,10(r2)
         m_adj (dtom(q), (int)i);
 32335a4:	e13ffb17 	ldw	r4,-20(fp)
 32335a8:	322c1f80 	call	322c1f8 <dtom>
 32335ac:	1009883a 	mov	r4,r2
 32335b0:	e17ff617 	ldw	r5,-40(fp)
 32335b4:	322bfd00 	call	322bfd0 <m_adj>
         break;
 32335b8:	00000f06 	br	32335f8 <tcp_reass+0x298>
      }
      q = (struct tcpiphdr *)q->ti_next;
 32335bc:	e0bffb17 	ldw	r2,-20(fp)
 32335c0:	10800017 	ldw	r2,0(r2)
 32335c4:	e0bffb15 	stw	r2,-20(fp)
      m = dtom(q->ti_prev);
 32335c8:	e0bffb17 	ldw	r2,-20(fp)
 32335cc:	11000117 	ldw	r4,4(r2)
 32335d0:	322c1f80 	call	322c1f8 <dtom>
 32335d4:	e0bff915 	stw	r2,-28(fp)
      remque (q->ti_prev);
 32335d8:	e0bffb17 	ldw	r2,-20(fp)
 32335dc:	11000117 	ldw	r4,4(r2)
 32335e0:	322c2a00 	call	322c2a0 <remque>
      m_freem (m);
 32335e4:	e13ff917 	ldw	r4,-28(fp)
 32335e8:	322bc680 	call	322bc68 <m_freem>

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 32335ec:	e0fffc17 	ldw	r3,-16(fp)
 32335f0:	e0bffb17 	ldw	r2,-20(fp)
 32335f4:	10ffcc1e 	bne	r2,r3,3233528 <tcp_reass+0x1c8>
   }

   /*
    * Stick new segment in its place.
    */
   insque(ti, q->ti_prev);
 32335f8:	e0bffb17 	ldw	r2,-20(fp)
 32335fc:	11400117 	ldw	r5,4(r2)
 3233600:	e13ffd17 	ldw	r4,-12(fp)
 3233604:	322c3100 	call	322c310 <insque>
present:
   /*
    * Present data to user, advancing rcv_nxt through
    * completed sequence space.
    */
   if (TCPS_HAVERCVDSYN (tp->t_state) == 0)
 3233608:	e0bffc17 	ldw	r2,-16(fp)
 323360c:	10800217 	ldw	r2,8(r2)
 3233610:	108000c8 	cmpgei	r2,r2,3
 3233614:	1000021e 	bne	r2,zero,3233620 <tcp_reass+0x2c0>
      return (0);
 3233618:	e03fff15 	stw	zero,-4(fp)
 323361c:	00004c06 	br	3233750 <tcp_reass+0x3f0>
   ti = tp->seg_next;
 3233620:	e0bffc17 	ldw	r2,-16(fp)
 3233624:	10800017 	ldw	r2,0(r2)
 3233628:	e0bffd15 	stw	r2,-12(fp)
   if (ti == (struct tcpiphdr *)tp || ti->ti_seq != tp->rcv_nxt)
 323362c:	e0fffc17 	ldw	r3,-16(fp)
 3233630:	e0bffd17 	ldw	r2,-12(fp)
 3233634:	10c00526 	beq	r2,r3,323364c <tcp_reass+0x2ec>
 3233638:	e0bffd17 	ldw	r2,-12(fp)
 323363c:	10c00617 	ldw	r3,24(r2)
 3233640:	e0bffc17 	ldw	r2,-16(fp)
 3233644:	10801617 	ldw	r2,88(r2)
 3233648:	18800226 	beq	r3,r2,3233654 <tcp_reass+0x2f4>
      return (0);
 323364c:	e03fff15 	stw	zero,-4(fp)
 3233650:	00003f06 	br	3233750 <tcp_reass+0x3f0>
   if (tp->t_state == TCPS_SYN_RECEIVED && ti->ti_len)
 3233654:	e0bffc17 	ldw	r2,-16(fp)
 3233658:	10800217 	ldw	r2,8(r2)
 323365c:	108000d8 	cmpnei	r2,r2,3
 3233660:	1000071e 	bne	r2,zero,3233680 <tcp_reass+0x320>
 3233664:	e0bffd17 	ldw	r2,-12(fp)
 3233668:	1080028b 	ldhu	r2,10(r2)
 323366c:	10bfffcc 	andi	r2,r2,65535
 3233670:	1005003a 	cmpeq	r2,r2,zero
 3233674:	1000021e 	bne	r2,zero,3233680 <tcp_reass+0x320>
      return (0);
 3233678:	e03fff15 	stw	zero,-4(fp)
 323367c:	00003406 	br	3233750 <tcp_reass+0x3f0>
   do 
   {
      tp->rcv_nxt += ti->ti_len;
 3233680:	e0bffc17 	ldw	r2,-16(fp)
 3233684:	10c01617 	ldw	r3,88(r2)
 3233688:	e0bffd17 	ldw	r2,-12(fp)
 323368c:	1080028b 	ldhu	r2,10(r2)
 3233690:	10bfffcc 	andi	r2,r2,65535
 3233694:	1887883a 	add	r3,r3,r2
 3233698:	e0bffc17 	ldw	r2,-16(fp)
 323369c:	10c01615 	stw	r3,88(r2)
      flags = ti->ti_flags & TH_FIN;
 32336a0:	e0bffd17 	ldw	r2,-12(fp)
 32336a4:	10800843 	ldbu	r2,33(r2)
 32336a8:	10803fcc 	andi	r2,r2,255
 32336ac:	1080004c 	andi	r2,r2,1
 32336b0:	e0bff815 	stw	r2,-32(fp)
      remque(ti);
 32336b4:	e13ffd17 	ldw	r4,-12(fp)
 32336b8:	322c2a00 	call	322c2a0 <remque>
      m = dtom(ti);
 32336bc:	e13ffd17 	ldw	r4,-12(fp)
 32336c0:	322c1f80 	call	322c1f8 <dtom>
 32336c4:	e0bff915 	stw	r2,-28(fp)
      ti = (struct tcpiphdr *)ti->ti_next;
 32336c8:	e0bffd17 	ldw	r2,-12(fp)
 32336cc:	10800017 	ldw	r2,0(r2)
 32336d0:	e0bffd15 	stw	r2,-12(fp)
      if (so->so_state & SS_CANTRCVMORE)
 32336d4:	e0bffa17 	ldw	r2,-24(fp)
 32336d8:	1080088b 	ldhu	r2,34(r2)
 32336dc:	10bfffcc 	andi	r2,r2,65535
 32336e0:	1080080c 	andi	r2,r2,32
 32336e4:	1005003a 	cmpeq	r2,r2,zero
 32336e8:	1000031e 	bne	r2,zero,32336f8 <tcp_reass+0x398>
         m_freem (m);
 32336ec:	e13ff917 	ldw	r4,-28(fp)
 32336f0:	322bc680 	call	322bc68 <m_freem>
 32336f4:	00000406 	br	3233708 <tcp_reass+0x3a8>
      else
         sbappend (&so->so_rcv, m);
 32336f8:	e0bffa17 	ldw	r2,-24(fp)
 32336fc:	11000a04 	addi	r4,r2,40
 3233700:	e17ff917 	ldw	r5,-28(fp)
 3233704:	32320d00 	call	32320d0 <sbappend>
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
 3233708:	e0fffc17 	ldw	r3,-16(fp)
 323370c:	e0bffd17 	ldw	r2,-12(fp)
 3233710:	10c00526 	beq	r2,r3,3233728 <tcp_reass+0x3c8>
 3233714:	e0bffd17 	ldw	r2,-12(fp)
 3233718:	10c00617 	ldw	r3,24(r2)
 323371c:	e0bffc17 	ldw	r2,-16(fp)
 3233720:	10801617 	ldw	r2,88(r2)
 3233724:	18bfd626 	beq	r3,r2,3233680 <tcp_reass+0x320>
      sorwakeup(so);
 3233728:	e0bffa17 	ldw	r2,-24(fp)
 323372c:	11400a04 	addi	r5,r2,40
 3233730:	e13ffa17 	ldw	r4,-24(fp)
 3233734:	3231f0c0 	call	3231f0c <sbwakeup>
   return (flags);
 3233738:	e0bff817 	ldw	r2,-32(fp)
 323373c:	e0bfff15 	stw	r2,-4(fp)
 3233740:	00000306 	br	3233750 <tcp_reass+0x3f0>
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
 3233744:	e13ffe17 	ldw	r4,-8(fp)
 3233748:	322bc680 	call	322bc68 <m_freem>
   return (0);
 323374c:	e03fff15 	stw	zero,-4(fp)
 3233750:	e0bfff17 	ldw	r2,-4(fp)
}
 3233754:	e037883a 	mov	sp,fp
 3233758:	dfc00117 	ldw	ra,4(sp)
 323375c:	df000017 	ldw	fp,0(sp)
 3233760:	dec00204 	addi	sp,sp,8
 3233764:	f800283a 	ret

03233768 <tcp_input>:
 * RETURNS: void
 */

void
tcp_input(struct mbuf * m, NET ifp)
{
 3233768:	deffd004 	addi	sp,sp,-192
 323376c:	dfc02f15 	stw	ra,188(sp)
 3233770:	df002e15 	stw	fp,184(sp)
 3233774:	df002e04 	addi	fp,sp,184
 3233778:	e13ff015 	stw	r4,-64(fp)
 323377c:	e17ff115 	stw	r5,-60(fp)
   ip6_addr    ip6_src;
   ip6_addr    ip6_dst;
#endif   /* IP_V6 */
   struct tcpiphdr * ti;
   struct inpcb * inp;
   struct mbuf *  om =  0;
 3233780:	e03feb15 	stw	zero,-84(fp)
   int   len,  tlen, off;
   struct tcpcb * tp =  0;
 3233784:	e03fe715 	stw	zero,-100(fp)
   int   tiflags;
   struct socket *   so =  NULL;
 3233788:	e03fe515 	stw	zero,-108(fp)
   int   todrop,  acked,   ourfinisacked, needoutput  =  0;
 323378c:	e03fe115 	stw	zero,-124(fp)
   int   dropsocket  =  0;
 3233790:	e03fe015 	stw	zero,-128(fp)
   long  iss   =  0;
 3233794:	e03fdf15 	stw	zero,-132(fp)
#ifdef DO_TCPTRACE
   int   ostate;
#endif


   tcpstat.tcps_rcvtotal++;
 3233798:	0080c9b4 	movhi	r2,806
 323379c:	10b3ca04 	addi	r2,r2,-12504
 32337a0:	10801917 	ldw	r2,100(r2)
 32337a4:	10c00044 	addi	r3,r2,1
 32337a8:	0080c9b4 	movhi	r2,806
 32337ac:	10b3ca04 	addi	r2,r2,-12504
 32337b0:	10c01915 	stw	r3,100(r2)
   TCP_MIB_INC(tcpInSegs);    /* keep MIB stats */
 32337b4:	0080c9b4 	movhi	r2,806
 32337b8:	10b39c04 	addi	r2,r2,-12688
 32337bc:	10800917 	ldw	r2,36(r2)
 32337c0:	10c00044 	addi	r3,r2,1
 32337c4:	0080c9b4 	movhi	r2,806
 32337c8:	10b39c04 	addi	r2,r2,-12688
 32337cc:	10c00915 	stw	r3,36(r2)
   {
      /*
       * Get IP and TCP header together in first mbuf.
       * Note: IP leaves IP header in first mbuf.
       */
      pip = mtod(m, struct ip *);
 32337d0:	e0bff017 	ldw	r2,-64(fp)
 32337d4:	10800317 	ldw	r2,12(r2)
 32337d8:	e0bfee15 	stw	r2,-72(fp)
      if (pip->ip_ver_ihl > 0x45)   /* IP v4, 5 dword hdr len */
 32337dc:	e0bfee17 	ldw	r2,-72(fp)
 32337e0:	10800003 	ldbu	r2,0(r2)
 32337e4:	10803fcc 	andi	r2,r2,255
 32337e8:	108011b0 	cmpltui	r2,r2,70
 32337ec:	1000061e 	bne	r2,zero,3233808 <tcp_input+0xa0>
      {
         np_stripoptions(pip, (struct mbuf *)m);
 32337f0:	e13fee17 	ldw	r4,-72(fp)
 32337f4:	e17ff017 	ldw	r5,-64(fp)
 32337f8:	322ccd40 	call	322ccd4 <np_stripoptions>
         pip = mtod(m, struct ip *);
 32337fc:	e0bff017 	ldw	r2,-64(fp)
 3233800:	10800317 	ldw	r2,12(r2)
 3233804:	e0bfee15 	stw	r2,-72(fp)
      }
      if (m->m_len < ((sizeof (struct ip) + sizeof (struct tcphdr))))
 3233808:	e0bff017 	ldw	r2,-64(fp)
 323380c:	10800217 	ldw	r2,8(r2)
 3233810:	10800a28 	cmpgeui	r2,r2,40
 3233814:	1000081e 	bne	r2,zero,3233838 <tcp_input+0xd0>
      {
         tcpstat.tcps_rcvshort++;
 3233818:	0080c9b4 	movhi	r2,806
 323381c:	10b3ca04 	addi	r2,r2,-12504
 3233820:	10801e17 	ldw	r2,120(r2)
 3233824:	10c00044 	addi	r3,r2,1
 3233828:	0080c9b4 	movhi	r2,806
 323382c:	10b3ca04 	addi	r2,r2,-12504
 3233830:	10c01e15 	stw	r3,120(r2)
         return;
 3233834:	00091c06 	br	3235ca8 <tcp_input+0x2540>
      }
      tlen = pip->ip_len;     /* this was fudged by IP layer */
 3233838:	e0bfee17 	ldw	r2,-72(fp)
 323383c:	1080008b 	ldhu	r2,2(r2)
 3233840:	10bfffcc 	andi	r2,r2,65535
 3233844:	e0bfe915 	stw	r2,-92(fp)
      /* The following is needed in the cases where the size of the
       * overlay structure is larger than the size of the ip header.
       * This can happen if the ih_next and ih_prev pointers in the
       * overlay structure are larger than 32 bit pointers.
       */
      ti = (struct tcpiphdr *)(m->m_data + sizeof(struct ip) - 
 3233848:	e0bff017 	ldw	r2,-64(fp)
 323384c:	10800317 	ldw	r2,12(r2)
 3233850:	e0bfed15 	stw	r2,-76(fp)
         sizeof(struct ipovly));
      if ((char *)ti < m->pkt->nb_buff)
 3233854:	e0bff017 	ldw	r2,-64(fp)
 3233858:	10800117 	ldw	r2,4(r2)
 323385c:	10c00117 	ldw	r3,4(r2)
 3233860:	e0bfed17 	ldw	r2,-76(fp)
 3233864:	10c0032e 	bgeu	r2,r3,3233874 <tcp_input+0x10c>
      {
         panic("tcp_input");
 3233868:	0100c974 	movhi	r4,805
 323386c:	213d6a04 	addi	r4,r4,-2648
 3233870:	3225df00 	call	3225df0 <panic>
   /*
    * Check that TCP offset makes sense,
    * pull out TCP options and adjust length.
    */

   off = GET_TH_OFF(ti->ti_t) << 2;
 3233874:	e0bfed17 	ldw	r2,-76(fp)
 3233878:	10800803 	ldbu	r2,32(r2)
 323387c:	10803fcc 	andi	r2,r2,255
 3233880:	1004d13a 	srli	r2,r2,4
 3233884:	10803fcc 	andi	r2,r2,255
 3233888:	1085883a 	add	r2,r2,r2
 323388c:	1085883a 	add	r2,r2,r2
 3233890:	e0bfe815 	stw	r2,-96(fp)
   if (off < sizeof (struct tcphdr) || off > tlen) 
 3233894:	e0bfe817 	ldw	r2,-96(fp)
 3233898:	10800530 	cmpltui	r2,r2,20
 323389c:	1000031e 	bne	r2,zero,32338ac <tcp_input+0x144>
 32338a0:	e0ffe817 	ldw	r3,-96(fp)
 32338a4:	e0bfe917 	ldw	r2,-92(fp)
 32338a8:	10c0110e 	bge	r2,r3,32338f0 <tcp_input+0x188>
   {
#ifdef DO_TCPTRACE
      tcp_trace("tcp off: src %x off %d\n", ti->ti_src, off);
#endif
      tcpstat.tcps_rcvbadoff++;
 32338ac:	0080c9b4 	movhi	r2,806
 32338b0:	10b3ca04 	addi	r2,r2,-12504
 32338b4:	10801d17 	ldw	r2,116(r2)
 32338b8:	10c00044 	addi	r3,r2,1
 32338bc:	0080c9b4 	movhi	r2,806
 32338c0:	10b3ca04 	addi	r2,r2,-12504
 32338c4:	10c01d15 	stw	r3,116(r2)
      TCP_MIB_INC(tcpInErrs);   /* keep MIB stats */
 32338c8:	0080c9b4 	movhi	r2,806
 32338cc:	10b39c04 	addi	r2,r2,-12688
 32338d0:	10800d17 	ldw	r2,52(r2)
 32338d4:	10c00044 	addi	r3,r2,1
 32338d8:	0080c9b4 	movhi	r2,806
 32338dc:	10b39c04 	addi	r2,r2,-12688
 32338e0:	10c00d15 	stw	r3,52(r2)
      GOTO_DROP;
 32338e4:	00805784 	movi	r2,350
 32338e8:	d0a8e915 	stw	r2,-23644(gp)
 32338ec:	0008e206 	br	3235c78 <tcp_input+0x2510>
   }
   tlen -= (int)off;
 32338f0:	e0ffe917 	ldw	r3,-92(fp)
 32338f4:	e0bfe817 	ldw	r2,-96(fp)
 32338f8:	1885c83a 	sub	r2,r3,r2
 32338fc:	e0bfe915 	stw	r2,-92(fp)
   ti->ti_len = (u_short)tlen;
 3233900:	e0bfe917 	ldw	r2,-92(fp)
 3233904:	1007883a 	mov	r3,r2
 3233908:	e0bfed17 	ldw	r2,-76(fp)
 323390c:	10c0028d 	sth	r3,10(r2)
   if (off > sizeof (struct tcphdr)) 
 3233910:	e0bfe817 	ldw	r2,-96(fp)
 3233914:	10800570 	cmpltui	r2,r2,21
 3233918:	1000341e 	bne	r2,zero,32339ec <tcp_input+0x284>
   {
      int olen;      /* length of options field */
      u_char * op;   /* scratch option pointer */

      olen = off - sizeof (struct tcphdr);   /* get options length */
 323391c:	e0bfe817 	ldw	r2,-96(fp)
 3233920:	10bffb04 	addi	r2,r2,-20
 3233924:	e0bfdd15 	stw	r2,-140(fp)
      om = m_getwithdata (MT_RXDATA, olen);  /* get mbuf for opts */
 3233928:	01000044 	movi	r4,1
 323392c:	e17fdd17 	ldw	r5,-140(fp)
 3233930:	322b98c0 	call	322b98c <m_getnbuf>
 3233934:	e0bfeb15 	stw	r2,-84(fp)
      if (om == 0)
 3233938:	e0bfeb17 	ldw	r2,-84(fp)
 323393c:	1004c03a 	cmpne	r2,r2,zero
 3233940:	1000031e 	bne	r2,zero,3233950 <tcp_input+0x1e8>
         GOTO_DROP;
 3233944:	00805a84 	movi	r2,362
 3233948:	d0a8e915 	stw	r2,-23644(gp)
 323394c:	0008ca06 	br	3235c78 <tcp_input+0x2510>
      om->m_len = olen;       /* set mbuf length */
 3233950:	e0ffdd17 	ldw	r3,-140(fp)
 3233954:	e0bfeb17 	ldw	r2,-84(fp)
 3233958:	10c00215 	stw	r3,8(r2)
      /* set pointer to options field at end of TCP header */
      if(m->pkt->type == htons(0x86DD))   /* IPv6 packet */
 323395c:	e0bff017 	ldw	r2,-64(fp)
 3233960:	10800117 	ldw	r2,4(r2)
 3233964:	1080080b 	ldhu	r2,32(r2)
 3233968:	10ffffcc 	andi	r3,r2,65535
 323396c:	00b76194 	movui	r2,56710
 3233970:	1880051e 	bne	r3,r2,3233988 <tcp_input+0x220>
         op = (u_char*)(m->m_data + 20);  /* past TCP header */
 3233974:	e0bff017 	ldw	r2,-64(fp)
 3233978:	10800317 	ldw	r2,12(r2)
 323397c:	10800504 	addi	r2,r2,20
 3233980:	e0bfdc15 	stw	r2,-144(fp)
 3233984:	00000406 	br	3233998 <tcp_input+0x230>
      else
         op = (u_char*)(m->m_data + 40);  /* past IP + TCP */
 3233988:	e0bff017 	ldw	r2,-64(fp)
 323398c:	10800317 	ldw	r2,12(r2)
 3233990:	10800a04 	addi	r2,r2,40
 3233994:	e0bfdc15 	stw	r2,-144(fp)
      MEMCPY(om->m_data, op, olen); /* copy to new mbuf */
 3233998:	e0bfeb17 	ldw	r2,-84(fp)
 323399c:	10c00317 	ldw	r3,12(r2)
 32339a0:	e1bfdd17 	ldw	r6,-140(fp)
 32339a4:	e0bfdc17 	ldw	r2,-144(fp)
 32339a8:	1809883a 	mov	r4,r3
 32339ac:	100b883a 	mov	r5,r2
 32339b0:	32067cc0 	call	32067cc <memcpy>

      /* strip options from data mbuf. This actually just cuts the first 
       * m_len bytes from the TCP header, but it leaves the mbuf members 
       * set so the adjustment below does the right thing.
       */
      m->m_data += om->m_len;
 32339b4:	e0bff017 	ldw	r2,-64(fp)
 32339b8:	10c00317 	ldw	r3,12(r2)
 32339bc:	e0bfeb17 	ldw	r2,-84(fp)
 32339c0:	10800217 	ldw	r2,8(r2)
 32339c4:	1887883a 	add	r3,r3,r2
 32339c8:	e0bff017 	ldw	r2,-64(fp)
 32339cc:	10c00315 	stw	r3,12(r2)
      m->m_len -= om->m_len;
 32339d0:	e0bff017 	ldw	r2,-64(fp)
 32339d4:	10c00217 	ldw	r3,8(r2)
 32339d8:	e0bfeb17 	ldw	r2,-84(fp)
 32339dc:	10800217 	ldw	r2,8(r2)
 32339e0:	1887c83a 	sub	r3,r3,r2
 32339e4:	e0bff017 	ldw	r2,-64(fp)
 32339e8:	10c00215 	stw	r3,8(r2)
   }
   tiflags = ti->ti_flags;
 32339ec:	e0bfed17 	ldw	r2,-76(fp)
 32339f0:	10800843 	ldbu	r2,33(r2)
 32339f4:	10803fcc 	andi	r2,r2,255
 32339f8:	e0bfe615 	stw	r2,-104(fp)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   /* Convert TCP protocol specific fields to host format. */
   ti->ti_seq = ntohl(ti->ti_seq);
 32339fc:	e0bfed17 	ldw	r2,-76(fp)
 3233a00:	10800617 	ldw	r2,24(r2)
 3233a04:	1004d63a 	srli	r2,r2,24
 3233a08:	10c03fcc 	andi	r3,r2,255
 3233a0c:	e0bfed17 	ldw	r2,-76(fp)
 3233a10:	10800617 	ldw	r2,24(r2)
 3233a14:	1004d23a 	srli	r2,r2,8
 3233a18:	10bfc00c 	andi	r2,r2,65280
 3233a1c:	1886b03a 	or	r3,r3,r2
 3233a20:	e0bfed17 	ldw	r2,-76(fp)
 3233a24:	10800617 	ldw	r2,24(r2)
 3233a28:	10bfc00c 	andi	r2,r2,65280
 3233a2c:	1004923a 	slli	r2,r2,8
 3233a30:	1886b03a 	or	r3,r3,r2
 3233a34:	e0bfed17 	ldw	r2,-76(fp)
 3233a38:	10800617 	ldw	r2,24(r2)
 3233a3c:	10803fcc 	andi	r2,r2,255
 3233a40:	1004963a 	slli	r2,r2,24
 3233a44:	1886b03a 	or	r3,r3,r2
 3233a48:	e0bfed17 	ldw	r2,-76(fp)
 3233a4c:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = ntohl(ti->ti_ack);
 3233a50:	e0bfed17 	ldw	r2,-76(fp)
 3233a54:	10800717 	ldw	r2,28(r2)
 3233a58:	1004d63a 	srli	r2,r2,24
 3233a5c:	10c03fcc 	andi	r3,r2,255
 3233a60:	e0bfed17 	ldw	r2,-76(fp)
 3233a64:	10800717 	ldw	r2,28(r2)
 3233a68:	1004d23a 	srli	r2,r2,8
 3233a6c:	10bfc00c 	andi	r2,r2,65280
 3233a70:	1886b03a 	or	r3,r3,r2
 3233a74:	e0bfed17 	ldw	r2,-76(fp)
 3233a78:	10800717 	ldw	r2,28(r2)
 3233a7c:	10bfc00c 	andi	r2,r2,65280
 3233a80:	1004923a 	slli	r2,r2,8
 3233a84:	1886b03a 	or	r3,r3,r2
 3233a88:	e0bfed17 	ldw	r2,-76(fp)
 3233a8c:	10800717 	ldw	r2,28(r2)
 3233a90:	10803fcc 	andi	r2,r2,255
 3233a94:	1004963a 	slli	r2,r2,24
 3233a98:	1886b03a 	or	r3,r3,r2
 3233a9c:	e0bfed17 	ldw	r2,-76(fp)
 3233aa0:	10c00715 	stw	r3,28(r2)
   ti->ti_urp = ntohs(ti->ti_urp);
 3233aa4:	e0bfed17 	ldw	r2,-76(fp)
 3233aa8:	1080098b 	ldhu	r2,38(r2)
 3233aac:	10bfffcc 	andi	r2,r2,65535
 3233ab0:	1004d23a 	srli	r2,r2,8
 3233ab4:	10803fcc 	andi	r2,r2,255
 3233ab8:	1009883a 	mov	r4,r2
 3233abc:	e0bfed17 	ldw	r2,-76(fp)
 3233ac0:	1080098b 	ldhu	r2,38(r2)
 3233ac4:	10bfffcc 	andi	r2,r2,65535
 3233ac8:	1004923a 	slli	r2,r2,8
 3233acc:	1007883a 	mov	r3,r2
 3233ad0:	00bfc004 	movi	r2,-256
 3233ad4:	1884703a 	and	r2,r3,r2
 3233ad8:	2084b03a 	or	r2,r4,r2
 3233adc:	1007883a 	mov	r3,r2
 3233ae0:	e0bfed17 	ldw	r2,-76(fp)
 3233ae4:	10c0098d 	sth	r3,38(r2)
   /*
    * Locate pcb for segment.
    */
findpcb:

   switch(m->pkt->type)
 3233ae8:	e0bff017 	ldw	r2,-64(fp)
 3233aec:	10800117 	ldw	r2,4(r2)
 3233af0:	1080080b 	ldhu	r2,32(r2)
 3233af4:	10bfffcc 	andi	r2,r2,65535
 3233af8:	10800220 	cmpeqi	r2,r2,8
 3233afc:	1000011e 	bne	r2,zero,3233b04 <tcp_input+0x39c>
 3233b00:	00001f06 	br	3233b80 <tcp_input+0x418>
   {
#ifdef IP_V4
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
 3233b04:	e0bff017 	ldw	r2,-64(fp)
 3233b08:	10800317 	ldw	r2,12(r2)
 3233b0c:	10c00a04 	addi	r3,r2,40
 3233b10:	e0bff017 	ldw	r2,-64(fp)
 3233b14:	10c00315 	stw	r3,12(r2)
      m->m_len -= 40;
 3233b18:	e0bff017 	ldw	r2,-64(fp)
 3233b1c:	10800217 	ldw	r2,8(r2)
 3233b20:	10fff604 	addi	r3,r2,-40
 3233b24:	e0bff017 	ldw	r2,-64(fp)
 3233b28:	10c00215 	stw	r3,8(r2)

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 3233b2c:	e0bfed17 	ldw	r2,-76(fp)
 3233b30:	11400317 	ldw	r5,12(r2)
 3233b34:	e0bfed17 	ldw	r2,-76(fp)
 3233b38:	1080050b 	ldhu	r2,20(r2)
 3233b3c:	11bfffcc 	andi	r6,r2,65535
 3233b40:	e0bfed17 	ldw	r2,-76(fp)
 3233b44:	11c00417 	ldw	r7,16(r2)
 3233b48:	e0bfed17 	ldw	r2,-76(fp)
 3233b4c:	1080058b 	ldhu	r2,22(r2)
 3233b50:	10bfffcc 	andi	r2,r2,65535
 3233b54:	d8800015 	stw	r2,0(sp)
 3233b58:	00800044 	movi	r2,1
 3233b5c:	d8800115 	stw	r2,4(sp)
 3233b60:	0100c9b4 	movhi	r4,806
 3233b64:	2133bf04 	addi	r4,r4,-12548
 3233b68:	32485240 	call	3248524 <in_pcblookup>
 3233b6c:	e0bfec15 	stw	r2,-80(fp)
    * If the state is CLOSED (i.e., TCB does not exist) then
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
 3233b70:	e0bfec17 	ldw	r2,-80(fp)
 3233b74:	1005003a 	cmpeq	r2,r2,zero
 3233b78:	1000031e 	bne	r2,zero,3233b88 <tcp_input+0x420>
 3233b7c:	00000506 	br	3233b94 <tcp_input+0x42c>
      inp = ip6_pcblookup(&tcb, &ip6_src, ti->ti_sport, 
         &ip6_dst, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
#endif   /* IP_V6 */
   default:
      dtrap();
 3233b80:	322ab8c0 	call	322ab8c <dtrap>
      return;
 3233b84:	00084806 	br	3235ca8 <tcp_input+0x2540>
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
      GOTO_DROPWITHRESET;
 3233b88:	00806b04 	movi	r2,428
 3233b8c:	d0a8e915 	stw	r2,-23644(gp)
 3233b90:	0007f506 	br	3235b68 <tcp_input+0x2400>
   tp = intotcpcb (inp);
 3233b94:	e0bfec17 	ldw	r2,-80(fp)
 3233b98:	10800917 	ldw	r2,36(r2)
 3233b9c:	e0bfe715 	stw	r2,-100(fp)
   if (tp == 0)
 3233ba0:	e0bfe717 	ldw	r2,-100(fp)
 3233ba4:	1004c03a 	cmpne	r2,r2,zero
 3233ba8:	1000031e 	bne	r2,zero,3233bb8 <tcp_input+0x450>
      GOTO_DROPWITHRESET;
 3233bac:	00806bc4 	movi	r2,431
 3233bb0:	d0a8e915 	stw	r2,-23644(gp)
 3233bb4:	0007ec06 	br	3235b68 <tcp_input+0x2400>
   if (tp->t_state == TCPS_CLOSED)
 3233bb8:	e0bfe717 	ldw	r2,-100(fp)
 3233bbc:	10800217 	ldw	r2,8(r2)
 3233bc0:	1004c03a 	cmpne	r2,r2,zero
 3233bc4:	1000031e 	bne	r2,zero,3233bd4 <tcp_input+0x46c>
      GOTO_DROP;
 3233bc8:	00806c44 	movi	r2,433
 3233bcc:	d0a8e915 	stw	r2,-23644(gp)
 3233bd0:	00082906 	br	3235c78 <tcp_input+0x2510>
   so = inp->inp_socket;
 3233bd4:	e0bfec17 	ldw	r2,-80(fp)
 3233bd8:	10800817 	ldw	r2,32(r2)
 3233bdc:	e0bfe515 	stw	r2,-108(fp)
      tcp_saveti = *ti;
   }
#endif

   /* figure out the size of the other guy's receive window */
   rx_win = (tcp_win)(ntohs(ti->ti_win));    /* convert endian */
 3233be0:	e0bfed17 	ldw	r2,-76(fp)
 3233be4:	1080088b 	ldhu	r2,34(r2)
 3233be8:	10bfffcc 	andi	r2,r2,65535
 3233bec:	1004d23a 	srli	r2,r2,8
 3233bf0:	10bfffcc 	andi	r2,r2,65535
 3233bf4:	10c03fcc 	andi	r3,r2,255
 3233bf8:	e0bfed17 	ldw	r2,-76(fp)
 3233bfc:	1080088b 	ldhu	r2,34(r2)
 3233c00:	10bfffcc 	andi	r2,r2,65535
 3233c04:	1004923a 	slli	r2,r2,8
 3233c08:	10bfc00c 	andi	r2,r2,65280
 3233c0c:	1884b03a 	or	r2,r3,r2
 3233c10:	e0bfde15 	stw	r2,-136(fp)
   {
      rx_win <<= tp->snd_wind_scale;         /* apply scale */
   }
#endif /* TCP_WIN_SCALE */

   if (so->so_options & SO_ACCEPTCONN) 
 3233c14:	e0bfe517 	ldw	r2,-108(fp)
 3233c18:	10800417 	ldw	r2,16(r2)
 3233c1c:	1080008c 	andi	r2,r2,2
 3233c20:	1005003a 	cmpeq	r2,r2,zero
 3233c24:	10002d1e 	bne	r2,zero,3233cdc <tcp_input+0x574>
   {
      so = sonewconn(so);
 3233c28:	e13fe517 	ldw	r4,-108(fp)
 3233c2c:	32319e40 	call	32319e4 <sonewconn>
 3233c30:	e0bfe515 	stw	r2,-108(fp)
      if (so == 0)
 3233c34:	e0bfe517 	ldw	r2,-108(fp)
 3233c38:	1004c03a 	cmpne	r2,r2,zero
 3233c3c:	1000031e 	bne	r2,zero,3233c4c <tcp_input+0x4e4>
         GOTO_DROP;
 3233c40:	00807344 	movi	r2,461
 3233c44:	d0a8e915 	stw	r2,-23644(gp)
 3233c48:	00080b06 	br	3235c78 <tcp_input+0x2510>
       * flag dropsocket to see if the temporary
       * socket created here should be discarded.
       * We mark the socket as discardable until
       * we're committed to it below in TCPS_LISTEN.
       */
      dropsocket++;
 3233c4c:	e0bfe017 	ldw	r2,-128(fp)
 3233c50:	10800044 	addi	r2,r2,1
 3233c54:	e0bfe015 	stw	r2,-128(fp)

      inp = (struct inpcb *)so->so_pcb;
 3233c58:	e0bfe517 	ldw	r2,-108(fp)
 3233c5c:	10800117 	ldw	r2,4(r2)
 3233c60:	e0bfec15 	stw	r2,-80(fp)
      inp->ifp = ifp;      /* save iface to peer */
 3233c64:	e0ffec17 	ldw	r3,-80(fp)
 3233c68:	e0bff117 	ldw	r2,-60(fp)
 3233c6c:	18800a15 	stw	r2,40(r3)

      switch(so->so_domain)
 3233c70:	e0bfe517 	ldw	r2,-108(fp)
 3233c74:	10800517 	ldw	r2,20(r2)
 3233c78:	108000a0 	cmpeqi	r2,r2,2
 3233c7c:	1000011e 	bne	r2,zero,3233c84 <tcp_input+0x51c>
 3233c80:	00000c06 	br	3233cb4 <tcp_input+0x54c>
      {
#ifdef IP_V4
      case AF_INET:
         inp->inp_laddr = ti->ti_dst;
 3233c84:	e0bfed17 	ldw	r2,-76(fp)
 3233c88:	10c00417 	ldw	r3,16(r2)
 3233c8c:	e0bfec17 	ldw	r2,-80(fp)
 3233c90:	10c00415 	stw	r3,16(r2)
#ifdef IP_PMTU
         inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
         inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 3233c94:	e0bff117 	ldw	r2,-60(fp)
 3233c98:	10c00917 	ldw	r3,36(r2)
 3233c9c:	e0bff117 	ldw	r2,-60(fp)
 3233ca0:	10800817 	ldw	r2,32(r2)
 3233ca4:	1885c83a 	sub	r2,r3,r2
 3233ca8:	10fff604 	addi	r3,r2,-40
 3233cac:	e0bfec17 	ldw	r2,-80(fp)
 3233cb0:	10c00615 	stw	r3,24(r2)
         inp->inp_pmtu = ip6_pmtulookup(&ip6_src, ifp);
         break;
#endif   /* end v6 */
      }

      inp->inp_lport = ti->ti_dport;
 3233cb4:	e0bfed17 	ldw	r2,-76(fp)
 3233cb8:	10c0058b 	ldhu	r3,22(r2)
 3233cbc:	e0bfec17 	ldw	r2,-80(fp)
 3233cc0:	10c0078d 	sth	r3,30(r2)
      tp = intotcpcb(inp);
 3233cc4:	e0bfec17 	ldw	r2,-80(fp)
 3233cc8:	10800917 	ldw	r2,36(r2)
 3233ccc:	e0bfe715 	stw	r2,-100(fp)
      tp->t_state = TCPS_LISTEN;
 3233cd0:	e0ffe717 	ldw	r3,-100(fp)
 3233cd4:	00800044 	movi	r2,1
 3233cd8:	18800215 	stw	r2,8(r3)

   /*
    * Segment received on connection.
    * Reset idle time and keep-alive timer.
    */
   tp->t_idle = 0;
 3233cdc:	e0bfe717 	ldw	r2,-100(fp)
 3233ce0:	10001d15 	stw	zero,116(r2)
   tp->t_timer[TCPT_KEEP] = tcp_keepidle;
 3233ce4:	0080c974 	movhi	r2,805
 3233ce8:	1089b104 	addi	r2,r2,9924
 3233cec:	10c00017 	ldw	r3,0(r2)
 3233cf0:	e0bfe717 	ldw	r2,-100(fp)
 3233cf4:	10c00515 	stw	r3,20(r2)

   /*
    * Process options if not in LISTEN state,
    * else do it below (after getting remote address).
    */
   if (om && tp->t_state != TCPS_LISTEN) 
 3233cf8:	e0bfeb17 	ldw	r2,-84(fp)
 3233cfc:	1005003a 	cmpeq	r2,r2,zero
 3233d00:	1000091e 	bne	r2,zero,3233d28 <tcp_input+0x5c0>
 3233d04:	e0bfe717 	ldw	r2,-100(fp)
 3233d08:	10800217 	ldw	r2,8(r2)
 3233d0c:	10800060 	cmpeqi	r2,r2,1
 3233d10:	1000051e 	bne	r2,zero,3233d28 <tcp_input+0x5c0>
   {
      tcp_dooptions(tp, om, ti);
 3233d14:	e13fe717 	ldw	r4,-100(fp)
 3233d18:	e17feb17 	ldw	r5,-84(fp)
 3233d1c:	e1bfed17 	ldw	r6,-76(fp)
 3233d20:	3235cbc0 	call	3235cbc <tcp_dooptions>
      om = 0;
 3233d24:	e03feb15 	stw	zero,-84(fp)
   }

   acked = (int)(ti->ti_ack - tp->snd_una);
 3233d28:	e0bfed17 	ldw	r2,-76(fp)
 3233d2c:	10c00717 	ldw	r3,28(r2)
 3233d30:	e0bfe717 	ldw	r2,-100(fp)
 3233d34:	10800e17 	ldw	r2,56(r2)
 3233d38:	1885c83a 	sub	r2,r3,r2
 3233d3c:	e0bfe315 	stw	r2,-116(fp)
    * Receive window is amount of space in rcv queue,
    * but not less than advertised window.
    */
   { long win;

      win = (long)sbspace(&so->so_rcv);
 3233d40:	e0bfe517 	ldw	r2,-108(fp)
 3233d44:	10800b17 	ldw	r2,44(r2)
 3233d48:	1007883a 	mov	r3,r2
 3233d4c:	e0bfe517 	ldw	r2,-108(fp)
 3233d50:	10800a17 	ldw	r2,40(r2)
 3233d54:	1885c83a 	sub	r2,r3,r2
 3233d58:	1004803a 	cmplt	r2,r2,zero
 3233d5c:	1000071e 	bne	r2,zero,3233d7c <tcp_input+0x614>
 3233d60:	e0bfe517 	ldw	r2,-108(fp)
 3233d64:	10c00b17 	ldw	r3,44(r2)
 3233d68:	e0bfe517 	ldw	r2,-108(fp)
 3233d6c:	10800a17 	ldw	r2,40(r2)
 3233d70:	1885c83a 	sub	r2,r3,r2
 3233d74:	e0bffd15 	stw	r2,-12(fp)
 3233d78:	00000106 	br	3233d80 <tcp_input+0x618>
 3233d7c:	e03ffd15 	stw	zero,-12(fp)
 3233d80:	e0bffd17 	ldw	r2,-12(fp)
 3233d84:	e0bfdb15 	stw	r2,-148(fp)
      if (win < 0)
 3233d88:	e0bfdb17 	ldw	r2,-148(fp)
 3233d8c:	1004403a 	cmpge	r2,r2,zero
 3233d90:	1000011e 	bne	r2,zero,3233d98 <tcp_input+0x630>
         win = 0;
 3233d94:	e03fdb15 	stw	zero,-148(fp)
      tp->rcv_wnd = (tcp_win)MAX((u_long)win, (tp->rcv_adv - tp->rcv_nxt));
 3233d98:	e0bfe717 	ldw	r2,-100(fp)
 3233d9c:	10c01917 	ldw	r3,100(r2)
 3233da0:	e0bfe717 	ldw	r2,-100(fp)
 3233da4:	10801617 	ldw	r2,88(r2)
 3233da8:	1885c83a 	sub	r2,r3,r2
 3233dac:	e0ffdb17 	ldw	r3,-148(fp)
 3233db0:	e0fffc15 	stw	r3,-16(fp)
 3233db4:	e0bffb15 	stw	r2,-20(fp)
 3233db8:	e13ffb17 	ldw	r4,-20(fp)
 3233dbc:	e0bffc17 	ldw	r2,-16(fp)
 3233dc0:	2080022e 	bgeu	r4,r2,3233dcc <tcp_input+0x664>
 3233dc4:	e0fffc17 	ldw	r3,-16(fp)
 3233dc8:	e0fffb15 	stw	r3,-20(fp)
 3233dcc:	e0bfe717 	ldw	r2,-100(fp)
 3233dd0:	e13ffb17 	ldw	r4,-20(fp)
 3233dd4:	11001515 	stw	r4,84(r2)
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 3233dd8:	e0bfe717 	ldw	r2,-100(fp)
 3233ddc:	10800217 	ldw	r2,8(r2)
 3233de0:	10800118 	cmpnei	r2,r2,4
 3233de4:	10010f1e 	bne	r2,zero,3234224 <tcp_input+0xabc>
 3233de8:	e0bfe617 	ldw	r2,-104(fp)
 3233dec:	10800dcc 	andi	r2,r2,55
 3233df0:	10800418 	cmpnei	r2,r2,16
 3233df4:	10010b1e 	bne	r2,zero,3234224 <tcp_input+0xabc>
 3233df8:	e0bfed17 	ldw	r2,-76(fp)
 3233dfc:	10c00617 	ldw	r3,24(r2)
 3233e00:	e0bfe717 	ldw	r2,-100(fp)
 3233e04:	10801617 	ldw	r2,88(r2)
 3233e08:	1881061e 	bne	r3,r2,3234224 <tcp_input+0xabc>
 3233e0c:	e0bfde17 	ldw	r2,-136(fp)
 3233e10:	1005003a 	cmpeq	r2,r2,zero
 3233e14:	1001031e 	bne	r2,zero,3234224 <tcp_input+0xabc>
 3233e18:	e0bfe717 	ldw	r2,-100(fp)
 3233e1c:	10c01417 	ldw	r3,80(r2)
 3233e20:	e0bfde17 	ldw	r2,-136(fp)
 3233e24:	1880ff1e 	bne	r3,r2,3234224 <tcp_input+0xabc>
 3233e28:	e0bfe717 	ldw	r2,-100(fp)
 3233e2c:	10c00f17 	ldw	r3,60(r2)
 3233e30:	e0bfe717 	ldw	r2,-100(fp)
 3233e34:	10801a17 	ldw	r2,104(r2)
 3233e38:	1880fa1e 	bne	r3,r2,3234224 <tcp_input+0xabc>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
       (rx_win && rx_win == tp->snd_wnd) &&
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
 3233e3c:	e0bfed17 	ldw	r2,-76(fp)
 3233e40:	1080028b 	ldhu	r2,10(r2)
 3233e44:	10bfffcc 	andi	r2,r2,65535
 3233e48:	1004c03a 	cmpne	r2,r2,zero
 3233e4c:	1000651e 	bne	r2,zero,3233fe4 <tcp_input+0x87c>
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 3233e50:	e0bfed17 	ldw	r2,-76(fp)
 3233e54:	10c00717 	ldw	r3,28(r2)
 3233e58:	e0bfe717 	ldw	r2,-100(fp)
 3233e5c:	10800e17 	ldw	r2,56(r2)
 3233e60:	1885c83a 	sub	r2,r3,r2
 3233e64:	10800050 	cmplti	r2,r2,1
 3233e68:	1000ee1e 	bne	r2,zero,3234224 <tcp_input+0xabc>
 3233e6c:	e0bfed17 	ldw	r2,-76(fp)
 3233e70:	10c00717 	ldw	r3,28(r2)
 3233e74:	e0bfe717 	ldw	r2,-100(fp)
 3233e78:	10801a17 	ldw	r2,104(r2)
 3233e7c:	1885c83a 	sub	r2,r3,r2
 3233e80:	10800048 	cmpgei	r2,r2,1
 3233e84:	1000e71e 	bne	r2,zero,3234224 <tcp_input+0xabc>
 3233e88:	e0bfe717 	ldw	r2,-100(fp)
 3233e8c:	10c01b17 	ldw	r3,108(r2)
 3233e90:	e0bfe717 	ldw	r2,-100(fp)
 3233e94:	10801417 	ldw	r2,80(r2)
 3233e98:	1880e236 	bltu	r3,r2,3234224 <tcp_input+0xabc>
             tp->snd_cwnd >= tp->snd_wnd) 
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
 3233e9c:	0080c9b4 	movhi	r2,806
 3233ea0:	10b3ca04 	addi	r2,r2,-12504
 3233ea4:	10803517 	ldw	r2,212(r2)
 3233ea8:	10c00044 	addi	r3,r2,1
 3233eac:	0080c9b4 	movhi	r2,806
 3233eb0:	10b3ca04 	addi	r2,r2,-12504
 3233eb4:	10c03515 	stw	r3,212(r2)
            if (tp->t_rttick && 
 3233eb8:	e0bfe717 	ldw	r2,-100(fp)
 3233ebc:	10801e17 	ldw	r2,120(r2)
 3233ec0:	1005003a 	cmpeq	r2,r2,zero
 3233ec4:	1000091e 	bne	r2,zero,3233eec <tcp_input+0x784>
 3233ec8:	e0bfed17 	ldw	r2,-76(fp)
 3233ecc:	10c00717 	ldw	r3,28(r2)
 3233ed0:	e0bfe717 	ldw	r2,-100(fp)
 3233ed4:	10801f17 	ldw	r2,124(r2)
 3233ed8:	1885c83a 	sub	r2,r3,r2
 3233edc:	10800050 	cmplti	r2,r2,1
 3233ee0:	1000021e 	bne	r2,zero,3233eec <tcp_input+0x784>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
            {
               tcp_xmit_timer(tp);
 3233ee4:	e13fe717 	ldw	r4,-100(fp)
 3233ee8:	3235f780 	call	3235f78 <tcp_xmit_timer>
            }

            tcpstat.tcps_rcvackpack++;
 3233eec:	0080c9b4 	movhi	r2,806
 3233ef0:	10b3ca04 	addi	r2,r2,-12504
 3233ef4:	10802b17 	ldw	r2,172(r2)
 3233ef8:	10c00044 	addi	r3,r2,1
 3233efc:	0080c9b4 	movhi	r2,806
 3233f00:	10b3ca04 	addi	r2,r2,-12504
 3233f04:	10c02b15 	stw	r3,172(r2)
            tcpstat.tcps_rcvackbyte += acked;
 3233f08:	0080c9b4 	movhi	r2,806
 3233f0c:	10b3ca04 	addi	r2,r2,-12504
 3233f10:	10c02c17 	ldw	r3,176(r2)
 3233f14:	e0bfe317 	ldw	r2,-116(fp)
 3233f18:	1887883a 	add	r3,r3,r2
 3233f1c:	0080c9b4 	movhi	r2,806
 3233f20:	10b3ca04 	addi	r2,r2,-12504
 3233f24:	10c02c15 	stw	r3,176(r2)
            sbdrop(&so->so_snd, acked);
 3233f28:	e0bfe517 	ldw	r2,-108(fp)
 3233f2c:	11001204 	addi	r4,r2,72
 3233f30:	e17fe317 	ldw	r5,-116(fp)
 3233f34:	32326d80 	call	32326d8 <sbdrop>
            tp->snd_una = ti->ti_ack;
 3233f38:	e0bfed17 	ldw	r2,-76(fp)
 3233f3c:	10c00717 	ldw	r3,28(r2)
 3233f40:	e0bfe717 	ldw	r2,-100(fp)
 3233f44:	10c00e15 	stw	r3,56(r2)
            m_freem(m);
 3233f48:	e13ff017 	ldw	r4,-64(fp)
 3233f4c:	322bc680 	call	322bc68 <m_freem>
             * If process is waiting for space,
             * wakeup/selwakeup/signal.  If data
             * are ready to send, let tcp_output
             * decide between more output or persist.
             */
            if (tp->snd_una == tp->snd_max)
 3233f50:	e0bfe717 	ldw	r2,-100(fp)
 3233f54:	10c00e17 	ldw	r3,56(r2)
 3233f58:	e0bfe717 	ldw	r2,-100(fp)
 3233f5c:	10801a17 	ldw	r2,104(r2)
 3233f60:	1880031e 	bne	r3,r2,3233f70 <tcp_input+0x808>
               tp->t_timer[TCPT_REXMT] = 0;
 3233f64:	e0bfe717 	ldw	r2,-100(fp)
 3233f68:	10000315 	stw	zero,12(r2)
 3233f6c:	00000806 	br	3233f90 <tcp_input+0x828>
            else if (tp->t_timer[TCPT_PERSIST] == 0)
 3233f70:	e0bfe717 	ldw	r2,-100(fp)
 3233f74:	10800417 	ldw	r2,16(r2)
 3233f78:	1004c03a 	cmpne	r2,r2,zero
 3233f7c:	1000041e 	bne	r2,zero,3233f90 <tcp_input+0x828>
               tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 3233f80:	e0bfe717 	ldw	r2,-100(fp)
 3233f84:	10c00817 	ldw	r3,32(r2)
 3233f88:	e0bfe717 	ldw	r2,-100(fp)
 3233f8c:	10c00315 	stw	r3,12(r2)

            if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 3233f90:	e0bfe517 	ldw	r2,-108(fp)
 3233f94:	1080190b 	ldhu	r2,100(r2)
 3233f98:	10bfffcc 	andi	r2,r2,65535
 3233f9c:	1080030c 	andi	r2,r2,12
 3233fa0:	1005003a 	cmpeq	r2,r2,zero
 3233fa4:	1000041e 	bne	r2,zero,3233fb8 <tcp_input+0x850>
               sowwakeup(so);
 3233fa8:	e0bfe517 	ldw	r2,-108(fp)
 3233fac:	11401204 	addi	r5,r2,72
 3233fb0:	e13fe517 	ldw	r4,-108(fp)
 3233fb4:	3231f0c0 	call	3231f0c <sbwakeup>

            /* If there is more data in the send buffer, and some is
             * still unsent, then call tcp_output() to try to send it
             */
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
 3233fb8:	e0bfe517 	ldw	r2,-108(fp)
 3233fbc:	11001217 	ldw	r4,72(r2)
 3233fc0:	e0bfe717 	ldw	r2,-100(fp)
 3233fc4:	10c00f17 	ldw	r3,60(r2)
 3233fc8:	e0bfe717 	ldw	r2,-100(fp)
 3233fcc:	10800e17 	ldw	r2,56(r2)
 3233fd0:	1885c83a 	sub	r2,r3,r2
 3233fd4:	1107342e 	bgeu	r2,r4,3235ca8 <tcp_input+0x2540>
               (void) tcp_output(tp);
 3233fd8:	e13fe717 	ldw	r4,-100(fp)
 3233fdc:	32363480 	call	3236348 <tcp_output>
            return;
 3233fe0:	00073106 	br	3235ca8 <tcp_input+0x2540>
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 3233fe4:	e0bfed17 	ldw	r2,-76(fp)
 3233fe8:	10c00717 	ldw	r3,28(r2)
 3233fec:	e0bfe717 	ldw	r2,-100(fp)
 3233ff0:	10800e17 	ldw	r2,56(r2)
 3233ff4:	18808b1e 	bne	r3,r2,3234224 <tcp_input+0xabc>
 3233ff8:	e0bfe717 	ldw	r2,-100(fp)
 3233ffc:	10c00017 	ldw	r3,0(r2)
 3234000:	e0bfe717 	ldw	r2,-100(fp)
 3234004:	1880871e 	bne	r3,r2,3234224 <tcp_input+0xabc>
 3234008:	e0bfed17 	ldw	r2,-76(fp)
 323400c:	1080028b 	ldhu	r2,10(r2)
 3234010:	10bfffcc 	andi	r2,r2,65535
 3234014:	e0bffa15 	stw	r2,-24(fp)
 3234018:	e0bfe517 	ldw	r2,-108(fp)
 323401c:	10800b17 	ldw	r2,44(r2)
 3234020:	1007883a 	mov	r3,r2
 3234024:	e0bfe517 	ldw	r2,-108(fp)
 3234028:	10800a17 	ldw	r2,40(r2)
 323402c:	1885c83a 	sub	r2,r3,r2
 3234030:	1004803a 	cmplt	r2,r2,zero
 3234034:	1000071e 	bne	r2,zero,3234054 <tcp_input+0x8ec>
 3234038:	e0bfe517 	ldw	r2,-108(fp)
 323403c:	10c00b17 	ldw	r3,44(r2)
 3234040:	e0bfe517 	ldw	r2,-108(fp)
 3234044:	10800a17 	ldw	r2,40(r2)
 3234048:	1887c83a 	sub	r3,r3,r2
 323404c:	e0fff915 	stw	r3,-28(fp)
 3234050:	00000106 	br	3234058 <tcp_input+0x8f0>
 3234054:	e03ff915 	stw	zero,-28(fp)
 3234058:	e0bff917 	ldw	r2,-28(fp)
 323405c:	e0fffa17 	ldw	r3,-24(fp)
 3234060:	10c07036 	bltu	r2,r3,3234224 <tcp_input+0xabc>
#endif   /* TCP_ZEROCOPY */

         /* this may also be a garden-variety probe received because
          * the socket sendbuf was full.
          */
         if(tp->rcv_wnd == 0)
 3234064:	e0bfe717 	ldw	r2,-100(fp)
 3234068:	10801517 	ldw	r2,84(r2)
 323406c:	1004c03a 	cmpne	r2,r2,zero
 3234070:	10000c1e 	bne	r2,zero,32340a4 <tcp_input+0x93c>
             * info in this seg, but Windows NT 4.0 has a nasty bug where it
             * will hammer us mericilessly with these probes (one customer
             * reports thousands per second) so we just dump it ASAP to
             * save cycles.
             */
            tcpstat.tcps_rcvwinprobe++;
 3234074:	0080c9b4 	movhi	r2,806
 3234078:	10b3ca04 	addi	r2,r2,-12504
 323407c:	10802817 	ldw	r2,160(r2)
 3234080:	10c00044 	addi	r3,r2,1
 3234084:	0080c9b4 	movhi	r2,806
 3234088:	10b3ca04 	addi	r2,r2,-12504
 323408c:	10c02815 	stw	r3,160(r2)
            m_freem (m);      /* free the received mbuf */
 3234090:	e13ff017 	ldw	r4,-64(fp)
 3234094:	322bc680 	call	322bc68 <m_freem>
            tcp_output(tp);   /* send the ack now... */
 3234098:	e13fe717 	ldw	r4,-100(fp)
 323409c:	32363480 	call	3236348 <tcp_output>
            return;
 32340a0:	00070106 	br	3235ca8 <tcp_input+0x2540>
         /*
          * this is a pure, in-sequence data packet
          * with nothing on the reassembly queue and
          * we have enough buffer space to take it.
          */
         ++tcpstat.tcps_preddat;
 32340a4:	0080c9b4 	movhi	r2,806
 32340a8:	10b3ca04 	addi	r2,r2,-12504
 32340ac:	10803617 	ldw	r2,216(r2)
 32340b0:	10c00044 	addi	r3,r2,1
 32340b4:	0080c9b4 	movhi	r2,806
 32340b8:	10b3ca04 	addi	r2,r2,-12504
 32340bc:	10c03615 	stw	r3,216(r2)
         tp->rcv_nxt += ti->ti_len;
 32340c0:	e0bfe717 	ldw	r2,-100(fp)
 32340c4:	10c01617 	ldw	r3,88(r2)
 32340c8:	e0bfed17 	ldw	r2,-76(fp)
 32340cc:	1080028b 	ldhu	r2,10(r2)
 32340d0:	10bfffcc 	andi	r2,r2,65535
 32340d4:	1887883a 	add	r3,r3,r2
 32340d8:	e0bfe717 	ldw	r2,-100(fp)
 32340dc:	10c01615 	stw	r3,88(r2)
         tcpstat.tcps_rcvpack++;
 32340e0:	0080c9b4 	movhi	r2,806
 32340e4:	10b3ca04 	addi	r2,r2,-12504
 32340e8:	10801a17 	ldw	r2,104(r2)
 32340ec:	10c00044 	addi	r3,r2,1
 32340f0:	0080c9b4 	movhi	r2,806
 32340f4:	10b3ca04 	addi	r2,r2,-12504
 32340f8:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 32340fc:	0080c9b4 	movhi	r2,806
 3234100:	10b3ca04 	addi	r2,r2,-12504
 3234104:	10c01b17 	ldw	r3,108(r2)
 3234108:	e0bfed17 	ldw	r2,-76(fp)
 323410c:	1080028b 	ldhu	r2,10(r2)
 3234110:	10bfffcc 	andi	r2,r2,65535
 3234114:	1887883a 	add	r3,r3,r2
 3234118:	0080c9b4 	movhi	r2,806
 323411c:	10b3ca04 	addi	r2,r2,-12504
 3234120:	10c01b15 	stw	r3,108(r2)
         /*
          * Add data to socket buffer.
          */
         sbappend(&so->so_rcv, m);
 3234124:	e0bfe517 	ldw	r2,-108(fp)
 3234128:	11000a04 	addi	r4,r2,40
 323412c:	e17ff017 	ldw	r5,-64(fp)
 3234130:	32320d00 	call	32320d0 <sbappend>
         sorwakeup(so);
 3234134:	e0bfe517 	ldw	r2,-108(fp)
 3234138:	11400a04 	addi	r5,r2,40
 323413c:	e13fe517 	ldw	r4,-108(fp)
 3234140:	3231f0c0 	call	3231f0c <sbwakeup>
         /*
          * If this is a short packet, then ACK now - with Nagel
          *   congestion avoidance sender won't send more until
          *   he gets an ACK.
          */
         if (tiflags & TH_PUSH)
 3234144:	e0bfe617 	ldw	r2,-104(fp)
 3234148:	1080020c 	andi	r2,r2,8
 323414c:	1005003a 	cmpeq	r2,r2,zero
 3234150:	1000071e 	bne	r2,zero,3234170 <tcp_input+0xa08>
            tp->t_flags |= TF_ACKNOW;
 3234154:	e0bfe717 	ldw	r2,-100(fp)
 3234158:	10800b0b 	ldhu	r2,44(r2)
 323415c:	10800054 	ori	r2,r2,1
 3234160:	1007883a 	mov	r3,r2
 3234164:	e0bfe717 	ldw	r2,-100(fp)
 3234168:	10c00b0d 	sth	r3,44(r2)
 323416c:	00000606 	br	3234188 <tcp_input+0xa20>
         else
            tp->t_flags |= TF_DELACK;
 3234170:	e0bfe717 	ldw	r2,-100(fp)
 3234174:	10800b0b 	ldhu	r2,44(r2)
 3234178:	10800094 	ori	r2,r2,2
 323417c:	1007883a 	mov	r3,r2
 3234180:	e0bfe717 	ldw	r2,-100(fp)
 3234184:	10c00b0d 	sth	r3,44(r2)

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));
 3234188:	e0bfe717 	ldw	r2,-100(fp)
 323418c:	11001517 	ldw	r4,84(r2)
 3234190:	e0bfe717 	ldw	r2,-100(fp)
 3234194:	10c01917 	ldw	r3,100(r2)
 3234198:	e0bfe717 	ldw	r2,-100(fp)
 323419c:	10801617 	ldw	r2,88(r2)
 32341a0:	1885c83a 	sub	r2,r3,r2
 32341a4:	2085c83a 	sub	r2,r4,r2
 32341a8:	e0bfda15 	stw	r2,-152(fp)

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 32341ac:	e0bfe717 	ldw	r2,-100(fp)
 32341b0:	10800a0b 	ldhu	r2,40(r2)
 32341b4:	10bfffcc 	andi	r2,r2,65535
 32341b8:	1085883a 	add	r2,r2,r2
 32341bc:	1007883a 	mov	r3,r2
 32341c0:	e0bfda17 	ldw	r2,-152(fp)
 32341c4:	10c0070e 	bge	r2,r3,32341e4 <tcp_input+0xa7c>
 32341c8:	e0bfe717 	ldw	r2,-100(fp)
 32341cc:	10800b0b 	ldhu	r2,44(r2)
 32341d0:	10bfffcc 	andi	r2,r2,65535
 32341d4:	1080004c 	andi	r2,r2,1
 32341d8:	10803fcc 	andi	r2,r2,255
 32341dc:	1005003a 	cmpeq	r2,r2,zero
 32341e0:	1006b11e 	bne	r2,zero,3235ca8 <tcp_input+0x2540>
               tp->t_flags &= ~TF_ACKNOW;
               return;
            }
#endif   /* DO_DELAY_ACKS */

            tp->t_flags |= TF_ACKNOW;
 32341e4:	e0bfe717 	ldw	r2,-100(fp)
 32341e8:	10800b0b 	ldhu	r2,44(r2)
 32341ec:	10800054 	ori	r2,r2,1
 32341f0:	1007883a 	mov	r3,r2
 32341f4:	e0bfe717 	ldw	r2,-100(fp)
 32341f8:	10c00b0d 	sth	r3,44(r2)
            tp->t_flags &= ~TF_DELACK;
 32341fc:	e0bfe717 	ldw	r2,-100(fp)
 3234200:	10c00b0b 	ldhu	r3,44(r2)
 3234204:	00bfff44 	movi	r2,-3
 3234208:	1884703a 	and	r2,r3,r2
 323420c:	1007883a 	mov	r3,r2
 3234210:	e0bfe717 	ldw	r2,-100(fp)
 3234214:	10c00b0d 	sth	r3,44(r2)
            tcp_output(tp);   /* send the ack now... */
 3234218:	e13fe717 	ldw	r4,-100(fp)
 323421c:	32363480 	call	3236348 <tcp_output>
         }

         return;
 3234220:	0006a106 	br	3235ca8 <tcp_input+0x2540>
      }
   }

   switch (tp->t_state) 
 3234224:	e0bfe717 	ldw	r2,-100(fp)
 3234228:	10800217 	ldw	r2,8(r2)
 323422c:	e0bff815 	stw	r2,-32(fp)
 3234230:	e13ff817 	ldw	r4,-32(fp)
 3234234:	20800060 	cmpeqi	r2,r4,1
 3234238:	1000041e 	bne	r2,zero,323424c <tcp_input+0xae4>
 323423c:	e0fff817 	ldw	r3,-32(fp)
 3234240:	188000a0 	cmpeqi	r2,r3,2
 3234244:	1000b91e 	bne	r2,zero,323452c <tcp_input+0xdc4>
 3234248:	00019806 	br	32348ac <tcp_input+0x1144>
    */
   case TCPS_LISTEN: 
   {
         struct mbuf *  am;

         if (tiflags & TH_RST)
 323424c:	e0bfe617 	ldw	r2,-104(fp)
 3234250:	1080010c 	andi	r2,r2,4
 3234254:	1005003a 	cmpeq	r2,r2,zero
 3234258:	1000031e 	bne	r2,zero,3234268 <tcp_input+0xb00>
            GOTO_DROP;
 323425c:	0080bec4 	movi	r2,763
 3234260:	d0a8e915 	stw	r2,-23644(gp)
 3234264:	00068406 	br	3235c78 <tcp_input+0x2510>
         if (tiflags & TH_ACK)
 3234268:	e0bfe617 	ldw	r2,-104(fp)
 323426c:	1080040c 	andi	r2,r2,16
 3234270:	1005003a 	cmpeq	r2,r2,zero
 3234274:	1000031e 	bne	r2,zero,3234284 <tcp_input+0xb1c>
            GOTO_DROPWITHRESET;
 3234278:	0080bf44 	movi	r2,765
 323427c:	d0a8e915 	stw	r2,-23644(gp)
 3234280:	00063906 	br	3235b68 <tcp_input+0x2400>
         if ((tiflags & TH_SYN) == 0)
 3234284:	e0bfe617 	ldw	r2,-104(fp)
 3234288:	1080008c 	andi	r2,r2,2
 323428c:	1004c03a 	cmpne	r2,r2,zero
 3234290:	1000031e 	bne	r2,zero,32342a0 <tcp_input+0xb38>
            GOTO_DROP;
 3234294:	0080bfc4 	movi	r2,767
 3234298:	d0a8e915 	stw	r2,-23644(gp)
 323429c:	00067606 	br	3235c78 <tcp_input+0x2510>
         if(in_broadcast(ti->ti_dst.s_addr))
 32342a0:	e0bfed17 	ldw	r2,-76(fp)
 32342a4:	11000417 	ldw	r4,16(r2)
 32342a8:	322cc940 	call	322cc94 <in_broadcast>
 32342ac:	1005003a 	cmpeq	r2,r2,zero
 32342b0:	1000031e 	bne	r2,zero,32342c0 <tcp_input+0xb58>
            GOTO_DROP;
 32342b4:	0080c044 	movi	r2,769
 32342b8:	d0a8e915 	stw	r2,-23644(gp)
 32342bc:	00066e06 	br	3235c78 <tcp_input+0x2510>
         am = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 32342c0:	01000244 	movi	r4,9
 32342c4:	01400404 	movi	r5,16
 32342c8:	322b98c0 	call	322b98c <m_getnbuf>
 32342cc:	e0bfd915 	stw	r2,-156(fp)
         if (am == NULL)
 32342d0:	e0bfd917 	ldw	r2,-156(fp)
 32342d4:	1004c03a 	cmpne	r2,r2,zero
 32342d8:	1000031e 	bne	r2,zero,32342e8 <tcp_input+0xb80>
            GOTO_DROP;
 32342dc:	0080c104 	movi	r2,772
 32342e0:	d0a8e915 	stw	r2,-23644(gp)
 32342e4:	00066406 	br	3235c78 <tcp_input+0x2510>

#ifdef IP_V4
         if(inp->inp_socket->so_domain == AF_INET)
 32342e8:	e0bfec17 	ldw	r2,-80(fp)
 32342ec:	10800817 	ldw	r2,32(r2)
 32342f0:	10800517 	ldw	r2,20(r2)
 32342f4:	10800098 	cmpnei	r2,r2,2
 32342f8:	10002e1e 	bne	r2,zero,32343b4 <tcp_input+0xc4c>
         {
         struct sockaddr_in * sin;
         am->m_len = sizeof (struct sockaddr_in);
 32342fc:	e0ffd917 	ldw	r3,-156(fp)
 3234300:	00800404 	movi	r2,16
 3234304:	18800215 	stw	r2,8(r3)
         sin = mtod(am, struct sockaddr_in *);
 3234308:	e0bfd917 	ldw	r2,-156(fp)
 323430c:	10800317 	ldw	r2,12(r2)
 3234310:	e0bfd815 	stw	r2,-160(fp)
         sin->sin_family = AF_INET;
 3234314:	e0ffd817 	ldw	r3,-160(fp)
 3234318:	00800084 	movi	r2,2
 323431c:	1880000d 	sth	r2,0(r3)
         sin->sin_addr = ti->ti_src;
 3234320:	e0bfed17 	ldw	r2,-76(fp)
 3234324:	10c00317 	ldw	r3,12(r2)
 3234328:	e0bfd817 	ldw	r2,-160(fp)
 323432c:	10c00115 	stw	r3,4(r2)
         sin->sin_port = ti->ti_sport;
 3234330:	e0bfed17 	ldw	r2,-76(fp)
 3234334:	10c0050b 	ldhu	r3,20(r2)
 3234338:	e0bfd817 	ldw	r2,-160(fp)
 323433c:	10c0008d 	sth	r3,2(r2)
         /* Assuming pcbconnect will work, we put the sender's address in 
          * the inp_laddr (after saving a local laddr copy). If the connect
          * fails we restore the inpcb before going to drop:
          */
         laddr = inp->inp_laddr;    /* save tmp laddr */
 3234340:	e0bfec17 	ldw	r2,-80(fp)
 3234344:	10800417 	ldw	r2,16(r2)
 3234348:	e0bfef15 	stw	r2,-68(fp)
         if (inp->inp_laddr.s_addr == INADDR_ANY)
 323434c:	e0bfec17 	ldw	r2,-80(fp)
 3234350:	10800417 	ldw	r2,16(r2)
 3234354:	1004c03a 	cmpne	r2,r2,zero
 3234358:	1000041e 	bne	r2,zero,323436c <tcp_input+0xc04>
            inp->inp_laddr = ti->ti_dst;
 323435c:	e0bfed17 	ldw	r2,-76(fp)
 3234360:	10c00417 	ldw	r3,16(r2)
 3234364:	e0bfec17 	ldw	r2,-80(fp)
 3234368:	10c00415 	stw	r3,16(r2)
         if (in_pcbconnect (inp, am)) 
 323436c:	e13fec17 	ldw	r4,-80(fp)
 3234370:	e17fd917 	ldw	r5,-156(fp)
 3234374:	32481bc0 	call	32481bc <in_pcbconnect>
 3234378:	1005003a 	cmpeq	r2,r2,zero
 323437c:	1000081e 	bne	r2,zero,32343a0 <tcp_input+0xc38>
         {
            inp->inp_laddr = laddr;
 3234380:	e0bfec17 	ldw	r2,-80(fp)
 3234384:	e0ffef17 	ldw	r3,-68(fp)
 3234388:	10c00415 	stw	r3,16(r2)
            (void) m_free(am);
 323438c:	e13fd917 	ldw	r4,-156(fp)
 3234390:	322bb340 	call	322bb34 <m_free>
            GOTO_DROP;
 3234394:	0080c684 	movi	r2,794
 3234398:	d0a8e915 	stw	r2,-23644(gp)
 323439c:	00063606 	br	3235c78 <tcp_input+0x2510>
         }
         
         inp->ifp = ifp;      /* set interface for conn.*/
 32343a0:	e0ffec17 	ldw	r3,-80(fp)
 32343a4:	e0bff117 	ldw	r2,-60(fp)
 32343a8:	18800a15 	stw	r2,40(r3)
         
         (void) m_free (am);
 32343ac:	e13fd917 	ldw	r4,-156(fp)
 32343b0:	322bb340 	call	322bb34 <m_free>
            }
            (void) m_free(am);
         }
#endif   /* end v6 */

         tp->t_template = tcp_template(tp);
 32343b4:	e13fe717 	ldw	r4,-100(fp)
 32343b8:	32377000 	call	3237700 <tcp_template>
 32343bc:	1007883a 	mov	r3,r2
 32343c0:	e0bfe717 	ldw	r2,-100(fp)
 32343c4:	10c00c15 	stw	r3,48(r2)
         if (tp->t_template == 0) 
 32343c8:	e0bfe717 	ldw	r2,-100(fp)
 32343cc:	10800c17 	ldw	r2,48(r2)
 32343d0:	1004c03a 	cmpne	r2,r2,zero
 32343d4:	1000071e 	bne	r2,zero,32343f4 <tcp_input+0xc8c>
         {
            SETTP(tp, tcp_drop(tp, ENOBUFS));
 32343d8:	e13fe717 	ldw	r4,-100(fp)
 32343dc:	01401a44 	movi	r5,105
 32343e0:	3237db80 	call	3237db8 <tcp_drop>
            dropsocket = 0;      /* socket is already gone */
 32343e4:	e03fe015 	stw	zero,-128(fp)
            GOTO_DROP;
 32343e8:	0080d1c4 	movi	r2,839
 32343ec:	d0a8e915 	stw	r2,-23644(gp)
 32343f0:	00062106 	br	3235c78 <tcp_input+0x2510>
         }
         if (om) 
 32343f4:	e0bfeb17 	ldw	r2,-84(fp)
 32343f8:	1005003a 	cmpeq	r2,r2,zero
 32343fc:	1000051e 	bne	r2,zero,3234414 <tcp_input+0xcac>
         {
            tcp_dooptions(tp, om, ti);
 3234400:	e13fe717 	ldw	r4,-100(fp)
 3234404:	e17feb17 	ldw	r5,-84(fp)
 3234408:	e1bfed17 	ldw	r6,-76(fp)
 323440c:	3235cbc0 	call	3235cbc <tcp_dooptions>
            om = 0;
 3234410:	e03feb15 	stw	zero,-84(fp)
         }
         if (iss)
 3234414:	e0bfdf17 	ldw	r2,-132(fp)
 3234418:	1005003a 	cmpeq	r2,r2,zero
 323441c:	1000041e 	bne	r2,zero,3234430 <tcp_input+0xcc8>
            tp->iss = iss;
 3234420:	e0ffdf17 	ldw	r3,-132(fp)
 3234424:	e0bfe717 	ldw	r2,-100(fp)
 3234428:	10c01315 	stw	r3,76(r2)
 323442c:	00000506 	br	3234444 <tcp_input+0xcdc>
         else
            tp->iss = tcp_iss;
 3234430:	0080c974 	movhi	r2,805
 3234434:	10926304 	addi	r2,r2,18828
 3234438:	10c00017 	ldw	r3,0(r2)
 323443c:	e0bfe717 	ldw	r2,-100(fp)
 3234440:	10c01315 	stw	r3,76(r2)
         tcp_iss += (unsigned)(TCP_ISSINCR/2);
 3234444:	0080c974 	movhi	r2,805
 3234448:	10926304 	addi	r2,r2,18828
 323444c:	10c00017 	ldw	r3,0(r2)
 3234450:	00be9fd4 	movui	r2,64127
 3234454:	1887883a 	add	r3,r3,r2
 3234458:	0080c974 	movhi	r2,805
 323445c:	10926304 	addi	r2,r2,18828
 3234460:	10c00015 	stw	r3,0(r2)
         tp->irs = ti->ti_seq;
 3234464:	e0bfed17 	ldw	r2,-76(fp)
 3234468:	10c00617 	ldw	r3,24(r2)
 323446c:	e0bfe717 	ldw	r2,-100(fp)
 3234470:	10c01815 	stw	r3,96(r2)
         tcp_sendseqinit(tp);
 3234474:	e0bfe717 	ldw	r2,-100(fp)
 3234478:	10c01317 	ldw	r3,76(r2)
 323447c:	e0bfe717 	ldw	r2,-100(fp)
 3234480:	10c01015 	stw	r3,64(r2)
 3234484:	e0bfe717 	ldw	r2,-100(fp)
 3234488:	10c01017 	ldw	r3,64(r2)
 323448c:	e0bfe717 	ldw	r2,-100(fp)
 3234490:	10c01a15 	stw	r3,104(r2)
 3234494:	e0bfe717 	ldw	r2,-100(fp)
 3234498:	10c01a17 	ldw	r3,104(r2)
 323449c:	e0bfe717 	ldw	r2,-100(fp)
 32344a0:	10c00f15 	stw	r3,60(r2)
 32344a4:	e0bfe717 	ldw	r2,-100(fp)
 32344a8:	10c00f17 	ldw	r3,60(r2)
 32344ac:	e0bfe717 	ldw	r2,-100(fp)
 32344b0:	10c00e15 	stw	r3,56(r2)
         tcp_rcvseqinit(tp);
 32344b4:	e0bfe717 	ldw	r2,-100(fp)
 32344b8:	10801817 	ldw	r2,96(r2)
 32344bc:	10c00044 	addi	r3,r2,1
 32344c0:	e0bfe717 	ldw	r2,-100(fp)
 32344c4:	10c01615 	stw	r3,88(r2)
 32344c8:	e0bfe717 	ldw	r2,-100(fp)
 32344cc:	10c01617 	ldw	r3,88(r2)
 32344d0:	e0bfe717 	ldw	r2,-100(fp)
 32344d4:	10c01915 	stw	r3,100(r2)
         tp->t_flags |= TF_ACKNOW;
 32344d8:	e0bfe717 	ldw	r2,-100(fp)
 32344dc:	10800b0b 	ldhu	r2,44(r2)
 32344e0:	10800054 	ori	r2,r2,1
 32344e4:	1007883a 	mov	r3,r2
 32344e8:	e0bfe717 	ldw	r2,-100(fp)
 32344ec:	10c00b0d 	sth	r3,44(r2)
         tp->t_state = TCPS_SYN_RECEIVED;
 32344f0:	e0ffe717 	ldw	r3,-100(fp)
 32344f4:	008000c4 	movi	r2,3
 32344f8:	18800215 	stw	r2,8(r3)
         tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 32344fc:	e0ffe717 	ldw	r3,-100(fp)
 3234500:	00802584 	movi	r2,150
 3234504:	18800515 	stw	r2,20(r3)
         dropsocket = 0;      /* committed to socket */
 3234508:	e03fe015 	stw	zero,-128(fp)
         tcpstat.tcps_accepts++;
 323450c:	0080c9b4 	movhi	r2,806
 3234510:	10b3ca04 	addi	r2,r2,-12504
 3234514:	10800117 	ldw	r2,4(r2)
 3234518:	10c00044 	addi	r3,r2,1
 323451c:	0080c9b4 	movhi	r2,806
 3234520:	10b3ca04 	addi	r2,r2,-12504
 3234524:	10c00115 	stw	r3,4(r2)
         goto trimthenstep6;
 3234528:	00009d06 	br	32347a0 <tcp_input+0x1038>
    *   if SYN has been acked change to ESTABLISHED else SYN_RCVD state
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
 323452c:	e0ffec17 	ldw	r3,-80(fp)
 3234530:	e0bff117 	ldw	r2,-60(fp)
 3234534:	18800a15 	stw	r2,40(r3)
      if ((tiflags & TH_ACK) &&
 3234538:	e0bfe617 	ldw	r2,-104(fp)
 323453c:	1080040c 	andi	r2,r2,16
 3234540:	1005003a 	cmpeq	r2,r2,zero
 3234544:	1000111e 	bne	r2,zero,323458c <tcp_input+0xe24>
 3234548:	e0bfed17 	ldw	r2,-76(fp)
 323454c:	10c00717 	ldw	r3,28(r2)
 3234550:	e0bfe717 	ldw	r2,-100(fp)
 3234554:	10801317 	ldw	r2,76(r2)
 3234558:	1885c83a 	sub	r2,r3,r2
 323455c:	10800050 	cmplti	r2,r2,1
 3234560:	1000071e 	bne	r2,zero,3234580 <tcp_input+0xe18>
 3234564:	e0bfed17 	ldw	r2,-76(fp)
 3234568:	10c00717 	ldw	r3,28(r2)
 323456c:	e0bfe717 	ldw	r2,-100(fp)
 3234570:	10801a17 	ldw	r2,104(r2)
 3234574:	1885c83a 	sub	r2,r3,r2
 3234578:	10800050 	cmplti	r2,r2,1
 323457c:	1000031e 	bne	r2,zero,323458c <tcp_input+0xe24>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
          SEQ_GT(ti->ti_ack, tp->snd_max)))
      {
         GOTO_DROPWITHRESET;
 3234580:	0080dc04 	movi	r2,880
 3234584:	d0a8e915 	stw	r2,-23644(gp)
 3234588:	00057706 	br	3235b68 <tcp_input+0x2400>
      }
      if (tiflags & TH_RST) 
 323458c:	e0bfe617 	ldw	r2,-104(fp)
 3234590:	1080010c 	andi	r2,r2,4
 3234594:	1005003a 	cmpeq	r2,r2,zero
 3234598:	10000a1e 	bne	r2,zero,32345c4 <tcp_input+0xe5c>
      {
         if (tiflags & TH_ACK)
 323459c:	e0bfe617 	ldw	r2,-104(fp)
 32345a0:	1080040c 	andi	r2,r2,16
 32345a4:	1005003a 	cmpeq	r2,r2,zero
 32345a8:	1000031e 	bne	r2,zero,32345b8 <tcp_input+0xe50>
            SETTP(tp, tcp_drop(tp, ECONNREFUSED));
 32345ac:	e13fe717 	ldw	r4,-100(fp)
 32345b0:	01401bc4 	movi	r5,111
 32345b4:	3237db80 	call	3237db8 <tcp_drop>
         GOTO_DROP;
 32345b8:	0080dd84 	movi	r2,886
 32345bc:	d0a8e915 	stw	r2,-23644(gp)
 32345c0:	0005ad06 	br	3235c78 <tcp_input+0x2510>
      }
      if ((tiflags & TH_SYN) == 0)
 32345c4:	e0bfe617 	ldw	r2,-104(fp)
 32345c8:	1080008c 	andi	r2,r2,2
 32345cc:	1004c03a 	cmpne	r2,r2,zero
 32345d0:	1000031e 	bne	r2,zero,32345e0 <tcp_input+0xe78>
         GOTO_DROP;
 32345d4:	0080de44 	movi	r2,889
 32345d8:	d0a8e915 	stw	r2,-23644(gp)
 32345dc:	0005a606 	br	3235c78 <tcp_input+0x2510>
      if (tiflags & TH_ACK) 
 32345e0:	e0bfe617 	ldw	r2,-104(fp)
 32345e4:	1080040c 	andi	r2,r2,16
 32345e8:	1005003a 	cmpeq	r2,r2,zero
 32345ec:	10000f1e 	bne	r2,zero,323462c <tcp_input+0xec4>
      {
         tp->snd_una = ti->ti_ack;
 32345f0:	e0bfed17 	ldw	r2,-76(fp)
 32345f4:	10c00717 	ldw	r3,28(r2)
 32345f8:	e0bfe717 	ldw	r2,-100(fp)
 32345fc:	10c00e15 	stw	r3,56(r2)
         if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 3234600:	e0bfe717 	ldw	r2,-100(fp)
 3234604:	10c00f17 	ldw	r3,60(r2)
 3234608:	e0bfe717 	ldw	r2,-100(fp)
 323460c:	10800e17 	ldw	r2,56(r2)
 3234610:	1885c83a 	sub	r2,r3,r2
 3234614:	1004403a 	cmpge	r2,r2,zero
 3234618:	1000041e 	bne	r2,zero,323462c <tcp_input+0xec4>
            tp->snd_nxt = tp->snd_una;
 323461c:	e0bfe717 	ldw	r2,-100(fp)
 3234620:	10c00e17 	ldw	r3,56(r2)
 3234624:	e0bfe717 	ldw	r2,-100(fp)
 3234628:	10c00f15 	stw	r3,60(r2)
      }
      tp->t_timer[TCPT_REXMT] = 0;
 323462c:	e0bfe717 	ldw	r2,-100(fp)
 3234630:	10000315 	stw	zero,12(r2)
      tp->irs = ti->ti_seq;
 3234634:	e0bfed17 	ldw	r2,-76(fp)
 3234638:	10c00617 	ldw	r3,24(r2)
 323463c:	e0bfe717 	ldw	r2,-100(fp)
 3234640:	10c01815 	stw	r3,96(r2)
      tcp_rcvseqinit(tp);
 3234644:	e0bfe717 	ldw	r2,-100(fp)
 3234648:	10801817 	ldw	r2,96(r2)
 323464c:	10c00044 	addi	r3,r2,1
 3234650:	e0bfe717 	ldw	r2,-100(fp)
 3234654:	10c01615 	stw	r3,88(r2)
 3234658:	e0bfe717 	ldw	r2,-100(fp)
 323465c:	10c01617 	ldw	r3,88(r2)
 3234660:	e0bfe717 	ldw	r2,-100(fp)
 3234664:	10c01915 	stw	r3,100(r2)
      if (inp->inp_laddr.s_addr != ti->ti_dst.s_addr) 
 3234668:	e0bfec17 	ldw	r2,-80(fp)
 323466c:	10c00417 	ldw	r3,16(r2)
 3234670:	e0bfed17 	ldw	r2,-76(fp)
 3234674:	10800417 	ldw	r2,16(r2)
 3234678:	18801926 	beq	r3,r2,32346e0 <tcp_input+0xf78>
          * the IP interface may have changed address since we sent our SYN
          * (e.g. PPP brings link up as a result of said SYN and gets new
          * address via IPCP); if so we need to update the inpcb and the
          * TCP header template with the new address.
          */
         if ((m->pkt->net != NULL)
 323467c:	e0bff017 	ldw	r2,-64(fp)
 3234680:	10800117 	ldw	r2,4(r2)
 3234684:	10800617 	ldw	r2,24(r2)
 3234688:	1005003a 	cmpeq	r2,r2,zero
 323468c:	1000141e 	bne	r2,zero,32346e0 <tcp_input+0xf78>
 3234690:	e0bff017 	ldw	r2,-64(fp)
 3234694:	10800117 	ldw	r2,4(r2)
 3234698:	10800617 	ldw	r2,24(r2)
 323469c:	10c00a17 	ldw	r3,40(r2)
 32346a0:	e0bfed17 	ldw	r2,-76(fp)
 32346a4:	10800417 	ldw	r2,16(r2)
 32346a8:	18800d1e 	bne	r3,r2,32346e0 <tcp_input+0xf78>
             && (m->pkt->net->n_ipaddr == ti->ti_dst.s_addr)) 
      /* send an ack */
         {
            inp->inp_laddr = ti->ti_dst;
 32346ac:	e0bfed17 	ldw	r2,-76(fp)
 32346b0:	10c00417 	ldw	r3,16(r2)
 32346b4:	e0bfec17 	ldw	r2,-80(fp)
 32346b8:	10c00415 	stw	r3,16(r2)
            if (tp->t_template != NULL)
 32346bc:	e0bfe717 	ldw	r2,-100(fp)
 32346c0:	10800c17 	ldw	r2,48(r2)
 32346c4:	1005003a 	cmpeq	r2,r2,zero
 32346c8:	1000051e 	bne	r2,zero,32346e0 <tcp_input+0xf78>
               tp->t_template->ti_src = ti->ti_dst;
 32346cc:	e0bfe717 	ldw	r2,-100(fp)
 32346d0:	10c00c17 	ldw	r3,48(r2)
 32346d4:	e0bfed17 	ldw	r2,-76(fp)
 32346d8:	10800417 	ldw	r2,16(r2)
 32346dc:	18800315 	stw	r2,12(r3)
         }
      }
      tp->t_flags |= TF_ACKNOW;
 32346e0:	e0bfe717 	ldw	r2,-100(fp)
 32346e4:	10800b0b 	ldhu	r2,44(r2)
 32346e8:	10800054 	ori	r2,r2,1
 32346ec:	1007883a 	mov	r3,r2
 32346f0:	e0bfe717 	ldw	r2,-100(fp)
 32346f4:	10c00b0d 	sth	r3,44(r2)
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 32346f8:	e0bfe617 	ldw	r2,-104(fp)
 32346fc:	1080040c 	andi	r2,r2,16
 3234700:	1005003a 	cmpeq	r2,r2,zero
 3234704:	1000231e 	bne	r2,zero,3234794 <tcp_input+0x102c>
 3234708:	e0bfe717 	ldw	r2,-100(fp)
 323470c:	10c00e17 	ldw	r3,56(r2)
 3234710:	e0bfe717 	ldw	r2,-100(fp)
 3234714:	10801317 	ldw	r2,76(r2)
 3234718:	1885c83a 	sub	r2,r3,r2
 323471c:	10800050 	cmplti	r2,r2,1
 3234720:	10001c1e 	bne	r2,zero,3234794 <tcp_input+0x102c>
      {
         tcpstat.tcps_connects++;
 3234724:	0080c9b4 	movhi	r2,806
 3234728:	10b3ca04 	addi	r2,r2,-12504
 323472c:	10800217 	ldw	r2,8(r2)
 3234730:	10c00044 	addi	r3,r2,1
 3234734:	0080c9b4 	movhi	r2,806
 3234738:	10b3ca04 	addi	r2,r2,-12504
 323473c:	10c00215 	stw	r3,8(r2)
         tp->t_state = TCPS_ESTABLISHED;
 3234740:	e0ffe717 	ldw	r3,-100(fp)
 3234744:	00800104 	movi	r2,4
 3234748:	18800215 	stw	r2,8(r3)
         soisconnected (so);
 323474c:	e13fe517 	ldw	r4,-108(fp)
 3234750:	32317a00 	call	32317a0 <soisconnected>
         tp->t_maxseg = tcp_mss(so);
 3234754:	e13fe517 	ldw	r4,-108(fp)
 3234758:	323622c0 	call	323622c <tcp_mss>
 323475c:	1007883a 	mov	r3,r2
 3234760:	e0bfe717 	ldw	r2,-100(fp)
 3234764:	10c00a0d 	sth	r3,40(r2)
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
 3234768:	e13fe717 	ldw	r4,-100(fp)
 323476c:	000b883a 	mov	r5,zero
 3234770:	e1bff017 	ldw	r6,-64(fp)
 3234774:	32333600 	call	3233360 <tcp_reass>
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 3234778:	e0bfe717 	ldw	r2,-100(fp)
 323477c:	10801e17 	ldw	r2,120(r2)
 3234780:	1005003a 	cmpeq	r2,r2,zero
 3234784:	1000061e 	bne	r2,zero,32347a0 <tcp_input+0x1038>
         {
            tcp_xmit_timer(tp);
 3234788:	e13fe717 	ldw	r4,-100(fp)
 323478c:	3235f780 	call	3235f78 <tcp_xmit_timer>
            if (tp->t_template != NULL)
               tp->t_template->ti_src = ti->ti_dst;
         }
      }
      tp->t_flags |= TF_ACKNOW;
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 3234790:	00000306 	br	32347a0 <tcp_input+0x1038>
         if (tp->t_rttick) 
         {
            tcp_xmit_timer(tp);
         }
      } else
         tp->t_state = TCPS_SYN_RECEIVED;
 3234794:	e0ffe717 	ldw	r3,-100(fp)
 3234798:	008000c4 	movi	r2,3
 323479c:	18800215 	stw	r2,8(r3)
      /*
       * Advance ti->ti_seq to correspond to first data byte.
       * If data, trim to stay within window,
       * dropping FIN if necessary.
       */
      ti->ti_seq++;
 32347a0:	e0bfed17 	ldw	r2,-76(fp)
 32347a4:	10800617 	ldw	r2,24(r2)
 32347a8:	10c00044 	addi	r3,r2,1
 32347ac:	e0bfed17 	ldw	r2,-76(fp)
 32347b0:	10c00615 	stw	r3,24(r2)
      if ((tcp_win)ti->ti_len > tp->rcv_wnd) 
 32347b4:	e0bfed17 	ldw	r2,-76(fp)
 32347b8:	1080028b 	ldhu	r2,10(r2)
 32347bc:	10ffffcc 	andi	r3,r2,65535
 32347c0:	e0bfe717 	ldw	r2,-100(fp)
 32347c4:	10801517 	ldw	r2,84(r2)
 32347c8:	10c02e2e 	bgeu	r2,r3,3234884 <tcp_input+0x111c>
      {
         todrop = ti->ti_len - (u_short)tp->rcv_wnd;
 32347cc:	e0bfed17 	ldw	r2,-76(fp)
 32347d0:	1080028b 	ldhu	r2,10(r2)
 32347d4:	10ffffcc 	andi	r3,r2,65535
 32347d8:	e0bfe717 	ldw	r2,-100(fp)
 32347dc:	10801517 	ldw	r2,84(r2)
 32347e0:	10bfffcc 	andi	r2,r2,65535
 32347e4:	1885c83a 	sub	r2,r3,r2
 32347e8:	e0bfe415 	stw	r2,-112(fp)
         /* XXX work around 4.2 m_adj bug */
         if (m->m_len) 
 32347ec:	e0bff017 	ldw	r2,-64(fp)
 32347f0:	10800217 	ldw	r2,8(r2)
 32347f4:	1005003a 	cmpeq	r2,r2,zero
 32347f8:	1000051e 	bne	r2,zero,3234810 <tcp_input+0x10a8>
         {
            m_adj(m, -todrop);
 32347fc:	e0bfe417 	ldw	r2,-112(fp)
 3234800:	008bc83a 	sub	r5,zero,r2
 3234804:	e13ff017 	ldw	r4,-64(fp)
 3234808:	322bfd00 	call	322bfd0 <m_adj>
 323480c:	00000506 	br	3234824 <tcp_input+0x10bc>
         }
         else 
         {
            /* skip tcp/ip header in first mbuf */
            m_adj(m->m_next, -todrop);
 3234810:	e0bff017 	ldw	r2,-64(fp)
 3234814:	11000617 	ldw	r4,24(r2)
 3234818:	e0bfe417 	ldw	r2,-112(fp)
 323481c:	008bc83a 	sub	r5,zero,r2
 3234820:	322bfd00 	call	322bfd0 <m_adj>
         }
         ti->ti_len = (u_short)tp->rcv_wnd;
 3234824:	e0bfe717 	ldw	r2,-100(fp)
 3234828:	10801517 	ldw	r2,84(r2)
 323482c:	1007883a 	mov	r3,r2
 3234830:	e0bfed17 	ldw	r2,-76(fp)
 3234834:	10c0028d 	sth	r3,10(r2)
         tiflags &= ~TH_FIN;
 3234838:	e0ffe617 	ldw	r3,-104(fp)
 323483c:	00bfff84 	movi	r2,-2
 3234840:	1884703a 	and	r2,r3,r2
 3234844:	e0bfe615 	stw	r2,-104(fp)
         tcpstat.tcps_rcvpackafterwin++;
 3234848:	0080c9b4 	movhi	r2,806
 323484c:	10b3ca04 	addi	r2,r2,-12504
 3234850:	10802517 	ldw	r2,148(r2)
 3234854:	10c00044 	addi	r3,r2,1
 3234858:	0080c9b4 	movhi	r2,806
 323485c:	10b3ca04 	addi	r2,r2,-12504
 3234860:	10c02515 	stw	r3,148(r2)
         tcpstat.tcps_rcvbyteafterwin += todrop;
 3234864:	0080c9b4 	movhi	r2,806
 3234868:	10b3ca04 	addi	r2,r2,-12504
 323486c:	10c02617 	ldw	r3,152(r2)
 3234870:	e0bfe417 	ldw	r2,-112(fp)
 3234874:	1887883a 	add	r3,r3,r2
 3234878:	0080c9b4 	movhi	r2,806
 323487c:	10b3ca04 	addi	r2,r2,-12504
 3234880:	10c02615 	stw	r3,152(r2)
      }
      tp->snd_wl1 = ti->ti_seq - 1;
 3234884:	e0bfed17 	ldw	r2,-76(fp)
 3234888:	10800617 	ldw	r2,24(r2)
 323488c:	10ffffc4 	addi	r3,r2,-1
 3234890:	e0bfe717 	ldw	r2,-100(fp)
 3234894:	10c01115 	stw	r3,68(r2)
      tp->rcv_up = ti->ti_seq;
 3234898:	e0bfed17 	ldw	r2,-76(fp)
 323489c:	10c00617 	ldw	r3,24(r2)
 32348a0:	e0bfe717 	ldw	r2,-100(fp)
 32348a4:	10c01715 	stw	r3,92(r2)
      goto step6;
 32348a8:	00032406 	br	323553c <tcp_input+0x1dd4>
    * States other than LISTEN or SYN_SENT.
    * First check that at least some bytes of segment are within 
    * receive window.  If segment begins before rcv_nxt,
    * drop leading data (and SYN); if nothing left, just ack.
    */
   todrop = (int)(tp->rcv_nxt - ti->ti_seq);
 32348ac:	e0bfe717 	ldw	r2,-100(fp)
 32348b0:	10c01617 	ldw	r3,88(r2)
 32348b4:	e0bfed17 	ldw	r2,-76(fp)
 32348b8:	10800617 	ldw	r2,24(r2)
 32348bc:	1885c83a 	sub	r2,r3,r2
 32348c0:	e0bfe415 	stw	r2,-112(fp)
   if (todrop > 0) 
 32348c4:	e0bfe417 	ldw	r2,-112(fp)
 32348c8:	10800050 	cmplti	r2,r2,1
 32348cc:	1000971e 	bne	r2,zero,3234b2c <tcp_input+0x13c4>
   {
      if (tiflags & TH_SYN) 
 32348d0:	e0bfe617 	ldw	r2,-104(fp)
 32348d4:	1080008c 	andi	r2,r2,2
 32348d8:	1005003a 	cmpeq	r2,r2,zero
 32348dc:	10001c1e 	bne	r2,zero,3234950 <tcp_input+0x11e8>
      {
         tiflags &= ~TH_SYN;
 32348e0:	e0ffe617 	ldw	r3,-104(fp)
 32348e4:	00bfff44 	movi	r2,-3
 32348e8:	1884703a 	and	r2,r3,r2
 32348ec:	e0bfe615 	stw	r2,-104(fp)
         ti->ti_seq++;
 32348f0:	e0bfed17 	ldw	r2,-76(fp)
 32348f4:	10800617 	ldw	r2,24(r2)
 32348f8:	10c00044 	addi	r3,r2,1
 32348fc:	e0bfed17 	ldw	r2,-76(fp)
 3234900:	10c00615 	stw	r3,24(r2)
         if (ti->ti_urp > 1) 
 3234904:	e0bfed17 	ldw	r2,-76(fp)
 3234908:	1080098b 	ldhu	r2,38(r2)
 323490c:	10bfffcc 	andi	r2,r2,65535
 3234910:	108000b0 	cmpltui	r2,r2,2
 3234914:	1000071e 	bne	r2,zero,3234934 <tcp_input+0x11cc>
            ti->ti_urp--;
 3234918:	e0bfed17 	ldw	r2,-76(fp)
 323491c:	1080098b 	ldhu	r2,38(r2)
 3234920:	10bfffc4 	addi	r2,r2,-1
 3234924:	1007883a 	mov	r3,r2
 3234928:	e0bfed17 	ldw	r2,-76(fp)
 323492c:	10c0098d 	sth	r3,38(r2)
 3234930:	00000406 	br	3234944 <tcp_input+0x11dc>
         else
            tiflags &= ~TH_URG;
 3234934:	e0bfe617 	ldw	r2,-104(fp)
 3234938:	00fff7c4 	movi	r3,-33
 323493c:	10c4703a 	and	r2,r2,r3
 3234940:	e0bfe615 	stw	r2,-104(fp)
         todrop--;
 3234944:	e0bfe417 	ldw	r2,-112(fp)
 3234948:	10bfffc4 	addi	r2,r2,-1
 323494c:	e0bfe415 	stw	r2,-112(fp)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 3234950:	e0bfed17 	ldw	r2,-76(fp)
 3234954:	1080028b 	ldhu	r2,10(r2)
 3234958:	10ffffcc 	andi	r3,r2,65535
 323495c:	e0bfe417 	ldw	r2,-112(fp)
 3234960:	18800916 	blt	r3,r2,3234988 <tcp_input+0x1220>
 3234964:	e0bfed17 	ldw	r2,-76(fp)
 3234968:	1080028b 	ldhu	r2,10(r2)
 323496c:	10ffffcc 	andi	r3,r2,65535
 3234970:	e0bfe417 	ldw	r2,-112(fp)
 3234974:	18803a1e 	bne	r3,r2,3234a60 <tcp_input+0x12f8>
 3234978:	e0bfe617 	ldw	r2,-104(fp)
 323497c:	1080004c 	andi	r2,r2,1
 3234980:	1004c03a 	cmpne	r2,r2,zero
 3234984:	1000361e 	bne	r2,zero,3234a60 <tcp_input+0x12f8>
          ((todrop == (int)ti->ti_len) && 
          (tiflags&TH_FIN) == 0)) 
      {
         tcpstat.tcps_rcvduppack++;
 3234988:	0080c9b4 	movhi	r2,806
 323498c:	10b3ca04 	addi	r2,r2,-12504
 3234990:	10801f17 	ldw	r2,124(r2)
 3234994:	10c00044 	addi	r3,r2,1
 3234998:	0080c9b4 	movhi	r2,806
 323499c:	10b3ca04 	addi	r2,r2,-12504
 32349a0:	10c01f15 	stw	r3,124(r2)
         tcpstat.tcps_rcvdupbyte += ti->ti_len;
 32349a4:	0080c9b4 	movhi	r2,806
 32349a8:	10b3ca04 	addi	r2,r2,-12504
 32349ac:	10c02017 	ldw	r3,128(r2)
 32349b0:	e0bfed17 	ldw	r2,-76(fp)
 32349b4:	1080028b 	ldhu	r2,10(r2)
 32349b8:	10bfffcc 	andi	r2,r2,65535
 32349bc:	1887883a 	add	r3,r3,r2
 32349c0:	0080c9b4 	movhi	r2,806
 32349c4:	10b3ca04 	addi	r2,r2,-12504
 32349c8:	10c02015 	stw	r3,128(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 32349cc:	e0bfe617 	ldw	r2,-104(fp)
 32349d0:	1080004c 	andi	r2,r2,1
 32349d4:	1080005c 	xori	r2,r2,1
 32349d8:	10803fcc 	andi	r2,r2,255
 32349dc:	1004c03a 	cmpne	r2,r2,zero
 32349e0:	1000061e 	bne	r2,zero,32349fc <tcp_input+0x1294>
 32349e4:	e0bfed17 	ldw	r2,-76(fp)
 32349e8:	1080028b 	ldhu	r2,10(r2)
 32349ec:	10bfffcc 	andi	r2,r2,65535
 32349f0:	10c00044 	addi	r3,r2,1
 32349f4:	e0bfe417 	ldw	r2,-112(fp)
 32349f8:	18800a26 	beq	r3,r2,3234a24 <tcp_input+0x12bc>
 32349fc:	e0bfe617 	ldw	r2,-104(fp)
 3234a00:	1080010c 	andi	r2,r2,4
 3234a04:	1005003a 	cmpeq	r2,r2,zero
 3234a08:	1004451e 	bne	r2,zero,3235b20 <tcp_input+0x23b8>
 3234a0c:	e0bfed17 	ldw	r2,-76(fp)
 3234a10:	10c00617 	ldw	r3,24(r2)
 3234a14:	e0bfe717 	ldw	r2,-100(fp)
 3234a18:	10801617 	ldw	r2,88(r2)
 3234a1c:	10bfffc4 	addi	r2,r2,-1
 3234a20:	18843f1e 	bne	r3,r2,3235b20 <tcp_input+0x23b8>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
         {
            todrop = ti->ti_len;
 3234a24:	e0bfed17 	ldw	r2,-76(fp)
 3234a28:	1080028b 	ldhu	r2,10(r2)
 3234a2c:	10bfffcc 	andi	r2,r2,65535
 3234a30:	e0bfe415 	stw	r2,-112(fp)
            tiflags &= ~TH_FIN;
 3234a34:	e0ffe617 	ldw	r3,-104(fp)
 3234a38:	00bfff84 	movi	r2,-2
 3234a3c:	1884703a 	and	r2,r3,r2
 3234a40:	e0bfe615 	stw	r2,-104(fp)
            tp->t_flags |= TF_ACKNOW;
 3234a44:	e0bfe717 	ldw	r2,-100(fp)
 3234a48:	10800b0b 	ldhu	r2,44(r2)
 3234a4c:	10800054 	ori	r2,r2,1
 3234a50:	1007883a 	mov	r3,r2
 3234a54:	e0bfe717 	ldw	r2,-100(fp)
 3234a58:	10c00b0d 	sth	r3,44(r2)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 3234a5c:	00000f06 	br	3234a9c <tcp_input+0x1334>
         else
            goto dropafterack;
      }
      else 
      {
         tcpstat.tcps_rcvpartduppack++;
 3234a60:	0080c9b4 	movhi	r2,806
 3234a64:	10b3ca04 	addi	r2,r2,-12504
 3234a68:	10802117 	ldw	r2,132(r2)
 3234a6c:	10c00044 	addi	r3,r2,1
 3234a70:	0080c9b4 	movhi	r2,806
 3234a74:	10b3ca04 	addi	r2,r2,-12504
 3234a78:	10c02115 	stw	r3,132(r2)
         tcpstat.tcps_rcvpartdupbyte += todrop;
 3234a7c:	0080c9b4 	movhi	r2,806
 3234a80:	10b3ca04 	addi	r2,r2,-12504
 3234a84:	10c02217 	ldw	r3,136(r2)
 3234a88:	e0bfe417 	ldw	r2,-112(fp)
 3234a8c:	1887883a 	add	r3,r3,r2
 3234a90:	0080c9b4 	movhi	r2,806
 3234a94:	10b3ca04 	addi	r2,r2,-12504
 3234a98:	10c02215 	stw	r3,136(r2)
      }
      m_adj(m, todrop);
 3234a9c:	e13ff017 	ldw	r4,-64(fp)
 3234aa0:	e17fe417 	ldw	r5,-112(fp)
 3234aa4:	322bfd00 	call	322bfd0 <m_adj>
      ti->ti_seq += todrop;
 3234aa8:	e0bfed17 	ldw	r2,-76(fp)
 3234aac:	10c00617 	ldw	r3,24(r2)
 3234ab0:	e0bfe417 	ldw	r2,-112(fp)
 3234ab4:	1887883a 	add	r3,r3,r2
 3234ab8:	e0bfed17 	ldw	r2,-76(fp)
 3234abc:	10c00615 	stw	r3,24(r2)
      ti->ti_len -= (u_short)todrop;
 3234ac0:	e0bfed17 	ldw	r2,-76(fp)
 3234ac4:	10c0028b 	ldhu	r3,10(r2)
 3234ac8:	e0bfe417 	ldw	r2,-112(fp)
 3234acc:	1885c83a 	sub	r2,r3,r2
 3234ad0:	1007883a 	mov	r3,r2
 3234ad4:	e0bfed17 	ldw	r2,-76(fp)
 3234ad8:	10c0028d 	sth	r3,10(r2)
      if (ti->ti_urp > (u_short)todrop)
 3234adc:	e0bfed17 	ldw	r2,-76(fp)
 3234ae0:	10c0098b 	ldhu	r3,38(r2)
 3234ae4:	e0bfe417 	ldw	r2,-112(fp)
 3234ae8:	18ffffcc 	andi	r3,r3,65535
 3234aec:	10bfffcc 	andi	r2,r2,65535
 3234af0:	10c0082e 	bgeu	r2,r3,3234b14 <tcp_input+0x13ac>
         ti->ti_urp -= (u_short)todrop;
 3234af4:	e0bfed17 	ldw	r2,-76(fp)
 3234af8:	10c0098b 	ldhu	r3,38(r2)
 3234afc:	e0bfe417 	ldw	r2,-112(fp)
 3234b00:	1885c83a 	sub	r2,r3,r2
 3234b04:	1007883a 	mov	r3,r2
 3234b08:	e0bfed17 	ldw	r2,-76(fp)
 3234b0c:	10c0098d 	sth	r3,38(r2)
 3234b10:	00000606 	br	3234b2c <tcp_input+0x13c4>
      else 
      {
         tiflags &= ~TH_URG;
 3234b14:	e0ffe617 	ldw	r3,-104(fp)
 3234b18:	00bff7c4 	movi	r2,-33
 3234b1c:	1884703a 	and	r2,r3,r2
 3234b20:	e0bfe615 	stw	r2,-104(fp)
         ti->ti_urp = 0;
 3234b24:	e0bfed17 	ldw	r2,-76(fp)
 3234b28:	1000098d 	sth	zero,38(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 3234b2c:	e0bfe517 	ldw	r2,-108(fp)
 3234b30:	1080088b 	ldhu	r2,34(r2)
 3234b34:	10bfffcc 	andi	r2,r2,65535
 3234b38:	1080004c 	andi	r2,r2,1
 3234b3c:	10803fcc 	andi	r2,r2,255
 3234b40:	1005003a 	cmpeq	r2,r2,zero
 3234b44:	1000161e 	bne	r2,zero,3234ba0 <tcp_input+0x1438>
 3234b48:	e0bfe717 	ldw	r2,-100(fp)
 3234b4c:	10800217 	ldw	r2,8(r2)
 3234b50:	10800190 	cmplti	r2,r2,6
 3234b54:	1000121e 	bne	r2,zero,3234ba0 <tcp_input+0x1438>
 3234b58:	e0bfed17 	ldw	r2,-76(fp)
 3234b5c:	1080028b 	ldhu	r2,10(r2)
 3234b60:	10bfffcc 	andi	r2,r2,65535
 3234b64:	1005003a 	cmpeq	r2,r2,zero
 3234b68:	10000d1e 	bne	r2,zero,3234ba0 <tcp_input+0x1438>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
   {
      tp = tcp_close(tp);
 3234b6c:	e13fe717 	ldw	r4,-100(fp)
 3234b70:	3237e640 	call	3237e64 <tcp_close>
 3234b74:	e0bfe715 	stw	r2,-100(fp)
      tcpstat.tcps_rcvafterclose++;
 3234b78:	0080c9b4 	movhi	r2,806
 3234b7c:	10b3ca04 	addi	r2,r2,-12504
 3234b80:	10802717 	ldw	r2,156(r2)
 3234b84:	10c00044 	addi	r3,r2,1
 3234b88:	0080c9b4 	movhi	r2,806
 3234b8c:	10b3ca04 	addi	r2,r2,-12504
 3234b90:	10c02715 	stw	r3,156(r2)
      GOTO_DROPWITHRESET;
 3234b94:	00810444 	movi	r2,1041
 3234b98:	d0a8e915 	stw	r2,-23644(gp)
 3234b9c:	0003f206 	br	3235b68 <tcp_input+0x2400>

   /*
    * If segment ends after window, drop trailing data
    * (and PUSH and FIN); if nothing left, just ACK.
    */
   todrop = (int)((ti->ti_seq + (short)ti->ti_len) - (tp->rcv_nxt+tp->rcv_wnd));
 3234ba0:	e0bfed17 	ldw	r2,-76(fp)
 3234ba4:	10c00617 	ldw	r3,24(r2)
 3234ba8:	e0bfed17 	ldw	r2,-76(fp)
 3234bac:	1080028b 	ldhu	r2,10(r2)
 3234bb0:	10bfffcc 	andi	r2,r2,65535
 3234bb4:	10a0001c 	xori	r2,r2,32768
 3234bb8:	10a00004 	addi	r2,r2,-32768
 3234bbc:	1889883a 	add	r4,r3,r2
 3234bc0:	e0bfe717 	ldw	r2,-100(fp)
 3234bc4:	10c01617 	ldw	r3,88(r2)
 3234bc8:	e0bfe717 	ldw	r2,-100(fp)
 3234bcc:	10801517 	ldw	r2,84(r2)
 3234bd0:	1885883a 	add	r2,r3,r2
 3234bd4:	2085c83a 	sub	r2,r4,r2
 3234bd8:	e0bfe415 	stw	r2,-112(fp)
   if (todrop > 0) 
 3234bdc:	e0bfe417 	ldw	r2,-112(fp)
 3234be0:	10800050 	cmplti	r2,r2,1
 3234be4:	10006b1e 	bne	r2,zero,3234d94 <tcp_input+0x162c>
   {
      tcpstat.tcps_rcvpackafterwin++;
 3234be8:	0080c9b4 	movhi	r2,806
 3234bec:	10b3ca04 	addi	r2,r2,-12504
 3234bf0:	10802517 	ldw	r2,148(r2)
 3234bf4:	10c00044 	addi	r3,r2,1
 3234bf8:	0080c9b4 	movhi	r2,806
 3234bfc:	10b3ca04 	addi	r2,r2,-12504
 3234c00:	10c02515 	stw	r3,148(r2)
      if (todrop >= (int)ti->ti_len) 
 3234c04:	e0bfed17 	ldw	r2,-76(fp)
 3234c08:	1080028b 	ldhu	r2,10(r2)
 3234c0c:	10ffffcc 	andi	r3,r2,65535
 3234c10:	e0bfe417 	ldw	r2,-112(fp)
 3234c14:	10c03e16 	blt	r2,r3,3234d10 <tcp_input+0x15a8>
      {
         tcpstat.tcps_rcvbyteafterwin += ti->ti_len;
 3234c18:	0080c9b4 	movhi	r2,806
 3234c1c:	10b3ca04 	addi	r2,r2,-12504
 3234c20:	10c02617 	ldw	r3,152(r2)
 3234c24:	e0bfed17 	ldw	r2,-76(fp)
 3234c28:	1080028b 	ldhu	r2,10(r2)
 3234c2c:	10bfffcc 	andi	r2,r2,65535
 3234c30:	1887883a 	add	r3,r3,r2
 3234c34:	0080c9b4 	movhi	r2,806
 3234c38:	10b3ca04 	addi	r2,r2,-12504
 3234c3c:	10c02615 	stw	r3,152(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 3234c40:	e0bfe617 	ldw	r2,-104(fp)
 3234c44:	1080008c 	andi	r2,r2,2
 3234c48:	1005003a 	cmpeq	r2,r2,zero
 3234c4c:	1000191e 	bne	r2,zero,3234cb4 <tcp_input+0x154c>
 3234c50:	e0bfe717 	ldw	r2,-100(fp)
 3234c54:	10800217 	ldw	r2,8(r2)
 3234c58:	10800298 	cmpnei	r2,r2,10
 3234c5c:	1000151e 	bne	r2,zero,3234cb4 <tcp_input+0x154c>
 3234c60:	e0bfed17 	ldw	r2,-76(fp)
 3234c64:	10c00617 	ldw	r3,24(r2)
 3234c68:	e0bfe717 	ldw	r2,-100(fp)
 3234c6c:	10801617 	ldw	r2,88(r2)
 3234c70:	1885c83a 	sub	r2,r3,r2
 3234c74:	10800050 	cmplti	r2,r2,1
 3234c78:	10000e1e 	bne	r2,zero,3234cb4 <tcp_input+0x154c>
             tp->t_state == TCPS_TIME_WAIT &&
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
         {
            iss = (tcp_seq)(tp->rcv_nxt + (TCP_ISSINCR));
 3234c7c:	e0bfe717 	ldw	r2,-100(fp)
 3234c80:	10c01617 	ldw	r3,88(r2)
 3234c84:	008000b4 	movhi	r2,2
 3234c88:	10bd3fc4 	addi	r2,r2,-2817
 3234c8c:	1885883a 	add	r2,r3,r2
 3234c90:	e0bfdf15 	stw	r2,-132(fp)
            if (iss & 0xff000000)
 3234c94:	e0bfdf17 	ldw	r2,-132(fp)
 3234c98:	10bfc02c 	andhi	r2,r2,65280
 3234c9c:	1005003a 	cmpeq	r2,r2,zero
 3234ca0:	1000011e 	bne	r2,zero,3234ca8 <tcp_input+0x1540>
            {
               iss = 0L;
 3234ca4:	e03fdf15 	stw	zero,-132(fp)
            }
            (void) tcp_close(tp);
 3234ca8:	e13fe717 	ldw	r4,-100(fp)
 3234cac:	3237e640 	call	3237e64 <tcp_close>
            goto findpcb;
 3234cb0:	003b8d06 	br	3233ae8 <tcp_input+0x380>
          * window edge, and have to drop data and PUSH from
          * incoming segments.  Continue processing, but
          * remember to ack.  Otherwise, drop segment
          * and ack.
          */
         if ((tp->rcv_wnd == 0) && (ti->ti_seq == tp->rcv_nxt))
 3234cb4:	e0bfe717 	ldw	r2,-100(fp)
 3234cb8:	10801517 	ldw	r2,84(r2)
 3234cbc:	1004c03a 	cmpne	r2,r2,zero
 3234cc0:	1003971e 	bne	r2,zero,3235b20 <tcp_input+0x23b8>
 3234cc4:	e0bfed17 	ldw	r2,-76(fp)
 3234cc8:	10c00617 	ldw	r3,24(r2)
 3234ccc:	e0bfe717 	ldw	r2,-100(fp)
 3234cd0:	10801617 	ldw	r2,88(r2)
 3234cd4:	1883921e 	bne	r3,r2,3235b20 <tcp_input+0x23b8>
         {
            tp->t_flags |= TF_ACKNOW;
 3234cd8:	e0bfe717 	ldw	r2,-100(fp)
 3234cdc:	10800b0b 	ldhu	r2,44(r2)
 3234ce0:	10800054 	ori	r2,r2,1
 3234ce4:	1007883a 	mov	r3,r2
 3234ce8:	e0bfe717 	ldw	r2,-100(fp)
 3234cec:	10c00b0d 	sth	r3,44(r2)
            tcpstat.tcps_rcvwinprobe++;
 3234cf0:	0080c9b4 	movhi	r2,806
 3234cf4:	10b3ca04 	addi	r2,r2,-12504
 3234cf8:	10802817 	ldw	r2,160(r2)
 3234cfc:	10c00044 	addi	r3,r2,1
 3234d00:	0080c9b4 	movhi	r2,806
 3234d04:	10b3ca04 	addi	r2,r2,-12504
 3234d08:	10c02815 	stw	r3,160(r2)
 3234d0c:	00000806 	br	3234d30 <tcp_input+0x15c8>
         } else
            goto dropafterack;
      } else
         tcpstat.tcps_rcvbyteafterwin += todrop;
 3234d10:	0080c9b4 	movhi	r2,806
 3234d14:	10b3ca04 	addi	r2,r2,-12504
 3234d18:	10c02617 	ldw	r3,152(r2)
 3234d1c:	e0bfe417 	ldw	r2,-112(fp)
 3234d20:	1887883a 	add	r3,r3,r2
 3234d24:	0080c9b4 	movhi	r2,806
 3234d28:	10b3ca04 	addi	r2,r2,-12504
 3234d2c:	10c02615 	stw	r3,152(r2)
      /* XXX work around m_adj bug */
      if (m->m_len) 
 3234d30:	e0bff017 	ldw	r2,-64(fp)
 3234d34:	10800217 	ldw	r2,8(r2)
 3234d38:	1005003a 	cmpeq	r2,r2,zero
 3234d3c:	1000051e 	bne	r2,zero,3234d54 <tcp_input+0x15ec>
      {
         m_adj(m, -todrop);
 3234d40:	e0bfe417 	ldw	r2,-112(fp)
 3234d44:	008bc83a 	sub	r5,zero,r2
 3234d48:	e13ff017 	ldw	r4,-64(fp)
 3234d4c:	322bfd00 	call	322bfd0 <m_adj>
 3234d50:	00000506 	br	3234d68 <tcp_input+0x1600>
      }
      else 
      {
         /* skip tcp/ip header in first mbuf */
         m_adj(m->m_next, -todrop);
 3234d54:	e0bff017 	ldw	r2,-64(fp)
 3234d58:	11000617 	ldw	r4,24(r2)
 3234d5c:	e0bfe417 	ldw	r2,-112(fp)
 3234d60:	008bc83a 	sub	r5,zero,r2
 3234d64:	322bfd00 	call	322bfd0 <m_adj>
      }
      ti->ti_len -= (u_short)todrop;
 3234d68:	e0bfed17 	ldw	r2,-76(fp)
 3234d6c:	10c0028b 	ldhu	r3,10(r2)
 3234d70:	e0bfe417 	ldw	r2,-112(fp)
 3234d74:	1885c83a 	sub	r2,r3,r2
 3234d78:	1007883a 	mov	r3,r2
 3234d7c:	e0bfed17 	ldw	r2,-76(fp)
 3234d80:	10c0028d 	sth	r3,10(r2)
      tiflags &= ~(TH_PUSH|TH_FIN);
 3234d84:	e0ffe617 	ldw	r3,-104(fp)
 3234d88:	00bffd84 	movi	r2,-10
 3234d8c:	1884703a 	and	r2,r3,r2
 3234d90:	e0bfe615 	stw	r2,-104(fp)
      tiflags &= ~TH_RST;  /* clear reset flag */
      goto dropafterack;   /* send an ack and drop current packet */
   }
#endif /* DOS_RST */

   if (tiflags&TH_RST) 
 3234d94:	e0bfe617 	ldw	r2,-104(fp)
 3234d98:	1080010c 	andi	r2,r2,4
 3234d9c:	1005003a 	cmpeq	r2,r2,zero
 3234da0:	1000391e 	bne	r2,zero,3234e88 <tcp_input+0x1720>
   {
      switch (tp->t_state) 
 3234da4:	e0bfe717 	ldw	r2,-100(fp)
 3234da8:	10800217 	ldw	r2,8(r2)
 3234dac:	10bfff44 	addi	r2,r2,-3
 3234db0:	e0bffe15 	stw	r2,-8(fp)
 3234db4:	e13ffe17 	ldw	r4,-8(fp)
 3234db8:	20800228 	cmpgeui	r2,r4,8
 3234dbc:	1000321e 	bne	r2,zero,3234e88 <tcp_input+0x1720>
 3234dc0:	e0fffe17 	ldw	r3,-8(fp)
 3234dc4:	e0fffe17 	ldw	r3,-8(fp)
 3234dc8:	18c5883a 	add	r2,r3,r3
 3234dcc:	1087883a 	add	r3,r2,r2
 3234dd0:	0080c8f4 	movhi	r2,803
 3234dd4:	10937904 	addi	r2,r2,19940
 3234dd8:	1885883a 	add	r2,r3,r2
 3234ddc:	10800017 	ldw	r2,0(r2)
 3234de0:	1000683a 	jmp	r2
 3234de4:	03234e04 	movi	r12,-29384
 3234de8:	03234e14 	movui	r12,36152
 3234dec:	03234e30 	cmpltui	r12,zero,36152
 3234df0:	03234e30 	cmpltui	r12,zero,36152
 3234df4:	03234e74 	movhi	r12,36153
 3234df8:	03234e74 	movhi	r12,36153
 3234dfc:	03234e30 	cmpltui	r12,zero,36152
 3234e00:	03234e74 	movhi	r12,36153
      {
   
      case TCPS_SYN_RECEIVED:
         so->so_error = ECONNREFUSED;
 3234e04:	e0ffe517 	ldw	r3,-108(fp)
 3234e08:	00801bc4 	movi	r2,111
 3234e0c:	18800615 	stw	r2,24(r3)
         goto close;
 3234e10:	00000a06 	br	3234e3c <tcp_input+0x16d4>
   
      case TCPS_ESTABLISHED:
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 3234e14:	0080c9b4 	movhi	r2,806
 3234e18:	10b39c04 	addi	r2,r2,-12688
 3234e1c:	10800717 	ldw	r2,28(r2)
 3234e20:	10c00044 	addi	r3,r2,1
 3234e24:	0080c9b4 	movhi	r2,806
 3234e28:	10b39c04 	addi	r2,r2,-12688
 3234e2c:	10c00715 	stw	r3,28(r2)
      case TCPS_FIN_WAIT_1:
      case TCPS_FIN_WAIT_2:
      case TCPS_CLOSE_WAIT:
         so->so_error = ECONNRESET;
 3234e30:	e0ffe517 	ldw	r3,-108(fp)
 3234e34:	00801a04 	movi	r2,104
 3234e38:	18800615 	stw	r2,24(r3)
         close:
         tp->t_state = TCPS_CLOSED;
 3234e3c:	e0bfe717 	ldw	r2,-100(fp)
 3234e40:	10000215 	stw	zero,8(r2)
         tcpstat.tcps_drops++;
 3234e44:	0080c9b4 	movhi	r2,806
 3234e48:	10b3ca04 	addi	r2,r2,-12504
 3234e4c:	10800317 	ldw	r2,12(r2)
 3234e50:	10c00044 	addi	r3,r2,1
 3234e54:	0080c9b4 	movhi	r2,806
 3234e58:	10b3ca04 	addi	r2,r2,-12504
 3234e5c:	10c00315 	stw	r3,12(r2)
         SETTP(tp, tcp_close(tp));
 3234e60:	e13fe717 	ldw	r4,-100(fp)
 3234e64:	3237e640 	call	3237e64 <tcp_close>
#ifdef TCP_ZEROCOPY
         if (so->rx_upcall)
            so->rx_upcall(so, NULL, ECONNRESET);
#endif   /* TCP_ZEROCOPY */
         GOTO_DROP;
 3234e68:	00812204 	movi	r2,1160
 3234e6c:	d0a8e915 	stw	r2,-23644(gp)
 3234e70:	00038106 	br	3235c78 <tcp_input+0x2510>
   
      case TCPS_CLOSING:
      case TCPS_LAST_ACK:
      case TCPS_TIME_WAIT:
         SETTP(tp, tcp_close(tp));
 3234e74:	e13fe717 	ldw	r4,-100(fp)
 3234e78:	3237e640 	call	3237e64 <tcp_close>
         GOTO_DROP;
 3234e7c:	00812384 	movi	r2,1166
 3234e80:	d0a8e915 	stw	r2,-23644(gp)
 3234e84:	00037c06 	br	3235c78 <tcp_input+0x2510>
     tcp_trace("rcvd SYN in established state - ignoring SYN.\n");
#endif
      GOTO_DROP;
   }
#else
   if (tiflags & TH_SYN) 
 3234e88:	e0bfe617 	ldw	r2,-104(fp)
 3234e8c:	1080008c 	andi	r2,r2,2
 3234e90:	1005003a 	cmpeq	r2,r2,zero
 3234e94:	1000071e 	bne	r2,zero,3234eb4 <tcp_input+0x174c>
   {
      tp = tcp_drop(tp, ECONNRESET);
 3234e98:	e13fe717 	ldw	r4,-100(fp)
 3234e9c:	01401a04 	movi	r5,104
 3234ea0:	3237db80 	call	3237db8 <tcp_drop>
 3234ea4:	e0bfe715 	stw	r2,-100(fp)
      GOTO_DROPWITHRESET;
 3234ea8:	00812b04 	movi	r2,1196
 3234eac:	d0a8e915 	stw	r2,-23644(gp)
 3234eb0:	00032d06 	br	3235b68 <tcp_input+0x2400>
#endif /* end of else of DOS_SYN */

   /*
    * If the ACK bit is off we drop the segment and return.
    */
   if ((tiflags & TH_ACK) == 0)
 3234eb4:	e0bfe617 	ldw	r2,-104(fp)
 3234eb8:	1080040c 	andi	r2,r2,16
 3234ebc:	1004c03a 	cmpne	r2,r2,zero
 3234ec0:	1000031e 	bne	r2,zero,3234ed0 <tcp_input+0x1768>
      GOTO_DROP;
 3234ec4:	00812d04 	movi	r2,1204
 3234ec8:	d0a8e915 	stw	r2,-23644(gp)
 3234ecc:	00036a06 	br	3235c78 <tcp_input+0x2510>

   /*
    * Ack processing.
    */
   switch (tp->t_state) 
 3234ed0:	e0bfe717 	ldw	r2,-100(fp)
 3234ed4:	10800217 	ldw	r2,8(r2)
 3234ed8:	e0bff715 	stw	r2,-36(fp)
 3234edc:	e13ff717 	ldw	r4,-36(fp)
 3234ee0:	208000e0 	cmpeqi	r2,r4,3
 3234ee4:	1000071e 	bne	r2,zero,3234f04 <tcp_input+0x179c>
 3234ee8:	e0fff717 	ldw	r3,-36(fp)
 3234eec:	188000d0 	cmplti	r2,r3,3
 3234ef0:	1001921e 	bne	r2,zero,323553c <tcp_input+0x1dd4>
 3234ef4:	e13ff717 	ldw	r4,-36(fp)
 3234ef8:	208002c8 	cmpgei	r2,r4,11
 3234efc:	10018f1e 	bne	r2,zero,323553c <tcp_input+0x1dd4>
 3234f00:	00003206 	br	3234fcc <tcp_input+0x1864>
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 3234f04:	e0bfe717 	ldw	r2,-100(fp)
 3234f08:	10c00e17 	ldw	r3,56(r2)
 3234f0c:	e0bfed17 	ldw	r2,-76(fp)
 3234f10:	10800717 	ldw	r2,28(r2)
 3234f14:	1885c83a 	sub	r2,r3,r2
 3234f18:	10800048 	cmpgei	r2,r2,1
 3234f1c:	1000071e 	bne	r2,zero,3234f3c <tcp_input+0x17d4>
 3234f20:	e0bfed17 	ldw	r2,-76(fp)
 3234f24:	10c00717 	ldw	r3,28(r2)
 3234f28:	e0bfe717 	ldw	r2,-100(fp)
 3234f2c:	10801a17 	ldw	r2,104(r2)
 3234f30:	1885c83a 	sub	r2,r3,r2
 3234f34:	10800050 	cmplti	r2,r2,1
 3234f38:	10000a1e 	bne	r2,zero,3234f64 <tcp_input+0x17fc>
          SEQ_GT(ti->ti_ack, tp->snd_max))
      {
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 3234f3c:	0080c9b4 	movhi	r2,806
 3234f40:	10b39c04 	addi	r2,r2,-12688
 3234f44:	10800717 	ldw	r2,28(r2)
 3234f48:	10c00044 	addi	r3,r2,1
 3234f4c:	0080c9b4 	movhi	r2,806
 3234f50:	10b39c04 	addi	r2,r2,-12688
 3234f54:	10c00715 	stw	r3,28(r2)
         GOTO_DROPWITHRESET;
 3234f58:	00813184 	movi	r2,1222
 3234f5c:	d0a8e915 	stw	r2,-23644(gp)
 3234f60:	00030106 	br	3235b68 <tcp_input+0x2400>
      }
      tcpstat.tcps_connects++;
 3234f64:	0080c9b4 	movhi	r2,806
 3234f68:	10b3ca04 	addi	r2,r2,-12504
 3234f6c:	10800217 	ldw	r2,8(r2)
 3234f70:	10c00044 	addi	r3,r2,1
 3234f74:	0080c9b4 	movhi	r2,806
 3234f78:	10b3ca04 	addi	r2,r2,-12504
 3234f7c:	10c00215 	stw	r3,8(r2)
      tp->t_state = TCPS_ESTABLISHED;
 3234f80:	e0ffe717 	ldw	r3,-100(fp)
 3234f84:	00800104 	movi	r2,4
 3234f88:	18800215 	stw	r2,8(r3)
      soisconnected(so);
 3234f8c:	e13fe517 	ldw	r4,-108(fp)
 3234f90:	32317a00 	call	32317a0 <soisconnected>
      tp->t_maxseg = tcp_mss(so);
 3234f94:	e13fe517 	ldw	r4,-108(fp)
 3234f98:	323622c0 	call	323622c <tcp_mss>
 3234f9c:	1007883a 	mov	r3,r2
 3234fa0:	e0bfe717 	ldw	r2,-100(fp)
 3234fa4:	10c00a0d 	sth	r3,40(r2)
      (void) tcp_reass(tp, (struct tcpiphdr *)0, m);
 3234fa8:	e13fe717 	ldw	r4,-100(fp)
 3234fac:	000b883a 	mov	r5,zero
 3234fb0:	e1bff017 	ldw	r6,-64(fp)
 3234fb4:	32333600 	call	3233360 <tcp_reass>
      tp->snd_wl1 = ti->ti_seq - 1;
 3234fb8:	e0bfed17 	ldw	r2,-76(fp)
 3234fbc:	10800617 	ldw	r2,24(r2)
 3234fc0:	10ffffc4 	addi	r3,r2,-1
 3234fc4:	e0bfe717 	ldw	r2,-100(fp)
 3234fc8:	10c01115 	stw	r3,68(r2)
   case TCPS_CLOSE_WAIT:
   case TCPS_CLOSING:
   case TCPS_LAST_ACK:
   case TCPS_TIME_WAIT:

      if (SEQ_LEQ(ti->ti_ack, tp->snd_una)) 
 3234fcc:	e0bfed17 	ldw	r2,-76(fp)
 3234fd0:	10c00717 	ldw	r3,28(r2)
 3234fd4:	e0bfe717 	ldw	r2,-100(fp)
 3234fd8:	10800e17 	ldw	r2,56(r2)
 3234fdc:	1885c83a 	sub	r2,r3,r2
 3234fe0:	10800048 	cmpgei	r2,r2,1
 3234fe4:	1000671e 	bne	r2,zero,3235184 <tcp_input+0x1a1c>
      {
         if (ti->ti_len == 0 && rx_win == tp->snd_wnd) 
 3234fe8:	e0bfed17 	ldw	r2,-76(fp)
 3234fec:	1080028b 	ldhu	r2,10(r2)
 3234ff0:	10bfffcc 	andi	r2,r2,65535
 3234ff4:	1004c03a 	cmpne	r2,r2,zero
 3234ff8:	10005f1e 	bne	r2,zero,3235178 <tcp_input+0x1a10>
 3234ffc:	e0bfe717 	ldw	r2,-100(fp)
 3235000:	10c01417 	ldw	r3,80(r2)
 3235004:	e0bfde17 	ldw	r2,-136(fp)
 3235008:	18805b1e 	bne	r3,r2,3235178 <tcp_input+0x1a10>
         {
            tcpstat.tcps_rcvdupack++;
 323500c:	0080c9b4 	movhi	r2,806
 3235010:	10b3ca04 	addi	r2,r2,-12504
 3235014:	10802917 	ldw	r2,164(r2)
 3235018:	10c00044 	addi	r3,r2,1
 323501c:	0080c9b4 	movhi	r2,806
 3235020:	10b3ca04 	addi	r2,r2,-12504
 3235024:	10c02915 	stw	r3,164(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 3235028:	e0bfe717 	ldw	r2,-100(fp)
 323502c:	10800317 	ldw	r2,12(r2)
 3235030:	1005003a 	cmpeq	r2,r2,zero
 3235034:	1000051e 	bne	r2,zero,323504c <tcp_input+0x18e4>
 3235038:	e0bfed17 	ldw	r2,-76(fp)
 323503c:	10c00717 	ldw	r3,28(r2)
 3235040:	e0bfe717 	ldw	r2,-100(fp)
 3235044:	10800e17 	ldw	r2,56(r2)
 3235048:	18800326 	beq	r3,r2,3235058 <tcp_input+0x18f0>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
 323504c:	e0bfe717 	ldw	r2,-100(fp)
 3235050:	10000915 	stw	zero,36(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 3235054:	00013906 	br	323553c <tcp_input+0x1dd4>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
 3235058:	e0bfe717 	ldw	r2,-100(fp)
 323505c:	10800917 	ldw	r2,36(r2)
 3235060:	10c00044 	addi	r3,r2,1
 3235064:	e0bfe717 	ldw	r2,-100(fp)
 3235068:	10c00915 	stw	r3,36(r2)
 323506c:	e0bfe717 	ldw	r2,-100(fp)
 3235070:	10c00917 	ldw	r3,36(r2)
 3235074:	d0a03883 	ldbu	r2,-32542(gp)
 3235078:	10803fcc 	andi	r2,r2,255
 323507c:	1080201c 	xori	r2,r2,128
 3235080:	10bfe004 	addi	r2,r2,-128
 3235084:	18812d1e 	bne	r3,r2,323553c <tcp_input+0x1dd4>
            {
               tcp_seq onxt = tp->snd_nxt;
 3235088:	e0bfe717 	ldw	r2,-100(fp)
 323508c:	10800f17 	ldw	r2,60(r2)
 3235090:	e0bfd715 	stw	r2,-164(fp)
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
               tp->t_maxseg;
 3235094:	e0bfe717 	ldw	r2,-100(fp)
 3235098:	10c01417 	ldw	r3,80(r2)
 323509c:	e0bfe717 	ldw	r2,-100(fp)
 32350a0:	10801b17 	ldw	r2,108(r2)
 32350a4:	e0bff615 	stw	r2,-40(fp)
 32350a8:	e0fff515 	stw	r3,-44(fp)
 32350ac:	e0bff617 	ldw	r2,-40(fp)
 32350b0:	e0fff517 	ldw	r3,-44(fp)
 32350b4:	10c0022e 	bgeu	r2,r3,32350c0 <tcp_input+0x1958>
 32350b8:	e13ff617 	ldw	r4,-40(fp)
 32350bc:	e13ff515 	stw	r4,-44(fp)
 32350c0:	e0bff517 	ldw	r2,-44(fp)
 32350c4:	1008d07a 	srli	r4,r2,1
 32350c8:	e0bfe717 	ldw	r2,-100(fp)
 32350cc:	10800a0b 	ldhu	r2,40(r2)
 32350d0:	117fffcc 	andi	r5,r2,65535
 32350d4:	32044bc0 	call	32044bc <__udivsi3>
 32350d8:	e0bfd60d 	sth	r2,-168(fp)

               if (win < 2)
 32350dc:	e0bfd60b 	ldhu	r2,-168(fp)
 32350e0:	108000a8 	cmpgeui	r2,r2,2
 32350e4:	1000021e 	bne	r2,zero,32350f0 <tcp_input+0x1988>
                  win = 2;
 32350e8:	00800084 	movi	r2,2
 32350ec:	e0bfd60d 	sth	r2,-168(fp)
               tp->snd_ssthresh = (u_short)(win * tp->t_maxseg);
 32350f0:	e0bfe717 	ldw	r2,-100(fp)
 32350f4:	10c00a0b 	ldhu	r3,40(r2)
 32350f8:	e0bfd60b 	ldhu	r2,-168(fp)
 32350fc:	1885383a 	mul	r2,r3,r2
 3235100:	10ffffcc 	andi	r3,r2,65535
 3235104:	e0bfe717 	ldw	r2,-100(fp)
 3235108:	10c01c15 	stw	r3,112(r2)

               tp->t_timer[TCPT_REXMT] = 0;
 323510c:	e0bfe717 	ldw	r2,-100(fp)
 3235110:	10000315 	stw	zero,12(r2)
               tp->t_rttick = 0;
 3235114:	e0bfe717 	ldw	r2,-100(fp)
 3235118:	10001e15 	stw	zero,120(r2)
               tp->snd_nxt = ti->ti_ack;
 323511c:	e0bfed17 	ldw	r2,-76(fp)
 3235120:	10c00717 	ldw	r3,28(r2)
 3235124:	e0bfe717 	ldw	r2,-100(fp)
 3235128:	10c00f15 	stw	r3,60(r2)
               tp->snd_cwnd = tp->t_maxseg;
 323512c:	e0bfe717 	ldw	r2,-100(fp)
 3235130:	10800a0b 	ldhu	r2,40(r2)
 3235134:	10ffffcc 	andi	r3,r2,65535
 3235138:	e0bfe717 	ldw	r2,-100(fp)
 323513c:	10c01b15 	stw	r3,108(r2)
               (void) tcp_output(tp);
 3235140:	e13fe717 	ldw	r4,-100(fp)
 3235144:	32363480 	call	3236348 <tcp_output>

               if (SEQ_GT(onxt, tp->snd_nxt))
 3235148:	e0bfe717 	ldw	r2,-100(fp)
 323514c:	10c00f17 	ldw	r3,60(r2)
 3235150:	e0bfd717 	ldw	r2,-164(fp)
 3235154:	10c5c83a 	sub	r2,r2,r3
 3235158:	10800050 	cmplti	r2,r2,1
 323515c:	1000031e 	bne	r2,zero,323516c <tcp_input+0x1a04>
                  tp->snd_nxt = onxt;
 3235160:	e0ffe717 	ldw	r3,-100(fp)
 3235164:	e0bfd717 	ldw	r2,-164(fp)
 3235168:	18800f15 	stw	r2,60(r3)
               GOTO_DROP;
 323516c:	00814544 	movi	r2,1301
 3235170:	d0a8e915 	stw	r2,-23644(gp)
 3235174:	0002c006 	br	3235c78 <tcp_input+0x2510>
            }
         } else
            tp->t_dupacks = 0;
 3235178:	e0bfe717 	ldw	r2,-100(fp)
 323517c:	10000915 	stw	zero,36(r2)
         break;
 3235180:	0000ee06 	br	323553c <tcp_input+0x1dd4>
      }
      tp->t_dupacks = 0;
 3235184:	e0bfe717 	ldw	r2,-100(fp)
 3235188:	10000915 	stw	zero,36(r2)
      if (SEQ_GT(ti->ti_ack, tp->snd_max)) 
 323518c:	e0bfed17 	ldw	r2,-76(fp)
 3235190:	10c00717 	ldw	r3,28(r2)
 3235194:	e0bfe717 	ldw	r2,-100(fp)
 3235198:	10801a17 	ldw	r2,104(r2)
 323519c:	1885c83a 	sub	r2,r3,r2
 32351a0:	10800050 	cmplti	r2,r2,1
 32351a4:	1000081e 	bne	r2,zero,32351c8 <tcp_input+0x1a60>
      {
         tcpstat.tcps_rcvacktoomuch++;
 32351a8:	0080c9b4 	movhi	r2,806
 32351ac:	10b3ca04 	addi	r2,r2,-12504
 32351b0:	10802a17 	ldw	r2,168(r2)
 32351b4:	10c00044 	addi	r3,r2,1
 32351b8:	0080c9b4 	movhi	r2,806
 32351bc:	10b3ca04 	addi	r2,r2,-12504
 32351c0:	10c02a15 	stw	r3,168(r2)
         goto dropafterack;
 32351c4:	00025606 	br	3235b20 <tcp_input+0x23b8>
      }
      acked = (int)(ti->ti_ack - tp->snd_una);
 32351c8:	e0bfed17 	ldw	r2,-76(fp)
 32351cc:	10c00717 	ldw	r3,28(r2)
 32351d0:	e0bfe717 	ldw	r2,-100(fp)
 32351d4:	10800e17 	ldw	r2,56(r2)
 32351d8:	1885c83a 	sub	r2,r3,r2
 32351dc:	e0bfe315 	stw	r2,-116(fp)
      tcpstat.tcps_rcvackpack++;
 32351e0:	0080c9b4 	movhi	r2,806
 32351e4:	10b3ca04 	addi	r2,r2,-12504
 32351e8:	10802b17 	ldw	r2,172(r2)
 32351ec:	10c00044 	addi	r3,r2,1
 32351f0:	0080c9b4 	movhi	r2,806
 32351f4:	10b3ca04 	addi	r2,r2,-12504
 32351f8:	10c02b15 	stw	r3,172(r2)
      tcpstat.tcps_rcvackbyte += acked;
 32351fc:	0080c9b4 	movhi	r2,806
 3235200:	10b3ca04 	addi	r2,r2,-12504
 3235204:	10c02c17 	ldw	r3,176(r2)
 3235208:	e0bfe317 	ldw	r2,-116(fp)
 323520c:	1887883a 	add	r3,r3,r2
 3235210:	0080c9b4 	movhi	r2,806
 3235214:	10b3ca04 	addi	r2,r2,-12504
 3235218:	10c02c15 	stw	r3,176(r2)
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 323521c:	e0bfe717 	ldw	r2,-100(fp)
 3235220:	10801e17 	ldw	r2,120(r2)
 3235224:	1005003a 	cmpeq	r2,r2,zero
 3235228:	1000091e 	bne	r2,zero,3235250 <tcp_input+0x1ae8>
 323522c:	e0bfed17 	ldw	r2,-76(fp)
 3235230:	10c00717 	ldw	r3,28(r2)
 3235234:	e0bfe717 	ldw	r2,-100(fp)
 3235238:	10801f17 	ldw	r2,124(r2)
 323523c:	1885c83a 	sub	r2,r3,r2
 3235240:	10800050 	cmplti	r2,r2,1
 3235244:	1000021e 	bne	r2,zero,3235250 <tcp_input+0x1ae8>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
         tcp_xmit_timer(tp);
 3235248:	e13fe717 	ldw	r4,-100(fp)
 323524c:	3235f780 	call	3235f78 <tcp_xmit_timer>
       * If all outstanding data is acked, stop retransmit
       * timer and remember to restart (more output or persist).
       * If there is more data to be acked, restart retransmit
       * timer, using current (possibly backed-off) value.
       */
      if (ti->ti_ack == tp->snd_max) 
 3235250:	e0bfed17 	ldw	r2,-76(fp)
 3235254:	10c00717 	ldw	r3,28(r2)
 3235258:	e0bfe717 	ldw	r2,-100(fp)
 323525c:	10801a17 	ldw	r2,104(r2)
 3235260:	1880051e 	bne	r3,r2,3235278 <tcp_input+0x1b10>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 3235264:	e0bfe717 	ldw	r2,-100(fp)
 3235268:	10000315 	stw	zero,12(r2)
         needoutput = 1;
 323526c:	00800044 	movi	r2,1
 3235270:	e0bfe115 	stw	r2,-124(fp)
 3235274:	00000806 	br	3235298 <tcp_input+0x1b30>
      } else if (tp->t_timer[TCPT_PERSIST] == 0)
 3235278:	e0bfe717 	ldw	r2,-100(fp)
 323527c:	10800417 	ldw	r2,16(r2)
 3235280:	1004c03a 	cmpne	r2,r2,zero
 3235284:	1000041e 	bne	r2,zero,3235298 <tcp_input+0x1b30>
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 3235288:	e0bfe717 	ldw	r2,-100(fp)
 323528c:	10c00817 	ldw	r3,32(r2)
 3235290:	e0bfe717 	ldw	r2,-100(fp)
 3235294:	10c00315 	stw	r3,12(r2)
       * in flight, open exponentially (maxseg per packet).
       * Otherwise open linearly (maxseg per window,
       * or maxseg^2 / cwnd per packet).
       */
      {
         tcp_win  cw =  tp->snd_cwnd;
 3235298:	e0bfe717 	ldw	r2,-100(fp)
 323529c:	10801b17 	ldw	r2,108(r2)
 32352a0:	e0bfd515 	stw	r2,-172(fp)
         u_short  incr  =  tp->t_maxseg;
 32352a4:	e0bfe717 	ldw	r2,-100(fp)
 32352a8:	10800a0b 	ldhu	r2,40(r2)
 32352ac:	e0bfd40d 	sth	r2,-176(fp)

         if (cw > tp->snd_ssthresh)
 32352b0:	e0bfe717 	ldw	r2,-100(fp)
 32352b4:	10c01c17 	ldw	r3,112(r2)
 32352b8:	e0bfd517 	ldw	r2,-172(fp)
 32352bc:	18800e2e 	bgeu	r3,r2,32352f8 <tcp_input+0x1b90>
            incr = MAX( (incr * incr / cw), (ALIGN_TYPE << 2) );
 32352c0:	e0ffd40b 	ldhu	r3,-176(fp)
 32352c4:	e0bfd40b 	ldhu	r2,-176(fp)
 32352c8:	1885383a 	mul	r2,r3,r2
 32352cc:	1009883a 	mov	r4,r2
 32352d0:	e17fd517 	ldw	r5,-172(fp)
 32352d4:	32044bc0 	call	32044bc <__udivsi3>
 32352d8:	e0bff415 	stw	r2,-48(fp)
 32352dc:	e0fff417 	ldw	r3,-48(fp)
 32352e0:	18800428 	cmpgeui	r2,r3,16
 32352e4:	1000021e 	bne	r2,zero,32352f0 <tcp_input+0x1b88>
 32352e8:	01000404 	movi	r4,16
 32352ec:	e13ff415 	stw	r4,-48(fp)
 32352f0:	e0bff417 	ldw	r2,-48(fp)
 32352f4:	e0bfd40d 	sth	r2,-176(fp)

         tp->snd_cwnd = MIN(cw + (u_short)incr, (IP_MAXPACKET));
 32352f8:	e0ffd40b 	ldhu	r3,-176(fp)
 32352fc:	e0bfd517 	ldw	r2,-172(fp)
 3235300:	1885883a 	add	r2,r3,r2
 3235304:	e0bff315 	stw	r2,-52(fp)
 3235308:	e0fff317 	ldw	r3,-52(fp)
 323530c:	18980070 	cmpltui	r2,r3,24577
 3235310:	1000021e 	bne	r2,zero,323531c <tcp_input+0x1bb4>
 3235314:	01180004 	movi	r4,24576
 3235318:	e13ff315 	stw	r4,-52(fp)
 323531c:	e0bfe717 	ldw	r2,-100(fp)
 3235320:	e0fff317 	ldw	r3,-52(fp)
 3235324:	10c01b15 	stw	r3,108(r2)
      }
      if (acked > (int)so->so_snd.sb_cc) 
 3235328:	e0bfe517 	ldw	r2,-108(fp)
 323532c:	10801217 	ldw	r2,72(r2)
 3235330:	1007883a 	mov	r3,r2
 3235334:	e0bfe317 	ldw	r2,-116(fp)
 3235338:	1880110e 	bge	r3,r2,3235380 <tcp_input+0x1c18>
      {
         tp->snd_wnd -= (u_short)so->so_snd.sb_cc;
 323533c:	e0bfe717 	ldw	r2,-100(fp)
 3235340:	10c01417 	ldw	r3,80(r2)
 3235344:	e0bfe517 	ldw	r2,-108(fp)
 3235348:	10801217 	ldw	r2,72(r2)
 323534c:	10bfffcc 	andi	r2,r2,65535
 3235350:	1887c83a 	sub	r3,r3,r2
 3235354:	e0bfe717 	ldw	r2,-100(fp)
 3235358:	10c01415 	stw	r3,80(r2)
         sbdrop(&so->so_snd, (int)so->so_snd.sb_cc);
 323535c:	e0bfe517 	ldw	r2,-108(fp)
 3235360:	11001204 	addi	r4,r2,72
 3235364:	e0bfe517 	ldw	r2,-108(fp)
 3235368:	10801217 	ldw	r2,72(r2)
 323536c:	100b883a 	mov	r5,r2
 3235370:	32326d80 	call	32326d8 <sbdrop>
         ourfinisacked = 1;
 3235374:	00800044 	movi	r2,1
 3235378:	e0bfe215 	stw	r2,-120(fp)
 323537c:	00000c06 	br	32353b0 <tcp_input+0x1c48>
      } 
      else 
      {
         sbdrop(&so->so_snd, acked);
 3235380:	e0bfe517 	ldw	r2,-108(fp)
 3235384:	11001204 	addi	r4,r2,72
 3235388:	e17fe317 	ldw	r5,-116(fp)
 323538c:	32326d80 	call	32326d8 <sbdrop>
         tp->snd_wnd -= (u_short)acked;
 3235390:	e0bfe717 	ldw	r2,-100(fp)
 3235394:	10c01417 	ldw	r3,80(r2)
 3235398:	e0bfe317 	ldw	r2,-116(fp)
 323539c:	10bfffcc 	andi	r2,r2,65535
 32353a0:	1887c83a 	sub	r3,r3,r2
 32353a4:	e0bfe717 	ldw	r2,-100(fp)
 32353a8:	10c01415 	stw	r3,80(r2)
         ourfinisacked = 0;
 32353ac:	e03fe215 	stw	zero,-120(fp)
      }

      if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 32353b0:	e0bfe517 	ldw	r2,-108(fp)
 32353b4:	1080190b 	ldhu	r2,100(r2)
 32353b8:	10bfffcc 	andi	r2,r2,65535
 32353bc:	1080030c 	andi	r2,r2,12
 32353c0:	1005003a 	cmpeq	r2,r2,zero
 32353c4:	1000041e 	bne	r2,zero,32353d8 <tcp_input+0x1c70>
         sowwakeup(so);
 32353c8:	e0bfe517 	ldw	r2,-108(fp)
 32353cc:	11401204 	addi	r5,r2,72
 32353d0:	e13fe517 	ldw	r4,-108(fp)
 32353d4:	3231f0c0 	call	3231f0c <sbwakeup>

      tp->snd_una = ti->ti_ack;
 32353d8:	e0bfed17 	ldw	r2,-76(fp)
 32353dc:	10c00717 	ldw	r3,28(r2)
 32353e0:	e0bfe717 	ldw	r2,-100(fp)
 32353e4:	10c00e15 	stw	r3,56(r2)
      if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 32353e8:	e0bfe717 	ldw	r2,-100(fp)
 32353ec:	10c00f17 	ldw	r3,60(r2)
 32353f0:	e0bfe717 	ldw	r2,-100(fp)
 32353f4:	10800e17 	ldw	r2,56(r2)
 32353f8:	1885c83a 	sub	r2,r3,r2
 32353fc:	1004403a 	cmpge	r2,r2,zero
 3235400:	1000041e 	bne	r2,zero,3235414 <tcp_input+0x1cac>
         tp->snd_nxt = tp->snd_una;
 3235404:	e0bfe717 	ldw	r2,-100(fp)
 3235408:	10c00e17 	ldw	r3,56(r2)
 323540c:	e0bfe717 	ldw	r2,-100(fp)
 3235410:	10c00f15 	stw	r3,60(r2)


      switch (tp->t_state) 
 3235414:	e0bfe717 	ldw	r2,-100(fp)
 3235418:	10800217 	ldw	r2,8(r2)
 323541c:	e0bff215 	stw	r2,-56(fp)
 3235420:	e13ff217 	ldw	r4,-56(fp)
 3235424:	208001e0 	cmpeqi	r2,r4,7
 3235428:	1000221e 	bne	r2,zero,32354b4 <tcp_input+0x1d4c>
 323542c:	e0fff217 	ldw	r3,-56(fp)
 3235430:	18800208 	cmpgei	r2,r3,8
 3235434:	1000041e 	bne	r2,zero,3235448 <tcp_input+0x1ce0>
 3235438:	e13ff217 	ldw	r4,-56(fp)
 323543c:	208001a0 	cmpeqi	r2,r4,6
 3235440:	1000081e 	bne	r2,zero,3235464 <tcp_input+0x1cfc>
 3235444:	00003d06 	br	323553c <tcp_input+0x1dd4>
 3235448:	e0fff217 	ldw	r3,-56(fp)
 323544c:	18800220 	cmpeqi	r2,r3,8
 3235450:	10002a1e 	bne	r2,zero,32354fc <tcp_input+0x1d94>
 3235454:	e13ff217 	ldw	r4,-56(fp)
 3235458:	208002a0 	cmpeqi	r2,r4,10
 323545c:	10002f1e 	bne	r2,zero,323551c <tcp_input+0x1db4>
 3235460:	00003606 	br	323553c <tcp_input+0x1dd4>
       * In FIN_WAIT_1 STATE in addition to the processing
       * for the ESTABLISHED state if our FIN is now acknowledged
       * then enter FIN_WAIT_2.
       */
      case TCPS_FIN_WAIT_1:
         if (ourfinisacked) 
 3235464:	e0bfe217 	ldw	r2,-120(fp)
 3235468:	1005003a 	cmpeq	r2,r2,zero
 323546c:	1000331e 	bne	r2,zero,323553c <tcp_input+0x1dd4>
             * data, then closing user can proceed.
             * Starting the timer is contrary to the
             * specification, but if we don't get a FIN
             * we'll hang forever.
             */
            if (so->so_state & SS_CANTRCVMORE) 
 3235470:	e0bfe517 	ldw	r2,-108(fp)
 3235474:	1080088b 	ldhu	r2,34(r2)
 3235478:	10bfffcc 	andi	r2,r2,65535
 323547c:	1080080c 	andi	r2,r2,32
 3235480:	1005003a 	cmpeq	r2,r2,zero
 3235484:	1000071e 	bne	r2,zero,32354a4 <tcp_input+0x1d3c>
            {
               soisdisconnected(so);
 3235488:	e13fe517 	ldw	r4,-108(fp)
 323548c:	32319280 	call	3231928 <soisdisconnected>
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
 3235490:	0080c974 	movhi	r2,805
 3235494:	10926204 	addi	r2,r2,18824
 3235498:	10c00017 	ldw	r3,0(r2)
 323549c:	e0bfe717 	ldw	r2,-100(fp)
 32354a0:	10c00615 	stw	r3,24(r2)
            }
            tp->t_state = TCPS_FIN_WAIT_2;
 32354a4:	e0ffe717 	ldw	r3,-100(fp)
 32354a8:	00800244 	movi	r2,9
 32354ac:	18800215 	stw	r2,8(r3)
         }
         break;
 32354b0:	00002206 	br	323553c <tcp_input+0x1dd4>
       * the ESTABLISHED state if the ACK acknowledges our FIN
       * then enter the TIME-WAIT state, otherwise ignore
       * the segment.
       */
      case TCPS_CLOSING:
         if (ourfinisacked) 
 32354b4:	e0bfe217 	ldw	r2,-120(fp)
 32354b8:	1005003a 	cmpeq	r2,r2,zero
 32354bc:	10001f1e 	bne	r2,zero,323553c <tcp_input+0x1dd4>
         {
            tp->t_state = TCPS_TIME_WAIT;
 32354c0:	e0ffe717 	ldw	r3,-100(fp)
 32354c4:	00800284 	movi	r2,10
 32354c8:	18800215 	stw	r2,8(r3)
            tcp_canceltimers(tp);
 32354cc:	e13fe717 	ldw	r4,-100(fp)
 32354d0:	32383300 	call	3238330 <tcp_canceltimers>
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 32354d4:	0080c974 	movhi	r2,805
 32354d8:	1089ae04 	addi	r2,r2,9912
 32354dc:	10800017 	ldw	r2,0(r2)
 32354e0:	1085883a 	add	r2,r2,r2
 32354e4:	1007883a 	mov	r3,r2
 32354e8:	e0bfe717 	ldw	r2,-100(fp)
 32354ec:	10c00615 	stw	r3,24(r2)
            soisdisconnected(so);
 32354f0:	e13fe517 	ldw	r4,-108(fp)
 32354f4:	32319280 	call	3231928 <soisdisconnected>
         }
         break;
 32354f8:	00001006 	br	323553c <tcp_input+0x1dd4>
       * and/or to be acked, as well as for the ack of our FIN.
       * If our FIN is now acknowledged, delete the TCB,
       * enter the closed state and return.
       */
      case TCPS_LAST_ACK:
         if (ourfinisacked) 
 32354fc:	e0bfe217 	ldw	r2,-120(fp)
 3235500:	1005003a 	cmpeq	r2,r2,zero
 3235504:	10000d1e 	bne	r2,zero,323553c <tcp_input+0x1dd4>
         {
            SETTP(tp, tcp_close(tp));
 3235508:	e13fe717 	ldw	r4,-100(fp)
 323550c:	3237e640 	call	3237e64 <tcp_close>
            GOTO_DROP;
 3235510:	00816644 	movi	r2,1433
 3235514:	d0a8e915 	stw	r2,-23644(gp)
 3235518:	0001d706 	br	3235c78 <tcp_input+0x2510>
       * In TIME_WAIT state the only thing that should arrive
       * is a retransmission of the remote FIN.  Acknowledge
       * it and restart the finack timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 323551c:	0080c974 	movhi	r2,805
 3235520:	1089ae04 	addi	r2,r2,9912
 3235524:	10800017 	ldw	r2,0(r2)
 3235528:	1085883a 	add	r2,r2,r2
 323552c:	1007883a 	mov	r3,r2
 3235530:	e0bfe717 	ldw	r2,-100(fp)
 3235534:	10c00615 	stw	r3,24(r2)
         goto dropafterack;
 3235538:	00017906 	br	3235b20 <tcp_input+0x23b8>
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 323553c:	e0bfe617 	ldw	r2,-104(fp)
 3235540:	1080040c 	andi	r2,r2,16
 3235544:	1005003a 	cmpeq	r2,r2,zero
 3235548:	1000471e 	bne	r2,zero,3235668 <tcp_input+0x1f00>
 323554c:	e0bfe717 	ldw	r2,-100(fp)
 3235550:	10c01117 	ldw	r3,68(r2)
 3235554:	e0bfed17 	ldw	r2,-76(fp)
 3235558:	10800617 	ldw	r2,24(r2)
 323555c:	1885c83a 	sub	r2,r3,r2
 3235560:	1004803a 	cmplt	r2,r2,zero
 3235564:	1000151e 	bne	r2,zero,32355bc <tcp_input+0x1e54>
 3235568:	e0bfe717 	ldw	r2,-100(fp)
 323556c:	10c01117 	ldw	r3,68(r2)
 3235570:	e0bfed17 	ldw	r2,-76(fp)
 3235574:	10800617 	ldw	r2,24(r2)
 3235578:	18803b1e 	bne	r3,r2,3235668 <tcp_input+0x1f00>
 323557c:	e0bfe717 	ldw	r2,-100(fp)
 3235580:	10c01217 	ldw	r3,72(r2)
 3235584:	e0bfed17 	ldw	r2,-76(fp)
 3235588:	10800717 	ldw	r2,28(r2)
 323558c:	1885c83a 	sub	r2,r3,r2
 3235590:	1004803a 	cmplt	r2,r2,zero
 3235594:	1000091e 	bne	r2,zero,32355bc <tcp_input+0x1e54>
 3235598:	e0bfe717 	ldw	r2,-100(fp)
 323559c:	10c01217 	ldw	r3,72(r2)
 32355a0:	e0bfed17 	ldw	r2,-76(fp)
 32355a4:	10800717 	ldw	r2,28(r2)
 32355a8:	18802f1e 	bne	r3,r2,3235668 <tcp_input+0x1f00>
 32355ac:	e0bfe717 	ldw	r2,-100(fp)
 32355b0:	10c01417 	ldw	r3,80(r2)
 32355b4:	e0bfde17 	ldw	r2,-136(fp)
 32355b8:	18802b2e 	bgeu	r3,r2,3235668 <tcp_input+0x1f00>
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 32355bc:	e0bfed17 	ldw	r2,-76(fp)
 32355c0:	1080028b 	ldhu	r2,10(r2)
 32355c4:	10bfffcc 	andi	r2,r2,65535
 32355c8:	1004c03a 	cmpne	r2,r2,zero
 32355cc:	1000101e 	bne	r2,zero,3235610 <tcp_input+0x1ea8>
 32355d0:	e0bfe717 	ldw	r2,-100(fp)
 32355d4:	10c01217 	ldw	r3,72(r2)
 32355d8:	e0bfed17 	ldw	r2,-76(fp)
 32355dc:	10800717 	ldw	r2,28(r2)
 32355e0:	18800b1e 	bne	r3,r2,3235610 <tcp_input+0x1ea8>
 32355e4:	e0bfe717 	ldw	r2,-100(fp)
 32355e8:	10c01417 	ldw	r3,80(r2)
 32355ec:	e0bfde17 	ldw	r2,-136(fp)
 32355f0:	1880072e 	bgeu	r3,r2,3235610 <tcp_input+0x1ea8>
          (tp->snd_wl2 == ti->ti_ack) &&
          (rx_win > tp->snd_wnd))
      {
         tcpstat.tcps_rcvwinupd++;
 32355f4:	0080c9b4 	movhi	r2,806
 32355f8:	10b3ca04 	addi	r2,r2,-12504
 32355fc:	10802d17 	ldw	r2,180(r2)
 3235600:	10c00044 	addi	r3,r2,1
 3235604:	0080c9b4 	movhi	r2,806
 3235608:	10b3ca04 	addi	r2,r2,-12504
 323560c:	10c02d15 	stw	r3,180(r2)
      }
      tp->snd_wnd = rx_win;
 3235610:	e0ffe717 	ldw	r3,-100(fp)
 3235614:	e0bfde17 	ldw	r2,-136(fp)
 3235618:	18801415 	stw	r2,80(r3)
      tp->snd_wl1 = ti->ti_seq;
 323561c:	e0bfed17 	ldw	r2,-76(fp)
 3235620:	10c00617 	ldw	r3,24(r2)
 3235624:	e0bfe717 	ldw	r2,-100(fp)
 3235628:	10c01115 	stw	r3,68(r2)
      tp->snd_wl2 = ti->ti_ack;
 323562c:	e0bfed17 	ldw	r2,-76(fp)
 3235630:	10c00717 	ldw	r3,28(r2)
 3235634:	e0bfe717 	ldw	r2,-100(fp)
 3235638:	10c01215 	stw	r3,72(r2)
      if (tp->snd_wnd > tp->max_sndwnd)
 323563c:	e0bfe717 	ldw	r2,-100(fp)
 3235640:	10c01417 	ldw	r3,80(r2)
 3235644:	e0bfe717 	ldw	r2,-100(fp)
 3235648:	10802317 	ldw	r2,140(r2)
 323564c:	10c0042e 	bgeu	r2,r3,3235660 <tcp_input+0x1ef8>
         tp->max_sndwnd = tp->snd_wnd;
 3235650:	e0bfe717 	ldw	r2,-100(fp)
 3235654:	10c01417 	ldw	r3,80(r2)
 3235658:	e0bfe717 	ldw	r2,-100(fp)
 323565c:	10c02315 	stw	r3,140(r2)
      needoutput = 1;
 3235660:	00800044 	movi	r2,1
 3235664:	e0bfe115 	stw	r2,-124(fp)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 3235668:	e0bfe617 	ldw	r2,-104(fp)
 323566c:	1080080c 	andi	r2,r2,32
 3235670:	1005003a 	cmpeq	r2,r2,zero
 3235674:	10005a1e 	bne	r2,zero,32357e0 <tcp_input+0x2078>
 3235678:	e0bfed17 	ldw	r2,-76(fp)
 323567c:	1080098b 	ldhu	r2,38(r2)
 3235680:	10bfffcc 	andi	r2,r2,65535
 3235684:	1005003a 	cmpeq	r2,r2,zero
 3235688:	1000551e 	bne	r2,zero,32357e0 <tcp_input+0x2078>
 323568c:	e0bfe717 	ldw	r2,-100(fp)
 3235690:	10800217 	ldw	r2,8(r2)
 3235694:	10800288 	cmpgei	r2,r2,10
 3235698:	1000511e 	bne	r2,zero,32357e0 <tcp_input+0x2078>
       * This is a kludge, but if we receive and accept
       * random urgent pointers, we'll crash in
       * soreceive.  It's hard to imagine someone
       * actually wanting to send this much urgent data.
       */
      if (ti->ti_urp + so->so_rcv.sb_cc > SB_MAX) 
 323569c:	e0bfed17 	ldw	r2,-76(fp)
 32356a0:	1080098b 	ldhu	r2,38(r2)
 32356a4:	10ffffcc 	andi	r3,r2,65535
 32356a8:	e0bfe517 	ldw	r2,-108(fp)
 32356ac:	10800a17 	ldw	r2,40(r2)
 32356b0:	1885883a 	add	r2,r3,r2
 32356b4:	10900070 	cmpltui	r2,r2,16385
 32356b8:	1000071e 	bne	r2,zero,32356d8 <tcp_input+0x1f70>
      {
         ti->ti_urp = 0;         /* XXX */
 32356bc:	e0bfed17 	ldw	r2,-76(fp)
 32356c0:	1000098d 	sth	zero,38(r2)
         tiflags &= ~TH_URG;     /* XXX */
 32356c4:	e0ffe617 	ldw	r3,-104(fp)
 32356c8:	00bff7c4 	movi	r2,-33
 32356cc:	1884703a 	and	r2,r3,r2
 32356d0:	e0bfe615 	stw	r2,-104(fp)
         goto dodata;         /* XXX */
 32356d4:	00004d06 	br	323580c <tcp_input+0x20a4>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
 32356d8:	e0bfed17 	ldw	r2,-76(fp)
 32356dc:	10c00617 	ldw	r3,24(r2)
 32356e0:	e0bfed17 	ldw	r2,-76(fp)
 32356e4:	1080098b 	ldhu	r2,38(r2)
 32356e8:	10bfffcc 	andi	r2,r2,65535
 32356ec:	1887883a 	add	r3,r3,r2
 32356f0:	e0bfe717 	ldw	r2,-100(fp)
 32356f4:	10801717 	ldw	r2,92(r2)
 32356f8:	1885c83a 	sub	r2,r3,r2
 32356fc:	10800050 	cmplti	r2,r2,1
 3235700:	1000261e 	bne	r2,zero,323579c <tcp_input+0x2034>
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
 3235704:	e0bfed17 	ldw	r2,-76(fp)
 3235708:	10c00617 	ldw	r3,24(r2)
 323570c:	e0bfed17 	ldw	r2,-76(fp)
 3235710:	1080098b 	ldhu	r2,38(r2)
 3235714:	10bfffcc 	andi	r2,r2,65535
 3235718:	1887883a 	add	r3,r3,r2
 323571c:	e0bfe717 	ldw	r2,-100(fp)
 3235720:	10c01715 	stw	r3,92(r2)
         so->so_oobmark = so->so_rcv.sb_cc +
 3235724:	e0bfe517 	ldw	r2,-108(fp)
 3235728:	11000a17 	ldw	r4,40(r2)
 323572c:	e0bfe717 	ldw	r2,-100(fp)
 3235730:	10c01717 	ldw	r3,92(r2)
 3235734:	e0bfe717 	ldw	r2,-100(fp)
 3235738:	10801617 	ldw	r2,88(r2)
 323573c:	1885c83a 	sub	r2,r3,r2
 3235740:	2085883a 	add	r2,r4,r2
 3235744:	10ffffc4 	addi	r3,r2,-1
 3235748:	e0bfe517 	ldw	r2,-108(fp)
 323574c:	10c01a15 	stw	r3,104(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
         if (so->so_oobmark == 0)
 3235750:	e0bfe517 	ldw	r2,-108(fp)
 3235754:	10801a17 	ldw	r2,104(r2)
 3235758:	1004c03a 	cmpne	r2,r2,zero
 323575c:	1000061e 	bne	r2,zero,3235778 <tcp_input+0x2010>
            so->so_state |= SS_RCVATMARK;
 3235760:	e0bfe517 	ldw	r2,-108(fp)
 3235764:	1080088b 	ldhu	r2,34(r2)
 3235768:	10801014 	ori	r2,r2,64
 323576c:	1007883a 	mov	r3,r2
 3235770:	e0bfe517 	ldw	r2,-108(fp)
 3235774:	10c0088d 	sth	r3,34(r2)
         sohasoutofband(so);
 3235778:	e13fe517 	ldw	r4,-108(fp)
 323577c:	32316f00 	call	32316f0 <sohasoutofband>
         tp->t_oobflags &= ~(TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 3235780:	e0bfe717 	ldw	r2,-100(fp)
 3235784:	10c02403 	ldbu	r3,144(r2)
 3235788:	00bfff04 	movi	r2,-4
 323578c:	1884703a 	and	r2,r3,r2
 3235790:	1007883a 	mov	r3,r2
 3235794:	e0bfe717 	ldw	r2,-100(fp)
 3235798:	10c02405 	stb	r3,144(r2)
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 323579c:	e0bfed17 	ldw	r2,-76(fp)
 32357a0:	10c0098b 	ldhu	r3,38(r2)
 32357a4:	e0bfed17 	ldw	r2,-76(fp)
 32357a8:	1080028b 	ldhu	r2,10(r2)
 32357ac:	18ffffcc 	andi	r3,r3,65535
 32357b0:	10bfffcc 	andi	r2,r2,65535
 32357b4:	10c01536 	bltu	r2,r3,323580c <tcp_input+0x20a4>
 32357b8:	e0bfe517 	ldw	r2,-108(fp)
 32357bc:	10800417 	ldw	r2,16(r2)
 32357c0:	1080400c 	andi	r2,r2,256
 32357c4:	1004c03a 	cmpne	r2,r2,zero
 32357c8:	1000101e 	bne	r2,zero,323580c <tcp_input+0x20a4>
#ifdef SO_OOBINLINE
       && (so->so_options & SO_OOBINLINE) == 0
#endif
       )
      {
         tcp_pulloutofband(so, ti, m);
 32357cc:	e13fe517 	ldw	r4,-108(fp)
 32357d0:	e17fed17 	ldw	r5,-76(fp)
 32357d4:	e1bff017 	ldw	r6,-64(fp)
 32357d8:	3235e4c0 	call	3235e4c <tcp_pulloutofband>
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 32357dc:	00000b06 	br	323580c <tcp_input+0x20a4>
      /*
       * If no out of band data is expected,
       * pull receive urgent pointer along
       * with the receive window.
       */
   if (SEQ_GT(tp->rcv_nxt, tp->rcv_up))
 32357e0:	e0bfe717 	ldw	r2,-100(fp)
 32357e4:	10c01617 	ldw	r3,88(r2)
 32357e8:	e0bfe717 	ldw	r2,-100(fp)
 32357ec:	10801717 	ldw	r2,92(r2)
 32357f0:	1885c83a 	sub	r2,r3,r2
 32357f4:	10800050 	cmplti	r2,r2,1
 32357f8:	1000041e 	bne	r2,zero,323580c <tcp_input+0x20a4>
      tp->rcv_up = tp->rcv_nxt;
 32357fc:	e0bfe717 	ldw	r2,-100(fp)
 3235800:	10c01617 	ldw	r3,88(r2)
 3235804:	e0bfe717 	ldw	r2,-100(fp)
 3235808:	10c01715 	stw	r3,92(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 323580c:	e0bfed17 	ldw	r2,-76(fp)
 3235810:	1080028b 	ldhu	r2,10(r2)
 3235814:	10bfffcc 	andi	r2,r2,65535
 3235818:	1004c03a 	cmpne	r2,r2,zero
 323581c:	1000051e 	bne	r2,zero,3235834 <tcp_input+0x20cc>
 3235820:	e0bfe617 	ldw	r2,-104(fp)
 3235824:	1080004c 	andi	r2,r2,1
 3235828:	10803fcc 	andi	r2,r2,255
 323582c:	1005003a 	cmpeq	r2,r2,zero
 3235830:	10005c1e 	bne	r2,zero,32359a4 <tcp_input+0x223c>
 3235834:	e0bfe717 	ldw	r2,-100(fp)
 3235838:	10800217 	ldw	r2,8(r2)
 323583c:	10800288 	cmpgei	r2,r2,10
 3235840:	1000581e 	bne	r2,zero,32359a4 <tcp_input+0x223c>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 3235844:	e0bfed17 	ldw	r2,-76(fp)
 3235848:	10c00617 	ldw	r3,24(r2)
 323584c:	e0bfe717 	ldw	r2,-100(fp)
 3235850:	10801617 	ldw	r2,88(r2)
 3235854:	1880351e 	bne	r3,r2,323592c <tcp_input+0x21c4>
 3235858:	e0bfe717 	ldw	r2,-100(fp)
 323585c:	10c00017 	ldw	r3,0(r2)
 3235860:	e0bfe717 	ldw	r2,-100(fp)
 3235864:	1880311e 	bne	r3,r2,323592c <tcp_input+0x21c4>
 3235868:	e0bfe717 	ldw	r2,-100(fp)
 323586c:	10800217 	ldw	r2,8(r2)
 3235870:	10800118 	cmpnei	r2,r2,4
 3235874:	10002d1e 	bne	r2,zero,323592c <tcp_input+0x21c4>
         else
         {
            tp->t_flags |= TF_ACKNOW;
         }
#else    /* not DO_DELAY_ACKS */
            tp->t_flags |= TF_ACKNOW;
 3235878:	e0bfe717 	ldw	r2,-100(fp)
 323587c:	10800b0b 	ldhu	r2,44(r2)
 3235880:	10800054 	ori	r2,r2,1
 3235884:	1007883a 	mov	r3,r2
 3235888:	e0bfe717 	ldw	r2,-100(fp)
 323588c:	10c00b0d 	sth	r3,44(r2)
#endif   /* DO_DELAY_ACKS */

         tp->rcv_nxt += ti->ti_len;
 3235890:	e0bfe717 	ldw	r2,-100(fp)
 3235894:	10c01617 	ldw	r3,88(r2)
 3235898:	e0bfed17 	ldw	r2,-76(fp)
 323589c:	1080028b 	ldhu	r2,10(r2)
 32358a0:	10bfffcc 	andi	r2,r2,65535
 32358a4:	1887883a 	add	r3,r3,r2
 32358a8:	e0bfe717 	ldw	r2,-100(fp)
 32358ac:	10c01615 	stw	r3,88(r2)
         tiflags = ti->ti_flags & TH_FIN;
 32358b0:	e0bfed17 	ldw	r2,-76(fp)
 32358b4:	10800843 	ldbu	r2,33(r2)
 32358b8:	10803fcc 	andi	r2,r2,255
 32358bc:	1080004c 	andi	r2,r2,1
 32358c0:	e0bfe615 	stw	r2,-104(fp)
         tcpstat.tcps_rcvpack++;
 32358c4:	0080c9b4 	movhi	r2,806
 32358c8:	10b3ca04 	addi	r2,r2,-12504
 32358cc:	10801a17 	ldw	r2,104(r2)
 32358d0:	10c00044 	addi	r3,r2,1
 32358d4:	0080c9b4 	movhi	r2,806
 32358d8:	10b3ca04 	addi	r2,r2,-12504
 32358dc:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 32358e0:	0080c9b4 	movhi	r2,806
 32358e4:	10b3ca04 	addi	r2,r2,-12504
 32358e8:	10c01b17 	ldw	r3,108(r2)
 32358ec:	e0bfed17 	ldw	r2,-76(fp)
 32358f0:	1080028b 	ldhu	r2,10(r2)
 32358f4:	10bfffcc 	andi	r2,r2,65535
 32358f8:	1887883a 	add	r3,r3,r2
 32358fc:	0080c9b4 	movhi	r2,806
 3235900:	10b3ca04 	addi	r2,r2,-12504
 3235904:	10c01b15 	stw	r3,108(r2)
         sbappend(&so->so_rcv, (m));
 3235908:	e0bfe517 	ldw	r2,-108(fp)
 323590c:	11000a04 	addi	r4,r2,40
 3235910:	e17ff017 	ldw	r5,-64(fp)
 3235914:	32320d00 	call	32320d0 <sbappend>
         sorwakeup(so);
 3235918:	e0bfe517 	ldw	r2,-108(fp)
 323591c:	11400a04 	addi	r5,r2,40
 3235920:	e13fe517 	ldw	r4,-108(fp)
 3235924:	3231f0c0 	call	3231f0c <sbwakeup>
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 3235928:	00000b06 	br	3235958 <tcp_input+0x21f0>
#endif /* TCP_SACK */
      }
      else     /* received out of sequence segment */
      {
         /* Drop it in the reassmbly queue */
         tiflags = tcp_reass(tp, ti, m);
 323592c:	e13fe717 	ldw	r4,-100(fp)
 3235930:	e17fed17 	ldw	r5,-76(fp)
 3235934:	e1bff017 	ldw	r6,-64(fp)
 3235938:	32333600 	call	3233360 <tcp_reass>
 323593c:	e0bfe615 	stw	r2,-104(fp)
         tp->t_flags |= TF_ACKNOW;
 3235940:	e0bfe717 	ldw	r2,-100(fp)
 3235944:	10800b0b 	ldhu	r2,44(r2)
 3235948:	10800054 	ori	r2,r2,1
 323594c:	1007883a 	mov	r3,r2
 3235950:	e0bfe717 	ldw	r2,-100(fp)
 3235954:	10c00b0d 	sth	r3,44(r2)
      /*
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
 3235958:	e0bfe517 	ldw	r2,-108(fp)
 323595c:	11000b17 	ldw	r4,44(r2)
 3235960:	e0bfe717 	ldw	r2,-100(fp)
 3235964:	10c01917 	ldw	r3,100(r2)
 3235968:	e0bfe717 	ldw	r2,-100(fp)
 323596c:	10801617 	ldw	r2,88(r2)
 3235970:	1885c83a 	sub	r2,r3,r2
 3235974:	2085c83a 	sub	r2,r4,r2
 3235978:	e0bfea15 	stw	r2,-88(fp)
      if (len > (int)tp->max_rcvd)
 323597c:	e0bfe717 	ldw	r2,-100(fp)
 3235980:	10802217 	ldw	r2,136(r2)
 3235984:	1007883a 	mov	r3,r2
 3235988:	e0bfea17 	ldw	r2,-88(fp)
 323598c:	18800b0e 	bge	r3,r2,32359bc <tcp_input+0x2254>
         tp->max_rcvd = (u_short)len;
 3235990:	e0bfea17 	ldw	r2,-88(fp)
 3235994:	10ffffcc 	andi	r3,r2,65535
 3235998:	e0bfe717 	ldw	r2,-100(fp)
 323599c:	10c02215 	stw	r3,136(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 32359a0:	00000606 	br	32359bc <tcp_input+0x2254>
      }
#endif   /* TCP_ZEROCOPY */
   } 
   else
   {
      m_freem(m);
 32359a4:	e13ff017 	ldw	r4,-64(fp)
 32359a8:	322bc680 	call	322bc68 <m_freem>
      tiflags &= ~TH_FIN;
 32359ac:	e0bfe617 	ldw	r2,-104(fp)
 32359b0:	00ffff84 	movi	r3,-2
 32359b4:	10c4703a 	and	r2,r2,r3
 32359b8:	e0bfe615 	stw	r2,-104(fp)

   /*
    * If FIN is received ACK the FIN and let the user know
    * that the connection is closing.
    */
   if (tiflags & TH_FIN) 
 32359bc:	e0bfe617 	ldw	r2,-104(fp)
 32359c0:	1080004c 	andi	r2,r2,1
 32359c4:	10803fcc 	andi	r2,r2,255
 32359c8:	1005003a 	cmpeq	r2,r2,zero
 32359cc:	1000471e 	bne	r2,zero,3235aec <tcp_input+0x2384>
   {
      if (TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 32359d0:	e0bfe717 	ldw	r2,-100(fp)
 32359d4:	10800217 	ldw	r2,8(r2)
 32359d8:	10800288 	cmpgei	r2,r2,10
 32359dc:	10000d1e 	bne	r2,zero,3235a14 <tcp_input+0x22ac>
      {
         socantrcvmore(so);
 32359e0:	e13fe517 	ldw	r4,-108(fp)
 32359e4:	3231e1c0 	call	3231e1c <socantrcvmore>
         tp->t_flags |= TF_ACKNOW;
 32359e8:	e0bfe717 	ldw	r2,-100(fp)
 32359ec:	10800b0b 	ldhu	r2,44(r2)
 32359f0:	10800054 	ori	r2,r2,1
 32359f4:	1007883a 	mov	r3,r2
 32359f8:	e0bfe717 	ldw	r2,-100(fp)
 32359fc:	10c00b0d 	sth	r3,44(r2)
         tp->rcv_nxt++;
 3235a00:	e0bfe717 	ldw	r2,-100(fp)
 3235a04:	10801617 	ldw	r2,88(r2)
 3235a08:	10c00044 	addi	r3,r2,1
 3235a0c:	e0bfe717 	ldw	r2,-100(fp)
 3235a10:	10c01615 	stw	r3,88(r2)
      }
      switch (tp->t_state) 
 3235a14:	e0bfe717 	ldw	r2,-100(fp)
 3235a18:	10800217 	ldw	r2,8(r2)
 3235a1c:	10bfff44 	addi	r2,r2,-3
 3235a20:	e0bfff15 	stw	r2,-4(fp)
 3235a24:	e0ffff17 	ldw	r3,-4(fp)
 3235a28:	18800228 	cmpgeui	r2,r3,8
 3235a2c:	10002f1e 	bne	r2,zero,3235aec <tcp_input+0x2384>
 3235a30:	e13fff17 	ldw	r4,-4(fp)
 3235a34:	e13fff17 	ldw	r4,-4(fp)
 3235a38:	2105883a 	add	r2,r4,r4
 3235a3c:	1087883a 	add	r3,r2,r2
 3235a40:	0080c8f4 	movhi	r2,803
 3235a44:	10969504 	addi	r2,r2,23124
 3235a48:	1885883a 	add	r2,r3,r2
 3235a4c:	10800017 	ldw	r2,0(r2)
 3235a50:	1000683a 	jmp	r2
 3235a54:	03235a74 	movhi	r12,36201
 3235a58:	03235a74 	movhi	r12,36201
 3235a5c:	03235aec 	andhi	r12,zero,36203
 3235a60:	03235a84 	movi	r12,-29334
 3235a64:	03235aec 	andhi	r12,zero,36203
 3235a68:	03235aec 	andhi	r12,zero,36203
 3235a6c:	03235a94 	movui	r12,36202
 3235a70:	03235ad0 	cmplti	r12,zero,-29333
       * In SYN_RECEIVED and ESTABLISHED STATES
       * enter the CLOSE_WAIT state.
       */
      case TCPS_SYN_RECEIVED:
      case TCPS_ESTABLISHED:
         tp->t_state = TCPS_CLOSE_WAIT;
 3235a74:	e0ffe717 	ldw	r3,-100(fp)
 3235a78:	00800144 	movi	r2,5
 3235a7c:	18800215 	stw	r2,8(r3)
         break;
 3235a80:	00001a06 	br	3235aec <tcp_input+0x2384>
       /*
       * If still in FIN_WAIT_1 STATE FIN has not been acked so
       * enter the CLOSING state.
       */
      case TCPS_FIN_WAIT_1:
         tp->t_state = TCPS_CLOSING;
 3235a84:	e0ffe717 	ldw	r3,-100(fp)
 3235a88:	008001c4 	movi	r2,7
 3235a8c:	18800215 	stw	r2,8(r3)
         break;
 3235a90:	00001606 	br	3235aec <tcp_input+0x2384>
       * In FIN_WAIT_2 state enter the TIME_WAIT state,
       * starting the time-wait timer, turning off the other 
       * standard timers.
       */
      case TCPS_FIN_WAIT_2:
         tp->t_state = TCPS_TIME_WAIT;
 3235a94:	e0ffe717 	ldw	r3,-100(fp)
 3235a98:	00800284 	movi	r2,10
 3235a9c:	18800215 	stw	r2,8(r3)
         tcp_canceltimers(tp);
 3235aa0:	e13fe717 	ldw	r4,-100(fp)
 3235aa4:	32383300 	call	3238330 <tcp_canceltimers>
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 3235aa8:	0080c974 	movhi	r2,805
 3235aac:	1089ae04 	addi	r2,r2,9912
 3235ab0:	10800017 	ldw	r2,0(r2)
 3235ab4:	1085883a 	add	r2,r2,r2
 3235ab8:	1007883a 	mov	r3,r2
 3235abc:	e0bfe717 	ldw	r2,-100(fp)
 3235ac0:	10c00615 	stw	r3,24(r2)
         soisdisconnected(so);
 3235ac4:	e13fe517 	ldw	r4,-108(fp)
 3235ac8:	32319280 	call	3231928 <soisdisconnected>
         break;
 3235acc:	00000706 	br	3235aec <tcp_input+0x2384>

      /*
       * In TIME_WAIT state restart the 2 MSL time_wait timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 3235ad0:	0080c974 	movhi	r2,805
 3235ad4:	1089ae04 	addi	r2,r2,9912
 3235ad8:	10800017 	ldw	r2,0(r2)
 3235adc:	1085883a 	add	r2,r2,r2
 3235ae0:	1007883a 	mov	r3,r2
 3235ae4:	e0bfe717 	ldw	r2,-100(fp)
 3235ae8:	10c00615 	stw	r3,24(r2)
    ostate, tp, &tcp_saveti);
#endif
   /*
    * Return any desired output.
    */
   if (needoutput || (tp->t_flags & TF_ACKNOW))
 3235aec:	e0bfe117 	ldw	r2,-124(fp)
 3235af0:	1004c03a 	cmpne	r2,r2,zero
 3235af4:	1000071e 	bne	r2,zero,3235b14 <tcp_input+0x23ac>
 3235af8:	e0bfe717 	ldw	r2,-100(fp)
 3235afc:	10800b0b 	ldhu	r2,44(r2)
 3235b00:	10bfffcc 	andi	r2,r2,65535
 3235b04:	1080004c 	andi	r2,r2,1
 3235b08:	10803fcc 	andi	r2,r2,255
 3235b0c:	1005003a 	cmpeq	r2,r2,zero
 3235b10:	1000651e 	bne	r2,zero,3235ca8 <tcp_input+0x2540>
      (void) tcp_output(tp);
 3235b14:	e13fe717 	ldw	r4,-100(fp)
 3235b18:	32363480 	call	3236348 <tcp_output>
   return;
 3235b1c:	00006206 	br	3235ca8 <tcp_input+0x2540>
dropafterack:
   /*
    * Generate an ACK dropping incoming segment if it occupies
    * sequence space, where the ACK reflects our state.
    */
   if (tiflags & TH_RST)
 3235b20:	e0bfe617 	ldw	r2,-104(fp)
 3235b24:	1080010c 	andi	r2,r2,4
 3235b28:	1005003a 	cmpeq	r2,r2,zero
 3235b2c:	1000031e 	bne	r2,zero,3235b3c <tcp_input+0x23d4>
      GOTO_DROP;
 3235b30:	0081a904 	movi	r2,1700
 3235b34:	d0a8e915 	stw	r2,-23644(gp)
 3235b38:	00004f06 	br	3235c78 <tcp_input+0x2510>
   m_freem (m);
 3235b3c:	e13ff017 	ldw	r4,-64(fp)
 3235b40:	322bc680 	call	322bc68 <m_freem>
   tp->t_flags |= TF_ACKNOW;
 3235b44:	e0bfe717 	ldw	r2,-100(fp)
 3235b48:	10800b0b 	ldhu	r2,44(r2)
 3235b4c:	10800054 	ori	r2,r2,1
 3235b50:	1007883a 	mov	r3,r2
 3235b54:	e0bfe717 	ldw	r2,-100(fp)
 3235b58:	10c00b0d 	sth	r3,44(r2)
   (void) tcp_output (tp);
 3235b5c:	e13fe717 	ldw	r4,-100(fp)
 3235b60:	32363480 	call	3236348 <tcp_output>
   return;
 3235b64:	00005006 	br	3235ca8 <tcp_input+0x2540>

dropwithreset:
   TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 3235b68:	0080c9b4 	movhi	r2,806
 3235b6c:	10b39c04 	addi	r2,r2,-12688
 3235b70:	10800d17 	ldw	r2,52(r2)
 3235b74:	10c00044 	addi	r3,r2,1
 3235b78:	0080c9b4 	movhi	r2,806
 3235b7c:	10b39c04 	addi	r2,r2,-12688
 3235b80:	10c00d15 	stw	r3,52(r2)
   if (om) 
 3235b84:	e0bfeb17 	ldw	r2,-84(fp)
 3235b88:	1005003a 	cmpeq	r2,r2,zero
 3235b8c:	1000031e 	bne	r2,zero,3235b9c <tcp_input+0x2434>
   {
      (void) m_free(om);
 3235b90:	e13feb17 	ldw	r4,-84(fp)
 3235b94:	322bb340 	call	322bb34 <m_free>
      om = 0;
 3235b98:	e03feb15 	stw	zero,-84(fp)
   }

   /* Don't reset resets */
   if (tiflags & TH_RST)
 3235b9c:	e0bfe617 	ldw	r2,-104(fp)
 3235ba0:	1080010c 	andi	r2,r2,4
 3235ba4:	1005003a 	cmpeq	r2,r2,zero
 3235ba8:	1000031e 	bne	r2,zero,3235bb8 <tcp_input+0x2450>
      GOTO_DROP;
 3235bac:	0081ad04 	movi	r2,1716
 3235bb0:	d0a8e915 	stw	r2,-23644(gp)
 3235bb4:	00003006 	br	3235c78 <tcp_input+0x2510>
    * Generate a RST, dropping incoming segment.
    * Make ACK acceptable to originator of segment.
    * Don't bother to respond if destination was broadcast.
    */
#ifdef IP_V4
   if (in_broadcast(ti->ti_dst.s_addr))
 3235bb8:	e0bfed17 	ldw	r2,-76(fp)
 3235bbc:	11000417 	ldw	r4,16(r2)
 3235bc0:	322cc940 	call	322cc94 <in_broadcast>
 3235bc4:	1005003a 	cmpeq	r2,r2,zero
 3235bc8:	1000031e 	bne	r2,zero,3235bd8 <tcp_input+0x2470>
      GOTO_DROP;
 3235bcc:	0081af44 	movi	r2,1725
 3235bd0:	d0a8e915 	stw	r2,-23644(gp)
 3235bd4:	00002806 	br	3235c78 <tcp_input+0x2510>
      IP6CPY(&(m->pkt->ip6_hdr->ip_src), &ip6_src);
      IP6CPY(&(m->pkt->ip6_hdr->ip_dest), &ip6_dst);
   }
#endif   /* IP_V6 */

   if (tiflags & TH_ACK)
 3235bd8:	e0bfe617 	ldw	r2,-104(fp)
 3235bdc:	1080040c 	andi	r2,r2,16
 3235be0:	1005003a 	cmpeq	r2,r2,zero
 3235be4:	10000b1e 	bne	r2,zero,3235c14 <tcp_input+0x24ac>
      tcp_respond (tp, ti, (tcp_seq)0, ti->ti_ack, TH_RST, m);
 3235be8:	e0bfed17 	ldw	r2,-76(fp)
 3235bec:	11c00717 	ldw	r7,28(r2)
 3235bf0:	00800104 	movi	r2,4
 3235bf4:	d8800015 	stw	r2,0(sp)
 3235bf8:	e0bff017 	ldw	r2,-64(fp)
 3235bfc:	d8800115 	stw	r2,4(sp)
 3235c00:	e13fe717 	ldw	r4,-100(fp)
 3235c04:	e17fed17 	ldw	r5,-76(fp)
 3235c08:	000d883a 	mov	r6,zero
 3235c0c:	32378180 	call	3237818 <tcp_respond>
 3235c10:	00001306 	br	3235c60 <tcp_input+0x24f8>
   else
   {
      if (tiflags & TH_SYN)
 3235c14:	e0bfe617 	ldw	r2,-104(fp)
 3235c18:	1080008c 	andi	r2,r2,2
 3235c1c:	1005003a 	cmpeq	r2,r2,zero
 3235c20:	1000051e 	bne	r2,zero,3235c38 <tcp_input+0x24d0>
         ti->ti_seq++;
 3235c24:	e0bfed17 	ldw	r2,-76(fp)
 3235c28:	10800617 	ldw	r2,24(r2)
 3235c2c:	10c00044 	addi	r3,r2,1
 3235c30:	e0bfed17 	ldw	r2,-76(fp)
 3235c34:	10c00615 	stw	r3,24(r2)
      tcp_respond(tp, ti, ti->ti_seq, (tcp_seq)0, TH_RST|TH_ACK, m);
 3235c38:	e0bfed17 	ldw	r2,-76(fp)
 3235c3c:	11800617 	ldw	r6,24(r2)
 3235c40:	00800504 	movi	r2,20
 3235c44:	d8800015 	stw	r2,0(sp)
 3235c48:	e0bff017 	ldw	r2,-64(fp)
 3235c4c:	d8800115 	stw	r2,4(sp)
 3235c50:	e13fe717 	ldw	r4,-100(fp)
 3235c54:	e17fed17 	ldw	r5,-76(fp)
 3235c58:	000f883a 	mov	r7,zero
 3235c5c:	32378180 	call	3237818 <tcp_respond>
   }
   /* destroy temporarily created socket */
   if (dropsocket)
 3235c60:	e0bfe017 	ldw	r2,-128(fp)
 3235c64:	1005003a 	cmpeq	r2,r2,zero
 3235c68:	10000f1e 	bne	r2,zero,3235ca8 <tcp_input+0x2540>
      (void) soabort(so);
 3235c6c:	e13fe517 	ldw	r4,-108(fp)
 3235c70:	322fafc0 	call	322fafc <soabort>
   return;
 3235c74:	00000c06 	br	3235ca8 <tcp_input+0x2540>

drop:
   if (om)
 3235c78:	e0bfeb17 	ldw	r2,-84(fp)
 3235c7c:	1005003a 	cmpeq	r2,r2,zero
 3235c80:	1000021e 	bne	r2,zero,3235c8c <tcp_input+0x2524>
      (void) m_free(om);
 3235c84:	e13feb17 	ldw	r4,-84(fp)
 3235c88:	322bb340 	call	322bb34 <m_free>
#ifdef DO_TCPTRACE
   if (tp && (tp->t_inpcb->inp_socket->so_options & SO_DEBUG))
      tcp_trace("drop: state %d, tcpcb: %x, saveti: %x",
    ostate, tp, &tcp_saveti);
#endif
   m_freem(m);
 3235c8c:	e13ff017 	ldw	r4,-64(fp)
 3235c90:	322bc680 	call	322bc68 <m_freem>
   /* destroy temporarily created socket */
   if (dropsocket)
 3235c94:	e0bfe017 	ldw	r2,-128(fp)
 3235c98:	1005003a 	cmpeq	r2,r2,zero
 3235c9c:	1000021e 	bne	r2,zero,3235ca8 <tcp_input+0x2540>
      (void) soabort(so);
 3235ca0:	e13fe517 	ldw	r4,-108(fp)
 3235ca4:	322fafc0 	call	322fafc <soabort>
   return;
}
 3235ca8:	e037883a 	mov	sp,fp
 3235cac:	dfc00117 	ldw	ra,4(sp)
 3235cb0:	df000017 	ldw	fp,0(sp)
 3235cb4:	dec00204 	addi	sp,sp,8
 3235cb8:	f800283a 	ret

03235cbc <tcp_dooptions>:

void
tcp_dooptions(struct tcpcb * tp, 
   struct mbuf *  om,
   struct tcpiphdr * ti)
{
 3235cbc:	defff404 	addi	sp,sp,-48
 3235cc0:	dfc00b15 	stw	ra,44(sp)
 3235cc4:	df000a15 	stw	fp,40(sp)
 3235cc8:	df000a04 	addi	fp,sp,40
 3235ccc:	e13ffc15 	stw	r4,-16(fp)
 3235cd0:	e17ffd15 	stw	r5,-12(fp)
 3235cd4:	e1bffe15 	stw	r6,-8(fp)
   u_char * cp;   /* pointer into option buffer */
   int   opt;     /* current option code */
   int   optlen;  /* length of current option */
   int   cnt;     /* byte count left in header */
   struct socket * so = tp->t_inpcb->inp_socket;
 3235cd8:	e0bffc17 	ldw	r2,-16(fp)
 3235cdc:	10800d17 	ldw	r2,52(r2)
 3235ce0:	10800817 	ldw	r2,32(r2)
 3235ce4:	e0bff715 	stw	r2,-36(fp)
#ifdef TCP_TIMESTAMP
   int   gotstamp = FALSE;    /* TRUE if we got a timestamp */
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
 3235ce8:	e0bffd17 	ldw	r2,-12(fp)
 3235cec:	10800317 	ldw	r2,12(r2)
 3235cf0:	e0bffb15 	stw	r2,-20(fp)
   cnt = om->m_len;
 3235cf4:	e0bffd17 	ldw	r2,-12(fp)
 3235cf8:	10800217 	ldw	r2,8(r2)
 3235cfc:	e0bff815 	stw	r2,-32(fp)
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 3235d00:	00004806 	br	3235e24 <tcp_dooptions+0x168>
   {
      opt = cp[0];
 3235d04:	e0bffb17 	ldw	r2,-20(fp)
 3235d08:	10800003 	ldbu	r2,0(r2)
 3235d0c:	10803fcc 	andi	r2,r2,255
 3235d10:	e0bffa15 	stw	r2,-24(fp)
      if (opt == TCPOPT_EOL)
 3235d14:	e0bffa17 	ldw	r2,-24(fp)
 3235d18:	1005003a 	cmpeq	r2,r2,zero
 3235d1c:	1000441e 	bne	r2,zero,3235e30 <tcp_dooptions+0x174>
         break;
      if (opt == TCPOPT_NOP)
 3235d20:	e0bffa17 	ldw	r2,-24(fp)
 3235d24:	10800058 	cmpnei	r2,r2,1
 3235d28:	1000031e 	bne	r2,zero,3235d38 <tcp_dooptions+0x7c>
         optlen = 1;
 3235d2c:	00800044 	movi	r2,1
 3235d30:	e0bff915 	stw	r2,-28(fp)
 3235d34:	00000806 	br	3235d58 <tcp_dooptions+0x9c>
      else 
      {
         optlen = cp[1];
 3235d38:	e0bffb17 	ldw	r2,-20(fp)
 3235d3c:	10800044 	addi	r2,r2,1
 3235d40:	10800003 	ldbu	r2,0(r2)
 3235d44:	10803fcc 	andi	r2,r2,255
 3235d48:	e0bff915 	stw	r2,-28(fp)
         if (optlen <= 0)
 3235d4c:	e0bff917 	ldw	r2,-28(fp)
 3235d50:	10800050 	cmplti	r2,r2,1
 3235d54:	1000361e 	bne	r2,zero,3235e30 <tcp_dooptions+0x174>
            break;
      }

      switch (opt) 
 3235d58:	e0bffa17 	ldw	r2,-24(fp)
 3235d5c:	108000a0 	cmpeqi	r2,r2,2
 3235d60:	1000011e 	bne	r2,zero,3235d68 <tcp_dooptions+0xac>
 3235d64:	00002606 	br	3235e00 <tcp_dooptions+0x144>
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
 3235d68:	e0bff917 	ldw	r2,-28(fp)
 3235d6c:	10800118 	cmpnei	r2,r2,4
 3235d70:	1000231e 	bne	r2,zero,3235e00 <tcp_dooptions+0x144>
            continue;
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
 3235d74:	e0bffe17 	ldw	r2,-8(fp)
 3235d78:	10800843 	ldbu	r2,33(r2)
 3235d7c:	10803fcc 	andi	r2,r2,255
 3235d80:	1080008c 	andi	r2,r2,2
 3235d84:	1005003a 	cmpeq	r2,r2,zero
 3235d88:	10001d1e 	bne	r2,zero,3235e00 <tcp_dooptions+0x144>
            continue;
         mssval = *(u_short *)(cp + 2);
 3235d8c:	e0bffb17 	ldw	r2,-20(fp)
 3235d90:	10800084 	addi	r2,r2,2
 3235d94:	1080000b 	ldhu	r2,0(r2)
 3235d98:	e0bff60d 	sth	r2,-40(fp)
         mssval = ntohs(mssval);
 3235d9c:	e0bff60b 	ldhu	r2,-40(fp)
 3235da0:	1004d23a 	srli	r2,r2,8
 3235da4:	10803fcc 	andi	r2,r2,255
 3235da8:	1009883a 	mov	r4,r2
 3235dac:	e0bff60b 	ldhu	r2,-40(fp)
 3235db0:	1004923a 	slli	r2,r2,8
 3235db4:	1007883a 	mov	r3,r2
 3235db8:	00bfc004 	movi	r2,-256
 3235dbc:	1884703a 	and	r2,r3,r2
 3235dc0:	2084b03a 	or	r2,r4,r2
 3235dc4:	e0bff60d 	sth	r2,-40(fp)
         tp->t_maxseg = (u_short)MIN(mssval, (u_short)tcp_mss(so));
 3235dc8:	e13ff717 	ldw	r4,-36(fp)
 3235dcc:	323622c0 	call	323622c <tcp_mss>
 3235dd0:	10ffffcc 	andi	r3,r2,65535
 3235dd4:	e0bff60b 	ldhu	r2,-40(fp)
 3235dd8:	1880042e 	bgeu	r3,r2,3235dec <tcp_dooptions+0x130>
 3235ddc:	e13ff717 	ldw	r4,-36(fp)
 3235de0:	323622c0 	call	323622c <tcp_mss>
 3235de4:	e0bfff0d 	sth	r2,-4(fp)
 3235de8:	00000206 	br	3235df4 <tcp_dooptions+0x138>
 3235dec:	e0bff60b 	ldhu	r2,-40(fp)
 3235df0:	e0bfff0d 	sth	r2,-4(fp)
 3235df4:	e0bffc17 	ldw	r2,-16(fp)
 3235df8:	e0ffff0b 	ldhu	r3,-4(fp)
 3235dfc:	10c00a0d 	sth	r3,40(r2)
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
   cnt = om->m_len;
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 3235e00:	e0fff817 	ldw	r3,-32(fp)
 3235e04:	e0bff917 	ldw	r2,-28(fp)
 3235e08:	1885c83a 	sub	r2,r3,r2
 3235e0c:	e0bff815 	stw	r2,-32(fp)
 3235e10:	e0bff917 	ldw	r2,-28(fp)
 3235e14:	1007883a 	mov	r3,r2
 3235e18:	e0bffb17 	ldw	r2,-20(fp)
 3235e1c:	10c5883a 	add	r2,r2,r3
 3235e20:	e0bffb15 	stw	r2,-20(fp)
 3235e24:	e0bff817 	ldw	r2,-32(fp)
 3235e28:	10800048 	cmpgei	r2,r2,1
 3235e2c:	103fb51e 	bne	r2,zero,3235d04 <tcp_dooptions+0x48>

      default:
         break;
      }
   }
   (void) m_free(om);
 3235e30:	e13ffd17 	ldw	r4,-12(fp)
 3235e34:	322bb340 	call	322bb34 <m_free>
         tp->t_flags &= ~TF_TIMESTAMP;
   }
#endif /* TCP_TIMESTAMP */

   return;
}
 3235e38:	e037883a 	mov	sp,fp
 3235e3c:	dfc00117 	ldw	ra,4(sp)
 3235e40:	df000017 	ldw	fp,0(sp)
 3235e44:	dec00204 	addi	sp,sp,8
 3235e48:	f800283a 	ret

03235e4c <tcp_pulloutofband>:

void
tcp_pulloutofband(struct socket * so, 
   struct tcpiphdr * ti,
   struct mbuf *  m)
{
 3235e4c:	defff804 	addi	sp,sp,-32
 3235e50:	dfc00715 	stw	ra,28(sp)
 3235e54:	df000615 	stw	fp,24(sp)
 3235e58:	df000604 	addi	fp,sp,24
 3235e5c:	e13ffd15 	stw	r4,-12(fp)
 3235e60:	e17ffe15 	stw	r5,-8(fp)
 3235e64:	e1bfff15 	stw	r6,-4(fp)
   int   cnt   =  ti->ti_urp  -  1;
 3235e68:	e0bffe17 	ldw	r2,-8(fp)
 3235e6c:	1080098b 	ldhu	r2,38(r2)
 3235e70:	10bfffcc 	andi	r2,r2,65535
 3235e74:	10bfffc4 	addi	r2,r2,-1
 3235e78:	e0bffc15 	stw	r2,-16(fp)

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 3235e7c:	00003306 	br	3235f4c <tcp_pulloutofband+0x100>
   {
      if (m->m_len > (unsigned)cnt) 
 3235e80:	e0bfff17 	ldw	r2,-4(fp)
 3235e84:	10c00217 	ldw	r3,8(r2)
 3235e88:	e0bffc17 	ldw	r2,-16(fp)
 3235e8c:	10c0242e 	bgeu	r2,r3,3235f20 <tcp_pulloutofband+0xd4>
      {
         char *   cp =  mtod(m,  char *) +  cnt;
 3235e90:	e0bfff17 	ldw	r2,-4(fp)
 3235e94:	10c00317 	ldw	r3,12(r2)
 3235e98:	e0bffc17 	ldw	r2,-16(fp)
 3235e9c:	1885883a 	add	r2,r3,r2
 3235ea0:	e0bffb15 	stw	r2,-20(fp)
         struct tcpcb * tp =  sototcpcb(so);
 3235ea4:	e0bffd17 	ldw	r2,-12(fp)
 3235ea8:	10800117 	ldw	r2,4(r2)
 3235eac:	10800917 	ldw	r2,36(r2)
 3235eb0:	e0bffa15 	stw	r2,-24(fp)

         tp->t_iobc = *cp;
 3235eb4:	e0bffb17 	ldw	r2,-20(fp)
 3235eb8:	10c00003 	ldbu	r3,0(r2)
 3235ebc:	e0bffa17 	ldw	r2,-24(fp)
 3235ec0:	10c02445 	stb	r3,145(r2)
         tp->t_oobflags |= TCPOOB_HAVEDATA;
 3235ec4:	e0bffa17 	ldw	r2,-24(fp)
 3235ec8:	10802403 	ldbu	r2,144(r2)
 3235ecc:	10800054 	ori	r2,r2,1
 3235ed0:	1007883a 	mov	r3,r2
 3235ed4:	e0bffa17 	ldw	r2,-24(fp)
 3235ed8:	10c02405 	stb	r3,144(r2)
         MEMCPY(cp, cp+1, (unsigned)(m->m_len - cnt - 1));
 3235edc:	e0bffb17 	ldw	r2,-20(fp)
 3235ee0:	11400044 	addi	r5,r2,1
 3235ee4:	e0bfff17 	ldw	r2,-4(fp)
 3235ee8:	10c00217 	ldw	r3,8(r2)
 3235eec:	e0bffc17 	ldw	r2,-16(fp)
 3235ef0:	1885c83a 	sub	r2,r3,r2
 3235ef4:	10ffffc4 	addi	r3,r2,-1
 3235ef8:	e0bffb17 	ldw	r2,-20(fp)
 3235efc:	1009883a 	mov	r4,r2
 3235f00:	180d883a 	mov	r6,r3
 3235f04:	32067cc0 	call	32067cc <memcpy>
         m->m_len--;
 3235f08:	e0bfff17 	ldw	r2,-4(fp)
 3235f0c:	10800217 	ldw	r2,8(r2)
 3235f10:	10ffffc4 	addi	r3,r2,-1
 3235f14:	e0bfff17 	ldw	r2,-4(fp)
 3235f18:	10c00215 	stw	r3,8(r2)
         return;
 3235f1c:	00001106 	br	3235f64 <tcp_pulloutofband+0x118>
      }
      cnt -= m->m_len;
 3235f20:	e0fffc17 	ldw	r3,-16(fp)
 3235f24:	e0bfff17 	ldw	r2,-4(fp)
 3235f28:	10800217 	ldw	r2,8(r2)
 3235f2c:	1885c83a 	sub	r2,r3,r2
 3235f30:	e0bffc15 	stw	r2,-16(fp)
      m = m->m_next;
 3235f34:	e0bfff17 	ldw	r2,-4(fp)
 3235f38:	10800617 	ldw	r2,24(r2)
 3235f3c:	e0bfff15 	stw	r2,-4(fp)
      if (m == 0)
 3235f40:	e0bfff17 	ldw	r2,-4(fp)
 3235f44:	1005003a 	cmpeq	r2,r2,zero
 3235f48:	1000031e 	bne	r2,zero,3235f58 <tcp_pulloutofband+0x10c>
   struct mbuf *  m)
{
   int   cnt   =  ti->ti_urp  -  1;

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 3235f4c:	e0bffc17 	ldw	r2,-16(fp)
 3235f50:	1004403a 	cmpge	r2,r2,zero
 3235f54:	103fca1e 	bne	r2,zero,3235e80 <tcp_pulloutofband+0x34>
      cnt -= m->m_len;
      m = m->m_next;
      if (m == 0)
         break;
   }
   panic("tcp_pulloutofband");
 3235f58:	0100c974 	movhi	r4,805
 3235f5c:	213d6d04 	addi	r4,r4,-2636
 3235f60:	3225df00 	call	3225df0 <panic>
}
 3235f64:	e037883a 	mov	sp,fp
 3235f68:	dfc00117 	ldw	ra,4(sp)
 3235f6c:	df000017 	ldw	fp,0(sp)
 3235f70:	dec00204 	addi	sp,sp,8
 3235f74:	f800283a 	ret

03235f78 <tcp_xmit_timer>:
 * RETURNS: 
 */

void
tcp_xmit_timer(struct tcpcb * tp)
{
 3235f78:	defffb04 	addi	sp,sp,-20
 3235f7c:	dfc00415 	stw	ra,16(sp)
 3235f80:	df000315 	stw	fp,12(sp)
 3235f84:	df000304 	addi	fp,sp,12
 3235f88:	e13fff15 	stw	r4,-4(fp)
   int delta;
   int rtt;

#ifdef NPDEBUG
   if(tp->t_rttick == 0){ dtrap(); return; }
 3235f8c:	e0bfff17 	ldw	r2,-4(fp)
 3235f90:	10801e17 	ldw	r2,120(r2)
 3235f94:	1004c03a 	cmpne	r2,r2,zero
 3235f98:	1000021e 	bne	r2,zero,3235fa4 <tcp_xmit_timer+0x2c>
 3235f9c:	322ab8c0 	call	322ab8c <dtrap>
 3235fa0:	00008b06 	br	32361d0 <tcp_xmit_timer+0x258>
#endif

   tcpstat.tcps_rttupdated++;
 3235fa4:	0080c9b4 	movhi	r2,806
 3235fa8:	10b3ca04 	addi	r2,r2,-12504
 3235fac:	10800717 	ldw	r2,28(r2)
 3235fb0:	10c00044 	addi	r3,r2,1
 3235fb4:	0080c9b4 	movhi	r2,806
 3235fb8:	10b3ca04 	addi	r2,r2,-12504
 3235fbc:	10c00715 	stw	r3,28(r2)

   /* get  this rtt. Convert from cticks to TCP slow ticks */
   rtt = (int)((cticks - tp->t_rttick) / (TPS/2));
 3235fc0:	0080c974 	movhi	r2,805
 3235fc4:	10925604 	addi	r2,r2,18776
 3235fc8:	10c00017 	ldw	r3,0(r2)
 3235fcc:	e0bfff17 	ldw	r2,-4(fp)
 3235fd0:	10801e17 	ldw	r2,120(r2)
 3235fd4:	1889c83a 	sub	r4,r3,r2
 3235fd8:	01407d04 	movi	r5,500
 3235fdc:	32044bc0 	call	32044bc <__udivsi3>
 3235fe0:	e0bffd15 	stw	r2,-12(fp)
   if(tp->t_srtt != 0)
 3235fe4:	e0bfff17 	ldw	r2,-4(fp)
 3235fe8:	10802017 	ldw	r2,128(r2)
 3235fec:	1005003a 	cmpeq	r2,r2,zero
 3235ff0:	10004a1e 	bne	r2,zero,323611c <tcp_xmit_timer+0x1a4>
   {
      if(rtt == 0)      /* fast path for small round trip */
 3235ff4:	e0bffd17 	ldw	r2,-12(fp)
 3235ff8:	1004c03a 	cmpne	r2,r2,zero
 3235ffc:	1000131e 	bne	r2,zero,323604c <tcp_xmit_timer+0xd4>
      {
         /* if either the rtt or varience is over 1, reduce it. */
         if(tp->t_srtt > 1)
 3236000:	e0bfff17 	ldw	r2,-4(fp)
 3236004:	10802017 	ldw	r2,128(r2)
 3236008:	10800090 	cmplti	r2,r2,2
 323600c:	1000051e 	bne	r2,zero,3236024 <tcp_xmit_timer+0xac>
            tp->t_srtt--;
 3236010:	e0bfff17 	ldw	r2,-4(fp)
 3236014:	10802017 	ldw	r2,128(r2)
 3236018:	10ffffc4 	addi	r3,r2,-1
 323601c:	e0bfff17 	ldw	r2,-4(fp)
 3236020:	10c02015 	stw	r3,128(r2)
         if(tp->t_rttvar > 1)
 3236024:	e0bfff17 	ldw	r2,-4(fp)
 3236028:	10802117 	ldw	r2,132(r2)
 323602c:	10800090 	cmplti	r2,r2,2
 3236030:	1000481e 	bne	r2,zero,3236154 <tcp_xmit_timer+0x1dc>
            tp->t_rttvar--;
 3236034:	e0bfff17 	ldw	r2,-4(fp)
 3236038:	10802117 	ldw	r2,132(r2)
 323603c:	10ffffc4 	addi	r3,r2,-1
 3236040:	e0bfff17 	ldw	r2,-4(fp)
 3236044:	10c02115 	stw	r3,132(r2)
 3236048:	00004206 	br	3236154 <tcp_xmit_timer+0x1dc>
       * The following magic is equivalent
       * to the smoothing algorithm in rfc793
       * with an alpha of .875
       * (srtt = rtt/8 + srtt*7/8 in fixed point).
       */
      delta = ((rtt - 1) << 2) - (int)(tp->t_srtt >> 3);
 323604c:	e0bffd17 	ldw	r2,-12(fp)
 3236050:	10bfffc4 	addi	r2,r2,-1
 3236054:	1085883a 	add	r2,r2,r2
 3236058:	1085883a 	add	r2,r2,r2
 323605c:	1007883a 	mov	r3,r2
 3236060:	e0bfff17 	ldw	r2,-4(fp)
 3236064:	10802017 	ldw	r2,128(r2)
 3236068:	1005d0fa 	srai	r2,r2,3
 323606c:	1885c83a 	sub	r2,r3,r2
 3236070:	e0bffe15 	stw	r2,-8(fp)
      if ((tp->t_srtt += delta) <= 0)
 3236074:	e0bfff17 	ldw	r2,-4(fp)
 3236078:	10c02017 	ldw	r3,128(r2)
 323607c:	e0bffe17 	ldw	r2,-8(fp)
 3236080:	1887883a 	add	r3,r3,r2
 3236084:	e0bfff17 	ldw	r2,-4(fp)
 3236088:	10c02015 	stw	r3,128(r2)
 323608c:	e0bfff17 	ldw	r2,-4(fp)
 3236090:	10802017 	ldw	r2,128(r2)
 3236094:	10800048 	cmpgei	r2,r2,1
 3236098:	1000031e 	bne	r2,zero,32360a8 <tcp_xmit_timer+0x130>
         tp->t_srtt = 1;
 323609c:	e0ffff17 	ldw	r3,-4(fp)
 32360a0:	00800044 	movi	r2,1
 32360a4:	18802015 	stw	r2,128(r3)
       * (scaled by 4).  The following is equivalent
       * to rfc793 smoothing with an alpha of .75
       * (rttvar = rttvar*3/4 + |delta| / 4).
       * This replaces rfc793's wired-in beta.
       */
      if (delta < 0)
 32360a8:	e0bffe17 	ldw	r2,-8(fp)
 32360ac:	1004403a 	cmpge	r2,r2,zero
 32360b0:	1000031e 	bne	r2,zero,32360c0 <tcp_xmit_timer+0x148>
         delta = -delta;
 32360b4:	e0bffe17 	ldw	r2,-8(fp)
 32360b8:	0085c83a 	sub	r2,zero,r2
 32360bc:	e0bffe15 	stw	r2,-8(fp)
      delta -= (short)(tp->t_rttvar >> 1);
 32360c0:	e0bfff17 	ldw	r2,-4(fp)
 32360c4:	10802117 	ldw	r2,132(r2)
 32360c8:	1005d07a 	srai	r2,r2,1
 32360cc:	10ffffcc 	andi	r3,r2,65535
 32360d0:	18e0001c 	xori	r3,r3,32768
 32360d4:	18e00004 	addi	r3,r3,-32768
 32360d8:	e0bffe17 	ldw	r2,-8(fp)
 32360dc:	10c5c83a 	sub	r2,r2,r3
 32360e0:	e0bffe15 	stw	r2,-8(fp)
      if ((tp->t_rttvar += delta) <= 0)
 32360e4:	e0bfff17 	ldw	r2,-4(fp)
 32360e8:	10c02117 	ldw	r3,132(r2)
 32360ec:	e0bffe17 	ldw	r2,-8(fp)
 32360f0:	1887883a 	add	r3,r3,r2
 32360f4:	e0bfff17 	ldw	r2,-4(fp)
 32360f8:	10c02115 	stw	r3,132(r2)
 32360fc:	e0bfff17 	ldw	r2,-4(fp)
 3236100:	10802117 	ldw	r2,132(r2)
 3236104:	10800048 	cmpgei	r2,r2,1
 3236108:	1000121e 	bne	r2,zero,3236154 <tcp_xmit_timer+0x1dc>
         tp->t_rttvar = 1;
 323610c:	e0ffff17 	ldw	r3,-4(fp)
 3236110:	00800044 	movi	r2,1
 3236114:	18802115 	stw	r2,132(r3)
 3236118:	00000e06 	br	3236154 <tcp_xmit_timer+0x1dc>
       * No rtt measurement yet - use the
       * unsmoothed rtt.  Set the variance
       * to half the rtt (so our first
       * retransmit happens at 2*rtt)
       */
      if(rtt < 1)
 323611c:	e0bffd17 	ldw	r2,-12(fp)
 3236120:	10800048 	cmpgei	r2,r2,1
 3236124:	1000021e 	bne	r2,zero,3236130 <tcp_xmit_timer+0x1b8>
         rtt = 1;
 3236128:	00800044 	movi	r2,1
 323612c:	e0bffd15 	stw	r2,-12(fp)
      tp->t_srtt = rtt << 3;
 3236130:	e0bffd17 	ldw	r2,-12(fp)
 3236134:	100690fa 	slli	r3,r2,3
 3236138:	e0bfff17 	ldw	r2,-4(fp)
 323613c:	10c02015 	stw	r3,128(r2)
      tp->t_rttvar = rtt << 1;
 3236140:	e0bffd17 	ldw	r2,-12(fp)
 3236144:	1085883a 	add	r2,r2,r2
 3236148:	1007883a 	mov	r3,r2
 323614c:	e0bfff17 	ldw	r2,-4(fp)
 3236150:	10c02115 	stw	r3,132(r2)
   }
   tp->t_rttick = 0;       /* clear RT timer */
 3236154:	e0bfff17 	ldw	r2,-4(fp)
 3236158:	10001e15 	stw	zero,120(r2)
   tp->t_rxtshift = 0;
 323615c:	e0bfff17 	ldw	r2,-4(fp)
 3236160:	10000715 	stw	zero,28(r2)
   TCPT_RANGESET(tp->t_rxtcur, 
 3236164:	e0bfff17 	ldw	r2,-4(fp)
 3236168:	10802017 	ldw	r2,128(r2)
 323616c:	1007d0ba 	srai	r3,r2,2
 3236170:	e0bfff17 	ldw	r2,-4(fp)
 3236174:	10802117 	ldw	r2,132(r2)
 3236178:	1885883a 	add	r2,r3,r2
 323617c:	1005d07a 	srai	r2,r2,1
 3236180:	10ffffcc 	andi	r3,r2,65535
 3236184:	18e0001c 	xori	r3,r3,32768
 3236188:	18e00004 	addi	r3,r3,-32768
 323618c:	e0bfff17 	ldw	r2,-4(fp)
 3236190:	10c00815 	stw	r3,32(r2)
 3236194:	e0bfff17 	ldw	r2,-4(fp)
 3236198:	10800817 	ldw	r2,32(r2)
 323619c:	10800088 	cmpgei	r2,r2,2
 32361a0:	1000041e 	bne	r2,zero,32361b4 <tcp_xmit_timer+0x23c>
 32361a4:	e0ffff17 	ldw	r3,-4(fp)
 32361a8:	00800084 	movi	r2,2
 32361ac:	18800815 	stw	r2,32(r3)
 32361b0:	00000706 	br	32361d0 <tcp_xmit_timer+0x258>
 32361b4:	e0bfff17 	ldw	r2,-4(fp)
 32361b8:	10800817 	ldw	r2,32(r2)
 32361bc:	10802050 	cmplti	r2,r2,129
 32361c0:	1000031e 	bne	r2,zero,32361d0 <tcp_xmit_timer+0x258>
 32361c4:	e0ffff17 	ldw	r3,-4(fp)
 32361c8:	00802004 	movi	r2,128
 32361cc:	18800815 	stw	r2,32(r3)
    ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1,
    TCPTV_MIN, TCPTV_REXMTMAX);
}
 32361d0:	e037883a 	mov	sp,fp
 32361d4:	dfc00117 	ldw	ra,4(sp)
 32361d8:	df000017 	ldw	fp,0(sp)
 32361dc:	dec00204 	addi	sp,sp,8
 32361e0:	f800283a 	ret

032361e4 <ip4_tcpmss>:


#ifdef IP_V4
int
ip4_tcpmss(struct socket * so)
{
 32361e4:	defffd04 	addi	sp,sp,-12
 32361e8:	df000215 	stw	fp,8(sp)
 32361ec:	df000204 	addi	fp,sp,8
 32361f0:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = so->so_pcb->ifp;
 32361f4:	e0bfff17 	ldw	r2,-4(fp)
 32361f8:	10800117 	ldw	r2,4(r2)
 32361fc:	10800a17 	ldw	r2,40(r2)
 3236200:	e0bffe15 	stw	r2,-8(fp)
   return(ifp->n_mtu - (40 + ifp->n_lnh));
 3236204:	e0bffe17 	ldw	r2,-8(fp)
 3236208:	10c00917 	ldw	r3,36(r2)
 323620c:	e0bffe17 	ldw	r2,-8(fp)
 3236210:	10800817 	ldw	r2,32(r2)
 3236214:	1885c83a 	sub	r2,r3,r2
 3236218:	10bff604 	addi	r2,r2,-40
}
 323621c:	e037883a 	mov	sp,fp
 3236220:	df000017 	ldw	fp,0(sp)
 3236224:	dec00104 	addi	sp,sp,4
 3236228:	f800283a 	ret

0323622c <tcp_mss>:
 */


int
tcp_mss(struct socket * so)
{
 323622c:	defff904 	addi	sp,sp,-28
 3236230:	dfc00615 	stw	ra,24(sp)
 3236234:	df000515 	stw	fp,20(sp)
 3236238:	df000504 	addi	fp,sp,20
 323623c:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 3236240:	e0bffe17 	ldw	r2,-8(fp)
 3236244:	1005003a 	cmpeq	r2,r2,zero
 3236248:	1000091e 	bne	r2,zero,3236270 <tcp_mss+0x44>
 323624c:	e0bffe17 	ldw	r2,-8(fp)
 3236250:	10800117 	ldw	r2,4(r2)
 3236254:	1005003a 	cmpeq	r2,r2,zero
 3236258:	1000051e 	bne	r2,zero,3236270 <tcp_mss+0x44>
 323625c:	e0bffe17 	ldw	r2,-8(fp)
 3236260:	10800117 	ldw	r2,4(r2)
 3236264:	10800a17 	ldw	r2,40(r2)
 3236268:	1004c03a 	cmpne	r2,r2,zero
 323626c:	1000071e 	bne	r2,zero,323628c <tcp_mss+0x60>
       (so->so_pcb == NULL) ||
       (so->so_pcb->ifp == NULL))
   {
      if (so->so_domain == AF_INET)  /* IPv4 */
 3236270:	e0bffe17 	ldw	r2,-8(fp)
 3236274:	10800517 	ldw	r2,20(r2)
 3236278:	10800098 	cmpnei	r2,r2,2
 323627c:	1000031e 	bne	r2,zero,323628c <tcp_mss+0x60>
         return TCP_MSS;            /* user defined */
 3236280:	00816d04 	movi	r2,1460
 3236284:	e0bfff15 	stw	r2,-4(fp)
 3236288:	00002906 	br	3236330 <tcp_mss+0x104>
#endif   /* IP_V6 */


#ifdef IP_V4   /* Begin messy domain defines */
#ifndef IP_V6  /* V4 only version */
   mss = ip4_tcpmss(so);
 323628c:	e13ffe17 	ldw	r4,-8(fp)
 3236290:	32361e40 	call	32361e4 <ip4_tcpmss>
 3236294:	e0bffd15 	stw	r2,-12(fp)
#endif         /* end of dual mode */
#else          /* no IP_v4, assume V6 only */
      mss = ip6_tcpmss(so, ifp);
#endif         /* end messy domain defines */

   if (mss > TCP_MSS)    /* check upper limit from compile */
 3236298:	e0bffd17 	ldw	r2,-12(fp)
 323629c:	10816d50 	cmplti	r2,r2,1461
 32362a0:	1000021e 	bne	r2,zero,32362ac <tcp_mss+0x80>
      mss = TCP_MSS;
 32362a4:	00816d04 	movi	r2,1460
 32362a8:	e0bffd15 	stw	r2,-12(fp)

   /* check upper limit which may be set by setsockopt() */
   inp = (struct inpcb *)so->so_pcb;         /* Map socket to IP cb */
 32362ac:	e0bffe17 	ldw	r2,-8(fp)
 32362b0:	10800117 	ldw	r2,4(r2)
 32362b4:	e0bffc15 	stw	r2,-16(fp)
   tp = (struct tcpcb *)inp->inp_ppcb;       /* Map IP to TCP cb */
 32362b8:	e0bffc17 	ldw	r2,-16(fp)
 32362bc:	10800917 	ldw	r2,36(r2)
 32362c0:	e0bffb15 	stw	r2,-20(fp)
   
   /* has user set max seg? */
   if (tp->t_flags & TF_MAXSEG)
 32362c4:	e0bffb17 	ldw	r2,-20(fp)
 32362c8:	10800b0b 	ldhu	r2,44(r2)
 32362cc:	10bfffcc 	andi	r2,r2,65535
 32362d0:	1081000c 	andi	r2,r2,1024
 32362d4:	1005003a 	cmpeq	r2,r2,zero
 32362d8:	1000051e 	bne	r2,zero,32362f0 <tcp_mss+0xc4>
      return tp->t_maxseg;    /* yup */
 32362dc:	e0bffb17 	ldw	r2,-20(fp)
 32362e0:	10800a0b 	ldhu	r2,40(r2)
 32362e4:	10bfffcc 	andi	r2,r2,65535
 32362e8:	e0bfff15 	stw	r2,-4(fp)
 32362ec:	00001006 	br	3236330 <tcp_mss+0x104>
      
   if (tp->t_maxseg && (mss > tp->t_maxseg))  /* check tcp's mss */
 32362f0:	e0bffb17 	ldw	r2,-20(fp)
 32362f4:	10800a0b 	ldhu	r2,40(r2)
 32362f8:	10bfffcc 	andi	r2,r2,65535
 32362fc:	1005003a 	cmpeq	r2,r2,zero
 3236300:	1000091e 	bne	r2,zero,3236328 <tcp_mss+0xfc>
 3236304:	e0bffb17 	ldw	r2,-20(fp)
 3236308:	10800a0b 	ldhu	r2,40(r2)
 323630c:	10ffffcc 	andi	r3,r2,65535
 3236310:	e0bffd17 	ldw	r2,-12(fp)
 3236314:	1880040e 	bge	r3,r2,3236328 <tcp_mss+0xfc>
   {
      mss = tp->t_maxseg;        /* limit new MSS to set MSS */
 3236318:	e0bffb17 	ldw	r2,-20(fp)
 323631c:	10800a0b 	ldhu	r2,40(r2)
 3236320:	10bfffcc 	andi	r2,r2,65535
 3236324:	e0bffd15 	stw	r2,-12(fp)
   }

   return mss;
 3236328:	e0bffd17 	ldw	r2,-12(fp)
 323632c:	e0bfff15 	stw	r2,-4(fp)
 3236330:	e0bfff17 	ldw	r2,-4(fp)
}
 3236334:	e037883a 	mov	sp,fp
 3236338:	dfc00117 	ldw	ra,4(sp)
 323633c:	df000017 	ldw	fp,0(sp)
 3236340:	dec00204 	addi	sp,sp,8
 3236344:	f800283a 	ret

03236348 <tcp_output>:
 * RETURNS: 0 if OK, else a sockets error code.
 */

int
tcp_output(struct tcpcb * tp)
{
 3236348:	deffe004 	addi	sp,sp,-128
 323634c:	dfc01f15 	stw	ra,124(sp)
 3236350:	df001e15 	stw	fp,120(sp)
 3236354:	df001e04 	addi	fp,sp,120
 3236358:	e13ff715 	stw	r4,-36(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 323635c:	e0bff717 	ldw	r2,-36(fp)
 3236360:	10800d17 	ldw	r2,52(r2)
 3236364:	10800817 	ldw	r2,32(r2)
 3236368:	e0bff515 	stw	r2,-44(fp)
   int   len;
   long  win;
   int   off,  flags,   error;
   struct mbuf *  m;
   struct tcpiphdr * ti;
   unsigned optlen = 0;
 323636c:	e03fed15 	stw	zero,-76(fp)
    * Determine length of data that should be transmitted,
    * and flags that will be used.
    * If there is some data or critical controls (SYN, RST)
    * to send, then transmit; otherwise, investigate further.
    */
   idle = (tp->snd_max == tp->snd_una);
 3236370:	e0bff717 	ldw	r2,-36(fp)
 3236374:	10c01a17 	ldw	r3,104(r2)
 3236378:	e0bff717 	ldw	r2,-36(fp)
 323637c:	10800e17 	ldw	r2,56(r2)
 3236380:	1885003a 	cmpeq	r2,r3,r2
 3236384:	e0bfec15 	stw	r2,-80(fp)

again:
   sendalot = 0;
 3236388:	e03feb15 	stw	zero,-84(fp)
   off = (int)(tp->snd_nxt - tp->snd_una);
 323638c:	e0bff717 	ldw	r2,-36(fp)
 3236390:	10c00f17 	ldw	r3,60(r2)
 3236394:	e0bff717 	ldw	r2,-36(fp)
 3236398:	10800e17 	ldw	r2,56(r2)
 323639c:	1885c83a 	sub	r2,r3,r2
 32363a0:	e0bff215 	stw	r2,-56(fp)
   win = (long)tp->snd_wnd;   /* set basic send window */
 32363a4:	e0bff717 	ldw	r2,-36(fp)
 32363a8:	10801417 	ldw	r2,80(r2)
 32363ac:	e0bff315 	stw	r2,-52(fp)
   if (win > (long)tp->snd_cwnd) /* see if we need congestion control */
 32363b0:	e0bff717 	ldw	r2,-36(fp)
 32363b4:	10801b17 	ldw	r2,108(r2)
 32363b8:	1007883a 	mov	r3,r2
 32363bc:	e0bff317 	ldw	r2,-52(fp)
 32363c0:	1880060e 	bge	r3,r2,32363dc <tcp_output+0x94>
   {
      win = (int)(tp->snd_cwnd & ~(ALIGN_TYPE-1)); /* keep data aligned */
 32363c4:	e0bff717 	ldw	r2,-36(fp)
 32363c8:	10801b17 	ldw	r2,108(r2)
 32363cc:	1007883a 	mov	r3,r2
 32363d0:	00bfff04 	movi	r2,-4
 32363d4:	1884703a 	and	r2,r3,r2
 32363d8:	e0bff315 	stw	r2,-52(fp)
    * If in persist timeout with window of 0, send 1 byte.
    * Otherwise, if window is small but nonzero
    * and timer expired, we will send what we can
    * and go to transmit state.
    */
   if (tp->t_force) 
 32363dc:	e0bff717 	ldw	r2,-36(fp)
 32363e0:	10800a83 	ldbu	r2,42(r2)
 32363e4:	10803fcc 	andi	r2,r2,255
 32363e8:	1080201c 	xori	r2,r2,128
 32363ec:	10bfe004 	addi	r2,r2,-128
 32363f0:	1005003a 	cmpeq	r2,r2,zero
 32363f4:	10000a1e 	bne	r2,zero,3236420 <tcp_output+0xd8>
   {
      if (win == 0)
 32363f8:	e0bff317 	ldw	r2,-52(fp)
 32363fc:	1004c03a 	cmpne	r2,r2,zero
 3236400:	1000031e 	bne	r2,zero,3236410 <tcp_output+0xc8>
         win = 1;
 3236404:	00800044 	movi	r2,1
 3236408:	e0bff315 	stw	r2,-52(fp)
 323640c:	00000406 	br	3236420 <tcp_output+0xd8>
      else 
      {
         tp->t_timer[TCPT_PERSIST] = 0;
 3236410:	e0bff717 	ldw	r2,-36(fp)
 3236414:	10000415 	stw	zero,16(r2)
         tp->t_rxtshift = 0;
 3236418:	e0bff717 	ldw	r2,-36(fp)
 323641c:	10000715 	stw	zero,28(r2)
   }
   else
#endif /* TCP_SACK */
   {
      /* set length of packets which are not sack resends */
      len = (int)MIN(so->so_snd.sb_cc, (unsigned)win) - off;
 3236420:	e0bff517 	ldw	r2,-44(fp)
 3236424:	10801217 	ldw	r2,72(r2)
 3236428:	e0fff317 	ldw	r3,-52(fp)
 323642c:	e0fffb15 	stw	r3,-20(fp)
 3236430:	e0bffa15 	stw	r2,-24(fp)
 3236434:	e0bffb17 	ldw	r2,-20(fp)
 3236438:	e0fffa17 	ldw	r3,-24(fp)
 323643c:	10c0022e 	bgeu	r2,r3,3236448 <tcp_output+0x100>
 3236440:	e0bffb17 	ldw	r2,-20(fp)
 3236444:	e0bffa15 	stw	r2,-24(fp)
 3236448:	e0fffa17 	ldw	r3,-24(fp)
 323644c:	e0bff217 	ldw	r2,-56(fp)
 3236450:	1885c83a 	sub	r2,r3,r2
 3236454:	e0bff415 	stw	r2,-48(fp)
   }

   flags = tcp_outflags[tp->t_state];
 3236458:	e0bff717 	ldw	r2,-36(fp)
 323645c:	10c00217 	ldw	r3,8(r2)
 3236460:	0080c974 	movhi	r2,805
 3236464:	10887304 	addi	r2,r2,8652
 3236468:	10c5883a 	add	r2,r2,r3
 323646c:	10800003 	ldbu	r2,0(r2)
 3236470:	10803fcc 	andi	r2,r2,255
 3236474:	e0bff115 	stw	r2,-60(fp)
   }
#else
   /* If other options not defined this build then don't bother to call bld_options() except 
    * on SYN packets
    */
   if(flags & TH_SYN)
 3236478:	e0bff117 	ldw	r2,-60(fp)
 323647c:	1080008c 	andi	r2,r2,2
 3236480:	1005003a 	cmpeq	r2,r2,zero
 3236484:	1000081e 	bne	r2,zero,32364a8 <tcp_output+0x160>
   {
      optlen = bld_options(tp, &tcp_optionbuf[optlen], flags, so);
 3236488:	e0ffed17 	ldw	r3,-76(fp)
 323648c:	d0a8ea04 	addi	r2,gp,-23640
 3236490:	188b883a 	add	r5,r3,r2
 3236494:	e13ff717 	ldw	r4,-36(fp)
 3236498:	e1bff117 	ldw	r6,-60(fp)
 323649c:	e1fff517 	ldw	r7,-44(fp)
 32364a0:	32375c00 	call	32375c0 <bld_options>
 32364a4:	e0bfed15 	stw	r2,-76(fp)
   }
#endif

   if (len < 0)
 32364a8:	e0bff417 	ldw	r2,-48(fp)
 32364ac:	1004403a 	cmpge	r2,r2,zero
 32364b0:	10000a1e 	bne	r2,zero,32364dc <tcp_output+0x194>
       * cancel pending retransmit and pull snd_nxt
       * back to (closed) window.  We will enter persist
       * state below.  If the window didn't close completely,
       * just wait for an ACK.
       */
      len = 0;
 32364b4:	e03ff415 	stw	zero,-48(fp)
      if (win == 0) 
 32364b8:	e0bff317 	ldw	r2,-52(fp)
 32364bc:	1004c03a 	cmpne	r2,r2,zero
 32364c0:	1000061e 	bne	r2,zero,32364dc <tcp_output+0x194>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 32364c4:	e0bff717 	ldw	r2,-36(fp)
 32364c8:	10000315 	stw	zero,12(r2)
         tp->snd_nxt = tp->snd_una;
 32364cc:	e0bff717 	ldw	r2,-36(fp)
 32364d0:	10c00e17 	ldw	r3,56(r2)
 32364d4:	e0bff717 	ldw	r2,-36(fp)
 32364d8:	10c00f15 	stw	r3,60(r2)
      }
   }

   if (len > (int)tp->t_maxseg)
 32364dc:	e0bff717 	ldw	r2,-36(fp)
 32364e0:	10800a0b 	ldhu	r2,40(r2)
 32364e4:	10ffffcc 	andi	r3,r2,65535
 32364e8:	e0bff417 	ldw	r2,-48(fp)
 32364ec:	1880060e 	bge	r3,r2,3236508 <tcp_output+0x1c0>
   {
      len = tp->t_maxseg;
 32364f0:	e0bff717 	ldw	r2,-36(fp)
 32364f4:	10800a0b 	ldhu	r2,40(r2)
 32364f8:	10bfffcc 	andi	r2,r2,65535
 32364fc:	e0bff415 	stw	r2,-48(fp)
      sendalot = 1;
 3236500:	00800044 	movi	r2,1
 3236504:	e0bfeb15 	stw	r2,-84(fp)
   /* We don't need a pmtu test for IPv6. V6 code limits t_maxseg to
    * the Path MTU, so the test above the v4 ifdef above covers us.
    */
#endif /* IP_V4 */

   if (SEQ_LT(tp->snd_nxt + len, tp->snd_una + so->so_snd.sb_cc))
 3236508:	e0bff717 	ldw	r2,-36(fp)
 323650c:	10c00f17 	ldw	r3,60(r2)
 3236510:	e0bff417 	ldw	r2,-48(fp)
 3236514:	1889883a 	add	r4,r3,r2
 3236518:	e0bff717 	ldw	r2,-36(fp)
 323651c:	10c00e17 	ldw	r3,56(r2)
 3236520:	e0bff517 	ldw	r2,-44(fp)
 3236524:	10801217 	ldw	r2,72(r2)
 3236528:	1885883a 	add	r2,r3,r2
 323652c:	2085c83a 	sub	r2,r4,r2
 3236530:	1004403a 	cmpge	r2,r2,zero
 3236534:	1000041e 	bne	r2,zero,3236548 <tcp_output+0x200>
      flags &= ~TH_FIN;
 3236538:	e0bff117 	ldw	r2,-60(fp)
 323653c:	00ffff84 	movi	r3,-2
 3236540:	10c4703a 	and	r2,r2,r3
 3236544:	e0bff115 	stw	r2,-60(fp)
   win = (long)(sbspace(&so->so_rcv));
 3236548:	e0bff517 	ldw	r2,-44(fp)
 323654c:	10800b17 	ldw	r2,44(r2)
 3236550:	1007883a 	mov	r3,r2
 3236554:	e0bff517 	ldw	r2,-44(fp)
 3236558:	10800a17 	ldw	r2,40(r2)
 323655c:	1885c83a 	sub	r2,r3,r2
 3236560:	1004803a 	cmplt	r2,r2,zero
 3236564:	1000071e 	bne	r2,zero,3236584 <tcp_output+0x23c>
 3236568:	e0bff517 	ldw	r2,-44(fp)
 323656c:	10c00b17 	ldw	r3,44(r2)
 3236570:	e0bff517 	ldw	r2,-44(fp)
 3236574:	10800a17 	ldw	r2,40(r2)
 3236578:	1885c83a 	sub	r2,r3,r2
 323657c:	e0bff915 	stw	r2,-28(fp)
 3236580:	00000106 	br	3236588 <tcp_output+0x240>
 3236584:	e03ff915 	stw	zero,-28(fp)
 3236588:	e0fff917 	ldw	r3,-28(fp)
 323658c:	e0fff315 	stw	r3,-52(fp)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 3236590:	e0bff117 	ldw	r2,-60(fp)
 3236594:	1080004c 	andi	r2,r2,1
 3236598:	10803fcc 	andi	r2,r2,255
 323659c:	1005003a 	cmpeq	r2,r2,zero
 32365a0:	10000f1e 	bne	r2,zero,32365e0 <tcp_output+0x298>
 32365a4:	e0bff517 	ldw	r2,-44(fp)
 32365a8:	10801217 	ldw	r2,72(r2)
 32365ac:	1004c03a 	cmpne	r2,r2,zero
 32365b0:	10000b1e 	bne	r2,zero,32365e0 <tcp_output+0x298>
 32365b4:	e0bff717 	ldw	r2,-36(fp)
 32365b8:	10800b0b 	ldhu	r2,44(r2)
 32365bc:	10bfffcc 	andi	r2,r2,65535
 32365c0:	1080040c 	andi	r2,r2,16
 32365c4:	1005003a 	cmpeq	r2,r2,zero
 32365c8:	1000721e 	bne	r2,zero,3236794 <tcp_output+0x44c>
 32365cc:	e0bff717 	ldw	r2,-36(fp)
 32365d0:	10c00f17 	ldw	r3,60(r2)
 32365d4:	e0bff717 	ldw	r2,-36(fp)
 32365d8:	10800e17 	ldw	r2,56(r2)
 32365dc:	18806d26 	beq	r3,r2,3236794 <tcp_output+0x44c>
      goto send;
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
 32365e0:	e0bff717 	ldw	r2,-36(fp)
 32365e4:	10800b0b 	ldhu	r2,44(r2)
 32365e8:	10bfffcc 	andi	r2,r2,65535
 32365ec:	1080004c 	andi	r2,r2,1
 32365f0:	10803fcc 	andi	r2,r2,255
 32365f4:	1004c03a 	cmpne	r2,r2,zero
 32365f8:	1000661e 	bne	r2,zero,3236794 <tcp_output+0x44c>
      goto send;
   if (flags & (TH_SYN|TH_RST))
 32365fc:	e0bff117 	ldw	r2,-60(fp)
 3236600:	1080018c 	andi	r2,r2,6
 3236604:	1004c03a 	cmpne	r2,r2,zero
 3236608:	1000621e 	bne	r2,zero,3236794 <tcp_output+0x44c>
      goto send;
   if (SEQ_GT(tp->snd_up, tp->snd_una))
 323660c:	e0bff717 	ldw	r2,-36(fp)
 3236610:	10c01017 	ldw	r3,64(r2)
 3236614:	e0bff717 	ldw	r2,-36(fp)
 3236618:	10800e17 	ldw	r2,56(r2)
 323661c:	1885c83a 	sub	r2,r3,r2
 3236620:	10800048 	cmpgei	r2,r2,1
 3236624:	10005b1e 	bne	r2,zero,3236794 <tcp_output+0x44c>
    * If peer's buffer is tiny, then send
    * when window is at least half open.
    * If retransmitting (possibly after persist timer forced us
    * to send into a small window), then must resend.
    */
   if (len)
 3236628:	e0bff417 	ldw	r2,-48(fp)
 323662c:	1005003a 	cmpeq	r2,r2,zero
 3236630:	1000281e 	bne	r2,zero,32366d4 <tcp_output+0x38c>
   {
      if (len == (int)tp->t_maxseg)
 3236634:	e0bff717 	ldw	r2,-36(fp)
 3236638:	10800a0b 	ldhu	r2,40(r2)
 323663c:	10ffffcc 	andi	r3,r2,65535
 3236640:	e0bff417 	ldw	r2,-48(fp)
 3236644:	18805326 	beq	r3,r2,3236794 <tcp_output+0x44c>
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 3236648:	e0bfec17 	ldw	r2,-80(fp)
 323664c:	1004c03a 	cmpne	r2,r2,zero
 3236650:	1000061e 	bne	r2,zero,323666c <tcp_output+0x324>
 3236654:	e0bff717 	ldw	r2,-36(fp)
 3236658:	10800b0b 	ldhu	r2,44(r2)
 323665c:	10bfffcc 	andi	r2,r2,65535
 3236660:	1080010c 	andi	r2,r2,4
 3236664:	1005003a 	cmpeq	r2,r2,zero
 3236668:	1000061e 	bne	r2,zero,3236684 <tcp_output+0x33c>
 323666c:	e0fff417 	ldw	r3,-48(fp)
 3236670:	e0bff217 	ldw	r2,-56(fp)
 3236674:	1887883a 	add	r3,r3,r2
 3236678:	e0bff517 	ldw	r2,-44(fp)
 323667c:	10801217 	ldw	r2,72(r2)
 3236680:	1880440e 	bge	r3,r2,3236794 <tcp_output+0x44c>
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
      }
      if (tp->t_force)
 3236684:	e0bff717 	ldw	r2,-36(fp)
 3236688:	10800a83 	ldbu	r2,42(r2)
 323668c:	10803fcc 	andi	r2,r2,255
 3236690:	1080201c 	xori	r2,r2,128
 3236694:	10bfe004 	addi	r2,r2,-128
 3236698:	1004c03a 	cmpne	r2,r2,zero
 323669c:	10003d1e 	bne	r2,zero,3236794 <tcp_output+0x44c>
         goto send;
      if (len >= (int)(tp->max_sndwnd / 2))
 32366a0:	e0bff717 	ldw	r2,-36(fp)
 32366a4:	10802317 	ldw	r2,140(r2)
 32366a8:	1004d07a 	srli	r2,r2,1
 32366ac:	1007883a 	mov	r3,r2
 32366b0:	e0bff417 	ldw	r2,-48(fp)
 32366b4:	10c0370e 	bge	r2,r3,3236794 <tcp_output+0x44c>
         goto send;
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
 32366b8:	e0bff717 	ldw	r2,-36(fp)
 32366bc:	10c00f17 	ldw	r3,60(r2)
 32366c0:	e0bff717 	ldw	r2,-36(fp)
 32366c4:	10801a17 	ldw	r2,104(r2)
 32366c8:	1885c83a 	sub	r2,r3,r2
 32366cc:	1004803a 	cmplt	r2,r2,zero
 32366d0:	1000301e 	bne	r2,zero,3236794 <tcp_output+0x44c>
    * known to peer (as advertised window less
    * next expected input).  If the difference is at least two
    * max size segments or at least 35% of the maximum possible
    * window, then want to send a window update to peer.
    */
   if (win > 0)
 32366d4:	e0bff317 	ldw	r2,-52(fp)
 32366d8:	10800050 	cmplti	r2,r2,1
 32366dc:	10001b1e 	bne	r2,zero,323674c <tcp_output+0x404>
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);
 32366e0:	e0bff717 	ldw	r2,-36(fp)
 32366e4:	10c01917 	ldw	r3,100(r2)
 32366e8:	e0bff717 	ldw	r2,-36(fp)
 32366ec:	10801617 	ldw	r2,88(r2)
 32366f0:	1885c83a 	sub	r2,r3,r2
 32366f4:	1007883a 	mov	r3,r2
 32366f8:	e0bff317 	ldw	r2,-52(fp)
 32366fc:	10c5c83a 	sub	r2,r2,r3
 3236700:	e0bfe715 	stw	r2,-100(fp)

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
 3236704:	e0bff517 	ldw	r2,-44(fp)
 3236708:	10800a17 	ldw	r2,40(r2)
 323670c:	1004c03a 	cmpne	r2,r2,zero
 3236710:	1000071e 	bne	r2,zero,3236730 <tcp_output+0x3e8>
 3236714:	e0bff717 	ldw	r2,-36(fp)
 3236718:	10800a0b 	ldhu	r2,40(r2)
 323671c:	10bfffcc 	andi	r2,r2,65535
 3236720:	1085883a 	add	r2,r2,r2
 3236724:	1007883a 	mov	r3,r2
 3236728:	e0bfe717 	ldw	r2,-100(fp)
 323672c:	10c0190e 	bge	r2,r3,3236794 <tcp_output+0x44c>
         goto send;
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
 3236730:	e0bfe717 	ldw	r2,-100(fp)
 3236734:	11001924 	muli	r4,r2,100
 3236738:	e0bff517 	ldw	r2,-44(fp)
 323673c:	11400b17 	ldw	r5,44(r2)
 3236740:	32044bc0 	call	32044bc <__udivsi3>
 3236744:	108008e8 	cmpgeui	r2,r2,35
 3236748:	1000121e 	bne	r2,zero,3236794 <tcp_output+0x44c>
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 323674c:	e0bff517 	ldw	r2,-44(fp)
 3236750:	10801217 	ldw	r2,72(r2)
 3236754:	1005003a 	cmpeq	r2,r2,zero
 3236758:	10000c1e 	bne	r2,zero,323678c <tcp_output+0x444>
 323675c:	e0bff717 	ldw	r2,-36(fp)
 3236760:	10800317 	ldw	r2,12(r2)
 3236764:	1004c03a 	cmpne	r2,r2,zero
 3236768:	1000081e 	bne	r2,zero,323678c <tcp_output+0x444>
 323676c:	e0bff717 	ldw	r2,-36(fp)
 3236770:	10800417 	ldw	r2,16(r2)
 3236774:	1004c03a 	cmpne	r2,r2,zero
 3236778:	1000041e 	bne	r2,zero,323678c <tcp_output+0x444>
       tp->t_timer[TCPT_PERSIST] == 0) 
   {
      tp->t_rxtshift = 0;
 323677c:	e0bff717 	ldw	r2,-36(fp)
 3236780:	10000715 	stw	zero,28(r2)
      tcp_setpersist(tp);
 3236784:	e13ff717 	ldw	r4,-36(fp)
 3236788:	32374c40 	call	32374c4 <tcp_setpersist>
   }

   /*
    * No reason to send a segment, just return.
    */
   return (0);
 323678c:	e03ff815 	stw	zero,-32(fp)
 3236790:	00034606 	br	32374ac <tcp_output+0x1164>

send:
   ENTER_CRIT_SECTION(tp);
 3236794:	322ad8c0 	call	322ad8c <irq_Mask>

   /* Limit send length to the current buffer so as to
    * avoid doing the "mbuf shuffle" in m_copy().
    */
   bufoff = off;
 3236798:	e0bff217 	ldw	r2,-56(fp)
 323679c:	e0bfe815 	stw	r2,-96(fp)
   sendm = so->so_snd.sb_mb;
 32367a0:	e0bff517 	ldw	r2,-44(fp)
 32367a4:	10801817 	ldw	r2,96(r2)
 32367a8:	e0bfea15 	stw	r2,-88(fp)
   if (len)
 32367ac:	e0bff417 	ldw	r2,-48(fp)
 32367b0:	1005003a 	cmpeq	r2,r2,zero
 32367b4:	10006b1e 	bne	r2,zero,3236964 <tcp_output+0x61c>
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 32367b8:	00000b06 	br	32367e8 <tcp_output+0x4a0>
      {
         bufoff -= sendm->m_len;
 32367bc:	e0ffe817 	ldw	r3,-96(fp)
 32367c0:	e0bfea17 	ldw	r2,-88(fp)
 32367c4:	10800217 	ldw	r2,8(r2)
 32367c8:	1885c83a 	sub	r2,r3,r2
 32367cc:	e0bfe815 	stw	r2,-96(fp)
         if (bufoff < 0)   /* if off is in this buffer, break */
 32367d0:	e0bfe817 	ldw	r2,-96(fp)
 32367d4:	1004803a 	cmplt	r2,r2,zero
 32367d8:	1000061e 	bne	r2,zero,32367f4 <tcp_output+0x4ac>
            break;
         sendm = sendm->m_next;
 32367dc:	e0bfea17 	ldw	r2,-88(fp)
 32367e0:	10800617 	ldw	r2,24(r2)
 32367e4:	e0bfea15 	stw	r2,-88(fp)
   bufoff = off;
   sendm = so->so_snd.sb_mb;
   if (len)
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 32367e8:	e0bfea17 	ldw	r2,-88(fp)
 32367ec:	1004c03a 	cmpne	r2,r2,zero
 32367f0:	103ff21e 	bne	r2,zero,32367bc <tcp_output+0x474>
         bufoff -= sendm->m_len;
         if (bufoff < 0)   /* if off is in this buffer, break */
            break;
         sendm = sendm->m_next;
      }
      if (!sendm) { dtrap();  /* shouldn't happen */ }
 32367f4:	e0bfea17 	ldw	r2,-88(fp)
 32367f8:	1004c03a 	cmpne	r2,r2,zero
 32367fc:	1000011e 	bne	r2,zero,3236804 <tcp_output+0x4bc>
 3236800:	322ab8c0 	call	322ab8c <dtrap>
      bufoff += sendm->m_len; /* index to next data to send in msend */
 3236804:	e0bfea17 	ldw	r2,-88(fp)
 3236808:	10c00217 	ldw	r3,8(r2)
 323680c:	e0bfe817 	ldw	r2,-96(fp)
 3236810:	1885883a 	add	r2,r3,r2
 3236814:	e0bfe815 	stw	r2,-96(fp)

      /* if socket has multiple unsent mbufs, set flag for send to loop */
      if ((sendm->m_next) && (len > (int)sendm->m_len))
 3236818:	e0bfea17 	ldw	r2,-88(fp)
 323681c:	10800617 	ldw	r2,24(r2)
 3236820:	1005003a 	cmpeq	r2,r2,zero
 3236824:	10000b1e 	bne	r2,zero,3236854 <tcp_output+0x50c>
 3236828:	e0bfea17 	ldw	r2,-88(fp)
 323682c:	10800217 	ldw	r2,8(r2)
 3236830:	1007883a 	mov	r3,r2
 3236834:	e0bff417 	ldw	r2,-48(fp)
 3236838:	1880060e 	bge	r3,r2,3236854 <tcp_output+0x50c>
      {
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 323683c:	e0fff117 	ldw	r3,-60(fp)
 3236840:	00bfff84 	movi	r2,-2
 3236844:	1884703a 	and	r2,r3,r2
 3236848:	e0bff115 	stw	r2,-60(fp)
         sendalot = 1;     /* set to send more segments */
 323684c:	00800044 	movi	r2,1
 3236850:	e0bfeb15 	stw	r2,-84(fp)
      }
      if((flags & TH_FIN) && (so->so_snd.sb_cc > (unsigned)len))
 3236854:	e0bff117 	ldw	r2,-60(fp)
 3236858:	1080004c 	andi	r2,r2,1
 323685c:	10803fcc 	andi	r2,r2,255
 3236860:	1005003a 	cmpeq	r2,r2,zero
 3236864:	1000081e 	bne	r2,zero,3236888 <tcp_output+0x540>
 3236868:	e0bff517 	ldw	r2,-44(fp)
 323686c:	10c01217 	ldw	r3,72(r2)
 3236870:	e0bff417 	ldw	r2,-48(fp)
 3236874:	10c0042e 	bgeu	r2,r3,3236888 <tcp_output+0x540>
      {
         /* This can happen on slow links (PPP) which retry the last 
          * segment - the one with the FIN bit attached to data.
          */
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 3236878:	e0bff117 	ldw	r2,-60(fp)
 323687c:	00ffff84 	movi	r3,-2
 3236880:	10c4703a 	and	r2,r2,r3
 3236884:	e0bff115 	stw	r2,-60(fp)
      }

      /* only send the rest of msend */
      len = min(len, (int)sendm->m_len);
 3236888:	e0bfea17 	ldw	r2,-88(fp)
 323688c:	10800217 	ldw	r2,8(r2)
 3236890:	e0fff417 	ldw	r3,-48(fp)
 3236894:	e0fffd15 	stw	r3,-12(fp)
 3236898:	e0bffc15 	stw	r2,-16(fp)
 323689c:	e0bffd17 	ldw	r2,-12(fp)
 32368a0:	e0fffc17 	ldw	r3,-16(fp)
 32368a4:	10c0020e 	bge	r2,r3,32368b0 <tcp_output+0x568>
 32368a8:	e0bffd17 	ldw	r2,-12(fp)
 32368ac:	e0bffc15 	stw	r2,-16(fp)
 32368b0:	e0fffc17 	ldw	r3,-16(fp)
 32368b4:	e0fff415 	stw	r3,-48(fp)
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 32368b8:	e0bfe817 	ldw	r2,-96(fp)
 32368bc:	1004c03a 	cmpne	r2,r2,zero
 32368c0:	1000091e 	bne	r2,zero,32368e8 <tcp_output+0x5a0>
 32368c4:	e0bfea17 	ldw	r2,-88(fp)
 32368c8:	10800317 	ldw	r2,12(r2)
 32368cc:	1007883a 	mov	r3,r2
 32368d0:	e0bfea17 	ldw	r2,-88(fp)
 32368d4:	10800417 	ldw	r2,16(r2)
 32368d8:	1885c83a 	sub	r2,r3,r2
 32368dc:	108000cc 	andi	r2,r2,3
 32368e0:	1005003a 	cmpeq	r2,r2,zero
 32368e4:	10001f1e 	bne	r2,zero,3236964 <tcp_output+0x61c>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
      {
         len = min(len, (int)(sendm->m_len - bufoff));   /* limit len again */
 32368e8:	e0bfea17 	ldw	r2,-88(fp)
 32368ec:	10c00217 	ldw	r3,8(r2)
 32368f0:	e0bfe817 	ldw	r2,-96(fp)
 32368f4:	1885c83a 	sub	r2,r3,r2
 32368f8:	e0fff417 	ldw	r3,-48(fp)
 32368fc:	e0ffff15 	stw	r3,-4(fp)
 3236900:	e0bffe15 	stw	r2,-8(fp)
 3236904:	e0bfff17 	ldw	r2,-4(fp)
 3236908:	e0fffe17 	ldw	r3,-8(fp)
 323690c:	10c0020e 	bge	r2,r3,3236918 <tcp_output+0x5d0>
 3236910:	e0bfff17 	ldw	r2,-4(fp)
 3236914:	e0bffe15 	stw	r2,-8(fp)
 3236918:	e0fffe17 	ldw	r3,-8(fp)
 323691c:	e0fff415 	stw	r3,-48(fp)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 3236920:	0080c974 	movhi	r2,805
 3236924:	1089aa04 	addi	r2,r2,9896
 3236928:	10800017 	ldw	r2,0(r2)
 323692c:	10bff204 	addi	r2,r2,-56
 3236930:	1007883a 	mov	r3,r2
 3236934:	e0bff417 	ldw	r2,-48(fp)
 3236938:	18800a0e 	bge	r3,r2,3236964 <tcp_output+0x61c>
 323693c:	0080c9b4 	movhi	r2,806
 3236940:	10b30104 	addi	r2,r2,-13308
 3236944:	10800217 	ldw	r2,8(r2)
 3236948:	10800088 	cmpgei	r2,r2,2
 323694c:	1000051e 	bne	r2,zero,3236964 <tcp_output+0x61c>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
         {
            len = lilbufsiz - HDRSLEN;
 3236950:	0080c974 	movhi	r2,805
 3236954:	1089aa04 	addi	r2,r2,9896
 3236958:	10800017 	ldw	r2,0(r2)
 323695c:	10bff204 	addi	r2,r2,-56
 3236960:	e0bff415 	stw	r2,-48(fp)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 3236964:	e0bff417 	ldw	r2,-48(fp)
 3236968:	1005003a 	cmpeq	r2,r2,zero
 323696c:	10003b1e 	bne	r2,zero,3236a5c <tcp_output+0x714>
 3236970:	e0bfe817 	ldw	r2,-96(fp)
 3236974:	1004c03a 	cmpne	r2,r2,zero
 3236978:	1000381e 	bne	r2,zero,3236a5c <tcp_output+0x714>
 323697c:	e0bfea17 	ldw	r2,-88(fp)
 3236980:	10800117 	ldw	r2,4(r2)
 3236984:	10800917 	ldw	r2,36(r2)
 3236988:	10800058 	cmpnei	r2,r2,1
 323698c:	1000331e 	bne	r2,zero,3236a5c <tcp_output+0x714>
 3236990:	e0bfea17 	ldw	r2,-88(fp)
 3236994:	10800317 	ldw	r2,12(r2)
 3236998:	1007883a 	mov	r3,r2
 323699c:	e0bfea17 	ldw	r2,-88(fp)
 32369a0:	10800417 	ldw	r2,16(r2)
 32369a4:	1885c83a 	sub	r2,r3,r2
 32369a8:	108000cc 	andi	r2,r2,3
 32369ac:	1004c03a 	cmpne	r2,r2,zero
 32369b0:	10002a1e 	bne	r2,zero,3236a5c <tcp_output+0x714>
 32369b4:	e0bfed17 	ldw	r2,-76(fp)
 32369b8:	1004c03a 	cmpne	r2,r2,zero
 32369bc:	1000271e 	bne	r2,zero,3236a5c <tcp_output+0x714>
       (sendm->pkt->inuse == 1) &&
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
       (optlen == 0))
   {
      /* get an empty mbuf to "clone" the data */
      m = m_getnbuf(MT_TXDATA, 0);
 32369c0:	01000084 	movi	r4,2
 32369c4:	000b883a 	mov	r5,zero
 32369c8:	322b98c0 	call	322b98c <m_getnbuf>
 32369cc:	e0bfef15 	stw	r2,-68(fp)
      if (!m)
 32369d0:	e0bfef17 	ldw	r2,-68(fp)
 32369d4:	1004c03a 	cmpne	r2,r2,zero
 32369d8:	1000041e 	bne	r2,zero,32369ec <tcp_output+0x6a4>
      {
         EXIT_CRIT_SECTION(tp);
 32369dc:	322ade80 	call	322ade8 <irq_Unmask>
         return (ENOBUFS);
 32369e0:	00801a44 	movi	r2,105
 32369e4:	e0bff815 	stw	r2,-32(fp)
 32369e8:	0002b006 	br	32374ac <tcp_output+0x1164>
      }
      m->pkt = sendm->pkt; /* copy packet location in new mbuf */
 32369ec:	e0bfea17 	ldw	r2,-88(fp)
 32369f0:	10c00117 	ldw	r3,4(r2)
 32369f4:	e0bfef17 	ldw	r2,-68(fp)
 32369f8:	10c00115 	stw	r3,4(r2)
      m->pkt->inuse++;     /* bump packet's use count */
 32369fc:	e0bfef17 	ldw	r2,-68(fp)
 3236a00:	10c00117 	ldw	r3,4(r2)
 3236a04:	18800917 	ldw	r2,36(r3)
 3236a08:	10800044 	addi	r2,r2,1
 3236a0c:	18800915 	stw	r2,36(r3)
      m->m_base = sendm->m_base; /* clone mbuf members */
 3236a10:	e0bfea17 	ldw	r2,-88(fp)
 3236a14:	10c00417 	ldw	r3,16(r2)
 3236a18:	e0bfef17 	ldw	r2,-68(fp)
 3236a1c:	10c00415 	stw	r3,16(r2)
      m->m_memsz = sendm->m_memsz;
 3236a20:	e0bfea17 	ldw	r2,-88(fp)
 3236a24:	10c00517 	ldw	r3,20(r2)
 3236a28:	e0bfef17 	ldw	r2,-68(fp)
 3236a2c:	10c00515 	stw	r3,20(r2)
      m->m_len = len + TCPIPHDRSZ;  /* adjust clone for header */
 3236a30:	e0bff417 	ldw	r2,-48(fp)
 3236a34:	10800a04 	addi	r2,r2,40
 3236a38:	1007883a 	mov	r3,r2
 3236a3c:	e0bfef17 	ldw	r2,-68(fp)
 3236a40:	10c00215 	stw	r3,8(r2)
      m->m_data = sendm->m_data - TCPIPHDRSZ;
 3236a44:	e0bfea17 	ldw	r2,-88(fp)
 3236a48:	10800317 	ldw	r2,12(r2)
 3236a4c:	10fff604 	addi	r3,r2,-40
 3236a50:	e0bfef17 	ldw	r2,-68(fp)
 3236a54:	10c00315 	stw	r3,12(r2)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 3236a58:	00002e06 	br	3236b14 <tcp_output+0x7cc>
   {
      /* Grab a header mbuf, attaching a copy of data to be 
       * transmitted, and initialize the header from 
       * the template for sends on this connection.
       */
      m = m_getwithdata (MT_HEADER, IFNETHDR_SIZE + TCPIPHDRSZ);
 3236a5c:	0080c974 	movhi	r2,805
 3236a60:	10922f04 	addi	r2,r2,18620
 3236a64:	10800017 	ldw	r2,0(r2)
 3236a68:	11400a04 	addi	r5,r2,40
 3236a6c:	010000c4 	movi	r4,3
 3236a70:	322b98c0 	call	322b98c <m_getnbuf>
 3236a74:	e0bfef15 	stw	r2,-68(fp)
      if (m ==(struct mbuf *)NULL)
 3236a78:	e0bfef17 	ldw	r2,-68(fp)
 3236a7c:	1004c03a 	cmpne	r2,r2,zero
 3236a80:	1000041e 	bne	r2,zero,3236a94 <tcp_output+0x74c>
      {
         EXIT_CRIT_SECTION(tp);
 3236a84:	322ade80 	call	322ade8 <irq_Unmask>
         return ENOBUFS;
 3236a88:	00c01a44 	movi	r3,105
 3236a8c:	e0fff815 	stw	r3,-32(fp)
 3236a90:	00028606 	br	32374ac <tcp_output+0x1164>
      }

      m->m_len = TCPIPHDRSZ;
 3236a94:	e0ffef17 	ldw	r3,-68(fp)
 3236a98:	00800a04 	movi	r2,40
 3236a9c:	18800215 	stw	r2,8(r3)
      m->m_data += IFNETHDR_SIZE;/* Move this to sizeof tcpip hdr leave*/
 3236aa0:	e0bfef17 	ldw	r2,-68(fp)
 3236aa4:	10c00317 	ldw	r3,12(r2)
 3236aa8:	0080c974 	movhi	r2,805
 3236aac:	10922f04 	addi	r2,r2,18620
 3236ab0:	10800017 	ldw	r2,0(r2)
 3236ab4:	1887883a 	add	r3,r3,r2
 3236ab8:	e0bfef17 	ldw	r2,-68(fp)
 3236abc:	10c00315 	stw	r3,12(r2)
      /* 14 bytes for ethernet header      */

      if (len) /* attach any data to send */
 3236ac0:	e0bff417 	ldw	r2,-48(fp)
 3236ac4:	1005003a 	cmpeq	r2,r2,zero
 3236ac8:	1000121e 	bne	r2,zero,3236b14 <tcp_output+0x7cc>
      {
         m->m_next = m_copy(so->so_snd.sb_mb, off, (int) len);
 3236acc:	e0bff517 	ldw	r2,-44(fp)
 3236ad0:	11001817 	ldw	r4,96(r2)
 3236ad4:	e17ff217 	ldw	r5,-56(fp)
 3236ad8:	e1bff417 	ldw	r6,-48(fp)
 3236adc:	322bcac0 	call	322bcac <m_copy>
 3236ae0:	1007883a 	mov	r3,r2
 3236ae4:	e0bfef17 	ldw	r2,-68(fp)
 3236ae8:	10c00615 	stw	r3,24(r2)
         if (m->m_next == 0)
 3236aec:	e0bfef17 	ldw	r2,-68(fp)
 3236af0:	10800617 	ldw	r2,24(r2)
 3236af4:	1004c03a 	cmpne	r2,r2,zero
 3236af8:	1000061e 	bne	r2,zero,3236b14 <tcp_output+0x7cc>
         {
            m_freem(m);
 3236afc:	e13fef17 	ldw	r4,-68(fp)
 3236b00:	322bc680 	call	322bc68 <m_freem>
            EXIT_CRIT_SECTION(tp);
 3236b04:	322ade80 	call	322ade8 <irq_Unmask>
            return ENOBUFS;
 3236b08:	00801a44 	movi	r2,105
 3236b0c:	e0bff815 	stw	r2,-32(fp)
 3236b10:	00026606 	br	32374ac <tcp_output+0x1164>
         }
      }
   }
   EXIT_CRIT_SECTION(tp);
 3236b14:	322ade80 	call	322ade8 <irq_Unmask>

   if (len) 
 3236b18:	e0bff417 	ldw	r2,-48(fp)
 3236b1c:	1005003a 	cmpeq	r2,r2,zero
 3236b20:	1000391e 	bne	r2,zero,3236c08 <tcp_output+0x8c0>
   {
      if (tp->t_force && len == 1)
 3236b24:	e0bff717 	ldw	r2,-36(fp)
 3236b28:	10800a83 	ldbu	r2,42(r2)
 3236b2c:	10803fcc 	andi	r2,r2,255
 3236b30:	1080201c 	xori	r2,r2,128
 3236b34:	10bfe004 	addi	r2,r2,-128
 3236b38:	1005003a 	cmpeq	r2,r2,zero
 3236b3c:	10000b1e 	bne	r2,zero,3236b6c <tcp_output+0x824>
 3236b40:	e0bff417 	ldw	r2,-48(fp)
 3236b44:	10800058 	cmpnei	r2,r2,1
 3236b48:	1000081e 	bne	r2,zero,3236b6c <tcp_output+0x824>
         tcpstat.tcps_sndprobe++;
 3236b4c:	0080c9b4 	movhi	r2,806
 3236b50:	10b3ca04 	addi	r2,r2,-12504
 3236b54:	10801517 	ldw	r2,84(r2)
 3236b58:	10c00044 	addi	r3,r2,1
 3236b5c:	0080c9b4 	movhi	r2,806
 3236b60:	10b3ca04 	addi	r2,r2,-12504
 3236b64:	10c01515 	stw	r3,84(r2)
   }
   EXIT_CRIT_SECTION(tp);

   if (len) 
   {
      if (tp->t_force && len == 1)
 3236b68:	00005806 	br	3236ccc <tcp_output+0x984>
         tcpstat.tcps_sndprobe++;
      else if (SEQ_LT(tp->snd_nxt, tp->snd_max)) 
 3236b6c:	e0bff717 	ldw	r2,-36(fp)
 3236b70:	10c00f17 	ldw	r3,60(r2)
 3236b74:	e0bff717 	ldw	r2,-36(fp)
 3236b78:	10801a17 	ldw	r2,104(r2)
 3236b7c:	1885c83a 	sub	r2,r3,r2
 3236b80:	1004403a 	cmpge	r2,r2,zero
 3236b84:	1000101e 	bne	r2,zero,3236bc8 <tcp_output+0x880>
      {
         tcpstat.tcps_sndrexmitpack++;
 3236b88:	0080c9b4 	movhi	r2,806
 3236b8c:	10b3ca04 	addi	r2,r2,-12504
 3236b90:	10801217 	ldw	r2,72(r2)
 3236b94:	10c00044 	addi	r3,r2,1
 3236b98:	0080c9b4 	movhi	r2,806
 3236b9c:	10b3ca04 	addi	r2,r2,-12504
 3236ba0:	10c01215 	stw	r3,72(r2)
         tcpstat.tcps_sndrexmitbyte += len;
 3236ba4:	0080c9b4 	movhi	r2,806
 3236ba8:	10b3ca04 	addi	r2,r2,-12504
 3236bac:	10c01317 	ldw	r3,76(r2)
 3236bb0:	e0bff417 	ldw	r2,-48(fp)
 3236bb4:	1887883a 	add	r3,r3,r2
 3236bb8:	0080c9b4 	movhi	r2,806
 3236bbc:	10b3ca04 	addi	r2,r2,-12504
 3236bc0:	10c01315 	stw	r3,76(r2)
 3236bc4:	00004106 	br	3236ccc <tcp_output+0x984>
         tcpstat.tcps_sackresend++;
#endif
      } 
      else 
      {
         tcpstat.tcps_sndpack++;
 3236bc8:	0080c9b4 	movhi	r2,806
 3236bcc:	10b3ca04 	addi	r2,r2,-12504
 3236bd0:	10801017 	ldw	r2,64(r2)
 3236bd4:	10c00044 	addi	r3,r2,1
 3236bd8:	0080c9b4 	movhi	r2,806
 3236bdc:	10b3ca04 	addi	r2,r2,-12504
 3236be0:	10c01015 	stw	r3,64(r2)
         tcpstat.tcps_sndbyte += len;
 3236be4:	0080c9b4 	movhi	r2,806
 3236be8:	10b3ca04 	addi	r2,r2,-12504
 3236bec:	10c01117 	ldw	r3,68(r2)
 3236bf0:	e0bff417 	ldw	r2,-48(fp)
 3236bf4:	1887883a 	add	r3,r3,r2
 3236bf8:	0080c9b4 	movhi	r2,806
 3236bfc:	10b3ca04 	addi	r2,r2,-12504
 3236c00:	10c01115 	stw	r3,68(r2)
 3236c04:	00003106 	br	3236ccc <tcp_output+0x984>
      }
   }
   else if (tp->t_flags & TF_ACKNOW)
 3236c08:	e0bff717 	ldw	r2,-36(fp)
 3236c0c:	10800b0b 	ldhu	r2,44(r2)
 3236c10:	10bfffcc 	andi	r2,r2,65535
 3236c14:	1080004c 	andi	r2,r2,1
 3236c18:	10803fcc 	andi	r2,r2,255
 3236c1c:	1005003a 	cmpeq	r2,r2,zero
 3236c20:	1000081e 	bne	r2,zero,3236c44 <tcp_output+0x8fc>
   {
      tcpstat.tcps_sndacks++;
 3236c24:	0080c9b4 	movhi	r2,806
 3236c28:	10b3ca04 	addi	r2,r2,-12504
 3236c2c:	10801417 	ldw	r2,80(r2)
 3236c30:	10c00044 	addi	r3,r2,1
 3236c34:	0080c9b4 	movhi	r2,806
 3236c38:	10b3ca04 	addi	r2,r2,-12504
 3236c3c:	10c01415 	stw	r3,80(r2)
 3236c40:	00002206 	br	3236ccc <tcp_output+0x984>
   }
   else if (flags & (TH_SYN|TH_FIN|TH_RST))
 3236c44:	e0bff117 	ldw	r2,-60(fp)
 3236c48:	108001cc 	andi	r2,r2,7
 3236c4c:	1005003a 	cmpeq	r2,r2,zero
 3236c50:	1000081e 	bne	r2,zero,3236c74 <tcp_output+0x92c>
      tcpstat.tcps_sndctrl++;
 3236c54:	0080c9b4 	movhi	r2,806
 3236c58:	10b3ca04 	addi	r2,r2,-12504
 3236c5c:	10801817 	ldw	r2,96(r2)
 3236c60:	10c00044 	addi	r3,r2,1
 3236c64:	0080c9b4 	movhi	r2,806
 3236c68:	10b3ca04 	addi	r2,r2,-12504
 3236c6c:	10c01815 	stw	r3,96(r2)
 3236c70:	00001606 	br	3236ccc <tcp_output+0x984>
   else if (SEQ_GT(tp->snd_up, tp->snd_una))
 3236c74:	e0bff717 	ldw	r2,-36(fp)
 3236c78:	10c01017 	ldw	r3,64(r2)
 3236c7c:	e0bff717 	ldw	r2,-36(fp)
 3236c80:	10800e17 	ldw	r2,56(r2)
 3236c84:	1885c83a 	sub	r2,r3,r2
 3236c88:	10800050 	cmplti	r2,r2,1
 3236c8c:	1000081e 	bne	r2,zero,3236cb0 <tcp_output+0x968>
      tcpstat.tcps_sndurg++;
 3236c90:	0080c9b4 	movhi	r2,806
 3236c94:	10b3ca04 	addi	r2,r2,-12504
 3236c98:	10801617 	ldw	r2,88(r2)
 3236c9c:	10c00044 	addi	r3,r2,1
 3236ca0:	0080c9b4 	movhi	r2,806
 3236ca4:	10b3ca04 	addi	r2,r2,-12504
 3236ca8:	10c01615 	stw	r3,88(r2)
 3236cac:	00000706 	br	3236ccc <tcp_output+0x984>
   else
      tcpstat.tcps_sndwinup++;
 3236cb0:	0080c9b4 	movhi	r2,806
 3236cb4:	10b3ca04 	addi	r2,r2,-12504
 3236cb8:	10801717 	ldw	r2,92(r2)
 3236cbc:	10c00044 	addi	r3,r2,1
 3236cc0:	0080c9b4 	movhi	r2,806
 3236cc4:	10b3ca04 	addi	r2,r2,-12504
 3236cc8:	10c01715 	stw	r3,92(r2)

   ti = (struct tcpiphdr *)(m->m_data+sizeof(struct ip)-sizeof(struct ipovly));
 3236ccc:	e0bfef17 	ldw	r2,-68(fp)
 3236cd0:	10800317 	ldw	r2,12(r2)
 3236cd4:	e0bfee15 	stw	r2,-72(fp)
   if ((char *)ti < m->pkt->nb_buff)
 3236cd8:	e0bfef17 	ldw	r2,-68(fp)
 3236cdc:	10800117 	ldw	r2,4(r2)
 3236ce0:	10c00117 	ldw	r3,4(r2)
 3236ce4:	e0bfee17 	ldw	r2,-72(fp)
 3236ce8:	10c0032e 	bgeu	r2,r3,3236cf8 <tcp_output+0x9b0>
   {
      panic("tcp_out- packet ptr underflow\n");
 3236cec:	0100c974 	movhi	r4,805
 3236cf0:	213d7204 	addi	r4,r4,-2616
 3236cf4:	3225df00 	call	3225df0 <panic>
   }
   tcp_mbuf = m;        /* flag TCP header mbuf */
 3236cf8:	e0bfef17 	ldw	r2,-68(fp)
 3236cfc:	e0bfe915 	stw	r2,-92(fp)
      tcp_mbuf->m_data += sizeof(struct ipovly);
      tcp_mbuf->m_len -= sizeof(struct ipovly);
   }
#endif   /* end IP_V6 */

   if (tp->t_template == 0)
 3236d00:	e0bff717 	ldw	r2,-36(fp)
 3236d04:	10800c17 	ldw	r2,48(r2)
 3236d08:	1004c03a 	cmpne	r2,r2,zero
 3236d0c:	1000031e 	bne	r2,zero,3236d1c <tcp_output+0x9d4>
      panic("tcp_output");
 3236d10:	0100c974 	movhi	r4,805
 3236d14:	213d7a04 	addi	r4,r4,-2584
 3236d18:	3225df00 	call	3225df0 <panic>

   MEMCPY((char*)ti, (char*)tp->t_template, sizeof(struct tcpiphdr));
 3236d1c:	e0ffee17 	ldw	r3,-72(fp)
 3236d20:	e0bff717 	ldw	r2,-36(fp)
 3236d24:	10800c17 	ldw	r2,48(r2)
 3236d28:	1809883a 	mov	r4,r3
 3236d2c:	100b883a 	mov	r5,r2
 3236d30:	01800a04 	movi	r6,40
 3236d34:	32067cc0 	call	32067cc <memcpy>
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 3236d38:	e0bff117 	ldw	r2,-60(fp)
 3236d3c:	1080004c 	andi	r2,r2,1
 3236d40:	10803fcc 	andi	r2,r2,255
 3236d44:	1005003a 	cmpeq	r2,r2,zero
 3236d48:	1000101e 	bne	r2,zero,3236d8c <tcp_output+0xa44>
 3236d4c:	e0bff717 	ldw	r2,-36(fp)
 3236d50:	10800b0b 	ldhu	r2,44(r2)
 3236d54:	10bfffcc 	andi	r2,r2,65535
 3236d58:	1080040c 	andi	r2,r2,16
 3236d5c:	1005003a 	cmpeq	r2,r2,zero
 3236d60:	10000a1e 	bne	r2,zero,3236d8c <tcp_output+0xa44>
 3236d64:	e0bff717 	ldw	r2,-36(fp)
 3236d68:	10c00f17 	ldw	r3,60(r2)
 3236d6c:	e0bff717 	ldw	r2,-36(fp)
 3236d70:	10801a17 	ldw	r2,104(r2)
 3236d74:	1880051e 	bne	r3,r2,3236d8c <tcp_output+0xa44>
       tp->snd_nxt == tp->snd_max)
   {
      tp->snd_nxt--;
 3236d78:	e0bff717 	ldw	r2,-36(fp)
 3236d7c:	10800f17 	ldw	r2,60(r2)
 3236d80:	10ffffc4 	addi	r3,r2,-1
 3236d84:	e0bff717 	ldw	r2,-36(fp)
 3236d88:	10c00f15 	stw	r3,60(r2)
   }

   ti->ti_seq = htonl(tp->snd_nxt);
 3236d8c:	e0bff717 	ldw	r2,-36(fp)
 3236d90:	10800f17 	ldw	r2,60(r2)
 3236d94:	1004d63a 	srli	r2,r2,24
 3236d98:	10c03fcc 	andi	r3,r2,255
 3236d9c:	e0bff717 	ldw	r2,-36(fp)
 3236da0:	10800f17 	ldw	r2,60(r2)
 3236da4:	1004d23a 	srli	r2,r2,8
 3236da8:	10bfc00c 	andi	r2,r2,65280
 3236dac:	1886b03a 	or	r3,r3,r2
 3236db0:	e0bff717 	ldw	r2,-36(fp)
 3236db4:	10800f17 	ldw	r2,60(r2)
 3236db8:	10bfc00c 	andi	r2,r2,65280
 3236dbc:	1004923a 	slli	r2,r2,8
 3236dc0:	1886b03a 	or	r3,r3,r2
 3236dc4:	e0bff717 	ldw	r2,-36(fp)
 3236dc8:	10800f17 	ldw	r2,60(r2)
 3236dcc:	10803fcc 	andi	r2,r2,255
 3236dd0:	1004963a 	slli	r2,r2,24
 3236dd4:	1886b03a 	or	r3,r3,r2
 3236dd8:	e0bfee17 	ldw	r2,-72(fp)
 3236ddc:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(tp->rcv_nxt);
 3236de0:	e0bff717 	ldw	r2,-36(fp)
 3236de4:	10801617 	ldw	r2,88(r2)
 3236de8:	1004d63a 	srli	r2,r2,24
 3236dec:	10c03fcc 	andi	r3,r2,255
 3236df0:	e0bff717 	ldw	r2,-36(fp)
 3236df4:	10801617 	ldw	r2,88(r2)
 3236df8:	1004d23a 	srli	r2,r2,8
 3236dfc:	10bfc00c 	andi	r2,r2,65280
 3236e00:	1886b03a 	or	r3,r3,r2
 3236e04:	e0bff717 	ldw	r2,-36(fp)
 3236e08:	10801617 	ldw	r2,88(r2)
 3236e0c:	10bfc00c 	andi	r2,r2,65280
 3236e10:	1004923a 	slli	r2,r2,8
 3236e14:	1886b03a 	or	r3,r3,r2
 3236e18:	e0bff717 	ldw	r2,-36(fp)
 3236e1c:	10801617 	ldw	r2,88(r2)
 3236e20:	10803fcc 	andi	r2,r2,255
 3236e24:	1004963a 	slli	r2,r2,24
 3236e28:	1886b03a 	or	r3,r3,r2
 3236e2c:	e0bfee17 	ldw	r2,-72(fp)
 3236e30:	10c00715 	stw	r3,28(r2)
    * a retransmission, and the original SYN caused PPP to start
    * bringing the interface up, and PPP has got a new IP address
    * via IPCP), update the template and the inpcb with the new 
    * address.
    */
   if (flags & TH_SYN)
 3236e34:	e0bff117 	ldw	r2,-60(fp)
 3236e38:	1080008c 	andi	r2,r2,2
 3236e3c:	1005003a 	cmpeq	r2,r2,zero
 3236e40:	1000221e 	bne	r2,zero,3236ecc <tcp_output+0xb84>
   {
      struct inpcb * inp;
      inp = (struct inpcb *)so->so_pcb;
 3236e44:	e0bff517 	ldw	r2,-44(fp)
 3236e48:	10800117 	ldw	r2,4(r2)
 3236e4c:	e0bfe615 	stw	r2,-104(fp)

      switch(so->so_domain)
 3236e50:	e0bff517 	ldw	r2,-44(fp)
 3236e54:	10800517 	ldw	r2,20(r2)
 3236e58:	108000a0 	cmpeqi	r2,r2,2
 3236e5c:	1000011e 	bne	r2,zero,3236e64 <tcp_output+0xb1c>
 3236e60:	00001906 	br	3236ec8 <tcp_output+0xb80>
         }
         }
#endif   /* INCLUDE_PPP */

         /* If this is a SYN (not a SYN/ACK) then set the pmtu */
         if((flags & TH_ACK) == 0)
 3236e64:	e0bff117 	ldw	r2,-60(fp)
 3236e68:	1080040c 	andi	r2,r2,16
 3236e6c:	1004c03a 	cmpne	r2,r2,zero
 3236e70:	1000161e 	bne	r2,zero,3236ecc <tcp_output+0xb84>
            inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
            {
               NET ifp;
               /* find iface for route. Pass "src" as nexthop return */
               ifp = iproute(ti->ti_dst.s_addr, &src);
 3236e74:	e0bfee17 	ldw	r2,-72(fp)
 3236e78:	11000417 	ldw	r4,16(r2)
 3236e7c:	e17ff604 	addi	r5,fp,-40
 3236e80:	32404f00 	call	32404f0 <iproute>
 3236e84:	e0bfe515 	stw	r2,-108(fp)
               if(ifp)
 3236e88:	e0bfe517 	ldw	r2,-108(fp)
 3236e8c:	1005003a 	cmpeq	r2,r2,zero
 3236e90:	1000091e 	bne	r2,zero,3236eb8 <tcp_output+0xb70>
                  inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 3236e94:	e0bfe517 	ldw	r2,-108(fp)
 3236e98:	10c00917 	ldw	r3,36(r2)
 3236e9c:	e0bfe517 	ldw	r2,-108(fp)
 3236ea0:	10800817 	ldw	r2,32(r2)
 3236ea4:	1885c83a 	sub	r2,r3,r2
 3236ea8:	10fff604 	addi	r3,r2,-40
 3236eac:	e0bfe617 	ldw	r2,-104(fp)
 3236eb0:	10c00615 	stw	r3,24(r2)
 3236eb4:	00000506 	br	3236ecc <tcp_output+0xb84>
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
 3236eb8:	e0ffe617 	ldw	r3,-104(fp)
 3236ebc:	00809104 	movi	r2,580
 3236ec0:	18800615 	stw	r2,24(r3)
            }
#endif   /* IP_PMTU */
         }
         break;
 3236ec4:	00000106 	br	3236ecc <tcp_output+0xb84>
         }
         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();    /* bad domain setting */
 3236ec8:	322ab8c0 	call	322ab8c <dtrap>
      }
   }

   /* fill in options if any are set */
   if (optlen)
 3236ecc:	e0bfed17 	ldw	r2,-76(fp)
 3236ed0:	1005003a 	cmpeq	r2,r2,zero
 3236ed4:	10002f1e 	bne	r2,zero,3236f94 <tcp_output+0xc4c>
   {
      struct mbuf * mopt;

      mopt = m_getwithdata(MT_TXDATA, MAXOPTLEN);
 3236ed8:	01000084 	movi	r4,2
 3236edc:	01404004 	movi	r5,256
 3236ee0:	322b98c0 	call	322b98c <m_getnbuf>
 3236ee4:	e0bfe415 	stw	r2,-112(fp)
      if (mopt == NULL) 
 3236ee8:	e0bfe417 	ldw	r2,-112(fp)
 3236eec:	1004c03a 	cmpne	r2,r2,zero
 3236ef0:	1000051e 	bne	r2,zero,3236f08 <tcp_output+0xbc0>
      {
         m_freem(m);
 3236ef4:	e13fef17 	ldw	r4,-68(fp)
 3236ef8:	322bc680 	call	322bc68 <m_freem>
         return (ENOBUFS);
 3236efc:	00c01a44 	movi	r3,105
 3236f00:	e0fff815 	stw	r3,-32(fp)
 3236f04:	00016906 	br	32374ac <tcp_output+0x1164>
      }

      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
 3236f08:	e0bfe917 	ldw	r2,-92(fp)
 3236f0c:	10c00617 	ldw	r3,24(r2)
 3236f10:	e0bfe417 	ldw	r2,-112(fp)
 3236f14:	10c00615 	stw	r3,24(r2)
      tcp_mbuf->m_next = mopt;
 3236f18:	e0ffe917 	ldw	r3,-92(fp)
 3236f1c:	e0bfe417 	ldw	r2,-112(fp)
 3236f20:	18800615 	stw	r2,24(r3)

      /* extend options to aligned address */
      while(optlen & 0x03)
 3236f24:	00000706 	br	3236f44 <tcp_output+0xbfc>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;
 3236f28:	e0ffed17 	ldw	r3,-76(fp)
 3236f2c:	d0a8ea04 	addi	r2,gp,-23640
 3236f30:	1885883a 	add	r2,r3,r2
 3236f34:	10000005 	stb	zero,0(r2)
 3236f38:	e0bfed17 	ldw	r2,-76(fp)
 3236f3c:	10800044 	addi	r2,r2,1
 3236f40:	e0bfed15 	stw	r2,-76(fp)
      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
      tcp_mbuf->m_next = mopt;

      /* extend options to aligned address */
      while(optlen & 0x03)
 3236f44:	e0bfed17 	ldw	r2,-76(fp)
 3236f48:	108000cc 	andi	r2,r2,3
 3236f4c:	1004c03a 	cmpne	r2,r2,zero
 3236f50:	103ff51e 	bne	r2,zero,3236f28 <tcp_output+0xbe0>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;

      MEMCPY(mtod(mopt, char *), tcp_optionbuf, optlen);
 3236f54:	e0bfe417 	ldw	r2,-112(fp)
 3236f58:	10800317 	ldw	r2,12(r2)
 3236f5c:	1009883a 	mov	r4,r2
 3236f60:	d168ea04 	addi	r5,gp,-23640
 3236f64:	e1bfed17 	ldw	r6,-76(fp)
 3236f68:	32067cc0 	call	32067cc <memcpy>
      mopt->m_len = optlen;
 3236f6c:	e0ffe417 	ldw	r3,-112(fp)
 3236f70:	e0bfed17 	ldw	r2,-76(fp)
 3236f74:	18800215 	stw	r2,8(r3)
      /* use portable macro to set tcp data offset bits */
      SET_TH_OFF(ti->ti_t, ((sizeof (struct tcphdr) + optlen) >> 2));
 3236f78:	e0bfed17 	ldw	r2,-76(fp)
 3236f7c:	10800504 	addi	r2,r2,20
 3236f80:	1004d0ba 	srli	r2,r2,2
 3236f84:	1004913a 	slli	r2,r2,4
 3236f88:	1007883a 	mov	r3,r2
 3236f8c:	e0bfee17 	ldw	r2,-72(fp)
 3236f90:	10c00805 	stb	r3,32(r2)
   }

   ti->ti_flags = (u_char)flags;
 3236f94:	e0bff117 	ldw	r2,-60(fp)
 3236f98:	1007883a 	mov	r3,r2
 3236f9c:	e0bfee17 	ldw	r2,-72(fp)
 3236fa0:	10c00845 	stb	r3,33(r2)
   /*
    * Calculate receive window. Don't shrink window,
    * but avoid silly window syndrome.
    */
   if (win < (long)(so->so_rcv.sb_hiwat / 4) && win < (long)tp->t_maxseg)
 3236fa4:	e0bff517 	ldw	r2,-44(fp)
 3236fa8:	10800b17 	ldw	r2,44(r2)
 3236fac:	1004d0ba 	srli	r2,r2,2
 3236fb0:	1007883a 	mov	r3,r2
 3236fb4:	e0bff317 	ldw	r2,-52(fp)
 3236fb8:	10c0060e 	bge	r2,r3,3236fd4 <tcp_output+0xc8c>
 3236fbc:	e0bff717 	ldw	r2,-36(fp)
 3236fc0:	10800a0b 	ldhu	r2,40(r2)
 3236fc4:	10ffffcc 	andi	r3,r2,65535
 3236fc8:	e0bff317 	ldw	r2,-52(fp)
 3236fcc:	10c0010e 	bge	r2,r3,3236fd4 <tcp_output+0xc8c>
      win = 0;
 3236fd0:	e03ff315 	stw	zero,-52(fp)
   if (win < (long)(tp->rcv_adv - tp->rcv_nxt))
 3236fd4:	e0bff717 	ldw	r2,-36(fp)
 3236fd8:	10c01917 	ldw	r3,100(r2)
 3236fdc:	e0bff717 	ldw	r2,-36(fp)
 3236fe0:	10801617 	ldw	r2,88(r2)
 3236fe4:	1885c83a 	sub	r2,r3,r2
 3236fe8:	1007883a 	mov	r3,r2
 3236fec:	e0bff317 	ldw	r2,-52(fp)
 3236ff0:	10c0060e 	bge	r2,r3,323700c <tcp_output+0xcc4>
      win = (long)(tp->rcv_adv - tp->rcv_nxt);
 3236ff4:	e0bff717 	ldw	r2,-36(fp)
 3236ff8:	10c01917 	ldw	r3,100(r2)
 3236ffc:	e0bff717 	ldw	r2,-36(fp)
 3237000:	10801617 	ldw	r2,88(r2)
 3237004:	1885c83a 	sub	r2,r3,r2
 3237008:	e0bff315 	stw	r2,-52(fp)

   /* do check for Iniche buffer limits -JB- */
   if (bigfreeq.q_len == 0)   /* If queue length is 0, set window to 0 */
 323700c:	0080c9b4 	movhi	r2,806
 3237010:	10b30104 	addi	r2,r2,-13308
 3237014:	10800217 	ldw	r2,8(r2)
 3237018:	1004c03a 	cmpne	r2,r2,zero
 323701c:	1000021e 	bne	r2,zero,3237028 <tcp_output+0xce0>
   {
      win = 0;
 3237020:	e03ff315 	stw	zero,-52(fp)
 3237024:	00001406 	br	3237078 <tcp_output+0xd30>
   }
   else if(win > (((long)bigfreeq.q_len - 1) * (long)bigbufsiz))
 3237028:	0080c9b4 	movhi	r2,806
 323702c:	10b30104 	addi	r2,r2,-13308
 3237030:	10800217 	ldw	r2,8(r2)
 3237034:	10ffffc4 	addi	r3,r2,-1
 3237038:	0080c974 	movhi	r2,805
 323703c:	1089ac04 	addi	r2,r2,9904
 3237040:	10800017 	ldw	r2,0(r2)
 3237044:	1887383a 	mul	r3,r3,r2
 3237048:	e0bff317 	ldw	r2,-52(fp)
 323704c:	18800a0e 	bge	r3,r2,3237078 <tcp_output+0xd30>
   {
      win = ((long)bigfreeq.q_len - 1) * bigbufsiz;
 3237050:	0080c9b4 	movhi	r2,806
 3237054:	10b30104 	addi	r2,r2,-13308
 3237058:	10800217 	ldw	r2,8(r2)
 323705c:	10bfffc4 	addi	r2,r2,-1
 3237060:	1007883a 	mov	r3,r2
 3237064:	0080c974 	movhi	r2,805
 3237068:	1089ac04 	addi	r2,r2,9904
 323706c:	10800017 	ldw	r2,0(r2)
 3237070:	1885383a 	mul	r2,r3,r2
 3237074:	e0bff315 	stw	r2,-52(fp)
      ti->ti_win = htons((u_short)(win >> tp->rcv_wind_scale)); /* apply scale */
   }
   else
#endif /* TCP_WIN_SCALE */
   {
      ti->ti_win = htons((u_short)win);
 3237078:	e0bff317 	ldw	r2,-52(fp)
 323707c:	10bfffcc 	andi	r2,r2,65535
 3237080:	1004d23a 	srli	r2,r2,8
 3237084:	10803fcc 	andi	r2,r2,255
 3237088:	1009883a 	mov	r4,r2
 323708c:	e0bff317 	ldw	r2,-52(fp)
 3237090:	10bfffcc 	andi	r2,r2,65535
 3237094:	1004923a 	slli	r2,r2,8
 3237098:	1007883a 	mov	r3,r2
 323709c:	00bfc004 	movi	r2,-256
 32370a0:	1884703a 	and	r2,r3,r2
 32370a4:	2084b03a 	or	r2,r4,r2
 32370a8:	1007883a 	mov	r3,r2
 32370ac:	e0bfee17 	ldw	r2,-72(fp)
 32370b0:	10c0088d 	sth	r3,34(r2)
   }

   if (SEQ_GT(tp->snd_up, tp->snd_nxt)) 
 32370b4:	e0bff717 	ldw	r2,-36(fp)
 32370b8:	10c01017 	ldw	r3,64(r2)
 32370bc:	e0bff717 	ldw	r2,-36(fp)
 32370c0:	10800f17 	ldw	r2,60(r2)
 32370c4:	1885c83a 	sub	r2,r3,r2
 32370c8:	10800050 	cmplti	r2,r2,1
 32370cc:	1000201e 	bne	r2,zero,3237150 <tcp_output+0xe08>
   {
      ti->ti_urp = htons((u_short)(tp->snd_up - tp->snd_nxt));
 32370d0:	e0bff717 	ldw	r2,-36(fp)
 32370d4:	10801017 	ldw	r2,64(r2)
 32370d8:	1007883a 	mov	r3,r2
 32370dc:	e0bff717 	ldw	r2,-36(fp)
 32370e0:	10800f17 	ldw	r2,60(r2)
 32370e4:	1885c83a 	sub	r2,r3,r2
 32370e8:	10bfffcc 	andi	r2,r2,65535
 32370ec:	1004d23a 	srli	r2,r2,8
 32370f0:	10803fcc 	andi	r2,r2,255
 32370f4:	1009883a 	mov	r4,r2
 32370f8:	e0bff717 	ldw	r2,-36(fp)
 32370fc:	10801017 	ldw	r2,64(r2)
 3237100:	1007883a 	mov	r3,r2
 3237104:	e0bff717 	ldw	r2,-36(fp)
 3237108:	10800f17 	ldw	r2,60(r2)
 323710c:	1885c83a 	sub	r2,r3,r2
 3237110:	10bfffcc 	andi	r2,r2,65535
 3237114:	1004923a 	slli	r2,r2,8
 3237118:	1007883a 	mov	r3,r2
 323711c:	00bfc004 	movi	r2,-256
 3237120:	1884703a 	and	r2,r3,r2
 3237124:	2084b03a 	or	r2,r4,r2
 3237128:	1007883a 	mov	r3,r2
 323712c:	e0bfee17 	ldw	r2,-72(fp)
 3237130:	10c0098d 	sth	r3,38(r2)
      ti->ti_flags |= TH_URG;
 3237134:	e0bfee17 	ldw	r2,-72(fp)
 3237138:	10800843 	ldbu	r2,33(r2)
 323713c:	10800814 	ori	r2,r2,32
 3237140:	1007883a 	mov	r3,r2
 3237144:	e0bfee17 	ldw	r2,-72(fp)
 3237148:	10c00845 	stb	r3,33(r2)
 323714c:	00000406 	br	3237160 <tcp_output+0xe18>
       * If no urgent pointer to send, then we pull
       * the urgent pointer to the left edge of the send window
       * so that it doesn't drift into the send window on sequence
       * number wraparound.
       */
      tp->snd_up = tp->snd_una;        /* drag it along */
 3237150:	e0bff717 	ldw	r2,-36(fp)
 3237154:	10c00e17 	ldw	r3,56(r2)
 3237158:	e0bff717 	ldw	r2,-36(fp)
 323715c:	10c01015 	stw	r3,64(r2)
   /*
    * If anything to send and we can send it all, set PUSH.
    * (This will keep happy those implementations which only
    * give data to the user when a buffer fills or a PUSH comes in.)
    */
   if (len && off+len == (int)so->so_snd.sb_cc)
 3237160:	e0bff417 	ldw	r2,-48(fp)
 3237164:	1005003a 	cmpeq	r2,r2,zero
 3237168:	10000c1e 	bne	r2,zero,323719c <tcp_output+0xe54>
 323716c:	e0fff217 	ldw	r3,-56(fp)
 3237170:	e0bff417 	ldw	r2,-48(fp)
 3237174:	1887883a 	add	r3,r3,r2
 3237178:	e0bff517 	ldw	r2,-44(fp)
 323717c:	10801217 	ldw	r2,72(r2)
 3237180:	1880061e 	bne	r3,r2,323719c <tcp_output+0xe54>
      ti->ti_flags |= TH_PUSH;
 3237184:	e0bfee17 	ldw	r2,-72(fp)
 3237188:	10800843 	ldbu	r2,33(r2)
 323718c:	10800214 	ori	r2,r2,8
 3237190:	1007883a 	mov	r3,r2
 3237194:	e0bfee17 	ldw	r2,-72(fp)
 3237198:	10c00845 	stb	r3,33(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 323719c:	e0bff717 	ldw	r2,-36(fp)
 32371a0:	10800a83 	ldbu	r2,42(r2)
 32371a4:	10803fcc 	andi	r2,r2,255
 32371a8:	1080201c 	xori	r2,r2,128
 32371ac:	10bfe004 	addi	r2,r2,-128
 32371b0:	1005003a 	cmpeq	r2,r2,zero
 32371b4:	1000041e 	bne	r2,zero,32371c8 <tcp_output+0xe80>
 32371b8:	e0bff717 	ldw	r2,-36(fp)
 32371bc:	10800417 	ldw	r2,16(r2)
 32371c0:	1004c03a 	cmpne	r2,r2,zero
 32371c4:	1000561e 	bne	r2,zero,3237320 <tcp_output+0xfd8>
   {
      tcp_seq startseq = tp->snd_nxt;
 32371c8:	e0bff717 	ldw	r2,-36(fp)
 32371cc:	10800f17 	ldw	r2,60(r2)
 32371d0:	e0bfe315 	stw	r2,-116(fp)

      /*
       * Advance snd_nxt over sequence space of this segment.
       */
      if (flags & TH_SYN)
 32371d4:	e0bff117 	ldw	r2,-60(fp)
 32371d8:	1080008c 	andi	r2,r2,2
 32371dc:	1005003a 	cmpeq	r2,r2,zero
 32371e0:	1000051e 	bne	r2,zero,32371f8 <tcp_output+0xeb0>
         tp->snd_nxt++;
 32371e4:	e0bff717 	ldw	r2,-36(fp)
 32371e8:	10800f17 	ldw	r2,60(r2)
 32371ec:	10c00044 	addi	r3,r2,1
 32371f0:	e0bff717 	ldw	r2,-36(fp)
 32371f4:	10c00f15 	stw	r3,60(r2)

      if (flags & TH_FIN)
 32371f8:	e0bff117 	ldw	r2,-60(fp)
 32371fc:	1080004c 	andi	r2,r2,1
 3237200:	10803fcc 	andi	r2,r2,255
 3237204:	1005003a 	cmpeq	r2,r2,zero
 3237208:	10000b1e 	bne	r2,zero,3237238 <tcp_output+0xef0>
      {
         tp->snd_nxt++;
 323720c:	e0bff717 	ldw	r2,-36(fp)
 3237210:	10800f17 	ldw	r2,60(r2)
 3237214:	10c00044 	addi	r3,r2,1
 3237218:	e0bff717 	ldw	r2,-36(fp)
 323721c:	10c00f15 	stw	r3,60(r2)
         tp->t_flags |= TF_SENTFIN;
 3237220:	e0bff717 	ldw	r2,-36(fp)
 3237224:	10800b0b 	ldhu	r2,44(r2)
 3237228:	10800414 	ori	r2,r2,16
 323722c:	1007883a 	mov	r3,r2
 3237230:	e0bff717 	ldw	r2,-36(fp)
 3237234:	10c00b0d 	sth	r3,44(r2)
      }
      tp->snd_nxt += len;
 3237238:	e0bff717 	ldw	r2,-36(fp)
 323723c:	10c00f17 	ldw	r3,60(r2)
 3237240:	e0bff417 	ldw	r2,-48(fp)
 3237244:	1887883a 	add	r3,r3,r2
 3237248:	e0bff717 	ldw	r2,-36(fp)
 323724c:	10c00f15 	stw	r3,60(r2)
      if (SEQ_GT(tp->snd_nxt, tp->snd_max)) 
 3237250:	e0bff717 	ldw	r2,-36(fp)
 3237254:	10c00f17 	ldw	r3,60(r2)
 3237258:	e0bff717 	ldw	r2,-36(fp)
 323725c:	10801a17 	ldw	r2,104(r2)
 3237260:	1885c83a 	sub	r2,r3,r2
 3237264:	10800050 	cmplti	r2,r2,1
 3237268:	1000171e 	bne	r2,zero,32372c8 <tcp_output+0xf80>
      {
         tp->snd_max = tp->snd_nxt;
 323726c:	e0bff717 	ldw	r2,-36(fp)
 3237270:	10c00f17 	ldw	r3,60(r2)
 3237274:	e0bff717 	ldw	r2,-36(fp)
 3237278:	10c01a15 	stw	r3,104(r2)
         /*
          * Time this transmission if not a retransmission and
          * not currently timing anything.
          */
         if (tp->t_rttick == 0) 
 323727c:	e0bff717 	ldw	r2,-36(fp)
 3237280:	10801e17 	ldw	r2,120(r2)
 3237284:	1004c03a 	cmpne	r2,r2,zero
 3237288:	10000f1e 	bne	r2,zero,32372c8 <tcp_output+0xf80>
         {
            tp->t_rttick = cticks;
 323728c:	0080c974 	movhi	r2,805
 3237290:	10925604 	addi	r2,r2,18776
 3237294:	10c00017 	ldw	r3,0(r2)
 3237298:	e0bff717 	ldw	r2,-36(fp)
 323729c:	10c01e15 	stw	r3,120(r2)
            tp->t_rtseq = startseq;
 32372a0:	e0fff717 	ldw	r3,-36(fp)
 32372a4:	e0bfe317 	ldw	r2,-116(fp)
 32372a8:	18801f15 	stw	r2,124(r3)
            tcpstat.tcps_segstimed++;
 32372ac:	0080c9b4 	movhi	r2,806
 32372b0:	10b3ca04 	addi	r2,r2,-12504
 32372b4:	10800617 	ldw	r2,24(r2)
 32372b8:	10c00044 	addi	r3,r2,1
 32372bc:	0080c9b4 	movhi	r2,806
 32372c0:	10b3ca04 	addi	r2,r2,-12504
 32372c4:	10c00615 	stw	r3,24(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 32372c8:	e0bff717 	ldw	r2,-36(fp)
 32372cc:	10800317 	ldw	r2,12(r2)
 32372d0:	1004c03a 	cmpne	r2,r2,zero
 32372d4:	1000211e 	bne	r2,zero,323735c <tcp_output+0x1014>
 32372d8:	e0bff717 	ldw	r2,-36(fp)
 32372dc:	10c00f17 	ldw	r3,60(r2)
 32372e0:	e0bff717 	ldw	r2,-36(fp)
 32372e4:	10800e17 	ldw	r2,56(r2)
 32372e8:	18801c26 	beq	r3,r2,323735c <tcp_output+0x1014>
          tp->snd_nxt != tp->snd_una) 
      {
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 32372ec:	e0bff717 	ldw	r2,-36(fp)
 32372f0:	10c00817 	ldw	r3,32(r2)
 32372f4:	e0bff717 	ldw	r2,-36(fp)
 32372f8:	10c00315 	stw	r3,12(r2)
         if (tp->t_timer[TCPT_PERSIST]) 
 32372fc:	e0bff717 	ldw	r2,-36(fp)
 3237300:	10800417 	ldw	r2,16(r2)
 3237304:	1005003a 	cmpeq	r2,r2,zero
 3237308:	1000141e 	bne	r2,zero,323735c <tcp_output+0x1014>
         {
            tp->t_timer[TCPT_PERSIST] = 0;
 323730c:	e0bff717 	ldw	r2,-36(fp)
 3237310:	10000415 	stw	zero,16(r2)
            tp->t_rxtshift = 0;
 3237314:	e0bff717 	ldw	r2,-36(fp)
 3237318:	10000715 	stw	zero,28(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 323731c:	00000f06 	br	323735c <tcp_output+0x1014>
         }
      }
   }
   else
   {
      if (SEQ_GT(tp->snd_nxt + len, tp->snd_max))
 3237320:	e0bff717 	ldw	r2,-36(fp)
 3237324:	10c00f17 	ldw	r3,60(r2)
 3237328:	e0bff417 	ldw	r2,-48(fp)
 323732c:	1887883a 	add	r3,r3,r2
 3237330:	e0bff717 	ldw	r2,-36(fp)
 3237334:	10801a17 	ldw	r2,104(r2)
 3237338:	1885c83a 	sub	r2,r3,r2
 323733c:	10800050 	cmplti	r2,r2,1
 3237340:	1000061e 	bne	r2,zero,323735c <tcp_output+0x1014>
         tp->snd_max = tp->snd_nxt + len;
 3237344:	e0bff717 	ldw	r2,-36(fp)
 3237348:	10c00f17 	ldw	r3,60(r2)
 323734c:	e0bff417 	ldw	r2,-48(fp)
 3237350:	1887883a 	add	r3,r3,r2
 3237354:	e0bff717 	ldw	r2,-36(fp)
 3237358:	10c01a15 	stw	r3,104(r2)
   tcp_trace("tcp_output: sending, state %d, tcpcb: %x",
    tp->t_state, tp );
#endif

#ifdef MUTE_WARNS
   error = 0;
 323735c:	e03ff015 	stw	zero,-64(fp)
   if(so->so_domain != AF_INET6)
#endif   /* IP_V6 */
   {
      struct ip * pip;
   
      pip = mtod(m, struct ip *);
 3237360:	e0bfef17 	ldw	r2,-68(fp)
 3237364:	10800317 	ldw	r2,12(r2)
 3237368:	e0bfe215 	stw	r2,-120(fp)
      /* Fill in IP length and send to IP level. */
      pip->ip_len = (u_short)(TCPIPHDRSZ + optlen + len);
 323736c:	e0bfed17 	ldw	r2,-76(fp)
 3237370:	1007883a 	mov	r3,r2
 3237374:	e0bff417 	ldw	r2,-48(fp)
 3237378:	1885883a 	add	r2,r3,r2
 323737c:	10800a04 	addi	r2,r2,40
 3237380:	1007883a 	mov	r3,r2
 3237384:	e0bfe217 	ldw	r2,-120(fp)
 3237388:	10c0008d 	sth	r3,2(r2)
      error = ip_output(m, so->so_optsPack);
 323738c:	e0bff517 	ldw	r2,-44(fp)
 3237390:	11401f17 	ldw	r5,124(r2)
 3237394:	e13fef17 	ldw	r4,-68(fp)
 3237398:	322c69c0 	call	322c69c <ip_output>
 323739c:	e0bff015 	stw	r2,-64(fp)
                    (sizeof(struct ipv6) + sizeof(struct tcphdr) + optlen + len),
                    (struct   ip_socopts *)0);          
   }
#endif   /* IP_V6 */

   if (error)
 32373a0:	e0bff017 	ldw	r2,-64(fp)
 32373a4:	1005003a 	cmpeq	r2,r2,zero
 32373a8:	1000151e 	bne	r2,zero,3237400 <tcp_output+0x10b8>
   {
      if (error == ENOBUFS)   /* ip_output needed a copy buffer it couldn't get */
 32373ac:	e0bff017 	ldw	r2,-64(fp)
 32373b0:	10801a58 	cmpnei	r2,r2,105
 32373b4:	10000f1e 	bne	r2,zero,32373f4 <tcp_output+0x10ac>
      {
         if (m->m_type == MT_FREE)  /* ip_output() probably freed first mbuf */
 32373b8:	e0bfef17 	ldw	r2,-68(fp)
 32373bc:	10800817 	ldw	r2,32(r2)
 32373c0:	1004c03a 	cmpne	r2,r2,zero
 32373c4:	1000031e 	bne	r2,zero,32373d4 <tcp_output+0x108c>
            m = m->m_next;
 32373c8:	e0bfef17 	ldw	r2,-68(fp)
 32373cc:	10800617 	ldw	r2,24(r2)
 32373d0:	e0bfef15 	stw	r2,-68(fp)
         m_freem(m); /* free the mbuf chain */
 32373d4:	e13fef17 	ldw	r4,-68(fp)
 32373d8:	322bc680 	call	322bc68 <m_freem>
         tcp_quench(tp->t_inpcb);
 32373dc:	e0bff717 	ldw	r2,-36(fp)
 32373e0:	11000d17 	ldw	r4,52(r2)
 32373e4:	3237f4c0 	call	3237f4c <tcp_quench>
         return (error);
 32373e8:	e0bff017 	ldw	r2,-64(fp)
 32373ec:	e0bff815 	stw	r2,-32(fp)
 32373f0:	00002e06 	br	32374ac <tcp_output+0x1164>
      }
      return (error);
 32373f4:	e0fff017 	ldw	r3,-64(fp)
 32373f8:	e0fff815 	stw	r3,-32(fp)
 32373fc:	00002b06 	br	32374ac <tcp_output+0x1164>

   /*
    * Data sent (as far as we can tell).
    */

   TCP_MIB_INC(tcpOutSegs);   /* keep MIB stats */
 3237400:	0080c9b4 	movhi	r2,806
 3237404:	10b39c04 	addi	r2,r2,-12688
 3237408:	10800a17 	ldw	r2,40(r2)
 323740c:	10c00044 	addi	r3,r2,1
 3237410:	0080c9b4 	movhi	r2,806
 3237414:	10b39c04 	addi	r2,r2,-12688
 3237418:	10c00a15 	stw	r3,40(r2)
   tcpstat.tcps_sndtotal++;
 323741c:	0080c9b4 	movhi	r2,806
 3237420:	10b3ca04 	addi	r2,r2,-12504
 3237424:	10800f17 	ldw	r2,60(r2)
 3237428:	10c00044 	addi	r3,r2,1
 323742c:	0080c9b4 	movhi	r2,806
 3237430:	10b3ca04 	addi	r2,r2,-12504
 3237434:	10c00f15 	stw	r3,60(r2)
   /*
    * If this advertises a larger window than any other segment,
    * then remember the size of the advertised window.
    * Any pending ACK has now been sent.
    */
   if (win > 0 && SEQ_GT(tp->rcv_nxt+win, tp->rcv_adv))
 3237438:	e0bff317 	ldw	r2,-52(fp)
 323743c:	10800050 	cmplti	r2,r2,1
 3237440:	10000f1e 	bne	r2,zero,3237480 <tcp_output+0x1138>
 3237444:	e0bff717 	ldw	r2,-36(fp)
 3237448:	10c01617 	ldw	r3,88(r2)
 323744c:	e0bff317 	ldw	r2,-52(fp)
 3237450:	1887883a 	add	r3,r3,r2
 3237454:	e0bff717 	ldw	r2,-36(fp)
 3237458:	10801917 	ldw	r2,100(r2)
 323745c:	1885c83a 	sub	r2,r3,r2
 3237460:	10800050 	cmplti	r2,r2,1
 3237464:	1000061e 	bne	r2,zero,3237480 <tcp_output+0x1138>
      tp->rcv_adv = tp->rcv_nxt + (unsigned)win;
 3237468:	e0bff717 	ldw	r2,-36(fp)
 323746c:	10c01617 	ldw	r3,88(r2)
 3237470:	e0bff317 	ldw	r2,-52(fp)
 3237474:	1887883a 	add	r3,r3,r2
 3237478:	e0bff717 	ldw	r2,-36(fp)
 323747c:	10c01915 	stw	r3,100(r2)
   tp->t_flags &= ~(TF_ACKNOW|TF_SACKNOW|TF_DELACK);
 3237480:	e0bff717 	ldw	r2,-36(fp)
 3237484:	10c00b0b 	ldhu	r3,44(r2)
 3237488:	00bfef04 	movi	r2,-68
 323748c:	1884703a 	and	r2,r3,r2
 3237490:	1007883a 	mov	r3,r2
 3237494:	e0bff717 	ldw	r2,-36(fp)
 3237498:	10c00b0d 	sth	r3,44(r2)
   if (sendalot)
 323749c:	e0bfeb17 	ldw	r2,-84(fp)
 32374a0:	1004c03a 	cmpne	r2,r2,zero
 32374a4:	103bb81e 	bne	r2,zero,3236388 <tcp_output+0x40>
      goto again;
   return (0);
 32374a8:	e03ff815 	stw	zero,-32(fp)
 32374ac:	e0bff817 	ldw	r2,-32(fp)
}
 32374b0:	e037883a 	mov	sp,fp
 32374b4:	dfc00117 	ldw	ra,4(sp)
 32374b8:	df000017 	ldw	fp,0(sp)
 32374bc:	dec00204 	addi	sp,sp,8
 32374c0:	f800283a 	ret

032374c4 <tcp_setpersist>:
 * RETURNS: NA
 */

void
tcp_setpersist(struct tcpcb * tp)
{
 32374c4:	defffc04 	addi	sp,sp,-16
 32374c8:	dfc00315 	stw	ra,12(sp)
 32374cc:	df000215 	stw	fp,8(sp)
 32374d0:	df000204 	addi	fp,sp,8
 32374d4:	e13fff15 	stw	r4,-4(fp)
   int   t;

   t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 32374d8:	e0bfff17 	ldw	r2,-4(fp)
 32374dc:	10802017 	ldw	r2,128(r2)
 32374e0:	1007d0ba 	srai	r3,r2,2
 32374e4:	e0bfff17 	ldw	r2,-4(fp)
 32374e8:	10802117 	ldw	r2,132(r2)
 32374ec:	1885883a 	add	r2,r3,r2
 32374f0:	1005d07a 	srai	r2,r2,1
 32374f4:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_timer[TCPT_REXMT])
 32374f8:	e0bfff17 	ldw	r2,-4(fp)
 32374fc:	10800317 	ldw	r2,12(r2)
 3237500:	1005003a 	cmpeq	r2,r2,zero
 3237504:	1000031e 	bne	r2,zero,3237514 <tcp_setpersist+0x50>
      panic("tcp_output REXMT");
 3237508:	0100c974 	movhi	r4,805
 323750c:	213d7d04 	addi	r4,r4,-2572
 3237510:	3225df00 	call	3225df0 <panic>
   /*
    * Start/restart persistance timer.
    */
   TCPT_RANGESET(tp->t_timer[TCPT_PERSIST],
 3237514:	e0bfff17 	ldw	r2,-4(fp)
 3237518:	10c00717 	ldw	r3,28(r2)
 323751c:	0080c974 	movhi	r2,805
 3237520:	108875c4 	addi	r2,r2,8663
 3237524:	10c5883a 	add	r2,r2,r3
 3237528:	10800003 	ldbu	r2,0(r2)
 323752c:	10c03fcc 	andi	r3,r2,255
 3237530:	e0bffe17 	ldw	r2,-8(fp)
 3237534:	1885383a 	mul	r2,r3,r2
 3237538:	10ffffcc 	andi	r3,r2,65535
 323753c:	18e0001c 	xori	r3,r3,32768
 3237540:	18e00004 	addi	r3,r3,-32768
 3237544:	e0bfff17 	ldw	r2,-4(fp)
 3237548:	10c00415 	stw	r3,16(r2)
 323754c:	e0bfff17 	ldw	r2,-4(fp)
 3237550:	10800417 	ldw	r2,16(r2)
 3237554:	10800288 	cmpgei	r2,r2,10
 3237558:	1000041e 	bne	r2,zero,323756c <tcp_setpersist+0xa8>
 323755c:	e0ffff17 	ldw	r3,-4(fp)
 3237560:	00800284 	movi	r2,10
 3237564:	18800415 	stw	r2,16(r3)
 3237568:	00000706 	br	3237588 <tcp_setpersist+0xc4>
 323756c:	e0bfff17 	ldw	r2,-4(fp)
 3237570:	10800417 	ldw	r2,16(r2)
 3237574:	10801e50 	cmplti	r2,r2,121
 3237578:	1000031e 	bne	r2,zero,3237588 <tcp_setpersist+0xc4>
 323757c:	e0ffff17 	ldw	r3,-4(fp)
 3237580:	00801e04 	movi	r2,120
 3237584:	18800415 	stw	r2,16(r3)
    t * tcp_backoff[tp->t_rxtshift],
    TCPTV_PERSMIN, TCPTV_PERSMAX);
   if (tp->t_rxtshift < TCP_MAXRXTSHIFT)
 3237588:	e0bfff17 	ldw	r2,-4(fp)
 323758c:	10800717 	ldw	r2,28(r2)
 3237590:	10800308 	cmpgei	r2,r2,12
 3237594:	1000051e 	bne	r2,zero,32375ac <tcp_setpersist+0xe8>
      tp->t_rxtshift++;
 3237598:	e0bfff17 	ldw	r2,-4(fp)
 323759c:	10800717 	ldw	r2,28(r2)
 32375a0:	10c00044 	addi	r3,r2,1
 32375a4:	e0bfff17 	ldw	r2,-4(fp)
 32375a8:	10c00715 	stw	r3,28(r2)

}
 32375ac:	e037883a 	mov	sp,fp
 32375b0:	dfc00117 	ldw	ra,4(sp)
 32375b4:	df000017 	ldw	fp,0(sp)
 32375b8:	dec00204 	addi	sp,sp,8
 32375bc:	f800283a 	ret

032375c0 <bld_options>:
 * RETURNS: length of option data added to buffer
 */

static int
bld_options(struct tcpcb * tp, u_char * cp, int flags, struct socket * so)
{
 32375c0:	defff704 	addi	sp,sp,-36
 32375c4:	dfc00815 	stw	ra,32(sp)
 32375c8:	df000715 	stw	fp,28(sp)
 32375cc:	df000704 	addi	fp,sp,28
 32375d0:	e13ffb15 	stw	r4,-20(fp)
 32375d4:	e17ffc15 	stw	r5,-16(fp)
 32375d8:	e1bffd15 	stw	r6,-12(fp)
 32375dc:	e1fffe15 	stw	r7,-8(fp)
   int      len;
   u_short  mss;

   if(tp->t_flags & TF_NOOPT)    /* no options allowed? */
 32375e0:	e0bffb17 	ldw	r2,-20(fp)
 32375e4:	10800b0b 	ldhu	r2,44(r2)
 32375e8:	10bfffcc 	andi	r2,r2,65535
 32375ec:	1080020c 	andi	r2,r2,8
 32375f0:	1005003a 	cmpeq	r2,r2,zero
 32375f4:	1000021e 	bne	r2,zero,3237600 <bld_options+0x40>
      return 0;
 32375f8:	e03fff15 	stw	zero,-4(fp)
 32375fc:	00002406 	br	3237690 <bld_options+0xd0>

   /* Alway put MSS option on SYN packets */
   if (flags & TH_SYN)
 3237600:	e0bffd17 	ldw	r2,-12(fp)
 3237604:	1080008c 	andi	r2,r2,2
 3237608:	1005003a 	cmpeq	r2,r2,zero
 323760c:	10001d1e 	bne	r2,zero,3237684 <bld_options+0xc4>
   {
      mss   =  (u_short)tcp_mss(so);
 3237610:	e13ffe17 	ldw	r4,-8(fp)
 3237614:	323622c0 	call	323622c <tcp_mss>
 3237618:	e0bff90d 	sth	r2,-28(fp)

      /* always send MSS option on SYN, fill in MSS parm */
      *(cp + 0) = TCPOPT_MAXSEG;
 323761c:	e0fffc17 	ldw	r3,-16(fp)
 3237620:	00800084 	movi	r2,2
 3237624:	18800005 	stb	r2,0(r3)
      *(cp + 1) = MSSOPT_LEN;               /* length byte */
 3237628:	e0bffc17 	ldw	r2,-16(fp)
 323762c:	10c00044 	addi	r3,r2,1
 3237630:	00800104 	movi	r2,4
 3237634:	18800005 	stb	r2,0(r3)
      *(cp + 2)  = (u_char) ((mss & 0xff00) >> 8);
 3237638:	e0bffc17 	ldw	r2,-16(fp)
 323763c:	10c00084 	addi	r3,r2,2
 3237640:	e0bff90b 	ldhu	r2,-28(fp)
 3237644:	10bfc00c 	andi	r2,r2,65280
 3237648:	1005d23a 	srai	r2,r2,8
 323764c:	18800005 	stb	r2,0(r3)
      *(cp + 3)  = (u_char) (mss & 0xff);
 3237650:	e0bffc17 	ldw	r2,-16(fp)
 3237654:	110000c4 	addi	r4,r2,3
 3237658:	e0bff90b 	ldhu	r2,-28(fp)
 323765c:	1007883a 	mov	r3,r2
 3237660:	00bfffc4 	movi	r2,-1
 3237664:	1884703a 	and	r2,r3,r2
 3237668:	20800005 	stb	r2,0(r4)
      len = 4;
 323766c:	00800104 	movi	r2,4
 3237670:	e0bffa15 	stw	r2,-24(fp)
      cp += 4;
 3237674:	e0bffc17 	ldw	r2,-16(fp)
 3237678:	10800104 	addi	r2,r2,4
 323767c:	e0bffc15 	stw	r2,-16(fp)
 3237680:	00000106 	br	3237688 <bld_options+0xc8>
   }
   else
      len = 0;
 3237684:	e03ffa15 	stw	zero,-24(fp)
      len += 10;
   }
#endif   /* TCP_TIMESTAMP */

   USE_ARG(so);
   return len;
 3237688:	e0bffa17 	ldw	r2,-24(fp)
 323768c:	e0bfff15 	stw	r2,-4(fp)
 3237690:	e0bfff17 	ldw	r2,-4(fp)
}
 3237694:	e037883a 	mov	sp,fp
 3237698:	dfc00117 	ldw	ra,4(sp)
 323769c:	df000017 	ldw	fp,0(sp)
 32376a0:	dec00204 	addi	sp,sp,8
 32376a4:	f800283a 	ret

032376a8 <tcp_init>:
 * RETURNS: 
 */

void
tcp_init()
{
 32376a8:	deffff04 	addi	sp,sp,-4
 32376ac:	df000015 	stw	fp,0(sp)
 32376b0:	d839883a 	mov	fp,sp
   tcp_iss = 1;      /* wrong */
 32376b4:	00c0c974 	movhi	r3,805
 32376b8:	18d26304 	addi	r3,r3,18828
 32376bc:	00800044 	movi	r2,1
 32376c0:	18800015 	stw	r2,0(r3)
   tcb.inp_next = tcb.inp_prev = &tcb;
 32376c4:	00c0c9b4 	movhi	r3,806
 32376c8:	18f3bf04 	addi	r3,r3,-12548
 32376cc:	0080c9b4 	movhi	r2,806
 32376d0:	10b3bf04 	addi	r2,r2,-12548
 32376d4:	18800115 	stw	r2,4(r3)
 32376d8:	0080c9b4 	movhi	r2,806
 32376dc:	10b3bf04 	addi	r2,r2,-12548
 32376e0:	10c00117 	ldw	r3,4(r2)
 32376e4:	0080c9b4 	movhi	r2,806
 32376e8:	10b3bf04 	addi	r2,r2,-12548
 32376ec:	10c00015 	stw	r3,0(r2)
}
 32376f0:	e037883a 	mov	sp,fp
 32376f4:	df000017 	ldw	fp,0(sp)
 32376f8:	dec00104 	addi	sp,sp,4
 32376fc:	f800283a 	ret

03237700 <tcp_template>:
 * RETURNS: 
 */

struct tcpiphdr * 
tcp_template(struct tcpcb * tp)
{
 3237700:	defffa04 	addi	sp,sp,-24
 3237704:	dfc00515 	stw	ra,20(sp)
 3237708:	df000415 	stw	fp,16(sp)
 323770c:	df000404 	addi	fp,sp,16
 3237710:	e13ffe15 	stw	r4,-8(fp)
   struct inpcb * inp   =  tp->t_inpcb;
 3237714:	e0bffe17 	ldw	r2,-8(fp)
 3237718:	10800d17 	ldw	r2,52(r2)
 323771c:	e0bffd15 	stw	r2,-12(fp)
   struct tcpiphdr * n;

   if ((n = tp->t_template) == 0)
 3237720:	e0bffe17 	ldw	r2,-8(fp)
 3237724:	10800c17 	ldw	r2,48(r2)
 3237728:	e0bffc15 	stw	r2,-16(fp)
 323772c:	e0bffc17 	ldw	r2,-16(fp)
 3237730:	1004c03a 	cmpne	r2,r2,zero
 3237734:	1000081e 	bne	r2,zero,3237758 <tcp_template+0x58>
   {
      n = (struct tcpiphdr *)TPH_ALLOC (sizeof (*n));
 3237738:	01000a04 	movi	r4,40
 323773c:	322b5d00 	call	322b5d0 <npalloc>
 3237740:	e0bffc15 	stw	r2,-16(fp)
      if (n == NULL)
 3237744:	e0bffc17 	ldw	r2,-16(fp)
 3237748:	1004c03a 	cmpne	r2,r2,zero
 323774c:	1000021e 	bne	r2,zero,3237758 <tcp_template+0x58>
         return (0);
 3237750:	e03fff15 	stw	zero,-4(fp)
 3237754:	00002a06 	br	3237800 <tcp_template+0x100>
   }
   n->ti_next = n->ti_prev = 0;
 3237758:	e0bffc17 	ldw	r2,-16(fp)
 323775c:	10000115 	stw	zero,4(r2)
 3237760:	e0bffc17 	ldw	r2,-16(fp)
 3237764:	10c00117 	ldw	r3,4(r2)
 3237768:	e0bffc17 	ldw	r2,-16(fp)
 323776c:	10c00015 	stw	r3,0(r2)
   n->ti_len = htons(sizeof (struct tcpiphdr) - sizeof (struct ip));
 3237770:	e0fffc17 	ldw	r3,-16(fp)
 3237774:	00850004 	movi	r2,5120
 3237778:	1880028d 	sth	r2,10(r3)
   n->ti_src = inp->inp_laddr;
 323777c:	e0bffd17 	ldw	r2,-12(fp)
 3237780:	10c00417 	ldw	r3,16(r2)
 3237784:	e0bffc17 	ldw	r2,-16(fp)
 3237788:	10c00315 	stw	r3,12(r2)
   n->ti_dst = inp->inp_faddr;
 323778c:	e0bffd17 	ldw	r2,-12(fp)
 3237790:	10c00317 	ldw	r3,12(r2)
 3237794:	e0bffc17 	ldw	r2,-16(fp)
 3237798:	10c00415 	stw	r3,16(r2)
   n->ti_sport = inp->inp_lport;
 323779c:	e0bffd17 	ldw	r2,-12(fp)
 32377a0:	10c0078b 	ldhu	r3,30(r2)
 32377a4:	e0bffc17 	ldw	r2,-16(fp)
 32377a8:	10c0050d 	sth	r3,20(r2)
   n->ti_dport = inp->inp_fport;
 32377ac:	e0bffd17 	ldw	r2,-12(fp)
 32377b0:	10c0070b 	ldhu	r3,28(r2)
 32377b4:	e0bffc17 	ldw	r2,-16(fp)
 32377b8:	10c0058d 	sth	r3,22(r2)
   n->ti_seq = 0;
 32377bc:	e0bffc17 	ldw	r2,-16(fp)
 32377c0:	10000615 	stw	zero,24(r2)
   n->ti_ack = 0;
 32377c4:	e0bffc17 	ldw	r2,-16(fp)
 32377c8:	10000715 	stw	zero,28(r2)
   n->ti_t.th_doff = (5 << 4);   /* NetPort */
 32377cc:	e0fffc17 	ldw	r3,-16(fp)
 32377d0:	00801404 	movi	r2,80
 32377d4:	18800805 	stb	r2,32(r3)
   n->ti_flags = 0;
 32377d8:	e0bffc17 	ldw	r2,-16(fp)
 32377dc:	10000845 	stb	zero,33(r2)
   n->ti_win = 0;
 32377e0:	e0bffc17 	ldw	r2,-16(fp)
 32377e4:	1000088d 	sth	zero,34(r2)
   n->ti_sum = 0;
 32377e8:	e0bffc17 	ldw	r2,-16(fp)
 32377ec:	1000090d 	sth	zero,36(r2)
   n->ti_urp = 0;
 32377f0:	e0bffc17 	ldw	r2,-16(fp)
 32377f4:	1000098d 	sth	zero,38(r2)
   return (n);
 32377f8:	e0bffc17 	ldw	r2,-16(fp)
 32377fc:	e0bfff15 	stw	r2,-4(fp)
 3237800:	e0bfff17 	ldw	r2,-4(fp)
}
 3237804:	e037883a 	mov	sp,fp
 3237808:	dfc00117 	ldw	ra,4(sp)
 323780c:	df000017 	ldw	fp,0(sp)
 3237810:	dec00204 	addi	sp,sp,8
 3237814:	f800283a 	ret

03237818 <tcp_respond>:
   struct tcpiphdr * ti,
   tcp_seq  ack,
   tcp_seq  seq,
   int   flags,
   struct mbuf *  ti_mbuf)
{
 3237818:	defff104 	addi	sp,sp,-60
 323781c:	dfc00e15 	stw	ra,56(sp)
 3237820:	df000d15 	stw	fp,52(sp)
 3237824:	df000d04 	addi	fp,sp,52
 3237828:	e13ffb15 	stw	r4,-20(fp)
 323782c:	e17ffc15 	stw	r5,-16(fp)
 3237830:	e1bffd15 	stw	r6,-12(fp)
 3237834:	e1fffe15 	stw	r7,-8(fp)
   int      tlen;       /* tcp data len - 0 or 1 */
   int      domain;     /* AF_INET or AF_INET6 */
   int      win = 0;    /* window to use in sent packet */
 3237838:	e03ff815 	stw	zero,-32(fp)
   struct mbuf *  m;    /* mbuf to send */
   struct tcpiphdr * tmp_thdr;   /* scratch */

   if (tp)
 323783c:	e0bffb17 	ldw	r2,-20(fp)
 3237840:	1005003a 	cmpeq	r2,r2,zero
 3237844:	10001a1e 	bne	r2,zero,32378b0 <tcp_respond+0x98>
      win = (int)sbspace(&tp->t_inpcb->inp_socket->so_rcv);
 3237848:	e0bffb17 	ldw	r2,-20(fp)
 323784c:	10800d17 	ldw	r2,52(r2)
 3237850:	10800817 	ldw	r2,32(r2)
 3237854:	10800b17 	ldw	r2,44(r2)
 3237858:	1007883a 	mov	r3,r2
 323785c:	e0bffb17 	ldw	r2,-20(fp)
 3237860:	10800d17 	ldw	r2,52(r2)
 3237864:	10800817 	ldw	r2,32(r2)
 3237868:	10800a17 	ldw	r2,40(r2)
 323786c:	1885c83a 	sub	r2,r3,r2
 3237870:	1004803a 	cmplt	r2,r2,zero
 3237874:	10000b1e 	bne	r2,zero,32378a4 <tcp_respond+0x8c>
 3237878:	e0bffb17 	ldw	r2,-20(fp)
 323787c:	10800d17 	ldw	r2,52(r2)
 3237880:	10800817 	ldw	r2,32(r2)
 3237884:	10c00b17 	ldw	r3,44(r2)
 3237888:	e0bffb17 	ldw	r2,-20(fp)
 323788c:	10800d17 	ldw	r2,52(r2)
 3237890:	10800817 	ldw	r2,32(r2)
 3237894:	10800a17 	ldw	r2,40(r2)
 3237898:	1885c83a 	sub	r2,r3,r2
 323789c:	e0bfff15 	stw	r2,-4(fp)
 32378a0:	00000106 	br	32378a8 <tcp_respond+0x90>
 32378a4:	e03fff15 	stw	zero,-4(fp)
 32378a8:	e0bfff17 	ldw	r2,-4(fp)
 32378ac:	e0bff815 	stw	r2,-32(fp)

   /* Figure out of we can recycle the passed buffer or if we need a 
    * new one. Construct the easy parts of the the TCP and IP headers.
    */
   if (flags == 0)   /* sending keepalive from timer */
 32378b0:	e0800217 	ldw	r2,8(fp)
 32378b4:	1004c03a 	cmpne	r2,r2,zero
 32378b8:	1000391e 	bne	r2,zero,32379a0 <tcp_respond+0x188>
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
 32378bc:	010000c4 	movi	r4,3
 32378c0:	01401004 	movi	r5,64
 32378c4:	322b98c0 	call	322b98c <m_getnbuf>
 32378c8:	e0bff715 	stw	r2,-36(fp)
      if (m == NULL)
 32378cc:	e0bff717 	ldw	r2,-36(fp)
 32378d0:	1005003a 	cmpeq	r2,r2,zero
 32378d4:	1000ed1e 	bne	r2,zero,3237c8c <tcp_respond+0x474>
         return;
      tlen = 1;   /* Keepalives have one byte of data */
 32378d8:	00800044 	movi	r2,1
 32378dc:	e0bffa15 	stw	r2,-24(fp)
      m->m_len = TCPIPHDRSZ + tlen;
 32378e0:	e0bffa17 	ldw	r2,-24(fp)
 32378e4:	10800a04 	addi	r2,r2,40
 32378e8:	1007883a 	mov	r3,r2
 32378ec:	e0bff717 	ldw	r2,-36(fp)
 32378f0:	10c00215 	stw	r3,8(r2)
      /*
       * Copy template contents into the mbuf and set ti to point
       * to the header structure in the mbuf.
       */
      tmp_thdr = (struct tcpiphdr *)((char *)m->m_data+sizeof(struct ip)
 32378f4:	e0bff717 	ldw	r2,-36(fp)
 32378f8:	10800317 	ldw	r2,12(r2)
 32378fc:	e0bff615 	stw	r2,-40(fp)
         - sizeof(struct ipovly));
      if ((char *)tmp_thdr < m->pkt->nb_buff)
 3237900:	e0bff717 	ldw	r2,-36(fp)
 3237904:	10800117 	ldw	r2,4(r2)
 3237908:	10c00117 	ldw	r3,4(r2)
 323790c:	e0bff617 	ldw	r2,-40(fp)
 3237910:	10c0032e 	bgeu	r2,r3,3237920 <tcp_respond+0x108>
      {
         panic("tcp_respond- packet ptr underflow\n");
 3237914:	0100c974 	movhi	r4,805
 3237918:	213d8204 	addi	r4,r4,-2552
 323791c:	3225df00 	call	3225df0 <panic>
      }
      MEMCPY(tmp_thdr, ti, sizeof(struct tcpiphdr));
 3237920:	e13ff617 	ldw	r4,-40(fp)
 3237924:	e0fffc17 	ldw	r3,-16(fp)
 3237928:	18800017 	ldw	r2,0(r3)
 323792c:	20800015 	stw	r2,0(r4)
 3237930:	18800117 	ldw	r2,4(r3)
 3237934:	20800115 	stw	r2,4(r4)
 3237938:	18800217 	ldw	r2,8(r3)
 323793c:	20800215 	stw	r2,8(r4)
 3237940:	18800317 	ldw	r2,12(r3)
 3237944:	20800315 	stw	r2,12(r4)
 3237948:	18800417 	ldw	r2,16(r3)
 323794c:	20800415 	stw	r2,16(r4)
 3237950:	18800517 	ldw	r2,20(r3)
 3237954:	20800515 	stw	r2,20(r4)
 3237958:	18800617 	ldw	r2,24(r3)
 323795c:	20800615 	stw	r2,24(r4)
 3237960:	18800717 	ldw	r2,28(r3)
 3237964:	20800715 	stw	r2,28(r4)
 3237968:	18800817 	ldw	r2,32(r3)
 323796c:	20800815 	stw	r2,32(r4)
 3237970:	18800917 	ldw	r2,36(r3)
 3237974:	20800915 	stw	r2,36(r4)
      ti = tmp_thdr;
 3237978:	e0bff617 	ldw	r2,-40(fp)
 323797c:	e0bffc15 	stw	r2,-16(fp)
      flags = TH_ACK;
 3237980:	00800404 	movi	r2,16
 3237984:	e0800215 	stw	r2,8(fp)
      domain = tp->t_inpcb->inp_socket->so_domain;
 3237988:	e0bffb17 	ldw	r2,-20(fp)
 323798c:	10800d17 	ldw	r2,52(r2)
 3237990:	10800817 	ldw	r2,32(r2)
 3237994:	10800517 	ldw	r2,20(r2)
 3237998:	e0bff915 	stw	r2,-28(fp)
 323799c:	00003b06 	br	3237a8c <tcp_respond+0x274>
   }
   else  /* Flag was passed (e.g. reset); recycle passed mbuf */
   {
      m = ti_mbuf;   /*dtom(ti);*/
 32379a0:	e0800317 	ldw	r2,12(fp)
 32379a4:	e0bff715 	stw	r2,-36(fp)
      if(m->pkt->type == IPTP)   /* IPv4 packet */
 32379a8:	e0bff717 	ldw	r2,-36(fp)
 32379ac:	10800117 	ldw	r2,4(r2)
 32379b0:	1080080b 	ldhu	r2,32(r2)
 32379b4:	10bfffcc 	andi	r2,r2,65535
 32379b8:	10800218 	cmpnei	r2,r2,8
 32379bc:	1000031e 	bne	r2,zero,32379cc <tcp_respond+0x1b4>
         domain = AF_INET;
 32379c0:	00800084 	movi	r2,2
 32379c4:	e0bff915 	stw	r2,-28(fp)
 32379c8:	00000206 	br	32379d4 <tcp_respond+0x1bc>
      else
         domain = AF_INET6;
 32379cc:	008000c4 	movi	r2,3
 32379d0:	e0bff915 	stw	r2,-28(fp)

      m_freem(m->m_next);
 32379d4:	e0bff717 	ldw	r2,-36(fp)
 32379d8:	11000617 	ldw	r4,24(r2)
 32379dc:	322bc680 	call	322bc68 <m_freem>
      m->m_next = 0;
 32379e0:	e0bff717 	ldw	r2,-36(fp)
 32379e4:	10000615 	stw	zero,24(r2)
      tlen = 0;         /* NO data */
 32379e8:	e03ffa15 	stw	zero,-24(fp)
      m->m_len = TCPIPHDRSZ;
 32379ec:	e0fff717 	ldw	r3,-36(fp)
 32379f0:	00800a04 	movi	r2,40
 32379f4:	18800215 	stw	r2,8(r3)
      xchg(ti->ti_dport, ti->ti_sport, u_short);
 32379f8:	e0bffc17 	ldw	r2,-16(fp)
 32379fc:	1080058b 	ldhu	r2,22(r2)
 3237a00:	e0bff50d 	sth	r2,-44(fp)
 3237a04:	e0bffc17 	ldw	r2,-16(fp)
 3237a08:	10c0050b 	ldhu	r3,20(r2)
 3237a0c:	e0bffc17 	ldw	r2,-16(fp)
 3237a10:	10c0058d 	sth	r3,22(r2)
 3237a14:	e0fffc17 	ldw	r3,-16(fp)
 3237a18:	e0bff50b 	ldhu	r2,-44(fp)
 3237a1c:	1880050d 	sth	r2,20(r3)
      if(m->pkt->type == IPTP)
 3237a20:	e0bff717 	ldw	r2,-36(fp)
 3237a24:	10800117 	ldw	r2,4(r2)
 3237a28:	1080080b 	ldhu	r2,32(r2)
 3237a2c:	10bfffcc 	andi	r2,r2,65535
 3237a30:	10800218 	cmpnei	r2,r2,8
 3237a34:	10000a1e 	bne	r2,zero,3237a60 <tcp_respond+0x248>
         xchg(ti->ti_dst.s_addr, ti->ti_src.s_addr, u_long);
 3237a38:	e0bffc17 	ldw	r2,-16(fp)
 3237a3c:	10800417 	ldw	r2,16(r2)
 3237a40:	e0bff415 	stw	r2,-48(fp)
 3237a44:	e0bffc17 	ldw	r2,-16(fp)
 3237a48:	10c00317 	ldw	r3,12(r2)
 3237a4c:	e0bffc17 	ldw	r2,-16(fp)
 3237a50:	10c00415 	stw	r3,16(r2)
 3237a54:	e0fffc17 	ldw	r3,-16(fp)
 3237a58:	e0bff417 	ldw	r2,-48(fp)
 3237a5c:	18800315 	stw	r2,12(r3)
      if (flags & TH_RST)  /* count resets in MIB */
 3237a60:	e0800217 	ldw	r2,8(fp)
 3237a64:	1080010c 	andi	r2,r2,4
 3237a68:	1005003a 	cmpeq	r2,r2,zero
 3237a6c:	1000071e 	bne	r2,zero,3237a8c <tcp_respond+0x274>
         TCP_MIB_INC(tcpOutRsts);   /* keep MIB stats */
 3237a70:	0080c9b4 	movhi	r2,806
 3237a74:	10b39c04 	addi	r2,r2,-12688
 3237a78:	10800e17 	ldw	r2,56(r2)
 3237a7c:	10c00044 	addi	r3,r2,1
 3237a80:	0080c9b4 	movhi	r2,806
 3237a84:	10b39c04 	addi	r2,r2,-12688
 3237a88:	10c00e15 	stw	r3,56(r2)
   }

   /* finish constructing the TCP header */
   ti->ti_seq = htonl(seq);
 3237a8c:	e0bffe17 	ldw	r2,-8(fp)
 3237a90:	1004d63a 	srli	r2,r2,24
 3237a94:	10c03fcc 	andi	r3,r2,255
 3237a98:	e0bffe17 	ldw	r2,-8(fp)
 3237a9c:	1004d23a 	srli	r2,r2,8
 3237aa0:	10bfc00c 	andi	r2,r2,65280
 3237aa4:	1886b03a 	or	r3,r3,r2
 3237aa8:	e0bffe17 	ldw	r2,-8(fp)
 3237aac:	10bfc00c 	andi	r2,r2,65280
 3237ab0:	1004923a 	slli	r2,r2,8
 3237ab4:	1886b03a 	or	r3,r3,r2
 3237ab8:	e0bffe17 	ldw	r2,-8(fp)
 3237abc:	10803fcc 	andi	r2,r2,255
 3237ac0:	1004963a 	slli	r2,r2,24
 3237ac4:	1886b03a 	or	r3,r3,r2
 3237ac8:	e0bffc17 	ldw	r2,-16(fp)
 3237acc:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(ack);
 3237ad0:	e0bffd17 	ldw	r2,-12(fp)
 3237ad4:	1004d63a 	srli	r2,r2,24
 3237ad8:	10c03fcc 	andi	r3,r2,255
 3237adc:	e0bffd17 	ldw	r2,-12(fp)
 3237ae0:	1004d23a 	srli	r2,r2,8
 3237ae4:	10bfc00c 	andi	r2,r2,65280
 3237ae8:	1886b03a 	or	r3,r3,r2
 3237aec:	e0bffd17 	ldw	r2,-12(fp)
 3237af0:	10bfc00c 	andi	r2,r2,65280
 3237af4:	1004923a 	slli	r2,r2,8
 3237af8:	1886b03a 	or	r3,r3,r2
 3237afc:	e0bffd17 	ldw	r2,-12(fp)
 3237b00:	10803fcc 	andi	r2,r2,255
 3237b04:	1004963a 	slli	r2,r2,24
 3237b08:	1886b03a 	or	r3,r3,r2
 3237b0c:	e0bffc17 	ldw	r2,-16(fp)
 3237b10:	10c00715 	stw	r3,28(r2)
   ti->ti_t.th_doff = 0x50;      /* NetPort: init data offset bits */
 3237b14:	e0fffc17 	ldw	r3,-16(fp)
 3237b18:	00801404 	movi	r2,80
 3237b1c:	18800805 	stb	r2,32(r3)
   ti->ti_flags = (u_char)flags;
 3237b20:	e0800217 	ldw	r2,8(fp)
 3237b24:	1007883a 	mov	r3,r2
 3237b28:	e0bffc17 	ldw	r2,-16(fp)
 3237b2c:	10c00845 	stb	r3,33(r2)
   ti->ti_win = htons((u_short)win);
 3237b30:	e0bff817 	ldw	r2,-32(fp)
 3237b34:	10bfffcc 	andi	r2,r2,65535
 3237b38:	1004d23a 	srli	r2,r2,8
 3237b3c:	10803fcc 	andi	r2,r2,255
 3237b40:	1009883a 	mov	r4,r2
 3237b44:	e0bff817 	ldw	r2,-32(fp)
 3237b48:	10bfffcc 	andi	r2,r2,65535
 3237b4c:	1004923a 	slli	r2,r2,8
 3237b50:	1007883a 	mov	r3,r2
 3237b54:	00bfc004 	movi	r2,-256
 3237b58:	1884703a 	and	r2,r3,r2
 3237b5c:	2084b03a 	or	r2,r4,r2
 3237b60:	1007883a 	mov	r3,r2
 3237b64:	e0bffc17 	ldw	r2,-16(fp)
 3237b68:	10c0088d 	sth	r3,34(r2)
   ti->ti_urp = 0;
 3237b6c:	e0bffc17 	ldw	r2,-16(fp)
 3237b70:	1000098d 	sth	zero,38(r2)

   /* Finish constructing IP header and send, based on IP type in use */
   switch(domain)
 3237b74:	e0bff917 	ldw	r2,-28(fp)
 3237b78:	108000a0 	cmpeqi	r2,r2,2
 3237b7c:	1000011e 	bne	r2,zero,3237b84 <tcp_respond+0x36c>
 3237b80:	00004106 	br	3237c88 <tcp_respond+0x470>
#ifdef IP_V4
      case AF_INET:
      {
         struct ip * pip;

         pip = (struct ip *)((char*)ti+sizeof(struct ipovly)-sizeof(struct ip));
 3237b84:	e0bffc17 	ldw	r2,-16(fp)
 3237b88:	e0bff315 	stw	r2,-52(fp)

         pip->ip_len = (unshort)(TCPIPHDRSZ + tlen);
 3237b8c:	e0bffa17 	ldw	r2,-24(fp)
 3237b90:	10800a04 	addi	r2,r2,40
 3237b94:	1007883a 	mov	r3,r2
 3237b98:	e0bff317 	ldw	r2,-52(fp)
 3237b9c:	10c0008d 	sth	r3,2(r2)
         /* If our system's max. MAC header size is geater than the size 
          * of the MAC header in the received packet then we need to 
          * adjust the IP header offset to allow for this. Since the packets 
          * are only headers they should always fit.
          */
         if(pip >= (struct ip *)(m->pkt->nb_buff + MaxLnh))
 3237ba0:	e0bff717 	ldw	r2,-36(fp)
 3237ba4:	10800117 	ldw	r2,4(r2)
 3237ba8:	10c00117 	ldw	r3,4(r2)
 3237bac:	0080c974 	movhi	r2,805
 3237bb0:	10922f04 	addi	r2,r2,18620
 3237bb4:	10800017 	ldw	r2,0(r2)
 3237bb8:	1885883a 	add	r2,r3,r2
 3237bbc:	1007883a 	mov	r3,r2
 3237bc0:	e0bff317 	ldw	r2,-52(fp)
 3237bc4:	10c00436 	bltu	r2,r3,3237bd8 <tcp_respond+0x3c0>
         {
            m->m_data = (char*)pip; /* headers will fit, just set pointer */
 3237bc8:	e0fff317 	ldw	r3,-52(fp)
 3237bcc:	e0bff717 	ldw	r2,-36(fp)
 3237bd0:	10c00315 	stw	r3,12(r2)
 3237bd4:	00001206 	br	3237c20 <tcp_respond+0x408>
         }
         else     /* MAC may not fit, adjust pointer and move headers back */
         {
            m->m_data = m->pkt->nb_prot = m->pkt->nb_buff + MaxLnh;  /* new ptr */
 3237bd8:	e0bff717 	ldw	r2,-36(fp)
 3237bdc:	11000117 	ldw	r4,4(r2)
 3237be0:	e0bff717 	ldw	r2,-36(fp)
 3237be4:	10800117 	ldw	r2,4(r2)
 3237be8:	10c00117 	ldw	r3,4(r2)
 3237bec:	0080c974 	movhi	r2,805
 3237bf0:	10922f04 	addi	r2,r2,18620
 3237bf4:	10800017 	ldw	r2,0(r2)
 3237bf8:	1885883a 	add	r2,r3,r2
 3237bfc:	20800315 	stw	r2,12(r4)
 3237c00:	20c00317 	ldw	r3,12(r4)
 3237c04:	e0bff717 	ldw	r2,-36(fp)
 3237c08:	10c00315 	stw	r3,12(r2)
            MEMMOVE(m->m_data, pip, TCPIPHDRSZ);  /* move back tcp/ip headers */
 3237c0c:	e0bff717 	ldw	r2,-36(fp)
 3237c10:	11000317 	ldw	r4,12(r2)
 3237c14:	e17ff317 	ldw	r5,-52(fp)
 3237c18:	01800a04 	movi	r6,40
 3237c1c:	320686c0 	call	320686c <memmove>

         /*
          * In the case of a SYN DOS attack, many RST|ACK replies
          *   have no tp structure and need to be freed.
          */
         if (!tp)
 3237c20:	e0bffb17 	ldw	r2,-20(fp)
 3237c24:	1004c03a 	cmpne	r2,r2,zero
 3237c28:	1000031e 	bne	r2,zero,3237c38 <tcp_respond+0x420>
              m_freem(m);
 3237c2c:	e13ff717 	ldw	r4,-36(fp)
 3237c30:	322bc680 	call	322bc68 <m_freem>
 3237c34:	00001506 	br	3237c8c <tcp_respond+0x474>
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 3237c38:	e0bffb17 	ldw	r2,-20(fp)
 3237c3c:	10800d17 	ldw	r2,52(r2)
 3237c40:	1005003a 	cmpeq	r2,r2,zero
 3237c44:	10000c1e 	bne	r2,zero,3237c78 <tcp_respond+0x460>
 3237c48:	e0bffb17 	ldw	r2,-20(fp)
 3237c4c:	10800d17 	ldw	r2,52(r2)
 3237c50:	10800817 	ldw	r2,32(r2)
 3237c54:	1005003a 	cmpeq	r2,r2,zero
 3237c58:	1000071e 	bne	r2,zero,3237c78 <tcp_respond+0x460>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
 3237c5c:	e0bffb17 	ldw	r2,-20(fp)
 3237c60:	10800d17 	ldw	r2,52(r2)
 3237c64:	10800817 	ldw	r2,32(r2)
 3237c68:	11401f17 	ldw	r5,124(r2)
 3237c6c:	e13ff717 	ldw	r4,-36(fp)
 3237c70:	322c69c0 	call	322c69c <ip_output>
          */
         if (!tp)
              m_freem(m);
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 3237c74:	00000506 	br	3237c8c <tcp_respond+0x474>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
 3237c78:	e13ff717 	ldw	r4,-36(fp)
 3237c7c:	000b883a 	mov	r5,zero
 3237c80:	322c69c0 	call	322c69c <ip_output>
		 }

         break;
 3237c84:	00000106 	br	3237c8c <tcp_respond+0x474>

         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();
 3237c88:	322ab8c0 	call	322ab8c <dtrap>
         break;
   }
   return;
}
 3237c8c:	e037883a 	mov	sp,fp
 3237c90:	dfc00117 	ldw	ra,4(sp)
 3237c94:	df000017 	ldw	fp,0(sp)
 3237c98:	dec00204 	addi	sp,sp,8
 3237c9c:	f800283a 	ret

03237ca0 <tcp_newtcpcb>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_newtcpcb(struct inpcb * inp)
{
 3237ca0:	defffa04 	addi	sp,sp,-24
 3237ca4:	dfc00515 	stw	ra,20(sp)
 3237ca8:	df000415 	stw	fp,16(sp)
 3237cac:	df000404 	addi	fp,sp,16
 3237cb0:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
   short t_time;

   tp = TCB_ALLOC(sizeof (*tp));
 3237cb4:	01002504 	movi	r4,148
 3237cb8:	322b5d00 	call	322b5d0 <npalloc>
 3237cbc:	e0bffd15 	stw	r2,-12(fp)
   if (tp == NULL)
 3237cc0:	e0bffd17 	ldw	r2,-12(fp)
 3237cc4:	1004c03a 	cmpne	r2,r2,zero
 3237cc8:	1000021e 	bne	r2,zero,3237cd4 <tcp_newtcpcb+0x34>
      return (struct tcpcb *)NULL;
 3237ccc:	e03fff15 	stw	zero,-4(fp)
 3237cd0:	00003306 	br	3237da0 <tcp_newtcpcb+0x100>
   tp->seg_next = tp->seg_prev = (struct tcpiphdr *)tp;
 3237cd4:	e0fffd17 	ldw	r3,-12(fp)
 3237cd8:	e0bffd17 	ldw	r2,-12(fp)
 3237cdc:	10c00115 	stw	r3,4(r2)
 3237ce0:	e0bffd17 	ldw	r2,-12(fp)
 3237ce4:	10c00117 	ldw	r3,4(r2)
 3237ce8:	e0bffd17 	ldw	r2,-12(fp)
 3237cec:	10c00015 	stw	r3,0(r2)
   tp->t_maxseg = TCP_MSS;
 3237cf0:	e0fffd17 	ldw	r3,-12(fp)
 3237cf4:	00816d04 	movi	r2,1460
 3237cf8:	18800a0d 	sth	r2,40(r3)
   tp->t_flags = 0;        /* sends options! */
 3237cfc:	e0bffd17 	ldw	r2,-12(fp)
 3237d00:	10000b0d 	sth	zero,44(r2)
   tp->t_inpcb = inp;
 3237d04:	e0fffd17 	ldw	r3,-12(fp)
 3237d08:	e0bffe17 	ldw	r2,-8(fp)
 3237d0c:	18800d15 	stw	r2,52(r3)
   /*
    * Init srtt to TCPTV_SRTTBASE (0), so we can tell that we have no
    * rtt estimate.  Set rttvar so that srtt + 2 * rttvar gives
    * reasonable initial retransmit time.
    */
   tp->t_srtt = TCPTV_SRTTBASE;
 3237d10:	e0bffd17 	ldw	r2,-12(fp)
 3237d14:	10002015 	stw	zero,128(r2)
   tp->t_rttvar = TCPTV_SRTTDFLT << 2;
 3237d18:	e0fffd17 	ldw	r3,-12(fp)
 3237d1c:	00800604 	movi	r2,24
 3237d20:	18802115 	stw	r2,132(r3)

   t_time = ((TCPTV_SRTTBASE >> 2) + (TCPTV_SRTTDFLT << 2)) >> 1;
 3237d24:	00800304 	movi	r2,12
 3237d28:	e0bffc0d 	sth	r2,-16(fp)
   TCPT_RANGESET(tp->t_rxtcur, t_time, TCPTV_MIN, TCPTV_REXMTMAX);
 3237d2c:	e0fffc0f 	ldh	r3,-16(fp)
 3237d30:	e0bffd17 	ldw	r2,-12(fp)
 3237d34:	10c00815 	stw	r3,32(r2)
 3237d38:	e0bffd17 	ldw	r2,-12(fp)
 3237d3c:	10800817 	ldw	r2,32(r2)
 3237d40:	10800088 	cmpgei	r2,r2,2
 3237d44:	1000041e 	bne	r2,zero,3237d58 <tcp_newtcpcb+0xb8>
 3237d48:	e0fffd17 	ldw	r3,-12(fp)
 3237d4c:	00800084 	movi	r2,2
 3237d50:	18800815 	stw	r2,32(r3)
 3237d54:	00000706 	br	3237d74 <tcp_newtcpcb+0xd4>
 3237d58:	e0bffd17 	ldw	r2,-12(fp)
 3237d5c:	10800817 	ldw	r2,32(r2)
 3237d60:	10802050 	cmplti	r2,r2,129
 3237d64:	1000031e 	bne	r2,zero,3237d74 <tcp_newtcpcb+0xd4>
 3237d68:	e0fffd17 	ldw	r3,-12(fp)
 3237d6c:	00802004 	movi	r2,128
 3237d70:	18800815 	stw	r2,32(r3)

   /* Set initial congestion window - RFC-2581, pg 4. */
   tp->snd_cwnd = 2 * TCP_MSS;
 3237d74:	e0fffd17 	ldw	r3,-12(fp)
 3237d78:	0082da04 	movi	r2,2920
 3237d7c:	18801b15 	stw	r2,108(r3)

#ifdef DO_DELAY_ACKS
   tp->t_delacktime = 1;
#endif   /* DO_DELAY_ACKS */

   tp->snd_ssthresh = 65535;  /* Start with high slow-start threshold */
 3237d80:	e0fffd17 	ldw	r3,-12(fp)
 3237d84:	00bfffd4 	movui	r2,65535
 3237d88:	18801c15 	stw	r2,112(r3)

   inp->inp_ppcb = (char *)tp;
 3237d8c:	e0fffd17 	ldw	r3,-12(fp)
 3237d90:	e0bffe17 	ldw	r2,-8(fp)
 3237d94:	10c00915 	stw	r3,36(r2)
   return (tp);
 3237d98:	e0bffd17 	ldw	r2,-12(fp)
 3237d9c:	e0bfff15 	stw	r2,-4(fp)
 3237da0:	e0bfff17 	ldw	r2,-4(fp)
}
 3237da4:	e037883a 	mov	sp,fp
 3237da8:	dfc00117 	ldw	ra,4(sp)
 3237dac:	df000017 	ldw	fp,0(sp)
 3237db0:	dec00204 	addi	sp,sp,8
 3237db4:	f800283a 	ret

03237db8 <tcp_drop>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_drop(struct tcpcb * tp, int err)
{
 3237db8:	defffb04 	addi	sp,sp,-20
 3237dbc:	dfc00415 	stw	ra,16(sp)
 3237dc0:	df000315 	stw	fp,12(sp)
 3237dc4:	df000304 	addi	fp,sp,12
 3237dc8:	e13ffe15 	stw	r4,-8(fp)
 3237dcc:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 3237dd0:	e0bffe17 	ldw	r2,-8(fp)
 3237dd4:	10800d17 	ldw	r2,52(r2)
 3237dd8:	10800817 	ldw	r2,32(r2)
 3237ddc:	e0bffd15 	stw	r2,-12(fp)

   if (TCPS_HAVERCVDSYN(tp->t_state)) 
 3237de0:	e0bffe17 	ldw	r2,-8(fp)
 3237de4:	10800217 	ldw	r2,8(r2)
 3237de8:	108000d0 	cmplti	r2,r2,3
 3237dec:	10000c1e 	bne	r2,zero,3237e20 <tcp_drop+0x68>
   {
      tp->t_state = TCPS_CLOSED;
 3237df0:	e0bffe17 	ldw	r2,-8(fp)
 3237df4:	10000215 	stw	zero,8(r2)
      (void) tcp_output(tp);
 3237df8:	e13ffe17 	ldw	r4,-8(fp)
 3237dfc:	32363480 	call	3236348 <tcp_output>
      tcpstat.tcps_drops++;
 3237e00:	0080c9b4 	movhi	r2,806
 3237e04:	10b3ca04 	addi	r2,r2,-12504
 3237e08:	10800317 	ldw	r2,12(r2)
 3237e0c:	10c00044 	addi	r3,r2,1
 3237e10:	0080c9b4 	movhi	r2,806
 3237e14:	10b3ca04 	addi	r2,r2,-12504
 3237e18:	10c00315 	stw	r3,12(r2)
 3237e1c:	00000706 	br	3237e3c <tcp_drop+0x84>
   }
   else
      tcpstat.tcps_conndrops++;
 3237e20:	0080c9b4 	movhi	r2,806
 3237e24:	10b3ca04 	addi	r2,r2,-12504
 3237e28:	10800417 	ldw	r2,16(r2)
 3237e2c:	10c00044 	addi	r3,r2,1
 3237e30:	0080c9b4 	movhi	r2,806
 3237e34:	10b3ca04 	addi	r2,r2,-12504
 3237e38:	10c00415 	stw	r3,16(r2)
   so->so_error = err;
 3237e3c:	e0fffd17 	ldw	r3,-12(fp)
 3237e40:	e0bfff17 	ldw	r2,-4(fp)
 3237e44:	18800615 	stw	r2,24(r3)
#ifdef TCP_ZEROCOPY
   if (so->rx_upcall)
      so->rx_upcall(so, NULL, err);
#endif   /* TCP_ZEROCOPY */
   return (tcp_close(tp));
 3237e48:	e13ffe17 	ldw	r4,-8(fp)
 3237e4c:	3237e640 	call	3237e64 <tcp_close>
}
 3237e50:	e037883a 	mov	sp,fp
 3237e54:	dfc00117 	ldw	ra,4(sp)
 3237e58:	df000017 	ldw	fp,0(sp)
 3237e5c:	dec00204 	addi	sp,sp,8
 3237e60:	f800283a 	ret

03237e64 <tcp_close>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_close(struct tcpcb * tp)
{
 3237e64:	defff904 	addi	sp,sp,-28
 3237e68:	dfc00615 	stw	ra,24(sp)
 3237e6c:	df000515 	stw	fp,20(sp)
 3237e70:	df000504 	addi	fp,sp,20
 3237e74:	e13fff15 	stw	r4,-4(fp)
   struct tcpiphdr * t;
   struct inpcb * inp   =  tp->t_inpcb;
 3237e78:	e0bfff17 	ldw	r2,-4(fp)
 3237e7c:	10800d17 	ldw	r2,52(r2)
 3237e80:	e0bffd15 	stw	r2,-12(fp)
   struct socket *   so =  inp->inp_socket;
 3237e84:	e0bffd17 	ldw	r2,-12(fp)
 3237e88:	10800817 	ldw	r2,32(r2)
 3237e8c:	e0bffc15 	stw	r2,-16(fp)
   struct mbuf *  m;

   t = tp->seg_next;
 3237e90:	e0bfff17 	ldw	r2,-4(fp)
 3237e94:	10800017 	ldw	r2,0(r2)
 3237e98:	e0bffe15 	stw	r2,-8(fp)
   while (t != (struct tcpiphdr *)tp) 
 3237e9c:	00000c06 	br	3237ed0 <tcp_close+0x6c>
   {
      t = (struct tcpiphdr *)t->ti_next;
 3237ea0:	e0bffe17 	ldw	r2,-8(fp)
 3237ea4:	10800017 	ldw	r2,0(r2)
 3237ea8:	e0bffe15 	stw	r2,-8(fp)
      m = dtom(t->ti_prev);
 3237eac:	e0bffe17 	ldw	r2,-8(fp)
 3237eb0:	11000117 	ldw	r4,4(r2)
 3237eb4:	322c1f80 	call	322c1f8 <dtom>
 3237eb8:	e0bffb15 	stw	r2,-20(fp)
      remque(t->ti_prev);
 3237ebc:	e0bffe17 	ldw	r2,-8(fp)
 3237ec0:	11000117 	ldw	r4,4(r2)
 3237ec4:	322c2a00 	call	322c2a0 <remque>
      m_freem (m);
 3237ec8:	e13ffb17 	ldw	r4,-20(fp)
 3237ecc:	322bc680 	call	322bc68 <m_freem>
   struct inpcb * inp   =  tp->t_inpcb;
   struct socket *   so =  inp->inp_socket;
   struct mbuf *  m;

   t = tp->seg_next;
   while (t != (struct tcpiphdr *)tp) 
 3237ed0:	e0ffff17 	ldw	r3,-4(fp)
 3237ed4:	e0bffe17 	ldw	r2,-8(fp)
 3237ed8:	10fff11e 	bne	r2,r3,3237ea0 <tcp_close+0x3c>
      t = (struct tcpiphdr *)t->ti_next;
      m = dtom(t->ti_prev);
      remque(t->ti_prev);
      m_freem (m);
   }
   if (tp->t_template)
 3237edc:	e0bfff17 	ldw	r2,-4(fp)
 3237ee0:	10800c17 	ldw	r2,48(r2)
 3237ee4:	1005003a 	cmpeq	r2,r2,zero
 3237ee8:	1000031e 	bne	r2,zero,3237ef8 <tcp_close+0x94>
      TPH_FREE (tp->t_template);
 3237eec:	e0bfff17 	ldw	r2,-4(fp)
 3237ef0:	11000c17 	ldw	r4,48(r2)
 3237ef4:	322b6c40 	call	322b6c4 <npfree>
   TCB_FREE (tp);
 3237ef8:	e13fff17 	ldw	r4,-4(fp)
 3237efc:	322b6c40 	call	322b6c4 <npfree>
   inp->inp_ppcb = 0;
 3237f00:	e0bffd17 	ldw	r2,-12(fp)
 3237f04:	10000915 	stw	zero,36(r2)
   soisdisconnected(so);
 3237f08:	e13ffc17 	ldw	r4,-16(fp)
 3237f0c:	32319280 	call	3231928 <soisdisconnected>
   in_pcbdetach(inp);
 3237f10:	e13ffd17 	ldw	r4,-12(fp)
 3237f14:	3247f140 	call	3247f14 <in_pcbdetach>
   tcpstat.tcps_closed++;
 3237f18:	0080c9b4 	movhi	r2,806
 3237f1c:	10b3ca04 	addi	r2,r2,-12504
 3237f20:	10800517 	ldw	r2,20(r2)
 3237f24:	10c00044 	addi	r3,r2,1
 3237f28:	0080c9b4 	movhi	r2,806
 3237f2c:	10b3ca04 	addi	r2,r2,-12504
 3237f30:	10c00515 	stw	r3,20(r2)
   return ((struct tcpcb *)0);
 3237f34:	0005883a 	mov	r2,zero
}
 3237f38:	e037883a 	mov	sp,fp
 3237f3c:	dfc00117 	ldw	ra,4(sp)
 3237f40:	df000017 	ldw	fp,0(sp)
 3237f44:	dec00204 	addi	sp,sp,8
 3237f48:	f800283a 	ret

03237f4c <tcp_quench>:
 * RETURNS: 
 */

void
tcp_quench(struct inpcb * inp)
{
 3237f4c:	defffd04 	addi	sp,sp,-12
 3237f50:	df000215 	stw	fp,8(sp)
 3237f54:	df000204 	addi	fp,sp,8
 3237f58:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp =  intotcpcb(inp);
 3237f5c:	e0bfff17 	ldw	r2,-4(fp)
 3237f60:	10800917 	ldw	r2,36(r2)
 3237f64:	e0bffe15 	stw	r2,-8(fp)

   if (tp)
 3237f68:	e0bffe17 	ldw	r2,-8(fp)
 3237f6c:	1005003a 	cmpeq	r2,r2,zero
 3237f70:	1000051e 	bne	r2,zero,3237f88 <tcp_quench+0x3c>
      tp->snd_cwnd = tp->t_maxseg;
 3237f74:	e0bffe17 	ldw	r2,-8(fp)
 3237f78:	10800a0b 	ldhu	r2,40(r2)
 3237f7c:	10ffffcc 	andi	r3,r2,65535
 3237f80:	e0bffe17 	ldw	r2,-8(fp)
 3237f84:	10c01b15 	stw	r3,108(r2)
}
 3237f88:	e037883a 	mov	sp,fp
 3237f8c:	df000017 	ldw	fp,0(sp)
 3237f90:	dec00104 	addi	sp,sp,4
 3237f94:	f800283a 	ret

03237f98 <tcp_putseq>:

/* tcp_putseq()  */

u_char *
tcp_putseq(u_char * cp, tcp_seq seq)
{
 3237f98:	defffc04 	addi	sp,sp,-16
 3237f9c:	df000315 	stw	fp,12(sp)
 3237fa0:	df000304 	addi	fp,sp,12
 3237fa4:	e13ffe15 	stw	r4,-8(fp)
 3237fa8:	e17fff15 	stw	r5,-4(fp)
   int   i;

   cp += 3;                /* do low byte first */
 3237fac:	e0bffe17 	ldw	r2,-8(fp)
 3237fb0:	108000c4 	addi	r2,r2,3
 3237fb4:	e0bffe15 	stw	r2,-8(fp)
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 3237fb8:	e03ffd15 	stw	zero,-12(fp)
 3237fbc:	00000d06 	br	3237ff4 <tcp_putseq+0x5c>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
 3237fc0:	e0bfff17 	ldw	r2,-4(fp)
 3237fc4:	1007883a 	mov	r3,r2
 3237fc8:	e0bffe17 	ldw	r2,-8(fp)
 3237fcc:	10c00005 	stb	r3,0(r2)
 3237fd0:	e0bffe17 	ldw	r2,-8(fp)
 3237fd4:	10bfffc4 	addi	r2,r2,-1
 3237fd8:	e0bffe15 	stw	r2,-8(fp)
      seq >>= 8;
 3237fdc:	e0bfff17 	ldw	r2,-4(fp)
 3237fe0:	1004d23a 	srli	r2,r2,8
 3237fe4:	e0bfff15 	stw	r2,-4(fp)
tcp_putseq(u_char * cp, tcp_seq seq)
{
   int   i;

   cp += 3;                /* do low byte first */
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 3237fe8:	e0bffd17 	ldw	r2,-12(fp)
 3237fec:	10800044 	addi	r2,r2,1
 3237ff0:	e0bffd15 	stw	r2,-12(fp)
 3237ff4:	e0bffd17 	ldw	r2,-12(fp)
 3237ff8:	10800110 	cmplti	r2,r2,4
 3237ffc:	103ff01e 	bne	r2,zero,3237fc0 <tcp_putseq+0x28>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
      seq >>= 8;
   }
   return (cp + 5);
 3238000:	e0bffe17 	ldw	r2,-8(fp)
 3238004:	10800144 	addi	r2,r2,5
}
 3238008:	e037883a 	mov	sp,fp
 323800c:	df000017 	ldw	fp,0(sp)
 3238010:	dec00104 	addi	sp,sp,4
 3238014:	f800283a 	ret

03238018 <tcp_getseq>:
 * RETURNS: a long in local endian
 */

u_long
tcp_getseq(u_char * cp)
{
 3238018:	defffc04 	addi	sp,sp,-16
 323801c:	df000315 	stw	fp,12(sp)
 3238020:	df000304 	addi	fp,sp,12
 3238024:	e13fff15 	stw	r4,-4(fp)
   int i;
   ulong seq = 0;
 3238028:	e03ffd15 	stw	zero,-12(fp)

   for(i = 0; i < 4; i++)
 323802c:	e03ffe15 	stw	zero,-8(fp)
 3238030:	00000f06 	br	3238070 <tcp_getseq+0x58>
   {
      seq <<= 8;
 3238034:	e0bffd17 	ldw	r2,-12(fp)
 3238038:	1004923a 	slli	r2,r2,8
 323803c:	e0bffd15 	stw	r2,-12(fp)
      seq += (u_long)*(cp++);
 3238040:	e0bfff17 	ldw	r2,-4(fp)
 3238044:	10800003 	ldbu	r2,0(r2)
 3238048:	10c03fcc 	andi	r3,r2,255
 323804c:	e0bffd17 	ldw	r2,-12(fp)
 3238050:	10c5883a 	add	r2,r2,r3
 3238054:	e0bffd15 	stw	r2,-12(fp)
 3238058:	e0bfff17 	ldw	r2,-4(fp)
 323805c:	10800044 	addi	r2,r2,1
 3238060:	e0bfff15 	stw	r2,-4(fp)
tcp_getseq(u_char * cp)
{
   int i;
   ulong seq = 0;

   for(i = 0; i < 4; i++)
 3238064:	e0bffe17 	ldw	r2,-8(fp)
 3238068:	10800044 	addi	r2,r2,1
 323806c:	e0bffe15 	stw	r2,-8(fp)
 3238070:	e0bffe17 	ldw	r2,-8(fp)
 3238074:	10800110 	cmplti	r2,r2,4
 3238078:	103fee1e 	bne	r2,zero,3238034 <tcp_getseq+0x1c>
   {
      seq <<= 8;
      seq += (u_long)*(cp++);
   }
   return seq;
 323807c:	e0bffd17 	ldw	r2,-12(fp)
}
 3238080:	e037883a 	mov	sp,fp
 3238084:	df000017 	ldw	fp,0(sp)
 3238088:	dec00104 	addi	sp,sp,4
 323808c:	f800283a 	ret

03238090 <tcp_slowtimo>:
 * RETURNS: 
 */

void
tcp_slowtimo(void)
{
 3238090:	defff704 	addi	sp,sp,-36
 3238094:	dfc00815 	stw	ra,32(sp)
 3238098:	df000715 	stw	fp,28(sp)
 323809c:	df000704 	addi	fp,sp,28
   struct tcpcb * tp;
   int   i;
   struct socket * so, * sonext;
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;
 32380a0:	d0a03b17 	ldw	r2,-32532(gp)
 32380a4:	100490fa 	slli	r2,r2,3
 32380a8:	d0a8eb15 	stw	r2,-23636(gp)

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 32380ac:	0080c9b4 	movhi	r2,806
 32380b0:	10b39704 	addi	r2,r2,-12708
 32380b4:	10800017 	ldw	r2,0(r2)
 32380b8:	e0bffb15 	stw	r2,-20(fp)
 32380bc:	00008306 	br	32382cc <tcp_slowtimo+0x23c>
   {
      sonext = so->next;
 32380c0:	e0bffb17 	ldw	r2,-20(fp)
 32380c4:	10800017 	ldw	r2,0(r2)
 32380c8:	e0bffa15 	stw	r2,-24(fp)

      /* for SOCK_STREAM (TCP) sockets, we must do slow-timeout 
       * processing and (optionally) processing of pending 
       * zero-copy socket upcalls.
       */
      if (so->so_type == SOCK_STREAM)
 32380cc:	e0bffb17 	ldw	r2,-20(fp)
 32380d0:	10800983 	ldbu	r2,38(r2)
 32380d4:	10803fcc 	andi	r2,r2,255
 32380d8:	1080201c 	xori	r2,r2,128
 32380dc:	10bfe004 	addi	r2,r2,-128
 32380e0:	10800058 	cmpnei	r2,r2,1
 32380e4:	1000471e 	bne	r2,zero,3238204 <tcp_slowtimo+0x174>
      {
         ip = so->so_pcb;
 32380e8:	e0bffb17 	ldw	r2,-20(fp)
 32380ec:	10800117 	ldw	r2,4(r2)
 32380f0:	e0bfff15 	stw	r2,-4(fp)
         if (!ip)
 32380f4:	e0bfff17 	ldw	r2,-4(fp)
 32380f8:	1005003a 	cmpeq	r2,r2,zero
 32380fc:	1000711e 	bne	r2,zero,32382c4 <tcp_slowtimo+0x234>
            continue;
         ipnxt = ip->inp_next;
 3238100:	e0bfff17 	ldw	r2,-4(fp)
 3238104:	10800017 	ldw	r2,0(r2)
 3238108:	e0bffe15 	stw	r2,-8(fp)

         tp = intotcpcb(so->so_pcb);
 323810c:	e0bffb17 	ldw	r2,-20(fp)
 3238110:	10800117 	ldw	r2,4(r2)
 3238114:	10800917 	ldw	r2,36(r2)
 3238118:	e0bffd15 	stw	r2,-12(fp)
         if (!tp)
 323811c:	e0bffd17 	ldw	r2,-12(fp)
 3238120:	1005003a 	cmpeq	r2,r2,zero
 3238124:	1000671e 	bne	r2,zero,32382c4 <tcp_slowtimo+0x234>
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 3238128:	e03ffc15 	stw	zero,-16(fp)
 323812c:	00002d06 	br	32381e4 <tcp_slowtimo+0x154>
         {
            if (tp->t_timer[i] && --tp->t_timer[i] == 0) 
 3238130:	e0bffc17 	ldw	r2,-16(fp)
 3238134:	e0fffd17 	ldw	r3,-12(fp)
 3238138:	1085883a 	add	r2,r2,r2
 323813c:	1085883a 	add	r2,r2,r2
 3238140:	10c5883a 	add	r2,r2,r3
 3238144:	10800304 	addi	r2,r2,12
 3238148:	10800017 	ldw	r2,0(r2)
 323814c:	1005003a 	cmpeq	r2,r2,zero
 3238150:	1000211e 	bne	r2,zero,32381d8 <tcp_slowtimo+0x148>
 3238154:	e0fffc17 	ldw	r3,-16(fp)
 3238158:	e13ffd17 	ldw	r4,-12(fp)
 323815c:	18c5883a 	add	r2,r3,r3
 3238160:	1085883a 	add	r2,r2,r2
 3238164:	1105883a 	add	r2,r2,r4
 3238168:	10800304 	addi	r2,r2,12
 323816c:	10800017 	ldw	r2,0(r2)
 3238170:	117fffc4 	addi	r5,r2,-1
 3238174:	e13ffd17 	ldw	r4,-12(fp)
 3238178:	18c5883a 	add	r2,r3,r3
 323817c:	1085883a 	add	r2,r2,r2
 3238180:	1105883a 	add	r2,r2,r4
 3238184:	10800304 	addi	r2,r2,12
 3238188:	11400015 	stw	r5,0(r2)
 323818c:	e13ffd17 	ldw	r4,-12(fp)
 3238190:	18c5883a 	add	r2,r3,r3
 3238194:	1085883a 	add	r2,r2,r2
 3238198:	1105883a 	add	r2,r2,r4
 323819c:	10800304 	addi	r2,r2,12
 32381a0:	10800017 	ldw	r2,0(r2)
 32381a4:	1004c03a 	cmpne	r2,r2,zero
 32381a8:	10000b1e 	bne	r2,zero,32381d8 <tcp_slowtimo+0x148>
            {
               /* call usrreq to do actual work */
               so->so_req = PRU_SLOWTIMO;
 32381ac:	e0fffb17 	ldw	r3,-20(fp)
 32381b0:	008004c4 	movi	r2,19
 32381b4:	18800715 	stw	r2,28(r3)
               (void) tcp_usrreq(so, (struct mbuf *)0, 
 32381b8:	e1bffc17 	ldw	r6,-16(fp)
 32381bc:	e13ffb17 	ldw	r4,-20(fp)
 32381c0:	000b883a 	mov	r5,zero
 32381c4:	32388280 	call	3238828 <tcp_usrreq>
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
 32381c8:	e0bffe17 	ldw	r2,-8(fp)
 32381cc:	10c00117 	ldw	r3,4(r2)
 32381d0:	e0bfff17 	ldw	r2,-4(fp)
 32381d4:	18803b1e 	bne	r3,r2,32382c4 <tcp_slowtimo+0x234>

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 32381d8:	e0bffc17 	ldw	r2,-16(fp)
 32381dc:	10800044 	addi	r2,r2,1
 32381e0:	e0bffc15 	stw	r2,-16(fp)
 32381e4:	e0bffc17 	ldw	r2,-16(fp)
 32381e8:	10800110 	cmplti	r2,r2,4
 32381ec:	103fd01e 	bne	r2,zero,3238130 <tcp_slowtimo+0xa0>
               }
            }
         }
#endif   /* TCP_ZEROCOPY */

         tp->t_idle++;
 32381f0:	e0bffd17 	ldw	r2,-12(fp)
 32381f4:	10801d17 	ldw	r2,116(r2)
 32381f8:	10c00044 	addi	r3,r2,1
 32381fc:	e0bffd17 	ldw	r2,-12(fp)
 3238200:	10c01d15 	stw	r3,116(r2)
      }

      /* wake up anyone sleeping in a select() involving this socket */
      sb = &so->so_rcv;
 3238204:	e0bffb17 	ldw	r2,-20(fp)
 3238208:	10800a04 	addi	r2,r2,40
 323820c:	e0bff915 	stw	r2,-28(fp)
      if (sb->sb_flags & SB_SEL) 
 3238210:	e0bff917 	ldw	r2,-28(fp)
 3238214:	1080070b 	ldhu	r2,28(r2)
 3238218:	10bfffcc 	andi	r2,r2,65535
 323821c:	1080020c 	andi	r2,r2,8
 3238220:	1005003a 	cmpeq	r2,r2,zero
 3238224:	10000d1e 	bne	r2,zero,323825c <tcp_slowtimo+0x1cc>
      {
         select_wait = 0;
 3238228:	0080c974 	movhi	r2,805
 323822c:	10925e04 	addi	r2,r2,18808
 3238230:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 3238234:	0100c974 	movhi	r4,805
 3238238:	21125e04 	addi	r4,r4,18808
 323823c:	32269000 	call	3226900 <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 3238240:	e0bff917 	ldw	r2,-28(fp)
 3238244:	10c0070b 	ldhu	r3,28(r2)
 3238248:	00bffdc4 	movi	r2,-9
 323824c:	1884703a 	and	r2,r3,r2
 3238250:	1007883a 	mov	r3,r2
 3238254:	e0bff917 	ldw	r2,-28(fp)
 3238258:	10c0070d 	sth	r3,28(r2)
      }
      sb = &so->so_snd;
 323825c:	e0bffb17 	ldw	r2,-20(fp)
 3238260:	10801204 	addi	r2,r2,72
 3238264:	e0bff915 	stw	r2,-28(fp)
      if (sb->sb_flags & SB_SEL) 
 3238268:	e0bff917 	ldw	r2,-28(fp)
 323826c:	1080070b 	ldhu	r2,28(r2)
 3238270:	10bfffcc 	andi	r2,r2,65535
 3238274:	1080020c 	andi	r2,r2,8
 3238278:	1005003a 	cmpeq	r2,r2,zero
 323827c:	10000d1e 	bne	r2,zero,32382b4 <tcp_slowtimo+0x224>
      {
         select_wait = 0;         
 3238280:	0080c974 	movhi	r2,805
 3238284:	10925e04 	addi	r2,r2,18808
 3238288:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 323828c:	0100c974 	movhi	r4,805
 3238290:	21125e04 	addi	r4,r4,18808
 3238294:	32269000 	call	3226900 <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 3238298:	e0bff917 	ldw	r2,-28(fp)
 323829c:	10c0070b 	ldhu	r3,28(r2)
 32382a0:	00bffdc4 	movi	r2,-9
 32382a4:	1884703a 	and	r2,r3,r2
 32382a8:	1007883a 	mov	r3,r2
 32382ac:	e0bff917 	ldw	r2,-28(fp)
 32382b0:	10c0070d 	sth	r3,28(r2)
      }

      /* wake any thread with a timer going for a connection state change */     
      tcp_wakeup((char*)&so->so_timeo);
 32382b4:	e0bffb17 	ldw	r2,-20(fp)
 32382b8:	10800904 	addi	r2,r2,36
 32382bc:	1009883a 	mov	r4,r2
 32382c0:	32269000 	call	3226900 <tcp_wakeup>
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 32382c4:	e0bffa17 	ldw	r2,-24(fp)
 32382c8:	e0bffb15 	stw	r2,-20(fp)
 32382cc:	e0bffb17 	ldw	r2,-20(fp)
 32382d0:	1004c03a 	cmpne	r2,r2,zero
 32382d4:	103f7a1e 	bne	r2,zero,32380c0 <tcp_slowtimo+0x30>

tpgone:
      ;
   }

   tcp_iss += (unsigned)(TCP_ISSINCR/PR_SLOWHZ);      /* increment iss */
 32382d8:	0080c974 	movhi	r2,805
 32382dc:	10926304 	addi	r2,r2,18828
 32382e0:	10c00017 	ldw	r3,0(r2)
 32382e4:	00be9fd4 	movui	r2,64127
 32382e8:	1887883a 	add	r3,r3,r2
 32382ec:	0080c974 	movhi	r2,805
 32382f0:	10926304 	addi	r2,r2,18828
 32382f4:	10c00015 	stw	r3,0(r2)

   if (tcp_iss & 0xff000000)
 32382f8:	0080c974 	movhi	r2,805
 32382fc:	10926304 	addi	r2,r2,18828
 3238300:	10800017 	ldw	r2,0(r2)
 3238304:	10bfc02c 	andhi	r2,r2,65280
 3238308:	1005003a 	cmpeq	r2,r2,zero
 323830c:	1000031e 	bne	r2,zero,323831c <tcp_slowtimo+0x28c>
      tcp_iss = 0L;
 3238310:	0080c974 	movhi	r2,805
 3238314:	10926304 	addi	r2,r2,18828
 3238318:	10000015 	stw	zero,0(r2)
}
 323831c:	e037883a 	mov	sp,fp
 3238320:	dfc00117 	ldw	ra,4(sp)
 3238324:	df000017 	ldw	fp,0(sp)
 3238328:	dec00204 	addi	sp,sp,8
 323832c:	f800283a 	ret

03238330 <tcp_canceltimers>:
 * RETURNS: 
 */

void
tcp_canceltimers(struct tcpcb * tp)
{
 3238330:	defffd04 	addi	sp,sp,-12
 3238334:	df000215 	stw	fp,8(sp)
 3238338:	df000204 	addi	fp,sp,8
 323833c:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 3238340:	e03ffe15 	stw	zero,-8(fp)
 3238344:	00000a06 	br	3238370 <tcp_canceltimers+0x40>
      tp->t_timer[i] = 0;
 3238348:	e0bffe17 	ldw	r2,-8(fp)
 323834c:	e0ffff17 	ldw	r3,-4(fp)
 3238350:	1085883a 	add	r2,r2,r2
 3238354:	1085883a 	add	r2,r2,r2
 3238358:	10c5883a 	add	r2,r2,r3
 323835c:	10800304 	addi	r2,r2,12
 3238360:	10000015 	stw	zero,0(r2)
void
tcp_canceltimers(struct tcpcb * tp)
{
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 3238364:	e0bffe17 	ldw	r2,-8(fp)
 3238368:	10800044 	addi	r2,r2,1
 323836c:	e0bffe15 	stw	r2,-8(fp)
 3238370:	e0bffe17 	ldw	r2,-8(fp)
 3238374:	10800110 	cmplti	r2,r2,4
 3238378:	103ff31e 	bne	r2,zero,3238348 <tcp_canceltimers+0x18>
      tp->t_timer[i] = 0;
}
 323837c:	e037883a 	mov	sp,fp
 3238380:	df000017 	ldw	fp,0(sp)
 3238384:	dec00104 	addi	sp,sp,4
 3238388:	f800283a 	ret

0323838c <tcp_timers>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_timers(struct tcpcb * tp, int timer)
{
 323838c:	defff504 	addi	sp,sp,-44
 3238390:	dfc00a15 	stw	ra,40(sp)
 3238394:	df000915 	stw	fp,36(sp)
 3238398:	df000904 	addi	fp,sp,36
 323839c:	e13ffb15 	stw	r4,-20(fp)
 32383a0:	e17ffc15 	stw	r5,-16(fp)
   int   rexmt;

   switch (timer) 
 32383a4:	e0bffc17 	ldw	r2,-16(fp)
 32383a8:	e0bffe15 	stw	r2,-8(fp)
 32383ac:	e0fffe17 	ldw	r3,-8(fp)
 32383b0:	18800060 	cmpeqi	r2,r3,1
 32383b4:	1000bd1e 	bne	r2,zero,32386ac <tcp_timers+0x320>
 32383b8:	e0fffe17 	ldw	r3,-8(fp)
 32383bc:	18800088 	cmpgei	r2,r3,2
 32383c0:	1000041e 	bne	r2,zero,32383d4 <tcp_timers+0x48>
 32383c4:	e0fffe17 	ldw	r3,-8(fp)
 32383c8:	1805003a 	cmpeq	r2,r3,zero
 32383cc:	10001b1e 	bne	r2,zero,323843c <tcp_timers+0xb0>
 32383d0:	00010f06 	br	3238810 <tcp_timers+0x484>
 32383d4:	e0fffe17 	ldw	r3,-8(fp)
 32383d8:	188000a0 	cmpeqi	r2,r3,2
 32383dc:	1000c41e 	bne	r2,zero,32386f0 <tcp_timers+0x364>
 32383e0:	e0fffe17 	ldw	r3,-8(fp)
 32383e4:	188000e0 	cmpeqi	r2,r3,3
 32383e8:	1000011e 	bne	r2,zero,32383f0 <tcp_timers+0x64>
 32383ec:	00010806 	br	3238810 <tcp_timers+0x484>
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 32383f0:	e0bffb17 	ldw	r2,-20(fp)
 32383f4:	10800217 	ldw	r2,8(r2)
 32383f8:	108002a0 	cmpeqi	r2,r2,10
 32383fc:	10000b1e 	bne	r2,zero,323842c <tcp_timers+0xa0>
 3238400:	e0bffb17 	ldw	r2,-20(fp)
 3238404:	10c01d17 	ldw	r3,116(r2)
 3238408:	d0a8eb17 	ldw	r2,-23636(gp)
 323840c:	10c00716 	blt	r2,r3,323842c <tcp_timers+0xa0>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
 3238410:	d0a03b17 	ldw	r2,-32532(gp)
 3238414:	10ffffcc 	andi	r3,r2,65535
 3238418:	18e0001c 	xori	r3,r3,32768
 323841c:	18e00004 	addi	r3,r3,-32768
 3238420:	e0bffb17 	ldw	r2,-20(fp)
 3238424:	10c00615 	stw	r3,24(r2)
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 3238428:	0000f906 	br	3238810 <tcp_timers+0x484>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
      }
      else
         tp = tcp_close(tp);
 323842c:	e13ffb17 	ldw	r4,-20(fp)
 3238430:	3237e640 	call	3237e64 <tcp_close>
 3238434:	e0bffb15 	stw	r2,-20(fp)
      break;
 3238438:	0000f506 	br	3238810 <tcp_timers+0x484>
    * Retransmission timer went off.  Message has not
    * been acked within retransmit interval.  Back off
    * to a longer retransmit interval and retransmit one segment.
    */
   case TCPT_REXMT:
      TCP_MIB_INC(tcpRetransSegs);     /* keep MIB stats */
 323843c:	0080c9b4 	movhi	r2,806
 3238440:	10b39c04 	addi	r2,r2,-12688
 3238444:	10800b17 	ldw	r2,44(r2)
 3238448:	10c00044 	addi	r3,r2,1
 323844c:	0080c9b4 	movhi	r2,806
 3238450:	10b39c04 	addi	r2,r2,-12688
 3238454:	10c00b15 	stw	r3,44(r2)
      if (++tp->t_rxtshift > TCP_MAXRXTSHIFT) 
 3238458:	e0bffb17 	ldw	r2,-20(fp)
 323845c:	10800717 	ldw	r2,28(r2)
 3238460:	10c00044 	addi	r3,r2,1
 3238464:	e0bffb17 	ldw	r2,-20(fp)
 3238468:	10c00715 	stw	r3,28(r2)
 323846c:	e0bffb17 	ldw	r2,-20(fp)
 3238470:	10800717 	ldw	r2,28(r2)
 3238474:	10800350 	cmplti	r2,r2,13
 3238478:	10000f1e 	bne	r2,zero,32384b8 <tcp_timers+0x12c>
      {
         tp->t_rxtshift = TCP_MAXRXTSHIFT;
 323847c:	e0fffb17 	ldw	r3,-20(fp)
 3238480:	00800304 	movi	r2,12
 3238484:	18800715 	stw	r2,28(r3)
         tcpstat.tcps_timeoutdrop++;
 3238488:	0080c9b4 	movhi	r2,806
 323848c:	10b3ca04 	addi	r2,r2,-12504
 3238490:	10800917 	ldw	r2,36(r2)
 3238494:	10c00044 	addi	r3,r2,1
 3238498:	0080c9b4 	movhi	r2,806
 323849c:	10b3ca04 	addi	r2,r2,-12504
 32384a0:	10c00915 	stw	r3,36(r2)
         tp = tcp_drop(tp, ETIMEDOUT);
 32384a4:	e13ffb17 	ldw	r4,-20(fp)
 32384a8:	01401d04 	movi	r5,116
 32384ac:	3237db80 	call	3237db8 <tcp_drop>
 32384b0:	e0bffb15 	stw	r2,-20(fp)
         break;
 32384b4:	0000d606 	br	3238810 <tcp_timers+0x484>
      }
      tcpstat.tcps_rexmttimeo++;
 32384b8:	0080c9b4 	movhi	r2,806
 32384bc:	10b3ca04 	addi	r2,r2,-12504
 32384c0:	10800a17 	ldw	r2,40(r2)
 32384c4:	10c00044 	addi	r3,r2,1
 32384c8:	0080c9b4 	movhi	r2,806
 32384cc:	10b3ca04 	addi	r2,r2,-12504
 32384d0:	10c00a15 	stw	r3,40(r2)
      rexmt = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 32384d4:	e0bffb17 	ldw	r2,-20(fp)
 32384d8:	10802017 	ldw	r2,128(r2)
 32384dc:	1007d0ba 	srai	r3,r2,2
 32384e0:	e0bffb17 	ldw	r2,-20(fp)
 32384e4:	10802117 	ldw	r2,132(r2)
 32384e8:	1885883a 	add	r2,r3,r2
 32384ec:	1005d07a 	srai	r2,r2,1
 32384f0:	e0bffa15 	stw	r2,-24(fp)
      rexmt *= tcp_backoff[tp->t_rxtshift];
 32384f4:	e0bffb17 	ldw	r2,-20(fp)
 32384f8:	10c00717 	ldw	r3,28(r2)
 32384fc:	0080c974 	movhi	r2,805
 3238500:	108875c4 	addi	r2,r2,8663
 3238504:	10c5883a 	add	r2,r2,r3
 3238508:	10800003 	ldbu	r2,0(r2)
 323850c:	10c03fcc 	andi	r3,r2,255
 3238510:	e0bffa17 	ldw	r2,-24(fp)
 3238514:	10c5383a 	mul	r2,r2,r3
 3238518:	e0bffa15 	stw	r2,-24(fp)
      TCPT_RANGESET(tp->t_rxtcur, rexmt, TCPTV_MIN, TCPTV_REXMTMAX);
 323851c:	e0bffa17 	ldw	r2,-24(fp)
 3238520:	10ffffcc 	andi	r3,r2,65535
 3238524:	18e0001c 	xori	r3,r3,32768
 3238528:	18e00004 	addi	r3,r3,-32768
 323852c:	e0bffb17 	ldw	r2,-20(fp)
 3238530:	10c00815 	stw	r3,32(r2)
 3238534:	e0bffb17 	ldw	r2,-20(fp)
 3238538:	10800817 	ldw	r2,32(r2)
 323853c:	10800088 	cmpgei	r2,r2,2
 3238540:	1000041e 	bne	r2,zero,3238554 <tcp_timers+0x1c8>
 3238544:	e0fffb17 	ldw	r3,-20(fp)
 3238548:	00800084 	movi	r2,2
 323854c:	18800815 	stw	r2,32(r3)
 3238550:	00000706 	br	3238570 <tcp_timers+0x1e4>
 3238554:	e0bffb17 	ldw	r2,-20(fp)
 3238558:	10800817 	ldw	r2,32(r2)
 323855c:	10802050 	cmplti	r2,r2,129
 3238560:	1000031e 	bne	r2,zero,3238570 <tcp_timers+0x1e4>
 3238564:	e0fffb17 	ldw	r3,-20(fp)
 3238568:	00802004 	movi	r2,128
 323856c:	18800815 	stw	r2,32(r3)
      tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 3238570:	e0bffb17 	ldw	r2,-20(fp)
 3238574:	10c00817 	ldw	r3,32(r2)
 3238578:	e0bffb17 	ldw	r2,-20(fp)
 323857c:	10c00315 	stw	r3,12(r2)
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 3238580:	e0bffb17 	ldw	r2,-20(fp)
 3238584:	10800717 	ldw	r2,28(r2)
 3238588:	10800110 	cmplti	r2,r2,4
 323858c:	1000101e 	bne	r2,zero,32385d0 <tcp_timers+0x244>
 3238590:	e0bffb17 	ldw	r2,-20(fp)
 3238594:	10800b0b 	ldhu	r2,44(r2)
 3238598:	10bfffcc 	andi	r2,r2,65535
 323859c:	1080400c 	andi	r2,r2,256
 32385a0:	1004c03a 	cmpne	r2,r2,zero
 32385a4:	10000a1e 	bne	r2,zero,32385d0 <tcp_timers+0x244>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
      {
         tp->t_rttvar += (tp->t_srtt >> 2);
 32385a8:	e0bffb17 	ldw	r2,-20(fp)
 32385ac:	10c02117 	ldw	r3,132(r2)
 32385b0:	e0bffb17 	ldw	r2,-20(fp)
 32385b4:	10802017 	ldw	r2,128(r2)
 32385b8:	1005d0ba 	srai	r2,r2,2
 32385bc:	1887883a 	add	r3,r3,r2
 32385c0:	e0bffb17 	ldw	r2,-20(fp)
 32385c4:	10c02115 	stw	r3,132(r2)
         tp->t_srtt = 0;
 32385c8:	e0bffb17 	ldw	r2,-20(fp)
 32385cc:	10002015 	stw	zero,128(r2)
      }
      tp->snd_nxt = tp->snd_una;
 32385d0:	e0bffb17 	ldw	r2,-20(fp)
 32385d4:	10c00e17 	ldw	r3,56(r2)
 32385d8:	e0bffb17 	ldw	r2,-20(fp)
 32385dc:	10c00f15 	stw	r3,60(r2)
      /*
       * If timing a segment in this window, stop the timer.
       */
      tp->t_rttick = 0;
 32385e0:	e0bffb17 	ldw	r2,-20(fp)
 32385e4:	10001e15 	stw	zero,120(r2)
       * to go below this.)
       *
       * Vers 1.9 - Skip slow start if the SO_NOSLOWSTART socket option
       * is set.
       */
      if((tp->t_inpcb->inp_socket->so_options & SO_NOSLOWSTART) == 0)
 32385e8:	e0bffb17 	ldw	r2,-20(fp)
 32385ec:	10800d17 	ldw	r2,52(r2)
 32385f0:	10800817 	ldw	r2,32(r2)
 32385f4:	10800417 	ldw	r2,16(r2)
 32385f8:	1090000c 	andi	r2,r2,16384
 32385fc:	1004c03a 	cmpne	r2,r2,zero
 3238600:	1000271e 	bne	r2,zero,32386a0 <tcp_timers+0x314>
      {
         u_int win = MIN(tp->snd_wnd, tp->snd_cwnd);
 3238604:	e0bffb17 	ldw	r2,-20(fp)
 3238608:	10c01417 	ldw	r3,80(r2)
 323860c:	e0bffb17 	ldw	r2,-20(fp)
 3238610:	10801b17 	ldw	r2,108(r2)
 3238614:	e0bffd15 	stw	r2,-12(fp)
 3238618:	e0ffff15 	stw	r3,-4(fp)
 323861c:	e0bffd17 	ldw	r2,-12(fp)
 3238620:	e0ffff17 	ldw	r3,-4(fp)
 3238624:	10c0022e 	bgeu	r2,r3,3238630 <tcp_timers+0x2a4>
 3238628:	e0bffd17 	ldw	r2,-12(fp)
 323862c:	e0bfff15 	stw	r2,-4(fp)
 3238630:	e0ffff17 	ldw	r3,-4(fp)
 3238634:	e0fff915 	stw	r3,-28(fp)
         win = win / 2 / tp->t_maxseg;
 3238638:	e0bff917 	ldw	r2,-28(fp)
 323863c:	1008d07a 	srli	r4,r2,1
 3238640:	e0bffb17 	ldw	r2,-20(fp)
 3238644:	10800a0b 	ldhu	r2,40(r2)
 3238648:	117fffcc 	andi	r5,r2,65535
 323864c:	32044bc0 	call	32044bc <__udivsi3>
 3238650:	e0bff915 	stw	r2,-28(fp)
         if (win < 2)
 3238654:	e0bff917 	ldw	r2,-28(fp)
 3238658:	108000a8 	cmpgeui	r2,r2,2
 323865c:	1000021e 	bne	r2,zero,3238668 <tcp_timers+0x2dc>
            win = 2;
 3238660:	00800084 	movi	r2,2
 3238664:	e0bff915 	stw	r2,-28(fp)
         tp->snd_cwnd = tp->t_maxseg;
 3238668:	e0bffb17 	ldw	r2,-20(fp)
 323866c:	10800a0b 	ldhu	r2,40(r2)
 3238670:	10ffffcc 	andi	r3,r2,65535
 3238674:	e0bffb17 	ldw	r2,-20(fp)
 3238678:	10c01b15 	stw	r3,108(r2)
         tp->snd_ssthresh = (u_short)win * tp->t_maxseg;
 323867c:	e0bff917 	ldw	r2,-28(fp)
 3238680:	10ffffcc 	andi	r3,r2,65535
 3238684:	e0bffb17 	ldw	r2,-20(fp)
 3238688:	10800a0b 	ldhu	r2,40(r2)
 323868c:	10bfffcc 	andi	r2,r2,65535
 3238690:	1885383a 	mul	r2,r3,r2
 3238694:	1007883a 	mov	r3,r2
 3238698:	e0bffb17 	ldw	r2,-20(fp)
 323869c:	10c01c15 	stw	r3,112(r2)
      }
      (void) tcp_output(tp);
 32386a0:	e13ffb17 	ldw	r4,-20(fp)
 32386a4:	32363480 	call	3236348 <tcp_output>
      break;
 32386a8:	00005906 	br	3238810 <tcp_timers+0x484>
   /*
    * Persistance timer into zero window.
    * Force a byte to be output, if possible.
    */
   case TCPT_PERSIST:
      tcpstat.tcps_persisttimeo++;
 32386ac:	0080c9b4 	movhi	r2,806
 32386b0:	10b3ca04 	addi	r2,r2,-12504
 32386b4:	10800b17 	ldw	r2,44(r2)
 32386b8:	10c00044 	addi	r3,r2,1
 32386bc:	0080c9b4 	movhi	r2,806
 32386c0:	10b3ca04 	addi	r2,r2,-12504
 32386c4:	10c00b15 	stw	r3,44(r2)
      tcp_setpersist(tp);
 32386c8:	e13ffb17 	ldw	r4,-20(fp)
 32386cc:	32374c40 	call	32374c4 <tcp_setpersist>
      tp->t_force = 1;
 32386d0:	e0fffb17 	ldw	r3,-20(fp)
 32386d4:	00800044 	movi	r2,1
 32386d8:	18800a85 	stb	r2,42(r3)
      (void) tcp_output(tp);
 32386dc:	e13ffb17 	ldw	r4,-20(fp)
 32386e0:	32363480 	call	3236348 <tcp_output>
      tp->t_force = 0;
 32386e4:	e0bffb17 	ldw	r2,-20(fp)
 32386e8:	10000a85 	stb	zero,42(r2)
      break;
 32386ec:	00004806 	br	3238810 <tcp_timers+0x484>
   /*
    * Keep-alive timer went off; send something
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
 32386f0:	0080c9b4 	movhi	r2,806
 32386f4:	10b3ca04 	addi	r2,r2,-12504
 32386f8:	10800c17 	ldw	r2,48(r2)
 32386fc:	10c00044 	addi	r3,r2,1
 3238700:	0080c9b4 	movhi	r2,806
 3238704:	10b3ca04 	addi	r2,r2,-12504
 3238708:	10c00c15 	stw	r3,48(r2)
      if (tp->t_state < TCPS_ESTABLISHED)
 323870c:	e0bffb17 	ldw	r2,-20(fp)
 3238710:	10800217 	ldw	r2,8(r2)
 3238714:	10800110 	cmplti	r2,r2,4
 3238718:	1000321e 	bne	r2,zero,32387e4 <tcp_timers+0x458>
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 323871c:	e0bffb17 	ldw	r2,-20(fp)
 3238720:	10800d17 	ldw	r2,52(r2)
 3238724:	10800817 	ldw	r2,32(r2)
 3238728:	10800417 	ldw	r2,16(r2)
 323872c:	1080020c 	andi	r2,r2,8
 3238730:	1005003a 	cmpeq	r2,r2,zero
 3238734:	1000241e 	bne	r2,zero,32387c8 <tcp_timers+0x43c>
 3238738:	e0bffb17 	ldw	r2,-20(fp)
 323873c:	10800217 	ldw	r2,8(r2)
 3238740:	10800188 	cmpgei	r2,r2,6
 3238744:	1000201e 	bne	r2,zero,32387c8 <tcp_timers+0x43c>
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
 3238748:	e0bffb17 	ldw	r2,-20(fp)
 323874c:	11001d17 	ldw	r4,116(r2)
 3238750:	d0e03a17 	ldw	r3,-32536(gp)
 3238754:	d0a8eb17 	ldw	r2,-23636(gp)
 3238758:	1885883a 	add	r2,r3,r2
 323875c:	2080210e 	bge	r4,r2,32387e4 <tcp_timers+0x458>
          * causes the transmitted zero-length segment
          * to lie outside the receive window;
          * by the protocol spec, this requires the
          * correspondent TCP to respond.
          */
         tcpstat.tcps_keepprobe++;
 3238760:	0080c9b4 	movhi	r2,806
 3238764:	10b3ca04 	addi	r2,r2,-12504
 3238768:	10800d17 	ldw	r2,52(r2)
 323876c:	10c00044 	addi	r3,r2,1
 3238770:	0080c9b4 	movhi	r2,806
 3238774:	10b3ca04 	addi	r2,r2,-12504
 3238778:	10c00d15 	stw	r3,52(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 323877c:	e0bffb17 	ldw	r2,-20(fp)
 3238780:	11400c17 	ldw	r5,48(r2)
 3238784:	e0bffb17 	ldw	r2,-20(fp)
 3238788:	10801617 	ldw	r2,88(r2)
 323878c:	11bfffc4 	addi	r6,r2,-1
 3238790:	e0bffb17 	ldw	r2,-20(fp)
 3238794:	10800e17 	ldw	r2,56(r2)
 3238798:	11ffffc4 	addi	r7,r2,-1
 323879c:	d8000015 	stw	zero,0(sp)
 32387a0:	d8000115 	stw	zero,4(sp)
 32387a4:	e13ffb17 	ldw	r4,-20(fp)
 32387a8:	32378180 	call	3237818 <tcp_respond>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
 32387ac:	d0a03b17 	ldw	r2,-32532(gp)
 32387b0:	10ffffcc 	andi	r3,r2,65535
 32387b4:	18e0001c 	xori	r3,r3,32768
 32387b8:	18e00004 	addi	r3,r3,-32768
 32387bc:	e0bffb17 	ldw	r2,-20(fp)
 32387c0:	10c00515 	stw	r3,20(r2)
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 32387c4:	00001206 	br	3238810 <tcp_timers+0x484>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
 32387c8:	d0a03a17 	ldw	r2,-32536(gp)
 32387cc:	10ffffcc 	andi	r3,r2,65535
 32387d0:	18e0001c 	xori	r3,r3,32768
 32387d4:	18e00004 	addi	r3,r3,-32768
 32387d8:	e0bffb17 	ldw	r2,-20(fp)
 32387dc:	10c00515 	stw	r3,20(r2)
      break;
 32387e0:	00000b06 	br	3238810 <tcp_timers+0x484>
      dropit:
      tcpstat.tcps_keepdrops++;
 32387e4:	0080c9b4 	movhi	r2,806
 32387e8:	10b3ca04 	addi	r2,r2,-12504
 32387ec:	10800e17 	ldw	r2,56(r2)
 32387f0:	10c00044 	addi	r3,r2,1
 32387f4:	0080c9b4 	movhi	r2,806
 32387f8:	10b3ca04 	addi	r2,r2,-12504
 32387fc:	10c00e15 	stw	r3,56(r2)
      tp = tcp_drop (tp, ETIMEDOUT);
 3238800:	e13ffb17 	ldw	r4,-20(fp)
 3238804:	01401d04 	movi	r5,116
 3238808:	3237db80 	call	3237db8 <tcp_drop>
 323880c:	e0bffb15 	stw	r2,-20(fp)
      break;
   }
   return tp;
 3238810:	e0bffb17 	ldw	r2,-20(fp)
}
 3238814:	e037883a 	mov	sp,fp
 3238818:	dfc00117 	ldw	ra,4(sp)
 323881c:	df000017 	ldw	fp,0(sp)
 3238820:	dec00204 	addi	sp,sp,8
 3238824:	f800283a 	ret

03238828 <tcp_usrreq>:

int
tcp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 3238828:	defff504 	addi	sp,sp,-44
 323882c:	dfc00a15 	stw	ra,40(sp)
 3238830:	df000915 	stw	fp,36(sp)
 3238834:	df000904 	addi	fp,sp,36
 3238838:	e13ffc15 	stw	r4,-16(fp)
 323883c:	e17ffd15 	stw	r5,-12(fp)
 3238840:	e1bffe15 	stw	r6,-8(fp)
   struct inpcb * inp;
   struct tcpcb * tp;
   int   error =  0;
 3238844:	e03ff915 	stw	zero,-28(fp)

#ifdef DO_TCPTRACE
   int   ostate;
#endif

   req = so->so_req;    /* get request from socket struct */
 3238848:	e0bffc17 	ldw	r2,-16(fp)
 323884c:	10800717 	ldw	r2,28(r2)
 3238850:	e0bff815 	stw	r2,-32(fp)
   inp = sotoinpcb(so);
 3238854:	e0bffc17 	ldw	r2,-16(fp)
 3238858:	10800117 	ldw	r2,4(r2)
 323885c:	e0bffb15 	stw	r2,-20(fp)
   /*
    * When a TCP is attached to a socket, then there will be
    * a (struct inpcb) pointed at by the socket, and this
    * structure will point at a subsidary (struct tcpcb).
    */
   if (inp == 0 && req != PRU_ATTACH) 
 3238860:	e0bffb17 	ldw	r2,-20(fp)
 3238864:	1004c03a 	cmpne	r2,r2,zero
 3238868:	1000061e 	bne	r2,zero,3238884 <tcp_usrreq+0x5c>
 323886c:	e0bff817 	ldw	r2,-32(fp)
 3238870:	1005003a 	cmpeq	r2,r2,zero
 3238874:	1000031e 	bne	r2,zero,3238884 <tcp_usrreq+0x5c>
   {
      return (EINVAL);
 3238878:	00800584 	movi	r2,22
 323887c:	e0bfff15 	stw	r2,-4(fp)
 3238880:	0001a406 	br	3238f14 <tcp_usrreq+0x6ec>
   }

   if (inp)
 3238884:	e0bffb17 	ldw	r2,-20(fp)
 3238888:	1005003a 	cmpeq	r2,r2,zero
 323888c:	1000041e 	bne	r2,zero,32388a0 <tcp_usrreq+0x78>
      tp = intotcpcb(inp);
 3238890:	e0bffb17 	ldw	r2,-20(fp)
 3238894:	10800917 	ldw	r2,36(r2)
 3238898:	e0bffa15 	stw	r2,-24(fp)
 323889c:	00000906 	br	32388c4 <tcp_usrreq+0x9c>
   else  /* inp and tp not set, make sure this is OK: */
   { 
      if (req == PRU_ATTACH)
 32388a0:	e0bff817 	ldw	r2,-32(fp)
 32388a4:	1004c03a 	cmpne	r2,r2,zero
 32388a8:	1000021e 	bne	r2,zero,32388b4 <tcp_usrreq+0x8c>
         tp = NULL;  /* stifle compiler warnings about using unassigned tp*/
 32388ac:	e03ffa15 	stw	zero,-24(fp)
 32388b0:	00000406 	br	32388c4 <tcp_usrreq+0x9c>
      else
      {
         dtrap(); /* programming error? */
 32388b4:	322ab8c0 	call	322ab8c <dtrap>
         return EINVAL;
 32388b8:	00800584 	movi	r2,22
 32388bc:	e0bfff15 	stw	r2,-4(fp)
 32388c0:	00019406 	br	3238f14 <tcp_usrreq+0x6ec>
      }
   }

   switch (req) 
 32388c4:	e0bff817 	ldw	r2,-32(fp)
 32388c8:	10800528 	cmpgeui	r2,r2,20
 32388cc:	10018c1e 	bne	r2,zero,3238f00 <tcp_usrreq+0x6d8>
 32388d0:	e0bff817 	ldw	r2,-32(fp)
 32388d4:	1085883a 	add	r2,r2,r2
 32388d8:	1087883a 	add	r3,r2,r2
 32388dc:	0080c934 	movhi	r2,804
 32388e0:	10a23c04 	addi	r2,r2,-30480
 32388e4:	1885883a 	add	r2,r3,r2
 32388e8:	10800017 	ldw	r2,0(r2)
 32388ec:	1000683a 	jmp	r2
 32388f0:	03238940 	call	323894 <OSCtxSw_SWITCH_PC+0x323854>
 32388f4:	032389b0 	cmpltui	r12,zero,36390
 32388f8:	032389d8 	cmpnei	r12,zero,-29145
 32388fc:	03238a10 	cmplti	r12,zero,-29144
 3238900:	03238a50 	cmplti	r12,zero,-29143
 3238904:	03238bd4 	movui	r12,36399
 3238908:	03238bc8 	cmpgei	r12,zero,-29137
 323890c:	03238c80 	call	3238c8 <OSCtxSw_SWITCH_PC+0x323888>
 3238910:	03238cb0 	cmpltui	r12,zero,36402
 3238914:	03238cbc 	xorhi	r12,zero,36402
 3238918:	03238d14 	movui	r12,36404
 323891c:	03238f00 	call	3238f0 <OSCtxSw_SWITCH_PC+0x3238b0>
 3238920:	03238d24 	muli	r12,zero,-29132
 3238924:	03238d30 	cmpltui	r12,zero,36404
 3238928:	03238e00 	call	3238e0 <OSCtxSw_SWITCH_PC+0x3238a0>
 323892c:	03238ed0 	cmplti	r12,zero,-29125
 3238930:	03238ee0 	cmpeqi	r12,zero,-29125
 3238934:	03238bbc 	xorhi	r12,zero,36398
 3238938:	03238f00 	call	3238f0 <OSCtxSw_SWITCH_PC+0x3238b0>
 323893c:	03238ef0 	cmpltui	r12,zero,36411
   /*
    * TCP attaches to socket via PRU_ATTACH, reserving space,
    * and an internet control block.
    */
   case PRU_ATTACH:
      if (inp) 
 3238940:	e0bffb17 	ldw	r2,-20(fp)
 3238944:	1005003a 	cmpeq	r2,r2,zero
 3238948:	1000031e 	bne	r2,zero,3238958 <tcp_usrreq+0x130>
      {
         error = EISCONN;
 323894c:	00801fc4 	movi	r2,127
 3238950:	e0bff915 	stw	r2,-28(fp)
         break;
 3238954:	00016d06 	br	3238f0c <tcp_usrreq+0x6e4>
      }
      error = tcp_attach(so);
 3238958:	e13ffc17 	ldw	r4,-16(fp)
 323895c:	3238f2c0 	call	3238f2c <tcp_attach>
 3238960:	e0bff915 	stw	r2,-28(fp)
      if (error)
 3238964:	e0bff917 	ldw	r2,-28(fp)
 3238968:	1004c03a 	cmpne	r2,r2,zero
 323896c:	1001671e 	bne	r2,zero,3238f0c <tcp_usrreq+0x6e4>
         break;
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 3238970:	e0bffc17 	ldw	r2,-16(fp)
 3238974:	10800417 	ldw	r2,16(r2)
 3238978:	1080200c 	andi	r2,r2,128
 323897c:	1005003a 	cmpeq	r2,r2,zero
 3238980:	1001621e 	bne	r2,zero,3238f0c <tcp_usrreq+0x6e4>
 3238984:	e0bffc17 	ldw	r2,-16(fp)
 3238988:	1080080b 	ldhu	r2,32(r2)
 323898c:	10bfffcc 	andi	r2,r2,65535
 3238990:	10a0001c 	xori	r2,r2,32768
 3238994:	10a00004 	addi	r2,r2,-32768
 3238998:	1004c03a 	cmpne	r2,r2,zero
 323899c:	10015b1e 	bne	r2,zero,3238f0c <tcp_usrreq+0x6e4>
         so->so_linger = TCP_LINGERTIME;
 32389a0:	e0fffc17 	ldw	r3,-16(fp)
 32389a4:	00801e04 	movi	r2,120
 32389a8:	1880080d 	sth	r2,32(r3)
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 32389ac:	00015706 	br	3238f0c <tcp_usrreq+0x6e4>
    * do this directly: have to initiate a PRU_DISCONNECT,
    * which may finish later; embryonic TCB's can just
    * be discarded here.
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
 32389b0:	e0bffa17 	ldw	r2,-24(fp)
 32389b4:	10800217 	ldw	r2,8(r2)
 32389b8:	10800090 	cmplti	r2,r2,2
 32389bc:	1000031e 	bne	r2,zero,32389cc <tcp_usrreq+0x1a4>
         SETTP(tp, tcp_disconnect(tp));
 32389c0:	e13ffa17 	ldw	r4,-24(fp)
 32389c4:	32390600 	call	3239060 <tcp_disconnect>
 32389c8:	00015006 	br	3238f0c <tcp_usrreq+0x6e4>
      else
         SETTP(tp, tcp_close(tp));
 32389cc:	e13ffa17 	ldw	r4,-24(fp)
 32389d0:	3237e640 	call	3237e64 <tcp_close>
      break;
 32389d4:	00014d06 	br	3238f0c <tcp_usrreq+0x6e4>
      /* bind is quite different for IPv4 and v6, so we use two 
       * seperate pcbbind routines. so_domain was checked for 
       * validity way up in t_bind()
       */
#ifdef IP_V4
      if(inp->inp_socket->so_domain == AF_INET)
 32389d8:	e0bffb17 	ldw	r2,-20(fp)
 32389dc:	10800817 	ldw	r2,32(r2)
 32389e0:	10800517 	ldw	r2,20(r2)
 32389e4:	10800098 	cmpnei	r2,r2,2
 32389e8:	1000051e 	bne	r2,zero,3238a00 <tcp_usrreq+0x1d8>
      {
         error = in_pcbbind(inp, nam);
 32389ec:	e13ffb17 	ldw	r4,-20(fp)
 32389f0:	e17ffe17 	ldw	r5,-8(fp)
 32389f4:	3247f680 	call	3247f68 <in_pcbbind>
 32389f8:	e0bff915 	stw	r2,-28(fp)
         break;
 32389fc:	00014306 	br	3238f0c <tcp_usrreq+0x6e4>
      {
         error = ip6_pcbbind(inp, nam);
         break;
      }
#endif /* IP_V6 */
      dtrap();    /* not v4 or v6? */
 3238a00:	322ab8c0 	call	322ab8c <dtrap>
      error = EINVAL;
 3238a04:	00800584 	movi	r2,22
 3238a08:	e0bff915 	stw	r2,-28(fp)
      break;
 3238a0c:	00013f06 	br	3238f0c <tcp_usrreq+0x6e4>
   /*
    * Prepare to accept connections.
    */
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
 3238a10:	e0bffb17 	ldw	r2,-20(fp)
 3238a14:	1080078b 	ldhu	r2,30(r2)
 3238a18:	10bfffcc 	andi	r2,r2,65535
 3238a1c:	1004c03a 	cmpne	r2,r2,zero
 3238a20:	1000041e 	bne	r2,zero,3238a34 <tcp_usrreq+0x20c>
         error = in_pcbbind(inp, (struct mbuf *)0);
 3238a24:	e13ffb17 	ldw	r4,-20(fp)
 3238a28:	000b883a 	mov	r5,zero
 3238a2c:	3247f680 	call	3247f68 <in_pcbbind>
 3238a30:	e0bff915 	stw	r2,-28(fp)
      if (error == 0)
 3238a34:	e0bff917 	ldw	r2,-28(fp)
 3238a38:	1004c03a 	cmpne	r2,r2,zero
 3238a3c:	1001331e 	bne	r2,zero,3238f0c <tcp_usrreq+0x6e4>
         tp->t_state = TCPS_LISTEN;
 3238a40:	e0fffa17 	ldw	r3,-24(fp)
 3238a44:	00800044 	movi	r2,1
 3238a48:	18800215 	stw	r2,8(r3)
      break;
 3238a4c:	00012f06 	br	3238f0c <tcp_usrreq+0x6e4>
    * Enter SYN_SENT state, and mark socket as connecting.
    * Start keep-alive timer, and seed output sequence space.
    * Send initial segment on connection.
    */
   case PRU_CONNECT:
      if (inp->inp_lport == 0) 
 3238a50:	e0bffb17 	ldw	r2,-20(fp)
 3238a54:	1080078b 	ldhu	r2,30(r2)
 3238a58:	10bfffcc 	andi	r2,r2,65535
 3238a5c:	1004c03a 	cmpne	r2,r2,zero
 3238a60:	1000071e 	bne	r2,zero,3238a80 <tcp_usrreq+0x258>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbbind(inp, (struct mbuf *)0);
 3238a64:	e13ffb17 	ldw	r4,-20(fp)
 3238a68:	000b883a 	mov	r5,zero
 3238a6c:	3247f680 	call	3247f68 <in_pcbbind>
 3238a70:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
 3238a74:	e0bff917 	ldw	r2,-28(fp)
 3238a78:	1004c03a 	cmpne	r2,r2,zero
 3238a7c:	1001231e 	bne	r2,zero,3238f0c <tcp_usrreq+0x6e4>
            break;
      }

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbconnect(inp, nam);
 3238a80:	e13ffb17 	ldw	r4,-20(fp)
 3238a84:	e17ffe17 	ldw	r5,-8(fp)
 3238a88:	32481bc0 	call	32481bc <in_pcbconnect>
 3238a8c:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
 3238a90:	e0bff917 	ldw	r2,-28(fp)
 3238a94:	1004c03a 	cmpne	r2,r2,zero
 3238a98:	10011c1e 	bne	r2,zero,3238f0c <tcp_usrreq+0x6e4>
         break;
      tp->t_template = tcp_template(tp);
 3238a9c:	e13ffa17 	ldw	r4,-24(fp)
 3238aa0:	32377000 	call	3237700 <tcp_template>
 3238aa4:	1007883a 	mov	r3,r2
 3238aa8:	e0bffa17 	ldw	r2,-24(fp)
 3238aac:	10c00c15 	stw	r3,48(r2)
      if (tp->t_template == 0) 
 3238ab0:	e0bffa17 	ldw	r2,-24(fp)
 3238ab4:	10800c17 	ldw	r2,48(r2)
 3238ab8:	1004c03a 	cmpne	r2,r2,zero
 3238abc:	1000051e 	bne	r2,zero,3238ad4 <tcp_usrreq+0x2ac>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
         in_pcbdisconnect(inp);
 3238ac0:	e13ffb17 	ldw	r4,-20(fp)
 3238ac4:	32483cc0 	call	32483cc <in_pcbdisconnect>
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
         ip6_pcbdisconnect(inp);
#endif   /* end v6 only */

         error = ENOBUFS;
 3238ac8:	00801a44 	movi	r2,105
 3238acc:	e0bff915 	stw	r2,-28(fp)
         break;
 3238ad0:	00010e06 	br	3238f0c <tcp_usrreq+0x6e4>
      }

      soisconnecting(so);
 3238ad4:	e13ffc17 	ldw	r4,-16(fp)
 3238ad8:	32317340 	call	3231734 <soisconnecting>
      tcpstat.tcps_connattempt++;
 3238adc:	0080c9b4 	movhi	r2,806
 3238ae0:	10b3ca04 	addi	r2,r2,-12504
 3238ae4:	10800017 	ldw	r2,0(r2)
 3238ae8:	10c00044 	addi	r3,r2,1
 3238aec:	0080c9b4 	movhi	r2,806
 3238af0:	10b3ca04 	addi	r2,r2,-12504
 3238af4:	10c00015 	stw	r3,0(r2)
      tp->t_state = TCPS_SYN_SENT;
 3238af8:	e0fffa17 	ldw	r3,-24(fp)
 3238afc:	00800084 	movi	r2,2
 3238b00:	18800215 	stw	r2,8(r3)
      tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 3238b04:	e0fffa17 	ldw	r3,-24(fp)
 3238b08:	00802584 	movi	r2,150
 3238b0c:	18800515 	stw	r2,20(r3)
      tp->iss = tcp_iss; 
 3238b10:	0080c974 	movhi	r2,805
 3238b14:	10926304 	addi	r2,r2,18828
 3238b18:	10c00017 	ldw	r3,0(r2)
 3238b1c:	e0bffa17 	ldw	r2,-24(fp)
 3238b20:	10c01315 	stw	r3,76(r2)
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
 3238b24:	0080c974 	movhi	r2,805
 3238b28:	10926304 	addi	r2,r2,18828
 3238b2c:	10c00017 	ldw	r3,0(r2)
 3238b30:	00be9fd4 	movui	r2,64127
 3238b34:	1887883a 	add	r3,r3,r2
 3238b38:	0080c974 	movhi	r2,805
 3238b3c:	10926304 	addi	r2,r2,18828
 3238b40:	10c00015 	stw	r3,0(r2)
      tcp_sendseqinit(tp);
 3238b44:	e0bffa17 	ldw	r2,-24(fp)
 3238b48:	10c01317 	ldw	r3,76(r2)
 3238b4c:	e0bffa17 	ldw	r2,-24(fp)
 3238b50:	10c01015 	stw	r3,64(r2)
 3238b54:	e0bffa17 	ldw	r2,-24(fp)
 3238b58:	10c01017 	ldw	r3,64(r2)
 3238b5c:	e0bffa17 	ldw	r2,-24(fp)
 3238b60:	10c01a15 	stw	r3,104(r2)
 3238b64:	e0bffa17 	ldw	r2,-24(fp)
 3238b68:	10c01a17 	ldw	r3,104(r2)
 3238b6c:	e0bffa17 	ldw	r2,-24(fp)
 3238b70:	10c00f15 	stw	r3,60(r2)
 3238b74:	e0bffa17 	ldw	r2,-24(fp)
 3238b78:	10c00f17 	ldw	r3,60(r2)
 3238b7c:	e0bffa17 	ldw	r2,-24(fp)
 3238b80:	10c00e15 	stw	r3,56(r2)
      error = tcp_output(tp);
 3238b84:	e13ffa17 	ldw	r4,-24(fp)
 3238b88:	32363480 	call	3236348 <tcp_output>
 3238b8c:	e0bff915 	stw	r2,-28(fp)
      if (!error)
 3238b90:	e0bff917 	ldw	r2,-28(fp)
 3238b94:	1004c03a 	cmpne	r2,r2,zero
 3238b98:	1000dc1e 	bne	r2,zero,3238f0c <tcp_usrreq+0x6e4>
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
 3238b9c:	0080c9b4 	movhi	r2,806
 3238ba0:	10b39c04 	addi	r2,r2,-12688
 3238ba4:	10800417 	ldw	r2,16(r2)
 3238ba8:	10c00044 	addi	r3,r2,1
 3238bac:	0080c9b4 	movhi	r2,806
 3238bb0:	10b39c04 	addi	r2,r2,-12688
 3238bb4:	10c00415 	stw	r3,16(r2)
      break;
 3238bb8:	0000d406 	br	3238f0c <tcp_usrreq+0x6e4>

   /*
    * Create a TCP connection between two sockets.
    */
   case PRU_CONNECT2:
      error = EOPNOTSUPP;
 3238bbc:	008017c4 	movi	r2,95
 3238bc0:	e0bff915 	stw	r2,-28(fp)
      break;
 3238bc4:	0000d106 	br	3238f0c <tcp_usrreq+0x6e4>
    * when peer sends FIN and acks ours.
    *
    * SHOULD IMPLEMENT LATER PRU_CONNECT VIA REALLOC TCPCB.
    */
   case PRU_DISCONNECT:
      SETTP(tp, tcp_disconnect(tp));
 3238bc8:	e13ffa17 	ldw	r4,-24(fp)
 3238bcc:	32390600 	call	3239060 <tcp_disconnect>
      break;
 3238bd0:	0000ce06 	br	3238f0c <tcp_usrreq+0x6e4>
    * done at higher levels; just return the address
    * of the peer, storing through addr.
    */
   case PRU_ACCEPT: 
   {
         struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 3238bd4:	e0bffe17 	ldw	r2,-8(fp)
 3238bd8:	10800317 	ldw	r2,12(r2)
 3238bdc:	e0bff715 	stw	r2,-36(fp)
            IP6CPY(&sin6->sin6_addr, &inp->ip6_faddr);
         }
#endif

#ifdef IP_V4
         if (so->so_domain == AF_INET)
 3238be0:	e0bffc17 	ldw	r2,-16(fp)
 3238be4:	10800517 	ldw	r2,20(r2)
 3238be8:	10800098 	cmpnei	r2,r2,2
 3238bec:	10000e1e 	bne	r2,zero,3238c28 <tcp_usrreq+0x400>
         {
            nam->m_len = sizeof (struct sockaddr_in);
 3238bf0:	e0fffe17 	ldw	r3,-8(fp)
 3238bf4:	00800404 	movi	r2,16
 3238bf8:	18800215 	stw	r2,8(r3)
            sin->sin_family = AF_INET;
 3238bfc:	e0fff717 	ldw	r3,-36(fp)
 3238c00:	00800084 	movi	r2,2
 3238c04:	1880000d 	sth	r2,0(r3)
            sin->sin_port = inp->inp_fport;
 3238c08:	e0bffb17 	ldw	r2,-20(fp)
 3238c0c:	10c0070b 	ldhu	r3,28(r2)
 3238c10:	e0bff717 	ldw	r2,-36(fp)
 3238c14:	10c0008d 	sth	r3,2(r2)
            sin->sin_addr = inp->inp_faddr;
 3238c18:	e0bffb17 	ldw	r2,-20(fp)
 3238c1c:	10c00317 	ldw	r3,12(r2)
 3238c20:	e0bff717 	ldw	r2,-36(fp)
 3238c24:	10c00115 	stw	r3,4(r2)
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 3238c28:	e0bffc17 	ldw	r2,-16(fp)
 3238c2c:	10800517 	ldw	r2,20(r2)
 3238c30:	108000a0 	cmpeqi	r2,r2,2
 3238c34:	10000a1e 	bne	r2,zero,3238c60 <tcp_usrreq+0x438>
 3238c38:	e0bffc17 	ldw	r2,-16(fp)
 3238c3c:	10800517 	ldw	r2,20(r2)
 3238c40:	108000e0 	cmpeqi	r2,r2,3
 3238c44:	1000061e 	bne	r2,zero,3238c60 <tcp_usrreq+0x438>
              !(so->so_domain == AF_INET6)
             )
         {
            dprintf("*** PRU_ACCEPT bad domain = %d\n", so->so_domain);
 3238c48:	e0bffc17 	ldw	r2,-16(fp)
 3238c4c:	11400517 	ldw	r5,20(r2)
 3238c50:	0100c974 	movhi	r4,805
 3238c54:	213d8b04 	addi	r4,r4,-2516
 3238c58:	3206adc0 	call	3206adc <printf>
            dtrap();
 3238c5c:	322ab8c0 	call	322ab8c <dtrap>
         } 
         TCP_MIB_INC(tcpPassiveOpens);    /* keep MIB stats */
 3238c60:	0080c9b4 	movhi	r2,806
 3238c64:	10b39c04 	addi	r2,r2,-12688
 3238c68:	10800517 	ldw	r2,20(r2)
 3238c6c:	10c00044 	addi	r3,r2,1
 3238c70:	0080c9b4 	movhi	r2,806
 3238c74:	10b39c04 	addi	r2,r2,-12688
 3238c78:	10c00515 	stw	r3,20(r2)
         break;
 3238c7c:	0000a306 	br	3238f0c <tcp_usrreq+0x6e4>

   /*
    * Mark the connection as being incapable of further output.
    */
   case PRU_SHUTDOWN:
      socantsendmore(so);
 3238c80:	e13ffc17 	ldw	r4,-16(fp)
 3238c84:	3231dcc0 	call	3231dcc <socantsendmore>
      tp = tcp_usrclosed(tp);
 3238c88:	e13ffa17 	ldw	r4,-24(fp)
 3238c8c:	32391340 	call	3239134 <tcp_usrclosed>
 3238c90:	e0bffa15 	stw	r2,-24(fp)
      if (tp)
 3238c94:	e0bffa17 	ldw	r2,-24(fp)
 3238c98:	1005003a 	cmpeq	r2,r2,zero
 3238c9c:	10009b1e 	bne	r2,zero,3238f0c <tcp_usrreq+0x6e4>
         error = tcp_output(tp);
 3238ca0:	e13ffa17 	ldw	r4,-24(fp)
 3238ca4:	32363480 	call	3236348 <tcp_output>
 3238ca8:	e0bff915 	stw	r2,-28(fp)
      break;
 3238cac:	00009706 	br	3238f0c <tcp_usrreq+0x6e4>

   /*
    * After a receive, possibly send window update to peer.
    */
   case PRU_RCVD:
      (void) tcp_output(tp);
 3238cb0:	e13ffa17 	ldw	r4,-24(fp)
 3238cb4:	32363480 	call	3236348 <tcp_output>
      break;
 3238cb8:	00009406 	br	3238f0c <tcp_usrreq+0x6e4>
   /*
    * Do a send by putting data in output queue and updating urgent
    * marker if URG set.  Possibly send more data.
    */
   case PRU_SEND:
      if (so->so_pcb == NULL)
 3238cbc:	e0bffc17 	ldw	r2,-16(fp)
 3238cc0:	10800117 	ldw	r2,4(r2)
 3238cc4:	1004c03a 	cmpne	r2,r2,zero
 3238cc8:	1000031e 	bne	r2,zero,3238cd8 <tcp_usrreq+0x4b0>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 3238ccc:	00800804 	movi	r2,32
 3238cd0:	e0bff915 	stw	r2,-28(fp)
         break;
 3238cd4:	00008d06 	br	3238f0c <tcp_usrreq+0x6e4>
      }
      sbappend(&so->so_snd, m);
 3238cd8:	e0bffc17 	ldw	r2,-16(fp)
 3238cdc:	11001204 	addi	r4,r2,72
 3238ce0:	e17ffd17 	ldw	r5,-12(fp)
 3238ce4:	32320d00 	call	32320d0 <sbappend>
      error = tcp_output(tp);
 3238ce8:	e13ffa17 	ldw	r4,-24(fp)
 3238cec:	32363480 	call	3236348 <tcp_output>
 3238cf0:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 3238cf4:	e0bff917 	ldw	r2,-28(fp)
 3238cf8:	10801a58 	cmpnei	r2,r2,105
 3238cfc:	1000831e 	bne	r2,zero,3238f0c <tcp_usrreq+0x6e4>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 3238d00:	e0bffc17 	ldw	r2,-16(fp)
 3238d04:	11001204 	addi	r4,r2,72
 3238d08:	e17ffd17 	ldw	r5,-12(fp)
 3238d0c:	32328a80 	call	32328a8 <sbdropend>
      break;
 3238d10:	00007e06 	br	3238f0c <tcp_usrreq+0x6e4>

   /*
    * Abort the TCP.
    */
   case PRU_ABORT:
      SETTP(tp, tcp_drop(tp, ECONNABORTED));
 3238d14:	e13ffa17 	ldw	r4,-24(fp)
 3238d18:	01401c44 	movi	r5,113
 3238d1c:	3237db80 	call	3237db8 <tcp_drop>
      break;
 3238d20:	00007a06 	br	3238f0c <tcp_usrreq+0x6e4>

   case PRU_SENSE:
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
 3238d24:	322ab8c0 	call	322ab8c <dtrap>
      return (0);
 3238d28:	e03fff15 	stw	zero,-4(fp)
 3238d2c:	00007906 	br	3238f14 <tcp_usrreq+0x6ec>

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 3238d30:	e0bffc17 	ldw	r2,-16(fp)
 3238d34:	10801a17 	ldw	r2,104(r2)
 3238d38:	1004c03a 	cmpne	r2,r2,zero
 3238d3c:	1000061e 	bne	r2,zero,3238d58 <tcp_usrreq+0x530>
 3238d40:	e0bffc17 	ldw	r2,-16(fp)
 3238d44:	1080088b 	ldhu	r2,34(r2)
 3238d48:	10bfffcc 	andi	r2,r2,65535
 3238d4c:	1080100c 	andi	r2,r2,64
 3238d50:	1005003a 	cmpeq	r2,r2,zero
 3238d54:	10000b1e 	bne	r2,zero,3238d84 <tcp_usrreq+0x55c>
 3238d58:	e0bffc17 	ldw	r2,-16(fp)
 3238d5c:	10800417 	ldw	r2,16(r2)
 3238d60:	1080400c 	andi	r2,r2,256
 3238d64:	1004c03a 	cmpne	r2,r2,zero
 3238d68:	1000061e 	bne	r2,zero,3238d84 <tcp_usrreq+0x55c>
 3238d6c:	e0bffa17 	ldw	r2,-24(fp)
 3238d70:	10802403 	ldbu	r2,144(r2)
 3238d74:	10803fcc 	andi	r2,r2,255
 3238d78:	1080008c 	andi	r2,r2,2
 3238d7c:	1005003a 	cmpeq	r2,r2,zero
 3238d80:	1000031e 	bne	r2,zero,3238d90 <tcp_usrreq+0x568>
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
       {
         error = EINVAL;
 3238d84:	00800584 	movi	r2,22
 3238d88:	e0bff915 	stw	r2,-28(fp)
         break;
 3238d8c:	00005f06 	br	3238f0c <tcp_usrreq+0x6e4>
      }
      if ((tp->t_oobflags & TCPOOB_HAVEDATA) == 0) 
 3238d90:	e0bffa17 	ldw	r2,-24(fp)
 3238d94:	10802403 	ldbu	r2,144(r2)
 3238d98:	10803fcc 	andi	r2,r2,255
 3238d9c:	1080004c 	andi	r2,r2,1
 3238da0:	1004c03a 	cmpne	r2,r2,zero
 3238da4:	1000031e 	bne	r2,zero,3238db4 <tcp_usrreq+0x58c>
      {
         error = EWOULDBLOCK;
 3238da8:	008002c4 	movi	r2,11
 3238dac:	e0bff915 	stw	r2,-28(fp)
         break;
 3238db0:	00005606 	br	3238f0c <tcp_usrreq+0x6e4>
      }
      m->m_len = 1;
 3238db4:	e0fffd17 	ldw	r3,-12(fp)
 3238db8:	00800044 	movi	r2,1
 3238dbc:	18800215 	stw	r2,8(r3)
      *mtod(m, char *) = tp->t_iobc;
 3238dc0:	e0bffd17 	ldw	r2,-12(fp)
 3238dc4:	10c00317 	ldw	r3,12(r2)
 3238dc8:	e0bffa17 	ldw	r2,-24(fp)
 3238dcc:	10802443 	ldbu	r2,145(r2)
 3238dd0:	18800005 	stb	r2,0(r3)
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
 3238dd4:	e0bffe17 	ldw	r2,-8(fp)
 3238dd8:	1080008c 	andi	r2,r2,2
 3238ddc:	1004c03a 	cmpne	r2,r2,zero
 3238de0:	10004a1e 	bne	r2,zero,3238f0c <tcp_usrreq+0x6e4>
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 3238de4:	e0bffa17 	ldw	r2,-24(fp)
 3238de8:	10802403 	ldbu	r2,144(r2)
 3238dec:	108000dc 	xori	r2,r2,3
 3238df0:	1007883a 	mov	r3,r2
 3238df4:	e0bffa17 	ldw	r2,-24(fp)
 3238df8:	10c02405 	stb	r3,144(r2)
      break;
 3238dfc:	00004306 	br	3238f0c <tcp_usrreq+0x6e4>

   case PRU_SENDOOB:
      if (so->so_pcb == NULL)
 3238e00:	e0bffc17 	ldw	r2,-16(fp)
 3238e04:	10800117 	ldw	r2,4(r2)
 3238e08:	1004c03a 	cmpne	r2,r2,zero
 3238e0c:	1000031e 	bne	r2,zero,3238e1c <tcp_usrreq+0x5f4>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 3238e10:	00800804 	movi	r2,32
 3238e14:	e0bff915 	stw	r2,-28(fp)
         break;
 3238e18:	00003c06 	br	3238f0c <tcp_usrreq+0x6e4>
      }
      if (sbspace(&so->so_snd) == 0) 
 3238e1c:	e0bffc17 	ldw	r2,-16(fp)
 3238e20:	10801317 	ldw	r2,76(r2)
 3238e24:	1007883a 	mov	r3,r2
 3238e28:	e0bffc17 	ldw	r2,-16(fp)
 3238e2c:	10801217 	ldw	r2,72(r2)
 3238e30:	1885c83a 	sub	r2,r3,r2
 3238e34:	1004803a 	cmplt	r2,r2,zero
 3238e38:	1000051e 	bne	r2,zero,3238e50 <tcp_usrreq+0x628>
 3238e3c:	e0bffc17 	ldw	r2,-16(fp)
 3238e40:	10c01317 	ldw	r3,76(r2)
 3238e44:	e0bffc17 	ldw	r2,-16(fp)
 3238e48:	10801217 	ldw	r2,72(r2)
 3238e4c:	1880051e 	bne	r3,r2,3238e64 <tcp_usrreq+0x63c>
      {
         m_freem(m);
 3238e50:	e13ffd17 	ldw	r4,-12(fp)
 3238e54:	322bc680 	call	322bc68 <m_freem>
         error = ENOBUFS;
 3238e58:	00801a44 	movi	r2,105
 3238e5c:	e0bff915 	stw	r2,-28(fp)
         break;
 3238e60:	00002a06 	br	3238f0c <tcp_usrreq+0x6e4>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section.
       * Otherwise, snd_up should be one lower.
       */
      sbappend(&so->so_snd, m);
 3238e64:	e0bffc17 	ldw	r2,-16(fp)
 3238e68:	11001204 	addi	r4,r2,72
 3238e6c:	e17ffd17 	ldw	r5,-12(fp)
 3238e70:	32320d00 	call	32320d0 <sbappend>
      tp->snd_up = tp->snd_una + so->so_snd.sb_cc;
 3238e74:	e0bffa17 	ldw	r2,-24(fp)
 3238e78:	10c00e17 	ldw	r3,56(r2)
 3238e7c:	e0bffc17 	ldw	r2,-16(fp)
 3238e80:	10801217 	ldw	r2,72(r2)
 3238e84:	1887883a 	add	r3,r3,r2
 3238e88:	e0bffa17 	ldw	r2,-24(fp)
 3238e8c:	10c01015 	stw	r3,64(r2)
      tp->t_force = 1;
 3238e90:	e0fffa17 	ldw	r3,-24(fp)
 3238e94:	00800044 	movi	r2,1
 3238e98:	18800a85 	stb	r2,42(r3)
      error = tcp_output(tp);
 3238e9c:	e13ffa17 	ldw	r4,-24(fp)
 3238ea0:	32363480 	call	3236348 <tcp_output>
 3238ea4:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 3238ea8:	e0bff917 	ldw	r2,-28(fp)
 3238eac:	10801a58 	cmpnei	r2,r2,105
 3238eb0:	1000041e 	bne	r2,zero,3238ec4 <tcp_usrreq+0x69c>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 3238eb4:	e0bffc17 	ldw	r2,-16(fp)
 3238eb8:	11001204 	addi	r4,r2,72
 3238ebc:	e17ffd17 	ldw	r5,-12(fp)
 3238ec0:	32328a80 	call	32328a8 <sbdropend>
      tp->t_force = 0;
 3238ec4:	e0bffa17 	ldw	r2,-24(fp)
 3238ec8:	10000a85 	stb	zero,42(r2)
      break;
 3238ecc:	00000f06 	br	3238f0c <tcp_usrreq+0x6e4>
   case PRU_SOCKADDR:

   /* sockaddr and peeraddr have to switch based on IP type */
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setsockaddr(inp, nam);
 3238ed0:	e13ffb17 	ldw	r4,-20(fp)
 3238ed4:	e17ffe17 	ldw	r5,-8(fp)
 3238ed8:	324842c0 	call	324842c <in_setsockaddr>
         in_setsockaddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setsockaddr(inp, nam);
#endif
      break;         
 3238edc:	00000b06 	br	3238f0c <tcp_usrreq+0x6e4>

   case PRU_PEERADDR:
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setpeeraddr(inp, nam);
 3238ee0:	e13ffb17 	ldw	r4,-20(fp)
 3238ee4:	e17ffe17 	ldw	r5,-8(fp)
 3238ee8:	32484a80 	call	32484a8 <in_setpeeraddr>
         in_setpeeraddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setpeeraddr(inp, nam);
#endif
      break;
 3238eec:	00000706 	br	3238f0c <tcp_usrreq+0x6e4>

   case PRU_SLOWTIMO:
      SETTP(tp, tcp_timers(tp, (int)MBUF2LONG(nam)));
 3238ef0:	e17ffe17 	ldw	r5,-8(fp)
 3238ef4:	e13ffa17 	ldw	r4,-24(fp)
 3238ef8:	323838c0 	call	323838c <tcp_timers>
#ifdef DO_TCPTRACE
      req |= (long)nam << 8;        /* for debug's sake */
#endif
      break;
 3238efc:	00000306 	br	3238f0c <tcp_usrreq+0x6e4>

      default:
      panic("tcp_usrreq");
 3238f00:	0100c974 	movhi	r4,805
 3238f04:	213d9304 	addi	r4,r4,-2484
 3238f08:	3225df00 	call	3225df0 <panic>
#ifdef DO_TCPTRACE
   if (tp && (so->so_options & SO_DEBUG))
      tcp_trace("usrreq: state: %d, tcpcb: %x, req: %d",
    ostate, tp, req);
#endif
   return (error);
 3238f0c:	e0bff917 	ldw	r2,-28(fp)
 3238f10:	e0bfff15 	stw	r2,-4(fp)
 3238f14:	e0bfff17 	ldw	r2,-4(fp)
}
 3238f18:	e037883a 	mov	sp,fp
 3238f1c:	dfc00117 	ldw	ra,4(sp)
 3238f20:	df000017 	ldw	fp,0(sp)
 3238f24:	dec00204 	addi	sp,sp,8
 3238f28:	f800283a 	ret

03238f2c <tcp_attach>:
 * RETURNS: 0 if OK, or nonzero error code.
 */

int
tcp_attach(struct socket * so)
{
 3238f2c:	defff804 	addi	sp,sp,-32
 3238f30:	dfc00715 	stw	ra,28(sp)
 3238f34:	df000615 	stw	fp,24(sp)
 3238f38:	df000604 	addi	fp,sp,24
 3238f3c:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
   struct inpcb * inp;
   int   error;

   if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) 
 3238f40:	e0bffe17 	ldw	r2,-8(fp)
 3238f44:	10801317 	ldw	r2,76(r2)
 3238f48:	1005003a 	cmpeq	r2,r2,zero
 3238f4c:	1000041e 	bne	r2,zero,3238f60 <tcp_attach+0x34>
 3238f50:	e0bffe17 	ldw	r2,-8(fp)
 3238f54:	10800b17 	ldw	r2,44(r2)
 3238f58:	1004c03a 	cmpne	r2,r2,zero
 3238f5c:	10000b1e 	bne	r2,zero,3238f8c <tcp_attach+0x60>
   {
      error = soreserve(so, tcp_sendspace, tcp_recvspace);
 3238f60:	d1603c17 	ldw	r5,-32528(gp)
 3238f64:	d1a03d17 	ldw	r6,-32524(gp)
 3238f68:	e13ffe17 	ldw	r4,-8(fp)
 3238f6c:	3231fa80 	call	3231fa8 <soreserve>
 3238f70:	e0bffb15 	stw	r2,-20(fp)
      if (error)
 3238f74:	e0bffb17 	ldw	r2,-20(fp)
 3238f78:	1005003a 	cmpeq	r2,r2,zero
 3238f7c:	1000031e 	bne	r2,zero,3238f8c <tcp_attach+0x60>
         return (error);
 3238f80:	e0bffb17 	ldw	r2,-20(fp)
 3238f84:	e0bfff15 	stw	r2,-4(fp)
 3238f88:	00002f06 	br	3239048 <tcp_attach+0x11c>
   }
   error = in_pcballoc(so, &tcb);
 3238f8c:	e13ffe17 	ldw	r4,-8(fp)
 3238f90:	0140c9b4 	movhi	r5,806
 3238f94:	2973bf04 	addi	r5,r5,-12548
 3238f98:	3247e800 	call	3247e80 <in_pcballoc>
 3238f9c:	e0bffb15 	stw	r2,-20(fp)
   if (error)
 3238fa0:	e0bffb17 	ldw	r2,-20(fp)
 3238fa4:	1005003a 	cmpeq	r2,r2,zero
 3238fa8:	1000031e 	bne	r2,zero,3238fb8 <tcp_attach+0x8c>
      return (error);
 3238fac:	e0bffb17 	ldw	r2,-20(fp)
 3238fb0:	e0bfff15 	stw	r2,-4(fp)
 3238fb4:	00002406 	br	3239048 <tcp_attach+0x11c>
   inp = sotoinpcb(so);
 3238fb8:	e0bffe17 	ldw	r2,-8(fp)
 3238fbc:	10800117 	ldw	r2,4(r2)
 3238fc0:	e0bffc15 	stw	r2,-16(fp)
   tp = tcp_newtcpcb(inp);
 3238fc4:	e13ffc17 	ldw	r4,-16(fp)
 3238fc8:	3237ca00 	call	3237ca0 <tcp_newtcpcb>
 3238fcc:	e0bffd15 	stw	r2,-12(fp)
   if (tp == 0) 
 3238fd0:	e0bffd17 	ldw	r2,-12(fp)
 3238fd4:	1004c03a 	cmpne	r2,r2,zero
 3238fd8:	1000181e 	bne	r2,zero,323903c <tcp_attach+0x110>
   {
      int   nofd  =  so->so_state   &  SS_NOFDREF; /* XXX */
 3238fdc:	e0bffe17 	ldw	r2,-8(fp)
 3238fe0:	1080088b 	ldhu	r2,34(r2)
 3238fe4:	10bfffcc 	andi	r2,r2,65535
 3238fe8:	1080004c 	andi	r2,r2,1
 3238fec:	e0bffa15 	stw	r2,-24(fp)

      so->so_state &= ~SS_NOFDREF;     /* don't free the socket yet */
 3238ff0:	e0bffe17 	ldw	r2,-8(fp)
 3238ff4:	10c0088b 	ldhu	r3,34(r2)
 3238ff8:	00bfff84 	movi	r2,-2
 3238ffc:	1884703a 	and	r2,r3,r2
 3239000:	1007883a 	mov	r3,r2
 3239004:	e0bffe17 	ldw	r2,-8(fp)
 3239008:	10c0088d 	sth	r3,34(r2)
      in_pcbdetach(inp);
 323900c:	e13ffc17 	ldw	r4,-16(fp)
 3239010:	3247f140 	call	3247f14 <in_pcbdetach>
      so->so_state |= nofd;
 3239014:	e0bffe17 	ldw	r2,-8(fp)
 3239018:	10c0088b 	ldhu	r3,34(r2)
 323901c:	e0bffa17 	ldw	r2,-24(fp)
 3239020:	1884b03a 	or	r2,r3,r2
 3239024:	1007883a 	mov	r3,r2
 3239028:	e0bffe17 	ldw	r2,-8(fp)
 323902c:	10c0088d 	sth	r3,34(r2)
      return (ENOBUFS);
 3239030:	00801a44 	movi	r2,105
 3239034:	e0bfff15 	stw	r2,-4(fp)
 3239038:	00000306 	br	3239048 <tcp_attach+0x11c>
   }
   tp->t_state = TCPS_CLOSED;
 323903c:	e0bffd17 	ldw	r2,-12(fp)
 3239040:	10000215 	stw	zero,8(r2)
   return (0);
 3239044:	e03fff15 	stw	zero,-4(fp)
 3239048:	e0bfff17 	ldw	r2,-4(fp)
}
 323904c:	e037883a 	mov	sp,fp
 3239050:	dfc00117 	ldw	ra,4(sp)
 3239054:	df000017 	ldw	fp,0(sp)
 3239058:	dec00204 	addi	sp,sp,8
 323905c:	f800283a 	ret

03239060 <tcp_disconnect>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_disconnect(struct tcpcb * tp)
{
 3239060:	defffc04 	addi	sp,sp,-16
 3239064:	dfc00315 	stw	ra,12(sp)
 3239068:	df000215 	stw	fp,8(sp)
 323906c:	df000204 	addi	fp,sp,8
 3239070:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 3239074:	e0bfff17 	ldw	r2,-4(fp)
 3239078:	10800d17 	ldw	r2,52(r2)
 323907c:	10800817 	ldw	r2,32(r2)
 3239080:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_state < TCPS_ESTABLISHED)
 3239084:	e0bfff17 	ldw	r2,-4(fp)
 3239088:	10800217 	ldw	r2,8(r2)
 323908c:	10800108 	cmpgei	r2,r2,4
 3239090:	1000041e 	bne	r2,zero,32390a4 <tcp_disconnect+0x44>
      tp = tcp_close(tp);
 3239094:	e13fff17 	ldw	r4,-4(fp)
 3239098:	3237e640 	call	3237e64 <tcp_close>
 323909c:	e0bfff15 	stw	r2,-4(fp)
 32390a0:	00001e06 	br	323911c <tcp_disconnect+0xbc>
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 32390a4:	e0bffe17 	ldw	r2,-8(fp)
 32390a8:	10800417 	ldw	r2,16(r2)
 32390ac:	1080200c 	andi	r2,r2,128
 32390b0:	1005003a 	cmpeq	r2,r2,zero
 32390b4:	10000c1e 	bne	r2,zero,32390e8 <tcp_disconnect+0x88>
 32390b8:	e0bffe17 	ldw	r2,-8(fp)
 32390bc:	1080080b 	ldhu	r2,32(r2)
 32390c0:	10bfffcc 	andi	r2,r2,65535
 32390c4:	10a0001c 	xori	r2,r2,32768
 32390c8:	10a00004 	addi	r2,r2,-32768
 32390cc:	1004c03a 	cmpne	r2,r2,zero
 32390d0:	1000051e 	bne	r2,zero,32390e8 <tcp_disconnect+0x88>
      tp = tcp_drop(tp, 0);
 32390d4:	e13fff17 	ldw	r4,-4(fp)
 32390d8:	000b883a 	mov	r5,zero
 32390dc:	3237db80 	call	3237db8 <tcp_drop>
 32390e0:	e0bfff15 	stw	r2,-4(fp)
{
   struct socket *   so =  tp->t_inpcb->inp_socket;

   if (tp->t_state < TCPS_ESTABLISHED)
      tp = tcp_close(tp);
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 32390e4:	00000d06 	br	323911c <tcp_disconnect+0xbc>
      tp = tcp_drop(tp, 0);
   else 
   {
      soisdisconnecting(so);
 32390e8:	e13ffe17 	ldw	r4,-8(fp)
 32390ec:	323189c0 	call	323189c <soisdisconnecting>
      sbflush(&so->so_rcv);
 32390f0:	e0bffe17 	ldw	r2,-8(fp)
 32390f4:	11000a04 	addi	r4,r2,40
 32390f8:	32326480 	call	3232648 <sbflush>
      tp = tcp_usrclosed(tp);
 32390fc:	e13fff17 	ldw	r4,-4(fp)
 3239100:	32391340 	call	3239134 <tcp_usrclosed>
 3239104:	e0bfff15 	stw	r2,-4(fp)
      if (tp)
 3239108:	e0bfff17 	ldw	r2,-4(fp)
 323910c:	1005003a 	cmpeq	r2,r2,zero
 3239110:	1000021e 	bne	r2,zero,323911c <tcp_disconnect+0xbc>
         (void) tcp_output(tp);
 3239114:	e13fff17 	ldw	r4,-4(fp)
 3239118:	32363480 	call	3236348 <tcp_output>
   }
   return (tp);
 323911c:	e0bfff17 	ldw	r2,-4(fp)
}
 3239120:	e037883a 	mov	sp,fp
 3239124:	dfc00117 	ldw	ra,4(sp)
 3239128:	df000017 	ldw	fp,0(sp)
 323912c:	dec00204 	addi	sp,sp,8
 3239130:	f800283a 	ret

03239134 <tcp_usrclosed>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_usrclosed(struct tcpcb * tp)
{
 3239134:	defffc04 	addi	sp,sp,-16
 3239138:	dfc00315 	stw	ra,12(sp)
 323913c:	df000215 	stw	fp,8(sp)
 3239140:	df000204 	addi	fp,sp,8
 3239144:	e13ffe15 	stw	r4,-8(fp)

   switch (tp->t_state) 
 3239148:	e0bffe17 	ldw	r2,-8(fp)
 323914c:	10800217 	ldw	r2,8(r2)
 3239150:	e0bfff15 	stw	r2,-4(fp)
 3239154:	e0ffff17 	ldw	r3,-4(fp)
 3239158:	188001a8 	cmpgeui	r2,r3,6
 323915c:	10001c1e 	bne	r2,zero,32391d0 <tcp_usrclosed+0x9c>
 3239160:	e13fff17 	ldw	r4,-4(fp)
 3239164:	e13fff17 	ldw	r4,-4(fp)
 3239168:	2105883a 	add	r2,r4,r4
 323916c:	1087883a 	add	r3,r2,r2
 3239170:	0080c934 	movhi	r2,804
 3239174:	10a46104 	addi	r2,r2,-28284
 3239178:	1885883a 	add	r2,r3,r2
 323917c:	10800017 	ldw	r2,0(r2)
 3239180:	1000683a 	jmp	r2
 3239184:	0323919c 	xori	r12,zero,36422
 3239188:	0323919c 	xori	r12,zero,36422
 323918c:	0323919c 	xori	r12,zero,36422
 3239190:	032391b4 	movhi	r12,36422
 3239194:	032391b4 	movhi	r12,36422
 3239198:	032391c4 	movi	r12,-29113
   {
   case TCPS_CLOSED:
   case TCPS_LISTEN:
   case TCPS_SYN_SENT:
      tp->t_state = TCPS_CLOSED;
 323919c:	e0bffe17 	ldw	r2,-8(fp)
 32391a0:	10000215 	stw	zero,8(r2)
      tp = tcp_close(tp);
 32391a4:	e13ffe17 	ldw	r4,-8(fp)
 32391a8:	3237e640 	call	3237e64 <tcp_close>
 32391ac:	e0bffe15 	stw	r2,-8(fp)
      break;
 32391b0:	00000706 	br	32391d0 <tcp_usrclosed+0x9c>

   case TCPS_SYN_RECEIVED:
   case TCPS_ESTABLISHED:
      tp->t_state = TCPS_FIN_WAIT_1;
 32391b4:	e0fffe17 	ldw	r3,-8(fp)
 32391b8:	00800184 	movi	r2,6
 32391bc:	18800215 	stw	r2,8(r3)
      break;
 32391c0:	00000306 	br	32391d0 <tcp_usrclosed+0x9c>

   case TCPS_CLOSE_WAIT:
      tp->t_state = TCPS_LAST_ACK;
 32391c4:	e0fffe17 	ldw	r3,-8(fp)
 32391c8:	00800204 	movi	r2,8
 32391cc:	18800215 	stw	r2,8(r3)
      break;
   }
   if (tp && tp->t_state >= TCPS_FIN_WAIT_2)
 32391d0:	e0bffe17 	ldw	r2,-8(fp)
 32391d4:	1005003a 	cmpeq	r2,r2,zero
 32391d8:	1000081e 	bne	r2,zero,32391fc <tcp_usrclosed+0xc8>
 32391dc:	e0bffe17 	ldw	r2,-8(fp)
 32391e0:	10800217 	ldw	r2,8(r2)
 32391e4:	10800250 	cmplti	r2,r2,9
 32391e8:	1000041e 	bne	r2,zero,32391fc <tcp_usrclosed+0xc8>
      soisdisconnected(tp->t_inpcb->inp_socket);
 32391ec:	e0bffe17 	ldw	r2,-8(fp)
 32391f0:	10800d17 	ldw	r2,52(r2)
 32391f4:	11000817 	ldw	r4,32(r2)
 32391f8:	32319280 	call	3231928 <soisdisconnected>
   return (tp);
 32391fc:	e0bffe17 	ldw	r2,-8(fp)
}
 3239200:	e037883a 	mov	sp,fp
 3239204:	dfc00117 	ldw	ra,4(sp)
 3239208:	df000017 	ldw	fp,0(sp)
 323920c:	dec00204 	addi	sp,sp,8
 3239210:	f800283a 	ret

03239214 <tcpinit>:
 * RETURNS: 0 if OK, else one of the ENP_ error codes
 */

int
tcpinit(void)
{
 3239214:	defffc04 	addi	sp,sp,-16
 3239218:	dfc00315 	stw	ra,12(sp)
 323921c:	df000215 	stw	fp,8(sp)
 3239220:	df000204 	addi	fp,sp,8
   tcp_sendspace = (TCP_MSS) * 2;
   tcp_recvspace = (TCP_MSS) * 2;
   TCPTV_MSL =    (4 * PR_SLOWHZ);     /* max seg lifetime default */
#endif

   e = nptcp_init();    /* call the NetPort init in nptcp.c */
 3239224:	322c38c0 	call	322c38c <nptcp_init>
 3239228:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 323922c:	e0bffe17 	ldw	r2,-8(fp)
 3239230:	1005003a 	cmpeq	r2,r2,zero
 3239234:	1000031e 	bne	r2,zero,3239244 <tcpinit+0x30>
      return e;
 3239238:	e0bffe17 	ldw	r2,-8(fp)
 323923c:	e0bfff15 	stw	r2,-4(fp)
 3239240:	00000106 	br	3239248 <tcpinit+0x34>

   return 0;   /* good return */
 3239244:	e03fff15 	stw	zero,-4(fp)
 3239248:	e0bfff17 	ldw	r2,-4(fp)
}
 323924c:	e037883a 	mov	sp,fp
 3239250:	dfc00117 	ldw	ra,4(sp)
 3239254:	df000017 	ldw	fp,0(sp)
 3239258:	dec00204 	addi	sp,sp,8
 323925c:	f800283a 	ret

03239260 <udp_lookup>:
 * RETURNS: 
 */

UDPCONN
udp_lookup(struct socket * so)
{
 3239260:	defffc04 	addi	sp,sp,-16
 3239264:	df000315 	stw	fp,12(sp)
 3239268:	df000304 	addi	fp,sp,12
 323926c:	e13ffe15 	stw	r4,-8(fp)
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 3239270:	0080c974 	movhi	r2,805
 3239274:	10924a04 	addi	r2,r2,18728
 3239278:	10800017 	ldw	r2,0(r2)
 323927c:	e0bffd15 	stw	r2,-12(fp)
 3239280:	00000a06 	br	32392ac <udp_lookup+0x4c>
      if (tmp->u_data == (void*)so)
 3239284:	e0bffd17 	ldw	r2,-12(fp)
 3239288:	10c00617 	ldw	r3,24(r2)
 323928c:	e0bffe17 	ldw	r2,-8(fp)
 3239290:	1880031e 	bne	r3,r2,32392a0 <udp_lookup+0x40>
      return (tmp);
 3239294:	e0bffd17 	ldw	r2,-12(fp)
 3239298:	e0bfff15 	stw	r2,-4(fp)
 323929c:	00000706 	br	32392bc <udp_lookup+0x5c>
UDPCONN
udp_lookup(struct socket * so)
{
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 32392a0:	e0bffd17 	ldw	r2,-12(fp)
 32392a4:	10800017 	ldw	r2,0(r2)
 32392a8:	e0bffd15 	stw	r2,-12(fp)
 32392ac:	e0bffd17 	ldw	r2,-12(fp)
 32392b0:	1004c03a 	cmpne	r2,r2,zero
 32392b4:	103ff31e 	bne	r2,zero,3239284 <udp_lookup+0x24>
      if (tmp->u_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 32392b8:	e03fff15 	stw	zero,-4(fp)
 32392bc:	e0bfff17 	ldw	r2,-4(fp)
}
 32392c0:	e037883a 	mov	sp,fp
 32392c4:	df000017 	ldw	fp,0(sp)
 32392c8:	dec00104 	addi	sp,sp,4
 32392cc:	f800283a 	ret

032392d0 <udp_soinput>:
 * RETURNS: 
 */

int
udp_soinput(PACKET pkt, void * so_ptr)
{
 32392d0:	defff404 	addi	sp,sp,-48
 32392d4:	dfc00b15 	stw	ra,44(sp)
 32392d8:	df000a15 	stw	fp,40(sp)
 32392dc:	df000a04 	addi	fp,sp,40
 32392e0:	e13ffd15 	stw	r4,-12(fp)
 32392e4:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 32392e8:	e0bffe17 	ldw	r2,-8(fp)
 32392ec:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;
   struct udp *   udpp;

   LOCK_NET_RESOURCE(NET_RESID); 
 32392f0:	0009883a 	mov	r4,zero
 32392f4:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 32392f8:	e0bff717 	ldw	r2,-36(fp)
 32392fc:	10c00a17 	ldw	r3,40(r2)
 3239300:	e0bffd17 	ldw	r2,-12(fp)
 3239304:	10800417 	ldw	r2,16(r2)
 3239308:	1887883a 	add	r3,r3,r2
 323930c:	e0bff717 	ldw	r2,-36(fp)
 3239310:	10800b17 	ldw	r2,44(r2)
 3239314:	18800536 	bltu	r3,r2,323932c <udp_soinput+0x5c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 3239318:	0009883a 	mov	r4,zero
 323931c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 3239320:	00801a44 	movi	r2,105
 3239324:	e0bfff15 	stw	r2,-4(fp)
 3239328:	00005106 	br	3239470 <udp_soinput+0x1a0>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 323932c:	01000044 	movi	r4,1
 3239330:	000b883a 	mov	r5,zero
 3239334:	322b98c0 	call	322b98c <m_getnbuf>
 3239338:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 323933c:	e0bff817 	ldw	r2,-32(fp)
 3239340:	1004c03a 	cmpne	r2,r2,zero
 3239344:	1000051e 	bne	r2,zero,323935c <udp_soinput+0x8c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 3239348:	0009883a 	mov	r4,zero
 323934c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 3239350:	00801a44 	movi	r2,105
 3239354:	e0bfff15 	stw	r2,-4(fp)
 3239358:	00004506 	br	3239470 <udp_soinput+0x1a0>
   }

   /* set data mbuf to point to start of UDP data */
   m_in->pkt = pkt;
 323935c:	e0fff817 	ldw	r3,-32(fp)
 3239360:	e0bffd17 	ldw	r2,-12(fp)
 3239364:	18800115 	stw	r2,4(r3)
   m_in->m_data = pkt->nb_prot;
 3239368:	e0bffd17 	ldw	r2,-12(fp)
 323936c:	10c00317 	ldw	r3,12(r2)
 3239370:	e0bff817 	ldw	r2,-32(fp)
 3239374:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 3239378:	e0bffd17 	ldw	r2,-12(fp)
 323937c:	10c00417 	ldw	r3,16(r2)
 3239380:	e0bff817 	ldw	r2,-32(fp)
 3239384:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;
 3239388:	e0bffd17 	ldw	r2,-12(fp)
 323938c:	10c00117 	ldw	r3,4(r2)
 3239390:	e0bff817 	ldw	r2,-32(fp)
 3239394:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 3239398:	e0bffd17 	ldw	r2,-12(fp)
 323939c:	10c00217 	ldw	r3,8(r2)
 32393a0:	e0bff817 	ldw	r2,-32(fp)
 32393a4:	10c00515 	stw	r3,20(r2)

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 32393a8:	e0bffd17 	ldw	r2,-12(fp)
 32393ac:	10800717 	ldw	r2,28(r2)
 32393b0:	e0bffa15 	stw	r2,-24(fp)
   udpp = (struct udp *)(pkt->nb_prot - sizeof(struct udp));
 32393b4:	e0bffd17 	ldw	r2,-12(fp)
 32393b8:	10800317 	ldw	r2,12(r2)
 32393bc:	10bffe04 	addi	r2,r2,-8
 32393c0:	e0bff615 	stw	r2,-40(fp)
   sin.sin_port = htons(udpp->ud_srcp);
 32393c4:	e0bff617 	ldw	r2,-40(fp)
 32393c8:	1080000b 	ldhu	r2,0(r2)
 32393cc:	10bfffcc 	andi	r2,r2,65535
 32393d0:	1004d23a 	srli	r2,r2,8
 32393d4:	10803fcc 	andi	r2,r2,255
 32393d8:	1009883a 	mov	r4,r2
 32393dc:	e0bff617 	ldw	r2,-40(fp)
 32393e0:	1080000b 	ldhu	r2,0(r2)
 32393e4:	10bfffcc 	andi	r2,r2,65535
 32393e8:	1004923a 	slli	r2,r2,8
 32393ec:	1007883a 	mov	r3,r2
 32393f0:	00bfc004 	movi	r2,-256
 32393f4:	1884703a 	and	r2,r3,r2
 32393f8:	2084b03a 	or	r2,r4,r2
 32393fc:	e0bff98d 	sth	r2,-26(fp)
   sin.sin_family = AF_INET;
 3239400:	00800084 	movi	r2,2
 3239404:	e0bff90d 	sth	r2,-28(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 3239408:	e0bff717 	ldw	r2,-36(fp)
 323940c:	11000a04 	addi	r4,r2,40
 3239410:	e17ff904 	addi	r5,fp,-28
 3239414:	e1bff817 	ldw	r6,-32(fp)
 3239418:	32322580 	call	3232258 <sbappendaddr>
 323941c:	1004c03a 	cmpne	r2,r2,zero
 3239420:	1000091e 	bne	r2,zero,3239448 <udp_soinput+0x178>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       */
      m_in->pkt = NULL;
 3239424:	e0bff817 	ldw	r2,-32(fp)
 3239428:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 323942c:	e13ff817 	ldw	r4,-32(fp)
 3239430:	322bb340 	call	322bb34 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 3239434:	0009883a 	mov	r4,zero
 3239438:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 323943c:	00801a44 	movi	r2,105
 3239440:	e0bfff15 	stw	r2,-4(fp)
 3239444:	00000a06 	br	3239470 <udp_soinput+0x1a0>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 3239448:	e0bff717 	ldw	r2,-36(fp)
 323944c:	11000a04 	addi	r4,r2,40
 3239450:	32269000 	call	3226900 <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 3239454:	e0bff717 	ldw	r2,-36(fp)
 3239458:	11400a04 	addi	r5,r2,40
 323945c:	e13ff717 	ldw	r4,-36(fp)
 3239460:	3231f0c0 	call	3231f0c <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 3239464:	0009883a 	mov	r4,zero
 3239468:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   return 0;
 323946c:	e03fff15 	stw	zero,-4(fp)
 3239470:	e0bfff17 	ldw	r2,-4(fp)
}
 3239474:	e037883a 	mov	sp,fp
 3239478:	dfc00117 	ldw	ra,4(sp)
 323947c:	df000017 	ldw	fp,0(sp)
 3239480:	dec00204 	addi	sp,sp,8
 3239484:	f800283a 	ret

03239488 <udp_usrreq>:

int
udp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 3239488:	defff704 	addi	sp,sp,-36
 323948c:	dfc00815 	stw	ra,32(sp)
 3239490:	df000715 	stw	fp,28(sp)
 3239494:	df000704 	addi	fp,sp,28
 3239498:	e13ffc15 	stw	r4,-16(fp)
 323949c:	e17ffd15 	stw	r5,-12(fp)
 32394a0:	e1bffe15 	stw	r6,-8(fp)
   UDPCONN udpconn = (UDPCONN)NULL;
 32394a4:	e03ffb15 	stw	zero,-20(fp)
   int   req;

   req = so->so_req;    /* get request from socket struct */
 32394a8:	e0bffc17 	ldw	r2,-16(fp)
 32394ac:	10800717 	ldw	r2,28(r2)
 32394b0:	e0bffa15 	stw	r2,-24(fp)

   switch (req) 
 32394b4:	e0bffa17 	ldw	r2,-24(fp)
 32394b8:	10800468 	cmpgeui	r2,r2,17
 32394bc:	10008b1e 	bne	r2,zero,32396ec <udp_usrreq+0x264>
 32394c0:	e0bffa17 	ldw	r2,-24(fp)
 32394c4:	1085883a 	add	r2,r2,r2
 32394c8:	1087883a 	add	r3,r2,r2
 32394cc:	0080c934 	movhi	r2,804
 32394d0:	10a53804 	addi	r2,r2,-27424
 32394d4:	1885883a 	add	r2,r3,r2
 32394d8:	10800017 	ldw	r2,0(r2)
 32394dc:	1000683a 	jmp	r2
 32394e0:	03239524 	muli	r12,zero,-29100
 32394e4:	032395ac 	andhi	r12,zero,36438
 32394e8:	032395f0 	cmpltui	r12,zero,36439
 32394ec:	032396ec 	andhi	r12,zero,36443
 32394f0:	032395f0 	cmpltui	r12,zero,36439
 32394f4:	032396ec 	andhi	r12,zero,36443
 32394f8:	032396e0 	cmpeqi	r12,zero,-29093
 32394fc:	032396ec 	andhi	r12,zero,36443
 3239500:	032396e0 	cmpeqi	r12,zero,-29093
 3239504:	03239640 	call	323964 <OSCtxSw_SWITCH_PC+0x323924>
 3239508:	032396ec 	andhi	r12,zero,36443
 323950c:	032396ec 	andhi	r12,zero,36443
 3239510:	032396ec 	andhi	r12,zero,36443
 3239514:	032396ec 	andhi	r12,zero,36443
 3239518:	032396ec 	andhi	r12,zero,36443
 323951c:	03239690 	cmplti	r12,zero,-29094
 3239520:	03239690 	cmplti	r12,zero,-29094
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = udp_maxalloc();
 3239524:	32452500 	call	3245250 <udp_maxalloc>
 3239528:	1007883a 	mov	r3,r2
 323952c:	e0bffc17 	ldw	r2,-16(fp)
 3239530:	10c01315 	stw	r3,76(r2)
 3239534:	e0bffc17 	ldw	r2,-16(fp)
 3239538:	10c01317 	ldw	r3,76(r2)
 323953c:	e0bffc17 	ldw	r2,-16(fp)
 3239540:	10c00b15 	stw	r3,44(r2)

#ifdef IP_V4
      /* make a NetPort UDP connection */
      /* unlock the net resource; UDP will immediatly re-lock it */
      if (so->so_domain  == AF_INET){
 3239544:	e0bffc17 	ldw	r2,-16(fp)
 3239548:	10800517 	ldw	r2,20(r2)
 323954c:	10800098 	cmpnei	r2,r2,2
 3239550:	10000e1e 	bne	r2,zero,323958c <udp_usrreq+0x104>
        UNLOCK_NET_RESOURCE(NET_RESID);
 3239554:	0009883a 	mov	r4,zero
 3239558:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
        udpconn = udp_open(0L, 0, udp_socket(), udp_soinput, so);
 323955c:	32450c00 	call	32450c0 <udp_socket>
 3239560:	11bfffcc 	andi	r6,r2,65535
 3239564:	e0bffc17 	ldw	r2,-16(fp)
 3239568:	d8800015 	stw	r2,0(sp)
 323956c:	0009883a 	mov	r4,zero
 3239570:	000b883a 	mov	r5,zero
 3239574:	01c0c934 	movhi	r7,804
 3239578:	39e4b404 	addi	r7,r7,-27952
 323957c:	322a6dc0 	call	322a6dc <udp_open>
 3239580:	e0bffb15 	stw	r2,-20(fp)
        LOCK_NET_RESOURCE(NET_RESID);
 3239584:	0009883a 	mov	r4,zero
 3239588:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
        UNLOCK_NET_RESOURCE(NET_RESID);
        udpconn = udp6_open(0L, 0, udp_socket(), udp6_soinput, so);
        LOCK_NET_RESOURCE(NET_RESID);
      }
#endif
      if (!udpconn)
 323958c:	e0bffb17 	ldw	r2,-20(fp)
 3239590:	1004c03a 	cmpne	r2,r2,zero
 3239594:	1000031e 	bne	r2,zero,32395a4 <udp_usrreq+0x11c>
         return(EINVAL);
 3239598:	00800584 	movi	r2,22
 323959c:	e0bfff15 	stw	r2,-4(fp)
 32395a0:	00005406 	br	32396f4 <udp_usrreq+0x26c>
      return 0;
 32395a4:	e03fff15 	stw	zero,-4(fp)
 32395a8:	00005206 	br	32396f4 <udp_usrreq+0x26c>
   case PRU_DETACH:
      /* delete the NetPort UDP connection */
      udpconn = udp_lookup(so);
 32395ac:	e13ffc17 	ldw	r4,-16(fp)
 32395b0:	32392600 	call	3239260 <udp_lookup>
 32395b4:	e0bffb15 	stw	r2,-20(fp)
      if (!udpconn)
 32395b8:	e0bffb17 	ldw	r2,-20(fp)
 32395bc:	1004c03a 	cmpne	r2,r2,zero
 32395c0:	1000031e 	bne	r2,zero,32395d0 <udp_usrreq+0x148>
         return(EINVAL);
 32395c4:	00800584 	movi	r2,22
 32395c8:	e0bfff15 	stw	r2,-4(fp)
 32395cc:	00004906 	br	32396f4 <udp_usrreq+0x26c>
      /* unlock the net resource; UDP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 32395d0:	0009883a 	mov	r4,zero
 32395d4:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      udp_close(udpconn);
 32395d8:	e13ffb17 	ldw	r4,-20(fp)
 32395dc:	322a9140 	call	322a914 <udp_close>
      LOCK_NET_RESOURCE(NET_RESID);
 32395e0:	0009883a 	mov	r4,zero
 32395e4:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      return 0;
 32395e8:	e03fff15 	stw	zero,-4(fp)
 32395ec:	00004106 	br	32396f4 <udp_usrreq+0x26c>
   case PRU_CONNECT:
      /* Install foreign port for UDP, making a virtual connection */
      /* fall to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 32395f0:	e0bffe17 	ldw	r2,-8(fp)
 32395f4:	1004c03a 	cmpne	r2,r2,zero
 32395f8:	1000031e 	bne	r2,zero,3239608 <udp_usrreq+0x180>
         return(EINVAL);
 32395fc:	00800584 	movi	r2,22
 3239600:	e0bfff15 	stw	r2,-4(fp)
 3239604:	00003b06 	br	32396f4 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 3239608:	e0bffc17 	ldw	r2,-16(fp)
 323960c:	10800517 	ldw	r2,20(r2)
 3239610:	10800098 	cmpnei	r2,r2,2
 3239614:	1000061e 	bne	r2,zero,3239630 <udp_usrreq+0x1a8>
        return udp4_sockbind(so, nam, req );
 3239618:	e13ffc17 	ldw	r4,-16(fp)
 323961c:	e17ffe17 	ldw	r5,-8(fp)
 3239620:	e1bffa17 	ldw	r6,-24(fp)
 3239624:	323970c0 	call	323970c <udp4_sockbind>
 3239628:	e0bfff15 	stw	r2,-4(fp)
 323962c:	00003106 	br	32396f4 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockbind(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 3239630:	322ab8c0 	call	322ab8c <dtrap>
      return EINVAL;
 3239634:	00800584 	movi	r2,22
 3239638:	e0bfff15 	stw	r2,-4(fp)
 323963c:	00002d06 	br	32396f4 <udp_usrreq+0x26c>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 3239640:	e0bffd17 	ldw	r2,-12(fp)
 3239644:	1004c03a 	cmpne	r2,r2,zero
 3239648:	1000031e 	bne	r2,zero,3239658 <udp_usrreq+0x1d0>
         return(EINVAL);
 323964c:	00800584 	movi	r2,22
 3239650:	e0bfff15 	stw	r2,-4(fp)
 3239654:	00002706 	br	32396f4 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 3239658:	e0bffc17 	ldw	r2,-16(fp)
 323965c:	10800517 	ldw	r2,20(r2)
 3239660:	10800098 	cmpnei	r2,r2,2
 3239664:	1000061e 	bne	r2,zero,3239680 <udp_usrreq+0x1f8>
        return udp4_socksend(so, m, nam );
 3239668:	e13ffc17 	ldw	r4,-16(fp)
 323966c:	e17ffd17 	ldw	r5,-12(fp)
 3239670:	e1bffe17 	ldw	r6,-8(fp)
 3239674:	3239a480 	call	3239a48 <udp4_socksend>
 3239678:	e0bfff15 	stw	r2,-4(fp)
 323967c:	00001d06 	br	32396f4 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_socksend(so, m, nam);
      }
#endif
      dtrap();   /* invalid address */
 3239680:	322ab8c0 	call	322ab8c <dtrap>
      return EINVAL;
 3239684:	00800584 	movi	r2,22
 3239688:	e0bfff15 	stw	r2,-4(fp)
 323968c:	00001906 	br	32396f4 <udp_usrreq+0x26c>

   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 3239690:	e0bffe17 	ldw	r2,-8(fp)
 3239694:	1004c03a 	cmpne	r2,r2,zero
 3239698:	1000031e 	bne	r2,zero,32396a8 <udp_usrreq+0x220>
         return(EINVAL);
 323969c:	00800584 	movi	r2,22
 32396a0:	e0bfff15 	stw	r2,-4(fp)
 32396a4:	00001306 	br	32396f4 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 32396a8:	e0bffc17 	ldw	r2,-16(fp)
 32396ac:	10800517 	ldw	r2,20(r2)
 32396b0:	10800098 	cmpnei	r2,r2,2
 32396b4:	1000061e 	bne	r2,zero,32396d0 <udp_usrreq+0x248>
        return udp4_sockaddr(so, nam, req );
 32396b8:	e13ffc17 	ldw	r4,-16(fp)
 32396bc:	e17ffe17 	ldw	r5,-8(fp)
 32396c0:	e1bffa17 	ldw	r6,-24(fp)
 32396c4:	3239e240 	call	3239e24 <udp4_sockaddr>
 32396c8:	e0bfff15 	stw	r2,-4(fp)
 32396cc:	00000906 	br	32396f4 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockaddr(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 32396d0:	322ab8c0 	call	322ab8c <dtrap>
      return EINVAL;
 32396d4:	00800584 	movi	r2,22
 32396d8:	e0bfff15 	stw	r2,-4(fp)
 32396dc:	00000506 	br	32396f4 <udp_usrreq+0x26c>

   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 32396e0:	322ab8c0 	call	322ab8c <dtrap>
      return 0;
 32396e4:	e03fff15 	stw	zero,-4(fp)
 32396e8:	00000206 	br	32396f4 <udp_usrreq+0x26c>
   case PRU_LISTEN:     /* don't support these for UDP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 32396ec:	008017c4 	movi	r2,95
 32396f0:	e0bfff15 	stw	r2,-4(fp)
 32396f4:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 32396f8:	e037883a 	mov	sp,fp
 32396fc:	dfc00117 	ldw	ra,4(sp)
 3239700:	df000017 	ldw	fp,0(sp)
 3239704:	dec00204 	addi	sp,sp,8
 3239708:	f800283a 	ret

0323970c <udp4_sockbind>:

#ifdef IP_V4
int udp4_sockbind(struct socket *so, struct mbuf *nam, int req ) 
{
 323970c:	defff304 	addi	sp,sp,-52
 3239710:	dfc00c15 	stw	ra,48(sp)
 3239714:	df000b15 	stw	fp,44(sp)
 3239718:	df000b04 	addi	fp,sp,44
 323971c:	e13ffc15 	stw	r4,-16(fp)
 3239720:	e17ffd15 	stw	r5,-12(fp)
 3239724:	e1bffe15 	stw	r6,-8(fp)
  u_short  lport;   /* local port (local byte order) */
  ip_addr fhost; /* host to send to/recv from (network byte order) */
  ip_addr lhost; /* local IP address to bind to (network byte order) */
  NET ifp;

  sin = mtod(nam, struct sockaddr_in *);
 3239728:	e0bffd17 	ldw	r2,-12(fp)
 323972c:	10800317 	ldw	r2,12(r2)
 3239730:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 3239734:	e0bffb17 	ldw	r2,-20(fp)
 3239738:	1004c03a 	cmpne	r2,r2,zero
 323973c:	1000031e 	bne	r2,zero,323974c <udp4_sockbind+0x40>
    return(EINVAL);
 3239740:	00800584 	movi	r2,22
 3239744:	e0bfff15 	stw	r2,-4(fp)
 3239748:	0000b906 	br	3239a30 <udp4_sockbind+0x324>
  if (nam->m_len != sizeof (*sin))
 323974c:	e0bffd17 	ldw	r2,-12(fp)
 3239750:	10800217 	ldw	r2,8(r2)
 3239754:	10800420 	cmpeqi	r2,r2,16
 3239758:	1000031e 	bne	r2,zero,3239768 <udp4_sockbind+0x5c>
    return(EINVAL);
 323975c:	00800584 	movi	r2,22
 3239760:	e0bfff15 	stw	r2,-4(fp)
 3239764:	0000b206 	br	3239a30 <udp4_sockbind+0x324>
  udpconn = udp_lookup(so);
 3239768:	e13ffc17 	ldw	r4,-16(fp)
 323976c:	32392600 	call	3239260 <udp_lookup>
 3239770:	e0bffa15 	stw	r2,-24(fp)
  if (!udpconn)
 3239774:	e0bffa17 	ldw	r2,-24(fp)
 3239778:	1004c03a 	cmpne	r2,r2,zero
 323977c:	1000031e 	bne	r2,zero,323978c <udp4_sockbind+0x80>
     return(EINVAL);
 3239780:	00800584 	movi	r2,22
 3239784:	e0bfff15 	stw	r2,-4(fp)
 3239788:	0000a906 	br	3239a30 <udp4_sockbind+0x324>
  if (req == PRU_BIND)
 323978c:	e0bffe17 	ldw	r2,-8(fp)
 3239790:	10800098 	cmpnei	r2,r2,2
 3239794:	1000601e 	bne	r2,zero,3239918 <udp4_sockbind+0x20c>
     * if the caller-supplied port is 0, try to get
     * the port from the UDP endpoint, or pick a new
     * unique port; else, use the caller-supplied
     * port
     */
    if (sin->sin_port == 0)
 3239798:	e0bffb17 	ldw	r2,-20(fp)
 323979c:	1080008b 	ldhu	r2,2(r2)
 32397a0:	10bfffcc 	andi	r2,r2,65535
 32397a4:	1004c03a 	cmpne	r2,r2,zero
 32397a8:	10000c1e 	bne	r2,zero,32397dc <udp4_sockbind+0xd0>
    {
      if (udpconn->u_lport != 0)
 32397ac:	e0bffa17 	ldw	r2,-24(fp)
 32397b0:	1080018b 	ldhu	r2,6(r2)
 32397b4:	10bfffcc 	andi	r2,r2,65535
 32397b8:	1005003a 	cmpeq	r2,r2,zero
 32397bc:	1000041e 	bne	r2,zero,32397d0 <udp4_sockbind+0xc4>
        lport = udpconn->u_lport;
 32397c0:	e0bffa17 	ldw	r2,-24(fp)
 32397c4:	1080018b 	ldhu	r2,6(r2)
 32397c8:	e0bff80d 	sth	r2,-32(fp)
 32397cc:	00001206 	br	3239818 <udp4_sockbind+0x10c>
      else
        lport = udp_socket();
 32397d0:	32450c00 	call	32450c0 <udp_socket>
 32397d4:	e0bff80d 	sth	r2,-32(fp)
 32397d8:	00000f06 	br	3239818 <udp4_sockbind+0x10c>
    }
    else
    {
      lport = ntohs(sin->sin_port);
 32397dc:	e0bffb17 	ldw	r2,-20(fp)
 32397e0:	1080008b 	ldhu	r2,2(r2)
 32397e4:	10bfffcc 	andi	r2,r2,65535
 32397e8:	1004d23a 	srli	r2,r2,8
 32397ec:	10803fcc 	andi	r2,r2,255
 32397f0:	1009883a 	mov	r4,r2
 32397f4:	e0bffb17 	ldw	r2,-20(fp)
 32397f8:	1080008b 	ldhu	r2,2(r2)
 32397fc:	10bfffcc 	andi	r2,r2,65535
 3239800:	1004923a 	slli	r2,r2,8
 3239804:	1007883a 	mov	r3,r2
 3239808:	00bfc004 	movi	r2,-256
 323980c:	1884703a 	and	r2,r3,r2
 3239810:	2084b03a 	or	r2,r4,r2
 3239814:	e0bff80d 	sth	r2,-32(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * don't bind to a specific address; else, 
     * make sure the caller-supplied address is
     * an interface IP address and if so, bind to that
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 3239818:	e0bffb17 	ldw	r2,-20(fp)
 323981c:	10800117 	ldw	r2,4(r2)
 3239820:	1004c03a 	cmpne	r2,r2,zero
 3239824:	1000021e 	bne	r2,zero,3239830 <udp4_sockbind+0x124>
    {
      lhost = 0L;
 3239828:	e03ff615 	stw	zero,-40(fp)
 323982c:	00001806 	br	3239890 <udp4_sockbind+0x184>
    }
    else
    {
      lhost = sin->sin_addr.s_addr;
 3239830:	e0bffb17 	ldw	r2,-20(fp)
 3239834:	10800117 	ldw	r2,4(r2)
 3239838:	e0bff615 	stw	r2,-40(fp)
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 323983c:	0080c9b4 	movhi	r2,806
 3239840:	10b45b04 	addi	r2,r2,-11924
 3239844:	10800017 	ldw	r2,0(r2)
 3239848:	e0bff515 	stw	r2,-44(fp)
 323984c:	00000706 	br	323986c <udp4_sockbind+0x160>
        if (ifp->n_ipaddr == lhost)
 3239850:	e0bff517 	ldw	r2,-44(fp)
 3239854:	10c00a17 	ldw	r3,40(r2)
 3239858:	e0bff617 	ldw	r2,-40(fp)
 323985c:	18800626 	beq	r3,r2,3239878 <udp4_sockbind+0x16c>
    else
    {
      lhost = sin->sin_addr.s_addr;
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3239860:	e0bff517 	ldw	r2,-44(fp)
 3239864:	10800017 	ldw	r2,0(r2)
 3239868:	e0bff515 	stw	r2,-44(fp)
 323986c:	e0bff517 	ldw	r2,-44(fp)
 3239870:	1004c03a 	cmpne	r2,r2,zero
 3239874:	103ff61e 	bne	r2,zero,3239850 <udp4_sockbind+0x144>
        if (ifp->n_ipaddr == lhost)
          break;
      if (ifp == NULL)
 3239878:	e0bff517 	ldw	r2,-44(fp)
 323987c:	1004c03a 	cmpne	r2,r2,zero
 3239880:	1000031e 	bne	r2,zero,3239890 <udp4_sockbind+0x184>
        return(EADDRNOTAVAIL);
 3239884:	00801f44 	movi	r2,125
 3239888:	e0bfff15 	stw	r2,-4(fp)
 323988c:	00006806 	br	3239a30 <udp4_sockbind+0x324>
    }

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
 3239890:	e0bffc17 	ldw	r2,-16(fp)
 3239894:	10800417 	ldw	r2,16(r2)
 3239898:	1080010c 	andi	r2,r2,4
 323989c:	1004c03a 	cmpne	r2,r2,zero
 32398a0:	1000161e 	bne	r2,zero,32398fc <udp4_sockbind+0x1f0>
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 32398a4:	0080c974 	movhi	r2,805
 32398a8:	10924a04 	addi	r2,r2,18728
 32398ac:	10800017 	ldw	r2,0(r2)
 32398b0:	e0bff915 	stw	r2,-28(fp)
 32398b4:	00000e06 	br	32398f0 <udp4_sockbind+0x1e4>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
 32398b8:	e0bff917 	ldw	r2,-28(fp)
 32398bc:	1080018b 	ldhu	r2,6(r2)
 32398c0:	10ffffcc 	andi	r3,r2,65535
 32398c4:	e0bff80b 	ldhu	r2,-32(fp)
 32398c8:	1880061e 	bne	r3,r2,32398e4 <udp4_sockbind+0x1d8>
 32398cc:	e0fff917 	ldw	r3,-28(fp)
 32398d0:	e0bffa17 	ldw	r2,-24(fp)
 32398d4:	18800326 	beq	r3,r2,32398e4 <udp4_sockbind+0x1d8>
          return(EADDRINUSE);
 32398d8:	00801c04 	movi	r2,112
 32398dc:	e0bfff15 	stw	r2,-4(fp)
 32398e0:	00005306 	br	3239a30 <udp4_sockbind+0x324>

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 32398e4:	e0bff917 	ldw	r2,-28(fp)
 32398e8:	10800017 	ldw	r2,0(r2)
 32398ec:	e0bff915 	stw	r2,-28(fp)
 32398f0:	e0bff917 	ldw	r2,-28(fp)
 32398f4:	1004c03a 	cmpne	r2,r2,zero
 32398f8:	103fef1e 	bne	r2,zero,32398b8 <udp4_sockbind+0x1ac>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
          return(EADDRINUSE);
    /* bind the UDP endpoint */
    udpconn->u_lport = lport;
 32398fc:	e0fffa17 	ldw	r3,-24(fp)
 3239900:	e0bff80b 	ldhu	r2,-32(fp)
 3239904:	1880018d 	sth	r2,6(r3)
    udpconn->u_lhost = lhost;
 3239908:	e0fffa17 	ldw	r3,-24(fp)
 323990c:	e0bff617 	ldw	r2,-40(fp)
 3239910:	18800315 	stw	r2,12(r3)
 3239914:	00004506 	br	3239a2c <udp4_sockbind+0x320>
  else /* PRU_CONNECT */
  {
    /* connect the socket to a remote IP address and
     * UDP port.
     */
    fport = ntohs(sin->sin_port);
 3239918:	e0bffb17 	ldw	r2,-20(fp)
 323991c:	1080008b 	ldhu	r2,2(r2)
 3239920:	10bfffcc 	andi	r2,r2,65535
 3239924:	1004d23a 	srli	r2,r2,8
 3239928:	10803fcc 	andi	r2,r2,255
 323992c:	1009883a 	mov	r4,r2
 3239930:	e0bffb17 	ldw	r2,-20(fp)
 3239934:	1080008b 	ldhu	r2,2(r2)
 3239938:	10bfffcc 	andi	r2,r2,65535
 323993c:	1004923a 	slli	r2,r2,8
 3239940:	1007883a 	mov	r3,r2
 3239944:	00bfc004 	movi	r2,-256
 3239948:	1884703a 	and	r2,r3,r2
 323994c:	2084b03a 	or	r2,r4,r2
 3239950:	e0bff88d 	sth	r2,-30(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * use the wildcard address; else, use the caller-
     * supplied address
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 3239954:	e0bffb17 	ldw	r2,-20(fp)
 3239958:	10800117 	ldw	r2,4(r2)
 323995c:	1004c03a 	cmpne	r2,r2,zero
 3239960:	1000021e 	bne	r2,zero,323996c <udp4_sockbind+0x260>
      fhost = 0L;
 3239964:	e03ff715 	stw	zero,-36(fp)
 3239968:	00000306 	br	3239978 <udp4_sockbind+0x26c>
    else
      fhost = sin->sin_addr.s_addr;
 323996c:	e0bffb17 	ldw	r2,-20(fp)
 3239970:	10800117 	ldw	r2,4(r2)
 3239974:	e0bff715 	stw	r2,-36(fp)
    /* prepare to bind the socket to the appropriate 
     * local interface address for the to-be-connected 
     * peer
     */
    lhost = ip_mymach(fhost);
 3239978:	e13ff717 	ldw	r4,-36(fp)
 323997c:	324018c0 	call	324018c <ip_mymach>
 3239980:	e0bff615 	stw	r2,-40(fp)
    if (lhost == 0)
 3239984:	e0bff617 	ldw	r2,-40(fp)
 3239988:	1004c03a 	cmpne	r2,r2,zero
 323998c:	1000031e 	bne	r2,zero,323999c <udp4_sockbind+0x290>
      return(ENETUNREACH);
 3239990:	00801c84 	movi	r2,114
 3239994:	e0bfff15 	stw	r2,-4(fp)
 3239998:	00002506 	br	3239a30 <udp4_sockbind+0x324>
    /* if the socket hasn't been bound to a local
     * port yet, do so now
     */
    lport = udpconn->u_lport;
 323999c:	e0bffa17 	ldw	r2,-24(fp)
 32399a0:	1080018b 	ldhu	r2,6(r2)
 32399a4:	e0bff80d 	sth	r2,-32(fp)
    if (lport == 0)
 32399a8:	e0bff80b 	ldhu	r2,-32(fp)
 32399ac:	1004c03a 	cmpne	r2,r2,zero
 32399b0:	1000021e 	bne	r2,zero,32399bc <udp4_sockbind+0x2b0>
      lport = udp_socket();
 32399b4:	32450c00 	call	32450c0 <udp_socket>
 32399b8:	e0bff80d 	sth	r2,-32(fp)
    /* bind and connect the UDP endpoint */
    udpconn->u_lhost = lhost;
 32399bc:	e0fffa17 	ldw	r3,-24(fp)
 32399c0:	e0bff617 	ldw	r2,-40(fp)
 32399c4:	18800315 	stw	r2,12(r3)
    udpconn->u_lport = lport;
 32399c8:	e0fffa17 	ldw	r3,-24(fp)
 32399cc:	e0bff80b 	ldhu	r2,-32(fp)
 32399d0:	1880018d 	sth	r2,6(r3)
    udpconn->u_fhost = fhost;
 32399d4:	e0fffa17 	ldw	r3,-24(fp)
 32399d8:	e0bff717 	ldw	r2,-36(fp)
 32399dc:	18800415 	stw	r2,16(r3)
    udpconn->u_fport = fport;
 32399e0:	e0fffa17 	ldw	r3,-24(fp)
 32399e4:	e0bff88b 	ldhu	r2,-30(fp)
 32399e8:	1880020d 	sth	r2,8(r3)
    /* mark the socket as connected */
    so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 32399ec:	e0bffc17 	ldw	r2,-16(fp)
 32399f0:	10c0088b 	ldhu	r3,34(r2)
 32399f4:	00bffcc4 	movi	r2,-13
 32399f8:	1884703a 	and	r2,r3,r2
 32399fc:	1007883a 	mov	r3,r2
 3239a00:	e0bffc17 	ldw	r2,-16(fp)
 3239a04:	10c0088d 	sth	r3,34(r2)
    so->so_state |= SS_ISCONNECTED;
 3239a08:	e0bffc17 	ldw	r2,-16(fp)
 3239a0c:	1080088b 	ldhu	r2,34(r2)
 3239a10:	10800094 	ori	r2,r2,2
 3239a14:	1007883a 	mov	r3,r2
 3239a18:	e0bffc17 	ldw	r2,-16(fp)
 3239a1c:	10c0088d 	sth	r3,34(r2)
    /* since socket was in listen state, packets may be queued */
    sbflush(&so->so_rcv);   /* dump these now */
 3239a20:	e0bffc17 	ldw	r2,-16(fp)
 3239a24:	11000a04 	addi	r4,r2,40
 3239a28:	32326480 	call	3232648 <sbflush>
  }
  return 0;
 3239a2c:	e03fff15 	stw	zero,-4(fp)
 3239a30:	e0bfff17 	ldw	r2,-4(fp)
}
 3239a34:	e037883a 	mov	sp,fp
 3239a38:	dfc00117 	ldw	ra,4(sp)
 3239a3c:	df000017 	ldw	fp,0(sp)
 3239a40:	dec00204 	addi	sp,sp,8
 3239a44:	f800283a 	ret

03239a48 <udp4_socksend>:

int udp4_socksend(struct socket *so, struct mbuf *m, 
		struct mbuf *nam ) 
{
 3239a48:	defff204 	addi	sp,sp,-56
 3239a4c:	dfc00d15 	stw	ra,52(sp)
 3239a50:	df000c15 	stw	fp,48(sp)
 3239a54:	dc000b15 	stw	r16,44(sp)
 3239a58:	df000b04 	addi	fp,sp,44
 3239a5c:	e13ffc15 	stw	r4,-16(fp)
 3239a60:	e17ffd15 	stw	r5,-12(fp)
 3239a64:	e1bffe15 	stw	r6,-8(fp)
  PACKET pkt;
#ifdef MULTI_HOMED
  NET ifp;
#endif

  udpconn = udp_lookup(so);
 3239a68:	e13ffc17 	ldw	r4,-16(fp)
 3239a6c:	32392600 	call	3239260 <udp_lookup>
 3239a70:	e0bff915 	stw	r2,-28(fp)
  if (!udpconn)
 3239a74:	e0bff917 	ldw	r2,-28(fp)
 3239a78:	1004c03a 	cmpne	r2,r2,zero
 3239a7c:	1000051e 	bne	r2,zero,3239a94 <udp4_socksend+0x4c>
  {
    m_free(m);
 3239a80:	e13ffd17 	ldw	r4,-12(fp)
 3239a84:	322bb340 	call	322bb34 <m_free>
    /* may be bogus socket, but more likely the connection may 
       have closed due to ICMP dest unreachable from other side. */
    return(ECONNREFUSED);
 3239a88:	00801bc4 	movi	r2,111
 3239a8c:	e0bfff15 	stw	r2,-4(fp)
 3239a90:	0000dd06 	br	3239e08 <udp4_socksend+0x3c0>
  }

  if (nam == NULL)  /* no sendto() info passed, must be send() */
 3239a94:	e0bffe17 	ldw	r2,-8(fp)
 3239a98:	1004c03a 	cmpne	r2,r2,zero
 3239a9c:	1000101e 	bne	r2,zero,3239ae0 <udp4_socksend+0x98>
  { 
    if (so->so_state & SS_ISCONNECTED)
 3239aa0:	e0bffc17 	ldw	r2,-16(fp)
 3239aa4:	1080088b 	ldhu	r2,34(r2)
 3239aa8:	10bfffcc 	andi	r2,r2,65535
 3239aac:	1080008c 	andi	r2,r2,2
 3239ab0:	1005003a 	cmpeq	r2,r2,zero
 3239ab4:	1000071e 	bne	r2,zero,3239ad4 <udp4_socksend+0x8c>
    {
      fport = udpconn->u_fport;
 3239ab8:	e0bff917 	ldw	r2,-28(fp)
 3239abc:	1080020b 	ldhu	r2,8(r2)
 3239ac0:	e0bff80d 	sth	r2,-32(fp)
      fhost = udpconn->u_fhost;
 3239ac4:	e0bff917 	ldw	r2,-28(fp)
 3239ac8:	10800417 	ldw	r2,16(r2)
 3239acc:	e0bff715 	stw	r2,-36(fp)
 3239ad0:	00003106 	br	3239b98 <udp4_socksend+0x150>
    }
    else
      return (EINVAL);
 3239ad4:	00800584 	movi	r2,22
 3239ad8:	e0bfff15 	stw	r2,-4(fp)
 3239adc:	0000ca06 	br	3239e08 <udp4_socksend+0x3c0>
  }
  else if(nam->m_len != sizeof (*sin))
 3239ae0:	e0bffe17 	ldw	r2,-8(fp)
 3239ae4:	10800217 	ldw	r2,8(r2)
 3239ae8:	10800420 	cmpeqi	r2,r2,16
 3239aec:	1000041e 	bne	r2,zero,3239b00 <udp4_socksend+0xb8>
  {
    dtrap();
 3239af0:	322ab8c0 	call	322ab8c <dtrap>
    return (EINVAL);
 3239af4:	00800584 	movi	r2,22
 3239af8:	e0bfff15 	stw	r2,-4(fp)
 3239afc:	0000c206 	br	3239e08 <udp4_socksend+0x3c0>
  }
  else
  {
    sin = mtod(nam, struct sockaddr_in *);
 3239b00:	e0bffe17 	ldw	r2,-8(fp)
 3239b04:	10800317 	ldw	r2,12(r2)
 3239b08:	e0bffa15 	stw	r2,-24(fp)
    fhost = sin->sin_addr.s_addr;
 3239b0c:	e0bffa17 	ldw	r2,-24(fp)
 3239b10:	10800117 	ldw	r2,4(r2)
 3239b14:	e0bff715 	stw	r2,-36(fp)
    /* use caller's fport if specified, ours may be a wildcard */
    if (sin->sin_port)   /* caller gets to change fport on the fly */
 3239b18:	e0bffa17 	ldw	r2,-24(fp)
 3239b1c:	1080008b 	ldhu	r2,2(r2)
 3239b20:	10bfffcc 	andi	r2,r2,65535
 3239b24:	1005003a 	cmpeq	r2,r2,zero
 3239b28:	1000101e 	bne	r2,zero,3239b6c <udp4_socksend+0x124>
      fport = ntohs(sin->sin_port);
 3239b2c:	e0bffa17 	ldw	r2,-24(fp)
 3239b30:	1080008b 	ldhu	r2,2(r2)
 3239b34:	10bfffcc 	andi	r2,r2,65535
 3239b38:	1004d23a 	srli	r2,r2,8
 3239b3c:	10803fcc 	andi	r2,r2,255
 3239b40:	1009883a 	mov	r4,r2
 3239b44:	e0bffa17 	ldw	r2,-24(fp)
 3239b48:	1080008b 	ldhu	r2,2(r2)
 3239b4c:	10bfffcc 	andi	r2,r2,65535
 3239b50:	1004923a 	slli	r2,r2,8
 3239b54:	1007883a 	mov	r3,r2
 3239b58:	00bfc004 	movi	r2,-256
 3239b5c:	1884703a 	and	r2,r3,r2
 3239b60:	2084b03a 	or	r2,r4,r2
 3239b64:	e0bff80d 	sth	r2,-32(fp)
 3239b68:	00000b06 	br	3239b98 <udp4_socksend+0x150>
    else  /* use port already set in UDP connection */
    {
      if (udpconn->u_fport == 0) /* don't send to port 0 */
 3239b6c:	e0bff917 	ldw	r2,-28(fp)
 3239b70:	1080020b 	ldhu	r2,8(r2)
 3239b74:	10bfffcc 	andi	r2,r2,65535
 3239b78:	1004c03a 	cmpne	r2,r2,zero
 3239b7c:	1000031e 	bne	r2,zero,3239b8c <udp4_socksend+0x144>
        return (EINVAL);
 3239b80:	00800584 	movi	r2,22
 3239b84:	e0bfff15 	stw	r2,-4(fp)
 3239b88:	00009f06 	br	3239e08 <udp4_socksend+0x3c0>
      fport = udpconn->u_fport;
 3239b8c:	e0bff917 	ldw	r2,-28(fp)
 3239b90:	1080020b 	ldhu	r2,8(r2)
 3239b94:	e0bff80d 	sth	r2,-32(fp)

  /* since our pkt->nb_buff size is tied to max packet size, we 
   * assume our UDP datagrams are always in one mbuf and that the 
   * mbuf 
   */
  if (m->m_len > (unsigned)udp_maxalloc()) /* but check anyway:*/
 3239b98:	e0bffd17 	ldw	r2,-12(fp)
 3239b9c:	14000217 	ldw	r16,8(r2)
 3239ba0:	32452500 	call	3245250 <udp_maxalloc>
 3239ba4:	1400042e 	bgeu	r2,r16,3239bb8 <udp4_socksend+0x170>
  {
    dtrap(); /* should never happen */
 3239ba8:	322ab8c0 	call	322ab8c <dtrap>
    return EMSGSIZE;  /* try to recover */
 3239bac:	00801e84 	movi	r2,122
 3239bb0:	e0bfff15 	stw	r2,-4(fp)
 3239bb4:	00009406 	br	3239e08 <udp4_socksend+0x3c0>
  }
  pkt = udp_alloc(m->m_len, 0);    /* get a NetPort buffer for send */
 3239bb8:	e0bffd17 	ldw	r2,-12(fp)
 3239bbc:	10800217 	ldw	r2,8(r2)
 3239bc0:	1009883a 	mov	r4,r2
 3239bc4:	000b883a 	mov	r5,zero
 3239bc8:	32451900 	call	3245190 <udp_alloc>
 3239bcc:	e0bff615 	stw	r2,-40(fp)
  if (!pkt)
 3239bd0:	e0bff617 	ldw	r2,-40(fp)
 3239bd4:	1004c03a 	cmpne	r2,r2,zero
 3239bd8:	1000051e 	bne	r2,zero,3239bf0 <udp4_socksend+0x1a8>
  {
    m_free(m);
 3239bdc:	e13ffd17 	ldw	r4,-12(fp)
 3239be0:	322bb340 	call	322bb34 <m_free>
    return ENOBUFS;   /* report buffer shortages */
 3239be4:	00801a44 	movi	r2,105
 3239be8:	e0bfff15 	stw	r2,-4(fp)
 3239bec:	00008606 	br	3239e08 <udp4_socksend+0x3c0>
  }
  MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 3239bf0:	e0bff617 	ldw	r2,-40(fp)
 3239bf4:	10c00317 	ldw	r3,12(r2)
 3239bf8:	e0bffd17 	ldw	r2,-12(fp)
 3239bfc:	11400317 	ldw	r5,12(r2)
 3239c00:	e0bffd17 	ldw	r2,-12(fp)
 3239c04:	10800217 	ldw	r2,8(r2)
 3239c08:	1809883a 	mov	r4,r3
 3239c0c:	100d883a 	mov	r6,r2
 3239c10:	32067cc0 	call	32067cc <memcpy>
  pkt->nb_plen = m->m_len;
 3239c14:	e0bffd17 	ldw	r2,-12(fp)
 3239c18:	10c00217 	ldw	r3,8(r2)
 3239c1c:	e0bff617 	ldw	r2,-40(fp)
 3239c20:	10c00415 	stw	r3,16(r2)
  /* finished with mbuf, free it now */
  m_free(m);
 3239c24:	e13ffd17 	ldw	r4,-12(fp)
 3239c28:	322bb340 	call	322bb34 <m_free>
  pkt->fhost = fhost;
 3239c2c:	e0fff617 	ldw	r3,-40(fp)
 3239c30:	e0bff717 	ldw	r2,-36(fp)
 3239c34:	18800715 	stw	r2,28(r3)
     * is up; if (after all that) we don't have an interface then we
     * fail with error EADDRNOTAVAIL; and finally, if we're built
     * for a single-homed configuration where there's only one
     * interface, we might as well use it, so we do.  
   */
  if (fhost == 0xffffffff)
 3239c38:	e0bff717 	ldw	r2,-36(fp)
 3239c3c:	10bfffd8 	cmpnei	r2,r2,-1
 3239c40:	10004f1e 	bne	r2,zero,3239d80 <udp4_socksend+0x338>
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
 3239c44:	e0bff917 	ldw	r2,-28(fp)
 3239c48:	10800317 	ldw	r2,12(r2)
 3239c4c:	1005003a 	cmpeq	r2,r2,zero
 3239c50:	1000111e 	bne	r2,zero,3239c98 <udp4_socksend+0x250>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3239c54:	0080c9b4 	movhi	r2,806
 3239c58:	10b45b04 	addi	r2,r2,-11924
 3239c5c:	10800017 	ldw	r2,0(r2)
 3239c60:	e0bff515 	stw	r2,-44(fp)
 3239c64:	00000806 	br	3239c88 <udp4_socksend+0x240>
        if (ifp->n_ipaddr == udpconn->u_lhost)
 3239c68:	e0bff517 	ldw	r2,-44(fp)
 3239c6c:	10c00a17 	ldw	r3,40(r2)
 3239c70:	e0bff917 	ldw	r2,-28(fp)
 3239c74:	10800317 	ldw	r2,12(r2)
 3239c78:	18802126 	beq	r3,r2,3239d00 <udp4_socksend+0x2b8>
  if (fhost == 0xffffffff)
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3239c7c:	e0bff517 	ldw	r2,-44(fp)
 3239c80:	10800017 	ldw	r2,0(r2)
 3239c84:	e0bff515 	stw	r2,-44(fp)
 3239c88:	e0bff517 	ldw	r2,-44(fp)
 3239c8c:	1004c03a 	cmpne	r2,r2,zero
 3239c90:	103ff51e 	bne	r2,zero,3239c68 <udp4_socksend+0x220>
 3239c94:	00001a06 	br	3239d00 <udp4_socksend+0x2b8>
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3239c98:	0080c9b4 	movhi	r2,806
 3239c9c:	10b45b04 	addi	r2,r2,-11924
 3239ca0:	10800017 	ldw	r2,0(r2)
 3239ca4:	e0bff515 	stw	r2,-44(fp)
 3239ca8:	00001206 	br	3239cf4 <udp4_socksend+0x2ac>
        if ((ifp->n_flags & NF_BCAST) &&
 3239cac:	e0bff517 	ldw	r2,-44(fp)
 3239cb0:	10802a17 	ldw	r2,168(r2)
 3239cb4:	1080004c 	andi	r2,r2,1
 3239cb8:	10803fcc 	andi	r2,r2,255
 3239cbc:	1005003a 	cmpeq	r2,r2,zero
 3239cc0:	1000091e 	bne	r2,zero,3239ce8 <udp4_socksend+0x2a0>
 3239cc4:	e0bff517 	ldw	r2,-44(fp)
 3239cc8:	10802717 	ldw	r2,156(r2)
 3239ccc:	1005003a 	cmpeq	r2,r2,zero
 3239cd0:	1000051e 	bne	r2,zero,3239ce8 <udp4_socksend+0x2a0>
 3239cd4:	e0bff517 	ldw	r2,-44(fp)
 3239cd8:	10802717 	ldw	r2,156(r2)
 3239cdc:	10800617 	ldw	r2,24(r2)
 3239ce0:	10800060 	cmpeqi	r2,r2,1
 3239ce4:	1000061e 	bne	r2,zero,3239d00 <udp4_socksend+0x2b8>
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3239ce8:	e0bff517 	ldw	r2,-44(fp)
 3239cec:	10800017 	ldw	r2,0(r2)
 3239cf0:	e0bff515 	stw	r2,-44(fp)
 3239cf4:	e0bff517 	ldw	r2,-44(fp)
 3239cf8:	1004c03a 	cmpne	r2,r2,zero
 3239cfc:	103feb1e 	bne	r2,zero,3239cac <udp4_socksend+0x264>
        if ((ifp->n_flags & NF_BCAST) &&
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
 3239d00:	e0bff517 	ldw	r2,-44(fp)
 3239d04:	1004c03a 	cmpne	r2,r2,zero
 3239d08:	10001a1e 	bne	r2,zero,3239d74 <udp4_socksend+0x32c>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3239d0c:	0080c9b4 	movhi	r2,806
 3239d10:	10b45b04 	addi	r2,r2,-11924
 3239d14:	10800017 	ldw	r2,0(r2)
 3239d18:	e0bff515 	stw	r2,-44(fp)
 3239d1c:	00000c06 	br	3239d50 <udp4_socksend+0x308>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 3239d20:	e0bff517 	ldw	r2,-44(fp)
 3239d24:	10802717 	ldw	r2,156(r2)
 3239d28:	1005003a 	cmpeq	r2,r2,zero
 3239d2c:	1000051e 	bne	r2,zero,3239d44 <udp4_socksend+0x2fc>
 3239d30:	e0bff517 	ldw	r2,-44(fp)
 3239d34:	10802717 	ldw	r2,156(r2)
 3239d38:	10800617 	ldw	r2,24(r2)
 3239d3c:	10800060 	cmpeqi	r2,r2,1
 3239d40:	1000061e 	bne	r2,zero,3239d5c <udp4_socksend+0x314>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3239d44:	e0bff517 	ldw	r2,-44(fp)
 3239d48:	10800017 	ldw	r2,0(r2)
 3239d4c:	e0bff515 	stw	r2,-44(fp)
 3239d50:	e0bff517 	ldw	r2,-44(fp)
 3239d54:	1004c03a 	cmpne	r2,r2,zero
 3239d58:	103ff11e 	bne	r2,zero,3239d20 <udp4_socksend+0x2d8>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
          break;
      if (ifp == NULL)
 3239d5c:	e0bff517 	ldw	r2,-44(fp)
 3239d60:	1004c03a 	cmpne	r2,r2,zero
 3239d64:	1000031e 	bne	r2,zero,3239d74 <udp4_socksend+0x32c>
        return(EADDRNOTAVAIL);
 3239d68:	00801f44 	movi	r2,125
 3239d6c:	e0bfff15 	stw	r2,-4(fp)
 3239d70:	00002506 	br	3239e08 <udp4_socksend+0x3c0>
    }
    pkt->net = ifp;
 3239d74:	e0fff617 	ldw	r3,-40(fp)
 3239d78:	e0bff517 	ldw	r2,-44(fp)
 3239d7c:	18800615 	stw	r2,24(r3)
#ifdef IP_MULTICAST

  /* If the socket has an IP moptions structure for multicast options,
   * place a pointer to this structure in the PACKET structure.
   */
  if (so->inp_moptions)
 3239d80:	e0bffc17 	ldw	r2,-16(fp)
 3239d84:	10800317 	ldw	r2,12(r2)
 3239d88:	1005003a 	cmpeq	r2,r2,zero
 3239d8c:	1000041e 	bne	r2,zero,3239da0 <udp4_socksend+0x358>
     pkt->imo = so->inp_moptions;
 3239d90:	e0bffc17 	ldw	r2,-16(fp)
 3239d94:	10c00317 	ldw	r3,12(r2)
 3239d98:	e0bff617 	ldw	r2,-40(fp)
 3239d9c:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

   /* have we set options? */
   if (so->so_optsPack)
 3239da0:	e0bffc17 	ldw	r2,-16(fp)
 3239da4:	10801f17 	ldw	r2,124(r2)
 3239da8:	1005003a 	cmpeq	r2,r2,zero
 3239dac:	1000041e 	bne	r2,zero,3239dc0 <udp4_socksend+0x378>
	   pkt->soxopts = so->so_optsPack; /* yup - copy to pkt */
 3239db0:	e0bffc17 	ldw	r2,-16(fp)
 3239db4:	10c01f17 	ldw	r3,124(r2)
 3239db8:	e0bff617 	ldw	r2,-40(fp)
 3239dbc:	10c00c15 	stw	r3,48(r2)

  /* unlock the net resource; UDP will immediately re-lock it */
  UNLOCK_NET_RESOURCE(NET_RESID);
 3239dc0:	0009883a 	mov	r4,zero
 3239dc4:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
  e = udp_send(fport, udpconn->u_lport, pkt);
 3239dc8:	e13ff80b 	ldhu	r4,-32(fp)
 3239dcc:	e0bff917 	ldw	r2,-28(fp)
 3239dd0:	1080018b 	ldhu	r2,6(r2)
 3239dd4:	117fffcc 	andi	r5,r2,65535
 3239dd8:	e1bff617 	ldw	r6,-40(fp)
 3239ddc:	3244cd80 	call	3244cd8 <udp_send>
 3239de0:	e0bffb15 	stw	r2,-20(fp)
  LOCK_NET_RESOURCE(NET_RESID);
 3239de4:	0009883a 	mov	r4,zero
 3239de8:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
  if (e < 0) 
 3239dec:	e0bffb17 	ldw	r2,-20(fp)
 3239df0:	1004403a 	cmpge	r2,r2,zero
 3239df4:	1000031e 	bne	r2,zero,3239e04 <udp4_socksend+0x3bc>
     return(e);
 3239df8:	e0bffb17 	ldw	r2,-20(fp)
 3239dfc:	e0bfff15 	stw	r2,-4(fp)
 3239e00:	00000106 	br	3239e08 <udp4_socksend+0x3c0>
  return 0;
 3239e04:	e03fff15 	stw	zero,-4(fp)
 3239e08:	e0bfff17 	ldw	r2,-4(fp)
}
 3239e0c:	e037883a 	mov	sp,fp
 3239e10:	dfc00217 	ldw	ra,8(sp)
 3239e14:	df000117 	ldw	fp,4(sp)
 3239e18:	dc000017 	ldw	r16,0(sp)
 3239e1c:	dec00304 	addi	sp,sp,12
 3239e20:	f800283a 	ret

03239e24 <udp4_sockaddr>:

int udp4_sockaddr(struct socket *so, struct mbuf *nam , int req)
{
 3239e24:	defff804 	addi	sp,sp,-32
 3239e28:	dfc00715 	stw	ra,28(sp)
 3239e2c:	df000615 	stw	fp,24(sp)
 3239e30:	df000604 	addi	fp,sp,24
 3239e34:	e13ffc15 	stw	r4,-16(fp)
 3239e38:	e17ffd15 	stw	r5,-12(fp)
 3239e3c:	e1bffe15 	stw	r6,-8(fp)
  struct sockaddr_in * sin;
  UDPCONN udpconn;

  sin = mtod(nam, struct sockaddr_in *);
 3239e40:	e0bffd17 	ldw	r2,-12(fp)
 3239e44:	10800317 	ldw	r2,12(r2)
 3239e48:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 3239e4c:	e0bffb17 	ldw	r2,-20(fp)
 3239e50:	1004c03a 	cmpne	r2,r2,zero
 3239e54:	1000031e 	bne	r2,zero,3239e64 <udp4_sockaddr+0x40>
     return(EINVAL);
 3239e58:	00800584 	movi	r2,22
 3239e5c:	e0bfff15 	stw	r2,-4(fp)
 3239e60:	00004106 	br	3239f68 <udp4_sockaddr+0x144>
  udpconn = udp_lookup(so);
 3239e64:	e13ffc17 	ldw	r4,-16(fp)
 3239e68:	32392600 	call	3239260 <udp_lookup>
 3239e6c:	e0bffa15 	stw	r2,-24(fp)
  if (!udpconn)
 3239e70:	e0bffa17 	ldw	r2,-24(fp)
 3239e74:	1004c03a 	cmpne	r2,r2,zero
 3239e78:	1000031e 	bne	r2,zero,3239e88 <udp4_sockaddr+0x64>
     return(EINVAL);
 3239e7c:	00800584 	movi	r2,22
 3239e80:	e0bfff15 	stw	r2,-4(fp)
 3239e84:	00003806 	br	3239f68 <udp4_sockaddr+0x144>
  nam->m_len = sizeof(*sin);
 3239e88:	e0fffd17 	ldw	r3,-12(fp)
 3239e8c:	00800404 	movi	r2,16
 3239e90:	18800215 	stw	r2,8(r3)
  if (req == PRU_SOCKADDR)
 3239e94:	e0bffe17 	ldw	r2,-8(fp)
 3239e98:	108003d8 	cmpnei	r2,r2,15
 3239e9c:	1000191e 	bne	r2,zero,3239f04 <udp4_sockaddr+0xe0>
  {
     sin->sin_family = AF_INET;
 3239ea0:	e0fffb17 	ldw	r3,-20(fp)
 3239ea4:	00800084 	movi	r2,2
 3239ea8:	1880000d 	sth	r2,0(r3)
     sin->sin_port = htons(udpconn->u_lport);
 3239eac:	e0bffa17 	ldw	r2,-24(fp)
 3239eb0:	1080018b 	ldhu	r2,6(r2)
 3239eb4:	10bfffcc 	andi	r2,r2,65535
 3239eb8:	1004d23a 	srli	r2,r2,8
 3239ebc:	10803fcc 	andi	r2,r2,255
 3239ec0:	1009883a 	mov	r4,r2
 3239ec4:	e0bffa17 	ldw	r2,-24(fp)
 3239ec8:	1080018b 	ldhu	r2,6(r2)
 3239ecc:	10bfffcc 	andi	r2,r2,65535
 3239ed0:	1004923a 	slli	r2,r2,8
 3239ed4:	1007883a 	mov	r3,r2
 3239ed8:	00bfc004 	movi	r2,-256
 3239edc:	1884703a 	and	r2,r3,r2
 3239ee0:	2084b03a 	or	r2,r4,r2
 3239ee4:	1007883a 	mov	r3,r2
 3239ee8:	e0bffb17 	ldw	r2,-20(fp)
 3239eec:	10c0008d 	sth	r3,2(r2)
     sin->sin_addr.s_addr = udpconn->u_lhost;
 3239ef0:	e0bffa17 	ldw	r2,-24(fp)
 3239ef4:	10c00317 	ldw	r3,12(r2)
 3239ef8:	e0bffb17 	ldw	r2,-20(fp)
 3239efc:	10c00115 	stw	r3,4(r2)
 3239f00:	00001806 	br	3239f64 <udp4_sockaddr+0x140>
  }
  else /* PRU_PEERADDR */
  {
    sin->sin_family = AF_INET;
 3239f04:	e0fffb17 	ldw	r3,-20(fp)
 3239f08:	00800084 	movi	r2,2
 3239f0c:	1880000d 	sth	r2,0(r3)
    sin->sin_port = htons(udpconn->u_fport);
 3239f10:	e0bffa17 	ldw	r2,-24(fp)
 3239f14:	1080020b 	ldhu	r2,8(r2)
 3239f18:	10bfffcc 	andi	r2,r2,65535
 3239f1c:	1004d23a 	srli	r2,r2,8
 3239f20:	10803fcc 	andi	r2,r2,255
 3239f24:	1009883a 	mov	r4,r2
 3239f28:	e0bffa17 	ldw	r2,-24(fp)
 3239f2c:	1080020b 	ldhu	r2,8(r2)
 3239f30:	10bfffcc 	andi	r2,r2,65535
 3239f34:	1004923a 	slli	r2,r2,8
 3239f38:	1007883a 	mov	r3,r2
 3239f3c:	00bfc004 	movi	r2,-256
 3239f40:	1884703a 	and	r2,r3,r2
 3239f44:	2084b03a 	or	r2,r4,r2
 3239f48:	1007883a 	mov	r3,r2
 3239f4c:	e0bffb17 	ldw	r2,-20(fp)
 3239f50:	10c0008d 	sth	r3,2(r2)
    sin->sin_addr.s_addr = udpconn->u_fhost;
 3239f54:	e0bffa17 	ldw	r2,-24(fp)
 3239f58:	10c00417 	ldw	r3,16(r2)
 3239f5c:	e0bffb17 	ldw	r2,-20(fp)
 3239f60:	10c00115 	stw	r3,4(r2)
  }
  return 0;
 3239f64:	e03fff15 	stw	zero,-4(fp)
 3239f68:	e0bfff17 	ldw	r2,-4(fp)
}
 3239f6c:	e037883a 	mov	sp,fp
 3239f70:	dfc00117 	ldw	ra,4(sp)
 3239f74:	df000017 	ldw	fp,0(sp)
 3239f78:	dec00204 	addi	sp,sp,8
 3239f7c:	f800283a 	ret

03239f80 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 3239f80:	defff404 	addi	sp,sp,-48
 3239f84:	df000b15 	stw	fp,44(sp)
 3239f88:	df000b04 	addi	fp,sp,44
 3239f8c:	e13ffb15 	stw	r4,-20(fp)
 3239f90:	e17ffc15 	stw	r5,-16(fp)
 3239f94:	e1bffd15 	stw	r6,-12(fp)
 3239f98:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 3239f9c:	e03ff915 	stw	zero,-28(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 3239fa0:	0080c974 	movhi	r2,805
 3239fa4:	10926604 	addi	r2,r2,18840
 3239fa8:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
 3239fac:	1005003a 	cmpeq	r2,r2,zero
 3239fb0:	1000411e 	bne	r2,zero,323a0b8 <alt_alarm_start+0x138>
  {
    if (alarm)
 3239fb4:	e0bffb17 	ldw	r2,-20(fp)
 3239fb8:	1005003a 	cmpeq	r2,r2,zero
 3239fbc:	10003b1e 	bne	r2,zero,323a0ac <alt_alarm_start+0x12c>
    {
      alarm->callback = callback;
 3239fc0:	e0fffb17 	ldw	r3,-20(fp)
 3239fc4:	e0bffd17 	ldw	r2,-12(fp)
 3239fc8:	18800315 	stw	r2,12(r3)
      alarm->context  = context;
 3239fcc:	e0fffb17 	ldw	r3,-20(fp)
 3239fd0:	e0bffe17 	ldw	r2,-8(fp)
 3239fd4:	18800515 	stw	r2,20(r3)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3239fd8:	0005303a 	rdctl	r2,status
 3239fdc:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3239fe0:	e0fff817 	ldw	r3,-32(fp)
 3239fe4:	00bfff84 	movi	r2,-2
 3239fe8:	1884703a 	and	r2,r3,r2
 3239fec:	1001703a 	wrctl	status,r2
  
  return context;
 3239ff0:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
 3239ff4:	e0bffa15 	stw	r2,-24(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 3239ff8:	0080c974 	movhi	r2,805
 3239ffc:	10926704 	addi	r2,r2,18844
 323a000:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
 323a004:	e0bff915 	stw	r2,-28(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 323a008:	e0fffc17 	ldw	r3,-16(fp)
 323a00c:	e0bff917 	ldw	r2,-28(fp)
 323a010:	1885883a 	add	r2,r3,r2
 323a014:	10c00044 	addi	r3,r2,1
 323a018:	e0bffb17 	ldw	r2,-20(fp)
 323a01c:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 323a020:	e0bffb17 	ldw	r2,-20(fp)
 323a024:	10c00217 	ldw	r3,8(r2)
 323a028:	e0bff917 	ldw	r2,-28(fp)
 323a02c:	1880042e 	bgeu	r3,r2,323a040 <alt_alarm_start+0xc0>
      {
        alarm->rollover = 1;
 323a030:	e0fffb17 	ldw	r3,-20(fp)
 323a034:	00800044 	movi	r2,1
 323a038:	18800405 	stb	r2,16(r3)
 323a03c:	00000206 	br	323a048 <alt_alarm_start+0xc8>
      }
      else
      {
        alarm->rollover = 0;
 323a040:	e0bffb17 	ldw	r2,-20(fp)
 323a044:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 323a048:	e0fffb17 	ldw	r3,-20(fp)
 323a04c:	0080c974 	movhi	r2,805
 323a050:	1089bc04 	addi	r2,r2,9968
 323a054:	e0bff615 	stw	r2,-40(fp)
 323a058:	e0fff715 	stw	r3,-36(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 323a05c:	e0fff717 	ldw	r3,-36(fp)
 323a060:	e0bff617 	ldw	r2,-40(fp)
 323a064:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 323a068:	e0bff617 	ldw	r2,-40(fp)
 323a06c:	10c00017 	ldw	r3,0(r2)
 323a070:	e0bff717 	ldw	r2,-36(fp)
 323a074:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 323a078:	e0bff617 	ldw	r2,-40(fp)
 323a07c:	10c00017 	ldw	r3,0(r2)
 323a080:	e0bff717 	ldw	r2,-36(fp)
 323a084:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 323a088:	e0fff617 	ldw	r3,-40(fp)
 323a08c:	e0bff717 	ldw	r2,-36(fp)
 323a090:	18800015 	stw	r2,0(r3)
 323a094:	e0bffa17 	ldw	r2,-24(fp)
 323a098:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 323a09c:	e0bff517 	ldw	r2,-44(fp)
 323a0a0:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 323a0a4:	e03fff15 	stw	zero,-4(fp)
 323a0a8:	00000506 	br	323a0c0 <alt_alarm_start+0x140>
    }
    else
    {
      return -EINVAL;
 323a0ac:	00bffa84 	movi	r2,-22
 323a0b0:	e0bfff15 	stw	r2,-4(fp)
 323a0b4:	00000206 	br	323a0c0 <alt_alarm_start+0x140>
    }
  }
  else
  {
    return -ENOTSUP;
 323a0b8:	00bfde84 	movi	r2,-134
 323a0bc:	e0bfff15 	stw	r2,-4(fp)
 323a0c0:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 323a0c4:	e037883a 	mov	sp,fp
 323a0c8:	df000017 	ldw	fp,0(sp)
 323a0cc:	dec00104 	addi	sp,sp,4
 323a0d0:	f800283a 	ret

0323a0d4 <alt_close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 323a0d4:	defff804 	addi	sp,sp,-32
 323a0d8:	dfc00715 	stw	ra,28(sp)
 323a0dc:	df000615 	stw	fp,24(sp)
 323a0e0:	df000604 	addi	fp,sp,24
 323a0e4:	e13ffc15 	stw	r4,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 323a0e8:	e0bffc17 	ldw	r2,-16(fp)
 323a0ec:	1004803a 	cmplt	r2,r2,zero
 323a0f0:	1000081e 	bne	r2,zero,323a114 <alt_close+0x40>
 323a0f4:	e0bffc17 	ldw	r2,-16(fp)
 323a0f8:	10800324 	muli	r2,r2,12
 323a0fc:	1007883a 	mov	r3,r2
 323a100:	0080c974 	movhi	r2,805
 323a104:	10888304 	addi	r2,r2,8716
 323a108:	1887883a 	add	r3,r3,r2
 323a10c:	e0ffff15 	stw	r3,-4(fp)
 323a110:	00000106 	br	323a118 <alt_close+0x44>
 323a114:	e03fff15 	stw	zero,-4(fp)
 323a118:	e0bfff17 	ldw	r2,-4(fp)
 323a11c:	e0bffb15 	stw	r2,-20(fp)

  if (fd)
 323a120:	e0bffb17 	ldw	r2,-20(fp)
 323a124:	1005003a 	cmpeq	r2,r2,zero
 323a128:	10001d1e 	bne	r2,zero,323a1a0 <alt_close+0xcc>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 323a12c:	e0bffb17 	ldw	r2,-20(fp)
 323a130:	10800017 	ldw	r2,0(r2)
 323a134:	10800417 	ldw	r2,16(r2)
 323a138:	1005003a 	cmpeq	r2,r2,zero
 323a13c:	1000071e 	bne	r2,zero,323a15c <alt_close+0x88>
 323a140:	e0bffb17 	ldw	r2,-20(fp)
 323a144:	10800017 	ldw	r2,0(r2)
 323a148:	10800417 	ldw	r2,16(r2)
 323a14c:	e13ffb17 	ldw	r4,-20(fp)
 323a150:	103ee83a 	callr	r2
 323a154:	e0bffe15 	stw	r2,-8(fp)
 323a158:	00000106 	br	323a160 <alt_close+0x8c>
 323a15c:	e03ffe15 	stw	zero,-8(fp)
 323a160:	e0bffe17 	ldw	r2,-8(fp)
 323a164:	e0bffa15 	stw	r2,-24(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 323a168:	e13ffc17 	ldw	r4,-16(fp)
 323a16c:	3214e480 	call	3214e48 <alt_release_fd>
    if (rval < 0)
 323a170:	e0bffa17 	ldw	r2,-24(fp)
 323a174:	1004403a 	cmpge	r2,r2,zero
 323a178:	1000071e 	bne	r2,zero,323a198 <alt_close+0xc4>
    {
      ALT_ERRNO = -rval;
 323a17c:	323a1d00 	call	323a1d0 <alt_get_errno>
 323a180:	e0fffa17 	ldw	r3,-24(fp)
 323a184:	00c7c83a 	sub	r3,zero,r3
 323a188:	10c00015 	stw	r3,0(r2)
      return -1;
 323a18c:	00bfffc4 	movi	r2,-1
 323a190:	e0bffd15 	stw	r2,-12(fp)
 323a194:	00000806 	br	323a1b8 <alt_close+0xe4>
    }
    return 0;
 323a198:	e03ffd15 	stw	zero,-12(fp)
 323a19c:	00000606 	br	323a1b8 <alt_close+0xe4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 323a1a0:	323a1d00 	call	323a1d0 <alt_get_errno>
 323a1a4:	1007883a 	mov	r3,r2
 323a1a8:	00801444 	movi	r2,81
 323a1ac:	18800015 	stw	r2,0(r3)
    return -1;
 323a1b0:	00bfffc4 	movi	r2,-1
 323a1b4:	e0bffd15 	stw	r2,-12(fp)
 323a1b8:	e0bffd17 	ldw	r2,-12(fp)
  }
}
 323a1bc:	e037883a 	mov	sp,fp
 323a1c0:	dfc00117 	ldw	ra,4(sp)
 323a1c4:	df000017 	ldw	fp,0(sp)
 323a1c8:	dec00204 	addi	sp,sp,8
 323a1cc:	f800283a 	ret

0323a1d0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 323a1d0:	defffd04 	addi	sp,sp,-12
 323a1d4:	dfc00215 	stw	ra,8(sp)
 323a1d8:	df000115 	stw	fp,4(sp)
 323a1dc:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 323a1e0:	0080c974 	movhi	r2,805
 323a1e4:	1089ba04 	addi	r2,r2,9960
 323a1e8:	10800017 	ldw	r2,0(r2)
 323a1ec:	1005003a 	cmpeq	r2,r2,zero
 323a1f0:	1000061e 	bne	r2,zero,323a20c <alt_get_errno+0x3c>
 323a1f4:	0080c974 	movhi	r2,805
 323a1f8:	1089ba04 	addi	r2,r2,9960
 323a1fc:	10800017 	ldw	r2,0(r2)
 323a200:	103ee83a 	callr	r2
 323a204:	e0bfff15 	stw	r2,-4(fp)
 323a208:	00000306 	br	323a218 <alt_get_errno+0x48>
 323a20c:	0080c974 	movhi	r2,805
 323a210:	10920d04 	addi	r2,r2,18484
 323a214:	e0bfff15 	stw	r2,-4(fp)
 323a218:	e0bfff17 	ldw	r2,-4(fp)
}
 323a21c:	e037883a 	mov	sp,fp
 323a220:	dfc00117 	ldw	ra,4(sp)
 323a224:	df000017 	ldw	fp,0(sp)
 323a228:	dec00204 	addi	sp,sp,8
 323a22c:	f800283a 	ret

0323a230 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 323a230:	defffb04 	addi	sp,sp,-20
 323a234:	df000415 	stw	fp,16(sp)
 323a238:	df000404 	addi	fp,sp,16
 323a23c:	e13ffe15 	stw	r4,-8(fp)
 323a240:	e17fff15 	stw	r5,-4(fp)
  {
    len = NIOS2_DCACHE_SIZE;
  }
  #endif

  end = ((char*) start) + len; 
 323a244:	e0fffe17 	ldw	r3,-8(fp)
 323a248:	e0bfff17 	ldw	r2,-4(fp)
 323a24c:	1885883a 	add	r2,r3,r2
 323a250:	e0bffc15 	stw	r2,-16(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 323a254:	e0bffe17 	ldw	r2,-8(fp)
 323a258:	e0bffd15 	stw	r2,-12(fp)
 323a25c:	00000506 	br	323a274 <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
 323a260:	e0bffd17 	ldw	r2,-12(fp)
 323a264:	1000001b 	flushda	0(r2)
  }
  #endif

  end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 323a268:	e0bffd17 	ldw	r2,-12(fp)
 323a26c:	10800804 	addi	r2,r2,32
 323a270:	e0bffd15 	stw	r2,-12(fp)
 323a274:	e0fffd17 	ldw	r3,-12(fp)
 323a278:	e0bffc17 	ldw	r2,-16(fp)
 323a27c:	18bff836 	bltu	r3,r2,323a260 <alt_dcache_flush+0x30>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
 323a280:	e0bffe17 	ldw	r2,-8(fp)
 323a284:	108007cc 	andi	r2,r2,31
 323a288:	1005003a 	cmpeq	r2,r2,zero
 323a28c:	1000021e 	bne	r2,zero,323a298 <alt_dcache_flush+0x68>
  {
    ALT_FLUSH_DATA(i);
 323a290:	e0bffd17 	ldw	r2,-12(fp)
 323a294:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 323a298:	e037883a 	mov	sp,fp
 323a29c:	df000017 	ldw	fp,0(sp)
 323a2a0:	dec00104 	addi	sp,sp,4
 323a2a4:	f800283a 	ret

0323a2a8 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 323a2a8:	defffe04 	addi	sp,sp,-8
 323a2ac:	df000115 	stw	fp,4(sp)
 323a2b0:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 323a2b4:	e03fff15 	stw	zero,-4(fp)
 323a2b8:	00000506 	br	323a2d0 <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
 323a2bc:	e0bfff17 	ldw	r2,-4(fp)
 323a2c0:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 323a2c4:	e0bfff17 	ldw	r2,-4(fp)
 323a2c8:	10800804 	addi	r2,r2,32
 323a2cc:	e0bfff15 	stw	r2,-4(fp)
 323a2d0:	e0bfff17 	ldw	r2,-4(fp)
 323a2d4:	10900030 	cmpltui	r2,r2,16384
 323a2d8:	103ff81e 	bne	r2,zero,323a2bc <alt_dcache_flush_all+0x14>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 323a2dc:	e037883a 	mov	sp,fp
 323a2e0:	df000017 	ldw	fp,0(sp)
 323a2e4:	dec00104 	addi	sp,sp,4
 323a2e8:	f800283a 	ret

0323a2ec <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 323a2ec:	defffc04 	addi	sp,sp,-16
 323a2f0:	df000315 	stw	fp,12(sp)
 323a2f4:	df000304 	addi	fp,sp,12
 323a2f8:	e13ffd15 	stw	r4,-12(fp)
 323a2fc:	e17ffe15 	stw	r5,-8(fp)
 323a300:	e1bfff15 	stw	r6,-4(fp)
  return len;
 323a304:	e0bfff17 	ldw	r2,-4(fp)
}
 323a308:	e037883a 	mov	sp,fp
 323a30c:	df000017 	ldw	fp,0(sp)
 323a310:	dec00104 	addi	sp,sp,4
 323a314:	f800283a 	ret

0323a318 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 323a318:	defff904 	addi	sp,sp,-28
 323a31c:	dfc00615 	stw	ra,24(sp)
 323a320:	df000515 	stw	fp,20(sp)
 323a324:	df000504 	addi	fp,sp,20
 323a328:	e13ffd15 	stw	r4,-12(fp)
 323a32c:	e17ffe15 	stw	r5,-8(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 323a330:	e0bffd17 	ldw	r2,-12(fp)
 323a334:	1005003a 	cmpeq	r2,r2,zero
 323a338:	1000041e 	bne	r2,zero,323a34c <alt_dev_llist_insert+0x34>
 323a33c:	e0bffd17 	ldw	r2,-12(fp)
 323a340:	10800217 	ldw	r2,8(r2)
 323a344:	1004c03a 	cmpne	r2,r2,zero
 323a348:	1000071e 	bne	r2,zero,323a368 <alt_dev_llist_insert+0x50>
  {
    ALT_ERRNO = EINVAL;
 323a34c:	323a3cc0 	call	323a3cc <alt_get_errno>
 323a350:	1007883a 	mov	r3,r2
 323a354:	00800584 	movi	r2,22
 323a358:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 323a35c:	00bffa84 	movi	r2,-22
 323a360:	e0bfff15 	stw	r2,-4(fp)
 323a364:	00001306 	br	323a3b4 <alt_dev_llist_insert+0x9c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 323a368:	e0fffd17 	ldw	r3,-12(fp)
 323a36c:	e0bffe17 	ldw	r2,-8(fp)
 323a370:	e0bffb15 	stw	r2,-20(fp)
 323a374:	e0fffc15 	stw	r3,-16(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 323a378:	e0fffc17 	ldw	r3,-16(fp)
 323a37c:	e0bffb17 	ldw	r2,-20(fp)
 323a380:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 323a384:	e0bffb17 	ldw	r2,-20(fp)
 323a388:	10c00017 	ldw	r3,0(r2)
 323a38c:	e0bffc17 	ldw	r2,-16(fp)
 323a390:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 323a394:	e0bffb17 	ldw	r2,-20(fp)
 323a398:	10c00017 	ldw	r3,0(r2)
 323a39c:	e0bffc17 	ldw	r2,-16(fp)
 323a3a0:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 323a3a4:	e0fffb17 	ldw	r3,-20(fp)
 323a3a8:	e0bffc17 	ldw	r2,-16(fp)
 323a3ac:	18800015 	stw	r2,0(r3)

  return 0;  
 323a3b0:	e03fff15 	stw	zero,-4(fp)
 323a3b4:	e0bfff17 	ldw	r2,-4(fp)
}
 323a3b8:	e037883a 	mov	sp,fp
 323a3bc:	dfc00117 	ldw	ra,4(sp)
 323a3c0:	df000017 	ldw	fp,0(sp)
 323a3c4:	dec00204 	addi	sp,sp,8
 323a3c8:	f800283a 	ret

0323a3cc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 323a3cc:	defffd04 	addi	sp,sp,-12
 323a3d0:	dfc00215 	stw	ra,8(sp)
 323a3d4:	df000115 	stw	fp,4(sp)
 323a3d8:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 323a3dc:	0080c974 	movhi	r2,805
 323a3e0:	1089ba04 	addi	r2,r2,9960
 323a3e4:	10800017 	ldw	r2,0(r2)
 323a3e8:	1005003a 	cmpeq	r2,r2,zero
 323a3ec:	1000061e 	bne	r2,zero,323a408 <alt_get_errno+0x3c>
 323a3f0:	0080c974 	movhi	r2,805
 323a3f4:	1089ba04 	addi	r2,r2,9960
 323a3f8:	10800017 	ldw	r2,0(r2)
 323a3fc:	103ee83a 	callr	r2
 323a400:	e0bfff15 	stw	r2,-4(fp)
 323a404:	00000306 	br	323a414 <alt_get_errno+0x48>
 323a408:	0080c974 	movhi	r2,805
 323a40c:	10920d04 	addi	r2,r2,18484
 323a410:	e0bfff15 	stw	r2,-4(fp)
 323a414:	e0bfff17 	ldw	r2,-4(fp)
}
 323a418:	e037883a 	mov	sp,fp
 323a41c:	dfc00117 	ldw	ra,4(sp)
 323a420:	df000017 	ldw	fp,0(sp)
 323a424:	dec00204 	addi	sp,sp,8
 323a428:	f800283a 	ret

0323a42c <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 323a42c:	defffd04 	addi	sp,sp,-12
 323a430:	dfc00215 	stw	ra,8(sp)
 323a434:	df000115 	stw	fp,4(sp)
 323a438:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 323a43c:	00bfff04 	movi	r2,-4
 323a440:	00c0c974 	movhi	r3,805
 323a444:	18f01d04 	addi	r3,r3,-16268
 323a448:	1885883a 	add	r2,r3,r2
 323a44c:	e0bfff15 	stw	r2,-4(fp)
 323a450:	00000606 	br	323a46c <_do_ctors+0x40>
        (*ctor) (); 
 323a454:	e0bfff17 	ldw	r2,-4(fp)
 323a458:	10800017 	ldw	r2,0(r2)
 323a45c:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 323a460:	e0bfff17 	ldw	r2,-4(fp)
 323a464:	10bfff04 	addi	r2,r2,-4
 323a468:	e0bfff15 	stw	r2,-4(fp)
 323a46c:	e0ffff17 	ldw	r3,-4(fp)
 323a470:	0080c974 	movhi	r2,805
 323a474:	10b01c04 	addi	r2,r2,-16272
 323a478:	18bff62e 	bgeu	r3,r2,323a454 <_do_ctors+0x28>
        (*ctor) (); 
}
 323a47c:	e037883a 	mov	sp,fp
 323a480:	dfc00117 	ldw	ra,4(sp)
 323a484:	df000017 	ldw	fp,0(sp)
 323a488:	dec00204 	addi	sp,sp,8
 323a48c:	f800283a 	ret

0323a490 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 323a490:	defffd04 	addi	sp,sp,-12
 323a494:	dfc00215 	stw	ra,8(sp)
 323a498:	df000115 	stw	fp,4(sp)
 323a49c:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 323a4a0:	00bfff04 	movi	r2,-4
 323a4a4:	00c0c974 	movhi	r3,805
 323a4a8:	18f01d04 	addi	r3,r3,-16268
 323a4ac:	1885883a 	add	r2,r3,r2
 323a4b0:	e0bfff15 	stw	r2,-4(fp)
 323a4b4:	00000606 	br	323a4d0 <_do_dtors+0x40>
        (*dtor) (); 
 323a4b8:	e0bfff17 	ldw	r2,-4(fp)
 323a4bc:	10800017 	ldw	r2,0(r2)
 323a4c0:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 323a4c4:	e0bfff17 	ldw	r2,-4(fp)
 323a4c8:	10bfff04 	addi	r2,r2,-4
 323a4cc:	e0bfff15 	stw	r2,-4(fp)
 323a4d0:	e0ffff17 	ldw	r3,-4(fp)
 323a4d4:	0080c974 	movhi	r2,805
 323a4d8:	10b01d04 	addi	r2,r2,-16268
 323a4dc:	18bff62e 	bgeu	r3,r2,323a4b8 <_do_dtors+0x28>
        (*dtor) (); 
}
 323a4e0:	e037883a 	mov	sp,fp
 323a4e4:	dfc00117 	ldw	ra,4(sp)
 323a4e8:	df000017 	ldw	fp,0(sp)
 323a4ec:	dec00204 	addi	sp,sp,8
 323a4f0:	f800283a 	ret

0323a4f4 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 323a4f4:	defff904 	addi	sp,sp,-28
 323a4f8:	dfc00615 	stw	ra,24(sp)
 323a4fc:	df000515 	stw	fp,20(sp)
 323a500:	df000504 	addi	fp,sp,20
 323a504:	e13ffd15 	stw	r4,-12(fp)
 323a508:	e17ffe15 	stw	r5,-8(fp)
  alt_dev* next = (alt_dev*) llist->next;
 323a50c:	e0bffe17 	ldw	r2,-8(fp)
 323a510:	10800017 	ldw	r2,0(r2)
 323a514:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 323a518:	e13ffd17 	ldw	r4,-12(fp)
 323a51c:	32081440 	call	3208144 <strlen>
 323a520:	10800044 	addi	r2,r2,1
 323a524:	e0bffb15 	stw	r2,-20(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 323a528:	00000d06 	br	323a560 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 323a52c:	e0bffc17 	ldw	r2,-16(fp)
 323a530:	11000217 	ldw	r4,8(r2)
 323a534:	e1bffb17 	ldw	r6,-20(fp)
 323a538:	e17ffd17 	ldw	r5,-12(fp)
 323a53c:	324b95c0 	call	324b95c <memcmp>
 323a540:	1004c03a 	cmpne	r2,r2,zero
 323a544:	1000031e 	bne	r2,zero,323a554 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 323a548:	e0bffc17 	ldw	r2,-16(fp)
 323a54c:	e0bfff15 	stw	r2,-4(fp)
 323a550:	00000706 	br	323a570 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 323a554:	e0bffc17 	ldw	r2,-16(fp)
 323a558:	10800017 	ldw	r2,0(r2)
 323a55c:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 323a560:	e0fffe17 	ldw	r3,-8(fp)
 323a564:	e0bffc17 	ldw	r2,-16(fp)
 323a568:	10fff01e 	bne	r2,r3,323a52c <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 323a56c:	e03fff15 	stw	zero,-4(fp)
 323a570:	e0bfff17 	ldw	r2,-4(fp)
}
 323a574:	e037883a 	mov	sp,fp
 323a578:	dfc00117 	ldw	ra,4(sp)
 323a57c:	df000017 	ldw	fp,0(sp)
 323a580:	dec00204 	addi	sp,sp,8
 323a584:	f800283a 	ret

0323a588 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 323a588:	defffa04 	addi	sp,sp,-24
 323a58c:	dfc00515 	stw	ra,20(sp)
 323a590:	df000415 	stw	fp,16(sp)
 323a594:	df000404 	addi	fp,sp,16
 323a598:	e13ffe15 	stw	r4,-8(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 323a59c:	0080c974 	movhi	r2,805
 323a5a0:	1089b504 	addi	r2,r2,9940
 323a5a4:	10800017 	ldw	r2,0(r2)
 323a5a8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 323a5ac:	00003306 	br	323a67c <alt_find_file+0xf4>
  {
    len = strlen(next->name);
 323a5b0:	e0bffd17 	ldw	r2,-12(fp)
 323a5b4:	11000217 	ldw	r4,8(r2)
 323a5b8:	32081440 	call	3208144 <strlen>
 323a5bc:	e0bffc15 	stw	r2,-16(fp)
    
    if (next->name[len-1] == '/')
 323a5c0:	e0bffd17 	ldw	r2,-12(fp)
 323a5c4:	10c00217 	ldw	r3,8(r2)
 323a5c8:	e0bffc17 	ldw	r2,-16(fp)
 323a5cc:	1885883a 	add	r2,r3,r2
 323a5d0:	10bfffc4 	addi	r2,r2,-1
 323a5d4:	10800003 	ldbu	r2,0(r2)
 323a5d8:	10803fcc 	andi	r2,r2,255
 323a5dc:	1080201c 	xori	r2,r2,128
 323a5e0:	10bfe004 	addi	r2,r2,-128
 323a5e4:	10800bd8 	cmpnei	r2,r2,47
 323a5e8:	1000031e 	bne	r2,zero,323a5f8 <alt_find_file+0x70>
    {
      len -= 1;
 323a5ec:	e0bffc17 	ldw	r2,-16(fp)
 323a5f0:	10bfffc4 	addi	r2,r2,-1
 323a5f4:	e0bffc15 	stw	r2,-16(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 323a5f8:	e0bffc17 	ldw	r2,-16(fp)
 323a5fc:	1007883a 	mov	r3,r2
 323a600:	e0bffe17 	ldw	r2,-8(fp)
 323a604:	1885883a 	add	r2,r3,r2
 323a608:	10800003 	ldbu	r2,0(r2)
 323a60c:	10803fcc 	andi	r2,r2,255
 323a610:	1080201c 	xori	r2,r2,128
 323a614:	10bfe004 	addi	r2,r2,-128
 323a618:	10800be0 	cmpeqi	r2,r2,47
 323a61c:	10000a1e 	bne	r2,zero,323a648 <alt_find_file+0xc0>
 323a620:	e0bffc17 	ldw	r2,-16(fp)
 323a624:	1007883a 	mov	r3,r2
 323a628:	e0bffe17 	ldw	r2,-8(fp)
 323a62c:	1885883a 	add	r2,r3,r2
 323a630:	10800003 	ldbu	r2,0(r2)
 323a634:	10803fcc 	andi	r2,r2,255
 323a638:	1080201c 	xori	r2,r2,128
 323a63c:	10bfe004 	addi	r2,r2,-128
 323a640:	1004c03a 	cmpne	r2,r2,zero
 323a644:	10000a1e 	bne	r2,zero,323a670 <alt_find_file+0xe8>
 323a648:	e0bffd17 	ldw	r2,-12(fp)
 323a64c:	11000217 	ldw	r4,8(r2)
 323a650:	e1bffc17 	ldw	r6,-16(fp)
 323a654:	e17ffe17 	ldw	r5,-8(fp)
 323a658:	324b95c0 	call	324b95c <memcmp>
 323a65c:	1004c03a 	cmpne	r2,r2,zero
 323a660:	1000031e 	bne	r2,zero,323a670 <alt_find_file+0xe8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 323a664:	e0bffd17 	ldw	r2,-12(fp)
 323a668:	e0bfff15 	stw	r2,-4(fp)
 323a66c:	00000806 	br	323a690 <alt_find_file+0x108>
    }
    next = (alt_dev*) next->llist.next;
 323a670:	e0bffd17 	ldw	r2,-12(fp)
 323a674:	10800017 	ldw	r2,0(r2)
 323a678:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 323a67c:	00c0c974 	movhi	r3,805
 323a680:	18c9b504 	addi	r3,r3,9940
 323a684:	e0bffd17 	ldw	r2,-12(fp)
 323a688:	10ffc91e 	bne	r2,r3,323a5b0 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 323a68c:	e03fff15 	stw	zero,-4(fp)
 323a690:	e0bfff17 	ldw	r2,-4(fp)
}
 323a694:	e037883a 	mov	sp,fp
 323a698:	dfc00117 	ldw	ra,4(sp)
 323a69c:	df000017 	ldw	fp,0(sp)
 323a6a0:	dec00204 	addi	sp,sp,8
 323a6a4:	f800283a 	ret

0323a6a8 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 323a6a8:	defff804 	addi	sp,sp,-32
 323a6ac:	dfc00715 	stw	ra,28(sp)
 323a6b0:	df000615 	stw	fp,24(sp)
 323a6b4:	df000604 	addi	fp,sp,24
 323a6b8:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 323a6bc:	00bffa04 	movi	r2,-24
 323a6c0:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
 323a6c4:	0080c974 	movhi	r2,805
 323a6c8:	10926404 	addi	r2,r2,18832
 323a6cc:	10800017 	ldw	r2,0(r2)
 323a6d0:	e0bffa15 	stw	r2,-24(fp)
 323a6d4:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 323a6d8:	e17ffb0b 	ldhu	r5,-20(fp)
 323a6dc:	e1bffe04 	addi	r6,fp,-8
 323a6e0:	e13ffa17 	ldw	r4,-24(fp)
 323a6e4:	321ade40 	call	321ade4 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 323a6e8:	e03ffd15 	stw	zero,-12(fp)
 323a6ec:	00001e06 	br	323a768 <alt_get_fd+0xc0>
  {
    if (!alt_fd_list[i].dev)
 323a6f0:	e0bffd17 	ldw	r2,-12(fp)
 323a6f4:	00c0c974 	movhi	r3,805
 323a6f8:	18c88304 	addi	r3,r3,8716
 323a6fc:	10800324 	muli	r2,r2,12
 323a700:	10c5883a 	add	r2,r2,r3
 323a704:	10800017 	ldw	r2,0(r2)
 323a708:	1004c03a 	cmpne	r2,r2,zero
 323a70c:	1000131e 	bne	r2,zero,323a75c <alt_get_fd+0xb4>
    {
      alt_fd_list[i].dev = dev;
 323a710:	e0bffd17 	ldw	r2,-12(fp)
 323a714:	00c0c974 	movhi	r3,805
 323a718:	18c88304 	addi	r3,r3,8716
 323a71c:	10800324 	muli	r2,r2,12
 323a720:	10c7883a 	add	r3,r2,r3
 323a724:	e0bfff17 	ldw	r2,-4(fp)
 323a728:	18800015 	stw	r2,0(r3)
      if (i > alt_max_fd)
 323a72c:	0080c974 	movhi	r2,805
 323a730:	1089b904 	addi	r2,r2,9956
 323a734:	10c00017 	ldw	r3,0(r2)
 323a738:	e0bffd17 	ldw	r2,-12(fp)
 323a73c:	1880040e 	bge	r3,r2,323a750 <alt_get_fd+0xa8>
      {
        alt_max_fd = i;
 323a740:	00c0c974 	movhi	r3,805
 323a744:	18c9b904 	addi	r3,r3,9956
 323a748:	e0bffd17 	ldw	r2,-12(fp)
 323a74c:	18800015 	stw	r2,0(r3)
      }
      rc = i;
 323a750:	e0bffd17 	ldw	r2,-12(fp)
 323a754:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
 323a758:	00000606 	br	323a774 <alt_get_fd+0xcc>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 323a75c:	e0bffd17 	ldw	r2,-12(fp)
 323a760:	10800044 	addi	r2,r2,1
 323a764:	e0bffd15 	stw	r2,-12(fp)
 323a768:	e0bffd17 	ldw	r2,-12(fp)
 323a76c:	10800810 	cmplti	r2,r2,32
 323a770:	103fdf1e 	bne	r2,zero,323a6f0 <alt_get_fd+0x48>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
 323a774:	0080c974 	movhi	r2,805
 323a778:	10926404 	addi	r2,r2,18832
 323a77c:	11000017 	ldw	r4,0(r2)
 323a780:	321b1dc0 	call	321b1dc <OSSemPost>

  return rc;
 323a784:	e0bffc17 	ldw	r2,-16(fp)
}
 323a788:	e037883a 	mov	sp,fp
 323a78c:	dfc00117 	ldw	ra,4(sp)
 323a790:	df000017 	ldw	fp,0(sp)
 323a794:	dec00204 	addi	sp,sp,8
 323a798:	f800283a 	ret

0323a79c <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 323a79c:	defffe04 	addi	sp,sp,-8
 323a7a0:	dfc00115 	stw	ra,4(sp)
 323a7a4:	df000015 	stw	fp,0(sp)
 323a7a8:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 323a7ac:	0009883a 	mov	r4,zero
 323a7b0:	01500004 	movi	r5,16384
 323a7b4:	324a5180 	call	324a518 <alt_icache_flush>
#endif
}
 323a7b8:	e037883a 	mov	sp,fp
 323a7bc:	dfc00117 	ldw	ra,4(sp)
 323a7c0:	df000017 	ldw	fp,0(sp)
 323a7c4:	dec00204 	addi	sp,sp,8
 323a7c8:	f800283a 	ret

0323a7cc <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 323a7cc:	defff904 	addi	sp,sp,-28
 323a7d0:	dfc00615 	stw	ra,24(sp)
 323a7d4:	df000515 	stw	fp,20(sp)
 323a7d8:	df000504 	addi	fp,sp,20
 323a7dc:	e13ffc15 	stw	r4,-16(fp)
 323a7e0:	e17ffd15 	stw	r5,-12(fp)
 323a7e4:	e1bffe15 	stw	r6,-8(fp)
 323a7e8:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 323a7ec:	e13ffd17 	ldw	r4,-12(fp)
 323a7f0:	e17ffe17 	ldw	r5,-8(fp)
 323a7f4:	e1bfff17 	ldw	r6,-4(fp)
 323a7f8:	3214c600 	call	3214c60 <open>
 323a7fc:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 323a800:	e0bffb17 	ldw	r2,-20(fp)
 323a804:	1004803a 	cmplt	r2,r2,zero
 323a808:	10001c1e 	bne	r2,zero,323a87c <alt_open_fd+0xb0>
  {
    fd->dev      = alt_fd_list[old].dev;
 323a80c:	e0bffb17 	ldw	r2,-20(fp)
 323a810:	00c0c974 	movhi	r3,805
 323a814:	18c88304 	addi	r3,r3,8716
 323a818:	10800324 	muli	r2,r2,12
 323a81c:	10c5883a 	add	r2,r2,r3
 323a820:	10c00017 	ldw	r3,0(r2)
 323a824:	e0bffc17 	ldw	r2,-16(fp)
 323a828:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 323a82c:	e0bffb17 	ldw	r2,-20(fp)
 323a830:	00c0c974 	movhi	r3,805
 323a834:	18c88304 	addi	r3,r3,8716
 323a838:	10800324 	muli	r2,r2,12
 323a83c:	10c5883a 	add	r2,r2,r3
 323a840:	10800104 	addi	r2,r2,4
 323a844:	10c00017 	ldw	r3,0(r2)
 323a848:	e0bffc17 	ldw	r2,-16(fp)
 323a84c:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 323a850:	e0bffb17 	ldw	r2,-20(fp)
 323a854:	00c0c974 	movhi	r3,805
 323a858:	18c88304 	addi	r3,r3,8716
 323a85c:	10800324 	muli	r2,r2,12
 323a860:	10c5883a 	add	r2,r2,r3
 323a864:	10800204 	addi	r2,r2,8
 323a868:	10c00017 	ldw	r3,0(r2)
 323a86c:	e0bffc17 	ldw	r2,-16(fp)
 323a870:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 323a874:	e13ffb17 	ldw	r4,-20(fp)
 323a878:	3214e480 	call	3214e48 <alt_release_fd>
  }
} 
 323a87c:	e037883a 	mov	sp,fp
 323a880:	dfc00117 	ldw	ra,4(sp)
 323a884:	df000017 	ldw	fp,0(sp)
 323a888:	dec00204 	addi	sp,sp,8
 323a88c:	f800283a 	ret

0323a890 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 323a890:	defffb04 	addi	sp,sp,-20
 323a894:	dfc00415 	stw	ra,16(sp)
 323a898:	df000315 	stw	fp,12(sp)
 323a89c:	df000304 	addi	fp,sp,12
 323a8a0:	e13ffd15 	stw	r4,-12(fp)
 323a8a4:	e17ffe15 	stw	r5,-8(fp)
 323a8a8:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 323a8ac:	0100c974 	movhi	r4,805
 323a8b0:	21088604 	addi	r4,r4,8728
 323a8b4:	e17ffd17 	ldw	r5,-12(fp)
 323a8b8:	01800044 	movi	r6,1
 323a8bc:	01c07fc4 	movi	r7,511
 323a8c0:	323a7cc0 	call	323a7cc <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 323a8c4:	0100c974 	movhi	r4,805
 323a8c8:	21088304 	addi	r4,r4,8716
 323a8cc:	e17ffe17 	ldw	r5,-8(fp)
 323a8d0:	000d883a 	mov	r6,zero
 323a8d4:	01c07fc4 	movi	r7,511
 323a8d8:	323a7cc0 	call	323a7cc <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 323a8dc:	0100c974 	movhi	r4,805
 323a8e0:	21088904 	addi	r4,r4,8740
 323a8e4:	e17fff17 	ldw	r5,-4(fp)
 323a8e8:	01800044 	movi	r6,1
 323a8ec:	01c07fc4 	movi	r7,511
 323a8f0:	323a7cc0 	call	323a7cc <alt_open_fd>
}  
 323a8f4:	e037883a 	mov	sp,fp
 323a8f8:	dfc00117 	ldw	ra,4(sp)
 323a8fc:	df000017 	ldw	fp,0(sp)
 323a900:	dec00204 	addi	sp,sp,8
 323a904:	f800283a 	ret

0323a908 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
 323a908:	deffef04 	addi	sp,sp,-68
 323a90c:	df001015 	stw	fp,64(sp)
 323a910:	df001004 	addi	fp,sp,64
 323a914:	e13ffc15 	stw	r4,-16(fp)
 323a918:	e17ffd15 	stw	r5,-12(fp)
 323a91c:	e1bffe15 	stw	r6,-8(fp)
  int rc = -EINVAL;  
 323a920:	00bffa84 	movi	r2,-22
 323a924:	e0bffb15 	stw	r2,-20(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 323a928:	e0bffc17 	ldw	r2,-16(fp)
 323a92c:	10800828 	cmpgeui	r2,r2,32
 323a930:	1000601e 	bne	r2,zero,323aab4 <alt_irq_register+0x1ac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 323a934:	0005303a 	rdctl	r2,status
 323a938:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 323a93c:	e0fff917 	ldw	r3,-28(fp)
 323a940:	00bfff84 	movi	r2,-2
 323a944:	1884703a 	and	r2,r3,r2
 323a948:	1001703a 	wrctl	status,r2
  
  return context;
 323a94c:	e0bff917 	ldw	r2,-28(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
 323a950:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = handler;
 323a954:	e0bffc17 	ldw	r2,-16(fp)
 323a958:	00c0c9b4 	movhi	r3,806
 323a95c:	18f47e04 	addi	r3,r3,-11784
 323a960:	100490fa 	slli	r2,r2,3
 323a964:	10c7883a 	add	r3,r2,r3
 323a968:	e0bffe17 	ldw	r2,-8(fp)
 323a96c:	18800015 	stw	r2,0(r3)
    alt_irq[id].context = context;
 323a970:	e0bffc17 	ldw	r2,-16(fp)
 323a974:	00c0c9b4 	movhi	r3,806
 323a978:	18f47e04 	addi	r3,r3,-11784
 323a97c:	100490fa 	slli	r2,r2,3
 323a980:	10c5883a 	add	r2,r2,r3
 323a984:	10c00104 	addi	r3,r2,4
 323a988:	e0bffd17 	ldw	r2,-12(fp)
 323a98c:	18800015 	stw	r2,0(r3)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
 323a990:	e0bffe17 	ldw	r2,-8(fp)
 323a994:	1005003a 	cmpeq	r2,r2,zero
 323a998:	1000201e 	bne	r2,zero,323aa1c <alt_irq_register+0x114>
 323a99c:	e0bffc17 	ldw	r2,-16(fp)
 323a9a0:	e0bff715 	stw	r2,-36(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 323a9a4:	0005303a 	rdctl	r2,status
 323a9a8:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 323a9ac:	e0fff617 	ldw	r3,-40(fp)
 323a9b0:	00bfff84 	movi	r2,-2
 323a9b4:	1884703a 	and	r2,r3,r2
 323a9b8:	1001703a 	wrctl	status,r2
  
  return context;
 323a9bc:	e0bff617 	ldw	r2,-40(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 323a9c0:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
 323a9c4:	e0fff717 	ldw	r3,-36(fp)
 323a9c8:	00800044 	movi	r2,1
 323a9cc:	10c4983a 	sll	r2,r2,r3
 323a9d0:	1007883a 	mov	r3,r2
 323a9d4:	0080c974 	movhi	r2,805
 323a9d8:	10926504 	addi	r2,r2,18836
 323a9dc:	10800017 	ldw	r2,0(r2)
 323a9e0:	1886b03a 	or	r3,r3,r2
 323a9e4:	0080c974 	movhi	r2,805
 323a9e8:	10926504 	addi	r2,r2,18836
 323a9ec:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 323a9f0:	0080c974 	movhi	r2,805
 323a9f4:	10926504 	addi	r2,r2,18836
 323a9f8:	10800017 	ldw	r2,0(r2)
 323a9fc:	100170fa 	wrctl	ienable,r2
 323aa00:	e0bff817 	ldw	r2,-32(fp)
 323aa04:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 323aa08:	e0bff517 	ldw	r2,-44(fp)
 323aa0c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 323aa10:	0005883a 	mov	r2,zero
 323aa14:	e0bfff15 	stw	r2,-4(fp)
 323aa18:	00002006 	br	323aa9c <alt_irq_register+0x194>
 323aa1c:	e0bffc17 	ldw	r2,-16(fp)
 323aa20:	e0bff315 	stw	r2,-52(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 323aa24:	0005303a 	rdctl	r2,status
 323aa28:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 323aa2c:	e0fff217 	ldw	r3,-56(fp)
 323aa30:	00bfff84 	movi	r2,-2
 323aa34:	1884703a 	and	r2,r3,r2
 323aa38:	1001703a 	wrctl	status,r2
  
  return context;
 323aa3c:	e0bff217 	ldw	r2,-56(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 323aa40:	e0bff415 	stw	r2,-48(fp)

  alt_irq_active &= ~(1 << id);
 323aa44:	e0fff317 	ldw	r3,-52(fp)
 323aa48:	00800044 	movi	r2,1
 323aa4c:	10c4983a 	sll	r2,r2,r3
 323aa50:	0084303a 	nor	r2,zero,r2
 323aa54:	1007883a 	mov	r3,r2
 323aa58:	0080c974 	movhi	r2,805
 323aa5c:	10926504 	addi	r2,r2,18836
 323aa60:	10800017 	ldw	r2,0(r2)
 323aa64:	1886703a 	and	r3,r3,r2
 323aa68:	0080c974 	movhi	r2,805
 323aa6c:	10926504 	addi	r2,r2,18836
 323aa70:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 323aa74:	0080c974 	movhi	r2,805
 323aa78:	10926504 	addi	r2,r2,18836
 323aa7c:	10800017 	ldw	r2,0(r2)
 323aa80:	100170fa 	wrctl	ienable,r2
 323aa84:	e0bff417 	ldw	r2,-48(fp)
 323aa88:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 323aa8c:	e0bff117 	ldw	r2,-60(fp)
 323aa90:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 323aa94:	0005883a 	mov	r2,zero
 323aa98:	e0bfff15 	stw	r2,-4(fp)
 323aa9c:	e0bfff17 	ldw	r2,-4(fp)
 323aaa0:	e0bffb15 	stw	r2,-20(fp)
 323aaa4:	e0bffa17 	ldw	r2,-24(fp)
 323aaa8:	e0bff015 	stw	r2,-64(fp)
 323aaac:	e0bff017 	ldw	r2,-64(fp)
 323aab0:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
 323aab4:	e0bffb17 	ldw	r2,-20(fp)
}
 323aab8:	e037883a 	mov	sp,fp
 323aabc:	df000017 	ldw	fp,0(sp)
 323aac0:	dec00104 	addi	sp,sp,4
 323aac4:	f800283a 	ret

0323aac8 <alt_read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 323aac8:	defff704 	addi	sp,sp,-36
 323aacc:	dfc00815 	stw	ra,32(sp)
 323aad0:	df000715 	stw	fp,28(sp)
 323aad4:	df000704 	addi	fp,sp,28
 323aad8:	e13ffb15 	stw	r4,-20(fp)
 323aadc:	e17ffc15 	stw	r5,-16(fp)
 323aae0:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 323aae4:	e0bffb17 	ldw	r2,-20(fp)
 323aae8:	1004803a 	cmplt	r2,r2,zero
 323aaec:	1000081e 	bne	r2,zero,323ab10 <alt_read+0x48>
 323aaf0:	e0bffb17 	ldw	r2,-20(fp)
 323aaf4:	10800324 	muli	r2,r2,12
 323aaf8:	1007883a 	mov	r3,r2
 323aafc:	0080c974 	movhi	r2,805
 323ab00:	10888304 	addi	r2,r2,8716
 323ab04:	1887883a 	add	r3,r3,r2
 323ab08:	e0ffff15 	stw	r3,-4(fp)
 323ab0c:	00000106 	br	323ab14 <alt_read+0x4c>
 323ab10:	e03fff15 	stw	zero,-4(fp)
 323ab14:	e0bfff17 	ldw	r2,-4(fp)
 323ab18:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 323ab1c:	e0bffa17 	ldw	r2,-24(fp)
 323ab20:	1005003a 	cmpeq	r2,r2,zero
 323ab24:	1000241e 	bne	r2,zero,323abb8 <alt_read+0xf0>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 323ab28:	e0bffa17 	ldw	r2,-24(fp)
 323ab2c:	10800217 	ldw	r2,8(r2)
 323ab30:	108000cc 	andi	r2,r2,3
 323ab34:	10800060 	cmpeqi	r2,r2,1
 323ab38:	10001a1e 	bne	r2,zero,323aba4 <alt_read+0xdc>
 323ab3c:	e0bffa17 	ldw	r2,-24(fp)
 323ab40:	10800017 	ldw	r2,0(r2)
 323ab44:	10800517 	ldw	r2,20(r2)
 323ab48:	1005003a 	cmpeq	r2,r2,zero
 323ab4c:	1000151e 	bne	r2,zero,323aba4 <alt_read+0xdc>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 323ab50:	e0bffa17 	ldw	r2,-24(fp)
 323ab54:	10800017 	ldw	r2,0(r2)
 323ab58:	10800517 	ldw	r2,20(r2)
 323ab5c:	e17ffc17 	ldw	r5,-16(fp)
 323ab60:	e1bffd17 	ldw	r6,-12(fp)
 323ab64:	e13ffa17 	ldw	r4,-24(fp)
 323ab68:	103ee83a 	callr	r2
 323ab6c:	e0bff915 	stw	r2,-28(fp)
 323ab70:	e0bff917 	ldw	r2,-28(fp)
 323ab74:	1004403a 	cmpge	r2,r2,zero
 323ab78:	1000071e 	bne	r2,zero,323ab98 <alt_read+0xd0>
        {
          ALT_ERRNO = -rval;
 323ab7c:	323abe80 	call	323abe8 <alt_get_errno>
 323ab80:	e0fff917 	ldw	r3,-28(fp)
 323ab84:	00c7c83a 	sub	r3,zero,r3
 323ab88:	10c00015 	stw	r3,0(r2)
          return -1;
 323ab8c:	00bfffc4 	movi	r2,-1
 323ab90:	e0bffe15 	stw	r2,-8(fp)
 323ab94:	00000e06 	br	323abd0 <alt_read+0x108>
        }
        return rval;
 323ab98:	e0bff917 	ldw	r2,-28(fp)
 323ab9c:	e0bffe15 	stw	r2,-8(fp)
 323aba0:	00000b06 	br	323abd0 <alt_read+0x108>
      }
      else
      {
        ALT_ERRNO = EACCES;
 323aba4:	323abe80 	call	323abe8 <alt_get_errno>
 323aba8:	1007883a 	mov	r3,r2
 323abac:	00800344 	movi	r2,13
 323abb0:	18800015 	stw	r2,0(r3)
 323abb4:	00000406 	br	323abc8 <alt_read+0x100>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 323abb8:	323abe80 	call	323abe8 <alt_get_errno>
 323abbc:	1007883a 	mov	r3,r2
 323abc0:	00801444 	movi	r2,81
 323abc4:	18800015 	stw	r2,0(r3)
  }
  return -1;
 323abc8:	00bfffc4 	movi	r2,-1
 323abcc:	e0bffe15 	stw	r2,-8(fp)
 323abd0:	e0bffe17 	ldw	r2,-8(fp)
}
 323abd4:	e037883a 	mov	sp,fp
 323abd8:	dfc00117 	ldw	ra,4(sp)
 323abdc:	df000017 	ldw	fp,0(sp)
 323abe0:	dec00204 	addi	sp,sp,8
 323abe4:	f800283a 	ret

0323abe8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 323abe8:	defffd04 	addi	sp,sp,-12
 323abec:	dfc00215 	stw	ra,8(sp)
 323abf0:	df000115 	stw	fp,4(sp)
 323abf4:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 323abf8:	0080c974 	movhi	r2,805
 323abfc:	1089ba04 	addi	r2,r2,9960
 323ac00:	10800017 	ldw	r2,0(r2)
 323ac04:	1005003a 	cmpeq	r2,r2,zero
 323ac08:	1000061e 	bne	r2,zero,323ac24 <alt_get_errno+0x3c>
 323ac0c:	0080c974 	movhi	r2,805
 323ac10:	1089ba04 	addi	r2,r2,9960
 323ac14:	10800017 	ldw	r2,0(r2)
 323ac18:	103ee83a 	callr	r2
 323ac1c:	e0bfff15 	stw	r2,-4(fp)
 323ac20:	00000306 	br	323ac30 <alt_get_errno+0x48>
 323ac24:	0080c974 	movhi	r2,805
 323ac28:	10920d04 	addi	r2,r2,18484
 323ac2c:	e0bfff15 	stw	r2,-4(fp)
 323ac30:	e0bfff17 	ldw	r2,-4(fp)
}
 323ac34:	e037883a 	mov	sp,fp
 323ac38:	dfc00117 	ldw	ra,4(sp)
 323ac3c:	df000017 	ldw	fp,0(sp)
 323ac40:	dec00204 	addi	sp,sp,8
 323ac44:	f800283a 	ret

0323ac48 <alt_remap_cached>:
 * Convert a pointer to a block of uncached memory, into a block of
 * cached memory.
 */

void* alt_remap_cached (volatile void* ptr, alt_u32 len)
{
 323ac48:	defffd04 	addi	sp,sp,-12
 323ac4c:	df000215 	stw	fp,8(sp)
 323ac50:	df000204 	addi	fp,sp,8
 323ac54:	e13ffe15 	stw	r4,-8(fp)
 323ac58:	e17fff15 	stw	r5,-4(fp)
  return (void*) (((alt_u32) ptr) & ~BYPASS_DCACHE_MASK);
 323ac5c:	e0bffe17 	ldw	r2,-8(fp)
 323ac60:	1007883a 	mov	r3,r2
 323ac64:	00a00034 	movhi	r2,32768
 323ac68:	10bfffc4 	addi	r2,r2,-1
 323ac6c:	1884703a 	and	r2,r3,r2
}
 323ac70:	e037883a 	mov	sp,fp
 323ac74:	df000017 	ldw	fp,0(sp)
 323ac78:	dec00104 	addi	sp,sp,4
 323ac7c:	f800283a 	ret

0323ac80 <alt_remap_uncached>:
 * Convert a pointer to a block of cached memory, into a block of
 * uncached memory.
 */

volatile void* alt_remap_uncached (void* ptr, alt_u32 len)
{
 323ac80:	defffc04 	addi	sp,sp,-16
 323ac84:	dfc00315 	stw	ra,12(sp)
 323ac88:	df000215 	stw	fp,8(sp)
 323ac8c:	df000204 	addi	fp,sp,8
 323ac90:	e13ffe15 	stw	r4,-8(fp)
 323ac94:	e17fff15 	stw	r5,-4(fp)
  alt_dcache_flush (ptr, len);
 323ac98:	e13ffe17 	ldw	r4,-8(fp)
 323ac9c:	e17fff17 	ldw	r5,-4(fp)
 323aca0:	323a2300 	call	323a230 <alt_dcache_flush>
  return (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK);
 323aca4:	e0bffe17 	ldw	r2,-8(fp)
 323aca8:	10a00034 	orhi	r2,r2,32768
}
 323acac:	e037883a 	mov	sp,fp
 323acb0:	dfc00117 	ldw	ra,4(sp)
 323acb4:	df000017 	ldw	fp,0(sp)
 323acb8:	dec00204 	addi	sp,sp,8
 323acbc:	f800283a 	ret

0323acc0 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 323acc0:	defffa04 	addi	sp,sp,-24
 323acc4:	df000515 	stw	fp,20(sp)
 323acc8:	df000504 	addi	fp,sp,20
 323accc:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 323acd0:	0005303a 	rdctl	r2,status
 323acd4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 323acd8:	e0fffd17 	ldw	r3,-12(fp)
 323acdc:	00bfff84 	movi	r2,-2
 323ace0:	1884703a 	and	r2,r3,r2
 323ace4:	1001703a 	wrctl	status,r2
  
  return context;
 323ace8:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 323acec:	e0bffe15 	stw	r2,-8(fp)
  alt_llist_remove (&alarm->llist);
 323acf0:	e0bfff17 	ldw	r2,-4(fp)
 323acf4:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 323acf8:	e0bffc17 	ldw	r2,-16(fp)
 323acfc:	10c00017 	ldw	r3,0(r2)
 323ad00:	e0bffc17 	ldw	r2,-16(fp)
 323ad04:	10800117 	ldw	r2,4(r2)
 323ad08:	18800115 	stw	r2,4(r3)
  entry->previous->next = entry->next;
 323ad0c:	e0bffc17 	ldw	r2,-16(fp)
 323ad10:	10c00117 	ldw	r3,4(r2)
 323ad14:	e0bffc17 	ldw	r2,-16(fp)
 323ad18:	10800017 	ldw	r2,0(r2)
 323ad1c:	18800015 	stw	r2,0(r3)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 323ad20:	e0fffc17 	ldw	r3,-16(fp)
 323ad24:	e0bffc17 	ldw	r2,-16(fp)
 323ad28:	18800115 	stw	r2,4(r3)
  entry->next     = entry;
 323ad2c:	e0fffc17 	ldw	r3,-16(fp)
 323ad30:	e0bffc17 	ldw	r2,-16(fp)
 323ad34:	18800015 	stw	r2,0(r3)
 323ad38:	e0bffe17 	ldw	r2,-8(fp)
 323ad3c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 323ad40:	e0bffb17 	ldw	r2,-20(fp)
 323ad44:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 323ad48:	e037883a 	mov	sp,fp
 323ad4c:	df000017 	ldw	fp,0(sp)
 323ad50:	dec00104 	addi	sp,sp,4
 323ad54:	f800283a 	ret

0323ad58 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 323ad58:	defffb04 	addi	sp,sp,-20
 323ad5c:	dfc00415 	stw	ra,16(sp)
 323ad60:	df000315 	stw	fp,12(sp)
 323ad64:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 323ad68:	d0a04517 	ldw	r2,-32492(gp)
 323ad6c:	e0bffe15 	stw	r2,-8(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 323ad70:	d0a8f017 	ldw	r2,-23616(gp)
 323ad74:	10800044 	addi	r2,r2,1
 323ad78:	d0a8f015 	stw	r2,-23616(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 323ad7c:	00003106 	br	323ae44 <alt_tick+0xec>
  {
    next = (alt_alarm*) alarm->llist.next;
 323ad80:	e0bffe17 	ldw	r2,-8(fp)
 323ad84:	10800017 	ldw	r2,0(r2)
 323ad88:	e0bfff15 	stw	r2,-4(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 323ad8c:	e0bffe17 	ldw	r2,-8(fp)
 323ad90:	10800403 	ldbu	r2,16(r2)
 323ad94:	10803fcc 	andi	r2,r2,255
 323ad98:	1005003a 	cmpeq	r2,r2,zero
 323ad9c:	1000051e 	bne	r2,zero,323adb4 <alt_tick+0x5c>
 323ada0:	d0a8f017 	ldw	r2,-23616(gp)
 323ada4:	1004c03a 	cmpne	r2,r2,zero
 323ada8:	1000021e 	bne	r2,zero,323adb4 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
 323adac:	e0bffe17 	ldw	r2,-8(fp)
 323adb0:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 323adb4:	e0bffe17 	ldw	r2,-8(fp)
 323adb8:	10c00217 	ldw	r3,8(r2)
 323adbc:	d0a8f017 	ldw	r2,-23616(gp)
 323adc0:	10c01e36 	bltu	r2,r3,323ae3c <alt_tick+0xe4>
 323adc4:	e0bffe17 	ldw	r2,-8(fp)
 323adc8:	10800403 	ldbu	r2,16(r2)
 323adcc:	10803fcc 	andi	r2,r2,255
 323add0:	1004c03a 	cmpne	r2,r2,zero
 323add4:	1000191e 	bne	r2,zero,323ae3c <alt_tick+0xe4>
    {
      next_callback = alarm->callback (alarm->context);
 323add8:	e0bffe17 	ldw	r2,-8(fp)
 323addc:	10c00317 	ldw	r3,12(r2)
 323ade0:	e0bffe17 	ldw	r2,-8(fp)
 323ade4:	11000517 	ldw	r4,20(r2)
 323ade8:	183ee83a 	callr	r3
 323adec:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 323adf0:	e0bffd17 	ldw	r2,-12(fp)
 323adf4:	1004c03a 	cmpne	r2,r2,zero
 323adf8:	1000031e 	bne	r2,zero,323ae08 <alt_tick+0xb0>
      {
        alt_alarm_stop (alarm);
 323adfc:	e13ffe17 	ldw	r4,-8(fp)
 323ae00:	323acc00 	call	323acc0 <alt_alarm_stop>
 323ae04:	00000d06 	br	323ae3c <alt_tick+0xe4>
      }
      else
      {
        alarm->time += next_callback;
 323ae08:	e0bffe17 	ldw	r2,-8(fp)
 323ae0c:	10c00217 	ldw	r3,8(r2)
 323ae10:	e0bffd17 	ldw	r2,-12(fp)
 323ae14:	1887883a 	add	r3,r3,r2
 323ae18:	e0bffe17 	ldw	r2,-8(fp)
 323ae1c:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 323ae20:	e0bffe17 	ldw	r2,-8(fp)
 323ae24:	10c00217 	ldw	r3,8(r2)
 323ae28:	d0a8f017 	ldw	r2,-23616(gp)
 323ae2c:	1880032e 	bgeu	r3,r2,323ae3c <alt_tick+0xe4>
        {
          alarm->rollover = 1;
 323ae30:	e0fffe17 	ldw	r3,-8(fp)
 323ae34:	00800044 	movi	r2,1
 323ae38:	18800405 	stb	r2,16(r3)
        }
      }
    }
    alarm = next;
 323ae3c:	e0bfff17 	ldw	r2,-4(fp)
 323ae40:	e0bffe15 	stw	r2,-8(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 323ae44:	d0e04504 	addi	r3,gp,-32492
 323ae48:	e0bffe17 	ldw	r2,-8(fp)
 323ae4c:	10ffcc1e 	bne	r2,r3,323ad80 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 323ae50:	3215fc80 	call	3215fc8 <OSTimeTick>
}
 323ae54:	e037883a 	mov	sp,fp
 323ae58:	dfc00117 	ldw	ra,4(sp)
 323ae5c:	df000017 	ldw	fp,0(sp)
 323ae60:	dec00204 	addi	sp,sp,8
 323ae64:	f800283a 	ret

0323ae68 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 323ae68:	defff904 	addi	sp,sp,-28
 323ae6c:	dfc00615 	stw	ra,24(sp)
 323ae70:	df000515 	stw	fp,20(sp)
 323ae74:	dc000415 	stw	r16,16(sp)
 323ae78:	df000404 	addi	fp,sp,16
 323ae7c:	e13ffe15 	stw	r4,-8(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
 323ae80:	0080c974 	movhi	r2,805
 323ae84:	10921b44 	addi	r2,r2,18541
 323ae88:	10800003 	ldbu	r2,0(r2)
 323ae8c:	10803fcc 	andi	r2,r2,255
 323ae90:	1004c03a 	cmpne	r2,r2,zero
 323ae94:	1000041e 	bne	r2,zero,323aea8 <usleep+0x40>
  {
    return alt_busy_sleep (us);
 323ae98:	e13ffe17 	ldw	r4,-8(fp)
 323ae9c:	324a2180 	call	324a218 <alt_busy_sleep>
 323aea0:	e0bfff15 	stw	r2,-4(fp)
 323aea4:	00002f06 	br	323af64 <usleep+0xfc>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 323aea8:	0080c974 	movhi	r2,805
 323aeac:	10926604 	addi	r2,r2,18840
 323aeb0:	10800017 	ldw	r2,0(r2)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
 323aeb4:	e0bffc15 	stw	r2,-16(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
 323aeb8:	e13ffe17 	ldw	r4,-8(fp)
 323aebc:	014003f4 	movhi	r5,15
 323aec0:	29509004 	addi	r5,r5,16960
 323aec4:	32044bc0 	call	32044bc <__udivsi3>
 323aec8:	1007883a 	mov	r3,r2
 323aecc:	e0bffc17 	ldw	r2,-16(fp)
 323aed0:	18a1383a 	mul	r16,r3,r2
 323aed4:	e13ffe17 	ldw	r4,-8(fp)
 323aed8:	014003f4 	movhi	r5,15
 323aedc:	29509004 	addi	r5,r5,16960
 323aee0:	32044c40 	call	32044c4 <__umodsi3>
 323aee4:	1007883a 	mov	r3,r2
 323aee8:	e0bffc17 	ldw	r2,-16(fp)
 323aeec:	1889383a 	mul	r4,r3,r2
 323aef0:	014003f4 	movhi	r5,15
 323aef4:	29509004 	addi	r5,r5,16960
 323aef8:	32044bc0 	call	32044bc <__udivsi3>
 323aefc:	8085883a 	add	r2,r16,r2
 323af00:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 323af04:	00000706 	br	323af24 <usleep+0xbc>
  {
    OSTimeDly(0xffff);
 323af08:	013fffd4 	movui	r4,65535
 323af0c:	321cf780 	call	321cf78 <OSTimeDly>
    ticks -= 0xffff;
 323af10:	e0bffd17 	ldw	r2,-12(fp)
 323af14:	00fffff4 	movhi	r3,65535
 323af18:	18c00044 	addi	r3,r3,1
 323af1c:	10c5883a 	add	r2,r2,r3
 323af20:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 323af24:	e0fffd17 	ldw	r3,-12(fp)
 323af28:	00bfffd4 	movui	r2,65535
 323af2c:	10fff636 	bltu	r2,r3,323af08 <usleep+0xa0>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
 323af30:	e0bffd17 	ldw	r2,-12(fp)
 323af34:	113fffcc 	andi	r4,r2,65535
 323af38:	321cf780 	call	321cf78 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
 323af3c:	010003f4 	movhi	r4,15
 323af40:	21109004 	addi	r4,r4,16960
 323af44:	e17ffc17 	ldw	r5,-16(fp)
 323af48:	32044bc0 	call	32044bc <__udivsi3>
 323af4c:	100b883a 	mov	r5,r2
 323af50:	e13ffe17 	ldw	r4,-8(fp)
 323af54:	32044c40 	call	32044c4 <__umodsi3>
 323af58:	1009883a 	mov	r4,r2
 323af5c:	324a2180 	call	324a218 <alt_busy_sleep>

  return 0;  
 323af60:	e03fff15 	stw	zero,-4(fp)
 323af64:	e0bfff17 	ldw	r2,-4(fp)
}
 323af68:	e037883a 	mov	sp,fp
 323af6c:	dfc00217 	ldw	ra,8(sp)
 323af70:	df000117 	ldw	fp,4(sp)
 323af74:	dc000017 	ldw	r16,0(sp)
 323af78:	dec00304 	addi	sp,sp,12
 323af7c:	f800283a 	ret

0323af80 <alt_write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 323af80:	defff704 	addi	sp,sp,-36
 323af84:	dfc00815 	stw	ra,32(sp)
 323af88:	df000715 	stw	fp,28(sp)
 323af8c:	df000704 	addi	fp,sp,28
 323af90:	e13ffb15 	stw	r4,-20(fp)
 323af94:	e17ffc15 	stw	r5,-16(fp)
 323af98:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 323af9c:	e0bffb17 	ldw	r2,-20(fp)
 323afa0:	1004803a 	cmplt	r2,r2,zero
 323afa4:	1000081e 	bne	r2,zero,323afc8 <alt_write+0x48>
 323afa8:	e0bffb17 	ldw	r2,-20(fp)
 323afac:	10800324 	muli	r2,r2,12
 323afb0:	1007883a 	mov	r3,r2
 323afb4:	0080c974 	movhi	r2,805
 323afb8:	10888304 	addi	r2,r2,8716
 323afbc:	1887883a 	add	r3,r3,r2
 323afc0:	e0ffff15 	stw	r3,-4(fp)
 323afc4:	00000106 	br	323afcc <alt_write+0x4c>
 323afc8:	e03fff15 	stw	zero,-4(fp)
 323afcc:	e0bfff17 	ldw	r2,-4(fp)
 323afd0:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 323afd4:	e0bffa17 	ldw	r2,-24(fp)
 323afd8:	1005003a 	cmpeq	r2,r2,zero
 323afdc:	1000241e 	bne	r2,zero,323b070 <alt_write+0xf0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 323afe0:	e0bffa17 	ldw	r2,-24(fp)
 323afe4:	10800217 	ldw	r2,8(r2)
 323afe8:	108000cc 	andi	r2,r2,3
 323afec:	1005003a 	cmpeq	r2,r2,zero
 323aff0:	10001a1e 	bne	r2,zero,323b05c <alt_write+0xdc>
 323aff4:	e0bffa17 	ldw	r2,-24(fp)
 323aff8:	10800017 	ldw	r2,0(r2)
 323affc:	10800617 	ldw	r2,24(r2)
 323b000:	1005003a 	cmpeq	r2,r2,zero
 323b004:	1000151e 	bne	r2,zero,323b05c <alt_write+0xdc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 323b008:	e0bffa17 	ldw	r2,-24(fp)
 323b00c:	10800017 	ldw	r2,0(r2)
 323b010:	10800617 	ldw	r2,24(r2)
 323b014:	e17ffc17 	ldw	r5,-16(fp)
 323b018:	e1bffd17 	ldw	r6,-12(fp)
 323b01c:	e13ffa17 	ldw	r4,-24(fp)
 323b020:	103ee83a 	callr	r2
 323b024:	e0bff915 	stw	r2,-28(fp)
 323b028:	e0bff917 	ldw	r2,-28(fp)
 323b02c:	1004403a 	cmpge	r2,r2,zero
 323b030:	1000071e 	bne	r2,zero,323b050 <alt_write+0xd0>
      {
        ALT_ERRNO = -rval;
 323b034:	323b0a00 	call	323b0a0 <alt_get_errno>
 323b038:	e0fff917 	ldw	r3,-28(fp)
 323b03c:	00c7c83a 	sub	r3,zero,r3
 323b040:	10c00015 	stw	r3,0(r2)
        return -1;
 323b044:	00bfffc4 	movi	r2,-1
 323b048:	e0bffe15 	stw	r2,-8(fp)
 323b04c:	00000e06 	br	323b088 <alt_write+0x108>
      }
      return rval;
 323b050:	e0bff917 	ldw	r2,-28(fp)
 323b054:	e0bffe15 	stw	r2,-8(fp)
 323b058:	00000b06 	br	323b088 <alt_write+0x108>
    }
    else
    {
      ALT_ERRNO = EACCES;
 323b05c:	323b0a00 	call	323b0a0 <alt_get_errno>
 323b060:	1007883a 	mov	r3,r2
 323b064:	00800344 	movi	r2,13
 323b068:	18800015 	stw	r2,0(r3)
 323b06c:	00000406 	br	323b080 <alt_write+0x100>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 323b070:	323b0a00 	call	323b0a0 <alt_get_errno>
 323b074:	1007883a 	mov	r3,r2
 323b078:	00801444 	movi	r2,81
 323b07c:	18800015 	stw	r2,0(r3)
  }
  return -1;
 323b080:	00bfffc4 	movi	r2,-1
 323b084:	e0bffe15 	stw	r2,-8(fp)
 323b088:	e0bffe17 	ldw	r2,-8(fp)
}
 323b08c:	e037883a 	mov	sp,fp
 323b090:	dfc00117 	ldw	ra,4(sp)
 323b094:	df000017 	ldw	fp,0(sp)
 323b098:	dec00204 	addi	sp,sp,8
 323b09c:	f800283a 	ret

0323b0a0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 323b0a0:	defffd04 	addi	sp,sp,-12
 323b0a4:	dfc00215 	stw	ra,8(sp)
 323b0a8:	df000115 	stw	fp,4(sp)
 323b0ac:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 323b0b0:	0080c974 	movhi	r2,805
 323b0b4:	1089ba04 	addi	r2,r2,9960
 323b0b8:	10800017 	ldw	r2,0(r2)
 323b0bc:	1005003a 	cmpeq	r2,r2,zero
 323b0c0:	1000061e 	bne	r2,zero,323b0dc <alt_get_errno+0x3c>
 323b0c4:	0080c974 	movhi	r2,805
 323b0c8:	1089ba04 	addi	r2,r2,9960
 323b0cc:	10800017 	ldw	r2,0(r2)
 323b0d0:	103ee83a 	callr	r2
 323b0d4:	e0bfff15 	stw	r2,-4(fp)
 323b0d8:	00000306 	br	323b0e8 <alt_get_errno+0x48>
 323b0dc:	0080c974 	movhi	r2,805
 323b0e0:	10920d04 	addi	r2,r2,18484
 323b0e4:	e0bfff15 	stw	r2,-4(fp)
 323b0e8:	e0bfff17 	ldw	r2,-4(fp)
}
 323b0ec:	e037883a 	mov	sp,fp
 323b0f0:	dfc00117 	ldw	ra,4(sp)
 323b0f4:	df000017 	ldw	fp,0(sp)
 323b0f8:	dec00204 	addi	sp,sp,8
 323b0fc:	f800283a 	ret

0323b100 <altera_nios2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_irq_init(void) 
{
 323b100:	deffff04 	addi	sp,sp,-4
 323b104:	df000015 	stw	fp,0(sp)
 323b108:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 323b10c:	000170fa 	wrctl	ienable,zero
}
 323b110:	e037883a 	mov	sp,fp
 323b114:	df000017 	ldw	fp,0(sp)
 323b118:	dec00104 	addi	sp,sp,4
 323b11c:	f800283a 	ret

0323b120 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
 323b120:	defff504 	addi	sp,sp,-44
      bltu  sp, et, .Lstack_overflow

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
 323b124:	d0e00117 	ldw	r3,-32764(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
 323b128:	d128b317 	ldw	r4,-23860(gp)

      stw ra,  0(sp)
 323b12c:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
 323b130:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
 323b134:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
 323b138:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
 323b13c:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
 323b140:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
 323b144:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
 323b148:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
 323b14c:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
 323b150:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
 323b154:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
 323b158:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 323b15c:	323b5400 	call	323b540 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
 323b160:	d128ae17 	ldw	r4,-23880(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
 323b164:	d168a607 	ldb	r5,-23912(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
 323b168:	d128b315 	stw	r4,-23860(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
 323b16c:	d168a645 	stb	r5,-23911(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
 323b170:	26c00017 	ldw	sp,0(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
 323b174:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
 323b178:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
 323b17c:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
 323b180:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
 323b184:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
 323b188:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
 323b18c:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
 323b190:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
 323b194:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
 323b198:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
 323b19c:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
 323b1a0:	d0e00115 	stw	r3,-32764(gp)

      stw et, %gprel(alt_stack_limit_value)(gp)

#endif

      addi sp, sp, 44
 323b1a4:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
 323b1a8:	f800283a 	ret

0323b1ac <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
 323b1ac:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
 323b1b0:	047fff84 	movi	r17,-2
      and   r18, r18, r17
 323b1b4:	9464703a 	and	r18,r18,r17
      wrctl status, r18
 323b1b8:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 323b1bc:	323b5400 	call	323b540 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
 323b1c0:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
 323b1c4:	d4a8a445 	stb	r18,-23919(gp)

      /*
       * start execution of the new task.
       */

      br 9b
 323b1c8:	003fe506 	br	323b160 <OSCtxSw+0x40>

0323b1cc <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
 323b1cc:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
 323b1d0:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
 323b1d4:	10800054 	ori	r2,r2,1
      wrctl status, r2
 323b1d8:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
 323b1dc:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
 323b1e0:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
 323b1e4:	dec00204 	addi	sp,sp,8

      callr r2
 323b1e8:	103ee83a 	callr	r2

      nop
 323b1ec:	0001883a 	nop

0323b1f0 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
 323b1f0:	defff704 	addi	sp,sp,-36
 323b1f4:	dfc00815 	stw	ra,32(sp)
 323b1f8:	df000715 	stw	fp,28(sp)
 323b1fc:	df000704 	addi	fp,sp,28
 323b200:	e13ffc15 	stw	r4,-16(fp)
 323b204:	e17ffd15 	stw	r5,-12(fp)
 323b208:	e1bffe15 	stw	r6,-8(fp)
 323b20c:	e1ffff0d 	sth	r7,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
 323b210:	e0bffe17 	ldw	r2,-8(fp)
 323b214:	1007883a 	mov	r3,r2
 323b218:	00bfff04 	movi	r2,-4
 323b21c:	1884703a 	and	r2,r3,r2
 323b220:	10bf0004 	addi	r2,r2,-1024
 323b224:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
 323b228:	e0bff917 	ldw	r2,-28(fp)
 323b22c:	10000015 	stw	zero,0(r2)
 323b230:	e0bff917 	ldw	r2,-28(fp)
 323b234:	10c0bb04 	addi	r3,r2,748
 323b238:	e0bff917 	ldw	r2,-28(fp)
 323b23c:	10c00115 	stw	r3,4(r2)
 323b240:	e0bff917 	ldw	r2,-28(fp)
 323b244:	1080bb04 	addi	r2,r2,748
 323b248:	10c01704 	addi	r3,r2,92
 323b24c:	e0bff917 	ldw	r2,-28(fp)
 323b250:	10c00215 	stw	r3,8(r2)
 323b254:	e0bff917 	ldw	r2,-28(fp)
 323b258:	1080bb04 	addi	r2,r2,748
 323b25c:	10c02e04 	addi	r3,r2,184
 323b260:	e0bff917 	ldw	r2,-28(fp)
 323b264:	10c00315 	stw	r3,12(r2)
 323b268:	e0bff917 	ldw	r2,-28(fp)
 323b26c:	10000415 	stw	zero,16(r2)
 323b270:	e0bff917 	ldw	r2,-28(fp)
 323b274:	10800504 	addi	r2,r2,20
 323b278:	1009883a 	mov	r4,r2
 323b27c:	01800644 	movi	r6,25
 323b280:	000b883a 	mov	r5,zero
 323b284:	320694c0 	call	320694c <memset>
 323b288:	e0bff917 	ldw	r2,-28(fp)
 323b28c:	10000c15 	stw	zero,48(r2)
 323b290:	e0fff917 	ldw	r3,-28(fp)
 323b294:	0080c974 	movhi	r2,805
 323b298:	10bd9904 	addi	r2,r2,-2460
 323b29c:	18800d15 	stw	r2,52(r3)
 323b2a0:	e0bff917 	ldw	r2,-28(fp)
 323b2a4:	10000e15 	stw	zero,56(r2)
 323b2a8:	e0bff917 	ldw	r2,-28(fp)
 323b2ac:	10000f15 	stw	zero,60(r2)
 323b2b0:	e0bff917 	ldw	r2,-28(fp)
 323b2b4:	10001015 	stw	zero,64(r2)
 323b2b8:	e0bff917 	ldw	r2,-28(fp)
 323b2bc:	10001115 	stw	zero,68(r2)
 323b2c0:	e0bff917 	ldw	r2,-28(fp)
 323b2c4:	10001215 	stw	zero,72(r2)
 323b2c8:	e0bff917 	ldw	r2,-28(fp)
 323b2cc:	10001315 	stw	zero,76(r2)
 323b2d0:	e0bff917 	ldw	r2,-28(fp)
 323b2d4:	10001415 	stw	zero,80(r2)
 323b2d8:	e0bff917 	ldw	r2,-28(fp)
 323b2dc:	10001515 	stw	zero,84(r2)
 323b2e0:	e0bff917 	ldw	r2,-28(fp)
 323b2e4:	10001615 	stw	zero,88(r2)
 323b2e8:	e0bff917 	ldw	r2,-28(fp)
 323b2ec:	10001715 	stw	zero,92(r2)
 323b2f0:	e0bff917 	ldw	r2,-28(fp)
 323b2f4:	10001805 	stb	zero,96(r2)
 323b2f8:	e0bff917 	ldw	r2,-28(fp)
 323b2fc:	10801f04 	addi	r2,r2,124
 323b300:	10000015 	stw	zero,0(r2)
 323b304:	10000115 	stw	zero,4(r2)
 323b308:	10000215 	stw	zero,8(r2)
 323b30c:	10000315 	stw	zero,12(r2)
 323b310:	10000415 	stw	zero,16(r2)
 323b314:	10000515 	stw	zero,20(r2)
 323b318:	10000615 	stw	zero,24(r2)
 323b31c:	10000715 	stw	zero,28(r2)
 323b320:	10000815 	stw	zero,32(r2)
 323b324:	e0bff917 	ldw	r2,-28(fp)
 323b328:	10002815 	stw	zero,160(r2)
 323b32c:	e0fff917 	ldw	r3,-28(fp)
 323b330:	00800044 	movi	r2,1
 323b334:	18802915 	stw	r2,164(r3)
 323b338:	18002a15 	stw	zero,168(r3)
 323b33c:	e0fff917 	ldw	r3,-28(fp)
 323b340:	008cc384 	movi	r2,13070
 323b344:	18802b0d 	sth	r2,172(r3)
 323b348:	e0fff917 	ldw	r3,-28(fp)
 323b34c:	00aaf344 	movi	r2,-21555
 323b350:	18802b8d 	sth	r2,174(r3)
 323b354:	e0fff917 	ldw	r3,-28(fp)
 323b358:	00848d04 	movi	r2,4660
 323b35c:	18802c0d 	sth	r2,176(r3)
 323b360:	e0fff917 	ldw	r3,-28(fp)
 323b364:	00b99b44 	movi	r2,-6547
 323b368:	18802c8d 	sth	r2,178(r3)
 323b36c:	e0fff917 	ldw	r3,-28(fp)
 323b370:	00b7bb04 	movi	r2,-8468
 323b374:	18802d0d 	sth	r2,180(r3)
 323b378:	e0fff917 	ldw	r3,-28(fp)
 323b37c:	00800144 	movi	r2,5
 323b380:	18802d8d 	sth	r2,182(r3)
 323b384:	e0fff917 	ldw	r3,-28(fp)
 323b388:	008002c4 	movi	r2,11
 323b38c:	18802e0d 	sth	r2,184(r3)
 323b390:	e0bff917 	ldw	r2,-28(fp)
 323b394:	10002f15 	stw	zero,188(r2)
 323b398:	e0bff917 	ldw	r2,-28(fp)
 323b39c:	10003015 	stw	zero,192(r2)
 323b3a0:	e0bff917 	ldw	r2,-28(fp)
 323b3a4:	10003115 	stw	zero,196(r2)
 323b3a8:	e0bff917 	ldw	r2,-28(fp)
 323b3ac:	10003215 	stw	zero,200(r2)
 323b3b0:	e0bff917 	ldw	r2,-28(fp)
 323b3b4:	10003315 	stw	zero,204(r2)
 323b3b8:	e0bff917 	ldw	r2,-28(fp)
 323b3bc:	10003415 	stw	zero,208(r2)
 323b3c0:	e0bff917 	ldw	r2,-28(fp)
 323b3c4:	10003e15 	stw	zero,248(r2)
 323b3c8:	e0bff917 	ldw	r2,-28(fp)
 323b3cc:	10003f15 	stw	zero,252(r2)
 323b3d0:	e0bff917 	ldw	r2,-28(fp)
 323b3d4:	10004015 	stw	zero,256(r2)
 323b3d8:	e0bff917 	ldw	r2,-28(fp)
 323b3dc:	10004115 	stw	zero,260(r2)
 323b3e0:	e0bff917 	ldw	r2,-28(fp)
 323b3e4:	10004215 	stw	zero,264(r2)
 323b3e8:	e0bff917 	ldw	r2,-28(fp)
 323b3ec:	10004315 	stw	zero,268(r2)
 323b3f0:	e0bff917 	ldw	r2,-28(fp)
 323b3f4:	10004415 	stw	zero,272(r2)
 323b3f8:	e0bff917 	ldw	r2,-28(fp)
 323b3fc:	10004515 	stw	zero,276(r2)
 323b400:	e0bff917 	ldw	r2,-28(fp)
 323b404:	10004615 	stw	zero,280(r2)
 323b408:	e0bff917 	ldw	r2,-28(fp)
 323b40c:	10004715 	stw	zero,284(r2)
 323b410:	e0bff917 	ldw	r2,-28(fp)
 323b414:	10003505 	stb	zero,212(r2)
 323b418:	e0bff917 	ldw	r2,-28(fp)
 323b41c:	10003705 	stb	zero,220(r2)
 323b420:	e0bff917 	ldw	r2,-28(fp)
 323b424:	10003d15 	stw	zero,244(r2)
 323b428:	e0bff917 	ldw	r2,-28(fp)
 323b42c:	10005215 	stw	zero,328(r2)
 323b430:	e0bff917 	ldw	r2,-28(fp)
 323b434:	10005315 	stw	zero,332(r2)
 323b438:	e0bff917 	ldw	r2,-28(fp)
 323b43c:	10005415 	stw	zero,336(r2)
 323b440:	e0bff917 	ldw	r2,-28(fp)
 323b444:	10005515 	stw	zero,340(r2)
 323b448:	e0bff917 	ldw	r2,-28(fp)
 323b44c:	1000b515 	stw	zero,724(r2)
 323b450:	e0bff917 	ldw	r2,-28(fp)
 323b454:	10007515 	stw	zero,468(r2)
 323b458:	e0bff917 	ldw	r2,-28(fp)
 323b45c:	1000b715 	stw	zero,732(r2)
 323b460:	e0bff917 	ldw	r2,-28(fp)
 323b464:	1000b815 	stw	zero,736(r2)
 323b468:	e0bff917 	ldw	r2,-28(fp)
 323b46c:	1000b915 	stw	zero,740(r2)
 323b470:	e0bff917 	ldw	r2,-28(fp)
 323b474:	1000ba15 	stw	zero,744(r2)
 323b478:	e0bff917 	ldw	r2,-28(fp)
 323b47c:	1080bb04 	addi	r2,r2,748
 323b480:	1009883a 	mov	r4,r2
 323b484:	01804504 	movi	r6,276
 323b488:	000b883a 	mov	r5,zero
 323b48c:	320694c0 	call	320694c <memset>
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
 323b490:	e0bff917 	ldw	r2,-28(fp)
 323b494:	e0bffb15 	stw	r2,-20(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
 323b498:	e0bffb17 	ldw	r2,-20(fp)
 323b49c:	10bff304 	addi	r2,r2,-52
 323b4a0:	e0bffa15 	stw	r2,-24(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
 323b4a4:	e0bffa17 	ldw	r2,-24(fp)
 323b4a8:	10c00c04 	addi	r3,r2,48
 323b4ac:	e0bffc17 	ldw	r2,-16(fp)
 323b4b0:	18800015 	stw	r2,0(r3)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
 323b4b4:	e0bffa17 	ldw	r2,-24(fp)
 323b4b8:	10c00b04 	addi	r3,r2,44
 323b4bc:	e0bffd17 	ldw	r2,-12(fp)
 323b4c0:	18800015 	stw	r2,0(r3)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
 323b4c4:	e0bffa17 	ldw	r2,-24(fp)
 323b4c8:	10c00a04 	addi	r3,r2,40
 323b4cc:	e0bff917 	ldw	r2,-28(fp)
 323b4d0:	18800015 	stw	r2,0(r3)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
 323b4d4:	0080c934 	movhi	r2,804
 323b4d8:	10ac7304 	addi	r2,r2,-20020
 323b4dc:	10c00104 	addi	r3,r2,4
 323b4e0:	e0bffa17 	ldw	r2,-24(fp)
 323b4e4:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
 323b4e8:	e0bffa17 	ldw	r2,-24(fp)
}
 323b4ec:	e037883a 	mov	sp,fp
 323b4f0:	dfc00117 	ldw	ra,4(sp)
 323b4f4:	df000017 	ldw	fp,0(sp)
 323b4f8:	dec00204 	addi	sp,sp,8
 323b4fc:	f800283a 	ret

0323b500 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
 323b500:	defffe04 	addi	sp,sp,-8
 323b504:	df000115 	stw	fp,4(sp)
 323b508:	df000104 	addi	fp,sp,4
 323b50c:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
 323b510:	e037883a 	mov	sp,fp
 323b514:	df000017 	ldw	fp,0(sp)
 323b518:	dec00104 	addi	sp,sp,4
 323b51c:	f800283a 	ret

0323b520 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
 323b520:	defffe04 	addi	sp,sp,-8
 323b524:	df000115 	stw	fp,4(sp)
 323b528:	df000104 	addi	fp,sp,4
 323b52c:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
 323b530:	e037883a 	mov	sp,fp
 323b534:	df000017 	ldw	fp,0(sp)
 323b538:	dec00104 	addi	sp,sp,4
 323b53c:	f800283a 	ret

0323b540 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
 323b540:	deffff04 	addi	sp,sp,-4
 323b544:	df000015 	stw	fp,0(sp)
 323b548:	d839883a 	mov	fp,sp
}
 323b54c:	e037883a 	mov	sp,fp
 323b550:	df000017 	ldw	fp,0(sp)
 323b554:	dec00104 	addi	sp,sp,4
 323b558:	f800283a 	ret

0323b55c <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
 323b55c:	deffff04 	addi	sp,sp,-4
 323b560:	df000015 	stw	fp,0(sp)
 323b564:	d839883a 	mov	fp,sp
}
 323b568:	e037883a 	mov	sp,fp
 323b56c:	df000017 	ldw	fp,0(sp)
 323b570:	dec00104 	addi	sp,sp,4
 323b574:	f800283a 	ret

0323b578 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
 323b578:	defffe04 	addi	sp,sp,-8
 323b57c:	dfc00115 	stw	ra,4(sp)
 323b580:	df000015 	stw	fp,0(sp)
 323b584:	d839883a 	mov	fp,sp
    }
#endif  
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
 323b588:	322ad200 	call	322ad20 <cticks_hook>
#endif
}
 323b58c:	e037883a 	mov	sp,fp
 323b590:	dfc00117 	ldw	ra,4(sp)
 323b594:	df000017 	ldw	fp,0(sp)
 323b598:	dec00204 	addi	sp,sp,8
 323b59c:	f800283a 	ret

0323b5a0 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
 323b5a0:	deffff04 	addi	sp,sp,-4
 323b5a4:	df000015 	stw	fp,0(sp)
 323b5a8:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
#endif
}
 323b5ac:	e037883a 	mov	sp,fp
 323b5b0:	df000017 	ldw	fp,0(sp)
 323b5b4:	dec00104 	addi	sp,sp,4
 323b5b8:	f800283a 	ret

0323b5bc <OSInitHookEnd>:

void OSInitHookEnd(void)
{
 323b5bc:	deffff04 	addi	sp,sp,-4
 323b5c0:	df000015 	stw	fp,0(sp)
 323b5c4:	d839883a 	mov	fp,sp
}
 323b5c8:	e037883a 	mov	sp,fp
 323b5cc:	df000017 	ldw	fp,0(sp)
 323b5d0:	dec00104 	addi	sp,sp,4
 323b5d4:	f800283a 	ret

0323b5d8 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
 323b5d8:	deffff04 	addi	sp,sp,-4
 323b5dc:	df000015 	stw	fp,0(sp)
 323b5e0:	d839883a 	mov	fp,sp
}
 323b5e4:	e037883a 	mov	sp,fp
 323b5e8:	df000017 	ldw	fp,0(sp)
 323b5ec:	dec00104 	addi	sp,sp,4
 323b5f0:	f800283a 	ret

0323b5f4 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
 323b5f4:	defffe04 	addi	sp,sp,-8
 323b5f8:	df000115 	stw	fp,4(sp)
 323b5fc:	df000104 	addi	fp,sp,4
 323b600:	e13fff15 	stw	r4,-4(fp)
}
 323b604:	e037883a 	mov	sp,fp
 323b608:	df000017 	ldw	fp,0(sp)
 323b60c:	dec00104 	addi	sp,sp,4
 323b610:	f800283a 	ret

0323b614 <alt_program_amd>:
 * then writes Addr, Data Addr, Data etc.
 */
int alt_program_amd(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 323b614:	defff704 	addi	sp,sp,-36
 323b618:	dfc00815 	stw	ra,32(sp)
 323b61c:	df000715 	stw	fp,28(sp)
 323b620:	df000704 	addi	fp,sp,28
 323b624:	e13ffc15 	stw	r4,-16(fp)
 323b628:	e17ffd15 	stw	r5,-12(fp)
 323b62c:	e1bffe15 	stw	r6,-8(fp)
 323b630:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 323b634:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 323b638:	e0bffc17 	ldw	r2,-16(fp)
 323b63c:	e0bffa15 	stw	r2,-24(fp)
  
  
  ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 323b640:	e1bfff17 	ldw	r6,-4(fp)
 323b644:	0080c934 	movhi	r2,804
 323b648:	10ae6e04 	addi	r2,r2,-17992
 323b64c:	d8800015 	stw	r2,0(sp)
 323b650:	e13ffa17 	ldw	r4,-24(fp)
 323b654:	e17ffe17 	ldw	r5,-8(fp)
 323b658:	e1c00217 	ldw	r7,8(fp)
 323b65c:	321dc3c0 	call	321dc3c <alt_flash_program_block>
 323b660:	e0bffb15 	stw	r2,-20(fp)
                                    alt_write_word_amd);
  return ret_code;
 323b664:	e0bffb17 	ldw	r2,-20(fp)
}
 323b668:	e037883a 	mov	sp,fp
 323b66c:	dfc00117 	ldw	ra,4(sp)
 323b670:	df000017 	ldw	fp,0(sp)
 323b674:	dec00204 	addi	sp,sp,8
 323b678:	f800283a 	ret

0323b67c <alt_erase_block_amd>:
 * alt_erase_block_amd
 * 
 * Erase the selected erase block
 */
int alt_erase_block_amd(alt_flash_dev* flash_info, int block_offset)
{
 323b67c:	defff804 	addi	sp,sp,-32
 323b680:	dfc00715 	stw	ra,28(sp)
 323b684:	df000615 	stw	fp,24(sp)
 323b688:	df000604 	addi	fp,sp,24
 323b68c:	e13ffe15 	stw	r4,-8(fp)
 323b690:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 323b694:	e03ffc15 	stw	zero,-16(fp)
  int   timeout;
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 323b698:	e0bffe17 	ldw	r2,-8(fp)
 323b69c:	e0bffa15 	stw	r2,-24(fp)
  volatile alt_u8  value;

  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 323b6a0:	e0bffa17 	ldw	r2,-24(fp)
 323b6a4:	10c03317 	ldw	r3,204(r2)
 323b6a8:	e0bffa17 	ldw	r2,-24(fp)
 323b6ac:	11000a17 	ldw	r4,40(r2)
 323b6b0:	01415544 	movi	r5,1365
 323b6b4:	01802a84 	movi	r6,170
 323b6b8:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 323b6bc:	e0bffa17 	ldw	r2,-24(fp)
 323b6c0:	10c03317 	ldw	r3,204(r2)
 323b6c4:	e0bffa17 	ldw	r2,-24(fp)
 323b6c8:	11000a17 	ldw	r4,40(r2)
 323b6cc:	0140aa84 	movi	r5,682
 323b6d0:	01801544 	movi	r6,85
 323b6d4:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0x80);
 323b6d8:	e0bffa17 	ldw	r2,-24(fp)
 323b6dc:	10c03317 	ldw	r3,204(r2)
 323b6e0:	e0bffa17 	ldw	r2,-24(fp)
 323b6e4:	11000a17 	ldw	r4,40(r2)
 323b6e8:	01415544 	movi	r5,1365
 323b6ec:	01802004 	movi	r6,128
 323b6f0:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 323b6f4:	e0bffa17 	ldw	r2,-24(fp)
 323b6f8:	10c03317 	ldw	r3,204(r2)
 323b6fc:	e0bffa17 	ldw	r2,-24(fp)
 323b700:	11000a17 	ldw	r4,40(r2)
 323b704:	01415544 	movi	r5,1365
 323b708:	01802a84 	movi	r6,170
 323b70c:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 323b710:	e0bffa17 	ldw	r2,-24(fp)
 323b714:	10c03317 	ldw	r3,204(r2)
 323b718:	e0bffa17 	ldw	r2,-24(fp)
 323b71c:	11000a17 	ldw	r4,40(r2)
 323b720:	0140aa84 	movi	r5,682
 323b724:	01801544 	movi	r6,85
 323b728:	183ee83a 	callr	r3

  (*flash->write_native)((alt_u8*)flash->dev.base_addr+block_offset, 0x30);
 323b72c:	e0bffa17 	ldw	r2,-24(fp)
 323b730:	11803517 	ldw	r6,212(r2)
 323b734:	e0bffa17 	ldw	r2,-24(fp)
 323b738:	10800a17 	ldw	r2,40(r2)
 323b73c:	1007883a 	mov	r3,r2
 323b740:	e0bfff17 	ldw	r2,-4(fp)
 323b744:	1889883a 	add	r4,r3,r2
 323b748:	01400c04 	movi	r5,48
 323b74c:	303ee83a 	callr	r6

  /*
   * Delay to meet AM29LV065D timing requirements
   */
  usleep(10000);
 323b750:	0109c404 	movi	r4,10000
 323b754:	323ae680 	call	323ae68 <usleep>
  
  /*
   * Bit 3 indicates that the erase command has been accepted
   * this last 50S
   */
  timeout = 50;   
 323b758:	00800c84 	movi	r2,50
 323b75c:	e0bffb15 	stw	r2,-20(fp)
  do 
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 323b760:	e0bffa17 	ldw	r2,-24(fp)
 323b764:	10800a17 	ldw	r2,40(r2)
 323b768:	1007883a 	mov	r3,r2
 323b76c:	e0bfff17 	ldw	r2,-4(fp)
 323b770:	1885883a 	add	r2,r3,r2
 323b774:	10800023 	ldbuio	r2,0(r2)
 323b778:	e0bffd05 	stb	r2,-12(fp)
    usleep(1000);
 323b77c:	0100fa04 	movi	r4,1000
 323b780:	323ae680 	call	323ae68 <usleep>
    timeout--;
 323b784:	e0bffb17 	ldw	r2,-20(fp)
 323b788:	10bfffc4 	addi	r2,r2,-1
 323b78c:	e0bffb15 	stw	r2,-20(fp)
  }while(!(value & 0x8) && (timeout > 0));
 323b790:	e0bffd03 	ldbu	r2,-12(fp)
 323b794:	10803fcc 	andi	r2,r2,255
 323b798:	1080020c 	andi	r2,r2,8
 323b79c:	1004c03a 	cmpne	r2,r2,zero
 323b7a0:	1000031e 	bne	r2,zero,323b7b0 <alt_erase_block_amd+0x134>
 323b7a4:	e0bffb17 	ldw	r2,-20(fp)
 323b7a8:	10800048 	cmpgei	r2,r2,1
 323b7ac:	103fec1e 	bne	r2,zero,323b760 <alt_erase_block_amd+0xe4>


  timeout = flash->erase_timeout;
 323b7b0:	e0bffa17 	ldw	r2,-24(fp)
 323b7b4:	10803117 	ldw	r2,196(r2)
 323b7b8:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 323b7bc:	00001706 	br	323b81c <alt_erase_block_amd+0x1a0>
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 323b7c0:	e0bffa17 	ldw	r2,-24(fp)
 323b7c4:	10800a17 	ldw	r2,40(r2)
 323b7c8:	1007883a 	mov	r3,r2
 323b7cc:	e0bfff17 	ldw	r2,-4(fp)
 323b7d0:	1885883a 	add	r2,r3,r2
 323b7d4:	10800023 	ldbuio	r2,0(r2)
 323b7d8:	e0bffd05 	stb	r2,-12(fp)
    if ((value & 0x80) || (value &0x20))
 323b7dc:	e0bffd03 	ldbu	r2,-12(fp)
 323b7e0:	10803fcc 	andi	r2,r2,255
 323b7e4:	1080201c 	xori	r2,r2,128
 323b7e8:	10bfe004 	addi	r2,r2,-128
 323b7ec:	1004803a 	cmplt	r2,r2,zero
 323b7f0:	10000d1e 	bne	r2,zero,323b828 <alt_erase_block_amd+0x1ac>
 323b7f4:	e0bffd03 	ldbu	r2,-12(fp)
 323b7f8:	10803fcc 	andi	r2,r2,255
 323b7fc:	1080080c 	andi	r2,r2,32
 323b800:	1004c03a 	cmpne	r2,r2,zero
 323b804:	1000081e 	bne	r2,zero,323b828 <alt_erase_block_amd+0x1ac>
    {
      break;
    }
    usleep(1000);
 323b808:	0100fa04 	movi	r4,1000
 323b80c:	323ae680 	call	323ae68 <usleep>
    timeout -= 1000;
 323b810:	e0bffb17 	ldw	r2,-20(fp)
 323b814:	10bf0604 	addi	r2,r2,-1000
 323b818:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 323b81c:	e0bffb17 	ldw	r2,-20(fp)
 323b820:	10800048 	cmpgei	r2,r2,1
 323b824:	103fe61e 	bne	r2,zero,323b7c0 <alt_erase_block_amd+0x144>
    }
    usleep(1000);
    timeout -= 1000;
  }
  
  if (timeout <= 0)
 323b828:	e0bffb17 	ldw	r2,-20(fp)
 323b82c:	10800048 	cmpgei	r2,r2,1
 323b830:	1000031e 	bne	r2,zero,323b840 <alt_erase_block_amd+0x1c4>
  {
    ret_code = -ETIMEDOUT;
 323b834:	00bfe304 	movi	r2,-116
 323b838:	e0bffc15 	stw	r2,-16(fp)
 323b83c:	00000f06 	br	323b87c <alt_erase_block_amd+0x200>
  }
  else
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 323b840:	e0bffa17 	ldw	r2,-24(fp)
 323b844:	10800a17 	ldw	r2,40(r2)
 323b848:	1007883a 	mov	r3,r2
 323b84c:	e0bfff17 	ldw	r2,-4(fp)
 323b850:	1885883a 	add	r2,r3,r2
 323b854:	10800023 	ldbuio	r2,0(r2)
 323b858:	e0bffd05 	stb	r2,-12(fp)
    if (!(value & 0x80))
 323b85c:	e0bffd03 	ldbu	r2,-12(fp)
 323b860:	10803fcc 	andi	r2,r2,255
 323b864:	1080201c 	xori	r2,r2,128
 323b868:	10bfe004 	addi	r2,r2,-128
 323b86c:	1004803a 	cmplt	r2,r2,zero
 323b870:	1000021e 	bne	r2,zero,323b87c <alt_erase_block_amd+0x200>
    {
      ret_code = -EIO;
 323b874:	00bffec4 	movi	r2,-5
 323b878:	e0bffc15 	stw	r2,-16(fp)
    }
  }    
  
  return ret_code;
 323b87c:	e0bffc17 	ldw	r2,-16(fp)
}
 323b880:	e037883a 	mov	sp,fp
 323b884:	dfc00117 	ldw	ra,4(sp)
 323b888:	df000017 	ldw	fp,0(sp)
 323b88c:	dec00204 	addi	sp,sp,8
 323b890:	f800283a 	ret

0323b894 <alt_wait_for_command_to_complete_amd>:
 */
 
int alt_wait_for_command_to_complete_amd(alt_flash_cfi_dev* flash,
                                         int offset, 
                                          alt_u8 data)
{
 323b894:	defff804 	addi	sp,sp,-32
 323b898:	dfc00715 	stw	ra,28(sp)
 323b89c:	df000615 	stw	fp,24(sp)
 323b8a0:	df000604 	addi	fp,sp,24
 323b8a4:	e13ffd15 	stw	r4,-12(fp)
 323b8a8:	e17ffe15 	stw	r5,-8(fp)
 323b8ac:	e1bfff05 	stb	r6,-4(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
 323b8b0:	e0bffd17 	ldw	r2,-12(fp)
 323b8b4:	10803017 	ldw	r2,192(r2)
 323b8b8:	10801924 	muli	r2,r2,100
 323b8bc:	e0bffb15 	stw	r2,-20(fp)
  int ret_code = 0;
 323b8c0:	e03ffa15 	stw	zero,-24(fp)
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
 323b8c4:	e0bffd17 	ldw	r2,-12(fp)
 323b8c8:	10800a17 	ldw	r2,40(r2)
 323b8cc:	1007883a 	mov	r3,r2
 323b8d0:	e0bffe17 	ldw	r2,-8(fp)
 323b8d4:	1885883a 	add	r2,r3,r2
 323b8d8:	10800023 	ldbuio	r2,0(r2)
 323b8dc:	e0bffc05 	stb	r2,-16(fp)
  while (timeout > 0)
 323b8e0:	00001706 	br	323b940 <alt_wait_for_command_to_complete_amd+0xac>
  {
    if (((value & 0x80 ) == (data &0x80)) ||
 323b8e4:	e0bffc03 	ldbu	r2,-16(fp)
 323b8e8:	10803fcc 	andi	r2,r2,255
 323b8ec:	10c0200c 	andi	r3,r2,128
 323b8f0:	e0bfff03 	ldbu	r2,-4(fp)
 323b8f4:	1080200c 	andi	r2,r2,128
 323b8f8:	18801426 	beq	r3,r2,323b94c <alt_wait_for_command_to_complete_amd+0xb8>
 323b8fc:	e0bffc03 	ldbu	r2,-16(fp)
 323b900:	10803fcc 	andi	r2,r2,255
 323b904:	1080080c 	andi	r2,r2,32
 323b908:	1004c03a 	cmpne	r2,r2,zero
 323b90c:	10000f1e 	bne	r2,zero,323b94c <alt_wait_for_command_to_complete_amd+0xb8>
        (value & 0x20))
    {
      break;
    }
    usleep (1);
 323b910:	01000044 	movi	r4,1
 323b914:	323ae680 	call	323ae68 <usleep>
    timeout--;
 323b918:	e0bffb17 	ldw	r2,-20(fp)
 323b91c:	10bfffc4 	addi	r2,r2,-1
 323b920:	e0bffb15 	stw	r2,-20(fp)
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 323b924:	e0bffd17 	ldw	r2,-12(fp)
 323b928:	10800a17 	ldw	r2,40(r2)
 323b92c:	1007883a 	mov	r3,r2
 323b930:	e0bffe17 	ldw	r2,-8(fp)
 323b934:	1885883a 	add	r2,r3,r2
 323b938:	10800023 	ldbuio	r2,0(r2)
 323b93c:	e0bffc05 	stb	r2,-16(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
  int ret_code = 0;
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
  while (timeout > 0)
 323b940:	e0bffb17 	ldw	r2,-20(fp)
 323b944:	10800048 	cmpgei	r2,r2,1
 323b948:	103fe61e 	bne	r2,zero,323b8e4 <alt_wait_for_command_to_complete_amd+0x50>
    usleep (1);
    timeout--;
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
  }
  
  if (timeout == 0)
 323b94c:	e0bffb17 	ldw	r2,-20(fp)
 323b950:	1004c03a 	cmpne	r2,r2,zero
 323b954:	1000031e 	bne	r2,zero,323b964 <alt_wait_for_command_to_complete_amd+0xd0>
  {
    ret_code = -ETIMEDOUT;
 323b958:	00bfe304 	movi	r2,-116
 323b95c:	e0bffa15 	stw	r2,-24(fp)
 323b960:	00000f06 	br	323b9a0 <alt_wait_for_command_to_complete_amd+0x10c>
  }
  else
  {
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 323b964:	e0bffd17 	ldw	r2,-12(fp)
 323b968:	10800a17 	ldw	r2,40(r2)
 323b96c:	1007883a 	mov	r3,r2
 323b970:	e0bffe17 	ldw	r2,-8(fp)
 323b974:	1885883a 	add	r2,r3,r2
 323b978:	10800023 	ldbuio	r2,0(r2)
 323b97c:	e0bffc05 	stb	r2,-16(fp)
    if ((value & 0x80) != (data&0x80))
 323b980:	e0bffc03 	ldbu	r2,-16(fp)
 323b984:	10803fcc 	andi	r2,r2,255
 323b988:	10c0200c 	andi	r3,r2,128
 323b98c:	e0bfff03 	ldbu	r2,-4(fp)
 323b990:	1080200c 	andi	r2,r2,128
 323b994:	18800226 	beq	r3,r2,323b9a0 <alt_wait_for_command_to_complete_amd+0x10c>
    {
      ret_code = -EIO;
 323b998:	00bffec4 	movi	r2,-5
 323b99c:	e0bffa15 	stw	r2,-24(fp)
    }
  }    
  return ret_code;
 323b9a0:	e0bffa17 	ldw	r2,-24(fp)
}
 323b9a4:	e037883a 	mov	sp,fp
 323b9a8:	dfc00117 	ldw	ra,4(sp)
 323b9ac:	df000017 	ldw	fp,0(sp)
 323b9b0:	dec00204 	addi	sp,sp,8
 323b9b4:	f800283a 	ret

0323b9b8 <alt_write_word_amd>:

static int alt_write_word_amd(  alt_flash_cfi_dev* flash, 
                                const int offset, 
                                const alt_u8* src_addr)
{
 323b9b8:	defff904 	addi	sp,sp,-28
 323b9bc:	dfc00615 	stw	ra,24(sp)
 323b9c0:	df000515 	stw	fp,20(sp)
 323b9c4:	df000504 	addi	fp,sp,20
 323b9c8:	e13ffd15 	stw	r4,-12(fp)
 323b9cc:	e17ffe15 	stw	r5,-8(fp)
 323b9d0:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 323b9d4:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 value;
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 323b9d8:	e0bffd17 	ldw	r2,-12(fp)
 323b9dc:	10c03317 	ldw	r3,204(r2)
 323b9e0:	e0bffd17 	ldw	r2,-12(fp)
 323b9e4:	11000a17 	ldw	r4,40(r2)
 323b9e8:	01415544 	movi	r5,1365
 323b9ec:	01802a84 	movi	r6,170
 323b9f0:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 323b9f4:	e0bffd17 	ldw	r2,-12(fp)
 323b9f8:	10c03317 	ldw	r3,204(r2)
 323b9fc:	e0bffd17 	ldw	r2,-12(fp)
 323ba00:	11000a17 	ldw	r4,40(r2)
 323ba04:	0140aa84 	movi	r5,682
 323ba08:	01801544 	movi	r6,85
 323ba0c:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xA0);
 323ba10:	e0bffd17 	ldw	r2,-12(fp)
 323ba14:	10c03317 	ldw	r3,204(r2)
 323ba18:	e0bffd17 	ldw	r2,-12(fp)
 323ba1c:	11000a17 	ldw	r4,40(r2)
 323ba20:	01415544 	movi	r5,1365
 323ba24:	01802804 	movi	r6,160
 323ba28:	183ee83a 	callr	r3
  
  value = *src_addr;
 323ba2c:	e0bfff17 	ldw	r2,-4(fp)
 323ba30:	10800003 	ldbu	r2,0(r2)
 323ba34:	e0bffb05 	stb	r2,-20(fp)

  alt_write_value_to_flash(flash, offset, src_addr);
 323ba38:	e13ffd17 	ldw	r4,-12(fp)
 323ba3c:	e17ffe17 	ldw	r5,-8(fp)
 323ba40:	e1bfff17 	ldw	r6,-4(fp)
 323ba44:	321dad80 	call	321dad8 <alt_write_value_to_flash>
  
  ret_code = alt_wait_for_command_to_complete_amd(flash, 
 323ba48:	e1bffb03 	ldbu	r6,-20(fp)
 323ba4c:	e13ffd17 	ldw	r4,-12(fp)
 323ba50:	e17ffe17 	ldw	r5,-8(fp)
 323ba54:	323b8940 	call	323b894 <alt_wait_for_command_to_complete_amd>
 323ba58:	e0bffc15 	stw	r2,-16(fp)
                                                  offset,
                                                  value);
  return ret_code;
 323ba5c:	e0bffc17 	ldw	r2,-16(fp)
  
}
 323ba60:	e037883a 	mov	sp,fp
 323ba64:	dfc00117 	ldw	ra,4(sp)
 323ba68:	df000017 	ldw	fp,0(sp)
 323ba6c:	dec00204 	addi	sp,sp,8
 323ba70:	f800283a 	ret

0323ba74 <alt_program_intel>:
 * Program a block (or part of one)
 */
int alt_program_intel(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 323ba74:	defff704 	addi	sp,sp,-36
 323ba78:	dfc00815 	stw	ra,32(sp)
 323ba7c:	df000715 	stw	fp,28(sp)
 323ba80:	df000704 	addi	fp,sp,28
 323ba84:	e13ffc15 	stw	r4,-16(fp)
 323ba88:	e17ffd15 	stw	r5,-12(fp)
 323ba8c:	e1bffe15 	stw	r6,-8(fp)
 323ba90:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 323ba94:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 323ba98:	e0bffc17 	ldw	r2,-16(fp)
 323ba9c:	e0bffa15 	stw	r2,-24(fp)
  
   /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 323baa0:	e13ffa17 	ldw	r4,-24(fp)
 323baa4:	e17ffd17 	ldw	r5,-12(fp)
 323baa8:	323bc6c0 	call	323bc6c <alt_unlock_block_intel>
 323baac:	e0bffb15 	stw	r2,-20(fp)

  if (!ret_code)
 323bab0:	e0bffb17 	ldw	r2,-20(fp)
 323bab4:	1004c03a 	cmpne	r2,r2,zero
 323bab8:	1000091e 	bne	r2,zero,323bae0 <alt_program_intel+0x6c>
  {

    ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 323babc:	e1bfff17 	ldw	r6,-4(fp)
 323bac0:	0080c934 	movhi	r2,804
 323bac4:	10af7e04 	addi	r2,r2,-16904
 323bac8:	d8800015 	stw	r2,0(sp)
 323bacc:	e13ffa17 	ldw	r4,-24(fp)
 323bad0:	e17ffe17 	ldw	r5,-8(fp)
 323bad4:	e1c00217 	ldw	r7,8(fp)
 323bad8:	321dc3c0 	call	321dc3c <alt_flash_program_block>
 323badc:	e0bffb15 	stw	r2,-20(fp)
                                        alt_write_word_intel);
  }
  
  return ret_code;
 323bae0:	e0bffb17 	ldw	r2,-20(fp)
}
 323bae4:	e037883a 	mov	sp,fp
 323bae8:	dfc00117 	ldw	ra,4(sp)
 323baec:	df000017 	ldw	fp,0(sp)
 323baf0:	dec00204 	addi	sp,sp,8
 323baf4:	f800283a 	ret

0323baf8 <alt_erase_block_intel>:
 * alt_erase_block_intel
 * 
 * Erase the selected erase block
 */
int alt_erase_block_intel(alt_flash_dev* flash_info, int block_offset)
{
 323baf8:	defff804 	addi	sp,sp,-32
 323bafc:	dfc00715 	stw	ra,28(sp)
 323bb00:	df000615 	stw	fp,24(sp)
 323bb04:	df000604 	addi	fp,sp,24
 323bb08:	e13ffe15 	stw	r4,-8(fp)
 323bb0c:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 323bb10:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 323bb14:	e0bffe17 	ldw	r2,-8(fp)
 323bb18:	e0bffb15 	stw	r2,-20(fp)
  volatile alt_u8  status;
  int   timeout = flash->erase_timeout;
 323bb1c:	e0bffb17 	ldw	r2,-20(fp)
 323bb20:	10803117 	ldw	r2,196(r2)
 323bb24:	e0bffa15 	stw	r2,-24(fp)

  /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 323bb28:	e13ffb17 	ldw	r4,-20(fp)
 323bb2c:	e17fff17 	ldw	r5,-4(fp)
 323bb30:	323bc6c0 	call	323bc6c <alt_unlock_block_intel>
 323bb34:	e0bffc15 	stw	r2,-16(fp)

  if (!ret_code)
 323bb38:	e0bffc17 	ldw	r2,-16(fp)
 323bb3c:	1004c03a 	cmpne	r2,r2,zero
 323bb40:	1000441e 	bne	r2,zero,323bc54 <alt_erase_block_intel+0x15c>
  {

    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x20);
 323bb44:	e0bffb17 	ldw	r2,-20(fp)
 323bb48:	11803517 	ldw	r6,212(r2)
 323bb4c:	e0bffb17 	ldw	r2,-20(fp)
 323bb50:	10800a17 	ldw	r2,40(r2)
 323bb54:	1007883a 	mov	r3,r2
 323bb58:	e0bfff17 	ldw	r2,-4(fp)
 323bb5c:	1889883a 	add	r4,r3,r2
 323bb60:	01400804 	movi	r5,32
 323bb64:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 323bb68:	e0bffb17 	ldw	r2,-20(fp)
 323bb6c:	11803517 	ldw	r6,212(r2)
 323bb70:	e0bffb17 	ldw	r2,-20(fp)
 323bb74:	10800a17 	ldw	r2,40(r2)
 323bb78:	1007883a 	mov	r3,r2
 323bb7c:	e0bfff17 	ldw	r2,-4(fp)
 323bb80:	1889883a 	add	r4,r3,r2
 323bb84:	01403404 	movi	r5,208
 323bb88:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 323bb8c:	e0bffb17 	ldw	r2,-20(fp)
 323bb90:	10800a17 	ldw	r2,40(r2)
 323bb94:	1007883a 	mov	r3,r2
 323bb98:	e0bfff17 	ldw	r2,-4(fp)
 323bb9c:	1885883a 	add	r2,r3,r2
 323bba0:	10800023 	ldbuio	r2,0(r2)
 323bba4:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 323bba8:	e0bffd03 	ldbu	r2,-12(fp)
 323bbac:	10803fcc 	andi	r2,r2,255
 323bbb0:	1080201c 	xori	r2,r2,128
 323bbb4:	10bfe004 	addi	r2,r2,-128
 323bbb8:	1004803a 	cmplt	r2,r2,zero
 323bbbc:	1000081e 	bne	r2,zero,323bbe0 <alt_erase_block_intel+0xe8>
      {
        break;
      }
      usleep(1000);
 323bbc0:	0100fa04 	movi	r4,1000
 323bbc4:	323ae680 	call	323ae68 <usleep>
      timeout -= 1000;
 323bbc8:	e0bffa17 	ldw	r2,-24(fp)
 323bbcc:	10bf0604 	addi	r2,r2,-1000
 323bbd0:	e0bffa15 	stw	r2,-24(fp)
    }while(timeout > 0);
 323bbd4:	e0bffa17 	ldw	r2,-24(fp)
 323bbd8:	10800048 	cmpgei	r2,r2,1
 323bbdc:	103feb1e 	bne	r2,zero,323bb8c <alt_erase_block_intel+0x94>
    
    if (timeout <= 0)
 323bbe0:	e0bffa17 	ldw	r2,-24(fp)
 323bbe4:	10800048 	cmpgei	r2,r2,1
 323bbe8:	1000031e 	bne	r2,zero,323bbf8 <alt_erase_block_intel+0x100>
    {
      ret_code = -ETIMEDOUT;
 323bbec:	00bfe304 	movi	r2,-116
 323bbf0:	e0bffc15 	stw	r2,-16(fp)
 323bbf4:	00000e06 	br	323bc30 <alt_erase_block_intel+0x138>
    }
    else if (status & 0x7f)
 323bbf8:	e0bffd03 	ldbu	r2,-12(fp)
 323bbfc:	10803fcc 	andi	r2,r2,255
 323bc00:	10801fcc 	andi	r2,r2,127
 323bc04:	1005003a 	cmpeq	r2,r2,zero
 323bc08:	1000091e 	bne	r2,zero,323bc30 <alt_erase_block_intel+0x138>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 323bc0c:	00bffec4 	movi	r2,-5
 323bc10:	e0bffc15 	stw	r2,-16(fp)
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 323bc14:	e0bffb17 	ldw	r2,-20(fp)
 323bc18:	10800a17 	ldw	r2,40(r2)
 323bc1c:	1007883a 	mov	r3,r2
 323bc20:	e0bfff17 	ldw	r2,-4(fp)
 323bc24:	1885883a 	add	r2,r3,r2
 323bc28:	10800023 	ldbuio	r2,0(r2)
 323bc2c:	e0bffd05 	stb	r2,-12(fp)
    }

    /* Put the device back into read array mode */
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 323bc30:	e0bffb17 	ldw	r2,-20(fp)
 323bc34:	11803517 	ldw	r6,212(r2)
 323bc38:	e0bffb17 	ldw	r2,-20(fp)
 323bc3c:	10800a17 	ldw	r2,40(r2)
 323bc40:	1007883a 	mov	r3,r2
 323bc44:	e0bfff17 	ldw	r2,-4(fp)
 323bc48:	1889883a 	add	r4,r3,r2
 323bc4c:	01403fc4 	movi	r5,255
 323bc50:	303ee83a 	callr	r6
  }
  
  return ret_code;
 323bc54:	e0bffc17 	ldw	r2,-16(fp)
}
 323bc58:	e037883a 	mov	sp,fp
 323bc5c:	dfc00117 	ldw	ra,4(sp)
 323bc60:	df000017 	ldw	fp,0(sp)
 323bc64:	dec00204 	addi	sp,sp,8
 323bc68:	f800283a 	ret

0323bc6c <alt_unlock_block_intel>:
/*
* Private Intel specific functions
*/

static int alt_unlock_block_intel(alt_flash_cfi_dev* flash, int block_offset)
{
 323bc6c:	defff904 	addi	sp,sp,-28
 323bc70:	dfc00615 	stw	ra,24(sp)
 323bc74:	df000515 	stw	fp,20(sp)
 323bc78:	df000504 	addi	fp,sp,20
 323bc7c:	e13ffe15 	stw	r4,-8(fp)
 323bc80:	e17fff15 	stw	r5,-4(fp)
  alt_u8  locked;
  alt_u8  status;
  int ret_code = 0;
 323bc84:	e03ffc15 	stw	zero,-16(fp)
  int timeout = flash->write_timeout * 100;
 323bc88:	e0bffe17 	ldw	r2,-8(fp)
 323bc8c:	10803017 	ldw	r2,192(r2)
 323bc90:	10801924 	muli	r2,r2,100
 323bc94:	e0bffb15 	stw	r2,-20(fp)


  /*
  * Is this block locked?
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x90);
 323bc98:	e0bffe17 	ldw	r2,-8(fp)
 323bc9c:	11803517 	ldw	r6,212(r2)
 323bca0:	e0bffe17 	ldw	r2,-8(fp)
 323bca4:	10800a17 	ldw	r2,40(r2)
 323bca8:	1007883a 	mov	r3,r2
 323bcac:	e0bfff17 	ldw	r2,-4(fp)
 323bcb0:	1889883a 	add	r4,r3,r2
 323bcb4:	01402404 	movi	r5,144
 323bcb8:	303ee83a 	callr	r6
  locked = IORD_8DIRECT(flash->dev.base_addr, block_offset + 4);
 323bcbc:	e0bffe17 	ldw	r2,-8(fp)
 323bcc0:	10800a17 	ldw	r2,40(r2)
 323bcc4:	1007883a 	mov	r3,r2
 323bcc8:	e0bfff17 	ldw	r2,-4(fp)
 323bccc:	1885883a 	add	r2,r3,r2
 323bcd0:	10800104 	addi	r2,r2,4
 323bcd4:	10800023 	ldbuio	r2,0(r2)
 323bcd8:	e0bffd45 	stb	r2,-11(fp)
  if (locked & 0x1)
 323bcdc:	e0bffd43 	ldbu	r2,-11(fp)
 323bce0:	1080004c 	andi	r2,r2,1
 323bce4:	10803fcc 	andi	r2,r2,255
 323bce8:	1005003a 	cmpeq	r2,r2,zero
 323bcec:	1000331e 	bne	r2,zero,323bdbc <alt_unlock_block_intel+0x150>
  {
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x60);
 323bcf0:	e0bffe17 	ldw	r2,-8(fp)
 323bcf4:	11803517 	ldw	r6,212(r2)
 323bcf8:	e0bffe17 	ldw	r2,-8(fp)
 323bcfc:	10800a17 	ldw	r2,40(r2)
 323bd00:	1007883a 	mov	r3,r2
 323bd04:	e0bfff17 	ldw	r2,-4(fp)
 323bd08:	1889883a 	add	r4,r3,r2
 323bd0c:	01401804 	movi	r5,96
 323bd10:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 323bd14:	e0bffe17 	ldw	r2,-8(fp)
 323bd18:	11803517 	ldw	r6,212(r2)
 323bd1c:	e0bffe17 	ldw	r2,-8(fp)
 323bd20:	10800a17 	ldw	r2,40(r2)
 323bd24:	1007883a 	mov	r3,r2
 323bd28:	e0bfff17 	ldw	r2,-4(fp)
 323bd2c:	1889883a 	add	r4,r3,r2
 323bd30:	01403404 	movi	r5,208
 323bd34:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 323bd38:	e0bffe17 	ldw	r2,-8(fp)
 323bd3c:	10800a17 	ldw	r2,40(r2)
 323bd40:	1007883a 	mov	r3,r2
 323bd44:	e0bfff17 	ldw	r2,-4(fp)
 323bd48:	1885883a 	add	r2,r3,r2
 323bd4c:	10800023 	ldbuio	r2,0(r2)
 323bd50:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 323bd54:	e0bffd03 	ldbu	r2,-12(fp)
 323bd58:	10803fcc 	andi	r2,r2,255
 323bd5c:	1080201c 	xori	r2,r2,128
 323bd60:	10bfe004 	addi	r2,r2,-128
 323bd64:	1004803a 	cmplt	r2,r2,zero
 323bd68:	1000081e 	bne	r2,zero,323bd8c <alt_unlock_block_intel+0x120>
      {
        break;
      }
      timeout--;
 323bd6c:	e0bffb17 	ldw	r2,-20(fp)
 323bd70:	10bfffc4 	addi	r2,r2,-1
 323bd74:	e0bffb15 	stw	r2,-20(fp)
      usleep(1);
 323bd78:	01000044 	movi	r4,1
 323bd7c:	323ae680 	call	323ae68 <usleep>
    }while(timeout > 0);
 323bd80:	e0bffb17 	ldw	r2,-20(fp)
 323bd84:	10800048 	cmpgei	r2,r2,1
 323bd88:	103feb1e 	bne	r2,zero,323bd38 <alt_unlock_block_intel+0xcc>

    if (timeout == 0)
 323bd8c:	e0bffb17 	ldw	r2,-20(fp)
 323bd90:	1004c03a 	cmpne	r2,r2,zero
 323bd94:	1000031e 	bne	r2,zero,323bda4 <alt_unlock_block_intel+0x138>
    {
      ret_code = -ETIMEDOUT;
 323bd98:	00bfe304 	movi	r2,-116
 323bd9c:	e0bffc15 	stw	r2,-16(fp)
 323bda0:	00000606 	br	323bdbc <alt_unlock_block_intel+0x150>
    }
    else if (status & 0x7f)
 323bda4:	e0bffd03 	ldbu	r2,-12(fp)
 323bda8:	10801fcc 	andi	r2,r2,127
 323bdac:	1005003a 	cmpeq	r2,r2,zero
 323bdb0:	1000021e 	bne	r2,zero,323bdbc <alt_unlock_block_intel+0x150>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 323bdb4:	00bffec4 	movi	r2,-5
 323bdb8:	e0bffc15 	stw	r2,-16(fp)
  }

  /*
  * Back to Read Array mode
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 323bdbc:	e0bffe17 	ldw	r2,-8(fp)
 323bdc0:	11803517 	ldw	r6,212(r2)
 323bdc4:	e0bffe17 	ldw	r2,-8(fp)
 323bdc8:	10800a17 	ldw	r2,40(r2)
 323bdcc:	1007883a 	mov	r3,r2
 323bdd0:	e0bfff17 	ldw	r2,-4(fp)
 323bdd4:	1889883a 	add	r4,r3,r2
 323bdd8:	01403fc4 	movi	r5,255
 323bddc:	303ee83a 	callr	r6

  return ret_code;
 323bde0:	e0bffc17 	ldw	r2,-16(fp)
}
 323bde4:	e037883a 	mov	sp,fp
 323bde8:	dfc00117 	ldw	ra,4(sp)
 323bdec:	df000017 	ldw	fp,0(sp)
 323bdf0:	dec00204 	addi	sp,sp,8
 323bdf4:	f800283a 	ret

0323bdf8 <alt_write_word_intel>:
 * offset bytes into the flash
 */
 
int alt_write_word_intel( alt_flash_cfi_dev* flash, 
                                  const int offset, const alt_u8* src_addr)
{ 
 323bdf8:	defff904 	addi	sp,sp,-28
 323bdfc:	dfc00615 	stw	ra,24(sp)
 323be00:	df000515 	stw	fp,20(sp)
 323be04:	df000504 	addi	fp,sp,20
 323be08:	e13ffd15 	stw	r4,-12(fp)
 323be0c:	e17ffe15 	stw	r5,-8(fp)
 323be10:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 323be14:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 status;
  (*flash->write_native)((alt_u8*)flash->dev.base_addr+offset, 0x40);
 323be18:	e0bffd17 	ldw	r2,-12(fp)
 323be1c:	11803517 	ldw	r6,212(r2)
 323be20:	e0bffd17 	ldw	r2,-12(fp)
 323be24:	10800a17 	ldw	r2,40(r2)
 323be28:	1007883a 	mov	r3,r2
 323be2c:	e0bffe17 	ldw	r2,-8(fp)
 323be30:	1889883a 	add	r4,r3,r2
 323be34:	01401004 	movi	r5,64
 323be38:	303ee83a 	callr	r6
  alt_write_value_to_flash(flash, offset, src_addr);
 323be3c:	e13ffd17 	ldw	r4,-12(fp)
 323be40:	e17ffe17 	ldw	r5,-8(fp)
 323be44:	e1bfff17 	ldw	r6,-4(fp)
 323be48:	321dad80 	call	321dad8 <alt_write_value_to_flash>

  do
  {
    status = IORD_8DIRECT(flash->dev.base_addr, offset);
 323be4c:	e0bffd17 	ldw	r2,-12(fp)
 323be50:	10800a17 	ldw	r2,40(r2)
 323be54:	1007883a 	mov	r3,r2
 323be58:	e0bffe17 	ldw	r2,-8(fp)
 323be5c:	1885883a 	add	r2,r3,r2
 323be60:	10800023 	ldbuio	r2,0(r2)
 323be64:	e0bffb05 	stb	r2,-20(fp)
  }while(!(status & 0x80));
 323be68:	e0bffb03 	ldbu	r2,-20(fp)
 323be6c:	10803fcc 	andi	r2,r2,255
 323be70:	1080201c 	xori	r2,r2,128
 323be74:	10bfe004 	addi	r2,r2,-128
 323be78:	1004403a 	cmpge	r2,r2,zero
 323be7c:	103ff31e 	bne	r2,zero,323be4c <alt_write_word_intel+0x54>

  /* If we have an error of some kind bomb out */
  if (status & 0x7f)
 323be80:	e0bffb03 	ldbu	r2,-20(fp)
 323be84:	10801fcc 	andi	r2,r2,127
 323be88:	1005003a 	cmpeq	r2,r2,zero
 323be8c:	1000021e 	bne	r2,zero,323be98 <alt_write_word_intel+0xa0>
  {
    ret_code = -EIO;
 323be90:	00bffec4 	movi	r2,-5
 323be94:	e0bffc15 	stw	r2,-16(fp)
  }

  /* Put the device back into read array mode */
  flash->write_native((alt_u8*)flash->dev.base_addr + offset, 0xFF);
 323be98:	e0bffd17 	ldw	r2,-12(fp)
 323be9c:	11803517 	ldw	r6,212(r2)
 323bea0:	e0bffd17 	ldw	r2,-12(fp)
 323bea4:	10800a17 	ldw	r2,40(r2)
 323bea8:	1007883a 	mov	r3,r2
 323beac:	e0bffe17 	ldw	r2,-8(fp)
 323beb0:	1889883a 	add	r4,r3,r2
 323beb4:	01403fc4 	movi	r5,255
 323beb8:	303ee83a 	callr	r6
  
  return ret_code;
 323bebc:	e0bffc17 	ldw	r2,-16(fp)
}
 323bec0:	e037883a 	mov	sp,fp
 323bec4:	dfc00117 	ldw	ra,4(sp)
 323bec8:	df000017 	ldw	fp,0(sp)
 323becc:	dec00204 	addi	sp,sp,8
 323bed0:	f800283a 	ret

0323bed4 <eth_ocm_set_phy_addr>:

static eth_ocm_phy_profile* eth_ocm_phy_profile_array[ETH_OCM_PHY_MAX_PROFILES] = {0}; 

static int eth_ocm_wait(int base);

void eth_ocm_set_phy_addr(int base, int phyad, int reg){
 323bed4:	defffc04 	addi	sp,sp,-16
 323bed8:	df000315 	stw	fp,12(sp)
 323bedc:	df000304 	addi	fp,sp,12
 323bee0:	e13ffd15 	stw	r4,-12(fp)
 323bee4:	e17ffe15 	stw	r5,-8(fp)
 323bee8:	e1bfff15 	stw	r6,-4(fp)
    phyad &= ETH_OCM_MIIADDRESS_FIAD_MSK; 
 323beec:	e0bffe17 	ldw	r2,-8(fp)
 323bef0:	108007cc 	andi	r2,r2,31
 323bef4:	e0bffe15 	stw	r2,-8(fp)
    reg = reg << ETH_OCM_MIIADDRESS_RGAD_OFST; 
 323bef8:	e0bfff17 	ldw	r2,-4(fp)
 323befc:	1004923a 	slli	r2,r2,8
 323bf00:	e0bfff15 	stw	r2,-4(fp)
    reg &= ETH_OCM_MIIADDRESS_RGAD_MSK;
 323bf04:	e0bfff17 	ldw	r2,-4(fp)
 323bf08:	1087c00c 	andi	r2,r2,7936
 323bf0c:	e0bfff15 	stw	r2,-4(fp)
    phyad |= reg;
 323bf10:	e0fffe17 	ldw	r3,-8(fp)
 323bf14:	e0bfff17 	ldw	r2,-4(fp)
 323bf18:	1884b03a 	or	r2,r3,r2
 323bf1c:	e0bffe15 	stw	r2,-8(fp)
    IOWR_ETH_OCM_MIIADDRESS(base, phyad); 
 323bf20:	e0bffd17 	ldw	r2,-12(fp)
 323bf24:	10800c04 	addi	r2,r2,48
 323bf28:	1007883a 	mov	r3,r2
 323bf2c:	e0bffe17 	ldw	r2,-8(fp)
 323bf30:	18800035 	stwio	r2,0(r3)
}
 323bf34:	e037883a 	mov	sp,fp
 323bf38:	df000017 	ldw	fp,0(sp)
 323bf3c:	dec00104 	addi	sp,sp,4
 323bf40:	f800283a 	ret

0323bf44 <eth_ocm_write_phy_reg>:

void eth_ocm_write_phy_reg(int base, int phyad, int reg, int data){
 323bf44:	defffa04 	addi	sp,sp,-24
 323bf48:	dfc00515 	stw	ra,20(sp)
 323bf4c:	df000415 	stw	fp,16(sp)
 323bf50:	df000404 	addi	fp,sp,16
 323bf54:	e13ffc15 	stw	r4,-16(fp)
 323bf58:	e17ffd15 	stw	r5,-12(fp)
 323bf5c:	e1bffe15 	stw	r6,-8(fp)
 323bf60:	e1ffff15 	stw	r7,-4(fp)
    eth_ocm_set_phy_addr(base, phyad, reg);
 323bf64:	e13ffc17 	ldw	r4,-16(fp)
 323bf68:	e17ffd17 	ldw	r5,-12(fp)
 323bf6c:	e1bffe17 	ldw	r6,-8(fp)
 323bf70:	323bed40 	call	323bed4 <eth_ocm_set_phy_addr>
    IOWR_ETH_OCM_MIITX_DATA(base, data);
 323bf74:	e0bffc17 	ldw	r2,-16(fp)
 323bf78:	10800d04 	addi	r2,r2,52
 323bf7c:	1007883a 	mov	r3,r2
 323bf80:	e0bfff17 	ldw	r2,-4(fp)
 323bf84:	18800035 	stwio	r2,0(r3)
    IOWR_ETH_OCM_MIICOMMAND(base, ETH_OCM_MIICOMMAND_WCTRLDATA_MSK);
 323bf88:	e0bffc17 	ldw	r2,-16(fp)
 323bf8c:	10800b04 	addi	r2,r2,44
 323bf90:	1007883a 	mov	r3,r2
 323bf94:	00800104 	movi	r2,4
 323bf98:	18800035 	stwio	r2,0(r3)
    eth_ocm_wait(base);
 323bf9c:	e13ffc17 	ldw	r4,-16(fp)
 323bfa0:	323c0cc0 	call	323c0cc <eth_ocm_wait>
}
 323bfa4:	e037883a 	mov	sp,fp
 323bfa8:	dfc00117 	ldw	ra,4(sp)
 323bfac:	df000017 	ldw	fp,0(sp)
 323bfb0:	dec00204 	addi	sp,sp,8
 323bfb4:	f800283a 	ret

0323bfb8 <eth_ocm_read_phy_reg>:

int  eth_ocm_read_phy_reg(int base, int phyad, int reg){
 323bfb8:	defffa04 	addi	sp,sp,-24
 323bfbc:	dfc00515 	stw	ra,20(sp)
 323bfc0:	df000415 	stw	fp,16(sp)
 323bfc4:	df000404 	addi	fp,sp,16
 323bfc8:	e13ffd15 	stw	r4,-12(fp)
 323bfcc:	e17ffe15 	stw	r5,-8(fp)
 323bfd0:	e1bfff15 	stw	r6,-4(fp)
    int result;

    eth_ocm_set_phy_addr(base, phyad, reg);
 323bfd4:	e13ffd17 	ldw	r4,-12(fp)
 323bfd8:	e17ffe17 	ldw	r5,-8(fp)
 323bfdc:	e1bfff17 	ldw	r6,-4(fp)
 323bfe0:	323bed40 	call	323bed4 <eth_ocm_set_phy_addr>
    IOWR_ETH_OCM_MIICOMMAND(base, ETH_OCM_MIICOMMAND_RSTAT_MSK);
 323bfe4:	e0bffd17 	ldw	r2,-12(fp)
 323bfe8:	10800b04 	addi	r2,r2,44
 323bfec:	1007883a 	mov	r3,r2
 323bff0:	00800084 	movi	r2,2
 323bff4:	18800035 	stwio	r2,0(r3)
    eth_ocm_wait(base);
 323bff8:	e13ffd17 	ldw	r4,-12(fp)
 323bffc:	323c0cc0 	call	323c0cc <eth_ocm_wait>
    result = IORD_ETH_OCM_MIIRX_DATA(base);
 323c000:	e0bffd17 	ldw	r2,-12(fp)
 323c004:	10800e04 	addi	r2,r2,56
 323c008:	10800037 	ldwio	r2,0(r2)
 323c00c:	e0bffc15 	stw	r2,-16(fp)
    return result;
 323c010:	e0bffc17 	ldw	r2,-16(fp)
}
 323c014:	e037883a 	mov	sp,fp
 323c018:	dfc00117 	ldw	ra,4(sp)
 323c01c:	df000017 	ldw	fp,0(sp)
 323c020:	dec00204 	addi	sp,sp,8
 323c024:	f800283a 	ret

0323c028 <eth_ocm_phy_add_profile>:

int eth_ocm_phy_add_profile(eth_ocm_phy_profile *profile){
 323c028:	defffc04 	addi	sp,sp,-16
 323c02c:	df000315 	stw	fp,12(sp)
 323c030:	df000304 	addi	fp,sp,12
 323c034:	e13ffe15 	stw	r4,-8(fp)
    int i;
    i = 0;
 323c038:	e03ffd15 	stw	zero,-12(fp)

    for(i=0;i<ETH_OCM_PHY_MAX_PROFILES;i++){
 323c03c:	e03ffd15 	stw	zero,-12(fp)
 323c040:	00001806 	br	323c0a4 <eth_ocm_phy_add_profile+0x7c>
        if(eth_ocm_phy_profile_array[i] == 0){
 323c044:	e0bffd17 	ldw	r2,-12(fp)
 323c048:	00c0c974 	movhi	r3,805
 323c04c:	18d4af04 	addi	r3,r3,21180
 323c050:	1085883a 	add	r2,r2,r2
 323c054:	1085883a 	add	r2,r2,r2
 323c058:	10c5883a 	add	r2,r2,r3
 323c05c:	10800017 	ldw	r2,0(r2)
 323c060:	1004c03a 	cmpne	r2,r2,zero
 323c064:	10000c1e 	bne	r2,zero,323c098 <eth_ocm_phy_add_profile+0x70>
            eth_ocm_phy_profile_array[i] = profile;
 323c068:	e0bffd17 	ldw	r2,-12(fp)
 323c06c:	00c0c974 	movhi	r3,805
 323c070:	18d4af04 	addi	r3,r3,21180
 323c074:	1085883a 	add	r2,r2,r2
 323c078:	1085883a 	add	r2,r2,r2
 323c07c:	10c7883a 	add	r3,r2,r3
 323c080:	e0bffe17 	ldw	r2,-8(fp)
 323c084:	18800015 	stw	r2,0(r3)
            i = ETH_OCM_PHY_MAX_PROFILES;
 323c088:	008000c4 	movi	r2,3
 323c08c:	e0bffd15 	stw	r2,-12(fp)
            return 0;
 323c090:	e03fff15 	stw	zero,-4(fp)
 323c094:	00000806 	br	323c0b8 <eth_ocm_phy_add_profile+0x90>

int eth_ocm_phy_add_profile(eth_ocm_phy_profile *profile){
    int i;
    i = 0;

    for(i=0;i<ETH_OCM_PHY_MAX_PROFILES;i++){
 323c098:	e0bffd17 	ldw	r2,-12(fp)
 323c09c:	10800044 	addi	r2,r2,1
 323c0a0:	e0bffd15 	stw	r2,-12(fp)
 323c0a4:	e0bffd17 	ldw	r2,-12(fp)
 323c0a8:	108000d0 	cmplti	r2,r2,3
 323c0ac:	103fe51e 	bne	r2,zero,323c044 <eth_ocm_phy_add_profile+0x1c>
            i = ETH_OCM_PHY_MAX_PROFILES;
            return 0;
        }
    }

    return -1;
 323c0b0:	00bfffc4 	movi	r2,-1
 323c0b4:	e0bfff15 	stw	r2,-4(fp)
 323c0b8:	e0bfff17 	ldw	r2,-4(fp)
}
 323c0bc:	e037883a 	mov	sp,fp
 323c0c0:	df000017 	ldw	fp,0(sp)
 323c0c4:	dec00104 	addi	sp,sp,4
 323c0c8:	f800283a 	ret

0323c0cc <eth_ocm_wait>:

static int eth_ocm_wait(int base){
 323c0cc:	defffc04 	addi	sp,sp,-16
 323c0d0:	df000315 	stw	fp,12(sp)
 323c0d4:	df000304 	addi	fp,sp,12
 323c0d8:	e13fff15 	stw	r4,-4(fp)
    int temp;
    int i;
    i = 0;
 323c0dc:	e03ffd15 	stw	zero,-12(fp)
    temp = 1;
 323c0e0:	00800044 	movi	r2,1
 323c0e4:	e0bffe15 	stw	r2,-8(fp)
    while(temp && i<1000){
 323c0e8:	00000a06 	br	323c114 <eth_ocm_wait+0x48>
        temp = IORD_ETH_OCM_MIISTATUS(base);
 323c0ec:	e0bfff17 	ldw	r2,-4(fp)
 323c0f0:	10800f04 	addi	r2,r2,60
 323c0f4:	10800037 	ldwio	r2,0(r2)
 323c0f8:	e0bffe15 	stw	r2,-8(fp)
        #if(ETH_OCM_DBG_LVL > 0)
        if(temp & ETH_OCM_MIISTATUS_NVALID_MSK)
            printf("Invalid bit set in MII Status register\n");
        #endif
        temp &= ETH_OCM_MIISTATUS_BUSY_MSK;
 323c0fc:	e0bffe17 	ldw	r2,-8(fp)
 323c100:	1080008c 	andi	r2,r2,2
 323c104:	e0bffe15 	stw	r2,-8(fp)
        i++;
 323c108:	e0bffd17 	ldw	r2,-12(fp)
 323c10c:	10800044 	addi	r2,r2,1
 323c110:	e0bffd15 	stw	r2,-12(fp)
static int eth_ocm_wait(int base){
    int temp;
    int i;
    i = 0;
    temp = 1;
    while(temp && i<1000){
 323c114:	e0bffe17 	ldw	r2,-8(fp)
 323c118:	1005003a 	cmpeq	r2,r2,zero
 323c11c:	1000031e 	bne	r2,zero,323c12c <eth_ocm_wait+0x60>
 323c120:	e0bffd17 	ldw	r2,-12(fp)
 323c124:	1080fa10 	cmplti	r2,r2,1000
 323c128:	103ff01e 	bne	r2,zero,323c0ec <eth_ocm_wait+0x20>
    #if(ETH_OCM_DBG_LVL > 0)
    if(i == 1000)
        printf("[eth_ocm_set_phy_reg] Failed waiting for MII module to be ready!\n");
    #endif
        
    return temp;
 323c12c:	e0bffe17 	ldw	r2,-8(fp)
    
}
 323c130:	e037883a 	mov	sp,fp
 323c134:	df000017 	ldw	fp,0(sp)
 323c138:	dec00104 	addi	sp,sp,4
 323c13c:	f800283a 	ret

0323c140 <eth_ocm_phy_init>:
 *
 * @param  dev Pointer to eth_ocm_dev struct which contains needed base address
 * @return 1 if Link is established in Full duplex.
 *         0 if Link is established in Half duplex.
 */
int eth_ocm_phy_init(eth_ocm_dev *dev){
 323c140:	defff104 	addi	sp,sp,-60
 323c144:	dfc00e15 	stw	ra,56(sp)
 323c148:	df000d15 	stw	fp,52(sp)
 323c14c:	df000d04 	addi	fp,sp,52
 323c150:	e13ffe15 	stw	r4,-8(fp)
    int base;
    int found;
    eth_ocm_phy_profile *profile;
    // determine PHY speed: This is PHY dependent and you need to change
    // this according to your PHY's specifications
    duplex = 1;
 323c154:	00800044 	movi	r2,1
 323c158:	e0bffd15 	stw	r2,-12(fp)
    dat = 0;
 323c15c:	e03ff715 	stw	zero,-36(fp)
    found = 0;
 323c160:	e03ff415 	stw	zero,-48(fp)
    base = dev->base;
 323c164:	e0bffe17 	ldw	r2,-8(fp)
 323c168:	10800717 	ldw	r2,28(r2)
 323c16c:	e0bff515 	stw	r2,-44(fp)

    // Add internal PHY profiles
    eth_ocm_phy_profiles_init();
 323c170:	323c4d40 	call	323c4d4 <eth_ocm_phy_profiles_init>

    // ------------------------------
    // PHY detection
    // ------------------------------
    phyid = eth_ocm_read_phy_reg(base, dat, ETH_OCM_PHY_ADDR_PHY_ID1);
 323c174:	e13ff517 	ldw	r4,-44(fp)
 323c178:	e17ff717 	ldw	r5,-36(fp)
 323c17c:	01800084 	movi	r6,2
 323c180:	323bfb80 	call	323bfb8 <eth_ocm_read_phy_reg>
 323c184:	e0bffc15 	stw	r2,-16(fp)
    for (dat = 0x00; dat < 0xff; dat++){
 323c188:	e03ff715 	stw	zero,-36(fp)
 323c18c:	00002906 	br	323c234 <eth_ocm_phy_init+0xf4>
        phyid = eth_ocm_read_phy_reg(base, dat, ETH_OCM_PHY_ADDR_PHY_ID1);
 323c190:	e13ff517 	ldw	r4,-44(fp)
 323c194:	e17ff717 	ldw	r5,-36(fp)
 323c198:	01800084 	movi	r6,2
 323c19c:	323bfb80 	call	323bfb8 <eth_ocm_read_phy_reg>
 323c1a0:	e0bffc15 	stw	r2,-16(fp)
        phyid2 = eth_ocm_read_phy_reg(base, dat, ETH_OCM_PHY_ADDR_PHY_ID2);
 323c1a4:	e13ff517 	ldw	r4,-44(fp)
 323c1a8:	e17ff717 	ldw	r5,-36(fp)
 323c1ac:	018000c4 	movi	r6,3
 323c1b0:	323bfb80 	call	323bfb8 <eth_ocm_read_phy_reg>
 323c1b4:	e0bffb15 	stw	r2,-20(fp)

        if (phyid != phyid2 && (phyid2 != 0xffff)){ // Found the PHY
 323c1b8:	e0fffc17 	ldw	r3,-16(fp)
 323c1bc:	e0bffb17 	ldw	r2,-20(fp)
 323c1c0:	18801926 	beq	r3,r2,323c228 <eth_ocm_phy_init+0xe8>
 323c1c4:	e0fffb17 	ldw	r3,-20(fp)
 323c1c8:	00bfffd4 	movui	r2,65535
 323c1cc:	18801626 	beq	r3,r2,323c228 <eth_ocm_phy_init+0xe8>
            // Extract phy info
            oui = phyid << 6;
 323c1d0:	e0bffc17 	ldw	r2,-16(fp)
 323c1d4:	100491ba 	slli	r2,r2,6
 323c1d8:	e0bffa15 	stw	r2,-24(fp)
            oui |= ((phyid2 >> 10) & 0x003F);
 323c1dc:	e0bffb17 	ldw	r2,-20(fp)
 323c1e0:	1005d2ba 	srai	r2,r2,10
 323c1e4:	10c00fcc 	andi	r3,r2,63
 323c1e8:	e0bffa17 	ldw	r2,-24(fp)
 323c1ec:	10c4b03a 	or	r2,r2,r3
 323c1f0:	e0bffa15 	stw	r2,-24(fp)
            mdl = ((phyid2 >> 4) & 0x03F);
 323c1f4:	e0bffb17 	ldw	r2,-20(fp)
 323c1f8:	1005d13a 	srai	r2,r2,4
 323c1fc:	10800fcc 	andi	r2,r2,63
 323c200:	e0bff915 	stw	r2,-28(fp)
            rev = (phyid2 & 0x000F);
 323c204:	e0bffb17 	ldw	r2,-20(fp)
 323c208:	108003cc 	andi	r2,r2,15
 323c20c:	e0bff815 	stw	r2,-32(fp)
                    "  OUI: 0x%x\n"
                    "  Model: 0x%x\n"
                    "  Rev: 0x%x\n",
                    dat, oui, mdl, rev);
            #endif
            phyadd = dat;
 323c210:	e0bff717 	ldw	r2,-36(fp)
 323c214:	e0bff615 	stw	r2,-40(fp)
            dat = 0xff; // end loop
 323c218:	00803fc4 	movi	r2,255
 323c21c:	e0bff715 	stw	r2,-36(fp)
            found = 1;
 323c220:	00800044 	movi	r2,1
 323c224:	e0bff415 	stw	r2,-48(fp)

    // ------------------------------
    // PHY detection
    // ------------------------------
    phyid = eth_ocm_read_phy_reg(base, dat, ETH_OCM_PHY_ADDR_PHY_ID1);
    for (dat = 0x00; dat < 0xff; dat++){
 323c228:	e0bff717 	ldw	r2,-36(fp)
 323c22c:	10800044 	addi	r2,r2,1
 323c230:	e0bff715 	stw	r2,-36(fp)
 323c234:	e0bff717 	ldw	r2,-36(fp)
 323c238:	10803fd0 	cmplti	r2,r2,255
 323c23c:	103fd41e 	bne	r2,zero,323c190 <eth_ocm_phy_init+0x50>
            dat = 0xff; // end loop
            found = 1;
        }
    }

    if(!found){
 323c240:	e0bff417 	ldw	r2,-48(fp)
 323c244:	1004c03a 	cmpne	r2,r2,zero
 323c248:	1000021e 	bne	r2,zero,323c254 <eth_ocm_phy_init+0x114>
        #if(ETH_OCM_DBG_LVL > 0)
        printf("[eth_ocm_phy_init] NO PHY FOUND!\n");
        #endif
        return 0;
 323c24c:	e03fff15 	stw	zero,-4(fp)
 323c250:	00006b06 	br	323c400 <eth_ocm_phy_init+0x2c0>
    }


    // A PHY was found, let's move on
    // Lookup PHY in table
    found = 0;
 323c254:	e03ff415 	stw	zero,-48(fp)
    for(dat=0;(dat<ETH_OCM_PHY_MAX_PROFILES) && (eth_ocm_phy_profile_array[dat] != 0); dat++){
 323c258:	e03ff715 	stw	zero,-36(fp)
 323c25c:	00001606 	br	323c2b8 <eth_ocm_phy_init+0x178>
        profile = eth_ocm_phy_profile_array[dat];
 323c260:	e0bff717 	ldw	r2,-36(fp)
 323c264:	00c0c974 	movhi	r3,805
 323c268:	18d4af04 	addi	r3,r3,21180
 323c26c:	1085883a 	add	r2,r2,r2
 323c270:	1085883a 	add	r2,r2,r2
 323c274:	10c5883a 	add	r2,r2,r3
 323c278:	10800017 	ldw	r2,0(r2)
 323c27c:	e0bff315 	stw	r2,-52(fp)
        // We compare oui & model number but not rev.
        if( (profile->oui == oui) && (profile->model_number == mdl)){
 323c280:	e0bff317 	ldw	r2,-52(fp)
 323c284:	10c01417 	ldw	r3,80(r2)
 323c288:	e0bffa17 	ldw	r2,-24(fp)
 323c28c:	1880071e 	bne	r3,r2,323c2ac <eth_ocm_phy_init+0x16c>
 323c290:	e0bff317 	ldw	r2,-52(fp)
 323c294:	10801503 	ldbu	r2,84(r2)
 323c298:	10c03fcc 	andi	r3,r2,255
 323c29c:	e0bff917 	ldw	r2,-28(fp)
 323c2a0:	1880021e 	bne	r3,r2,323c2ac <eth_ocm_phy_init+0x16c>
            // Found a match in the table
            found = 1;
 323c2a4:	00800044 	movi	r2,1
 323c2a8:	e0bff415 	stw	r2,-48(fp)


    // A PHY was found, let's move on
    // Lookup PHY in table
    found = 0;
    for(dat=0;(dat<ETH_OCM_PHY_MAX_PROFILES) && (eth_ocm_phy_profile_array[dat] != 0); dat++){
 323c2ac:	e0bff717 	ldw	r2,-36(fp)
 323c2b0:	10800044 	addi	r2,r2,1
 323c2b4:	e0bff715 	stw	r2,-36(fp)
 323c2b8:	e0bff717 	ldw	r2,-36(fp)
 323c2bc:	108000c8 	cmpgei	r2,r2,3
 323c2c0:	1000091e 	bne	r2,zero,323c2e8 <eth_ocm_phy_init+0x1a8>
 323c2c4:	e0bff717 	ldw	r2,-36(fp)
 323c2c8:	00c0c974 	movhi	r3,805
 323c2cc:	18d4af04 	addi	r3,r3,21180
 323c2d0:	1085883a 	add	r2,r2,r2
 323c2d4:	1085883a 	add	r2,r2,r2
 323c2d8:	10c5883a 	add	r2,r2,r3
 323c2dc:	10800017 	ldw	r2,0(r2)
 323c2e0:	1004c03a 	cmpne	r2,r2,zero
 323c2e4:	103fde1e 	bne	r2,zero,323c260 <eth_ocm_phy_init+0x120>
            printf("[eth_ocm_phy_init] Found PHY: %s\n", profile->name);
            #endif
        }
    }

    if(!found){
 323c2e8:	e0bff417 	ldw	r2,-48(fp)
 323c2ec:	1004c03a 	cmpne	r2,r2,zero
 323c2f0:	1000021e 	bne	r2,zero,323c2fc <eth_ocm_phy_init+0x1bc>
        #if(ETH_OCM_DBG_LVL > 0)
        printf("[eth_ocm_phy_init] Could not find matching PHY profile!\n");
        #endif
        return 0;
 323c2f4:	e03fff15 	stw	zero,-4(fp)
 323c2f8:	00004106 	br	323c400 <eth_ocm_phy_init+0x2c0>
    }

    dev->phyadd = phyadd;
 323c2fc:	e0fff617 	ldw	r3,-40(fp)
 323c300:	e0bffe17 	ldw	r2,-8(fp)
 323c304:	10c00815 	stw	r3,32(r2)
    // Call the config function if provided
    if(profile->phy_cfg != NULL)
 323c308:	e0bff317 	ldw	r2,-52(fp)
 323c30c:	10801617 	ldw	r2,88(r2)
 323c310:	1005003a 	cmpeq	r2,r2,zero
 323c314:	1000041e 	bne	r2,zero,323c328 <eth_ocm_phy_init+0x1e8>
        profile->phy_cfg(dev);
 323c318:	e0bff317 	ldw	r2,-52(fp)
 323c31c:	10801617 	ldw	r2,88(r2)
 323c320:	e13ffe17 	ldw	r4,-8(fp)
 323c324:	103ee83a 	callr	r2
        eth_ocm_write_phy_reg(base, phyadd, ETH_OCM_PHY_ADDR_CONTROL,PCS_CTL_an_enable | PCS_CTL_sw_reset);    // send PHY reset command
        dprintf("[eth_ocm_phy_init] PHY Reset\n" );
    }
    */
    
    if(!(eth_ocm_read_phy_reg(base, phyadd, ETH_OCM_PHY_ADDR_STATUS)& PCS_ST_an_done)) {
 323c328:	e13ff517 	ldw	r4,-44(fp)
 323c32c:	e17ff617 	ldw	r5,-40(fp)
 323c330:	01800044 	movi	r6,1
 323c334:	323bfb80 	call	323bfb8 <eth_ocm_read_phy_reg>
 323c338:	1080080c 	andi	r2,r2,32
 323c33c:	1004c03a 	cmpne	r2,r2,zero
 323c340:	1000141e 	bne	r2,zero,323c394 <eth_ocm_phy_init+0x254>
        #if(ETH_OCM_DBG_LVL > 0)
        printf("[eth_ocm_phy_init] Waiting on PHY link...");
        #endif
        dat=0;
 323c344:	e03ff715 	stw	zero,-36(fp)
        while( (eth_ocm_read_phy_reg(base, phyadd, ETH_OCM_PHY_ADDR_STATUS) & PCS_ST_an_done) == 0 ){
 323c348:	00000b06 	br	323c378 <eth_ocm_phy_init+0x238>
            if( dat++ > ETH_OCM_PHY_TIMEOUT_THRESHOLD) {
 323c34c:	e0fff717 	ldw	r3,-36(fp)
 323c350:	008000b4 	movhi	r2,2
 323c354:	10a1a804 	addi	r2,r2,-31072
 323c358:	10c4803a 	cmplt	r2,r2,r3
 323c35c:	1007883a 	mov	r3,r2
 323c360:	e0bff717 	ldw	r2,-36(fp)
 323c364:	10800044 	addi	r2,r2,1
 323c368:	e0bff715 	stw	r2,-36(fp)
 323c36c:	18803fcc 	andi	r2,r3,255
 323c370:	1004c03a 	cmpne	r2,r2,zero
 323c374:	1000071e 	bne	r2,zero,323c394 <eth_ocm_phy_init+0x254>
    if(!(eth_ocm_read_phy_reg(base, phyadd, ETH_OCM_PHY_ADDR_STATUS)& PCS_ST_an_done)) {
        #if(ETH_OCM_DBG_LVL > 0)
        printf("[eth_ocm_phy_init] Waiting on PHY link...");
        #endif
        dat=0;
        while( (eth_ocm_read_phy_reg(base, phyadd, ETH_OCM_PHY_ADDR_STATUS) & PCS_ST_an_done) == 0 ){
 323c378:	e13ff517 	ldw	r4,-44(fp)
 323c37c:	e17ff617 	ldw	r5,-40(fp)
 323c380:	01800044 	movi	r6,1
 323c384:	323bfb80 	call	323bfb8 <eth_ocm_read_phy_reg>
 323c388:	1080080c 	andi	r2,r2,32
 323c38c:	1005003a 	cmpeq	r2,r2,zero
 323c390:	103fee1e 	bne	r2,zero,323c34c <eth_ocm_phy_init+0x20c>
        #if(ETH_OCM_DBG_LVL > 0)
        printf("OK. x=%d, PHY STATUS=%04x\n",dat, eth_ocm_read_phy_reg(base, phyadd, ETH_OCM_PHY_ADDR_STATUS));
        #endif
    }

    if(profile->duplex_status_read != NULL){
 323c394:	e0bff317 	ldw	r2,-52(fp)
 323c398:	10801717 	ldw	r2,92(r2)
 323c39c:	1005003a 	cmpeq	r2,r2,zero
 323c3a0:	1000071e 	bne	r2,zero,323c3c0 <eth_ocm_phy_init+0x280>
        duplex = profile->duplex_status_read(dev) & 0x01;
 323c3a4:	e0bff317 	ldw	r2,-52(fp)
 323c3a8:	10801717 	ldw	r2,92(r2)
 323c3ac:	e13ffe17 	ldw	r4,-8(fp)
 323c3b0:	103ee83a 	callr	r2
 323c3b4:	1080004c 	andi	r2,r2,1
 323c3b8:	e0bffd15 	stw	r2,-12(fp)
 323c3bc:	00000e06 	br	323c3f8 <eth_ocm_phy_init+0x2b8>
    }else{
        dat = eth_ocm_read_phy_reg(base, phyadd, profile->status_reg_location);
 323c3c0:	e0bff317 	ldw	r2,-52(fp)
 323c3c4:	10801583 	ldbu	r2,86(r2)
 323c3c8:	11803fcc 	andi	r6,r2,255
 323c3cc:	e13ff517 	ldw	r4,-44(fp)
 323c3d0:	e17ff617 	ldw	r5,-40(fp)
 323c3d4:	323bfb80 	call	323bfb8 <eth_ocm_read_phy_reg>
 323c3d8:	e0bff715 	stw	r2,-36(fp)
        duplex = (dat >> profile->duplex_bit_location) & 0x01;
 323c3dc:	e0bff317 	ldw	r2,-52(fp)
 323c3e0:	108015c3 	ldbu	r2,87(r2)
 323c3e4:	10c03fcc 	andi	r3,r2,255
 323c3e8:	e0bff717 	ldw	r2,-36(fp)
 323c3ec:	10c5d83a 	sra	r2,r2,r3
 323c3f0:	1080004c 	andi	r2,r2,1
 323c3f4:	e0bffd15 	stw	r2,-12(fp)

    #if(ETH_OCM_DBG_LVL > 0)
    printf("[eth_ocm_phy_init] Full Duplex is %d\n", duplex);
    #endif

    return duplex;
 323c3f8:	e0bffd17 	ldw	r2,-12(fp)
 323c3fc:	e0bfff15 	stw	r2,-4(fp)
 323c400:	e0bfff17 	ldw	r2,-4(fp)
}
 323c404:	e037883a 	mov	sp,fp
 323c408:	dfc00117 	ldw	ra,4(sp)
 323c40c:	df000017 	ldw	fp,0(sp)
 323c410:	dec00204 	addi	sp,sp,8
 323c414:	f800283a 	ret

0323c418 <phy_cfg_MVL88E1111>:

// ***************
// Marvell 88E1111
// ***************
#ifdef ETH_OCM_PHY_SUPPORT_MVL88E1111
static alt_32 phy_cfg_MVL88E1111(eth_ocm_dev *dev){
 323c418:	defff904 	addi	sp,sp,-28
 323c41c:	dfc00615 	stw	ra,24(sp)
 323c420:	df000515 	stw	fp,20(sp)
 323c424:	df000504 	addi	fp,sp,20
 323c428:	e13fff15 	stw	r4,-4(fp)
    int duplex;     /* 1 = full ; 0 = half*/
    int dat;
    int phyadd;
    int base;

    duplex = 1;
 323c42c:	00800044 	movi	r2,1
 323c430:	e0bffe15 	stw	r2,-8(fp)
    dat = 0;
 323c434:	e03ffd15 	stw	zero,-12(fp)
    phyadd = 0;
 323c438:	e03ffc15 	stw	zero,-16(fp)
    base = dev->base;
 323c43c:	e0bfff17 	ldw	r2,-4(fp)
 323c440:	10800717 	ldw	r2,28(r2)
 323c444:	e0bffb15 	stw	r2,-20(fp)
    phyadd = dev->phyadd;
 323c448:	e0bfff17 	ldw	r2,-4(fp)
 323c44c:	10800817 	ldw	r2,32(r2)
 323c450:	e0bffc15 	stw	r2,-16(fp)

    // Disable 1000BASE-T Autonegotiation
    dat = eth_ocm_read_phy_reg(base, phyadd, 0x09);
 323c454:	e13ffb17 	ldw	r4,-20(fp)
 323c458:	e17ffc17 	ldw	r5,-16(fp)
 323c45c:	01800244 	movi	r6,9
 323c460:	323bfb80 	call	323bfb8 <eth_ocm_read_phy_reg>
 323c464:	e0bffd15 	stw	r2,-12(fp)
    dat &= 0xFCFF;
 323c468:	e0bffd17 	ldw	r2,-12(fp)
 323c46c:	10bf3fcc 	andi	r2,r2,64767
 323c470:	e0bffd15 	stw	r2,-12(fp)
    eth_ocm_write_phy_reg(base, phyadd, 0x09, dat);    
 323c474:	e13ffb17 	ldw	r4,-20(fp)
 323c478:	e17ffc17 	ldw	r5,-16(fp)
 323c47c:	01800244 	movi	r6,9
 323c480:	e1fffd17 	ldw	r7,-12(fp)
 323c484:	323bf440 	call	323bf44 <eth_ocm_write_phy_reg>
    // Restart autonegotiation
    dat = eth_ocm_read_phy_reg(base, phyadd, ETH_OCM_PHY_ADDR_CONTROL);
 323c488:	e13ffb17 	ldw	r4,-20(fp)
 323c48c:	e17ffc17 	ldw	r5,-16(fp)
 323c490:	000d883a 	mov	r6,zero
 323c494:	323bfb80 	call	323bfb8 <eth_ocm_read_phy_reg>
 323c498:	e0bffd15 	stw	r2,-12(fp)
    dat |=  PCS_CTL_an_restart;
 323c49c:	e0bffd17 	ldw	r2,-12(fp)
 323c4a0:	10808014 	ori	r2,r2,512
 323c4a4:	e0bffd15 	stw	r2,-12(fp)
    eth_ocm_write_phy_reg(base, phyadd, ETH_OCM_PHY_ADDR_CONTROL, dat);
 323c4a8:	e13ffb17 	ldw	r4,-20(fp)
 323c4ac:	e17ffc17 	ldw	r5,-16(fp)
 323c4b0:	000d883a 	mov	r6,zero
 323c4b4:	e1fffd17 	ldw	r7,-12(fp)
 323c4b8:	323bf440 	call	323bf44 <eth_ocm_write_phy_reg>
    
    return 0;
 323c4bc:	0005883a 	mov	r2,zero
}
 323c4c0:	e037883a 	mov	sp,fp
 323c4c4:	dfc00117 	ldw	ra,4(sp)
 323c4c8:	df000017 	ldw	fp,0(sp)
 323c4cc:	dec00204 	addi	sp,sp,8
 323c4d0:	f800283a 	ret

0323c4d4 <eth_ocm_phy_profiles_init>:
	NULL
};
 
#endif // ETH_OCM_PHY_SUPPORT_VSC8641

void eth_ocm_phy_profiles_init(){
 323c4d4:	defffe04 	addi	sp,sp,-8
 323c4d8:	dfc00115 	stw	ra,4(sp)
 323c4dc:	df000015 	stw	fp,0(sp)
 323c4e0:	d839883a 	mov	fp,sp
#ifdef ETH_OCM_PHY_SUPPORT_LXT972A
    eth_ocm_phy_add_profile(&profile_LXT972A);
#endif

#ifdef ETH_OCM_PHY_SUPPORT_MVL88E1111
    eth_ocm_phy_add_profile(&profile_MVL88E1111);
 323c4e4:	0100c974 	movhi	r4,805
 323c4e8:	2108e304 	addi	r4,r4,9100
 323c4ec:	323c0280 	call	323c028 <eth_ocm_phy_add_profile>
#endif

#ifdef ETH_OCM_PHY_SUPPORT_DP83848C
    eth_ocm_phy_add_profile(&profile_DP83848C);
 323c4f0:	0100c974 	movhi	r4,805
 323c4f4:	2108fb04 	addi	r4,r4,9196
 323c4f8:	323c0280 	call	323c028 <eth_ocm_phy_add_profile>
#endif

#ifdef ETH_OCM_PHY_SUPPORT_VSC8641
    eth_ocm_phy_add_profile(&profile_VSC8641);
#endif
}
 323c4fc:	e037883a 	mov	sp,fp
 323c500:	dfc00117 	ldw	ra,4(sp)
 323c504:	df000017 	ldw	fp,0(sp)
 323c508:	dec00204 	addi	sp,sp,8
 323c50c:	f800283a 	ret

0323c510 <netmain_init>:
 * RETURNS: 
 */

void 
netmain_init(void)
{
 323c510:	defffb04 	addi	sp,sp,-20
 323c514:	dfc00415 	stw	ra,16(sp)
 323c518:	df000315 	stw	fp,12(sp)
 323c51c:	dc000215 	stw	r16,8(sp)
 323c520:	df000204 	addi	fp,sp,8
   int   e = 0;
 323c524:	e03fff15 	stw	zero,-4(fp)
   char *   msg;
#ifdef IP_V6
   ip6_addr host;
#endif

   printf("%s\n", name);
 323c528:	d1204717 	ldw	r4,-32484(gp)
 323c52c:	3206e040 	call	3206e04 <puts>
   printf("Copyright 1996-2008 by InterNiche Technologies. All rights reserved. \n");
 323c530:	0100c974 	movhi	r4,805
 323c534:	213da504 	addi	r4,r4,-2412
 323c538:	3206e040 	call	3206e04 <puts>
#ifdef IN_MENUS
   install_version("allports3.1");
#endif
#ifndef SUPERLOOP
   /* call this to do pre-task setup including intialization of port_prep */
   msg = pre_task_setup();
 323c53c:	322b4d00 	call	322b4d0 <pre_task_setup>
 323c540:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 323c544:	e0bffe17 	ldw	r2,-8(fp)
 323c548:	1005003a 	cmpeq	r2,r2,zero
 323c54c:	1000021e 	bne	r2,zero,323c558 <netmain_init+0x48>
      panic(msg);
 323c550:	e13ffe17 	ldw	r4,-8(fp)
 323c554:	3225df00 	call	3225df0 <panic>
      printf("global_log_create() failed\n");
   }
   glog_with_type(LOG_TYPE_INFO, "INICHE LOG initialized", 1);
#endif

   msg = ip_startup();
 323c558:	32239380 	call	3223938 <ip_startup>
 323c55c:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 323c560:	e0bffe17 	ldw	r2,-8(fp)
 323c564:	1005003a 	cmpeq	r2,r2,zero
 323c568:	1000071e 	bne	r2,zero,323c588 <netmain_init+0x78>
   {
      printf("inet startup error: %s\n", msg);
 323c56c:	0100c974 	movhi	r4,805
 323c570:	213db704 	addi	r4,r4,-2340
 323c574:	e17ffe17 	ldw	r5,-8(fp)
 323c578:	3206adc0 	call	3206adc <printf>
      panic("IP");
 323c57c:	0100c974 	movhi	r4,805
 323c580:	213dbd04 	addi	r4,r4,-2316
 323c584:	3225df00 	call	3225df0 <panic>
   }

#if defined(MEMDEV_SIZE) && defined(VFS_FILES)
   init_memdev(); /* init the mem and null test devices */
 323c588:	32470980 	call	3247098 <init_memdev>
#endif

#ifdef IP_MULTICAST
#ifdef INCLUDE_TCP
   /* call the IP multicast test program */
   u_mctest_init();
 323c58c:	32466600 	call	3246660 <u_mctest_init>

   /* clear debugging flags. Port can optionally turn them
    * back on in post_task_setup();
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    
 323c590:	0080c974 	movhi	r2,805
 323c594:	10923104 	addi	r2,r2,18628
 323c598:	10000015 	stw	zero,0(r2)

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 323c59c:	0080c9b4 	movhi	r2,806
 323c5a0:	10b45b04 	addi	r2,r2,-11924
 323c5a4:	10800017 	ldw	r2,0(r2)
 323c5a8:	14000104 	addi	r16,r2,4
 323c5ac:	0080c9b4 	movhi	r2,806
 323c5b0:	10b45b04 	addi	r2,r2,-11924
 323c5b4:	10800017 	ldw	r2,0(r2)
 323c5b8:	11000a17 	ldw	r4,40(r2)
 323c5bc:	3225c500 	call	3225c50 <print_ipad>
 323c5c0:	100d883a 	mov	r6,r2
 323c5c4:	0100c974 	movhi	r4,805
 323c5c8:	213dbe04 	addi	r4,r4,-2312
 323c5cc:	800b883a 	mov	r5,r16
 323c5d0:	3206adc0 	call	3206adc <printf>
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 
#ifndef SUPERLOOP
   /* call this per-target routine after basic tasks & net are up */
   msg = post_task_setup();
 323c5d4:	322b5440 	call	322b544 <post_task_setup>
 323c5d8:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 323c5dc:	e0bffe17 	ldw	r2,-8(fp)
 323c5e0:	1005003a 	cmpeq	r2,r2,zero
 323c5e4:	1000021e 	bne	r2,zero,323c5f0 <netmain_init+0xe0>
      panic(msg);
 323c5e8:	e13ffe17 	ldw	r4,-8(fp)
 323c5ec:	3225df00 	call	3225df0 <panic>
#ifdef USE_AUTOIP
   Upnp_init();      /* start Auto IP before DHCP client */
#endif   /* USE_AUTOIP */

#ifdef DHCP_CLIENT
   dhc_setup();   /* kick off any DHCP clients */
 323c5f0:	3246d0c0 	call	3246d0c <dhc_setup>
      panic("prep_modules");
   }
#endif
   USE_ARG(e);    /* Avoid compiler warnings */

} /* end of netmain_init() */
 323c5f4:	e037883a 	mov	sp,fp
 323c5f8:	dfc00217 	ldw	ra,8(sp)
 323c5fc:	df000117 	ldw	fp,4(sp)
 323c600:	dc000017 	ldw	r16,0(sp)
 323c604:	dec00304 	addi	sp,sp,12
 323c608:	f800283a 	ret

0323c60c <icmp_port_du>:
 * RETURNS: 
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
 323c60c:	defffb04 	addi	sp,sp,-20
 323c610:	dfc00415 	stw	ra,16(sp)
 323c614:	df000315 	stw	fp,12(sp)
 323c618:	dc000215 	stw	r16,8(sp)
 323c61c:	df000204 	addi	fp,sp,8
 323c620:	e13ffe15 	stw	r4,-8(fp)
 323c624:	e17fff15 	stw	r5,-4(fp)
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
 323c628:	e0bfff17 	ldw	r2,-4(fp)
 323c62c:	10800003 	ldbu	r2,0(r2)
 323c630:	10803fcc 	andi	r2,r2,255
 323c634:	1080201c 	xori	r2,r2,128
 323c638:	10bfe004 	addi	r2,r2,-128
 323c63c:	00c0c974 	movhi	r3,805
 323c640:	18c91304 	addi	r3,r3,9292
 323c644:	1085883a 	add	r2,r2,r2
 323c648:	1085883a 	add	r2,r2,r2
 323c64c:	10c5883a 	add	r2,r2,r3
 323c650:	14000017 	ldw	r16,0(r2)
 323c654:	e0bffe17 	ldw	r2,-8(fp)
 323c658:	11000717 	ldw	r4,28(r2)
 323c65c:	3225c500 	call	3225c50 <print_ipad>
 323c660:	100d883a 	mov	r6,r2
 323c664:	0100c974 	movhi	r4,805
 323c668:	213dce04 	addi	r4,r4,-2248
 323c66c:	800b883a 	mov	r5,r16
 323c670:	3206adc0 	call	3206adc <printf>
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
   dprintf(prompt);
 323c674:	d1204817 	ldw	r4,-32480(gp)
 323c678:	3206adc0 	call	3206adc <printf>
}
 323c67c:	e037883a 	mov	sp,fp
 323c680:	dfc00217 	ldw	ra,8(sp)
 323c684:	df000117 	ldw	fp,4(sp)
 323c688:	dc000017 	ldw	r16,0(sp)
 323c68c:	dec00304 	addi	sp,sp,12
 323c690:	f800283a 	ret

0323c694 <station_state>:
 * RETURNS: 
 */

int
station_state(void * pio)
{
 323c694:	defff904 	addi	sp,sp,-28
 323c698:	dfc00615 	stw	ra,24(sp)
 323c69c:	df000515 	stw	fp,20(sp)
 323c6a0:	dc000415 	stw	r16,16(sp)
 323c6a4:	df000404 	addi	fp,sp,16
 323c6a8:	e13fff15 	stw	r4,-4(fp)
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 323c6ac:	e03ffe15 	stw	zero,-8(fp)
 323c6b0:	0080c9b4 	movhi	r2,806
 323c6b4:	10b45b04 	addi	r2,r2,-11924
 323c6b8:	10800017 	ldw	r2,0(r2)
 323c6bc:	e0bffd15 	stw	r2,-12(fp)
 323c6c0:	00002206 	br	323c74c <station_state+0xb8>
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
 323c6c4:	e0bffd17 	ldw	r2,-12(fp)
 323c6c8:	14000104 	addi	r16,r2,4
 323c6cc:	e0bffd17 	ldw	r2,-12(fp)
 323c6d0:	11000a17 	ldw	r4,40(r2)
 323c6d4:	3225c500 	call	3225c50 <print_ipad>
 323c6d8:	d8800015 	stw	r2,0(sp)
 323c6dc:	e13fff17 	ldw	r4,-4(fp)
 323c6e0:	0140c974 	movhi	r5,805
 323c6e4:	297dd704 	addi	r5,r5,-2212
 323c6e8:	e1bffe17 	ldw	r6,-8(fp)
 323c6ec:	800f883a 	mov	r7,r16
 323c6f0:	32260180 	call	3226018 <ns_printf>
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
 323c6f4:	e0bffd17 	ldw	r2,-12(fp)
 323c6f8:	11000c17 	ldw	r4,48(r2)
 323c6fc:	3225c500 	call	3225c50 <print_ipad>
 323c700:	100d883a 	mov	r6,r2
 323c704:	e13fff17 	ldw	r4,-4(fp)
 323c708:	0140c974 	movhi	r5,805
 323c70c:	297dde04 	addi	r5,r5,-2184
 323c710:	32260180 	call	3226018 <ns_printf>
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
 323c714:	e0bffd17 	ldw	r2,-12(fp)
 323c718:	11000d17 	ldw	r4,52(r2)
 323c71c:	3225c500 	call	3225c50 <print_ipad>
 323c720:	100d883a 	mov	r6,r2
 323c724:	e13fff17 	ldw	r4,-4(fp)
 323c728:	0140c974 	movhi	r5,805
 323c72c:	297de104 	addi	r5,r5,-2172
 323c730:	32260180 	call	3226018 <ns_printf>
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 323c734:	e0bffd17 	ldw	r2,-12(fp)
 323c738:	10800017 	ldw	r2,0(r2)
 323c73c:	e0bffd15 	stw	r2,-12(fp)
 323c740:	e0bffe17 	ldw	r2,-8(fp)
 323c744:	10800044 	addi	r2,r2,1
 323c748:	e0bffe15 	stw	r2,-8(fp)
 323c74c:	e0bffd17 	ldw	r2,-12(fp)
 323c750:	1004c03a 	cmpne	r2,r2,zero
 323c754:	103fdb1e 	bne	r2,zero,323c6c4 <station_state+0x30>
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
   }
#endif   /* NO_INET_STACK */

   ns_printf(pio, "current tick count %lu\n", cticks);
 323c758:	0080c974 	movhi	r2,805
 323c75c:	10925604 	addi	r2,r2,18776
 323c760:	11800017 	ldw	r6,0(r2)
 323c764:	e13fff17 	ldw	r4,-4(fp)
 323c768:	0140c974 	movhi	r5,805
 323c76c:	297de404 	addi	r5,r5,-2160
 323c770:	32260180 	call	3226018 <ns_printf>

   ns_printf(pio, "common delay parameter:  %lu ticks (%lu ms).\n", pingdelay, (pingdelay * TIMEFOR1TICK));
 323c774:	d1a04917 	ldw	r6,-32476(gp)
 323c778:	d1e04917 	ldw	r7,-32476(gp)
 323c77c:	e13fff17 	ldw	r4,-4(fp)
 323c780:	0140c974 	movhi	r5,805
 323c784:	297dea04 	addi	r5,r5,-2136
 323c788:	32260180 	call	3226018 <ns_printf>
   ns_printf(pio, "common host parameter: %s\n", print_ipad(activehost));
 323c78c:	d128f117 	ldw	r4,-23612(gp)
 323c790:	3225c500 	call	3225c50 <print_ipad>
 323c794:	100d883a 	mov	r6,r2
 323c798:	e13fff17 	ldw	r4,-4(fp)
 323c79c:	0140c974 	movhi	r5,805
 323c7a0:	297df604 	addi	r5,r5,-2088
 323c7a4:	32260180 	call	3226018 <ns_printf>
   ns_printf(pio, "common length parameter: %d\n", deflength);
 323c7a8:	d1a04a17 	ldw	r6,-32472(gp)
 323c7ac:	e13fff17 	ldw	r4,-4(fp)
 323c7b0:	0140c974 	movhi	r5,805
 323c7b4:	297dfd04 	addi	r5,r5,-2060
 323c7b8:	32260180 	call	3226018 <ns_printf>
#ifdef USE_PPP
   ns_printf(pio, "current dial-in user name is %s\n", pppcfg.username);
   ns_printf(pio, "current dial-in password is %s\n", pppcfg.password);
#endif   /* USE_PPP */

   task_stats(pio);
 323c7bc:	e13fff17 	ldw	r4,-4(fp)
 323c7c0:	323cd880 	call	323cd88 <task_stats>

   return 0;
 323c7c4:	0005883a 	mov	r2,zero
}
 323c7c8:	e037883a 	mov	sp,fp
 323c7cc:	dfc00217 	ldw	ra,8(sp)
 323c7d0:	df000117 	ldw	fp,4(sp)
 323c7d4:	dc000017 	ldw	r16,0(sp)
 323c7d8:	dec00304 	addi	sp,sp,12
 323c7dc:	f800283a 	ret

0323c7e0 <sysuptime>:
 * RETURNS: 
 */

unsigned long
sysuptime()
{
 323c7e0:	defffe04 	addi	sp,sp,-8
 323c7e4:	dfc00115 	stw	ra,4(sp)
 323c7e8:	df000015 	stw	fp,0(sp)
 323c7ec:	d839883a 	mov	fp,sp
   return ((cticks/TPS)*100);    /* 100ths of a sec since boot time */
 323c7f0:	0080c974 	movhi	r2,805
 323c7f4:	10925604 	addi	r2,r2,18776
 323c7f8:	11000017 	ldw	r4,0(r2)
 323c7fc:	0140fa04 	movi	r5,1000
 323c800:	32044bc0 	call	32044bc <__udivsi3>
 323c804:	10801924 	muli	r2,r2,100
}
 323c808:	e037883a 	mov	sp,fp
 323c80c:	dfc00117 	ldw	ra,4(sp)
 323c810:	df000017 	ldw	fp,0(sp)
 323c814:	dec00204 	addi	sp,sp,8
 323c818:	f800283a 	ret

0323c81c <packet_check>:

static int inside_pktdemux = 0; 

void
packet_check(void)
{
 323c81c:	defffe04 	addi	sp,sp,-8
 323c820:	dfc00115 	stw	ra,4(sp)
 323c824:	df000015 	stw	fp,0(sp)
 323c828:	d839883a 	mov	fp,sp
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
 323c82c:	d0a8f217 	ldw	r2,-23608(gp)
 323c830:	1004c03a 	cmpne	r2,r2,zero
 323c834:	1000071e 	bne	r2,zero,323c854 <packet_check+0x38>
      return;           /* do not re-enter pktdemux(), packet will wait... */
   inside_pktdemux++;   /* set re-entrany flag */
 323c838:	d0a8f217 	ldw	r2,-23608(gp)
 323c83c:	10800044 	addi	r2,r2,1
 323c840:	d0a8f215 	stw	r2,-23608(gp)
   pktdemux();          /* process low level packet input */
 323c844:	32232f00 	call	32232f0 <pktdemux>
   inside_pktdemux--;   /* clear re-entrany flag */
 323c848:	d0a8f217 	ldw	r2,-23608(gp)
 323c84c:	10bfffc4 	addi	r2,r2,-1
 323c850:	d0a8f215 	stw	r2,-23608(gp)
}
 323c854:	e037883a 	mov	sp,fp
 323c858:	dfc00117 	ldw	ra,4(sp)
 323c85c:	df000017 	ldw	fp,0(sp)
 323c860:	dec00204 	addi	sp,sp,8
 323c864:	f800283a 	ret

0323c868 <mcastlist>:
 * RETURNS: 
 */

int
mcastlist(struct in_multi * multi_ptr)
{
 323c868:	defffe04 	addi	sp,sp,-8
 323c86c:	df000115 	stw	fp,4(sp)
 323c870:	df000104 	addi	fp,sp,4
 323c874:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(multi_ptr);

   return 0;
 323c878:	0005883a 	mov	r2,zero
}
 323c87c:	e037883a 	mov	sp,fp
 323c880:	df000017 	ldw	fp,0(sp)
 323c884:	dec00104 	addi	sp,sp,4
 323c888:	f800283a 	ret

0323c88c <prep_modules>:
#ifdef USE_MODEM
extern   int   prep_modem(void);
#endif   /* USE_MODEM */

int prep_modules(void)
{
 323c88c:	defffd04 	addi	sp,sp,-12
 323c890:	dfc00215 	stw	ra,8(sp)
 323c894:	df000115 	stw	fp,4(sp)
 323c898:	df000104 	addi	fp,sp,4
#ifdef IP_V6
   ip6_addr host;
   int i;
#endif

int e = 0;
 323c89c:	e03fff15 	stw	zero,-4(fp)
      panic("prep_modules");
   }
#endif   /* SMTP_ALERTS */

#ifdef VFS_FILES
   e = prep_vfs();
 323c8a0:	324a1f40 	call	324a1f4 <prep_vfs>
 323c8a4:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0)
 323c8a8:	e0bfff17 	ldw	r2,-4(fp)
 323c8ac:	1005003a 	cmpeq	r2,r2,zero
 323c8b0:	1000061e 	bne	r2,zero,323c8cc <prep_modules+0x40>
   {
      dprintf("VFS Module prep failed\n");
 323c8b4:	0100c974 	movhi	r4,805
 323c8b8:	213e0504 	addi	r4,r4,-2028
 323c8bc:	3206e040 	call	3206e04 <puts>
      panic("prep_modules");
 323c8c0:	0100c974 	movhi	r4,805
 323c8c4:	213e0b04 	addi	r4,r4,-2004
 323c8c8:	3225df00 	call	3225df0 <panic>
   {
      dprintf("sslapp_init() failed\n");
      panic("prep_modules");
   }
#endif
   return 0;
 323c8cc:	0005883a 	mov	r2,zero
}
 323c8d0:	e037883a 	mov	sp,fp
 323c8d4:	dfc00117 	ldw	ra,4(sp)
 323c8d8:	df000017 	ldw	fp,0(sp)
 323c8dc:	dec00204 	addi	sp,sp,8
 323c8e0:	f800283a 	ret

0323c8e4 <inet_timer>:
 * RETURNS: 
 */

void
inet_timer(void)
{
 323c8e4:	defffe04 	addi	sp,sp,-8
 323c8e8:	dfc00115 	stw	ra,4(sp)
 323c8ec:	df000015 	stw	fp,0(sp)
 323c8f0:	d839883a 	mov	fp,sp
#ifdef IP_FRAGMENTS
   /* run thru' the IP reassembly queue (once every second) */
   if (ire_cticks < cticks)
 323c8f4:	0080c974 	movhi	r2,805
 323c8f8:	10927704 	addi	r2,r2,18908
 323c8fc:	10c00017 	ldw	r3,0(r2)
 323c900:	0080c974 	movhi	r2,805
 323c904:	10925604 	addi	r2,r2,18776
 323c908:	10800017 	ldw	r2,0(r2)
 323c90c:	1880012e 	bgeu	r3,r2,323c914 <inet_timer+0x30>
      ip_reasm_process_timer_tick ();
 323c910:	3241e940 	call	3241e94 <ip_reasm_process_timer_tick>
#endif

#ifdef INCLUDE_TCP
   tcp_tick();          /* run TCP timers */
 323c914:	322d1140 	call	322d114 <tcp_tick>
#endif

#ifdef INICHE_TIMERS    /* interval timers? */
   check_interval_timers();
 323c918:	323c9a80 	call	323c9a8 <check_interval_timers>
#endif

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Call igmp timeout routine */
   if (igmp_cticks < cticks)  /* Call igmp timeout routine 5 times per sec */
 323c91c:	0080c974 	movhi	r2,805
 323c920:	10923504 	addi	r2,r2,18644
 323c924:	10c00017 	ldw	r3,0(r2)
 323c928:	0080c974 	movhi	r2,805
 323c92c:	10925604 	addi	r2,r2,18776
 323c930:	10800017 	ldw	r2,0(r2)
 323c934:	1880012e 	bgeu	r3,r2,323c93c <inet_timer+0x58>
      igmp_fasttimo();
 323c938:	3223f900 	call	3223f90 <igmp_fasttimo>
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 323c93c:	d0a8f317 	ldw	r2,-23604(gp)
 323c940:	00c0c974 	movhi	r3,805
 323c944:	18d25604 	addi	r3,r3,18776
 323c948:	18c00017 	ldw	r3,0(r3)
 323c94c:	10c00636 	bltu	r2,r3,323c968 <inet_timer+0x84>
 323c950:	0080c974 	movhi	r2,805
 323c954:	10925604 	addi	r2,r2,18776
 323c958:	10800017 	ldw	r2,0(r2)
 323c95c:	10c9c404 	addi	r3,r2,10000
 323c960:	d0a8f317 	ldw	r2,-23604(gp)
 323c964:	18800b2e 	bgeu	r3,r2,323c994 <inet_timer+0xb0>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
   {
      nextppp = cticks + TPS;
 323c968:	0080c974 	movhi	r2,805
 323c96c:	10925604 	addi	r2,r2,18776
 323c970:	10800017 	ldw	r2,0(r2)
 323c974:	1080fa04 	addi	r2,r2,1000
 323c978:	d0a8f315 	stw	r2,-23604(gp)

      if (port_1s_callout != NULL)
 323c97c:	d0a8f417 	ldw	r2,-23600(gp)
 323c980:	1005003a 	cmpeq	r2,r2,zero
 323c984:	1000021e 	bne	r2,zero,323c990 <inet_timer+0xac>
         (*port_1s_callout)();
 323c988:	d0a8f417 	ldw	r2,-23600(gp)
 323c98c:	103ee83a 	callr	r2

#ifdef USE_PPP
      ppp_timeisup();
#endif
#ifdef DHCP_CLIENT
      dhc_second();
 323c990:	32291e40 	call	32291e4 <dhc_second>
#endif
#ifdef IPSEC
      IPSecTimer();
#endif
   }
}
 323c994:	e037883a 	mov	sp,fp
 323c998:	dfc00117 	ldw	ra,4(sp)
 323c99c:	df000017 	ldw	fp,0(sp)
 323c9a0:	dec00204 	addi	sp,sp,8
 323c9a4:	f800283a 	ret

0323c9a8 <check_interval_timers>:

static int numtimers = 0;     /* number of active timers */

static void
check_interval_timers(void)
{
 323c9a8:	defffc04 	addi	sp,sp,-16
 323c9ac:	dfc00315 	stw	ra,12(sp)
 323c9b0:	df000215 	stw	fp,8(sp)
 323c9b4:	df000204 	addi	fp,sp,8
   int   i;
   int   found = 0;  /* number of valid timers found */
 323c9b8:	e03ffe15 	stw	zero,-8(fp)

   /* if no timers, just return */
   if (numtimers > 0)
 323c9bc:	d0a8f517 	ldw	r2,-23596(gp)
 323c9c0:	10800050 	cmplti	r2,r2,1
 323c9c4:	1000591e 	bne	r2,zero,323cb2c <check_interval_timers+0x184>
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 323c9c8:	e03fff15 	stw	zero,-4(fp)
 323c9cc:	00005406 	br	323cb20 <check_interval_timers+0x178>
      {
         if (intimers[i].callback)   /* is this timer active? */
 323c9d0:	e0bfff17 	ldw	r2,-4(fp)
 323c9d4:	00c0c9b4 	movhi	r3,806
 323c9d8:	18f40204 	addi	r3,r3,-12280
 323c9dc:	10800524 	muli	r2,r2,20
 323c9e0:	10c5883a 	add	r2,r2,r3
 323c9e4:	10800017 	ldw	r2,0(r2)
 323c9e8:	1005003a 	cmpeq	r2,r2,zero
 323c9ec:	1000491e 	bne	r2,zero,323cb14 <check_interval_timers+0x16c>
	 {
            if ((intimers[i].tmo < cticks) && (!intimers[i].inuse))  /* timer ready fire? */
 323c9f0:	e0bfff17 	ldw	r2,-4(fp)
 323c9f4:	00c0c9b4 	movhi	r3,806
 323c9f8:	18f40204 	addi	r3,r3,-12280
 323c9fc:	10800524 	muli	r2,r2,20
 323ca00:	10c5883a 	add	r2,r2,r3
 323ca04:	10800304 	addi	r2,r2,12
 323ca08:	10c00017 	ldw	r3,0(r2)
 323ca0c:	0080c974 	movhi	r2,805
 323ca10:	10925604 	addi	r2,r2,18776
 323ca14:	10800017 	ldw	r2,0(r2)
 323ca18:	1880382e 	bgeu	r3,r2,323cafc <check_interval_timers+0x154>
 323ca1c:	e0bfff17 	ldw	r2,-4(fp)
 323ca20:	00c0c9b4 	movhi	r3,806
 323ca24:	18f40204 	addi	r3,r3,-12280
 323ca28:	10800524 	muli	r2,r2,20
 323ca2c:	10c5883a 	add	r2,r2,r3
 323ca30:	10800404 	addi	r2,r2,16
 323ca34:	10800017 	ldw	r2,0(r2)
 323ca38:	1004c03a 	cmpne	r2,r2,zero
 323ca3c:	10002f1e 	bne	r2,zero,323cafc <check_interval_timers+0x154>
            {
               intimers[i].tmo = intimers[i].interval + cticks;   /* set next tmo */
 323ca40:	e17fff17 	ldw	r5,-4(fp)
 323ca44:	e0bfff17 	ldw	r2,-4(fp)
 323ca48:	00c0c9b4 	movhi	r3,806
 323ca4c:	18f40204 	addi	r3,r3,-12280
 323ca50:	10800524 	muli	r2,r2,20
 323ca54:	10c5883a 	add	r2,r2,r3
 323ca58:	10800204 	addi	r2,r2,8
 323ca5c:	10c00017 	ldw	r3,0(r2)
 323ca60:	0080c974 	movhi	r2,805
 323ca64:	10925604 	addi	r2,r2,18776
 323ca68:	10800017 	ldw	r2,0(r2)
 323ca6c:	1889883a 	add	r4,r3,r2
 323ca70:	00c0c9b4 	movhi	r3,806
 323ca74:	18f40204 	addi	r3,r3,-12280
 323ca78:	28800524 	muli	r2,r5,20
 323ca7c:	10c5883a 	add	r2,r2,r3
 323ca80:	10800304 	addi	r2,r2,12
 323ca84:	11000015 	stw	r4,0(r2)
               intimers[i].inuse = TRUE;
 323ca88:	e0bfff17 	ldw	r2,-4(fp)
 323ca8c:	00c0c9b4 	movhi	r3,806
 323ca90:	18f40204 	addi	r3,r3,-12280
 323ca94:	10800524 	muli	r2,r2,20
 323ca98:	10c5883a 	add	r2,r2,r3
 323ca9c:	10c00404 	addi	r3,r2,16
 323caa0:	00800044 	movi	r2,1
 323caa4:	18800015 	stw	r2,0(r3)
               intimers[i].callback(intimers[i].parm);      /* call user routine */
 323caa8:	e0bfff17 	ldw	r2,-4(fp)
 323caac:	00c0c9b4 	movhi	r3,806
 323cab0:	18f40204 	addi	r3,r3,-12280
 323cab4:	10800524 	muli	r2,r2,20
 323cab8:	10c5883a 	add	r2,r2,r3
 323cabc:	11400017 	ldw	r5,0(r2)
 323cac0:	e0bfff17 	ldw	r2,-4(fp)
 323cac4:	00c0c9b4 	movhi	r3,806
 323cac8:	18f40204 	addi	r3,r3,-12280
 323cacc:	10800524 	muli	r2,r2,20
 323cad0:	10c5883a 	add	r2,r2,r3
 323cad4:	10800104 	addi	r2,r2,4
 323cad8:	11000017 	ldw	r4,0(r2)
 323cadc:	283ee83a 	callr	r5
               intimers[i].inuse = FALSE;
 323cae0:	e0bfff17 	ldw	r2,-4(fp)
 323cae4:	00c0c9b4 	movhi	r3,806
 323cae8:	18f40204 	addi	r3,r3,-12280
 323caec:	10800524 	muli	r2,r2,20
 323caf0:	10c5883a 	add	r2,r2,r3
 323caf4:	10800404 	addi	r2,r2,16
 323caf8:	10000015 	stw	zero,0(r2)
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
 323cafc:	e0bffe17 	ldw	r2,-8(fp)
 323cb00:	10800044 	addi	r2,r2,1
 323cb04:	e0bffe15 	stw	r2,-8(fp)
 323cb08:	d0e8f517 	ldw	r3,-23596(gp)
 323cb0c:	e0bffe17 	ldw	r2,-8(fp)
 323cb10:	10c0060e 	bge	r2,r3,323cb2c <check_interval_timers+0x184>

   /* if no timers, just return */
   if (numtimers > 0)
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 323cb14:	e0bfff17 	ldw	r2,-4(fp)
 323cb18:	10800044 	addi	r2,r2,1
 323cb1c:	e0bfff15 	stw	r2,-4(fp)
 323cb20:	e0bfff17 	ldw	r2,-4(fp)
 323cb24:	10800150 	cmplti	r2,r2,5
 323cb28:	103fa91e 	bne	r2,zero,323c9d0 <check_interval_timers+0x28>
            if (++found >= numtimers)
               break;
         }
      }
   }
}
 323cb2c:	e037883a 	mov	sp,fp
 323cb30:	dfc00117 	ldw	ra,4(sp)
 323cb34:	df000017 	ldw	fp,0(sp)
 323cb38:	dec00204 	addi	sp,sp,8
 323cb3c:	f800283a 	ret

0323cb40 <in_timerset>:
 * RETURNS: timer ID if OK, else if table is full.
 */

long
in_timerset(void (*callback)(long), long msecs, long parm)
{
 323cb40:	defff804 	addi	sp,sp,-32
 323cb44:	dfc00715 	stw	ra,28(sp)
 323cb48:	df000615 	stw	fp,24(sp)
 323cb4c:	dc000515 	stw	r16,20(sp)
 323cb50:	df000504 	addi	fp,sp,20
 323cb54:	e13ffc15 	stw	r4,-16(fp)
 323cb58:	e17ffd15 	stw	r5,-12(fp)
 323cb5c:	e1bffe15 	stw	r6,-8(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 323cb60:	e03ffb15 	stw	zero,-20(fp)
 323cb64:	00004a06 	br	323cc90 <in_timerset+0x150>
   {
      if(intimers[i].callback == NULL)
 323cb68:	e0bffb17 	ldw	r2,-20(fp)
 323cb6c:	00c0c9b4 	movhi	r3,806
 323cb70:	18f40204 	addi	r3,r3,-12280
 323cb74:	10800524 	muli	r2,r2,20
 323cb78:	10c5883a 	add	r2,r2,r3
 323cb7c:	10800017 	ldw	r2,0(r2)
 323cb80:	1004c03a 	cmpne	r2,r2,zero
 323cb84:	10003f1e 	bne	r2,zero,323cc84 <in_timerset+0x144>
      {
         /* found empty table entry, set up new timer */
         intimers[i].callback = callback;
 323cb88:	e0bffb17 	ldw	r2,-20(fp)
 323cb8c:	00c0c9b4 	movhi	r3,806
 323cb90:	18f40204 	addi	r3,r3,-12280
 323cb94:	10800524 	muli	r2,r2,20
 323cb98:	10c7883a 	add	r3,r2,r3
 323cb9c:	e0bffc17 	ldw	r2,-16(fp)
 323cba0:	18800015 	stw	r2,0(r3)
         intimers[i].parm = parm;
 323cba4:	e0bffb17 	ldw	r2,-20(fp)
 323cba8:	00c0c9b4 	movhi	r3,806
 323cbac:	18f40204 	addi	r3,r3,-12280
 323cbb0:	10800524 	muli	r2,r2,20
 323cbb4:	10c5883a 	add	r2,r2,r3
 323cbb8:	10c00104 	addi	r3,r2,4
 323cbbc:	e0bffe17 	ldw	r2,-8(fp)
 323cbc0:	18800015 	stw	r2,0(r3)
         /* set interval, in TPS (cticks) units */
         intimers[i].interval = (msecs * TPS)/1000;
 323cbc4:	e43ffb17 	ldw	r16,-20(fp)
 323cbc8:	e0bffd17 	ldw	r2,-12(fp)
 323cbcc:	1100fa24 	muli	r4,r2,1000
 323cbd0:	0140fa04 	movi	r5,1000
 323cbd4:	32044bc0 	call	32044bc <__udivsi3>
 323cbd8:	1009883a 	mov	r4,r2
 323cbdc:	00c0c9b4 	movhi	r3,806
 323cbe0:	18f40204 	addi	r3,r3,-12280
 323cbe4:	80800524 	muli	r2,r16,20
 323cbe8:	10c5883a 	add	r2,r2,r3
 323cbec:	10800204 	addi	r2,r2,8
 323cbf0:	11000015 	stw	r4,0(r2)
         intimers[i].tmo = intimers[i].interval + cticks;   /* first tmo */
 323cbf4:	e17ffb17 	ldw	r5,-20(fp)
 323cbf8:	e0bffb17 	ldw	r2,-20(fp)
 323cbfc:	00c0c9b4 	movhi	r3,806
 323cc00:	18f40204 	addi	r3,r3,-12280
 323cc04:	10800524 	muli	r2,r2,20
 323cc08:	10c5883a 	add	r2,r2,r3
 323cc0c:	10800204 	addi	r2,r2,8
 323cc10:	10c00017 	ldw	r3,0(r2)
 323cc14:	0080c974 	movhi	r2,805
 323cc18:	10925604 	addi	r2,r2,18776
 323cc1c:	10800017 	ldw	r2,0(r2)
 323cc20:	1889883a 	add	r4,r3,r2
 323cc24:	00c0c9b4 	movhi	r3,806
 323cc28:	18f40204 	addi	r3,r3,-12280
 323cc2c:	28800524 	muli	r2,r5,20
 323cc30:	10c5883a 	add	r2,r2,r3
 323cc34:	10800304 	addi	r2,r2,12
 323cc38:	11000015 	stw	r4,0(r2)
		 intimers[i].inuse = FALSE;
 323cc3c:	e0bffb17 	ldw	r2,-20(fp)
 323cc40:	00c0c9b4 	movhi	r3,806
 323cc44:	18f40204 	addi	r3,r3,-12280
 323cc48:	10800524 	muli	r2,r2,20
 323cc4c:	10c5883a 	add	r2,r2,r3
 323cc50:	10800404 	addi	r2,r2,16
 323cc54:	10000015 	stw	zero,0(r2)
         numtimers++;
 323cc58:	d0a8f517 	ldw	r2,-23596(gp)
 323cc5c:	10800044 	addi	r2,r2,1
 323cc60:	d0a8f515 	stw	r2,-23596(gp)
         return (long)&intimers[i];
 323cc64:	e0bffb17 	ldw	r2,-20(fp)
 323cc68:	10800524 	muli	r2,r2,20
 323cc6c:	1007883a 	mov	r3,r2
 323cc70:	0080c9b4 	movhi	r2,806
 323cc74:	10b40204 	addi	r2,r2,-12280
 323cc78:	1885883a 	add	r2,r3,r2
 323cc7c:	e0bfff15 	stw	r2,-4(fp)
 323cc80:	00000706 	br	323cca0 <in_timerset+0x160>
long
in_timerset(void (*callback)(long), long msecs, long parm)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 323cc84:	e0bffb17 	ldw	r2,-20(fp)
 323cc88:	10800044 	addi	r2,r2,1
 323cc8c:	e0bffb15 	stw	r2,-20(fp)
 323cc90:	e0bffb17 	ldw	r2,-20(fp)
 323cc94:	10800150 	cmplti	r2,r2,5
 323cc98:	103fb31e 	bne	r2,zero,323cb68 <in_timerset+0x28>
		 intimers[i].inuse = FALSE;
         numtimers++;
         return (long)&intimers[i];
      }
   }
   return 0;
 323cc9c:	e03fff15 	stw	zero,-4(fp)
 323cca0:	e0bfff17 	ldw	r2,-4(fp)
}
 323cca4:	e037883a 	mov	sp,fp
 323cca8:	dfc00217 	ldw	ra,8(sp)
 323ccac:	df000117 	ldw	fp,4(sp)
 323ccb0:	dc000017 	ldw	r16,0(sp)
 323ccb4:	dec00304 	addi	sp,sp,12
 323ccb8:	f800283a 	ret

0323ccbc <in_timerkill>:
 */


int
in_timerkill(long timer)
{
 323ccbc:	defffb04 	addi	sp,sp,-20
 323ccc0:	dfc00415 	stw	ra,16(sp)
 323ccc4:	df000315 	stw	fp,12(sp)
 323ccc8:	df000304 	addi	fp,sp,12
 323cccc:	e13ffe15 	stw	r4,-8(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 323ccd0:	e03ffd15 	stw	zero,-12(fp)
 323ccd4:	00001706 	br	323cd34 <in_timerkill+0x78>
   {
      if(timer == (long)&intimers[i])
 323ccd8:	e0bffd17 	ldw	r2,-12(fp)
 323ccdc:	10800524 	muli	r2,r2,20
 323cce0:	1007883a 	mov	r3,r2
 323cce4:	0080c9b4 	movhi	r2,806
 323cce8:	10b40204 	addi	r2,r2,-12280
 323ccec:	1885883a 	add	r2,r3,r2
 323ccf0:	1007883a 	mov	r3,r2
 323ccf4:	e0bffe17 	ldw	r2,-8(fp)
 323ccf8:	18800b1e 	bne	r3,r2,323cd28 <in_timerkill+0x6c>
      {
         intimers[i].callback = NULL;
 323ccfc:	e0bffd17 	ldw	r2,-12(fp)
 323cd00:	00c0c9b4 	movhi	r3,806
 323cd04:	18f40204 	addi	r3,r3,-12280
 323cd08:	10800524 	muli	r2,r2,20
 323cd0c:	10c5883a 	add	r2,r2,r3
 323cd10:	10000015 	stw	zero,0(r2)
         numtimers--;
 323cd14:	d0a8f517 	ldw	r2,-23596(gp)
 323cd18:	10bfffc4 	addi	r2,r2,-1
 323cd1c:	d0a8f515 	stw	r2,-23596(gp)
         return 0;      /* OK return */
 323cd20:	e03fff15 	stw	zero,-4(fp)
 323cd24:	00000906 	br	323cd4c <in_timerkill+0x90>
int
in_timerkill(long timer)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 323cd28:	e0bffd17 	ldw	r2,-12(fp)
 323cd2c:	10800044 	addi	r2,r2,1
 323cd30:	e0bffd15 	stw	r2,-12(fp)
 323cd34:	e0bffd17 	ldw	r2,-12(fp)
 323cd38:	10800150 	cmplti	r2,r2,5
 323cd3c:	103fe61e 	bne	r2,zero,323ccd8 <in_timerkill+0x1c>
         intimers[i].callback = NULL;
         numtimers--;
         return 0;      /* OK return */
      }
   }
   dtrap();    /* timer to kill not found */
 323cd40:	322ab8c0 	call	322ab8c <dtrap>
   return ENP_PARAM;
 323cd44:	00bffd84 	movi	r2,-10
 323cd48:	e0bfff15 	stw	r2,-4(fp)
 323cd4c:	e0bfff17 	ldw	r2,-4(fp)
}
 323cd50:	e037883a 	mov	sp,fp
 323cd54:	dfc00117 	ldw	ra,4(sp)
 323cd58:	df000017 	ldw	fp,0(sp)
 323cd5c:	dec00204 	addi	sp,sp,8
 323cd60:	f800283a 	ret

0323cd64 <create_apptasks>:
#endif
/* per-application thread definitions */

int
create_apptasks(void)
{
 323cd64:	defffe04 	addi	sp,sp,-8
 323cd68:	df000115 	stw	fp,4(sp)
 323cd6c:	df000104 	addi	fp,sp,4
int e = 0;
 323cd70:	e03fff15 	stw	zero,-4(fp)
#endif
/* 
 * Altera Niche Stack Nios port modification:
 * return error code, if any 
 */
   return e;
 323cd74:	e0bfff17 	ldw	r2,-4(fp)
}
 323cd78:	e037883a 	mov	sp,fp
 323cd7c:	df000017 	ldw	fp,0(sp)
 323cd80:	dec00104 	addi	sp,sp,4
 323cd84:	f800283a 	ret

0323cd88 <task_stats>:
 */


void
task_stats(void * pio)
{
 323cd88:	defffd04 	addi	sp,sp,-12
 323cd8c:	dfc00215 	stw	ra,8(sp)
 323cd90:	df000115 	stw	fp,4(sp)
 323cd94:	df000104 	addi	fp,sp,4
 323cd98:	e13fff15 	stw	r4,-4(fp)
   ns_printf(pio, "Task wakeups:");
 323cd9c:	e13fff17 	ldw	r4,-4(fp)
 323cda0:	0140c974 	movhi	r5,805
 323cda4:	297e0f04 	addi	r5,r5,-1988
 323cda8:	32260180 	call	3226018 <ns_printf>

#ifndef NO_INET_STACK
   ns_printf(pio, "netmain: %lu\n", netmain_wakes);
 323cdac:	0080c974 	movhi	r2,805
 323cdb0:	10923804 	addi	r2,r2,18656
 323cdb4:	11800017 	ldw	r6,0(r2)
 323cdb8:	e13fff17 	ldw	r4,-4(fp)
 323cdbc:	0140c974 	movhi	r5,805
 323cdc0:	297e1304 	addi	r5,r5,-1972
 323cdc4:	32260180 	call	3226018 <ns_printf>
#endif
#ifndef NO_INET_TICK
   ns_printf(pio, "nettick: %lu\n", nettick_wakes);
 323cdc8:	0080c974 	movhi	r2,805
 323cdcc:	10923904 	addi	r2,r2,18660
 323cdd0:	11800017 	ldw	r6,0(r2)
 323cdd4:	e13fff17 	ldw	r4,-4(fp)
 323cdd8:	0140c974 	movhi	r5,805
 323cddc:	297e1704 	addi	r5,r5,-1956
 323cde0:	32260180 	call	3226018 <ns_printf>
   ns_printf(pio, "browtask: %lu  ", browtask_wakes);
#endif
#ifdef INCLUDE_SSLAPP
   ns_printf(pio, "INCLUDE_SSLAPP: %lu  ", sslapp_wakes);
#endif
   ns_printf(pio, "\n");
 323cde4:	e13fff17 	ldw	r4,-4(fp)
 323cde8:	0140c974 	movhi	r5,805
 323cdec:	297e1b04 	addi	r5,r5,-1940
 323cdf0:	32260180 	call	3226018 <ns_printf>
}
 323cdf4:	e037883a 	mov	sp,fp
 323cdf8:	dfc00117 	ldw	ra,4(sp)
 323cdfc:	df000017 	ldw	fp,0(sp)
 323ce00:	dec00204 	addi	sp,sp,8
 323ce04:	f800283a 	ret

0323ce08 <fcntl>:
 * (for files and device drivers) or calls the InterNiche bsd_ioctl for 
 * sockets.
 */
 
int fcntl (int file, int cmd, ...)
{
 323ce08:	defff704 	addi	sp,sp,-36
 323ce0c:	dfc00615 	stw	ra,24(sp)
 323ce10:	df000515 	stw	fp,20(sp)
 323ce14:	df000504 	addi	fp,sp,20
 323ce18:	e13ffd15 	stw	r4,-12(fp)
 323ce1c:	e1800215 	stw	r6,8(fp)
 323ce20:	e1c00315 	stw	r7,12(fp)
 323ce24:	e17ffe15 	stw	r5,-8(fp)
  long     flags;
  va_list  argp;

  if (file < ALT_MAX_FD)
 323ce28:	e0bffd17 	ldw	r2,-12(fp)
 323ce2c:	10800808 	cmpgei	r2,r2,32
 323ce30:	10000e1e 	bne	r2,zero,323ce6c <fcntl+0x64>
  {
    va_start(argp, cmd);
 323ce34:	e0800204 	addi	r2,fp,8
 323ce38:	e0bffc15 	stw	r2,-16(fp)
    flags = va_arg(argp, long);
 323ce3c:	e0fffc17 	ldw	r3,-16(fp)
 323ce40:	18800104 	addi	r2,r3,4
 323ce44:	e0bffc15 	stw	r2,-16(fp)
 323ce48:	1805883a 	mov	r2,r3
 323ce4c:	10800017 	ldw	r2,0(r2)
 323ce50:	e0bffb15 	stw	r2,-20(fp)
    va_end(argp);
    return alt_fcntl(file, cmd, flags);
 323ce54:	e13ffd17 	ldw	r4,-12(fp)
 323ce58:	e17ffe17 	ldw	r5,-8(fp)
 323ce5c:	e1bffb17 	ldw	r6,-20(fp)
 323ce60:	324a3640 	call	324a364 <alt_fcntl>
 323ce64:	e0bfff15 	stw	r2,-4(fp)
 323ce68:	00000d06 	br	323cea0 <fcntl+0x98>
  }
  else
  {
    va_start(argp, cmd);
 323ce6c:	e0800204 	addi	r2,fp,8
 323ce70:	e0bffc15 	stw	r2,-16(fp)
    flags = va_arg(argp, long);
 323ce74:	e0fffc17 	ldw	r3,-16(fp)
 323ce78:	18800104 	addi	r2,r3,4
 323ce7c:	e0bffc15 	stw	r2,-16(fp)
 323ce80:	1805883a 	mov	r2,r3
 323ce84:	10800017 	ldw	r2,0(r2)
 323ce88:	e0bffb15 	stw	r2,-20(fp)
    va_end(argp);
    return bsd_ioctl(file, cmd, flags);
 323ce8c:	e17ffe17 	ldw	r5,-8(fp)
 323ce90:	e13ffd17 	ldw	r4,-12(fp)
 323ce94:	e1bffb17 	ldw	r6,-20(fp)
 323ce98:	32254600 	call	3225460 <bsd_ioctl>
 323ce9c:	e0bfff15 	stw	r2,-4(fp)
 323cea0:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 323cea4:	e037883a 	mov	sp,fp
 323cea8:	dfc00117 	ldw	ra,4(sp)
 323ceac:	df000017 	ldw	fp,0(sp)
 323ceb0:	dec00404 	addi	sp,sp,16
 323ceb4:	f800283a 	ret

0323ceb8 <etainit>:
 * RETURNS: int               0 if OK, else nonzero
 */

int
etainit(void)
{
 323ceb8:	defffd04 	addi	sp,sp,-12
 323cebc:	dfc00215 	stw	ra,8(sp)
 323cec0:	df000115 	stw	fp,4(sp)
 323cec4:	df000104 	addi	fp,sp,4
   /* register ARP type with the Net Driver */
   if (reg_type(ET_ARP) != 0)
 323cec8:	01018204 	movi	r4,1544
 323cecc:	323e4bc0 	call	323e4bc <reg_type>
 323ced0:	1005003a 	cmpeq	r2,r2,zero
 323ced4:	1000061e 	bne	r2,zero,323cef0 <etainit+0x38>
   {
#ifdef NPDEBUG
      dprintf("ARP: unable to register type with MAC Driver\n");
 323ced8:	0100c974 	movhi	r4,805
 323cedc:	213e1c04 	addi	r4,r4,-1936
 323cee0:	3206e040 	call	3206e04 <puts>
#endif
      return (1);
 323cee4:	00800044 	movi	r2,1
 323cee8:	e0bfff15 	stw	r2,-4(fp)
 323ceec:	00000106 	br	323cef4 <etainit+0x3c>
   }
   return (0);
 323cef0:	e03fff15 	stw	zero,-4(fp)
 323cef4:	e0bfff17 	ldw	r2,-4(fp)
}
 323cef8:	e037883a 	mov	sp,fp
 323cefc:	dfc00117 	ldw	ra,4(sp)
 323cf00:	df000017 	ldw	fp,0(sp)
 323cf04:	dec00204 	addi	sp,sp,8
 323cf08:	f800283a 	ret

0323cf0c <et_send>:
 * and MIB info in the packet header. 
 */

int
et_send(PACKET pkt, struct arptabent *tp)
{
 323cf0c:	defff904 	addi	sp,sp,-28
 323cf10:	dfc00615 	stw	ra,24(sp)
 323cf14:	df000515 	stw	fp,20(sp)
 323cf18:	df000504 	addi	fp,sp,20
 323cf1c:	e13ffe15 	stw	r4,-8(fp)
 323cf20:	e17fff15 	stw	r5,-4(fp)
   char *ethhdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 323cf24:	e0bffe17 	ldw	r2,-8(fp)
 323cf28:	10800617 	ldw	r2,24(r2)
 323cf2c:	10802717 	ldw	r2,156(r2)
 323cf30:	e0bffc15 	stw	r2,-16(fp)
   int err;

   tp->lasttime = cticks;
 323cf34:	0080c974 	movhi	r2,805
 323cf38:	10925604 	addi	r2,r2,18776
 323cf3c:	10c00017 	ldw	r3,0(r2)
 323cf40:	e0bfff17 	ldw	r2,-4(fp)
 323cf44:	10c00615 	stw	r3,24(r2)
   pkt->nb_prot -= ETHHDR_SIZE;  /* prepare for prepending ethernet header */
 323cf48:	e0bffe17 	ldw	r2,-8(fp)
 323cf4c:	10800317 	ldw	r2,12(r2)
 323cf50:	10fffc04 	addi	r3,r2,-16
 323cf54:	e0bffe17 	ldw	r2,-8(fp)
 323cf58:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen += ETHHDR_SIZE;
 323cf5c:	e0bffe17 	ldw	r2,-8(fp)
 323cf60:	10800417 	ldw	r2,16(r2)
 323cf64:	10c00404 	addi	r3,r2,16
 323cf68:	e0bffe17 	ldw	r2,-8(fp)
 323cf6c:	10c00415 	stw	r3,16(r2)
   ethhdr = pkt->nb_prot + ETHHDR_BIAS;
 323cf70:	e0bffe17 	ldw	r2,-8(fp)
 323cf74:	10800317 	ldw	r2,12(r2)
 323cf78:	10800084 	addi	r2,r2,2
 323cf7c:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(snap, snapdata, 6);
      snap->type = ARPIP;
   }
#endif   /* IEEE_802_3 */

   if (ethhdr < pkt->nb_buff)   /* sanity check pointer */
 323cf80:	e0bffe17 	ldw	r2,-8(fp)
 323cf84:	10c00117 	ldw	r3,4(r2)
 323cf88:	e0bffd17 	ldw	r2,-12(fp)
 323cf8c:	10c0032e 	bgeu	r2,r3,323cf9c <et_send+0x90>
      panic("et_send: prepend");
 323cf90:	0100c974 	movhi	r4,805
 323cf94:	213e2804 	addi	r4,r4,-1888
 323cf98:	3225df00 	call	3225df0 <panic>

   MEMMOVE(ethhdr + ET_DSTOFF, tp->t_phy_addr, 6);  /* set pkt's MAC dst addr */
 323cf9c:	e0bfff17 	ldw	r2,-4(fp)
 323cfa0:	11400104 	addi	r5,r2,4
 323cfa4:	e13ffd17 	ldw	r4,-12(fp)
 323cfa8:	01800184 	movi	r6,6
 323cfac:	320686c0 	call	320686c <memmove>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);  /* MAC src */
 323cfb0:	e0bffd17 	ldw	r2,-12(fp)
 323cfb4:	11000184 	addi	r4,r2,6
 323cfb8:	e0bffc17 	ldw	r2,-16(fp)
 323cfbc:	11400517 	ldw	r5,20(r2)
 323cfc0:	01800184 	movi	r6,6
 323cfc4:	320686c0 	call	320686c <memmove>

   /* nice clean ethernet II header */
   if ((tp->flags & (ET_ETH2|ET_SNAP)) != ET_SNAP)
 323cfc8:	e0bfff17 	ldw	r2,-4(fp)
 323cfcc:	1080070b 	ldhu	r2,28(r2)
 323cfd0:	10bfffcc 	andi	r2,r2,65535
 323cfd4:	108000cc 	andi	r2,r2,3
 323cfd8:	108000a0 	cmpeqi	r2,r2,2
 323cfdc:	1000041e 	bne	r2,zero,323cff0 <et_send+0xe4>
      ET_TYPE_SET(ethhdr, ntohs(ARPIP));
 323cfe0:	e0bffd17 	ldw	r2,-12(fp)
 323cfe4:	10c00304 	addi	r3,r2,12
 323cfe8:	00800204 	movi	r2,8
 323cfec:	18800005 	stb	r2,0(r3)
 323cff0:	e0bffd17 	ldw	r2,-12(fp)
 323cff4:	10800344 	addi	r2,r2,13
 323cff8:	10000005 	stb	zero,0(r2)
      ET_TYPE_SET(ethhdr, len8023);
   }
#endif   /* IEEE_802_3 */

   /* if a packet oriented send exists, use it: */
   if (pkt->net->pkt_send)
 323cffc:	e0bffe17 	ldw	r2,-8(fp)
 323d000:	10800617 	ldw	r2,24(r2)
 323d004:	10800417 	ldw	r2,16(r2)
 323d008:	1005003a 	cmpeq	r2,r2,zero
 323d00c:	1000071e 	bne	r2,zero,323d02c <et_send+0x120>
      err = pkt->net->pkt_send(pkt);   /* send packet to media */
 323d010:	e0bffe17 	ldw	r2,-8(fp)
 323d014:	10800617 	ldw	r2,24(r2)
 323d018:	10800417 	ldw	r2,16(r2)
 323d01c:	e13ffe17 	ldw	r4,-8(fp)
 323d020:	103ee83a 	callr	r2
 323d024:	e0bffb15 	stw	r2,-20(fp)
 323d028:	00001106 	br	323d070 <et_send+0x164>
   else  /* else use older raw_send routine */
   {
      /* sent to media */
      err = pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 323d02c:	e0bffe17 	ldw	r2,-8(fp)
 323d030:	10800617 	ldw	r2,24(r2)
 323d034:	10c00317 	ldw	r3,12(r2)
 323d038:	e0bffe17 	ldw	r2,-8(fp)
 323d03c:	11000617 	ldw	r4,24(r2)
 323d040:	e0bffe17 	ldw	r2,-8(fp)
 323d044:	11400317 	ldw	r5,12(r2)
 323d048:	e0bffe17 	ldw	r2,-8(fp)
 323d04c:	11800417 	ldw	r6,16(r2)
 323d050:	183ee83a 	callr	r3
 323d054:	e0bffb15 	stw	r2,-20(fp)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 323d058:	01000084 	movi	r4,2
 323d05c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(pkt);
 323d060:	e13ffe17 	ldw	r4,-8(fp)
 323d064:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323d068:	01000084 	movi	r4,2
 323d06c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   }

   return (err);
 323d070:	e0bffb17 	ldw	r2,-20(fp)
}
 323d074:	e037883a 	mov	sp,fp
 323d078:	dfc00117 	ldw	ra,4(sp)
 323d07c:	df000017 	ldw	fp,0(sp)
 323d080:	dec00204 	addi	sp,sp,8
 323d084:	f800283a 	ret

0323d088 <arp_free_pending>:
 * and mark the entry "unused".
 */

void
arp_free_pending(struct arptabent *entry)
{
 323d088:	defffb04 	addi	sp,sp,-20
 323d08c:	dfc00415 	stw	ra,16(sp)
 323d090:	df000315 	stw	fp,12(sp)
 323d094:	df000304 	addi	fp,sp,12
 323d098:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt;
   PACKET nextpkt;

   /* entry->pending has the linked list of all pending packets */
   tmppkt = entry->pending;
 323d09c:	e0bfff17 	ldw	r2,-4(fp)
 323d0a0:	10800417 	ldw	r2,16(r2)
 323d0a4:	e0bffe15 	stw	r2,-8(fp)
   entry->pending = (PACKET)NULL;
 323d0a8:	e0bfff17 	ldw	r2,-4(fp)
 323d0ac:	10000415 	stw	zero,16(r2)

   LOCK_NET_RESOURCE(FREEQ_RESID);
 323d0b0:	01000084 	movi	r4,2
 323d0b4:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>

   /* free all pending packets */
   while (tmppkt)
 323d0b8:	00000906 	br	323d0e0 <arp_free_pending+0x58>
   {
      nextpkt = tmppkt->next;        /* save the next packet in list */
 323d0bc:	e0bffe17 	ldw	r2,-8(fp)
 323d0c0:	10800017 	ldw	r2,0(r2)
 323d0c4:	e0bffd15 	stw	r2,-12(fp)
      tmppkt->next = (PACKET)NULL;
 323d0c8:	e0bffe17 	ldw	r2,-8(fp)
 323d0cc:	10000015 	stw	zero,0(r2)
      pk_free(tmppkt);               /* free current packet */
 323d0d0:	e13ffe17 	ldw	r4,-8(fp)
 323d0d4:	322a2dc0 	call	322a2dc <pk_free>
      tmppkt = nextpkt;              /* process the next packet */
 323d0d8:	e0bffd17 	ldw	r2,-12(fp)
 323d0dc:	e0bffe15 	stw	r2,-8(fp)
   entry->pending = (PACKET)NULL;

   LOCK_NET_RESOURCE(FREEQ_RESID);

   /* free all pending packets */
   while (tmppkt)
 323d0e0:	e0bffe17 	ldw	r2,-8(fp)
 323d0e4:	1004c03a 	cmpne	r2,r2,zero
 323d0e8:	103ff41e 	bne	r2,zero,323d0bc <arp_free_pending+0x34>
      tmppkt->next = (PACKET)NULL;
      pk_free(tmppkt);               /* free current packet */
      tmppkt = nextpkt;              /* process the next packet */
   }

   entry->t_pro_addr = 0;     /* mark the entry "unused" */
 323d0ec:	e0bfff17 	ldw	r2,-4(fp)
 323d0f0:	10000015 	stw	zero,0(r2)

   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323d0f4:	01000084 	movi	r4,2
 323d0f8:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
}
 323d0fc:	e037883a 	mov	sp,fp
 323d100:	dfc00117 	ldw	ra,4(sp)
 323d104:	df000017 	ldw	fp,0(sp)
 323d108:	dec00204 	addi	sp,sp,8
 323d10c:	f800283a 	ret

0323d110 <arp_send_pending>:
 * Clear the list (entry->pending) after sending the packets.
 */

void
arp_send_pending(struct arptabent *entry)
{
 323d110:	defffc04 	addi	sp,sp,-16
 323d114:	dfc00315 	stw	ra,12(sp)
 323d118:	df000215 	stw	fp,8(sp)
 323d11c:	df000204 	addi	fp,sp,8
 323d120:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt = entry->pending;
 323d124:	e0bfff17 	ldw	r2,-4(fp)
 323d128:	10800417 	ldw	r2,16(r2)
 323d12c:	e0bffe15 	stw	r2,-8(fp)

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 323d130:	00000906 	br	323d158 <arp_send_pending+0x48>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
 323d134:	e0bffe17 	ldw	r2,-8(fp)
 323d138:	10c00017 	ldw	r3,0(r2)
 323d13c:	e0bfff17 	ldw	r2,-4(fp)
 323d140:	10c00415 	stw	r3,16(r2)
      tmppkt->next = (PACKET)NULL;
 323d144:	e0bffe17 	ldw	r2,-8(fp)
 323d148:	10000015 	stw	zero,0(r2)
      et_send(tmppkt, entry);          /* try send again */
 323d14c:	e13ffe17 	ldw	r4,-8(fp)
 323d150:	e17fff17 	ldw	r5,-4(fp)
 323d154:	323cf0c0 	call	323cf0c <et_send>
   PACKET tmppkt = entry->pending;

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 323d158:	e0bfff17 	ldw	r2,-4(fp)
 323d15c:	10800417 	ldw	r2,16(r2)
 323d160:	e0bffe15 	stw	r2,-8(fp)
 323d164:	e0bffe17 	ldw	r2,-8(fp)
 323d168:	1004c03a 	cmpne	r2,r2,zero
 323d16c:	103ff11e 	bne	r2,zero,323d134 <arp_send_pending+0x24>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
      tmppkt->next = (PACKET)NULL;
      et_send(tmppkt, entry);          /* try send again */
   }
}
 323d170:	e037883a 	mov	sp,fp
 323d174:	dfc00117 	ldw	ra,4(sp)
 323d178:	df000017 	ldw	fp,0(sp)
 323d17c:	dec00204 	addi	sp,sp,8
 323d180:	f800283a 	ret

0323d184 <send_arp>:
 * timeout will eventually free packet. 
 */

int
send_arp(PACKET pkt, ip_addr dest_ip)
{
 323d184:	defff304 	addi	sp,sp,-52
 323d188:	dfc00c15 	stw	ra,48(sp)
 323d18c:	df000b15 	stw	fp,44(sp)
 323d190:	df000b04 	addi	fp,sp,44
 323d194:	e13ffd15 	stw	r4,-12(fp)
 323d198:	e17ffe15 	stw	r5,-8(fp)
   struct arptabent *   oldest;
   char * ethhdr;
   NET net = pkt->net;
 323d19c:	e0bffd17 	ldw	r2,-12(fp)
 323d1a0:	10800617 	ldw	r2,24(r2)
 323d1a4:	e0bff915 	stw	r2,-28(fp)
   struct arp_hdr *  arphdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 323d1a8:	e0bffd17 	ldw	r2,-12(fp)
 323d1ac:	10800617 	ldw	r2,24(r2)
 323d1b0:	10802717 	ldw	r2,156(r2)
 323d1b4:	e0bff715 	stw	r2,-36(fp)
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 323d1b8:	e0bffe17 	ldw	r2,-8(fp)
 323d1bc:	10bfffe0 	cmpeqi	r2,r2,-1
 323d1c0:	10001b1e 	bne	r2,zero,323d230 <send_arp+0xac>
 323d1c4:	e0bff917 	ldw	r2,-28(fp)
 323d1c8:	10800c17 	ldw	r2,48(r2)
 323d1cc:	0086303a 	nor	r3,zero,r2
 323d1d0:	e0bffe17 	ldw	r2,-8(fp)
 323d1d4:	1886703a 	and	r3,r3,r2
 323d1d8:	e0bff917 	ldw	r2,-28(fp)
 323d1dc:	10800c17 	ldw	r2,48(r2)
 323d1e0:	0084303a 	nor	r2,zero,r2
 323d1e4:	18801226 	beq	r3,r2,323d230 <send_arp+0xac>
 323d1e8:	e0bffe17 	ldw	r2,-8(fp)
 323d1ec:	1004d63a 	srli	r2,r2,24
 323d1f0:	10c03fcc 	andi	r3,r2,255
 323d1f4:	e0bffe17 	ldw	r2,-8(fp)
 323d1f8:	1004d23a 	srli	r2,r2,8
 323d1fc:	10bfc00c 	andi	r2,r2,65280
 323d200:	1886b03a 	or	r3,r3,r2
 323d204:	e0bffe17 	ldw	r2,-8(fp)
 323d208:	10bfc00c 	andi	r2,r2,65280
 323d20c:	1004923a 	slli	r2,r2,8
 323d210:	1886b03a 	or	r3,r3,r2
 323d214:	e0bffe17 	ldw	r2,-8(fp)
 323d218:	10803fcc 	andi	r2,r2,255
 323d21c:	1004963a 	slli	r2,r2,24
 323d220:	1884b03a 	or	r2,r3,r2
 323d224:	10fc002c 	andhi	r3,r2,61440
 323d228:	00b80034 	movhi	r2,57344
 323d22c:	1880441e 	bne	r3,r2,323d340 <send_arp+0x1bc>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask))))

#endif /* IP_MULTICAST */
   {
      /* get unused or oldest entry in table */
      oldest = make_arp_entry(dest_ip, pkt->net);
 323d230:	e0bffd17 	ldw	r2,-12(fp)
 323d234:	11400617 	ldw	r5,24(r2)
 323d238:	e13ffe17 	ldw	r4,-8(fp)
 323d23c:	323d7c40 	call	323d7c4 <make_arp_entry>
 323d240:	e0bffb15 	stw	r2,-20(fp)

      /* set MAC destination to ethernet broadcast (all FFs) */
      MEMSET(oldest->t_phy_addr, 0xFF, 6);
 323d244:	e0bffb17 	ldw	r2,-20(fp)
 323d248:	10c00104 	addi	r3,r2,4
 323d24c:	00bfffc4 	movi	r2,-1
 323d250:	18800005 	stb	r2,0(r3)
 323d254:	00bfffc4 	movi	r2,-1
 323d258:	18800045 	stb	r2,1(r3)
 323d25c:	00bfffc4 	movi	r2,-1
 323d260:	18800085 	stb	r2,2(r3)
 323d264:	00bfffc4 	movi	r2,-1
 323d268:	188000c5 	stb	r2,3(r3)
 323d26c:	00bfffc4 	movi	r2,-1
 323d270:	18800105 	stb	r2,4(r3)
 323d274:	00bfffc4 	movi	r2,-1
 323d278:	18800145 	stb	r2,5(r3)
#ifdef IP_MULTICAST
      /* If n_mcastlist routine is defined in the net structure,
         map IP mcast to Ether multicast  */

#ifdef ETHMCAST
      if ((pkt->net->n_mcastlist) && (IN_MULTICAST(ntohl(dest_ip))))
 323d27c:	e0bffd17 	ldw	r2,-12(fp)
 323d280:	10800617 	ldw	r2,24(r2)
 323d284:	10802b17 	ldw	r2,172(r2)
 323d288:	1005003a 	cmpeq	r2,r2,zero
 323d28c:	1000271e 	bne	r2,zero,323d32c <send_arp+0x1a8>
 323d290:	e0bffe17 	ldw	r2,-8(fp)
 323d294:	1004d63a 	srli	r2,r2,24
 323d298:	10c03fcc 	andi	r3,r2,255
 323d29c:	e0bffe17 	ldw	r2,-8(fp)
 323d2a0:	1004d23a 	srli	r2,r2,8
 323d2a4:	10bfc00c 	andi	r2,r2,65280
 323d2a8:	1886b03a 	or	r3,r3,r2
 323d2ac:	e0bffe17 	ldw	r2,-8(fp)
 323d2b0:	10bfc00c 	andi	r2,r2,65280
 323d2b4:	1004923a 	slli	r2,r2,8
 323d2b8:	1886b03a 	or	r3,r3,r2
 323d2bc:	e0bffe17 	ldw	r2,-8(fp)
 323d2c0:	10803fcc 	andi	r2,r2,255
 323d2c4:	1004963a 	slli	r2,r2,24
 323d2c8:	1884b03a 	or	r2,r3,r2
 323d2cc:	10fc002c 	andhi	r3,r2,61440
 323d2d0:	00b80034 	movhi	r2,57344
 323d2d4:	1880151e 	bne	r3,r2,323d32c <send_arp+0x1a8>
      {
         /* If IP mcast to be mapped to Ethernet multicast */
         dest_ip_ptr.l = dest_ip;
 323d2d8:	e0bffe17 	ldw	r2,-8(fp)
 323d2dc:	e0bffc15 	stw	r2,-16(fp)
         oldest->t_phy_addr[0] = 0x01;
 323d2e0:	e0fffb17 	ldw	r3,-20(fp)
 323d2e4:	00800044 	movi	r2,1
 323d2e8:	18800105 	stb	r2,4(r3)
         oldest->t_phy_addr[1] = 0x00;
 323d2ec:	e0bffb17 	ldw	r2,-20(fp)
 323d2f0:	10000145 	stb	zero,5(r2)
         oldest->t_phy_addr[2] = 0x5e;
 323d2f4:	e0fffb17 	ldw	r3,-20(fp)
 323d2f8:	00801784 	movi	r2,94
 323d2fc:	18800185 	stb	r2,6(r3)
         oldest->t_phy_addr[3] = (u_char )(dest_ip_ptr.c[1] & 0x7f);
 323d300:	e0bffc43 	ldbu	r2,-15(fp)
 323d304:	10801fcc 	andi	r2,r2,127
 323d308:	1007883a 	mov	r3,r2
 323d30c:	e0bffb17 	ldw	r2,-20(fp)
 323d310:	10c001c5 	stb	r3,7(r2)
         oldest->t_phy_addr[4] = (u_char )dest_ip_ptr.c[2];
 323d314:	e0fffc83 	ldbu	r3,-14(fp)
 323d318:	e0bffb17 	ldw	r2,-20(fp)
 323d31c:	10c00205 	stb	r3,8(r2)
         oldest->t_phy_addr[5] = (u_char )dest_ip_ptr.c[3];
 323d320:	e0fffcc3 	ldbu	r3,-13(fp)
 323d324:	e0bffb17 	ldw	r2,-20(fp)
 323d328:	10c00245 	stb	r3,9(r2)
      }
#endif /* ETHMCAST */
#endif /* IP_MULTICAST */
      return (et_send(pkt, oldest));
 323d32c:	e13ffd17 	ldw	r4,-12(fp)
 323d330:	e17ffb17 	ldw	r5,-20(fp)
 323d334:	323cf0c0 	call	323cf0c <et_send>
 323d338:	e0bfff15 	stw	r2,-4(fp)
 323d33c:	0000b106 	br	323d604 <send_arp+0x480>

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 323d340:	e0bffd17 	ldw	r2,-12(fp)
 323d344:	10c00717 	ldw	r3,28(r2)
 323d348:	e0bffd17 	ldw	r2,-12(fp)
 323d34c:	10800617 	ldw	r2,24(r2)
 323d350:	10800a17 	ldw	r2,40(r2)
 323d354:	18800e1e 	bne	r3,r2,323d390 <send_arp+0x20c>
 323d358:	e0bffd17 	ldw	r2,-12(fp)
 323d35c:	10800717 	ldw	r2,28(r2)
 323d360:	10803fcc 	andi	r2,r2,255
 323d364:	10801fe0 	cmpeqi	r2,r2,127
 323d368:	1000091e 	bne	r2,zero,323d390 <send_arp+0x20c>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 323d36c:	01000084 	movi	r4,2
 323d370:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(pkt);
 323d374:	e13ffd17 	ldw	r4,-12(fp)
 323d378:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323d37c:	01000084 	movi	r4,2
 323d380:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return ENP_NO_ROUTE;
 323d384:	00bff7c4 	movi	r2,-33
 323d388:	e0bfff15 	stw	r2,-4(fp)
 323d38c:	00009d06 	br	323d604 <send_arp+0x480>
   }

   /* not broadcasting, so get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 323d390:	01000084 	movi	r4,2
 323d394:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 323d398:	01000c04 	movi	r4,48
 323d39c:	3229f480 	call	3229f48 <pk_alloc>
 323d3a0:	e0bff615 	stw	r2,-40(fp)
   if (!arppkt)
 323d3a4:	e0bff617 	ldw	r2,-40(fp)
 323d3a8:	1004c03a 	cmpne	r2,r2,zero
 323d3ac:	1000071e 	bne	r2,zero,323d3cc <send_arp+0x248>
   {
      pk_free(pkt);
 323d3b0:	e13ffd17 	ldw	r4,-12(fp)
 323d3b4:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323d3b8:	01000084 	movi	r4,2
 323d3bc:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 323d3c0:	00bffa84 	movi	r2,-22
 323d3c4:	e0bfff15 	stw	r2,-4(fp)
 323d3c8:	00008e06 	br	323d604 <send_arp+0x480>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323d3cc:	01000084 	movi	r4,2
 323d3d0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 323d3d4:	e0bff617 	ldw	r2,-40(fp)
 323d3d8:	10c00117 	ldw	r3,4(r2)
 323d3dc:	e0bff617 	ldw	r2,-40(fp)
 323d3e0:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 323d3e4:	e0fff617 	ldw	r3,-40(fp)
 323d3e8:	00800c04 	movi	r2,48
 323d3ec:	18800415 	stw	r2,16(r3)
   arppkt->net = pkt->net;
 323d3f0:	e0bffd17 	ldw	r2,-12(fp)
 323d3f4:	10c00617 	ldw	r3,24(r2)
 323d3f8:	e0bff617 	ldw	r2,-40(fp)
 323d3fc:	10c00615 	stw	r3,24(r2)

   /* get unused or oldest entry in table */
   oldest = make_arp_entry(dest_ip, pkt->net);
 323d400:	e0bffd17 	ldw	r2,-12(fp)
 323d404:	11400617 	ldw	r5,24(r2)
 323d408:	e13ffe17 	ldw	r4,-8(fp)
 323d40c:	323d7c40 	call	323d7c4 <make_arp_entry>
 323d410:	e0bffb15 	stw	r2,-20(fp)

   oldest->pending = pkt;           /* packet is "pended", not pk_free()d */
 323d414:	e0fffb17 	ldw	r3,-20(fp)
 323d418:	e0bffd17 	ldw	r2,-12(fp)
 323d41c:	18800415 	stw	r2,16(r3)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 323d420:	e0bff617 	ldw	r2,-40(fp)
 323d424:	10800117 	ldw	r2,4(r2)
 323d428:	10800084 	addi	r2,r2,2
 323d42c:	e0bffa15 	stw	r2,-24(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 323d430:	e0bff617 	ldw	r2,-40(fp)
 323d434:	10800117 	ldw	r2,4(r2)
 323d438:	10800404 	addi	r2,r2,16
 323d43c:	e0bff815 	stw	r2,-32(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 323d440:	e0fff817 	ldw	r3,-32(fp)
 323d444:	00804004 	movi	r2,256
 323d448:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 323d44c:	e0fff817 	ldw	r3,-32(fp)
 323d450:	00800204 	movi	r2,8
 323d454:	1880008d 	sth	r2,2(r3)
   arphdr->ar_hln = 6;
 323d458:	e0fff817 	ldw	r3,-32(fp)
 323d45c:	00800184 	movi	r2,6
 323d460:	18800105 	stb	r2,4(r3)
   arphdr->ar_pln = 4;
 323d464:	e0fff817 	ldw	r3,-32(fp)
 323d468:	00800104 	movi	r2,4
 323d46c:	18800145 	stb	r2,5(r3)
   arphdr->ar_op = ARREQ;
 323d470:	e0fff817 	ldw	r3,-32(fp)
 323d474:	00804004 	movi	r2,256
 323d478:	1880018d 	sth	r2,6(r3)
   arphdr->ar_tpa = dest_ip;        /* target's IP address */
 323d47c:	e0fff817 	ldw	r3,-32(fp)
 323d480:	e0bffe17 	ldw	r2,-8(fp)
 323d484:	18800715 	stw	r2,28(r3)
   arphdr->ar_spa = pkt->net->n_ipaddr;   /* my IP address */
 323d488:	e0bffd17 	ldw	r2,-12(fp)
 323d48c:	10800617 	ldw	r2,24(r2)
 323d490:	10c00a17 	ldw	r3,40(r2)
 323d494:	e0bff817 	ldw	r2,-32(fp)
 323d498:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 323d49c:	e0bff817 	ldw	r2,-32(fp)
 323d4a0:	11000204 	addi	r4,r2,8
 323d4a4:	e0bff717 	ldw	r2,-36(fp)
 323d4a8:	11400517 	ldw	r5,20(r2)
 323d4ac:	01800184 	movi	r6,6
 323d4b0:	320686c0 	call	320686c <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 323d4b4:	e0fffa17 	ldw	r3,-24(fp)
 323d4b8:	00bfffc4 	movi	r2,-1
 323d4bc:	18800005 	stb	r2,0(r3)
 323d4c0:	00bfffc4 	movi	r2,-1
 323d4c4:	18800045 	stb	r2,1(r3)
 323d4c8:	00bfffc4 	movi	r2,-1
 323d4cc:	18800085 	stb	r2,2(r3)
 323d4d0:	00bfffc4 	movi	r2,-1
 323d4d4:	188000c5 	stb	r2,3(r3)
 323d4d8:	00bfffc4 	movi	r2,-1
 323d4dc:	18800105 	stb	r2,4(r3)
 323d4e0:	00bfffc4 	movi	r2,-1
 323d4e4:	18800145 	stb	r2,5(r3)
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 323d4e8:	e0bffa17 	ldw	r2,-24(fp)
 323d4ec:	11000184 	addi	r4,r2,6
 323d4f0:	e0bff717 	ldw	r2,-36(fp)
 323d4f4:	11400517 	ldw	r5,20(r2)
 323d4f8:	01800184 	movi	r6,6
 323d4fc:	320686c0 	call	320686c <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 323d500:	e0bffa17 	ldw	r2,-24(fp)
 323d504:	10c00304 	addi	r3,r2,12
 323d508:	00800204 	movi	r2,8
 323d50c:	18800005 	stb	r2,0(r3)
 323d510:	e0bffa17 	ldw	r2,-24(fp)
 323d514:	10c00344 	addi	r3,r2,13
 323d518:	00800184 	movi	r2,6
 323d51c:	18800005 	stb	r2,0(r3)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 323d520:	e0bff817 	ldw	r2,-32(fp)
 323d524:	e0bff515 	stw	r2,-44(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 323d528:	e0bff517 	ldw	r2,-44(fp)
 323d52c:	11000204 	addi	r4,r2,8
 323d530:	e0bff817 	ldw	r2,-32(fp)
 323d534:	11400204 	addi	r5,r2,8
 323d538:	01800184 	movi	r6,6
 323d53c:	320686c0 	call	320686c <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 323d540:	e0bff517 	ldw	r2,-44(fp)
 323d544:	10800204 	addi	r2,r2,8
 323d548:	11000184 	addi	r4,r2,6
 323d54c:	e0bff817 	ldw	r2,-32(fp)
 323d550:	11400404 	addi	r5,r2,16
 323d554:	01800104 	movi	r6,4
 323d558:	320686c0 	call	320686c <memmove>
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 323d55c:	e0bff517 	ldw	r2,-44(fp)
 323d560:	10800204 	addi	r2,r2,8
 323d564:	11000284 	addi	r4,r2,10
 323d568:	e0bff817 	ldw	r2,-32(fp)
 323d56c:	11400504 	addi	r5,r2,20
 323d570:	01800184 	movi	r6,6
 323d574:	320686c0 	call	320686c <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 323d578:	e0bff517 	ldw	r2,-44(fp)
 323d57c:	10800204 	addi	r2,r2,8
 323d580:	11000404 	addi	r4,r2,16
 323d584:	e0bff817 	ldw	r2,-32(fp)
 323d588:	11400704 	addi	r5,r2,28
 323d58c:	01800104 	movi	r6,4
 323d590:	320686c0 	call	320686c <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 323d594:	e0bff917 	ldw	r2,-28(fp)
 323d598:	10800417 	ldw	r2,16(r2)
 323d59c:	1005003a 	cmpeq	r2,r2,zero
 323d5a0:	1000051e 	bne	r2,zero,323d5b8 <send_arp+0x434>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 323d5a4:	e0bff917 	ldw	r2,-28(fp)
 323d5a8:	10800417 	ldw	r2,16(r2)
 323d5ac:	e13ff617 	ldw	r4,-40(fp)
 323d5b0:	103ee83a 	callr	r2
 323d5b4:	00000e06 	br	323d5f0 <send_arp+0x46c>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 323d5b8:	e0bff917 	ldw	r2,-28(fp)
 323d5bc:	10c00317 	ldw	r3,12(r2)
 323d5c0:	e0bff617 	ldw	r2,-40(fp)
 323d5c4:	11000617 	ldw	r4,24(r2)
 323d5c8:	e0bff617 	ldw	r2,-40(fp)
 323d5cc:	11400117 	ldw	r5,4(r2)
 323d5d0:	01800c04 	movi	r6,48
 323d5d4:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 323d5d8:	01000084 	movi	r4,2
 323d5dc:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 323d5e0:	e13ff617 	ldw	r4,-40(fp)
 323d5e4:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323d5e8:	01000084 	movi	r4,2
 323d5ec:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 323d5f0:	d0a8f917 	ldw	r2,-23580(gp)
 323d5f4:	10800044 	addi	r2,r2,1
 323d5f8:	d0a8f915 	stw	r2,-23580(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 323d5fc:	00800044 	movi	r2,1
 323d600:	e0bfff15 	stw	r2,-4(fp)
 323d604:	e0bfff17 	ldw	r2,-4(fp)
}
 323d608:	e037883a 	mov	sp,fp
 323d60c:	dfc00117 	ldw	ra,4(sp)
 323d610:	df000017 	ldw	fp,0(sp)
 323d614:	dec00204 	addi	sp,sp,8
 323d618:	f800283a 	ret

0323d61c <find_oldest_arp>:
 * Old entries are removed from the table.
 */

struct arptabent * 
find_oldest_arp(ip_addr dest_ip)
{
 323d61c:	defff604 	addi	sp,sp,-40
 323d620:	dfc00915 	stw	ra,36(sp)
 323d624:	df000815 	stw	fp,32(sp)
 323d628:	df000804 	addi	fp,sp,32
 323d62c:	e13ffd15 	stw	r4,-12(fp)
   struct arptabent *tp;
   struct arptabent *exact  = (struct arptabent *)NULL;
 323d630:	e03ffb15 	stw	zero,-20(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
 323d634:	e03ffa15 	stw	zero,-24(fp)
   struct arptabent *empty  = (struct arptabent *)NULL;
 323d638:	e03ff915 	stw	zero,-28(fp)
   unsigned long lticks = cticks;
 323d63c:	0080c974 	movhi	r2,805
 323d640:	10925604 	addi	r2,r2,18776
 323d644:	10800017 	ldw	r2,0(r2)
 323d648:	e0bff815 	stw	r2,-32(fp)

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 323d64c:	0080c9b4 	movhi	r2,806
 323d650:	10b41b04 	addi	r2,r2,-12180
 323d654:	e0bffc15 	stw	r2,-16(fp)
 323d658:	00004006 	br	323d75c <find_oldest_arp+0x140>
   {
      /* age out old, pending entries */
      if (tp->pending)
 323d65c:	e0bffc17 	ldw	r2,-16(fp)
 323d660:	10800417 	ldw	r2,16(r2)
 323d664:	1005003a 	cmpeq	r2,r2,zero
 323d668:	10000b1e 	bne	r2,zero,323d698 <find_oldest_arp+0x7c>
      {
         /* purge if pending for more than one second */
         if ((lticks - tp->createtime) > TPS)
 323d66c:	e0bffc17 	ldw	r2,-16(fp)
 323d670:	10c00517 	ldw	r3,20(r2)
 323d674:	e0bff817 	ldw	r2,-32(fp)
 323d678:	10c5c83a 	sub	r2,r2,r3
 323d67c:	1080fa70 	cmpltui	r2,r2,1001
 323d680:	1000181e 	bne	r2,zero,323d6e4 <find_oldest_arp+0xc8>
         {
            arp_free_pending(tp);   /* free pending packets */
 323d684:	e13ffc17 	ldw	r4,-16(fp)
 323d688:	323d0880 	call	323d088 <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 323d68c:	e0bffc17 	ldw	r2,-16(fp)
 323d690:	10000015 	stw	zero,0(r2)
 323d694:	00001306 	br	323d6e4 <find_oldest_arp+0xc8>
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 323d698:	e0bffc17 	ldw	r2,-16(fp)
 323d69c:	10800017 	ldw	r2,0(r2)
 323d6a0:	1005003a 	cmpeq	r2,r2,zero
 323d6a4:	10000f1e 	bne	r2,zero,323d6e4 <find_oldest_arp+0xc8>
 323d6a8:	e0bffc17 	ldw	r2,-16(fp)
 323d6ac:	10c00517 	ldw	r3,20(r2)
 323d6b0:	e0bff817 	ldw	r2,-32(fp)
 323d6b4:	10c5c83a 	sub	r2,r2,r3
 323d6b8:	1007883a 	mov	r3,r2
 323d6bc:	d0a04b17 	ldw	r2,-32468(gp)
 323d6c0:	18800816 	blt	r3,r2,323d6e4 <find_oldest_arp+0xc8>
 323d6c4:	e0bffc17 	ldw	r2,-16(fp)
 323d6c8:	10c00617 	ldw	r3,24(r2)
 323d6cc:	e0bff817 	ldw	r2,-32(fp)
 323d6d0:	10c5c83a 	sub	r2,r2,r3
 323d6d4:	1080fa30 	cmpltui	r2,r2,1000
 323d6d8:	1000021e 	bne	r2,zero,323d6e4 <find_oldest_arp+0xc8>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
               ((int)(lticks - tp->lasttime)   >= TPS))
      {
         /* entry has "expired" and has not been reference in 1 sec. */
         tp->t_pro_addr = 0;     /* mark entry as "unused" */
 323d6dc:	e0bffc17 	ldw	r2,-16(fp)
 323d6e0:	10000015 	stw	zero,0(r2)
      }

      if (tp->t_pro_addr == dest_ip)   /* ip addr already has entry */
 323d6e4:	e0bffc17 	ldw	r2,-16(fp)
 323d6e8:	10c00017 	ldw	r3,0(r2)
 323d6ec:	e0bffd17 	ldw	r2,-12(fp)
 323d6f0:	1880031e 	bne	r3,r2,323d700 <find_oldest_arp+0xe4>
      {
         exact = tp;
 323d6f4:	e0bffc17 	ldw	r2,-16(fp)
 323d6f8:	e0bffb15 	stw	r2,-20(fp)
 323d6fc:	00001406 	br	323d750 <find_oldest_arp+0x134>
      }
      else if (tp->t_pro_addr != 0)
 323d700:	e0bffc17 	ldw	r2,-16(fp)
 323d704:	10800017 	ldw	r2,0(r2)
 323d708:	1005003a 	cmpeq	r2,r2,zero
 323d70c:	10000b1e 	bne	r2,zero,323d73c <find_oldest_arp+0x120>
      {
         if (!oldest || (tp->lasttime < oldest->lasttime))
 323d710:	e0bffa17 	ldw	r2,-24(fp)
 323d714:	1005003a 	cmpeq	r2,r2,zero
 323d718:	1000051e 	bne	r2,zero,323d730 <find_oldest_arp+0x114>
 323d71c:	e0bffc17 	ldw	r2,-16(fp)
 323d720:	10c00617 	ldw	r3,24(r2)
 323d724:	e0bffa17 	ldw	r2,-24(fp)
 323d728:	10800617 	ldw	r2,24(r2)
 323d72c:	1880082e 	bgeu	r3,r2,323d750 <find_oldest_arp+0x134>
            oldest = tp;
 323d730:	e0bffc17 	ldw	r2,-16(fp)
 323d734:	e0bffa15 	stw	r2,-24(fp)
 323d738:	00000506 	br	323d750 <find_oldest_arp+0x134>
      }
      else if (!empty)
 323d73c:	e0bff917 	ldw	r2,-28(fp)
 323d740:	1004c03a 	cmpne	r2,r2,zero
 323d744:	1000021e 	bne	r2,zero,323d750 <find_oldest_arp+0x134>
         empty = tp;          /* grab first empty slot */
 323d748:	e0bffc17 	ldw	r2,-16(fp)
 323d74c:	e0bff915 	stw	r2,-28(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
   struct arptabent *empty  = (struct arptabent *)NULL;
   unsigned long lticks = cticks;

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 323d750:	e0bffc17 	ldw	r2,-16(fp)
 323d754:	10800804 	addi	r2,r2,32
 323d758:	e0bffc15 	stw	r2,-16(fp)
 323d75c:	00c0c9b4 	movhi	r3,806
 323d760:	18f45b04 	addi	r3,r3,-11924
 323d764:	e0bffc17 	ldw	r2,-16(fp)
 323d768:	10ffbc36 	bltu	r2,r3,323d65c <find_oldest_arp+0x40>
      }
      else if (!empty)
         empty = tp;          /* grab first empty slot */
   }

   return ((exact) ? exact : ((empty) ? empty : oldest));
 323d76c:	e0bffb17 	ldw	r2,-20(fp)
 323d770:	1004c03a 	cmpne	r2,r2,zero
 323d774:	10000b1e 	bne	r2,zero,323d7a4 <find_oldest_arp+0x188>
 323d778:	e0bff917 	ldw	r2,-28(fp)
 323d77c:	1005003a 	cmpeq	r2,r2,zero
 323d780:	1000031e 	bne	r2,zero,323d790 <find_oldest_arp+0x174>
 323d784:	e0bff917 	ldw	r2,-28(fp)
 323d788:	e0bffe15 	stw	r2,-8(fp)
 323d78c:	00000206 	br	323d798 <find_oldest_arp+0x17c>
 323d790:	e0bffa17 	ldw	r2,-24(fp)
 323d794:	e0bffe15 	stw	r2,-8(fp)
 323d798:	e0bffe17 	ldw	r2,-8(fp)
 323d79c:	e0bfff15 	stw	r2,-4(fp)
 323d7a0:	00000206 	br	323d7ac <find_oldest_arp+0x190>
 323d7a4:	e0bffb17 	ldw	r2,-20(fp)
 323d7a8:	e0bfff15 	stw	r2,-4(fp)
 323d7ac:	e0bfff17 	ldw	r2,-4(fp)
}
 323d7b0:	e037883a 	mov	sp,fp
 323d7b4:	dfc00117 	ldw	ra,4(sp)
 323d7b8:	df000017 	ldw	fp,0(sp)
 323d7bc:	dec00204 	addi	sp,sp,8
 323d7c0:	f800283a 	ret

0323d7c4 <make_arp_entry>:
 * active.
 */

struct arptabent *   
make_arp_entry(ip_addr dest_ip, NET net)
{
 323d7c4:	defffa04 	addi	sp,sp,-24
 323d7c8:	dfc00515 	stw	ra,20(sp)
 323d7cc:	df000415 	stw	fp,16(sp)
 323d7d0:	df000404 	addi	fp,sp,16
 323d7d4:	e13ffe15 	stw	r4,-8(fp)
 323d7d8:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *oldest;
   unsigned long lticks = cticks;
 323d7dc:	0080c974 	movhi	r2,805
 323d7e0:	10925604 	addi	r2,r2,18776
 323d7e4:	10800017 	ldw	r2,0(r2)
 323d7e8:	e0bffc15 	stw	r2,-16(fp)

   /* find usable (or existing) ARP table entry */
   oldest = find_oldest_arp(dest_ip);
 323d7ec:	e13ffe17 	ldw	r4,-8(fp)
 323d7f0:	323d61c0 	call	323d61c <find_oldest_arp>
 323d7f4:	e0bffd15 	stw	r2,-12(fp)

   /* If recycling entry, don't leak packets which may be stuck here */
   if (oldest->pending && (oldest->t_pro_addr != dest_ip))
 323d7f8:	e0bffd17 	ldw	r2,-12(fp)
 323d7fc:	10800417 	ldw	r2,16(r2)
 323d800:	1005003a 	cmpeq	r2,r2,zero
 323d804:	1000061e 	bne	r2,zero,323d820 <make_arp_entry+0x5c>
 323d808:	e0bffd17 	ldw	r2,-12(fp)
 323d80c:	10c00017 	ldw	r3,0(r2)
 323d810:	e0bffe17 	ldw	r2,-8(fp)
 323d814:	18800226 	beq	r3,r2,323d820 <make_arp_entry+0x5c>
   {
      arp_free_pending(oldest);
 323d818:	e13ffd17 	ldw	r4,-12(fp)
 323d81c:	323d0880 	call	323d088 <arp_free_pending>
   }

   /* partially fill in arp entry */
   oldest->t_pro_addr = dest_ip;
 323d820:	e0fffd17 	ldw	r3,-12(fp)
 323d824:	e0bffe17 	ldw	r2,-8(fp)
 323d828:	18800015 	stw	r2,0(r3)
   oldest->net = net;
 323d82c:	e0fffd17 	ldw	r3,-12(fp)
 323d830:	e0bfff17 	ldw	r2,-4(fp)
 323d834:	18800315 	stw	r2,12(r3)
   oldest->flags = 0;
 323d838:	e0bffd17 	ldw	r2,-12(fp)
 323d83c:	1000070d 	sth	zero,28(r2)
   MEMSET(oldest->t_phy_addr, '\0', 6);   /* clear mac address */
 323d840:	e0bffd17 	ldw	r2,-12(fp)
 323d844:	10800104 	addi	r2,r2,4
 323d848:	10000005 	stb	zero,0(r2)
 323d84c:	10000045 	stb	zero,1(r2)
 323d850:	10000085 	stb	zero,2(r2)
 323d854:	100000c5 	stb	zero,3(r2)
 323d858:	10000105 	stb	zero,4(r2)
 323d85c:	10000145 	stb	zero,5(r2)
   oldest->createtime = oldest->lasttime = lticks;
 323d860:	e0fffd17 	ldw	r3,-12(fp)
 323d864:	e0bffc17 	ldw	r2,-16(fp)
 323d868:	18800615 	stw	r2,24(r3)
 323d86c:	e0bffd17 	ldw	r2,-12(fp)
 323d870:	10c00617 	ldw	r3,24(r2)
 323d874:	e0bffd17 	ldw	r2,-12(fp)
 323d878:	10c00515 	stw	r3,20(r2)

   /* start a ARP timer if there isn't one already */
   /* update the timeout value if there is a timer */
   /* time is specified in milliseconds */
   if (arp_timer == 0)
 323d87c:	d0a8f617 	ldw	r2,-23592(gp)
 323d880:	1004c03a 	cmpne	r2,r2,zero
 323d884:	1000071e 	bne	r2,zero,323d8a4 <make_arp_entry+0xe0>
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
 323d888:	0100c934 	movhi	r4,804
 323d88c:	2137dd04 	addi	r4,r4,-8332
 323d890:	0149c404 	movi	r5,10000
 323d894:	000d883a 	mov	r6,zero
 323d898:	323cb400 	call	323cb40 <in_timerset>
 323d89c:	d0a8f615 	stw	r2,-23592(gp)
 323d8a0:	00000706 	br	323d8c0 <make_arp_entry+0xfc>
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 323d8a4:	d0a8f617 	ldw	r2,-23592(gp)
 323d8a8:	1009883a 	mov	r4,r2
 323d8ac:	d0a8f617 	ldw	r2,-23592(gp)
 323d8b0:	10c00217 	ldw	r3,8(r2)
 323d8b4:	e0bffc17 	ldw	r2,-16(fp)
 323d8b8:	1885883a 	add	r2,r3,r2
 323d8bc:	20800315 	stw	r2,12(r4)
              ((struct intimer *)arp_timer)->interval + lticks;
   }

   return oldest;
 323d8c0:	e0bffd17 	ldw	r2,-12(fp)
}
 323d8c4:	e037883a 	mov	sp,fp
 323d8c8:	dfc00117 	ldw	ra,4(sp)
 323d8cc:	df000017 	ldw	fp,0(sp)
 323d8d0:	dec00204 	addi	sp,sp,8
 323d8d4:	f800283a 	ret

0323d8d8 <arpReply>:
 * must be freed (or reused) herein. 
 */

void
arpReply(PACKET pkt)
{
 323d8d8:	defff704 	addi	sp,sp,-36
 323d8dc:	dfc00815 	stw	ra,32(sp)
 323d8e0:	df000715 	stw	fp,28(sp)
 323d8e4:	df000704 	addi	fp,sp,28
 323d8e8:	e13fff15 	stw	r4,-4(fp)
   struct arp_hdr *in;
   struct arp_hdr *out;
   char *ethout;
   char *ethin;

   LOCK_NET_RESOURCE(FREEQ_RESID);
 323d8ec:	01000084 	movi	r4,2
 323d8f0:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   outpkt = pk_alloc(arpsize);
 323d8f4:	01000c04 	movi	r4,48
 323d8f8:	3229f480 	call	3229f48 <pk_alloc>
 323d8fc:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323d900:	01000084 	movi	r4,2
 323d904:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   if (!outpkt)
 323d908:	e0bffe17 	ldw	r2,-8(fp)
 323d90c:	1004c03a 	cmpne	r2,r2,zero
 323d910:	1000021e 	bne	r2,zero,323d91c <arpReply+0x44>
   {
      dtrap();
 323d914:	322ab8c0 	call	322ab8c <dtrap>
      return;
 323d918:	00008f06 	br	323db58 <arpReply+0x280>
   }

   outpkt->net = pkt->net;    /* send back out the iface it came from */
 323d91c:	e0bfff17 	ldw	r2,-4(fp)
 323d920:	10c00617 	ldw	r3,24(r2)
 323d924:	e0bffe17 	ldw	r2,-8(fp)
 323d928:	10c00615 	stw	r3,24(r2)

   ethin = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 323d92c:	e0bfff17 	ldw	r2,-4(fp)
 323d930:	10800317 	ldw	r2,12(r2)
 323d934:	10bffc84 	addi	r2,r2,-14
 323d938:	e0bffa15 	stw	r2,-24(fp)
   ethout = outpkt->nb_buff + ETHHDR_BIAS;
 323d93c:	e0bffe17 	ldw	r2,-8(fp)
 323d940:	10800117 	ldw	r2,4(r2)
 323d944:	10800084 	addi	r2,r2,2
 323d948:	e0bffb15 	stw	r2,-20(fp)
      snap->type = ET_ARP;
   }
   else
#endif   /* IEEE_802_3 */
   {
      ET_TYPE_SET(ethout, ntohs(ET_ARP));   /* 0x0806 - ARP type on ethernet */
 323d94c:	e0bffb17 	ldw	r2,-20(fp)
 323d950:	10c00304 	addi	r3,r2,12
 323d954:	00800204 	movi	r2,8
 323d958:	18800005 	stb	r2,0(r3)
 323d95c:	e0bffb17 	ldw	r2,-20(fp)
 323d960:	10c00344 	addi	r3,r2,13
 323d964:	00800184 	movi	r2,6
 323d968:	18800005 	stb	r2,0(r3)
      in = (struct arp_hdr *)(pkt->nb_prot);
 323d96c:	e0bfff17 	ldw	r2,-4(fp)
 323d970:	10800317 	ldw	r2,12(r2)
 323d974:	e0bffd15 	stw	r2,-12(fp)
      out = (struct arp_hdr *)(outpkt->nb_buff + ETHHDR_SIZE);
 323d978:	e0bffe17 	ldw	r2,-8(fp)
 323d97c:	10800117 	ldw	r2,4(r2)
 323d980:	10800404 	addi	r2,r2,16
 323d984:	e0bffc15 	stw	r2,-16(fp)
      outpkt->nb_plen = arpsize;
 323d988:	e0fffe17 	ldw	r3,-8(fp)
 323d98c:	00800c04 	movi	r2,48
 323d990:	18800415 	stw	r2,16(r3)

   /* prepare outgoing arp packet */
#ifdef IEEE_802_3
   out->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   out->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 323d994:	e0fffc17 	ldw	r3,-16(fp)
 323d998:	00804004 	movi	r2,256
 323d99c:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   out->ar_pro = ARPIP;
 323d9a0:	e0fffc17 	ldw	r3,-16(fp)
 323d9a4:	00800204 	movi	r2,8
 323d9a8:	1880008d 	sth	r2,2(r3)
   out->ar_hln = 6;
 323d9ac:	e0fffc17 	ldw	r3,-16(fp)
 323d9b0:	00800184 	movi	r2,6
 323d9b4:	18800105 	stb	r2,4(r3)
   out->ar_pln = 4;
 323d9b8:	e0fffc17 	ldw	r3,-16(fp)
 323d9bc:	00800104 	movi	r2,4
 323d9c0:	18800145 	stb	r2,5(r3)
   out->ar_op = ARREP;
 323d9c4:	e0fffc17 	ldw	r3,-16(fp)
 323d9c8:	00808004 	movi	r2,512
 323d9cc:	1880018d 	sth	r2,6(r3)
   out->ar_tpa = in->ar_spa;     /* swap IP addresses */
 323d9d0:	e0bffd17 	ldw	r2,-12(fp)
 323d9d4:	10c00417 	ldw	r3,16(r2)
 323d9d8:	e0bffc17 	ldw	r2,-16(fp)
 323d9dc:	10c00715 	stw	r3,28(r2)
   out->ar_spa = in->ar_tpa;
 323d9e0:	e0bffd17 	ldw	r2,-12(fp)
 323d9e4:	10c00717 	ldw	r3,28(r2)
 323d9e8:	e0bffc17 	ldw	r2,-16(fp)
 323d9ec:	10c00415 	stw	r3,16(r2)
   MEMMOVE(out->ar_tha, in->ar_sha, 6);    /* move his MAC address */
 323d9f0:	e0bffc17 	ldw	r2,-16(fp)
 323d9f4:	11000504 	addi	r4,r2,20
 323d9f8:	e0bffd17 	ldw	r2,-12(fp)
 323d9fc:	11400204 	addi	r5,r2,8
 323da00:	01800184 	movi	r6,6
 323da04:	320686c0 	call	320686c <memmove>
   MEMMOVE(out->ar_sha, outpkt->net->n_mib->ifPhysAddress, 6);  /* fill in our mac address */
 323da08:	e0bffc17 	ldw	r2,-16(fp)
 323da0c:	11000204 	addi	r4,r2,8
 323da10:	e0bffe17 	ldw	r2,-8(fp)
 323da14:	10800617 	ldw	r2,24(r2)
 323da18:	10802717 	ldw	r2,156(r2)
 323da1c:	11400517 	ldw	r5,20(r2)
 323da20:	01800184 	movi	r6,6
 323da24:	320686c0 	call	320686c <memmove>

   /* prepend ethernet unicast header to arp reply */
   MEMMOVE(ethout + ET_DSTOFF, ethin + ET_SRCOFF, 6);
 323da28:	e0bffa17 	ldw	r2,-24(fp)
 323da2c:	11400184 	addi	r5,r2,6
 323da30:	e13ffb17 	ldw	r4,-20(fp)
 323da34:	01800184 	movi	r6,6
 323da38:	320686c0 	call	320686c <memmove>
   MEMMOVE(ethout + ET_SRCOFF, outpkt->net->n_mib->ifPhysAddress, 6);
 323da3c:	e0bffb17 	ldw	r2,-20(fp)
 323da40:	11000184 	addi	r4,r2,6
 323da44:	e0bffe17 	ldw	r2,-8(fp)
 323da48:	10800617 	ldw	r2,24(r2)
 323da4c:	10802717 	ldw	r2,156(r2)
 323da50:	11400517 	ldw	r5,20(r2)
 323da54:	01800184 	movi	r6,6
 323da58:	320686c0 	call	320686c <memmove>

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)out;
 323da5c:	e0bffc17 	ldw	r2,-16(fp)
 323da60:	e0bff915 	stw	r2,-28(fp)
      MEMMOVE(&arwp->data[AR_SHA], out->ar_sha, 6);
 323da64:	e0bff917 	ldw	r2,-28(fp)
 323da68:	11000204 	addi	r4,r2,8
 323da6c:	e0bffc17 	ldw	r2,-16(fp)
 323da70:	11400204 	addi	r5,r2,8
 323da74:	01800184 	movi	r6,6
 323da78:	320686c0 	call	320686c <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &out->ar_spa, 4);
 323da7c:	e0bff917 	ldw	r2,-28(fp)
 323da80:	10800204 	addi	r2,r2,8
 323da84:	11000184 	addi	r4,r2,6
 323da88:	e0bffc17 	ldw	r2,-16(fp)
 323da8c:	11400404 	addi	r5,r2,16
 323da90:	01800104 	movi	r6,4
 323da94:	320686c0 	call	320686c <memmove>
      MEMMOVE(&arwp->data[AR_THA], out->ar_tha, 6);
 323da98:	e0bff917 	ldw	r2,-28(fp)
 323da9c:	10800204 	addi	r2,r2,8
 323daa0:	11000284 	addi	r4,r2,10
 323daa4:	e0bffc17 	ldw	r2,-16(fp)
 323daa8:	11400504 	addi	r5,r2,20
 323daac:	01800184 	movi	r6,6
 323dab0:	320686c0 	call	320686c <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &out->ar_tpa, 4);
 323dab4:	e0bff917 	ldw	r2,-28(fp)
 323dab8:	10800204 	addi	r2,r2,8
 323dabc:	11000404 	addi	r4,r2,16
 323dac0:	e0bffc17 	ldw	r2,-16(fp)
 323dac4:	11400704 	addi	r5,r2,28
 323dac8:	01800104 	movi	r6,4
 323dacc:	320686c0 	call	320686c <memmove>
   }
#endif   /* NO_CC_PACKING */

   /* if a packet oriented send exists, use it: */
   if (outpkt->net->pkt_send)
 323dad0:	e0bffe17 	ldw	r2,-8(fp)
 323dad4:	10800617 	ldw	r2,24(r2)
 323dad8:	10800417 	ldw	r2,16(r2)
 323dadc:	1005003a 	cmpeq	r2,r2,zero
 323dae0:	10000a1e 	bne	r2,zero,323db0c <arpReply+0x234>
   {
      outpkt->nb_prot = outpkt->nb_buff;
 323dae4:	e0bffe17 	ldw	r2,-8(fp)
 323dae8:	10c00117 	ldw	r3,4(r2)
 323daec:	e0bffe17 	ldw	r2,-8(fp)
 323daf0:	10c00315 	stw	r3,12(r2)
      outpkt->net->pkt_send(outpkt);
 323daf4:	e0bffe17 	ldw	r2,-8(fp)
 323daf8:	10800617 	ldw	r2,24(r2)
 323dafc:	10800417 	ldw	r2,16(r2)
 323db00:	e13ffe17 	ldw	r4,-8(fp)
 323db04:	103ee83a 	callr	r2
 323db08:	00001006 	br	323db4c <arpReply+0x274>
   }
   else
   {
      outpkt->net->raw_send(pkt->net, outpkt->nb_buff, outpkt->nb_plen);
 323db0c:	e0bffe17 	ldw	r2,-8(fp)
 323db10:	10800617 	ldw	r2,24(r2)
 323db14:	10c00317 	ldw	r3,12(r2)
 323db18:	e0bfff17 	ldw	r2,-4(fp)
 323db1c:	11000617 	ldw	r4,24(r2)
 323db20:	e0bffe17 	ldw	r2,-8(fp)
 323db24:	11400117 	ldw	r5,4(r2)
 323db28:	e0bffe17 	ldw	r2,-8(fp)
 323db2c:	11800417 	ldw	r6,16(r2)
 323db30:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 323db34:	01000084 	movi	r4,2
 323db38:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(outpkt);
 323db3c:	e13ffe17 	ldw	r4,-8(fp)
 323db40:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323db44:	01000084 	movi	r4,2
 323db48:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   }
   /* input 'pkt' will be freed by caller */
   arpRepsOut++;
 323db4c:	d0a8fb17 	ldw	r2,-23572(gp)
 323db50:	10800044 	addi	r2,r2,1
 323db54:	d0a8fb15 	stw	r2,-23572(gp)
}
 323db58:	e037883a 	mov	sp,fp
 323db5c:	dfc00117 	ldw	ra,4(sp)
 323db60:	df000017 	ldw	fp,0(sp)
 323db64:	dec00204 	addi	sp,sp,8
 323db68:	f800283a 	ret

0323db6c <arprcv>:
 *                            else a negative error code. 
 */

int
arprcv(PACKET pkt)
{
 323db6c:	defff804 	addi	sp,sp,-32
 323db70:	dfc00715 	stw	ra,28(sp)
 323db74:	df000615 	stw	fp,24(sp)
 323db78:	df000604 	addi	fp,sp,24
 323db7c:	e13ffe15 	stw	r4,-8(fp)
   char *eth;
#ifdef IEEE_802_3
   int      ieee = FALSE;     /* TRUE if received packet is 802.3 */
#endif

   eth = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 323db80:	e0bffe17 	ldw	r2,-8(fp)
 323db84:	10800317 	ldw	r2,12(r2)
 323db88:	10bffc84 	addi	r2,r2,-14
 323db8c:	e0bffb15 	stw	r2,-20(fp)
   arphdr = (struct arp_hdr *)(pkt->nb_prot);
 323db90:	e0bffe17 	ldw	r2,-8(fp)
 323db94:	10800317 	ldw	r2,12(r2)
 323db98:	e0bffd15 	stw	r2,-12(fp)
#endif   /* IEEE_802_3_ONLY */
#endif   /* IEEE_802_3 */

#ifdef NO_CC_PACKING    /* force ARP fields to local CPU valid boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 323db9c:	e0bffd17 	ldw	r2,-12(fp)
 323dba0:	e0bffa15 	stw	r2,-24(fp)
      MEMMOVE(&arphdr->ar_tpa, &arwp->data[AR_TPA], 4);
 323dba4:	e0bffd17 	ldw	r2,-12(fp)
 323dba8:	11000704 	addi	r4,r2,28
 323dbac:	e0bffa17 	ldw	r2,-24(fp)
 323dbb0:	10800204 	addi	r2,r2,8
 323dbb4:	11400404 	addi	r5,r2,16
 323dbb8:	01800104 	movi	r6,4
 323dbbc:	320686c0 	call	320686c <memmove>
      MEMMOVE(arphdr->ar_tha, &arwp->data[AR_THA], 6);
 323dbc0:	e0bffd17 	ldw	r2,-12(fp)
 323dbc4:	11000504 	addi	r4,r2,20
 323dbc8:	e0bffa17 	ldw	r2,-24(fp)
 323dbcc:	10800204 	addi	r2,r2,8
 323dbd0:	11400284 	addi	r5,r2,10
 323dbd4:	01800184 	movi	r6,6
 323dbd8:	320686c0 	call	320686c <memmove>
      MEMMOVE(&arphdr->ar_spa, &arwp->data[AR_SPA], 4);
 323dbdc:	e0bffd17 	ldw	r2,-12(fp)
 323dbe0:	11000404 	addi	r4,r2,16
 323dbe4:	e0bffa17 	ldw	r2,-24(fp)
 323dbe8:	10800204 	addi	r2,r2,8
 323dbec:	11400184 	addi	r5,r2,6
 323dbf0:	01800104 	movi	r6,4
 323dbf4:	320686c0 	call	320686c <memmove>
      MEMMOVE(arphdr->ar_sha, &arwp->data[AR_SHA], 6);
 323dbf8:	e0bffd17 	ldw	r2,-12(fp)
 323dbfc:	11000204 	addi	r4,r2,8
 323dc00:	e0bffa17 	ldw	r2,-24(fp)
 323dc04:	11400204 	addi	r5,r2,8
 323dc08:	01800184 	movi	r6,6
 323dc0c:	320686c0 	call	320686c <memmove>
   }
#endif

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 323dc10:	e0bffd17 	ldw	r2,-12(fp)
 323dc14:	10c00717 	ldw	r3,28(r2)
 323dc18:	e0bffe17 	ldw	r2,-8(fp)
 323dc1c:	10800617 	ldw	r2,24(r2)
 323dc20:	10800a17 	ldw	r2,40(r2)
 323dc24:	18801f26 	beq	r3,r2,323dca4 <arprcv+0x138>
 323dc28:	e0bffd17 	ldw	r2,-12(fp)
 323dc2c:	10800717 	ldw	r2,28(r2)
 323dc30:	1004d63a 	srli	r2,r2,24
 323dc34:	10c03fcc 	andi	r3,r2,255
 323dc38:	e0bffd17 	ldw	r2,-12(fp)
 323dc3c:	10800717 	ldw	r2,28(r2)
 323dc40:	1004d23a 	srli	r2,r2,8
 323dc44:	10bfc00c 	andi	r2,r2,65280
 323dc48:	1886b03a 	or	r3,r3,r2
 323dc4c:	e0bffd17 	ldw	r2,-12(fp)
 323dc50:	10800717 	ldw	r2,28(r2)
 323dc54:	10bfc00c 	andi	r2,r2,65280
 323dc58:	1004923a 	slli	r2,r2,8
 323dc5c:	1886b03a 	or	r3,r3,r2
 323dc60:	e0bffd17 	ldw	r2,-12(fp)
 323dc64:	10800717 	ldw	r2,28(r2)
 323dc68:	10803fcc 	andi	r2,r2,255
 323dc6c:	1004963a 	slli	r2,r2,24
 323dc70:	1884b03a 	or	r2,r3,r2
 323dc74:	10fc002c 	andhi	r3,r2,61440
 323dc78:	00b80034 	movhi	r2,57344
 323dc7c:	18800926 	beq	r3,r2,323dca4 <arprcv+0x138>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
#else
   if (arphdr->ar_tpa != pkt->net->n_ipaddr)
#endif /* IP_MULTICAST */
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 323dc80:	01000084 	movi	r4,2
 323dc84:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(pkt);     /* not for us, dump & ret (proxy here later?) */
 323dc88:	e13ffe17 	ldw	r4,-8(fp)
 323dc8c:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323dc90:	01000084 	movi	r4,2
 323dc94:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return (ENP_NOT_MINE);
 323dc98:	00800084 	movi	r2,2
 323dc9c:	e0bfff15 	stw	r2,-4(fp)
 323dca0:	00004406 	br	323ddb4 <arprcv+0x248>
   }

   if (arphdr->ar_op == ARREQ)   /* is it an arp request? */
 323dca4:	e0bffd17 	ldw	r2,-12(fp)
 323dca8:	1080018b 	ldhu	r2,6(r2)
 323dcac:	10bfffcc 	andi	r2,r2,65535
 323dcb0:	10804018 	cmpnei	r2,r2,256
 323dcb4:	10000b1e 	bne	r2,zero,323dce4 <arprcv+0x178>
   {
      arpReqsIn++;   /* count these */
 323dcb8:	d0a8f817 	ldw	r2,-23584(gp)
 323dcbc:	10800044 	addi	r2,r2,1
 323dcc0:	d0a8f815 	stw	r2,-23584(gp)
      arpReply(pkt); /* send arp reply */
 323dcc4:	e13ffe17 	ldw	r4,-8(fp)
 323dcc8:	323d8d80 	call	323d8d8 <arpReply>
      /* make partial ARP table entry */
      make_arp_entry(arphdr->ar_spa, pkt->net);
 323dccc:	e0bffd17 	ldw	r2,-12(fp)
 323dcd0:	11000417 	ldw	r4,16(r2)
 323dcd4:	e0bffe17 	ldw	r2,-8(fp)
 323dcd8:	11400617 	ldw	r5,24(r2)
 323dcdc:	323d7c40 	call	323d7c4 <make_arp_entry>
 323dce0:	00000306 	br	323dcf0 <arprcv+0x184>
      /* fall thru to arp reply logic to finish our table entry */
   }
   else     /* ARP reply, count and fall thru to logic to update table */
   {
      arpRepsIn++;
 323dce4:	d0a8fa17 	ldw	r2,-23576(gp)
 323dce8:	10800044 	addi	r2,r2,1
 323dcec:	d0a8fa15 	stw	r2,-23576(gp)
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 323dcf0:	0080c9b4 	movhi	r2,806
 323dcf4:	10b41b04 	addi	r2,r2,-12180
 323dcf8:	e0bffc15 	stw	r2,-16(fp)
 323dcfc:	00002106 	br	323dd84 <arprcv+0x218>
   {
      if (tp->t_pro_addr == arphdr->ar_spa)     /* we found IP address, update entry */
 323dd00:	e0bffc17 	ldw	r2,-16(fp)
 323dd04:	10c00017 	ldw	r3,0(r2)
 323dd08:	e0bffd17 	ldw	r2,-12(fp)
 323dd0c:	10800417 	ldw	r2,16(r2)
 323dd10:	1880191e 	bne	r3,r2,323dd78 <arprcv+0x20c>
            tp->flags |= ET_SNAP;
         else
            tp->flags |= ET_ETH2;      /* else it's ethernet II */
#endif   /* IEEE_802_3 */

         MEMMOVE(tp->t_phy_addr, arphdr->ar_sha, 6);   /* update MAC adddress */
 323dd14:	e0bffc17 	ldw	r2,-16(fp)
 323dd18:	11000104 	addi	r4,r2,4
 323dd1c:	e0bffd17 	ldw	r2,-12(fp)
 323dd20:	11400204 	addi	r5,r2,8
 323dd24:	01800184 	movi	r6,6
 323dd28:	320686c0 	call	320686c <memmove>
         tp->lasttime = cticks;
 323dd2c:	0080c974 	movhi	r2,805
 323dd30:	10925604 	addi	r2,r2,18776
 323dd34:	10c00017 	ldw	r3,0(r2)
 323dd38:	e0bffc17 	ldw	r2,-16(fp)
 323dd3c:	10c00615 	stw	r3,24(r2)
         if (tp->pending)     /* packet waiting for this IP entry? */
 323dd40:	e0bffc17 	ldw	r2,-16(fp)
 323dd44:	10800417 	ldw	r2,16(r2)
 323dd48:	1005003a 	cmpeq	r2,r2,zero
 323dd4c:	1000021e 	bne	r2,zero,323dd58 <arprcv+0x1ec>
         {
            arp_send_pending(tp);
 323dd50:	e13ffc17 	ldw	r4,-16(fp)
 323dd54:	323d1100 	call	323d110 <arp_send_pending>
         }
         LOCK_NET_RESOURCE(FREEQ_RESID);
 323dd58:	01000084 	movi	r4,2
 323dd5c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pk_free(pkt);
 323dd60:	e13ffe17 	ldw	r4,-8(fp)
 323dd64:	322a2dc0 	call	322a2dc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323dd68:	01000084 	movi	r4,2
 323dd6c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

         return (0);
 323dd70:	e03fff15 	stw	zero,-4(fp)
 323dd74:	00000f06 	br	323ddb4 <arprcv+0x248>
      arpRepsIn++;
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 323dd78:	e0bffc17 	ldw	r2,-16(fp)
 323dd7c:	10800804 	addi	r2,r2,32
 323dd80:	e0bffc15 	stw	r2,-16(fp)
 323dd84:	00c0c9b4 	movhi	r3,806
 323dd88:	18f45b04 	addi	r3,r3,-11924
 323dd8c:	e0bffc17 	ldw	r2,-16(fp)
 323dd90:	10ffdb36 	bltu	r2,r3,323dd00 <arprcv+0x194>

#ifdef IEEE_802_3_ONLY
drop:
#endif /* IEEE_802_3_ONLY */
   /* fall to here if packet is not in table */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 323dd94:	01000084 	movi	r4,2
 323dd98:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   pk_free(pkt);
 323dd9c:	e13ffe17 	ldw	r4,-8(fp)
 323dda0:	322a2dc0 	call	322a2dc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323dda4:	01000084 	movi	r4,2
 323dda8:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   return ENP_NOT_MINE;
 323ddac:	00800084 	movi	r2,2
 323ddb0:	e0bfff15 	stw	r2,-4(fp)
 323ddb4:	e0bfff17 	ldw	r2,-4(fp)
}
 323ddb8:	e037883a 	mov	sp,fp
 323ddbc:	dfc00117 	ldw	ra,4(sp)
 323ddc0:	df000017 	ldw	fp,0(sp)
 323ddc4:	dec00204 	addi	sp,sp,8
 323ddc8:	f800283a 	ret

0323ddcc <send_via_arp>:
 * change the PC's IP address. 
 */

int
send_via_arp(PACKET pkt, ip_addr dest_ip)
{
 323ddcc:	defff704 	addi	sp,sp,-36
 323ddd0:	dfc00815 	stw	ra,32(sp)
 323ddd4:	df000715 	stw	fp,28(sp)
 323ddd8:	df000704 	addi	fp,sp,28
 323dddc:	e13ffd15 	stw	r4,-12(fp)
 323dde0:	e17ffe15 	stw	r5,-8(fp)
   struct arptabent *tp;
   unsigned long lticks = cticks;
 323dde4:	0080c974 	movhi	r2,805
 323dde8:	10925604 	addi	r2,r2,18776
 323ddec:	10800017 	ldw	r2,0(r2)
 323ddf0:	e0bffb15 	stw	r2,-20(fp)
   int err;

   /* don't allow zero dest */
   if (dest_ip == 0)
 323ddf4:	e0bffe17 	ldw	r2,-8(fp)
 323ddf8:	1004c03a 	cmpne	r2,r2,zero
 323ddfc:	1000091e 	bne	r2,zero,323de24 <send_via_arp+0x58>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 323de00:	01000084 	movi	r4,2
 323de04:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(pkt);
 323de08:	e13ffd17 	ldw	r4,-12(fp)
 323de0c:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323de10:	01000084 	movi	r4,2
 323de14:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return SEND_DROPPED; 
 323de18:	00bffa84 	movi	r2,-22
 323de1c:	e0bfff15 	stw	r2,-4(fp)
 323de20:	00004e06 	br	323df5c <send_via_arp+0x190>
   }

   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
 323de24:	d0e8fc17 	ldw	r3,-23568(gp)
 323de28:	e0bffb17 	ldw	r2,-20(fp)
 323de2c:	10c5c83a 	sub	r2,r2,r3
 323de30:	1080fa70 	cmpltui	r2,r2,1001
 323de34:	1000011e 	bne	r2,zero,323de3c <send_via_arp+0x70>
      arpcache = (struct arptabent *)NULL;
 323de38:	d028f715 	stw	zero,-23588(gp)

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 323de3c:	d0a8f717 	ldw	r2,-23588(gp)
 323de40:	1005003a 	cmpeq	r2,r2,zero
 323de44:	1000071e 	bne	r2,zero,323de64 <send_via_arp+0x98>
 323de48:	d0a8f717 	ldw	r2,-23588(gp)
 323de4c:	10c00017 	ldw	r3,0(r2)
 323de50:	e0bffe17 	ldw	r2,-8(fp)
 323de54:	1880031e 	bne	r3,r2,323de64 <send_via_arp+0x98>
      tp = arpcache;
 323de58:	d0a8f717 	ldw	r2,-23588(gp)
 323de5c:	e0bffc15 	stw	r2,-16(fp)
   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
      arpcache = (struct arptabent *)NULL;

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 323de60:	00000306 	br	323de70 <send_via_arp+0xa4>
      tp = arpcache;
   else
   {
      /* scan arp table for an existing entry */
      tp = find_oldest_arp(dest_ip);
 323de64:	e13ffe17 	ldw	r4,-8(fp)
 323de68:	323d61c0 	call	323d61c <find_oldest_arp>
 323de6c:	e0bffc15 	stw	r2,-16(fp)
   }

   if (tp->t_pro_addr == dest_ip)   /* we found our entry */
 323de70:	e0bffc17 	ldw	r2,-16(fp)
 323de74:	10c00017 	ldw	r3,0(r2)
 323de78:	e0bffe17 	ldw	r2,-8(fp)
 323de7c:	1880311e 	bne	r3,r2,323df44 <send_via_arp+0x178>
   {
      if (tp->pending)  /* arp already pending for this IP? */
 323de80:	e0bffc17 	ldw	r2,-16(fp)
 323de84:	10800417 	ldw	r2,16(r2)
 323de88:	1005003a 	cmpeq	r2,r2,zero
 323de8c:	1000241e 	bne	r2,zero,323df20 <send_via_arp+0x154>
      {
         if (lilfreeq.q_len < 2)
 323de90:	0080c9b4 	movhi	r2,806
 323de94:	10b2bc04 	addi	r2,r2,-13584
 323de98:	10800217 	ldw	r2,8(r2)
 323de9c:	10800088 	cmpgei	r2,r2,2
 323dea0:	1000091e 	bne	r2,zero,323dec8 <send_via_arp+0xfc>
         {
            /* system is depleted of resources - free the
             * pkt instead of queueing it - so that we are in a
             * position to receive an arp reply 
             */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 323dea4:	01000084 	movi	r4,2
 323dea8:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
            pk_free(pkt);  /* sorry, we have to dump this one.. */
 323deac:	e13ffd17 	ldw	r4,-12(fp)
 323deb0:	322a2dc0 	call	322a2dc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323deb4:	01000084 	movi	r4,2
 323deb8:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
            err = SEND_DROPPED;    /* pkts already waiting for this IP entry */
 323debc:	00bffa84 	movi	r2,-22
 323dec0:	e0bffa15 	stw	r2,-24(fp)
 323dec4:	00002306 	br	323df54 <send_via_arp+0x188>
         }
         else
         {
            PACKET tmppkt=tp->pending;
 323dec8:	e0bffc17 	ldw	r2,-16(fp)
 323decc:	10800417 	ldw	r2,16(r2)
 323ded0:	e0bff915 	stw	r2,-28(fp)

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 323ded4:	00000306 	br	323dee4 <send_via_arp+0x118>
               tmppkt = tmppkt->next;
 323ded8:	e0bff917 	ldw	r2,-28(fp)
 323dedc:	10800017 	ldw	r2,0(r2)
 323dee0:	e0bff915 	stw	r2,-28(fp)
         else
         {
            PACKET tmppkt=tp->pending;

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 323dee4:	e0bff917 	ldw	r2,-28(fp)
 323dee8:	10800017 	ldw	r2,0(r2)
 323deec:	1004c03a 	cmpne	r2,r2,zero
 323def0:	103ff91e 	bne	r2,zero,323ded8 <send_via_arp+0x10c>
               tmppkt = tmppkt->next;
            tmppkt->next = pkt;      /* add new pkt to end of list */
 323def4:	e0fff917 	ldw	r3,-28(fp)
 323def8:	e0bffd17 	ldw	r2,-12(fp)
 323defc:	18800015 	stw	r2,0(r3)
            if (pkt->next)
 323df00:	e0bffd17 	ldw	r2,-12(fp)
 323df04:	10800017 	ldw	r2,0(r2)
 323df08:	1005003a 	cmpeq	r2,r2,zero
 323df0c:	1000011e 	bne	r2,zero,323df14 <send_via_arp+0x148>
            {
               dtrap();              /* chain of pkts to be sent ??? */
 323df10:	322ab8c0 	call	322ab8c <dtrap>
            }
            err = ENP_SEND_PENDING; /* packet queued pending ARP reply */
 323df14:	00800044 	movi	r2,1
 323df18:	e0bffa15 	stw	r2,-24(fp)
 323df1c:	00000d06 	br	323df54 <send_via_arp+0x188>
         }
      }
      else  /* just send it */
      {
         arpcache = tp;       /* cache this entry */
 323df20:	e0bffc17 	ldw	r2,-16(fp)
 323df24:	d0a8f715 	stw	r2,-23588(gp)
         cachetime = lticks;  /* mark time we cached */
 323df28:	e0bffb17 	ldw	r2,-20(fp)
 323df2c:	d0a8fc15 	stw	r2,-23568(gp)
         err = et_send(pkt, tp);
 323df30:	e13ffd17 	ldw	r4,-12(fp)
 323df34:	e17ffc17 	ldw	r5,-16(fp)
 323df38:	323cf0c0 	call	323cf0c <et_send>
 323df3c:	e0bffa15 	stw	r2,-24(fp)
 323df40:	00000406 	br	323df54 <send_via_arp+0x188>
      }
   }
   else
      /* start the ARP process for this IP address */
      err = send_arp(pkt, dest_ip);
 323df44:	e13ffd17 	ldw	r4,-12(fp)
 323df48:	e17ffe17 	ldw	r5,-8(fp)
 323df4c:	323d1840 	call	323d184 <send_arp>
 323df50:	e0bffa15 	stw	r2,-24(fp)

   return (err);
 323df54:	e0bffa17 	ldw	r2,-24(fp)
 323df58:	e0bfff15 	stw	r2,-4(fp)
 323df5c:	e0bfff17 	ldw	r2,-4(fp)
}
 323df60:	e037883a 	mov	sp,fp
 323df64:	dfc00117 	ldw	ra,4(sp)
 323df68:	df000017 	ldw	fp,0(sp)
 323df6c:	dec00204 	addi	sp,sp,8
 323df70:	f800283a 	ret

0323df74 <cb_arpent_tmo>:
 *
 * If there are no more unresolved entries, cancel the timer.
 */
void
cb_arpent_tmo(long arg)
{
 323df74:	defffa04 	addi	sp,sp,-24
 323df78:	dfc00515 	stw	ra,20(sp)
 323df7c:	df000415 	stw	fp,16(sp)
 323df80:	df000404 	addi	fp,sp,16
 323df84:	e13fff15 	stw	r4,-4(fp)
   struct arptabent *tp;
   int arp_count = 0;
 323df88:	e03ffd15 	stw	zero,-12(fp)
   unsigned long lticks = cticks;
 323df8c:	0080c974 	movhi	r2,805
 323df90:	10925604 	addi	r2,r2,18776
 323df94:	10800017 	ldw	r2,0(r2)
 323df98:	e0bffc15 	stw	r2,-16(fp)

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 323df9c:	0080c9b4 	movhi	r2,806
 323dfa0:	10b41b04 	addi	r2,r2,-12180
 323dfa4:	e0bffe15 	stw	r2,-8(fp)
 323dfa8:	00002906 	br	323e050 <cb_arpent_tmo+0xdc>
   {
      if (tp->t_pro_addr != 0)
 323dfac:	e0bffe17 	ldw	r2,-8(fp)
 323dfb0:	10800017 	ldw	r2,0(r2)
 323dfb4:	1005003a 	cmpeq	r2,r2,zero
 323dfb8:	1000221e 	bne	r2,zero,323e044 <cb_arpent_tmo+0xd0>
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 323dfbc:	e0bffe17 	ldw	r2,-8(fp)
 323dfc0:	10800417 	ldw	r2,16(r2)
 323dfc4:	1005003a 	cmpeq	r2,r2,zero
 323dfc8:	10000b1e 	bne	r2,zero,323dff8 <cb_arpent_tmo+0x84>
 323dfcc:	e0bffe17 	ldw	r2,-8(fp)
 323dfd0:	10c00517 	ldw	r3,20(r2)
 323dfd4:	e0bffc17 	ldw	r2,-16(fp)
 323dfd8:	10c5c83a 	sub	r2,r2,r3
 323dfdc:	1080fa70 	cmpltui	r2,r2,1001
 323dfe0:	1000051e 	bne	r2,zero,323dff8 <cb_arpent_tmo+0x84>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
 323dfe4:	e13ffe17 	ldw	r4,-8(fp)
 323dfe8:	323d0880 	call	323d088 <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 323dfec:	e0bffe17 	ldw	r2,-8(fp)
 323dff0:	10000015 	stw	zero,0(r2)
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
   {
      if (tp->t_pro_addr != 0)
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 323dff4:	00001306 	br	323e044 <cb_arpent_tmo+0xd0>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 323dff8:	e0bffe17 	ldw	r2,-8(fp)
 323dffc:	10c00517 	ldw	r3,20(r2)
 323e000:	e0bffc17 	ldw	r2,-16(fp)
 323e004:	10c5c83a 	sub	r2,r2,r3
 323e008:	1007883a 	mov	r3,r2
 323e00c:	d0a04b17 	ldw	r2,-32468(gp)
 323e010:	18800916 	blt	r3,r2,323e038 <cb_arpent_tmo+0xc4>
 323e014:	e0bffe17 	ldw	r2,-8(fp)
 323e018:	10c00617 	ldw	r3,24(r2)
 323e01c:	e0bffc17 	ldw	r2,-16(fp)
 323e020:	10c5c83a 	sub	r2,r2,r3
 323e024:	1080fa30 	cmpltui	r2,r2,1000
 323e028:	1000031e 	bne	r2,zero,323e038 <cb_arpent_tmo+0xc4>
                  ((int)(lticks - tp->lasttime)   >= TPS))
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 323e02c:	e0bffe17 	ldw	r2,-8(fp)
 323e030:	10000015 	stw	zero,0(r2)
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 323e034:	00000306 	br	323e044 <cb_arpent_tmo+0xd0>
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else
            arp_count++;
 323e038:	e0bffd17 	ldw	r2,-12(fp)
 323e03c:	10800044 	addi	r2,r2,1
 323e040:	e0bffd15 	stw	r2,-12(fp)
{
   struct arptabent *tp;
   int arp_count = 0;
   unsigned long lticks = cticks;

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 323e044:	e0bffe17 	ldw	r2,-8(fp)
 323e048:	10800804 	addi	r2,r2,32
 323e04c:	e0bffe15 	stw	r2,-8(fp)
 323e050:	00c0c9b4 	movhi	r3,806
 323e054:	18f45b04 	addi	r3,r3,-11924
 323e058:	e0bffe17 	ldw	r2,-8(fp)
 323e05c:	10ffd336 	bltu	r2,r3,323dfac <cb_arpent_tmo+0x38>
            arp_count++;
      }
   }

   /* if there are no more "pending" entries, kill the timer */
   if (arp_count == 0)
 323e060:	e0bffd17 	ldw	r2,-12(fp)
 323e064:	1004c03a 	cmpne	r2,r2,zero
 323e068:	1000031e 	bne	r2,zero,323e078 <cb_arpent_tmo+0x104>
   {
      in_timerkill(arp_timer);
 323e06c:	d128f617 	ldw	r4,-23592(gp)
 323e070:	323ccbc0 	call	323ccbc <in_timerkill>
      arp_timer = 0;
 323e074:	d028f615 	stw	zero,-23592(gp)
   }
      
   USE_ARG(arg);
}
 323e078:	e037883a 	mov	sp,fp
 323e07c:	dfc00117 	ldw	ra,4(sp)
 323e080:	df000017 	ldw	fp,0(sp)
 323e084:	dec00204 	addi	sp,sp,8
 323e088:	f800283a 	ret

0323e08c <grat_arp>:
 * RETURNS: Returns 0 if OK, or the usual ENP_ errors 
 */

int
grat_arp(NET net, int flag)
{
 323e08c:	defff604 	addi	sp,sp,-40
 323e090:	dfc00915 	stw	ra,36(sp)
 323e094:	df000815 	stw	fp,32(sp)
 323e098:	df000804 	addi	fp,sp,32
 323e09c:	e13ffd15 	stw	r4,-12(fp)
 323e0a0:	e17ffe15 	stw	r5,-8(fp)
   char * ethhdr;
   struct arp_hdr *  arphdr;
   IFMIB etif = net->n_mib;    /* mib info for this ethernet interface */
 323e0a4:	e0bffd17 	ldw	r2,-12(fp)
 323e0a8:	10802717 	ldw	r2,156(r2)
 323e0ac:	e0bffa15 	stw	r2,-24(fp)
   PACKET arppkt;

   /* get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 323e0b0:	01000084 	movi	r4,2
 323e0b4:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 323e0b8:	01000c04 	movi	r4,48
 323e0bc:	3229f480 	call	3229f48 <pk_alloc>
 323e0c0:	e0bff915 	stw	r2,-28(fp)
   if (!arppkt)
 323e0c4:	e0bff917 	ldw	r2,-28(fp)
 323e0c8:	1004c03a 	cmpne	r2,r2,zero
 323e0cc:	1000051e 	bne	r2,zero,323e0e4 <grat_arp+0x58>
   {
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323e0d0:	01000084 	movi	r4,2
 323e0d4:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 323e0d8:	00bffa84 	movi	r2,-22
 323e0dc:	e0bfff15 	stw	r2,-4(fp)
 323e0e0:	00009706 	br	323e340 <grat_arp+0x2b4>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323e0e4:	01000084 	movi	r4,2
 323e0e8:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 323e0ec:	e0bff917 	ldw	r2,-28(fp)
 323e0f0:	10c00117 	ldw	r3,4(r2)
 323e0f4:	e0bff917 	ldw	r2,-28(fp)
 323e0f8:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 323e0fc:	e0fff917 	ldw	r3,-28(fp)
 323e100:	00800c04 	movi	r2,48
 323e104:	18800415 	stw	r2,16(r3)
   arppkt->net = net;
 323e108:	e0fff917 	ldw	r3,-28(fp)
 323e10c:	e0bffd17 	ldw	r2,-12(fp)
 323e110:	18800615 	stw	r2,24(r3)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 323e114:	e0bff917 	ldw	r2,-28(fp)
 323e118:	10800117 	ldw	r2,4(r2)
 323e11c:	10800084 	addi	r2,r2,2
 323e120:	e0bffc15 	stw	r2,-16(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 323e124:	e0bff917 	ldw	r2,-28(fp)
 323e128:	10800117 	ldw	r2,4(r2)
 323e12c:	10800404 	addi	r2,r2,16
 323e130:	e0bffb15 	stw	r2,-20(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 323e134:	e0fffb17 	ldw	r3,-20(fp)
 323e138:	00804004 	movi	r2,256
 323e13c:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 323e140:	e0fffb17 	ldw	r3,-20(fp)
 323e144:	00800204 	movi	r2,8
 323e148:	1880008d 	sth	r2,2(r3)
   arphdr->ar_hln = 6;
 323e14c:	e0fffb17 	ldw	r3,-20(fp)
 323e150:	00800184 	movi	r2,6
 323e154:	18800105 	stb	r2,4(r3)
   arphdr->ar_pln = 4;
 323e158:	e0fffb17 	ldw	r3,-20(fp)
 323e15c:	00800104 	movi	r2,4
 323e160:	18800145 	stb	r2,5(r3)
   
   /* ARP req? */
   if (flag == 0)
 323e164:	e0bffe17 	ldw	r2,-8(fp)
 323e168:	1004c03a 	cmpne	r2,r2,zero
 323e16c:	1000041e 	bne	r2,zero,323e180 <grat_arp+0xf4>
      /* yup */
      arphdr->ar_op = ARREQ;
 323e170:	e0fffb17 	ldw	r3,-20(fp)
 323e174:	00804004 	movi	r2,256
 323e178:	1880018d 	sth	r2,6(r3)
 323e17c:	00000306 	br	323e18c <grat_arp+0x100>
   else
     /* nope */
      arphdr->ar_op = ARREP;
 323e180:	e0fffb17 	ldw	r3,-20(fp)
 323e184:	00808004 	movi	r2,512
 323e188:	1880018d 	sth	r2,6(r3)
      
   arphdr->ar_tpa = net->n_ipaddr;        /* target's IP address */
 323e18c:	e0bffd17 	ldw	r2,-12(fp)
 323e190:	10c00a17 	ldw	r3,40(r2)
 323e194:	e0bffb17 	ldw	r2,-20(fp)
 323e198:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = net->n_ipaddr;   /* my IP address */
 323e19c:	e0bffd17 	ldw	r2,-12(fp)
 323e1a0:	10c00a17 	ldw	r3,40(r2)
 323e1a4:	e0bffb17 	ldw	r2,-20(fp)
 323e1a8:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 323e1ac:	e0bffb17 	ldw	r2,-20(fp)
 323e1b0:	11000204 	addi	r4,r2,8
 323e1b4:	e0bffa17 	ldw	r2,-24(fp)
 323e1b8:	11400517 	ldw	r5,20(r2)
 323e1bc:	01800184 	movi	r6,6
 323e1c0:	320686c0 	call	320686c <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 323e1c4:	e0fffc17 	ldw	r3,-16(fp)
 323e1c8:	00bfffc4 	movi	r2,-1
 323e1cc:	18800005 	stb	r2,0(r3)
 323e1d0:	00bfffc4 	movi	r2,-1
 323e1d4:	18800045 	stb	r2,1(r3)
 323e1d8:	00bfffc4 	movi	r2,-1
 323e1dc:	18800085 	stb	r2,2(r3)
 323e1e0:	00bfffc4 	movi	r2,-1
 323e1e4:	188000c5 	stb	r2,3(r3)
 323e1e8:	00bfffc4 	movi	r2,-1
 323e1ec:	18800105 	stb	r2,4(r3)
 323e1f0:	00bfffc4 	movi	r2,-1
 323e1f4:	18800145 	stb	r2,5(r3)
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 323e1f8:	e0bffc17 	ldw	r2,-16(fp)
 323e1fc:	11000184 	addi	r4,r2,6
 323e200:	e0bffa17 	ldw	r2,-24(fp)
 323e204:	11400517 	ldw	r5,20(r2)
 323e208:	01800184 	movi	r6,6
 323e20c:	320686c0 	call	320686c <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 323e210:	e0bffc17 	ldw	r2,-16(fp)
 323e214:	10c00304 	addi	r3,r2,12
 323e218:	00800204 	movi	r2,8
 323e21c:	18800005 	stb	r2,0(r3)
 323e220:	e0bffc17 	ldw	r2,-16(fp)
 323e224:	10c00344 	addi	r3,r2,13
 323e228:	00800184 	movi	r2,6
 323e22c:	18800005 	stb	r2,0(r3)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 323e230:	e0bffb17 	ldw	r2,-20(fp)
 323e234:	e0bff815 	stw	r2,-32(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 323e238:	e0bff817 	ldw	r2,-32(fp)
 323e23c:	11000204 	addi	r4,r2,8
 323e240:	e0bffb17 	ldw	r2,-20(fp)
 323e244:	11400204 	addi	r5,r2,8
 323e248:	01800184 	movi	r6,6
 323e24c:	320686c0 	call	320686c <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 323e250:	e0bff817 	ldw	r2,-32(fp)
 323e254:	10800204 	addi	r2,r2,8
 323e258:	11000184 	addi	r4,r2,6
 323e25c:	e0bffb17 	ldw	r2,-20(fp)
 323e260:	11400404 	addi	r5,r2,16
 323e264:	01800104 	movi	r6,4
 323e268:	320686c0 	call	320686c <memmove>

   /* ARP req? */
   if (flag == 0)
 323e26c:	e0bffe17 	ldw	r2,-8(fp)
 323e270:	1004c03a 	cmpne	r2,r2,zero
 323e274:	1000081e 	bne	r2,zero,323e298 <grat_arp+0x20c>
      /* yup */      
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 323e278:	e0bff817 	ldw	r2,-32(fp)
 323e27c:	10800204 	addi	r2,r2,8
 323e280:	11000284 	addi	r4,r2,10
 323e284:	e0bffb17 	ldw	r2,-20(fp)
 323e288:	11400504 	addi	r5,r2,20
 323e28c:	01800184 	movi	r6,6
 323e290:	320686c0 	call	320686c <memmove>
 323e294:	00000706 	br	323e2b4 <grat_arp+0x228>
   else
      /* nope */
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_sha, 6);
 323e298:	e0bff817 	ldw	r2,-32(fp)
 323e29c:	10800204 	addi	r2,r2,8
 323e2a0:	11000284 	addi	r4,r2,10
 323e2a4:	e0bffb17 	ldw	r2,-20(fp)
 323e2a8:	11400204 	addi	r5,r2,8
 323e2ac:	01800184 	movi	r6,6
 323e2b0:	320686c0 	call	320686c <memmove>
      
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 323e2b4:	e0bff817 	ldw	r2,-32(fp)
 323e2b8:	10800204 	addi	r2,r2,8
 323e2bc:	11000404 	addi	r4,r2,16
 323e2c0:	e0bffb17 	ldw	r2,-20(fp)
 323e2c4:	11400704 	addi	r5,r2,28
 323e2c8:	01800104 	movi	r6,4
 323e2cc:	320686c0 	call	320686c <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 323e2d0:	e0bffd17 	ldw	r2,-12(fp)
 323e2d4:	10800417 	ldw	r2,16(r2)
 323e2d8:	1005003a 	cmpeq	r2,r2,zero
 323e2dc:	1000051e 	bne	r2,zero,323e2f4 <grat_arp+0x268>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 323e2e0:	e0bffd17 	ldw	r2,-12(fp)
 323e2e4:	10800417 	ldw	r2,16(r2)
 323e2e8:	e13ff917 	ldw	r4,-28(fp)
 323e2ec:	103ee83a 	callr	r2
 323e2f0:	00000e06 	br	323e32c <grat_arp+0x2a0>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 323e2f4:	e0bffd17 	ldw	r2,-12(fp)
 323e2f8:	10c00317 	ldw	r3,12(r2)
 323e2fc:	e0bff917 	ldw	r2,-28(fp)
 323e300:	11000617 	ldw	r4,24(r2)
 323e304:	e0bff917 	ldw	r2,-28(fp)
 323e308:	11400117 	ldw	r5,4(r2)
 323e30c:	01800c04 	movi	r6,48
 323e310:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 323e314:	01000084 	movi	r4,2
 323e318:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 323e31c:	e13ff917 	ldw	r4,-28(fp)
 323e320:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323e324:	01000084 	movi	r4,2
 323e328:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 323e32c:	d0a8f917 	ldw	r2,-23580(gp)
 323e330:	10800044 	addi	r2,r2,1
 323e334:	d0a8f915 	stw	r2,-23580(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 323e338:	00800044 	movi	r2,1
 323e33c:	e0bfff15 	stw	r2,-4(fp)
 323e340:	e0bfff17 	ldw	r2,-4(fp)
}
 323e344:	e037883a 	mov	sp,fp
 323e348:	dfc00117 	ldw	ra,4(sp)
 323e34c:	df000017 	ldw	fp,0(sp)
 323e350:	dec00204 	addi	sp,sp,8
 323e354:	f800283a 	ret

0323e358 <if_getbynum>:
 * RETURNS: Returns NET pointer, or NULL if out of range
 */

NET
if_getbynum(int ifnum)
{
 323e358:	defffb04 	addi	sp,sp,-20
 323e35c:	dfc00415 	stw	ra,16(sp)
 323e360:	df000315 	stw	fp,12(sp)
 323e364:	df000304 	addi	fp,sp,12
 323e368:	e13ffe15 	stw	r4,-8(fp)
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 323e36c:	0080c9b4 	movhi	r2,806
 323e370:	10b45b04 	addi	r2,r2,-11924
 323e374:	10800017 	ldw	r2,0(r2)
 323e378:	e0bffd15 	stw	r2,-12(fp)
 323e37c:	00000c06 	br	323e3b0 <if_getbynum+0x58>
   {
      if(ifnum-- == 0)
 323e380:	e0bffe17 	ldw	r2,-8(fp)
 323e384:	10bfffc4 	addi	r2,r2,-1
 323e388:	e0bffe15 	stw	r2,-8(fp)
 323e38c:	e0bffe17 	ldw	r2,-8(fp)
 323e390:	10bfffd8 	cmpnei	r2,r2,-1
 323e394:	1000031e 	bne	r2,zero,323e3a4 <if_getbynum+0x4c>
         return ifp;
 323e398:	e0bffd17 	ldw	r2,-12(fp)
 323e39c:	e0bfff15 	stw	r2,-4(fp)
 323e3a0:	00000806 	br	323e3c4 <if_getbynum+0x6c>

NET
if_getbynum(int ifnum)
{
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 323e3a4:	e0bffd17 	ldw	r2,-12(fp)
 323e3a8:	10800017 	ldw	r2,0(r2)
 323e3ac:	e0bffd15 	stw	r2,-12(fp)
 323e3b0:	e0bffd17 	ldw	r2,-12(fp)
 323e3b4:	1004c03a 	cmpne	r2,r2,zero
 323e3b8:	103ff11e 	bne	r2,zero,323e380 <if_getbynum+0x28>
   {
      if(ifnum-- == 0)
         return ifp;
   }
   dtrap();
 323e3bc:	322ab8c0 	call	322ab8c <dtrap>
   return NULL;   /* list is not long enough */
 323e3c0:	e03fff15 	stw	zero,-4(fp)
 323e3c4:	e0bfff17 	ldw	r2,-4(fp)
}
 323e3c8:	e037883a 	mov	sp,fp
 323e3cc:	dfc00117 	ldw	ra,4(sp)
 323e3d0:	df000017 	ldw	fp,0(sp)
 323e3d4:	dec00204 	addi	sp,sp,8
 323e3d8:	f800283a 	ret

0323e3dc <isbcast>:
 * RETURNS:  Returns TRUE if broadcast, else false. 
 */

int
isbcast(NET ifc, unsigned char * addr)
{
 323e3dc:	defffc04 	addi	sp,sp,-16
 323e3e0:	df000315 	stw	fp,12(sp)
 323e3e4:	df000304 	addi	fp,sp,12
 323e3e8:	e13ffd15 	stw	r4,-12(fp)
 323e3ec:	e17ffe15 	stw	r5,-8(fp)
#if (ALIGN_TYPE > 2)
   /* On systems with 32bit alignment requirements we have to make
    * sure our tests are aligned. Specifically, this results in "data
    * abort" errors on the Samsung/ARM port. 
    */
   if((u_long)addr & (ALIGN_TYPE - 1))
 323e3f0:	e0bffe17 	ldw	r2,-8(fp)
 323e3f4:	108000cc 	andi	r2,r2,3
 323e3f8:	1005003a 	cmpeq	r2,r2,zero
 323e3fc:	10000e1e 	bne	r2,zero,323e438 <isbcast+0x5c>
   {
      /* check first two bytes */
      if ((u_short)*(u_short*)(addr) != 0xFFFF)
 323e400:	e0bffe17 	ldw	r2,-8(fp)
 323e404:	1080000b 	ldhu	r2,0(r2)
 323e408:	10ffffcc 	andi	r3,r2,65535
 323e40c:	00bfffd4 	movui	r2,65535
 323e410:	18800226 	beq	r3,r2,323e41c <isbcast+0x40>
         return(FALSE);
 323e414:	e03fff15 	stw	zero,-4(fp)
 323e418:	00002306 	br	323e4a8 <isbcast+0xcc>
      if ((u_long)(*(u_long*)(addr + 2)) != 0xFFFFFFFF)
 323e41c:	e0bffe17 	ldw	r2,-8(fp)
 323e420:	10800084 	addi	r2,r2,2
 323e424:	10800017 	ldw	r2,0(r2)
 323e428:	10bfffe0 	cmpeqi	r2,r2,-1
 323e42c:	1000101e 	bne	r2,zero,323e470 <isbcast+0x94>
         return FALSE;
 323e430:	e03fff15 	stw	zero,-4(fp)
 323e434:	00001c06 	br	323e4a8 <isbcast+0xcc>
#endif /* ALIGN_TYPE > 4 */
   {
      /* check first four bytes for all ones. Since this is the fastest
       * test, do it first
       */
      if ((u_long)(*(u_long*)addr) != 0xFFFFFFFF)
 323e438:	e0bffe17 	ldw	r2,-8(fp)
 323e43c:	10800017 	ldw	r2,0(r2)
 323e440:	10bfffe0 	cmpeqi	r2,r2,-1
 323e444:	1000021e 	bne	r2,zero,323e450 <isbcast+0x74>
         return FALSE;
 323e448:	e03fff15 	stw	zero,-4(fp)
 323e44c:	00001606 	br	323e4a8 <isbcast+0xcc>

      /* check last two bytes */
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
 323e450:	e0bffe17 	ldw	r2,-8(fp)
 323e454:	10800104 	addi	r2,r2,4
 323e458:	1080000b 	ldhu	r2,0(r2)
 323e45c:	10ffffcc 	andi	r3,r2,65535
 323e460:	00bfffd4 	movui	r2,65535
 323e464:	18800226 	beq	r3,r2,323e470 <isbcast+0x94>
         return(FALSE);
 323e468:	e03fff15 	stw	zero,-4(fp)
 323e46c:	00000e06 	br	323e4a8 <isbcast+0xcc>
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 323e470:	e0bffd17 	ldw	r2,-12(fp)
 323e474:	10802717 	ldw	r2,156(r2)
 323e478:	10800217 	ldw	r2,8(r2)
 323e47c:	108005e0 	cmpeqi	r2,r2,23
 323e480:	1000051e 	bne	r2,zero,323e498 <isbcast+0xbc>
 323e484:	e0bffd17 	ldw	r2,-12(fp)
 323e488:	10802717 	ldw	r2,156(r2)
 323e48c:	10800217 	ldw	r2,8(r2)
 323e490:	10800718 	cmpnei	r2,r2,28
 323e494:	1000021e 	bne	r2,zero,323e4a0 <isbcast+0xc4>
       (ifc->n_mib->ifType == SLIP))
   {
      return FALSE;
 323e498:	e03fff15 	stw	zero,-4(fp)
 323e49c:	00000206 	br	323e4a8 <isbcast+0xcc>
   }

   /* passed all tests, must be broadcast */
   return(TRUE);
 323e4a0:	00800044 	movi	r2,1
 323e4a4:	e0bfff15 	stw	r2,-4(fp)
 323e4a8:	e0bfff17 	ldw	r2,-4(fp)
}
 323e4ac:	e037883a 	mov	sp,fp
 323e4b0:	df000017 	ldw	fp,0(sp)
 323e4b4:	dec00104 	addi	sp,sp,4
 323e4b8:	f800283a 	ret

0323e4bc <reg_type>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
reg_type(unshort type)
{
 323e4bc:	defffa04 	addi	sp,sp,-24
 323e4c0:	dfc00515 	stw	ra,20(sp)
 323e4c4:	df000415 	stw	fp,16(sp)
 323e4c8:	df000404 	addi	fp,sp,16
 323e4cc:	e13ffe0d 	sth	r4,-8(fp)
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 323e4d0:	0080c9b4 	movhi	r2,806
 323e4d4:	10b45b04 	addi	r2,r2,-11924
 323e4d8:	10800017 	ldw	r2,0(r2)
 323e4dc:	e0bffd15 	stw	r2,-12(fp)
 323e4e0:	00001306 	br	323e530 <reg_type+0x74>
   {
      if (ifp->n_reg_type)    /* make sure call exists */
 323e4e4:	e0bffd17 	ldw	r2,-12(fp)
 323e4e8:	10800617 	ldw	r2,24(r2)
 323e4ec:	1005003a 	cmpeq	r2,r2,zero
 323e4f0:	10000c1e 	bne	r2,zero,323e524 <reg_type+0x68>
      {
         e = (ifp->n_reg_type)(type, ifp);
 323e4f4:	e0bffd17 	ldw	r2,-12(fp)
 323e4f8:	10800617 	ldw	r2,24(r2)
 323e4fc:	e13ffe0b 	ldhu	r4,-8(fp)
 323e500:	e17ffd17 	ldw	r5,-12(fp)
 323e504:	103ee83a 	callr	r2
 323e508:	e0bffc15 	stw	r2,-16(fp)
         if (e)
 323e50c:	e0bffc17 	ldw	r2,-16(fp)
 323e510:	1005003a 	cmpeq	r2,r2,zero
 323e514:	1000031e 	bne	r2,zero,323e524 <reg_type+0x68>
            return e;   /* bails out if error */
 323e518:	e0bffc17 	ldw	r2,-16(fp)
 323e51c:	e0bfff15 	stw	r2,-4(fp)
 323e520:	00000706 	br	323e540 <reg_type+0x84>
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 323e524:	e0bffd17 	ldw	r2,-12(fp)
 323e528:	10800017 	ldw	r2,0(r2)
 323e52c:	e0bffd15 	stw	r2,-12(fp)
 323e530:	e0bffd17 	ldw	r2,-12(fp)
 323e534:	1004c03a 	cmpne	r2,r2,zero
 323e538:	103fea1e 	bne	r2,zero,323e4e4 <reg_type+0x28>
         e = (ifp->n_reg_type)(type, ifp);
         if (e)
            return e;   /* bails out if error */
      }
   }
   return 0;   /* OK code */
 323e53c:	e03fff15 	stw	zero,-4(fp)
 323e540:	e0bfff17 	ldw	r2,-4(fp)
}
 323e544:	e037883a 	mov	sp,fp
 323e548:	dfc00117 	ldw	ra,4(sp)
 323e54c:	df000017 	ldw	fp,0(sp)
 323e550:	dec00204 	addi	sp,sp,8
 323e554:	f800283a 	ret

0323e558 <if_killsocks>:
 */

      /* kill this NETs sockets */
void
if_killsocks(NET ifp)
{
 323e558:	defffa04 	addi	sp,sp,-24
 323e55c:	dfc00515 	stw	ra,20(sp)
 323e560:	df000415 	stw	fp,16(sp)
 323e564:	df000404 	addi	fp,sp,16
 323e568:	e13fff15 	stw	r4,-4(fp)
   struct socket * so;
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
 323e56c:	0080c9b4 	movhi	r2,806
 323e570:	10b39704 	addi	r2,r2,-12708
 323e574:	10800017 	ldw	r2,0(r2)
 323e578:	e0bffe15 	stw	r2,-8(fp)
   while(so)
 323e57c:	00001406 	br	323e5d0 <if_killsocks+0x78>
   {
      if(so->so_pcb)
 323e580:	e0bffe17 	ldw	r2,-8(fp)
 323e584:	10800117 	ldw	r2,4(r2)
 323e588:	1005003a 	cmpeq	r2,r2,zero
 323e58c:	1000051e 	bne	r2,zero,323e5a4 <if_killsocks+0x4c>
         so_ifp = so->so_pcb->ifp;
 323e590:	e0bffe17 	ldw	r2,-8(fp)
 323e594:	10800117 	ldw	r2,4(r2)
 323e598:	10800a17 	ldw	r2,40(r2)
 323e59c:	e0bffc15 	stw	r2,-16(fp)
 323e5a0:	00000106 	br	323e5a8 <if_killsocks+0x50>
      else
         so_ifp = NULL;
 323e5a4:	e03ffc15 	stw	zero,-16(fp)
      next = (struct socket *)so->next;
 323e5a8:	e0bffe17 	ldw	r2,-8(fp)
 323e5ac:	10800017 	ldw	r2,0(r2)
 323e5b0:	e0bffd15 	stw	r2,-12(fp)
      if (so_ifp == ifp)
 323e5b4:	e0fffc17 	ldw	r3,-16(fp)
 323e5b8:	e0bfff17 	ldw	r2,-4(fp)
 323e5bc:	1880021e 	bne	r3,r2,323e5c8 <if_killsocks+0x70>
      {
         /* this is a direct heavy-handed close. A reset is sent
          * and all data is lost. The user should really have closed
          * all the sockets gracfully first.... 
          */
         soabort(so);
 323e5c0:	e13ffe17 	ldw	r4,-8(fp)
 323e5c4:	322fafc0 	call	322fafc <soabort>
      }
      so = next;
 323e5c8:	e0bffd17 	ldw	r2,-12(fp)
 323e5cc:	e0bffe15 	stw	r2,-8(fp)
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
   while(so)
 323e5d0:	e0bffe17 	ldw	r2,-8(fp)
 323e5d4:	1004c03a 	cmpne	r2,r2,zero
 323e5d8:	103fe91e 	bne	r2,zero,323e580 <if_killsocks+0x28>
          */
         soabort(so);
      }
      so = next;
   }
}
 323e5dc:	e037883a 	mov	sp,fp
 323e5e0:	dfc00117 	ldw	ra,4(sp)
 323e5e4:	df000017 	ldw	fp,0(sp)
 323e5e8:	dec00204 	addi	sp,sp,8
 323e5ec:	f800283a 	ret

0323e5f0 <ip_init>:
 * OK, else returns a non-zero error code. 
 */

int
ip_init(void)
{
 323e5f0:	defffd04 	addi	sp,sp,-12
 323e5f4:	dfc00215 	stw	ra,8(sp)
 323e5f8:	df000115 	stw	fp,4(sp)
 323e5fc:	df000104 	addi	fp,sp,4

   /* register IP type with link layer drivers */
   if (reg_type(IP_TYPE) != 0)
 323e600:	01000204 	movi	r4,8
 323e604:	323e4bc0 	call	323e4bc <reg_type>
 323e608:	1005003a 	cmpeq	r2,r2,zero
 323e60c:	1000061e 	bne	r2,zero,323e628 <ip_init+0x38>
   {   
#ifdef NPDEBUG
      dprintf("IP_INIT: unable to register type with MAC driver\n");
 323e610:	0100c974 	movhi	r4,805
 323e614:	213e2d04 	addi	r4,r4,-1868
 323e618:	3206e040 	call	3206e04 <puts>
#endif
      return(1);
 323e61c:	00800044 	movi	r2,1
 323e620:	e0bfff15 	stw	r2,-4(fp)
 323e624:	00002b06 	br	323e6d4 <ip_init+0xe4>
   }

   /* initialize the IP mib */
   MEMSET(&ip_mib, 0, sizeof(ip_mib));
 323e628:	0080c9b4 	movhi	r2,806
 323e62c:	10b46004 	addi	r2,r2,-11904
 323e630:	1009883a 	mov	r4,r2
 323e634:	01801404 	movi	r6,80
 323e638:	000b883a 	mov	r5,zero
 323e63c:	320694c0 	call	320694c <memset>
   ip_mib.ipForwarding = 2;   /* default to host, not gateway (router) */
 323e640:	00c0c9b4 	movhi	r3,806
 323e644:	18f46004 	addi	r3,r3,-11904
 323e648:	00800084 	movi	r2,2
 323e64c:	18800015 	stw	r2,0(r3)
   ip_mib.ipDefaultTTL = IP_TTL;
 323e650:	00c0c9b4 	movhi	r3,806
 323e654:	18f46004 	addi	r3,r3,-11904
 323e658:	00801004 	movi	r2,64
 323e65c:	18800115 	stw	r2,4(r3)

#ifdef IP_ROUTING
   /* alloc space for the route table */
   rt_mib = (struct RtMib*)RT_ALLOC(ipRoutes * sizeof(struct RtMib));
 323e660:	d0a04d17 	ldw	r2,-32460(gp)
 323e664:	11000f24 	muli	r4,r2,60
 323e668:	322b5d00 	call	322b5d0 <npalloc>
 323e66c:	d0a8fd15 	stw	r2,-23564(gp)
   if (!rt_mib)
 323e670:	d0a8fd17 	ldw	r2,-23564(gp)
 323e674:	1004c03a 	cmpne	r2,r2,zero
 323e678:	1000061e 	bne	r2,zero,323e694 <ip_init+0xa4>
   {
#ifdef NPDEBUG
      dprintf("IP_INIT ERROR: can't alloc route table\n");
 323e67c:	0100c974 	movhi	r4,805
 323e680:	213e3a04 	addi	r4,r4,-1816
 323e684:	3206e040 	call	3206e04 <puts>
#endif   /* NPDEBUG */
      return(ENP_NOMEM);
 323e688:	00bffb04 	movi	r2,-20
 323e68c:	e0bfff15 	stw	r2,-4(fp)
 323e690:	00001006 	br	323e6d4 <ip_init+0xe4>
   }

  MEMSET(rt_mib,0, ipRoutes * sizeof(struct RtMib)) ;
 323e694:	d0e8fd17 	ldw	r3,-23564(gp)
 323e698:	d0a04d17 	ldw	r2,-32460(gp)
 323e69c:	10800f24 	muli	r2,r2,60
 323e6a0:	1809883a 	mov	r4,r3
 323e6a4:	100d883a 	mov	r6,r2
 323e6a8:	000b883a 	mov	r5,zero
 323e6ac:	320694c0 	call	320694c <memset>
  ip_mib.ipForwarding = 1;   /* override default, be gateway (router) */
 323e6b0:	00c0c9b4 	movhi	r3,806
 323e6b4:	18f46004 	addi	r3,r3,-11904
 323e6b8:	00800044 	movi	r2,1
 323e6bc:	18800015 	stw	r2,0(r3)
#endif   /* IP_ROUTING */

   /* set IP reassembly timeout */
   ip_mib.ipReasmTimeout = IRE_TMO;
 323e6c0:	00c0c9b4 	movhi	r3,806
 323e6c4:	18f46004 	addi	r3,r3,-11904
 323e6c8:	00801e04 	movi	r2,120
 323e6cc:	18800c15 	stw	r2,48(r3)
      return(1);
   }
#endif   /* IPSEC */

   /* everything opened OK return 0 */
   return(SUCCESS);
 323e6d0:	e03fff15 	stw	zero,-4(fp)
 323e6d4:	e0bfff17 	ldw	r2,-4(fp)
}
 323e6d8:	e037883a 	mov	sp,fp
 323e6dc:	dfc00117 	ldw	ra,4(sp)
 323e6e0:	df000017 	ldw	fp,0(sp)
 323e6e4:	dec00204 	addi	sp,sp,8
 323e6e8:	f800283a 	ret

0323e6ec <ip_bldhead>:
 * RETURNS: void
 */

void
ip_bldhead(PACKET p, unsigned pid, u_char prot, unshort fragword)
{
 323e6ec:	defff804 	addi	sp,sp,-32
 323e6f0:	dfc00715 	stw	ra,28(sp)
 323e6f4:	df000615 	stw	fp,24(sp)
 323e6f8:	df000604 	addi	fp,sp,24
 323e6fc:	e13ffc15 	stw	r4,-16(fp)
 323e700:	e17ffd15 	stw	r5,-12(fp)
 323e704:	e1bffe05 	stb	r6,-8(fp)
 323e708:	e1ffff0d 	sth	r7,-4(fp)
   struct ip * pip;
   struct ip_socopts *sopts;

   /* prepend IP header to packet data */
   p->nb_prot -= sizeof(struct ip);       /* this assumes no send options! */
 323e70c:	e0bffc17 	ldw	r2,-16(fp)
 323e710:	10800317 	ldw	r2,12(r2)
 323e714:	10fffb04 	addi	r3,r2,-20
 323e718:	e0bffc17 	ldw	r2,-16(fp)
 323e71c:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 323e720:	e0bffc17 	ldw	r2,-16(fp)
 323e724:	10800417 	ldw	r2,16(r2)
 323e728:	10c00504 	addi	r3,r2,20
 323e72c:	e0bffc17 	ldw	r2,-16(fp)
 323e730:	10c00415 	stw	r3,16(r2)

   pip = (struct ip*)p->nb_prot;
 323e734:	e0bffc17 	ldw	r2,-16(fp)
 323e738:	10800317 	ldw	r2,12(r2)
 323e73c:	e0bffb15 	stw	r2,-20(fp)

   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 323e740:	e0fffb17 	ldw	r3,-20(fp)
 323e744:	00801144 	movi	r2,69
 323e748:	18800005 	stb	r2,0(r3)
   pip->ip_flgs_foff = fragword; /* fragment flags and offset */
 323e74c:	e0fffb17 	ldw	r3,-20(fp)
 323e750:	e0bfff0b 	ldhu	r2,-4(fp)
 323e754:	1880018d 	sth	r2,6(r3)
   pip->ip_id = htons((unshort)pid);   /* IP datagram ID */
 323e758:	e0bffd17 	ldw	r2,-12(fp)
 323e75c:	10bfffcc 	andi	r2,r2,65535
 323e760:	1004d23a 	srli	r2,r2,8
 323e764:	10803fcc 	andi	r2,r2,255
 323e768:	1009883a 	mov	r4,r2
 323e76c:	e0bffd17 	ldw	r2,-12(fp)
 323e770:	10bfffcc 	andi	r2,r2,65535
 323e774:	1004923a 	slli	r2,r2,8
 323e778:	1007883a 	mov	r3,r2
 323e77c:	00bfc004 	movi	r2,-256
 323e780:	1884703a 	and	r2,r3,r2
 323e784:	2084b03a 	or	r2,r4,r2
 323e788:	1007883a 	mov	r3,r2
 323e78c:	e0bffb17 	ldw	r2,-20(fp)
 323e790:	10c0010d 	sth	r3,4(r2)
   pip->ip_len = htons((unshort)p->nb_plen);
 323e794:	e0bffc17 	ldw	r2,-16(fp)
 323e798:	10800417 	ldw	r2,16(r2)
 323e79c:	10bfffcc 	andi	r2,r2,65535
 323e7a0:	1004d23a 	srli	r2,r2,8
 323e7a4:	10803fcc 	andi	r2,r2,255
 323e7a8:	1009883a 	mov	r4,r2
 323e7ac:	e0bffc17 	ldw	r2,-16(fp)
 323e7b0:	10800417 	ldw	r2,16(r2)
 323e7b4:	10bfffcc 	andi	r2,r2,65535
 323e7b8:	1004923a 	slli	r2,r2,8
 323e7bc:	1007883a 	mov	r3,r2
 323e7c0:	00bfc004 	movi	r2,-256
 323e7c4:	1884703a 	and	r2,r3,r2
 323e7c8:	2084b03a 	or	r2,r4,r2
 323e7cc:	1007883a 	mov	r3,r2
 323e7d0:	e0bffb17 	ldw	r2,-20(fp)
 323e7d4:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;          /* install protocol ID (TCP, UDP, etc) */
 323e7d8:	e0fffb17 	ldw	r3,-20(fp)
 323e7dc:	e0bffe03 	ldbu	r2,-8(fp)
 323e7e0:	18800245 	stb	r2,9(r3)

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 323e7e4:	e0bffc17 	ldw	r2,-16(fp)
 323e7e8:	10800c17 	ldw	r2,48(r2)
 323e7ec:	e0bffa15 	stw	r2,-24(fp)
 323e7f0:	e0bffa17 	ldw	r2,-24(fp)
 323e7f4:	1005003a 	cmpeq	r2,r2,zero
 323e7f8:	1000121e 	bne	r2,zero,323e844 <ip_bldhead+0x158>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 323e7fc:	e0bffa17 	ldw	r2,-24(fp)
 323e800:	10800043 	ldbu	r2,1(r2)
 323e804:	10803fcc 	andi	r2,r2,255
 323e808:	1005003a 	cmpeq	r2,r2,zero
 323e80c:	1000051e 	bne	r2,zero,323e824 <ip_bldhead+0x138>
         pip->ip_time = sopts->ip_ttl;
 323e810:	e0bffa17 	ldw	r2,-24(fp)
 323e814:	10c00043 	ldbu	r3,1(r2)
 323e818:	e0bffb17 	ldw	r2,-20(fp)
 323e81c:	10c00205 	stb	r3,8(r2)
 323e820:	00000306 	br	323e830 <ip_bldhead+0x144>
	  else
         pip->ip_time = (u_char)IP_TTL;     /* default number of hops, really */
 323e824:	e0fffb17 	ldw	r3,-20(fp)
 323e828:	00801004 	movi	r2,64
 323e82c:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 323e830:	e0bffa17 	ldw	r2,-24(fp)
 323e834:	10c00003 	ldbu	r3,0(r2)
 323e838:	e0bffb17 	ldw	r2,-20(fp)
 323e83c:	10c00045 	stb	r3,1(r2)
 323e840:	00000506 	br	323e858 <ip_bldhead+0x16c>
   }
   else
   {
	  /* nope */
      pip->ip_time = (u_char)IP_TTL;       /* default number of hops, really */
 323e844:	e0bffb17 	ldw	r2,-20(fp)
 323e848:	00c01004 	movi	r3,64
 323e84c:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 323e850:	e0bffb17 	ldw	r2,-20(fp)
 323e854:	10000045 	stb	zero,1(r2)
   }
   
   pip->ip_chksum = IPXSUM;      /* clear checksum field for summing */
 323e858:	e0bffb17 	ldw	r2,-20(fp)
 323e85c:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 323e860:	e13ffb17 	ldw	r4,-20(fp)
 323e864:	01400284 	movi	r5,10
 323e868:	32259f80 	call	32259f8 <cksum>
 323e86c:	0084303a 	nor	r2,zero,r2
 323e870:	1007883a 	mov	r3,r2
 323e874:	e0bffb17 	ldw	r2,-20(fp)
 323e878:	10c0028d 	sth	r3,10(r2)
}
 323e87c:	e037883a 	mov	sp,fp
 323e880:	dfc00117 	ldw	ra,4(sp)
 323e884:	df000017 	ldw	fp,0(sp)
 323e888:	dec00204 	addi	sp,sp,8
 323e88c:	f800283a 	ret

0323e890 <ip_write_internal>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_write_internal(PACKET p)
{
 323e890:	deffed04 	addi	sp,sp,-76
 323e894:	dfc01215 	stw	ra,72(sp)
 323e898:	df001115 	stw	fp,68(sp)
 323e89c:	df001104 	addi	fp,sp,68
 323e8a0:	e13ffc15 	stw	r4,-16(fp)
   PACKET newpkt;
   unsigned maxbuflen;

#ifdef IP_MULTICAST
   /* If destination address is multicast, process multicast options */
   if (IN_MULTICAST(ntohl(p->fhost)))
 323e8a4:	e0bffc17 	ldw	r2,-16(fp)
 323e8a8:	10800717 	ldw	r2,28(r2)
 323e8ac:	1004d63a 	srli	r2,r2,24
 323e8b0:	10c03fcc 	andi	r3,r2,255
 323e8b4:	e0bffc17 	ldw	r2,-16(fp)
 323e8b8:	10800717 	ldw	r2,28(r2)
 323e8bc:	1004d23a 	srli	r2,r2,8
 323e8c0:	10bfc00c 	andi	r2,r2,65280
 323e8c4:	1886b03a 	or	r3,r3,r2
 323e8c8:	e0bffc17 	ldw	r2,-16(fp)
 323e8cc:	10800717 	ldw	r2,28(r2)
 323e8d0:	10bfc00c 	andi	r2,r2,65280
 323e8d4:	1004923a 	slli	r2,r2,8
 323e8d8:	1886b03a 	or	r3,r3,r2
 323e8dc:	e0bffc17 	ldw	r2,-16(fp)
 323e8e0:	10800717 	ldw	r2,28(r2)
 323e8e4:	10803fcc 	andi	r2,r2,255
 323e8e8:	1004963a 	slli	r2,r2,24
 323e8ec:	1884b03a 	or	r2,r3,r2
 323e8f0:	10fc002c 	andhi	r3,r2,61440
 323e8f4:	00b80034 	movhi	r2,57344
 323e8f8:	1880b31e 	bne	r3,r2,323ebc8 <ip_write_internal+0x338>
   {
      if (p->imo != NULL)
 323e8fc:	e0bffc17 	ldw	r2,-16(fp)
 323e900:	10800b17 	ldw	r2,44(r2)
 323e904:	1005003a 	cmpeq	r2,r2,zero
 323e908:	1000131e 	bne	r2,zero,323e958 <ip_write_internal+0xc8>
         if (p->imo->imo_multicast_netp)
 323e90c:	e0bffc17 	ldw	r2,-16(fp)
 323e910:	10800b17 	ldw	r2,44(r2)
 323e914:	10800017 	ldw	r2,0(r2)
 323e918:	1005003a 	cmpeq	r2,r2,zero
 323e91c:	1000061e 	bne	r2,zero,323e938 <ip_write_internal+0xa8>
            p->net = p->imo->imo_multicast_netp;
 323e920:	e0bffc17 	ldw	r2,-16(fp)
 323e924:	10800b17 	ldw	r2,44(r2)
 323e928:	10c00017 	ldw	r3,0(r2)
 323e92c:	e0bffc17 	ldw	r2,-16(fp)
 323e930:	10c00615 	stw	r3,24(r2)
 323e934:	00002606 	br	323e9d0 <ip_write_internal+0x140>
         else
            p->net = iproute(p->fhost, &firsthop);
 323e938:	e0bffc17 	ldw	r2,-16(fp)
 323e93c:	11000717 	ldw	r4,28(r2)
 323e940:	e17ffb04 	addi	r5,fp,-20
 323e944:	32404f00 	call	32404f0 <iproute>
 323e948:	1007883a 	mov	r3,r2
 323e94c:	e0bffc17 	ldw	r2,-16(fp)
 323e950:	10c00615 	stw	r3,24(r2)
 323e954:	00001e06 	br	323e9d0 <ip_write_internal+0x140>
      else
      {
         for (i = 0; i < ifNumber; i++)
 323e958:	e03ff815 	stw	zero,-32(fp)
 323e95c:	00001706 	br	323e9bc <ip_write_internal+0x12c>
            if (nets[i]->n_mcastlist)
 323e960:	e0bff817 	ldw	r2,-32(fp)
 323e964:	00c0c9b4 	movhi	r3,806
 323e968:	18f25a04 	addi	r3,r3,-13976
 323e96c:	1085883a 	add	r2,r2,r2
 323e970:	1085883a 	add	r2,r2,r2
 323e974:	10c5883a 	add	r2,r2,r3
 323e978:	10800017 	ldw	r2,0(r2)
 323e97c:	10802b17 	ldw	r2,172(r2)
 323e980:	1005003a 	cmpeq	r2,r2,zero
 323e984:	10000a1e 	bne	r2,zero,323e9b0 <ip_write_internal+0x120>
            {
               p->net = nets[i];
 323e988:	e0bff817 	ldw	r2,-32(fp)
 323e98c:	00c0c9b4 	movhi	r3,806
 323e990:	18f25a04 	addi	r3,r3,-13976
 323e994:	1085883a 	add	r2,r2,r2
 323e998:	1085883a 	add	r2,r2,r2
 323e99c:	10c5883a 	add	r2,r2,r3
 323e9a0:	10c00017 	ldw	r3,0(r2)
 323e9a4:	e0bffc17 	ldw	r2,-16(fp)
 323e9a8:	10c00615 	stw	r3,24(r2)
               break;
 323e9ac:	00000806 	br	323e9d0 <ip_write_internal+0x140>
            p->net = p->imo->imo_multicast_netp;
         else
            p->net = iproute(p->fhost, &firsthop);
      else
      {
         for (i = 0; i < ifNumber; i++)
 323e9b0:	e0bff817 	ldw	r2,-32(fp)
 323e9b4:	10800044 	addi	r2,r2,1
 323e9b8:	e0bff815 	stw	r2,-32(fp)
 323e9bc:	0080c974 	movhi	r2,805
 323e9c0:	10923204 	addi	r2,r2,18632
 323e9c4:	10c00017 	ldw	r3,0(r2)
 323e9c8:	e0bff817 	ldw	r2,-32(fp)
 323e9cc:	10ffe436 	bltu	r2,r3,323e960 <ip_write_internal+0xd0>
               break;
            }
      }

      /* Confirm that the outgoing interface supports multicast. */
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
 323e9d0:	e0bffc17 	ldw	r2,-16(fp)
 323e9d4:	10800617 	ldw	r2,24(r2)
 323e9d8:	1005003a 	cmpeq	r2,r2,zero
 323e9dc:	1000051e 	bne	r2,zero,323e9f4 <ip_write_internal+0x164>
 323e9e0:	e0bffc17 	ldw	r2,-16(fp)
 323e9e4:	10800617 	ldw	r2,24(r2)
 323e9e8:	10802b17 	ldw	r2,172(r2)
 323e9ec:	1004c03a 	cmpne	r2,r2,zero
 323e9f0:	10002e1e 	bne	r2,zero,323eaac <ip_write_internal+0x21c>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 323e9f4:	0080c974 	movhi	r2,805
 323e9f8:	10923104 	addi	r2,r2,18628
 323e9fc:	10800017 	ldw	r2,0(r2)
 323ea00:	1080840c 	andi	r2,r2,528
 323ea04:	1005003a 	cmpeq	r2,r2,zero
 323ea08:	1000181e 	bne	r2,zero,323ea6c <ip_write_internal+0x1dc>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 323ea0c:	e0bffc17 	ldw	r2,-16(fp)
 323ea10:	11800417 	ldw	r6,16(r2)
 323ea14:	e0bffc17 	ldw	r2,-16(fp)
 323ea18:	10800717 	ldw	r2,28(r2)
 323ea1c:	11c03fcc 	andi	r7,r2,255
 323ea20:	e0bffc17 	ldw	r2,-16(fp)
 323ea24:	10800717 	ldw	r2,28(r2)
 323ea28:	1004d23a 	srli	r2,r2,8
 323ea2c:	11003fcc 	andi	r4,r2,255
 323ea30:	e0bffc17 	ldw	r2,-16(fp)
 323ea34:	10800717 	ldw	r2,28(r2)
 323ea38:	1004d43a 	srli	r2,r2,16
 323ea3c:	10c03fcc 	andi	r3,r2,255
 323ea40:	e0bffc17 	ldw	r2,-16(fp)
 323ea44:	10800717 	ldw	r2,28(r2)
 323ea48:	1004d63a 	srli	r2,r2,24
 323ea4c:	d9000015 	stw	r4,0(sp)
 323ea50:	d8c00115 	stw	r3,4(sp)
 323ea54:	d8800215 	stw	r2,8(sp)
 323ea58:	0100c974 	movhi	r4,805
 323ea5c:	213e4404 	addi	r4,r4,-1776
 323ea60:	e17ffc17 	ldw	r5,-16(fp)
 323ea64:	3206adc0 	call	3206adc <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 323ea68:	322ab8c0 	call	322ab8c <dtrap>
         }
#endif
         ip_mib.ipOutNoRoutes++;
 323ea6c:	0080c9b4 	movhi	r2,806
 323ea70:	10b46004 	addi	r2,r2,-11904
 323ea74:	10800b17 	ldw	r2,44(r2)
 323ea78:	10c00044 	addi	r3,r2,1
 323ea7c:	0080c9b4 	movhi	r2,806
 323ea80:	10b46004 	addi	r2,r2,-11904
 323ea84:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 323ea88:	01000084 	movi	r4,2
 323ea8c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pk_free(p);
 323ea90:	e13ffc17 	ldw	r4,-16(fp)
 323ea94:	322a2dc0 	call	322a2dc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323ea98:	01000084 	movi	r4,2
 323ea9c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 323eaa0:	00bff7c4 	movi	r2,-33
 323eaa4:	e0bffd15 	stw	r2,-12(fp)
 323eaa8:	00015306 	br	323eff8 <ip_write_internal+0x768>
       * If we belong to the destination multicast group
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
 323eaac:	e0bffc17 	ldw	r2,-16(fp)
 323eab0:	11000717 	ldw	r4,28(r2)
 323eab4:	e0bffc17 	ldw	r2,-16(fp)
 323eab8:	11400617 	ldw	r5,24(r2)
 323eabc:	32436ec0 	call	32436ec <lookup_mcast>
 323eac0:	e0bff915 	stw	r2,-28(fp)
      if ((inm != NULL) &&
 323eac4:	e0bff917 	ldw	r2,-28(fp)
 323eac8:	1005003a 	cmpeq	r2,r2,zero
 323eacc:	10001f1e 	bne	r2,zero,323eb4c <ip_write_internal+0x2bc>
 323ead0:	e0bffc17 	ldw	r2,-16(fp)
 323ead4:	10800b17 	ldw	r2,44(r2)
 323ead8:	1005003a 	cmpeq	r2,r2,zero
 323eadc:	1000061e 	bne	r2,zero,323eaf8 <ip_write_internal+0x268>
 323eae0:	e0bffc17 	ldw	r2,-16(fp)
 323eae4:	10800b17 	ldw	r2,44(r2)
 323eae8:	10800143 	ldbu	r2,5(r2)
 323eaec:	10803fcc 	andi	r2,r2,255
 323eaf0:	1005003a 	cmpeq	r2,r2,zero
 323eaf4:	1000151e 	bne	r2,zero,323eb4c <ip_write_internal+0x2bc>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
      {
         p->type = IPTP;
 323eaf8:	e0fffc17 	ldw	r3,-16(fp)
 323eafc:	00800204 	movi	r2,8
 323eb00:	1880080d 	sth	r2,32(r3)
         pkt2 = ip_copypkt(p);
 323eb04:	e13ffc17 	ldw	r4,-16(fp)
 323eb08:	324075c0 	call	324075c <ip_copypkt>
 323eb0c:	e0bffa15 	stw	r2,-24(fp)
         if (pkt2)
 323eb10:	e0bffa17 	ldw	r2,-24(fp)
 323eb14:	1005003a 	cmpeq	r2,r2,zero
 323eb18:	10000c1e 	bne	r2,zero,323eb4c <ip_write_internal+0x2bc>
         {
            LOCK_NET_RESOURCE(RXQ_RESID);
 323eb1c:	01000044 	movi	r4,1
 323eb20:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
            putq(&rcvdq, (q_elt)pkt2);
 323eb24:	e17ffa17 	ldw	r5,-24(fp)
 323eb28:	0100c9b4 	movhi	r4,806
 323eb2c:	21319504 	addi	r4,r4,-14764
 323eb30:	322a51c0 	call	322a51c <putq>
            UNLOCK_NET_RESOURCE(RXQ_RESID);
 323eb34:	01000044 	movi	r4,1
 323eb38:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
            SignalPktDemux();
 323eb3c:	0080c974 	movhi	r2,805
 323eb40:	10925904 	addi	r2,r2,18788
 323eb44:	11000017 	ldw	r4,0(r2)
 323eb48:	321b1dc0 	call	321b1dc <OSSemPost>
       * Also, multicasts addressed to the loopback interface
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
 323eb4c:	e0bffc17 	ldw	r2,-16(fp)
 323eb50:	10800317 	ldw	r2,12(r2)
 323eb54:	e0bff715 	stw	r2,-36(fp)
      if ((pip->ip_time == 0) || 
 323eb58:	e0bff717 	ldw	r2,-36(fp)
 323eb5c:	10800203 	ldbu	r2,8(r2)
 323eb60:	10803fcc 	andi	r2,r2,255
 323eb64:	1005003a 	cmpeq	r2,r2,zero
 323eb68:	10000b1e 	bne	r2,zero,323eb98 <ip_write_internal+0x308>
 323eb6c:	e0bffc17 	ldw	r2,-16(fp)
 323eb70:	10800717 	ldw	r2,28(r2)
 323eb74:	10803fcc 	andi	r2,r2,255
 323eb78:	10801fe0 	cmpeqi	r2,r2,127
 323eb7c:	1000061e 	bne	r2,zero,323eb98 <ip_write_internal+0x308>
 323eb80:	e0bffc17 	ldw	r2,-16(fp)
 323eb84:	10c00717 	ldw	r3,28(r2)
 323eb88:	e0bffc17 	ldw	r2,-16(fp)
 323eb8c:	10800617 	ldw	r2,24(r2)
 323eb90:	10800a17 	ldw	r2,40(r2)
 323eb94:	1880081e 	bne	r3,r2,323ebb8 <ip_write_internal+0x328>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
          (p->fhost == p->net->n_ipaddr))
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 323eb98:	01000084 	movi	r4,2
 323eb9c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pk_free(p);
 323eba0:	e13ffc17 	ldw	r4,-16(fp)
 323eba4:	322a2dc0 	call	322a2dc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323eba8:	01000084 	movi	r4,2
 323ebac:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return(SUCCESS);
 323ebb0:	e03ffd15 	stw	zero,-12(fp)
 323ebb4:	00011006 	br	323eff8 <ip_write_internal+0x768>
      }

      firsthop = p->fhost;
 323ebb8:	e0bffc17 	ldw	r2,-16(fp)
 323ebbc:	10800717 	ldw	r2,28(r2)
 323ebc0:	e0bffb15 	stw	r2,-20(fp)

      goto sendit;
 323ebc4:	00004106 	br	323eccc <ip_write_internal+0x43c>
   }

#endif /* IP_MULTICAST */

   /* if this is a broadcast packet, use the caller-selected network */
   if (p->fhost == 0xFFFFFFFF)
 323ebc8:	e0bffc17 	ldw	r2,-16(fp)
 323ebcc:	10800717 	ldw	r2,28(r2)
 323ebd0:	10bfffd8 	cmpnei	r2,r2,-1
 323ebd4:	1000041e 	bne	r2,zero,323ebe8 <ip_write_internal+0x358>
   {
      firsthop = p->fhost;
 323ebd8:	e0bffc17 	ldw	r2,-16(fp)
 323ebdc:	10800717 	ldw	r2,28(r2)
 323ebe0:	e0bffb15 	stw	r2,-20(fp)
 323ebe4:	00003906 	br	323eccc <ip_write_internal+0x43c>
   }
   else
   {
      p->net = iproute(p->fhost, &firsthop);
 323ebe8:	e0bffc17 	ldw	r2,-16(fp)
 323ebec:	11000717 	ldw	r4,28(r2)
 323ebf0:	e17ffb04 	addi	r5,fp,-20
 323ebf4:	32404f00 	call	32404f0 <iproute>
 323ebf8:	1007883a 	mov	r3,r2
 323ebfc:	e0bffc17 	ldw	r2,-16(fp)
 323ec00:	10c00615 	stw	r3,24(r2)
      if (p->net == NULL)
 323ec04:	e0bffc17 	ldw	r2,-16(fp)
 323ec08:	10800617 	ldw	r2,24(r2)
 323ec0c:	1004c03a 	cmpne	r2,r2,zero
 323ec10:	10002e1e 	bne	r2,zero,323eccc <ip_write_internal+0x43c>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 323ec14:	0080c974 	movhi	r2,805
 323ec18:	10923104 	addi	r2,r2,18628
 323ec1c:	10800017 	ldw	r2,0(r2)
 323ec20:	1080840c 	andi	r2,r2,528
 323ec24:	1005003a 	cmpeq	r2,r2,zero
 323ec28:	1000181e 	bne	r2,zero,323ec8c <ip_write_internal+0x3fc>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 323ec2c:	e0bffc17 	ldw	r2,-16(fp)
 323ec30:	11800417 	ldw	r6,16(r2)
 323ec34:	e0bffc17 	ldw	r2,-16(fp)
 323ec38:	10800717 	ldw	r2,28(r2)
 323ec3c:	11c03fcc 	andi	r7,r2,255
 323ec40:	e0bffc17 	ldw	r2,-16(fp)
 323ec44:	10800717 	ldw	r2,28(r2)
 323ec48:	1004d23a 	srli	r2,r2,8
 323ec4c:	11003fcc 	andi	r4,r2,255
 323ec50:	e0bffc17 	ldw	r2,-16(fp)
 323ec54:	10800717 	ldw	r2,28(r2)
 323ec58:	1004d43a 	srli	r2,r2,16
 323ec5c:	10c03fcc 	andi	r3,r2,255
 323ec60:	e0bffc17 	ldw	r2,-16(fp)
 323ec64:	10800717 	ldw	r2,28(r2)
 323ec68:	1004d63a 	srli	r2,r2,24
 323ec6c:	d9000015 	stw	r4,0(sp)
 323ec70:	d8c00115 	stw	r3,4(sp)
 323ec74:	d8800215 	stw	r2,8(sp)
 323ec78:	0100c974 	movhi	r4,805
 323ec7c:	213e4404 	addi	r4,r4,-1776
 323ec80:	e17ffc17 	ldw	r5,-16(fp)
 323ec84:	3206adc0 	call	3206adc <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 323ec88:	322ab8c0 	call	322ab8c <dtrap>
         }
#endif   /* NPDEBUG */
         ip_mib.ipOutNoRoutes++;
 323ec8c:	0080c9b4 	movhi	r2,806
 323ec90:	10b46004 	addi	r2,r2,-11904
 323ec94:	10800b17 	ldw	r2,44(r2)
 323ec98:	10c00044 	addi	r3,r2,1
 323ec9c:	0080c9b4 	movhi	r2,806
 323eca0:	10b46004 	addi	r2,r2,-11904
 323eca4:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 323eca8:	01000084 	movi	r4,2
 323ecac:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pk_free(p);
 323ecb0:	e13ffc17 	ldw	r4,-16(fp)
 323ecb4:	322a2dc0 	call	322a2dc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323ecb8:	01000084 	movi	r4,2
 323ecbc:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 323ecc0:	00fff7c4 	movi	r3,-33
 323ecc4:	e0fffd15 	stw	r3,-12(fp)
 323ecc8:	0000cb06 	br	323eff8 <ip_write_internal+0x768>
#ifdef   IP_MULTICAST
sendit:  /* label used for multicast packets to skip routing logic */
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
 323eccc:	0080c974 	movhi	r2,805
 323ecd0:	10923104 	addi	r2,r2,18628
 323ecd4:	10800017 	ldw	r2,0(r2)
 323ecd8:	1080800c 	andi	r2,r2,512
 323ecdc:	1005003a 	cmpeq	r2,r2,zero
 323ece0:	1000231e 	bne	r2,zero,323ed70 <ip_write_internal+0x4e0>
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 323ece4:	e0bffc17 	ldw	r2,-16(fp)
 323ece8:	11400417 	ldw	r5,16(r2)
 323ecec:	e0bffc17 	ldw	r2,-16(fp)
 323ecf0:	10800717 	ldw	r2,28(r2)
 323ecf4:	11803fcc 	andi	r6,r2,255
 323ecf8:	e0bffc17 	ldw	r2,-16(fp)
 323ecfc:	10800717 	ldw	r2,28(r2)
 323ed00:	1004d23a 	srli	r2,r2,8
 323ed04:	11c03fcc 	andi	r7,r2,255
 323ed08:	e0bffc17 	ldw	r2,-16(fp)
 323ed0c:	10800717 	ldw	r2,28(r2)
 323ed10:	1004d43a 	srli	r2,r2,16
 323ed14:	10c03fcc 	andi	r3,r2,255
 323ed18:	e0bffc17 	ldw	r2,-16(fp)
 323ed1c:	10800717 	ldw	r2,28(r2)
 323ed20:	1004d63a 	srli	r2,r2,24
 323ed24:	d8c00015 	stw	r3,0(sp)
 323ed28:	d8800115 	stw	r2,4(sp)
 323ed2c:	0100c974 	movhi	r4,805
 323ed30:	213e5404 	addi	r4,r4,-1712
 323ed34:	3206adc0 	call	3206adc <printf>
       p->nb_plen, PUSH_IPADDR(p->fhost));
      dprintf(" route %u.%u.%u.%u\n", PUSH_IPADDR(firsthop));
 323ed38:	e0bffb17 	ldw	r2,-20(fp)
 323ed3c:	11403fcc 	andi	r5,r2,255
 323ed40:	e0bffb17 	ldw	r2,-20(fp)
 323ed44:	1004d23a 	srli	r2,r2,8
 323ed48:	11803fcc 	andi	r6,r2,255
 323ed4c:	e0bffb17 	ldw	r2,-20(fp)
 323ed50:	1004d43a 	srli	r2,r2,16
 323ed54:	11c03fcc 	andi	r7,r2,255
 323ed58:	e0bffb17 	ldw	r2,-20(fp)
 323ed5c:	1004d63a 	srli	r2,r2,24
 323ed60:	d8800015 	stw	r2,0(sp)
 323ed64:	0100c974 	movhi	r4,805
 323ed68:	213e5d04 	addi	r4,r4,-1676
 323ed6c:	3206adc0 	call	3206adc <printf>
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 323ed70:	e0bffc17 	ldw	r2,-16(fp)
 323ed74:	10800617 	ldw	r2,24(r2)
 323ed78:	10c00a17 	ldw	r3,40(r2)
 323ed7c:	e0bffc17 	ldw	r2,-16(fp)
 323ed80:	10800717 	ldw	r2,28(r2)
 323ed84:	18802a1e 	bne	r3,r2,323ee30 <ip_write_internal+0x5a0>
 323ed88:	e0bffc17 	ldw	r2,-16(fp)
 323ed8c:	10800717 	ldw	r2,28(r2)
 323ed90:	10803fcc 	andi	r2,r2,255
 323ed94:	10801fe0 	cmpeqi	r2,r2,127
 323ed98:	1000251e 	bne	r2,zero,323ee30 <ip_write_internal+0x5a0>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
   {
      if (!(p->net->n_flags & NF_NBPROT))
 323ed9c:	e0bffc17 	ldw	r2,-16(fp)
 323eda0:	10800617 	ldw	r2,24(r2)
 323eda4:	10802a17 	ldw	r2,168(r2)
 323eda8:	1080020c 	andi	r2,r2,8
 323edac:	1004c03a 	cmpne	r2,r2,zero
 323edb0:	10000a1e 	bne	r2,zero,323eddc <ip_write_internal+0x54c>
          * IP or ARP protocol header) and nb_type to the protocol
          * type, and set the NF_NBPROT flag in its interfaces'
          * n_flags fields.
          */
#ifdef NPDEBUG
         dtrap();
 323edb4:	322ab8c0 	call	322ab8c <dtrap>
#endif
         LOCK_NET_RESOURCE(FREEQ_RESID);
 323edb8:	01000084 	movi	r4,2
 323edbc:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pk_free(p);
 323edc0:	e13ffc17 	ldw	r4,-16(fp)
 323edc4:	322a2dc0 	call	322a2dc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323edc8:	01000084 	movi	r4,2
 323edcc:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_LOGIC;
 323edd0:	00bffd44 	movi	r2,-11
 323edd4:	e0bffd15 	stw	r2,-12(fp)
 323edd8:	00008706 	br	323eff8 <ip_write_internal+0x768>
      }
      p->type = IPTP;
 323eddc:	e0fffc17 	ldw	r3,-16(fp)
 323ede0:	00800204 	movi	r2,8
 323ede4:	1880080d 	sth	r2,32(r3)
      UNLOCK_NET_RESOURCE(NET_RESID);
 323ede8:	0009883a 	mov	r4,zero
 323edec:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(RXQ_RESID);
 323edf0:	01000044 	movi	r4,1
 323edf4:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      putq(&rcvdq, (q_elt)p);
 323edf8:	e17ffc17 	ldw	r5,-16(fp)
 323edfc:	0100c9b4 	movhi	r4,806
 323ee00:	21319504 	addi	r4,r4,-14764
 323ee04:	322a51c0 	call	322a51c <putq>
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 323ee08:	01000044 	movi	r4,1
 323ee0c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(NET_RESID);
 323ee10:	0009883a 	mov	r4,zero
 323ee14:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);

      SignalPktDemux();
 323ee18:	0080c974 	movhi	r2,805
 323ee1c:	10925904 	addi	r2,r2,18788
 323ee20:	11000017 	ldw	r4,0(r2)
 323ee24:	321b1dc0 	call	321b1dc <OSSemPost>

      return SUCCESS;
 323ee28:	e03ffd15 	stw	zero,-12(fp)
 323ee2c:	00007206 	br	323eff8 <ip_write_internal+0x768>
   }

   /* determine if the buffer that needs to be transmitted is interrupt-safe */
   intrsafe_buf = ((p->flags & PKF_INTRUNSAFE) ? 0 : 1);
 323ee30:	e0bffc17 	ldw	r2,-16(fp)
 323ee34:	10800a17 	ldw	r2,40(r2)
 323ee38:	1080040c 	andi	r2,r2,16
 323ee3c:	1005003a 	cmpeq	r2,r2,zero
 323ee40:	e0bff605 	stb	r2,-40(fp)
   /* obtain the length of the largest interrupt-safe buffer that can be 
    * allocated via pk_alloc () */
   maxbuflen = pk_get_max_intrsafe_buf_len ();
 323ee44:	322a3880 	call	322a388 <pk_get_max_intrsafe_buf_len>
 323ee48:	e0bff315 	stw	r2,-52(fp)
    * the original buffer is interrupt-safe, we just need to consider the
    * MTU of the egress interface.  If the original buffer is interrupt-
    * unsafe, we compute the MIN of the largest interrupt-safe buffer that
    * we can use and the MTU of the egress interface (since we must satisfy
    * both constraints) */
   if (!intrsafe_buf)
 323ee4c:	e0bff603 	ldbu	r2,-40(fp)
 323ee50:	1004c03a 	cmpne	r2,r2,zero
 323ee54:	10000e1e 	bne	r2,zero,323ee90 <ip_write_internal+0x600>
       limit = MIN(maxbuflen,p->net->n_mtu);
 323ee58:	e0bffc17 	ldw	r2,-16(fp)
 323ee5c:	10800617 	ldw	r2,24(r2)
 323ee60:	10800917 	ldw	r2,36(r2)
 323ee64:	e0fff317 	ldw	r3,-52(fp)
 323ee68:	e0ffff15 	stw	r3,-4(fp)
 323ee6c:	e0bffe15 	stw	r2,-8(fp)
 323ee70:	e0bfff17 	ldw	r2,-4(fp)
 323ee74:	e0fffe17 	ldw	r3,-8(fp)
 323ee78:	10c0022e 	bgeu	r2,r3,323ee84 <ip_write_internal+0x5f4>
 323ee7c:	e0bfff17 	ldw	r2,-4(fp)
 323ee80:	e0bffe15 	stw	r2,-8(fp)
 323ee84:	e0fffe17 	ldw	r3,-8(fp)
 323ee88:	e0fff515 	stw	r3,-44(fp)
 323ee8c:	00000406 	br	323eea0 <ip_write_internal+0x610>
   else
       limit = p->net->n_mtu;
 323ee90:	e0bffc17 	ldw	r2,-16(fp)
 323ee94:	10800617 	ldw	r2,24(r2)
 323ee98:	10800917 	ldw	r2,36(r2)
 323ee9c:	e0bff515 	stw	r2,-44(fp)

   if ((p->nb_plen + p->net->n_lnh) > limit)
 323eea0:	e0bffc17 	ldw	r2,-16(fp)
 323eea4:	10c00417 	ldw	r3,16(r2)
 323eea8:	e0bffc17 	ldw	r2,-16(fp)
 323eeac:	10800617 	ldw	r2,24(r2)
 323eeb0:	10800817 	ldw	r2,32(r2)
 323eeb4:	1887883a 	add	r3,r3,r2
 323eeb8:	e0bff517 	ldw	r2,-44(fp)
 323eebc:	10c0072e 	bgeu	r2,r3,323eedc <ip_write_internal+0x64c>
   {
#ifdef IP_FRAGMENTS
      int err;
      err = ip_fragment(p, firsthop);
 323eec0:	e17ffb17 	ldw	r5,-20(fp)
 323eec4:	e13ffc17 	ldw	r4,-16(fp)
 323eec8:	323fb680 	call	323fb68 <ip_fragment>
 323eecc:	e0bff215 	stw	r2,-56(fp)
      IN_PROFILER(PF_IP, PF_EXIT);
      return(err);
 323eed0:	e0bff217 	ldw	r2,-56(fp)
 323eed4:	e0bffd15 	stw	r2,-12(fp)
 323eed8:	00004706 	br	323eff8 <ip_write_internal+0x768>
   }
   else
   {
      /* fragmentation is not required; check to see if we need to copy out of
       * an interrupt-unsafe buffer */ 
      if (!intrsafe_buf)
 323eedc:	e0bff603 	ldbu	r2,-40(fp)
 323eee0:	1004c03a 	cmpne	r2,r2,zero
 323eee4:	1000401e 	bne	r2,zero,323efe8 <ip_write_internal+0x758>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 323eee8:	01000084 	movi	r4,2
 323eeec:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         newpkt = pk_alloc(p->nb_plen + p->net->n_lnh);
 323eef0:	e0bffc17 	ldw	r2,-16(fp)
 323eef4:	10c00417 	ldw	r3,16(r2)
 323eef8:	e0bffc17 	ldw	r2,-16(fp)
 323eefc:	10800617 	ldw	r2,24(r2)
 323ef00:	10800817 	ldw	r2,32(r2)
 323ef04:	1889883a 	add	r4,r3,r2
 323ef08:	3229f480 	call	3229f48 <pk_alloc>
 323ef0c:	e0bff415 	stw	r2,-48(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323ef10:	01000084 	movi	r4,2
 323ef14:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         if (newpkt == 0)
 323ef18:	e0bff417 	ldw	r2,-48(fp)
 323ef1c:	1004c03a 	cmpne	r2,r2,zero
 323ef20:	1000091e 	bne	r2,zero,323ef48 <ip_write_internal+0x6b8>
         {
            /* can't allocate interrupt-safe buffer, so free the packet that 
             * we are working with */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 323ef24:	01000084 	movi	r4,2
 323ef28:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
            pk_free(p);
 323ef2c:	e13ffc17 	ldw	r4,-16(fp)
 323ef30:	322a2dc0 	call	322a2dc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323ef34:	01000084 	movi	r4,2
 323ef38:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NOBUFFER;
 323ef3c:	00fffac4 	movi	r3,-21
 323ef40:	e0fffd15 	stw	r3,-12(fp)
 323ef44:	00002c06 	br	323eff8 <ip_write_internal+0x768>
         }
         else
         {
            /* copy from interrupt-unsafe buffer into interrupt-safe buffer */
            newpkt->nb_prot = newpkt->nb_buff + p->net->n_lnh;
 323ef48:	e0bff417 	ldw	r2,-48(fp)
 323ef4c:	10c00117 	ldw	r3,4(r2)
 323ef50:	e0bffc17 	ldw	r2,-16(fp)
 323ef54:	10800617 	ldw	r2,24(r2)
 323ef58:	10800817 	ldw	r2,32(r2)
 323ef5c:	1887883a 	add	r3,r3,r2
 323ef60:	e0bff417 	ldw	r2,-48(fp)
 323ef64:	10c00315 	stw	r3,12(r2)
            MEMCPY(newpkt->nb_prot, p->nb_prot, p->nb_plen);
 323ef68:	e0bff417 	ldw	r2,-48(fp)
 323ef6c:	10c00317 	ldw	r3,12(r2)
 323ef70:	e0bffc17 	ldw	r2,-16(fp)
 323ef74:	11400317 	ldw	r5,12(r2)
 323ef78:	e0bffc17 	ldw	r2,-16(fp)
 323ef7c:	10800417 	ldw	r2,16(r2)
 323ef80:	1809883a 	mov	r4,r3
 323ef84:	100d883a 	mov	r6,r2
 323ef88:	32067cc0 	call	32067cc <memcpy>
            /* setup various fields in the newly allocated PACKET structure */
            newpkt->nb_plen = p->nb_plen;
 323ef8c:	e0bffc17 	ldw	r2,-16(fp)
 323ef90:	10c00417 	ldw	r3,16(r2)
 323ef94:	e0bff417 	ldw	r2,-48(fp)
 323ef98:	10c00415 	stw	r3,16(r2)
            newpkt->net = p->net;
 323ef9c:	e0bffc17 	ldw	r2,-16(fp)
 323efa0:	10c00617 	ldw	r3,24(r2)
 323efa4:	e0bff417 	ldw	r2,-48(fp)
 323efa8:	10c00615 	stw	r3,24(r2)
            newpkt->fhost = p->fhost;
 323efac:	e0bffc17 	ldw	r2,-16(fp)
 323efb0:	10c00717 	ldw	r3,28(r2)
 323efb4:	e0bff417 	ldw	r2,-48(fp)
 323efb8:	10c00715 	stw	r3,28(r2)
            /* free the original packet since it is no longer needed */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 323efbc:	01000084 	movi	r4,2
 323efc0:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
            pk_free(p);
 323efc4:	e13ffc17 	ldw	r4,-16(fp)
 323efc8:	322a2dc0 	call	322a2dc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323efcc:	01000084 	movi	r4,2
 323efd0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            /* send packet to MAC layer. This will try to resolve MAC layer addressing 
             * and send packet. ip2mac() can return SUCCESS, PENDING, or error codes. 
             */
            return(ip2mac(newpkt, firsthop));
 323efd4:	e17ffb17 	ldw	r5,-20(fp)
 323efd8:	e13ff417 	ldw	r4,-48(fp)
 323efdc:	32237940 	call	3223794 <ip2mac>
 323efe0:	e0bffd15 	stw	r2,-12(fp)
 323efe4:	00000406 	br	323eff8 <ip_write_internal+0x768>
      else
      {
         /* since the packet is in an interrupt-safe buffer, it can be passed to 
          * ip2mac () without any additional work. */
         IN_PROFILER(PF_IP, PF_EXIT);
         return(ip2mac(p, firsthop));
 323efe8:	e17ffb17 	ldw	r5,-20(fp)
 323efec:	e13ffc17 	ldw	r4,-16(fp)
 323eff0:	32237940 	call	3223794 <ip2mac>
 323eff4:	e0bffd15 	stw	r2,-12(fp)
 323eff8:	e0bffd17 	ldw	r2,-12(fp)
      }
   }
}
 323effc:	e037883a 	mov	sp,fp
 323f000:	dfc00117 	ldw	ra,4(sp)
 323f004:	df000017 	ldw	fp,0(sp)
 323f008:	dec00204 	addi	sp,sp,8
 323f00c:	f800283a 	ret

0323f010 <ip_write>:

int
ip_write(
   u_char   prot,
   PACKET   p)
{
 323f010:	defff904 	addi	sp,sp,-28
 323f014:	dfc00615 	stw	ra,24(sp)
 323f018:	df000515 	stw	fp,20(sp)
 323f01c:	df000504 	addi	fp,sp,20
 323f020:	e17fff15 	stw	r5,-4(fp)
 323f024:	e13ffe05 	stb	r4,-8(fp)
   u_char ttl;
   struct ip_socopts *sopts;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 323f028:	0080c9b4 	movhi	r2,806
 323f02c:	10b46004 	addi	r2,r2,-11904
 323f030:	10800917 	ldw	r2,36(r2)
 323f034:	10c00044 	addi	r3,r2,1
 323f038:	0080c9b4 	movhi	r2,806
 323f03c:	10b46004 	addi	r2,r2,-11904
 323f040:	10c00915 	stw	r3,36(r2)

   /* make room for IP header, and form a pointer to it (pip) */
   p->nb_prot -= sizeof(struct ip);
 323f044:	e0bfff17 	ldw	r2,-4(fp)
 323f048:	10800317 	ldw	r2,12(r2)
 323f04c:	10fffb04 	addi	r3,r2,-20
 323f050:	e0bfff17 	ldw	r2,-4(fp)
 323f054:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 323f058:	e0bfff17 	ldw	r2,-4(fp)
 323f05c:	10800417 	ldw	r2,16(r2)
 323f060:	10c00504 	addi	r3,r2,20
 323f064:	e0bfff17 	ldw	r2,-4(fp)
 323f068:	10c00415 	stw	r3,16(r2)
   pip = (struct ip*)(p->nb_prot);
 323f06c:	e0bfff17 	ldw	r2,-4(fp)
 323f070:	10800317 	ldw	r2,12(r2)
 323f074:	e0bffd15 	stw	r2,-12(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 323f078:	e0fffd17 	ldw	r3,-12(fp)
 323f07c:	00801144 	movi	r2,69
 323f080:	18800005 	stb	r2,0(r3)
   pip->ip_flgs_foff = 0;        /* clear fragmentation info field */
 323f084:	e0bffd17 	ldw	r2,-12(fp)
 323f088:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 323f08c:	d0a04c17 	ldw	r2,-32464(gp)
 323f090:	10bfffcc 	andi	r2,r2,65535
 323f094:	1004d23a 	srli	r2,r2,8
 323f098:	10803fcc 	andi	r2,r2,255
 323f09c:	1009883a 	mov	r4,r2
 323f0a0:	d0a04c17 	ldw	r2,-32464(gp)
 323f0a4:	10bfffcc 	andi	r2,r2,65535
 323f0a8:	1004923a 	slli	r2,r2,8
 323f0ac:	1007883a 	mov	r3,r2
 323f0b0:	00bfc004 	movi	r2,-256
 323f0b4:	1884703a 	and	r2,r3,r2
 323f0b8:	2084b03a 	or	r2,r4,r2
 323f0bc:	1007883a 	mov	r3,r2
 323f0c0:	e0bffd17 	ldw	r2,-12(fp)
 323f0c4:	10c0010d 	sth	r3,4(r2)
   uid++;
 323f0c8:	d0a04c17 	ldw	r2,-32464(gp)
 323f0cc:	10800044 	addi	r2,r2,1
 323f0d0:	d0a04c15 	stw	r2,-32464(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 323f0d4:	e0bfff17 	ldw	r2,-4(fp)
 323f0d8:	10800417 	ldw	r2,16(r2)
 323f0dc:	10bfffcc 	andi	r2,r2,65535
 323f0e0:	1004d23a 	srli	r2,r2,8
 323f0e4:	10803fcc 	andi	r2,r2,255
 323f0e8:	1009883a 	mov	r4,r2
 323f0ec:	e0bfff17 	ldw	r2,-4(fp)
 323f0f0:	10800417 	ldw	r2,16(r2)
 323f0f4:	10bfffcc 	andi	r2,r2,65535
 323f0f8:	1004923a 	slli	r2,r2,8
 323f0fc:	1007883a 	mov	r3,r2
 323f100:	00bfc004 	movi	r2,-256
 323f104:	1884703a 	and	r2,r3,r2
 323f108:	2084b03a 	or	r2,r4,r2
 323f10c:	1007883a 	mov	r3,r2
 323f110:	e0bffd17 	ldw	r2,-12(fp)
 323f114:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 323f118:	e0fffd17 	ldw	r3,-12(fp)
 323f11c:	e0bffe03 	ldbu	r2,-8(fp)
 323f120:	18800245 	stb	r2,9(r3)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 323f124:	e0bffd17 	ldw	r2,-12(fp)
 323f128:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 323f12c:	00801004 	movi	r2,64
 323f130:	e0bffc05 	stb	r2,-16(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 323f134:	e0bfff17 	ldw	r2,-4(fp)
 323f138:	10800717 	ldw	r2,28(r2)
 323f13c:	1004d63a 	srli	r2,r2,24
 323f140:	10c03fcc 	andi	r3,r2,255
 323f144:	e0bfff17 	ldw	r2,-4(fp)
 323f148:	10800717 	ldw	r2,28(r2)
 323f14c:	1004d23a 	srli	r2,r2,8
 323f150:	10bfc00c 	andi	r2,r2,65280
 323f154:	1886b03a 	or	r3,r3,r2
 323f158:	e0bfff17 	ldw	r2,-4(fp)
 323f15c:	10800717 	ldw	r2,28(r2)
 323f160:	10bfc00c 	andi	r2,r2,65280
 323f164:	1004923a 	slli	r2,r2,8
 323f168:	1886b03a 	or	r3,r3,r2
 323f16c:	e0bfff17 	ldw	r2,-4(fp)
 323f170:	10800717 	ldw	r2,28(r2)
 323f174:	10803fcc 	andi	r2,r2,255
 323f178:	1004963a 	slli	r2,r2,24
 323f17c:	1884b03a 	or	r2,r3,r2
 323f180:	10fc002c 	andhi	r3,r2,61440
 323f184:	00b80034 	movhi	r2,57344
 323f188:	1880081e 	bne	r3,r2,323f1ac <ip_write+0x19c>
 323f18c:	e0bfff17 	ldw	r2,-4(fp)
 323f190:	10800b17 	ldw	r2,44(r2)
 323f194:	1005003a 	cmpeq	r2,r2,zero
 323f198:	1000041e 	bne	r2,zero,323f1ac <ip_write+0x19c>
      ttl = p->imo->imo_multicast_ttl;
 323f19c:	e0bfff17 	ldw	r2,-4(fp)
 323f1a0:	10800b17 	ldw	r2,44(r2)
 323f1a4:	10800103 	ldbu	r2,4(r2)
 323f1a8:	e0bffc05 	stb	r2,-16(fp)
#endif /* IP_MULTICAST */

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 323f1ac:	e0bfff17 	ldw	r2,-4(fp)
 323f1b0:	10800c17 	ldw	r2,48(r2)
 323f1b4:	e0bffb15 	stw	r2,-20(fp)
 323f1b8:	e0bffb17 	ldw	r2,-20(fp)
 323f1bc:	1005003a 	cmpeq	r2,r2,zero
 323f1c0:	1000121e 	bne	r2,zero,323f20c <ip_write+0x1fc>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 323f1c4:	e0bffb17 	ldw	r2,-20(fp)
 323f1c8:	10800043 	ldbu	r2,1(r2)
 323f1cc:	10803fcc 	andi	r2,r2,255
 323f1d0:	1005003a 	cmpeq	r2,r2,zero
 323f1d4:	1000051e 	bne	r2,zero,323f1ec <ip_write+0x1dc>
         pip->ip_time = sopts->ip_ttl;
 323f1d8:	e0bffb17 	ldw	r2,-20(fp)
 323f1dc:	10c00043 	ldbu	r3,1(r2)
 323f1e0:	e0bffd17 	ldw	r2,-12(fp)
 323f1e4:	10c00205 	stb	r3,8(r2)
 323f1e8:	00000306 	br	323f1f8 <ip_write+0x1e8>
	  else
         pip->ip_time = ttl;
 323f1ec:	e0fffd17 	ldw	r3,-12(fp)
 323f1f0:	e0bffc03 	ldbu	r2,-16(fp)
 323f1f4:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 323f1f8:	e0bffb17 	ldw	r2,-20(fp)
 323f1fc:	10c00003 	ldbu	r3,0(r2)
 323f200:	e0bffd17 	ldw	r2,-12(fp)
 323f204:	10c00045 	stb	r3,1(r2)
 323f208:	00000506 	br	323f220 <ip_write+0x210>
   }
   else
   {
	  /* nope */
      pip->ip_time = ttl;
 323f20c:	e0bffd17 	ldw	r2,-12(fp)
 323f210:	e0fffc03 	ldbu	r3,-16(fp)
 323f214:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 323f218:	e0bffd17 	ldw	r2,-12(fp)
 323f21c:	10000045 	stb	zero,1(r2)
   }
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum(pip, 10);
 323f220:	e13ffd17 	ldw	r4,-12(fp)
 323f224:	01400284 	movi	r5,10
 323f228:	32259f80 	call	32259f8 <cksum>
 323f22c:	0084303a 	nor	r2,zero,r2
 323f230:	1007883a 	mov	r3,r2
 323f234:	e0bffd17 	ldw	r2,-12(fp)
 323f238:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 323f23c:	e13fff17 	ldw	r4,-4(fp)
 323f240:	323e8900 	call	323e890 <ip_write_internal>
}
 323f244:	e037883a 	mov	sp,fp
 323f248:	dfc00117 	ldw	ra,4(sp)
 323f24c:	df000017 	ldw	fp,0(sp)
 323f250:	dec00204 	addi	sp,sp,8
 323f254:	f800283a 	ret

0323f258 <ip_write2>:
 * OUTPUT: This function returns the return code from 
 *         ip_write_internal ().
 */

int ip_write2 (u_char prot, PACKET p, u_char * optp)
{
 323f258:	defff504 	addi	sp,sp,-44
 323f25c:	dfc00a15 	stw	ra,40(sp)
 323f260:	df000915 	stw	fp,36(sp)
 323f264:	df000904 	addi	fp,sp,36
 323f268:	e17ffe15 	stw	r5,-8(fp)
 323f26c:	e1bfff15 	stw	r6,-4(fp)
 323f270:	e13ffd05 	stb	r4,-12(fp)
   struct ip * pip;
   u_char ttl;
   struct ip_socopts * sopts;
   u_char iphlen = sizeof (struct ip);
 323f274:	00800504 	movi	r2,20
 323f278:	e0bff905 	stb	r2,-28(fp)
   u_char iphlen_pad;
   u_char i;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 323f27c:	0080c9b4 	movhi	r2,806
 323f280:	10b46004 	addi	r2,r2,-11904
 323f284:	10800917 	ldw	r2,36(r2)
 323f288:	10c00044 	addi	r3,r2,1
 323f28c:	0080c9b4 	movhi	r2,806
 323f290:	10b46004 	addi	r2,r2,-11904
 323f294:	10c00915 	stw	r3,36(r2)

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 323f298:	e0bfff17 	ldw	r2,-4(fp)
 323f29c:	e0bff815 	stw	r2,-32(fp)
 323f2a0:	00000c06 	br	323f2d4 <ip_write2+0x7c>
   {
      /* account for options, if any (caller has already created
       * adequate space for the requested option) */
      switch (*tmpp)
 323f2a4:	e0bff817 	ldw	r2,-32(fp)
 323f2a8:	10800003 	ldbu	r2,0(r2)
 323f2ac:	10803fcc 	andi	r2,r2,255
 323f2b0:	10800520 	cmpeqi	r2,r2,20
 323f2b4:	1000011e 	bne	r2,zero,323f2bc <ip_write2+0x64>
 323f2b8:	00000306 	br	323f2c8 <ip_write2+0x70>
      {
         case IP_RTR_ALERT_OPT:
            iphlen += IP_RTR_ALERT_OPT_SIZE;
 323f2bc:	e0bff903 	ldbu	r2,-28(fp)
 323f2c0:	10800104 	addi	r2,r2,4
 323f2c4:	e0bff905 	stb	r2,-28(fp)
   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 323f2c8:	e0bff817 	ldw	r2,-32(fp)
 323f2cc:	10800044 	addi	r2,r2,1
 323f2d0:	e0bff815 	stw	r2,-32(fp)
 323f2d4:	e0bff817 	ldw	r2,-32(fp)
 323f2d8:	10800003 	ldbu	r2,0(r2)
 323f2dc:	10803fcc 	andi	r2,r2,255
 323f2e0:	1004c03a 	cmpne	r2,r2,zero
 323f2e4:	103fef1e 	bne	r2,zero,323f2a4 <ip_write2+0x4c>
   }

   /* compute the amount of padding required, if any (to ensure
    * that the IP header (including options) ends on a dword
    * (four byte) boundary */
   if (iphlen & 0x3)
 323f2e8:	e0bff903 	ldbu	r2,-28(fp)
 323f2ec:	108000cc 	andi	r2,r2,3
 323f2f0:	1005003a 	cmpeq	r2,r2,zero
 323f2f4:	1000071e 	bne	r2,zero,323f314 <ip_write2+0xbc>
      iphlen_pad = 4 - (iphlen & 0x3);
 323f2f8:	e0bff903 	ldbu	r2,-28(fp)
 323f2fc:	108000cc 	andi	r2,r2,3
 323f300:	1007883a 	mov	r3,r2
 323f304:	00800104 	movi	r2,4
 323f308:	10c5c83a 	sub	r2,r2,r3
 323f30c:	e0bff745 	stb	r2,-35(fp)
 323f310:	00000106 	br	323f318 <ip_write2+0xc0>
   else iphlen_pad = 0; /* no header padding required */
 323f314:	e03ff745 	stb	zero,-35(fp)
   /* the packet passed to ip_write2 () has its nb_prot set to
    * point to start of the protocol's (e.g., IGMP) data, and 
    * nb_plen set to the length of that data.  locate start of 
    * the IP header (account for IP options), and form a pointer 
    * to it (pip) */
   p->nb_prot -= (iphlen + iphlen_pad);
 323f318:	e0bffe17 	ldw	r2,-8(fp)
 323f31c:	11000317 	ldw	r4,12(r2)
 323f320:	e0fff903 	ldbu	r3,-28(fp)
 323f324:	e0bff743 	ldbu	r2,-35(fp)
 323f328:	1885883a 	add	r2,r3,r2
 323f32c:	2087c83a 	sub	r3,r4,r2
 323f330:	e0bffe17 	ldw	r2,-8(fp)
 323f334:	10c00315 	stw	r3,12(r2)
   /* add padding length to the total length of the IP datagram */
   p->nb_plen += (iphlen + iphlen_pad);
 323f338:	e0bffe17 	ldw	r2,-8(fp)
 323f33c:	11000417 	ldw	r4,16(r2)
 323f340:	e0fff903 	ldbu	r3,-28(fp)
 323f344:	e0bff743 	ldbu	r2,-35(fp)
 323f348:	1885883a 	add	r2,r3,r2
 323f34c:	2087883a 	add	r3,r4,r2
 323f350:	e0bffe17 	ldw	r2,-8(fp)
 323f354:	10c00415 	stw	r3,16(r2)
   pip = (struct ip *) (p->nb_prot);
 323f358:	e0bffe17 	ldw	r2,-8(fp)
 323f35c:	10800317 	ldw	r2,12(r2)
 323f360:	e0bffc15 	stw	r2,-16(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = ((IP_VER << 4) | ((iphlen + iphlen_pad) >> 2));
 323f364:	e0fff903 	ldbu	r3,-28(fp)
 323f368:	e0bff743 	ldbu	r2,-35(fp)
 323f36c:	1885883a 	add	r2,r3,r2
 323f370:	1005d0ba 	srai	r2,r2,2
 323f374:	10801014 	ori	r2,r2,64
 323f378:	1007883a 	mov	r3,r2
 323f37c:	e0bffc17 	ldw	r2,-16(fp)
 323f380:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0; /* clear fragmentation info field */
 323f384:	e0bffc17 	ldw	r2,-16(fp)
 323f388:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 323f38c:	d0a04c17 	ldw	r2,-32464(gp)
 323f390:	10bfffcc 	andi	r2,r2,65535
 323f394:	1004d23a 	srli	r2,r2,8
 323f398:	10803fcc 	andi	r2,r2,255
 323f39c:	1009883a 	mov	r4,r2
 323f3a0:	d0a04c17 	ldw	r2,-32464(gp)
 323f3a4:	10bfffcc 	andi	r2,r2,65535
 323f3a8:	1004923a 	slli	r2,r2,8
 323f3ac:	1007883a 	mov	r3,r2
 323f3b0:	00bfc004 	movi	r2,-256
 323f3b4:	1884703a 	and	r2,r3,r2
 323f3b8:	2084b03a 	or	r2,r4,r2
 323f3bc:	1007883a 	mov	r3,r2
 323f3c0:	e0bffc17 	ldw	r2,-16(fp)
 323f3c4:	10c0010d 	sth	r3,4(r2)
   uid++;
 323f3c8:	d0a04c17 	ldw	r2,-32464(gp)
 323f3cc:	10800044 	addi	r2,r2,1
 323f3d0:	d0a04c15 	stw	r2,-32464(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 323f3d4:	e0bffe17 	ldw	r2,-8(fp)
 323f3d8:	10800417 	ldw	r2,16(r2)
 323f3dc:	10bfffcc 	andi	r2,r2,65535
 323f3e0:	1004d23a 	srli	r2,r2,8
 323f3e4:	10803fcc 	andi	r2,r2,255
 323f3e8:	1009883a 	mov	r4,r2
 323f3ec:	e0bffe17 	ldw	r2,-8(fp)
 323f3f0:	10800417 	ldw	r2,16(r2)
 323f3f4:	10bfffcc 	andi	r2,r2,65535
 323f3f8:	1004923a 	slli	r2,r2,8
 323f3fc:	1007883a 	mov	r3,r2
 323f400:	00bfc004 	movi	r2,-256
 323f404:	1884703a 	and	r2,r3,r2
 323f408:	2084b03a 	or	r2,r4,r2
 323f40c:	1007883a 	mov	r3,r2
 323f410:	e0bffc17 	ldw	r2,-16(fp)
 323f414:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 323f418:	e0fffc17 	ldw	r3,-16(fp)
 323f41c:	e0bffd03 	ldbu	r2,-12(fp)
 323f420:	18800245 	stb	r2,9(r3)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 323f424:	e0bffc17 	ldw	r2,-16(fp)
 323f428:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 323f42c:	00801004 	movi	r2,64
 323f430:	e0bffb05 	stb	r2,-20(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 323f434:	e0bffe17 	ldw	r2,-8(fp)
 323f438:	10800717 	ldw	r2,28(r2)
 323f43c:	1004d63a 	srli	r2,r2,24
 323f440:	10c03fcc 	andi	r3,r2,255
 323f444:	e0bffe17 	ldw	r2,-8(fp)
 323f448:	10800717 	ldw	r2,28(r2)
 323f44c:	1004d23a 	srli	r2,r2,8
 323f450:	10bfc00c 	andi	r2,r2,65280
 323f454:	1886b03a 	or	r3,r3,r2
 323f458:	e0bffe17 	ldw	r2,-8(fp)
 323f45c:	10800717 	ldw	r2,28(r2)
 323f460:	10bfc00c 	andi	r2,r2,65280
 323f464:	1004923a 	slli	r2,r2,8
 323f468:	1886b03a 	or	r3,r3,r2
 323f46c:	e0bffe17 	ldw	r2,-8(fp)
 323f470:	10800717 	ldw	r2,28(r2)
 323f474:	10803fcc 	andi	r2,r2,255
 323f478:	1004963a 	slli	r2,r2,24
 323f47c:	1884b03a 	or	r2,r3,r2
 323f480:	10fc002c 	andhi	r3,r2,61440
 323f484:	00b80034 	movhi	r2,57344
 323f488:	1880081e 	bne	r3,r2,323f4ac <ip_write2+0x254>
 323f48c:	e0bffe17 	ldw	r2,-8(fp)
 323f490:	10800b17 	ldw	r2,44(r2)
 323f494:	1005003a 	cmpeq	r2,r2,zero
 323f498:	1000041e 	bne	r2,zero,323f4ac <ip_write2+0x254>
      ttl = p->imo->imo_multicast_ttl;
 323f49c:	e0bffe17 	ldw	r2,-8(fp)
 323f4a0:	10800b17 	ldw	r2,44(r2)
 323f4a4:	10800103 	ldbu	r2,4(r2)
 323f4a8:	e0bffb05 	stb	r2,-20(fp)
#endif /* IP_MULTICAST */

   /* have TOS or TTL been set (via socket options)? */
   if ((sopts = p->soxopts))
 323f4ac:	e0bffe17 	ldw	r2,-8(fp)
 323f4b0:	10800c17 	ldw	r2,48(r2)
 323f4b4:	e0bffa15 	stw	r2,-24(fp)
 323f4b8:	e0bffa17 	ldw	r2,-24(fp)
 323f4bc:	1005003a 	cmpeq	r2,r2,zero
 323f4c0:	1000121e 	bne	r2,zero,323f50c <ip_write2+0x2b4>
   {
      if (sopts->ip_ttl)
 323f4c4:	e0bffa17 	ldw	r2,-24(fp)
 323f4c8:	10800043 	ldbu	r2,1(r2)
 323f4cc:	10803fcc 	andi	r2,r2,255
 323f4d0:	1005003a 	cmpeq	r2,r2,zero
 323f4d4:	1000051e 	bne	r2,zero,323f4ec <ip_write2+0x294>
         pip->ip_time = sopts->ip_ttl;
 323f4d8:	e0bffa17 	ldw	r2,-24(fp)
 323f4dc:	10c00043 	ldbu	r3,1(r2)
 323f4e0:	e0bffc17 	ldw	r2,-16(fp)
 323f4e4:	10c00205 	stb	r3,8(r2)
 323f4e8:	00000306 	br	323f4f8 <ip_write2+0x2a0>
      else
         pip->ip_time = ttl;
 323f4ec:	e0fffc17 	ldw	r3,-16(fp)
 323f4f0:	e0bffb03 	ldbu	r2,-20(fp)
 323f4f4:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 323f4f8:	e0bffa17 	ldw	r2,-24(fp)
 323f4fc:	10c00003 	ldbu	r3,0(r2)
 323f500:	e0bffc17 	ldw	r2,-16(fp)
 323f504:	10c00045 	stb	r3,1(r2)
 323f508:	00000506 	br	323f520 <ip_write2+0x2c8>
   }
   else
   {
      pip->ip_time = ttl;
 323f50c:	e0bffc17 	ldw	r2,-16(fp)
 323f510:	e0fffb03 	ldbu	r3,-20(fp)
 323f514:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 323f518:	e0bffc17 	ldw	r2,-16(fp)
 323f51c:	10000045 	stb	zero,1(r2)
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 323f520:	e0bffe17 	ldw	r2,-8(fp)
 323f524:	10800317 	ldw	r2,12(r2)
 323f528:	10800504 	addi	r2,r2,20
 323f52c:	e0bff815 	stw	r2,-32(fp)
 323f530:	00000f06 	br	323f570 <ip_write2+0x318>
   {
      /* caller has already provided adequate space for the requested options */
      switch (*optp)
 323f534:	e0bfff17 	ldw	r2,-4(fp)
 323f538:	10800003 	ldbu	r2,0(r2)
 323f53c:	10803fcc 	andi	r2,r2,255
 323f540:	10800520 	cmpeqi	r2,r2,20
 323f544:	1000011e 	bne	r2,zero,323f54c <ip_write2+0x2f4>
 323f548:	00000606 	br	323f564 <ip_write2+0x30c>
      {
         case IP_RTR_ALERT_OPT:
            *((u_long *) tmpp) = htonl (IP_RTR_ALERT_OPT_DATA);
 323f54c:	e0fff817 	ldw	r3,-32(fp)
 323f550:	00812504 	movi	r2,1172
 323f554:	18800015 	stw	r2,0(r3)
            /* this option is 4 bytes long */
            tmpp += IP_RTR_ALERT_OPT_SIZE;
 323f558:	e0bff817 	ldw	r2,-32(fp)
 323f55c:	10800104 	addi	r2,r2,4
 323f560:	e0bff815 	stw	r2,-32(fp)
      pip->ip_time = ttl;
      pip->ip_tos = IP_TOS_DEFVAL;
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 323f564:	e0bfff17 	ldw	r2,-4(fp)
 323f568:	10800044 	addi	r2,r2,1
 323f56c:	e0bfff15 	stw	r2,-4(fp)
 323f570:	e0bfff17 	ldw	r2,-4(fp)
 323f574:	10800003 	ldbu	r2,0(r2)
 323f578:	10803fcc 	andi	r2,r2,255
 323f57c:	1004c03a 	cmpne	r2,r2,zero
 323f580:	103fec1e 	bne	r2,zero,323f534 <ip_write2+0x2dc>
            break;
      }
   }

   /* add one (or more) one-byte long End of Option options (if required) */
   for (i = 0; i < iphlen_pad; ++i) *(tmpp + i) = 0;
 323f584:	e03ff705 	stb	zero,-36(fp)
 323f588:	00000806 	br	323f5ac <ip_write2+0x354>
 323f58c:	e0bff703 	ldbu	r2,-36(fp)
 323f590:	1007883a 	mov	r3,r2
 323f594:	e0bff817 	ldw	r2,-32(fp)
 323f598:	1885883a 	add	r2,r3,r2
 323f59c:	10000005 	stb	zero,0(r2)
 323f5a0:	e0bff703 	ldbu	r2,-36(fp)
 323f5a4:	10800044 	addi	r2,r2,1
 323f5a8:	e0bff705 	stb	r2,-36(fp)
 323f5ac:	e0fff703 	ldbu	r3,-36(fp)
 323f5b0:	e0bff743 	ldbu	r2,-35(fp)
 323f5b4:	18bff536 	bltu	r3,r2,323f58c <ip_write2+0x334>
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum (pip, ((iphlen + iphlen_pad)/2));
 323f5b8:	e0fff903 	ldbu	r3,-28(fp)
 323f5bc:	e0bff743 	ldbu	r2,-35(fp)
 323f5c0:	1887883a 	add	r3,r3,r2
 323f5c4:	1804d7fa 	srli	r2,r3,31
 323f5c8:	10c5883a 	add	r2,r2,r3
 323f5cc:	1005d07a 	srai	r2,r2,1
 323f5d0:	100b883a 	mov	r5,r2
 323f5d4:	e13ffc17 	ldw	r4,-16(fp)
 323f5d8:	32259f80 	call	32259f8 <cksum>
 323f5dc:	0084303a 	nor	r2,zero,r2
 323f5e0:	1007883a 	mov	r3,r2
 323f5e4:	e0bffc17 	ldw	r2,-16(fp)
 323f5e8:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal (p));
 323f5ec:	e13ffe17 	ldw	r4,-8(fp)
 323f5f0:	323e8900 	call	323e890 <ip_write_internal>
}
 323f5f4:	e037883a 	mov	sp,fp
 323f5f8:	dfc00117 	ldw	ra,4(sp)
 323f5fc:	df000017 	ldw	fp,0(sp)
 323f600:	dec00204 	addi	sp,sp,8
 323f604:	f800283a 	ret

0323f608 <ip_raw_write>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_raw_write(PACKET p)
{
 323f608:	defffc04 	addi	sp,sp,-16
 323f60c:	dfc00315 	stw	ra,12(sp)
 323f610:	df000215 	stw	fp,8(sp)
 323f614:	df000204 	addi	fp,sp,8
 323f618:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 323f61c:	0080c9b4 	movhi	r2,806
 323f620:	10b46004 	addi	r2,r2,-11904
 323f624:	10800917 	ldw	r2,36(r2)
 323f628:	10c00044 	addi	r3,r2,1
 323f62c:	0080c9b4 	movhi	r2,806
 323f630:	10b46004 	addi	r2,r2,-11904
 323f634:	10c00915 	stw	r3,36(r2)

   /* form a pointer to IP header (pip) */
   pip = (struct ip*)(p->nb_prot);
 323f638:	e0bfff17 	ldw	r2,-4(fp)
 323f63c:	10800317 	ldw	r2,12(r2)
 323f640:	e0bffe15 	stw	r2,-8(fp)
   
   /* if there's no IP id, give it one */
   if (pip->ip_id == 0)
 323f644:	e0bffe17 	ldw	r2,-8(fp)
 323f648:	1080010b 	ldhu	r2,4(r2)
 323f64c:	10bfffcc 	andi	r2,r2,65535
 323f650:	1004c03a 	cmpne	r2,r2,zero
 323f654:	1000121e 	bne	r2,zero,323f6a0 <ip_raw_write+0x98>
   {
      pip->ip_id = htons((unshort)uid);
 323f658:	d0a04c17 	ldw	r2,-32464(gp)
 323f65c:	10bfffcc 	andi	r2,r2,65535
 323f660:	1004d23a 	srli	r2,r2,8
 323f664:	10803fcc 	andi	r2,r2,255
 323f668:	1009883a 	mov	r4,r2
 323f66c:	d0a04c17 	ldw	r2,-32464(gp)
 323f670:	10bfffcc 	andi	r2,r2,65535
 323f674:	1004923a 	slli	r2,r2,8
 323f678:	1007883a 	mov	r3,r2
 323f67c:	00bfc004 	movi	r2,-256
 323f680:	1884703a 	and	r2,r3,r2
 323f684:	2084b03a 	or	r2,r4,r2
 323f688:	1007883a 	mov	r3,r2
 323f68c:	e0bffe17 	ldw	r2,-8(fp)
 323f690:	10c0010d 	sth	r3,4(r2)
      uid++;
 323f694:	d0a04c17 	ldw	r2,-32464(gp)
 323f698:	10800044 	addi	r2,r2,1
 323f69c:	d0a04c15 	stw	r2,-32464(gp)
   }

   /* checksum the IP header */
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 323f6a0:	e0bffe17 	ldw	r2,-8(fp)
 323f6a4:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 323f6a8:	e13ffe17 	ldw	r4,-8(fp)
 323f6ac:	01400284 	movi	r5,10
 323f6b0:	32259f80 	call	32259f8 <cksum>
 323f6b4:	0084303a 	nor	r2,zero,r2
 323f6b8:	1007883a 	mov	r3,r2
 323f6bc:	e0bffe17 	ldw	r2,-8(fp)
 323f6c0:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 323f6c4:	e13fff17 	ldw	r4,-4(fp)
 323f6c8:	323e8900 	call	323e890 <ip_write_internal>
}
 323f6cc:	e037883a 	mov	sp,fp
 323f6d0:	dfc00117 	ldw	ra,4(sp)
 323f6d4:	df000017 	ldw	fp,0(sp)
 323f6d8:	dec00204 	addi	sp,sp,8
 323f6dc:	f800283a 	ret

0323f6e0 <ip_fragment_lc>:
 *              invocation of ip2mac () for the last generated fragment
 */

int
ip_fragment_lc(PACKET p, ip_addr firsthop)
{
 323f6e0:	deffed04 	addi	sp,sp,-76
 323f6e4:	dfc01215 	stw	ra,72(sp)
 323f6e8:	df001115 	stw	fp,68(sp)
 323f6ec:	df001104 	addi	fp,sp,68
 323f6f0:	e13ffa15 	stw	r4,-24(fp)
 323f6f4:	e17ffb15 	stw	r5,-20(fp)
   int      e;
   struct ip * pip;
   int      iphlen;     /* IP header length */
   unshort  tmp_fraginfo   ;

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 323f6f8:	0080c9b4 	movhi	r2,806
 323f6fc:	10b46004 	addi	r2,r2,-11904
 323f700:	10801017 	ldw	r2,64(r2)
 323f704:	10c00044 	addi	r3,r2,1
 323f708:	0080c9b4 	movhi	r2,806
 323f70c:	10b46004 	addi	r2,r2,-11904
 323f710:	10c01015 	stw	r3,64(r2)
   pip = (struct ip *)(p->nb_prot);          /* get ptr to IP header */
 323f714:	e0bffa17 	ldw	r2,-24(fp)
 323f718:	10800317 	ldw	r2,12(r2)
 323f71c:	e0bff115 	stw	r2,-60(fp)
   iphlen = (pip->ip_ver_ihl & 0xf) << 2;    /* and its length */
 323f720:	e0bff117 	ldw	r2,-60(fp)
 323f724:	10800003 	ldbu	r2,0(r2)
 323f728:	10803fcc 	andi	r2,r2,255
 323f72c:	108003cc 	andi	r2,r2,15
 323f730:	1085883a 	add	r2,r2,r2
 323f734:	1085883a 	add	r2,r2,r2
 323f738:	e0bff015 	stw	r2,-64(fp)
   left = (int)p->nb_plen - iphlen; /* bytes left to send in datagram */
 323f73c:	e0bffa17 	ldw	r2,-24(fp)
 323f740:	10800417 	ldw	r2,16(r2)
 323f744:	1007883a 	mov	r3,r2
 323f748:	e0bff017 	ldw	r2,-64(fp)
 323f74c:	1885c83a 	sub	r2,r3,r2
 323f750:	e0bff415 	stw	r2,-48(fp)
    * of fragments to get a fragment length that will result
    * in similarly-sized segments (remembering to round this
    * length up to a multiple of 8 because that's how the IP 
    * Fragment Offset field is scaled).
    */
   maxipsize = p->net->n_mtu - (iphlen + p->net->n_lnh + 8);   /* 8 == for rounding up */
 323f754:	e0bffa17 	ldw	r2,-24(fp)
 323f758:	10800617 	ldw	r2,24(r2)
 323f75c:	11000917 	ldw	r4,36(r2)
 323f760:	e0bffa17 	ldw	r2,-24(fp)
 323f764:	10800617 	ldw	r2,24(r2)
 323f768:	10c00817 	ldw	r3,32(r2)
 323f76c:	e0bff017 	ldw	r2,-64(fp)
 323f770:	1885883a 	add	r2,r3,r2
 323f774:	2085c83a 	sub	r2,r4,r2
 323f778:	10bffe04 	addi	r2,r2,-8
 323f77c:	e0bff815 	stw	r2,-32(fp)
   if (maxipsize < 64)  /* to small to use */
 323f780:	e0bff817 	ldw	r2,-32(fp)
 323f784:	10801028 	cmpgeui	r2,r2,64
 323f788:	1000041e 	bne	r2,zero,323f79c <ip_fragment_lc+0xbc>
   {
      dtrap();    /* probably bad programming */
 323f78c:	322ab8c0 	call	322ab8c <dtrap>
      return ENP_LOGIC;
 323f790:	00bffd44 	movi	r2,-11
 323f794:	e0bffe15 	stw	r2,-8(fp)
 323f798:	0000ed06 	br	323fb50 <ip_fragment_lc+0x470>
   }
   numfrags = (p->nb_plen/maxipsize) + 1;    /* number of fragments */
 323f79c:	e0bffa17 	ldw	r2,-24(fp)
 323f7a0:	11000417 	ldw	r4,16(r2)
 323f7a4:	e17ff817 	ldw	r5,-32(fp)
 323f7a8:	32044bc0 	call	32044bc <__udivsi3>
 323f7ac:	10800044 	addi	r2,r2,1
 323f7b0:	e0bff715 	stw	r2,-36(fp)
   fragsize = (((p->nb_plen + (numfrags - 1)) / numfrags) + 7) & ~7; 
 323f7b4:	e0bffa17 	ldw	r2,-24(fp)
 323f7b8:	10c00417 	ldw	r3,16(r2)
 323f7bc:	e0bff717 	ldw	r2,-36(fp)
 323f7c0:	1885883a 	add	r2,r3,r2
 323f7c4:	113fffc4 	addi	r4,r2,-1
 323f7c8:	e17ff717 	ldw	r5,-36(fp)
 323f7cc:	32044bc0 	call	32044bc <__udivsi3>
 323f7d0:	10c001c4 	addi	r3,r2,7
 323f7d4:	00bffe04 	movi	r2,-8
 323f7d8:	1884703a 	and	r2,r3,r2
 323f7dc:	e0bff915 	stw	r2,-28(fp)
   foffset = 0;
 323f7e0:	e03ff615 	stw	zero,-40(fp)

   /* Now update from any previous info */
   tmp_fraginfo = ntohs(pip->ip_flgs_foff);     /* get current frag info*/
 323f7e4:	e0bff117 	ldw	r2,-60(fp)
 323f7e8:	1080018b 	ldhu	r2,6(r2)
 323f7ec:	10bfffcc 	andi	r2,r2,65535
 323f7f0:	1004d23a 	srli	r2,r2,8
 323f7f4:	10803fcc 	andi	r2,r2,255
 323f7f8:	1009883a 	mov	r4,r2
 323f7fc:	e0bff117 	ldw	r2,-60(fp)
 323f800:	1080018b 	ldhu	r2,6(r2)
 323f804:	10bfffcc 	andi	r2,r2,65535
 323f808:	1004923a 	slli	r2,r2,8
 323f80c:	1007883a 	mov	r3,r2
 323f810:	00bfc004 	movi	r2,-256
 323f814:	1884703a 	and	r2,r3,r2
 323f818:	2084b03a 	or	r2,r4,r2
 323f81c:	e0bfef0d 	sth	r2,-68(fp)
   if ( tmp_fraginfo & (~IP_FLG_MASK) )
 323f820:	e0ffef0b 	ldhu	r3,-68(fp)
 323f824:	00bffff4 	movhi	r2,65535
 323f828:	1087ffc4 	addi	r2,r2,8191
 323f82c:	1884703a 	and	r2,r3,r2
 323f830:	1005003a 	cmpeq	r2,r2,zero
 323f834:	1000081e 	bne	r2,zero,323f858 <ip_fragment_lc+0x178>
   {
      /* When fragmenting an already fragmented packet, we need to
         add the initial offset */
      foffset = (tmp_fraginfo & (~IP_FLG_MASK))  ;
 323f838:	e0ffef0b 	ldhu	r3,-68(fp)
 323f83c:	00bffff4 	movhi	r2,65535
 323f840:	1087ffc4 	addi	r2,r2,8191
 323f844:	1884703a 	and	r2,r3,r2
 323f848:	e0bff615 	stw	r2,-40(fp)
      foffset <<= 3;    /* Multiply by 8 to get "offset in num of bytes" */
 323f84c:	e0bff617 	ldw	r2,-40(fp)
 323f850:	100490fa 	slli	r2,r2,3
 323f854:	e0bff615 	stw	r2,-40(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
 323f858:	e0bffa17 	ldw	r2,-24(fp)
 323f85c:	e0bff315 	stw	r2,-52(fp)
   e = 0;
 323f860:	e03ff215 	stw	zero,-56(fp)
   while (left > 1)  /* more data left to send? */
 323f864:	0000b506 	br	323fb3c <ip_fragment_lc+0x45c>
   {
      p = pkt2;  /* move next fragment up */
 323f868:	e0bff317 	ldw	r2,-52(fp)
 323f86c:	e0bffa15 	stw	r2,-24(fp)
      pip = (struct ip *)(p->nb_prot);
 323f870:	e0bffa17 	ldw	r2,-24(fp)
 323f874:	10800317 	ldw	r2,12(r2)
 323f878:	e0bff115 	stw	r2,-60(fp)
      p->nb_plen = min((int)fragsize, left) + iphlen; /* set size of fragment */
 323f87c:	e0bff917 	ldw	r2,-28(fp)
 323f880:	e0fff417 	ldw	r3,-48(fp)
 323f884:	e0ffff15 	stw	r3,-4(fp)
 323f888:	e0bffd15 	stw	r2,-12(fp)
 323f88c:	e0bfff17 	ldw	r2,-4(fp)
 323f890:	e0fffd17 	ldw	r3,-12(fp)
 323f894:	10c0020e 	bge	r2,r3,323f8a0 <ip_fragment_lc+0x1c0>
 323f898:	e0bfff17 	ldw	r2,-4(fp)
 323f89c:	e0bffd15 	stw	r2,-12(fp)
 323f8a0:	e0bff017 	ldw	r2,-64(fp)
 323f8a4:	e0fffd17 	ldw	r3,-12(fp)
 323f8a8:	1885883a 	add	r2,r3,r2
 323f8ac:	1007883a 	mov	r3,r2
 323f8b0:	e0bffa17 	ldw	r2,-24(fp)
 323f8b4:	10c00415 	stw	r3,16(r2)
      left -= fragsize; /* decrement count of bytes left to send */
 323f8b8:	e0fff417 	ldw	r3,-48(fp)
 323f8bc:	e0bff917 	ldw	r2,-28(fp)
 323f8c0:	1885c83a 	sub	r2,r3,r2
 323f8c4:	e0bff415 	stw	r2,-48(fp)

      /* set the IP datagram length */
      pip->ip_len = htons((unshort)p->nb_plen);
 323f8c8:	e0bffa17 	ldw	r2,-24(fp)
 323f8cc:	10800417 	ldw	r2,16(r2)
 323f8d0:	10bfffcc 	andi	r2,r2,65535
 323f8d4:	1004d23a 	srli	r2,r2,8
 323f8d8:	10803fcc 	andi	r2,r2,255
 323f8dc:	1009883a 	mov	r4,r2
 323f8e0:	e0bffa17 	ldw	r2,-24(fp)
 323f8e4:	10800417 	ldw	r2,16(r2)
 323f8e8:	10bfffcc 	andi	r2,r2,65535
 323f8ec:	1004923a 	slli	r2,r2,8
 323f8f0:	1007883a 	mov	r3,r2
 323f8f4:	00bfc004 	movi	r2,-256
 323f8f8:	1884703a 	and	r2,r3,r2
 323f8fc:	2084b03a 	or	r2,r4,r2
 323f900:	1007883a 	mov	r3,r2
 323f904:	e0bff117 	ldw	r2,-60(fp)
 323f908:	10c0008d 	sth	r3,2(r2)

      /* build 16bit IP header field value for fragment flags & offset */
      fraginfo = (unshort)(foffset >> 3);    /* offset, in 8 byte chunks */
 323f90c:	e0bff617 	ldw	r2,-40(fp)
 323f910:	1004d0fa 	srli	r2,r2,3
 323f914:	e0bff50d 	sth	r2,-44(fp)
      fraginfo |= ((left>1)?IP_FLG_MF:0);    /* OR in MoreFrags flag */
 323f918:	e0bff417 	ldw	r2,-48(fp)
 323f91c:	10800090 	cmplti	r2,r2,2
 323f920:	1000031e 	bne	r2,zero,323f930 <ip_fragment_lc+0x250>
 323f924:	00880004 	movi	r2,8192
 323f928:	e0bffc0d 	sth	r2,-16(fp)
 323f92c:	00000106 	br	323f934 <ip_fragment_lc+0x254>
 323f930:	e03ffc0d 	sth	zero,-16(fp)
 323f934:	e0bff50b 	ldhu	r2,-44(fp)
 323f938:	e0fffc0b 	ldhu	r3,-16(fp)
 323f93c:	1884b03a 	or	r2,r3,r2
 323f940:	e0bff50d 	sth	r2,-44(fp)

      if ( tmp_fraginfo & IP_FLG_MF )             
 323f944:	e0bfef0b 	ldhu	r2,-68(fp)
 323f948:	1088000c 	andi	r2,r2,8192
 323f94c:	1005003a 	cmpeq	r2,r2,zero
 323f950:	1000031e 	bne	r2,zero,323f960 <ip_fragment_lc+0x280>
      {
         /* As flag is set in main packet, it should be set in all
          * fragmented packets also 
          */
         fraginfo |= IP_FLG_MF;
 323f954:	e0bff50b 	ldhu	r2,-44(fp)
 323f958:	10880014 	ori	r2,r2,8192
 323f95c:	e0bff50d 	sth	r2,-44(fp)
      }

      pip->ip_flgs_foff = htons(fraginfo);   /* do htons macro on separate line */
 323f960:	e0bff50b 	ldhu	r2,-44(fp)
 323f964:	1004d23a 	srli	r2,r2,8
 323f968:	10803fcc 	andi	r2,r2,255
 323f96c:	1009883a 	mov	r4,r2
 323f970:	e0bff50b 	ldhu	r2,-44(fp)
 323f974:	1004923a 	slli	r2,r2,8
 323f978:	1007883a 	mov	r3,r2
 323f97c:	00bfc004 	movi	r2,-256
 323f980:	1884703a 	and	r2,r3,r2
 323f984:	2084b03a 	or	r2,r4,r2
 323f988:	1007883a 	mov	r3,r2
 323f98c:	e0bff117 	ldw	r2,-60(fp)
 323f990:	10c0018d 	sth	r3,6(r2)
      /* set up & save next fragment (pkt2) since ip2mac() will delete p */
      if (left > 1)
 323f994:	e0bff417 	ldw	r2,-48(fp)
 323f998:	10800090 	cmplti	r2,r2,2
 323f99c:	1000401e 	bne	r2,zero,323faa0 <ip_fragment_lc+0x3c0>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 323f9a0:	01000084 	movi	r4,2
 323f9a4:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pkt2 = pk_alloc(left + iphlen + MaxLnh);
 323f9a8:	e0fff417 	ldw	r3,-48(fp)
 323f9ac:	e0bff017 	ldw	r2,-64(fp)
 323f9b0:	1887883a 	add	r3,r3,r2
 323f9b4:	0080c974 	movhi	r2,805
 323f9b8:	10922f04 	addi	r2,r2,18620
 323f9bc:	10800017 	ldw	r2,0(r2)
 323f9c0:	1885883a 	add	r2,r3,r2
 323f9c4:	1009883a 	mov	r4,r2
 323f9c8:	3229f480 	call	3229f48 <pk_alloc>
 323f9cc:	e0bff315 	stw	r2,-52(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323f9d0:	01000084 	movi	r4,2
 323f9d4:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         if (!pkt2)
 323f9d8:	e0bff317 	ldw	r2,-52(fp)
 323f9dc:	1004c03a 	cmpne	r2,r2,zero
 323f9e0:	1000111e 	bne	r2,zero,323fa28 <ip_fragment_lc+0x348>
         {
            dtrap();
 323f9e4:	322ab8c0 	call	322ab8c <dtrap>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 323f9e8:	01000084 	movi	r4,2
 323f9ec:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
            pk_free(p);
 323f9f0:	e13ffa17 	ldw	r4,-24(fp)
 323f9f4:	322a2dc0 	call	322a2dc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323f9f8:	01000084 	movi	r4,2
 323f9fc:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 323fa00:	0080c9b4 	movhi	r2,806
 323fa04:	10b46004 	addi	r2,r2,-11904
 323fa08:	10801117 	ldw	r2,68(r2)
 323fa0c:	10c00044 	addi	r3,r2,1
 323fa10:	0080c9b4 	movhi	r2,806
 323fa14:	10b46004 	addi	r2,r2,-11904
 323fa18:	10c01115 	stw	r3,68(r2)
            return ENP_RESOURCE;
 323fa1c:	00bffa84 	movi	r2,-22
 323fa20:	e0bffe15 	stw	r2,-8(fp)
 323fa24:	00004a06 	br	323fb50 <ip_fragment_lc+0x470>
         }

         pkt2->net = p->net;       /* copy critical parms to new packet */
 323fa28:	e0bffa17 	ldw	r2,-24(fp)
 323fa2c:	10c00617 	ldw	r3,24(r2)
 323fa30:	e0bff317 	ldw	r2,-52(fp)
 323fa34:	10c00615 	stw	r3,24(r2)
         pkt2->fhost = p->fhost;
 323fa38:	e0bffa17 	ldw	r2,-24(fp)
 323fa3c:	10c00717 	ldw	r3,28(r2)
 323fa40:	e0bff317 	ldw	r2,-52(fp)
 323fa44:	10c00715 	stw	r3,28(r2)
         /* Duplicate the IPHeader */
         MEMCPY(pkt2->nb_prot, p->nb_prot, iphlen);
 323fa48:	e0bff317 	ldw	r2,-52(fp)
 323fa4c:	11000317 	ldw	r4,12(r2)
 323fa50:	e0bffa17 	ldw	r2,-24(fp)
 323fa54:	10800317 	ldw	r2,12(r2)
 323fa58:	e0fff017 	ldw	r3,-64(fp)
 323fa5c:	100b883a 	mov	r5,r2
 323fa60:	180d883a 	mov	r6,r3
 323fa64:	32067cc0 	call	32067cc <memcpy>
         /* copy data for NEXT fragment from p to pkt2 */
         MEMCPY(pkt2->nb_prot + iphlen, p->nb_prot + iphlen + fragsize, left);
 323fa68:	e0bff317 	ldw	r2,-52(fp)
 323fa6c:	10c00317 	ldw	r3,12(r2)
 323fa70:	e0bff017 	ldw	r2,-64(fp)
 323fa74:	1889883a 	add	r4,r3,r2
 323fa78:	e0bffa17 	ldw	r2,-24(fp)
 323fa7c:	10c00317 	ldw	r3,12(r2)
 323fa80:	e0bff017 	ldw	r2,-64(fp)
 323fa84:	1887883a 	add	r3,r3,r2
 323fa88:	e0bff917 	ldw	r2,-28(fp)
 323fa8c:	1885883a 	add	r2,r3,r2
 323fa90:	e0fff417 	ldw	r3,-48(fp)
 323fa94:	100b883a 	mov	r5,r2
 323fa98:	180d883a 	mov	r6,r3
 323fa9c:	32067cc0 	call	32067cc <memcpy>
      }

      /* we've changed the IP header, so recalculate the checksum */
      pip->ip_chksum = IPXSUM;
 323faa0:	e0bff117 	ldw	r2,-60(fp)
 323faa4:	1000028d 	sth	zero,10(r2)
      pip->ip_chksum = ~cksum(pip, 10);
 323faa8:	e13ff117 	ldw	r4,-60(fp)
 323faac:	01400284 	movi	r5,10
 323fab0:	32259f80 	call	32259f8 <cksum>
 323fab4:	0084303a 	nor	r2,zero,r2
 323fab8:	1007883a 	mov	r3,r2
 323fabc:	e0bff117 	ldw	r2,-60(fp)
 323fac0:	10c0028d 	sth	r3,10(r2)

      /* ip_dump(p); */

      e = ip2mac(p, firsthop);   /* send fragment in p */
 323fac4:	e13ffa17 	ldw	r4,-24(fp)
 323fac8:	e17ffb17 	ldw	r5,-20(fp)
 323facc:	32237940 	call	3223794 <ip2mac>
 323fad0:	e0bff215 	stw	r2,-56(fp)
      ip_mib.ipFragCreates++;
 323fad4:	0080c9b4 	movhi	r2,806
 323fad8:	10b46004 	addi	r2,r2,-11904
 323fadc:	10801217 	ldw	r2,72(r2)
 323fae0:	10c00044 	addi	r3,r2,1
 323fae4:	0080c9b4 	movhi	r2,806
 323fae8:	10b46004 	addi	r2,r2,-11904
 323faec:	10c01215 	stw	r3,72(r2)
      if (e < 0)
 323faf0:	e0bff217 	ldw	r2,-56(fp)
 323faf4:	1004403a 	cmpge	r2,r2,zero
 323faf8:	10000c1e 	bne	r2,zero,323fb2c <ip_fragment_lc+0x44c>
      {
         if (left > 1) 
 323fafc:	e0bff417 	ldw	r2,-48(fp)
 323fb00:	10800090 	cmplti	r2,r2,2
 323fb04:	1000061e 	bne	r2,zero,323fb20 <ip_fragment_lc+0x440>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 323fb08:	01000084 	movi	r4,2
 323fb0c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
            pk_free(pkt2);
 323fb10:	e13ff317 	ldw	r4,-52(fp)
 323fb14:	322a2dc0 	call	322a2dc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323fb18:	01000084 	movi	r4,2
 323fb1c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         }
         return e;
 323fb20:	e0fff217 	ldw	r3,-56(fp)
 323fb24:	e0fffe15 	stw	r3,-8(fp)
 323fb28:	00000906 	br	323fb50 <ip_fragment_lc+0x470>
      }
      foffset += fragsize;    /* offset for next fragment */
 323fb2c:	e0bff617 	ldw	r2,-40(fp)
 323fb30:	e0fff917 	ldw	r3,-28(fp)
 323fb34:	10c5883a 	add	r2,r2,r3
 323fb38:	e0bff615 	stw	r2,-40(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
   e = 0;
   while (left > 1)  /* more data left to send? */
 323fb3c:	e0bff417 	ldw	r2,-48(fp)
 323fb40:	10800088 	cmpgei	r2,r2,2
 323fb44:	103f481e 	bne	r2,zero,323f868 <ip_fragment_lc+0x188>
         }
         return e;
      }
      foffset += fragsize;    /* offset for next fragment */
   }
   return e;
 323fb48:	e0bff217 	ldw	r2,-56(fp)
 323fb4c:	e0bffe15 	stw	r2,-8(fp)
 323fb50:	e0bffe17 	ldw	r2,-8(fp)
}
 323fb54:	e037883a 	mov	sp,fp
 323fb58:	dfc00117 	ldw	ra,4(sp)
 323fb5c:	df000017 	ldw	fp,0(sp)
 323fb60:	dec00204 	addi	sp,sp,8
 323fb64:	f800283a 	ret

0323fb68 <ip_fragment>:
 *              generated fragment, if less than zero
 *          (5) 0, if everything went okay
 */

int ip_fragment(PACKET p, ip_addr firsthop)
{
 323fb68:	deffed04 	addi	sp,sp,-76
 323fb6c:	dfc01215 	stw	ra,72(sp)
 323fb70:	df001115 	stw	fp,68(sp)
 323fb74:	df001104 	addi	fp,sp,68
 323fb78:	e13ffa15 	stw	r4,-24(fp)
 323fb7c:	e17ffb15 	stw	r5,-20(fp)
   u_short parent_mf;
   PACKET newpkt;
   struct ip * newpip;
   int e;

   pip = ip_head(p);
 323fb80:	e0bffa17 	ldw	r2,-24(fp)
 323fb84:	10800317 	ldw	r2,12(r2)
 323fb88:	e0bff815 	stw	r2,-32(fp)
   if ((ntohs(pip->ip_flgs_foff)) & IP_FLG_DF)
 323fb8c:	e0bff817 	ldw	r2,-32(fp)
 323fb90:	1080018b 	ldhu	r2,6(r2)
 323fb94:	10bfffcc 	andi	r2,r2,65535
 323fb98:	1004d23a 	srli	r2,r2,8
 323fb9c:	10bfffcc 	andi	r2,r2,65535
 323fba0:	10c03fcc 	andi	r3,r2,255
 323fba4:	e0bff817 	ldw	r2,-32(fp)
 323fba8:	1080018b 	ldhu	r2,6(r2)
 323fbac:	10bfffcc 	andi	r2,r2,65535
 323fbb0:	1004923a 	slli	r2,r2,8
 323fbb4:	10bfc00c 	andi	r2,r2,65280
 323fbb8:	1884b03a 	or	r2,r3,r2
 323fbbc:	1090000c 	andi	r2,r2,16384
 323fbc0:	1005003a 	cmpeq	r2,r2,zero
 323fbc4:	10001a1e 	bne	r2,zero,323fc30 <ip_fragment+0xc8>
   {
      /* can't fragment a packet with the DF bit set */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 323fbc8:	01000084 	movi	r4,2
 323fbcc:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(p);
 323fbd0:	e13ffa17 	ldw	r4,-24(fp)
 323fbd4:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323fbd8:	01000084 	movi	r4,2
 323fbdc:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      ip_mib.ipFragFails++;
 323fbe0:	0080c9b4 	movhi	r2,806
 323fbe4:	10b46004 	addi	r2,r2,-11904
 323fbe8:	10801117 	ldw	r2,68(r2)
 323fbec:	10c00044 	addi	r3,r2,1
 323fbf0:	0080c9b4 	movhi	r2,806
 323fbf4:	10b46004 	addi	r2,r2,-11904
 323fbf8:	10c01115 	stw	r3,68(r2)
#ifdef FULL_ICMP
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 323fbfc:	e0bff817 	ldw	r2,-32(fp)
 323fc00:	11000317 	ldw	r4,12(r2)
 323fc04:	e0bffa17 	ldw	r2,-24(fp)
 323fc08:	10800617 	ldw	r2,24(r2)
 323fc0c:	11400a17 	ldw	r5,40(r2)
 323fc10:	e0bffa17 	ldw	r2,-24(fp)
 323fc14:	10800617 	ldw	r2,24(r2)
 323fc18:	d8800015 	stw	r2,0(sp)
 323fc1c:	e1bff817 	ldw	r6,-32(fp)
 323fc20:	01c00104 	movi	r7,4
 323fc24:	324b1dc0 	call	324b1dc <icmp_destun>
#endif   /* FULL_ICMP */
      return 0;
 323fc28:	e03ffe15 	stw	zero,-8(fp)
 323fc2c:	00015106 	br	3240174 <ip_fragment+0x60c>
   }

   maxbuflen = pk_get_max_intrsafe_buf_len ();
 323fc30:	322a3880 	call	322a388 <pk_get_max_intrsafe_buf_len>
 323fc34:	e0bff915 	stw	r2,-28(fp)

   /* the maximum amount of data that will be sent to ip2mac ().  Please note that
    * our definition of MTU is different from the traditional definition of that
    * parameter (which excludes the data link layer header). */
   maxl3_len = (unsigned short int) (MIN(maxbuflen, ((unsigned) p->net->n_mtu)));
 323fc38:	e0bffa17 	ldw	r2,-24(fp)
 323fc3c:	10800617 	ldw	r2,24(r2)
 323fc40:	10800917 	ldw	r2,36(r2)
 323fc44:	e0fff917 	ldw	r3,-28(fp)
 323fc48:	e0ffff15 	stw	r3,-4(fp)
 323fc4c:	e0bffd15 	stw	r2,-12(fp)
 323fc50:	e0bfff17 	ldw	r2,-4(fp)
 323fc54:	e0fffd17 	ldw	r3,-12(fp)
 323fc58:	10c0022e 	bgeu	r2,r3,323fc64 <ip_fragment+0xfc>
 323fc5c:	e0bfff17 	ldw	r2,-4(fp)
 323fc60:	e0bffd15 	stw	r2,-12(fp)
 323fc64:	e0fffd17 	ldw	r3,-12(fp)
 323fc68:	e0fff58d 	sth	r3,-42(fp)

   /* get the length of the IP header of the original, unfragmented datagram */
   iphlen = ip_hlen(pip);
 323fc6c:	e0bff817 	ldw	r2,-32(fp)
 323fc70:	10800003 	ldbu	r2,0(r2)
 323fc74:	108003cc 	andi	r2,r2,15
 323fc78:	1085883a 	add	r2,r2,r2
 323fc7c:	1085883a 	add	r2,r2,r2
 323fc80:	e0bff7c5 	stb	r2,-33(fp)

   /* obtain the useable payload length in an IP datagram (after accounting for the 
    * length of the IP and data link layer headers) */
   l2hdr_len = (u_char) p->net->n_lnh;
 323fc84:	e0bffa17 	ldw	r2,-24(fp)
 323fc88:	10800617 	ldw	r2,24(r2)
 323fc8c:	10800817 	ldw	r2,32(r2)
 323fc90:	e0bff785 	stb	r2,-34(fp)
   useable_payload_len = maxl3_len - iphlen - l2hdr_len;
 323fc94:	e0fff7c3 	ldbu	r3,-33(fp)
 323fc98:	e0bff58b 	ldhu	r2,-42(fp)
 323fc9c:	10c5c83a 	sub	r2,r2,r3
 323fca0:	1007883a 	mov	r3,r2
 323fca4:	e0bff783 	ldbu	r2,-34(fp)
 323fca8:	1885c83a 	sub	r2,r3,r2
 323fcac:	e0bff70d 	sth	r2,-36(fp)

   /* IP fragments must always have a length that is a multiple of 8 bytes, so we
    * need to round 'payload_len' down to the nearest multiple of 8 bytes. */
   useable_payload_len &= (~((unsigned short int) 0x07));
 323fcb0:	e0fff70b 	ldhu	r3,-36(fp)
 323fcb4:	00bffe04 	movi	r2,-8
 323fcb8:	1884703a 	and	r2,r3,r2
 323fcbc:	e0bff70d 	sth	r2,-36(fp)

   /* compute the number of packets that we need to send.  First compute the total
    * payload length of the "original" datagram (which could itself be a fragment). 
    */
   total_payload_len = (ntohs(pip->ip_len)) - iphlen;
 323fcc0:	e0bff817 	ldw	r2,-32(fp)
 323fcc4:	1080008b 	ldhu	r2,2(r2)
 323fcc8:	10bfffcc 	andi	r2,r2,65535
 323fccc:	1004d23a 	srli	r2,r2,8
 323fcd0:	10803fcc 	andi	r2,r2,255
 323fcd4:	1009883a 	mov	r4,r2
 323fcd8:	e0bff817 	ldw	r2,-32(fp)
 323fcdc:	1080008b 	ldhu	r2,2(r2)
 323fce0:	10bfffcc 	andi	r2,r2,65535
 323fce4:	1004923a 	slli	r2,r2,8
 323fce8:	1007883a 	mov	r3,r2
 323fcec:	00bfc004 	movi	r2,-256
 323fcf0:	1884703a 	and	r2,r3,r2
 323fcf4:	2084b03a 	or	r2,r4,r2
 323fcf8:	1007883a 	mov	r3,r2
 323fcfc:	e0bff7c3 	ldbu	r2,-33(fp)
 323fd00:	1885c83a 	sub	r2,r3,r2
 323fd04:	e0bff68d 	sth	r2,-38(fp)
   num_frags = (total_payload_len / useable_payload_len);
 323fd08:	e13ff68b 	ldhu	r4,-38(fp)
 323fd0c:	e17ff70b 	ldhu	r5,-36(fp)
 323fd10:	32044bc0 	call	32044bc <__udivsi3>
 323fd14:	e0bff50d 	sth	r2,-44(fp)
   if ((last_payload_len = (total_payload_len % useable_payload_len)) != 0)
 323fd18:	e13ff68b 	ldhu	r4,-38(fp)
 323fd1c:	e17ff70b 	ldhu	r5,-36(fp)
 323fd20:	32044c40 	call	32044c4 <__umodsi3>
 323fd24:	e0bff60d 	sth	r2,-40(fp)
 323fd28:	e0bff60b 	ldhu	r2,-40(fp)
 323fd2c:	1005003a 	cmpeq	r2,r2,zero
 323fd30:	1000031e 	bne	r2,zero,323fd40 <ip_fragment+0x1d8>
   {
      /* we will have one additional (also last) fragment that is smaller than the 
       * other fragments */
      ++num_frags;
 323fd34:	e0bff50b 	ldhu	r2,-44(fp)
 323fd38:	10800044 	addi	r2,r2,1
 323fd3c:	e0bff50d 	sth	r2,-44(fp)
    * the one passed to this function) is interrupt-safe, then we use 
    * ip_fragment_lc () for creating the child fragments.  This decreases the 
    * amount of copying that needs to be done in those cases (as compared to this 
    * function); however, for larger packets, ip_fragment () becomes more efficient 
    * (than ip_fragment_lc ()). */
   if ((num_frags <= FRAG_SCHEME_SWITCH_THRESHOLD) && (!(p->flags & PKF_INTRUNSAFE)))
 323fd40:	e0bff50b 	ldhu	r2,-44(fp)
 323fd44:	10800128 	cmpgeui	r2,r2,4
 323fd48:	10000a1e 	bne	r2,zero,323fd74 <ip_fragment+0x20c>
 323fd4c:	e0bffa17 	ldw	r2,-24(fp)
 323fd50:	10800a17 	ldw	r2,40(r2)
 323fd54:	1080040c 	andi	r2,r2,16
 323fd58:	1004c03a 	cmpne	r2,r2,zero
 323fd5c:	1000051e 	bne	r2,zero,323fd74 <ip_fragment+0x20c>
   {
      return (ip_fragment_lc (p, firsthop));
 323fd60:	e13ffa17 	ldw	r4,-24(fp)
 323fd64:	e17ffb17 	ldw	r5,-20(fp)
 323fd68:	323f6e00 	call	323f6e0 <ip_fragment_lc>
 323fd6c:	e0bffe15 	stw	r2,-8(fp)
 323fd70:	00010006 	br	3240174 <ip_fragment+0x60c>
   }

   parent_frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 323fd74:	e0bff817 	ldw	r2,-32(fp)
 323fd78:	1080018b 	ldhu	r2,6(r2)
 323fd7c:	10bfffcc 	andi	r2,r2,65535
 323fd80:	1004d23a 	srli	r2,r2,8
 323fd84:	10803fcc 	andi	r2,r2,255
 323fd88:	1009883a 	mov	r4,r2
 323fd8c:	e0bff817 	ldw	r2,-32(fp)
 323fd90:	1080018b 	ldhu	r2,6(r2)
 323fd94:	10bfffcc 	andi	r2,r2,65535
 323fd98:	1004923a 	slli	r2,r2,8
 323fd9c:	1007883a 	mov	r3,r2
 323fda0:	00bfc004 	movi	r2,-256
 323fda4:	1884703a 	and	r2,r3,r2
 323fda8:	2084b03a 	or	r2,r4,r2
 323fdac:	1087ffcc 	andi	r2,r2,8191
 323fdb0:	100490fa 	slli	r2,r2,3
 323fdb4:	e0bff38d 	sth	r2,-50(fp)
   parent_mf = ((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF);
 323fdb8:	e0bff817 	ldw	r2,-32(fp)
 323fdbc:	1080018b 	ldhu	r2,6(r2)
 323fdc0:	10bfffcc 	andi	r2,r2,65535
 323fdc4:	1004d23a 	srli	r2,r2,8
 323fdc8:	10803fcc 	andi	r2,r2,255
 323fdcc:	1009883a 	mov	r4,r2
 323fdd0:	e0bff817 	ldw	r2,-32(fp)
 323fdd4:	1080018b 	ldhu	r2,6(r2)
 323fdd8:	10bfffcc 	andi	r2,r2,65535
 323fddc:	1004923a 	slli	r2,r2,8
 323fde0:	1007883a 	mov	r3,r2
 323fde4:	00bfc004 	movi	r2,-256
 323fde8:	1884703a 	and	r2,r3,r2
 323fdec:	2084b03a 	or	r2,r4,r2
 323fdf0:	1088000c 	andi	r2,r2,8192
 323fdf4:	e0bff30d 	sth	r2,-52(fp)
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 323fdf8:	e03ff48d 	sth	zero,-46(fp)
 323fdfc:	0000cc06 	br	3240130 <ip_fragment+0x5c8>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 323fe00:	01000084 	movi	r4,2
 323fe04:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      newpkt = pk_alloc (useable_payload_len + iphlen + l2hdr_len); 
 323fe08:	e0fff70b 	ldhu	r3,-36(fp)
 323fe0c:	e0bff7c3 	ldbu	r2,-33(fp)
 323fe10:	1887883a 	add	r3,r3,r2
 323fe14:	e0bff783 	ldbu	r2,-34(fp)
 323fe18:	1885883a 	add	r2,r3,r2
 323fe1c:	1009883a 	mov	r4,r2
 323fe20:	3229f480 	call	3229f48 <pk_alloc>
 323fe24:	e0bff215 	stw	r2,-56(fp)
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323fe28:	01000084 	movi	r4,2
 323fe2c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

      if (newpkt == 0)
 323fe30:	e0bff217 	ldw	r2,-56(fp)
 323fe34:	1004c03a 	cmpne	r2,r2,zero
 323fe38:	1000101e 	bne	r2,zero,323fe7c <ip_fragment+0x314>
      {
         /* free the packet that we are working with */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 323fe3c:	01000084 	movi	r4,2
 323fe40:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pk_free(p);
 323fe44:	e13ffa17 	ldw	r4,-24(fp)
 323fe48:	322a2dc0 	call	322a2dc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323fe4c:	01000084 	movi	r4,2
 323fe50:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         ip_mib.ipFragFails++;
 323fe54:	0080c9b4 	movhi	r2,806
 323fe58:	10b46004 	addi	r2,r2,-11904
 323fe5c:	10801117 	ldw	r2,68(r2)
 323fe60:	10c00044 	addi	r3,r2,1
 323fe64:	0080c9b4 	movhi	r2,806
 323fe68:	10b46004 	addi	r2,r2,-11904
 323fe6c:	10c01115 	stw	r3,68(r2)
         return ENP_NOBUFFER;
 323fe70:	00bffac4 	movi	r2,-21
 323fe74:	e0bffe15 	stw	r2,-8(fp)
 323fe78:	0000be06 	br	3240174 <ip_fragment+0x60c>
      }
      else
      {
         /* copy the IP header from the original datagram into the fragment */
         MEMCPY((newpkt->nb_buff + l2hdr_len), p->nb_prot, iphlen);
 323fe7c:	e0bff217 	ldw	r2,-56(fp)
 323fe80:	10c00117 	ldw	r3,4(r2)
 323fe84:	e0bff783 	ldbu	r2,-34(fp)
 323fe88:	1889883a 	add	r4,r3,r2
 323fe8c:	e0bffa17 	ldw	r2,-24(fp)
 323fe90:	10800317 	ldw	r2,12(r2)
 323fe94:	e0fff7c3 	ldbu	r3,-33(fp)
 323fe98:	100b883a 	mov	r5,r2
 323fe9c:	180d883a 	mov	r6,r3
 323fea0:	32067cc0 	call	32067cc <memcpy>

         /* compute the amount of payload that needs to be copied into each 
          * child fragment */
         if (i < (num_frags - 1))
 323fea4:	e0fff48b 	ldhu	r3,-46(fp)
 323fea8:	e0bff50b 	ldhu	r2,-44(fp)
 323feac:	10bfffc4 	addi	r2,r2,-1
 323feb0:	1880030e 	bge	r3,r2,323fec0 <ip_fragment+0x358>
         {
            amt_to_copy = useable_payload_len;
 323feb4:	e0bff70b 	ldhu	r2,-36(fp)
 323feb8:	e0bff40d 	sth	r2,-48(fp)
 323febc:	00000a06 	br	323fee8 <ip_fragment+0x380>
         }
         else
         {
            amt_to_copy = ((last_payload_len == 0) ? useable_payload_len : last_payload_len);
 323fec0:	e0bff60b 	ldhu	r2,-40(fp)
 323fec4:	1004c03a 	cmpne	r2,r2,zero
 323fec8:	1000031e 	bne	r2,zero,323fed8 <ip_fragment+0x370>
 323fecc:	e0fff70b 	ldhu	r3,-36(fp)
 323fed0:	e0fffc0d 	sth	r3,-16(fp)
 323fed4:	00000206 	br	323fee0 <ip_fragment+0x378>
 323fed8:	e0bff60b 	ldhu	r2,-40(fp)
 323fedc:	e0bffc0d 	sth	r2,-16(fp)
 323fee0:	e0fffc0b 	ldhu	r3,-16(fp)
 323fee4:	e0fff40d 	sth	r3,-48(fp)
         }
         MEMCPY((newpkt->nb_buff + l2hdr_len + iphlen), p->nb_prot + iphlen + (useable_payload_len * i), amt_to_copy);
 323fee8:	e0bff217 	ldw	r2,-56(fp)
 323feec:	10c00117 	ldw	r3,4(r2)
 323fef0:	e0bff783 	ldbu	r2,-34(fp)
 323fef4:	1887883a 	add	r3,r3,r2
 323fef8:	e0bff7c3 	ldbu	r2,-33(fp)
 323fefc:	188b883a 	add	r5,r3,r2
 323ff00:	e0bffa17 	ldw	r2,-24(fp)
 323ff04:	10c00317 	ldw	r3,12(r2)
 323ff08:	e0bff7c3 	ldbu	r2,-33(fp)
 323ff0c:	1889883a 	add	r4,r3,r2
 323ff10:	e0fff70b 	ldhu	r3,-36(fp)
 323ff14:	e0bff48b 	ldhu	r2,-46(fp)
 323ff18:	1885383a 	mul	r2,r3,r2
 323ff1c:	2085883a 	add	r2,r4,r2
 323ff20:	e0fff40b 	ldhu	r3,-48(fp)
 323ff24:	2809883a 	mov	r4,r5
 323ff28:	100b883a 	mov	r5,r2
 323ff2c:	180d883a 	mov	r6,r3
 323ff30:	32067cc0 	call	32067cc <memcpy>

         /* set up the various netbuf fields for the fragment */
         newpkt->nb_prot = newpkt->nb_buff + l2hdr_len;
 323ff34:	e0bff217 	ldw	r2,-56(fp)
 323ff38:	10c00117 	ldw	r3,4(r2)
 323ff3c:	e0bff783 	ldbu	r2,-34(fp)
 323ff40:	1887883a 	add	r3,r3,r2
 323ff44:	e0bff217 	ldw	r2,-56(fp)
 323ff48:	10c00315 	stw	r3,12(r2)
         newpkt->nb_plen = iphlen + amt_to_copy;
 323ff4c:	e0fff7c3 	ldbu	r3,-33(fp)
 323ff50:	e0bff40b 	ldhu	r2,-48(fp)
 323ff54:	1885883a 	add	r2,r3,r2
 323ff58:	1007883a 	mov	r3,r2
 323ff5c:	e0bff217 	ldw	r2,-56(fp)
 323ff60:	10c00415 	stw	r3,16(r2)
         newpkt->net = p->net;
 323ff64:	e0bffa17 	ldw	r2,-24(fp)
 323ff68:	10c00617 	ldw	r3,24(r2)
 323ff6c:	e0bff217 	ldw	r2,-56(fp)
 323ff70:	10c00615 	stw	r3,24(r2)
         newpkt->fhost = p->fhost;
 323ff74:	e0bffa17 	ldw	r2,-24(fp)
 323ff78:	10c00717 	ldw	r3,28(r2)
 323ff7c:	e0bff217 	ldw	r2,-56(fp)
 323ff80:	10c00715 	stw	r3,28(r2)
         /* type and nb_tstamp fields are not used in the egress direction, but we set 'type' anyway */
         newpkt->type = htons(IPTP);
 323ff84:	e0fff217 	ldw	r3,-56(fp)
 323ff88:	00820004 	movi	r2,2048
 323ff8c:	1880080d 	sth	r2,32(r3)

         /* now set the Total Length, Fragment Offset, and More Fragments fields */
         newpip = ip_head(newpkt);
 323ff90:	e0bff217 	ldw	r2,-56(fp)
 323ff94:	10800317 	ldw	r2,12(r2)
 323ff98:	e0bff115 	stw	r2,-60(fp)
         newpip->ip_len = htons(newpkt->nb_plen);
 323ff9c:	e0bff217 	ldw	r2,-56(fp)
 323ffa0:	10800417 	ldw	r2,16(r2)
 323ffa4:	1004d23a 	srli	r2,r2,8
 323ffa8:	10803fcc 	andi	r2,r2,255
 323ffac:	1009883a 	mov	r4,r2
 323ffb0:	e0bff217 	ldw	r2,-56(fp)
 323ffb4:	10800417 	ldw	r2,16(r2)
 323ffb8:	1004923a 	slli	r2,r2,8
 323ffbc:	1007883a 	mov	r3,r2
 323ffc0:	00bfc004 	movi	r2,-256
 323ffc4:	1884703a 	and	r2,r3,r2
 323ffc8:	2084b03a 	or	r2,r4,r2
 323ffcc:	1007883a 	mov	r3,r2
 323ffd0:	e0bff117 	ldw	r2,-60(fp)
 323ffd4:	10c0008d 	sth	r3,2(r2)
         /* the following statement will reset DF and MF bits */
         newpip->ip_flgs_foff = htons((parent_frag_offset + (useable_payload_len * i)) >> 3);
 323ffd8:	e13ff38b 	ldhu	r4,-50(fp)
 323ffdc:	e0fff70b 	ldhu	r3,-36(fp)
 323ffe0:	e0bff48b 	ldhu	r2,-46(fp)
 323ffe4:	1885383a 	mul	r2,r3,r2
 323ffe8:	2085883a 	add	r2,r4,r2
 323ffec:	1005d2fa 	srai	r2,r2,11
 323fff0:	10803fcc 	andi	r2,r2,255
 323fff4:	100b883a 	mov	r5,r2
 323fff8:	e13ff38b 	ldhu	r4,-50(fp)
 323fffc:	e0fff70b 	ldhu	r3,-36(fp)
 3240000:	e0bff48b 	ldhu	r2,-46(fp)
 3240004:	1885383a 	mul	r2,r3,r2
 3240008:	2085883a 	add	r2,r4,r2
 324000c:	1005d0fa 	srai	r2,r2,3
 3240010:	1004923a 	slli	r2,r2,8
 3240014:	1007883a 	mov	r3,r2
 3240018:	00bfc004 	movi	r2,-256
 324001c:	1884703a 	and	r2,r3,r2
 3240020:	2884b03a 	or	r2,r5,r2
 3240024:	1007883a 	mov	r3,r2
 3240028:	e0bff117 	ldw	r2,-60(fp)
 324002c:	10c0018d 	sth	r3,6(r2)
          *     child fragments but the last will have the MF bit set)
          * (2) Parent fragment offset = x, MF = 1: first or middle fragment (FF or MF)
          *     (all child fragments will have the MF bit set)
          * (3) Parent fragment offset > 0, MF = 0: last fragment (LF) (all child fragments
          *     except the last will have the MF bit set) */
         if (i < (num_frags - 1))
 3240030:	e0fff48b 	ldhu	r3,-46(fp)
 3240034:	e0bff50b 	ldhu	r2,-44(fp)
 3240038:	10bfffc4 	addi	r2,r2,-1
 324003c:	1880070e 	bge	r3,r2,324005c <ip_fragment+0x4f4>
         {
            newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 3240040:	e0bff117 	ldw	r2,-60(fp)
 3240044:	1080018b 	ldhu	r2,6(r2)
 3240048:	10800814 	ori	r2,r2,32
 324004c:	1007883a 	mov	r3,r2
 3240050:	e0bff117 	ldw	r2,-60(fp)
 3240054:	10c0018d 	sth	r3,6(r2)
 3240058:	00000906 	br	3240080 <ip_fragment+0x518>
         }
         else
         {
            if (parent_mf)
 324005c:	e0bff30b 	ldhu	r2,-52(fp)
 3240060:	1005003a 	cmpeq	r2,r2,zero
 3240064:	1000061e 	bne	r2,zero,3240080 <ip_fragment+0x518>
            {
               newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 3240068:	e0bff117 	ldw	r2,-60(fp)
 324006c:	1080018b 	ldhu	r2,6(r2)
 3240070:	10800814 	ori	r2,r2,32
 3240074:	1007883a 	mov	r3,r2
 3240078:	e0bff117 	ldw	r2,-60(fp)
 324007c:	10c0018d 	sth	r3,6(r2)
            }
         }

         /* finally, update the checksum */
         newpip->ip_chksum = IPXSUM;
 3240080:	e0bff117 	ldw	r2,-60(fp)
 3240084:	1000028d 	sth	zero,10(r2)
         newpip->ip_chksum = ~cksum(newpip, (iphlen/2));
 3240088:	e0bff7c3 	ldbu	r2,-33(fp)
 324008c:	1004d07a 	srli	r2,r2,1
 3240090:	11403fcc 	andi	r5,r2,255
 3240094:	e13ff117 	ldw	r4,-60(fp)
 3240098:	32259f80 	call	32259f8 <cksum>
 324009c:	0084303a 	nor	r2,zero,r2
 32400a0:	1007883a 	mov	r3,r2
 32400a4:	e0bff117 	ldw	r2,-60(fp)
 32400a8:	10c0028d 	sth	r3,10(r2)

         ip_mib.ipFragCreates++;
 32400ac:	0080c9b4 	movhi	r2,806
 32400b0:	10b46004 	addi	r2,r2,-11904
 32400b4:	10801217 	ldw	r2,72(r2)
 32400b8:	10c00044 	addi	r3,r2,1
 32400bc:	0080c9b4 	movhi	r2,806
 32400c0:	10b46004 	addi	r2,r2,-11904
 32400c4:	10c01215 	stw	r3,72(r2)

         /* we're done; hand the packet off to ip2mac () */
         e = ip2mac (newpkt, firsthop);
 32400c8:	e13ff217 	ldw	r4,-56(fp)
 32400cc:	e17ffb17 	ldw	r5,-20(fp)
 32400d0:	32237940 	call	3223794 <ip2mac>
 32400d4:	e0bff015 	stw	r2,-64(fp)
         if (e < 0)
 32400d8:	e0bff017 	ldw	r2,-64(fp)
 32400dc:	1004403a 	cmpge	r2,r2,zero
 32400e0:	1000101e 	bne	r2,zero,3240124 <ip_fragment+0x5bc>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 32400e4:	01000084 	movi	r4,2
 32400e8:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
            pk_free(p);
 32400ec:	e13ffa17 	ldw	r4,-24(fp)
 32400f0:	322a2dc0 	call	322a2dc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32400f4:	01000084 	movi	r4,2
 32400f8:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 32400fc:	0080c9b4 	movhi	r2,806
 3240100:	10b46004 	addi	r2,r2,-11904
 3240104:	10801117 	ldw	r2,68(r2)
 3240108:	10c00044 	addi	r3,r2,1
 324010c:	0080c9b4 	movhi	r2,806
 3240110:	10b46004 	addi	r2,r2,-11904
 3240114:	10c01115 	stw	r3,68(r2)
            return e;
 3240118:	e0bff017 	ldw	r2,-64(fp)
 324011c:	e0bffe15 	stw	r2,-8(fp)
 3240120:	00001406 	br	3240174 <ip_fragment+0x60c>
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 3240124:	e0bff48b 	ldhu	r2,-46(fp)
 3240128:	10800044 	addi	r2,r2,1
 324012c:	e0bff48d 	sth	r2,-46(fp)
 3240130:	e0fff48b 	ldhu	r3,-46(fp)
 3240134:	e0bff50b 	ldhu	r2,-44(fp)
 3240138:	18bf3136 	bltu	r3,r2,323fe00 <ip_fragment+0x298>

   } /* end FOR (all child fragments) */

   /* free the parent buffer since all of the data from it have been copied 
    * out into the child fragments */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 324013c:	01000084 	movi	r4,2
 3240140:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   pk_free(p);
 3240144:	e13ffa17 	ldw	r4,-24(fp)
 3240148:	322a2dc0 	call	322a2dc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324014c:	01000084 	movi	r4,2
 3240150:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 3240154:	0080c9b4 	movhi	r2,806
 3240158:	10b46004 	addi	r2,r2,-11904
 324015c:	10801017 	ldw	r2,64(r2)
 3240160:	10c00044 	addi	r3,r2,1
 3240164:	0080c9b4 	movhi	r2,806
 3240168:	10b46004 	addi	r2,r2,-11904
 324016c:	10c01015 	stw	r3,64(r2)

   return 0;
 3240170:	e03ffe15 	stw	zero,-8(fp)
 3240174:	e0bffe17 	ldw	r2,-8(fp)
}
 3240178:	e037883a 	mov	sp,fp
 324017c:	dfc00117 	ldw	ra,4(sp)
 3240180:	df000017 	ldw	fp,0(sp)
 3240184:	dec00204 	addi	sp,sp,8
 3240188:	f800283a 	ret

0324018c <ip_mymach>:
 * certain foreign host. 
 */

ip_addr
ip_mymach(ip_addr host)
{
 324018c:	defff904 	addi	sp,sp,-28
 3240190:	dfc00615 	stw	ra,24(sp)
 3240194:	df000515 	stw	fp,20(sp)
 3240198:	df000504 	addi	fp,sp,20
 324019c:	e13ffe15 	stw	r4,-8(fp)

#ifndef MULTI_HOMED /* single static interface */
   USE_ARG(host);
   return(nets[0]->n_ipaddr);   /* always use address from only net */
#else   /* MULTI_HOMED */
   tnet = iproute(host, &temp);
 32401a0:	e17ffd04 	addi	r5,fp,-12
 32401a4:	e13ffe17 	ldw	r4,-8(fp)
 32401a8:	32404f00 	call	32404f0 <iproute>
 32401ac:	e0bffc15 	stw	r2,-16(fp)
   if (tnet == 0)
 32401b0:	e0bffc17 	ldw	r2,-16(fp)
 32401b4:	1004c03a 	cmpne	r2,r2,zero
 32401b8:	1000161e 	bne	r2,zero,3240214 <ip_mymach+0x88>
   {
#ifdef   NPDEBUG
      if (NDEBUG & (PROTERR|INFOMSG))
 32401bc:	0080c974 	movhi	r2,805
 32401c0:	10923104 	addi	r2,r2,18628
 32401c4:	10800017 	ldw	r2,0(r2)
 32401c8:	1080050c 	andi	r2,r2,20
 32401cc:	1005003a 	cmpeq	r2,r2,zero
 32401d0:	10000e1e 	bne	r2,zero,324020c <ip_mymach+0x80>
         dprintf("IP: Couldn't route to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 32401d4:	e0bffe17 	ldw	r2,-8(fp)
 32401d8:	11403fcc 	andi	r5,r2,255
 32401dc:	e0bffe17 	ldw	r2,-8(fp)
 32401e0:	1004d23a 	srli	r2,r2,8
 32401e4:	11803fcc 	andi	r6,r2,255
 32401e8:	e0bffe17 	ldw	r2,-8(fp)
 32401ec:	1004d43a 	srli	r2,r2,16
 32401f0:	11c03fcc 	andi	r7,r2,255
 32401f4:	e0bffe17 	ldw	r2,-8(fp)
 32401f8:	1004d63a 	srli	r2,r2,24
 32401fc:	d8800015 	stw	r2,0(sp)
 3240200:	0100c974 	movhi	r4,805
 3240204:	213e6204 	addi	r4,r4,-1656
 3240208:	3206adc0 	call	3206adc <printf>
#endif   /* NPDEBUG */
      return 0L;
 324020c:	e03fff15 	stw	zero,-4(fp)
 3240210:	00000306 	br	3240220 <ip_mymach+0x94>
   }
   return tnet->n_ipaddr;
 3240214:	e0bffc17 	ldw	r2,-16(fp)
 3240218:	10800a17 	ldw	r2,40(r2)
 324021c:	e0bfff15 	stw	r2,-4(fp)
 3240220:	e0bfff17 	ldw	r2,-4(fp)
#endif /* MULTI_HOMED */
}
 3240224:	e037883a 	mov	sp,fp
 3240228:	dfc00117 	ldw	ra,4(sp)
 324022c:	df000017 	ldw	fp,0(sp)
 3240230:	dec00204 	addi	sp,sp,8
 3240234:	f800283a 	ret

03240238 <ip_dump>:
 * RETURNS: void
 */

void
ip_dump(PACKET p)
{
 3240238:	defff204 	addi	sp,sp,-56
 324023c:	dfc00d15 	stw	ra,52(sp)
 3240240:	df000c15 	stw	fp,48(sp)
 3240244:	df000c04 	addi	fp,sp,48
 3240248:	e13ffa15 	stw	r4,-24(fp)
   struct ip * pip;
   unsigned char * cp;
   unsigned short xsum, osum;

   pip = ip_head(p);
 324024c:	e0bffa17 	ldw	r2,-24(fp)
 3240250:	10800317 	ldw	r2,12(r2)
 3240254:	e0bff915 	stw	r2,-28(fp)
   osum = pip->ip_chksum;
 3240258:	e0bff917 	ldw	r2,-28(fp)
 324025c:	1080028b 	ldhu	r2,10(r2)
 3240260:	e0bff70d 	sth	r2,-36(fp)
   pip->ip_chksum = 0;
 3240264:	e0bff917 	ldw	r2,-28(fp)
 3240268:	1000028d 	sth	zero,10(r2)
   xsum = ~cksum(pip, ip_hlen(pip) >> 1);
 324026c:	e0bff917 	ldw	r2,-28(fp)
 3240270:	10800003 	ldbu	r2,0(r2)
 3240274:	10803fcc 	andi	r2,r2,255
 3240278:	108003cc 	andi	r2,r2,15
 324027c:	1085883a 	add	r2,r2,r2
 3240280:	1085883a 	add	r2,r2,r2
 3240284:	1005d07a 	srai	r2,r2,1
 3240288:	100b883a 	mov	r5,r2
 324028c:	e13ff917 	ldw	r4,-28(fp)
 3240290:	32259f80 	call	32259f8 <cksum>
 3240294:	0084303a 	nor	r2,zero,r2
 3240298:	e0bff78d 	sth	r2,-34(fp)

   if (osum != xsum)          /* trap here if checksum is wrong */
 324029c:	e0fff70b 	ldhu	r3,-36(fp)
 32402a0:	e0bff78b 	ldhu	r2,-34(fp)
 32402a4:	18800126 	beq	r3,r2,32402ac <ip_dump+0x74>
   {
      dtrap();
 32402a8:	322ab8c0 	call	322ab8c <dtrap>
   /* dtrap() is fatal in the default Windows implementation, so
    * we comment it out */
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
 32402ac:	0009883a 	mov	r4,zero
 32402b0:	0140c974 	movhi	r5,805
 32402b4:	297e6b04 	addi	r5,r5,-1620
 32402b8:	32260180 	call	3226018 <ns_printf>
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
 32402bc:	e0bff917 	ldw	r2,-28(fp)
 32402c0:	e0bff815 	stw	r2,-32(fp)
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 32402c4:	e0bff817 	ldw	r2,-32(fp)
 32402c8:	10800003 	ldbu	r2,0(r2)
 32402cc:	11803fcc 	andi	r6,r2,255
 32402d0:	e0bff817 	ldw	r2,-32(fp)
 32402d4:	10800044 	addi	r2,r2,1
 32402d8:	10800003 	ldbu	r2,0(r2)
 32402dc:	11c03fcc 	andi	r7,r2,255
 32402e0:	e0bff917 	ldw	r2,-28(fp)
 32402e4:	1080008b 	ldhu	r2,2(r2)
 32402e8:	10bfffcc 	andi	r2,r2,65535
 32402ec:	1004d23a 	srli	r2,r2,8
 32402f0:	10bfffcc 	andi	r2,r2,65535
 32402f4:	10c03fcc 	andi	r3,r2,255
 32402f8:	e0bff917 	ldw	r2,-28(fp)
 32402fc:	1080008b 	ldhu	r2,2(r2)
 3240300:	10bfffcc 	andi	r2,r2,65535
 3240304:	1004923a 	slli	r2,r2,8
 3240308:	10bfc00c 	andi	r2,r2,65280
 324030c:	1888b03a 	or	r4,r3,r2
 3240310:	e0bff917 	ldw	r2,-28(fp)
 3240314:	1080010b 	ldhu	r2,4(r2)
 3240318:	10bfffcc 	andi	r2,r2,65535
 324031c:	1004d23a 	srli	r2,r2,8
 3240320:	10bfffcc 	andi	r2,r2,65535
 3240324:	10c03fcc 	andi	r3,r2,255
 3240328:	e0bff917 	ldw	r2,-28(fp)
 324032c:	1080010b 	ldhu	r2,4(r2)
 3240330:	10bfffcc 	andi	r2,r2,65535
 3240334:	1004923a 	slli	r2,r2,8
 3240338:	10bfc00c 	andi	r2,r2,65280
 324033c:	1884b03a 	or	r2,r3,r2
 3240340:	d9000015 	stw	r4,0(sp)
 3240344:	d8800115 	stw	r2,4(sp)
 3240348:	0009883a 	mov	r4,zero
 324034c:	0140c974 	movhi	r5,805
 3240350:	297e7004 	addi	r5,r5,-1600
 3240354:	32260180 	call	3226018 <ns_printf>
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 3240358:	e0bff817 	ldw	r2,-32(fp)
 324035c:	10800184 	addi	r2,r2,6
 3240360:	1080000b 	ldhu	r2,0(r2)
 3240364:	10bfffcc 	andi	r2,r2,65535
 3240368:	1004d23a 	srli	r2,r2,8
 324036c:	10bfffcc 	andi	r2,r2,65535
 3240370:	10c03fcc 	andi	r3,r2,255
 3240374:	e0bff817 	ldw	r2,-32(fp)
 3240378:	10800184 	addi	r2,r2,6
 324037c:	1080000b 	ldhu	r2,0(r2)
 3240380:	10bfffcc 	andi	r2,r2,65535
 3240384:	1004923a 	slli	r2,r2,8
 3240388:	10bfc00c 	andi	r2,r2,65280
 324038c:	1886b03a 	or	r3,r3,r2
 3240390:	e0ffff15 	stw	r3,-4(fp)
 3240394:	e0bff917 	ldw	r2,-28(fp)
 3240398:	10800203 	ldbu	r2,8(r2)
 324039c:	10803fcc 	andi	r2,r2,255
 32403a0:	e0bffe15 	stw	r2,-8(fp)
 32403a4:	e0bff917 	ldw	r2,-28(fp)
 32403a8:	10800243 	ldbu	r2,9(r2)
 32403ac:	10803fcc 	andi	r2,r2,255
 32403b0:	e0bffd15 	stw	r2,-12(fp)
 32403b4:	e0bff70b 	ldhu	r2,-36(fp)
 32403b8:	1004d23a 	srli	r2,r2,8
 32403bc:	10bfffcc 	andi	r2,r2,65535
 32403c0:	10c03fcc 	andi	r3,r2,255
 32403c4:	e0bff70b 	ldhu	r2,-36(fp)
 32403c8:	1004923a 	slli	r2,r2,8
 32403cc:	10bfc00c 	andi	r2,r2,65280
 32403d0:	1886b03a 	or	r3,r3,r2
 32403d4:	e0fffc15 	stw	r3,-16(fp)
 32403d8:	e0fff70b 	ldhu	r3,-36(fp)
 32403dc:	e0bff78b 	ldhu	r2,-34(fp)
 32403e0:	1880041e 	bne	r3,r2,32403f4 <ip_dump+0x1bc>
 32403e4:	0080c974 	movhi	r2,805
 32403e8:	10be7c04 	addi	r2,r2,-1552
 32403ec:	e0bffb15 	stw	r2,-20(fp)
 32403f0:	00000306 	br	3240400 <ip_dump+0x1c8>
 32403f4:	0080c974 	movhi	r2,805
 32403f8:	10be7d04 	addi	r2,r2,-1548
 32403fc:	e0bffb15 	stw	r2,-20(fp)
 3240400:	e0bffd17 	ldw	r2,-12(fp)
 3240404:	d8800015 	stw	r2,0(sp)
 3240408:	e0bffc17 	ldw	r2,-16(fp)
 324040c:	d8800115 	stw	r2,4(sp)
 3240410:	e0bffb17 	ldw	r2,-20(fp)
 3240414:	d8800215 	stw	r2,8(sp)
 3240418:	0009883a 	mov	r4,zero
 324041c:	0140c974 	movhi	r5,805
 3240420:	297e7e04 	addi	r5,r5,-1544
 3240424:	e1bfff17 	ldw	r6,-4(fp)
 3240428:	e1fffe17 	ldw	r7,-8(fp)
 324042c:	32260180 	call	3226018 <ns_printf>
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
   ns_printf(NULL ,"src: %u.%u.%u.%u  ", PUSH_IPADDR(pip->ip_src));
 3240430:	e0bff917 	ldw	r2,-28(fp)
 3240434:	10800317 	ldw	r2,12(r2)
 3240438:	11803fcc 	andi	r6,r2,255
 324043c:	e0bff917 	ldw	r2,-28(fp)
 3240440:	10800317 	ldw	r2,12(r2)
 3240444:	1004d23a 	srli	r2,r2,8
 3240448:	11c03fcc 	andi	r7,r2,255
 324044c:	e0bff917 	ldw	r2,-28(fp)
 3240450:	10800317 	ldw	r2,12(r2)
 3240454:	1004d43a 	srli	r2,r2,16
 3240458:	10c03fcc 	andi	r3,r2,255
 324045c:	e0bff917 	ldw	r2,-28(fp)
 3240460:	10800317 	ldw	r2,12(r2)
 3240464:	1004d63a 	srli	r2,r2,24
 3240468:	d8c00015 	stw	r3,0(sp)
 324046c:	d8800115 	stw	r2,4(sp)
 3240470:	0009883a 	mov	r4,zero
 3240474:	0140c974 	movhi	r5,805
 3240478:	297e8e04 	addi	r5,r5,-1480
 324047c:	32260180 	call	3226018 <ns_printf>
   ns_printf(NULL ,"dest: %u.%u.%u.%u\n", PUSH_IPADDR(pip->ip_dest));
 3240480:	e0bff917 	ldw	r2,-28(fp)
 3240484:	10800417 	ldw	r2,16(r2)
 3240488:	11803fcc 	andi	r6,r2,255
 324048c:	e0bff917 	ldw	r2,-28(fp)
 3240490:	10800417 	ldw	r2,16(r2)
 3240494:	1004d23a 	srli	r2,r2,8
 3240498:	11c03fcc 	andi	r7,r2,255
 324049c:	e0bff917 	ldw	r2,-28(fp)
 32404a0:	10800417 	ldw	r2,16(r2)
 32404a4:	1004d43a 	srli	r2,r2,16
 32404a8:	10c03fcc 	andi	r3,r2,255
 32404ac:	e0bff917 	ldw	r2,-28(fp)
 32404b0:	10800417 	ldw	r2,16(r2)
 32404b4:	1004d63a 	srli	r2,r2,24
 32404b8:	d8c00015 	stw	r3,0(sp)
 32404bc:	d8800115 	stw	r2,4(sp)
 32404c0:	0009883a 	mov	r4,zero
 32404c4:	0140c974 	movhi	r5,805
 32404c8:	297e9304 	addi	r5,r5,-1460
 32404cc:	32260180 	call	3226018 <ns_printf>

   pip->ip_chksum = osum;     /* fix what we clobbered */
 32404d0:	e0fff917 	ldw	r3,-28(fp)
 32404d4:	e0bff70b 	ldhu	r2,-36(fp)
 32404d8:	1880028d 	sth	r2,10(r3)
}
 32404dc:	e037883a 	mov	sp,fp
 32404e0:	dfc00117 	ldw	ra,4(sp)
 32404e4:	df000017 	ldw	fp,0(sp)
 32404e8:	dec00204 	addi	sp,sp,8
 32404ec:	f800283a 	ret

032404f0 <iproute>:
 * RETURNS: Returns NULL when unable to route, else returns a NET pointer.
 */

NET
iproute(ip_addr host, ip_addr * hop1)
{
 32404f0:	defff704 	addi	sp,sp,-36
 32404f4:	dfc00815 	stw	ra,32(sp)
 32404f8:	df000715 	stw	fp,28(sp)
 32404fc:	df000704 	addi	fp,sp,28
 3240500:	e13ffd15 	stw	r4,-12(fp)
 3240504:	e17ffe15 	stw	r5,-8(fp)
   NET      ifp;
#ifdef IP_ROUTING
   RTMIB    rtp;
#endif   /* IP_ROUTING */

   if (host == 0L)      /* Sanity check parameter. */
 3240508:	e0bffd17 	ldw	r2,-12(fp)
 324050c:	1004c03a 	cmpne	r2,r2,zero
 3240510:	1000021e 	bne	r2,zero,324051c <iproute+0x2c>
      return NULL;
 3240514:	e03fff15 	stw	zero,-4(fp)
 3240518:	00008a06 	br	3240744 <iproute+0x254>
    * stack has been initialized (tk_yield() gets called out of the 
    * dialer code as part of PPP initialization), one symptom of 
    * which is the routing table not being present yet. if this 
    * happens, quit. 
    */
   if (rt_mib == NULL)
 324051c:	d0a8fd17 	ldw	r2,-23564(gp)
 3240520:	1004c03a 	cmpne	r2,r2,zero
 3240524:	1000021e 	bne	r2,zero,3240530 <iproute+0x40>
      return NULL;
 3240528:	e03fff15 	stw	zero,-4(fp)
 324052c:	00008506 	br	3240744 <iproute+0x254>
#endif   /* BTREE_ROUTING */

   /* see if the host matches the cached route */
   if (cachedRoute)     /* don't test this if route is null  */
 3240530:	0080c974 	movhi	r2,805
 3240534:	10927e04 	addi	r2,r2,18936
 3240538:	10800017 	ldw	r2,0(r2)
 324053c:	1005003a 	cmpeq	r2,r2,zero
 3240540:	1000191e 	bne	r2,zero,32405a8 <iproute+0xb8>
   {
      if (cachedRoute->ipRouteDest == host)    /* exact match */
 3240544:	0080c974 	movhi	r2,805
 3240548:	10927e04 	addi	r2,r2,18936
 324054c:	10800017 	ldw	r2,0(r2)
 3240550:	10c00017 	ldw	r3,0(r2)
 3240554:	e0bffd17 	ldw	r2,-12(fp)
 3240558:	1880131e 	bne	r3,r2,32405a8 <iproute+0xb8>
      {
         *hop1 = cachedRoute->ipRouteNextHop;   /* fill in nexthop IP addr */
 324055c:	0080c974 	movhi	r2,805
 3240560:	10927e04 	addi	r2,r2,18936
 3240564:	10800017 	ldw	r2,0(r2)
 3240568:	10c00617 	ldw	r3,24(r2)
 324056c:	e0bffe17 	ldw	r2,-8(fp)
 3240570:	10c00015 	stw	r3,0(r2)
         cachedRoute->ipRouteAge = cticks;      /* timestamp route entry */
 3240574:	0080c974 	movhi	r2,805
 3240578:	10927e04 	addi	r2,r2,18936
 324057c:	10c00017 	ldw	r3,0(r2)
 3240580:	0080c974 	movhi	r2,805
 3240584:	10925604 	addi	r2,r2,18776
 3240588:	10800017 	ldw	r2,0(r2)
 324058c:	18800915 	stw	r2,36(r3)
         return(cachedRoute->ifp); /* net to send on */
 3240590:	0080c974 	movhi	r2,805
 3240594:	10927e04 	addi	r2,r2,18936
 3240598:	10800017 	ldw	r2,0(r2)
 324059c:	10800e17 	ldw	r2,56(r2)
 32405a0:	e0bfff15 	stw	r2,-4(fp)
 32405a4:	00006706 	br	3240744 <iproute+0x254>
      }
   }

   rtp = rt_lookup(host);
 32405a8:	e13ffd17 	ldw	r4,-12(fp)
 32405ac:	3243d900 	call	3243d90 <rt_lookup>
 32405b0:	e0bffa15 	stw	r2,-24(fp)
   if(rtp)
 32405b4:	e0bffa17 	ldw	r2,-24(fp)
 32405b8:	1005003a 	cmpeq	r2,r2,zero
 32405bc:	10000c1e 	bne	r2,zero,32405f0 <iproute+0x100>
   {
      cachedRoute = rtp;
 32405c0:	00c0c974 	movhi	r3,805
 32405c4:	18d27e04 	addi	r3,r3,18936
 32405c8:	e0bffa17 	ldw	r2,-24(fp)
 32405cc:	18800015 	stw	r2,0(r3)
      *hop1 = rtp->ipRouteNextHop;  /* fill in IP dest (next hop) */
 32405d0:	e0bffa17 	ldw	r2,-24(fp)
 32405d4:	10c00617 	ldw	r3,24(r2)
 32405d8:	e0bffe17 	ldw	r2,-8(fp)
 32405dc:	10c00015 	stw	r3,0(r2)
      return(rtp->ifp);             /* return pointer to net */
 32405e0:	e0bffa17 	ldw	r2,-24(fp)
 32405e4:	10800e17 	ldw	r2,56(r2)
 32405e8:	e0bfff15 	stw	r2,-4(fp)
 32405ec:	00005506 	br	3240744 <iproute+0x254>
    * the initial state for the for loop that iterates through the
    * list), but only build the iterator for multi-homed systems
    * because single-homed systems are often memory-limited systems as
    * well.  
    */
   ifp = (NET)(netlist.q_head);
 32405f0:	0080c9b4 	movhi	r2,806
 32405f4:	10b45b04 	addi	r2,r2,-11924
 32405f8:	10800017 	ldw	r2,0(r2)
 32405fc:	e0bffb15 	stw	r2,-20(fp)
   i = 0;
 3240600:	e03ffc15 	stw	zero,-16(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 3240604:	00002f06 	br	32406c4 <iproute+0x1d4>
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 3240608:	e0bffb17 	ldw	r2,-20(fp)
 324060c:	10800c17 	ldw	r2,48(r2)
 3240610:	1005003a 	cmpeq	r2,r2,zero
 3240614:	1000251e 	bne	r2,zero,32406ac <iproute+0x1bc>
 3240618:	e0bffb17 	ldw	r2,-20(fp)
 324061c:	10800a17 	ldw	r2,40(r2)
 3240620:	1005003a 	cmpeq	r2,r2,zero
 3240624:	1000211e 	bne	r2,zero,32406ac <iproute+0x1bc>
 3240628:	e0bffb17 	ldw	r2,-20(fp)
 324062c:	10c00a17 	ldw	r3,40(r2)
 3240630:	e0bffb17 	ldw	r2,-20(fp)
 3240634:	10800c17 	ldw	r2,48(r2)
 3240638:	1888703a 	and	r4,r3,r2
 324063c:	e0bffb17 	ldw	r2,-20(fp)
 3240640:	10c00c17 	ldw	r3,48(r2)
 3240644:	e0bffd17 	ldw	r2,-12(fp)
 3240648:	1884703a 	and	r2,r3,r2
 324064c:	2080171e 	bne	r4,r2,32406ac <iproute+0x1bc>
         (ifp->n_ipaddr != 0) && 
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
      {
#ifdef IP_ROUTING
         /* make a cached Route entry for next time */
         cachedRoute = add_route(host, 0xFFFFFFFF, host, i, IPRP_OTHER);
 3240650:	00800044 	movi	r2,1
 3240654:	d8800015 	stw	r2,0(sp)
 3240658:	e13ffd17 	ldw	r4,-12(fp)
 324065c:	017fffc4 	movi	r5,-1
 3240660:	e1bffd17 	ldw	r6,-12(fp)
 3240664:	e1fffc17 	ldw	r7,-16(fp)
 3240668:	3243f140 	call	3243f14 <add_route>
 324066c:	1007883a 	mov	r3,r2
 3240670:	0080c974 	movhi	r2,805
 3240674:	10927e04 	addi	r2,r2,18936
 3240678:	10c00015 	stw	r3,0(r2)
#ifdef NPDEBUG
         if (cachedRoute == NULL)
 324067c:	0080c974 	movhi	r2,805
 3240680:	10927e04 	addi	r2,r2,18936
 3240684:	10800017 	ldw	r2,0(r2)
 3240688:	1004c03a 	cmpne	r2,r2,zero
 324068c:	1000011e 	bne	r2,zero,3240694 <iproute+0x1a4>
            dtrap();
 3240690:	322ab8c0 	call	322ab8c <dtrap>
#endif   /* NPDEBUG */
#endif   /* IP_ROUTING */
         *hop1 = host;
 3240694:	e0fffe17 	ldw	r3,-8(fp)
 3240698:	e0bffd17 	ldw	r2,-12(fp)
 324069c:	18800015 	stw	r2,0(r3)
         return ifp;
 32406a0:	e0bffb17 	ldw	r2,-20(fp)
 32406a4:	e0bfff15 	stw	r2,-4(fp)
 32406a8:	00002606 	br	3240744 <iproute+0x254>
    * well.  
    */
   ifp = (NET)(netlist.q_head);
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 32406ac:	e0bffb17 	ldw	r2,-20(fp)
 32406b0:	10800017 	ldw	r2,0(r2)
 32406b4:	e0bffb15 	stw	r2,-20(fp)
 32406b8:	e0bffc17 	ldw	r2,-16(fp)
 32406bc:	10800044 	addi	r2,r2,1
 32406c0:	e0bffc15 	stw	r2,-16(fp)
 32406c4:	e0bffb17 	ldw	r2,-20(fp)
 32406c8:	1004c03a 	cmpne	r2,r2,zero
 32406cc:	103fce1e 	bne	r2,zero,3240608 <iproute+0x118>
#endif   /* IP_LOOPBACK */

   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
 32406d0:	0080c9b4 	movhi	r2,806
 32406d4:	10b45b04 	addi	r2,r2,-11924
 32406d8:	10800017 	ldw	r2,0(r2)
 32406dc:	e0bffb15 	stw	r2,-20(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 32406e0:	00000e06 	br	324071c <iproute+0x22c>
#endif   /* MULTI_HOMED */
   {
      /* Check if this net has a gateway */
      if(ifp->n_defgw)
 32406e4:	e0bffb17 	ldw	r2,-20(fp)
 32406e8:	10800d17 	ldw	r2,52(r2)
 32406ec:	1005003a 	cmpeq	r2,r2,zero
 32406f0:	1000071e 	bne	r2,zero,3240710 <iproute+0x220>
      {
         *hop1 = ifp->n_defgw;
 32406f4:	e0bffb17 	ldw	r2,-20(fp)
 32406f8:	10c00d17 	ldw	r3,52(r2)
 32406fc:	e0bffe17 	ldw	r2,-8(fp)
 3240700:	10c00015 	stw	r3,0(r2)
         return ifp;
 3240704:	e0bffb17 	ldw	r2,-20(fp)
 3240708:	e0bfff15 	stw	r2,-4(fp)
 324070c:	00000d06 	br	3240744 <iproute+0x254>
   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 3240710:	e0bffb17 	ldw	r2,-20(fp)
 3240714:	10800017 	ldw	r2,0(r2)
 3240718:	e0bffb15 	stw	r2,-20(fp)
 324071c:	e0bffb17 	ldw	r2,-20(fp)
 3240720:	1004c03a 	cmpne	r2,r2,zero
 3240724:	103fef1e 	bne	r2,zero,32406e4 <iproute+0x1f4>
   /* if no gateway is set, then change the first hop address to the 
    * host we're trying to route to. this is just a kluge to make 
    * this work with arp routing. otherwise, we would try to return 
    * some sort of error indication. 
    */
   *hop1 = host;
 3240728:	e0fffe17 	ldw	r3,-8(fp)
 324072c:	e0bffd17 	ldw	r2,-12(fp)
 3240730:	18800015 	stw	r2,0(r3)
   return((NET)(netlist.q_head));
 3240734:	0080c9b4 	movhi	r2,806
 3240738:	10b45b04 	addi	r2,r2,-11924
 324073c:	10800017 	ldw	r2,0(r2)
 3240740:	e0bfff15 	stw	r2,-4(fp)
 3240744:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* STRICT_SUBNETTING */
}
 3240748:	e037883a 	mov	sp,fp
 324074c:	dfc00117 	ldw	ra,4(sp)
 3240750:	df000017 	ldw	fp,0(sp)
 3240754:	dec00204 	addi	sp,sp,8
 3240758:	f800283a 	ret

0324075c <ip_copypkt>:
 * RETURNS: a pointer to the new copy of the packet,
 *          or NULL if no packet buffer could be allocated
 */
PACKET
ip_copypkt(PACKET p)
{
 324075c:	defffa04 	addi	sp,sp,-24
 3240760:	dfc00515 	stw	ra,20(sp)
 3240764:	df000415 	stw	fp,16(sp)
 3240768:	df000404 	addi	fp,sp,16
 324076c:	e13ffe15 	stw	r4,-8(fp)
   int len;

   /* figure out how much we need to copy from the packet, 
    * and allocate a new buffer to hold it 
    */
   len = p->nb_plen + (p->nb_prot - p->nb_buff);
 3240770:	e0bffe17 	ldw	r2,-8(fp)
 3240774:	11000417 	ldw	r4,16(r2)
 3240778:	e0bffe17 	ldw	r2,-8(fp)
 324077c:	10800317 	ldw	r2,12(r2)
 3240780:	1007883a 	mov	r3,r2
 3240784:	e0bffe17 	ldw	r2,-8(fp)
 3240788:	10800117 	ldw	r2,4(r2)
 324078c:	1885c83a 	sub	r2,r3,r2
 3240790:	2085883a 	add	r2,r4,r2
 3240794:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 3240798:	01000084 	movi	r4,2
 324079c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   np = pk_alloc(len);
 32407a0:	e13ffc17 	ldw	r4,-16(fp)
 32407a4:	3229f480 	call	3229f48 <pk_alloc>
 32407a8:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32407ac:	01000084 	movi	r4,2
 32407b0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   if (np == NULL)
 32407b4:	e0bffd17 	ldw	r2,-12(fp)
 32407b8:	1004c03a 	cmpne	r2,r2,zero
 32407bc:	1000061e 	bne	r2,zero,32407d8 <ip_copypkt+0x7c>
   {
#ifdef NPDEBUG
      dprintf("ip_copypkt(): unable to obtain packet (len %d)\n", len);
 32407c0:	0100c974 	movhi	r4,805
 32407c4:	213e9804 	addi	r4,r4,-1440
 32407c8:	e17ffc17 	ldw	r5,-16(fp)
 32407cc:	3206adc0 	call	3206adc <printf>
#endif
      return NULL;
 32407d0:	e03fff15 	stw	zero,-4(fp)
 32407d4:	00002906 	br	324087c <ip_copypkt+0x120>
   }

   /* copy packet data into new buffer */
   MEMCPY(np->nb_buff, p->nb_buff, len);
 32407d8:	e0bffd17 	ldw	r2,-12(fp)
 32407dc:	11000117 	ldw	r4,4(r2)
 32407e0:	e0bffe17 	ldw	r2,-8(fp)
 32407e4:	10800117 	ldw	r2,4(r2)
 32407e8:	e0fffc17 	ldw	r3,-16(fp)
 32407ec:	100b883a 	mov	r5,r2
 32407f0:	180d883a 	mov	r6,r3
 32407f4:	32067cc0 	call	32067cc <memcpy>

   /* copy relevant packet fields */
   np->nb_prot = np->nb_buff + (p->nb_prot - p->nb_buff);
 32407f8:	e0bffd17 	ldw	r2,-12(fp)
 32407fc:	11000117 	ldw	r4,4(r2)
 3240800:	e0bffe17 	ldw	r2,-8(fp)
 3240804:	10800317 	ldw	r2,12(r2)
 3240808:	1007883a 	mov	r3,r2
 324080c:	e0bffe17 	ldw	r2,-8(fp)
 3240810:	10800117 	ldw	r2,4(r2)
 3240814:	1885c83a 	sub	r2,r3,r2
 3240818:	2087883a 	add	r3,r4,r2
 324081c:	e0bffd17 	ldw	r2,-12(fp)
 3240820:	10c00315 	stw	r3,12(r2)
   np->nb_plen = p->nb_plen;
 3240824:	e0bffe17 	ldw	r2,-8(fp)
 3240828:	10c00417 	ldw	r3,16(r2)
 324082c:	e0bffd17 	ldw	r2,-12(fp)
 3240830:	10c00415 	stw	r3,16(r2)
   np->net = p->net;
 3240834:	e0bffe17 	ldw	r2,-8(fp)
 3240838:	10c00617 	ldw	r3,24(r2)
 324083c:	e0bffd17 	ldw	r2,-12(fp)
 3240840:	10c00615 	stw	r3,24(r2)
   np->fhost = p->fhost;
 3240844:	e0bffe17 	ldw	r2,-8(fp)
 3240848:	10c00717 	ldw	r3,28(r2)
 324084c:	e0bffd17 	ldw	r2,-12(fp)
 3240850:	10c00715 	stw	r3,28(r2)
   np->type = p->type;
 3240854:	e0bffe17 	ldw	r2,-8(fp)
 3240858:	10c0080b 	ldhu	r3,32(r2)
 324085c:	e0bffd17 	ldw	r2,-12(fp)
 3240860:	10c0080d 	sth	r3,32(r2)
   np->nb_tstamp = p->nb_tstamp;
 3240864:	e0bffe17 	ldw	r2,-8(fp)
 3240868:	10c00517 	ldw	r3,20(r2)
 324086c:	e0bffd17 	ldw	r2,-12(fp)
 3240870:	10c00515 	stw	r3,20(r2)

   /* return pointer to the copy */
   return np;
 3240874:	e0bffd17 	ldw	r2,-12(fp)
 3240878:	e0bfff15 	stw	r2,-4(fp)
 324087c:	e0bfff17 	ldw	r2,-4(fp)
}
 3240880:	e037883a 	mov	sp,fp
 3240884:	dfc00117 	ldw	ra,4(sp)
 3240888:	df000017 	ldw	fp,0(sp)
 324088c:	dec00204 	addi	sp,sp,8
 3240890:	f800283a 	ret

03240894 <ip_reasm_match_frag_with_ire>:
packet being processed.  If no such entry is found, this function returns 
NULL.
*/

IREP ip_reasm_match_frag_with_ire (struct ip * pip)
{
 3240894:	defff904 	addi	sp,sp,-28
 3240898:	df000615 	stw	fp,24(sp)
 324089c:	df000604 	addi	fp,sp,24
 32408a0:	e13ffe15 	stw	r4,-8(fp)
   ip_addr dest;
   u_char prot;
   u_short id;
   IREP tmpp;
 
   src = pip->ip_src;
 32408a4:	e0bffe17 	ldw	r2,-8(fp)
 32408a8:	10800317 	ldw	r2,12(r2)
 32408ac:	e0bffd15 	stw	r2,-12(fp)
   dest = pip->ip_dest;
 32408b0:	e0bffe17 	ldw	r2,-8(fp)
 32408b4:	10800417 	ldw	r2,16(r2)
 32408b8:	e0bffc15 	stw	r2,-16(fp)
   prot = pip->ip_prot;
 32408bc:	e0bffe17 	ldw	r2,-8(fp)
 32408c0:	10800243 	ldbu	r2,9(r2)
 32408c4:	e0bffb85 	stb	r2,-18(fp)
   id = pip->ip_id;
 32408c8:	e0bffe17 	ldw	r2,-8(fp)
 32408cc:	1080010b 	ldhu	r2,4(r2)
 32408d0:	e0bffb0d 	sth	r2,-20(fp)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 32408d4:	d0a8ff17 	ldw	r2,-23556(gp)
 32408d8:	e0bffa15 	stw	r2,-24(fp)
 32408dc:	00001806 	br	3240940 <ip_reasm_match_frag_with_ire+0xac>
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 32408e0:	e0bffa17 	ldw	r2,-24(fp)
 32408e4:	10c00117 	ldw	r3,4(r2)
 32408e8:	e0bffd17 	ldw	r2,-12(fp)
 32408ec:	1880111e 	bne	r3,r2,3240934 <ip_reasm_match_frag_with_ire+0xa0>
 32408f0:	e0bffa17 	ldw	r2,-24(fp)
 32408f4:	10c00217 	ldw	r3,8(r2)
 32408f8:	e0bffc17 	ldw	r2,-16(fp)
 32408fc:	18800d1e 	bne	r3,r2,3240934 <ip_reasm_match_frag_with_ire+0xa0>
 3240900:	e0bffa17 	ldw	r2,-24(fp)
 3240904:	10800383 	ldbu	r2,14(r2)
 3240908:	10c03fcc 	andi	r3,r2,255
 324090c:	e0bffb83 	ldbu	r2,-18(fp)
 3240910:	1880081e 	bne	r3,r2,3240934 <ip_reasm_match_frag_with_ire+0xa0>
 3240914:	e0bffa17 	ldw	r2,-24(fp)
 3240918:	1080030b 	ldhu	r2,12(r2)
 324091c:	10ffffcc 	andi	r3,r2,65535
 3240920:	e0bffb0b 	ldhu	r2,-20(fp)
 3240924:	1880031e 	bne	r3,r2,3240934 <ip_reasm_match_frag_with_ire+0xa0>
          (tmpp->prot == prot) && (tmpp->id == id))
         {
         return tmpp; /* we've found a match */
 3240928:	e0bffa17 	ldw	r2,-24(fp)
 324092c:	e0bfff15 	stw	r2,-4(fp)
 3240930:	00000706 	br	3240950 <ip_reasm_match_frag_with_ire+0xbc>
   prot = pip->ip_prot;
   id = pip->ip_id;

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 3240934:	e0bffa17 	ldw	r2,-24(fp)
 3240938:	10800017 	ldw	r2,0(r2)
 324093c:	e0bffa15 	stw	r2,-24(fp)
 3240940:	e0bffa17 	ldw	r2,-24(fp)
 3240944:	1004c03a 	cmpne	r2,r2,zero
 3240948:	103fe51e 	bne	r2,zero,32408e0 <ip_reasm_match_frag_with_ire+0x4c>
         return tmpp; /* we've found a match */
         }
      }

   /* no match found */
   return NULL;
 324094c:	e03fff15 	stw	zero,-4(fp)
 3240950:	e0bfff17 	ldw	r2,-4(fp)
}
 3240954:	e037883a 	mov	sp,fp
 3240958:	df000017 	ldw	fp,0(sp)
 324095c:	dec00104 	addi	sp,sp,4
 3240960:	f800283a 	ret

03240964 <ip_reasm_determine_type_of_frag>:
OUTPUT: One of the various IP_FRAGTYPE values (IP_CP, IP_FF, IP_MF, 
or IP_LF)
*/

IP_FRAGTYPE ip_reasm_determine_type_of_frag (struct ip * pip)
{
 3240964:	defffc04 	addi	sp,sp,-16
 3240968:	df000315 	stw	fp,12(sp)
 324096c:	df000304 	addi	fp,sp,12
 3240970:	e13fff15 	stw	r4,-4(fp)
  u_short mf;
  u_short foff;
  IP_FRAGTYPE rc;

  mf = (((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF) >> 13);
 3240974:	e0bfff17 	ldw	r2,-4(fp)
 3240978:	1080018b 	ldhu	r2,6(r2)
 324097c:	10bfffcc 	andi	r2,r2,65535
 3240980:	1004d23a 	srli	r2,r2,8
 3240984:	10bfffcc 	andi	r2,r2,65535
 3240988:	10c03fcc 	andi	r3,r2,255
 324098c:	e0bfff17 	ldw	r2,-4(fp)
 3240990:	1080018b 	ldhu	r2,6(r2)
 3240994:	10bfffcc 	andi	r2,r2,65535
 3240998:	1004923a 	slli	r2,r2,8
 324099c:	10bfc00c 	andi	r2,r2,65280
 32409a0:	1884b03a 	or	r2,r3,r2
 32409a4:	1088000c 	andi	r2,r2,8192
 32409a8:	1005d37a 	srai	r2,r2,13
 32409ac:	e0bffe8d 	sth	r2,-6(fp)
  foff = ((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF);
 32409b0:	e0bfff17 	ldw	r2,-4(fp)
 32409b4:	1080018b 	ldhu	r2,6(r2)
 32409b8:	10bfffcc 	andi	r2,r2,65535
 32409bc:	1004d23a 	srli	r2,r2,8
 32409c0:	10803fcc 	andi	r2,r2,255
 32409c4:	1009883a 	mov	r4,r2
 32409c8:	e0bfff17 	ldw	r2,-4(fp)
 32409cc:	1080018b 	ldhu	r2,6(r2)
 32409d0:	10bfffcc 	andi	r2,r2,65535
 32409d4:	1004923a 	slli	r2,r2,8
 32409d8:	1007883a 	mov	r3,r2
 32409dc:	00bfc004 	movi	r2,-256
 32409e0:	1884703a 	and	r2,r3,r2
 32409e4:	2084b03a 	or	r2,r4,r2
 32409e8:	1087ffcc 	andi	r2,r2,8191
 32409ec:	e0bffe0d 	sth	r2,-8(fp)

  if (mf == 0)
 32409f0:	e0bffe8b 	ldhu	r2,-6(fp)
 32409f4:	1004c03a 	cmpne	r2,r2,zero
 32409f8:	1000081e 	bne	r2,zero,3240a1c <ip_reasm_determine_type_of_frag+0xb8>
     {
     if (foff == 0) {rc = IP_CP;}
 32409fc:	e0bffe0b 	ldhu	r2,-8(fp)
 3240a00:	1004c03a 	cmpne	r2,r2,zero
 3240a04:	1000021e 	bne	r2,zero,3240a10 <ip_reasm_determine_type_of_frag+0xac>
 3240a08:	e03ffd15 	stw	zero,-12(fp)
 3240a0c:	00000b06 	br	3240a3c <ip_reasm_determine_type_of_frag+0xd8>
     else {rc = IP_LF;}
 3240a10:	00800144 	movi	r2,5
 3240a14:	e0bffd15 	stw	r2,-12(fp)
 3240a18:	00000806 	br	3240a3c <ip_reasm_determine_type_of_frag+0xd8>
     }
  else
     {
     if (foff == 0) {rc = IP_FF;}
 3240a1c:	e0bffe0b 	ldhu	r2,-8(fp)
 3240a20:	1004c03a 	cmpne	r2,r2,zero
 3240a24:	1000031e 	bne	r2,zero,3240a34 <ip_reasm_determine_type_of_frag+0xd0>
 3240a28:	00800044 	movi	r2,1
 3240a2c:	e0bffd15 	stw	r2,-12(fp)
 3240a30:	00000206 	br	3240a3c <ip_reasm_determine_type_of_frag+0xd8>
     else {rc = IP_MF;}
 3240a34:	008000c4 	movi	r2,3
 3240a38:	e0bffd15 	stw	r2,-12(fp)
     }

  return rc;
 3240a3c:	e0bffd17 	ldw	r2,-12(fp)
}
 3240a40:	e037883a 	mov	sp,fp
 3240a44:	df000017 	ldw	fp,0(sp)
 3240a48:	dec00104 	addi	sp,sp,4
 3240a4c:	f800283a 	ret

03240a50 <ip_reasm_check_mem_useage>:
OUTPUT: ENP_RESOURCE, if the increment request can't be allowed; 
otherwise it returns IPREASM_OK.
*/

int ip_reasm_check_mem_useage (u_short increment)
{
 3240a50:	defffd04 	addi	sp,sp,-12
 3240a54:	df000215 	stw	fp,8(sp)
 3240a58:	df000204 	addi	fp,sp,8
 3240a5c:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity check */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 3240a60:	d0e8fe17 	ldw	r3,-23560(gp)
 3240a64:	008001b4 	movhi	r2,6
 3240a68:	10c0072e 	bgeu	r2,r3,3240a88 <ip_reasm_check_mem_useage+0x38>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 3240a6c:	0080c9b4 	movhi	r2,806
 3240a70:	10b47404 	addi	r2,r2,-11824
 3240a74:	10800217 	ldw	r2,8(r2)
 3240a78:	10c00044 	addi	r3,r2,1
 3240a7c:	0080c9b4 	movhi	r2,806
 3240a80:	10b47404 	addi	r2,r2,-11824
 3240a84:	10c00215 	stw	r3,8(r2)
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 3240a88:	d0e8fe17 	ldw	r3,-23560(gp)
 3240a8c:	008001b4 	movhi	r2,6
 3240a90:	18800526 	beq	r3,r2,3240aa8 <ip_reasm_check_mem_useage+0x58>
 3240a94:	e0fffe0b 	ldhu	r3,-8(fp)
 3240a98:	d0a8fe17 	ldw	r2,-23560(gp)
 3240a9c:	1887883a 	add	r3,r3,r2
 3240aa0:	008001b4 	movhi	r2,6
 3240aa4:	10c00a2e 	bgeu	r2,r3,3240ad0 <ip_reasm_check_mem_useage+0x80>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
   {
      /* return an error indication */
      ++ire_stats.mem_check_fail;
 3240aa8:	0080c9b4 	movhi	r2,806
 3240aac:	10b47404 	addi	r2,r2,-11824
 3240ab0:	10800317 	ldw	r2,12(r2)
 3240ab4:	10c00044 	addi	r3,r2,1
 3240ab8:	0080c9b4 	movhi	r2,806
 3240abc:	10b47404 	addi	r2,r2,-11824
 3240ac0:	10c00315 	stw	r3,12(r2)
      return ENP_RESOURCE;
 3240ac4:	00bffa84 	movi	r2,-22
 3240ac8:	e0bfff15 	stw	r2,-4(fp)
 3240acc:	00000106 	br	3240ad4 <ip_reasm_check_mem_useage+0x84>
   }

   /* memory limits will not be exceeded with this increment */
   return IPREASM_OK;
 3240ad0:	e03fff15 	stw	zero,-4(fp)
 3240ad4:	e0bfff17 	ldw	r2,-4(fp)
}
 3240ad8:	e037883a 	mov	sp,fp
 3240adc:	df000017 	ldw	fp,0(sp)
 3240ae0:	dec00104 	addi	sp,sp,4
 3240ae4:	f800283a 	ret

03240ae8 <ip_reasm_incr_mem_useage>:
system exceeding the maximum limit or if the system has already exceeded 
the prespecified limit for memory useage; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_incr_mem_useage (u_short increment)
{
 3240ae8:	defffd04 	addi	sp,sp,-12
 3240aec:	df000215 	stw	fp,8(sp)
 3240af0:	df000204 	addi	fp,sp,8
 3240af4:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 3240af8:	d0e8fe17 	ldw	r3,-23560(gp)
 3240afc:	008001b4 	movhi	r2,6
 3240b00:	10c00a2e 	bgeu	r2,r3,3240b2c <ip_reasm_incr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 3240b04:	0080c9b4 	movhi	r2,806
 3240b08:	10b47404 	addi	r2,r2,-11824
 3240b0c:	10800217 	ldw	r2,8(r2)
 3240b10:	10c00044 	addi	r3,r2,1
 3240b14:	0080c9b4 	movhi	r2,806
 3240b18:	10b47404 	addi	r2,r2,-11824
 3240b1c:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 3240b20:	00bffa84 	movi	r2,-22
 3240b24:	e0bfff15 	stw	r2,-4(fp)
 3240b28:	00001406 	br	3240b7c <ip_reasm_incr_mem_useage+0x94>
   }
   if (ipr_curr_mem + increment > IP_REASM_MAX_MEM)
 3240b2c:	e0fffe0b 	ldhu	r3,-8(fp)
 3240b30:	d0a8fe17 	ldw	r2,-23560(gp)
 3240b34:	1887883a 	add	r3,r3,r2
 3240b38:	008001b4 	movhi	r2,6
 3240b3c:	10c00a2e 	bgeu	r2,r3,3240b68 <ip_reasm_incr_mem_useage+0x80>
   {
      /* this should never happen since caller should have 
       * checked prior to asking for the increment */
      ++ire_stats.mem_incr_fail;
 3240b40:	0080c9b4 	movhi	r2,806
 3240b44:	10b47404 	addi	r2,r2,-11824
 3240b48:	10800417 	ldw	r2,16(r2)
 3240b4c:	10c00044 	addi	r3,r2,1
 3240b50:	0080c9b4 	movhi	r2,806
 3240b54:	10b47404 	addi	r2,r2,-11824
 3240b58:	10c00415 	stw	r3,16(r2)
      return ENP_RESOURCE;
 3240b5c:	00bffa84 	movi	r2,-22
 3240b60:	e0bfff15 	stw	r2,-4(fp)
 3240b64:	00000506 	br	3240b7c <ip_reasm_incr_mem_useage+0x94>
   }

   ipr_curr_mem += increment;
 3240b68:	e0bffe0b 	ldhu	r2,-8(fp)
 3240b6c:	d0e8fe17 	ldw	r3,-23560(gp)
 3240b70:	10c5883a 	add	r2,r2,r3
 3240b74:	d0a8fe15 	stw	r2,-23560(gp)

   /* successfully incremented memory useage counter */
   return IPREASM_OK;
 3240b78:	e03fff15 	stw	zero,-4(fp)
 3240b7c:	e0bfff17 	ldw	r2,-4(fp)
}
 3240b80:	e037883a 	mov	sp,fp
 3240b84:	df000017 	ldw	fp,0(sp)
 3240b88:	dec00104 	addi	sp,sp,4
 3240b8c:	f800283a 	ret

03240b90 <ip_reasm_decr_mem_useage>:
exceeded the prespecified limit for memory useage; otherwise, it returns 
IPREASM_OK.
*/

int ip_reasm_decr_mem_useage (u_short decrement)
{
 3240b90:	defffd04 	addi	sp,sp,-12
 3240b94:	df000215 	stw	fp,8(sp)
 3240b98:	df000204 	addi	fp,sp,8
 3240b9c:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 3240ba0:	d0e8fe17 	ldw	r3,-23560(gp)
 3240ba4:	008001b4 	movhi	r2,6
 3240ba8:	10c00a2e 	bgeu	r2,r3,3240bd4 <ip_reasm_decr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 3240bac:	0080c9b4 	movhi	r2,806
 3240bb0:	10b47404 	addi	r2,r2,-11824
 3240bb4:	10800217 	ldw	r2,8(r2)
 3240bb8:	10c00044 	addi	r3,r2,1
 3240bbc:	0080c9b4 	movhi	r2,806
 3240bc0:	10b47404 	addi	r2,r2,-11824
 3240bc4:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 3240bc8:	00bffa84 	movi	r2,-22
 3240bcc:	e0bfff15 	stw	r2,-4(fp)
 3240bd0:	00001206 	br	3240c1c <ip_reasm_decr_mem_useage+0x8c>
   }
   if (ipr_curr_mem < decrement)
 3240bd4:	e0fffe0b 	ldhu	r3,-8(fp)
 3240bd8:	d0a8fe17 	ldw	r2,-23560(gp)
 3240bdc:	10c00a2e 	bgeu	r2,r3,3240c08 <ip_reasm_decr_mem_useage+0x78>
   {
      /* this should never happen since the current memory useage
       * counter must always be greater than or at least equal to
       * the allocation that is being "returned" */
      ++ire_stats.mem_decr_fail;
 3240be0:	0080c9b4 	movhi	r2,806
 3240be4:	10b47404 	addi	r2,r2,-11824
 3240be8:	10800517 	ldw	r2,20(r2)
 3240bec:	10c00044 	addi	r3,r2,1
 3240bf0:	0080c9b4 	movhi	r2,806
 3240bf4:	10b47404 	addi	r2,r2,-11824
 3240bf8:	10c00515 	stw	r3,20(r2)
      return ENP_RESOURCE;
 3240bfc:	00bffa84 	movi	r2,-22
 3240c00:	e0bfff15 	stw	r2,-4(fp)
 3240c04:	00000506 	br	3240c1c <ip_reasm_decr_mem_useage+0x8c>
   }

   ipr_curr_mem -= decrement;
 3240c08:	d0a8fe17 	ldw	r2,-23560(gp)
 3240c0c:	e0fffe0b 	ldhu	r3,-8(fp)
 3240c10:	10c5c83a 	sub	r2,r2,r3
 3240c14:	d0a8fe15 	stw	r2,-23560(gp)

   /* successfully decremented memory useage counter */
   return IPREASM_OK;
 3240c18:	e03fff15 	stw	zero,-4(fp)
 3240c1c:	e0bfff17 	ldw	r2,-4(fp)
}
 3240c20:	e037883a 	mov	sp,fp
 3240c24:	df000017 	ldw	fp,0(sp)
 3240c28:	dec00104 	addi	sp,sp,4
 3240c2c:	f800283a 	ret

03240c30 <ip_reasm_process_first_fragment>:
OUTPUT: ENP_RESOURCE if the memory check (in ip_reasm_check_mem_useage ()) 
or the allocation for an IRE fails; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_process_first_fragment (PACKET p)
{
 3240c30:	defff604 	addi	sp,sp,-40
 3240c34:	dfc00915 	stw	ra,36(sp)
 3240c38:	df000815 	stw	fp,32(sp)
 3240c3c:	df000804 	addi	fp,sp,32
 3240c40:	e13ffe15 	stw	r4,-8(fp)
   u_short total_len;
   int rc;

   /* this is a fragment from a hitherto unknown fragment stream; 
    * check for resource limits before accepting it */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (IRE)))) != IPREASM_OK)
 3240c44:	e0bffe17 	ldw	r2,-8(fp)
 3240c48:	10800217 	ldw	r2,8(r2)
 3240c4c:	10802204 	addi	r2,r2,136
 3240c50:	113fffcc 	andi	r4,r2,65535
 3240c54:	3240a500 	call	3240a50 <ip_reasm_check_mem_useage>
 3240c58:	e0bff815 	stw	r2,-32(fp)
 3240c5c:	e0bff817 	ldw	r2,-32(fp)
 3240c60:	1005003a 	cmpeq	r2,r2,zero
 3240c64:	1000101e 	bne	r2,zero,3240ca8 <ip_reasm_process_first_fragment+0x78>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 3240c68:	01000084 	movi	r4,2
 3240c6c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free (p);
 3240c70:	e13ffe17 	ldw	r4,-8(fp)
 3240c74:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3240c78:	01000084 	movi	r4,2
 3240c7c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 3240c80:	0080c9b4 	movhi	r2,806
 3240c84:	10b46004 	addi	r2,r2,-11904
 3240c88:	10800f17 	ldw	r2,60(r2)
 3240c8c:	10c00044 	addi	r3,r2,1
 3240c90:	0080c9b4 	movhi	r2,806
 3240c94:	10b46004 	addi	r2,r2,-11904
 3240c98:	10c00f15 	stw	r3,60(r2)
      return rc;
 3240c9c:	e0bff817 	ldw	r2,-32(fp)
 3240ca0:	e0bfff15 	stw	r2,-4(fp)
 3240ca4:	00009406 	br	3240ef8 <ip_reasm_process_first_fragment+0x2c8>
   }

   /* we are ok wrt memory limits; since this is the first fragment, we need 
    * to create an IRE entry */
   irep = (IREP) IPR_ALLOC(sizeof(IRE));
 3240ca8:	01002204 	movi	r4,136
 3240cac:	322b5d00 	call	322b5d0 <npalloc>
 3240cb0:	e0bffc15 	stw	r2,-16(fp)
   if (irep == 0) 
 3240cb4:	e0bffc17 	ldw	r2,-16(fp)
 3240cb8:	1004c03a 	cmpne	r2,r2,zero
 3240cbc:	1000101e 	bne	r2,zero,3240d00 <ip_reasm_process_first_fragment+0xd0>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 3240cc0:	01000084 	movi	r4,2
 3240cc4:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free (p);
 3240cc8:	e13ffe17 	ldw	r4,-8(fp)
 3240ccc:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3240cd0:	01000084 	movi	r4,2
 3240cd4:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 3240cd8:	0080c9b4 	movhi	r2,806
 3240cdc:	10b46004 	addi	r2,r2,-11904
 3240ce0:	10800f17 	ldw	r2,60(r2)
 3240ce4:	10c00044 	addi	r3,r2,1
 3240ce8:	0080c9b4 	movhi	r2,806
 3240cec:	10b46004 	addi	r2,r2,-11904
 3240cf0:	10c00f15 	stw	r3,60(r2)
      return ENP_RESOURCE;
 3240cf4:	00bffa84 	movi	r2,-22
 3240cf8:	e0bfff15 	stw	r2,-4(fp)
 3240cfc:	00007e06 	br	3240ef8 <ip_reasm_process_first_fragment+0x2c8>
   }

   pip = ip_head(p);
 3240d00:	e0bffe17 	ldw	r2,-8(fp)
 3240d04:	10800317 	ldw	r2,12(r2)
 3240d08:	e0bffd15 	stw	r2,-12(fp)
   iphlen = ip_hlen(pip);
 3240d0c:	e0bffd17 	ldw	r2,-12(fp)
 3240d10:	10800003 	ldbu	r2,0(r2)
 3240d14:	108003cc 	andi	r2,r2,15
 3240d18:	1085883a 	add	r2,r2,r2
 3240d1c:	1085883a 	add	r2,r2,r2
 3240d20:	e0bffa05 	stb	r2,-24(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 3240d24:	e13ffd17 	ldw	r4,-12(fp)
 3240d28:	32409640 	call	3240964 <ip_reasm_determine_type_of_frag>
 3240d2c:	e0bffb15 	stw	r2,-20(fp)
   frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 3240d30:	e0bffd17 	ldw	r2,-12(fp)
 3240d34:	1080018b 	ldhu	r2,6(r2)
 3240d38:	10bfffcc 	andi	r2,r2,65535
 3240d3c:	1004d23a 	srli	r2,r2,8
 3240d40:	10803fcc 	andi	r2,r2,255
 3240d44:	1009883a 	mov	r4,r2
 3240d48:	e0bffd17 	ldw	r2,-12(fp)
 3240d4c:	1080018b 	ldhu	r2,6(r2)
 3240d50:	10bfffcc 	andi	r2,r2,65535
 3240d54:	1004923a 	slli	r2,r2,8
 3240d58:	1007883a 	mov	r3,r2
 3240d5c:	00bfc004 	movi	r2,-256
 3240d60:	1884703a 	and	r2,r3,r2
 3240d64:	2084b03a 	or	r2,r4,r2
 3240d68:	1087ffcc 	andi	r2,r2,8191
 3240d6c:	100490fa 	slli	r2,r2,3
 3240d70:	e0bff98d 	sth	r2,-26(fp)
   total_len = ntohs(pip->ip_len);
 3240d74:	e0bffd17 	ldw	r2,-12(fp)
 3240d78:	1080008b 	ldhu	r2,2(r2)
 3240d7c:	10bfffcc 	andi	r2,r2,65535
 3240d80:	1004d23a 	srli	r2,r2,8
 3240d84:	10803fcc 	andi	r2,r2,255
 3240d88:	1009883a 	mov	r4,r2
 3240d8c:	e0bffd17 	ldw	r2,-12(fp)
 3240d90:	1080008b 	ldhu	r2,2(r2)
 3240d94:	10bfffcc 	andi	r2,r2,65535
 3240d98:	1004923a 	slli	r2,r2,8
 3240d9c:	1007883a 	mov	r3,r2
 3240da0:	00bfc004 	movi	r2,-256
 3240da4:	1884703a 	and	r2,r3,r2
 3240da8:	2084b03a 	or	r2,r4,r2
 3240dac:	e0bff90d 	sth	r2,-28(fp)

   /* now setup various fields in the IRE entry (multi-byte fields stored in network 
    * byte order) */
   irep->src = pip->ip_src;
 3240db0:	e0bffd17 	ldw	r2,-12(fp)
 3240db4:	10c00317 	ldw	r3,12(r2)
 3240db8:	e0bffc17 	ldw	r2,-16(fp)
 3240dbc:	10c00115 	stw	r3,4(r2)
   irep->dest = pip->ip_dest;
 3240dc0:	e0bffd17 	ldw	r2,-12(fp)
 3240dc4:	10c00417 	ldw	r3,16(r2)
 3240dc8:	e0bffc17 	ldw	r2,-16(fp)
 3240dcc:	10c00215 	stw	r3,8(r2)
   irep->prot = pip->ip_prot;
 3240dd0:	e0bffd17 	ldw	r2,-12(fp)
 3240dd4:	10c00243 	ldbu	r3,9(r2)
 3240dd8:	e0bffc17 	ldw	r2,-16(fp)
 3240ddc:	10c00385 	stb	r3,14(r2)
   irep->id = pip->ip_id;
 3240de0:	e0bffd17 	ldw	r2,-12(fp)
 3240de4:	10c0010b 	ldhu	r3,4(r2)
 3240de8:	e0bffc17 	ldw	r2,-16(fp)
 3240dec:	10c0030d 	sth	r3,12(r2)
   if (ftype == IP_LF)
 3240df0:	e0bffb17 	ldw	r2,-20(fp)
 3240df4:	10800158 	cmpnei	r2,r2,5
 3240df8:	10000a1e 	bne	r2,zero,3240e24 <ip_reasm_process_first_fragment+0x1f4>
      {
      irep->length = frag_offset + (total_len - iphlen);
 3240dfc:	e0fffa03 	ldbu	r3,-24(fp)
 3240e00:	e0bff90b 	ldhu	r2,-28(fp)
 3240e04:	10c5c83a 	sub	r2,r2,r3
 3240e08:	1007883a 	mov	r3,r2
 3240e0c:	e0bff98b 	ldhu	r2,-26(fp)
 3240e10:	1885883a 	add	r2,r3,r2
 3240e14:	1007883a 	mov	r3,r2
 3240e18:	e0bffc17 	ldw	r2,-16(fp)
 3240e1c:	10c0040d 	sth	r3,16(r2)
 3240e20:	00000a06 	br	3240e4c <ip_reasm_process_first_fragment+0x21c>
      }
   else if (ftype == IP_FF)
 3240e24:	e0bffb17 	ldw	r2,-20(fp)
 3240e28:	10800058 	cmpnei	r2,r2,1
 3240e2c:	1000071e 	bne	r2,zero,3240e4c <ip_reasm_process_first_fragment+0x21c>
       * out, and results in the transmission of an ICMP Time Exceeded message (with the
       * code set to "fragment reassembly time exceeded").  Please note that the 'l2_hdr' 
       * as set below may not be the start address for the L2 header (but it is adequate 
       * for our use).  If the FF is never received, these fields stay at their initial
       * value of 0. */
      irep->l2_hdr = p->nb_buff;
 3240e30:	e0bffe17 	ldw	r2,-8(fp)
 3240e34:	10c00117 	ldw	r3,4(r2)
 3240e38:	e0bffc17 	ldw	r2,-16(fp)
 3240e3c:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 3240e40:	e0fffd17 	ldw	r3,-12(fp)
 3240e44:	e0bffc17 	ldw	r2,-16(fp)
 3240e48:	10c02015 	stw	r3,128(r2)
      }

   /* note that the 'rcvd' and 'length' counters only keep track of the data part of 
    * the IP datagram */
   irep->rcvd = total_len - iphlen;
 3240e4c:	e0fffa03 	ldbu	r3,-24(fp)
 3240e50:	e0bff90b 	ldhu	r2,-28(fp)
 3240e54:	10c5c83a 	sub	r2,r2,r3
 3240e58:	1007883a 	mov	r3,r2
 3240e5c:	e0bffc17 	ldw	r2,-16(fp)
 3240e60:	10c0048d 	sth	r3,18(r2)
   irep->age = 0;
 3240e64:	e0bffc17 	ldw	r2,-16(fp)
 3240e68:	10000515 	stw	zero,20(r2)

   /* all RFQs are compact when created */
   irep->flags |= IPR_RFQ_COMPACT;
 3240e6c:	e0bffc17 	ldw	r2,-16(fp)
 3240e70:	10802103 	ldbu	r2,132(r2)
 3240e74:	10800054 	ori	r2,r2,1
 3240e78:	1007883a 	mov	r3,r2
 3240e7c:	e0bffc17 	ldw	r2,-16(fp)
 3240e80:	10c02105 	stb	r3,132(r2)

   /* store PACKET pointer in the first location of the first RFQ */
   irep->rfq.bufp[0] = p;
 3240e84:	e0fffc17 	ldw	r3,-16(fp)
 3240e88:	e0bffe17 	ldw	r2,-8(fp)
 3240e8c:	18800715 	stw	r2,28(r3)
   irep->rfq.frag_offset[0] = frag_offset;
 3240e90:	e0fffc17 	ldw	r3,-16(fp)
 3240e94:	e0bff98b 	ldhu	r2,-26(fp)
 3240e98:	1880170d 	sth	r2,92(r3)
   /* the next pointer in the RFQ is already 0 */

   p->nb_prot += iphlen;
 3240e9c:	e0bffe17 	ldw	r2,-8(fp)
 3240ea0:	10c00317 	ldw	r3,12(r2)
 3240ea4:	e0bffa03 	ldbu	r2,-24(fp)
 3240ea8:	1887883a 	add	r3,r3,r2
 3240eac:	e0bffe17 	ldw	r2,-8(fp)
 3240eb0:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 3240eb4:	e0bffe17 	ldw	r2,-8(fp)
 3240eb8:	10c00417 	ldw	r3,16(r2)
 3240ebc:	e0bffa03 	ldbu	r2,-24(fp)
 3240ec0:	1887c83a 	sub	r3,r3,r2
 3240ec4:	e0bffe17 	ldw	r2,-8(fp)
 3240ec8:	10c00415 	stw	r3,16(r2)

   /* insert at start of global IRE list */
   irep->next = h_ireq;
 3240ecc:	d0e8ff17 	ldw	r3,-23556(gp)
 3240ed0:	e0bffc17 	ldw	r2,-16(fp)
 3240ed4:	10c00015 	stw	r3,0(r2)
   h_ireq = irep;
 3240ed8:	e0bffc17 	ldw	r2,-16(fp)
 3240edc:	d0a8ff15 	stw	r2,-23556(gp)

   /* increment the memory useage */
   ip_reasm_incr_mem_useage (p->nb_blen + (sizeof (IRE)));
 3240ee0:	e0bffe17 	ldw	r2,-8(fp)
 3240ee4:	10800217 	ldw	r2,8(r2)
 3240ee8:	10802204 	addi	r2,r2,136
 3240eec:	113fffcc 	andi	r4,r2,65535
 3240ef0:	3240ae80 	call	3240ae8 <ip_reasm_incr_mem_useage>

   return IPREASM_OK;
 3240ef4:	e03fff15 	stw	zero,-4(fp)
 3240ef8:	e0bfff17 	ldw	r2,-4(fp)
}
 3240efc:	e037883a 	mov	sp,fp
 3240f00:	dfc00117 	ldw	ra,4(sp)
 3240f04:	df000017 	ldw	fp,0(sp)
 3240f08:	dec00204 	addi	sp,sp,8
 3240f0c:	f800283a 	ret

03240f10 <ip_reassm>:
merely passes their return code back to its caller.  Otherwise, it returns
IPREASM_OK indicating that the fragment was successfully processed.
*/

int ip_reassm (PACKET p)
{
 3240f10:	defff804 	addi	sp,sp,-32
 3240f14:	dfc00715 	stw	ra,28(sp)
 3240f18:	df000615 	stw	fp,24(sp)
 3240f1c:	df000604 	addi	fp,sp,24
 3240f20:	e13ffe15 	stw	r4,-8(fp)
   IREP irep;
   struct ip * pip;
   int rc1, rc2;

   pip = ip_head(p);
 3240f24:	e0bffe17 	ldw	r2,-8(fp)
 3240f28:	10800317 	ldw	r2,12(r2)
 3240f2c:	e0bffc15 	stw	r2,-16(fp)

   /* we have just received a fragment, so let's start processing it.  First
    * check for a matching IRE entry. */
   irep = ip_reasm_match_frag_with_ire (pip);
 3240f30:	e13ffc17 	ldw	r4,-16(fp)
 3240f34:	32408940 	call	3240894 <ip_reasm_match_frag_with_ire>
 3240f38:	e0bffd15 	stw	r2,-12(fp)

   if (!irep)
 3240f3c:	e0bffd17 	ldw	r2,-12(fp)
 3240f40:	1004c03a 	cmpne	r2,r2,zero
 3240f44:	1000091e 	bne	r2,zero,3240f6c <ip_reassm+0x5c>
   {
      /* this is the first packet for a "new" fragment stream */
      if ((rc1 = ip_reasm_process_first_fragment (p)) != IPREASM_OK)
 3240f48:	e13ffe17 	ldw	r4,-8(fp)
 3240f4c:	3240c300 	call	3240c30 <ip_reasm_process_first_fragment>
 3240f50:	e0bffb15 	stw	r2,-20(fp)
 3240f54:	e0bffb17 	ldw	r2,-20(fp)
 3240f58:	1005003a 	cmpeq	r2,r2,zero
 3240f5c:	10000d1e 	bne	r2,zero,3240f94 <ip_reassm+0x84>
      {
         /* ip_reasm_process_first_fragment () will free the packet */
         return rc1;
 3240f60:	e0bffb17 	ldw	r2,-20(fp)
 3240f64:	e0bfff15 	stw	r2,-4(fp)
 3240f68:	00000b06 	br	3240f98 <ip_reassm+0x88>
      }
   }
   else
   {
      /* a matching IRE already exists for this fragment */
      if ((rc2 = ip_reasm_process_subsequent_fragments (p, irep)) != IPREASM_OK)
 3240f6c:	e13ffe17 	ldw	r4,-8(fp)
 3240f70:	e17ffd17 	ldw	r5,-12(fp)
 3240f74:	32415400 	call	3241540 <ip_reasm_process_subsequent_fragments>
 3240f78:	e0bffa15 	stw	r2,-24(fp)
 3240f7c:	e0bffa17 	ldw	r2,-24(fp)
 3240f80:	1005003a 	cmpeq	r2,r2,zero
 3240f84:	1000031e 	bne	r2,zero,3240f94 <ip_reassm+0x84>
      {
         /* ip_reasm_process_subsequent_fragments () has already deleted the IRE entry */
         return rc2;
 3240f88:	e0bffa17 	ldw	r2,-24(fp)
 3240f8c:	e0bfff15 	stw	r2,-4(fp)
 3240f90:	00000106 	br	3240f98 <ip_reassm+0x88>
      }
   }

   return IPREASM_OK;
 3240f94:	e03fff15 	stw	zero,-4(fp)
 3240f98:	e0bfff17 	ldw	r2,-4(fp)
}
 3240f9c:	e037883a 	mov	sp,fp
 3240fa0:	dfc00117 	ldw	ra,4(sp)
 3240fa4:	df000017 	ldw	fp,0(sp)
 3240fa8:	dec00204 	addi	sp,sp,8
 3240fac:	f800283a 	ret

03240fb0 <ip_reasm_compute_overlap>:
            (i.e., contains "unique" data).
*/

IPREASM_RC ip_reasm_compute_overlap (PACKET p, IREP irep, u_short * indexp, 
 RFQP * last_rfqpp, u_short * frag_offsetp, u_char * hole_createdp)
{
 3240fb0:	defff204 	addi	sp,sp,-56
 3240fb4:	dfc00d15 	stw	ra,52(sp)
 3240fb8:	df000c15 	stw	fp,48(sp)
 3240fbc:	df000c04 	addi	fp,sp,48
 3240fc0:	e13ffb15 	stw	r4,-20(fp)
 3240fc4:	e17ffc15 	stw	r5,-16(fp)
 3240fc8:	e1bffd15 	stw	r6,-12(fp)
 3240fcc:	e1fffe15 	stw	r7,-8(fp)
   u_short currend;
   u_short drop_len;
   u_char iphlen;
   u_short i;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 3240fd0:	e13ffc17 	ldw	r4,-16(fp)
 3240fd4:	3241ad40 	call	3241ad4 <ip_reasm_find_ire>
 3240fd8:	10803fcc 	andi	r2,r2,255
 3240fdc:	10800060 	cmpeqi	r2,r2,1
 3240fe0:	1000101e 	bne	r2,zero,3241024 <ip_reasm_compute_overlap+0x74>
      {
      ++ire_stats.bad_irep;
 3240fe4:	0080c9b4 	movhi	r2,806
 3240fe8:	10b47404 	addi	r2,r2,-11824
 3240fec:	10800017 	ldw	r2,0(r2)
 3240ff0:	10c00044 	addi	r3,r2,1
 3240ff4:	0080c9b4 	movhi	r2,806
 3240ff8:	10b47404 	addi	r2,r2,-11824
 3240ffc:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 3241000:	01000084 	movi	r4,2
 3241004:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free (p);
 3241008:	e13ffb17 	ldw	r4,-20(fp)
 324100c:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241010:	01000084 	movi	r4,2
 3241014:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return IPREASM_DROP_FRAG_BAD_PARAM;
 3241018:	00800044 	movi	r2,1
 324101c:	e0bfff15 	stw	r2,-4(fp)
 3241020:	00014106 	br	3241528 <ip_reasm_compute_overlap+0x578>
      }

   jrip = ip_head(p);
 3241024:	e0bffb17 	ldw	r2,-20(fp)
 3241028:	10800317 	ldw	r2,12(r2)
 324102c:	e0bff815 	stw	r2,-32(fp)
   iphlen = ip_hlen (jrip);
 3241030:	e0bff817 	ldw	r2,-32(fp)
 3241034:	10800003 	ldbu	r2,0(r2)
 3241038:	108003cc 	andi	r2,r2,15
 324103c:	1085883a 	add	r2,r2,r2
 3241040:	1085883a 	add	r2,r2,r2
 3241044:	e0bff485 	stb	r2,-46(fp)
   jrstart = (((ntohs(jrip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 3241048:	e0bff817 	ldw	r2,-32(fp)
 324104c:	1080018b 	ldhu	r2,6(r2)
 3241050:	10bfffcc 	andi	r2,r2,65535
 3241054:	1004d23a 	srli	r2,r2,8
 3241058:	10803fcc 	andi	r2,r2,255
 324105c:	1009883a 	mov	r4,r2
 3241060:	e0bff817 	ldw	r2,-32(fp)
 3241064:	1080018b 	ldhu	r2,6(r2)
 3241068:	10bfffcc 	andi	r2,r2,65535
 324106c:	1004923a 	slli	r2,r2,8
 3241070:	1007883a 	mov	r3,r2
 3241074:	00bfc004 	movi	r2,-256
 3241078:	1884703a 	and	r2,r3,r2
 324107c:	2084b03a 	or	r2,r4,r2
 3241080:	1087ffcc 	andi	r2,r2,8191
 3241084:	100490fa 	slli	r2,r2,3
 3241088:	e0bff70d 	sth	r2,-36(fp)
   jrend =   jrstart + ((ntohs(jrip->ip_len)) - iphlen) - 1;
 324108c:	e0bff817 	ldw	r2,-32(fp)
 3241090:	1080008b 	ldhu	r2,2(r2)
 3241094:	10bfffcc 	andi	r2,r2,65535
 3241098:	1004d23a 	srli	r2,r2,8
 324109c:	10803fcc 	andi	r2,r2,255
 32410a0:	1009883a 	mov	r4,r2
 32410a4:	e0bff817 	ldw	r2,-32(fp)
 32410a8:	1080008b 	ldhu	r2,2(r2)
 32410ac:	10bfffcc 	andi	r2,r2,65535
 32410b0:	1004923a 	slli	r2,r2,8
 32410b4:	1007883a 	mov	r3,r2
 32410b8:	00bfc004 	movi	r2,-256
 32410bc:	1884703a 	and	r2,r3,r2
 32410c0:	2084b03a 	or	r2,r4,r2
 32410c4:	1007883a 	mov	r3,r2
 32410c8:	e0bff483 	ldbu	r2,-46(fp)
 32410cc:	1885c83a 	sub	r2,r3,r2
 32410d0:	1007883a 	mov	r3,r2
 32410d4:	e0bff70b 	ldhu	r2,-36(fp)
 32410d8:	1885883a 	add	r2,r3,r2
 32410dc:	10bfffc4 	addi	r2,r2,-1
 32410e0:	e0bff68d 	sth	r2,-38(fp)
   /* skip past the IP header of the just received fragment as we get ready 
    * to compare for overlap between the just received fragment and the 
    * fragments that are currently queued in the IRE entry for this fragment 
    * chain */
   p->nb_prot += iphlen;
 32410e4:	e0bffb17 	ldw	r2,-20(fp)
 32410e8:	10c00317 	ldw	r3,12(r2)
 32410ec:	e0bff483 	ldbu	r2,-46(fp)
 32410f0:	1887883a 	add	r3,r3,r2
 32410f4:	e0bffb17 	ldw	r2,-20(fp)
 32410f8:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 32410fc:	e0bffb17 	ldw	r2,-20(fp)
 3241100:	10c00417 	ldw	r3,16(r2)
 3241104:	e0bff483 	ldbu	r2,-46(fp)
 3241108:	1887c83a 	sub	r3,r3,r2
 324110c:	e0bffb17 	ldw	r2,-20(fp)
 3241110:	10c00415 	stw	r3,16(r2)

   *frag_offsetp = jrstart;
 3241114:	e0c00217 	ldw	r3,8(fp)
 3241118:	e0bff70b 	ldhu	r2,-36(fp)
 324111c:	1880000d 	sth	r2,0(r3)
   *indexp = INVALID_FRAG_INDEX;
 3241120:	e0fffd17 	ldw	r3,-12(fp)
 3241124:	00800404 	movi	r2,16
 3241128:	1880000d 	sth	r2,0(r3)
   *last_rfqpp = 0;
 324112c:	e0bffe17 	ldw	r2,-8(fp)
 3241130:	10000015 	stw	zero,0(r2)
   *hole_createdp = IPREASM_FALSE;
 3241134:	e0800317 	ldw	r2,12(fp)
 3241138:	10000005 	stb	zero,0(r2)

   rfqp = &(irep->rfq);
 324113c:	e0bffc17 	ldw	r2,-16(fp)
 3241140:	10800604 	addi	r2,r2,24
 3241144:	e0bffa15 	stw	r2,-24(fp)

   while (rfqp)
 3241148:	0000ef06 	br	3241508 <ip_reasm_compute_overlap+0x558>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 324114c:	e03ff40d 	sth	zero,-48(fp)
 3241150:	0000df06 	br	32414d0 <ip_reasm_compute_overlap+0x520>
         {
         if ((currpkt = rfqp->bufp[i]) != 0)
 3241154:	e0bff40b 	ldhu	r2,-48(fp)
 3241158:	e0fffa17 	ldw	r3,-24(fp)
 324115c:	1085883a 	add	r2,r2,r2
 3241160:	1085883a 	add	r2,r2,r2
 3241164:	10c5883a 	add	r2,r2,r3
 3241168:	10800104 	addi	r2,r2,4
 324116c:	10800017 	ldw	r2,0(r2)
 3241170:	e0bff915 	stw	r2,-28(fp)
 3241174:	e0bff917 	ldw	r2,-28(fp)
 3241178:	1005003a 	cmpeq	r2,r2,zero
 324117c:	1000bf1e 	bne	r2,zero,324147c <ip_reasm_compute_overlap+0x4cc>
            {
            currstart = rfqp->frag_offset[i];
 3241180:	e0bff40b 	ldhu	r2,-48(fp)
 3241184:	e0fffa17 	ldw	r3,-24(fp)
 3241188:	1085883a 	add	r2,r2,r2
 324118c:	10c5883a 	add	r2,r2,r3
 3241190:	10801104 	addi	r2,r2,68
 3241194:	1080000b 	ldhu	r2,0(r2)
 3241198:	e0bff60d 	sth	r2,-40(fp)
            currend = currstart + currpkt->nb_plen - 1;
 324119c:	e0bff917 	ldw	r2,-28(fp)
 32411a0:	10800417 	ldw	r2,16(r2)
 32411a4:	1007883a 	mov	r3,r2
 32411a8:	e0bff60b 	ldhu	r2,-40(fp)
 32411ac:	1885883a 	add	r2,r3,r2
 32411b0:	10bfffc4 	addi	r2,r2,-1
 32411b4:	e0bff58d 	sth	r2,-42(fp)

            if (currstart < jrstart)
 32411b8:	e0fff60b 	ldhu	r3,-40(fp)
 32411bc:	e0bff70b 	ldhu	r2,-36(fp)
 32411c0:	18802b2e 	bgeu	r3,r2,3241270 <ip_reasm_compute_overlap+0x2c0>
               {
               if (currend < jrend) /* cases A1 and A2 */
 32411c4:	e0fff58b 	ldhu	r3,-42(fp)
 32411c8:	e0bff68b 	ldhu	r2,-38(fp)
 32411cc:	1880202e 	bgeu	r3,r2,3241250 <ip_reasm_compute_overlap+0x2a0>
                  {
                  if (currend < jrstart) /* A1 */
 32411d0:	e0fff58b 	ldhu	r3,-42(fp)
 32411d4:	e0bff70b 	ldhu	r2,-36(fp)
 32411d8:	1880ba36 	bltu	r3,r2,32414c4 <ip_reasm_compute_overlap+0x514>
                     {
                     /* the just received fragment partially overlaps current 
                      * fragment on the latter's right; increment start 
                      * pointer and decrement length of just received fragment.
                      * Move on to the next fragment in the RFQ. */
                     drop_len = (currend - jrstart) + 1;
 32411dc:	e0fff58b 	ldhu	r3,-42(fp)
 32411e0:	e0bff70b 	ldhu	r2,-36(fp)
 32411e4:	1885c83a 	sub	r2,r3,r2
 32411e8:	10800044 	addi	r2,r2,1
 32411ec:	e0bff50d 	sth	r2,-44(fp)
                     p->nb_prot += drop_len;
 32411f0:	e0bffb17 	ldw	r2,-20(fp)
 32411f4:	10c00317 	ldw	r3,12(r2)
 32411f8:	e0bff50b 	ldhu	r2,-44(fp)
 32411fc:	1887883a 	add	r3,r3,r2
 3241200:	e0bffb17 	ldw	r2,-20(fp)
 3241204:	10c00315 	stw	r3,12(r2)
                     p->nb_plen -= drop_len;
 3241208:	e0bffb17 	ldw	r2,-20(fp)
 324120c:	10c00417 	ldw	r3,16(r2)
 3241210:	e0bff50b 	ldhu	r2,-44(fp)
 3241214:	1887c83a 	sub	r3,r3,r2
 3241218:	e0bffb17 	ldw	r2,-20(fp)
 324121c:	10c00415 	stw	r3,16(r2)
                     jrstart += drop_len;
 3241220:	e0fff70b 	ldhu	r3,-36(fp)
 3241224:	e0bff50b 	ldhu	r2,-44(fp)
 3241228:	1885883a 	add	r2,r3,r2
 324122c:	e0bff70d 	sth	r2,-36(fp)
                     jrend = jrstart + p->nb_plen - 1;
 3241230:	e0bffb17 	ldw	r2,-20(fp)
 3241234:	10800417 	ldw	r2,16(r2)
 3241238:	1007883a 	mov	r3,r2
 324123c:	e0bff70b 	ldhu	r2,-36(fp)
 3241240:	1885883a 	add	r2,r3,r2
 3241244:	10bfffc4 	addi	r2,r2,-1
 3241248:	e0bff68d 	sth	r2,-38(fp)
 324124c:	00009d06 	br	32414c4 <ip_reasm_compute_overlap+0x514>
               else
                  {
                  /* currend is greater than or equal to jrend (cases E1 and E2).
                   * The current fragment is a superset of the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 3241250:	01000084 	movi	r4,2
 3241254:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
                  pk_free (p);
 3241258:	e13ffb17 	ldw	r4,-20(fp)
 324125c:	322a2dc0 	call	322a2dc <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241260:	01000084 	movi	r4,2
 3241264:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 3241268:	e03fff15 	stw	zero,-4(fp)
 324126c:	0000ae06 	br	3241528 <ip_reasm_compute_overlap+0x578>
                  }
               }
            else if (currstart > jrstart)
 3241270:	e0fff60b 	ldhu	r3,-40(fp)
 3241274:	e0bff70b 	ldhu	r2,-36(fp)
 3241278:	10c04d2e 	bgeu	r2,r3,32413b0 <ip_reasm_compute_overlap+0x400>
               {
               if (currend > jrend) /* cases B1 and B2 */
 324127c:	e0fff58b 	ldhu	r3,-42(fp)
 3241280:	e0bff68b 	ldhu	r2,-38(fp)
 3241284:	10c0112e 	bgeu	r2,r3,32412cc <ip_reasm_compute_overlap+0x31c>
                  {
                  if (currstart > jrend) /* B1 */
 3241288:	e0fff60b 	ldhu	r3,-40(fp)
 324128c:	e0bff68b 	ldhu	r2,-38(fp)
 3241290:	10c08c36 	bltu	r2,r3,32414c4 <ip_reasm_compute_overlap+0x514>
                     {
                     /* just received fragment partially overlaps current 
                      * fragment on the latter's left; decrement length of 
                      * just received fragment.  Move on to the next fragment 
                      * in the RFQ. */
                     p->nb_plen = currstart - jrstart;
 3241294:	e0fff60b 	ldhu	r3,-40(fp)
 3241298:	e0bff70b 	ldhu	r2,-36(fp)
 324129c:	1885c83a 	sub	r2,r3,r2
 32412a0:	1007883a 	mov	r3,r2
 32412a4:	e0bffb17 	ldw	r2,-20(fp)
 32412a8:	10c00415 	stw	r3,16(r2)
                     /* start offset remains unchanged, but jrend must be updated */
                     jrend = jrstart + p->nb_plen - 1;
 32412ac:	e0bffb17 	ldw	r2,-20(fp)
 32412b0:	10800417 	ldw	r2,16(r2)
 32412b4:	1007883a 	mov	r3,r2
 32412b8:	e0bff70b 	ldhu	r2,-36(fp)
 32412bc:	1885883a 	add	r2,r3,r2
 32412c0:	10bfffc4 	addi	r2,r2,-1
 32412c4:	e0bff68d 	sth	r2,-38(fp)
 32412c8:	00007e06 	br	32414c4 <ip_reasm_compute_overlap+0x514>
                     }
                  }
               else if (currend == jrend) /* F1 */
 32412cc:	e0fff58b 	ldhu	r3,-42(fp)
 32412d0:	e0bff68b 	ldhu	r2,-38(fp)
 32412d4:	18800e1e 	bne	r3,r2,3241310 <ip_reasm_compute_overlap+0x360>
                  {
                  /* current fragment is a subset of the just received fragment.  
                   * Decrement the length of the just received fragment.  Move
                   * on to the next fragment in the RFQ. */
                  p->nb_plen = currstart - jrstart;
 32412d8:	e0fff60b 	ldhu	r3,-40(fp)
 32412dc:	e0bff70b 	ldhu	r2,-36(fp)
 32412e0:	1885c83a 	sub	r2,r3,r2
 32412e4:	1007883a 	mov	r3,r2
 32412e8:	e0bffb17 	ldw	r2,-20(fp)
 32412ec:	10c00415 	stw	r3,16(r2)
                  jrend = jrstart + p->nb_plen - 1;
 32412f0:	e0bffb17 	ldw	r2,-20(fp)
 32412f4:	10800417 	ldw	r2,16(r2)
 32412f8:	1007883a 	mov	r3,r2
 32412fc:	e0bff70b 	ldhu	r2,-36(fp)
 3241300:	1885883a 	add	r2,r3,r2
 3241304:	10bfffc4 	addi	r2,r2,-1
 3241308:	e0bff68d 	sth	r2,-38(fp)
 324130c:	00006d06 	br	32414c4 <ip_reasm_compute_overlap+0x514>
                  {
                  /* currend is less than jrend (case F2).  current fragment is 
                   * a subset of the just received fragment.  Drop current
                   * fragment.  Move on to the next fragment in the RFQ.  Decrement
                   * the amount of memory currently in use. */
                  ip_reasm_decr_mem_useage (currpkt->nb_blen);
 3241310:	e0bff917 	ldw	r2,-28(fp)
 3241314:	10800217 	ldw	r2,8(r2)
 3241318:	113fffcc 	andi	r4,r2,65535
 324131c:	3240b900 	call	3240b90 <ip_reasm_decr_mem_useage>
                  irep->rcvd -= currpkt->nb_plen;
 3241320:	e0bffc17 	ldw	r2,-16(fp)
 3241324:	10c0048b 	ldhu	r3,18(r2)
 3241328:	e0bff917 	ldw	r2,-28(fp)
 324132c:	10800417 	ldw	r2,16(r2)
 3241330:	1885c83a 	sub	r2,r3,r2
 3241334:	1007883a 	mov	r3,r2
 3241338:	e0bffc17 	ldw	r2,-16(fp)
 324133c:	10c0048d 	sth	r3,18(r2)
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 3241340:	01000084 	movi	r4,2
 3241344:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
                  pk_free (currpkt);
 3241348:	e13ff917 	ldw	r4,-28(fp)
 324134c:	322a2dc0 	call	322a2dc <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241350:	01000084 	movi	r4,2
 3241354:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
                  rfqp->bufp[i] = 0; /* mark slot as unused */
 3241358:	e0bff40b 	ldhu	r2,-48(fp)
 324135c:	e0fffa17 	ldw	r3,-24(fp)
 3241360:	1085883a 	add	r2,r2,r2
 3241364:	1085883a 	add	r2,r2,r2
 3241368:	10c5883a 	add	r2,r2,r3
 324136c:	10800104 	addi	r2,r2,4
 3241370:	10000015 	stw	zero,0(r2)
                  /* save the location of the empty slot */
                  if ((*indexp) == INVALID_FRAG_INDEX) 
 3241374:	e0bffd17 	ldw	r2,-12(fp)
 3241378:	1080000b 	ldhu	r2,0(r2)
 324137c:	10bfffcc 	andi	r2,r2,65535
 3241380:	10800418 	cmpnei	r2,r2,16
 3241384:	1000061e 	bne	r2,zero,32413a0 <ip_reasm_compute_overlap+0x3f0>
                     {
                     *indexp = i;
 3241388:	e0fffd17 	ldw	r3,-12(fp)
 324138c:	e0bff40b 	ldhu	r2,-48(fp)
 3241390:	1880000d 	sth	r2,0(r3)
                     *last_rfqpp = rfqp;
 3241394:	e0fffe17 	ldw	r3,-8(fp)
 3241398:	e0bffa17 	ldw	r2,-24(fp)
 324139c:	18800015 	stw	r2,0(r3)
                     }
                  /* we've just created a hole; the array may no longer be "compact" */
                  *hole_createdp = IPREASM_TRUE;
 32413a0:	e0c00317 	ldw	r3,12(fp)
 32413a4:	00800044 	movi	r2,1
 32413a8:	18800005 	stb	r2,0(r3)
 32413ac:	00004506 	br	32414c4 <ip_reasm_compute_overlap+0x514>
                  }
               }
            else
               {
               /* currstart and jrstart are equal */
               if (currend == jrend) /* case C */
 32413b0:	e0fff58b 	ldhu	r3,-42(fp)
 32413b4:	e0bff68b 	ldhu	r2,-38(fp)
 32413b8:	1880081e 	bne	r3,r2,32413dc <ip_reasm_compute_overlap+0x42c>
                  {
                  /* the current fragment is identical to the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 32413bc:	01000084 	movi	r4,2
 32413c0:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
                  pk_free (p);
 32413c4:	e13ffb17 	ldw	r4,-20(fp)
 32413c8:	322a2dc0 	call	322a2dc <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 32413cc:	01000084 	movi	r4,2
 32413d0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 32413d4:	e03fff15 	stw	zero,-4(fp)
 32413d8:	00005306 	br	3241528 <ip_reasm_compute_overlap+0x578>
                  }
               else if (currend > jrend) /* case D1 */
 32413dc:	e0fff58b 	ldhu	r3,-42(fp)
 32413e0:	e0bff68b 	ldhu	r2,-38(fp)
 32413e4:	10c0082e 	bgeu	r2,r3,3241408 <ip_reasm_compute_overlap+0x458>
                  {
                  /* current fragment is a superset of just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 32413e8:	01000084 	movi	r4,2
 32413ec:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
                  pk_free (p);
 32413f0:	e13ffb17 	ldw	r4,-20(fp)
 32413f4:	322a2dc0 	call	322a2dc <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 32413f8:	01000084 	movi	r4,2
 32413fc:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 3241400:	e03fff15 	stw	zero,-4(fp)
 3241404:	00004806 	br	3241528 <ip_reasm_compute_overlap+0x578>
                  /* currend is less than jrend (case D2).  current fragment 
                   * is a subset of the just received fragment.  Increment 
                   * the start pointer and decrement the length of the just
                   * received fragment.  Move on to the next fragment in 
                   * the RFQ. */
                  drop_len = (currend - jrstart) + 1;
 3241408:	e0fff58b 	ldhu	r3,-42(fp)
 324140c:	e0bff70b 	ldhu	r2,-36(fp)
 3241410:	1885c83a 	sub	r2,r3,r2
 3241414:	10800044 	addi	r2,r2,1
 3241418:	e0bff50d 	sth	r2,-44(fp)
                  p->nb_prot += drop_len;
 324141c:	e0bffb17 	ldw	r2,-20(fp)
 3241420:	10c00317 	ldw	r3,12(r2)
 3241424:	e0bff50b 	ldhu	r2,-44(fp)
 3241428:	1887883a 	add	r3,r3,r2
 324142c:	e0bffb17 	ldw	r2,-20(fp)
 3241430:	10c00315 	stw	r3,12(r2)
                  p->nb_plen -= drop_len;
 3241434:	e0bffb17 	ldw	r2,-20(fp)
 3241438:	10c00417 	ldw	r3,16(r2)
 324143c:	e0bff50b 	ldhu	r2,-44(fp)
 3241440:	1887c83a 	sub	r3,r3,r2
 3241444:	e0bffb17 	ldw	r2,-20(fp)
 3241448:	10c00415 	stw	r3,16(r2)
                  jrstart += drop_len;
 324144c:	e0fff70b 	ldhu	r3,-36(fp)
 3241450:	e0bff50b 	ldhu	r2,-44(fp)
 3241454:	1885883a 	add	r2,r3,r2
 3241458:	e0bff70d 	sth	r2,-36(fp)
                  jrend = jrstart + p->nb_plen - 1;
 324145c:	e0bffb17 	ldw	r2,-20(fp)
 3241460:	10800417 	ldw	r2,16(r2)
 3241464:	1007883a 	mov	r3,r2
 3241468:	e0bff70b 	ldhu	r2,-36(fp)
 324146c:	1885883a 	add	r2,r3,r2
 3241470:	10bfffc4 	addi	r2,r2,-1
 3241474:	e0bff68d 	sth	r2,-38(fp)
 3241478:	00001206 	br	32414c4 <ip_reasm_compute_overlap+0x514>
                  }
               }
            } /* end if (PACKET buffer exists at this slot) */
         else
            {
            if ((*indexp) == INVALID_FRAG_INDEX)
 324147c:	e0bffd17 	ldw	r2,-12(fp)
 3241480:	1080000b 	ldhu	r2,0(r2)
 3241484:	10bfffcc 	andi	r2,r2,65535
 3241488:	10800418 	cmpnei	r2,r2,16
 324148c:	1000061e 	bne	r2,zero,32414a8 <ip_reasm_compute_overlap+0x4f8>
               {
               *indexp = i;
 3241490:	e0fffd17 	ldw	r3,-12(fp)
 3241494:	e0bff40b 	ldhu	r2,-48(fp)
 3241498:	1880000d 	sth	r2,0(r3)
               *last_rfqpp = rfqp;               
 324149c:	e0fffe17 	ldw	r3,-8(fp)
 32414a0:	e0bffa17 	ldw	r2,-24(fp)
 32414a4:	18800015 	stw	r2,0(r3)
               }
            if (irep->flags & IPR_RFQ_COMPACT)
 32414a8:	e0bffc17 	ldw	r2,-16(fp)
 32414ac:	10802103 	ldbu	r2,132(r2)
 32414b0:	10803fcc 	andi	r2,r2,255
 32414b4:	1080004c 	andi	r2,r2,1
 32414b8:	10803fcc 	andi	r2,r2,255
 32414bc:	1004c03a 	cmpne	r2,r2,zero
 32414c0:	1000061e 	bne	r2,zero,32414dc <ip_reasm_compute_overlap+0x52c>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 32414c4:	e0bff40b 	ldhu	r2,-48(fp)
 32414c8:	10800044 	addi	r2,r2,1
 32414cc:	e0bff40d 	sth	r2,-48(fp)
 32414d0:	e0bff40b 	ldhu	r2,-48(fp)
 32414d4:	10800430 	cmpltui	r2,r2,16
 32414d8:	103f1e1e 	bne	r2,zero,3241154 <ip_reasm_compute_overlap+0x1a4>
               }
            }
         } /* end FOR (0...(IPR_MAX_FRAGS - 1)) */

      /* skip saving RFQ pointer if we've already found an empty slot */
      if ((*indexp) == INVALID_FRAG_INDEX) 
 32414dc:	e0bffd17 	ldw	r2,-12(fp)
 32414e0:	1080000b 	ldhu	r2,0(r2)
 32414e4:	10bfffcc 	andi	r2,r2,65535
 32414e8:	10800418 	cmpnei	r2,r2,16
 32414ec:	1000031e 	bne	r2,zero,32414fc <ip_reasm_compute_overlap+0x54c>
         {
         *last_rfqpp = rfqp;
 32414f0:	e0fffe17 	ldw	r3,-8(fp)
 32414f4:	e0bffa17 	ldw	r2,-24(fp)
 32414f8:	18800015 	stw	r2,0(r3)
         }
      rfqp = rfqp->next;
 32414fc:	e0bffa17 	ldw	r2,-24(fp)
 3241500:	10800017 	ldw	r2,0(r2)
 3241504:	e0bffa15 	stw	r2,-24(fp)
   *last_rfqpp = 0;
   *hole_createdp = IPREASM_FALSE;

   rfqp = &(irep->rfq);

   while (rfqp)
 3241508:	e0bffa17 	ldw	r2,-24(fp)
 324150c:	1004c03a 	cmpne	r2,r2,zero
 3241510:	103f0e1e 	bne	r2,zero,324114c <ip_reasm_compute_overlap+0x19c>
      } /* end while (rfqp) */

   /* if no empty slots were found, (*last_rfqpp) will contain a pointer 
    * to the last RFQ that we were working with */

   *frag_offsetp = jrstart; /* stored in host byte order */
 3241514:	e0c00217 	ldw	r3,8(fp)
 3241518:	e0bff70b 	ldhu	r2,-36(fp)
 324151c:	1880000d 	sth	r2,0(r3)

   return IPREASM_ACCEPT_FRAG;
 3241520:	00800084 	movi	r2,2
 3241524:	e0bfff15 	stw	r2,-4(fp)
 3241528:	e0bfff17 	ldw	r2,-4(fp)
}
 324152c:	e037883a 	mov	sp,fp
 3241530:	dfc00117 	ldw	ra,4(sp)
 3241534:	df000017 	ldw	fp,0(sp)
 3241538:	dec00204 	addi	sp,sp,8
 324153c:	f800283a 	ret

03241540 <ip_reasm_process_subsequent_fragments>:
            queued fragments (and hence has been dropped), or if the fragment
            has been processed successfully.
*/

int ip_reasm_process_subsequent_fragments (PACKET p, IREP irep)
{
 3241540:	deffed04 	addi	sp,sp,-76
 3241544:	dfc01215 	stw	ra,72(sp)
 3241548:	df001115 	stw	fp,68(sp)
 324154c:	df001104 	addi	fp,sp,68
 3241550:	e13ffa15 	stw	r4,-24(fp)
 3241554:	e17ffb15 	stw	r5,-20(fp)
   PACKET reassy_pkt;
   struct ip * pip;
   RFQP new_rfqp = 0;
 3241558:	e03ff415 	stw	zero,-48(fp)
   u_short index;
   RFQP rfqp;
   u_short frag_offset;
   u_char hole_created;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 324155c:	e13ffb17 	ldw	r4,-20(fp)
 3241560:	3241ad40 	call	3241ad4 <ip_reasm_find_ire>
 3241564:	10803fcc 	andi	r2,r2,255
 3241568:	10800060 	cmpeqi	r2,r2,1
 324156c:	1000171e 	bne	r2,zero,32415cc <ip_reasm_process_subsequent_fragments+0x8c>
      {
      ++ire_stats.bad_irep;
 3241570:	0080c9b4 	movhi	r2,806
 3241574:	10b47404 	addi	r2,r2,-11824
 3241578:	10800017 	ldw	r2,0(r2)
 324157c:	10c00044 	addi	r3,r2,1
 3241580:	0080c9b4 	movhi	r2,806
 3241584:	10b47404 	addi	r2,r2,-11824
 3241588:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 324158c:	01000084 	movi	r4,2
 3241590:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free (p);
 3241594:	e13ffa17 	ldw	r4,-24(fp)
 3241598:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 324159c:	01000084 	movi	r4,2
 32415a0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 32415a4:	0080c9b4 	movhi	r2,806
 32415a8:	10b46004 	addi	r2,r2,-11904
 32415ac:	10800f17 	ldw	r2,60(r2)
 32415b0:	10c00044 	addi	r3,r2,1
 32415b4:	0080c9b4 	movhi	r2,806
 32415b8:	10b46004 	addi	r2,r2,-11904
 32415bc:	10c00f15 	stw	r3,60(r2)
      return ENP_PARAM;
 32415c0:	00bffd84 	movi	r2,-10
 32415c4:	e0bffe15 	stw	r2,-8(fp)
 32415c8:	00013c06 	br	3241abc <ip_reasm_process_subsequent_fragments+0x57c>
      }

   pip = ip_head(p);
 32415cc:	e0bffa17 	ldw	r2,-24(fp)
 32415d0:	10800317 	ldw	r2,12(r2)
 32415d4:	e0bff515 	stw	r2,-44(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 32415d8:	e13ff517 	ldw	r4,-44(fp)
 32415dc:	32409640 	call	3240964 <ip_reasm_determine_type_of_frag>
 32415e0:	e0bff215 	stw	r2,-56(fp)
   /* this fragment is a destined for an already queued fragment stream.
    * we update the 'length' field for LFs here because ip_reasm_compute_overlap ()
    * modifies the received fragment's nb_prot pointer (thereby making its IP header 
    * inaccessible) */
   if (ftype == IP_LF)
 32415e4:	e0bff217 	ldw	r2,-56(fp)
 32415e8:	10800158 	cmpnei	r2,r2,5
 32415ec:	10002c1e 	bne	r2,zero,32416a0 <ip_reasm_process_subsequent_fragments+0x160>
      {
      irep->length = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3) + ((ntohs(pip->ip_len)) - ip_hlen(pip));
 32415f0:	e0bff517 	ldw	r2,-44(fp)
 32415f4:	1080018b 	ldhu	r2,6(r2)
 32415f8:	10bfffcc 	andi	r2,r2,65535
 32415fc:	1004d23a 	srli	r2,r2,8
 3241600:	10803fcc 	andi	r2,r2,255
 3241604:	1009883a 	mov	r4,r2
 3241608:	e0bff517 	ldw	r2,-44(fp)
 324160c:	1080018b 	ldhu	r2,6(r2)
 3241610:	10bfffcc 	andi	r2,r2,65535
 3241614:	1004923a 	slli	r2,r2,8
 3241618:	1007883a 	mov	r3,r2
 324161c:	00bfc004 	movi	r2,-256
 3241620:	1884703a 	and	r2,r3,r2
 3241624:	2084b03a 	or	r2,r4,r2
 3241628:	1087ffcc 	andi	r2,r2,8191
 324162c:	100490fa 	slli	r2,r2,3
 3241630:	100b883a 	mov	r5,r2
 3241634:	e0bff517 	ldw	r2,-44(fp)
 3241638:	1080008b 	ldhu	r2,2(r2)
 324163c:	10bfffcc 	andi	r2,r2,65535
 3241640:	1004d23a 	srli	r2,r2,8
 3241644:	10803fcc 	andi	r2,r2,255
 3241648:	1009883a 	mov	r4,r2
 324164c:	e0bff517 	ldw	r2,-44(fp)
 3241650:	1080008b 	ldhu	r2,2(r2)
 3241654:	10bfffcc 	andi	r2,r2,65535
 3241658:	1004923a 	slli	r2,r2,8
 324165c:	1007883a 	mov	r3,r2
 3241660:	00bfc004 	movi	r2,-256
 3241664:	1884703a 	and	r2,r3,r2
 3241668:	2084b03a 	or	r2,r4,r2
 324166c:	1007883a 	mov	r3,r2
 3241670:	e0bff517 	ldw	r2,-44(fp)
 3241674:	10800003 	ldbu	r2,0(r2)
 3241678:	10803fcc 	andi	r2,r2,255
 324167c:	108003cc 	andi	r2,r2,15
 3241680:	1085883a 	add	r2,r2,r2
 3241684:	1085883a 	add	r2,r2,r2
 3241688:	1885c83a 	sub	r2,r3,r2
 324168c:	2885883a 	add	r2,r5,r2
 3241690:	1007883a 	mov	r3,r2
 3241694:	e0bffb17 	ldw	r2,-20(fp)
 3241698:	10c0040d 	sth	r3,16(r2)
 324169c:	00000a06 	br	32416c8 <ip_reasm_process_subsequent_fragments+0x188>
      }
   else if (ftype == IP_FF)
 32416a0:	e0bff217 	ldw	r2,-56(fp)
 32416a4:	10800058 	cmpnei	r2,r2,1
 32416a8:	1000071e 	bne	r2,zero,32416c8 <ip_reasm_process_subsequent_fragments+0x188>
      {
      irep->l2_hdr = p->nb_buff;
 32416ac:	e0bffa17 	ldw	r2,-24(fp)
 32416b0:	10c00117 	ldw	r3,4(r2)
 32416b4:	e0bffb17 	ldw	r2,-20(fp)
 32416b8:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 32416bc:	e0fff517 	ldw	r3,-44(fp)
 32416c0:	e0bffb17 	ldw	r2,-20(fp)
 32416c4:	10c02015 	stw	r3,128(r2)
      }

   /* Check for overlap, and determine the increase in memory resource 
    * requirements from the newly arrived fragment */
   if ((rc2 = ip_reasm_compute_overlap (p, irep, &index, &rfqp, &frag_offset, &hole_created)) != IPREASM_ACCEPT_FRAG)
 32416c8:	e1bff704 	addi	r6,fp,-36
 32416cc:	e1fff804 	addi	r7,fp,-32
 32416d0:	e0bff904 	addi	r2,fp,-28
 32416d4:	d8800015 	stw	r2,0(sp)
 32416d8:	e0bff984 	addi	r2,fp,-26
 32416dc:	d8800115 	stw	r2,4(sp)
 32416e0:	e13ffa17 	ldw	r4,-24(fp)
 32416e4:	e17ffb17 	ldw	r5,-20(fp)
 32416e8:	3240fb00 	call	3240fb0 <ip_reasm_compute_overlap>
 32416ec:	e0bff115 	stw	r2,-60(fp)
 32416f0:	e0bff117 	ldw	r2,-60(fp)
 32416f4:	108000a0 	cmpeqi	r2,r2,2
 32416f8:	10000e1e 	bne	r2,zero,3241734 <ip_reasm_process_subsequent_fragments+0x1f4>
      {
      switch (rc2)
 32416fc:	e0fff117 	ldw	r3,-60(fp)
 3241700:	e0ffff15 	stw	r3,-4(fp)
 3241704:	e13fff17 	ldw	r4,-4(fp)
 3241708:	2005003a 	cmpeq	r2,r4,zero
 324170c:	1000041e 	bne	r2,zero,3241720 <ip_reasm_process_subsequent_fragments+0x1e0>
 3241710:	e0ffff17 	ldw	r3,-4(fp)
 3241714:	18800060 	cmpeqi	r2,r3,1
 3241718:	1000031e 	bne	r2,zero,3241728 <ip_reasm_process_subsequent_fragments+0x1e8>
 324171c:	00000506 	br	3241734 <ip_reasm_process_subsequent_fragments+0x1f4>
         {
         case IPREASM_DROP_FRAG_DUPLICATE:
            /* this isn't really an error, since it indicates that the received 
             * fragment's information is a duplicate of what is present in the 
             * already queued fragments */
            return IPREASM_OK;
 3241720:	e03ffe15 	stw	zero,-8(fp)
 3241724:	0000e506 	br	3241abc <ip_reasm_process_subsequent_fragments+0x57c>
         case IPREASM_DROP_FRAG_BAD_PARAM:
            /* this is a real error */
            return ENP_PARAM;
 3241728:	013ffd84 	movi	r4,-10
 324172c:	e13ffe15 	stw	r4,-8(fp)
 3241730:	0000e206 	br	3241abc <ip_reasm_process_subsequent_fragments+0x57c>
      }

   /* this is a fragment from an existing fragment stream; 
    * check for resource limits before accepting it.  For now
    * assume that an extra RFQ is not required. */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen)) != IPREASM_OK)
 3241734:	e0bffa17 	ldw	r2,-24(fp)
 3241738:	10800217 	ldw	r2,8(r2)
 324173c:	113fffcc 	andi	r4,r2,65535
 3241740:	3240a500 	call	3240a50 <ip_reasm_check_mem_useage>
 3241744:	e0bff315 	stw	r2,-52(fp)
 3241748:	e0bff317 	ldw	r2,-52(fp)
 324174c:	1005003a 	cmpeq	r2,r2,zero
 3241750:	1000121e 	bne	r2,zero,324179c <ip_reasm_process_subsequent_fragments+0x25c>
      {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 3241754:	01000084 	movi	r4,2
 3241758:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free (p);
 324175c:	e13ffa17 	ldw	r4,-24(fp)
 3241760:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241764:	01000084 	movi	r4,2
 3241768:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      ip_reasm_delete_ire (irep);
 324176c:	e13ffb17 	ldw	r4,-20(fp)
 3241770:	3241f780 	call	3241f78 <ip_reasm_delete_ire>
      ++ip_mib.ipReasmFails;
 3241774:	0080c9b4 	movhi	r2,806
 3241778:	10b46004 	addi	r2,r2,-11904
 324177c:	10800f17 	ldw	r2,60(r2)
 3241780:	10c00044 	addi	r3,r2,1
 3241784:	0080c9b4 	movhi	r2,806
 3241788:	10b46004 	addi	r2,r2,-11904
 324178c:	10c00f15 	stw	r3,60(r2)
      return rc;
 3241790:	e0bff317 	ldw	r2,-52(fp)
 3241794:	e0bffe15 	stw	r2,-8(fp)
 3241798:	0000c806 	br	3241abc <ip_reasm_process_subsequent_fragments+0x57c>

   /* the two combinations of index and rfqp are as follows:
    * (1) index = INVALID_FRAG_INDEX, rfqp = non-zero: no empty slot found in RFQ(s),
    *     and rfqp points to the last RFQ that was processed
    * (2) index != INVALID_FRAG_INDEX, rfqp = non-zero: empty slot found in RFQ(s) */
   if (index != INVALID_FRAG_INDEX)
 324179c:	e0bff70b 	ldhu	r2,-36(fp)
 32417a0:	10bfffcc 	andi	r2,r2,65535
 32417a4:	10800420 	cmpeqi	r2,r2,16
 32417a8:	1000121e 	bne	r2,zero,32417f4 <ip_reasm_process_subsequent_fragments+0x2b4>
      {
      /* we have an empty slot in the PACKET array into which we can place 
       * the just received fragment */
      rfqp->bufp[index] = p;
 32417ac:	e0fff817 	ldw	r3,-32(fp)
 32417b0:	e0bff70b 	ldhu	r2,-36(fp)
 32417b4:	10bfffcc 	andi	r2,r2,65535
 32417b8:	1085883a 	add	r2,r2,r2
 32417bc:	1085883a 	add	r2,r2,r2
 32417c0:	10c5883a 	add	r2,r2,r3
 32417c4:	10c00104 	addi	r3,r2,4
 32417c8:	e0bffa17 	ldw	r2,-24(fp)
 32417cc:	18800015 	stw	r2,0(r3)
      rfqp->frag_offset[index] = frag_offset;
 32417d0:	e0fff817 	ldw	r3,-32(fp)
 32417d4:	e0bff70b 	ldhu	r2,-36(fp)
 32417d8:	10bfffcc 	andi	r2,r2,65535
 32417dc:	e13ff90b 	ldhu	r4,-28(fp)
 32417e0:	1085883a 	add	r2,r2,r2
 32417e4:	10c5883a 	add	r2,r2,r3
 32417e8:	10801104 	addi	r2,r2,68
 32417ec:	1100000d 	sth	r4,0(r2)
 32417f0:	00003c06 	br	32418e4 <ip_reasm_process_subsequent_fragments+0x3a4>
      }
   else
      {
      /* since we need to allocate an extra RFQ, check for memory useage again... */
      if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (RFQ)))) != IPREASM_OK)
 32417f4:	e0bffa17 	ldw	r2,-24(fp)
 32417f8:	10800217 	ldw	r2,8(r2)
 32417fc:	10801904 	addi	r2,r2,100
 3241800:	113fffcc 	andi	r4,r2,65535
 3241804:	3240a500 	call	3240a50 <ip_reasm_check_mem_useage>
 3241808:	e0bff315 	stw	r2,-52(fp)
 324180c:	e0bff317 	ldw	r2,-52(fp)
 3241810:	1005003a 	cmpeq	r2,r2,zero
 3241814:	1000121e 	bne	r2,zero,3241860 <ip_reasm_process_subsequent_fragments+0x320>
         {
         LOCK_NET_RESOURCE (FREEQ_RESID);
 3241818:	01000084 	movi	r4,2
 324181c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pk_free (p);
 3241820:	e13ffa17 	ldw	r4,-24(fp)
 3241824:	322a2dc0 	call	322a2dc <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241828:	01000084 	movi	r4,2
 324182c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 3241830:	e13ffb17 	ldw	r4,-20(fp)
 3241834:	3241f780 	call	3241f78 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 3241838:	0080c9b4 	movhi	r2,806
 324183c:	10b46004 	addi	r2,r2,-11904
 3241840:	10800f17 	ldw	r2,60(r2)
 3241844:	10c00044 	addi	r3,r2,1
 3241848:	0080c9b4 	movhi	r2,806
 324184c:	10b46004 	addi	r2,r2,-11904
 3241850:	10c00f15 	stw	r3,60(r2)
         return rc;
 3241854:	e0fff317 	ldw	r3,-52(fp)
 3241858:	e0fffe15 	stw	r3,-8(fp)
 324185c:	00009706 	br	3241abc <ip_reasm_process_subsequent_fragments+0x57c>
         }

      /* no slots are available in the one (or more) existing RFQs; we 
       * need to create a new RFQ to store the just received fragment */
      new_rfqp = (RFQP) IPR_ALLOC (sizeof(RFQ));
 3241860:	01001904 	movi	r4,100
 3241864:	322b5d00 	call	322b5d0 <npalloc>
 3241868:	e0bff415 	stw	r2,-48(fp)
      if (new_rfqp == 0)
 324186c:	e0bff417 	ldw	r2,-48(fp)
 3241870:	1004c03a 	cmpne	r2,r2,zero
 3241874:	1000121e 	bne	r2,zero,32418c0 <ip_reasm_process_subsequent_fragments+0x380>
         {
         /* can't store the existing fragment, so we'll drop it */
         LOCK_NET_RESOURCE (FREEQ_RESID);
 3241878:	01000084 	movi	r4,2
 324187c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pk_free (p);
 3241880:	e13ffa17 	ldw	r4,-24(fp)
 3241884:	322a2dc0 	call	322a2dc <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241888:	01000084 	movi	r4,2
 324188c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 3241890:	e13ffb17 	ldw	r4,-20(fp)
 3241894:	3241f780 	call	3241f78 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 3241898:	0080c9b4 	movhi	r2,806
 324189c:	10b46004 	addi	r2,r2,-11904
 32418a0:	10800f17 	ldw	r2,60(r2)
 32418a4:	10c00044 	addi	r3,r2,1
 32418a8:	0080c9b4 	movhi	r2,806
 32418ac:	10b46004 	addi	r2,r2,-11904
 32418b0:	10c00f15 	stw	r3,60(r2)
         return ENP_RESOURCE;
 32418b4:	013ffa84 	movi	r4,-22
 32418b8:	e13ffe15 	stw	r4,-8(fp)
 32418bc:	00007f06 	br	3241abc <ip_reasm_process_subsequent_fragments+0x57c>
         }
      else
         {
         new_rfqp->bufp[0] = p;
 32418c0:	e0fff417 	ldw	r3,-48(fp)
 32418c4:	e0bffa17 	ldw	r2,-24(fp)
 32418c8:	18800115 	stw	r2,4(r3)
         new_rfqp->frag_offset[0] = frag_offset;
 32418cc:	e0fff90b 	ldhu	r3,-28(fp)
 32418d0:	e0bff417 	ldw	r2,-48(fp)
 32418d4:	10c0110d 	sth	r3,68(r2)
         rfqp->next = new_rfqp;
 32418d8:	e0fff817 	ldw	r3,-32(fp)
 32418dc:	e0bff417 	ldw	r2,-48(fp)
 32418e0:	18800015 	stw	r2,0(r3)
         }
      }
      
      /* check to see if the RFQ is still compact, but only if hole(s) were created 
       * in ip_reasm_compute_overlap () */
      if (hole_created)
 32418e4:	e0bff983 	ldbu	r2,-26(fp)
 32418e8:	10803fcc 	andi	r2,r2,255
 32418ec:	1005003a 	cmpeq	r2,r2,zero
 32418f0:	1000161e 	bne	r2,zero,324194c <ip_reasm_process_subsequent_fragments+0x40c>
         {
         if ((rc = ip_reasm_mark_compact_rfq (irep)) != IPREASM_OK)
 32418f4:	e13ffb17 	ldw	r4,-20(fp)
 32418f8:	32421400 	call	3242140 <ip_reasm_mark_compact_rfq>
 32418fc:	e0bff315 	stw	r2,-52(fp)
 3241900:	e0bff317 	ldw	r2,-52(fp)
 3241904:	1005003a 	cmpeq	r2,r2,zero
 3241908:	1000101e 	bne	r2,zero,324194c <ip_reasm_process_subsequent_fragments+0x40c>
            {
            /* an error return is due to a bad IRE pointer, which ip_reasm_mark_compact_rfq () logs */
            LOCK_NET_RESOURCE (FREEQ_RESID);
 324190c:	01000084 	movi	r4,2
 3241910:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
            pk_free (p);
 3241914:	e13ffa17 	ldw	r4,-24(fp)
 3241918:	322a2dc0 	call	322a2dc <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);
 324191c:	01000084 	movi	r4,2
 3241920:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
            ++ip_mib.ipReasmFails;
 3241924:	0080c9b4 	movhi	r2,806
 3241928:	10b46004 	addi	r2,r2,-11904
 324192c:	10800f17 	ldw	r2,60(r2)
 3241930:	10c00044 	addi	r3,r2,1
 3241934:	0080c9b4 	movhi	r2,806
 3241938:	10b46004 	addi	r2,r2,-11904
 324193c:	10c00f15 	stw	r3,60(r2)
            return rc;
 3241940:	e0bff317 	ldw	r2,-52(fp)
 3241944:	e0bffe15 	stw	r2,-8(fp)
 3241948:	00005c06 	br	3241abc <ip_reasm_process_subsequent_fragments+0x57c>

   /* compute the total number of bytes queued in this IRE.  Note 
    * that the RHS has been updated to reflect the amount of "unique"
    * data in the just received fragment (the IP header has been dropped,
    * and perhaps additional duplicate data too (if present)) */
   irep->rcvd += (u_short) (p->nb_plen);
 324194c:	e0bffb17 	ldw	r2,-20(fp)
 3241950:	10c0048b 	ldhu	r3,18(r2)
 3241954:	e0bffa17 	ldw	r2,-24(fp)
 3241958:	10800417 	ldw	r2,16(r2)
 324195c:	1885883a 	add	r2,r3,r2
 3241960:	1007883a 	mov	r3,r2
 3241964:	e0bffb17 	ldw	r2,-20(fp)
 3241968:	10c0048d 	sth	r3,18(r2)
   ip_reasm_incr_mem_useage (p->nb_blen + ((new_rfqp == 0) ? 0 : (sizeof(RFQ))));
 324196c:	e0bffa17 	ldw	r2,-24(fp)
 3241970:	10800217 	ldw	r2,8(r2)
 3241974:	e0bffd0d 	sth	r2,-12(fp)
 3241978:	e0bff417 	ldw	r2,-48(fp)
 324197c:	1004c03a 	cmpne	r2,r2,zero
 3241980:	1000021e 	bne	r2,zero,324198c <ip_reasm_process_subsequent_fragments+0x44c>
 3241984:	e03ffc0d 	sth	zero,-16(fp)
 3241988:	00000206 	br	3241994 <ip_reasm_process_subsequent_fragments+0x454>
 324198c:	00c01904 	movi	r3,100
 3241990:	e0fffc0d 	sth	r3,-16(fp)
 3241994:	e13ffd0b 	ldhu	r4,-12(fp)
 3241998:	e0fffc0b 	ldhu	r3,-16(fp)
 324199c:	20c5883a 	add	r2,r4,r3
 32419a0:	113fffcc 	andi	r4,r2,65535
 32419a4:	3240ae80 	call	3240ae8 <ip_reasm_incr_mem_useage>

   if (irep->length != 0)
 32419a8:	e0bffb17 	ldw	r2,-20(fp)
 32419ac:	1080040b 	ldhu	r2,16(r2)
 32419b0:	10bfffcc 	andi	r2,r2,65535
 32419b4:	1005003a 	cmpeq	r2,r2,zero
 32419b8:	10003f1e 	bne	r2,zero,3241ab8 <ip_reasm_process_subsequent_fragments+0x578>
      {
      /* we know the total length of the original unfragmented datagram; 
       * let's check to see if we have all of the bytes... */
      if (irep->rcvd == irep->length)
 32419bc:	e0bffb17 	ldw	r2,-20(fp)
 32419c0:	10c0048b 	ldhu	r3,18(r2)
 32419c4:	e0bffb17 	ldw	r2,-20(fp)
 32419c8:	1080040b 	ldhu	r2,16(r2)
 32419cc:	18ffffcc 	andi	r3,r3,65535
 32419d0:	10bfffcc 	andi	r2,r2,65535
 32419d4:	1880381e 	bne	r3,r2,3241ab8 <ip_reasm_process_subsequent_fragments+0x578>
          * Ensure that we allocate space for the data link header, IP header, 
          * and the payload of the original, unfragmented datagram.  We pick 
          * the data link layer and IP headers from the First Fragment (FF), 
          * but we need to adjust some of the fields in the IP header after 
          * reassembly is complete. */
         pip = (struct ip *) irep->l3_hdr;
 32419d8:	e0bffb17 	ldw	r2,-20(fp)
 32419dc:	10802017 	ldw	r2,128(r2)
 32419e0:	e0bff515 	stw	r2,-44(fp)
         LOCK_NET_RESOURCE (FREEQ_RESID);
 32419e4:	01000084 	movi	r4,2
 32419e8:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         reassy_pkt = pk_alloc (irep->length + (irep->l3_hdr - irep->l2_hdr) + ip_hlen (pip));
 32419ec:	e0bffb17 	ldw	r2,-20(fp)
 32419f0:	1080040b 	ldhu	r2,16(r2)
 32419f4:	113fffcc 	andi	r4,r2,65535
 32419f8:	e0bffb17 	ldw	r2,-20(fp)
 32419fc:	10802017 	ldw	r2,128(r2)
 3241a00:	1007883a 	mov	r3,r2
 3241a04:	e0bffb17 	ldw	r2,-20(fp)
 3241a08:	10801f17 	ldw	r2,124(r2)
 3241a0c:	1885c83a 	sub	r2,r3,r2
 3241a10:	2087883a 	add	r3,r4,r2
 3241a14:	e0bff517 	ldw	r2,-44(fp)
 3241a18:	10800003 	ldbu	r2,0(r2)
 3241a1c:	10803fcc 	andi	r2,r2,255
 3241a20:	108003cc 	andi	r2,r2,15
 3241a24:	1085883a 	add	r2,r2,r2
 3241a28:	1085883a 	add	r2,r2,r2
 3241a2c:	1885883a 	add	r2,r3,r2
 3241a30:	1009883a 	mov	r4,r2
 3241a34:	3229f480 	call	3229f48 <pk_alloc>
 3241a38:	e0bff615 	stw	r2,-40(fp)
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241a3c:	01000084 	movi	r4,2
 3241a40:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         if (reassy_pkt == 0)
 3241a44:	e0bff617 	ldw	r2,-40(fp)
 3241a48:	1004c03a 	cmpne	r2,r2,zero
 3241a4c:	10000c1e 	bne	r2,zero,3241a80 <ip_reasm_process_subsequent_fragments+0x540>
            {
            /* the following call will delete all queued fragments, including
             * the currently received one */
            ip_reasm_delete_ire (irep);
 3241a50:	e13ffb17 	ldw	r4,-20(fp)
 3241a54:	3241f780 	call	3241f78 <ip_reasm_delete_ire>
            ++ip_mib.ipReasmFails;
 3241a58:	0080c9b4 	movhi	r2,806
 3241a5c:	10b46004 	addi	r2,r2,-11904
 3241a60:	10800f17 	ldw	r2,60(r2)
 3241a64:	10c00044 	addi	r3,r2,1
 3241a68:	0080c9b4 	movhi	r2,806
 3241a6c:	10b46004 	addi	r2,r2,-11904
 3241a70:	10c00f15 	stw	r3,60(r2)
            return ENP_NOBUFFER;
 3241a74:	013ffac4 	movi	r4,-21
 3241a78:	e13ffe15 	stw	r4,-8(fp)
 3241a7c:	00000f06 	br	3241abc <ip_reasm_process_subsequent_fragments+0x57c>
            }
         else
            {
            ip_reasm_copy_queued_fragments_into_reassy_buffer (reassy_pkt, irep);
 3241a80:	e13ff617 	ldw	r4,-40(fp)
 3241a84:	e17ffb17 	ldw	r5,-20(fp)
 3241a88:	3241b380 	call	3241b38 <ip_reasm_copy_queued_fragments_into_reassy_buffer>
            /* free the IRE structure (and its constituent elements) */
            ip_reasm_delete_ire (irep);
 3241a8c:	e13ffb17 	ldw	r4,-20(fp)
 3241a90:	3241f780 	call	3241f78 <ip_reasm_delete_ire>
            /* at this point, 'irep' is no longer a valid pointer, and so should 
             * not be referenced.  We're done, and we now pass the packet for 
             * demux'ing to the appropriate entity (e.g., UDP, TCP, etc.).  Note
             * that ip_demux () expects 'nb_prot' to point to the beginning of 
             * the IP header. */
            ++ip_mib.ipReasmOKs;
 3241a94:	0080c9b4 	movhi	r2,806
 3241a98:	10b46004 	addi	r2,r2,-11904
 3241a9c:	10800e17 	ldw	r2,56(r2)
 3241aa0:	10c00044 	addi	r3,r2,1
 3241aa4:	0080c9b4 	movhi	r2,806
 3241aa8:	10b46004 	addi	r2,r2,-11904
 3241aac:	10c00e15 	stw	r3,56(r2)
            ip_demux (reassy_pkt);
 3241ab0:	e13ff617 	ldw	r4,-40(fp)
 3241ab4:	324303c0 	call	324303c <ip_demux>
      {
      /* we haven't received the LF (so we don't know the total amount of data in 
       * the original, unfragmented datagram), and therefore reassembly can't complete yet */
      }

   return IPREASM_OK;
 3241ab8:	e03ffe15 	stw	zero,-8(fp)
 3241abc:	e0bffe17 	ldw	r2,-8(fp)
}
 3241ac0:	e037883a 	mov	sp,fp
 3241ac4:	dfc00117 	ldw	ra,4(sp)
 3241ac8:	df000017 	ldw	fp,0(sp)
 3241acc:	dec00204 	addi	sp,sp,8
 3241ad0:	f800283a 	ret

03241ad4 <ip_reasm_find_ire>:
OUTPUT: This function returns a IPREASM_TRUE if the IRE exists in the master 
IRE list; otherwise, it returns a IPREASM_FALSE.
*/

u_char ip_reasm_find_ire (IREP irep)
{
 3241ad4:	defffc04 	addi	sp,sp,-16
 3241ad8:	df000315 	stw	fp,12(sp)
 3241adc:	df000304 	addi	fp,sp,12
 3241ae0:	e13ffe15 	stw	r4,-8(fp)
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 3241ae4:	d0a8ff17 	ldw	r2,-23556(gp)
 3241ae8:	e0bffd15 	stw	r2,-12(fp)
 3241aec:	00000906 	br	3241b14 <ip_reasm_find_ire+0x40>
      {
      if (tmpp == irep) 
 3241af0:	e0fffd17 	ldw	r3,-12(fp)
 3241af4:	e0bffe17 	ldw	r2,-8(fp)
 3241af8:	1880031e 	bne	r3,r2,3241b08 <ip_reasm_find_ire+0x34>
         {
         return IPREASM_TRUE;
 3241afc:	00800044 	movi	r2,1
 3241b00:	e0bfff15 	stw	r2,-4(fp)
 3241b04:	00000706 	br	3241b24 <ip_reasm_find_ire+0x50>
u_char ip_reasm_find_ire (IREP irep)
{
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 3241b08:	e0bffd17 	ldw	r2,-12(fp)
 3241b0c:	10800017 	ldw	r2,0(r2)
 3241b10:	e0bffd15 	stw	r2,-12(fp)
 3241b14:	e0bffd17 	ldw	r2,-12(fp)
 3241b18:	1004c03a 	cmpne	r2,r2,zero
 3241b1c:	103ff41e 	bne	r2,zero,3241af0 <ip_reasm_find_ire+0x1c>
         {
         return IPREASM_TRUE;
         }
      }

   return IPREASM_FALSE;
 3241b20:	e03fff15 	stw	zero,-4(fp)
 3241b24:	e0bfff17 	ldw	r2,-4(fp)
}
 3241b28:	e037883a 	mov	sp,fp
 3241b2c:	df000017 	ldw	fp,0(sp)
 3241b30:	dec00104 	addi	sp,sp,4
 3241b34:	f800283a 	ret

03241b38 <ip_reasm_copy_queued_fragments_into_reassy_buffer>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_copy_queued_fragments_into_reassy_buffer (PACKET reassy_pkt, IREP irep)
{
 3241b38:	defff404 	addi	sp,sp,-48
 3241b3c:	dfc00b15 	stw	ra,44(sp)
 3241b40:	df000a15 	stw	fp,40(sp)
 3241b44:	df000a04 	addi	fp,sp,40
 3241b48:	e13ffe15 	stw	r4,-8(fp)
 3241b4c:	e17fff15 	stw	r5,-4(fp)
   RFQP rfqp;
   u_short i;
   PACKET p;
   u_char iphlen;
   char * writep;
   PACKET sav_pkt = 0;
 3241b50:	e03ff615 	stw	zero,-40(fp)

   pip = (struct ip *) irep->l3_hdr;
 3241b54:	e0bfff17 	ldw	r2,-4(fp)
 3241b58:	10802017 	ldw	r2,128(r2)
 3241b5c:	e0bffd15 	stw	r2,-12(fp)
   iphlen = ip_hlen (pip);
 3241b60:	e0bffd17 	ldw	r2,-12(fp)
 3241b64:	10800003 	ldbu	r2,0(r2)
 3241b68:	108003cc 	andi	r2,r2,15
 3241b6c:	1085883a 	add	r2,r2,r2
 3241b70:	1085883a 	add	r2,r2,r2
 3241b74:	e0bff805 	stb	r2,-32(fp)

   /* copy the data link and IP layer headers into place.  These headers are 
    * from the First Fragment (FF). */
   offset = (u_char) ((irep->l3_hdr - irep->l2_hdr) + iphlen);
 3241b78:	e0bfff17 	ldw	r2,-4(fp)
 3241b7c:	10802017 	ldw	r2,128(r2)
 3241b80:	1007883a 	mov	r3,r2
 3241b84:	e0bfff17 	ldw	r2,-4(fp)
 3241b88:	10801f17 	ldw	r2,124(r2)
 3241b8c:	1885c83a 	sub	r2,r3,r2
 3241b90:	1007883a 	mov	r3,r2
 3241b94:	e0bff803 	ldbu	r2,-32(fp)
 3241b98:	1885883a 	add	r2,r3,r2
 3241b9c:	e0bffc05 	stb	r2,-16(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);
 3241ba0:	e0bffe17 	ldw	r2,-8(fp)
 3241ba4:	11000117 	ldw	r4,4(r2)
 3241ba8:	e0bfff17 	ldw	r2,-4(fp)
 3241bac:	10801f17 	ldw	r2,124(r2)
 3241bb0:	e0fffc03 	ldbu	r3,-16(fp)
 3241bb4:	100b883a 	mov	r5,r2
 3241bb8:	180d883a 	mov	r6,r3
 3241bbc:	32067cc0 	call	32067cc <memcpy>

   rfqp = &(irep->rfq);
 3241bc0:	e0bfff17 	ldw	r2,-4(fp)
 3241bc4:	10800604 	addi	r2,r2,24
 3241bc8:	e0bffb15 	stw	r2,-20(fp)
   writep = reassy_pkt->nb_buff + offset;
 3241bcc:	e0bffe17 	ldw	r2,-8(fp)
 3241bd0:	10c00117 	ldw	r3,4(r2)
 3241bd4:	e0bffc03 	ldbu	r2,-16(fp)
 3241bd8:	1885883a 	add	r2,r3,r2
 3241bdc:	e0bff715 	stw	r2,-36(fp)

   while (rfqp)
 3241be0:	00004606 	br	3241cfc <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1c4>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 3241be4:	e03ffa0d 	sth	zero,-24(fp)
 3241be8:	00003e06 	br	3241ce4 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1ac>
         {
         if ((p = rfqp->bufp [i]) != 0)
 3241bec:	e0bffa0b 	ldhu	r2,-24(fp)
 3241bf0:	e0fffb17 	ldw	r3,-20(fp)
 3241bf4:	1085883a 	add	r2,r2,r2
 3241bf8:	1085883a 	add	r2,r2,r2
 3241bfc:	10c5883a 	add	r2,r2,r3
 3241c00:	10800104 	addi	r2,r2,4
 3241c04:	10800017 	ldw	r2,0(r2)
 3241c08:	e0bff915 	stw	r2,-28(fp)
 3241c0c:	e0bff917 	ldw	r2,-28(fp)
 3241c10:	1005003a 	cmpeq	r2,r2,zero
 3241c14:	1000291e 	bne	r2,zero,3241cbc <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x184>
            {
            /* note that rfqp->frag_offset[i] is the true value of the offset field, 
             * and does not require any scaling (like the Fragment Offset field in 
             * the IP header) */
            MEMCPY((writep + rfqp->frag_offset[i]), p->nb_prot, p->nb_plen);
 3241c18:	e0bffa0b 	ldhu	r2,-24(fp)
 3241c1c:	e0fffb17 	ldw	r3,-20(fp)
 3241c20:	1085883a 	add	r2,r2,r2
 3241c24:	10c5883a 	add	r2,r2,r3
 3241c28:	10801104 	addi	r2,r2,68
 3241c2c:	1080000b 	ldhu	r2,0(r2)
 3241c30:	10bfffcc 	andi	r2,r2,65535
 3241c34:	1007883a 	mov	r3,r2
 3241c38:	e0bff717 	ldw	r2,-36(fp)
 3241c3c:	1887883a 	add	r3,r3,r2
 3241c40:	e0bff917 	ldw	r2,-28(fp)
 3241c44:	11400317 	ldw	r5,12(r2)
 3241c48:	e0bff917 	ldw	r2,-28(fp)
 3241c4c:	10800417 	ldw	r2,16(r2)
 3241c50:	1809883a 	mov	r4,r3
 3241c54:	100d883a 	mov	r6,r2
 3241c58:	32067cc0 	call	32067cc <memcpy>
            /* free fragment after we've copied data out from it (unless we need to
             * save it so that we can copy some fields from it later (after exiting 
             * from the loop)) */
            if (!sav_pkt) sav_pkt = p;
 3241c5c:	e0bff617 	ldw	r2,-40(fp)
 3241c60:	1004c03a 	cmpne	r2,r2,zero
 3241c64:	1000031e 	bne	r2,zero,3241c74 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x13c>
 3241c68:	e0bff917 	ldw	r2,-28(fp)
 3241c6c:	e0bff615 	stw	r2,-40(fp)
 3241c70:	00000a06 	br	3241c9c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x164>
            else
               {
               ip_reasm_decr_mem_useage (p->nb_blen);
 3241c74:	e0bff917 	ldw	r2,-28(fp)
 3241c78:	10800217 	ldw	r2,8(r2)
 3241c7c:	113fffcc 	andi	r4,r2,65535
 3241c80:	3240b900 	call	3240b90 <ip_reasm_decr_mem_useage>
               LOCK_NET_RESOURCE (FREEQ_RESID);
 3241c84:	01000084 	movi	r4,2
 3241c88:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
               pk_free (p);
 3241c8c:	e13ff917 	ldw	r4,-28(fp)
 3241c90:	322a2dc0 	call	322a2dc <pk_free>
               UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241c94:	01000084 	movi	r4,2
 3241c98:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
               }
            /* since we're done with the packet, mark slot as unused */
            rfqp->bufp [i] = 0;
 3241c9c:	e0bffa0b 	ldhu	r2,-24(fp)
 3241ca0:	e0fffb17 	ldw	r3,-20(fp)
 3241ca4:	1085883a 	add	r2,r2,r2
 3241ca8:	1085883a 	add	r2,r2,r2
 3241cac:	10c5883a 	add	r2,r2,r3
 3241cb0:	10800104 	addi	r2,r2,4
 3241cb4:	10000015 	stw	zero,0(r2)
 3241cb8:	00000706 	br	3241cd8 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1a0>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 3241cbc:	e0bfff17 	ldw	r2,-4(fp)
 3241cc0:	10802103 	ldbu	r2,132(r2)
 3241cc4:	10803fcc 	andi	r2,r2,255
 3241cc8:	1080004c 	andi	r2,r2,1
 3241ccc:	10803fcc 	andi	r2,r2,255
 3241cd0:	1004c03a 	cmpne	r2,r2,zero
 3241cd4:	1000061e 	bne	r2,zero,3241cf0 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1b8>
   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 3241cd8:	e0bffa0b 	ldhu	r2,-24(fp)
 3241cdc:	10800044 	addi	r2,r2,1
 3241ce0:	e0bffa0d 	sth	r2,-24(fp)
 3241ce4:	e0bffa0b 	ldhu	r2,-24(fp)
 3241ce8:	10800430 	cmpltui	r2,r2,16
 3241cec:	103fbf1e 	bne	r2,zero,3241bec <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xb4>
               break;
               }
            }
          }

      rfqp = rfqp->next;
 3241cf0:	e0bffb17 	ldw	r2,-20(fp)
 3241cf4:	10800017 	ldw	r2,0(r2)
 3241cf8:	e0bffb15 	stw	r2,-20(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);

   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
 3241cfc:	e0bffb17 	ldw	r2,-20(fp)
 3241d00:	1004c03a 	cmpne	r2,r2,zero
 3241d04:	103fb71e 	bne	r2,zero,3241be4 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xac>
      }

   /* update various fields in the reassembled packet.  Some fields will be 
    * picked from one of the constituent fragments (sav_pkt) which hasn't
    * been deleted yet. */
   reassy_pkt->nb_prot = reassy_pkt->nb_buff + (irep->l3_hdr - irep->l2_hdr);
 3241d08:	e0bffe17 	ldw	r2,-8(fp)
 3241d0c:	11000117 	ldw	r4,4(r2)
 3241d10:	e0bfff17 	ldw	r2,-4(fp)
 3241d14:	10802017 	ldw	r2,128(r2)
 3241d18:	1007883a 	mov	r3,r2
 3241d1c:	e0bfff17 	ldw	r2,-4(fp)
 3241d20:	10801f17 	ldw	r2,124(r2)
 3241d24:	1885c83a 	sub	r2,r3,r2
 3241d28:	2087883a 	add	r3,r4,r2
 3241d2c:	e0bffe17 	ldw	r2,-8(fp)
 3241d30:	10c00315 	stw	r3,12(r2)
   reassy_pkt->nb_plen = irep->length + iphlen;
 3241d34:	e0bfff17 	ldw	r2,-4(fp)
 3241d38:	1080040b 	ldhu	r2,16(r2)
 3241d3c:	10ffffcc 	andi	r3,r2,65535
 3241d40:	e0bff803 	ldbu	r2,-32(fp)
 3241d44:	1885883a 	add	r2,r3,r2
 3241d48:	1007883a 	mov	r3,r2
 3241d4c:	e0bffe17 	ldw	r2,-8(fp)
 3241d50:	10c00415 	stw	r3,16(r2)
   reassy_pkt->nb_tstamp = cticks;
 3241d54:	0080c974 	movhi	r2,805
 3241d58:	10925604 	addi	r2,r2,18776
 3241d5c:	10800017 	ldw	r2,0(r2)
 3241d60:	1007883a 	mov	r3,r2
 3241d64:	e0bffe17 	ldw	r2,-8(fp)
 3241d68:	10c00515 	stw	r3,20(r2)
   reassy_pkt->flags |= ((sav_pkt->flags) & (PKF_BCAST | PKF_MCAST));
 3241d6c:	e0bffe17 	ldw	r2,-8(fp)
 3241d70:	10c00a17 	ldw	r3,40(r2)
 3241d74:	e0bff617 	ldw	r2,-40(fp)
 3241d78:	10800a17 	ldw	r2,40(r2)
 3241d7c:	108000cc 	andi	r2,r2,3
 3241d80:	1886b03a 	or	r3,r3,r2
 3241d84:	e0bffe17 	ldw	r2,-8(fp)
 3241d88:	10c00a15 	stw	r3,40(r2)
   reassy_pkt->net = sav_pkt->net;
 3241d8c:	e0bff617 	ldw	r2,-40(fp)
 3241d90:	10c00617 	ldw	r3,24(r2)
 3241d94:	e0bffe17 	ldw	r2,-8(fp)
 3241d98:	10c00615 	stw	r3,24(r2)
   reassy_pkt->type = sav_pkt->type;
 3241d9c:	e0bff617 	ldw	r2,-40(fp)
 3241da0:	10c0080b 	ldhu	r3,32(r2)
 3241da4:	e0bffe17 	ldw	r2,-8(fp)
 3241da8:	10c0080d 	sth	r3,32(r2)
   /* fhost is set by ip_demux () before handing off to the packet to its 
    * intended destination (protocol) */

   /* free the saved packet too, since we don't need it anymore */
   ip_reasm_decr_mem_useage (sav_pkt->nb_blen);
 3241dac:	e0bff617 	ldw	r2,-40(fp)
 3241db0:	10800217 	ldw	r2,8(r2)
 3241db4:	113fffcc 	andi	r4,r2,65535
 3241db8:	3240b900 	call	3240b90 <ip_reasm_decr_mem_useage>
   LOCK_NET_RESOURCE (FREEQ_RESID);
 3241dbc:	01000084 	movi	r4,2
 3241dc0:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   pk_free (sav_pkt);
 3241dc4:	e13ff617 	ldw	r4,-40(fp)
 3241dc8:	322a2dc0 	call	322a2dc <pk_free>
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241dcc:	01000084 	movi	r4,2
 3241dd0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   /* after the reassembly is complete, we update the following fields in
    * the IP header: Total Length, Flags/Fragment Offset, header checksum */
   pip = ip_head(reassy_pkt);
 3241dd4:	e0bffe17 	ldw	r2,-8(fp)
 3241dd8:	10800317 	ldw	r2,12(r2)
 3241ddc:	e0bffd15 	stw	r2,-12(fp)
   pip->ip_len = htons(reassy_pkt->nb_plen);
 3241de0:	e0bffe17 	ldw	r2,-8(fp)
 3241de4:	10800417 	ldw	r2,16(r2)
 3241de8:	1004d23a 	srli	r2,r2,8
 3241dec:	10803fcc 	andi	r2,r2,255
 3241df0:	1009883a 	mov	r4,r2
 3241df4:	e0bffe17 	ldw	r2,-8(fp)
 3241df8:	10800417 	ldw	r2,16(r2)
 3241dfc:	1004923a 	slli	r2,r2,8
 3241e00:	1007883a 	mov	r3,r2
 3241e04:	00bfc004 	movi	r2,-256
 3241e08:	1884703a 	and	r2,r3,r2
 3241e0c:	2084b03a 	or	r2,r4,r2
 3241e10:	1007883a 	mov	r3,r2
 3241e14:	e0bffd17 	ldw	r2,-12(fp)
 3241e18:	10c0008d 	sth	r3,2(r2)
   /* turn off More Fragments (MF) bit; the DF bit stays unchanged */
   pip->ip_flgs_foff &= htons(~((u_short) IP_FLG_MF));
 3241e1c:	e0bffd17 	ldw	r2,-12(fp)
 3241e20:	10c0018b 	ldhu	r3,6(r2)
 3241e24:	00bff7c4 	movi	r2,-33
 3241e28:	1884703a 	and	r2,r3,r2
 3241e2c:	1007883a 	mov	r3,r2
 3241e30:	e0bffd17 	ldw	r2,-12(fp)
 3241e34:	10c0018d 	sth	r3,6(r2)
   /* clear the Fragment Offset bits */
   pip->ip_flgs_foff &= htons(~((u_short) IP_EXTRACT_FOFF)); 
 3241e38:	e0bffd17 	ldw	r2,-12(fp)
 3241e3c:	1080018b 	ldhu	r2,6(r2)
 3241e40:	1080380c 	andi	r2,r2,224
 3241e44:	1007883a 	mov	r3,r2
 3241e48:	e0bffd17 	ldw	r2,-12(fp)
 3241e4c:	10c0018d 	sth	r3,6(r2)
   /* the following isn't really required, and can be removed */
   pip->ip_chksum = IPXSUM;
 3241e50:	e0bffd17 	ldw	r2,-12(fp)
 3241e54:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum (pip, (iphlen/2));
 3241e58:	e0bff803 	ldbu	r2,-32(fp)
 3241e5c:	1004d07a 	srli	r2,r2,1
 3241e60:	11403fcc 	andi	r5,r2,255
 3241e64:	e13ffd17 	ldw	r4,-12(fp)
 3241e68:	32259f80 	call	32259f8 <cksum>
 3241e6c:	0084303a 	nor	r2,zero,r2
 3241e70:	1007883a 	mov	r3,r2
 3241e74:	e0bffd17 	ldw	r2,-12(fp)
 3241e78:	10c0028d 	sth	r3,10(r2)

   return IPREASM_OK;
 3241e7c:	0005883a 	mov	r2,zero
}
 3241e80:	e037883a 	mov	sp,fp
 3241e84:	dfc00117 	ldw	ra,4(sp)
 3241e88:	df000017 	ldw	fp,0(sp)
 3241e8c:	dec00204 	addi	sp,sp,8
 3241e90:	f800283a 	ret

03241e94 <ip_reasm_process_timer_tick>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_process_timer_tick (void)
{
 3241e94:	defffc04 	addi	sp,sp,-16
 3241e98:	dfc00315 	stw	ra,12(sp)
 3241e9c:	df000215 	stw	fp,8(sp)
 3241ea0:	df000204 	addi	fp,sp,8
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 3241ea4:	0009883a 	mov	r4,zero
 3241ea8:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 3241eac:	d0a8ff17 	ldw	r2,-23556(gp)
 3241eb0:	e0bfff15 	stw	r2,-4(fp)
 3241eb4:	00002006 	br	3241f38 <ip_reasm_process_timer_tick+0xa4>
      {
      /* save the next pointer for the IRE that may be deleted */
      nxt_tmpp = tmpp->next;
 3241eb8:	e0bfff17 	ldw	r2,-4(fp)
 3241ebc:	10800017 	ldw	r2,0(r2)
 3241ec0:	e0bffe15 	stw	r2,-8(fp)
      ++tmpp->age;
 3241ec4:	e0bfff17 	ldw	r2,-4(fp)
 3241ec8:	10800517 	ldw	r2,20(r2)
 3241ecc:	10c00044 	addi	r3,r2,1
 3241ed0:	e0bfff17 	ldw	r2,-4(fp)
 3241ed4:	10c00515 	stw	r3,20(r2)
      /* check to see if this entry has reached its max age (expired)? */
      if (tmpp->age == IRE_TMO)
 3241ed8:	e0bfff17 	ldw	r2,-4(fp)
 3241edc:	10800517 	ldw	r2,20(r2)
 3241ee0:	10801e18 	cmpnei	r2,r2,120
 3241ee4:	1000121e 	bne	r2,zero,3241f30 <ip_reasm_process_timer_tick+0x9c>
         {
         /* it has...and therefore must be deleted. */
         ++ire_stats.ire_timed_out;
 3241ee8:	0080c9b4 	movhi	r2,806
 3241eec:	10b47404 	addi	r2,r2,-11824
 3241ef0:	10800117 	ldw	r2,4(r2)
 3241ef4:	10c00044 	addi	r3,r2,1
 3241ef8:	0080c9b4 	movhi	r2,806
 3241efc:	10b47404 	addi	r2,r2,-11824
 3241f00:	10c00115 	stw	r3,4(r2)
#ifdef FULL_ICMP
         /* send ICMP Time Exceeded message with code 1 ("fragment reassembly time exceeded") */
         ip_reasm_send_icmp_timex (tmpp);
 3241f04:	e13fff17 	ldw	r4,-4(fp)
 3241f08:	32425dc0 	call	32425dc <ip_reasm_send_icmp_timex>
#endif
         ip_reasm_delete_ire (tmpp);
 3241f0c:	e13fff17 	ldw	r4,-4(fp)
 3241f10:	3241f780 	call	3241f78 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 3241f14:	0080c9b4 	movhi	r2,806
 3241f18:	10b46004 	addi	r2,r2,-11904
 3241f1c:	10800f17 	ldw	r2,60(r2)
 3241f20:	10c00044 	addi	r3,r2,1
 3241f24:	0080c9b4 	movhi	r2,806
 3241f28:	10b46004 	addi	r2,r2,-11904
 3241f2c:	10c00f15 	stw	r3,60(r2)
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 3241f30:	e0bffe17 	ldw	r2,-8(fp)
 3241f34:	e0bfff15 	stw	r2,-4(fp)
 3241f38:	e0bfff17 	ldw	r2,-4(fp)
 3241f3c:	1004c03a 	cmpne	r2,r2,zero
 3241f40:	103fdd1e 	bne	r2,zero,3241eb8 <ip_reasm_process_timer_tick+0x24>
         ++ip_mib.ipReasmFails;
         }
      }

   /* set the time for the next invocation of this routine (one second later) */
   ire_cticks = cticks + TPS;
 3241f44:	0080c974 	movhi	r2,805
 3241f48:	10925604 	addi	r2,r2,18776
 3241f4c:	10800017 	ldw	r2,0(r2)
 3241f50:	1080fa04 	addi	r2,r2,1000
 3241f54:	d0a90015 	stw	r2,-23552(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 3241f58:	0009883a 	mov	r4,zero
 3241f5c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   return IPREASM_OK;
 3241f60:	0005883a 	mov	r2,zero
}
 3241f64:	e037883a 	mov	sp,fp
 3241f68:	dfc00117 	ldw	ra,4(sp)
 3241f6c:	df000017 	ldw	fp,0(sp)
 3241f70:	dec00204 	addi	sp,sp,8
 3241f74:	f800283a 	ret

03241f78 <ip_reasm_delete_ire>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in the 
master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_delete_ire (IREP irep)
{
 3241f78:	defff504 	addi	sp,sp,-44
 3241f7c:	dfc00a15 	stw	ra,40(sp)
 3241f80:	df000915 	stw	fp,36(sp)
 3241f84:	df000904 	addi	fp,sp,36
 3241f88:	e13ffe15 	stw	r4,-8(fp)
   RFQP rfqp, first_rfqp, prev_rfqp;
   u_short i;
   PACKET p;
   IREP tmpp;
   IREP prev_tmpp = 0;
 3241f8c:	e03ff715 	stw	zero,-36(fp)

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 3241f90:	d0a8ff17 	ldw	r2,-23556(gp)
 3241f94:	e0bff815 	stw	r2,-32(fp)
 3241f98:	00001406 	br	3241fec <ip_reasm_delete_ire+0x74>
      {
      if (tmpp == irep) 
 3241f9c:	e0fff817 	ldw	r3,-32(fp)
 3241fa0:	e0bffe17 	ldw	r2,-8(fp)
 3241fa4:	18800c1e 	bne	r3,r2,3241fd8 <ip_reasm_delete_ire+0x60>
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
 3241fa8:	d0e8ff17 	ldw	r3,-23556(gp)
 3241fac:	e0bff817 	ldw	r2,-32(fp)
 3241fb0:	10c0041e 	bne	r2,r3,3241fc4 <ip_reasm_delete_ire+0x4c>
 3241fb4:	e0bffe17 	ldw	r2,-8(fp)
 3241fb8:	10800017 	ldw	r2,0(r2)
 3241fbc:	d0a8ff15 	stw	r2,-23556(gp)
 3241fc0:	00000d06 	br	3241ff8 <ip_reasm_delete_ire+0x80>
         else prev_tmpp->next = irep->next;
 3241fc4:	e0bffe17 	ldw	r2,-8(fp)
 3241fc8:	10c00017 	ldw	r3,0(r2)
 3241fcc:	e0bff717 	ldw	r2,-36(fp)
 3241fd0:	10c00015 	stw	r3,0(r2)
         break;
 3241fd4:	00000806 	br	3241ff8 <ip_reasm_delete_ire+0x80>
         }
      prev_tmpp = tmpp;
 3241fd8:	e0bff817 	ldw	r2,-32(fp)
 3241fdc:	e0bff715 	stw	r2,-36(fp)
   IREP tmpp;
   IREP prev_tmpp = 0;

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 3241fe0:	e0bff817 	ldw	r2,-32(fp)
 3241fe4:	10800017 	ldw	r2,0(r2)
 3241fe8:	e0bff815 	stw	r2,-32(fp)
 3241fec:	e0bff817 	ldw	r2,-32(fp)
 3241ff0:	1004c03a 	cmpne	r2,r2,zero
 3241ff4:	103fe91e 	bne	r2,zero,3241f9c <ip_reasm_delete_ire+0x24>
      prev_tmpp = tmpp;
      }

   /* if the IRE entry does not exist in the master table, return an error 
    * to the caller */
   if (!tmpp)
 3241ff8:	e0bff817 	ldw	r2,-32(fp)
 3241ffc:	1004c03a 	cmpne	r2,r2,zero
 3242000:	10000a1e 	bne	r2,zero,324202c <ip_reasm_delete_ire+0xb4>
      {
      ++ire_stats.bad_irep;
 3242004:	0080c9b4 	movhi	r2,806
 3242008:	10b47404 	addi	r2,r2,-11824
 324200c:	10800017 	ldw	r2,0(r2)
 3242010:	10c00044 	addi	r3,r2,1
 3242014:	0080c9b4 	movhi	r2,806
 3242018:	10b47404 	addi	r2,r2,-11824
 324201c:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 3242020:	00bffd84 	movi	r2,-10
 3242024:	e0bfff15 	stw	r2,-4(fp)
 3242028:	00003f06 	br	3242128 <ip_reasm_delete_ire+0x1b0>
      }

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);
 324202c:	e0bffe17 	ldw	r2,-8(fp)
 3242030:	10800604 	addi	r2,r2,24
 3242034:	e0bffc15 	stw	r2,-16(fp)
 3242038:	e0bffc17 	ldw	r2,-16(fp)
 324203c:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 3242040:	00003106 	br	3242108 <ip_reasm_delete_ire+0x190>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 3242044:	e03ffa0d 	sth	zero,-24(fp)
 3242048:	00002006 	br	32420cc <ip_reasm_delete_ire+0x154>
         {
         if ((p = rfqp->bufp [i]) != 0)
 324204c:	e0bffa0b 	ldhu	r2,-24(fp)
 3242050:	e0fffd17 	ldw	r3,-12(fp)
 3242054:	1085883a 	add	r2,r2,r2
 3242058:	1085883a 	add	r2,r2,r2
 324205c:	10c5883a 	add	r2,r2,r3
 3242060:	10800104 	addi	r2,r2,4
 3242064:	10800017 	ldw	r2,0(r2)
 3242068:	e0bff915 	stw	r2,-28(fp)
 324206c:	e0bff917 	ldw	r2,-28(fp)
 3242070:	1005003a 	cmpeq	r2,r2,zero
 3242074:	10000b1e 	bne	r2,zero,32420a4 <ip_reasm_delete_ire+0x12c>
            {
            ip_reasm_decr_mem_useage (p->nb_blen);
 3242078:	e0bff917 	ldw	r2,-28(fp)
 324207c:	10800217 	ldw	r2,8(r2)
 3242080:	113fffcc 	andi	r4,r2,65535
 3242084:	3240b900 	call	3240b90 <ip_reasm_decr_mem_useage>
            LOCK_NET_RESOURCE (FREEQ_RESID);
 3242088:	01000084 	movi	r4,2
 324208c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
            pk_free (p);
 3242090:	e13ff917 	ldw	r4,-28(fp)
 3242094:	322a2dc0 	call	322a2dc <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);               
 3242098:	01000084 	movi	r4,2
 324209c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
 32420a0:	00000706 	br	32420c0 <ip_reasm_delete_ire+0x148>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 32420a4:	e0bffe17 	ldw	r2,-8(fp)
 32420a8:	10802103 	ldbu	r2,132(r2)
 32420ac:	10803fcc 	andi	r2,r2,255
 32420b0:	1080004c 	andi	r2,r2,1
 32420b4:	10803fcc 	andi	r2,r2,255
 32420b8:	1004c03a 	cmpne	r2,r2,zero
 32420bc:	1000061e 	bne	r2,zero,32420d8 <ip_reasm_delete_ire+0x160>
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 32420c0:	e0bffa0b 	ldhu	r2,-24(fp)
 32420c4:	10800044 	addi	r2,r2,1
 32420c8:	e0bffa0d 	sth	r2,-24(fp)
 32420cc:	e0bffa0b 	ldhu	r2,-24(fp)
 32420d0:	10800430 	cmpltui	r2,r2,16
 32420d4:	103fdd1e 	bne	r2,zero,324204c <ip_reasm_delete_ire+0xd4>
               break;
               }
            }
          }

       prev_rfqp = rfqp;
 32420d8:	e0bffd17 	ldw	r2,-12(fp)
 32420dc:	e0bffb15 	stw	r2,-20(fp)
       rfqp = rfqp->next;
 32420e0:	e0bffd17 	ldw	r2,-12(fp)
 32420e4:	10800017 	ldw	r2,0(r2)
 32420e8:	e0bffd15 	stw	r2,-12(fp)
       /* the first RFQ is statically allocated, and cannot be freed */
       if (prev_rfqp != first_rfqp)
 32420ec:	e0fffb17 	ldw	r3,-20(fp)
 32420f0:	e0bffc17 	ldw	r2,-16(fp)
 32420f4:	18800426 	beq	r3,r2,3242108 <ip_reasm_delete_ire+0x190>
          {
          ip_reasm_decr_mem_useage (sizeof(RFQ));
 32420f8:	01001904 	movi	r4,100
 32420fc:	3240b900 	call	3240b90 <ip_reasm_decr_mem_useage>
          IPR_FREE (prev_rfqp);
 3242100:	e13ffb17 	ldw	r4,-20(fp)
 3242104:	322b6c40 	call	322b6c4 <npfree>

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
 3242108:	e0bffd17 	ldw	r2,-12(fp)
 324210c:	1004c03a 	cmpne	r2,r2,zero
 3242110:	103fcc1e 	bne	r2,zero,3242044 <ip_reasm_delete_ire+0xcc>
          IPR_FREE (prev_rfqp);
          }
      }

   /* now free the parent entity */
   ip_reasm_decr_mem_useage (sizeof(IRE));
 3242114:	01002204 	movi	r4,136
 3242118:	3240b900 	call	3240b90 <ip_reasm_decr_mem_useage>
   IPR_FREE (irep);
 324211c:	e13ffe17 	ldw	r4,-8(fp)
 3242120:	322b6c40 	call	322b6c4 <npfree>

   return IPREASM_OK;
 3242124:	e03fff15 	stw	zero,-4(fp)
 3242128:	e0bfff17 	ldw	r2,-4(fp)
}
 324212c:	e037883a 	mov	sp,fp
 3242130:	dfc00117 	ldw	ra,4(sp)
 3242134:	df000017 	ldw	fp,0(sp)
 3242138:	dec00204 	addi	sp,sp,8
 324213c:	f800283a 	ret

03242140 <ip_reasm_mark_compact_rfq>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in 
the master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_mark_compact_rfq (IREP irep)
{
 3242140:	defffa04 	addi	sp,sp,-24
 3242144:	dfc00515 	stw	ra,20(sp)
 3242148:	df000415 	stw	fp,16(sp)
 324214c:	df000404 	addi	fp,sp,16
 3242150:	e13ffe15 	stw	r4,-8(fp)
   RFQP rfqp;
   u_short i;
   u_char empty_slot_discovered = IPREASM_FALSE;
 3242154:	e03ffc45 	stb	zero,-15(fp)
   u_char compact = IPREASM_TRUE;
 3242158:	00800044 	movi	r2,1
 324215c:	e0bffc05 	stb	r2,-16(fp)

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 3242160:	e13ffe17 	ldw	r4,-8(fp)
 3242164:	3241ad40 	call	3241ad4 <ip_reasm_find_ire>
 3242168:	10803fcc 	andi	r2,r2,255
 324216c:	10800060 	cmpeqi	r2,r2,1
 3242170:	10000a1e 	bne	r2,zero,324219c <ip_reasm_mark_compact_rfq+0x5c>
   {
      ++ire_stats.bad_irep;
 3242174:	0080c9b4 	movhi	r2,806
 3242178:	10b47404 	addi	r2,r2,-11824
 324217c:	10800017 	ldw	r2,0(r2)
 3242180:	10c00044 	addi	r3,r2,1
 3242184:	0080c9b4 	movhi	r2,806
 3242188:	10b47404 	addi	r2,r2,-11824
 324218c:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 3242190:	00bffd84 	movi	r2,-10
 3242194:	e0bfff15 	stw	r2,-4(fp)
 3242198:	00003506 	br	3242270 <ip_reasm_mark_compact_rfq+0x130>
   }

   rfqp = &(irep->rfq);
 324219c:	e0bffe17 	ldw	r2,-8(fp)
 32421a0:	10800604 	addi	r2,r2,24
 32421a4:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 32421a8:	00001c06 	br	324221c <ip_reasm_mark_compact_rfq+0xdc>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 32421ac:	e03ffc8d 	sth	zero,-14(fp)
 32421b0:	00001406 	br	3242204 <ip_reasm_mark_compact_rfq+0xc4>
         {
         if (rfqp->bufp [i] == 0)
 32421b4:	e0bffc8b 	ldhu	r2,-14(fp)
 32421b8:	e0fffd17 	ldw	r3,-12(fp)
 32421bc:	1085883a 	add	r2,r2,r2
 32421c0:	1085883a 	add	r2,r2,r2
 32421c4:	10c5883a 	add	r2,r2,r3
 32421c8:	10800104 	addi	r2,r2,4
 32421cc:	10800017 	ldw	r2,0(r2)
 32421d0:	1004c03a 	cmpne	r2,r2,zero
 32421d4:	1000031e 	bne	r2,zero,32421e4 <ip_reasm_mark_compact_rfq+0xa4>
            {            
            empty_slot_discovered = IPREASM_TRUE;
 32421d8:	00800044 	movi	r2,1
 32421dc:	e0bffc45 	stb	r2,-15(fp)
 32421e0:	00000506 	br	32421f8 <ip_reasm_mark_compact_rfq+0xb8>
            }
         else
            {
            if (empty_slot_discovered) 
 32421e4:	e0bffc43 	ldbu	r2,-15(fp)
 32421e8:	1005003a 	cmpeq	r2,r2,zero
 32421ec:	1000021e 	bne	r2,zero,32421f8 <ip_reasm_mark_compact_rfq+0xb8>
               {
               compact = IPREASM_FALSE;
 32421f0:	e03ffc05 	stb	zero,-16(fp)
               break;
 32421f4:	00000606 	br	3242210 <ip_reasm_mark_compact_rfq+0xd0>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 32421f8:	e0bffc8b 	ldhu	r2,-14(fp)
 32421fc:	10800044 	addi	r2,r2,1
 3242200:	e0bffc8d 	sth	r2,-14(fp)
 3242204:	e0bffc8b 	ldhu	r2,-14(fp)
 3242208:	10800430 	cmpltui	r2,r2,16
 324220c:	103fe91e 	bne	r2,zero,32421b4 <ip_reasm_mark_compact_rfq+0x74>
               compact = IPREASM_FALSE;
               break;
               }
            }
          }
       rfqp = rfqp->next;
 3242210:	e0bffd17 	ldw	r2,-12(fp)
 3242214:	10800017 	ldw	r2,0(r2)
 3242218:	e0bffd15 	stw	r2,-12(fp)
      return ENP_PARAM;
   }

   rfqp = &(irep->rfq);

   while (rfqp)
 324221c:	e0bffd17 	ldw	r2,-12(fp)
 3242220:	1004c03a 	cmpne	r2,r2,zero
 3242224:	103fe11e 	bne	r2,zero,32421ac <ip_reasm_mark_compact_rfq+0x6c>
            }
          }
       rfqp = rfqp->next;
      }

   if (compact) 
 3242228:	e0bffc03 	ldbu	r2,-16(fp)
 324222c:	1005003a 	cmpeq	r2,r2,zero
 3242230:	1000071e 	bne	r2,zero,3242250 <ip_reasm_mark_compact_rfq+0x110>
      {
      irep->flags |= IPR_RFQ_COMPACT;
 3242234:	e0bffe17 	ldw	r2,-8(fp)
 3242238:	10802103 	ldbu	r2,132(r2)
 324223c:	10800054 	ori	r2,r2,1
 3242240:	1007883a 	mov	r3,r2
 3242244:	e0bffe17 	ldw	r2,-8(fp)
 3242248:	10c02105 	stb	r3,132(r2)
 324224c:	00000706 	br	324226c <ip_reasm_mark_compact_rfq+0x12c>
      }
   else 
      {
      irep->flags &= ~IPR_RFQ_COMPACT;
 3242250:	e0bffe17 	ldw	r2,-8(fp)
 3242254:	10c02103 	ldbu	r3,132(r2)
 3242258:	00bfff84 	movi	r2,-2
 324225c:	1884703a 	and	r2,r3,r2
 3242260:	1007883a 	mov	r3,r2
 3242264:	e0bffe17 	ldw	r2,-8(fp)
 3242268:	10c02105 	stb	r3,132(r2)
      }

   return IPREASM_OK;
 324226c:	e03fff15 	stw	zero,-4(fp)
 3242270:	e0bfff17 	ldw	r2,-4(fp)
}
 3242274:	e037883a 	mov	sp,fp
 3242278:	dfc00117 	ldw	ra,4(sp)
 324227c:	df000017 	ldw	fp,0(sp)
 3242280:	dec00204 	addi	sp,sp,8
 3242284:	f800283a 	ret

03242288 <ipr_stats>:

OUTPUT: This function always returns IPREASM_OK.
*/

int ipr_stats(void * pio)
{
 3242288:	deffec04 	addi	sp,sp,-80
 324228c:	dfc01315 	stw	ra,76(sp)
 3242290:	df001215 	stw	fp,72(sp)
 3242294:	dc001115 	stw	r16,68(sp)
 3242298:	df001104 	addi	fp,sp,68
 324229c:	e13fff15 	stw	r4,-4(fp)
   unsigned long ticks_elapsed = cticks;
 32422a0:	0080c974 	movhi	r2,805
 32422a4:	10925604 	addi	r2,r2,18776
 32422a8:	10800017 	ldw	r2,0(r2)
 32422ac:	e0bffe15 	stw	r2,-8(fp)
   u_short size_ire = sizeof(IRE);
 32422b0:	00802204 	movi	r2,136
 32422b4:	e0bffd8d 	sth	r2,-10(fp)
   u_short size_rfq = sizeof(RFQ);
 32422b8:	00801904 	movi	r2,100
 32422bc:	e0bffd0d 	sth	r2,-12(fp)
   IREP tmpp;
   u_short count = 0;
 32422c0:	e03ffb0d 	sth	zero,-20(fp)
   RFQP rfqp;
   u_short frag_count = 0;
 32422c4:	e03ff98d 	sth	zero,-26(fp)
   u_short i;

   ns_printf(pio,"IP reassembly statistics:\n");
 32422c8:	e13fff17 	ldw	r4,-4(fp)
 32422cc:	0140c974 	movhi	r5,805
 32422d0:	297ea404 	addi	r5,r5,-1392
 32422d4:	32260180 	call	3226018 <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
 32422d8:	d428fe17 	ldw	r16,-23560(gp)
 32422dc:	e13ffe17 	ldw	r4,-8(fp)
 32422e0:	0140fa04 	movi	r5,1000
 32422e4:	32044bc0 	call	32044bc <__udivsi3>
 32422e8:	e0fffd8b 	ldhu	r3,-10(fp)
 32422ec:	e13ffd0b 	ldhu	r4,-12(fp)
 32422f0:	d8800015 	stw	r2,0(sp)
 32422f4:	d8c00115 	stw	r3,4(sp)
 32422f8:	d9000215 	stw	r4,8(sp)
 32422fc:	e13fff17 	ldw	r4,-4(fp)
 3242300:	0140c974 	movhi	r5,805
 3242304:	297eab04 	addi	r5,r5,-1364
 3242308:	800d883a 	mov	r6,r16
 324230c:	e1fffe17 	ldw	r7,-8(fp)
 3242310:	32260180 	call	3226018 <ns_printf>
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
 3242314:	0080c9b4 	movhi	r2,806
 3242318:	10b47404 	addi	r2,r2,-11824
 324231c:	11800117 	ldw	r6,4(r2)
 3242320:	0080c9b4 	movhi	r2,806
 3242324:	10b47404 	addi	r2,r2,-11824
 3242328:	11c00017 	ldw	r7,0(r2)
 324232c:	0080c9b4 	movhi	r2,806
 3242330:	10b47404 	addi	r2,r2,-11824
 3242334:	11000217 	ldw	r4,8(r2)
 3242338:	0080c9b4 	movhi	r2,806
 324233c:	10b47404 	addi	r2,r2,-11824
 3242340:	11400317 	ldw	r5,12(r2)
 3242344:	0080c9b4 	movhi	r2,806
 3242348:	10b47404 	addi	r2,r2,-11824
 324234c:	10c00417 	ldw	r3,16(r2)
 3242350:	0080c9b4 	movhi	r2,806
 3242354:	10b47404 	addi	r2,r2,-11824
 3242358:	10800517 	ldw	r2,20(r2)
 324235c:	d9000015 	stw	r4,0(sp)
 3242360:	d9400115 	stw	r5,4(sp)
 3242364:	d8c00215 	stw	r3,8(sp)
 3242368:	d8800315 	stw	r2,12(sp)
 324236c:	e13fff17 	ldw	r4,-4(fp)
 3242370:	0140c974 	movhi	r5,805
 3242374:	297ebb04 	addi	r5,r5,-1300
 3242378:	32260180 	call	3226018 <ns_printf>
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
 324237c:	d1a8ff17 	ldw	r6,-23556(gp)
 3242380:	e13fff17 	ldw	r4,-4(fp)
 3242384:	0140c974 	movhi	r5,805
 3242388:	297ed004 	addi	r5,r5,-1216
 324238c:	32260180 	call	3226018 <ns_printf>
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 3242390:	d0a8ff17 	ldw	r2,-23556(gp)
 3242394:	e0bffc15 	stw	r2,-16(fp)
 3242398:	00008106 	br	32425a0 <ipr_stats+0x318>
      {
      ++count;
 324239c:	e0bffb0b 	ldhu	r2,-20(fp)
 32423a0:	10800044 	addi	r2,r2,1
 32423a4:	e0bffb0d 	sth	r2,-20(fp)
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
 32423a8:	e0bffc17 	ldw	r2,-16(fp)
 32423ac:	10800604 	addi	r2,r2,24
 32423b0:	e0bffa15 	stw	r2,-24(fp)
      while (rfqp)
 32423b4:	00001f06 	br	3242434 <ipr_stats+0x1ac>
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 32423b8:	e03ff90d 	sth	zero,-28(fp)
 32423bc:	00001706 	br	324241c <ipr_stats+0x194>
            {
            if (rfqp->bufp [i] != 0)
 32423c0:	e0bff90b 	ldhu	r2,-28(fp)
 32423c4:	e0fffa17 	ldw	r3,-24(fp)
 32423c8:	1085883a 	add	r2,r2,r2
 32423cc:	1085883a 	add	r2,r2,r2
 32423d0:	10c5883a 	add	r2,r2,r3
 32423d4:	10800104 	addi	r2,r2,4
 32423d8:	10800017 	ldw	r2,0(r2)
 32423dc:	1005003a 	cmpeq	r2,r2,zero
 32423e0:	1000041e 	bne	r2,zero,32423f4 <ipr_stats+0x16c>
               {
               ++frag_count;            
 32423e4:	e0bff98b 	ldhu	r2,-26(fp)
 32423e8:	10800044 	addi	r2,r2,1
 32423ec:	e0bff98d 	sth	r2,-26(fp)
 32423f0:	00000706 	br	3242410 <ipr_stats+0x188>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
 32423f4:	e0bffc17 	ldw	r2,-16(fp)
 32423f8:	10802103 	ldbu	r2,132(r2)
 32423fc:	10803fcc 	andi	r2,r2,255
 3242400:	1080004c 	andi	r2,r2,1
 3242404:	10803fcc 	andi	r2,r2,255
 3242408:	1004c03a 	cmpne	r2,r2,zero
 324240c:	1000061e 	bne	r2,zero,3242428 <ipr_stats+0x1a0>
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 3242410:	e0bff90b 	ldhu	r2,-28(fp)
 3242414:	10800044 	addi	r2,r2,1
 3242418:	e0bff90d 	sth	r2,-28(fp)
 324241c:	e0bff90b 	ldhu	r2,-28(fp)
 3242420:	10800430 	cmpltui	r2,r2,16
 3242424:	103fe61e 	bne	r2,zero,32423c0 <ipr_stats+0x138>
                  {
                  break;
                  }
               }
            }
         rfqp = rfqp->next;
 3242428:	e0bffa17 	ldw	r2,-24(fp)
 324242c:	10800017 	ldw	r2,0(r2)
 3242430:	e0bffa15 	stw	r2,-24(fp)
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
 3242434:	e0bffa17 	ldw	r2,-24(fp)
 3242438:	1004c03a 	cmpne	r2,r2,zero
 324243c:	103fde1e 	bne	r2,zero,32423b8 <ipr_stats+0x130>
                  }
               }
            }
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
 3242440:	e1fff98b 	ldhu	r7,-26(fp)
 3242444:	e0bffc17 	ldw	r2,-16(fp)
 3242448:	10800117 	ldw	r2,4(r2)
 324244c:	1004d63a 	srli	r2,r2,24
 3242450:	10c03fcc 	andi	r3,r2,255
 3242454:	e0bffc17 	ldw	r2,-16(fp)
 3242458:	10800117 	ldw	r2,4(r2)
 324245c:	1004d23a 	srli	r2,r2,8
 3242460:	10bfc00c 	andi	r2,r2,65280
 3242464:	1886b03a 	or	r3,r3,r2
 3242468:	e0bffc17 	ldw	r2,-16(fp)
 324246c:	10800117 	ldw	r2,4(r2)
 3242470:	10bfc00c 	andi	r2,r2,65280
 3242474:	1004923a 	slli	r2,r2,8
 3242478:	1886b03a 	or	r3,r3,r2
 324247c:	e0bffc17 	ldw	r2,-16(fp)
 3242480:	10800117 	ldw	r2,4(r2)
 3242484:	10803fcc 	andi	r2,r2,255
 3242488:	1004963a 	slli	r2,r2,24
 324248c:	1888b03a 	or	r4,r3,r2
 3242490:	e0bffc17 	ldw	r2,-16(fp)
 3242494:	10800217 	ldw	r2,8(r2)
 3242498:	1004d63a 	srli	r2,r2,24
 324249c:	10c03fcc 	andi	r3,r2,255
 32424a0:	e0bffc17 	ldw	r2,-16(fp)
 32424a4:	10800217 	ldw	r2,8(r2)
 32424a8:	1004d23a 	srli	r2,r2,8
 32424ac:	10bfc00c 	andi	r2,r2,65280
 32424b0:	1886b03a 	or	r3,r3,r2
 32424b4:	e0bffc17 	ldw	r2,-16(fp)
 32424b8:	10800217 	ldw	r2,8(r2)
 32424bc:	10bfc00c 	andi	r2,r2,65280
 32424c0:	1004923a 	slli	r2,r2,8
 32424c4:	1886b03a 	or	r3,r3,r2
 32424c8:	e0bffc17 	ldw	r2,-16(fp)
 32424cc:	10800217 	ldw	r2,8(r2)
 32424d0:	10803fcc 	andi	r2,r2,255
 32424d4:	1004963a 	slli	r2,r2,24
 32424d8:	188ab03a 	or	r5,r3,r2
 32424dc:	e0bffc17 	ldw	r2,-16(fp)
 32424e0:	10800383 	ldbu	r2,14(r2)
 32424e4:	11803fcc 	andi	r6,r2,255
 32424e8:	e0bffc17 	ldw	r2,-16(fp)
 32424ec:	1080030b 	ldhu	r2,12(r2)
 32424f0:	10bfffcc 	andi	r2,r2,65535
 32424f4:	1004d23a 	srli	r2,r2,8
 32424f8:	10bfffcc 	andi	r2,r2,65535
 32424fc:	10c03fcc 	andi	r3,r2,255
 3242500:	e0bffc17 	ldw	r2,-16(fp)
 3242504:	1080030b 	ldhu	r2,12(r2)
 3242508:	10bfffcc 	andi	r2,r2,65535
 324250c:	1004923a 	slli	r2,r2,8
 3242510:	10bfc00c 	andi	r2,r2,65280
 3242514:	1886b03a 	or	r3,r3,r2
 3242518:	e0bffc17 	ldw	r2,-16(fp)
 324251c:	1080040b 	ldhu	r2,16(r2)
 3242520:	123fffcc 	andi	r8,r2,65535
 3242524:	e0bffc17 	ldw	r2,-16(fp)
 3242528:	1080048b 	ldhu	r2,18(r2)
 324252c:	127fffcc 	andi	r9,r2,65535
 3242530:	e0bffc17 	ldw	r2,-16(fp)
 3242534:	12800517 	ldw	r10,20(r2)
 3242538:	e0bffc17 	ldw	r2,-16(fp)
 324253c:	12c01f17 	ldw	r11,124(r2)
 3242540:	e0bffc17 	ldw	r2,-16(fp)
 3242544:	13002017 	ldw	r12,128(r2)
 3242548:	e0bffc17 	ldw	r2,-16(fp)
 324254c:	10802103 	ldbu	r2,132(r2)
 3242550:	10803fcc 	andi	r2,r2,255
 3242554:	1080004c 	andi	r2,r2,1
 3242558:	d9000015 	stw	r4,0(sp)
 324255c:	d9400115 	stw	r5,4(sp)
 3242560:	d9800215 	stw	r6,8(sp)
 3242564:	d8c00315 	stw	r3,12(sp)
 3242568:	da000415 	stw	r8,16(sp)
 324256c:	da400515 	stw	r9,20(sp)
 3242570:	da800615 	stw	r10,24(sp)
 3242574:	dac00715 	stw	r11,28(sp)
 3242578:	db000815 	stw	r12,32(sp)
 324257c:	d8800915 	stw	r2,36(sp)
 3242580:	e13fff17 	ldw	r4,-4(fp)
 3242584:	0140c974 	movhi	r5,805
 3242588:	297ed604 	addi	r5,r5,-1192
 324258c:	e1bffc17 	ldw	r6,-16(fp)
 3242590:	32260180 	call	3226018 <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 3242594:	e0bffc17 	ldw	r2,-16(fp)
 3242598:	10800017 	ldw	r2,0(r2)
 324259c:	e0bffc15 	stw	r2,-16(fp)
 32425a0:	e0bffc17 	ldw	r2,-16(fp)
 32425a4:	1004c03a 	cmpne	r2,r2,zero
 32425a8:	103f7c1e 	bne	r2,zero,324239c <ipr_stats+0x114>
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
      } /* end FOR (IRE linked list) */

   ns_printf(pio,"Found a total of %u IRE entries\n",count);
 32425ac:	e1bffb0b 	ldhu	r6,-20(fp)
 32425b0:	e13fff17 	ldw	r4,-4(fp)
 32425b4:	0140c974 	movhi	r5,805
 32425b8:	297ef104 	addi	r5,r5,-1084
 32425bc:	32260180 	call	3226018 <ns_printf>

   return IPREASM_OK;
 32425c0:	0005883a 	mov	r2,zero
}
 32425c4:	e037883a 	mov	sp,fp
 32425c8:	dfc00217 	ldw	ra,8(sp)
 32425cc:	df000117 	ldw	fp,4(sp)
 32425d0:	dc000017 	ldw	r16,0(sp)
 32425d4:	dec00304 	addi	sp,sp,12
 32425d8:	f800283a 	ret

032425dc <ip_reasm_send_icmp_timex>:
OUTPUT: This function always returns IPREASM_OK.
*/

#ifdef FULL_ICMP
u_long ip_reasm_send_icmp_timex (IREP irep)
{
 32425dc:	defffc04 	addi	sp,sp,-16
 32425e0:	dfc00315 	stw	ra,12(sp)
 32425e4:	df000215 	stw	fp,8(sp)
 32425e8:	df000204 	addi	fp,sp,8
 32425ec:	e13fff15 	stw	r4,-4(fp)

   /* we can only send an ICMP Time Exceeded message with code 1 ("fragment reassembly 
    * time exceeded") if we have received the First Fragment (FF) of the original, 
    * unfragmented datagram.  This is indicated by a non-zero value for the l2_hdr and
    * l3_hdr fields in the IRE data structure. */
   if (irep->l2_hdr)
 32425f0:	e0bfff17 	ldw	r2,-4(fp)
 32425f4:	10801f17 	ldw	r2,124(r2)
 32425f8:	1005003a 	cmpeq	r2,r2,zero
 32425fc:	1000061e 	bne	r2,zero,3242618 <ip_reasm_send_icmp_timex+0x3c>
      {
      pip = (struct ip *) irep->l3_hdr;
 3242600:	e0bfff17 	ldw	r2,-4(fp)
 3242604:	10802017 	ldw	r2,128(r2)
 3242608:	e0bffe15 	stw	r2,-8(fp)
      icmp_timex (pip, TIMEX_REASSY_FAILED);
 324260c:	e13ffe17 	ldw	r4,-8(fp)
 3242610:	01400044 	movi	r5,1
 3242614:	324b52c0 	call	324b52c <icmp_timex>
      }

   return IPREASM_OK;
 3242618:	0005883a 	mov	r2,zero
}
 324261c:	e037883a 	mov	sp,fp
 3242620:	dfc00117 	ldw	ra,4(sp)
 3242624:	df000017 	ldw	fp,0(sp)
 3242628:	dec00204 	addi	sp,sp,8
 324262c:	f800283a 	ret

03242630 <ip_rcv>:
 * RETURNS: 
 */

int
ip_rcv(PACKET p)
{
 3242630:	defff204 	addi	sp,sp,-56
 3242634:	dfc00d15 	stw	ra,52(sp)
 3242638:	df000c15 	stw	fp,48(sp)
 324263c:	dc000b15 	stw	r16,44(sp)
 3242640:	df000b04 	addi	fp,sp,44
 3242644:	e13ffe15 	stw	r4,-8(fp)
   unsigned hdrlen;  /* length of IP header including options */
   unsigned len;     /* total length including IP header */
   unsigned short int num_pkts;
   PACKET * pktp;
   unsigned char i;
   int rcvrc = -1;
 3242648:	00bfffc4 	movi	r2,-1
 324264c:	e0bff515 	stw	r2,-44(fp)
   unsigned char rc_ret;
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 3242650:	0080c974 	movhi	r2,805
 3242654:	10923104 	addi	r2,r2,18628
 3242658:	10800017 	ldw	r2,0(r2)
 324265c:	1081000c 	andi	r2,r2,1024
 3242660:	1005003a 	cmpeq	r2,r2,zero
 3242664:	1000101e 	bne	r2,zero,32426a8 <ip_rcv+0x78>
 3242668:	0080c974 	movhi	r2,805
 324266c:	10923104 	addi	r2,r2,18628
 3242670:	10800017 	ldw	r2,0(r2)
 3242674:	1080800c 	andi	r2,r2,512
 3242678:	1005003a 	cmpeq	r2,r2,zero
 324267c:	10000a1e 	bne	r2,zero,32426a8 <ip_rcv+0x78>
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 3242680:	e0bffe17 	ldw	r2,-8(fp)
 3242684:	14000417 	ldw	r16,16(r2)
 3242688:	e0bffe17 	ldw	r2,-8(fp)
 324268c:	11000617 	ldw	r4,24(r2)
 3242690:	3223d580 	call	3223d58 <if_netnumber>
 3242694:	100d883a 	mov	r6,r2
 3242698:	0100c974 	movhi	r4,805
 324269c:	213efa04 	addi	r4,r4,-1048
 32426a0:	800b883a 	mov	r5,r16
 32426a4:	3206adc0 	call	3206adc <printf>
         p->nb_plen, net_num(p->net));
#endif

   IN_PROFILER(PF_IP, PF_ENTRY);

   nt = p->net;      /* which interface it came in on */
 32426a8:	e0bffe17 	ldw	r2,-8(fp)
 32426ac:	10800617 	ldw	r2,24(r2)
 32426b0:	e0bffb15 	stw	r2,-20(fp)
   ip_mib.ipInReceives++;
 32426b4:	0080c9b4 	movhi	r2,806
 32426b8:	10b46004 	addi	r2,r2,-11904
 32426bc:	10800217 	ldw	r2,8(r2)
 32426c0:	10c00044 	addi	r3,r2,1
 32426c4:	0080c9b4 	movhi	r2,806
 32426c8:	10b46004 	addi	r2,r2,-11904
 32426cc:	10c00215 	stw	r3,8(r2)
   pip = ip_head(p);
 32426d0:	e0bffe17 	ldw	r2,-8(fp)
 32426d4:	10800317 	ldw	r2,12(r2)
 32426d8:	e0bffd15 	stw	r2,-12(fp)

   /* test received MAC len against IP header len */
   if (p->nb_plen < (unsigned)htons(pip->ip_len))
 32426dc:	e0bffe17 	ldw	r2,-8(fp)
 32426e0:	11000417 	ldw	r4,16(r2)
 32426e4:	e0bffd17 	ldw	r2,-12(fp)
 32426e8:	1080008b 	ldhu	r2,2(r2)
 32426ec:	10bfffcc 	andi	r2,r2,65535
 32426f0:	1004d23a 	srli	r2,r2,8
 32426f4:	10bfffcc 	andi	r2,r2,65535
 32426f8:	10c03fcc 	andi	r3,r2,255
 32426fc:	e0bffd17 	ldw	r2,-12(fp)
 3242700:	1080008b 	ldhu	r2,2(r2)
 3242704:	10bfffcc 	andi	r2,r2,65535
 3242708:	1004923a 	slli	r2,r2,8
 324270c:	10bfc00c 	andi	r2,r2,65280
 3242710:	1884b03a 	or	r2,r3,r2
 3242714:	2080272e 	bgeu	r4,r2,32427b4 <ip_rcv+0x184>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 3242718:	0080c974 	movhi	r2,805
 324271c:	10923104 	addi	r2,r2,18628
 3242720:	10800017 	ldw	r2,0(r2)
 3242724:	1081000c 	andi	r2,r2,1024
 3242728:	1005003a 	cmpeq	r2,r2,zero
 324272c:	1000111e 	bne	r2,zero,3242774 <ip_rcv+0x144>
 3242730:	0080c974 	movhi	r2,805
 3242734:	10923104 	addi	r2,r2,18628
 3242738:	10800017 	ldw	r2,0(r2)
 324273c:	1080800c 	andi	r2,r2,512
 3242740:	1005003a 	cmpeq	r2,r2,zero
 3242744:	10000b1e 	bne	r2,zero,3242774 <ip_rcv+0x144>
      {
         dprintf("ip_rcv: bad pkt len\n");
 3242748:	0100c974 	movhi	r4,805
 324274c:	213f0304 	addi	r4,r4,-1012
 3242750:	3206e040 	call	3206e04 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 3242754:	0080c974 	movhi	r2,805
 3242758:	10923104 	addi	r2,r2,18628
 324275c:	10800017 	ldw	r2,0(r2)
 3242760:	1080008c 	andi	r2,r2,2
 3242764:	1005003a 	cmpeq	r2,r2,zero
 3242768:	1000021e 	bne	r2,zero,3242774 <ip_rcv+0x144>
 324276c:	e13ffe17 	ldw	r4,-8(fp)
 3242770:	32402380 	call	3240238 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 3242774:	0080c9b4 	movhi	r2,806
 3242778:	10b46004 	addi	r2,r2,-11904
 324277c:	10800317 	ldw	r2,12(r2)
 3242780:	10c00044 	addi	r3,r2,1
 3242784:	0080c9b4 	movhi	r2,806
 3242788:	10b46004 	addi	r2,r2,-11904
 324278c:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 3242790:	01000084 	movi	r4,2
 3242794:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(p);
 3242798:	e13ffe17 	ldw	r4,-8(fp)
 324279c:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32427a0:	01000084 	movi	r4,2
 32427a4:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 32427a8:	00bff804 	movi	r2,-32
 32427ac:	e0bfff15 	stw	r2,-4(fp)
 32427b0:	00009806 	br	3242a14 <ip_rcv+0x3e4>
   }

   /* use length from IP header; MAC value may be padded */
   len = htons(pip->ip_len);
 32427b4:	e0bffd17 	ldw	r2,-12(fp)
 32427b8:	1080008b 	ldhu	r2,2(r2)
 32427bc:	10bfffcc 	andi	r2,r2,65535
 32427c0:	1004d23a 	srli	r2,r2,8
 32427c4:	10bfffcc 	andi	r2,r2,65535
 32427c8:	10c03fcc 	andi	r3,r2,255
 32427cc:	e0bffd17 	ldw	r2,-12(fp)
 32427d0:	1080008b 	ldhu	r2,2(r2)
 32427d4:	10bfffcc 	andi	r2,r2,65535
 32427d8:	1004923a 	slli	r2,r2,8
 32427dc:	10bfc00c 	andi	r2,r2,65280
 32427e0:	1884b03a 	or	r2,r3,r2
 32427e4:	e0bff915 	stw	r2,-28(fp)
   p->nb_plen = len;       /* fix pkt len */
 32427e8:	e0fffe17 	ldw	r3,-8(fp)
 32427ec:	e0bff917 	ldw	r2,-28(fp)
 32427f0:	18800415 	stw	r2,16(r3)

   if ( ((pip->ip_ver_ihl & 0xf0) >> 4) != IP_VER)
 32427f4:	e0bffd17 	ldw	r2,-12(fp)
 32427f8:	10800003 	ldbu	r2,0(r2)
 32427fc:	10803fcc 	andi	r2,r2,255
 3242800:	10803c0c 	andi	r2,r2,240
 3242804:	1005d13a 	srai	r2,r2,4
 3242808:	10800120 	cmpeqi	r2,r2,4
 324280c:	1000271e 	bne	r2,zero,32428ac <ip_rcv+0x27c>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 3242810:	0080c974 	movhi	r2,805
 3242814:	10923104 	addi	r2,r2,18628
 3242818:	10800017 	ldw	r2,0(r2)
 324281c:	1081000c 	andi	r2,r2,1024
 3242820:	1005003a 	cmpeq	r2,r2,zero
 3242824:	1000111e 	bne	r2,zero,324286c <ip_rcv+0x23c>
 3242828:	0080c974 	movhi	r2,805
 324282c:	10923104 	addi	r2,r2,18628
 3242830:	10800017 	ldw	r2,0(r2)
 3242834:	1080800c 	andi	r2,r2,512
 3242838:	1005003a 	cmpeq	r2,r2,zero
 324283c:	10000b1e 	bne	r2,zero,324286c <ip_rcv+0x23c>
      {
         dprintf("ip_rcv: bad version number\n");
 3242840:	0100c974 	movhi	r4,805
 3242844:	213f0804 	addi	r4,r4,-992
 3242848:	3206e040 	call	3206e04 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 324284c:	0080c974 	movhi	r2,805
 3242850:	10923104 	addi	r2,r2,18628
 3242854:	10800017 	ldw	r2,0(r2)
 3242858:	1080008c 	andi	r2,r2,2
 324285c:	1005003a 	cmpeq	r2,r2,zero
 3242860:	1000021e 	bne	r2,zero,324286c <ip_rcv+0x23c>
 3242864:	e13ffe17 	ldw	r4,-8(fp)
 3242868:	32402380 	call	3240238 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 324286c:	0080c9b4 	movhi	r2,806
 3242870:	10b46004 	addi	r2,r2,-11904
 3242874:	10800317 	ldw	r2,12(r2)
 3242878:	10c00044 	addi	r3,r2,1
 324287c:	0080c9b4 	movhi	r2,806
 3242880:	10b46004 	addi	r2,r2,-11904
 3242884:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 3242888:	01000084 	movi	r4,2
 324288c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(p);
 3242890:	e13ffe17 	ldw	r4,-8(fp)
 3242894:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3242898:	01000084 	movi	r4,2
 324289c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 32428a0:	00bff804 	movi	r2,-32
 32428a4:	e0bfff15 	stw	r2,-4(fp)
 32428a8:	00005a06 	br	3242a14 <ip_rcv+0x3e4>
   }

   csum = pip->ip_chksum;
 32428ac:	e0bffd17 	ldw	r2,-12(fp)
 32428b0:	1080028b 	ldhu	r2,10(r2)
 32428b4:	e0bffc8d 	sth	r2,-14(fp)
   pip->ip_chksum = 0;
 32428b8:	e0bffd17 	ldw	r2,-12(fp)
 32428bc:	1000028d 	sth	zero,10(r2)
   hdrlen = ip_hlen(pip);
 32428c0:	e0bffd17 	ldw	r2,-12(fp)
 32428c4:	10800003 	ldbu	r2,0(r2)
 32428c8:	10803fcc 	andi	r2,r2,255
 32428cc:	108003cc 	andi	r2,r2,15
 32428d0:	1085883a 	add	r2,r2,r2
 32428d4:	1085883a 	add	r2,r2,r2
 32428d8:	e0bffa15 	stw	r2,-24(fp)
   tempsum = ~cksum(pip, hdrlen >> 1);
 32428dc:	e0bffa17 	ldw	r2,-24(fp)
 32428e0:	100ad07a 	srli	r5,r2,1
 32428e4:	e13ffd17 	ldw	r4,-12(fp)
 32428e8:	32259f80 	call	32259f8 <cksum>
 32428ec:	0084303a 	nor	r2,zero,r2
 32428f0:	e0bffc0d 	sth	r2,-16(fp)

   if (csum != tempsum)
 32428f4:	e0fffc8b 	ldhu	r3,-14(fp)
 32428f8:	e0bffc0b 	ldhu	r2,-16(fp)
 32428fc:	18802a26 	beq	r3,r2,32429a8 <ip_rcv+0x378>
   {
      pip->ip_chksum = csum;
 3242900:	e0fffd17 	ldw	r3,-12(fp)
 3242904:	e0bffc8b 	ldhu	r2,-14(fp)
 3242908:	1880028d 	sth	r2,10(r3)
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 324290c:	0080c974 	movhi	r2,805
 3242910:	10923104 	addi	r2,r2,18628
 3242914:	10800017 	ldw	r2,0(r2)
 3242918:	1081000c 	andi	r2,r2,1024
 324291c:	1005003a 	cmpeq	r2,r2,zero
 3242920:	1000111e 	bne	r2,zero,3242968 <ip_rcv+0x338>
 3242924:	0080c974 	movhi	r2,805
 3242928:	10923104 	addi	r2,r2,18628
 324292c:	10800017 	ldw	r2,0(r2)
 3242930:	1080800c 	andi	r2,r2,512
 3242934:	1005003a 	cmpeq	r2,r2,zero
 3242938:	10000b1e 	bne	r2,zero,3242968 <ip_rcv+0x338>
      {
         dprintf("ip_rcv: bad xsum\n");
 324293c:	0100c974 	movhi	r4,805
 3242940:	213f0f04 	addi	r4,r4,-964
 3242944:	3206e040 	call	3206e04 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 3242948:	0080c974 	movhi	r2,805
 324294c:	10923104 	addi	r2,r2,18628
 3242950:	10800017 	ldw	r2,0(r2)
 3242954:	1080008c 	andi	r2,r2,2
 3242958:	1005003a 	cmpeq	r2,r2,zero
 324295c:	1000021e 	bne	r2,zero,3242968 <ip_rcv+0x338>
 3242960:	e13ffe17 	ldw	r4,-8(fp)
 3242964:	32402380 	call	3240238 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 3242968:	0080c9b4 	movhi	r2,806
 324296c:	10b46004 	addi	r2,r2,-11904
 3242970:	10800317 	ldw	r2,12(r2)
 3242974:	10c00044 	addi	r3,r2,1
 3242978:	0080c9b4 	movhi	r2,806
 324297c:	10b46004 	addi	r2,r2,-11904
 3242980:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 3242984:	01000084 	movi	r4,2
 3242988:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(p);
 324298c:	e13ffe17 	ldw	r4,-8(fp)
 3242990:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3242994:	01000084 	movi	r4,2
 3242998:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 324299c:	00bff804 	movi	r2,-32
 32429a0:	e0bfff15 	stw	r2,-4(fp)
 32429a4:	00001b06 	br	3242a14 <ip_rcv+0x3e4>
   }

   pip->ip_chksum = csum;
 32429a8:	e0fffd17 	ldw	r3,-12(fp)
 32429ac:	e0bffc8b 	ldhu	r2,-14(fp)
 32429b0:	1880028d 	sth	r2,10(r3)
#endif

    /* start off by assuming that we will only process the "current" packet;
     * these values may get overwritten by the NAT module if it returns
     * more than one packet back to this function (ip_rcv ()) */
    num_pkts = 1;
 32429b4:	00800044 	movi	r2,1
 32429b8:	e0bff80d 	sth	r2,-32(fp)
    pktp = &p;
 32429bc:	e0bffe04 	addi	r2,fp,-8
 32429c0:	e0bff715 	stw	r2,-36(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 32429c4:	e03ff605 	stb	zero,-40(fp)
 32429c8:	00000c06 	br	32429fc <ip_rcv+0x3cc>
   {
      rcvrc = ip_rcv_phase2 (*(pktp + i));
 32429cc:	e0bff603 	ldbu	r2,-40(fp)
 32429d0:	1085883a 	add	r2,r2,r2
 32429d4:	1085883a 	add	r2,r2,r2
 32429d8:	1007883a 	mov	r3,r2
 32429dc:	e0bff717 	ldw	r2,-36(fp)
 32429e0:	1885883a 	add	r2,r3,r2
 32429e4:	11000017 	ldw	r4,0(r2)
 32429e8:	3242a300 	call	3242a30 <ip_rcv_phase2>
 32429ec:	e0bff515 	stw	r2,-44(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 32429f0:	e0bff603 	ldbu	r2,-40(fp)
 32429f4:	10800044 	addi	r2,r2,1
 32429f8:	e0bff605 	stb	r2,-40(fp)
 32429fc:	e0bff603 	ldbu	r2,-40(fp)
 3242a00:	10ffffcc 	andi	r3,r2,65535
 3242a04:	e0bff80b 	ldhu	r2,-32(fp)
 3242a08:	18bff036 	bltu	r3,r2,32429cc <ip_rcv+0x39c>
   if (pktp != &p) nat_free (pktp);
#endif /* NATRT */

   /* when multiple packets are processed in the loop above, the return code
    * contains the return code for the last packet */
   return rcvrc;
 3242a0c:	e0bff517 	ldw	r2,-44(fp)
 3242a10:	e0bfff15 	stw	r2,-4(fp)
 3242a14:	e0bfff17 	ldw	r2,-4(fp)
}
 3242a18:	e037883a 	mov	sp,fp
 3242a1c:	dfc00217 	ldw	ra,8(sp)
 3242a20:	df000117 	ldw	fp,4(sp)
 3242a24:	dc000017 	ldw	r16,0(sp)
 3242a28:	dec00304 	addi	sp,sp,12
 3242a2c:	f800283a 	ret

03242a30 <ip_rcv_phase2>:


int ip_rcv_phase2 (PACKET p)
{
 3242a30:	defff404 	addi	sp,sp,-48
 3242a34:	dfc00b15 	stw	ra,44(sp)
 3242a38:	df000a15 	stw	fp,40(sp)
 3242a3c:	df000a04 	addi	fp,sp,40
 3242a40:	e13ffe15 	stw	r4,-8(fp)

   struct ip * pip;     /* the internet header */
   NET nt;
   unsigned short tempsum;

   pip = ip_head(p);
 3242a44:	e0bffe17 	ldw	r2,-8(fp)
 3242a48:	10800317 	ldw	r2,12(r2)
 3242a4c:	e0bffc15 	stw	r2,-16(fp)
   nt = p->net;      /* which interface it came in on */
 3242a50:	e0bffe17 	ldw	r2,-8(fp)
 3242a54:	10800617 	ldw	r2,24(r2)
 3242a58:	e0bffb15 	stw	r2,-20(fp)

#ifdef IP_MULTICAST

   if (IN_MULTICAST(ntohl(pip->ip_dest))) 
 3242a5c:	e0bffc17 	ldw	r2,-16(fp)
 3242a60:	10800417 	ldw	r2,16(r2)
 3242a64:	1004d63a 	srli	r2,r2,24
 3242a68:	10c03fcc 	andi	r3,r2,255
 3242a6c:	e0bffc17 	ldw	r2,-16(fp)
 3242a70:	10800417 	ldw	r2,16(r2)
 3242a74:	1004d23a 	srli	r2,r2,8
 3242a78:	10bfc00c 	andi	r2,r2,65280
 3242a7c:	1886b03a 	or	r3,r3,r2
 3242a80:	e0bffc17 	ldw	r2,-16(fp)
 3242a84:	10800417 	ldw	r2,16(r2)
 3242a88:	10bfc00c 	andi	r2,r2,65280
 3242a8c:	1004923a 	slli	r2,r2,8
 3242a90:	1886b03a 	or	r3,r3,r2
 3242a94:	e0bffc17 	ldw	r2,-16(fp)
 3242a98:	10800417 	ldw	r2,16(r2)
 3242a9c:	10803fcc 	andi	r2,r2,255
 3242aa0:	1004963a 	slli	r2,r2,24
 3242aa4:	1884b03a 	or	r2,r3,r2
 3242aa8:	10fc002c 	andhi	r3,r2,61440
 3242aac:	00b80034 	movhi	r2,57344
 3242ab0:	1880181e 	bne	r3,r2,3242b14 <ip_rcv_phase2+0xe4>
      struct in_multi * inm;
      /*
       * See if we belong to the destination multicast group on the
       * arrival interface.
       */
      inm = lookup_mcast(pip->ip_dest, nt);
 3242ab4:	e0bffc17 	ldw	r2,-16(fp)
 3242ab8:	11000417 	ldw	r4,16(r2)
 3242abc:	e17ffb17 	ldw	r5,-20(fp)
 3242ac0:	32436ec0 	call	32436ec <lookup_mcast>
 3242ac4:	e0bff915 	stw	r2,-28(fp)
      if (inm == NULL) 
 3242ac8:	e0bff917 	ldw	r2,-28(fp)
 3242acc:	1004c03a 	cmpne	r2,r2,zero
 3242ad0:	10010d1e 	bne	r2,zero,3242f08 <ip_rcv_phase2+0x4d8>
      {
         ip_mib.ipOutNoRoutes++;
 3242ad4:	0080c9b4 	movhi	r2,806
 3242ad8:	10b46004 	addi	r2,r2,-11904
 3242adc:	10800b17 	ldw	r2,44(r2)
 3242ae0:	10c00044 	addi	r3,r2,1
 3242ae4:	0080c9b4 	movhi	r2,806
 3242ae8:	10b46004 	addi	r2,r2,-11904
 3242aec:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 3242af0:	01000084 	movi	r4,2
 3242af4:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pk_free(p);
 3242af8:	e13ffe17 	ldw	r4,-8(fp)
 3242afc:	322a2dc0 	call	322a2dc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3242b00:	01000084 	movi	r4,2
 3242b04:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
 3242b08:	00800084 	movi	r2,2
 3242b0c:	e0bfff15 	stw	r2,-4(fp)
 3242b10:	00014406 	br	3243024 <ip_rcv_phase2+0x5f4>
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 3242b14:	e0bffc17 	ldw	r2,-16(fp)
 3242b18:	10c00417 	ldw	r3,16(r2)
 3242b1c:	e0bffb17 	ldw	r2,-20(fp)
 3242b20:	10800a17 	ldw	r2,40(r2)
 3242b24:	1880f826 	beq	r3,r2,3242f08 <ip_rcv_phase2+0x4d8>
 3242b28:	e0bffc17 	ldw	r2,-16(fp)
 3242b2c:	10800417 	ldw	r2,16(r2)
 3242b30:	10bfffe0 	cmpeqi	r2,r2,-1
 3242b34:	1000f41e 	bne	r2,zero,3242f08 <ip_rcv_phase2+0x4d8>
 3242b38:	e0bffc17 	ldw	r2,-16(fp)
 3242b3c:	10c00417 	ldw	r3,16(r2)
 3242b40:	e0bffb17 	ldw	r2,-20(fp)
 3242b44:	10800e17 	ldw	r2,56(r2)
 3242b48:	1880ef26 	beq	r3,r2,3242f08 <ip_rcv_phase2+0x4d8>
 3242b4c:	e0bffc17 	ldw	r2,-16(fp)
 3242b50:	10c00417 	ldw	r3,16(r2)
 3242b54:	e0bffb17 	ldw	r2,-20(fp)
 3242b58:	10800f17 	ldw	r2,60(r2)
 3242b5c:	1880ea26 	beq	r3,r2,3242f08 <ip_rcv_phase2+0x4d8>
 3242b60:	e0bffc17 	ldw	r2,-16(fp)
 3242b64:	10c00417 	ldw	r3,16(r2)
 3242b68:	e0bffb17 	ldw	r2,-20(fp)
 3242b6c:	10801017 	ldw	r2,64(r2)
 3242b70:	1880e526 	beq	r3,r2,3242f08 <ip_rcv_phase2+0x4d8>
 3242b74:	e0bffb17 	ldw	r2,-20(fp)
 3242b78:	10c00a17 	ldw	r3,40(r2)
 3242b7c:	e0bffb17 	ldw	r2,-20(fp)
 3242b80:	10800c17 	ldw	r2,48(r2)
 3242b84:	0084303a 	nor	r2,zero,r2
 3242b88:	1884703a 	and	r2,r3,r2
 3242b8c:	1005003a 	cmpeq	r2,r2,zero
 3242b90:	1000dd1e 	bne	r2,zero,3242f08 <ip_rcv_phase2+0x4d8>
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 3242b94:	0080c974 	movhi	r2,805
 3242b98:	10923104 	addi	r2,r2,18628
 3242b9c:	10800017 	ldw	r2,0(r2)
 3242ba0:	1081000c 	andi	r2,r2,1024
 3242ba4:	1005003a 	cmpeq	r2,r2,zero
 3242ba8:	1000181e 	bne	r2,zero,3242c0c <ip_rcv_phase2+0x1dc>
 3242bac:	0080c974 	movhi	r2,805
 3242bb0:	10923104 	addi	r2,r2,18628
 3242bb4:	10800017 	ldw	r2,0(r2)
 3242bb8:	1080800c 	andi	r2,r2,512
 3242bbc:	1005003a 	cmpeq	r2,r2,zero
 3242bc0:	1000121e 	bne	r2,zero,3242c0c <ip_rcv_phase2+0x1dc>
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 3242bc4:	e0bffc17 	ldw	r2,-16(fp)
 3242bc8:	10800417 	ldw	r2,16(r2)
 3242bcc:	11403fcc 	andi	r5,r2,255
 3242bd0:	e0bffc17 	ldw	r2,-16(fp)
 3242bd4:	10800417 	ldw	r2,16(r2)
 3242bd8:	1004d23a 	srli	r2,r2,8
 3242bdc:	11803fcc 	andi	r6,r2,255
 3242be0:	e0bffc17 	ldw	r2,-16(fp)
 3242be4:	10800417 	ldw	r2,16(r2)
 3242be8:	1004d43a 	srli	r2,r2,16
 3242bec:	11c03fcc 	andi	r7,r2,255
 3242bf0:	e0bffc17 	ldw	r2,-16(fp)
 3242bf4:	10800417 	ldw	r2,16(r2)
 3242bf8:	1004d63a 	srli	r2,r2,24
 3242bfc:	d8800015 	stw	r2,0(sp)
 3242c00:	0100c974 	movhi	r4,805
 3242c04:	213f1404 	addi	r4,r4,-944
 3242c08:	3206adc0 	call	3206adc <printf>

#ifdef IP_ROUTING    /* if multi-homed router, try to route */
      /* Do routing only if ipForwarding is enabled in the IP MIB. This
       * is the switch for routing whether SNMP is used or not.
       */
      if (ip_mib.ipForwarding == 2)
 3242c0c:	0080c9b4 	movhi	r2,806
 3242c10:	10b46004 	addi	r2,r2,-11904
 3242c14:	10800017 	ldw	r2,0(r2)
 3242c18:	10800098 	cmpnei	r2,r2,2
 3242c1c:	1000101e 	bne	r2,zero,3242c60 <ip_rcv_phase2+0x230>
      {
         ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 3242c20:	0080c9b4 	movhi	r2,806
 3242c24:	10b46004 	addi	r2,r2,-11904
 3242c28:	10800a17 	ldw	r2,40(r2)
 3242c2c:	10c00044 	addi	r3,r2,1
 3242c30:	0080c9b4 	movhi	r2,806
 3242c34:	10b46004 	addi	r2,r2,-11904
 3242c38:	10c00a15 	stw	r3,40(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 3242c3c:	01000084 	movi	r4,2
 3242c40:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
         pk_free(p);
 3242c44:	e13ffe17 	ldw	r4,-8(fp)
 3242c48:	322a2dc0 	call	322a2dc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3242c4c:	01000084 	movi	r4,2
 3242c50:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_NO_ROUTE;
 3242c54:	00bff7c4 	movi	r2,-33
 3242c58:	e0bfff15 	stw	r2,-4(fp)
 3242c5c:	0000f106 	br	3243024 <ip_rcv_phase2+0x5f4>
         NET outnet;
#ifdef IP_FRAGMENTS
         int err;
#endif

         ip_mib.ipForwDatagrams++;  /* Count MIB-2 route attempts here */
 3242c60:	0080c9b4 	movhi	r2,806
 3242c64:	10b46004 	addi	r2,r2,-11904
 3242c68:	10800517 	ldw	r2,20(r2)
 3242c6c:	10c00044 	addi	r3,r2,1
 3242c70:	0080c9b4 	movhi	r2,806
 3242c74:	10b46004 	addi	r2,r2,-11904
 3242c78:	10c00515 	stw	r3,20(r2)
         if (pip->ip_time <= 1)     /* Time to Live (hopcount) expired? */
 3242c7c:	e0bffc17 	ldw	r2,-16(fp)
 3242c80:	10800203 	ldbu	r2,8(r2)
 3242c84:	10803fcc 	andi	r2,r2,255
 3242c88:	108000a8 	cmpgeui	r2,r2,2
 3242c8c:	10001b1e 	bne	r2,zero,3242cfc <ip_rcv_phase2+0x2cc>
         {
            ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 3242c90:	0080c9b4 	movhi	r2,806
 3242c94:	10b46004 	addi	r2,r2,-11904
 3242c98:	10800a17 	ldw	r2,40(r2)
 3242c9c:	10c00044 	addi	r3,r2,1
 3242ca0:	0080c9b4 	movhi	r2,806
 3242ca4:	10b46004 	addi	r2,r2,-11904
 3242ca8:	10c00a15 	stw	r3,40(r2)
#ifdef FULL_ICMP
            icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, (TIMEX <<8), p->net);
 3242cac:	e0bffc17 	ldw	r2,-16(fp)
 3242cb0:	11000317 	ldw	r4,12(r2)
 3242cb4:	e0bffe17 	ldw	r2,-8(fp)
 3242cb8:	10800617 	ldw	r2,24(r2)
 3242cbc:	11400a17 	ldw	r5,40(r2)
 3242cc0:	e0bffe17 	ldw	r2,-8(fp)
 3242cc4:	10800617 	ldw	r2,24(r2)
 3242cc8:	d8800015 	stw	r2,0(sp)
 3242ccc:	e1bffc17 	ldw	r6,-16(fp)
 3242cd0:	01c2c004 	movi	r7,2816
 3242cd4:	324b1dc0 	call	324b1dc <icmp_destun>
#endif   /* FULL_ICMP */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 3242cd8:	01000084 	movi	r4,2
 3242cdc:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
            pk_free(p);
 3242ce0:	e13ffe17 	ldw	r4,-8(fp)
 3242ce4:	322a2dc0 	call	322a2dc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3242ce8:	01000084 	movi	r4,2
 3242cec:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 3242cf0:	00bff7c4 	movi	r2,-33
 3242cf4:	e0bfff15 	stw	r2,-4(fp)
 3242cf8:	0000ca06 	br	3243024 <ip_rcv_phase2+0x5f4>
         }

         p->fhost = pip->ip_dest;   /* set packet's target IP in net endian */
 3242cfc:	e0bffc17 	ldw	r2,-16(fp)
 3242d00:	10c00417 	ldw	r3,16(r2)
 3242d04:	e0bffe17 	ldw	r2,-8(fp)
 3242d08:	10c00715 	stw	r3,28(r2)
         if ((outnet = iproute(p->fhost, &firsthop)) == NULL)  /* find route */
 3242d0c:	e0bffe17 	ldw	r2,-8(fp)
 3242d10:	11000717 	ldw	r4,28(r2)
 3242d14:	e17ffd04 	addi	r5,fp,-12
 3242d18:	32404f00 	call	32404f0 <iproute>
 3242d1c:	e0bff815 	stw	r2,-32(fp)
 3242d20:	e0bff817 	ldw	r2,-32(fp)
 3242d24:	1004c03a 	cmpne	r2,r2,zero
 3242d28:	1000101e 	bne	r2,zero,3242d6c <ip_rcv_phase2+0x33c>
         {
            ip_mib.ipOutNoRoutes++; /* count unroutable pkts */
 3242d2c:	0080c9b4 	movhi	r2,806
 3242d30:	10b46004 	addi	r2,r2,-11904
 3242d34:	10800b17 	ldw	r2,44(r2)
 3242d38:	10c00044 	addi	r3,r2,1
 3242d3c:	0080c9b4 	movhi	r2,806
 3242d40:	10b46004 	addi	r2,r2,-11904
 3242d44:	10c00b15 	stw	r3,44(r2)
            LOCK_NET_RESOURCE(FREEQ_RESID);
 3242d48:	01000084 	movi	r4,2
 3242d4c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
            pk_free(p);
 3242d50:	e13ffe17 	ldw	r4,-8(fp)
 3242d54:	322a2dc0 	call	322a2dc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3242d58:	01000084 	movi	r4,2
 3242d5c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 3242d60:	00bff7c4 	movi	r2,-33
 3242d64:	e0bfff15 	stw	r2,-4(fp)
 3242d68:	0000ae06 	br	3243024 <ip_rcv_phase2+0x5f4>
         /* Check to see if the packet was is addressed to one of our IP
          * addresses other than the interface it was received on. If so,
          * routing should have returned that interface and we can trap this
          * situation by checking the interfaces IP address.
          */
         if(pip->ip_dest == outnet->n_ipaddr)
 3242d6c:	e0bffc17 	ldw	r2,-16(fp)
 3242d70:	10c00417 	ldw	r3,16(r2)
 3242d74:	e0bff817 	ldw	r2,-32(fp)
 3242d78:	10800a17 	ldw	r2,40(r2)
 3242d7c:	18806226 	beq	r3,r2,3242f08 <ip_rcv_phase2+0x4d8>
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 3242d80:	e0bffc17 	ldw	r2,-16(fp)
 3242d84:	10c00417 	ldw	r3,16(r2)
 3242d88:	e0bff817 	ldw	r2,-32(fp)
 3242d8c:	10800e17 	ldw	r2,56(r2)
 3242d90:	18805d26 	beq	r3,r2,3242f08 <ip_rcv_phase2+0x4d8>
 3242d94:	e0bffc17 	ldw	r2,-16(fp)
 3242d98:	10c00417 	ldw	r3,16(r2)
 3242d9c:	e0bffe17 	ldw	r2,-8(fp)
 3242da0:	10800617 	ldw	r2,24(r2)
 3242da4:	10800e17 	ldw	r2,56(r2)
 3242da8:	18805726 	beq	r3,r2,3242f08 <ip_rcv_phase2+0x4d8>
         {
            goto ours;            
         }

         /* Routed OK, prepare to send */
         p->net = outnet;           /* set iface to send on */
 3242dac:	e0fffe17 	ldw	r3,-8(fp)
 3242db0:	e0bff817 	ldw	r2,-32(fp)
 3242db4:	18800615 	stw	r2,24(r3)
            }
         }
#endif   /* IPSEC */

         /* see if packet is too big for media of dest net */
         if ((p->nb_plen + p->net->n_lnh) > (unsigned)outnet->n_mtu)
 3242db8:	e0bffe17 	ldw	r2,-8(fp)
 3242dbc:	10c00417 	ldw	r3,16(r2)
 3242dc0:	e0bffe17 	ldw	r2,-8(fp)
 3242dc4:	10800617 	ldw	r2,24(r2)
 3242dc8:	10800817 	ldw	r2,32(r2)
 3242dcc:	1887883a 	add	r3,r3,r2
 3242dd0:	e0bff817 	ldw	r2,-32(fp)
 3242dd4:	10800917 	ldw	r2,36(r2)
 3242dd8:	10c0372e 	bgeu	r2,r3,3242eb8 <ip_rcv_phase2+0x488>
         {
#ifdef IP_FRAGMENTS
            /* see if we're not supposed to fragment it */
            if (ntohs(pip->ip_flgs_foff) & IP_FLG_DF)
 3242ddc:	e0bffc17 	ldw	r2,-16(fp)
 3242de0:	1080018b 	ldhu	r2,6(r2)
 3242de4:	10bfffcc 	andi	r2,r2,65535
 3242de8:	1004d23a 	srli	r2,r2,8
 3242dec:	10bfffcc 	andi	r2,r2,65535
 3242df0:	10c03fcc 	andi	r3,r2,255
 3242df4:	e0bffc17 	ldw	r2,-16(fp)
 3242df8:	1080018b 	ldhu	r2,6(r2)
 3242dfc:	10bfffcc 	andi	r2,r2,65535
 3242e00:	1004923a 	slli	r2,r2,8
 3242e04:	10bfc00c 	andi	r2,r2,65280
 3242e08:	1884b03a 	or	r2,r3,r2
 3242e0c:	1090000c 	andi	r2,r2,16384
 3242e10:	1005003a 	cmpeq	r2,r2,zero
 3242e14:	10001b1e 	bne	r2,zero,3242e84 <ip_rcv_phase2+0x454>
            {
#ifdef FULL_ICMP
               icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 3242e18:	e0bffc17 	ldw	r2,-16(fp)
 3242e1c:	11000317 	ldw	r4,12(r2)
 3242e20:	e0bffe17 	ldw	r2,-8(fp)
 3242e24:	10800617 	ldw	r2,24(r2)
 3242e28:	11400a17 	ldw	r5,40(r2)
 3242e2c:	e0bffe17 	ldw	r2,-8(fp)
 3242e30:	10800617 	ldw	r2,24(r2)
 3242e34:	d8800015 	stw	r2,0(sp)
 3242e38:	e1bffc17 	ldw	r6,-16(fp)
 3242e3c:	01c00104 	movi	r7,4
 3242e40:	324b1dc0 	call	324b1dc <icmp_destun>
#endif   /* FULL_ICMP */
               ip_mib.ipFragFails++;
 3242e44:	0080c9b4 	movhi	r2,806
 3242e48:	10b46004 	addi	r2,r2,-11904
 3242e4c:	10801117 	ldw	r2,68(r2)
 3242e50:	10c00044 	addi	r3,r2,1
 3242e54:	0080c9b4 	movhi	r2,806
 3242e58:	10b46004 	addi	r2,r2,-11904
 3242e5c:	10c01115 	stw	r3,68(r2)
               LOCK_NET_RESOURCE(FREEQ_RESID);
 3242e60:	01000084 	movi	r4,2
 3242e64:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
               pk_free(p);
 3242e68:	e13ffe17 	ldw	r4,-8(fp)
 3242e6c:	322a2dc0 	call	322a2dc <pk_free>
               UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3242e70:	01000084 	movi	r4,2
 3242e74:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
               IN_PROFILER(PF_IP, PF_EXIT);
               return ENP_LOGIC;
 3242e78:	00bffd44 	movi	r2,-11
 3242e7c:	e0bfff15 	stw	r2,-4(fp)
 3242e80:	00006806 	br	3243024 <ip_rcv_phase2+0x5f4>
            }

            /* fall to here if we're going to fragment it. */
            pip->ip_time--;            /* datagram's hop count */
 3242e84:	e0bffc17 	ldw	r2,-16(fp)
 3242e88:	10800203 	ldbu	r2,8(r2)
 3242e8c:	10bfffc4 	addi	r2,r2,-1
 3242e90:	1007883a 	mov	r3,r2
 3242e94:	e0bffc17 	ldw	r2,-16(fp)
 3242e98:	10c00205 	stb	r3,8(r2)
            err = ip_fragment(p, firsthop);
 3242e9c:	e17ffd17 	ldw	r5,-12(fp)
 3242ea0:	e13ffe17 	ldw	r4,-8(fp)
 3242ea4:	323fb680 	call	323fb68 <ip_fragment>
 3242ea8:	e0bff715 	stw	r2,-36(fp)
            IN_PROFILER(PF_IP, PF_EXIT);
            return(err);
 3242eac:	e0bff717 	ldw	r2,-36(fp)
 3242eb0:	e0bfff15 	stw	r2,-4(fp)
 3242eb4:	00005b06 	br	3243024 <ip_rcv_phase2+0x5f4>
            pk_free(p);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
            return ENP_LOGIC;
#endif   /* IP_FRAGMENTS */
         }
         pip->ip_time--;            /* datagram's hop count */
 3242eb8:	e0bffc17 	ldw	r2,-16(fp)
 3242ebc:	10800203 	ldbu	r2,8(r2)
 3242ec0:	10bfffc4 	addi	r2,r2,-1
 3242ec4:	1007883a 	mov	r3,r2
 3242ec8:	e0bffc17 	ldw	r2,-16(fp)
 3242ecc:	10c00205 	stb	r3,8(r2)
         pip->ip_chksum = IPXSUM;   /* clear checksum field for summing */
 3242ed0:	e0bffc17 	ldw	r2,-16(fp)
 3242ed4:	1000028d 	sth	zero,10(r2)
         pip->ip_chksum = ~cksum(pip, 10);   /* new xsum */
 3242ed8:	e13ffc17 	ldw	r4,-16(fp)
 3242edc:	01400284 	movi	r5,10
 3242ee0:	32259f80 	call	32259f8 <cksum>
 3242ee4:	0084303a 	nor	r2,zero,r2
 3242ee8:	1007883a 	mov	r3,r2
 3242eec:	e0bffc17 	ldw	r2,-16(fp)
 3242ef0:	10c0028d 	sth	r3,10(r2)
         IN_PROFILER(PF_IP, PF_EXIT);
#ifdef RF_SIMULATION
         if(rfsim_routing)
            return(rfsim_send(p, firsthop));
#endif   /* RF_SIMULATION */
         return(ip2mac(p, firsthop));
 3242ef4:	e17ffd17 	ldw	r5,-12(fp)
 3242ef8:	e13ffe17 	ldw	r4,-8(fp)
 3242efc:	32237940 	call	3223794 <ip2mac>
 3242f00:	e0bfff15 	stw	r2,-4(fp)
 3242f04:	00004706 	br	3243024 <ip_rcv_phase2+0x5f4>
#if defined (IP_MULTICAST) || defined (IP_ROUTING)
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
 3242f08:	e0bffc17 	ldw	r2,-16(fp)
 3242f0c:	1080018b 	ldhu	r2,6(r2)
 3242f10:	10bfffcc 	andi	r2,r2,65535
 3242f14:	1004d23a 	srli	r2,r2,8
 3242f18:	10803fcc 	andi	r2,r2,255
 3242f1c:	1009883a 	mov	r4,r2
 3242f20:	e0bffc17 	ldw	r2,-16(fp)
 3242f24:	1080018b 	ldhu	r2,6(r2)
 3242f28:	10bfffcc 	andi	r2,r2,65535
 3242f2c:	1004923a 	slli	r2,r2,8
 3242f30:	1007883a 	mov	r3,r2
 3242f34:	00bfc004 	movi	r2,-256
 3242f38:	1884703a 	and	r2,r3,r2
 3242f3c:	2084b03a 	or	r2,r4,r2
 3242f40:	e0bffa0d 	sth	r2,-24(fp)
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 3242f44:	e0bffa0b 	ldhu	r2,-24(fp)
 3242f48:	1088000c 	andi	r2,r2,8192
 3242f4c:	1004c03a 	cmpne	r2,r2,zero
 3242f50:	1000061e 	bne	r2,zero,3242f6c <ip_rcv_phase2+0x53c>
 3242f54:	e0fffa0b 	ldhu	r3,-24(fp)
 3242f58:	00bffff4 	movhi	r2,65535
 3242f5c:	1087ffc4 	addi	r2,r2,8191
 3242f60:	1884703a 	and	r2,r3,r2
 3242f64:	1005003a 	cmpeq	r2,r2,zero
 3242f68:	10002b1e 	bne	r2,zero,3243018 <ip_rcv_phase2+0x5e8>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 3242f6c:	0080c974 	movhi	r2,805
 3242f70:	10923104 	addi	r2,r2,18628
 3242f74:	10800017 	ldw	r2,0(r2)
 3242f78:	1081000c 	andi	r2,r2,1024
 3242f7c:	1005003a 	cmpeq	r2,r2,zero
 3242f80:	10001a1e 	bne	r2,zero,3242fec <ip_rcv_phase2+0x5bc>
 3242f84:	0080c974 	movhi	r2,805
 3242f88:	10923104 	addi	r2,r2,18628
 3242f8c:	10800017 	ldw	r2,0(r2)
 3242f90:	1080800c 	andi	r2,r2,512
 3242f94:	1005003a 	cmpeq	r2,r2,zero
 3242f98:	1000141e 	bne	r2,zero,3242fec <ip_rcv_phase2+0x5bc>
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 3242f9c:	e0bffc17 	ldw	r2,-16(fp)
 3242fa0:	10800317 	ldw	r2,12(r2)
 3242fa4:	11403fcc 	andi	r5,r2,255
 3242fa8:	e0bffc17 	ldw	r2,-16(fp)
 3242fac:	10800317 	ldw	r2,12(r2)
 3242fb0:	1004d23a 	srli	r2,r2,8
 3242fb4:	11803fcc 	andi	r6,r2,255
 3242fb8:	e0bffc17 	ldw	r2,-16(fp)
 3242fbc:	10800317 	ldw	r2,12(r2)
 3242fc0:	1004d43a 	srli	r2,r2,16
 3242fc4:	11c03fcc 	andi	r7,r2,255
 3242fc8:	e0bffc17 	ldw	r2,-16(fp)
 3242fcc:	10800317 	ldw	r2,12(r2)
 3242fd0:	1004d63a 	srli	r2,r2,24
 3242fd4:	d8800015 	stw	r2,0(sp)
 3242fd8:	0100c974 	movhi	r4,805
 3242fdc:	213f2004 	addi	r4,r4,-896
 3242fe0:	3206adc0 	call	3206adc <printf>
          PUSH_IPADDR(pip->ip_src));
         ip_dump(p);
 3242fe4:	e13ffe17 	ldw	r4,-8(fp)
 3242fe8:	32402380 	call	3240238 <ip_dump>
      }
#endif
      ip_mib.ipReasmReqds++;     /* got a reassemble request; ie a frag */
 3242fec:	0080c9b4 	movhi	r2,806
 3242ff0:	10b46004 	addi	r2,r2,-11904
 3242ff4:	10800d17 	ldw	r2,52(r2)
 3242ff8:	10c00044 	addi	r3,r2,1
 3242ffc:	0080c9b4 	movhi	r2,806
 3243000:	10b46004 	addi	r2,r2,-11904
 3243004:	10c00d15 	stw	r3,52(r2)
#ifdef IP_FRAGMENTS
      return(ip_reassm(p));
 3243008:	e13ffe17 	ldw	r4,-8(fp)
 324300c:	3240f100 	call	3240f10 <ip_reassm>
 3243010:	e0bfff15 	stw	r2,-4(fp)
 3243014:	00000306 	br	3243024 <ip_rcv_phase2+0x5f4>
   {
      return ENP_LOGIC;
   }
#endif /* IPSEC */

   return(ip_demux(p));    /* demux to correct to upper layer */
 3243018:	e13ffe17 	ldw	r4,-8(fp)
 324301c:	324303c0 	call	324303c <ip_demux>
 3243020:	e0bfff15 	stw	r2,-4(fp)
 3243024:	e0bfff17 	ldw	r2,-4(fp)
}
 3243028:	e037883a 	mov	sp,fp
 324302c:	dfc00117 	ldw	ra,4(sp)
 3243030:	df000017 	ldw	fp,0(sp)
 3243034:	dec00204 	addi	sp,sp,8
 3243038:	f800283a 	ret

0324303c <ip_demux>:
 * RETURNS: Same return values as ip_rcv(). 
 */

int
ip_demux(PACKET p)
{
 324303c:	defff704 	addi	sp,sp,-36
 3243040:	dfc00815 	stw	ra,32(sp)
 3243044:	df000715 	stw	fp,28(sp)
 3243048:	df000704 	addi	fp,sp,28
 324304c:	e13ffd15 	stw	r4,-12(fp)
   int   err;

   /* The packet is verified; the header is correct. Now we have
    * to demultiplex it among our internet connections.
    */
   pip = (struct ip *)(p->nb_prot);
 3243050:	e0bffd17 	ldw	r2,-12(fp)
 3243054:	10800317 	ldw	r2,12(r2)
 3243058:	e0bffc15 	stw	r2,-16(fp)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
 324305c:	e0bffc17 	ldw	r2,-16(fp)
 3243060:	10800003 	ldbu	r2,0(r2)
 3243064:	10803fcc 	andi	r2,r2,255
 3243068:	10801160 	cmpeqi	r2,r2,69
 324306c:	1000131e 	bne	r2,zero,32430bc <ip_demux+0x80>
   {
      if((pip->ip_ver_ihl < 0x45) ||
 3243070:	e0bffc17 	ldw	r2,-16(fp)
 3243074:	10800003 	ldbu	r2,0(r2)
 3243078:	10803fcc 	andi	r2,r2,255
 324307c:	10801170 	cmpltui	r2,r2,69
 3243080:	1000051e 	bne	r2,zero,3243098 <ip_demux+0x5c>
 3243084:	e0bffc17 	ldw	r2,-16(fp)
 3243088:	10800003 	ldbu	r2,0(r2)
 324308c:	10803fcc 	andi	r2,r2,255
 3243090:	10801230 	cmpltui	r2,r2,72
 3243094:	1000091e 	bne	r2,zero,32430bc <ip_demux+0x80>
         (pip->ip_ver_ihl > 0x47))
      {
         dprintf("ip_demux: bad IP type 0x%x\n", pip->ip_ver_ihl);
 3243098:	e0bffc17 	ldw	r2,-16(fp)
 324309c:	10800003 	ldbu	r2,0(r2)
 32430a0:	11403fcc 	andi	r5,r2,255
 32430a4:	0100c974 	movhi	r4,805
 32430a8:	213f2904 	addi	r4,r4,-860
 32430ac:	3206adc0 	call	3206adc <printf>
         return ENP_LOGIC;
 32430b0:	00bffd44 	movi	r2,-11
 32430b4:	e0bfff15 	stw	r2,-4(fp)
 32430b8:	0000e606 	br	3243454 <ip_demux+0x418>

   /* for profiling purposes count the upper layers (UDP, ICMP) in the IP
    * profile bucket. TCP will insert it's own nested profile calls 
    */
   IN_PROFILER(PF_IP, PF_ENTRY);
   p->fhost = pip->ip_src;
 32430bc:	e0bffc17 	ldw	r2,-16(fp)
 32430c0:	10c00317 	ldw	r3,12(r2)
 32430c4:	e0bffd17 	ldw	r2,-12(fp)
 32430c8:	10c00715 	stw	r3,28(r2)

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 32430cc:	0080c974 	movhi	r2,805
 32430d0:	10923104 	addi	r2,r2,18628
 32430d4:	10800017 	ldw	r2,0(r2)
 32430d8:	1081000c 	andi	r2,r2,1024
 32430dc:	1005003a 	cmpeq	r2,r2,zero
 32430e0:	1000241e 	bne	r2,zero,3243174 <ip_demux+0x138>
 32430e4:	0080c974 	movhi	r2,805
 32430e8:	10923104 	addi	r2,r2,18628
 32430ec:	10800017 	ldw	r2,0(r2)
 32430f0:	1080800c 	andi	r2,r2,512
 32430f4:	1005003a 	cmpeq	r2,r2,zero
 32430f8:	10001e1e 	bne	r2,zero,3243174 <ip_demux+0x138>
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 32430fc:	e0bffc17 	ldw	r2,-16(fp)
 3243100:	10800243 	ldbu	r2,9(r2)
 3243104:	11403fcc 	andi	r5,r2,255
 3243108:	e0bffc17 	ldw	r2,-16(fp)
 324310c:	10800317 	ldw	r2,12(r2)
 3243110:	11803fcc 	andi	r6,r2,255
 3243114:	e0bffc17 	ldw	r2,-16(fp)
 3243118:	10800317 	ldw	r2,12(r2)
 324311c:	1004d23a 	srli	r2,r2,8
 3243120:	11c03fcc 	andi	r7,r2,255
 3243124:	e0bffc17 	ldw	r2,-16(fp)
 3243128:	10800317 	ldw	r2,12(r2)
 324312c:	1004d43a 	srli	r2,r2,16
 3243130:	10c03fcc 	andi	r3,r2,255
 3243134:	e0bffc17 	ldw	r2,-16(fp)
 3243138:	10800317 	ldw	r2,12(r2)
 324313c:	1004d63a 	srli	r2,r2,24
 3243140:	d8c00015 	stw	r3,0(sp)
 3243144:	d8800115 	stw	r2,4(sp)
 3243148:	0100c974 	movhi	r4,805
 324314c:	213f3004 	addi	r4,r4,-832
 3243150:	3206adc0 	call	3206adc <printf>
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
      if (NDEBUG & DUMP) ip_dump(p);
 3243154:	0080c974 	movhi	r2,805
 3243158:	10923104 	addi	r2,r2,18628
 324315c:	10800017 	ldw	r2,0(r2)
 3243160:	1080008c 	andi	r2,r2,2
 3243164:	1005003a 	cmpeq	r2,r2,zero
 3243168:	1000021e 	bne	r2,zero,3243174 <ip_demux+0x138>
 324316c:	e13ffd17 	ldw	r4,-12(fp)
 3243170:	32402380 	call	3240238 <ip_dump>
   }
#endif

   switch (pip->ip_prot)
 3243174:	e0bffc17 	ldw	r2,-16(fp)
 3243178:	10800243 	ldbu	r2,9(r2)
 324317c:	10803fcc 	andi	r2,r2,255
 3243180:	e0bffe15 	stw	r2,-8(fp)
 3243184:	e0fffe17 	ldw	r3,-8(fp)
 3243188:	188000a0 	cmpeqi	r2,r3,2
 324318c:	1000241e 	bne	r2,zero,3243220 <ip_demux+0x1e4>
 3243190:	e0fffe17 	ldw	r3,-8(fp)
 3243194:	188000c8 	cmpgei	r2,r3,3
 3243198:	1000041e 	bne	r2,zero,32431ac <ip_demux+0x170>
 324319c:	e0fffe17 	ldw	r3,-8(fp)
 32431a0:	18800060 	cmpeqi	r2,r3,1
 32431a4:	1000131e 	bne	r2,zero,32431f4 <ip_demux+0x1b8>
 32431a8:	00003306 	br	3243278 <ip_demux+0x23c>
 32431ac:	e0fffe17 	ldw	r3,-8(fp)
 32431b0:	188001a0 	cmpeqi	r2,r3,6
 32431b4:	1000251e 	bne	r2,zero,324324c <ip_demux+0x210>
 32431b8:	e0fffe17 	ldw	r3,-8(fp)
 32431bc:	18800460 	cmpeqi	r2,r3,17
 32431c0:	1000011e 	bne	r2,zero,32431c8 <ip_demux+0x18c>
 32431c4:	00002c06 	br	3243278 <ip_demux+0x23c>
   {
   case UDP_PROT:
      ip_mib.ipInDelivers++;
 32431c8:	0080c9b4 	movhi	r2,806
 32431cc:	10b46004 	addi	r2,r2,-11904
 32431d0:	10800817 	ldw	r2,32(r2)
 32431d4:	10c00044 	addi	r3,r2,1
 32431d8:	0080c9b4 	movhi	r2,806
 32431dc:	10b46004 	addi	r2,r2,-11904
 32431e0:	10c00815 	stw	r3,32(r2)
      err = udpdemux(p);
 32431e4:	e13ffd17 	ldw	r4,-12(fp)
 32431e8:	32444800 	call	3244480 <udpdemux>
 32431ec:	e0bffb15 	stw	r2,-20(fp)
      break;
 32431f0:	00002b06 	br	32432a0 <ip_demux+0x264>
   case ICMP_PROT:
      ip_mib.ipInDelivers++;
 32431f4:	0080c9b4 	movhi	r2,806
 32431f8:	10b46004 	addi	r2,r2,-11904
 32431fc:	10800817 	ldw	r2,32(r2)
 3243200:	10c00044 	addi	r3,r2,1
 3243204:	0080c9b4 	movhi	r2,806
 3243208:	10b46004 	addi	r2,r2,-11904
 324320c:	10c00815 	stw	r3,32(r2)
      err = icmprcv(p);
 3243210:	e13ffd17 	ldw	r4,-12(fp)
 3243214:	324a5a80 	call	324a5a8 <icmprcv>
 3243218:	e0bffb15 	stw	r2,-20(fp)
      break;
 324321c:	00002006 	br	32432a0 <ip_demux+0x264>
#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   case IGMP_PROT:
      ip_mib.ipInDelivers++;
 3243220:	0080c9b4 	movhi	r2,806
 3243224:	10b46004 	addi	r2,r2,-11904
 3243228:	10800817 	ldw	r2,32(r2)
 324322c:	10c00044 	addi	r3,r2,1
 3243230:	0080c9b4 	movhi	r2,806
 3243234:	10b46004 	addi	r2,r2,-11904
 3243238:	10c00815 	stw	r3,32(r2)
      err = igmp_input(p);
 324323c:	e13ffd17 	ldw	r4,-12(fp)
 3243240:	3223e980 	call	3223e98 <igmp_input>
 3243244:	e0bffb15 	stw	r2,-20(fp)
      break;
 3243248:	00001506 	br	32432a0 <ip_demux+0x264>
#endif   /* IP_MULTICAST and (IGMPv1 or IGMPv2) */
#ifdef INCLUDE_TCP
   case TCP_PROT:
      ip_mib.ipInDelivers++;
 324324c:	0080c9b4 	movhi	r2,806
 3243250:	10b46004 	addi	r2,r2,-11904
 3243254:	10800817 	ldw	r2,32(r2)
 3243258:	10c00044 	addi	r3,r2,1
 324325c:	0080c9b4 	movhi	r2,806
 3243260:	10b46004 	addi	r2,r2,-11904
 3243264:	10c00815 	stw	r3,32(r2)
      err = tcp_rcv(p);
 3243268:	e13ffd17 	ldw	r4,-12(fp)
 324326c:	322c4b00 	call	322c4b0 <tcp_rcv>
 3243270:	e0bffb15 	stw	r2,-20(fp)
      break;
 3243274:	00000a06 	br	32432a0 <ip_demux+0x264>
      err = v6t_rcv(p);
      break;
#endif /* IPV6_TUNNEL */
   default: /* unknown upper protocol */
#ifdef IP_RAW
      ip_mib.ipInDelivers++;
 3243278:	0080c9b4 	movhi	r2,806
 324327c:	10b46004 	addi	r2,r2,-11904
 3243280:	10800817 	ldw	r2,32(r2)
 3243284:	10c00044 	addi	r3,r2,1
 3243288:	0080c9b4 	movhi	r2,806
 324328c:	10b46004 	addi	r2,r2,-11904
 3243290:	10c00815 	stw	r3,32(r2)
      err = ip_raw_input(p);
 3243294:	e13ffd17 	ldw	r4,-12(fp)
 3243298:	32439f00 	call	32439f0 <ip_raw_input>
 324329c:	e0bffb15 	stw	r2,-20(fp)
#endif /* IP_RAW */
   }

   IN_PROFILER(PF_IP, PF_EXIT);

   if(err != ENP_PARAM)
 32432a0:	e0bffb17 	ldw	r2,-20(fp)
 32432a4:	10bffda0 	cmpeqi	r2,r2,-10
 32432a8:	1000031e 	bne	r2,zero,32432b8 <ip_demux+0x27c>
   {
      return err;
 32432ac:	e0bffb17 	ldw	r2,-20(fp)
 32432b0:	e0bfff15 	stw	r2,-4(fp)
 32432b4:	00006706 	br	3243454 <ip_demux+0x418>

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 32432b8:	e0bffc17 	ldw	r2,-16(fp)
 32432bc:	10800417 	ldw	r2,16(r2)
 32432c0:	10bfffe0 	cmpeqi	r2,r2,-1
 32432c4:	1000541e 	bne	r2,zero,3243418 <ip_demux+0x3dc>
 32432c8:	e0bffc17 	ldw	r2,-16(fp)
 32432cc:	10800417 	ldw	r2,16(r2)
 32432d0:	1004d63a 	srli	r2,r2,24
 32432d4:	10c03fcc 	andi	r3,r2,255
 32432d8:	e0bffc17 	ldw	r2,-16(fp)
 32432dc:	10800417 	ldw	r2,16(r2)
 32432e0:	1004d23a 	srli	r2,r2,8
 32432e4:	10bfc00c 	andi	r2,r2,65280
 32432e8:	1886b03a 	or	r3,r3,r2
 32432ec:	e0bffc17 	ldw	r2,-16(fp)
 32432f0:	10800417 	ldw	r2,16(r2)
 32432f4:	10bfc00c 	andi	r2,r2,65280
 32432f8:	1004923a 	slli	r2,r2,8
 32432fc:	1886b03a 	or	r3,r3,r2
 3243300:	e0bffc17 	ldw	r2,-16(fp)
 3243304:	10800417 	ldw	r2,16(r2)
 3243308:	10803fcc 	andi	r2,r2,255
 324330c:	1004963a 	slli	r2,r2,24
 3243310:	1884b03a 	or	r2,r3,r2
 3243314:	10fc002c 	andhi	r3,r2,61440
 3243318:	00b80034 	movhi	r2,57344
 324331c:	18803e26 	beq	r3,r2,3243418 <ip_demux+0x3dc>
 3243320:	e0bffc17 	ldw	r2,-16(fp)
 3243324:	10c00417 	ldw	r3,16(r2)
 3243328:	e0bffd17 	ldw	r2,-12(fp)
 324332c:	10800617 	ldw	r2,24(r2)
 3243330:	10800e17 	ldw	r2,56(r2)
 3243334:	18803826 	beq	r3,r2,3243418 <ip_demux+0x3dc>
 3243338:	e0bffc17 	ldw	r2,-16(fp)
 324333c:	10c00417 	ldw	r3,16(r2)
 3243340:	e0bffd17 	ldw	r2,-12(fp)
 3243344:	10800617 	ldw	r2,24(r2)
 3243348:	10800f17 	ldw	r2,60(r2)
 324334c:	18803226 	beq	r3,r2,3243418 <ip_demux+0x3dc>
 3243350:	e0bffc17 	ldw	r2,-16(fp)
 3243354:	10c00417 	ldw	r3,16(r2)
 3243358:	e0bffd17 	ldw	r2,-12(fp)
 324335c:	10800617 	ldw	r2,24(r2)
 3243360:	10801017 	ldw	r2,64(r2)
 3243364:	18802c26 	beq	r3,r2,3243418 <ip_demux+0x3dc>
 3243368:	e0bffd17 	ldw	r2,-12(fp)
 324336c:	10800617 	ldw	r2,24(r2)
 3243370:	10c00a17 	ldw	r3,40(r2)
 3243374:	e0bffd17 	ldw	r2,-12(fp)
 3243378:	10800617 	ldw	r2,24(r2)
 324337c:	10801017 	ldw	r2,64(r2)
 3243380:	18802526 	beq	r3,r2,3243418 <ip_demux+0x3dc>
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
   {

#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 3243384:	0080c974 	movhi	r2,805
 3243388:	10923104 	addi	r2,r2,18628
 324338c:	10800017 	ldw	r2,0(r2)
 3243390:	1081000c 	andi	r2,r2,1024
 3243394:	1005003a 	cmpeq	r2,r2,zero
 3243398:	1000141e 	bne	r2,zero,32433ec <ip_demux+0x3b0>
 324339c:	0080c974 	movhi	r2,805
 32433a0:	10923104 	addi	r2,r2,18628
 32433a4:	10800017 	ldw	r2,0(r2)
 32433a8:	1080800c 	andi	r2,r2,512
 32433ac:	1005003a 	cmpeq	r2,r2,zero
 32433b0:	10000e1e 	bne	r2,zero,32433ec <ip_demux+0x3b0>
      {
         dprintf("ip_demux: unhandled prot %u\n", pip->ip_prot);
 32433b4:	e0bffc17 	ldw	r2,-16(fp)
 32433b8:	10800243 	ldbu	r2,9(r2)
 32433bc:	11403fcc 	andi	r5,r2,255
 32433c0:	0100c974 	movhi	r4,805
 32433c4:	213f3a04 	addi	r4,r4,-792
 32433c8:	3206adc0 	call	3206adc <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 32433cc:	0080c974 	movhi	r2,805
 32433d0:	10923104 	addi	r2,r2,18628
 32433d4:	10800017 	ldw	r2,0(r2)
 32433d8:	1080008c 	andi	r2,r2,2
 32433dc:	1005003a 	cmpeq	r2,r2,zero
 32433e0:	1000021e 	bne	r2,zero,32433ec <ip_demux+0x3b0>
 32433e4:	e13ffd17 	ldw	r4,-12(fp)
 32433e8:	32402380 	call	3240238 <ip_dump>
      }
#endif   /* NPDEBUG */
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTPROT, p->net);
 32433ec:	e0bffc17 	ldw	r2,-16(fp)
 32433f0:	11000317 	ldw	r4,12(r2)
 32433f4:	e0bffd17 	ldw	r2,-12(fp)
 32433f8:	10800617 	ldw	r2,24(r2)
 32433fc:	11400a17 	ldw	r5,40(r2)
 3243400:	e0bffd17 	ldw	r2,-12(fp)
 3243404:	10800617 	ldw	r2,24(r2)
 3243408:	d8800015 	stw	r2,0(sp)
 324340c:	e1bffc17 	ldw	r6,-16(fp)
 3243410:	01c00084 	movi	r7,2
 3243414:	324b1dc0 	call	324b1dc <icmp_destun>
   }
#endif   /* FULL_ICMP */

   ip_mib.ipUnknownProtos++;
 3243418:	0080c9b4 	movhi	r2,806
 324341c:	10b46004 	addi	r2,r2,-11904
 3243420:	10800617 	ldw	r2,24(r2)
 3243424:	10c00044 	addi	r3,r2,1
 3243428:	0080c9b4 	movhi	r2,806
 324342c:	10b46004 	addi	r2,r2,-11904
 3243430:	10c00615 	stw	r3,24(r2)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 3243434:	01000084 	movi	r4,2
 3243438:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   pk_free(p);
 324343c:	e13ffd17 	ldw	r4,-12(fp)
 3243440:	322a2dc0 	call	322a2dc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3243444:	01000084 	movi	r4,2
 3243448:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   return ENP_NOT_MINE;
 324344c:	00c00084 	movi	r3,2
 3243450:	e0ffff15 	stw	r3,-4(fp)
 3243454:	e0bfff17 	ldw	r2,-4(fp)
}
 3243458:	e037883a 	mov	sp,fp
 324345c:	dfc00117 	ldw	ra,4(sp)
 3243460:	df000017 	ldw	fp,0(sp)
 3243464:	dec00204 	addi	sp,sp,8
 3243468:	f800283a 	ret

0324346c <in_addmulti>:
 * RETURNS: 
 */

struct in_multi * 
in_addmulti(ip_addr *ap, struct net *netp, int addrtype)
{
 324346c:	defff804 	addi	sp,sp,-32
 3243470:	dfc00715 	stw	ra,28(sp)
 3243474:	df000615 	stw	fp,24(sp)
 3243478:	df000604 	addi	fp,sp,24
 324347c:	e13ffc15 	stw	r4,-16(fp)
 3243480:	e17ffd15 	stw	r5,-12(fp)
 3243484:	e1bffe15 	stw	r6,-8(fp)
   struct in_multi *inm = (struct in_multi *)NULL;
 3243488:	e03ffb15 	stw	zero,-20(fp)
   int error;

   /* check for good addr. */
   if ((ap == (ip_addr *)NULL) || (*ap == 0))
 324348c:	e0bffc17 	ldw	r2,-16(fp)
 3243490:	1005003a 	cmpeq	r2,r2,zero
 3243494:	1000041e 	bne	r2,zero,32434a8 <in_addmulti+0x3c>
 3243498:	e0bffc17 	ldw	r2,-16(fp)
 324349c:	10800017 	ldw	r2,0(r2)
 32434a0:	1004c03a 	cmpne	r2,r2,zero
 32434a4:	1000021e 	bne	r2,zero,32434b0 <in_addmulti+0x44>
      return ((struct in_multi *)NULL);  
 32434a8:	e03fff15 	stw	zero,-4(fp)
 32434ac:	00004306 	br	32435bc <in_addmulti+0x150>

   ENTER_CRIT_SECTION(netp);
 32434b0:	322ad8c0 	call	322ad8c <irq_Mask>
#ifdef IP_V6
   if(addrtype == 6)
      inm = v6_lookup_mcast((ip6_addr*)ap, netp);
#endif
#ifdef IP_V4
   if(addrtype != 6)
 32434b4:	e0bffe17 	ldw	r2,-8(fp)
 32434b8:	108001a0 	cmpeqi	r2,r2,6
 32434bc:	1000051e 	bne	r2,zero,32434d4 <in_addmulti+0x68>
      inm = lookup_mcast(*ap, netp);
 32434c0:	e0bffc17 	ldw	r2,-16(fp)
 32434c4:	11000017 	ldw	r4,0(r2)
 32434c8:	e17ffd17 	ldw	r5,-12(fp)
 32434cc:	32436ec0 	call	32436ec <lookup_mcast>
 32434d0:	e0bffb15 	stw	r2,-20(fp)
#endif

   if (inm != (struct in_multi *)NULL) 
 32434d4:	e0bffb17 	ldw	r2,-20(fp)
 32434d8:	1005003a 	cmpeq	r2,r2,zero
 32434dc:	1000061e 	bne	r2,zero,32434f8 <in_addmulti+0x8c>
   {
      /* Found it; just increment the reference count. */
      ++inm->inm_refcount;
 32434e0:	e0bffb17 	ldw	r2,-20(fp)
 32434e4:	10800217 	ldw	r2,8(r2)
 32434e8:	10c00044 	addi	r3,r2,1
 32434ec:	e0bffb17 	ldw	r2,-20(fp)
 32434f0:	10c00215 	stw	r3,8(r2)
 32434f4:	00002e06 	br	32435b0 <in_addmulti+0x144>
   {
      /*
       * New address; allocate a new multicast record
       * and link it into the interface's multicast list.
       */
      inm = (struct in_multi *)INM_ALLOC(sizeof(*inm));
 32434f8:	01000604 	movi	r4,24
 32434fc:	322b5d00 	call	322b5d0 <npalloc>
 3243500:	e0bffb15 	stw	r2,-20(fp)

      if (inm == (struct in_multi *)NULL) 
 3243504:	e0bffb17 	ldw	r2,-20(fp)
 3243508:	1004c03a 	cmpne	r2,r2,zero
 324350c:	1000031e 	bne	r2,zero,324351c <in_addmulti+0xb0>
      {
         EXIT_CRIT_SECTION(netp);
 3243510:	322ade80 	call	322ade8 <irq_Unmask>
         return ((struct in_multi *)NULL);
 3243514:	e03fff15 	stw	zero,-4(fp)
 3243518:	00002806 	br	32435bc <in_addmulti+0x150>
#ifdef IP_V6
      if(addrtype == 6)
         IP6CPY(&inm->ip6addr, (struct in6_addr *)ap);
#endif
#ifdef IP_V4
      if(addrtype != 6)
 324351c:	e0bffe17 	ldw	r2,-8(fp)
 3243520:	108001a0 	cmpeqi	r2,r2,6
 3243524:	1000041e 	bne	r2,zero,3243538 <in_addmulti+0xcc>
         inm->inm_addr = *ap;
 3243528:	e0bffc17 	ldw	r2,-16(fp)
 324352c:	10c00017 	ldw	r3,0(r2)
 3243530:	e0bffb17 	ldw	r2,-20(fp)
 3243534:	10c00015 	stw	r3,0(r2)
#endif
      inm->inm_netp = netp;
 3243538:	e0fffb17 	ldw	r3,-20(fp)
 324353c:	e0bffd17 	ldw	r2,-12(fp)
 3243540:	18800115 	stw	r2,4(r3)
      inm->inm_refcount = 1;
 3243544:	e0fffb17 	ldw	r3,-20(fp)
 3243548:	00800044 	movi	r2,1
 324354c:	18800215 	stw	r2,8(r3)
      inm->inm_next = netp->mc_list;
 3243550:	e0bffd17 	ldw	r2,-12(fp)
 3243554:	10c02c17 	ldw	r3,176(r2)
 3243558:	e0bffb17 	ldw	r2,-20(fp)
 324355c:	10c00515 	stw	r3,20(r2)
      netp->mc_list = inm;
 3243560:	e0fffd17 	ldw	r3,-12(fp)
 3243564:	e0bffb17 	ldw	r2,-20(fp)
 3243568:	18802c15 	stw	r2,176(r3)
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the new address.
       */
      if(netp->n_mcastlist)
 324356c:	e0bffd17 	ldw	r2,-12(fp)
 3243570:	10802b17 	ldw	r2,172(r2)
 3243574:	1005003a 	cmpeq	r2,r2,zero
 3243578:	1000061e 	bne	r2,zero,3243594 <in_addmulti+0x128>
         error = netp->n_mcastlist(inm);
 324357c:	e0bffd17 	ldw	r2,-12(fp)
 3243580:	10802b17 	ldw	r2,172(r2)
 3243584:	e13ffb17 	ldw	r4,-20(fp)
 3243588:	103ee83a 	callr	r2
 324358c:	e0bffa15 	stw	r2,-24(fp)
 3243590:	00000106 	br	3243598 <in_addmulti+0x12c>
      else
         error = 0;
 3243594:	e03ffa15 	stw	zero,-24(fp)
#if defined (IGMP_V1) || defined (IGMP_V2)
      /*
       * Let IGMP know that we have joined a new IP multicast group.
       */
      if (inm->inm_addr) igmp_joingroup(inm);
 3243598:	e0bffb17 	ldw	r2,-20(fp)
 324359c:	10800017 	ldw	r2,0(r2)
 32435a0:	1005003a 	cmpeq	r2,r2,zero
 32435a4:	1000021e 	bne	r2,zero,32435b0 <in_addmulti+0x144>
 32435a8:	e13ffb17 	ldw	r4,-20(fp)
 32435ac:	32243d40 	call	32243d4 <igmp_joingroup>
#endif      
   }

   EXIT_CRIT_SECTION(netp);
 32435b0:	322ade80 	call	322ade8 <irq_Unmask>
   USE_ARG(error);

   return (inm);
 32435b4:	e0bffb17 	ldw	r2,-20(fp)
 32435b8:	e0bfff15 	stw	r2,-4(fp)
 32435bc:	e0bfff17 	ldw	r2,-4(fp)
}
 32435c0:	e037883a 	mov	sp,fp
 32435c4:	dfc00117 	ldw	ra,4(sp)
 32435c8:	df000017 	ldw	fp,0(sp)
 32435cc:	dec00204 	addi	sp,sp,8
 32435d0:	f800283a 	ret

032435d4 <in_delmulti>:
 * RETURNS: 
 */

void
in_delmulti(struct in_multi * inm)
{
 32435d4:	defffa04 	addi	sp,sp,-24
 32435d8:	dfc00515 	stw	ra,20(sp)
 32435dc:	df000415 	stw	fp,16(sp)
 32435e0:	df000404 	addi	fp,sp,16
 32435e4:	e13fff15 	stw	r4,-4(fp)
   struct in_multi * p;
   NET         netp = inm->inm_netp;
 32435e8:	e0bfff17 	ldw	r2,-4(fp)
 32435ec:	10800117 	ldw	r2,4(r2)
 32435f0:	e0bffd15 	stw	r2,-12(fp)
   int error;

   ENTER_CRIT_SECTION(inm);
 32435f4:	322ad8c0 	call	322ad8c <irq_Mask>
   if (--inm->inm_refcount == 0) 
 32435f8:	e0bfff17 	ldw	r2,-4(fp)
 32435fc:	10800217 	ldw	r2,8(r2)
 3243600:	10ffffc4 	addi	r3,r2,-1
 3243604:	e0bfff17 	ldw	r2,-4(fp)
 3243608:	10c00215 	stw	r3,8(r2)
 324360c:	e0bfff17 	ldw	r2,-4(fp)
 3243610:	10800217 	ldw	r2,8(r2)
 3243614:	1004c03a 	cmpne	r2,r2,zero
 3243618:	10002e1e 	bne	r2,zero,32436d4 <in_delmulti+0x100>
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 324361c:	e0bffd17 	ldw	r2,-12(fp)
 3243620:	10802c17 	ldw	r2,176(r2)
 3243624:	e0bffe15 	stw	r2,-8(fp)
 3243628:	00001406 	br	324367c <in_delmulti+0xa8>
      {
         if(p == inm)   /* inm is first in mc_list */
 324362c:	e0fffe17 	ldw	r3,-8(fp)
 3243630:	e0bfff17 	ldw	r2,-4(fp)
 3243634:	1880051e 	bne	r3,r2,324364c <in_delmulti+0x78>
         {
            netp->mc_list = p->inm_next;  /* unlink */
 3243638:	e0bffe17 	ldw	r2,-8(fp)
 324363c:	10c00517 	ldw	r3,20(r2)
 3243640:	e0bffd17 	ldw	r2,-12(fp)
 3243644:	10c02c15 	stw	r3,176(r2)
            break;
 3243648:	00000f06 	br	3243688 <in_delmulti+0xb4>
         }
         else if(p->inm_next == inm)   /* inm is next */
 324364c:	e0bffe17 	ldw	r2,-8(fp)
 3243650:	10c00517 	ldw	r3,20(r2)
 3243654:	e0bfff17 	ldw	r2,-4(fp)
 3243658:	1880051e 	bne	r3,r2,3243670 <in_delmulti+0x9c>
         {
            p->inm_next = inm->inm_next;  /* unlink */
 324365c:	e0bfff17 	ldw	r2,-4(fp)
 3243660:	10c00517 	ldw	r3,20(r2)
 3243664:	e0bffe17 	ldw	r2,-8(fp)
 3243668:	10c00515 	stw	r3,20(r2)
            break;
 324366c:	00000606 	br	3243688 <in_delmulti+0xb4>

   ENTER_CRIT_SECTION(inm);
   if (--inm->inm_refcount == 0) 
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 3243670:	e0bffe17 	ldw	r2,-8(fp)
 3243674:	10800517 	ldw	r2,20(r2)
 3243678:	e0bffe15 	stw	r2,-8(fp)
 324367c:	e0bffe17 	ldw	r2,-8(fp)
 3243680:	1004c03a 	cmpne	r2,r2,zero
 3243684:	103fe91e 	bne	r2,zero,324362c <in_delmulti+0x58>
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the deleted address.
       */
      if(netp->n_mcastlist)
 3243688:	e0bffd17 	ldw	r2,-12(fp)
 324368c:	10802b17 	ldw	r2,172(r2)
 3243690:	1005003a 	cmpeq	r2,r2,zero
 3243694:	1000061e 	bne	r2,zero,32436b0 <in_delmulti+0xdc>
         error = netp->n_mcastlist(inm);
 3243698:	e0bffd17 	ldw	r2,-12(fp)
 324369c:	10802b17 	ldw	r2,172(r2)
 32436a0:	e13fff17 	ldw	r4,-4(fp)
 32436a4:	103ee83a 	callr	r2
 32436a8:	e0bffc15 	stw	r2,-16(fp)
 32436ac:	00000106 	br	32436b4 <in_delmulti+0xe0>
      else
         error = 0;
 32436b0:	e03ffc15 	stw	zero,-16(fp)
#if defined (IGMP_V2)
      /*
       * No remaining claims to this record; let IGMP know that
       * we are leaving the multicast group.
       */
      if (inm->inm_addr) igmp_leavegroup(inm);
 32436b4:	e0bfff17 	ldw	r2,-4(fp)
 32436b8:	10800017 	ldw	r2,0(r2)
 32436bc:	1005003a 	cmpeq	r2,r2,zero
 32436c0:	1000021e 	bne	r2,zero,32436cc <in_delmulti+0xf8>
 32436c4:	e13fff17 	ldw	r4,-4(fp)
 32436c8:	32246400 	call	3224640 <igmp_leavegroup>
#endif      

      IM_FREE(inm);
 32436cc:	e13fff17 	ldw	r4,-4(fp)
 32436d0:	322b6c40 	call	322b6c4 <npfree>
   }
   EXIT_CRIT_SECTION(inm);
 32436d4:	322ade80 	call	322ade8 <irq_Unmask>
}
 32436d8:	e037883a 	mov	sp,fp
 32436dc:	dfc00117 	ldw	ra,4(sp)
 32436e0:	df000017 	ldw	fp,0(sp)
 32436e4:	dec00204 	addi	sp,sp,8
 32436e8:	f800283a 	ret

032436ec <lookup_mcast>:
 * RETURNS: pointer to mcast addr structure, or NULL if not found.
 */

struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
 32436ec:	defffb04 	addi	sp,sp,-20
 32436f0:	df000415 	stw	fp,16(sp)
 32436f4:	df000404 	addi	fp,sp,16
 32436f8:	e13ffd15 	stw	r4,-12(fp)
 32436fc:	e17ffe15 	stw	r5,-8(fp)
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 3243700:	e0bffe17 	ldw	r2,-8(fp)
 3243704:	10802c17 	ldw	r2,176(r2)
 3243708:	e0bffc15 	stw	r2,-16(fp)
 324370c:	00000a06 	br	3243738 <lookup_mcast+0x4c>
   {
      if(imp->inm_addr == addr)
 3243710:	e0bffc17 	ldw	r2,-16(fp)
 3243714:	10c00017 	ldw	r3,0(r2)
 3243718:	e0bffd17 	ldw	r2,-12(fp)
 324371c:	1880031e 	bne	r3,r2,324372c <lookup_mcast+0x40>
         return imp;
 3243720:	e0bffc17 	ldw	r2,-16(fp)
 3243724:	e0bfff15 	stw	r2,-4(fp)
 3243728:	00000706 	br	3243748 <lookup_mcast+0x5c>
struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 324372c:	e0bffc17 	ldw	r2,-16(fp)
 3243730:	10800517 	ldw	r2,20(r2)
 3243734:	e0bffc15 	stw	r2,-16(fp)
 3243738:	e0bffc17 	ldw	r2,-16(fp)
 324373c:	1004c03a 	cmpne	r2,r2,zero
 3243740:	103ff31e 	bne	r2,zero,3243710 <lookup_mcast+0x24>
   {
      if(imp->inm_addr == addr)
         return imp;
   }
   return NULL;   /* addr not found in mcast list */
 3243744:	e03fff15 	stw	zero,-4(fp)
 3243748:	e0bfff17 	ldw	r2,-4(fp)
}
 324374c:	e037883a 	mov	sp,fp
 3243750:	df000017 	ldw	fp,0(sp)
 3243754:	dec00104 	addi	sp,sp,4
 3243758:	f800283a 	ret

0324375c <prep_ifaces>:
 * passed value. 
 */

int
prep_ifaces(int ifaces_found)
{
 324375c:	defffc04 	addi	sp,sp,-16
 3243760:	dfc00315 	stw	ra,12(sp)
 3243764:	df000215 	stw	fp,8(sp)
 3243768:	df000204 	addi	fp,sp,8
 324376c:	e13ffe15 	stw	r4,-8(fp)
   if (port_prep)
 3243770:	d0a90117 	ldw	r2,-23548(gp)
 3243774:	1005003a 	cmpeq	r2,r2,zero
 3243778:	1000041e 	bne	r2,zero,324378c <prep_ifaces+0x30>
      ifaces_found = port_prep(ifaces_found);
 324377c:	d0a90117 	ldw	r2,-23548(gp)
 3243780:	e13ffe17 	ldw	r4,-8(fp)
 3243784:	103ee83a 	callr	r2
 3243788:	e0bffe15 	stw	r2,-8(fp)

#ifdef MAC_LOOPBACK
   ifaces_found = prep_lb(ifaces_found);
#endif   /* MAC_LOOPBACK */

   ifNumber = ifaces_found;   /* set global interface counter */
 324378c:	e0fffe17 	ldw	r3,-8(fp)
 3243790:	0080c974 	movhi	r2,805
 3243794:	10923204 	addi	r2,r2,18632
 3243798:	10c00015 	stw	r3,0(r2)

   initmsg("prepped %u interface%s, initializing...\n", 
 324379c:	e0bffe17 	ldw	r2,-8(fp)
 32437a0:	10800058 	cmpnei	r2,r2,1
 32437a4:	1000041e 	bne	r2,zero,32437b8 <prep_ifaces+0x5c>
 32437a8:	0080c974 	movhi	r2,805
 32437ac:	10bf4204 	addi	r2,r2,-760
 32437b0:	e0bfff15 	stw	r2,-4(fp)
 32437b4:	00000306 	br	32437c4 <prep_ifaces+0x68>
 32437b8:	0080c974 	movhi	r2,805
 32437bc:	10bf4304 	addi	r2,r2,-756
 32437c0:	e0bfff15 	stw	r2,-4(fp)
 32437c4:	0100c974 	movhi	r4,805
 32437c8:	213f4404 	addi	r4,r4,-752
 32437cc:	e17ffe17 	ldw	r5,-8(fp)
 32437d0:	e1bfff17 	ldw	r6,-4(fp)
 32437d4:	3206adc0 	call	3206adc <printf>
      ifaces_found, ifaces_found==1?"":"s");

   return ifaces_found;
 32437d8:	e0bffe17 	ldw	r2,-8(fp)
}
 32437dc:	e037883a 	mov	sp,fp
 32437e0:	dfc00117 	ldw	ra,4(sp)
 32437e4:	df000017 	ldw	fp,0(sp)
 32437e8:	dec00204 	addi	sp,sp,8
 32437ec:	f800283a 	ret

032437f0 <netexit>:
 * RETURNS: SHould not return
 */

void
netexit(int err)      /* exit error level */
{
 32437f0:	defffd04 	addi	sp,sp,-12
 32437f4:	dfc00215 	stw	ra,8(sp)
 32437f8:	df000115 	stw	fp,4(sp)
 32437fc:	df000104 	addi	fp,sp,4
 3243800:	e13fff15 	stw	r4,-4(fp)
   net_system_exit = TRUE; /* set flag for shutting down */
 3243804:	00800044 	movi	r2,1
 3243808:	d0a90215 	stw	r2,-23544(gp)
   ip_exit();  /* do the exit_hook()ed stuff */
 324380c:	3223c880 	call	3223c88 <ip_exit>

   PORT_EXIT_FUNC(err);    /* should not return! */
 3243810:	e13fff17 	ldw	r4,-4(fp)
 3243814:	324b8fc0 	call	324b8fc <exit>

03243818 <evtmap_setup>:
 * INPUT: None.
 * OUTPUT: None
 */
 
void evtmap_setup (void)
{
 3243818:	deffff04 	addi	sp,sp,-4
 324381c:	df000015 	stw	fp,0(sp)
 3243820:	d839883a 	mov	fp,sp
#ifdef SOCK_MAP_EVENTS
   so_evtmap = TRUE;
   so_evtmap_create = evtmap_create;
   so_evtmap_delete = evtmap_delete;
#else
   so_evtmap = FALSE;
 3243824:	d0290505 	stb	zero,-23532(gp)
   so_evtmap_create = 0;
 3243828:	d0290315 	stw	zero,-23540(gp)
   so_evtmap_delete = 0;
 324382c:	d0290415 	stw	zero,-23536(gp)
#endif   /* SOCK_MAP_EVENTS */ 

}
 3243830:	e037883a 	mov	sp,fp
 3243834:	df000017 	ldw	fp,0(sp)
 3243838:	dec00104 	addi	sp,sp,4
 324383c:	f800283a 	ret

03243840 <ip_raw_open>:
ip_raw_open(u_char prot,
            ip_addr laddr,
            ip_addr faddr,
            int (*handler)(PACKET, void *),
            void * data)
{
 3243840:	defff804 	addi	sp,sp,-32
 3243844:	dfc00715 	stw	ra,28(sp)
 3243848:	df000615 	stw	fp,24(sp)
 324384c:	df000604 	addi	fp,sp,24
 3243850:	e17ffc15 	stw	r5,-16(fp)
 3243854:	e1bffd15 	stw	r6,-12(fp)
 3243858:	e1fffe15 	stw	r7,-8(fp)
 324385c:	e13ffb05 	stb	r4,-20(fp)
   struct ipraw_ep * ep;

   LOCK_NET_RESOURCE(NET_RESID);
 3243860:	0009883a 	mov	r4,zero
 3243864:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>

   /* allocate a structure for the endpoint */
   ep = (struct ipraw_ep *)IEP_ALLOC(sizeof(struct ipraw_ep));
 3243868:	01000604 	movi	r4,24
 324386c:	322b5d00 	call	322b5d0 <npalloc>
 3243870:	e0bffa15 	stw	r2,-24(fp)
   if (ep == NULL)
 3243874:	e0bffa17 	ldw	r2,-24(fp)
 3243878:	1004c03a 	cmpne	r2,r2,zero
 324387c:	10000e1e 	bne	r2,zero,32438b8 <ip_raw_open+0x78>
   {
#ifdef NPDEBUG
      if (NDEBUG & INFOMSG)
 3243880:	0080c974 	movhi	r2,805
 3243884:	10923104 	addi	r2,r2,18628
 3243888:	10800017 	ldw	r2,0(r2)
 324388c:	1080010c 	andi	r2,r2,4
 3243890:	1005003a 	cmpeq	r2,r2,zero
 3243894:	1000031e 	bne	r2,zero,32438a4 <ip_raw_open+0x64>
         dprintf("IP: Couldn't allocate ep storage.\n");
 3243898:	0100c974 	movhi	r4,805
 324389c:	213f4f04 	addi	r4,r4,-708
 32438a0:	3206e040 	call	3206e04 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 32438a4:	0009883a 	mov	r4,zero
 32438a8:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return ep;
 32438ac:	e0bffa17 	ldw	r2,-24(fp)
 32438b0:	e0bfff15 	stw	r2,-4(fp)
 32438b4:	00001806 	br	3243918 <ip_raw_open+0xd8>
   }

   /* fill it in with the caller's requested binding */
   ep->ipr_laddr = laddr;
 32438b8:	e0fffa17 	ldw	r3,-24(fp)
 32438bc:	e0bffc17 	ldw	r2,-16(fp)
 32438c0:	18800115 	stw	r2,4(r3)
   ep->ipr_faddr = faddr;
 32438c4:	e0fffa17 	ldw	r3,-24(fp)
 32438c8:	e0bffd17 	ldw	r2,-12(fp)
 32438cc:	18800215 	stw	r2,8(r3)
   ep->ipr_prot = prot;
 32438d0:	e0fffa17 	ldw	r3,-24(fp)
 32438d4:	e0bffb03 	ldbu	r2,-20(fp)
 32438d8:	18800505 	stb	r2,20(r3)
   ep->ipr_rcv = handler;
 32438dc:	e0fffa17 	ldw	r3,-24(fp)
 32438e0:	e0bffe17 	ldw	r2,-8(fp)
 32438e4:	18800315 	stw	r2,12(r3)
   ep->ipr_data = data;
 32438e8:	e0fffa17 	ldw	r3,-24(fp)
 32438ec:	e0800217 	ldw	r2,8(fp)
 32438f0:	18800415 	stw	r2,16(r3)

   /* link it into the list 
    * (at the head, because that's simple and fast) 
    */
   ep->ipr_next = ipraw_eps;
 32438f4:	d0e90617 	ldw	r3,-23528(gp)
 32438f8:	e0bffa17 	ldw	r2,-24(fp)
 32438fc:	10c00015 	stw	r3,0(r2)
   ipraw_eps = ep;
 3243900:	e0bffa17 	ldw	r2,-24(fp)
 3243904:	d0a90615 	stw	r2,-23528(gp)

   /* and return the pointer to the endpoint */
   UNLOCK_NET_RESOURCE(NET_RESID);
 3243908:	0009883a 	mov	r4,zero
 324390c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   return ep;
 3243910:	e0bffa17 	ldw	r2,-24(fp)
 3243914:	e0bfff15 	stw	r2,-4(fp)
 3243918:	e0bfff17 	ldw	r2,-4(fp)
}
 324391c:	e037883a 	mov	sp,fp
 3243920:	dfc00117 	ldw	ra,4(sp)
 3243924:	df000017 	ldw	fp,0(sp)
 3243928:	dec00204 	addi	sp,sp,8
 324392c:	f800283a 	ret

03243930 <ip_raw_close>:
 *                               that is to be closed
 * RETURNS: void
 */
void
ip_raw_close(struct ipraw_ep * ep)
{
 3243930:	defffb04 	addi	sp,sp,-20
 3243934:	dfc00415 	stw	ra,16(sp)
 3243938:	df000315 	stw	fp,12(sp)
 324393c:	df000304 	addi	fp,sp,12
 3243940:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * prev_ep;
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);
 3243944:	0009883a 	mov	r4,zero
 3243948:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 324394c:	e03ffe15 	stw	zero,-8(fp)
 3243950:	d0a90617 	ldw	r2,-23528(gp)
 3243954:	e0bffd15 	stw	r2,-12(fp)
        curr_ep != NULL;
 3243958:	00000806 	br	324397c <ip_raw_close+0x4c>
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
 324395c:	e0fffd17 	ldw	r3,-12(fp)
 3243960:	e0bfff17 	ldw	r2,-4(fp)
 3243964:	18800826 	beq	r3,r2,3243988 <ip_raw_close+0x58>
         break;
      prev_ep = curr_ep;
 3243968:	e0bffd17 	ldw	r2,-12(fp)
 324396c:	e0bffe15 	stw	r2,-8(fp)
   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
 3243970:	e0bffd17 	ldw	r2,-12(fp)
 3243974:	10800017 	ldw	r2,0(r2)
 3243978:	e0bffd15 	stw	r2,-12(fp)

   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
 324397c:	e0bffd17 	ldw	r2,-12(fp)
 3243980:	1004c03a 	cmpne	r2,r2,zero
 3243984:	103ff51e 	bne	r2,zero,324395c <ip_raw_close+0x2c>
         break;
      prev_ep = curr_ep;
   }

   /* if we didn't find it, we can't close it, so just return */
   if (curr_ep == NULL)
 3243988:	e0bffd17 	ldw	r2,-12(fp)
 324398c:	1004c03a 	cmpne	r2,r2,zero
 3243990:	1000041e 	bne	r2,zero,32439a4 <ip_raw_close+0x74>
   {
#ifdef NPDEBUG
      /* caller passed pointer to endpoint not in list 
       * -- not fatal, but may be programming error
       */
      dtrap();
 3243994:	322ab8c0 	call	322ab8c <dtrap>
#endif /* NPDEBUG */
      UNLOCK_NET_RESOURCE(NET_RESID);
 3243998:	0009883a 	mov	r4,zero
 324399c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return;
 32439a0:	00000e06 	br	32439dc <ip_raw_close+0xac>
   }

   /* unlink it from the list */
   if (prev_ep)
 32439a4:	e0bffe17 	ldw	r2,-8(fp)
 32439a8:	1005003a 	cmpeq	r2,r2,zero
 32439ac:	1000041e 	bne	r2,zero,32439c0 <ip_raw_close+0x90>
      prev_ep = curr_ep->ipr_next;
 32439b0:	e0bffd17 	ldw	r2,-12(fp)
 32439b4:	10800017 	ldw	r2,0(r2)
 32439b8:	e0bffe15 	stw	r2,-8(fp)
 32439bc:	00000306 	br	32439cc <ip_raw_close+0x9c>
   else
      ipraw_eps = curr_ep->ipr_next;
 32439c0:	e0bffd17 	ldw	r2,-12(fp)
 32439c4:	10800017 	ldw	r2,0(r2)
 32439c8:	d0a90615 	stw	r2,-23528(gp)

   /* free its storage */
   IEP_FREE(curr_ep);
 32439cc:	e13ffd17 	ldw	r4,-12(fp)
 32439d0:	322b6c40 	call	322b6c4 <npfree>

   /* and return */
   UNLOCK_NET_RESOURCE(NET_RESID);
 32439d4:	0009883a 	mov	r4,zero
 32439d8:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
}
 32439dc:	e037883a 	mov	sp,fp
 32439e0:	dfc00117 	ldw	ra,4(sp)
 32439e4:	df000017 	ldw	fp,0(sp)
 32439e8:	dec00204 	addi	sp,sp,8
 32439ec:	f800283a 	ret

032439f0 <ip_raw_input>:
 *          freed); else an error code indicating that the
 *          received packet was not accepted/processed
 */
int
ip_raw_input(PACKET p)
{
 32439f0:	defff604 	addi	sp,sp,-40
 32439f4:	dfc00915 	stw	ra,36(sp)
 32439f8:	df000815 	stw	fp,32(sp)
 32439fc:	df000804 	addi	fp,sp,32
 3243a00:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;              /* the internet header */
   struct ipraw_ep * ep;
   struct ipraw_ep * next_ep;
   struct ipraw_ep * matched_ep = NULL;
 3243a04:	e03ffb15 	stw	zero,-20(fp)
   int err;
   int delivered;

   /* start out expecting to not deliver the packet */
   delivered = 0;
 3243a08:	e03ff915 	stw	zero,-28(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);
 3243a0c:	e0bfff17 	ldw	r2,-4(fp)
 3243a10:	10800317 	ldw	r2,12(r2)
 3243a14:	e0bffe15 	stw	r2,-8(fp)

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 3243a18:	d0a90617 	ldw	r2,-23528(gp)
 3243a1c:	e0bffd15 	stw	r2,-12(fp)
 3243a20:	00004d06 	br	3243b58 <ip_raw_input+0x168>
   {
      /* keep track of next endpoint -- defense against upcall
       * function closing its own endpoint
       */
      next_ep = ep->ipr_next;
 3243a24:	e0bffd17 	ldw	r2,-12(fp)
 3243a28:	10800017 	ldw	r2,0(r2)
 3243a2c:	e0bffc15 	stw	r2,-16(fp)

      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
 3243a30:	e0bffd17 	ldw	r2,-12(fp)
 3243a34:	10800503 	ldbu	r2,20(r2)
 3243a38:	10803fcc 	andi	r2,r2,255
 3243a3c:	1005003a 	cmpeq	r2,r2,zero
 3243a40:	1000071e 	bne	r2,zero,3243a60 <ip_raw_input+0x70>
 3243a44:	e0bffd17 	ldw	r2,-12(fp)
 3243a48:	10c00503 	ldbu	r3,20(r2)
 3243a4c:	e0bffe17 	ldw	r2,-8(fp)
 3243a50:	10800243 	ldbu	r2,9(r2)
 3243a54:	18c03fcc 	andi	r3,r3,255
 3243a58:	10803fcc 	andi	r2,r2,255
 3243a5c:	18803c1e 	bne	r3,r2,3243b50 <ip_raw_input+0x160>
         continue;
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
 3243a60:	e0bffd17 	ldw	r2,-12(fp)
 3243a64:	10800117 	ldw	r2,4(r2)
 3243a68:	1005003a 	cmpeq	r2,r2,zero
 3243a6c:	1000051e 	bne	r2,zero,3243a84 <ip_raw_input+0x94>
 3243a70:	e0bffd17 	ldw	r2,-12(fp)
 3243a74:	10c00117 	ldw	r3,4(r2)
 3243a78:	e0bffe17 	ldw	r2,-8(fp)
 3243a7c:	10800417 	ldw	r2,16(r2)
 3243a80:	1880331e 	bne	r3,r2,3243b50 <ip_raw_input+0x160>
         continue;
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
 3243a84:	e0bffd17 	ldw	r2,-12(fp)
 3243a88:	10800217 	ldw	r2,8(r2)
 3243a8c:	1005003a 	cmpeq	r2,r2,zero
 3243a90:	1000051e 	bne	r2,zero,3243aa8 <ip_raw_input+0xb8>
 3243a94:	e0bffd17 	ldw	r2,-12(fp)
 3243a98:	10c00217 	ldw	r3,8(r2)
 3243a9c:	e0bffe17 	ldw	r2,-8(fp)
 3243aa0:	10800317 	ldw	r2,12(r2)
 3243aa4:	18802a1e 	bne	r3,r2,3243b50 <ip_raw_input+0x160>
         continue;

      /* if the endpoint has a receive upcall function, 
       * keep track of the endpoint
       */
      if (ep->ipr_rcv != NULL)
 3243aa8:	e0bffd17 	ldw	r2,-12(fp)
 3243aac:	10800317 	ldw	r2,12(r2)
 3243ab0:	1005003a 	cmpeq	r2,r2,zero
 3243ab4:	1000261e 	bne	r2,zero,3243b50 <ip_raw_input+0x160>
          * copy the packet into a new buffer,
          * and pass the new copy to the previously matched 
          * endpoint's upcall function 
          * before we forget the previous endpoint
          */
         if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 3243ab8:	e0bffb17 	ldw	r2,-20(fp)
 3243abc:	1005003a 	cmpeq	r2,r2,zero
 3243ac0:	1000211e 	bne	r2,zero,3243b48 <ip_raw_input+0x158>
 3243ac4:	e0bffb17 	ldw	r2,-20(fp)
 3243ac8:	10800317 	ldw	r2,12(r2)
 3243acc:	1005003a 	cmpeq	r2,r2,zero
 3243ad0:	10001d1e 	bne	r2,zero,3243b48 <ip_raw_input+0x158>
         {
            PACKET p2;

            p2 = ip_copypkt(p);
 3243ad4:	e13fff17 	ldw	r4,-4(fp)
 3243ad8:	324075c0 	call	324075c <ip_copypkt>
 3243adc:	e0bff815 	stw	r2,-32(fp)
            if (p2)
 3243ae0:	e0bff817 	ldw	r2,-32(fp)
 3243ae4:	1005003a 	cmpeq	r2,r2,zero
 3243ae8:	1000171e 	bne	r2,zero,3243b48 <ip_raw_input+0x158>
            {
               UNLOCK_NET_RESOURCE(NET_RESID);
 3243aec:	0009883a 	mov	r4,zero
 3243af0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
               err = ((*matched_ep->ipr_rcv)(p2, matched_ep->ipr_data));
 3243af4:	e0bffb17 	ldw	r2,-20(fp)
 3243af8:	10c00317 	ldw	r3,12(r2)
 3243afc:	e0bffb17 	ldw	r2,-20(fp)
 3243b00:	11400417 	ldw	r5,16(r2)
 3243b04:	e13ff817 	ldw	r4,-32(fp)
 3243b08:	183ee83a 	callr	r3
 3243b0c:	e0bffa15 	stw	r2,-24(fp)
               LOCK_NET_RESOURCE(NET_RESID);
 3243b10:	0009883a 	mov	r4,zero
 3243b14:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
               if (err)
 3243b18:	e0bffa17 	ldw	r2,-24(fp)
 3243b1c:	1005003a 	cmpeq	r2,r2,zero
 3243b20:	1000071e 	bne	r2,zero,3243b40 <ip_raw_input+0x150>
               {
                  LOCK_NET_RESOURCE(FREEQ_RESID);
 3243b24:	01000084 	movi	r4,2
 3243b28:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
                  pk_free(p2);
 3243b2c:	e13ff817 	ldw	r4,-32(fp)
 3243b30:	322a2dc0 	call	322a2dc <pk_free>
                  UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3243b34:	01000084 	movi	r4,2
 3243b38:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
 3243b3c:	00000206 	br	3243b48 <ip_raw_input+0x158>
               }
               else
                  delivered = 1;
 3243b40:	00800044 	movi	r2,1
 3243b44:	e0bff915 	stw	r2,-28(fp)
            }
         }
         matched_ep = ep;
 3243b48:	e0bffd17 	ldw	r2,-12(fp)
 3243b4c:	e0bffb15 	stw	r2,-20(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 3243b50:	e0bffc17 	ldw	r2,-16(fp)
 3243b54:	e0bffd15 	stw	r2,-12(fp)
 3243b58:	e0bffd17 	ldw	r2,-12(fp)
 3243b5c:	1004c03a 	cmpne	r2,r2,zero
 3243b60:	103fb01e 	bne	r2,zero,3243a24 <ip_raw_input+0x34>
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 3243b64:	e0bffb17 	ldw	r2,-20(fp)
 3243b68:	1005003a 	cmpeq	r2,r2,zero
 3243b6c:	1000151e 	bne	r2,zero,3243bc4 <ip_raw_input+0x1d4>
 3243b70:	e0bffb17 	ldw	r2,-20(fp)
 3243b74:	10800317 	ldw	r2,12(r2)
 3243b78:	1005003a 	cmpeq	r2,r2,zero
 3243b7c:	1000111e 	bne	r2,zero,3243bc4 <ip_raw_input+0x1d4>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 3243b80:	0009883a 	mov	r4,zero
 3243b84:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
 3243b88:	e0bffb17 	ldw	r2,-20(fp)
 3243b8c:	10c00317 	ldw	r3,12(r2)
 3243b90:	e0bffb17 	ldw	r2,-20(fp)
 3243b94:	11400417 	ldw	r5,16(r2)
 3243b98:	e13fff17 	ldw	r4,-4(fp)
 3243b9c:	183ee83a 	callr	r3
 3243ba0:	e0bffa15 	stw	r2,-24(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 3243ba4:	0009883a 	mov	r4,zero
 3243ba8:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      if (err == 0)
 3243bac:	e0bffa17 	ldw	r2,-24(fp)
 3243bb0:	1004c03a 	cmpne	r2,r2,zero
 3243bb4:	10000c1e 	bne	r2,zero,3243be8 <ip_raw_input+0x1f8>
         delivered = 1;
 3243bb8:	00800044 	movi	r2,1
 3243bbc:	e0bff915 	stw	r2,-28(fp)
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 3243bc0:	00000906 	br	3243be8 <ip_raw_input+0x1f8>
      if (err == 0)
         delivered = 1;
   }
   else
   {
      err = ENP_PARAM;
 3243bc4:	00bffd84 	movi	r2,-10
 3243bc8:	e0bffa15 	stw	r2,-24(fp)
      ip_mib.ipUnknownProtos++;
 3243bcc:	0080c9b4 	movhi	r2,806
 3243bd0:	10b46004 	addi	r2,r2,-11904
 3243bd4:	10800617 	ldw	r2,24(r2)
 3243bd8:	10c00044 	addi	r3,r2,1
 3243bdc:	0080c9b4 	movhi	r2,806
 3243be0:	10b46004 	addi	r2,r2,-11904
 3243be4:	10c00615 	stw	r3,24(r2)
   }

   if (!delivered)
 3243be8:	e0bff917 	ldw	r2,-28(fp)
 3243bec:	1004c03a 	cmpne	r2,r2,zero
 3243bf0:	1000071e 	bne	r2,zero,3243c10 <ip_raw_input+0x220>
      ip_mib.ipInDelivers--;
 3243bf4:	0080c9b4 	movhi	r2,806
 3243bf8:	10b46004 	addi	r2,r2,-11904
 3243bfc:	10800817 	ldw	r2,32(r2)
 3243c00:	10ffffc4 	addi	r3,r2,-1
 3243c04:	0080c9b4 	movhi	r2,806
 3243c08:	10b46004 	addi	r2,r2,-11904
 3243c0c:	10c00815 	stw	r3,32(r2)

   return err;
 3243c10:	e0bffa17 	ldw	r2,-24(fp)
}
 3243c14:	e037883a 	mov	sp,fp
 3243c18:	dfc00117 	ldw	ra,4(sp)
 3243c1c:	df000017 	ldw	fp,0(sp)
 3243c20:	dec00204 	addi	sp,sp,8
 3243c24:	f800283a 	ret

03243c28 <ip_raw_alloc>:
 *          inclhdr is zero.
 */

PACKET
ip_raw_alloc(int reqlen, int hdrincl)
{
 3243c28:	defffa04 	addi	sp,sp,-24
 3243c2c:	dfc00515 	stw	ra,20(sp)
 3243c30:	df000415 	stw	fp,16(sp)
 3243c34:	df000404 	addi	fp,sp,16
 3243c38:	e13ffe15 	stw	r4,-8(fp)
 3243c3c:	e17fff15 	stw	r5,-4(fp)
   int len;
   PACKET p;

   len = (reqlen + 1) & ~1;
 3243c40:	e0bffe17 	ldw	r2,-8(fp)
 3243c44:	10c00044 	addi	r3,r2,1
 3243c48:	00bfff84 	movi	r2,-2
 3243c4c:	1884703a 	and	r2,r3,r2
 3243c50:	e0bffd15 	stw	r2,-12(fp)
   if (!hdrincl)
 3243c54:	e0bfff17 	ldw	r2,-4(fp)
 3243c58:	1004c03a 	cmpne	r2,r2,zero
 3243c5c:	1000031e 	bne	r2,zero,3243c6c <ip_raw_alloc+0x44>
      len += IPHSIZ;
 3243c60:	e0bffd17 	ldw	r2,-12(fp)
 3243c64:	10800504 	addi	r2,r2,20
 3243c68:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 3243c6c:	01000084 	movi	r4,2
 3243c70:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   p = pk_alloc(len + MaxLnh);
 3243c74:	0080c974 	movhi	r2,805
 3243c78:	10922f04 	addi	r2,r2,18620
 3243c7c:	10c00017 	ldw	r3,0(r2)
 3243c80:	e0bffd17 	ldw	r2,-12(fp)
 3243c84:	1885883a 	add	r2,r3,r2
 3243c88:	1009883a 	mov	r4,r2
 3243c8c:	3229f480 	call	3229f48 <pk_alloc>
 3243c90:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3243c94:	01000084 	movi	r4,2
 3243c98:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   if (p)
 3243c9c:	e0bffc17 	ldw	r2,-16(fp)
 3243ca0:	1005003a 	cmpeq	r2,r2,zero
 3243ca4:	10000d1e 	bne	r2,zero,3243cdc <ip_raw_alloc+0xb4>
   {
      if (!hdrincl)
 3243ca8:	e0bfff17 	ldw	r2,-4(fp)
 3243cac:	1004c03a 	cmpne	r2,r2,zero
 3243cb0:	10000a1e 	bne	r2,zero,3243cdc <ip_raw_alloc+0xb4>
      {
         p->nb_prot += IPHSIZ;
 3243cb4:	e0bffc17 	ldw	r2,-16(fp)
 3243cb8:	10800317 	ldw	r2,12(r2)
 3243cbc:	10c00504 	addi	r3,r2,20
 3243cc0:	e0bffc17 	ldw	r2,-16(fp)
 3243cc4:	10c00315 	stw	r3,12(r2)
         p->nb_plen -= IPHSIZ;
 3243cc8:	e0bffc17 	ldw	r2,-16(fp)
 3243ccc:	10800417 	ldw	r2,16(r2)
 3243cd0:	10fffb04 	addi	r3,r2,-20
 3243cd4:	e0bffc17 	ldw	r2,-16(fp)
 3243cd8:	10c00415 	stw	r3,16(r2)
      }
   }
   return p;
 3243cdc:	e0bffc17 	ldw	r2,-16(fp)
}
 3243ce0:	e037883a 	mov	sp,fp
 3243ce4:	dfc00117 	ldw	ra,4(sp)
 3243ce8:	df000017 	ldw	fp,0(sp)
 3243cec:	dec00204 	addi	sp,sp,8
 3243cf0:	f800283a 	ret

03243cf4 <ip_raw_free>:
 * RETURNS: void
 */

void
ip_raw_free(PACKET p)
{
 3243cf4:	defffd04 	addi	sp,sp,-12
 3243cf8:	dfc00215 	stw	ra,8(sp)
 3243cfc:	df000115 	stw	fp,4(sp)
 3243d00:	df000104 	addi	fp,sp,4
 3243d04:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 3243d08:	01000084 	movi	r4,2
 3243d0c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   pk_free(p);
 3243d10:	e13fff17 	ldw	r4,-4(fp)
 3243d14:	322a2dc0 	call	322a2dc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3243d18:	01000084 	movi	r4,2
 3243d1c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
}
 3243d20:	e037883a 	mov	sp,fp
 3243d24:	dfc00117 	ldw	ra,4(sp)
 3243d28:	df000017 	ldw	fp,0(sp)
 3243d2c:	dec00204 	addi	sp,sp,8
 3243d30:	f800283a 	ret

03243d34 <ip_raw_maxalloc>:
 *          for 
 */

int
ip_raw_maxalloc(int hdrincl)
{
 3243d34:	defffd04 	addi	sp,sp,-12
 3243d38:	df000215 	stw	fp,8(sp)
 3243d3c:	df000204 	addi	fp,sp,8
 3243d40:	e13fff15 	stw	r4,-4(fp)
   int len;

   len = bigbufsiz - MaxLnh;
 3243d44:	0080c974 	movhi	r2,805
 3243d48:	1089ac04 	addi	r2,r2,9904
 3243d4c:	10c00017 	ldw	r3,0(r2)
 3243d50:	0080c974 	movhi	r2,805
 3243d54:	10922f04 	addi	r2,r2,18620
 3243d58:	10800017 	ldw	r2,0(r2)
 3243d5c:	1885c83a 	sub	r2,r3,r2
 3243d60:	e0bffe15 	stw	r2,-8(fp)
   if (!hdrincl)
 3243d64:	e0bfff17 	ldw	r2,-4(fp)
 3243d68:	1004c03a 	cmpne	r2,r2,zero
 3243d6c:	1000031e 	bne	r2,zero,3243d7c <ip_raw_maxalloc+0x48>
      len -= IPHSIZ;
 3243d70:	e0bffe17 	ldw	r2,-8(fp)
 3243d74:	10bffb04 	addi	r2,r2,-20
 3243d78:	e0bffe15 	stw	r2,-8(fp)
   return len;
 3243d7c:	e0bffe17 	ldw	r2,-8(fp)
}
 3243d80:	e037883a 	mov	sp,fp
 3243d84:	df000017 	ldw	fp,0(sp)
 3243d88:	dec00104 	addi	sp,sp,4
 3243d8c:	f800283a 	ret

03243d90 <rt_lookup>:
 * entry was found.
 */

RTMIB
rt_lookup(ip_addr host)
{
 3243d90:	defff804 	addi	sp,sp,-32
 3243d94:	df000715 	stw	fp,28(sp)
 3243d98:	df000704 	addi	fp,sp,28
 3243d9c:	e13fff15 	stw	r4,-4(fp)
   RTMIB    rtp;
   RTMIB    netmatch;
   unsigned char max_bits_matched = 0;
 3243da0:	e03ffc45 	stb	zero,-15(fp)
   unsigned char curr_bits_matched;
   ip_addr  entry_mask;
   unsigned long int bitcount_mask;
   unsigned long int extracted_bit;

   netmatch = NULL;
 3243da4:	e03ffd15 	stw	zero,-12(fp)

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 3243da8:	0080c974 	movhi	r2,805
 3243dac:	10927404 	addi	r2,r2,18896
 3243db0:	10800017 	ldw	r2,0(r2)
 3243db4:	e0bffe15 	stw	r2,-8(fp)
 3243db8:	00003e06 	br	3243eb4 <rt_lookup+0x124>
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
 3243dbc:	e0bffe17 	ldw	r2,-8(fp)
 3243dc0:	10800617 	ldw	r2,24(r2)
 3243dc4:	1005003a 	cmpeq	r2,r2,zero
 3243dc8:	1000371e 	bne	r2,zero,3243ea8 <rt_lookup+0x118>
#ifdef RIP_SUPPORT
      /* skip RIP private entries */
      if (rtp->ipRouteFlags & RIP_PRIVATE)
         continue;
#endif
      entry_mask = rtp->ipRouteMask;
 3243dcc:	e0bffe17 	ldw	r2,-8(fp)
 3243dd0:	10800a17 	ldw	r2,40(r2)
 3243dd4:	e0bffb15 	stw	r2,-20(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
 3243dd8:	e0bffe17 	ldw	r2,-8(fp)
 3243ddc:	10c00017 	ldw	r3,0(r2)
 3243de0:	e0bffb17 	ldw	r2,-20(fp)
 3243de4:	1888703a 	and	r4,r3,r2
 3243de8:	e0ffff17 	ldw	r3,-4(fp)
 3243dec:	e0bffb17 	ldw	r2,-20(fp)
 3243df0:	1884703a 	and	r2,r3,r2
 3243df4:	20802c1e 	bne	r4,r2,3243ea8 <rt_lookup+0x118>
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 3243df8:	e03ffc05 	stb	zero,-16(fp)
 3243dfc:	00a00034 	movhi	r2,32768
 3243e00:	e0bffa15 	stw	r2,-24(fp)
 3243e04:	00001b06 	br	3243e74 <rt_lookup+0xe4>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
 3243e08:	e0bffb17 	ldw	r2,-20(fp)
 3243e0c:	1004d63a 	srli	r2,r2,24
 3243e10:	10c03fcc 	andi	r3,r2,255
 3243e14:	e0bffb17 	ldw	r2,-20(fp)
 3243e18:	1004d23a 	srli	r2,r2,8
 3243e1c:	10bfc00c 	andi	r2,r2,65280
 3243e20:	1886b03a 	or	r3,r3,r2
 3243e24:	e0bffb17 	ldw	r2,-20(fp)
 3243e28:	10bfc00c 	andi	r2,r2,65280
 3243e2c:	1004923a 	slli	r2,r2,8
 3243e30:	1886b03a 	or	r3,r3,r2
 3243e34:	e0bffb17 	ldw	r2,-20(fp)
 3243e38:	10803fcc 	andi	r2,r2,255
 3243e3c:	1004963a 	slli	r2,r2,24
 3243e40:	1886b03a 	or	r3,r3,r2
 3243e44:	e0bffa17 	ldw	r2,-24(fp)
 3243e48:	1884703a 	and	r2,r3,r2
 3243e4c:	e0bff915 	stw	r2,-28(fp)
            if (extracted_bit) ++curr_bits_matched;
 3243e50:	e0bff917 	ldw	r2,-28(fp)
 3243e54:	1005003a 	cmpeq	r2,r2,zero
 3243e58:	1000031e 	bne	r2,zero,3243e68 <rt_lookup+0xd8>
 3243e5c:	e0bffc03 	ldbu	r2,-16(fp)
 3243e60:	10800044 	addi	r2,r2,1
 3243e64:	e0bffc05 	stb	r2,-16(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 3243e68:	e0bffa17 	ldw	r2,-24(fp)
 3243e6c:	1004d07a 	srli	r2,r2,1
 3243e70:	e0bffa15 	stw	r2,-24(fp)
 3243e74:	e0bffa17 	ldw	r2,-24(fp)
 3243e78:	1004c03a 	cmpne	r2,r2,zero
 3243e7c:	103fe21e 	bne	r2,zero,3243e08 <rt_lookup+0x78>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
            if (extracted_bit) ++curr_bits_matched;
         }
         if (curr_bits_matched > max_bits_matched)
 3243e80:	e0fffc03 	ldbu	r3,-16(fp)
 3243e84:	e0bffc43 	ldbu	r2,-15(fp)
 3243e88:	10c0072e 	bgeu	r2,r3,3243ea8 <rt_lookup+0x118>
         {
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
 3243e8c:	e0bffc03 	ldbu	r2,-16(fp)
 3243e90:	e0bffc45 	stb	r2,-15(fp)
            netmatch = rtp;
 3243e94:	e0bffe17 	ldw	r2,-8(fp)
 3243e98:	e0bffd15 	stw	r2,-12(fp)
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
 3243e9c:	e0bffc43 	ldbu	r2,-15(fp)
 3243ea0:	10800820 	cmpeqi	r2,r2,32
 3243ea4:	10000e1e 	bne	r2,zero,3243ee0 <rt_lookup+0x150>
   unsigned long int extracted_bit;

   netmatch = NULL;

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 3243ea8:	e0bffe17 	ldw	r2,-8(fp)
 3243eac:	10800f04 	addi	r2,r2,60
 3243eb0:	e0bffe15 	stw	r2,-8(fp)
 3243eb4:	0080c974 	movhi	r2,805
 3243eb8:	1089c404 	addi	r2,r2,10000
 3243ebc:	10800017 	ldw	r2,0(r2)
 3243ec0:	10800f24 	muli	r2,r2,60
 3243ec4:	1007883a 	mov	r3,r2
 3243ec8:	0080c974 	movhi	r2,805
 3243ecc:	10927404 	addi	r2,r2,18896
 3243ed0:	10800017 	ldw	r2,0(r2)
 3243ed4:	1887883a 	add	r3,r3,r2
 3243ed8:	e0bffe17 	ldw	r2,-8(fp)
 3243edc:	10ffb736 	bltu	r2,r3,3243dbc <rt_lookup+0x2c>
               break;
         }
      }
   }

   if (netmatch)
 3243ee0:	e0bffd17 	ldw	r2,-12(fp)
 3243ee4:	1005003a 	cmpeq	r2,r2,zero
 3243ee8:	1000051e 	bne	r2,zero,3243f00 <rt_lookup+0x170>
      netmatch->ipRouteAge = cticks;   /* timestamp entry we used */
 3243eec:	0080c974 	movhi	r2,805
 3243ef0:	10925604 	addi	r2,r2,18776
 3243ef4:	10c00017 	ldw	r3,0(r2)
 3243ef8:	e0bffd17 	ldw	r2,-12(fp)
 3243efc:	10c00915 	stw	r3,36(r2)

   return netmatch;
 3243f00:	e0bffd17 	ldw	r2,-12(fp)
}
 3243f04:	e037883a 	mov	sp,fp
 3243f08:	df000017 	ldw	fp,0(sp)
 3243f0c:	dec00104 	addi	sp,sp,4
 3243f10:	f800283a 	ret

03243f14 <add_route>:
   ip_addr  dest,       /* ultimate destination */
   ip_addr  mask,       /* net mask, 0xFFFFFFFF if dest is host address */
   ip_addr  nexthop,    /* where to forward to */
   int      iface,      /* interface (net) for nexthop */
   int      prot)       /* how we know it: icmp, table, etc */
{
 3243f14:	defff604 	addi	sp,sp,-40
 3243f18:	dfc00915 	stw	ra,36(sp)
 3243f1c:	df000815 	stw	fp,32(sp)
 3243f20:	df000804 	addi	fp,sp,32
 3243f24:	e13ffb15 	stw	r4,-20(fp)
 3243f28:	e17ffc15 	stw	r5,-16(fp)
 3243f2c:	e1bffd15 	stw	r6,-12(fp)
 3243f30:	e1fffe15 	stw	r7,-8(fp)
   RTMIB rtp;           /* scratch route table entrry pointer */
   RTMIB newrt;         /* best entry for new route */
   struct net * ifp;    /* interface (net) for nexthop */

   newrt = NULL;     /* may be replaced with empty or more expendable entry */
 3243f34:	e03ff915 	stw	zero,-28(fp)
					 
   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   ifp = if_getbynum(iface);
 3243f38:	e13ffe17 	ldw	r4,-8(fp)
 3243f3c:	323e3580 	call	323e358 <if_getbynum>
 3243f40:	e0bff815 	stw	r2,-32(fp)
   if(!ifp)
 3243f44:	e0bff817 	ldw	r2,-32(fp)
 3243f48:	1004c03a 	cmpne	r2,r2,zero
 3243f4c:	1000021e 	bne	r2,zero,3243f58 <add_route+0x44>
      return NULL;
 3243f50:	e03fff15 	stw	zero,-4(fp)
 3243f54:	0000f306 	br	3244324 <add_route+0x410>

   if (rt_mib == NULL)
 3243f58:	0080c974 	movhi	r2,805
 3243f5c:	10927404 	addi	r2,r2,18896
 3243f60:	10800017 	ldw	r2,0(r2)
 3243f64:	1004c03a 	cmpne	r2,r2,zero
 3243f68:	1000021e 	bne	r2,zero,3243f74 <add_route+0x60>
      return NULL;
 3243f6c:	e03fff15 	stw	zero,-4(fp)
 3243f70:	0000ec06 	br	3244324 <add_route+0x410>

   /* Don't add null masks or IP addresses - they give false positives on
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
 3243f74:	e0bffb17 	ldw	r2,-20(fp)
 3243f78:	1005003a 	cmpeq	r2,r2,zero
 3243f7c:	1000031e 	bne	r2,zero,3243f8c <add_route+0x78>
 3243f80:	e0bffc17 	ldw	r2,-16(fp)
 3243f84:	1004c03a 	cmpne	r2,r2,zero
 3243f88:	1000241e 	bne	r2,zero,324401c <add_route+0x108>
   {
      dtrap();    /* bad configuration? */
 3243f8c:	322ab8c0 	call	322ab8c <dtrap>
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 3243f90:	e0bffb17 	ldw	r2,-20(fp)
 3243f94:	1004d63a 	srli	r2,r2,24
 3243f98:	10c03fcc 	andi	r3,r2,255
 3243f9c:	e0bffb17 	ldw	r2,-20(fp)
 3243fa0:	1004d23a 	srli	r2,r2,8
 3243fa4:	10bfc00c 	andi	r2,r2,65280
 3243fa8:	1886b03a 	or	r3,r3,r2
 3243fac:	e0bffb17 	ldw	r2,-20(fp)
 3243fb0:	10bfc00c 	andi	r2,r2,65280
 3243fb4:	1004923a 	slli	r2,r2,8
 3243fb8:	1886b03a 	or	r3,r3,r2
 3243fbc:	e0bffb17 	ldw	r2,-20(fp)
 3243fc0:	10803fcc 	andi	r2,r2,255
 3243fc4:	1004963a 	slli	r2,r2,24
 3243fc8:	188ab03a 	or	r5,r3,r2
 3243fcc:	e0bffc17 	ldw	r2,-16(fp)
 3243fd0:	1004d63a 	srli	r2,r2,24
 3243fd4:	10c03fcc 	andi	r3,r2,255
 3243fd8:	e0bffc17 	ldw	r2,-16(fp)
 3243fdc:	1004d23a 	srli	r2,r2,8
 3243fe0:	10bfc00c 	andi	r2,r2,65280
 3243fe4:	1886b03a 	or	r3,r3,r2
 3243fe8:	e0bffc17 	ldw	r2,-16(fp)
 3243fec:	10bfc00c 	andi	r2,r2,65280
 3243ff0:	1004923a 	slli	r2,r2,8
 3243ff4:	1886b03a 	or	r3,r3,r2
 3243ff8:	e0bffc17 	ldw	r2,-16(fp)
 3243ffc:	10803fcc 	andi	r2,r2,255
 3244000:	1004963a 	slli	r2,r2,24
 3244004:	188cb03a 	or	r6,r3,r2
 3244008:	0100c974 	movhi	r4,805
 324400c:	213f5804 	addi	r4,r4,-672
 3244010:	3206adc0 	call	3206adc <printf>
	      htonl(dest), htonl(mask) );
      return NULL;
 3244014:	e03fff15 	stw	zero,-4(fp)
 3244018:	0000c206 	br	3244324 <add_route+0x410>
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 324401c:	0080c974 	movhi	r2,805
 3244020:	10927404 	addi	r2,r2,18896
 3244024:	10800017 	ldw	r2,0(r2)
 3244028:	e0bffa15 	stw	r2,-24(fp)
 324402c:	00006f06 	br	32441ec <add_route+0x2d8>
   {
      if (rtp->ipRouteDest == dest) /* found existing entry for target */
 3244030:	e0bffa17 	ldw	r2,-24(fp)
 3244034:	10c00017 	ldw	r3,0(r2)
 3244038:	e0bffb17 	ldw	r2,-20(fp)
 324403c:	1880181e 	bne	r3,r2,32440a0 <add_route+0x18c>
      {
         rtp->ipRouteNextHop = nexthop;      /* fix entry */
 3244040:	e0fffa17 	ldw	r3,-24(fp)
 3244044:	e0bffd17 	ldw	r2,-12(fp)
 3244048:	18800615 	stw	r2,24(r3)
         rtp->ipRouteAge = cticks;           /* timestamp it */
 324404c:	0080c974 	movhi	r2,805
 3244050:	10925604 	addi	r2,r2,18776
 3244054:	10c00017 	ldw	r3,0(r2)
 3244058:	e0bffa17 	ldw	r2,-24(fp)
 324405c:	10c00915 	stw	r3,36(r2)
         /* set the rfc1213 1-based SNMP-ish interface index */
         rtp->ipRouteIfIndex = (long)(iface) + 1;
 3244060:	e0bffe17 	ldw	r2,-8(fp)
 3244064:	10c00044 	addi	r3,r2,1
 3244068:	e0bffa17 	ldw	r2,-24(fp)
 324406c:	10c00115 	stw	r3,4(r2)
         rtp->ipRouteProto = prot;           /* icmp, or whatever */
 3244070:	e0fffa17 	ldw	r3,-24(fp)
 3244074:	e0800217 	ldw	r2,8(fp)
 3244078:	18800815 	stw	r2,32(r3)
         rtp->ipRouteMask = mask;
 324407c:	e0fffa17 	ldw	r3,-24(fp)
 3244080:	e0bffc17 	ldw	r2,-16(fp)
 3244084:	18800a15 	stw	r2,40(r3)
         rtp->ifp = ifp;
 3244088:	e0fffa17 	ldw	r3,-24(fp)
 324408c:	e0bff817 	ldw	r2,-32(fp)
 3244090:	18800e15 	stw	r2,56(r3)
         return(rtp);   /* just update and exit */
 3244094:	e0bffa17 	ldw	r2,-24(fp)
 3244098:	e0bfff15 	stw	r2,-4(fp)
 324409c:	0000a106 	br	3244324 <add_route+0x410>
      }
      /* if we didn't find empty slot yet, look for good slot to recycle */
      if (!newrt || (newrt->ipRouteProto != 0))
 32440a0:	e0bff917 	ldw	r2,-28(fp)
 32440a4:	1005003a 	cmpeq	r2,r2,zero
 32440a8:	1000041e 	bne	r2,zero,32440bc <add_route+0x1a8>
 32440ac:	e0bff917 	ldw	r2,-28(fp)
 32440b0:	10800817 	ldw	r2,32(r2)
 32440b4:	1005003a 	cmpeq	r2,r2,zero
 32440b8:	1000491e 	bne	r2,zero,32441e0 <add_route+0x2cc>
      {
         if (!rtp->ipRouteNextHop)  /* found empty slot for use */
 32440bc:	e0bffa17 	ldw	r2,-24(fp)
 32440c0:	10800617 	ldw	r2,24(r2)
 32440c4:	1004c03a 	cmpne	r2,r2,zero
 32440c8:	1000051e 	bne	r2,zero,32440e0 <add_route+0x1cc>
         {
            newrt = rtp;   /* record empty route for use */
 32440cc:	e0bffa17 	ldw	r2,-24(fp)
 32440d0:	e0bff915 	stw	r2,-28(fp)
            newrt->ipRouteProto = 0;
 32440d4:	e0bff917 	ldw	r2,-28(fp)
 32440d8:	10000815 	stw	zero,32(r2)
            continue;
 32440dc:	00004006 	br	32441e0 <add_route+0x2cc>
         }
         /* else see if the new route has higher priority than this slot: */
         if (rtp_priority[prot] >= rtp_priority[rtp->ipRouteProto])
 32440e0:	e0c00217 	ldw	r3,8(fp)
 32440e4:	0080c974 	movhi	r2,805
 32440e8:	10891904 	addi	r2,r2,9316
 32440ec:	10c5883a 	add	r2,r2,r3
 32440f0:	11000003 	ldbu	r4,0(r2)
 32440f4:	e0bffa17 	ldw	r2,-24(fp)
 32440f8:	10c00817 	ldw	r3,32(r2)
 32440fc:	0080c974 	movhi	r2,805
 3244100:	10891904 	addi	r2,r2,9316
 3244104:	10c5883a 	add	r2,r2,r3
 3244108:	10800003 	ldbu	r2,0(r2)
 324410c:	20c03fcc 	andi	r3,r4,255
 3244110:	10803fcc 	andi	r2,r2,255
 3244114:	18803236 	bltu	r3,r2,32441e0 <add_route+0x2cc>
         {
            if (!newrt)
 3244118:	e0bff917 	ldw	r2,-28(fp)
 324411c:	1004c03a 	cmpne	r2,r2,zero
 3244120:	1000031e 	bne	r2,zero,3244130 <add_route+0x21c>
            {
               newrt = rtp;
 3244124:	e0bffa17 	ldw	r2,-24(fp)
 3244128:	e0bff915 	stw	r2,-28(fp)
               continue;
 324412c:	00002c06 	br	32441e0 <add_route+0x2cc>
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 3244130:	e0bffa17 	ldw	r2,-24(fp)
 3244134:	10c00817 	ldw	r3,32(r2)
 3244138:	0080c974 	movhi	r2,805
 324413c:	10891904 	addi	r2,r2,9316
 3244140:	10c5883a 	add	r2,r2,r3
 3244144:	11000003 	ldbu	r4,0(r2)
 3244148:	e0bff917 	ldw	r2,-28(fp)
 324414c:	10c00817 	ldw	r3,32(r2)
 3244150:	0080c974 	movhi	r2,805
 3244154:	10891904 	addi	r2,r2,9316
 3244158:	10c5883a 	add	r2,r2,r3
 324415c:	10800003 	ldbu	r2,0(r2)
 3244160:	20c03fcc 	andi	r3,r4,255
 3244164:	10803fcc 	andi	r2,r2,255
 3244168:	1880032e 	bgeu	r3,r2,3244178 <add_route+0x264>
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
 324416c:	e0bffa17 	ldw	r2,-24(fp)
 3244170:	e0bff915 	stw	r2,-28(fp)
 3244174:	00001a06 	br	32441e0 <add_route+0x2cc>
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 3244178:	e0bffa17 	ldw	r2,-24(fp)
 324417c:	10c00817 	ldw	r3,32(r2)
 3244180:	0080c974 	movhi	r2,805
 3244184:	10891904 	addi	r2,r2,9316
 3244188:	10c5883a 	add	r2,r2,r3
 324418c:	11000003 	ldbu	r4,0(r2)
 3244190:	e0bff917 	ldw	r2,-28(fp)
 3244194:	10c00817 	ldw	r3,32(r2)
 3244198:	0080c974 	movhi	r2,805
 324419c:	10891904 	addi	r2,r2,9316
 32441a0:	10c5883a 	add	r2,r2,r3
 32441a4:	10800003 	ldbu	r2,0(r2)
 32441a8:	20c03fcc 	andi	r3,r4,255
 32441ac:	10803fcc 	andi	r2,r2,255
 32441b0:	18800b1e 	bne	r3,r2,32441e0 <add_route+0x2cc>
                rtp_priority[newrt->ipRouteProto])
            {
               /* if equal priority, keep the older entry for deletion */
               if (c_older(rtp->ipRouteAge, newrt->ipRouteAge) == rtp->ipRouteAge)
 32441b4:	e0bffa17 	ldw	r2,-24(fp)
 32441b8:	11000917 	ldw	r4,36(r2)
 32441bc:	e0bff917 	ldw	r2,-28(fp)
 32441c0:	11400917 	ldw	r5,36(r2)
 32441c4:	32236c40 	call	32236c4 <c_older>
 32441c8:	1007883a 	mov	r3,r2
 32441cc:	e0bffa17 	ldw	r2,-24(fp)
 32441d0:	10800917 	ldw	r2,36(r2)
 32441d4:	1880021e 	bne	r3,r2,32441e0 <add_route+0x2cc>
                  newrt = rtp;   /* got an older one */
 32441d8:	e0bffa17 	ldw	r2,-24(fp)
 32441dc:	e0bff915 	stw	r2,-28(fp)
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 32441e0:	e0bffa17 	ldw	r2,-24(fp)
 32441e4:	10800f04 	addi	r2,r2,60
 32441e8:	e0bffa15 	stw	r2,-24(fp)
 32441ec:	0080c974 	movhi	r2,805
 32441f0:	1089c404 	addi	r2,r2,10000
 32441f4:	10800017 	ldw	r2,0(r2)
 32441f8:	10800f24 	muli	r2,r2,60
 32441fc:	1007883a 	mov	r3,r2
 3244200:	0080c974 	movhi	r2,805
 3244204:	10927404 	addi	r2,r2,18896
 3244208:	10800017 	ldw	r2,0(r2)
 324420c:	1887883a 	add	r3,r3,r2
 3244210:	e0bffa17 	ldw	r2,-24(fp)
 3244214:	10ff8636 	bltu	r2,r3,3244030 <add_route+0x11c>
         }
      }
   }

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
 3244218:	e0bff917 	ldw	r2,-28(fp)
 324421c:	1005003a 	cmpeq	r2,r2,zero
 3244220:	10002a1e 	bne	r2,zero,32442cc <add_route+0x3b8>
      rtp = newrt;   /* create new entry in lowest priority slot */
 3244224:	e0bff917 	ldw	r2,-28(fp)
 3244228:	e0bffa15 	stw	r2,-24(fp)
   else  /* all slots have higher priority, new entry looses */
      return NULL;

   /* set default value in new route entry, caller can modiy further. */
   rtp->ifp = ifp;
 324422c:	e0fffa17 	ldw	r3,-24(fp)
 3244230:	e0bff817 	ldw	r2,-32(fp)
 3244234:	18800e15 	stw	r2,56(r3)
   rtp->ipRouteDest = dest;
 3244238:	e0fffa17 	ldw	r3,-24(fp)
 324423c:	e0bffb17 	ldw	r2,-20(fp)
 3244240:	18800015 	stw	r2,0(r3)
   rtp->ipRouteIfIndex = (long)(if_netnumber(ifp)) + 1; /* set interface number */
 3244244:	e13ff817 	ldw	r4,-32(fp)
 3244248:	3223d580 	call	3223d58 <if_netnumber>
 324424c:	10c00044 	addi	r3,r2,1
 3244250:	e0bffa17 	ldw	r2,-24(fp)
 3244254:	10c00115 	stw	r3,4(r2)
   rtp->ipRouteMetric1 = ip_mib.ipDefaultTTL;
 3244258:	0080c9b4 	movhi	r2,806
 324425c:	10b46004 	addi	r2,r2,-11904
 3244260:	10800117 	ldw	r2,4(r2)
 3244264:	1007883a 	mov	r3,r2
 3244268:	e0bffa17 	ldw	r2,-24(fp)
 324426c:	10c00215 	stw	r3,8(r2)
   rtp->ipRouteMetric2 = -1;
 3244270:	e0fffa17 	ldw	r3,-24(fp)
 3244274:	00bfffc4 	movi	r2,-1
 3244278:	18800315 	stw	r2,12(r3)
   rtp->ipRouteMetric3 = -1;
 324427c:	e0fffa17 	ldw	r3,-24(fp)
 3244280:	00bfffc4 	movi	r2,-1
 3244284:	18800415 	stw	r2,16(r3)
   rtp->ipRouteMetric4 = -1;
 3244288:	e0fffa17 	ldw	r3,-24(fp)
 324428c:	00bfffc4 	movi	r2,-1
 3244290:	18800515 	stw	r2,20(r3)
   rtp->ipRouteNextHop = nexthop;
 3244294:	e0fffa17 	ldw	r3,-24(fp)
 3244298:	e0bffd17 	ldw	r2,-12(fp)
 324429c:	18800615 	stw	r2,24(r3)
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */
 32442a0:	e0fffa17 	ldw	r3,-24(fp)
 32442a4:	e0800217 	ldw	r2,8(fp)
 32442a8:	18800815 	stw	r2,32(r3)

   if ((dest & mask) == (nexthop & mask))
 32442ac:	e0fffb17 	ldw	r3,-20(fp)
 32442b0:	e0bffc17 	ldw	r2,-16(fp)
 32442b4:	1888703a 	and	r4,r3,r2
 32442b8:	e0fffd17 	ldw	r3,-12(fp)
 32442bc:	e0bffc17 	ldw	r2,-16(fp)
 32442c0:	1884703a 	and	r2,r3,r2
 32442c4:	20800326 	beq	r4,r2,32442d4 <add_route+0x3c0>
 32442c8:	00000606 	br	32442e4 <add_route+0x3d0>

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
      rtp = newrt;   /* create new entry in lowest priority slot */
   else  /* all slots have higher priority, new entry looses */
      return NULL;
 32442cc:	e03fff15 	stw	zero,-4(fp)
 32442d0:	00001406 	br	3244324 <add_route+0x410>
   rtp->ipRouteMetric4 = -1;
   rtp->ipRouteNextHop = nexthop;
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */

   if ((dest & mask) == (nexthop & mask))
      rtp->ipRouteType = IPRT_DIRECT;
 32442d4:	e0fffa17 	ldw	r3,-24(fp)
 32442d8:	008000c4 	movi	r2,3
 32442dc:	18800715 	stw	r2,28(r3)
 32442e0:	00000306 	br	32442f0 <add_route+0x3dc>
   else
      rtp->ipRouteType = IPRT_INDIRECT;
 32442e4:	e0fffa17 	ldw	r3,-24(fp)
 32442e8:	00800104 	movi	r2,4
 32442ec:	18800715 	stw	r2,28(r3)

   rtp->ipRouteAge = cticks;        /* timestamp it */
 32442f0:	0080c974 	movhi	r2,805
 32442f4:	10925604 	addi	r2,r2,18776
 32442f8:	10c00017 	ldw	r3,0(r2)
 32442fc:	e0bffa17 	ldw	r2,-24(fp)
 3244300:	10c00915 	stw	r3,36(r2)
   rtp->ipRouteMask = mask;
 3244304:	e0fffa17 	ldw	r3,-24(fp)
 3244308:	e0bffc17 	ldw	r2,-16(fp)
 324430c:	18800a15 	stw	r2,40(r3)
   rtp->ipRouteMetric5 = -1;
 3244310:	e0fffa17 	ldw	r3,-24(fp)
 3244314:	00bfffc4 	movi	r2,-1
 3244318:	18800b15 	stw	r2,44(r3)
   return(rtp);
 324431c:	e0bffa17 	ldw	r2,-24(fp)
 3244320:	e0bfff15 	stw	r2,-4(fp)
 3244324:	e0bfff17 	ldw	r2,-4(fp)
}
 3244328:	e037883a 	mov	sp,fp
 324432c:	dfc00117 	ldw	ra,4(sp)
 3244330:	df000017 	ldw	fp,0(sp)
 3244334:	dec00204 	addi	sp,sp,8
 3244338:	f800283a 	ret

0324433c <del_route>:
 * RETURNS: Returns number of route table entries deleted. 
 */

int
del_route(ip_addr dest, ip_addr mask, int iface)
{
 324433c:	defff704 	addi	sp,sp,-36
 3244340:	dfc00815 	stw	ra,32(sp)
 3244344:	df000715 	stw	fp,28(sp)
 3244348:	df000704 	addi	fp,sp,28
 324434c:	e13ffc15 	stw	r4,-16(fp)
 3244350:	e17ffd15 	stw	r5,-12(fp)
 3244354:	e1bffe15 	stw	r6,-8(fp)
   RTMIB rtp;
   int   retval   =  0;
 3244358:	e03ffa15 	stw	zero,-24(fp)

   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   if(iface == -1)
 324435c:	e0bffe17 	ldw	r2,-8(fp)
 3244360:	10bfffd8 	cmpnei	r2,r2,-1
 3244364:	1000021e 	bne	r2,zero,3244370 <del_route+0x34>
      ifp = NULL;    /* wildcard */
 3244368:	e03ff915 	stw	zero,-28(fp)
 324436c:	00000306 	br	324437c <del_route+0x40>
   else
      ifp = if_getbynum(iface);
 3244370:	e13ffe17 	ldw	r4,-8(fp)
 3244374:	323e3580 	call	323e358 <if_getbynum>
 3244378:	e0bff915 	stw	r2,-28(fp)

   if (rt_mib == NULL)     /* Make sure we're up */
 324437c:	0080c974 	movhi	r2,805
 3244380:	10927404 	addi	r2,r2,18896
 3244384:	10800017 	ldw	r2,0(r2)
 3244388:	1004c03a 	cmpne	r2,r2,zero
 324438c:	1000021e 	bne	r2,zero,3244398 <del_route+0x5c>
      return 0;
 3244390:	e03fff15 	stw	zero,-4(fp)
 3244394:	00003406 	br	3244468 <del_route+0x12c>

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 3244398:	0080c974 	movhi	r2,805
 324439c:	10927404 	addi	r2,r2,18896
 32443a0:	10800017 	ldw	r2,0(r2)
 32443a4:	e0bffb15 	stw	r2,-20(fp)
 32443a8:	00002206 	br	3244434 <del_route+0xf8>
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
 32443ac:	e0bffb17 	ldw	r2,-20(fp)
 32443b0:	10800617 	ldw	r2,24(r2)
 32443b4:	1005003a 	cmpeq	r2,r2,zero
 32443b8:	10001b1e 	bne	r2,zero,3244428 <del_route+0xec>
         continue;
      if(ifp != NULL && ifp != rtp->ifp)
 32443bc:	e0bff917 	ldw	r2,-28(fp)
 32443c0:	1005003a 	cmpeq	r2,r2,zero
 32443c4:	1000041e 	bne	r2,zero,32443d8 <del_route+0x9c>
 32443c8:	e0bffb17 	ldw	r2,-20(fp)
 32443cc:	10c00e17 	ldw	r3,56(r2)
 32443d0:	e0bff917 	ldw	r2,-28(fp)
 32443d4:	1880141e 	bne	r3,r2,3244428 <del_route+0xec>
         continue;   /* interface didn't match */
      if ((rtp->ipRouteDest & mask) == (dest & mask))
 32443d8:	e0bffb17 	ldw	r2,-20(fp)
 32443dc:	10c00017 	ldw	r3,0(r2)
 32443e0:	e0bffd17 	ldw	r2,-12(fp)
 32443e4:	1888703a 	and	r4,r3,r2
 32443e8:	e0fffc17 	ldw	r3,-16(fp)
 32443ec:	e0bffd17 	ldw	r2,-12(fp)
 32443f0:	1884703a 	and	r2,r3,r2
 32443f4:	2080081e 	bne	r4,r2,3244418 <del_route+0xdc>
      {
         MEMSET(rtp, 0, sizeof(*rtp)); /* clear entry */
 32443f8:	e0bffb17 	ldw	r2,-20(fp)
 32443fc:	1009883a 	mov	r4,r2
 3244400:	01800f04 	movi	r6,60
 3244404:	000b883a 	mov	r5,zero
 3244408:	320694c0 	call	320694c <memset>
         retval++;
 324440c:	e0bffa17 	ldw	r2,-24(fp)
 3244410:	10800044 	addi	r2,r2,1
 3244414:	e0bffa15 	stw	r2,-24(fp)
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
 3244418:	d0e90717 	ldw	r3,-23524(gp)
 324441c:	e0bffb17 	ldw	r2,-20(fp)
 3244420:	1880011e 	bne	r3,r2,3244428 <del_route+0xec>
         cachedRoute = NULL;
 3244424:	d0290715 	stw	zero,-23524(gp)
      ifp = if_getbynum(iface);

   if (rt_mib == NULL)     /* Make sure we're up */
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 3244428:	e0bffb17 	ldw	r2,-20(fp)
 324442c:	10800f04 	addi	r2,r2,60
 3244430:	e0bffb15 	stw	r2,-20(fp)
 3244434:	0080c974 	movhi	r2,805
 3244438:	1089c404 	addi	r2,r2,10000
 324443c:	10800017 	ldw	r2,0(r2)
 3244440:	10800f24 	muli	r2,r2,60
 3244444:	1007883a 	mov	r3,r2
 3244448:	0080c974 	movhi	r2,805
 324444c:	10927404 	addi	r2,r2,18896
 3244450:	10800017 	ldw	r2,0(r2)
 3244454:	1887883a 	add	r3,r3,r2
 3244458:	e0bffb17 	ldw	r2,-20(fp)
 324445c:	10ffd336 	bltu	r2,r3,32443ac <del_route+0x70>
         retval++;
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
         cachedRoute = NULL;
   }
   return retval;
 3244460:	e0bffa17 	ldw	r2,-24(fp)
 3244464:	e0bfff15 	stw	r2,-4(fp)
 3244468:	e0bfff17 	ldw	r2,-4(fp)
}
 324446c:	e037883a 	mov	sp,fp
 3244470:	dfc00117 	ldw	ra,4(sp)
 3244474:	df000017 	ldw	fp,0(sp)
 3244478:	dec00204 	addi	sp,sp,8
 324447c:	f800283a 	ret

03244480 <udpdemux>:
 * RETURNS: 0 if OK or ENP error code
 */

int
udpdemux(PACKET p)
{
 3244480:	deffec04 	addi	sp,sp,-80
 3244484:	dfc01315 	stw	ra,76(sp)
 3244488:	df001215 	stw	fp,72(sp)
 324448c:	df001204 	addi	fp,sp,72
 3244490:	e13ffe15 	stw	r4,-8(fp)
   unsigned short osum, xsum; /* scratch checksum holders */
   unsigned plen; /* packet length */
   int   e;    /* general error holder */

   /* First let's verify that it's a valid UDP packet. */
   pip = ip_head(p);       /* we'll need IP header info */
 3244494:	e0bffe17 	ldw	r2,-8(fp)
 3244498:	10800317 	ldw	r2,12(r2)
 324449c:	e0bffa15 	stw	r2,-24(fp)
   pup = (struct udp*)ip_data(pip);   /*  also need UDP header */
 32444a0:	e0bffa17 	ldw	r2,-24(fp)
 32444a4:	10800003 	ldbu	r2,0(r2)
 32444a8:	10803fcc 	andi	r2,r2,255
 32444ac:	108003cc 	andi	r2,r2,15
 32444b0:	1085883a 	add	r2,r2,r2
 32444b4:	1085883a 	add	r2,r2,r2
 32444b8:	1007883a 	mov	r3,r2
 32444bc:	e0bffa17 	ldw	r2,-24(fp)
 32444c0:	1885883a 	add	r2,r3,r2
 32444c4:	e0bff915 	stw	r2,-28(fp)
   plen = htons(pup->ud_len);
 32444c8:	e0bff917 	ldw	r2,-28(fp)
 32444cc:	1080010b 	ldhu	r2,4(r2)
 32444d0:	10bfffcc 	andi	r2,r2,65535
 32444d4:	1004d23a 	srli	r2,r2,8
 32444d8:	10bfffcc 	andi	r2,r2,65535
 32444dc:	10c03fcc 	andi	r3,r2,255
 32444e0:	e0bff917 	ldw	r2,-28(fp)
 32444e4:	1080010b 	ldhu	r2,4(r2)
 32444e8:	10bfffcc 	andi	r2,r2,65535
 32444ec:	1004923a 	slli	r2,r2,8
 32444f0:	10bfc00c 	andi	r2,r2,65280
 32444f4:	1884b03a 	or	r2,r3,r2
 32444f8:	e0bff615 	stw	r2,-40(fp)

   if (plen > p->nb_plen)
 32444fc:	e0bffe17 	ldw	r2,-8(fp)
 3244500:	10c00417 	ldw	r3,16(r2)
 3244504:	e0bff617 	ldw	r2,-40(fp)
 3244508:	18802a2e 	bgeu	r3,r2,32445b4 <udpdemux+0x134>
#ifdef   NPDEBUG
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 324450c:	0080c974 	movhi	r2,805
 3244510:	10923104 	addi	r2,r2,18628
 3244514:	10800017 	ldw	r2,0(r2)
 3244518:	1081000c 	andi	r2,r2,1024
 324451c:	1005003a 	cmpeq	r2,r2,zero
 3244520:	1000181e 	bne	r2,zero,3244584 <udpdemux+0x104>
 3244524:	0080c974 	movhi	r2,805
 3244528:	10923104 	addi	r2,r2,18628
 324452c:	10800017 	ldw	r2,0(r2)
 3244530:	1080400c 	andi	r2,r2,256
 3244534:	1005003a 	cmpeq	r2,r2,zero
 3244538:	1000121e 	bne	r2,zero,3244584 <udpdemux+0x104>
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 324453c:	e0bffe17 	ldw	r2,-8(fp)
 3244540:	11400417 	ldw	r5,16(r2)
 3244544:	e0bff917 	ldw	r2,-28(fp)
 3244548:	1080010b 	ldhu	r2,4(r2)
 324454c:	10bfffcc 	andi	r2,r2,65535
 3244550:	1004d23a 	srli	r2,r2,8
 3244554:	10bfffcc 	andi	r2,r2,65535
 3244558:	10c03fcc 	andi	r3,r2,255
 324455c:	e0bff917 	ldw	r2,-28(fp)
 3244560:	1080010b 	ldhu	r2,4(r2)
 3244564:	10bfffcc 	andi	r2,r2,65535
 3244568:	1004923a 	slli	r2,r2,8
 324456c:	10bfc00c 	andi	r2,r2,65280
 3244570:	1884b03a 	or	r2,r3,r2
 3244574:	11800204 	addi	r6,r2,8
 3244578:	0100c974 	movhi	r4,805
 324457c:	213f6604 	addi	r4,r4,-616
 3244580:	3206adc0 	call	3206adc <printf>
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
#endif
      udp_mib.udpInErrors++;
 3244584:	0080c9b4 	movhi	r2,806
 3244588:	10b47a04 	addi	r2,r2,-11800
 324458c:	10800217 	ldw	r2,8(r2)
 3244590:	10c00044 	addi	r3,r2,1
 3244594:	0080c9b4 	movhi	r2,806
 3244598:	10b47a04 	addi	r2,r2,-11800
 324459c:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 32445a0:	e13ffe17 	ldw	r4,-8(fp)
 32445a4:	324527c0 	call	324527c <udp_free>
      return ENP_BAD_HEADER;
 32445a8:	00bff804 	movi	r2,-32
 32445ac:	e0bfff15 	stw	r2,-4(fp)
 32445b0:	0001c306 	br	3244cc0 <udpdemux+0x840>
   }

   osum = pup->ud_cksum;
 32445b4:	e0bff917 	ldw	r2,-28(fp)
 32445b8:	1080018b 	ldhu	r2,6(r2)
 32445bc:	e0bff78d 	sth	r2,-34(fp)
   /* did other guy use checksumming? */
   if (osum)
 32445c0:	e0bff78b 	ldhu	r2,-34(fp)
 32445c4:	1005003a 	cmpeq	r2,r2,zero
 32445c8:	1000631e 	bne	r2,zero,3244758 <udpdemux+0x2d8>
   {
      if (plen & 1) ((char *)pup)[plen] = 0;
 32445cc:	e0bff617 	ldw	r2,-40(fp)
 32445d0:	1080004c 	andi	r2,r2,1
 32445d4:	10803fcc 	andi	r2,r2,255
 32445d8:	1005003a 	cmpeq	r2,r2,zero
 32445dc:	1000041e 	bne	r2,zero,32445f0 <udpdemux+0x170>
 32445e0:	e0bff917 	ldw	r2,-28(fp)
 32445e4:	e0fff617 	ldw	r3,-40(fp)
 32445e8:	10c5883a 	add	r2,r2,r3
 32445ec:	10000005 	stb	zero,0(r2)
         php.ph_src = p->fhost;
 32445f0:	e0bffe17 	ldw	r2,-8(fp)
 32445f4:	10800717 	ldw	r2,28(r2)
 32445f8:	e0bffb15 	stw	r2,-20(fp)
      php.ph_dest = pip->ip_dest;
 32445fc:	e0bffa17 	ldw	r2,-24(fp)
 3244600:	10800417 	ldw	r2,16(r2)
 3244604:	e0bffc15 	stw	r2,-16(fp)
      php.ph_zero = 0;
 3244608:	e03ffd05 	stb	zero,-12(fp)
      php.ph_prot = UDP_PROT;
 324460c:	00800444 	movi	r2,17
 3244610:	e0bffd45 	stb	r2,-11(fp)
      php.ph_len  = pup->ud_len;
 3244614:	e0bff917 	ldw	r2,-28(fp)
 3244618:	1080010b 	ldhu	r2,4(r2)
 324461c:	e0bffd8d 	sth	r2,-10(fp)

      pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 3244620:	e13ffb04 	addi	r4,fp,-20
 3244624:	01400184 	movi	r5,6
 3244628:	32259f80 	call	32259f8 <cksum>
 324462c:	1007883a 	mov	r3,r2
 3244630:	e0bff917 	ldw	r2,-28(fp)
 3244634:	10c0018d 	sth	r3,6(r2)
      xsum = ~cksum(pup, (plen+1)>>1);
 3244638:	e0bff617 	ldw	r2,-40(fp)
 324463c:	10800044 	addi	r2,r2,1
 3244640:	100ad07a 	srli	r5,r2,1
 3244644:	e13ff917 	ldw	r4,-28(fp)
 3244648:	32259f80 	call	32259f8 <cksum>
 324464c:	0084303a 	nor	r2,zero,r2
 3244650:	e0bff70d 	sth	r2,-36(fp)
      if (!xsum)
 3244654:	e0bff70b 	ldhu	r2,-36(fp)
 3244658:	1004c03a 	cmpne	r2,r2,zero
 324465c:	1000021e 	bne	r2,zero,3244668 <udpdemux+0x1e8>
         xsum = 0xffff;
 3244660:	00bfffc4 	movi	r2,-1
 3244664:	e0bff70d 	sth	r2,-36(fp)
      pup->ud_cksum = osum;
 3244668:	e0fff917 	ldw	r3,-28(fp)
 324466c:	e0bff78b 	ldhu	r2,-34(fp)
 3244670:	1880018d 	sth	r2,6(r3)
      if (xsum != osum)
 3244674:	e0fff70b 	ldhu	r3,-36(fp)
 3244678:	e0bff78b 	ldhu	r2,-34(fp)
 324467c:	18803626 	beq	r3,r2,3244758 <udpdemux+0x2d8>
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 3244680:	0080c974 	movhi	r2,805
 3244684:	10923104 	addi	r2,r2,18628
 3244688:	10800017 	ldw	r2,0(r2)
 324468c:	1081000c 	andi	r2,r2,1024
 3244690:	1005003a 	cmpeq	r2,r2,zero
 3244694:	1000241e 	bne	r2,zero,3244728 <udpdemux+0x2a8>
 3244698:	0080c974 	movhi	r2,805
 324469c:	10923104 	addi	r2,r2,18628
 32446a0:	10800017 	ldw	r2,0(r2)
 32446a4:	1080400c 	andi	r2,r2,256
 32446a8:	1005003a 	cmpeq	r2,r2,zero
 32446ac:	10001e1e 	bne	r2,zero,3244728 <udpdemux+0x2a8>
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 32446b0:	e17ff78b 	ldhu	r5,-34(fp)
 32446b4:	e1bff70b 	ldhu	r6,-36(fp)
 32446b8:	e0bffe17 	ldw	r2,-8(fp)
 32446bc:	10800717 	ldw	r2,28(r2)
 32446c0:	11c03fcc 	andi	r7,r2,255
 32446c4:	e0bffe17 	ldw	r2,-8(fp)
 32446c8:	10800717 	ldw	r2,28(r2)
 32446cc:	1004d23a 	srli	r2,r2,8
 32446d0:	11003fcc 	andi	r4,r2,255
 32446d4:	e0bffe17 	ldw	r2,-8(fp)
 32446d8:	10800717 	ldw	r2,28(r2)
 32446dc:	1004d43a 	srli	r2,r2,16
 32446e0:	10c03fcc 	andi	r3,r2,255
 32446e4:	e0bffe17 	ldw	r2,-8(fp)
 32446e8:	10800717 	ldw	r2,28(r2)
 32446ec:	1004d63a 	srli	r2,r2,24
 32446f0:	d9000015 	stw	r4,0(sp)
 32446f4:	d8c00115 	stw	r3,4(sp)
 32446f8:	d8800215 	stw	r2,8(sp)
 32446fc:	0100c974 	movhi	r4,805
 3244700:	213f7004 	addi	r4,r4,-576
 3244704:	3206adc0 	call	3206adc <printf>
                    osum, xsum, PUSH_IPADDR(p->fhost));
            if (NDEBUG & DUMP)
 3244708:	0080c974 	movhi	r2,805
 324470c:	10923104 	addi	r2,r2,18628
 3244710:	10800017 	ldw	r2,0(r2)
 3244714:	1080008c 	andi	r2,r2,2
 3244718:	1005003a 	cmpeq	r2,r2,zero
 324471c:	1000021e 	bne	r2,zero,3244728 <udpdemux+0x2a8>
               ip_dump(p);
 3244720:	e13ffe17 	ldw	r4,-8(fp)
 3244724:	32402380 	call	3240238 <ip_dump>
         }
#endif
         udp_mib.udpInErrors++;
 3244728:	0080c9b4 	movhi	r2,806
 324472c:	10b47a04 	addi	r2,r2,-11800
 3244730:	10800217 	ldw	r2,8(r2)
 3244734:	10c00044 	addi	r3,r2,1
 3244738:	0080c9b4 	movhi	r2,806
 324473c:	10b47a04 	addi	r2,r2,-11800
 3244740:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 3244744:	e13ffe17 	ldw	r4,-8(fp)
 3244748:	324527c0 	call	324527c <udp_free>
         return ENP_BAD_HEADER;
 324474c:	00bff804 	movi	r2,-32
 3244750:	e0bfff15 	stw	r2,-4(fp)
 3244754:	00015a06 	br	3244cc0 <udpdemux+0x840>
      }
   }

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 3244758:	e13ff917 	ldw	r4,-28(fp)
 324475c:	3244f900 	call	3244f90 <udpswap>
#endif

   /* Prior to upcall, adjust nb_prot for size of IP and UDP headers */
   e = (sizeof(struct udp) + ip_hlen(pip));
 3244760:	e0bffa17 	ldw	r2,-24(fp)
 3244764:	10800003 	ldbu	r2,0(r2)
 3244768:	10803fcc 	andi	r2,r2,255
 324476c:	108003cc 	andi	r2,r2,15
 3244770:	1085883a 	add	r2,r2,r2
 3244774:	1085883a 	add	r2,r2,r2
 3244778:	10800204 	addi	r2,r2,8
 324477c:	e0bff515 	stw	r2,-44(fp)
   p->nb_plen -= e;
 3244780:	e0bffe17 	ldw	r2,-8(fp)
 3244784:	10c00417 	ldw	r3,16(r2)
 3244788:	e0bff517 	ldw	r2,-44(fp)
 324478c:	1887c83a 	sub	r3,r3,r2
 3244790:	e0bffe17 	ldw	r2,-8(fp)
 3244794:	10c00415 	stw	r3,16(r2)
   p->nb_prot += e;
 3244798:	e0bffe17 	ldw	r2,-8(fp)
 324479c:	10c00317 	ldw	r3,12(r2)
 32447a0:	e0bff517 	ldw	r2,-44(fp)
 32447a4:	1887883a 	add	r3,r3,r2
 32447a8:	e0bffe17 	ldw	r2,-8(fp)
 32447ac:	10c00315 	stw	r3,12(r2)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 32447b0:	0080c974 	movhi	r2,805
 32447b4:	10923104 	addi	r2,r2,18628
 32447b8:	10800017 	ldw	r2,0(r2)
 32447bc:	1081000c 	andi	r2,r2,1024
 32447c0:	1005003a 	cmpeq	r2,r2,zero
 32447c4:	1000221e 	bne	r2,zero,3244850 <udpdemux+0x3d0>
 32447c8:	0080c974 	movhi	r2,805
 32447cc:	10923104 	addi	r2,r2,18628
 32447d0:	10800017 	ldw	r2,0(r2)
 32447d4:	1080400c 	andi	r2,r2,256
 32447d8:	1005003a 	cmpeq	r2,r2,zero
 32447dc:	10001c1e 	bne	r2,zero,3244850 <udpdemux+0x3d0>
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 32447e0:	e0bffe17 	ldw	r2,-8(fp)
 32447e4:	10800717 	ldw	r2,28(r2)
 32447e8:	11803fcc 	andi	r6,r2,255
 32447ec:	e0bffe17 	ldw	r2,-8(fp)
 32447f0:	10800717 	ldw	r2,28(r2)
 32447f4:	1004d23a 	srli	r2,r2,8
 32447f8:	11c03fcc 	andi	r7,r2,255
 32447fc:	e0bffe17 	ldw	r2,-8(fp)
 3244800:	10800717 	ldw	r2,28(r2)
 3244804:	1004d43a 	srli	r2,r2,16
 3244808:	10c03fcc 	andi	r3,r2,255
 324480c:	e0bffe17 	ldw	r2,-8(fp)
 3244810:	10800717 	ldw	r2,28(r2)
 3244814:	1008d63a 	srli	r4,r2,24
 3244818:	e0bff917 	ldw	r2,-28(fp)
 324481c:	1080000b 	ldhu	r2,0(r2)
 3244820:	117fffcc 	andi	r5,r2,65535
 3244824:	e0bff917 	ldw	r2,-28(fp)
 3244828:	1080008b 	ldhu	r2,2(r2)
 324482c:	10bfffcc 	andi	r2,r2,65535
 3244830:	d8c00015 	stw	r3,0(sp)
 3244834:	d9000115 	stw	r4,4(sp)
 3244838:	d9400215 	stw	r5,8(sp)
 324483c:	d8800315 	stw	r2,12(sp)
 3244840:	0100c974 	movhi	r4,805
 3244844:	213f7e04 	addi	r4,r4,-520
 3244848:	e17ff617 	ldw	r5,-40(fp)
 324484c:	3206adc0 	call	3206adc <printf>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 3244850:	0080c974 	movhi	r2,805
 3244854:	10924a04 	addi	r2,r2,18728
 3244858:	10800017 	ldw	r2,0(r2)
 324485c:	e0bff815 	stw	r2,-32(fp)
 3244860:	0000b106 	br	3244b28 <udpdemux+0x6a8>
         continue;
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
 3244864:	e0bff817 	ldw	r2,-32(fp)
 3244868:	1080018b 	ldhu	r2,6(r2)
 324486c:	10bfffcc 	andi	r2,r2,65535
 3244870:	1005003a 	cmpeq	r2,r2,zero
 3244874:	1000071e 	bne	r2,zero,3244894 <udpdemux+0x414>
 3244878:	e0bff817 	ldw	r2,-32(fp)
 324487c:	10c0018b 	ldhu	r3,6(r2)
 3244880:	e0bff917 	ldw	r2,-28(fp)
 3244884:	1080008b 	ldhu	r2,2(r2)
 3244888:	18ffffcc 	andi	r3,r3,65535
 324488c:	10bfffcc 	andi	r2,r2,65535
 3244890:	1880a21e 	bne	r3,r2,3244b1c <udpdemux+0x69c>
         continue;
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
 3244894:	e0bff817 	ldw	r2,-32(fp)
 3244898:	1080020b 	ldhu	r2,8(r2)
 324489c:	10bfffcc 	andi	r2,r2,65535
 32448a0:	1005003a 	cmpeq	r2,r2,zero
 32448a4:	1000071e 	bne	r2,zero,32448c4 <udpdemux+0x444>
 32448a8:	e0bff817 	ldw	r2,-32(fp)
 32448ac:	10c0020b 	ldhu	r3,8(r2)
 32448b0:	e0bff917 	ldw	r2,-28(fp)
 32448b4:	1080000b 	ldhu	r2,0(r2)
 32448b8:	18ffffcc 	andi	r3,r3,65535
 32448bc:	10bfffcc 	andi	r2,r2,65535
 32448c0:	1880961e 	bne	r3,r2,3244b1c <udpdemux+0x69c>
         continue;
      if (con->u_fhost && (con->u_fhost != p->fhost))
 32448c4:	e0bff817 	ldw	r2,-32(fp)
 32448c8:	10800417 	ldw	r2,16(r2)
 32448cc:	1005003a 	cmpeq	r2,r2,zero
 32448d0:	1000051e 	bne	r2,zero,32448e8 <udpdemux+0x468>
 32448d4:	e0bff817 	ldw	r2,-32(fp)
 32448d8:	10c00417 	ldw	r3,16(r2)
 32448dc:	e0bffe17 	ldw	r2,-8(fp)
 32448e0:	10800717 	ldw	r2,28(r2)
 32448e4:	18808d1e 	bne	r3,r2,3244b1c <udpdemux+0x69c>
#ifdef IP_MULTICAST
      /* In the case of multicast, check if there is multicast membership
       * attached to this socket and if so, is the incoming packet
       * addressed to the multicast address
       */
      if (IN_MULTICAST(ntohl(pip->ip_dest)))
 32448e8:	e0bffa17 	ldw	r2,-24(fp)
 32448ec:	10800417 	ldw	r2,16(r2)
 32448f0:	1004d63a 	srli	r2,r2,24
 32448f4:	10c03fcc 	andi	r3,r2,255
 32448f8:	e0bffa17 	ldw	r2,-24(fp)
 32448fc:	10800417 	ldw	r2,16(r2)
 3244900:	1004d23a 	srli	r2,r2,8
 3244904:	10bfc00c 	andi	r2,r2,65280
 3244908:	1886b03a 	or	r3,r3,r2
 324490c:	e0bffa17 	ldw	r2,-24(fp)
 3244910:	10800417 	ldw	r2,16(r2)
 3244914:	10bfc00c 	andi	r2,r2,65280
 3244918:	1004923a 	slli	r2,r2,8
 324491c:	1886b03a 	or	r3,r3,r2
 3244920:	e0bffa17 	ldw	r2,-24(fp)
 3244924:	10800417 	ldw	r2,16(r2)
 3244928:	10803fcc 	andi	r2,r2,255
 324492c:	1004963a 	slli	r2,r2,24
 3244930:	1884b03a 	or	r2,r3,r2
 3244934:	10fc002c 	andhi	r3,r2,61440
 3244938:	00b80034 	movhi	r2,57344
 324493c:	1880301e 	bne	r3,r2,3244a00 <udpdemux+0x580>
      {
         struct socket *soptr = (struct socket *)con->u_data;
 3244940:	e0bff817 	ldw	r2,-32(fp)
 3244944:	10800617 	ldw	r2,24(r2)
 3244948:	e0bff415 	stw	r2,-48(fp)

         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
 324494c:	e0bff817 	ldw	r2,-32(fp)
 3244950:	10c00517 	ldw	r3,20(r2)
 3244954:	0080c934 	movhi	r2,804
 3244958:	10a4b404 	addi	r2,r2,-27952
 324495c:	1880281e 	bne	r3,r2,3244a00 <udpdemux+0x580>
 3244960:	e0bff417 	ldw	r2,-48(fp)
 3244964:	10800317 	ldw	r2,12(r2)
 3244968:	1005003a 	cmpeq	r2,r2,zero
 324496c:	1000241e 	bne	r2,zero,3244a00 <udpdemux+0x580>
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;
 3244970:	e0bff417 	ldw	r2,-48(fp)
 3244974:	10800317 	ldw	r2,12(r2)
 3244978:	e0bff215 	stw	r2,-56(fp)

            for (i = 0; i < imo->imo_num_memberships; ++i)
 324497c:	e03ff30d 	sth	zero,-52(fp)
 3244980:	00001906 	br	32449e8 <udpdemux+0x568>
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 3244984:	e0bff30b 	ldhu	r2,-52(fp)
 3244988:	e0fff217 	ldw	r3,-56(fp)
 324498c:	1085883a 	add	r2,r2,r2
 3244990:	1085883a 	add	r2,r2,r2
 3244994:	10c5883a 	add	r2,r2,r3
 3244998:	10800204 	addi	r2,r2,8
 324499c:	10800017 	ldw	r2,0(r2)
 32449a0:	10c00117 	ldw	r3,4(r2)
 32449a4:	e0bffe17 	ldw	r2,-8(fp)
 32449a8:	10800617 	ldw	r2,24(r2)
 32449ac:	18800b1e 	bne	r3,r2,32449dc <udpdemux+0x55c>
 32449b0:	e0bff30b 	ldhu	r2,-52(fp)
 32449b4:	e0fff217 	ldw	r3,-56(fp)
 32449b8:	1085883a 	add	r2,r2,r2
 32449bc:	1085883a 	add	r2,r2,r2
 32449c0:	10c5883a 	add	r2,r2,r3
 32449c4:	10800204 	addi	r2,r2,8
 32449c8:	10800017 	ldw	r2,0(r2)
 32449cc:	10c00017 	ldw	r3,0(r2)
 32449d0:	e0bffa17 	ldw	r2,-24(fp)
 32449d4:	10800417 	ldw	r2,16(r2)
 32449d8:	18800926 	beq	r3,r2,3244a00 <udpdemux+0x580>
         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
 32449dc:	e0bff30b 	ldhu	r2,-52(fp)
 32449e0:	10800044 	addi	r2,r2,1
 32449e4:	e0bff30d 	sth	r2,-52(fp)
 32449e8:	e0bff217 	ldw	r2,-56(fp)
 32449ec:	1080018b 	ldhu	r2,6(r2)
 32449f0:	10ffffcc 	andi	r3,r2,65535
 32449f4:	e0bff30b 	ldhu	r2,-52(fp)
 32449f8:	10ffe236 	bltu	r2,r3,3244984 <udpdemux+0x504>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
               }
            }
            continue;
 32449fc:	00004706 	br	3244b1c <udpdemux+0x69c>
#endif /* INCLUDE_TCP */

      /* if this endpoint has been bound to a local interface address,
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
 3244a00:	e0bffa17 	ldw	r2,-24(fp)
 3244a04:	10800417 	ldw	r2,16(r2)
 3244a08:	1004d63a 	srli	r2,r2,24
 3244a0c:	10c03fcc 	andi	r3,r2,255
 3244a10:	e0bffa17 	ldw	r2,-24(fp)
 3244a14:	10800417 	ldw	r2,16(r2)
 3244a18:	1004d23a 	srli	r2,r2,8
 3244a1c:	10bfc00c 	andi	r2,r2,65280
 3244a20:	1886b03a 	or	r3,r3,r2
 3244a24:	e0bffa17 	ldw	r2,-24(fp)
 3244a28:	10800417 	ldw	r2,16(r2)
 3244a2c:	10bfc00c 	andi	r2,r2,65280
 3244a30:	1004923a 	slli	r2,r2,8
 3244a34:	1886b03a 	or	r3,r3,r2
 3244a38:	e0bffa17 	ldw	r2,-24(fp)
 3244a3c:	10800417 	ldw	r2,16(r2)
 3244a40:	10803fcc 	andi	r2,r2,255
 3244a44:	1004963a 	slli	r2,r2,24
 3244a48:	1884b03a 	or	r2,r3,r2
 3244a4c:	10fc002c 	andhi	r3,r2,61440
 3244a50:	00b80034 	movhi	r2,57344
 3244a54:	18800926 	beq	r3,r2,3244a7c <udpdemux+0x5fc>
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
 3244a58:	e0bff817 	ldw	r2,-32(fp)
 3244a5c:	10800317 	ldw	r2,12(r2)
 3244a60:	1005003a 	cmpeq	r2,r2,zero
 3244a64:	1000051e 	bne	r2,zero,3244a7c <udpdemux+0x5fc>
 3244a68:	e0bff817 	ldw	r2,-32(fp)
 3244a6c:	10c00317 	ldw	r3,12(r2)
 3244a70:	e0bffa17 	ldw	r2,-24(fp)
 3244a74:	10800417 	ldw	r2,16(r2)
 3244a78:	1880281e 	bne	r3,r2,3244b1c <udpdemux+0x69c>
            continue;
      }

      /* fall to here if we found it */
      udp_mib.udpInDatagrams++;
 3244a7c:	0080c9b4 	movhi	r2,806
 3244a80:	10b47a04 	addi	r2,r2,-11800
 3244a84:	10800017 	ldw	r2,0(r2)
 3244a88:	10c00044 	addi	r3,r2,1
 3244a8c:	0080c9b4 	movhi	r2,806
 3244a90:	10b47a04 	addi	r2,r2,-11800
 3244a94:	10c00015 	stw	r3,0(r2)
      if (con->u_rcv)         /* if upcall address is set... */
 3244a98:	e0bff817 	ldw	r2,-32(fp)
 3244a9c:	10800517 	ldw	r2,20(r2)
 3244aa0:	1005003a 	cmpeq	r2,r2,zero
 3244aa4:	10000c1e 	bne	r2,zero,3244ad8 <udpdemux+0x658>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 3244aa8:	0009883a 	mov	r4,zero
 3244aac:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         e = ((*con->u_rcv)(p, con->u_data));   /* upcall it */
 3244ab0:	e0bff817 	ldw	r2,-32(fp)
 3244ab4:	10c00517 	ldw	r3,20(r2)
 3244ab8:	e0bff817 	ldw	r2,-32(fp)
 3244abc:	11400617 	ldw	r5,24(r2)
 3244ac0:	e13ffe17 	ldw	r4,-8(fp)
 3244ac4:	183ee83a 	callr	r3
 3244ac8:	e0bff515 	stw	r2,-44(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 3244acc:	0009883a 	mov	r4,zero
 3244ad0:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
 3244ad4:	00000206 	br	3244ae0 <udpdemux+0x660>
      }
      else
         e = ENP_LOGIC;
 3244ad8:	00bffd44 	movi	r2,-11
 3244adc:	e0bff515 	stw	r2,-44(fp)

      /* if error occurred in upcall or there was no upcall hander
         its up to this routine to free the packet buffer */
      if (e)
 3244ae0:	e0bff517 	ldw	r2,-44(fp)
 3244ae4:	1005003a 	cmpeq	r2,r2,zero
 3244ae8:	1000091e 	bne	r2,zero,3244b10 <udpdemux+0x690>
      {
         udp_mib.udpInErrors++;
 3244aec:	0080c9b4 	movhi	r2,806
 3244af0:	10b47a04 	addi	r2,r2,-11800
 3244af4:	10800217 	ldw	r2,8(r2)
 3244af8:	10c00044 	addi	r3,r2,1
 3244afc:	0080c9b4 	movhi	r2,806
 3244b00:	10b47a04 	addi	r2,r2,-11800
 3244b04:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 3244b08:	e13ffe17 	ldw	r4,-8(fp)
 3244b0c:	324527c0 	call	324527c <udp_free>
      }

      return(e);
 3244b10:	e0bff517 	ldw	r2,-44(fp)
 3244b14:	e0bfff15 	stw	r2,-4(fp)
 3244b18:	00006906 	br	3244cc0 <udpdemux+0x840>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 3244b1c:	e0bff817 	ldw	r2,-32(fp)
 3244b20:	10800017 	ldw	r2,0(r2)
 3244b24:	e0bff815 	stw	r2,-32(fp)
 3244b28:	e0bff817 	ldw	r2,-32(fp)
 3244b2c:	1004c03a 	cmpne	r2,r2,zero
 3244b30:	103f4c1e 	bne	r2,zero,3244864 <udpdemux+0x3e4>

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 3244b34:	e0bffa17 	ldw	r2,-24(fp)
 3244b38:	10800417 	ldw	r2,16(r2)
 3244b3c:	10bfffe0 	cmpeqi	r2,r2,-1
 3244b40:	1000121e 	bne	r2,zero,3244b8c <udpdemux+0x70c>
 3244b44:	e0bffa17 	ldw	r2,-24(fp)
 3244b48:	10c00417 	ldw	r3,16(r2)
 3244b4c:	e0bffe17 	ldw	r2,-8(fp)
 3244b50:	10800617 	ldw	r2,24(r2)
 3244b54:	10800e17 	ldw	r2,56(r2)
 3244b58:	18800c26 	beq	r3,r2,3244b8c <udpdemux+0x70c>
 3244b5c:	e0bffa17 	ldw	r2,-24(fp)
 3244b60:	10c00417 	ldw	r3,16(r2)
 3244b64:	e0bffe17 	ldw	r2,-8(fp)
 3244b68:	10800617 	ldw	r2,24(r2)
 3244b6c:	10800f17 	ldw	r2,60(r2)
 3244b70:	18800626 	beq	r3,r2,3244b8c <udpdemux+0x70c>
 3244b74:	e0bffa17 	ldw	r2,-24(fp)
 3244b78:	10c00417 	ldw	r3,16(r2)
 3244b7c:	e0bffe17 	ldw	r2,-8(fp)
 3244b80:	10800617 	ldw	r2,24(r2)
 3244b84:	10801017 	ldw	r2,64(r2)
 3244b88:	18801b1e 	bne	r3,r2,3244bf8 <udpdemux+0x778>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
   {
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 3244b8c:	0080c974 	movhi	r2,805
 3244b90:	10923104 	addi	r2,r2,18628
 3244b94:	10800017 	ldw	r2,0(r2)
 3244b98:	1081000c 	andi	r2,r2,1024
 3244b9c:	1005003a 	cmpeq	r2,r2,zero
 3244ba0:	1000091e 	bne	r2,zero,3244bc8 <udpdemux+0x748>
 3244ba4:	0080c974 	movhi	r2,805
 3244ba8:	10923104 	addi	r2,r2,18628
 3244bac:	10800017 	ldw	r2,0(r2)
 3244bb0:	1080400c 	andi	r2,r2,256
 3244bb4:	1005003a 	cmpeq	r2,r2,zero
 3244bb8:	1000031e 	bne	r2,zero,3244bc8 <udpdemux+0x748>
         dprintf("UDP: ignoring ip broadcast\n");
 3244bbc:	0100c974 	movhi	r4,805
 3244bc0:	213f8804 	addi	r4,r4,-480
 3244bc4:	3206e040 	call	3206e04 <puts>
#endif
      udp_mib.udpInErrors++;
 3244bc8:	0080c9b4 	movhi	r2,806
 3244bcc:	10b47a04 	addi	r2,r2,-11800
 3244bd0:	10800217 	ldw	r2,8(r2)
 3244bd4:	10c00044 	addi	r3,r2,1
 3244bd8:	0080c9b4 	movhi	r2,806
 3244bdc:	10b47a04 	addi	r2,r2,-11800
 3244be0:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 3244be4:	e13ffe17 	ldw	r4,-8(fp)
 3244be8:	324527c0 	call	324527c <udp_free>
      return ENP_NOT_MINE;
 3244bec:	00800084 	movi	r2,2
 3244bf0:	e0bfff15 	stw	r2,-4(fp)
 3244bf4:	00003206 	br	3244cc0 <udpdemux+0x840>
   }

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 3244bf8:	0080c974 	movhi	r2,805
 3244bfc:	10923104 	addi	r2,r2,18628
 3244c00:	10800017 	ldw	r2,0(r2)
 3244c04:	1081000c 	andi	r2,r2,1024
 3244c08:	1005003a 	cmpeq	r2,r2,zero
 3244c0c:	1000141e 	bne	r2,zero,3244c60 <udpdemux+0x7e0>
 3244c10:	0080c974 	movhi	r2,805
 3244c14:	10923104 	addi	r2,r2,18628
 3244c18:	10800017 	ldw	r2,0(r2)
 3244c1c:	1080400c 	andi	r2,r2,256
 3244c20:	1005003a 	cmpeq	r2,r2,zero
 3244c24:	10000e1e 	bne	r2,zero,3244c60 <udpdemux+0x7e0>
   {
      dprintf("UDP: unexpected port %04x\n", pup->ud_dstp);
 3244c28:	e0bff917 	ldw	r2,-28(fp)
 3244c2c:	1080008b 	ldhu	r2,2(r2)
 3244c30:	117fffcc 	andi	r5,r2,65535
 3244c34:	0100c974 	movhi	r4,805
 3244c38:	213f8f04 	addi	r4,r4,-452
 3244c3c:	3206adc0 	call	3206adc <printf>
      if (NDEBUG & DUMP) 
 3244c40:	0080c974 	movhi	r2,805
 3244c44:	10923104 	addi	r2,r2,18628
 3244c48:	10800017 	ldw	r2,0(r2)
 3244c4c:	1080008c 	andi	r2,r2,2
 3244c50:	1005003a 	cmpeq	r2,r2,zero
 3244c54:	1000021e 	bne	r2,zero,3244c60 <udpdemux+0x7e0>
         ip_dump(p);
 3244c58:	e13ffe17 	ldw	r4,-8(fp)
 3244c5c:	32402380 	call	3240238 <ip_dump>
#ifdef FULL_ICMP
   /* send destination unreachable.  Swap back all the swapped information */
   /* so that the destun packet format is correct */

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 3244c60:	e13ff917 	ldw	r4,-28(fp)
 3244c64:	3244f900 	call	3244f90 <udpswap>
#endif   /* BYTE_ORDER */
   
   icmp_destun(p->fhost, p->net->n_ipaddr, pip, DSTPORT, p->net);
 3244c68:	e0bffe17 	ldw	r2,-8(fp)
 3244c6c:	11000717 	ldw	r4,28(r2)
 3244c70:	e0bffe17 	ldw	r2,-8(fp)
 3244c74:	10800617 	ldw	r2,24(r2)
 3244c78:	11400a17 	ldw	r5,40(r2)
 3244c7c:	e0bffe17 	ldw	r2,-8(fp)
 3244c80:	10800617 	ldw	r2,24(r2)
 3244c84:	d8800015 	stw	r2,0(sp)
 3244c88:	e1bffa17 	ldw	r6,-24(fp)
 3244c8c:	01c000c4 	movi	r7,3
 3244c90:	324b1dc0 	call	324b1dc <icmp_destun>
#endif   /* FULL_ICMP */

   udp_mib.udpNoPorts++;
 3244c94:	0080c9b4 	movhi	r2,806
 3244c98:	10b47a04 	addi	r2,r2,-11800
 3244c9c:	10800117 	ldw	r2,4(r2)
 3244ca0:	10c00044 	addi	r3,r2,1
 3244ca4:	0080c9b4 	movhi	r2,806
 3244ca8:	10b47a04 	addi	r2,r2,-11800
 3244cac:	10c00115 	stw	r3,4(r2)
   udp_free(p);
 3244cb0:	e13ffe17 	ldw	r4,-8(fp)
 3244cb4:	324527c0 	call	324527c <udp_free>
   return ENP_NOT_MINE;
 3244cb8:	00800084 	movi	r2,2
 3244cbc:	e0bfff15 	stw	r2,-4(fp)
 3244cc0:	e0bfff17 	ldw	r2,-4(fp)
}
 3244cc4:	e037883a 	mov	sp,fp
 3244cc8:	dfc00117 	ldw	ra,4(sp)
 3244ccc:	df000017 	ldw	fp,0(sp)
 3244cd0:	dec00204 	addi	sp,sp,8
 3244cd4:	f800283a 	ret

03244cd8 <udp_send>:
 * detected. 
 */

int
udp_send(unshort fport, unshort lport, PACKET p)
{
 3244cd8:	deffee04 	addi	sp,sp,-72
 3244cdc:	dfc01115 	stw	ra,68(sp)
 3244ce0:	df001015 	stw	fp,64(sp)
 3244ce4:	df001004 	addi	fp,sp,64
 3244ce8:	e1bffe15 	stw	r6,-8(fp)
 3244cec:	e13ffc0d 	sth	r4,-16(fp)
 3244cf0:	e17ffd0d 	sth	r5,-12(fp)
   int         udplen;
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
 3244cf4:	0080c974 	movhi	r2,805
 3244cf8:	10923104 	addi	r2,r2,18628
 3244cfc:	10800017 	ldw	r2,0(r2)
 3244d00:	1080410c 	andi	r2,r2,260
 3244d04:	1005003a 	cmpeq	r2,r2,zero
 3244d08:	10001c1e 	bne	r2,zero,3244d7c <udp_send+0xa4>
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 3244d0c:	e0bffe17 	ldw	r2,-8(fp)
 3244d10:	11800417 	ldw	r6,16(r2)
 3244d14:	e1fffd0b 	ldhu	r7,-12(fp)
 3244d18:	e0bffe17 	ldw	r2,-8(fp)
 3244d1c:	10800717 	ldw	r2,28(r2)
 3244d20:	12003fcc 	andi	r8,r2,255
 3244d24:	e0bffe17 	ldw	r2,-8(fp)
 3244d28:	10800717 	ldw	r2,28(r2)
 3244d2c:	1004d23a 	srli	r2,r2,8
 3244d30:	11003fcc 	andi	r4,r2,255
 3244d34:	e0bffe17 	ldw	r2,-8(fp)
 3244d38:	10800717 	ldw	r2,28(r2)
 3244d3c:	1004d43a 	srli	r2,r2,16
 3244d40:	11403fcc 	andi	r5,r2,255
 3244d44:	e0bffe17 	ldw	r2,-8(fp)
 3244d48:	10800717 	ldw	r2,28(r2)
 3244d4c:	1004d63a 	srli	r2,r2,24
 3244d50:	e0fffc0b 	ldhu	r3,-16(fp)
 3244d54:	d9000015 	stw	r4,0(sp)
 3244d58:	d9400115 	stw	r5,4(sp)
 3244d5c:	d8800215 	stw	r2,8(sp)
 3244d60:	d8c00315 	stw	r3,12(sp)
 3244d64:	0100c974 	movhi	r4,805
 3244d68:	213f9604 	addi	r4,r4,-424
 3244d6c:	300b883a 	mov	r5,r6
 3244d70:	380d883a 	mov	r6,r7
 3244d74:	400f883a 	mov	r7,r8
 3244d78:	3206adc0 	call	3206adc <printf>
    PUSH_IPADDR(p->fhost), fport);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 3244d7c:	0009883a 	mov	r4,zero
 3244d80:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   /* prepend UDP header to upper layer's data */
   p->nb_prot -= sizeof(struct udp);
 3244d84:	e0bffe17 	ldw	r2,-8(fp)
 3244d88:	10800317 	ldw	r2,12(r2)
 3244d8c:	10fffe04 	addi	r3,r2,-8
 3244d90:	e0bffe17 	ldw	r2,-8(fp)
 3244d94:	10c00315 	stw	r3,12(r2)
   pup = (struct udp*)p->nb_prot;
 3244d98:	e0bffe17 	ldw	r2,-8(fp)
 3244d9c:	10800317 	ldw	r2,12(r2)
 3244da0:	e0bff815 	stw	r2,-32(fp)
   udplen = p->nb_plen + sizeof(struct udp);
 3244da4:	e0bffe17 	ldw	r2,-8(fp)
 3244da8:	10800417 	ldw	r2,16(r2)
 3244dac:	10800204 	addi	r2,r2,8
 3244db0:	e0bff615 	stw	r2,-40(fp)
   p->nb_plen = udplen;
 3244db4:	e0fff617 	ldw	r3,-40(fp)
 3244db8:	e0bffe17 	ldw	r2,-8(fp)
 3244dbc:	10c00415 	stw	r3,16(r2)
   if (udplen & 1) ((char *)pup)[udplen] = 0;
 3244dc0:	e0bff617 	ldw	r2,-40(fp)
 3244dc4:	1080004c 	andi	r2,r2,1
 3244dc8:	10803fcc 	andi	r2,r2,255
 3244dcc:	1005003a 	cmpeq	r2,r2,zero
 3244dd0:	1000041e 	bne	r2,zero,3244de4 <udp_send+0x10c>
 3244dd4:	e0fff817 	ldw	r3,-32(fp)
 3244dd8:	e0bff617 	ldw	r2,-40(fp)
 3244ddc:	1885883a 	add	r2,r3,r2
 3244de0:	10000005 	stb	zero,0(r2)

      pup->ud_len = (unshort)udplen;   /* fill in the UDP header */
 3244de4:	e0bff617 	ldw	r2,-40(fp)
 3244de8:	1007883a 	mov	r3,r2
 3244dec:	e0bff817 	ldw	r2,-32(fp)
 3244df0:	10c0010d 	sth	r3,4(r2)
   pup->ud_srcp = lport;
 3244df4:	e0fff817 	ldw	r3,-32(fp)
 3244df8:	e0bffd0b 	ldhu	r2,-12(fp)
 3244dfc:	1880000d 	sth	r2,0(r3)
   pup->ud_dstp = fport;
 3244e00:	e0fff817 	ldw	r3,-32(fp)
 3244e04:	e0bffc0b 	ldhu	r2,-16(fp)
 3244e08:	1880008d 	sth	r2,2(r3)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 3244e0c:	e13ff817 	ldw	r4,-32(fp)
 3244e10:	3244f900 	call	3244f90 <udpswap>
#endif   /* BYTE_ORDER */
   
#ifdef MULTI_HOMED
   /* getting the source IP address for a broadcast is a bit tricky: */
   if (p->fhost == 0xffffffff)
 3244e14:	e0bffe17 	ldw	r2,-8(fp)
 3244e18:	10800717 	ldw	r2,28(r2)
 3244e1c:	10bfffd8 	cmpnei	r2,r2,-1
 3244e20:	1000111e 	bne	r2,zero,3244e68 <udp_send+0x190>
   {
      if (!p->net)
 3244e24:	e0bffe17 	ldw	r2,-8(fp)
 3244e28:	10800617 	ldw	r2,24(r2)
 3244e2c:	1004c03a 	cmpne	r2,r2,zero
 3244e30:	1000081e 	bne	r2,zero,3244e54 <udp_send+0x17c>
      {
         dtrap();    /* programmer forgot to select iface */
 3244e34:	322ab8c0 	call	322ab8c <dtrap>
         /* it would appear that the callers of udp_send() expect it
            to do cleanup on failure, so free the packet buffer here */
         udp_free(p);
 3244e38:	e13ffe17 	ldw	r4,-8(fp)
 3244e3c:	324527c0 	call	324527c <udp_free>
         UNLOCK_NET_RESOURCE(NET_RESID);
 3244e40:	0009883a 	mov	r4,zero
 3244e44:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
         return ENP_NO_IFACE;
 3244e48:	00bff784 	movi	r2,-34
 3244e4c:	e0bfff15 	stw	r2,-4(fp)
 3244e50:	00004906 	br	3244f78 <udp_send+0x2a0>
      }
      src_ip = p->net->n_ipaddr;
 3244e54:	e0bffe17 	ldw	r2,-8(fp)
 3244e58:	10800617 	ldw	r2,24(r2)
 3244e5c:	10800a17 	ldw	r2,40(r2)
 3244e60:	e0bff415 	stw	r2,-48(fp)
 3244e64:	00000406 	br	3244e78 <udp_send+0x1a0>
   /* set the IP addresses in the IP header. The pseudo header used for
    * checksumming overlays the addresses on the IP header area in the
    * buffer, so setting them there (which we need to do for cksum
    * anyway) sets up for IP too.
    */
   src_ip = ip_mymach(p->fhost);
 3244e68:	e0bffe17 	ldw	r2,-8(fp)
 3244e6c:	11000717 	ldw	r4,28(r2)
 3244e70:	324018c0 	call	324018c <ip_mymach>
 3244e74:	e0bff415 	stw	r2,-48(fp)
   php.ph_src = src_ip;
 3244e78:	e0bff417 	ldw	r2,-48(fp)
 3244e7c:	e0bff915 	stw	r2,-28(fp)
   php.ph_dest = p->fhost;
 3244e80:	e0bffe17 	ldw	r2,-8(fp)
 3244e84:	10800717 	ldw	r2,28(r2)
 3244e88:	e0bffa15 	stw	r2,-24(fp)
#ifdef NO_UDP_CKSUM
   /* If no UDP checksum support, just zero the checksum field */
   pup->ud_cksum = 0;
#else
   /* finish filling in the pseudo header required for checksumming */
   php.ph_zero = 0;
 3244e8c:	e03ffb05 	stb	zero,-20(fp)
   php.ph_prot = UDP_PROT;
 3244e90:	00800444 	movi	r2,17
 3244e94:	e0bffb45 	stb	r2,-19(fp)
   php.ph_len = pup->ud_len;
 3244e98:	e0bff817 	ldw	r2,-32(fp)
 3244e9c:	1080010b 	ldhu	r2,4(r2)
 3244ea0:	e0bffb8d 	sth	r2,-18(fp)
   pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 3244ea4:	e13ff904 	addi	r4,fp,-28
 3244ea8:	01400184 	movi	r5,6
 3244eac:	32259f80 	call	32259f8 <cksum>
 3244eb0:	1007883a 	mov	r3,r2
 3244eb4:	e0bff817 	ldw	r2,-32(fp)
 3244eb8:	10c0018d 	sth	r3,6(r2)
   pup->ud_cksum = ~cksum(pup, (udplen+1)>>1);
 3244ebc:	e0bff617 	ldw	r2,-40(fp)
 3244ec0:	10800044 	addi	r2,r2,1
 3244ec4:	1005d07a 	srai	r2,r2,1
 3244ec8:	100b883a 	mov	r5,r2
 3244ecc:	e13ff817 	ldw	r4,-32(fp)
 3244ed0:	32259f80 	call	32259f8 <cksum>
 3244ed4:	0084303a 	nor	r2,zero,r2
 3244ed8:	1007883a 	mov	r3,r2
 3244edc:	e0bff817 	ldw	r2,-32(fp)
 3244ee0:	10c0018d 	sth	r3,6(r2)
   if (pup->ud_cksum == 0)
 3244ee4:	e0bff817 	ldw	r2,-32(fp)
 3244ee8:	1080018b 	ldhu	r2,6(r2)
 3244eec:	10bfffcc 	andi	r2,r2,65535
 3244ef0:	1004c03a 	cmpne	r2,r2,zero
 3244ef4:	1000031e 	bne	r2,zero,3244f04 <udp_send+0x22c>
      pup->ud_cksum = 0xffff;
 3244ef8:	e0fff817 	ldw	r3,-32(fp)
 3244efc:	00bfffc4 	movi	r2,-1
 3244f00:	1880018d 	sth	r2,6(r3)
#endif

   /* need to fill in IP addresses at this layer too */
   pip = (struct ip *)(p->nb_prot - sizeof(struct ip));
 3244f04:	e0bffe17 	ldw	r2,-8(fp)
 3244f08:	10800317 	ldw	r2,12(r2)
 3244f0c:	10bffb04 	addi	r2,r2,-20
 3244f10:	e0bff715 	stw	r2,-36(fp)
   pip->ip_src = src_ip;
 3244f14:	e0fff717 	ldw	r3,-36(fp)
 3244f18:	e0bff417 	ldw	r2,-48(fp)
 3244f1c:	18800315 	stw	r2,12(r3)
   pip->ip_dest = p->fhost;
 3244f20:	e0bffe17 	ldw	r2,-8(fp)
 3244f24:	10c00717 	ldw	r3,28(r2)
 3244f28:	e0bff717 	ldw	r2,-36(fp)
 3244f2c:	10c00415 	stw	r3,16(r2)

   udp_mib.udpOutDatagrams++;
 3244f30:	0080c9b4 	movhi	r2,806
 3244f34:	10b47a04 	addi	r2,r2,-11800
 3244f38:	10800317 	ldw	r2,12(r2)
 3244f3c:	10c00044 	addi	r3,r2,1
 3244f40:	0080c9b4 	movhi	r2,806
 3244f44:	10b47a04 	addi	r2,r2,-11800
 3244f48:	10c00315 	stw	r3,12(r2)

   p->nb_plen = udplen;       /* nb_prot was adjusted above */
 3244f4c:	e0fff617 	ldw	r3,-40(fp)
 3244f50:	e0bffe17 	ldw	r2,-8(fp)
 3244f54:	10c00415 	stw	r3,16(r2)
   e = ip_write(UDP_PROT, p);
 3244f58:	01000444 	movi	r4,17
 3244f5c:	e17ffe17 	ldw	r5,-8(fp)
 3244f60:	323f0100 	call	323f010 <ip_write>
 3244f64:	e0bff515 	stw	r2,-44(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 3244f68:	0009883a 	mov	r4,zero
 3244f6c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   return e;
 3244f70:	e0bff517 	ldw	r2,-44(fp)
 3244f74:	e0bfff15 	stw	r2,-4(fp)
 3244f78:	e0bfff17 	ldw	r2,-4(fp)
}
 3244f7c:	e037883a 	mov	sp,fp
 3244f80:	dfc00117 	ldw	ra,4(sp)
 3244f84:	df000017 	ldw	fp,0(sp)
 3244f88:	dec00204 	addi	sp,sp,8
 3244f8c:	f800283a 	ret

03244f90 <udpswap>:
 */

#if (BYTE_ORDER == LITTLE_ENDIAN)
void
udpswap(struct udp *pup)
{
 3244f90:	defffe04 	addi	sp,sp,-8
 3244f94:	df000115 	stw	fp,4(sp)
 3244f98:	df000104 	addi	fp,sp,4
 3244f9c:	e13fff15 	stw	r4,-4(fp)

   pup->ud_srcp = htons(pup->ud_srcp);
 3244fa0:	e0bfff17 	ldw	r2,-4(fp)
 3244fa4:	1080000b 	ldhu	r2,0(r2)
 3244fa8:	10bfffcc 	andi	r2,r2,65535
 3244fac:	1004d23a 	srli	r2,r2,8
 3244fb0:	10803fcc 	andi	r2,r2,255
 3244fb4:	1009883a 	mov	r4,r2
 3244fb8:	e0bfff17 	ldw	r2,-4(fp)
 3244fbc:	1080000b 	ldhu	r2,0(r2)
 3244fc0:	10bfffcc 	andi	r2,r2,65535
 3244fc4:	1004923a 	slli	r2,r2,8
 3244fc8:	1007883a 	mov	r3,r2
 3244fcc:	00bfc004 	movi	r2,-256
 3244fd0:	1884703a 	and	r2,r3,r2
 3244fd4:	2084b03a 	or	r2,r4,r2
 3244fd8:	1007883a 	mov	r3,r2
 3244fdc:	e0bfff17 	ldw	r2,-4(fp)
 3244fe0:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = htons(pup->ud_dstp);
 3244fe4:	e0bfff17 	ldw	r2,-4(fp)
 3244fe8:	1080008b 	ldhu	r2,2(r2)
 3244fec:	10bfffcc 	andi	r2,r2,65535
 3244ff0:	1004d23a 	srli	r2,r2,8
 3244ff4:	10803fcc 	andi	r2,r2,255
 3244ff8:	1009883a 	mov	r4,r2
 3244ffc:	e0bfff17 	ldw	r2,-4(fp)
 3245000:	1080008b 	ldhu	r2,2(r2)
 3245004:	10bfffcc 	andi	r2,r2,65535
 3245008:	1004923a 	slli	r2,r2,8
 324500c:	1007883a 	mov	r3,r2
 3245010:	00bfc004 	movi	r2,-256
 3245014:	1884703a 	and	r2,r3,r2
 3245018:	2084b03a 	or	r2,r4,r2
 324501c:	1007883a 	mov	r3,r2
 3245020:	e0bfff17 	ldw	r2,-4(fp)
 3245024:	10c0008d 	sth	r3,2(r2)
   pup->ud_len = htons(pup->ud_len);
 3245028:	e0bfff17 	ldw	r2,-4(fp)
 324502c:	1080010b 	ldhu	r2,4(r2)
 3245030:	10bfffcc 	andi	r2,r2,65535
 3245034:	1004d23a 	srli	r2,r2,8
 3245038:	10803fcc 	andi	r2,r2,255
 324503c:	1009883a 	mov	r4,r2
 3245040:	e0bfff17 	ldw	r2,-4(fp)
 3245044:	1080010b 	ldhu	r2,4(r2)
 3245048:	10bfffcc 	andi	r2,r2,65535
 324504c:	1004923a 	slli	r2,r2,8
 3245050:	1007883a 	mov	r3,r2
 3245054:	00bfc004 	movi	r2,-256
 3245058:	1884703a 	and	r2,r3,r2
 324505c:	2084b03a 	or	r2,r4,r2
 3245060:	1007883a 	mov	r3,r2
 3245064:	e0bfff17 	ldw	r2,-4(fp)
 3245068:	10c0010d 	sth	r3,4(r2)
   pup->ud_cksum = htons(pup->ud_cksum);
 324506c:	e0bfff17 	ldw	r2,-4(fp)
 3245070:	1080018b 	ldhu	r2,6(r2)
 3245074:	10bfffcc 	andi	r2,r2,65535
 3245078:	1004d23a 	srli	r2,r2,8
 324507c:	10803fcc 	andi	r2,r2,255
 3245080:	1009883a 	mov	r4,r2
 3245084:	e0bfff17 	ldw	r2,-4(fp)
 3245088:	1080018b 	ldhu	r2,6(r2)
 324508c:	10bfffcc 	andi	r2,r2,65535
 3245090:	1004923a 	slli	r2,r2,8
 3245094:	1007883a 	mov	r3,r2
 3245098:	00bfc004 	movi	r2,-256
 324509c:	1884703a 	and	r2,r3,r2
 32450a0:	2084b03a 	or	r2,r4,r2
 32450a4:	1007883a 	mov	r3,r2
 32450a8:	e0bfff17 	ldw	r2,-4(fp)
 32450ac:	10c0018d 	sth	r3,6(r2)
}
 32450b0:	e037883a 	mov	sp,fp
 32450b4:	df000017 	ldw	fp,0(sp)
 32450b8:	dec00104 	addi	sp,sp,4
 32450bc:	f800283a 	ret

032450c0 <udp_socket>:
#define  MINSOCKET   1200
static unshort usocket = 0;   /* next socket to grab */

unshort
udp_socket(void)
{
 32450c0:	defffe04 	addi	sp,sp,-8
 32450c4:	df000115 	stw	fp,4(sp)
 32450c8:	df000104 	addi	fp,sp,4
   UDPCONN tmp;

   if (usocket < MINSOCKET)
 32450cc:	d0a9080b 	ldhu	r2,-23520(gp)
 32450d0:	10bfffcc 	andi	r2,r2,65535
 32450d4:	10812c28 	cmpgeui	r2,r2,1200
 32450d8:	10000c1e 	bne	r2,zero,324510c <udp_socket+0x4c>
   {
      /* logic for for init and after wraps */
      usocket = (unshort)(cticks & 0x7fff);
 32450dc:	0080c974 	movhi	r2,805
 32450e0:	10925604 	addi	r2,r2,18776
 32450e4:	10800017 	ldw	r2,0(r2)
 32450e8:	109fffcc 	andi	r2,r2,32767
 32450ec:	d0a9080d 	sth	r2,-23520(gp)
      if (usocket < MINSOCKET)
 32450f0:	d0a9080b 	ldhu	r2,-23520(gp)
 32450f4:	10bfffcc 	andi	r2,r2,65535
 32450f8:	10812c28 	cmpgeui	r2,r2,1200
 32450fc:	1000031e 	bne	r2,zero,324510c <udp_socket+0x4c>
         usocket += MINSOCKET;
 3245100:	d0a9080b 	ldhu	r2,-23520(gp)
 3245104:	10812c04 	addi	r2,r2,1200
 3245108:	d0a9080d 	sth	r2,-23520(gp)
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 324510c:	0080c974 	movhi	r2,805
 3245110:	10924a04 	addi	r2,r2,18728
 3245114:	10800017 	ldw	r2,0(r2)
 3245118:	e0bfff15 	stw	r2,-4(fp)
 324511c:	00001006 	br	3245160 <udp_socket+0xa0>
   {
      if (tmp->u_lport == usocket)
 3245120:	e0bfff17 	ldw	r2,-4(fp)
 3245124:	1080018b 	ldhu	r2,6(r2)
 3245128:	d0e9080b 	ldhu	r3,-23520(gp)
 324512c:	113fffcc 	andi	r4,r2,65535
 3245130:	18bfffcc 	andi	r2,r3,65535
 3245134:	2080071e 	bne	r4,r2,3245154 <udp_socket+0x94>
      {
         usocket++;     /* bump socket number */
 3245138:	d0a9080b 	ldhu	r2,-23520(gp)
 324513c:	10800044 	addi	r2,r2,1
 3245140:	d0a9080d 	sth	r2,-23520(gp)
         tmp = firstudp;   /* restart scan */
 3245144:	0080c974 	movhi	r2,805
 3245148:	10924a04 	addi	r2,r2,18728
 324514c:	10800017 	ldw	r2,0(r2)
 3245150:	e0bfff15 	stw	r2,-4(fp)
      usocket = (unshort)(cticks & 0x7fff);
      if (usocket < MINSOCKET)
         usocket += MINSOCKET;
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 3245154:	e0bfff17 	ldw	r2,-4(fp)
 3245158:	10800017 	ldw	r2,0(r2)
 324515c:	e0bfff15 	stw	r2,-4(fp)
 3245160:	e0bfff17 	ldw	r2,-4(fp)
 3245164:	1004c03a 	cmpne	r2,r2,zero
 3245168:	103fed1e 	bne	r2,zero,3245120 <udp_socket+0x60>
         usocket++;     /* bump socket number */
         tmp = firstudp;   /* restart scan */
         continue;
      }
   }
   return usocket++;
 324516c:	d0a9080b 	ldhu	r2,-23520(gp)
 3245170:	10ffffcc 	andi	r3,r2,65535
 3245174:	10800044 	addi	r2,r2,1
 3245178:	d0a9080d 	sth	r2,-23520(gp)
 324517c:	1805883a 	mov	r2,r3
}
 3245180:	e037883a 	mov	sp,fp
 3245184:	df000017 	ldw	fp,0(sp)
 3245188:	dec00104 	addi	sp,sp,4
 324518c:	f800283a 	ret

03245190 <udp_alloc>:
 * RETURNS:  Returns buffer, or NULL in no buffer was available. 
 */

PACKET
udp_alloc(int datalen, int optlen)
{
 3245190:	defffa04 	addi	sp,sp,-24
 3245194:	dfc00515 	stw	ra,20(sp)
 3245198:	df000415 	stw	fp,16(sp)
 324519c:	df000404 	addi	fp,sp,16
 32451a0:	e13ffe15 	stw	r4,-8(fp)
 32451a4:	e17fff15 	stw	r5,-4(fp)
   int   len;
   PACKET p;

   len = (datalen + sizeof(struct udp) + 1) & ~1;
 32451a8:	e0bffe17 	ldw	r2,-8(fp)
 32451ac:	10800244 	addi	r2,r2,9
 32451b0:	1007883a 	mov	r3,r2
 32451b4:	00bfff84 	movi	r2,-2
 32451b8:	1884703a 	and	r2,r3,r2
 32451bc:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 32451c0:	01000084 	movi	r4,2
 32451c4:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   p = pk_alloc(len + UDPHDRSLEN + optlen);
 32451c8:	e0fffd17 	ldw	r3,-12(fp)
 32451cc:	e0bfff17 	ldw	r2,-4(fp)
 32451d0:	1885883a 	add	r2,r3,r2
 32451d4:	10800904 	addi	r2,r2,36
 32451d8:	1009883a 	mov	r4,r2
 32451dc:	3229f480 	call	3229f48 <pk_alloc>
 32451e0:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32451e4:	01000084 	movi	r4,2
 32451e8:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   if (p != (PACKET)NULL)
 32451ec:	e0bffc17 	ldw	r2,-16(fp)
 32451f0:	1005003a 	cmpeq	r2,r2,zero
 32451f4:	1000101e 	bne	r2,zero,3245238 <udp_alloc+0xa8>
   {
      /* set prot pointers past end of UDP header  */
      len = sizeof(struct ip) + (optlen >> 2) + sizeof(struct udp);
 32451f8:	e0bfff17 	ldw	r2,-4(fp)
 32451fc:	1005d0ba 	srai	r2,r2,2
 3245200:	10800704 	addi	r2,r2,28
 3245204:	e0bffd15 	stw	r2,-12(fp)
      p->nb_prot += len;
 3245208:	e0bffc17 	ldw	r2,-16(fp)
 324520c:	10c00317 	ldw	r3,12(r2)
 3245210:	e0bffd17 	ldw	r2,-12(fp)
 3245214:	1887883a 	add	r3,r3,r2
 3245218:	e0bffc17 	ldw	r2,-16(fp)
 324521c:	10c00315 	stw	r3,12(r2)
      p->nb_plen -= len;
 3245220:	e0bffc17 	ldw	r2,-16(fp)
 3245224:	10c00417 	ldw	r3,16(r2)
 3245228:	e0bffd17 	ldw	r2,-12(fp)
 324522c:	1887c83a 	sub	r3,r3,r2
 3245230:	e0bffc17 	ldw	r2,-16(fp)
 3245234:	10c00415 	stw	r3,16(r2)
   }

   return (p);
 3245238:	e0bffc17 	ldw	r2,-16(fp)
}
 324523c:	e037883a 	mov	sp,fp
 3245240:	dfc00117 	ldw	ra,4(sp)
 3245244:	df000017 	ldw	fp,0(sp)
 3245248:	dec00204 	addi	sp,sp,8
 324524c:	f800283a 	ret

03245250 <udp_maxalloc>:
 *          returned value, the allocation will fail
 */

int
udp_maxalloc(void)
{
 3245250:	deffff04 	addi	sp,sp,-4
 3245254:	df000015 	stw	fp,0(sp)
 3245258:	d839883a 	mov	fp,sp
    * created is ((2^16 - 1) - (size of IP and UDP headers)) */
   return (0xFFFF - (sizeof (struct ip) + sizeof (struct udp)));
#else
   /* if heap buffers are not available, the largest size of a UDP datagram
    * is constrained by what will fit inside a big buffer */
   return (bigbufsiz - UDPHDRSLEN);
 324525c:	0080c974 	movhi	r2,805
 3245260:	1089ac04 	addi	r2,r2,9904
 3245264:	10800017 	ldw	r2,0(r2)
 3245268:	10bff704 	addi	r2,r2,-36
#endif
}
 324526c:	e037883a 	mov	sp,fp
 3245270:	df000017 	ldw	fp,0(sp)
 3245274:	dec00104 	addi	sp,sp,4
 3245278:	f800283a 	ret

0324527c <udp_free>:
 * RETURNS: void
 */

void
udp_free(PACKET p)
{
 324527c:	defffd04 	addi	sp,sp,-12
 3245280:	dfc00215 	stw	ra,8(sp)
 3245284:	df000115 	stw	fp,4(sp)
 3245288:	df000104 	addi	fp,sp,4
 324528c:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 3245290:	01000084 	movi	r4,2
 3245294:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   pk_free(p);
 3245298:	e13fff17 	ldw	r4,-4(fp)
 324529c:	322a2dc0 	call	322a2dc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32452a0:	01000084 	movi	r4,2
 32452a4:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
}
 32452a8:	e037883a 	mov	sp,fp
 32452ac:	dfc00117 	ldw	ra,4(sp)
 32452b0:	df000017 	ldw	fp,0(sp)
 32452b4:	dec00204 	addi	sp,sp,8
 32452b8:	f800283a 	ret

032452bc <igmpv1_input>:
 * OUTPUT: This function returns IGMP_ERR if it is passed an "unknown"
 * packet type.  Otherwise, it returns IGMP_OK.
 */

int igmpv1_input(PACKET p)
{
 32452bc:	defff704 	addi	sp,sp,-36
 32452c0:	dfc00815 	stw	ra,32(sp)
 32452c4:	df000715 	stw	fp,28(sp)
 32452c8:	df000704 	addi	fp,sp,28
 32452cc:	e13ffe15 	stw	r4,-8(fp)
   struct igmp *  igmp;
   struct ip *    pip;
   struct in_multi * inm;
   NET netp  = p->net;
 32452d0:	e0bffe17 	ldw	r2,-8(fp)
 32452d4:	10800617 	ldw	r2,24(r2)
 32452d8:	e0bffa15 	stw	r2,-24(fp)
   int rc;
         
   pip = ip_head (p);
 32452dc:	e0bffe17 	ldw	r2,-8(fp)
 32452e0:	10800317 	ldw	r2,12(r2)
 32452e4:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));
 32452e8:	e0bffc17 	ldw	r2,-16(fp)
 32452ec:	10800003 	ldbu	r2,0(r2)
 32452f0:	10803fcc 	andi	r2,r2,255
 32452f4:	108003cc 	andi	r2,r2,15
 32452f8:	1085883a 	add	r2,r2,r2
 32452fc:	1085883a 	add	r2,r2,r2
 3245300:	1007883a 	mov	r3,r2
 3245304:	e0bffc17 	ldw	r2,-16(fp)
 3245308:	1885883a 	add	r2,r3,r2
 324530c:	e0bffd15 	stw	r2,-12(fp)

   switch (igmp->igmp_type) 
 3245310:	e0bffd17 	ldw	r2,-12(fp)
 3245314:	10800003 	ldbu	r2,0(r2)
 3245318:	10803fcc 	andi	r2,r2,255
 324531c:	e0bfff15 	stw	r2,-4(fp)
 3245320:	e0ffff17 	ldw	r3,-4(fp)
 3245324:	18800460 	cmpeqi	r2,r3,17
 3245328:	1000041e 	bne	r2,zero,324533c <igmpv1_input+0x80>
 324532c:	e0ffff17 	ldw	r3,-4(fp)
 3245330:	188004a0 	cmpeqi	r2,r3,18
 3245334:	1000611e 	bne	r2,zero,32454bc <igmpv1_input+0x200>
 3245338:	00008506 	br	3245550 <igmpv1_input+0x294>
   {
   case IGMP_HOST_MEMBERSHIP_QUERY:
      ++igmpstats.igmpv1mode_v1_queries_rcvd;
 324533c:	0080c9b4 	movhi	r2,806
 3245340:	10b25e04 	addi	r2,r2,-13960
 3245344:	10800117 	ldw	r2,4(r2)
 3245348:	10c00044 	addi	r3,r2,1
 324534c:	0080c9b4 	movhi	r2,806
 3245350:	10b25e04 	addi	r2,r2,-13960
 3245354:	10c00115 	stw	r3,4(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 3245358:	e0bffa17 	ldw	r2,-24(fp)
 324535c:	10802c17 	ldw	r2,176(r2)
 3245360:	e0bffb15 	stw	r2,-20(fp)
 3245364:	00005006 	br	32454a8 <igmpv1_input+0x1ec>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
 3245368:	e0bffb17 	ldw	r2,-20(fp)
 324536c:	10800017 	ldw	r2,0(r2)
 3245370:	1005003a 	cmpeq	r2,r2,zero
 3245374:	1000491e 	bne	r2,zero,324549c <igmpv1_input+0x1e0>
            continue;
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 3245378:	e0bffb17 	ldw	r2,-20(fp)
 324537c:	10c00017 	ldw	r3,0(r2)
 3245380:	0080c974 	movhi	r2,805
 3245384:	10923604 	addi	r2,r2,18648
 3245388:	10800017 	ldw	r2,0(r2)
 324538c:	18804326 	beq	r3,r2,324549c <igmpv1_input+0x1e0>
         {
            if (inm->inm_timer == 0)
 3245390:	e0bffb17 	ldw	r2,-20(fp)
 3245394:	10800317 	ldw	r2,12(r2)
 3245398:	1004c03a 	cmpne	r2,r2,zero
 324539c:	10003f1e 	bne	r2,zero,324549c <igmpv1_input+0x1e0>
            {
               inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 32453a0:	0080c9b4 	movhi	r2,806
 32453a4:	10b46004 	addi	r2,r2,-11904
 32453a8:	11000217 	ldw	r4,8(r2)
 32453ac:	0080c9b4 	movhi	r2,806
 32453b0:	10b25a04 	addi	r2,r2,-13976
 32453b4:	10800017 	ldw	r2,0(r2)
 32453b8:	10800a17 	ldw	r2,40(r2)
 32453bc:	1004d63a 	srli	r2,r2,24
 32453c0:	10c03fcc 	andi	r3,r2,255
 32453c4:	0080c9b4 	movhi	r2,806
 32453c8:	10b25a04 	addi	r2,r2,-13976
 32453cc:	10800017 	ldw	r2,0(r2)
 32453d0:	10800a17 	ldw	r2,40(r2)
 32453d4:	1004d23a 	srli	r2,r2,8
 32453d8:	10bfc00c 	andi	r2,r2,65280
 32453dc:	1886b03a 	or	r3,r3,r2
 32453e0:	0080c9b4 	movhi	r2,806
 32453e4:	10b25a04 	addi	r2,r2,-13976
 32453e8:	10800017 	ldw	r2,0(r2)
 32453ec:	10800a17 	ldw	r2,40(r2)
 32453f0:	10bfc00c 	andi	r2,r2,65280
 32453f4:	1004923a 	slli	r2,r2,8
 32453f8:	1886b03a 	or	r3,r3,r2
 32453fc:	0080c9b4 	movhi	r2,806
 3245400:	10b25a04 	addi	r2,r2,-13976
 3245404:	10800017 	ldw	r2,0(r2)
 3245408:	10800a17 	ldw	r2,40(r2)
 324540c:	10803fcc 	andi	r2,r2,255
 3245410:	1004963a 	slli	r2,r2,24
 3245414:	1884b03a 	or	r2,r3,r2
 3245418:	2089883a 	add	r4,r4,r2
 324541c:	e0bffb17 	ldw	r2,-20(fp)
 3245420:	10800017 	ldw	r2,0(r2)
 3245424:	1004d63a 	srli	r2,r2,24
 3245428:	10c03fcc 	andi	r3,r2,255
 324542c:	e0bffb17 	ldw	r2,-20(fp)
 3245430:	10800017 	ldw	r2,0(r2)
 3245434:	1004d23a 	srli	r2,r2,8
 3245438:	10bfc00c 	andi	r2,r2,65280
 324543c:	1886b03a 	or	r3,r3,r2
 3245440:	e0bffb17 	ldw	r2,-20(fp)
 3245444:	10800017 	ldw	r2,0(r2)
 3245448:	10bfc00c 	andi	r2,r2,65280
 324544c:	1004923a 	slli	r2,r2,8
 3245450:	1886b03a 	or	r3,r3,r2
 3245454:	e0bffb17 	ldw	r2,-20(fp)
 3245458:	10800017 	ldw	r2,0(r2)
 324545c:	10803fcc 	andi	r2,r2,255
 3245460:	1004963a 	slli	r2,r2,24
 3245464:	1884b03a 	or	r2,r3,r2
 3245468:	2089883a 	add	r4,r4,r2
 324546c:	01400c84 	movi	r5,50
 3245470:	32044c40 	call	32044c4 <__umodsi3>
 3245474:	10c00044 	addi	r3,r2,1
 3245478:	e0bffb17 	ldw	r2,-20(fp)
 324547c:	10c00315 	stw	r3,12(r2)
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
 3245480:	0080c974 	movhi	r2,805
 3245484:	10923404 	addi	r2,r2,18640
 3245488:	10800017 	ldw	r2,0(r2)
 324548c:	10c00044 	addi	r3,r2,1
 3245490:	0080c974 	movhi	r2,805
 3245494:	10923404 	addi	r2,r2,18640
 3245498:	10c00015 	stw	r3,0(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 324549c:	e0bffb17 	ldw	r2,-20(fp)
 32454a0:	10800517 	ldw	r2,20(r2)
 32454a4:	e0bffb15 	stw	r2,-20(fp)
 32454a8:	e0bffb17 	ldw	r2,-20(fp)
 32454ac:	1004c03a 	cmpne	r2,r2,zero
 32454b0:	103fad1e 	bne	r2,zero,3245368 <igmpv1_input+0xac>
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
            }   
         }
      }
      rc = IGMP_OK;
 32454b4:	e03ff915 	stw	zero,-28(fp)
      break;
 32454b8:	00002e06 	br	3245574 <igmpv1_input+0x2b8>

   case IGMP_HOST_MEMBERSHIP_REPORT:
      ++igmpstats.igmpv1mode_v1_reports_rcvd;
 32454bc:	0080c9b4 	movhi	r2,806
 32454c0:	10b25e04 	addi	r2,r2,-13960
 32454c4:	10800217 	ldw	r2,8(r2)
 32454c8:	10c00044 	addi	r3,r2,1
 32454cc:	0080c9b4 	movhi	r2,806
 32454d0:	10b25e04 	addi	r2,r2,-13960
 32454d4:	10c00215 	stw	r3,8(r2)
      /*
       * If we belong to the group being reported and have a 
       * running timer for that group, stop our timer for that 
       * group.
       */
      inm = lookup_mcast(igmp->igmp_group, netp);
 32454d8:	e0bffd17 	ldw	r2,-12(fp)
 32454dc:	11000117 	ldw	r4,4(r2)
 32454e0:	e17ffa17 	ldw	r5,-24(fp)
 32454e4:	32436ec0 	call	32436ec <lookup_mcast>
 32454e8:	e0bffb15 	stw	r2,-20(fp)
      if (inm != NULL) 
 32454ec:	e0bffb17 	ldw	r2,-20(fp)
 32454f0:	1005003a 	cmpeq	r2,r2,zero
 32454f4:	1000141e 	bne	r2,zero,3245548 <igmpv1_input+0x28c>
      {
         if (inm->inm_timer > 0)
 32454f8:	e0bffb17 	ldw	r2,-20(fp)
 32454fc:	10800317 	ldw	r2,12(r2)
 3245500:	1005003a 	cmpeq	r2,r2,zero
 3245504:	1000101e 	bne	r2,zero,3245548 <igmpv1_input+0x28c>
         {
            inm->inm_timer = 0;
 3245508:	e0bffb17 	ldw	r2,-20(fp)
 324550c:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 3245510:	0080c974 	movhi	r2,805
 3245514:	10923404 	addi	r2,r2,18640
 3245518:	10800017 	ldw	r2,0(r2)
 324551c:	10ffffc4 	addi	r3,r2,-1
 3245520:	0080c974 	movhi	r2,805
 3245524:	10923404 	addi	r2,r2,18640
 3245528:	10c00015 	stw	r3,0(r2)
            ++igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer;
 324552c:	0080c9b4 	movhi	r2,806
 3245530:	10b25e04 	addi	r2,r2,-13960
 3245534:	10800317 	ldw	r2,12(r2)
 3245538:	10c00044 	addi	r3,r2,1
 324553c:	0080c9b4 	movhi	r2,806
 3245540:	10b25e04 	addi	r2,r2,-13960
 3245544:	10c00315 	stw	r3,12(r2)
         }
      }
      rc = IGMP_OK;
 3245548:	e03ff915 	stw	zero,-28(fp)
      break;
 324554c:	00000906 	br	3245574 <igmpv1_input+0x2b8>
      
   default:
      ++igmpstats.igmpv1mode_unknown_pkttype;
 3245550:	0080c9b4 	movhi	r2,806
 3245554:	10b25e04 	addi	r2,r2,-13960
 3245558:	10801017 	ldw	r2,64(r2)
 324555c:	10c00044 	addi	r3,r2,1
 3245560:	0080c9b4 	movhi	r2,806
 3245564:	10b25e04 	addi	r2,r2,-13960
 3245568:	10c01015 	stw	r3,64(r2)
      rc = IGMP_ERR;
 324556c:	00bfffc4 	movi	r2,-1
 3245570:	e0bff915 	stw	r2,-28(fp)
      break;   
   }

   /* we're done with the received packet; return packet buffer back 
    * to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 3245574:	01000084 	movi	r4,2
 3245578:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   pk_free(p);
 324557c:	e13ffe17 	ldw	r4,-8(fp)
 3245580:	322a2dc0 	call	322a2dc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3245584:	01000084 	movi	r4,2
 3245588:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      
   return rc;
 324558c:	e0bff917 	ldw	r2,-28(fp)
}
 3245590:	e037883a 	mov	sp,fp
 3245594:	dfc00117 	ldw	ra,4(sp)
 3245598:	df000017 	ldw	fp,0(sp)
 324559c:	dec00204 	addi	sp,sp,8
 32455a0:	f800283a 	ret

032455a4 <igmpv2_input>:
 * from igmpv2_process_report (), IGMP_OK (for a received Leave Group
 * message only), or IGMP_ERR (for a message of an "unknown" type).
 */

int igmpv2_input (PACKET p)
{
 32455a4:	defff704 	addi	sp,sp,-36
 32455a8:	dfc00815 	stw	ra,32(sp)
 32455ac:	df000715 	stw	fp,28(sp)
 32455b0:	df000704 	addi	fp,sp,28
 32455b4:	e13ffe15 	stw	r4,-8(fp)
   struct ip * pip;
   int igmplen;
   u_char type;
   int rc;

   pip = ip_head (p);    
 32455b8:	e0bffe17 	ldw	r2,-8(fp)
 32455bc:	10800317 	ldw	r2,12(r2)
 32455c0:	e0bffc15 	stw	r2,-16(fp)
   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */   
   igmplen = p->nb_plen - ip_hlen (pip);
 32455c4:	e0bffe17 	ldw	r2,-8(fp)
 32455c8:	10c00417 	ldw	r3,16(r2)
 32455cc:	e0bffc17 	ldw	r2,-16(fp)
 32455d0:	10800003 	ldbu	r2,0(r2)
 32455d4:	10803fcc 	andi	r2,r2,255
 32455d8:	108003cc 	andi	r2,r2,15
 32455dc:	1085883a 	add	r2,r2,r2
 32455e0:	1085883a 	add	r2,r2,r2
 32455e4:	1885c83a 	sub	r2,r3,r2
 32455e8:	e0bffb15 	stw	r2,-20(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 32455ec:	e0bffc17 	ldw	r2,-16(fp)
 32455f0:	10800003 	ldbu	r2,0(r2)
 32455f4:	10803fcc 	andi	r2,r2,255
 32455f8:	108003cc 	andi	r2,r2,15
 32455fc:	1085883a 	add	r2,r2,r2
 3245600:	1085883a 	add	r2,r2,r2
 3245604:	1007883a 	mov	r3,r2
 3245608:	e0bffc17 	ldw	r2,-16(fp)
 324560c:	1885883a 	add	r2,r3,r2
 3245610:	e0bffd15 	stw	r2,-12(fp)
   /* extract the IGMP packet type from received packet */
   type = igmp->igmp_type;
 3245614:	e0bffd17 	ldw	r2,-12(fp)
 3245618:	10800003 	ldbu	r2,0(r2)
 324561c:	e0bffa05 	stb	r2,-24(fp)

   switch (type) 
 3245620:	e0bffa03 	ldbu	r2,-24(fp)
 3245624:	e0bfff15 	stw	r2,-4(fp)
 3245628:	e0ffff17 	ldw	r3,-4(fp)
 324562c:	188004a0 	cmpeqi	r2,r3,18
 3245630:	1000121e 	bne	r2,zero,324567c <igmpv2_input+0xd8>
 3245634:	e0ffff17 	ldw	r3,-4(fp)
 3245638:	188004c8 	cmpgei	r2,r3,19
 324563c:	1000041e 	bne	r2,zero,3245650 <igmpv2_input+0xac>
 3245640:	e0ffff17 	ldw	r3,-4(fp)
 3245644:	18800460 	cmpeqi	r2,r3,17
 3245648:	1000081e 	bne	r2,zero,324566c <igmpv2_input+0xc8>
 324564c:	00001806 	br	32456b0 <igmpv2_input+0x10c>
 3245650:	e0ffff17 	ldw	r3,-4(fp)
 3245654:	188005a0 	cmpeqi	r2,r3,22
 3245658:	1000081e 	bne	r2,zero,324567c <igmpv2_input+0xd8>
 324565c:	e0ffff17 	ldw	r3,-4(fp)
 3245660:	188005e0 	cmpeqi	r2,r3,23
 3245664:	1000091e 	bne	r2,zero,324568c <igmpv2_input+0xe8>
 3245668:	00001106 	br	32456b0 <igmpv2_input+0x10c>
   {
      case IGMP_HOST_MEMBERSHIP_QUERY:
         rc = igmpv2_process_query (p);
 324566c:	e13ffe17 	ldw	r4,-8(fp)
 3245670:	32458500 	call	3245850 <igmpv2_process_query>
 3245674:	e0bff915 	stw	r2,-28(fp)
         break;
 3245678:	00001606 	br	32456d4 <igmpv2_input+0x130>

      case IGMP_HOST_MEMBERSHIP_REPORT:
      case IGMPv2_MEMBERSHIP_REPORT:
         rc = igmpv2_process_report (p);
 324567c:	e13ffe17 	ldw	r4,-8(fp)
 3245680:	32457040 	call	3245704 <igmpv2_process_report>
 3245684:	e0bff915 	stw	r2,-28(fp)
         break;
 3245688:	00001206 	br	32456d4 <igmpv2_input+0x130>
          * expect to receive such messages.  However, according to
          * RFC 2236, some implementations of an older version of the 
          * IGMPv2 specification send leave messages to the group 
          * being left.  If we do receive such a message, we will 
          * drop it. */       
         ++igmpstats.igmpv2mode_v2_leave_msgs_rcvd;
 324568c:	0080c9b4 	movhi	r2,806
 3245690:	10b25e04 	addi	r2,r2,-13960
 3245694:	10800917 	ldw	r2,36(r2)
 3245698:	10c00044 	addi	r3,r2,1
 324569c:	0080c9b4 	movhi	r2,806
 32456a0:	10b25e04 	addi	r2,r2,-13960
 32456a4:	10c00915 	stw	r3,36(r2)
         rc = IGMP_OK;
 32456a8:	e03ff915 	stw	zero,-28(fp)
         break;               
 32456ac:	00000906 	br	32456d4 <igmpv2_input+0x130>

      default:     
         ++igmpstats.igmpv2mode_unknown_pkttype;
 32456b0:	0080c9b4 	movhi	r2,806
 32456b4:	10b25e04 	addi	r2,r2,-13960
 32456b8:	10801517 	ldw	r2,84(r2)
 32456bc:	10c00044 	addi	r3,r2,1
 32456c0:	0080c9b4 	movhi	r2,806
 32456c4:	10b25e04 	addi	r2,r2,-13960
 32456c8:	10c01515 	stw	r3,84(r2)
         rc = IGMP_ERR;         
 32456cc:	00bfffc4 	movi	r2,-1
 32456d0:	e0bff915 	stw	r2,-28(fp)
         break;
   } /* end SWITCH */

   /* we're done processing the received packet; return packet buffer 
    * back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 32456d4:	01000084 	movi	r4,2
 32456d8:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   pk_free(p);
 32456dc:	e13ffe17 	ldw	r4,-8(fp)
 32456e0:	322a2dc0 	call	322a2dc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32456e4:	01000084 	movi	r4,2
 32456e8:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
   
   return rc;
 32456ec:	e0bff917 	ldw	r2,-28(fp)
}
 32456f0:	e037883a 	mov	sp,fp
 32456f4:	dfc00117 	ldw	ra,4(sp)
 32456f8:	df000017 	ldw	fp,0(sp)
 32456fc:	dec00204 	addi	sp,sp,8
 3245700:	f800283a 	ret

03245704 <igmpv2_process_report>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_report (PACKET p)
{
 3245704:	defff904 	addi	sp,sp,-28
 3245708:	dfc00615 	stw	ra,24(sp)
 324570c:	df000515 	stw	fp,20(sp)
 3245710:	df000504 	addi	fp,sp,20
 3245714:	e13fff15 	stw	r4,-4(fp)
   struct igmp * igmp;
   struct ip * pip;
   NET netp;
   struct in_multi * inm;

   netp = p->net;
 3245718:	e0bfff17 	ldw	r2,-4(fp)
 324571c:	10800617 	ldw	r2,24(r2)
 3245720:	e0bffc15 	stw	r2,-16(fp)
   pip = ip_head (p);
 3245724:	e0bfff17 	ldw	r2,-4(fp)
 3245728:	10800317 	ldw	r2,12(r2)
 324572c:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 3245730:	e0bffd17 	ldw	r2,-12(fp)
 3245734:	10800003 	ldbu	r2,0(r2)
 3245738:	10803fcc 	andi	r2,r2,255
 324573c:	108003cc 	andi	r2,r2,15
 3245740:	1085883a 	add	r2,r2,r2
 3245744:	1085883a 	add	r2,r2,r2
 3245748:	1007883a 	mov	r3,r2
 324574c:	e0bffd17 	ldw	r2,-12(fp)
 3245750:	1885883a 	add	r2,r3,r2
 3245754:	e0bffe15 	stw	r2,-8(fp)
    * processing IGMPv2 packets (it has "downgraded" itself because
    * there are IGMPv1 routers on that network); however, we do not
    * know that, and hence we don't cancel our timer (for the 
    * subsequent transmission of a IGMPv1 report).
    */
   inm = lookup_mcast(igmp->igmp_group, netp);
 3245758:	e0bffe17 	ldw	r2,-8(fp)
 324575c:	11000117 	ldw	r4,4(r2)
 3245760:	e17ffc17 	ldw	r5,-16(fp)
 3245764:	32436ec0 	call	32436ec <lookup_mcast>
 3245768:	e0bffb15 	stw	r2,-20(fp)
   if (inm != NULL) 
 324576c:	e0bffb17 	ldw	r2,-20(fp)
 3245770:	1005003a 	cmpeq	r2,r2,zero
 3245774:	1000291e 	bne	r2,zero,324581c <igmpv2_process_report+0x118>
   {
      if (inm->inm_timer != 0)
 3245778:	e0bffb17 	ldw	r2,-20(fp)
 324577c:	10800317 	ldw	r2,12(r2)
 3245780:	1005003a 	cmpeq	r2,r2,zero
 3245784:	10001d1e 	bne	r2,zero,32457fc <igmpv2_process_report+0xf8>
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 3245788:	e0bffc17 	ldw	r2,-16(fp)
 324578c:	10802d03 	ldbu	r2,180(r2)
 3245790:	10803fcc 	andi	r2,r2,255
 3245794:	1005003a 	cmpeq	r2,r2,zero
 3245798:	1000051e 	bne	r2,zero,32457b0 <igmpv2_process_report+0xac>
 324579c:	e0bffe17 	ldw	r2,-8(fp)
 32457a0:	10800003 	ldbu	r2,0(r2)
 32457a4:	10803fcc 	andi	r2,r2,255
 32457a8:	108005a0 	cmpeqi	r2,r2,22
 32457ac:	1000221e 	bne	r2,zero,3245838 <igmpv2_process_report+0x134>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
         {
            /* cancel timer */
            inm->inm_timer = 0;
 32457b0:	e0bffb17 	ldw	r2,-20(fp)
 32457b4:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 32457b8:	0080c974 	movhi	r2,805
 32457bc:	10923404 	addi	r2,r2,18640
 32457c0:	10800017 	ldw	r2,0(r2)
 32457c4:	10ffffc4 	addi	r3,r2,-1
 32457c8:	0080c974 	movhi	r2,805
 32457cc:	10923404 	addi	r2,r2,18640
 32457d0:	10c00015 	stw	r3,0(r2)
            /* indicate that we are not the last host to send a 
             * report for this group */
            inm->last2send_report = IGMP_FALSE;
 32457d4:	e0bffb17 	ldw	r2,-20(fp)
 32457d8:	10000405 	stb	zero,16(r2)
            ++igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer;
 32457dc:	0080c9b4 	movhi	r2,806
 32457e0:	10b25e04 	addi	r2,r2,-13960
 32457e4:	10800717 	ldw	r2,28(r2)
 32457e8:	10c00044 	addi	r3,r2,1
 32457ec:	0080c9b4 	movhi	r2,806
 32457f0:	10b25e04 	addi	r2,r2,-13960
 32457f4:	10c00715 	stw	r3,28(r2)
 32457f8:	00000f06 	br	3245838 <igmpv2_process_report+0x134>
      else
      {
         /* we don't have a timer running; perhaps the source
          * host has just joined the group, and has sent an
          * unsolicited report */
         ++igmpstats.igmpv2mode_v12_reports_rcvd_no_timer;   
 32457fc:	0080c9b4 	movhi	r2,806
 3245800:	10b25e04 	addi	r2,r2,-13960
 3245804:	10800817 	ldw	r2,32(r2)
 3245808:	10c00044 	addi	r3,r2,1
 324580c:	0080c9b4 	movhi	r2,806
 3245810:	10b25e04 	addi	r2,r2,-13960
 3245814:	10c00815 	stw	r3,32(r2)
 3245818:	00000706 	br	3245838 <igmpv2_process_report+0x134>
       * on that interface.  Even if imperfect filtering at the 
       * device level causes reports for unregistered groups to 
       * be passed up to the IP module, ip_rcv_phase2 () is 
       * responsible for dropping them, and so we should never
       * receive such packets. */
      ++igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd;
 324581c:	0080c9b4 	movhi	r2,806
 3245820:	10b25e04 	addi	r2,r2,-13960
 3245824:	10801317 	ldw	r2,76(r2)
 3245828:	10c00044 	addi	r3,r2,1
 324582c:	0080c9b4 	movhi	r2,806
 3245830:	10b25e04 	addi	r2,r2,-13960
 3245834:	10c01315 	stw	r3,76(r2)
   }
   
   return IGMP_OK;   
 3245838:	0005883a 	mov	r2,zero
}
 324583c:	e037883a 	mov	sp,fp
 3245840:	dfc00117 	ldw	ra,4(sp)
 3245844:	df000017 	ldw	fp,0(sp)
 3245848:	dec00204 	addi	sp,sp,8
 324584c:	f800283a 	ret

03245850 <igmpv2_process_query>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_query (PACKET p)
{
 3245850:	defff704 	addi	sp,sp,-36
 3245854:	dfc00815 	stw	ra,32(sp)
 3245858:	df000715 	stw	fp,28(sp)
 324585c:	df000704 	addi	fp,sp,28
 3245860:	e13fff15 	stw	r4,-4(fp)
   u_short max_resp_time;
   u_char process_all;
   struct in_multi * inm;
   ip_addr mcgrp_addr;

   netp = p->net;
 3245864:	e0bfff17 	ldw	r2,-4(fp)
 3245868:	10800617 	ldw	r2,24(r2)
 324586c:	e0bffc15 	stw	r2,-16(fp)
   pip = ip_head (p);
 3245870:	e0bfff17 	ldw	r2,-4(fp)
 3245874:	10800317 	ldw	r2,12(r2)
 3245878:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));
 324587c:	e0bffd17 	ldw	r2,-12(fp)
 3245880:	10800003 	ldbu	r2,0(r2)
 3245884:	10803fcc 	andi	r2,r2,255
 3245888:	108003cc 	andi	r2,r2,15
 324588c:	1085883a 	add	r2,r2,r2
 3245890:	1085883a 	add	r2,r2,r2
 3245894:	1007883a 	mov	r3,r2
 3245898:	e0bffd17 	ldw	r2,-12(fp)
 324589c:	1885883a 	add	r2,r3,r2
 32458a0:	e0bffe15 	stw	r2,-8(fp)
   mcgrp_addr = ntohl(igmp->igmp_group);
 32458a4:	e0bffe17 	ldw	r2,-8(fp)
 32458a8:	10800117 	ldw	r2,4(r2)
 32458ac:	1004d63a 	srli	r2,r2,24
 32458b0:	10c03fcc 	andi	r3,r2,255
 32458b4:	e0bffe17 	ldw	r2,-8(fp)
 32458b8:	10800117 	ldw	r2,4(r2)
 32458bc:	1004d23a 	srli	r2,r2,8
 32458c0:	10bfc00c 	andi	r2,r2,65280
 32458c4:	1886b03a 	or	r3,r3,r2
 32458c8:	e0bffe17 	ldw	r2,-8(fp)
 32458cc:	10800117 	ldw	r2,4(r2)
 32458d0:	10bfc00c 	andi	r2,r2,65280
 32458d4:	1004923a 	slli	r2,r2,8
 32458d8:	1886b03a 	or	r3,r3,r2
 32458dc:	e0bffe17 	ldw	r2,-8(fp)
 32458e0:	10800117 	ldw	r2,4(r2)
 32458e4:	10803fcc 	andi	r2,r2,255
 32458e8:	1004963a 	slli	r2,r2,24
 32458ec:	1884b03a 	or	r2,r3,r2
 32458f0:	e0bff915 	stw	r2,-28(fp)

   if (igmp->igmp_code == 0)
 32458f4:	e0bffe17 	ldw	r2,-8(fp)
 32458f8:	10800043 	ldbu	r2,1(r2)
 32458fc:	10803fcc 	andi	r2,r2,255
 3245900:	1004c03a 	cmpne	r2,r2,zero
 3245904:	1000141e 	bne	r2,zero,3245958 <igmpv2_process_query+0x108>
   {
      /* this is a IGMPv1 Host Membership Query */
      netp->igmpv1_rtr_present = IGMP_TRUE;
 3245908:	e0fffc17 	ldw	r3,-16(fp)
 324590c:	00800044 	movi	r2,1
 3245910:	18802d05 	stb	r2,180(r3)
      netp->igmpv1_query_rcvd_time = cticks;      
 3245914:	0080c974 	movhi	r2,805
 3245918:	10925604 	addi	r2,r2,18776
 324591c:	10c00017 	ldw	r3,0(r2)
 3245920:	e0bffc17 	ldw	r2,-16(fp)
 3245924:	10c02e15 	stw	r3,184(r2)
      ++igmpstats.igmpv2mode_v1_queries_rcvd;
 3245928:	0080c9b4 	movhi	r2,806
 324592c:	10b25e04 	addi	r2,r2,-13960
 3245930:	10800417 	ldw	r2,16(r2)
 3245934:	10c00044 	addi	r3,r2,1
 3245938:	0080c9b4 	movhi	r2,806
 324593c:	10b25e04 	addi	r2,r2,-13960
 3245940:	10c00415 	stw	r3,16(r2)
      /* set maximum time to respond to the equivalent of 10 
       * seconds worth of "ticks" (the timeout routine is
       * intended to be invoked PR_FASTHZ (5) times a second,
       * so each tick is equal to 200 ms) */
      max_resp_time = IGMP_MAX_HOST_REPORT_DELAY * PR_FASTHZ;
 3245944:	00800c84 	movi	r2,50
 3245948:	e0bffb8d 	sth	r2,-18(fp)
      process_all = IGMP_TRUE;
 324594c:	00800044 	movi	r2,1
 3245950:	e0bffb05 	stb	r2,-20(fp)
 3245954:	00001d06 	br	32459cc <igmpv2_process_query+0x17c>
   }
   else
   {
      /* this is either a IGMPv2 General Query or 
       * a IGMPv2 Group-Specific Query */
      if (igmp->igmp_group == 0)
 3245958:	e0bffe17 	ldw	r2,-8(fp)
 324595c:	10800117 	ldw	r2,4(r2)
 3245960:	1004c03a 	cmpne	r2,r2,zero
 3245964:	10000a1e 	bne	r2,zero,3245990 <igmpv2_process_query+0x140>
      {
         /* this is a IGMPv2 General Query */
         ++igmpstats.igmpv2mode_v2_general_queries_rcvd;
 3245968:	0080c9b4 	movhi	r2,806
 324596c:	10b25e04 	addi	r2,r2,-13960
 3245970:	10800517 	ldw	r2,20(r2)
 3245974:	10c00044 	addi	r3,r2,1
 3245978:	0080c9b4 	movhi	r2,806
 324597c:	10b25e04 	addi	r2,r2,-13960
 3245980:	10c00515 	stw	r3,20(r2)
         process_all = IGMP_TRUE;
 3245984:	00800044 	movi	r2,1
 3245988:	e0bffb05 	stb	r2,-20(fp)
 324598c:	00000806 	br	32459b0 <igmpv2_process_query+0x160>
      }
      else
      {
         /* this is a IGMPv2 Group-Specific Query */       
         ++igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd;
 3245990:	0080c9b4 	movhi	r2,806
 3245994:	10b25e04 	addi	r2,r2,-13960
 3245998:	10800617 	ldw	r2,24(r2)
 324599c:	10c00044 	addi	r3,r2,1
 32459a0:	0080c9b4 	movhi	r2,806
 32459a4:	10b25e04 	addi	r2,r2,-13960
 32459a8:	10c00615 	stw	r3,24(r2)
         process_all = IGMP_FALSE;
 32459ac:	e03ffb05 	stb	zero,-20(fp)
       * IGMPv2 General Query or a IGMPv2 Group-Specific Query,
       * set maximum time to respond to value extracted 
       * from received message. The value in the message
       * is in tenths of a second.  max_resp_time is in
       * units of ticks (where one tick is 200 ms) */
      max_resp_time = (igmp->igmp_code * PR_FASTHZ) / 10;
 32459b0:	e0bffe17 	ldw	r2,-8(fp)
 32459b4:	10800043 	ldbu	r2,1(r2)
 32459b8:	10c03fcc 	andi	r3,r2,255
 32459bc:	1804d7fa 	srli	r2,r3,31
 32459c0:	10c5883a 	add	r2,r2,r3
 32459c4:	1005d07a 	srai	r2,r2,1
 32459c8:	e0bffb8d 	sth	r2,-18(fp)
   
   /* process all entries in a link's multicast address linked
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
 32459cc:	e0bffb03 	ldbu	r2,-20(fp)
 32459d0:	1005003a 	cmpeq	r2,r2,zero
 32459d4:	1000181e 	bne	r2,zero,3245a38 <igmpv2_process_query+0x1e8>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 32459d8:	e0bffc17 	ldw	r2,-16(fp)
 32459dc:	10802c17 	ldw	r2,176(r2)
 32459e0:	e0bffa15 	stw	r2,-24(fp)
 32459e4:	00001006 	br	3245a28 <igmpv2_process_query+0x1d8>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 32459e8:	e0bffa17 	ldw	r2,-24(fp)
 32459ec:	10800017 	ldw	r2,0(r2)
 32459f0:	1005003a 	cmpeq	r2,r2,zero
 32459f4:	1000091e 	bne	r2,zero,3245a1c <igmpv2_process_query+0x1cc>
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 32459f8:	e0bffa17 	ldw	r2,-24(fp)
 32459fc:	10c00017 	ldw	r3,0(r2)
 3245a00:	0080c974 	movhi	r2,805
 3245a04:	10923604 	addi	r2,r2,18648
 3245a08:	10800017 	ldw	r2,0(r2)
 3245a0c:	18800326 	beq	r3,r2,3245a1c <igmpv2_process_query+0x1cc>
            igmpv2_chk_set_timer (inm, max_resp_time);
 3245a10:	e17ffb8b 	ldhu	r5,-18(fp)
 3245a14:	e13ffa17 	ldw	r4,-24(fp)
 3245a18:	3245a9c0 	call	3245a9c <igmpv2_chk_set_timer>
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 3245a1c:	e0bffa17 	ldw	r2,-24(fp)
 3245a20:	10800517 	ldw	r2,20(r2)
 3245a24:	e0bffa15 	stw	r2,-24(fp)
 3245a28:	e0bffa17 	ldw	r2,-24(fp)
 3245a2c:	1004c03a 	cmpne	r2,r2,zero
 3245a30:	103fed1e 	bne	r2,zero,32459e8 <igmpv2_process_query+0x198>
 3245a34:	00001306 	br	3245a84 <igmpv2_process_query+0x234>
   {
      /* process one (for IGMPv2 Group-Specific Query) entry (the 
       * one that corresponds to the address listed in the received 
       * query) - it should be present in the link's multicast
       * address list */
      inm = lookup_mcast(igmp->igmp_group, netp);
 3245a38:	e0bffe17 	ldw	r2,-8(fp)
 3245a3c:	11000117 	ldw	r4,4(r2)
 3245a40:	e17ffc17 	ldw	r5,-16(fp)
 3245a44:	32436ec0 	call	32436ec <lookup_mcast>
 3245a48:	e0bffa15 	stw	r2,-24(fp)
      if (inm != NULL)
 3245a4c:	e0bffa17 	ldw	r2,-24(fp)
 3245a50:	1005003a 	cmpeq	r2,r2,zero
 3245a54:	1000041e 	bne	r2,zero,3245a68 <igmpv2_process_query+0x218>
         igmpv2_chk_set_timer (inm, max_resp_time);
 3245a58:	e17ffb8b 	ldhu	r5,-18(fp)
 3245a5c:	e13ffa17 	ldw	r4,-24(fp)
 3245a60:	3245a9c0 	call	3245a9c <igmpv2_chk_set_timer>
 3245a64:	00000706 	br	3245a84 <igmpv2_process_query+0x234>
      else ++igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd;
 3245a68:	0080c9b4 	movhi	r2,806
 3245a6c:	10b25e04 	addi	r2,r2,-13960
 3245a70:	10801217 	ldw	r2,72(r2)
 3245a74:	10c00044 	addi	r3,r2,1
 3245a78:	0080c9b4 	movhi	r2,806
 3245a7c:	10b25e04 	addi	r2,r2,-13960
 3245a80:	10c01215 	stw	r3,72(r2)
   } /* end ELSE (process ALL) */
   
   /* return success; caller will the received packet back to the 
    * free pool */
   return IGMP_OK;
 3245a84:	0005883a 	mov	r2,zero
}
 3245a88:	e037883a 	mov	sp,fp
 3245a8c:	dfc00117 	ldw	ra,4(sp)
 3245a90:	df000017 	ldw	fp,0(sp)
 3245a94:	dec00204 	addi	sp,sp,8
 3245a98:	f800283a 	ret

03245a9c <igmpv2_chk_set_timer>:
 *
 * OUTPUT: None.
 */

void igmpv2_chk_set_timer (struct in_multi * inm, u_short max_resp_time)
{  
 3245a9c:	defffc04 	addi	sp,sp,-16
 3245aa0:	dfc00315 	stw	ra,12(sp)
 3245aa4:	df000215 	stw	fp,8(sp)
 3245aa8:	df000204 	addi	fp,sp,8
 3245aac:	e13ffe15 	stw	r4,-8(fp)
 3245ab0:	e17fff0d 	sth	r5,-4(fp)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 3245ab4:	e0bffe17 	ldw	r2,-8(fp)
 3245ab8:	10c00317 	ldw	r3,12(r2)
 3245abc:	e0bfff0b 	ldhu	r2,-4(fp)
 3245ac0:	10c00436 	bltu	r2,r3,3245ad4 <igmpv2_chk_set_timer+0x38>
 3245ac4:	e0bffe17 	ldw	r2,-8(fp)
 3245ac8:	10800317 	ldw	r2,12(r2)
 3245acc:	1004c03a 	cmpne	r2,r2,zero
 3245ad0:	1000431e 	bne	r2,zero,3245be0 <igmpv2_chk_set_timer+0x144>
       (inm->inm_timer == 0))
   {
      if (inm->inm_timer == 0) ++igmp_timers_are_running;
 3245ad4:	e0bffe17 	ldw	r2,-8(fp)
 3245ad8:	10800317 	ldw	r2,12(r2)
 3245adc:	1004c03a 	cmpne	r2,r2,zero
 3245ae0:	1000071e 	bne	r2,zero,3245b00 <igmpv2_chk_set_timer+0x64>
 3245ae4:	0080c974 	movhi	r2,805
 3245ae8:	10923404 	addi	r2,r2,18640
 3245aec:	10800017 	ldw	r2,0(r2)
 3245af0:	10c00044 	addi	r3,r2,1
 3245af4:	0080c974 	movhi	r2,805
 3245af8:	10923404 	addi	r2,r2,18640
 3245afc:	10c00015 	stw	r3,0(r2)
      inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY (max_resp_time, inm->inm_addr);                     
 3245b00:	0080c9b4 	movhi	r2,806
 3245b04:	10b46004 	addi	r2,r2,-11904
 3245b08:	11000217 	ldw	r4,8(r2)
 3245b0c:	0080c9b4 	movhi	r2,806
 3245b10:	10b25a04 	addi	r2,r2,-13976
 3245b14:	10800017 	ldw	r2,0(r2)
 3245b18:	10800a17 	ldw	r2,40(r2)
 3245b1c:	1004d63a 	srli	r2,r2,24
 3245b20:	10c03fcc 	andi	r3,r2,255
 3245b24:	0080c9b4 	movhi	r2,806
 3245b28:	10b25a04 	addi	r2,r2,-13976
 3245b2c:	10800017 	ldw	r2,0(r2)
 3245b30:	10800a17 	ldw	r2,40(r2)
 3245b34:	1004d23a 	srli	r2,r2,8
 3245b38:	10bfc00c 	andi	r2,r2,65280
 3245b3c:	1886b03a 	or	r3,r3,r2
 3245b40:	0080c9b4 	movhi	r2,806
 3245b44:	10b25a04 	addi	r2,r2,-13976
 3245b48:	10800017 	ldw	r2,0(r2)
 3245b4c:	10800a17 	ldw	r2,40(r2)
 3245b50:	10bfc00c 	andi	r2,r2,65280
 3245b54:	1004923a 	slli	r2,r2,8
 3245b58:	1886b03a 	or	r3,r3,r2
 3245b5c:	0080c9b4 	movhi	r2,806
 3245b60:	10b25a04 	addi	r2,r2,-13976
 3245b64:	10800017 	ldw	r2,0(r2)
 3245b68:	10800a17 	ldw	r2,40(r2)
 3245b6c:	10803fcc 	andi	r2,r2,255
 3245b70:	1004963a 	slli	r2,r2,24
 3245b74:	1884b03a 	or	r2,r3,r2
 3245b78:	2089883a 	add	r4,r4,r2
 3245b7c:	e0bffe17 	ldw	r2,-8(fp)
 3245b80:	10800017 	ldw	r2,0(r2)
 3245b84:	1004d63a 	srli	r2,r2,24
 3245b88:	10c03fcc 	andi	r3,r2,255
 3245b8c:	e0bffe17 	ldw	r2,-8(fp)
 3245b90:	10800017 	ldw	r2,0(r2)
 3245b94:	1004d23a 	srli	r2,r2,8
 3245b98:	10bfc00c 	andi	r2,r2,65280
 3245b9c:	1886b03a 	or	r3,r3,r2
 3245ba0:	e0bffe17 	ldw	r2,-8(fp)
 3245ba4:	10800017 	ldw	r2,0(r2)
 3245ba8:	10bfc00c 	andi	r2,r2,65280
 3245bac:	1004923a 	slli	r2,r2,8
 3245bb0:	1886b03a 	or	r3,r3,r2
 3245bb4:	e0bffe17 	ldw	r2,-8(fp)
 3245bb8:	10800017 	ldw	r2,0(r2)
 3245bbc:	10803fcc 	andi	r2,r2,255
 3245bc0:	1004963a 	slli	r2,r2,24
 3245bc4:	1884b03a 	or	r2,r3,r2
 3245bc8:	2089883a 	add	r4,r4,r2
 3245bcc:	e17fff0b 	ldhu	r5,-4(fp)
 3245bd0:	32044c40 	call	32044c4 <__umodsi3>
 3245bd4:	10c00044 	addi	r3,r2,1
 3245bd8:	e0bffe17 	ldw	r2,-8(fp)
 3245bdc:	10c00315 	stw	r3,12(r2)
   }

   return;
}
 3245be0:	e037883a 	mov	sp,fp
 3245be4:	dfc00117 	ldw	ra,4(sp)
 3245be8:	df000017 	ldw	fp,0(sp)
 3245bec:	dec00204 	addi	sp,sp,8
 3245bf0:	f800283a 	ret

03245bf4 <igmpv2_chk4_rtr_alert_opt>:
 *         the IP Router Alert option in the received
 *         packet, and IGMP_FALSE otherwise.
 */

u_char igmpv2_chk4_rtr_alert_opt (struct ip * pip)
{
 3245bf4:	defff904 	addi	sp,sp,-28
 3245bf8:	df000615 	stw	fp,24(sp)
 3245bfc:	df000604 	addi	fp,sp,24
 3245c00:	e13ffd15 	stw	r4,-12(fp)
   u_long * rtr_alert_optp;
   u_char total_optlen;
   u_char optlen;
   u_char optval;

   total_optlen = ip_hlen (pip) - sizeof (struct ip);
 3245c04:	e0bffd17 	ldw	r2,-12(fp)
 3245c08:	10800003 	ldbu	r2,0(r2)
 3245c0c:	108003cc 	andi	r2,r2,15
 3245c10:	1085883a 	add	r2,r2,r2
 3245c14:	1085883a 	add	r2,r2,r2
 3245c18:	10bffb04 	addi	r2,r2,-20
 3245c1c:	e0bffa85 	stb	r2,-22(fp)

   if (total_optlen > 0)
 3245c20:	e0bffa83 	ldbu	r2,-22(fp)
 3245c24:	1005003a 	cmpeq	r2,r2,zero
 3245c28:	1000481e 	bne	r2,zero,3245d4c <igmpv2_chk4_rtr_alert_opt+0x158>
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
 3245c2c:	e0bffd17 	ldw	r2,-12(fp)
 3245c30:	10800504 	addi	r2,r2,20
 3245c34:	e0bffc15 	stw	r2,-16(fp)
  
      while (total_optlen > 0)
 3245c38:	00004106 	br	3245d40 <igmpv2_chk4_rtr_alert_opt+0x14c>
      {
         /* only the lowermost 5 bits are significant */    
         optval = (*optp) & IPOPT_TYPE_MASK;
 3245c3c:	e0bffc17 	ldw	r2,-16(fp)
 3245c40:	10800003 	ldbu	r2,0(r2)
 3245c44:	108007cc 	andi	r2,r2,31
 3245c48:	e0bffa05 	stb	r2,-24(fp)
         switch (optval)
 3245c4c:	e0bffa03 	ldbu	r2,-24(fp)
 3245c50:	e0bfff15 	stw	r2,-4(fp)
 3245c54:	e0ffff17 	ldw	r3,-4(fp)
 3245c58:	18800060 	cmpeqi	r2,r3,1
 3245c5c:	10000b1e 	bne	r2,zero,3245c8c <igmpv2_chk4_rtr_alert_opt+0x98>
 3245c60:	e0ffff17 	ldw	r3,-4(fp)
 3245c64:	18800520 	cmpeqi	r2,r3,20
 3245c68:	10000b1e 	bne	r2,zero,3245c98 <igmpv2_chk4_rtr_alert_opt+0xa4>
 3245c6c:	e0ffff17 	ldw	r3,-4(fp)
 3245c70:	1805003a 	cmpeq	r2,r3,zero
 3245c74:	1000011e 	bne	r2,zero,3245c7c <igmpv2_chk4_rtr_alert_opt+0x88>
 3245c78:	00002306 	br	3245d08 <igmpv2_chk4_rtr_alert_opt+0x114>
         {
            case EOL_OPT:
               /* we've encountered the End of Option List option, 
                * and so setting optlen isn't necessary */
               optlen = 1;
 3245c7c:	00800044 	movi	r2,1
 3245c80:	e0bffa45 	stb	r2,-23(fp)
               /* we're done - we couldn't locate the IP Router Alert 
                * option in this IP header */
               return IGMP_FALSE;
 3245c84:	e03ffe15 	stw	zero,-8(fp)
 3245c88:	00003106 	br	3245d50 <igmpv2_chk4_rtr_alert_opt+0x15c>
         
            case NOOP_OPT:
               /* skip past the one byte of the No Operation option */
               optlen = 1;
 3245c8c:	00800044 	movi	r2,1
 3245c90:	e0bffa45 	stb	r2,-23(fp)
               break;
 3245c94:	00002106 	br	3245d1c <igmpv2_chk4_rtr_alert_opt+0x128>
         
            case IP_RTR_ALERT_OPT:
               rtr_alert_optp = (u_long *) optp; 
 3245c98:	e0bffc17 	ldw	r2,-16(fp)
 3245c9c:	e0bffb15 	stw	r2,-20(fp)
               if ((ntohl (*rtr_alert_optp)) == IP_RTR_ALERT_OPT_DATA)
 3245ca0:	e0bffb17 	ldw	r2,-20(fp)
 3245ca4:	10800017 	ldw	r2,0(r2)
 3245ca8:	1004d63a 	srli	r2,r2,24
 3245cac:	10c03fcc 	andi	r3,r2,255
 3245cb0:	e0bffb17 	ldw	r2,-20(fp)
 3245cb4:	10800017 	ldw	r2,0(r2)
 3245cb8:	1004d23a 	srli	r2,r2,8
 3245cbc:	10bfc00c 	andi	r2,r2,65280
 3245cc0:	1886b03a 	or	r3,r3,r2
 3245cc4:	e0bffb17 	ldw	r2,-20(fp)
 3245cc8:	10800017 	ldw	r2,0(r2)
 3245ccc:	10bfc00c 	andi	r2,r2,65280
 3245cd0:	1004923a 	slli	r2,r2,8
 3245cd4:	1886b03a 	or	r3,r3,r2
 3245cd8:	e0bffb17 	ldw	r2,-20(fp)
 3245cdc:	10800017 	ldw	r2,0(r2)
 3245ce0:	10803fcc 	andi	r2,r2,255
 3245ce4:	1004963a 	slli	r2,r2,24
 3245ce8:	1886b03a 	or	r3,r3,r2
 3245cec:	00a50134 	movhi	r2,37892
 3245cf0:	1880031e 	bne	r3,r2,3245d00 <igmpv2_chk4_rtr_alert_opt+0x10c>
                  /* found the option, return success */
                  return IGMP_TRUE;
 3245cf4:	00800044 	movi	r2,1
 3245cf8:	e0bffe15 	stw	r2,-8(fp)
 3245cfc:	00001406 	br	3245d50 <igmpv2_chk4_rtr_alert_opt+0x15c>
               else return IGMP_FALSE;
 3245d00:	e03ffe15 	stw	zero,-8(fp)
 3245d04:	00001206 	br	3245d50 <igmpv2_chk4_rtr_alert_opt+0x15c>
          
            default:
               /* extract the length of the current option, and compute
                * the total length of this option */
               optlen = (*(optp + 1)) + 2;
 3245d08:	e0bffc17 	ldw	r2,-16(fp)
 3245d0c:	10800044 	addi	r2,r2,1
 3245d10:	10800003 	ldbu	r2,0(r2)
 3245d14:	10800084 	addi	r2,r2,2
 3245d18:	e0bffa45 	stb	r2,-23(fp)
               break;
         }
         
         /* skip past the bytes associated with the current option to 
          * point to the next option. */
         optp += optlen;
 3245d1c:	e0bffa43 	ldbu	r2,-23(fp)
 3245d20:	1007883a 	mov	r3,r2
 3245d24:	e0bffc17 	ldw	r2,-16(fp)
 3245d28:	10c5883a 	add	r2,r2,r3
 3245d2c:	e0bffc15 	stw	r2,-16(fp)
         total_optlen -= optlen;
 3245d30:	e0fffa83 	ldbu	r3,-22(fp)
 3245d34:	e0bffa43 	ldbu	r2,-23(fp)
 3245d38:	1885c83a 	sub	r2,r3,r2
 3245d3c:	e0bffa85 	stb	r2,-22(fp)
   if (total_optlen > 0)
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
  
      while (total_optlen > 0)
 3245d40:	e0bffa83 	ldbu	r2,-22(fp)
 3245d44:	1004c03a 	cmpne	r2,r2,zero
 3245d48:	103fbc1e 	bne	r2,zero,3245c3c <igmpv2_chk4_rtr_alert_opt+0x48>
         total_optlen -= optlen;
      } /* end WHILE */
   }

   /* didn't find IP Alert option in IP header of rcvd packet */
   return IGMP_FALSE;
 3245d4c:	e03ffe15 	stw	zero,-8(fp)
 3245d50:	e0bffe17 	ldw	r2,-8(fp)
}
 3245d54:	e037883a 	mov	sp,fp
 3245d58:	df000017 	ldw	fp,0(sp)
 3245d5c:	dec00104 	addi	sp,sp,4
 3245d60:	f800283a 	ret

03245d64 <IPADDR_TO_NETP>:
 * RETURNS: 
 */

void
IPADDR_TO_NETP(ip_addr addr, NET* netp)
{
 3245d64:	defffc04 	addi	sp,sp,-16
 3245d68:	df000315 	stw	fp,12(sp)
 3245d6c:	df000304 	addi	fp,sp,12
 3245d70:	e13ffe15 	stw	r4,-8(fp)
 3245d74:	e17fff15 	stw	r5,-4(fp)
   u_short  idx   =  0;
 3245d78:	e03ffd0d 	sth	zero,-12(fp)
   *netp = nets[idx];
 3245d7c:	e0bffd0b 	ldhu	r2,-12(fp)
 3245d80:	00c0c9b4 	movhi	r3,806
 3245d84:	18f25a04 	addi	r3,r3,-13976
 3245d88:	1085883a 	add	r2,r2,r2
 3245d8c:	1085883a 	add	r2,r2,r2
 3245d90:	10c5883a 	add	r2,r2,r3
 3245d94:	10c00017 	ldw	r3,0(r2)
 3245d98:	e0bfff17 	ldw	r2,-4(fp)
 3245d9c:	10c00015 	stw	r3,0(r2)
/*
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
 3245da0:	e0bffe17 	ldw	r2,-8(fp)
 3245da4:	1004c03a 	cmpne	r2,r2,zero
 3245da8:	1000331e 	bne	r2,zero,3245e78 <IPADDR_TO_NETP+0x114>
   {
      for (idx = 0; idx < ifNumber; idx++)
 3245dac:	e03ffd0d 	sth	zero,-12(fp)
 3245db0:	00001706 	br	3245e10 <IPADDR_TO_NETP+0xac>
      {
         if (nets[idx]->n_mcastlist)
 3245db4:	e0bffd0b 	ldhu	r2,-12(fp)
 3245db8:	00c0c9b4 	movhi	r3,806
 3245dbc:	18f25a04 	addi	r3,r3,-13976
 3245dc0:	1085883a 	add	r2,r2,r2
 3245dc4:	1085883a 	add	r2,r2,r2
 3245dc8:	10c5883a 	add	r2,r2,r3
 3245dcc:	10800017 	ldw	r2,0(r2)
 3245dd0:	10802b17 	ldw	r2,172(r2)
 3245dd4:	1005003a 	cmpeq	r2,r2,zero
 3245dd8:	10000a1e 	bne	r2,zero,3245e04 <IPADDR_TO_NETP+0xa0>
         {
            *netp = nets[idx];
 3245ddc:	e0bffd0b 	ldhu	r2,-12(fp)
 3245de0:	00c0c9b4 	movhi	r3,806
 3245de4:	18f25a04 	addi	r3,r3,-13976
 3245de8:	1085883a 	add	r2,r2,r2
 3245dec:	1085883a 	add	r2,r2,r2
 3245df0:	10c5883a 	add	r2,r2,r3
 3245df4:	10c00017 	ldw	r3,0(r2)
 3245df8:	e0bfff17 	ldw	r2,-4(fp)
 3245dfc:	10c00015 	stw	r3,0(r2)
            break;
 3245e00:	00002606 	br	3245e9c <IPADDR_TO_NETP+0x138>
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
   {
      for (idx = 0; idx < ifNumber; idx++)
 3245e04:	e0bffd0b 	ldhu	r2,-12(fp)
 3245e08:	10800044 	addi	r2,r2,1
 3245e0c:	e0bffd0d 	sth	r2,-12(fp)
 3245e10:	e0bffd0b 	ldhu	r2,-12(fp)
 3245e14:	00c0c974 	movhi	r3,805
 3245e18:	18d23204 	addi	r3,r3,18632
 3245e1c:	18c00017 	ldw	r3,0(r3)
 3245e20:	10ffe436 	bltu	r2,r3,3245db4 <IPADDR_TO_NETP+0x50>
 3245e24:	00001d06 	br	3245e9c <IPADDR_TO_NETP+0x138>
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
      {
         idx++;
 3245e28:	e0bffd0b 	ldhu	r2,-12(fp)
 3245e2c:	10800044 	addi	r2,r2,1
 3245e30:	e0bffd0d 	sth	r2,-12(fp)
         if (idx >= ifNumber)
 3245e34:	e0fffd0b 	ldhu	r3,-12(fp)
 3245e38:	0080c974 	movhi	r2,805
 3245e3c:	10923204 	addi	r2,r2,18632
 3245e40:	10800017 	ldw	r2,0(r2)
 3245e44:	18800336 	bltu	r3,r2,3245e54 <IPADDR_TO_NETP+0xf0>
         {
            *netp = NULL;
 3245e48:	e0bfff17 	ldw	r2,-4(fp)
 3245e4c:	10000015 	stw	zero,0(r2)
            break;
 3245e50:	00001206 	br	3245e9c <IPADDR_TO_NETP+0x138>
         }
         else
            *netp = nets[idx];
 3245e54:	e0bffd0b 	ldhu	r2,-12(fp)
 3245e58:	00c0c9b4 	movhi	r3,806
 3245e5c:	18f25a04 	addi	r3,r3,-13976
 3245e60:	1085883a 	add	r2,r2,r2
 3245e64:	1085883a 	add	r2,r2,r2
 3245e68:	10c5883a 	add	r2,r2,r3
 3245e6c:	10c00017 	ldw	r3,0(r2)
 3245e70:	e0bfff17 	ldw	r2,-4(fp)
 3245e74:	10c00015 	stw	r3,0(r2)
         }
      }
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
 3245e78:	e0bfff17 	ldw	r2,-4(fp)
 3245e7c:	10800017 	ldw	r2,0(r2)
 3245e80:	1005003a 	cmpeq	r2,r2,zero
 3245e84:	1000051e 	bne	r2,zero,3245e9c <IPADDR_TO_NETP+0x138>
 3245e88:	e0bfff17 	ldw	r2,-4(fp)
 3245e8c:	10800017 	ldw	r2,0(r2)
 3245e90:	10c00a17 	ldw	r3,40(r2)
 3245e94:	e0bffe17 	ldw	r2,-8(fp)
 3245e98:	18bfe31e 	bne	r3,r2,3245e28 <IPADDR_TO_NETP+0xc4>
         }
         else
            *netp = nets[idx];
      }
   }
}
 3245e9c:	e037883a 	mov	sp,fp
 3245ea0:	df000017 	ldw	fp,0(sp)
 3245ea4:	dec00104 	addi	sp,sp,4
 3245ea8:	f800283a 	ret

03245eac <ip_setmoptions>:
 * RETURNS: 
 */

int
ip_setmoptions(int optname, struct socket * so, void * val)
{
 3245eac:	defff104 	addi	sp,sp,-60
 3245eb0:	dfc00e15 	stw	ra,56(sp)
 3245eb4:	df000d15 	stw	fp,52(sp)
 3245eb8:	dc000c15 	stw	r16,48(sp)
 3245ebc:	df000c04 	addi	fp,sp,48
 3245ec0:	e13ffb15 	stw	r4,-20(fp)
 3245ec4:	e17ffc15 	stw	r5,-16(fp)
 3245ec8:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 3245ecc:	e03ff915 	stw	zero,-28(fp)
   u_short  i;
   struct ip_mreq *  mreq;
   struct net *   netp  =  NULL;
 3245ed0:	e03ffa15 	stw	zero,-24(fp)
   struct ip_moptions * imo   =  so->inp_moptions;
 3245ed4:	e0bffc17 	ldw	r2,-16(fp)
 3245ed8:	10800317 	ldw	r2,12(r2)
 3245edc:	e0bff615 	stw	r2,-40(fp)
   struct ip_moptions **imop  =  &so->inp_moptions;
 3245ee0:	e0bffc17 	ldw	r2,-16(fp)
 3245ee4:	10800304 	addi	r2,r2,12
 3245ee8:	e0bff515 	stw	r2,-44(fp)
   ip_addr addr;


   if (imo == NULL) 
 3245eec:	e0bff617 	ldw	r2,-40(fp)
 3245ef0:	1004c03a 	cmpne	r2,r2,zero
 3245ef4:	1000161e 	bne	r2,zero,3245f50 <ip_setmoptions+0xa4>
   {
   /*
    * No multicast option buffer attached to the pcb;
    * allocate one and initialize to default values.
    */
      imo = (struct ip_moptions*)IM_ALLOC(sizeof(*imo));
 3245ef8:	01001604 	movi	r4,88
 3245efc:	322b5d00 	call	322b5d0 <npalloc>
 3245f00:	e0bff615 	stw	r2,-40(fp)

      if (imo == NULL)
 3245f04:	e0bff617 	ldw	r2,-40(fp)
 3245f08:	1004c03a 	cmpne	r2,r2,zero
 3245f0c:	1000031e 	bne	r2,zero,3245f1c <ip_setmoptions+0x70>
         return (ENOBUFS);
 3245f10:	00801a44 	movi	r2,105
 3245f14:	e0bffe15 	stw	r2,-8(fp)
 3245f18:	00015906 	br	3246480 <ip_setmoptions+0x5d4>
      *imop = imo;
 3245f1c:	e0fff517 	ldw	r3,-44(fp)
 3245f20:	e0bff617 	ldw	r2,-40(fp)
 3245f24:	18800015 	stw	r2,0(r3)
      imo->imo_multicast_netp = NULL;
 3245f28:	e0bff617 	ldw	r2,-40(fp)
 3245f2c:	10000015 	stw	zero,0(r2)
      imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
 3245f30:	e0fff617 	ldw	r3,-40(fp)
 3245f34:	00800044 	movi	r2,1
 3245f38:	18800105 	stb	r2,4(r3)
      imo->imo_multicast_loop = IP_DEFAULT_MULTICAST_LOOP;
 3245f3c:	e0fff617 	ldw	r3,-40(fp)
 3245f40:	00800044 	movi	r2,1
 3245f44:	18800145 	stb	r2,5(r3)
      imo->imo_num_memberships = 0;
 3245f48:	e0bff617 	ldw	r2,-40(fp)
 3245f4c:	1000018d 	sth	zero,6(r2)
   }

   switch (optname) 
 3245f50:	e0bffb17 	ldw	r2,-20(fp)
 3245f54:	10bffdc4 	addi	r2,r2,-9
 3245f58:	e0bfff15 	stw	r2,-4(fp)
 3245f5c:	e0ffff17 	ldw	r3,-4(fp)
 3245f60:	18800168 	cmpgeui	r2,r3,5
 3245f64:	10012a1e 	bne	r2,zero,3246410 <ip_setmoptions+0x564>
 3245f68:	e13fff17 	ldw	r4,-4(fp)
 3245f6c:	e13fff17 	ldw	r4,-4(fp)
 3245f70:	2105883a 	add	r2,r4,r4
 3245f74:	1087883a 	add	r3,r2,r2
 3245f78:	0080c934 	movhi	r2,804
 3245f7c:	1097e304 	addi	r2,r2,24460
 3245f80:	1885883a 	add	r2,r3,r2
 3245f84:	10800017 	ldw	r2,0(r2)
 3245f88:	1000683a 	jmp	r2
 3245f8c:	03245fa0 	cmpeqi	r12,zero,-28290
 3245f90:	03246014 	movui	r12,37248
 3245f94:	03246028 	cmpgeui	r12,zero,37248
 3245f98:	0324605c 	xori	r12,zero,37249
 3245f9c:	0324622c 	andhi	r12,zero,37256

   case IP_MULTICAST_IF:
      /*
       * Select the interface for outgoing multicast packets.
       */
      addr = *(ip_addr *)val;
 3245fa0:	e0bffd17 	ldw	r2,-12(fp)
 3245fa4:	10800017 	ldw	r2,0(r2)
 3245fa8:	e0bff415 	stw	r2,-48(fp)
         /*
          * AADDR is used to remove a previous selection.
          * When no interface is selected, a default one is
          * chosen every time a multicast packet is sent.
          */
      if (addr == AADDR) 
 3245fac:	e0bff417 	ldw	r2,-48(fp)
 3245fb0:	1004c03a 	cmpne	r2,r2,zero
 3245fb4:	1000031e 	bne	r2,zero,3245fc4 <ip_setmoptions+0x118>
      {
         imo->imo_multicast_netp = NULL;
 3245fb8:	e0bff617 	ldw	r2,-40(fp)
 3245fbc:	10000015 	stw	zero,0(r2)
         break;
 3245fc0:	00011506 	br	3246418 <ip_setmoptions+0x56c>
         /*
          * The selected interface is identified by its local
          * IP address.  Find the interface and confirm that
          * it supports multicasting.
          */
      IPADDR_TO_NETP(addr, &netp);
 3245fc4:	e17ffa04 	addi	r5,fp,-24
 3245fc8:	e13ff417 	ldw	r4,-48(fp)
 3245fcc:	3245d640 	call	3245d64 <IPADDR_TO_NETP>
      if ((netp == NULL) || (netp->n_mcastlist) == NULL) 
 3245fd0:	e0bffa17 	ldw	r2,-24(fp)
 3245fd4:	1005003a 	cmpeq	r2,r2,zero
 3245fd8:	1000041e 	bne	r2,zero,3245fec <ip_setmoptions+0x140>
 3245fdc:	e0bffa17 	ldw	r2,-24(fp)
 3245fe0:	10802b17 	ldw	r2,172(r2)
 3245fe4:	1004c03a 	cmpne	r2,r2,zero
 3245fe8:	1000031e 	bne	r2,zero,3245ff8 <ip_setmoptions+0x14c>
      {
         error = EADDRNOTAVAIL;
 3245fec:	00801f44 	movi	r2,125
 3245ff0:	e0bff915 	stw	r2,-28(fp)
         break;
 3245ff4:	00010806 	br	3246418 <ip_setmoptions+0x56c>
      }
      if (addr != AADDR) 
 3245ff8:	e0bff417 	ldw	r2,-48(fp)
 3245ffc:	1005003a 	cmpeq	r2,r2,zero
 3246000:	1001051e 	bne	r2,zero,3246418 <ip_setmoptions+0x56c>
         imo->imo_multicast_netp = netp;
 3246004:	e0fffa17 	ldw	r3,-24(fp)
 3246008:	e0bff617 	ldw	r2,-40(fp)
 324600c:	10c00015 	stw	r3,0(r2)
      break;
 3246010:	00010106 	br	3246418 <ip_setmoptions+0x56c>

   case IP_MULTICAST_TTL:
      /*
       * Set the IP time-to-live for outgoing multicast packets.
       */
      imo->imo_multicast_ttl = *(u_char *)val;
 3246014:	e0bffd17 	ldw	r2,-12(fp)
 3246018:	10c00003 	ldbu	r3,0(r2)
 324601c:	e0bff617 	ldw	r2,-40(fp)
 3246020:	10c00105 	stb	r3,4(r2)
      break;
 3246024:	0000fc06 	br	3246418 <ip_setmoptions+0x56c>
   case IP_MULTICAST_LOOP:
      /*
       * Set the loopback flag for outgoing multicast packets.
       * Must be zero or one.
       */
      if (*(u_char *)val > 1) 
 3246028:	e0bffd17 	ldw	r2,-12(fp)
 324602c:	10800003 	ldbu	r2,0(r2)
 3246030:	10803fcc 	andi	r2,r2,255
 3246034:	108000b0 	cmpltui	r2,r2,2
 3246038:	1000031e 	bne	r2,zero,3246048 <ip_setmoptions+0x19c>
      {
         error = EINVAL;
 324603c:	00800584 	movi	r2,22
 3246040:	e0bff915 	stw	r2,-28(fp)
         break;
 3246044:	0000f406 	br	3246418 <ip_setmoptions+0x56c>
      }
      imo->imo_multicast_loop = *(u_char *)(val);
 3246048:	e0bffd17 	ldw	r2,-12(fp)
 324604c:	10c00003 	ldbu	r3,0(r2)
 3246050:	e0bff617 	ldw	r2,-40(fp)
 3246054:	10c00145 	stb	r3,5(r2)
      break;
 3246058:	0000ef06 	br	3246418 <ip_setmoptions+0x56c>
   case IP_ADD_MEMBERSHIP:
      /*
       * Add a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 324605c:	e0bffd17 	ldw	r2,-12(fp)
 3246060:	e0bff715 	stw	r2,-36(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 3246064:	e0bff717 	ldw	r2,-36(fp)
 3246068:	10800017 	ldw	r2,0(r2)
 324606c:	1004d63a 	srli	r2,r2,24
 3246070:	10c03fcc 	andi	r3,r2,255
 3246074:	e0bff717 	ldw	r2,-36(fp)
 3246078:	10800017 	ldw	r2,0(r2)
 324607c:	1004d23a 	srli	r2,r2,8
 3246080:	10bfc00c 	andi	r2,r2,65280
 3246084:	1886b03a 	or	r3,r3,r2
 3246088:	e0bff717 	ldw	r2,-36(fp)
 324608c:	10800017 	ldw	r2,0(r2)
 3246090:	10bfc00c 	andi	r2,r2,65280
 3246094:	1004923a 	slli	r2,r2,8
 3246098:	1886b03a 	or	r3,r3,r2
 324609c:	e0bff717 	ldw	r2,-36(fp)
 32460a0:	10800017 	ldw	r2,0(r2)
 32460a4:	10803fcc 	andi	r2,r2,255
 32460a8:	1004963a 	slli	r2,r2,24
 32460ac:	1884b03a 	or	r2,r3,r2
 32460b0:	10fc002c 	andhi	r3,r2,61440
 32460b4:	00b80034 	movhi	r2,57344
 32460b8:	18800326 	beq	r3,r2,32460c8 <ip_setmoptions+0x21c>
      {
         error = EINVAL;
 32460bc:	00800584 	movi	r2,22
 32460c0:	e0bff915 	stw	r2,-28(fp)
         break;
 32460c4:	0000d406 	br	3246418 <ip_setmoptions+0x56c>
       * If no interface address was provided, use the interface of
       * the route to the given multicast address.
       * For the Iniche stack implementation, look for a default
       * interface that supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 32460c8:	e0bff717 	ldw	r2,-36(fp)
 32460cc:	11000117 	ldw	r4,4(r2)
 32460d0:	e17ffa04 	addi	r5,fp,-24
 32460d4:	3245d640 	call	3245d64 <IPADDR_TO_NETP>
      /*
       * See if we found an interface, and confirm that it
       * supports multicast.
       */
      if (netp == NULL || (netp->n_mcastlist) == NULL) 
 32460d8:	e0bffa17 	ldw	r2,-24(fp)
 32460dc:	1005003a 	cmpeq	r2,r2,zero
 32460e0:	1000041e 	bne	r2,zero,32460f4 <ip_setmoptions+0x248>
 32460e4:	e0bffa17 	ldw	r2,-24(fp)
 32460e8:	10802b17 	ldw	r2,172(r2)
 32460ec:	1004c03a 	cmpne	r2,r2,zero
 32460f0:	1000031e 	bne	r2,zero,3246100 <ip_setmoptions+0x254>
      {
         error = EADDRNOTAVAIL;
 32460f4:	00801f44 	movi	r2,125
 32460f8:	e0bff915 	stw	r2,-28(fp)
         break;
 32460fc:	0000c606 	br	3246418 <ip_setmoptions+0x56c>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 3246100:	e03ff80d 	sth	zero,-32(fp)
 3246104:	00001806 	br	3246168 <ip_setmoptions+0x2bc>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 3246108:	e0bff80b 	ldhu	r2,-32(fp)
 324610c:	e0fff617 	ldw	r3,-40(fp)
 3246110:	1085883a 	add	r2,r2,r2
 3246114:	1085883a 	add	r2,r2,r2
 3246118:	10c5883a 	add	r2,r2,r3
 324611c:	10800204 	addi	r2,r2,8
 3246120:	10800017 	ldw	r2,0(r2)
 3246124:	10c00117 	ldw	r3,4(r2)
 3246128:	e0bffa17 	ldw	r2,-24(fp)
 324612c:	18800b1e 	bne	r3,r2,324615c <ip_setmoptions+0x2b0>
 3246130:	e0bff80b 	ldhu	r2,-32(fp)
 3246134:	e0fff617 	ldw	r3,-40(fp)
 3246138:	1085883a 	add	r2,r2,r2
 324613c:	1085883a 	add	r2,r2,r2
 3246140:	10c5883a 	add	r2,r2,r3
 3246144:	10800204 	addi	r2,r2,8
 3246148:	10800017 	ldw	r2,0(r2)
 324614c:	10c00017 	ldw	r3,0(r2)
 3246150:	e0bff717 	ldw	r2,-36(fp)
 3246154:	10800017 	ldw	r2,0(r2)
 3246158:	18800826 	beq	r3,r2,324617c <ip_setmoptions+0x2d0>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 324615c:	e0bff80b 	ldhu	r2,-32(fp)
 3246160:	10800044 	addi	r2,r2,1
 3246164:	e0bff80d 	sth	r2,-32(fp)
 3246168:	e0bff617 	ldw	r2,-40(fp)
 324616c:	1080018b 	ldhu	r2,6(r2)
 3246170:	10ffffcc 	andi	r3,r2,65535
 3246174:	e0bff80b 	ldhu	r2,-32(fp)
 3246178:	10ffe336 	bltu	r2,r3,3246108 <ip_setmoptions+0x25c>
             == mreq->imr_multiaddr)
         {
            break;
         }
      }
      if (i < imo->imo_num_memberships) 
 324617c:	e0bff617 	ldw	r2,-40(fp)
 3246180:	1080018b 	ldhu	r2,6(r2)
 3246184:	10ffffcc 	andi	r3,r2,65535
 3246188:	e0bff80b 	ldhu	r2,-32(fp)
 324618c:	10c0032e 	bgeu	r2,r3,324619c <ip_setmoptions+0x2f0>
      {
         error = EADDRINUSE;
 3246190:	00801c04 	movi	r2,112
 3246194:	e0bff915 	stw	r2,-28(fp)
         break;
 3246198:	00009f06 	br	3246418 <ip_setmoptions+0x56c>
      }
      if (i == IP_MAX_MEMBERSHIPS) 
 324619c:	e0bff80b 	ldhu	r2,-32(fp)
 32461a0:	10800518 	cmpnei	r2,r2,20
 32461a4:	1000031e 	bne	r2,zero,32461b4 <ip_setmoptions+0x308>
      {
         error = ETOOMANYREFS;
 32461a8:	00802044 	movi	r2,129
 32461ac:	e0bff915 	stw	r2,-28(fp)
         break;
 32461b0:	00009906 	br	3246418 <ip_setmoptions+0x56c>
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 32461b4:	e43ff80b 	ldhu	r16,-32(fp)
 32461b8:	e13ff717 	ldw	r4,-36(fp)
 32461bc:	e17ffa17 	ldw	r5,-24(fp)
 32461c0:	01800104 	movi	r6,4
 32461c4:	324346c0 	call	324346c <in_addmulti>
 32461c8:	1009883a 	mov	r4,r2
 32461cc:	e0fff617 	ldw	r3,-40(fp)
 32461d0:	8405883a 	add	r2,r16,r16
 32461d4:	1085883a 	add	r2,r2,r2
 32461d8:	10c5883a 	add	r2,r2,r3
 32461dc:	10800204 	addi	r2,r2,8
 32461e0:	11000015 	stw	r4,0(r2)
 32461e4:	e0fff617 	ldw	r3,-40(fp)
 32461e8:	8405883a 	add	r2,r16,r16
 32461ec:	1085883a 	add	r2,r2,r2
 32461f0:	10c5883a 	add	r2,r2,r3
 32461f4:	10800204 	addi	r2,r2,8
 32461f8:	10800017 	ldw	r2,0(r2)
 32461fc:	1004c03a 	cmpne	r2,r2,zero
 3246200:	1000031e 	bne	r2,zero,3246210 <ip_setmoptions+0x364>
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
      {
         error = ENOBUFS;
 3246204:	00801a44 	movi	r2,105
 3246208:	e0bff915 	stw	r2,-28(fp)
         break;
 324620c:	00008206 	br	3246418 <ip_setmoptions+0x56c>
      }
      ++imo->imo_num_memberships;
 3246210:	e0bff617 	ldw	r2,-40(fp)
 3246214:	1080018b 	ldhu	r2,6(r2)
 3246218:	10800044 	addi	r2,r2,1
 324621c:	1007883a 	mov	r3,r2
 3246220:	e0bff617 	ldw	r2,-40(fp)
 3246224:	10c0018d 	sth	r3,6(r2)
      break;
 3246228:	00007b06 	br	3246418 <ip_setmoptions+0x56c>
   case IP_DROP_MEMBERSHIP:
      /*
       * Drop a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 324622c:	e0bffd17 	ldw	r2,-12(fp)
 3246230:	e0bff715 	stw	r2,-36(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 3246234:	e0bff717 	ldw	r2,-36(fp)
 3246238:	10800017 	ldw	r2,0(r2)
 324623c:	1004d63a 	srli	r2,r2,24
 3246240:	10c03fcc 	andi	r3,r2,255
 3246244:	e0bff717 	ldw	r2,-36(fp)
 3246248:	10800017 	ldw	r2,0(r2)
 324624c:	1004d23a 	srli	r2,r2,8
 3246250:	10bfc00c 	andi	r2,r2,65280
 3246254:	1886b03a 	or	r3,r3,r2
 3246258:	e0bff717 	ldw	r2,-36(fp)
 324625c:	10800017 	ldw	r2,0(r2)
 3246260:	10bfc00c 	andi	r2,r2,65280
 3246264:	1004923a 	slli	r2,r2,8
 3246268:	1886b03a 	or	r3,r3,r2
 324626c:	e0bff717 	ldw	r2,-36(fp)
 3246270:	10800017 	ldw	r2,0(r2)
 3246274:	10803fcc 	andi	r2,r2,255
 3246278:	1004963a 	slli	r2,r2,24
 324627c:	1884b03a 	or	r2,r3,r2
 3246280:	10fc002c 	andhi	r3,r2,61440
 3246284:	00b80034 	movhi	r2,57344
 3246288:	18800326 	beq	r3,r2,3246298 <ip_setmoptions+0x3ec>
      {
         error = EINVAL;
 324628c:	00800584 	movi	r2,22
 3246290:	e0bff915 	stw	r2,-28(fp)
         break;
 3246294:	00006006 	br	3246418 <ip_setmoptions+0x56c>
       * If an interface address was specified, get a pointer
       * to its ifnet structure. If an interface address was not
       * specified, get a pointer to the first interface that
       * supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 3246298:	e0bff717 	ldw	r2,-36(fp)
 324629c:	11000117 	ldw	r4,4(r2)
 32462a0:	e17ffa04 	addi	r5,fp,-24
 32462a4:	3245d640 	call	3245d64 <IPADDR_TO_NETP>
      if (netp == NULL) 
 32462a8:	e0bffa17 	ldw	r2,-24(fp)
 32462ac:	1004c03a 	cmpne	r2,r2,zero
 32462b0:	1000031e 	bne	r2,zero,32462c0 <ip_setmoptions+0x414>
      {
         error = EADDRNOTAVAIL;
 32462b4:	00801f44 	movi	r2,125
 32462b8:	e0bff915 	stw	r2,-28(fp)
         break;
 32462bc:	00005606 	br	3246418 <ip_setmoptions+0x56c>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 32462c0:	e03ff80d 	sth	zero,-32(fp)
 32462c4:	00001b06 	br	3246334 <ip_setmoptions+0x488>
      {
         if ((netp == NULL ||
 32462c8:	e0bffa17 	ldw	r2,-24(fp)
 32462cc:	1005003a 	cmpeq	r2,r2,zero
 32462d0:	10000a1e 	bne	r2,zero,32462fc <ip_setmoptions+0x450>
 32462d4:	e0bff80b 	ldhu	r2,-32(fp)
 32462d8:	e0fff617 	ldw	r3,-40(fp)
 32462dc:	1085883a 	add	r2,r2,r2
 32462e0:	1085883a 	add	r2,r2,r2
 32462e4:	10c5883a 	add	r2,r2,r3
 32462e8:	10800204 	addi	r2,r2,8
 32462ec:	10800017 	ldw	r2,0(r2)
 32462f0:	10c00117 	ldw	r3,4(r2)
 32462f4:	e0bffa17 	ldw	r2,-24(fp)
 32462f8:	18800b1e 	bne	r3,r2,3246328 <ip_setmoptions+0x47c>
 32462fc:	e0bff80b 	ldhu	r2,-32(fp)
 3246300:	e0fff617 	ldw	r3,-40(fp)
 3246304:	1085883a 	add	r2,r2,r2
 3246308:	1085883a 	add	r2,r2,r2
 324630c:	10c5883a 	add	r2,r2,r3
 3246310:	10800204 	addi	r2,r2,8
 3246314:	10800017 	ldw	r2,0(r2)
 3246318:	10c00017 	ldw	r3,0(r2)
 324631c:	e0bff717 	ldw	r2,-36(fp)
 3246320:	10800017 	ldw	r2,0(r2)
 3246324:	18800826 	beq	r3,r2,3246348 <ip_setmoptions+0x49c>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 3246328:	e0bff80b 	ldhu	r2,-32(fp)
 324632c:	10800044 	addi	r2,r2,1
 3246330:	e0bff80d 	sth	r2,-32(fp)
 3246334:	e0bff617 	ldw	r2,-40(fp)
 3246338:	1080018b 	ldhu	r2,6(r2)
 324633c:	10ffffcc 	andi	r3,r2,65535
 3246340:	e0bff80b 	ldhu	r2,-32(fp)
 3246344:	10ffe036 	bltu	r2,r3,32462c8 <ip_setmoptions+0x41c>
             mreq->imr_multiaddr)
         {
            break;
         }
      }
      if (i == imo->imo_num_memberships) 
 3246348:	e0bff617 	ldw	r2,-40(fp)
 324634c:	1080018b 	ldhu	r2,6(r2)
 3246350:	10ffffcc 	andi	r3,r2,65535
 3246354:	e0bff80b 	ldhu	r2,-32(fp)
 3246358:	1880031e 	bne	r3,r2,3246368 <ip_setmoptions+0x4bc>
      {
         error = EADDRNOTAVAIL;
 324635c:	00801f44 	movi	r2,125
 3246360:	e0bff915 	stw	r2,-28(fp)
         break;
 3246364:	00002c06 	br	3246418 <ip_setmoptions+0x56c>
      }
      /*
       * Give up the multicast address record to which the
       * membership points.
       */
      in_delmulti(imo->imo_membership[i]);
 3246368:	e0bff80b 	ldhu	r2,-32(fp)
 324636c:	e0fff617 	ldw	r3,-40(fp)
 3246370:	1085883a 	add	r2,r2,r2
 3246374:	1085883a 	add	r2,r2,r2
 3246378:	10c5883a 	add	r2,r2,r3
 324637c:	10800204 	addi	r2,r2,8
 3246380:	11000017 	ldw	r4,0(r2)
 3246384:	32435d40 	call	32435d4 <in_delmulti>
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 3246388:	e0bff80b 	ldhu	r2,-32(fp)
 324638c:	10800044 	addi	r2,r2,1
 3246390:	e0bff80d 	sth	r2,-32(fp)
 3246394:	00001206 	br	32463e0 <ip_setmoptions+0x534>
         imo->imo_membership[i-1] = imo->imo_membership[i];
 3246398:	e0bff80b 	ldhu	r2,-32(fp)
 324639c:	113fffc4 	addi	r4,r2,-1
 32463a0:	e0bff80b 	ldhu	r2,-32(fp)
 32463a4:	e0fff617 	ldw	r3,-40(fp)
 32463a8:	1085883a 	add	r2,r2,r2
 32463ac:	1085883a 	add	r2,r2,r2
 32463b0:	10c5883a 	add	r2,r2,r3
 32463b4:	10800204 	addi	r2,r2,8
 32463b8:	11400017 	ldw	r5,0(r2)
 32463bc:	e0fff617 	ldw	r3,-40(fp)
 32463c0:	2105883a 	add	r2,r4,r4
 32463c4:	1085883a 	add	r2,r2,r2
 32463c8:	10c5883a 	add	r2,r2,r3
 32463cc:	10800204 	addi	r2,r2,8
 32463d0:	11400015 	stw	r5,0(r2)
       */
      in_delmulti(imo->imo_membership[i]);
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 32463d4:	e0bff80b 	ldhu	r2,-32(fp)
 32463d8:	10800044 	addi	r2,r2,1
 32463dc:	e0bff80d 	sth	r2,-32(fp)
 32463e0:	e0bff617 	ldw	r2,-40(fp)
 32463e4:	1080018b 	ldhu	r2,6(r2)
 32463e8:	10ffffcc 	andi	r3,r2,65535
 32463ec:	e0bff80b 	ldhu	r2,-32(fp)
 32463f0:	10ffe936 	bltu	r2,r3,3246398 <ip_setmoptions+0x4ec>
         imo->imo_membership[i-1] = imo->imo_membership[i];
      --imo->imo_num_memberships;
 32463f4:	e0bff617 	ldw	r2,-40(fp)
 32463f8:	1080018b 	ldhu	r2,6(r2)
 32463fc:	10bfffc4 	addi	r2,r2,-1
 3246400:	1007883a 	mov	r3,r2
 3246404:	e0bff617 	ldw	r2,-40(fp)
 3246408:	10c0018d 	sth	r3,6(r2)
      break;
 324640c:	00000206 	br	3246418 <ip_setmoptions+0x56c>

      default:
      error = EOPNOTSUPP;
 3246410:	008017c4 	movi	r2,95
 3246414:	e0bff915 	stw	r2,-28(fp)
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 3246418:	e0bff617 	ldw	r2,-40(fp)
 324641c:	10800017 	ldw	r2,0(r2)
 3246420:	1004c03a 	cmpne	r2,r2,zero
 3246424:	1000141e 	bne	r2,zero,3246478 <ip_setmoptions+0x5cc>
 3246428:	e0bff617 	ldw	r2,-40(fp)
 324642c:	10800103 	ldbu	r2,4(r2)
 3246430:	10803fcc 	andi	r2,r2,255
 3246434:	10800058 	cmpnei	r2,r2,1
 3246438:	10000f1e 	bne	r2,zero,3246478 <ip_setmoptions+0x5cc>
 324643c:	e0bff617 	ldw	r2,-40(fp)
 3246440:	10800143 	ldbu	r2,5(r2)
 3246444:	10803fcc 	andi	r2,r2,255
 3246448:	10800058 	cmpnei	r2,r2,1
 324644c:	10000a1e 	bne	r2,zero,3246478 <ip_setmoptions+0x5cc>
 3246450:	e0bff617 	ldw	r2,-40(fp)
 3246454:	1080018b 	ldhu	r2,6(r2)
 3246458:	10bfffcc 	andi	r2,r2,65535
 324645c:	1004c03a 	cmpne	r2,r2,zero
 3246460:	1000051e 	bne	r2,zero,3246478 <ip_setmoptions+0x5cc>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
       imo->imo_num_memberships == 0) 
   {
      IM_FREE(*imop);
 3246464:	e0bff517 	ldw	r2,-44(fp)
 3246468:	11000017 	ldw	r4,0(r2)
 324646c:	322b6c40 	call	322b6c4 <npfree>
      *imop = NULL;
 3246470:	e0bff517 	ldw	r2,-44(fp)
 3246474:	10000015 	stw	zero,0(r2)
   }
   return (error);
 3246478:	e0bff917 	ldw	r2,-28(fp)
 324647c:	e0bffe15 	stw	r2,-8(fp)
 3246480:	e0bffe17 	ldw	r2,-8(fp)
}
 3246484:	e037883a 	mov	sp,fp
 3246488:	dfc00217 	ldw	ra,8(sp)
 324648c:	df000117 	ldw	fp,4(sp)
 3246490:	dc000017 	ldw	r16,0(sp)
 3246494:	dec00304 	addi	sp,sp,12
 3246498:	f800283a 	ret

0324649c <ip_getmoptions>:
 * RETURNS: 
 */

int
ip_getmoptions(int optname, struct socket * so, void * val)
{
 324649c:	defff604 	addi	sp,sp,-40
 32464a0:	df000915 	stw	fp,36(sp)
 32464a4:	df000904 	addi	fp,sp,36
 32464a8:	e13ffb15 	stw	r4,-20(fp)
 32464ac:	e17ffc15 	stw	r5,-16(fp)
 32464b0:	e1bffd15 	stw	r6,-12(fp)
   u_char * ttl;
   u_char * loop;
   ip_addr *addr;
   struct ip_moptions*  imo   =  so->inp_moptions;
 32464b4:	e0bffc17 	ldw	r2,-16(fp)
 32464b8:	10800317 	ldw	r2,12(r2)
 32464bc:	e0bff715 	stw	r2,-36(fp)
   /* The following code will be commented out for Iniche stack.
    * Don't allocate a buffer here.
    *
    *        *mp = m_get(M_WAIT, MT_SOOPTS);
    */
   switch (optname) 
 32464c0:	e0bffb17 	ldw	r2,-20(fp)
 32464c4:	e0bfff15 	stw	r2,-4(fp)
 32464c8:	e0ffff17 	ldw	r3,-4(fp)
 32464cc:	18800260 	cmpeqi	r2,r3,9
 32464d0:	10000a1e 	bne	r2,zero,32464fc <ip_getmoptions+0x60>
 32464d4:	e0ffff17 	ldw	r3,-4(fp)
 32464d8:	18800250 	cmplti	r2,r3,9
 32464dc:	1000381e 	bne	r2,zero,32465c0 <ip_getmoptions+0x124>
 32464e0:	e0ffff17 	ldw	r3,-4(fp)
 32464e4:	188002a0 	cmpeqi	r2,r3,10
 32464e8:	1000171e 	bne	r2,zero,3246548 <ip_getmoptions+0xac>
 32464ec:	e0ffff17 	ldw	r3,-4(fp)
 32464f0:	188002e0 	cmpeqi	r2,r3,11
 32464f4:	1000231e 	bne	r2,zero,3246584 <ip_getmoptions+0xe8>
 32464f8:	00003106 	br	32465c0 <ip_getmoptions+0x124>
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
 32464fc:	e0bffd17 	ldw	r2,-12(fp)
 3246500:	e0bff815 	stw	r2,-32(fp)
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 3246504:	e0bff717 	ldw	r2,-36(fp)
 3246508:	1005003a 	cmpeq	r2,r2,zero
 324650c:	1000041e 	bne	r2,zero,3246520 <ip_getmoptions+0x84>
 3246510:	e0bff717 	ldw	r2,-36(fp)
 3246514:	10800017 	ldw	r2,0(r2)
 3246518:	1004c03a 	cmpne	r2,r2,zero
 324651c:	1000031e 	bne	r2,zero,324652c <ip_getmoptions+0x90>
         *addr = AADDR;
 3246520:	e0bff817 	ldw	r2,-32(fp)
 3246524:	10000015 	stw	zero,0(r2)
   switch (optname) 
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 3246528:	00000506 	br	3246540 <ip_getmoptions+0xa4>
         *addr = AADDR;
      else
         *addr = imo->imo_multicast_netp->n_ipaddr;
 324652c:	e0bff717 	ldw	r2,-36(fp)
 3246530:	10800017 	ldw	r2,0(r2)
 3246534:	10c00a17 	ldw	r3,40(r2)
 3246538:	e0bff817 	ldw	r2,-32(fp)
 324653c:	10c00015 	stw	r3,0(r2)
      return (0);
 3246540:	e03ffe15 	stw	zero,-8(fp)
 3246544:	00002006 	br	32465c8 <ip_getmoptions+0x12c>

   case IP_MULTICAST_TTL:
      ttl = (u_char *)val;
 3246548:	e0bffd17 	ldw	r2,-12(fp)
 324654c:	e0bffa15 	stw	r2,-24(fp)
      if (imo == NULL)
 3246550:	e0bff717 	ldw	r2,-36(fp)
 3246554:	1004c03a 	cmpne	r2,r2,zero
 3246558:	1000041e 	bne	r2,zero,324656c <ip_getmoptions+0xd0>
         *ttl = IP_DEFAULT_MULTICAST_TTL;
 324655c:	e0fffa17 	ldw	r3,-24(fp)
 3246560:	00800044 	movi	r2,1
 3246564:	18800005 	stb	r2,0(r3)
 3246568:	00000406 	br	324657c <ip_getmoptions+0xe0>
      else
         *ttl = imo->imo_multicast_ttl;
 324656c:	e0bff717 	ldw	r2,-36(fp)
 3246570:	10c00103 	ldbu	r3,4(r2)
 3246574:	e0bffa17 	ldw	r2,-24(fp)
 3246578:	10c00005 	stb	r3,0(r2)
      return (0);
 324657c:	e03ffe15 	stw	zero,-8(fp)
 3246580:	00001106 	br	32465c8 <ip_getmoptions+0x12c>

   case IP_MULTICAST_LOOP:
      loop = (u_char *)val;
 3246584:	e0bffd17 	ldw	r2,-12(fp)
 3246588:	e0bff915 	stw	r2,-28(fp)
      if (imo == NULL)
 324658c:	e0bff717 	ldw	r2,-36(fp)
 3246590:	1004c03a 	cmpne	r2,r2,zero
 3246594:	1000041e 	bne	r2,zero,32465a8 <ip_getmoptions+0x10c>
         *loop = IP_DEFAULT_MULTICAST_LOOP;
 3246598:	e0fff917 	ldw	r3,-28(fp)
 324659c:	00800044 	movi	r2,1
 32465a0:	18800005 	stb	r2,0(r3)
 32465a4:	00000406 	br	32465b8 <ip_getmoptions+0x11c>
      else
         *loop = imo->imo_multicast_loop;
 32465a8:	e0bff717 	ldw	r2,-36(fp)
 32465ac:	10c00143 	ldbu	r3,5(r2)
 32465b0:	e0bff917 	ldw	r2,-28(fp)
 32465b4:	10c00005 	stb	r3,0(r2)
      return (0);
 32465b8:	e03ffe15 	stw	zero,-8(fp)
 32465bc:	00000206 	br	32465c8 <ip_getmoptions+0x12c>

      default:
      return (EOPNOTSUPP);
 32465c0:	008017c4 	movi	r2,95
 32465c4:	e0bffe15 	stw	r2,-8(fp)
 32465c8:	e0bffe17 	ldw	r2,-8(fp)
   }
}
 32465cc:	e037883a 	mov	sp,fp
 32465d0:	df000017 	ldw	fp,0(sp)
 32465d4:	dec00104 	addi	sp,sp,4
 32465d8:	f800283a 	ret

032465dc <ip_freemoptions>:
 * RETURNS: 
 */

void
ip_freemoptions(struct ip_moptions * imo)
{
 32465dc:	defffc04 	addi	sp,sp,-16
 32465e0:	dfc00315 	stw	ra,12(sp)
 32465e4:	df000215 	stw	fp,8(sp)
 32465e8:	df000204 	addi	fp,sp,8
 32465ec:	e13fff15 	stw	r4,-4(fp)
   u_short  i;

   if (imo != NULL) 
 32465f0:	e0bfff17 	ldw	r2,-4(fp)
 32465f4:	1005003a 	cmpeq	r2,r2,zero
 32465f8:	1000141e 	bne	r2,zero,324664c <ip_freemoptions+0x70>
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 32465fc:	e03ffe0d 	sth	zero,-8(fp)
 3246600:	00000b06 	br	3246630 <ip_freemoptions+0x54>
         in_delmulti(imo->imo_membership[i]);
 3246604:	e0bffe0b 	ldhu	r2,-8(fp)
 3246608:	e0ffff17 	ldw	r3,-4(fp)
 324660c:	1085883a 	add	r2,r2,r2
 3246610:	1085883a 	add	r2,r2,r2
 3246614:	10c5883a 	add	r2,r2,r3
 3246618:	10800204 	addi	r2,r2,8
 324661c:	11000017 	ldw	r4,0(r2)
 3246620:	32435d40 	call	32435d4 <in_delmulti>
{
   u_short  i;

   if (imo != NULL) 
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 3246624:	e0bffe0b 	ldhu	r2,-8(fp)
 3246628:	10800044 	addi	r2,r2,1
 324662c:	e0bffe0d 	sth	r2,-8(fp)
 3246630:	e0bfff17 	ldw	r2,-4(fp)
 3246634:	1080018b 	ldhu	r2,6(r2)
 3246638:	10ffffcc 	andi	r3,r2,65535
 324663c:	e0bffe0b 	ldhu	r2,-8(fp)
 3246640:	10fff036 	bltu	r2,r3,3246604 <ip_freemoptions+0x28>
         in_delmulti(imo->imo_membership[i]);
      npfree(imo);
 3246644:	e13fff17 	ldw	r4,-4(fp)
 3246648:	322b6c40 	call	322b6c4 <npfree>
   }
}
 324664c:	e037883a 	mov	sp,fp
 3246650:	dfc00117 	ldw	ra,4(sp)
 3246654:	df000017 	ldw	fp,0(sp)
 3246658:	dec00204 	addi	sp,sp,8
 324665c:	f800283a 	ret

03246660 <u_mctest_init>:
 *
 * RETURNS: 
 */

void u_mctest_init()
{
 3246660:	defffe04 	addi	sp,sp,-8
 3246664:	dfc00115 	stw	ra,4(sp)
 3246668:	df000015 	stw	fp,0(sp)
 324666c:	d839883a 	mov	fp,sp
   printf("mctest init called\n");
 3246670:	0100c974 	movhi	r4,805
 3246674:	213fa004 	addi	r4,r4,-384
 3246678:	3206e040 	call	3206e04 <puts>
// altera changes end (cadler@altera.com)
   install_menu(u_mctest_menu);
// altera changes begin (cadler@altera.com)
#endif //IN_MENUS
// altera changes end (cadler@altera.com)
}
 324667c:	e037883a 	mov	sp,fp
 3246680:	dfc00117 	ldw	ra,4(sp)
 3246684:	df000017 	ldw	fp,0(sp)
 3246688:	dec00204 	addi	sp,sp,8
 324668c:	f800283a 	ret

03246690 <u_mctest_run>:
 *
 * RETURNS: 
 */

int u_mctest_run(void * pio)
{
 3246690:	defede04 	addi	sp,sp,-1160
 3246694:	dfc12115 	stw	ra,1156(sp)
 3246698:	df012015 	stw	fp,1152(sp)
 324669c:	df012004 	addi	fp,sp,1152
 32466a0:	e13fff15 	stw	r4,-4(fp)
    struct sockaddr_in   stLocal, stTo, stFrom;
    char  achIn[BUFSIZE];
    char  achOut[] = "Message number:              ";
 32466a4:	00c0c974 	movhi	r3,805
 32466a8:	18c04c04 	addi	r3,r3,304
 32466ac:	18800017 	ldw	r2,0(r3)
 32466b0:	e0bff215 	stw	r2,-56(fp)
 32466b4:	18800117 	ldw	r2,4(r3)
 32466b8:	e0bff315 	stw	r2,-52(fp)
 32466bc:	18800217 	ldw	r2,8(r3)
 32466c0:	e0bff415 	stw	r2,-48(fp)
 32466c4:	18800317 	ldw	r2,12(r3)
 32466c8:	e0bff515 	stw	r2,-44(fp)
 32466cc:	18800417 	ldw	r2,16(r3)
 32466d0:	e0bff615 	stw	r2,-40(fp)
 32466d4:	18800517 	ldw	r2,20(r3)
 32466d8:	e0bff715 	stw	r2,-36(fp)
 32466dc:	18800617 	ldw	r2,24(r3)
 32466e0:	e0bff815 	stw	r2,-32(fp)
 32466e4:	1880070b 	ldhu	r2,28(r3)
 32466e8:	e0bff90d 	sth	r2,-28(fp)
    struct ip_mreq stMreq;
    u_char cTmp;
    unsigned long endtime;

   /* get a datagram socket */
   s = t_socket(AF_INET,SOCK_DGRAM, 0);
 32466ec:	01000084 	movi	r4,2
 32466f0:	01400084 	movi	r5,2
 32466f4:	000d883a 	mov	r6,zero
 32466f8:	322dc100 	call	322dc10 <t_socket>
 32466fc:	e0bee515 	stw	r2,-1132(fp)

   if (s == INVALID_SOCKET) 
 3246700:	e0bee517 	ldw	r2,-1132(fp)
 3246704:	10bfffd8 	cmpnei	r2,r2,-1
 3246708:	1000091e 	bne	r2,zero,3246730 <u_mctest_run+0xa0>
   {
      ns_printf (pio,"t_socket() failed, Err: %d\n", t_errno(s));
 324670c:	e13ee517 	ldw	r4,-1132(fp)
 3246710:	322f3240 	call	322f324 <t_errno>
 3246714:	100d883a 	mov	r6,r2
 3246718:	e13fff17 	ldw	r4,-4(fp)
 324671c:	0140c974 	movhi	r5,805
 3246720:	297fa504 	addi	r5,r5,-364
 3246724:	32260180 	call	3226018 <ns_printf>
      exit(1);
 3246728:	01000044 	movi	r4,1
 324672c:	324b8fc0 	call	324b8fc <exit>
   }

   /* avoid EADDRINUSE error on bind() */ 
   iTmp = 1;
 3246730:	00800044 	movi	r2,1
 3246734:	e0bffa15 	stw	r2,-24(fp)
   iRet = t_setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&iTmp, sizeof(iTmp));
 3246738:	e1fffa04 	addi	r7,fp,-24
 324673c:	00800104 	movi	r2,4
 3246740:	d8800015 	stw	r2,0(sp)
 3246744:	e13ee517 	ldw	r4,-1132(fp)
 3246748:	017fffc4 	movi	r5,-1
 324674c:	01800104 	movi	r6,4
 3246750:	322e6c40 	call	322e6c4 <t_setsockopt>
 3246754:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 3246758:	e0bee317 	ldw	r2,-1140(fp)
 324675c:	10bfffd8 	cmpnei	r2,r2,-1
 3246760:	1000071e 	bne	r2,zero,3246780 <u_mctest_run+0xf0>
   {
      ns_printf (pio,"t_setsockopt() SO_REUSEADDR failed, Err: %d\n",
 3246764:	e13ee517 	ldw	r4,-1132(fp)
 3246768:	322f3240 	call	322f324 <t_errno>
 324676c:	100d883a 	mov	r6,r2
 3246770:	e13fff17 	ldw	r4,-4(fp)
 3246774:	0140c974 	movhi	r5,805
 3246778:	297fac04 	addi	r5,r5,-336
 324677c:	32260180 	call	3226018 <ns_printf>
       t_errno(s));
   }

   /* name the socket */
   stLocal.sin_family =   AF_INET;
 3246780:	00800084 	movi	r2,2
 3246784:	e0bee60d 	sth	r2,-1128(fp)
   stLocal.sin_addr.s_addr = htonl(INADDR_ANY);
 3246788:	e03ee715 	stw	zero,-1124(fp)
   stLocal.sin_port =   htons(TEST_PORT);
 324678c:	00a00344 	movi	r2,-32755
 3246790:	e0bee68d 	sth	r2,-1126(fp)
   iRet = t_bind(s, (struct sockaddr*) &stLocal, sizeof(struct sockaddr_in));
 3246794:	e17ee604 	addi	r5,fp,-1128
 3246798:	e13ee517 	ldw	r4,-1132(fp)
 324679c:	01800404 	movi	r6,16
 32467a0:	322dca00 	call	322dca0 <t_bind>
 32467a4:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 32467a8:	e0bee317 	ldw	r2,-1140(fp)
 32467ac:	10bfffd8 	cmpnei	r2,r2,-1
 32467b0:	1000061e 	bne	r2,zero,32467cc <u_mctest_run+0x13c>
   {
      printf ("t_bind() failed, Err: %d\n",
 32467b4:	e13ee517 	ldw	r4,-1132(fp)
 32467b8:	322f3240 	call	322f324 <t_errno>
 32467bc:	100b883a 	mov	r5,r2
 32467c0:	0100c974 	movhi	r4,805
 32467c4:	213fb804 	addi	r4,r4,-288
 32467c8:	3206adc0 	call	3206adc <printf>
       t_errno(s));
   }

   /* join the multicast group. TEST_ADDR */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR);
 32467cc:	e13fff17 	ldw	r4,-4(fp)
 32467d0:	0140c974 	movhi	r5,805
 32467d4:	297fbf04 	addi	r5,r5,-260
 32467d8:	0180c974 	movhi	r6,805
 32467dc:	31bfc704 	addi	r6,r6,-228
 32467e0:	32260180 	call	3226018 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 32467e4:	0100c974 	movhi	r4,805
 32467e8:	213fc704 	addi	r4,r4,-228
 32467ec:	32477c00 	call	32477c0 <inet_addr>
 32467f0:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 32467f4:	0080c9b4 	movhi	r2,806
 32467f8:	10b19a04 	addi	r2,r2,-14744
 32467fc:	10800a17 	ldw	r2,40(r2)
 3246800:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP,
 3246804:	e1fffb04 	addi	r7,fp,-20
 3246808:	00800204 	movi	r2,8
 324680c:	d8800015 	stw	r2,0(sp)
 3246810:	e13ee517 	ldw	r4,-1132(fp)
 3246814:	000b883a 	mov	r5,zero
 3246818:	01800304 	movi	r6,12
 324681c:	322e6c40 	call	322e6c4 <t_setsockopt>
 3246820:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 3246824:	e0bee317 	ldw	r2,-1140(fp)
 3246828:	10bfffd8 	cmpnei	r2,r2,-1
 324682c:	1000071e 	bne	r2,zero,324684c <u_mctest_run+0x1bc>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 3246830:	e13ee517 	ldw	r4,-1132(fp)
 3246834:	322f3240 	call	322f324 <t_errno>
 3246838:	100d883a 	mov	r6,r2
 324683c:	e13fff17 	ldw	r4,-4(fp)
 3246840:	0140c974 	movhi	r5,805
 3246844:	297fca04 	addi	r5,r5,-216
 3246848:	32260180 	call	3226018 <ns_printf>
                     t_errno(s));
   } 
   tk_yield();
 324684c:	3226a780 	call	3226a78 <tk_yield>

   /* join the multicast group. TEST_ADDR1 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR1);
 3246850:	e13fff17 	ldw	r4,-4(fp)
 3246854:	0140c974 	movhi	r5,805
 3246858:	297fbf04 	addi	r5,r5,-260
 324685c:	0180c974 	movhi	r6,805
 3246860:	31bfd704 	addi	r6,r6,-164
 3246864:	32260180 	call	3226018 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR1);
 3246868:	0100c974 	movhi	r4,805
 324686c:	213fd704 	addi	r4,r4,-164
 3246870:	32477c00 	call	32477c0 <inet_addr>
 3246874:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 3246878:	0080c9b4 	movhi	r2,806
 324687c:	10b19a04 	addi	r2,r2,-14744
 3246880:	10800a17 	ldw	r2,40(r2)
 3246884:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 3246888:	e1fffb04 	addi	r7,fp,-20
 324688c:	00800204 	movi	r2,8
 3246890:	d8800015 	stw	r2,0(sp)
 3246894:	e13ee517 	ldw	r4,-1132(fp)
 3246898:	000b883a 	mov	r5,zero
 324689c:	01800304 	movi	r6,12
 32468a0:	322e6c40 	call	322e6c4 <t_setsockopt>
 32468a4:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 32468a8:	e0bee317 	ldw	r2,-1140(fp)
 32468ac:	10bfffd8 	cmpnei	r2,r2,-1
 32468b0:	1000071e 	bne	r2,zero,32468d0 <u_mctest_run+0x240>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 32468b4:	e13ee517 	ldw	r4,-1132(fp)
 32468b8:	322f3240 	call	322f324 <t_errno>
 32468bc:	100d883a 	mov	r6,r2
 32468c0:	e13fff17 	ldw	r4,-4(fp)
 32468c4:	0140c974 	movhi	r5,805
 32468c8:	297fca04 	addi	r5,r5,-216
 32468cc:	32260180 	call	3226018 <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 32468d0:	3226a780 	call	3226a78 <tk_yield>

   /* join the multicast group. TEST_ADDR2 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR2);
 32468d4:	e13fff17 	ldw	r4,-4(fp)
 32468d8:	0140c974 	movhi	r5,805
 32468dc:	297fbf04 	addi	r5,r5,-260
 32468e0:	0180c974 	movhi	r6,805
 32468e4:	31bfda04 	addi	r6,r6,-152
 32468e8:	32260180 	call	3226018 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR2);
 32468ec:	0100c974 	movhi	r4,805
 32468f0:	213fda04 	addi	r4,r4,-152
 32468f4:	32477c00 	call	32477c0 <inet_addr>
 32468f8:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 32468fc:	0080c9b4 	movhi	r2,806
 3246900:	10b19a04 	addi	r2,r2,-14744
 3246904:	10800a17 	ldw	r2,40(r2)
 3246908:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 324690c:	e1fffb04 	addi	r7,fp,-20
 3246910:	00800204 	movi	r2,8
 3246914:	d8800015 	stw	r2,0(sp)
 3246918:	e13ee517 	ldw	r4,-1132(fp)
 324691c:	000b883a 	mov	r5,zero
 3246920:	01800304 	movi	r6,12
 3246924:	322e6c40 	call	322e6c4 <t_setsockopt>
 3246928:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 324692c:	e0bee317 	ldw	r2,-1140(fp)
 3246930:	10bfffd8 	cmpnei	r2,r2,-1
 3246934:	1000071e 	bne	r2,zero,3246954 <u_mctest_run+0x2c4>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 3246938:	e13ee517 	ldw	r4,-1132(fp)
 324693c:	322f3240 	call	322f324 <t_errno>
 3246940:	100d883a 	mov	r6,r2
 3246944:	e13fff17 	ldw	r4,-4(fp)
 3246948:	0140c974 	movhi	r5,805
 324694c:	297fca04 	addi	r5,r5,-216
 3246950:	32260180 	call	3226018 <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 3246954:	3226a780 	call	3226a78 <tk_yield>

   /* set TTL to traverse up to multiple routers */
   cTmp = TTL_VALUE;
 3246958:	00800084 	movi	r2,2
 324695c:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, (char *)&cTmp, sizeof(cTmp));
 3246960:	e1fffd04 	addi	r7,fp,-12
 3246964:	00800044 	movi	r2,1
 3246968:	d8800015 	stw	r2,0(sp)
 324696c:	e13ee517 	ldw	r4,-1132(fp)
 3246970:	000b883a 	mov	r5,zero
 3246974:	01800284 	movi	r6,10
 3246978:	322e6c40 	call	322e6c4 <t_setsockopt>
 324697c:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 3246980:	e0bee317 	ldw	r2,-1140(fp)
 3246984:	10bfffd8 	cmpnei	r2,r2,-1
 3246988:	1000071e 	bne	r2,zero,32469a8 <u_mctest_run+0x318>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_TTL failed, Err: %d\n",
 324698c:	e13ee517 	ldw	r4,-1132(fp)
 3246990:	322f3240 	call	322f324 <t_errno>
 3246994:	100d883a 	mov	r6,r2
 3246998:	e13fff17 	ldw	r4,-4(fp)
 324699c:	0140c974 	movhi	r5,805
 32469a0:	297fdd04 	addi	r5,r5,-140
 32469a4:	32260180 	call	3226018 <ns_printf>
                     t_errno(s));
   }

   /* enable loopback */
   cTmp = 1;
 32469a8:	00800044 	movi	r2,1
 32469ac:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, (char *)&cTmp, sizeof(cTmp));
 32469b0:	e1fffd04 	addi	r7,fp,-12
 32469b4:	00800044 	movi	r2,1
 32469b8:	d8800015 	stw	r2,0(sp)
 32469bc:	e13ee517 	ldw	r4,-1132(fp)
 32469c0:	000b883a 	mov	r5,zero
 32469c4:	018002c4 	movi	r6,11
 32469c8:	322e6c40 	call	322e6c4 <t_setsockopt>
 32469cc:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 32469d0:	e0bee317 	ldw	r2,-1140(fp)
 32469d4:	10bfffd8 	cmpnei	r2,r2,-1
 32469d8:	1000071e 	bne	r2,zero,32469f8 <u_mctest_run+0x368>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_LOOP failed, Err: %d\n",
 32469dc:	e13ee517 	ldw	r4,-1132(fp)
 32469e0:	322f3240 	call	322f324 <t_errno>
 32469e4:	100d883a 	mov	r6,r2
 32469e8:	e13fff17 	ldw	r4,-4(fp)
 32469ec:	0140c974 	movhi	r5,805
 32469f0:	297fea04 	addi	r5,r5,-88
 32469f4:	32260180 	call	3226018 <ns_printf>
                     t_errno(s));
   }

   /* assign our destination address */
   stTo.sin_family =      AF_INET;
 32469f8:	00800084 	movi	r2,2
 32469fc:	e0beea0d 	sth	r2,-1112(fp)
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
 3246a00:	0100c974 	movhi	r4,805
 3246a04:	213fd704 	addi	r4,r4,-164
 3246a08:	32477c00 	call	32477c0 <inet_addr>
 3246a0c:	e0beeb15 	stw	r2,-1108(fp)
   stTo.sin_port =        htons(TEST_PORT);
 3246a10:	00a00344 	movi	r2,-32755
 3246a14:	e0beea8d 	sth	r2,-1110(fp)
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
 3246a18:	e13fff17 	ldw	r4,-4(fp)
 3246a1c:	0140c974 	movhi	r5,805
 3246a20:	297ff704 	addi	r5,r5,-36
 3246a24:	0180c974 	movhi	r6,805
 3246a28:	31bfd704 	addi	r6,r6,-164
 3246a2c:	32260180 	call	3226018 <ns_printf>
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 3246a30:	e03ee415 	stw	zero,-1136(fp)
 3246a34:	00008506 	br	3246c4c <u_mctest_run+0x5bc>
   {
      static int iCounter = 1;

      /* send to the multicast address */
      sprintf(&achOut[16], "%d", iCounter++);
 3246a38:	e0bff204 	addi	r2,fp,-56
 3246a3c:	11000404 	addi	r4,r2,16
 3246a40:	d0a04e17 	ldw	r2,-32456(gp)
 3246a44:	100d883a 	mov	r6,r2
 3246a48:	10800044 	addi	r2,r2,1
 3246a4c:	d0a04e15 	stw	r2,-32456(gp)
 3246a50:	0140c974 	movhi	r5,805
 3246a54:	29400604 	addi	r5,r5,24
 3246a58:	32076bc0 	call	32076bc <sprintf>
      iRet = t_sendto(s, achOut, sizeof(achOut), 0, (struct sockaddr*)&stTo,
 3246a5c:	e0beea04 	addi	r2,fp,-1112
 3246a60:	e17ff204 	addi	r5,fp,-56
 3246a64:	d8800015 	stw	r2,0(sp)
 3246a68:	00800404 	movi	r2,16
 3246a6c:	d8800115 	stw	r2,4(sp)
 3246a70:	e13ee517 	ldw	r4,-1132(fp)
 3246a74:	01800784 	movi	r6,30
 3246a78:	000f883a 	mov	r7,zero
 3246a7c:	322ec840 	call	322ec84 <t_sendto>
 3246a80:	e0bee315 	stw	r2,-1140(fp)
                      sizeof(struct sockaddr_in));
      if (iRet < 0) 
 3246a84:	e0bee317 	ldw	r2,-1140(fp)
 3246a88:	1004403a 	cmpge	r2,r2,zero
 3246a8c:	1000081e 	bne	r2,zero,3246ab0 <u_mctest_run+0x420>
      {
         /*      perror("sendto() failed\n"); */
         ns_printf (pio,"t_sendto() failed, Error: %d\n", t_errno(s));
 3246a90:	e13ee517 	ldw	r4,-1132(fp)
 3246a94:	322f3240 	call	322f324 <t_errno>
 3246a98:	100d883a 	mov	r6,r2
 3246a9c:	e13fff17 	ldw	r4,-4(fp)
 3246aa0:	0140c974 	movhi	r5,805
 3246aa4:	29400704 	addi	r5,r5,28
 3246aa8:	32260180 	call	3226018 <ns_printf>
         /*     exit(1); */
         goto exitloop;
 3246aac:	00006a06 	br	3246c58 <u_mctest_run+0x5c8>
      }

      /* make the socket non-blocking */
      iTmp = 1;
 3246ab0:	00800044 	movi	r2,1
 3246ab4:	e0bffa15 	stw	r2,-24(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&iTmp, sizeof(iTmp));
 3246ab8:	e1fffa04 	addi	r7,fp,-24
 3246abc:	00800104 	movi	r2,4
 3246ac0:	d8800015 	stw	r2,0(sp)
 3246ac4:	e13ee517 	ldw	r4,-1132(fp)
 3246ac8:	017fffc4 	movi	r5,-1
 3246acc:	01840584 	movi	r6,4118
 3246ad0:	322e6c40 	call	322e6c4 <t_setsockopt>
 3246ad4:	e0bee315 	stw	r2,-1140(fp)
      if (iRet == SOCKET_ERROR) 
 3246ad8:	e0bee317 	ldw	r2,-1140(fp)
 3246adc:	10bfffd8 	cmpnei	r2,r2,-1
 3246ae0:	1000071e 	bne	r2,zero,3246b00 <u_mctest_run+0x470>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (1) failed, Err: %d\n",
 3246ae4:	e13ee517 	ldw	r4,-1132(fp)
 3246ae8:	322f3240 	call	322f324 <t_errno>
 3246aec:	100d883a 	mov	r6,r2
 3246af0:	e13fff17 	ldw	r4,-4(fp)
 3246af4:	0140c974 	movhi	r5,805
 3246af8:	29400f04 	addi	r5,r5,60
 3246afc:	32260180 	call	3226018 <ns_printf>
                        t_errno(s));
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);
 3246b00:	0080c974 	movhi	r2,805
 3246b04:	10925604 	addi	r2,r2,18776
 3246b08:	10800017 	ldw	r2,0(r2)
 3246b0c:	1084e204 	addi	r2,r2,5000
 3246b10:	e0bee215 	stw	r2,-1144(fp)

      while (cticks < endtime)
 3246b14:	00003206 	br	3246be0 <u_mctest_run+0x550>
      {
         int sa_size = sizeof(struct sockaddr_in);
 3246b18:	00800404 	movi	r2,16
 3246b1c:	e0bffe15 	stw	r2,-8(fp)
         tk_yield();
 3246b20:	3226a780 	call	3226a78 <tk_yield>

         iRet = t_recvfrom(s, achIn, BUFSIZE, 0, (struct sockaddr*)&stFrom, &sa_size);
 3246b24:	e0beee04 	addi	r2,fp,-1096
 3246b28:	e17ef204 	addi	r5,fp,-1080
 3246b2c:	d8800015 	stw	r2,0(sp)
 3246b30:	e0bffe04 	addi	r2,fp,-8
 3246b34:	d8800115 	stw	r2,4(sp)
 3246b38:	e13ee517 	ldw	r4,-1132(fp)
 3246b3c:	01810004 	movi	r6,1024
 3246b40:	000f883a 	mov	r7,zero
 3246b44:	322eb340 	call	322eb34 <t_recvfrom>
 3246b48:	e0bee315 	stw	r2,-1140(fp)
         if (iRet < 0) 
 3246b4c:	e0bee317 	ldw	r2,-1140(fp)
 3246b50:	1004403a 	cmpge	r2,r2,zero
 3246b54:	10000c1e 	bne	r2,zero,3246b88 <u_mctest_run+0x4f8>
         {
            if (t_errno(s) != EWOULDBLOCK)
 3246b58:	e13ee517 	ldw	r4,-1132(fp)
 3246b5c:	322f3240 	call	322f324 <t_errno>
 3246b60:	108002e0 	cmpeqi	r2,r2,11
 3246b64:	1000081e 	bne	r2,zero,3246b88 <u_mctest_run+0x4f8>
            {
               /*      perror("recvfrom() failed\n"); */
               ns_printf (pio,"t_recvfrom() failed, Error: %d\n", t_errno(s));
 3246b68:	e13ee517 	ldw	r4,-1132(fp)
 3246b6c:	322f3240 	call	322f324 <t_errno>
 3246b70:	100d883a 	mov	r6,r2
 3246b74:	e13fff17 	ldw	r4,-4(fp)
 3246b78:	0140c974 	movhi	r5,805
 3246b7c:	29401b04 	addi	r5,r5,108
 3246b80:	32260180 	call	3226018 <ns_printf>
               /*     exit(1); */
               goto exitloop;
 3246b84:	00003406 	br	3246c58 <u_mctest_run+0x5c8>
            }
         }
         if (iRet > 0)
 3246b88:	e0bee317 	ldw	r2,-1140(fp)
 3246b8c:	10800050 	cmplti	r2,r2,1
 3246b90:	1000131e 	bne	r2,zero,3246be0 <u_mctest_run+0x550>
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 3246b94:	e13eef17 	ldw	r4,-1092(fp)
 3246b98:	3225c500 	call	3225c50 <print_ipad>
 3246b9c:	100d883a 	mov	r6,r2
 3246ba0:	e0beee8b 	ldhu	r2,-1094(fp)
 3246ba4:	10bfffcc 	andi	r2,r2,65535
 3246ba8:	1004d23a 	srli	r2,r2,8
 3246bac:	10bfffcc 	andi	r2,r2,65535
 3246bb0:	10c03fcc 	andi	r3,r2,255
 3246bb4:	e0beee8b 	ldhu	r2,-1094(fp)
 3246bb8:	10bfffcc 	andi	r2,r2,65535
 3246bbc:	1004923a 	slli	r2,r2,8
 3246bc0:	10bfc00c 	andi	r2,r2,65280
 3246bc4:	188eb03a 	or	r7,r3,r2
 3246bc8:	e0bef204 	addi	r2,fp,-1080
 3246bcc:	d8800015 	stw	r2,0(sp)
 3246bd0:	e13fff17 	ldw	r4,-4(fp)
 3246bd4:	0140c974 	movhi	r5,805
 3246bd8:	29402304 	addi	r5,r5,140
 3246bdc:	32260180 	call	3226018 <ns_printf>
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);

      while (cticks < endtime)
 3246be0:	0080c974 	movhi	r2,805
 3246be4:	10925604 	addi	r2,r2,18776
 3246be8:	10c00017 	ldw	r3,0(r2)
 3246bec:	e0bee217 	ldw	r2,-1144(fp)
 3246bf0:	18bfc936 	bltu	r3,r2,3246b18 <u_mctest_run+0x488>
             ntohs(stFrom.sin_port), achIn);
         }
      }   /* end while (cticks...) */

      /* make the socket blocking */
      cTmp = 0;
 3246bf4:	e03ffd05 	stb	zero,-12(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&cTmp, sizeof(cTmp));
 3246bf8:	e1fffd04 	addi	r7,fp,-12
 3246bfc:	00800044 	movi	r2,1
 3246c00:	d8800015 	stw	r2,0(sp)
 3246c04:	e13ee517 	ldw	r4,-1132(fp)
 3246c08:	017fffc4 	movi	r5,-1
 3246c0c:	01840584 	movi	r6,4118
 3246c10:	322e6c40 	call	322e6c4 <t_setsockopt>
 3246c14:	e0bee315 	stw	r2,-1140(fp)
      if (iRet == SOCKET_ERROR) 
 3246c18:	e0bee317 	ldw	r2,-1140(fp)
 3246c1c:	10bfffd8 	cmpnei	r2,r2,-1
 3246c20:	1000071e 	bne	r2,zero,3246c40 <u_mctest_run+0x5b0>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (0) failed, Err: %d\n",
 3246c24:	e13ee517 	ldw	r4,-1132(fp)
 3246c28:	322f3240 	call	322f324 <t_errno>
 3246c2c:	100d883a 	mov	r6,r2
 3246c30:	e13fff17 	ldw	r4,-4(fp)
 3246c34:	0140c974 	movhi	r5,805
 3246c38:	29402a04 	addi	r5,r5,168
 3246c3c:	32260180 	call	3226018 <ns_printf>
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
   stTo.sin_port =        htons(TEST_PORT);
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 3246c40:	e0bee417 	ldw	r2,-1136(fp)
 3246c44:	10800044 	addi	r2,r2,1
 3246c48:	e0bee415 	stw	r2,-1136(fp)
 3246c4c:	e0bee417 	ldw	r2,-1136(fp)
 3246c50:	108000d0 	cmplti	r2,r2,3
 3246c54:	103f781e 	bne	r2,zero,3246a38 <u_mctest_run+0x3a8>
      }
   }   /* end for(;;) */

exitloop:
   /* delete the multicast group. */
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 3246c58:	0100c974 	movhi	r4,805
 3246c5c:	213fc704 	addi	r4,r4,-228
 3246c60:	32477c00 	call	32477c0 <inet_addr>
 3246c64:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 3246c68:	0080c9b4 	movhi	r2,806
 3246c6c:	10b19a04 	addi	r2,r2,-14744
 3246c70:	10800a17 	ldw	r2,40(r2)
 3246c74:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char *)&stMreq, sizeof(stMreq));
 3246c78:	e1fffb04 	addi	r7,fp,-20
 3246c7c:	00800204 	movi	r2,8
 3246c80:	d8800015 	stw	r2,0(sp)
 3246c84:	e13ee517 	ldw	r4,-1132(fp)
 3246c88:	000b883a 	mov	r5,zero
 3246c8c:	01800344 	movi	r6,13
 3246c90:	322e6c40 	call	322e6c4 <t_setsockopt>
 3246c94:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 3246c98:	e0bee317 	ldw	r2,-1140(fp)
 3246c9c:	10bfffd8 	cmpnei	r2,r2,-1
 3246ca0:	1000071e 	bne	r2,zero,3246cc0 <u_mctest_run+0x630>
   {
      ns_printf (pio,"t_setsockopt() IP_DROP_MEMBERSHIP failed, Err: %d\n",
 3246ca4:	e13ee517 	ldw	r4,-1132(fp)
 3246ca8:	322f3240 	call	322f324 <t_errno>
 3246cac:	100d883a 	mov	r6,r2
 3246cb0:	e13fff17 	ldw	r4,-4(fp)
 3246cb4:	0140c974 	movhi	r5,805
 3246cb8:	29403604 	addi	r5,r5,216
 3246cbc:	32260180 	call	3226018 <ns_printf>
   {
      ns_printf (pio,"t_shutdown failed.  Err: %d\n", t_errno(s));
   }
#endif

   iRet = t_socketclose(s);
 3246cc0:	e13ee517 	ldw	r4,-1132(fp)
 3246cc4:	322f1bc0 	call	322f1bc <t_socketclose>
 3246cc8:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 3246ccc:	e0bee317 	ldw	r2,-1140(fp)
 3246cd0:	10bfffd8 	cmpnei	r2,r2,-1
 3246cd4:	1000071e 	bne	r2,zero,3246cf4 <u_mctest_run+0x664>
   {
      ns_printf (pio,"t_socketclose() failed.  Err: %d\n", t_errno(s));
 3246cd8:	e13ee517 	ldw	r4,-1132(fp)
 3246cdc:	322f3240 	call	322f324 <t_errno>
 3246ce0:	100d883a 	mov	r6,r2
 3246ce4:	e13fff17 	ldw	r4,-4(fp)
 3246ce8:	0140c974 	movhi	r5,805
 3246cec:	29404304 	addi	r5,r5,268
 3246cf0:	32260180 	call	3226018 <ns_printf>
   }

   return(0);
 3246cf4:	0005883a 	mov	r2,zero
}  /* end main() */  
 3246cf8:	e037883a 	mov	sp,fp
 3246cfc:	dfc00117 	ldw	ra,4(sp)
 3246d00:	df000017 	ldw	fp,0(sp)
 3246d04:	dec00204 	addi	sp,sp,8
 3246d08:	f800283a 	ret

03246d0c <dhc_setup>:
 * RETURNS: void
 */

void
dhc_setup(void)
{  
 3246d0c:	defff604 	addi	sp,sp,-40
 3246d10:	dfc00915 	stw	ra,36(sp)
 3246d14:	df000815 	stw	fp,32(sp)
 3246d18:	df000804 	addi	fp,sp,32
   int      iface;
   ulong    dhcp_started;
   ip_addr  dhcp_saveaddr[STATIC_NETS];
   int      e;
   int      dhcnets = 0;   /* number of nets doing DHCP */
 3246d1c:	e03ff815 	stw	zero,-32(fp)

   e = dhc_init();
 3246d20:	3226d3c0 	call	3226d3c <dhc_init>
 3246d24:	e0bff915 	stw	r2,-28(fp)

   if (e)
 3246d28:	e0bff917 	ldw	r2,-28(fp)
 3246d2c:	1005003a 	cmpeq	r2,r2,zero
 3246d30:	1000051e 	bne	r2,zero,3246d48 <dhc_setup+0x3c>
   {
      printf("Error starting DHCP client code.\n");
 3246d34:	0100c974 	movhi	r4,805
 3246d38:	21005404 	addi	r4,r4,336
 3246d3c:	3206e040 	call	3206e04 <puts>
      netexit(1);
 3246d40:	01000044 	movi	r4,1
 3246d44:	32437f00 	call	32437f0 <netexit>
   }

   dhcp_started = cticks;  /* init timeout */
 3246d48:	0080c974 	movhi	r2,805
 3246d4c:	10925604 	addi	r2,r2,18776
 3246d50:	10800017 	ldw	r2,0(r2)
 3246d54:	e0bffa15 	stw	r2,-24(fp)

   for (iface = 0; iface < STATIC_NETS; iface++)
 3246d58:	e03ffb15 	stw	zero,-20(fp)
 3246d5c:	00005106 	br	3246ea4 <dhc_setup+0x198>
   {
      if (!nets[iface])
 3246d60:	e0bffb17 	ldw	r2,-20(fp)
 3246d64:	00c0c9b4 	movhi	r3,806
 3246d68:	18f25a04 	addi	r3,r3,-13976
 3246d6c:	1085883a 	add	r2,r2,r2
 3246d70:	1085883a 	add	r2,r2,r2
 3246d74:	10c5883a 	add	r2,r2,r3
 3246d78:	10800017 	ldw	r2,0(r2)
 3246d7c:	1005003a 	cmpeq	r2,r2,zero
 3246d80:	1000451e 	bne	r2,zero,3246e98 <dhc_setup+0x18c>
#ifdef INCLUDE_NVPARMS
      if (inet_nvparms.ifs[iface].client_dhcp)
         nets[iface]->n_flags |= NF_DHCPC ; /* use DHCP Client on this iface */
#endif   /* INCLUDE_NVPARMS */

      if (!(nets[iface]->n_flags & NF_DHCPC))
 3246d84:	e0bffb17 	ldw	r2,-20(fp)
 3246d88:	00c0c9b4 	movhi	r3,806
 3246d8c:	18f25a04 	addi	r3,r3,-13976
 3246d90:	1085883a 	add	r2,r2,r2
 3246d94:	1085883a 	add	r2,r2,r2
 3246d98:	10c5883a 	add	r2,r2,r3
 3246d9c:	10800017 	ldw	r2,0(r2)
 3246da0:	10802a17 	ldw	r2,168(r2)
 3246da4:	1080400c 	andi	r2,r2,256
 3246da8:	1005003a 	cmpeq	r2,r2,zero
 3246dac:	10003a1e 	bne	r2,zero,3246e98 <dhc_setup+0x18c>
         continue;

      /* If callback is not already in use (by AutoIP) grab it for
       * our printf routine.
       */
      if(dhc_states[iface].callback == NULL)
 3246db0:	e0bffb17 	ldw	r2,-20(fp)
 3246db4:	00c0c9b4 	movhi	r3,806
 3246db8:	18f28004 	addi	r3,r3,-13824
 3246dbc:	10800f24 	muli	r2,r2,60
 3246dc0:	10c5883a 	add	r2,r2,r3
 3246dc4:	10800e04 	addi	r2,r2,56
 3246dc8:	10800017 	ldw	r2,0(r2)
 3246dcc:	1004c03a 	cmpne	r2,r2,zero
 3246dd0:	1000041e 	bne	r2,zero,3246de4 <dhc_setup+0xd8>
      {
         dhc_set_callback(iface, dhc_main_ipset);
 3246dd4:	e13ffb17 	ldw	r4,-20(fp)
 3246dd8:	0140c934 	movhi	r5,804
 3246ddc:	295be504 	addi	r5,r5,28564
 3246de0:	3226df80 	call	3226df8 <dhc_set_callback>
      }

      /* start DHCP on the iface - first save the default address */
      dhcp_saveaddr[iface] = nets[iface]->n_ipaddr;
 3246de4:	e13ffb17 	ldw	r4,-20(fp)
 3246de8:	e0bffb17 	ldw	r2,-20(fp)
 3246dec:	00c0c9b4 	movhi	r3,806
 3246df0:	18f25a04 	addi	r3,r3,-13976
 3246df4:	1085883a 	add	r2,r2,r2
 3246df8:	1085883a 	add	r2,r2,r2
 3246dfc:	10c5883a 	add	r2,r2,r3
 3246e00:	10800017 	ldw	r2,0(r2)
 3246e04:	10c00a17 	ldw	r3,40(r2)
 3246e08:	2105883a 	add	r2,r4,r4
 3246e0c:	1085883a 	add	r2,r2,r2
 3246e10:	e13ff804 	addi	r4,fp,-32
 3246e14:	1105883a 	add	r2,r2,r4
 3246e18:	10800404 	addi	r2,r2,16
 3246e1c:	10c00015 	stw	r3,0(r2)

      if (dhcp_saveaddr[iface] == 0L)  /* see if there is a default */
 3246e20:	e0bffb17 	ldw	r2,-20(fp)
 3246e24:	1085883a 	add	r2,r2,r2
 3246e28:	1085883a 	add	r2,r2,r2
 3246e2c:	e0fff804 	addi	r3,fp,-32
 3246e30:	10c5883a 	add	r2,r2,r3
 3246e34:	10800404 	addi	r2,r2,16
 3246e38:	10800017 	ldw	r2,0(r2)
 3246e3c:	1004c03a 	cmpne	r2,r2,zero
 3246e40:	1000041e 	bne	r2,zero,3246e54 <dhc_setup+0x148>
         dhc_state_init(iface, TRUE);  /* Put DHCPClient in INIT state */
 3246e44:	e13ffb17 	ldw	r4,-20(fp)
 3246e48:	01400044 	movi	r5,1
 3246e4c:	32299d80 	call	32299d8 <dhc_state_init>
 3246e50:	00000306 	br	3246e60 <dhc_setup+0x154>
      else
         dhc_state_init(iface, FALSE); /* Put DHCPClient in INIT-REBOOT state */
 3246e54:	e13ffb17 	ldw	r4,-20(fp)
 3246e58:	000b883a 	mov	r5,zero
 3246e5c:	32299d80 	call	32299d8 <dhc_state_init>

      e=dhc_second();                  /* To send the DISCOVER/REQUEST pkt */
 3246e60:	32291e40 	call	32291e4 <dhc_second>
 3246e64:	e0bff915 	stw	r2,-28(fp)
      if (e)
 3246e68:	e0bff917 	ldw	r2,-28(fp)
 3246e6c:	1005003a 	cmpeq	r2,r2,zero
 3246e70:	1000061e 	bne	r2,zero,3246e8c <dhc_setup+0x180>
      {
         printf("Error sending DHCP packet on iface %d.\n", iface);
 3246e74:	0100c974 	movhi	r4,805
 3246e78:	21005d04 	addi	r4,r4,372
 3246e7c:	e17ffb17 	ldw	r5,-20(fp)
 3246e80:	3206adc0 	call	3206adc <printf>
         netexit(1);
 3246e84:	01000044 	movi	r4,1
 3246e88:	32437f00 	call	32437f0 <netexit>
      /* If we are not using Auto IP then we want to block below waiting
       * for DHCP completion. If we are using Auto IP then we want to
       * return and let the Auto IP code handle the DHCP completion.
       * "dhcnets" is a flag which allows this.
       */
      dhcnets++;
 3246e8c:	e0bff817 	ldw	r2,-32(fp)
 3246e90:	10800044 	addi	r2,r2,1
 3246e94:	e0bff815 	stw	r2,-32(fp)
      netexit(1);
   }

   dhcp_started = cticks;  /* init timeout */

   for (iface = 0; iface < STATIC_NETS; iface++)
 3246e98:	e0bffb17 	ldw	r2,-20(fp)
 3246e9c:	10800044 	addi	r2,r2,1
 3246ea0:	e0bffb15 	stw	r2,-20(fp)
 3246ea4:	e0bffb17 	ldw	r2,-20(fp)
 3246ea8:	10800110 	cmplti	r2,r2,4
 3246eac:	103fac1e 	bne	r2,zero,3246d60 <dhc_setup+0x54>
       */
      dhcnets++;
#endif
   }

   if(dhcnets == 0)  /* no nets doing DHCP? */
 3246eb0:	e0bff817 	ldw	r2,-32(fp)
 3246eb4:	1005003a 	cmpeq	r2,r2,zero
 3246eb8:	1000311e 	bne	r2,zero,3246f80 <dhc_setup+0x274>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 3246ebc:	00000206 	br	3246ec8 <dhc_setup+0x1bc>
   {
      /* let other tasks spin. This is required, since some systems
       * increment cticks in tasks, or use a polling task to receive
       * packets. Without this activity this loop will never exit.
       */
      tk_yield();
 3246ec0:	3226a780 	call	3226a78 <tk_yield>
      pktdemux();
 3246ec4:	32232f00 	call	32232f0 <pktdemux>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 3246ec8:	0080c974 	movhi	r2,805
 3246ecc:	10925604 	addi	r2,r2,18776
 3246ed0:	10c00017 	ldw	r3,0(r2)
 3246ed4:	e0bffa17 	ldw	r2,-24(fp)
 3246ed8:	1887c83a 	sub	r3,r3,r2
 3246edc:	008000b4 	movhi	r2,2
 3246ee0:	10bef3c4 	addi	r2,r2,-1073
 3246ee4:	10c00336 	bltu	r2,r3,3246ef4 <dhc_setup+0x1e8>
 3246ee8:	3229a380 	call	3229a38 <dhc_alldone>
 3246eec:	1005003a 	cmpeq	r2,r2,zero
 3246ef0:	103ff31e 	bne	r2,zero,3246ec0 <dhc_setup+0x1b4>
#ifdef SUPERLOOP
      dhc_second ();
#endif
   }

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
 3246ef4:	3229a380 	call	3229a38 <dhc_alldone>
 3246ef8:	1004c03a 	cmpne	r2,r2,zero
 3246efc:	1000201e 	bne	r2,zero,3246f80 <dhc_setup+0x274>
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
 3246f00:	0100c974 	movhi	r4,805
 3246f04:	21006704 	addi	r4,r4,412
 3246f08:	3206e040 	call	3206e04 <puts>
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 3246f0c:	e03ffb15 	stw	zero,-20(fp)
 3246f10:	00001806 	br	3246f74 <dhc_setup+0x268>
      {
         if (dhc_ifacedone(iface) == FALSE)
 3246f14:	e13ffb17 	ldw	r4,-20(fp)
 3246f18:	3229ac80 	call	3229ac8 <dhc_ifacedone>
 3246f1c:	1004c03a 	cmpne	r2,r2,zero
 3246f20:	1000111e 	bne	r2,zero,3246f68 <dhc_setup+0x25c>
         {
            dhc_halt(iface);
 3246f24:	e13ffb17 	ldw	r4,-20(fp)
 3246f28:	32297800 	call	3229780 <dhc_halt>
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
 3246f2c:	e0bffb17 	ldw	r2,-20(fp)
 3246f30:	00c0c9b4 	movhi	r3,806
 3246f34:	18f25a04 	addi	r3,r3,-13976
 3246f38:	1085883a 	add	r2,r2,r2
 3246f3c:	1085883a 	add	r2,r2,r2
 3246f40:	10c5883a 	add	r2,r2,r3
 3246f44:	10c00017 	ldw	r3,0(r2)
 3246f48:	e0bffb17 	ldw	r2,-20(fp)
 3246f4c:	1085883a 	add	r2,r2,r2
 3246f50:	1085883a 	add	r2,r2,r2
 3246f54:	e13ff804 	addi	r4,fp,-32
 3246f58:	1105883a 	add	r2,r2,r4
 3246f5c:	10800404 	addi	r2,r2,16
 3246f60:	10800017 	ldw	r2,0(r2)
 3246f64:	18800a15 	stw	r2,40(r3)

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 3246f68:	e0bffb17 	ldw	r2,-20(fp)
 3246f6c:	10800044 	addi	r2,r2,1
 3246f70:	e0bffb15 	stw	r2,-20(fp)
 3246f74:	e0bffb17 	ldw	r2,-20(fp)
 3246f78:	10800110 	cmplti	r2,r2,4
 3246f7c:	103fe51e 	bne	r2,zero,3246f14 <dhc_setup+0x208>
            dhc_halt(iface);
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
         }
      }
   }
}
 3246f80:	e037883a 	mov	sp,fp
 3246f84:	dfc00117 	ldw	ra,4(sp)
 3246f88:	df000017 	ldw	fp,0(sp)
 3246f8c:	dec00204 	addi	sp,sp,8
 3246f90:	f800283a 	ret

03246f94 <dhc_main_ipset>:
 * RETURNS: 
 */

int
dhc_main_ipset(int iface, int state)
{
 3246f94:	defffc04 	addi	sp,sp,-16
 3246f98:	dfc00315 	stw	ra,12(sp)
 3246f9c:	df000215 	stw	fp,8(sp)
 3246fa0:	df000204 	addi	fp,sp,8
 3246fa4:	e13ffe15 	stw	r4,-8(fp)
 3246fa8:	e17fff15 	stw	r5,-4(fp)
   if ( state == DHCS_BOUND )
 3246fac:	e0bfff17 	ldw	r2,-4(fp)
 3246fb0:	10800198 	cmpnei	r2,r2,6
 3246fb4:	1000321e 	bne	r2,zero,3247080 <dhc_main_ipset+0xec>
   {
      /* print IP address acquired through DHCP Client - for user's benefit */
      printf("Acquired IP address via DHCP client for interface: %s\n",
 3246fb8:	e0bffe17 	ldw	r2,-8(fp)
 3246fbc:	00c0c9b4 	movhi	r3,806
 3246fc0:	18f25a04 	addi	r3,r3,-13976
 3246fc4:	1085883a 	add	r2,r2,r2
 3246fc8:	1085883a 	add	r2,r2,r2
 3246fcc:	10c5883a 	add	r2,r2,r3
 3246fd0:	10800017 	ldw	r2,0(r2)
 3246fd4:	11400104 	addi	r5,r2,4
 3246fd8:	0100c974 	movhi	r4,805
 3246fdc:	21007504 	addi	r4,r4,468
 3246fe0:	3206adc0 	call	3206adc <printf>
              nets[iface]->name);

      printf("IP address : %s\n", print_ipad(nets[iface]->n_ipaddr));
 3246fe4:	e0bffe17 	ldw	r2,-8(fp)
 3246fe8:	00c0c9b4 	movhi	r3,806
 3246fec:	18f25a04 	addi	r3,r3,-13976
 3246ff0:	1085883a 	add	r2,r2,r2
 3246ff4:	1085883a 	add	r2,r2,r2
 3246ff8:	10c5883a 	add	r2,r2,r3
 3246ffc:	10800017 	ldw	r2,0(r2)
 3247000:	11000a17 	ldw	r4,40(r2)
 3247004:	3225c500 	call	3225c50 <print_ipad>
 3247008:	100b883a 	mov	r5,r2
 324700c:	0100c974 	movhi	r4,805
 3247010:	21008304 	addi	r4,r4,524
 3247014:	3206adc0 	call	3206adc <printf>
      printf("Subnet Mask: %s\n", print_ipad(nets[iface]->snmask));
 3247018:	e0bffe17 	ldw	r2,-8(fp)
 324701c:	00c0c9b4 	movhi	r3,806
 3247020:	18f25a04 	addi	r3,r3,-13976
 3247024:	1085883a 	add	r2,r2,r2
 3247028:	1085883a 	add	r2,r2,r2
 324702c:	10c5883a 	add	r2,r2,r3
 3247030:	10800017 	ldw	r2,0(r2)
 3247034:	11000c17 	ldw	r4,48(r2)
 3247038:	3225c500 	call	3225c50 <print_ipad>
 324703c:	100b883a 	mov	r5,r2
 3247040:	0100c974 	movhi	r4,805
 3247044:	21008804 	addi	r4,r4,544
 3247048:	3206adc0 	call	3206adc <printf>
      printf("Gateway    : %s\n", print_ipad(nets[iface]->n_defgw));
 324704c:	e0bffe17 	ldw	r2,-8(fp)
 3247050:	00c0c9b4 	movhi	r3,806
 3247054:	18f25a04 	addi	r3,r3,-13976
 3247058:	1085883a 	add	r2,r2,r2
 324705c:	1085883a 	add	r2,r2,r2
 3247060:	10c5883a 	add	r2,r2,r3
 3247064:	10800017 	ldw	r2,0(r2)
 3247068:	11000d17 	ldw	r4,52(r2)
 324706c:	3225c500 	call	3225c50 <print_ipad>
 3247070:	100b883a 	mov	r5,r2
 3247074:	0100c974 	movhi	r4,805
 3247078:	21008d04 	addi	r4,r4,564
 324707c:	3206adc0 	call	3206adc <printf>
   }
   return 0;
 3247080:	0005883a 	mov	r2,zero
}
 3247084:	e037883a 	mov	sp,fp
 3247088:	dfc00117 	ldw	ra,4(sp)
 324708c:	df000017 	ldw	fp,0(sp)
 3247090:	dec00204 	addi	sp,sp,8
 3247094:	f800283a 	ret

03247098 <init_memdev>:
 * RETURNS: 
 */

int
init_memdev(void)
{
 3247098:	deffff04 	addi	sp,sp,-4
 324709c:	df000015 	stw	fp,0(sp)
 32470a0:	d839883a 	mov	fp,sp
   /* add our IO pointer to master list */
   mdio.next = vfsystems;
 32470a4:	0080c974 	movhi	r2,805
 32470a8:	10928204 	addi	r2,r2,18952
 32470ac:	10c00017 	ldw	r3,0(r2)
 32470b0:	0080c974 	movhi	r2,805
 32470b4:	10891c04 	addi	r2,r2,9328
 32470b8:	10c00015 	stw	r3,0(r2)
   vfsystems = &mdio;
 32470bc:	00c0c974 	movhi	r3,805
 32470c0:	18d28204 	addi	r3,r3,18952
 32470c4:	0080c974 	movhi	r2,805
 32470c8:	10891c04 	addi	r2,r2,9328
 32470cc:	18800015 	stw	r2,0(r3)

   /* add the memory device files to vfs list */
   mdlist[0].next = vfsfiles;
 32470d0:	0080c974 	movhi	r2,805
 32470d4:	10928404 	addi	r2,r2,18960
 32470d8:	10c00017 	ldw	r3,0(r2)
 32470dc:	0080c974 	movhi	r2,805
 32470e0:	10892504 	addi	r2,r2,9364
 32470e4:	10c00015 	stw	r3,0(r2)
   vfsfiles = &mdlist[3];
 32470e8:	00c0c974 	movhi	r3,805
 32470ec:	18c94604 	addi	r3,r3,9496
 32470f0:	0080c974 	movhi	r2,805
 32470f4:	10928404 	addi	r2,r2,18960
 32470f8:	10c00015 	stw	r3,0(r2)

   return 0;
 32470fc:	0005883a 	mov	r2,zero
}
 3247100:	e037883a 	mov	sp,fp
 3247104:	df000017 	ldw	fp,0(sp)
 3247108:	dec00104 	addi	sp,sp,4
 324710c:	f800283a 	ret

03247110 <md_fopen>:
 * RETURNS: 
 */

VFILE* 
md_fopen(char * name, char * mode)
{
 3247110:	defffd04 	addi	sp,sp,-12
 3247114:	df000215 	stw	fp,8(sp)
 3247118:	df000204 	addi	fp,sp,8
 324711c:	e13ffe15 	stw	r4,-8(fp)
 3247120:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(mode);
   USE_ARG(name);
   return NULL;
 3247124:	0005883a 	mov	r2,zero
}
 3247128:	e037883a 	mov	sp,fp
 324712c:	df000017 	ldw	fp,0(sp)
 3247130:	dec00104 	addi	sp,sp,4
 3247134:	f800283a 	ret

03247138 <md_fclose>:
 * RETURNS: 
 */

void   
md_fclose(VFILE * vfd)
{
 3247138:	defffe04 	addi	sp,sp,-8
 324713c:	df000115 	stw	fp,4(sp)
 3247140:	df000104 	addi	fp,sp,4
 3247144:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);
}
 3247148:	e037883a 	mov	sp,fp
 324714c:	df000017 	ldw	fp,0(sp)
 3247150:	dec00104 	addi	sp,sp,4
 3247154:	f800283a 	ret

03247158 <md_fread>:
 * RETURNS: 
 */

int    
md_fread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 3247158:	defff604 	addi	sp,sp,-40
 324715c:	dfc00915 	stw	ra,36(sp)
 3247160:	df000815 	stw	fp,32(sp)
 3247164:	df000804 	addi	fp,sp,32
 3247168:	e13ffb15 	stw	r4,-20(fp)
 324716c:	e17ffc15 	stw	r5,-16(fp)
 3247170:	e1bffd15 	stw	r6,-12(fp)
 3247174:	e1fffe15 	stw	r7,-8(fp)
   u_long   bcount;     /* number of bytes put in caller's buffer */
   u_long   location;   /* current offset into file */
   unsigned long file_size = MEMDEV_SIZE;
 3247178:	00800834 	movhi	r2,32
 324717c:	e0bff815 	stw	r2,-32(fp)
   if(vfd && vfd->file)
 3247180:	e0bffe17 	ldw	r2,-8(fp)
 3247184:	1005003a 	cmpeq	r2,r2,zero
 3247188:	1000081e 	bne	r2,zero,32471ac <md_fread+0x54>
 324718c:	e0bffe17 	ldw	r2,-8(fp)
 3247190:	10800117 	ldw	r2,4(r2)
 3247194:	1005003a 	cmpeq	r2,r2,zero
 3247198:	1000041e 	bne	r2,zero,32471ac <md_fread+0x54>
   {
      file_size = vfd->file->real_size; 
 324719c:	e0bffe17 	ldw	r2,-8(fp)
 32471a0:	10800117 	ldw	r2,4(r2)
 32471a4:	10800717 	ldw	r2,28(r2)
 32471a8:	e0bff815 	stw	r2,-32(fp)
#ifdef SEG16_16   /* 16-bit x86 must include segment. */
   if(vfd->cmploc == (u_char*)0xFFFFFFFF)   /* at EOF */
      return 0;
   location = (u_long)(((char huge *)vfd->cmploc) - ((char huge *)vfd->file->data));
#else
   location = (u_long)(vfd->cmploc - vfd->file->data);
 32471ac:	e0bffe17 	ldw	r2,-8(fp)
 32471b0:	10800217 	ldw	r2,8(r2)
 32471b4:	1007883a 	mov	r3,r2
 32471b8:	e0bffe17 	ldw	r2,-8(fp)
 32471bc:	10800117 	ldw	r2,4(r2)
 32471c0:	10800617 	ldw	r2,24(r2)
 32471c4:	1885c83a 	sub	r2,r3,r2
 32471c8:	e0bff915 	stw	r2,-28(fp)
#endif   /* SEG16_16 */

   bcount = (items * (u_long)size);     /* number of bytes to transfer */
 32471cc:	e0fffd17 	ldw	r3,-12(fp)
 32471d0:	e0bffc17 	ldw	r2,-16(fp)
 32471d4:	1885383a 	mul	r2,r3,r2
 32471d8:	e0bffa15 	stw	r2,-24(fp)

   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
 32471dc:	e0fff917 	ldw	r3,-28(fp)
 32471e0:	e0bffa17 	ldw	r2,-24(fp)
 32471e4:	1887883a 	add	r3,r3,r2
 32471e8:	e0bff817 	ldw	r2,-32(fp)
 32471ec:	10c0042e 	bgeu	r2,r3,3247200 <md_fread+0xa8>
      bcount = ((u_long)file_size - location);
 32471f0:	e0bff817 	ldw	r2,-32(fp)
 32471f4:	e0fff917 	ldw	r3,-28(fp)
 32471f8:	10c5c83a 	sub	r2,r2,r3
 32471fc:	e0bffa15 	stw	r2,-24(fp)

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 3247200:	e0fff917 	ldw	r3,-28(fp)
 3247204:	e0bff817 	ldw	r2,-32(fp)
 3247208:	1880072e 	bgeu	r3,r2,3247228 <md_fread+0xd0>
 324720c:	e0bffa17 	ldw	r2,-24(fp)
 3247210:	10bfffec 	andhi	r2,r2,65535
 3247214:	1004c03a 	cmpne	r2,r2,zero
 3247218:	1000031e 	bne	r2,zero,3247228 <md_fread+0xd0>
 324721c:	e0bffa17 	ldw	r2,-24(fp)
 3247220:	1004c03a 	cmpne	r2,r2,zero
 3247224:	1000021e 	bne	r2,zero,3247230 <md_fread+0xd8>
      (bcount  & 0xFFFF0000) ||
      (bcount == 0))
   {
      return 0;
 3247228:	e03fff15 	stw	zero,-4(fp)
 324722c:	00002406 	br	32472c0 <md_fread+0x168>
   /* Use VF_NODATA if memory devices have a size, but no
      data. This can be used to measure file read speed
      without introducing an undefined data copy. */
   /* VF_NODATA is defined in ../h/vfsfiles.h */
   
   if (!(vfd->file->flags & VF_NODATA))
 3247230:	e0bffe17 	ldw	r2,-8(fp)
 3247234:	10800117 	ldw	r2,4(r2)
 3247238:	1080058b 	ldhu	r2,22(r2)
 324723c:	10bfffcc 	andi	r2,r2,65535
 3247240:	10a0001c 	xori	r2,r2,32768
 3247244:	10a00004 	addi	r2,r2,-32768
 3247248:	1004803a 	cmplt	r2,r2,zero
 324724c:	1000111e 	bne	r2,zero,3247294 <md_fread+0x13c>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 3247250:	e0bffe17 	ldw	r2,-8(fp)
 3247254:	10800117 	ldw	r2,4(r2)
 3247258:	10800103 	ldbu	r2,4(r2)
 324725c:	10803fcc 	andi	r2,r2,255
 3247260:	1080201c 	xori	r2,r2,128
 3247264:	10bfe004 	addi	r2,r2,-128
 3247268:	10801b58 	cmpnei	r2,r2,109
 324726c:	1000091e 	bne	r2,zero,3247294 <md_fread+0x13c>
         MEMCPY(buf, vfd->cmploc + MEMDEV_BASE, (unsigned)bcount);
 3247270:	e0bffe17 	ldw	r2,-8(fp)
 3247274:	10c00217 	ldw	r3,8(r2)
 3247278:	00800834 	movhi	r2,32
 324727c:	1887883a 	add	r3,r3,r2
 3247280:	e0bffb17 	ldw	r2,-20(fp)
 3247284:	1009883a 	mov	r4,r2
 3247288:	180b883a 	mov	r5,r3
 324728c:	e1bffa17 	ldw	r6,-24(fp)
 3247290:	32067cc0 	call	32067cc <memcpy>
         vfd->cmploc = (u_char *)cp;
      else     /* read wrapped memory, set pointer to EOF value */
         vfd->cmploc = (u_char*)(0xFFFFFFFF);  /* EOF */
   }
#else
   vfd->cmploc += bcount;  /* adjust location */
 3247294:	e0bffe17 	ldw	r2,-8(fp)
 3247298:	10c00217 	ldw	r3,8(r2)
 324729c:	e0bffa17 	ldw	r2,-24(fp)
 32472a0:	1887883a 	add	r3,r3,r2
 32472a4:	e0bffe17 	ldw	r2,-8(fp)
 32472a8:	10c00215 	stw	r3,8(r2)
#endif
   
   return ((int)bcount/size);
 32472ac:	e0bffa17 	ldw	r2,-24(fp)
 32472b0:	1009883a 	mov	r4,r2
 32472b4:	e17ffc17 	ldw	r5,-16(fp)
 32472b8:	32044bc0 	call	32044bc <__udivsi3>
 32472bc:	e0bfff15 	stw	r2,-4(fp)
 32472c0:	e0bfff17 	ldw	r2,-4(fp)
}
 32472c4:	e037883a 	mov	sp,fp
 32472c8:	dfc00117 	ldw	ra,4(sp)
 32472cc:	df000017 	ldw	fp,0(sp)
 32472d0:	dec00204 	addi	sp,sp,8
 32472d4:	f800283a 	ret

032472d8 <md_fwrite>:
 * RETURNS: 
 */

int    
md_fwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 32472d8:	defffa04 	addi	sp,sp,-24
 32472dc:	df000515 	stw	fp,20(sp)
 32472e0:	df000504 	addi	fp,sp,20
 32472e4:	e13ffb15 	stw	r4,-20(fp)
 32472e8:	e17ffc15 	stw	r5,-16(fp)
 32472ec:	e1bffd15 	stw	r6,-12(fp)
 32472f0:	e1fffe15 	stw	r7,-8(fp)
   if (vfd->file->name[0] == 'm')   /* memory device */
 32472f4:	e0bffe17 	ldw	r2,-8(fp)
 32472f8:	10800117 	ldw	r2,4(r2)
 32472fc:	10800103 	ldbu	r2,4(r2)
 3247300:	10803fcc 	andi	r2,r2,255
 3247304:	1080201c 	xori	r2,r2,128
 3247308:	10bfe004 	addi	r2,r2,-128
 324730c:	10801b58 	cmpnei	r2,r2,109
 3247310:	1000021e 	bne	r2,zero,324731c <md_fwrite+0x44>
      return 0;   /* not writable device */
 3247314:	e03fff15 	stw	zero,-4(fp)
 3247318:	00000a06 	br	3247344 <md_fwrite+0x6c>

   vfd->cmploc += (items * size);   /* adjust location */
 324731c:	e0bffe17 	ldw	r2,-8(fp)
 3247320:	11000217 	ldw	r4,8(r2)
 3247324:	e0fffd17 	ldw	r3,-12(fp)
 3247328:	e0bffc17 	ldw	r2,-16(fp)
 324732c:	1885383a 	mul	r2,r3,r2
 3247330:	2087883a 	add	r3,r4,r2
 3247334:	e0bffe17 	ldw	r2,-8(fp)
 3247338:	10c00215 	stw	r3,8(r2)

   USE_ARG(buf);     /* supress compiler warnings */

   return (items);
 324733c:	e0bffd17 	ldw	r2,-12(fp)
 3247340:	e0bfff15 	stw	r2,-4(fp)
 3247344:	e0bfff17 	ldw	r2,-4(fp)
}
 3247348:	e037883a 	mov	sp,fp
 324734c:	df000017 	ldw	fp,0(sp)
 3247350:	dec00104 	addi	sp,sp,4
 3247354:	f800283a 	ret

03247358 <md_fseek>:
 * RETURNS: 
 */

int
md_fseek(VFILE * vfd, long offset, int mode)
{
 3247358:	defffc04 	addi	sp,sp,-16
 324735c:	df000315 	stw	fp,12(sp)
 3247360:	df000304 	addi	fp,sp,12
 3247364:	e13ffd15 	stw	r4,-12(fp)
 3247368:	e17ffe15 	stw	r5,-8(fp)
 324736c:	e1bfff15 	stw	r6,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   USE_ARG(offset);
   USE_ARG(mode);
   return 0;
 3247370:	0005883a 	mov	r2,zero
}
 3247374:	e037883a 	mov	sp,fp
 3247378:	df000017 	ldw	fp,0(sp)
 324737c:	dec00104 	addi	sp,sp,4
 3247380:	f800283a 	ret

03247384 <md_ftell>:
 * RETURNS: 
 */

long   
md_ftell(VFILE * vfd)
{
 3247384:	defffe04 	addi	sp,sp,-8
 3247388:	df000115 	stw	fp,4(sp)
 324738c:	df000104 	addi	fp,sp,4
 3247390:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   return MEMDEV_SIZE;
 3247394:	00800834 	movhi	r2,32
}
 3247398:	e037883a 	mov	sp,fp
 324739c:	df000017 	ldw	fp,0(sp)
 32473a0:	dec00104 	addi	sp,sp,4
 32473a4:	f800283a 	ret

032473a8 <md_fgetc>:
 * RETURNS: 
 */

int    
md_fgetc(VFILE * vfd)
{
 32473a8:	defffb04 	addi	sp,sp,-20
 32473ac:	df000415 	stw	fp,16(sp)
 32473b0:	df000404 	addi	fp,sp,16
 32473b4:	e13ffe15 	stw	r4,-8(fp)
   unsigned location;   /* current offset infile */
   int   retval   =  0;
 32473b8:	e03ffc15 	stw	zero,-16(fp)

   location = vfd->cmploc - vfd->file->data;
 32473bc:	e0bffe17 	ldw	r2,-8(fp)
 32473c0:	10800217 	ldw	r2,8(r2)
 32473c4:	1007883a 	mov	r3,r2
 32473c8:	e0bffe17 	ldw	r2,-8(fp)
 32473cc:	10800117 	ldw	r2,4(r2)
 32473d0:	10800617 	ldw	r2,24(r2)
 32473d4:	1885c83a 	sub	r2,r3,r2
 32473d8:	e0bffd15 	stw	r2,-12(fp)
   if (location >= vfd->file->real_size)     /* at end of file? */
 32473dc:	e0bffe17 	ldw	r2,-8(fp)
 32473e0:	10800117 	ldw	r2,4(r2)
 32473e4:	10c00717 	ldw	r3,28(r2)
 32473e8:	e0bffd17 	ldw	r2,-12(fp)
 32473ec:	10c00336 	bltu	r2,r3,32473fc <md_fgetc+0x54>
      return EOF;
 32473f0:	00bfffc4 	movi	r2,-1
 32473f4:	e0bfff15 	stw	r2,-4(fp)
 32473f8:	00001c06 	br	324746c <md_fgetc+0xc4>

   if (!(vfd->file->flags & VF_NODATA))
 32473fc:	e0bffe17 	ldw	r2,-8(fp)
 3247400:	10800117 	ldw	r2,4(r2)
 3247404:	1080058b 	ldhu	r2,22(r2)
 3247408:	10bfffcc 	andi	r2,r2,65535
 324740c:	10a0001c 	xori	r2,r2,32768
 3247410:	10a00004 	addi	r2,r2,-32768
 3247414:	1004803a 	cmplt	r2,r2,zero
 3247418:	10000d1e 	bne	r2,zero,3247450 <md_fgetc+0xa8>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 324741c:	e0bffe17 	ldw	r2,-8(fp)
 3247420:	10800117 	ldw	r2,4(r2)
 3247424:	10800103 	ldbu	r2,4(r2)
 3247428:	10803fcc 	andi	r2,r2,255
 324742c:	1080201c 	xori	r2,r2,128
 3247430:	10bfe004 	addi	r2,r2,-128
 3247434:	10801b58 	cmpnei	r2,r2,109
 3247438:	1000051e 	bne	r2,zero,3247450 <md_fgetc+0xa8>
         retval = (int)(*vfd->cmploc) & 0xFF ;
 324743c:	e0bffe17 	ldw	r2,-8(fp)
 3247440:	10800217 	ldw	r2,8(r2)
 3247444:	10800003 	ldbu	r2,0(r2)
 3247448:	10803fcc 	andi	r2,r2,255
 324744c:	e0bffc15 	stw	r2,-16(fp)
   }

   /* else for null device or files without data, 
      use whatever is in retval */

   vfd->cmploc++;    /* adjust location */
 3247450:	e0bffe17 	ldw	r2,-8(fp)
 3247454:	10800217 	ldw	r2,8(r2)
 3247458:	10c00044 	addi	r3,r2,1
 324745c:	e0bffe17 	ldw	r2,-8(fp)
 3247460:	10c00215 	stw	r3,8(r2)
   return retval;
 3247464:	e0bffc17 	ldw	r2,-16(fp)
 3247468:	e0bfff15 	stw	r2,-4(fp)
 324746c:	e0bfff17 	ldw	r2,-4(fp)
}
 3247470:	e037883a 	mov	sp,fp
 3247474:	df000017 	ldw	fp,0(sp)
 3247478:	dec00104 	addi	sp,sp,4
 324747c:	f800283a 	ret

03247480 <md_unlink>:
 * RETURNS: 
 */

int    
md_unlink(char * filename)
{
 3247480:	defffe04 	addi	sp,sp,-8
 3247484:	df000115 	stw	fp,4(sp)
 3247488:	df000104 	addi	fp,sp,4
 324748c:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(filename);     /* supress compiler warnings */
   return 0;
 3247490:	0005883a 	mov	r2,zero
}
 3247494:	e037883a 	mov	sp,fp
 3247498:	df000017 	ldw	fp,0(sp)
 324749c:	dec00104 	addi	sp,sp,4
 32474a0:	f800283a 	ret

032474a4 <parse_ipad>:

char *   
parse_ipad(ip_addr * ipout,   /* pointer to IP address to set */
   unsigned *  sbits,      /* default subnet bit number */
   char *   stringin)      /* buffer with ascii to parse */
{
 32474a4:	defff504 	addi	sp,sp,-44
 32474a8:	dfc00a15 	stw	ra,40(sp)
 32474ac:	df000915 	stw	fp,36(sp)
 32474b0:	df000904 	addi	fp,sp,36
 32474b4:	e13ffc15 	stw	r4,-16(fp)
 32474b8:	e17ffd15 	stw	r5,-12(fp)
 32474bc:	e1bffe15 	stw	r6,-8(fp)
   char *   cp;
   int   dots  =  0; /* periods imbedded in input string */
 32474c0:	e03ff915 	stw	zero,-28(fp)
   union   
   {
      u_char   c[4];
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";
 32474c4:	0080c974 	movhi	r2,805
 32474c8:	10809204 	addi	r2,r2,584
 32474cc:	e0bff715 	stw	r2,-36(fp)

   cp = stringin;
 32474d0:	e0bffe17 	ldw	r2,-8(fp)
 32474d4:	e0bffa15 	stw	r2,-24(fp)
   while (*cp)
 32474d8:	00002606 	br	3247574 <parse_ipad+0xd0>
   {
      if (*cp > '9' || *cp < '.' || *cp == '/')
 32474dc:	e0bffa17 	ldw	r2,-24(fp)
 32474e0:	10800003 	ldbu	r2,0(r2)
 32474e4:	10803fcc 	andi	r2,r2,255
 32474e8:	1080201c 	xori	r2,r2,128
 32474ec:	10bfe004 	addi	r2,r2,-128
 32474f0:	10800e88 	cmpgei	r2,r2,58
 32474f4:	10000e1e 	bne	r2,zero,3247530 <parse_ipad+0x8c>
 32474f8:	e0bffa17 	ldw	r2,-24(fp)
 32474fc:	10800003 	ldbu	r2,0(r2)
 3247500:	10803fcc 	andi	r2,r2,255
 3247504:	1080201c 	xori	r2,r2,128
 3247508:	10bfe004 	addi	r2,r2,-128
 324750c:	10800b90 	cmplti	r2,r2,46
 3247510:	1000071e 	bne	r2,zero,3247530 <parse_ipad+0x8c>
 3247514:	e0bffa17 	ldw	r2,-24(fp)
 3247518:	10800003 	ldbu	r2,0(r2)
 324751c:	10803fcc 	andi	r2,r2,255
 3247520:	1080201c 	xori	r2,r2,128
 3247524:	10bfe004 	addi	r2,r2,-128
 3247528:	10800bd8 	cmpnei	r2,r2,47
 324752c:	1000041e 	bne	r2,zero,3247540 <parse_ipad+0x9c>
         return("all chars must be digits (0-9) or dots (.)");
 3247530:	0080c974 	movhi	r2,805
 3247534:	10809b04 	addi	r2,r2,620
 3247538:	e0bfff15 	stw	r2,-4(fp)
 324753c:	00009a06 	br	32477a8 <parse_ipad+0x304>
      if (*cp == '.')dots++;
 3247540:	e0bffa17 	ldw	r2,-24(fp)
 3247544:	10800003 	ldbu	r2,0(r2)
 3247548:	10803fcc 	andi	r2,r2,255
 324754c:	1080201c 	xori	r2,r2,128
 3247550:	10bfe004 	addi	r2,r2,-128
 3247554:	10800b98 	cmpnei	r2,r2,46
 3247558:	1000031e 	bne	r2,zero,3247568 <parse_ipad+0xc4>
 324755c:	e0bff917 	ldw	r2,-28(fp)
 3247560:	10800044 	addi	r2,r2,1
 3247564:	e0bff915 	stw	r2,-28(fp)
         cp++;
 3247568:	e0bffa17 	ldw	r2,-24(fp)
 324756c:	10800044 	addi	r2,r2,1
 3247570:	e0bffa15 	stw	r2,-24(fp)
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";

   cp = stringin;
   while (*cp)
 3247574:	e0bffa17 	ldw	r2,-24(fp)
 3247578:	10800003 	ldbu	r2,0(r2)
 324757c:	10803fcc 	andi	r2,r2,255
 3247580:	1080201c 	xori	r2,r2,128
 3247584:	10bfe004 	addi	r2,r2,-128
 3247588:	1004c03a 	cmpne	r2,r2,zero
 324758c:	103fd31e 	bne	r2,zero,32474dc <parse_ipad+0x38>
         return("all chars must be digits (0-9) or dots (.)");
      if (*cp == '.')dots++;
         cp++;
   }

   if ( dots < 1 || dots > 3 )
 3247590:	e0bff917 	ldw	r2,-28(fp)
 3247594:	10800050 	cmplti	r2,r2,1
 3247598:	1000031e 	bne	r2,zero,32475a8 <parse_ipad+0x104>
 324759c:	e0bff917 	ldw	r2,-28(fp)
 32475a0:	10800110 	cmplti	r2,r2,4
 32475a4:	1000041e 	bne	r2,zero,32475b8 <parse_ipad+0x114>
      return("string must contain 1 - 3 dots (.)");
 32475a8:	0080c974 	movhi	r2,805
 32475ac:	1080a604 	addi	r2,r2,664
 32475b0:	e0bfff15 	stw	r2,-4(fp)
 32475b4:	00007c06 	br	32477a8 <parse_ipad+0x304>

   cp = stringin;
 32475b8:	e0bffe17 	ldw	r2,-8(fp)
 32475bc:	e0bffa15 	stw	r2,-24(fp)
   if ((number = atoi(cp)) > 255)   /* set net number */
 32475c0:	e13ffa17 	ldw	r4,-24(fp)
 32475c4:	324b8d40 	call	324b8d4 <atoi>
 32475c8:	e0bff815 	stw	r2,-32(fp)
 32475cc:	e0bff817 	ldw	r2,-32(fp)
 32475d0:	10804010 	cmplti	r2,r2,256
 32475d4:	1000031e 	bne	r2,zero,32475e4 <parse_ipad+0x140>
      return(toobig);
 32475d8:	e0bff717 	ldw	r2,-36(fp)
 32475dc:	e0bfff15 	stw	r2,-4(fp)
 32475e0:	00007106 	br	32477a8 <parse_ipad+0x304>

   retval.c[0] = (u_char)number;
 32475e4:	e0bff817 	ldw	r2,-32(fp)
 32475e8:	e0bffb05 	stb	r2,-20(fp)

   while (*cp != '.')cp++; /* find dot (end of number) */
 32475ec:	00000306 	br	32475fc <parse_ipad+0x158>
 32475f0:	e0bffa17 	ldw	r2,-24(fp)
 32475f4:	10800044 	addi	r2,r2,1
 32475f8:	e0bffa15 	stw	r2,-24(fp)
 32475fc:	e0bffa17 	ldw	r2,-24(fp)
 3247600:	10800003 	ldbu	r2,0(r2)
 3247604:	10803fcc 	andi	r2,r2,255
 3247608:	1080201c 	xori	r2,r2,128
 324760c:	10bfe004 	addi	r2,r2,-128
 3247610:	10800b98 	cmpnei	r2,r2,46
 3247614:	103ff61e 	bne	r2,zero,32475f0 <parse_ipad+0x14c>
      cp++;             /* point past dot */
 3247618:	e0bffa17 	ldw	r2,-24(fp)
 324761c:	10800044 	addi	r2,r2,1
 3247620:	e0bffa15 	stw	r2,-24(fp)

   if (dots == 1 || dots == 2) retval.c[1] = 0;
 3247624:	e0bff917 	ldw	r2,-28(fp)
 3247628:	10800060 	cmpeqi	r2,r2,1
 324762c:	1000031e 	bne	r2,zero,324763c <parse_ipad+0x198>
 3247630:	e0bff917 	ldw	r2,-28(fp)
 3247634:	10800098 	cmpnei	r2,r2,2
 3247638:	1000021e 	bne	r2,zero,3247644 <parse_ipad+0x1a0>
 324763c:	e03ffb45 	stb	zero,-19(fp)
 3247640:	00001906 	br	32476a8 <parse_ipad+0x204>
      else
   {
      number = atoi(cp);
 3247644:	e13ffa17 	ldw	r4,-24(fp)
 3247648:	324b8d40 	call	324b8d4 <atoi>
 324764c:	e0bff815 	stw	r2,-32(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 3247650:	00000306 	br	3247660 <parse_ipad+0x1bc>
 3247654:	e0bffa17 	ldw	r2,-24(fp)
 3247658:	10800044 	addi	r2,r2,1
 324765c:	e0bffa15 	stw	r2,-24(fp)
 3247660:	e0bffa17 	ldw	r2,-24(fp)
 3247664:	10800003 	ldbu	r2,0(r2)
 3247668:	10803fcc 	andi	r2,r2,255
 324766c:	1080201c 	xori	r2,r2,128
 3247670:	10bfe004 	addi	r2,r2,-128
 3247674:	10800b98 	cmpnei	r2,r2,46
 3247678:	103ff61e 	bne	r2,zero,3247654 <parse_ipad+0x1b0>
         cp++;             /* point past dot */
 324767c:	e0bffa17 	ldw	r2,-24(fp)
 3247680:	10800044 	addi	r2,r2,1
 3247684:	e0bffa15 	stw	r2,-24(fp)
      if (number > 255) return(toobig);
 3247688:	e0bff817 	ldw	r2,-32(fp)
 324768c:	10804010 	cmplti	r2,r2,256
 3247690:	1000031e 	bne	r2,zero,32476a0 <parse_ipad+0x1fc>
 3247694:	e0bff717 	ldw	r2,-36(fp)
 3247698:	e0bfff15 	stw	r2,-4(fp)
 324769c:	00004206 	br	32477a8 <parse_ipad+0x304>
         retval.c[1] = (u_char)number;
 32476a0:	e0bff817 	ldw	r2,-32(fp)
 32476a4:	e0bffb45 	stb	r2,-19(fp)
   }

   if (dots == 1) retval.c[2] = 0;
 32476a8:	e0bff917 	ldw	r2,-28(fp)
 32476ac:	10800058 	cmpnei	r2,r2,1
 32476b0:	1000021e 	bne	r2,zero,32476bc <parse_ipad+0x218>
 32476b4:	e03ffb85 	stb	zero,-18(fp)
 32476b8:	00001906 	br	3247720 <parse_ipad+0x27c>
      else
   {
      number = atoi(cp);
 32476bc:	e13ffa17 	ldw	r4,-24(fp)
 32476c0:	324b8d40 	call	324b8d4 <atoi>
 32476c4:	e0bff815 	stw	r2,-32(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 32476c8:	00000306 	br	32476d8 <parse_ipad+0x234>
 32476cc:	e0bffa17 	ldw	r2,-24(fp)
 32476d0:	10800044 	addi	r2,r2,1
 32476d4:	e0bffa15 	stw	r2,-24(fp)
 32476d8:	e0bffa17 	ldw	r2,-24(fp)
 32476dc:	10800003 	ldbu	r2,0(r2)
 32476e0:	10803fcc 	andi	r2,r2,255
 32476e4:	1080201c 	xori	r2,r2,128
 32476e8:	10bfe004 	addi	r2,r2,-128
 32476ec:	10800b98 	cmpnei	r2,r2,46
 32476f0:	103ff61e 	bne	r2,zero,32476cc <parse_ipad+0x228>
         cp++;             /* point past dot */
 32476f4:	e0bffa17 	ldw	r2,-24(fp)
 32476f8:	10800044 	addi	r2,r2,1
 32476fc:	e0bffa15 	stw	r2,-24(fp)
      if (number > 255) return(toobig);
 3247700:	e0bff817 	ldw	r2,-32(fp)
 3247704:	10804010 	cmplti	r2,r2,256
 3247708:	1000031e 	bne	r2,zero,3247718 <parse_ipad+0x274>
 324770c:	e0bff717 	ldw	r2,-36(fp)
 3247710:	e0bfff15 	stw	r2,-4(fp)
 3247714:	00002406 	br	32477a8 <parse_ipad+0x304>
         retval.c[2] = (u_char)number;
 3247718:	e0bff817 	ldw	r2,-32(fp)
 324771c:	e0bffb85 	stb	r2,-18(fp)
   }

   if ((number = atoi(cp)) > 255)
 3247720:	e13ffa17 	ldw	r4,-24(fp)
 3247724:	324b8d40 	call	324b8d4 <atoi>
 3247728:	e0bff815 	stw	r2,-32(fp)
 324772c:	e0bff817 	ldw	r2,-32(fp)
 3247730:	10804010 	cmplti	r2,r2,256
 3247734:	1000031e 	bne	r2,zero,3247744 <parse_ipad+0x2a0>
      return(toobig);
 3247738:	e0bff717 	ldw	r2,-36(fp)
 324773c:	e0bfff15 	stw	r2,-4(fp)
 3247740:	00001906 	br	32477a8 <parse_ipad+0x304>
   retval.c[3] = (u_char)number;
 3247744:	e0bff817 	ldw	r2,-32(fp)
 3247748:	e0bffbc5 	stb	r2,-17(fp)

   if (retval.c[0] < 128) *sbits = 8;
 324774c:	e0bffb03 	ldbu	r2,-20(fp)
 3247750:	10803fcc 	andi	r2,r2,255
 3247754:	10802028 	cmpgeui	r2,r2,128
 3247758:	1000041e 	bne	r2,zero,324776c <parse_ipad+0x2c8>
 324775c:	e0fffd17 	ldw	r3,-12(fp)
 3247760:	00800204 	movi	r2,8
 3247764:	18800015 	stw	r2,0(r3)
 3247768:	00000b06 	br	3247798 <parse_ipad+0x2f4>
      else if(retval.c[0] < 192) *sbits = 16;
 324776c:	e0bffb03 	ldbu	r2,-20(fp)
 3247770:	10803fcc 	andi	r2,r2,255
 3247774:	10803028 	cmpgeui	r2,r2,192
 3247778:	1000041e 	bne	r2,zero,324778c <parse_ipad+0x2e8>
 324777c:	e0fffd17 	ldw	r3,-12(fp)
 3247780:	00800404 	movi	r2,16
 3247784:	18800015 	stw	r2,0(r3)
 3247788:	00000306 	br	3247798 <parse_ipad+0x2f4>
      else *sbits = 24;
 324778c:	e0fffd17 	ldw	r3,-12(fp)
 3247790:	00800604 	movi	r2,24
 3247794:	18800015 	stw	r2,0(r3)

      *ipout = retval.l;      /* everything went OK, return number */
 3247798:	e0fffb17 	ldw	r3,-20(fp)
 324779c:	e0bffc17 	ldw	r2,-16(fp)
 32477a0:	10c00015 	stw	r3,0(r2)
   return(NULL);        /* return OK code (no error string) */
 32477a4:	e03fff15 	stw	zero,-4(fp)
 32477a8:	e0bfff17 	ldw	r2,-4(fp)
}
 32477ac:	e037883a 	mov	sp,fp
 32477b0:	dfc00117 	ldw	ra,4(sp)
 32477b4:	df000017 	ldw	fp,0(sp)
 32477b8:	dec00204 	addi	sp,sp,8
 32477bc:	f800283a 	ret

032477c0 <inet_addr>:
 * RETURNS: u_long ipaddr
 */

u_long 
inet_addr(char FAR * str)
{
 32477c0:	defffa04 	addi	sp,sp,-24
 32477c4:	dfc00515 	stw	ra,20(sp)
 32477c8:	df000415 	stw	fp,16(sp)
 32477cc:	df000404 	addi	fp,sp,16
 32477d0:	e13ffe15 	stw	r4,-8(fp)
    * we need to make the conversion. Usually this function will be 
    * used for debugging, so I think we can bear the STRCPY overhead.
    */
   static char nearBuf[30];

   strcpy((char FAR *)nearBuf,str);
 32477d4:	0100c974 	movhi	r4,805
 32477d8:	2114b204 	addi	r4,r4,21192
 32477dc:	e17ffe17 	ldw	r5,-8(fp)
 32477e0:	324b9d00 	call	324b9d0 <strcpy>
   if ( parse_ipad(&ipaddr,&bits,nearBuf) == NULL )
 32477e4:	e17ffd04 	addi	r5,fp,-12
 32477e8:	e13ffc04 	addi	r4,fp,-16
 32477ec:	0180c974 	movhi	r6,805
 32477f0:	3194b204 	addi	r6,r6,21192
 32477f4:	32474a40 	call	32474a4 <parse_ipad>
 32477f8:	1004c03a 	cmpne	r2,r2,zero
 32477fc:	1000031e 	bne	r2,zero,324780c <inet_addr+0x4c>
   {
      return ipaddr ;
 3247800:	e0bffc17 	ldw	r2,-16(fp)
 3247804:	e0bfff15 	stw	r2,-4(fp)
 3247808:	00000106 	br	3247810 <inet_addr+0x50>
   }
   else
   {
      return (u_long)NULL ;
 324780c:	e03fff15 	stw	zero,-4(fp)
 3247810:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 3247814:	e037883a 	mov	sp,fp
 3247818:	dfc00117 	ldw	ra,4(sp)
 324781c:	df000017 	ldw	fp,0(sp)
 3247820:	dec00204 	addi	sp,sp,8
 3247824:	f800283a 	ret

03247828 <hextoa>:
 * RETURNS: character 0-9 or A-F
 */

char
hextoa(int val)
{
 3247828:	defffd04 	addi	sp,sp,-12
 324782c:	df000215 	stw	fp,8(sp)
 3247830:	df000204 	addi	fp,sp,8
 3247834:	e13ffe15 	stw	r4,-8(fp)
   val &= 0x0f;
 3247838:	e0bffe17 	ldw	r2,-8(fp)
 324783c:	108003cc 	andi	r2,r2,15
 3247840:	e0bffe15 	stw	r2,-8(fp)
   if(val < 10)
 3247844:	e0bffe17 	ldw	r2,-8(fp)
 3247848:	10800288 	cmpgei	r2,r2,10
 324784c:	1000071e 	bne	r2,zero,324786c <hextoa+0x44>
      return (char)(val + '0');
 3247850:	e0bffe17 	ldw	r2,-8(fp)
 3247854:	10800c04 	addi	r2,r2,48
 3247858:	10803fcc 	andi	r2,r2,255
 324785c:	1080201c 	xori	r2,r2,128
 3247860:	10bfe004 	addi	r2,r2,-128
 3247864:	e0bfff15 	stw	r2,-4(fp)
 3247868:	00000606 	br	3247884 <hextoa+0x5c>
   else
      return (char)(val + 55);   /* converts 10-15 -> "A-F" */
 324786c:	e0bffe17 	ldw	r2,-8(fp)
 3247870:	10800dc4 	addi	r2,r2,55
 3247874:	10803fcc 	andi	r2,r2,255
 3247878:	1080201c 	xori	r2,r2,128
 324787c:	10bfe004 	addi	r2,r2,-128
 3247880:	e0bfff15 	stw	r2,-4(fp)
 3247884:	e0bfff17 	ldw	r2,-4(fp)
}
 3247888:	e037883a 	mov	sp,fp
 324788c:	df000017 	ldw	fp,0(sp)
 3247890:	dec00104 	addi	sp,sp,4
 3247894:	f800283a 	ret

03247898 <inet_pton>:

char * pton_error = "";

int
inet_pton(int af, const char * src, void * dst)
{
 3247898:	defff704 	addi	sp,sp,-36
 324789c:	dfc00815 	stw	ra,32(sp)
 32478a0:	df000715 	stw	fp,28(sp)
 32478a4:	df000704 	addi	fp,sp,28
 32478a8:	e13ffc15 	stw	r4,-16(fp)
 32478ac:	e17ffd15 	stw	r5,-12(fp)
 32478b0:	e1bffe15 	stw	r6,-8(fp)
   int            words;   /* count of words written to dest */
#endif

#if defined(IP_V4) || defined(MINI_IP)
   /* RFC 2133 wants us to support both types of address */
   if(af == AF_INET)    /* wants a v4 address */
 32478b4:	e0bffc17 	ldw	r2,-16(fp)
 32478b8:	10800098 	cmpnei	r2,r2,2
 32478bc:	10001a1e 	bne	r2,zero,3247928 <inet_pton+0x90>
   {
      u_long ip4addr;
      unsigned sbits;
      char * err;
      
      err = parse_ipad(&ip4addr, &sbits, (char *) src);
 32478c0:	e13ffa04 	addi	r4,fp,-24
 32478c4:	e17ffb04 	addi	r5,fp,-20
 32478c8:	e1bffd17 	ldw	r6,-12(fp)
 32478cc:	32474a40 	call	32474a4 <parse_ipad>
 32478d0:	e0bff915 	stw	r2,-28(fp)
      if(err == NULL)
 32478d4:	e0bff917 	ldw	r2,-28(fp)
 32478d8:	1004c03a 	cmpne	r2,r2,zero
 32478dc:	10000c1e 	bne	r2,zero,3247910 <inet_pton+0x78>
      {
         /* copy the parsed address into caller's buffer, and 
          * return success
          */
         MEMCPY(dst, &ip4addr, sizeof (u_long));
 32478e0:	e13ffe17 	ldw	r4,-8(fp)
 32478e4:	e0fffa04 	addi	r3,fp,-24
 32478e8:	18800003 	ldbu	r2,0(r3)
 32478ec:	20800005 	stb	r2,0(r4)
 32478f0:	18800043 	ldbu	r2,1(r3)
 32478f4:	20800045 	stb	r2,1(r4)
 32478f8:	18800083 	ldbu	r2,2(r3)
 32478fc:	20800085 	stb	r2,2(r4)
 3247900:	188000c3 	ldbu	r2,3(r3)
 3247904:	208000c5 	stb	r2,3(r4)
         return 0;
 3247908:	e03fff15 	stw	zero,-4(fp)
 324790c:	00000706 	br	324792c <inet_pton+0x94>
      }
      else
      {
         /* return failure */
         pton_error = "IPv4 address parse failure";
 3247910:	0080c974 	movhi	r2,805
 3247914:	1080b004 	addi	r2,r2,704
 3247918:	d0a05015 	stw	r2,-32448(gp)
         return 1;
 324791c:	00800044 	movi	r2,1
 3247920:	e0bfff15 	stw	r2,-4(fp)
 3247924:	00000106 	br	324792c <inet_pton+0x94>
      pton_error = "too short - missing colon?";
      return 1;
   }
   
#endif /* IP_V6 */   
   return 0;
 3247928:	e03fff15 	stw	zero,-4(fp)
 324792c:	e0bfff17 	ldw	r2,-4(fp)
}
 3247930:	e037883a 	mov	sp,fp
 3247934:	dfc00117 	ldw	ra,4(sp)
 3247938:	df000017 	ldw	fp,0(sp)
 324793c:	dec00204 	addi	sp,sp,8
 3247940:	f800283a 	ret

03247944 <inet_ntop>:
 * address output (40 bytes).
 */

const char *
inet_ntop(int af, const void *addr, char *str, size_t size)
{
 3247944:	defff704 	addi	sp,sp,-36
 3247948:	dfc00815 	stw	ra,32(sp)
 324794c:	df000715 	stw	fp,28(sp)
 3247950:	df000704 	addi	fp,sp,28
 3247954:	e13ffb15 	stw	r4,-20(fp)
 3247958:	e17ffc15 	stw	r5,-16(fp)
 324795c:	e1bffd15 	stw	r6,-12(fp)
 3247960:	e1fffe15 	stw	r7,-8(fp)
   char *cp;

#if defined(IP_V4) || defined(MINI_IP)
   if (af == AF_INET)
 3247964:	e0bffb17 	ldw	r2,-20(fp)
 3247968:	10800098 	cmpnei	r2,r2,2
 324796c:	1000111e 	bne	r2,zero,32479b4 <inet_ntop+0x70>
   {
      u_long   ip4addr;

      ip4addr = *(u_long*)addr;
 3247970:	e0bffc17 	ldw	r2,-16(fp)
 3247974:	10800017 	ldw	r2,0(r2)
 3247978:	e0bff915 	stw	r2,-28(fp)
      cp = print_ipad(ip4addr);
 324797c:	e13ff917 	ldw	r4,-28(fp)
 3247980:	3225c500 	call	3225c50 <print_ipad>
 3247984:	e0bffa15 	stw	r2,-24(fp)
      if (strlen(cp) < size)
 3247988:	e13ffa17 	ldw	r4,-24(fp)
 324798c:	32081440 	call	3208144 <strlen>
 3247990:	1007883a 	mov	r3,r2
 3247994:	e0bffe17 	ldw	r2,-8(fp)
 3247998:	1880062e 	bgeu	r3,r2,32479b4 <inet_ntop+0x70>
      {
         strcpy(str, cp);
 324799c:	e13ffd17 	ldw	r4,-12(fp)
 32479a0:	e17ffa17 	ldw	r5,-24(fp)
 32479a4:	324b9d00 	call	324b9d0 <strcpy>
         return (str);
 32479a8:	e0bffd17 	ldw	r2,-12(fp)
 32479ac:	e0bfff15 	stw	r2,-4(fp)
 32479b0:	00000106 	br	32479b8 <inet_ntop+0x74>
         return (str);
      }
   }
#endif

   return ((const char *)NULL);
 32479b4:	e03fff15 	stw	zero,-4(fp)
 32479b8:	e0bfff17 	ldw	r2,-4(fp)
}
 32479bc:	e037883a 	mov	sp,fp
 32479c0:	dfc00117 	ldw	ra,4(sp)
 32479c4:	df000017 	ldw	fp,0(sp)
 32479c8:	dec00204 	addi	sp,sp,8
 32479cc:	f800283a 	ret

032479d0 <print46_addr>:
 *
 * RETURNS: Pointer to string with the address in readable format.
 */

char * print46_addr(struct sockaddr *ipaddr)
{
 32479d0:	defffb04 	addi	sp,sp,-20
 32479d4:	dfc00415 	stw	ra,16(sp)
 32479d8:	df000315 	stw	fp,12(sp)
 32479dc:	df000304 	addi	fp,sp,12
 32479e0:	e13ffe15 	stw	r4,-8(fp)
   if (ipaddr->sa_family == AF_INET)
 32479e4:	e0bffe17 	ldw	r2,-8(fp)
 32479e8:	1080000b 	ldhu	r2,0(r2)
 32479ec:	10bfffcc 	andi	r2,r2,65535
 32479f0:	10800098 	cmpnei	r2,r2,2
 32479f4:	1000071e 	bne	r2,zero,3247a14 <print46_addr+0x44>
   {
      struct sockaddr_in * addr = (struct sockaddr_in *)ipaddr;
 32479f8:	e0bffe17 	ldw	r2,-8(fp)
 32479fc:	e0bffd15 	stw	r2,-12(fp)
      return print_ipad(addr->sin_addr.s_addr);
 3247a00:	e0bffd17 	ldw	r2,-12(fp)
 3247a04:	11000117 	ldw	r4,4(r2)
 3247a08:	3225c500 	call	3225c50 <print_ipad>
 3247a0c:	e0bfff15 	stw	r2,-4(fp)
 3247a10:	00000106 	br	3247a18 <print46_addr+0x48>
      static char namebuf[46];  /* max len of IPv6 addr */
      return (char *)inet_ntop(AF_INET6,&addr->sin6_addr, namebuf, sizeof(namebuf));
   }
#endif

   return NULL;
 3247a14:	e03fff15 	stw	zero,-4(fp)
 3247a18:	e0bfff17 	ldw	r2,-4(fp)
}
 3247a1c:	e037883a 	mov	sp,fp
 3247a20:	dfc00117 	ldw	ra,4(sp)
 3247a24:	df000017 	ldw	fp,0(sp)
 3247a28:	dec00204 	addi	sp,sp,8
 3247a2c:	f800283a 	ret

03247a30 <inet46_addr>:
 *
 */

int 
inet46_addr(char * str, struct sockaddr *address)
{
 3247a30:	defffb04 	addi	sp,sp,-20
 3247a34:	dfc00415 	stw	ra,16(sp)
 3247a38:	df000315 	stw	fp,12(sp)
 3247a3c:	df000304 	addi	fp,sp,12
 3247a40:	e13ffe15 	stw	r4,-8(fp)
 3247a44:	e17fff15 	stw	r5,-4(fp)
   /* Read the IPv4/IPv6 address */
   address->sa_family = AF_INET; /* assume IPv4 address by default */
 3247a48:	e0ffff17 	ldw	r3,-4(fp)
 3247a4c:	00800084 	movi	r2,2
 3247a50:	1880000d 	sth	r2,0(r3)

   if ((str[1] == '.') || (str[2] == '.') || (str[3] == '.'))
 3247a54:	e0bffe17 	ldw	r2,-8(fp)
 3247a58:	10800044 	addi	r2,r2,1
 3247a5c:	10800003 	ldbu	r2,0(r2)
 3247a60:	10803fcc 	andi	r2,r2,255
 3247a64:	1080201c 	xori	r2,r2,128
 3247a68:	10bfe004 	addi	r2,r2,-128
 3247a6c:	10800ba0 	cmpeqi	r2,r2,46
 3247a70:	1000101e 	bne	r2,zero,3247ab4 <inet46_addr+0x84>
 3247a74:	e0bffe17 	ldw	r2,-8(fp)
 3247a78:	10800084 	addi	r2,r2,2
 3247a7c:	10800003 	ldbu	r2,0(r2)
 3247a80:	10803fcc 	andi	r2,r2,255
 3247a84:	1080201c 	xori	r2,r2,128
 3247a88:	10bfe004 	addi	r2,r2,-128
 3247a8c:	10800ba0 	cmpeqi	r2,r2,46
 3247a90:	1000081e 	bne	r2,zero,3247ab4 <inet46_addr+0x84>
 3247a94:	e0bffe17 	ldw	r2,-8(fp)
 3247a98:	108000c4 	addi	r2,r2,3
 3247a9c:	10800003 	ldbu	r2,0(r2)
 3247aa0:	10803fcc 	andi	r2,r2,255
 3247aa4:	1080201c 	xori	r2,r2,128
 3247aa8:	10bfe004 	addi	r2,r2,-128
 3247aac:	10800b98 	cmpnei	r2,r2,46
 3247ab0:	10000a1e 	bne	r2,zero,3247adc <inet46_addr+0xac>
   {
      struct sockaddr_in *addr = (struct sockaddr_in *)address;
 3247ab4:	e0bfff17 	ldw	r2,-4(fp)
 3247ab8:	e0bffd15 	stw	r2,-12(fp)
      addr->sin_addr.s_addr = inet_addr(str);
 3247abc:	e13ffe17 	ldw	r4,-8(fp)
 3247ac0:	32477c00 	call	32477c0 <inet_addr>
 3247ac4:	1007883a 	mov	r3,r2
 3247ac8:	e0bffd17 	ldw	r2,-12(fp)
 3247acc:	10c00115 	stw	r3,4(r2)
      addr->sin_family = AF_INET;
 3247ad0:	e0fffd17 	ldw	r3,-12(fp)
 3247ad4:	00800084 	movi	r2,2
 3247ad8:	1880000d 	sth	r2,0(r3)
      inet_pton(AF_INET6, str, &addr->sin6_addr);
      addr->sin6_family = AF_INET6;
   }
#endif

   return 0;
 3247adc:	0005883a 	mov	r2,zero
}
 3247ae0:	e037883a 	mov	sp,fp
 3247ae4:	dfc00117 	ldw	ra,4(sp)
 3247ae8:	df000017 	ldw	fp,0(sp)
 3247aec:	dec00204 	addi	sp,sp,8
 3247af0:	f800283a 	ret

03247af4 <inet_setport>:
 *
 * RETURNS: -
 */

void inet_setport(struct sockaddr *addr,int port) 
{
 3247af4:	defffc04 	addi	sp,sp,-16
 3247af8:	df000315 	stw	fp,12(sp)
 3247afc:	df000304 	addi	fp,sp,12
 3247b00:	e13ffe15 	stw	r4,-8(fp)
 3247b04:	e17fff15 	stw	r5,-4(fp)
   if (addr->sa_family == AF_INET)
 3247b08:	e0bffe17 	ldw	r2,-8(fp)
 3247b0c:	1080000b 	ldhu	r2,0(r2)
 3247b10:	10bfffcc 	andi	r2,r2,65535
 3247b14:	10800098 	cmpnei	r2,r2,2
 3247b18:	10000f1e 	bne	r2,zero,3247b58 <inet_setport+0x64>
   {
      struct sockaddr_in *si = (struct sockaddr_in *)addr;
 3247b1c:	e0bffe17 	ldw	r2,-8(fp)
 3247b20:	e0bffd15 	stw	r2,-12(fp)
      si->sin_port = htons(port);  
 3247b24:	e0bfff17 	ldw	r2,-4(fp)
 3247b28:	1005d23a 	srai	r2,r2,8
 3247b2c:	10803fcc 	andi	r2,r2,255
 3247b30:	1009883a 	mov	r4,r2
 3247b34:	e0bfff17 	ldw	r2,-4(fp)
 3247b38:	1004923a 	slli	r2,r2,8
 3247b3c:	1007883a 	mov	r3,r2
 3247b40:	00bfc004 	movi	r2,-256
 3247b44:	1884703a 	and	r2,r3,r2
 3247b48:	2084b03a 	or	r2,r4,r2
 3247b4c:	1007883a 	mov	r3,r2
 3247b50:	e0bffd17 	ldw	r2,-12(fp)
 3247b54:	10c0008d 	sth	r3,2(r2)
      struct sockaddr_in6 *si = (struct sockaddr_in6 *)addr;
      si->sin6_port = htons(port);
   }
#endif

}
 3247b58:	e037883a 	mov	sp,fp
 3247b5c:	df000017 	ldw	fp,0(sp)
 3247b60:	dec00104 	addi	sp,sp,4
 3247b64:	f800283a 	ret

03247b68 <convert_ip>:
 *Returns:
 *
 */

unsigned long convert_ip(const char *p)
{
 3247b68:	defff804 	addi	sp,sp,-32
 3247b6c:	df000715 	stw	fp,28(sp)
 3247b70:	df000704 	addi	fp,sp,28
 3247b74:	e13ffe15 	stw	r4,-8(fp)
   const char *cp = p;
 3247b78:	e0bffe17 	ldw	r2,-8(fp)
 3247b7c:	e0bffc15 	stw	r2,-16(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
 3247b80:	e0bffd04 	addi	r2,fp,-12
 3247b84:	e0bffb15 	stw	r2,-20(fp)
   int n = 0;
 3247b88:	e03ffa15 	stw	zero,-24(fp)
   unsigned short v = 0;
 3247b8c:	e03ff90d 	sth	zero,-28(fp)
   dw = 0;
 3247b90:	e03ffd15 	stw	zero,-12(fp)
   while(*cp)
 3247b94:	00003306 	br	3247c64 <convert_ip+0xfc>
   {
      if( *cp == '.')
 3247b98:	e0bffc17 	ldw	r2,-16(fp)
 3247b9c:	10800003 	ldbu	r2,0(r2)
 3247ba0:	10803fcc 	andi	r2,r2,255
 3247ba4:	1080201c 	xori	r2,r2,128
 3247ba8:	10bfe004 	addi	r2,r2,-128
 3247bac:	10800b98 	cmpnei	r2,r2,46
 3247bb0:	1000101e 	bne	r2,zero,3247bf4 <convert_ip+0x8c>
      {
         lpb[n] = (unsigned char) v;
 3247bb4:	e0bffa17 	ldw	r2,-24(fp)
 3247bb8:	1007883a 	mov	r3,r2
 3247bbc:	e0bffb17 	ldw	r2,-20(fp)
 3247bc0:	1887883a 	add	r3,r3,r2
 3247bc4:	e0bff90b 	ldhu	r2,-28(fp)
 3247bc8:	18800005 	stb	r2,0(r3)
         v = 0;
 3247bcc:	e03ff90d 	sth	zero,-28(fp)
         n++;
 3247bd0:	e0bffa17 	ldw	r2,-24(fp)
 3247bd4:	10800044 	addi	r2,r2,1
 3247bd8:	e0bffa15 	stw	r2,-24(fp)
         if(n > 3)
 3247bdc:	e0bffa17 	ldw	r2,-24(fp)
 3247be0:	10800110 	cmplti	r2,r2,4
 3247be4:	10001c1e 	bne	r2,zero,3247c58 <convert_ip+0xf0>
         {
            return dw;
 3247be8:	e0bffd17 	ldw	r2,-12(fp)
 3247bec:	e0bfff15 	stw	r2,-4(fp)
 3247bf0:	00002b06 	br	3247ca0 <convert_ip+0x138>
         }
      }
      else if(((*cp >= '0') && (*cp <= '9')))
 3247bf4:	e0bffc17 	ldw	r2,-16(fp)
 3247bf8:	10800003 	ldbu	r2,0(r2)
 3247bfc:	10803fcc 	andi	r2,r2,255
 3247c00:	1080201c 	xori	r2,r2,128
 3247c04:	10bfe004 	addi	r2,r2,-128
 3247c08:	10800c10 	cmplti	r2,r2,48
 3247c0c:	1000121e 	bne	r2,zero,3247c58 <convert_ip+0xf0>
 3247c10:	e0bffc17 	ldw	r2,-16(fp)
 3247c14:	10800003 	ldbu	r2,0(r2)
 3247c18:	10803fcc 	andi	r2,r2,255
 3247c1c:	1080201c 	xori	r2,r2,128
 3247c20:	10bfe004 	addi	r2,r2,-128
 3247c24:	10800e88 	cmpgei	r2,r2,58
 3247c28:	10000b1e 	bne	r2,zero,3247c58 <convert_ip+0xf0>
      {
         v = (v * 10) + (*cp - '0');
 3247c2c:	e0bff90b 	ldhu	r2,-28(fp)
 3247c30:	108002a4 	muli	r2,r2,10
 3247c34:	1007883a 	mov	r3,r2
 3247c38:	e0bffc17 	ldw	r2,-16(fp)
 3247c3c:	10800003 	ldbu	r2,0(r2)
 3247c40:	10803fcc 	andi	r2,r2,255
 3247c44:	1080201c 	xori	r2,r2,128
 3247c48:	10bfe004 	addi	r2,r2,-128
 3247c4c:	1885883a 	add	r2,r3,r2
 3247c50:	10bff404 	addi	r2,r2,-48
 3247c54:	e0bff90d 	sth	r2,-28(fp)
      }
      cp++;
 3247c58:	e0bffc17 	ldw	r2,-16(fp)
 3247c5c:	10800044 	addi	r2,r2,1
 3247c60:	e0bffc15 	stw	r2,-16(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
   int n = 0;
   unsigned short v = 0;
   dw = 0;
   while(*cp)
 3247c64:	e0bffc17 	ldw	r2,-16(fp)
 3247c68:	10800003 	ldbu	r2,0(r2)
 3247c6c:	10803fcc 	andi	r2,r2,255
 3247c70:	1080201c 	xori	r2,r2,128
 3247c74:	10bfe004 	addi	r2,r2,-128
 3247c78:	1004c03a 	cmpne	r2,r2,zero
 3247c7c:	103fc61e 	bne	r2,zero,3247b98 <convert_ip+0x30>
      {
         v = (v * 10) + (*cp - '0');
      }
      cp++;
   }
   lpb[n] = (unsigned char) v;
 3247c80:	e0bffa17 	ldw	r2,-24(fp)
 3247c84:	1007883a 	mov	r3,r2
 3247c88:	e0bffb17 	ldw	r2,-20(fp)
 3247c8c:	1887883a 	add	r3,r3,r2
 3247c90:	e0bff90b 	ldhu	r2,-28(fp)
 3247c94:	18800005 	stb	r2,0(r3)
   return dw;
 3247c98:	e0bffd17 	ldw	r2,-12(fp)
 3247c9c:	e0bfff15 	stw	r2,-4(fp)
 3247ca0:	e0bfff17 	ldw	r2,-4(fp)
}  /* convert_ip() */
 3247ca4:	e037883a 	mov	sp,fp
 3247ca8:	df000017 	ldw	fp,0(sp)
 3247cac:	dec00104 	addi	sp,sp,4
 3247cb0:	f800283a 	ret

03247cb4 <tcp_cksum>:
 * RETURNS: 
 */

unshort
tcp_cksum(struct ip * pip)
{
 3247cb4:	defff804 	addi	sp,sp,-32
 3247cb8:	dfc00715 	stw	ra,28(sp)
 3247cbc:	df000615 	stw	fp,24(sp)
 3247cc0:	df000604 	addi	fp,sp,24
 3247cc4:	e13fff15 	stw	r4,-4(fp)
   unshort  oldsum;
   unshort  newsum;
   struct tcphdr * tp;

#ifdef MUTE_WARNS    /* stifle compiler warnings */
   tcpdata = (char *)NULL;
 3247cc8:	e03ffd15 	stw	zero,-12(fp)
#endif   /* MUTE_WARNS */

   IN_PROFILER(PF_TSUM, PF_ENTRY);

   oddchar = 0;
 3247ccc:	e03ffc05 	stb	zero,-16(fp)

   iphlen = (unshort)ip_hlen(pip);
 3247cd0:	e0bfff17 	ldw	r2,-4(fp)
 3247cd4:	10800003 	ldbu	r2,0(r2)
 3247cd8:	10803fcc 	andi	r2,r2,255
 3247cdc:	108003cc 	andi	r2,r2,15
 3247ce0:	1085883a 	add	r2,r2,r2
 3247ce4:	1085883a 	add	r2,r2,r2
 3247ce8:	e0bffe8d 	sth	r2,-6(fp)
   tcplen = htons(pip->ip_len) - iphlen;
 3247cec:	e0bfff17 	ldw	r2,-4(fp)
 3247cf0:	1080008b 	ldhu	r2,2(r2)
 3247cf4:	10bfffcc 	andi	r2,r2,65535
 3247cf8:	1004d23a 	srli	r2,r2,8
 3247cfc:	10803fcc 	andi	r2,r2,255
 3247d00:	1009883a 	mov	r4,r2
 3247d04:	e0bfff17 	ldw	r2,-4(fp)
 3247d08:	1080008b 	ldhu	r2,2(r2)
 3247d0c:	10bfffcc 	andi	r2,r2,65535
 3247d10:	1004923a 	slli	r2,r2,8
 3247d14:	1007883a 	mov	r3,r2
 3247d18:	00bfc004 	movi	r2,-256
 3247d1c:	1884703a 	and	r2,r3,r2
 3247d20:	2084b03a 	or	r2,r4,r2
 3247d24:	1007883a 	mov	r3,r2
 3247d28:	e0bffe8b 	ldhu	r2,-6(fp)
 3247d2c:	1885c83a 	sub	r2,r3,r2
 3247d30:	e0bffe0d 	sth	r2,-8(fp)

   tp = (struct tcphdr*)ip_data(pip);     /* get TCP header */
 3247d34:	e0bfff17 	ldw	r2,-4(fp)
 3247d38:	10800003 	ldbu	r2,0(r2)
 3247d3c:	10803fcc 	andi	r2,r2,255
 3247d40:	108003cc 	andi	r2,r2,15
 3247d44:	1085883a 	add	r2,r2,r2
 3247d48:	1085883a 	add	r2,r2,r2
 3247d4c:	1007883a 	mov	r3,r2
 3247d50:	e0bfff17 	ldw	r2,-4(fp)
 3247d54:	1885883a 	add	r2,r3,r2
 3247d58:	e0bffa15 	stw	r2,-24(fp)
   oldsum = tp->th_sum;       /* Save passed checksum */
 3247d5c:	e0bffa17 	ldw	r2,-24(fp)
 3247d60:	1080040b 	ldhu	r2,16(r2)
 3247d64:	e0bffb8d 	sth	r2,-18(fp)
    * cannot overflow a 16 bit field) and put them in the cksum field. 
    * We include the IP addresses by passing them to the lower level 
    * fast sum routine. This results in their values being factored into 
    * the sum and the cksum field contributes zero.
    */
   tp->th_sum = htons(tcplen + 6);
 3247d68:	e0bffe0b 	ldhu	r2,-8(fp)
 3247d6c:	10800184 	addi	r2,r2,6
 3247d70:	1005d23a 	srai	r2,r2,8
 3247d74:	10803fcc 	andi	r2,r2,255
 3247d78:	1009883a 	mov	r4,r2
 3247d7c:	e0bffe0b 	ldhu	r2,-8(fp)
 3247d80:	10800184 	addi	r2,r2,6
 3247d84:	1004923a 	slli	r2,r2,8
 3247d88:	1007883a 	mov	r3,r2
 3247d8c:	00bfc004 	movi	r2,-256
 3247d90:	1884703a 	and	r2,r3,r2
 3247d94:	2084b03a 	or	r2,r4,r2
 3247d98:	1007883a 	mov	r3,r2
 3247d9c:	e0bffa17 	ldw	r2,-24(fp)
 3247da0:	10c0040d 	sth	r3,16(r2)

   /* zero pad odd sized packets for checksumming */
   if (tcplen & 1)   
 3247da4:	e0bffe0b 	ldhu	r2,-8(fp)
 3247da8:	1080004c 	andi	r2,r2,1
 3247dac:	10803fcc 	andi	r2,r2,255
 3247db0:	1005003a 	cmpeq	r2,r2,zero
 3247db4:	10000f1e 	bne	r2,zero,3247df4 <tcp_cksum+0x140>
   {
      tcpdata = ((char*)pip) + iphlen + tcplen;    /* end of packet */
 3247db8:	e0bffe8b 	ldhu	r2,-6(fp)
 3247dbc:	1007883a 	mov	r3,r2
 3247dc0:	e0bfff17 	ldw	r2,-4(fp)
 3247dc4:	1887883a 	add	r3,r3,r2
 3247dc8:	e0bffe0b 	ldhu	r2,-8(fp)
 3247dcc:	1885883a 	add	r2,r3,r2
 3247dd0:	e0bffd15 	stw	r2,-12(fp)
      oddchar = *tcpdata;
 3247dd4:	e0bffd17 	ldw	r2,-12(fp)
 3247dd8:	10800003 	ldbu	r2,0(r2)
 3247ddc:	e0bffc05 	stb	r2,-16(fp)
      *tcpdata = '\0';        /* zero out pad byte */
 3247de0:	e0bffd17 	ldw	r2,-12(fp)
 3247de4:	10000005 	stb	zero,0(r2)
      tcplen++;               /* bump length to pass to cksum() */
 3247de8:	e0bffe0b 	ldhu	r2,-8(fp)
 3247dec:	10800044 	addi	r2,r2,1
 3247df0:	e0bffe0d 	sth	r2,-8(fp)

   /* Pass a pointer to the beginning of the IP address area into the IP header
    * the the low level sum routine. Add the size of these two IP addresses to
    * the length, and convert the length to 16 bit words.
    */
   newsum = ~cksum(((char*)tp) - 8, (tcplen + 8) >> 1);
 3247df4:	e0bffa17 	ldw	r2,-24(fp)
 3247df8:	113ffe04 	addi	r4,r2,-8
 3247dfc:	e0bffe0b 	ldhu	r2,-8(fp)
 3247e00:	10800204 	addi	r2,r2,8
 3247e04:	1005d07a 	srai	r2,r2,1
 3247e08:	100b883a 	mov	r5,r2
 3247e0c:	32259f80 	call	32259f8 <cksum>
 3247e10:	0084303a 	nor	r2,zero,r2
 3247e14:	e0bffb0d 	sth	r2,-20(fp)

   /* If the old checksum is 0xffff, but the actual checksum is 0x0000,
    * declare that to be a match.
    */
   if ((newsum != oldsum) && (oldsum == 0xffff) && (newsum == 0x0000))
 3247e18:	e0fffb0b 	ldhu	r3,-20(fp)
 3247e1c:	e0bffb8b 	ldhu	r2,-18(fp)
 3247e20:	18800826 	beq	r3,r2,3247e44 <tcp_cksum+0x190>
 3247e24:	e0fffb8b 	ldhu	r3,-18(fp)
 3247e28:	00bfffd4 	movui	r2,65535
 3247e2c:	1880051e 	bne	r3,r2,3247e44 <tcp_cksum+0x190>
 3247e30:	e0bffb0b 	ldhu	r2,-20(fp)
 3247e34:	1004c03a 	cmpne	r2,r2,zero
 3247e38:	1000021e 	bne	r2,zero,3247e44 <tcp_cksum+0x190>
      newsum = 0xffff;
 3247e3c:	00bfffc4 	movi	r2,-1
 3247e40:	e0bffb0d 	sth	r2,-20(fp)

   /* restore what we clobbered */
   tp->th_sum = oldsum;       /* put back passed checksum */
 3247e44:	e0fffa17 	ldw	r3,-24(fp)
 3247e48:	e0bffb8b 	ldhu	r2,-18(fp)
 3247e4c:	1880040d 	sth	r2,16(r3)
   if (oddchar)
 3247e50:	e0bffc07 	ldb	r2,-16(fp)
 3247e54:	1005003a 	cmpeq	r2,r2,zero
 3247e58:	1000031e 	bne	r2,zero,3247e68 <tcp_cksum+0x1b4>
      *tcpdata = oddchar;     /* restore odd byte if we zeroed it */
 3247e5c:	e0fffd17 	ldw	r3,-12(fp)
 3247e60:	e0bffc03 	ldbu	r2,-16(fp)
 3247e64:	18800005 	stb	r2,0(r3)

   IN_PROFILER(PF_TSUM, PF_EXIT);

   return newsum;
 3247e68:	e0bffb0b 	ldhu	r2,-20(fp)
}
 3247e6c:	e037883a 	mov	sp,fp
 3247e70:	dfc00117 	ldw	ra,4(sp)
 3247e74:	df000017 	ldw	fp,0(sp)
 3247e78:	dec00204 	addi	sp,sp,8
 3247e7c:	f800283a 	ret

03247e80 <in_pcballoc>:
 */

int
in_pcballoc(struct socket * so, 
   struct inpcb * head)
{
 3247e80:	defffa04 	addi	sp,sp,-24
 3247e84:	dfc00515 	stw	ra,20(sp)
 3247e88:	df000415 	stw	fp,16(sp)
 3247e8c:	df000404 	addi	fp,sp,16
 3247e90:	e13ffd15 	stw	r4,-12(fp)
 3247e94:	e17ffe15 	stw	r5,-8(fp)
   struct inpcb * inp;

   inp = INP_ALLOC (sizeof (*inp));
 3247e98:	01000b04 	movi	r4,44
 3247e9c:	322b5d00 	call	322b5d0 <npalloc>
 3247ea0:	e0bffc15 	stw	r2,-16(fp)
   if (inp == 0)
 3247ea4:	e0bffc17 	ldw	r2,-16(fp)
 3247ea8:	1004c03a 	cmpne	r2,r2,zero
 3247eac:	1000031e 	bne	r2,zero,3247ebc <in_pcballoc+0x3c>
      return ENOMEM;
 3247eb0:	00800304 	movi	r2,12
 3247eb4:	e0bfff15 	stw	r2,-4(fp)
 3247eb8:	00001006 	br	3247efc <in_pcballoc+0x7c>
   inp->inp_head = head;
 3247ebc:	e0fffc17 	ldw	r3,-16(fp)
 3247ec0:	e0bffe17 	ldw	r2,-8(fp)
 3247ec4:	18800215 	stw	r2,8(r3)
   inp->inp_socket = so;
 3247ec8:	e0fffc17 	ldw	r3,-16(fp)
 3247ecc:	e0bffd17 	ldw	r2,-12(fp)
 3247ed0:	18800815 	stw	r2,32(r3)

   /* Set Path MTU to a very small default. It should get expanded 
    * later by v4 or v6 specific SYN code. We don't want it zero 
    * in case it doesn't get expanded promptly.
    */
   inp->inp_pmtu = 512;
 3247ed4:	e0fffc17 	ldw	r3,-16(fp)
 3247ed8:	00808004 	movi	r2,512
 3247edc:	18800615 	stw	r2,24(r3)
   insque(inp, head);
 3247ee0:	e13ffc17 	ldw	r4,-16(fp)
 3247ee4:	e17ffe17 	ldw	r5,-8(fp)
 3247ee8:	322c3100 	call	322c310 <insque>
   so->so_pcb = inp;
 3247eec:	e0fffd17 	ldw	r3,-12(fp)
 3247ef0:	e0bffc17 	ldw	r2,-16(fp)
 3247ef4:	18800115 	stw	r2,4(r3)
   return 0;
 3247ef8:	e03fff15 	stw	zero,-4(fp)
 3247efc:	e0bfff17 	ldw	r2,-4(fp)
}
 3247f00:	e037883a 	mov	sp,fp
 3247f04:	dfc00117 	ldw	ra,4(sp)
 3247f08:	df000017 	ldw	fp,0(sp)
 3247f0c:	dec00204 	addi	sp,sp,8
 3247f10:	f800283a 	ret

03247f14 <in_pcbdetach>:
 * RETURNS: 
 */

void
in_pcbdetach(struct inpcb * inp)
{
 3247f14:	defffc04 	addi	sp,sp,-16
 3247f18:	dfc00315 	stw	ra,12(sp)
 3247f1c:	df000215 	stw	fp,8(sp)
 3247f20:	df000204 	addi	fp,sp,8
 3247f24:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  inp->inp_socket;
 3247f28:	e0bfff17 	ldw	r2,-4(fp)
 3247f2c:	10800817 	ldw	r2,32(r2)
 3247f30:	e0bffe15 	stw	r2,-8(fp)

   so->so_pcb = 0;
 3247f34:	e0bffe17 	ldw	r2,-8(fp)
 3247f38:	10000115 	stw	zero,4(r2)
   sofree(so);
 3247f3c:	e13ffe17 	ldw	r4,-8(fp)
 3247f40:	322f6d80 	call	322f6d8 <sofree>
   remque(inp);
 3247f44:	e13fff17 	ldw	r4,-4(fp)
 3247f48:	322c2a00 	call	322c2a0 <remque>
   INP_FREE (inp);
 3247f4c:	e13fff17 	ldw	r4,-4(fp)
 3247f50:	322b6c40 	call	322b6c4 <npfree>
}
 3247f54:	e037883a 	mov	sp,fp
 3247f58:	dfc00117 	ldw	ra,4(sp)
 3247f5c:	df000017 	ldw	fp,0(sp)
 3247f60:	dec00204 	addi	sp,sp,8
 3247f64:	f800283a 	ret

03247f68 <in_pcbbind>:

int
in_pcbbind(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 3247f68:	defff404 	addi	sp,sp,-48
 3247f6c:	dfc00b15 	stw	ra,44(sp)
 3247f70:	df000a15 	stw	fp,40(sp)
 3247f74:	df000a04 	addi	fp,sp,40
 3247f78:	e13ffd15 	stw	r4,-12(fp)
 3247f7c:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so =  inp->inp_socket;
 3247f80:	e0bffd17 	ldw	r2,-12(fp)
 3247f84:	10800817 	ldw	r2,32(r2)
 3247f88:	e0bffc15 	stw	r2,-16(fp)
   struct inpcb * head  =  inp->inp_head;
 3247f8c:	e0bffd17 	ldw	r2,-12(fp)
 3247f90:	10800217 	ldw	r2,8(r2)
 3247f94:	e0bffb15 	stw	r2,-20(fp)
   struct sockaddr_in * sin;
   u_short  lport =  0;
 3247f98:	e03ff90d 	sth	zero,-28(fp)


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
 3247f9c:	e0bffd17 	ldw	r2,-12(fp)
 3247fa0:	1080078b 	ldhu	r2,30(r2)
 3247fa4:	10bfffcc 	andi	r2,r2,65535
 3247fa8:	1004c03a 	cmpne	r2,r2,zero
 3247fac:	1000041e 	bne	r2,zero,3247fc0 <in_pcbbind+0x58>
 3247fb0:	e0bffd17 	ldw	r2,-12(fp)
 3247fb4:	10800417 	ldw	r2,16(r2)
 3247fb8:	1005003a 	cmpeq	r2,r2,zero
 3247fbc:	1000031e 	bne	r2,zero,3247fcc <in_pcbbind+0x64>
      return (EINVAL);
 3247fc0:	00800584 	movi	r2,22
 3247fc4:	e0bfff15 	stw	r2,-4(fp)
 3247fc8:	00007606 	br	32481a4 <in_pcbbind+0x23c>
   if (nam == 0)
 3247fcc:	e0bffe17 	ldw	r2,-8(fp)
 3247fd0:	1005003a 	cmpeq	r2,r2,zero
 3247fd4:	10003e1e 	bne	r2,zero,32480d0 <in_pcbbind+0x168>
      goto noname;
   sin = mtod(nam, struct sockaddr_in *);
 3247fd8:	e0bffe17 	ldw	r2,-8(fp)
 3247fdc:	10800317 	ldw	r2,12(r2)
 3247fe0:	e0bffa15 	stw	r2,-24(fp)
   /*
    * removed test here for "if (nam->m_len != sizeof (*sin))"
    * since it really complicatges supporting dual IPv4/v6, and 
    * the 2.0 stack now checks this in t_bind(). -JB-
    */
   if (sin->sin_addr.s_addr != INADDR_ANY) 
 3247fe4:	e0bffa17 	ldw	r2,-24(fp)
 3247fe8:	10800117 	ldw	r2,4(r2)
 3247fec:	1005003a 	cmpeq	r2,r2,zero
 3247ff0:	10000a1e 	bne	r2,zero,324801c <in_pcbbind+0xb4>
   {
      if (ip_mymach(sin->sin_addr.s_addr) != sin->sin_addr.s_addr)
 3247ff4:	e0bffa17 	ldw	r2,-24(fp)
 3247ff8:	11000117 	ldw	r4,4(r2)
 3247ffc:	324018c0 	call	324018c <ip_mymach>
 3248000:	1007883a 	mov	r3,r2
 3248004:	e0bffa17 	ldw	r2,-24(fp)
 3248008:	10800117 	ldw	r2,4(r2)
 324800c:	18800326 	beq	r3,r2,324801c <in_pcbbind+0xb4>
      return (EADDRNOTAVAIL);
 3248010:	00801f44 	movi	r2,125
 3248014:	e0bfff15 	stw	r2,-4(fp)
 3248018:	00006206 	br	32481a4 <in_pcbbind+0x23c>
   }
   lport = sin->sin_port;
 324801c:	e0bffa17 	ldw	r2,-24(fp)
 3248020:	1080008b 	ldhu	r2,2(r2)
 3248024:	e0bff90d 	sth	r2,-28(fp)
   if (lport) 
 3248028:	e0bff90b 	ldhu	r2,-28(fp)
 324802c:	1005003a 	cmpeq	r2,r2,zero
 3248030:	1000231e 	bne	r2,zero,32480c0 <in_pcbbind+0x158>
   {
      int   wild  =  0;
 3248034:	e03ff815 	stw	zero,-32(fp)

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 3248038:	e0bffc17 	ldw	r2,-16(fp)
 324803c:	10800417 	ldw	r2,16(r2)
 3248040:	1080010c 	andi	r2,r2,4
 3248044:	1004c03a 	cmpne	r2,r2,zero
 3248048:	10000e1e 	bne	r2,zero,3248084 <in_pcbbind+0x11c>
 324804c:	e0bffc17 	ldw	r2,-16(fp)
 3248050:	10800217 	ldw	r2,8(r2)
 3248054:	1080010b 	ldhu	r2,4(r2)
 3248058:	10bfffcc 	andi	r2,r2,65535
 324805c:	1080010c 	andi	r2,r2,4
 3248060:	1005003a 	cmpeq	r2,r2,zero
 3248064:	1000051e 	bne	r2,zero,324807c <in_pcbbind+0x114>
 3248068:	e0bffc17 	ldw	r2,-16(fp)
 324806c:	10800417 	ldw	r2,16(r2)
 3248070:	1080008c 	andi	r2,r2,2
 3248074:	1004c03a 	cmpne	r2,r2,zero
 3248078:	1000021e 	bne	r2,zero,3248084 <in_pcbbind+0x11c>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
          (so->so_options & SO_ACCEPTCONN) == 0))
      {
         wild = INPLOOKUP_WILDCARD;
 324807c:	00800044 	movi	r2,1
 3248080:	e0bff815 	stw	r2,-32(fp)
      }
      if (in_pcblookup(head,
 3248084:	e0bffa17 	ldw	r2,-24(fp)
 3248088:	11c00117 	ldw	r7,4(r2)
 324808c:	e0bff90b 	ldhu	r2,-28(fp)
 3248090:	d8800015 	stw	r2,0(sp)
 3248094:	e0bff817 	ldw	r2,-32(fp)
 3248098:	d8800115 	stw	r2,4(sp)
 324809c:	e13ffb17 	ldw	r4,-20(fp)
 32480a0:	000b883a 	mov	r5,zero
 32480a4:	000d883a 	mov	r6,zero
 32480a8:	32485240 	call	3248524 <in_pcblookup>
 32480ac:	1005003a 	cmpeq	r2,r2,zero
 32480b0:	1000031e 	bne	r2,zero,32480c0 <in_pcbbind+0x158>
          0L, 0, sin->sin_addr.s_addr, lport, wild))
      {
         return (EADDRINUSE);
 32480b4:	00801c04 	movi	r2,112
 32480b8:	e0bfff15 	stw	r2,-4(fp)
 32480bc:	00003906 	br	32481a4 <in_pcbbind+0x23c>
      }
   }
   inp->inp_laddr = sin->sin_addr;
 32480c0:	e0bffa17 	ldw	r2,-24(fp)
 32480c4:	10c00117 	ldw	r3,4(r2)
 32480c8:	e0bffd17 	ldw	r2,-12(fp)
 32480cc:	10c00415 	stw	r3,16(r2)
noname:
   if (lport == 0)
 32480d0:	e0bff90b 	ldhu	r2,-28(fp)
 32480d4:	1004c03a 	cmpne	r2,r2,zero
 32480d8:	10002e1e 	bne	r2,zero,3248194 <in_pcbbind+0x22c>
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 32480dc:	e0bffb17 	ldw	r2,-20(fp)
 32480e0:	10c0078b 	ldhu	r3,30(r2)
 32480e4:	18bfffcc 	andi	r2,r3,65535
 32480e8:	10810030 	cmpltui	r2,r2,1024
 32480ec:	1009883a 	mov	r4,r2
 32480f0:	18800044 	addi	r2,r3,1
 32480f4:	1007883a 	mov	r3,r2
 32480f8:	e0bffb17 	ldw	r2,-20(fp)
 32480fc:	10c0078d 	sth	r3,30(r2)
 3248100:	20803fcc 	andi	r2,r4,255
 3248104:	1004c03a 	cmpne	r2,r2,zero
 3248108:	1000051e 	bne	r2,zero,3248120 <in_pcbbind+0x1b8>
 324810c:	e0bffb17 	ldw	r2,-20(fp)
 3248110:	1080078b 	ldhu	r2,30(r2)
 3248114:	10bfffcc 	andi	r2,r2,65535
 3248118:	1084e270 	cmpltui	r2,r2,5001
 324811c:	1000031e 	bne	r2,zero,324812c <in_pcbbind+0x1c4>
             head->inp_lport > IPPORT_USERRESERVED)
         {
            head->inp_lport = IPPORT_RESERVED;
 3248120:	e0fffb17 	ldw	r3,-20(fp)
 3248124:	00810004 	movi	r2,1024
 3248128:	1880078d 	sth	r2,30(r3)
         }
         lport = htons(head->inp_lport);
 324812c:	e0bffb17 	ldw	r2,-20(fp)
 3248130:	1080078b 	ldhu	r2,30(r2)
 3248134:	10bfffcc 	andi	r2,r2,65535
 3248138:	1004d23a 	srli	r2,r2,8
 324813c:	10803fcc 	andi	r2,r2,255
 3248140:	1009883a 	mov	r4,r2
 3248144:	e0bffb17 	ldw	r2,-20(fp)
 3248148:	1080078b 	ldhu	r2,30(r2)
 324814c:	10bfffcc 	andi	r2,r2,65535
 3248150:	1004923a 	slli	r2,r2,8
 3248154:	1007883a 	mov	r3,r2
 3248158:	00bfc004 	movi	r2,-256
 324815c:	1884703a 	and	r2,r3,r2
 3248160:	2084b03a 	or	r2,r4,r2
 3248164:	e0bff90d 	sth	r2,-28(fp)
      } while(in_pcblookup(head, 0L, 0, inp->inp_laddr.s_addr, lport, 0));
 3248168:	e0bffd17 	ldw	r2,-12(fp)
 324816c:	11c00417 	ldw	r7,16(r2)
 3248170:	e0bff90b 	ldhu	r2,-28(fp)
 3248174:	d8800015 	stw	r2,0(sp)
 3248178:	d8000115 	stw	zero,4(sp)
 324817c:	e13ffb17 	ldw	r4,-20(fp)
 3248180:	000b883a 	mov	r5,zero
 3248184:	000d883a 	mov	r6,zero
 3248188:	32485240 	call	3248524 <in_pcblookup>
 324818c:	1004c03a 	cmpne	r2,r2,zero
 3248190:	103fd21e 	bne	r2,zero,32480dc <in_pcbbind+0x174>
   }
   inp->inp_lport = lport;
 3248194:	e0fffd17 	ldw	r3,-12(fp)
 3248198:	e0bff90b 	ldhu	r2,-28(fp)
 324819c:	1880078d 	sth	r2,30(r3)
   return (0);
 32481a0:	e03fff15 	stw	zero,-4(fp)
 32481a4:	e0bfff17 	ldw	r2,-4(fp)
}
 32481a8:	e037883a 	mov	sp,fp
 32481ac:	dfc00117 	ldw	ra,4(sp)
 32481b0:	df000017 	ldw	fp,0(sp)
 32481b4:	dec00204 	addi	sp,sp,8
 32481b8:	f800283a 	ret

032481bc <in_pcbconnect>:
 */

int
in_pcbconnect(struct inpcb * inp, 
   struct mbuf *  nam)
{
 32481bc:	defff504 	addi	sp,sp,-44
 32481c0:	dfc00a15 	stw	ra,40(sp)
 32481c4:	df000915 	stw	fp,36(sp)
 32481c8:	df000904 	addi	fp,sp,36
 32481cc:	e13ffd15 	stw	r4,-12(fp)
 32481d0:	e17ffe15 	stw	r5,-8(fp)
   unsigned long ifaddr;
   struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 32481d4:	e0bffe17 	ldw	r2,-8(fp)
 32481d8:	10800317 	ldw	r2,12(r2)
 32481dc:	e0bffa15 	stw	r2,-24(fp)

   if (nam->m_len < sizeof (*sin))
 32481e0:	e0bffe17 	ldw	r2,-8(fp)
 32481e4:	10800217 	ldw	r2,8(r2)
 32481e8:	10800428 	cmpgeui	r2,r2,16
 32481ec:	1000031e 	bne	r2,zero,32481fc <in_pcbconnect+0x40>
      return (EINVAL);
 32481f0:	00800584 	movi	r2,22
 32481f4:	e0bfff15 	stw	r2,-4(fp)
 32481f8:	00006e06 	br	32483b4 <in_pcbconnect+0x1f8>
   if (sin->sin_family != AF_INET)
 32481fc:	e0bffa17 	ldw	r2,-24(fp)
 3248200:	1080000b 	ldhu	r2,0(r2)
 3248204:	10bfffcc 	andi	r2,r2,65535
 3248208:	10a0001c 	xori	r2,r2,32768
 324820c:	10a00004 	addi	r2,r2,-32768
 3248210:	108000a0 	cmpeqi	r2,r2,2
 3248214:	1000031e 	bne	r2,zero,3248224 <in_pcbconnect+0x68>
      return (EAFNOSUPPORT);
 3248218:	00801a84 	movi	r2,106
 324821c:	e0bfff15 	stw	r2,-4(fp)
 3248220:	00006406 	br	32483b4 <in_pcbconnect+0x1f8>
   if (sin->sin_port == 0)
 3248224:	e0bffa17 	ldw	r2,-24(fp)
 3248228:	1080008b 	ldhu	r2,2(r2)
 324822c:	10bfffcc 	andi	r2,r2,65535
 3248230:	1004c03a 	cmpne	r2,r2,zero
 3248234:	1000031e 	bne	r2,zero,3248244 <in_pcbconnect+0x88>
      return (EADDRNOTAVAIL);
 3248238:	00801f44 	movi	r2,125
 324823c:	e0bfff15 	stw	r2,-4(fp)
 3248240:	00005c06 	br	32483b4 <in_pcbconnect+0x1f8>
    * use the primary local address.
    * If the supplied address is INADDR_BROADCAST,
    * and the primary interface supports broadcast,
    * choose the broadcast address for that interface.
    */
   if (sin->sin_addr.s_addr == INADDR_ANY)
 3248244:	e0bffa17 	ldw	r2,-24(fp)
 3248248:	10800117 	ldw	r2,4(r2)
 324824c:	1004c03a 	cmpne	r2,r2,zero
 3248250:	1000101e 	bne	r2,zero,3248294 <in_pcbconnect+0xd8>
   {
      if (inp && inp->ifp)
 3248254:	e0bffd17 	ldw	r2,-12(fp)
 3248258:	1005003a 	cmpeq	r2,r2,zero
 324825c:	10000a1e 	bne	r2,zero,3248288 <in_pcbconnect+0xcc>
 3248260:	e0bffd17 	ldw	r2,-12(fp)
 3248264:	10800a17 	ldw	r2,40(r2)
 3248268:	1005003a 	cmpeq	r2,r2,zero
 324826c:	1000061e 	bne	r2,zero,3248288 <in_pcbconnect+0xcc>
         sin->sin_addr.s_addr = inp->ifp->n_ipaddr;
 3248270:	e0bffd17 	ldw	r2,-12(fp)
 3248274:	10800a17 	ldw	r2,40(r2)
 3248278:	10c00a17 	ldw	r3,40(r2)
 324827c:	e0bffa17 	ldw	r2,-24(fp)
 3248280:	10c00115 	stw	r3,4(r2)
 3248284:	00000a06 	br	32482b0 <in_pcbconnect+0xf4>
      else
         return (EADDRNOTAVAIL);
 3248288:	00801f44 	movi	r2,125
 324828c:	e0bfff15 	stw	r2,-4(fp)
 3248290:	00004806 	br	32483b4 <in_pcbconnect+0x1f8>
   }
   else if (sin->sin_addr.s_addr == INADDR_BROADCAST)
 3248294:	e0bffa17 	ldw	r2,-24(fp)
 3248298:	10800117 	ldw	r2,4(r2)
 324829c:	10bfffd8 	cmpnei	r2,r2,-1
 32482a0:	1000031e 	bne	r2,zero,32482b0 <in_pcbconnect+0xf4>
      return (EADDRNOTAVAIL);
 32482a4:	00801f44 	movi	r2,125
 32482a8:	e0bfff15 	stw	r2,-4(fp)
 32482ac:	00004106 	br	32483b4 <in_pcbconnect+0x1f8>


   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 32482b0:	e0bffd17 	ldw	r2,-12(fp)
 32482b4:	10800417 	ldw	r2,16(r2)
 32482b8:	1004c03a 	cmpne	r2,r2,zero
 32482bc:	10000f1e 	bne	r2,zero,32482fc <in_pcbconnect+0x140>
   {
#ifdef MULTI_HOMED
      ip_addr hop1;     /* dummy for pass to iproute() */
      NET npnet;     /* the netport iface we can send on */
      /* call netport stack's IP routing */
      npnet = iproute(sin->sin_addr.s_addr, &hop1);
 32482c0:	e0bffa17 	ldw	r2,-24(fp)
 32482c4:	11000117 	ldw	r4,4(r2)
 32482c8:	e17ffc04 	addi	r5,fp,-16
 32482cc:	32404f00 	call	32404f0 <iproute>
 32482d0:	e0bff915 	stw	r2,-28(fp)
      if (!npnet)
 32482d4:	e0bff917 	ldw	r2,-28(fp)
 32482d8:	1004c03a 	cmpne	r2,r2,zero
 32482dc:	1000031e 	bne	r2,zero,32482ec <in_pcbconnect+0x130>
         return EADDRNOTAVAIL;
 32482e0:	00801f44 	movi	r2,125
 32482e4:	e0bfff15 	stw	r2,-4(fp)
 32482e8:	00003206 	br	32483b4 <in_pcbconnect+0x1f8>
      ifaddr = npnet->n_ipaddr;  /* local address for this host */
 32482ec:	e0bff917 	ldw	r2,-28(fp)
 32482f0:	10800a17 	ldw	r2,40(r2)
 32482f4:	e0bffb15 	stw	r2,-20(fp)
 32482f8:	00000306 	br	3248308 <in_pcbconnect+0x14c>
#else    /* not netport MULTI_HOMED, use 0th (only) iface */
      ifaddr = nets[0]->n_ipaddr;
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */
 32482fc:	e0bffd17 	ldw	r2,-12(fp)
 3248300:	10800417 	ldw	r2,16(r2)
 3248304:	e0bffb15 	stw	r2,-20(fp)

   if (in_pcblookup(inp->inp_head,
 3248308:	e0bffd17 	ldw	r2,-12(fp)
 324830c:	11000217 	ldw	r4,8(r2)
 3248310:	e0bffa17 	ldw	r2,-24(fp)
 3248314:	11400117 	ldw	r5,4(r2)
 3248318:	e0bffa17 	ldw	r2,-24(fp)
 324831c:	1080008b 	ldhu	r2,2(r2)
 3248320:	11bfffcc 	andi	r6,r2,65535
 3248324:	e0bffd17 	ldw	r2,-12(fp)
 3248328:	1080078b 	ldhu	r2,30(r2)
 324832c:	10bfffcc 	andi	r2,r2,65535
 3248330:	d8800015 	stw	r2,0(sp)
 3248334:	d8000115 	stw	zero,4(sp)
 3248338:	e1fffb17 	ldw	r7,-20(fp)
 324833c:	32485240 	call	3248524 <in_pcblookup>
 3248340:	1005003a 	cmpeq	r2,r2,zero
 3248344:	1000031e 	bne	r2,zero,3248354 <in_pcbconnect+0x198>
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
       0))
   {
      return (EADDRINUSE);
 3248348:	00801c04 	movi	r2,112
 324834c:	e0bfff15 	stw	r2,-4(fp)
 3248350:	00001806 	br	32483b4 <in_pcbconnect+0x1f8>
   }
   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 3248354:	e0bffd17 	ldw	r2,-12(fp)
 3248358:	10800417 	ldw	r2,16(r2)
 324835c:	1004c03a 	cmpne	r2,r2,zero
 3248360:	10000b1e 	bne	r2,zero,3248390 <in_pcbconnect+0x1d4>
   {
      if (inp->inp_lport == 0)
 3248364:	e0bffd17 	ldw	r2,-12(fp)
 3248368:	1080078b 	ldhu	r2,30(r2)
 324836c:	10bfffcc 	andi	r2,r2,65535
 3248370:	1004c03a 	cmpne	r2,r2,zero
 3248374:	1000031e 	bne	r2,zero,3248384 <in_pcbconnect+0x1c8>
         (void)in_pcbbind(inp, (struct mbuf *)0);
 3248378:	e13ffd17 	ldw	r4,-12(fp)
 324837c:	000b883a 	mov	r5,zero
 3248380:	3247f680 	call	3247f68 <in_pcbbind>
      inp->inp_laddr.s_addr = ifaddr;
 3248384:	e0fffd17 	ldw	r3,-12(fp)
 3248388:	e0bffb17 	ldw	r2,-20(fp)
 324838c:	18800415 	stw	r2,16(r3)
   }
   inp->inp_faddr = sin->sin_addr;
 3248390:	e0bffa17 	ldw	r2,-24(fp)
 3248394:	10c00117 	ldw	r3,4(r2)
 3248398:	e0bffd17 	ldw	r2,-12(fp)
 324839c:	10c00315 	stw	r3,12(r2)
   inp->inp_fport = sin->sin_port;
 32483a0:	e0bffa17 	ldw	r2,-24(fp)
 32483a4:	10c0008b 	ldhu	r3,2(r2)
 32483a8:	e0bffd17 	ldw	r2,-12(fp)
 32483ac:	10c0070d 	sth	r3,28(r2)
   return 0;
 32483b0:	e03fff15 	stw	zero,-4(fp)
 32483b4:	e0bfff17 	ldw	r2,-4(fp)
}
 32483b8:	e037883a 	mov	sp,fp
 32483bc:	dfc00117 	ldw	ra,4(sp)
 32483c0:	df000017 	ldw	fp,0(sp)
 32483c4:	dec00204 	addi	sp,sp,8
 32483c8:	f800283a 	ret

032483cc <in_pcbdisconnect>:
 * RETURNS: 
 */

void
in_pcbdisconnect(struct inpcb * inp)
{
 32483cc:	defffd04 	addi	sp,sp,-12
 32483d0:	dfc00215 	stw	ra,8(sp)
 32483d4:	df000115 	stw	fp,4(sp)
 32483d8:	df000104 	addi	fp,sp,4
 32483dc:	e13fff15 	stw	r4,-4(fp)

   inp->inp_faddr.s_addr = INADDR_ANY;
 32483e0:	e0bfff17 	ldw	r2,-4(fp)
 32483e4:	10000315 	stw	zero,12(r2)
   inp->inp_fport = 0;
 32483e8:	e0bfff17 	ldw	r2,-4(fp)
 32483ec:	1000070d 	sth	zero,28(r2)
   if (inp->inp_socket->so_state & SS_NOFDREF)
 32483f0:	e0bfff17 	ldw	r2,-4(fp)
 32483f4:	10800817 	ldw	r2,32(r2)
 32483f8:	1080088b 	ldhu	r2,34(r2)
 32483fc:	10bfffcc 	andi	r2,r2,65535
 3248400:	1080004c 	andi	r2,r2,1
 3248404:	10803fcc 	andi	r2,r2,255
 3248408:	1005003a 	cmpeq	r2,r2,zero
 324840c:	1000021e 	bne	r2,zero,3248418 <in_pcbdisconnect+0x4c>
      in_pcbdetach (inp);
 3248410:	e13fff17 	ldw	r4,-4(fp)
 3248414:	3247f140 	call	3247f14 <in_pcbdetach>
}
 3248418:	e037883a 	mov	sp,fp
 324841c:	dfc00117 	ldw	ra,4(sp)
 3248420:	df000017 	ldw	fp,0(sp)
 3248424:	dec00204 	addi	sp,sp,8
 3248428:	f800283a 	ret

0324842c <in_setsockaddr>:
 */

void
in_setsockaddr(struct inpcb * inp, 
   struct mbuf *  nam)
{
 324842c:	defffc04 	addi	sp,sp,-16
 3248430:	df000315 	stw	fp,12(sp)
 3248434:	df000304 	addi	fp,sp,12
 3248438:	e13ffe15 	stw	r4,-8(fp)
 324843c:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 3248440:	e0ffff17 	ldw	r3,-4(fp)
 3248444:	00800404 	movi	r2,16
 3248448:	18800215 	stw	r2,8(r3)
   sin = mtod(nam, struct sockaddr_in *);
 324844c:	e0bfff17 	ldw	r2,-4(fp)
 3248450:	10800317 	ldw	r2,12(r2)
 3248454:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 3248458:	e0bffd17 	ldw	r2,-12(fp)
 324845c:	10000015 	stw	zero,0(r2)
 3248460:	10000115 	stw	zero,4(r2)
 3248464:	10000215 	stw	zero,8(r2)
 3248468:	10000315 	stw	zero,12(r2)
   sin->sin_family = AF_INET;
 324846c:	e0fffd17 	ldw	r3,-12(fp)
 3248470:	00800084 	movi	r2,2
 3248474:	1880000d 	sth	r2,0(r3)
   sin->sin_port = inp->inp_lport;
 3248478:	e0bffe17 	ldw	r2,-8(fp)
 324847c:	10c0078b 	ldhu	r3,30(r2)
 3248480:	e0bffd17 	ldw	r2,-12(fp)
 3248484:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_laddr;
 3248488:	e0bffe17 	ldw	r2,-8(fp)
 324848c:	10c00417 	ldw	r3,16(r2)
 3248490:	e0bffd17 	ldw	r2,-12(fp)
 3248494:	10c00115 	stw	r3,4(r2)
}
 3248498:	e037883a 	mov	sp,fp
 324849c:	df000017 	ldw	fp,0(sp)
 32484a0:	dec00104 	addi	sp,sp,4
 32484a4:	f800283a 	ret

032484a8 <in_setpeeraddr>:

void
in_setpeeraddr(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 32484a8:	defffc04 	addi	sp,sp,-16
 32484ac:	df000315 	stw	fp,12(sp)
 32484b0:	df000304 	addi	fp,sp,12
 32484b4:	e13ffe15 	stw	r4,-8(fp)
 32484b8:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 32484bc:	e0ffff17 	ldw	r3,-4(fp)
 32484c0:	00800404 	movi	r2,16
 32484c4:	18800215 	stw	r2,8(r3)
   sin = mtod(nam, struct sockaddr_in *);
 32484c8:	e0bfff17 	ldw	r2,-4(fp)
 32484cc:	10800317 	ldw	r2,12(r2)
 32484d0:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 32484d4:	e0bffd17 	ldw	r2,-12(fp)
 32484d8:	10000015 	stw	zero,0(r2)
 32484dc:	10000115 	stw	zero,4(r2)
 32484e0:	10000215 	stw	zero,8(r2)
 32484e4:	10000315 	stw	zero,12(r2)
   sin->sin_family = AF_INET;
 32484e8:	e0fffd17 	ldw	r3,-12(fp)
 32484ec:	00800084 	movi	r2,2
 32484f0:	1880000d 	sth	r2,0(r3)
   sin->sin_port = inp->inp_fport;
 32484f4:	e0bffe17 	ldw	r2,-8(fp)
 32484f8:	10c0070b 	ldhu	r3,28(r2)
 32484fc:	e0bffd17 	ldw	r2,-12(fp)
 3248500:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_faddr;
 3248504:	e0bffe17 	ldw	r2,-8(fp)
 3248508:	10c00317 	ldw	r3,12(r2)
 324850c:	e0bffd17 	ldw	r2,-12(fp)
 3248510:	10c00115 	stw	r3,4(r2)
}
 3248514:	e037883a 	mov	sp,fp
 3248518:	df000017 	ldw	fp,0(sp)
 324851c:	dec00104 	addi	sp,sp,4
 3248520:	f800283a 	ret

03248524 <in_pcblookup>:
   u_long   faddr, 
   unshort  xfport,
   u_long   laddr,
   unshort  xlport,
   int   flags)
{
 3248524:	defff404 	addi	sp,sp,-48
 3248528:	df000b15 	stw	fp,44(sp)
 324852c:	df000b04 	addi	fp,sp,44
 3248530:	e13ffa15 	stw	r4,-24(fp)
 3248534:	e17ffb15 	stw	r5,-20(fp)
 3248538:	e1fffd15 	stw	r7,-12(fp)
 324853c:	e0800117 	ldw	r2,4(fp)
 3248540:	e1bffc0d 	sth	r6,-16(fp)
 3248544:	e0bffe0d 	sth	r2,-8(fp)
   struct inpcb * inp, *   match =  0;
 3248548:	e03ff815 	stw	zero,-32(fp)
   unshort  fport =  xfport; 
 324854c:	e0bffc0b 	ldhu	r2,-16(fp)
 3248550:	e0bff78d 	sth	r2,-34(fp)
   unshort  lport =  xlport;
 3248554:	e0bffe0b 	ldhu	r2,-8(fp)
 3248558:	e0bff70d 	sth	r2,-36(fp)
   int   matchwild   =  3;
 324855c:	008000c4 	movi	r2,3
 3248560:	e0bff615 	stw	r2,-40(fp)
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 3248564:	e0bffa17 	ldw	r2,-24(fp)
 3248568:	10800017 	ldw	r2,0(r2)
 324856c:	e0bff915 	stw	r2,-28(fp)
 3248570:	00005006 	br	32486b4 <in_pcblookup+0x190>
   {
      if (inp->inp_lport != lport)
 3248574:	e0bff917 	ldw	r2,-28(fp)
 3248578:	1080078b 	ldhu	r2,30(r2)
 324857c:	10ffffcc 	andi	r3,r2,65535
 3248580:	e0bff70b 	ldhu	r2,-36(fp)
 3248584:	1880481e 	bne	r3,r2,32486a8 <in_pcblookup+0x184>
         continue;

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
 3248588:	e0bff917 	ldw	r2,-28(fp)
 324858c:	10800817 	ldw	r2,32(r2)
 3248590:	10800517 	ldw	r2,20(r2)
 3248594:	10800098 	cmpnei	r2,r2,2
 3248598:	1000431e 	bne	r2,zero,32486a8 <in_pcblookup+0x184>
         continue;

      wildcard = 0;
 324859c:	e03ff515 	stw	zero,-44(fp)
      if (inp->inp_laddr.s_addr != INADDR_ANY) 
 32485a0:	e0bff917 	ldw	r2,-28(fp)
 32485a4:	10800417 	ldw	r2,16(r2)
 32485a8:	1005003a 	cmpeq	r2,r2,zero
 32485ac:	10000c1e 	bne	r2,zero,32485e0 <in_pcblookup+0xbc>
      {
         if (laddr == INADDR_ANY)
 32485b0:	e0bffd17 	ldw	r2,-12(fp)
 32485b4:	1004c03a 	cmpne	r2,r2,zero
 32485b8:	1000041e 	bne	r2,zero,32485cc <in_pcblookup+0xa8>
            wildcard++;
 32485bc:	e0bff517 	ldw	r2,-44(fp)
 32485c0:	10800044 	addi	r2,r2,1
 32485c4:	e0bff515 	stw	r2,-44(fp)
 32485c8:	00000b06 	br	32485f8 <in_pcblookup+0xd4>
         else if (inp->inp_laddr.s_addr != laddr)
 32485cc:	e0bff917 	ldw	r2,-28(fp)
 32485d0:	10c00417 	ldw	r3,16(r2)
 32485d4:	e0bffd17 	ldw	r2,-12(fp)
 32485d8:	1880331e 	bne	r3,r2,32486a8 <in_pcblookup+0x184>
            continue;
 32485dc:	00000606 	br	32485f8 <in_pcblookup+0xd4>
      }
      else 
      {
         if (laddr != INADDR_ANY)
 32485e0:	e0bffd17 	ldw	r2,-12(fp)
 32485e4:	1005003a 	cmpeq	r2,r2,zero
 32485e8:	1000031e 	bne	r2,zero,32485f8 <in_pcblookup+0xd4>
            wildcard++;
 32485ec:	e0bff517 	ldw	r2,-44(fp)
 32485f0:	10800044 	addi	r2,r2,1
 32485f4:	e0bff515 	stw	r2,-44(fp)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
 32485f8:	e0bff917 	ldw	r2,-28(fp)
 32485fc:	10800317 	ldw	r2,12(r2)
 3248600:	1005003a 	cmpeq	r2,r2,zero
 3248604:	1000111e 	bne	r2,zero,324864c <in_pcblookup+0x128>
      {
         if (faddr == INADDR_ANY)
 3248608:	e0bffb17 	ldw	r2,-20(fp)
 324860c:	1004c03a 	cmpne	r2,r2,zero
 3248610:	1000041e 	bne	r2,zero,3248624 <in_pcblookup+0x100>
            wildcard++;
 3248614:	e0bff517 	ldw	r2,-44(fp)
 3248618:	10800044 	addi	r2,r2,1
 324861c:	e0bff515 	stw	r2,-44(fp)
 3248620:	00001006 	br	3248664 <in_pcblookup+0x140>
         else if (inp->inp_faddr.s_addr != faddr ||
 3248624:	e0bff917 	ldw	r2,-28(fp)
 3248628:	10c00317 	ldw	r3,12(r2)
 324862c:	e0bffb17 	ldw	r2,-20(fp)
 3248630:	18801d1e 	bne	r3,r2,32486a8 <in_pcblookup+0x184>
 3248634:	e0bff917 	ldw	r2,-28(fp)
 3248638:	1080070b 	ldhu	r2,28(r2)
 324863c:	10ffffcc 	andi	r3,r2,65535
 3248640:	e0bff78b 	ldhu	r2,-34(fp)
 3248644:	1880181e 	bne	r3,r2,32486a8 <in_pcblookup+0x184>
 3248648:	00000606 	br	3248664 <in_pcblookup+0x140>
         {
            continue;
         }
      } else 
      {
         if (faddr != INADDR_ANY)
 324864c:	e0bffb17 	ldw	r2,-20(fp)
 3248650:	1005003a 	cmpeq	r2,r2,zero
 3248654:	1000031e 	bne	r2,zero,3248664 <in_pcblookup+0x140>
            wildcard++;
 3248658:	e0bff517 	ldw	r2,-44(fp)
 324865c:	10800044 	addi	r2,r2,1
 3248660:	e0bff515 	stw	r2,-44(fp)
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
 3248664:	e0bff517 	ldw	r2,-44(fp)
 3248668:	1005003a 	cmpeq	r2,r2,zero
 324866c:	1000041e 	bne	r2,zero,3248680 <in_pcblookup+0x15c>
 3248670:	e0800217 	ldw	r2,8(fp)
 3248674:	1080004c 	andi	r2,r2,1
 3248678:	1005003a 	cmpeq	r2,r2,zero
 324867c:	10000a1e 	bne	r2,zero,32486a8 <in_pcblookup+0x184>
         continue;
      if (wildcard < matchwild) 
 3248680:	e0fff517 	ldw	r3,-44(fp)
 3248684:	e0bff617 	ldw	r2,-40(fp)
 3248688:	1880070e 	bge	r3,r2,32486a8 <in_pcblookup+0x184>
      {
         match = inp;
 324868c:	e0bff917 	ldw	r2,-28(fp)
 3248690:	e0bff815 	stw	r2,-32(fp)
         matchwild = wildcard;
 3248694:	e0bff517 	ldw	r2,-44(fp)
 3248698:	e0bff615 	stw	r2,-40(fp)
         if (matchwild == 0)
 324869c:	e0bff617 	ldw	r2,-40(fp)
 32486a0:	1005003a 	cmpeq	r2,r2,zero
 32486a4:	1000061e 	bne	r2,zero,32486c0 <in_pcblookup+0x19c>
   unshort  fport =  xfport; 
   unshort  lport =  xlport;
   int   matchwild   =  3;
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 32486a8:	e0bff917 	ldw	r2,-28(fp)
 32486ac:	10800017 	ldw	r2,0(r2)
 32486b0:	e0bff915 	stw	r2,-28(fp)
 32486b4:	e0fff917 	ldw	r3,-28(fp)
 32486b8:	e0bffa17 	ldw	r2,-24(fp)
 32486bc:	18bfad1e 	bne	r3,r2,3248574 <in_pcblookup+0x50>
         matchwild = wildcard;
         if (matchwild == 0)
            break;
      }
   }
   if (match == NULL)
 32486c0:	e0bff817 	ldw	r2,-32(fp)
 32486c4:	1004c03a 	cmpne	r2,r2,zero
 32486c8:	1000031e 	bne	r2,zero,32486d8 <in_pcblookup+0x1b4>
      return match;
 32486cc:	e0bff817 	ldw	r2,-32(fp)
 32486d0:	e0bfff15 	stw	r2,-4(fp)
 32486d4:	00002506 	br	324876c <in_pcblookup+0x248>

   if (head->inp_next == match)  /* got cache hit? */
 32486d8:	e0bffa17 	ldw	r2,-24(fp)
 32486dc:	10c00017 	ldw	r3,0(r2)
 32486e0:	e0bff817 	ldw	r2,-32(fp)
 32486e4:	1880041e 	bne	r3,r2,32486f8 <in_pcblookup+0x1d4>
   {
      inpcb_cachehits++;
 32486e8:	d0a90917 	ldw	r2,-23516(gp)
 32486ec:	10800044 	addi	r2,r2,1
 32486f0:	d0a90915 	stw	r2,-23516(gp)
 32486f4:	00001b06 	br	3248764 <in_pcblookup+0x240>
   }
   else
   {
      inpcb_cachemiss++;
 32486f8:	d0a90a17 	ldw	r2,-23512(gp)
 32486fc:	10800044 	addi	r2,r2,1
 3248700:	d0a90a15 	stw	r2,-23512(gp)
      /* "cache" the match to be first checked next time. */
      match->inp_next->inp_prev = match->inp_prev; /*unlink match */
 3248704:	e0bff817 	ldw	r2,-32(fp)
 3248708:	10c00017 	ldw	r3,0(r2)
 324870c:	e0bff817 	ldw	r2,-32(fp)
 3248710:	10800117 	ldw	r2,4(r2)
 3248714:	18800115 	stw	r2,4(r3)
      match->inp_prev->inp_next = match->inp_next;
 3248718:	e0bff817 	ldw	r2,-32(fp)
 324871c:	10c00117 	ldw	r3,4(r2)
 3248720:	e0bff817 	ldw	r2,-32(fp)
 3248724:	10800017 	ldw	r2,0(r2)
 3248728:	18800015 	stw	r2,0(r3)

      /* relink match as head->inp_next */
      match->inp_next = head->inp_next;
 324872c:	e0bffa17 	ldw	r2,-24(fp)
 3248730:	10c00017 	ldw	r3,0(r2)
 3248734:	e0bff817 	ldw	r2,-32(fp)
 3248738:	10c00015 	stw	r3,0(r2)
      head->inp_next = match;
 324873c:	e0fffa17 	ldw	r3,-24(fp)
 3248740:	e0bff817 	ldw	r2,-32(fp)
 3248744:	18800015 	stw	r2,0(r3)
      match->inp_prev = head;
 3248748:	e0fff817 	ldw	r3,-32(fp)
 324874c:	e0bffa17 	ldw	r2,-24(fp)
 3248750:	18800115 	stw	r2,4(r3)
      match->inp_next->inp_prev = match;
 3248754:	e0bff817 	ldw	r2,-32(fp)
 3248758:	10c00017 	ldw	r3,0(r2)
 324875c:	e0bff817 	ldw	r2,-32(fp)
 3248760:	18800115 	stw	r2,4(r3)
   }
   return (match);
 3248764:	e0bff817 	ldw	r2,-32(fp)
 3248768:	e0bfff15 	stw	r2,-4(fp)
 324876c:	e0bfff17 	ldw	r2,-4(fp)
}
 3248770:	e037883a 	mov	sp,fp
 3248774:	df000017 	ldw	fp,0(sp)
 3248778:	dec00104 	addi	sp,sp,4
 324877c:	f800283a 	ret

03248780 <set_vfopen_error>:
 *
 * RETURNS: 
 */

void set_vfopen_error(int error)
{
 3248780:	defffe04 	addi	sp,sp,-8
 3248784:	df000115 	stw	fp,4(sp)
 3248788:	df000104 	addi	fp,sp,4
 324878c:	e13fff15 	stw	r4,-4(fp)
   vfopen_error = error;
 3248790:	e0bfff17 	ldw	r2,-4(fp)
 3248794:	d0a90e15 	stw	r2,-23496(gp)
}
 3248798:	e037883a 	mov	sp,fp
 324879c:	df000017 	ldw	fp,0(sp)
 32487a0:	dec00104 	addi	sp,sp,4
 32487a4:	f800283a 	ret

032487a8 <get_vfopen_error>:
 *
 * RETURNS: 
 */

int get_vfopen_error()
{
 32487a8:	deffff04 	addi	sp,sp,-4
 32487ac:	df000015 	stw	fp,0(sp)
 32487b0:	d839883a 	mov	fp,sp
   return vfopen_error;
 32487b4:	d0a90e17 	ldw	r2,-23496(gp)
}
 32487b8:	e037883a 	mov	sp,fp
 32487bc:	df000017 	ldw	fp,0(sp)
 32487c0:	dec00104 	addi	sp,sp,4
 32487c4:	f800283a 	ret

032487c8 <vf_alloc_and_link_vop>:
 *
 * RETURNS: 
 */

VFILE * vf_alloc_and_link_vop()
{
 32487c8:	defffc04 	addi	sp,sp,-16
 32487cc:	dfc00315 	stw	ra,12(sp)
 32487d0:	df000215 	stw	fp,8(sp)
 32487d4:	df000204 	addi	fp,sp,8
   struct vfs_open * vop;

   /* enforce maximum number of simultaneously open files */
   if (vfs_open_files >= VFS_MAX_OPEN_FILES)
 32487d8:	d0a91017 	ldw	r2,-23488(gp)
 32487dc:	10803ff0 	cmpltui	r2,r2,255
 32487e0:	1000021e 	bne	r2,zero,32487ec <vf_alloc_and_link_vop+0x24>
   {
#ifdef VFS_VERBOSE
      dprintf("vfs_open_files too big (%ld) in vf_alloc_and_link_vop()\n",
       vfs_open_files);
#endif   /* VFS_VERBOSE */
      return NULL;
 32487e4:	e03fff15 	stw	zero,-4(fp)
 32487e8:	00001006 	br	324882c <vf_alloc_and_link_vop+0x64>
   }

   /* allocate a structure to represent the open file */
   vop = VFS_VFS_OPEN_ALLOC();
 32487ec:	01000504 	movi	r4,20
 32487f0:	322b5d00 	call	322b5d0 <npalloc>
 32487f4:	e0bffe15 	stw	r2,-8(fp)

   /* if the allocation succeeded */
   if (vop)
 32487f8:	e0bffe17 	ldw	r2,-8(fp)
 32487fc:	1005003a 	cmpeq	r2,r2,zero
 3248800:	1000081e 	bne	r2,zero,3248824 <vf_alloc_and_link_vop+0x5c>
   {
      /* add to the beginning of the list of open files */
      vop->next = vfiles;
 3248804:	d0e90c17 	ldw	r3,-23504(gp)
 3248808:	e0bffe17 	ldw	r2,-8(fp)
 324880c:	10c00015 	stw	r3,0(r2)
      vfiles = vop;
 3248810:	e0bffe17 	ldw	r2,-8(fp)
 3248814:	d0a90c15 	stw	r2,-23504(gp)
      /* increment the count of open files */
      vfs_open_files++;
 3248818:	d0a91017 	ldw	r2,-23488(gp)
 324881c:	10800044 	addi	r2,r2,1
 3248820:	d0a91015 	stw	r2,-23488(gp)
#ifdef VFS_VERBOSE
   else
      dprintf("VFS_VFS_OPEN_ALLOC() failed in vf_alloc_and_link_vop()\n");
#endif   /* VFS_VERBOSE */

   return vop;
 3248824:	e0bffe17 	ldw	r2,-8(fp)
 3248828:	e0bfff15 	stw	r2,-4(fp)
 324882c:	e0bfff17 	ldw	r2,-4(fp)
}
 3248830:	e037883a 	mov	sp,fp
 3248834:	dfc00117 	ldw	ra,4(sp)
 3248838:	df000017 	ldw	fp,0(sp)
 324883c:	dec00204 	addi	sp,sp,8
 3248840:	f800283a 	ret

03248844 <vf_alloc_buffer>:
 *
 * RETURNS: 
 */

unsigned char * vf_alloc_buffer(unsigned long size)
{
 3248844:	defff804 	addi	sp,sp,-32
 3248848:	dfc00715 	stw	ra,28(sp)
 324884c:	df000615 	stw	fp,24(sp)
 3248850:	df000604 	addi	fp,sp,24
 3248854:	e13ffe15 	stw	r4,-8(fp)
   unsigned int long_size,int_size;
#endif   /* MUTE_WARNS */

   /* make sure the requested allocation does not exceed the total
      memory space reserved for file buffers */
   if ((vfs_total_rw_space + size) > VFS_MAX_TOTAL_RW_SPACE)
 3248858:	d0e91117 	ldw	r3,-23484(gp)
 324885c:	e0bffe17 	ldw	r2,-8(fp)
 3248860:	1887883a 	add	r3,r3,r2
 3248864:	00bfffd4 	movui	r2,65535
 3248868:	10c0022e 	bgeu	r2,r3,3248874 <vf_alloc_buffer+0x30>
      return NULL;
 324886c:	e03fff15 	stw	zero,-4(fp)
 3248870:	00002406 	br	3248904 <vf_alloc_buffer+0xc0>
    * any bigger than what will fit in an unsigned int 
    */
#ifdef MUTE_WARNS
   /* the idiotic hoops you got to jump through to suppress compiler
      warnings */
   long_size   =  sizeof(unsigned   long);
 3248874:	00800104 	movi	r2,4
 3248878:	e0bffc15 	stw	r2,-16(fp)
   int_size = sizeof(unsigned int);
 324887c:	00800104 	movi	r2,4
 3248880:	e0bffb15 	stw	r2,-20(fp)
   if (long_size > int_size)
 3248884:	e0fffc17 	ldw	r3,-16(fp)
 3248888:	e0bffb17 	ldw	r2,-20(fp)
 324888c:	10c0112e 	bgeu	r2,r3,32488d4 <vf_alloc_buffer+0x90>
       * most systems where this "if" expression will evaluate to 
       * true (2 byte ints, 4 byte longs). if any of those upper bits 
       * are on in your requested size, you otta luck.
       */
#ifdef MUTE_WARNS
      switch (int_size)
 3248890:	e0bffb17 	ldw	r2,-20(fp)
 3248894:	108000a0 	cmpeqi	r2,r2,2
 3248898:	1000011e 	bne	r2,zero,32488a0 <vf_alloc_buffer+0x5c>
 324889c:	00000806 	br	32488c0 <vf_alloc_buffer+0x7c>
#else
      switch (sizeof(unsigned int))
#endif   /* MUTE_WARNS */
      {
      case 2 :
         mem_mask = 0xffff0000;
 32488a0:	00bffff4 	movhi	r2,65535
 32488a4:	e0bffa15 	stw	r2,-24(fp)
         default :
            dtrap();    /* you have a weird compiler */
         return NULL;
      }

      if (size & mem_mask)
 32488a8:	e0fffe17 	ldw	r3,-8(fp)
 32488ac:	e0bffa17 	ldw	r2,-24(fp)
 32488b0:	1884703a 	and	r2,r3,r2
 32488b4:	1004c03a 	cmpne	r2,r2,zero
 32488b8:	1000041e 	bne	r2,zero,32488cc <vf_alloc_buffer+0x88>
 32488bc:	00000506 	br	32488d4 <vf_alloc_buffer+0x90>
      {
      case 2 :
         mem_mask = 0xffff0000;
         break;
         default :
            dtrap();    /* you have a weird compiler */
 32488c0:	322ab8c0 	call	322ab8c <dtrap>
         return NULL;
 32488c4:	e03fff15 	stw	zero,-4(fp)
 32488c8:	00000e06 	br	3248904 <vf_alloc_buffer+0xc0>
      }

      if (size & mem_mask)
         return NULL;
 32488cc:	e03fff15 	stw	zero,-4(fp)
 32488d0:	00000c06 	br	3248904 <vf_alloc_buffer+0xc0>
   }

   /* try to allocate a buffer of the requested size */
   buffer = (unsigned char *) npalloc((unsigned int) size);
 32488d4:	e13ffe17 	ldw	r4,-8(fp)
 32488d8:	322b5d00 	call	322b5d0 <npalloc>
 32488dc:	e0bffd15 	stw	r2,-12(fp)

   /* if the allocation succeeded */
   if (buffer)
 32488e0:	e0bffd17 	ldw	r2,-12(fp)
 32488e4:	1005003a 	cmpeq	r2,r2,zero
 32488e8:	1000041e 	bne	r2,zero,32488fc <vf_alloc_buffer+0xb8>
   {
      /* add size to the count of total buffer space allocated */
      vfs_total_rw_space += size;
 32488ec:	d0a91117 	ldw	r2,-23484(gp)
 32488f0:	e0fffe17 	ldw	r3,-8(fp)
 32488f4:	10c5883a 	add	r2,r2,r3
 32488f8:	d0a91115 	stw	r2,-23484(gp)
   }

   return buffer;
 32488fc:	e0bffd17 	ldw	r2,-12(fp)
 3248900:	e0bfff15 	stw	r2,-4(fp)
 3248904:	e0bfff17 	ldw	r2,-4(fp)
}
 3248908:	e037883a 	mov	sp,fp
 324890c:	dfc00117 	ldw	ra,4(sp)
 3248910:	df000017 	ldw	fp,0(sp)
 3248914:	dec00204 	addi	sp,sp,8
 3248918:	f800283a 	ret

0324891c <vf_free_buffer>:
 *
 * RETURNS: 
 */

void vf_free_buffer(unsigned char * buffer, unsigned long size)
{
 324891c:	defffc04 	addi	sp,sp,-16
 3248920:	dfc00315 	stw	ra,12(sp)
 3248924:	df000215 	stw	fp,8(sp)
 3248928:	df000204 	addi	fp,sp,8
 324892c:	e13ffe15 	stw	r4,-8(fp)
 3248930:	e17fff15 	stw	r5,-4(fp)
   /* free the buffer */
   if (buffer)
 3248934:	e0bffe17 	ldw	r2,-8(fp)
 3248938:	1005003a 	cmpeq	r2,r2,zero
 324893c:	1000021e 	bne	r2,zero,3248948 <vf_free_buffer+0x2c>
      npfree(buffer);
 3248940:	e13ffe17 	ldw	r4,-8(fp)
 3248944:	322b6c40 	call	322b6c4 <npfree>

   /* and subtract its size from the total buffer space count */
   vfs_total_rw_space -= size;
 3248948:	d0a91117 	ldw	r2,-23484(gp)
 324894c:	e0ffff17 	ldw	r3,-4(fp)
 3248950:	10c5c83a 	sub	r2,r2,r3
 3248954:	d0a91115 	stw	r2,-23484(gp)
}
 3248958:	e037883a 	mov	sp,fp
 324895c:	dfc00117 	ldw	ra,4(sp)
 3248960:	df000017 	ldw	fp,0(sp)
 3248964:	dec00204 	addi	sp,sp,8
 3248968:	f800283a 	ret

0324896c <vfopen_locked>:
 * RETURNS: 
 */

VFILE *
vfopen_locked(char * name, char * mode)
{
 324896c:	defff804 	addi	sp,sp,-32
 3248970:	dfc00715 	stw	ra,28(sp)
 3248974:	df000615 	stw	fp,24(sp)
 3248978:	df000604 	addi	fp,sp,24
 324897c:	e13ffd15 	stw	r4,-12(fp)
 3248980:	e17ffe15 	stw	r5,-8(fp)
   struct vfs_file * vfp;
   struct vfs_open * vop;

   /* clear any previous vfopen() error */
   set_vfopen_error(0);
 3248984:	0009883a 	mov	r4,zero
 3248988:	32487800 	call	3248780 <set_vfopen_error>

   /* the old code used to do special handling of '?' in files for 
    * the benefit of the web server. the web server should be doing 
    * this now. this is here to make sure that its doing it 
    */
   if (strchr(name,'?'))
 324898c:	e13ffd17 	ldw	r4,-12(fp)
 3248990:	01400fc4 	movi	r5,63
 3248994:	32079f00 	call	32079f0 <strchr>
 3248998:	1005003a 	cmpeq	r2,r2,zero
 324899c:	1000031e 	bne	r2,zero,32489ac <vfopen_locked+0x40>
   {
      dtrap();
 32489a0:	322ab8c0 	call	322ab8c <dtrap>
      return NULL;
 32489a4:	e03fff15 	stw	zero,-4(fp)
 32489a8:	0000c406 	br	3248cbc <vfopen_locked+0x350>
   }

   /* determine if the file exists */
   /* if the directory exists, vfp will point to its directory entry
      structure else vfp will be NULL */
   vfp = vfslookup_locked(name);
 32489ac:	e13ffd17 	ldw	r4,-12(fp)
 32489b0:	3249d180 	call	3249d18 <vfslookup_locked>
 32489b4:	e0bffc15 	stw	r2,-16(fp)

   /* if the file exists */
   if (vfp)
 32489b8:	e0bffc17 	ldw	r2,-16(fp)
 32489bc:	1005003a 	cmpeq	r2,r2,zero
 32489c0:	10004e1e 	bne	r2,zero,3248afc <vfopen_locked+0x190>

#ifdef HT_RWVFS

      /* if mode begins with 'w' we will truncate to end of file */
      /* make sure the file is writable before proceeding */
      if ((*mode == 'w') && !(vfp->flags & VF_WRITE))
 32489c4:	e0bffe17 	ldw	r2,-8(fp)
 32489c8:	10800003 	ldbu	r2,0(r2)
 32489cc:	10803fcc 	andi	r2,r2,255
 32489d0:	1080201c 	xori	r2,r2,128
 32489d4:	10bfe004 	addi	r2,r2,-128
 32489d8:	10801dd8 	cmpnei	r2,r2,119
 32489dc:	10000a1e 	bne	r2,zero,3248a08 <vfopen_locked+0x9c>
 32489e0:	e0bffc17 	ldw	r2,-16(fp)
 32489e4:	1080058b 	ldhu	r2,22(r2)
 32489e8:	10bfffcc 	andi	r2,r2,65535
 32489ec:	1080080c 	andi	r2,r2,32
 32489f0:	1004c03a 	cmpne	r2,r2,zero
 32489f4:	1000041e 	bne	r2,zero,3248a08 <vfopen_locked+0x9c>
      {
         set_vfopen_error(ENP_FILEIO);
 32489f8:	013ff984 	movi	r4,-26
 32489fc:	32487800 	call	3248780 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("mode w with no VF_WRITE\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 3248a00:	e03fff15 	stw	zero,-4(fp)
 3248a04:	0000ad06 	br	3248cbc <vfopen_locked+0x350>
      }

#endif   /* HT_RWVFS */

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 3248a08:	32487c80 	call	32487c8 <vf_alloc_and_link_vop>
 3248a0c:	e0bffb15 	stw	r2,-20(fp)

      /* check for failure */
      if (!vop)
 3248a10:	e0bffb17 	ldw	r2,-20(fp)
 3248a14:	1004c03a 	cmpne	r2,r2,zero
 3248a18:	1000041e 	bne	r2,zero,3248a2c <vfopen_locked+0xc0>
      {
         set_vfopen_error(ENP_NOMEM);
 3248a1c:	013ffb04 	movi	r4,-20
 3248a20:	32487800 	call	3248780 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 1\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 3248a24:	e03fff15 	stw	zero,-4(fp)
 3248a28:	0000a406 	br	3248cbc <vfopen_locked+0x350>
      }

      /* link to the file's directory entry structure */
      vop->file = vfp;
 3248a2c:	e0fffb17 	ldw	r3,-20(fp)
 3248a30:	e0bffc17 	ldw	r2,-16(fp)
 3248a34:	18800115 	stw	r2,4(r3)

      /* by default start at the beginning of the file */
      /* note that vfp->data could be NULL at this point since empty
         files might have no data buffer allocated to them */
      vop->cmploc = vfp->data;   /* start at beginning of file */
 3248a38:	e0bffc17 	ldw	r2,-16(fp)
 3248a3c:	10c00617 	ldw	r3,24(r2)
 3248a40:	e0bffb17 	ldw	r2,-20(fp)
 3248a44:	10c00215 	stw	r3,8(r2)

#ifdef HT_RWVFS

      /* if mode begins with 'a', seek to end of file */
      if (*mode == 'a')
 3248a48:	e0bffe17 	ldw	r2,-8(fp)
 3248a4c:	10800003 	ldbu	r2,0(r2)
 3248a50:	10803fcc 	andi	r2,r2,255
 3248a54:	1080201c 	xori	r2,r2,128
 3248a58:	10bfe004 	addi	r2,r2,-128
 3248a5c:	10801858 	cmpnei	r2,r2,97
 3248a60:	10000b1e 	bne	r2,zero,3248a90 <vfopen_locked+0x124>
      {
         if (vfp->data)
 3248a64:	e0bffc17 	ldw	r2,-16(fp)
 3248a68:	10800617 	ldw	r2,24(r2)
 3248a6c:	1005003a 	cmpeq	r2,r2,zero
 3248a70:	1000071e 	bne	r2,zero,3248a90 <vfopen_locked+0x124>
         {
            vop->cmploc = vfp->data + vfp->comp_size;
 3248a74:	e0bffc17 	ldw	r2,-16(fp)
 3248a78:	10c00617 	ldw	r3,24(r2)
 3248a7c:	e0bffc17 	ldw	r2,-16(fp)
 3248a80:	10800817 	ldw	r2,32(r2)
 3248a84:	1887883a 	add	r3,r3,r2
 3248a88:	e0bffb17 	ldw	r2,-20(fp)
 3248a8c:	10c00215 	stw	r3,8(r2)
         }
      }

      /* if mode begins with 'w', truncate to end of file */
      if (*mode == 'w')
 3248a90:	e0bffe17 	ldw	r2,-8(fp)
 3248a94:	10800003 	ldbu	r2,0(r2)
 3248a98:	10803fcc 	andi	r2,r2,255
 3248a9c:	1080201c 	xori	r2,r2,128
 3248aa0:	10bfe004 	addi	r2,r2,-128
 3248aa4:	10801dd8 	cmpnei	r2,r2,119
 3248aa8:	1000111e 	bne	r2,zero,3248af0 <vfopen_locked+0x184>
      {
         /* set the size of the file before compression to 0 */
         vfp->real_size = 0;
 3248aac:	e0bffc17 	ldw	r2,-16(fp)
 3248ab0:	10000715 	stw	zero,28(r2)
         /* set the size of the compressed data to 0 */
         vfp->comp_size = 0;
 3248ab4:	e0bffc17 	ldw	r2,-16(fp)
 3248ab8:	10000815 	stw	zero,32(r2)
         /* note we leave the pointer to the file buffer and its length
            alone since first writes will go to it */
         /* flag that the file has been modified */
         vfp->flags |= VF_STALE;
 3248abc:	e0bffc17 	ldw	r2,-16(fp)
 3248ac0:	1080058b 	ldhu	r2,22(r2)
 3248ac4:	10808014 	ori	r2,r2,512
 3248ac8:	1007883a 	mov	r3,r2
 3248acc:	e0bffc17 	ldw	r2,-16(fp)
 3248ad0:	10c0058d 	sth	r3,22(r2)

         /* turn off the compression flag */
         vfp->flags &= ~VF_HTMLCOMPRESSED;
 3248ad4:	e0bffc17 	ldw	r2,-16(fp)
 3248ad8:	10c0058b 	ldhu	r3,22(r2)
 3248adc:	00bfff84 	movi	r2,-2
 3248ae0:	1884703a 	and	r2,r3,r2
 3248ae4:	1007883a 	mov	r3,r2
 3248ae8:	e0bffc17 	ldw	r2,-16(fp)
 3248aec:	10c0058d 	sth	r3,22(r2)
      }

#endif   /* HT_RWVFS */

      return vop;
 3248af0:	e0bffb17 	ldw	r2,-20(fp)
 3248af4:	e0bfff15 	stw	r2,-4(fp)
 3248af8:	00007006 	br	3248cbc <vfopen_locked+0x350>

#ifdef HT_EXTDEV

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 3248afc:	e0bffe17 	ldw	r2,-8(fp)
 3248b00:	10800003 	ldbu	r2,0(r2)
 3248b04:	10803fcc 	andi	r2,r2,255
 3248b08:	1080201c 	xori	r2,r2,128
 3248b0c:	10bfe004 	addi	r2,r2,-128
 3248b10:	10801ca0 	cmpeqi	r2,r2,114
 3248b14:	1000151e 	bne	r2,zero,3248b6c <vfopen_locked+0x200>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 3248b18:	d0a90b17 	ldw	r2,-23508(gp)
 3248b1c:	e0bffa15 	stw	r2,-24(fp)
 3248b20:	00000f06 	br	3248b60 <vfopen_locked+0x1f4>
      {
         if ((vop = vfs->r_fopen(name, mode)) != NULL)
 3248b24:	e0bffa17 	ldw	r2,-24(fp)
 3248b28:	10800117 	ldw	r2,4(r2)
 3248b2c:	e13ffd17 	ldw	r4,-12(fp)
 3248b30:	e17ffe17 	ldw	r5,-8(fp)
 3248b34:	103ee83a 	callr	r2
 3248b38:	e0bffb15 	stw	r2,-20(fp)
 3248b3c:	e0bffb17 	ldw	r2,-20(fp)
 3248b40:	1005003a 	cmpeq	r2,r2,zero
 3248b44:	1000031e 	bne	r2,zero,3248b54 <vfopen_locked+0x1e8>
         {
            return vop;
 3248b48:	e0bffb17 	ldw	r2,-20(fp)
 3248b4c:	e0bfff15 	stw	r2,-4(fp)
 3248b50:	00005a06 	br	3248cbc <vfopen_locked+0x350>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 3248b54:	e0bffa17 	ldw	r2,-24(fp)
 3248b58:	10800017 	ldw	r2,0(r2)
 3248b5c:	e0bffa15 	stw	r2,-24(fp)
 3248b60:	e0bffa17 	ldw	r2,-24(fp)
 3248b64:	1004c03a 	cmpne	r2,r2,zero
 3248b68:	103fee1e 	bne	r2,zero,3248b24 <vfopen_locked+0x1b8>

#ifdef HT_RWVFS

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 3248b6c:	e0bffe17 	ldw	r2,-8(fp)
 3248b70:	10800003 	ldbu	r2,0(r2)
 3248b74:	10803fcc 	andi	r2,r2,255
 3248b78:	1080201c 	xori	r2,r2,128
 3248b7c:	10bfe004 	addi	r2,r2,-128
 3248b80:	10801ca0 	cmpeqi	r2,r2,114
 3248b84:	10004a1e 	bne	r2,zero,3248cb0 <vfopen_locked+0x344>
   {
      /* enforce maximum number of files */
      if (vfs_total_dyna_files >= VFS_MAX_DYNA_FILES)
 3248b88:	d0a91217 	ldw	r2,-23480(gp)
 3248b8c:	10803ff0 	cmpltui	r2,r2,255
 3248b90:	1000041e 	bne	r2,zero,3248ba4 <vfopen_locked+0x238>
      {
         set_vfopen_error(ENP_NOMEM);
 3248b94:	013ffb04 	movi	r4,-20
 3248b98:	32487800 	call	3248780 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_total_dyna_files too big in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 3248b9c:	e03fff15 	stw	zero,-4(fp)
 3248ba0:	00004606 	br	3248cbc <vfopen_locked+0x350>
      }

      /* make sure the file name is not too long for the VFS */
      if (strlen(name) > FILENAMEMAX)
 3248ba4:	e13ffd17 	ldw	r4,-12(fp)
 3248ba8:	32081440 	call	3208144 <strlen>
 3248bac:	10800470 	cmpltui	r2,r2,17
 3248bb0:	1000041e 	bne	r2,zero,3248bc4 <vfopen_locked+0x258>
      {
         set_vfopen_error(ENP_PARAM);
 3248bb4:	013ffd84 	movi	r4,-10
 3248bb8:	32487800 	call	3248780 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("file name too long in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 3248bbc:	e03fff15 	stw	zero,-4(fp)
 3248bc0:	00003e06 	br	3248cbc <vfopen_locked+0x350>
      }

      /* allocate a vfs_file structure to hold the new file entry in */
      vfp = VFS_VFS_FILE_ALLOC();
 3248bc4:	01000b04 	movi	r4,44
 3248bc8:	322b5d00 	call	322b5d0 <npalloc>
 3248bcc:	e0bffc15 	stw	r2,-16(fp)

      /* check for memory allocation failure */
      if (!vfp)
 3248bd0:	e0bffc17 	ldw	r2,-16(fp)
 3248bd4:	1004c03a 	cmpne	r2,r2,zero
 3248bd8:	1000041e 	bne	r2,zero,3248bec <vfopen_locked+0x280>
      {
         set_vfopen_error(ENP_NOMEM);
 3248bdc:	013ffb04 	movi	r4,-20
 3248be0:	32487800 	call	3248780 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("VFS_VFS_FILE_ALLOC() failed in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 3248be4:	e03fff15 	stw	zero,-4(fp)
 3248be8:	00003406 	br	3248cbc <vfopen_locked+0x350>
      }

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 3248bec:	32487c80 	call	32487c8 <vf_alloc_and_link_vop>
 3248bf0:	e0bffb15 	stw	r2,-20(fp)

      /* check for memory allocation failure */
      if (!vop)
 3248bf4:	e0bffb17 	ldw	r2,-20(fp)
 3248bf8:	1004c03a 	cmpne	r2,r2,zero
 3248bfc:	1000061e 	bne	r2,zero,3248c18 <vfopen_locked+0x2ac>
      {
         VFS_VFS_FILE_FREE(vfp); /* free the allocated vfs_file entry */
 3248c00:	e13ffc17 	ldw	r4,-16(fp)
 3248c04:	322b6c40 	call	322b6c4 <npfree>
         set_vfopen_error(ENP_NOMEM);
 3248c08:	013ffb04 	movi	r4,-20
 3248c0c:	32487800 	call	3248780 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 2\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 3248c10:	e03fff15 	stw	zero,-4(fp)
 3248c14:	00002906 	br	3248cbc <vfopen_locked+0x350>
      }

      /* add the vfs_file structure to the head of the list */

      vfp->next = vfsfiles;
 3248c18:	d0e90d17 	ldw	r3,-23500(gp)
 3248c1c:	e0bffc17 	ldw	r2,-16(fp)
 3248c20:	10c00015 	stw	r3,0(r2)
      vfsfiles = vfp;
 3248c24:	e0bffc17 	ldw	r2,-16(fp)
 3248c28:	d0a90d15 	stw	r2,-23500(gp)

      /* increment count of total files */
      vfs_total_dyna_files++;
 3248c2c:	d0a91217 	ldw	r2,-23480(gp)
 3248c30:	10800044 	addi	r2,r2,1
 3248c34:	d0a91215 	stw	r2,-23480(gp)

      /* remove leading directory separator before storing name */
      if (*name == '/' || *name == '\\')
 3248c38:	e0bffd17 	ldw	r2,-12(fp)
 3248c3c:	10800003 	ldbu	r2,0(r2)
 3248c40:	10803fcc 	andi	r2,r2,255
 3248c44:	1080201c 	xori	r2,r2,128
 3248c48:	10bfe004 	addi	r2,r2,-128
 3248c4c:	10800be0 	cmpeqi	r2,r2,47
 3248c50:	1000071e 	bne	r2,zero,3248c70 <vfopen_locked+0x304>
 3248c54:	e0bffd17 	ldw	r2,-12(fp)
 3248c58:	10800003 	ldbu	r2,0(r2)
 3248c5c:	10803fcc 	andi	r2,r2,255
 3248c60:	1080201c 	xori	r2,r2,128
 3248c64:	10bfe004 	addi	r2,r2,-128
 3248c68:	10801718 	cmpnei	r2,r2,92
 3248c6c:	1000031e 	bne	r2,zero,3248c7c <vfopen_locked+0x310>
         name++;
 3248c70:	e0bffd17 	ldw	r2,-12(fp)
 3248c74:	10800044 	addi	r2,r2,1
 3248c78:	e0bffd15 	stw	r2,-12(fp)

      /* store the converted name in the directory entry structure */
      strcpy(vfp->name,name);
 3248c7c:	e0bffc17 	ldw	r2,-16(fp)
 3248c80:	11000104 	addi	r4,r2,4
 3248c84:	e17ffd17 	ldw	r5,-12(fp)
 3248c88:	324b9d00 	call	324b9d0 <strcpy>

      /* set the flags */
      vfp->flags = VF_DYNAMICINFO   /* the directory entry was allocated */
 3248c8c:	e0fffc17 	ldw	r3,-16(fp)
 3248c90:	0080d804 	movi	r2,864
 3248c94:	1880058d 	sth	r2,22(r3)
       * note that this means the data pointer contains a null 
       * because we don't allocate any buffer to hold the data 
       * in until the first write 
       */
      /* link to the file's directory entry structure */
      vop->file = vfp;
 3248c98:	e0fffb17 	ldw	r3,-20(fp)
 3248c9c:	e0bffc17 	ldw	r2,-16(fp)
 3248ca0:	18800115 	stw	r2,4(r3)
      /* the cmploc and tag fields of the vop retain their NULLs from 
       * npalloc(). cmploc contains NULL because there is no data 
       * buffer to point to yet. tag contains NULL because no 
       * decompression operation has started yet
       */
      return vop;
 3248ca4:	e0bffb17 	ldw	r2,-20(fp)
 3248ca8:	e0bfff15 	stw	r2,-4(fp)
 3248cac:	00000306 	br	3248cbc <vfopen_locked+0x350>
   /* pass the open to the local file system */
   return (VFILE *) fopen(name,mode);

#else

   set_vfopen_error(ENP_NOFILE);
 3248cb0:	013ff9c4 	movi	r4,-25
 3248cb4:	32487800 	call	3248780 <set_vfopen_error>
#ifdef VFS_VERBOSE
   dprintf("fell thru to end of vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
   return NULL;
 3248cb8:	e03fff15 	stw	zero,-4(fp)
 3248cbc:	e0bfff17 	ldw	r2,-4(fp)

#endif   /* HT_LOCALFS */
}
 3248cc0:	e037883a 	mov	sp,fp
 3248cc4:	dfc00117 	ldw	ra,4(sp)
 3248cc8:	df000017 	ldw	fp,0(sp)
 3248ccc:	dec00204 	addi	sp,sp,8
 3248cd0:	f800283a 	ret

03248cd4 <vfopen>:
 * RETURNS: 
 */

VFILE *
vfopen(char * name, char * mode)
{
 3248cd4:	defffb04 	addi	sp,sp,-20
 3248cd8:	dfc00415 	stw	ra,16(sp)
 3248cdc:	df000315 	stw	fp,12(sp)
 3248ce0:	df000304 	addi	fp,sp,12
 3248ce4:	e13ffe15 	stw	r4,-8(fp)
 3248ce8:	e17fff15 	stw	r5,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfopen() passed >%s<,%s\n",name,mode);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 3248cec:	01000144 	movi	r4,5
 3248cf0:	322b1880 	call	322b188 <wait_app_sem>

   vfd = vfopen_locked(name,mode);
 3248cf4:	e13ffe17 	ldw	r4,-8(fp)
 3248cf8:	e17fff17 	ldw	r5,-4(fp)
 3248cfc:	324896c0 	call	324896c <vfopen_locked>
 3248d00:	e0bffd15 	stw	r2,-12(fp)

   vfs_unlock();
 3248d04:	01000144 	movi	r4,5
 3248d08:	322b23c0 	call	322b23c <post_app_sem>

   return vfd;
 3248d0c:	e0bffd17 	ldw	r2,-12(fp)
}
 3248d10:	e037883a 	mov	sp,fp
 3248d14:	dfc00117 	ldw	ra,4(sp)
 3248d18:	df000017 	ldw	fp,0(sp)
 3248d1c:	dec00204 	addi	sp,sp,8
 3248d20:	f800283a 	ret

03248d24 <vfclose_locked>:
 * RETURNS: 
 */

void 
vfclose_locked(VFILE * vfd)
{
 3248d24:	defff804 	addi	sp,sp,-32
 3248d28:	dfc00715 	stw	ra,28(sp)
 3248d2c:	df000615 	stw	fp,24(sp)
 3248d30:	df000604 	addi	fp,sp,24
 3248d34:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;
   VFILE * vlast;

   vlast = NULL;
 3248d38:	e03ffd15 	stw	zero,-12(fp)

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
 3248d3c:	d0a90c17 	ldw	r2,-23504(gp)
 3248d40:	e0bffe15 	stw	r2,-8(fp)
   while (vtmp)
 3248d44:	00000806 	br	3248d68 <vfclose_locked+0x44>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
 3248d48:	e0ffff17 	ldw	r3,-4(fp)
 3248d4c:	e0bffe17 	ldw	r2,-8(fp)
 3248d50:	18800826 	beq	r3,r2,3248d74 <vfclose_locked+0x50>
         break;

      /* bump the next and previous pointers along to try the next one */
      vlast = vtmp;
 3248d54:	e0bffe17 	ldw	r2,-8(fp)
 3248d58:	e0bffd15 	stw	r2,-12(fp)
      vtmp = vtmp->next;
 3248d5c:	e0bffe17 	ldw	r2,-8(fp)
 3248d60:	10800017 	ldw	r2,0(r2)
 3248d64:	e0bffe15 	stw	r2,-8(fp)
   vlast = NULL;

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
   while (vtmp)
 3248d68:	e0bffe17 	ldw	r2,-8(fp)
 3248d6c:	1004c03a 	cmpne	r2,r2,zero
 3248d70:	103ff51e 	bne	r2,zero,3248d48 <vfclose_locked+0x24>
      vlast = vtmp;
      vtmp = vtmp->next;
   }

   /* if the passed in handle was not in the list we maintain */
   if (vfd != vtmp)
 3248d74:	e0ffff17 	ldw	r3,-4(fp)
 3248d78:	e0bffe17 	ldw	r2,-8(fp)
 3248d7c:	18804e1e 	bne	r3,r2,3248eb8 <vfclose_locked+0x194>

   /* this not really a forever loop. it exists so we can break easily
      and deal with all the ifdefs */
   while (1)
   {
      struct vfs_file * vfp   =  vfd->file;
 3248d80:	e0bfff17 	ldw	r2,-4(fp)
 3248d84:	10800117 	ldw	r2,4(r2)
 3248d88:	e0bffc15 	stw	r2,-16(fp)
      /* vfd->file will be null if somebody unlinked the file after
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
 3248d8c:	e0bffc17 	ldw	r2,-16(fp)
 3248d90:	1005003a 	cmpeq	r2,r2,zero
 3248d94:	1000381e 	bne	r2,zero,3248e78 <vfclose_locked+0x154>
         break;
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 3248d98:	e0bffc17 	ldw	r2,-16(fp)
 3248d9c:	10800a17 	ldw	r2,40(r2)
 3248da0:	1005003a 	cmpeq	r2,r2,zero
 3248da4:	1000081e 	bne	r2,zero,3248dc8 <vfclose_locked+0xa4>
      {
         /* call that file system's fclose() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)(vfp->method);
 3248da8:	e0bffc17 	ldw	r2,-16(fp)
 3248dac:	10800a17 	ldw	r2,40(r2)
 3248db0:	e0bffa15 	stw	r2,-24(fp)

         vfs->r_fclose(vfd);
 3248db4:	e0bffa17 	ldw	r2,-24(fp)
 3248db8:	10800217 	ldw	r2,8(r2)
 3248dbc:	e13fff17 	ldw	r4,-4(fp)
 3248dc0:	103ee83a 	callr	r2
         break;   /* break to list deletion code after end of phoney loop */
 3248dc4:	00002c06 	br	3248e78 <vfclose_locked+0x154>

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 3248dc8:	e0bffc17 	ldw	r2,-16(fp)
 3248dcc:	1080058b 	ldhu	r2,22(r2)
 3248dd0:	10bfffcc 	andi	r2,r2,65535
 3248dd4:	1080200c 	andi	r2,r2,128
 3248dd8:	1005003a 	cmpeq	r2,r2,zero
 3248ddc:	1000261e 	bne	r2,zero,3248e78 <vfclose_locked+0x154>
 3248de0:	e0bffc17 	ldw	r2,-16(fp)
 3248de4:	10c00917 	ldw	r3,36(r2)
 3248de8:	e0bffc17 	ldw	r2,-16(fp)
 3248dec:	10800817 	ldw	r2,32(r2)
 3248df0:	1885c83a 	sub	r2,r3,r2
 3248df4:	10804030 	cmpltui	r2,r2,256
 3248df8:	10001f1e 	bne	r2,zero,3248e78 <vfclose_locked+0x154>
 3248dfc:	e0bffc17 	ldw	r2,-16(fp)
 3248e00:	10800617 	ldw	r2,24(r2)
 3248e04:	1005003a 	cmpeq	r2,r2,zero
 3248e08:	10001b1e 	bne	r2,zero,3248e78 <vfclose_locked+0x154>
          vfp->data) /* this last test is a sanity check */
      {
         /* try to reclaim the unused data */

         /* allocate a new buffer just big enough for the data */
         new_buffer = vf_alloc_buffer(vfp->comp_size);
 3248e0c:	e0bffc17 	ldw	r2,-16(fp)
 3248e10:	11000817 	ldw	r4,32(r2)
 3248e14:	32488440 	call	3248844 <vf_alloc_buffer>
 3248e18:	e0bffb15 	stw	r2,-20(fp)

         /* if the allocation worked */
         if (new_buffer)
 3248e1c:	e0bffb17 	ldw	r2,-20(fp)
 3248e20:	1005003a 	cmpeq	r2,r2,zero
 3248e24:	1000141e 	bne	r2,zero,3248e78 <vfclose_locked+0x154>
         {
            /* copy the old buffer to the new one */
            MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 3248e28:	e0bffc17 	ldw	r2,-16(fp)
 3248e2c:	10c00617 	ldw	r3,24(r2)
 3248e30:	e0bffc17 	ldw	r2,-16(fp)
 3248e34:	11800817 	ldw	r6,32(r2)
 3248e38:	e0bffb17 	ldw	r2,-20(fp)
 3248e3c:	1009883a 	mov	r4,r2
 3248e40:	180b883a 	mov	r5,r3
 3248e44:	32067cc0 	call	32067cc <memcpy>
            /* free the old buffer */
            vf_free_buffer(vfp->data,vfp->buf_size);
 3248e48:	e0bffc17 	ldw	r2,-16(fp)
 3248e4c:	11000617 	ldw	r4,24(r2)
 3248e50:	e0bffc17 	ldw	r2,-16(fp)
 3248e54:	11400917 	ldw	r5,36(r2)
 3248e58:	324891c0 	call	324891c <vf_free_buffer>
            /* update the buffer pointer and size to reflect the
               just big enough buffer */
            vfp->data = new_buffer;
 3248e5c:	e0fffc17 	ldw	r3,-16(fp)
 3248e60:	e0bffb17 	ldw	r2,-20(fp)
 3248e64:	18800615 	stw	r2,24(r3)
            vfp->buf_size = vfp->comp_size;
 3248e68:	e0bffc17 	ldw	r2,-16(fp)
 3248e6c:	10c00817 	ldw	r3,32(r2)
 3248e70:	e0bffc17 	ldw	r2,-16(fp)
 3248e74:	10c00915 	stw	r3,36(r2)
      /* break to list deletion code below */
      break;

   }

   if (vlast)  /* unlink from list of open files */
 3248e78:	e0bffd17 	ldw	r2,-12(fp)
 3248e7c:	1005003a 	cmpeq	r2,r2,zero
 3248e80:	1000051e 	bne	r2,zero,3248e98 <vfclose_locked+0x174>
      vlast->next = vtmp->next;
 3248e84:	e0bffe17 	ldw	r2,-8(fp)
 3248e88:	10c00017 	ldw	r3,0(r2)
 3248e8c:	e0bffd17 	ldw	r2,-12(fp)
 3248e90:	10c00015 	stw	r3,0(r2)
 3248e94:	00000306 	br	3248ea4 <vfclose_locked+0x180>
   else
      vfiles = vtmp->next;
 3248e98:	e0bffe17 	ldw	r2,-8(fp)
 3248e9c:	10800017 	ldw	r2,0(r2)
 3248ea0:	d0a90c15 	stw	r2,-23504(gp)

   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
 3248ea4:	e13ffe17 	ldw	r4,-8(fp)
 3248ea8:	322b6c40 	call	322b6c4 <npfree>
   /* decrement the number of open files */
   vfs_open_files--;
 3248eac:	d0a91017 	ldw	r2,-23488(gp)
 3248eb0:	10bfffc4 	addi	r2,r2,-1
 3248eb4:	d0a91015 	stw	r2,-23488(gp)
   return;
}
 3248eb8:	e037883a 	mov	sp,fp
 3248ebc:	dfc00117 	ldw	ra,4(sp)
 3248ec0:	df000017 	ldw	fp,0(sp)
 3248ec4:	dec00204 	addi	sp,sp,8
 3248ec8:	f800283a 	ret

03248ecc <vfclose>:
 *
 * RETURNS: 
 */

void vfclose(VFILE * vfd)
{
 3248ecc:	defffd04 	addi	sp,sp,-12
 3248ed0:	dfc00215 	stw	ra,8(sp)
 3248ed4:	df000115 	stw	fp,4(sp)
 3248ed8:	df000104 	addi	fp,sp,4
 3248edc:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 3248ee0:	01000144 	movi	r4,5
 3248ee4:	322b1880 	call	322b188 <wait_app_sem>

   vfclose_locked(vfd);
 3248ee8:	e13fff17 	ldw	r4,-4(fp)
 3248eec:	3248d240 	call	3248d24 <vfclose_locked>

   vfs_unlock();
 3248ef0:	01000144 	movi	r4,5
 3248ef4:	322b23c0 	call	322b23c <post_app_sem>
}
 3248ef8:	e037883a 	mov	sp,fp
 3248efc:	dfc00117 	ldw	ra,4(sp)
 3248f00:	df000017 	ldw	fp,0(sp)
 3248f04:	dec00204 	addi	sp,sp,8
 3248f08:	f800283a 	ret

03248f0c <vfflush>:
 *
 * RETURNS: 
 */

int vfflush(VFILE * vfd)
{
 3248f0c:	defffd04 	addi	sp,sp,-12
 3248f10:	dfc00215 	stw	ra,8(sp)
 3248f14:	df000115 	stw	fp,4(sp)
 3248f18:	df000104 	addi	fp,sp,4
 3248f1c:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 3248f20:	01000144 	movi	r4,5
 3248f24:	322b1880 	call	322b188 <wait_app_sem>

   printf("vfflush(): This function needs to be implemented\n");
 3248f28:	0100c974 	movhi	r4,805
 3248f2c:	2100b704 	addi	r4,r4,732
 3248f30:	3206e040 	call	3206e04 <puts>

   vfs_unlock();
 3248f34:	01000144 	movi	r4,5
 3248f38:	322b23c0 	call	322b23c <post_app_sem>
   return(0);
 3248f3c:	0005883a 	mov	r2,zero
}
 3248f40:	e037883a 	mov	sp,fp
 3248f44:	dfc00117 	ldw	ra,4(sp)
 3248f48:	df000017 	ldw	fp,0(sp)
 3248f4c:	dec00204 	addi	sp,sp,8
 3248f50:	f800283a 	ret

03248f54 <vfgets>:

char * vfgets(char * s, int lim, VFILE * fp) 
{
 3248f54:	defff804 	addi	sp,sp,-32
 3248f58:	dfc00715 	stw	ra,28(sp)
 3248f5c:	df000615 	stw	fp,24(sp)
 3248f60:	df000604 	addi	fp,sp,24
 3248f64:	e13ffc15 	stw	r4,-16(fp)
 3248f68:	e17ffd15 	stw	r5,-12(fp)
 3248f6c:	e1bffe15 	stw	r6,-8(fp)
   int c;
   char * ret;

   ret = s;
 3248f70:	e0bffc17 	ldw	r2,-16(fp)
 3248f74:	e0bffa15 	stw	r2,-24(fp)
   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 3248f78:	00001106 	br	3248fc0 <vfgets+0x6c>
      if (( *ret ++ = c) == '\n')
 3248f7c:	e0bffb17 	ldw	r2,-20(fp)
 3248f80:	1007883a 	mov	r3,r2
 3248f84:	e0bffa17 	ldw	r2,-24(fp)
 3248f88:	10c00005 	stb	r3,0(r2)
 3248f8c:	e0bffa17 	ldw	r2,-24(fp)
 3248f90:	10800003 	ldbu	r2,0(r2)
 3248f94:	10803fcc 	andi	r2,r2,255
 3248f98:	1080201c 	xori	r2,r2,128
 3248f9c:	10bfe004 	addi	r2,r2,-128
 3248fa0:	108002a0 	cmpeqi	r2,r2,10
 3248fa4:	1007883a 	mov	r3,r2
 3248fa8:	e0bffa17 	ldw	r2,-24(fp)
 3248fac:	10800044 	addi	r2,r2,1
 3248fb0:	e0bffa15 	stw	r2,-24(fp)
 3248fb4:	18803fcc 	andi	r2,r3,255
 3248fb8:	1004c03a 	cmpne	r2,r2,zero
 3248fbc:	10000c1e 	bne	r2,zero,3248ff0 <vfgets+0x9c>
{
   int c;
   char * ret;

   ret = s;
   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 3248fc0:	e0bffd17 	ldw	r2,-12(fp)
 3248fc4:	10bfffc4 	addi	r2,r2,-1
 3248fc8:	e0bffd15 	stw	r2,-12(fp)
 3248fcc:	e0bffd17 	ldw	r2,-12(fp)
 3248fd0:	10800050 	cmplti	r2,r2,1
 3248fd4:	1000061e 	bne	r2,zero,3248ff0 <vfgets+0x9c>
 3248fd8:	e13ffe17 	ldw	r4,-8(fp)
 3248fdc:	3249cd00 	call	3249cd0 <vgetc>
 3248fe0:	e0bffb15 	stw	r2,-20(fp)
 3248fe4:	e0bffb17 	ldw	r2,-20(fp)
 3248fe8:	10bfffd8 	cmpnei	r2,r2,-1
 3248fec:	103fe31e 	bne	r2,zero,3248f7c <vfgets+0x28>
      if (( *ret ++ = c) == '\n')
         break;
   *ret = '\0';
 3248ff0:	e0bffa17 	ldw	r2,-24(fp)
 3248ff4:	10000005 	stb	zero,0(r2)
   return ( c == EOF && ret == s) ? NULL : s;
 3248ff8:	e0bffb17 	ldw	r2,-20(fp)
 3248ffc:	10bfffd8 	cmpnei	r2,r2,-1
 3249000:	1000031e 	bne	r2,zero,3249010 <vfgets+0xbc>
 3249004:	e0fffa17 	ldw	r3,-24(fp)
 3249008:	e0bffc17 	ldw	r2,-16(fp)
 324900c:	18800326 	beq	r3,r2,324901c <vfgets+0xc8>
 3249010:	e0bffc17 	ldw	r2,-16(fp)
 3249014:	e0bfff15 	stw	r2,-4(fp)
 3249018:	00000106 	br	3249020 <vfgets+0xcc>
 324901c:	e03fff15 	stw	zero,-4(fp)
 3249020:	e0bfff17 	ldw	r2,-4(fp)
}
 3249024:	e037883a 	mov	sp,fp
 3249028:	dfc00117 	ldw	ra,4(sp)
 324902c:	df000017 	ldw	fp,0(sp)
 3249030:	dec00204 	addi	sp,sp,8
 3249034:	f800283a 	ret

03249038 <vfeof>:
 *
 * RETURNS: 1 if the file pointer is at EOF, otherwise 0
 */
 
int vfeof(VFILE * vfd)
{
 3249038:	defffb04 	addi	sp,sp,-20
 324903c:	dfc00415 	stw	ra,16(sp)
 3249040:	df000315 	stw	fp,12(sp)
 3249044:	df000304 	addi	fp,sp,12
 3249048:	e13ffe15 	stw	r4,-8(fp)
   int c = 0;
 324904c:	e03ffd15 	stw	zero,-12(fp)

#ifdef HT_LOCALFS
   return(feof((FILE*)vfd));
#endif
   if ((c = vgetc(vfd)) == EOF )
 3249050:	e13ffe17 	ldw	r4,-8(fp)
 3249054:	3249cd00 	call	3249cd0 <vgetc>
 3249058:	e0bffd15 	stw	r2,-12(fp)
 324905c:	e0bffd17 	ldw	r2,-12(fp)
 3249060:	10bfffd8 	cmpnei	r2,r2,-1
 3249064:	1000031e 	bne	r2,zero,3249074 <vfeof+0x3c>
   {
      return 1;
 3249068:	00800044 	movi	r2,1
 324906c:	e0bfff15 	stw	r2,-4(fp)
 3249070:	00000106 	br	3249078 <vfeof+0x40>
   }   
   return 0;
 3249074:	e03fff15 	stw	zero,-4(fp)
 3249078:	e0bfff17 	ldw	r2,-4(fp)
}
 324907c:	e037883a 	mov	sp,fp
 3249080:	dfc00117 	ldw	ra,4(sp)
 3249084:	df000017 	ldw	fp,0(sp)
 3249088:	dec00204 	addi	sp,sp,8
 324908c:	f800283a 	ret

03249090 <vunlink_flag_open_files>:
 *
 * RETURNS: 
 */

void vunlink_flag_open_files(struct vfs_file * vfp)
{
 3249090:	defffd04 	addi	sp,sp,-12
 3249094:	df000215 	stw	fp,8(sp)
 3249098:	df000204 	addi	fp,sp,8
 324909c:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 32490a0:	d0a90c17 	ldw	r2,-23504(gp)
 32490a4:	e0bffe15 	stw	r2,-8(fp)
 32490a8:	00000906 	br	32490d0 <vunlink_flag_open_files+0x40>
   {
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
 32490ac:	e0bffe17 	ldw	r2,-8(fp)
 32490b0:	10c00117 	ldw	r3,4(r2)
 32490b4:	e0bfff17 	ldw	r2,-4(fp)
 32490b8:	1880021e 	bne	r3,r2,32490c4 <vunlink_flag_open_files+0x34>
         vtmp->file = NULL;
 32490bc:	e0bffe17 	ldw	r2,-8(fp)
 32490c0:	10000115 	stw	zero,4(r2)
void vunlink_flag_open_files(struct vfs_file * vfp)
{
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 32490c4:	e0bffe17 	ldw	r2,-8(fp)
 32490c8:	10800017 	ldw	r2,0(r2)
 32490cc:	e0bffe15 	stw	r2,-8(fp)
 32490d0:	e0bffe17 	ldw	r2,-8(fp)
 32490d4:	1004c03a 	cmpne	r2,r2,zero
 32490d8:	103ff41e 	bne	r2,zero,32490ac <vunlink_flag_open_files+0x1c>
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
         vtmp->file = NULL;
   }
}
 32490dc:	e037883a 	mov	sp,fp
 32490e0:	df000017 	ldw	fp,0(sp)
 32490e4:	dec00104 	addi	sp,sp,4
 32490e8:	f800283a 	ret

032490ec <vunlink>:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
int
vunlink(const char * const_name)
{
 32490ec:	defff504 	addi	sp,sp,-44
 32490f0:	dfc00a15 	stw	ra,40(sp)
 32490f4:	df000915 	stw	fp,36(sp)
 32490f8:	df000904 	addi	fp,sp,36
 32490fc:	e13ffe15 	stw	r4,-8(fp)
   struct vfs_file * vfp;
   int   rc =  0;
 3249100:	e03ffc15 	stw	zero,-16(fp)
/*
 * Altera Niche Stack Nios port modification:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
   char * name = malloc(strlen(const_name));
 3249104:	e13ffe17 	ldw	r4,-8(fp)
 3249108:	32081440 	call	3208144 <strlen>
 324910c:	1009883a 	mov	r4,r2
 3249110:	324b9480 	call	324b948 <malloc>
 3249114:	e0bff815 	stw	r2,-32(fp)
   strcpy(name, const_name);
 3249118:	e13ff817 	ldw	r4,-32(fp)
 324911c:	e17ffe17 	ldw	r5,-8(fp)
 3249120:	324b9d00 	call	324b9d0 <strcpy>
   if (vfs_log_file_name)
      dprintf("vunlink() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 3249124:	01000144 	movi	r4,5
 3249128:	322b1880 	call	322b188 <wait_app_sem>

   /* see if the converted name is one of the one's in our list */
   /* if it isn't */
   if ((vfp = vfslookup_locked(name)) == NULL)
 324912c:	e13ff817 	ldw	r4,-32(fp)
 3249130:	3249d180 	call	3249d18 <vfslookup_locked>
 3249134:	e0bffd15 	stw	r2,-12(fp)
 3249138:	e0bffd17 	ldw	r2,-12(fp)
 324913c:	1004c03a 	cmpne	r2,r2,zero
 3249140:	1000071e 	bne	r2,zero,3249160 <vunlink+0x74>
   {
      vfs_unlock();
 3249144:	01000144 	movi	r4,5
 3249148:	322b23c0 	call	322b23c <post_app_sem>
#ifdef HT_LOCALFS
      /* default to call on local system */
      return remove(name);
#else
      /* no local file system, so return error condition */
      free(name);
 324914c:	e13ff817 	ldw	r4,-32(fp)
 3249150:	324b9340 	call	324b934 <free>
      return -1;
 3249154:	00bfffc4 	movi	r2,-1
 3249158:	e0bfff15 	stw	r2,-4(fp)
 324915c:	00006506 	br	32492f4 <vunlink+0x208>
#ifdef   HT_RWVFS
   /* save the next link pointer since in one path through the code, 
    * the vfs_file structure gets freed before its unlinked from the 
    * list
    */
   vfnext = vfp->next;
 3249160:	e0bffd17 	ldw	r2,-12(fp)
 3249164:	10800017 	ldw	r2,0(r2)
 3249168:	e0bff915 	stw	r2,-28(fp)

   /* search list of files to determine predecessor in list */
   vflast = NULL;
 324916c:	e03ffa15 	stw	zero,-24(fp)
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 3249170:	d0a90d17 	ldw	r2,-23500(gp)
 3249174:	e0bffb15 	stw	r2,-20(fp)
 3249178:	00000806 	br	324919c <vunlink+0xb0>
   {
      if (vtmp == vfp)
 324917c:	e0fffb17 	ldw	r3,-20(fp)
 3249180:	e0bffd17 	ldw	r2,-12(fp)
 3249184:	18800826 	beq	r3,r2,32491a8 <vunlink+0xbc>
         break;
      vflast = vtmp;
 3249188:	e0bffb17 	ldw	r2,-20(fp)
 324918c:	e0bffa15 	stw	r2,-24(fp)
    */
   vfnext = vfp->next;

   /* search list of files to determine predecessor in list */
   vflast = NULL;
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 3249190:	e0bffb17 	ldw	r2,-20(fp)
 3249194:	10800017 	ldw	r2,0(r2)
 3249198:	e0bffb15 	stw	r2,-20(fp)
 324919c:	e0bffb17 	ldw	r2,-20(fp)
 32491a0:	1004c03a 	cmpne	r2,r2,zero
 32491a4:	103ff51e 	bne	r2,zero,324917c <vunlink+0x90>
      vflast = vtmp;
   }

   /* this shouldn't happen since vfslookup_locked() already searched
      the list, but just in case */
   if (vtmp == NULL)
 32491a8:	e0bffb17 	ldw	r2,-20(fp)
 32491ac:	1004c03a 	cmpne	r2,r2,zero
 32491b0:	1000081e 	bne	r2,zero,32491d4 <vunlink+0xe8>
   {
      dtrap();
 32491b4:	322ab8c0 	call	322ab8c <dtrap>
      vfs_unlock();
 32491b8:	01000144 	movi	r4,5
 32491bc:	322b23c0 	call	322b23c <post_app_sem>
      free(name);
 32491c0:	e13ff817 	ldw	r4,-32(fp)
 32491c4:	324b9340 	call	324b934 <free>
      return -1;
 32491c8:	00bfffc4 	movi	r2,-1
 32491cc:	e0bfff15 	stw	r2,-4(fp)
 32491d0:	00004806 	br	32492f4 <vunlink+0x208>
   while (1)
   {

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 32491d4:	e0bffd17 	ldw	r2,-12(fp)
 32491d8:	10800a17 	ldw	r2,40(r2)
 32491dc:	1005003a 	cmpeq	r2,r2,zero
 32491e0:	1000091e 	bne	r2,zero,3249208 <vunlink+0x11c>
      {
         /* call that file system's unlink() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfp->method);
 32491e4:	e0bffd17 	ldw	r2,-12(fp)
 32491e8:	10800a17 	ldw	r2,40(r2)
 32491ec:	e0bff715 	stw	r2,-36(fp)

         rc = vfs->r_unlink(name);
 32491f0:	e0bff717 	ldw	r2,-36(fp)
 32491f4:	10800817 	ldw	r2,32(r2)
 32491f8:	e13ff817 	ldw	r4,-32(fp)
 32491fc:	103ee83a 	callr	r2
 3249200:	e0bffc15 	stw	r2,-16(fp)
         break;   /* break to list deletion code after end of phoney loop */
 3249204:	00002806 	br	32492a8 <vunlink+0x1bc>
      }
#endif   /* HT_EXTDEV */

      /* if the file is not write enabled, return error condition */
      if (!(vfp->flags & VF_WRITE))
 3249208:	e0bffd17 	ldw	r2,-12(fp)
 324920c:	1080058b 	ldhu	r2,22(r2)
 3249210:	10bfffcc 	andi	r2,r2,65535
 3249214:	1080080c 	andi	r2,r2,32
 3249218:	1004c03a 	cmpne	r2,r2,zero
 324921c:	1000071e 	bne	r2,zero,324923c <vunlink+0x150>
      {
         vfs_unlock();
 3249220:	01000144 	movi	r4,5
 3249224:	322b23c0 	call	322b23c <post_app_sem>
         free(name);
 3249228:	e13ff817 	ldw	r4,-32(fp)
 324922c:	324b9340 	call	324b934 <free>
         return -1;
 3249230:	00bfffc4 	movi	r2,-1
 3249234:	e0bfff15 	stw	r2,-4(fp)
 3249238:	00002e06 	br	32492f4 <vunlink+0x208>
      }

      /* if the data buffer containing the file's data was dynamically
         allocated and is not null */
      if ((vfp->flags & VF_DYNAMICDATA) && (vfp->data))
 324923c:	e0bffd17 	ldw	r2,-12(fp)
 3249240:	1080058b 	ldhu	r2,22(r2)
 3249244:	10bfffcc 	andi	r2,r2,65535
 3249248:	1080200c 	andi	r2,r2,128
 324924c:	1005003a 	cmpeq	r2,r2,zero
 3249250:	1000091e 	bne	r2,zero,3249278 <vunlink+0x18c>
 3249254:	e0bffd17 	ldw	r2,-12(fp)
 3249258:	10800617 	ldw	r2,24(r2)
 324925c:	1005003a 	cmpeq	r2,r2,zero
 3249260:	1000051e 	bne	r2,zero,3249278 <vunlink+0x18c>
      {
         /* free the buffer */
         vf_free_buffer(vfp->data,vfp->buf_size);
 3249264:	e0bffd17 	ldw	r2,-12(fp)
 3249268:	11000617 	ldw	r4,24(r2)
 324926c:	e0bffd17 	ldw	r2,-12(fp)
 3249270:	11400917 	ldw	r5,36(r2)
 3249274:	324891c0 	call	324891c <vf_free_buffer>
      }

      /* if the vfs_file structure itself was allocated dynamically */
      if (vfp->flags & VF_DYNAMICINFO)
 3249278:	e0bffd17 	ldw	r2,-12(fp)
 324927c:	1080058b 	ldhu	r2,22(r2)
 3249280:	10bfffcc 	andi	r2,r2,65535
 3249284:	1080100c 	andi	r2,r2,64
 3249288:	1005003a 	cmpeq	r2,r2,zero
 324928c:	1000051e 	bne	r2,zero,32492a4 <vunlink+0x1b8>
      {
         /* decrement count of total files */
         vfs_total_dyna_files--;
 3249290:	d0a91217 	ldw	r2,-23480(gp)
 3249294:	10bfffc4 	addi	r2,r2,-1
 3249298:	d0a91215 	stw	r2,-23480(gp)

         /* free the vfs_file structure */
         VFS_VFS_FILE_FREE(vfp);
 324929c:	e13ffd17 	ldw	r4,-12(fp)
 32492a0:	322b6c40 	call	322b6c4 <npfree>
         the vfs_file has been deleted from the list */
#ifdef VFS_AUTO_SYNC
      do_sync = 1;
#endif
      /* we were successful at our unlink */
      rc = 0;
 32492a4:	e03ffc15 	stw	zero,-16(fp)

      break;
   }

   /* delete the vfs_file structure from the list headed by vfsfiles */
   if (vflast)
 32492a8:	e0bffa17 	ldw	r2,-24(fp)
 32492ac:	1005003a 	cmpeq	r2,r2,zero
 32492b0:	1000041e 	bne	r2,zero,32492c4 <vunlink+0x1d8>
      vflast->next = vfnext;
 32492b4:	e0fffa17 	ldw	r3,-24(fp)
 32492b8:	e0bff917 	ldw	r2,-28(fp)
 32492bc:	18800015 	stw	r2,0(r3)
 32492c0:	00000206 	br	32492cc <vunlink+0x1e0>
   else
      vfsfiles = vfnext;
 32492c4:	e0bff917 	ldw	r2,-28(fp)
 32492c8:	d0a90d15 	stw	r2,-23500(gp)

   /* fix up references to deleted file in list of currently open VFILEs */
   vunlink_flag_open_files(vfp);
 32492cc:	e13ffd17 	ldw	r4,-12(fp)
 32492d0:	32490900 	call	3249090 <vunlink_flag_open_files>

   /* flag that the directory is stale so vfs_sync() knows it has to do
      something */
   vfs_dir_stale = TRUE;
 32492d4:	00800044 	movi	r2,1
 32492d8:	d0a90f15 	stw	r2,-23492(gp)

   /* unlinks not allowed on read-only VFS */
   rc = -1;

#endif   /* HT_RWVFS */
   vfs_unlock();
 32492dc:	01000144 	movi	r4,5
 32492e0:	322b23c0 	call	322b23c <post_app_sem>
   free(name);
 32492e4:	e13ff817 	ldw	r4,-32(fp)
 32492e8:	324b9340 	call	324b934 <free>
   return rc;
 32492ec:	e0bffc17 	ldw	r2,-16(fp)
 32492f0:	e0bfff15 	stw	r2,-4(fp)
 32492f4:	e0bfff17 	ldw	r2,-4(fp)
}
 32492f8:	e037883a 	mov	sp,fp
 32492fc:	dfc00117 	ldw	ra,4(sp)
 3249300:	df000017 	ldw	fp,0(sp)
 3249304:	dec00204 	addi	sp,sp,8
 3249308:	f800283a 	ret

0324930c <vfread>:
 * RETURNS: 
 */

int 
vfread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 324930c:	defff504 	addi	sp,sp,-44
 3249310:	dfc00a15 	stw	ra,40(sp)
 3249314:	df000915 	stw	fp,36(sp)
 3249318:	df000904 	addi	fp,sp,36
 324931c:	e13ffb15 	stw	r4,-20(fp)
 3249320:	e17ffc15 	stw	r5,-16(fp)
 3249324:	e1bffd15 	stw	r6,-12(fp)
 3249328:	e1fffe15 	stw	r7,-8(fp)
   unsigned bcount;  /* number of bytes put in caller's buffer */

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 324932c:	01000144 	movi	r4,5
 3249330:	322b1880 	call	322b188 <wait_app_sem>

   /* if the file is in our list of open files */
   if (isvfile_locked(vfd))
 3249334:	e13ffe17 	ldw	r4,-8(fp)
 3249338:	324a0800 	call	324a080 <isvfile_locked>
 324933c:	1005003a 	cmpeq	r2,r2,zero
 3249340:	1000541e 	bne	r2,zero,3249494 <vfread+0x188>
   {

#ifdef HT_RWVFS
      /* the caller is trying to read a handle to a file that's been
         deleted, so he gets 0 data back */
      if (vfd->file == NULL)
 3249344:	e0bffe17 	ldw	r2,-8(fp)
 3249348:	10800117 	ldw	r2,4(r2)
 324934c:	1004c03a 	cmpne	r2,r2,zero
 3249350:	1000041e 	bne	r2,zero,3249364 <vfread+0x58>
      {
         vfs_unlock();
 3249354:	01000144 	movi	r4,5
 3249358:	322b23c0 	call	322b23c <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 324935c:	e03fff15 	stw	zero,-4(fp)
 3249360:	00004f06 	br	32494a0 <vfread+0x194>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfd->file->method)
 3249364:	e0bffe17 	ldw	r2,-8(fp)
 3249368:	10800117 	ldw	r2,4(r2)
 324936c:	10800a17 	ldw	r2,40(r2)
 3249370:	1005003a 	cmpeq	r2,r2,zero
 3249374:	1000111e 	bne	r2,zero,32493bc <vfread+0xb0>
      {
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 3249378:	e0bffe17 	ldw	r2,-8(fp)
 324937c:	10800117 	ldw	r2,4(r2)
 3249380:	10800a17 	ldw	r2,40(r2)
 3249384:	e0bff915 	stw	r2,-28(fp)
         int   rc;

         /* call that system's fread() */
         rc = vfs->r_fread(buf,size,items,vfd);
 3249388:	e0bff917 	ldw	r2,-28(fp)
 324938c:	10800317 	ldw	r2,12(r2)
 3249390:	e13ffb17 	ldw	r4,-20(fp)
 3249394:	e17ffc17 	ldw	r5,-16(fp)
 3249398:	e1bffd17 	ldw	r6,-12(fp)
 324939c:	e1fffe17 	ldw	r7,-8(fp)
 32493a0:	103ee83a 	callr	r2
 32493a4:	e0bff815 	stw	r2,-32(fp)
         vfs_unlock();
 32493a8:	01000144 	movi	r4,5
 32493ac:	322b23c0 	call	322b23c <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return rc;
 32493b0:	e0bff817 	ldw	r2,-32(fp)
 32493b4:	e0bfff15 	stw	r2,-4(fp)
 32493b8:	00003906 	br	32494a0 <vfread+0x194>
#ifdef HT_RWVFS
      /* the data pointer can be NULL if somebody tries to read from 
       * a freshly created file, in which case there is no data in 
       * the file, so return 0
       */
      if (!(vfd->file->data))
 32493bc:	e0bffe17 	ldw	r2,-8(fp)
 32493c0:	10800117 	ldw	r2,4(r2)
 32493c4:	10800617 	ldw	r2,24(r2)
 32493c8:	1004c03a 	cmpne	r2,r2,zero
 32493cc:	1000041e 	bne	r2,zero,32493e0 <vfread+0xd4>
      {
         vfs_unlock();
 32493d0:	01000144 	movi	r4,5
 32493d4:	322b23c0 	call	322b23c <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 32493d8:	e03fff15 	stw	zero,-4(fp)
 32493dc:	00003006 	br	32494a0 <vfread+0x194>
      }
#endif   /* HT_RWVFS */

      bcount = items * size;  /* number of bytes to transfer */
 32493e0:	e0fffd17 	ldw	r3,-12(fp)
 32493e4:	e0bffc17 	ldw	r2,-16(fp)
 32493e8:	1885383a 	mul	r2,r3,r2
 32493ec:	e0bffa15 	stw	r2,-24(fp)
         return(items); /* filled user buffer, return # items copied */
      }
      else  /* else fall to faster non-compression code */
#endif   /* HTML_COMPRESSION */
      {  /* get here to do simple uncompressed data read */
         unsigned location = vfd->cmploc - vfd->file->data;
 32493f0:	e0bffe17 	ldw	r2,-8(fp)
 32493f4:	10800217 	ldw	r2,8(r2)
 32493f8:	1007883a 	mov	r3,r2
 32493fc:	e0bffe17 	ldw	r2,-8(fp)
 3249400:	10800117 	ldw	r2,4(r2)
 3249404:	10800617 	ldw	r2,24(r2)
 3249408:	1885c83a 	sub	r2,r3,r2
 324940c:	e0bff715 	stw	r2,-36(fp)

         if (((unsigned long)location + bcount) > vfd->file->comp_size)
 3249410:	e0fff717 	ldw	r3,-36(fp)
 3249414:	e0bffa17 	ldw	r2,-24(fp)
 3249418:	1887883a 	add	r3,r3,r2
 324941c:	e0bffe17 	ldw	r2,-8(fp)
 3249420:	10800117 	ldw	r2,4(r2)
 3249424:	10800817 	ldw	r2,32(r2)
 3249428:	10c0062e 	bgeu	r2,r3,3249444 <vfread+0x138>
            bcount = (unsigned)(vfd->file->comp_size - location);
 324942c:	e0bffe17 	ldw	r2,-8(fp)
 3249430:	10800117 	ldw	r2,4(r2)
 3249434:	10c00817 	ldw	r3,32(r2)
 3249438:	e0bff717 	ldw	r2,-36(fp)
 324943c:	1885c83a 	sub	r2,r3,r2
 3249440:	e0bffa15 	stw	r2,-24(fp)
         MEMCPY(buf, vfd->cmploc, bcount);
 3249444:	e0bffe17 	ldw	r2,-8(fp)
 3249448:	10c00217 	ldw	r3,8(r2)
 324944c:	e0bffb17 	ldw	r2,-20(fp)
 3249450:	1009883a 	mov	r4,r2
 3249454:	180b883a 	mov	r5,r3
 3249458:	e1bffa17 	ldw	r6,-24(fp)
 324945c:	32067cc0 	call	32067cc <memcpy>
         vfd->cmploc += bcount;
 3249460:	e0bffe17 	ldw	r2,-8(fp)
 3249464:	10c00217 	ldw	r3,8(r2)
 3249468:	e0bffa17 	ldw	r2,-24(fp)
 324946c:	1887883a 	add	r3,r3,r2
 3249470:	e0bffe17 	ldw	r2,-8(fp)
 3249474:	10c00215 	stw	r3,8(r2)
      }
      vfs_unlock();
 3249478:	01000144 	movi	r4,5
 324947c:	322b23c0 	call	322b23c <post_app_sem>
      IN_PROFILER(PF_FS, PF_EXIT);
      return (bcount/size);
 3249480:	e13ffa17 	ldw	r4,-24(fp)
 3249484:	e17ffc17 	ldw	r5,-16(fp)
 3249488:	32044bc0 	call	32044bc <__udivsi3>
 324948c:	e0bfff15 	stw	r2,-4(fp)
 3249490:	00000306 	br	32494a0 <vfread+0x194>
   }

   vfs_unlock();
 3249494:	01000144 	movi	r4,5
 3249498:	322b23c0 	call	322b23c <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fread(buf, size, items, (FILE*)vfd));
#else
   return 0;
 324949c:	e03fff15 	stw	zero,-4(fp)
 32494a0:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 32494a4:	e037883a 	mov	sp,fp
 32494a8:	dfc00117 	ldw	ra,4(sp)
 32494ac:	df000017 	ldw	fp,0(sp)
 32494b0:	dec00204 	addi	sp,sp,8
 32494b4:	f800283a 	ret

032494b8 <vfwrite_locked>:
 * RETURNS: 
 */

int 
vfwrite_locked(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 32494b8:	defff104 	addi	sp,sp,-60
 32494bc:	dfc00e15 	stw	ra,56(sp)
 32494c0:	df000d15 	stw	fp,52(sp)
 32494c4:	df000d04 	addi	fp,sp,52
 32494c8:	e13ffb15 	stw	r4,-20(fp)
 32494cc:	e17ffc15 	stw	r5,-16(fp)
 32494d0:	e1bffd15 	stw	r6,-12(fp)
 32494d4:	e1fffe15 	stw	r7,-8(fp)
   unsigned long current_offset;
   struct vfs_file * vfp;
#endif   /* HT_RWVFS */

   /* if the file is not in our list of files */
   if (!isvfile_locked(vfd))
 32494d8:	e13ffe17 	ldw	r4,-8(fp)
 32494dc:	324a0800 	call	324a080 <isvfile_locked>
 32494e0:	1004c03a 	cmpne	r2,r2,zero
 32494e4:	1000031e 	bne	r2,zero,32494f4 <vfwrite_locked+0x3c>
   {
#ifdef HT_LOCALFS
      /* default to call on local system */
      return(fwrite(buf, size, items, (FILE*)vfd));
#else
      return EBADF;
 32494e8:	00800244 	movi	r2,9
 32494ec:	e0bfff15 	stw	r2,-4(fp)
 32494f0:	0000e506 	br	3249888 <vfwrite_locked+0x3d0>
   }
   /* this file is in our list of files */

#ifdef HT_EXTDEV
   /* if the file was created by an external file system */
   if (vfd->file->method)
 32494f4:	e0bffe17 	ldw	r2,-8(fp)
 32494f8:	10800117 	ldw	r2,4(r2)
 32494fc:	10800a17 	ldw	r2,40(r2)
 3249500:	1005003a 	cmpeq	r2,r2,zero
 3249504:	10000f1e 	bne	r2,zero,3249544 <vfwrite_locked+0x8c>
   {
      struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 3249508:	e0bffe17 	ldw	r2,-8(fp)
 324950c:	10800117 	ldw	r2,4(r2)
 3249510:	10800a17 	ldw	r2,40(r2)
 3249514:	e0bff715 	stw	r2,-36(fp)
      int   rc;

      /* call that system's fwrite() */
      rc = vfs->r_fwrite(buf,size,items,vfd);
 3249518:	e0bff717 	ldw	r2,-36(fp)
 324951c:	10800417 	ldw	r2,16(r2)
 3249520:	e13ffb17 	ldw	r4,-20(fp)
 3249524:	e17ffc17 	ldw	r5,-16(fp)
 3249528:	e1bffd17 	ldw	r6,-12(fp)
 324952c:	e1fffe17 	ldw	r7,-8(fp)
 3249530:	103ee83a 	callr	r2
 3249534:	e0bff615 	stw	r2,-40(fp)
      return rc;
 3249538:	e0bff617 	ldw	r2,-40(fp)
 324953c:	e0bfff15 	stw	r2,-4(fp)
 3249540:	0000d106 	br	3249888 <vfwrite_locked+0x3d0>

#else    /* HT_RWVFS */

   /* the caller is trying to write to a file that's been deleted,
      so he writes 0 data */
   if (vfd->file == NULL)
 3249544:	e0bffe17 	ldw	r2,-8(fp)
 3249548:	10800117 	ldw	r2,4(r2)
 324954c:	1004c03a 	cmpne	r2,r2,zero
 3249550:	1000021e 	bne	r2,zero,324955c <vfwrite_locked+0xa4>
   {
      return 0;
 3249554:	e03fff15 	stw	zero,-4(fp)
 3249558:	0000cb06 	br	3249888 <vfwrite_locked+0x3d0>
   }

   vfp = vfd->file;
 324955c:	e0bffe17 	ldw	r2,-8(fp)
 3249560:	10800117 	ldw	r2,4(r2)
 3249564:	e0bff815 	stw	r2,-32(fp)

   /* if the file is not writable, return error condition */
   if (!(vfp->flags & VF_WRITE))
 3249568:	e0bff817 	ldw	r2,-32(fp)
 324956c:	1080058b 	ldhu	r2,22(r2)
 3249570:	10bfffcc 	andi	r2,r2,65535
 3249574:	1080080c 	andi	r2,r2,32
 3249578:	1004c03a 	cmpne	r2,r2,zero
 324957c:	1000051e 	bne	r2,zero,3249594 <vfwrite_locked+0xdc>
   {
      vfd->error = ENP_FILEIO;
 3249580:	e0fffe17 	ldw	r3,-8(fp)
 3249584:	00bff984 	movi	r2,-26
 3249588:	18800415 	stw	r2,16(r3)
      return 0;
 324958c:	e03fff15 	stw	zero,-4(fp)
 3249590:	0000bd06 	br	3249888 <vfwrite_locked+0x3d0>
   }

   /* compute number of bytes to write */
   bcount = size * items;
 3249594:	e0fffc17 	ldw	r3,-16(fp)
 3249598:	e0bffd17 	ldw	r2,-12(fp)
 324959c:	1885383a 	mul	r2,r3,r2
 32495a0:	e0bffa15 	stw	r2,-24(fp)

   /* get rid of this degenerate case up front */
   if (bcount == 0)
 32495a4:	e0bffa17 	ldw	r2,-24(fp)
 32495a8:	1004c03a 	cmpne	r2,r2,zero
 32495ac:	1000021e 	bne	r2,zero,32495b8 <vfwrite_locked+0x100>
   {
      return 0;
 32495b0:	e03fff15 	stw	zero,-4(fp)
 32495b4:	0000b406 	br	3249888 <vfwrite_locked+0x3d0>
   }

   /* if the file currently has no data buffer */
   if (vfp->data == NULL)
 32495b8:	e0bff817 	ldw	r2,-32(fp)
 32495bc:	10800617 	ldw	r2,24(r2)
 32495c0:	1004c03a 	cmpne	r2,r2,zero
 32495c4:	1000401e 	bne	r2,zero,32496c8 <vfwrite_locked+0x210>
   {
      /* compute the size of the buffer to be created */
      /* we round up the size of the data to be written so we dont have
         the overhead of a memory allocation on every write */
      unsigned long buf_size = VFS_ROUND_UP((unsigned long)bcount);
 32495c8:	e0bffa17 	ldw	r2,-24(fp)
 32495cc:	10bfffc4 	addi	r2,r2,-1
 32495d0:	1004d37a 	srli	r2,r2,13
 32495d4:	1004937a 	slli	r2,r2,13
 32495d8:	10880004 	addi	r2,r2,8192
 32495dc:	e0bff515 	stw	r2,-44(fp)

      /* allocate a buffer of that size */
      vfp->data = vf_alloc_buffer(buf_size);
 32495e0:	e13ff517 	ldw	r4,-44(fp)
 32495e4:	32488440 	call	3248844 <vf_alloc_buffer>
 32495e8:	1007883a 	mov	r3,r2
 32495ec:	e0bff817 	ldw	r2,-32(fp)
 32495f0:	10c00615 	stw	r3,24(r2)

      /* if the allocation failed */
      if (!(vfp->data))
 32495f4:	e0bff817 	ldw	r2,-32(fp)
 32495f8:	10800617 	ldw	r2,24(r2)
 32495fc:	1004c03a 	cmpne	r2,r2,zero
 3249600:	1000051e 	bne	r2,zero,3249618 <vfwrite_locked+0x160>
      {
         vfd->error = ENP_NOMEM;
 3249604:	e0fffe17 	ldw	r3,-8(fp)
 3249608:	00bffb04 	movi	r2,-20
 324960c:	18800415 	stw	r2,16(r3)
         return 0;
 3249610:	e03fff15 	stw	zero,-4(fp)
 3249614:	00009c06 	br	3249888 <vfwrite_locked+0x3d0>
      }

      /* store the size of the allocated buffer */
      vfp->buf_size = buf_size;
 3249618:	e0fff817 	ldw	r3,-32(fp)
 324961c:	e0bff517 	ldw	r2,-44(fp)
 3249620:	18800915 	stw	r2,36(r3)

      /* store the number of bytes written in the real and compressed
         file sizes */
      vfp->real_size = bcount;
 3249624:	e0fff817 	ldw	r3,-32(fp)
 3249628:	e0bffa17 	ldw	r2,-24(fp)
 324962c:	18800715 	stw	r2,28(r3)
      vfp->comp_size = bcount;
 3249630:	e0fff817 	ldw	r3,-32(fp)
 3249634:	e0bffa17 	ldw	r2,-24(fp)
 3249638:	18800815 	stw	r2,32(r3)

      /* set the file pointer to the first byte following the last
         byte written */
      vfd->cmploc = vfp->data + bcount;
 324963c:	e0bff817 	ldw	r2,-32(fp)
 3249640:	10c00617 	ldw	r3,24(r2)
 3249644:	e0bffa17 	ldw	r2,-24(fp)
 3249648:	1887883a 	add	r3,r3,r2
 324964c:	e0bffe17 	ldw	r2,-8(fp)
 3249650:	10c00215 	stw	r3,8(r2)

      /* turn off the compression flag */
      vfp->flags &= ~VF_HTMLCOMPRESSED;
 3249654:	e0bff817 	ldw	r2,-32(fp)
 3249658:	10c0058b 	ldhu	r3,22(r2)
 324965c:	00bfff84 	movi	r2,-2
 3249660:	1884703a 	and	r2,r3,r2
 3249664:	1007883a 	mov	r3,r2
 3249668:	e0bff817 	ldw	r2,-32(fp)
 324966c:	10c0058d 	sth	r3,22(r2)

      /* the data in the file is stale */
      vfp->flags |= VF_STALE;
 3249670:	e0bff817 	ldw	r2,-32(fp)
 3249674:	1080058b 	ldhu	r2,22(r2)
 3249678:	10808014 	ori	r2,r2,512
 324967c:	1007883a 	mov	r3,r2
 3249680:	e0bff817 	ldw	r2,-32(fp)
 3249684:	10c0058d 	sth	r3,22(r2)

      /* the buffer data was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 3249688:	e0bff817 	ldw	r2,-32(fp)
 324968c:	1080058b 	ldhu	r2,22(r2)
 3249690:	10802014 	ori	r2,r2,128
 3249694:	1007883a 	mov	r3,r2
 3249698:	e0bff817 	ldw	r2,-32(fp)
 324969c:	10c0058d 	sth	r3,22(r2)

      /* copy the data to be written to the file buffer */
      MEMCPY(vfp->data,buf,bcount);
 32496a0:	e0bff817 	ldw	r2,-32(fp)
 32496a4:	10800617 	ldw	r2,24(r2)
 32496a8:	e0fffb17 	ldw	r3,-20(fp)
 32496ac:	1009883a 	mov	r4,r2
 32496b0:	180b883a 	mov	r5,r3
 32496b4:	e1bffa17 	ldw	r6,-24(fp)
 32496b8:	32067cc0 	call	32067cc <memcpy>

      /* return the number of "items" written */
      return items;
 32496bc:	e0bffd17 	ldw	r2,-12(fp)
 32496c0:	e0bfff15 	stw	r2,-4(fp)
 32496c4:	00007006 	br	3249888 <vfwrite_locked+0x3d0>
   }

   /* compute the current offset into the file */
   current_offset = vfd->cmploc - vfp->data;
 32496c8:	e0bffe17 	ldw	r2,-8(fp)
 32496cc:	10800217 	ldw	r2,8(r2)
 32496d0:	1007883a 	mov	r3,r2
 32496d4:	e0bff817 	ldw	r2,-32(fp)
 32496d8:	10800617 	ldw	r2,24(r2)
 32496dc:	1885c83a 	sub	r2,r3,r2
 32496e0:	e0bff915 	stw	r2,-28(fp)

   /* if the data to be written wont fit into the file buffer */
   if ((current_offset + bcount) > vfp->buf_size)
 32496e4:	e0fff917 	ldw	r3,-28(fp)
 32496e8:	e0bffa17 	ldw	r2,-24(fp)
 32496ec:	1887883a 	add	r3,r3,r2
 32496f0:	e0bff817 	ldw	r2,-32(fp)
 32496f4:	10800917 	ldw	r2,36(r2)
 32496f8:	10c0382e 	bgeu	r2,r3,32497dc <vfwrite_locked+0x324>
   {
      /* compute the size of a new buffer to hold the data */
      unsigned long new_buf_size = VFS_ROUND_UP(current_offset + bcount);
 32496fc:	e0fff917 	ldw	r3,-28(fp)
 3249700:	e0bffa17 	ldw	r2,-24(fp)
 3249704:	1885883a 	add	r2,r3,r2
 3249708:	10bfffc4 	addi	r2,r2,-1
 324970c:	1004d37a 	srli	r2,r2,13
 3249710:	1004937a 	slli	r2,r2,13
 3249714:	10880004 	addi	r2,r2,8192
 3249718:	e0bff415 	stw	r2,-48(fp)
      unsigned char *new_buffer;

      /* allocate a new buffer */
      new_buffer = vf_alloc_buffer(new_buf_size);
 324971c:	e13ff417 	ldw	r4,-48(fp)
 3249720:	32488440 	call	3248844 <vf_alloc_buffer>
 3249724:	e0bff315 	stw	r2,-52(fp)

      /* check for allocation failure */
      if (!new_buffer)
 3249728:	e0bff317 	ldw	r2,-52(fp)
 324972c:	1004c03a 	cmpne	r2,r2,zero
 3249730:	1000051e 	bne	r2,zero,3249748 <vfwrite_locked+0x290>
      {
         vfd->error = ENP_NOMEM;
 3249734:	e0fffe17 	ldw	r3,-8(fp)
 3249738:	00bffb04 	movi	r2,-20
 324973c:	18800415 	stw	r2,16(r3)
         return 0;
 3249740:	e03fff15 	stw	zero,-4(fp)
 3249744:	00005006 	br	3249888 <vfwrite_locked+0x3d0>
      }

      /* copy the old buffer contents to the new buffer */
      MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 3249748:	e0bff817 	ldw	r2,-32(fp)
 324974c:	10c00617 	ldw	r3,24(r2)
 3249750:	e0bff817 	ldw	r2,-32(fp)
 3249754:	11800817 	ldw	r6,32(r2)
 3249758:	e0bff317 	ldw	r2,-52(fp)
 324975c:	1009883a 	mov	r4,r2
 3249760:	180b883a 	mov	r5,r3
 3249764:	32067cc0 	call	32067cc <memcpy>

      /* if the old buffer had been dynamically allocated */
      if (vfp->flags & VF_DYNAMICDATA)
 3249768:	e0bff817 	ldw	r2,-32(fp)
 324976c:	1080058b 	ldhu	r2,22(r2)
 3249770:	10bfffcc 	andi	r2,r2,65535
 3249774:	1080200c 	andi	r2,r2,128
 3249778:	1005003a 	cmpeq	r2,r2,zero
 324977c:	1000051e 	bne	r2,zero,3249794 <vfwrite_locked+0x2dc>
      {
         /* free it */
         vf_free_buffer(vfp->data,vfp->buf_size);
 3249780:	e0bff817 	ldw	r2,-32(fp)
 3249784:	11000617 	ldw	r4,24(r2)
 3249788:	e0bff817 	ldw	r2,-32(fp)
 324978c:	11400917 	ldw	r5,36(r2)
 3249790:	324891c0 	call	324891c <vf_free_buffer>
      }

      /* store the new buffer in the file structure */
      vfp->data = new_buffer;
 3249794:	e0fff817 	ldw	r3,-32(fp)
 3249798:	e0bff317 	ldw	r2,-52(fp)
 324979c:	18800615 	stw	r2,24(r3)

      /* store the new buffer size in the file structure */
      vfp->buf_size = new_buf_size;
 32497a0:	e0fff817 	ldw	r3,-32(fp)
 32497a4:	e0bff417 	ldw	r2,-48(fp)
 32497a8:	18800915 	stw	r2,36(r3)

      /* the new buffer was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 32497ac:	e0bff817 	ldw	r2,-32(fp)
 32497b0:	1080058b 	ldhu	r2,22(r2)
 32497b4:	10802014 	ori	r2,r2,128
 32497b8:	1007883a 	mov	r3,r2
 32497bc:	e0bff817 	ldw	r2,-32(fp)
 32497c0:	10c0058d 	sth	r3,22(r2)
       * buffer note that this means the VFS does not support 
       * simultaneous opens of the same file, since for that to work, 
       * all the other cmploc's that point to this file would 
       * have to be updated also 
       */
      vfd->cmploc = vfp->data + current_offset;
 32497c4:	e0bff817 	ldw	r2,-32(fp)
 32497c8:	10c00617 	ldw	r3,24(r2)
 32497cc:	e0bff917 	ldw	r2,-28(fp)
 32497d0:	1887883a 	add	r3,r3,r2
 32497d4:	e0bffe17 	ldw	r2,-8(fp)
 32497d8:	10c00215 	stw	r3,8(r2)
   }

   /* copy the data to the current file pointer */
   MEMCPY(vfd->cmploc,buf,bcount);
 32497dc:	e0bffe17 	ldw	r2,-8(fp)
 32497e0:	10800217 	ldw	r2,8(r2)
 32497e4:	e0fffb17 	ldw	r3,-20(fp)
 32497e8:	1009883a 	mov	r4,r2
 32497ec:	180b883a 	mov	r5,r3
 32497f0:	e1bffa17 	ldw	r6,-24(fp)
 32497f4:	32067cc0 	call	32067cc <memcpy>

   /* update the current file pointer */
   vfd->cmploc += bcount;
 32497f8:	e0bffe17 	ldw	r2,-8(fp)
 32497fc:	10c00217 	ldw	r3,8(r2)
 3249800:	e0bffa17 	ldw	r2,-24(fp)
 3249804:	1887883a 	add	r3,r3,r2
 3249808:	e0bffe17 	ldw	r2,-8(fp)
 324980c:	10c00215 	stw	r3,8(r2)

   /* if the resulting current offset is greater than the file size */
   if (current_offset + bcount > vfp->comp_size)
 3249810:	e0fff917 	ldw	r3,-28(fp)
 3249814:	e0bffa17 	ldw	r2,-24(fp)
 3249818:	1887883a 	add	r3,r3,r2
 324981c:	e0bff817 	ldw	r2,-32(fp)
 3249820:	10800817 	ldw	r2,32(r2)
 3249824:	10c0052e 	bgeu	r2,r3,324983c <vfwrite_locked+0x384>
   {
      /* update the "compressed" file size */
      vfp->comp_size = current_offset + bcount;
 3249828:	e0fff917 	ldw	r3,-28(fp)
 324982c:	e0bffa17 	ldw	r2,-24(fp)
 3249830:	1887883a 	add	r3,r3,r2
 3249834:	e0bff817 	ldw	r2,-32(fp)
 3249838:	10c00815 	stw	r3,32(r2)
   }

   /* since we turn off the compression bit below, the "real" size and
      the compressed size must be the same */
   vfp->real_size = vfp->comp_size;
 324983c:	e0bff817 	ldw	r2,-32(fp)
 3249840:	10c00817 	ldw	r3,32(r2)
 3249844:	e0bff817 	ldw	r2,-32(fp)
 3249848:	10c00715 	stw	r3,28(r2)

   /* turn off the compression flag */
   vfp->flags &= ~VF_HTMLCOMPRESSED;
 324984c:	e0bff817 	ldw	r2,-32(fp)
 3249850:	10c0058b 	ldhu	r3,22(r2)
 3249854:	00bfff84 	movi	r2,-2
 3249858:	1884703a 	and	r2,r3,r2
 324985c:	1007883a 	mov	r3,r2
 3249860:	e0bff817 	ldw	r2,-32(fp)
 3249864:	10c0058d 	sth	r3,22(r2)

   /* the data in the file is stale */
   vfp->flags |= VF_STALE;
 3249868:	e0bff817 	ldw	r2,-32(fp)
 324986c:	1080058b 	ldhu	r2,22(r2)
 3249870:	10808014 	ori	r2,r2,512
 3249874:	1007883a 	mov	r3,r2
 3249878:	e0bff817 	ldw	r2,-32(fp)
 324987c:	10c0058d 	sth	r3,22(r2)

   /* return the number of "items" written */
   return items;
 3249880:	e0bffd17 	ldw	r2,-12(fp)
 3249884:	e0bfff15 	stw	r2,-4(fp)
 3249888:	e0bfff17 	ldw	r2,-4(fp)

#endif   /* HT_RWVFS */
}
 324988c:	e037883a 	mov	sp,fp
 3249890:	dfc00117 	ldw	ra,4(sp)
 3249894:	df000017 	ldw	fp,0(sp)
 3249898:	dec00204 	addi	sp,sp,8
 324989c:	f800283a 	ret

032498a0 <vfwrite>:
 * RETURNS: 
 */

int
vfwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 32498a0:	defff904 	addi	sp,sp,-28
 32498a4:	dfc00615 	stw	ra,24(sp)
 32498a8:	df000515 	stw	fp,20(sp)
 32498ac:	df000504 	addi	fp,sp,20
 32498b0:	e13ffc15 	stw	r4,-16(fp)
 32498b4:	e17ffd15 	stw	r5,-12(fp)
 32498b8:	e1bffe15 	stw	r6,-8(fp)
 32498bc:	e1ffff15 	stw	r7,-4(fp)
   int   rc;

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 32498c0:	01000144 	movi	r4,5
 32498c4:	322b1880 	call	322b188 <wait_app_sem>

   /* do the write */
   rc = vfwrite_locked(buf, size, items, vfd);
 32498c8:	e13ffc17 	ldw	r4,-16(fp)
 32498cc:	e17ffd17 	ldw	r5,-12(fp)
 32498d0:	e1bffe17 	ldw	r6,-8(fp)
 32498d4:	e1ffff17 	ldw	r7,-4(fp)
 32498d8:	32494b80 	call	32494b8 <vfwrite_locked>
 32498dc:	e0bffb15 	stw	r2,-20(fp)

   /* unlock the VFS */
   vfs_unlock();
 32498e0:	01000144 	movi	r4,5
 32498e4:	322b23c0 	call	322b23c <post_app_sem>

   IN_PROFILER(PF_FS, PF_EXIT);

   return rc;
 32498e8:	e0bffb17 	ldw	r2,-20(fp)
}
 32498ec:	e037883a 	mov	sp,fp
 32498f0:	dfc00117 	ldw	ra,4(sp)
 32498f4:	df000017 	ldw	fp,0(sp)
 32498f8:	dec00204 	addi	sp,sp,8
 32498fc:	f800283a 	ret

03249900 <vfseek>:
 * RETURNS: 
 */

int 
vfseek(VFILE * vfd, long offset, int mode)
{
 3249900:	defff704 	addi	sp,sp,-36
 3249904:	dfc00815 	stw	ra,32(sp)
 3249908:	df000715 	stw	fp,28(sp)
 324990c:	df000704 	addi	fp,sp,28
 3249910:	e13ffb15 	stw	r4,-20(fp)
 3249914:	e17ffc15 	stw	r5,-16(fp)
 3249918:	e1bffd15 	stw	r6,-12(fp)
   /* lock the VFS */
   vfs_lock();
 324991c:	01000144 	movi	r4,5
 3249920:	322b1880 	call	322b188 <wait_app_sem>

   if (isvfile_locked(vfd))
 3249924:	e13ffb17 	ldw	r4,-20(fp)
 3249928:	324a0800 	call	324a080 <isvfile_locked>
 324992c:	1005003a 	cmpeq	r2,r2,zero
 3249930:	1000481e 	bne	r2,zero,3249a54 <vfseek+0x154>
   {
#ifdef HT_RWVFS
      /* the caller is trying to seek a file that's been deleted,
         so return an error indication */
      if (vfd->file == NULL)
 3249934:	e0bffb17 	ldw	r2,-20(fp)
 3249938:	10800117 	ldw	r2,4(r2)
 324993c:	1004c03a 	cmpne	r2,r2,zero
 3249940:	1000051e 	bne	r2,zero,3249958 <vfseek+0x58>
      {
         vfs_unlock();
 3249944:	01000144 	movi	r4,5
 3249948:	322b23c0 	call	322b23c <post_app_sem>
         return -1;
 324994c:	00bfffc4 	movi	r2,-1
 3249950:	e0bffe15 	stw	r2,-8(fp)
 3249954:	00004306 	br	3249a64 <vfseek+0x164>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 3249958:	e0bffb17 	ldw	r2,-20(fp)
 324995c:	10800117 	ldw	r2,4(r2)
 3249960:	10800a17 	ldw	r2,40(r2)
 3249964:	1005003a 	cmpeq	r2,r2,zero
 3249968:	1000101e 	bne	r2,zero,32499ac <vfseek+0xac>
      {
         struct vfroutines *vfp = (struct vfroutines*)(vfd->file->method);
 324996c:	e0bffb17 	ldw	r2,-20(fp)
 3249970:	10800117 	ldw	r2,4(r2)
 3249974:	10800a17 	ldw	r2,40(r2)
 3249978:	e0bffa15 	stw	r2,-24(fp)
         int   rc;

         rc = vfp->r_fseek(vfd, offset, mode);
 324997c:	e0bffa17 	ldw	r2,-24(fp)
 3249980:	10800517 	ldw	r2,20(r2)
 3249984:	e13ffb17 	ldw	r4,-20(fp)
 3249988:	e17ffc17 	ldw	r5,-16(fp)
 324998c:	e1bffd17 	ldw	r6,-12(fp)
 3249990:	103ee83a 	callr	r2
 3249994:	e0bff915 	stw	r2,-28(fp)
         vfs_unlock();
 3249998:	01000144 	movi	r4,5
 324999c:	322b23c0 	call	322b23c <post_app_sem>
         return rc;
 32499a0:	e0fff917 	ldw	r3,-28(fp)
 32499a4:	e0fffe15 	stw	r3,-8(fp)
 32499a8:	00002e06 	br	3249a64 <vfseek+0x164>
      }
#endif   /* HT_EXTDEV */
      /* this vfseek() currently only supports seek to exact
         end or begining of file */
      switch (mode)
 32499ac:	e0bffd17 	ldw	r2,-12(fp)
 32499b0:	e0bfff15 	stw	r2,-4(fp)
 32499b4:	e0ffff17 	ldw	r3,-4(fp)
 32499b8:	18800060 	cmpeqi	r2,r3,1
 32499bc:	10000f1e 	bne	r2,zero,32499fc <vfseek+0xfc>
 32499c0:	e0ffff17 	ldw	r3,-4(fp)
 32499c4:	188000a0 	cmpeqi	r2,r3,2
 32499c8:	1000131e 	bne	r2,zero,3249a18 <vfseek+0x118>
 32499cc:	e0ffff17 	ldw	r3,-4(fp)
 32499d0:	1805003a 	cmpeq	r2,r3,zero
 32499d4:	1000011e 	bne	r2,zero,32499dc <vfseek+0xdc>
 32499d8:	00001a06 	br	3249a44 <vfseek+0x144>
      {
      case SEEK_SET:
         vfd->cmploc = vfd->file->data + offset;
 32499dc:	e0bffb17 	ldw	r2,-20(fp)
 32499e0:	10800117 	ldw	r2,4(r2)
 32499e4:	10c00617 	ldw	r3,24(r2)
 32499e8:	e0bffc17 	ldw	r2,-16(fp)
 32499ec:	1887883a 	add	r3,r3,r2
 32499f0:	e0bffb17 	ldw	r2,-20(fp)
 32499f4:	10c00215 	stw	r3,8(r2)
         break;
 32499f8:	00001206 	br	3249a44 <vfseek+0x144>
      case SEEK_CUR:
         /* If the file is compressed, then the following
          * adjustment is inaccurate. Currently we don't have
          * any scenario where this happens. - handle later */
         vfd->cmploc += offset; 
 32499fc:	e0bffb17 	ldw	r2,-20(fp)
 3249a00:	10c00217 	ldw	r3,8(r2)
 3249a04:	e0bffc17 	ldw	r2,-16(fp)
 3249a08:	1887883a 	add	r3,r3,r2
 3249a0c:	e0bffb17 	ldw	r2,-20(fp)
 3249a10:	10c00215 	stw	r3,8(r2)
         break;
 3249a14:	00000b06 	br	3249a44 <vfseek+0x144>
      case SEEK_END:
         vfd->cmploc = vfd->file->data + vfd->file->comp_size + offset;
 3249a18:	e0bffb17 	ldw	r2,-20(fp)
 3249a1c:	10800117 	ldw	r2,4(r2)
 3249a20:	10c00617 	ldw	r3,24(r2)
 3249a24:	e0bffb17 	ldw	r2,-20(fp)
 3249a28:	10800117 	ldw	r2,4(r2)
 3249a2c:	10800817 	ldw	r2,32(r2)
 3249a30:	1887883a 	add	r3,r3,r2
 3249a34:	e0bffc17 	ldw	r2,-16(fp)
 3249a38:	1887883a 	add	r3,r3,r2
 3249a3c:	e0bffb17 	ldw	r2,-20(fp)
 3249a40:	10c00215 	stw	r3,8(r2)
         break;
      }
      vfs_unlock();
 3249a44:	01000144 	movi	r4,5
 3249a48:	322b23c0 	call	322b23c <post_app_sem>
      return(0);
 3249a4c:	e03ffe15 	stw	zero,-8(fp)
 3249a50:	00000406 	br	3249a64 <vfseek+0x164>
   }

   vfs_unlock();
 3249a54:	01000144 	movi	r4,5
 3249a58:	322b23c0 	call	322b23c <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fseek((FILE*)vfd, offset, mode));
#else
   return -1;
 3249a5c:	00bfffc4 	movi	r2,-1
 3249a60:	e0bffe15 	stw	r2,-8(fp)
 3249a64:	e0bffe17 	ldw	r2,-8(fp)
#endif   /* HT_LOCALFS */
}
 3249a68:	e037883a 	mov	sp,fp
 3249a6c:	dfc00117 	ldw	ra,4(sp)
 3249a70:	df000017 	ldw	fp,0(sp)
 3249a74:	dec00204 	addi	sp,sp,8
 3249a78:	f800283a 	ret

03249a7c <vftell>:
 * RETURNS: 
 */

long
vftell(VFILE * vfd)
{
 3249a7c:	defffa04 	addi	sp,sp,-24
 3249a80:	dfc00515 	stw	ra,20(sp)
 3249a84:	df000415 	stw	fp,16(sp)
 3249a88:	df000404 	addi	fp,sp,16
 3249a8c:	e13ffe15 	stw	r4,-8(fp)
   /* lock the VFS */
   vfs_lock();
 3249a90:	01000144 	movi	r4,5
 3249a94:	322b1880 	call	322b188 <wait_app_sem>

   if (isvfile_locked(vfd))
 3249a98:	e13ffe17 	ldw	r4,-8(fp)
 3249a9c:	324a0800 	call	324a080 <isvfile_locked>
 3249aa0:	1005003a 	cmpeq	r2,r2,zero
 3249aa4:	1000381e 	bne	r2,zero,3249b88 <vftell+0x10c>
   {
#ifdef HT_RWVFS
      /* the caller is trying to ftell a deleted file,
         so return an error condition */
      if (vfd->file == NULL)
 3249aa8:	e0bffe17 	ldw	r2,-8(fp)
 3249aac:	10800117 	ldw	r2,4(r2)
 3249ab0:	1004c03a 	cmpne	r2,r2,zero
 3249ab4:	1000051e 	bne	r2,zero,3249acc <vftell+0x50>
      {
         vfs_unlock();
 3249ab8:	01000144 	movi	r4,5
 3249abc:	322b23c0 	call	322b23c <post_app_sem>
         return -1;
 3249ac0:	00bfffc4 	movi	r2,-1
 3249ac4:	e0bfff15 	stw	r2,-4(fp)
 3249ac8:	00003306 	br	3249b98 <vftell+0x11c>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 3249acc:	e0bffe17 	ldw	r2,-8(fp)
 3249ad0:	10800117 	ldw	r2,4(r2)
 3249ad4:	10800a17 	ldw	r2,40(r2)
 3249ad8:	1005003a 	cmpeq	r2,r2,zero
 3249adc:	10000e1e 	bne	r2,zero,3249b18 <vftell+0x9c>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 3249ae0:	e0bffe17 	ldw	r2,-8(fp)
 3249ae4:	10800117 	ldw	r2,4(r2)
 3249ae8:	10800a17 	ldw	r2,40(r2)
 3249aec:	e0bffd15 	stw	r2,-12(fp)
         long  rc;

         rc = vfp->r_ftell(vfd);
 3249af0:	e0bffd17 	ldw	r2,-12(fp)
 3249af4:	10800617 	ldw	r2,24(r2)
 3249af8:	e13ffe17 	ldw	r4,-8(fp)
 3249afc:	103ee83a 	callr	r2
 3249b00:	e0bffc15 	stw	r2,-16(fp)
         vfs_unlock();
 3249b04:	01000144 	movi	r4,5
 3249b08:	322b23c0 	call	322b23c <post_app_sem>
         return rc;
 3249b0c:	e0bffc17 	ldw	r2,-16(fp)
 3249b10:	e0bfff15 	stw	r2,-4(fp)
 3249b14:	00002006 	br	3249b98 <vftell+0x11c>
      }
#endif   /* HT_EXTDEV */
      /* if file has been fseeked to end, return uncompressed size.
         else return current location in compression stream */
      if (vfd->cmploc == vfd->file->data + vfd->file->comp_size)
 3249b18:	e0bffe17 	ldw	r2,-8(fp)
 3249b1c:	11000217 	ldw	r4,8(r2)
 3249b20:	e0bffe17 	ldw	r2,-8(fp)
 3249b24:	10800117 	ldw	r2,4(r2)
 3249b28:	10c00617 	ldw	r3,24(r2)
 3249b2c:	e0bffe17 	ldw	r2,-8(fp)
 3249b30:	10800117 	ldw	r2,4(r2)
 3249b34:	10800817 	ldw	r2,32(r2)
 3249b38:	1885883a 	add	r2,r3,r2
 3249b3c:	2080071e 	bne	r4,r2,3249b5c <vftell+0xe0>
      {
         vfs_unlock();
 3249b40:	01000144 	movi	r4,5
 3249b44:	322b23c0 	call	322b23c <post_app_sem>

         return vfd->file->comp_size;
 3249b48:	e0bffe17 	ldw	r2,-8(fp)
 3249b4c:	10800117 	ldw	r2,4(r2)
 3249b50:	10800817 	ldw	r2,32(r2)
 3249b54:	e0bfff15 	stw	r2,-4(fp)
 3249b58:	00000f06 	br	3249b98 <vftell+0x11c>
      }
      else
      {
         vfs_unlock();
 3249b5c:	01000144 	movi	r4,5
 3249b60:	322b23c0 	call	322b23c <post_app_sem>

         return (vfd->cmploc - vfd->file->data);
 3249b64:	e0bffe17 	ldw	r2,-8(fp)
 3249b68:	10800217 	ldw	r2,8(r2)
 3249b6c:	1007883a 	mov	r3,r2
 3249b70:	e0bffe17 	ldw	r2,-8(fp)
 3249b74:	10800117 	ldw	r2,4(r2)
 3249b78:	10800617 	ldw	r2,24(r2)
 3249b7c:	1887c83a 	sub	r3,r3,r2
 3249b80:	e0ffff15 	stw	r3,-4(fp)
 3249b84:	00000406 	br	3249b98 <vftell+0x11c>
      }
   }

   vfs_unlock();
 3249b88:	01000144 	movi	r4,5
 3249b8c:	322b23c0 	call	322b23c <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(ftell((FILE*)vfd));
#else
   return EBADF;
 3249b90:	00800244 	movi	r2,9
 3249b94:	e0bfff15 	stw	r2,-4(fp)
 3249b98:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 3249b9c:	e037883a 	mov	sp,fp
 3249ba0:	dfc00117 	ldw	ra,4(sp)
 3249ba4:	df000017 	ldw	fp,0(sp)
 3249ba8:	dec00204 	addi	sp,sp,8
 3249bac:	f800283a 	ret

03249bb0 <vgetc_locked>:
 * RETURNS: 
 */

int
vgetc_locked(VFILE * vfd)
{
 3249bb0:	defffa04 	addi	sp,sp,-24
 3249bb4:	dfc00515 	stw	ra,20(sp)
 3249bb8:	df000415 	stw	fp,16(sp)
 3249bbc:	df000404 	addi	fp,sp,16
 3249bc0:	e13ffe15 	stw	r4,-8(fp)
   int   chr;

   if (isvfile_locked(vfd))
 3249bc4:	e13ffe17 	ldw	r4,-8(fp)
 3249bc8:	324a0800 	call	324a080 <isvfile_locked>
 3249bcc:	1005003a 	cmpeq	r2,r2,zero
 3249bd0:	1000361e 	bne	r2,zero,3249cac <vgetc_locked+0xfc>
   {
#ifdef HT_RWVFS
      /* the caller is trying to read a file that's been deleted,
         so return an error condition */
      if (vfd->file == NULL)
 3249bd4:	e0bffe17 	ldw	r2,-8(fp)
 3249bd8:	10800117 	ldw	r2,4(r2)
 3249bdc:	1004c03a 	cmpne	r2,r2,zero
 3249be0:	1000031e 	bne	r2,zero,3249bf0 <vgetc_locked+0x40>
      {
         return EOF;
 3249be4:	00bfffc4 	movi	r2,-1
 3249be8:	e0bfff15 	stw	r2,-4(fp)
 3249bec:	00003206 	br	3249cb8 <vgetc_locked+0x108>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 3249bf0:	e0bffe17 	ldw	r2,-8(fp)
 3249bf4:	10800117 	ldw	r2,4(r2)
 3249bf8:	10800a17 	ldw	r2,40(r2)
 3249bfc:	1005003a 	cmpeq	r2,r2,zero
 3249c00:	10000a1e 	bne	r2,zero,3249c2c <vgetc_locked+0x7c>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 3249c04:	e0bffe17 	ldw	r2,-8(fp)
 3249c08:	10800117 	ldw	r2,4(r2)
 3249c0c:	10800a17 	ldw	r2,40(r2)
 3249c10:	e0bffc15 	stw	r2,-16(fp)
         return (vfp->r_fgetc(vfd));
 3249c14:	e0bffc17 	ldw	r2,-16(fp)
 3249c18:	10800717 	ldw	r2,28(r2)
 3249c1c:	e13ffe17 	ldw	r4,-8(fp)
 3249c20:	103ee83a 	callr	r2
 3249c24:	e0bfff15 	stw	r2,-4(fp)
 3249c28:	00002306 	br	3249cb8 <vgetc_locked+0x108>
#endif   /* HT_EXTDEV */

#ifdef HT_RWVFS
      /* a freshly created file might not have a data buffer associated
         with it yet */
      if (vfd->file->data == NULL)
 3249c2c:	e0bffe17 	ldw	r2,-8(fp)
 3249c30:	10800117 	ldw	r2,4(r2)
 3249c34:	10800617 	ldw	r2,24(r2)
 3249c38:	1004c03a 	cmpne	r2,r2,zero
 3249c3c:	1000031e 	bne	r2,zero,3249c4c <vgetc_locked+0x9c>
         return EOF;
 3249c40:	00bfffc4 	movi	r2,-1
 3249c44:	e0bfff15 	stw	r2,-4(fp)
 3249c48:	00001b06 	br	3249cb8 <vgetc_locked+0x108>
      }
      else  /* HTML compression flag not set */
      {
#endif   /* HTML_COMPRESSION */
         /* Check to see if read has advanced to end of file */
         if (vfd->cmploc >= (vfd->file->data + vfd->file->comp_size))
 3249c4c:	e0bffe17 	ldw	r2,-8(fp)
 3249c50:	11000217 	ldw	r4,8(r2)
 3249c54:	e0bffe17 	ldw	r2,-8(fp)
 3249c58:	10800117 	ldw	r2,4(r2)
 3249c5c:	10c00617 	ldw	r3,24(r2)
 3249c60:	e0bffe17 	ldw	r2,-8(fp)
 3249c64:	10800117 	ldw	r2,4(r2)
 3249c68:	10800817 	ldw	r2,32(r2)
 3249c6c:	1885883a 	add	r2,r3,r2
 3249c70:	20800336 	bltu	r4,r2,3249c80 <vgetc_locked+0xd0>
            chr = EOF;
 3249c74:	00bfffc4 	movi	r2,-1
 3249c78:	e0bffd15 	stw	r2,-12(fp)
 3249c7c:	00000806 	br	3249ca0 <vgetc_locked+0xf0>
         else  /* else just get next char to return */
            chr = *(vfd->cmploc++);
 3249c80:	e0bffe17 	ldw	r2,-8(fp)
 3249c84:	10c00217 	ldw	r3,8(r2)
 3249c88:	18800003 	ldbu	r2,0(r3)
 3249c8c:	10803fcc 	andi	r2,r2,255
 3249c90:	e0bffd15 	stw	r2,-12(fp)
 3249c94:	18c00044 	addi	r3,r3,1
 3249c98:	e0bffe17 	ldw	r2,-8(fp)
 3249c9c:	10c00215 	stw	r3,8(r2)
#ifdef HTML_COMPRESSION
      }  /* need to close brace form if...else; */
#endif   /* HTML_COMPRESSION */

      return chr;
 3249ca0:	e0bffd17 	ldw	r2,-12(fp)
 3249ca4:	e0bfff15 	stw	r2,-4(fp)
 3249ca8:	00000306 	br	3249cb8 <vgetc_locked+0x108>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(getc((FILE*)vfd));
#else
   dtrap(); /* can this happen? */
 3249cac:	322ab8c0 	call	322ab8c <dtrap>
   return EOF;
 3249cb0:	00bfffc4 	movi	r2,-1
 3249cb4:	e0bfff15 	stw	r2,-4(fp)
 3249cb8:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 3249cbc:	e037883a 	mov	sp,fp
 3249cc0:	dfc00117 	ldw	ra,4(sp)
 3249cc4:	df000017 	ldw	fp,0(sp)
 3249cc8:	dec00204 	addi	sp,sp,8
 3249ccc:	f800283a 	ret

03249cd0 <vgetc>:
 * RETURNS: 
 */

int
vgetc(VFILE * vfd)
{
 3249cd0:	defffc04 	addi	sp,sp,-16
 3249cd4:	dfc00315 	stw	ra,12(sp)
 3249cd8:	df000215 	stw	fp,8(sp)
 3249cdc:	df000204 	addi	fp,sp,8
 3249ce0:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 3249ce4:	01000144 	movi	r4,5
 3249ce8:	322b1880 	call	322b188 <wait_app_sem>

   /* get the character */
   rc = vgetc_locked(vfd);
 3249cec:	e13fff17 	ldw	r4,-4(fp)
 3249cf0:	3249bb00 	call	3249bb0 <vgetc_locked>
 3249cf4:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 3249cf8:	01000144 	movi	r4,5
 3249cfc:	322b23c0 	call	322b23c <post_app_sem>
   return rc;
 3249d00:	e0bffe17 	ldw	r2,-8(fp)
}
 3249d04:	e037883a 	mov	sp,fp
 3249d08:	dfc00117 	ldw	ra,4(sp)
 3249d0c:	df000017 	ldw	fp,0(sp)
 3249d10:	dec00204 	addi	sp,sp,8
 3249d14:	f800283a 	ret

03249d18 <vfslookup_locked>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup_locked(char * name)
{
 3249d18:	defffa04 	addi	sp,sp,-24
 3249d1c:	dfc00515 	stw	ra,20(sp)
 3249d20:	df000415 	stw	fp,16(sp)
 3249d24:	df000404 	addi	fp,sp,16
 3249d28:	e13ffe15 	stw	r4,-8(fp)

#ifdef VFS_STRIPPATH
   char *   cp;

   /* If root path is prepended to name, skip past it */
   if (*name == '/' || *name == '\\')
 3249d2c:	e0bffe17 	ldw	r2,-8(fp)
 3249d30:	10800003 	ldbu	r2,0(r2)
 3249d34:	10803fcc 	andi	r2,r2,255
 3249d38:	1080201c 	xori	r2,r2,128
 3249d3c:	10bfe004 	addi	r2,r2,-128
 3249d40:	10800be0 	cmpeqi	r2,r2,47
 3249d44:	1000071e 	bne	r2,zero,3249d64 <vfslookup_locked+0x4c>
 3249d48:	e0bffe17 	ldw	r2,-8(fp)
 3249d4c:	10800003 	ldbu	r2,0(r2)
 3249d50:	10803fcc 	andi	r2,r2,255
 3249d54:	1080201c 	xori	r2,r2,128
 3249d58:	10bfe004 	addi	r2,r2,-128
 3249d5c:	10801718 	cmpnei	r2,r2,92
 3249d60:	10001a1e 	bne	r2,zero,3249dcc <vfslookup_locked+0xb4>
   {
      cp = strippath(name);
 3249d64:	e13ffe17 	ldw	r4,-8(fp)
 3249d68:	3249e980 	call	3249e98 <strippath>
 3249d6c:	e0bffc15 	stw	r2,-16(fp)

      if (!cp) /* strippath coundn't match our path */
 3249d70:	e0bffc17 	ldw	r2,-16(fp)
 3249d74:	1004c03a 	cmpne	r2,r2,zero
 3249d78:	1000121e 	bne	r2,zero,3249dc4 <vfslookup_locked+0xac>
      {
         /* Files like "/hub47.gif" need to be taken care of */
         if (*name == '/' || *name == '\\')
 3249d7c:	e0bffe17 	ldw	r2,-8(fp)
 3249d80:	10800003 	ldbu	r2,0(r2)
 3249d84:	10803fcc 	andi	r2,r2,255
 3249d88:	1080201c 	xori	r2,r2,128
 3249d8c:	10bfe004 	addi	r2,r2,-128
 3249d90:	10800be0 	cmpeqi	r2,r2,47
 3249d94:	1000071e 	bne	r2,zero,3249db4 <vfslookup_locked+0x9c>
 3249d98:	e0bffe17 	ldw	r2,-8(fp)
 3249d9c:	10800003 	ldbu	r2,0(r2)
 3249da0:	10803fcc 	andi	r2,r2,255
 3249da4:	1080201c 	xori	r2,r2,128
 3249da8:	10bfe004 	addi	r2,r2,-128
 3249dac:	10801718 	cmpnei	r2,r2,92
 3249db0:	1000061e 	bne	r2,zero,3249dcc <vfslookup_locked+0xb4>
            name++;
 3249db4:	e0bffe17 	ldw	r2,-8(fp)
 3249db8:	10800044 	addi	r2,r2,1
 3249dbc:	e0bffe15 	stw	r2,-8(fp)
 3249dc0:	00000206 	br	3249dcc <vfslookup_locked+0xb4>
      }
      else
         name = cp ;
 3249dc4:	e0bffc17 	ldw	r2,-16(fp)
 3249dc8:	e0bffe15 	stw	r2,-8(fp)
   }
#endif   /* VFS_STRIPPATH */

   /* see if there is a question mark in the file name */
   if (strchr(name,'?'))
 3249dcc:	e13ffe17 	ldw	r4,-8(fp)
 3249dd0:	01400fc4 	movi	r5,63
 3249dd4:	32079f00 	call	32079f0 <strchr>
 3249dd8:	1005003a 	cmpeq	r2,r2,zero
 3249ddc:	1000031e 	bne	r2,zero,3249dec <vfslookup_locked+0xd4>
   {
      dtrap(); /* is this still allowed? */
 3249de0:	322ab8c0 	call	322ab8c <dtrap>
      return NULL;
 3249de4:	e03fff15 	stw	zero,-4(fp)
 3249de8:	00001306 	br	3249e38 <vfslookup_locked+0x120>
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 3249dec:	d0a90d17 	ldw	r2,-23500(gp)
 3249df0:	e0bffd15 	stw	r2,-12(fp)
 3249df4:	00000c06 	br	3249e28 <vfslookup_locked+0x110>
   {
      if (strcmp(name, vp->name) == 0)
 3249df8:	e0bffd17 	ldw	r2,-12(fp)
 3249dfc:	11400104 	addi	r5,r2,4
 3249e00:	e13ffe17 	ldw	r4,-8(fp)
 3249e04:	320ebb80 	call	320ebb8 <strcmp>
 3249e08:	1004c03a 	cmpne	r2,r2,zero
 3249e0c:	1000031e 	bne	r2,zero,3249e1c <vfslookup_locked+0x104>
         return vp;
 3249e10:	e0bffd17 	ldw	r2,-12(fp)
 3249e14:	e0bfff15 	stw	r2,-4(fp)
 3249e18:	00000706 	br	3249e38 <vfslookup_locked+0x120>
   {
      dtrap(); /* is this still allowed? */
      return NULL;
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 3249e1c:	e0bffd17 	ldw	r2,-12(fp)
 3249e20:	10800017 	ldw	r2,0(r2)
 3249e24:	e0bffd15 	stw	r2,-12(fp)
 3249e28:	e0bffd17 	ldw	r2,-12(fp)
 3249e2c:	1004c03a 	cmpne	r2,r2,zero
 3249e30:	103ff11e 	bne	r2,zero,3249df8 <vfslookup_locked+0xe0>
   {
      if (strcmp(name, vp->name) == 0)
         return vp;
   }

   return NULL;   /* fall to here if not found in for loop */
 3249e34:	e03fff15 	stw	zero,-4(fp)
 3249e38:	e0bfff17 	ldw	r2,-4(fp)
}
 3249e3c:	e037883a 	mov	sp,fp
 3249e40:	dfc00117 	ldw	ra,4(sp)
 3249e44:	df000017 	ldw	fp,0(sp)
 3249e48:	dec00204 	addi	sp,sp,8
 3249e4c:	f800283a 	ret

03249e50 <vfslookup>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup(char * name) 
{
 3249e50:	defffc04 	addi	sp,sp,-16
 3249e54:	dfc00315 	stw	ra,12(sp)
 3249e58:	df000215 	stw	fp,8(sp)
 3249e5c:	df000204 	addi	fp,sp,8
 3249e60:	e13fff15 	stw	r4,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfslookup() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 3249e64:	01000144 	movi	r4,5
 3249e68:	322b1880 	call	322b188 <wait_app_sem>

   /* do the lookup */
   vp = vfslookup_locked(name);
 3249e6c:	e13fff17 	ldw	r4,-4(fp)
 3249e70:	3249d180 	call	3249d18 <vfslookup_locked>
 3249e74:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 3249e78:	01000144 	movi	r4,5
 3249e7c:	322b23c0 	call	322b23c <post_app_sem>
   return vp;
 3249e80:	e0bffe17 	ldw	r2,-8(fp)
}
 3249e84:	e037883a 	mov	sp,fp
 3249e88:	dfc00117 	ldw	ra,4(sp)
 3249e8c:	df000017 	ldw	fp,0(sp)
 3249e90:	dec00204 	addi	sp,sp,8
 3249e94:	f800283a 	ret

03249e98 <strippath>:
 * have the http_root_path prepended; or on any error. 
 */

char * 
strippath(char * name)
{
 3249e98:	defff804 	addi	sp,sp,-32
 3249e9c:	dfc00715 	stw	ra,28(sp)
 3249ea0:	df000615 	stw	fp,24(sp)
 3249ea4:	df000604 	addi	fp,sp,24
 3249ea8:	e13ffe15 	stw	r4,-8(fp)
   char *   path; /* pointer into system path */
   char *   ptmp; /* another pointer into path */
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
 3249eac:	e13ffe17 	ldw	r4,-8(fp)
 3249eb0:	3225f980 	call	3225f98 <uslash>
 3249eb4:	e0bffb15 	stw	r2,-20(fp)
   path = http_root_path; /* The servers root path, at least one UNIX slash */
 3249eb8:	d0a05117 	ldw	r2,-32444(gp)
 3249ebc:	e0bffd15 	stw	r2,-12(fp)
   while (*path && *ntmp)
 3249ec0:	00003e06 	br	3249fbc <strippath+0x124>
   {
      while (*path == '/') path++;   /* strip leading slash */
 3249ec4:	e0bffd17 	ldw	r2,-12(fp)
 3249ec8:	10800044 	addi	r2,r2,1
 3249ecc:	e0bffd15 	stw	r2,-12(fp)
 3249ed0:	e0bffd17 	ldw	r2,-12(fp)
 3249ed4:	10800003 	ldbu	r2,0(r2)
 3249ed8:	10803fcc 	andi	r2,r2,255
 3249edc:	1080201c 	xori	r2,r2,128
 3249ee0:	10bfe004 	addi	r2,r2,-128
 3249ee4:	10800be0 	cmpeqi	r2,r2,47
 3249ee8:	103ff61e 	bne	r2,zero,3249ec4 <strippath+0x2c>
         if (*path == 0)
 3249eec:	e0bffd17 	ldw	r2,-12(fp)
 3249ef0:	10800003 	ldbu	r2,0(r2)
 3249ef4:	10803fcc 	andi	r2,r2,255
 3249ef8:	1080201c 	xori	r2,r2,128
 3249efc:	10bfe004 	addi	r2,r2,-128
 3249f00:	1005003a 	cmpeq	r2,r2,zero
 3249f04:	10003b1e 	bne	r2,zero,3249ff4 <strippath+0x15c>
         break;
      /* find number of chars in this directory layer's name */
      ptmp = strchr(path, '/');   /* location of next slash in path */
 3249f08:	e13ffd17 	ldw	r4,-12(fp)
 3249f0c:	01400bc4 	movi	r5,47
 3249f10:	32079f00 	call	32079f0 <strchr>
 3249f14:	e0bffc15 	stw	r2,-16(fp)
      if (ptmp)
 3249f18:	e0bffc17 	ldw	r2,-16(fp)
 3249f1c:	1005003a 	cmpeq	r2,r2,zero
 3249f20:	1000051e 	bne	r2,zero,3249f38 <strippath+0xa0>
         dirlen = ptmp - path;
 3249f24:	e0bffc17 	ldw	r2,-16(fp)
 3249f28:	e0fffd17 	ldw	r3,-12(fp)
 3249f2c:	10c5c83a 	sub	r2,r2,r3
 3249f30:	e0bffa15 	stw	r2,-24(fp)
 3249f34:	00000706 	br	3249f54 <strippath+0xbc>
      else
         dirlen = strlen(path);
 3249f38:	e13ffd17 	ldw	r4,-12(fp)
 3249f3c:	32081440 	call	3208144 <strlen>
 3249f40:	e0bffa15 	stw	r2,-24(fp)

      while (*ntmp == '/') ntmp++;   /* strip leading slash */
 3249f44:	00000306 	br	3249f54 <strippath+0xbc>
 3249f48:	e0bffb17 	ldw	r2,-20(fp)
 3249f4c:	10800044 	addi	r2,r2,1
 3249f50:	e0bffb15 	stw	r2,-20(fp)
 3249f54:	e0bffb17 	ldw	r2,-20(fp)
 3249f58:	10800003 	ldbu	r2,0(r2)
 3249f5c:	10803fcc 	andi	r2,r2,255
 3249f60:	1080201c 	xori	r2,r2,128
 3249f64:	10bfe004 	addi	r2,r2,-128
 3249f68:	10800be0 	cmpeqi	r2,r2,47
 3249f6c:	103ff61e 	bne	r2,zero,3249f48 <strippath+0xb0>
         if (strncmp(ntmp, path, dirlen) == 0)
 3249f70:	e1bffa17 	ldw	r6,-24(fp)
 3249f74:	e13ffb17 	ldw	r4,-20(fp)
 3249f78:	e17ffd17 	ldw	r5,-12(fp)
 3249f7c:	324ba5c0 	call	324ba5c <strncmp>
 3249f80:	1004c03a 	cmpne	r2,r2,zero
 3249f84:	10000b1e 	bne	r2,zero,3249fb4 <strippath+0x11c>
      {
         path += dirlen;
 3249f88:	e0bffa17 	ldw	r2,-24(fp)
 3249f8c:	1007883a 	mov	r3,r2
 3249f90:	e0bffd17 	ldw	r2,-12(fp)
 3249f94:	10c5883a 	add	r2,r2,r3
 3249f98:	e0bffd15 	stw	r2,-12(fp)
         ntmp += dirlen;
 3249f9c:	e0bffa17 	ldw	r2,-24(fp)
 3249fa0:	1007883a 	mov	r3,r2
 3249fa4:	e0bffb17 	ldw	r2,-20(fp)
 3249fa8:	10c5883a 	add	r2,r2,r3
 3249fac:	e0bffb15 	stw	r2,-20(fp)
 3249fb0:	00000206 	br	3249fbc <strippath+0x124>
      }
      else
         return NULL;   /* didn't match */
 3249fb4:	e03fff15 	stw	zero,-4(fp)
 3249fb8:	00002b06 	br	324a068 <strippath+0x1d0>
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
   path = http_root_path; /* The servers root path, at least one UNIX slash */
   while (*path && *ntmp)
 3249fbc:	e0bffd17 	ldw	r2,-12(fp)
 3249fc0:	10800003 	ldbu	r2,0(r2)
 3249fc4:	10803fcc 	andi	r2,r2,255
 3249fc8:	1080201c 	xori	r2,r2,128
 3249fcc:	10bfe004 	addi	r2,r2,-128
 3249fd0:	1005003a 	cmpeq	r2,r2,zero
 3249fd4:	1000071e 	bne	r2,zero,3249ff4 <strippath+0x15c>
 3249fd8:	e0bffb17 	ldw	r2,-20(fp)
 3249fdc:	10800003 	ldbu	r2,0(r2)
 3249fe0:	10803fcc 	andi	r2,r2,255
 3249fe4:	1080201c 	xori	r2,r2,128
 3249fe8:	10bfe004 	addi	r2,r2,-128
 3249fec:	1004c03a 	cmpne	r2,r2,zero
 3249ff0:	103fb71e 	bne	r2,zero,3249ed0 <strippath+0x38>
         ntmp += dirlen;
      }
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
 3249ff4:	e0bffd17 	ldw	r2,-12(fp)
 3249ff8:	10800003 	ldbu	r2,0(r2)
 3249ffc:	10803fcc 	andi	r2,r2,255
 324a000:	1080201c 	xori	r2,r2,128
 324a004:	10bfe004 	addi	r2,r2,-128
 324a008:	1004c03a 	cmpne	r2,r2,zero
 324a00c:	1000151e 	bne	r2,zero,324a064 <strippath+0x1cc>
   {
      while (*ntmp == '\\' || *ntmp == '/')
 324a010:	00000306 	br	324a020 <strippath+0x188>
         ntmp++;
 324a014:	e0bffb17 	ldw	r2,-20(fp)
 324a018:	10800044 	addi	r2,r2,1
 324a01c:	e0bffb15 	stw	r2,-20(fp)
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
   {
      while (*ntmp == '\\' || *ntmp == '/')
 324a020:	e0bffb17 	ldw	r2,-20(fp)
 324a024:	10800003 	ldbu	r2,0(r2)
 324a028:	10803fcc 	andi	r2,r2,255
 324a02c:	1080201c 	xori	r2,r2,128
 324a030:	10bfe004 	addi	r2,r2,-128
 324a034:	10801720 	cmpeqi	r2,r2,92
 324a038:	103ff61e 	bne	r2,zero,324a014 <strippath+0x17c>
 324a03c:	e0bffb17 	ldw	r2,-20(fp)
 324a040:	10800003 	ldbu	r2,0(r2)
 324a044:	10803fcc 	andi	r2,r2,255
 324a048:	1080201c 	xori	r2,r2,128
 324a04c:	10bfe004 	addi	r2,r2,-128
 324a050:	10800be0 	cmpeqi	r2,r2,47
 324a054:	103fef1e 	bne	r2,zero,324a014 <strippath+0x17c>
         ntmp++;
      return ntmp;
 324a058:	e0bffb17 	ldw	r2,-20(fp)
 324a05c:	e0bfff15 	stw	r2,-4(fp)
 324a060:	00000106 	br	324a068 <strippath+0x1d0>
   }
   else
      return NULL;
 324a064:	e03fff15 	stw	zero,-4(fp)
 324a068:	e0bfff17 	ldw	r2,-4(fp)
}
 324a06c:	e037883a 	mov	sp,fp
 324a070:	dfc00117 	ldw	ra,4(sp)
 324a074:	df000017 	ldw	fp,0(sp)
 324a078:	dec00204 	addi	sp,sp,8
 324a07c:	f800283a 	ret

0324a080 <isvfile_locked>:
 * RETURNS: 
 */

int
isvfile_locked(VFILE * vfp)
{
 324a080:	defffc04 	addi	sp,sp,-16
 324a084:	df000315 	stw	fp,12(sp)
 324a088:	df000304 	addi	fp,sp,12
 324a08c:	e13ffe15 	stw	r4,-8(fp)
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 324a090:	d0a90c17 	ldw	r2,-23504(gp)
 324a094:	e0bffd15 	stw	r2,-12(fp)
 324a098:	00000906 	br	324a0c0 <isvfile_locked+0x40>
      if (vtmp == vfp)
 324a09c:	e0fffd17 	ldw	r3,-12(fp)
 324a0a0:	e0bffe17 	ldw	r2,-8(fp)
 324a0a4:	1880031e 	bne	r3,r2,324a0b4 <isvfile_locked+0x34>
      return TRUE;
 324a0a8:	00800044 	movi	r2,1
 324a0ac:	e0bfff15 	stw	r2,-4(fp)
 324a0b0:	00000706 	br	324a0d0 <isvfile_locked+0x50>
int
isvfile_locked(VFILE * vfp)
{
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 324a0b4:	e0bffd17 	ldw	r2,-12(fp)
 324a0b8:	10800017 	ldw	r2,0(r2)
 324a0bc:	e0bffd15 	stw	r2,-12(fp)
 324a0c0:	e0bffd17 	ldw	r2,-12(fp)
 324a0c4:	1004c03a 	cmpne	r2,r2,zero
 324a0c8:	103ff41e 	bne	r2,zero,324a09c <isvfile_locked+0x1c>
      if (vtmp == vfp)
      return TRUE;

   return FALSE;  /* passed pointer not found in list */
 324a0cc:	e03fff15 	stw	zero,-4(fp)
 324a0d0:	e0bfff17 	ldw	r2,-4(fp)
}
 324a0d4:	e037883a 	mov	sp,fp
 324a0d8:	df000017 	ldw	fp,0(sp)
 324a0dc:	dec00104 	addi	sp,sp,4
 324a0e0:	f800283a 	ret

0324a0e4 <isvfile>:
 * RETURNS: 
 */

int
isvfile(VFILE * vfp)
{
 324a0e4:	defffc04 	addi	sp,sp,-16
 324a0e8:	dfc00315 	stw	ra,12(sp)
 324a0ec:	df000215 	stw	fp,8(sp)
 324a0f0:	df000204 	addi	fp,sp,8
 324a0f4:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 324a0f8:	01000144 	movi	r4,5
 324a0fc:	322b1880 	call	322b188 <wait_app_sem>

   /* do the lookup */
   rc = isvfile_locked(vfp);
 324a100:	e13fff17 	ldw	r4,-4(fp)
 324a104:	324a0800 	call	324a080 <isvfile_locked>
 324a108:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 324a10c:	01000144 	movi	r4,5
 324a110:	322b23c0 	call	322b23c <post_app_sem>
   return rc;
 324a114:	e0bffe17 	ldw	r2,-8(fp)
}
 324a118:	e037883a 	mov	sp,fp
 324a11c:	dfc00117 	ldw	ra,4(sp)
 324a120:	df000017 	ldw	fp,0(sp)
 324a124:	dec00204 	addi	sp,sp,8
 324a128:	f800283a 	ret

0324a12c <vferror>:
 * RETURNS: 
 */

int
vferror(VFILE * vfd)
{
 324a12c:	defffc04 	addi	sp,sp,-16
 324a130:	dfc00315 	stw	ra,12(sp)
 324a134:	df000215 	stw	fp,8(sp)
 324a138:	df000204 	addi	fp,sp,8
 324a13c:	e13ffe15 	stw	r4,-8(fp)
   /* lock the VFS */
   vfs_lock();
 324a140:	01000144 	movi	r4,5
 324a144:	322b1880 	call	322b188 <wait_app_sem>

   if (isvfile_locked(vfd))
 324a148:	e13ffe17 	ldw	r4,-8(fp)
 324a14c:	324a0800 	call	324a080 <isvfile_locked>
 324a150:	1005003a 	cmpeq	r2,r2,zero
 324a154:	1000061e 	bne	r2,zero,324a170 <vferror+0x44>
   {
      vfs_unlock();
 324a158:	01000144 	movi	r4,5
 324a15c:	322b23c0 	call	322b23c <post_app_sem>

      return vfd->error;
 324a160:	e0bffe17 	ldw	r2,-8(fp)
 324a164:	10800417 	ldw	r2,16(r2)
 324a168:	e0bfff15 	stw	r2,-4(fp)
 324a16c:	00000406 	br	324a180 <vferror+0x54>
   }

   vfs_unlock();
 324a170:	01000144 	movi	r4,5
 324a174:	322b23c0 	call	322b23c <post_app_sem>

#ifdef HT_LOCALFS
   return(ferror((FILE*)vfd));
#else /* not a VFILE, and no local FS */
   return -1;  /* should this be an error? */
 324a178:	00bfffc4 	movi	r2,-1
 324a17c:	e0bfff15 	stw	r2,-4(fp)
 324a180:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 324a184:	e037883a 	mov	sp,fp
 324a188:	dfc00117 	ldw	ra,4(sp)
 324a18c:	df000017 	ldw	fp,0(sp)
 324a190:	dec00204 	addi	sp,sp,8
 324a194:	f800283a 	ret

0324a198 <vclearerr>:
 *
 * RETURNS: 
 */

void vclearerr(VFILE * vfd)
{
 324a198:	defffd04 	addi	sp,sp,-12
 324a19c:	dfc00215 	stw	ra,8(sp)
 324a1a0:	df000115 	stw	fp,4(sp)
 324a1a4:	df000104 	addi	fp,sp,4
 324a1a8:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 324a1ac:	01000144 	movi	r4,5
 324a1b0:	322b1880 	call	322b188 <wait_app_sem>

   if (isvfile_locked(vfd))
 324a1b4:	e13fff17 	ldw	r4,-4(fp)
 324a1b8:	324a0800 	call	324a080 <isvfile_locked>
 324a1bc:	1005003a 	cmpeq	r2,r2,zero
 324a1c0:	1000051e 	bne	r2,zero,324a1d8 <vclearerr+0x40>
   {
      vfs_unlock();
 324a1c4:	01000144 	movi	r4,5
 324a1c8:	322b23c0 	call	322b23c <post_app_sem>

      vfd->error = 0;
 324a1cc:	e0bfff17 	ldw	r2,-4(fp)
 324a1d0:	10000415 	stw	zero,16(r2)
      return;
 324a1d4:	00000206 	br	324a1e0 <vclearerr+0x48>
   }

   vfs_unlock();
 324a1d8:	01000144 	movi	r4,5
 324a1dc:	322b23c0 	call	322b23c <post_app_sem>

#ifdef HT_LOCALFS
   clearerr((FILE *) vfd);
#endif   /* HT_LOCALFS */
}
 324a1e0:	e037883a 	mov	sp,fp
 324a1e4:	dfc00117 	ldw	ra,4(sp)
 324a1e8:	df000017 	ldw	fp,0(sp)
 324a1ec:	dec00204 	addi	sp,sp,8
 324a1f0:	f800283a 	ret

0324a1f4 <prep_vfs>:
 * PARAMS: NONE
 *
 * RETURNS: Error Code or 0 for OK
 */
int prep_vfs(void)
{
 324a1f4:	defffe04 	addi	sp,sp,-8
 324a1f8:	df000115 	stw	fp,4(sp)
 324a1fc:	df000104 	addi	fp,sp,4
int e = 0;
 324a200:	e03fff15 	stw	zero,-4(fp)
   {
      dprintf("unable to install VFS NVPARMS, reconfigure nv_formats[]\n");
      dtrap();
   }
#endif   /* INCLUDE_NVPARMS */
   return e;
 324a204:	e0bfff17 	ldw	r2,-4(fp)
}
 324a208:	e037883a 	mov	sp,fp
 324a20c:	df000017 	ldw	fp,0(sp)
 324a210:	dec00104 	addi	sp,sp,4
 324a214:	f800283a 	ret

0324a218 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 324a218:	defffa04 	addi	sp,sp,-24
 324a21c:	dfc00515 	stw	ra,20(sp)
 324a220:	df000415 	stw	fp,16(sp)
 324a224:	df000404 	addi	fp,sp,16
 324a228:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 324a22c:	008000c4 	movi	r2,3
 324a230:	e0bffc15 	stw	r2,-16(fp)
  }
  

  big_loops = us / (INT_MAX/
 324a234:	e0fffc17 	ldw	r3,-16(fp)
 324a238:	008003f4 	movhi	r2,15
 324a23c:	10909004 	addi	r2,r2,16960
 324a240:	188b383a 	mul	r5,r3,r2
 324a244:	01017db4 	movhi	r4,1526
 324a248:	21384004 	addi	r4,r4,-7936
 324a24c:	32044bc0 	call	32044bc <__udivsi3>
 324a250:	100b883a 	mov	r5,r2
 324a254:	01200034 	movhi	r4,32768
 324a258:	213fffc4 	addi	r4,r4,-1
 324a25c:	32044bc0 	call	32044bc <__udivsi3>
 324a260:	100b883a 	mov	r5,r2
 324a264:	e13fff17 	ldw	r4,-4(fp)
 324a268:	32044bc0 	call	32044bc <__udivsi3>
 324a26c:	e0bffd15 	stw	r2,-12(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 324a270:	e0bffd17 	ldw	r2,-12(fp)
 324a274:	1005003a 	cmpeq	r2,r2,zero
 324a278:	1000281e 	bne	r2,zero,324a31c <alt_busy_sleep+0x104>
  {
    for(i=0;i<big_loops;i++)
 324a27c:	e03ffe15 	stw	zero,-8(fp)
 324a280:	00001606 	br	324a2dc <alt_busy_sleep+0xc4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 324a284:	00a00034 	movhi	r2,32768
 324a288:	10bfffc4 	addi	r2,r2,-1
 324a28c:	10bfffc4 	addi	r2,r2,-1
 324a290:	103ffe1e 	bne	r2,zero,324a28c <alt_busy_sleep+0x74>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 324a294:	e0fffc17 	ldw	r3,-16(fp)
 324a298:	008003f4 	movhi	r2,15
 324a29c:	10909004 	addi	r2,r2,16960
 324a2a0:	188b383a 	mul	r5,r3,r2
 324a2a4:	01017db4 	movhi	r4,1526
 324a2a8:	21384004 	addi	r4,r4,-7936
 324a2ac:	32044bc0 	call	32044bc <__udivsi3>
 324a2b0:	100b883a 	mov	r5,r2
 324a2b4:	01200034 	movhi	r4,32768
 324a2b8:	213fffc4 	addi	r4,r4,-1
 324a2bc:	32044bc0 	call	32044bc <__udivsi3>
 324a2c0:	1007883a 	mov	r3,r2
 324a2c4:	e0bfff17 	ldw	r2,-4(fp)
 324a2c8:	10c5c83a 	sub	r2,r2,r3
 324a2cc:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 324a2d0:	e0bffe17 	ldw	r2,-8(fp)
 324a2d4:	10800044 	addi	r2,r2,1
 324a2d8:	e0bffe15 	stw	r2,-8(fp)
 324a2dc:	e0fffe17 	ldw	r3,-8(fp)
 324a2e0:	e0bffd17 	ldw	r2,-12(fp)
 324a2e4:	18bfe716 	blt	r3,r2,324a284 <alt_busy_sleep+0x6c>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 324a2e8:	e0fffc17 	ldw	r3,-16(fp)
 324a2ec:	008003f4 	movhi	r2,15
 324a2f0:	10909004 	addi	r2,r2,16960
 324a2f4:	188b383a 	mul	r5,r3,r2
 324a2f8:	01017db4 	movhi	r4,1526
 324a2fc:	21384004 	addi	r4,r4,-7936
 324a300:	32044bc0 	call	32044bc <__udivsi3>
 324a304:	1007883a 	mov	r3,r2
 324a308:	e0bfff17 	ldw	r2,-4(fp)
 324a30c:	1885383a 	mul	r2,r3,r2
 324a310:	10bfffc4 	addi	r2,r2,-1
 324a314:	103ffe1e 	bne	r2,zero,324a310 <alt_busy_sleep+0xf8>
 324a318:	00000c06 	br	324a34c <alt_busy_sleep+0x134>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 324a31c:	e0fffc17 	ldw	r3,-16(fp)
 324a320:	008003f4 	movhi	r2,15
 324a324:	10909004 	addi	r2,r2,16960
 324a328:	188b383a 	mul	r5,r3,r2
 324a32c:	01017db4 	movhi	r4,1526
 324a330:	21384004 	addi	r4,r4,-7936
 324a334:	32044bc0 	call	32044bc <__udivsi3>
 324a338:	1007883a 	mov	r3,r2
 324a33c:	e0bfff17 	ldw	r2,-4(fp)
 324a340:	1885383a 	mul	r2,r3,r2
 324a344:	10bfffc4 	addi	r2,r2,-1
 324a348:	00bffe16 	blt	zero,r2,324a344 <alt_busy_sleep+0x12c>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 324a34c:	0005883a 	mov	r2,zero
}
 324a350:	e037883a 	mov	sp,fp
 324a354:	dfc00117 	ldw	ra,4(sp)
 324a358:	df000017 	ldw	fp,0(sp)
 324a35c:	dec00204 	addi	sp,sp,8
 324a360:	f800283a 	ret

0324a364 <alt_fcntl>:
 *
 * ALT_FCNTL is mapped onto the fcntl() system call in alt_syscall.h
 */
 
int ALT_FCNTL (int file, int cmd, ...)
{ 
 324a364:	defff404 	addi	sp,sp,-48
 324a368:	dfc00915 	stw	ra,36(sp)
 324a36c:	df000815 	stw	fp,32(sp)
 324a370:	df000804 	addi	fp,sp,32
 324a374:	e13ffb15 	stw	r4,-20(fp)
 324a378:	e1800215 	stw	r6,8(fp)
 324a37c:	e1c00315 	stw	r7,12(fp)
 324a380:	e17ffc15 	stw	r5,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 324a384:	e0bffb17 	ldw	r2,-20(fp)
 324a388:	1004803a 	cmplt	r2,r2,zero
 324a38c:	1000081e 	bne	r2,zero,324a3b0 <alt_fcntl+0x4c>
 324a390:	e0bffb17 	ldw	r2,-20(fp)
 324a394:	10800324 	muli	r2,r2,12
 324a398:	1007883a 	mov	r3,r2
 324a39c:	0080c974 	movhi	r2,805
 324a3a0:	10888304 	addi	r2,r2,8716
 324a3a4:	1887883a 	add	r3,r3,r2
 324a3a8:	e0fffe15 	stw	r3,-8(fp)
 324a3ac:	00000106 	br	324a3b4 <alt_fcntl+0x50>
 324a3b0:	e03ffe15 	stw	zero,-8(fp)
 324a3b4:	e0bffe17 	ldw	r2,-8(fp)
 324a3b8:	e0bff915 	stw	r2,-28(fp)
  
  if (fd)
 324a3bc:	e0bff917 	ldw	r2,-28(fp)
 324a3c0:	1005003a 	cmpeq	r2,r2,zero
 324a3c4:	1000301e 	bne	r2,zero,324a488 <alt_fcntl+0x124>
  {
    switch (cmd)
 324a3c8:	e0fffc17 	ldw	r3,-16(fp)
 324a3cc:	e0ffff15 	stw	r3,-4(fp)
 324a3d0:	e0ffff17 	ldw	r3,-4(fp)
 324a3d4:	188000e0 	cmpeqi	r2,r3,3
 324a3d8:	1000041e 	bne	r2,zero,324a3ec <alt_fcntl+0x88>
 324a3dc:	e0ffff17 	ldw	r3,-4(fp)
 324a3e0:	18800120 	cmpeqi	r2,r3,4
 324a3e4:	1000081e 	bne	r2,zero,324a408 <alt_fcntl+0xa4>
 324a3e8:	00002006 	br	324a46c <alt_fcntl+0x108>
    {
    case F_GETFL:
      return fd->fd_flags & ~((alt_u32) ALT_FD_FLAGS_MASK);
 324a3ec:	e0bff917 	ldw	r2,-28(fp)
 324a3f0:	10c00217 	ldw	r3,8(r2)
 324a3f4:	00900034 	movhi	r2,16384
 324a3f8:	10bfffc4 	addi	r2,r2,-1
 324a3fc:	1886703a 	and	r3,r3,r2
 324a400:	e0fffd15 	stw	r3,-12(fp)
 324a404:	00002606 	br	324a4a0 <alt_fcntl+0x13c>
    case F_SETFL:
      va_start(argp, cmd);
 324a408:	e0800204 	addi	r2,fp,8
 324a40c:	e0bffa15 	stw	r2,-24(fp)
      flags = va_arg(argp, long);
 324a410:	e0fffa17 	ldw	r3,-24(fp)
 324a414:	18800104 	addi	r2,r3,4
 324a418:	e0bffa15 	stw	r2,-24(fp)
 324a41c:	1805883a 	mov	r2,r3
 324a420:	10800017 	ldw	r2,0(r2)
 324a424:	e0bff815 	stw	r2,-32(fp)
      fd->fd_flags &= ~ALT_FCNTL_FLAGS_MASK;
 324a428:	e0bff917 	ldw	r2,-28(fp)
 324a42c:	10c00217 	ldw	r3,8(r2)
 324a430:	00affdc4 	movi	r2,-16393
 324a434:	1886703a 	and	r3,r3,r2
 324a438:	e0bff917 	ldw	r2,-28(fp)
 324a43c:	10c00215 	stw	r3,8(r2)
      fd->fd_flags |= (flags & ALT_FCNTL_FLAGS_MASK);
 324a440:	e0bff917 	ldw	r2,-28(fp)
 324a444:	10800217 	ldw	r2,8(r2)
 324a448:	1007883a 	mov	r3,r2
 324a44c:	e0bff817 	ldw	r2,-32(fp)
 324a450:	1090020c 	andi	r2,r2,16392
 324a454:	1884b03a 	or	r2,r3,r2
 324a458:	1007883a 	mov	r3,r2
 324a45c:	e0bff917 	ldw	r2,-28(fp)
 324a460:	10c00215 	stw	r3,8(r2)
      va_end(argp);
      return 0;
 324a464:	e03ffd15 	stw	zero,-12(fp)
 324a468:	00000d06 	br	324a4a0 <alt_fcntl+0x13c>
    default:
      ALT_ERRNO = EINVAL;
 324a46c:	324a4b80 	call	324a4b8 <alt_get_errno>
 324a470:	1007883a 	mov	r3,r2
 324a474:	00800584 	movi	r2,22
 324a478:	18800015 	stw	r2,0(r3)
      return -1;
 324a47c:	00bfffc4 	movi	r2,-1
 324a480:	e0bffd15 	stw	r2,-12(fp)
 324a484:	00000606 	br	324a4a0 <alt_fcntl+0x13c>
    }
  }

  ALT_ERRNO = EBADFD;
 324a488:	324a4b80 	call	324a4b8 <alt_get_errno>
 324a48c:	1007883a 	mov	r3,r2
 324a490:	00801444 	movi	r2,81
 324a494:	18800015 	stw	r2,0(r3)
  return -1;
 324a498:	00ffffc4 	movi	r3,-1
 324a49c:	e0fffd15 	stw	r3,-12(fp)
 324a4a0:	e0bffd17 	ldw	r2,-12(fp)
}
 324a4a4:	e037883a 	mov	sp,fp
 324a4a8:	dfc00117 	ldw	ra,4(sp)
 324a4ac:	df000017 	ldw	fp,0(sp)
 324a4b0:	dec00404 	addi	sp,sp,16
 324a4b4:	f800283a 	ret

0324a4b8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 324a4b8:	defffd04 	addi	sp,sp,-12
 324a4bc:	dfc00215 	stw	ra,8(sp)
 324a4c0:	df000115 	stw	fp,4(sp)
 324a4c4:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 324a4c8:	0080c974 	movhi	r2,805
 324a4cc:	1089ba04 	addi	r2,r2,9960
 324a4d0:	10800017 	ldw	r2,0(r2)
 324a4d4:	1005003a 	cmpeq	r2,r2,zero
 324a4d8:	1000061e 	bne	r2,zero,324a4f4 <alt_get_errno+0x3c>
 324a4dc:	0080c974 	movhi	r2,805
 324a4e0:	1089ba04 	addi	r2,r2,9960
 324a4e4:	10800017 	ldw	r2,0(r2)
 324a4e8:	103ee83a 	callr	r2
 324a4ec:	e0bfff15 	stw	r2,-4(fp)
 324a4f0:	00000306 	br	324a500 <alt_get_errno+0x48>
 324a4f4:	0080c974 	movhi	r2,805
 324a4f8:	10920d04 	addi	r2,r2,18484
 324a4fc:	e0bfff15 	stw	r2,-4(fp)
 324a500:	e0bfff17 	ldw	r2,-4(fp)
}
 324a504:	e037883a 	mov	sp,fp
 324a508:	dfc00117 	ldw	ra,4(sp)
 324a50c:	df000017 	ldw	fp,0(sp)
 324a510:	dec00204 	addi	sp,sp,8
 324a514:	f800283a 	ret

0324a518 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
 324a518:	defffb04 	addi	sp,sp,-20
 324a51c:	df000415 	stw	fp,16(sp)
 324a520:	df000404 	addi	fp,sp,16
 324a524:	e13ffe15 	stw	r4,-8(fp)
 324a528:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
 324a52c:	e0bfff17 	ldw	r2,-4(fp)
 324a530:	10900070 	cmpltui	r2,r2,16385
 324a534:	1000021e 	bne	r2,zero,324a540 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
 324a538:	00900004 	movi	r2,16384
 324a53c:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
 324a540:	e0fffe17 	ldw	r3,-8(fp)
 324a544:	e0bfff17 	ldw	r2,-4(fp)
 324a548:	1885883a 	add	r2,r3,r2
 324a54c:	e0bffc15 	stw	r2,-16(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 324a550:	e0bffe17 	ldw	r2,-8(fp)
 324a554:	e0bffd15 	stw	r2,-12(fp)
 324a558:	00000506 	br	324a570 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 324a55c:	e0bffd17 	ldw	r2,-12(fp)
 324a560:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 324a564:	e0bffd17 	ldw	r2,-12(fp)
 324a568:	10800804 	addi	r2,r2,32
 324a56c:	e0bffd15 	stw	r2,-12(fp)
 324a570:	e0fffd17 	ldw	r3,-12(fp)
 324a574:	e0bffc17 	ldw	r2,-16(fp)
 324a578:	18bff836 	bltu	r3,r2,324a55c <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 324a57c:	e0bffe17 	ldw	r2,-8(fp)
 324a580:	108007cc 	andi	r2,r2,31
 324a584:	1005003a 	cmpeq	r2,r2,zero
 324a588:	1000021e 	bne	r2,zero,324a594 <alt_icache_flush+0x7c>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 324a58c:	e0bffd17 	ldw	r2,-12(fp)
 324a590:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 324a594:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
 324a598:	e037883a 	mov	sp,fp
 324a59c:	df000017 	ldw	fp,0(sp)
 324a5a0:	dec00104 	addi	sp,sp,4
 324a5a4:	f800283a 	ret

0324a5a8 <icmprcv>:
};
#endif /* USER_PING_TSTAMP */

int
icmprcv(PACKET p)      /* the incoming packet */
{
 324a5a8:	deffed04 	addi	sp,sp,-76
 324a5ac:	dfc01215 	stw	ra,72(sp)
 324a5b0:	df001115 	stw	fp,68(sp)
 324a5b4:	dc401015 	stw	r17,64(sp)
 324a5b8:	dc000f15 	stw	r16,60(sp)
 324a5bc:	df000f04 	addi	fp,sp,60
 324a5c0:	e13ffd15 	stw	r4,-12(fp)
   unsigned short xsum;
#ifdef FULL_ICMP
   struct redirect * rd;
   struct destun *   pdp;
#endif   /* FULL_ICMP */
   char sav_ch = 0;
 324a5c4:	e03ff505 	stb	zero,-44(fp)
   int i;

   icmp_mib.icmpInMsgs++;                 /* received one more icmp */
 324a5c8:	0080c9b4 	movhi	r2,806
 324a5cc:	10b4be04 	addi	r2,r2,-11528
 324a5d0:	10800017 	ldw	r2,0(r2)
 324a5d4:	10c00044 	addi	r3,r2,1
 324a5d8:	0080c9b4 	movhi	r2,806
 324a5dc:	10b4be04 	addi	r2,r2,-11528
 324a5e0:	10c00015 	stw	r3,0(r2)

   pip = ip_head(p);                      /* find IP header */
 324a5e4:	e0bffd17 	ldw	r2,-12(fp)
 324a5e8:	10800317 	ldw	r2,12(r2)
 324a5ec:	e0bffa15 	stw	r2,-24(fp)
   len = p->nb_plen - (ip_hlen(pip));     /* strip IP header length */
 324a5f0:	e0bffd17 	ldw	r2,-12(fp)
 324a5f4:	10c00417 	ldw	r3,16(r2)
 324a5f8:	e0bffa17 	ldw	r2,-24(fp)
 324a5fc:	10800003 	ldbu	r2,0(r2)
 324a600:	10803fcc 	andi	r2,r2,255
 324a604:	108003cc 	andi	r2,r2,15
 324a608:	1085883a 	add	r2,r2,r2
 324a60c:	1085883a 	add	r2,r2,r2
 324a610:	1885c83a 	sub	r2,r3,r2
 324a614:	e0bffc15 	stw	r2,-16(fp)
   host = p->fhost;                       /* filled in by IP layer */
 324a618:	e0bffd17 	ldw	r2,-12(fp)
 324a61c:	10800717 	ldw	r2,28(r2)
 324a620:	e0bffb15 	stw	r2,-20(fp)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 324a624:	0080c974 	movhi	r2,805
 324a628:	10923104 	addi	r2,r2,18628
 324a62c:	10800017 	ldw	r2,0(r2)
 324a630:	1081000c 	andi	r2,r2,1024
 324a634:	1005003a 	cmpeq	r2,r2,zero
 324a638:	1000161e 	bne	r2,zero,324a694 <icmprcv+0xec>
 324a63c:	0080c974 	movhi	r2,805
 324a640:	10923104 	addi	r2,r2,18628
 324a644:	10800017 	ldw	r2,0(r2)
 324a648:	1080800c 	andi	r2,r2,512
 324a64c:	1005003a 	cmpeq	r2,r2,zero
 324a650:	1000101e 	bne	r2,zero,324a694 <icmprcv+0xec>
      dprintf("ICMP: p[%u] from %u.%u.%u.%u\n", len, PUSH_IPADDR(host));
 324a654:	e0bffb17 	ldw	r2,-20(fp)
 324a658:	11803fcc 	andi	r6,r2,255
 324a65c:	e0bffb17 	ldw	r2,-20(fp)
 324a660:	1004d23a 	srli	r2,r2,8
 324a664:	11c03fcc 	andi	r7,r2,255
 324a668:	e0bffb17 	ldw	r2,-20(fp)
 324a66c:	1004d43a 	srli	r2,r2,16
 324a670:	10c03fcc 	andi	r3,r2,255
 324a674:	e0bffb17 	ldw	r2,-20(fp)
 324a678:	1004d63a 	srli	r2,r2,24
 324a67c:	d8c00015 	stw	r3,0(sp)
 324a680:	d8800115 	stw	r2,4(sp)
 324a684:	0100c974 	movhi	r4,805
 324a688:	2100c404 	addi	r4,r4,784
 324a68c:	e17ffc17 	ldw	r5,-16(fp)
 324a690:	3206adc0 	call	3206adc <printf>
#endif

   e = (struct ping *)ip_data(pip);       /* finally, extract ICMP header */
 324a694:	e0bffa17 	ldw	r2,-24(fp)
 324a698:	10800003 	ldbu	r2,0(r2)
 324a69c:	10803fcc 	andi	r2,r2,255
 324a6a0:	108003cc 	andi	r2,r2,15
 324a6a4:	1085883a 	add	r2,r2,r2
 324a6a8:	1085883a 	add	r2,r2,r2
 324a6ac:	1007883a 	mov	r3,r2
 324a6b0:	e0bffa17 	ldw	r2,-24(fp)
 324a6b4:	1885883a 	add	r2,r3,r2
 324a6b8:	e0bff915 	stw	r2,-28(fp)

   osum = e->pchksum;
 324a6bc:	e0bff917 	ldw	r2,-28(fp)
 324a6c0:	1080008b 	ldhu	r2,2(r2)
 324a6c4:	e0bff88d 	sth	r2,-30(fp)
   e->pchksum = 0;
 324a6c8:	e0bff917 	ldw	r2,-28(fp)
 324a6cc:	1000008d 	sth	zero,2(r2)

   if (len&1)
 324a6d0:	e0bffc17 	ldw	r2,-16(fp)
 324a6d4:	1080004c 	andi	r2,r2,1
 324a6d8:	10803fcc 	andi	r2,r2,255
 324a6dc:	1005003a 	cmpeq	r2,r2,zero
 324a6e0:	1000091e 	bne	r2,zero,324a708 <icmprcv+0x160>
   {
      sav_ch = *(((char *) e) + len);
 324a6e4:	e0fff917 	ldw	r3,-28(fp)
 324a6e8:	e0bffc17 	ldw	r2,-16(fp)
 324a6ec:	1885883a 	add	r2,r3,r2
 324a6f0:	10800003 	ldbu	r2,0(r2)
 324a6f4:	e0bff505 	stb	r2,-44(fp)
      ((char *)e)[len] = 0;
 324a6f8:	e0fff917 	ldw	r3,-28(fp)
 324a6fc:	e0bffc17 	ldw	r2,-16(fp)
 324a700:	1885883a 	add	r2,r3,r2
 324a704:	10000005 	stb	zero,0(r2)
   }

   xsum = ~cksum(e, (len+1)>>1);
 324a708:	e0bffc17 	ldw	r2,-16(fp)
 324a70c:	10800044 	addi	r2,r2,1
 324a710:	100ad07a 	srli	r5,r2,1
 324a714:	e13ff917 	ldw	r4,-28(fp)
 324a718:	32259f80 	call	32259f8 <cksum>
 324a71c:	0084303a 	nor	r2,zero,r2
 324a720:	e0bff80d 	sth	r2,-32(fp)
   if (len&1) *(((char *) e) + len) = sav_ch;
 324a724:	e0bffc17 	ldw	r2,-16(fp)
 324a728:	1080004c 	andi	r2,r2,1
 324a72c:	10803fcc 	andi	r2,r2,255
 324a730:	1005003a 	cmpeq	r2,r2,zero
 324a734:	1000051e 	bne	r2,zero,324a74c <icmprcv+0x1a4>
 324a738:	e0fff917 	ldw	r3,-28(fp)
 324a73c:	e0bffc17 	ldw	r2,-16(fp)
 324a740:	1887883a 	add	r3,r3,r2
 324a744:	e0bff503 	ldbu	r2,-44(fp)
 324a748:	18800005 	stb	r2,0(r3)
   if (xsum != osum)
 324a74c:	e0fff80b 	ldhu	r3,-32(fp)
 324a750:	e0bff88b 	ldhu	r2,-30(fp)
 324a754:	18802c26 	beq	r3,r2,324a808 <icmprcv+0x260>
   {
      e->pchksum = osum;
 324a758:	e0fff917 	ldw	r3,-28(fp)
 324a75c:	e0bff88b 	ldhu	r2,-30(fp)
 324a760:	1880008d 	sth	r2,2(r3)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 324a764:	0080c974 	movhi	r2,805
 324a768:	10923104 	addi	r2,r2,18628
 324a76c:	10800017 	ldw	r2,0(r2)
 324a770:	1081000c 	andi	r2,r2,1024
 324a774:	1005003a 	cmpeq	r2,r2,zero
 324a778:	1000131e 	bne	r2,zero,324a7c8 <icmprcv+0x220>
 324a77c:	0080c974 	movhi	r2,805
 324a780:	10923104 	addi	r2,r2,18628
 324a784:	10800017 	ldw	r2,0(r2)
 324a788:	1080800c 	andi	r2,r2,512
 324a78c:	1005003a 	cmpeq	r2,r2,zero
 324a790:	10000d1e 	bne	r2,zero,324a7c8 <icmprcv+0x220>
      {
         dprintf("ICMP: Bad xsum %04x should have been %04x\n",
 324a794:	e17ff88b 	ldhu	r5,-30(fp)
 324a798:	e1bff80b 	ldhu	r6,-32(fp)
 324a79c:	0100c974 	movhi	r4,805
 324a7a0:	2100cc04 	addi	r4,r4,816
 324a7a4:	3206adc0 	call	3206adc <printf>
          osum, xsum);
         if (NDEBUG & DUMP) ip_dump(p);
 324a7a8:	0080c974 	movhi	r2,805
 324a7ac:	10923104 	addi	r2,r2,18628
 324a7b0:	10800017 	ldw	r2,0(r2)
 324a7b4:	1080008c 	andi	r2,r2,2
 324a7b8:	1005003a 	cmpeq	r2,r2,zero
 324a7bc:	1000021e 	bne	r2,zero,324a7c8 <icmprcv+0x220>
 324a7c0:	e13ffd17 	ldw	r4,-12(fp)
 324a7c4:	32402380 	call	3240238 <ip_dump>
      }
#endif
      icmp_mib.icmpInErrors++;
 324a7c8:	0080c9b4 	movhi	r2,806
 324a7cc:	10b4be04 	addi	r2,r2,-11528
 324a7d0:	10800117 	ldw	r2,4(r2)
 324a7d4:	10c00044 	addi	r3,r2,1
 324a7d8:	0080c9b4 	movhi	r2,806
 324a7dc:	10b4be04 	addi	r2,r2,-11528
 324a7e0:	10c00115 	stw	r3,4(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 324a7e4:	01000084 	movi	r4,2
 324a7e8:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(p);
 324a7ec:	e13ffd17 	ldw	r4,-12(fp)
 324a7f0:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324a7f4:	01000084 	movi	r4,2
 324a7f8:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 324a7fc:	00bff804 	movi	r2,-32
 324a800:	e0bfff15 	stw	r2,-4(fp)
 324a804:	00026d06 	br	324b1bc <icmprcv+0xc14>
   }

   e->pchksum = osum;
 324a808:	e0fff917 	ldw	r3,-28(fp)
 324a80c:	e0bff88b 	ldhu	r2,-30(fp)
 324a810:	1880008d 	sth	r2,2(r3)

   switch (e->ptype) 
 324a814:	e0bff917 	ldw	r2,-28(fp)
 324a818:	10800003 	ldbu	r2,0(r2)
 324a81c:	10803fcc 	andi	r2,r2,255
 324a820:	1080201c 	xori	r2,r2,128
 324a824:	10bfe004 	addi	r2,r2,-128
 324a828:	e0bffe15 	stw	r2,-8(fp)
 324a82c:	e0fffe17 	ldw	r3,-8(fp)
 324a830:	18800428 	cmpgeui	r2,r3,16
 324a834:	1002401e 	bne	r2,zero,324b138 <icmprcv+0xb90>
 324a838:	e13ffe17 	ldw	r4,-8(fp)
 324a83c:	e13ffe17 	ldw	r4,-8(fp)
 324a840:	2105883a 	add	r2,r4,r4
 324a844:	1087883a 	add	r3,r2,r2
 324a848:	0080c974 	movhi	r2,805
 324a84c:	10aa1704 	addi	r2,r2,-22436
 324a850:	1885883a 	add	r2,r3,r2
 324a854:	10800017 	ldw	r2,0(r2)
 324a858:	1000683a 	jmp	r2
 324a85c:	0324ab40 	call	324ab4 <OSCtxSw_SWITCH_PC+0x324a74>
 324a860:	0324b138 	rdprs	r12,zero,-27964
 324a864:	0324b138 	rdprs	r12,zero,-27964
 324a868:	0324ab6c 	andhi	r12,zero,37549
 324a86c:	0324ac5c 	xori	r12,zero,37553
 324a870:	0324ad04 	movi	r12,-27980
 324a874:	0324b138 	rdprs	r12,zero,-27964
 324a878:	0324b138 	rdprs	r12,zero,-27964
 324a87c:	0324a89c 	xori	r12,zero,37538
 324a880:	0324b138 	rdprs	r12,zero,-27964
 324a884:	0324b138 	rdprs	r12,zero,-27964
 324a888:	0324ae24 	muli	r12,zero,-27976
 324a88c:	0324af2c 	andhi	r12,zero,37564
 324a890:	0324afa8 	cmpgeui	r12,zero,37566
 324a894:	0324b138 	rdprs	r12,zero,-27964
 324a898:	0324b0f8 	rdprs	r12,zero,-27965
   {
   case ECHOREQ:  /* got ping request, send reply */
      icmp_mib.icmpInEchos++;
 324a89c:	0080c9b4 	movhi	r2,806
 324a8a0:	10b4be04 	addi	r2,r2,-11528
 324a8a4:	10800717 	ldw	r2,28(r2)
 324a8a8:	10c00044 	addi	r3,r2,1
 324a8ac:	0080c9b4 	movhi	r2,806
 324a8b0:	10b4be04 	addi	r2,r2,-11528
 324a8b4:	10c00715 	stw	r3,28(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 324a8b8:	0080c974 	movhi	r2,805
 324a8bc:	10923104 	addi	r2,r2,18628
 324a8c0:	10800017 	ldw	r2,0(r2)
 324a8c4:	1081000c 	andi	r2,r2,1024
 324a8c8:	1005003a 	cmpeq	r2,r2,zero
 324a8cc:	1000141e 	bne	r2,zero,324a920 <icmprcv+0x378>
 324a8d0:	0080c974 	movhi	r2,805
 324a8d4:	10923104 	addi	r2,r2,18628
 324a8d8:	10800017 	ldw	r2,0(r2)
 324a8dc:	1080800c 	andi	r2,r2,512
 324a8e0:	1005003a 	cmpeq	r2,r2,zero
 324a8e4:	10000e1e 	bne	r2,zero,324a920 <icmprcv+0x378>
         dprintf("ICMP: echo reply to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 324a8e8:	e0bffb17 	ldw	r2,-20(fp)
 324a8ec:	11403fcc 	andi	r5,r2,255
 324a8f0:	e0bffb17 	ldw	r2,-20(fp)
 324a8f4:	1004d23a 	srli	r2,r2,8
 324a8f8:	11803fcc 	andi	r6,r2,255
 324a8fc:	e0bffb17 	ldw	r2,-20(fp)
 324a900:	1004d43a 	srli	r2,r2,16
 324a904:	11c03fcc 	andi	r7,r2,255
 324a908:	e0bffb17 	ldw	r2,-20(fp)
 324a90c:	1004d63a 	srli	r2,r2,24
 324a910:	d8800015 	stw	r2,0(sp)
 324a914:	0100c974 	movhi	r4,805
 324a918:	2100d704 	addi	r4,r4,860
 324a91c:	3206adc0 	call	3206adc <printf>
#endif
      e->ptype = ECHOREP;
 324a920:	e0bff917 	ldw	r2,-28(fp)
 324a924:	10000005 	stb	zero,0(r2)
      e->pchksum = 0;
 324a928:	e0bff917 	ldw	r2,-28(fp)
 324a92c:	1000008d 	sth	zero,2(r2)
      if (len&1)  /* pad odd length packets for checksum routine */
 324a930:	e0bffc17 	ldw	r2,-16(fp)
 324a934:	1080004c 	andi	r2,r2,1
 324a938:	10803fcc 	andi	r2,r2,255
 324a93c:	1005003a 	cmpeq	r2,r2,zero
 324a940:	1000091e 	bne	r2,zero,324a968 <icmprcv+0x3c0>
      {
         sav_ch = *(((char *) e) + len);
 324a944:	e0fff917 	ldw	r3,-28(fp)
 324a948:	e0bffc17 	ldw	r2,-16(fp)
 324a94c:	1885883a 	add	r2,r3,r2
 324a950:	10800003 	ldbu	r2,0(r2)
 324a954:	e0bff505 	stb	r2,-44(fp)
         ((char *)e)[len] = 0;
 324a958:	e0fff917 	ldw	r3,-28(fp)
 324a95c:	e0bffc17 	ldw	r2,-16(fp)
 324a960:	1885883a 	add	r2,r3,r2
 324a964:	10000005 	stb	zero,0(r2)
      }

      e->pchksum = ~cksum(e, (len+1)>>1);
 324a968:	e0bffc17 	ldw	r2,-16(fp)
 324a96c:	10800044 	addi	r2,r2,1
 324a970:	100ad07a 	srli	r5,r2,1
 324a974:	e13ff917 	ldw	r4,-28(fp)
 324a978:	32259f80 	call	32259f8 <cksum>
 324a97c:	0084303a 	nor	r2,zero,r2
 324a980:	1007883a 	mov	r3,r2
 324a984:	e0bff917 	ldw	r2,-28(fp)
 324a988:	10c0008d 	sth	r3,2(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
 324a98c:	e0bffc17 	ldw	r2,-16(fp)
 324a990:	1080004c 	andi	r2,r2,1
 324a994:	10803fcc 	andi	r2,r2,255
 324a998:	1005003a 	cmpeq	r2,r2,zero
 324a99c:	1000051e 	bne	r2,zero,324a9b4 <icmprcv+0x40c>
 324a9a0:	e0fff917 	ldw	r3,-28(fp)
 324a9a4:	e0bffc17 	ldw	r2,-16(fp)
 324a9a8:	1887883a 	add	r3,r3,r2
 324a9ac:	e0bff503 	ldbu	r2,-44(fp)
 324a9b0:	18800005 	stb	r2,0(r3)
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 324a9b4:	e0bffa17 	ldw	r2,-24(fp)
 324a9b8:	10800417 	ldw	r2,16(r2)
 324a9bc:	10bfffe0 	cmpeqi	r2,r2,-1
 324a9c0:	1000211e 	bne	r2,zero,324aa48 <icmprcv+0x4a0>
 324a9c4:	e0bffa17 	ldw	r2,-24(fp)
 324a9c8:	10800417 	ldw	r2,16(r2)
 324a9cc:	1004d63a 	srli	r2,r2,24
 324a9d0:	10c03fcc 	andi	r3,r2,255
 324a9d4:	e0bffa17 	ldw	r2,-24(fp)
 324a9d8:	10800417 	ldw	r2,16(r2)
 324a9dc:	1004d23a 	srli	r2,r2,8
 324a9e0:	10bfc00c 	andi	r2,r2,65280
 324a9e4:	1886b03a 	or	r3,r3,r2
 324a9e8:	e0bffa17 	ldw	r2,-24(fp)
 324a9ec:	10800417 	ldw	r2,16(r2)
 324a9f0:	10bfc00c 	andi	r2,r2,65280
 324a9f4:	1004923a 	slli	r2,r2,8
 324a9f8:	1886b03a 	or	r3,r3,r2
 324a9fc:	e0bffa17 	ldw	r2,-24(fp)
 324aa00:	10800417 	ldw	r2,16(r2)
 324aa04:	10803fcc 	andi	r2,r2,255
 324aa08:	1004963a 	slli	r2,r2,24
 324aa0c:	1884b03a 	or	r2,r3,r2
 324aa10:	10fc002c 	andhi	r3,r2,61440
 324aa14:	00b80034 	movhi	r2,57344
 324aa18:	18800b26 	beq	r3,r2,324aa48 <icmprcv+0x4a0>
 324aa1c:	e0bffa17 	ldw	r2,-24(fp)
 324aa20:	11000417 	ldw	r4,16(r2)
 324aa24:	e0bffd17 	ldw	r2,-12(fp)
 324aa28:	10800617 	ldw	r2,24(r2)
 324aa2c:	10c00a17 	ldw	r3,40(r2)
 324aa30:	e0bffd17 	ldw	r2,-12(fp)
 324aa34:	10800617 	ldw	r2,24(r2)
 324aa38:	10800c17 	ldw	r2,48(r2)
 324aa3c:	0084303a 	nor	r2,zero,r2
 324aa40:	1884b03a 	or	r2,r3,r2
 324aa44:	2080061e 	bne	r4,r2,324aa60 <icmprcv+0x4b8>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
 324aa48:	e0bffd17 	ldw	r2,-12(fp)
 324aa4c:	10800617 	ldw	r2,24(r2)
 324aa50:	10c00a17 	ldw	r3,40(r2)
 324aa54:	e0bffa17 	ldw	r2,-24(fp)
 324aa58:	10c00315 	stw	r3,12(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 324aa5c:	00000406 	br	324aa70 <icmprcv+0x4c8>
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
      }
      else pip->ip_src = pip->ip_dest;
 324aa60:	e0bffa17 	ldw	r2,-24(fp)
 324aa64:	10c00417 	ldw	r3,16(r2)
 324aa68:	e0bffa17 	ldw	r2,-24(fp)
 324aa6c:	10c00315 	stw	r3,12(r2)

      pip->ip_dest = host;
 324aa70:	e0fffa17 	ldw	r3,-24(fp)
 324aa74:	e0bffb17 	ldw	r2,-20(fp)
 324aa78:	18800415 	stw	r2,16(r3)
      icmp_mib.icmpOutEchoReps++;
 324aa7c:	0080c9b4 	movhi	r2,806
 324aa80:	10b4be04 	addi	r2,r2,-11528
 324aa84:	10801517 	ldw	r2,84(r2)
 324aa88:	10c00044 	addi	r3,r2,1
 324aa8c:	0080c9b4 	movhi	r2,806
 324aa90:	10b4be04 	addi	r2,r2,-11528
 324aa94:	10c01515 	stw	r3,84(r2)
      icmp_mib.icmpOutMsgs++;
 324aa98:	0080c9b4 	movhi	r2,806
 324aa9c:	10b4be04 	addi	r2,r2,-11528
 324aaa0:	10800d17 	ldw	r2,52(r2)
 324aaa4:	10c00044 	addi	r3,r2,1
 324aaa8:	0080c9b4 	movhi	r2,806
 324aaac:	10b4be04 	addi	r2,r2,-11528
 324aab0:	10c00d15 	stw	r3,52(r2)
      p->fhost = host;
 324aab4:	e0fffd17 	ldw	r3,-12(fp)
 324aab8:	e0bffb17 	ldw	r2,-20(fp)
 324aabc:	18800715 	stw	r2,28(r3)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 324aac0:	e0bffd17 	ldw	r2,-12(fp)
 324aac4:	10c00317 	ldw	r3,12(r2)
 324aac8:	e0bffa17 	ldw	r2,-24(fp)
 324aacc:	10800003 	ldbu	r2,0(r2)
 324aad0:	10803fcc 	andi	r2,r2,255
 324aad4:	108003cc 	andi	r2,r2,15
 324aad8:	1085883a 	add	r2,r2,r2
 324aadc:	1085883a 	add	r2,r2,r2
 324aae0:	1887883a 	add	r3,r3,r2
 324aae4:	e0bffd17 	ldw	r2,-12(fp)
 324aae8:	10c00315 	stw	r3,12(r2)
      p->nb_plen = len;
 324aaec:	e0fffd17 	ldw	r3,-12(fp)
 324aaf0:	e0bffc17 	ldw	r2,-16(fp)
 324aaf4:	18800415 	stw	r2,16(r3)

      i = ip_write(ICMP_PROT, p);
 324aaf8:	01000044 	movi	r4,1
 324aafc:	e17ffd17 	ldw	r5,-12(fp)
 324ab00:	323f0100 	call	323f010 <ip_write>
 324ab04:	e0bff415 	stw	r2,-48(fp)
      if (i < 0)
 324ab08:	e0bff417 	ldw	r2,-48(fp)
 324ab0c:	1004403a 	cmpge	r2,r2,zero
 324ab10:	1000091e 	bne	r2,zero,324ab38 <icmprcv+0x590>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (UPCTRACE))
 324ab14:	0080c974 	movhi	r2,805
 324ab18:	10923104 	addi	r2,r2,18628
 324ab1c:	10800017 	ldw	r2,0(r2)
 324ab20:	1081000c 	andi	r2,r2,1024
 324ab24:	1005003a 	cmpeq	r2,r2,zero
 324ab28:	1000031e 	bne	r2,zero,324ab38 <icmprcv+0x590>
            dprintf("icmp: reply failed\n");
 324ab2c:	0100c974 	movhi	r4,805
 324ab30:	2100e004 	addi	r4,r4,896
 324ab34:	3206e040 	call	3206e04 <puts>
#endif
      }
      /* reused p will be freed by net->xxx_send() */
      return 0;
 324ab38:	e03fff15 	stw	zero,-4(fp)
 324ab3c:	00019f06 	br	324b1bc <icmprcv+0xc14>
   case ECHOREP:
      icmp_mib.icmpInEchoReps++;
 324ab40:	0080c9b4 	movhi	r2,806
 324ab44:	10b4be04 	addi	r2,r2,-11528
 324ab48:	10800817 	ldw	r2,32(r2)
 324ab4c:	10c00044 	addi	r3,r2,1
 324ab50:	0080c9b4 	movhi	r2,806
 324ab54:	10b4be04 	addi	r2,r2,-11528
 324ab58:	10c00815 	stw	r3,32(r2)
      
/* 
 * Altera Niche Stack Nios port modification
 */
#if defined(ALT_INICHE) && !defined(PING_APP) && defined(IP_RAW)
      return(ip_raw_input(p));
 324ab5c:	e13ffd17 	ldw	r4,-12(fp)
 324ab60:	32439f00 	call	32439f0 <ip_raw_input>
 324ab64:	e0bfff15 	stw	r2,-4(fp)
 324ab68:	00019406 	br	324b1bc <icmprcv+0xc14>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
      return(0);
#endif   /* PING_APP */
#ifdef FULL_ICMP
   case DESTIN:
      icmp_mib.icmpInDestUnreachs++;
 324ab6c:	0080c9b4 	movhi	r2,806
 324ab70:	10b4be04 	addi	r2,r2,-11528
 324ab74:	10800217 	ldw	r2,8(r2)
 324ab78:	10c00044 	addi	r3,r2,1
 324ab7c:	0080c9b4 	movhi	r2,806
 324ab80:	10b4be04 	addi	r2,r2,-11528
 324ab84:	10c00215 	stw	r3,8(r2)
      pdp = (struct destun *)e;
 324ab88:	e0bff917 	ldw	r2,-28(fp)
 324ab8c:	e0bff615 	stw	r2,-40(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 324ab90:	0080c974 	movhi	r2,805
 324ab94:	10923104 	addi	r2,r2,18628
 324ab98:	10800017 	ldw	r2,0(r2)
 324ab9c:	1081000c 	andi	r2,r2,1024
 324aba0:	1005003a 	cmpeq	r2,r2,zero
 324aba4:	1000291e 	bne	r2,zero,324ac4c <icmprcv+0x6a4>
      {
         dprintf("ICMP: got dest unreachable type ");
 324aba8:	0100c974 	movhi	r4,805
 324abac:	2100e504 	addi	r4,r4,916
 324abb0:	3206adc0 	call	3206adc <printf>
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 324abb4:	e0bff617 	ldw	r2,-40(fp)
 324abb8:	10800043 	ldbu	r2,1(r2)
 324abbc:	11403fcc 	andi	r5,r2,255
 324abc0:	2940201c 	xori	r5,r5,128
 324abc4:	297fe004 	addi	r5,r5,-128
 324abc8:	e0bff617 	ldw	r2,-40(fp)
 324abcc:	10800617 	ldw	r2,24(r2)
 324abd0:	11803fcc 	andi	r6,r2,255
 324abd4:	e0bff617 	ldw	r2,-40(fp)
 324abd8:	10800617 	ldw	r2,24(r2)
 324abdc:	1004d23a 	srli	r2,r2,8
 324abe0:	11c03fcc 	andi	r7,r2,255
 324abe4:	e0bff617 	ldw	r2,-40(fp)
 324abe8:	10800617 	ldw	r2,24(r2)
 324abec:	1004d43a 	srli	r2,r2,16
 324abf0:	10c03fcc 	andi	r3,r2,255
 324abf4:	e0bff617 	ldw	r2,-40(fp)
 324abf8:	10800617 	ldw	r2,24(r2)
 324abfc:	1004d63a 	srli	r2,r2,24
 324ac00:	d8c00015 	stw	r3,0(sp)
 324ac04:	d8800115 	stw	r2,4(sp)
 324ac08:	0100c974 	movhi	r4,805
 324ac0c:	2100ee04 	addi	r4,r4,952
 324ac10:	3206adc0 	call	3206adc <printf>
          PUSH_IPADDR(pdp->dip.ip_dest));
         dprintf("from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 324ac14:	e0bffb17 	ldw	r2,-20(fp)
 324ac18:	11403fcc 	andi	r5,r2,255
 324ac1c:	e0bffb17 	ldw	r2,-20(fp)
 324ac20:	1004d23a 	srli	r2,r2,8
 324ac24:	11803fcc 	andi	r6,r2,255
 324ac28:	e0bffb17 	ldw	r2,-20(fp)
 324ac2c:	1004d43a 	srli	r2,r2,16
 324ac30:	11c03fcc 	andi	r7,r2,255
 324ac34:	e0bffb17 	ldw	r2,-20(fp)
 324ac38:	1004d63a 	srli	r2,r2,24
 324ac3c:	d8800015 	stw	r2,0(sp)
 324ac40:	0100c974 	movhi	r4,805
 324ac44:	2100f304 	addi	r4,r4,972
 324ac48:	3206adc0 	call	3206adc <printf>
      }
#endif   /* NPDEBUG */
      icmp_du(p, pdp);
 324ac4c:	e13ffd17 	ldw	r4,-12(fp)
 324ac50:	e17ff617 	ldw	r5,-40(fp)
 324ac54:	324b8600 	call	324b860 <icmp_du>
      break;
 324ac58:	00015606 	br	324b1b4 <icmprcv+0xc0c>
   case SOURCEQ:
      icmp_mib.icmpInSrcQuenchs++;
 324ac5c:	0080c9b4 	movhi	r2,806
 324ac60:	10b4be04 	addi	r2,r2,-11528
 324ac64:	10800517 	ldw	r2,20(r2)
 324ac68:	10c00044 	addi	r3,r2,1
 324ac6c:	0080c9b4 	movhi	r2,806
 324ac70:	10b4be04 	addi	r2,r2,-11528
 324ac74:	10c00515 	stw	r3,20(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 324ac78:	0080c974 	movhi	r2,805
 324ac7c:	10923104 	addi	r2,r2,18628
 324ac80:	10800017 	ldw	r2,0(r2)
 324ac84:	1081000c 	andi	r2,r2,1024
 324ac88:	1005003a 	cmpeq	r2,r2,zero
 324ac8c:	1000161e 	bne	r2,zero,324ace8 <icmprcv+0x740>
      {
         dprintf("ICMP: source quench from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 324ac90:	e0bffb17 	ldw	r2,-20(fp)
 324ac94:	11403fcc 	andi	r5,r2,255
 324ac98:	e0bffb17 	ldw	r2,-20(fp)
 324ac9c:	1004d23a 	srli	r2,r2,8
 324aca0:	11803fcc 	andi	r6,r2,255
 324aca4:	e0bffb17 	ldw	r2,-20(fp)
 324aca8:	1004d43a 	srli	r2,r2,16
 324acac:	11c03fcc 	andi	r7,r2,255
 324acb0:	e0bffb17 	ldw	r2,-20(fp)
 324acb4:	1004d63a 	srli	r2,r2,24
 324acb8:	d8800015 	stw	r2,0(sp)
 324acbc:	0100c974 	movhi	r4,805
 324acc0:	2100f804 	addi	r4,r4,992
 324acc4:	3206adc0 	call	3206adc <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 324acc8:	0080c974 	movhi	r2,805
 324accc:	10923104 	addi	r2,r2,18628
 324acd0:	10800017 	ldw	r2,0(r2)
 324acd4:	1080008c 	andi	r2,r2,2
 324acd8:	1005003a 	cmpeq	r2,r2,zero
 324acdc:	1000021e 	bne	r2,zero,324ace8 <icmprcv+0x740>
 324ace0:	e13ffd17 	ldw	r4,-12(fp)
 324ace4:	32402380 	call	3240238 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 324ace8:	01000084 	movi	r4,2
 324acec:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(p);
 324acf0:	e13ffd17 	ldw	r4,-12(fp)
 324acf4:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324acf8:	01000084 	movi	r4,2
 324acfc:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      break;
 324ad00:	00012c06 	br	324b1b4 <icmprcv+0xc0c>
   case REDIR:          /* got an icmp redirect */
      icmp_mib.icmpInRedirects++;
 324ad04:	0080c9b4 	movhi	r2,806
 324ad08:	10b4be04 	addi	r2,r2,-11528
 324ad0c:	10800617 	ldw	r2,24(r2)
 324ad10:	10c00044 	addi	r3,r2,1
 324ad14:	0080c9b4 	movhi	r2,806
 324ad18:	10b4be04 	addi	r2,r2,-11528
 324ad1c:	10c00615 	stw	r3,24(r2)
      rd = (struct redirect *)e;
 324ad20:	e0bff917 	ldw	r2,-28(fp)
 324ad24:	e0bff715 	stw	r2,-36(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 324ad28:	0080c974 	movhi	r2,805
 324ad2c:	10923104 	addi	r2,r2,18628
 324ad30:	10800017 	ldw	r2,0(r2)
 324ad34:	1081000c 	andi	r2,r2,1024
 324ad38:	1005003a 	cmpeq	r2,r2,zero
 324ad3c:	1000241e 	bne	r2,zero,324add0 <icmprcv+0x828>
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 324ad40:	e0bff717 	ldw	r2,-36(fp)
 324ad44:	10800617 	ldw	r2,24(r2)
 324ad48:	11403fcc 	andi	r5,r2,255
 324ad4c:	e0bff717 	ldw	r2,-36(fp)
 324ad50:	10800617 	ldw	r2,24(r2)
 324ad54:	1004d23a 	srli	r2,r2,8
 324ad58:	11803fcc 	andi	r6,r2,255
 324ad5c:	e0bff717 	ldw	r2,-36(fp)
 324ad60:	10800617 	ldw	r2,24(r2)
 324ad64:	1004d43a 	srli	r2,r2,16
 324ad68:	11c03fcc 	andi	r7,r2,255
 324ad6c:	e0bff717 	ldw	r2,-36(fp)
 324ad70:	10800617 	ldw	r2,24(r2)
 324ad74:	1004d63a 	srli	r2,r2,24
 324ad78:	d8800015 	stw	r2,0(sp)
 324ad7c:	0100c974 	movhi	r4,805
 324ad80:	21010204 	addi	r4,r4,1032
 324ad84:	3206adc0 	call	3206adc <printf>
          PUSH_IPADDR(rd->rdip.ip_dest));
         dprintf("to %u.%u.%u.%u\n", PUSH_IPADDR(rd->rdgw));
 324ad88:	e0bff717 	ldw	r2,-36(fp)
 324ad8c:	10800117 	ldw	r2,4(r2)
 324ad90:	11403fcc 	andi	r5,r2,255
 324ad94:	e0bff717 	ldw	r2,-36(fp)
 324ad98:	10800117 	ldw	r2,4(r2)
 324ad9c:	1004d23a 	srli	r2,r2,8
 324ada0:	11803fcc 	andi	r6,r2,255
 324ada4:	e0bff717 	ldw	r2,-36(fp)
 324ada8:	10800117 	ldw	r2,4(r2)
 324adac:	1004d43a 	srli	r2,r2,16
 324adb0:	11c03fcc 	andi	r7,r2,255
 324adb4:	e0bff717 	ldw	r2,-36(fp)
 324adb8:	10800117 	ldw	r2,4(r2)
 324adbc:	1004d63a 	srli	r2,r2,24
 324adc0:	d8800015 	stw	r2,0(sp)
 324adc4:	0100c974 	movhi	r4,805
 324adc8:	21010c04 	addi	r4,r4,1072
 324adcc:	3206adc0 	call	3206adc <printf>
      }
#endif   /* NPDEBUG */
#ifdef IP_ROUTING
      /* try to add/update route table */
      add_route(rd->rdip.ip_dest, 0xFFFFFFFF, rd->rdgw, 
 324add0:	e0bff717 	ldw	r2,-36(fp)
 324add4:	14000617 	ldw	r16,24(r2)
 324add8:	e0bff717 	ldw	r2,-36(fp)
 324addc:	14400117 	ldw	r17,4(r2)
 324ade0:	e0bffd17 	ldw	r2,-12(fp)
 324ade4:	11000617 	ldw	r4,24(r2)
 324ade8:	3223d580 	call	3223d58 <if_netnumber>
 324adec:	100f883a 	mov	r7,r2
 324adf0:	00800104 	movi	r2,4
 324adf4:	d8800015 	stw	r2,0(sp)
 324adf8:	8009883a 	mov	r4,r16
 324adfc:	017fffc4 	movi	r5,-1
 324ae00:	880d883a 	mov	r6,r17
 324ae04:	3243f140 	call	3243f14 <add_route>
       net_num(p->net), IPRP_ICMP);
#endif   /* IP_ROUTING */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 324ae08:	01000084 	movi	r4,2
 324ae0c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(p);
 324ae10:	e13ffd17 	ldw	r4,-12(fp)
 324ae14:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324ae18:	01000084 	movi	r4,2
 324ae1c:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      break;
 324ae20:	0000e406 	br	324b1b4 <icmprcv+0xc0c>
   case TIMEX:
      icmp_mib.icmpInTimeExcds++;
 324ae24:	0080c9b4 	movhi	r2,806
 324ae28:	10b4be04 	addi	r2,r2,-11528
 324ae2c:	10800317 	ldw	r2,12(r2)
 324ae30:	10c00044 	addi	r3,r2,1
 324ae34:	0080c9b4 	movhi	r2,806
 324ae38:	10b4be04 	addi	r2,r2,-11528
 324ae3c:	10c00315 	stw	r3,12(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 324ae40:	0080c974 	movhi	r2,805
 324ae44:	10923104 	addi	r2,r2,18628
 324ae48:	10800017 	ldw	r2,0(r2)
 324ae4c:	1081000c 	andi	r2,r2,1024
 324ae50:	1005003a 	cmpeq	r2,r2,zero
 324ae54:	10002e1e 	bne	r2,zero,324af10 <icmprcv+0x968>
      {
         struct timex * pt =  (struct  timex *)e;
 324ae58:	e0bff917 	ldw	r2,-28(fp)
 324ae5c:	e0bff315 	stw	r2,-52(fp)

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 324ae60:	e0bffd17 	ldw	r2,-12(fp)
 324ae64:	10800717 	ldw	r2,28(r2)
 324ae68:	11403fcc 	andi	r5,r2,255
 324ae6c:	e0bffd17 	ldw	r2,-12(fp)
 324ae70:	10800717 	ldw	r2,28(r2)
 324ae74:	1004d23a 	srli	r2,r2,8
 324ae78:	11803fcc 	andi	r6,r2,255
 324ae7c:	e0bffd17 	ldw	r2,-12(fp)
 324ae80:	10800717 	ldw	r2,28(r2)
 324ae84:	1004d43a 	srli	r2,r2,16
 324ae88:	11c03fcc 	andi	r7,r2,255
 324ae8c:	e0bffd17 	ldw	r2,-12(fp)
 324ae90:	10800717 	ldw	r2,28(r2)
 324ae94:	1004d63a 	srli	r2,r2,24
 324ae98:	d8800015 	stw	r2,0(sp)
 324ae9c:	0100c974 	movhi	r4,805
 324aea0:	21011004 	addi	r4,r4,1088
 324aea4:	3206adc0 	call	3206adc <printf>
          PUSH_IPADDR(p->fhost));
         dprintf(" about %u.%u.%u.%u\n", PUSH_IPADDR(pt->tip.ip_dest));
 324aea8:	e0bff317 	ldw	r2,-52(fp)
 324aeac:	10800617 	ldw	r2,24(r2)
 324aeb0:	11403fcc 	andi	r5,r2,255
 324aeb4:	e0bff317 	ldw	r2,-52(fp)
 324aeb8:	10800617 	ldw	r2,24(r2)
 324aebc:	1004d23a 	srli	r2,r2,8
 324aec0:	11803fcc 	andi	r6,r2,255
 324aec4:	e0bff317 	ldw	r2,-52(fp)
 324aec8:	10800617 	ldw	r2,24(r2)
 324aecc:	1004d43a 	srli	r2,r2,16
 324aed0:	11c03fcc 	andi	r7,r2,255
 324aed4:	e0bff317 	ldw	r2,-52(fp)
 324aed8:	10800617 	ldw	r2,24(r2)
 324aedc:	1004d63a 	srli	r2,r2,24
 324aee0:	d8800015 	stw	r2,0(sp)
 324aee4:	0100c974 	movhi	r4,805
 324aee8:	21011904 	addi	r4,r4,1124
 324aeec:	3206adc0 	call	3206adc <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 324aef0:	0080c974 	movhi	r2,805
 324aef4:	10923104 	addi	r2,r2,18628
 324aef8:	10800017 	ldw	r2,0(r2)
 324aefc:	1080008c 	andi	r2,r2,2
 324af00:	1005003a 	cmpeq	r2,r2,zero
 324af04:	1000021e 	bne	r2,zero,324af10 <icmprcv+0x968>
 324af08:	e13ffd17 	ldw	r4,-12(fp)
 324af0c:	32402380 	call	3240238 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 324af10:	01000084 	movi	r4,2
 324af14:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(p);
 324af18:	e13ffd17 	ldw	r4,-12(fp)
 324af1c:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324af20:	01000084 	movi	r4,2
 324af24:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      break;
 324af28:	0000a206 	br	324b1b4 <icmprcv+0xc0c>
   case PARAM:
      icmp_mib.icmpInParmProbs++;
 324af2c:	0080c9b4 	movhi	r2,806
 324af30:	10b4be04 	addi	r2,r2,-11528
 324af34:	10800417 	ldw	r2,16(r2)
 324af38:	10c00044 	addi	r3,r2,1
 324af3c:	0080c9b4 	movhi	r2,806
 324af40:	10b4be04 	addi	r2,r2,-11528
 324af44:	10c00415 	stw	r3,16(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 324af48:	0080c974 	movhi	r2,805
 324af4c:	10923104 	addi	r2,r2,18628
 324af50:	10800017 	ldw	r2,0(r2)
 324af54:	1081000c 	andi	r2,r2,1024
 324af58:	1005003a 	cmpeq	r2,r2,zero
 324af5c:	1000031e 	bne	r2,zero,324af6c <icmprcv+0x9c4>
         dprintf("ICMP: got param problem message\n");
 324af60:	0100c974 	movhi	r4,805
 324af64:	21011e04 	addi	r4,r4,1144
 324af68:	3206e040 	call	3206e04 <puts>
      if (NDEBUG & DUMP)
 324af6c:	0080c974 	movhi	r2,805
 324af70:	10923104 	addi	r2,r2,18628
 324af74:	10800017 	ldw	r2,0(r2)
 324af78:	1080008c 	andi	r2,r2,2
 324af7c:	1005003a 	cmpeq	r2,r2,zero
 324af80:	1000021e 	bne	r2,zero,324af8c <icmprcv+0x9e4>
      {
         ip_dump(p);
 324af84:	e13ffd17 	ldw	r4,-12(fp)
 324af88:	32402380 	call	3240238 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 324af8c:	01000084 	movi	r4,2
 324af90:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(p);
 324af94:	e13ffd17 	ldw	r4,-12(fp)
 324af98:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324af9c:	01000084 	movi	r4,2
 324afa0:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      break;
 324afa4:	00008306 	br	324b1b4 <icmprcv+0xc0c>
   case TIMEREQ:
      icmp_mib.icmpInTimestamps++;
 324afa8:	0080c9b4 	movhi	r2,806
 324afac:	10b4be04 	addi	r2,r2,-11528
 324afb0:	10800917 	ldw	r2,36(r2)
 324afb4:	10c00044 	addi	r3,r2,1
 324afb8:	0080c9b4 	movhi	r2,806
 324afbc:	10b4be04 	addi	r2,r2,-11528
 324afc0:	10c00915 	stw	r3,36(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 324afc4:	0080c974 	movhi	r2,805
 324afc8:	10923104 	addi	r2,r2,18628
 324afcc:	10800017 	ldw	r2,0(r2)
 324afd0:	1081000c 	andi	r2,r2,1024
 324afd4:	1005003a 	cmpeq	r2,r2,zero
 324afd8:	1000031e 	bne	r2,zero,324afe8 <icmprcv+0xa40>
         dprintf("ICMP: got timestamp request\n");
 324afdc:	0100c974 	movhi	r4,805
 324afe0:	21012604 	addi	r4,r4,1176
 324afe4:	3206e040 	call	3206e04 <puts>
#endif   /* NPDEBUG */
      e->ptype = TIMEREP;
 324afe8:	e0fff917 	ldw	r3,-28(fp)
 324afec:	00800384 	movi	r2,14
 324aff0:	18800005 	stb	r2,0(r3)
      e->pchksum = 0;
 324aff4:	e0bff917 	ldw	r2,-28(fp)
 324aff8:	1000008d 	sth	zero,2(r2)
		   */
		  sstmp->dtstamp[1] = sstmp->dtstamp[2] = user_UTCtime();
	  }
#endif /* USER_PING_TSTAMP */

      e->pchksum = ~cksum(e, sizeof(struct tstamp)>>1);
 324affc:	e13ff917 	ldw	r4,-28(fp)
 324b000:	01400284 	movi	r5,10
 324b004:	32259f80 	call	32259f8 <cksum>
 324b008:	0084303a 	nor	r2,zero,r2
 324b00c:	1007883a 	mov	r3,r2
 324b010:	e0bff917 	ldw	r2,-28(fp)
 324b014:	10c0008d 	sth	r3,2(r2)
      pip->ip_src = pip->ip_dest;
 324b018:	e0bffa17 	ldw	r2,-24(fp)
 324b01c:	10c00417 	ldw	r3,16(r2)
 324b020:	e0bffa17 	ldw	r2,-24(fp)
 324b024:	10c00315 	stw	r3,12(r2)
      pip->ip_dest = host;
 324b028:	e0fffa17 	ldw	r3,-24(fp)
 324b02c:	e0bffb17 	ldw	r2,-20(fp)
 324b030:	18800415 	stw	r2,16(r3)
      icmp_mib.icmpOutMsgs++;
 324b034:	0080c9b4 	movhi	r2,806
 324b038:	10b4be04 	addi	r2,r2,-11528
 324b03c:	10800d17 	ldw	r2,52(r2)
 324b040:	10c00044 	addi	r3,r2,1
 324b044:	0080c9b4 	movhi	r2,806
 324b048:	10b4be04 	addi	r2,r2,-11528
 324b04c:	10c00d15 	stw	r3,52(r2)
      icmp_mib.icmpOutTimestampReps++;
 324b050:	0080c9b4 	movhi	r2,806
 324b054:	10b4be04 	addi	r2,r2,-11528
 324b058:	10801717 	ldw	r2,92(r2)
 324b05c:	10c00044 	addi	r3,r2,1
 324b060:	0080c9b4 	movhi	r2,806
 324b064:	10b4be04 	addi	r2,r2,-11528
 324b068:	10c01715 	stw	r3,92(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 324b06c:	e0bffd17 	ldw	r2,-12(fp)
 324b070:	10c00317 	ldw	r3,12(r2)
 324b074:	e0bffa17 	ldw	r2,-24(fp)
 324b078:	10800003 	ldbu	r2,0(r2)
 324b07c:	10803fcc 	andi	r2,r2,255
 324b080:	108003cc 	andi	r2,r2,15
 324b084:	1085883a 	add	r2,r2,r2
 324b088:	1085883a 	add	r2,r2,r2
 324b08c:	1887883a 	add	r3,r3,r2
 324b090:	e0bffd17 	ldw	r2,-12(fp)
 324b094:	10c00315 	stw	r3,12(r2)
      p->nb_plen = sizeof(struct tstamp);
 324b098:	e0fffd17 	ldw	r3,-12(fp)
 324b09c:	00800504 	movi	r2,20
 324b0a0:	18800415 	stw	r2,16(r3)
      p->fhost = host;
 324b0a4:	e0fffd17 	ldw	r3,-12(fp)
 324b0a8:	e0bffb17 	ldw	r2,-20(fp)
 324b0ac:	18800715 	stw	r2,28(r3)
      i = ip_write(ICMP_PROT, p);
 324b0b0:	01000044 	movi	r4,1
 324b0b4:	e17ffd17 	ldw	r5,-12(fp)
 324b0b8:	323f0100 	call	323f010 <ip_write>
 324b0bc:	e0bff415 	stw	r2,-48(fp)
      if (i < 0)
 324b0c0:	e0bff417 	ldw	r2,-48(fp)
 324b0c4:	1004403a 	cmpge	r2,r2,zero
 324b0c8:	1000091e 	bne	r2,zero,324b0f0 <icmprcv+0xb48>
      {
#ifdef   NPDEBUG
         if (NDEBUG & UPCTRACE)
 324b0cc:	0080c974 	movhi	r2,805
 324b0d0:	10923104 	addi	r2,r2,18628
 324b0d4:	10800017 	ldw	r2,0(r2)
 324b0d8:	1081000c 	andi	r2,r2,1024
 324b0dc:	1005003a 	cmpeq	r2,r2,zero
 324b0e0:	1000031e 	bne	r2,zero,324b0f0 <icmprcv+0xb48>
            dprintf("icmp: can't send timestamp reply\n");
 324b0e4:	0100c974 	movhi	r4,805
 324b0e8:	21012d04 	addi	r4,r4,1204
 324b0ec:	3206e040 	call	3206e04 <puts>
#endif   /* NPDEBUG */
      }
      /* re-used packet was pk_free()d by net->send() */
      return (0);
 324b0f0:	e03fff15 	stw	zero,-4(fp)
 324b0f4:	00003106 	br	324b1bc <icmprcv+0xc14>
   case INFO:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 324b0f8:	0080c974 	movhi	r2,805
 324b0fc:	10923104 	addi	r2,r2,18628
 324b100:	10800017 	ldw	r2,0(r2)
 324b104:	1081000c 	andi	r2,r2,1024
 324b108:	1005003a 	cmpeq	r2,r2,zero
 324b10c:	1000031e 	bne	r2,zero,324b11c <icmprcv+0xb74>
         dprintf("icmp: got info request\n");
 324b110:	0100c974 	movhi	r4,805
 324b114:	21013604 	addi	r4,r4,1240
 324b118:	3206e040 	call	3206e04 <puts>
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 324b11c:	01000084 	movi	r4,2
 324b120:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(p);
 324b124:	e13ffd17 	ldw	r4,-12(fp)
 324b128:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324b12c:	01000084 	movi	r4,2
 324b130:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      break;
 324b134:	00001f06 	br	324b1b4 <icmprcv+0xc0c>
#endif   /* FULL_ICMP */
   default:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 324b138:	0080c974 	movhi	r2,805
 324b13c:	10923104 	addi	r2,r2,18628
 324b140:	10800017 	ldw	r2,0(r2)
 324b144:	1081000c 	andi	r2,r2,1024
 324b148:	1005003a 	cmpeq	r2,r2,zero
 324b14c:	1000101e 	bne	r2,zero,324b190 <icmprcv+0xbe8>
      {
         dprintf("icmp: unhandled type %u\n", e->ptype);
 324b150:	e0bff917 	ldw	r2,-28(fp)
 324b154:	10800003 	ldbu	r2,0(r2)
 324b158:	11403fcc 	andi	r5,r2,255
 324b15c:	2940201c 	xori	r5,r5,128
 324b160:	297fe004 	addi	r5,r5,-128
 324b164:	0100c974 	movhi	r4,805
 324b168:	21013c04 	addi	r4,r4,1264
 324b16c:	3206adc0 	call	3206adc <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 324b170:	0080c974 	movhi	r2,805
 324b174:	10923104 	addi	r2,r2,18628
 324b178:	10800017 	ldw	r2,0(r2)
 324b17c:	1080008c 	andi	r2,r2,2
 324b180:	1005003a 	cmpeq	r2,r2,zero
 324b184:	1000021e 	bne	r2,zero,324b190 <icmprcv+0xbe8>
 324b188:	e13ffd17 	ldw	r4,-12(fp)
 324b18c:	32402380 	call	3240238 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 324b190:	01000084 	movi	r4,2
 324b194:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
      pk_free(p);
 324b198:	e13ffd17 	ldw	r4,-12(fp)
 324b19c:	322a2dc0 	call	322a2dc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324b1a0:	01000084 	movi	r4,2
 324b1a4:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>
      return ENP_NOT_MINE;
 324b1a8:	00800084 	movi	r2,2
 324b1ac:	e0bfff15 	stw	r2,-4(fp)
 324b1b0:	00000206 	br	324b1bc <icmprcv+0xc14>
   }
#ifdef FULL_ICMP
   return ENP_NOT_MINE;
 324b1b4:	00c00084 	movi	r3,2
 324b1b8:	e0ffff15 	stw	r3,-4(fp)
 324b1bc:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* FULL_ICMP */
}
 324b1c0:	e037883a 	mov	sp,fp
 324b1c4:	dfc00317 	ldw	ra,12(sp)
 324b1c8:	df000217 	ldw	fp,8(sp)
 324b1cc:	dc400117 	ldw	r17,4(sp)
 324b1d0:	dc000017 	ldw	r16,0(sp)
 324b1d4:	dec00404 	addi	sp,sp,16
 324b1d8:	f800283a 	ret

0324b1dc <icmp_destun>:
icmp_destun(ip_addr host,  /* host to complain to */
   ip_addr src_addr, /* source address for outgoing ICMP/IP packet header */
   struct ip * ip,   /* IP header of offending packet */
   unsigned typecode,    /* type & code of DU to send (PROT, PORT, HOST) */
   NET   net)        /* interface that this packet came in on */
{
 324b1dc:	defff404 	addi	sp,sp,-48
 324b1e0:	dfc00b15 	stw	ra,44(sp)
 324b1e4:	df000a15 	stw	fp,40(sp)
 324b1e8:	df000a04 	addi	fp,sp,40
 324b1ec:	e13ffc15 	stw	r4,-16(fp)
 324b1f0:	e17ffd15 	stw	r5,-12(fp)
 324b1f4:	e1bffe15 	stw	r6,-8(fp)
 324b1f8:	e1ffff15 	stw	r7,-4(fp)
   struct destun *   d;
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 324b1fc:	0080c974 	movhi	r2,805
 324b200:	10923104 	addi	r2,r2,18628
 324b204:	10800017 	ldw	r2,0(r2)
 324b208:	1080040c 	andi	r2,r2,16
 324b20c:	1005003a 	cmpeq	r2,r2,zero
 324b210:	1000171e 	bne	r2,zero,324b270 <icmp_destun+0x94>
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 324b214:	e0bfff17 	ldw	r2,-4(fp)
 324b218:	10803fcc 	andi	r2,r2,255
 324b21c:	00c0c974 	movhi	r3,805
 324b220:	18c97104 	addi	r3,r3,9668
 324b224:	1085883a 	add	r2,r2,r2
 324b228:	1085883a 	add	r2,r2,r2
 324b22c:	10c5883a 	add	r2,r2,r3
 324b230:	11400017 	ldw	r5,0(r2)
 324b234:	e0bffc17 	ldw	r2,-16(fp)
 324b238:	11803fcc 	andi	r6,r2,255
 324b23c:	e0bffc17 	ldw	r2,-16(fp)
 324b240:	1004d23a 	srli	r2,r2,8
 324b244:	11c03fcc 	andi	r7,r2,255
 324b248:	e0bffc17 	ldw	r2,-16(fp)
 324b24c:	1004d43a 	srli	r2,r2,16
 324b250:	10c03fcc 	andi	r3,r2,255
 324b254:	e0bffc17 	ldw	r2,-16(fp)
 324b258:	1004d63a 	srli	r2,r2,24
 324b25c:	d8c00015 	stw	r3,0(sp)
 324b260:	d8800115 	stw	r2,4(sp)
 324b264:	0100c974 	movhi	r4,805
 324b268:	21015604 	addi	r4,r4,1368
 324b26c:	3206adc0 	call	3206adc <printf>
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(FREEQ_RESID);
 324b270:	01000084 	movi	r4,2
 324b274:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
   p = pk_alloc(512 + IPHSIZ);   /* get packet to send icmp dest unreachable */
 324b278:	01008504 	movi	r4,532
 324b27c:	3229f480 	call	3229f48 <pk_alloc>
 324b280:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324b284:	01000084 	movi	r4,2
 324b288:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 324b28c:	e0bffb17 	ldw	r2,-20(fp)
 324b290:	1004c03a 	cmpne	r2,r2,zero
 324b294:	1000111e 	bne	r2,zero,324b2dc <icmp_destun+0x100>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 324b298:	0080c974 	movhi	r2,805
 324b29c:	10923104 	addi	r2,r2,18628
 324b2a0:	10800017 	ldw	r2,0(r2)
 324b2a4:	1080800c 	andi	r2,r2,512
 324b2a8:	1005003a 	cmpeq	r2,r2,zero
 324b2ac:	1000031e 	bne	r2,zero,324b2bc <icmp_destun+0xe0>
         dprintf("icmp: can't alloc pkt\n");
 324b2b0:	0100c974 	movhi	r4,805
 324b2b4:	21016304 	addi	r4,r4,1420
 324b2b8:	3206e040 	call	3206e04 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 324b2bc:	0080c9b4 	movhi	r2,806
 324b2c0:	10b4be04 	addi	r2,r2,-11528
 324b2c4:	10800e17 	ldw	r2,56(r2)
 324b2c8:	10c00044 	addi	r3,r2,1
 324b2cc:	0080c9b4 	movhi	r2,806
 324b2d0:	10b4be04 	addi	r2,r2,-11528
 324b2d4:	10c00e15 	stw	r3,56(r2)
      return;
 324b2d8:	00008f06 	br	324b518 <icmp_destun+0x33c>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 324b2dc:	e0bffb17 	ldw	r2,-20(fp)
 324b2e0:	10800317 	ldw	r2,12(r2)
 324b2e4:	e0bff915 	stw	r2,-28(fp)
   pip->ip_src = src_addr;
 324b2e8:	e0fff917 	ldw	r3,-28(fp)
 324b2ec:	e0bffd17 	ldw	r2,-12(fp)
 324b2f0:	18800315 	stw	r2,12(r3)
   pip->ip_dest = host;
 324b2f4:	e0fff917 	ldw	r3,-28(fp)
 324b2f8:	e0bffc17 	ldw	r2,-16(fp)
 324b2fc:	18800415 	stw	r2,16(r3)

   /* allow space for icmp header */
   p->nb_prot += sizeof(struct ip);
 324b300:	e0bffb17 	ldw	r2,-20(fp)
 324b304:	10800317 	ldw	r2,12(r2)
 324b308:	10c00504 	addi	r3,r2,20
 324b30c:	e0bffb17 	ldw	r2,-20(fp)
 324b310:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= sizeof(struct ip);
 324b314:	e0bffb17 	ldw	r2,-20(fp)
 324b318:	10800417 	ldw	r2,16(r2)
 324b31c:	10fffb04 	addi	r3,r2,-20
 324b320:	e0bffb17 	ldw	r2,-20(fp)
 324b324:	10c00415 	stw	r3,16(r2)
   p->net = net;     /* Put in the interface that this packet came in on */
 324b328:	e0fffb17 	ldw	r3,-20(fp)
 324b32c:	e0800217 	ldw	r2,8(fp)
 324b330:	18800615 	stw	r2,24(r3)

   d = (struct destun *)p->nb_prot;
 324b334:	e0bffb17 	ldw	r2,-20(fp)
 324b338:	10800317 	ldw	r2,12(r2)
 324b33c:	e0bffa15 	stw	r2,-24(fp)

   if (typecode & 0xFF00)               /* if the type was sent */
 324b340:	e0bfff17 	ldw	r2,-4(fp)
 324b344:	10bfc00c 	andi	r2,r2,65280
 324b348:	1005003a 	cmpeq	r2,r2,zero
 324b34c:	1000061e 	bne	r2,zero,324b368 <icmp_destun+0x18c>
      d->dtype = (char)(typecode >>8);  /* then use it */
 324b350:	e0bfff17 	ldw	r2,-4(fp)
 324b354:	1004d23a 	srli	r2,r2,8
 324b358:	1007883a 	mov	r3,r2
 324b35c:	e0bffa17 	ldw	r2,-24(fp)
 324b360:	10c00005 	stb	r3,0(r2)
 324b364:	00000306 	br	324b374 <icmp_destun+0x198>
   else                                 /* else use default */
      d->dtype = DESTIN;
 324b368:	e0fffa17 	ldw	r3,-24(fp)
 324b36c:	008000c4 	movi	r2,3
 324b370:	18800005 	stb	r2,0(r3)
   d->dcode = (char)(typecode & 0xFF);
 324b374:	e0bfff17 	ldw	r2,-4(fp)
 324b378:	1007883a 	mov	r3,r2
 324b37c:	e0bffa17 	ldw	r2,-24(fp)
 324b380:	10c00045 	stb	r3,1(r2)
   d->dno1 = d->dno2 = 0;
 324b384:	e0bffa17 	ldw	r2,-24(fp)
 324b388:	1000018d 	sth	zero,6(r2)
 324b38c:	e0bffa17 	ldw	r2,-24(fp)
 324b390:	10c0018b 	ldhu	r3,6(r2)
 324b394:	e0bffa17 	ldw	r2,-24(fp)
 324b398:	10c0010d 	sth	r3,4(r2)
#ifndef ICMP_SUPPRESS_PMTU
   if ((typecode & 0xFF) == DSTFRAG)
 324b39c:	e0bfff17 	ldw	r2,-4(fp)
 324b3a0:	10803fcc 	andi	r2,r2,255
 324b3a4:	10800118 	cmpnei	r2,r2,4
 324b3a8:	1000151e 	bne	r2,zero,324b400 <icmp_destun+0x224>
      d->dno2 = htons(net->n_mtu - net->n_lnh);
 324b3ac:	e0800217 	ldw	r2,8(fp)
 324b3b0:	10c00917 	ldw	r3,36(r2)
 324b3b4:	e0800217 	ldw	r2,8(fp)
 324b3b8:	10800817 	ldw	r2,32(r2)
 324b3bc:	1885c83a 	sub	r2,r3,r2
 324b3c0:	1005d23a 	srai	r2,r2,8
 324b3c4:	10803fcc 	andi	r2,r2,255
 324b3c8:	1009883a 	mov	r4,r2
 324b3cc:	e0800217 	ldw	r2,8(fp)
 324b3d0:	10c00917 	ldw	r3,36(r2)
 324b3d4:	e0800217 	ldw	r2,8(fp)
 324b3d8:	10800817 	ldw	r2,32(r2)
 324b3dc:	1885c83a 	sub	r2,r3,r2
 324b3e0:	1004923a 	slli	r2,r2,8
 324b3e4:	1007883a 	mov	r3,r2
 324b3e8:	00bfc004 	movi	r2,-256
 324b3ec:	1884703a 	and	r2,r3,r2
 324b3f0:	2084b03a 	or	r2,r4,r2
 324b3f4:	1007883a 	mov	r3,r2
 324b3f8:	e0bffa17 	ldw	r2,-24(fp)
 324b3fc:	10c0018d 	sth	r3,6(r2)
#endif    /* ICMP_SUPPRESS_PMTU */
   MEMCPY(&d->dip, ip, (sizeof(struct ip) + ICMPDUDATA));
 324b400:	e0bffa17 	ldw	r2,-24(fp)
 324b404:	11000204 	addi	r4,r2,8
 324b408:	e0fffe17 	ldw	r3,-8(fp)
 324b40c:	18800017 	ldw	r2,0(r3)
 324b410:	20800015 	stw	r2,0(r4)
 324b414:	18800117 	ldw	r2,4(r3)
 324b418:	20800115 	stw	r2,4(r4)
 324b41c:	18800217 	ldw	r2,8(r3)
 324b420:	20800215 	stw	r2,8(r4)
 324b424:	18800317 	ldw	r2,12(r3)
 324b428:	20800315 	stw	r2,12(r4)
 324b42c:	18800417 	ldw	r2,16(r3)
 324b430:	20800415 	stw	r2,16(r4)
 324b434:	18800517 	ldw	r2,20(r3)
 324b438:	20800515 	stw	r2,20(r4)
 324b43c:	18800617 	ldw	r2,24(r3)
 324b440:	20800615 	stw	r2,24(r4)

   d->dchksum = 0;
 324b444:	e0bffa17 	ldw	r2,-24(fp)
 324b448:	1000008d 	sth	zero,2(r2)
   d->dchksum = ~cksum(d, sizeof(struct destun)>>1);
 324b44c:	e13ffa17 	ldw	r4,-24(fp)
 324b450:	01400484 	movi	r5,18
 324b454:	32259f80 	call	32259f8 <cksum>
 324b458:	0084303a 	nor	r2,zero,r2
 324b45c:	1007883a 	mov	r3,r2
 324b460:	e0bffa17 	ldw	r2,-24(fp)
 324b464:	10c0008d 	sth	r3,2(r2)

   p->nb_plen =  sizeof(struct destun);
 324b468:	e0fffb17 	ldw	r3,-20(fp)
 324b46c:	00800904 	movi	r2,36
 324b470:	18800415 	stw	r2,16(r3)
   p->fhost = host;
 324b474:	e0fffb17 	ldw	r3,-20(fp)
 324b478:	e0bffc17 	ldw	r2,-16(fp)
 324b47c:	18800715 	stw	r2,28(r3)
   i = ip_write(ICMP_PROT, p);
 324b480:	01000044 	movi	r4,1
 324b484:	e17ffb17 	ldw	r5,-20(fp)
 324b488:	323f0100 	call	323f010 <ip_write>
 324b48c:	e0bff815 	stw	r2,-32(fp)
   if (i < 0)
 324b490:	e0bff817 	ldw	r2,-32(fp)
 324b494:	1004403a 	cmpge	r2,r2,zero
 324b498:	1000111e 	bne	r2,zero,324b4e0 <icmp_destun+0x304>
   {
      icmp_mib.icmpOutErrors++;
 324b49c:	0080c9b4 	movhi	r2,806
 324b4a0:	10b4be04 	addi	r2,r2,-11528
 324b4a4:	10800e17 	ldw	r2,56(r2)
 324b4a8:	10c00044 	addi	r3,r2,1
 324b4ac:	0080c9b4 	movhi	r2,806
 324b4b0:	10b4be04 	addi	r2,r2,-11528
 324b4b4:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 324b4b8:	0080c974 	movhi	r2,805
 324b4bc:	10923104 	addi	r2,r2,18628
 324b4c0:	10800017 	ldw	r2,0(r2)
 324b4c4:	1080860c 	andi	r2,r2,536
 324b4c8:	1005003a 	cmpeq	r2,r2,zero
 324b4cc:	1000121e 	bne	r2,zero,324b518 <icmp_destun+0x33c>
         dprintf("ICMP: Can't send dest unreachable\n");
 324b4d0:	0100c974 	movhi	r4,805
 324b4d4:	21016904 	addi	r4,r4,1444
 324b4d8:	3206e040 	call	3206e04 <puts>
#endif   /* NPDEBUG  */
      return;
 324b4dc:	00000e06 	br	324b518 <icmp_destun+0x33c>
   }
   icmp_mib.icmpOutMsgs++;
 324b4e0:	0080c9b4 	movhi	r2,806
 324b4e4:	10b4be04 	addi	r2,r2,-11528
 324b4e8:	10800d17 	ldw	r2,52(r2)
 324b4ec:	10c00044 	addi	r3,r2,1
 324b4f0:	0080c9b4 	movhi	r2,806
 324b4f4:	10b4be04 	addi	r2,r2,-11528
 324b4f8:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutDestUnreachs++;
 324b4fc:	0080c9b4 	movhi	r2,806
 324b500:	10b4be04 	addi	r2,r2,-11528
 324b504:	10800f17 	ldw	r2,60(r2)
 324b508:	10c00044 	addi	r3,r2,1
 324b50c:	0080c9b4 	movhi	r2,806
 324b510:	10b4be04 	addi	r2,r2,-11528
 324b514:	10c00f15 	stw	r3,60(r2)
   return;
}
 324b518:	e037883a 	mov	sp,fp
 324b51c:	dfc00117 	ldw	ra,4(sp)
 324b520:	df000017 	ldw	fp,0(sp)
 324b524:	dec00204 	addi	sp,sp,8
 324b528:	f800283a 	ret

0324b52c <icmp_timex>:
 *
 * RETURNS: void
 */

void icmp_timex (struct ip * ip, char code) 
{
 324b52c:	defff504 	addi	sp,sp,-44
 324b530:	dfc00a15 	stw	ra,40(sp)
 324b534:	df000915 	stw	fp,36(sp)
 324b538:	df000904 	addi	fp,sp,36
 324b53c:	e13ffe15 	stw	r4,-8(fp)
 324b540:	e17fff05 	stb	r5,-4(fp)
   struct ip * pip;
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 324b544:	0080c974 	movhi	r2,805
 324b548:	10923104 	addi	r2,r2,18628
 324b54c:	10800017 	ldw	r2,0(r2)
 324b550:	1080040c 	andi	r2,r2,16
 324b554:	1005003a 	cmpeq	r2,r2,zero
 324b558:	1000301e 	bne	r2,zero,324b61c <icmp_timex+0xf0>
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 324b55c:	e17fff07 	ldb	r5,-4(fp)
 324b560:	e0bffe17 	ldw	r2,-8(fp)
 324b564:	10800317 	ldw	r2,12(r2)
 324b568:	1004d23a 	srli	r2,r2,8
 324b56c:	10c03fcc 	andi	r3,r2,255
 324b570:	e0bffe17 	ldw	r2,-8(fp)
 324b574:	10800317 	ldw	r2,12(r2)
 324b578:	1004923a 	slli	r2,r2,8
 324b57c:	10bfc00c 	andi	r2,r2,65280
 324b580:	1884b03a 	or	r2,r3,r2
 324b584:	11803fcc 	andi	r6,r2,255
 324b588:	e0bffe17 	ldw	r2,-8(fp)
 324b58c:	10800317 	ldw	r2,12(r2)
 324b590:	1004d23a 	srli	r2,r2,8
 324b594:	10c03fcc 	andi	r3,r2,255
 324b598:	e0bffe17 	ldw	r2,-8(fp)
 324b59c:	10800317 	ldw	r2,12(r2)
 324b5a0:	1004923a 	slli	r2,r2,8
 324b5a4:	10bfc00c 	andi	r2,r2,65280
 324b5a8:	1884b03a 	or	r2,r3,r2
 324b5ac:	1004d23a 	srli	r2,r2,8
 324b5b0:	11c03fcc 	andi	r7,r2,255
 324b5b4:	e0bffe17 	ldw	r2,-8(fp)
 324b5b8:	10800317 	ldw	r2,12(r2)
 324b5bc:	1004d23a 	srli	r2,r2,8
 324b5c0:	10c03fcc 	andi	r3,r2,255
 324b5c4:	e0bffe17 	ldw	r2,-8(fp)
 324b5c8:	10800317 	ldw	r2,12(r2)
 324b5cc:	1004923a 	slli	r2,r2,8
 324b5d0:	10bfc00c 	andi	r2,r2,65280
 324b5d4:	1884b03a 	or	r2,r3,r2
 324b5d8:	1004d43a 	srli	r2,r2,16
 324b5dc:	11003fcc 	andi	r4,r2,255
 324b5e0:	e0bffe17 	ldw	r2,-8(fp)
 324b5e4:	10800317 	ldw	r2,12(r2)
 324b5e8:	1004d23a 	srli	r2,r2,8
 324b5ec:	10c03fcc 	andi	r3,r2,255
 324b5f0:	e0bffe17 	ldw	r2,-8(fp)
 324b5f4:	10800317 	ldw	r2,12(r2)
 324b5f8:	1004923a 	slli	r2,r2,8
 324b5fc:	10bfc00c 	andi	r2,r2,65280
 324b600:	1884b03a 	or	r2,r3,r2
 324b604:	1004d63a 	srli	r2,r2,24
 324b608:	d9000015 	stw	r4,0(sp)
 324b60c:	d8800115 	stw	r2,4(sp)
 324b610:	0100c974 	movhi	r4,805
 324b614:	21017204 	addi	r4,r4,1480
 324b618:	3206adc0 	call	3206adc <printf>
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
#endif   /* NPDEBUG */

   icmp_pkt_len = ICMPTIMEX_HDR_LEN + ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN;
 324b61c:	e0bffe17 	ldw	r2,-8(fp)
 324b620:	10800003 	ldbu	r2,0(r2)
 324b624:	108003cc 	andi	r2,r2,15
 324b628:	1085883a 	add	r2,r2,r2
 324b62c:	1085883a 	add	r2,r2,r2
 324b630:	10800404 	addi	r2,r2,16
 324b634:	e0bff905 	stb	r2,-28(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 324b638:	01000084 	movi	r4,2
 324b63c:	322ae2c0 	call	322ae2c <LOCK_NET_RESOURCE>
    * length of the "outer" IP header, length of the ICMP header (ICMPTIMEX_HDR_LEN,
    * 8 bytes), length of the "inner" IP header, and length of "user" data 
    * (ICMPTIMEX_PAYLOAD_DATA_LEN, 8 bytes) (just past the "inner" IP header).  The 
    * latter two items are from the packet that the ICMP Time Exceeded message is 
    * being sent in response to. */
   p = pk_alloc(MaxLnh + IPHSIZ + icmp_pkt_len);
 324b640:	e0fff903 	ldbu	r3,-28(fp)
 324b644:	0080c974 	movhi	r2,805
 324b648:	10922f04 	addi	r2,r2,18620
 324b64c:	10800017 	ldw	r2,0(r2)
 324b650:	1885883a 	add	r2,r3,r2
 324b654:	11000504 	addi	r4,r2,20
 324b658:	3229f480 	call	3229f48 <pk_alloc>
 324b65c:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324b660:	01000084 	movi	r4,2
 324b664:	322aeec0 	call	322aeec <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 324b668:	e0bffd17 	ldw	r2,-12(fp)
 324b66c:	1004c03a 	cmpne	r2,r2,zero
 324b670:	1000111e 	bne	r2,zero,324b6b8 <icmp_timex+0x18c>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 324b674:	0080c974 	movhi	r2,805
 324b678:	10923104 	addi	r2,r2,18628
 324b67c:	10800017 	ldw	r2,0(r2)
 324b680:	1080800c 	andi	r2,r2,512
 324b684:	1005003a 	cmpeq	r2,r2,zero
 324b688:	1000031e 	bne	r2,zero,324b698 <icmp_timex+0x16c>
         dprintf("icmp: can't alloc pkt\n");
 324b68c:	0100c974 	movhi	r4,805
 324b690:	21016304 	addi	r4,r4,1420
 324b694:	3206e040 	call	3206e04 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 324b698:	0080c9b4 	movhi	r2,806
 324b69c:	10b4be04 	addi	r2,r2,-11528
 324b6a0:	10800e17 	ldw	r2,56(r2)
 324b6a4:	10c00044 	addi	r3,r2,1
 324b6a8:	0080c9b4 	movhi	r2,806
 324b6ac:	10b4be04 	addi	r2,r2,-11528
 324b6b0:	10c00e15 	stw	r3,56(r2)
      return;
 324b6b4:	00006506 	br	324b84c <icmp_timex+0x320>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 324b6b8:	e0bffd17 	ldw	r2,-12(fp)
 324b6bc:	10800317 	ldw	r2,12(r2)
 324b6c0:	e0bffb15 	stw	r2,-20(fp)
   /* source IP address of packet is our address (i.e., destination IP address 
    * in the datagram whose reassembly timed out) */
   pip->ip_src = ip->ip_dest;
 324b6c4:	e0bffe17 	ldw	r2,-8(fp)
 324b6c8:	10c00417 	ldw	r3,16(r2)
 324b6cc:	e0bffb17 	ldw	r2,-20(fp)
 324b6d0:	10c00315 	stw	r3,12(r2)
   /* the destination address is the same as the source IP address of the 
    * datagram whose reassembly timed out */
   pip->ip_dest = ip->ip_src;
 324b6d4:	e0bffe17 	ldw	r2,-8(fp)
 324b6d8:	10c00317 	ldw	r3,12(r2)
 324b6dc:	e0bffb17 	ldw	r2,-20(fp)
 324b6e0:	10c00415 	stw	r3,16(r2)

   /* move past space for IP header to get to start of ICMP header */
   p->nb_prot += sizeof(struct ip);
 324b6e4:	e0bffd17 	ldw	r2,-12(fp)
 324b6e8:	10800317 	ldw	r2,12(r2)
 324b6ec:	10c00504 	addi	r3,r2,20
 324b6f0:	e0bffd17 	ldw	r2,-12(fp)
 324b6f4:	10c00315 	stw	r3,12(r2)

   tx = (struct timex *) p->nb_prot;
 324b6f8:	e0bffd17 	ldw	r2,-12(fp)
 324b6fc:	10800317 	ldw	r2,12(r2)
 324b700:	e0bffc15 	stw	r2,-16(fp)

   tx->ttype = TIMEX;
 324b704:	e0fffc17 	ldw	r3,-16(fp)
 324b708:	008002c4 	movi	r2,11
 324b70c:	18800005 	stb	r2,0(r3)
   tx->tcode = code;
 324b710:	e0fffc17 	ldw	r3,-16(fp)
 324b714:	e0bfff03 	ldbu	r2,-4(fp)
 324b718:	18800045 	stb	r2,1(r3)
   tx->tno1 = tx->tno2 = 0;
 324b71c:	e0bffc17 	ldw	r2,-16(fp)
 324b720:	1000018d 	sth	zero,6(r2)
 324b724:	e0bffc17 	ldw	r2,-16(fp)
 324b728:	10c0018b 	ldhu	r3,6(r2)
 324b72c:	e0bffc17 	ldw	r2,-16(fp)
 324b730:	10c0010d 	sth	r3,4(r2)
   MEMCPY(&tx->tip, ip, (ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN));
 324b734:	e0bffc17 	ldw	r2,-16(fp)
 324b738:	11000204 	addi	r4,r2,8
 324b73c:	e0bffe17 	ldw	r2,-8(fp)
 324b740:	10800003 	ldbu	r2,0(r2)
 324b744:	10803fcc 	andi	r2,r2,255
 324b748:	108003cc 	andi	r2,r2,15
 324b74c:	1085883a 	add	r2,r2,r2
 324b750:	1085883a 	add	r2,r2,r2
 324b754:	10800204 	addi	r2,r2,8
 324b758:	1007883a 	mov	r3,r2
 324b75c:	e0bffe17 	ldw	r2,-8(fp)
 324b760:	100b883a 	mov	r5,r2
 324b764:	180d883a 	mov	r6,r3
 324b768:	32067cc0 	call	32067cc <memcpy>

   tx->tchksum = 0;
 324b76c:	e0bffc17 	ldw	r2,-16(fp)
 324b770:	1000008d 	sth	zero,2(r2)
   tx->tchksum = ~cksum(tx, (icmp_pkt_len>>1));
 324b774:	e0bff903 	ldbu	r2,-28(fp)
 324b778:	1004d07a 	srli	r2,r2,1
 324b77c:	11403fcc 	andi	r5,r2,255
 324b780:	e13ffc17 	ldw	r4,-16(fp)
 324b784:	32259f80 	call	32259f8 <cksum>
 324b788:	0084303a 	nor	r2,zero,r2
 324b78c:	1007883a 	mov	r3,r2
 324b790:	e0bffc17 	ldw	r2,-16(fp)
 324b794:	10c0008d 	sth	r3,2(r2)

   p->nb_plen = icmp_pkt_len;
 324b798:	e0fff903 	ldbu	r3,-28(fp)
 324b79c:	e0bffd17 	ldw	r2,-12(fp)
 324b7a0:	10c00415 	stw	r3,16(r2)
   /* p->fhost is expected to be in network byte order */
   p->fhost = pip->ip_dest;
 324b7a4:	e0bffb17 	ldw	r2,-20(fp)
 324b7a8:	10c00417 	ldw	r3,16(r2)
 324b7ac:	e0bffd17 	ldw	r2,-12(fp)
 324b7b0:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 324b7b4:	01000044 	movi	r4,1
 324b7b8:	e17ffd17 	ldw	r5,-12(fp)
 324b7bc:	323f0100 	call	323f010 <ip_write>
 324b7c0:	e0bffa15 	stw	r2,-24(fp)
   if (i < 0)
 324b7c4:	e0bffa17 	ldw	r2,-24(fp)
 324b7c8:	1004403a 	cmpge	r2,r2,zero
 324b7cc:	1000111e 	bne	r2,zero,324b814 <icmp_timex+0x2e8>
   {
      icmp_mib.icmpOutErrors++;
 324b7d0:	0080c9b4 	movhi	r2,806
 324b7d4:	10b4be04 	addi	r2,r2,-11528
 324b7d8:	10800e17 	ldw	r2,56(r2)
 324b7dc:	10c00044 	addi	r3,r2,1
 324b7e0:	0080c9b4 	movhi	r2,806
 324b7e4:	10b4be04 	addi	r2,r2,-11528
 324b7e8:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 324b7ec:	0080c974 	movhi	r2,805
 324b7f0:	10923104 	addi	r2,r2,18628
 324b7f4:	10800017 	ldw	r2,0(r2)
 324b7f8:	1080860c 	andi	r2,r2,536
 324b7fc:	1005003a 	cmpeq	r2,r2,zero
 324b800:	1000121e 	bne	r2,zero,324b84c <icmp_timex+0x320>
         dprintf("ICMP: Can't send Time Exceeded\n");
 324b804:	0100c974 	movhi	r4,805
 324b808:	21018204 	addi	r4,r4,1544
 324b80c:	3206e040 	call	3206e04 <puts>
#endif   /* NPDEBUG  */
      return;
 324b810:	00000e06 	br	324b84c <icmp_timex+0x320>
   }
   icmp_mib.icmpOutMsgs++;
 324b814:	0080c9b4 	movhi	r2,806
 324b818:	10b4be04 	addi	r2,r2,-11528
 324b81c:	10800d17 	ldw	r2,52(r2)
 324b820:	10c00044 	addi	r3,r2,1
 324b824:	0080c9b4 	movhi	r2,806
 324b828:	10b4be04 	addi	r2,r2,-11528
 324b82c:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutTimeExcds++;
 324b830:	0080c9b4 	movhi	r2,806
 324b834:	10b4be04 	addi	r2,r2,-11528
 324b838:	10801017 	ldw	r2,64(r2)
 324b83c:	10c00044 	addi	r3,r2,1
 324b840:	0080c9b4 	movhi	r2,806
 324b844:	10b4be04 	addi	r2,r2,-11528
 324b848:	10c01015 	stw	r3,64(r2)
   return;
}
 324b84c:	e037883a 	mov	sp,fp
 324b850:	dfc00117 	ldw	ra,4(sp)
 324b854:	df000017 	ldw	fp,0(sp)
 324b858:	dec00204 	addi	sp,sp,8
 324b85c:	f800283a 	ret

0324b860 <icmp_du>:
 * RETURNS: void
 */

void  
icmp_du(PACKET p, struct destun * pdp)
{
 324b860:	defffc04 	addi	sp,sp,-16
 324b864:	dfc00315 	stw	ra,12(sp)
 324b868:	df000215 	stw	fp,8(sp)
 324b86c:	df000204 	addi	fp,sp,8
 324b870:	e13ffe15 	stw	r4,-8(fp)
 324b874:	e17fff15 	stw	r5,-4(fp)
   /* see if user app wants notification first */
   if (icmpdu_hook)
 324b878:	d0a91317 	ldw	r2,-23476(gp)
 324b87c:	1005003a 	cmpeq	r2,r2,zero
 324b880:	1000041e 	bne	r2,zero,324b894 <icmp_du+0x34>
      icmpdu_hook(p, pdp);
 324b884:	d0a91317 	ldw	r2,-23476(gp)
 324b888:	e13ffe17 	ldw	r4,-8(fp)
 324b88c:	e17fff17 	ldw	r5,-4(fp)
 324b890:	103ee83a 	callr	r2

#ifdef INCLUDE_TCP
   /* Tell the sockets layer so it can correct the problem. */
   so_icmpdu(p, pdp);   /* this call should free packet p */
 324b894:	e13ffe17 	ldw	r4,-8(fp)
 324b898:	e17fff17 	ldw	r5,-4(fp)
 324b89c:	322cdbc0 	call	322cdbc <so_icmpdu>
done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(p); /* else just free packet */
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif   /* INCLUDE_TCP */
}
 324b8a0:	e037883a 	mov	sp,fp
 324b8a4:	dfc00117 	ldw	ra,4(sp)
 324b8a8:	df000017 	ldw	fp,0(sp)
 324b8ac:	dec00204 	addi	sp,sp,8
 324b8b0:	f800283a 	ret

0324b8b4 <atexit>:
 324b8b4:	200b883a 	mov	r5,r4
 324b8b8:	000d883a 	mov	r6,zero
 324b8bc:	0009883a 	mov	r4,zero
 324b8c0:	000f883a 	mov	r7,zero
 324b8c4:	324bcb01 	jmpi	324bcb0 <__register_exitproc>

0324b8c8 <_atoi_r>:
 324b8c8:	000d883a 	mov	r6,zero
 324b8cc:	01c00284 	movi	r7,10
 324b8d0:	32102e01 	jmpi	32102e0 <_strtol_r>

0324b8d4 <atoi>:
 324b8d4:	000b883a 	mov	r5,zero
 324b8d8:	01800284 	movi	r6,10
 324b8dc:	32105241 	jmpi	3210524 <strtol>

0324b8e0 <calloc>:
 324b8e0:	0180c974 	movhi	r6,805
 324b8e4:	31897804 	addi	r6,r6,9696
 324b8e8:	2007883a 	mov	r3,r4
 324b8ec:	31000017 	ldw	r4,0(r6)
 324b8f0:	280d883a 	mov	r6,r5
 324b8f4:	180b883a 	mov	r5,r3
 324b8f8:	32110381 	jmpi	3211038 <_calloc_r>

0324b8fc <exit>:
 324b8fc:	defffe04 	addi	sp,sp,-8
 324b900:	000b883a 	mov	r5,zero
 324b904:	dc000015 	stw	r16,0(sp)
 324b908:	dfc00115 	stw	ra,4(sp)
 324b90c:	2021883a 	mov	r16,r4
 324b910:	324bde80 	call	324bde8 <__call_exitprocs>
 324b914:	0080c974 	movhi	r2,805
 324b918:	10897904 	addi	r2,r2,9700
 324b91c:	11000017 	ldw	r4,0(r2)
 324b920:	20800f17 	ldw	r2,60(r4)
 324b924:	10000126 	beq	r2,zero,324b92c <exit+0x30>
 324b928:	103ee83a 	callr	r2
 324b92c:	8009883a 	mov	r4,r16
 324b930:	324bfd80 	call	324bfd8 <_exit>

0324b934 <free>:
 324b934:	0080c974 	movhi	r2,805
 324b938:	10897804 	addi	r2,r2,9696
 324b93c:	200b883a 	mov	r5,r4
 324b940:	11000017 	ldw	r4,0(r2)
 324b944:	3204e0c1 	jmpi	3204e0c <_free_r>

0324b948 <malloc>:
 324b948:	0080c974 	movhi	r2,805
 324b94c:	10897804 	addi	r2,r2,9696
 324b950:	200b883a 	mov	r5,r4
 324b954:	11000017 	ldw	r4,0(r2)
 324b958:	3205fa81 	jmpi	3205fa8 <_malloc_r>

0324b95c <memcmp>:
 324b95c:	00c000c4 	movi	r3,3
 324b960:	1980032e 	bgeu	r3,r6,324b970 <memcmp+0x14>
 324b964:	2144b03a 	or	r2,r4,r5
 324b968:	10c4703a 	and	r2,r2,r3
 324b96c:	10000f26 	beq	r2,zero,324b9ac <memcmp+0x50>
 324b970:	31ffffc4 	addi	r7,r6,-1
 324b974:	3000061e 	bne	r6,zero,324b990 <memcmp+0x34>
 324b978:	00000a06 	br	324b9a4 <memcmp+0x48>
 324b97c:	39ffffc4 	addi	r7,r7,-1
 324b980:	00bfffc4 	movi	r2,-1
 324b984:	21000044 	addi	r4,r4,1
 324b988:	29400044 	addi	r5,r5,1
 324b98c:	38800526 	beq	r7,r2,324b9a4 <memcmp+0x48>
 324b990:	20c00003 	ldbu	r3,0(r4)
 324b994:	28800003 	ldbu	r2,0(r5)
 324b998:	18bff826 	beq	r3,r2,324b97c <memcmp+0x20>
 324b99c:	1885c83a 	sub	r2,r3,r2
 324b9a0:	f800283a 	ret
 324b9a4:	0005883a 	mov	r2,zero
 324b9a8:	f800283a 	ret
 324b9ac:	180f883a 	mov	r7,r3
 324b9b0:	20c00017 	ldw	r3,0(r4)
 324b9b4:	28800017 	ldw	r2,0(r5)
 324b9b8:	18bfed1e 	bne	r3,r2,324b970 <memcmp+0x14>
 324b9bc:	31bfff04 	addi	r6,r6,-4
 324b9c0:	21000104 	addi	r4,r4,4
 324b9c4:	29400104 	addi	r5,r5,4
 324b9c8:	39bff936 	bltu	r7,r6,324b9b0 <memcmp+0x54>
 324b9cc:	003fe806 	br	324b970 <memcmp+0x14>

0324b9d0 <strcpy>:
 324b9d0:	2904b03a 	or	r2,r5,r4
 324b9d4:	108000cc 	andi	r2,r2,3
 324b9d8:	10000826 	beq	r2,zero,324b9fc <strcpy+0x2c>
 324b9dc:	2007883a 	mov	r3,r4
 324b9e0:	28800003 	ldbu	r2,0(r5)
 324b9e4:	29400044 	addi	r5,r5,1
 324b9e8:	18800005 	stb	r2,0(r3)
 324b9ec:	18c00044 	addi	r3,r3,1
 324b9f0:	103ffb1e 	bne	r2,zero,324b9e0 <strcpy+0x10>
 324b9f4:	2005883a 	mov	r2,r4
 324b9f8:	f800283a 	ret
 324b9fc:	29800017 	ldw	r6,0(r5)
 324ba00:	023fbff4 	movhi	r8,65279
 324ba04:	423fbfc4 	addi	r8,r8,-257
 324ba08:	02a02074 	movhi	r10,32897
 324ba0c:	52a02004 	addi	r10,r10,-32640
 324ba10:	3205883a 	add	r2,r6,r8
 324ba14:	0186303a 	nor	r3,zero,r6
 324ba18:	10c4703a 	and	r2,r2,r3
 324ba1c:	1284703a 	and	r2,r2,r10
 324ba20:	200f883a 	mov	r7,r4
 324ba24:	10000b1e 	bne	r2,zero,324ba54 <strcpy+0x84>
 324ba28:	4013883a 	mov	r9,r8
 324ba2c:	5011883a 	mov	r8,r10
 324ba30:	39800015 	stw	r6,0(r7)
 324ba34:	29400104 	addi	r5,r5,4
 324ba38:	29800017 	ldw	r6,0(r5)
 324ba3c:	39c00104 	addi	r7,r7,4
 324ba40:	3245883a 	add	r2,r6,r9
 324ba44:	0186303a 	nor	r3,zero,r6
 324ba48:	10c4703a 	and	r2,r2,r3
 324ba4c:	1204703a 	and	r2,r2,r8
 324ba50:	103ff726 	beq	r2,zero,324ba30 <strcpy+0x60>
 324ba54:	3807883a 	mov	r3,r7
 324ba58:	003fe106 	br	324b9e0 <strcpy+0x10>

0324ba5c <strncmp>:
 324ba5c:	30003926 	beq	r6,zero,324bb44 <strncmp+0xe8>
 324ba60:	2144b03a 	or	r2,r4,r5
 324ba64:	108000cc 	andi	r2,r2,3
 324ba68:	028000c4 	movi	r10,3
 324ba6c:	1000241e 	bne	r2,zero,324bb00 <strncmp+0xa4>
 324ba70:	2011883a 	mov	r8,r4
 324ba74:	280f883a 	mov	r7,r5
 324ba78:	51801f2e 	bgeu	r10,r6,324baf8 <strncmp+0x9c>
 324ba7c:	21000017 	ldw	r4,0(r4)
 324ba80:	28800017 	ldw	r2,0(r5)
 324ba84:	20801c1e 	bne	r4,r2,324baf8 <strncmp+0x9c>
 324ba88:	31bfff04 	addi	r6,r6,-4
 324ba8c:	30002d26 	beq	r6,zero,324bb44 <strncmp+0xe8>
 324ba90:	027fbff4 	movhi	r9,65279
 324ba94:	4a7fbfc4 	addi	r9,r9,-257
 324ba98:	2247883a 	add	r3,r4,r9
 324ba9c:	01602074 	movhi	r5,32897
 324baa0:	29602004 	addi	r5,r5,-32640
 324baa4:	1946703a 	and	r3,r3,r5
 324baa8:	0104303a 	nor	r2,zero,r4
 324baac:	10c4703a 	and	r2,r2,r3
 324bab0:	1000241e 	bne	r2,zero,324bb44 <strncmp+0xe8>
 324bab4:	5017883a 	mov	r11,r10
 324bab8:	4815883a 	mov	r10,r9
 324babc:	2813883a 	mov	r9,r5
 324bac0:	00000a06 	br	324baec <strncmp+0x90>
 324bac4:	41000017 	ldw	r4,0(r8)
 324bac8:	39400017 	ldw	r5,0(r7)
 324bacc:	2285883a 	add	r2,r4,r10
 324bad0:	1244703a 	and	r2,r2,r9
 324bad4:	0106303a 	nor	r3,zero,r4
 324bad8:	1886703a 	and	r3,r3,r2
 324badc:	2140061e 	bne	r4,r5,324baf8 <strncmp+0x9c>
 324bae0:	31bfff04 	addi	r6,r6,-4
 324bae4:	30001726 	beq	r6,zero,324bb44 <strncmp+0xe8>
 324bae8:	1800161e 	bne	r3,zero,324bb44 <strncmp+0xe8>
 324baec:	42000104 	addi	r8,r8,4
 324baf0:	39c00104 	addi	r7,r7,4
 324baf4:	59bff336 	bltu	r11,r6,324bac4 <strncmp+0x68>
 324baf8:	4009883a 	mov	r4,r8
 324bafc:	380b883a 	mov	r5,r7
 324bb00:	31bfffc4 	addi	r6,r6,-1
 324bb04:	01ffffc4 	movi	r7,-1
 324bb08:	31c00a1e 	bne	r6,r7,324bb34 <strncmp+0xd8>
 324bb0c:	20c00003 	ldbu	r3,0(r4)
 324bb10:	28800003 	ldbu	r2,0(r5)
 324bb14:	1885c83a 	sub	r2,r3,r2
 324bb18:	f800283a 	ret
 324bb1c:	30000926 	beq	r6,zero,324bb44 <strncmp+0xe8>
 324bb20:	18000826 	beq	r3,zero,324bb44 <strncmp+0xe8>
 324bb24:	31bfffc4 	addi	r6,r6,-1
 324bb28:	21000044 	addi	r4,r4,1
 324bb2c:	29400044 	addi	r5,r5,1
 324bb30:	31fff626 	beq	r6,r7,324bb0c <strncmp+0xb0>
 324bb34:	20c00007 	ldb	r3,0(r4)
 324bb38:	28800007 	ldb	r2,0(r5)
 324bb3c:	18bff726 	beq	r3,r2,324bb1c <strncmp+0xc0>
 324bb40:	003ff206 	br	324bb0c <strncmp+0xb0>
 324bb44:	0005883a 	mov	r2,zero
 324bb48:	f800283a 	ret

0324bb4c <strncpy>:
 324bb4c:	2904b03a 	or	r2,r5,r4
 324bb50:	108000cc 	andi	r2,r2,3
 324bb54:	00c000c4 	movi	r3,3
 324bb58:	1000291e 	bne	r2,zero,324bc00 <strncpy+0xb4>
 324bb5c:	1980282e 	bgeu	r3,r6,324bc00 <strncpy+0xb4>
 324bb60:	1817883a 	mov	r11,r3
 324bb64:	2011883a 	mov	r8,r4
 324bb68:	02bfbff4 	movhi	r10,65279
 324bb6c:	52bfbfc4 	addi	r10,r10,-257
 324bb70:	02602074 	movhi	r9,32897
 324bb74:	4a602004 	addi	r9,r9,-32640
 324bb78:	29c00017 	ldw	r7,0(r5)
 324bb7c:	3a85883a 	add	r2,r7,r10
 324bb80:	01c6303a 	nor	r3,zero,r7
 324bb84:	10c4703a 	and	r2,r2,r3
 324bb88:	1244703a 	and	r2,r2,r9
 324bb8c:	1000051e 	bne	r2,zero,324bba4 <strncpy+0x58>
 324bb90:	31bfff04 	addi	r6,r6,-4
 324bb94:	41c00015 	stw	r7,0(r8)
 324bb98:	29400104 	addi	r5,r5,4
 324bb9c:	42000104 	addi	r8,r8,4
 324bba0:	59bff536 	bltu	r11,r6,324bb78 <strncpy+0x2c>
 324bba4:	400f883a 	mov	r7,r8
 324bba8:	30001326 	beq	r6,zero,324bbf8 <strncpy+0xac>
 324bbac:	28800003 	ldbu	r2,0(r5)
 324bbb0:	31bfffc4 	addi	r6,r6,-1
 324bbb4:	38c00044 	addi	r3,r7,1
 324bbb8:	38800005 	stb	r2,0(r7)
 324bbbc:	10000826 	beq	r2,zero,324bbe0 <strncpy+0x94>
 324bbc0:	29400044 	addi	r5,r5,1
 324bbc4:	30000c26 	beq	r6,zero,324bbf8 <strncpy+0xac>
 324bbc8:	28800003 	ldbu	r2,0(r5)
 324bbcc:	31bfffc4 	addi	r6,r6,-1
 324bbd0:	29400044 	addi	r5,r5,1
 324bbd4:	18800005 	stb	r2,0(r3)
 324bbd8:	18c00044 	addi	r3,r3,1
 324bbdc:	103ff91e 	bne	r2,zero,324bbc4 <strncpy+0x78>
 324bbe0:	30000526 	beq	r6,zero,324bbf8 <strncpy+0xac>
 324bbe4:	1805883a 	mov	r2,r3
 324bbe8:	30cd883a 	add	r6,r6,r3
 324bbec:	10000005 	stb	zero,0(r2)
 324bbf0:	10800044 	addi	r2,r2,1
 324bbf4:	30bffd1e 	bne	r6,r2,324bbec <strncpy+0xa0>
 324bbf8:	2005883a 	mov	r2,r4
 324bbfc:	f800283a 	ret
 324bc00:	200f883a 	mov	r7,r4
 324bc04:	003fe806 	br	324bba8 <strncpy+0x5c>

0324bc08 <_vprintf_r>:
 324bc08:	2807883a 	mov	r3,r5
 324bc0c:	21400217 	ldw	r5,8(r4)
 324bc10:	300f883a 	mov	r7,r6
 324bc14:	180d883a 	mov	r6,r3
 324bc18:	32082181 	jmpi	3208218 <___vfprintf_internal_r>

0324bc1c <vprintf>:
 324bc1c:	0080c974 	movhi	r2,805
 324bc20:	10897804 	addi	r2,r2,9696
 324bc24:	12000017 	ldw	r8,0(r2)
 324bc28:	280f883a 	mov	r7,r5
 324bc2c:	200d883a 	mov	r6,r4
 324bc30:	41400217 	ldw	r5,8(r8)
 324bc34:	4009883a 	mov	r4,r8
 324bc38:	32082181 	jmpi	3208218 <___vfprintf_internal_r>

0324bc3c <_vsprintf_r>:
 324bc3c:	deffe804 	addi	sp,sp,-96
 324bc40:	00808204 	movi	r2,520
 324bc44:	2811883a 	mov	r8,r5
 324bc48:	02600034 	movhi	r9,32768
 324bc4c:	4a7fffc4 	addi	r9,r9,-1
 324bc50:	d880030d 	sth	r2,12(sp)
 324bc54:	d80b883a 	mov	r5,sp
 324bc58:	00bfffc4 	movi	r2,-1
 324bc5c:	dfc01715 	stw	ra,92(sp)
 324bc60:	da000415 	stw	r8,16(sp)
 324bc64:	da400515 	stw	r9,20(sp)
 324bc68:	d880038d 	sth	r2,14(sp)
 324bc6c:	da000015 	stw	r8,0(sp)
 324bc70:	da400215 	stw	r9,8(sp)
 324bc74:	32082180 	call	3208218 <___vfprintf_internal_r>
 324bc78:	d8c00017 	ldw	r3,0(sp)
 324bc7c:	18000005 	stb	zero,0(r3)
 324bc80:	dfc01717 	ldw	ra,92(sp)
 324bc84:	dec01804 	addi	sp,sp,96
 324bc88:	f800283a 	ret

0324bc8c <vsprintf>:
 324bc8c:	0080c974 	movhi	r2,805
 324bc90:	10897804 	addi	r2,r2,9696
 324bc94:	2013883a 	mov	r9,r4
 324bc98:	11000017 	ldw	r4,0(r2)
 324bc9c:	2805883a 	mov	r2,r5
 324bca0:	300f883a 	mov	r7,r6
 324bca4:	480b883a 	mov	r5,r9
 324bca8:	100d883a 	mov	r6,r2
 324bcac:	324bc3c1 	jmpi	324bc3c <_vsprintf_r>

0324bcb0 <__register_exitproc>:
 324bcb0:	defffa04 	addi	sp,sp,-24
 324bcb4:	0080c974 	movhi	r2,805
 324bcb8:	10897904 	addi	r2,r2,9700
 324bcbc:	dc000015 	stw	r16,0(sp)
 324bcc0:	14000017 	ldw	r16,0(r2)
 324bcc4:	dd000415 	stw	r20,16(sp)
 324bcc8:	2829883a 	mov	r20,r5
 324bccc:	81405217 	ldw	r5,328(r16)
 324bcd0:	dcc00315 	stw	r19,12(sp)
 324bcd4:	dc800215 	stw	r18,8(sp)
 324bcd8:	dc400115 	stw	r17,4(sp)
 324bcdc:	dfc00515 	stw	ra,20(sp)
 324bce0:	2023883a 	mov	r17,r4
 324bce4:	3027883a 	mov	r19,r6
 324bce8:	3825883a 	mov	r18,r7
 324bcec:	28002526 	beq	r5,zero,324bd84 <__register_exitproc+0xd4>
 324bcf0:	29000117 	ldw	r4,4(r5)
 324bcf4:	008007c4 	movi	r2,31
 324bcf8:	11002716 	blt	r2,r4,324bd98 <__register_exitproc+0xe8>
 324bcfc:	8800101e 	bne	r17,zero,324bd40 <__register_exitproc+0x90>
 324bd00:	2105883a 	add	r2,r4,r4
 324bd04:	1085883a 	add	r2,r2,r2
 324bd08:	20c00044 	addi	r3,r4,1
 324bd0c:	1145883a 	add	r2,r2,r5
 324bd10:	0009883a 	mov	r4,zero
 324bd14:	15000215 	stw	r20,8(r2)
 324bd18:	28c00115 	stw	r3,4(r5)
 324bd1c:	2005883a 	mov	r2,r4
 324bd20:	dfc00517 	ldw	ra,20(sp)
 324bd24:	dd000417 	ldw	r20,16(sp)
 324bd28:	dcc00317 	ldw	r19,12(sp)
 324bd2c:	dc800217 	ldw	r18,8(sp)
 324bd30:	dc400117 	ldw	r17,4(sp)
 324bd34:	dc000017 	ldw	r16,0(sp)
 324bd38:	dec00604 	addi	sp,sp,24
 324bd3c:	f800283a 	ret
 324bd40:	29802204 	addi	r6,r5,136
 324bd44:	00800044 	movi	r2,1
 324bd48:	110e983a 	sll	r7,r2,r4
 324bd4c:	30c04017 	ldw	r3,256(r6)
 324bd50:	2105883a 	add	r2,r4,r4
 324bd54:	1085883a 	add	r2,r2,r2
 324bd58:	1185883a 	add	r2,r2,r6
 324bd5c:	19c6b03a 	or	r3,r3,r7
 324bd60:	14802015 	stw	r18,128(r2)
 324bd64:	14c00015 	stw	r19,0(r2)
 324bd68:	00800084 	movi	r2,2
 324bd6c:	30c04015 	stw	r3,256(r6)
 324bd70:	88bfe31e 	bne	r17,r2,324bd00 <__register_exitproc+0x50>
 324bd74:	30804117 	ldw	r2,260(r6)
 324bd78:	11c4b03a 	or	r2,r2,r7
 324bd7c:	30804115 	stw	r2,260(r6)
 324bd80:	003fdf06 	br	324bd00 <__register_exitproc+0x50>
 324bd84:	0080c9b4 	movhi	r2,806
 324bd88:	10b4d804 	addi	r2,r2,-11424
 324bd8c:	100b883a 	mov	r5,r2
 324bd90:	80805215 	stw	r2,328(r16)
 324bd94:	003fd606 	br	324bcf0 <__register_exitproc+0x40>
 324bd98:	0080c974 	movhi	r2,805
 324bd9c:	10ae5204 	addi	r2,r2,-18104
 324bda0:	1000021e 	bne	r2,zero,324bdac <__register_exitproc+0xfc>
 324bda4:	013fffc4 	movi	r4,-1
 324bda8:	003fdc06 	br	324bd1c <__register_exitproc+0x6c>
 324bdac:	01006404 	movi	r4,400
 324bdb0:	103ee83a 	callr	r2
 324bdb4:	1007883a 	mov	r3,r2
 324bdb8:	103ffa26 	beq	r2,zero,324bda4 <__register_exitproc+0xf4>
 324bdbc:	80805217 	ldw	r2,328(r16)
 324bdc0:	180b883a 	mov	r5,r3
 324bdc4:	18000115 	stw	zero,4(r3)
 324bdc8:	18800015 	stw	r2,0(r3)
 324bdcc:	80c05215 	stw	r3,328(r16)
 324bdd0:	18006215 	stw	zero,392(r3)
 324bdd4:	18006315 	stw	zero,396(r3)
 324bdd8:	0009883a 	mov	r4,zero
 324bddc:	883fc826 	beq	r17,zero,324bd00 <__register_exitproc+0x50>
 324bde0:	003fd706 	br	324bd40 <__register_exitproc+0x90>

0324bde4 <register_fini>:
 324bde4:	f800283a 	ret

0324bde8 <__call_exitprocs>:
 324bde8:	0080c974 	movhi	r2,805
 324bdec:	10897904 	addi	r2,r2,9700
 324bdf0:	10800017 	ldw	r2,0(r2)
 324bdf4:	defff304 	addi	sp,sp,-52
 324bdf8:	df000b15 	stw	fp,44(sp)
 324bdfc:	d8800115 	stw	r2,4(sp)
 324be00:	0080c974 	movhi	r2,805
 324be04:	10ae4d04 	addi	r2,r2,-18124
 324be08:	1005003a 	cmpeq	r2,r2,zero
 324be0c:	d8800215 	stw	r2,8(sp)
 324be10:	d8800117 	ldw	r2,4(sp)
 324be14:	dd400815 	stw	r21,32(sp)
 324be18:	dd000715 	stw	r20,28(sp)
 324be1c:	10805204 	addi	r2,r2,328
 324be20:	dfc00c15 	stw	ra,48(sp)
 324be24:	ddc00a15 	stw	r23,40(sp)
 324be28:	dd800915 	stw	r22,36(sp)
 324be2c:	dcc00615 	stw	r19,24(sp)
 324be30:	dc800515 	stw	r18,20(sp)
 324be34:	dc400415 	stw	r17,16(sp)
 324be38:	dc000315 	stw	r16,12(sp)
 324be3c:	282b883a 	mov	r21,r5
 324be40:	2039883a 	mov	fp,r4
 324be44:	d8800015 	stw	r2,0(sp)
 324be48:	2829003a 	cmpeq	r20,r5,zero
 324be4c:	d8800117 	ldw	r2,4(sp)
 324be50:	14405217 	ldw	r17,328(r2)
 324be54:	88001026 	beq	r17,zero,324be98 <__call_exitprocs+0xb0>
 324be58:	ddc00017 	ldw	r23,0(sp)
 324be5c:	88800117 	ldw	r2,4(r17)
 324be60:	8c802204 	addi	r18,r17,136
 324be64:	143fffc4 	addi	r16,r2,-1
 324be68:	80000916 	blt	r16,zero,324be90 <__call_exitprocs+0xa8>
 324be6c:	05bfffc4 	movi	r22,-1
 324be70:	a000151e 	bne	r20,zero,324bec8 <__call_exitprocs+0xe0>
 324be74:	8409883a 	add	r4,r16,r16
 324be78:	2105883a 	add	r2,r4,r4
 324be7c:	1485883a 	add	r2,r2,r18
 324be80:	10c02017 	ldw	r3,128(r2)
 324be84:	a8c01126 	beq	r21,r3,324becc <__call_exitprocs+0xe4>
 324be88:	843fffc4 	addi	r16,r16,-1
 324be8c:	85bff81e 	bne	r16,r22,324be70 <__call_exitprocs+0x88>
 324be90:	d8800217 	ldw	r2,8(sp)
 324be94:	10003126 	beq	r2,zero,324bf5c <__call_exitprocs+0x174>
 324be98:	dfc00c17 	ldw	ra,48(sp)
 324be9c:	df000b17 	ldw	fp,44(sp)
 324bea0:	ddc00a17 	ldw	r23,40(sp)
 324bea4:	dd800917 	ldw	r22,36(sp)
 324bea8:	dd400817 	ldw	r21,32(sp)
 324beac:	dd000717 	ldw	r20,28(sp)
 324beb0:	dcc00617 	ldw	r19,24(sp)
 324beb4:	dc800517 	ldw	r18,20(sp)
 324beb8:	dc400417 	ldw	r17,16(sp)
 324bebc:	dc000317 	ldw	r16,12(sp)
 324bec0:	dec00d04 	addi	sp,sp,52
 324bec4:	f800283a 	ret
 324bec8:	8409883a 	add	r4,r16,r16
 324becc:	88c00117 	ldw	r3,4(r17)
 324bed0:	2105883a 	add	r2,r4,r4
 324bed4:	1445883a 	add	r2,r2,r17
 324bed8:	18ffffc4 	addi	r3,r3,-1
 324bedc:	11800217 	ldw	r6,8(r2)
 324bee0:	1c001526 	beq	r3,r16,324bf38 <__call_exitprocs+0x150>
 324bee4:	10000215 	stw	zero,8(r2)
 324bee8:	303fe726 	beq	r6,zero,324be88 <__call_exitprocs+0xa0>
 324beec:	00c00044 	movi	r3,1
 324bef0:	1c06983a 	sll	r3,r3,r16
 324bef4:	90804017 	ldw	r2,256(r18)
 324bef8:	8cc00117 	ldw	r19,4(r17)
 324befc:	1884703a 	and	r2,r3,r2
 324bf00:	10001426 	beq	r2,zero,324bf54 <__call_exitprocs+0x16c>
 324bf04:	90804117 	ldw	r2,260(r18)
 324bf08:	1884703a 	and	r2,r3,r2
 324bf0c:	10000c1e 	bne	r2,zero,324bf40 <__call_exitprocs+0x158>
 324bf10:	2105883a 	add	r2,r4,r4
 324bf14:	1485883a 	add	r2,r2,r18
 324bf18:	11400017 	ldw	r5,0(r2)
 324bf1c:	e009883a 	mov	r4,fp
 324bf20:	303ee83a 	callr	r6
 324bf24:	88800117 	ldw	r2,4(r17)
 324bf28:	98bfc81e 	bne	r19,r2,324be4c <__call_exitprocs+0x64>
 324bf2c:	b8800017 	ldw	r2,0(r23)
 324bf30:	147fd526 	beq	r2,r17,324be88 <__call_exitprocs+0xa0>
 324bf34:	003fc506 	br	324be4c <__call_exitprocs+0x64>
 324bf38:	8c000115 	stw	r16,4(r17)
 324bf3c:	003fea06 	br	324bee8 <__call_exitprocs+0x100>
 324bf40:	2105883a 	add	r2,r4,r4
 324bf44:	1485883a 	add	r2,r2,r18
 324bf48:	11000017 	ldw	r4,0(r2)
 324bf4c:	303ee83a 	callr	r6
 324bf50:	003ff406 	br	324bf24 <__call_exitprocs+0x13c>
 324bf54:	303ee83a 	callr	r6
 324bf58:	003ff206 	br	324bf24 <__call_exitprocs+0x13c>
 324bf5c:	88800117 	ldw	r2,4(r17)
 324bf60:	1000081e 	bne	r2,zero,324bf84 <__call_exitprocs+0x19c>
 324bf64:	89000017 	ldw	r4,0(r17)
 324bf68:	20000726 	beq	r4,zero,324bf88 <__call_exitprocs+0x1a0>
 324bf6c:	b9000015 	stw	r4,0(r23)
 324bf70:	8809883a 	mov	r4,r17
 324bf74:	324b9340 	call	324b934 <free>
 324bf78:	bc400017 	ldw	r17,0(r23)
 324bf7c:	883fb71e 	bne	r17,zero,324be5c <__call_exitprocs+0x74>
 324bf80:	003fc506 	br	324be98 <__call_exitprocs+0xb0>
 324bf84:	89000017 	ldw	r4,0(r17)
 324bf88:	882f883a 	mov	r23,r17
 324bf8c:	2023883a 	mov	r17,r4
 324bf90:	883fb21e 	bne	r17,zero,324be5c <__call_exitprocs+0x74>
 324bf94:	003fc006 	br	324be98 <__call_exitprocs+0xb0>

0324bf98 <alt_sim_halt>:

/*
 * Routine called on exit.
 */
static ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
 324bf98:	defffd04 	addi	sp,sp,-12
 324bf9c:	df000215 	stw	fp,8(sp)
 324bfa0:	df000204 	addi	fp,sp,8
 324bfa4:	e13fff15 	stw	r4,-4(fp)
  int r2 = exit_code;
 324bfa8:	e0bfff17 	ldw	r2,-4(fp)
 324bfac:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 324bfb0:	e0bffe17 	ldw	r2,-8(fp)
 324bfb4:	1005003a 	cmpeq	r2,r2,zero
 324bfb8:	1000021e 	bne	r2,zero,324bfc4 <alt_sim_halt+0x2c>
    ALT_SIM_FAIL();
 324bfbc:	002af070 	cmpltui	zero,zero,43969
 324bfc0:	00000106 	br	324bfc8 <alt_sim_halt+0x30>
  } else {
    ALT_SIM_PASS();
 324bfc4:	002af0b0 	cmpltui	zero,zero,43970
  }
#endif /* DEBUG_STUB */
}
 324bfc8:	e037883a 	mov	sp,fp
 324bfcc:	df000017 	ldw	fp,0(sp)
 324bfd0:	dec00104 	addi	sp,sp,4
 324bfd4:	f800283a 	ret

0324bfd8 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 324bfd8:	defffd04 	addi	sp,sp,-12
 324bfdc:	dfc00215 	stw	ra,8(sp)
 324bfe0:	df000115 	stw	fp,4(sp)
 324bfe4:	df000104 	addi	fp,sp,4
 324bfe8:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 324bfec:	0080c974 	movhi	r2,805
 324bff0:	10921b44 	addi	r2,r2,18541
 324bff4:	10000005 	stb	zero,0(r2)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
  ALT_SIM_HALT(exit_code);
 324bff8:	e13fff17 	ldw	r4,-4(fp)
 324bffc:	324bf980 	call	324bf98 <alt_sim_halt>

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 324c000:	003fff06 	br	324c000 <_exit+0x28>
 324c004:	00000010 	cmplti	zero,zero,0
 324c008:	00000000 	call	0 <OSTCBStkPtr_OFFSET>
 324c00c:	00527a01 	jmpi	527a0 <OSCtxSw_SWITCH_PC+0x52760>
 324c010:	011f7c01 	jmpi	11f7c0 <OSCtxSw_SWITCH_PC+0x11f780>
 324c014:	001b0c0b 	ldhu	zero,27696(zero)
 324c018:	00000028 	cmpgeui	zero,zero,0
 324c01c:	00000018 	cmpnei	zero,zero,0
 324c020:	03211db0 	cmpltui	r12,zero,33910
 324c024:	000005dc 	xori	zero,zero,23
 324c028:	400e4400 	call	400e440 <__alt_data_end+0xc0e440>
 324c02c:	92099170 	cmpltui	r8,r18,9797
 324c030:	95079308 	cmpgei	r20,r18,7756
 324c034:	97049605 	stb	fp,4696(r18)
 324c038:	90019f03 	ldbu	zero,1660(r18)
 324c03c:	9c06940a 	0x9c06940a
 324c040:	00000002 	0x2
 324c044:	00000028 	cmpgeui	zero,zero,0
 324c048:	00000044 	movi	zero,1
 324c04c:	0321238c 	andi	r12,zero,33934
 324c050:	000005b0 	cmpltui	zero,zero,22
 324c054:	3c0e4400 	call	3c0e440 <__alt_data_end+0x80e440>
 324c058:	92099168 	cmpgeui	r8,r18,9797
 324c05c:	95079308 	cmpgei	r20,r18,7756
 324c060:	9c039705 	stb	r16,3676(r19)
 324c064:	90019f02 	0x90019f02
 324c068:	9606940a 	0x9606940a
 324c06c:	00000004 	movi	zero,0
 324c070:	0324bde4 	muli	r12,zero,-27913
