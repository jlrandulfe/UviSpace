
SocketServer.elf:     file format elf32-littlenios2
SocketServer.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x032001c0

Program Header:
    LOAD off    0x00001000 vaddr 0x03200000 paddr 0x03200000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x03200020 paddr 0x03200020 align 2**12
         filesz 0x000509b4 memsz 0x000509b4 flags r-x
    LOAD off    0x000519d4 vaddr 0x032509d4 paddr 0x03252ad0 align 2**12
         filesz 0x000020fc memsz 0x000020fc flags rw-
    LOAD off    0x00053bcc vaddr 0x03254bcc paddr 0x03254bcc align 2**12
         filesz 0x00000000 memsz 0x00008cd0 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  03200000  03200000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   000001a0  03200020  03200020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004c1ac  032001c0  032001c0  000011c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00004668  0324c36c  0324c36c  0004d36c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000020fc  032509d4  03252ad0  000519d4  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00008cd0  03254bcc  03254bcc  00053bcc  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000026  00000000  00000000  00053ad0  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00001e98  00000000  00000000  00053af8  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 0000588c  00000000  00000000  00055990  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0008a46a  00000000  00000000  0005b21c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00014850  00000000  00000000  000e5686  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00048822  00000000  00000000  000f9ed6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00006c74  00000000  00000000  001426f8  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00003d84  00000000  00000000  0014936c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00019bfa  00000000  00000000  0014d0f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000060  00000000  00000000  00166cec  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000b48  00000000  00000000  00166d50  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000006  00000000  00000000  001725bf  2**0
                  CONTENTS, READONLY
 18 .cpu          00000003  00000000  00000000  001725c5  2**0
                  CONTENTS, READONLY
 19 .simulation_enabled 00000001  00000000  00000000  001725c8  2**0
                  CONTENTS, READONLY
 20 .sysid_hash   00000004  00000000  00000000  001725c9  2**0
                  CONTENTS, READONLY
 21 .sysid_base   00000004  00000000  00000000  001725cd  2**0
                  CONTENTS, READONLY
 22 .sysid_time   00000004  00000000  00000000  001725d1  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000009  00000000  00000000  001725d5  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000009  00000000  00000000  001725de  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000009  00000000  00000000  001725e7  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 0000000c  00000000  00000000  001725f0  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 0000000e  00000000  00000000  001725fc  2**0
                  CONTENTS, READONLY
 28 .jdi          00004495  00000000  00000000  0017260a  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
03200000 l    d  .entry	00000000 .entry
03200020 l    d  .exceptions	00000000 .exceptions
032001c0 l    d  .text	00000000 .text
0324c36c l    d  .rodata	00000000 .rodata
032509d4 l    d  .rwdata	00000000 .rwdata
03254bcc l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
03200208 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_error_handler.c
00000000 l    df *ABS*	00000000 camera.c
03254bcc l     O .bss	00000004 vga.1628
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 network_utilities.c
00000000 l    df *ABS*	00000000 simple_socket_server.c
03254bdc l     O .bss	00000004 SSSCommand.4717
03254dd8 l     O .bss	00000814 conn.5299
00000000 l    df *ABS*	00000000 trackers.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
03204684 l     F .text	0000007c udivmodsi4
00000000 l    df *ABS*	00000000 ctype_.c
0324d921 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
03204b24 l     F .text	00000058 std
03204c30 l     F .text	00000008 __fp_lock
03204c38 l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 getc.c
00000000 l    df *ABS*	00000000 impure.c
03250a14 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 perror.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 refill.c
032078d4 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 rget.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 sscanf.c
03207a94 l     F .text	00000008 eofread
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strerror.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 u_strerr.c
00000000 l    df *ABS*	00000000 vfprintf.c
032084c4 l     F .text	00000058 __sprint_r
0324e2c2 l     O .rodata	00000010 blanks.3452
0324e2b2 l     O .rodata	00000010 zeroes.3453
00000000 l    df *ABS*	00000000 vfscanf.c
0324e2da l     O .rodata	00000022 basefix.3357
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
0320bedc l     F .text	00000218 quorem
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
032529a0 l     O .rwdata	00000004 charset
0324e31c l     O .rodata	00000030 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 mprec.c
0324e464 l     O .rodata	0000000c p05.2458
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 s_isinfd.c
00000000 l    df *ABS*	00000000 s_isnand.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
0320ef78 l     F .text	00000048 match
0325123c l     O .rwdata	00000014 fpi.1950
0324e480 l     O .rodata	00000028 tinytens
03251228 l     O .rwdata	00000014 fpinan.1986
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
032113f0 l     F .text	00000024 htinit
0321147c l     F .text	000000b0 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
03211ce4 l     F .text	0000004c L_shift
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
03212da8 l     F .text	00000410 _fpadd_parts
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_fstat.c
03214a04 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
03214b24 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
03214c04 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
03214d60 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
03214e88 l     F .text	000000dc alt_file_locked
032150ec l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
032529ac l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_env_lock.c
032529b0 l     O .rwdata	00000004 lockid
03254c08 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
032529b4 l     O .rwdata	00000004 lockid
03254c10 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
03216c40 l     F .text	00000044 OS_InitMisc
03216c84 l     F .text	0000006c OS_InitRdyList
03216de8 l     F .text	000000e0 OS_InitTCBList
03216b64 l     F .text	000000dc OS_InitEventList
03216cf0 l     F .text	0000007c OS_InitTaskIdle
03216d6c l     F .text	0000007c OS_InitTaskStat
0321705c l     F .text	00000070 OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
03218f7c l     F .text	00000110 OS_FlagTaskRdy
03218cd4 l     F .text	000001c4 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
03251250 l     O .rwdata	000000d8 ext_flash
03251328 l     O .rwdata	0000106c jtag_uart
03252394 l     O .rwdata	00000124 lcd
0321d918 l     F .text	00000038 alt_dev_reg
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash.c
0321d9ec l     F .text	00000038 alt_flash_device_register
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_table.c
0321e7dc l     F .text	0000007c alt_read_16bit_query_entry
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0321f938 l     F .text	000002c8 altera_avalon_jtag_uart_irq
0321fc00 l     F .text	00000114 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207.c
03252a2c l     O .rwdata	00000004 colstart
03220418 l     F .text	000000b8 lcd_write_command
032204d0 l     F .text	000000d4 lcd_write_data
032205a4 l     F .text	000000c4 lcd_clear_screen
03220668 l     F .text	000001ec lcd_repaint_screen
03220854 l     F .text	000000c8 lcd_scroll_up
0322091c l     F .text	000002d0 lcd_handle_escape
03221124 l     F .text	000000cc alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
032213ac l     F .text	00000074 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 avalon_locator.c
00000000 l    df *ABS*	00000000 ins_eth_ocm.c
03221db0 l     F .text	000000a0 eth_ocm_pkt_send
032222c0 l     F .text	000000f4 eth_ocm_isr
032223b4 l     F .text	000001dc eth_ocm_read_init
03222004 l     F .text	000002bc eth_ocm_tx_isr
03221e50 l     F .text	000001b4 eth_ocm_low_send
03222590 l     F .text	0000035c eth_ocm_rx_isr
00000000 l    df *ABS*	00000000 alt_iniche_close.c
00000000 l    df *ABS*	00000000 alt_iniche_dev.c
00000000 l    df *ABS*	00000000 alt_iniche_read.c
00000000 l    df *ABS*	00000000 alt_iniche_write.c
00000000 l    df *ABS*	00000000 ipnet.c
00000000 l    df *ABS*	00000000 ipstart.c
03254c78 l     O .bss	00000004 nclosers
03255614 l     O .bss	0000003c closers
00000000 l    df *ABS*	00000000 igmp_cmn.c
00000000 l    df *ABS*	00000000 bsdsock.c
00000000 l    df *ABS*	00000000 cksum.c
03252a3c l     O .rwdata	00000004 cksum_select
00000000 l    df *ABS*	00000000 in_utils.c
03255650 l     O .bss	00000018 tistring
00000000 l    df *ABS*	00000000 netmain.c
00000000 l    df *ABS*	00000000 tk_crnos.c
00000000 l    df *ABS*	00000000 dhcpclnt.c
032291c0 l     F .text	000000cc dh_getlong
00000000 l    df *ABS*	00000000 dhcputil.c
00000000 l    df *ABS*	00000000 pktalloc.c
00000000 l    df *ABS*	00000000 q.c
00000000 l    df *ABS*	00000000 udp_open.c
0322aeec l       .text	00000000 done
0322ad7c l       .text	00000000 asm1
0322aea8 l       .text	00000000 loop0
0322ada4 l       .text	00000000 loop
0322aec4 l       .text	00000000 fold
00000000 l    df *ABS*	00000000 brdutils.c
03254cd8 l     O .bss	00000004 kbd_init.3791
03254ce4 l     O .bss	00000004 cpu_statusreg
00000000 l    df *ABS*	00000000 osportco.c
00000000 l    df *ABS*	00000000 targnios.c
00000000 l    df *ABS*	00000000 nptcp.c
03254d18 l     O .bss	00000004 in_tcptick
00000000 l    df *ABS*	00000000 rawsock.c
00000000 l    df *ABS*	00000000 sockcall.c
0322f5f0 l     F .text	00000098 sockargs
0322e82c l     F .text	000001fc t_getname
00000000 l    df *ABS*	00000000 socket.c
00000000 l    df *ABS*	00000000 socket2.c
00000000 l    df *ABS*	00000000 soselect.c
00000000 l    df *ABS*	00000000 tcp_in.c
00000000 l    df *ABS*	00000000 tcp_out.c
03237924 l     F .text	000000e8 bld_options
00000000 l    df *ABS*	00000000 tcp_subr.c
00000000 l    df *ABS*	00000000 tcp_timr.c
00000000 l    df *ABS*	00000000 tcp_usr.c
00000000 l    df *ABS*	00000000 tcpport.c
00000000 l    df *ABS*	00000000 udpsock.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
0323a534 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
0323a650 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0323a730 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0323ab30 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_read.c
0323af4c l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_remap_cached.c
00000000 l    df *ABS*	00000000 alt_remap_uncached.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
0323b404 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 altera_nios2_irq.c
00000040 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_amd.c
0323bd1c l     F .text	000000bc alt_write_word_amd
0323bbf8 l     F .text	00000124 alt_wait_for_command_to_complete_amd
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_intel.c
0323bfd0 l     F .text	0000018c alt_unlock_block_intel
0323c15c l     F .text	000000dc alt_write_word_intel
00000000 l    df *ABS*	00000000 eth_ocm_phy.c
03255668 l     O .bss	0000000c eth_ocm_phy_profile_array
0323c430 l     F .text	00000074 eth_ocm_wait
00000000 l    df *ABS*	00000000 eth_ocm_phy_profiles.c
0323c77c l     F .text	000000bc phy_cfg_MVL88E1111
03252738 l     O .rwdata	00000060 profile_MVL88E1111
03252798 l     O .rwdata	00000060 profile_DP83848C
00000000 l    df *ABS*	00000000 allports.c
03254d50 l     O .bss	00000004 inside_pktdemux
00000000 l    df *ABS*	00000000 timeouts.c
0323cd0c l     F .text	00000198 check_interval_timers
03254d5c l     O .bss	00000004 numtimers
00000000 l    df *ABS*	00000000 tk_misc.c
00000000 l    df *ABS*	00000000 alt_iniche_fcntl.c
00000000 l    df *ABS*	00000000 et_arp.c
03254d60 l     O .bss	00000004 arp_timer
03254d78 l     O .bss	00000004 cachetime
00000000 l    df *ABS*	00000000 iface.c
00000000 l    df *ABS*	00000000 ip.c
03252ab8 l     O .rwdata	00000004 uid
00000000 l    df *ABS*	00000000 ip_reasm.c
00000000 l    df *ABS*	00000000 ipdemux.c
00000000 l    df *ABS*	00000000 ipmc.c
00000000 l    df *ABS*	00000000 ipport.c
00000000 l    df *ABS*	00000000 ipraw.c
00000000 l    df *ABS*	00000000 iproute.c
00000000 l    df *ABS*	00000000 udp.c
03254da8 l     O .bss	00000002 usocket
00000000 l    df *ABS*	00000000 igmp.c
00000000 l    df *ABS*	00000000 igmp2.c
00000000 l    df *ABS*	00000000 ipopt.c
00000000 l    df *ABS*	00000000 u_mctest.c
03252ac0 l     O .rwdata	00000004 iCounter.4549
00000000 l    df *ABS*	00000000 dhcsetup.c
00000000 l    df *ABS*	00000000 memdev.c
00000000 l    df *ABS*	00000000 parseip.c
03255674 l     O .bss	0000001e nearBuf.4227
00000000 l    df *ABS*	00000000 tcpcksum.c
00000000 l    df *ABS*	00000000 in_pcb.c
00000000 l    df *ABS*	00000000 vfsfiles.c
00000000 l    df *ABS*	00000000 vfsport.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_fcntl.c
0324a81c l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 icmp.c
03252970 l     O .rwdata	00000018 dsts
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 calloc.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 vprintf.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0324c148 l     F .text	00000004 register_fini
00000000 l    df *ABS*	00000000 alt_exit.c
0324c2fc l     F .text	00000040 alt_sim_halt
03207044 g     F .text	0000001c putchar
0325d208 g     O .bss	00000014 soq
0320e124 g     F .text	00000094 _mprec_log10
03252a02 g     O .rwdata	00000002 OSTaskNameSize
0320e210 g     F .text	00000088 __any_on
0320da40 g     F .text	00000070 _isatty_r
0324e43c g     O .rodata	00000028 __mprec_tinytens
0323ebf4 g     F .text	00000780 ip_write_internal
03214dc0 g     F .text	000000c8 alt_main
0324bd34 g     F .text	0000008c strcpy
0322a640 g     F .text	000000ac pk_free
03207068 g     F .text	000000a0 _puts_r
0321e29c g     F .text	00000048 alt_read_query_entry_32bit
0325d5a4 g     O .bss	00000100 alt_irq
0323c4a4 g     F .text	000002d8 eth_ocm_phy_init
03252810 g     O .rwdata	00000009 rtp_priority
0320dba0 g     F .text	00000078 _lseek_r
0324b890 g     F .text	00000334 icmp_timex
0322bfcc g     F .text	00000044 m_freem
0324a034 g     F .text	00000048 vgetc
0322b068 g     F .text	0000001c clock_c
03254d30 g     O .bss	00000004 tcp_optionbuf
0323e6bc g     F .text	00000084 if_getbynum
03219870 g     F .text	000000d0 OS_MemInit
03254cd0 g     O .bss	00000004 dsc_rlyerrs
03254cc0 g     O .bss	00000004 dsc_releases
0321da24 g     F .text	000002c0 alt_flash_cfi_write
03226d68 g     F .text	00000074 TK_OSTaskQuery
0322ad5c g       .text	00000000 asm_cksum
03252ad0 g       *ABS*	00000000 __flash_rwdata_start
0321d7b0 g     F .text	00000064 OSTimeSet
03249f14 g     F .text	00000120 vgetc_locked
0322b8a8 g     F .text	00000020 post_task_setup
032425ec g     F .text	00000354 ipr_stats
03239290 g     F .text	00000134 tcp_attach
03252a4c g     O .rwdata	00000004 reqlist_len
0322d478 g     F .text	00000084 tcp_tick
03225fb4 g     F .text	00000074 print_ipad
03226c64 g     F .text	00000104 tcp_wakeup
0320d6a8 g     F .text	000000a0 __sflags
032138c8 g     F .text	00000088 __eqdf2
03254bd4 g     O .bss	00000004 last_flash_sector_offset
03254c7c g     O .bss	00000004 igmp_timers_are_running
032361b0 g     F .text	0000012c tcp_pulloutofband
032157bc g     F .text	000006b4 OSEventPendMulti
0325d89c g       *ABS*	00000000 __alt_heap_start
0323b864 g     F .text	00000020 OSTaskCreateHook
03229e2c g     F .text	00000074 dhc_ifacedone
03242994 g     F .text	00000400 ip_rcv
03249c64 g     F .text	0000017c vfseek
03232010 g     F .text	00000120 soqremque
03255694 g     O .bss	00002000 task1_stk
032447e4 g     F .text	00000858 udpdemux
03206de0 g     F .text	00000044 printf
03254d7c g     O .bss	00000004 rt_mib
032529da g     O .rwdata	00000002 OSMboxEn
03229d3c g     F .text	00000060 dhc_state_init
0324bff0 g     F .text	00000024 vsprintf
03215ec4 g     F .text	0000007c OSIntEnter
03200000 g       *ABS*	00000000 __alt_mem_sram
03207bb0 g     F .text	00000068 __sseek
03204b8c g     F .text	000000a4 __sinit
03243938 g     F .text	00000118 in_delmulti
0320bb6c g     F .text	00000130 __swbuf_r
03254d94 g     O .bss	00000004 so_evtmap_create
032529ea g     O .rwdata	00000002 OSQEn
032481e4 g     F .text	00000094 in_pcballoc
03252a68 g     O .rwdata	00000002 socket_defaults
0320db00 g     F .text	00000084 _setlocale_r
0323d4e8 g     F .text	00000498 send_arp
03204c8c g     F .text	00000068 __sfmoreglue
03248cd0 g     F .text	00000368 vfopen_locked
03211320 g     F .text	0000001c ungetc
03215478 g     F .text	000000d0 __malloc_unlock
0323b8c0 g     F .text	0000001c OSTaskStatHook
0323cbf0 g     F .text	00000058 prep_modules
032254ec g     F .text	000001b8 bsd_i_sockoptlen
03254c18 g     O .bss	00000001 OSLockNesting
03252a44 g     O .rwdata	00000004 xids
0320efc0 g     F .text	000014e4 _strtod_r
03207dd4 g     F .text	00000674 strerror
03249230 g     F .text	00000040 vfclose
0325d2a8 g     O .bss	0000002c tcb
03252a28 g     O .rwdata	00000002 OSDataSize
0323afac g     F .text	00000038 alt_remap_cached
03254c19 g     O .bss	00000001 OSRunning
0323e3f0 g     F .text	000002cc grat_arp
032018fc g     F .text	000001e0 get_ip_addr
03247bfc g     F .text	000000ac inet_pton
0323e820 g     F .text	0000009c reg_type
0325cdac g     O .bss	000000f0 dhc_states
032242f4 g     F .text	0000019c igmp_fasttimo
032493f4 g     F .text	0000005c vunlink_flag_open_files
03229ae4 g     F .text	00000088 dhc_halt
03254cb4 g     O .bss	00000004 dsc_acks
0325d2d4 g     O .bss	000000e0 tcpstat
03241e9c g     F .text	0000035c ip_reasm_copy_queued_fragments_into_reassy_buffer
0322c55c g     F .text	000000a8 dtom
03237828 g     F .text	000000fc tcp_setpersist
0322ec04 g     F .text	000001a4 t_getsockopt
03206b70 g     F .text	000000e0 memmove
03254cc4 g     O .bss	00000004 dsc_naks
0322ca00 g     F .text	000005f8 ip_output
0323b904 g     F .text	0000001c OSInitHookBegin
0324bbc4 g     F .text	00000054 icmp_du
03252a40 g     O .rwdata	00000004 num_net_tasks
03254db8 g     O .bss	00000004 vfiles
03252a20 g     O .rwdata	00000002 OSTmrSize
032472f8 g     F .text	00000104 dhc_main_ipset
03204c7c g     F .text	00000010 _cleanup
03240f94 g     F .text	000002e0 ip_reasm_process_first_fragment
0320e298 g     F .text	000000bc _Balloc
03201fc0 g     F .text	0000027c get_board_mac_addr
03254c1c g     O .bss	00000004 OSIdleCtr
03246210 g     F .text	000005f0 ip_setmoptions
032139d8 g     F .text	00000088 __gtdf2
032476bc g     F .text	0000002c md_fseek
0323b530 g       .text	00000000 OSStartTsk
00000000  w      *UND*	00000000 __errno
03217390 g     F .text	000002e0 OS_TCBInit
03241274 g     F .text	000000a0 ip_reassm
03229b6c g     F .text	000001d0 dhc_reclaim
0321e428 g     F .text	00000048 alt_write_flash_command_32bit_device_16bit_mode
0325d594 g     O .bss	00000010 udp_mib
03200000 g     F .entry	0000001c __reset
0322f43c g     F .text	000000e4 t_shutdown
03203870 g     F .text	000001ec sss_handle_receive
0322ee98 g     F .text	00000150 t_recvfrom
03252a26 g     O .rwdata	00000002 OSTmrWheelTblSize
032469f4 g     F .text	0000067c u_mctest_run
03243ac0 g     F .text	00000094 prep_ifaces
03200020 g       *ABS*	00000000 __flash_exceptions_start
03254c98 g     O .bss	00000001 to_netmain
0322a2ac g     F .text	000000dc pk_alloc
032529c6 g     O .rwdata	00000002 OSEventSize
03200ac8 g     F .text	000002ec alt_SSSErrorHandler
03254c20 g     O .bss	00000001 OSPrioHighRdy
03205884 g     F .text	00000074 _fstat_r
032269dc g     F .text	0000004c tk_nettick
0323b884 g     F .text	00000020 OSTaskDelHook
0321df40 g     F .text	000002d8 alt_flash_program_block
03254be0 g     O .bss	00000004 errno
0320793c g     F .text	00000014 __srget
03222a58 g     F .text	000000e8 eth_ocm_close
0323333c g     F .text	000000cc in_pcbnotify
0320ba6c g     F .text	00000024 __svfscanf
0323b510 g       .text	00000000 OSStartHighRdy
0325ce9c g     O .bss	00000014 lilfreeq
0320020c g     F .text	00000624 alt_uCOSIIErrorHandler
03243b7c g     F .text	00000028 evtmap_setup
0321bf84 g     F .text	00000200 OSTaskCreateExt
03254c9c g     O .bss	00000004 tcp_sleep_timeout
03232a3c g     F .text	000001d0 sbdrop
03254d90 g     O .bss	00000004 net_system_exit
0325d6a4 g     O .bss	00000068 icmp_mib
0323837c g     F .text	00000078 tcp_getseq
03243f8c g     F .text	000000cc ip_raw_alloc
032187f0 g     F .text	00000068 OSFlagPendGetFlagsRdy
03252a06 g     O .rwdata	00000002 OSTaskStatStkSize
03228208 g     F .text	00000b3c dhc_request
032306c8 g     F .text	000007e4 soreceive
032141c0 g     F .text	0000002c __make_fp
032177fc g     F .text	00000334 OSFlagAccept
03219fa8 g     F .text	000000c8 OSQFlush
03219940 g     F .text	00000154 OSQAccept
03254c00 g     O .bss	00000004 alt_argv
0325a988 g       *ABS*	00000000 _gp
03242940 g     F .text	00000054 ip_reasm_send_icmp_timex
0323b1cc g     F .text	00000118 usleep
03249270 g     F .text	00000048 vfflush
0325d1b0 g     O .bss	00000040 resid_semaphore
03225e6c g     F .text	00000148 hexdump
03240e4c g     F .text	000000a8 ip_reasm_incr_mem_useage
0322b900 g     F .text	00000034 calloc2
032249a4 g     F .text	0000007c igmp_leavegroup
0321bdb0 g     F .text	000001d4 OSTaskCreate
03201088 g     F .text	00000058 set_image_size
0321b83c g     F .text	00000574 OSTaskChangePrio
03254c14 g     O .bss	00000004 alt_heapsem
032381c8 g     F .text	000000e8 tcp_close
03217670 g     F .text	0000018c OSDebugInit
0321c184 g     F .text	0000040c OSTaskDel
0324a490 g     F .text	0000006c vferror
032454f4 g     F .text	000000c0 udp_alloc
032525b8 g     O .rwdata	00000180 alt_fd_list
032597dc g     O .bss	00000370 OSFlagTbl
03254d1c g     O .bss	00000008 mbstat
03206088 g     F .text	00000090 _getc_r
03205ff0 g     F .text	00000098 getc
03207060 g     F .text	00000008 _putchar_r
03216940 g     F .text	000000b8 OS_EventTaskRemove
03245e00 g     F .text	00000158 igmpv2_chk_set_timer
03226a28 g     F .text	0000002c TK_OSTimeDly
03259694 g     O .bss	00000048 trackers
0323a858 g     F .text	00000094 alt_find_dev
03206ad0 g     F .text	000000a0 memcpy
03254ccc g     O .bss	00000004 dsc_rebind
03211d30 g     F .text	00000248 __hexnan
0323d0ec g     F .text	00000080 task_stats
0322df28 g     F .text	0000004c DOMAIN_CHECK
0322cff8 g     F .text	00000040 in_broadcast
032529f0 g     O .rwdata	00000002 OSRdyTblSize
032010e0 g     F .text	00000050 get_image_exposure
03254db4 g     O .bss	00000004 vfsystems
03245424 g     F .text	000000d0 udp_socket
03254c6c g     O .bss	00000004 MaxMtu
03232fd0 g     F .text	00000158 sock_selscan
03204c70 g     F .text	0000000c _cleanup_r
03213bf8 g     F .text	000000f8 __floatsidf
03240bf8 g     F .text	000000d0 ip_reasm_match_frag_with_ire
03232180 g     F .text	00000050 socantrcvmore
032026c0 g     F .text	000010f0 sss_exec_command
03206dcc g     F .text	00000014 perror
0323abf4 g     F .text	00000078 alt_io_redirect
03213ae8 g     F .text	00000088 __ltdf2
03254cf8 g     O .bss	00000004 netq_intmask
03247b8c g     F .text	00000070 hextoa
0324c36c g       *ABS*	00000000 __DTOR_END__
0322f214 g     F .text	00000228 t_send
0323a438 g     F .text	000000fc alt_close
03254d24 g     O .bss	00000002 select_wait
03207108 g     F .text	00000014 puts
03226500 g     F .text	00000044 std_out
0324a07c g     F .text	00000138 vfslookup_locked
0322feb0 g     F .text	0000009c soaccept
03215548 g     F .text	00000130 OSEventNameGet
032529d4 g     O .rwdata	00000002 OSFlagMax
0320dc98 g     F .text	00000040 mbrtowc
0323b464 g     F .text	00000020 altera_nios2_irq_init
0325d21c g     O .bss	0000003c tcpmib
0322f688 g     F .text	0000009c t_errno
03243ba4 g     F .text	000000f0 ip_raw_open
0320ba90 g     F .text	00000068 _vfscanf_r
032290a8 g     F .text	00000118 dhc_decline
0320e074 g     F .text	000000b0 __ratio
03215f40 g     F .text	00000100 OSIntExit
03252abc g     O .rwdata	00000004 ipRoutes
0324939c g     F .text	00000058 vfeof
03238694 g     F .text	0000005c tcp_canceltimers
032279d0 g     F .text	0000021c dhc_buildheader
03252a0e g     O .rwdata	00000002 OSTCBSize
03254c21 g     O .bss	00000001 OSPrioCur
0321fe7c g     F .text	000002c0 altera_avalon_jtag_uart_read
0324bcac g     F .text	00000014 malloc
03254db0 g     O .bss	00000004 inpcb_cachemiss
03206e24 g     F .text	00000034 _printf_r
03247d94 g     F .text	000000c4 inet46_addr
03254dac g     O .bss	00000004 inpcb_cachehits
032047c0 g     F .text	00000008 __udivsi3
03252578 g     O .rwdata	0000000b tcp_outflags
03214a64 g     F .text	000000c0 isatty
032529f4 g     O .rwdata	00000002 OSStkWidth
0320dab0 g     F .text	0000002c iswspace
0324e34c g     O .rodata	000000c8 __mprec_tens
03248b2c g     F .text	0000007c vf_alloc_and_link_vop
032529e8 g     O .rwdata	00000002 OSPtrSize
03254d80 g     O .bss	00000004 ipr_curr_mem
03223f80 g     F .text	0000006c exit_hook
032217b0 g     F .text	000000b0 get_search_window
03254c80 g     O .bss	00000004 igmp_cticks
03254d0c g     O .bss	00000004 mheap_sem_ptr
03236548 g     F .text	00000048 ip4_tcpmss
0320dadc g     F .text	00000008 __locale_charset
032529c8 g     O .rwdata	00000002 OSEventTblSize
0325d518 g     O .bss	00000014 netlist
03230eac g     F .text	000000a8 soshutdown
03212010 g     F .text	000000a4 __fixunsdfsi
032014e8 g     F .text	00000100 select_vga_output
0323b484 g       .text	00000000 OSCtxSw
0323cb80 g     F .text	0000004c packet_check
03228d44 g     F .text	00000280 dhc_setip
0324a87c g     F .text	00000090 alt_icache_flush
0325d258 g     O .bss	00000014 mbufq
0322fe60 g     F .text	00000050 soabort
03254be4 g     O .bss	00000004 __malloc_top_pad
03254c24 g     O .bss	00000004 OSTCBList
0322a930 g     F .text	00000110 qdel
032214e8 g     F .text	000001c4 get_current_corners
0323c9f8 g     F .text	0000014c station_state
032440f4 g     F .text	00000184 rt_lookup
03254d3c g     O .bss	00000004 alt_fd_list_lock
03210d94 g     F .text	00000024 strtoul
0325299c g     O .rwdata	00000004 __mb_cur_max
03224a20 g     F .text	0000035c igmp_validate
0320dae4 g     F .text	0000000c _localeconv_r
03223c9c g     F .text	000002e4 ip_startup
03210db8 g     F .text	000002f0 _strtoull_r
0322e264 g     F .text	00000298 t_accept
03231c00 g     F .text	0000008c soisdisconnecting
0320e990 g     F .text	0000003c __i2b
032058f8 g     F .text	0000049c __sfvwrite_r
03223654 g     F .text	000003d4 pktdemux
03259b4c g     O .bss	00000c30 OSMemTbl
03254c28 g     O .bss	00000001 OSTickStepState
0322af20 g     F .text	000000ac kbhit
0322ea28 g     F .text	000001dc t_setsockopt
03207950 g     F .text	00000070 _sbrk_r
0323bdd8 g     F .text	00000084 alt_program_intel
032527f8 g     O .rwdata	00000018 icmpdu_types
03249450 g     F .text	00000220 vunlink
032529ec g     O .rwdata	00000002 OSQMax
03225cac g     F .text	000000b0 ccksum
03248ba8 g     F .text	000000d8 vf_alloc_buffer
03254da4 g     O .bss	00000004 cachedRoute
03252a50 g     O .rwdata	00000004 lilbufs
0325a77c g     O .bss	00000800 OSTaskStatStk
032476e8 g     F .text	00000024 md_ftell
03225d5c g     F .text	00000068 cksum
03219458 g     F .text	0000010c OSMemNameGet
0322fa3c g     F .text	00000130 sofree
03254c74 g     O .bss	00000004 ifNumber
032529cc g     O .rwdata	00000002 OSFlagEn
0320ed0c g     F .text	00000078 _read_r
032214a8 g     F .text	00000040 locator_init
03252a12 g     O .rwdata	00000002 OSTimeTickHookEn
0323a594 g     F .text	00000078 alt_dcache_flush
0321a50c g     F .text	00000180 OSQPost
0321908c g     F .text	000000ac OS_FlagUnlink
0325121c g     O .rwdata	0000000c __lc_ctype
03252a90 g     O .rwdata	00000004 alt_max_fd
0321e218 g     F .text	00000040 alt_read_query_entry_8bit
03216f1c g     F .text	0000006c OS_MemCopy
03252a58 g     O .rwdata	00000004 bigbufs
032393c4 g     F .text	000000d4 tcp_disconnect
03216f88 g     F .text	000000d4 OS_Sched
03214500 g     F .text	00000138 __unpack_d
032047d0 g     F .text	00000110 _fclose_r
03219354 g     F .text	00000104 OSMemGet
03204224 g     F .text	000000b4 get_search_window_of_tracker
0321c8b8 g     F .text	000001c4 OSTaskNameSet
0323be5c g     F .text	00000174 alt_erase_block_intel
03204af0 g     F .text	00000034 fflush
03254be8 g     O .bss	00000004 __malloc_max_sbrked_mem
03254c2c g     O .bss	00000004 OSCtxSwCtr
0325cd24 g     O .bss	00000064 igmpstats
032015e8 g     F .text	00000060 write_in_lcd
0323b8dc g     F .text	00000028 OSTimeTickHook
03228104 g     F .text	00000104 dhc_rx_offer
032256a4 g     F .text	00000120 bsd_getsockopt
0323ac6c g     F .text	000001c0 alt_irq_register
032529d6 g     O .rwdata	00000002 OSFlagNameSize
0325d57c g     O .bss	00000018 ire_stats
03239634 g     F .text	000001b8 udp_soinput
0322a880 g     F .text	000000b0 putq
032169f8 g     F .text	00000104 OS_EventTaskRemoveMulti
03254c94 g     O .bss	00000004 iniche_net_ready
03213238 g     F .text	00000074 __adddf3
03212c40 g     F .text	00000078 __nesf2
032167ec g     F .text	00000154 OS_EventTaskWaitMulti
0324a448 g     F .text	00000048 isvfile
03231054 g     F .text	000004c0 sosetopt
03226860 g     F .text	000000f4 netmain
03236590 g     F .text	0000011c tcp_mss
0320df54 g     F .text	00000120 __b2d
03247808 g     F .text	0000031c parse_ipad
03248b0c g     F .text	00000020 get_vfopen_error
032529ee g     O .rwdata	00000002 OSQSize
03212690 g     F .text	000005b0 __umoddi3
03214c70 g     F .text	000000f0 lseek
0323cc48 g     F .text	000000c4 inet_timer
0321b0e8 g     F .text	0000027c OSSemPend
032023f0 g     F .text	000002d0 sss_send_menu
03252990 g     O .rwdata	00000004 _global_impure_ptr
03226198 g     F .text	00000164 print_eth
03249038 g     F .text	00000050 vfopen
0323ae2c g     F .text	00000120 alt_read
0320711c g     F .text	000005f4 _realloc_r
03200830 g     F .text	00000298 alt_NetworkErrorHandler
032529d8 g     O .rwdata	00000002 OSLowestPrio
0325d89c g       *ABS*	00000000 __bss_end
0322be98 g     F .text	00000134 m_free
0323b958 g     F .text	00000020 OSTCBInitHook
0322a388 g     F .text	000002b8 pk_validate
03252a1e g     O .rwdata	00000002 OSTmrCfgTicksPerSec
0323b0bc g     F .text	00000110 alt_tick
03248888 g     F .text	0000025c in_pcblookup
03229f50 g     F .text	000000cc find_opt
032596dc g     O .bss	00000100 __hexdig
032120b4 g     F .text	000005dc __udivdi3
0322bcf0 g     F .text	000001a8 m_getnbuf
0322a70c g     F .text	000000ac dump_buf_estats
03254d74 g     O .bss	00000004 arpRepsOut
032529c0 g     O .rwdata	00000002 OSEventEn
0324e414 g     O .rodata	00000028 __mprec_bigtens
0320ebec g     F .text	00000120 __s2b
03252a1a g     O .rwdata	00000002 OSTmrCfgNameSize
03213e3c g     F .text	00000194 __floatunsidf
0323c874 g     F .text	000000fc netmain_init
0320de74 g     F .text	00000060 __mcmp
03254cb0 g     O .bss	00000004 dsc_requests
03237b7c g     F .text	00000488 tcp_respond
03239a70 g     F .text	0000033c udp4_sockbind
03252988 g     O .rwdata	00000004 __ctype_ptr
03254cfc g     O .bss	00000004 old_mode
03224738 g     F .text	0000026c igmp_joingroup
0322d120 g     F .text	00000358 so_icmpdu
03204c58 g     F .text	00000018 __fp_lock_all
03254dc4 g     O .bss	00000004 vfs_dir_stale
032421f8 g     F .text	000000e4 ip_reasm_process_timer_tick
0324a4fc g     F .text	0000005c vclearerr
03225bc0 g     F .text	000000ec bsd_setsockopt
0322c504 g     F .text	00000058 mbuf_len
03218e98 g     F .text	000000e4 OS_FlagInit
0323b024 g     F .text	00000098 alt_alarm_stop
0324a1fc g     F .text	000001e8 strippath
03252a48 g     O .rwdata	00000004 reqlist
03226ac4 g     F .text	000001a0 tcp_sleep
03210828 g     F .text	00000024 strtol
032271a0 g     F .text	00000830 dhc_upcall
03239498 g     F .text	000000e0 tcp_usrclosed
03254ce8 g     O .bss	00000004 cticks_factor
032529fc g     O .rwdata	00000002 OSTaskIdleStkSize
032482cc g     F .text	00000254 in_pcbbind
0320438c g     F .text	0000017c get_current_windows_of_activated_trackers
03254d40 g     O .bss	00000004 alt_irq_active
0321ac74 g     F .text	000000c0 OSSemAccept
03219684 g     F .text	000000f0 OSMemPut
03219138 g     F .text	0000021c OSMemCreate
03254c30 g     O .bss	00000004 OSIdleCtrMax
032000ec g     F .exceptions	000000d4 alt_irq_handler
03252590 g     O .rwdata	00000028 alt_dev_null
032509d4 g     O .rwdata	00000028 camera
03252a6a g     O .rwdata	00000001 tcprexmtthresh
03252a10 g     O .rwdata	00000002 OSTicksPerSec
0323e8bc g     F .text	00000098 if_killsocks
0323f374 g     F .text	00000248 ip_write
03242d94 g     F .text	0000060c ip_rcv_phase2
0322e7e8 g     F .text	00000044 t_getsockname
0322e4fc g     F .text	000002a8 t_connect
03221a1c g     F .text	00000394 eth_ocm_init
03252a64 g     O .rwdata	00000004 TCPTV_MSL
0325ceb0 g     O .bss	00000010 memestats
0322afcc g     F .text	00000060 getch
03214050 g     F .text	000000c8 __unpack_f
0321e730 g     F .text	000000ac alt_set_flash_algorithm_func
032528f0 g     O .rwdata	00000080 vfs_root_path
0322e7a4 g     F .text	00000044 t_getpeername
03240ef4 g     F .text	000000a0 ip_reasm_decr_mem_useage
0323230c g     F .text	00000080 soreserve
0323b484 g       .text	00000000 OSIntCtxSw
0322b934 g     F .text	000000f4 npalloc
0323a60c g     F .text	00000044 alt_dcache_flush_all
0320dd40 g     F .text	00000070 __hi0bits
03254da0 g     O .bss	00000004 ipraw_eps
0322a01c g     F .text	00000290 pk_init
032474bc g     F .text	00000180 md_fread
0324bc44 g     F .text	0000001c calloc
03213cf0 g     F .text	000000d8 __fixdfsi
0325d3b4 g     O .bss	00000064 intimers
032323ec g     F .text	00000048 sbrelease
03233470 g     F .text	000000f0 ifd_clr
03232d1c g     F .text	00000094 sbdroprecord
032262fc g     F .text	00000080 uslash
0323b2e4 g     F .text	00000120 alt_write
0321e2e4 g     F .text	0000003c alt_write_flash_command_8bit_device_8bit_mode
03254d70 g     O .bss	00000004 arpRepsIn
03227010 g     F .text	00000090 dhc_get_srv_ipaddr
0323cea4 g     F .text	0000017c in_timerset
032105c8 g     F .text	0000001c strtod
03254c34 g     O .bss	00000004 OSTCBFreeList
03252ad0 g       *ABS*	00000000 __ram_rwdata_end
0321b364 g     F .text	0000017c OSSemPendAbort
032366ac g     F .text	0000117c tcp_output
03254d4c g     O .bss	00000004 activehost
03252a88 g     O .rwdata	00000008 alt_dev_list
03226634 g     F .text	0000022c parse_args
03254d00 g     O .bss	00000004 global_TCPwakeup_setIndx
0320d7ac g     F .text	00000058 _fputc_r
03222d50 g     F .text	00000070 write
0322ba28 g     F .text	000000b8 npfree
03206f5c g     F .text	000000e8 _putc_r
0323dc3c g     F .text	00000294 arpReply
03225df0 g     F .text	0000007c nextarg
03252a14 g     O .rwdata	00000002 OSVersionNbr
032418a4 g     F .text	00000594 ip_reasm_process_subsequent_fragments
03252ac8 g     O .rwdata	00000004 pton_error
03254ca4 g     O .bss	00000004 dsc_errors
03212cb8 g     F .text	00000078 __gtsf2
03257694 g     O .bss	00002000 SSSInitialTaskStk
0325ca00 g     O .bss	00000014 rcvdq
03233408 g     F .text	00000068 tcp_notify
032509d4 g       *ABS*	00000000 __ram_rodata_end
03214930 g     F .text	000000d4 fstat
03204ef4 g     F .text	0000002c fprintf
0322ff4c g     F .text	000000d4 soconnect
03244098 g     F .text	0000005c ip_raw_maxalloc
03213b70 g     F .text	00000088 __ledf2
03227bec g     F .text	00000518 dhc_discover
0321f5e4 g     F .text	000000dc alt_check_primary_table
0324880c g     F .text	0000007c in_setpeeraddr
032529bc g     O .rwdata	00000004 OSEndiannessTest
0322b02c g     F .text	0000003c clock_init
032492b8 g     F .text	000000e4 vfgets
0323d270 g     F .text	0000017c et_send
0320eacc g     F .text	00000120 __pow5mult
03254bf0 g     O .bss	00000004 __nlocale_changed
032047c8 g     F .text	00000008 __umodsi3
0321dd74 g     F .text	00000068 alt_flash_cfi_read
0321e4b8 g     F .text	00000034 alt_write_native_8bit
03247b24 g     F .text	00000068 inet_addr
03240db4 g     F .text	00000098 ip_reasm_check_mem_useage
03230f54 g     F .text	00000100 sorflush
0324bf80 g     F .text	00000020 vprintf
0325cfc4 g     O .bss	000000fc global_tcb_ext
0323fa44 g     F .text	00000488 ip_fragment_lc
0325ca14 g     O .bss	00000300 netstatic
0322e004 g     F .text	0000017c t_bind
03201440 g     F .text	000000a8 select_sensor_output
032529ce g     O .rwdata	00000002 OSFlagGrpSize
0322ac78 g     F .text	000000e4 udp_close
0322b618 g     F .text	0000021c alt_iniche_init
0323c2a8 g     F .text	00000074 eth_ocm_write_phy_reg
0325d89c g       *ABS*	00000000 end
0322b250 g     F .text	00000088 UNLOCK_NET_RESOURCE
0322eda8 g     F .text	000000f0 t_recv
03214700 g     F .text	00000160 __pack_f
0321e320 g     F .text	0000007c alt_write_flash_command_16bit_device_8bit_mode
03220bec g     F .text	00000538 altera_avalon_lcd_16207_write
03249670 g     F .text	000001ac vfread
0322356c g     F .text	000000e8 netclose
03203a5c g     F .text	000001ac SSSSimpleSocketServerTask
0324bc2c g     F .text	0000000c _atoi_r
03205860 g     F .text	00000024 fseek
0321e858 g     F .text	000005e0 alt_read_cfi_table
03252a74 g     O .rwdata	00000004 tcp_keepintvl
0321f808 g     F .text	00000130 altera_avalon_jtag_uart_init
03217200 g     F .text	000000c8 OS_TaskStat
03254ca8 g     O .bss	00000004 dsc_discovers
03252530 g     O .rwdata	00000018 tcp_protosw
0324c368 g       *ABS*	00000000 __CTOR_LIST__
03254dc0 g     O .bss	00000004 vfopen_error
03400000 g       *ABS*	00000000 __alt_stack_pointer
03254d34 g     O .bss	00000004 tcp_maxidle
03254cd4 g     O .bss	00000004 firstudp
03221420 g     F .text	00000088 alt_avalon_timer_sc_init
03213fd0 g     F .text	00000080 __clzsi2
03204508 g     F .text	0000017c get_current_corners_of_activated_trackers
0322013c g     F .text	000002dc altera_avalon_jtag_uart_write
0321d950 g     F .text	0000009c alt_flash_cfi_init
03204b7c g     F .text	00000004 __sfp_lock_acquire
032069ec g     F .text	000000e4 memchr
03216ec8 g     F .text	00000054 OS_MemClr
0320851c g     F .text	00001eac ___vfprintf_internal_r
0323b554 g     F .text	00000310 OSTaskStkInit
03201648 g     F .text	00000088 task1
03207a34 g     F .text	00000060 _sprintf_r
03205110 g     F .text	00000314 _free_r
03245f58 g     F .text	00000170 igmpv2_chk4_rtr_alert_opt
03200f14 g     F .text	0000011c write_camera_registers
0322f520 g     F .text	000000d0 t_socketclose
03216548 g     F .text	00000194 OS_EventTaskRdy
0324c14c g     F .text	000001b0 __call_exitprocs
032078f0 g     F .text	0000004c __srget_r
03203cc0 g     F .text	000000a0 trackers_free
03254c38 g     O .bss	00000001 OSCPUUsage
0325cd14 g     O .bss	00000010 nets
0322b190 g     F .text	000000c0 LOCK_NET_RESOURCE
03228fc4 g     F .text	000000e4 dhc_resetip
03254bf4 g     O .bss	00000004 __mlocale_changed
0322df74 g     F .text	00000090 t_socket
03252998 g     O .rwdata	00000004 __malloc_sbrk_base
032001c0 g     F .text	0000004c _start
0323d21c g     F .text	00000054 etainit
03254d44 g     O .bss	00000004 _alt_tick_rate
0323cbcc g     F .text	00000024 mcastlist
0321a070 g     F .text	00000320 OSQPend
032042d8 g     F .text	000000b4 get_current_corners_of_tracker
0325cec0 g     O .bss	000000f0 pktlog
0321084c g     F .text	00000318 _strtoll_r
03245a68 g     F .text	0000014c igmpv2_process_report
032335d4 g     F .text	00000080 ifd_isset
032446a0 g     F .text	00000144 del_route
032084bc g     F .text	00000008 _user_strerror
0321d27c g     F .text	0000014c OSTimeDly
032228ec g     F .text	0000016c eth_ocm_stats
0323c238 g     F .text	00000070 eth_ocm_set_phy_addr
032017fc g     F .text	00000100 get_mac_addr
0322f94c g     F .text	000000f0 solisten
0320e65c g     F .text	0000014c __lshift
03254d48 g     O .bss	00000004 _alt_nticks
03201330 g     F .text	00000058 set_sensor_mode
03222cd8 g     F .text	00000078 read
0321d848 g     F .text	000000d0 alt_sys_init
032382b0 g     F .text	0000004c tcp_quench
0322637c g     F .text	00000184 ns_printf
03206ce8 g     F .text	00000078 _open_r
0323e740 g     F .text	000000e0 isbcast
0322b2d8 g     F .text	00000214 TK_NEWTASK
0324c014 g     F .text	00000134 __register_exitproc
03254c39 g     O .bss	00000001 OSTaskCtr
03240cc8 g     F .text	000000ec ip_reasm_determine_type_of_frag
0324bdc0 g     F .text	000000f0 strncmp
03201130 g     F .text	00000048 set_image_exposure
0321e258 g     F .text	00000044 alt_read_query_entry_16bit
0321d3c8 g     F .text	00000174 OSTimeDlyHMSM
0323afe4 g     F .text	00000040 alt_remap_uncached
03243c94 g     F .text	000000c0 ip_raw_close
0320e7a8 g     F .text	000001e8 __multiply
03252840 g     O .rwdata	000000b0 mdlist
0321fd14 g     F .text	00000074 altera_avalon_jtag_uart_close
032241fc g     F .text	000000f8 igmp_input
0323f96c g     F .text	000000d8 ip_raw_write
032509d4 g       *ABS*	00000000 __ram_rwdata_start
0324981c g     F .text	000003e8 vfwrite_locked
0324beb0 g     F .text	000000bc strncpy
0324c36c g       *ABS*	00000000 __ram_rodata_start
03254cac g     O .bss	00000004 dsc_offers
032555ec g     O .bss	00000028 __malloc_current_mallinfo
032529c2 g     O .rwdata	00000002 OSEventMax
03247e58 g     F .text	00000074 inet_setport
0321e550 g     F .text	000001e0 alt_set_flash_width_func
0320e354 g     F .text	0000017c __d2b
0321b4e0 g     F .text	00000128 OSSemPost
03236020 g     F .text	00000190 tcp_dooptions
03231b04 g     F .text	000000fc soisconnected
032160cc g     F .text	000000e4 OSSchedUnlock
03243b54 g     F .text	00000028 netexit
03201adc g     F .text	000001dc get_serial_number
03254c90 g     O .bss	00000004 nettick_wakes
03254d28 g     O .bss	00000001 tcpprintfs
0323d020 g     F .text	000000a8 in_timerkill
03245908 g     F .text	00000160 igmpv2_input
03254cbc g     O .bss	00000004 dsc_declines
0321f6c0 g     F .text	00000058 altera_avalon_jtag_uart_read_fd
03210b64 g     F .text	00000230 _strtoul_r
03225dc4 g     F .text	0000002c do_trap
0323aa0c g     F .text	000000f4 alt_get_fd
032257c4 g     F .text	00000104 bsd_ioctl
03254c3c g     O .bss	00000004 OSMemFreeList
03216220 g     F .text	000000ac OSStatInit
0322c814 g     F .text	000001ec tcp_rcv
03226154 g     F .text	00000044 panic
03254dc8 g     O .bss	00000004 vfs_open_files
0324a57c g     F .text	0000014c alt_busy_sleep
03223af8 g     F .text	000001a4 ip2mac
03218c00 g     F .text	000000d4 OSFlagQuery
03214638 g     F .text	000000c8 __fpcmp_parts_d
03233128 g     F .text	00000214 sock_select
03247070 g     F .text	00000288 dhc_setup
03237a0c g     F .text	00000058 tcp_init
03254d04 g     O .bss	00000004 cticks
03254c99 g     O .bss	00000001 to_nettick
032529f8 g     O .rwdata	00000002 OSTaskCreateExtEn
0320be6c g     F .text	00000070 _close_r
03222dc0 g     F .text	0000064c Netinit
0322b8c8 g     F .text	00000038 prep_armintcp
032437d0 g     F .text	00000168 in_addmulti
03237a64 g     F .text	00000118 tcp_template
0322c604 g     F .text	00000070 remque
0323b9e0 g     F .text	00000218 alt_erase_block_amd
0324bf6c g     F .text	00000014 _vprintf_r
032336c4 g     F .text	00000408 tcp_reass
03248018 g     F .text	000001cc tcp_cksum
03239dac g     F .text	000003dc udp4_socksend
03249088 g     F .text	000001a8 vfclose_locked
03233560 g     F .text	00000074 ifd_set
0324bcc0 g     F .text	00000074 memcmp
0321652c g     F .text	0000001c OS_Dummy
0321f770 g     F .text	00000048 altera_avalon_jtag_uart_close_fd
03229ea0 g     F .text	000000b0 dhc_set_state
03254c70 g     O .bss	00000004 NDEBUG
0325d89c g       *ABS*	00000000 __alt_stack_base
03254bd8 g     O .bss	00000004 last_flash_sector
0321f7b8 g     F .text	00000050 altera_avalon_jtag_uart_ioctl_fd
0323238c g     F .text	00000060 sbreserve
03243d54 g     F .text	00000238 ip_raw_input
03205f14 g     F .text	0000009c _fwrite_r
03200e1c g     F .text	000000f8 read_camera_registers
03252a54 g     O .rwdata	00000004 lilbufsiz
0323c838 g     F .text	0000003c eth_ocm_phy_profiles_init
03233654 g     F .text	00000070 ifd_get
03232270 g     F .text	0000009c sbwakeup
03207b24 g     F .text	00000084 sscanf
0320bd30 g     F .text	0000013c __swsetup_r
0321ee38 g     F .text	000007ac alt_read_cfi_width
0325af7c g     O .bss	000001e0 OSQTbl
032362dc g     F .text	0000026c tcp_xmit_timer
03213670 g     F .text	00000258 __divdf3
03204cf4 g     F .text	000000f0 __sfp
03201e84 g     F .text	0000013c generate_mac_addr
0323ea50 g     F .text	000001a4 ip_bldhead
0320e1b8 g     F .text	00000058 __copybits
03232434 g     F .text	000000a8 sbappend
03250e14 g     O .rwdata	00000408 __malloc_av_
03204b88 g     F .text	00000004 __sinit_lock_release
03254c40 g     O .bss	00000004 OSTCBHighRdy
032132ac g     F .text	000003c4 __muldf3
0323f5bc g     F .text	000003b0 ip_write2
03207c94 g     F .text	00000060 __sread
03252ab4 g     O .rwdata	00000004 arp_ageout
0320da00 g     F .text	00000040 fread
03254c44 g     O .bss	00000004 OSQFreeList
0323c38c g     F .text	000000a4 eth_ocm_phy_add_profile
0323e954 g     F .text	000000fc ip_init
0323a8ec g     F .text	00000120 alt_find_file
03244058 g     F .text	00000040 ip_raw_free
0323db28 g     F .text	00000114 make_arp_entry
0323a67c g     F .text	000000b4 alt_dev_llist_insert
03215370 g     F .text	00000108 __malloc_lock
03204f20 g     F .text	00000034 _fprintf_r
032151ac g     F .text	000000bc sbrk
032395c4 g     F .text	00000070 udp_lookup
03215678 g     F .text	00000144 OSEventNameSet
032048f4 g     F .text	000001fc _fflush_r
0321133c g     F .text	000000b4 _calloc_r
03254c48 g     O .bss	00000001 OSRdyGrp
03247474 g     F .text	00000028 md_fopen
03252548 g     O .rwdata	00000018 udp_protosw
032529a4 g     O .rwdata	00000008 alt_flash_dev_list
0321e3e4 g     F .text	00000044 alt_write_flash_command_16bit_device_16bit_mode
03248790 g     F .text	0000007c in_setsockaddr
03204ed8 g     F .text	0000001c fopen
03254bcc g       *ABS*	00000000 __bss_start
03203ca0 g     F .text	00000020 trackers_number
032324dc g     F .text	000000e0 sbappendrecord
0325d52c g     O .bss	00000050 ip_mib
03206c50 g     F .text	00000098 memset
03230020 g     F .text	000000a0 sodisconnect
03201780 g     F .text	0000007c main
03201228 g     F .text	00000058 get_sensor_size
03254c04 g     O .bss	00000004 alt_envp
03254bec g     O .bss	00000004 __malloc_max_total_mem
03202380 g     F .text	00000070 sss_reset_connection
0322c334 g     F .text	000001d0 m_adj
0321f718 g     F .text	00000058 altera_avalon_jtag_uart_write_fd
0320bc9c g     F .text	0000001c __swbuf
0324770c g     F .text	000000d8 md_fgetc
0324e5e8 g     O .rodata	00000100 OSUnMapTbl
0324059c g     F .text	000002b8 ip_dump
03226e08 g     F .text	00000208 tk_stats
03212d30 g     F .text	00000078 __ltsf2
0320d804 g     F .text	000001fc _fread_r
03252a30 g     O .rwdata	00000008 alt_iniche_dev_list
032211f0 g     F .text	00000164 altera_avalon_lcd_16207_init
032529f2 g     O .rwdata	00000002 OSSemEn
03254cec g     O .bss	00000004 OS_TPS
0322d740 g     F .text	000007e8 rawip_usrreq
03218858 g     F .text	000003a8 OSFlagPost
03203f8c g     F .text	000000e0 free_tracker
03207ba8 g     F .text	00000008 __sclose
03247d34 g     F .text	00000060 print46_addr
03400000 g       *ABS*	00000000 __alt_heap_limit
032048e0 g     F .text	00000014 fclose
032166dc g     F .text	00000110 OS_EventTaskWait
032105e4 g     F .text	00000244 _strtol_r
03213dc8 g     F .text	00000074 __truncdfsf2
03226028 g     F .text	0000012c print_uptime
032172c8 g     F .text	000000c8 OS_TaskStatStkChk
0325d70c g     O .bss	00000190 _atexit0
0321c590 g     F .text	00000170 OSTaskDelReq
0320c0f4 g     F .text	000015b4 _dtoa_r
032062ac g     F .text	00000740 _malloc_r
032477e4 g     F .text	00000024 md_unlink
03248278 g     F .text	00000054 in_pcbdetach
03252a94 g     O .rwdata	00000004 alt_errno
03252ac4 g     O .rwdata	00000004 mdlist_size
032161b0 g     F .text	00000070 OSStart
032110a8 g     F .text	000000dc __submore
0321e470 g     F .text	00000048 alt_write_flash_command_32bit_device_32bit_mode
032469c4 g     F .text	00000030 u_mctest_init
03215314 g     F .text	0000005c __env_unlock
03203ec8 g     F .text	000000c4 disable_tracker
03205e5c g     F .text	000000b8 _fwalk
0321ca7c g     F .text	00000218 OSTaskResume
03219774 g     F .text	000000fc OSMemQuery
03247ecc g     F .text	0000014c convert_ip
0323d980 g     F .text	000001a8 find_oldest_arp
03252a04 g     O .rwdata	00000002 OSTaskStatEn
03254d68 g     O .bss	00000004 arpReqsIn
03248c80 g     F .text	00000050 vf_free_buffer
0321dddc g     F .text	00000164 alt_write_value_to_flash
0320dcd8 g     F .text	00000040 _mbtowc_r
0324a6c8 g     F .text	00000154 alt_fcntl
032529de g     O .rwdata	00000002 OSMemMax
0321a68c g     F .text	00000188 OSQPostFront
0321e4ec g     F .text	00000034 alt_write_native_16bit
0322aef0 g     F .text	00000030 dtrap
03252a60 g     O .rwdata	00000004 kb_last
03206e58 g     F .text	00000104 putc
032012d8 g     F .text	00000058 get_sensor_mode
03204700 g     F .text	00000060 __divsi3
03254c49 g     O .bss	00000003 OSRdyTbl
032529b8 g     O .rwdata	00000002 OSDebugEn
0324e4c4 g     O .rodata	00000014 __thenan_df
03223fec g     F .text	000000d0 ip_exit
03204fe4 g     F .text	0000012c _malloc_trim_r
0324c36c g       *ABS*	00000000 __CTOR_END__
032529d0 g     O .rwdata	00000002 OSFlagNodeSize
03254ca0 g     O .bss	00000004 dhc_conn
03201030 g     F .text	00000058 get_image_size
0322b084 g     F .text	0000006c cticks_hook
03252a18 g     O .rwdata	00000002 OSTmrCfgMax
0323cb44 g     F .text	0000003c sysuptime
0320eebc g     F .text	000000bc strcmp
03201cb8 g     F .text	000001cc generate_and_store_mac_addr
032422dc g     F .text	000001c8 ip_reasm_delete_ire
03219a94 g     F .text	00000214 OSQCreate
0322b0f0 g     F .text	0000005c irq_Mask
0321c700 g     F .text	000001b8 OSTaskNameGet
03254d54 g     O .bss	00000004 nextppp
03254ce0 g     O .bss	00000004 irq_level
03201388 g     F .text	000000b8 camera_configure
0322340c g     F .text	00000160 fixup_subnet_mask
0324c36c g       *ABS*	00000000 __flash_rodata_start
0321a814 g     F .text	00000234 OSQPostOpt
032162cc g     F .text	00000240 OSTimeTick
03240ac0 g     F .text	00000138 ip_copypkt
03229d9c g     F .text	00000090 dhc_alldone
03252a00 g     O .rwdata	00000002 OSTaskMax
0324c36c g       *ABS*	00000000 __DTOR_LIST__
0321ad34 g     F .text	00000114 OSSemCreate
03254c84 g     O .bss	00000004 igmp_all_hosts_group
03252a24 g     O .rwdata	00000002 OSTmrWheelSize
032321d0 g     F .text	00000038 sbselqueue
03254c8c g     O .bss	00000004 netmain_wakes
0323ded0 g     F .text	00000260 arprcv
03226a54 g     F .text	00000070 TK_OSTaskResume
03224d7c g     F .text	000003e0 igmp_print_stats
03213950 g     F .text	00000088 __nedf2
0322bb80 g     F .text	000000a0 pffindtype
032529fa g     O .rwdata	00000002 OSTaskDelEn
03252a78 g     O .rwdata	00000004 tcp_sendspace
03249de0 g     F .text	00000134 vftell
0325cd88 g     O .bss	00000012 eth_prt_buf
0321b608 g     F .text	00000130 OSSemQuery
03219ca8 g     F .text	00000300 OSQDel
0321a390 g     F .text	0000017c OSQPendAbort
0321d814 g     F .text	00000034 alt_irq_init
0325d1f0 g     O .bss	00000018 app_semaphore
0321514c g     F .text	00000060 alt_release_fd
0322b5a0 g     F .text	00000078 post_app_sem
0322414c g     F .text	000000b0 igmp_init
032079c0 g     F .text	00000074 sprintf
0324e4d8 g     O .rodata	00000100 __clz_tab
03254cc8 g     O .bss	00000004 dsc_renew
0324763c g     F .text	00000080 md_fwrite
03254bf8 g     O .bss	00000004 _PathLocale
03254cf0 g     O .bss	00000004 tcp_sleep_count
0322c674 g     F .text	0000007c insque
032104a4 g     F .text	00000124 strtof
0324bc18 g     F .text	00000014 atexit
03254dbc g     O .bss	00000004 vfsfiles
0320bcb8 g     F .text	00000078 _write_r
0324bfa0 g     F .text	00000050 _vsprintf_r
0324503c g     F .text	000002b8 udp_send
03216040 g     F .text	0000008c OSSchedLock
03224490 g     F .text	000002a8 igmp_send
0320db84 g     F .text	0000001c setlocale
032216ac g     F .text	00000104 set_search_window
03217b30 g     F .text	0000013c OSFlagCreate
0322b14c g     F .text	00000044 irq_Unmask
0322e180 g     F .text	000000e4 t_listen
0320eeb4 g     F .text	00000008 nanf
0325298c g     O .rwdata	00000004 _impure_ptr
032509fc g     O .rwdata	00000018 ssstask
03254bfc g     O .bss	00000004 alt_argc
03238b8c g     F .text	00000704 tcp_usrreq
032397ec g     F .text	00000284 udp_usrreq
0322bae0 g     F .text	00000054 ncpalloc
0320dc18 g     F .text	00000080 _mbrtowc_r
0323a7f4 g     F .text	00000064 _do_dtors
032529ca g     O .rwdata	00000002 OSEventMultiEn
03252aac g     O .rwdata	00000004 pingdelay
03205424 g     F .text	0000043c _fseek_r
0323d474 g     F .text	00000074 arp_send_pending
03245620 g     F .text	000002e8 igmpv1_input
03207710 g     F .text	000001c4 __srefill_r
0322b834 g     F .text	00000074 pre_task_setup
03254d10 g     O .bss	00000004 rcvdq_sem_ptr
032253c0 g     F .text	0000012c bsd_getsockname
032424a4 g     F .text	00000148 ip_reasm_mark_compact_rfq
0320223c g     F .text	00000144 FindLastFlashSectorOffset
03217c6c g     F .text	000002a8 OSFlagDel
03254c4c g     O .bss	00000004 OSEventFreeList
0322715c g     F .text	00000044 dhc_set_callback
03200020 g       .exceptions	00000000 alt_irq_entry
03254d64 g     O .bss	00000004 arpcache
03203c08 g     F .text	00000098 trackers_init
0324b540 g     F .text	00000350 icmp_destun
03243a50 g     F .text	00000070 lookup_mcast
0324a1b4 g     F .text	00000048 vfslookup
032433a0 g     F .text	00000430 ip_demux
0320ded4 g     F .text	00000080 __ulp
0320ed84 g     F .text	00000040 __isinfd
03254cf4 g     O .bss	00000004 tcp_wakeup_count
032181ac g     F .text	00000644 OSFlagPend
03252a16 g     O .rwdata	00000002 OSTmrEn
03204c40 g     F .text	00000018 __fp_unlock_all
0322b4ec g     F .text	000000b4 wait_app_sem
03221354 g     F .text	00000058 altera_avalon_lcd_16207_write_fd
0320d748 g     F .text	00000064 fputc
03252a38 g     O .rwdata	00000004 ipmcfail_str
03254d08 g     O .bss	00000004 memtrapsize
0322c010 g     F .text	00000324 m_copy
03252a80 g     O .rwdata	00000008 alt_fs_list
0320406c g     F .text	000001b8 set_search_window_of_tracker
0325d26c g     O .bss	00000014 mfreeq
032170cc g     F .text	00000080 OS_StrCopy
0322f8f0 g     F .text	0000005c sobind
032473fc g     F .text	00000078 init_memdev
03254bd0 g     O .bss	00000001 to_ssstask
0321e39c g     F .text	00000048 alt_write_flash_command_32bit_device_8bit_mode
0322c6f0 g     F .text	00000124 nptcp_init
03201280 g     F .text	00000058 set_sensor_size
032529e0 g     O .rwdata	00000002 OSMemNameSize
0325d0c0 g     O .bss	000000f0 global_TCPwakeup_set
0323b920 g     F .text	0000001c OSInitHookEnd
03231c8c g     F .text	000000bc soisdisconnected
03200020 g       *ABS*	00000000 __ram_exceptions_start
0323d3ec g     F .text	00000088 arp_free_pending
03252a0c g     O .rwdata	00000002 OSTCBPrioTblMax
0320daf0 g     F .text	00000010 localeconv
0322fb6c g     F .text	000002f4 soclose
0325cfb0 g     O .bss	00000014 bigfreeq
03252a08 g     O .rwdata	00000002 OSTaskStatStkChkEn
03252aa8 g     O .rwdata	00000004 prompt
032524b8 g     O .rwdata	00000048 eth_ocm_0
03252a70 g     O .rwdata	00000004 tcp_keepidle
0322d56c g     F .text	000001d4 rawip_soinput
03249c04 g     F .text	00000060 vfwrite
032529dc g     O .rwdata	00000002 OSMemEn
03231f64 g     F .text	000000ac soqinsque
03254d98 g     O .bss	00000004 so_evtmap_delete
03205fb0 g     F .text	00000040 fwrite
03211414 g     F .text	00000068 __hexdig_init
03207a9c g     F .text	00000088 _sscanf_r
032529e6 g     O .rwdata	00000002 OSMutexEn
03254d84 g     O .bss	00000004 h_ireq
03252ad0 g       *ABS*	00000000 _edata
0323fecc g     F .text	00000624 ip_fragment
03222b94 g     F .text	00000144 iniche_devices_init
0325d280 g     O .bss	00000028 tcp_saveti
03226544 g     F .text	000000f0 con_page
0325d89c g       *ABS*	00000000 _end
03231514 g     F .text	00000540 sogetopt
03214860 g     F .text	0000007c alt_flash_open_dev
03254c50 g     O .bss	00000001 OSIntNesting
03252500 g     O .rwdata	00000030 nettasks
0322a6ec g     F .text	00000020 pk_get_max_intrsafe_buf_len
03240854 g     F .text	0000026c iproute
0322d038 g     F .text	000000e8 np_stripoptions
03254d9c g     O .bss	00000001 so_evtmap
032001c0 g       *ABS*	00000000 __ram_exceptions_end
0320baf8 g     F .text	00000074 vfscanf
0321fd88 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
03204f54 g     F .text	00000074 _fputs_r
0321d53c g     F .text	00000210 OSTimeDlyResume
03244278 g     F .text	00000428 add_route
03218058 g     F .text	00000154 OSFlagNameSet
03223a28 g     F .text	000000d0 c_older
032329ac g     F .text	00000090 sbflush
0323c31c g     F .text	00000070 eth_ocm_read_phy_reg
0324749c g     F .text	00000020 md_fclose
03226ddc g     F .text	0000002c tk_yield
032037b0 g     F .text	000000c0 sss_handle_accept
0321cc94 g     F .text	000001fc OSTaskStkChk
032300c0 g     F .text	00000608 sosend
032529e2 g     O .rwdata	00000002 OSMemSize
03201178 g     F .text	00000058 get_start_image
032404f0 g     F .text	000000ac ip_mymach
03207c18 g     F .text	0000007c __swrite
03254cdc g     O .bss	00000004 cticks_initialized
03252ab0 g     O .rwdata	00000004 deflength
0322efe8 g     F .text	0000022c t_sendto
03252994 g     O .rwdata	00000004 __malloc_trim_threshold
03206d60 g     F .text	0000006c _perror_r
03254c54 g     O .bss	00000004 OSTCBCur
0322f724 g     F .text	000001cc socreate
0324bc60 g     F .text	00000038 exit
0325d418 g     O .bss	00000100 arp_table
03254dd4 g     O .bss	00000004 icmpdu_hook
032529e4 g     O .rwdata	00000002 OSMemTblSize
03205d94 g     F .text	000000c8 _fwalk_reent
0323d0c8 g     F .text	00000024 create_apptasks
03252a6c g     O .rwdata	00000004 tcp_ttl
0320e4d0 g     F .text	0000018c __mdiff
032148dc g     F .text	00000054 alt_flash_close_dev
0322bb34 g     F .text	0000004c ncpfree
03204760 g     F .text	00000060 __modsi3
03254c68 g     O .bss	00000004 MaxLnh
032011d0 g     F .text	00000058 set_start_image
03247ca8 g     F .text	0000008c inet_ntop
032455b4 g     F .text	0000002c udp_maxalloc
03400000 g       *ABS*	00000000 __alt_data_end
03200020 g     F .exceptions	00000000 alt_exception
03204b80 g     F .text	00000004 __sfp_lock_release
03215e70 g     F .text	00000054 OSInit
0321d0bc g     F .text	00000144 OSTaskQuery
0323c970 g     F .text	00000088 icmp_port_du
03254d38 g     O .bss	00000004 tcp_iss
0321abc8 g     F .text	000000ac OS_QInit
0320edf4 g     F .text	000000c0 __sccl
0324bc38 g     F .text	0000000c atoi
03252a5c g     O .rwdata	00000004 bigbufsiz
0321714c g     F .text	00000058 OS_StrLen
032382fc g     F .text	00000080 tcp_putseq
03219564 g     F .text	00000120 OSMemNameSet
0324d820 g     O .rodata	00000101 _ctype_
032325bc g     F .text	00000208 sbappendaddr
02800000 g       *ABS*	00000000 __alt_mem_ext_flash
03254dcc g     O .bss	00000004 vfs_total_rw_space
03246800 g     F .text	00000140 ip_getmoptions
032529fe g     O .rwdata	00000002 OSTaskProfileEn
032452f4 g     F .text	00000130 udpswap
03254c58 g     O .bss	00000004 OSTime
03254d14 g     O .bss	00000004 nextslow
032383f4 g     F .text	000002a0 tcp_slowtimo
03238004 g     F .text	00000118 tcp_newtcpcb
0323e130 g     F .text	000001a8 send_via_arp
032270a0 g     F .text	000000bc dhc_init
03241e38 g     F .text	00000064 ip_reasm_find_ire
03214118 g     F .text	000000a8 __fpcmp_parts_f
0325b15c g     O .bss	00000800 OSTaskIdleStk
03204de4 g     F .text	000000f4 _fopen_r
0324c33c g     F .text	0000002c _exit
0324a3e4 g     F .text	00000064 isvfile_locked
0320edc4 g     F .text	00000030 __isnand
03225a58 g     F .text	00000168 bsd_select
0323a2e4 g     F .text	00000154 alt_alarm_start
03217f14 g     F .text	00000144 OSFlagNameGet
032455e0 g     F .text	00000040 udp_free
0322a7b8 g     F .text	000000c8 getq
0324a558 g     F .text	00000024 prep_vfs
0321d74c g     F .text	00000064 OSTimeGet
03252aa4 g     O .rwdata	00000004 name
03232c0c g     F .text	00000110 sbdropend
03211f78 g     F .text	00000098 __muldi3
03206118 g     F .text	00000194 __smakebuf_r
0321e520 g     F .text	00000030 alt_write_native_32bit
0323e2d8 g     F .text	00000118 cb_arpent_tmo
03208448 g     F .text	00000074 strlen
032460c8 g     F .text	00000148 IPADDR_TO_NETP
032258c8 g     F .text	00000030 bsd_inet_ntoa
0323b8a4 g     F .text	0000001c OSTaskSwHook
03214f64 g     F .text	00000188 open
0322aa40 g     F .text	00000238 udp_open
0325b95c g     O .bss	00000b40 OSEventTbl
03232130 g     F .text	00000050 socantsendmore
03254dd0 g     O .bss	00000004 vfs_total_dyna_files
03213a60 g     F .text	00000088 __gedf2
0325c49c g     O .bss	00000510 OSTCBTbl
0321152c g     F .text	000007b8 __gethex
03254d6c g     O .bss	00000004 arpReqsOut
0321b738 g     F .text	00000104 OSSemSet
03252acc g     O .rwdata	00000004 http_root_path
0322928c g     F .text	000002bc dhc_extract_opts
03241314 g     F .text	00000590 ip_reasm_compute_overlap
0321dce4 g     F .text	00000090 alt_flash_cfi_get_info
0323ab00 g     F .text	00000030 alt_icache_flush_all
03207cf4 g     F .text	000000e0 strchr
0325cd9a g     O .bss	00000012 ipreturn
03254d8c g     O .bss	00000004 port_prep
03252583 g     O .rwdata	0000000d tcp_backoff
03231a98 g     F .text	0000006c soisconnecting
032016d0 g     F .text	000000b0 SSSInitialTask
03204fc8 g     F .text	0000001c fputs
03252a98 g     O .rwdata	00000004 alt_priority_mask
03245bb4 g     F .text	0000024c igmpv2_process_query
03232db0 g     F .text	00000220 t_select
0321ae48 g     F .text	000002a0 OSSemDel
03203d60 g     F .text	00000168 activate_tracker
0323a188 g     F .text	0000015c udp4_sockaddr
03254c5c g     O .bss	00000004 OSFlagFreeList
03248520 g     F .text	00000210 in_pcbconnect
03254d2c g     O .bss	00000004 dropline
03254d88 g     O .bss	00000004 ire_cticks
032529c4 g     O .rwdata	00000002 OSEventNameSize
0320a3c8 g     F .text	00000024 __vfprintf_internal
03226954 g     F .text	00000088 tk_netmain
03248730 g     F .text	00000060 in_pcbdisconnect
03254c60 g     O .bss	00000001 OSStatRdy
03200db4 g     F .text	00000068 camera_init
0325c9ac g     O .bss	00000054 OSTCBPrioTbl
03221860 g     F .text	000001bc eth_ocm_prep
03215268 g     F .text	000000ac __env_lock
03252a0a g     O .rwdata	00000002 OSTaskSwHookEn
0325281c g     O .rwdata	00000024 mdio
0322515c g     F .text	00000138 bsd_accept
03252a7c g     O .rwdata	00000004 tcp_recvspace
032131b8 g     F .text	00000080 __subdf3
03239578 g     F .text	0000004c tcpinit
03254c88 g     O .bss	00000004 igmp_all_rtrs_group
0322d4fc g     F .text	00000070 rawip_lookup
0323d16c g     F .text	000000b0 fcntl
0320ddb0 g     F .text	000000c4 __lo0bits
032327c4 g     F .text	000001e8 sbcompress
0320a3ec g     F .text	00001680 __svfscanf_r
03252a9c g     O .rwdata	00000008 alt_alarm_list
03211184 g     F .text	0000019c _ungetc_r
0323811c g     F .text	000000ac tcp_drop
032529d2 g     O .rwdata	00000002 OSFlagWidth
0323a790 g     F .text	00000064 _do_ctors
032386f0 g     F .text	0000049c tcp_timers
032240bc g     F .text	00000090 if_netnumber
03246940 g     F .text	00000084 ip_freemoptions
03231a54 g     F .text	00000044 sohasoutofband
03233acc g     F .text	00002554 tcp_input
03225294 g     F .text	0000012c bsd_getpeername
032258f8 g     F .text	00000160 bsd_recvfrom
03222b40 g     F .text	00000054 close
03254cb8 g     O .bss	00000004 dsc_bpreplys
0323b978 g     F .text	00000068 alt_program_amd
03254c0c g     O .bss	00000004 alt_envsem
03254c64 g     O .bss	00000004 OSIdleCtrRun
0321650c g     F .text	00000020 OSVersion
03252a1c g     O .rwdata	00000002 OSTmrCfgWheelSize
03214b84 g     F .text	00000080 alt_load
0321d200 g     F .text	0000007c OS_TaskStkClr
03248ae4 g     F .text	00000028 set_vfopen_error
032141ec g     F .text	00000314 __pack_d
032529f6 g     O .rwdata	00000002 OSTaskCreateEn
03252560 g     O .rwdata	00000018 rawip_protosw
03232208 g     F .text	00000068 sbwait
03216afc g     F .text	00000068 OS_EventWaitListInit
03229548 g     F .text	0000059c dhc_second
03254d58 g     O .bss	00000004 port_1s_callout
0323b93c g     F .text	0000001c OSTaskIdleHook
0324bc98 g     F .text	00000014 free
03204b84 g     F .text	00000004 __sinit_lock_acquire
0320e9cc g     F .text	00000100 __multadd
0321ce90 g     F .text	0000022c OSTaskSuspend
0320dd18 g     F .text	00000028 _Bfree
03231d48 g     F .text	0000021c sonewconn
0324a90c g     F .text	00000c34 icmprcv
0322bc20 g     F .text	000000d0 pffindproto
032171a4 g     F .text	0000005c OS_TaskIdle
03252a22 g     O .rwdata	00000002 OSTmrTblSize
0321aa48 g     F .text	00000180 OSQQuery



Disassembly of section .entry:

03200000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 3200000:	00900014 	movui	r2,16384
#endif

0:
    initi r2
 3200004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 3200008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 320000c:	00bffd16 	blt	zero,r2,3200004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 3200010:	0040c834 	movhi	at,800
    ori r1, r1, %lo(_start)
 3200014:	08407014 	ori	at,at,448
    jmp r1
 3200018:	0800683a 	jmp	at
 320001c:	00000000 	call	0 <OSTCBStkPtr_OFFSET>

Disassembly of section .exceptions:

03200020 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -76
 3200020:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
 3200024:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
 3200028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 320002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 3200030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 3200034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 3200038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 320003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 3200040:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
 3200044:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
 3200048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 320004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 3200050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 3200054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 3200058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 320005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 3200060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 3200064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 3200068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 320006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 3200070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 3200074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 3200078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 320007c:	10000326 	beq	r2,zero,320008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 3200080:	20000226 	beq	r4,zero,320008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 3200084:	32000ec0 	call	32000ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 3200088:	00000306 	br	3200098 <alt_exception+0x78>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
 320008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
 3200090:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
 3200094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 3200098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 320009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 32000a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 32000a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 32000a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 32000ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 32000b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 32000b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 32000b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 32000bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 32000c0:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
 32000c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 32000c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 32000cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 32000d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 32000d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 32000d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 32000dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 32000e0:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
 32000e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 32000e8:	ef80083a 	eret

032000ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 32000ec:	defff904 	addi	sp,sp,-28
 32000f0:	dfc00615 	stw	ra,24(sp)
 32000f4:	df000515 	stw	fp,20(sp)
 32000f8:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 32000fc:	3215ec40 	call	3215ec4 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 3200100:	0005313a 	rdctl	r2,ipending
 3200104:	e0bffc15 	stw	r2,-16(fp)

  return active;
 3200108:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 320010c:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
 3200110:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 3200114:	00800044 	movi	r2,1
 3200118:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 320011c:	e0ffff17 	ldw	r3,-4(fp)
 3200120:	e0bffe17 	ldw	r2,-8(fp)
 3200124:	1884703a 	and	r2,r3,r2
 3200128:	1005003a 	cmpeq	r2,r2,zero
 320012c:	1000171e 	bne	r2,zero,320018c <alt_irq_handler+0xa0>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
 3200130:	e0bffd17 	ldw	r2,-12(fp)
 3200134:	00c0c9b4 	movhi	r3,806
 3200138:	18f56904 	addi	r3,r3,-10844
 320013c:	100490fa 	slli	r2,r2,3
 3200140:	10c5883a 	add	r2,r2,r3
 3200144:	11800017 	ldw	r6,0(r2)
 3200148:	e0bffd17 	ldw	r2,-12(fp)
 320014c:	00c0c9b4 	movhi	r3,806
 3200150:	18f56904 	addi	r3,r3,-10844
 3200154:	100490fa 	slli	r2,r2,3
 3200158:	10c5883a 	add	r2,r2,r3
 320015c:	10800104 	addi	r2,r2,4
 3200160:	11000017 	ldw	r4,0(r2)
 3200164:	e17ffd17 	ldw	r5,-12(fp)
 3200168:	303ee83a 	callr	r6
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 320016c:	0005313a 	rdctl	r2,ipending
 3200170:	e0bffb15 	stw	r2,-20(fp)

  return active;
 3200174:	e0bffb17 	ldw	r2,-20(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
 3200178:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
 320017c:	e0bfff17 	ldw	r2,-4(fp)
 3200180:	1004c03a 	cmpne	r2,r2,zero
 3200184:	103fe21e 	bne	r2,zero,3200110 <alt_irq_handler+0x24>
 3200188:	00000706 	br	32001a8 <alt_irq_handler+0xbc>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
 320018c:	e0bffe17 	ldw	r2,-8(fp)
 3200190:	1085883a 	add	r2,r2,r2
 3200194:	e0bffe15 	stw	r2,-8(fp)
      i++;
 3200198:	e0bffd17 	ldw	r2,-12(fp)
 320019c:	10800044 	addi	r2,r2,1
 32001a0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 32001a4:	003fdd06 	br	320011c <alt_irq_handler+0x30>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 32001a8:	3215f400 	call	3215f40 <OSIntExit>
}
 32001ac:	e037883a 	mov	sp,fp
 32001b0:	dfc00117 	ldw	ra,4(sp)
 32001b4:	df000017 	ldw	fp,0(sp)
 32001b8:	dec00204 	addi	sp,sp,8
 32001bc:	f800283a 	ret

Disassembly of section .text:

032001c0 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 32001c0:	00900014 	movui	r2,16384
#endif

0:
    initd 0(r2)
 32001c4:	10000033 	initd	0(r2)
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 32001c8:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 32001cc:	00bffd16 	blt	zero,r2,32001c4 <_start+0x4>
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 32001d0:	06c0d034 	movhi	sp,832
    ori sp, sp, %lo(__alt_stack_pointer)
 32001d4:	dec00014 	ori	sp,sp,0

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
 32001d8:	0680c974 	movhi	gp,805
    ori gp, gp, %lo(_gp)
 32001dc:	d6aa6214 	ori	gp,gp,43400
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 32001e0:	0080c974 	movhi	r2,805
    ori r2, r2, %lo(__bss_start)
 32001e4:	1092f314 	ori	r2,r2,19404

    movhi r3, %hi(__bss_end)
 32001e8:	00c0c974 	movhi	r3,805
    ori r3, r3, %lo(__bss_end)
 32001ec:	18f62714 	ori	r3,r3,55452

    beq r2, r3, 1f
 32001f0:	10c00326 	beq	r2,r3,3200200 <_start+0x40>

0:
    stw zero, (r2)
 32001f4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 32001f8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 32001fc:	10fffd36 	bltu	r2,r3,32001f4 <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 3200200:	3214b840 	call	3214b84 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 3200204:	3214dc00 	call	3214dc0 <alt_main>

03200208 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 3200208:	003fff06 	br	3200208 <alt_after_alt_main>

0320020c <alt_uCOSIIErrorHandler>:
#include <errno.h>
#include "includes.h"
#include "alt_error_handler.h"
 
void alt_uCOSIIErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 320020c:	defff904 	addi	sp,sp,-28
 3200210:	dfc00615 	stw	ra,24(sp)
 3200214:	df000515 	stw	fp,20(sp)
 3200218:	df000504 	addi	fp,sp,20
 320021c:	e17ffd15 	stw	r5,-12(fp)
 3200220:	e13ffc05 	stb	r4,-16(fp)
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
 3200224:	e0bffc03 	ldbu	r2,-16(fp)
 3200228:	1005003a 	cmpeq	r2,r2,zero
 320022c:	10017b1e 	bne	r2,zero,320081c <alt_uCOSIIErrorHandler+0x610>
   {
      return;
   }
   
   fault_level = SYSTEM;  
 3200230:	00800084 	movi	r2,2
 3200234:	e0bffb15 	stw	r2,-20(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 3200238:	32160400 	call	3216040 <OSSchedLock>
      
   switch (error_code)
 320023c:	e0bffc03 	ldbu	r2,-16(fp)
 3200240:	e0bffe15 	stw	r2,-8(fp)
 3200244:	e0fffe17 	ldw	r3,-8(fp)
 3200248:	18800a20 	cmpeqi	r2,r3,40
 320024c:	1000371e 	bne	r2,zero,320032c <alt_uCOSIIErrorHandler+0x120>
 3200250:	e0fffe17 	ldw	r3,-8(fp)
 3200254:	18800a48 	cmpgei	r2,r3,41
 3200258:	10001a1e 	bne	r2,zero,32002c4 <alt_uCOSIIErrorHandler+0xb8>
 320025c:	e0fffe17 	ldw	r3,-8(fp)
 3200260:	18800120 	cmpeqi	r2,r3,4
 3200264:	1000761e 	bne	r2,zero,3200440 <alt_uCOSIIErrorHandler+0x234>
 3200268:	e0fffe17 	ldw	r3,-8(fp)
 320026c:	18800148 	cmpgei	r2,r3,5
 3200270:	10000a1e 	bne	r2,zero,320029c <alt_uCOSIIErrorHandler+0x90>
 3200274:	e0fffe17 	ldw	r3,-8(fp)
 3200278:	188000a0 	cmpeqi	r2,r3,2
 320027c:	1000911e 	bne	r2,zero,32004c4 <alt_uCOSIIErrorHandler+0x2b8>
 3200280:	e0fffe17 	ldw	r3,-8(fp)
 3200284:	188000c8 	cmpgei	r2,r3,3
 3200288:	1000771e 	bne	r2,zero,3200468 <alt_uCOSIIErrorHandler+0x25c>
 320028c:	e0fffe17 	ldw	r3,-8(fp)
 3200290:	18800060 	cmpeqi	r2,r3,1
 3200294:	10005e1e 	bne	r2,zero,3200410 <alt_uCOSIIErrorHandler+0x204>
 3200298:	0000d806 	br	32005fc <alt_uCOSIIErrorHandler+0x3f0>
 320029c:	e0fffe17 	ldw	r3,-8(fp)
 32002a0:	18800520 	cmpeqi	r2,r3,20
 32002a4:	10004f1e 	bne	r2,zero,32003e4 <alt_uCOSIIErrorHandler+0x1d8>
 32002a8:	e0fffe17 	ldw	r3,-8(fp)
 32002ac:	188007a0 	cmpeqi	r2,r3,30
 32002b0:	1000ad1e 	bne	r2,zero,3200568 <alt_uCOSIIErrorHandler+0x35c>
 32002b4:	e0fffe17 	ldw	r3,-8(fp)
 32002b8:	188002a0 	cmpeqi	r2,r3,10
 32002bc:	1000761e 	bne	r2,zero,3200498 <alt_uCOSIIErrorHandler+0x28c>
 32002c0:	0000ce06 	br	32005fc <alt_uCOSIIErrorHandler+0x3f0>
 32002c4:	e0fffe17 	ldw	r3,-8(fp)
 32002c8:	18801020 	cmpeqi	r2,r3,64
 32002cc:	10009c1e 	bne	r2,zero,3200540 <alt_uCOSIIErrorHandler+0x334>
 32002d0:	e0fffe17 	ldw	r3,-8(fp)
 32002d4:	18801048 	cmpgei	r2,r3,65
 32002d8:	10000a1e 	bne	r2,zero,3200304 <alt_uCOSIIErrorHandler+0xf8>
 32002dc:	e0fffe17 	ldw	r3,-8(fp)
 32002e0:	18800f60 	cmpeqi	r2,r3,61
 32002e4:	10008b1e 	bne	r2,zero,3200514 <alt_uCOSIIErrorHandler+0x308>
 32002e8:	e0fffe17 	ldw	r3,-8(fp)
 32002ec:	18800fa0 	cmpeqi	r2,r3,62
 32002f0:	10007e1e 	bne	r2,zero,32004ec <alt_uCOSIIErrorHandler+0x2e0>
 32002f4:	e0fffe17 	ldw	r3,-8(fp)
 32002f8:	18800aa0 	cmpeqi	r2,r3,42
 32002fc:	1000151e 	bne	r2,zero,3200354 <alt_uCOSIIErrorHandler+0x148>
 3200300:	0000be06 	br	32005fc <alt_uCOSIIErrorHandler+0x3f0>
 3200304:	e0fffe17 	ldw	r3,-8(fp)
 3200308:	18801920 	cmpeqi	r2,r3,100
 320030c:	1000a11e 	bne	r2,zero,3200594 <alt_uCOSIIErrorHandler+0x388>
 3200310:	e0fffe17 	ldw	r3,-8(fp)
 3200314:	18803fe0 	cmpeqi	r2,r3,255
 3200318:	1000aa1e 	bne	r2,zero,32005c4 <alt_uCOSIIErrorHandler+0x3b8>
 320031c:	e0fffe17 	ldw	r3,-8(fp)
 3200320:	188010a0 	cmpeqi	r2,r3,66
 3200324:	10001d1e 	bne	r2,zero,320039c <alt_uCOSIIErrorHandler+0x190>
 3200328:	0000b406 	br	32005fc <alt_uCOSIIErrorHandler+0x3f0>
   {  
      case OS_PRIO_EXIST:
         fprintf(stderr, "Attempted to assign task priority aready in use.\n");
 320032c:	0080c974 	movhi	r2,805
 3200330:	108a6304 	addi	r2,r2,10636
 3200334:	10800017 	ldw	r2,0(r2)
 3200338:	11c00317 	ldw	r7,12(r2)
 320033c:	0100c974 	movhi	r4,805
 3200340:	2130db04 	addi	r4,r4,-15508
 3200344:	01400044 	movi	r5,1
 3200348:	01800c44 	movi	r6,49
 320034c:	3205fb00 	call	3205fb0 <fwrite>
         break;
 3200350:	0000c106 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_PRIO_INVALID:
         fprintf(stderr, "Specified task priority higher than allowed max.\n");
 3200354:	0080c974 	movhi	r2,805
 3200358:	108a6304 	addi	r2,r2,10636
 320035c:	10800017 	ldw	r2,0(r2)
 3200360:	11c00317 	ldw	r7,12(r2)
 3200364:	0100c974 	movhi	r4,805
 3200368:	2130e804 	addi	r4,r4,-15456
 320036c:	01400044 	movi	r5,1
 3200370:	01800c44 	movi	r6,49
 3200374:	3205fb00 	call	3205fb0 <fwrite>
         fprintf(stderr, "Task can't be assigned a priority higher than %d\n",
 3200378:	0080c974 	movhi	r2,805
 320037c:	108a6304 	addi	r2,r2,10636
 3200380:	10800017 	ldw	r2,0(r2)
 3200384:	11000317 	ldw	r4,12(r2)
 3200388:	0140c974 	movhi	r5,805
 320038c:	2970f504 	addi	r5,r5,-15404
 3200390:	01800504 	movi	r6,20
 3200394:	3204ef40 	call	3204ef4 <fprintf>
            OS_LOWEST_PRIO);
         break;
 3200398:	0000af06 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_NO_MORE_TCB:
         fprintf(stderr, "Task Control Blocks have been exhausted\n");
 320039c:	0080c974 	movhi	r2,805
 32003a0:	108a6304 	addi	r2,r2,10636
 32003a4:	10800017 	ldw	r2,0(r2)
 32003a8:	11c00317 	ldw	r7,12(r2)
 32003ac:	0100c974 	movhi	r4,805
 32003b0:	21310204 	addi	r4,r4,-15352
 32003b4:	01400044 	movi	r5,1
 32003b8:	01800a04 	movi	r6,40
 32003bc:	3205fb00 	call	3205fb0 <fwrite>
         fprintf(stderr, "Current max number of tasks is %d\n",OS_MAX_TASKS);
 32003c0:	0080c974 	movhi	r2,805
 32003c4:	108a6304 	addi	r2,r2,10636
 32003c8:	10800017 	ldw	r2,0(r2)
 32003cc:	11000317 	ldw	r4,12(r2)
 32003d0:	0140c974 	movhi	r5,805
 32003d4:	29710d04 	addi	r5,r5,-15308
 32003d8:	01800284 	movi	r6,10
 32003dc:	3204ef40 	call	3204ef4 <fprintf>
         break;
 32003e0:	00009d06 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_MBOX_FULL:
         fault_level = NONE;
 32003e4:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted Post to Mailbox already holding message\n");
 32003e8:	0080c974 	movhi	r2,805
 32003ec:	108a6304 	addi	r2,r2,10636
 32003f0:	10800017 	ldw	r2,0(r2)
 32003f4:	11c00317 	ldw	r7,12(r2)
 32003f8:	0100c974 	movhi	r4,805
 32003fc:	21311604 	addi	r4,r4,-15272
 3200400:	01400044 	movi	r5,1
 3200404:	01800c84 	movi	r6,50
 3200408:	3205fb00 	call	3205fb0 <fwrite>
         break;
 320040c:	00009206 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_EVENT_TYPE:
         fault_level = TASK;
 3200410:	00800044 	movi	r2,1
 3200414:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, 
 3200418:	0080c974 	movhi	r2,805
 320041c:	108a6304 	addi	r2,r2,10636
 3200420:	10800017 	ldw	r2,0(r2)
 3200424:	11c00317 	ldw	r7,12(r2)
 3200428:	0100c974 	movhi	r4,805
 320042c:	21312304 	addi	r4,r4,-15220
 3200430:	01400044 	movi	r5,1
 3200434:	01801244 	movi	r6,73
 3200438:	3205fb00 	call	3205fb0 <fwrite>
"Attempted to access a resource with no match for the required data type.\n");
         break;
 320043c:	00008606 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_PEVENT_NULL:
         fprintf(stderr, "Attempting to access a resource pointing to NULL\n");
 3200440:	0080c974 	movhi	r2,805
 3200444:	108a6304 	addi	r2,r2,10636
 3200448:	10800017 	ldw	r2,0(r2)
 320044c:	11c00317 	ldw	r7,12(r2)
 3200450:	0100c974 	movhi	r4,805
 3200454:	21313604 	addi	r4,r4,-15144
 3200458:	01400044 	movi	r5,1
 320045c:	01800c44 	movi	r6,49
 3200460:	3205fb00 	call	3205fb0 <fwrite>
         break;
 3200464:	00007c06 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_POST_NULL_PTR:
         fault_level = TASK;
 3200468:	00800044 	movi	r2,1
 320046c:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, "Attempted to Post a NULL to a resource. \n");
 3200470:	0080c974 	movhi	r2,805
 3200474:	108a6304 	addi	r2,r2,10636
 3200478:	10800017 	ldw	r2,0(r2)
 320047c:	11c00317 	ldw	r7,12(r2)
 3200480:	0100c974 	movhi	r4,805
 3200484:	21314304 	addi	r4,r4,-15092
 3200488:	01400044 	movi	r5,1
 320048c:	01800a44 	movi	r6,41
 3200490:	3205fb00 	call	3205fb0 <fwrite>
         break;
 3200494:	00007006 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TIMEOUT:
         fault_level = NONE;
 3200498:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Resource not received in specified time\n");
 320049c:	0080c974 	movhi	r2,805
 32004a0:	108a6304 	addi	r2,r2,10636
 32004a4:	10800017 	ldw	r2,0(r2)
 32004a8:	11c00317 	ldw	r7,12(r2)
 32004ac:	0100c974 	movhi	r4,805
 32004b0:	21314e04 	addi	r4,r4,-15048
 32004b4:	01400044 	movi	r5,1
 32004b8:	01800a04 	movi	r6,40
 32004bc:	3205fb00 	call	3205fb0 <fwrite>
         break;
 32004c0:	00006506 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_PEND_ISR:
         fprintf(stderr, "Attempting to pend for a resource in an ISR\n");
 32004c4:	0080c974 	movhi	r2,805
 32004c8:	108a6304 	addi	r2,r2,10636
 32004cc:	10800017 	ldw	r2,0(r2)
 32004d0:	11c00317 	ldw	r7,12(r2)
 32004d4:	0100c974 	movhi	r4,805
 32004d8:	21315904 	addi	r4,r4,-15004
 32004dc:	01400044 	movi	r5,1
 32004e0:	01800b04 	movi	r6,44
 32004e4:	3205fb00 	call	3205fb0 <fwrite>
         break;
 32004e8:	00005b06 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_IDLE:
         fprintf(stderr, "Attempted to delete the IDLE task\n");
 32004ec:	0080c974 	movhi	r2,805
 32004f0:	108a6304 	addi	r2,r2,10636
 32004f4:	10800017 	ldw	r2,0(r2)
 32004f8:	11c00317 	ldw	r7,12(r2)
 32004fc:	0100c974 	movhi	r4,805
 3200500:	21316504 	addi	r4,r4,-14956
 3200504:	01400044 	movi	r5,1
 3200508:	01800884 	movi	r6,34
 320050c:	3205fb00 	call	3205fb0 <fwrite>
         break;
 3200510:	00005106 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_ERR:
         fault_level = NONE;
 3200514:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted to delete a task that does not exist\n");
 3200518:	0080c974 	movhi	r2,805
 320051c:	108a6304 	addi	r2,r2,10636
 3200520:	10800017 	ldw	r2,0(r2)
 3200524:	11c00317 	ldw	r7,12(r2)
 3200528:	0100c974 	movhi	r4,805
 320052c:	21316e04 	addi	r4,r4,-14920
 3200530:	01400044 	movi	r5,1
 3200534:	01800bc4 	movi	r6,47
 3200538:	3205fb00 	call	3205fb0 <fwrite>
         break;
 320053c:	00004606 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_ISR:
         fprintf(stderr, "Attempted to delete a task from an ISR\n");
 3200540:	0080c974 	movhi	r2,805
 3200544:	108a6304 	addi	r2,r2,10636
 3200548:	10800017 	ldw	r2,0(r2)
 320054c:	11c00317 	ldw	r7,12(r2)
 3200550:	0100c974 	movhi	r4,805
 3200554:	21317a04 	addi	r4,r4,-14872
 3200558:	01400044 	movi	r5,1
 320055c:	018009c4 	movi	r6,39
 3200560:	3205fb00 	call	3205fb0 <fwrite>
         break;
 3200564:	00003c06 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_Q_FULL:
         fault_level = NONE;
 3200568:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted to post to a full message queue\n");
 320056c:	0080c974 	movhi	r2,805
 3200570:	108a6304 	addi	r2,r2,10636
 3200574:	10800017 	ldw	r2,0(r2)
 3200578:	11c00317 	ldw	r7,12(r2)
 320057c:	0100c974 	movhi	r4,805
 3200580:	21318404 	addi	r4,r4,-14832
 3200584:	01400044 	movi	r5,1
 3200588:	01800a84 	movi	r6,42
 320058c:	3205fb00 	call	3205fb0 <fwrite>
         break;
 3200590:	00003106 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_NOT_MUTEX_OWNER:
         fault_level = TASK;
 3200594:	00800044 	movi	r2,1
 3200598:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, "Attempted to post a mutex not owned by the task\n");
 320059c:	0080c974 	movhi	r2,805
 32005a0:	108a6304 	addi	r2,r2,10636
 32005a4:	10800017 	ldw	r2,0(r2)
 32005a8:	11c00317 	ldw	r7,12(r2)
 32005ac:	0100c974 	movhi	r4,805
 32005b0:	21318f04 	addi	r4,r4,-14788
 32005b4:	01400044 	movi	r5,1
 32005b8:	01800c04 	movi	r6,48
 32005bc:	3205fb00 	call	3205fb0 <fwrite>
         break;
 32005c0:	00002506 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 32005c4:	00800084 	movi	r2,2
 32005c8:	e0bffb15 	stw	r2,-20(fp)
         printf(
 32005cc:	0100c974 	movhi	r4,805
 32005d0:	21319c04 	addi	r4,r4,-14736
 32005d4:	3206de00 	call	3206de0 <printf>
"\n[MicroC/OS-II]: See STDERR for expanded diagnosis translation.");    
         fprintf(stderr, "\n[MicroC/OS-II]: Expanded Diagnosis: %s.", 
 32005d8:	0080c974 	movhi	r2,805
 32005dc:	108a6304 	addi	r2,r2,10636
 32005e0:	10800017 	ldw	r2,0(r2)
 32005e4:	11000317 	ldw	r4,12(r2)
 32005e8:	e1bffd17 	ldw	r6,-12(fp)
 32005ec:	0140c974 	movhi	r5,805
 32005f0:	2971ac04 	addi	r5,r5,-14672
 32005f4:	3204ef40 	call	3204ef4 <fprintf>
                 (char *)expanded_diagnosis_ptr);
         break;           
 32005f8:	00001706 	br	3200658 <alt_uCOSIIErrorHandler+0x44c>
      default:
         printf("\n[MicroC/OS-II]: (Not a MicroC/OS-II error) See STDERR.\n");    
 32005fc:	0100c974 	movhi	r4,805
 3200600:	2131b704 	addi	r4,r4,-14628
 3200604:	32071080 	call	3207108 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]:");
 3200608:	0080c974 	movhi	r2,805
 320060c:	108a6304 	addi	r2,r2,10636
 3200610:	10800017 	ldw	r2,0(r2)
 3200614:	11c00317 	ldw	r7,12(r2)
 3200618:	0100c974 	movhi	r4,805
 320061c:	2131c504 	addi	r4,r4,-14572
 3200620:	01400044 	movi	r5,1
 3200624:	01800404 	movi	r6,16
 3200628:	3205fb00 	call	3205fb0 <fwrite>
         fprintf(stderr, "\nError_code %d.\n", error_code);
 320062c:	0080c974 	movhi	r2,805
 3200630:	108a6304 	addi	r2,r2,10636
 3200634:	10800017 	ldw	r2,0(r2)
 3200638:	11000317 	ldw	r4,12(r2)
 320063c:	e1bffc03 	ldbu	r6,-16(fp)
 3200640:	0140c974 	movhi	r5,805
 3200644:	2971ca04 	addi	r5,r5,-14552
 3200648:	3204ef40 	call	3204ef4 <fprintf>
         perror("\n[MicroC/OS-II]: (Not a MicroC/OS-II error), ERRNO: ");
 320064c:	0100c974 	movhi	r4,805
 3200650:	2131cf04 	addi	r4,r4,-14532
 3200654:	3206dcc0 	call	3206dcc <perror>

   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */  
   switch (fault_level) {
 3200658:	e0bffb17 	ldw	r2,-20(fp)
 320065c:	e0bfff15 	stw	r2,-4(fp)
 3200660:	e0ffff17 	ldw	r3,-4(fp)
 3200664:	18800060 	cmpeqi	r2,r3,1
 3200668:	1000071e 	bne	r2,zero,3200688 <alt_uCOSIIErrorHandler+0x47c>
 320066c:	e0ffff17 	ldw	r3,-4(fp)
 3200670:	18800070 	cmpltui	r2,r3,1
 3200674:	10003f1e 	bne	r2,zero,3200774 <alt_uCOSIIErrorHandler+0x568>
 3200678:	e0ffff17 	ldw	r3,-4(fp)
 320067c:	188000a0 	cmpeqi	r2,r3,2
 3200680:	10001d1e 	bne	r2,zero,32006f8 <alt_uCOSIIErrorHandler+0x4ec>
 3200684:	00005806 	br	32007e8 <alt_uCOSIIErrorHandler+0x5dc>
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is TASK).");
 3200688:	0100c974 	movhi	r4,805
 320068c:	2131dd04 	addi	r4,r4,-14476
 3200690:	3206de00 	call	3206de0 <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is TASK");
 3200694:	0080c974 	movhi	r2,805
 3200698:	108a6304 	addi	r2,r2,10636
 320069c:	10800017 	ldw	r2,0(r2)
 32006a0:	11c00317 	ldw	r7,12(r2)
 32006a4:	0100c974 	movhi	r4,805
 32006a8:	2131ea04 	addi	r4,r4,-14424
 32006ac:	01400044 	movi	r5,1
 32006b0:	01800904 	movi	r6,36
 32006b4:	3205fb00 	call	3205fb0 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Task is being deleted.\n");
 32006b8:	0080c974 	movhi	r2,805
 32006bc:	108a6304 	addi	r2,r2,10636
 32006c0:	10800017 	ldw	r2,0(r2)
 32006c4:	11c00317 	ldw	r7,12(r2)
 32006c8:	0100c974 	movhi	r4,805
 32006cc:	2131f404 	addi	r4,r4,-14384
 32006d0:	01400044 	movi	r5,1
 32006d4:	01800a04 	movi	r6,40
 32006d8:	3205fb00 	call	3205fb0 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 32006dc:	32160cc0 	call	32160cc <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 32006e0:	01003fc4 	movi	r4,255
 32006e4:	321c1840 	call	321c184 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 32006e8:	e13ffc03 	ldbu	r4,-16(fp)
 32006ec:	000b883a 	mov	r5,zero
 32006f0:	320020c0 	call	320020c <alt_uCOSIIErrorHandler>
         break;
 32006f4:	00004806 	br	3200818 <alt_uCOSIIErrorHandler+0x60c>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 32006f8:	0100c974 	movhi	r4,805
 32006fc:	2131ff04 	addi	r4,r4,-14340
 3200700:	3206de00 	call	3206de0 <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is SYSTEM");
 3200704:	0080c974 	movhi	r2,805
 3200708:	108a6304 	addi	r2,r2,10636
 320070c:	10800017 	ldw	r2,0(r2)
 3200710:	11c00317 	ldw	r7,12(r2)
 3200714:	0100c974 	movhi	r4,805
 3200718:	21320d04 	addi	r4,r4,-14284
 320071c:	01400044 	movi	r5,1
 3200720:	01800984 	movi	r6,38
 3200724:	3205fb00 	call	3205fb0 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: FATAL Error, Restart required.");
 3200728:	0080c974 	movhi	r2,805
 320072c:	108a6304 	addi	r2,r2,10636
 3200730:	10800017 	ldw	r2,0(r2)
 3200734:	11c00317 	ldw	r7,12(r2)
 3200738:	0100c974 	movhi	r4,805
 320073c:	21321704 	addi	r4,r4,-14244
 3200740:	01400044 	movi	r5,1
 3200744:	01800bc4 	movi	r6,47
 3200748:	3205fb00 	call	3205fb0 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Locking scheduler - endless loop.\n");
 320074c:	0080c974 	movhi	r2,805
 3200750:	108a6304 	addi	r2,r2,10636
 3200754:	10800017 	ldw	r2,0(r2)
 3200758:	11c00317 	ldw	r7,12(r2)
 320075c:	0100c974 	movhi	r4,805
 3200760:	21322304 	addi	r4,r4,-14196
 3200764:	01400044 	movi	r5,1
 3200768:	01800cc4 	movi	r6,51
 320076c:	3205fb00 	call	3205fb0 <fwrite>
         while(1); /* Since scheduler is locked,loop halts all task activity.*/
 3200770:	003fff06 	br	3200770 <alt_uCOSIIErrorHandler+0x564>
         break;
      case NONE:
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is NONE");
 3200774:	0080c974 	movhi	r2,805
 3200778:	108a6304 	addi	r2,r2,10636
 320077c:	10800017 	ldw	r2,0(r2)
 3200780:	11c00317 	ldw	r7,12(r2)
 3200784:	0100c974 	movhi	r4,805
 3200788:	21323004 	addi	r4,r4,-14144
 320078c:	01400044 	movi	r5,1
 3200790:	01800904 	movi	r6,36
 3200794:	3205fb00 	call	3205fb0 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Informational error only, control"); 
 3200798:	0080c974 	movhi	r2,805
 320079c:	108a6304 	addi	r2,r2,10636
 32007a0:	10800017 	ldw	r2,0(r2)
 32007a4:	11c00317 	ldw	r7,12(r2)
 32007a8:	0100c974 	movhi	r4,805
 32007ac:	21323a04 	addi	r4,r4,-14104
 32007b0:	01400044 	movi	r5,1
 32007b4:	01800c84 	movi	r6,50
 32007b8:	3205fb00 	call	3205fb0 <fwrite>
         fprintf(stderr, 
 32007bc:	0080c974 	movhi	r2,805
 32007c0:	108a6304 	addi	r2,r2,10636
 32007c4:	10800017 	ldw	r2,0(r2)
 32007c8:	11c00317 	ldw	r7,12(r2)
 32007cc:	0100c974 	movhi	r4,805
 32007d0:	21324704 	addi	r4,r4,-14052
 32007d4:	01400044 	movi	r5,1
 32007d8:	01800f84 	movi	r6,62
 32007dc:	3205fb00 	call	3205fb0 <fwrite>
            "returned to task to complete processing at application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */
 32007e0:	32160cc0 	call	32160cc <OSSchedUnlock>
         return;   
 32007e4:	00000d06 	br	320081c <alt_uCOSIIErrorHandler+0x610>
         break;      
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
 32007e8:	0100c974 	movhi	r4,805
 32007ec:	21325704 	addi	r4,r4,-13988
 32007f0:	32071080 	call	3207108 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
 32007f4:	0080c974 	movhi	r2,805
 32007f8:	108a6304 	addi	r2,r2,10636
 32007fc:	10800017 	ldw	r2,0(r2)
 3200800:	11c00317 	ldw	r7,12(r2)
 3200804:	0100c974 	movhi	r4,805
 3200808:	21326504 	addi	r4,r4,-13932
 320080c:	01400044 	movi	r5,1
 3200810:	01800ac4 	movi	r6,43
 3200814:	3205fb00 	call	3205fb0 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 3200818:	003fff06 	br	3200818 <alt_uCOSIIErrorHandler+0x60c>
}
 320081c:	e037883a 	mov	sp,fp
 3200820:	dfc00117 	ldw	ra,4(sp)
 3200824:	df000017 	ldw	fp,0(sp)
 3200828:	dec00204 	addi	sp,sp,8
 320082c:	f800283a 	ret

03200830 <alt_NetworkErrorHandler>:

void alt_NetworkErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 3200830:	defffa04 	addi	sp,sp,-24
 3200834:	dfc00515 	stw	ra,20(sp)
 3200838:	df000415 	stw	fp,16(sp)
 320083c:	df000404 	addi	fp,sp,16
 3200840:	e17ffe15 	stw	r5,-8(fp)
 3200844:	e13ffd05 	stb	r4,-12(fp)
   FAULT_LEVEL fault_level;

   if(error_code == OS_NO_ERR)
 3200848:	e0bffd03 	ldbu	r2,-12(fp)
 320084c:	1005003a 	cmpeq	r2,r2,zero
 3200850:	1000981e 	bne	r2,zero,3200ab4 <alt_NetworkErrorHandler+0x284>
   {
      return;
   }

   fault_level = SYSTEM;   
 3200854:	00800084 	movi	r2,2
 3200858:	e0bffc15 	stw	r2,-16(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */  
 320085c:	32160400 	call	3216040 <OSSchedLock>

   if (error_code == EXPANDED_DIAGNOSIS_CODE) 
 3200860:	e0bffd03 	ldbu	r2,-12(fp)
 3200864:	10803fd8 	cmpnei	r2,r2,255
 3200868:	1000111e 	bne	r2,zero,32008b0 <alt_NetworkErrorHandler+0x80>
   {
      fault_level = SYSTEM;
 320086c:	00800084 	movi	r2,2
 3200870:	e0bffc15 	stw	r2,-16(fp)
      printf("\n[Network]: See STDERR for expanded diagnosis translation.");    
 3200874:	0100c974 	movhi	r4,805
 3200878:	21327004 	addi	r4,r4,-13888
 320087c:	3206de00 	call	3206de0 <printf>
      fprintf(stderr, "\n[Network]: %s", (char *)expanded_diagnosis_ptr);
 3200880:	0080c974 	movhi	r2,805
 3200884:	108a6304 	addi	r2,r2,10636
 3200888:	10800017 	ldw	r2,0(r2)
 320088c:	11000317 	ldw	r4,12(r2)
 3200890:	e1bffe17 	ldw	r6,-8(fp)
 3200894:	0140c974 	movhi	r5,805
 3200898:	29727f04 	addi	r5,r5,-13828
 320089c:	3204ef40 	call	3204ef4 <fprintf>
      /* Check errno also in case it has been set. */
      perror("\n[Network]:  ERRNO: ");
 32008a0:	0100c974 	movhi	r4,805
 32008a4:	21328304 	addi	r4,r4,-13812
 32008a8:	3206dcc0 	call	3206dcc <perror>
 32008ac:	00001006 	br	32008f0 <alt_NetworkErrorHandler+0xc0>
   }
   else 
   {
      fault_level = TASK;
 32008b0:	00800044 	movi	r2,1
 32008b4:	e0bffc15 	stw	r2,-16(fp)
      printf("\n[Network]: See STDERR.\n");    
 32008b8:	0100c974 	movhi	r4,805
 32008bc:	21328904 	addi	r4,r4,-13788
 32008c0:	32071080 	call	3207108 <puts>
      fprintf(stderr, "\n[Network]: Error_code %d!\n", error_code);        
 32008c4:	0080c974 	movhi	r2,805
 32008c8:	108a6304 	addi	r2,r2,10636
 32008cc:	10800017 	ldw	r2,0(r2)
 32008d0:	11000317 	ldw	r4,12(r2)
 32008d4:	e1bffd03 	ldbu	r6,-12(fp)
 32008d8:	0140c974 	movhi	r5,805
 32008dc:	29728f04 	addi	r5,r5,-13764
 32008e0:	3204ef40 	call	3204ef4 <fprintf>
      perror("\n[Network]:  ERRNO: ");
 32008e4:	0100c974 	movhi	r4,805
 32008e8:	21328304 	addi	r4,r4,-13812
 32008ec:	3206dcc0 	call	3206dcc <perror>
   }

   /* Process error based on fault level, reenable scheduler if appropriate. */     
   switch (fault_level) 
 32008f0:	e0bffc17 	ldw	r2,-16(fp)
 32008f4:	e0bfff15 	stw	r2,-4(fp)
 32008f8:	e0ffff17 	ldw	r3,-4(fp)
 32008fc:	18800060 	cmpeqi	r2,r3,1
 3200900:	1000071e 	bne	r2,zero,3200920 <alt_NetworkErrorHandler+0xf0>
 3200904:	e0ffff17 	ldw	r3,-4(fp)
 3200908:	18800070 	cmpltui	r2,r3,1
 320090c:	10003f1e 	bne	r2,zero,3200a0c <alt_NetworkErrorHandler+0x1dc>
 3200910:	e0ffff17 	ldw	r3,-4(fp)
 3200914:	188000a0 	cmpeqi	r2,r3,2
 3200918:	10001d1e 	bne	r2,zero,3200990 <alt_NetworkErrorHandler+0x160>
 320091c:	00005806 	br	3200a80 <alt_NetworkErrorHandler+0x250>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is TASK).");
 3200920:	0100c974 	movhi	r4,805
 3200924:	21329604 	addi	r4,r4,-13736
 3200928:	3206de00 	call	3206de0 <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is TASK");
 320092c:	0080c974 	movhi	r2,805
 3200930:	108a6304 	addi	r2,r2,10636
 3200934:	10800017 	ldw	r2,0(r2)
 3200938:	11c00317 	ldw	r7,12(r2)
 320093c:	0100c974 	movhi	r4,805
 3200940:	2132a204 	addi	r4,r4,-13688
 3200944:	01400044 	movi	r5,1
 3200948:	018007c4 	movi	r6,31
 320094c:	3205fb00 	call	3205fb0 <fwrite>
         fprintf(stderr, "\n[Network]: Task is being deleted.\n");
 3200950:	0080c974 	movhi	r2,805
 3200954:	108a6304 	addi	r2,r2,10636
 3200958:	10800017 	ldw	r2,0(r2)
 320095c:	11c00317 	ldw	r7,12(r2)
 3200960:	0100c974 	movhi	r4,805
 3200964:	2132aa04 	addi	r4,r4,-13656
 3200968:	01400044 	movi	r5,1
 320096c:	018008c4 	movi	r6,35
 3200970:	3205fb00 	call	3205fb0 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 3200974:	32160cc0 	call	32160cc <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 3200978:	01003fc4 	movi	r4,255
 320097c:	321c1840 	call	321c184 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 3200980:	e13ffd03 	ldbu	r4,-12(fp)
 3200984:	000b883a 	mov	r5,zero
 3200988:	320020c0 	call	320020c <alt_uCOSIIErrorHandler>
         break;
 320098c:	00004806 	br	3200ab0 <alt_NetworkErrorHandler+0x280>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 3200990:	0100c974 	movhi	r4,805
 3200994:	2132b304 	addi	r4,r4,-13620
 3200998:	3206de00 	call	3206de0 <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is SYSTEM.");
 320099c:	0080c974 	movhi	r2,805
 32009a0:	108a6304 	addi	r2,r2,10636
 32009a4:	10800017 	ldw	r2,0(r2)
 32009a8:	11c00317 	ldw	r7,12(r2)
 32009ac:	0100c974 	movhi	r4,805
 32009b0:	2132bf04 	addi	r4,r4,-13572
 32009b4:	01400044 	movi	r5,1
 32009b8:	01800884 	movi	r6,34
 32009bc:	3205fb00 	call	3205fb0 <fwrite>
         fprintf(stderr, "\n[Network]: FATAL Error, Restart required.");
 32009c0:	0080c974 	movhi	r2,805
 32009c4:	108a6304 	addi	r2,r2,10636
 32009c8:	10800017 	ldw	r2,0(r2)
 32009cc:	11c00317 	ldw	r7,12(r2)
 32009d0:	0100c974 	movhi	r4,805
 32009d4:	2132c804 	addi	r4,r4,-13536
 32009d8:	01400044 	movi	r5,1
 32009dc:	01800a84 	movi	r6,42
 32009e0:	3205fb00 	call	3205fb0 <fwrite>
         fprintf(stderr, "\n[Network]: Locking scheduler - endless loop.\n");
 32009e4:	0080c974 	movhi	r2,805
 32009e8:	108a6304 	addi	r2,r2,10636
 32009ec:	10800017 	ldw	r2,0(r2)
 32009f0:	11c00317 	ldw	r7,12(r2)
 32009f4:	0100c974 	movhi	r4,805
 32009f8:	2132d304 	addi	r4,r4,-13492
 32009fc:	01400044 	movi	r5,1
 3200a00:	01800b84 	movi	r6,46
 3200a04:	3205fb00 	call	3205fb0 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 3200a08:	003fff06 	br	3200a08 <alt_NetworkErrorHandler+0x1d8>
         break;
      case NONE:
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is NONE.");
 3200a0c:	0080c974 	movhi	r2,805
 3200a10:	108a6304 	addi	r2,r2,10636
 3200a14:	10800017 	ldw	r2,0(r2)
 3200a18:	11c00317 	ldw	r7,12(r2)
 3200a1c:	0100c974 	movhi	r4,805
 3200a20:	2132df04 	addi	r4,r4,-13444
 3200a24:	01400044 	movi	r5,1
 3200a28:	01800804 	movi	r6,32
 3200a2c:	3205fb00 	call	3205fb0 <fwrite>
         fprintf(stderr, "\n[Network]: Informational "
 3200a30:	0080c974 	movhi	r2,805
 3200a34:	108a6304 	addi	r2,r2,10636
 3200a38:	10800017 	ldw	r2,0(r2)
 3200a3c:	11c00317 	ldw	r7,12(r2)
 3200a40:	0100c974 	movhi	r4,805
 3200a44:	2132e804 	addi	r4,r4,-13408
 3200a48:	01400044 	movi	r5,1
 3200a4c:	01800d84 	movi	r6,54
 3200a50:	3205fb00 	call	3205fb0 <fwrite>
                         "error only, control returned");
         fprintf(stderr, 
 3200a54:	0080c974 	movhi	r2,805
 3200a58:	108a6304 	addi	r2,r2,10636
 3200a5c:	10800017 	ldw	r2,0(r2)
 3200a60:	11c00317 	ldw	r7,12(r2)
 3200a64:	0100c974 	movhi	r4,805
 3200a68:	2132f604 	addi	r4,r4,-13352
 3200a6c:	01400044 	movi	r5,1
 3200a70:	01800e44 	movi	r6,57
 3200a74:	3205fb00 	call	3205fb0 <fwrite>
            "to task to complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 3200a78:	32160cc0 	call	32160cc <OSSchedUnlock>
         return;
 3200a7c:	00000d06 	br	3200ab4 <alt_NetworkErrorHandler+0x284>
         break;         
      default:
         printf("\n[Network]: See STDERR (FAULT_LEVEL is unknown).\n");    
 3200a80:	0100c974 	movhi	r4,805
 3200a84:	21330504 	addi	r4,r4,-13292
 3200a88:	32071080 	call	3207108 <puts>
         fprintf(stderr, "\n[Network] FAULT_LEVEL is unknown !?!\n");
 3200a8c:	0080c974 	movhi	r2,805
 3200a90:	108a6304 	addi	r2,r2,10636
 3200a94:	10800017 	ldw	r2,0(r2)
 3200a98:	11c00317 	ldw	r7,12(r2)
 3200a9c:	0100c974 	movhi	r4,805
 3200aa0:	21331204 	addi	r4,r4,-13240
 3200aa4:	01400044 	movi	r5,1
 3200aa8:	01800984 	movi	r6,38
 3200aac:	3205fb00 	call	3205fb0 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 3200ab0:	003fff06 	br	3200ab0 <alt_NetworkErrorHandler+0x280>
}
 3200ab4:	e037883a 	mov	sp,fp
 3200ab8:	dfc00117 	ldw	ra,4(sp)
 3200abc:	df000017 	ldw	fp,0(sp)
 3200ac0:	dec00204 	addi	sp,sp,8
 3200ac4:	f800283a 	ret

03200ac8 <alt_SSSErrorHandler>:
   
   
void alt_SSSErrorHandler(INT8U error_code, 
                         void *expanded_diagnosis_ptr)
{
 3200ac8:	defff804 	addi	sp,sp,-32
 3200acc:	dfc00715 	stw	ra,28(sp)
 3200ad0:	df000615 	stw	fp,24(sp)
 3200ad4:	df000604 	addi	fp,sp,24
 3200ad8:	e17ffc15 	stw	r5,-16(fp)
 3200adc:	e13ffb05 	stb	r4,-20(fp)
   FAULT_LEVEL fault_level;
   
   if   (error_code == OS_NO_ERR)
 3200ae0:	e0bffb03 	ldbu	r2,-20(fp)
 3200ae4:	1005003a 	cmpeq	r2,r2,zero
 3200ae8:	1000ad1e 	bne	r2,zero,3200da0 <alt_SSSErrorHandler+0x2d8>
   {
      return;
   }

   fault_level = (error_code == OS_NO_ERR) ? NONE : SYSTEM;
 3200aec:	e0bffb03 	ldbu	r2,-20(fp)
 3200af0:	1004c03a 	cmpne	r2,r2,zero
 3200af4:	1000021e 	bne	r2,zero,3200b00 <alt_SSSErrorHandler+0x38>
 3200af8:	e03ffe15 	stw	zero,-8(fp)
 3200afc:	00000206 	br	3200b08 <alt_SSSErrorHandler+0x40>
 3200b00:	00800084 	movi	r2,2
 3200b04:	e0bffe15 	stw	r2,-8(fp)
 3200b08:	e0fffe17 	ldw	r3,-8(fp)
 3200b0c:	e0fffa15 	stw	r3,-24(fp)
   
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 3200b10:	32160400 	call	3216040 <OSSchedLock>
   switch (error_code)
 3200b14:	e0bffb03 	ldbu	r2,-20(fp)
 3200b18:	e0bffd15 	stw	r2,-12(fp)
 3200b1c:	e0fffd17 	ldw	r3,-12(fp)
 3200b20:	188007a0 	cmpeqi	r2,r3,30
 3200b24:	1000121e 	bne	r2,zero,3200b70 <alt_SSSErrorHandler+0xa8>
 3200b28:	e0fffd17 	ldw	r3,-12(fp)
 3200b2c:	18803fe0 	cmpeqi	r2,r3,255
 3200b30:	1000011e 	bne	r2,zero,3200b38 <alt_SSSErrorHandler+0x70>
 3200b34:	00001906 	br	3200b9c <alt_SSSErrorHandler+0xd4>
   {
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 3200b38:	00800084 	movi	r2,2
 3200b3c:	e0bffa15 	stw	r2,-24(fp)
         printf("\n[SSS]: See STDERR for expanded diagnosis translation.");    
 3200b40:	0100c974 	movhi	r4,805
 3200b44:	21331c04 	addi	r4,r4,-13200
 3200b48:	3206de00 	call	3206de0 <printf>
         fprintf(stderr, "\n[SSS]: %s", (char *)expanded_diagnosis_ptr);
 3200b4c:	0080c974 	movhi	r2,805
 3200b50:	108a6304 	addi	r2,r2,10636
 3200b54:	10800017 	ldw	r2,0(r2)
 3200b58:	11000317 	ldw	r4,12(r2)
 3200b5c:	e1bffc17 	ldw	r6,-16(fp)
 3200b60:	0140c974 	movhi	r5,805
 3200b64:	29732a04 	addi	r5,r5,-13144
 3200b68:	3204ef40 	call	3204ef4 <fprintf>
         break;
 3200b6c:	00001b06 	br	3200bdc <alt_SSSErrorHandler+0x114>
         
      case OS_Q_FULL:
         fault_level = NONE;
 3200b70:	e03ffa15 	stw	zero,-24(fp)
         fprintf(stderr,"\n[SSS]: Attempted to post to a full message queue.");
 3200b74:	0080c974 	movhi	r2,805
 3200b78:	108a6304 	addi	r2,r2,10636
 3200b7c:	10800017 	ldw	r2,0(r2)
 3200b80:	11c00317 	ldw	r7,12(r2)
 3200b84:	0100c974 	movhi	r4,805
 3200b88:	21332d04 	addi	r4,r4,-13132
 3200b8c:	01400044 	movi	r5,1
 3200b90:	01800c84 	movi	r6,50
 3200b94:	3205fb00 	call	3205fb0 <fwrite>
         break;
 3200b98:	00001006 	br	3200bdc <alt_SSSErrorHandler+0x114>
      
      default:
         fault_level = SYSTEM;
 3200b9c:	00800084 	movi	r2,2
 3200ba0:	e0bffa15 	stw	r2,-24(fp)
         printf("\n[SSS]: See STDERR.\n");    
 3200ba4:	0100c974 	movhi	r4,805
 3200ba8:	21333a04 	addi	r4,r4,-13080
 3200bac:	32071080 	call	3207108 <puts>
         fprintf(stderr, "\n[SSS]: Error_code %d!", error_code);        
 3200bb0:	0080c974 	movhi	r2,805
 3200bb4:	108a6304 	addi	r2,r2,10636
 3200bb8:	10800017 	ldw	r2,0(r2)
 3200bbc:	11000317 	ldw	r4,12(r2)
 3200bc0:	e1bffb03 	ldbu	r6,-20(fp)
 3200bc4:	0140c974 	movhi	r5,805
 3200bc8:	29733f04 	addi	r5,r5,-13060
 3200bcc:	3204ef40 	call	3204ef4 <fprintf>
         perror("\n[SSS]:  ERRNO: ");
 3200bd0:	0100c974 	movhi	r4,805
 3200bd4:	21334504 	addi	r4,r4,-13036
 3200bd8:	3206dcc0 	call	3206dcc <perror>
   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */     
   switch (fault_level) 
 3200bdc:	e0bffa17 	ldw	r2,-24(fp)
 3200be0:	e0bfff15 	stw	r2,-4(fp)
 3200be4:	e0ffff17 	ldw	r3,-4(fp)
 3200be8:	18800060 	cmpeqi	r2,r3,1
 3200bec:	1000071e 	bne	r2,zero,3200c0c <alt_SSSErrorHandler+0x144>
 3200bf0:	e0ffff17 	ldw	r3,-4(fp)
 3200bf4:	18800070 	cmpltui	r2,r3,1
 3200bf8:	10003f1e 	bne	r2,zero,3200cf8 <alt_SSSErrorHandler+0x230>
 3200bfc:	e0ffff17 	ldw	r3,-4(fp)
 3200c00:	188000a0 	cmpeqi	r2,r3,2
 3200c04:	10001d1e 	bne	r2,zero,3200c7c <alt_SSSErrorHandler+0x1b4>
 3200c08:	00005806 	br	3200d6c <alt_SSSErrorHandler+0x2a4>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is TASK).");
 3200c0c:	0100c974 	movhi	r4,805
 3200c10:	21334a04 	addi	r4,r4,-13016
 3200c14:	3206de00 	call	3206de0 <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is TASK");
 3200c18:	0080c974 	movhi	r2,805
 3200c1c:	108a6304 	addi	r2,r2,10636
 3200c20:	10800017 	ldw	r2,0(r2)
 3200c24:	11c00317 	ldw	r7,12(r2)
 3200c28:	0100c974 	movhi	r4,805
 3200c2c:	21335504 	addi	r4,r4,-12972
 3200c30:	01400044 	movi	r5,1
 3200c34:	018006c4 	movi	r6,27
 3200c38:	3205fb00 	call	3205fb0 <fwrite>
         fprintf(stderr, "\n[SSS]: Task is being deleted.\n");
 3200c3c:	0080c974 	movhi	r2,805
 3200c40:	108a6304 	addi	r2,r2,10636
 3200c44:	10800017 	ldw	r2,0(r2)
 3200c48:	11c00317 	ldw	r7,12(r2)
 3200c4c:	0100c974 	movhi	r4,805
 3200c50:	21335c04 	addi	r4,r4,-12944
 3200c54:	01400044 	movi	r5,1
 3200c58:	018007c4 	movi	r6,31
 3200c5c:	3205fb00 	call	3205fb0 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 3200c60:	32160cc0 	call	32160cc <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 3200c64:	01003fc4 	movi	r4,255
 3200c68:	321c1840 	call	321c184 <OSTaskDel>
         /* Invoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 3200c6c:	e13ffb03 	ldbu	r4,-20(fp)
 3200c70:	000b883a 	mov	r5,zero
 3200c74:	320020c0 	call	320020c <alt_uCOSIIErrorHandler>
         break;
 3200c78:	00004806 	br	3200d9c <alt_SSSErrorHandler+0x2d4>
      case SYSTEM:
          /* Total System Failure, Restart Required */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 3200c7c:	0100c974 	movhi	r4,805
 3200c80:	21336404 	addi	r4,r4,-12912
 3200c84:	3206de00 	call	3206de0 <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is SYSTEM.");
 3200c88:	0080c974 	movhi	r2,805
 3200c8c:	108a6304 	addi	r2,r2,10636
 3200c90:	10800017 	ldw	r2,0(r2)
 3200c94:	11c00317 	ldw	r7,12(r2)
 3200c98:	0100c974 	movhi	r4,805
 3200c9c:	21336f04 	addi	r4,r4,-12868
 3200ca0:	01400044 	movi	r5,1
 3200ca4:	01800784 	movi	r6,30
 3200ca8:	3205fb00 	call	3205fb0 <fwrite>
         fprintf(stderr, "\n[SSS]: FATAL Error, Restart required.");
 3200cac:	0080c974 	movhi	r2,805
 3200cb0:	108a6304 	addi	r2,r2,10636
 3200cb4:	10800017 	ldw	r2,0(r2)
 3200cb8:	11c00317 	ldw	r7,12(r2)
 3200cbc:	0100c974 	movhi	r4,805
 3200cc0:	21337704 	addi	r4,r4,-12836
 3200cc4:	01400044 	movi	r5,1
 3200cc8:	01800984 	movi	r6,38
 3200ccc:	3205fb00 	call	3205fb0 <fwrite>
         fprintf(stderr, "\n[SSS]: Locking scheduler - endless loop.\n");
 3200cd0:	0080c974 	movhi	r2,805
 3200cd4:	108a6304 	addi	r2,r2,10636
 3200cd8:	10800017 	ldw	r2,0(r2)
 3200cdc:	11c00317 	ldw	r7,12(r2)
 3200ce0:	0100c974 	movhi	r4,805
 3200ce4:	21338104 	addi	r4,r4,-12796
 3200ce8:	01400044 	movi	r5,1
 3200cec:	01800a84 	movi	r6,42
 3200cf0:	3205fb00 	call	3205fb0 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 3200cf4:	003fff06 	br	3200cf4 <alt_SSSErrorHandler+0x22c>
         break;
      case NONE:
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is NONE.");
 3200cf8:	0080c974 	movhi	r2,805
 3200cfc:	108a6304 	addi	r2,r2,10636
 3200d00:	10800017 	ldw	r2,0(r2)
 3200d04:	11c00317 	ldw	r7,12(r2)
 3200d08:	0100c974 	movhi	r4,805
 3200d0c:	21338c04 	addi	r4,r4,-12752
 3200d10:	01400044 	movi	r5,1
 3200d14:	018006c4 	movi	r6,27
 3200d18:	3205fb00 	call	3205fb0 <fwrite>
         fprintf(stderr, 
 3200d1c:	0080c974 	movhi	r2,805
 3200d20:	108a6304 	addi	r2,r2,10636
 3200d24:	10800017 	ldw	r2,0(r2)
 3200d28:	11c00317 	ldw	r7,12(r2)
 3200d2c:	0100c974 	movhi	r4,805
 3200d30:	21339304 	addi	r4,r4,-12724
 3200d34:	01400044 	movi	r5,1
 3200d38:	01800f44 	movi	r6,61
 3200d3c:	3205fb00 	call	3205fb0 <fwrite>
            "\n[SSS] Informational error only, control returned to task to ");
         fprintf(stderr,
 3200d40:	0080c974 	movhi	r2,805
 3200d44:	108a6304 	addi	r2,r2,10636
 3200d48:	10800017 	ldw	r2,0(r2)
 3200d4c:	11c00317 	ldw	r7,12(r2)
 3200d50:	0100c974 	movhi	r4,805
 3200d54:	2133a304 	addi	r4,r4,-12660
 3200d58:	01400044 	movi	r5,1
 3200d5c:	01800b84 	movi	r6,46
 3200d60:	3205fb00 	call	3205fb0 <fwrite>
            "complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 3200d64:	32160cc0 	call	32160cc <OSSchedUnlock>
         return;         
 3200d68:	00000d06 	br	3200da0 <alt_SSSErrorHandler+0x2d8>
         break;
      default:
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is Unknown).\n");
 3200d6c:	0100c974 	movhi	r4,805
 3200d70:	2133af04 	addi	r4,r4,-12612
 3200d74:	32071080 	call	3207108 <puts>
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is unknown!?!\n");
 3200d78:	0080c974 	movhi	r2,805
 3200d7c:	108a6304 	addi	r2,r2,10636
 3200d80:	10800017 	ldw	r2,0(r2)
 3200d84:	11c00317 	ldw	r7,12(r2)
 3200d88:	0100c974 	movhi	r4,805
 3200d8c:	2133bb04 	addi	r4,r4,-12564
 3200d90:	01400044 	movi	r5,1
 3200d94:	01800844 	movi	r6,33
 3200d98:	3205fb00 	call	3205fb0 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 3200d9c:	003fff06 	br	3200d9c <alt_SSSErrorHandler+0x2d4>
}
 3200da0:	e037883a 	mov	sp,fp
 3200da4:	dfc00117 	ldw	ra,4(sp)
 3200da8:	df000017 	ldw	fp,0(sp)
 3200dac:	dec00204 	addi	sp,sp,8
 3200db0:	f800283a 	ret

03200db4 <camera_init>:

// Creates the camera handler device
CAMERA camera = {CAMERA_BASE};

void camera_init()
{
 3200db4:	defffe04 	addi	sp,sp,-8
 3200db8:	dfc00115 	stw	ra,4(sp)
 3200dbc:	df000015 	stw	fp,0(sp)
 3200dc0:	d839883a 	mov	fp,sp
	IOWR_CAMERA_CONFIGURE(camera.base, 1); // Initialization
 3200dc4:	0080c974 	movhi	r2,805
 3200dc8:	10827504 	addi	r2,r2,2516
 3200dcc:	10800017 	ldw	r2,0(r2)
 3200dd0:	10800104 	addi	r2,r2,4
 3200dd4:	1007883a 	mov	r3,r2
 3200dd8:	00800044 	movi	r2,1
 3200ddc:	18800035 	stwio	r2,0(r3)
	while (!IORD_CAMERA_READY(camera.base));
 3200de0:	0080c974 	movhi	r2,805
 3200de4:	10827504 	addi	r2,r2,2516
 3200de8:	10800017 	ldw	r2,0(r2)
 3200dec:	10800104 	addi	r2,r2,4
 3200df0:	10800037 	ldwio	r2,0(r2)
 3200df4:	1005003a 	cmpeq	r2,r2,zero
 3200df8:	103ff91e 	bne	r2,zero,3200de0 <camera_init+0x2c>
	read_camera_registers(&camera);
 3200dfc:	0100c974 	movhi	r4,805
 3200e00:	21027504 	addi	r4,r4,2516
 3200e04:	3200e1c0 	call	3200e1c <read_camera_registers>
}
 3200e08:	e037883a 	mov	sp,fp
 3200e0c:	dfc00117 	ldw	ra,4(sp)
 3200e10:	df000017 	ldw	fp,0(sp)
 3200e14:	dec00204 	addi	sp,sp,8
 3200e18:	f800283a 	ret

03200e1c <read_camera_registers>:

/* Reads values of camera registers. */
void read_camera_registers(CAMERA *sp)
{
 3200e1c:	defffe04 	addi	sp,sp,-8
 3200e20:	df000115 	stw	fp,4(sp)
 3200e24:	df000104 	addi	fp,sp,4
 3200e28:	e13fff15 	stw	r4,-4(fp)
	sp->width = IORD_CAMERA_WIDTH(sp->base);
 3200e2c:	e0bfff17 	ldw	r2,-4(fp)
 3200e30:	10800017 	ldw	r2,0(r2)
 3200e34:	10800804 	addi	r2,r2,32
 3200e38:	10c00037 	ldwio	r3,0(r2)
 3200e3c:	e0bfff17 	ldw	r2,-4(fp)
 3200e40:	10c00115 	stw	r3,4(r2)
	sp->height = IORD_CAMERA_HEIGHT(sp->base);
 3200e44:	e0bfff17 	ldw	r2,-4(fp)
 3200e48:	10800017 	ldw	r2,0(r2)
 3200e4c:	10800a04 	addi	r2,r2,40
 3200e50:	10c00037 	ldwio	r3,0(r2)
 3200e54:	e0bfff17 	ldw	r2,-4(fp)
 3200e58:	10c00215 	stw	r3,8(r2)
	sp->exposure = IORD_CAMERA_EXPOSURE(sp->base);
 3200e5c:	e0bfff17 	ldw	r2,-4(fp)
 3200e60:	10800017 	ldw	r2,0(r2)
 3200e64:	10801804 	addi	r2,r2,96
 3200e68:	10c00037 	ldwio	r3,0(r2)
 3200e6c:	e0bfff17 	ldw	r2,-4(fp)
 3200e70:	10c00315 	stw	r3,12(r2)
	sp->start_column = IORD_CAMERA_START_COLUMN(sp->base);
 3200e74:	e0bfff17 	ldw	r2,-4(fp)
 3200e78:	10800017 	ldw	r2,0(r2)
 3200e7c:	10800e04 	addi	r2,r2,56
 3200e80:	10c00037 	ldwio	r3,0(r2)
 3200e84:	e0bfff17 	ldw	r2,-4(fp)
 3200e88:	10c00415 	stw	r3,16(r2)
	sp->start_row = IORD_CAMERA_START_ROW(sp->base);
 3200e8c:	e0bfff17 	ldw	r2,-4(fp)
 3200e90:	10800017 	ldw	r2,0(r2)
 3200e94:	10800c04 	addi	r2,r2,48
 3200e98:	10c00037 	ldwio	r3,0(r2)
 3200e9c:	e0bfff17 	ldw	r2,-4(fp)
 3200ea0:	10c00515 	stw	r3,20(r2)
	sp->column_size = IORD_CAMERA_COLUMN_SIZE(sp->base);
 3200ea4:	e0bfff17 	ldw	r2,-4(fp)
 3200ea8:	10800017 	ldw	r2,0(r2)
 3200eac:	10801204 	addi	r2,r2,72
 3200eb0:	10c00037 	ldwio	r3,0(r2)
 3200eb4:	e0bfff17 	ldw	r2,-4(fp)
 3200eb8:	10c00615 	stw	r3,24(r2)
	sp->row_size = IORD_CAMERA_ROW_SIZE(sp->base);
 3200ebc:	e0bfff17 	ldw	r2,-4(fp)
 3200ec0:	10800017 	ldw	r2,0(r2)
 3200ec4:	10801004 	addi	r2,r2,64
 3200ec8:	10c00037 	ldwio	r3,0(r2)
 3200ecc:	e0bfff17 	ldw	r2,-4(fp)
 3200ed0:	10c00715 	stw	r3,28(r2)
	sp->column_mode = IORD_CAMERA_COLUMN_MODE(sp->base);
 3200ed4:	e0bfff17 	ldw	r2,-4(fp)
 3200ed8:	10800017 	ldw	r2,0(r2)
 3200edc:	10801604 	addi	r2,r2,88
 3200ee0:	10c00037 	ldwio	r3,0(r2)
 3200ee4:	e0bfff17 	ldw	r2,-4(fp)
 3200ee8:	10c00815 	stw	r3,32(r2)
	sp->row_mode = IORD_CAMERA_ROW_MODE(sp->base);
 3200eec:	e0bfff17 	ldw	r2,-4(fp)
 3200ef0:	10800017 	ldw	r2,0(r2)
 3200ef4:	10801404 	addi	r2,r2,80
 3200ef8:	10c00037 	ldwio	r3,0(r2)
 3200efc:	e0bfff17 	ldw	r2,-4(fp)
 3200f00:	10c00915 	stw	r3,36(r2)
}
 3200f04:	e037883a 	mov	sp,fp
 3200f08:	df000017 	ldw	fp,0(sp)
 3200f0c:	dec00104 	addi	sp,sp,4
 3200f10:	f800283a 	ret

03200f14 <write_camera_registers>:

/* Writes values of camera registers. */
void write_camera_registers(CAMERA *sp)
{
 3200f14:	defffe04 	addi	sp,sp,-8
 3200f18:	df000115 	stw	fp,4(sp)
 3200f1c:	df000104 	addi	fp,sp,4
 3200f20:	e13fff15 	stw	r4,-4(fp)
	IOWR_CAMERA_WIDTH(sp->base, sp->width);
 3200f24:	e0bfff17 	ldw	r2,-4(fp)
 3200f28:	10800017 	ldw	r2,0(r2)
 3200f2c:	11000804 	addi	r4,r2,32
 3200f30:	e0bfff17 	ldw	r2,-4(fp)
 3200f34:	10c00117 	ldw	r3,4(r2)
 3200f38:	2005883a 	mov	r2,r4
 3200f3c:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_HEIGHT(sp->base, sp->height);
 3200f40:	e0bfff17 	ldw	r2,-4(fp)
 3200f44:	10800017 	ldw	r2,0(r2)
 3200f48:	11000a04 	addi	r4,r2,40
 3200f4c:	e0bfff17 	ldw	r2,-4(fp)
 3200f50:	10c00217 	ldw	r3,8(r2)
 3200f54:	2005883a 	mov	r2,r4
 3200f58:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_EXPOSURE(sp->base, sp->exposure);
 3200f5c:	e0bfff17 	ldw	r2,-4(fp)
 3200f60:	10800017 	ldw	r2,0(r2)
 3200f64:	11001804 	addi	r4,r2,96
 3200f68:	e0bfff17 	ldw	r2,-4(fp)
 3200f6c:	10c00317 	ldw	r3,12(r2)
 3200f70:	2005883a 	mov	r2,r4
 3200f74:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_START_COLUMN(sp->base, sp->start_column);
 3200f78:	e0bfff17 	ldw	r2,-4(fp)
 3200f7c:	10800017 	ldw	r2,0(r2)
 3200f80:	11000e04 	addi	r4,r2,56
 3200f84:	e0bfff17 	ldw	r2,-4(fp)
 3200f88:	10c00417 	ldw	r3,16(r2)
 3200f8c:	2005883a 	mov	r2,r4
 3200f90:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_START_ROW(sp->base, sp->start_row);
 3200f94:	e0bfff17 	ldw	r2,-4(fp)
 3200f98:	10800017 	ldw	r2,0(r2)
 3200f9c:	11000c04 	addi	r4,r2,48
 3200fa0:	e0bfff17 	ldw	r2,-4(fp)
 3200fa4:	10c00517 	ldw	r3,20(r2)
 3200fa8:	2005883a 	mov	r2,r4
 3200fac:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_COLUMN_SIZE(sp->base, sp->column_size);
 3200fb0:	e0bfff17 	ldw	r2,-4(fp)
 3200fb4:	10800017 	ldw	r2,0(r2)
 3200fb8:	11001204 	addi	r4,r2,72
 3200fbc:	e0bfff17 	ldw	r2,-4(fp)
 3200fc0:	10c00617 	ldw	r3,24(r2)
 3200fc4:	2005883a 	mov	r2,r4
 3200fc8:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_ROW_SIZE(sp->base, sp->row_size);
 3200fcc:	e0bfff17 	ldw	r2,-4(fp)
 3200fd0:	10800017 	ldw	r2,0(r2)
 3200fd4:	11001004 	addi	r4,r2,64
 3200fd8:	e0bfff17 	ldw	r2,-4(fp)
 3200fdc:	10c00717 	ldw	r3,28(r2)
 3200fe0:	2005883a 	mov	r2,r4
 3200fe4:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_COLUMN_MODE(sp->base, sp->column_mode);
 3200fe8:	e0bfff17 	ldw	r2,-4(fp)
 3200fec:	10800017 	ldw	r2,0(r2)
 3200ff0:	11001604 	addi	r4,r2,88
 3200ff4:	e0bfff17 	ldw	r2,-4(fp)
 3200ff8:	10c00817 	ldw	r3,32(r2)
 3200ffc:	2005883a 	mov	r2,r4
 3201000:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_ROW_MODE(sp->base, sp->row_mode);
 3201004:	e0bfff17 	ldw	r2,-4(fp)
 3201008:	10800017 	ldw	r2,0(r2)
 320100c:	11001404 	addi	r4,r2,80
 3201010:	e0bfff17 	ldw	r2,-4(fp)
 3201014:	10c00917 	ldw	r3,36(r2)
 3201018:	2005883a 	mov	r2,r4
 320101c:	10c00035 	stwio	r3,0(r2)
}
 3201020:	e037883a 	mov	sp,fp
 3201024:	df000017 	ldw	fp,0(sp)
 3201028:	dec00104 	addi	sp,sp,4
 320102c:	f800283a 	ret

03201030 <get_image_size>:

int get_image_size(CAMERA *sp, char *char_buffer)
{
 3201030:	defffb04 	addi	sp,sp,-20
 3201034:	dfc00415 	stw	ra,16(sp)
 3201038:	df000315 	stw	fp,12(sp)
 320103c:	df000304 	addi	fp,sp,12
 3201040:	e13ffe15 	stw	r4,-8(fp)
 3201044:	e17fff15 	stw	r5,-4(fp)
	int nchars = 0;
 3201048:	e03ffd15 	stw	zero,-12(fp)
	nchars = sprintf(char_buffer, "(%i,%i)", sp->width, sp->height);
 320104c:	e0bffe17 	ldw	r2,-8(fp)
 3201050:	11800117 	ldw	r6,4(r2)
 3201054:	e0bffe17 	ldw	r2,-8(fp)
 3201058:	11c00217 	ldw	r7,8(r2)
 320105c:	e13fff17 	ldw	r4,-4(fp)
 3201060:	0140c974 	movhi	r5,805
 3201064:	2973c404 	addi	r5,r5,-12528
 3201068:	32079c00 	call	32079c0 <sprintf>
 320106c:	e0bffd15 	stw	r2,-12(fp)
	return nchars;
 3201070:	e0bffd17 	ldw	r2,-12(fp)
}
 3201074:	e037883a 	mov	sp,fp
 3201078:	dfc00117 	ldw	ra,4(sp)
 320107c:	df000017 	ldw	fp,0(sp)
 3201080:	dec00204 	addi	sp,sp,8
 3201084:	f800283a 	ret

03201088 <set_image_size>:

int set_image_size(CAMERA *sp, char *char_buffer, int width, int height)
{
 3201088:	defffa04 	addi	sp,sp,-24
 320108c:	dfc00515 	stw	ra,20(sp)
 3201090:	df000415 	stw	fp,16(sp)
 3201094:	df000404 	addi	fp,sp,16
 3201098:	e13ffc15 	stw	r4,-16(fp)
 320109c:	e17ffd15 	stw	r5,-12(fp)
 32010a0:	e1bffe15 	stw	r6,-8(fp)
 32010a4:	e1ffff15 	stw	r7,-4(fp)
	sp->width = width;
 32010a8:	e0fffc17 	ldw	r3,-16(fp)
 32010ac:	e0bffe17 	ldw	r2,-8(fp)
 32010b0:	18800115 	stw	r2,4(r3)
	sp->height = height;
 32010b4:	e0fffc17 	ldw	r3,-16(fp)
 32010b8:	e0bfff17 	ldw	r2,-4(fp)
 32010bc:	18800215 	stw	r2,8(r3)
	return get_image_size(sp, char_buffer);
 32010c0:	e13ffc17 	ldw	r4,-16(fp)
 32010c4:	e17ffd17 	ldw	r5,-12(fp)
 32010c8:	32010300 	call	3201030 <get_image_size>
}
 32010cc:	e037883a 	mov	sp,fp
 32010d0:	dfc00117 	ldw	ra,4(sp)
 32010d4:	df000017 	ldw	fp,0(sp)
 32010d8:	dec00204 	addi	sp,sp,8
 32010dc:	f800283a 	ret

032010e0 <get_image_exposure>:

int get_image_exposure(CAMERA *sp, char *char_buffer)
{
 32010e0:	defffb04 	addi	sp,sp,-20
 32010e4:	dfc00415 	stw	ra,16(sp)
 32010e8:	df000315 	stw	fp,12(sp)
 32010ec:	df000304 	addi	fp,sp,12
 32010f0:	e13ffe15 	stw	r4,-8(fp)
 32010f4:	e17fff15 	stw	r5,-4(fp)
	int nchars = 0;
 32010f8:	e03ffd15 	stw	zero,-12(fp)
	nchars = sprintf(char_buffer, "%i", sp->exposure);
 32010fc:	e0bffe17 	ldw	r2,-8(fp)
 3201100:	11800317 	ldw	r6,12(r2)
 3201104:	e13fff17 	ldw	r4,-4(fp)
 3201108:	0140c974 	movhi	r5,805
 320110c:	2973c604 	addi	r5,r5,-12520
 3201110:	32079c00 	call	32079c0 <sprintf>
 3201114:	e0bffd15 	stw	r2,-12(fp)
	return nchars;
 3201118:	e0bffd17 	ldw	r2,-12(fp)
}
 320111c:	e037883a 	mov	sp,fp
 3201120:	dfc00117 	ldw	ra,4(sp)
 3201124:	df000017 	ldw	fp,0(sp)
 3201128:	dec00204 	addi	sp,sp,8
 320112c:	f800283a 	ret

03201130 <set_image_exposure>:

int set_image_exposure(CAMERA *sp, char *char_buffer, int exposure)
{
 3201130:	defffb04 	addi	sp,sp,-20
 3201134:	dfc00415 	stw	ra,16(sp)
 3201138:	df000315 	stw	fp,12(sp)
 320113c:	df000304 	addi	fp,sp,12
 3201140:	e13ffd15 	stw	r4,-12(fp)
 3201144:	e17ffe15 	stw	r5,-8(fp)
 3201148:	e1bfff15 	stw	r6,-4(fp)
	sp->exposure = exposure;
 320114c:	e0fffd17 	ldw	r3,-12(fp)
 3201150:	e0bfff17 	ldw	r2,-4(fp)
 3201154:	18800315 	stw	r2,12(r3)
	return get_image_exposure(sp, char_buffer);
 3201158:	e13ffd17 	ldw	r4,-12(fp)
 320115c:	e17ffe17 	ldw	r5,-8(fp)
 3201160:	32010e00 	call	32010e0 <get_image_exposure>
}
 3201164:	e037883a 	mov	sp,fp
 3201168:	dfc00117 	ldw	ra,4(sp)
 320116c:	df000017 	ldw	fp,0(sp)
 3201170:	dec00204 	addi	sp,sp,8
 3201174:	f800283a 	ret

03201178 <get_start_image>:

int get_start_image(CAMERA *sp, char *char_buffer)
{
 3201178:	defffb04 	addi	sp,sp,-20
 320117c:	dfc00415 	stw	ra,16(sp)
 3201180:	df000315 	stw	fp,12(sp)
 3201184:	df000304 	addi	fp,sp,12
 3201188:	e13ffe15 	stw	r4,-8(fp)
 320118c:	e17fff15 	stw	r5,-4(fp)
	int nchars = 0;
 3201190:	e03ffd15 	stw	zero,-12(fp)
	nchars = sprintf(char_buffer, "(%i,%i)", sp->start_column, sp->start_row);
 3201194:	e0bffe17 	ldw	r2,-8(fp)
 3201198:	11800417 	ldw	r6,16(r2)
 320119c:	e0bffe17 	ldw	r2,-8(fp)
 32011a0:	11c00517 	ldw	r7,20(r2)
 32011a4:	e13fff17 	ldw	r4,-4(fp)
 32011a8:	0140c974 	movhi	r5,805
 32011ac:	2973c404 	addi	r5,r5,-12528
 32011b0:	32079c00 	call	32079c0 <sprintf>
 32011b4:	e0bffd15 	stw	r2,-12(fp)
	return nchars;
 32011b8:	e0bffd17 	ldw	r2,-12(fp)
}
 32011bc:	e037883a 	mov	sp,fp
 32011c0:	dfc00117 	ldw	ra,4(sp)
 32011c4:	df000017 	ldw	fp,0(sp)
 32011c8:	dec00204 	addi	sp,sp,8
 32011cc:	f800283a 	ret

032011d0 <set_start_image>:

int set_start_image(CAMERA *sp, char *char_buffer, int start_column, int start_row)
{
 32011d0:	defffa04 	addi	sp,sp,-24
 32011d4:	dfc00515 	stw	ra,20(sp)
 32011d8:	df000415 	stw	fp,16(sp)
 32011dc:	df000404 	addi	fp,sp,16
 32011e0:	e13ffc15 	stw	r4,-16(fp)
 32011e4:	e17ffd15 	stw	r5,-12(fp)
 32011e8:	e1bffe15 	stw	r6,-8(fp)
 32011ec:	e1ffff15 	stw	r7,-4(fp)
	sp->start_column = start_column;
 32011f0:	e0fffc17 	ldw	r3,-16(fp)
 32011f4:	e0bffe17 	ldw	r2,-8(fp)
 32011f8:	18800415 	stw	r2,16(r3)
	sp->start_row = start_row;
 32011fc:	e0fffc17 	ldw	r3,-16(fp)
 3201200:	e0bfff17 	ldw	r2,-4(fp)
 3201204:	18800515 	stw	r2,20(r3)
	return get_start_image(sp, char_buffer);
 3201208:	e13ffc17 	ldw	r4,-16(fp)
 320120c:	e17ffd17 	ldw	r5,-12(fp)
 3201210:	32011780 	call	3201178 <get_start_image>
}
 3201214:	e037883a 	mov	sp,fp
 3201218:	dfc00117 	ldw	ra,4(sp)
 320121c:	df000017 	ldw	fp,0(sp)
 3201220:	dec00204 	addi	sp,sp,8
 3201224:	f800283a 	ret

03201228 <get_sensor_size>:

int get_sensor_size(CAMERA *sp, char *char_buffer)
{
 3201228:	defffb04 	addi	sp,sp,-20
 320122c:	dfc00415 	stw	ra,16(sp)
 3201230:	df000315 	stw	fp,12(sp)
 3201234:	df000304 	addi	fp,sp,12
 3201238:	e13ffe15 	stw	r4,-8(fp)
 320123c:	e17fff15 	stw	r5,-4(fp)
	int nchars = 0;
 3201240:	e03ffd15 	stw	zero,-12(fp)
	nchars = sprintf(char_buffer, "(%i,%i)", sp->column_size, sp->row_size);
 3201244:	e0bffe17 	ldw	r2,-8(fp)
 3201248:	11800617 	ldw	r6,24(r2)
 320124c:	e0bffe17 	ldw	r2,-8(fp)
 3201250:	11c00717 	ldw	r7,28(r2)
 3201254:	e13fff17 	ldw	r4,-4(fp)
 3201258:	0140c974 	movhi	r5,805
 320125c:	2973c404 	addi	r5,r5,-12528
 3201260:	32079c00 	call	32079c0 <sprintf>
 3201264:	e0bffd15 	stw	r2,-12(fp)
	return nchars;
 3201268:	e0bffd17 	ldw	r2,-12(fp)
}
 320126c:	e037883a 	mov	sp,fp
 3201270:	dfc00117 	ldw	ra,4(sp)
 3201274:	df000017 	ldw	fp,0(sp)
 3201278:	dec00204 	addi	sp,sp,8
 320127c:	f800283a 	ret

03201280 <set_sensor_size>:

int set_sensor_size(CAMERA *sp, char *char_buffer, int column_size, int row_size)
{
 3201280:	defffa04 	addi	sp,sp,-24
 3201284:	dfc00515 	stw	ra,20(sp)
 3201288:	df000415 	stw	fp,16(sp)
 320128c:	df000404 	addi	fp,sp,16
 3201290:	e13ffc15 	stw	r4,-16(fp)
 3201294:	e17ffd15 	stw	r5,-12(fp)
 3201298:	e1bffe15 	stw	r6,-8(fp)
 320129c:	e1ffff15 	stw	r7,-4(fp)
	sp->column_size = column_size;
 32012a0:	e0fffc17 	ldw	r3,-16(fp)
 32012a4:	e0bffe17 	ldw	r2,-8(fp)
 32012a8:	18800615 	stw	r2,24(r3)
	sp->row_size = row_size;
 32012ac:	e0fffc17 	ldw	r3,-16(fp)
 32012b0:	e0bfff17 	ldw	r2,-4(fp)
 32012b4:	18800715 	stw	r2,28(r3)
	return get_sensor_size(sp, char_buffer);
 32012b8:	e13ffc17 	ldw	r4,-16(fp)
 32012bc:	e17ffd17 	ldw	r5,-12(fp)
 32012c0:	32012280 	call	3201228 <get_sensor_size>
}
 32012c4:	e037883a 	mov	sp,fp
 32012c8:	dfc00117 	ldw	ra,4(sp)
 32012cc:	df000017 	ldw	fp,0(sp)
 32012d0:	dec00204 	addi	sp,sp,8
 32012d4:	f800283a 	ret

032012d8 <get_sensor_mode>:

int get_sensor_mode(CAMERA *sp, char *char_buffer)
{
 32012d8:	defffb04 	addi	sp,sp,-20
 32012dc:	dfc00415 	stw	ra,16(sp)
 32012e0:	df000315 	stw	fp,12(sp)
 32012e4:	df000304 	addi	fp,sp,12
 32012e8:	e13ffe15 	stw	r4,-8(fp)
 32012ec:	e17fff15 	stw	r5,-4(fp)
	int nchars = 0;
 32012f0:	e03ffd15 	stw	zero,-12(fp)
	nchars = sprintf(char_buffer, "(%i,%i)", sp->column_mode, sp->row_mode);
 32012f4:	e0bffe17 	ldw	r2,-8(fp)
 32012f8:	11800817 	ldw	r6,32(r2)
 32012fc:	e0bffe17 	ldw	r2,-8(fp)
 3201300:	11c00917 	ldw	r7,36(r2)
 3201304:	e13fff17 	ldw	r4,-4(fp)
 3201308:	0140c974 	movhi	r5,805
 320130c:	2973c404 	addi	r5,r5,-12528
 3201310:	32079c00 	call	32079c0 <sprintf>
 3201314:	e0bffd15 	stw	r2,-12(fp)
	return nchars;
 3201318:	e0bffd17 	ldw	r2,-12(fp)
}
 320131c:	e037883a 	mov	sp,fp
 3201320:	dfc00117 	ldw	ra,4(sp)
 3201324:	df000017 	ldw	fp,0(sp)
 3201328:	dec00204 	addi	sp,sp,8
 320132c:	f800283a 	ret

03201330 <set_sensor_mode>:

int set_sensor_mode(CAMERA *sp, char *char_buffer, int column_mode, int row_mode)
{
 3201330:	defffa04 	addi	sp,sp,-24
 3201334:	dfc00515 	stw	ra,20(sp)
 3201338:	df000415 	stw	fp,16(sp)
 320133c:	df000404 	addi	fp,sp,16
 3201340:	e13ffc15 	stw	r4,-16(fp)
 3201344:	e17ffd15 	stw	r5,-12(fp)
 3201348:	e1bffe15 	stw	r6,-8(fp)
 320134c:	e1ffff15 	stw	r7,-4(fp)
	sp->column_mode = column_mode;
 3201350:	e0fffc17 	ldw	r3,-16(fp)
 3201354:	e0bffe17 	ldw	r2,-8(fp)
 3201358:	18800815 	stw	r2,32(r3)
	sp->row_mode = row_mode;
 320135c:	e0fffc17 	ldw	r3,-16(fp)
 3201360:	e0bfff17 	ldw	r2,-4(fp)
 3201364:	18800915 	stw	r2,36(r3)
	return get_sensor_mode(sp, char_buffer);
 3201368:	e13ffc17 	ldw	r4,-16(fp)
 320136c:	e17ffd17 	ldw	r5,-12(fp)
 3201370:	32012d80 	call	32012d8 <get_sensor_mode>
}
 3201374:	e037883a 	mov	sp,fp
 3201378:	dfc00117 	ldw	ra,4(sp)
 320137c:	df000017 	ldw	fp,0(sp)
 3201380:	dec00204 	addi	sp,sp,8
 3201384:	f800283a 	ret

03201388 <camera_configure>:

/* Configures the camera sensor. */
int camera_configure(CAMERA *sp, char *char_buffer)
{
 3201388:	defffb04 	addi	sp,sp,-20
 320138c:	dfc00415 	stw	ra,16(sp)
 3201390:	df000315 	stw	fp,12(sp)
 3201394:	df000304 	addi	fp,sp,12
 3201398:	e13ffe15 	stw	r4,-8(fp)
 320139c:	e17fff15 	stw	r5,-4(fp)
	printf("Configuring camera sensor...\n");
 32013a0:	0100c974 	movhi	r4,805
 32013a4:	2133c704 	addi	r4,r4,-12516
 32013a8:	32071080 	call	3207108 <puts>
	write_camera_registers(sp);
 32013ac:	e13ffe17 	ldw	r4,-8(fp)
 32013b0:	3200f140 	call	3200f14 <write_camera_registers>
	IOWR_CAMERA_CONFIGURE(sp->base, 0);
 32013b4:	e0bffe17 	ldw	r2,-8(fp)
 32013b8:	10800017 	ldw	r2,0(r2)
 32013bc:	10800104 	addi	r2,r2,4
 32013c0:	10000035 	stwio	zero,0(r2)
	IOWR_CAMERA_CONFIGURE(sp->base, 1);
 32013c4:	e0bffe17 	ldw	r2,-8(fp)
 32013c8:	10800017 	ldw	r2,0(r2)
 32013cc:	10800104 	addi	r2,r2,4
 32013d0:	1007883a 	mov	r3,r2
 32013d4:	00800044 	movi	r2,1
 32013d8:	18800035 	stwio	r2,0(r3)
	while (!IORD_CAMERA_READY(sp->base));
 32013dc:	e0bffe17 	ldw	r2,-8(fp)
 32013e0:	10800017 	ldw	r2,0(r2)
 32013e4:	10800104 	addi	r2,r2,4
 32013e8:	10800037 	ldwio	r2,0(r2)
 32013ec:	1005003a 	cmpeq	r2,r2,zero
 32013f0:	103ffa1e 	bne	r2,zero,32013dc <camera_configure+0x54>
	printf("Camera sensor configured.\n");
 32013f4:	0100c974 	movhi	r4,805
 32013f8:	2133cf04 	addi	r4,r4,-12484
 32013fc:	32071080 	call	3207108 <puts>

	int nchars = 0;
 3201400:	e03ffd15 	stw	zero,-12(fp)
	nchars = sprintf(char_buffer, "Camera sensor configured.");
 3201404:	e0bfff17 	ldw	r2,-4(fp)
 3201408:	00c0c974 	movhi	r3,805
 320140c:	18f3cf04 	addi	r3,r3,-12484
 3201410:	1009883a 	mov	r4,r2
 3201414:	180b883a 	mov	r5,r3
 3201418:	01800684 	movi	r6,26
 320141c:	3206ad00 	call	3206ad0 <memcpy>
 3201420:	00800644 	movi	r2,25
 3201424:	e0bffd15 	stw	r2,-12(fp)
	return nchars;
 3201428:	e0bffd17 	ldw	r2,-12(fp)
}
 320142c:	e037883a 	mov	sp,fp
 3201430:	dfc00117 	ldw	ra,4(sp)
 3201434:	df000017 	ldw	fp,0(sp)
 3201438:	dec00204 	addi	sp,sp,8
 320143c:	f800283a 	ret

03201440 <select_sensor_output>:

/* Selects the sensor output. */
int select_sensor_output(CAMERA *sp, char *char_buffer, int output)
{
 3201440:	defffa04 	addi	sp,sp,-24
 3201444:	dfc00515 	stw	ra,20(sp)
 3201448:	df000415 	stw	fp,16(sp)
 320144c:	df000404 	addi	fp,sp,16
 3201450:	e13ffd15 	stw	r4,-12(fp)
 3201454:	e17ffe15 	stw	r5,-8(fp)
 3201458:	e1bfff15 	stw	r6,-4(fp)
	int nchars = 0;
 320145c:	e03ffc15 	stw	zero,-16(fp)
	if ((output < 7) && (output != 3)) {
 3201460:	e0bfff17 	ldw	r2,-4(fp)
 3201464:	108001c8 	cmpgei	r2,r2,7
 3201468:	1000101e 	bne	r2,zero,32014ac <select_sensor_output+0x6c>
 320146c:	e0bfff17 	ldw	r2,-4(fp)
 3201470:	108000e0 	cmpeqi	r2,r2,3
 3201474:	10000d1e 	bne	r2,zero,32014ac <select_sensor_output+0x6c>
		IOWR_CAMERA_CAPTURE_SELECT_SENSOR(sp->base, output);
 3201478:	e0bffd17 	ldw	r2,-12(fp)
 320147c:	10800017 	ldw	r2,0(r2)
 3201480:	10800304 	addi	r2,r2,12
 3201484:	1007883a 	mov	r3,r2
 3201488:	e0bfff17 	ldw	r2,-4(fp)
 320148c:	18800035 	stwio	r2,0(r3)
		nchars = sprintf(char_buffer, "%i", output);
 3201490:	e13ffe17 	ldw	r4,-8(fp)
 3201494:	0140c974 	movhi	r5,805
 3201498:	2973c604 	addi	r5,r5,-12520
 320149c:	e1bfff17 	ldw	r6,-4(fp)
 32014a0:	32079c00 	call	32079c0 <sprintf>
 32014a4:	e0bffc15 	stw	r2,-16(fp)

/* Selects the sensor output. */
int select_sensor_output(CAMERA *sp, char *char_buffer, int output)
{
	int nchars = 0;
	if ((output < 7) && (output != 3)) {
 32014a8:	00000906 	br	32014d0 <select_sensor_output+0x90>
		IOWR_CAMERA_CAPTURE_SELECT_SENSOR(sp->base, output);
		nchars = sprintf(char_buffer, "%i", output);
	}
	else {
		nchars = sprintf(char_buffer, "Wrong sensor output.");
 32014ac:	e0bffe17 	ldw	r2,-8(fp)
 32014b0:	00c0c974 	movhi	r3,805
 32014b4:	18f3d604 	addi	r3,r3,-12456
 32014b8:	1009883a 	mov	r4,r2
 32014bc:	180b883a 	mov	r5,r3
 32014c0:	01800544 	movi	r6,21
 32014c4:	3206ad00 	call	3206ad0 <memcpy>
 32014c8:	00800504 	movi	r2,20
 32014cc:	e0bffc15 	stw	r2,-16(fp)
	}
	return nchars;
 32014d0:	e0bffc17 	ldw	r2,-16(fp)
}
 32014d4:	e037883a 	mov	sp,fp
 32014d8:	dfc00117 	ldw	ra,4(sp)
 32014dc:	df000017 	ldw	fp,0(sp)
 32014e0:	dec00204 	addi	sp,sp,8
 32014e4:	f800283a 	ret

032014e8 <select_vga_output>:

/* Selects the vga output. */
int select_vga_output(CAMERA *sp, char *char_buffer)
{
 32014e8:	defffb04 	addi	sp,sp,-20
 32014ec:	dfc00415 	stw	ra,16(sp)
 32014f0:	df000315 	stw	fp,12(sp)
 32014f4:	df000304 	addi	fp,sp,12
 32014f8:	e13ffe15 	stw	r4,-8(fp)
 32014fc:	e17fff15 	stw	r5,-4(fp)
	static int vga = 0;

	printf("Configuring VGA...\n");
 3201500:	0100c974 	movhi	r4,805
 3201504:	2133dc04 	addi	r4,r4,-12432
 3201508:	32071080 	call	3207108 <puts>
	vga = ~vga;
 320150c:	d0a89117 	ldw	r2,-23996(gp)
 3201510:	0084303a 	nor	r2,zero,r2
 3201514:	d0a89115 	stw	r2,-23996(gp)
	IOWR_CAMERA_CAPTURE_SELECT_VGA(sp->base, vga);
 3201518:	e0bffe17 	ldw	r2,-8(fp)
 320151c:	10800017 	ldw	r2,0(r2)
 3201520:	10800204 	addi	r2,r2,8
 3201524:	d0e89117 	ldw	r3,-23996(gp)
 3201528:	10c00035 	stwio	r3,0(r2)
	IOWR_CAMERA_CONFIGURE(sp->base, 0);
 320152c:	e0bffe17 	ldw	r2,-8(fp)
 3201530:	10800017 	ldw	r2,0(r2)
 3201534:	10800104 	addi	r2,r2,4
 3201538:	10000035 	stwio	zero,0(r2)
	IOWR_CAMERA_CONFIGURE(sp->base, 1);
 320153c:	e0bffe17 	ldw	r2,-8(fp)
 3201540:	10800017 	ldw	r2,0(r2)
 3201544:	10800104 	addi	r2,r2,4
 3201548:	1007883a 	mov	r3,r2
 320154c:	00800044 	movi	r2,1
 3201550:	18800035 	stwio	r2,0(r3)
	while (!IORD_CAMERA_READY(sp->base));
 3201554:	e0bffe17 	ldw	r2,-8(fp)
 3201558:	10800017 	ldw	r2,0(r2)
 320155c:	10800104 	addi	r2,r2,4
 3201560:	10800037 	ldwio	r2,0(r2)
 3201564:	1005003a 	cmpeq	r2,r2,zero
 3201568:	103ffa1e 	bne	r2,zero,3201554 <select_vga_output+0x6c>
	if (vga) IOWR_CAMERA_CAPTURE_START(sp->base);
 320156c:	d0a89117 	ldw	r2,-23996(gp)
 3201570:	1005003a 	cmpeq	r2,r2,zero
 3201574:	1000061e 	bne	r2,zero,3201590 <select_vga_output+0xa8>
 3201578:	e0bffe17 	ldw	r2,-8(fp)
 320157c:	10800017 	ldw	r2,0(r2)
 3201580:	1007883a 	mov	r3,r2
 3201584:	00800044 	movi	r2,1
 3201588:	18800035 	stwio	r2,0(r3)
 320158c:	00000306 	br	320159c <select_vga_output+0xb4>
	else IOWR_CAMERA_CAPTURE_STOP(sp->base);
 3201590:	e0bffe17 	ldw	r2,-8(fp)
 3201594:	10800017 	ldw	r2,0(r2)
 3201598:	10000035 	stwio	zero,0(r2)
	printf("VGA output configured.\n");
 320159c:	0100c974 	movhi	r4,805
 32015a0:	2133e104 	addi	r4,r4,-12412
 32015a4:	32071080 	call	3207108 <puts>

	int nchars = 0;
 32015a8:	e03ffd15 	stw	zero,-12(fp)
	nchars = sprintf(char_buffer, "VGA output configured.");
 32015ac:	e0bfff17 	ldw	r2,-4(fp)
 32015b0:	00c0c974 	movhi	r3,805
 32015b4:	18f3e104 	addi	r3,r3,-12412
 32015b8:	1009883a 	mov	r4,r2
 32015bc:	180b883a 	mov	r5,r3
 32015c0:	018005c4 	movi	r6,23
 32015c4:	3206ad00 	call	3206ad0 <memcpy>
 32015c8:	00800584 	movi	r2,22
 32015cc:	e0bffd15 	stw	r2,-12(fp)
	return nchars;
 32015d0:	e0bffd17 	ldw	r2,-12(fp)
}
 32015d4:	e037883a 	mov	sp,fp
 32015d8:	dfc00117 	ldw	ra,4(sp)
 32015dc:	df000017 	ldw	fp,0(sp)
 32015e0:	dec00204 	addi	sp,sp,8
 32015e4:	f800283a 	ret

032015e8 <write_in_lcd>:
OS_STK    task1_stk[TASK_STACKSIZE];

#define TASK1_PRIORITY      10

/* Print a message in LCD */
void write_in_lcd(char* msg) {
 32015e8:	defffc04 	addi	sp,sp,-16
 32015ec:	dfc00315 	stw	ra,12(sp)
 32015f0:	df000215 	stw	fp,8(sp)
 32015f4:	df000204 	addi	fp,sp,8
 32015f8:	e13fff15 	stw	r4,-4(fp)
	FILE* fp;
	fp = fopen ("/dev/lcd", "w");
 32015fc:	0100c974 	movhi	r4,805
 3201600:	2133e704 	addi	r4,r4,-12388
 3201604:	0140c974 	movhi	r5,805
 3201608:	2973ea04 	addi	r5,r5,-12376
 320160c:	3204ed80 	call	3204ed8 <fopen>
 3201610:	e0bffe15 	stw	r2,-8(fp)
	if (fp!=NULL) {
 3201614:	e0bffe17 	ldw	r2,-8(fp)
 3201618:	1005003a 	cmpeq	r2,r2,zero
 320161c:	1000051e 	bne	r2,zero,3201634 <write_in_lcd+0x4c>
		fprintf(fp, "%s",msg);
 3201620:	e13fff17 	ldw	r4,-4(fp)
 3201624:	e17ffe17 	ldw	r5,-8(fp)
 3201628:	3204fc80 	call	3204fc8 <fputs>
		fclose (fp);
 320162c:	e13ffe17 	ldw	r4,-8(fp)
 3201630:	32048e00 	call	32048e0 <fclose>
	}
}
 3201634:	e037883a 	mov	sp,fp
 3201638:	dfc00117 	ldw	ra,4(sp)
 320163c:	df000017 	ldw	fp,0(sp)
 3201640:	dec00204 	addi	sp,sp,8
 3201644:	f800283a 	ret

03201648 <task1>:

// TODO: Group tasks in tasks.c file

/* Prints the time of execution in seconds from reset */
void task1(void* pdata) {
 3201648:	defff404 	addi	sp,sp,-48
 320164c:	dfc00b15 	stw	ra,44(sp)
 3201650:	df000a15 	stw	fp,40(sp)
 3201654:	df000a04 	addi	fp,sp,40
 3201658:	e13fff15 	stw	r4,-4(fp)
	// Camera initialization
	camera_init();
 320165c:	3200db40 	call	3200db4 <camera_init>
	// Trackers initialization
	trackers_init();
 3201660:	3203c080 	call	3203c08 <trackers_init>

	char msg[16];

	while (1) {
		// Show time of execution in seconds
		i++;
 3201664:	e0bffa17 	ldw	r2,-24(fp)
 3201668:	10800044 	addi	r2,r2,1
 320166c:	e0bffa15 	stw	r2,-24(fp)
		printf("%is Run...\r", i);
 3201670:	0100c974 	movhi	r4,805
 3201674:	2133eb04 	addi	r4,r4,-12372
 3201678:	e17ffa17 	ldw	r5,-24(fp)
 320167c:	3206de00 	call	3206de0 <printf>

		// Show in LCD: IP and TIME
		sprintf(msg, "#%d.%d.%d.%d\n%is Run...\n", IPADDR0, IPADDR1, IPADDR2, IPADDR3, i);
 3201680:	e13ffb04 	addi	r4,fp,-20
 3201684:	00800144 	movi	r2,5
 3201688:	d8800015 	stw	r2,0(sp)
 320168c:	00803544 	movi	r2,213
 3201690:	d8800115 	stw	r2,4(sp)
 3201694:	e0bffa17 	ldw	r2,-24(fp)
 3201698:	d8800215 	stw	r2,8(sp)
 320169c:	0140c974 	movhi	r5,805
 32016a0:	2973ee04 	addi	r5,r5,-12360
 32016a4:	01802b04 	movi	r6,172
 32016a8:	01c004c4 	movi	r7,19
 32016ac:	32079c00 	call	32079c0 <sprintf>
		write_in_lcd(msg);
 32016b0:	e13ffb04 	addi	r4,fp,-20
 32016b4:	32015e80 	call	32015e8 <write_in_lcd>

		OSTimeDlyHMSM(0, 0, 1, 0);
 32016b8:	0009883a 	mov	r4,zero
 32016bc:	000b883a 	mov	r5,zero
 32016c0:	01800044 	movi	r6,1
 32016c4:	000f883a 	mov	r7,zero
 32016c8:	321d3c80 	call	321d3c8 <OSTimeDlyHMSM>
	}
 32016cc:	003fe506 	br	3201664 <task1+0x1c>

032016d0 <SSSInitialTask>:
 * NicheStack is initialized from a task, so that RTOS will have started, and
 * I/O drivers are available.  Two tasks are created:
 *     "Inet main"  task with priority 2
 *     "clock tick" task with priority 3
 */
void SSSInitialTask(void *task_data) {
 32016d0:	defff704 	addi	sp,sp,-36
 32016d4:	dfc00815 	stw	ra,32(sp)
 32016d8:	df000715 	stw	fp,28(sp)
 32016dc:	df000704 	addi	fp,sp,28
 32016e0:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	alt_iniche_init();
 32016e4:	322b6180 	call	322b618 <alt_iniche_init>

	netmain();
 32016e8:	32268600 	call	3226860 <netmain>

	/* Wait for the network stack to be ready before proceeding.
	 * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
	 */
	while (!iniche_net_ready) TK_SLEEP(1);
 32016ec:	00000206 	br	32016f8 <SSSInitialTask+0x28>
 32016f0:	01000084 	movi	r4,2
 32016f4:	321d27c0 	call	321d27c <OSTimeDly>
 32016f8:	0080c974 	movhi	r2,805
 32016fc:	10932504 	addi	r2,r2,19604
 3201700:	10800017 	ldw	r2,0(r2)
 3201704:	1005003a 	cmpeq	r2,r2,zero
 3201708:	103ff91e 	bne	r2,zero,32016f0 <SSSInitialTask+0x20>


	/* Application Specific Task Launching Code Block Begin */

	printf("\nSimple Socket Server starting up\n");
 320170c:	0100c974 	movhi	r4,805
 3201710:	2133fb04 	addi	r4,r4,-12308
 3201714:	32071080 	call	3207108 <puts>

	/* Create the main simple socket server task. */
	TK_NEWTASK(&ssstask);
 3201718:	0100c974 	movhi	r4,805
 320171c:	21027f04 	addi	r4,r4,2556
 3201720:	322b2d80 	call	322b2d8 <TK_NEWTASK>

	/* Create the other tasks */
	//SSSCreateTasks();
	OSTaskCreateExt(task1,
 3201724:	0180c974 	movhi	r6,805
 3201728:	319da404 	addi	r6,r6,30352
 320172c:	00800284 	movi	r2,10
 3201730:	d8800015 	stw	r2,0(sp)
 3201734:	0080c974 	movhi	r2,805
 3201738:	1095a504 	addi	r2,r2,22164
 320173c:	d8800115 	stw	r2,4(sp)
 3201740:	00820004 	movi	r2,2048
 3201744:	d8800215 	stw	r2,8(sp)
 3201748:	d8000315 	stw	zero,12(sp)
 320174c:	d8000415 	stw	zero,16(sp)
 3201750:	0100c834 	movhi	r4,800
 3201754:	21059204 	addi	r4,r4,5704
 3201758:	000b883a 	mov	r5,zero
 320175c:	01c00284 	movi	r7,10
 3201760:	321bf840 	call	321bf84 <OSTaskCreateExt>

	/* Application Specific Task Launching Code Block End */


	/*This task is deleted because there is no need for it to run again */
	error_code = OSTaskDel(OS_PRIO_SELF);
 3201764:	01003fc4 	movi	r4,255
 3201768:	321c1840 	call	321c184 <OSTaskDel>
 320176c:	e0bffe05 	stb	r2,-8(fp)
	alt_uCOSIIErrorHandler(error_code, 0);
 3201770:	e13ffe03 	ldbu	r4,-8(fp)
 3201774:	000b883a 	mov	r5,zero
 3201778:	320020c0 	call	320020c <alt_uCOSIIErrorHandler>

	while (1); /* Correct Program Flow should never get here */
 320177c:	003fff06 	br	320177c <SSSInitialTask+0xac>

03201780 <main>:
}

/* Main creates a single task, SSSInitialTask, and starts task scheduler.
 */
int main(int argc, char* argv[], char* envp[]) {
 3201780:	defff504 	addi	sp,sp,-44
 3201784:	dfc00a15 	stw	ra,40(sp)
 3201788:	df000915 	stw	fp,36(sp)
 320178c:	df000904 	addi	fp,sp,36
 3201790:	e13ffd15 	stw	r4,-12(fp)
 3201794:	e17ffe15 	stw	r5,-8(fp)
 3201798:	e1bfff15 	stw	r6,-4(fp)

	INT8U error_code;

	/* Clear the RTOS timer */
	OSTimeSet(0);
 320179c:	0009883a 	mov	r4,zero
 32017a0:	321d7b00 	call	321d7b0 <OSTimeSet>

	/* SSSInitialTask will initialize the NicheStack TCP/IP Stack
	 * and then initialize the rest of the Simple Socket Server example
	 * RTOS structures and tasks.
	 */
	error_code = OSTaskCreateExt(SSSInitialTask,
 32017a4:	0180c9b4 	movhi	r6,806
 32017a8:	31a5a504 	addi	r6,r6,-26988
 32017ac:	00800144 	movi	r2,5
 32017b0:	d8800015 	stw	r2,0(sp)
 32017b4:	0080c974 	movhi	r2,805
 32017b8:	109da504 	addi	r2,r2,30356
 32017bc:	d8800115 	stw	r2,4(sp)
 32017c0:	00820004 	movi	r2,2048
 32017c4:	d8800215 	stw	r2,8(sp)
 32017c8:	d8000315 	stw	zero,12(sp)
 32017cc:	d8000415 	stw	zero,16(sp)
 32017d0:	0100c834 	movhi	r4,800
 32017d4:	2105b404 	addi	r4,r4,5840
 32017d8:	000b883a 	mov	r5,zero
 32017dc:	01c00144 	movi	r7,5
 32017e0:	321bf840 	call	321bf84 <OSTaskCreateExt>
 32017e4:	e0bffc05 	stb	r2,-16(fp)
			SSS_INITIAL_TASK_PRIORITY,
			SSSInitialTaskStk,
			TASK_STACKSIZE,
			NULL,
			0);
	alt_uCOSIIErrorHandler(error_code, 0);
 32017e8:	e13ffc03 	ldbu	r4,-16(fp)
 32017ec:	000b883a 	mov	r5,zero
 32017f0:	320020c0 	call	320020c <alt_uCOSIIErrorHandler>

	/*
	 * As with all MicroC/OS-II designs, once the initial thread(s) and
	 * associated RTOS resources are declared, we start the RTOS. That's it!
	 */
	OSStart();
 32017f4:	32161b00 	call	32161b0 <OSStart>

	while(1); /* Correct Program Flow never gets here. */
 32017f8:	003fff06 	br	32017f8 <main+0x78>

032017fc <get_mac_addr>:
* Read the MAC address in a board specific way. Prompt user to enter serial 
* number to generate MAC address if failed to read from flash.
*
*/
int get_mac_addr(NET net, unsigned char mac_addr[6])
{
 32017fc:	defff804 	addi	sp,sp,-32
 3201800:	dfc00715 	stw	ra,28(sp)
 3201804:	df000615 	stw	fp,24(sp)
 3201808:	df000604 	addi	fp,sp,24
 320180c:	e13ffe15 	stw	r4,-8(fp)
 3201810:	e17fff15 	stw	r5,-4(fp)

	error_t error = 0;
 3201814:	e03ffd15 	stw	zero,-12(fp)

#ifdef FIXED_MAC
	mac_addr[0] = DEFAULT_MAC_0;
 3201818:	e0bfff17 	ldw	r2,-4(fp)
 320181c:	10000005 	stb	zero,0(r2)
	mac_addr[1] = DEFAULT_MAC_1;
 3201820:	e0bfff17 	ldw	r2,-4(fp)
 3201824:	10c00044 	addi	r3,r2,1
 3201828:	008001c4 	movi	r2,7
 320182c:	18800005 	stb	r2,0(r3)
	mac_addr[2] = DEFAULT_MAC_2;
 3201830:	e0bfff17 	ldw	r2,-4(fp)
 3201834:	10c00084 	addi	r3,r2,2
 3201838:	00bffb44 	movi	r2,-19
 320183c:	18800005 	stb	r2,0(r3)
	mac_addr[3] = DEFAULT_MAC_3;
 3201840:	e0bfff17 	ldw	r2,-4(fp)
 3201844:	10c000c4 	addi	r3,r2,3
 3201848:	00bfffc4 	movi	r2,-1
 320184c:	18800005 	stb	r2,0(r3)
	mac_addr[4] = DEFAULT_MAC_4;
 3201850:	e0bfff17 	ldw	r2,-4(fp)
 3201854:	10c00104 	addi	r3,r2,4
 3201858:	00801ac4 	movi	r2,107
 320185c:	18800005 	stb	r2,0(r3)
	mac_addr[5] = DEFAULT_MAC_5;
 3201860:	e0bfff17 	ldw	r2,-4(fp)
 3201864:	10c00144 	addi	r3,r2,5
 3201868:	00bff1c4 	movi	r2,-57
 320186c:	18800005 	stb	r2,0(r3)

	printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n",
 3201870:	e0bfff17 	ldw	r2,-4(fp)
 3201874:	10800003 	ldbu	r2,0(r2)
 3201878:	11403fcc 	andi	r5,r2,255
 320187c:	e0bfff17 	ldw	r2,-4(fp)
 3201880:	10800044 	addi	r2,r2,1
 3201884:	10800003 	ldbu	r2,0(r2)
 3201888:	11803fcc 	andi	r6,r2,255
 320188c:	e0bfff17 	ldw	r2,-4(fp)
 3201890:	10800084 	addi	r2,r2,2
 3201894:	10800003 	ldbu	r2,0(r2)
 3201898:	11c03fcc 	andi	r7,r2,255
 320189c:	e0bfff17 	ldw	r2,-4(fp)
 32018a0:	108000c4 	addi	r2,r2,3
 32018a4:	10800003 	ldbu	r2,0(r2)
 32018a8:	10c03fcc 	andi	r3,r2,255
 32018ac:	e0bfff17 	ldw	r2,-4(fp)
 32018b0:	10800104 	addi	r2,r2,4
 32018b4:	10800003 	ldbu	r2,0(r2)
 32018b8:	11003fcc 	andi	r4,r2,255
 32018bc:	e0bfff17 	ldw	r2,-4(fp)
 32018c0:	10800144 	addi	r2,r2,5
 32018c4:	10800003 	ldbu	r2,0(r2)
 32018c8:	10803fcc 	andi	r2,r2,255
 32018cc:	d8c00015 	stw	r3,0(sp)
 32018d0:	d9000115 	stw	r4,4(sp)
 32018d4:	d8800215 	stw	r2,8(sp)
 32018d8:	0100c974 	movhi	r4,805
 32018dc:	21340404 	addi	r4,r4,-12272
 32018e0:	3206de00 	call	3206de0 <printf>
        /* Failed read MAC address from flash, prompt user to enter serial 
           number to generate MAC address. */
        error = generate_mac_addr(mac_addr);
    }
#endif
    return error;
 32018e4:	e0bffd17 	ldw	r2,-12(fp)
}
 32018e8:	e037883a 	mov	sp,fp
 32018ec:	dfc00117 	ldw	ra,4(sp)
 32018f0:	df000017 	ldw	fp,0(sp)
 32018f4:	dec00204 	addi	sp,sp,8
 32018f8:	f800283a 	ret

032018fc <get_ip_addr>:
int get_ip_addr(alt_iniche_dev *p_dev,
                ip_addr* ipaddr,
                ip_addr* netmask,
                ip_addr* gw,
                int* use_dhcp)
{
 32018fc:	defff304 	addi	sp,sp,-52
 3201900:	dfc00c15 	stw	ra,48(sp)
 3201904:	df000b15 	stw	fp,44(sp)
 3201908:	df000b04 	addi	fp,sp,44
 320190c:	e13ffc15 	stw	r4,-16(fp)
 3201910:	e17ffd15 	stw	r5,-12(fp)
 3201914:	e1bffe15 	stw	r6,-8(fp)
 3201918:	e1ffff15 	stw	r7,-4(fp)

    IP4_ADDR(*ipaddr, IPADDR0, IPADDR1, IPADDR2, IPADDR3);
 320191c:	e0fffd17 	ldw	r3,-12(fp)
 3201920:	00b54174 	movhi	r2,54533
 3201924:	1084eb04 	addi	r2,r2,5036
 3201928:	18800015 	stw	r2,0(r3)
    IP4_ADDR(*gw, GWADDR0, GWADDR1, GWADDR2, GWADDR3);
 320192c:	e0ffff17 	ldw	r3,-4(fp)
 3201930:	00804174 	movhi	r2,261
 3201934:	1084eb04 	addi	r2,r2,5036
 3201938:	18800015 	stw	r2,0(r3)
    IP4_ADDR(*netmask, MSKADDR0, MSKADDR1, MSKADDR2, MSKADDR3);
 320193c:	e0fffe17 	ldw	r3,-8(fp)
 3201940:	00804034 	movhi	r2,256
 3201944:	10bfffc4 	addi	r2,r2,-1
 3201948:	18800015 	stw	r2,0(r3)

#if defined (DHCP_CLIENT) && ! defined (FIXED_IP)
   *use_dhcp = 1;
 320194c:	e0c00217 	ldw	r3,8(fp)
 3201950:	00800044 	movi	r2,1
 3201954:	18800015 	stw	r2,0(r3)
        ip4_addr3(*ipaddr),
        ip4_addr4(*ipaddr));
#endif /* not DHCP_CLIENT */

    char lcd_msg[20];
    sprintf(lcd_msg, "IP:%d.%d.%d.%d\n",
 3201958:	e0bffd17 	ldw	r2,-12(fp)
 320195c:	10800017 	ldw	r2,0(r2)
 3201960:	1004d63a 	srli	r2,r2,24
 3201964:	10c03fcc 	andi	r3,r2,255
 3201968:	e0bffd17 	ldw	r2,-12(fp)
 320196c:	10800017 	ldw	r2,0(r2)
 3201970:	1004d23a 	srli	r2,r2,8
 3201974:	10bfc00c 	andi	r2,r2,65280
 3201978:	1886b03a 	or	r3,r3,r2
 320197c:	e0bffd17 	ldw	r2,-12(fp)
 3201980:	10800017 	ldw	r2,0(r2)
 3201984:	10bfc00c 	andi	r2,r2,65280
 3201988:	1004923a 	slli	r2,r2,8
 320198c:	1886b03a 	or	r3,r3,r2
 3201990:	e0bffd17 	ldw	r2,-12(fp)
 3201994:	10800017 	ldw	r2,0(r2)
 3201998:	10803fcc 	andi	r2,r2,255
 320199c:	1004963a 	slli	r2,r2,24
 32019a0:	1884b03a 	or	r2,r3,r2
 32019a4:	1004d63a 	srli	r2,r2,24
 32019a8:	11803fcc 	andi	r6,r2,255
 32019ac:	e0bffd17 	ldw	r2,-12(fp)
 32019b0:	10800017 	ldw	r2,0(r2)
 32019b4:	1004d63a 	srli	r2,r2,24
 32019b8:	10c03fcc 	andi	r3,r2,255
 32019bc:	e0bffd17 	ldw	r2,-12(fp)
 32019c0:	10800017 	ldw	r2,0(r2)
 32019c4:	1004d23a 	srli	r2,r2,8
 32019c8:	10bfc00c 	andi	r2,r2,65280
 32019cc:	1886b03a 	or	r3,r3,r2
 32019d0:	e0bffd17 	ldw	r2,-12(fp)
 32019d4:	10800017 	ldw	r2,0(r2)
 32019d8:	10bfc00c 	andi	r2,r2,65280
 32019dc:	1004923a 	slli	r2,r2,8
 32019e0:	1886b03a 	or	r3,r3,r2
 32019e4:	e0bffd17 	ldw	r2,-12(fp)
 32019e8:	10800017 	ldw	r2,0(r2)
 32019ec:	10803fcc 	andi	r2,r2,255
 32019f0:	1004963a 	slli	r2,r2,24
 32019f4:	1884b03a 	or	r2,r3,r2
 32019f8:	1004d43a 	srli	r2,r2,16
 32019fc:	11c03fcc 	andi	r7,r2,255
 3201a00:	e0bffd17 	ldw	r2,-12(fp)
 3201a04:	10800017 	ldw	r2,0(r2)
 3201a08:	1004d63a 	srli	r2,r2,24
 3201a0c:	10c03fcc 	andi	r3,r2,255
 3201a10:	e0bffd17 	ldw	r2,-12(fp)
 3201a14:	10800017 	ldw	r2,0(r2)
 3201a18:	1004d23a 	srli	r2,r2,8
 3201a1c:	10bfc00c 	andi	r2,r2,65280
 3201a20:	1886b03a 	or	r3,r3,r2
 3201a24:	e0bffd17 	ldw	r2,-12(fp)
 3201a28:	10800017 	ldw	r2,0(r2)
 3201a2c:	10bfc00c 	andi	r2,r2,65280
 3201a30:	1004923a 	slli	r2,r2,8
 3201a34:	1886b03a 	or	r3,r3,r2
 3201a38:	e0bffd17 	ldw	r2,-12(fp)
 3201a3c:	10800017 	ldw	r2,0(r2)
 3201a40:	10803fcc 	andi	r2,r2,255
 3201a44:	1004963a 	slli	r2,r2,24
 3201a48:	1884b03a 	or	r2,r3,r2
 3201a4c:	1004d23a 	srli	r2,r2,8
 3201a50:	11003fcc 	andi	r4,r2,255
 3201a54:	e0bffd17 	ldw	r2,-12(fp)
 3201a58:	10800017 	ldw	r2,0(r2)
 3201a5c:	1004d63a 	srli	r2,r2,24
 3201a60:	10c03fcc 	andi	r3,r2,255
 3201a64:	e0bffd17 	ldw	r2,-12(fp)
 3201a68:	10800017 	ldw	r2,0(r2)
 3201a6c:	1004d23a 	srli	r2,r2,8
 3201a70:	10bfc00c 	andi	r2,r2,65280
 3201a74:	1886b03a 	or	r3,r3,r2
 3201a78:	e0bffd17 	ldw	r2,-12(fp)
 3201a7c:	10800017 	ldw	r2,0(r2)
 3201a80:	10bfc00c 	andi	r2,r2,65280
 3201a84:	1004923a 	slli	r2,r2,8
 3201a88:	1886b03a 	or	r3,r3,r2
 3201a8c:	e0bffd17 	ldw	r2,-12(fp)
 3201a90:	10800017 	ldw	r2,0(r2)
 3201a94:	10803fcc 	andi	r2,r2,255
 3201a98:	1004963a 	slli	r2,r2,24
 3201a9c:	1884b03a 	or	r2,r3,r2
 3201aa0:	10803fcc 	andi	r2,r2,255
 3201aa4:	d9000015 	stw	r4,0(sp)
 3201aa8:	d8800115 	stw	r2,4(sp)
 3201aac:	e13ff704 	addi	r4,fp,-36
 3201ab0:	0140c974 	movhi	r5,805
 3201ab4:	29741304 	addi	r5,r5,-12212
 3201ab8:	32079c00 	call	32079c0 <sprintf>
            ip4_addr1(*ipaddr),
            ip4_addr2(*ipaddr),
            ip4_addr3(*ipaddr),
            ip4_addr4(*ipaddr));
    write_in_lcd(lcd_msg);
 3201abc:	e13ff704 	addi	r4,fp,-36
 3201ac0:	32015e80 	call	32015e8 <write_in_lcd>

    /* Non-standard API: return 1 for success */
    return 1;
 3201ac4:	00800044 	movi	r2,1
}
 3201ac8:	e037883a 	mov	sp,fp
 3201acc:	dfc00117 	ldw	ra,4(sp)
 3201ad0:	df000017 	ldw	fp,0(sp)
 3201ad4:	dec00204 	addi	sp,sp,8
 3201ad8:	f800283a 	ret

03201adc <get_serial_number>:
*
* Prompt user to enter 9-digit serial number. 
*
*/
alt_u32 get_serial_number (void)
{
 3201adc:	defff804 	addi	sp,sp,-32
 3201ae0:	dfc00715 	stw	ra,28(sp)
 3201ae4:	df000615 	stw	fp,24(sp)
 3201ae8:	dc000515 	stw	r16,20(sp)
 3201aec:	df000504 	addi	fp,sp,20
    alt_u32 ser_num = 0;
 3201af0:	e03ffc15 	stw	zero,-16(fp)
    char serial_number[9];
    int i = 0;
 3201af4:	e03ffb15 	stw	zero,-20(fp)
    
    while(!ser_num)
 3201af8:	00006506 	br	3201c90 <get_serial_number+0x1b4>
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
 3201afc:	0100c974 	movhi	r4,805
 3201b00:	21341704 	addi	r4,r4,-12196
 3201b04:	32071080 	call	3207108 <puts>
        printf("label under your Nios dev. board. The first 3 digits of the \n");
 3201b08:	0100c974 	movhi	r4,805
 3201b0c:	21342704 	addi	r4,r4,-12132
 3201b10:	32071080 	call	3207108 <puts>
        printf("label are ASJ and the serial number follows this.\n -->");
 3201b14:	0100c974 	movhi	r4,805
 3201b18:	21343704 	addi	r4,r4,-12068
 3201b1c:	3206de00 	call	3206de0 <printf>
        
        for(i=0; i<9; i++)
 3201b20:	e03ffb15 	stw	zero,-20(fp)
 3201b24:	00002806 	br	3201bc8 <get_serial_number+0xec>
        {
            serial_number[i] = getchar();
 3201b28:	e43ffb17 	ldw	r16,-20(fp)
 3201b2c:	0080c974 	movhi	r2,805
 3201b30:	108a6304 	addi	r2,r2,10636
 3201b34:	10800017 	ldw	r2,0(r2)
 3201b38:	11000117 	ldw	r4,4(r2)
 3201b3c:	3205ff00 	call	3205ff0 <getc>
 3201b40:	1007883a 	mov	r3,r2
 3201b44:	e0bffd04 	addi	r2,fp,-12
 3201b48:	1405883a 	add	r2,r2,r16
 3201b4c:	10c00005 	stb	r3,0(r2)
            putchar(serial_number[i]);
 3201b50:	e0fffb17 	ldw	r3,-20(fp)
 3201b54:	e0bffd04 	addi	r2,fp,-12
 3201b58:	10c5883a 	add	r2,r2,r3
 3201b5c:	10800003 	ldbu	r2,0(r2)
 3201b60:	11003fcc 	andi	r4,r2,255
 3201b64:	2100201c 	xori	r4,r4,128
 3201b68:	213fe004 	addi	r4,r4,-128
 3201b6c:	0080c974 	movhi	r2,805
 3201b70:	108a6304 	addi	r2,r2,10636
 3201b74:	10800017 	ldw	r2,0(r2)
 3201b78:	11400217 	ldw	r5,8(r2)
 3201b7c:	3206e580 	call	3206e58 <putc>
            
            /* Handle backspaces.  How civilized. */
            if ((serial_number[i] == 0x08) && (i >= 0)) 
 3201b80:	e0fffb17 	ldw	r3,-20(fp)
 3201b84:	e0bffd04 	addi	r2,fp,-12
 3201b88:	10c5883a 	add	r2,r2,r3
 3201b8c:	10800003 	ldbu	r2,0(r2)
 3201b90:	10803fcc 	andi	r2,r2,255
 3201b94:	1080201c 	xori	r2,r2,128
 3201b98:	10bfe004 	addi	r2,r2,-128
 3201b9c:	10800218 	cmpnei	r2,r2,8
 3201ba0:	1000061e 	bne	r2,zero,3201bbc <get_serial_number+0xe0>
 3201ba4:	e0bffb17 	ldw	r2,-20(fp)
 3201ba8:	1004803a 	cmplt	r2,r2,zero
 3201bac:	1000031e 	bne	r2,zero,3201bbc <get_serial_number+0xe0>
            {
                i--;
 3201bb0:	e0bffb17 	ldw	r2,-20(fp)
 3201bb4:	10bfffc4 	addi	r2,r2,-1
 3201bb8:	e0bffb15 	stw	r2,-20(fp)
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
        printf("label under your Nios dev. board. The first 3 digits of the \n");
        printf("label are ASJ and the serial number follows this.\n -->");
        
        for(i=0; i<9; i++)
 3201bbc:	e0bffb17 	ldw	r2,-20(fp)
 3201bc0:	10800044 	addi	r2,r2,1
 3201bc4:	e0bffb15 	stw	r2,-20(fp)
 3201bc8:	e0bffb17 	ldw	r2,-20(fp)
 3201bcc:	10800250 	cmplti	r2,r2,9
 3201bd0:	103fd51e 	bne	r2,zero,3201b28 <get_serial_number+0x4c>
            if ((serial_number[i] == 0x08) && (i >= 0)) 
            {
                i--;
            }
        }
        printf("\n");
 3201bd4:	01000284 	movi	r4,10
 3201bd8:	32070440 	call	3207044 <putchar>
                
        for(i=0; i<9; i++)
 3201bdc:	e03ffb15 	stw	zero,-20(fp)
 3201be0:	00002806 	br	3201c84 <get_serial_number+0x1a8>
        {
            if (isdigit(serial_number[i]))
 3201be4:	e0fffb17 	ldw	r3,-20(fp)
 3201be8:	e0bffd04 	addi	r2,fp,-12
 3201bec:	10c5883a 	add	r2,r2,r3
 3201bf0:	10800003 	ldbu	r2,0(r2)
 3201bf4:	10803fcc 	andi	r2,r2,255
 3201bf8:	1080201c 	xori	r2,r2,128
 3201bfc:	10bfe004 	addi	r2,r2,-128
 3201c00:	1007883a 	mov	r3,r2
 3201c04:	0080c974 	movhi	r2,805
 3201c08:	108a6204 	addi	r2,r2,10632
 3201c0c:	10800017 	ldw	r2,0(r2)
 3201c10:	1885883a 	add	r2,r3,r2
 3201c14:	10800003 	ldbu	r2,0(r2)
 3201c18:	10803fcc 	andi	r2,r2,255
 3201c1c:	1080010c 	andi	r2,r2,4
 3201c20:	1005003a 	cmpeq	r2,r2,zero
 3201c24:	1000121e 	bne	r2,zero,3201c70 <get_serial_number+0x194>
            {
                ser_num *= 10;
 3201c28:	e0bffc17 	ldw	r2,-16(fp)
 3201c2c:	108002a4 	muli	r2,r2,10
 3201c30:	e0bffc15 	stw	r2,-16(fp)
                ser_num += serial_number[i] - '0';
 3201c34:	e0fffb17 	ldw	r3,-20(fp)
 3201c38:	e0bffd04 	addi	r2,fp,-12
 3201c3c:	10c5883a 	add	r2,r2,r3
 3201c40:	10800003 	ldbu	r2,0(r2)
 3201c44:	10c03fcc 	andi	r3,r2,255
 3201c48:	18c0201c 	xori	r3,r3,128
 3201c4c:	18ffe004 	addi	r3,r3,-128
 3201c50:	e0bffc17 	ldw	r2,-16(fp)
 3201c54:	1885883a 	add	r2,r3,r2
 3201c58:	10bff404 	addi	r2,r2,-48
 3201c5c:	e0bffc15 	stw	r2,-16(fp)
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 3201c60:	e0bffb17 	ldw	r2,-20(fp)
 3201c64:	10800044 	addi	r2,r2,1
 3201c68:	e0bffb15 	stw	r2,-20(fp)
 3201c6c:	00000506 	br	3201c84 <get_serial_number+0x1a8>
                ser_num *= 10;
                ser_num += serial_number[i] - '0';
            }
            else
            {
                ser_num = 0;
 3201c70:	e03ffc15 	stw	zero,-16(fp)
                printf("Serial number only contains decimal digits and is non-zero\n");
 3201c74:	0100c974 	movhi	r4,805
 3201c78:	21344504 	addi	r4,r4,-12012
 3201c7c:	32071080 	call	3207108 <puts>
                break;
 3201c80:	00000306 	br	3201c90 <get_serial_number+0x1b4>
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 3201c84:	e0bffb17 	ldw	r2,-20(fp)
 3201c88:	10800250 	cmplti	r2,r2,9
 3201c8c:	103fd51e 	bne	r2,zero,3201be4 <get_serial_number+0x108>
{
    alt_u32 ser_num = 0;
    char serial_number[9];
    int i = 0;
    
    while(!ser_num)
 3201c90:	e0bffc17 	ldw	r2,-16(fp)
 3201c94:	1005003a 	cmpeq	r2,r2,zero
 3201c98:	103f981e 	bne	r2,zero,3201afc <get_serial_number+0x20>
                break;
            }
        }
    }
    
    return ser_num;
 3201c9c:	e0bffc17 	ldw	r2,-16(fp)
}
 3201ca0:	e037883a 	mov	sp,fp
 3201ca4:	dfc00217 	ldw	ra,8(sp)
 3201ca8:	df000117 	ldw	fp,4(sp)
 3201cac:	dc000017 	ldw	r16,0(sp)
 3201cb0:	dec00304 	addi	sp,sp,12
 3201cb4:	f800283a 	ret

03201cb8 <generate_and_store_mac_addr>:
 * sections. These fail-safe static settings are compatible with previous
 * Nios Ethernet designs, and allow the "factory-safe" design to behave 
 * as expected if the last flash sector is erased.
 */
error_t generate_and_store_mac_addr()
{
 3201cb8:	deffef04 	addi	sp,sp,-68
 3201cbc:	dfc01015 	stw	ra,64(sp)
 3201cc0:	df000f15 	stw	fp,60(sp)
 3201cc4:	df000f04 	addi	fp,sp,60
    error_t error = -1;
 3201cc8:	00bfffc4 	movi	r2,-1
 3201ccc:	e0bff715 	stw	r2,-36(fp)
    alt_u32 ser_num = 0;
 3201cd0:	e03ff615 	stw	zero,-40(fp)
    char flash_content[32];
    alt_flash_fd* flash_handle;
    
    printf("Can't read the MAC address from your board (this probably means\n");
 3201cd4:	0100c974 	movhi	r4,805
 3201cd8:	21345404 	addi	r4,r4,-11952
 3201cdc:	32071080 	call	3207108 <puts>
    printf("that your flash was erased). We will assign you a MAC address and\n");
 3201ce0:	0100c974 	movhi	r4,805
 3201ce4:	21346404 	addi	r4,r4,-11888
 3201ce8:	32071080 	call	3207108 <puts>
    printf("static network settings\n\n");
 3201cec:	0100c974 	movhi	r4,805
 3201cf0:	21347504 	addi	r4,r4,-11820
 3201cf4:	32071080 	call	3207108 <puts>
    
    ser_num = get_serial_number();
 3201cf8:	3201adc0 	call	3201adc <get_serial_number>
 3201cfc:	e0bff615 	stw	r2,-40(fp)
  
    if (ser_num)
 3201d00:	e0bff617 	ldw	r2,-40(fp)
 3201d04:	1005003a 	cmpeq	r2,r2,zero
 3201d08:	1000581e 	bne	r2,zero,3201e6c <generate_and_store_mac_addr+0x1b4>
    {
        /* This says the image is safe */
        flash_content[0] = 0xfe;
 3201d0c:	00bfff84 	movi	r2,-2
 3201d10:	e0bff805 	stb	r2,-32(fp)
        flash_content[1] = 0x5a;
 3201d14:	00801684 	movi	r2,90
 3201d18:	e0bff845 	stb	r2,-31(fp)
        flash_content[2] = 0x0;
 3201d1c:	e03ff885 	stb	zero,-30(fp)
        flash_content[3] = 0x0;
 3201d20:	e03ff8c5 	stb	zero,-29(fp)
        
        /* This is the Altera Vendor ID */
        flash_content[4] = 0x0;
 3201d24:	e03ff905 	stb	zero,-28(fp)
        flash_content[5] = 0x7;
 3201d28:	008001c4 	movi	r2,7
 3201d2c:	e0bff945 	stb	r2,-27(fp)
        flash_content[6] = 0xed;
 3201d30:	00bffb44 	movi	r2,-19
 3201d34:	e0bff985 	stb	r2,-26(fp)
        
        /* Reserverd Board identifier for erase boards */
        flash_content[7] = 0xFF;
 3201d38:	00bfffc4 	movi	r2,-1
 3201d3c:	e0bff9c5 	stb	r2,-25(fp)
        flash_content[8] = (ser_num & 0xff00) >> 8;
 3201d40:	e0bff617 	ldw	r2,-40(fp)
 3201d44:	10bfc00c 	andi	r2,r2,65280
 3201d48:	1004d23a 	srli	r2,r2,8
 3201d4c:	e0bffa05 	stb	r2,-24(fp)
        flash_content[9] = ser_num & 0xff;
 3201d50:	e0bff617 	ldw	r2,-40(fp)
 3201d54:	e0bffa45 	stb	r2,-23(fp)
        
        /* Then comes a 16-bit "flags" field */
        flash_content[10] = 0xFF;
 3201d58:	00bfffc4 	movi	r2,-1
 3201d5c:	e0bffa85 	stb	r2,-22(fp)
        flash_content[11] = 0xFF;
 3201d60:	00bfffc4 	movi	r2,-1
 3201d64:	e0bffac5 	stb	r2,-21(fp)
        
        /* Then comes the static IP address */
        flash_content[12] = IPADDR0;
 3201d68:	00bfeb04 	movi	r2,-84
 3201d6c:	e0bffb05 	stb	r2,-20(fp)
        flash_content[13] = IPADDR1;
 3201d70:	008004c4 	movi	r2,19
 3201d74:	e0bffb45 	stb	r2,-19(fp)
        flash_content[14] = IPADDR2;
 3201d78:	00800144 	movi	r2,5
 3201d7c:	e0bffb85 	stb	r2,-18(fp)
        flash_content[15] = IPADDR3;
 3201d80:	00bff544 	movi	r2,-43
 3201d84:	e0bffbc5 	stb	r2,-17(fp)
        
        /* Then comes the static nameserver address */
        flash_content[16] = 0xFF;
 3201d88:	00bfffc4 	movi	r2,-1
 3201d8c:	e0bffc05 	stb	r2,-16(fp)
        flash_content[17] = 0xFF;
 3201d90:	00bfffc4 	movi	r2,-1
 3201d94:	e0bffc45 	stb	r2,-15(fp)
        flash_content[18] = 0xFF;
 3201d98:	00bfffc4 	movi	r2,-1
 3201d9c:	e0bffc85 	stb	r2,-14(fp)
        flash_content[19] = 0xFF;
 3201da0:	00bfffc4 	movi	r2,-1
 3201da4:	e0bffcc5 	stb	r2,-13(fp)
        
        /* Then comes the static subnet mask */
        flash_content[20] = MSKADDR0;
 3201da8:	00bfffc4 	movi	r2,-1
 3201dac:	e0bffd05 	stb	r2,-12(fp)
        flash_content[21] = MSKADDR1;
 3201db0:	00bfffc4 	movi	r2,-1
 3201db4:	e0bffd45 	stb	r2,-11(fp)
        flash_content[22] = MSKADDR2;
 3201db8:	00bfffc4 	movi	r2,-1
 3201dbc:	e0bffd85 	stb	r2,-10(fp)
        flash_content[23] = MSKADDR3;
 3201dc0:	e03ffdc5 	stb	zero,-9(fp)
        
        /* Then comes the static gateway address */
        flash_content[24] = GWADDR0;
 3201dc4:	00bfeb04 	movi	r2,-84
 3201dc8:	e0bffe05 	stb	r2,-8(fp)
        flash_content[25] = GWADDR1;
 3201dcc:	008004c4 	movi	r2,19
 3201dd0:	e0bffe45 	stb	r2,-7(fp)
        flash_content[26] = GWADDR2;
 3201dd4:	00800144 	movi	r2,5
 3201dd8:	e0bffe85 	stb	r2,-6(fp)
        flash_content[27] = GWADDR3;
 3201ddc:	00800044 	movi	r2,1
 3201de0:	e0bffec5 	stb	r2,-5(fp)
        
        /* And finally whether to use DHCP - set all bits to be safe */
        flash_content[28] = 0xFF;
 3201de4:	00bfffc4 	movi	r2,-1
 3201de8:	e0bfff05 	stb	r2,-4(fp)
        flash_content[29] = 0xFF;
 3201dec:	00bfffc4 	movi	r2,-1
 3201df0:	e0bfff45 	stb	r2,-3(fp)
        flash_content[30] = 0xFF;
 3201df4:	00bfffc4 	movi	r2,-1
 3201df8:	e0bfff85 	stb	r2,-2(fp)
        flash_content[31] = 0xFF;
 3201dfc:	00bfffc4 	movi	r2,-1
 3201e00:	e0bfffc5 	stb	r2,-1(fp)
        
        /* Write the MAC address to flash */
        flash_handle = alt_flash_open_dev(EXT_FLASH_NAME);
 3201e04:	0100c974 	movhi	r4,805
 3201e08:	21347c04 	addi	r4,r4,-11792
 3201e0c:	32148600 	call	3214860 <alt_flash_open_dev>
 3201e10:	e0bff515 	stw	r2,-44(fp)
        if (flash_handle)
 3201e14:	e0bff517 	ldw	r2,-44(fp)
 3201e18:	1005003a 	cmpeq	r2,r2,zero
 3201e1c:	1000131e 	bne	r2,zero,3201e6c <generate_and_store_mac_addr+0x1b4>
        {
            alt_write_flash(flash_handle,
 3201e20:	d0a89317 	ldw	r2,-23988(gp)
 3201e24:	1007883a 	mov	r3,r2
 3201e28:	e0bff517 	ldw	r2,-44(fp)
 3201e2c:	e0bff115 	stw	r2,-60(fp)
 3201e30:	e0fff215 	stw	r3,-56(fp)
 3201e34:	e0bff804 	addi	r2,fp,-32
 3201e38:	e0bff315 	stw	r2,-52(fp)
 3201e3c:	00800804 	movi	r2,32
 3201e40:	e0bff415 	stw	r2,-48(fp)
                                                           alt_flash_fd* fd, 
                                                           int offset, 
                                                           const void* src_addr, 
                                                           int length )
{
  return fd->write( fd, offset, src_addr, length );
 3201e44:	e0bff117 	ldw	r2,-60(fp)
 3201e48:	10800517 	ldw	r2,20(r2)
 3201e4c:	e13ff117 	ldw	r4,-60(fp)
 3201e50:	e17ff217 	ldw	r5,-56(fp)
 3201e54:	e1bff317 	ldw	r6,-52(fp)
 3201e58:	e1fff417 	ldw	r7,-48(fp)
 3201e5c:	103ee83a 	callr	r2
                            last_flash_sector_offset,
                            flash_content,
                            32);
            alt_flash_close_dev(flash_handle);
 3201e60:	e13ff517 	ldw	r4,-44(fp)
 3201e64:	32148dc0 	call	32148dc <alt_flash_close_dev>
            error = 0;
 3201e68:	e03ff715 	stw	zero,-36(fp)
        }
    }

    return error;    
 3201e6c:	e0bff717 	ldw	r2,-36(fp)
}
 3201e70:	e037883a 	mov	sp,fp
 3201e74:	dfc00117 	ldw	ra,4(sp)
 3201e78:	df000017 	ldw	fp,0(sp)
 3201e7c:	dec00204 	addi	sp,sp,8
 3201e80:	f800283a 	ret

03201e84 <generate_mac_addr>:
 * Development Board serial number is 040800017, the corresponding ethernet 
 * number generated will be 00:07:ED:FF:8F:11.
 * 
 */
error_t generate_mac_addr(unsigned char mac_addr[6])
{
 3201e84:	defff804 	addi	sp,sp,-32
 3201e88:	dfc00715 	stw	ra,28(sp)
 3201e8c:	df000615 	stw	fp,24(sp)
 3201e90:	df000604 	addi	fp,sp,24
 3201e94:	e13fff15 	stw	r4,-4(fp)
    error_t error = -1;
 3201e98:	00bfffc4 	movi	r2,-1
 3201e9c:	e0bffe15 	stw	r2,-8(fp)
    alt_u32 ser_num = 0;
 3201ea0:	e03ffd15 	stw	zero,-12(fp)
    
    printf("\nCan't read the MAC address from your board. We will assign you\n");
 3201ea4:	0100c974 	movhi	r4,805
 3201ea8:	21348004 	addi	r4,r4,-11776
 3201eac:	32071080 	call	3207108 <puts>
    printf("a MAC address.\n\n");
 3201eb0:	0100c974 	movhi	r4,805
 3201eb4:	21349004 	addi	r4,r4,-11712
 3201eb8:	32071080 	call	3207108 <puts>
    
    ser_num = get_serial_number();
 3201ebc:	3201adc0 	call	3201adc <get_serial_number>
 3201ec0:	e0bffd15 	stw	r2,-12(fp)
  
    if (ser_num)
 3201ec4:	e0bffd17 	ldw	r2,-12(fp)
 3201ec8:	1005003a 	cmpeq	r2,r2,zero
 3201ecc:	1000361e 	bne	r2,zero,3201fa8 <generate_mac_addr+0x124>
    {
        /* This is the Altera Vendor ID */
        mac_addr[0] = 0x0;
 3201ed0:	e0bfff17 	ldw	r2,-4(fp)
 3201ed4:	10000005 	stb	zero,0(r2)
        mac_addr[1] = 0x7;
 3201ed8:	e0bfff17 	ldw	r2,-4(fp)
 3201edc:	10c00044 	addi	r3,r2,1
 3201ee0:	008001c4 	movi	r2,7
 3201ee4:	18800005 	stb	r2,0(r3)
        mac_addr[2] = 0xed;
 3201ee8:	e0bfff17 	ldw	r2,-4(fp)
 3201eec:	10c00084 	addi	r3,r2,2
 3201ef0:	00bffb44 	movi	r2,-19
 3201ef4:	18800005 	stb	r2,0(r3)
        
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
 3201ef8:	e0bfff17 	ldw	r2,-4(fp)
 3201efc:	10c000c4 	addi	r3,r2,3
 3201f00:	00bfffc4 	movi	r2,-1
 3201f04:	18800005 	stb	r2,0(r3)
        mac_addr[4] = (ser_num & 0xff00) >> 8;
 3201f08:	e0bfff17 	ldw	r2,-4(fp)
 3201f0c:	10c00104 	addi	r3,r2,4
 3201f10:	e0bffd17 	ldw	r2,-12(fp)
 3201f14:	10bfc00c 	andi	r2,r2,65280
 3201f18:	1004d23a 	srli	r2,r2,8
 3201f1c:	18800005 	stb	r2,0(r3)
        mac_addr[5] = ser_num & 0xff;
 3201f20:	e0bfff17 	ldw	r2,-4(fp)
 3201f24:	10c00144 	addi	r3,r2,5
 3201f28:	e0bffd17 	ldw	r2,-12(fp)
 3201f2c:	18800005 	stb	r2,0(r3)
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 3201f30:	e0bfff17 	ldw	r2,-4(fp)
 3201f34:	10800003 	ldbu	r2,0(r2)
 3201f38:	11403fcc 	andi	r5,r2,255
 3201f3c:	e0bfff17 	ldw	r2,-4(fp)
 3201f40:	10800044 	addi	r2,r2,1
 3201f44:	10800003 	ldbu	r2,0(r2)
 3201f48:	11803fcc 	andi	r6,r2,255
 3201f4c:	e0bfff17 	ldw	r2,-4(fp)
 3201f50:	10800084 	addi	r2,r2,2
 3201f54:	10800003 	ldbu	r2,0(r2)
 3201f58:	11c03fcc 	andi	r7,r2,255
 3201f5c:	e0bfff17 	ldw	r2,-4(fp)
 3201f60:	108000c4 	addi	r2,r2,3
 3201f64:	10800003 	ldbu	r2,0(r2)
 3201f68:	10c03fcc 	andi	r3,r2,255
 3201f6c:	e0bfff17 	ldw	r2,-4(fp)
 3201f70:	10800104 	addi	r2,r2,4
 3201f74:	10800003 	ldbu	r2,0(r2)
 3201f78:	11003fcc 	andi	r4,r2,255
 3201f7c:	e0bfff17 	ldw	r2,-4(fp)
 3201f80:	10800144 	addi	r2,r2,5
 3201f84:	10800003 	ldbu	r2,0(r2)
 3201f88:	10803fcc 	andi	r2,r2,255
 3201f8c:	d8c00015 	stw	r3,0(sp)
 3201f90:	d9000115 	stw	r4,4(sp)
 3201f94:	d8800215 	stw	r2,8(sp)
 3201f98:	0100c974 	movhi	r4,805
 3201f9c:	21340404 	addi	r4,r4,-12272
 3201fa0:	3206de00 	call	3206de0 <printf>
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
        
        error = 0;
 3201fa4:	e03ffe15 	stw	zero,-8(fp)
    }
  
    return error;    
 3201fa8:	e0bffe17 	ldw	r2,-8(fp)
}
 3201fac:	e037883a 	mov	sp,fp
 3201fb0:	dfc00117 	ldw	ra,4(sp)
 3201fb4:	df000017 	ldw	fp,0(sp)
 3201fb8:	dec00204 	addi	sp,sp,8
 3201fbc:	f800283a 	ret

03201fc0 <get_board_mac_addr>:
*
* Read the MAC address in a board specific way
*
*/
error_t get_board_mac_addr(unsigned char mac_addr[6])
{
 3201fc0:	defff804 	addi	sp,sp,-32
 3201fc4:	dfc00715 	stw	ra,28(sp)
 3201fc8:	df000615 	stw	fp,24(sp)
 3201fcc:	df000604 	addi	fp,sp,24
 3201fd0:	e13fff15 	stw	r4,-4(fp)

	 printf("Your Ethernet MAC address before reading flash is %02x:%02x:%02x:%02x:%02x:%02x\n",
 3201fd4:	e0bfff17 	ldw	r2,-4(fp)
 3201fd8:	10800003 	ldbu	r2,0(r2)
 3201fdc:	11403fcc 	andi	r5,r2,255
 3201fe0:	e0bfff17 	ldw	r2,-4(fp)
 3201fe4:	10800044 	addi	r2,r2,1
 3201fe8:	10800003 	ldbu	r2,0(r2)
 3201fec:	11803fcc 	andi	r6,r2,255
 3201ff0:	e0bfff17 	ldw	r2,-4(fp)
 3201ff4:	10800084 	addi	r2,r2,2
 3201ff8:	10800003 	ldbu	r2,0(r2)
 3201ffc:	11c03fcc 	andi	r7,r2,255
 3202000:	e0bfff17 	ldw	r2,-4(fp)
 3202004:	108000c4 	addi	r2,r2,3
 3202008:	10800003 	ldbu	r2,0(r2)
 320200c:	10c03fcc 	andi	r3,r2,255
 3202010:	e0bfff17 	ldw	r2,-4(fp)
 3202014:	10800104 	addi	r2,r2,4
 3202018:	10800003 	ldbu	r2,0(r2)
 320201c:	11003fcc 	andi	r4,r2,255
 3202020:	e0bfff17 	ldw	r2,-4(fp)
 3202024:	10800144 	addi	r2,r2,5
 3202028:	10800003 	ldbu	r2,0(r2)
 320202c:	10803fcc 	andi	r2,r2,255
 3202030:	d8c00015 	stw	r3,0(sp)
 3202034:	d9000115 	stw	r4,4(sp)
 3202038:	d8800215 	stw	r2,8(sp)
 320203c:	0100c974 	movhi	r4,805
 3202040:	21349404 	addi	r4,r4,-11696
 3202044:	3206de00 	call	3206de0 <printf>
		            mac_addr[2],
		            mac_addr[3],
		            mac_addr[4],
		            mac_addr[5]);

	error_t error = 0;
 3202048:	e03ffe15 	stw	zero,-8(fp)
    alt_u32 signature;
    
    /* Get the flash sector with the MAC address. */
    error = FindLastFlashSectorOffset(&last_flash_sector_offset);
 320204c:	d1289304 	addi	r4,gp,-23988
 3202050:	320223c0 	call	320223c <FindLastFlashSectorOffset>
 3202054:	e0bffe15 	stw	r2,-8(fp)
    if (!error)
 3202058:	e0bffe17 	ldw	r2,-8(fp)
 320205c:	1004c03a 	cmpne	r2,r2,zero
 3202060:	1000041e 	bne	r2,zero,3202074 <get_board_mac_addr+0xb4>
        last_flash_sector = EXT_FLASH_BASE + last_flash_sector_offset;
 3202064:	d0a89317 	ldw	r2,-23988(gp)
 3202068:	00c0a034 	movhi	r3,640
 320206c:	10c5883a 	add	r2,r2,r3
 3202070:	d0a89415 	stw	r2,-23984(gp)
     * valid network settings are present, indicated by a signature of 0x00005afe at 
     * the first address of the last flash sector.  This hex value is chosen as the 
     * signature since it looks like the english word "SAFE", meaning that it is 
     * safe to use these network address values.  
    */
    if (!error)
 3202074:	e0bffe17 	ldw	r2,-8(fp)
 3202078:	1004c03a 	cmpne	r2,r2,zero
 320207c:	1000081e 	bne	r2,zero,32020a0 <get_board_mac_addr+0xe0>
    {
        signature = IORD_32DIRECT(last_flash_sector, 0);
 3202080:	d0a89417 	ldw	r2,-23984(gp)
 3202084:	10800037 	ldwio	r2,0(r2)
 3202088:	e0bffd15 	stw	r2,-12(fp)
        if (signature != 0x00005afe)
 320208c:	e0bffd17 	ldw	r2,-12(fp)
 3202090:	1096bfa0 	cmpeqi	r2,r2,23294
 3202094:	1000021e 	bne	r2,zero,32020a0 <get_board_mac_addr+0xe0>
        {
          error = generate_and_store_mac_addr();
 3202098:	3201cb80 	call	3201cb8 <generate_and_store_mac_addr>
 320209c:	e0bffe15 	stw	r2,-8(fp)
        }
    }
  
    printf("Your Ethernet MAC address after reading flash is %02x:%02x:%02x:%02x:%02x:%02x\n",
 32020a0:	e0bfff17 	ldw	r2,-4(fp)
 32020a4:	10800003 	ldbu	r2,0(r2)
 32020a8:	11403fcc 	andi	r5,r2,255
 32020ac:	e0bfff17 	ldw	r2,-4(fp)
 32020b0:	10800044 	addi	r2,r2,1
 32020b4:	10800003 	ldbu	r2,0(r2)
 32020b8:	11803fcc 	andi	r6,r2,255
 32020bc:	e0bfff17 	ldw	r2,-4(fp)
 32020c0:	10800084 	addi	r2,r2,2
 32020c4:	10800003 	ldbu	r2,0(r2)
 32020c8:	11c03fcc 	andi	r7,r2,255
 32020cc:	e0bfff17 	ldw	r2,-4(fp)
 32020d0:	108000c4 	addi	r2,r2,3
 32020d4:	10800003 	ldbu	r2,0(r2)
 32020d8:	10c03fcc 	andi	r3,r2,255
 32020dc:	e0bfff17 	ldw	r2,-4(fp)
 32020e0:	10800104 	addi	r2,r2,4
 32020e4:	10800003 	ldbu	r2,0(r2)
 32020e8:	11003fcc 	andi	r4,r2,255
 32020ec:	e0bfff17 	ldw	r2,-4(fp)
 32020f0:	10800144 	addi	r2,r2,5
 32020f4:	10800003 	ldbu	r2,0(r2)
 32020f8:	10803fcc 	andi	r2,r2,255
 32020fc:	d8c00015 	stw	r3,0(sp)
 3202100:	d9000115 	stw	r4,4(sp)
 3202104:	d8800215 	stw	r2,8(sp)
 3202108:	0100c974 	movhi	r4,805
 320210c:	2134a904 	addi	r4,r4,-11612
 3202110:	3206de00 	call	3206de0 <printf>
    	            mac_addr[2],
    	            mac_addr[3],
    	            mac_addr[4],
    	            mac_addr[5]);

    if (!error)
 3202114:	e0bffe17 	ldw	r2,-8(fp)
 3202118:	1004c03a 	cmpne	r2,r2,zero
 320211c:	1000411e 	bne	r2,zero,3202224 <get_board_mac_addr+0x264>
    {
        mac_addr[0] = IORD_8DIRECT(last_flash_sector, 4);
 3202120:	d0a89417 	ldw	r2,-23984(gp)
 3202124:	10800104 	addi	r2,r2,4
 3202128:	10800023 	ldbuio	r2,0(r2)
 320212c:	1007883a 	mov	r3,r2
 3202130:	e0bfff17 	ldw	r2,-4(fp)
 3202134:	10c00005 	stb	r3,0(r2)
        mac_addr[1] = IORD_8DIRECT(last_flash_sector, 5);
 3202138:	e0bfff17 	ldw	r2,-4(fp)
 320213c:	10c00044 	addi	r3,r2,1
 3202140:	d0a89417 	ldw	r2,-23984(gp)
 3202144:	10800144 	addi	r2,r2,5
 3202148:	10800023 	ldbuio	r2,0(r2)
 320214c:	18800005 	stb	r2,0(r3)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
 3202150:	e0bfff17 	ldw	r2,-4(fp)
 3202154:	10c00084 	addi	r3,r2,2
 3202158:	d0a89417 	ldw	r2,-23984(gp)
 320215c:	10800184 	addi	r2,r2,6
 3202160:	10800023 	ldbuio	r2,0(r2)
 3202164:	18800005 	stb	r2,0(r3)
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
 3202168:	e0bfff17 	ldw	r2,-4(fp)
 320216c:	10c000c4 	addi	r3,r2,3
 3202170:	d0a89417 	ldw	r2,-23984(gp)
 3202174:	108001c4 	addi	r2,r2,7
 3202178:	10800023 	ldbuio	r2,0(r2)
 320217c:	18800005 	stb	r2,0(r3)
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
 3202180:	e0bfff17 	ldw	r2,-4(fp)
 3202184:	10c00104 	addi	r3,r2,4
 3202188:	d0a89417 	ldw	r2,-23984(gp)
 320218c:	10800204 	addi	r2,r2,8
 3202190:	10800023 	ldbuio	r2,0(r2)
 3202194:	18800005 	stb	r2,0(r3)
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
 3202198:	e0bfff17 	ldw	r2,-4(fp)
 320219c:	10c00144 	addi	r3,r2,5
 32021a0:	d0a89417 	ldw	r2,-23984(gp)
 32021a4:	10800244 	addi	r2,r2,9
 32021a8:	10800023 	ldbuio	r2,0(r2)
 32021ac:	18800005 	stb	r2,0(r3)
		
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 32021b0:	e0bfff17 	ldw	r2,-4(fp)
 32021b4:	10800003 	ldbu	r2,0(r2)
 32021b8:	11403fcc 	andi	r5,r2,255
 32021bc:	e0bfff17 	ldw	r2,-4(fp)
 32021c0:	10800044 	addi	r2,r2,1
 32021c4:	10800003 	ldbu	r2,0(r2)
 32021c8:	11803fcc 	andi	r6,r2,255
 32021cc:	e0bfff17 	ldw	r2,-4(fp)
 32021d0:	10800084 	addi	r2,r2,2
 32021d4:	10800003 	ldbu	r2,0(r2)
 32021d8:	11c03fcc 	andi	r7,r2,255
 32021dc:	e0bfff17 	ldw	r2,-4(fp)
 32021e0:	108000c4 	addi	r2,r2,3
 32021e4:	10800003 	ldbu	r2,0(r2)
 32021e8:	10c03fcc 	andi	r3,r2,255
 32021ec:	e0bfff17 	ldw	r2,-4(fp)
 32021f0:	10800104 	addi	r2,r2,4
 32021f4:	10800003 	ldbu	r2,0(r2)
 32021f8:	11003fcc 	andi	r4,r2,255
 32021fc:	e0bfff17 	ldw	r2,-4(fp)
 3202200:	10800144 	addi	r2,r2,5
 3202204:	10800003 	ldbu	r2,0(r2)
 3202208:	10803fcc 	andi	r2,r2,255
 320220c:	d8c00015 	stw	r3,0(sp)
 3202210:	d9000115 	stw	r4,4(sp)
 3202214:	d8800215 	stw	r2,8(sp)
 3202218:	0100c974 	movhi	r4,805
 320221c:	21340404 	addi	r4,r4,-12272
 3202220:	3206de00 	call	3206de0 <printf>
            mac_addr[4],
            mac_addr[5]);
    
    }
    
    return error;
 3202224:	e0bffe17 	ldw	r2,-8(fp)
}
 3202228:	e037883a 	mov	sp,fp
 320222c:	dfc00117 	ldw	ra,4(sp)
 3202230:	df000017 	ldw	fp,0(sp)
 3202234:	dec00204 	addi	sp,sp,8
 3202238:	f800283a 	ret

0320223c <FindLastFlashSectorOffset>:
 * in pLastFlashSectorOffset.
 */

int FindLastFlashSectorOffset(
    alt_u32                     *pLastFlashSectorOffset)
{
 320223c:	defff304 	addi	sp,sp,-52
 3202240:	dfc00c15 	stw	ra,48(sp)
 3202244:	df000b15 	stw	fp,44(sp)
 3202248:	df000b04 	addi	fp,sp,44
 320224c:	e13fff15 	stw	r4,-4(fp)
    flash_region                *regions;
    int                         numRegions;
    flash_region                *pLastRegion;
    int                         lastFlashSectorOffset;
    int                         n;
    int                         error = 0;
 3202250:	e03ff815 	stw	zero,-32(fp)

    /* Open the flash device. */
    fd = alt_flash_open_dev(EXT_FLASH_NAME);
 3202254:	0100c974 	movhi	r4,805
 3202258:	21347c04 	addi	r4,r4,-11792
 320225c:	32148600 	call	3214860 <alt_flash_open_dev>
 3202260:	e0bffc15 	stw	r2,-16(fp)
    if (fd <= 0)
 3202264:	e0bffc17 	ldw	r2,-16(fp)
 3202268:	1004c03a 	cmpne	r2,r2,zero
 320226c:	1000021e 	bne	r2,zero,3202278 <FindLastFlashSectorOffset+0x3c>
        error = -1;
 3202270:	00bfffc4 	movi	r2,-1
 3202274:	e0bff815 	stw	r2,-32(fp)

    /* Get the flash info. */
    if (!error)
 3202278:	e0bff817 	ldw	r2,-32(fp)
 320227c:	1004c03a 	cmpne	r2,r2,zero
 3202280:	10000d1e 	bne	r2,zero,32022b8 <FindLastFlashSectorOffset+0x7c>
 3202284:	e0bffc17 	ldw	r2,-16(fp)
 3202288:	e0bff515 	stw	r2,-44(fp)
 320228c:	e0bffd04 	addi	r2,fp,-12
 3202290:	e0bff615 	stw	r2,-40(fp)
 3202294:	e0bffe04 	addi	r2,fp,-8
 3202298:	e0bff715 	stw	r2,-36(fp)
 */
static __inline__ int __attribute__ ((always_inline)) alt_get_flash_info( 
                                      alt_flash_fd* fd, flash_region** info, 
                                      int* number_of_regions)
{
  return fd->get_info( fd, info, number_of_regions);
 320229c:	e0bff517 	ldw	r2,-44(fp)
 32022a0:	10800717 	ldw	r2,28(r2)
 32022a4:	e13ff517 	ldw	r4,-44(fp)
 32022a8:	e17ff617 	ldw	r5,-40(fp)
 32022ac:	e1bff717 	ldw	r6,-36(fp)
 32022b0:	103ee83a 	callr	r2
        error = alt_get_flash_info(fd, &regions, &numRegions);
 32022b4:	e0bff815 	stw	r2,-32(fp)

    /* Find the last flash sector. */
    if (!error)
 32022b8:	e0bff817 	ldw	r2,-32(fp)
 32022bc:	1004c03a 	cmpne	r2,r2,zero
 32022c0:	1000231e 	bne	r2,zero,3202350 <FindLastFlashSectorOffset+0x114>
    {
        pLastRegion = &(regions[0]);
 32022c4:	e0bffd17 	ldw	r2,-12(fp)
 32022c8:	e0bffb15 	stw	r2,-20(fp)
        for (n = 1; n < numRegions; n++)
 32022cc:	00800044 	movi	r2,1
 32022d0:	e0bff915 	stw	r2,-28(fp)
 32022d4:	00001206 	br	3202320 <FindLastFlashSectorOffset+0xe4>
        {
            if (regions[n].offset > pLastRegion->offset)
 32022d8:	e0bff917 	ldw	r2,-28(fp)
 32022dc:	1004913a 	slli	r2,r2,4
 32022e0:	1007883a 	mov	r3,r2
 32022e4:	e0bffd17 	ldw	r2,-12(fp)
 32022e8:	1885883a 	add	r2,r3,r2
 32022ec:	10c00017 	ldw	r3,0(r2)
 32022f0:	e0bffb17 	ldw	r2,-20(fp)
 32022f4:	10800017 	ldw	r2,0(r2)
 32022f8:	10c0060e 	bge	r2,r3,3202314 <FindLastFlashSectorOffset+0xd8>
                pLastRegion = &(regions[n]);
 32022fc:	e0bff917 	ldw	r2,-28(fp)
 3202300:	1004913a 	slli	r2,r2,4
 3202304:	1007883a 	mov	r3,r2
 3202308:	e0bffd17 	ldw	r2,-12(fp)
 320230c:	1885883a 	add	r2,r3,r2
 3202310:	e0bffb15 	stw	r2,-20(fp)

    /* Find the last flash sector. */
    if (!error)
    {
        pLastRegion = &(regions[0]);
        for (n = 1; n < numRegions; n++)
 3202314:	e0bff917 	ldw	r2,-28(fp)
 3202318:	10800044 	addi	r2,r2,1
 320231c:	e0bff915 	stw	r2,-28(fp)
 3202320:	e0fffe17 	ldw	r3,-8(fp)
 3202324:	e0bff917 	ldw	r2,-28(fp)
 3202328:	10ffeb16 	blt	r2,r3,32022d8 <FindLastFlashSectorOffset+0x9c>
        {
            if (regions[n].offset > pLastRegion->offset)
                pLastRegion = &(regions[n]);
        }
        lastFlashSectorOffset =   pLastRegion->offset
 320232c:	e0bffb17 	ldw	r2,-20(fp)
 3202330:	10c00017 	ldw	r3,0(r2)
 3202334:	e0bffb17 	ldw	r2,-20(fp)
 3202338:	10800117 	ldw	r2,4(r2)
 320233c:	1887883a 	add	r3,r3,r2
 3202340:	e0bffb17 	ldw	r2,-20(fp)
 3202344:	10800317 	ldw	r2,12(r2)
 3202348:	1885c83a 	sub	r2,r3,r2
 320234c:	e0bffa15 	stw	r2,-24(fp)
                                + pLastRegion->region_size
                                - pLastRegion->block_size;
    }

    /* Return results. */
    if (!error)
 3202350:	e0bff817 	ldw	r2,-32(fp)
 3202354:	1004c03a 	cmpne	r2,r2,zero
 3202358:	1000031e 	bne	r2,zero,3202368 <FindLastFlashSectorOffset+0x12c>
        *pLastFlashSectorOffset = lastFlashSectorOffset;
 320235c:	e0fffa17 	ldw	r3,-24(fp)
 3202360:	e0bfff17 	ldw	r2,-4(fp)
 3202364:	10c00015 	stw	r3,0(r2)

    return (error);
 3202368:	e0bff817 	ldw	r2,-32(fp)
}
 320236c:	e037883a 	mov	sp,fp
 3202370:	dfc00117 	ldw	ra,4(sp)
 3202374:	df000017 	ldw	fp,0(sp)
 3202378:	dec00204 	addi	sp,sp,8
 320237c:	f800283a 	ret

03202380 <sss_reset_connection>:
 * This routine will, when called, reset our SSSConn struct's members 
 * to a reliable initial state. Note that we set our socket (FD) number to
 * -1 to easily determine whether the connection is in a "reset, ready to go" 
 * state.
 */
void sss_reset_connection(SSSConn* conn) {
 3202380:	defffd04 	addi	sp,sp,-12
 3202384:	dfc00215 	stw	ra,8(sp)
 3202388:	df000115 	stw	fp,4(sp)
 320238c:	df000104 	addi	fp,sp,4
 3202390:	e13fff15 	stw	r4,-4(fp)
	memset(conn, 0, sizeof(SSSConn));
 3202394:	e0bfff17 	ldw	r2,-4(fp)
 3202398:	1009883a 	mov	r4,r2
 320239c:	01820504 	movi	r6,2068
 32023a0:	000b883a 	mov	r5,zero
 32023a4:	3206c500 	call	3206c50 <memset>

	conn->fd = -1;
 32023a8:	e0ffff17 	ldw	r3,-4(fp)
 32023ac:	00bfffc4 	movi	r2,-1
 32023b0:	18800115 	stw	r2,4(r3)
	conn->state = READY;
 32023b4:	e0bfff17 	ldw	r2,-4(fp)
 32023b8:	10000015 	stw	zero,0(r2)
	conn->rx_wr_pos = conn->rx_buffer;
 32023bc:	e0bfff17 	ldw	r2,-4(fp)
 32023c0:	10c00304 	addi	r3,r2,12
 32023c4:	e0bfff17 	ldw	r2,-4(fp)
 32023c8:	10c20415 	stw	r3,2064(r2)
	conn->rx_rd_pos = conn->rx_buffer;
 32023cc:	e0bfff17 	ldw	r2,-4(fp)
 32023d0:	10c00304 	addi	r3,r2,12
 32023d4:	e0bfff17 	ldw	r2,-4(fp)
 32023d8:	10c20315 	stw	r3,2060(r2)
}
 32023dc:	e037883a 	mov	sp,fp
 32023e0:	dfc00117 	ldw	ra,4(sp)
 32023e4:	df000017 	ldw	fp,0(sp)
 32023e8:	dec00204 	addi	sp,sp,8
 32023ec:	f800283a 	ret

032023f0 <sss_send_menu>:
/*
 * sss_send_menu()
 * 
 * This routine will transmit the menu out to the telnet client.
 */
void sss_send_menu(SSSConn* conn) {
 32023f0:	defdfc04 	addi	sp,sp,-2064
 32023f4:	dfc20315 	stw	ra,2060(sp)
 32023f8:	df020215 	stw	fp,2056(sp)
 32023fc:	df020204 	addi	fp,sp,2056
 3202400:	e13fff15 	stw	r4,-4(fp)
	alt_u8  tx_buf[SSS_TX_BUF_SIZE];
	alt_u8 *tx_wr_pos = tx_buf;
 3202404:	e0bdff04 	addi	r2,fp,-2052
 3202408:	e0bdfe15 	stw	r2,-2056(fp)

	tx_wr_pos += sprintf(tx_wr_pos, "===========================================\n");
 320240c:	e0bdfe17 	ldw	r2,-2056(fp)
 3202410:	00c0c974 	movhi	r3,805
 3202414:	18f4bd04 	addi	r3,r3,-11532
 3202418:	1009883a 	mov	r4,r2
 320241c:	180b883a 	mov	r5,r3
 3202420:	01800b44 	movi	r6,45
 3202424:	3206ad00 	call	3206ad0 <memcpy>
 3202428:	e0bdfe17 	ldw	r2,-2056(fp)
 320242c:	10800b04 	addi	r2,r2,44
 3202430:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "Nios II Camera Commands Menu               \n");
 3202434:	e0bdfe17 	ldw	r2,-2056(fp)
 3202438:	00c0c974 	movhi	r3,805
 320243c:	18f4c904 	addi	r3,r3,-11484
 3202440:	1009883a 	mov	r4,r2
 3202444:	180b883a 	mov	r5,r3
 3202448:	01800b44 	movi	r6,45
 320244c:	3206ad00 	call	3206ad0 <memcpy>
 3202450:	e0bdfe17 	ldw	r2,-2056(fp)
 3202454:	10800b04 	addi	r2,r2,44
 3202458:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "===========================================\n");
 320245c:	e0bdfe17 	ldw	r2,-2056(fp)
 3202460:	00c0c974 	movhi	r3,805
 3202464:	18f4bd04 	addi	r3,r3,-11532
 3202468:	1009883a 	mov	r4,r2
 320246c:	180b883a 	mov	r5,r3
 3202470:	01800b44 	movi	r6,45
 3202474:	3206ad00 	call	3206ad0 <memcpy>
 3202478:	e0bdfe17 	ldw	r2,-2056(fp)
 320247c:	10800b04 	addi	r2,r2,44
 3202480:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "                                           \n");
 3202484:	e0bdfe17 	ldw	r2,-2056(fp)
 3202488:	00c0c974 	movhi	r3,805
 320248c:	18f4d504 	addi	r3,r3,-11436
 3202490:	1009883a 	mov	r4,r2
 3202494:	180b883a 	mov	r5,r3
 3202498:	01800b44 	movi	r6,45
 320249c:	3206ad00 	call	3206ad0 <memcpy>
 32024a0:	e0bdfe17 	ldw	r2,-2056(fp)
 32024a4:	10800b04 	addi	r2,r2,44
 32024a8:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "r,xx: Read value of register (xx)          \n");
 32024ac:	e0bdfe17 	ldw	r2,-2056(fp)
 32024b0:	00c0c974 	movhi	r3,805
 32024b4:	18f4e104 	addi	r3,r3,-11388
 32024b8:	1009883a 	mov	r4,r2
 32024bc:	180b883a 	mov	r5,r3
 32024c0:	01800b44 	movi	r6,45
 32024c4:	3206ad00 	call	3206ad0 <memcpy>
 32024c8:	e0bdfe17 	ldw	r2,-2056(fp)
 32024cc:	10800b04 	addi	r2,r2,44
 32024d0:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "w,xx,yy: Write value (yy) in register (xx) \n");
 32024d4:	e0bdfe17 	ldw	r2,-2056(fp)
 32024d8:	00c0c974 	movhi	r3,805
 32024dc:	18f4ed04 	addi	r3,r3,-11340
 32024e0:	1009883a 	mov	r4,r2
 32024e4:	180b883a 	mov	r5,r3
 32024e8:	01800b44 	movi	r6,45
 32024ec:	3206ad00 	call	3206ad0 <memcpy>
 32024f0:	e0bdfe17 	ldw	r2,-2056(fp)
 32024f4:	10800b04 	addi	r2,r2,44
 32024f8:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "                                           \n");
 32024fc:	e0bdfe17 	ldw	r2,-2056(fp)
 3202500:	00c0c974 	movhi	r3,805
 3202504:	18f4d504 	addi	r3,r3,-11436
 3202508:	1009883a 	mov	r4,r2
 320250c:	180b883a 	mov	r5,r3
 3202510:	01800b44 	movi	r6,45
 3202514:	3206ad00 	call	3206ad0 <memcpy>
 3202518:	e0bdfe17 	ldw	r2,-2056(fp)
 320251c:	10800b04 	addi	r2,r2,44
 3202520:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "C: Configure camera sensor                 \n");
 3202524:	e0bdfe17 	ldw	r2,-2056(fp)
 3202528:	00c0c974 	movhi	r3,805
 320252c:	18f4f904 	addi	r3,r3,-11292
 3202530:	1009883a 	mov	r4,r2
 3202534:	180b883a 	mov	r5,r3
 3202538:	01800b44 	movi	r6,45
 320253c:	3206ad00 	call	3206ad0 <memcpy>
 3202540:	e0bdfe17 	ldw	r2,-2056(fp)
 3202544:	10800b04 	addi	r2,r2,44
 3202548:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "S: Start/Stop capture                      \n");
 320254c:	e0bdfe17 	ldw	r2,-2056(fp)
 3202550:	00c0c974 	movhi	r3,805
 3202554:	18f50504 	addi	r3,r3,-11244
 3202558:	1009883a 	mov	r4,r2
 320255c:	180b883a 	mov	r5,r3
 3202560:	01800b44 	movi	r6,45
 3202564:	3206ad00 	call	3206ad0 <memcpy>
 3202568:	e0bdfe17 	ldw	r2,-2056(fp)
 320256c:	10800b04 	addi	r2,r2,44
 3202570:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "D: Send RGB image data                     \n");
 3202574:	e0bdfe17 	ldw	r2,-2056(fp)
 3202578:	00c0c974 	movhi	r3,805
 320257c:	18f51104 	addi	r3,r3,-11196
 3202580:	1009883a 	mov	r4,r2
 3202584:	180b883a 	mov	r5,r3
 3202588:	01800b44 	movi	r6,45
 320258c:	3206ad00 	call	3206ad0 <memcpy>
 3202590:	e0bdfe17 	ldw	r2,-2056(fp)
 3202594:	10800b04 	addi	r2,r2,44
 3202598:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "G: Send gray image data                    \n");
 320259c:	e0bdfe17 	ldw	r2,-2056(fp)
 32025a0:	00c0c974 	movhi	r3,805
 32025a4:	18f51d04 	addi	r3,r3,-11148
 32025a8:	1009883a 	mov	r4,r2
 32025ac:	180b883a 	mov	r5,r3
 32025b0:	01800b44 	movi	r6,45
 32025b4:	3206ad00 	call	3206ad0 <memcpy>
 32025b8:	e0bdfe17 	ldw	r2,-2056(fp)
 32025bc:	10800b04 	addi	r2,r2,44
 32025c0:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "V: VGA (live video mode)                   \n");
 32025c4:	e0bdfe17 	ldw	r2,-2056(fp)
 32025c8:	00c0c974 	movhi	r3,805
 32025cc:	18f52904 	addi	r3,r3,-11100
 32025d0:	1009883a 	mov	r4,r2
 32025d4:	180b883a 	mov	r5,r3
 32025d8:	01800b44 	movi	r6,45
 32025dc:	3206ad00 	call	3206ad0 <memcpy>
 32025e0:	e0bdfe17 	ldw	r2,-2056(fp)
 32025e4:	10800b04 	addi	r2,r2,44
 32025e8:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "                                           \n");
 32025ec:	e0bdfe17 	ldw	r2,-2056(fp)
 32025f0:	00c0c974 	movhi	r3,805
 32025f4:	18f4d504 	addi	r3,r3,-11436
 32025f8:	1009883a 	mov	r4,r2
 32025fc:	180b883a 	mov	r5,r3
 3202600:	01800b44 	movi	r6,45
 3202604:	3206ad00 	call	3206ad0 <memcpy>
 3202608:	e0bdfe17 	ldw	r2,-2056(fp)
 320260c:	10800b04 	addi	r2,r2,44
 3202610:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "Q: Terminate session                       \n");
 3202614:	e0bdfe17 	ldw	r2,-2056(fp)
 3202618:	00c0c974 	movhi	r3,805
 320261c:	18f53504 	addi	r3,r3,-11052
 3202620:	1009883a 	mov	r4,r2
 3202624:	180b883a 	mov	r5,r3
 3202628:	01800b44 	movi	r6,45
 320262c:	3206ad00 	call	3206ad0 <memcpy>
 3202630:	e0bdfe17 	ldw	r2,-2056(fp)
 3202634:	10800b04 	addi	r2,r2,44
 3202638:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "===========================================\n");
 320263c:	e0bdfe17 	ldw	r2,-2056(fp)
 3202640:	00c0c974 	movhi	r3,805
 3202644:	18f4bd04 	addi	r3,r3,-11532
 3202648:	1009883a 	mov	r4,r2
 320264c:	180b883a 	mov	r5,r3
 3202650:	01800b44 	movi	r6,45
 3202654:	3206ad00 	call	3206ad0 <memcpy>
 3202658:	e0bdfe17 	ldw	r2,-2056(fp)
 320265c:	10800b04 	addi	r2,r2,44
 3202660:	e0bdfe15 	stw	r2,-2056(fp)
	tx_wr_pos += sprintf(tx_wr_pos, "Enter your choice & press return:>\n");
 3202664:	e0bdfe17 	ldw	r2,-2056(fp)
 3202668:	00c0c974 	movhi	r3,805
 320266c:	18f54104 	addi	r3,r3,-11004
 3202670:	1009883a 	mov	r4,r2
 3202674:	180b883a 	mov	r5,r3
 3202678:	01800904 	movi	r6,36
 320267c:	3206ad00 	call	3206ad0 <memcpy>
 3202680:	e0bdfe17 	ldw	r2,-2056(fp)
 3202684:	108008c4 	addi	r2,r2,35
 3202688:	e0bdfe15 	stw	r2,-2056(fp)

	send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
 320268c:	e0bfff17 	ldw	r2,-4(fp)
 3202690:	11000117 	ldw	r4,4(r2)
 3202694:	e17dff04 	addi	r5,fp,-2052
 3202698:	e0fdfe17 	ldw	r3,-2056(fp)
 320269c:	e0bdff04 	addi	r2,fp,-2052
 32026a0:	188dc83a 	sub	r6,r3,r2
 32026a4:	000f883a 	mov	r7,zero
 32026a8:	322f2140 	call	322f214 <t_send>
}
 32026ac:	e037883a 	mov	sp,fp
 32026b0:	dfc00117 	ldw	ra,4(sp)
 32026b4:	df000017 	ldw	fp,0(sp)
 32026b8:	dec00204 	addi	sp,sp,8
 32026bc:	f800283a 	ret

032026c0 <sss_exec_command>:
 * If the user wishes to quit, we set the "close" member of our SSSConn
 * struct, which will be looked at back in sss_handle_receive() when it 
 * comes time to see whether to close the connection or not.
 */

void sss_exec_command(SSSConn* conn) {
 32026c0:	defddd04 	addi	sp,sp,-2188
 32026c4:	dfc22215 	stw	ra,2184(sp)
 32026c8:	df022115 	stw	fp,2180(sp)
 32026cc:	dc022015 	stw	r16,2176(sp)
 32026d0:	df022004 	addi	fp,sp,2176
 32026d4:	e13ff915 	stw	r4,-28(fp)
	int bytes_to_process = conn->rx_wr_pos - conn->rx_rd_pos;
 32026d8:	e0bff917 	ldw	r2,-28(fp)
 32026dc:	10820417 	ldw	r2,2064(r2)
 32026e0:	1007883a 	mov	r3,r2
 32026e4:	e0bff917 	ldw	r2,-28(fp)
 32026e8:	10820317 	ldw	r2,2060(r2)
 32026ec:	1885c83a 	sub	r2,r3,r2
 32026f0:	e0bdf215 	stw	r2,-2104(fp)
	INT8U tx_buf[SSS_TX_BUF_SIZE];
	INT8U *tx_wr_pos = tx_buf;
 32026f4:	e0bdf304 	addi	r2,fp,-2100
 32026f8:	e0bdf115 	stw	r2,-2108(fp)
     * SSSSimpleSocketServerTask, since the LEDManagementTask does not
     * have access to the stack of the SSSSimpleSocketServerTask.
     */
    static INT32U SSSCommand;

    INT8U send_data = 0;
 32026fc:	e03df005 	stb	zero,-2112(fp)

    // Command parser
    char cmd;
    char reg[2];
    int data0, data1, data2, data3, data4;
    int captured = 0;
 3202700:	e03def15 	stw	zero,-2116(fp)
    int _captured = 0;
 3202704:	e03dee15 	stw	zero,-2120(fp)

    //printf("(%i) %s", strlen(conn->rx_rd_pos), conn->rx_rd_pos);
    sscanf(conn->rx_rd_pos, "%c,%c%c,%i,%i,%i,%i,%i", &cmd, &reg[0], &reg[1],
 3202708:	e0bff917 	ldw	r2,-28(fp)
 320270c:	10820317 	ldw	r2,2060(r2)
 3202710:	1009883a 	mov	r4,r2
 3202714:	e0bff344 	addi	r2,fp,-51
 3202718:	10800044 	addi	r2,r2,1
 320271c:	e1bff304 	addi	r6,fp,-52
 3202720:	e1fff344 	addi	r7,fp,-51
 3202724:	d8800015 	stw	r2,0(sp)
 3202728:	e0bff404 	addi	r2,fp,-48
 320272c:	d8800115 	stw	r2,4(sp)
 3202730:	e0bff504 	addi	r2,fp,-44
 3202734:	d8800215 	stw	r2,8(sp)
 3202738:	e0bff604 	addi	r2,fp,-40
 320273c:	d8800315 	stw	r2,12(sp)
 3202740:	e0bff704 	addi	r2,fp,-36
 3202744:	d8800415 	stw	r2,16(sp)
 3202748:	e0bff804 	addi	r2,fp,-32
 320274c:	d8800515 	stw	r2,20(sp)
 3202750:	0140c974 	movhi	r5,805
 3202754:	29754a04 	addi	r5,r5,-10968
 3202758:	3207b240 	call	3207b24 <sscanf>
    	   &data0, &data1, &data2, &data3, &data4);

	bytes_to_process--;
 320275c:	e0bdf217 	ldw	r2,-2104(fp)
 3202760:	10bfffc4 	addi	r2,r2,-1
 3202764:	e0bdf215 	stw	r2,-2104(fp)
    SSSCommand = toupper(*(conn->rx_rd_pos++));
 3202768:	e0bff917 	ldw	r2,-28(fp)
 320276c:	10c20317 	ldw	r3,2060(r2)
 3202770:	18800003 	ldbu	r2,0(r3)
 3202774:	10803fcc 	andi	r2,r2,255
 3202778:	e0bded15 	stw	r2,-2124(fp)
 320277c:	18c00044 	addi	r3,r3,1
 3202780:	e0bff917 	ldw	r2,-28(fp)
 3202784:	10c20315 	stw	r3,2060(r2)
 3202788:	0080c974 	movhi	r2,805
 320278c:	108a6204 	addi	r2,r2,10632
 3202790:	10c00017 	ldw	r3,0(r2)
 3202794:	e0bded17 	ldw	r2,-2124(fp)
 3202798:	1885883a 	add	r2,r3,r2
 320279c:	10800003 	ldbu	r2,0(r2)
 32027a0:	10803fcc 	andi	r2,r2,255
 32027a4:	1080008c 	andi	r2,r2,2
 32027a8:	1005003a 	cmpeq	r2,r2,zero
 32027ac:	1000041e 	bne	r2,zero,32027c0 <sss_exec_command+0x100>
 32027b0:	e0bded17 	ldw	r2,-2124(fp)
 32027b4:	10bff804 	addi	r2,r2,-32
 32027b8:	e0bffe15 	stw	r2,-8(fp)
 32027bc:	00000206 	br	32027c8 <sss_exec_command+0x108>
 32027c0:	e0bded17 	ldw	r2,-2124(fp)
 32027c4:	e0bffe15 	stw	r2,-8(fp)
 32027c8:	e0bffe17 	ldw	r2,-8(fp)
 32027cc:	d0a89515 	stw	r2,-23980(gp)
    while (bytes_to_process--) {
 32027d0:	00000506 	br	32027e8 <sss_exec_command+0x128>
    	*(conn->rx_rd_pos++);
 32027d4:	e0bff917 	ldw	r2,-28(fp)
 32027d8:	10820317 	ldw	r2,2060(r2)
 32027dc:	10c00044 	addi	r3,r2,1
 32027e0:	e0bff917 	ldw	r2,-28(fp)
 32027e4:	10c20315 	stw	r3,2060(r2)
    sscanf(conn->rx_rd_pos, "%c,%c%c,%i,%i,%i,%i,%i", &cmd, &reg[0], &reg[1],
    	   &data0, &data1, &data2, &data3, &data4);

	bytes_to_process--;
    SSSCommand = toupper(*(conn->rx_rd_pos++));
    while (bytes_to_process--) {
 32027e8:	e0bdf217 	ldw	r2,-2104(fp)
 32027ec:	10bfffc4 	addi	r2,r2,-1
 32027f0:	e0bdf215 	stw	r2,-2104(fp)
 32027f4:	e0bdf217 	ldw	r2,-2104(fp)
 32027f8:	10bfffd8 	cmpnei	r2,r2,-1
 32027fc:	103ff51e 	bne	r2,zero,32027d4 <sss_exec_command+0x114>
    	*(conn->rx_rd_pos++);
    }

    switch(SSSCommand) {
 3202800:	d0a89517 	ldw	r2,-23980(gp)
 3202804:	10bfef44 	addi	r2,r2,-67
 3202808:	e0bfff15 	stw	r2,-4(fp)
 320280c:	e0ffff17 	ldw	r3,-4(fp)
 3202810:	18800568 	cmpgeui	r2,r3,21
 3202814:	10031b1e 	bne	r2,zero,3203484 <sss_exec_command+0xdc4>
 3202818:	e13fff17 	ldw	r4,-4(fp)
 320281c:	e13fff17 	ldw	r4,-4(fp)
 3202820:	2105883a 	add	r2,r4,r4
 3202824:	1087883a 	add	r3,r2,r2
 3202828:	0080c834 	movhi	r2,800
 320282c:	108a0f04 	addi	r2,r2,10300
 3202830:	1885883a 	add	r2,r3,r2
 3202834:	10800017 	ldw	r2,0(r2)
 3202838:	1000683a 	jmp	r2
 320283c:	03203364 	muli	r12,zero,-32563
 3202840:	03203404 	movi	r12,-32560
 3202844:	03203484 	movi	r12,-32558
 3202848:	03203484 	movi	r12,-32558
 320284c:	03203424 	muli	r12,zero,-32560
 3202850:	03203484 	movi	r12,-32558
 3202854:	03203484 	movi	r12,-32558
 3202858:	03203484 	movi	r12,-32558
 320285c:	03203484 	movi	r12,-32558
 3202860:	03203484 	movi	r12,-32558
 3202864:	03203484 	movi	r12,-32558
 3202868:	03203484 	movi	r12,-32558
 320286c:	03203484 	movi	r12,-32558
 3202870:	03203484 	movi	r12,-32558
 3202874:	03203484 	movi	r12,-32558
 3202878:	03202890 	cmplti	r12,zero,-32606
 320287c:	032033a4 	muli	r12,zero,-32562
 3202880:	03203484 	movi	r12,-32558
 3202884:	03203484 	movi	r12,-32558
 3202888:	03203444 	movi	r12,-32559
 320288c:	03202de4 	muli	r12,zero,-32585
		case CMD_READ:
			/* Reads camera image registers */
			if (reg[0] == 'i' && reg[1] == 's') { // image size (width, height)
 3202890:	e0bff343 	ldbu	r2,-51(fp)
 3202894:	10803fcc 	andi	r2,r2,255
 3202898:	1080201c 	xori	r2,r2,128
 320289c:	10bfe004 	addi	r2,r2,-128
 32028a0:	10801a58 	cmpnei	r2,r2,105
 32028a4:	10000f1e 	bne	r2,zero,32028e4 <sss_exec_command+0x224>
 32028a8:	e0bff383 	ldbu	r2,-50(fp)
 32028ac:	10803fcc 	andi	r2,r2,255
 32028b0:	1080201c 	xori	r2,r2,128
 32028b4:	10bfe004 	addi	r2,r2,-128
 32028b8:	10801cd8 	cmpnei	r2,r2,115
 32028bc:	1000091e 	bne	r2,zero,32028e4 <sss_exec_command+0x224>
				tx_wr_pos += get_image_size(&camera, tx_wr_pos);
 32028c0:	e17df117 	ldw	r5,-2108(fp)
 32028c4:	0100c974 	movhi	r4,805
 32028c8:	21027504 	addi	r4,r4,2516
 32028cc:	32010300 	call	3201030 <get_image_size>
 32028d0:	1007883a 	mov	r3,r2
 32028d4:	e0bdf117 	ldw	r2,-2108(fp)
 32028d8:	10c5883a 	add	r2,r2,r3
 32028dc:	e0bdf115 	stw	r2,-2108(fp)
    }

    switch(SSSCommand) {
		case CMD_READ:
			/* Reads camera image registers */
			if (reg[0] == 'i' && reg[1] == 's') { // image size (width, height)
 32028e0:	00013806 	br	3202dc4 <sss_exec_command+0x704>
				tx_wr_pos += get_image_size(&camera, tx_wr_pos);
			}
			else if (reg[0] == 'i' && reg[1] == 'e') { // image exposure (exposure)
 32028e4:	e0bff343 	ldbu	r2,-51(fp)
 32028e8:	10803fcc 	andi	r2,r2,255
 32028ec:	1080201c 	xori	r2,r2,128
 32028f0:	10bfe004 	addi	r2,r2,-128
 32028f4:	10801a58 	cmpnei	r2,r2,105
 32028f8:	10000f1e 	bne	r2,zero,3202938 <sss_exec_command+0x278>
 32028fc:	e0bff383 	ldbu	r2,-50(fp)
 3202900:	10803fcc 	andi	r2,r2,255
 3202904:	1080201c 	xori	r2,r2,128
 3202908:	10bfe004 	addi	r2,r2,-128
 320290c:	10801958 	cmpnei	r2,r2,101
 3202910:	1000091e 	bne	r2,zero,3202938 <sss_exec_command+0x278>
				tx_wr_pos += get_image_exposure(&camera, tx_wr_pos);
 3202914:	e17df117 	ldw	r5,-2108(fp)
 3202918:	0100c974 	movhi	r4,805
 320291c:	21027504 	addi	r4,r4,2516
 3202920:	32010e00 	call	32010e0 <get_image_exposure>
 3202924:	1007883a 	mov	r3,r2
 3202928:	e0bdf117 	ldw	r2,-2108(fp)
 320292c:	10c5883a 	add	r2,r2,r3
 3202930:	e0bdf115 	stw	r2,-2108(fp)
		case CMD_READ:
			/* Reads camera image registers */
			if (reg[0] == 'i' && reg[1] == 's') { // image size (width, height)
				tx_wr_pos += get_image_size(&camera, tx_wr_pos);
			}
			else if (reg[0] == 'i' && reg[1] == 'e') { // image exposure (exposure)
 3202934:	00012306 	br	3202dc4 <sss_exec_command+0x704>
				tx_wr_pos += get_image_exposure(&camera, tx_wr_pos);
			}
			else if (reg[0] == 's' && reg[1] == 'i') { // start image (start_column, start_row)
 3202938:	e0bff343 	ldbu	r2,-51(fp)
 320293c:	10803fcc 	andi	r2,r2,255
 3202940:	1080201c 	xori	r2,r2,128
 3202944:	10bfe004 	addi	r2,r2,-128
 3202948:	10801cd8 	cmpnei	r2,r2,115
 320294c:	10000f1e 	bne	r2,zero,320298c <sss_exec_command+0x2cc>
 3202950:	e0bff383 	ldbu	r2,-50(fp)
 3202954:	10803fcc 	andi	r2,r2,255
 3202958:	1080201c 	xori	r2,r2,128
 320295c:	10bfe004 	addi	r2,r2,-128
 3202960:	10801a58 	cmpnei	r2,r2,105
 3202964:	1000091e 	bne	r2,zero,320298c <sss_exec_command+0x2cc>
				tx_wr_pos += get_start_image(&camera, tx_wr_pos);
 3202968:	e17df117 	ldw	r5,-2108(fp)
 320296c:	0100c974 	movhi	r4,805
 3202970:	21027504 	addi	r4,r4,2516
 3202974:	32011780 	call	3201178 <get_start_image>
 3202978:	1007883a 	mov	r3,r2
 320297c:	e0bdf117 	ldw	r2,-2108(fp)
 3202980:	10c5883a 	add	r2,r2,r3
 3202984:	e0bdf115 	stw	r2,-2108(fp)
				tx_wr_pos += get_image_size(&camera, tx_wr_pos);
			}
			else if (reg[0] == 'i' && reg[1] == 'e') { // image exposure (exposure)
				tx_wr_pos += get_image_exposure(&camera, tx_wr_pos);
			}
			else if (reg[0] == 's' && reg[1] == 'i') { // start image (start_column, start_row)
 3202988:	00010e06 	br	3202dc4 <sss_exec_command+0x704>
				tx_wr_pos += get_start_image(&camera, tx_wr_pos);
			}
			else if (reg[0] == 's' && reg[1] == 's') { // sensor size (column_size, row_size)
 320298c:	e0bff343 	ldbu	r2,-51(fp)
 3202990:	10803fcc 	andi	r2,r2,255
 3202994:	1080201c 	xori	r2,r2,128
 3202998:	10bfe004 	addi	r2,r2,-128
 320299c:	10801cd8 	cmpnei	r2,r2,115
 32029a0:	10000f1e 	bne	r2,zero,32029e0 <sss_exec_command+0x320>
 32029a4:	e0bff383 	ldbu	r2,-50(fp)
 32029a8:	10803fcc 	andi	r2,r2,255
 32029ac:	1080201c 	xori	r2,r2,128
 32029b0:	10bfe004 	addi	r2,r2,-128
 32029b4:	10801cd8 	cmpnei	r2,r2,115
 32029b8:	1000091e 	bne	r2,zero,32029e0 <sss_exec_command+0x320>
				tx_wr_pos += get_sensor_size(&camera, tx_wr_pos);
 32029bc:	e17df117 	ldw	r5,-2108(fp)
 32029c0:	0100c974 	movhi	r4,805
 32029c4:	21027504 	addi	r4,r4,2516
 32029c8:	32012280 	call	3201228 <get_sensor_size>
 32029cc:	1007883a 	mov	r3,r2
 32029d0:	e0bdf117 	ldw	r2,-2108(fp)
 32029d4:	10c5883a 	add	r2,r2,r3
 32029d8:	e0bdf115 	stw	r2,-2108(fp)
				tx_wr_pos += get_image_exposure(&camera, tx_wr_pos);
			}
			else if (reg[0] == 's' && reg[1] == 'i') { // start image (start_column, start_row)
				tx_wr_pos += get_start_image(&camera, tx_wr_pos);
			}
			else if (reg[0] == 's' && reg[1] == 's') { // sensor size (column_size, row_size)
 32029dc:	0000f906 	br	3202dc4 <sss_exec_command+0x704>
				tx_wr_pos += get_sensor_size(&camera, tx_wr_pos);
			}
			else if (reg[0] == 's' && reg[1] == 'm') { // sensor mode (column_mode, row_mode)
 32029e0:	e0bff343 	ldbu	r2,-51(fp)
 32029e4:	10803fcc 	andi	r2,r2,255
 32029e8:	1080201c 	xori	r2,r2,128
 32029ec:	10bfe004 	addi	r2,r2,-128
 32029f0:	10801cd8 	cmpnei	r2,r2,115
 32029f4:	10000f1e 	bne	r2,zero,3202a34 <sss_exec_command+0x374>
 32029f8:	e0bff383 	ldbu	r2,-50(fp)
 32029fc:	10803fcc 	andi	r2,r2,255
 3202a00:	1080201c 	xori	r2,r2,128
 3202a04:	10bfe004 	addi	r2,r2,-128
 3202a08:	10801b58 	cmpnei	r2,r2,109
 3202a0c:	1000091e 	bne	r2,zero,3202a34 <sss_exec_command+0x374>
				tx_wr_pos += get_sensor_mode(&camera, tx_wr_pos);
 3202a10:	e17df117 	ldw	r5,-2108(fp)
 3202a14:	0100c974 	movhi	r4,805
 3202a18:	21027504 	addi	r4,r4,2516
 3202a1c:	32012d80 	call	32012d8 <get_sensor_mode>
 3202a20:	1007883a 	mov	r3,r2
 3202a24:	e0bdf117 	ldw	r2,-2108(fp)
 3202a28:	10c5883a 	add	r2,r2,r3
 3202a2c:	e0bdf115 	stw	r2,-2108(fp)
				tx_wr_pos += get_start_image(&camera, tx_wr_pos);
			}
			else if (reg[0] == 's' && reg[1] == 's') { // sensor size (column_size, row_size)
				tx_wr_pos += get_sensor_size(&camera, tx_wr_pos);
			}
			else if (reg[0] == 's' && reg[1] == 'm') { // sensor mode (column_mode, row_mode)
 3202a30:	0000e406 	br	3202dc4 <sss_exec_command+0x704>
				tx_wr_pos += get_sensor_mode(&camera, tx_wr_pos);
			}
			/* Reads thresholds (min, max) */
			else if (reg[0] == 'r' && reg[1] == 't') {
 3202a34:	e0bff343 	ldbu	r2,-51(fp)
 3202a38:	10803fcc 	andi	r2,r2,255
 3202a3c:	1080201c 	xori	r2,r2,128
 3202a40:	10bfe004 	addi	r2,r2,-128
 3202a44:	10801c98 	cmpnei	r2,r2,114
 3202a48:	1000191e 	bne	r2,zero,3202ab0 <sss_exec_command+0x3f0>
 3202a4c:	e0bff383 	ldbu	r2,-50(fp)
 3202a50:	10803fcc 	andi	r2,r2,255
 3202a54:	1080201c 	xori	r2,r2,128
 3202a58:	10bfe004 	addi	r2,r2,-128
 3202a5c:	10801d18 	cmpnei	r2,r2,116
 3202a60:	1000131e 	bne	r2,zero,3202ab0 <sss_exec_command+0x3f0>
				data0 = IORD_SENSOR_RED_THRESHOLD_MIN(SENSOR_BASE);
 3202a64:	0080d034 	movhi	r2,832
 3202a68:	10880004 	addi	r2,r2,8192
 3202a6c:	10800037 	ldwio	r2,0(r2)
 3202a70:	e0bff415 	stw	r2,-48(fp)
				data1 = IORD_SENSOR_RED_THRESHOLD_MAX(SENSOR_BASE);
 3202a74:	0080d034 	movhi	r2,832
 3202a78:	10880404 	addi	r2,r2,8208
 3202a7c:	10800037 	ldwio	r2,0(r2)
 3202a80:	e0bff515 	stw	r2,-44(fp)
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
 3202a84:	e13df117 	ldw	r4,-2108(fp)
 3202a88:	e1bff417 	ldw	r6,-48(fp)
 3202a8c:	e1fff517 	ldw	r7,-44(fp)
 3202a90:	0140c974 	movhi	r5,805
 3202a94:	29755004 	addi	r5,r5,-10944
 3202a98:	32079c00 	call	32079c0 <sprintf>
 3202a9c:	1007883a 	mov	r3,r2
 3202aa0:	e0bdf117 	ldw	r2,-2108(fp)
 3202aa4:	10c5883a 	add	r2,r2,r3
 3202aa8:	e0bdf115 	stw	r2,-2108(fp)
			}
			else if (reg[0] == 's' && reg[1] == 'm') { // sensor mode (column_mode, row_mode)
				tx_wr_pos += get_sensor_mode(&camera, tx_wr_pos);
			}
			/* Reads thresholds (min, max) */
			else if (reg[0] == 'r' && reg[1] == 't') {
 3202aac:	0000c506 	br	3202dc4 <sss_exec_command+0x704>
				data0 = IORD_SENSOR_RED_THRESHOLD_MIN(SENSOR_BASE);
				data1 = IORD_SENSOR_RED_THRESHOLD_MAX(SENSOR_BASE);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			else if (reg[0] == 'g' && reg[1] == 't') {
 3202ab0:	e0bff343 	ldbu	r2,-51(fp)
 3202ab4:	10803fcc 	andi	r2,r2,255
 3202ab8:	1080201c 	xori	r2,r2,128
 3202abc:	10bfe004 	addi	r2,r2,-128
 3202ac0:	108019d8 	cmpnei	r2,r2,103
 3202ac4:	1000191e 	bne	r2,zero,3202b2c <sss_exec_command+0x46c>
 3202ac8:	e0bff383 	ldbu	r2,-50(fp)
 3202acc:	10803fcc 	andi	r2,r2,255
 3202ad0:	1080201c 	xori	r2,r2,128
 3202ad4:	10bfe004 	addi	r2,r2,-128
 3202ad8:	10801d18 	cmpnei	r2,r2,116
 3202adc:	1000131e 	bne	r2,zero,3202b2c <sss_exec_command+0x46c>
				data0 = IORD_SENSOR_GREEN_THRESHOLD_MIN(SENSOR_BASE);
 3202ae0:	0080d034 	movhi	r2,832
 3202ae4:	10880804 	addi	r2,r2,8224
 3202ae8:	10800037 	ldwio	r2,0(r2)
 3202aec:	e0bff415 	stw	r2,-48(fp)
				data1 = IORD_SENSOR_GREEN_THRESHOLD_MAX(SENSOR_BASE);
 3202af0:	0080d034 	movhi	r2,832
 3202af4:	10880c04 	addi	r2,r2,8240
 3202af8:	10800037 	ldwio	r2,0(r2)
 3202afc:	e0bff515 	stw	r2,-44(fp)
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
 3202b00:	e13df117 	ldw	r4,-2108(fp)
 3202b04:	e1bff417 	ldw	r6,-48(fp)
 3202b08:	e1fff517 	ldw	r7,-44(fp)
 3202b0c:	0140c974 	movhi	r5,805
 3202b10:	29755004 	addi	r5,r5,-10944
 3202b14:	32079c00 	call	32079c0 <sprintf>
 3202b18:	1007883a 	mov	r3,r2
 3202b1c:	e0bdf117 	ldw	r2,-2108(fp)
 3202b20:	10c5883a 	add	r2,r2,r3
 3202b24:	e0bdf115 	stw	r2,-2108(fp)
			else if (reg[0] == 'r' && reg[1] == 't') {
				data0 = IORD_SENSOR_RED_THRESHOLD_MIN(SENSOR_BASE);
				data1 = IORD_SENSOR_RED_THRESHOLD_MAX(SENSOR_BASE);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			else if (reg[0] == 'g' && reg[1] == 't') {
 3202b28:	0000a606 	br	3202dc4 <sss_exec_command+0x704>
				data0 = IORD_SENSOR_GREEN_THRESHOLD_MIN(SENSOR_BASE);
				data1 = IORD_SENSOR_GREEN_THRESHOLD_MAX(SENSOR_BASE);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			else if (reg[0] == 'b' && reg[1] == 't') {
 3202b2c:	e0bff343 	ldbu	r2,-51(fp)
 3202b30:	10803fcc 	andi	r2,r2,255
 3202b34:	1080201c 	xori	r2,r2,128
 3202b38:	10bfe004 	addi	r2,r2,-128
 3202b3c:	10801898 	cmpnei	r2,r2,98
 3202b40:	1000191e 	bne	r2,zero,3202ba8 <sss_exec_command+0x4e8>
 3202b44:	e0bff383 	ldbu	r2,-50(fp)
 3202b48:	10803fcc 	andi	r2,r2,255
 3202b4c:	1080201c 	xori	r2,r2,128
 3202b50:	10bfe004 	addi	r2,r2,-128
 3202b54:	10801d18 	cmpnei	r2,r2,116
 3202b58:	1000131e 	bne	r2,zero,3202ba8 <sss_exec_command+0x4e8>
				data0 = IORD_SENSOR_BLUE_THRESHOLD_MIN(SENSOR_BASE);
 3202b5c:	0080d034 	movhi	r2,832
 3202b60:	10881004 	addi	r2,r2,8256
 3202b64:	10800037 	ldwio	r2,0(r2)
 3202b68:	e0bff415 	stw	r2,-48(fp)
				data1 = IORD_SENSOR_BLUE_THRESHOLD_MAX(SENSOR_BASE);
 3202b6c:	0080d034 	movhi	r2,832
 3202b70:	10881404 	addi	r2,r2,8272
 3202b74:	10800037 	ldwio	r2,0(r2)
 3202b78:	e0bff515 	stw	r2,-44(fp)
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
 3202b7c:	e13df117 	ldw	r4,-2108(fp)
 3202b80:	e1bff417 	ldw	r6,-48(fp)
 3202b84:	e1fff517 	ldw	r7,-44(fp)
 3202b88:	0140c974 	movhi	r5,805
 3202b8c:	29755004 	addi	r5,r5,-10944
 3202b90:	32079c00 	call	32079c0 <sprintf>
 3202b94:	1007883a 	mov	r3,r2
 3202b98:	e0bdf117 	ldw	r2,-2108(fp)
 3202b9c:	10c5883a 	add	r2,r2,r3
 3202ba0:	e0bdf115 	stw	r2,-2108(fp)
			else if (reg[0] == 'g' && reg[1] == 't') {
				data0 = IORD_SENSOR_GREEN_THRESHOLD_MIN(SENSOR_BASE);
				data1 = IORD_SENSOR_GREEN_THRESHOLD_MAX(SENSOR_BASE);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			else if (reg[0] == 'b' && reg[1] == 't') {
 3202ba4:	00008706 	br	3202dc4 <sss_exec_command+0x704>
				data0 = IORD_SENSOR_BLUE_THRESHOLD_MIN(SENSOR_BASE);
				data1 = IORD_SENSOR_BLUE_THRESHOLD_MAX(SENSOR_BASE);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			/* Reads the number of tracker resources */
			else if (reg[0] == 't' && reg[1] == 'r') {
 3202ba8:	e0bff343 	ldbu	r2,-51(fp)
 3202bac:	10803fcc 	andi	r2,r2,255
 3202bb0:	1080201c 	xori	r2,r2,128
 3202bb4:	10bfe004 	addi	r2,r2,-128
 3202bb8:	10801d18 	cmpnei	r2,r2,116
 3202bbc:	1000121e 	bne	r2,zero,3202c08 <sss_exec_command+0x548>
 3202bc0:	e0bff383 	ldbu	r2,-50(fp)
 3202bc4:	10803fcc 	andi	r2,r2,255
 3202bc8:	1080201c 	xori	r2,r2,128
 3202bcc:	10bfe004 	addi	r2,r2,-128
 3202bd0:	10801c98 	cmpnei	r2,r2,114
 3202bd4:	10000c1e 	bne	r2,zero,3202c08 <sss_exec_command+0x548>
				tx_wr_pos += sprintf(tx_wr_pos, "%i", trackers_number());
 3202bd8:	e43df117 	ldw	r16,-2108(fp)
 3202bdc:	3203ca00 	call	3203ca0 <trackers_number>
 3202be0:	100d883a 	mov	r6,r2
 3202be4:	8009883a 	mov	r4,r16
 3202be8:	0140c974 	movhi	r5,805
 3202bec:	29755204 	addi	r5,r5,-10936
 3202bf0:	32079c00 	call	32079c0 <sprintf>
 3202bf4:	1007883a 	mov	r3,r2
 3202bf8:	e0bdf117 	ldw	r2,-2108(fp)
 3202bfc:	10c5883a 	add	r2,r2,r3
 3202c00:	e0bdf115 	stw	r2,-2108(fp)
				data0 = IORD_SENSOR_BLUE_THRESHOLD_MIN(SENSOR_BASE);
				data1 = IORD_SENSOR_BLUE_THRESHOLD_MAX(SENSOR_BASE);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			/* Reads the number of tracker resources */
			else if (reg[0] == 't' && reg[1] == 'r') {
 3202c04:	00006f06 	br	3202dc4 <sss_exec_command+0x704>
				tx_wr_pos += sprintf(tx_wr_pos, "%i", trackers_number());
			}
			/* Reads the search window of the assigned tracker (left, top, right, bottom) */
			else if (reg[0] == 's' && reg[1] == 'w') {
 3202c08:	e0bff343 	ldbu	r2,-51(fp)
 3202c0c:	10803fcc 	andi	r2,r2,255
 3202c10:	1080201c 	xori	r2,r2,128
 3202c14:	10bfe004 	addi	r2,r2,-128
 3202c18:	10801cd8 	cmpnei	r2,r2,115
 3202c1c:	10000e1e 	bne	r2,zero,3202c58 <sss_exec_command+0x598>
 3202c20:	e0bff383 	ldbu	r2,-50(fp)
 3202c24:	10803fcc 	andi	r2,r2,255
 3202c28:	1080201c 	xori	r2,r2,128
 3202c2c:	10bfe004 	addi	r2,r2,-128
 3202c30:	10801dd8 	cmpnei	r2,r2,119
 3202c34:	1000081e 	bne	r2,zero,3202c58 <sss_exec_command+0x598>
				tx_wr_pos += get_search_window_of_tracker(data0, tx_wr_pos);
 3202c38:	e13ff417 	ldw	r4,-48(fp)
 3202c3c:	e17df117 	ldw	r5,-2108(fp)
 3202c40:	32042240 	call	3204224 <get_search_window_of_tracker>
 3202c44:	1007883a 	mov	r3,r2
 3202c48:	e0bdf117 	ldw	r2,-2108(fp)
 3202c4c:	10c5883a 	add	r2,r2,r3
 3202c50:	e0bdf115 	stw	r2,-2108(fp)
			/* Reads the number of tracker resources */
			else if (reg[0] == 't' && reg[1] == 'r') {
				tx_wr_pos += sprintf(tx_wr_pos, "%i", trackers_number());
			}
			/* Reads the search window of the assigned tracker (left, top, right, bottom) */
			else if (reg[0] == 's' && reg[1] == 'w') {
 3202c54:	00005b06 	br	3202dc4 <sss_exec_command+0x704>
				tx_wr_pos += get_search_window_of_tracker(data0, tx_wr_pos);
			}
			/* Reads the corners locations of the assigned tracker ((x0, y0),...,(x7,y7)) */
			else if (reg[0] == 'c' && reg[1] == 'l') {
 3202c58:	e0bff343 	ldbu	r2,-51(fp)
 3202c5c:	10803fcc 	andi	r2,r2,255
 3202c60:	1080201c 	xori	r2,r2,128
 3202c64:	10bfe004 	addi	r2,r2,-128
 3202c68:	108018d8 	cmpnei	r2,r2,99
 3202c6c:	1000161e 	bne	r2,zero,3202cc8 <sss_exec_command+0x608>
 3202c70:	e0bff383 	ldbu	r2,-50(fp)
 3202c74:	10803fcc 	andi	r2,r2,255
 3202c78:	1080201c 	xori	r2,r2,128
 3202c7c:	10bfe004 	addi	r2,r2,-128
 3202c80:	10801b18 	cmpnei	r2,r2,108
 3202c84:	1000101e 	bne	r2,zero,3202cc8 <sss_exec_command+0x608>
				while (!IORD_CAMERA_CAPTURE_DONE(CAMERA_BASE)) OSTimeDly(1);
 3202c88:	00000206 	br	3202c94 <sss_exec_command+0x5d4>
 3202c8c:	01000044 	movi	r4,1
 3202c90:	321d27c0 	call	321d27c <OSTimeDly>
 3202c94:	0080d034 	movhi	r2,832
 3202c98:	10890004 	addi	r2,r2,9216
 3202c9c:	10800037 	ldwio	r2,0(r2)
 3202ca0:	1005003a 	cmpeq	r2,r2,zero
 3202ca4:	103ff91e 	bne	r2,zero,3202c8c <sss_exec_command+0x5cc>
				tx_wr_pos += get_current_corners_of_tracker(data0, tx_wr_pos);
 3202ca8:	e13ff417 	ldw	r4,-48(fp)
 3202cac:	e17df117 	ldw	r5,-2108(fp)
 3202cb0:	32042d80 	call	32042d8 <get_current_corners_of_tracker>
 3202cb4:	1007883a 	mov	r3,r2
 3202cb8:	e0bdf117 	ldw	r2,-2108(fp)
 3202cbc:	10c5883a 	add	r2,r2,r3
 3202cc0:	e0bdf115 	stw	r2,-2108(fp)
			/* Reads the search window of the assigned tracker (left, top, right, bottom) */
			else if (reg[0] == 's' && reg[1] == 'w') {
				tx_wr_pos += get_search_window_of_tracker(data0, tx_wr_pos);
			}
			/* Reads the corners locations of the assigned tracker ((x0, y0),...,(x7,y7)) */
			else if (reg[0] == 'c' && reg[1] == 'l') {
 3202cc4:	00003f06 	br	3202dc4 <sss_exec_command+0x704>
				while (!IORD_CAMERA_CAPTURE_DONE(CAMERA_BASE)) OSTimeDly(1);
				tx_wr_pos += get_current_corners_of_tracker(data0, tx_wr_pos);
			}
			/* Reads all search windows of activated trackers */
			else if (reg[0] == 'a' && reg[1] == 'w') {
 3202cc8:	e0bff343 	ldbu	r2,-51(fp)
 3202ccc:	10803fcc 	andi	r2,r2,255
 3202cd0:	1080201c 	xori	r2,r2,128
 3202cd4:	10bfe004 	addi	r2,r2,-128
 3202cd8:	10801858 	cmpnei	r2,r2,97
 3202cdc:	10000d1e 	bne	r2,zero,3202d14 <sss_exec_command+0x654>
 3202ce0:	e0bff383 	ldbu	r2,-50(fp)
 3202ce4:	10803fcc 	andi	r2,r2,255
 3202ce8:	1080201c 	xori	r2,r2,128
 3202cec:	10bfe004 	addi	r2,r2,-128
 3202cf0:	10801dd8 	cmpnei	r2,r2,119
 3202cf4:	1000071e 	bne	r2,zero,3202d14 <sss_exec_command+0x654>
				//while (!IORD_CAMERA_CAPTURE_DONE(CAMERA_BASE));
				// Reads all search windows
				tx_wr_pos += get_current_windows_of_activated_trackers(tx_wr_pos);
 3202cf8:	e13df117 	ldw	r4,-2108(fp)
 3202cfc:	320438c0 	call	320438c <get_current_windows_of_activated_trackers>
 3202d00:	1007883a 	mov	r3,r2
 3202d04:	e0bdf117 	ldw	r2,-2108(fp)
 3202d08:	10c5883a 	add	r2,r2,r3
 3202d0c:	e0bdf115 	stw	r2,-2108(fp)
			else if (reg[0] == 'c' && reg[1] == 'l') {
				while (!IORD_CAMERA_CAPTURE_DONE(CAMERA_BASE)) OSTimeDly(1);
				tx_wr_pos += get_current_corners_of_tracker(data0, tx_wr_pos);
			}
			/* Reads all search windows of activated trackers */
			else if (reg[0] == 'a' && reg[1] == 'w') {
 3202d10:	00002c06 	br	3202dc4 <sss_exec_command+0x704>
				//while (!IORD_CAMERA_CAPTURE_DONE(CAMERA_BASE));
				// Reads all search windows
				tx_wr_pos += get_current_windows_of_activated_trackers(tx_wr_pos);
			}
			/* Reads all corners locations and captures a new frame */
			else if (reg[0] == 'a' && reg[1] == 'l') {
 3202d14:	e0bff343 	ldbu	r2,-51(fp)
 3202d18:	10803fcc 	andi	r2,r2,255
 3202d1c:	1080201c 	xori	r2,r2,128
 3202d20:	10bfe004 	addi	r2,r2,-128
 3202d24:	10801858 	cmpnei	r2,r2,97
 3202d28:	10001c1e 	bne	r2,zero,3202d9c <sss_exec_command+0x6dc>
 3202d2c:	e0bff383 	ldbu	r2,-50(fp)
 3202d30:	10803fcc 	andi	r2,r2,255
 3202d34:	1080201c 	xori	r2,r2,128
 3202d38:	10bfe004 	addi	r2,r2,-128
 3202d3c:	10801b18 	cmpnei	r2,r2,108
 3202d40:	1000161e 	bne	r2,zero,3202d9c <sss_exec_command+0x6dc>
				while (!IORD_CAMERA_CAPTURE_DONE(CAMERA_BASE)) OSTimeDly(1);
 3202d44:	00000206 	br	3202d50 <sss_exec_command+0x690>
 3202d48:	01000044 	movi	r4,1
 3202d4c:	321d27c0 	call	321d27c <OSTimeDly>
 3202d50:	0080d034 	movhi	r2,832
 3202d54:	10890004 	addi	r2,r2,9216
 3202d58:	10800037 	ldwio	r2,0(r2)
 3202d5c:	1005003a 	cmpeq	r2,r2,zero
 3202d60:	103ff91e 	bne	r2,zero,3202d48 <sss_exec_command+0x688>
				// Captures a new frame
				IOWR_CAMERA_CAPTURE_START(CAMERA_BASE);
 3202d64:	00c0d034 	movhi	r3,832
 3202d68:	18c90004 	addi	r3,r3,9216
 3202d6c:	00800044 	movi	r2,1
 3202d70:	18800035 	stwio	r2,0(r3)
				IOWR_CAMERA_CAPTURE_STOP(CAMERA_BASE);
 3202d74:	0080d034 	movhi	r2,832
 3202d78:	10890004 	addi	r2,r2,9216
 3202d7c:	10000035 	stwio	zero,0(r2)
				// Reads all corners locations
				tx_wr_pos += get_current_corners_of_activated_trackers(tx_wr_pos);
 3202d80:	e13df117 	ldw	r4,-2108(fp)
 3202d84:	32045080 	call	3204508 <get_current_corners_of_activated_trackers>
 3202d88:	1007883a 	mov	r3,r2
 3202d8c:	e0bdf117 	ldw	r2,-2108(fp)
 3202d90:	10c5883a 	add	r2,r2,r3
 3202d94:	e0bdf115 	stw	r2,-2108(fp)
				//while (!IORD_CAMERA_CAPTURE_DONE(CAMERA_BASE));
				// Reads all search windows
				tx_wr_pos += get_current_windows_of_activated_trackers(tx_wr_pos);
			}
			/* Reads all corners locations and captures a new frame */
			else if (reg[0] == 'a' && reg[1] == 'l') {
 3202d98:	00000a06 	br	3202dc4 <sss_exec_command+0x704>
				IOWR_CAMERA_CAPTURE_STOP(CAMERA_BASE);
				// Reads all corners locations
				tx_wr_pos += get_current_corners_of_activated_trackers(tx_wr_pos);
			}
			else {
				tx_wr_pos += sprintf(tx_wr_pos, "Wrong command!");
 3202d9c:	e0bdf117 	ldw	r2,-2108(fp)
 3202da0:	00c0c974 	movhi	r3,805
 3202da4:	18f55304 	addi	r3,r3,-10932
 3202da8:	1009883a 	mov	r4,r2
 3202dac:	180b883a 	mov	r5,r3
 3202db0:	018003c4 	movi	r6,15
 3202db4:	3206ad00 	call	3206ad0 <memcpy>
 3202db8:	e0bdf117 	ldw	r2,-2108(fp)
 3202dbc:	10800384 	addi	r2,r2,14
 3202dc0:	e0bdf115 	stw	r2,-2108(fp)
			}
			tx_wr_pos += sprintf(tx_wr_pos, "\n");
 3202dc4:	e0fdf117 	ldw	r3,-2108(fp)
 3202dc8:	00800284 	movi	r2,10
 3202dcc:	18800005 	stb	r2,0(r3)
 3202dd0:	18000045 	stb	zero,1(r3)
 3202dd4:	e0bdf117 	ldw	r2,-2108(fp)
 3202dd8:	10800044 	addi	r2,r2,1
 3202ddc:	e0bdf115 	stw	r2,-2108(fp)
			break;
 3202de0:	0001ce06 	br	320351c <sss_exec_command+0xe5c>
		case CMD_WRITE:
			/* Writes camera image registers */
			if (reg[0] == 'i' && reg[1] == 's') { // image size (width, height)
 3202de4:	e0bff343 	ldbu	r2,-51(fp)
 3202de8:	10803fcc 	andi	r2,r2,255
 3202dec:	1080201c 	xori	r2,r2,128
 3202df0:	10bfe004 	addi	r2,r2,-128
 3202df4:	10801a58 	cmpnei	r2,r2,105
 3202df8:	1000111e 	bne	r2,zero,3202e40 <sss_exec_command+0x780>
 3202dfc:	e0bff383 	ldbu	r2,-50(fp)
 3202e00:	10803fcc 	andi	r2,r2,255
 3202e04:	1080201c 	xori	r2,r2,128
 3202e08:	10bfe004 	addi	r2,r2,-128
 3202e0c:	10801cd8 	cmpnei	r2,r2,115
 3202e10:	10000b1e 	bne	r2,zero,3202e40 <sss_exec_command+0x780>
				tx_wr_pos += set_image_size(&camera, tx_wr_pos, data0, data1);
 3202e14:	e17df117 	ldw	r5,-2108(fp)
 3202e18:	e1bff417 	ldw	r6,-48(fp)
 3202e1c:	e1fff517 	ldw	r7,-44(fp)
 3202e20:	0100c974 	movhi	r4,805
 3202e24:	21027504 	addi	r4,r4,2516
 3202e28:	32010880 	call	3201088 <set_image_size>
 3202e2c:	1007883a 	mov	r3,r2
 3202e30:	e0bdf117 	ldw	r2,-2108(fp)
 3202e34:	10c5883a 	add	r2,r2,r3
 3202e38:	e0bdf115 	stw	r2,-2108(fp)
			}
			tx_wr_pos += sprintf(tx_wr_pos, "\n");
			break;
		case CMD_WRITE:
			/* Writes camera image registers */
			if (reg[0] == 'i' && reg[1] == 's') { // image size (width, height)
 3202e3c:	00014106 	br	3203344 <sss_exec_command+0xc84>
				tx_wr_pos += set_image_size(&camera, tx_wr_pos, data0, data1);
			}
			else if (reg[0] == 'i' && reg[1] == 'e') { // image exposure (exposure)
 3202e40:	e0bff343 	ldbu	r2,-51(fp)
 3202e44:	10803fcc 	andi	r2,r2,255
 3202e48:	1080201c 	xori	r2,r2,128
 3202e4c:	10bfe004 	addi	r2,r2,-128
 3202e50:	10801a58 	cmpnei	r2,r2,105
 3202e54:	1000101e 	bne	r2,zero,3202e98 <sss_exec_command+0x7d8>
 3202e58:	e0bff383 	ldbu	r2,-50(fp)
 3202e5c:	10803fcc 	andi	r2,r2,255
 3202e60:	1080201c 	xori	r2,r2,128
 3202e64:	10bfe004 	addi	r2,r2,-128
 3202e68:	10801958 	cmpnei	r2,r2,101
 3202e6c:	10000a1e 	bne	r2,zero,3202e98 <sss_exec_command+0x7d8>
				tx_wr_pos += set_image_exposure(&camera, tx_wr_pos, data0);
 3202e70:	e17df117 	ldw	r5,-2108(fp)
 3202e74:	e1bff417 	ldw	r6,-48(fp)
 3202e78:	0100c974 	movhi	r4,805
 3202e7c:	21027504 	addi	r4,r4,2516
 3202e80:	32011300 	call	3201130 <set_image_exposure>
 3202e84:	1007883a 	mov	r3,r2
 3202e88:	e0bdf117 	ldw	r2,-2108(fp)
 3202e8c:	10c5883a 	add	r2,r2,r3
 3202e90:	e0bdf115 	stw	r2,-2108(fp)
		case CMD_WRITE:
			/* Writes camera image registers */
			if (reg[0] == 'i' && reg[1] == 's') { // image size (width, height)
				tx_wr_pos += set_image_size(&camera, tx_wr_pos, data0, data1);
			}
			else if (reg[0] == 'i' && reg[1] == 'e') { // image exposure (exposure)
 3202e94:	00012b06 	br	3203344 <sss_exec_command+0xc84>
				tx_wr_pos += set_image_exposure(&camera, tx_wr_pos, data0);
			}
			else if (reg[0] == 's' && reg[1] == 'i') { // start image (start_column, start_row)
 3202e98:	e0bff343 	ldbu	r2,-51(fp)
 3202e9c:	10803fcc 	andi	r2,r2,255
 3202ea0:	1080201c 	xori	r2,r2,128
 3202ea4:	10bfe004 	addi	r2,r2,-128
 3202ea8:	10801cd8 	cmpnei	r2,r2,115
 3202eac:	1000111e 	bne	r2,zero,3202ef4 <sss_exec_command+0x834>
 3202eb0:	e0bff383 	ldbu	r2,-50(fp)
 3202eb4:	10803fcc 	andi	r2,r2,255
 3202eb8:	1080201c 	xori	r2,r2,128
 3202ebc:	10bfe004 	addi	r2,r2,-128
 3202ec0:	10801a58 	cmpnei	r2,r2,105
 3202ec4:	10000b1e 	bne	r2,zero,3202ef4 <sss_exec_command+0x834>
				tx_wr_pos += set_start_image(&camera, tx_wr_pos, data0, data1);
 3202ec8:	e17df117 	ldw	r5,-2108(fp)
 3202ecc:	e1bff417 	ldw	r6,-48(fp)
 3202ed0:	e1fff517 	ldw	r7,-44(fp)
 3202ed4:	0100c974 	movhi	r4,805
 3202ed8:	21027504 	addi	r4,r4,2516
 3202edc:	32011d00 	call	32011d0 <set_start_image>
 3202ee0:	1007883a 	mov	r3,r2
 3202ee4:	e0bdf117 	ldw	r2,-2108(fp)
 3202ee8:	10c5883a 	add	r2,r2,r3
 3202eec:	e0bdf115 	stw	r2,-2108(fp)
				tx_wr_pos += set_image_size(&camera, tx_wr_pos, data0, data1);
			}
			else if (reg[0] == 'i' && reg[1] == 'e') { // image exposure (exposure)
				tx_wr_pos += set_image_exposure(&camera, tx_wr_pos, data0);
			}
			else if (reg[0] == 's' && reg[1] == 'i') { // start image (start_column, start_row)
 3202ef0:	00011406 	br	3203344 <sss_exec_command+0xc84>
				tx_wr_pos += set_start_image(&camera, tx_wr_pos, data0, data1);
			}
			else if (reg[0] == 's' && reg[1] == 's'){ // sensor size (column_size, row_size)
 3202ef4:	e0bff343 	ldbu	r2,-51(fp)
 3202ef8:	10803fcc 	andi	r2,r2,255
 3202efc:	1080201c 	xori	r2,r2,128
 3202f00:	10bfe004 	addi	r2,r2,-128
 3202f04:	10801cd8 	cmpnei	r2,r2,115
 3202f08:	1000111e 	bne	r2,zero,3202f50 <sss_exec_command+0x890>
 3202f0c:	e0bff383 	ldbu	r2,-50(fp)
 3202f10:	10803fcc 	andi	r2,r2,255
 3202f14:	1080201c 	xori	r2,r2,128
 3202f18:	10bfe004 	addi	r2,r2,-128
 3202f1c:	10801cd8 	cmpnei	r2,r2,115
 3202f20:	10000b1e 	bne	r2,zero,3202f50 <sss_exec_command+0x890>
				tx_wr_pos += set_sensor_size(&camera, tx_wr_pos, data0, data1);
 3202f24:	e17df117 	ldw	r5,-2108(fp)
 3202f28:	e1bff417 	ldw	r6,-48(fp)
 3202f2c:	e1fff517 	ldw	r7,-44(fp)
 3202f30:	0100c974 	movhi	r4,805
 3202f34:	21027504 	addi	r4,r4,2516
 3202f38:	32012800 	call	3201280 <set_sensor_size>
 3202f3c:	1007883a 	mov	r3,r2
 3202f40:	e0bdf117 	ldw	r2,-2108(fp)
 3202f44:	10c5883a 	add	r2,r2,r3
 3202f48:	e0bdf115 	stw	r2,-2108(fp)
				tx_wr_pos += set_image_exposure(&camera, tx_wr_pos, data0);
			}
			else if (reg[0] == 's' && reg[1] == 'i') { // start image (start_column, start_row)
				tx_wr_pos += set_start_image(&camera, tx_wr_pos, data0, data1);
			}
			else if (reg[0] == 's' && reg[1] == 's'){ // sensor size (column_size, row_size)
 3202f4c:	0000fd06 	br	3203344 <sss_exec_command+0xc84>
				tx_wr_pos += set_sensor_size(&camera, tx_wr_pos, data0, data1);
			}
			else if (reg[0] == 's' && reg[1] == 'm'){ // sensor mode (column_mode, row_mode)
 3202f50:	e0bff343 	ldbu	r2,-51(fp)
 3202f54:	10803fcc 	andi	r2,r2,255
 3202f58:	1080201c 	xori	r2,r2,128
 3202f5c:	10bfe004 	addi	r2,r2,-128
 3202f60:	10801cd8 	cmpnei	r2,r2,115
 3202f64:	1000111e 	bne	r2,zero,3202fac <sss_exec_command+0x8ec>
 3202f68:	e0bff383 	ldbu	r2,-50(fp)
 3202f6c:	10803fcc 	andi	r2,r2,255
 3202f70:	1080201c 	xori	r2,r2,128
 3202f74:	10bfe004 	addi	r2,r2,-128
 3202f78:	10801b58 	cmpnei	r2,r2,109
 3202f7c:	10000b1e 	bne	r2,zero,3202fac <sss_exec_command+0x8ec>
				tx_wr_pos += set_sensor_mode(&camera, tx_wr_pos, data0, data1);
 3202f80:	e17df117 	ldw	r5,-2108(fp)
 3202f84:	e1bff417 	ldw	r6,-48(fp)
 3202f88:	e1fff517 	ldw	r7,-44(fp)
 3202f8c:	0100c974 	movhi	r4,805
 3202f90:	21027504 	addi	r4,r4,2516
 3202f94:	32013300 	call	3201330 <set_sensor_mode>
 3202f98:	1007883a 	mov	r3,r2
 3202f9c:	e0bdf117 	ldw	r2,-2108(fp)
 3202fa0:	10c5883a 	add	r2,r2,r3
 3202fa4:	e0bdf115 	stw	r2,-2108(fp)
				tx_wr_pos += set_start_image(&camera, tx_wr_pos, data0, data1);
			}
			else if (reg[0] == 's' && reg[1] == 's'){ // sensor size (column_size, row_size)
				tx_wr_pos += set_sensor_size(&camera, tx_wr_pos, data0, data1);
			}
			else if (reg[0] == 's' && reg[1] == 'm'){ // sensor mode (column_mode, row_mode)
 3202fa8:	0000e606 	br	3203344 <sss_exec_command+0xc84>
				tx_wr_pos += set_sensor_mode(&camera, tx_wr_pos, data0, data1);
			}
			/* Writes the selected sensor output */
			else if (reg[0] == 's' && reg[1] == 'o') { //  select output
 3202fac:	e0bff343 	ldbu	r2,-51(fp)
 3202fb0:	10803fcc 	andi	r2,r2,255
 3202fb4:	1080201c 	xori	r2,r2,128
 3202fb8:	10bfe004 	addi	r2,r2,-128
 3202fbc:	10801cd8 	cmpnei	r2,r2,115
 3202fc0:	1000101e 	bne	r2,zero,3203004 <sss_exec_command+0x944>
 3202fc4:	e0bff383 	ldbu	r2,-50(fp)
 3202fc8:	10803fcc 	andi	r2,r2,255
 3202fcc:	1080201c 	xori	r2,r2,128
 3202fd0:	10bfe004 	addi	r2,r2,-128
 3202fd4:	10801bd8 	cmpnei	r2,r2,111
 3202fd8:	10000a1e 	bne	r2,zero,3203004 <sss_exec_command+0x944>
				tx_wr_pos += select_sensor_output(&camera, tx_wr_pos, data0);
 3202fdc:	e17df117 	ldw	r5,-2108(fp)
 3202fe0:	e1bff417 	ldw	r6,-48(fp)
 3202fe4:	0100c974 	movhi	r4,805
 3202fe8:	21027504 	addi	r4,r4,2516
 3202fec:	32014400 	call	3201440 <select_sensor_output>
 3202ff0:	1007883a 	mov	r3,r2
 3202ff4:	e0bdf117 	ldw	r2,-2108(fp)
 3202ff8:	10c5883a 	add	r2,r2,r3
 3202ffc:	e0bdf115 	stw	r2,-2108(fp)
			}
			else if (reg[0] == 's' && reg[1] == 'm'){ // sensor mode (column_mode, row_mode)
				tx_wr_pos += set_sensor_mode(&camera, tx_wr_pos, data0, data1);
			}
			/* Writes the selected sensor output */
			else if (reg[0] == 's' && reg[1] == 'o') { //  select output
 3203000:	0000d006 	br	3203344 <sss_exec_command+0xc84>
				tx_wr_pos += select_sensor_output(&camera, tx_wr_pos, data0);
			}
			// TODO: Group sensor configuration functions
			/* Writes thresholds (min, max) */
			else if (reg[0] == 'r' && reg[1] == 't'){
 3203004:	e0bff343 	ldbu	r2,-51(fp)
 3203008:	10803fcc 	andi	r2,r2,255
 320300c:	1080201c 	xori	r2,r2,128
 3203010:	10bfe004 	addi	r2,r2,-128
 3203014:	10801c98 	cmpnei	r2,r2,114
 3203018:	1000191e 	bne	r2,zero,3203080 <sss_exec_command+0x9c0>
 320301c:	e0bff383 	ldbu	r2,-50(fp)
 3203020:	10803fcc 	andi	r2,r2,255
 3203024:	1080201c 	xori	r2,r2,128
 3203028:	10bfe004 	addi	r2,r2,-128
 320302c:	10801d18 	cmpnei	r2,r2,116
 3203030:	1000131e 	bne	r2,zero,3203080 <sss_exec_command+0x9c0>
				IOWR_SENSOR_RED_THRESHOLD_MIN(SENSOR_BASE, data0);
 3203034:	e0fff417 	ldw	r3,-48(fp)
 3203038:	0080d034 	movhi	r2,832
 320303c:	10880004 	addi	r2,r2,8192
 3203040:	10c00035 	stwio	r3,0(r2)
				IOWR_SENSOR_RED_THRESHOLD_MAX(SENSOR_BASE, data1);
 3203044:	e0fff517 	ldw	r3,-44(fp)
 3203048:	0080d034 	movhi	r2,832
 320304c:	10880404 	addi	r2,r2,8208
 3203050:	10c00035 	stwio	r3,0(r2)
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
 3203054:	e13df117 	ldw	r4,-2108(fp)
 3203058:	e1bff417 	ldw	r6,-48(fp)
 320305c:	e1fff517 	ldw	r7,-44(fp)
 3203060:	0140c974 	movhi	r5,805
 3203064:	29755004 	addi	r5,r5,-10944
 3203068:	32079c00 	call	32079c0 <sprintf>
 320306c:	1007883a 	mov	r3,r2
 3203070:	e0bdf117 	ldw	r2,-2108(fp)
 3203074:	10c5883a 	add	r2,r2,r3
 3203078:	e0bdf115 	stw	r2,-2108(fp)
			else if (reg[0] == 's' && reg[1] == 'o') { //  select output
				tx_wr_pos += select_sensor_output(&camera, tx_wr_pos, data0);
			}
			// TODO: Group sensor configuration functions
			/* Writes thresholds (min, max) */
			else if (reg[0] == 'r' && reg[1] == 't'){
 320307c:	0000b106 	br	3203344 <sss_exec_command+0xc84>
				IOWR_SENSOR_RED_THRESHOLD_MIN(SENSOR_BASE, data0);
				IOWR_SENSOR_RED_THRESHOLD_MAX(SENSOR_BASE, data1);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			else if (reg[0] == 'g' && reg[1] == 't'){
 3203080:	e0bff343 	ldbu	r2,-51(fp)
 3203084:	10803fcc 	andi	r2,r2,255
 3203088:	1080201c 	xori	r2,r2,128
 320308c:	10bfe004 	addi	r2,r2,-128
 3203090:	108019d8 	cmpnei	r2,r2,103
 3203094:	1000191e 	bne	r2,zero,32030fc <sss_exec_command+0xa3c>
 3203098:	e0bff383 	ldbu	r2,-50(fp)
 320309c:	10803fcc 	andi	r2,r2,255
 32030a0:	1080201c 	xori	r2,r2,128
 32030a4:	10bfe004 	addi	r2,r2,-128
 32030a8:	10801d18 	cmpnei	r2,r2,116
 32030ac:	1000131e 	bne	r2,zero,32030fc <sss_exec_command+0xa3c>
				IOWR_SENSOR_GREEN_THRESHOLD_MIN(SENSOR_BASE, data0);
 32030b0:	e0fff417 	ldw	r3,-48(fp)
 32030b4:	0080d034 	movhi	r2,832
 32030b8:	10880804 	addi	r2,r2,8224
 32030bc:	10c00035 	stwio	r3,0(r2)
				IOWR_SENSOR_GREEN_THRESHOLD_MAX(SENSOR_BASE, data1);
 32030c0:	e0fff517 	ldw	r3,-44(fp)
 32030c4:	0080d034 	movhi	r2,832
 32030c8:	10880c04 	addi	r2,r2,8240
 32030cc:	10c00035 	stwio	r3,0(r2)
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
 32030d0:	e13df117 	ldw	r4,-2108(fp)
 32030d4:	e1bff417 	ldw	r6,-48(fp)
 32030d8:	e1fff517 	ldw	r7,-44(fp)
 32030dc:	0140c974 	movhi	r5,805
 32030e0:	29755004 	addi	r5,r5,-10944
 32030e4:	32079c00 	call	32079c0 <sprintf>
 32030e8:	1007883a 	mov	r3,r2
 32030ec:	e0bdf117 	ldw	r2,-2108(fp)
 32030f0:	10c5883a 	add	r2,r2,r3
 32030f4:	e0bdf115 	stw	r2,-2108(fp)
			else if (reg[0] == 'r' && reg[1] == 't'){
				IOWR_SENSOR_RED_THRESHOLD_MIN(SENSOR_BASE, data0);
				IOWR_SENSOR_RED_THRESHOLD_MAX(SENSOR_BASE, data1);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			else if (reg[0] == 'g' && reg[1] == 't'){
 32030f8:	00009206 	br	3203344 <sss_exec_command+0xc84>
				IOWR_SENSOR_GREEN_THRESHOLD_MIN(SENSOR_BASE, data0);
				IOWR_SENSOR_GREEN_THRESHOLD_MAX(SENSOR_BASE, data1);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			else if (reg[0] == 'b' && reg[1] == 't'){
 32030fc:	e0bff343 	ldbu	r2,-51(fp)
 3203100:	10803fcc 	andi	r2,r2,255
 3203104:	1080201c 	xori	r2,r2,128
 3203108:	10bfe004 	addi	r2,r2,-128
 320310c:	10801898 	cmpnei	r2,r2,98
 3203110:	1000191e 	bne	r2,zero,3203178 <sss_exec_command+0xab8>
 3203114:	e0bff383 	ldbu	r2,-50(fp)
 3203118:	10803fcc 	andi	r2,r2,255
 320311c:	1080201c 	xori	r2,r2,128
 3203120:	10bfe004 	addi	r2,r2,-128
 3203124:	10801d18 	cmpnei	r2,r2,116
 3203128:	1000131e 	bne	r2,zero,3203178 <sss_exec_command+0xab8>
				IOWR_SENSOR_BLUE_THRESHOLD_MIN(SENSOR_BASE, data0);
 320312c:	e0fff417 	ldw	r3,-48(fp)
 3203130:	0080d034 	movhi	r2,832
 3203134:	10881004 	addi	r2,r2,8256
 3203138:	10c00035 	stwio	r3,0(r2)
				IOWR_SENSOR_BLUE_THRESHOLD_MAX(SENSOR_BASE, data1);
 320313c:	e0fff517 	ldw	r3,-44(fp)
 3203140:	0080d034 	movhi	r2,832
 3203144:	10881404 	addi	r2,r2,8272
 3203148:	10c00035 	stwio	r3,0(r2)
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
 320314c:	e13df117 	ldw	r4,-2108(fp)
 3203150:	e1bff417 	ldw	r6,-48(fp)
 3203154:	e1fff517 	ldw	r7,-44(fp)
 3203158:	0140c974 	movhi	r5,805
 320315c:	29755004 	addi	r5,r5,-10944
 3203160:	32079c00 	call	32079c0 <sprintf>
 3203164:	1007883a 	mov	r3,r2
 3203168:	e0bdf117 	ldw	r2,-2108(fp)
 320316c:	10c5883a 	add	r2,r2,r3
 3203170:	e0bdf115 	stw	r2,-2108(fp)
			else if (reg[0] == 'g' && reg[1] == 't'){
				IOWR_SENSOR_GREEN_THRESHOLD_MIN(SENSOR_BASE, data0);
				IOWR_SENSOR_GREEN_THRESHOLD_MAX(SENSOR_BASE, data1);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			else if (reg[0] == 'b' && reg[1] == 't'){
 3203174:	00007306 	br	3203344 <sss_exec_command+0xc84>
				IOWR_SENSOR_BLUE_THRESHOLD_MIN(SENSOR_BASE, data0);
				IOWR_SENSOR_BLUE_THRESHOLD_MAX(SENSOR_BASE, data1);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			/* Frees all tracker devices */
			else if (reg[0] == 'f' && reg[1] == 'a') {
 3203178:	e0bff343 	ldbu	r2,-51(fp)
 320317c:	10803fcc 	andi	r2,r2,255
 3203180:	1080201c 	xori	r2,r2,128
 3203184:	10bfe004 	addi	r2,r2,-128
 3203188:	10801998 	cmpnei	r2,r2,102
 320318c:	10000d1e 	bne	r2,zero,32031c4 <sss_exec_command+0xb04>
 3203190:	e0bff383 	ldbu	r2,-50(fp)
 3203194:	10803fcc 	andi	r2,r2,255
 3203198:	1080201c 	xori	r2,r2,128
 320319c:	10bfe004 	addi	r2,r2,-128
 32031a0:	10801858 	cmpnei	r2,r2,97
 32031a4:	1000071e 	bne	r2,zero,32031c4 <sss_exec_command+0xb04>
				tx_wr_pos += trackers_free(tx_wr_pos);
 32031a8:	e13df117 	ldw	r4,-2108(fp)
 32031ac:	3203cc00 	call	3203cc0 <trackers_free>
 32031b0:	1007883a 	mov	r3,r2
 32031b4:	e0bdf117 	ldw	r2,-2108(fp)
 32031b8:	10c5883a 	add	r2,r2,r3
 32031bc:	e0bdf115 	stw	r2,-2108(fp)
				IOWR_SENSOR_BLUE_THRESHOLD_MIN(SENSOR_BASE, data0);
				IOWR_SENSOR_BLUE_THRESHOLD_MAX(SENSOR_BASE, data1);
				tx_wr_pos += sprintf(tx_wr_pos, "(%i,%i)", data0, data1);
			}
			/* Frees all tracker devices */
			else if (reg[0] == 'f' && reg[1] == 'a') {
 32031c0:	00006006 	br	3203344 <sss_exec_command+0xc84>
				tx_wr_pos += trackers_free(tx_wr_pos);
			}
			/* Activates a tracker device. */
			else if (reg[0] == 'a' && reg[1] == 't') {
 32031c4:	e0bff343 	ldbu	r2,-51(fp)
 32031c8:	10803fcc 	andi	r2,r2,255
 32031cc:	1080201c 	xori	r2,r2,128
 32031d0:	10bfe004 	addi	r2,r2,-128
 32031d4:	10801858 	cmpnei	r2,r2,97
 32031d8:	10000e1e 	bne	r2,zero,3203214 <sss_exec_command+0xb54>
 32031dc:	e0bff383 	ldbu	r2,-50(fp)
 32031e0:	10803fcc 	andi	r2,r2,255
 32031e4:	1080201c 	xori	r2,r2,128
 32031e8:	10bfe004 	addi	r2,r2,-128
 32031ec:	10801d18 	cmpnei	r2,r2,116
 32031f0:	1000081e 	bne	r2,zero,3203214 <sss_exec_command+0xb54>
				tx_wr_pos += activate_tracker(data0, tx_wr_pos);
 32031f4:	e13ff417 	ldw	r4,-48(fp)
 32031f8:	e17df117 	ldw	r5,-2108(fp)
 32031fc:	3203d600 	call	3203d60 <activate_tracker>
 3203200:	1007883a 	mov	r3,r2
 3203204:	e0bdf117 	ldw	r2,-2108(fp)
 3203208:	10c5883a 	add	r2,r2,r3
 320320c:	e0bdf115 	stw	r2,-2108(fp)
			/* Frees all tracker devices */
			else if (reg[0] == 'f' && reg[1] == 'a') {
				tx_wr_pos += trackers_free(tx_wr_pos);
			}
			/* Activates a tracker device. */
			else if (reg[0] == 'a' && reg[1] == 't') {
 3203210:	00004c06 	br	3203344 <sss_exec_command+0xc84>
				tx_wr_pos += activate_tracker(data0, tx_wr_pos);
			}
			/* Disables a tracker device. */
			else if (reg[0] == 'd' && reg[1] == 't') {
 3203214:	e0bff343 	ldbu	r2,-51(fp)
 3203218:	10803fcc 	andi	r2,r2,255
 320321c:	1080201c 	xori	r2,r2,128
 3203220:	10bfe004 	addi	r2,r2,-128
 3203224:	10801918 	cmpnei	r2,r2,100
 3203228:	10000e1e 	bne	r2,zero,3203264 <sss_exec_command+0xba4>
 320322c:	e0bff383 	ldbu	r2,-50(fp)
 3203230:	10803fcc 	andi	r2,r2,255
 3203234:	1080201c 	xori	r2,r2,128
 3203238:	10bfe004 	addi	r2,r2,-128
 320323c:	10801d18 	cmpnei	r2,r2,116
 3203240:	1000081e 	bne	r2,zero,3203264 <sss_exec_command+0xba4>
				tx_wr_pos += disable_tracker(data0, tx_wr_pos);
 3203244:	e13ff417 	ldw	r4,-48(fp)
 3203248:	e17df117 	ldw	r5,-2108(fp)
 320324c:	3203ec80 	call	3203ec8 <disable_tracker>
 3203250:	1007883a 	mov	r3,r2
 3203254:	e0bdf117 	ldw	r2,-2108(fp)
 3203258:	10c5883a 	add	r2,r2,r3
 320325c:	e0bdf115 	stw	r2,-2108(fp)
			/* Activates a tracker device. */
			else if (reg[0] == 'a' && reg[1] == 't') {
				tx_wr_pos += activate_tracker(data0, tx_wr_pos);
			}
			/* Disables a tracker device. */
			else if (reg[0] == 'd' && reg[1] == 't') {
 3203260:	00003806 	br	3203344 <sss_exec_command+0xc84>
				tx_wr_pos += disable_tracker(data0, tx_wr_pos);
			}
			/* Frees a tracker device. */
			else if (reg[0] == 'f' && reg[1] == 't') {
 3203264:	e0bff343 	ldbu	r2,-51(fp)
 3203268:	10803fcc 	andi	r2,r2,255
 320326c:	1080201c 	xori	r2,r2,128
 3203270:	10bfe004 	addi	r2,r2,-128
 3203274:	10801998 	cmpnei	r2,r2,102
 3203278:	10000e1e 	bne	r2,zero,32032b4 <sss_exec_command+0xbf4>
 320327c:	e0bff383 	ldbu	r2,-50(fp)
 3203280:	10803fcc 	andi	r2,r2,255
 3203284:	1080201c 	xori	r2,r2,128
 3203288:	10bfe004 	addi	r2,r2,-128
 320328c:	10801d18 	cmpnei	r2,r2,116
 3203290:	1000081e 	bne	r2,zero,32032b4 <sss_exec_command+0xbf4>
				tx_wr_pos += free_tracker(data0, tx_wr_pos);
 3203294:	e13ff417 	ldw	r4,-48(fp)
 3203298:	e17df117 	ldw	r5,-2108(fp)
 320329c:	3203f8c0 	call	3203f8c <free_tracker>
 32032a0:	1007883a 	mov	r3,r2
 32032a4:	e0bdf117 	ldw	r2,-2108(fp)
 32032a8:	10c5883a 	add	r2,r2,r3
 32032ac:	e0bdf115 	stw	r2,-2108(fp)
			/* Disables a tracker device. */
			else if (reg[0] == 'd' && reg[1] == 't') {
				tx_wr_pos += disable_tracker(data0, tx_wr_pos);
			}
			/* Frees a tracker device. */
			else if (reg[0] == 'f' && reg[1] == 't') {
 32032b0:	00002406 	br	3203344 <sss_exec_command+0xc84>
				tx_wr_pos += free_tracker(data0, tx_wr_pos);
			}
			/* Sets a search window for the assigned tracker device (x, y, width, height) */
			else if (reg[0] == 's' && reg[1] == 'w') {
 32032b4:	e0bff343 	ldbu	r2,-51(fp)
 32032b8:	10803fcc 	andi	r2,r2,255
 32032bc:	1080201c 	xori	r2,r2,128
 32032c0:	10bfe004 	addi	r2,r2,-128
 32032c4:	10801cd8 	cmpnei	r2,r2,115
 32032c8:	1000141e 	bne	r2,zero,320331c <sss_exec_command+0xc5c>
 32032cc:	e0bff383 	ldbu	r2,-50(fp)
 32032d0:	10803fcc 	andi	r2,r2,255
 32032d4:	1080201c 	xori	r2,r2,128
 32032d8:	10bfe004 	addi	r2,r2,-128
 32032dc:	10801dd8 	cmpnei	r2,r2,119
 32032e0:	10000e1e 	bne	r2,zero,320331c <sss_exec_command+0xc5c>
				tx_wr_pos += set_search_window_of_tracker(data0, tx_wr_pos, data1, data2, data3, data4);
 32032e4:	e13ff417 	ldw	r4,-48(fp)
 32032e8:	e17df117 	ldw	r5,-2108(fp)
 32032ec:	e1bff517 	ldw	r6,-44(fp)
 32032f0:	e1fff617 	ldw	r7,-40(fp)
 32032f4:	e0bff717 	ldw	r2,-36(fp)
 32032f8:	e0fff817 	ldw	r3,-32(fp)
 32032fc:	d8800015 	stw	r2,0(sp)
 3203300:	d8c00115 	stw	r3,4(sp)
 3203304:	320406c0 	call	320406c <set_search_window_of_tracker>
 3203308:	1007883a 	mov	r3,r2
 320330c:	e0bdf117 	ldw	r2,-2108(fp)
 3203310:	10c5883a 	add	r2,r2,r3
 3203314:	e0bdf115 	stw	r2,-2108(fp)
			/* Frees a tracker device. */
			else if (reg[0] == 'f' && reg[1] == 't') {
				tx_wr_pos += free_tracker(data0, tx_wr_pos);
			}
			/* Sets a search window for the assigned tracker device (x, y, width, height) */
			else if (reg[0] == 's' && reg[1] == 'w') {
 3203318:	00000a06 	br	3203344 <sss_exec_command+0xc84>
				tx_wr_pos += set_search_window_of_tracker(data0, tx_wr_pos, data1, data2, data3, data4);
			}
			else {
				tx_wr_pos += sprintf(tx_wr_pos, "Wrong command!");
 320331c:	e0bdf117 	ldw	r2,-2108(fp)
 3203320:	00c0c974 	movhi	r3,805
 3203324:	18f55304 	addi	r3,r3,-10932
 3203328:	1009883a 	mov	r4,r2
 320332c:	180b883a 	mov	r5,r3
 3203330:	018003c4 	movi	r6,15
 3203334:	3206ad00 	call	3206ad0 <memcpy>
 3203338:	e0bdf117 	ldw	r2,-2108(fp)
 320333c:	10800384 	addi	r2,r2,14
 3203340:	e0bdf115 	stw	r2,-2108(fp)
			}
			tx_wr_pos += sprintf(tx_wr_pos, "\n");
 3203344:	e0fdf117 	ldw	r3,-2108(fp)
 3203348:	00800284 	movi	r2,10
 320334c:	18800005 	stb	r2,0(r3)
 3203350:	18000045 	stb	zero,1(r3)
 3203354:	e0bdf117 	ldw	r2,-2108(fp)
 3203358:	10800044 	addi	r2,r2,1
 320335c:	e0bdf115 	stw	r2,-2108(fp)
			break;
 3203360:	00006e06 	br	320351c <sss_exec_command+0xe5c>
		case CMD_CONFIGURE: // Reconfigures the camera sensor
			tx_wr_pos += camera_configure(&camera, tx_wr_pos);
 3203364:	e17df117 	ldw	r5,-2108(fp)
 3203368:	0100c974 	movhi	r4,805
 320336c:	21027504 	addi	r4,r4,2516
 3203370:	32013880 	call	3201388 <camera_configure>
 3203374:	1007883a 	mov	r3,r2
 3203378:	e0bdf117 	ldw	r2,-2108(fp)
 320337c:	10c5883a 	add	r2,r2,r3
 3203380:	e0bdf115 	stw	r2,-2108(fp)
			tx_wr_pos += sprintf(tx_wr_pos, "\n");
 3203384:	e0fdf117 	ldw	r3,-2108(fp)
 3203388:	00800284 	movi	r2,10
 320338c:	18800005 	stb	r2,0(r3)
 3203390:	18000045 	stb	zero,1(r3)
 3203394:	e0bdf117 	ldw	r2,-2108(fp)
 3203398:	10800044 	addi	r2,r2,1
 320339c:	e0bdf115 	stw	r2,-2108(fp)
			break;
 32033a0:	00005e06 	br	320351c <sss_exec_command+0xe5c>
		case CMD_CAPTURE: // Captures the image data (Start/Stop)
			printf("Capturing image...\n");
 32033a4:	0100c974 	movhi	r4,805
 32033a8:	21355704 	addi	r4,r4,-10916
 32033ac:	32071080 	call	3207108 <puts>
			IOWR_CAMERA_CAPTURE_START(CAMERA_BASE);
 32033b0:	00c0d034 	movhi	r3,832
 32033b4:	18c90004 	addi	r3,r3,9216
 32033b8:	00800044 	movi	r2,1
 32033bc:	18800035 	stwio	r2,0(r3)
			IOWR_CAMERA_CAPTURE_STOP(CAMERA_BASE);
 32033c0:	0080d034 	movhi	r2,832
 32033c4:	10890004 	addi	r2,r2,9216
 32033c8:	10000035 	stwio	zero,0(r2)
			//OSTimeDly(1);
			printf("Image captured\n");
 32033cc:	0100c974 	movhi	r4,805
 32033d0:	21355c04 	addi	r4,r4,-10896
 32033d4:	32071080 	call	3207108 <puts>
			tx_wr_pos += sprintf(tx_wr_pos, "Image captured.\n");
 32033d8:	e0bdf117 	ldw	r2,-2108(fp)
 32033dc:	00c0c974 	movhi	r3,805
 32033e0:	18f56004 	addi	r3,r3,-10880
 32033e4:	1009883a 	mov	r4,r2
 32033e8:	180b883a 	mov	r5,r3
 32033ec:	01800444 	movi	r6,17
 32033f0:	3206ad00 	call	3206ad0 <memcpy>
 32033f4:	e0bdf117 	ldw	r2,-2108(fp)
 32033f8:	10800404 	addi	r2,r2,16
 32033fc:	e0bdf115 	stw	r2,-2108(fp)
			break;
 3203400:	00004606 	br	320351c <sss_exec_command+0xe5c>
		case CMD_DATA:
			// Send image data
			send_data = 1;
 3203404:	00800044 	movi	r2,1
 3203408:	e0bdf005 	stb	r2,-2112(fp)
			printf("RGB image data sending...\n");
 320340c:	0100c974 	movhi	r4,805
 3203410:	21356504 	addi	r4,r4,-10860
 3203414:	32071080 	call	3207108 <puts>
			tx_wr_pos = tx_buf;
 3203418:	e0bdf304 	addi	r2,fp,-2100
 320341c:	e0bdf115 	stw	r2,-2108(fp)
			break;
 3203420:	00003e06 	br	320351c <sss_exec_command+0xe5c>
		case CMD_GRAY:
			// Send gray image data
			send_data = 2;
 3203424:	00800084 	movi	r2,2
 3203428:	e0bdf005 	stb	r2,-2112(fp)
			printf("Gray image data sending...\n");
 320342c:	0100c974 	movhi	r4,805
 3203430:	21356c04 	addi	r4,r4,-10832
 3203434:	32071080 	call	3207108 <puts>
			tx_wr_pos = tx_buf;
 3203438:	e0bdf304 	addi	r2,fp,-2100
 320343c:	e0bdf115 	stw	r2,-2108(fp)
			break;
 3203440:	00003606 	br	320351c <sss_exec_command+0xe5c>
		case CMD_VGA: // Selects the VGA output
			tx_wr_pos += select_vga_output(&camera, tx_wr_pos);
 3203444:	e17df117 	ldw	r5,-2108(fp)
 3203448:	0100c974 	movhi	r4,805
 320344c:	21027504 	addi	r4,r4,2516
 3203450:	32014e80 	call	32014e8 <select_vga_output>
 3203454:	1007883a 	mov	r3,r2
 3203458:	e0bdf117 	ldw	r2,-2108(fp)
 320345c:	10c5883a 	add	r2,r2,r3
 3203460:	e0bdf115 	stw	r2,-2108(fp)
			tx_wr_pos += sprintf(tx_wr_pos, "\n");
 3203464:	e0fdf117 	ldw	r3,-2108(fp)
 3203468:	00800284 	movi	r2,10
 320346c:	18800005 	stb	r2,0(r3)
 3203470:	18000045 	stb	zero,1(r3)
 3203474:	e0bdf117 	ldw	r2,-2108(fp)
 3203478:	10800044 	addi	r2,r2,1
 320347c:	e0bdf115 	stw	r2,-2108(fp)
			break;
 3203480:	00002606 	br	320351c <sss_exec_command+0xe5c>
		default:
			if(SSSCommand >= ' ' && SSSCommand <= '~') {
 3203484:	d0a89517 	ldw	r2,-23980(gp)
 3203488:	10800830 	cmpltui	r2,r2,32
 320348c:	10000f1e 	bne	r2,zero,32034cc <sss_exec_command+0xe0c>
 3203490:	d0a89517 	ldw	r2,-23980(gp)
 3203494:	10801fe8 	cmpgeui	r2,r2,127
 3203498:	10000c1e 	bne	r2,zero,32034cc <sss_exec_command+0xe0c>
					tx_wr_pos += sprintf(tx_wr_pos,
 320349c:	e13df117 	ldw	r4,-2108(fp)
 32034a0:	d0a89517 	ldw	r2,-23980(gp)
 32034a4:	11803fcc 	andi	r6,r2,255
 32034a8:	3180201c 	xori	r6,r6,128
 32034ac:	31bfe004 	addi	r6,r6,-128
 32034b0:	0140c974 	movhi	r5,805
 32034b4:	29757304 	addi	r5,r5,-10804
 32034b8:	32079c00 	call	32079c0 <sprintf>
 32034bc:	1007883a 	mov	r3,r2
 32034c0:	e0bdf117 	ldw	r2,-2108(fp)
 32034c4:	10c5883a 	add	r2,r2,r3
 32034c8:	e0bdf115 	stw	r2,-2108(fp)
							"--> Simple Socket Server Command %c.\n",
							(char)SSSCommand);
			}
			if (SSSCommand == CMD_QUIT) {
 32034cc:	d0a89517 	ldw	r2,-23980(gp)
 32034d0:	10801458 	cmpnei	r2,r2,81
 32034d4:	10000e1e 	bne	r2,zero,3203510 <sss_exec_command+0xe50>
					tx_wr_pos += sprintf(tx_wr_pos, "Terminating connection.\n\n\r");
 32034d8:	e0bdf117 	ldw	r2,-2108(fp)
 32034dc:	00c0c974 	movhi	r3,805
 32034e0:	18f57d04 	addi	r3,r3,-10764
 32034e4:	1009883a 	mov	r4,r2
 32034e8:	180b883a 	mov	r5,r3
 32034ec:	018006c4 	movi	r6,27
 32034f0:	3206ad00 	call	3206ad0 <memcpy>
 32034f4:	e0bdf117 	ldw	r2,-2108(fp)
 32034f8:	10800684 	addi	r2,r2,26
 32034fc:	e0bdf115 	stw	r2,-2108(fp)
					conn->close = 1;
 3203500:	e0fff917 	ldw	r3,-28(fp)
 3203504:	00800044 	movi	r2,1
 3203508:	18800215 	stw	r2,8(r3)
 320350c:	00000306 	br	320351c <sss_exec_command+0xe5c>
			}
			else {
					alt_SSSErrorHandler(error_code, 0);
 3203510:	e13df043 	ldbu	r4,-2111(fp)
 3203514:	000b883a 	mov	r5,zero
 3203518:	3200ac80 	call	3200ac8 <alt_SSSErrorHandler>
			}
			break;
    }

	// Send image data
    if (send_data) {
 320351c:	e0bdf003 	ldbu	r2,-2112(fp)
 3203520:	1005003a 	cmpeq	r2,r2,zero
 3203524:	1000921e 	bne	r2,zero,3203770 <sss_exec_command+0x10b0>
    	// Waits to end of capture
		while (!IORD_CAMERA_CAPTURE_DONE(CAMERA_BASE)) OSTimeDly(1);
 3203528:	00000206 	br	3203534 <sss_exec_command+0xe74>
 320352c:	01000044 	movi	r4,1
 3203530:	321d27c0 	call	321d27c <OSTimeDly>
 3203534:	0080d034 	movhi	r2,832
 3203538:	10890004 	addi	r2,r2,9216
 320353c:	10800037 	ldwio	r2,0(r2)
 3203540:	1005003a 	cmpeq	r2,r2,zero
 3203544:	103ff91e 	bne	r2,zero,320352c <sss_exec_command+0xe6c>

    	alt_u32 data;
		alt_u8  r, g, b;

		int WIDTH = IORD_CAMERA_WIDTH(CAMERA_BASE);
 3203548:	0080d034 	movhi	r2,832
 320354c:	10890804 	addi	r2,r2,9248
 3203550:	10800037 	ldwio	r2,0(r2)
 3203554:	e0bdea15 	stw	r2,-2136(fp)
		int HEIGHT = IORD_CAMERA_HEIGHT(CAMERA_BASE);
 3203558:	0080d034 	movhi	r2,832
 320355c:	10890a04 	addi	r2,r2,9256
 3203560:	10800037 	ldwio	r2,0(r2)
 3203564:	e0bde915 	stw	r2,-2140(fp)
		//	alt_u8 g;
		//	alt_u8 r;
		//} volatile color;

		//color *col = (color *)(&data);
		if (send_data == 1) {
 3203568:	e0bdf003 	ldbu	r2,-2112(fp)
 320356c:	10800058 	cmpnei	r2,r2,1
 3203570:	10004b1e 	bne	r2,zero,32036a0 <sss_exec_command+0xfe0>
			// Send RGB image

			int S = (WIDTH / 600) + 1;
 3203574:	e13dea17 	ldw	r4,-2136(fp)
 3203578:	01409604 	movi	r5,600
 320357c:	32047000 	call	3204700 <__divsi3>
 3203580:	10800044 	addi	r2,r2,1
 3203584:	e0bde815 	stw	r2,-2144(fp)
			int Y = HEIGHT * S;
 3203588:	e0fde917 	ldw	r3,-2140(fp)
 320358c:	e0bde817 	ldw	r2,-2144(fp)
 3203590:	1885383a 	mul	r2,r3,r2
 3203594:	e0bde715 	stw	r2,-2148(fp)
			int X = WIDTH / S;
 3203598:	e13dea17 	ldw	r4,-2136(fp)
 320359c:	e17de817 	ldw	r5,-2144(fp)
 32035a0:	32047000 	call	3204700 <__divsi3>
 32035a4:	e0bde615 	stw	r2,-2152(fp)

			register int i;
			register int j;
			for(j = 0; j < Y; j++) {
 32035a8:	e03ffc15 	stw	zero,-16(fp)
 32035ac:	00003806 	br	3203690 <sss_exec_command+0xfd0>
				for(i = 0; i < X; i++) {
 32035b0:	e03ffd15 	stw	zero,-12(fp)
 32035b4:	00002406 	br	3203648 <sss_exec_command+0xf88>
					data = IORD_CAMERA_READ_DATA(CAMERA_BASE);
 32035b8:	0080d034 	movhi	r2,832
 32035bc:	10890404 	addi	r2,r2,9232
 32035c0:	10800037 	ldwio	r2,0(r2)
 32035c4:	e0bdec15 	stw	r2,-2128(fp)
					r = data >> 16;
 32035c8:	e0bdec17 	ldw	r2,-2128(fp)
 32035cc:	1004d43a 	srli	r2,r2,16
 32035d0:	e0bdeb85 	stb	r2,-2130(fp)
					g = data >> 8;
 32035d4:	e0bdec17 	ldw	r2,-2128(fp)
 32035d8:	1004d23a 	srli	r2,r2,8
 32035dc:	e0bdeb45 	stb	r2,-2131(fp)
					b = data;
 32035e0:	e0bdec17 	ldw	r2,-2128(fp)
 32035e4:	e0bdeb05 	stb	r2,-2132(fp)
					//tx_wr_pos += sprintf(tx_wr_pos, "%c%c%c", col->r, col->g, col->b);
					tx_wr_pos += sprintf(tx_wr_pos, "%c%c%c", (char) r, (char) g, (char) b);
 32035e8:	e13df117 	ldw	r4,-2108(fp)
 32035ec:	e0bdeb83 	ldbu	r2,-2130(fp)
 32035f0:	11803fcc 	andi	r6,r2,255
 32035f4:	3180201c 	xori	r6,r6,128
 32035f8:	31bfe004 	addi	r6,r6,-128
 32035fc:	e0bdeb43 	ldbu	r2,-2131(fp)
 3203600:	11c03fcc 	andi	r7,r2,255
 3203604:	39c0201c 	xori	r7,r7,128
 3203608:	39ffe004 	addi	r7,r7,-128
 320360c:	e0bdeb03 	ldbu	r2,-2132(fp)
 3203610:	10803fcc 	andi	r2,r2,255
 3203614:	1080201c 	xori	r2,r2,128
 3203618:	10bfe004 	addi	r2,r2,-128
 320361c:	d8800015 	stw	r2,0(sp)
 3203620:	0140c974 	movhi	r5,805
 3203624:	29758404 	addi	r5,r5,-10736
 3203628:	32079c00 	call	32079c0 <sprintf>
 320362c:	1007883a 	mov	r3,r2
 3203630:	e0bdf117 	ldw	r2,-2108(fp)
 3203634:	10c5883a 	add	r2,r2,r3
 3203638:	e0bdf115 	stw	r2,-2108(fp)
			int X = WIDTH / S;

			register int i;
			register int j;
			for(j = 0; j < Y; j++) {
				for(i = 0; i < X; i++) {
 320363c:	e0bffd17 	ldw	r2,-12(fp)
 3203640:	10800044 	addi	r2,r2,1
 3203644:	e0bffd15 	stw	r2,-12(fp)
 3203648:	e0bde617 	ldw	r2,-2152(fp)
 320364c:	e0fffd17 	ldw	r3,-12(fp)
 3203650:	18bfd916 	blt	r3,r2,32035b8 <sss_exec_command+0xef8>
					g = data >> 8;
					b = data;
					//tx_wr_pos += sprintf(tx_wr_pos, "%c%c%c", col->r, col->g, col->b);
					tx_wr_pos += sprintf(tx_wr_pos, "%c%c%c", (char) r, (char) g, (char) b);
				}
				send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
 3203654:	e0bff917 	ldw	r2,-28(fp)
 3203658:	11000117 	ldw	r4,4(r2)
 320365c:	e17df304 	addi	r5,fp,-2100
 3203660:	e0fdf117 	ldw	r3,-2108(fp)
 3203664:	e0bdf304 	addi	r2,fp,-2100
 3203668:	188dc83a 	sub	r6,r3,r2
 320366c:	000f883a 	mov	r7,zero
 3203670:	322f2140 	call	322f214 <t_send>
				tx_wr_pos = tx_buf;
 3203674:	e0bdf304 	addi	r2,fp,-2100
 3203678:	e0bdf115 	stw	r2,-2108(fp)
				OSTimeDly(1);
 320367c:	01000044 	movi	r4,1
 3203680:	321d27c0 	call	321d27c <OSTimeDly>
			int Y = HEIGHT * S;
			int X = WIDTH / S;

			register int i;
			register int j;
			for(j = 0; j < Y; j++) {
 3203684:	e13ffc17 	ldw	r4,-16(fp)
 3203688:	21000044 	addi	r4,r4,1
 320368c:	e13ffc15 	stw	r4,-16(fp)
 3203690:	e0bde717 	ldw	r2,-2148(fp)
 3203694:	e0fffc17 	ldw	r3,-16(fp)
 3203698:	18bfc516 	blt	r3,r2,32035b0 <sss_exec_command+0xef0>
 320369c:	00003206 	br	3203768 <sss_exec_command+0x10a8>
				send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
				tx_wr_pos = tx_buf;
				OSTimeDly(1);
			}
		}
		else if (send_data == 2) {
 32036a0:	e0bdf003 	ldbu	r2,-2112(fp)
 32036a4:	10800098 	cmpnei	r2,r2,2
 32036a8:	10002f1e 	bne	r2,zero,3203768 <sss_exec_command+0x10a8>
			// Send gray image
			register int i;
			register int j;
			for(j = 0; j < HEIGHT; j++) {
 32036ac:	e03ffa15 	stw	zero,-24(fp)
 32036b0:	00002a06 	br	320375c <sss_exec_command+0x109c>
				for(i = 0; i < WIDTH; i++) {
 32036b4:	e03ffb15 	stw	zero,-20(fp)
 32036b8:	00001606 	br	3203714 <sss_exec_command+0x1054>
					data = IORD_CAMERA_READ_DATA(CAMERA_BASE);
 32036bc:	0080d034 	movhi	r2,832
 32036c0:	10890404 	addi	r2,r2,9232
 32036c4:	10800037 	ldwio	r2,0(r2)
 32036c8:	e0bdec15 	stw	r2,-2128(fp)
					g = data >> 24;
 32036cc:	e0bdec17 	ldw	r2,-2128(fp)
 32036d0:	1004d63a 	srli	r2,r2,24
 32036d4:	e0bdeb45 	stb	r2,-2131(fp)
					tx_wr_pos += sprintf(tx_wr_pos, "%c", (char) g);
 32036d8:	e13df117 	ldw	r4,-2108(fp)
 32036dc:	e0bdeb43 	ldbu	r2,-2131(fp)
 32036e0:	11803fcc 	andi	r6,r2,255
 32036e4:	3180201c 	xori	r6,r6,128
 32036e8:	31bfe004 	addi	r6,r6,-128
 32036ec:	0140c974 	movhi	r5,805
 32036f0:	29758604 	addi	r5,r5,-10728
 32036f4:	32079c00 	call	32079c0 <sprintf>
 32036f8:	1007883a 	mov	r3,r2
 32036fc:	e0bdf117 	ldw	r2,-2108(fp)
 3203700:	10c5883a 	add	r2,r2,r3
 3203704:	e0bdf115 	stw	r2,-2108(fp)
		else if (send_data == 2) {
			// Send gray image
			register int i;
			register int j;
			for(j = 0; j < HEIGHT; j++) {
				for(i = 0; i < WIDTH; i++) {
 3203708:	e13ffb17 	ldw	r4,-20(fp)
 320370c:	21000044 	addi	r4,r4,1
 3203710:	e13ffb15 	stw	r4,-20(fp)
 3203714:	e0bdea17 	ldw	r2,-2136(fp)
 3203718:	e0fffb17 	ldw	r3,-20(fp)
 320371c:	18bfe716 	blt	r3,r2,32036bc <sss_exec_command+0xffc>
					data = IORD_CAMERA_READ_DATA(CAMERA_BASE);
					g = data >> 24;
					tx_wr_pos += sprintf(tx_wr_pos, "%c", (char) g);
				}
				send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
 3203720:	e0bff917 	ldw	r2,-28(fp)
 3203724:	11000117 	ldw	r4,4(r2)
 3203728:	e17df304 	addi	r5,fp,-2100
 320372c:	e0fdf117 	ldw	r3,-2108(fp)
 3203730:	e0bdf304 	addi	r2,fp,-2100
 3203734:	188dc83a 	sub	r6,r3,r2
 3203738:	000f883a 	mov	r7,zero
 320373c:	322f2140 	call	322f214 <t_send>
				tx_wr_pos = tx_buf;
 3203740:	e0bdf304 	addi	r2,fp,-2100
 3203744:	e0bdf115 	stw	r2,-2108(fp)
				OSTimeDly(1);
 3203748:	01000044 	movi	r4,1
 320374c:	321d27c0 	call	321d27c <OSTimeDly>
		}
		else if (send_data == 2) {
			// Send gray image
			register int i;
			register int j;
			for(j = 0; j < HEIGHT; j++) {
 3203750:	e13ffa17 	ldw	r4,-24(fp)
 3203754:	21000044 	addi	r4,r4,1
 3203758:	e13ffa15 	stw	r4,-24(fp)
 320375c:	e0bde917 	ldw	r2,-2140(fp)
 3203760:	e0fffa17 	ldw	r3,-24(fp)
 3203764:	18bfd316 	blt	r3,r2,32036b4 <sss_exec_command+0xff4>
				send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
				tx_wr_pos = tx_buf;
				OSTimeDly(1);
			}
		}
		send_data = 0;
 3203768:	e03df005 	stb	zero,-2112(fp)
 320376c:	00000a06 	br	3203798 <sss_exec_command+0x10d8>
    }
    else {
        // Send buffer
        send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
 3203770:	e0bff917 	ldw	r2,-28(fp)
 3203774:	11000117 	ldw	r4,4(r2)
 3203778:	e17df304 	addi	r5,fp,-2100
 320377c:	e0fdf117 	ldw	r3,-2108(fp)
 3203780:	e0bdf304 	addi	r2,fp,-2100
 3203784:	188dc83a 	sub	r6,r3,r2
 3203788:	000f883a 	mov	r7,zero
 320378c:	322f2140 	call	322f214 <t_send>
        tx_wr_pos = tx_buf;
 3203790:	e0bdf304 	addi	r2,fp,-2100
 3203794:	e0bdf115 	stw	r2,-2108(fp)
    }
}
 3203798:	e037883a 	mov	sp,fp
 320379c:	dfc00217 	ldw	ra,8(sp)
 32037a0:	df000117 	ldw	fp,4(sp)
 32037a4:	dc000017 	ldw	r16,0(sp)
 32037a8:	dec00304 	addi	sp,sp,12
 32037ac:	f800283a 	ret

032037b0 <sss_handle_accept>:
 * connection request and call the telent_send_menu() routine to transmit
 * instructions to the user, and print out the client's IP address. Otherwise,
 * the connection is already in use, reject the incoming request by
 * immediately closing the new socket.
 */
void sss_handle_accept(int listen_socket, SSSConn* conn) {
 32037b0:	defff604 	addi	sp,sp,-40
 32037b4:	dfc00915 	stw	ra,36(sp)
 32037b8:	df000815 	stw	fp,32(sp)
 32037bc:	df000804 	addi	fp,sp,32
 32037c0:	e13ffe15 	stw	r4,-8(fp)
 32037c4:	e17fff15 	stw	r5,-4(fp)
	int	socket, len;
	struct sockaddr_in  incoming_addr;

	len = sizeof(incoming_addr);
 32037c8:	00800404 	movi	r2,16
 32037cc:	e0bff915 	stw	r2,-28(fp)

	if ((conn)->fd == -1) {
 32037d0:	e0bfff17 	ldw	r2,-4(fp)
 32037d4:	10800117 	ldw	r2,4(r2)
 32037d8:	10bfffd8 	cmpnei	r2,r2,-1
 32037dc:	1000191e 	bne	r2,zero,3203844 <sss_handle_accept+0x94>
		if((socket=accept(listen_socket, (struct sockaddr*) &incoming_addr, &len)) <0) {
 32037e0:	e17ffa04 	addi	r5,fp,-24
 32037e4:	e1bff904 	addi	r6,fp,-28
 32037e8:	e13ffe17 	ldw	r4,-8(fp)
 32037ec:	322515c0 	call	322515c <bsd_accept>
 32037f0:	e0bff815 	stw	r2,-32(fp)
 32037f4:	e0bff817 	ldw	r2,-32(fp)
 32037f8:	1004403a 	cmpge	r2,r2,zero
 32037fc:	1000051e 	bne	r2,zero,3203814 <sss_handle_accept+0x64>
			alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,
 3203800:	01003fc4 	movi	r4,255
 3203804:	0140c974 	movhi	r5,805
 3203808:	29758704 	addi	r5,r5,-10724
 320380c:	32008300 	call	3200830 <alt_NetworkErrorHandler>
 3203810:	00001206 	br	320385c <sss_handle_accept+0xac>
					"[sss_handle_accept] accept failed");
		}
		else {
			(conn)->fd = socket;
 3203814:	e0bfff17 	ldw	r2,-4(fp)
 3203818:	e0fff817 	ldw	r3,-32(fp)
 320381c:	10c00115 	stw	r3,4(r2)
			sss_send_menu(conn);
 3203820:	e13fff17 	ldw	r4,-4(fp)
 3203824:	32023f00 	call	32023f0 <sss_send_menu>
			printf("[sss_handle_accept] accepted connection request from %s\n",
 3203828:	e13ffb17 	ldw	r4,-20(fp)
 320382c:	32258c80 	call	32258c8 <bsd_inet_ntoa>
 3203830:	100b883a 	mov	r5,r2
 3203834:	0100c974 	movhi	r4,805
 3203838:	21359004 	addi	r4,r4,-10688
 320383c:	3206de00 	call	3206de0 <printf>
 3203840:	00000606 	br	320385c <sss_handle_accept+0xac>
					inet_ntoa(incoming_addr.sin_addr));
		}
	}
	else {
		printf("[sss_handle_accept] rejected connection request from %s\n",
 3203844:	e13ffb17 	ldw	r4,-20(fp)
 3203848:	32258c80 	call	32258c8 <bsd_inet_ntoa>
 320384c:	100b883a 	mov	r5,r2
 3203850:	0100c974 	movhi	r4,805
 3203854:	21359f04 	addi	r4,r4,-10628
 3203858:	3206de00 	call	3206de0 <printf>
				inet_ntoa(incoming_addr.sin_addr));
	}
}
 320385c:	e037883a 	mov	sp,fp
 3203860:	dfc00117 	ldw	ra,4(sp)
 3203864:	df000017 	ldw	fp,0(sp)
 3203868:	dec00204 	addi	sp,sp,8
 320386c:	f800283a 	ret

03203870 <sss_handle_receive>:
 * and popped off from the beginning of the buffer with the 
 * sss_exec_command() routine. Aside from these, we must move incoming
 * (un-processed) data to buffer start as appropriate and keep track of 
 * associated pointers.
 */
void sss_handle_receive(SSSConn* conn) {
 3203870:	defff904 	addi	sp,sp,-28
 3203874:	dfc00615 	stw	ra,24(sp)
 3203878:	df000515 	stw	fp,20(sp)
 320387c:	df000504 	addi	fp,sp,20
 3203880:	e13ffe15 	stw	r4,-8(fp)
	int data_used = 0, rx_code = 0;
 3203884:	e03ffd15 	stw	zero,-12(fp)
 3203888:	e03ffc15 	stw	zero,-16(fp)
	INT8U *lf_addr;

	conn->rx_rd_pos = conn->rx_buffer;
 320388c:	e0bffe17 	ldw	r2,-8(fp)
 3203890:	10c00304 	addi	r3,r2,12
 3203894:	e0bffe17 	ldw	r2,-8(fp)
 3203898:	10c20315 	stw	r3,2060(r2)
	conn->rx_wr_pos = conn->rx_buffer;
 320389c:	e0bffe17 	ldw	r2,-8(fp)
 32038a0:	10c00304 	addi	r3,r2,12
 32038a4:	e0bffe17 	ldw	r2,-8(fp)
 32038a8:	10c20415 	stw	r3,2064(r2)

	printf("[sss_handle_receive] processing RX data\n");
 32038ac:	0100c974 	movhi	r4,805
 32038b0:	2135ae04 	addi	r4,r4,-10568
 32038b4:	32071080 	call	3207108 <puts>

	while(conn->state != CLOSE) {
 32038b8:	00005706 	br	3203a18 <sss_handle_receive+0x1a8>
		/* Find the Carriage return which marks the end of the header
		 * and go do whatever the user wanted us to do.
		 * Or, if no newline received, then ask the socket for data.
		 */
		lf_addr = strchr(conn->rx_buffer, '\n');
 32038bc:	e0bffe17 	ldw	r2,-8(fp)
 32038c0:	10800304 	addi	r2,r2,12
 32038c4:	1009883a 	mov	r4,r2
 32038c8:	01400284 	movi	r5,10
 32038cc:	3207cf40 	call	3207cf4 <strchr>
 32038d0:	e0bffb15 	stw	r2,-20(fp)

		if(lf_addr) {
 32038d4:	e0bffb17 	ldw	r2,-20(fp)
 32038d8:	1005003a 	cmpeq	r2,r2,zero
 32038dc:	1000031e 	bne	r2,zero,32038ec <sss_handle_receive+0x7c>
			sss_exec_command(conn);
 32038e0:	e13ffe17 	ldw	r4,-8(fp)
 32038e4:	32026c00 	call	32026c0 <sss_exec_command>
 32038e8:	00001c06 	br	320395c <sss_handle_receive+0xec>
		}
		else {
			rx_code = recv(conn->fd, conn->rx_wr_pos,
 32038ec:	e0bffe17 	ldw	r2,-8(fp)
 32038f0:	11000117 	ldw	r4,4(r2)
 32038f4:	e0bffe17 	ldw	r2,-8(fp)
 32038f8:	10820417 	ldw	r2,2064(r2)
 32038fc:	100b883a 	mov	r5,r2
 3203900:	e0bffe17 	ldw	r2,-8(fp)
 3203904:	10800304 	addi	r2,r2,12
 3203908:	1007883a 	mov	r3,r2
 320390c:	e0bffe17 	ldw	r2,-8(fp)
 3203910:	10820417 	ldw	r2,2064(r2)
 3203914:	1885c83a 	sub	r2,r3,r2
 3203918:	1181ffc4 	addi	r6,r2,2047
 320391c:	000f883a 	mov	r7,zero
 3203920:	322eda80 	call	322eda8 <t_recv>
 3203924:	e0bffc15 	stw	r2,-16(fp)
					SSS_RX_BUF_SIZE - (conn->rx_wr_pos - conn->rx_buffer) - 1, 0);

			if(rx_code > 0) {
 3203928:	e0bffc17 	ldw	r2,-16(fp)
 320392c:	10800050 	cmplti	r2,r2,1
 3203930:	10000a1e 	bne	r2,zero,320395c <sss_handle_receive+0xec>
				conn->rx_wr_pos += rx_code;
 3203934:	e0bffe17 	ldw	r2,-8(fp)
 3203938:	10c20417 	ldw	r3,2064(r2)
 320393c:	e0bffc17 	ldw	r2,-16(fp)
 3203940:	1887883a 	add	r3,r3,r2
 3203944:	e0bffe17 	ldw	r2,-8(fp)
 3203948:	10c20415 	stw	r3,2064(r2)

				/* Zero terminate so we can use string functions */
				*(conn->rx_wr_pos + 1) = 0;
 320394c:	e0bffe17 	ldw	r2,-8(fp)
 3203950:	10820417 	ldw	r2,2064(r2)
 3203954:	10800044 	addi	r2,r2,1
 3203958:	10000005 	stb	zero,0(r2)

		/*
		 * When the quit command is received, update our connection state so that
		 * we can exit the while() loop and close the connection
		 */
		conn->state = conn->close ? CLOSE : READY;
 320395c:	e0bffe17 	ldw	r2,-8(fp)
 3203960:	10800217 	ldw	r2,8(r2)
 3203964:	1005003a 	cmpeq	r2,r2,zero
 3203968:	1000031e 	bne	r2,zero,3203978 <sss_handle_receive+0x108>
 320396c:	00800084 	movi	r2,2
 3203970:	e0bfff15 	stw	r2,-4(fp)
 3203974:	00000106 	br	320397c <sss_handle_receive+0x10c>
 3203978:	e03fff15 	stw	zero,-4(fp)
 320397c:	e0bffe17 	ldw	r2,-8(fp)
 3203980:	e0ffff17 	ldw	r3,-4(fp)
 3203984:	10c00015 	stw	r3,0(r2)

		/* Manage buffer */
		data_used = conn->rx_rd_pos - conn->rx_buffer;
 3203988:	e0bffe17 	ldw	r2,-8(fp)
 320398c:	10820317 	ldw	r2,2060(r2)
 3203990:	1007883a 	mov	r3,r2
 3203994:	e0bffe17 	ldw	r2,-8(fp)
 3203998:	10800304 	addi	r2,r2,12
 320399c:	1885c83a 	sub	r2,r3,r2
 32039a0:	e0bffd15 	stw	r2,-12(fp)
		memmove(conn->rx_buffer, conn->rx_rd_pos,
 32039a4:	e0bffe17 	ldw	r2,-8(fp)
 32039a8:	11000304 	addi	r4,r2,12
 32039ac:	e0bffe17 	ldw	r2,-8(fp)
 32039b0:	11420317 	ldw	r5,2060(r2)
 32039b4:	e0bffe17 	ldw	r2,-8(fp)
 32039b8:	10820417 	ldw	r2,2064(r2)
 32039bc:	1007883a 	mov	r3,r2
 32039c0:	e0bffe17 	ldw	r2,-8(fp)
 32039c4:	10820317 	ldw	r2,2060(r2)
 32039c8:	1885c83a 	sub	r2,r3,r2
 32039cc:	100d883a 	mov	r6,r2
 32039d0:	3206b700 	call	3206b70 <memmove>
				conn->rx_wr_pos - conn->rx_rd_pos);
		conn->rx_rd_pos = conn->rx_buffer;
 32039d4:	e0bffe17 	ldw	r2,-8(fp)
 32039d8:	10c00304 	addi	r3,r2,12
 32039dc:	e0bffe17 	ldw	r2,-8(fp)
 32039e0:	10c20315 	stw	r3,2060(r2)
		conn->rx_wr_pos -= data_used;
 32039e4:	e0bffe17 	ldw	r2,-8(fp)
 32039e8:	10c20417 	ldw	r3,2064(r2)
 32039ec:	e0bffd17 	ldw	r2,-12(fp)
 32039f0:	1887c83a 	sub	r3,r3,r2
 32039f4:	e0bffe17 	ldw	r2,-8(fp)
 32039f8:	10c20415 	stw	r3,2064(r2)
		memset(conn->rx_wr_pos, 0, data_used);
 32039fc:	e0bffe17 	ldw	r2,-8(fp)
 3203a00:	10820417 	ldw	r2,2064(r2)
 3203a04:	e0fffd17 	ldw	r3,-12(fp)
 3203a08:	1009883a 	mov	r4,r2
 3203a0c:	180d883a 	mov	r6,r3
 3203a10:	000b883a 	mov	r5,zero
 3203a14:	3206c500 	call	3206c50 <memset>
	conn->rx_rd_pos = conn->rx_buffer;
	conn->rx_wr_pos = conn->rx_buffer;

	printf("[sss_handle_receive] processing RX data\n");

	while(conn->state != CLOSE) {
 3203a18:	e0bffe17 	ldw	r2,-8(fp)
 3203a1c:	10800017 	ldw	r2,0(r2)
 3203a20:	10800098 	cmpnei	r2,r2,2
 3203a24:	103fa51e 	bne	r2,zero,32038bc <sss_handle_receive+0x4c>
		conn->rx_rd_pos = conn->rx_buffer;
		conn->rx_wr_pos -= data_used;
		memset(conn->rx_wr_pos, 0, data_used);
	}

	printf("[sss_handle_receive] closing connection\n");
 3203a28:	0100c974 	movhi	r4,805
 3203a2c:	2135b804 	addi	r4,r4,-10528
 3203a30:	32071080 	call	3207108 <puts>
	close(conn->fd);
 3203a34:	e0bffe17 	ldw	r2,-8(fp)
 3203a38:	11000117 	ldw	r4,4(r2)
 3203a3c:	3222b400 	call	3222b40 <close>
	sss_reset_connection(conn);
 3203a40:	e13ffe17 	ldw	r4,-8(fp)
 3203a44:	32023800 	call	3202380 <sss_reset_connection>
}
 3203a48:	e037883a 	mov	sp,fp
 3203a4c:	dfc00117 	ldw	ra,4(sp)
 3203a50:	df000017 	ldw	fp,0(sp)
 3203a54:	dec00204 	addi	sp,sp,8
 3203a58:	f800283a 	ret

03203a5c <SSSSimpleSocketServerTask>:
 * it perpetually waits for incoming data to either the listening socket, or
 * (if a connection is active), the sss data socket. When data arrives, 
 * the approrpriate routine is called to either accept/reject a connection 
 * request, or process incoming data.
 */
void SSSSimpleSocketServerTask() {
 3203a5c:	deffb604 	addi	sp,sp,-296
 3203a60:	dfc04915 	stw	ra,292(sp)
 3203a64:	df004815 	stw	fp,288(sp)
 3203a68:	df004804 	addi	fp,sp,288
	 *
	 * The listen socket is a socket which is waiting for incoming connections.
	 * This call to listen will block (i.e. not return) until someone tries to
	 * connect to this port.
	 */
	if ((fd_listen = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
 3203a6c:	01000084 	movi	r4,2
 3203a70:	01400044 	movi	r5,1
 3203a74:	000d883a 	mov	r6,zero
 3203a78:	322df740 	call	322df74 <t_socket>
 3203a7c:	e0bfba15 	stw	r2,-280(fp)
 3203a80:	e0bfba17 	ldw	r2,-280(fp)
 3203a84:	1004403a 	cmpge	r2,r2,zero
 3203a88:	1000041e 	bne	r2,zero,3203a9c <SSSSimpleSocketServerTask+0x40>
		alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE, "[sss_task] Socket creation failed");
 3203a8c:	01003fc4 	movi	r4,255
 3203a90:	0140c974 	movhi	r5,805
 3203a94:	2975c204 	addi	r5,r5,-10488
 3203a98:	32008300 	call	3200830 <alt_NetworkErrorHandler>
	}

	addr.sin_family = AF_INET;
 3203a9c:	00800084 	movi	r2,2
 3203aa0:	e0bfbb0d 	sth	r2,-276(fp)
	addr.sin_port = htons(SSS_PORT);
 3203aa4:	00a344c4 	movi	r2,-29421
 3203aa8:	e0bfbb8d 	sth	r2,-274(fp)
	addr.sin_addr.s_addr = INADDR_ANY;
 3203aac:	e03fbc15 	stw	zero,-272(fp)
  
	if ((bind(fd_listen, (struct sockaddr *) & addr, sizeof(addr))) < 0) {
 3203ab0:	e17fbb04 	addi	r5,fp,-276
 3203ab4:	e13fba17 	ldw	r4,-280(fp)
 3203ab8:	01800404 	movi	r6,16
 3203abc:	322e0040 	call	322e004 <t_bind>
 3203ac0:	1004403a 	cmpge	r2,r2,zero
 3203ac4:	1000041e 	bne	r2,zero,3203ad8 <SSSSimpleSocketServerTask+0x7c>
		alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE, "[sss_task] Bind failed");
 3203ac8:	01003fc4 	movi	r4,255
 3203acc:	0140c974 	movhi	r5,805
 3203ad0:	2975cb04 	addi	r5,r5,-10452
 3203ad4:	32008300 	call	3200830 <alt_NetworkErrorHandler>
	}

	if ((listen(fd_listen, 1)) < 0) {
 3203ad8:	e13fba17 	ldw	r4,-280(fp)
 3203adc:	01400044 	movi	r5,1
 3203ae0:	322e1800 	call	322e180 <t_listen>
 3203ae4:	1004403a 	cmpge	r2,r2,zero
 3203ae8:	1000041e 	bne	r2,zero,3203afc <SSSSimpleSocketServerTask+0xa0>
		alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE, "[sss_task] Listen failed");
 3203aec:	01003fc4 	movi	r4,255
 3203af0:	0140c974 	movhi	r5,805
 3203af4:	2975d104 	addi	r5,r5,-10428
 3203af8:	32008300 	call	3200830 <alt_NetworkErrorHandler>
	}

	/* At this point we have successfully created a socket which is listening
	 * on SSS_PORT for connection requests from any remote address.
	 */
	sss_reset_connection(&conn);
 3203afc:	0100c974 	movhi	r4,805
 3203b00:	21137604 	addi	r4,r4,19928
 3203b04:	32023800 	call	3202380 <sss_reset_connection>
	printf("[sss_task] Simple Socket Server listening on port %d\n", SSS_PORT);
 3203b08:	0100c974 	movhi	r4,805
 3203b0c:	2135d804 	addi	r4,r4,-10400
 3203b10:	0144e344 	movi	r5,5005
 3203b14:	3206de00 	call	3206de0 <printf>
 3203b18:	00000006 	br	3203b1c <SSSSimpleSocketServerTask+0xc0>
		 *
		 *   FD_ZERO  - Zero's out the sockets we're interested in
		 *   FD_SET   - Adds a socket to those we're interested in
		 *   FD_ISSET - Tests whether the chosen socket is set
		 */
		FD_ZERO(&readfds);
 3203b1c:	e03fbf15 	stw	zero,-260(fp)
		FD_SET(fd_listen, &readfds);
 3203b20:	e17fbf04 	addi	r5,fp,-260
 3203b24:	e13fba17 	ldw	r4,-280(fp)
 3203b28:	32335600 	call	3233560 <ifd_set>
		max_socket = fd_listen + 1;
 3203b2c:	e0bfba17 	ldw	r2,-280(fp)
 3203b30:	10800044 	addi	r2,r2,1
 3203b34:	e0bfb915 	stw	r2,-284(fp)

		if (conn.fd != -1) {
 3203b38:	0080c974 	movhi	r2,805
 3203b3c:	10937604 	addi	r2,r2,19928
 3203b40:	10800117 	ldw	r2,4(r2)
 3203b44:	10bfffe0 	cmpeqi	r2,r2,-1
 3203b48:	10000f1e 	bne	r2,zero,3203b88 <SSSSimpleSocketServerTask+0x12c>
			FD_SET(conn.fd, &readfds);
 3203b4c:	0080c974 	movhi	r2,805
 3203b50:	10937604 	addi	r2,r2,19928
 3203b54:	11000117 	ldw	r4,4(r2)
 3203b58:	e17fbf04 	addi	r5,fp,-260
 3203b5c:	32335600 	call	3233560 <ifd_set>
			if (max_socket <= conn.fd) {
 3203b60:	0080c974 	movhi	r2,805
 3203b64:	10937604 	addi	r2,r2,19928
 3203b68:	10c00117 	ldw	r3,4(r2)
 3203b6c:	e0bfb917 	ldw	r2,-284(fp)
 3203b70:	18800516 	blt	r3,r2,3203b88 <SSSSimpleSocketServerTask+0x12c>
				max_socket = conn.fd + 1;
 3203b74:	0080c974 	movhi	r2,805
 3203b78:	10937604 	addi	r2,r2,19928
 3203b7c:	10800117 	ldw	r2,4(r2)
 3203b80:	10800044 	addi	r2,r2,1
 3203b84:	e0bfb915 	stw	r2,-284(fp)
			}
		}

		select(max_socket, &readfds, NULL, NULL, NULL);
 3203b88:	e17fbf04 	addi	r5,fp,-260
 3203b8c:	d8000015 	stw	zero,0(sp)
 3203b90:	e13fb917 	ldw	r4,-284(fp)
 3203b94:	000d883a 	mov	r6,zero
 3203b98:	000f883a 	mov	r7,zero
 3203b9c:	3225a580 	call	3225a58 <bsd_select>
		 * independent of the listening socket we created above. This socket's
		 * descriptor is stored in conn.fd. If conn.fs is set in readfs... we have
		 * incoming data for our sss server, and we call our receiver routine
		 * to process it.
		 */
		if (FD_ISSET(fd_listen, &readfds)) {
 3203ba0:	e17fbf04 	addi	r5,fp,-260
 3203ba4:	e13fba17 	ldw	r4,-280(fp)
 3203ba8:	32335d40 	call	32335d4 <ifd_isset>
 3203bac:	1005003a 	cmpeq	r2,r2,zero
 3203bb0:	1000051e 	bne	r2,zero,3203bc8 <SSSSimpleSocketServerTask+0x16c>
			sss_handle_accept(fd_listen, &conn);
 3203bb4:	e13fba17 	ldw	r4,-280(fp)
 3203bb8:	0140c974 	movhi	r5,805
 3203bbc:	29537604 	addi	r5,r5,19928
 3203bc0:	32037b00 	call	32037b0 <sss_handle_accept>
 3203bc4:	003fd506 	br	3203b1c <SSSSimpleSocketServerTask+0xc0>
		}
		else {
			if ((conn.fd != -1) && FD_ISSET(conn.fd, &readfds)) {
 3203bc8:	0080c974 	movhi	r2,805
 3203bcc:	10937604 	addi	r2,r2,19928
 3203bd0:	10800117 	ldw	r2,4(r2)
 3203bd4:	10bfffe0 	cmpeqi	r2,r2,-1
 3203bd8:	103fd01e 	bne	r2,zero,3203b1c <SSSSimpleSocketServerTask+0xc0>
 3203bdc:	0080c974 	movhi	r2,805
 3203be0:	10937604 	addi	r2,r2,19928
 3203be4:	11000117 	ldw	r4,4(r2)
 3203be8:	e17fbf04 	addi	r5,fp,-260
 3203bec:	32335d40 	call	32335d4 <ifd_isset>
 3203bf0:	1005003a 	cmpeq	r2,r2,zero
 3203bf4:	103fc91e 	bne	r2,zero,3203b1c <SSSSimpleSocketServerTask+0xc0>
				sss_handle_receive(&conn);
 3203bf8:	0100c974 	movhi	r4,805
 3203bfc:	21137604 	addi	r4,r4,19928
 3203c00:	32038700 	call	3203870 <sss_handle_receive>
			}
		}
	}
 3203c04:	003fc506 	br	3203b1c <SSSSimpleSocketServerTask+0xc0>

03203c08 <trackers_init>:
// Creates the trackers handlers devices
LOCATOR trackers[TRACKERS];

/* Initializes the trackers handlers. */
void trackers_init()
{
 3203c08:	defffe04 	addi	sp,sp,-8
 3203c0c:	dfc00115 	stw	ra,4(sp)
 3203c10:	df000015 	stw	fp,0(sp)
 3203c14:	d839883a 	mov	fp,sp
	locator_init(&trackers[0], TRACKER(0));
 3203c18:	0100c9b4 	movhi	r4,806
 3203c1c:	2125a504 	addi	r4,r4,-26988
 3203c20:	01404034 	movhi	r5,256
 3203c24:	29414004 	addi	r5,r5,1280
 3203c28:	32214a80 	call	32214a8 <locator_init>
	locator_init(&trackers[1], TRACKER(1));
 3203c2c:	0100c9b4 	movhi	r4,806
 3203c30:	2125a804 	addi	r4,r4,-26976
 3203c34:	01404034 	movhi	r5,256
 3203c38:	29410004 	addi	r5,r5,1024
 3203c3c:	32214a80 	call	32214a8 <locator_init>
	locator_init(&trackers[2], TRACKER(2));
 3203c40:	0100c9b4 	movhi	r4,806
 3203c44:	2125ab04 	addi	r4,r4,-26964
 3203c48:	01404034 	movhi	r5,256
 3203c4c:	2940c004 	addi	r5,r5,768
 3203c50:	32214a80 	call	32214a8 <locator_init>
	locator_init(&trackers[3], TRACKER(3));
 3203c54:	0100c9b4 	movhi	r4,806
 3203c58:	2125ae04 	addi	r4,r4,-26952
 3203c5c:	01404034 	movhi	r5,256
 3203c60:	29408004 	addi	r5,r5,512
 3203c64:	32214a80 	call	32214a8 <locator_init>
	locator_init(&trackers[4], TRACKER(4));
 3203c68:	0100c9b4 	movhi	r4,806
 3203c6c:	2125b104 	addi	r4,r4,-26940
 3203c70:	01404034 	movhi	r5,256
 3203c74:	29404004 	addi	r5,r5,256
 3203c78:	32214a80 	call	32214a8 <locator_init>
	locator_init(&trackers[4], TRACKER(5));
 3203c7c:	0100c9b4 	movhi	r4,806
 3203c80:	2125b104 	addi	r4,r4,-26940
 3203c84:	01404034 	movhi	r5,256
 3203c88:	32214a80 	call	32214a8 <locator_init>
}
 3203c8c:	e037883a 	mov	sp,fp
 3203c90:	dfc00117 	ldw	ra,4(sp)
 3203c94:	df000017 	ldw	fp,0(sp)
 3203c98:	dec00204 	addi	sp,sp,8
 3203c9c:	f800283a 	ret

03203ca0 <trackers_number>:

/* Gets the number of the tracker resources. */
int trackers_number()
{
 3203ca0:	deffff04 	addi	sp,sp,-4
 3203ca4:	df000015 	stw	fp,0(sp)
 3203ca8:	d839883a 	mov	fp,sp
	return TRACKERS;
 3203cac:	00800184 	movi	r2,6
}
 3203cb0:	e037883a 	mov	sp,fp
 3203cb4:	df000017 	ldw	fp,0(sp)
 3203cb8:	dec00104 	addi	sp,sp,4
 3203cbc:	f800283a 	ret

03203cc0 <trackers_free>:

/* Frees all tracker handlers. */
int trackers_free(char *char_buffer)
{
 3203cc0:	defffc04 	addi	sp,sp,-16
 3203cc4:	dfc00315 	stw	ra,12(sp)
 3203cc8:	df000215 	stw	fp,8(sp)
 3203ccc:	df000204 	addi	fp,sp,8
 3203cd0:	e13fff15 	stw	r4,-4(fp)
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203cd4:	e03ffe15 	stw	zero,-8(fp)
 3203cd8:	00001106 	br	3203d20 <trackers_free+0x60>
		trackers[i].active = 0;
 3203cdc:	e0bffe17 	ldw	r2,-8(fp)
 3203ce0:	00c0c9b4 	movhi	r3,806
 3203ce4:	18e5a504 	addi	r3,r3,-26988
 3203ce8:	10800324 	muli	r2,r2,12
 3203cec:	10c5883a 	add	r2,r2,r3
 3203cf0:	10800204 	addi	r2,r2,8
 3203cf4:	10000015 	stw	zero,0(r2)
		trackers[i].id = 0;
 3203cf8:	e0bffe17 	ldw	r2,-8(fp)
 3203cfc:	00c0c9b4 	movhi	r3,806
 3203d00:	18e5a504 	addi	r3,r3,-26988
 3203d04:	10800324 	muli	r2,r2,12
 3203d08:	10c5883a 	add	r2,r2,r3
 3203d0c:	10800104 	addi	r2,r2,4
 3203d10:	10000015 	stw	zero,0(r2)

/* Frees all tracker handlers. */
int trackers_free(char *char_buffer)
{
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203d14:	e0bffe17 	ldw	r2,-8(fp)
 3203d18:	10800044 	addi	r2,r2,1
 3203d1c:	e0bffe15 	stw	r2,-8(fp)
 3203d20:	e0bffe17 	ldw	r2,-8(fp)
 3203d24:	10800190 	cmplti	r2,r2,6
 3203d28:	103fec1e 	bne	r2,zero,3203cdc <trackers_free+0x1c>
		trackers[i].active = 0;
		trackers[i].id = 0;
	}
	return sprintf(char_buffer, "All trackers freed.");
 3203d2c:	e0bfff17 	ldw	r2,-4(fp)
 3203d30:	00c0c974 	movhi	r3,805
 3203d34:	18f5e604 	addi	r3,r3,-10344
 3203d38:	1009883a 	mov	r4,r2
 3203d3c:	180b883a 	mov	r5,r3
 3203d40:	01800504 	movi	r6,20
 3203d44:	3206ad00 	call	3206ad0 <memcpy>
 3203d48:	008004c4 	movi	r2,19
}
 3203d4c:	e037883a 	mov	sp,fp
 3203d50:	dfc00117 	ldw	ra,4(sp)
 3203d54:	df000017 	ldw	fp,0(sp)
 3203d58:	dec00204 	addi	sp,sp,8
 3203d5c:	f800283a 	ret

03203d60 <activate_tracker>:

/* Activates a tracker device. */
int activate_tracker(int id, char *char_buffer)
{
 3203d60:	defffa04 	addi	sp,sp,-24
 3203d64:	dfc00515 	stw	ra,20(sp)
 3203d68:	df000415 	stw	fp,16(sp)
 3203d6c:	df000404 	addi	fp,sp,16
 3203d70:	e13ffd15 	stw	r4,-12(fp)
 3203d74:	e17ffe15 	stw	r5,-8(fp)
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203d78:	e03ffc15 	stw	zero,-16(fp)
 3203d7c:	00001b06 	br	3203dec <activate_tracker+0x8c>
		if (trackers[i].id == id) {
 3203d80:	e0bffc17 	ldw	r2,-16(fp)
 3203d84:	00c0c9b4 	movhi	r3,806
 3203d88:	18e5a504 	addi	r3,r3,-26988
 3203d8c:	10800324 	muli	r2,r2,12
 3203d90:	10c5883a 	add	r2,r2,r3
 3203d94:	10800104 	addi	r2,r2,4
 3203d98:	10c00017 	ldw	r3,0(r2)
 3203d9c:	e0bffd17 	ldw	r2,-12(fp)
 3203da0:	18800f1e 	bne	r3,r2,3203de0 <activate_tracker+0x80>
			trackers[i].active = 1;
 3203da4:	e0bffc17 	ldw	r2,-16(fp)
 3203da8:	00c0c9b4 	movhi	r3,806
 3203dac:	18e5a504 	addi	r3,r3,-26988
 3203db0:	10800324 	muli	r2,r2,12
 3203db4:	10c5883a 	add	r2,r2,r3
 3203db8:	10c00204 	addi	r3,r2,8
 3203dbc:	00800044 	movi	r2,1
 3203dc0:	18800015 	stw	r2,0(r3)
			return sprintf(char_buffer, "Id %i activated.", id);
 3203dc4:	e13ffe17 	ldw	r4,-8(fp)
 3203dc8:	0140c974 	movhi	r5,805
 3203dcc:	2975eb04 	addi	r5,r5,-10324
 3203dd0:	e1bffd17 	ldw	r6,-12(fp)
 3203dd4:	32079c00 	call	32079c0 <sprintf>
 3203dd8:	e0bfff15 	stw	r2,-4(fp)
 3203ddc:	00003406 	br	3203eb0 <activate_tracker+0x150>

/* Activates a tracker device. */
int activate_tracker(int id, char *char_buffer)
{
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203de0:	e0bffc17 	ldw	r2,-16(fp)
 3203de4:	10800044 	addi	r2,r2,1
 3203de8:	e0bffc15 	stw	r2,-16(fp)
 3203dec:	e0bffc17 	ldw	r2,-16(fp)
 3203df0:	10800190 	cmplti	r2,r2,6
 3203df4:	103fe21e 	bne	r2,zero,3203d80 <activate_tracker+0x20>
		if (trackers[i].id == id) {
			trackers[i].active = 1;
			return sprintf(char_buffer, "Id %i activated.", id);
		}
	}
	for (i = 0; i < TRACKERS; i++) {
 3203df8:	e03ffc15 	stw	zero,-16(fp)
 3203dfc:	00002306 	br	3203e8c <activate_tracker+0x12c>
		if (trackers[i].id == 0) {
 3203e00:	e0bffc17 	ldw	r2,-16(fp)
 3203e04:	00c0c9b4 	movhi	r3,806
 3203e08:	18e5a504 	addi	r3,r3,-26988
 3203e0c:	10800324 	muli	r2,r2,12
 3203e10:	10c5883a 	add	r2,r2,r3
 3203e14:	10800104 	addi	r2,r2,4
 3203e18:	10800017 	ldw	r2,0(r2)
 3203e1c:	1004c03a 	cmpne	r2,r2,zero
 3203e20:	1000171e 	bne	r2,zero,3203e80 <activate_tracker+0x120>
			trackers[i].id = id;
 3203e24:	e0bffc17 	ldw	r2,-16(fp)
 3203e28:	00c0c9b4 	movhi	r3,806
 3203e2c:	18e5a504 	addi	r3,r3,-26988
 3203e30:	10800324 	muli	r2,r2,12
 3203e34:	10c5883a 	add	r2,r2,r3
 3203e38:	10c00104 	addi	r3,r2,4
 3203e3c:	e0bffd17 	ldw	r2,-12(fp)
 3203e40:	18800015 	stw	r2,0(r3)
			trackers[i].active = 1;
 3203e44:	e0bffc17 	ldw	r2,-16(fp)
 3203e48:	00c0c9b4 	movhi	r3,806
 3203e4c:	18e5a504 	addi	r3,r3,-26988
 3203e50:	10800324 	muli	r2,r2,12
 3203e54:	10c5883a 	add	r2,r2,r3
 3203e58:	10c00204 	addi	r3,r2,8
 3203e5c:	00800044 	movi	r2,1
 3203e60:	18800015 	stw	r2,0(r3)
			return sprintf(char_buffer, "Id %i activated.", id);
 3203e64:	e13ffe17 	ldw	r4,-8(fp)
 3203e68:	0140c974 	movhi	r5,805
 3203e6c:	2975eb04 	addi	r5,r5,-10324
 3203e70:	e1bffd17 	ldw	r6,-12(fp)
 3203e74:	32079c00 	call	32079c0 <sprintf>
 3203e78:	e0bfff15 	stw	r2,-4(fp)
 3203e7c:	00000c06 	br	3203eb0 <activate_tracker+0x150>
		if (trackers[i].id == id) {
			trackers[i].active = 1;
			return sprintf(char_buffer, "Id %i activated.", id);
		}
	}
	for (i = 0; i < TRACKERS; i++) {
 3203e80:	e0bffc17 	ldw	r2,-16(fp)
 3203e84:	10800044 	addi	r2,r2,1
 3203e88:	e0bffc15 	stw	r2,-16(fp)
 3203e8c:	e0bffc17 	ldw	r2,-16(fp)
 3203e90:	10800190 	cmplti	r2,r2,6
 3203e94:	103fda1e 	bne	r2,zero,3203e00 <activate_tracker+0xa0>
			trackers[i].id = id;
			trackers[i].active = 1;
			return sprintf(char_buffer, "Id %i activated.", id);
		}
	}
	return sprintf(char_buffer, "Id %i not assigned", id);
 3203e98:	e13ffe17 	ldw	r4,-8(fp)
 3203e9c:	0140c974 	movhi	r5,805
 3203ea0:	2975f004 	addi	r5,r5,-10304
 3203ea4:	e1bffd17 	ldw	r6,-12(fp)
 3203ea8:	32079c00 	call	32079c0 <sprintf>
 3203eac:	e0bfff15 	stw	r2,-4(fp)
 3203eb0:	e0bfff17 	ldw	r2,-4(fp)
}
 3203eb4:	e037883a 	mov	sp,fp
 3203eb8:	dfc00117 	ldw	ra,4(sp)
 3203ebc:	df000017 	ldw	fp,0(sp)
 3203ec0:	dec00204 	addi	sp,sp,8
 3203ec4:	f800283a 	ret

03203ec8 <disable_tracker>:

/* Disables a tracker device. */
int disable_tracker(int id, char *char_buffer)
{
 3203ec8:	defffa04 	addi	sp,sp,-24
 3203ecc:	dfc00515 	stw	ra,20(sp)
 3203ed0:	df000415 	stw	fp,16(sp)
 3203ed4:	df000404 	addi	fp,sp,16
 3203ed8:	e13ffd15 	stw	r4,-12(fp)
 3203edc:	e17ffe15 	stw	r5,-8(fp)
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203ee0:	e03ffc15 	stw	zero,-16(fp)
 3203ee4:	00001a06 	br	3203f50 <disable_tracker+0x88>
		if (trackers[i].id == id) {
 3203ee8:	e0bffc17 	ldw	r2,-16(fp)
 3203eec:	00c0c9b4 	movhi	r3,806
 3203ef0:	18e5a504 	addi	r3,r3,-26988
 3203ef4:	10800324 	muli	r2,r2,12
 3203ef8:	10c5883a 	add	r2,r2,r3
 3203efc:	10800104 	addi	r2,r2,4
 3203f00:	10c00017 	ldw	r3,0(r2)
 3203f04:	e0bffd17 	ldw	r2,-12(fp)
 3203f08:	18800e1e 	bne	r3,r2,3203f44 <disable_tracker+0x7c>
			trackers[i].active = 0;
 3203f0c:	e0bffc17 	ldw	r2,-16(fp)
 3203f10:	00c0c9b4 	movhi	r3,806
 3203f14:	18e5a504 	addi	r3,r3,-26988
 3203f18:	10800324 	muli	r2,r2,12
 3203f1c:	10c5883a 	add	r2,r2,r3
 3203f20:	10800204 	addi	r2,r2,8
 3203f24:	10000015 	stw	zero,0(r2)
			return sprintf(char_buffer, "Id %i disabled.", id);
 3203f28:	e13ffe17 	ldw	r4,-8(fp)
 3203f2c:	0140c974 	movhi	r5,805
 3203f30:	2975f504 	addi	r5,r5,-10284
 3203f34:	e1bffd17 	ldw	r6,-12(fp)
 3203f38:	32079c00 	call	32079c0 <sprintf>
 3203f3c:	e0bfff15 	stw	r2,-4(fp)
 3203f40:	00000c06 	br	3203f74 <disable_tracker+0xac>

/* Disables a tracker device. */
int disable_tracker(int id, char *char_buffer)
{
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203f44:	e0bffc17 	ldw	r2,-16(fp)
 3203f48:	10800044 	addi	r2,r2,1
 3203f4c:	e0bffc15 	stw	r2,-16(fp)
 3203f50:	e0bffc17 	ldw	r2,-16(fp)
 3203f54:	10800190 	cmplti	r2,r2,6
 3203f58:	103fe31e 	bne	r2,zero,3203ee8 <disable_tracker+0x20>
		if (trackers[i].id == id) {
			trackers[i].active = 0;
			return sprintf(char_buffer, "Id %i disabled.", id);
		}
	}
	return sprintf(char_buffer, "Id %i not found.", id);
 3203f5c:	e13ffe17 	ldw	r4,-8(fp)
 3203f60:	0140c974 	movhi	r5,805
 3203f64:	2975f904 	addi	r5,r5,-10268
 3203f68:	e1bffd17 	ldw	r6,-12(fp)
 3203f6c:	32079c00 	call	32079c0 <sprintf>
 3203f70:	e0bfff15 	stw	r2,-4(fp)
 3203f74:	e0bfff17 	ldw	r2,-4(fp)
}
 3203f78:	e037883a 	mov	sp,fp
 3203f7c:	dfc00117 	ldw	ra,4(sp)
 3203f80:	df000017 	ldw	fp,0(sp)
 3203f84:	dec00204 	addi	sp,sp,8
 3203f88:	f800283a 	ret

03203f8c <free_tracker>:

/* Frees a tracker device. */
int free_tracker(int id, char *char_buffer)
{
 3203f8c:	defffa04 	addi	sp,sp,-24
 3203f90:	dfc00515 	stw	ra,20(sp)
 3203f94:	df000415 	stw	fp,16(sp)
 3203f98:	df000404 	addi	fp,sp,16
 3203f9c:	e13ffd15 	stw	r4,-12(fp)
 3203fa0:	e17ffe15 	stw	r5,-8(fp)
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3203fa4:	e03ffc15 	stw	zero,-16(fp)
 3203fa8:	00002106 	br	3204030 <free_tracker+0xa4>
		if (trackers[i].id == id) {
 3203fac:	e0bffc17 	ldw	r2,-16(fp)
 3203fb0:	00c0c9b4 	movhi	r3,806
 3203fb4:	18e5a504 	addi	r3,r3,-26988
 3203fb8:	10800324 	muli	r2,r2,12
 3203fbc:	10c5883a 	add	r2,r2,r3
 3203fc0:	10800104 	addi	r2,r2,4
 3203fc4:	10c00017 	ldw	r3,0(r2)
 3203fc8:	e0bffd17 	ldw	r2,-12(fp)
 3203fcc:	1880151e 	bne	r3,r2,3204024 <free_tracker+0x98>
			trackers[i].active = 0;
 3203fd0:	e0bffc17 	ldw	r2,-16(fp)
 3203fd4:	00c0c9b4 	movhi	r3,806
 3203fd8:	18e5a504 	addi	r3,r3,-26988
 3203fdc:	10800324 	muli	r2,r2,12
 3203fe0:	10c5883a 	add	r2,r2,r3
 3203fe4:	10800204 	addi	r2,r2,8
 3203fe8:	10000015 	stw	zero,0(r2)
			trackers[i].id = 0;
 3203fec:	e0bffc17 	ldw	r2,-16(fp)
 3203ff0:	00c0c9b4 	movhi	r3,806
 3203ff4:	18e5a504 	addi	r3,r3,-26988
 3203ff8:	10800324 	muli	r2,r2,12
 3203ffc:	10c5883a 	add	r2,r2,r3
 3204000:	10800104 	addi	r2,r2,4
 3204004:	10000015 	stw	zero,0(r2)
			return sprintf(char_buffer, "Id %i free.", id);
 3204008:	e13ffe17 	ldw	r4,-8(fp)
 320400c:	0140c974 	movhi	r5,805
 3204010:	2975fe04 	addi	r5,r5,-10248
 3204014:	e1bffd17 	ldw	r6,-12(fp)
 3204018:	32079c00 	call	32079c0 <sprintf>
 320401c:	e0bfff15 	stw	r2,-4(fp)
 3204020:	00000c06 	br	3204054 <free_tracker+0xc8>

/* Frees a tracker device. */
int free_tracker(int id, char *char_buffer)
{
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3204024:	e0bffc17 	ldw	r2,-16(fp)
 3204028:	10800044 	addi	r2,r2,1
 320402c:	e0bffc15 	stw	r2,-16(fp)
 3204030:	e0bffc17 	ldw	r2,-16(fp)
 3204034:	10800190 	cmplti	r2,r2,6
 3204038:	103fdc1e 	bne	r2,zero,3203fac <free_tracker+0x20>
			trackers[i].active = 0;
			trackers[i].id = 0;
			return sprintf(char_buffer, "Id %i free.", id);
		}
	}
	return sprintf(char_buffer, "Id %i not found.", id);
 320403c:	e13ffe17 	ldw	r4,-8(fp)
 3204040:	0140c974 	movhi	r5,805
 3204044:	2975f904 	addi	r5,r5,-10268
 3204048:	e1bffd17 	ldw	r6,-12(fp)
 320404c:	32079c00 	call	32079c0 <sprintf>
 3204050:	e0bfff15 	stw	r2,-4(fp)
 3204054:	e0bfff17 	ldw	r2,-4(fp)
}
 3204058:	e037883a 	mov	sp,fp
 320405c:	dfc00117 	ldw	ra,4(sp)
 3204060:	df000017 	ldw	fp,0(sp)
 3204064:	dec00204 	addi	sp,sp,8
 3204068:	f800283a 	ret

0320406c <set_search_window_of_tracker>:

/* Sets the search window of the assigned tracker device. */
int set_search_window_of_tracker(int id, char *char_buffer, int x, int y, int width, int height)
{
 320406c:	defff604 	addi	sp,sp,-40
 3204070:	dfc00915 	stw	ra,36(sp)
 3204074:	df000815 	stw	fp,32(sp)
 3204078:	df000804 	addi	fp,sp,32
 320407c:	e13ffb15 	stw	r4,-20(fp)
 3204080:	e17ffc15 	stw	r5,-16(fp)
 3204084:	e1bffd15 	stw	r6,-12(fp)
 3204088:	e1fffe15 	stw	r7,-8(fp)
	int i;
	for (i = 0; i < TRACKERS; i++) {
 320408c:	e03ffa15 	stw	zero,-24(fp)
 3204090:	00002406 	br	3204124 <set_search_window_of_tracker+0xb8>
		if (trackers[i].id == id) {
 3204094:	e0bffa17 	ldw	r2,-24(fp)
 3204098:	00c0c9b4 	movhi	r3,806
 320409c:	18e5a504 	addi	r3,r3,-26988
 32040a0:	10800324 	muli	r2,r2,12
 32040a4:	10c5883a 	add	r2,r2,r3
 32040a8:	10800104 	addi	r2,r2,4
 32040ac:	10c00017 	ldw	r3,0(r2)
 32040b0:	e0bffb17 	ldw	r2,-20(fp)
 32040b4:	1880181e 	bne	r3,r2,3204118 <set_search_window_of_tracker+0xac>
			trackers[i].active = 1;
 32040b8:	e0bffa17 	ldw	r2,-24(fp)
 32040bc:	00c0c9b4 	movhi	r3,806
 32040c0:	18e5a504 	addi	r3,r3,-26988
 32040c4:	10800324 	muli	r2,r2,12
 32040c8:	10c5883a 	add	r2,r2,r3
 32040cc:	10c00204 	addi	r3,r2,8
 32040d0:	00800044 	movi	r2,1
 32040d4:	18800015 	stw	r2,0(r3)
			return set_search_window(&trackers[i], char_buffer, x, y, width, height);
 32040d8:	e0bffa17 	ldw	r2,-24(fp)
 32040dc:	10800324 	muli	r2,r2,12
 32040e0:	1007883a 	mov	r3,r2
 32040e4:	0080c9b4 	movhi	r2,806
 32040e8:	10a5a504 	addi	r2,r2,-26988
 32040ec:	1889883a 	add	r4,r3,r2
 32040f0:	e0800217 	ldw	r2,8(fp)
 32040f4:	d8800015 	stw	r2,0(sp)
 32040f8:	e0800317 	ldw	r2,12(fp)
 32040fc:	d8800115 	stw	r2,4(sp)
 3204100:	e17ffc17 	ldw	r5,-16(fp)
 3204104:	e1bffd17 	ldw	r6,-12(fp)
 3204108:	e1fffe17 	ldw	r7,-8(fp)
 320410c:	32216ac0 	call	32216ac <set_search_window>
 3204110:	e0bfff15 	stw	r2,-4(fp)
 3204114:	00003d06 	br	320420c <set_search_window_of_tracker+0x1a0>

/* Sets the search window of the assigned tracker device. */
int set_search_window_of_tracker(int id, char *char_buffer, int x, int y, int width, int height)
{
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3204118:	e0bffa17 	ldw	r2,-24(fp)
 320411c:	10800044 	addi	r2,r2,1
 3204120:	e0bffa15 	stw	r2,-24(fp)
 3204124:	e0bffa17 	ldw	r2,-24(fp)
 3204128:	10800190 	cmplti	r2,r2,6
 320412c:	103fd91e 	bne	r2,zero,3204094 <set_search_window_of_tracker+0x28>
		if (trackers[i].id == id) {
			trackers[i].active = 1;
			return set_search_window(&trackers[i], char_buffer, x, y, width, height);
		}
	}
	for (i = 0; i < TRACKERS; i++) {
 3204130:	e03ffa15 	stw	zero,-24(fp)
 3204134:	00002c06 	br	32041e8 <set_search_window_of_tracker+0x17c>
		if (trackers[i].id == 0) {
 3204138:	e0bffa17 	ldw	r2,-24(fp)
 320413c:	00c0c9b4 	movhi	r3,806
 3204140:	18e5a504 	addi	r3,r3,-26988
 3204144:	10800324 	muli	r2,r2,12
 3204148:	10c5883a 	add	r2,r2,r3
 320414c:	10800104 	addi	r2,r2,4
 3204150:	10800017 	ldw	r2,0(r2)
 3204154:	1004c03a 	cmpne	r2,r2,zero
 3204158:	1000201e 	bne	r2,zero,32041dc <set_search_window_of_tracker+0x170>
			trackers[i].id = id;
 320415c:	e0bffa17 	ldw	r2,-24(fp)
 3204160:	00c0c9b4 	movhi	r3,806
 3204164:	18e5a504 	addi	r3,r3,-26988
 3204168:	10800324 	muli	r2,r2,12
 320416c:	10c5883a 	add	r2,r2,r3
 3204170:	10c00104 	addi	r3,r2,4
 3204174:	e0bffb17 	ldw	r2,-20(fp)
 3204178:	18800015 	stw	r2,0(r3)
			trackers[i].active = 1;
 320417c:	e0bffa17 	ldw	r2,-24(fp)
 3204180:	00c0c9b4 	movhi	r3,806
 3204184:	18e5a504 	addi	r3,r3,-26988
 3204188:	10800324 	muli	r2,r2,12
 320418c:	10c5883a 	add	r2,r2,r3
 3204190:	10c00204 	addi	r3,r2,8
 3204194:	00800044 	movi	r2,1
 3204198:	18800015 	stw	r2,0(r3)
			return set_search_window(&trackers[i], char_buffer, x, y, width, height);
 320419c:	e0bffa17 	ldw	r2,-24(fp)
 32041a0:	10800324 	muli	r2,r2,12
 32041a4:	1007883a 	mov	r3,r2
 32041a8:	0080c9b4 	movhi	r2,806
 32041ac:	10a5a504 	addi	r2,r2,-26988
 32041b0:	1889883a 	add	r4,r3,r2
 32041b4:	e0800217 	ldw	r2,8(fp)
 32041b8:	d8800015 	stw	r2,0(sp)
 32041bc:	e0800317 	ldw	r2,12(fp)
 32041c0:	d8800115 	stw	r2,4(sp)
 32041c4:	e17ffc17 	ldw	r5,-16(fp)
 32041c8:	e1bffd17 	ldw	r6,-12(fp)
 32041cc:	e1fffe17 	ldw	r7,-8(fp)
 32041d0:	32216ac0 	call	32216ac <set_search_window>
 32041d4:	e0bfff15 	stw	r2,-4(fp)
 32041d8:	00000c06 	br	320420c <set_search_window_of_tracker+0x1a0>
		if (trackers[i].id == id) {
			trackers[i].active = 1;
			return set_search_window(&trackers[i], char_buffer, x, y, width, height);
		}
	}
	for (i = 0; i < TRACKERS; i++) {
 32041dc:	e0bffa17 	ldw	r2,-24(fp)
 32041e0:	10800044 	addi	r2,r2,1
 32041e4:	e0bffa15 	stw	r2,-24(fp)
 32041e8:	e0bffa17 	ldw	r2,-24(fp)
 32041ec:	10800190 	cmplti	r2,r2,6
 32041f0:	103fd11e 	bne	r2,zero,3204138 <set_search_window_of_tracker+0xcc>
			trackers[i].id = id;
			trackers[i].active = 1;
			return set_search_window(&trackers[i], char_buffer, x, y, width, height);
		}
	}
	return sprintf(char_buffer, "Id %i not assigned.", id);
 32041f4:	e13ffc17 	ldw	r4,-16(fp)
 32041f8:	0140c974 	movhi	r5,805
 32041fc:	29760104 	addi	r5,r5,-10236
 3204200:	e1bffb17 	ldw	r6,-20(fp)
 3204204:	32079c00 	call	32079c0 <sprintf>
 3204208:	e0bfff15 	stw	r2,-4(fp)
 320420c:	e0bfff17 	ldw	r2,-4(fp)
}
 3204210:	e037883a 	mov	sp,fp
 3204214:	dfc00117 	ldw	ra,4(sp)
 3204218:	df000017 	ldw	fp,0(sp)
 320421c:	dec00204 	addi	sp,sp,8
 3204220:	f800283a 	ret

03204224 <get_search_window_of_tracker>:

/* Gets the search window of the assigned tracker device. */
int get_search_window_of_tracker(int id, char *char_buffer)
{
 3204224:	defffa04 	addi	sp,sp,-24
 3204228:	dfc00515 	stw	ra,20(sp)
 320422c:	df000415 	stw	fp,16(sp)
 3204230:	df000404 	addi	fp,sp,16
 3204234:	e13ffd15 	stw	r4,-12(fp)
 3204238:	e17ffe15 	stw	r5,-8(fp)
	int i;
	for (i = 0; i < TRACKERS; i++) {
 320423c:	e03ffc15 	stw	zero,-16(fp)
 3204240:	00001606 	br	320429c <get_search_window_of_tracker+0x78>
		if (trackers[i].id == id) {
 3204244:	e0bffc17 	ldw	r2,-16(fp)
 3204248:	00c0c9b4 	movhi	r3,806
 320424c:	18e5a504 	addi	r3,r3,-26988
 3204250:	10800324 	muli	r2,r2,12
 3204254:	10c5883a 	add	r2,r2,r3
 3204258:	10800104 	addi	r2,r2,4
 320425c:	10c00017 	ldw	r3,0(r2)
 3204260:	e0bffd17 	ldw	r2,-12(fp)
 3204264:	18800a1e 	bne	r3,r2,3204290 <get_search_window_of_tracker+0x6c>
			return get_search_window(&trackers[i], char_buffer);
 3204268:	e0bffc17 	ldw	r2,-16(fp)
 320426c:	10800324 	muli	r2,r2,12
 3204270:	1007883a 	mov	r3,r2
 3204274:	0080c9b4 	movhi	r2,806
 3204278:	10a5a504 	addi	r2,r2,-26988
 320427c:	1889883a 	add	r4,r3,r2
 3204280:	e17ffe17 	ldw	r5,-8(fp)
 3204284:	32217b00 	call	32217b0 <get_search_window>
 3204288:	e0bfff15 	stw	r2,-4(fp)
 320428c:	00000c06 	br	32042c0 <get_search_window_of_tracker+0x9c>

/* Gets the search window of the assigned tracker device. */
int get_search_window_of_tracker(int id, char *char_buffer)
{
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3204290:	e0bffc17 	ldw	r2,-16(fp)
 3204294:	10800044 	addi	r2,r2,1
 3204298:	e0bffc15 	stw	r2,-16(fp)
 320429c:	e0bffc17 	ldw	r2,-16(fp)
 32042a0:	10800190 	cmplti	r2,r2,6
 32042a4:	103fe71e 	bne	r2,zero,3204244 <get_search_window_of_tracker+0x20>
		if (trackers[i].id == id) {
			return get_search_window(&trackers[i], char_buffer);
		}
	}
	return sprintf(char_buffer, "Id %i not found.", id);
 32042a8:	e13ffe17 	ldw	r4,-8(fp)
 32042ac:	0140c974 	movhi	r5,805
 32042b0:	2975f904 	addi	r5,r5,-10268
 32042b4:	e1bffd17 	ldw	r6,-12(fp)
 32042b8:	32079c00 	call	32079c0 <sprintf>
 32042bc:	e0bfff15 	stw	r2,-4(fp)
 32042c0:	e0bfff17 	ldw	r2,-4(fp)
}
 32042c4:	e037883a 	mov	sp,fp
 32042c8:	dfc00117 	ldw	ra,4(sp)
 32042cc:	df000017 	ldw	fp,0(sp)
 32042d0:	dec00204 	addi	sp,sp,8
 32042d4:	f800283a 	ret

032042d8 <get_current_corners_of_tracker>:

/* Gets the corners locations of the assigned tracker device. */
int get_current_corners_of_tracker(int id, char *char_buffer)
{
 32042d8:	defffa04 	addi	sp,sp,-24
 32042dc:	dfc00515 	stw	ra,20(sp)
 32042e0:	df000415 	stw	fp,16(sp)
 32042e4:	df000404 	addi	fp,sp,16
 32042e8:	e13ffd15 	stw	r4,-12(fp)
 32042ec:	e17ffe15 	stw	r5,-8(fp)
	int i;
	for (i = 0; i < TRACKERS; i++) {
 32042f0:	e03ffc15 	stw	zero,-16(fp)
 32042f4:	00001606 	br	3204350 <get_current_corners_of_tracker+0x78>
		if (trackers[i].id == id) {
 32042f8:	e0bffc17 	ldw	r2,-16(fp)
 32042fc:	00c0c9b4 	movhi	r3,806
 3204300:	18e5a504 	addi	r3,r3,-26988
 3204304:	10800324 	muli	r2,r2,12
 3204308:	10c5883a 	add	r2,r2,r3
 320430c:	10800104 	addi	r2,r2,4
 3204310:	10c00017 	ldw	r3,0(r2)
 3204314:	e0bffd17 	ldw	r2,-12(fp)
 3204318:	18800a1e 	bne	r3,r2,3204344 <get_current_corners_of_tracker+0x6c>
			return get_current_corners(&trackers[i], char_buffer);
 320431c:	e0bffc17 	ldw	r2,-16(fp)
 3204320:	10800324 	muli	r2,r2,12
 3204324:	1007883a 	mov	r3,r2
 3204328:	0080c9b4 	movhi	r2,806
 320432c:	10a5a504 	addi	r2,r2,-26988
 3204330:	1889883a 	add	r4,r3,r2
 3204334:	e17ffe17 	ldw	r5,-8(fp)
 3204338:	32214e80 	call	32214e8 <get_current_corners>
 320433c:	e0bfff15 	stw	r2,-4(fp)
 3204340:	00000c06 	br	3204374 <get_current_corners_of_tracker+0x9c>

/* Gets the corners locations of the assigned tracker device. */
int get_current_corners_of_tracker(int id, char *char_buffer)
{
	int i;
	for (i = 0; i < TRACKERS; i++) {
 3204344:	e0bffc17 	ldw	r2,-16(fp)
 3204348:	10800044 	addi	r2,r2,1
 320434c:	e0bffc15 	stw	r2,-16(fp)
 3204350:	e0bffc17 	ldw	r2,-16(fp)
 3204354:	10800190 	cmplti	r2,r2,6
 3204358:	103fe71e 	bne	r2,zero,32042f8 <get_current_corners_of_tracker+0x20>
		if (trackers[i].id == id) {
			return get_current_corners(&trackers[i], char_buffer);
		}
	}
	return sprintf(char_buffer, "Id %i not found.", id);
 320435c:	e13ffe17 	ldw	r4,-8(fp)
 3204360:	0140c974 	movhi	r5,805
 3204364:	2975f904 	addi	r5,r5,-10268
 3204368:	e1bffd17 	ldw	r6,-12(fp)
 320436c:	32079c00 	call	32079c0 <sprintf>
 3204370:	e0bfff15 	stw	r2,-4(fp)
 3204374:	e0bfff17 	ldw	r2,-4(fp)
}
 3204378:	e037883a 	mov	sp,fp
 320437c:	dfc00117 	ldw	ra,4(sp)
 3204380:	df000017 	ldw	fp,0(sp)
 3204384:	dec00204 	addi	sp,sp,8
 3204388:	f800283a 	ret

0320438c <get_current_windows_of_activated_trackers>:

/* Gets the search windows of all activated tracker devices. */
int get_current_windows_of_activated_trackers(char *char_buffer)
{
 320438c:	defffb04 	addi	sp,sp,-20
 3204390:	dfc00415 	stw	ra,16(sp)
 3204394:	df000315 	stw	fp,12(sp)
 3204398:	df000304 	addi	fp,sp,12
 320439c:	e13fff15 	stw	r4,-4(fp)
	int i;
	int nchars = 0;
 32043a0:	e03ffd15 	stw	zero,-12(fp)

	nchars += sprintf(char_buffer, "{");
 32043a4:	e0ffff17 	ldw	r3,-4(fp)
 32043a8:	00801ec4 	movi	r2,123
 32043ac:	18800005 	stb	r2,0(r3)
 32043b0:	18000045 	stb	zero,1(r3)
 32043b4:	e0bffd17 	ldw	r2,-12(fp)
 32043b8:	10800044 	addi	r2,r2,1
 32043bc:	e0bffd15 	stw	r2,-12(fp)
	for (i = 0; i < TRACKERS; i++) {
 32043c0:	e03ffe15 	stw	zero,-8(fp)
 32043c4:	00003706 	br	32044a4 <get_current_windows_of_activated_trackers+0x118>
		if (trackers[i].active == 1) {
 32043c8:	e0bffe17 	ldw	r2,-8(fp)
 32043cc:	00c0c9b4 	movhi	r3,806
 32043d0:	18e5a504 	addi	r3,r3,-26988
 32043d4:	10800324 	muli	r2,r2,12
 32043d8:	10c5883a 	add	r2,r2,r3
 32043dc:	10800204 	addi	r2,r2,8
 32043e0:	10800017 	ldw	r2,0(r2)
 32043e4:	10800058 	cmpnei	r2,r2,1
 32043e8:	10002b1e 	bne	r2,zero,3204498 <get_current_windows_of_activated_trackers+0x10c>
			nchars += sprintf(char_buffer + nchars, "'%i':", trackers[i].id);
 32043ec:	e0bffd17 	ldw	r2,-12(fp)
 32043f0:	1007883a 	mov	r3,r2
 32043f4:	e0bfff17 	ldw	r2,-4(fp)
 32043f8:	1889883a 	add	r4,r3,r2
 32043fc:	e0bffe17 	ldw	r2,-8(fp)
 3204400:	00c0c9b4 	movhi	r3,806
 3204404:	18e5a504 	addi	r3,r3,-26988
 3204408:	10800324 	muli	r2,r2,12
 320440c:	10c5883a 	add	r2,r2,r3
 3204410:	10800104 	addi	r2,r2,4
 3204414:	11800017 	ldw	r6,0(r2)
 3204418:	0140c974 	movhi	r5,805
 320441c:	29760604 	addi	r5,r5,-10216
 3204420:	32079c00 	call	32079c0 <sprintf>
 3204424:	1007883a 	mov	r3,r2
 3204428:	e0bffd17 	ldw	r2,-12(fp)
 320442c:	10c5883a 	add	r2,r2,r3
 3204430:	e0bffd15 	stw	r2,-12(fp)
			nchars += get_search_window(&trackers[i], char_buffer + nchars);
 3204434:	e0bffe17 	ldw	r2,-8(fp)
 3204438:	10800324 	muli	r2,r2,12
 320443c:	1007883a 	mov	r3,r2
 3204440:	0080c9b4 	movhi	r2,806
 3204444:	10a5a504 	addi	r2,r2,-26988
 3204448:	1889883a 	add	r4,r3,r2
 320444c:	e0bffd17 	ldw	r2,-12(fp)
 3204450:	1007883a 	mov	r3,r2
 3204454:	e0bfff17 	ldw	r2,-4(fp)
 3204458:	188b883a 	add	r5,r3,r2
 320445c:	32217b00 	call	32217b0 <get_search_window>
 3204460:	1007883a 	mov	r3,r2
 3204464:	e0bffd17 	ldw	r2,-12(fp)
 3204468:	10c5883a 	add	r2,r2,r3
 320446c:	e0bffd15 	stw	r2,-12(fp)
			nchars += sprintf(char_buffer + nchars, ",");
 3204470:	e0bffd17 	ldw	r2,-12(fp)
 3204474:	1007883a 	mov	r3,r2
 3204478:	e0bfff17 	ldw	r2,-4(fp)
 320447c:	1887883a 	add	r3,r3,r2
 3204480:	00800b04 	movi	r2,44
 3204484:	18800005 	stb	r2,0(r3)
 3204488:	18000045 	stb	zero,1(r3)
 320448c:	e0bffd17 	ldw	r2,-12(fp)
 3204490:	10800044 	addi	r2,r2,1
 3204494:	e0bffd15 	stw	r2,-12(fp)
{
	int i;
	int nchars = 0;

	nchars += sprintf(char_buffer, "{");
	for (i = 0; i < TRACKERS; i++) {
 3204498:	e0bffe17 	ldw	r2,-8(fp)
 320449c:	10800044 	addi	r2,r2,1
 32044a0:	e0bffe15 	stw	r2,-8(fp)
 32044a4:	e0bffe17 	ldw	r2,-8(fp)
 32044a8:	10800190 	cmplti	r2,r2,6
 32044ac:	103fc61e 	bne	r2,zero,32043c8 <get_current_windows_of_activated_trackers+0x3c>
			nchars += sprintf(char_buffer + nchars, "'%i':", trackers[i].id);
			nchars += get_search_window(&trackers[i], char_buffer + nchars);
			nchars += sprintf(char_buffer + nchars, ",");
		}
	}
	if (nchars > 1) nchars--;
 32044b0:	e0bffd17 	ldw	r2,-12(fp)
 32044b4:	10800090 	cmplti	r2,r2,2
 32044b8:	1000031e 	bne	r2,zero,32044c8 <get_current_windows_of_activated_trackers+0x13c>
 32044bc:	e0bffd17 	ldw	r2,-12(fp)
 32044c0:	10bfffc4 	addi	r2,r2,-1
 32044c4:	e0bffd15 	stw	r2,-12(fp)
	nchars += sprintf(char_buffer + nchars, "}");
 32044c8:	e0bffd17 	ldw	r2,-12(fp)
 32044cc:	1007883a 	mov	r3,r2
 32044d0:	e0bfff17 	ldw	r2,-4(fp)
 32044d4:	1887883a 	add	r3,r3,r2
 32044d8:	00801f44 	movi	r2,125
 32044dc:	18800005 	stb	r2,0(r3)
 32044e0:	18000045 	stb	zero,1(r3)
 32044e4:	e0bffd17 	ldw	r2,-12(fp)
 32044e8:	10800044 	addi	r2,r2,1
 32044ec:	e0bffd15 	stw	r2,-12(fp)

	return nchars;
 32044f0:	e0bffd17 	ldw	r2,-12(fp)
}
 32044f4:	e037883a 	mov	sp,fp
 32044f8:	dfc00117 	ldw	ra,4(sp)
 32044fc:	df000017 	ldw	fp,0(sp)
 3204500:	dec00204 	addi	sp,sp,8
 3204504:	f800283a 	ret

03204508 <get_current_corners_of_activated_trackers>:

/* Gets the corners locations of all activated tracker devices. */
int get_current_corners_of_activated_trackers(char *char_buffer)
{
 3204508:	defffb04 	addi	sp,sp,-20
 320450c:	dfc00415 	stw	ra,16(sp)
 3204510:	df000315 	stw	fp,12(sp)
 3204514:	df000304 	addi	fp,sp,12
 3204518:	e13fff15 	stw	r4,-4(fp)
	int i;
	int nchars = 0;
 320451c:	e03ffd15 	stw	zero,-12(fp)

	nchars += sprintf(char_buffer, "{");
 3204520:	e0ffff17 	ldw	r3,-4(fp)
 3204524:	00801ec4 	movi	r2,123
 3204528:	18800005 	stb	r2,0(r3)
 320452c:	18000045 	stb	zero,1(r3)
 3204530:	e0bffd17 	ldw	r2,-12(fp)
 3204534:	10800044 	addi	r2,r2,1
 3204538:	e0bffd15 	stw	r2,-12(fp)
	for (i = 0; i < TRACKERS; i++) {
 320453c:	e03ffe15 	stw	zero,-8(fp)
 3204540:	00003706 	br	3204620 <get_current_corners_of_activated_trackers+0x118>
		if (trackers[i].active == 1) {
 3204544:	e0bffe17 	ldw	r2,-8(fp)
 3204548:	00c0c9b4 	movhi	r3,806
 320454c:	18e5a504 	addi	r3,r3,-26988
 3204550:	10800324 	muli	r2,r2,12
 3204554:	10c5883a 	add	r2,r2,r3
 3204558:	10800204 	addi	r2,r2,8
 320455c:	10800017 	ldw	r2,0(r2)
 3204560:	10800058 	cmpnei	r2,r2,1
 3204564:	10002b1e 	bne	r2,zero,3204614 <get_current_corners_of_activated_trackers+0x10c>
			nchars += sprintf(char_buffer + nchars, "'%i':", trackers[i].id);
 3204568:	e0bffd17 	ldw	r2,-12(fp)
 320456c:	1007883a 	mov	r3,r2
 3204570:	e0bfff17 	ldw	r2,-4(fp)
 3204574:	1889883a 	add	r4,r3,r2
 3204578:	e0bffe17 	ldw	r2,-8(fp)
 320457c:	00c0c9b4 	movhi	r3,806
 3204580:	18e5a504 	addi	r3,r3,-26988
 3204584:	10800324 	muli	r2,r2,12
 3204588:	10c5883a 	add	r2,r2,r3
 320458c:	10800104 	addi	r2,r2,4
 3204590:	11800017 	ldw	r6,0(r2)
 3204594:	0140c974 	movhi	r5,805
 3204598:	29760604 	addi	r5,r5,-10216
 320459c:	32079c00 	call	32079c0 <sprintf>
 32045a0:	1007883a 	mov	r3,r2
 32045a4:	e0bffd17 	ldw	r2,-12(fp)
 32045a8:	10c5883a 	add	r2,r2,r3
 32045ac:	e0bffd15 	stw	r2,-12(fp)
			nchars += get_current_corners(&trackers[i], char_buffer + nchars);
 32045b0:	e0bffe17 	ldw	r2,-8(fp)
 32045b4:	10800324 	muli	r2,r2,12
 32045b8:	1007883a 	mov	r3,r2
 32045bc:	0080c9b4 	movhi	r2,806
 32045c0:	10a5a504 	addi	r2,r2,-26988
 32045c4:	1889883a 	add	r4,r3,r2
 32045c8:	e0bffd17 	ldw	r2,-12(fp)
 32045cc:	1007883a 	mov	r3,r2
 32045d0:	e0bfff17 	ldw	r2,-4(fp)
 32045d4:	188b883a 	add	r5,r3,r2
 32045d8:	32214e80 	call	32214e8 <get_current_corners>
 32045dc:	1007883a 	mov	r3,r2
 32045e0:	e0bffd17 	ldw	r2,-12(fp)
 32045e4:	10c5883a 	add	r2,r2,r3
 32045e8:	e0bffd15 	stw	r2,-12(fp)
			nchars += sprintf(char_buffer + nchars, ",");
 32045ec:	e0bffd17 	ldw	r2,-12(fp)
 32045f0:	1007883a 	mov	r3,r2
 32045f4:	e0bfff17 	ldw	r2,-4(fp)
 32045f8:	1887883a 	add	r3,r3,r2
 32045fc:	00800b04 	movi	r2,44
 3204600:	18800005 	stb	r2,0(r3)
 3204604:	18000045 	stb	zero,1(r3)
 3204608:	e0bffd17 	ldw	r2,-12(fp)
 320460c:	10800044 	addi	r2,r2,1
 3204610:	e0bffd15 	stw	r2,-12(fp)
{
	int i;
	int nchars = 0;

	nchars += sprintf(char_buffer, "{");
	for (i = 0; i < TRACKERS; i++) {
 3204614:	e0bffe17 	ldw	r2,-8(fp)
 3204618:	10800044 	addi	r2,r2,1
 320461c:	e0bffe15 	stw	r2,-8(fp)
 3204620:	e0bffe17 	ldw	r2,-8(fp)
 3204624:	10800190 	cmplti	r2,r2,6
 3204628:	103fc61e 	bne	r2,zero,3204544 <get_current_corners_of_activated_trackers+0x3c>
			nchars += sprintf(char_buffer + nchars, "'%i':", trackers[i].id);
			nchars += get_current_corners(&trackers[i], char_buffer + nchars);
			nchars += sprintf(char_buffer + nchars, ",");
		}
	}
	if (nchars > 1) nchars--;
 320462c:	e0bffd17 	ldw	r2,-12(fp)
 3204630:	10800090 	cmplti	r2,r2,2
 3204634:	1000031e 	bne	r2,zero,3204644 <get_current_corners_of_activated_trackers+0x13c>
 3204638:	e0bffd17 	ldw	r2,-12(fp)
 320463c:	10bfffc4 	addi	r2,r2,-1
 3204640:	e0bffd15 	stw	r2,-12(fp)
	nchars += sprintf(char_buffer + nchars, "}");
 3204644:	e0bffd17 	ldw	r2,-12(fp)
 3204648:	1007883a 	mov	r3,r2
 320464c:	e0bfff17 	ldw	r2,-4(fp)
 3204650:	1887883a 	add	r3,r3,r2
 3204654:	00801f44 	movi	r2,125
 3204658:	18800005 	stb	r2,0(r3)
 320465c:	18000045 	stb	zero,1(r3)
 3204660:	e0bffd17 	ldw	r2,-12(fp)
 3204664:	10800044 	addi	r2,r2,1
 3204668:	e0bffd15 	stw	r2,-12(fp)

	return nchars;
 320466c:	e0bffd17 	ldw	r2,-12(fp)
}
 3204670:	e037883a 	mov	sp,fp
 3204674:	dfc00117 	ldw	ra,4(sp)
 3204678:	df000017 	ldw	fp,0(sp)
 320467c:	dec00204 	addi	sp,sp,8
 3204680:	f800283a 	ret

03204684 <udivmodsi4>:
 3204684:	29001b2e 	bgeu	r5,r4,32046f4 <udivmodsi4+0x70>
 3204688:	28001a16 	blt	r5,zero,32046f4 <udivmodsi4+0x70>
 320468c:	00800044 	movi	r2,1
 3204690:	0007883a 	mov	r3,zero
 3204694:	01c007c4 	movi	r7,31
 3204698:	00000306 	br	32046a8 <udivmodsi4+0x24>
 320469c:	19c01326 	beq	r3,r7,32046ec <udivmodsi4+0x68>
 32046a0:	18c00044 	addi	r3,r3,1
 32046a4:	28000416 	blt	r5,zero,32046b8 <udivmodsi4+0x34>
 32046a8:	294b883a 	add	r5,r5,r5
 32046ac:	1085883a 	add	r2,r2,r2
 32046b0:	293ffa36 	bltu	r5,r4,320469c <udivmodsi4+0x18>
 32046b4:	10000d26 	beq	r2,zero,32046ec <udivmodsi4+0x68>
 32046b8:	0007883a 	mov	r3,zero
 32046bc:	21400236 	bltu	r4,r5,32046c8 <udivmodsi4+0x44>
 32046c0:	2149c83a 	sub	r4,r4,r5
 32046c4:	1886b03a 	or	r3,r3,r2
 32046c8:	1004d07a 	srli	r2,r2,1
 32046cc:	280ad07a 	srli	r5,r5,1
 32046d0:	103ffa1e 	bne	r2,zero,32046bc <udivmodsi4+0x38>
 32046d4:	30000226 	beq	r6,zero,32046e0 <udivmodsi4+0x5c>
 32046d8:	2005883a 	mov	r2,r4
 32046dc:	f800283a 	ret
 32046e0:	1809883a 	mov	r4,r3
 32046e4:	2005883a 	mov	r2,r4
 32046e8:	f800283a 	ret
 32046ec:	0007883a 	mov	r3,zero
 32046f0:	003ff806 	br	32046d4 <udivmodsi4+0x50>
 32046f4:	00800044 	movi	r2,1
 32046f8:	0007883a 	mov	r3,zero
 32046fc:	003fef06 	br	32046bc <udivmodsi4+0x38>

03204700 <__divsi3>:
 3204700:	defffe04 	addi	sp,sp,-8
 3204704:	dc000015 	stw	r16,0(sp)
 3204708:	dfc00115 	stw	ra,4(sp)
 320470c:	0021883a 	mov	r16,zero
 3204710:	20000c16 	blt	r4,zero,3204744 <__divsi3+0x44>
 3204714:	000d883a 	mov	r6,zero
 3204718:	28000e16 	blt	r5,zero,3204754 <__divsi3+0x54>
 320471c:	32046840 	call	3204684 <udivmodsi4>
 3204720:	1007883a 	mov	r3,r2
 3204724:	8005003a 	cmpeq	r2,r16,zero
 3204728:	1000011e 	bne	r2,zero,3204730 <__divsi3+0x30>
 320472c:	00c7c83a 	sub	r3,zero,r3
 3204730:	1805883a 	mov	r2,r3
 3204734:	dfc00117 	ldw	ra,4(sp)
 3204738:	dc000017 	ldw	r16,0(sp)
 320473c:	dec00204 	addi	sp,sp,8
 3204740:	f800283a 	ret
 3204744:	0109c83a 	sub	r4,zero,r4
 3204748:	04000044 	movi	r16,1
 320474c:	000d883a 	mov	r6,zero
 3204750:	283ff20e 	bge	r5,zero,320471c <__divsi3+0x1c>
 3204754:	014bc83a 	sub	r5,zero,r5
 3204758:	8021003a 	cmpeq	r16,r16,zero
 320475c:	003fef06 	br	320471c <__divsi3+0x1c>

03204760 <__modsi3>:
 3204760:	deffff04 	addi	sp,sp,-4
 3204764:	dfc00015 	stw	ra,0(sp)
 3204768:	01800044 	movi	r6,1
 320476c:	2807883a 	mov	r3,r5
 3204770:	20000416 	blt	r4,zero,3204784 <__modsi3+0x24>
 3204774:	28000c16 	blt	r5,zero,32047a8 <__modsi3+0x48>
 3204778:	dfc00017 	ldw	ra,0(sp)
 320477c:	dec00104 	addi	sp,sp,4
 3204780:	32046841 	jmpi	3204684 <udivmodsi4>
 3204784:	0109c83a 	sub	r4,zero,r4
 3204788:	28000b16 	blt	r5,zero,32047b8 <__modsi3+0x58>
 320478c:	180b883a 	mov	r5,r3
 3204790:	01800044 	movi	r6,1
 3204794:	32046840 	call	3204684 <udivmodsi4>
 3204798:	0085c83a 	sub	r2,zero,r2
 320479c:	dfc00017 	ldw	ra,0(sp)
 32047a0:	dec00104 	addi	sp,sp,4
 32047a4:	f800283a 	ret
 32047a8:	014bc83a 	sub	r5,zero,r5
 32047ac:	dfc00017 	ldw	ra,0(sp)
 32047b0:	dec00104 	addi	sp,sp,4
 32047b4:	32046841 	jmpi	3204684 <udivmodsi4>
 32047b8:	0147c83a 	sub	r3,zero,r5
 32047bc:	003ff306 	br	320478c <__modsi3+0x2c>

032047c0 <__udivsi3>:
 32047c0:	000d883a 	mov	r6,zero
 32047c4:	32046841 	jmpi	3204684 <udivmodsi4>

032047c8 <__umodsi3>:
 32047c8:	01800044 	movi	r6,1
 32047cc:	32046841 	jmpi	3204684 <udivmodsi4>

032047d0 <_fclose_r>:
 32047d0:	defffc04 	addi	sp,sp,-16
 32047d4:	dc400115 	stw	r17,4(sp)
 32047d8:	dc000015 	stw	r16,0(sp)
 32047dc:	dfc00315 	stw	ra,12(sp)
 32047e0:	dc800215 	stw	r18,8(sp)
 32047e4:	2821883a 	mov	r16,r5
 32047e8:	2023883a 	mov	r17,r4
 32047ec:	28002926 	beq	r5,zero,3204894 <_fclose_r+0xc4>
 32047f0:	3204b7c0 	call	3204b7c <__sfp_lock_acquire>
 32047f4:	88000226 	beq	r17,zero,3204800 <_fclose_r+0x30>
 32047f8:	88800e17 	ldw	r2,56(r17)
 32047fc:	10002d26 	beq	r2,zero,32048b4 <_fclose_r+0xe4>
 3204800:	8080030f 	ldh	r2,12(r16)
 3204804:	10002226 	beq	r2,zero,3204890 <_fclose_r+0xc0>
 3204808:	8809883a 	mov	r4,r17
 320480c:	800b883a 	mov	r5,r16
 3204810:	32048f40 	call	32048f4 <_fflush_r>
 3204814:	1025883a 	mov	r18,r2
 3204818:	80800b17 	ldw	r2,44(r16)
 320481c:	10000426 	beq	r2,zero,3204830 <_fclose_r+0x60>
 3204820:	81400717 	ldw	r5,28(r16)
 3204824:	8809883a 	mov	r4,r17
 3204828:	103ee83a 	callr	r2
 320482c:	10002a16 	blt	r2,zero,32048d8 <_fclose_r+0x108>
 3204830:	8080030b 	ldhu	r2,12(r16)
 3204834:	1080200c 	andi	r2,r2,128
 3204838:	1000231e 	bne	r2,zero,32048c8 <_fclose_r+0xf8>
 320483c:	81400c17 	ldw	r5,48(r16)
 3204840:	28000526 	beq	r5,zero,3204858 <_fclose_r+0x88>
 3204844:	80801004 	addi	r2,r16,64
 3204848:	28800226 	beq	r5,r2,3204854 <_fclose_r+0x84>
 320484c:	8809883a 	mov	r4,r17
 3204850:	32051100 	call	3205110 <_free_r>
 3204854:	80000c15 	stw	zero,48(r16)
 3204858:	81401117 	ldw	r5,68(r16)
 320485c:	28000326 	beq	r5,zero,320486c <_fclose_r+0x9c>
 3204860:	8809883a 	mov	r4,r17
 3204864:	32051100 	call	3205110 <_free_r>
 3204868:	80001115 	stw	zero,68(r16)
 320486c:	8000030d 	sth	zero,12(r16)
 3204870:	3204b800 	call	3204b80 <__sfp_lock_release>
 3204874:	9005883a 	mov	r2,r18
 3204878:	dfc00317 	ldw	ra,12(sp)
 320487c:	dc800217 	ldw	r18,8(sp)
 3204880:	dc400117 	ldw	r17,4(sp)
 3204884:	dc000017 	ldw	r16,0(sp)
 3204888:	dec00404 	addi	sp,sp,16
 320488c:	f800283a 	ret
 3204890:	3204b800 	call	3204b80 <__sfp_lock_release>
 3204894:	0025883a 	mov	r18,zero
 3204898:	9005883a 	mov	r2,r18
 320489c:	dfc00317 	ldw	ra,12(sp)
 32048a0:	dc800217 	ldw	r18,8(sp)
 32048a4:	dc400117 	ldw	r17,4(sp)
 32048a8:	dc000017 	ldw	r16,0(sp)
 32048ac:	dec00404 	addi	sp,sp,16
 32048b0:	f800283a 	ret
 32048b4:	8809883a 	mov	r4,r17
 32048b8:	3204b8c0 	call	3204b8c <__sinit>
 32048bc:	8080030f 	ldh	r2,12(r16)
 32048c0:	103fd11e 	bne	r2,zero,3204808 <_fclose_r+0x38>
 32048c4:	003ff206 	br	3204890 <_fclose_r+0xc0>
 32048c8:	81400417 	ldw	r5,16(r16)
 32048cc:	8809883a 	mov	r4,r17
 32048d0:	32051100 	call	3205110 <_free_r>
 32048d4:	003fd906 	br	320483c <_fclose_r+0x6c>
 32048d8:	04bfffc4 	movi	r18,-1
 32048dc:	003fd406 	br	3204830 <_fclose_r+0x60>

032048e0 <fclose>:
 32048e0:	0080c974 	movhi	r2,805
 32048e4:	108a6304 	addi	r2,r2,10636
 32048e8:	200b883a 	mov	r5,r4
 32048ec:	11000017 	ldw	r4,0(r2)
 32048f0:	32047d01 	jmpi	32047d0 <_fclose_r>

032048f4 <_fflush_r>:
 32048f4:	defffb04 	addi	sp,sp,-20
 32048f8:	dcc00315 	stw	r19,12(sp)
 32048fc:	dc800215 	stw	r18,8(sp)
 3204900:	dfc00415 	stw	ra,16(sp)
 3204904:	dc400115 	stw	r17,4(sp)
 3204908:	dc000015 	stw	r16,0(sp)
 320490c:	2027883a 	mov	r19,r4
 3204910:	2825883a 	mov	r18,r5
 3204914:	20000226 	beq	r4,zero,3204920 <_fflush_r+0x2c>
 3204918:	20800e17 	ldw	r2,56(r4)
 320491c:	10005626 	beq	r2,zero,3204a78 <_fflush_r+0x184>
 3204920:	9100030b 	ldhu	r4,12(r18)
 3204924:	20ffffcc 	andi	r3,r4,65535
 3204928:	18e0001c 	xori	r3,r3,32768
 320492c:	18e00004 	addi	r3,r3,-32768
 3204930:	1880020c 	andi	r2,r3,8
 3204934:	1000261e 	bne	r2,zero,32049d0 <_fflush_r+0xdc>
 3204938:	90c00117 	ldw	r3,4(r18)
 320493c:	20820014 	ori	r2,r4,2048
 3204940:	9080030d 	sth	r2,12(r18)
 3204944:	1009883a 	mov	r4,r2
 3204948:	00c0400e 	bge	zero,r3,3204a4c <_fflush_r+0x158>
 320494c:	92000a17 	ldw	r8,40(r18)
 3204950:	40004026 	beq	r8,zero,3204a54 <_fflush_r+0x160>
 3204954:	2084000c 	andi	r2,r4,4096
 3204958:	10005326 	beq	r2,zero,3204aa8 <_fflush_r+0x1b4>
 320495c:	94001417 	ldw	r16,80(r18)
 3204960:	9080030b 	ldhu	r2,12(r18)
 3204964:	1080010c 	andi	r2,r2,4
 3204968:	1000481e 	bne	r2,zero,3204a8c <_fflush_r+0x198>
 320496c:	91400717 	ldw	r5,28(r18)
 3204970:	9809883a 	mov	r4,r19
 3204974:	800d883a 	mov	r6,r16
 3204978:	000f883a 	mov	r7,zero
 320497c:	403ee83a 	callr	r8
 3204980:	8080261e 	bne	r16,r2,3204a1c <_fflush_r+0x128>
 3204984:	9080030b 	ldhu	r2,12(r18)
 3204988:	91000417 	ldw	r4,16(r18)
 320498c:	90000115 	stw	zero,4(r18)
 3204990:	10bdffcc 	andi	r2,r2,63487
 3204994:	10ffffcc 	andi	r3,r2,65535
 3204998:	18c4000c 	andi	r3,r3,4096
 320499c:	9080030d 	sth	r2,12(r18)
 32049a0:	91000015 	stw	r4,0(r18)
 32049a4:	18002b26 	beq	r3,zero,3204a54 <_fflush_r+0x160>
 32049a8:	0007883a 	mov	r3,zero
 32049ac:	1805883a 	mov	r2,r3
 32049b0:	94001415 	stw	r16,80(r18)
 32049b4:	dfc00417 	ldw	ra,16(sp)
 32049b8:	dcc00317 	ldw	r19,12(sp)
 32049bc:	dc800217 	ldw	r18,8(sp)
 32049c0:	dc400117 	ldw	r17,4(sp)
 32049c4:	dc000017 	ldw	r16,0(sp)
 32049c8:	dec00504 	addi	sp,sp,20
 32049cc:	f800283a 	ret
 32049d0:	94400417 	ldw	r17,16(r18)
 32049d4:	88001f26 	beq	r17,zero,3204a54 <_fflush_r+0x160>
 32049d8:	90800017 	ldw	r2,0(r18)
 32049dc:	18c000cc 	andi	r3,r3,3
 32049e0:	94400015 	stw	r17,0(r18)
 32049e4:	1461c83a 	sub	r16,r2,r17
 32049e8:	18002526 	beq	r3,zero,3204a80 <_fflush_r+0x18c>
 32049ec:	0005883a 	mov	r2,zero
 32049f0:	90800215 	stw	r2,8(r18)
 32049f4:	0400170e 	bge	zero,r16,3204a54 <_fflush_r+0x160>
 32049f8:	90c00917 	ldw	r3,36(r18)
 32049fc:	91400717 	ldw	r5,28(r18)
 3204a00:	880d883a 	mov	r6,r17
 3204a04:	800f883a 	mov	r7,r16
 3204a08:	9809883a 	mov	r4,r19
 3204a0c:	183ee83a 	callr	r3
 3204a10:	88a3883a 	add	r17,r17,r2
 3204a14:	80a1c83a 	sub	r16,r16,r2
 3204a18:	00bff616 	blt	zero,r2,32049f4 <_fflush_r+0x100>
 3204a1c:	9080030b 	ldhu	r2,12(r18)
 3204a20:	00ffffc4 	movi	r3,-1
 3204a24:	10801014 	ori	r2,r2,64
 3204a28:	9080030d 	sth	r2,12(r18)
 3204a2c:	1805883a 	mov	r2,r3
 3204a30:	dfc00417 	ldw	ra,16(sp)
 3204a34:	dcc00317 	ldw	r19,12(sp)
 3204a38:	dc800217 	ldw	r18,8(sp)
 3204a3c:	dc400117 	ldw	r17,4(sp)
 3204a40:	dc000017 	ldw	r16,0(sp)
 3204a44:	dec00504 	addi	sp,sp,20
 3204a48:	f800283a 	ret
 3204a4c:	90800f17 	ldw	r2,60(r18)
 3204a50:	00bfbe16 	blt	zero,r2,320494c <_fflush_r+0x58>
 3204a54:	0007883a 	mov	r3,zero
 3204a58:	1805883a 	mov	r2,r3
 3204a5c:	dfc00417 	ldw	ra,16(sp)
 3204a60:	dcc00317 	ldw	r19,12(sp)
 3204a64:	dc800217 	ldw	r18,8(sp)
 3204a68:	dc400117 	ldw	r17,4(sp)
 3204a6c:	dc000017 	ldw	r16,0(sp)
 3204a70:	dec00504 	addi	sp,sp,20
 3204a74:	f800283a 	ret
 3204a78:	3204b8c0 	call	3204b8c <__sinit>
 3204a7c:	003fa806 	br	3204920 <_fflush_r+0x2c>
 3204a80:	90800517 	ldw	r2,20(r18)
 3204a84:	90800215 	stw	r2,8(r18)
 3204a88:	003fda06 	br	32049f4 <_fflush_r+0x100>
 3204a8c:	90800117 	ldw	r2,4(r18)
 3204a90:	90c00c17 	ldw	r3,48(r18)
 3204a94:	80a1c83a 	sub	r16,r16,r2
 3204a98:	183fb426 	beq	r3,zero,320496c <_fflush_r+0x78>
 3204a9c:	90800f17 	ldw	r2,60(r18)
 3204aa0:	80a1c83a 	sub	r16,r16,r2
 3204aa4:	003fb106 	br	320496c <_fflush_r+0x78>
 3204aa8:	91400717 	ldw	r5,28(r18)
 3204aac:	9809883a 	mov	r4,r19
 3204ab0:	000d883a 	mov	r6,zero
 3204ab4:	01c00044 	movi	r7,1
 3204ab8:	403ee83a 	callr	r8
 3204abc:	1021883a 	mov	r16,r2
 3204ac0:	00bfffc4 	movi	r2,-1
 3204ac4:	80800226 	beq	r16,r2,3204ad0 <_fflush_r+0x1dc>
 3204ac8:	92000a17 	ldw	r8,40(r18)
 3204acc:	003fa406 	br	3204960 <_fflush_r+0x6c>
 3204ad0:	98c00017 	ldw	r3,0(r19)
 3204ad4:	00800744 	movi	r2,29
 3204ad8:	18bfde26 	beq	r3,r2,3204a54 <_fflush_r+0x160>
 3204adc:	9080030b 	ldhu	r2,12(r18)
 3204ae0:	8007883a 	mov	r3,r16
 3204ae4:	10801014 	ori	r2,r2,64
 3204ae8:	9080030d 	sth	r2,12(r18)
 3204aec:	003fcf06 	br	3204a2c <_fflush_r+0x138>

03204af0 <fflush>:
 3204af0:	0140c834 	movhi	r5,800
 3204af4:	29523d04 	addi	r5,r5,18676
 3204af8:	2007883a 	mov	r3,r4
 3204afc:	20000526 	beq	r4,zero,3204b14 <fflush+0x24>
 3204b00:	0080c974 	movhi	r2,805
 3204b04:	108a6304 	addi	r2,r2,10636
 3204b08:	11000017 	ldw	r4,0(r2)
 3204b0c:	180b883a 	mov	r5,r3
 3204b10:	32048f41 	jmpi	32048f4 <_fflush_r>
 3204b14:	0080c974 	movhi	r2,805
 3204b18:	108a6404 	addi	r2,r2,10640
 3204b1c:	11000017 	ldw	r4,0(r2)
 3204b20:	3205d941 	jmpi	3205d94 <_fwalk_reent>

03204b24 <std>:
 3204b24:	0080c834 	movhi	r2,800
 3204b28:	109eea04 	addi	r2,r2,31656
 3204b2c:	20800b15 	stw	r2,44(r4)
 3204b30:	0080c834 	movhi	r2,800
 3204b34:	109f2504 	addi	r2,r2,31892
 3204b38:	20800815 	stw	r2,32(r4)
 3204b3c:	00c0c834 	movhi	r3,800
 3204b40:	18df0604 	addi	r3,r3,31768
 3204b44:	0080c834 	movhi	r2,800
 3204b48:	109eec04 	addi	r2,r2,31664
 3204b4c:	2140030d 	sth	r5,12(r4)
 3204b50:	2180038d 	sth	r6,14(r4)
 3204b54:	20c00915 	stw	r3,36(r4)
 3204b58:	20800a15 	stw	r2,40(r4)
 3204b5c:	20000015 	stw	zero,0(r4)
 3204b60:	20000115 	stw	zero,4(r4)
 3204b64:	20000215 	stw	zero,8(r4)
 3204b68:	20000415 	stw	zero,16(r4)
 3204b6c:	20000515 	stw	zero,20(r4)
 3204b70:	20000615 	stw	zero,24(r4)
 3204b74:	21000715 	stw	r4,28(r4)
 3204b78:	f800283a 	ret

03204b7c <__sfp_lock_acquire>:
 3204b7c:	f800283a 	ret

03204b80 <__sfp_lock_release>:
 3204b80:	f800283a 	ret

03204b84 <__sinit_lock_acquire>:
 3204b84:	f800283a 	ret

03204b88 <__sinit_lock_release>:
 3204b88:	f800283a 	ret

03204b8c <__sinit>:
 3204b8c:	20800e17 	ldw	r2,56(r4)
 3204b90:	defffd04 	addi	sp,sp,-12
 3204b94:	dc400115 	stw	r17,4(sp)
 3204b98:	dc000015 	stw	r16,0(sp)
 3204b9c:	dfc00215 	stw	ra,8(sp)
 3204ba0:	04400044 	movi	r17,1
 3204ba4:	01400104 	movi	r5,4
 3204ba8:	000d883a 	mov	r6,zero
 3204bac:	2021883a 	mov	r16,r4
 3204bb0:	2200bb04 	addi	r8,r4,748
 3204bb4:	200f883a 	mov	r7,r4
 3204bb8:	10000526 	beq	r2,zero,3204bd0 <__sinit+0x44>
 3204bbc:	dfc00217 	ldw	ra,8(sp)
 3204bc0:	dc400117 	ldw	r17,4(sp)
 3204bc4:	dc000017 	ldw	r16,0(sp)
 3204bc8:	dec00304 	addi	sp,sp,12
 3204bcc:	f800283a 	ret
 3204bd0:	21000117 	ldw	r4,4(r4)
 3204bd4:	0080c834 	movhi	r2,800
 3204bd8:	10931c04 	addi	r2,r2,19568
 3204bdc:	00c000c4 	movi	r3,3
 3204be0:	80800f15 	stw	r2,60(r16)
 3204be4:	80c0b915 	stw	r3,740(r16)
 3204be8:	8200ba15 	stw	r8,744(r16)
 3204bec:	84400e15 	stw	r17,56(r16)
 3204bf0:	8000b815 	stw	zero,736(r16)
 3204bf4:	3204b240 	call	3204b24 <std>
 3204bf8:	81000217 	ldw	r4,8(r16)
 3204bfc:	880d883a 	mov	r6,r17
 3204c00:	800f883a 	mov	r7,r16
 3204c04:	01400284 	movi	r5,10
 3204c08:	3204b240 	call	3204b24 <std>
 3204c0c:	81000317 	ldw	r4,12(r16)
 3204c10:	800f883a 	mov	r7,r16
 3204c14:	01400484 	movi	r5,18
 3204c18:	01800084 	movi	r6,2
 3204c1c:	dfc00217 	ldw	ra,8(sp)
 3204c20:	dc400117 	ldw	r17,4(sp)
 3204c24:	dc000017 	ldw	r16,0(sp)
 3204c28:	dec00304 	addi	sp,sp,12
 3204c2c:	3204b241 	jmpi	3204b24 <std>

03204c30 <__fp_lock>:
 3204c30:	0005883a 	mov	r2,zero
 3204c34:	f800283a 	ret

03204c38 <__fp_unlock>:
 3204c38:	0005883a 	mov	r2,zero
 3204c3c:	f800283a 	ret

03204c40 <__fp_unlock_all>:
 3204c40:	0080c974 	movhi	r2,805
 3204c44:	108a6304 	addi	r2,r2,10636
 3204c48:	11000017 	ldw	r4,0(r2)
 3204c4c:	0140c834 	movhi	r5,800
 3204c50:	29530e04 	addi	r5,r5,19512
 3204c54:	3205e5c1 	jmpi	3205e5c <_fwalk>

03204c58 <__fp_lock_all>:
 3204c58:	0080c974 	movhi	r2,805
 3204c5c:	108a6304 	addi	r2,r2,10636
 3204c60:	11000017 	ldw	r4,0(r2)
 3204c64:	0140c834 	movhi	r5,800
 3204c68:	29530c04 	addi	r5,r5,19504
 3204c6c:	3205e5c1 	jmpi	3205e5c <_fwalk>

03204c70 <_cleanup_r>:
 3204c70:	0140c834 	movhi	r5,800
 3204c74:	29523804 	addi	r5,r5,18656
 3204c78:	3205e5c1 	jmpi	3205e5c <_fwalk>

03204c7c <_cleanup>:
 3204c7c:	0080c974 	movhi	r2,805
 3204c80:	108a6404 	addi	r2,r2,10640
 3204c84:	11000017 	ldw	r4,0(r2)
 3204c88:	3204c701 	jmpi	3204c70 <_cleanup_r>

03204c8c <__sfmoreglue>:
 3204c8c:	defffc04 	addi	sp,sp,-16
 3204c90:	dc400115 	stw	r17,4(sp)
 3204c94:	2c401724 	muli	r17,r5,92
 3204c98:	dc800215 	stw	r18,8(sp)
 3204c9c:	2825883a 	mov	r18,r5
 3204ca0:	89400304 	addi	r5,r17,12
 3204ca4:	dc000015 	stw	r16,0(sp)
 3204ca8:	dfc00315 	stw	ra,12(sp)
 3204cac:	32062ac0 	call	32062ac <_malloc_r>
 3204cb0:	0021883a 	mov	r16,zero
 3204cb4:	880d883a 	mov	r6,r17
 3204cb8:	000b883a 	mov	r5,zero
 3204cbc:	10000626 	beq	r2,zero,3204cd8 <__sfmoreglue+0x4c>
 3204cc0:	11000304 	addi	r4,r2,12
 3204cc4:	14800115 	stw	r18,4(r2)
 3204cc8:	10000015 	stw	zero,0(r2)
 3204ccc:	11000215 	stw	r4,8(r2)
 3204cd0:	1021883a 	mov	r16,r2
 3204cd4:	3206c500 	call	3206c50 <memset>
 3204cd8:	8005883a 	mov	r2,r16
 3204cdc:	dfc00317 	ldw	ra,12(sp)
 3204ce0:	dc800217 	ldw	r18,8(sp)
 3204ce4:	dc400117 	ldw	r17,4(sp)
 3204ce8:	dc000017 	ldw	r16,0(sp)
 3204cec:	dec00404 	addi	sp,sp,16
 3204cf0:	f800283a 	ret

03204cf4 <__sfp>:
 3204cf4:	defffd04 	addi	sp,sp,-12
 3204cf8:	0080c974 	movhi	r2,805
 3204cfc:	108a6404 	addi	r2,r2,10640
 3204d00:	dc000015 	stw	r16,0(sp)
 3204d04:	14000017 	ldw	r16,0(r2)
 3204d08:	dc400115 	stw	r17,4(sp)
 3204d0c:	dfc00215 	stw	ra,8(sp)
 3204d10:	80800e17 	ldw	r2,56(r16)
 3204d14:	2023883a 	mov	r17,r4
 3204d18:	10002626 	beq	r2,zero,3204db4 <__sfp+0xc0>
 3204d1c:	8400b804 	addi	r16,r16,736
 3204d20:	80800117 	ldw	r2,4(r16)
 3204d24:	81000217 	ldw	r4,8(r16)
 3204d28:	10ffffc4 	addi	r3,r2,-1
 3204d2c:	18000916 	blt	r3,zero,3204d54 <__sfp+0x60>
 3204d30:	2080030f 	ldh	r2,12(r4)
 3204d34:	10000b26 	beq	r2,zero,3204d64 <__sfp+0x70>
 3204d38:	017fffc4 	movi	r5,-1
 3204d3c:	00000206 	br	3204d48 <__sfp+0x54>
 3204d40:	2080030f 	ldh	r2,12(r4)
 3204d44:	10000726 	beq	r2,zero,3204d64 <__sfp+0x70>
 3204d48:	18ffffc4 	addi	r3,r3,-1
 3204d4c:	21001704 	addi	r4,r4,92
 3204d50:	197ffb1e 	bne	r3,r5,3204d40 <__sfp+0x4c>
 3204d54:	80800017 	ldw	r2,0(r16)
 3204d58:	10001926 	beq	r2,zero,3204dc0 <__sfp+0xcc>
 3204d5c:	1021883a 	mov	r16,r2
 3204d60:	003fef06 	br	3204d20 <__sfp+0x2c>
 3204d64:	00bfffc4 	movi	r2,-1
 3204d68:	00c00044 	movi	r3,1
 3204d6c:	2080038d 	sth	r2,14(r4)
 3204d70:	20c0030d 	sth	r3,12(r4)
 3204d74:	20000015 	stw	zero,0(r4)
 3204d78:	20000215 	stw	zero,8(r4)
 3204d7c:	20000115 	stw	zero,4(r4)
 3204d80:	20000415 	stw	zero,16(r4)
 3204d84:	20000515 	stw	zero,20(r4)
 3204d88:	20000615 	stw	zero,24(r4)
 3204d8c:	20000c15 	stw	zero,48(r4)
 3204d90:	20000d15 	stw	zero,52(r4)
 3204d94:	20001115 	stw	zero,68(r4)
 3204d98:	20001215 	stw	zero,72(r4)
 3204d9c:	2005883a 	mov	r2,r4
 3204da0:	dfc00217 	ldw	ra,8(sp)
 3204da4:	dc400117 	ldw	r17,4(sp)
 3204da8:	dc000017 	ldw	r16,0(sp)
 3204dac:	dec00304 	addi	sp,sp,12
 3204db0:	f800283a 	ret
 3204db4:	8009883a 	mov	r4,r16
 3204db8:	3204b8c0 	call	3204b8c <__sinit>
 3204dbc:	003fd706 	br	3204d1c <__sfp+0x28>
 3204dc0:	8809883a 	mov	r4,r17
 3204dc4:	01400104 	movi	r5,4
 3204dc8:	3204c8c0 	call	3204c8c <__sfmoreglue>
 3204dcc:	80800015 	stw	r2,0(r16)
 3204dd0:	103fe21e 	bne	r2,zero,3204d5c <__sfp+0x68>
 3204dd4:	00800304 	movi	r2,12
 3204dd8:	0009883a 	mov	r4,zero
 3204ddc:	88800015 	stw	r2,0(r17)
 3204de0:	003fee06 	br	3204d9c <__sfp+0xa8>

03204de4 <_fopen_r>:
 3204de4:	defffa04 	addi	sp,sp,-24
 3204de8:	dcc00415 	stw	r19,16(sp)
 3204dec:	2827883a 	mov	r19,r5
 3204df0:	300b883a 	mov	r5,r6
 3204df4:	d80d883a 	mov	r6,sp
 3204df8:	dc800315 	stw	r18,12(sp)
 3204dfc:	dc400215 	stw	r17,8(sp)
 3204e00:	dc000115 	stw	r16,4(sp)
 3204e04:	dfc00515 	stw	ra,20(sp)
 3204e08:	2021883a 	mov	r16,r4
 3204e0c:	320d6a80 	call	320d6a8 <__sflags>
 3204e10:	1025883a 	mov	r18,r2
 3204e14:	8009883a 	mov	r4,r16
 3204e18:	0023883a 	mov	r17,zero
 3204e1c:	1000081e 	bne	r2,zero,3204e40 <_fopen_r+0x5c>
 3204e20:	8805883a 	mov	r2,r17
 3204e24:	dfc00517 	ldw	ra,20(sp)
 3204e28:	dcc00417 	ldw	r19,16(sp)
 3204e2c:	dc800317 	ldw	r18,12(sp)
 3204e30:	dc400217 	ldw	r17,8(sp)
 3204e34:	dc000117 	ldw	r16,4(sp)
 3204e38:	dec00604 	addi	sp,sp,24
 3204e3c:	f800283a 	ret
 3204e40:	3204cf40 	call	3204cf4 <__sfp>
 3204e44:	1023883a 	mov	r17,r2
 3204e48:	980b883a 	mov	r5,r19
 3204e4c:	8009883a 	mov	r4,r16
 3204e50:	01c06d84 	movi	r7,438
 3204e54:	103ff226 	beq	r2,zero,3204e20 <_fopen_r+0x3c>
 3204e58:	d9800017 	ldw	r6,0(sp)
 3204e5c:	3206ce80 	call	3206ce8 <_open_r>
 3204e60:	10001816 	blt	r2,zero,3204ec4 <_fopen_r+0xe0>
 3204e64:	00c0c834 	movhi	r3,800
 3204e68:	18df0604 	addi	r3,r3,31768
 3204e6c:	923fffcc 	andi	r8,r18,65535
 3204e70:	8880038d 	sth	r2,14(r17)
 3204e74:	0080c834 	movhi	r2,800
 3204e78:	109f2504 	addi	r2,r2,31892
 3204e7c:	88800815 	stw	r2,32(r17)
 3204e80:	88c00915 	stw	r3,36(r17)
 3204e84:	0080c834 	movhi	r2,800
 3204e88:	109eec04 	addi	r2,r2,31664
 3204e8c:	00c0c834 	movhi	r3,800
 3204e90:	18deea04 	addi	r3,r3,31656
 3204e94:	4200400c 	andi	r8,r8,256
 3204e98:	8c80030d 	sth	r18,12(r17)
 3204e9c:	8009883a 	mov	r4,r16
 3204ea0:	880b883a 	mov	r5,r17
 3204ea4:	000d883a 	mov	r6,zero
 3204ea8:	01c00084 	movi	r7,2
 3204eac:	88800a15 	stw	r2,40(r17)
 3204eb0:	88c00b15 	stw	r3,44(r17)
 3204eb4:	8c400715 	stw	r17,28(r17)
 3204eb8:	403fd926 	beq	r8,zero,3204e20 <_fopen_r+0x3c>
 3204ebc:	32054240 	call	3205424 <_fseek_r>
 3204ec0:	003fd706 	br	3204e20 <_fopen_r+0x3c>
 3204ec4:	3204b7c0 	call	3204b7c <__sfp_lock_acquire>
 3204ec8:	8800030d 	sth	zero,12(r17)
 3204ecc:	3204b800 	call	3204b80 <__sfp_lock_release>
 3204ed0:	0023883a 	mov	r17,zero
 3204ed4:	003fd206 	br	3204e20 <_fopen_r+0x3c>

03204ed8 <fopen>:
 3204ed8:	0180c974 	movhi	r6,805
 3204edc:	318a6304 	addi	r6,r6,10636
 3204ee0:	2007883a 	mov	r3,r4
 3204ee4:	31000017 	ldw	r4,0(r6)
 3204ee8:	280d883a 	mov	r6,r5
 3204eec:	180b883a 	mov	r5,r3
 3204ef0:	3204de41 	jmpi	3204de4 <_fopen_r>

03204ef4 <fprintf>:
 3204ef4:	defffc04 	addi	sp,sp,-16
 3204ef8:	dfc00115 	stw	ra,4(sp)
 3204efc:	d9800215 	stw	r6,8(sp)
 3204f00:	d9c00315 	stw	r7,12(sp)
 3204f04:	d8800204 	addi	r2,sp,8
 3204f08:	100d883a 	mov	r6,r2
 3204f0c:	d8800015 	stw	r2,0(sp)
 3204f10:	320a3c80 	call	320a3c8 <__vfprintf_internal>
 3204f14:	dfc00117 	ldw	ra,4(sp)
 3204f18:	dec00404 	addi	sp,sp,16
 3204f1c:	f800283a 	ret

03204f20 <_fprintf_r>:
 3204f20:	defffd04 	addi	sp,sp,-12
 3204f24:	2807883a 	mov	r3,r5
 3204f28:	dfc00115 	stw	ra,4(sp)
 3204f2c:	d9c00215 	stw	r7,8(sp)
 3204f30:	d8800204 	addi	r2,sp,8
 3204f34:	300b883a 	mov	r5,r6
 3204f38:	1809883a 	mov	r4,r3
 3204f3c:	100d883a 	mov	r6,r2
 3204f40:	d8800015 	stw	r2,0(sp)
 3204f44:	320a3c80 	call	320a3c8 <__vfprintf_internal>
 3204f48:	dfc00117 	ldw	ra,4(sp)
 3204f4c:	dec00304 	addi	sp,sp,12
 3204f50:	f800283a 	ret

03204f54 <_fputs_r>:
 3204f54:	defff804 	addi	sp,sp,-32
 3204f58:	dc000515 	stw	r16,20(sp)
 3204f5c:	2021883a 	mov	r16,r4
 3204f60:	2809883a 	mov	r4,r5
 3204f64:	dc400615 	stw	r17,24(sp)
 3204f68:	dfc00715 	stw	ra,28(sp)
 3204f6c:	3023883a 	mov	r17,r6
 3204f70:	d9400015 	stw	r5,0(sp)
 3204f74:	32084480 	call	3208448 <strlen>
 3204f78:	00c00044 	movi	r3,1
 3204f7c:	d8800115 	stw	r2,4(sp)
 3204f80:	d8c00315 	stw	r3,12(sp)
 3204f84:	d8800415 	stw	r2,16(sp)
 3204f88:	dec00215 	stw	sp,8(sp)
 3204f8c:	80000326 	beq	r16,zero,3204f9c <_fputs_r+0x48>
 3204f90:	80800e17 	ldw	r2,56(r16)
 3204f94:	8009883a 	mov	r4,r16
 3204f98:	10000926 	beq	r2,zero,3204fc0 <_fputs_r+0x6c>
 3204f9c:	8009883a 	mov	r4,r16
 3204fa0:	880b883a 	mov	r5,r17
 3204fa4:	d9800204 	addi	r6,sp,8
 3204fa8:	32058f80 	call	32058f8 <__sfvwrite_r>
 3204fac:	dfc00717 	ldw	ra,28(sp)
 3204fb0:	dc400617 	ldw	r17,24(sp)
 3204fb4:	dc000517 	ldw	r16,20(sp)
 3204fb8:	dec00804 	addi	sp,sp,32
 3204fbc:	f800283a 	ret
 3204fc0:	3204b8c0 	call	3204b8c <__sinit>
 3204fc4:	003ff506 	br	3204f9c <_fputs_r+0x48>

03204fc8 <fputs>:
 3204fc8:	0180c974 	movhi	r6,805
 3204fcc:	318a6304 	addi	r6,r6,10636
 3204fd0:	2007883a 	mov	r3,r4
 3204fd4:	31000017 	ldw	r4,0(r6)
 3204fd8:	280d883a 	mov	r6,r5
 3204fdc:	180b883a 	mov	r5,r3
 3204fe0:	3204f541 	jmpi	3204f54 <_fputs_r>

03204fe4 <_malloc_trim_r>:
 3204fe4:	defffb04 	addi	sp,sp,-20
 3204fe8:	dcc00315 	stw	r19,12(sp)
 3204fec:	04c0c974 	movhi	r19,805
 3204ff0:	9cc38504 	addi	r19,r19,3604
 3204ff4:	dc800215 	stw	r18,8(sp)
 3204ff8:	dc400115 	stw	r17,4(sp)
 3204ffc:	dc000015 	stw	r16,0(sp)
 3205000:	2823883a 	mov	r17,r5
 3205004:	2025883a 	mov	r18,r4
 3205008:	dfc00415 	stw	ra,16(sp)
 320500c:	32153700 	call	3215370 <__malloc_lock>
 3205010:	98800217 	ldw	r2,8(r19)
 3205014:	9009883a 	mov	r4,r18
 3205018:	000b883a 	mov	r5,zero
 320501c:	10c00117 	ldw	r3,4(r2)
 3205020:	00bfff04 	movi	r2,-4
 3205024:	18a0703a 	and	r16,r3,r2
 3205028:	8463c83a 	sub	r17,r16,r17
 320502c:	8c43fbc4 	addi	r17,r17,4079
 3205030:	8822d33a 	srli	r17,r17,12
 3205034:	0083ffc4 	movi	r2,4095
 3205038:	8c7fffc4 	addi	r17,r17,-1
 320503c:	8822933a 	slli	r17,r17,12
 3205040:	1440060e 	bge	r2,r17,320505c <_malloc_trim_r+0x78>
 3205044:	32079500 	call	3207950 <_sbrk_r>
 3205048:	98c00217 	ldw	r3,8(r19)
 320504c:	9009883a 	mov	r4,r18
 3205050:	044bc83a 	sub	r5,zero,r17
 3205054:	80c7883a 	add	r3,r16,r3
 3205058:	10c00926 	beq	r2,r3,3205080 <_malloc_trim_r+0x9c>
 320505c:	32154780 	call	3215478 <__malloc_unlock>
 3205060:	0005883a 	mov	r2,zero
 3205064:	dfc00417 	ldw	ra,16(sp)
 3205068:	dcc00317 	ldw	r19,12(sp)
 320506c:	dc800217 	ldw	r18,8(sp)
 3205070:	dc400117 	ldw	r17,4(sp)
 3205074:	dc000017 	ldw	r16,0(sp)
 3205078:	dec00504 	addi	sp,sp,20
 320507c:	f800283a 	ret
 3205080:	9009883a 	mov	r4,r18
 3205084:	32079500 	call	3207950 <_sbrk_r>
 3205088:	844dc83a 	sub	r6,r16,r17
 320508c:	00ffffc4 	movi	r3,-1
 3205090:	9009883a 	mov	r4,r18
 3205094:	000b883a 	mov	r5,zero
 3205098:	01c0c974 	movhi	r7,805
 320509c:	39d57b04 	addi	r7,r7,21996
 32050a0:	31800054 	ori	r6,r6,1
 32050a4:	10c00926 	beq	r2,r3,32050cc <_malloc_trim_r+0xe8>
 32050a8:	38800017 	ldw	r2,0(r7)
 32050ac:	98c00217 	ldw	r3,8(r19)
 32050b0:	9009883a 	mov	r4,r18
 32050b4:	1445c83a 	sub	r2,r2,r17
 32050b8:	38800015 	stw	r2,0(r7)
 32050bc:	19800115 	stw	r6,4(r3)
 32050c0:	32154780 	call	3215478 <__malloc_unlock>
 32050c4:	00800044 	movi	r2,1
 32050c8:	003fe606 	br	3205064 <_malloc_trim_r+0x80>
 32050cc:	32079500 	call	3207950 <_sbrk_r>
 32050d0:	99800217 	ldw	r6,8(r19)
 32050d4:	100f883a 	mov	r7,r2
 32050d8:	9009883a 	mov	r4,r18
 32050dc:	1187c83a 	sub	r3,r2,r6
 32050e0:	008003c4 	movi	r2,15
 32050e4:	19400054 	ori	r5,r3,1
 32050e8:	10ffdc0e 	bge	r2,r3,320505c <_malloc_trim_r+0x78>
 32050ec:	0080c974 	movhi	r2,805
 32050f0:	108a6604 	addi	r2,r2,10648
 32050f4:	10c00017 	ldw	r3,0(r2)
 32050f8:	0080c974 	movhi	r2,805
 32050fc:	10957b04 	addi	r2,r2,21996
 3205100:	31400115 	stw	r5,4(r6)
 3205104:	38c7c83a 	sub	r3,r7,r3
 3205108:	10c00015 	stw	r3,0(r2)
 320510c:	003fd306 	br	320505c <_malloc_trim_r+0x78>

03205110 <_free_r>:
 3205110:	defffd04 	addi	sp,sp,-12
 3205114:	dc400115 	stw	r17,4(sp)
 3205118:	dc000015 	stw	r16,0(sp)
 320511c:	dfc00215 	stw	ra,8(sp)
 3205120:	2821883a 	mov	r16,r5
 3205124:	2023883a 	mov	r17,r4
 3205128:	28005a26 	beq	r5,zero,3205294 <_free_r+0x184>
 320512c:	32153700 	call	3215370 <__malloc_lock>
 3205130:	823ffe04 	addi	r8,r16,-8
 3205134:	41400117 	ldw	r5,4(r8)
 3205138:	00bfff84 	movi	r2,-2
 320513c:	0280c974 	movhi	r10,805
 3205140:	52838504 	addi	r10,r10,3604
 3205144:	288e703a 	and	r7,r5,r2
 3205148:	41cd883a 	add	r6,r8,r7
 320514c:	30c00117 	ldw	r3,4(r6)
 3205150:	51000217 	ldw	r4,8(r10)
 3205154:	00bfff04 	movi	r2,-4
 3205158:	1892703a 	and	r9,r3,r2
 320515c:	5017883a 	mov	r11,r10
 3205160:	31006726 	beq	r6,r4,3205300 <_free_r+0x1f0>
 3205164:	2880004c 	andi	r2,r5,1
 3205168:	1005003a 	cmpeq	r2,r2,zero
 320516c:	32400115 	stw	r9,4(r6)
 3205170:	10001a1e 	bne	r2,zero,32051dc <_free_r+0xcc>
 3205174:	000b883a 	mov	r5,zero
 3205178:	3247883a 	add	r3,r6,r9
 320517c:	18800117 	ldw	r2,4(r3)
 3205180:	1080004c 	andi	r2,r2,1
 3205184:	1000231e 	bne	r2,zero,3205214 <_free_r+0x104>
 3205188:	280ac03a 	cmpne	r5,r5,zero
 320518c:	3a4f883a 	add	r7,r7,r9
 3205190:	2800451e 	bne	r5,zero,32052a8 <_free_r+0x198>
 3205194:	31000217 	ldw	r4,8(r6)
 3205198:	0080c974 	movhi	r2,805
 320519c:	10838704 	addi	r2,r2,3612
 32051a0:	20807b26 	beq	r4,r2,3205390 <_free_r+0x280>
 32051a4:	30800317 	ldw	r2,12(r6)
 32051a8:	3a07883a 	add	r3,r7,r8
 32051ac:	19c00015 	stw	r7,0(r3)
 32051b0:	11000215 	stw	r4,8(r2)
 32051b4:	20800315 	stw	r2,12(r4)
 32051b8:	38800054 	ori	r2,r7,1
 32051bc:	40800115 	stw	r2,4(r8)
 32051c0:	28001a26 	beq	r5,zero,320522c <_free_r+0x11c>
 32051c4:	8809883a 	mov	r4,r17
 32051c8:	dfc00217 	ldw	ra,8(sp)
 32051cc:	dc400117 	ldw	r17,4(sp)
 32051d0:	dc000017 	ldw	r16,0(sp)
 32051d4:	dec00304 	addi	sp,sp,12
 32051d8:	32154781 	jmpi	3215478 <__malloc_unlock>
 32051dc:	80bffe17 	ldw	r2,-8(r16)
 32051e0:	50c00204 	addi	r3,r10,8
 32051e4:	4091c83a 	sub	r8,r8,r2
 32051e8:	41000217 	ldw	r4,8(r8)
 32051ec:	388f883a 	add	r7,r7,r2
 32051f0:	20c06126 	beq	r4,r3,3205378 <_free_r+0x268>
 32051f4:	40800317 	ldw	r2,12(r8)
 32051f8:	3247883a 	add	r3,r6,r9
 32051fc:	000b883a 	mov	r5,zero
 3205200:	11000215 	stw	r4,8(r2)
 3205204:	20800315 	stw	r2,12(r4)
 3205208:	18800117 	ldw	r2,4(r3)
 320520c:	1080004c 	andi	r2,r2,1
 3205210:	103fdd26 	beq	r2,zero,3205188 <_free_r+0x78>
 3205214:	38800054 	ori	r2,r7,1
 3205218:	3a07883a 	add	r3,r7,r8
 320521c:	280ac03a 	cmpne	r5,r5,zero
 3205220:	40800115 	stw	r2,4(r8)
 3205224:	19c00015 	stw	r7,0(r3)
 3205228:	283fe61e 	bne	r5,zero,32051c4 <_free_r+0xb4>
 320522c:	00807fc4 	movi	r2,511
 3205230:	11c01f2e 	bgeu	r2,r7,32052b0 <_free_r+0x1a0>
 3205234:	3806d27a 	srli	r3,r7,9
 3205238:	1800481e 	bne	r3,zero,320535c <_free_r+0x24c>
 320523c:	3804d0fa 	srli	r2,r7,3
 3205240:	100690fa 	slli	r3,r2,3
 3205244:	1acd883a 	add	r6,r3,r11
 3205248:	31400217 	ldw	r5,8(r6)
 320524c:	31405926 	beq	r6,r5,32053b4 <_free_r+0x2a4>
 3205250:	28800117 	ldw	r2,4(r5)
 3205254:	00ffff04 	movi	r3,-4
 3205258:	10c4703a 	and	r2,r2,r3
 320525c:	3880022e 	bgeu	r7,r2,3205268 <_free_r+0x158>
 3205260:	29400217 	ldw	r5,8(r5)
 3205264:	317ffa1e 	bne	r6,r5,3205250 <_free_r+0x140>
 3205268:	29800317 	ldw	r6,12(r5)
 320526c:	41800315 	stw	r6,12(r8)
 3205270:	41400215 	stw	r5,8(r8)
 3205274:	8809883a 	mov	r4,r17
 3205278:	2a000315 	stw	r8,12(r5)
 320527c:	32000215 	stw	r8,8(r6)
 3205280:	dfc00217 	ldw	ra,8(sp)
 3205284:	dc400117 	ldw	r17,4(sp)
 3205288:	dc000017 	ldw	r16,0(sp)
 320528c:	dec00304 	addi	sp,sp,12
 3205290:	32154781 	jmpi	3215478 <__malloc_unlock>
 3205294:	dfc00217 	ldw	ra,8(sp)
 3205298:	dc400117 	ldw	r17,4(sp)
 320529c:	dc000017 	ldw	r16,0(sp)
 32052a0:	dec00304 	addi	sp,sp,12
 32052a4:	f800283a 	ret
 32052a8:	31000217 	ldw	r4,8(r6)
 32052ac:	003fbd06 	br	32051a4 <_free_r+0x94>
 32052b0:	3806d0fa 	srli	r3,r7,3
 32052b4:	00800044 	movi	r2,1
 32052b8:	51400117 	ldw	r5,4(r10)
 32052bc:	180890fa 	slli	r4,r3,3
 32052c0:	1807d0ba 	srai	r3,r3,2
 32052c4:	22c9883a 	add	r4,r4,r11
 32052c8:	21800217 	ldw	r6,8(r4)
 32052cc:	10c4983a 	sll	r2,r2,r3
 32052d0:	41000315 	stw	r4,12(r8)
 32052d4:	41800215 	stw	r6,8(r8)
 32052d8:	288ab03a 	or	r5,r5,r2
 32052dc:	22000215 	stw	r8,8(r4)
 32052e0:	8809883a 	mov	r4,r17
 32052e4:	51400115 	stw	r5,4(r10)
 32052e8:	32000315 	stw	r8,12(r6)
 32052ec:	dfc00217 	ldw	ra,8(sp)
 32052f0:	dc400117 	ldw	r17,4(sp)
 32052f4:	dc000017 	ldw	r16,0(sp)
 32052f8:	dec00304 	addi	sp,sp,12
 32052fc:	32154781 	jmpi	3215478 <__malloc_unlock>
 3205300:	2880004c 	andi	r2,r5,1
 3205304:	3a4d883a 	add	r6,r7,r9
 3205308:	1000071e 	bne	r2,zero,3205328 <_free_r+0x218>
 320530c:	80bffe17 	ldw	r2,-8(r16)
 3205310:	4091c83a 	sub	r8,r8,r2
 3205314:	41000317 	ldw	r4,12(r8)
 3205318:	40c00217 	ldw	r3,8(r8)
 320531c:	308d883a 	add	r6,r6,r2
 3205320:	20c00215 	stw	r3,8(r4)
 3205324:	19000315 	stw	r4,12(r3)
 3205328:	0080c974 	movhi	r2,805
 320532c:	108a6504 	addi	r2,r2,10644
 3205330:	11000017 	ldw	r4,0(r2)
 3205334:	30c00054 	ori	r3,r6,1
 3205338:	52000215 	stw	r8,8(r10)
 320533c:	40c00115 	stw	r3,4(r8)
 3205340:	313fa036 	bltu	r6,r4,32051c4 <_free_r+0xb4>
 3205344:	0080c974 	movhi	r2,805
 3205348:	1092f904 	addi	r2,r2,19428
 320534c:	11400017 	ldw	r5,0(r2)
 3205350:	8809883a 	mov	r4,r17
 3205354:	3204fe40 	call	3204fe4 <_malloc_trim_r>
 3205358:	003f9a06 	br	32051c4 <_free_r+0xb4>
 320535c:	00800104 	movi	r2,4
 3205360:	10c0072e 	bgeu	r2,r3,3205380 <_free_r+0x270>
 3205364:	00800504 	movi	r2,20
 3205368:	10c01936 	bltu	r2,r3,32053d0 <_free_r+0x2c0>
 320536c:	188016c4 	addi	r2,r3,91
 3205370:	100690fa 	slli	r3,r2,3
 3205374:	003fb306 	br	3205244 <_free_r+0x134>
 3205378:	01400044 	movi	r5,1
 320537c:	003f7e06 	br	3205178 <_free_r+0x68>
 3205380:	3804d1ba 	srli	r2,r7,6
 3205384:	10800e04 	addi	r2,r2,56
 3205388:	100690fa 	slli	r3,r2,3
 320538c:	003fad06 	br	3205244 <_free_r+0x134>
 3205390:	22000315 	stw	r8,12(r4)
 3205394:	22000215 	stw	r8,8(r4)
 3205398:	3a05883a 	add	r2,r7,r8
 320539c:	38c00054 	ori	r3,r7,1
 32053a0:	11c00015 	stw	r7,0(r2)
 32053a4:	41000215 	stw	r4,8(r8)
 32053a8:	40c00115 	stw	r3,4(r8)
 32053ac:	41000315 	stw	r4,12(r8)
 32053b0:	003f8406 	br	32051c4 <_free_r+0xb4>
 32053b4:	1005d0ba 	srai	r2,r2,2
 32053b8:	00c00044 	movi	r3,1
 32053bc:	51000117 	ldw	r4,4(r10)
 32053c0:	1886983a 	sll	r3,r3,r2
 32053c4:	20c8b03a 	or	r4,r4,r3
 32053c8:	51000115 	stw	r4,4(r10)
 32053cc:	003fa706 	br	320526c <_free_r+0x15c>
 32053d0:	00801504 	movi	r2,84
 32053d4:	10c00436 	bltu	r2,r3,32053e8 <_free_r+0x2d8>
 32053d8:	3804d33a 	srli	r2,r7,12
 32053dc:	10801b84 	addi	r2,r2,110
 32053e0:	100690fa 	slli	r3,r2,3
 32053e4:	003f9706 	br	3205244 <_free_r+0x134>
 32053e8:	00805504 	movi	r2,340
 32053ec:	10c00436 	bltu	r2,r3,3205400 <_free_r+0x2f0>
 32053f0:	3804d3fa 	srli	r2,r7,15
 32053f4:	10801dc4 	addi	r2,r2,119
 32053f8:	100690fa 	slli	r3,r2,3
 32053fc:	003f9106 	br	3205244 <_free_r+0x134>
 3205400:	00815504 	movi	r2,1364
 3205404:	10c0032e 	bgeu	r2,r3,3205414 <_free_r+0x304>
 3205408:	00801f84 	movi	r2,126
 320540c:	00c0fc04 	movi	r3,1008
 3205410:	003f8c06 	br	3205244 <_free_r+0x134>
 3205414:	3804d4ba 	srli	r2,r7,18
 3205418:	10801f04 	addi	r2,r2,124
 320541c:	100690fa 	slli	r3,r2,3
 3205420:	003f8806 	br	3205244 <_free_r+0x134>

03205424 <_fseek_r>:
 3205424:	deffe804 	addi	sp,sp,-96
 3205428:	dd801515 	stw	r22,84(sp)
 320542c:	dcc01215 	stw	r19,72(sp)
 3205430:	dc801115 	stw	r18,68(sp)
 3205434:	dc000f15 	stw	r16,60(sp)
 3205438:	dfc01715 	stw	ra,92(sp)
 320543c:	ddc01615 	stw	r23,88(sp)
 3205440:	dd401415 	stw	r21,80(sp)
 3205444:	dd001315 	stw	r20,76(sp)
 3205448:	dc401015 	stw	r17,64(sp)
 320544c:	2025883a 	mov	r18,r4
 3205450:	2821883a 	mov	r16,r5
 3205454:	302d883a 	mov	r22,r6
 3205458:	3827883a 	mov	r19,r7
 320545c:	20000226 	beq	r4,zero,3205468 <_fseek_r+0x44>
 3205460:	20800e17 	ldw	r2,56(r4)
 3205464:	10007826 	beq	r2,zero,3205648 <_fseek_r+0x224>
 3205468:	8080030b 	ldhu	r2,12(r16)
 320546c:	00c04204 	movi	r3,264
 3205470:	1080420c 	andi	r2,r2,264
 3205474:	10c07926 	beq	r2,r3,320565c <_fseek_r+0x238>
 3205478:	85400a17 	ldw	r21,40(r16)
 320547c:	a800ea26 	beq	r21,zero,3205828 <_fseek_r+0x404>
 3205480:	00800044 	movi	r2,1
 3205484:	98805f26 	beq	r19,r2,3205604 <_fseek_r+0x1e0>
 3205488:	00800084 	movi	r2,2
 320548c:	98801026 	beq	r19,r2,32054d0 <_fseek_r+0xac>
 3205490:	98000f26 	beq	r19,zero,32054d0 <_fseek_r+0xac>
 3205494:	00800584 	movi	r2,22
 3205498:	013fffc4 	movi	r4,-1
 320549c:	90800015 	stw	r2,0(r18)
 32054a0:	2005883a 	mov	r2,r4
 32054a4:	dfc01717 	ldw	ra,92(sp)
 32054a8:	ddc01617 	ldw	r23,88(sp)
 32054ac:	dd801517 	ldw	r22,84(sp)
 32054b0:	dd401417 	ldw	r21,80(sp)
 32054b4:	dd001317 	ldw	r20,76(sp)
 32054b8:	dcc01217 	ldw	r19,72(sp)
 32054bc:	dc801117 	ldw	r18,68(sp)
 32054c0:	dc401017 	ldw	r17,64(sp)
 32054c4:	dc000f17 	ldw	r16,60(sp)
 32054c8:	dec01804 	addi	sp,sp,96
 32054cc:	f800283a 	ret
 32054d0:	81800417 	ldw	r6,16(r16)
 32054d4:	0023883a 	mov	r17,zero
 32054d8:	002f883a 	mov	r23,zero
 32054dc:	3000a626 	beq	r6,zero,3205778 <_fseek_r+0x354>
 32054e0:	8100030b 	ldhu	r4,12(r16)
 32054e4:	2082068c 	andi	r2,r4,2074
 32054e8:	1000081e 	bne	r2,zero,320550c <_fseek_r+0xe8>
 32054ec:	2081000c 	andi	r2,r4,1024
 32054f0:	10001b1e 	bne	r2,zero,3205560 <_fseek_r+0x13c>
 32054f4:	0080c834 	movhi	r2,800
 32054f8:	109eec04 	addi	r2,r2,31664
 32054fc:	a8800926 	beq	r21,r2,3205524 <_fseek_r+0x100>
 3205500:	8080030b 	ldhu	r2,12(r16)
 3205504:	10820014 	ori	r2,r2,2048
 3205508:	8080030d 	sth	r2,12(r16)
 320550c:	9009883a 	mov	r4,r18
 3205510:	800b883a 	mov	r5,r16
 3205514:	32048f40 	call	32048f4 <_fflush_r>
 3205518:	1000a326 	beq	r2,zero,32057a8 <_fseek_r+0x384>
 320551c:	013fffc4 	movi	r4,-1
 3205520:	003fdf06 	br	32054a0 <_fseek_r+0x7c>
 3205524:	8140038f 	ldh	r5,14(r16)
 3205528:	283ff516 	blt	r5,zero,3205500 <_fseek_r+0xdc>
 320552c:	9009883a 	mov	r4,r18
 3205530:	d80d883a 	mov	r6,sp
 3205534:	32058840 	call	3205884 <_fstat_r>
 3205538:	103ff11e 	bne	r2,zero,3205500 <_fseek_r+0xdc>
 320553c:	d8800117 	ldw	r2,4(sp)
 3205540:	00e00014 	movui	r3,32768
 3205544:	10bc000c 	andi	r2,r2,61440
 3205548:	10ffed1e 	bne	r2,r3,3205500 <_fseek_r+0xdc>
 320554c:	80c0030b 	ldhu	r3,12(r16)
 3205550:	00810004 	movi	r2,1024
 3205554:	80801315 	stw	r2,76(r16)
 3205558:	1886b03a 	or	r3,r3,r2
 320555c:	80c0030d 	sth	r3,12(r16)
 3205560:	9800701e 	bne	r19,zero,3205724 <_fseek_r+0x300>
 3205564:	b029883a 	mov	r20,r22
 3205568:	b804c03a 	cmpne	r2,r23,zero
 320556c:	10003f1e 	bne	r2,zero,320566c <_fseek_r+0x248>
 3205570:	8100030b 	ldhu	r4,12(r16)
 3205574:	2084000c 	andi	r2,r4,4096
 3205578:	1000a126 	beq	r2,zero,3205800 <_fseek_r+0x3dc>
 320557c:	81801417 	ldw	r6,80(r16)
 3205580:	80c00117 	ldw	r3,4(r16)
 3205584:	81400c17 	ldw	r5,48(r16)
 3205588:	30e3c83a 	sub	r17,r6,r3
 320558c:	28008026 	beq	r5,zero,3205790 <_fseek_r+0x36c>
 3205590:	81c00f17 	ldw	r7,60(r16)
 3205594:	89e3c83a 	sub	r17,r17,r7
 3205598:	80800e17 	ldw	r2,56(r16)
 320559c:	81800417 	ldw	r6,16(r16)
 32055a0:	88c7883a 	add	r3,r17,r3
 32055a4:	1185c83a 	sub	r2,r2,r6
 32055a8:	11cf883a 	add	r7,r2,r7
 32055ac:	1887c83a 	sub	r3,r3,r2
 32055b0:	2088000c 	andi	r2,r4,8192
 32055b4:	10003e1e 	bne	r2,zero,32056b0 <_fseek_r+0x28c>
 32055b8:	a0c03d16 	blt	r20,r3,32056b0 <_fseek_r+0x28c>
 32055bc:	38c5883a 	add	r2,r7,r3
 32055c0:	a0803b2e 	bgeu	r20,r2,32056b0 <_fseek_r+0x28c>
 32055c4:	a0c5c83a 	sub	r2,r20,r3
 32055c8:	3887c83a 	sub	r3,r7,r2
 32055cc:	3085883a 	add	r2,r6,r2
 32055d0:	80800015 	stw	r2,0(r16)
 32055d4:	80c00115 	stw	r3,4(r16)
 32055d8:	28000526 	beq	r5,zero,32055f0 <_fseek_r+0x1cc>
 32055dc:	80801004 	addi	r2,r16,64
 32055e0:	28800226 	beq	r5,r2,32055ec <_fseek_r+0x1c8>
 32055e4:	9009883a 	mov	r4,r18
 32055e8:	32051100 	call	3205110 <_free_r>
 32055ec:	80000c15 	stw	zero,48(r16)
 32055f0:	8080030b 	ldhu	r2,12(r16)
 32055f4:	0009883a 	mov	r4,zero
 32055f8:	10bff7cc 	andi	r2,r2,65503
 32055fc:	8080030d 	sth	r2,12(r16)
 3205600:	003fa706 	br	32054a0 <_fseek_r+0x7c>
 3205604:	9009883a 	mov	r4,r18
 3205608:	800b883a 	mov	r5,r16
 320560c:	32048f40 	call	32048f4 <_fflush_r>
 3205610:	8100030b 	ldhu	r4,12(r16)
 3205614:	2084000c 	andi	r2,r4,4096
 3205618:	10008726 	beq	r2,zero,3205838 <_fseek_r+0x414>
 320561c:	84401417 	ldw	r17,80(r16)
 3205620:	2080010c 	andi	r2,r4,4
 3205624:	1000171e 	bne	r2,zero,3205684 <_fseek_r+0x260>
 3205628:	2080020c 	andi	r2,r4,8
 320562c:	10003b26 	beq	r2,zero,320571c <_fseek_r+0x2f8>
 3205630:	80800017 	ldw	r2,0(r16)
 3205634:	10003926 	beq	r2,zero,320571c <_fseek_r+0x2f8>
 3205638:	81800417 	ldw	r6,16(r16)
 320563c:	1185c83a 	sub	r2,r2,r6
 3205640:	88a3883a 	add	r17,r17,r2
 3205644:	00001606 	br	32056a0 <_fseek_r+0x27c>
 3205648:	3204b8c0 	call	3204b8c <__sinit>
 320564c:	8080030b 	ldhu	r2,12(r16)
 3205650:	00c04204 	movi	r3,264
 3205654:	1080420c 	andi	r2,r2,264
 3205658:	10ff871e 	bne	r2,r3,3205478 <_fseek_r+0x54>
 320565c:	9009883a 	mov	r4,r18
 3205660:	800b883a 	mov	r5,r16
 3205664:	32048f40 	call	32048f4 <_fflush_r>
 3205668:	003f8306 	br	3205478 <_fseek_r+0x54>
 320566c:	81400c17 	ldw	r5,48(r16)
 3205670:	28004526 	beq	r5,zero,3205788 <_fseek_r+0x364>
 3205674:	8100030b 	ldhu	r4,12(r16)
 3205678:	80c00117 	ldw	r3,4(r16)
 320567c:	81c00f17 	ldw	r7,60(r16)
 3205680:	003fc506 	br	3205598 <_fseek_r+0x174>
 3205684:	80c00117 	ldw	r3,4(r16)
 3205688:	80800c17 	ldw	r2,48(r16)
 320568c:	88e3c83a 	sub	r17,r17,r3
 3205690:	10002226 	beq	r2,zero,320571c <_fseek_r+0x2f8>
 3205694:	81c00f17 	ldw	r7,60(r16)
 3205698:	81800417 	ldw	r6,16(r16)
 320569c:	89e3c83a 	sub	r17,r17,r7
 32056a0:	b46d883a 	add	r22,r22,r17
 32056a4:	0027883a 	mov	r19,zero
 32056a8:	05c00044 	movi	r23,1
 32056ac:	003f8b06 	br	32054dc <_fseek_r+0xb8>
 32056b0:	80801317 	ldw	r2,76(r16)
 32056b4:	81400717 	ldw	r5,28(r16)
 32056b8:	9009883a 	mov	r4,r18
 32056bc:	0085c83a 	sub	r2,zero,r2
 32056c0:	a0a2703a 	and	r17,r20,r2
 32056c4:	880d883a 	mov	r6,r17
 32056c8:	000f883a 	mov	r7,zero
 32056cc:	a83ee83a 	callr	r21
 32056d0:	00ffffc4 	movi	r3,-1
 32056d4:	10ff8d26 	beq	r2,r3,320550c <_fseek_r+0xe8>
 32056d8:	80800417 	ldw	r2,16(r16)
 32056dc:	81400c17 	ldw	r5,48(r16)
 32056e0:	80000115 	stw	zero,4(r16)
 32056e4:	80800015 	stw	r2,0(r16)
 32056e8:	28000526 	beq	r5,zero,3205700 <_fseek_r+0x2dc>
 32056ec:	80801004 	addi	r2,r16,64
 32056f0:	28800226 	beq	r5,r2,32056fc <_fseek_r+0x2d8>
 32056f4:	9009883a 	mov	r4,r18
 32056f8:	32051100 	call	3205110 <_free_r>
 32056fc:	80000c15 	stw	zero,48(r16)
 3205700:	8080030b 	ldhu	r2,12(r16)
 3205704:	a463c83a 	sub	r17,r20,r17
 3205708:	10bff7cc 	andi	r2,r2,65503
 320570c:	8080030d 	sth	r2,12(r16)
 3205710:	88000c1e 	bne	r17,zero,3205744 <_fseek_r+0x320>
 3205714:	0009883a 	mov	r4,zero
 3205718:	003f6106 	br	32054a0 <_fseek_r+0x7c>
 320571c:	81800417 	ldw	r6,16(r16)
 3205720:	003fdf06 	br	32056a0 <_fseek_r+0x27c>
 3205724:	8140038f 	ldh	r5,14(r16)
 3205728:	9009883a 	mov	r4,r18
 320572c:	d80d883a 	mov	r6,sp
 3205730:	32058840 	call	3205884 <_fstat_r>
 3205734:	103f751e 	bne	r2,zero,320550c <_fseek_r+0xe8>
 3205738:	d8800417 	ldw	r2,16(sp)
 320573c:	b0a9883a 	add	r20,r22,r2
 3205740:	003f8906 	br	3205568 <_fseek_r+0x144>
 3205744:	9009883a 	mov	r4,r18
 3205748:	800b883a 	mov	r5,r16
 320574c:	32077100 	call	3207710 <__srefill_r>
 3205750:	103f6e1e 	bne	r2,zero,320550c <_fseek_r+0xe8>
 3205754:	80c00117 	ldw	r3,4(r16)
 3205758:	1c7f6c36 	bltu	r3,r17,320550c <_fseek_r+0xe8>
 320575c:	80800017 	ldw	r2,0(r16)
 3205760:	1c47c83a 	sub	r3,r3,r17
 3205764:	0009883a 	mov	r4,zero
 3205768:	1445883a 	add	r2,r2,r17
 320576c:	80c00115 	stw	r3,4(r16)
 3205770:	80800015 	stw	r2,0(r16)
 3205774:	003f4a06 	br	32054a0 <_fseek_r+0x7c>
 3205778:	9009883a 	mov	r4,r18
 320577c:	800b883a 	mov	r5,r16
 3205780:	32061180 	call	3206118 <__smakebuf_r>
 3205784:	003f5606 	br	32054e0 <_fseek_r+0xbc>
 3205788:	8100030b 	ldhu	r4,12(r16)
 320578c:	80c00117 	ldw	r3,4(r16)
 3205790:	80800017 	ldw	r2,0(r16)
 3205794:	81800417 	ldw	r6,16(r16)
 3205798:	1185c83a 	sub	r2,r2,r6
 320579c:	10cf883a 	add	r7,r2,r3
 32057a0:	8887c83a 	sub	r3,r17,r2
 32057a4:	003f8206 	br	32055b0 <_fseek_r+0x18c>
 32057a8:	81400717 	ldw	r5,28(r16)
 32057ac:	b00d883a 	mov	r6,r22
 32057b0:	980f883a 	mov	r7,r19
 32057b4:	9009883a 	mov	r4,r18
 32057b8:	a83ee83a 	callr	r21
 32057bc:	00ffffc4 	movi	r3,-1
 32057c0:	10ff5626 	beq	r2,r3,320551c <_fseek_r+0xf8>
 32057c4:	81400c17 	ldw	r5,48(r16)
 32057c8:	28000526 	beq	r5,zero,32057e0 <_fseek_r+0x3bc>
 32057cc:	80801004 	addi	r2,r16,64
 32057d0:	28800226 	beq	r5,r2,32057dc <_fseek_r+0x3b8>
 32057d4:	9009883a 	mov	r4,r18
 32057d8:	32051100 	call	3205110 <_free_r>
 32057dc:	80000c15 	stw	zero,48(r16)
 32057e0:	8080030b 	ldhu	r2,12(r16)
 32057e4:	80c00417 	ldw	r3,16(r16)
 32057e8:	0009883a 	mov	r4,zero
 32057ec:	10bdf7cc 	andi	r2,r2,63455
 32057f0:	8080030d 	sth	r2,12(r16)
 32057f4:	80c00015 	stw	r3,0(r16)
 32057f8:	80000115 	stw	zero,4(r16)
 32057fc:	003f2806 	br	32054a0 <_fseek_r+0x7c>
 3205800:	81400717 	ldw	r5,28(r16)
 3205804:	000d883a 	mov	r6,zero
 3205808:	9009883a 	mov	r4,r18
 320580c:	01c00044 	movi	r7,1
 3205810:	a83ee83a 	callr	r21
 3205814:	100d883a 	mov	r6,r2
 3205818:	00bfffc4 	movi	r2,-1
 320581c:	30bf3b26 	beq	r6,r2,320550c <_fseek_r+0xe8>
 3205820:	8100030b 	ldhu	r4,12(r16)
 3205824:	003f5606 	br	3205580 <_fseek_r+0x15c>
 3205828:	00800744 	movi	r2,29
 320582c:	013fffc4 	movi	r4,-1
 3205830:	90800015 	stw	r2,0(r18)
 3205834:	003f1a06 	br	32054a0 <_fseek_r+0x7c>
 3205838:	81400717 	ldw	r5,28(r16)
 320583c:	980f883a 	mov	r7,r19
 3205840:	9009883a 	mov	r4,r18
 3205844:	000d883a 	mov	r6,zero
 3205848:	a83ee83a 	callr	r21
 320584c:	1023883a 	mov	r17,r2
 3205850:	00bfffc4 	movi	r2,-1
 3205854:	88bf3126 	beq	r17,r2,320551c <_fseek_r+0xf8>
 3205858:	8100030b 	ldhu	r4,12(r16)
 320585c:	003f7006 	br	3205620 <_fseek_r+0x1fc>

03205860 <fseek>:
 3205860:	0080c974 	movhi	r2,805
 3205864:	108a6304 	addi	r2,r2,10636
 3205868:	2013883a 	mov	r9,r4
 320586c:	11000017 	ldw	r4,0(r2)
 3205870:	2805883a 	mov	r2,r5
 3205874:	300f883a 	mov	r7,r6
 3205878:	480b883a 	mov	r5,r9
 320587c:	100d883a 	mov	r6,r2
 3205880:	32054241 	jmpi	3205424 <_fseek_r>

03205884 <_fstat_r>:
 3205884:	defffd04 	addi	sp,sp,-12
 3205888:	dc000015 	stw	r16,0(sp)
 320588c:	0400c974 	movhi	r16,805
 3205890:	8412f804 	addi	r16,r16,19424
 3205894:	dc400115 	stw	r17,4(sp)
 3205898:	80000015 	stw	zero,0(r16)
 320589c:	2023883a 	mov	r17,r4
 32058a0:	2809883a 	mov	r4,r5
 32058a4:	300b883a 	mov	r5,r6
 32058a8:	dfc00215 	stw	ra,8(sp)
 32058ac:	32149300 	call	3214930 <fstat>
 32058b0:	1007883a 	mov	r3,r2
 32058b4:	00bfffc4 	movi	r2,-1
 32058b8:	18800626 	beq	r3,r2,32058d4 <_fstat_r+0x50>
 32058bc:	1805883a 	mov	r2,r3
 32058c0:	dfc00217 	ldw	ra,8(sp)
 32058c4:	dc400117 	ldw	r17,4(sp)
 32058c8:	dc000017 	ldw	r16,0(sp)
 32058cc:	dec00304 	addi	sp,sp,12
 32058d0:	f800283a 	ret
 32058d4:	80800017 	ldw	r2,0(r16)
 32058d8:	103ff826 	beq	r2,zero,32058bc <_fstat_r+0x38>
 32058dc:	88800015 	stw	r2,0(r17)
 32058e0:	1805883a 	mov	r2,r3
 32058e4:	dfc00217 	ldw	ra,8(sp)
 32058e8:	dc400117 	ldw	r17,4(sp)
 32058ec:	dc000017 	ldw	r16,0(sp)
 32058f0:	dec00304 	addi	sp,sp,12
 32058f4:	f800283a 	ret

032058f8 <__sfvwrite_r>:
 32058f8:	30800217 	ldw	r2,8(r6)
 32058fc:	defff504 	addi	sp,sp,-44
 3205900:	df000915 	stw	fp,36(sp)
 3205904:	dd800715 	stw	r22,28(sp)
 3205908:	dc800315 	stw	r18,12(sp)
 320590c:	dfc00a15 	stw	ra,40(sp)
 3205910:	ddc00815 	stw	r23,32(sp)
 3205914:	dd400615 	stw	r21,24(sp)
 3205918:	dd000515 	stw	r20,20(sp)
 320591c:	dcc00415 	stw	r19,16(sp)
 3205920:	dc400215 	stw	r17,8(sp)
 3205924:	dc000115 	stw	r16,4(sp)
 3205928:	302d883a 	mov	r22,r6
 320592c:	2039883a 	mov	fp,r4
 3205930:	2825883a 	mov	r18,r5
 3205934:	10001c26 	beq	r2,zero,32059a8 <__sfvwrite_r+0xb0>
 3205938:	29c0030b 	ldhu	r7,12(r5)
 320593c:	3880020c 	andi	r2,r7,8
 3205940:	10002726 	beq	r2,zero,32059e0 <__sfvwrite_r+0xe8>
 3205944:	28800417 	ldw	r2,16(r5)
 3205948:	10002526 	beq	r2,zero,32059e0 <__sfvwrite_r+0xe8>
 320594c:	3880008c 	andi	r2,r7,2
 3205950:	b5400017 	ldw	r21,0(r22)
 3205954:	10002826 	beq	r2,zero,32059f8 <__sfvwrite_r+0x100>
 3205958:	0021883a 	mov	r16,zero
 320595c:	0023883a 	mov	r17,zero
 3205960:	880d883a 	mov	r6,r17
 3205964:	e009883a 	mov	r4,fp
 3205968:	00810004 	movi	r2,1024
 320596c:	80006e26 	beq	r16,zero,3205b28 <__sfvwrite_r+0x230>
 3205970:	800f883a 	mov	r7,r16
 3205974:	91400717 	ldw	r5,28(r18)
 3205978:	1400012e 	bgeu	r2,r16,3205980 <__sfvwrite_r+0x88>
 320597c:	100f883a 	mov	r7,r2
 3205980:	90c00917 	ldw	r3,36(r18)
 3205984:	183ee83a 	callr	r3
 3205988:	1007883a 	mov	r3,r2
 320598c:	80a1c83a 	sub	r16,r16,r2
 3205990:	88a3883a 	add	r17,r17,r2
 3205994:	00806d0e 	bge	zero,r2,3205b4c <__sfvwrite_r+0x254>
 3205998:	b0800217 	ldw	r2,8(r22)
 320599c:	10c5c83a 	sub	r2,r2,r3
 32059a0:	b0800215 	stw	r2,8(r22)
 32059a4:	103fee1e 	bne	r2,zero,3205960 <__sfvwrite_r+0x68>
 32059a8:	0009883a 	mov	r4,zero
 32059ac:	2005883a 	mov	r2,r4
 32059b0:	dfc00a17 	ldw	ra,40(sp)
 32059b4:	df000917 	ldw	fp,36(sp)
 32059b8:	ddc00817 	ldw	r23,32(sp)
 32059bc:	dd800717 	ldw	r22,28(sp)
 32059c0:	dd400617 	ldw	r21,24(sp)
 32059c4:	dd000517 	ldw	r20,20(sp)
 32059c8:	dcc00417 	ldw	r19,16(sp)
 32059cc:	dc800317 	ldw	r18,12(sp)
 32059d0:	dc400217 	ldw	r17,8(sp)
 32059d4:	dc000117 	ldw	r16,4(sp)
 32059d8:	dec00b04 	addi	sp,sp,44
 32059dc:	f800283a 	ret
 32059e0:	320bd300 	call	320bd30 <__swsetup_r>
 32059e4:	1000e41e 	bne	r2,zero,3205d78 <__sfvwrite_r+0x480>
 32059e8:	91c0030b 	ldhu	r7,12(r18)
 32059ec:	b5400017 	ldw	r21,0(r22)
 32059f0:	3880008c 	andi	r2,r7,2
 32059f4:	103fd81e 	bne	r2,zero,3205958 <__sfvwrite_r+0x60>
 32059f8:	3880004c 	andi	r2,r7,1
 32059fc:	1005003a 	cmpeq	r2,r2,zero
 3205a00:	10005726 	beq	r2,zero,3205b60 <__sfvwrite_r+0x268>
 3205a04:	0029883a 	mov	r20,zero
 3205a08:	002f883a 	mov	r23,zero
 3205a0c:	a0004226 	beq	r20,zero,3205b18 <__sfvwrite_r+0x220>
 3205a10:	3880800c 	andi	r2,r7,512
 3205a14:	94000217 	ldw	r16,8(r18)
 3205a18:	10008b26 	beq	r2,zero,3205c48 <__sfvwrite_r+0x350>
 3205a1c:	800d883a 	mov	r6,r16
 3205a20:	a400a536 	bltu	r20,r16,3205cb8 <__sfvwrite_r+0x3c0>
 3205a24:	3881200c 	andi	r2,r7,1152
 3205a28:	10002726 	beq	r2,zero,3205ac8 <__sfvwrite_r+0x1d0>
 3205a2c:	90800517 	ldw	r2,20(r18)
 3205a30:	92000417 	ldw	r8,16(r18)
 3205a34:	91400017 	ldw	r5,0(r18)
 3205a38:	1087883a 	add	r3,r2,r2
 3205a3c:	1887883a 	add	r3,r3,r2
 3205a40:	1808d7fa 	srli	r4,r3,31
 3205a44:	2a21c83a 	sub	r16,r5,r8
 3205a48:	80800044 	addi	r2,r16,1
 3205a4c:	20c9883a 	add	r4,r4,r3
 3205a50:	2027d07a 	srai	r19,r4,1
 3205a54:	a085883a 	add	r2,r20,r2
 3205a58:	980d883a 	mov	r6,r19
 3205a5c:	9880022e 	bgeu	r19,r2,3205a68 <__sfvwrite_r+0x170>
 3205a60:	1027883a 	mov	r19,r2
 3205a64:	100d883a 	mov	r6,r2
 3205a68:	3881000c 	andi	r2,r7,1024
 3205a6c:	1000b826 	beq	r2,zero,3205d50 <__sfvwrite_r+0x458>
 3205a70:	300b883a 	mov	r5,r6
 3205a74:	e009883a 	mov	r4,fp
 3205a78:	32062ac0 	call	32062ac <_malloc_r>
 3205a7c:	10003126 	beq	r2,zero,3205b44 <__sfvwrite_r+0x24c>
 3205a80:	91400417 	ldw	r5,16(r18)
 3205a84:	1009883a 	mov	r4,r2
 3205a88:	800d883a 	mov	r6,r16
 3205a8c:	1023883a 	mov	r17,r2
 3205a90:	3206ad00 	call	3206ad0 <memcpy>
 3205a94:	90c0030b 	ldhu	r3,12(r18)
 3205a98:	00beffc4 	movi	r2,-1025
 3205a9c:	1886703a 	and	r3,r3,r2
 3205aa0:	18c02014 	ori	r3,r3,128
 3205aa4:	90c0030d 	sth	r3,12(r18)
 3205aa8:	9c07c83a 	sub	r3,r19,r16
 3205aac:	8c05883a 	add	r2,r17,r16
 3205ab0:	a00d883a 	mov	r6,r20
 3205ab4:	a021883a 	mov	r16,r20
 3205ab8:	90800015 	stw	r2,0(r18)
 3205abc:	90c00215 	stw	r3,8(r18)
 3205ac0:	94400415 	stw	r17,16(r18)
 3205ac4:	94c00515 	stw	r19,20(r18)
 3205ac8:	91000017 	ldw	r4,0(r18)
 3205acc:	b80b883a 	mov	r5,r23
 3205ad0:	a023883a 	mov	r17,r20
 3205ad4:	3206b700 	call	3206b70 <memmove>
 3205ad8:	90c00217 	ldw	r3,8(r18)
 3205adc:	90800017 	ldw	r2,0(r18)
 3205ae0:	a027883a 	mov	r19,r20
 3205ae4:	1c07c83a 	sub	r3,r3,r16
 3205ae8:	1405883a 	add	r2,r2,r16
 3205aec:	90c00215 	stw	r3,8(r18)
 3205af0:	a021883a 	mov	r16,r20
 3205af4:	90800015 	stw	r2,0(r18)
 3205af8:	b0800217 	ldw	r2,8(r22)
 3205afc:	1405c83a 	sub	r2,r2,r16
 3205b00:	b0800215 	stw	r2,8(r22)
 3205b04:	103fa826 	beq	r2,zero,32059a8 <__sfvwrite_r+0xb0>
 3205b08:	a469c83a 	sub	r20,r20,r17
 3205b0c:	91c0030b 	ldhu	r7,12(r18)
 3205b10:	bcef883a 	add	r23,r23,r19
 3205b14:	a03fbe1e 	bne	r20,zero,3205a10 <__sfvwrite_r+0x118>
 3205b18:	adc00017 	ldw	r23,0(r21)
 3205b1c:	ad000117 	ldw	r20,4(r21)
 3205b20:	ad400204 	addi	r21,r21,8
 3205b24:	003fb906 	br	3205a0c <__sfvwrite_r+0x114>
 3205b28:	ac400017 	ldw	r17,0(r21)
 3205b2c:	ac000117 	ldw	r16,4(r21)
 3205b30:	ad400204 	addi	r21,r21,8
 3205b34:	003f8a06 	br	3205960 <__sfvwrite_r+0x68>
 3205b38:	91400417 	ldw	r5,16(r18)
 3205b3c:	e009883a 	mov	r4,fp
 3205b40:	32051100 	call	3205110 <_free_r>
 3205b44:	00800304 	movi	r2,12
 3205b48:	e0800015 	stw	r2,0(fp)
 3205b4c:	9080030b 	ldhu	r2,12(r18)
 3205b50:	013fffc4 	movi	r4,-1
 3205b54:	10801014 	ori	r2,r2,64
 3205b58:	9080030d 	sth	r2,12(r18)
 3205b5c:	003f9306 	br	32059ac <__sfvwrite_r+0xb4>
 3205b60:	0027883a 	mov	r19,zero
 3205b64:	002f883a 	mov	r23,zero
 3205b68:	d8000015 	stw	zero,0(sp)
 3205b6c:	0029883a 	mov	r20,zero
 3205b70:	98001e26 	beq	r19,zero,3205bec <__sfvwrite_r+0x2f4>
 3205b74:	d8c00017 	ldw	r3,0(sp)
 3205b78:	1804c03a 	cmpne	r2,r3,zero
 3205b7c:	10005e26 	beq	r2,zero,3205cf8 <__sfvwrite_r+0x400>
 3205b80:	9821883a 	mov	r16,r19
 3205b84:	a4c0012e 	bgeu	r20,r19,3205b8c <__sfvwrite_r+0x294>
 3205b88:	a021883a 	mov	r16,r20
 3205b8c:	91000017 	ldw	r4,0(r18)
 3205b90:	90800417 	ldw	r2,16(r18)
 3205b94:	91800217 	ldw	r6,8(r18)
 3205b98:	91c00517 	ldw	r7,20(r18)
 3205b9c:	1100022e 	bgeu	r2,r4,3205ba8 <__sfvwrite_r+0x2b0>
 3205ba0:	31e3883a 	add	r17,r6,r7
 3205ba4:	8c001616 	blt	r17,r16,3205c00 <__sfvwrite_r+0x308>
 3205ba8:	81c03816 	blt	r16,r7,3205c8c <__sfvwrite_r+0x394>
 3205bac:	90c00917 	ldw	r3,36(r18)
 3205bb0:	91400717 	ldw	r5,28(r18)
 3205bb4:	e009883a 	mov	r4,fp
 3205bb8:	b80d883a 	mov	r6,r23
 3205bbc:	183ee83a 	callr	r3
 3205bc0:	1023883a 	mov	r17,r2
 3205bc4:	00bfe10e 	bge	zero,r2,3205b4c <__sfvwrite_r+0x254>
 3205bc8:	a469c83a 	sub	r20,r20,r17
 3205bcc:	a0001826 	beq	r20,zero,3205c30 <__sfvwrite_r+0x338>
 3205bd0:	b0800217 	ldw	r2,8(r22)
 3205bd4:	1445c83a 	sub	r2,r2,r17
 3205bd8:	b0800215 	stw	r2,8(r22)
 3205bdc:	103f7226 	beq	r2,zero,32059a8 <__sfvwrite_r+0xb0>
 3205be0:	9c67c83a 	sub	r19,r19,r17
 3205be4:	bc6f883a 	add	r23,r23,r17
 3205be8:	983fe21e 	bne	r19,zero,3205b74 <__sfvwrite_r+0x27c>
 3205bec:	adc00017 	ldw	r23,0(r21)
 3205bf0:	acc00117 	ldw	r19,4(r21)
 3205bf4:	ad400204 	addi	r21,r21,8
 3205bf8:	d8000015 	stw	zero,0(sp)
 3205bfc:	003fdc06 	br	3205b70 <__sfvwrite_r+0x278>
 3205c00:	b80b883a 	mov	r5,r23
 3205c04:	880d883a 	mov	r6,r17
 3205c08:	3206b700 	call	3206b70 <memmove>
 3205c0c:	90c00017 	ldw	r3,0(r18)
 3205c10:	e009883a 	mov	r4,fp
 3205c14:	900b883a 	mov	r5,r18
 3205c18:	1c47883a 	add	r3,r3,r17
 3205c1c:	90c00015 	stw	r3,0(r18)
 3205c20:	32048f40 	call	32048f4 <_fflush_r>
 3205c24:	103fc91e 	bne	r2,zero,3205b4c <__sfvwrite_r+0x254>
 3205c28:	a469c83a 	sub	r20,r20,r17
 3205c2c:	a03fe81e 	bne	r20,zero,3205bd0 <__sfvwrite_r+0x2d8>
 3205c30:	e009883a 	mov	r4,fp
 3205c34:	900b883a 	mov	r5,r18
 3205c38:	32048f40 	call	32048f4 <_fflush_r>
 3205c3c:	103fc31e 	bne	r2,zero,3205b4c <__sfvwrite_r+0x254>
 3205c40:	d8000015 	stw	zero,0(sp)
 3205c44:	003fe206 	br	3205bd0 <__sfvwrite_r+0x2d8>
 3205c48:	91000017 	ldw	r4,0(r18)
 3205c4c:	90800417 	ldw	r2,16(r18)
 3205c50:	1100022e 	bgeu	r2,r4,3205c5c <__sfvwrite_r+0x364>
 3205c54:	8023883a 	mov	r17,r16
 3205c58:	85003136 	bltu	r16,r20,3205d20 <__sfvwrite_r+0x428>
 3205c5c:	91c00517 	ldw	r7,20(r18)
 3205c60:	a1c01836 	bltu	r20,r7,3205cc4 <__sfvwrite_r+0x3cc>
 3205c64:	90c00917 	ldw	r3,36(r18)
 3205c68:	91400717 	ldw	r5,28(r18)
 3205c6c:	e009883a 	mov	r4,fp
 3205c70:	b80d883a 	mov	r6,r23
 3205c74:	183ee83a 	callr	r3
 3205c78:	1021883a 	mov	r16,r2
 3205c7c:	00bfb30e 	bge	zero,r2,3205b4c <__sfvwrite_r+0x254>
 3205c80:	1023883a 	mov	r17,r2
 3205c84:	1027883a 	mov	r19,r2
 3205c88:	003f9b06 	br	3205af8 <__sfvwrite_r+0x200>
 3205c8c:	b80b883a 	mov	r5,r23
 3205c90:	800d883a 	mov	r6,r16
 3205c94:	3206b700 	call	3206b70 <memmove>
 3205c98:	90c00217 	ldw	r3,8(r18)
 3205c9c:	90800017 	ldw	r2,0(r18)
 3205ca0:	8023883a 	mov	r17,r16
 3205ca4:	1c07c83a 	sub	r3,r3,r16
 3205ca8:	1405883a 	add	r2,r2,r16
 3205cac:	90c00215 	stw	r3,8(r18)
 3205cb0:	90800015 	stw	r2,0(r18)
 3205cb4:	003fc406 	br	3205bc8 <__sfvwrite_r+0x2d0>
 3205cb8:	a00d883a 	mov	r6,r20
 3205cbc:	a021883a 	mov	r16,r20
 3205cc0:	003f8106 	br	3205ac8 <__sfvwrite_r+0x1d0>
 3205cc4:	b80b883a 	mov	r5,r23
 3205cc8:	a00d883a 	mov	r6,r20
 3205ccc:	3206b700 	call	3206b70 <memmove>
 3205cd0:	90c00217 	ldw	r3,8(r18)
 3205cd4:	90800017 	ldw	r2,0(r18)
 3205cd8:	a021883a 	mov	r16,r20
 3205cdc:	1d07c83a 	sub	r3,r3,r20
 3205ce0:	1505883a 	add	r2,r2,r20
 3205ce4:	a023883a 	mov	r17,r20
 3205ce8:	a027883a 	mov	r19,r20
 3205cec:	90c00215 	stw	r3,8(r18)
 3205cf0:	90800015 	stw	r2,0(r18)
 3205cf4:	003f8006 	br	3205af8 <__sfvwrite_r+0x200>
 3205cf8:	b809883a 	mov	r4,r23
 3205cfc:	01400284 	movi	r5,10
 3205d00:	980d883a 	mov	r6,r19
 3205d04:	32069ec0 	call	32069ec <memchr>
 3205d08:	10001726 	beq	r2,zero,3205d68 <__sfvwrite_r+0x470>
 3205d0c:	15c5c83a 	sub	r2,r2,r23
 3205d10:	15000044 	addi	r20,r2,1
 3205d14:	00800044 	movi	r2,1
 3205d18:	d8800015 	stw	r2,0(sp)
 3205d1c:	003f9806 	br	3205b80 <__sfvwrite_r+0x288>
 3205d20:	b80b883a 	mov	r5,r23
 3205d24:	800d883a 	mov	r6,r16
 3205d28:	3206b700 	call	3206b70 <memmove>
 3205d2c:	90c00017 	ldw	r3,0(r18)
 3205d30:	e009883a 	mov	r4,fp
 3205d34:	900b883a 	mov	r5,r18
 3205d38:	1c07883a 	add	r3,r3,r16
 3205d3c:	90c00015 	stw	r3,0(r18)
 3205d40:	8027883a 	mov	r19,r16
 3205d44:	32048f40 	call	32048f4 <_fflush_r>
 3205d48:	103f6b26 	beq	r2,zero,3205af8 <__sfvwrite_r+0x200>
 3205d4c:	003f7f06 	br	3205b4c <__sfvwrite_r+0x254>
 3205d50:	400b883a 	mov	r5,r8
 3205d54:	e009883a 	mov	r4,fp
 3205d58:	320711c0 	call	320711c <_realloc_r>
 3205d5c:	103f7626 	beq	r2,zero,3205b38 <__sfvwrite_r+0x240>
 3205d60:	1023883a 	mov	r17,r2
 3205d64:	003f5006 	br	3205aa8 <__sfvwrite_r+0x1b0>
 3205d68:	00c00044 	movi	r3,1
 3205d6c:	9d000044 	addi	r20,r19,1
 3205d70:	d8c00015 	stw	r3,0(sp)
 3205d74:	003f8206 	br	3205b80 <__sfvwrite_r+0x288>
 3205d78:	9080030b 	ldhu	r2,12(r18)
 3205d7c:	00c00244 	movi	r3,9
 3205d80:	013fffc4 	movi	r4,-1
 3205d84:	10801014 	ori	r2,r2,64
 3205d88:	9080030d 	sth	r2,12(r18)
 3205d8c:	e0c00015 	stw	r3,0(fp)
 3205d90:	003f0606 	br	32059ac <__sfvwrite_r+0xb4>

03205d94 <_fwalk_reent>:
 3205d94:	defff704 	addi	sp,sp,-36
 3205d98:	dcc00315 	stw	r19,12(sp)
 3205d9c:	24c0b804 	addi	r19,r4,736
 3205da0:	dd800615 	stw	r22,24(sp)
 3205da4:	dd400515 	stw	r21,20(sp)
 3205da8:	dfc00815 	stw	ra,32(sp)
 3205dac:	ddc00715 	stw	r23,28(sp)
 3205db0:	dd000415 	stw	r20,16(sp)
 3205db4:	dc800215 	stw	r18,8(sp)
 3205db8:	dc400115 	stw	r17,4(sp)
 3205dbc:	dc000015 	stw	r16,0(sp)
 3205dc0:	202b883a 	mov	r21,r4
 3205dc4:	282d883a 	mov	r22,r5
 3205dc8:	3204b7c0 	call	3204b7c <__sfp_lock_acquire>
 3205dcc:	98002126 	beq	r19,zero,3205e54 <_fwalk_reent+0xc0>
 3205dd0:	002f883a 	mov	r23,zero
 3205dd4:	9c800117 	ldw	r18,4(r19)
 3205dd8:	9c000217 	ldw	r16,8(r19)
 3205ddc:	90bfffc4 	addi	r2,r18,-1
 3205de0:	10000d16 	blt	r2,zero,3205e18 <_fwalk_reent+0x84>
 3205de4:	0023883a 	mov	r17,zero
 3205de8:	053fffc4 	movi	r20,-1
 3205dec:	8080030f 	ldh	r2,12(r16)
 3205df0:	8c400044 	addi	r17,r17,1
 3205df4:	10000626 	beq	r2,zero,3205e10 <_fwalk_reent+0x7c>
 3205df8:	8080038f 	ldh	r2,14(r16)
 3205dfc:	800b883a 	mov	r5,r16
 3205e00:	a809883a 	mov	r4,r21
 3205e04:	15000226 	beq	r2,r20,3205e10 <_fwalk_reent+0x7c>
 3205e08:	b03ee83a 	callr	r22
 3205e0c:	b8aeb03a 	or	r23,r23,r2
 3205e10:	84001704 	addi	r16,r16,92
 3205e14:	947ff51e 	bne	r18,r17,3205dec <_fwalk_reent+0x58>
 3205e18:	9cc00017 	ldw	r19,0(r19)
 3205e1c:	983fed1e 	bne	r19,zero,3205dd4 <_fwalk_reent+0x40>
 3205e20:	3204b800 	call	3204b80 <__sfp_lock_release>
 3205e24:	b805883a 	mov	r2,r23
 3205e28:	dfc00817 	ldw	ra,32(sp)
 3205e2c:	ddc00717 	ldw	r23,28(sp)
 3205e30:	dd800617 	ldw	r22,24(sp)
 3205e34:	dd400517 	ldw	r21,20(sp)
 3205e38:	dd000417 	ldw	r20,16(sp)
 3205e3c:	dcc00317 	ldw	r19,12(sp)
 3205e40:	dc800217 	ldw	r18,8(sp)
 3205e44:	dc400117 	ldw	r17,4(sp)
 3205e48:	dc000017 	ldw	r16,0(sp)
 3205e4c:	dec00904 	addi	sp,sp,36
 3205e50:	f800283a 	ret
 3205e54:	002f883a 	mov	r23,zero
 3205e58:	003ff106 	br	3205e20 <_fwalk_reent+0x8c>

03205e5c <_fwalk>:
 3205e5c:	defff804 	addi	sp,sp,-32
 3205e60:	dcc00315 	stw	r19,12(sp)
 3205e64:	24c0b804 	addi	r19,r4,736
 3205e68:	dd400515 	stw	r21,20(sp)
 3205e6c:	dfc00715 	stw	ra,28(sp)
 3205e70:	dd800615 	stw	r22,24(sp)
 3205e74:	dd000415 	stw	r20,16(sp)
 3205e78:	dc800215 	stw	r18,8(sp)
 3205e7c:	dc400115 	stw	r17,4(sp)
 3205e80:	dc000015 	stw	r16,0(sp)
 3205e84:	282b883a 	mov	r21,r5
 3205e88:	3204b7c0 	call	3204b7c <__sfp_lock_acquire>
 3205e8c:	98001f26 	beq	r19,zero,3205f0c <_fwalk+0xb0>
 3205e90:	002d883a 	mov	r22,zero
 3205e94:	9c800117 	ldw	r18,4(r19)
 3205e98:	9c000217 	ldw	r16,8(r19)
 3205e9c:	90bfffc4 	addi	r2,r18,-1
 3205ea0:	10000c16 	blt	r2,zero,3205ed4 <_fwalk+0x78>
 3205ea4:	0023883a 	mov	r17,zero
 3205ea8:	053fffc4 	movi	r20,-1
 3205eac:	8080030f 	ldh	r2,12(r16)
 3205eb0:	8c400044 	addi	r17,r17,1
 3205eb4:	10000526 	beq	r2,zero,3205ecc <_fwalk+0x70>
 3205eb8:	8080038f 	ldh	r2,14(r16)
 3205ebc:	8009883a 	mov	r4,r16
 3205ec0:	15000226 	beq	r2,r20,3205ecc <_fwalk+0x70>
 3205ec4:	a83ee83a 	callr	r21
 3205ec8:	b0acb03a 	or	r22,r22,r2
 3205ecc:	84001704 	addi	r16,r16,92
 3205ed0:	947ff61e 	bne	r18,r17,3205eac <_fwalk+0x50>
 3205ed4:	9cc00017 	ldw	r19,0(r19)
 3205ed8:	983fee1e 	bne	r19,zero,3205e94 <_fwalk+0x38>
 3205edc:	3204b800 	call	3204b80 <__sfp_lock_release>
 3205ee0:	b005883a 	mov	r2,r22
 3205ee4:	dfc00717 	ldw	ra,28(sp)
 3205ee8:	dd800617 	ldw	r22,24(sp)
 3205eec:	dd400517 	ldw	r21,20(sp)
 3205ef0:	dd000417 	ldw	r20,16(sp)
 3205ef4:	dcc00317 	ldw	r19,12(sp)
 3205ef8:	dc800217 	ldw	r18,8(sp)
 3205efc:	dc400117 	ldw	r17,4(sp)
 3205f00:	dc000017 	ldw	r16,0(sp)
 3205f04:	dec00804 	addi	sp,sp,32
 3205f08:	f800283a 	ret
 3205f0c:	002d883a 	mov	r22,zero
 3205f10:	003ff206 	br	3205edc <_fwalk+0x80>

03205f14 <_fwrite_r>:
 3205f14:	defff604 	addi	sp,sp,-40
 3205f18:	dc400615 	stw	r17,24(sp)
 3205f1c:	39a3383a 	mul	r17,r7,r6
 3205f20:	00800044 	movi	r2,1
 3205f24:	dcc00815 	stw	r19,32(sp)
 3205f28:	dc800715 	stw	r18,28(sp)
 3205f2c:	dc000515 	stw	r16,20(sp)
 3205f30:	dfc00915 	stw	ra,36(sp)
 3205f34:	3825883a 	mov	r18,r7
 3205f38:	3027883a 	mov	r19,r6
 3205f3c:	2021883a 	mov	r16,r4
 3205f40:	d9400015 	stw	r5,0(sp)
 3205f44:	d8800315 	stw	r2,12(sp)
 3205f48:	dc400115 	stw	r17,4(sp)
 3205f4c:	dc400415 	stw	r17,16(sp)
 3205f50:	dec00215 	stw	sp,8(sp)
 3205f54:	20000226 	beq	r4,zero,3205f60 <_fwrite_r+0x4c>
 3205f58:	20800e17 	ldw	r2,56(r4)
 3205f5c:	10001226 	beq	r2,zero,3205fa8 <_fwrite_r+0x94>
 3205f60:	d9400a17 	ldw	r5,40(sp)
 3205f64:	8009883a 	mov	r4,r16
 3205f68:	d9800204 	addi	r6,sp,8
 3205f6c:	32058f80 	call	32058f8 <__sfvwrite_r>
 3205f70:	980b883a 	mov	r5,r19
 3205f74:	10000426 	beq	r2,zero,3205f88 <_fwrite_r+0x74>
 3205f78:	d9000417 	ldw	r4,16(sp)
 3205f7c:	8909c83a 	sub	r4,r17,r4
 3205f80:	32047c00 	call	32047c0 <__udivsi3>
 3205f84:	1025883a 	mov	r18,r2
 3205f88:	9005883a 	mov	r2,r18
 3205f8c:	dfc00917 	ldw	ra,36(sp)
 3205f90:	dcc00817 	ldw	r19,32(sp)
 3205f94:	dc800717 	ldw	r18,28(sp)
 3205f98:	dc400617 	ldw	r17,24(sp)
 3205f9c:	dc000517 	ldw	r16,20(sp)
 3205fa0:	dec00a04 	addi	sp,sp,40
 3205fa4:	f800283a 	ret
 3205fa8:	3204b8c0 	call	3204b8c <__sinit>
 3205fac:	003fec06 	br	3205f60 <_fwrite_r+0x4c>

03205fb0 <fwrite>:
 3205fb0:	0080c974 	movhi	r2,805
 3205fb4:	108a6304 	addi	r2,r2,10636
 3205fb8:	2017883a 	mov	r11,r4
 3205fbc:	11000017 	ldw	r4,0(r2)
 3205fc0:	defffe04 	addi	sp,sp,-8
 3205fc4:	3013883a 	mov	r9,r6
 3205fc8:	2805883a 	mov	r2,r5
 3205fcc:	d9c00015 	stw	r7,0(sp)
 3205fd0:	580b883a 	mov	r5,r11
 3205fd4:	100d883a 	mov	r6,r2
 3205fd8:	480f883a 	mov	r7,r9
 3205fdc:	dfc00115 	stw	ra,4(sp)
 3205fe0:	3205f140 	call	3205f14 <_fwrite_r>
 3205fe4:	dfc00117 	ldw	ra,4(sp)
 3205fe8:	dec00204 	addi	sp,sp,8
 3205fec:	f800283a 	ret

03205ff0 <getc>:
 3205ff0:	defffd04 	addi	sp,sp,-12
 3205ff4:	dc400115 	stw	r17,4(sp)
 3205ff8:	0440c974 	movhi	r17,805
 3205ffc:	8c4a6304 	addi	r17,r17,10636
 3206000:	88c00017 	ldw	r3,0(r17)
 3206004:	dc000015 	stw	r16,0(sp)
 3206008:	dfc00215 	stw	ra,8(sp)
 320600c:	2021883a 	mov	r16,r4
 3206010:	18000326 	beq	r3,zero,3206020 <getc+0x30>
 3206014:	18800e17 	ldw	r2,56(r3)
 3206018:	1809883a 	mov	r4,r3
 320601c:	10000e26 	beq	r2,zero,3206058 <getc+0x68>
 3206020:	80800117 	ldw	r2,4(r16)
 3206024:	800b883a 	mov	r5,r16
 3206028:	10bfffc4 	addi	r2,r2,-1
 320602c:	80800115 	stw	r2,4(r16)
 3206030:	10000f16 	blt	r2,zero,3206070 <getc+0x80>
 3206034:	80c00017 	ldw	r3,0(r16)
 3206038:	18800003 	ldbu	r2,0(r3)
 320603c:	18c00044 	addi	r3,r3,1
 3206040:	80c00015 	stw	r3,0(r16)
 3206044:	dfc00217 	ldw	ra,8(sp)
 3206048:	dc400117 	ldw	r17,4(sp)
 320604c:	dc000017 	ldw	r16,0(sp)
 3206050:	dec00304 	addi	sp,sp,12
 3206054:	f800283a 	ret
 3206058:	3204b8c0 	call	3204b8c <__sinit>
 320605c:	80800117 	ldw	r2,4(r16)
 3206060:	800b883a 	mov	r5,r16
 3206064:	10bfffc4 	addi	r2,r2,-1
 3206068:	80800115 	stw	r2,4(r16)
 320606c:	103ff10e 	bge	r2,zero,3206034 <getc+0x44>
 3206070:	89000017 	ldw	r4,0(r17)
 3206074:	dfc00217 	ldw	ra,8(sp)
 3206078:	dc400117 	ldw	r17,4(sp)
 320607c:	dc000017 	ldw	r16,0(sp)
 3206080:	dec00304 	addi	sp,sp,12
 3206084:	32078f01 	jmpi	32078f0 <__srget_r>

03206088 <_getc_r>:
 3206088:	defffd04 	addi	sp,sp,-12
 320608c:	dc400115 	stw	r17,4(sp)
 3206090:	dc000015 	stw	r16,0(sp)
 3206094:	dfc00215 	stw	ra,8(sp)
 3206098:	2021883a 	mov	r16,r4
 320609c:	2823883a 	mov	r17,r5
 32060a0:	20000226 	beq	r4,zero,32060ac <_getc_r+0x24>
 32060a4:	20800e17 	ldw	r2,56(r4)
 32060a8:	10000f26 	beq	r2,zero,32060e8 <_getc_r+0x60>
 32060ac:	88800117 	ldw	r2,4(r17)
 32060b0:	8009883a 	mov	r4,r16
 32060b4:	880b883a 	mov	r5,r17
 32060b8:	10bfffc4 	addi	r2,r2,-1
 32060bc:	88800115 	stw	r2,4(r17)
 32060c0:	10001016 	blt	r2,zero,3206104 <_getc_r+0x7c>
 32060c4:	88c00017 	ldw	r3,0(r17)
 32060c8:	18800003 	ldbu	r2,0(r3)
 32060cc:	18c00044 	addi	r3,r3,1
 32060d0:	88c00015 	stw	r3,0(r17)
 32060d4:	dfc00217 	ldw	ra,8(sp)
 32060d8:	dc400117 	ldw	r17,4(sp)
 32060dc:	dc000017 	ldw	r16,0(sp)
 32060e0:	dec00304 	addi	sp,sp,12
 32060e4:	f800283a 	ret
 32060e8:	3204b8c0 	call	3204b8c <__sinit>
 32060ec:	88800117 	ldw	r2,4(r17)
 32060f0:	8009883a 	mov	r4,r16
 32060f4:	880b883a 	mov	r5,r17
 32060f8:	10bfffc4 	addi	r2,r2,-1
 32060fc:	88800115 	stw	r2,4(r17)
 3206100:	103ff00e 	bge	r2,zero,32060c4 <_getc_r+0x3c>
 3206104:	dfc00217 	ldw	ra,8(sp)
 3206108:	dc400117 	ldw	r17,4(sp)
 320610c:	dc000017 	ldw	r16,0(sp)
 3206110:	dec00304 	addi	sp,sp,12
 3206114:	32078f01 	jmpi	32078f0 <__srget_r>

03206118 <__smakebuf_r>:
 3206118:	2880030b 	ldhu	r2,12(r5)
 320611c:	deffed04 	addi	sp,sp,-76
 3206120:	dc401015 	stw	r17,64(sp)
 3206124:	1080008c 	andi	r2,r2,2
 3206128:	dc000f15 	stw	r16,60(sp)
 320612c:	dfc01215 	stw	ra,72(sp)
 3206130:	dc801115 	stw	r18,68(sp)
 3206134:	2821883a 	mov	r16,r5
 3206138:	2023883a 	mov	r17,r4
 320613c:	10000b26 	beq	r2,zero,320616c <__smakebuf_r+0x54>
 3206140:	28c010c4 	addi	r3,r5,67
 3206144:	00800044 	movi	r2,1
 3206148:	28800515 	stw	r2,20(r5)
 320614c:	28c00415 	stw	r3,16(r5)
 3206150:	28c00015 	stw	r3,0(r5)
 3206154:	dfc01217 	ldw	ra,72(sp)
 3206158:	dc801117 	ldw	r18,68(sp)
 320615c:	dc401017 	ldw	r17,64(sp)
 3206160:	dc000f17 	ldw	r16,60(sp)
 3206164:	dec01304 	addi	sp,sp,76
 3206168:	f800283a 	ret
 320616c:	2940038f 	ldh	r5,14(r5)
 3206170:	28002116 	blt	r5,zero,32061f8 <__smakebuf_r+0xe0>
 3206174:	d80d883a 	mov	r6,sp
 3206178:	32058840 	call	3205884 <_fstat_r>
 320617c:	10001e16 	blt	r2,zero,32061f8 <__smakebuf_r+0xe0>
 3206180:	d8800117 	ldw	r2,4(sp)
 3206184:	00e00014 	movui	r3,32768
 3206188:	113c000c 	andi	r4,r2,61440
 320618c:	20c03126 	beq	r4,r3,3206254 <__smakebuf_r+0x13c>
 3206190:	8080030b 	ldhu	r2,12(r16)
 3206194:	00c80004 	movi	r3,8192
 3206198:	10820014 	ori	r2,r2,2048
 320619c:	8080030d 	sth	r2,12(r16)
 32061a0:	20c01e26 	beq	r4,r3,320621c <__smakebuf_r+0x104>
 32061a4:	04810004 	movi	r18,1024
 32061a8:	8809883a 	mov	r4,r17
 32061ac:	900b883a 	mov	r5,r18
 32061b0:	32062ac0 	call	32062ac <_malloc_r>
 32061b4:	1009883a 	mov	r4,r2
 32061b8:	10003126 	beq	r2,zero,3206280 <__smakebuf_r+0x168>
 32061bc:	80c0030b 	ldhu	r3,12(r16)
 32061c0:	0080c834 	movhi	r2,800
 32061c4:	10931c04 	addi	r2,r2,19568
 32061c8:	88800f15 	stw	r2,60(r17)
 32061cc:	18c02014 	ori	r3,r3,128
 32061d0:	84800515 	stw	r18,20(r16)
 32061d4:	80c0030d 	sth	r3,12(r16)
 32061d8:	81000415 	stw	r4,16(r16)
 32061dc:	81000015 	stw	r4,0(r16)
 32061e0:	dfc01217 	ldw	ra,72(sp)
 32061e4:	dc801117 	ldw	r18,68(sp)
 32061e8:	dc401017 	ldw	r17,64(sp)
 32061ec:	dc000f17 	ldw	r16,60(sp)
 32061f0:	dec01304 	addi	sp,sp,76
 32061f4:	f800283a 	ret
 32061f8:	80c0030b 	ldhu	r3,12(r16)
 32061fc:	1880200c 	andi	r2,r3,128
 3206200:	10000426 	beq	r2,zero,3206214 <__smakebuf_r+0xfc>
 3206204:	04801004 	movi	r18,64
 3206208:	18820014 	ori	r2,r3,2048
 320620c:	8080030d 	sth	r2,12(r16)
 3206210:	003fe506 	br	32061a8 <__smakebuf_r+0x90>
 3206214:	04810004 	movi	r18,1024
 3206218:	003ffb06 	br	3206208 <__smakebuf_r+0xf0>
 320621c:	8140038f 	ldh	r5,14(r16)
 3206220:	8809883a 	mov	r4,r17
 3206224:	320da400 	call	320da40 <_isatty_r>
 3206228:	103fde26 	beq	r2,zero,32061a4 <__smakebuf_r+0x8c>
 320622c:	8080030b 	ldhu	r2,12(r16)
 3206230:	80c010c4 	addi	r3,r16,67
 3206234:	04810004 	movi	r18,1024
 3206238:	10800054 	ori	r2,r2,1
 320623c:	8080030d 	sth	r2,12(r16)
 3206240:	00800044 	movi	r2,1
 3206244:	80c00415 	stw	r3,16(r16)
 3206248:	80800515 	stw	r2,20(r16)
 320624c:	80c00015 	stw	r3,0(r16)
 3206250:	003fd506 	br	32061a8 <__smakebuf_r+0x90>
 3206254:	80c00a17 	ldw	r3,40(r16)
 3206258:	0080c834 	movhi	r2,800
 320625c:	109eec04 	addi	r2,r2,31664
 3206260:	18bfcb1e 	bne	r3,r2,3206190 <__smakebuf_r+0x78>
 3206264:	8080030b 	ldhu	r2,12(r16)
 3206268:	00c10004 	movi	r3,1024
 320626c:	1825883a 	mov	r18,r3
 3206270:	10c4b03a 	or	r2,r2,r3
 3206274:	8080030d 	sth	r2,12(r16)
 3206278:	80c01315 	stw	r3,76(r16)
 320627c:	003fca06 	br	32061a8 <__smakebuf_r+0x90>
 3206280:	8100030b 	ldhu	r4,12(r16)
 3206284:	2080800c 	andi	r2,r4,512
 3206288:	103fb21e 	bne	r2,zero,3206154 <__smakebuf_r+0x3c>
 320628c:	80c010c4 	addi	r3,r16,67
 3206290:	21000094 	ori	r4,r4,2
 3206294:	00800044 	movi	r2,1
 3206298:	80800515 	stw	r2,20(r16)
 320629c:	8100030d 	sth	r4,12(r16)
 32062a0:	80c00415 	stw	r3,16(r16)
 32062a4:	80c00015 	stw	r3,0(r16)
 32062a8:	003faa06 	br	3206154 <__smakebuf_r+0x3c>

032062ac <_malloc_r>:
 32062ac:	defff604 	addi	sp,sp,-40
 32062b0:	28c002c4 	addi	r3,r5,11
 32062b4:	00800584 	movi	r2,22
 32062b8:	dc800215 	stw	r18,8(sp)
 32062bc:	dfc00915 	stw	ra,36(sp)
 32062c0:	df000815 	stw	fp,32(sp)
 32062c4:	ddc00715 	stw	r23,28(sp)
 32062c8:	dd800615 	stw	r22,24(sp)
 32062cc:	dd400515 	stw	r21,20(sp)
 32062d0:	dd000415 	stw	r20,16(sp)
 32062d4:	dcc00315 	stw	r19,12(sp)
 32062d8:	dc400115 	stw	r17,4(sp)
 32062dc:	dc000015 	stw	r16,0(sp)
 32062e0:	2025883a 	mov	r18,r4
 32062e4:	10c01236 	bltu	r2,r3,3206330 <_malloc_r+0x84>
 32062e8:	04400404 	movi	r17,16
 32062ec:	8940142e 	bgeu	r17,r5,3206340 <_malloc_r+0x94>
 32062f0:	00800304 	movi	r2,12
 32062f4:	0007883a 	mov	r3,zero
 32062f8:	90800015 	stw	r2,0(r18)
 32062fc:	1805883a 	mov	r2,r3
 3206300:	dfc00917 	ldw	ra,36(sp)
 3206304:	df000817 	ldw	fp,32(sp)
 3206308:	ddc00717 	ldw	r23,28(sp)
 320630c:	dd800617 	ldw	r22,24(sp)
 3206310:	dd400517 	ldw	r21,20(sp)
 3206314:	dd000417 	ldw	r20,16(sp)
 3206318:	dcc00317 	ldw	r19,12(sp)
 320631c:	dc800217 	ldw	r18,8(sp)
 3206320:	dc400117 	ldw	r17,4(sp)
 3206324:	dc000017 	ldw	r16,0(sp)
 3206328:	dec00a04 	addi	sp,sp,40
 320632c:	f800283a 	ret
 3206330:	00bffe04 	movi	r2,-8
 3206334:	18a2703a 	and	r17,r3,r2
 3206338:	883fed16 	blt	r17,zero,32062f0 <_malloc_r+0x44>
 320633c:	897fec36 	bltu	r17,r5,32062f0 <_malloc_r+0x44>
 3206340:	9009883a 	mov	r4,r18
 3206344:	32153700 	call	3215370 <__malloc_lock>
 3206348:	00807dc4 	movi	r2,503
 320634c:	14402b2e 	bgeu	r2,r17,32063fc <_malloc_r+0x150>
 3206350:	8806d27a 	srli	r3,r17,9
 3206354:	18003f1e 	bne	r3,zero,3206454 <_malloc_r+0x1a8>
 3206358:	880cd0fa 	srli	r6,r17,3
 320635c:	300490fa 	slli	r2,r6,3
 3206360:	02c0c974 	movhi	r11,805
 3206364:	5ac38504 	addi	r11,r11,3604
 3206368:	12cb883a 	add	r5,r2,r11
 320636c:	2c000317 	ldw	r16,12(r5)
 3206370:	580f883a 	mov	r7,r11
 3206374:	2c00041e 	bne	r5,r16,3206388 <_malloc_r+0xdc>
 3206378:	00000a06 	br	32063a4 <_malloc_r+0xf8>
 320637c:	1800860e 	bge	r3,zero,3206598 <_malloc_r+0x2ec>
 3206380:	84000317 	ldw	r16,12(r16)
 3206384:	2c000726 	beq	r5,r16,32063a4 <_malloc_r+0xf8>
 3206388:	80800117 	ldw	r2,4(r16)
 320638c:	00ffff04 	movi	r3,-4
 3206390:	10c8703a 	and	r4,r2,r3
 3206394:	2447c83a 	sub	r3,r4,r17
 3206398:	008003c4 	movi	r2,15
 320639c:	10fff70e 	bge	r2,r3,320637c <_malloc_r+0xd0>
 32063a0:	31bfffc4 	addi	r6,r6,-1
 32063a4:	32400044 	addi	r9,r6,1
 32063a8:	0280c974 	movhi	r10,805
 32063ac:	52838704 	addi	r10,r10,3612
 32063b0:	54000217 	ldw	r16,8(r10)
 32063b4:	8280a026 	beq	r16,r10,3206638 <_malloc_r+0x38c>
 32063b8:	80800117 	ldw	r2,4(r16)
 32063bc:	00ffff04 	movi	r3,-4
 32063c0:	10ca703a 	and	r5,r2,r3
 32063c4:	2c4dc83a 	sub	r6,r5,r17
 32063c8:	008003c4 	movi	r2,15
 32063cc:	11808316 	blt	r2,r6,32065dc <_malloc_r+0x330>
 32063d0:	52800315 	stw	r10,12(r10)
 32063d4:	52800215 	stw	r10,8(r10)
 32063d8:	30002916 	blt	r6,zero,3206480 <_malloc_r+0x1d4>
 32063dc:	8147883a 	add	r3,r16,r5
 32063e0:	18800117 	ldw	r2,4(r3)
 32063e4:	9009883a 	mov	r4,r18
 32063e8:	10800054 	ori	r2,r2,1
 32063ec:	18800115 	stw	r2,4(r3)
 32063f0:	32154780 	call	3215478 <__malloc_unlock>
 32063f4:	80c00204 	addi	r3,r16,8
 32063f8:	003fc006 	br	32062fc <_malloc_r+0x50>
 32063fc:	02c0c974 	movhi	r11,805
 3206400:	5ac38504 	addi	r11,r11,3604
 3206404:	8ac5883a 	add	r2,r17,r11
 3206408:	14000317 	ldw	r16,12(r2)
 320640c:	580f883a 	mov	r7,r11
 3206410:	8806d0fa 	srli	r3,r17,3
 3206414:	14006c26 	beq	r2,r16,32065c8 <_malloc_r+0x31c>
 3206418:	80c00117 	ldw	r3,4(r16)
 320641c:	00bfff04 	movi	r2,-4
 3206420:	81800317 	ldw	r6,12(r16)
 3206424:	1886703a 	and	r3,r3,r2
 3206428:	80c7883a 	add	r3,r16,r3
 320642c:	18800117 	ldw	r2,4(r3)
 3206430:	81400217 	ldw	r5,8(r16)
 3206434:	9009883a 	mov	r4,r18
 3206438:	10800054 	ori	r2,r2,1
 320643c:	18800115 	stw	r2,4(r3)
 3206440:	31400215 	stw	r5,8(r6)
 3206444:	29800315 	stw	r6,12(r5)
 3206448:	32154780 	call	3215478 <__malloc_unlock>
 320644c:	80c00204 	addi	r3,r16,8
 3206450:	003faa06 	br	32062fc <_malloc_r+0x50>
 3206454:	00800104 	movi	r2,4
 3206458:	10c0052e 	bgeu	r2,r3,3206470 <_malloc_r+0x1c4>
 320645c:	00800504 	movi	r2,20
 3206460:	10c07836 	bltu	r2,r3,3206644 <_malloc_r+0x398>
 3206464:	198016c4 	addi	r6,r3,91
 3206468:	300490fa 	slli	r2,r6,3
 320646c:	003fbc06 	br	3206360 <_malloc_r+0xb4>
 3206470:	8804d1ba 	srli	r2,r17,6
 3206474:	11800e04 	addi	r6,r2,56
 3206478:	300490fa 	slli	r2,r6,3
 320647c:	003fb806 	br	3206360 <_malloc_r+0xb4>
 3206480:	00807fc4 	movi	r2,511
 3206484:	1140bb36 	bltu	r2,r5,3206774 <_malloc_r+0x4c8>
 3206488:	2806d0fa 	srli	r3,r5,3
 320648c:	573ffe04 	addi	fp,r10,-8
 3206490:	00800044 	movi	r2,1
 3206494:	180890fa 	slli	r4,r3,3
 3206498:	1807d0ba 	srai	r3,r3,2
 320649c:	e1c00117 	ldw	r7,4(fp)
 32064a0:	5909883a 	add	r4,r11,r4
 32064a4:	21400217 	ldw	r5,8(r4)
 32064a8:	10c4983a 	sll	r2,r2,r3
 32064ac:	81000315 	stw	r4,12(r16)
 32064b0:	81400215 	stw	r5,8(r16)
 32064b4:	388eb03a 	or	r7,r7,r2
 32064b8:	2c000315 	stw	r16,12(r5)
 32064bc:	24000215 	stw	r16,8(r4)
 32064c0:	e1c00115 	stw	r7,4(fp)
 32064c4:	4807883a 	mov	r3,r9
 32064c8:	4800cd16 	blt	r9,zero,3206800 <_malloc_r+0x554>
 32064cc:	1807d0ba 	srai	r3,r3,2
 32064d0:	00800044 	movi	r2,1
 32064d4:	10c8983a 	sll	r4,r2,r3
 32064d8:	39004436 	bltu	r7,r4,32065ec <_malloc_r+0x340>
 32064dc:	21c4703a 	and	r2,r4,r7
 32064e0:	10000a1e 	bne	r2,zero,320650c <_malloc_r+0x260>
 32064e4:	2109883a 	add	r4,r4,r4
 32064e8:	00bfff04 	movi	r2,-4
 32064ec:	4884703a 	and	r2,r9,r2
 32064f0:	3906703a 	and	r3,r7,r4
 32064f4:	12400104 	addi	r9,r2,4
 32064f8:	1800041e 	bne	r3,zero,320650c <_malloc_r+0x260>
 32064fc:	2109883a 	add	r4,r4,r4
 3206500:	3904703a 	and	r2,r7,r4
 3206504:	4a400104 	addi	r9,r9,4
 3206508:	103ffc26 	beq	r2,zero,32064fc <_malloc_r+0x250>
 320650c:	480490fa 	slli	r2,r9,3
 3206510:	4819883a 	mov	r12,r9
 3206514:	023fff04 	movi	r8,-4
 3206518:	589b883a 	add	r13,r11,r2
 320651c:	6807883a 	mov	r3,r13
 3206520:	014003c4 	movi	r5,15
 3206524:	1c000317 	ldw	r16,12(r3)
 3206528:	1c00041e 	bne	r3,r16,320653c <_malloc_r+0x290>
 320652c:	0000a706 	br	32067cc <_malloc_r+0x520>
 3206530:	3000ab0e 	bge	r6,zero,32067e0 <_malloc_r+0x534>
 3206534:	84000317 	ldw	r16,12(r16)
 3206538:	1c00a426 	beq	r3,r16,32067cc <_malloc_r+0x520>
 320653c:	80800117 	ldw	r2,4(r16)
 3206540:	1204703a 	and	r2,r2,r8
 3206544:	144dc83a 	sub	r6,r2,r17
 3206548:	29bff90e 	bge	r5,r6,3206530 <_malloc_r+0x284>
 320654c:	81000317 	ldw	r4,12(r16)
 3206550:	80c00217 	ldw	r3,8(r16)
 3206554:	89400054 	ori	r5,r17,1
 3206558:	8445883a 	add	r2,r16,r17
 320655c:	20c00215 	stw	r3,8(r4)
 3206560:	19000315 	stw	r4,12(r3)
 3206564:	81400115 	stw	r5,4(r16)
 3206568:	1187883a 	add	r3,r2,r6
 320656c:	31000054 	ori	r4,r6,1
 3206570:	50800315 	stw	r2,12(r10)
 3206574:	50800215 	stw	r2,8(r10)
 3206578:	19800015 	stw	r6,0(r3)
 320657c:	11000115 	stw	r4,4(r2)
 3206580:	12800215 	stw	r10,8(r2)
 3206584:	12800315 	stw	r10,12(r2)
 3206588:	9009883a 	mov	r4,r18
 320658c:	32154780 	call	3215478 <__malloc_unlock>
 3206590:	80c00204 	addi	r3,r16,8
 3206594:	003f5906 	br	32062fc <_malloc_r+0x50>
 3206598:	8109883a 	add	r4,r16,r4
 320659c:	20800117 	ldw	r2,4(r4)
 32065a0:	80c00217 	ldw	r3,8(r16)
 32065a4:	81400317 	ldw	r5,12(r16)
 32065a8:	10800054 	ori	r2,r2,1
 32065ac:	20800115 	stw	r2,4(r4)
 32065b0:	28c00215 	stw	r3,8(r5)
 32065b4:	19400315 	stw	r5,12(r3)
 32065b8:	9009883a 	mov	r4,r18
 32065bc:	32154780 	call	3215478 <__malloc_unlock>
 32065c0:	80c00204 	addi	r3,r16,8
 32065c4:	003f4d06 	br	32062fc <_malloc_r+0x50>
 32065c8:	80800204 	addi	r2,r16,8
 32065cc:	14000317 	ldw	r16,12(r2)
 32065d0:	143f911e 	bne	r2,r16,3206418 <_malloc_r+0x16c>
 32065d4:	1a400084 	addi	r9,r3,2
 32065d8:	003f7306 	br	32063a8 <_malloc_r+0xfc>
 32065dc:	88c00054 	ori	r3,r17,1
 32065e0:	8445883a 	add	r2,r16,r17
 32065e4:	80c00115 	stw	r3,4(r16)
 32065e8:	003fdf06 	br	3206568 <_malloc_r+0x2bc>
 32065ec:	e4000217 	ldw	r16,8(fp)
 32065f0:	00bfff04 	movi	r2,-4
 32065f4:	80c00117 	ldw	r3,4(r16)
 32065f8:	802d883a 	mov	r22,r16
 32065fc:	18aa703a 	and	r21,r3,r2
 3206600:	ac401636 	bltu	r21,r17,320665c <_malloc_r+0x3b0>
 3206604:	ac49c83a 	sub	r4,r21,r17
 3206608:	008003c4 	movi	r2,15
 320660c:	1100130e 	bge	r2,r4,320665c <_malloc_r+0x3b0>
 3206610:	88800054 	ori	r2,r17,1
 3206614:	8447883a 	add	r3,r16,r17
 3206618:	80800115 	stw	r2,4(r16)
 320661c:	20800054 	ori	r2,r4,1
 3206620:	18800115 	stw	r2,4(r3)
 3206624:	e0c00215 	stw	r3,8(fp)
 3206628:	9009883a 	mov	r4,r18
 320662c:	32154780 	call	3215478 <__malloc_unlock>
 3206630:	80c00204 	addi	r3,r16,8
 3206634:	003f3106 	br	32062fc <_malloc_r+0x50>
 3206638:	39c00117 	ldw	r7,4(r7)
 320663c:	573ffe04 	addi	fp,r10,-8
 3206640:	003fa006 	br	32064c4 <_malloc_r+0x218>
 3206644:	00801504 	movi	r2,84
 3206648:	10c06736 	bltu	r2,r3,32067e8 <_malloc_r+0x53c>
 320664c:	8804d33a 	srli	r2,r17,12
 3206650:	11801b84 	addi	r6,r2,110
 3206654:	300490fa 	slli	r2,r6,3
 3206658:	003f4106 	br	3206360 <_malloc_r+0xb4>
 320665c:	d0a89717 	ldw	r2,-23972(gp)
 3206660:	d0e00417 	ldw	r3,-32752(gp)
 3206664:	053fffc4 	movi	r20,-1
 3206668:	10800404 	addi	r2,r2,16
 320666c:	88a7883a 	add	r19,r17,r2
 3206670:	1d000326 	beq	r3,r20,3206680 <_malloc_r+0x3d4>
 3206674:	98c3ffc4 	addi	r3,r19,4095
 3206678:	00bc0004 	movi	r2,-4096
 320667c:	18a6703a 	and	r19,r3,r2
 3206680:	9009883a 	mov	r4,r18
 3206684:	980b883a 	mov	r5,r19
 3206688:	32079500 	call	3207950 <_sbrk_r>
 320668c:	1009883a 	mov	r4,r2
 3206690:	15000426 	beq	r2,r20,32066a4 <_malloc_r+0x3f8>
 3206694:	854b883a 	add	r5,r16,r21
 3206698:	1029883a 	mov	r20,r2
 320669c:	11405a2e 	bgeu	r2,r5,3206808 <_malloc_r+0x55c>
 32066a0:	87000c26 	beq	r16,fp,32066d4 <_malloc_r+0x428>
 32066a4:	e4000217 	ldw	r16,8(fp)
 32066a8:	80c00117 	ldw	r3,4(r16)
 32066ac:	00bfff04 	movi	r2,-4
 32066b0:	1884703a 	and	r2,r3,r2
 32066b4:	14400336 	bltu	r2,r17,32066c4 <_malloc_r+0x418>
 32066b8:	1449c83a 	sub	r4,r2,r17
 32066bc:	008003c4 	movi	r2,15
 32066c0:	113fd316 	blt	r2,r4,3206610 <_malloc_r+0x364>
 32066c4:	9009883a 	mov	r4,r18
 32066c8:	32154780 	call	3215478 <__malloc_unlock>
 32066cc:	0007883a 	mov	r3,zero
 32066d0:	003f0a06 	br	32062fc <_malloc_r+0x50>
 32066d4:	05c0c974 	movhi	r23,805
 32066d8:	bdd57b04 	addi	r23,r23,21996
 32066dc:	b8800017 	ldw	r2,0(r23)
 32066e0:	988d883a 	add	r6,r19,r2
 32066e4:	b9800015 	stw	r6,0(r23)
 32066e8:	d0e00417 	ldw	r3,-32752(gp)
 32066ec:	00bfffc4 	movi	r2,-1
 32066f0:	18808e26 	beq	r3,r2,320692c <_malloc_r+0x680>
 32066f4:	2145c83a 	sub	r2,r4,r5
 32066f8:	3085883a 	add	r2,r6,r2
 32066fc:	b8800015 	stw	r2,0(r23)
 3206700:	20c001cc 	andi	r3,r4,7
 3206704:	18005f1e 	bne	r3,zero,3206884 <_malloc_r+0x5d8>
 3206708:	000b883a 	mov	r5,zero
 320670c:	a4c5883a 	add	r2,r20,r19
 3206710:	1083ffcc 	andi	r2,r2,4095
 3206714:	00c40004 	movi	r3,4096
 3206718:	1887c83a 	sub	r3,r3,r2
 320671c:	28e7883a 	add	r19,r5,r3
 3206720:	9009883a 	mov	r4,r18
 3206724:	980b883a 	mov	r5,r19
 3206728:	32079500 	call	3207950 <_sbrk_r>
 320672c:	1007883a 	mov	r3,r2
 3206730:	00bfffc4 	movi	r2,-1
 3206734:	18807a26 	beq	r3,r2,3206920 <_malloc_r+0x674>
 3206738:	1d05c83a 	sub	r2,r3,r20
 320673c:	9885883a 	add	r2,r19,r2
 3206740:	10c00054 	ori	r3,r2,1
 3206744:	b8800017 	ldw	r2,0(r23)
 3206748:	a021883a 	mov	r16,r20
 320674c:	a0c00115 	stw	r3,4(r20)
 3206750:	9885883a 	add	r2,r19,r2
 3206754:	b8800015 	stw	r2,0(r23)
 3206758:	e5000215 	stw	r20,8(fp)
 320675c:	b7003626 	beq	r22,fp,3206838 <_malloc_r+0x58c>
 3206760:	018003c4 	movi	r6,15
 3206764:	35404b36 	bltu	r6,r21,3206894 <_malloc_r+0x5e8>
 3206768:	00800044 	movi	r2,1
 320676c:	a0800115 	stw	r2,4(r20)
 3206770:	003fcd06 	br	32066a8 <_malloc_r+0x3fc>
 3206774:	2808d27a 	srli	r4,r5,9
 3206778:	2000371e 	bne	r4,zero,3206858 <_malloc_r+0x5ac>
 320677c:	2808d0fa 	srli	r4,r5,3
 3206780:	200690fa 	slli	r3,r4,3
 3206784:	1ad1883a 	add	r8,r3,r11
 3206788:	41800217 	ldw	r6,8(r8)
 320678c:	41805b26 	beq	r8,r6,32068fc <_malloc_r+0x650>
 3206790:	30800117 	ldw	r2,4(r6)
 3206794:	00ffff04 	movi	r3,-4
 3206798:	10c4703a 	and	r2,r2,r3
 320679c:	2880022e 	bgeu	r5,r2,32067a8 <_malloc_r+0x4fc>
 32067a0:	31800217 	ldw	r6,8(r6)
 32067a4:	41bffa1e 	bne	r8,r6,3206790 <_malloc_r+0x4e4>
 32067a8:	32000317 	ldw	r8,12(r6)
 32067ac:	39c00117 	ldw	r7,4(r7)
 32067b0:	82000315 	stw	r8,12(r16)
 32067b4:	81800215 	stw	r6,8(r16)
 32067b8:	0700c974 	movhi	fp,805
 32067bc:	e7038504 	addi	fp,fp,3604
 32067c0:	34000315 	stw	r16,12(r6)
 32067c4:	44000215 	stw	r16,8(r8)
 32067c8:	003f3e06 	br	32064c4 <_malloc_r+0x218>
 32067cc:	63000044 	addi	r12,r12,1
 32067d0:	608000cc 	andi	r2,r12,3
 32067d4:	10005d26 	beq	r2,zero,320694c <_malloc_r+0x6a0>
 32067d8:	18c00204 	addi	r3,r3,8
 32067dc:	003f5106 	br	3206524 <_malloc_r+0x278>
 32067e0:	8089883a 	add	r4,r16,r2
 32067e4:	003f6d06 	br	320659c <_malloc_r+0x2f0>
 32067e8:	00805504 	movi	r2,340
 32067ec:	10c02036 	bltu	r2,r3,3206870 <_malloc_r+0x5c4>
 32067f0:	8804d3fa 	srli	r2,r17,15
 32067f4:	11801dc4 	addi	r6,r2,119
 32067f8:	300490fa 	slli	r2,r6,3
 32067fc:	003ed806 	br	3206360 <_malloc_r+0xb4>
 3206800:	48c000c4 	addi	r3,r9,3
 3206804:	003f3106 	br	32064cc <_malloc_r+0x220>
 3206808:	05c0c974 	movhi	r23,805
 320680c:	bdd57b04 	addi	r23,r23,21996
 3206810:	b8800017 	ldw	r2,0(r23)
 3206814:	988d883a 	add	r6,r19,r2
 3206818:	b9800015 	stw	r6,0(r23)
 320681c:	293fb21e 	bne	r5,r4,32066e8 <_malloc_r+0x43c>
 3206820:	2083ffcc 	andi	r2,r4,4095
 3206824:	103fb01e 	bne	r2,zero,32066e8 <_malloc_r+0x43c>
 3206828:	e4000217 	ldw	r16,8(fp)
 320682c:	9d45883a 	add	r2,r19,r21
 3206830:	10800054 	ori	r2,r2,1
 3206834:	80800115 	stw	r2,4(r16)
 3206838:	b8c00017 	ldw	r3,0(r23)
 320683c:	d0a89817 	ldw	r2,-23968(gp)
 3206840:	10c0012e 	bgeu	r2,r3,3206848 <_malloc_r+0x59c>
 3206844:	d0e89815 	stw	r3,-23968(gp)
 3206848:	d0a89917 	ldw	r2,-23964(gp)
 320684c:	10ff962e 	bgeu	r2,r3,32066a8 <_malloc_r+0x3fc>
 3206850:	d0e89915 	stw	r3,-23964(gp)
 3206854:	003f9406 	br	32066a8 <_malloc_r+0x3fc>
 3206858:	00800104 	movi	r2,4
 320685c:	11001e36 	bltu	r2,r4,32068d8 <_malloc_r+0x62c>
 3206860:	2804d1ba 	srli	r2,r5,6
 3206864:	11000e04 	addi	r4,r2,56
 3206868:	200690fa 	slli	r3,r4,3
 320686c:	003fc506 	br	3206784 <_malloc_r+0x4d8>
 3206870:	00815504 	movi	r2,1364
 3206874:	10c01d2e 	bgeu	r2,r3,32068ec <_malloc_r+0x640>
 3206878:	01801f84 	movi	r6,126
 320687c:	0080fc04 	movi	r2,1008
 3206880:	003eb706 	br	3206360 <_malloc_r+0xb4>
 3206884:	00800204 	movi	r2,8
 3206888:	10cbc83a 	sub	r5,r2,r3
 320688c:	2169883a 	add	r20,r4,r5
 3206890:	003f9e06 	br	320670c <_malloc_r+0x460>
 3206894:	00bffe04 	movi	r2,-8
 3206898:	a93ffd04 	addi	r4,r21,-12
 320689c:	2088703a 	and	r4,r4,r2
 32068a0:	b10b883a 	add	r5,r22,r4
 32068a4:	00c00144 	movi	r3,5
 32068a8:	28c00215 	stw	r3,8(r5)
 32068ac:	28c00115 	stw	r3,4(r5)
 32068b0:	b0800117 	ldw	r2,4(r22)
 32068b4:	1080004c 	andi	r2,r2,1
 32068b8:	2084b03a 	or	r2,r4,r2
 32068bc:	b0800115 	stw	r2,4(r22)
 32068c0:	313fdd2e 	bgeu	r6,r4,3206838 <_malloc_r+0x58c>
 32068c4:	b1400204 	addi	r5,r22,8
 32068c8:	9009883a 	mov	r4,r18
 32068cc:	32051100 	call	3205110 <_free_r>
 32068d0:	e4000217 	ldw	r16,8(fp)
 32068d4:	003fd806 	br	3206838 <_malloc_r+0x58c>
 32068d8:	00800504 	movi	r2,20
 32068dc:	11001536 	bltu	r2,r4,3206934 <_malloc_r+0x688>
 32068e0:	210016c4 	addi	r4,r4,91
 32068e4:	200690fa 	slli	r3,r4,3
 32068e8:	003fa606 	br	3206784 <_malloc_r+0x4d8>
 32068ec:	8804d4ba 	srli	r2,r17,18
 32068f0:	11801f04 	addi	r6,r2,124
 32068f4:	300490fa 	slli	r2,r6,3
 32068f8:	003e9906 	br	3206360 <_malloc_r+0xb4>
 32068fc:	2009d0ba 	srai	r4,r4,2
 3206900:	0140c974 	movhi	r5,805
 3206904:	29438504 	addi	r5,r5,3604
 3206908:	00c00044 	movi	r3,1
 320690c:	28800117 	ldw	r2,4(r5)
 3206910:	1906983a 	sll	r3,r3,r4
 3206914:	10c4b03a 	or	r2,r2,r3
 3206918:	28800115 	stw	r2,4(r5)
 320691c:	003fa306 	br	32067ac <_malloc_r+0x500>
 3206920:	0027883a 	mov	r19,zero
 3206924:	00c00044 	movi	r3,1
 3206928:	003f8606 	br	3206744 <_malloc_r+0x498>
 320692c:	d1200415 	stw	r4,-32752(gp)
 3206930:	003f7306 	br	3206700 <_malloc_r+0x454>
 3206934:	00801504 	movi	r2,84
 3206938:	11001936 	bltu	r2,r4,32069a0 <_malloc_r+0x6f4>
 320693c:	2804d33a 	srli	r2,r5,12
 3206940:	11001b84 	addi	r4,r2,110
 3206944:	200690fa 	slli	r3,r4,3
 3206948:	003f8e06 	br	3206784 <_malloc_r+0x4d8>
 320694c:	480b883a 	mov	r5,r9
 3206950:	6807883a 	mov	r3,r13
 3206954:	288000cc 	andi	r2,r5,3
 3206958:	18fffe04 	addi	r3,r3,-8
 320695c:	297fffc4 	addi	r5,r5,-1
 3206960:	10001526 	beq	r2,zero,32069b8 <_malloc_r+0x70c>
 3206964:	18800217 	ldw	r2,8(r3)
 3206968:	10fffa26 	beq	r2,r3,3206954 <_malloc_r+0x6a8>
 320696c:	2109883a 	add	r4,r4,r4
 3206970:	393f1e36 	bltu	r7,r4,32065ec <_malloc_r+0x340>
 3206974:	203f1d26 	beq	r4,zero,32065ec <_malloc_r+0x340>
 3206978:	21c4703a 	and	r2,r4,r7
 320697c:	10000226 	beq	r2,zero,3206988 <_malloc_r+0x6dc>
 3206980:	6013883a 	mov	r9,r12
 3206984:	003ee106 	br	320650c <_malloc_r+0x260>
 3206988:	2109883a 	add	r4,r4,r4
 320698c:	3904703a 	and	r2,r7,r4
 3206990:	63000104 	addi	r12,r12,4
 3206994:	103ffc26 	beq	r2,zero,3206988 <_malloc_r+0x6dc>
 3206998:	6013883a 	mov	r9,r12
 320699c:	003edb06 	br	320650c <_malloc_r+0x260>
 32069a0:	00805504 	movi	r2,340
 32069a4:	11000836 	bltu	r2,r4,32069c8 <_malloc_r+0x71c>
 32069a8:	2804d3fa 	srli	r2,r5,15
 32069ac:	11001dc4 	addi	r4,r2,119
 32069b0:	200690fa 	slli	r3,r4,3
 32069b4:	003f7306 	br	3206784 <_malloc_r+0x4d8>
 32069b8:	0104303a 	nor	r2,zero,r4
 32069bc:	388e703a 	and	r7,r7,r2
 32069c0:	e1c00115 	stw	r7,4(fp)
 32069c4:	003fe906 	br	320696c <_malloc_r+0x6c0>
 32069c8:	00815504 	movi	r2,1364
 32069cc:	1100032e 	bgeu	r2,r4,32069dc <_malloc_r+0x730>
 32069d0:	01001f84 	movi	r4,126
 32069d4:	00c0fc04 	movi	r3,1008
 32069d8:	003f6a06 	br	3206784 <_malloc_r+0x4d8>
 32069dc:	2804d4ba 	srli	r2,r5,18
 32069e0:	11001f04 	addi	r4,r2,124
 32069e4:	200690fa 	slli	r3,r4,3
 32069e8:	003f6606 	br	3206784 <_malloc_r+0x4d8>

032069ec <memchr>:
 32069ec:	008000c4 	movi	r2,3
 32069f0:	29403fcc 	andi	r5,r5,255
 32069f4:	2007883a 	mov	r3,r4
 32069f8:	1180022e 	bgeu	r2,r6,3206a04 <memchr+0x18>
 32069fc:	2084703a 	and	r2,r4,r2
 3206a00:	10000b26 	beq	r2,zero,3206a30 <memchr+0x44>
 3206a04:	313fffc4 	addi	r4,r6,-1
 3206a08:	3000051e 	bne	r6,zero,3206a20 <memchr+0x34>
 3206a0c:	00002c06 	br	3206ac0 <memchr+0xd4>
 3206a10:	213fffc4 	addi	r4,r4,-1
 3206a14:	00bfffc4 	movi	r2,-1
 3206a18:	18c00044 	addi	r3,r3,1
 3206a1c:	20802826 	beq	r4,r2,3206ac0 <memchr+0xd4>
 3206a20:	18800003 	ldbu	r2,0(r3)
 3206a24:	28bffa1e 	bne	r5,r2,3206a10 <memchr+0x24>
 3206a28:	1805883a 	mov	r2,r3
 3206a2c:	f800283a 	ret
 3206a30:	0011883a 	mov	r8,zero
 3206a34:	0007883a 	mov	r3,zero
 3206a38:	01c00104 	movi	r7,4
 3206a3c:	4004923a 	slli	r2,r8,8
 3206a40:	18c00044 	addi	r3,r3,1
 3206a44:	1151883a 	add	r8,r2,r5
 3206a48:	19fffc1e 	bne	r3,r7,3206a3c <memchr+0x50>
 3206a4c:	02bfbff4 	movhi	r10,65279
 3206a50:	52bfbfc4 	addi	r10,r10,-257
 3206a54:	02602074 	movhi	r9,32897
 3206a58:	4a602004 	addi	r9,r9,-32640
 3206a5c:	02c000c4 	movi	r11,3
 3206a60:	20800017 	ldw	r2,0(r4)
 3206a64:	31bfff04 	addi	r6,r6,-4
 3206a68:	200f883a 	mov	r7,r4
 3206a6c:	1204f03a 	xor	r2,r2,r8
 3206a70:	1287883a 	add	r3,r2,r10
 3206a74:	1a46703a 	and	r3,r3,r9
 3206a78:	0084303a 	nor	r2,zero,r2
 3206a7c:	10c4703a 	and	r2,r2,r3
 3206a80:	10000b26 	beq	r2,zero,3206ab0 <memchr+0xc4>
 3206a84:	20800003 	ldbu	r2,0(r4)
 3206a88:	28800f26 	beq	r5,r2,3206ac8 <memchr+0xdc>
 3206a8c:	20800043 	ldbu	r2,1(r4)
 3206a90:	21c00044 	addi	r7,r4,1
 3206a94:	28800c26 	beq	r5,r2,3206ac8 <memchr+0xdc>
 3206a98:	20800083 	ldbu	r2,2(r4)
 3206a9c:	21c00084 	addi	r7,r4,2
 3206aa0:	28800926 	beq	r5,r2,3206ac8 <memchr+0xdc>
 3206aa4:	208000c3 	ldbu	r2,3(r4)
 3206aa8:	21c000c4 	addi	r7,r4,3
 3206aac:	28800626 	beq	r5,r2,3206ac8 <memchr+0xdc>
 3206ab0:	21000104 	addi	r4,r4,4
 3206ab4:	59bfea36 	bltu	r11,r6,3206a60 <memchr+0x74>
 3206ab8:	2007883a 	mov	r3,r4
 3206abc:	003fd106 	br	3206a04 <memchr+0x18>
 3206ac0:	0005883a 	mov	r2,zero
 3206ac4:	f800283a 	ret
 3206ac8:	3805883a 	mov	r2,r7
 3206acc:	f800283a 	ret

03206ad0 <memcpy>:
 3206ad0:	01c003c4 	movi	r7,15
 3206ad4:	2007883a 	mov	r3,r4
 3206ad8:	3980032e 	bgeu	r7,r6,3206ae8 <memcpy+0x18>
 3206adc:	2904b03a 	or	r2,r5,r4
 3206ae0:	108000cc 	andi	r2,r2,3
 3206ae4:	10000926 	beq	r2,zero,3206b0c <memcpy+0x3c>
 3206ae8:	30000626 	beq	r6,zero,3206b04 <memcpy+0x34>
 3206aec:	30cd883a 	add	r6,r6,r3
 3206af0:	28800003 	ldbu	r2,0(r5)
 3206af4:	29400044 	addi	r5,r5,1
 3206af8:	18800005 	stb	r2,0(r3)
 3206afc:	18c00044 	addi	r3,r3,1
 3206b00:	30fffb1e 	bne	r6,r3,3206af0 <memcpy+0x20>
 3206b04:	2005883a 	mov	r2,r4
 3206b08:	f800283a 	ret
 3206b0c:	3811883a 	mov	r8,r7
 3206b10:	200f883a 	mov	r7,r4
 3206b14:	28c00017 	ldw	r3,0(r5)
 3206b18:	31bffc04 	addi	r6,r6,-16
 3206b1c:	38c00015 	stw	r3,0(r7)
 3206b20:	28800117 	ldw	r2,4(r5)
 3206b24:	38800115 	stw	r2,4(r7)
 3206b28:	28c00217 	ldw	r3,8(r5)
 3206b2c:	38c00215 	stw	r3,8(r7)
 3206b30:	28800317 	ldw	r2,12(r5)
 3206b34:	29400404 	addi	r5,r5,16
 3206b38:	38800315 	stw	r2,12(r7)
 3206b3c:	39c00404 	addi	r7,r7,16
 3206b40:	41bff436 	bltu	r8,r6,3206b14 <memcpy+0x44>
 3206b44:	008000c4 	movi	r2,3
 3206b48:	1180072e 	bgeu	r2,r6,3206b68 <memcpy+0x98>
 3206b4c:	1007883a 	mov	r3,r2
 3206b50:	28800017 	ldw	r2,0(r5)
 3206b54:	31bfff04 	addi	r6,r6,-4
 3206b58:	29400104 	addi	r5,r5,4
 3206b5c:	38800015 	stw	r2,0(r7)
 3206b60:	39c00104 	addi	r7,r7,4
 3206b64:	19bffa36 	bltu	r3,r6,3206b50 <memcpy+0x80>
 3206b68:	3807883a 	mov	r3,r7
 3206b6c:	003fde06 	br	3206ae8 <memcpy+0x18>

03206b70 <memmove>:
 3206b70:	2807883a 	mov	r3,r5
 3206b74:	2011883a 	mov	r8,r4
 3206b78:	29000c2e 	bgeu	r5,r4,3206bac <memmove+0x3c>
 3206b7c:	298f883a 	add	r7,r5,r6
 3206b80:	21c00a2e 	bgeu	r4,r7,3206bac <memmove+0x3c>
 3206b84:	30000726 	beq	r6,zero,3206ba4 <memmove+0x34>
 3206b88:	2187883a 	add	r3,r4,r6
 3206b8c:	198dc83a 	sub	r6,r3,r6
 3206b90:	39ffffc4 	addi	r7,r7,-1
 3206b94:	38800003 	ldbu	r2,0(r7)
 3206b98:	18ffffc4 	addi	r3,r3,-1
 3206b9c:	18800005 	stb	r2,0(r3)
 3206ba0:	19bffb1e 	bne	r3,r6,3206b90 <memmove+0x20>
 3206ba4:	2005883a 	mov	r2,r4
 3206ba8:	f800283a 	ret
 3206bac:	01c003c4 	movi	r7,15
 3206bb0:	39800a36 	bltu	r7,r6,3206bdc <memmove+0x6c>
 3206bb4:	303ffb26 	beq	r6,zero,3206ba4 <memmove+0x34>
 3206bb8:	400f883a 	mov	r7,r8
 3206bbc:	320d883a 	add	r6,r6,r8
 3206bc0:	28800003 	ldbu	r2,0(r5)
 3206bc4:	29400044 	addi	r5,r5,1
 3206bc8:	38800005 	stb	r2,0(r7)
 3206bcc:	39c00044 	addi	r7,r7,1
 3206bd0:	39bffb1e 	bne	r7,r6,3206bc0 <memmove+0x50>
 3206bd4:	2005883a 	mov	r2,r4
 3206bd8:	f800283a 	ret
 3206bdc:	1904b03a 	or	r2,r3,r4
 3206be0:	108000cc 	andi	r2,r2,3
 3206be4:	103ff31e 	bne	r2,zero,3206bb4 <memmove+0x44>
 3206be8:	3811883a 	mov	r8,r7
 3206bec:	180b883a 	mov	r5,r3
 3206bf0:	200f883a 	mov	r7,r4
 3206bf4:	28c00017 	ldw	r3,0(r5)
 3206bf8:	31bffc04 	addi	r6,r6,-16
 3206bfc:	38c00015 	stw	r3,0(r7)
 3206c00:	28800117 	ldw	r2,4(r5)
 3206c04:	38800115 	stw	r2,4(r7)
 3206c08:	28c00217 	ldw	r3,8(r5)
 3206c0c:	38c00215 	stw	r3,8(r7)
 3206c10:	28800317 	ldw	r2,12(r5)
 3206c14:	29400404 	addi	r5,r5,16
 3206c18:	38800315 	stw	r2,12(r7)
 3206c1c:	39c00404 	addi	r7,r7,16
 3206c20:	41bff436 	bltu	r8,r6,3206bf4 <memmove+0x84>
 3206c24:	008000c4 	movi	r2,3
 3206c28:	1180072e 	bgeu	r2,r6,3206c48 <memmove+0xd8>
 3206c2c:	1007883a 	mov	r3,r2
 3206c30:	28800017 	ldw	r2,0(r5)
 3206c34:	31bfff04 	addi	r6,r6,-4
 3206c38:	29400104 	addi	r5,r5,4
 3206c3c:	38800015 	stw	r2,0(r7)
 3206c40:	39c00104 	addi	r7,r7,4
 3206c44:	19bffa36 	bltu	r3,r6,3206c30 <memmove+0xc0>
 3206c48:	3811883a 	mov	r8,r7
 3206c4c:	003fd906 	br	3206bb4 <memmove+0x44>

03206c50 <memset>:
 3206c50:	008000c4 	movi	r2,3
 3206c54:	29403fcc 	andi	r5,r5,255
 3206c58:	2007883a 	mov	r3,r4
 3206c5c:	1180022e 	bgeu	r2,r6,3206c68 <memset+0x18>
 3206c60:	2084703a 	and	r2,r4,r2
 3206c64:	10000826 	beq	r2,zero,3206c88 <memset+0x38>
 3206c68:	30000526 	beq	r6,zero,3206c80 <memset+0x30>
 3206c6c:	2805883a 	mov	r2,r5
 3206c70:	30cd883a 	add	r6,r6,r3
 3206c74:	18800005 	stb	r2,0(r3)
 3206c78:	18c00044 	addi	r3,r3,1
 3206c7c:	19bffd1e 	bne	r3,r6,3206c74 <memset+0x24>
 3206c80:	2005883a 	mov	r2,r4
 3206c84:	f800283a 	ret
 3206c88:	2804923a 	slli	r2,r5,8
 3206c8c:	020003c4 	movi	r8,15
 3206c90:	200f883a 	mov	r7,r4
 3206c94:	2884b03a 	or	r2,r5,r2
 3206c98:	1006943a 	slli	r3,r2,16
 3206c9c:	10c6b03a 	or	r3,r2,r3
 3206ca0:	41800a2e 	bgeu	r8,r6,3206ccc <memset+0x7c>
 3206ca4:	4005883a 	mov	r2,r8
 3206ca8:	31bffc04 	addi	r6,r6,-16
 3206cac:	38c00015 	stw	r3,0(r7)
 3206cb0:	38c00115 	stw	r3,4(r7)
 3206cb4:	38c00215 	stw	r3,8(r7)
 3206cb8:	38c00315 	stw	r3,12(r7)
 3206cbc:	39c00404 	addi	r7,r7,16
 3206cc0:	11bff936 	bltu	r2,r6,3206ca8 <memset+0x58>
 3206cc4:	008000c4 	movi	r2,3
 3206cc8:	1180052e 	bgeu	r2,r6,3206ce0 <memset+0x90>
 3206ccc:	31bfff04 	addi	r6,r6,-4
 3206cd0:	008000c4 	movi	r2,3
 3206cd4:	38c00015 	stw	r3,0(r7)
 3206cd8:	39c00104 	addi	r7,r7,4
 3206cdc:	11bffb36 	bltu	r2,r6,3206ccc <memset+0x7c>
 3206ce0:	3807883a 	mov	r3,r7
 3206ce4:	003fe006 	br	3206c68 <memset+0x18>

03206ce8 <_open_r>:
 3206ce8:	defffd04 	addi	sp,sp,-12
 3206cec:	dc000015 	stw	r16,0(sp)
 3206cf0:	0400c974 	movhi	r16,805
 3206cf4:	8412f804 	addi	r16,r16,19424
 3206cf8:	dc400115 	stw	r17,4(sp)
 3206cfc:	80000015 	stw	zero,0(r16)
 3206d00:	2023883a 	mov	r17,r4
 3206d04:	2809883a 	mov	r4,r5
 3206d08:	300b883a 	mov	r5,r6
 3206d0c:	380d883a 	mov	r6,r7
 3206d10:	dfc00215 	stw	ra,8(sp)
 3206d14:	3214f640 	call	3214f64 <open>
 3206d18:	1007883a 	mov	r3,r2
 3206d1c:	00bfffc4 	movi	r2,-1
 3206d20:	18800626 	beq	r3,r2,3206d3c <_open_r+0x54>
 3206d24:	1805883a 	mov	r2,r3
 3206d28:	dfc00217 	ldw	ra,8(sp)
 3206d2c:	dc400117 	ldw	r17,4(sp)
 3206d30:	dc000017 	ldw	r16,0(sp)
 3206d34:	dec00304 	addi	sp,sp,12
 3206d38:	f800283a 	ret
 3206d3c:	80800017 	ldw	r2,0(r16)
 3206d40:	103ff826 	beq	r2,zero,3206d24 <_open_r+0x3c>
 3206d44:	88800015 	stw	r2,0(r17)
 3206d48:	1805883a 	mov	r2,r3
 3206d4c:	dfc00217 	ldw	ra,8(sp)
 3206d50:	dc400117 	ldw	r17,4(sp)
 3206d54:	dc000017 	ldw	r16,0(sp)
 3206d58:	dec00304 	addi	sp,sp,12
 3206d5c:	f800283a 	ret

03206d60 <_perror_r>:
 3206d60:	defffe04 	addi	sp,sp,-8
 3206d64:	dc000015 	stw	r16,0(sp)
 3206d68:	dfc00115 	stw	ra,4(sp)
 3206d6c:	2021883a 	mov	r16,r4
 3206d70:	28000326 	beq	r5,zero,3206d80 <_perror_r+0x20>
 3206d74:	28800007 	ldb	r2,0(r5)
 3206d78:	2809883a 	mov	r4,r5
 3206d7c:	10000c1e 	bne	r2,zero,3206db0 <_perror_r+0x50>
 3206d80:	81000017 	ldw	r4,0(r16)
 3206d84:	3207dd40 	call	3207dd4 <strerror>
 3206d88:	1009883a 	mov	r4,r2
 3206d8c:	10000226 	beq	r2,zero,3206d98 <_perror_r+0x38>
 3206d90:	81400317 	ldw	r5,12(r16)
 3206d94:	3204fc80 	call	3204fc8 <fputs>
 3206d98:	81400317 	ldw	r5,12(r16)
 3206d9c:	01000284 	movi	r4,10
 3206da0:	dfc00117 	ldw	ra,4(sp)
 3206da4:	dc000017 	ldw	r16,0(sp)
 3206da8:	dec00204 	addi	sp,sp,8
 3206dac:	320d7481 	jmpi	320d748 <fputc>
 3206db0:	81400317 	ldw	r5,12(r16)
 3206db4:	3204fc80 	call	3204fc8 <fputs>
 3206db8:	81400317 	ldw	r5,12(r16)
 3206dbc:	0100c974 	movhi	r4,805
 3206dc0:	2136aa04 	addi	r4,r4,-9560
 3206dc4:	3204fc80 	call	3204fc8 <fputs>
 3206dc8:	003fed06 	br	3206d80 <_perror_r+0x20>

03206dcc <perror>:
 3206dcc:	0080c974 	movhi	r2,805
 3206dd0:	108a6304 	addi	r2,r2,10636
 3206dd4:	200b883a 	mov	r5,r4
 3206dd8:	11000017 	ldw	r4,0(r2)
 3206ddc:	3206d601 	jmpi	3206d60 <_perror_r>

03206de0 <printf>:
 3206de0:	defffb04 	addi	sp,sp,-20
 3206de4:	dfc00115 	stw	ra,4(sp)
 3206de8:	d9400215 	stw	r5,8(sp)
 3206dec:	d9800315 	stw	r6,12(sp)
 3206df0:	d9c00415 	stw	r7,16(sp)
 3206df4:	0080c974 	movhi	r2,805
 3206df8:	108a6304 	addi	r2,r2,10636
 3206dfc:	10c00017 	ldw	r3,0(r2)
 3206e00:	200b883a 	mov	r5,r4
 3206e04:	d8800204 	addi	r2,sp,8
 3206e08:	19000217 	ldw	r4,8(r3)
 3206e0c:	100d883a 	mov	r6,r2
 3206e10:	d8800015 	stw	r2,0(sp)
 3206e14:	320a3c80 	call	320a3c8 <__vfprintf_internal>
 3206e18:	dfc00117 	ldw	ra,4(sp)
 3206e1c:	dec00504 	addi	sp,sp,20
 3206e20:	f800283a 	ret

03206e24 <_printf_r>:
 3206e24:	defffc04 	addi	sp,sp,-16
 3206e28:	dfc00115 	stw	ra,4(sp)
 3206e2c:	d9800215 	stw	r6,8(sp)
 3206e30:	d9c00315 	stw	r7,12(sp)
 3206e34:	280d883a 	mov	r6,r5
 3206e38:	21400217 	ldw	r5,8(r4)
 3206e3c:	d8c00204 	addi	r3,sp,8
 3206e40:	180f883a 	mov	r7,r3
 3206e44:	d8c00015 	stw	r3,0(sp)
 3206e48:	320851c0 	call	320851c <___vfprintf_internal_r>
 3206e4c:	dfc00117 	ldw	ra,4(sp)
 3206e50:	dec00404 	addi	sp,sp,16
 3206e54:	f800283a 	ret

03206e58 <putc>:
 3206e58:	defffc04 	addi	sp,sp,-16
 3206e5c:	dc800215 	stw	r18,8(sp)
 3206e60:	0480c974 	movhi	r18,805
 3206e64:	948a6304 	addi	r18,r18,10636
 3206e68:	90c00017 	ldw	r3,0(r18)
 3206e6c:	dc400115 	stw	r17,4(sp)
 3206e70:	dc000015 	stw	r16,0(sp)
 3206e74:	dfc00315 	stw	ra,12(sp)
 3206e78:	2023883a 	mov	r17,r4
 3206e7c:	2821883a 	mov	r16,r5
 3206e80:	18000226 	beq	r3,zero,3206e8c <putc+0x34>
 3206e84:	18800e17 	ldw	r2,56(r3)
 3206e88:	10001126 	beq	r2,zero,3206ed0 <putc+0x78>
 3206e8c:	80800217 	ldw	r2,8(r16)
 3206e90:	10ffffc4 	addi	r3,r2,-1
 3206e94:	80c00215 	stw	r3,8(r16)
 3206e98:	18001316 	blt	r3,zero,3206ee8 <putc+0x90>
 3206e9c:	80800017 	ldw	r2,0(r16)
 3206ea0:	14400005 	stb	r17,0(r2)
 3206ea4:	80c00017 	ldw	r3,0(r16)
 3206ea8:	18800044 	addi	r2,r3,1
 3206eac:	18c00003 	ldbu	r3,0(r3)
 3206eb0:	80800015 	stw	r2,0(r16)
 3206eb4:	1805883a 	mov	r2,r3
 3206eb8:	dfc00317 	ldw	ra,12(sp)
 3206ebc:	dc800217 	ldw	r18,8(sp)
 3206ec0:	dc400117 	ldw	r17,4(sp)
 3206ec4:	dc000017 	ldw	r16,0(sp)
 3206ec8:	dec00404 	addi	sp,sp,16
 3206ecc:	f800283a 	ret
 3206ed0:	1809883a 	mov	r4,r3
 3206ed4:	3204b8c0 	call	3204b8c <__sinit>
 3206ed8:	80800217 	ldw	r2,8(r16)
 3206edc:	10ffffc4 	addi	r3,r2,-1
 3206ee0:	80c00215 	stw	r3,8(r16)
 3206ee4:	183fed0e 	bge	r3,zero,3206e9c <putc+0x44>
 3206ee8:	80800617 	ldw	r2,24(r16)
 3206eec:	18800f16 	blt	r3,r2,3206f2c <putc+0xd4>
 3206ef0:	80800017 	ldw	r2,0(r16)
 3206ef4:	14400005 	stb	r17,0(r2)
 3206ef8:	81000017 	ldw	r4,0(r16)
 3206efc:	00800284 	movi	r2,10
 3206f00:	20c00003 	ldbu	r3,0(r4)
 3206f04:	18801226 	beq	r3,r2,3206f50 <putc+0xf8>
 3206f08:	20800044 	addi	r2,r4,1
 3206f0c:	80800015 	stw	r2,0(r16)
 3206f10:	1805883a 	mov	r2,r3
 3206f14:	dfc00317 	ldw	ra,12(sp)
 3206f18:	dc800217 	ldw	r18,8(sp)
 3206f1c:	dc400117 	ldw	r17,4(sp)
 3206f20:	dc000017 	ldw	r16,0(sp)
 3206f24:	dec00404 	addi	sp,sp,16
 3206f28:	f800283a 	ret
 3206f2c:	91000017 	ldw	r4,0(r18)
 3206f30:	880b883a 	mov	r5,r17
 3206f34:	800d883a 	mov	r6,r16
 3206f38:	dfc00317 	ldw	ra,12(sp)
 3206f3c:	dc800217 	ldw	r18,8(sp)
 3206f40:	dc400117 	ldw	r17,4(sp)
 3206f44:	dc000017 	ldw	r16,0(sp)
 3206f48:	dec00404 	addi	sp,sp,16
 3206f4c:	320bb6c1 	jmpi	320bb6c <__swbuf_r>
 3206f50:	91000017 	ldw	r4,0(r18)
 3206f54:	180b883a 	mov	r5,r3
 3206f58:	003ff606 	br	3206f34 <putc+0xdc>

03206f5c <_putc_r>:
 3206f5c:	defffc04 	addi	sp,sp,-16
 3206f60:	dc400215 	stw	r17,8(sp)
 3206f64:	dc000115 	stw	r16,4(sp)
 3206f68:	dfc00315 	stw	ra,12(sp)
 3206f6c:	2021883a 	mov	r16,r4
 3206f70:	2823883a 	mov	r17,r5
 3206f74:	20000226 	beq	r4,zero,3206f80 <_putc_r+0x24>
 3206f78:	20800e17 	ldw	r2,56(r4)
 3206f7c:	10001026 	beq	r2,zero,3206fc0 <_putc_r+0x64>
 3206f80:	30800217 	ldw	r2,8(r6)
 3206f84:	10ffffc4 	addi	r3,r2,-1
 3206f88:	30c00215 	stw	r3,8(r6)
 3206f8c:	18001316 	blt	r3,zero,3206fdc <_putc_r+0x80>
 3206f90:	30800017 	ldw	r2,0(r6)
 3206f94:	14400005 	stb	r17,0(r2)
 3206f98:	30c00017 	ldw	r3,0(r6)
 3206f9c:	18800044 	addi	r2,r3,1
 3206fa0:	18c00003 	ldbu	r3,0(r3)
 3206fa4:	30800015 	stw	r2,0(r6)
 3206fa8:	1805883a 	mov	r2,r3
 3206fac:	dfc00317 	ldw	ra,12(sp)
 3206fb0:	dc400217 	ldw	r17,8(sp)
 3206fb4:	dc000117 	ldw	r16,4(sp)
 3206fb8:	dec00404 	addi	sp,sp,16
 3206fbc:	f800283a 	ret
 3206fc0:	d9800015 	stw	r6,0(sp)
 3206fc4:	3204b8c0 	call	3204b8c <__sinit>
 3206fc8:	d9800017 	ldw	r6,0(sp)
 3206fcc:	30800217 	ldw	r2,8(r6)
 3206fd0:	10ffffc4 	addi	r3,r2,-1
 3206fd4:	30c00215 	stw	r3,8(r6)
 3206fd8:	183fed0e 	bge	r3,zero,3206f90 <_putc_r+0x34>
 3206fdc:	30800617 	ldw	r2,24(r6)
 3206fe0:	18800e16 	blt	r3,r2,320701c <_putc_r+0xc0>
 3206fe4:	30800017 	ldw	r2,0(r6)
 3206fe8:	14400005 	stb	r17,0(r2)
 3206fec:	31000017 	ldw	r4,0(r6)
 3206ff0:	00800284 	movi	r2,10
 3206ff4:	20c00003 	ldbu	r3,0(r4)
 3206ff8:	18800f26 	beq	r3,r2,3207038 <_putc_r+0xdc>
 3206ffc:	20800044 	addi	r2,r4,1
 3207000:	30800015 	stw	r2,0(r6)
 3207004:	1805883a 	mov	r2,r3
 3207008:	dfc00317 	ldw	ra,12(sp)
 320700c:	dc400217 	ldw	r17,8(sp)
 3207010:	dc000117 	ldw	r16,4(sp)
 3207014:	dec00404 	addi	sp,sp,16
 3207018:	f800283a 	ret
 320701c:	8009883a 	mov	r4,r16
 3207020:	880b883a 	mov	r5,r17
 3207024:	dfc00317 	ldw	ra,12(sp)
 3207028:	dc400217 	ldw	r17,8(sp)
 320702c:	dc000117 	ldw	r16,4(sp)
 3207030:	dec00404 	addi	sp,sp,16
 3207034:	320bb6c1 	jmpi	320bb6c <__swbuf_r>
 3207038:	8009883a 	mov	r4,r16
 320703c:	180b883a 	mov	r5,r3
 3207040:	003ff806 	br	3207024 <_putc_r+0xc8>

03207044 <putchar>:
 3207044:	0080c974 	movhi	r2,805
 3207048:	108a6304 	addi	r2,r2,10636
 320704c:	11800017 	ldw	r6,0(r2)
 3207050:	200b883a 	mov	r5,r4
 3207054:	3009883a 	mov	r4,r6
 3207058:	31800217 	ldw	r6,8(r6)
 320705c:	3206f5c1 	jmpi	3206f5c <_putc_r>

03207060 <_putchar_r>:
 3207060:	21800217 	ldw	r6,8(r4)
 3207064:	3206f5c1 	jmpi	3206f5c <_putc_r>

03207068 <_puts_r>:
 3207068:	defff604 	addi	sp,sp,-40
 320706c:	dc400715 	stw	r17,28(sp)
 3207070:	2023883a 	mov	r17,r4
 3207074:	2809883a 	mov	r4,r5
 3207078:	dfc00915 	stw	ra,36(sp)
 320707c:	dcc00815 	stw	r19,32(sp)
 3207080:	2827883a 	mov	r19,r5
 3207084:	32084480 	call	3208448 <strlen>
 3207088:	89400217 	ldw	r5,8(r17)
 320708c:	00c0c974 	movhi	r3,805
 3207090:	18f6ab04 	addi	r3,r3,-9556
 3207094:	01c00044 	movi	r7,1
 3207098:	12000044 	addi	r8,r2,1
 320709c:	d8c00515 	stw	r3,20(sp)
 32070a0:	d9c00615 	stw	r7,24(sp)
 32070a4:	d8c00304 	addi	r3,sp,12
 32070a8:	01c00084 	movi	r7,2
 32070ac:	8809883a 	mov	r4,r17
 32070b0:	d80d883a 	mov	r6,sp
 32070b4:	d8c00015 	stw	r3,0(sp)
 32070b8:	dcc00315 	stw	r19,12(sp)
 32070bc:	da000215 	stw	r8,8(sp)
 32070c0:	d9c00115 	stw	r7,4(sp)
 32070c4:	d8800415 	stw	r2,16(sp)
 32070c8:	32058f80 	call	32058f8 <__sfvwrite_r>
 32070cc:	00ffffc4 	movi	r3,-1
 32070d0:	10000626 	beq	r2,zero,32070ec <_puts_r+0x84>
 32070d4:	1805883a 	mov	r2,r3
 32070d8:	dfc00917 	ldw	ra,36(sp)
 32070dc:	dcc00817 	ldw	r19,32(sp)
 32070e0:	dc400717 	ldw	r17,28(sp)
 32070e4:	dec00a04 	addi	sp,sp,40
 32070e8:	f800283a 	ret
 32070ec:	00c00284 	movi	r3,10
 32070f0:	1805883a 	mov	r2,r3
 32070f4:	dfc00917 	ldw	ra,36(sp)
 32070f8:	dcc00817 	ldw	r19,32(sp)
 32070fc:	dc400717 	ldw	r17,28(sp)
 3207100:	dec00a04 	addi	sp,sp,40
 3207104:	f800283a 	ret

03207108 <puts>:
 3207108:	0080c974 	movhi	r2,805
 320710c:	108a6304 	addi	r2,r2,10636
 3207110:	200b883a 	mov	r5,r4
 3207114:	11000017 	ldw	r4,0(r2)
 3207118:	32070681 	jmpi	3207068 <_puts_r>

0320711c <_realloc_r>:
 320711c:	defff404 	addi	sp,sp,-48
 3207120:	dd800815 	stw	r22,32(sp)
 3207124:	dc800415 	stw	r18,16(sp)
 3207128:	dc400315 	stw	r17,12(sp)
 320712c:	dfc00b15 	stw	ra,44(sp)
 3207130:	df000a15 	stw	fp,40(sp)
 3207134:	ddc00915 	stw	r23,36(sp)
 3207138:	dd400715 	stw	r21,28(sp)
 320713c:	dd000615 	stw	r20,24(sp)
 3207140:	dcc00515 	stw	r19,20(sp)
 3207144:	dc000215 	stw	r16,8(sp)
 3207148:	2825883a 	mov	r18,r5
 320714c:	3023883a 	mov	r17,r6
 3207150:	202d883a 	mov	r22,r4
 3207154:	2800c926 	beq	r5,zero,320747c <_realloc_r+0x360>
 3207158:	32153700 	call	3215370 <__malloc_lock>
 320715c:	943ffe04 	addi	r16,r18,-8
 3207160:	88c002c4 	addi	r3,r17,11
 3207164:	00800584 	movi	r2,22
 3207168:	82000117 	ldw	r8,4(r16)
 320716c:	10c01b2e 	bgeu	r2,r3,32071dc <_realloc_r+0xc0>
 3207170:	00bffe04 	movi	r2,-8
 3207174:	188e703a 	and	r7,r3,r2
 3207178:	3839883a 	mov	fp,r7
 320717c:	38001a16 	blt	r7,zero,32071e8 <_realloc_r+0xcc>
 3207180:	e4401936 	bltu	fp,r17,32071e8 <_realloc_r+0xcc>
 3207184:	013fff04 	movi	r4,-4
 3207188:	4126703a 	and	r19,r8,r4
 320718c:	99c02616 	blt	r19,r7,3207228 <_realloc_r+0x10c>
 3207190:	802b883a 	mov	r21,r16
 3207194:	9829883a 	mov	r20,r19
 3207198:	84000204 	addi	r16,r16,8
 320719c:	a80f883a 	mov	r7,r21
 32071a0:	a70dc83a 	sub	r6,r20,fp
 32071a4:	008003c4 	movi	r2,15
 32071a8:	1180c136 	bltu	r2,r6,32074b0 <_realloc_r+0x394>
 32071ac:	38800117 	ldw	r2,4(r7)
 32071b0:	a549883a 	add	r4,r20,r21
 32071b4:	1080004c 	andi	r2,r2,1
 32071b8:	a084b03a 	or	r2,r20,r2
 32071bc:	38800115 	stw	r2,4(r7)
 32071c0:	20c00117 	ldw	r3,4(r4)
 32071c4:	18c00054 	ori	r3,r3,1
 32071c8:	20c00115 	stw	r3,4(r4)
 32071cc:	b009883a 	mov	r4,r22
 32071d0:	32154780 	call	3215478 <__malloc_unlock>
 32071d4:	8023883a 	mov	r17,r16
 32071d8:	00000606 	br	32071f4 <_realloc_r+0xd8>
 32071dc:	01c00404 	movi	r7,16
 32071e0:	3839883a 	mov	fp,r7
 32071e4:	e47fe72e 	bgeu	fp,r17,3207184 <_realloc_r+0x68>
 32071e8:	00800304 	movi	r2,12
 32071ec:	0023883a 	mov	r17,zero
 32071f0:	b0800015 	stw	r2,0(r22)
 32071f4:	8805883a 	mov	r2,r17
 32071f8:	dfc00b17 	ldw	ra,44(sp)
 32071fc:	df000a17 	ldw	fp,40(sp)
 3207200:	ddc00917 	ldw	r23,36(sp)
 3207204:	dd800817 	ldw	r22,32(sp)
 3207208:	dd400717 	ldw	r21,28(sp)
 320720c:	dd000617 	ldw	r20,24(sp)
 3207210:	dcc00517 	ldw	r19,20(sp)
 3207214:	dc800417 	ldw	r18,16(sp)
 3207218:	dc400317 	ldw	r17,12(sp)
 320721c:	dc000217 	ldw	r16,8(sp)
 3207220:	dec00c04 	addi	sp,sp,48
 3207224:	f800283a 	ret
 3207228:	0080c974 	movhi	r2,805
 320722c:	10838504 	addi	r2,r2,3604
 3207230:	12400217 	ldw	r9,8(r2)
 3207234:	84cd883a 	add	r6,r16,r19
 3207238:	802b883a 	mov	r21,r16
 320723c:	3240b926 	beq	r6,r9,3207524 <_realloc_r+0x408>
 3207240:	31400117 	ldw	r5,4(r6)
 3207244:	00bfff84 	movi	r2,-2
 3207248:	2884703a 	and	r2,r5,r2
 320724c:	1185883a 	add	r2,r2,r6
 3207250:	10c00117 	ldw	r3,4(r2)
 3207254:	18c0004c 	andi	r3,r3,1
 3207258:	1807003a 	cmpeq	r3,r3,zero
 320725c:	1800a326 	beq	r3,zero,32074ec <_realloc_r+0x3d0>
 3207260:	2908703a 	and	r4,r5,r4
 3207264:	9929883a 	add	r20,r19,r4
 3207268:	a1c0a30e 	bge	r20,r7,32074f8 <_realloc_r+0x3dc>
 320726c:	4080004c 	andi	r2,r8,1
 3207270:	1000551e 	bne	r2,zero,32073c8 <_realloc_r+0x2ac>
 3207274:	80800017 	ldw	r2,0(r16)
 3207278:	80afc83a 	sub	r23,r16,r2
 320727c:	b8c00117 	ldw	r3,4(r23)
 3207280:	00bfff04 	movi	r2,-4
 3207284:	1884703a 	and	r2,r3,r2
 3207288:	30002e26 	beq	r6,zero,3207344 <_realloc_r+0x228>
 320728c:	3240b926 	beq	r6,r9,3207574 <_realloc_r+0x458>
 3207290:	98a9883a 	add	r20,r19,r2
 3207294:	2509883a 	add	r4,r4,r20
 3207298:	d9000015 	stw	r4,0(sp)
 320729c:	21c02a16 	blt	r4,r7,3207348 <_realloc_r+0x22c>
 32072a0:	30800317 	ldw	r2,12(r6)
 32072a4:	30c00217 	ldw	r3,8(r6)
 32072a8:	01400904 	movi	r5,36
 32072ac:	99bfff04 	addi	r6,r19,-4
 32072b0:	18800315 	stw	r2,12(r3)
 32072b4:	10c00215 	stw	r3,8(r2)
 32072b8:	b9000317 	ldw	r4,12(r23)
 32072bc:	b8800217 	ldw	r2,8(r23)
 32072c0:	b82b883a 	mov	r21,r23
 32072c4:	bc000204 	addi	r16,r23,8
 32072c8:	20800215 	stw	r2,8(r4)
 32072cc:	11000315 	stw	r4,12(r2)
 32072d0:	2980e436 	bltu	r5,r6,3207664 <_realloc_r+0x548>
 32072d4:	008004c4 	movi	r2,19
 32072d8:	9009883a 	mov	r4,r18
 32072dc:	8011883a 	mov	r8,r16
 32072e0:	11800f2e 	bgeu	r2,r6,3207320 <_realloc_r+0x204>
 32072e4:	90800017 	ldw	r2,0(r18)
 32072e8:	ba000404 	addi	r8,r23,16
 32072ec:	91000204 	addi	r4,r18,8
 32072f0:	b8800215 	stw	r2,8(r23)
 32072f4:	90c00117 	ldw	r3,4(r18)
 32072f8:	008006c4 	movi	r2,27
 32072fc:	b8c00315 	stw	r3,12(r23)
 3207300:	1180072e 	bgeu	r2,r6,3207320 <_realloc_r+0x204>
 3207304:	90c00217 	ldw	r3,8(r18)
 3207308:	ba000604 	addi	r8,r23,24
 320730c:	91000404 	addi	r4,r18,16
 3207310:	b8c00415 	stw	r3,16(r23)
 3207314:	90800317 	ldw	r2,12(r18)
 3207318:	b8800515 	stw	r2,20(r23)
 320731c:	3140e726 	beq	r6,r5,32076bc <_realloc_r+0x5a0>
 3207320:	20800017 	ldw	r2,0(r4)
 3207324:	dd000017 	ldw	r20,0(sp)
 3207328:	b80f883a 	mov	r7,r23
 320732c:	40800015 	stw	r2,0(r8)
 3207330:	20c00117 	ldw	r3,4(r4)
 3207334:	40c00115 	stw	r3,4(r8)
 3207338:	20800217 	ldw	r2,8(r4)
 320733c:	40800215 	stw	r2,8(r8)
 3207340:	003f9706 	br	32071a0 <_realloc_r+0x84>
 3207344:	98a9883a 	add	r20,r19,r2
 3207348:	a1c01f16 	blt	r20,r7,32073c8 <_realloc_r+0x2ac>
 320734c:	b8c00317 	ldw	r3,12(r23)
 3207350:	b8800217 	ldw	r2,8(r23)
 3207354:	99bfff04 	addi	r6,r19,-4
 3207358:	01400904 	movi	r5,36
 320735c:	b82b883a 	mov	r21,r23
 3207360:	18800215 	stw	r2,8(r3)
 3207364:	10c00315 	stw	r3,12(r2)
 3207368:	bc000204 	addi	r16,r23,8
 320736c:	2980c336 	bltu	r5,r6,320767c <_realloc_r+0x560>
 3207370:	008004c4 	movi	r2,19
 3207374:	9009883a 	mov	r4,r18
 3207378:	8011883a 	mov	r8,r16
 320737c:	11800f2e 	bgeu	r2,r6,32073bc <_realloc_r+0x2a0>
 3207380:	90800017 	ldw	r2,0(r18)
 3207384:	ba000404 	addi	r8,r23,16
 3207388:	91000204 	addi	r4,r18,8
 320738c:	b8800215 	stw	r2,8(r23)
 3207390:	90c00117 	ldw	r3,4(r18)
 3207394:	008006c4 	movi	r2,27
 3207398:	b8c00315 	stw	r3,12(r23)
 320739c:	1180072e 	bgeu	r2,r6,32073bc <_realloc_r+0x2a0>
 32073a0:	90c00217 	ldw	r3,8(r18)
 32073a4:	ba000604 	addi	r8,r23,24
 32073a8:	91000404 	addi	r4,r18,16
 32073ac:	b8c00415 	stw	r3,16(r23)
 32073b0:	90800317 	ldw	r2,12(r18)
 32073b4:	b8800515 	stw	r2,20(r23)
 32073b8:	3140c726 	beq	r6,r5,32076d8 <_realloc_r+0x5bc>
 32073bc:	20800017 	ldw	r2,0(r4)
 32073c0:	b80f883a 	mov	r7,r23
 32073c4:	003fd906 	br	320732c <_realloc_r+0x210>
 32073c8:	880b883a 	mov	r5,r17
 32073cc:	b009883a 	mov	r4,r22
 32073d0:	32062ac0 	call	32062ac <_malloc_r>
 32073d4:	1023883a 	mov	r17,r2
 32073d8:	10002526 	beq	r2,zero,3207470 <_realloc_r+0x354>
 32073dc:	80800117 	ldw	r2,4(r16)
 32073e0:	00ffff84 	movi	r3,-2
 32073e4:	893ffe04 	addi	r4,r17,-8
 32073e8:	10c4703a 	and	r2,r2,r3
 32073ec:	8085883a 	add	r2,r16,r2
 32073f0:	20809526 	beq	r4,r2,3207648 <_realloc_r+0x52c>
 32073f4:	99bfff04 	addi	r6,r19,-4
 32073f8:	01c00904 	movi	r7,36
 32073fc:	39804536 	bltu	r7,r6,3207514 <_realloc_r+0x3f8>
 3207400:	008004c4 	movi	r2,19
 3207404:	9009883a 	mov	r4,r18
 3207408:	880b883a 	mov	r5,r17
 320740c:	11800f2e 	bgeu	r2,r6,320744c <_realloc_r+0x330>
 3207410:	90800017 	ldw	r2,0(r18)
 3207414:	89400204 	addi	r5,r17,8
 3207418:	91000204 	addi	r4,r18,8
 320741c:	88800015 	stw	r2,0(r17)
 3207420:	90c00117 	ldw	r3,4(r18)
 3207424:	008006c4 	movi	r2,27
 3207428:	88c00115 	stw	r3,4(r17)
 320742c:	1180072e 	bgeu	r2,r6,320744c <_realloc_r+0x330>
 3207430:	90c00217 	ldw	r3,8(r18)
 3207434:	89400404 	addi	r5,r17,16
 3207438:	91000404 	addi	r4,r18,16
 320743c:	88c00215 	stw	r3,8(r17)
 3207440:	90800317 	ldw	r2,12(r18)
 3207444:	88800315 	stw	r2,12(r17)
 3207448:	31c09126 	beq	r6,r7,3207690 <_realloc_r+0x574>
 320744c:	20800017 	ldw	r2,0(r4)
 3207450:	28800015 	stw	r2,0(r5)
 3207454:	20c00117 	ldw	r3,4(r4)
 3207458:	28c00115 	stw	r3,4(r5)
 320745c:	20800217 	ldw	r2,8(r4)
 3207460:	28800215 	stw	r2,8(r5)
 3207464:	900b883a 	mov	r5,r18
 3207468:	b009883a 	mov	r4,r22
 320746c:	32051100 	call	3205110 <_free_r>
 3207470:	b009883a 	mov	r4,r22
 3207474:	32154780 	call	3215478 <__malloc_unlock>
 3207478:	003f5e06 	br	32071f4 <_realloc_r+0xd8>
 320747c:	300b883a 	mov	r5,r6
 3207480:	dfc00b17 	ldw	ra,44(sp)
 3207484:	df000a17 	ldw	fp,40(sp)
 3207488:	ddc00917 	ldw	r23,36(sp)
 320748c:	dd800817 	ldw	r22,32(sp)
 3207490:	dd400717 	ldw	r21,28(sp)
 3207494:	dd000617 	ldw	r20,24(sp)
 3207498:	dcc00517 	ldw	r19,20(sp)
 320749c:	dc800417 	ldw	r18,16(sp)
 32074a0:	dc400317 	ldw	r17,12(sp)
 32074a4:	dc000217 	ldw	r16,8(sp)
 32074a8:	dec00c04 	addi	sp,sp,48
 32074ac:	32062ac1 	jmpi	32062ac <_malloc_r>
 32074b0:	38800117 	ldw	r2,4(r7)
 32074b4:	e54b883a 	add	r5,fp,r21
 32074b8:	31000054 	ori	r4,r6,1
 32074bc:	1080004c 	andi	r2,r2,1
 32074c0:	1704b03a 	or	r2,r2,fp
 32074c4:	38800115 	stw	r2,4(r7)
 32074c8:	29000115 	stw	r4,4(r5)
 32074cc:	2987883a 	add	r3,r5,r6
 32074d0:	18800117 	ldw	r2,4(r3)
 32074d4:	29400204 	addi	r5,r5,8
 32074d8:	b009883a 	mov	r4,r22
 32074dc:	10800054 	ori	r2,r2,1
 32074e0:	18800115 	stw	r2,4(r3)
 32074e4:	32051100 	call	3205110 <_free_r>
 32074e8:	003f3806 	br	32071cc <_realloc_r+0xb0>
 32074ec:	000d883a 	mov	r6,zero
 32074f0:	0009883a 	mov	r4,zero
 32074f4:	003f5d06 	br	320726c <_realloc_r+0x150>
 32074f8:	30c00217 	ldw	r3,8(r6)
 32074fc:	30800317 	ldw	r2,12(r6)
 3207500:	800f883a 	mov	r7,r16
 3207504:	84000204 	addi	r16,r16,8
 3207508:	10c00215 	stw	r3,8(r2)
 320750c:	18800315 	stw	r2,12(r3)
 3207510:	003f2306 	br	32071a0 <_realloc_r+0x84>
 3207514:	8809883a 	mov	r4,r17
 3207518:	900b883a 	mov	r5,r18
 320751c:	3206b700 	call	3206b70 <memmove>
 3207520:	003fd006 	br	3207464 <_realloc_r+0x348>
 3207524:	30800117 	ldw	r2,4(r6)
 3207528:	e0c00404 	addi	r3,fp,16
 320752c:	1108703a 	and	r4,r2,r4
 3207530:	9905883a 	add	r2,r19,r4
 3207534:	10ff4d16 	blt	r2,r3,320726c <_realloc_r+0x150>
 3207538:	1705c83a 	sub	r2,r2,fp
 320753c:	870b883a 	add	r5,r16,fp
 3207540:	10800054 	ori	r2,r2,1
 3207544:	28800115 	stw	r2,4(r5)
 3207548:	80c00117 	ldw	r3,4(r16)
 320754c:	0080c974 	movhi	r2,805
 3207550:	10838504 	addi	r2,r2,3604
 3207554:	b009883a 	mov	r4,r22
 3207558:	18c0004c 	andi	r3,r3,1
 320755c:	e0c6b03a 	or	r3,fp,r3
 3207560:	11400215 	stw	r5,8(r2)
 3207564:	80c00115 	stw	r3,4(r16)
 3207568:	32154780 	call	3215478 <__malloc_unlock>
 320756c:	84400204 	addi	r17,r16,8
 3207570:	003f2006 	br	32071f4 <_realloc_r+0xd8>
 3207574:	98a9883a 	add	r20,r19,r2
 3207578:	2509883a 	add	r4,r4,r20
 320757c:	e0800404 	addi	r2,fp,16
 3207580:	d9000115 	stw	r4,4(sp)
 3207584:	20bf7016 	blt	r4,r2,3207348 <_realloc_r+0x22c>
 3207588:	b8c00317 	ldw	r3,12(r23)
 320758c:	b8800217 	ldw	r2,8(r23)
 3207590:	99bfff04 	addi	r6,r19,-4
 3207594:	01400904 	movi	r5,36
 3207598:	18800215 	stw	r2,8(r3)
 320759c:	10c00315 	stw	r3,12(r2)
 32075a0:	bc400204 	addi	r17,r23,8
 32075a4:	29804136 	bltu	r5,r6,32076ac <_realloc_r+0x590>
 32075a8:	008004c4 	movi	r2,19
 32075ac:	9009883a 	mov	r4,r18
 32075b0:	880f883a 	mov	r7,r17
 32075b4:	11800f2e 	bgeu	r2,r6,32075f4 <_realloc_r+0x4d8>
 32075b8:	90800017 	ldw	r2,0(r18)
 32075bc:	b9c00404 	addi	r7,r23,16
 32075c0:	91000204 	addi	r4,r18,8
 32075c4:	b8800215 	stw	r2,8(r23)
 32075c8:	90c00117 	ldw	r3,4(r18)
 32075cc:	008006c4 	movi	r2,27
 32075d0:	b8c00315 	stw	r3,12(r23)
 32075d4:	1180072e 	bgeu	r2,r6,32075f4 <_realloc_r+0x4d8>
 32075d8:	90c00217 	ldw	r3,8(r18)
 32075dc:	b9c00604 	addi	r7,r23,24
 32075e0:	91000404 	addi	r4,r18,16
 32075e4:	b8c00415 	stw	r3,16(r23)
 32075e8:	90800317 	ldw	r2,12(r18)
 32075ec:	b8800515 	stw	r2,20(r23)
 32075f0:	31404026 	beq	r6,r5,32076f4 <_realloc_r+0x5d8>
 32075f4:	20800017 	ldw	r2,0(r4)
 32075f8:	38800015 	stw	r2,0(r7)
 32075fc:	20c00117 	ldw	r3,4(r4)
 3207600:	38c00115 	stw	r3,4(r7)
 3207604:	20800217 	ldw	r2,8(r4)
 3207608:	38800215 	stw	r2,8(r7)
 320760c:	d8c00117 	ldw	r3,4(sp)
 3207610:	bf0b883a 	add	r5,r23,fp
 3207614:	b009883a 	mov	r4,r22
 3207618:	1f05c83a 	sub	r2,r3,fp
 320761c:	10800054 	ori	r2,r2,1
 3207620:	28800115 	stw	r2,4(r5)
 3207624:	b8c00117 	ldw	r3,4(r23)
 3207628:	0080c974 	movhi	r2,805
 320762c:	10838504 	addi	r2,r2,3604
 3207630:	11400215 	stw	r5,8(r2)
 3207634:	18c0004c 	andi	r3,r3,1
 3207638:	e0c6b03a 	or	r3,fp,r3
 320763c:	b8c00115 	stw	r3,4(r23)
 3207640:	32154780 	call	3215478 <__malloc_unlock>
 3207644:	003eeb06 	br	32071f4 <_realloc_r+0xd8>
 3207648:	20800117 	ldw	r2,4(r4)
 320764c:	00ffff04 	movi	r3,-4
 3207650:	800f883a 	mov	r7,r16
 3207654:	10c4703a 	and	r2,r2,r3
 3207658:	98a9883a 	add	r20,r19,r2
 320765c:	84000204 	addi	r16,r16,8
 3207660:	003ecf06 	br	32071a0 <_realloc_r+0x84>
 3207664:	900b883a 	mov	r5,r18
 3207668:	8009883a 	mov	r4,r16
 320766c:	3206b700 	call	3206b70 <memmove>
 3207670:	dd000017 	ldw	r20,0(sp)
 3207674:	b80f883a 	mov	r7,r23
 3207678:	003ec906 	br	32071a0 <_realloc_r+0x84>
 320767c:	900b883a 	mov	r5,r18
 3207680:	8009883a 	mov	r4,r16
 3207684:	3206b700 	call	3206b70 <memmove>
 3207688:	b80f883a 	mov	r7,r23
 320768c:	003ec406 	br	32071a0 <_realloc_r+0x84>
 3207690:	90c00417 	ldw	r3,16(r18)
 3207694:	89400604 	addi	r5,r17,24
 3207698:	91000604 	addi	r4,r18,24
 320769c:	88c00415 	stw	r3,16(r17)
 32076a0:	90800517 	ldw	r2,20(r18)
 32076a4:	88800515 	stw	r2,20(r17)
 32076a8:	003f6806 	br	320744c <_realloc_r+0x330>
 32076ac:	900b883a 	mov	r5,r18
 32076b0:	8809883a 	mov	r4,r17
 32076b4:	3206b700 	call	3206b70 <memmove>
 32076b8:	003fd406 	br	320760c <_realloc_r+0x4f0>
 32076bc:	90c00417 	ldw	r3,16(r18)
 32076c0:	91000604 	addi	r4,r18,24
 32076c4:	ba000804 	addi	r8,r23,32
 32076c8:	b8c00615 	stw	r3,24(r23)
 32076cc:	90800517 	ldw	r2,20(r18)
 32076d0:	b8800715 	stw	r2,28(r23)
 32076d4:	003f1206 	br	3207320 <_realloc_r+0x204>
 32076d8:	90c00417 	ldw	r3,16(r18)
 32076dc:	91000604 	addi	r4,r18,24
 32076e0:	ba000804 	addi	r8,r23,32
 32076e4:	b8c00615 	stw	r3,24(r23)
 32076e8:	90800517 	ldw	r2,20(r18)
 32076ec:	b8800715 	stw	r2,28(r23)
 32076f0:	003f3206 	br	32073bc <_realloc_r+0x2a0>
 32076f4:	90c00417 	ldw	r3,16(r18)
 32076f8:	91000604 	addi	r4,r18,24
 32076fc:	b9c00804 	addi	r7,r23,32
 3207700:	b8c00615 	stw	r3,24(r23)
 3207704:	90800517 	ldw	r2,20(r18)
 3207708:	b8800715 	stw	r2,28(r23)
 320770c:	003fb906 	br	32075f4 <_realloc_r+0x4d8>

03207710 <__srefill_r>:
 3207710:	defffd04 	addi	sp,sp,-12
 3207714:	dc400115 	stw	r17,4(sp)
 3207718:	dc000015 	stw	r16,0(sp)
 320771c:	dfc00215 	stw	ra,8(sp)
 3207720:	2023883a 	mov	r17,r4
 3207724:	2821883a 	mov	r16,r5
 3207728:	20000226 	beq	r4,zero,3207734 <__srefill_r+0x24>
 320772c:	20800e17 	ldw	r2,56(r4)
 3207730:	10004126 	beq	r2,zero,3207838 <__srefill_r+0x128>
 3207734:	80c0030b 	ldhu	r3,12(r16)
 3207738:	80000115 	stw	zero,4(r16)
 320773c:	1880080c 	andi	r2,r3,32
 3207740:	1000361e 	bne	r2,zero,320781c <__srefill_r+0x10c>
 3207744:	1880010c 	andi	r2,r3,4
 3207748:	1000211e 	bne	r2,zero,32077d0 <__srefill_r+0xc0>
 320774c:	1880040c 	andi	r2,r3,16
 3207750:	10005026 	beq	r2,zero,3207894 <__srefill_r+0x184>
 3207754:	1880020c 	andi	r2,r3,8
 3207758:	1000541e 	bne	r2,zero,32078ac <__srefill_r+0x19c>
 320775c:	8080030b 	ldhu	r2,12(r16)
 3207760:	10800114 	ori	r2,r2,4
 3207764:	8080030d 	sth	r2,12(r16)
 3207768:	80800417 	ldw	r2,16(r16)
 320776c:	10004526 	beq	r2,zero,3207884 <__srefill_r+0x174>
 3207770:	8080030b 	ldhu	r2,12(r16)
 3207774:	108000cc 	andi	r2,r2,3
 3207778:	1000361e 	bne	r2,zero,3207854 <__srefill_r+0x144>
 320777c:	81800417 	ldw	r6,16(r16)
 3207780:	80c00817 	ldw	r3,32(r16)
 3207784:	81400717 	ldw	r5,28(r16)
 3207788:	81c00517 	ldw	r7,20(r16)
 320778c:	8809883a 	mov	r4,r17
 3207790:	81800015 	stw	r6,0(r16)
 3207794:	183ee83a 	callr	r3
 3207798:	80c0030b 	ldhu	r3,12(r16)
 320779c:	1009883a 	mov	r4,r2
 32077a0:	80800115 	stw	r2,4(r16)
 32077a4:	00b7ffc4 	movi	r2,-8193
 32077a8:	1884703a 	and	r2,r3,r2
 32077ac:	8080030d 	sth	r2,12(r16)
 32077b0:	0100230e 	bge	zero,r4,3207840 <__srefill_r+0x130>
 32077b4:	0009883a 	mov	r4,zero
 32077b8:	2005883a 	mov	r2,r4
 32077bc:	dfc00217 	ldw	ra,8(sp)
 32077c0:	dc400117 	ldw	r17,4(sp)
 32077c4:	dc000017 	ldw	r16,0(sp)
 32077c8:	dec00304 	addi	sp,sp,12
 32077cc:	f800283a 	ret
 32077d0:	81400c17 	ldw	r5,48(r16)
 32077d4:	283fe426 	beq	r5,zero,3207768 <__srefill_r+0x58>
 32077d8:	80801004 	addi	r2,r16,64
 32077dc:	28800226 	beq	r5,r2,32077e8 <__srefill_r+0xd8>
 32077e0:	8809883a 	mov	r4,r17
 32077e4:	32051100 	call	3205110 <_free_r>
 32077e8:	80800f17 	ldw	r2,60(r16)
 32077ec:	80000c15 	stw	zero,48(r16)
 32077f0:	80800115 	stw	r2,4(r16)
 32077f4:	103fdc26 	beq	r2,zero,3207768 <__srefill_r+0x58>
 32077f8:	80800e17 	ldw	r2,56(r16)
 32077fc:	0009883a 	mov	r4,zero
 3207800:	80800015 	stw	r2,0(r16)
 3207804:	2005883a 	mov	r2,r4
 3207808:	dfc00217 	ldw	ra,8(sp)
 320780c:	dc400117 	ldw	r17,4(sp)
 3207810:	dc000017 	ldw	r16,0(sp)
 3207814:	dec00304 	addi	sp,sp,12
 3207818:	f800283a 	ret
 320781c:	013fffc4 	movi	r4,-1
 3207820:	2005883a 	mov	r2,r4
 3207824:	dfc00217 	ldw	ra,8(sp)
 3207828:	dc400117 	ldw	r17,4(sp)
 320782c:	dc000017 	ldw	r16,0(sp)
 3207830:	dec00304 	addi	sp,sp,12
 3207834:	f800283a 	ret
 3207838:	3204b8c0 	call	3204b8c <__sinit>
 320783c:	003fbd06 	br	3207734 <__srefill_r+0x24>
 3207840:	20000b1e 	bne	r4,zero,3207870 <__srefill_r+0x160>
 3207844:	10800814 	ori	r2,r2,32
 3207848:	013fffc4 	movi	r4,-1
 320784c:	8080030d 	sth	r2,12(r16)
 3207850:	003fd906 	br	32077b8 <__srefill_r+0xa8>
 3207854:	0080c974 	movhi	r2,805
 3207858:	108a6404 	addi	r2,r2,10640
 320785c:	11000017 	ldw	r4,0(r2)
 3207860:	0140c834 	movhi	r5,800
 3207864:	295e3504 	addi	r5,r5,30932
 3207868:	3205e5c0 	call	3205e5c <_fwalk>
 320786c:	003fc306 	br	320777c <__srefill_r+0x6c>
 3207870:	10801014 	ori	r2,r2,64
 3207874:	013fffc4 	movi	r4,-1
 3207878:	8080030d 	sth	r2,12(r16)
 320787c:	80000115 	stw	zero,4(r16)
 3207880:	003fcd06 	br	32077b8 <__srefill_r+0xa8>
 3207884:	8809883a 	mov	r4,r17
 3207888:	800b883a 	mov	r5,r16
 320788c:	32061180 	call	3206118 <__smakebuf_r>
 3207890:	003fb706 	br	3207770 <__srefill_r+0x60>
 3207894:	18c01014 	ori	r3,r3,64
 3207898:	00800244 	movi	r2,9
 320789c:	013fffc4 	movi	r4,-1
 32078a0:	88800015 	stw	r2,0(r17)
 32078a4:	80c0030d 	sth	r3,12(r16)
 32078a8:	003fc306 	br	32077b8 <__srefill_r+0xa8>
 32078ac:	8809883a 	mov	r4,r17
 32078b0:	800b883a 	mov	r5,r16
 32078b4:	32048f40 	call	32048f4 <_fflush_r>
 32078b8:	103fd81e 	bne	r2,zero,320781c <__srefill_r+0x10c>
 32078bc:	8080030b 	ldhu	r2,12(r16)
 32078c0:	80000215 	stw	zero,8(r16)
 32078c4:	80000615 	stw	zero,24(r16)
 32078c8:	10bffdcc 	andi	r2,r2,65527
 32078cc:	8080030d 	sth	r2,12(r16)
 32078d0:	003fa206 	br	320775c <__srefill_r+0x4c>

032078d4 <lflush>:
 32078d4:	20c0030b 	ldhu	r3,12(r4)
 32078d8:	01400244 	movi	r5,9
 32078dc:	0005883a 	mov	r2,zero
 32078e0:	18c0024c 	andi	r3,r3,9
 32078e4:	19400126 	beq	r3,r5,32078ec <lflush+0x18>
 32078e8:	f800283a 	ret
 32078ec:	3204af01 	jmpi	3204af0 <fflush>

032078f0 <__srget_r>:
 32078f0:	defffe04 	addi	sp,sp,-8
 32078f4:	dc000015 	stw	r16,0(sp)
 32078f8:	dfc00115 	stw	ra,4(sp)
 32078fc:	2821883a 	mov	r16,r5
 3207900:	32077100 	call	3207710 <__srefill_r>
 3207904:	013fffc4 	movi	r4,-1
 3207908:	1000071e 	bne	r2,zero,3207928 <__srget_r+0x38>
 320790c:	80800117 	ldw	r2,4(r16)
 3207910:	81000017 	ldw	r4,0(r16)
 3207914:	10bfffc4 	addi	r2,r2,-1
 3207918:	20c00044 	addi	r3,r4,1
 320791c:	80800115 	stw	r2,4(r16)
 3207920:	21000003 	ldbu	r4,0(r4)
 3207924:	80c00015 	stw	r3,0(r16)
 3207928:	2005883a 	mov	r2,r4
 320792c:	dfc00117 	ldw	ra,4(sp)
 3207930:	dc000017 	ldw	r16,0(sp)
 3207934:	dec00204 	addi	sp,sp,8
 3207938:	f800283a 	ret

0320793c <__srget>:
 320793c:	0080c974 	movhi	r2,805
 3207940:	108a6304 	addi	r2,r2,10636
 3207944:	200b883a 	mov	r5,r4
 3207948:	11000017 	ldw	r4,0(r2)
 320794c:	32078f01 	jmpi	32078f0 <__srget_r>

03207950 <_sbrk_r>:
 3207950:	defffd04 	addi	sp,sp,-12
 3207954:	dc000015 	stw	r16,0(sp)
 3207958:	0400c974 	movhi	r16,805
 320795c:	8412f804 	addi	r16,r16,19424
 3207960:	dc400115 	stw	r17,4(sp)
 3207964:	80000015 	stw	zero,0(r16)
 3207968:	2023883a 	mov	r17,r4
 320796c:	2809883a 	mov	r4,r5
 3207970:	dfc00215 	stw	ra,8(sp)
 3207974:	32151ac0 	call	32151ac <sbrk>
 3207978:	1007883a 	mov	r3,r2
 320797c:	00bfffc4 	movi	r2,-1
 3207980:	18800626 	beq	r3,r2,320799c <_sbrk_r+0x4c>
 3207984:	1805883a 	mov	r2,r3
 3207988:	dfc00217 	ldw	ra,8(sp)
 320798c:	dc400117 	ldw	r17,4(sp)
 3207990:	dc000017 	ldw	r16,0(sp)
 3207994:	dec00304 	addi	sp,sp,12
 3207998:	f800283a 	ret
 320799c:	80800017 	ldw	r2,0(r16)
 32079a0:	103ff826 	beq	r2,zero,3207984 <_sbrk_r+0x34>
 32079a4:	88800015 	stw	r2,0(r17)
 32079a8:	1805883a 	mov	r2,r3
 32079ac:	dfc00217 	ldw	ra,8(sp)
 32079b0:	dc400117 	ldw	r17,4(sp)
 32079b4:	dc000017 	ldw	r16,0(sp)
 32079b8:	dec00304 	addi	sp,sp,12
 32079bc:	f800283a 	ret

032079c0 <sprintf>:
 32079c0:	deffe504 	addi	sp,sp,-108
 32079c4:	2013883a 	mov	r9,r4
 32079c8:	dfc01815 	stw	ra,96(sp)
 32079cc:	d9801915 	stw	r6,100(sp)
 32079d0:	d9c01a15 	stw	r7,104(sp)
 32079d4:	d8801904 	addi	r2,sp,100
 32079d8:	d8800015 	stw	r2,0(sp)
 32079dc:	0080c974 	movhi	r2,805
 32079e0:	108a6304 	addi	r2,r2,10636
 32079e4:	11000017 	ldw	r4,0(r2)
 32079e8:	d9c00017 	ldw	r7,0(sp)
 32079ec:	00808204 	movi	r2,520
 32079f0:	00e00034 	movhi	r3,32768
 32079f4:	18ffffc4 	addi	r3,r3,-1
 32079f8:	280d883a 	mov	r6,r5
 32079fc:	d880040d 	sth	r2,16(sp)
 3207a00:	d9400104 	addi	r5,sp,4
 3207a04:	00bfffc4 	movi	r2,-1
 3207a08:	d8c00615 	stw	r3,24(sp)
 3207a0c:	d8c00315 	stw	r3,12(sp)
 3207a10:	da400515 	stw	r9,20(sp)
 3207a14:	d880048d 	sth	r2,18(sp)
 3207a18:	da400115 	stw	r9,4(sp)
 3207a1c:	320851c0 	call	320851c <___vfprintf_internal_r>
 3207a20:	d8c00117 	ldw	r3,4(sp)
 3207a24:	18000005 	stb	zero,0(r3)
 3207a28:	dfc01817 	ldw	ra,96(sp)
 3207a2c:	dec01b04 	addi	sp,sp,108
 3207a30:	f800283a 	ret

03207a34 <_sprintf_r>:
 3207a34:	deffe604 	addi	sp,sp,-104
 3207a38:	2813883a 	mov	r9,r5
 3207a3c:	dfc01815 	stw	ra,96(sp)
 3207a40:	d9c01915 	stw	r7,100(sp)
 3207a44:	d8801904 	addi	r2,sp,100
 3207a48:	d8800015 	stw	r2,0(sp)
 3207a4c:	100f883a 	mov	r7,r2
 3207a50:	00808204 	movi	r2,520
 3207a54:	00e00034 	movhi	r3,32768
 3207a58:	18ffffc4 	addi	r3,r3,-1
 3207a5c:	d880040d 	sth	r2,16(sp)
 3207a60:	d9400104 	addi	r5,sp,4
 3207a64:	00bfffc4 	movi	r2,-1
 3207a68:	d8c00615 	stw	r3,24(sp)
 3207a6c:	d8c00315 	stw	r3,12(sp)
 3207a70:	da400515 	stw	r9,20(sp)
 3207a74:	d880048d 	sth	r2,18(sp)
 3207a78:	da400115 	stw	r9,4(sp)
 3207a7c:	320851c0 	call	320851c <___vfprintf_internal_r>
 3207a80:	d8c00117 	ldw	r3,4(sp)
 3207a84:	18000005 	stb	zero,0(r3)
 3207a88:	dfc01817 	ldw	ra,96(sp)
 3207a8c:	dec01a04 	addi	sp,sp,104
 3207a90:	f800283a 	ret

03207a94 <eofread>:
 3207a94:	0005883a 	mov	r2,zero
 3207a98:	f800283a 	ret

03207a9c <_sscanf_r>:
 3207a9c:	deffe404 	addi	sp,sp,-112
 3207aa0:	dcc01915 	stw	r19,100(sp)
 3207aa4:	2027883a 	mov	r19,r4
 3207aa8:	dfc01a15 	stw	ra,104(sp)
 3207aac:	dc401815 	stw	r17,96(sp)
 3207ab0:	d9c01b15 	stw	r7,108(sp)
 3207ab4:	00808104 	movi	r2,516
 3207ab8:	2809883a 	mov	r4,r5
 3207abc:	3023883a 	mov	r17,r6
 3207ac0:	d9400115 	stw	r5,4(sp)
 3207ac4:	d9400515 	stw	r5,20(sp)
 3207ac8:	d880040d 	sth	r2,16(sp)
 3207acc:	32084480 	call	3208448 <strlen>
 3207ad0:	d8c01b04 	addi	r3,sp,108
 3207ad4:	d8c00015 	stw	r3,0(sp)
 3207ad8:	180f883a 	mov	r7,r3
 3207adc:	023fffc4 	movi	r8,-1
 3207ae0:	00c0c834 	movhi	r3,800
 3207ae4:	18dea504 	addi	r3,r3,31380
 3207ae8:	9809883a 	mov	r4,r19
 3207aec:	880d883a 	mov	r6,r17
 3207af0:	d9400104 	addi	r5,sp,4
 3207af4:	d8800615 	stw	r2,24(sp)
 3207af8:	d8c00915 	stw	r3,36(sp)
 3207afc:	da00048d 	sth	r8,18(sp)
 3207b00:	d8800215 	stw	r2,8(sp)
 3207b04:	d8000d15 	stw	zero,52(sp)
 3207b08:	d8001215 	stw	zero,72(sp)
 3207b0c:	320a3ec0 	call	320a3ec <__svfscanf_r>
 3207b10:	dfc01a17 	ldw	ra,104(sp)
 3207b14:	dcc01917 	ldw	r19,100(sp)
 3207b18:	dc401817 	ldw	r17,96(sp)
 3207b1c:	dec01c04 	addi	sp,sp,112
 3207b20:	f800283a 	ret

03207b24 <sscanf>:
 3207b24:	deffe404 	addi	sp,sp,-112
 3207b28:	dfc01915 	stw	ra,100(sp)
 3207b2c:	dc401815 	stw	r17,96(sp)
 3207b30:	d9801a15 	stw	r6,104(sp)
 3207b34:	d9c01b15 	stw	r7,108(sp)
 3207b38:	00808104 	movi	r2,516
 3207b3c:	2823883a 	mov	r17,r5
 3207b40:	d9000515 	stw	r4,20(sp)
 3207b44:	d9000115 	stw	r4,4(sp)
 3207b48:	d880040d 	sth	r2,16(sp)
 3207b4c:	32084480 	call	3208448 <strlen>
 3207b50:	d8c01a04 	addi	r3,sp,104
 3207b54:	d8c00015 	stw	r3,0(sp)
 3207b58:	00c0c974 	movhi	r3,805
 3207b5c:	18ca6304 	addi	r3,r3,10636
 3207b60:	19000017 	ldw	r4,0(r3)
 3207b64:	d9c00017 	ldw	r7,0(sp)
 3207b68:	00c0c834 	movhi	r3,800
 3207b6c:	18dea504 	addi	r3,r3,31380
 3207b70:	023fffc4 	movi	r8,-1
 3207b74:	880d883a 	mov	r6,r17
 3207b78:	d9400104 	addi	r5,sp,4
 3207b7c:	d8800615 	stw	r2,24(sp)
 3207b80:	d8c00915 	stw	r3,36(sp)
 3207b84:	da00048d 	sth	r8,18(sp)
 3207b88:	d8800215 	stw	r2,8(sp)
 3207b8c:	d8000d15 	stw	zero,52(sp)
 3207b90:	d8001215 	stw	zero,72(sp)
 3207b94:	320a3ec0 	call	320a3ec <__svfscanf_r>
 3207b98:	dfc01917 	ldw	ra,100(sp)
 3207b9c:	dc401817 	ldw	r17,96(sp)
 3207ba0:	dec01c04 	addi	sp,sp,112
 3207ba4:	f800283a 	ret

03207ba8 <__sclose>:
 3207ba8:	2940038f 	ldh	r5,14(r5)
 3207bac:	320be6c1 	jmpi	320be6c <_close_r>

03207bb0 <__sseek>:
 3207bb0:	defffe04 	addi	sp,sp,-8
 3207bb4:	dc000015 	stw	r16,0(sp)
 3207bb8:	2821883a 	mov	r16,r5
 3207bbc:	2940038f 	ldh	r5,14(r5)
 3207bc0:	dfc00115 	stw	ra,4(sp)
 3207bc4:	320dba00 	call	320dba0 <_lseek_r>
 3207bc8:	1007883a 	mov	r3,r2
 3207bcc:	00bfffc4 	movi	r2,-1
 3207bd0:	18800926 	beq	r3,r2,3207bf8 <__sseek+0x48>
 3207bd4:	8080030b 	ldhu	r2,12(r16)
 3207bd8:	80c01415 	stw	r3,80(r16)
 3207bdc:	10840014 	ori	r2,r2,4096
 3207be0:	8080030d 	sth	r2,12(r16)
 3207be4:	1805883a 	mov	r2,r3
 3207be8:	dfc00117 	ldw	ra,4(sp)
 3207bec:	dc000017 	ldw	r16,0(sp)
 3207bf0:	dec00204 	addi	sp,sp,8
 3207bf4:	f800283a 	ret
 3207bf8:	8080030b 	ldhu	r2,12(r16)
 3207bfc:	10bbffcc 	andi	r2,r2,61439
 3207c00:	8080030d 	sth	r2,12(r16)
 3207c04:	1805883a 	mov	r2,r3
 3207c08:	dfc00117 	ldw	ra,4(sp)
 3207c0c:	dc000017 	ldw	r16,0(sp)
 3207c10:	dec00204 	addi	sp,sp,8
 3207c14:	f800283a 	ret

03207c18 <__swrite>:
 3207c18:	2880030b 	ldhu	r2,12(r5)
 3207c1c:	defffb04 	addi	sp,sp,-20
 3207c20:	dcc00315 	stw	r19,12(sp)
 3207c24:	1080400c 	andi	r2,r2,256
 3207c28:	dc800215 	stw	r18,8(sp)
 3207c2c:	dc400115 	stw	r17,4(sp)
 3207c30:	dc000015 	stw	r16,0(sp)
 3207c34:	3027883a 	mov	r19,r6
 3207c38:	3825883a 	mov	r18,r7
 3207c3c:	dfc00415 	stw	ra,16(sp)
 3207c40:	2821883a 	mov	r16,r5
 3207c44:	000d883a 	mov	r6,zero
 3207c48:	01c00084 	movi	r7,2
 3207c4c:	2023883a 	mov	r17,r4
 3207c50:	10000226 	beq	r2,zero,3207c5c <__swrite+0x44>
 3207c54:	2940038f 	ldh	r5,14(r5)
 3207c58:	320dba00 	call	320dba0 <_lseek_r>
 3207c5c:	8080030b 	ldhu	r2,12(r16)
 3207c60:	8140038f 	ldh	r5,14(r16)
 3207c64:	8809883a 	mov	r4,r17
 3207c68:	10bbffcc 	andi	r2,r2,61439
 3207c6c:	980d883a 	mov	r6,r19
 3207c70:	900f883a 	mov	r7,r18
 3207c74:	8080030d 	sth	r2,12(r16)
 3207c78:	dfc00417 	ldw	ra,16(sp)
 3207c7c:	dcc00317 	ldw	r19,12(sp)
 3207c80:	dc800217 	ldw	r18,8(sp)
 3207c84:	dc400117 	ldw	r17,4(sp)
 3207c88:	dc000017 	ldw	r16,0(sp)
 3207c8c:	dec00504 	addi	sp,sp,20
 3207c90:	320bcb81 	jmpi	320bcb8 <_write_r>

03207c94 <__sread>:
 3207c94:	defffe04 	addi	sp,sp,-8
 3207c98:	dc000015 	stw	r16,0(sp)
 3207c9c:	2821883a 	mov	r16,r5
 3207ca0:	2940038f 	ldh	r5,14(r5)
 3207ca4:	dfc00115 	stw	ra,4(sp)
 3207ca8:	320ed0c0 	call	320ed0c <_read_r>
 3207cac:	1007883a 	mov	r3,r2
 3207cb0:	10000816 	blt	r2,zero,3207cd4 <__sread+0x40>
 3207cb4:	80801417 	ldw	r2,80(r16)
 3207cb8:	10c5883a 	add	r2,r2,r3
 3207cbc:	80801415 	stw	r2,80(r16)
 3207cc0:	1805883a 	mov	r2,r3
 3207cc4:	dfc00117 	ldw	ra,4(sp)
 3207cc8:	dc000017 	ldw	r16,0(sp)
 3207ccc:	dec00204 	addi	sp,sp,8
 3207cd0:	f800283a 	ret
 3207cd4:	8080030b 	ldhu	r2,12(r16)
 3207cd8:	10bbffcc 	andi	r2,r2,61439
 3207cdc:	8080030d 	sth	r2,12(r16)
 3207ce0:	1805883a 	mov	r2,r3
 3207ce4:	dfc00117 	ldw	ra,4(sp)
 3207ce8:	dc000017 	ldw	r16,0(sp)
 3207cec:	dec00204 	addi	sp,sp,8
 3207cf0:	f800283a 	ret

03207cf4 <strchr>:
 3207cf4:	208000cc 	andi	r2,r4,3
 3207cf8:	2007883a 	mov	r3,r4
 3207cfc:	1000311e 	bne	r2,zero,3207dc4 <strchr+0xd0>
 3207d00:	29c03fcc 	andi	r7,r5,255
 3207d04:	0015883a 	mov	r10,zero
 3207d08:	0007883a 	mov	r3,zero
 3207d0c:	01400104 	movi	r5,4
 3207d10:	5004923a 	slli	r2,r10,8
 3207d14:	18c00044 	addi	r3,r3,1
 3207d18:	3894b03a 	or	r10,r7,r2
 3207d1c:	197ffc1e 	bne	r3,r5,3207d10 <strchr+0x1c>
 3207d20:	200d883a 	mov	r6,r4
 3207d24:	21000017 	ldw	r4,0(r4)
 3207d28:	017fbff4 	movhi	r5,65279
 3207d2c:	297fbfc4 	addi	r5,r5,-257
 3207d30:	02202074 	movhi	r8,32897
 3207d34:	42202004 	addi	r8,r8,-32640
 3207d38:	2145883a 	add	r2,r4,r5
 3207d3c:	1204703a 	and	r2,r2,r8
 3207d40:	0106303a 	nor	r3,zero,r4
 3207d44:	10c4703a 	and	r2,r2,r3
 3207d48:	1000151e 	bne	r2,zero,3207da0 <strchr+0xac>
 3207d4c:	2284f03a 	xor	r2,r4,r10
 3207d50:	1147883a 	add	r3,r2,r5
 3207d54:	1a06703a 	and	r3,r3,r8
 3207d58:	0084303a 	nor	r2,zero,r2
 3207d5c:	10c4703a 	and	r2,r2,r3
 3207d60:	10000f1e 	bne	r2,zero,3207da0 <strchr+0xac>
 3207d64:	2813883a 	mov	r9,r5
 3207d68:	00000106 	br	3207d70 <strchr+0x7c>
 3207d6c:	18000c1e 	bne	r3,zero,3207da0 <strchr+0xac>
 3207d70:	31800104 	addi	r6,r6,4
 3207d74:	30800017 	ldw	r2,0(r6)
 3207d78:	1286f03a 	xor	r3,r2,r10
 3207d7c:	124b883a 	add	r5,r2,r9
 3207d80:	1a49883a 	add	r4,r3,r9
 3207d84:	2a0a703a 	and	r5,r5,r8
 3207d88:	0084303a 	nor	r2,zero,r2
 3207d8c:	2208703a 	and	r4,r4,r8
 3207d90:	00c6303a 	nor	r3,zero,r3
 3207d94:	1144703a 	and	r2,r2,r5
 3207d98:	1906703a 	and	r3,r3,r4
 3207d9c:	103ff326 	beq	r2,zero,3207d6c <strchr+0x78>
 3207da0:	3007883a 	mov	r3,r6
 3207da4:	00000206 	br	3207db0 <strchr+0xbc>
 3207da8:	38800426 	beq	r7,r2,3207dbc <strchr+0xc8>
 3207dac:	18c00044 	addi	r3,r3,1
 3207db0:	18800003 	ldbu	r2,0(r3)
 3207db4:	103ffc1e 	bne	r2,zero,3207da8 <strchr+0xb4>
 3207db8:	3800041e 	bne	r7,zero,3207dcc <strchr+0xd8>
 3207dbc:	1805883a 	mov	r2,r3
 3207dc0:	f800283a 	ret
 3207dc4:	29c03fcc 	andi	r7,r5,255
 3207dc8:	003ff906 	br	3207db0 <strchr+0xbc>
 3207dcc:	0005883a 	mov	r2,zero
 3207dd0:	f800283a 	ret

03207dd4 <strerror>:
 3207dd4:	deffff04 	addi	sp,sp,-4
 3207dd8:	00802184 	movi	r2,134
 3207ddc:	dfc00015 	stw	ra,0(sp)
 3207de0:	200b883a 	mov	r5,r4
 3207de4:	11008e36 	bltu	r2,r4,3208020 <strerror+0x24c>
 3207de8:	2105883a 	add	r2,r4,r4
 3207dec:	1085883a 	add	r2,r2,r2
 3207df0:	00c0c834 	movhi	r3,800
 3207df4:	18df8104 	addi	r3,r3,32260
 3207df8:	10c5883a 	add	r2,r2,r3
 3207dfc:	11000017 	ldw	r4,0(r2)
 3207e00:	2000683a 	jmp	r4
 3207e04:	03208020 	cmpeqi	r12,zero,-32256
 3207e08:	03208058 	cmpnei	r12,zero,-32255
 3207e0c:	03208064 	muli	r12,zero,-32255
 3207e10:	03208070 	cmpltui	r12,zero,33281
 3207e14:	0320807c 	xorhi	r12,zero,33281
 3207e18:	03208088 	cmpgei	r12,zero,-32254
 3207e1c:	03208094 	movui	r12,33282
 3207e20:	032080a0 	cmpeqi	r12,zero,-32254
 3207e24:	032080ac 	andhi	r12,zero,33282
 3207e28:	032080b8 	rdprs	r12,zero,-32254
 3207e2c:	032080c4 	movi	r12,-32253
 3207e30:	032080d0 	cmplti	r12,zero,-32253
 3207e34:	032080dc 	xori	r12,zero,33283
 3207e38:	032080e8 	cmpgeui	r12,zero,33283
 3207e3c:	032080f4 	movhi	r12,33283
 3207e40:	03208100 	call	320810 <OSCtxSw_SWITCH_PC+0x3207d0>
 3207e44:	0320810c 	andi	r12,zero,33284
 3207e48:	03208118 	cmpnei	r12,zero,-32252
 3207e4c:	03208124 	muli	r12,zero,-32252
 3207e50:	03208130 	cmpltui	r12,zero,33284
 3207e54:	0320813c 	xorhi	r12,zero,33284
 3207e58:	03208148 	cmpgei	r12,zero,-32251
 3207e5c:	03208154 	movui	r12,33285
 3207e60:	03208160 	cmpeqi	r12,zero,-32251
 3207e64:	0320816c 	andhi	r12,zero,33285
 3207e68:	03208178 	rdprs	r12,zero,-32251
 3207e6c:	03208184 	movi	r12,-32250
 3207e70:	03208190 	cmplti	r12,zero,-32250
 3207e74:	0320819c 	xori	r12,zero,33286
 3207e78:	032081a8 	cmpgeui	r12,zero,33286
 3207e7c:	032081b4 	movhi	r12,33286
 3207e80:	032081c0 	call	32081c <OSCtxSw_SWITCH_PC+0x3207dc>
 3207e84:	032081cc 	andi	r12,zero,33287
 3207e88:	032081d8 	cmpnei	r12,zero,-32249
 3207e8c:	032081e4 	muli	r12,zero,-32249
 3207e90:	032081f0 	cmpltui	r12,zero,33287
 3207e94:	032081fc 	xorhi	r12,zero,33287
 3207e98:	03208020 	cmpeqi	r12,zero,-32256
 3207e9c:	03208020 	cmpeqi	r12,zero,-32256
 3207ea0:	03208020 	cmpeqi	r12,zero,-32256
 3207ea4:	03208020 	cmpeqi	r12,zero,-32256
 3207ea8:	03208020 	cmpeqi	r12,zero,-32256
 3207eac:	03208020 	cmpeqi	r12,zero,-32256
 3207eb0:	03208020 	cmpeqi	r12,zero,-32256
 3207eb4:	03208020 	cmpeqi	r12,zero,-32256
 3207eb8:	03208208 	cmpgei	r12,zero,-32248
 3207ebc:	03208214 	movui	r12,33288
 3207ec0:	03208020 	cmpeqi	r12,zero,-32256
 3207ec4:	03208020 	cmpeqi	r12,zero,-32256
 3207ec8:	03208020 	cmpeqi	r12,zero,-32256
 3207ecc:	03208020 	cmpeqi	r12,zero,-32256
 3207ed0:	03208020 	cmpeqi	r12,zero,-32256
 3207ed4:	03208020 	cmpeqi	r12,zero,-32256
 3207ed8:	03208020 	cmpeqi	r12,zero,-32256
 3207edc:	03208020 	cmpeqi	r12,zero,-32256
 3207ee0:	03208020 	cmpeqi	r12,zero,-32256
 3207ee4:	03208020 	cmpeqi	r12,zero,-32256
 3207ee8:	03208020 	cmpeqi	r12,zero,-32256
 3207eec:	03208020 	cmpeqi	r12,zero,-32256
 3207ef0:	03208020 	cmpeqi	r12,zero,-32256
 3207ef4:	03208220 	cmpeqi	r12,zero,-32248
 3207ef8:	03208020 	cmpeqi	r12,zero,-32256
 3207efc:	0320822c 	andhi	r12,zero,33288
 3207f00:	03208238 	rdprs	r12,zero,-32248
 3207f04:	03208244 	movi	r12,-32247
 3207f08:	03208250 	cmplti	r12,zero,-32247
 3207f0c:	0320825c 	xori	r12,zero,33289
 3207f10:	03208268 	cmpgeui	r12,zero,33289
 3207f14:	03208274 	movhi	r12,33289
 3207f18:	03208280 	call	320828 <OSCtxSw_SWITCH_PC+0x3207e8>
 3207f1c:	0320828c 	andi	r12,zero,33290
 3207f20:	03208298 	cmpnei	r12,zero,-32246
 3207f24:	03208020 	cmpeqi	r12,zero,-32256
 3207f28:	03208020 	cmpeqi	r12,zero,-32256
 3207f2c:	032082a4 	muli	r12,zero,-32246
 3207f30:	03208020 	cmpeqi	r12,zero,-32256
 3207f34:	03208020 	cmpeqi	r12,zero,-32256
 3207f38:	032082b0 	cmpltui	r12,zero,33290
 3207f3c:	03208020 	cmpeqi	r12,zero,-32256
 3207f40:	03208020 	cmpeqi	r12,zero,-32256
 3207f44:	03208020 	cmpeqi	r12,zero,-32256
 3207f48:	03208020 	cmpeqi	r12,zero,-32256
 3207f4c:	03208020 	cmpeqi	r12,zero,-32256
 3207f50:	032082bc 	xorhi	r12,zero,33290
 3207f54:	032082c8 	cmpgei	r12,zero,-32245
 3207f58:	032082d4 	movui	r12,33291
 3207f5c:	032082e0 	cmpeqi	r12,zero,-32245
 3207f60:	032082ec 	andhi	r12,zero,33291
 3207f64:	032082f8 	rdprs	r12,zero,-32245
 3207f68:	03208304 	movi	r12,-32244
 3207f6c:	03208310 	cmplti	r12,zero,-32244
 3207f70:	0320831c 	xori	r12,zero,33292
 3207f74:	03208328 	cmpgeui	r12,zero,33292
 3207f78:	03208020 	cmpeqi	r12,zero,-32256
 3207f7c:	03208020 	cmpeqi	r12,zero,-32256
 3207f80:	03208334 	movhi	r12,33292
 3207f84:	03208020 	cmpeqi	r12,zero,-32256
 3207f88:	03208020 	cmpeqi	r12,zero,-32256
 3207f8c:	03208020 	cmpeqi	r12,zero,-32256
 3207f90:	03208020 	cmpeqi	r12,zero,-32256
 3207f94:	03208020 	cmpeqi	r12,zero,-32256
 3207f98:	03208020 	cmpeqi	r12,zero,-32256
 3207f9c:	03208020 	cmpeqi	r12,zero,-32256
 3207fa0:	03208020 	cmpeqi	r12,zero,-32256
 3207fa4:	03208020 	cmpeqi	r12,zero,-32256
 3207fa8:	03208340 	call	320834 <OSCtxSw_SWITCH_PC+0x3207f4>
 3207fac:	0320834c 	andi	r12,zero,33293
 3207fb0:	03208358 	cmpnei	r12,zero,-32243
 3207fb4:	03208364 	muli	r12,zero,-32243
 3207fb8:	03208370 	cmpltui	r12,zero,33293
 3207fbc:	0320837c 	xorhi	r12,zero,33293
 3207fc0:	03208388 	cmpgei	r12,zero,-32242
 3207fc4:	03208394 	movui	r12,33294
 3207fc8:	032083a0 	cmpeqi	r12,zero,-32242
 3207fcc:	032083ac 	andhi	r12,zero,33294
 3207fd0:	032083b8 	rdprs	r12,zero,-32242
 3207fd4:	032083c4 	movi	r12,-32241
 3207fd8:	032083d0 	cmplti	r12,zero,-32241
 3207fdc:	032083dc 	xori	r12,zero,33295
 3207fe0:	032083e8 	cmpgeui	r12,zero,33295
 3207fe4:	032083f4 	movhi	r12,33295
 3207fe8:	03208400 	call	320840 <OSCtxSw_SWITCH_PC+0x320800>
 3207fec:	0320840c 	andi	r12,zero,33296
 3207ff0:	03208418 	cmpnei	r12,zero,-32240
 3207ff4:	03208424 	muli	r12,zero,-32240
 3207ff8:	03208020 	cmpeqi	r12,zero,-32256
 3207ffc:	03208020 	cmpeqi	r12,zero,-32256
 3208000:	03208430 	cmpltui	r12,zero,33296
 3208004:	0320843c 	xorhi	r12,zero,33296
 3208008:	03208020 	cmpeqi	r12,zero,-32256
 320800c:	03208020 	cmpeqi	r12,zero,-32256
 3208010:	03208020 	cmpeqi	r12,zero,-32256
 3208014:	03208020 	cmpeqi	r12,zero,-32256
 3208018:	03208020 	cmpeqi	r12,zero,-32256
 320801c:	0320804c 	andi	r12,zero,33281
 3208020:	2809883a 	mov	r4,r5
 3208024:	32084bc0 	call	32084bc <_user_strerror>
 3208028:	10000326 	beq	r2,zero,3208038 <strerror+0x264>
 320802c:	dfc00017 	ldw	ra,0(sp)
 3208030:	dec00104 	addi	sp,sp,4
 3208034:	f800283a 	ret
 3208038:	0080c974 	movhi	r2,805
 320803c:	10b8a404 	addi	r2,r2,-7536
 3208040:	dfc00017 	ldw	ra,0(sp)
 3208044:	dec00104 	addi	sp,sp,4
 3208048:	f800283a 	ret
 320804c:	0080c974 	movhi	r2,805
 3208050:	10b76704 	addi	r2,r2,-8804
 3208054:	003ff506 	br	320802c <strerror+0x258>
 3208058:	0080c974 	movhi	r2,805
 320805c:	10b6b704 	addi	r2,r2,-9508
 3208060:	003ff206 	br	320802c <strerror+0x258>
 3208064:	0080c974 	movhi	r2,805
 3208068:	10b6ba04 	addi	r2,r2,-9496
 320806c:	003fef06 	br	320802c <strerror+0x258>
 3208070:	0080c974 	movhi	r2,805
 3208074:	10b6c104 	addi	r2,r2,-9468
 3208078:	003fec06 	br	320802c <strerror+0x258>
 320807c:	0080c974 	movhi	r2,805
 3208080:	10b6c504 	addi	r2,r2,-9452
 3208084:	003fe906 	br	320802c <strerror+0x258>
 3208088:	0080c974 	movhi	r2,805
 320808c:	10b6cb04 	addi	r2,r2,-9428
 3208090:	003fe606 	br	320802c <strerror+0x258>
 3208094:	0080c974 	movhi	r2,805
 3208098:	10b6ce04 	addi	r2,r2,-9416
 320809c:	003fe306 	br	320802c <strerror+0x258>
 32080a0:	0080c974 	movhi	r2,805
 32080a4:	10b6d504 	addi	r2,r2,-9388
 32080a8:	003fe006 	br	320802c <strerror+0x258>
 32080ac:	0080c974 	movhi	r2,805
 32080b0:	10b6da04 	addi	r2,r2,-9368
 32080b4:	003fdd06 	br	320802c <strerror+0x258>
 32080b8:	0080c974 	movhi	r2,805
 32080bc:	10b6e604 	addi	r2,r2,-9320
 32080c0:	003fda06 	br	320802c <strerror+0x258>
 32080c4:	0080c974 	movhi	r2,805
 32080c8:	10b6ea04 	addi	r2,r2,-9304
 32080cc:	003fd706 	br	320802c <strerror+0x258>
 32080d0:	0080c974 	movhi	r2,805
 32080d4:	10b6f504 	addi	r2,r2,-9260
 32080d8:	003fd406 	br	320802c <strerror+0x258>
 32080dc:	0080c974 	movhi	r2,805
 32080e0:	10b6fa04 	addi	r2,r2,-9240
 32080e4:	003fd106 	br	320802c <strerror+0x258>
 32080e8:	0080c974 	movhi	r2,805
 32080ec:	10b6ff04 	addi	r2,r2,-9220
 32080f0:	003fce06 	br	320802c <strerror+0x258>
 32080f4:	0080c974 	movhi	r2,805
 32080f8:	10b70404 	addi	r2,r2,-9200
 32080fc:	003fcb06 	br	320802c <strerror+0x258>
 3208100:	0080c974 	movhi	r2,805
 3208104:	10b70704 	addi	r2,r2,-9188
 3208108:	003fc806 	br	320802c <strerror+0x258>
 320810c:	0080c974 	movhi	r2,805
 3208110:	10b70d04 	addi	r2,r2,-9164
 3208114:	003fc506 	br	320802c <strerror+0x258>
 3208118:	0080c974 	movhi	r2,805
 320811c:	10b71304 	addi	r2,r2,-9140
 3208120:	003fc206 	br	320802c <strerror+0x258>
 3208124:	0080c974 	movhi	r2,805
 3208128:	10b71604 	addi	r2,r2,-9128
 320812c:	003fbf06 	br	320802c <strerror+0x258>
 3208130:	0080c974 	movhi	r2,805
 3208134:	10b71b04 	addi	r2,r2,-9108
 3208138:	003fbc06 	br	320802c <strerror+0x258>
 320813c:	0080c974 	movhi	r2,805
 3208140:	10b71f04 	addi	r2,r2,-9092
 3208144:	003fb906 	br	320802c <strerror+0x258>
 3208148:	0080c974 	movhi	r2,805
 320814c:	10b72f04 	addi	r2,r2,-9028
 3208150:	003fb606 	br	320802c <strerror+0x258>
 3208154:	0080c974 	movhi	r2,805
 3208158:	10b73304 	addi	r2,r2,-9012
 320815c:	003fb306 	br	320802c <strerror+0x258>
 3208160:	0080c974 	movhi	r2,805
 3208164:	10b74104 	addi	r2,r2,-8956
 3208168:	003fb006 	br	320802c <strerror+0x258>
 320816c:	0080c974 	movhi	r2,805
 3208170:	10b74904 	addi	r2,r2,-8924
 3208174:	003fad06 	br	320802c <strerror+0x258>
 3208178:	0080c974 	movhi	r2,805
 320817c:	10b74e04 	addi	r2,r2,-8904
 3208180:	003faa06 	br	320802c <strerror+0x258>
 3208184:	0080c974 	movhi	r2,805
 3208188:	10b75404 	addi	r2,r2,-8880
 320818c:	003fa706 	br	320802c <strerror+0x258>
 3208190:	0080c974 	movhi	r2,805
 3208194:	10b75804 	addi	r2,r2,-8864
 3208198:	003fa406 	br	320802c <strerror+0x258>
 320819c:	0080c974 	movhi	r2,805
 32081a0:	10b76104 	addi	r2,r2,-8828
 32081a4:	003fa106 	br	320802c <strerror+0x258>
 32081a8:	0080c974 	movhi	r2,805
 32081ac:	10b76b04 	addi	r2,r2,-8788
 32081b0:	003f9e06 	br	320802c <strerror+0x258>
 32081b4:	0080c974 	movhi	r2,805
 32081b8:	10b76f04 	addi	r2,r2,-8772
 32081bc:	003f9b06 	br	320802c <strerror+0x258>
 32081c0:	0080c974 	movhi	r2,805
 32081c4:	10b77504 	addi	r2,r2,-8748
 32081c8:	003f9806 	br	320802c <strerror+0x258>
 32081cc:	0080c974 	movhi	r2,805
 32081d0:	10b77904 	addi	r2,r2,-8732
 32081d4:	003f9506 	br	320802c <strerror+0x258>
 32081d8:	0080c974 	movhi	r2,805
 32081dc:	10b77c04 	addi	r2,r2,-8720
 32081e0:	003f9206 	br	320802c <strerror+0x258>
 32081e4:	0080c974 	movhi	r2,805
 32081e8:	10b78004 	addi	r2,r2,-8704
 32081ec:	003f8f06 	br	320802c <strerror+0x258>
 32081f0:	0080c974 	movhi	r2,805
 32081f4:	10b78504 	addi	r2,r2,-8684
 32081f8:	003f8c06 	br	320802c <strerror+0x258>
 32081fc:	0080c974 	movhi	r2,805
 3208200:	10b78c04 	addi	r2,r2,-8656
 3208204:	003f8906 	br	320802c <strerror+0x258>
 3208208:	0080c974 	movhi	r2,805
 320820c:	10b79104 	addi	r2,r2,-8636
 3208210:	003f8606 	br	320802c <strerror+0x258>
 3208214:	0080c974 	movhi	r2,805
 3208218:	10b79a04 	addi	r2,r2,-8600
 320821c:	003f8306 	br	320802c <strerror+0x258>
 3208220:	0080c974 	movhi	r2,805
 3208224:	10b79c04 	addi	r2,r2,-8592
 3208228:	003f8006 	br	320802c <strerror+0x258>
 320822c:	0080c974 	movhi	r2,805
 3208230:	10b7a004 	addi	r2,r2,-8576
 3208234:	003f7d06 	br	320802c <strerror+0x258>
 3208238:	0080c974 	movhi	r2,805
 320823c:	10b7a604 	addi	r2,r2,-8552
 3208240:	003f7a06 	br	320802c <strerror+0x258>
 3208244:	0080c974 	movhi	r2,805
 3208248:	10b7ab04 	addi	r2,r2,-8532
 320824c:	003f7706 	br	320802c <strerror+0x258>
 3208250:	0080c974 	movhi	r2,805
 3208254:	10b7b304 	addi	r2,r2,-8500
 3208258:	003f7406 	br	320802c <strerror+0x258>
 320825c:	0080c974 	movhi	r2,805
 3208260:	10b7b604 	addi	r2,r2,-8488
 3208264:	003f7106 	br	320802c <strerror+0x258>
 3208268:	0080c974 	movhi	r2,805
 320826c:	10b7bb04 	addi	r2,r2,-8468
 3208270:	003f6e06 	br	320802c <strerror+0x258>
 3208274:	0080c974 	movhi	r2,805
 3208278:	10b7c104 	addi	r2,r2,-8444
 320827c:	003f6b06 	br	320802c <strerror+0x258>
 3208280:	0080c974 	movhi	r2,805
 3208284:	10b7c504 	addi	r2,r2,-8428
 3208288:	003f6806 	br	320802c <strerror+0x258>
 320828c:	0080c974 	movhi	r2,805
 3208290:	10b7c904 	addi	r2,r2,-8412
 3208294:	003f6506 	br	320802c <strerror+0x258>
 3208298:	0080c974 	movhi	r2,805
 320829c:	10b7ce04 	addi	r2,r2,-8392
 32082a0:	003f6206 	br	320802c <strerror+0x258>
 32082a4:	0080c974 	movhi	r2,805
 32082a8:	10b7d704 	addi	r2,r2,-8356
 32082ac:	003f5f06 	br	320802c <strerror+0x258>
 32082b0:	0080c974 	movhi	r2,805
 32082b4:	10b7dc04 	addi	r2,r2,-8336
 32082b8:	003f5c06 	br	320802c <strerror+0x258>
 32082bc:	0080c974 	movhi	r2,805
 32082c0:	10b7df04 	addi	r2,r2,-8324
 32082c4:	003f5906 	br	320802c <strerror+0x258>
 32082c8:	0080c974 	movhi	r2,805
 32082cc:	10b7e904 	addi	r2,r2,-8284
 32082d0:	003f5606 	br	320802c <strerror+0x258>
 32082d4:	0080c974 	movhi	r2,805
 32082d8:	10b7f304 	addi	r2,r2,-8244
 32082dc:	003f5306 	br	320802c <strerror+0x258>
 32082e0:	0080c974 	movhi	r2,805
 32082e4:	10b7fb04 	addi	r2,r2,-8212
 32082e8:	003f5006 	br	320802c <strerror+0x258>
 32082ec:	0080c974 	movhi	r2,805
 32082f0:	10b80b04 	addi	r2,r2,-8148
 32082f4:	003f4d06 	br	320802c <strerror+0x258>
 32082f8:	0080c974 	movhi	r2,805
 32082fc:	10b81504 	addi	r2,r2,-8108
 3208300:	003f4a06 	br	320802c <strerror+0x258>
 3208304:	0080c974 	movhi	r2,805
 3208308:	10b81c04 	addi	r2,r2,-8080
 320830c:	003f4706 	br	320802c <strerror+0x258>
 3208310:	0080c974 	movhi	r2,805
 3208314:	10b82004 	addi	r2,r2,-8064
 3208318:	003f4406 	br	320802c <strerror+0x258>
 320831c:	0080c974 	movhi	r2,805
 3208320:	10b82504 	addi	r2,r2,-8044
 3208324:	003f4106 	br	320802c <strerror+0x258>
 3208328:	0080c974 	movhi	r2,805
 320832c:	10b82c04 	addi	r2,r2,-8016
 3208330:	003f3e06 	br	320802c <strerror+0x258>
 3208334:	0080c974 	movhi	r2,805
 3208338:	10b88c04 	addi	r2,r2,-7632
 320833c:	003f3b06 	br	320802c <strerror+0x258>
 3208340:	0080c974 	movhi	r2,805
 3208344:	10b83204 	addi	r2,r2,-7992
 3208348:	003f3806 	br	320802c <strerror+0x258>
 320834c:	0080c974 	movhi	r2,805
 3208350:	10b83904 	addi	r2,r2,-7964
 3208354:	003f3506 	br	320802c <strerror+0x258>
 3208358:	0080c974 	movhi	r2,805
 320835c:	10b84504 	addi	r2,r2,-7916
 3208360:	003f3206 	br	320802c <strerror+0x258>
 3208364:	0080c974 	movhi	r2,805
 3208368:	10b84d04 	addi	r2,r2,-7884
 320836c:	003f2f06 	br	320802c <strerror+0x258>
 3208370:	0080c974 	movhi	r2,805
 3208374:	10b85504 	addi	r2,r2,-7852
 3208378:	003f2c06 	br	320802c <strerror+0x258>
 320837c:	0080c974 	movhi	r2,805
 3208380:	10b85b04 	addi	r2,r2,-7828
 3208384:	003f2906 	br	320802c <strerror+0x258>
 3208388:	0080c974 	movhi	r2,805
 320838c:	10b86404 	addi	r2,r2,-7792
 3208390:	003f2606 	br	320802c <strerror+0x258>
 3208394:	0080c974 	movhi	r2,805
 3208398:	10b86904 	addi	r2,r2,-7772
 320839c:	003f2306 	br	320802c <strerror+0x258>
 32083a0:	0080c974 	movhi	r2,805
 32083a4:	10b86f04 	addi	r2,r2,-7748
 32083a8:	003f2006 	br	320802c <strerror+0x258>
 32083ac:	0080c974 	movhi	r2,805
 32083b0:	10b79404 	addi	r2,r2,-8624
 32083b4:	003f1d06 	br	320802c <strerror+0x258>
 32083b8:	0080c974 	movhi	r2,805
 32083bc:	10b73804 	addi	r2,r2,-8992
 32083c0:	003f1a06 	br	320802c <strerror+0x258>
 32083c4:	0080c974 	movhi	r2,805
 32083c8:	10b6b104 	addi	r2,r2,-9532
 32083cc:	003f1706 	br	320802c <strerror+0x258>
 32083d0:	0080c974 	movhi	r2,805
 32083d4:	10b72304 	addi	r2,r2,-9076
 32083d8:	003f1406 	br	320802c <strerror+0x258>
 32083dc:	0080c974 	movhi	r2,805
 32083e0:	10b75c04 	addi	r2,r2,-8848
 32083e4:	003f1106 	br	320802c <strerror+0x258>
 32083e8:	0080c974 	movhi	r2,805
 32083ec:	10b72704 	addi	r2,r2,-9060
 32083f0:	003f0e06 	br	320802c <strerror+0x258>
 32083f4:	0080c974 	movhi	r2,805
 32083f8:	10b6df04 	addi	r2,r2,-9348
 32083fc:	003f0b06 	br	320802c <strerror+0x258>
 3208400:	0080c974 	movhi	r2,805
 3208404:	10b6ed04 	addi	r2,r2,-9292
 3208408:	003f0806 	br	320802c <strerror+0x258>
 320840c:	0080c974 	movhi	r2,805
 3208410:	10b6ac04 	addi	r2,r2,-9552
 3208414:	003f0506 	br	320802c <strerror+0x258>
 3208418:	0080c974 	movhi	r2,805
 320841c:	10b7d204 	addi	r2,r2,-8376
 3208420:	003f0206 	br	320802c <strerror+0x258>
 3208424:	0080c974 	movhi	r2,805
 3208428:	10b87e04 	addi	r2,r2,-7688
 320842c:	003eff06 	br	320802c <strerror+0x258>
 3208430:	0080c974 	movhi	r2,805
 3208434:	10b88504 	addi	r2,r2,-7660
 3208438:	003efc06 	br	320802c <strerror+0x258>
 320843c:	0080c974 	movhi	r2,805
 3208440:	10b87804 	addi	r2,r2,-7712
 3208444:	003ef906 	br	320802c <strerror+0x258>

03208448 <strlen>:
 3208448:	208000cc 	andi	r2,r4,3
 320844c:	2011883a 	mov	r8,r4
 3208450:	1000161e 	bne	r2,zero,32084ac <strlen+0x64>
 3208454:	20c00017 	ldw	r3,0(r4)
 3208458:	017fbff4 	movhi	r5,65279
 320845c:	297fbfc4 	addi	r5,r5,-257
 3208460:	01e02074 	movhi	r7,32897
 3208464:	39e02004 	addi	r7,r7,-32640
 3208468:	1945883a 	add	r2,r3,r5
 320846c:	11c4703a 	and	r2,r2,r7
 3208470:	00c6303a 	nor	r3,zero,r3
 3208474:	1886703a 	and	r3,r3,r2
 3208478:	18000c1e 	bne	r3,zero,32084ac <strlen+0x64>
 320847c:	280d883a 	mov	r6,r5
 3208480:	380b883a 	mov	r5,r7
 3208484:	21000104 	addi	r4,r4,4
 3208488:	20800017 	ldw	r2,0(r4)
 320848c:	1187883a 	add	r3,r2,r6
 3208490:	1946703a 	and	r3,r3,r5
 3208494:	0084303a 	nor	r2,zero,r2
 3208498:	10c4703a 	and	r2,r2,r3
 320849c:	103ff926 	beq	r2,zero,3208484 <strlen+0x3c>
 32084a0:	20800007 	ldb	r2,0(r4)
 32084a4:	10000326 	beq	r2,zero,32084b4 <strlen+0x6c>
 32084a8:	21000044 	addi	r4,r4,1
 32084ac:	20800007 	ldb	r2,0(r4)
 32084b0:	103ffd1e 	bne	r2,zero,32084a8 <strlen+0x60>
 32084b4:	2205c83a 	sub	r2,r4,r8
 32084b8:	f800283a 	ret

032084bc <_user_strerror>:
 32084bc:	0005883a 	mov	r2,zero
 32084c0:	f800283a 	ret

032084c4 <__sprint_r>:
 32084c4:	30800217 	ldw	r2,8(r6)
 32084c8:	defffe04 	addi	sp,sp,-8
 32084cc:	dc000015 	stw	r16,0(sp)
 32084d0:	dfc00115 	stw	ra,4(sp)
 32084d4:	3021883a 	mov	r16,r6
 32084d8:	0007883a 	mov	r3,zero
 32084dc:	1000061e 	bne	r2,zero,32084f8 <__sprint_r+0x34>
 32084e0:	1805883a 	mov	r2,r3
 32084e4:	30000115 	stw	zero,4(r6)
 32084e8:	dfc00117 	ldw	ra,4(sp)
 32084ec:	dc000017 	ldw	r16,0(sp)
 32084f0:	dec00204 	addi	sp,sp,8
 32084f4:	f800283a 	ret
 32084f8:	32058f80 	call	32058f8 <__sfvwrite_r>
 32084fc:	1007883a 	mov	r3,r2
 3208500:	1805883a 	mov	r2,r3
 3208504:	80000115 	stw	zero,4(r16)
 3208508:	80000215 	stw	zero,8(r16)
 320850c:	dfc00117 	ldw	ra,4(sp)
 3208510:	dc000017 	ldw	r16,0(sp)
 3208514:	dec00204 	addi	sp,sp,8
 3208518:	f800283a 	ret

0320851c <___vfprintf_internal_r>:
 320851c:	defea404 	addi	sp,sp,-1392
 3208520:	dd815815 	stw	r22,1376(sp)
 3208524:	dc015215 	stw	r16,1352(sp)
 3208528:	d9c15115 	stw	r7,1348(sp)
 320852c:	dfc15b15 	stw	ra,1388(sp)
 3208530:	df015a15 	stw	fp,1384(sp)
 3208534:	ddc15915 	stw	r23,1380(sp)
 3208538:	dd415715 	stw	r21,1372(sp)
 320853c:	dd015615 	stw	r20,1368(sp)
 3208540:	dcc15515 	stw	r19,1364(sp)
 3208544:	dc815415 	stw	r18,1360(sp)
 3208548:	dc415315 	stw	r17,1356(sp)
 320854c:	282d883a 	mov	r22,r5
 3208550:	3021883a 	mov	r16,r6
 3208554:	d9014f15 	stw	r4,1340(sp)
 3208558:	320dae40 	call	320dae4 <_localeconv_r>
 320855c:	10800017 	ldw	r2,0(r2)
 3208560:	d9c15117 	ldw	r7,1348(sp)
 3208564:	d8814915 	stw	r2,1316(sp)
 3208568:	d8814f17 	ldw	r2,1340(sp)
 320856c:	10000226 	beq	r2,zero,3208578 <___vfprintf_internal_r+0x5c>
 3208570:	10800e17 	ldw	r2,56(r2)
 3208574:	10020d26 	beq	r2,zero,3208dac <___vfprintf_internal_r+0x890>
 3208578:	b080030b 	ldhu	r2,12(r22)
 320857c:	1080020c 	andi	r2,r2,8
 3208580:	10020e26 	beq	r2,zero,3208dbc <___vfprintf_internal_r+0x8a0>
 3208584:	b0800417 	ldw	r2,16(r22)
 3208588:	10020c26 	beq	r2,zero,3208dbc <___vfprintf_internal_r+0x8a0>
 320858c:	b200030b 	ldhu	r8,12(r22)
 3208590:	00800284 	movi	r2,10
 3208594:	40c0068c 	andi	r3,r8,26
 3208598:	18802f1e 	bne	r3,r2,3208658 <___vfprintf_internal_r+0x13c>
 320859c:	b080038f 	ldh	r2,14(r22)
 32085a0:	10002d16 	blt	r2,zero,3208658 <___vfprintf_internal_r+0x13c>
 32085a4:	b240038b 	ldhu	r9,14(r22)
 32085a8:	b2800717 	ldw	r10,28(r22)
 32085ac:	b2c00917 	ldw	r11,36(r22)
 32085b0:	d9014f17 	ldw	r4,1340(sp)
 32085b4:	dc402904 	addi	r17,sp,164
 32085b8:	d8804004 	addi	r2,sp,256
 32085bc:	00c10004 	movi	r3,1024
 32085c0:	423fff4c 	andi	r8,r8,65533
 32085c4:	800d883a 	mov	r6,r16
 32085c8:	880b883a 	mov	r5,r17
 32085cc:	da002c0d 	sth	r8,176(sp)
 32085d0:	da402c8d 	sth	r9,178(sp)
 32085d4:	da803015 	stw	r10,192(sp)
 32085d8:	dac03215 	stw	r11,200(sp)
 32085dc:	d8802d15 	stw	r2,180(sp)
 32085e0:	d8c02e15 	stw	r3,184(sp)
 32085e4:	d8802915 	stw	r2,164(sp)
 32085e8:	d8c02b15 	stw	r3,172(sp)
 32085ec:	d8002f15 	stw	zero,188(sp)
 32085f0:	320851c0 	call	320851c <___vfprintf_internal_r>
 32085f4:	d8814b15 	stw	r2,1324(sp)
 32085f8:	10000416 	blt	r2,zero,320860c <___vfprintf_internal_r+0xf0>
 32085fc:	d9014f17 	ldw	r4,1340(sp)
 3208600:	880b883a 	mov	r5,r17
 3208604:	32048f40 	call	32048f4 <_fflush_r>
 3208608:	1002321e 	bne	r2,zero,3208ed4 <___vfprintf_internal_r+0x9b8>
 320860c:	d8802c0b 	ldhu	r2,176(sp)
 3208610:	1080100c 	andi	r2,r2,64
 3208614:	10000326 	beq	r2,zero,3208624 <___vfprintf_internal_r+0x108>
 3208618:	b080030b 	ldhu	r2,12(r22)
 320861c:	10801014 	ori	r2,r2,64
 3208620:	b080030d 	sth	r2,12(r22)
 3208624:	d8814b17 	ldw	r2,1324(sp)
 3208628:	dfc15b17 	ldw	ra,1388(sp)
 320862c:	df015a17 	ldw	fp,1384(sp)
 3208630:	ddc15917 	ldw	r23,1380(sp)
 3208634:	dd815817 	ldw	r22,1376(sp)
 3208638:	dd415717 	ldw	r21,1372(sp)
 320863c:	dd015617 	ldw	r20,1368(sp)
 3208640:	dcc15517 	ldw	r19,1364(sp)
 3208644:	dc815417 	ldw	r18,1360(sp)
 3208648:	dc415317 	ldw	r17,1356(sp)
 320864c:	dc015217 	ldw	r16,1352(sp)
 3208650:	dec15c04 	addi	sp,sp,1392
 3208654:	f800283a 	ret
 3208658:	0005883a 	mov	r2,zero
 320865c:	0007883a 	mov	r3,zero
 3208660:	dd401904 	addi	r21,sp,100
 3208664:	d8814215 	stw	r2,1288(sp)
 3208668:	802f883a 	mov	r23,r16
 320866c:	d8c14315 	stw	r3,1292(sp)
 3208670:	d8014b15 	stw	zero,1324(sp)
 3208674:	d8014815 	stw	zero,1312(sp)
 3208678:	d8014415 	stw	zero,1296(sp)
 320867c:	d8014715 	stw	zero,1308(sp)
 3208680:	dd400c15 	stw	r21,48(sp)
 3208684:	d8000e15 	stw	zero,56(sp)
 3208688:	d8000d15 	stw	zero,52(sp)
 320868c:	b8800007 	ldb	r2,0(r23)
 3208690:	10001926 	beq	r2,zero,32086f8 <___vfprintf_internal_r+0x1dc>
 3208694:	00c00944 	movi	r3,37
 3208698:	10c01726 	beq	r2,r3,32086f8 <___vfprintf_internal_r+0x1dc>
 320869c:	b821883a 	mov	r16,r23
 32086a0:	00000106 	br	32086a8 <___vfprintf_internal_r+0x18c>
 32086a4:	10c00326 	beq	r2,r3,32086b4 <___vfprintf_internal_r+0x198>
 32086a8:	84000044 	addi	r16,r16,1
 32086ac:	80800007 	ldb	r2,0(r16)
 32086b0:	103ffc1e 	bne	r2,zero,32086a4 <___vfprintf_internal_r+0x188>
 32086b4:	85e7c83a 	sub	r19,r16,r23
 32086b8:	98000e26 	beq	r19,zero,32086f4 <___vfprintf_internal_r+0x1d8>
 32086bc:	dc800e17 	ldw	r18,56(sp)
 32086c0:	dc400d17 	ldw	r17,52(sp)
 32086c4:	008001c4 	movi	r2,7
 32086c8:	94e5883a 	add	r18,r18,r19
 32086cc:	8c400044 	addi	r17,r17,1
 32086d0:	adc00015 	stw	r23,0(r21)
 32086d4:	dc800e15 	stw	r18,56(sp)
 32086d8:	acc00115 	stw	r19,4(r21)
 32086dc:	dc400d15 	stw	r17,52(sp)
 32086e0:	14428b16 	blt	r2,r17,3209110 <___vfprintf_internal_r+0xbf4>
 32086e4:	ad400204 	addi	r21,r21,8
 32086e8:	d9014b17 	ldw	r4,1324(sp)
 32086ec:	24c9883a 	add	r4,r4,r19
 32086f0:	d9014b15 	stw	r4,1324(sp)
 32086f4:	802f883a 	mov	r23,r16
 32086f8:	b8800007 	ldb	r2,0(r23)
 32086fc:	10013c26 	beq	r2,zero,3208bf0 <___vfprintf_internal_r+0x6d4>
 3208700:	bdc00044 	addi	r23,r23,1
 3208704:	d8000405 	stb	zero,16(sp)
 3208708:	b8c00007 	ldb	r3,0(r23)
 320870c:	04ffffc4 	movi	r19,-1
 3208710:	d8014c15 	stw	zero,1328(sp)
 3208714:	d8014a15 	stw	zero,1320(sp)
 3208718:	d8c14d15 	stw	r3,1332(sp)
 320871c:	bdc00044 	addi	r23,r23,1
 3208720:	d9414d17 	ldw	r5,1332(sp)
 3208724:	00801604 	movi	r2,88
 3208728:	28fff804 	addi	r3,r5,-32
 320872c:	10c06036 	bltu	r2,r3,32088b0 <___vfprintf_internal_r+0x394>
 3208730:	18c5883a 	add	r2,r3,r3
 3208734:	1085883a 	add	r2,r2,r2
 3208738:	00c0c874 	movhi	r3,801
 320873c:	18e1d304 	addi	r3,r3,-30900
 3208740:	10c5883a 	add	r2,r2,r3
 3208744:	11000017 	ldw	r4,0(r2)
 3208748:	2000683a 	jmp	r4
 320874c:	032096c0 	call	32096c <OSCtxSw_SWITCH_PC+0x32092c>
 3208750:	032088b0 	cmpltui	r12,zero,33314
 3208754:	032088b0 	cmpltui	r12,zero,33314
 3208758:	032096ac 	andhi	r12,zero,33370
 320875c:	032088b0 	cmpltui	r12,zero,33314
 3208760:	032088b0 	cmpltui	r12,zero,33314
 3208764:	032088b0 	cmpltui	r12,zero,33314
 3208768:	032088b0 	cmpltui	r12,zero,33314
 320876c:	032088b0 	cmpltui	r12,zero,33314
 3208770:	032088b0 	cmpltui	r12,zero,33314
 3208774:	0320948c 	andi	r12,zero,33362
 3208778:	0320969c 	xori	r12,zero,33370
 320877c:	032088b0 	cmpltui	r12,zero,33314
 3208780:	032094a4 	muli	r12,zero,-32174
 3208784:	03209738 	rdprs	r12,zero,-32164
 3208788:	032088b0 	cmpltui	r12,zero,33314
 320878c:	03209724 	muli	r12,zero,-32164
 3208790:	032096ec 	andhi	r12,zero,33371
 3208794:	032096ec 	andhi	r12,zero,33371
 3208798:	032096ec 	andhi	r12,zero,33371
 320879c:	032096ec 	andhi	r12,zero,33371
 32087a0:	032096ec 	andhi	r12,zero,33371
 32087a4:	032096ec 	andhi	r12,zero,33371
 32087a8:	032096ec 	andhi	r12,zero,33371
 32087ac:	032096ec 	andhi	r12,zero,33371
 32087b0:	032096ec 	andhi	r12,zero,33371
 32087b4:	032088b0 	cmpltui	r12,zero,33314
 32087b8:	032088b0 	cmpltui	r12,zero,33314
 32087bc:	032088b0 	cmpltui	r12,zero,33314
 32087c0:	032088b0 	cmpltui	r12,zero,33314
 32087c4:	032088b0 	cmpltui	r12,zero,33314
 32087c8:	032088b0 	cmpltui	r12,zero,33314
 32087cc:	032088b0 	cmpltui	r12,zero,33314
 32087d0:	032088b0 	cmpltui	r12,zero,33314
 32087d4:	032088b0 	cmpltui	r12,zero,33314
 32087d8:	032088b0 	cmpltui	r12,zero,33314
 32087dc:	03208f08 	cmpgei	r12,zero,-32196
 32087e0:	03209574 	movhi	r12,33365
 32087e4:	032088b0 	cmpltui	r12,zero,33314
 32087e8:	03209574 	movhi	r12,33365
 32087ec:	032088b0 	cmpltui	r12,zero,33314
 32087f0:	032088b0 	cmpltui	r12,zero,33314
 32087f4:	032088b0 	cmpltui	r12,zero,33314
 32087f8:	032088b0 	cmpltui	r12,zero,33314
 32087fc:	032096d8 	cmpnei	r12,zero,-32165
 3208800:	032088b0 	cmpltui	r12,zero,33314
 3208804:	032088b0 	cmpltui	r12,zero,33314
 3208808:	03208fbc 	xorhi	r12,zero,33342
 320880c:	032088b0 	cmpltui	r12,zero,33314
 3208810:	032088b0 	cmpltui	r12,zero,33314
 3208814:	032088b0 	cmpltui	r12,zero,33314
 3208818:	032088b0 	cmpltui	r12,zero,33314
 320881c:	032088b0 	cmpltui	r12,zero,33314
 3208820:	03209008 	cmpgei	r12,zero,-32192
 3208824:	032088b0 	cmpltui	r12,zero,33314
 3208828:	032088b0 	cmpltui	r12,zero,33314
 320882c:	03209628 	cmpgeui	r12,zero,33368
 3208830:	032088b0 	cmpltui	r12,zero,33314
 3208834:	032088b0 	cmpltui	r12,zero,33314
 3208838:	032088b0 	cmpltui	r12,zero,33314
 320883c:	032088b0 	cmpltui	r12,zero,33314
 3208840:	032088b0 	cmpltui	r12,zero,33314
 3208844:	032088b0 	cmpltui	r12,zero,33314
 3208848:	032088b0 	cmpltui	r12,zero,33314
 320884c:	032088b0 	cmpltui	r12,zero,33314
 3208850:	032088b0 	cmpltui	r12,zero,33314
 3208854:	032088b0 	cmpltui	r12,zero,33314
 3208858:	032095fc 	xorhi	r12,zero,33367
 320885c:	03208f14 	movui	r12,33340
 3208860:	03209574 	movhi	r12,33365
 3208864:	03209574 	movhi	r12,33365
 3208868:	03209574 	movhi	r12,33365
 320886c:	03209560 	cmpeqi	r12,zero,-32171
 3208870:	03208f14 	movui	r12,33340
 3208874:	032088b0 	cmpltui	r12,zero,33314
 3208878:	032088b0 	cmpltui	r12,zero,33314
 320887c:	032094e8 	cmpgeui	r12,zero,33363
 3208880:	032088b0 	cmpltui	r12,zero,33314
 3208884:	032094b8 	rdprs	r12,zero,-32174
 3208888:	03208fc8 	cmpgei	r12,zero,-32193
 320888c:	03209518 	cmpnei	r12,zero,-32172
 3208890:	03209504 	movi	r12,-32172
 3208894:	032088b0 	cmpltui	r12,zero,33314
 3208898:	03209794 	movui	r12,33374
 320889c:	032088b0 	cmpltui	r12,zero,33314
 32088a0:	03209014 	movui	r12,33344
 32088a4:	032088b0 	cmpltui	r12,zero,33314
 32088a8:	032088b0 	cmpltui	r12,zero,33314
 32088ac:	0320968c 	andi	r12,zero,33370
 32088b0:	d9014d17 	ldw	r4,1332(sp)
 32088b4:	2000ce26 	beq	r4,zero,3208bf0 <___vfprintf_internal_r+0x6d4>
 32088b8:	01400044 	movi	r5,1
 32088bc:	d9800f04 	addi	r6,sp,60
 32088c0:	d9c14015 	stw	r7,1280(sp)
 32088c4:	d9414515 	stw	r5,1300(sp)
 32088c8:	d9814115 	stw	r6,1284(sp)
 32088cc:	280f883a 	mov	r7,r5
 32088d0:	d9000f05 	stb	r4,60(sp)
 32088d4:	d8000405 	stb	zero,16(sp)
 32088d8:	d8014615 	stw	zero,1304(sp)
 32088dc:	d8c14c17 	ldw	r3,1328(sp)
 32088e0:	1880008c 	andi	r2,r3,2
 32088e4:	1005003a 	cmpeq	r2,r2,zero
 32088e8:	d8815015 	stw	r2,1344(sp)
 32088ec:	1000031e 	bne	r2,zero,32088fc <___vfprintf_internal_r+0x3e0>
 32088f0:	d9014517 	ldw	r4,1300(sp)
 32088f4:	21000084 	addi	r4,r4,2
 32088f8:	d9014515 	stw	r4,1300(sp)
 32088fc:	d9414c17 	ldw	r5,1328(sp)
 3208900:	2940210c 	andi	r5,r5,132
 3208904:	d9414e15 	stw	r5,1336(sp)
 3208908:	28002d1e 	bne	r5,zero,32089c0 <___vfprintf_internal_r+0x4a4>
 320890c:	d9814a17 	ldw	r6,1320(sp)
 3208910:	d8814517 	ldw	r2,1300(sp)
 3208914:	30a1c83a 	sub	r16,r6,r2
 3208918:	0400290e 	bge	zero,r16,32089c0 <___vfprintf_internal_r+0x4a4>
 320891c:	00800404 	movi	r2,16
 3208920:	1404580e 	bge	r2,r16,3209a84 <___vfprintf_internal_r+0x1568>
 3208924:	dc800e17 	ldw	r18,56(sp)
 3208928:	dc400d17 	ldw	r17,52(sp)
 320892c:	1027883a 	mov	r19,r2
 3208930:	0700c974 	movhi	fp,805
 3208934:	e738b084 	addi	fp,fp,-7486
 3208938:	050001c4 	movi	r20,7
 320893c:	00000306 	br	320894c <___vfprintf_internal_r+0x430>
 3208940:	843ffc04 	addi	r16,r16,-16
 3208944:	ad400204 	addi	r21,r21,8
 3208948:	9c00130e 	bge	r19,r16,3208998 <___vfprintf_internal_r+0x47c>
 320894c:	94800404 	addi	r18,r18,16
 3208950:	8c400044 	addi	r17,r17,1
 3208954:	af000015 	stw	fp,0(r21)
 3208958:	acc00115 	stw	r19,4(r21)
 320895c:	dc800e15 	stw	r18,56(sp)
 3208960:	dc400d15 	stw	r17,52(sp)
 3208964:	a47ff60e 	bge	r20,r17,3208940 <___vfprintf_internal_r+0x424>
 3208968:	d9014f17 	ldw	r4,1340(sp)
 320896c:	b00b883a 	mov	r5,r22
 3208970:	d9800c04 	addi	r6,sp,48
 3208974:	d9c15115 	stw	r7,1348(sp)
 3208978:	32084c40 	call	32084c4 <__sprint_r>
 320897c:	d9c15117 	ldw	r7,1348(sp)
 3208980:	10009e1e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3208984:	843ffc04 	addi	r16,r16,-16
 3208988:	dc800e17 	ldw	r18,56(sp)
 320898c:	dc400d17 	ldw	r17,52(sp)
 3208990:	dd401904 	addi	r21,sp,100
 3208994:	9c3fed16 	blt	r19,r16,320894c <___vfprintf_internal_r+0x430>
 3208998:	9425883a 	add	r18,r18,r16
 320899c:	8c400044 	addi	r17,r17,1
 32089a0:	008001c4 	movi	r2,7
 32089a4:	af000015 	stw	fp,0(r21)
 32089a8:	ac000115 	stw	r16,4(r21)
 32089ac:	dc800e15 	stw	r18,56(sp)
 32089b0:	dc400d15 	stw	r17,52(sp)
 32089b4:	1441f516 	blt	r2,r17,320918c <___vfprintf_internal_r+0xc70>
 32089b8:	ad400204 	addi	r21,r21,8
 32089bc:	00000206 	br	32089c8 <___vfprintf_internal_r+0x4ac>
 32089c0:	dc800e17 	ldw	r18,56(sp)
 32089c4:	dc400d17 	ldw	r17,52(sp)
 32089c8:	d8800407 	ldb	r2,16(sp)
 32089cc:	10000b26 	beq	r2,zero,32089fc <___vfprintf_internal_r+0x4e0>
 32089d0:	00800044 	movi	r2,1
 32089d4:	94800044 	addi	r18,r18,1
 32089d8:	8c400044 	addi	r17,r17,1
 32089dc:	a8800115 	stw	r2,4(r21)
 32089e0:	d8c00404 	addi	r3,sp,16
 32089e4:	008001c4 	movi	r2,7
 32089e8:	a8c00015 	stw	r3,0(r21)
 32089ec:	dc800e15 	stw	r18,56(sp)
 32089f0:	dc400d15 	stw	r17,52(sp)
 32089f4:	1441da16 	blt	r2,r17,3209160 <___vfprintf_internal_r+0xc44>
 32089f8:	ad400204 	addi	r21,r21,8
 32089fc:	d9015017 	ldw	r4,1344(sp)
 3208a00:	20000b1e 	bne	r4,zero,3208a30 <___vfprintf_internal_r+0x514>
 3208a04:	d8800444 	addi	r2,sp,17
 3208a08:	94800084 	addi	r18,r18,2
 3208a0c:	8c400044 	addi	r17,r17,1
 3208a10:	a8800015 	stw	r2,0(r21)
 3208a14:	00c00084 	movi	r3,2
 3208a18:	008001c4 	movi	r2,7
 3208a1c:	a8c00115 	stw	r3,4(r21)
 3208a20:	dc800e15 	stw	r18,56(sp)
 3208a24:	dc400d15 	stw	r17,52(sp)
 3208a28:	1441c216 	blt	r2,r17,3209134 <___vfprintf_internal_r+0xc18>
 3208a2c:	ad400204 	addi	r21,r21,8
 3208a30:	d9414e17 	ldw	r5,1336(sp)
 3208a34:	00802004 	movi	r2,128
 3208a38:	2880b126 	beq	r5,r2,3208d00 <___vfprintf_internal_r+0x7e4>
 3208a3c:	d8c14617 	ldw	r3,1304(sp)
 3208a40:	19e1c83a 	sub	r16,r3,r7
 3208a44:	0400260e 	bge	zero,r16,3208ae0 <___vfprintf_internal_r+0x5c4>
 3208a48:	00800404 	movi	r2,16
 3208a4c:	1403c90e 	bge	r2,r16,3209974 <___vfprintf_internal_r+0x1458>
 3208a50:	1027883a 	mov	r19,r2
 3208a54:	0700c974 	movhi	fp,805
 3208a58:	e738ac84 	addi	fp,fp,-7502
 3208a5c:	050001c4 	movi	r20,7
 3208a60:	00000306 	br	3208a70 <___vfprintf_internal_r+0x554>
 3208a64:	843ffc04 	addi	r16,r16,-16
 3208a68:	ad400204 	addi	r21,r21,8
 3208a6c:	9c00130e 	bge	r19,r16,3208abc <___vfprintf_internal_r+0x5a0>
 3208a70:	94800404 	addi	r18,r18,16
 3208a74:	8c400044 	addi	r17,r17,1
 3208a78:	af000015 	stw	fp,0(r21)
 3208a7c:	acc00115 	stw	r19,4(r21)
 3208a80:	dc800e15 	stw	r18,56(sp)
 3208a84:	dc400d15 	stw	r17,52(sp)
 3208a88:	a47ff60e 	bge	r20,r17,3208a64 <___vfprintf_internal_r+0x548>
 3208a8c:	d9014f17 	ldw	r4,1340(sp)
 3208a90:	b00b883a 	mov	r5,r22
 3208a94:	d9800c04 	addi	r6,sp,48
 3208a98:	d9c15115 	stw	r7,1348(sp)
 3208a9c:	32084c40 	call	32084c4 <__sprint_r>
 3208aa0:	d9c15117 	ldw	r7,1348(sp)
 3208aa4:	1000551e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3208aa8:	843ffc04 	addi	r16,r16,-16
 3208aac:	dc800e17 	ldw	r18,56(sp)
 3208ab0:	dc400d17 	ldw	r17,52(sp)
 3208ab4:	dd401904 	addi	r21,sp,100
 3208ab8:	9c3fed16 	blt	r19,r16,3208a70 <___vfprintf_internal_r+0x554>
 3208abc:	9425883a 	add	r18,r18,r16
 3208ac0:	8c400044 	addi	r17,r17,1
 3208ac4:	008001c4 	movi	r2,7
 3208ac8:	af000015 	stw	fp,0(r21)
 3208acc:	ac000115 	stw	r16,4(r21)
 3208ad0:	dc800e15 	stw	r18,56(sp)
 3208ad4:	dc400d15 	stw	r17,52(sp)
 3208ad8:	14418216 	blt	r2,r17,32090e4 <___vfprintf_internal_r+0xbc8>
 3208adc:	ad400204 	addi	r21,r21,8
 3208ae0:	d9014c17 	ldw	r4,1328(sp)
 3208ae4:	2080400c 	andi	r2,r4,256
 3208ae8:	10004a1e 	bne	r2,zero,3208c14 <___vfprintf_internal_r+0x6f8>
 3208aec:	d9414117 	ldw	r5,1284(sp)
 3208af0:	91e5883a 	add	r18,r18,r7
 3208af4:	8c400044 	addi	r17,r17,1
 3208af8:	008001c4 	movi	r2,7
 3208afc:	a9400015 	stw	r5,0(r21)
 3208b00:	a9c00115 	stw	r7,4(r21)
 3208b04:	dc800e15 	stw	r18,56(sp)
 3208b08:	dc400d15 	stw	r17,52(sp)
 3208b0c:	14416716 	blt	r2,r17,32090ac <___vfprintf_internal_r+0xb90>
 3208b10:	a8c00204 	addi	r3,r21,8
 3208b14:	d9814c17 	ldw	r6,1328(sp)
 3208b18:	3080010c 	andi	r2,r6,4
 3208b1c:	10002826 	beq	r2,zero,3208bc0 <___vfprintf_internal_r+0x6a4>
 3208b20:	d8814a17 	ldw	r2,1320(sp)
 3208b24:	d9014517 	ldw	r4,1300(sp)
 3208b28:	1121c83a 	sub	r16,r2,r4
 3208b2c:	0400240e 	bge	zero,r16,3208bc0 <___vfprintf_internal_r+0x6a4>
 3208b30:	00800404 	movi	r2,16
 3208b34:	14044f0e 	bge	r2,r16,3209c74 <___vfprintf_internal_r+0x1758>
 3208b38:	dc400d17 	ldw	r17,52(sp)
 3208b3c:	1027883a 	mov	r19,r2
 3208b40:	0700c974 	movhi	fp,805
 3208b44:	e738b084 	addi	fp,fp,-7486
 3208b48:	050001c4 	movi	r20,7
 3208b4c:	00000306 	br	3208b5c <___vfprintf_internal_r+0x640>
 3208b50:	843ffc04 	addi	r16,r16,-16
 3208b54:	18c00204 	addi	r3,r3,8
 3208b58:	9c00110e 	bge	r19,r16,3208ba0 <___vfprintf_internal_r+0x684>
 3208b5c:	94800404 	addi	r18,r18,16
 3208b60:	8c400044 	addi	r17,r17,1
 3208b64:	1f000015 	stw	fp,0(r3)
 3208b68:	1cc00115 	stw	r19,4(r3)
 3208b6c:	dc800e15 	stw	r18,56(sp)
 3208b70:	dc400d15 	stw	r17,52(sp)
 3208b74:	a47ff60e 	bge	r20,r17,3208b50 <___vfprintf_internal_r+0x634>
 3208b78:	d9014f17 	ldw	r4,1340(sp)
 3208b7c:	b00b883a 	mov	r5,r22
 3208b80:	d9800c04 	addi	r6,sp,48
 3208b84:	32084c40 	call	32084c4 <__sprint_r>
 3208b88:	10001c1e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3208b8c:	843ffc04 	addi	r16,r16,-16
 3208b90:	dc800e17 	ldw	r18,56(sp)
 3208b94:	dc400d17 	ldw	r17,52(sp)
 3208b98:	d8c01904 	addi	r3,sp,100
 3208b9c:	9c3fef16 	blt	r19,r16,3208b5c <___vfprintf_internal_r+0x640>
 3208ba0:	9425883a 	add	r18,r18,r16
 3208ba4:	8c400044 	addi	r17,r17,1
 3208ba8:	008001c4 	movi	r2,7
 3208bac:	1f000015 	stw	fp,0(r3)
 3208bb0:	1c000115 	stw	r16,4(r3)
 3208bb4:	dc800e15 	stw	r18,56(sp)
 3208bb8:	dc400d15 	stw	r17,52(sp)
 3208bbc:	1440cb16 	blt	r2,r17,3208eec <___vfprintf_internal_r+0x9d0>
 3208bc0:	d8814a17 	ldw	r2,1320(sp)
 3208bc4:	d9414517 	ldw	r5,1300(sp)
 3208bc8:	1140010e 	bge	r2,r5,3208bd0 <___vfprintf_internal_r+0x6b4>
 3208bcc:	2805883a 	mov	r2,r5
 3208bd0:	d9814b17 	ldw	r6,1324(sp)
 3208bd4:	308d883a 	add	r6,r6,r2
 3208bd8:	d9814b15 	stw	r6,1324(sp)
 3208bdc:	90013b1e 	bne	r18,zero,32090cc <___vfprintf_internal_r+0xbb0>
 3208be0:	d9c14017 	ldw	r7,1280(sp)
 3208be4:	dd401904 	addi	r21,sp,100
 3208be8:	d8000d15 	stw	zero,52(sp)
 3208bec:	003ea706 	br	320868c <___vfprintf_internal_r+0x170>
 3208bf0:	d8800e17 	ldw	r2,56(sp)
 3208bf4:	10053f1e 	bne	r2,zero,320a0f4 <___vfprintf_internal_r+0x1bd8>
 3208bf8:	d8000d15 	stw	zero,52(sp)
 3208bfc:	b080030b 	ldhu	r2,12(r22)
 3208c00:	1080100c 	andi	r2,r2,64
 3208c04:	103e8726 	beq	r2,zero,3208624 <___vfprintf_internal_r+0x108>
 3208c08:	00bfffc4 	movi	r2,-1
 3208c0c:	d8814b15 	stw	r2,1324(sp)
 3208c10:	003e8406 	br	3208624 <___vfprintf_internal_r+0x108>
 3208c14:	d9814d17 	ldw	r6,1332(sp)
 3208c18:	00801944 	movi	r2,101
 3208c1c:	11806e16 	blt	r2,r6,3208dd8 <___vfprintf_internal_r+0x8bc>
 3208c20:	d9414717 	ldw	r5,1308(sp)
 3208c24:	00c00044 	movi	r3,1
 3208c28:	1943430e 	bge	r3,r5,3209938 <___vfprintf_internal_r+0x141c>
 3208c2c:	d8814117 	ldw	r2,1284(sp)
 3208c30:	94800044 	addi	r18,r18,1
 3208c34:	8c400044 	addi	r17,r17,1
 3208c38:	a8800015 	stw	r2,0(r21)
 3208c3c:	008001c4 	movi	r2,7
 3208c40:	a8c00115 	stw	r3,4(r21)
 3208c44:	dc800e15 	stw	r18,56(sp)
 3208c48:	dc400d15 	stw	r17,52(sp)
 3208c4c:	1441ca16 	blt	r2,r17,3209378 <___vfprintf_internal_r+0xe5c>
 3208c50:	a8c00204 	addi	r3,r21,8
 3208c54:	d9014917 	ldw	r4,1316(sp)
 3208c58:	00800044 	movi	r2,1
 3208c5c:	94800044 	addi	r18,r18,1
 3208c60:	8c400044 	addi	r17,r17,1
 3208c64:	18800115 	stw	r2,4(r3)
 3208c68:	008001c4 	movi	r2,7
 3208c6c:	19000015 	stw	r4,0(r3)
 3208c70:	dc800e15 	stw	r18,56(sp)
 3208c74:	dc400d15 	stw	r17,52(sp)
 3208c78:	1441b616 	blt	r2,r17,3209354 <___vfprintf_internal_r+0xe38>
 3208c7c:	1cc00204 	addi	r19,r3,8
 3208c80:	d9014217 	ldw	r4,1288(sp)
 3208c84:	d9414317 	ldw	r5,1292(sp)
 3208c88:	000d883a 	mov	r6,zero
 3208c8c:	000f883a 	mov	r7,zero
 3208c90:	32139500 	call	3213950 <__nedf2>
 3208c94:	10017426 	beq	r2,zero,3209268 <___vfprintf_internal_r+0xd4c>
 3208c98:	d9414717 	ldw	r5,1308(sp)
 3208c9c:	d9814117 	ldw	r6,1284(sp)
 3208ca0:	8c400044 	addi	r17,r17,1
 3208ca4:	2c85883a 	add	r2,r5,r18
 3208ca8:	14bfffc4 	addi	r18,r2,-1
 3208cac:	28bfffc4 	addi	r2,r5,-1
 3208cb0:	30c00044 	addi	r3,r6,1
 3208cb4:	98800115 	stw	r2,4(r19)
 3208cb8:	008001c4 	movi	r2,7
 3208cbc:	98c00015 	stw	r3,0(r19)
 3208cc0:	dc800e15 	stw	r18,56(sp)
 3208cc4:	dc400d15 	stw	r17,52(sp)
 3208cc8:	14418e16 	blt	r2,r17,3209304 <___vfprintf_internal_r+0xde8>
 3208ccc:	9cc00204 	addi	r19,r19,8
 3208cd0:	d9414817 	ldw	r5,1312(sp)
 3208cd4:	d8800804 	addi	r2,sp,32
 3208cd8:	8c400044 	addi	r17,r17,1
 3208cdc:	9165883a 	add	r18,r18,r5
 3208ce0:	98800015 	stw	r2,0(r19)
 3208ce4:	008001c4 	movi	r2,7
 3208ce8:	99400115 	stw	r5,4(r19)
 3208cec:	dc800e15 	stw	r18,56(sp)
 3208cf0:	dc400d15 	stw	r17,52(sp)
 3208cf4:	1440ed16 	blt	r2,r17,32090ac <___vfprintf_internal_r+0xb90>
 3208cf8:	98c00204 	addi	r3,r19,8
 3208cfc:	003f8506 	br	3208b14 <___vfprintf_internal_r+0x5f8>
 3208d00:	d9814a17 	ldw	r6,1320(sp)
 3208d04:	d8814517 	ldw	r2,1300(sp)
 3208d08:	30a1c83a 	sub	r16,r6,r2
 3208d0c:	043f4b0e 	bge	zero,r16,3208a3c <___vfprintf_internal_r+0x520>
 3208d10:	00800404 	movi	r2,16
 3208d14:	1404340e 	bge	r2,r16,3209de8 <___vfprintf_internal_r+0x18cc>
 3208d18:	1027883a 	mov	r19,r2
 3208d1c:	0700c974 	movhi	fp,805
 3208d20:	e738ac84 	addi	fp,fp,-7502
 3208d24:	050001c4 	movi	r20,7
 3208d28:	00000306 	br	3208d38 <___vfprintf_internal_r+0x81c>
 3208d2c:	843ffc04 	addi	r16,r16,-16
 3208d30:	ad400204 	addi	r21,r21,8
 3208d34:	9c00130e 	bge	r19,r16,3208d84 <___vfprintf_internal_r+0x868>
 3208d38:	94800404 	addi	r18,r18,16
 3208d3c:	8c400044 	addi	r17,r17,1
 3208d40:	af000015 	stw	fp,0(r21)
 3208d44:	acc00115 	stw	r19,4(r21)
 3208d48:	dc800e15 	stw	r18,56(sp)
 3208d4c:	dc400d15 	stw	r17,52(sp)
 3208d50:	a47ff60e 	bge	r20,r17,3208d2c <___vfprintf_internal_r+0x810>
 3208d54:	d9014f17 	ldw	r4,1340(sp)
 3208d58:	b00b883a 	mov	r5,r22
 3208d5c:	d9800c04 	addi	r6,sp,48
 3208d60:	d9c15115 	stw	r7,1348(sp)
 3208d64:	32084c40 	call	32084c4 <__sprint_r>
 3208d68:	d9c15117 	ldw	r7,1348(sp)
 3208d6c:	103fa31e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3208d70:	843ffc04 	addi	r16,r16,-16
 3208d74:	dc800e17 	ldw	r18,56(sp)
 3208d78:	dc400d17 	ldw	r17,52(sp)
 3208d7c:	dd401904 	addi	r21,sp,100
 3208d80:	9c3fed16 	blt	r19,r16,3208d38 <___vfprintf_internal_r+0x81c>
 3208d84:	9425883a 	add	r18,r18,r16
 3208d88:	8c400044 	addi	r17,r17,1
 3208d8c:	008001c4 	movi	r2,7
 3208d90:	af000015 	stw	fp,0(r21)
 3208d94:	ac000115 	stw	r16,4(r21)
 3208d98:	dc800e15 	stw	r18,56(sp)
 3208d9c:	dc400d15 	stw	r17,52(sp)
 3208da0:	14416116 	blt	r2,r17,3209328 <___vfprintf_internal_r+0xe0c>
 3208da4:	ad400204 	addi	r21,r21,8
 3208da8:	003f2406 	br	3208a3c <___vfprintf_internal_r+0x520>
 3208dac:	d9014f17 	ldw	r4,1340(sp)
 3208db0:	3204b8c0 	call	3204b8c <__sinit>
 3208db4:	d9c15117 	ldw	r7,1348(sp)
 3208db8:	003def06 	br	3208578 <___vfprintf_internal_r+0x5c>
 3208dbc:	d9014f17 	ldw	r4,1340(sp)
 3208dc0:	b00b883a 	mov	r5,r22
 3208dc4:	d9c15115 	stw	r7,1348(sp)
 3208dc8:	320bd300 	call	320bd30 <__swsetup_r>
 3208dcc:	d9c15117 	ldw	r7,1348(sp)
 3208dd0:	103dee26 	beq	r2,zero,320858c <___vfprintf_internal_r+0x70>
 3208dd4:	003f8c06 	br	3208c08 <___vfprintf_internal_r+0x6ec>
 3208dd8:	d9014217 	ldw	r4,1288(sp)
 3208ddc:	d9414317 	ldw	r5,1292(sp)
 3208de0:	000d883a 	mov	r6,zero
 3208de4:	000f883a 	mov	r7,zero
 3208de8:	32138c80 	call	32138c8 <__eqdf2>
 3208dec:	1000f21e 	bne	r2,zero,32091b8 <___vfprintf_internal_r+0xc9c>
 3208df0:	0080c974 	movhi	r2,805
 3208df4:	10b8ac04 	addi	r2,r2,-7504
 3208df8:	94800044 	addi	r18,r18,1
 3208dfc:	8c400044 	addi	r17,r17,1
 3208e00:	a8800015 	stw	r2,0(r21)
 3208e04:	00c00044 	movi	r3,1
 3208e08:	008001c4 	movi	r2,7
 3208e0c:	a8c00115 	stw	r3,4(r21)
 3208e10:	dc800e15 	stw	r18,56(sp)
 3208e14:	dc400d15 	stw	r17,52(sp)
 3208e18:	1442fa16 	blt	r2,r17,3209a04 <___vfprintf_internal_r+0x14e8>
 3208e1c:	a8c00204 	addi	r3,r21,8
 3208e20:	d8800517 	ldw	r2,20(sp)
 3208e24:	d9014717 	ldw	r4,1308(sp)
 3208e28:	11015c0e 	bge	r2,r4,320939c <___vfprintf_internal_r+0xe80>
 3208e2c:	dc400d17 	ldw	r17,52(sp)
 3208e30:	d9814917 	ldw	r6,1316(sp)
 3208e34:	00800044 	movi	r2,1
 3208e38:	94800044 	addi	r18,r18,1
 3208e3c:	8c400044 	addi	r17,r17,1
 3208e40:	18800115 	stw	r2,4(r3)
 3208e44:	008001c4 	movi	r2,7
 3208e48:	19800015 	stw	r6,0(r3)
 3208e4c:	dc800e15 	stw	r18,56(sp)
 3208e50:	dc400d15 	stw	r17,52(sp)
 3208e54:	14431016 	blt	r2,r17,3209a98 <___vfprintf_internal_r+0x157c>
 3208e58:	18c00204 	addi	r3,r3,8
 3208e5c:	d8814717 	ldw	r2,1308(sp)
 3208e60:	143fffc4 	addi	r16,r2,-1
 3208e64:	043f2b0e 	bge	zero,r16,3208b14 <___vfprintf_internal_r+0x5f8>
 3208e68:	00800404 	movi	r2,16
 3208e6c:	1402a20e 	bge	r2,r16,32098f8 <___vfprintf_internal_r+0x13dc>
 3208e70:	dc400d17 	ldw	r17,52(sp)
 3208e74:	1027883a 	mov	r19,r2
 3208e78:	0700c974 	movhi	fp,805
 3208e7c:	e738ac84 	addi	fp,fp,-7502
 3208e80:	050001c4 	movi	r20,7
 3208e84:	00000306 	br	3208e94 <___vfprintf_internal_r+0x978>
 3208e88:	18c00204 	addi	r3,r3,8
 3208e8c:	843ffc04 	addi	r16,r16,-16
 3208e90:	9c029c0e 	bge	r19,r16,3209904 <___vfprintf_internal_r+0x13e8>
 3208e94:	94800404 	addi	r18,r18,16
 3208e98:	8c400044 	addi	r17,r17,1
 3208e9c:	1f000015 	stw	fp,0(r3)
 3208ea0:	1cc00115 	stw	r19,4(r3)
 3208ea4:	dc800e15 	stw	r18,56(sp)
 3208ea8:	dc400d15 	stw	r17,52(sp)
 3208eac:	a47ff60e 	bge	r20,r17,3208e88 <___vfprintf_internal_r+0x96c>
 3208eb0:	d9014f17 	ldw	r4,1340(sp)
 3208eb4:	b00b883a 	mov	r5,r22
 3208eb8:	d9800c04 	addi	r6,sp,48
 3208ebc:	32084c40 	call	32084c4 <__sprint_r>
 3208ec0:	103f4e1e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3208ec4:	dc800e17 	ldw	r18,56(sp)
 3208ec8:	dc400d17 	ldw	r17,52(sp)
 3208ecc:	d8c01904 	addi	r3,sp,100
 3208ed0:	003fee06 	br	3208e8c <___vfprintf_internal_r+0x970>
 3208ed4:	d8802c0b 	ldhu	r2,176(sp)
 3208ed8:	00ffffc4 	movi	r3,-1
 3208edc:	d8c14b15 	stw	r3,1324(sp)
 3208ee0:	1080100c 	andi	r2,r2,64
 3208ee4:	103dcc1e 	bne	r2,zero,3208618 <___vfprintf_internal_r+0xfc>
 3208ee8:	003dce06 	br	3208624 <___vfprintf_internal_r+0x108>
 3208eec:	d9014f17 	ldw	r4,1340(sp)
 3208ef0:	b00b883a 	mov	r5,r22
 3208ef4:	d9800c04 	addi	r6,sp,48
 3208ef8:	32084c40 	call	32084c4 <__sprint_r>
 3208efc:	103f3f1e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3208f00:	dc800e17 	ldw	r18,56(sp)
 3208f04:	003f2e06 	br	3208bc0 <___vfprintf_internal_r+0x6a4>
 3208f08:	d9414c17 	ldw	r5,1328(sp)
 3208f0c:	29400414 	ori	r5,r5,16
 3208f10:	d9414c15 	stw	r5,1328(sp)
 3208f14:	d9814c17 	ldw	r6,1328(sp)
 3208f18:	3080080c 	andi	r2,r6,32
 3208f1c:	10014f1e 	bne	r2,zero,320945c <___vfprintf_internal_r+0xf40>
 3208f20:	d8c14c17 	ldw	r3,1328(sp)
 3208f24:	1880040c 	andi	r2,r3,16
 3208f28:	1002ea1e 	bne	r2,zero,3209ad4 <___vfprintf_internal_r+0x15b8>
 3208f2c:	d9014c17 	ldw	r4,1328(sp)
 3208f30:	2080100c 	andi	r2,r4,64
 3208f34:	1002e726 	beq	r2,zero,3209ad4 <___vfprintf_internal_r+0x15b8>
 3208f38:	3880000f 	ldh	r2,0(r7)
 3208f3c:	39c00104 	addi	r7,r7,4
 3208f40:	d9c14015 	stw	r7,1280(sp)
 3208f44:	1023d7fa 	srai	r17,r2,31
 3208f48:	1021883a 	mov	r16,r2
 3208f4c:	88037216 	blt	r17,zero,3209d18 <___vfprintf_internal_r+0x17fc>
 3208f50:	01000044 	movi	r4,1
 3208f54:	98000416 	blt	r19,zero,3208f68 <___vfprintf_internal_r+0xa4c>
 3208f58:	d8c14c17 	ldw	r3,1328(sp)
 3208f5c:	00bfdfc4 	movi	r2,-129
 3208f60:	1886703a 	and	r3,r3,r2
 3208f64:	d8c14c15 	stw	r3,1328(sp)
 3208f68:	8444b03a 	or	r2,r16,r17
 3208f6c:	1002261e 	bne	r2,zero,3209808 <___vfprintf_internal_r+0x12ec>
 3208f70:	9802251e 	bne	r19,zero,3209808 <___vfprintf_internal_r+0x12ec>
 3208f74:	20803fcc 	andi	r2,r4,255
 3208f78:	10029b26 	beq	r2,zero,32099e8 <___vfprintf_internal_r+0x14cc>
 3208f7c:	d8c01904 	addi	r3,sp,100
 3208f80:	dd000f04 	addi	r20,sp,60
 3208f84:	d8c14115 	stw	r3,1284(sp)
 3208f88:	d8c14117 	ldw	r3,1284(sp)
 3208f8c:	dcc14515 	stw	r19,1300(sp)
 3208f90:	a0c5c83a 	sub	r2,r20,r3
 3208f94:	11c00a04 	addi	r7,r2,40
 3208f98:	99c0010e 	bge	r19,r7,3208fa0 <___vfprintf_internal_r+0xa84>
 3208f9c:	d9c14515 	stw	r7,1300(sp)
 3208fa0:	dcc14615 	stw	r19,1304(sp)
 3208fa4:	d8800407 	ldb	r2,16(sp)
 3208fa8:	103e4c26 	beq	r2,zero,32088dc <___vfprintf_internal_r+0x3c0>
 3208fac:	d8814517 	ldw	r2,1300(sp)
 3208fb0:	10800044 	addi	r2,r2,1
 3208fb4:	d8814515 	stw	r2,1300(sp)
 3208fb8:	003e4806 	br	32088dc <___vfprintf_internal_r+0x3c0>
 3208fbc:	d9814c17 	ldw	r6,1328(sp)
 3208fc0:	31800414 	ori	r6,r6,16
 3208fc4:	d9814c15 	stw	r6,1328(sp)
 3208fc8:	d8c14c17 	ldw	r3,1328(sp)
 3208fcc:	1880080c 	andi	r2,r3,32
 3208fd0:	1001271e 	bne	r2,zero,3209470 <___vfprintf_internal_r+0xf54>
 3208fd4:	d9414c17 	ldw	r5,1328(sp)
 3208fd8:	2880040c 	andi	r2,r5,16
 3208fdc:	1002b61e 	bne	r2,zero,3209ab8 <___vfprintf_internal_r+0x159c>
 3208fe0:	d9814c17 	ldw	r6,1328(sp)
 3208fe4:	3080100c 	andi	r2,r6,64
 3208fe8:	1002b326 	beq	r2,zero,3209ab8 <___vfprintf_internal_r+0x159c>
 3208fec:	3c00000b 	ldhu	r16,0(r7)
 3208ff0:	0009883a 	mov	r4,zero
 3208ff4:	39c00104 	addi	r7,r7,4
 3208ff8:	0023883a 	mov	r17,zero
 3208ffc:	d9c14015 	stw	r7,1280(sp)
 3209000:	d8000405 	stb	zero,16(sp)
 3209004:	003fd306 	br	3208f54 <___vfprintf_internal_r+0xa38>
 3209008:	d9014c17 	ldw	r4,1328(sp)
 320900c:	21000414 	ori	r4,r4,16
 3209010:	d9014c15 	stw	r4,1328(sp)
 3209014:	d9414c17 	ldw	r5,1328(sp)
 3209018:	2880080c 	andi	r2,r5,32
 320901c:	1001081e 	bne	r2,zero,3209440 <___vfprintf_internal_r+0xf24>
 3209020:	d8c14c17 	ldw	r3,1328(sp)
 3209024:	1880040c 	andi	r2,r3,16
 3209028:	1002b01e 	bne	r2,zero,3209aec <___vfprintf_internal_r+0x15d0>
 320902c:	d9014c17 	ldw	r4,1328(sp)
 3209030:	2080100c 	andi	r2,r4,64
 3209034:	1002ad26 	beq	r2,zero,3209aec <___vfprintf_internal_r+0x15d0>
 3209038:	3c00000b 	ldhu	r16,0(r7)
 320903c:	01000044 	movi	r4,1
 3209040:	39c00104 	addi	r7,r7,4
 3209044:	0023883a 	mov	r17,zero
 3209048:	d9c14015 	stw	r7,1280(sp)
 320904c:	d8000405 	stb	zero,16(sp)
 3209050:	003fc006 	br	3208f54 <___vfprintf_internal_r+0xa38>
 3209054:	d9014f17 	ldw	r4,1340(sp)
 3209058:	b00b883a 	mov	r5,r22
 320905c:	d9800c04 	addi	r6,sp,48
 3209060:	32084c40 	call	32084c4 <__sprint_r>
 3209064:	103ee51e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3209068:	dc800e17 	ldw	r18,56(sp)
 320906c:	d8c01904 	addi	r3,sp,100
 3209070:	d9814c17 	ldw	r6,1328(sp)
 3209074:	3080004c 	andi	r2,r6,1
 3209078:	1005003a 	cmpeq	r2,r2,zero
 320907c:	103ea51e 	bne	r2,zero,3208b14 <___vfprintf_internal_r+0x5f8>
 3209080:	00800044 	movi	r2,1
 3209084:	dc400d17 	ldw	r17,52(sp)
 3209088:	18800115 	stw	r2,4(r3)
 320908c:	d8814917 	ldw	r2,1316(sp)
 3209090:	94800044 	addi	r18,r18,1
 3209094:	8c400044 	addi	r17,r17,1
 3209098:	18800015 	stw	r2,0(r3)
 320909c:	008001c4 	movi	r2,7
 32090a0:	dc800e15 	stw	r18,56(sp)
 32090a4:	dc400d15 	stw	r17,52(sp)
 32090a8:	14421e0e 	bge	r2,r17,3209924 <___vfprintf_internal_r+0x1408>
 32090ac:	d9014f17 	ldw	r4,1340(sp)
 32090b0:	b00b883a 	mov	r5,r22
 32090b4:	d9800c04 	addi	r6,sp,48
 32090b8:	32084c40 	call	32084c4 <__sprint_r>
 32090bc:	103ecf1e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 32090c0:	dc800e17 	ldw	r18,56(sp)
 32090c4:	d8c01904 	addi	r3,sp,100
 32090c8:	003e9206 	br	3208b14 <___vfprintf_internal_r+0x5f8>
 32090cc:	d9014f17 	ldw	r4,1340(sp)
 32090d0:	b00b883a 	mov	r5,r22
 32090d4:	d9800c04 	addi	r6,sp,48
 32090d8:	32084c40 	call	32084c4 <__sprint_r>
 32090dc:	103ec026 	beq	r2,zero,3208be0 <___vfprintf_internal_r+0x6c4>
 32090e0:	003ec606 	br	3208bfc <___vfprintf_internal_r+0x6e0>
 32090e4:	d9014f17 	ldw	r4,1340(sp)
 32090e8:	b00b883a 	mov	r5,r22
 32090ec:	d9800c04 	addi	r6,sp,48
 32090f0:	d9c15115 	stw	r7,1348(sp)
 32090f4:	32084c40 	call	32084c4 <__sprint_r>
 32090f8:	d9c15117 	ldw	r7,1348(sp)
 32090fc:	103ebf1e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3209100:	dc800e17 	ldw	r18,56(sp)
 3209104:	dc400d17 	ldw	r17,52(sp)
 3209108:	dd401904 	addi	r21,sp,100
 320910c:	003e7406 	br	3208ae0 <___vfprintf_internal_r+0x5c4>
 3209110:	d9014f17 	ldw	r4,1340(sp)
 3209114:	b00b883a 	mov	r5,r22
 3209118:	d9800c04 	addi	r6,sp,48
 320911c:	d9c15115 	stw	r7,1348(sp)
 3209120:	32084c40 	call	32084c4 <__sprint_r>
 3209124:	d9c15117 	ldw	r7,1348(sp)
 3209128:	103eb41e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 320912c:	dd401904 	addi	r21,sp,100
 3209130:	003d6d06 	br	32086e8 <___vfprintf_internal_r+0x1cc>
 3209134:	d9014f17 	ldw	r4,1340(sp)
 3209138:	b00b883a 	mov	r5,r22
 320913c:	d9800c04 	addi	r6,sp,48
 3209140:	d9c15115 	stw	r7,1348(sp)
 3209144:	32084c40 	call	32084c4 <__sprint_r>
 3209148:	d9c15117 	ldw	r7,1348(sp)
 320914c:	103eab1e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3209150:	dc800e17 	ldw	r18,56(sp)
 3209154:	dc400d17 	ldw	r17,52(sp)
 3209158:	dd401904 	addi	r21,sp,100
 320915c:	003e3406 	br	3208a30 <___vfprintf_internal_r+0x514>
 3209160:	d9014f17 	ldw	r4,1340(sp)
 3209164:	b00b883a 	mov	r5,r22
 3209168:	d9800c04 	addi	r6,sp,48
 320916c:	d9c15115 	stw	r7,1348(sp)
 3209170:	32084c40 	call	32084c4 <__sprint_r>
 3209174:	d9c15117 	ldw	r7,1348(sp)
 3209178:	103ea01e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 320917c:	dc800e17 	ldw	r18,56(sp)
 3209180:	dc400d17 	ldw	r17,52(sp)
 3209184:	dd401904 	addi	r21,sp,100
 3209188:	003e1c06 	br	32089fc <___vfprintf_internal_r+0x4e0>
 320918c:	d9014f17 	ldw	r4,1340(sp)
 3209190:	b00b883a 	mov	r5,r22
 3209194:	d9800c04 	addi	r6,sp,48
 3209198:	d9c15115 	stw	r7,1348(sp)
 320919c:	32084c40 	call	32084c4 <__sprint_r>
 32091a0:	d9c15117 	ldw	r7,1348(sp)
 32091a4:	103e951e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 32091a8:	dc800e17 	ldw	r18,56(sp)
 32091ac:	dc400d17 	ldw	r17,52(sp)
 32091b0:	dd401904 	addi	r21,sp,100
 32091b4:	003e0406 	br	32089c8 <___vfprintf_internal_r+0x4ac>
 32091b8:	d9000517 	ldw	r4,20(sp)
 32091bc:	0102520e 	bge	zero,r4,3209b08 <___vfprintf_internal_r+0x15ec>
 32091c0:	d9814717 	ldw	r6,1308(sp)
 32091c4:	21807a16 	blt	r4,r6,32093b0 <___vfprintf_internal_r+0xe94>
 32091c8:	d8814117 	ldw	r2,1284(sp)
 32091cc:	91a5883a 	add	r18,r18,r6
 32091d0:	8c400044 	addi	r17,r17,1
 32091d4:	a8800015 	stw	r2,0(r21)
 32091d8:	008001c4 	movi	r2,7
 32091dc:	a9800115 	stw	r6,4(r21)
 32091e0:	dc800e15 	stw	r18,56(sp)
 32091e4:	dc400d15 	stw	r17,52(sp)
 32091e8:	1442f616 	blt	r2,r17,3209dc4 <___vfprintf_internal_r+0x18a8>
 32091ec:	a8c00204 	addi	r3,r21,8
 32091f0:	d9414717 	ldw	r5,1308(sp)
 32091f4:	2161c83a 	sub	r16,r4,r5
 32091f8:	043f9d0e 	bge	zero,r16,3209070 <___vfprintf_internal_r+0xb54>
 32091fc:	00800404 	movi	r2,16
 3209200:	1402130e 	bge	r2,r16,3209a50 <___vfprintf_internal_r+0x1534>
 3209204:	dc400d17 	ldw	r17,52(sp)
 3209208:	1027883a 	mov	r19,r2
 320920c:	0700c974 	movhi	fp,805
 3209210:	e738ac84 	addi	fp,fp,-7502
 3209214:	050001c4 	movi	r20,7
 3209218:	00000306 	br	3209228 <___vfprintf_internal_r+0xd0c>
 320921c:	18c00204 	addi	r3,r3,8
 3209220:	843ffc04 	addi	r16,r16,-16
 3209224:	9c020d0e 	bge	r19,r16,3209a5c <___vfprintf_internal_r+0x1540>
 3209228:	94800404 	addi	r18,r18,16
 320922c:	8c400044 	addi	r17,r17,1
 3209230:	1f000015 	stw	fp,0(r3)
 3209234:	1cc00115 	stw	r19,4(r3)
 3209238:	dc800e15 	stw	r18,56(sp)
 320923c:	dc400d15 	stw	r17,52(sp)
 3209240:	a47ff60e 	bge	r20,r17,320921c <___vfprintf_internal_r+0xd00>
 3209244:	d9014f17 	ldw	r4,1340(sp)
 3209248:	b00b883a 	mov	r5,r22
 320924c:	d9800c04 	addi	r6,sp,48
 3209250:	32084c40 	call	32084c4 <__sprint_r>
 3209254:	103e691e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3209258:	dc800e17 	ldw	r18,56(sp)
 320925c:	dc400d17 	ldw	r17,52(sp)
 3209260:	d8c01904 	addi	r3,sp,100
 3209264:	003fee06 	br	3209220 <___vfprintf_internal_r+0xd04>
 3209268:	d8814717 	ldw	r2,1308(sp)
 320926c:	143fffc4 	addi	r16,r2,-1
 3209270:	043e970e 	bge	zero,r16,3208cd0 <___vfprintf_internal_r+0x7b4>
 3209274:	00800404 	movi	r2,16
 3209278:	1400180e 	bge	r2,r16,32092dc <___vfprintf_internal_r+0xdc0>
 320927c:	1029883a 	mov	r20,r2
 3209280:	0700c974 	movhi	fp,805
 3209284:	e738ac84 	addi	fp,fp,-7502
 3209288:	054001c4 	movi	r21,7
 320928c:	00000306 	br	320929c <___vfprintf_internal_r+0xd80>
 3209290:	9cc00204 	addi	r19,r19,8
 3209294:	843ffc04 	addi	r16,r16,-16
 3209298:	a400120e 	bge	r20,r16,32092e4 <___vfprintf_internal_r+0xdc8>
 320929c:	94800404 	addi	r18,r18,16
 32092a0:	8c400044 	addi	r17,r17,1
 32092a4:	9f000015 	stw	fp,0(r19)
 32092a8:	9d000115 	stw	r20,4(r19)
 32092ac:	dc800e15 	stw	r18,56(sp)
 32092b0:	dc400d15 	stw	r17,52(sp)
 32092b4:	ac7ff60e 	bge	r21,r17,3209290 <___vfprintf_internal_r+0xd74>
 32092b8:	d9014f17 	ldw	r4,1340(sp)
 32092bc:	b00b883a 	mov	r5,r22
 32092c0:	d9800c04 	addi	r6,sp,48
 32092c4:	32084c40 	call	32084c4 <__sprint_r>
 32092c8:	103e4c1e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 32092cc:	dc800e17 	ldw	r18,56(sp)
 32092d0:	dc400d17 	ldw	r17,52(sp)
 32092d4:	dcc01904 	addi	r19,sp,100
 32092d8:	003fee06 	br	3209294 <___vfprintf_internal_r+0xd78>
 32092dc:	0700c974 	movhi	fp,805
 32092e0:	e738ac84 	addi	fp,fp,-7502
 32092e4:	9425883a 	add	r18,r18,r16
 32092e8:	8c400044 	addi	r17,r17,1
 32092ec:	008001c4 	movi	r2,7
 32092f0:	9f000015 	stw	fp,0(r19)
 32092f4:	9c000115 	stw	r16,4(r19)
 32092f8:	dc800e15 	stw	r18,56(sp)
 32092fc:	dc400d15 	stw	r17,52(sp)
 3209300:	147e720e 	bge	r2,r17,3208ccc <___vfprintf_internal_r+0x7b0>
 3209304:	d9014f17 	ldw	r4,1340(sp)
 3209308:	b00b883a 	mov	r5,r22
 320930c:	d9800c04 	addi	r6,sp,48
 3209310:	32084c40 	call	32084c4 <__sprint_r>
 3209314:	103e391e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3209318:	dc800e17 	ldw	r18,56(sp)
 320931c:	dc400d17 	ldw	r17,52(sp)
 3209320:	dcc01904 	addi	r19,sp,100
 3209324:	003e6a06 	br	3208cd0 <___vfprintf_internal_r+0x7b4>
 3209328:	d9014f17 	ldw	r4,1340(sp)
 320932c:	b00b883a 	mov	r5,r22
 3209330:	d9800c04 	addi	r6,sp,48
 3209334:	d9c15115 	stw	r7,1348(sp)
 3209338:	32084c40 	call	32084c4 <__sprint_r>
 320933c:	d9c15117 	ldw	r7,1348(sp)
 3209340:	103e2e1e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3209344:	dc800e17 	ldw	r18,56(sp)
 3209348:	dc400d17 	ldw	r17,52(sp)
 320934c:	dd401904 	addi	r21,sp,100
 3209350:	003dba06 	br	3208a3c <___vfprintf_internal_r+0x520>
 3209354:	d9014f17 	ldw	r4,1340(sp)
 3209358:	b00b883a 	mov	r5,r22
 320935c:	d9800c04 	addi	r6,sp,48
 3209360:	32084c40 	call	32084c4 <__sprint_r>
 3209364:	103e251e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3209368:	dc800e17 	ldw	r18,56(sp)
 320936c:	dc400d17 	ldw	r17,52(sp)
 3209370:	dcc01904 	addi	r19,sp,100
 3209374:	003e4206 	br	3208c80 <___vfprintf_internal_r+0x764>
 3209378:	d9014f17 	ldw	r4,1340(sp)
 320937c:	b00b883a 	mov	r5,r22
 3209380:	d9800c04 	addi	r6,sp,48
 3209384:	32084c40 	call	32084c4 <__sprint_r>
 3209388:	103e1c1e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 320938c:	dc800e17 	ldw	r18,56(sp)
 3209390:	dc400d17 	ldw	r17,52(sp)
 3209394:	d8c01904 	addi	r3,sp,100
 3209398:	003e2e06 	br	3208c54 <___vfprintf_internal_r+0x738>
 320939c:	d9414c17 	ldw	r5,1328(sp)
 32093a0:	2880004c 	andi	r2,r5,1
 32093a4:	1005003a 	cmpeq	r2,r2,zero
 32093a8:	103dda1e 	bne	r2,zero,3208b14 <___vfprintf_internal_r+0x5f8>
 32093ac:	003e9f06 	br	3208e2c <___vfprintf_internal_r+0x910>
 32093b0:	d8c14117 	ldw	r3,1284(sp)
 32093b4:	9125883a 	add	r18,r18,r4
 32093b8:	8c400044 	addi	r17,r17,1
 32093bc:	008001c4 	movi	r2,7
 32093c0:	a8c00015 	stw	r3,0(r21)
 32093c4:	a9000115 	stw	r4,4(r21)
 32093c8:	dc800e15 	stw	r18,56(sp)
 32093cc:	dc400d15 	stw	r17,52(sp)
 32093d0:	14426616 	blt	r2,r17,3209d6c <___vfprintf_internal_r+0x1850>
 32093d4:	a8c00204 	addi	r3,r21,8
 32093d8:	d9414917 	ldw	r5,1316(sp)
 32093dc:	00800044 	movi	r2,1
 32093e0:	94800044 	addi	r18,r18,1
 32093e4:	8c400044 	addi	r17,r17,1
 32093e8:	18800115 	stw	r2,4(r3)
 32093ec:	008001c4 	movi	r2,7
 32093f0:	19400015 	stw	r5,0(r3)
 32093f4:	dc800e15 	stw	r18,56(sp)
 32093f8:	dc400d15 	stw	r17,52(sp)
 32093fc:	2021883a 	mov	r16,r4
 3209400:	14425016 	blt	r2,r17,3209d44 <___vfprintf_internal_r+0x1828>
 3209404:	19400204 	addi	r5,r3,8
 3209408:	d9814717 	ldw	r6,1308(sp)
 320940c:	8c400044 	addi	r17,r17,1
 3209410:	dc400d15 	stw	r17,52(sp)
 3209414:	3107c83a 	sub	r3,r6,r4
 3209418:	d9014117 	ldw	r4,1284(sp)
 320941c:	90e5883a 	add	r18,r18,r3
 3209420:	28c00115 	stw	r3,4(r5)
 3209424:	8105883a 	add	r2,r16,r4
 3209428:	28800015 	stw	r2,0(r5)
 320942c:	008001c4 	movi	r2,7
 3209430:	dc800e15 	stw	r18,56(sp)
 3209434:	147f1d16 	blt	r2,r17,32090ac <___vfprintf_internal_r+0xb90>
 3209438:	28c00204 	addi	r3,r5,8
 320943c:	003db506 	br	3208b14 <___vfprintf_internal_r+0x5f8>
 3209440:	3c000017 	ldw	r16,0(r7)
 3209444:	3c400117 	ldw	r17,4(r7)
 3209448:	39800204 	addi	r6,r7,8
 320944c:	01000044 	movi	r4,1
 3209450:	d9814015 	stw	r6,1280(sp)
 3209454:	d8000405 	stb	zero,16(sp)
 3209458:	003ebe06 	br	3208f54 <___vfprintf_internal_r+0xa38>
 320945c:	3c000017 	ldw	r16,0(r7)
 3209460:	3c400117 	ldw	r17,4(r7)
 3209464:	38800204 	addi	r2,r7,8
 3209468:	d8814015 	stw	r2,1280(sp)
 320946c:	003eb706 	br	3208f4c <___vfprintf_internal_r+0xa30>
 3209470:	3c000017 	ldw	r16,0(r7)
 3209474:	3c400117 	ldw	r17,4(r7)
 3209478:	39000204 	addi	r4,r7,8
 320947c:	d9014015 	stw	r4,1280(sp)
 3209480:	0009883a 	mov	r4,zero
 3209484:	d8000405 	stb	zero,16(sp)
 3209488:	003eb206 	br	3208f54 <___vfprintf_internal_r+0xa38>
 320948c:	38c00017 	ldw	r3,0(r7)
 3209490:	39c00104 	addi	r7,r7,4
 3209494:	d8c14a15 	stw	r3,1320(sp)
 3209498:	1800d10e 	bge	r3,zero,32097e0 <___vfprintf_internal_r+0x12c4>
 320949c:	00c7c83a 	sub	r3,zero,r3
 32094a0:	d8c14a15 	stw	r3,1320(sp)
 32094a4:	d9014c17 	ldw	r4,1328(sp)
 32094a8:	b8c00007 	ldb	r3,0(r23)
 32094ac:	21000114 	ori	r4,r4,4
 32094b0:	d9014c15 	stw	r4,1328(sp)
 32094b4:	003c9806 	br	3208718 <___vfprintf_internal_r+0x1fc>
 32094b8:	d9814c17 	ldw	r6,1328(sp)
 32094bc:	3080080c 	andi	r2,r6,32
 32094c0:	1001f026 	beq	r2,zero,3209c84 <___vfprintf_internal_r+0x1768>
 32094c4:	d9014b17 	ldw	r4,1324(sp)
 32094c8:	38800017 	ldw	r2,0(r7)
 32094cc:	39c00104 	addi	r7,r7,4
 32094d0:	d9c14015 	stw	r7,1280(sp)
 32094d4:	2007d7fa 	srai	r3,r4,31
 32094d8:	d9c14017 	ldw	r7,1280(sp)
 32094dc:	11000015 	stw	r4,0(r2)
 32094e0:	10c00115 	stw	r3,4(r2)
 32094e4:	003c6906 	br	320868c <___vfprintf_internal_r+0x170>
 32094e8:	b8c00007 	ldb	r3,0(r23)
 32094ec:	00801b04 	movi	r2,108
 32094f0:	18824f26 	beq	r3,r2,3209e30 <___vfprintf_internal_r+0x1914>
 32094f4:	d9414c17 	ldw	r5,1328(sp)
 32094f8:	29400414 	ori	r5,r5,16
 32094fc:	d9414c15 	stw	r5,1328(sp)
 3209500:	003c8506 	br	3208718 <___vfprintf_internal_r+0x1fc>
 3209504:	d9814c17 	ldw	r6,1328(sp)
 3209508:	b8c00007 	ldb	r3,0(r23)
 320950c:	31800814 	ori	r6,r6,32
 3209510:	d9814c15 	stw	r6,1328(sp)
 3209514:	003c8006 	br	3208718 <___vfprintf_internal_r+0x1fc>
 3209518:	d8814c17 	ldw	r2,1328(sp)
 320951c:	3c000017 	ldw	r16,0(r7)
 3209520:	00c01e04 	movi	r3,120
 3209524:	10800094 	ori	r2,r2,2
 3209528:	d8814c15 	stw	r2,1328(sp)
 320952c:	39c00104 	addi	r7,r7,4
 3209530:	0140c974 	movhi	r5,805
 3209534:	29789504 	addi	r5,r5,-7596
 3209538:	00800c04 	movi	r2,48
 320953c:	0023883a 	mov	r17,zero
 3209540:	01000084 	movi	r4,2
 3209544:	d9c14015 	stw	r7,1280(sp)
 3209548:	d8c14d15 	stw	r3,1332(sp)
 320954c:	d9414415 	stw	r5,1296(sp)
 3209550:	d8800445 	stb	r2,17(sp)
 3209554:	d8c00485 	stb	r3,18(sp)
 3209558:	d8000405 	stb	zero,16(sp)
 320955c:	003e7d06 	br	3208f54 <___vfprintf_internal_r+0xa38>
 3209560:	d8814c17 	ldw	r2,1328(sp)
 3209564:	b8c00007 	ldb	r3,0(r23)
 3209568:	10801014 	ori	r2,r2,64
 320956c:	d8814c15 	stw	r2,1328(sp)
 3209570:	003c6906 	br	3208718 <___vfprintf_internal_r+0x1fc>
 3209574:	d9414c17 	ldw	r5,1328(sp)
 3209578:	2880020c 	andi	r2,r5,8
 320957c:	1001df26 	beq	r2,zero,3209cfc <___vfprintf_internal_r+0x17e0>
 3209580:	39800017 	ldw	r6,0(r7)
 3209584:	38800204 	addi	r2,r7,8
 3209588:	d8814015 	stw	r2,1280(sp)
 320958c:	d9814215 	stw	r6,1288(sp)
 3209590:	39c00117 	ldw	r7,4(r7)
 3209594:	d9c14315 	stw	r7,1292(sp)
 3209598:	d9014217 	ldw	r4,1288(sp)
 320959c:	d9414317 	ldw	r5,1292(sp)
 32095a0:	320ed840 	call	320ed84 <__isinfd>
 32095a4:	10021726 	beq	r2,zero,3209e04 <___vfprintf_internal_r+0x18e8>
 32095a8:	d9014217 	ldw	r4,1288(sp)
 32095ac:	d9414317 	ldw	r5,1292(sp)
 32095b0:	000d883a 	mov	r6,zero
 32095b4:	000f883a 	mov	r7,zero
 32095b8:	3213ae80 	call	3213ae8 <__ltdf2>
 32095bc:	1002ca16 	blt	r2,zero,320a0e8 <___vfprintf_internal_r+0x1bcc>
 32095c0:	d9414d17 	ldw	r5,1332(sp)
 32095c4:	008011c4 	movi	r2,71
 32095c8:	11420a16 	blt	r2,r5,3209df4 <___vfprintf_internal_r+0x18d8>
 32095cc:	0180c974 	movhi	r6,805
 32095d0:	31b89a04 	addi	r6,r6,-7576
 32095d4:	d9814115 	stw	r6,1284(sp)
 32095d8:	d9014c17 	ldw	r4,1328(sp)
 32095dc:	00c000c4 	movi	r3,3
 32095e0:	00bfdfc4 	movi	r2,-129
 32095e4:	2088703a 	and	r4,r4,r2
 32095e8:	180f883a 	mov	r7,r3
 32095ec:	d8c14515 	stw	r3,1300(sp)
 32095f0:	d9014c15 	stw	r4,1328(sp)
 32095f4:	d8014615 	stw	zero,1304(sp)
 32095f8:	003e6a06 	br	3208fa4 <___vfprintf_internal_r+0xa88>
 32095fc:	38800017 	ldw	r2,0(r7)
 3209600:	00c00044 	movi	r3,1
 3209604:	39c00104 	addi	r7,r7,4
 3209608:	d9c14015 	stw	r7,1280(sp)
 320960c:	d9000f04 	addi	r4,sp,60
 3209610:	180f883a 	mov	r7,r3
 3209614:	d8c14515 	stw	r3,1300(sp)
 3209618:	d9014115 	stw	r4,1284(sp)
 320961c:	d8800f05 	stb	r2,60(sp)
 3209620:	d8000405 	stb	zero,16(sp)
 3209624:	003cac06 	br	32088d8 <___vfprintf_internal_r+0x3bc>
 3209628:	0140c974 	movhi	r5,805
 320962c:	2978a004 	addi	r5,r5,-7552
 3209630:	d9414415 	stw	r5,1296(sp)
 3209634:	d9814c17 	ldw	r6,1328(sp)
 3209638:	3080080c 	andi	r2,r6,32
 320963c:	1000f926 	beq	r2,zero,3209a24 <___vfprintf_internal_r+0x1508>
 3209640:	3c000017 	ldw	r16,0(r7)
 3209644:	3c400117 	ldw	r17,4(r7)
 3209648:	38800204 	addi	r2,r7,8
 320964c:	d8814015 	stw	r2,1280(sp)
 3209650:	d9414c17 	ldw	r5,1328(sp)
 3209654:	2880004c 	andi	r2,r5,1
 3209658:	1005003a 	cmpeq	r2,r2,zero
 320965c:	1000b31e 	bne	r2,zero,320992c <___vfprintf_internal_r+0x1410>
 3209660:	8444b03a 	or	r2,r16,r17
 3209664:	1000b126 	beq	r2,zero,320992c <___vfprintf_internal_r+0x1410>
 3209668:	d9814d17 	ldw	r6,1332(sp)
 320966c:	29400094 	ori	r5,r5,2
 3209670:	00800c04 	movi	r2,48
 3209674:	01000084 	movi	r4,2
 3209678:	d9414c15 	stw	r5,1328(sp)
 320967c:	d8800445 	stb	r2,17(sp)
 3209680:	d9800485 	stb	r6,18(sp)
 3209684:	d8000405 	stb	zero,16(sp)
 3209688:	003e3206 	br	3208f54 <___vfprintf_internal_r+0xa38>
 320968c:	0180c974 	movhi	r6,805
 3209690:	31b89504 	addi	r6,r6,-7596
 3209694:	d9814415 	stw	r6,1296(sp)
 3209698:	003fe606 	br	3209634 <___vfprintf_internal_r+0x1118>
 320969c:	00800ac4 	movi	r2,43
 32096a0:	d8800405 	stb	r2,16(sp)
 32096a4:	b8c00007 	ldb	r3,0(r23)
 32096a8:	003c1b06 	br	3208718 <___vfprintf_internal_r+0x1fc>
 32096ac:	d8814c17 	ldw	r2,1328(sp)
 32096b0:	b8c00007 	ldb	r3,0(r23)
 32096b4:	10800054 	ori	r2,r2,1
 32096b8:	d8814c15 	stw	r2,1328(sp)
 32096bc:	003c1606 	br	3208718 <___vfprintf_internal_r+0x1fc>
 32096c0:	d8800407 	ldb	r2,16(sp)
 32096c4:	1000461e 	bne	r2,zero,32097e0 <___vfprintf_internal_r+0x12c4>
 32096c8:	00800804 	movi	r2,32
 32096cc:	d8800405 	stb	r2,16(sp)
 32096d0:	b8c00007 	ldb	r3,0(r23)
 32096d4:	003c1006 	br	3208718 <___vfprintf_internal_r+0x1fc>
 32096d8:	d9814c17 	ldw	r6,1328(sp)
 32096dc:	b8c00007 	ldb	r3,0(r23)
 32096e0:	31800214 	ori	r6,r6,8
 32096e4:	d9814c15 	stw	r6,1328(sp)
 32096e8:	003c0b06 	br	3208718 <___vfprintf_internal_r+0x1fc>
 32096ec:	0007883a 	mov	r3,zero
 32096f0:	01000244 	movi	r4,9
 32096f4:	188002a4 	muli	r2,r3,10
 32096f8:	b8c00007 	ldb	r3,0(r23)
 32096fc:	d9814d17 	ldw	r6,1332(sp)
 3209700:	bdc00044 	addi	r23,r23,1
 3209704:	d8c14d15 	stw	r3,1332(sp)
 3209708:	d9414d17 	ldw	r5,1332(sp)
 320970c:	3085883a 	add	r2,r6,r2
 3209710:	10fff404 	addi	r3,r2,-48
 3209714:	28bff404 	addi	r2,r5,-48
 3209718:	20bff62e 	bgeu	r4,r2,32096f4 <___vfprintf_internal_r+0x11d8>
 320971c:	d8c14a15 	stw	r3,1320(sp)
 3209720:	003bff06 	br	3208720 <___vfprintf_internal_r+0x204>
 3209724:	d9414c17 	ldw	r5,1328(sp)
 3209728:	b8c00007 	ldb	r3,0(r23)
 320972c:	29402014 	ori	r5,r5,128
 3209730:	d9414c15 	stw	r5,1328(sp)
 3209734:	003bf806 	br	3208718 <___vfprintf_internal_r+0x1fc>
 3209738:	b8c00007 	ldb	r3,0(r23)
 320973c:	00800a84 	movi	r2,42
 3209740:	bdc00044 	addi	r23,r23,1
 3209744:	18831526 	beq	r3,r2,320a39c <___vfprintf_internal_r+0x1e80>
 3209748:	d8c14d15 	stw	r3,1332(sp)
 320974c:	18bff404 	addi	r2,r3,-48
 3209750:	00c00244 	movi	r3,9
 3209754:	18827836 	bltu	r3,r2,320a138 <___vfprintf_internal_r+0x1c1c>
 3209758:	000d883a 	mov	r6,zero
 320975c:	308002a4 	muli	r2,r6,10
 3209760:	b9800007 	ldb	r6,0(r23)
 3209764:	d9414d17 	ldw	r5,1332(sp)
 3209768:	bdc00044 	addi	r23,r23,1
 320976c:	d9814d15 	stw	r6,1332(sp)
 3209770:	d9014d17 	ldw	r4,1332(sp)
 3209774:	1145883a 	add	r2,r2,r5
 3209778:	11bff404 	addi	r6,r2,-48
 320977c:	20bff404 	addi	r2,r4,-48
 3209780:	18bff62e 	bgeu	r3,r2,320975c <___vfprintf_internal_r+0x1240>
 3209784:	3027883a 	mov	r19,r6
 3209788:	303be50e 	bge	r6,zero,3208720 <___vfprintf_internal_r+0x204>
 320978c:	04ffffc4 	movi	r19,-1
 3209790:	003be306 	br	3208720 <___vfprintf_internal_r+0x204>
 3209794:	d8000405 	stb	zero,16(sp)
 3209798:	39800017 	ldw	r6,0(r7)
 320979c:	39c00104 	addi	r7,r7,4
 32097a0:	d9c14015 	stw	r7,1280(sp)
 32097a4:	d9814115 	stw	r6,1284(sp)
 32097a8:	3001c926 	beq	r6,zero,3209ed0 <___vfprintf_internal_r+0x19b4>
 32097ac:	98000e16 	blt	r19,zero,32097e8 <___vfprintf_internal_r+0x12cc>
 32097b0:	d9014117 	ldw	r4,1284(sp)
 32097b4:	000b883a 	mov	r5,zero
 32097b8:	980d883a 	mov	r6,r19
 32097bc:	32069ec0 	call	32069ec <memchr>
 32097c0:	10025926 	beq	r2,zero,320a128 <___vfprintf_internal_r+0x1c0c>
 32097c4:	d8c14117 	ldw	r3,1284(sp)
 32097c8:	10cfc83a 	sub	r7,r2,r3
 32097cc:	99c19e16 	blt	r19,r7,3209e48 <___vfprintf_internal_r+0x192c>
 32097d0:	d9c14515 	stw	r7,1300(sp)
 32097d4:	38000916 	blt	r7,zero,32097fc <___vfprintf_internal_r+0x12e0>
 32097d8:	d8014615 	stw	zero,1304(sp)
 32097dc:	003df106 	br	3208fa4 <___vfprintf_internal_r+0xa88>
 32097e0:	b8c00007 	ldb	r3,0(r23)
 32097e4:	003bcc06 	br	3208718 <___vfprintf_internal_r+0x1fc>
 32097e8:	d9014117 	ldw	r4,1284(sp)
 32097ec:	32084480 	call	3208448 <strlen>
 32097f0:	d8814515 	stw	r2,1300(sp)
 32097f4:	100f883a 	mov	r7,r2
 32097f8:	103ff70e 	bge	r2,zero,32097d8 <___vfprintf_internal_r+0x12bc>
 32097fc:	d8014515 	stw	zero,1300(sp)
 3209800:	d8014615 	stw	zero,1304(sp)
 3209804:	003de706 	br	3208fa4 <___vfprintf_internal_r+0xa88>
 3209808:	20c03fcc 	andi	r3,r4,255
 320980c:	00800044 	movi	r2,1
 3209810:	18802d26 	beq	r3,r2,32098c8 <___vfprintf_internal_r+0x13ac>
 3209814:	18800e36 	bltu	r3,r2,3209850 <___vfprintf_internal_r+0x1334>
 3209818:	00800084 	movi	r2,2
 320981c:	1880fa26 	beq	r3,r2,3209c08 <___vfprintf_internal_r+0x16ec>
 3209820:	0100c974 	movhi	r4,805
 3209824:	2138a504 	addi	r4,r4,-7532
 3209828:	32084480 	call	3208448 <strlen>
 320982c:	100f883a 	mov	r7,r2
 3209830:	dcc14515 	stw	r19,1300(sp)
 3209834:	9880010e 	bge	r19,r2,320983c <___vfprintf_internal_r+0x1320>
 3209838:	d8814515 	stw	r2,1300(sp)
 320983c:	0080c974 	movhi	r2,805
 3209840:	10b8a504 	addi	r2,r2,-7532
 3209844:	dcc14615 	stw	r19,1304(sp)
 3209848:	d8814115 	stw	r2,1284(sp)
 320984c:	003dd506 	br	3208fa4 <___vfprintf_internal_r+0xa88>
 3209850:	d9401904 	addi	r5,sp,100
 3209854:	dd000f04 	addi	r20,sp,60
 3209858:	d9414115 	stw	r5,1284(sp)
 320985c:	880a977a 	slli	r5,r17,29
 3209860:	d9814117 	ldw	r6,1284(sp)
 3209864:	8004d0fa 	srli	r2,r16,3
 3209868:	8806d0fa 	srli	r3,r17,3
 320986c:	810001cc 	andi	r4,r16,7
 3209870:	2884b03a 	or	r2,r5,r2
 3209874:	31bfffc4 	addi	r6,r6,-1
 3209878:	21000c04 	addi	r4,r4,48
 320987c:	d9814115 	stw	r6,1284(sp)
 3209880:	10cab03a 	or	r5,r2,r3
 3209884:	31000005 	stb	r4,0(r6)
 3209888:	1021883a 	mov	r16,r2
 320988c:	1823883a 	mov	r17,r3
 3209890:	283ff21e 	bne	r5,zero,320985c <___vfprintf_internal_r+0x1340>
 3209894:	d8c14c17 	ldw	r3,1328(sp)
 3209898:	1880004c 	andi	r2,r3,1
 320989c:	1005003a 	cmpeq	r2,r2,zero
 32098a0:	103db91e 	bne	r2,zero,3208f88 <___vfprintf_internal_r+0xa6c>
 32098a4:	20803fcc 	andi	r2,r4,255
 32098a8:	1080201c 	xori	r2,r2,128
 32098ac:	10bfe004 	addi	r2,r2,-128
 32098b0:	00c00c04 	movi	r3,48
 32098b4:	10fdb426 	beq	r2,r3,3208f88 <___vfprintf_internal_r+0xa6c>
 32098b8:	31bfffc4 	addi	r6,r6,-1
 32098bc:	d9814115 	stw	r6,1284(sp)
 32098c0:	30c00005 	stb	r3,0(r6)
 32098c4:	003db006 	br	3208f88 <___vfprintf_internal_r+0xa6c>
 32098c8:	88800068 	cmpgeui	r2,r17,1
 32098cc:	10002c1e 	bne	r2,zero,3209980 <___vfprintf_internal_r+0x1464>
 32098d0:	8800021e 	bne	r17,zero,32098dc <___vfprintf_internal_r+0x13c0>
 32098d4:	00800244 	movi	r2,9
 32098d8:	14002936 	bltu	r2,r16,3209980 <___vfprintf_internal_r+0x1464>
 32098dc:	d90018c4 	addi	r4,sp,99
 32098e0:	dd000f04 	addi	r20,sp,60
 32098e4:	d9014115 	stw	r4,1284(sp)
 32098e8:	d9014117 	ldw	r4,1284(sp)
 32098ec:	80800c04 	addi	r2,r16,48
 32098f0:	20800005 	stb	r2,0(r4)
 32098f4:	003da406 	br	3208f88 <___vfprintf_internal_r+0xa6c>
 32098f8:	dc400d17 	ldw	r17,52(sp)
 32098fc:	0700c974 	movhi	fp,805
 3209900:	e738ac84 	addi	fp,fp,-7502
 3209904:	9425883a 	add	r18,r18,r16
 3209908:	8c400044 	addi	r17,r17,1
 320990c:	008001c4 	movi	r2,7
 3209910:	1f000015 	stw	fp,0(r3)
 3209914:	1c000115 	stw	r16,4(r3)
 3209918:	dc800e15 	stw	r18,56(sp)
 320991c:	dc400d15 	stw	r17,52(sp)
 3209920:	147de216 	blt	r2,r17,32090ac <___vfprintf_internal_r+0xb90>
 3209924:	18c00204 	addi	r3,r3,8
 3209928:	003c7a06 	br	3208b14 <___vfprintf_internal_r+0x5f8>
 320992c:	01000084 	movi	r4,2
 3209930:	d8000405 	stb	zero,16(sp)
 3209934:	003d8706 	br	3208f54 <___vfprintf_internal_r+0xa38>
 3209938:	d9814c17 	ldw	r6,1328(sp)
 320993c:	30c4703a 	and	r2,r6,r3
 3209940:	1005003a 	cmpeq	r2,r2,zero
 3209944:	103cb926 	beq	r2,zero,3208c2c <___vfprintf_internal_r+0x710>
 3209948:	d9014117 	ldw	r4,1284(sp)
 320994c:	94800044 	addi	r18,r18,1
 3209950:	8c400044 	addi	r17,r17,1
 3209954:	008001c4 	movi	r2,7
 3209958:	a9000015 	stw	r4,0(r21)
 320995c:	a8c00115 	stw	r3,4(r21)
 3209960:	dc800e15 	stw	r18,56(sp)
 3209964:	dc400d15 	stw	r17,52(sp)
 3209968:	147e6616 	blt	r2,r17,3209304 <___vfprintf_internal_r+0xde8>
 320996c:	acc00204 	addi	r19,r21,8
 3209970:	003cd706 	br	3208cd0 <___vfprintf_internal_r+0x7b4>
 3209974:	0700c974 	movhi	fp,805
 3209978:	e738ac84 	addi	fp,fp,-7502
 320997c:	003c4f06 	br	3208abc <___vfprintf_internal_r+0x5a0>
 3209980:	dd000f04 	addi	r20,sp,60
 3209984:	dc801904 	addi	r18,sp,100
 3209988:	8009883a 	mov	r4,r16
 320998c:	880b883a 	mov	r5,r17
 3209990:	01800284 	movi	r6,10
 3209994:	000f883a 	mov	r7,zero
 3209998:	32126900 	call	3212690 <__umoddi3>
 320999c:	12000c04 	addi	r8,r2,48
 32099a0:	94bfffc4 	addi	r18,r18,-1
 32099a4:	8009883a 	mov	r4,r16
 32099a8:	880b883a 	mov	r5,r17
 32099ac:	01800284 	movi	r6,10
 32099b0:	000f883a 	mov	r7,zero
 32099b4:	92000005 	stb	r8,0(r18)
 32099b8:	32120b40 	call	32120b4 <__udivdi3>
 32099bc:	1009883a 	mov	r4,r2
 32099c0:	1021883a 	mov	r16,r2
 32099c4:	18800068 	cmpgeui	r2,r3,1
 32099c8:	1823883a 	mov	r17,r3
 32099cc:	103fee1e 	bne	r2,zero,3209988 <___vfprintf_internal_r+0x146c>
 32099d0:	1800021e 	bne	r3,zero,32099dc <___vfprintf_internal_r+0x14c0>
 32099d4:	00800244 	movi	r2,9
 32099d8:	113feb36 	bltu	r2,r4,3209988 <___vfprintf_internal_r+0x146c>
 32099dc:	94bfffc4 	addi	r18,r18,-1
 32099e0:	dc814115 	stw	r18,1284(sp)
 32099e4:	003fc006 	br	32098e8 <___vfprintf_internal_r+0x13cc>
 32099e8:	d9014c17 	ldw	r4,1328(sp)
 32099ec:	2080004c 	andi	r2,r4,1
 32099f0:	10009a1e 	bne	r2,zero,3209c5c <___vfprintf_internal_r+0x1740>
 32099f4:	d9401904 	addi	r5,sp,100
 32099f8:	dd000f04 	addi	r20,sp,60
 32099fc:	d9414115 	stw	r5,1284(sp)
 3209a00:	003d6106 	br	3208f88 <___vfprintf_internal_r+0xa6c>
 3209a04:	d9014f17 	ldw	r4,1340(sp)
 3209a08:	b00b883a 	mov	r5,r22
 3209a0c:	d9800c04 	addi	r6,sp,48
 3209a10:	32084c40 	call	32084c4 <__sprint_r>
 3209a14:	103c791e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3209a18:	dc800e17 	ldw	r18,56(sp)
 3209a1c:	d8c01904 	addi	r3,sp,100
 3209a20:	003cff06 	br	3208e20 <___vfprintf_internal_r+0x904>
 3209a24:	d8c14c17 	ldw	r3,1328(sp)
 3209a28:	1880040c 	andi	r2,r3,16
 3209a2c:	1000711e 	bne	r2,zero,3209bf4 <___vfprintf_internal_r+0x16d8>
 3209a30:	d9014c17 	ldw	r4,1328(sp)
 3209a34:	2080100c 	andi	r2,r4,64
 3209a38:	10006e26 	beq	r2,zero,3209bf4 <___vfprintf_internal_r+0x16d8>
 3209a3c:	3c00000b 	ldhu	r16,0(r7)
 3209a40:	0023883a 	mov	r17,zero
 3209a44:	39c00104 	addi	r7,r7,4
 3209a48:	d9c14015 	stw	r7,1280(sp)
 3209a4c:	003f0006 	br	3209650 <___vfprintf_internal_r+0x1134>
 3209a50:	dc400d17 	ldw	r17,52(sp)
 3209a54:	0700c974 	movhi	fp,805
 3209a58:	e738ac84 	addi	fp,fp,-7502
 3209a5c:	9425883a 	add	r18,r18,r16
 3209a60:	8c400044 	addi	r17,r17,1
 3209a64:	008001c4 	movi	r2,7
 3209a68:	1f000015 	stw	fp,0(r3)
 3209a6c:	1c000115 	stw	r16,4(r3)
 3209a70:	dc800e15 	stw	r18,56(sp)
 3209a74:	dc400d15 	stw	r17,52(sp)
 3209a78:	147d7616 	blt	r2,r17,3209054 <___vfprintf_internal_r+0xb38>
 3209a7c:	18c00204 	addi	r3,r3,8
 3209a80:	003d7b06 	br	3209070 <___vfprintf_internal_r+0xb54>
 3209a84:	dc800e17 	ldw	r18,56(sp)
 3209a88:	dc400d17 	ldw	r17,52(sp)
 3209a8c:	0700c974 	movhi	fp,805
 3209a90:	e738b084 	addi	fp,fp,-7486
 3209a94:	003bc006 	br	3208998 <___vfprintf_internal_r+0x47c>
 3209a98:	d9014f17 	ldw	r4,1340(sp)
 3209a9c:	b00b883a 	mov	r5,r22
 3209aa0:	d9800c04 	addi	r6,sp,48
 3209aa4:	32084c40 	call	32084c4 <__sprint_r>
 3209aa8:	103c541e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3209aac:	dc800e17 	ldw	r18,56(sp)
 3209ab0:	d8c01904 	addi	r3,sp,100
 3209ab4:	003ce906 	br	3208e5c <___vfprintf_internal_r+0x940>
 3209ab8:	3c000017 	ldw	r16,0(r7)
 3209abc:	0009883a 	mov	r4,zero
 3209ac0:	39c00104 	addi	r7,r7,4
 3209ac4:	0023883a 	mov	r17,zero
 3209ac8:	d9c14015 	stw	r7,1280(sp)
 3209acc:	d8000405 	stb	zero,16(sp)
 3209ad0:	003d2006 	br	3208f54 <___vfprintf_internal_r+0xa38>
 3209ad4:	38800017 	ldw	r2,0(r7)
 3209ad8:	39c00104 	addi	r7,r7,4
 3209adc:	d9c14015 	stw	r7,1280(sp)
 3209ae0:	1023d7fa 	srai	r17,r2,31
 3209ae4:	1021883a 	mov	r16,r2
 3209ae8:	003d1806 	br	3208f4c <___vfprintf_internal_r+0xa30>
 3209aec:	3c000017 	ldw	r16,0(r7)
 3209af0:	01000044 	movi	r4,1
 3209af4:	39c00104 	addi	r7,r7,4
 3209af8:	0023883a 	mov	r17,zero
 3209afc:	d9c14015 	stw	r7,1280(sp)
 3209b00:	d8000405 	stb	zero,16(sp)
 3209b04:	003d1306 	br	3208f54 <___vfprintf_internal_r+0xa38>
 3209b08:	0080c974 	movhi	r2,805
 3209b0c:	10b8ac04 	addi	r2,r2,-7504
 3209b10:	94800044 	addi	r18,r18,1
 3209b14:	8c400044 	addi	r17,r17,1
 3209b18:	a8800015 	stw	r2,0(r21)
 3209b1c:	00c00044 	movi	r3,1
 3209b20:	008001c4 	movi	r2,7
 3209b24:	a8c00115 	stw	r3,4(r21)
 3209b28:	dc800e15 	stw	r18,56(sp)
 3209b2c:	dc400d15 	stw	r17,52(sp)
 3209b30:	1440ca16 	blt	r2,r17,3209e5c <___vfprintf_internal_r+0x1940>
 3209b34:	a8c00204 	addi	r3,r21,8
 3209b38:	2000061e 	bne	r4,zero,3209b54 <___vfprintf_internal_r+0x1638>
 3209b3c:	d9414717 	ldw	r5,1308(sp)
 3209b40:	2800041e 	bne	r5,zero,3209b54 <___vfprintf_internal_r+0x1638>
 3209b44:	d9814c17 	ldw	r6,1328(sp)
 3209b48:	3080004c 	andi	r2,r6,1
 3209b4c:	1005003a 	cmpeq	r2,r2,zero
 3209b50:	103bf01e 	bne	r2,zero,3208b14 <___vfprintf_internal_r+0x5f8>
 3209b54:	00800044 	movi	r2,1
 3209b58:	dc400d17 	ldw	r17,52(sp)
 3209b5c:	18800115 	stw	r2,4(r3)
 3209b60:	d8814917 	ldw	r2,1316(sp)
 3209b64:	94800044 	addi	r18,r18,1
 3209b68:	8c400044 	addi	r17,r17,1
 3209b6c:	18800015 	stw	r2,0(r3)
 3209b70:	008001c4 	movi	r2,7
 3209b74:	dc800e15 	stw	r18,56(sp)
 3209b78:	dc400d15 	stw	r17,52(sp)
 3209b7c:	1440ca16 	blt	r2,r17,3209ea8 <___vfprintf_internal_r+0x198c>
 3209b80:	18c00204 	addi	r3,r3,8
 3209b84:	0121c83a 	sub	r16,zero,r4
 3209b88:	0400500e 	bge	zero,r16,3209ccc <___vfprintf_internal_r+0x17b0>
 3209b8c:	00800404 	movi	r2,16
 3209b90:	1400800e 	bge	r2,r16,3209d94 <___vfprintf_internal_r+0x1878>
 3209b94:	1027883a 	mov	r19,r2
 3209b98:	0700c974 	movhi	fp,805
 3209b9c:	e738ac84 	addi	fp,fp,-7502
 3209ba0:	050001c4 	movi	r20,7
 3209ba4:	00000306 	br	3209bb4 <___vfprintf_internal_r+0x1698>
 3209ba8:	18c00204 	addi	r3,r3,8
 3209bac:	843ffc04 	addi	r16,r16,-16
 3209bb0:	9c007a0e 	bge	r19,r16,3209d9c <___vfprintf_internal_r+0x1880>
 3209bb4:	94800404 	addi	r18,r18,16
 3209bb8:	8c400044 	addi	r17,r17,1
 3209bbc:	1f000015 	stw	fp,0(r3)
 3209bc0:	1cc00115 	stw	r19,4(r3)
 3209bc4:	dc800e15 	stw	r18,56(sp)
 3209bc8:	dc400d15 	stw	r17,52(sp)
 3209bcc:	a47ff60e 	bge	r20,r17,3209ba8 <___vfprintf_internal_r+0x168c>
 3209bd0:	d9014f17 	ldw	r4,1340(sp)
 3209bd4:	b00b883a 	mov	r5,r22
 3209bd8:	d9800c04 	addi	r6,sp,48
 3209bdc:	32084c40 	call	32084c4 <__sprint_r>
 3209be0:	103c061e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3209be4:	dc800e17 	ldw	r18,56(sp)
 3209be8:	dc400d17 	ldw	r17,52(sp)
 3209bec:	d8c01904 	addi	r3,sp,100
 3209bf0:	003fee06 	br	3209bac <___vfprintf_internal_r+0x1690>
 3209bf4:	3c000017 	ldw	r16,0(r7)
 3209bf8:	0023883a 	mov	r17,zero
 3209bfc:	39c00104 	addi	r7,r7,4
 3209c00:	d9c14015 	stw	r7,1280(sp)
 3209c04:	003e9206 	br	3209650 <___vfprintf_internal_r+0x1134>
 3209c08:	d9401904 	addi	r5,sp,100
 3209c0c:	dd000f04 	addi	r20,sp,60
 3209c10:	d9414115 	stw	r5,1284(sp)
 3209c14:	d9814417 	ldw	r6,1296(sp)
 3209c18:	880a973a 	slli	r5,r17,28
 3209c1c:	8004d13a 	srli	r2,r16,4
 3209c20:	810003cc 	andi	r4,r16,15
 3209c24:	3109883a 	add	r4,r6,r4
 3209c28:	2884b03a 	or	r2,r5,r2
 3209c2c:	21400003 	ldbu	r5,0(r4)
 3209c30:	d9014117 	ldw	r4,1284(sp)
 3209c34:	8806d13a 	srli	r3,r17,4
 3209c38:	1021883a 	mov	r16,r2
 3209c3c:	213fffc4 	addi	r4,r4,-1
 3209c40:	d9014115 	stw	r4,1284(sp)
 3209c44:	d9814117 	ldw	r6,1284(sp)
 3209c48:	10c8b03a 	or	r4,r2,r3
 3209c4c:	1823883a 	mov	r17,r3
 3209c50:	31400005 	stb	r5,0(r6)
 3209c54:	203fef1e 	bne	r4,zero,3209c14 <___vfprintf_internal_r+0x16f8>
 3209c58:	003ccb06 	br	3208f88 <___vfprintf_internal_r+0xa6c>
 3209c5c:	00800c04 	movi	r2,48
 3209c60:	d98018c4 	addi	r6,sp,99
 3209c64:	dd000f04 	addi	r20,sp,60
 3209c68:	d88018c5 	stb	r2,99(sp)
 3209c6c:	d9814115 	stw	r6,1284(sp)
 3209c70:	003cc506 	br	3208f88 <___vfprintf_internal_r+0xa6c>
 3209c74:	dc400d17 	ldw	r17,52(sp)
 3209c78:	0700c974 	movhi	fp,805
 3209c7c:	e738b084 	addi	fp,fp,-7486
 3209c80:	003bc706 	br	3208ba0 <___vfprintf_internal_r+0x684>
 3209c84:	d9414c17 	ldw	r5,1328(sp)
 3209c88:	2880040c 	andi	r2,r5,16
 3209c8c:	10007c26 	beq	r2,zero,3209e80 <___vfprintf_internal_r+0x1964>
 3209c90:	38800017 	ldw	r2,0(r7)
 3209c94:	39c00104 	addi	r7,r7,4
 3209c98:	d9c14015 	stw	r7,1280(sp)
 3209c9c:	d9814b17 	ldw	r6,1324(sp)
 3209ca0:	d9c14017 	ldw	r7,1280(sp)
 3209ca4:	11800015 	stw	r6,0(r2)
 3209ca8:	003a7806 	br	320868c <___vfprintf_internal_r+0x170>
 3209cac:	d9014f17 	ldw	r4,1340(sp)
 3209cb0:	b00b883a 	mov	r5,r22
 3209cb4:	d9800c04 	addi	r6,sp,48
 3209cb8:	32084c40 	call	32084c4 <__sprint_r>
 3209cbc:	103bcf1e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3209cc0:	dc800e17 	ldw	r18,56(sp)
 3209cc4:	dc400d17 	ldw	r17,52(sp)
 3209cc8:	d8c01904 	addi	r3,sp,100
 3209ccc:	d9014717 	ldw	r4,1308(sp)
 3209cd0:	d9414117 	ldw	r5,1284(sp)
 3209cd4:	8c400044 	addi	r17,r17,1
 3209cd8:	9125883a 	add	r18,r18,r4
 3209cdc:	008001c4 	movi	r2,7
 3209ce0:	19400015 	stw	r5,0(r3)
 3209ce4:	19000115 	stw	r4,4(r3)
 3209ce8:	dc800e15 	stw	r18,56(sp)
 3209cec:	dc400d15 	stw	r17,52(sp)
 3209cf0:	147cee16 	blt	r2,r17,32090ac <___vfprintf_internal_r+0xb90>
 3209cf4:	18c00204 	addi	r3,r3,8
 3209cf8:	003b8606 	br	3208b14 <___vfprintf_internal_r+0x5f8>
 3209cfc:	38c00017 	ldw	r3,0(r7)
 3209d00:	39000204 	addi	r4,r7,8
 3209d04:	d9014015 	stw	r4,1280(sp)
 3209d08:	d8c14215 	stw	r3,1288(sp)
 3209d0c:	39c00117 	ldw	r7,4(r7)
 3209d10:	d9c14315 	stw	r7,1292(sp)
 3209d14:	003e2006 	br	3209598 <___vfprintf_internal_r+0x107c>
 3209d18:	0005883a 	mov	r2,zero
 3209d1c:	1409c83a 	sub	r4,r2,r16
 3209d20:	1105803a 	cmpltu	r2,r2,r4
 3209d24:	044bc83a 	sub	r5,zero,r17
 3209d28:	2885c83a 	sub	r2,r5,r2
 3209d2c:	2021883a 	mov	r16,r4
 3209d30:	1023883a 	mov	r17,r2
 3209d34:	01000044 	movi	r4,1
 3209d38:	00800b44 	movi	r2,45
 3209d3c:	d8800405 	stb	r2,16(sp)
 3209d40:	003c8406 	br	3208f54 <___vfprintf_internal_r+0xa38>
 3209d44:	d9014f17 	ldw	r4,1340(sp)
 3209d48:	b00b883a 	mov	r5,r22
 3209d4c:	d9800c04 	addi	r6,sp,48
 3209d50:	32084c40 	call	32084c4 <__sprint_r>
 3209d54:	103ba91e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3209d58:	dc800e17 	ldw	r18,56(sp)
 3209d5c:	dc400d17 	ldw	r17,52(sp)
 3209d60:	d9000517 	ldw	r4,20(sp)
 3209d64:	d9401904 	addi	r5,sp,100
 3209d68:	003da706 	br	3209408 <___vfprintf_internal_r+0xeec>
 3209d6c:	d9014f17 	ldw	r4,1340(sp)
 3209d70:	b00b883a 	mov	r5,r22
 3209d74:	d9800c04 	addi	r6,sp,48
 3209d78:	32084c40 	call	32084c4 <__sprint_r>
 3209d7c:	103b9f1e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3209d80:	dc800e17 	ldw	r18,56(sp)
 3209d84:	dc400d17 	ldw	r17,52(sp)
 3209d88:	d9000517 	ldw	r4,20(sp)
 3209d8c:	d8c01904 	addi	r3,sp,100
 3209d90:	003d9106 	br	32093d8 <___vfprintf_internal_r+0xebc>
 3209d94:	0700c974 	movhi	fp,805
 3209d98:	e738ac84 	addi	fp,fp,-7502
 3209d9c:	9425883a 	add	r18,r18,r16
 3209da0:	8c400044 	addi	r17,r17,1
 3209da4:	008001c4 	movi	r2,7
 3209da8:	1f000015 	stw	fp,0(r3)
 3209dac:	1c000115 	stw	r16,4(r3)
 3209db0:	dc800e15 	stw	r18,56(sp)
 3209db4:	dc400d15 	stw	r17,52(sp)
 3209db8:	147fbc16 	blt	r2,r17,3209cac <___vfprintf_internal_r+0x1790>
 3209dbc:	18c00204 	addi	r3,r3,8
 3209dc0:	003fc206 	br	3209ccc <___vfprintf_internal_r+0x17b0>
 3209dc4:	d9014f17 	ldw	r4,1340(sp)
 3209dc8:	b00b883a 	mov	r5,r22
 3209dcc:	d9800c04 	addi	r6,sp,48
 3209dd0:	32084c40 	call	32084c4 <__sprint_r>
 3209dd4:	103b891e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3209dd8:	dc800e17 	ldw	r18,56(sp)
 3209ddc:	d9000517 	ldw	r4,20(sp)
 3209de0:	d8c01904 	addi	r3,sp,100
 3209de4:	003d0206 	br	32091f0 <___vfprintf_internal_r+0xcd4>
 3209de8:	0700c974 	movhi	fp,805
 3209dec:	e738ac84 	addi	fp,fp,-7502
 3209df0:	003be406 	br	3208d84 <___vfprintf_internal_r+0x868>
 3209df4:	0080c974 	movhi	r2,805
 3209df8:	10b89b04 	addi	r2,r2,-7572
 3209dfc:	d8814115 	stw	r2,1284(sp)
 3209e00:	003df506 	br	32095d8 <___vfprintf_internal_r+0x10bc>
 3209e04:	d9014217 	ldw	r4,1288(sp)
 3209e08:	d9414317 	ldw	r5,1292(sp)
 3209e0c:	320edc40 	call	320edc4 <__isnand>
 3209e10:	10003926 	beq	r2,zero,3209ef8 <___vfprintf_internal_r+0x19dc>
 3209e14:	d9414d17 	ldw	r5,1332(sp)
 3209e18:	008011c4 	movi	r2,71
 3209e1c:	1140ce16 	blt	r2,r5,320a158 <___vfprintf_internal_r+0x1c3c>
 3209e20:	0180c974 	movhi	r6,805
 3209e24:	31b89c04 	addi	r6,r6,-7568
 3209e28:	d9814115 	stw	r6,1284(sp)
 3209e2c:	003dea06 	br	32095d8 <___vfprintf_internal_r+0x10bc>
 3209e30:	d9014c17 	ldw	r4,1328(sp)
 3209e34:	bdc00044 	addi	r23,r23,1
 3209e38:	b8c00007 	ldb	r3,0(r23)
 3209e3c:	21000814 	ori	r4,r4,32
 3209e40:	d9014c15 	stw	r4,1328(sp)
 3209e44:	003a3406 	br	3208718 <___vfprintf_internal_r+0x1fc>
 3209e48:	dcc14515 	stw	r19,1300(sp)
 3209e4c:	98011016 	blt	r19,zero,320a290 <___vfprintf_internal_r+0x1d74>
 3209e50:	980f883a 	mov	r7,r19
 3209e54:	d8014615 	stw	zero,1304(sp)
 3209e58:	003c5206 	br	3208fa4 <___vfprintf_internal_r+0xa88>
 3209e5c:	d9014f17 	ldw	r4,1340(sp)
 3209e60:	b00b883a 	mov	r5,r22
 3209e64:	d9800c04 	addi	r6,sp,48
 3209e68:	32084c40 	call	32084c4 <__sprint_r>
 3209e6c:	103b631e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3209e70:	dc800e17 	ldw	r18,56(sp)
 3209e74:	d9000517 	ldw	r4,20(sp)
 3209e78:	d8c01904 	addi	r3,sp,100
 3209e7c:	003f2e06 	br	3209b38 <___vfprintf_internal_r+0x161c>
 3209e80:	d8c14c17 	ldw	r3,1328(sp)
 3209e84:	1880100c 	andi	r2,r3,64
 3209e88:	1000a026 	beq	r2,zero,320a10c <___vfprintf_internal_r+0x1bf0>
 3209e8c:	38800017 	ldw	r2,0(r7)
 3209e90:	39c00104 	addi	r7,r7,4
 3209e94:	d9c14015 	stw	r7,1280(sp)
 3209e98:	d9014b17 	ldw	r4,1324(sp)
 3209e9c:	d9c14017 	ldw	r7,1280(sp)
 3209ea0:	1100000d 	sth	r4,0(r2)
 3209ea4:	0039f906 	br	320868c <___vfprintf_internal_r+0x170>
 3209ea8:	d9014f17 	ldw	r4,1340(sp)
 3209eac:	b00b883a 	mov	r5,r22
 3209eb0:	d9800c04 	addi	r6,sp,48
 3209eb4:	32084c40 	call	32084c4 <__sprint_r>
 3209eb8:	103b501e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 3209ebc:	dc800e17 	ldw	r18,56(sp)
 3209ec0:	dc400d17 	ldw	r17,52(sp)
 3209ec4:	d9000517 	ldw	r4,20(sp)
 3209ec8:	d8c01904 	addi	r3,sp,100
 3209ecc:	003f2d06 	br	3209b84 <___vfprintf_internal_r+0x1668>
 3209ed0:	00800184 	movi	r2,6
 3209ed4:	14c09a36 	bltu	r2,r19,320a140 <___vfprintf_internal_r+0x1c24>
 3209ed8:	dcc14515 	stw	r19,1300(sp)
 3209edc:	9800010e 	bge	r19,zero,3209ee4 <___vfprintf_internal_r+0x19c8>
 3209ee0:	d8014515 	stw	zero,1300(sp)
 3209ee4:	0080c974 	movhi	r2,805
 3209ee8:	10b89e04 	addi	r2,r2,-7560
 3209eec:	980f883a 	mov	r7,r19
 3209ef0:	d8814115 	stw	r2,1284(sp)
 3209ef4:	003a7806 	br	32088d8 <___vfprintf_internal_r+0x3bc>
 3209ef8:	00bfffc4 	movi	r2,-1
 3209efc:	9880e226 	beq	r19,r2,320a288 <___vfprintf_internal_r+0x1d6c>
 3209f00:	d9414d17 	ldw	r5,1332(sp)
 3209f04:	008019c4 	movi	r2,103
 3209f08:	2880dc26 	beq	r5,r2,320a27c <___vfprintf_internal_r+0x1d60>
 3209f0c:	008011c4 	movi	r2,71
 3209f10:	2880da26 	beq	r5,r2,320a27c <___vfprintf_internal_r+0x1d60>
 3209f14:	d9414c17 	ldw	r5,1328(sp)
 3209f18:	d9014317 	ldw	r4,1292(sp)
 3209f1c:	d9814217 	ldw	r6,1288(sp)
 3209f20:	29404014 	ori	r5,r5,256
 3209f24:	d9414c15 	stw	r5,1328(sp)
 3209f28:	2000cc16 	blt	r4,zero,320a25c <___vfprintf_internal_r+0x1d40>
 3209f2c:	3021883a 	mov	r16,r6
 3209f30:	2023883a 	mov	r17,r4
 3209f34:	0039883a 	mov	fp,zero
 3209f38:	d9414d17 	ldw	r5,1332(sp)
 3209f3c:	00801984 	movi	r2,102
 3209f40:	2880b726 	beq	r5,r2,320a220 <___vfprintf_internal_r+0x1d04>
 3209f44:	00801184 	movi	r2,70
 3209f48:	2880b526 	beq	r5,r2,320a220 <___vfprintf_internal_r+0x1d04>
 3209f4c:	00801944 	movi	r2,101
 3209f50:	2880c826 	beq	r5,r2,320a274 <___vfprintf_internal_r+0x1d58>
 3209f54:	00801144 	movi	r2,69
 3209f58:	2880c626 	beq	r5,r2,320a274 <___vfprintf_internal_r+0x1d58>
 3209f5c:	9829883a 	mov	r20,r19
 3209f60:	d9014f17 	ldw	r4,1340(sp)
 3209f64:	d8800504 	addi	r2,sp,20
 3209f68:	880d883a 	mov	r6,r17
 3209f6c:	d8800115 	stw	r2,4(sp)
 3209f70:	d8c00604 	addi	r3,sp,24
 3209f74:	d8800704 	addi	r2,sp,28
 3209f78:	800b883a 	mov	r5,r16
 3209f7c:	01c00084 	movi	r7,2
 3209f80:	d8c00215 	stw	r3,8(sp)
 3209f84:	d8800315 	stw	r2,12(sp)
 3209f88:	dd000015 	stw	r20,0(sp)
 3209f8c:	320c0f40 	call	320c0f4 <_dtoa_r>
 3209f90:	d9814d17 	ldw	r6,1332(sp)
 3209f94:	d8814115 	stw	r2,1284(sp)
 3209f98:	008019c4 	movi	r2,103
 3209f9c:	30809526 	beq	r6,r2,320a1f4 <___vfprintf_internal_r+0x1cd8>
 3209fa0:	d8c14d17 	ldw	r3,1332(sp)
 3209fa4:	008011c4 	movi	r2,71
 3209fa8:	18809226 	beq	r3,r2,320a1f4 <___vfprintf_internal_r+0x1cd8>
 3209fac:	d9414117 	ldw	r5,1284(sp)
 3209fb0:	d9814d17 	ldw	r6,1332(sp)
 3209fb4:	00801984 	movi	r2,102
 3209fb8:	2d25883a 	add	r18,r5,r20
 3209fbc:	30808626 	beq	r6,r2,320a1d8 <___vfprintf_internal_r+0x1cbc>
 3209fc0:	00801184 	movi	r2,70
 3209fc4:	30808426 	beq	r6,r2,320a1d8 <___vfprintf_internal_r+0x1cbc>
 3209fc8:	000d883a 	mov	r6,zero
 3209fcc:	000f883a 	mov	r7,zero
 3209fd0:	880b883a 	mov	r5,r17
 3209fd4:	8009883a 	mov	r4,r16
 3209fd8:	32138c80 	call	32138c8 <__eqdf2>
 3209fdc:	1000751e 	bne	r2,zero,320a1b4 <___vfprintf_internal_r+0x1c98>
 3209fe0:	9005883a 	mov	r2,r18
 3209fe4:	dc800715 	stw	r18,28(sp)
 3209fe8:	d9014117 	ldw	r4,1284(sp)
 3209fec:	d9414d17 	ldw	r5,1332(sp)
 3209ff0:	00c019c4 	movi	r3,103
 3209ff4:	1125c83a 	sub	r18,r2,r4
 3209ff8:	28c06826 	beq	r5,r3,320a19c <___vfprintf_internal_r+0x1c80>
 3209ffc:	008011c4 	movi	r2,71
 320a000:	28806626 	beq	r5,r2,320a19c <___vfprintf_internal_r+0x1c80>
 320a004:	d9000517 	ldw	r4,20(sp)
 320a008:	d8c14d17 	ldw	r3,1332(sp)
 320a00c:	00801944 	movi	r2,101
 320a010:	10c05516 	blt	r2,r3,320a168 <___vfprintf_internal_r+0x1c4c>
 320a014:	213fffc4 	addi	r4,r4,-1
 320a018:	d9000515 	stw	r4,20(sp)
 320a01c:	d8c00805 	stb	r3,32(sp)
 320a020:	2021883a 	mov	r16,r4
 320a024:	2000c116 	blt	r4,zero,320a32c <___vfprintf_internal_r+0x1e10>
 320a028:	00800ac4 	movi	r2,43
 320a02c:	d8800845 	stb	r2,33(sp)
 320a030:	00800244 	movi	r2,9
 320a034:	1400af0e 	bge	r2,r16,320a2f4 <___vfprintf_internal_r+0x1dd8>
 320a038:	1027883a 	mov	r19,r2
 320a03c:	dc400b84 	addi	r17,sp,46
 320a040:	8009883a 	mov	r4,r16
 320a044:	01400284 	movi	r5,10
 320a048:	32047600 	call	3204760 <__modsi3>
 320a04c:	10800c04 	addi	r2,r2,48
 320a050:	8c7fffc4 	addi	r17,r17,-1
 320a054:	8009883a 	mov	r4,r16
 320a058:	01400284 	movi	r5,10
 320a05c:	88800005 	stb	r2,0(r17)
 320a060:	32047000 	call	3204700 <__divsi3>
 320a064:	1021883a 	mov	r16,r2
 320a068:	98bff516 	blt	r19,r2,320a040 <___vfprintf_internal_r+0x1b24>
 320a06c:	10c00c04 	addi	r3,r2,48
 320a070:	d88009c4 	addi	r2,sp,39
 320a074:	108001c4 	addi	r2,r2,7
 320a078:	897fffc4 	addi	r5,r17,-1
 320a07c:	88ffffc5 	stb	r3,-1(r17)
 320a080:	2880a72e 	bgeu	r5,r2,320a320 <___vfprintf_internal_r+0x1e04>
 320a084:	1009883a 	mov	r4,r2
 320a088:	d9800804 	addi	r6,sp,32
 320a08c:	d8c00884 	addi	r3,sp,34
 320a090:	28800003 	ldbu	r2,0(r5)
 320a094:	29400044 	addi	r5,r5,1
 320a098:	18800005 	stb	r2,0(r3)
 320a09c:	18c00044 	addi	r3,r3,1
 320a0a0:	293ffb36 	bltu	r5,r4,320a090 <___vfprintf_internal_r+0x1b74>
 320a0a4:	1987c83a 	sub	r3,r3,r6
 320a0a8:	00800044 	movi	r2,1
 320a0ac:	d8c14815 	stw	r3,1312(sp)
 320a0b0:	90cf883a 	add	r7,r18,r3
 320a0b4:	1480960e 	bge	r2,r18,320a310 <___vfprintf_internal_r+0x1df4>
 320a0b8:	39c00044 	addi	r7,r7,1
 320a0bc:	d9c14515 	stw	r7,1300(sp)
 320a0c0:	38003416 	blt	r7,zero,320a194 <___vfprintf_internal_r+0x1c78>
 320a0c4:	e0803fcc 	andi	r2,fp,255
 320a0c8:	1080201c 	xori	r2,r2,128
 320a0cc:	10bfe004 	addi	r2,r2,-128
 320a0d0:	10004e26 	beq	r2,zero,320a20c <___vfprintf_internal_r+0x1cf0>
 320a0d4:	00800b44 	movi	r2,45
 320a0d8:	dc814715 	stw	r18,1308(sp)
 320a0dc:	d8014615 	stw	zero,1304(sp)
 320a0e0:	d8800405 	stb	r2,16(sp)
 320a0e4:	003bb106 	br	3208fac <___vfprintf_internal_r+0xa90>
 320a0e8:	00800b44 	movi	r2,45
 320a0ec:	d8800405 	stb	r2,16(sp)
 320a0f0:	003d3306 	br	32095c0 <___vfprintf_internal_r+0x10a4>
 320a0f4:	d9014f17 	ldw	r4,1340(sp)
 320a0f8:	b00b883a 	mov	r5,r22
 320a0fc:	d9800c04 	addi	r6,sp,48
 320a100:	32084c40 	call	32084c4 <__sprint_r>
 320a104:	103abd1e 	bne	r2,zero,3208bfc <___vfprintf_internal_r+0x6e0>
 320a108:	003abb06 	br	3208bf8 <___vfprintf_internal_r+0x6dc>
 320a10c:	38800017 	ldw	r2,0(r7)
 320a110:	39c00104 	addi	r7,r7,4
 320a114:	d9c14015 	stw	r7,1280(sp)
 320a118:	d9414b17 	ldw	r5,1324(sp)
 320a11c:	d9c14017 	ldw	r7,1280(sp)
 320a120:	11400015 	stw	r5,0(r2)
 320a124:	00395906 	br	320868c <___vfprintf_internal_r+0x170>
 320a128:	980f883a 	mov	r7,r19
 320a12c:	dcc14515 	stw	r19,1300(sp)
 320a130:	d8014615 	stw	zero,1304(sp)
 320a134:	003b9b06 	br	3208fa4 <___vfprintf_internal_r+0xa88>
 320a138:	0027883a 	mov	r19,zero
 320a13c:	00397806 	br	3208720 <___vfprintf_internal_r+0x204>
 320a140:	00c0c974 	movhi	r3,805
 320a144:	18f89e04 	addi	r3,r3,-7560
 320a148:	100f883a 	mov	r7,r2
 320a14c:	d8814515 	stw	r2,1300(sp)
 320a150:	d8c14115 	stw	r3,1284(sp)
 320a154:	0039e006 	br	32088d8 <___vfprintf_internal_r+0x3bc>
 320a158:	0080c974 	movhi	r2,805
 320a15c:	10b89d04 	addi	r2,r2,-7564
 320a160:	d8814115 	stw	r2,1284(sp)
 320a164:	003d1c06 	br	32095d8 <___vfprintf_internal_r+0x10bc>
 320a168:	d9414d17 	ldw	r5,1332(sp)
 320a16c:	00801984 	movi	r2,102
 320a170:	28804926 	beq	r5,r2,320a298 <___vfprintf_internal_r+0x1d7c>
 320a174:	200f883a 	mov	r7,r4
 320a178:	24805716 	blt	r4,r18,320a2d8 <___vfprintf_internal_r+0x1dbc>
 320a17c:	d9414c17 	ldw	r5,1328(sp)
 320a180:	2880004c 	andi	r2,r5,1
 320a184:	10000126 	beq	r2,zero,320a18c <___vfprintf_internal_r+0x1c70>
 320a188:	21c00044 	addi	r7,r4,1
 320a18c:	d9c14515 	stw	r7,1300(sp)
 320a190:	383fcc0e 	bge	r7,zero,320a0c4 <___vfprintf_internal_r+0x1ba8>
 320a194:	d8014515 	stw	zero,1300(sp)
 320a198:	003fca06 	br	320a0c4 <___vfprintf_internal_r+0x1ba8>
 320a19c:	d9000517 	ldw	r4,20(sp)
 320a1a0:	00bfff04 	movi	r2,-4
 320a1a4:	1100480e 	bge	r2,r4,320a2c8 <___vfprintf_internal_r+0x1dac>
 320a1a8:	99004716 	blt	r19,r4,320a2c8 <___vfprintf_internal_r+0x1dac>
 320a1ac:	d8c14d15 	stw	r3,1332(sp)
 320a1b0:	003ff006 	br	320a174 <___vfprintf_internal_r+0x1c58>
 320a1b4:	d8800717 	ldw	r2,28(sp)
 320a1b8:	14bf8b2e 	bgeu	r2,r18,3209fe8 <___vfprintf_internal_r+0x1acc>
 320a1bc:	9007883a 	mov	r3,r18
 320a1c0:	01000c04 	movi	r4,48
 320a1c4:	11000005 	stb	r4,0(r2)
 320a1c8:	10800044 	addi	r2,r2,1
 320a1cc:	d8800715 	stw	r2,28(sp)
 320a1d0:	18bffc1e 	bne	r3,r2,320a1c4 <___vfprintf_internal_r+0x1ca8>
 320a1d4:	003f8406 	br	3209fe8 <___vfprintf_internal_r+0x1acc>
 320a1d8:	d8814117 	ldw	r2,1284(sp)
 320a1dc:	10c00007 	ldb	r3,0(r2)
 320a1e0:	00800c04 	movi	r2,48
 320a1e4:	18805b26 	beq	r3,r2,320a354 <___vfprintf_internal_r+0x1e38>
 320a1e8:	d9000517 	ldw	r4,20(sp)
 320a1ec:	9125883a 	add	r18,r18,r4
 320a1f0:	003f7506 	br	3209fc8 <___vfprintf_internal_r+0x1aac>
 320a1f4:	d9014c17 	ldw	r4,1328(sp)
 320a1f8:	2080004c 	andi	r2,r4,1
 320a1fc:	1005003a 	cmpeq	r2,r2,zero
 320a200:	103f6a26 	beq	r2,zero,3209fac <___vfprintf_internal_r+0x1a90>
 320a204:	d8800717 	ldw	r2,28(sp)
 320a208:	003f7706 	br	3209fe8 <___vfprintf_internal_r+0x1acc>
 320a20c:	d9c14515 	stw	r7,1300(sp)
 320a210:	38004d16 	blt	r7,zero,320a348 <___vfprintf_internal_r+0x1e2c>
 320a214:	dc814715 	stw	r18,1308(sp)
 320a218:	d8014615 	stw	zero,1304(sp)
 320a21c:	003b6106 	br	3208fa4 <___vfprintf_internal_r+0xa88>
 320a220:	d9014f17 	ldw	r4,1340(sp)
 320a224:	d8800504 	addi	r2,sp,20
 320a228:	d8800115 	stw	r2,4(sp)
 320a22c:	d8c00604 	addi	r3,sp,24
 320a230:	d8800704 	addi	r2,sp,28
 320a234:	800b883a 	mov	r5,r16
 320a238:	880d883a 	mov	r6,r17
 320a23c:	01c000c4 	movi	r7,3
 320a240:	d8c00215 	stw	r3,8(sp)
 320a244:	d8800315 	stw	r2,12(sp)
 320a248:	dcc00015 	stw	r19,0(sp)
 320a24c:	9829883a 	mov	r20,r19
 320a250:	320c0f40 	call	320c0f4 <_dtoa_r>
 320a254:	d8814115 	stw	r2,1284(sp)
 320a258:	003f5106 	br	3209fa0 <___vfprintf_internal_r+0x1a84>
 320a25c:	d8c14217 	ldw	r3,1288(sp)
 320a260:	d9014317 	ldw	r4,1292(sp)
 320a264:	07000b44 	movi	fp,45
 320a268:	1821883a 	mov	r16,r3
 320a26c:	2460003c 	xorhi	r17,r4,32768
 320a270:	003f3106 	br	3209f38 <___vfprintf_internal_r+0x1a1c>
 320a274:	9d000044 	addi	r20,r19,1
 320a278:	003f3906 	br	3209f60 <___vfprintf_internal_r+0x1a44>
 320a27c:	983f251e 	bne	r19,zero,3209f14 <___vfprintf_internal_r+0x19f8>
 320a280:	04c00044 	movi	r19,1
 320a284:	003f2306 	br	3209f14 <___vfprintf_internal_r+0x19f8>
 320a288:	04c00184 	movi	r19,6
 320a28c:	003f2106 	br	3209f14 <___vfprintf_internal_r+0x19f8>
 320a290:	d8014515 	stw	zero,1300(sp)
 320a294:	003eee06 	br	3209e50 <___vfprintf_internal_r+0x1934>
 320a298:	200f883a 	mov	r7,r4
 320a29c:	0100370e 	bge	zero,r4,320a37c <___vfprintf_internal_r+0x1e60>
 320a2a0:	9800031e 	bne	r19,zero,320a2b0 <___vfprintf_internal_r+0x1d94>
 320a2a4:	d9814c17 	ldw	r6,1328(sp)
 320a2a8:	3080004c 	andi	r2,r6,1
 320a2ac:	103fb726 	beq	r2,zero,320a18c <___vfprintf_internal_r+0x1c70>
 320a2b0:	20800044 	addi	r2,r4,1
 320a2b4:	98a7883a 	add	r19,r19,r2
 320a2b8:	dcc14515 	stw	r19,1300(sp)
 320a2bc:	980f883a 	mov	r7,r19
 320a2c0:	983f800e 	bge	r19,zero,320a0c4 <___vfprintf_internal_r+0x1ba8>
 320a2c4:	003fb306 	br	320a194 <___vfprintf_internal_r+0x1c78>
 320a2c8:	d9814d17 	ldw	r6,1332(sp)
 320a2cc:	31bfff84 	addi	r6,r6,-2
 320a2d0:	d9814d15 	stw	r6,1332(sp)
 320a2d4:	003f4c06 	br	320a008 <___vfprintf_internal_r+0x1aec>
 320a2d8:	0100180e 	bge	zero,r4,320a33c <___vfprintf_internal_r+0x1e20>
 320a2dc:	00800044 	movi	r2,1
 320a2e0:	1485883a 	add	r2,r2,r18
 320a2e4:	d8814515 	stw	r2,1300(sp)
 320a2e8:	100f883a 	mov	r7,r2
 320a2ec:	103f750e 	bge	r2,zero,320a0c4 <___vfprintf_internal_r+0x1ba8>
 320a2f0:	003fa806 	br	320a194 <___vfprintf_internal_r+0x1c78>
 320a2f4:	80c00c04 	addi	r3,r16,48
 320a2f8:	00800c04 	movi	r2,48
 320a2fc:	d8c008c5 	stb	r3,35(sp)
 320a300:	d9800804 	addi	r6,sp,32
 320a304:	d8c00904 	addi	r3,sp,36
 320a308:	d8800885 	stb	r2,34(sp)
 320a30c:	003f6506 	br	320a0a4 <___vfprintf_internal_r+0x1b88>
 320a310:	d9014c17 	ldw	r4,1328(sp)
 320a314:	2084703a 	and	r2,r4,r2
 320a318:	103f9c26 	beq	r2,zero,320a18c <___vfprintf_internal_r+0x1c70>
 320a31c:	003f6606 	br	320a0b8 <___vfprintf_internal_r+0x1b9c>
 320a320:	d9800804 	addi	r6,sp,32
 320a324:	d8c00884 	addi	r3,sp,34
 320a328:	003f5e06 	br	320a0a4 <___vfprintf_internal_r+0x1b88>
 320a32c:	00800b44 	movi	r2,45
 320a330:	0121c83a 	sub	r16,zero,r4
 320a334:	d8800845 	stb	r2,33(sp)
 320a338:	003f3d06 	br	320a030 <___vfprintf_internal_r+0x1b14>
 320a33c:	00800084 	movi	r2,2
 320a340:	1105c83a 	sub	r2,r2,r4
 320a344:	003fe606 	br	320a2e0 <___vfprintf_internal_r+0x1dc4>
 320a348:	d8014515 	stw	zero,1300(sp)
 320a34c:	dc814715 	stw	r18,1308(sp)
 320a350:	003fb106 	br	320a218 <___vfprintf_internal_r+0x1cfc>
 320a354:	000d883a 	mov	r6,zero
 320a358:	000f883a 	mov	r7,zero
 320a35c:	8009883a 	mov	r4,r16
 320a360:	880b883a 	mov	r5,r17
 320a364:	32139500 	call	3213950 <__nedf2>
 320a368:	103f9f26 	beq	r2,zero,320a1e8 <___vfprintf_internal_r+0x1ccc>
 320a36c:	00800044 	movi	r2,1
 320a370:	1509c83a 	sub	r4,r2,r20
 320a374:	d9000515 	stw	r4,20(sp)
 320a378:	003f9b06 	br	320a1e8 <___vfprintf_internal_r+0x1ccc>
 320a37c:	98000d1e 	bne	r19,zero,320a3b4 <___vfprintf_internal_r+0x1e98>
 320a380:	d8c14c17 	ldw	r3,1328(sp)
 320a384:	1880004c 	andi	r2,r3,1
 320a388:	10000a1e 	bne	r2,zero,320a3b4 <___vfprintf_internal_r+0x1e98>
 320a38c:	01000044 	movi	r4,1
 320a390:	200f883a 	mov	r7,r4
 320a394:	d9014515 	stw	r4,1300(sp)
 320a398:	003f4a06 	br	320a0c4 <___vfprintf_internal_r+0x1ba8>
 320a39c:	3cc00017 	ldw	r19,0(r7)
 320a3a0:	39c00104 	addi	r7,r7,4
 320a3a4:	983d0e0e 	bge	r19,zero,32097e0 <___vfprintf_internal_r+0x12c4>
 320a3a8:	b8c00007 	ldb	r3,0(r23)
 320a3ac:	04ffffc4 	movi	r19,-1
 320a3b0:	0038d906 	br	3208718 <___vfprintf_internal_r+0x1fc>
 320a3b4:	9cc00084 	addi	r19,r19,2
 320a3b8:	dcc14515 	stw	r19,1300(sp)
 320a3bc:	980f883a 	mov	r7,r19
 320a3c0:	983f400e 	bge	r19,zero,320a0c4 <___vfprintf_internal_r+0x1ba8>
 320a3c4:	003f7306 	br	320a194 <___vfprintf_internal_r+0x1c78>

0320a3c8 <__vfprintf_internal>:
 320a3c8:	0080c974 	movhi	r2,805
 320a3cc:	108a6304 	addi	r2,r2,10636
 320a3d0:	2013883a 	mov	r9,r4
 320a3d4:	11000017 	ldw	r4,0(r2)
 320a3d8:	2805883a 	mov	r2,r5
 320a3dc:	300f883a 	mov	r7,r6
 320a3e0:	480b883a 	mov	r5,r9
 320a3e4:	100d883a 	mov	r6,r2
 320a3e8:	320851c1 	jmpi	320851c <___vfprintf_internal_r>

0320a3ec <__svfscanf_r>:
 320a3ec:	deff4e04 	addi	sp,sp,-712
 320a3f0:	dd80ae15 	stw	r22,696(sp)
 320a3f4:	dd00ac15 	stw	r20,688(sp)
 320a3f8:	dc40a915 	stw	r17,676(sp)
 320a3fc:	dc00a815 	stw	r16,672(sp)
 320a400:	dfc0b115 	stw	ra,708(sp)
 320a404:	df00b015 	stw	fp,704(sp)
 320a408:	ddc0af15 	stw	r23,700(sp)
 320a40c:	dd40ad15 	stw	r21,692(sp)
 320a410:	dcc0ab15 	stw	r19,684(sp)
 320a414:	dc80aa15 	stw	r18,680(sp)
 320a418:	202d883a 	mov	r22,r4
 320a41c:	2821883a 	mov	r16,r5
 320a420:	d9c0a415 	stw	r7,656(sp)
 320a424:	3029883a 	mov	r20,r6
 320a428:	d800a215 	stw	zero,648(sp)
 320a42c:	0023883a 	mov	r17,zero
 320a430:	d800a115 	stw	zero,644(sp)
 320a434:	d800a015 	stw	zero,640(sp)
 320a438:	a1000007 	ldb	r4,0(r20)
 320a43c:	d9000115 	stw	r4,4(sp)
 320a440:	20001f26 	beq	r4,zero,320a4c0 <__svfscanf_r+0xd4>
 320a444:	0480c974 	movhi	r18,805
 320a448:	948a6204 	addi	r18,r18,10632
 320a44c:	91800017 	ldw	r6,0(r18)
 320a450:	a5000044 	addi	r20,r20,1
 320a454:	3107883a 	add	r3,r6,r4
 320a458:	18800003 	ldbu	r2,0(r3)
 320a45c:	1080020c 	andi	r2,r2,8
 320a460:	10002426 	beq	r2,zero,320a4f4 <__svfscanf_r+0x108>
 320a464:	80c00117 	ldw	r3,4(r16)
 320a468:	00c00e0e 	bge	zero,r3,320a4a4 <__svfscanf_r+0xb8>
 320a46c:	81400017 	ldw	r5,0(r16)
 320a470:	90800017 	ldw	r2,0(r18)
 320a474:	28c00003 	ldbu	r3,0(r5)
 320a478:	1887883a 	add	r3,r3,r2
 320a47c:	19000003 	ldbu	r4,0(r3)
 320a480:	2100020c 	andi	r4,r4,8
 320a484:	203fec26 	beq	r4,zero,320a438 <__svfscanf_r+0x4c>
 320a488:	80c00117 	ldw	r3,4(r16)
 320a48c:	29800044 	addi	r6,r5,1
 320a490:	8c400044 	addi	r17,r17,1
 320a494:	18ffffc4 	addi	r3,r3,-1
 320a498:	81800015 	stw	r6,0(r16)
 320a49c:	80c00115 	stw	r3,4(r16)
 320a4a0:	00fff216 	blt	zero,r3,320a46c <__svfscanf_r+0x80>
 320a4a4:	b009883a 	mov	r4,r22
 320a4a8:	800b883a 	mov	r5,r16
 320a4ac:	32077100 	call	3207710 <__srefill_r>
 320a4b0:	103fee26 	beq	r2,zero,320a46c <__svfscanf_r+0x80>
 320a4b4:	a1000007 	ldb	r4,0(r20)
 320a4b8:	d9000115 	stw	r4,4(sp)
 320a4bc:	203fe11e 	bne	r4,zero,320a444 <__svfscanf_r+0x58>
 320a4c0:	d880a217 	ldw	r2,648(sp)
 320a4c4:	dfc0b117 	ldw	ra,708(sp)
 320a4c8:	df00b017 	ldw	fp,704(sp)
 320a4cc:	ddc0af17 	ldw	r23,700(sp)
 320a4d0:	dd80ae17 	ldw	r22,696(sp)
 320a4d4:	dd40ad17 	ldw	r21,692(sp)
 320a4d8:	dd00ac17 	ldw	r20,688(sp)
 320a4dc:	dcc0ab17 	ldw	r19,684(sp)
 320a4e0:	dc80aa17 	ldw	r18,680(sp)
 320a4e4:	dc40a917 	ldw	r17,676(sp)
 320a4e8:	dc00a817 	ldw	r16,672(sp)
 320a4ec:	dec0b204 	addi	sp,sp,712
 320a4f0:	f800283a 	ret
 320a4f4:	00800944 	movi	r2,37
 320a4f8:	20801626 	beq	r4,r2,320a554 <__svfscanf_r+0x168>
 320a4fc:	80800117 	ldw	r2,4(r16)
 320a500:	00800b0e 	bge	zero,r2,320a530 <__svfscanf_r+0x144>
 320a504:	81000017 	ldw	r4,0(r16)
 320a508:	a0ffffc7 	ldb	r3,-1(r20)
 320a50c:	20800003 	ldbu	r2,0(r4)
 320a510:	10ffeb1e 	bne	r2,r3,320a4c0 <__svfscanf_r+0xd4>
 320a514:	80c00117 	ldw	r3,4(r16)
 320a518:	21800044 	addi	r6,r4,1
 320a51c:	8c400044 	addi	r17,r17,1
 320a520:	18ffffc4 	addi	r3,r3,-1
 320a524:	80c00115 	stw	r3,4(r16)
 320a528:	81800015 	stw	r6,0(r16)
 320a52c:	003fc206 	br	320a438 <__svfscanf_r+0x4c>
 320a530:	b009883a 	mov	r4,r22
 320a534:	800b883a 	mov	r5,r16
 320a538:	32077100 	call	3207710 <__srefill_r>
 320a53c:	103ff126 	beq	r2,zero,320a504 <__svfscanf_r+0x118>
 320a540:	d900a217 	ldw	r4,648(sp)
 320a544:	2004c91e 	bne	r4,zero,320b86c <__svfscanf_r+0x1480>
 320a548:	00bfffc4 	movi	r2,-1
 320a54c:	d880a215 	stw	r2,648(sp)
 320a550:	003fdb06 	br	320a4c0 <__svfscanf_r+0xd4>
 320a554:	d800a315 	stw	zero,652(sp)
 320a558:	0027883a 	mov	r19,zero
 320a55c:	a0c00003 	ldbu	r3,0(r20)
 320a560:	00801e04 	movi	r2,120
 320a564:	a5000044 	addi	r20,r20,1
 320a568:	19403fcc 	andi	r5,r3,255
 320a56c:	2940201c 	xori	r5,r5,128
 320a570:	297fe004 	addi	r5,r5,-128
 320a574:	10c08036 	bltu	r2,r3,320a778 <__svfscanf_r+0x38c>
 320a578:	18c5883a 	add	r2,r3,r3
 320a57c:	1085883a 	add	r2,r2,r2
 320a580:	00c0c874 	movhi	r3,801
 320a584:	18e96504 	addi	r3,r3,-23148
 320a588:	10c5883a 	add	r2,r2,r3
 320a58c:	11000017 	ldw	r4,0(r2)
 320a590:	2000683a 	jmp	r4
 320a594:	0320a548 	cmpgei	r12,zero,-32107
 320a598:	0320a778 	rdprs	r12,zero,-32099
 320a59c:	0320a778 	rdprs	r12,zero,-32099
 320a5a0:	0320a778 	rdprs	r12,zero,-32099
 320a5a4:	0320a778 	rdprs	r12,zero,-32099
 320a5a8:	0320a778 	rdprs	r12,zero,-32099
 320a5ac:	0320a778 	rdprs	r12,zero,-32099
 320a5b0:	0320a778 	rdprs	r12,zero,-32099
 320a5b4:	0320a778 	rdprs	r12,zero,-32099
 320a5b8:	0320a778 	rdprs	r12,zero,-32099
 320a5bc:	0320a778 	rdprs	r12,zero,-32099
 320a5c0:	0320a778 	rdprs	r12,zero,-32099
 320a5c4:	0320a778 	rdprs	r12,zero,-32099
 320a5c8:	0320a778 	rdprs	r12,zero,-32099
 320a5cc:	0320a778 	rdprs	r12,zero,-32099
 320a5d0:	0320a778 	rdprs	r12,zero,-32099
 320a5d4:	0320a778 	rdprs	r12,zero,-32099
 320a5d8:	0320a778 	rdprs	r12,zero,-32099
 320a5dc:	0320a778 	rdprs	r12,zero,-32099
 320a5e0:	0320a778 	rdprs	r12,zero,-32099
 320a5e4:	0320a778 	rdprs	r12,zero,-32099
 320a5e8:	0320a778 	rdprs	r12,zero,-32099
 320a5ec:	0320a778 	rdprs	r12,zero,-32099
 320a5f0:	0320a778 	rdprs	r12,zero,-32099
 320a5f4:	0320a778 	rdprs	r12,zero,-32099
 320a5f8:	0320a778 	rdprs	r12,zero,-32099
 320a5fc:	0320a778 	rdprs	r12,zero,-32099
 320a600:	0320a778 	rdprs	r12,zero,-32099
 320a604:	0320a778 	rdprs	r12,zero,-32099
 320a608:	0320a778 	rdprs	r12,zero,-32099
 320a60c:	0320a778 	rdprs	r12,zero,-32099
 320a610:	0320a778 	rdprs	r12,zero,-32099
 320a614:	0320a778 	rdprs	r12,zero,-32099
 320a618:	0320a778 	rdprs	r12,zero,-32099
 320a61c:	0320a778 	rdprs	r12,zero,-32099
 320a620:	0320a778 	rdprs	r12,zero,-32099
 320a624:	0320a778 	rdprs	r12,zero,-32099
 320a628:	0320a4fc 	xorhi	r12,zero,33427
 320a62c:	0320a778 	rdprs	r12,zero,-32099
 320a630:	0320a778 	rdprs	r12,zero,-32099
 320a634:	0320a778 	rdprs	r12,zero,-32099
 320a638:	0320a778 	rdprs	r12,zero,-32099
 320a63c:	0320b79c 	xori	r12,zero,33502
 320a640:	0320a778 	rdprs	r12,zero,-32099
 320a644:	0320a778 	rdprs	r12,zero,-32099
 320a648:	0320a778 	rdprs	r12,zero,-32099
 320a64c:	0320a778 	rdprs	r12,zero,-32099
 320a650:	0320a778 	rdprs	r12,zero,-32099
 320a654:	0320b198 	cmpnei	r12,zero,-32058
 320a658:	0320b198 	cmpnei	r12,zero,-32058
 320a65c:	0320b198 	cmpnei	r12,zero,-32058
 320a660:	0320b198 	cmpnei	r12,zero,-32058
 320a664:	0320b198 	cmpnei	r12,zero,-32058
 320a668:	0320b198 	cmpnei	r12,zero,-32058
 320a66c:	0320b198 	cmpnei	r12,zero,-32058
 320a670:	0320b198 	cmpnei	r12,zero,-32058
 320a674:	0320b198 	cmpnei	r12,zero,-32058
 320a678:	0320b198 	cmpnei	r12,zero,-32058
 320a67c:	0320a778 	rdprs	r12,zero,-32099
 320a680:	0320a778 	rdprs	r12,zero,-32099
 320a684:	0320a778 	rdprs	r12,zero,-32099
 320a688:	0320a778 	rdprs	r12,zero,-32099
 320a68c:	0320a778 	rdprs	r12,zero,-32099
 320a690:	0320a778 	rdprs	r12,zero,-32099
 320a694:	0320a778 	rdprs	r12,zero,-32099
 320a698:	0320a778 	rdprs	r12,zero,-32099
 320a69c:	0320a778 	rdprs	r12,zero,-32099
 320a6a0:	0320a778 	rdprs	r12,zero,-32099
 320a6a4:	0320b918 	cmpnei	r12,zero,-32028
 320a6a8:	0320b910 	cmplti	r12,zero,-32028
 320a6ac:	0320a778 	rdprs	r12,zero,-32099
 320a6b0:	0320b910 	cmplti	r12,zero,-32028
 320a6b4:	0320a778 	rdprs	r12,zero,-32099
 320a6b8:	0320a778 	rdprs	r12,zero,-32099
 320a6bc:	0320a778 	rdprs	r12,zero,-32099
 320a6c0:	0320a778 	rdprs	r12,zero,-32099
 320a6c4:	0320b9a8 	cmpgeui	r12,zero,33510
 320a6c8:	0320a778 	rdprs	r12,zero,-32099
 320a6cc:	0320a778 	rdprs	r12,zero,-32099
 320a6d0:	0320b960 	cmpeqi	r12,zero,-32027
 320a6d4:	0320a778 	rdprs	r12,zero,-32099
 320a6d8:	0320a778 	rdprs	r12,zero,-32099
 320a6dc:	0320a778 	rdprs	r12,zero,-32099
 320a6e0:	0320a778 	rdprs	r12,zero,-32099
 320a6e4:	0320a778 	rdprs	r12,zero,-32099
 320a6e8:	0320a778 	rdprs	r12,zero,-32099
 320a6ec:	0320a778 	rdprs	r12,zero,-32099
 320a6f0:	0320a778 	rdprs	r12,zero,-32099
 320a6f4:	0320b7a4 	muli	r12,zero,-32034
 320a6f8:	0320a778 	rdprs	r12,zero,-32099
 320a6fc:	0320a778 	rdprs	r12,zero,-32099
 320a700:	0320b944 	movi	r12,-32027
 320a704:	0320a778 	rdprs	r12,zero,-32099
 320a708:	0320a778 	rdprs	r12,zero,-32099
 320a70c:	0320a778 	rdprs	r12,zero,-32099
 320a710:	0320a778 	rdprs	r12,zero,-32099
 320a714:	0320a778 	rdprs	r12,zero,-32099
 320a718:	0320a778 	rdprs	r12,zero,-32099
 320a71c:	0320a778 	rdprs	r12,zero,-32099
 320a720:	0320b938 	rdprs	r12,zero,-32028
 320a724:	0320b91c 	xori	r12,zero,33508
 320a728:	0320b910 	cmplti	r12,zero,-32028
 320a72c:	0320b910 	cmplti	r12,zero,-32028
 320a730:	0320b910 	cmplti	r12,zero,-32028
 320a734:	0320b908 	cmpgei	r12,zero,-32028
 320a738:	0320b9fc 	xorhi	r12,zero,33511
 320a73c:	0320a778 	rdprs	r12,zero,-32099
 320a740:	0320a778 	rdprs	r12,zero,-32099
 320a744:	0320b9e8 	cmpgeui	r12,zero,33511
 320a748:	0320a778 	rdprs	r12,zero,-32099
 320a74c:	0320b980 	call	320b98 <OSCtxSw_SWITCH_PC+0x320b58>
 320a750:	0320b964 	muli	r12,zero,-32027
 320a754:	0320b9b8 	rdprs	r12,zero,-32026
 320a758:	0320a778 	rdprs	r12,zero,-32099
 320a75c:	0320a778 	rdprs	r12,zero,-32099
 320a760:	0320b9b0 	cmpltui	r12,zero,33510
 320a764:	0320a778 	rdprs	r12,zero,-32099
 320a768:	0320ace8 	cmpgeui	r12,zero,33459
 320a76c:	0320a778 	rdprs	r12,zero,-32099
 320a770:	0320a778 	rdprs	r12,zero,-32099
 320a774:	0320b7a4 	muli	r12,zero,-32034
 320a778:	2987883a 	add	r3,r5,r6
 320a77c:	18800003 	ldbu	r2,0(r3)
 320a780:	1080004c 	andi	r2,r2,1
 320a784:	1005003a 	cmpeq	r2,r2,zero
 320a788:	10002c26 	beq	r2,zero,320a83c <__svfscanf_r+0x450>
 320a78c:	0100c874 	movhi	r4,801
 320a790:	21017904 	addi	r4,r4,1508
 320a794:	00800284 	movi	r2,10
 320a798:	d900a015 	stw	r4,640(sp)
 320a79c:	054000c4 	movi	r21,3
 320a7a0:	d880a115 	stw	r2,644(sp)
 320a7a4:	80c00117 	ldw	r3,4(r16)
 320a7a8:	00c14a0e 	bge	zero,r3,320acd4 <__svfscanf_r+0x8e8>
 320a7ac:	9880100c 	andi	r2,r19,64
 320a7b0:	10001326 	beq	r2,zero,320a800 <__svfscanf_r+0x414>
 320a7b4:	00800104 	movi	r2,4
 320a7b8:	157f1f36 	bltu	r2,r21,320a438 <__svfscanf_r+0x4c>
 320a7bc:	ad45883a 	add	r2,r21,r21
 320a7c0:	1085883a 	add	r2,r2,r2
 320a7c4:	00c0c874 	movhi	r3,801
 320a7c8:	18e9f604 	addi	r3,r3,-22568
 320a7cc:	10c5883a 	add	r2,r2,r3
 320a7d0:	11000017 	ldw	r4,0(r2)
 320a7d4:	2000683a 	jmp	r4
 320a7d8:	0320a844 	movi	r12,-32095
 320a7dc:	0320a950 	cmplti	r12,zero,-32091
 320a7e0:	0320a9c4 	movi	r12,-32089
 320a7e4:	0320acb0 	cmpltui	r12,zero,33458
 320a7e8:	0320aafc 	xorhi	r12,zero,33451
 320a7ec:	b009883a 	mov	r4,r22
 320a7f0:	800b883a 	mov	r5,r16
 320a7f4:	32077100 	call	3207710 <__srefill_r>
 320a7f8:	103f511e 	bne	r2,zero,320a540 <__svfscanf_r+0x154>
 320a7fc:	8c400044 	addi	r17,r17,1
 320a800:	81400017 	ldw	r5,0(r16)
 320a804:	90800017 	ldw	r2,0(r18)
 320a808:	28c00003 	ldbu	r3,0(r5)
 320a80c:	1887883a 	add	r3,r3,r2
 320a810:	19000003 	ldbu	r4,0(r3)
 320a814:	2100020c 	andi	r4,r4,8
 320a818:	203fe626 	beq	r4,zero,320a7b4 <__svfscanf_r+0x3c8>
 320a81c:	80c00117 	ldw	r3,4(r16)
 320a820:	18ffffc4 	addi	r3,r3,-1
 320a824:	80c00115 	stw	r3,4(r16)
 320a828:	00fff00e 	bge	zero,r3,320a7ec <__svfscanf_r+0x400>
 320a82c:	29800044 	addi	r6,r5,1
 320a830:	8c400044 	addi	r17,r17,1
 320a834:	81800015 	stw	r6,0(r16)
 320a838:	003ff106 	br	320a800 <__svfscanf_r+0x414>
 320a83c:	9cc00054 	ori	r19,r19,1
 320a840:	003fd206 	br	320a78c <__svfscanf_r+0x3a0>
 320a844:	d8c0a317 	ldw	r3,652(sp)
 320a848:	1800021e 	bne	r3,zero,320a854 <__svfscanf_r+0x468>
 320a84c:	01000044 	movi	r4,1
 320a850:	d900a315 	stw	r4,652(sp)
 320a854:	9880004c 	andi	r2,r19,1
 320a858:	1005003a 	cmpeq	r2,r2,zero
 320a85c:	1003d91e 	bne	r2,zero,320b7c4 <__svfscanf_r+0x13d8>
 320a860:	9d40040c 	andi	r21,r19,16
 320a864:	a839003a 	cmpeq	fp,r21,zero
 320a868:	e0042526 	beq	fp,zero,320b900 <__svfscanf_r+0x1514>
 320a86c:	d880a417 	ldw	r2,656(sp)
 320a870:	14c00017 	ldw	r19,0(r2)
 320a874:	10800104 	addi	r2,r2,4
 320a878:	d880a415 	stw	r2,656(sp)
 320a87c:	d8c0a317 	ldw	r3,652(sp)
 320a880:	18041a26 	beq	r3,zero,320b8ec <__svfscanf_r+0x1500>
 320a884:	0100c974 	movhi	r4,805
 320a888:	210a6704 	addi	r4,r4,10652
 320a88c:	20800017 	ldw	r2,0(r4)
 320a890:	103f2b26 	beq	r2,zero,320a540 <__svfscanf_r+0x154>
 320a894:	d8804404 	addi	r2,sp,272
 320a898:	0025883a 	mov	r18,zero
 320a89c:	d880a615 	stw	r2,664(sp)
 320a8a0:	05ffffc4 	movi	r23,-1
 320a8a4:	80800017 	ldw	r2,0(r16)
 320a8a8:	80c00117 	ldw	r3,4(r16)
 320a8ac:	d900a617 	ldw	r4,664(sp)
 320a8b0:	12000003 	ldbu	r8,0(r2)
 320a8b4:	18ffffc4 	addi	r3,r3,-1
 320a8b8:	11800044 	addi	r6,r2,1
 320a8bc:	248f883a 	add	r7,r4,r18
 320a8c0:	80c00115 	stw	r3,4(r16)
 320a8c4:	81800015 	stw	r6,0(r16)
 320a8c8:	3a000005 	stb	r8,0(r7)
 320a8cc:	d9000204 	addi	r4,sp,8
 320a8d0:	000b883a 	mov	r5,zero
 320a8d4:	01800204 	movi	r6,8
 320a8d8:	3206c500 	call	3206c50 <memset>
 320a8dc:	d980a617 	ldw	r6,664(sp)
 320a8e0:	94800044 	addi	r18,r18,1
 320a8e4:	d8800204 	addi	r2,sp,8
 320a8e8:	b009883a 	mov	r4,r22
 320a8ec:	980b883a 	mov	r5,r19
 320a8f0:	900f883a 	mov	r7,r18
 320a8f4:	d8800015 	stw	r2,0(sp)
 320a8f8:	320dc180 	call	320dc18 <_mbrtowc_r>
 320a8fc:	1007883a 	mov	r3,r2
 320a900:	15ff0f26 	beq	r2,r23,320a540 <__svfscanf_r+0x154>
 320a904:	1003f11e 	bne	r2,zero,320b8cc <__svfscanf_r+0x14e0>
 320a908:	a800011e 	bne	r21,zero,320a910 <__svfscanf_r+0x524>
 320a90c:	98000015 	stw	zero,0(r19)
 320a910:	d8c0a317 	ldw	r3,652(sp)
 320a914:	8ca3883a 	add	r17,r17,r18
 320a918:	18ffffc4 	addi	r3,r3,-1
 320a91c:	d8c0a315 	stw	r3,652(sp)
 320a920:	e0000126 	beq	fp,zero,320a928 <__svfscanf_r+0x53c>
 320a924:	9cc00104 	addi	r19,r19,4
 320a928:	0025883a 	mov	r18,zero
 320a92c:	80c00117 	ldw	r3,4(r16)
 320a930:	00c3e90e 	bge	zero,r3,320b8d8 <__svfscanf_r+0x14ec>
 320a934:	d900a317 	ldw	r4,652(sp)
 320a938:	2003ec26 	beq	r4,zero,320b8ec <__svfscanf_r+0x1500>
 320a93c:	00c0c974 	movhi	r3,805
 320a940:	18ca6704 	addi	r3,r3,10652
 320a944:	18800017 	ldw	r2,0(r3)
 320a948:	90bfd61e 	bne	r18,r2,320a8a4 <__svfscanf_r+0x4b8>
 320a94c:	003efc06 	br	320a540 <__svfscanf_r+0x154>
 320a950:	d880a317 	ldw	r2,652(sp)
 320a954:	1000021e 	bne	r2,zero,320a960 <__svfscanf_r+0x574>
 320a958:	00ffffc4 	movi	r3,-1
 320a95c:	d8c0a315 	stw	r3,652(sp)
 320a960:	9880040c 	andi	r2,r19,16
 320a964:	10036526 	beq	r2,zero,320b6fc <__svfscanf_r+0x1310>
 320a968:	0027883a 	mov	r19,zero
 320a96c:	dd400404 	addi	r21,sp,16
 320a970:	81000017 	ldw	r4,0(r16)
 320a974:	20800003 	ldbu	r2,0(r4)
 320a978:	a885883a 	add	r2,r21,r2
 320a97c:	10c00007 	ldb	r3,0(r2)
 320a980:	1803be26 	beq	r3,zero,320b87c <__svfscanf_r+0x1490>
 320a984:	80c00117 	ldw	r3,4(r16)
 320a988:	21800044 	addi	r6,r4,1
 320a98c:	d900a317 	ldw	r4,652(sp)
 320a990:	18ffffc4 	addi	r3,r3,-1
 320a994:	9cc00044 	addi	r19,r19,1
 320a998:	81800015 	stw	r6,0(r16)
 320a99c:	80c00115 	stw	r3,4(r16)
 320a9a0:	24c3b626 	beq	r4,r19,320b87c <__svfscanf_r+0x1490>
 320a9a4:	00fff216 	blt	zero,r3,320a970 <__svfscanf_r+0x584>
 320a9a8:	b009883a 	mov	r4,r22
 320a9ac:	800b883a 	mov	r5,r16
 320a9b0:	32077100 	call	3207710 <__srefill_r>
 320a9b4:	103fee26 	beq	r2,zero,320a970 <__svfscanf_r+0x584>
 320a9b8:	983ee126 	beq	r19,zero,320a540 <__svfscanf_r+0x154>
 320a9bc:	8ce3883a 	add	r17,r17,r19
 320a9c0:	003e9d06 	br	320a438 <__svfscanf_r+0x4c>
 320a9c4:	d900a317 	ldw	r4,652(sp)
 320a9c8:	2000021e 	bne	r4,zero,320a9d4 <__svfscanf_r+0x5e8>
 320a9cc:	00bfffc4 	movi	r2,-1
 320a9d0:	d880a315 	stw	r2,652(sp)
 320a9d4:	9880004c 	andi	r2,r19,1
 320a9d8:	1005003a 	cmpeq	r2,r2,zero
 320a9dc:	1001f41e 	bne	r2,zero,320b1b0 <__svfscanf_r+0xdc4>
 320a9e0:	9dc0040c 	andi	r23,r19,16
 320a9e4:	b807003a 	cmpeq	r3,r23,zero
 320a9e8:	d8c0a515 	stw	r3,660(sp)
 320a9ec:	1803b21e 	bne	r3,zero,320b8b8 <__svfscanf_r+0x14cc>
 320a9f0:	dd400104 	addi	r21,sp,4
 320a9f4:	0027883a 	mov	r19,zero
 320a9f8:	073fffc4 	movi	fp,-1
 320a9fc:	81400017 	ldw	r5,0(r16)
 320aa00:	90800017 	ldw	r2,0(r18)
 320aa04:	29c00003 	ldbu	r7,0(r5)
 320aa08:	38c03fcc 	andi	r3,r7,255
 320aa0c:	1887883a 	add	r3,r3,r2
 320aa10:	19000003 	ldbu	r4,0(r3)
 320aa14:	2100020c 	andi	r4,r4,8
 320aa18:	2000321e 	bne	r4,zero,320aae4 <__svfscanf_r+0x6f8>
 320aa1c:	d8c0a317 	ldw	r3,652(sp)
 320aa20:	18003026 	beq	r3,zero,320aae4 <__svfscanf_r+0x6f8>
 320aa24:	0080c974 	movhi	r2,805
 320aa28:	108a6704 	addi	r2,r2,10652
 320aa2c:	10c00017 	ldw	r3,0(r2)
 320aa30:	98fec326 	beq	r19,r3,320a540 <__svfscanf_r+0x154>
 320aa34:	d8c04404 	addi	r3,sp,272
 320aa38:	80800117 	ldw	r2,4(r16)
 320aa3c:	d8c0a615 	stw	r3,664(sp)
 320aa40:	d900a617 	ldw	r4,664(sp)
 320aa44:	10ffffc4 	addi	r3,r2,-1
 320aa48:	29800044 	addi	r6,r5,1
 320aa4c:	80c00115 	stw	r3,4(r16)
 320aa50:	24c5883a 	add	r2,r4,r19
 320aa54:	81800015 	stw	r6,0(r16)
 320aa58:	d9000204 	addi	r4,sp,8
 320aa5c:	000b883a 	mov	r5,zero
 320aa60:	01800204 	movi	r6,8
 320aa64:	11c00005 	stb	r7,0(r2)
 320aa68:	3206c500 	call	3206c50 <memset>
 320aa6c:	d980a617 	ldw	r6,664(sp)
 320aa70:	9cc00044 	addi	r19,r19,1
 320aa74:	d8800204 	addi	r2,sp,8
 320aa78:	b009883a 	mov	r4,r22
 320aa7c:	a80b883a 	mov	r5,r21
 320aa80:	980f883a 	mov	r7,r19
 320aa84:	d8800015 	stw	r2,0(sp)
 320aa88:	320dc180 	call	320dc18 <_mbrtowc_r>
 320aa8c:	1007883a 	mov	r3,r2
 320aa90:	173eab26 	beq	r2,fp,320a540 <__svfscanf_r+0x154>
 320aa94:	1003851e 	bne	r2,zero,320b8ac <__svfscanf_r+0x14c0>
 320aa98:	a8000015 	stw	zero,0(r21)
 320aa9c:	a9000017 	ldw	r4,0(r21)
 320aaa0:	320dab00 	call	320dab0 <iswspace>
 320aaa4:	1003781e 	bne	r2,zero,320b888 <__svfscanf_r+0x149c>
 320aaa8:	d900a317 	ldw	r4,652(sp)
 320aaac:	d880a517 	ldw	r2,660(sp)
 320aab0:	8ce3883a 	add	r17,r17,r19
 320aab4:	213fffc4 	addi	r4,r4,-1
 320aab8:	d900a315 	stw	r4,652(sp)
 320aabc:	10000126 	beq	r2,zero,320aac4 <__svfscanf_r+0x6d8>
 320aac0:	ad400104 	addi	r21,r21,4
 320aac4:	0027883a 	mov	r19,zero
 320aac8:	80c00117 	ldw	r3,4(r16)
 320aacc:	00ffcb16 	blt	zero,r3,320a9fc <__svfscanf_r+0x610>
 320aad0:	b009883a 	mov	r4,r22
 320aad4:	800b883a 	mov	r5,r16
 320aad8:	32077100 	call	3207710 <__srefill_r>
 320aadc:	103fc726 	beq	r2,zero,320a9fc <__svfscanf_r+0x610>
 320aae0:	983e971e 	bne	r19,zero,320a540 <__svfscanf_r+0x154>
 320aae4:	b83e541e 	bne	r23,zero,320a438 <__svfscanf_r+0x4c>
 320aae8:	d900a217 	ldw	r4,648(sp)
 320aaec:	a8000015 	stw	zero,0(r21)
 320aaf0:	21000044 	addi	r4,r4,1
 320aaf4:	d900a215 	stw	r4,648(sp)
 320aaf8:	003e4f06 	br	320a438 <__svfscanf_r+0x4c>
 320aafc:	d900a317 	ldw	r4,652(sp)
 320ab00:	00805704 	movi	r2,348
 320ab04:	20ffffc4 	addi	r3,r4,-1
 320ab08:	10c1ed2e 	bgeu	r2,r3,320b2c0 <__svfscanf_r+0xed4>
 320ab0c:	00805744 	movi	r2,349
 320ab10:	21bfa8c4 	addi	r6,r4,-349
 320ab14:	9d41e014 	ori	r21,r19,1920
 320ab18:	d880a315 	stw	r2,652(sp)
 320ab1c:	d8c04404 	addi	r3,sp,272
 320ab20:	d8c0a615 	stw	r3,664(sp)
 320ab24:	182f883a 	mov	r23,r3
 320ab28:	d8009f15 	stw	zero,636(sp)
 320ab2c:	d8009e15 	stw	zero,632(sp)
 320ab30:	d8009d15 	stw	zero,628(sp)
 320ab34:	d8009c15 	stw	zero,624(sp)
 320ab38:	0039883a 	mov	fp,zero
 320ab3c:	0025883a 	mov	r18,zero
 320ab40:	80800017 	ldw	r2,0(r16)
 320ab44:	11400003 	ldbu	r5,0(r2)
 320ab48:	00801384 	movi	r2,78
 320ab4c:	28fff544 	addi	r3,r5,-43
 320ab50:	18c03fcc 	andi	r3,r3,255
 320ab54:	10c07d36 	bltu	r2,r3,320ad4c <__svfscanf_r+0x960>
 320ab58:	18c5883a 	add	r2,r3,r3
 320ab5c:	1085883a 	add	r2,r2,r2
 320ab60:	00c0c874 	movhi	r3,801
 320ab64:	18eadd04 	addi	r3,r3,-21644
 320ab68:	10c5883a 	add	r2,r2,r3
 320ab6c:	11000017 	ldw	r4,0(r2)
 320ab70:	2000683a 	jmp	r4
 320ab74:	0320ad04 	movi	r12,-32076
 320ab78:	0320ad4c 	andi	r12,zero,33461
 320ab7c:	0320ad04 	movi	r12,-32076
 320ab80:	0320ae98 	cmpnei	r12,zero,-32070
 320ab84:	0320ad4c 	andi	r12,zero,33461
 320ab88:	0320aed0 	cmplti	r12,zero,-32069
 320ab8c:	0320af04 	movi	r12,-32068
 320ab90:	0320af04 	movi	r12,-32068
 320ab94:	0320af04 	movi	r12,-32068
 320ab98:	0320af04 	movi	r12,-32068
 320ab9c:	0320af04 	movi	r12,-32068
 320aba0:	0320af04 	movi	r12,-32068
 320aba4:	0320af04 	movi	r12,-32068
 320aba8:	0320af04 	movi	r12,-32068
 320abac:	0320af04 	movi	r12,-32068
 320abb0:	0320ad4c 	andi	r12,zero,33461
 320abb4:	0320ad4c 	andi	r12,zero,33461
 320abb8:	0320ad4c 	andi	r12,zero,33461
 320abbc:	0320ad4c 	andi	r12,zero,33461
 320abc0:	0320ad4c 	andi	r12,zero,33461
 320abc4:	0320ad4c 	andi	r12,zero,33461
 320abc8:	0320ad4c 	andi	r12,zero,33461
 320abcc:	0320af24 	muli	r12,zero,-32068
 320abd0:	0320ad4c 	andi	r12,zero,33461
 320abd4:	0320ad4c 	andi	r12,zero,33461
 320abd8:	0320ad4c 	andi	r12,zero,33461
 320abdc:	0320af34 	movhi	r12,33468
 320abe0:	0320afd0 	cmplti	r12,zero,-32065
 320abe4:	0320ad4c 	andi	r12,zero,33461
 320abe8:	0320ad4c 	andi	r12,zero,33461
 320abec:	0320afec 	andhi	r12,zero,33471
 320abf0:	0320ad4c 	andi	r12,zero,33461
 320abf4:	0320ad4c 	andi	r12,zero,33461
 320abf8:	0320ad4c 	andi	r12,zero,33461
 320abfc:	0320ad4c 	andi	r12,zero,33461
 320ac00:	0320b018 	cmpnei	r12,zero,-32064
 320ac04:	0320ad4c 	andi	r12,zero,33461
 320ac08:	0320ad4c 	andi	r12,zero,33461
 320ac0c:	0320ad4c 	andi	r12,zero,33461
 320ac10:	0320ad4c 	andi	r12,zero,33461
 320ac14:	0320ad4c 	andi	r12,zero,33461
 320ac18:	0320b06c 	andhi	r12,zero,33473
 320ac1c:	0320ad4c 	andi	r12,zero,33461
 320ac20:	0320ad4c 	andi	r12,zero,33461
 320ac24:	0320ad4c 	andi	r12,zero,33461
 320ac28:	0320ad4c 	andi	r12,zero,33461
 320ac2c:	0320b17c 	xorhi	r12,zero,33477
 320ac30:	0320ad4c 	andi	r12,zero,33461
 320ac34:	0320ad4c 	andi	r12,zero,33461
 320ac38:	0320ad4c 	andi	r12,zero,33461
 320ac3c:	0320ad4c 	andi	r12,zero,33461
 320ac40:	0320ad4c 	andi	r12,zero,33461
 320ac44:	0320ad4c 	andi	r12,zero,33461
 320ac48:	0320ad4c 	andi	r12,zero,33461
 320ac4c:	0320af24 	muli	r12,zero,-32068
 320ac50:	0320ad4c 	andi	r12,zero,33461
 320ac54:	0320ad4c 	andi	r12,zero,33461
 320ac58:	0320ad4c 	andi	r12,zero,33461
 320ac5c:	0320af34 	movhi	r12,33468
 320ac60:	0320afd0 	cmplti	r12,zero,-32065
 320ac64:	0320ad4c 	andi	r12,zero,33461
 320ac68:	0320ad4c 	andi	r12,zero,33461
 320ac6c:	0320afec 	andhi	r12,zero,33471
 320ac70:	0320ad4c 	andi	r12,zero,33461
 320ac74:	0320ad4c 	andi	r12,zero,33461
 320ac78:	0320ad4c 	andi	r12,zero,33461
 320ac7c:	0320ad4c 	andi	r12,zero,33461
 320ac80:	0320b018 	cmpnei	r12,zero,-32064
 320ac84:	0320ad4c 	andi	r12,zero,33461
 320ac88:	0320ad4c 	andi	r12,zero,33461
 320ac8c:	0320ad4c 	andi	r12,zero,33461
 320ac90:	0320ad4c 	andi	r12,zero,33461
 320ac94:	0320ad4c 	andi	r12,zero,33461
 320ac98:	0320b06c 	andhi	r12,zero,33473
 320ac9c:	0320ad4c 	andi	r12,zero,33461
 320aca0:	0320ad4c 	andi	r12,zero,33461
 320aca4:	0320ad4c 	andi	r12,zero,33461
 320aca8:	0320ad4c 	andi	r12,zero,33461
 320acac:	0320b17c 	xorhi	r12,zero,33477
 320acb0:	d900a317 	ldw	r4,652(sp)
 320acb4:	00805704 	movi	r2,348
 320acb8:	20ffffc4 	addi	r3,r4,-1
 320acbc:	10c18c2e 	bgeu	r2,r3,320b2f0 <__svfscanf_r+0xf04>
 320acc0:	00805744 	movi	r2,349
 320acc4:	257fa8c4 	addi	r21,r4,-349
 320acc8:	9c836014 	ori	r18,r19,3456
 320accc:	d880a315 	stw	r2,652(sp)
 320acd0:	0001a106 	br	320b358 <__svfscanf_r+0xf6c>
 320acd4:	b009883a 	mov	r4,r22
 320acd8:	800b883a 	mov	r5,r16
 320acdc:	32077100 	call	3207710 <__srefill_r>
 320ace0:	103eb226 	beq	r2,zero,320a7ac <__svfscanf_r+0x3c0>
 320ace4:	003e1606 	br	320a540 <__svfscanf_r+0x154>
 320ace8:	01000284 	movi	r4,10
 320acec:	0080c874 	movhi	r2,801
 320acf0:	1082d904 	addi	r2,r2,2916
 320acf4:	054000c4 	movi	r21,3
 320acf8:	d900a115 	stw	r4,644(sp)
 320acfc:	d880a015 	stw	r2,640(sp)
 320ad00:	003ea806 	br	320a7a4 <__svfscanf_r+0x3b8>
 320ad04:	a880200c 	andi	r2,r21,128
 320ad08:	10001026 	beq	r2,zero,320ad4c <__svfscanf_r+0x960>
 320ad0c:	00bfdfc4 	movi	r2,-129
 320ad10:	a8aa703a 	and	r21,r21,r2
 320ad14:	b9400005 	stb	r5,0(r23)
 320ad18:	bdc00044 	addi	r23,r23,1
 320ad1c:	80c00117 	ldw	r3,4(r16)
 320ad20:	8c400044 	addi	r17,r17,1
 320ad24:	18bfffc4 	addi	r2,r3,-1
 320ad28:	80800115 	stw	r2,4(r16)
 320ad2c:	0080610e 	bge	zero,r2,320aeb4 <__svfscanf_r+0xac8>
 320ad30:	80800017 	ldw	r2,0(r16)
 320ad34:	10800044 	addi	r2,r2,1
 320ad38:	80800015 	stw	r2,0(r16)
 320ad3c:	d880a317 	ldw	r2,652(sp)
 320ad40:	10bfffc4 	addi	r2,r2,-1
 320ad44:	d880a315 	stw	r2,652(sp)
 320ad48:	103f7d1e 	bne	r2,zero,320ab40 <__svfscanf_r+0x754>
 320ad4c:	d8c09e17 	ldw	r3,632(sp)
 320ad50:	18000226 	beq	r3,zero,320ad5c <__svfscanf_r+0x970>
 320ad54:	00bfbfc4 	movi	r2,-257
 320ad58:	a8aa703a 	and	r21,r21,r2
 320ad5c:	90ffffc4 	addi	r3,r18,-1
 320ad60:	00800044 	movi	r2,1
 320ad64:	10c0cd2e 	bgeu	r2,r3,320b09c <__svfscanf_r+0xcb0>
 320ad68:	e1003fcc 	andi	r4,fp,255
 320ad6c:	2100201c 	xori	r4,r4,128
 320ad70:	213fe004 	addi	r4,r4,-128
 320ad74:	20ffffc4 	addi	r3,r4,-1
 320ad78:	00800184 	movi	r2,6
 320ad7c:	10c01736 	bltu	r2,r3,320addc <__svfscanf_r+0x9f0>
 320ad80:	00c00084 	movi	r3,2
 320ad84:	1900880e 	bge	r3,r4,320afa8 <__svfscanf_r+0xbbc>
 320ad88:	008000c4 	movi	r2,3
 320ad8c:	1100130e 	bge	r2,r4,320addc <__svfscanf_r+0x9f0>
 320ad90:	e4ffffc4 	addi	r19,fp,-1
 320ad94:	b825883a 	mov	r18,r23
 320ad98:	94bfffc4 	addi	r18,r18,-1
 320ad9c:	91400007 	ldb	r5,0(r18)
 320ada0:	b009883a 	mov	r4,r22
 320ada4:	800d883a 	mov	r6,r16
 320ada8:	32111840 	call	3211184 <_ungetc_r>
 320adac:	9cffffc4 	addi	r19,r19,-1
 320adb0:	98c03fcc 	andi	r3,r19,255
 320adb4:	18c0201c 	xori	r3,r3,128
 320adb8:	18ffe004 	addi	r3,r3,-128
 320adbc:	00800084 	movi	r2,2
 320adc0:	18bff51e 	bne	r3,r2,320ad98 <__svfscanf_r+0x9ac>
 320adc4:	e0bfff04 	addi	r2,fp,-4
 320adc8:	10803fcc 	andi	r2,r2,255
 320adcc:	b887c83a 	sub	r3,r23,r2
 320add0:	8885c83a 	sub	r2,r17,r2
 320add4:	147fffc4 	addi	r17,r2,-1
 320add8:	1dffffc4 	addi	r23,r3,-1
 320addc:	a880400c 	andi	r2,r21,256
 320ade0:	10001226 	beq	r2,zero,320ae2c <__svfscanf_r+0xa40>
 320ade4:	a881000c 	andi	r2,r21,1024
 320ade8:	1000651e 	bne	r2,zero,320af80 <__svfscanf_r+0xb94>
 320adec:	bdffffc4 	addi	r23,r23,-1
 320adf0:	b9400007 	ldb	r5,0(r23)
 320adf4:	00801944 	movi	r2,101
 320adf8:	8c7fffc4 	addi	r17,r17,-1
 320adfc:	28800826 	beq	r5,r2,320ae20 <__svfscanf_r+0xa34>
 320ae00:	00801144 	movi	r2,69
 320ae04:	28800626 	beq	r5,r2,320ae20 <__svfscanf_r+0xa34>
 320ae08:	bdffffc4 	addi	r23,r23,-1
 320ae0c:	b009883a 	mov	r4,r22
 320ae10:	800d883a 	mov	r6,r16
 320ae14:	32111840 	call	3211184 <_ungetc_r>
 320ae18:	b9400007 	ldb	r5,0(r23)
 320ae1c:	8c7fffc4 	addi	r17,r17,-1
 320ae20:	b009883a 	mov	r4,r22
 320ae24:	800d883a 	mov	r6,r16
 320ae28:	32111840 	call	3211184 <_ungetc_r>
 320ae2c:	a880040c 	andi	r2,r21,16
 320ae30:	103d811e 	bne	r2,zero,320a438 <__svfscanf_r+0x4c>
 320ae34:	a8c1800c 	andi	r3,r21,1536
 320ae38:	00810004 	movi	r2,1024
 320ae3c:	b8000005 	stb	zero,0(r23)
 320ae40:	1880bb26 	beq	r3,r2,320b130 <__svfscanf_r+0xd44>
 320ae44:	d8809d17 	ldw	r2,628(sp)
 320ae48:	1000a61e 	bne	r2,zero,320b0e4 <__svfscanf_r+0xcf8>
 320ae4c:	d940a617 	ldw	r5,664(sp)
 320ae50:	b009883a 	mov	r4,r22
 320ae54:	000d883a 	mov	r6,zero
 320ae58:	320efc00 	call	320efc0 <_strtod_r>
 320ae5c:	a900004c 	andi	r4,r21,1
 320ae60:	2009003a 	cmpeq	r4,r4,zero
 320ae64:	1025883a 	mov	r18,r2
 320ae68:	1827883a 	mov	r19,r3
 320ae6c:	2000951e 	bne	r4,zero,320b0c4 <__svfscanf_r+0xcd8>
 320ae70:	d8c0a417 	ldw	r3,656(sp)
 320ae74:	18800017 	ldw	r2,0(r3)
 320ae78:	1d400104 	addi	r21,r3,4
 320ae7c:	14c00115 	stw	r19,4(r2)
 320ae80:	14800015 	stw	r18,0(r2)
 320ae84:	d8c0a217 	ldw	r3,648(sp)
 320ae88:	dd40a415 	stw	r21,656(sp)
 320ae8c:	18c00044 	addi	r3,r3,1
 320ae90:	d8c0a215 	stw	r3,648(sp)
 320ae94:	003d6806 	br	320a438 <__svfscanf_r+0x4c>
 320ae98:	a880800c 	andi	r2,r21,512
 320ae9c:	103fab26 	beq	r2,zero,320ad4c <__svfscanf_r+0x960>
 320aea0:	d9009e17 	ldw	r4,632(sp)
 320aea4:	00bf5fc4 	movi	r2,-641
 320aea8:	a8aa703a 	and	r21,r21,r2
 320aeac:	d9009f15 	stw	r4,636(sp)
 320aeb0:	003f9806 	br	320ad14 <__svfscanf_r+0x928>
 320aeb4:	b009883a 	mov	r4,r22
 320aeb8:	800b883a 	mov	r5,r16
 320aebc:	d980a715 	stw	r6,668(sp)
 320aec0:	32077100 	call	3207710 <__srefill_r>
 320aec4:	d980a717 	ldw	r6,668(sp)
 320aec8:	103f9c26 	beq	r2,zero,320ad3c <__svfscanf_r+0x950>
 320aecc:	003f9f06 	br	320ad4c <__svfscanf_r+0x960>
 320aed0:	a880400c 	andi	r2,r21,256
 320aed4:	10000b26 	beq	r2,zero,320af04 <__svfscanf_r+0xb18>
 320aed8:	00bfdfc4 	movi	r2,-129
 320aedc:	a8aa703a 	and	r21,r21,r2
 320aee0:	d8809e17 	ldw	r2,632(sp)
 320aee4:	10800044 	addi	r2,r2,1
 320aee8:	d8809e15 	stw	r2,632(sp)
 320aeec:	303f8b26 	beq	r6,zero,320ad1c <__svfscanf_r+0x930>
 320aef0:	d8c0a317 	ldw	r3,652(sp)
 320aef4:	31bfffc4 	addi	r6,r6,-1
 320aef8:	18c00044 	addi	r3,r3,1
 320aefc:	d8c0a315 	stw	r3,652(sp)
 320af00:	003f8606 	br	320ad1c <__svfscanf_r+0x930>
 320af04:	e0803fcc 	andi	r2,fp,255
 320af08:	1080201c 	xori	r2,r2,128
 320af0c:	10bfe004 	addi	r2,r2,-128
 320af10:	9085883a 	add	r2,r18,r2
 320af14:	103f8d1e 	bne	r2,zero,320ad4c <__svfscanf_r+0x960>
 320af18:	00bf9fc4 	movi	r2,-385
 320af1c:	a8aa703a 	and	r21,r21,r2
 320af20:	003f7c06 	br	320ad14 <__svfscanf_r+0x928>
 320af24:	00800044 	movi	r2,1
 320af28:	90bf881e 	bne	r18,r2,320ad4c <__svfscanf_r+0x960>
 320af2c:	04800084 	movi	r18,2
 320af30:	003f7806 	br	320ad14 <__svfscanf_r+0x928>
 320af34:	a8c1400c 	andi	r3,r21,1280
 320af38:	00810004 	movi	r2,1024
 320af3c:	18800426 	beq	r3,r2,320af50 <__svfscanf_r+0xb64>
 320af40:	a884703a 	and	r2,r21,r2
 320af44:	103f8126 	beq	r2,zero,320ad4c <__svfscanf_r+0x960>
 320af48:	d8809e17 	ldw	r2,632(sp)
 320af4c:	103f8326 	beq	r2,zero,320ad5c <__svfscanf_r+0x970>
 320af50:	a880800c 	andi	r2,r21,512
 320af54:	1000051e 	bne	r2,zero,320af6c <__svfscanf_r+0xb80>
 320af58:	d8c09e17 	ldw	r3,632(sp)
 320af5c:	d9009f17 	ldw	r4,636(sp)
 320af60:	ddc09c15 	stw	r23,624(sp)
 320af64:	1907c83a 	sub	r3,r3,r4
 320af68:	d8c09d15 	stw	r3,628(sp)
 320af6c:	00be7fc4 	movi	r2,-1537
 320af70:	a884703a 	and	r2,r21,r2
 320af74:	15406014 	ori	r21,r2,384
 320af78:	d8009e15 	stw	zero,632(sp)
 320af7c:	003f6506 	br	320ad14 <__svfscanf_r+0x928>
 320af80:	d900a617 	ldw	r4,664(sp)
 320af84:	25fd4e2e 	bgeu	r4,r23,320a4c0 <__svfscanf_r+0xd4>
 320af88:	bdffffc4 	addi	r23,r23,-1
 320af8c:	b9400007 	ldb	r5,0(r23)
 320af90:	b009883a 	mov	r4,r22
 320af94:	800d883a 	mov	r6,r16
 320af98:	32111840 	call	3211184 <_ungetc_r>
 320af9c:	d880a617 	ldw	r2,664(sp)
 320afa0:	15fff936 	bltu	r2,r23,320af88 <__svfscanf_r+0xb9c>
 320afa4:	003d4606 	br	320a4c0 <__svfscanf_r+0xd4>
 320afa8:	d900a617 	ldw	r4,664(sp)
 320afac:	25fd442e 	bgeu	r4,r23,320a4c0 <__svfscanf_r+0xd4>
 320afb0:	bdffffc4 	addi	r23,r23,-1
 320afb4:	b9400007 	ldb	r5,0(r23)
 320afb8:	b009883a 	mov	r4,r22
 320afbc:	800d883a 	mov	r6,r16
 320afc0:	32111840 	call	3211184 <_ungetc_r>
 320afc4:	d8c0a617 	ldw	r3,664(sp)
 320afc8:	1dfff936 	bltu	r3,r23,320afb0 <__svfscanf_r+0xbc4>
 320afcc:	003d3c06 	br	320a4c0 <__svfscanf_r+0xd4>
 320afd0:	e0c03fcc 	andi	r3,fp,255
 320afd4:	18c0201c 	xori	r3,r3,128
 320afd8:	18ffe004 	addi	r3,r3,-128
 320afdc:	00800084 	movi	r2,2
 320afe0:	18bf5a1e 	bne	r3,r2,320ad4c <__svfscanf_r+0x960>
 320afe4:	070000c4 	movi	fp,3
 320afe8:	003f4a06 	br	320ad14 <__svfscanf_r+0x928>
 320afec:	e0c03fcc 	andi	r3,fp,255
 320aff0:	18c0201c 	xori	r3,r3,128
 320aff4:	18ffe004 	addi	r3,r3,-128
 320aff8:	1800231e 	bne	r3,zero,320b088 <__svfscanf_r+0xc9c>
 320affc:	a8c1c00c 	andi	r3,r21,1792
 320b000:	0081c004 	movi	r2,1792
 320b004:	18bf511e 	bne	r3,r2,320ad4c <__svfscanf_r+0x960>
 320b008:	00be1fc4 	movi	r2,-1921
 320b00c:	a8aa703a 	and	r21,r21,r2
 320b010:	07000044 	movi	fp,1
 320b014:	003f3f06 	br	320ad14 <__svfscanf_r+0x928>
 320b018:	9000101e 	bne	r18,zero,320b05c <__svfscanf_r+0xc70>
 320b01c:	a8c1c00c 	andi	r3,r21,1792
 320b020:	0081c004 	movi	r2,1792
 320b024:	18800926 	beq	r3,r2,320b04c <__svfscanf_r+0xc60>
 320b028:	e0c03fcc 	andi	r3,fp,255
 320b02c:	18c0201c 	xori	r3,r3,128
 320b030:	18ffe004 	addi	r3,r3,-128
 320b034:	00800044 	movi	r2,1
 320b038:	18800226 	beq	r3,r2,320b044 <__svfscanf_r+0xc58>
 320b03c:	00800104 	movi	r2,4
 320b040:	18bf421e 	bne	r3,r2,320ad4c <__svfscanf_r+0x960>
 320b044:	e7000044 	addi	fp,fp,1
 320b048:	003f3206 	br	320ad14 <__svfscanf_r+0x928>
 320b04c:	00be1fc4 	movi	r2,-1921
 320b050:	a8aa703a 	and	r21,r21,r2
 320b054:	04800044 	movi	r18,1
 320b058:	003f2e06 	br	320ad14 <__svfscanf_r+0x928>
 320b05c:	00800084 	movi	r2,2
 320b060:	90bff11e 	bne	r18,r2,320b028 <__svfscanf_r+0xc3c>
 320b064:	048000c4 	movi	r18,3
 320b068:	003f2a06 	br	320ad14 <__svfscanf_r+0x928>
 320b06c:	e0c03fcc 	andi	r3,fp,255
 320b070:	18c0201c 	xori	r3,r3,128
 320b074:	18ffe004 	addi	r3,r3,-128
 320b078:	00800184 	movi	r2,6
 320b07c:	18bf331e 	bne	r3,r2,320ad4c <__svfscanf_r+0x960>
 320b080:	070001c4 	movi	fp,7
 320b084:	003f2306 	br	320ad14 <__svfscanf_r+0x928>
 320b088:	008000c4 	movi	r2,3
 320b08c:	18bfed26 	beq	r3,r2,320b044 <__svfscanf_r+0xc58>
 320b090:	00800144 	movi	r2,5
 320b094:	18bfeb26 	beq	r3,r2,320b044 <__svfscanf_r+0xc58>
 320b098:	003f2c06 	br	320ad4c <__svfscanf_r+0x960>
 320b09c:	d900a617 	ldw	r4,664(sp)
 320b0a0:	25fd072e 	bgeu	r4,r23,320a4c0 <__svfscanf_r+0xd4>
 320b0a4:	bdffffc4 	addi	r23,r23,-1
 320b0a8:	b9400007 	ldb	r5,0(r23)
 320b0ac:	b009883a 	mov	r4,r22
 320b0b0:	800d883a 	mov	r6,r16
 320b0b4:	32111840 	call	3211184 <_ungetc_r>
 320b0b8:	d880a617 	ldw	r2,664(sp)
 320b0bc:	15fff936 	bltu	r2,r23,320b0a4 <__svfscanf_r+0xcb8>
 320b0c0:	003cff06 	br	320a4c0 <__svfscanf_r+0xd4>
 320b0c4:	a880008c 	andi	r2,r21,2
 320b0c8:	10002026 	beq	r2,zero,320b14c <__svfscanf_r+0xd60>
 320b0cc:	d900a417 	ldw	r4,656(sp)
 320b0d0:	20800017 	ldw	r2,0(r4)
 320b0d4:	25400104 	addi	r21,r4,4
 320b0d8:	10c00115 	stw	r3,4(r2)
 320b0dc:	14800015 	stw	r18,0(r2)
 320b0e0:	003f6806 	br	320ae84 <__svfscanf_r+0xa98>
 320b0e4:	d8c09c17 	ldw	r3,624(sp)
 320b0e8:	b009883a 	mov	r4,r22
 320b0ec:	000d883a 	mov	r6,zero
 320b0f0:	19400044 	addi	r5,r3,1
 320b0f4:	01c00284 	movi	r7,10
 320b0f8:	32105e40 	call	32105e4 <_strtol_r>
 320b0fc:	d9009d17 	ldw	r4,628(sp)
 320b100:	110dc83a 	sub	r6,r2,r4
 320b104:	d8c0a617 	ldw	r3,664(sp)
 320b108:	d9009c17 	ldw	r4,624(sp)
 320b10c:	188054c4 	addi	r2,r3,339
 320b110:	20800236 	bltu	r4,r2,320b11c <__svfscanf_r+0xd30>
 320b114:	18805484 	addi	r2,r3,338
 320b118:	d8809c15 	stw	r2,624(sp)
 320b11c:	d9009c17 	ldw	r4,624(sp)
 320b120:	0140c974 	movhi	r5,805
 320b124:	2978b504 	addi	r5,r5,-7468
 320b128:	32079c00 	call	32079c0 <sprintf>
 320b12c:	003f4706 	br	320ae4c <__svfscanf_r+0xa60>
 320b130:	d8c09e17 	ldw	r3,632(sp)
 320b134:	d9009f17 	ldw	r4,636(sp)
 320b138:	1905c83a 	sub	r2,r3,r4
 320b13c:	103f4326 	beq	r2,zero,320ae4c <__svfscanf_r+0xa60>
 320b140:	008dc83a 	sub	r6,zero,r2
 320b144:	ddc09c15 	stw	r23,624(sp)
 320b148:	003fee06 	br	320b104 <__svfscanf_r+0xd18>
 320b14c:	d880a417 	ldw	r2,656(sp)
 320b150:	9009883a 	mov	r4,r18
 320b154:	180b883a 	mov	r5,r3
 320b158:	15c00017 	ldw	r23,0(r2)
 320b15c:	15400104 	addi	r21,r2,4
 320b160:	320edc40 	call	320edc4 <__isnand>
 320b164:	10021c1e 	bne	r2,zero,320b9d8 <__svfscanf_r+0x15ec>
 320b168:	980b883a 	mov	r5,r19
 320b16c:	9009883a 	mov	r4,r18
 320b170:	3213dc80 	call	3213dc8 <__truncdfsf2>
 320b174:	b8800015 	stw	r2,0(r23)
 320b178:	003f4206 	br	320ae84 <__svfscanf_r+0xa98>
 320b17c:	e0c03fcc 	andi	r3,fp,255
 320b180:	18c0201c 	xori	r3,r3,128
 320b184:	18ffe004 	addi	r3,r3,-128
 320b188:	008001c4 	movi	r2,7
 320b18c:	18beef1e 	bne	r3,r2,320ad4c <__svfscanf_r+0x960>
 320b190:	07000204 	movi	fp,8
 320b194:	003edf06 	br	320ad14 <__svfscanf_r+0x928>
 320b198:	d900a317 	ldw	r4,652(sp)
 320b19c:	208002a4 	muli	r2,r4,10
 320b1a0:	1145883a 	add	r2,r2,r5
 320b1a4:	10bff404 	addi	r2,r2,-48
 320b1a8:	d880a315 	stw	r2,652(sp)
 320b1ac:	003ceb06 	br	320a55c <__svfscanf_r+0x170>
 320b1b0:	9880040c 	andi	r2,r19,16
 320b1b4:	10001426 	beq	r2,zero,320b208 <__svfscanf_r+0xe1c>
 320b1b8:	0027883a 	mov	r19,zero
 320b1bc:	00000906 	br	320b1e4 <__svfscanf_r+0xdf8>
 320b1c0:	80c00117 	ldw	r3,4(r16)
 320b1c4:	d880a317 	ldw	r2,652(sp)
 320b1c8:	29800044 	addi	r6,r5,1
 320b1cc:	18ffffc4 	addi	r3,r3,-1
 320b1d0:	9cc00044 	addi	r19,r19,1
 320b1d4:	81800015 	stw	r6,0(r16)
 320b1d8:	80c00115 	stw	r3,4(r16)
 320b1dc:	14fdf726 	beq	r2,r19,320a9bc <__svfscanf_r+0x5d0>
 320b1e0:	00c02c0e 	bge	zero,r3,320b294 <__svfscanf_r+0xea8>
 320b1e4:	81400017 	ldw	r5,0(r16)
 320b1e8:	90800017 	ldw	r2,0(r18)
 320b1ec:	28c00003 	ldbu	r3,0(r5)
 320b1f0:	1887883a 	add	r3,r3,r2
 320b1f4:	19000003 	ldbu	r4,0(r3)
 320b1f8:	2100020c 	andi	r4,r4,8
 320b1fc:	203ff026 	beq	r4,zero,320b1c0 <__svfscanf_r+0xdd4>
 320b200:	8ce3883a 	add	r17,r17,r19
 320b204:	003c8c06 	br	320a438 <__svfscanf_r+0x4c>
 320b208:	d8c0a417 	ldw	r3,656(sp)
 320b20c:	1d400017 	ldw	r21,0(r3)
 320b210:	a827883a 	mov	r19,r21
 320b214:	00000e06 	br	320b250 <__svfscanf_r+0xe64>
 320b218:	80800117 	ldw	r2,4(r16)
 320b21c:	d900a317 	ldw	r4,652(sp)
 320b220:	29800044 	addi	r6,r5,1
 320b224:	10ffffc4 	addi	r3,r2,-1
 320b228:	213fffc4 	addi	r4,r4,-1
 320b22c:	d900a315 	stw	r4,652(sp)
 320b230:	80c00115 	stw	r3,4(r16)
 320b234:	28800003 	ldbu	r2,0(r5)
 320b238:	98800005 	stb	r2,0(r19)
 320b23c:	81800015 	stw	r6,0(r16)
 320b240:	9cc00044 	addi	r19,r19,1
 320b244:	20000926 	beq	r4,zero,320b26c <__svfscanf_r+0xe80>
 320b248:	80800117 	ldw	r2,4(r16)
 320b24c:	0080170e 	bge	zero,r2,320b2ac <__svfscanf_r+0xec0>
 320b250:	81400017 	ldw	r5,0(r16)
 320b254:	90800017 	ldw	r2,0(r18)
 320b258:	28c00003 	ldbu	r3,0(r5)
 320b25c:	1887883a 	add	r3,r3,r2
 320b260:	19000003 	ldbu	r4,0(r3)
 320b264:	2100020c 	andi	r4,r4,8
 320b268:	203feb26 	beq	r4,zero,320b218 <__svfscanf_r+0xe2c>
 320b26c:	9d45c83a 	sub	r2,r19,r21
 320b270:	d8c0a217 	ldw	r3,648(sp)
 320b274:	88a3883a 	add	r17,r17,r2
 320b278:	d880a417 	ldw	r2,656(sp)
 320b27c:	18c00044 	addi	r3,r3,1
 320b280:	d8c0a215 	stw	r3,648(sp)
 320b284:	10800104 	addi	r2,r2,4
 320b288:	d880a415 	stw	r2,656(sp)
 320b28c:	98000005 	stb	zero,0(r19)
 320b290:	003c6906 	br	320a438 <__svfscanf_r+0x4c>
 320b294:	b009883a 	mov	r4,r22
 320b298:	800b883a 	mov	r5,r16
 320b29c:	32077100 	call	3207710 <__srefill_r>
 320b2a0:	103fd026 	beq	r2,zero,320b1e4 <__svfscanf_r+0xdf8>
 320b2a4:	8ce3883a 	add	r17,r17,r19
 320b2a8:	003c6306 	br	320a438 <__svfscanf_r+0x4c>
 320b2ac:	b009883a 	mov	r4,r22
 320b2b0:	800b883a 	mov	r5,r16
 320b2b4:	32077100 	call	3207710 <__srefill_r>
 320b2b8:	103fe526 	beq	r2,zero,320b250 <__svfscanf_r+0xe64>
 320b2bc:	003feb06 	br	320b26c <__svfscanf_r+0xe80>
 320b2c0:	d900a317 	ldw	r4,652(sp)
 320b2c4:	9d41e014 	ori	r21,r19,1920
 320b2c8:	2000821e 	bne	r4,zero,320b4d4 <__svfscanf_r+0x10e8>
 320b2cc:	d8c04404 	addi	r3,sp,272
 320b2d0:	182f883a 	mov	r23,r3
 320b2d4:	0039883a 	mov	fp,zero
 320b2d8:	d8c0a615 	stw	r3,664(sp)
 320b2dc:	d8009c15 	stw	zero,624(sp)
 320b2e0:	d8009d15 	stw	zero,628(sp)
 320b2e4:	d8009f15 	stw	zero,636(sp)
 320b2e8:	d8009e15 	stw	zero,632(sp)
 320b2ec:	003e9e06 	br	320ad68 <__svfscanf_r+0x97c>
 320b2f0:	d900a317 	ldw	r4,652(sp)
 320b2f4:	9c836014 	ori	r18,r19,3456
 320b2f8:	2000161e 	bne	r4,zero,320b354 <__svfscanf_r+0xf68>
 320b2fc:	d8804404 	addi	r2,sp,272
 320b300:	d880a615 	stw	r2,664(sp)
 320b304:	002f883a 	mov	r23,zero
 320b308:	1027883a 	mov	r19,r2
 320b30c:	9080400c 	andi	r2,r18,256
 320b310:	10000926 	beq	r2,zero,320b338 <__svfscanf_r+0xf4c>
 320b314:	d8c0a617 	ldw	r3,664(sp)
 320b318:	1cc0052e 	bgeu	r3,r19,320b330 <__svfscanf_r+0xf44>
 320b31c:	9cffffc4 	addi	r19,r19,-1
 320b320:	99400007 	ldb	r5,0(r19)
 320b324:	b009883a 	mov	r4,r22
 320b328:	800d883a 	mov	r6,r16
 320b32c:	32111840 	call	3211184 <_ungetc_r>
 320b330:	d900a617 	ldw	r4,664(sp)
 320b334:	24fc6226 	beq	r4,r19,320a4c0 <__svfscanf_r+0xd4>
 320b338:	9080040c 	andi	r2,r18,16
 320b33c:	10006726 	beq	r2,zero,320b4dc <__svfscanf_r+0x10f0>
 320b340:	d8c0a617 	ldw	r3,664(sp)
 320b344:	98c5c83a 	sub	r2,r19,r3
 320b348:	b885883a 	add	r2,r23,r2
 320b34c:	88a3883a 	add	r17,r17,r2
 320b350:	003c3906 	br	320a438 <__svfscanf_r+0x4c>
 320b354:	002b883a 	mov	r21,zero
 320b358:	d8c04404 	addi	r3,sp,272
 320b35c:	d8c0a615 	stw	r3,664(sp)
 320b360:	002f883a 	mov	r23,zero
 320b364:	1827883a 	mov	r19,r3
 320b368:	81800017 	ldw	r6,0(r16)
 320b36c:	00c01344 	movi	r3,77
 320b370:	31400003 	ldbu	r5,0(r6)
 320b374:	28bff544 	addi	r2,r5,-43
 320b378:	10803fcc 	andi	r2,r2,255
 320b37c:	18bfe336 	bltu	r3,r2,320b30c <__svfscanf_r+0xf20>
 320b380:	1085883a 	add	r2,r2,r2
 320b384:	1085883a 	add	r2,r2,r2
 320b388:	00c0c874 	movhi	r3,801
 320b38c:	18ece704 	addi	r3,r3,-19556
 320b390:	10c5883a 	add	r2,r2,r3
 320b394:	11000017 	ldw	r4,0(r2)
 320b398:	2000683a 	jmp	r4
 320b39c:	0320b530 	cmpltui	r12,zero,33492
 320b3a0:	0320b30c 	andi	r12,zero,33484
 320b3a4:	0320b530 	cmpltui	r12,zero,33492
 320b3a8:	0320b30c 	andi	r12,zero,33484
 320b3ac:	0320b30c 	andi	r12,zero,33484
 320b3b0:	0320b574 	movhi	r12,33493
 320b3b4:	0320b670 	cmpltui	r12,zero,33497
 320b3b8:	0320b670 	cmpltui	r12,zero,33497
 320b3bc:	0320b670 	cmpltui	r12,zero,33497
 320b3c0:	0320b670 	cmpltui	r12,zero,33497
 320b3c4:	0320b670 	cmpltui	r12,zero,33497
 320b3c8:	0320b670 	cmpltui	r12,zero,33497
 320b3cc:	0320b670 	cmpltui	r12,zero,33497
 320b3d0:	0320b698 	cmpnei	r12,zero,-32038
 320b3d4:	0320b698 	cmpnei	r12,zero,-32038
 320b3d8:	0320b30c 	andi	r12,zero,33484
 320b3dc:	0320b30c 	andi	r12,zero,33484
 320b3e0:	0320b30c 	andi	r12,zero,33484
 320b3e4:	0320b30c 	andi	r12,zero,33484
 320b3e8:	0320b30c 	andi	r12,zero,33484
 320b3ec:	0320b30c 	andi	r12,zero,33484
 320b3f0:	0320b30c 	andi	r12,zero,33484
 320b3f4:	0320b6c8 	cmpgei	r12,zero,-32037
 320b3f8:	0320b6c8 	cmpgei	r12,zero,-32037
 320b3fc:	0320b6c8 	cmpgei	r12,zero,-32037
 320b400:	0320b6c8 	cmpgei	r12,zero,-32037
 320b404:	0320b6c8 	cmpgei	r12,zero,-32037
 320b408:	0320b6c8 	cmpgei	r12,zero,-32037
 320b40c:	0320b30c 	andi	r12,zero,33484
 320b410:	0320b30c 	andi	r12,zero,33484
 320b414:	0320b30c 	andi	r12,zero,33484
 320b418:	0320b30c 	andi	r12,zero,33484
 320b41c:	0320b30c 	andi	r12,zero,33484
 320b420:	0320b30c 	andi	r12,zero,33484
 320b424:	0320b30c 	andi	r12,zero,33484
 320b428:	0320b30c 	andi	r12,zero,33484
 320b42c:	0320b30c 	andi	r12,zero,33484
 320b430:	0320b30c 	andi	r12,zero,33484
 320b434:	0320b30c 	andi	r12,zero,33484
 320b438:	0320b30c 	andi	r12,zero,33484
 320b43c:	0320b30c 	andi	r12,zero,33484
 320b440:	0320b30c 	andi	r12,zero,33484
 320b444:	0320b30c 	andi	r12,zero,33484
 320b448:	0320b30c 	andi	r12,zero,33484
 320b44c:	0320b30c 	andi	r12,zero,33484
 320b450:	0320b6d8 	cmpnei	r12,zero,-32037
 320b454:	0320b30c 	andi	r12,zero,33484
 320b458:	0320b30c 	andi	r12,zero,33484
 320b45c:	0320b30c 	andi	r12,zero,33484
 320b460:	0320b30c 	andi	r12,zero,33484
 320b464:	0320b30c 	andi	r12,zero,33484
 320b468:	0320b30c 	andi	r12,zero,33484
 320b46c:	0320b30c 	andi	r12,zero,33484
 320b470:	0320b30c 	andi	r12,zero,33484
 320b474:	0320b6c8 	cmpgei	r12,zero,-32037
 320b478:	0320b6c8 	cmpgei	r12,zero,-32037
 320b47c:	0320b6c8 	cmpgei	r12,zero,-32037
 320b480:	0320b6c8 	cmpgei	r12,zero,-32037
 320b484:	0320b6c8 	cmpgei	r12,zero,-32037
 320b488:	0320b6c8 	cmpgei	r12,zero,-32037
 320b48c:	0320b30c 	andi	r12,zero,33484
 320b490:	0320b30c 	andi	r12,zero,33484
 320b494:	0320b30c 	andi	r12,zero,33484
 320b498:	0320b30c 	andi	r12,zero,33484
 320b49c:	0320b30c 	andi	r12,zero,33484
 320b4a0:	0320b30c 	andi	r12,zero,33484
 320b4a4:	0320b30c 	andi	r12,zero,33484
 320b4a8:	0320b30c 	andi	r12,zero,33484
 320b4ac:	0320b30c 	andi	r12,zero,33484
 320b4b0:	0320b30c 	andi	r12,zero,33484
 320b4b4:	0320b30c 	andi	r12,zero,33484
 320b4b8:	0320b30c 	andi	r12,zero,33484
 320b4bc:	0320b30c 	andi	r12,zero,33484
 320b4c0:	0320b30c 	andi	r12,zero,33484
 320b4c4:	0320b30c 	andi	r12,zero,33484
 320b4c8:	0320b30c 	andi	r12,zero,33484
 320b4cc:	0320b30c 	andi	r12,zero,33484
 320b4d0:	0320b6d8 	cmpnei	r12,zero,-32037
 320b4d4:	000d883a 	mov	r6,zero
 320b4d8:	003d9006 	br	320ab1c <__svfscanf_r+0x730>
 320b4dc:	98000005 	stb	zero,0(r19)
 320b4e0:	d8c0a017 	ldw	r3,640(sp)
 320b4e4:	d940a617 	ldw	r5,664(sp)
 320b4e8:	d9c0a117 	ldw	r7,644(sp)
 320b4ec:	b009883a 	mov	r4,r22
 320b4f0:	000d883a 	mov	r6,zero
 320b4f4:	183ee83a 	callr	r3
 320b4f8:	1007883a 	mov	r3,r2
 320b4fc:	9080080c 	andi	r2,r18,32
 320b500:	10004d1e 	bne	r2,zero,320b638 <__svfscanf_r+0x124c>
 320b504:	9080010c 	andi	r2,r18,4
 320b508:	10003426 	beq	r2,zero,320b5dc <__svfscanf_r+0x11f0>
 320b50c:	d900a417 	ldw	r4,656(sp)
 320b510:	20800017 	ldw	r2,0(r4)
 320b514:	21000104 	addi	r4,r4,4
 320b518:	d900a415 	stw	r4,656(sp)
 320b51c:	10c0000d 	sth	r3,0(r2)
 320b520:	d880a217 	ldw	r2,648(sp)
 320b524:	10800044 	addi	r2,r2,1
 320b528:	d880a215 	stw	r2,648(sp)
 320b52c:	003f8406 	br	320b340 <__svfscanf_r+0xf54>
 320b530:	9080200c 	andi	r2,r18,128
 320b534:	103f7526 	beq	r2,zero,320b30c <__svfscanf_r+0xf20>
 320b538:	00bfdfc4 	movi	r2,-129
 320b53c:	90a4703a 	and	r18,r18,r2
 320b540:	99400005 	stb	r5,0(r19)
 320b544:	9cc00044 	addi	r19,r19,1
 320b548:	80c00117 	ldw	r3,4(r16)
 320b54c:	18ffffc4 	addi	r3,r3,-1
 320b550:	80c00115 	stw	r3,4(r16)
 320b554:	00c0130e 	bge	zero,r3,320b5a4 <__svfscanf_r+0x11b8>
 320b558:	31800044 	addi	r6,r6,1
 320b55c:	81800015 	stw	r6,0(r16)
 320b560:	d880a317 	ldw	r2,652(sp)
 320b564:	10bfffc4 	addi	r2,r2,-1
 320b568:	d880a315 	stw	r2,652(sp)
 320b56c:	103f7e1e 	bne	r2,zero,320b368 <__svfscanf_r+0xf7c>
 320b570:	003f6606 	br	320b30c <__svfscanf_r+0xf20>
 320b574:	9082000c 	andi	r2,r18,2048
 320b578:	103ff126 	beq	r2,zero,320b540 <__svfscanf_r+0x1154>
 320b57c:	d8c0a117 	ldw	r3,644(sp)
 320b580:	1800031e 	bne	r3,zero,320b590 <__svfscanf_r+0x11a4>
 320b584:	01000204 	movi	r4,8
 320b588:	94808014 	ori	r18,r18,512
 320b58c:	d900a115 	stw	r4,644(sp)
 320b590:	9081000c 	andi	r2,r18,1024
 320b594:	10000826 	beq	r2,zero,320b5b8 <__svfscanf_r+0x11cc>
 320b598:	00be9fc4 	movi	r2,-1409
 320b59c:	90a4703a 	and	r18,r18,r2
 320b5a0:	003fe706 	br	320b540 <__svfscanf_r+0x1154>
 320b5a4:	b009883a 	mov	r4,r22
 320b5a8:	800b883a 	mov	r5,r16
 320b5ac:	32077100 	call	3207710 <__srefill_r>
 320b5b0:	103feb26 	beq	r2,zero,320b560 <__svfscanf_r+0x1174>
 320b5b4:	003f5506 	br	320b30c <__svfscanf_r+0xf20>
 320b5b8:	a8000426 	beq	r21,zero,320b5cc <__svfscanf_r+0x11e0>
 320b5bc:	d880a317 	ldw	r2,652(sp)
 320b5c0:	ad7fffc4 	addi	r21,r21,-1
 320b5c4:	10800044 	addi	r2,r2,1
 320b5c8:	d880a315 	stw	r2,652(sp)
 320b5cc:	00bf1fc4 	movi	r2,-897
 320b5d0:	90a4703a 	and	r18,r18,r2
 320b5d4:	bdc00044 	addi	r23,r23,1
 320b5d8:	003fdb06 	br	320b548 <__svfscanf_r+0x115c>
 320b5dc:	9080004c 	andi	r2,r18,1
 320b5e0:	1005003a 	cmpeq	r2,r2,zero
 320b5e4:	10001426 	beq	r2,zero,320b638 <__svfscanf_r+0x124c>
 320b5e8:	9080008c 	andi	r2,r18,2
 320b5ec:	10001226 	beq	r2,zero,320b638 <__svfscanf_r+0x124c>
 320b5f0:	d8c0a017 	ldw	r3,640(sp)
 320b5f4:	0080c874 	movhi	r2,801
 320b5f8:	1082d904 	addi	r2,r2,2916
 320b5fc:	18801426 	beq	r3,r2,320b650 <__svfscanf_r+0x1264>
 320b600:	d9c0a117 	ldw	r7,644(sp)
 320b604:	d940a617 	ldw	r5,664(sp)
 320b608:	000d883a 	mov	r6,zero
 320b60c:	b009883a 	mov	r4,r22
 320b610:	321084c0 	call	321084c <_strtoll_r>
 320b614:	100d883a 	mov	r6,r2
 320b618:	180f883a 	mov	r7,r3
 320b61c:	d900a417 	ldw	r4,656(sp)
 320b620:	20800017 	ldw	r2,0(r4)
 320b624:	21000104 	addi	r4,r4,4
 320b628:	d900a415 	stw	r4,656(sp)
 320b62c:	11c00115 	stw	r7,4(r2)
 320b630:	11800015 	stw	r6,0(r2)
 320b634:	003fba06 	br	320b520 <__svfscanf_r+0x1134>
 320b638:	d900a417 	ldw	r4,656(sp)
 320b63c:	20800017 	ldw	r2,0(r4)
 320b640:	21000104 	addi	r4,r4,4
 320b644:	d900a415 	stw	r4,656(sp)
 320b648:	10c00015 	stw	r3,0(r2)
 320b64c:	003fb406 	br	320b520 <__svfscanf_r+0x1134>
 320b650:	d9c0a117 	ldw	r7,644(sp)
 320b654:	d940a617 	ldw	r5,664(sp)
 320b658:	000d883a 	mov	r6,zero
 320b65c:	b009883a 	mov	r4,r22
 320b660:	3210db80 	call	3210db8 <_strtoull_r>
 320b664:	100d883a 	mov	r6,r2
 320b668:	180f883a 	mov	r7,r3
 320b66c:	003feb06 	br	320b61c <__svfscanf_r+0x1230>
 320b670:	d8c0a117 	ldw	r3,644(sp)
 320b674:	18c5883a 	add	r2,r3,r3
 320b678:	00c0c974 	movhi	r3,805
 320b67c:	18f8b684 	addi	r3,r3,-7462
 320b680:	10c5883a 	add	r2,r2,r3
 320b684:	1080000f 	ldh	r2,0(r2)
 320b688:	00fd1fc4 	movi	r3,-2945
 320b68c:	90e4703a 	and	r18,r18,r3
 320b690:	d880a115 	stw	r2,644(sp)
 320b694:	003faa06 	br	320b540 <__svfscanf_r+0x1154>
 320b698:	d900a117 	ldw	r4,644(sp)
 320b69c:	00c0c974 	movhi	r3,805
 320b6a0:	18f8b684 	addi	r3,r3,-7462
 320b6a4:	2105883a 	add	r2,r4,r4
 320b6a8:	10c5883a 	add	r2,r2,r3
 320b6ac:	1080000f 	ldh	r2,0(r2)
 320b6b0:	00c00204 	movi	r3,8
 320b6b4:	d880a115 	stw	r2,644(sp)
 320b6b8:	18bf140e 	bge	r3,r2,320b30c <__svfscanf_r+0xf20>
 320b6bc:	00bd1fc4 	movi	r2,-2945
 320b6c0:	90a4703a 	and	r18,r18,r2
 320b6c4:	003f9e06 	br	320b540 <__svfscanf_r+0x1154>
 320b6c8:	d8c0a117 	ldw	r3,644(sp)
 320b6cc:	00800284 	movi	r2,10
 320b6d0:	10fffa16 	blt	r2,r3,320b6bc <__svfscanf_r+0x12d0>
 320b6d4:	003f0d06 	br	320b30c <__svfscanf_r+0xf20>
 320b6d8:	90c1800c 	andi	r3,r18,1536
 320b6dc:	00808004 	movi	r2,512
 320b6e0:	18bf0a1e 	bne	r3,r2,320b30c <__svfscanf_r+0xf20>
 320b6e4:	00bf7fc4 	movi	r2,-513
 320b6e8:	9084703a 	and	r2,r18,r2
 320b6ec:	01000404 	movi	r4,16
 320b6f0:	14814014 	ori	r18,r2,1280
 320b6f4:	d900a115 	stw	r4,644(sp)
 320b6f8:	003f9106 	br	320b540 <__svfscanf_r+0x1154>
 320b6fc:	d880a417 	ldw	r2,656(sp)
 320b700:	dd400404 	addi	r21,sp,16
 320b704:	14800017 	ldw	r18,0(r2)
 320b708:	9027883a 	mov	r19,r18
 320b70c:	81000017 	ldw	r4,0(r16)
 320b710:	20800003 	ldbu	r2,0(r4)
 320b714:	a885883a 	add	r2,r21,r2
 320b718:	10c00007 	ldb	r3,0(r2)
 320b71c:	18001426 	beq	r3,zero,320b770 <__svfscanf_r+0x1384>
 320b720:	d8c0a317 	ldw	r3,652(sp)
 320b724:	80800117 	ldw	r2,4(r16)
 320b728:	21800044 	addi	r6,r4,1
 320b72c:	18ffffc4 	addi	r3,r3,-1
 320b730:	d8c0a315 	stw	r3,652(sp)
 320b734:	10ffffc4 	addi	r3,r2,-1
 320b738:	80c00115 	stw	r3,4(r16)
 320b73c:	20800003 	ldbu	r2,0(r4)
 320b740:	90800005 	stb	r2,0(r18)
 320b744:	d900a317 	ldw	r4,652(sp)
 320b748:	81800015 	stw	r6,0(r16)
 320b74c:	94800044 	addi	r18,r18,1
 320b750:	20000726 	beq	r4,zero,320b770 <__svfscanf_r+0x1384>
 320b754:	80800117 	ldw	r2,4(r16)
 320b758:	00bfec16 	blt	zero,r2,320b70c <__svfscanf_r+0x1320>
 320b75c:	b009883a 	mov	r4,r22
 320b760:	800b883a 	mov	r5,r16
 320b764:	32077100 	call	3207710 <__srefill_r>
 320b768:	103fe826 	beq	r2,zero,320b70c <__svfscanf_r+0x1320>
 320b76c:	9cbb7426 	beq	r19,r18,320a540 <__svfscanf_r+0x154>
 320b770:	94e7c83a 	sub	r19,r18,r19
 320b774:	983b5226 	beq	r19,zero,320a4c0 <__svfscanf_r+0xd4>
 320b778:	90000005 	stb	zero,0(r18)
 320b77c:	d880a417 	ldw	r2,656(sp)
 320b780:	d8c0a217 	ldw	r3,648(sp)
 320b784:	8ce3883a 	add	r17,r17,r19
 320b788:	10800104 	addi	r2,r2,4
 320b78c:	18c00044 	addi	r3,r3,1
 320b790:	d880a415 	stw	r2,656(sp)
 320b794:	d8c0a215 	stw	r3,648(sp)
 320b798:	003b2706 	br	320a438 <__svfscanf_r+0x4c>
 320b79c:	9cc00414 	ori	r19,r19,16
 320b7a0:	003b6e06 	br	320a55c <__svfscanf_r+0x170>
 320b7a4:	00c00404 	movi	r3,16
 320b7a8:	0100c874 	movhi	r4,801
 320b7ac:	2102d904 	addi	r4,r4,2916
 320b7b0:	9cc08014 	ori	r19,r19,512
 320b7b4:	054000c4 	movi	r21,3
 320b7b8:	d8c0a115 	stw	r3,644(sp)
 320b7bc:	d900a015 	stw	r4,640(sp)
 320b7c0:	003bf806 	br	320a7a4 <__svfscanf_r+0x3b8>
 320b7c4:	9880040c 	andi	r2,r19,16
 320b7c8:	10001926 	beq	r2,zero,320b830 <__svfscanf_r+0x1444>
 320b7cc:	0027883a 	mov	r19,zero
 320b7d0:	00000b06 	br	320b800 <__svfscanf_r+0x1414>
 320b7d4:	80800017 	ldw	r2,0(r16)
 320b7d8:	b009883a 	mov	r4,r22
 320b7dc:	800b883a 	mov	r5,r16
 320b7e0:	148d883a 	add	r6,r2,r18
 320b7e4:	81800015 	stw	r6,0(r16)
 320b7e8:	9ca7883a 	add	r19,r19,r18
 320b7ec:	32077100 	call	3207710 <__srefill_r>
 320b7f0:	103c711e 	bne	r2,zero,320a9b8 <__svfscanf_r+0x5cc>
 320b7f4:	d900a317 	ldw	r4,652(sp)
 320b7f8:	2489c83a 	sub	r4,r4,r18
 320b7fc:	d900a315 	stw	r4,652(sp)
 320b800:	84800117 	ldw	r18,4(r16)
 320b804:	d8c0a317 	ldw	r3,652(sp)
 320b808:	90fff216 	blt	r18,r3,320b7d4 <__svfscanf_r+0x13e8>
 320b80c:	d900a317 	ldw	r4,652(sp)
 320b810:	80800017 	ldw	r2,0(r16)
 320b814:	9927883a 	add	r19,r19,r4
 320b818:	9107c83a 	sub	r3,r18,r4
 320b81c:	110d883a 	add	r6,r2,r4
 320b820:	8ce3883a 	add	r17,r17,r19
 320b824:	80c00115 	stw	r3,4(r16)
 320b828:	81800015 	stw	r6,0(r16)
 320b82c:	003b0206 	br	320a438 <__svfscanf_r+0x4c>
 320b830:	d880a417 	ldw	r2,656(sp)
 320b834:	d980a317 	ldw	r6,652(sp)
 320b838:	01400044 	movi	r5,1
 320b83c:	11000017 	ldw	r4,0(r2)
 320b840:	800f883a 	mov	r7,r16
 320b844:	320da000 	call	320da00 <fread>
 320b848:	103b3d26 	beq	r2,zero,320a540 <__svfscanf_r+0x154>
 320b84c:	d8c0a417 	ldw	r3,656(sp)
 320b850:	d900a217 	ldw	r4,648(sp)
 320b854:	88a3883a 	add	r17,r17,r2
 320b858:	18c00104 	addi	r3,r3,4
 320b85c:	21000044 	addi	r4,r4,1
 320b860:	d8c0a415 	stw	r3,656(sp)
 320b864:	d900a215 	stw	r4,648(sp)
 320b868:	003af306 	br	320a438 <__svfscanf_r+0x4c>
 320b86c:	8080030b 	ldhu	r2,12(r16)
 320b870:	1080100c 	andi	r2,r2,64
 320b874:	103b1226 	beq	r2,zero,320a4c0 <__svfscanf_r+0xd4>
 320b878:	003b3306 	br	320a548 <__svfscanf_r+0x15c>
 320b87c:	983b1026 	beq	r19,zero,320a4c0 <__svfscanf_r+0xd4>
 320b880:	8ce3883a 	add	r17,r17,r19
 320b884:	003aec06 	br	320a438 <__svfscanf_r+0x4c>
 320b888:	983c9626 	beq	r19,zero,320aae4 <__svfscanf_r+0x6f8>
 320b88c:	9cffffc4 	addi	r19,r19,-1
 320b890:	d8c04404 	addi	r3,sp,272
 320b894:	1cc5883a 	add	r2,r3,r19
 320b898:	11400003 	ldbu	r5,0(r2)
 320b89c:	b009883a 	mov	r4,r22
 320b8a0:	800d883a 	mov	r6,r16
 320b8a4:	32111840 	call	3211184 <_ungetc_r>
 320b8a8:	003ff706 	br	320b888 <__svfscanf_r+0x149c>
 320b8ac:	00bfff84 	movi	r2,-2
 320b8b0:	18bc7a1e 	bne	r3,r2,320aa9c <__svfscanf_r+0x6b0>
 320b8b4:	003c8406 	br	320aac8 <__svfscanf_r+0x6dc>
 320b8b8:	d900a417 	ldw	r4,656(sp)
 320b8bc:	25400017 	ldw	r21,0(r4)
 320b8c0:	21000104 	addi	r4,r4,4
 320b8c4:	d900a415 	stw	r4,656(sp)
 320b8c8:	003c4a06 	br	320a9f4 <__svfscanf_r+0x608>
 320b8cc:	00bfff84 	movi	r2,-2
 320b8d0:	18bc0f1e 	bne	r3,r2,320a910 <__svfscanf_r+0x524>
 320b8d4:	003c1506 	br	320a92c <__svfscanf_r+0x540>
 320b8d8:	b009883a 	mov	r4,r22
 320b8dc:	800b883a 	mov	r5,r16
 320b8e0:	32077100 	call	3207710 <__srefill_r>
 320b8e4:	103c1326 	beq	r2,zero,320a934 <__svfscanf_r+0x548>
 320b8e8:	903b151e 	bne	r18,zero,320a540 <__svfscanf_r+0x154>
 320b8ec:	a83ad21e 	bne	r21,zero,320a438 <__svfscanf_r+0x4c>
 320b8f0:	d880a217 	ldw	r2,648(sp)
 320b8f4:	10800044 	addi	r2,r2,1
 320b8f8:	d880a215 	stw	r2,648(sp)
 320b8fc:	003ace06 	br	320a438 <__svfscanf_r+0x4c>
 320b900:	0027883a 	mov	r19,zero
 320b904:	003bdd06 	br	320a87c <__svfscanf_r+0x490>
 320b908:	9cc00114 	ori	r19,r19,4
 320b90c:	003b1306 	br	320a55c <__svfscanf_r+0x170>
 320b910:	05400104 	movi	r21,4
 320b914:	003ba306 	br	320a7a4 <__svfscanf_r+0x3b8>
 320b918:	9cc00054 	ori	r19,r19,1
 320b91c:	0080c874 	movhi	r2,801
 320b920:	10817904 	addi	r2,r2,1508
 320b924:	00c00284 	movi	r3,10
 320b928:	054000c4 	movi	r21,3
 320b92c:	d880a015 	stw	r2,640(sp)
 320b930:	d8c0a115 	stw	r3,644(sp)
 320b934:	003b9b06 	br	320a7a4 <__svfscanf_r+0x3b8>
 320b938:	9cc01014 	ori	r19,r19,64
 320b93c:	002b883a 	mov	r21,zero
 320b940:	003b9806 	br	320a7a4 <__svfscanf_r+0x3b8>
 320b944:	a00b883a 	mov	r5,r20
 320b948:	d9000404 	addi	r4,sp,16
 320b94c:	320edf40 	call	320edf4 <__sccl>
 320b950:	1029883a 	mov	r20,r2
 320b954:	9cc01014 	ori	r19,r19,64
 320b958:	05400044 	movi	r21,1
 320b95c:	003b9106 	br	320a7a4 <__svfscanf_r+0x3b8>
 320b960:	9cc00054 	ori	r19,r19,1
 320b964:	00800204 	movi	r2,8
 320b968:	00c0c874 	movhi	r3,801
 320b96c:	18c2d904 	addi	r3,r3,2916
 320b970:	054000c4 	movi	r21,3
 320b974:	d880a115 	stw	r2,644(sp)
 320b978:	d8c0a015 	stw	r3,640(sp)
 320b97c:	003b8906 	br	320a7a4 <__svfscanf_r+0x3b8>
 320b980:	9880040c 	andi	r2,r19,16
 320b984:	103aac1e 	bne	r2,zero,320a438 <__svfscanf_r+0x4c>
 320b988:	9880010c 	andi	r2,r19,4
 320b98c:	10002426 	beq	r2,zero,320ba20 <__svfscanf_r+0x1634>
 320b990:	d900a417 	ldw	r4,656(sp)
 320b994:	20800017 	ldw	r2,0(r4)
 320b998:	21000104 	addi	r4,r4,4
 320b99c:	d900a415 	stw	r4,656(sp)
 320b9a0:	1440000d 	sth	r17,0(r2)
 320b9a4:	003aa406 	br	320a438 <__svfscanf_r+0x4c>
 320b9a8:	9cc00094 	ori	r19,r19,2
 320b9ac:	003aeb06 	br	320a55c <__svfscanf_r+0x170>
 320b9b0:	05400084 	movi	r21,2
 320b9b4:	003b7b06 	br	320a7a4 <__svfscanf_r+0x3b8>
 320b9b8:	00800404 	movi	r2,16
 320b9bc:	00c0c874 	movhi	r3,801
 320b9c0:	18c2d904 	addi	r3,r3,2916
 320b9c4:	9cc08814 	ori	r19,r19,544
 320b9c8:	054000c4 	movi	r21,3
 320b9cc:	d880a115 	stw	r2,644(sp)
 320b9d0:	d8c0a015 	stw	r3,640(sp)
 320b9d4:	003b7306 	br	320a7a4 <__svfscanf_r+0x3b8>
 320b9d8:	0009883a 	mov	r4,zero
 320b9dc:	320eeb40 	call	320eeb4 <nanf>
 320b9e0:	b8800015 	stw	r2,0(r23)
 320b9e4:	003d2706 	br	320ae84 <__svfscanf_r+0xa98>
 320b9e8:	a0c00007 	ldb	r3,0(r20)
 320b9ec:	00801b04 	movi	r2,108
 320b9f0:	18800826 	beq	r3,r2,320ba14 <__svfscanf_r+0x1628>
 320b9f4:	9cc00054 	ori	r19,r19,1
 320b9f8:	003ad806 	br	320a55c <__svfscanf_r+0x170>
 320b9fc:	0100c874 	movhi	r4,801
 320ba00:	21017904 	addi	r4,r4,1508
 320ba04:	054000c4 	movi	r21,3
 320ba08:	d900a015 	stw	r4,640(sp)
 320ba0c:	d800a115 	stw	zero,644(sp)
 320ba10:	003b6406 	br	320a7a4 <__svfscanf_r+0x3b8>
 320ba14:	a5000044 	addi	r20,r20,1
 320ba18:	9cc00094 	ori	r19,r19,2
 320ba1c:	003acf06 	br	320a55c <__svfscanf_r+0x170>
 320ba20:	9880004c 	andi	r2,r19,1
 320ba24:	1005003a 	cmpeq	r2,r2,zero
 320ba28:	10000a26 	beq	r2,zero,320ba54 <__svfscanf_r+0x1668>
 320ba2c:	9880008c 	andi	r2,r19,2
 320ba30:	10000826 	beq	r2,zero,320ba54 <__svfscanf_r+0x1668>
 320ba34:	d900a417 	ldw	r4,656(sp)
 320ba38:	8807d7fa 	srai	r3,r17,31
 320ba3c:	20800017 	ldw	r2,0(r4)
 320ba40:	21000104 	addi	r4,r4,4
 320ba44:	d900a415 	stw	r4,656(sp)
 320ba48:	14400015 	stw	r17,0(r2)
 320ba4c:	10c00115 	stw	r3,4(r2)
 320ba50:	003a7906 	br	320a438 <__svfscanf_r+0x4c>
 320ba54:	d8c0a417 	ldw	r3,656(sp)
 320ba58:	18800017 	ldw	r2,0(r3)
 320ba5c:	18c00104 	addi	r3,r3,4
 320ba60:	d8c0a415 	stw	r3,656(sp)
 320ba64:	14400015 	stw	r17,0(r2)
 320ba68:	003a7306 	br	320a438 <__svfscanf_r+0x4c>

0320ba6c <__svfscanf>:
 320ba6c:	0080c974 	movhi	r2,805
 320ba70:	108a6304 	addi	r2,r2,10636
 320ba74:	2013883a 	mov	r9,r4
 320ba78:	11000017 	ldw	r4,0(r2)
 320ba7c:	2805883a 	mov	r2,r5
 320ba80:	300f883a 	mov	r7,r6
 320ba84:	480b883a 	mov	r5,r9
 320ba88:	100d883a 	mov	r6,r2
 320ba8c:	320a3ec1 	jmpi	320a3ec <__svfscanf_r>

0320ba90 <_vfscanf_r>:
 320ba90:	defffb04 	addi	sp,sp,-20
 320ba94:	dcc00315 	stw	r19,12(sp)
 320ba98:	dc800215 	stw	r18,8(sp)
 320ba9c:	dc400115 	stw	r17,4(sp)
 320baa0:	dc000015 	stw	r16,0(sp)
 320baa4:	dfc00415 	stw	ra,16(sp)
 320baa8:	2021883a 	mov	r16,r4
 320baac:	2823883a 	mov	r17,r5
 320bab0:	3025883a 	mov	r18,r6
 320bab4:	3827883a 	mov	r19,r7
 320bab8:	20000226 	beq	r4,zero,320bac4 <_vfscanf_r+0x34>
 320babc:	20800e17 	ldw	r2,56(r4)
 320bac0:	10000b26 	beq	r2,zero,320baf0 <_vfscanf_r+0x60>
 320bac4:	8009883a 	mov	r4,r16
 320bac8:	880b883a 	mov	r5,r17
 320bacc:	900d883a 	mov	r6,r18
 320bad0:	980f883a 	mov	r7,r19
 320bad4:	dfc00417 	ldw	ra,16(sp)
 320bad8:	dcc00317 	ldw	r19,12(sp)
 320badc:	dc800217 	ldw	r18,8(sp)
 320bae0:	dc400117 	ldw	r17,4(sp)
 320bae4:	dc000017 	ldw	r16,0(sp)
 320bae8:	dec00504 	addi	sp,sp,20
 320baec:	320a3ec1 	jmpi	320a3ec <__svfscanf_r>
 320baf0:	3204b8c0 	call	3204b8c <__sinit>
 320baf4:	003ff306 	br	320bac4 <_vfscanf_r+0x34>

0320baf8 <vfscanf>:
 320baf8:	defffb04 	addi	sp,sp,-20
 320bafc:	dcc00315 	stw	r19,12(sp)
 320bb00:	04c0c974 	movhi	r19,805
 320bb04:	9cca6304 	addi	r19,r19,10636
 320bb08:	98c00017 	ldw	r3,0(r19)
 320bb0c:	dc800215 	stw	r18,8(sp)
 320bb10:	dc400115 	stw	r17,4(sp)
 320bb14:	dc000015 	stw	r16,0(sp)
 320bb18:	dfc00415 	stw	ra,16(sp)
 320bb1c:	2021883a 	mov	r16,r4
 320bb20:	2823883a 	mov	r17,r5
 320bb24:	3025883a 	mov	r18,r6
 320bb28:	18000326 	beq	r3,zero,320bb38 <vfscanf+0x40>
 320bb2c:	18800e17 	ldw	r2,56(r3)
 320bb30:	1809883a 	mov	r4,r3
 320bb34:	10000b26 	beq	r2,zero,320bb64 <vfscanf+0x6c>
 320bb38:	99000017 	ldw	r4,0(r19)
 320bb3c:	800b883a 	mov	r5,r16
 320bb40:	880d883a 	mov	r6,r17
 320bb44:	900f883a 	mov	r7,r18
 320bb48:	dfc00417 	ldw	ra,16(sp)
 320bb4c:	dcc00317 	ldw	r19,12(sp)
 320bb50:	dc800217 	ldw	r18,8(sp)
 320bb54:	dc400117 	ldw	r17,4(sp)
 320bb58:	dc000017 	ldw	r16,0(sp)
 320bb5c:	dec00504 	addi	sp,sp,20
 320bb60:	320a3ec1 	jmpi	320a3ec <__svfscanf_r>
 320bb64:	3204b8c0 	call	3204b8c <__sinit>
 320bb68:	003ff306 	br	320bb38 <vfscanf+0x40>

0320bb6c <__swbuf_r>:
 320bb6c:	defffc04 	addi	sp,sp,-16
 320bb70:	dc400215 	stw	r17,8(sp)
 320bb74:	dc000115 	stw	r16,4(sp)
 320bb78:	dfc00315 	stw	ra,12(sp)
 320bb7c:	2023883a 	mov	r17,r4
 320bb80:	2821883a 	mov	r16,r5
 320bb84:	20000226 	beq	r4,zero,320bb90 <__swbuf_r+0x24>
 320bb88:	20800e17 	ldw	r2,56(r4)
 320bb8c:	10002f26 	beq	r2,zero,320bc4c <__swbuf_r+0xe0>
 320bb90:	3080030b 	ldhu	r2,12(r6)
 320bb94:	30c00617 	ldw	r3,24(r6)
 320bb98:	1080020c 	andi	r2,r2,8
 320bb9c:	30c00215 	stw	r3,8(r6)
 320bba0:	10002226 	beq	r2,zero,320bc2c <__swbuf_r+0xc0>
 320bba4:	30c00417 	ldw	r3,16(r6)
 320bba8:	18002026 	beq	r3,zero,320bc2c <__swbuf_r+0xc0>
 320bbac:	31000017 	ldw	r4,0(r6)
 320bbb0:	30800517 	ldw	r2,20(r6)
 320bbb4:	20c7c83a 	sub	r3,r4,r3
 320bbb8:	18802f0e 	bge	r3,r2,320bc78 <__swbuf_r+0x10c>
 320bbbc:	19400044 	addi	r5,r3,1
 320bbc0:	30800217 	ldw	r2,8(r6)
 320bbc4:	84003fcc 	andi	r16,r16,255
 320bbc8:	20c00044 	addi	r3,r4,1
 320bbcc:	10bfffc4 	addi	r2,r2,-1
 320bbd0:	30800215 	stw	r2,8(r6)
 320bbd4:	24000005 	stb	r16,0(r4)
 320bbd8:	30800517 	ldw	r2,20(r6)
 320bbdc:	30c00015 	stw	r3,0(r6)
 320bbe0:	11400c26 	beq	r2,r5,320bc14 <__swbuf_r+0xa8>
 320bbe4:	3080030b 	ldhu	r2,12(r6)
 320bbe8:	1080004c 	andi	r2,r2,1
 320bbec:	1005003a 	cmpeq	r2,r2,zero
 320bbf0:	10000626 	beq	r2,zero,320bc0c <__swbuf_r+0xa0>
 320bbf4:	8005883a 	mov	r2,r16
 320bbf8:	dfc00317 	ldw	ra,12(sp)
 320bbfc:	dc400217 	ldw	r17,8(sp)
 320bc00:	dc000117 	ldw	r16,4(sp)
 320bc04:	dec00404 	addi	sp,sp,16
 320bc08:	f800283a 	ret
 320bc0c:	00800284 	movi	r2,10
 320bc10:	80bff81e 	bne	r16,r2,320bbf4 <__swbuf_r+0x88>
 320bc14:	8809883a 	mov	r4,r17
 320bc18:	300b883a 	mov	r5,r6
 320bc1c:	32048f40 	call	32048f4 <_fflush_r>
 320bc20:	103ff426 	beq	r2,zero,320bbf4 <__swbuf_r+0x88>
 320bc24:	043fffc4 	movi	r16,-1
 320bc28:	003ff206 	br	320bbf4 <__swbuf_r+0x88>
 320bc2c:	300b883a 	mov	r5,r6
 320bc30:	8809883a 	mov	r4,r17
 320bc34:	d9800015 	stw	r6,0(sp)
 320bc38:	320bd300 	call	320bd30 <__swsetup_r>
 320bc3c:	d9800017 	ldw	r6,0(sp)
 320bc40:	1000061e 	bne	r2,zero,320bc5c <__swbuf_r+0xf0>
 320bc44:	30c00417 	ldw	r3,16(r6)
 320bc48:	003fd806 	br	320bbac <__swbuf_r+0x40>
 320bc4c:	d9800015 	stw	r6,0(sp)
 320bc50:	3204b8c0 	call	3204b8c <__sinit>
 320bc54:	d9800017 	ldw	r6,0(sp)
 320bc58:	003fcd06 	br	320bb90 <__swbuf_r+0x24>
 320bc5c:	3080030b 	ldhu	r2,12(r6)
 320bc60:	00c00244 	movi	r3,9
 320bc64:	043fffc4 	movi	r16,-1
 320bc68:	10801014 	ori	r2,r2,64
 320bc6c:	3080030d 	sth	r2,12(r6)
 320bc70:	88c00015 	stw	r3,0(r17)
 320bc74:	003fdf06 	br	320bbf4 <__swbuf_r+0x88>
 320bc78:	300b883a 	mov	r5,r6
 320bc7c:	8809883a 	mov	r4,r17
 320bc80:	d9800015 	stw	r6,0(sp)
 320bc84:	32048f40 	call	32048f4 <_fflush_r>
 320bc88:	d9800017 	ldw	r6,0(sp)
 320bc8c:	103fe51e 	bne	r2,zero,320bc24 <__swbuf_r+0xb8>
 320bc90:	31000017 	ldw	r4,0(r6)
 320bc94:	01400044 	movi	r5,1
 320bc98:	003fc906 	br	320bbc0 <__swbuf_r+0x54>

0320bc9c <__swbuf>:
 320bc9c:	0180c974 	movhi	r6,805
 320bca0:	318a6304 	addi	r6,r6,10636
 320bca4:	2007883a 	mov	r3,r4
 320bca8:	31000017 	ldw	r4,0(r6)
 320bcac:	280d883a 	mov	r6,r5
 320bcb0:	180b883a 	mov	r5,r3
 320bcb4:	320bb6c1 	jmpi	320bb6c <__swbuf_r>

0320bcb8 <_write_r>:
 320bcb8:	defffd04 	addi	sp,sp,-12
 320bcbc:	dc000015 	stw	r16,0(sp)
 320bcc0:	0400c974 	movhi	r16,805
 320bcc4:	8412f804 	addi	r16,r16,19424
 320bcc8:	dc400115 	stw	r17,4(sp)
 320bccc:	80000015 	stw	zero,0(r16)
 320bcd0:	2023883a 	mov	r17,r4
 320bcd4:	2809883a 	mov	r4,r5
 320bcd8:	300b883a 	mov	r5,r6
 320bcdc:	380d883a 	mov	r6,r7
 320bce0:	dfc00215 	stw	ra,8(sp)
 320bce4:	3222d500 	call	3222d50 <write>
 320bce8:	1007883a 	mov	r3,r2
 320bcec:	00bfffc4 	movi	r2,-1
 320bcf0:	18800626 	beq	r3,r2,320bd0c <_write_r+0x54>
 320bcf4:	1805883a 	mov	r2,r3
 320bcf8:	dfc00217 	ldw	ra,8(sp)
 320bcfc:	dc400117 	ldw	r17,4(sp)
 320bd00:	dc000017 	ldw	r16,0(sp)
 320bd04:	dec00304 	addi	sp,sp,12
 320bd08:	f800283a 	ret
 320bd0c:	80800017 	ldw	r2,0(r16)
 320bd10:	103ff826 	beq	r2,zero,320bcf4 <_write_r+0x3c>
 320bd14:	88800015 	stw	r2,0(r17)
 320bd18:	1805883a 	mov	r2,r3
 320bd1c:	dfc00217 	ldw	ra,8(sp)
 320bd20:	dc400117 	ldw	r17,4(sp)
 320bd24:	dc000017 	ldw	r16,0(sp)
 320bd28:	dec00304 	addi	sp,sp,12
 320bd2c:	f800283a 	ret

0320bd30 <__swsetup_r>:
 320bd30:	0080c974 	movhi	r2,805
 320bd34:	108a6304 	addi	r2,r2,10636
 320bd38:	10c00017 	ldw	r3,0(r2)
 320bd3c:	defffd04 	addi	sp,sp,-12
 320bd40:	dc400115 	stw	r17,4(sp)
 320bd44:	dc000015 	stw	r16,0(sp)
 320bd48:	dfc00215 	stw	ra,8(sp)
 320bd4c:	2023883a 	mov	r17,r4
 320bd50:	2821883a 	mov	r16,r5
 320bd54:	18000226 	beq	r3,zero,320bd60 <__swsetup_r+0x30>
 320bd58:	18800e17 	ldw	r2,56(r3)
 320bd5c:	10001f26 	beq	r2,zero,320bddc <__swsetup_r+0xac>
 320bd60:	8100030b 	ldhu	r4,12(r16)
 320bd64:	2080020c 	andi	r2,r4,8
 320bd68:	10002826 	beq	r2,zero,320be0c <__swsetup_r+0xdc>
 320bd6c:	81400417 	ldw	r5,16(r16)
 320bd70:	28001d26 	beq	r5,zero,320bde8 <__swsetup_r+0xb8>
 320bd74:	2080004c 	andi	r2,r4,1
 320bd78:	1005003a 	cmpeq	r2,r2,zero
 320bd7c:	10000b26 	beq	r2,zero,320bdac <__swsetup_r+0x7c>
 320bd80:	2080008c 	andi	r2,r4,2
 320bd84:	10001226 	beq	r2,zero,320bdd0 <__swsetup_r+0xa0>
 320bd88:	0005883a 	mov	r2,zero
 320bd8c:	80800215 	stw	r2,8(r16)
 320bd90:	28000b26 	beq	r5,zero,320bdc0 <__swsetup_r+0x90>
 320bd94:	0005883a 	mov	r2,zero
 320bd98:	dfc00217 	ldw	ra,8(sp)
 320bd9c:	dc400117 	ldw	r17,4(sp)
 320bda0:	dc000017 	ldw	r16,0(sp)
 320bda4:	dec00304 	addi	sp,sp,12
 320bda8:	f800283a 	ret
 320bdac:	80800517 	ldw	r2,20(r16)
 320bdb0:	80000215 	stw	zero,8(r16)
 320bdb4:	0085c83a 	sub	r2,zero,r2
 320bdb8:	80800615 	stw	r2,24(r16)
 320bdbc:	283ff51e 	bne	r5,zero,320bd94 <__swsetup_r+0x64>
 320bdc0:	2080200c 	andi	r2,r4,128
 320bdc4:	103ff326 	beq	r2,zero,320bd94 <__swsetup_r+0x64>
 320bdc8:	00bfffc4 	movi	r2,-1
 320bdcc:	003ff206 	br	320bd98 <__swsetup_r+0x68>
 320bdd0:	80800517 	ldw	r2,20(r16)
 320bdd4:	80800215 	stw	r2,8(r16)
 320bdd8:	003fed06 	br	320bd90 <__swsetup_r+0x60>
 320bddc:	1809883a 	mov	r4,r3
 320bde0:	3204b8c0 	call	3204b8c <__sinit>
 320bde4:	003fde06 	br	320bd60 <__swsetup_r+0x30>
 320bde8:	20c0a00c 	andi	r3,r4,640
 320bdec:	00808004 	movi	r2,512
 320bdf0:	18bfe026 	beq	r3,r2,320bd74 <__swsetup_r+0x44>
 320bdf4:	8809883a 	mov	r4,r17
 320bdf8:	800b883a 	mov	r5,r16
 320bdfc:	32061180 	call	3206118 <__smakebuf_r>
 320be00:	8100030b 	ldhu	r4,12(r16)
 320be04:	81400417 	ldw	r5,16(r16)
 320be08:	003fda06 	br	320bd74 <__swsetup_r+0x44>
 320be0c:	2080040c 	andi	r2,r4,16
 320be10:	103fed26 	beq	r2,zero,320bdc8 <__swsetup_r+0x98>
 320be14:	2080010c 	andi	r2,r4,4
 320be18:	10001226 	beq	r2,zero,320be64 <__swsetup_r+0x134>
 320be1c:	81400c17 	ldw	r5,48(r16)
 320be20:	28000526 	beq	r5,zero,320be38 <__swsetup_r+0x108>
 320be24:	80801004 	addi	r2,r16,64
 320be28:	28800226 	beq	r5,r2,320be34 <__swsetup_r+0x104>
 320be2c:	8809883a 	mov	r4,r17
 320be30:	32051100 	call	3205110 <_free_r>
 320be34:	80000c15 	stw	zero,48(r16)
 320be38:	8080030b 	ldhu	r2,12(r16)
 320be3c:	81400417 	ldw	r5,16(r16)
 320be40:	80000115 	stw	zero,4(r16)
 320be44:	10bff6cc 	andi	r2,r2,65499
 320be48:	8080030d 	sth	r2,12(r16)
 320be4c:	81400015 	stw	r5,0(r16)
 320be50:	8080030b 	ldhu	r2,12(r16)
 320be54:	10800214 	ori	r2,r2,8
 320be58:	113fffcc 	andi	r4,r2,65535
 320be5c:	8080030d 	sth	r2,12(r16)
 320be60:	003fc306 	br	320bd70 <__swsetup_r+0x40>
 320be64:	81400417 	ldw	r5,16(r16)
 320be68:	003ff906 	br	320be50 <__swsetup_r+0x120>

0320be6c <_close_r>:
 320be6c:	defffd04 	addi	sp,sp,-12
 320be70:	dc000015 	stw	r16,0(sp)
 320be74:	0400c974 	movhi	r16,805
 320be78:	8412f804 	addi	r16,r16,19424
 320be7c:	dc400115 	stw	r17,4(sp)
 320be80:	80000015 	stw	zero,0(r16)
 320be84:	2023883a 	mov	r17,r4
 320be88:	2809883a 	mov	r4,r5
 320be8c:	dfc00215 	stw	ra,8(sp)
 320be90:	3222b400 	call	3222b40 <close>
 320be94:	1007883a 	mov	r3,r2
 320be98:	00bfffc4 	movi	r2,-1
 320be9c:	18800626 	beq	r3,r2,320beb8 <_close_r+0x4c>
 320bea0:	1805883a 	mov	r2,r3
 320bea4:	dfc00217 	ldw	ra,8(sp)
 320bea8:	dc400117 	ldw	r17,4(sp)
 320beac:	dc000017 	ldw	r16,0(sp)
 320beb0:	dec00304 	addi	sp,sp,12
 320beb4:	f800283a 	ret
 320beb8:	80800017 	ldw	r2,0(r16)
 320bebc:	103ff826 	beq	r2,zero,320bea0 <_close_r+0x34>
 320bec0:	88800015 	stw	r2,0(r17)
 320bec4:	1805883a 	mov	r2,r3
 320bec8:	dfc00217 	ldw	ra,8(sp)
 320becc:	dc400117 	ldw	r17,4(sp)
 320bed0:	dc000017 	ldw	r16,0(sp)
 320bed4:	dec00304 	addi	sp,sp,12
 320bed8:	f800283a 	ret

0320bedc <quorem>:
 320bedc:	28c00417 	ldw	r3,16(r5)
 320bee0:	20800417 	ldw	r2,16(r4)
 320bee4:	defff604 	addi	sp,sp,-40
 320bee8:	ddc00715 	stw	r23,28(sp)
 320beec:	dd400515 	stw	r21,20(sp)
 320bef0:	dfc00915 	stw	ra,36(sp)
 320bef4:	df000815 	stw	fp,32(sp)
 320bef8:	dd800615 	stw	r22,24(sp)
 320befc:	dd000415 	stw	r20,16(sp)
 320bf00:	dcc00315 	stw	r19,12(sp)
 320bf04:	dc800215 	stw	r18,8(sp)
 320bf08:	dc400115 	stw	r17,4(sp)
 320bf0c:	dc000015 	stw	r16,0(sp)
 320bf10:	202f883a 	mov	r23,r4
 320bf14:	282b883a 	mov	r21,r5
 320bf18:	10c07416 	blt	r2,r3,320c0ec <quorem+0x210>
 320bf1c:	1c7fffc4 	addi	r17,r3,-1
 320bf20:	8c45883a 	add	r2,r17,r17
 320bf24:	1085883a 	add	r2,r2,r2
 320bf28:	2c000504 	addi	r16,r5,20
 320bf2c:	24c00504 	addi	r19,r4,20
 320bf30:	14ed883a 	add	r22,r2,r19
 320bf34:	80a5883a 	add	r18,r16,r2
 320bf38:	b7000017 	ldw	fp,0(r22)
 320bf3c:	91400017 	ldw	r5,0(r18)
 320bf40:	e009883a 	mov	r4,fp
 320bf44:	29400044 	addi	r5,r5,1
 320bf48:	32047c00 	call	32047c0 <__udivsi3>
 320bf4c:	1029883a 	mov	r20,r2
 320bf50:	10003c1e 	bne	r2,zero,320c044 <quorem+0x168>
 320bf54:	a80b883a 	mov	r5,r21
 320bf58:	b809883a 	mov	r4,r23
 320bf5c:	320de740 	call	320de74 <__mcmp>
 320bf60:	10002b16 	blt	r2,zero,320c010 <quorem+0x134>
 320bf64:	a5000044 	addi	r20,r20,1
 320bf68:	980f883a 	mov	r7,r19
 320bf6c:	0011883a 	mov	r8,zero
 320bf70:	0009883a 	mov	r4,zero
 320bf74:	81400017 	ldw	r5,0(r16)
 320bf78:	38c00017 	ldw	r3,0(r7)
 320bf7c:	84000104 	addi	r16,r16,4
 320bf80:	28bfffcc 	andi	r2,r5,65535
 320bf84:	2085883a 	add	r2,r4,r2
 320bf88:	11bfffcc 	andi	r6,r2,65535
 320bf8c:	193fffcc 	andi	r4,r3,65535
 320bf90:	1004d43a 	srli	r2,r2,16
 320bf94:	280ad43a 	srli	r5,r5,16
 320bf98:	2189c83a 	sub	r4,r4,r6
 320bf9c:	2209883a 	add	r4,r4,r8
 320bfa0:	1806d43a 	srli	r3,r3,16
 320bfa4:	288b883a 	add	r5,r5,r2
 320bfa8:	200dd43a 	srai	r6,r4,16
 320bfac:	28bfffcc 	andi	r2,r5,65535
 320bfb0:	1887c83a 	sub	r3,r3,r2
 320bfb4:	1987883a 	add	r3,r3,r6
 320bfb8:	3900000d 	sth	r4,0(r7)
 320bfbc:	38c0008d 	sth	r3,2(r7)
 320bfc0:	2808d43a 	srli	r4,r5,16
 320bfc4:	39c00104 	addi	r7,r7,4
 320bfc8:	1811d43a 	srai	r8,r3,16
 320bfcc:	943fe92e 	bgeu	r18,r16,320bf74 <quorem+0x98>
 320bfd0:	8c45883a 	add	r2,r17,r17
 320bfd4:	1085883a 	add	r2,r2,r2
 320bfd8:	9885883a 	add	r2,r19,r2
 320bfdc:	10c00017 	ldw	r3,0(r2)
 320bfe0:	18000b1e 	bne	r3,zero,320c010 <quorem+0x134>
 320bfe4:	113fff04 	addi	r4,r2,-4
 320bfe8:	9900082e 	bgeu	r19,r4,320c00c <quorem+0x130>
 320bfec:	10bfff17 	ldw	r2,-4(r2)
 320bff0:	10000326 	beq	r2,zero,320c000 <quorem+0x124>
 320bff4:	00000506 	br	320c00c <quorem+0x130>
 320bff8:	20800017 	ldw	r2,0(r4)
 320bffc:	1000031e 	bne	r2,zero,320c00c <quorem+0x130>
 320c000:	213fff04 	addi	r4,r4,-4
 320c004:	8c7fffc4 	addi	r17,r17,-1
 320c008:	993ffb36 	bltu	r19,r4,320bff8 <quorem+0x11c>
 320c00c:	bc400415 	stw	r17,16(r23)
 320c010:	a005883a 	mov	r2,r20
 320c014:	dfc00917 	ldw	ra,36(sp)
 320c018:	df000817 	ldw	fp,32(sp)
 320c01c:	ddc00717 	ldw	r23,28(sp)
 320c020:	dd800617 	ldw	r22,24(sp)
 320c024:	dd400517 	ldw	r21,20(sp)
 320c028:	dd000417 	ldw	r20,16(sp)
 320c02c:	dcc00317 	ldw	r19,12(sp)
 320c030:	dc800217 	ldw	r18,8(sp)
 320c034:	dc400117 	ldw	r17,4(sp)
 320c038:	dc000017 	ldw	r16,0(sp)
 320c03c:	dec00a04 	addi	sp,sp,40
 320c040:	f800283a 	ret
 320c044:	980f883a 	mov	r7,r19
 320c048:	8011883a 	mov	r8,r16
 320c04c:	0013883a 	mov	r9,zero
 320c050:	000d883a 	mov	r6,zero
 320c054:	40c00017 	ldw	r3,0(r8)
 320c058:	39000017 	ldw	r4,0(r7)
 320c05c:	42000104 	addi	r8,r8,4
 320c060:	18bfffcc 	andi	r2,r3,65535
 320c064:	a085383a 	mul	r2,r20,r2
 320c068:	1806d43a 	srli	r3,r3,16
 320c06c:	217fffcc 	andi	r5,r4,65535
 320c070:	3085883a 	add	r2,r6,r2
 320c074:	11bfffcc 	andi	r6,r2,65535
 320c078:	a0c7383a 	mul	r3,r20,r3
 320c07c:	1004d43a 	srli	r2,r2,16
 320c080:	298bc83a 	sub	r5,r5,r6
 320c084:	2a4b883a 	add	r5,r5,r9
 320c088:	2008d43a 	srli	r4,r4,16
 320c08c:	1887883a 	add	r3,r3,r2
 320c090:	280dd43a 	srai	r6,r5,16
 320c094:	18bfffcc 	andi	r2,r3,65535
 320c098:	2089c83a 	sub	r4,r4,r2
 320c09c:	2189883a 	add	r4,r4,r6
 320c0a0:	3900008d 	sth	r4,2(r7)
 320c0a4:	3940000d 	sth	r5,0(r7)
 320c0a8:	180cd43a 	srli	r6,r3,16
 320c0ac:	39c00104 	addi	r7,r7,4
 320c0b0:	2013d43a 	srai	r9,r4,16
 320c0b4:	923fe72e 	bgeu	r18,r8,320c054 <quorem+0x178>
 320c0b8:	e03fa61e 	bne	fp,zero,320bf54 <quorem+0x78>
 320c0bc:	b0ffff04 	addi	r3,r22,-4
 320c0c0:	98c0082e 	bgeu	r19,r3,320c0e4 <quorem+0x208>
 320c0c4:	b0bfff17 	ldw	r2,-4(r22)
 320c0c8:	10000326 	beq	r2,zero,320c0d8 <quorem+0x1fc>
 320c0cc:	00000506 	br	320c0e4 <quorem+0x208>
 320c0d0:	18800017 	ldw	r2,0(r3)
 320c0d4:	1000031e 	bne	r2,zero,320c0e4 <quorem+0x208>
 320c0d8:	18ffff04 	addi	r3,r3,-4
 320c0dc:	8c7fffc4 	addi	r17,r17,-1
 320c0e0:	98fffb36 	bltu	r19,r3,320c0d0 <quorem+0x1f4>
 320c0e4:	bc400415 	stw	r17,16(r23)
 320c0e8:	003f9a06 	br	320bf54 <quorem+0x78>
 320c0ec:	0005883a 	mov	r2,zero
 320c0f0:	003fc806 	br	320c014 <quorem+0x138>

0320c0f4 <_dtoa_r>:
 320c0f4:	22001017 	ldw	r8,64(r4)
 320c0f8:	deffda04 	addi	sp,sp,-152
 320c0fc:	dd402115 	stw	r21,132(sp)
 320c100:	dd002015 	stw	r20,128(sp)
 320c104:	dc801e15 	stw	r18,120(sp)
 320c108:	dc401d15 	stw	r17,116(sp)
 320c10c:	dfc02515 	stw	ra,148(sp)
 320c110:	df002415 	stw	fp,144(sp)
 320c114:	ddc02315 	stw	r23,140(sp)
 320c118:	dd802215 	stw	r22,136(sp)
 320c11c:	dcc01f15 	stw	r19,124(sp)
 320c120:	dc001c15 	stw	r16,112(sp)
 320c124:	d9001615 	stw	r4,88(sp)
 320c128:	3023883a 	mov	r17,r6
 320c12c:	2829883a 	mov	r20,r5
 320c130:	d9c01715 	stw	r7,92(sp)
 320c134:	dc802817 	ldw	r18,160(sp)
 320c138:	302b883a 	mov	r21,r6
 320c13c:	40000a26 	beq	r8,zero,320c168 <_dtoa_r+0x74>
 320c140:	20801117 	ldw	r2,68(r4)
 320c144:	400b883a 	mov	r5,r8
 320c148:	40800115 	stw	r2,4(r8)
 320c14c:	20c01117 	ldw	r3,68(r4)
 320c150:	00800044 	movi	r2,1
 320c154:	10c4983a 	sll	r2,r2,r3
 320c158:	40800215 	stw	r2,8(r8)
 320c15c:	320dd180 	call	320dd18 <_Bfree>
 320c160:	d8c01617 	ldw	r3,88(sp)
 320c164:	18001015 	stw	zero,64(r3)
 320c168:	8800a316 	blt	r17,zero,320c3f8 <_dtoa_r+0x304>
 320c16c:	90000015 	stw	zero,0(r18)
 320c170:	a8dffc2c 	andhi	r3,r21,32752
 320c174:	009ffc34 	movhi	r2,32752
 320c178:	18809126 	beq	r3,r2,320c3c0 <_dtoa_r+0x2cc>
 320c17c:	000d883a 	mov	r6,zero
 320c180:	000f883a 	mov	r7,zero
 320c184:	a009883a 	mov	r4,r20
 320c188:	a80b883a 	mov	r5,r21
 320c18c:	dd001215 	stw	r20,72(sp)
 320c190:	dd401315 	stw	r21,76(sp)
 320c194:	32139500 	call	3213950 <__nedf2>
 320c198:	1000171e 	bne	r2,zero,320c1f8 <_dtoa_r+0x104>
 320c19c:	d9802717 	ldw	r6,156(sp)
 320c1a0:	00800044 	movi	r2,1
 320c1a4:	30800015 	stw	r2,0(r6)
 320c1a8:	d8802917 	ldw	r2,164(sp)
 320c1ac:	10029b26 	beq	r2,zero,320cc1c <_dtoa_r+0xb28>
 320c1b0:	d9002917 	ldw	r4,164(sp)
 320c1b4:	0080c974 	movhi	r2,805
 320c1b8:	10b8ac44 	addi	r2,r2,-7503
 320c1bc:	10ffffc4 	addi	r3,r2,-1
 320c1c0:	20800015 	stw	r2,0(r4)
 320c1c4:	1805883a 	mov	r2,r3
 320c1c8:	dfc02517 	ldw	ra,148(sp)
 320c1cc:	df002417 	ldw	fp,144(sp)
 320c1d0:	ddc02317 	ldw	r23,140(sp)
 320c1d4:	dd802217 	ldw	r22,136(sp)
 320c1d8:	dd402117 	ldw	r21,132(sp)
 320c1dc:	dd002017 	ldw	r20,128(sp)
 320c1e0:	dcc01f17 	ldw	r19,124(sp)
 320c1e4:	dc801e17 	ldw	r18,120(sp)
 320c1e8:	dc401d17 	ldw	r17,116(sp)
 320c1ec:	dc001c17 	ldw	r16,112(sp)
 320c1f0:	dec02604 	addi	sp,sp,152
 320c1f4:	f800283a 	ret
 320c1f8:	d9001617 	ldw	r4,88(sp)
 320c1fc:	d9401217 	ldw	r5,72(sp)
 320c200:	d8800104 	addi	r2,sp,4
 320c204:	a80d883a 	mov	r6,r21
 320c208:	d9c00204 	addi	r7,sp,8
 320c20c:	d8800015 	stw	r2,0(sp)
 320c210:	320e3540 	call	320e354 <__d2b>
 320c214:	d8800715 	stw	r2,28(sp)
 320c218:	a804d53a 	srli	r2,r21,20
 320c21c:	1101ffcc 	andi	r4,r2,2047
 320c220:	20008626 	beq	r4,zero,320c43c <_dtoa_r+0x348>
 320c224:	d8c01217 	ldw	r3,72(sp)
 320c228:	00800434 	movhi	r2,16
 320c22c:	10bfffc4 	addi	r2,r2,-1
 320c230:	ddc00117 	ldw	r23,4(sp)
 320c234:	a884703a 	and	r2,r21,r2
 320c238:	1811883a 	mov	r8,r3
 320c23c:	124ffc34 	orhi	r9,r2,16368
 320c240:	25bf0044 	addi	r22,r4,-1023
 320c244:	d8000815 	stw	zero,32(sp)
 320c248:	0005883a 	mov	r2,zero
 320c24c:	00cffe34 	movhi	r3,16376
 320c250:	480b883a 	mov	r5,r9
 320c254:	4009883a 	mov	r4,r8
 320c258:	180f883a 	mov	r7,r3
 320c25c:	100d883a 	mov	r6,r2
 320c260:	32131b80 	call	32131b8 <__subdf3>
 320c264:	0218dbf4 	movhi	r8,25455
 320c268:	4210d844 	addi	r8,r8,17249
 320c26c:	024ff4f4 	movhi	r9,16339
 320c270:	4a61e9c4 	addi	r9,r9,-30809
 320c274:	480f883a 	mov	r7,r9
 320c278:	400d883a 	mov	r6,r8
 320c27c:	180b883a 	mov	r5,r3
 320c280:	1009883a 	mov	r4,r2
 320c284:	32132ac0 	call	32132ac <__muldf3>
 320c288:	0222d874 	movhi	r8,35681
 320c28c:	42322cc4 	addi	r8,r8,-14157
 320c290:	024ff1f4 	movhi	r9,16327
 320c294:	4a628a04 	addi	r9,r9,-30168
 320c298:	480f883a 	mov	r7,r9
 320c29c:	400d883a 	mov	r6,r8
 320c2a0:	180b883a 	mov	r5,r3
 320c2a4:	1009883a 	mov	r4,r2
 320c2a8:	32132380 	call	3213238 <__adddf3>
 320c2ac:	b009883a 	mov	r4,r22
 320c2b0:	1021883a 	mov	r16,r2
 320c2b4:	1823883a 	mov	r17,r3
 320c2b8:	3213bf80 	call	3213bf8 <__floatsidf>
 320c2bc:	021427f4 	movhi	r8,20639
 320c2c0:	421e7ec4 	addi	r8,r8,31227
 320c2c4:	024ff4f4 	movhi	r9,16339
 320c2c8:	4a5104c4 	addi	r9,r9,17427
 320c2cc:	480f883a 	mov	r7,r9
 320c2d0:	400d883a 	mov	r6,r8
 320c2d4:	180b883a 	mov	r5,r3
 320c2d8:	1009883a 	mov	r4,r2
 320c2dc:	32132ac0 	call	32132ac <__muldf3>
 320c2e0:	180f883a 	mov	r7,r3
 320c2e4:	880b883a 	mov	r5,r17
 320c2e8:	100d883a 	mov	r6,r2
 320c2ec:	8009883a 	mov	r4,r16
 320c2f0:	32132380 	call	3213238 <__adddf3>
 320c2f4:	1009883a 	mov	r4,r2
 320c2f8:	180b883a 	mov	r5,r3
 320c2fc:	1021883a 	mov	r16,r2
 320c300:	1823883a 	mov	r17,r3
 320c304:	3213cf00 	call	3213cf0 <__fixdfsi>
 320c308:	000d883a 	mov	r6,zero
 320c30c:	000f883a 	mov	r7,zero
 320c310:	8009883a 	mov	r4,r16
 320c314:	880b883a 	mov	r5,r17
 320c318:	d8800d15 	stw	r2,52(sp)
 320c31c:	3213ae80 	call	3213ae8 <__ltdf2>
 320c320:	10031716 	blt	r2,zero,320cf80 <_dtoa_r+0xe8c>
 320c324:	d8c00d17 	ldw	r3,52(sp)
 320c328:	00800584 	movi	r2,22
 320c32c:	10c1482e 	bgeu	r2,r3,320c850 <_dtoa_r+0x75c>
 320c330:	01000044 	movi	r4,1
 320c334:	d9000c15 	stw	r4,48(sp)
 320c338:	bd85c83a 	sub	r2,r23,r22
 320c33c:	11bfffc4 	addi	r6,r2,-1
 320c340:	30030b16 	blt	r6,zero,320cf70 <_dtoa_r+0xe7c>
 320c344:	d9800a15 	stw	r6,40(sp)
 320c348:	d8001115 	stw	zero,68(sp)
 320c34c:	d8c00d17 	ldw	r3,52(sp)
 320c350:	1802ff16 	blt	r3,zero,320cf50 <_dtoa_r+0xe5c>
 320c354:	d9000a17 	ldw	r4,40(sp)
 320c358:	d8c00915 	stw	r3,36(sp)
 320c35c:	d8001015 	stw	zero,64(sp)
 320c360:	20c9883a 	add	r4,r4,r3
 320c364:	d9000a15 	stw	r4,40(sp)
 320c368:	d9001717 	ldw	r4,92(sp)
 320c36c:	00800244 	movi	r2,9
 320c370:	11004636 	bltu	r2,r4,320c48c <_dtoa_r+0x398>
 320c374:	00800144 	movi	r2,5
 320c378:	11020416 	blt	r2,r4,320cb8c <_dtoa_r+0xa98>
 320c37c:	04400044 	movi	r17,1
 320c380:	d8c01717 	ldw	r3,92(sp)
 320c384:	00800144 	movi	r2,5
 320c388:	10c1ed36 	bltu	r2,r3,320cb40 <_dtoa_r+0xa4c>
 320c38c:	18c5883a 	add	r2,r3,r3
 320c390:	1085883a 	add	r2,r2,r2
 320c394:	00c0c874 	movhi	r3,801
 320c398:	18f0ea04 	addi	r3,r3,-15448
 320c39c:	10c5883a 	add	r2,r2,r3
 320c3a0:	11000017 	ldw	r4,0(r2)
 320c3a4:	2000683a 	jmp	r4
 320c3a8:	0320c494 	movui	r12,33554
 320c3ac:	0320c494 	movui	r12,33554
 320c3b0:	0320ce94 	movui	r12,33594
 320c3b4:	0320ce6c 	andhi	r12,zero,33593
 320c3b8:	0320ceb0 	cmpltui	r12,zero,33594
 320c3bc:	0320cebc 	xorhi	r12,zero,33594
 320c3c0:	d9002717 	ldw	r4,156(sp)
 320c3c4:	0089c3c4 	movi	r2,9999
 320c3c8:	20800015 	stw	r2,0(r4)
 320c3cc:	a0001026 	beq	r20,zero,320c410 <_dtoa_r+0x31c>
 320c3d0:	00c0c974 	movhi	r3,805
 320c3d4:	18f8c204 	addi	r3,r3,-7416
 320c3d8:	d9802917 	ldw	r6,164(sp)
 320c3dc:	303f7926 	beq	r6,zero,320c1c4 <_dtoa_r+0xd0>
 320c3e0:	188000c7 	ldb	r2,3(r3)
 320c3e4:	190000c4 	addi	r4,r3,3
 320c3e8:	1000101e 	bne	r2,zero,320c42c <_dtoa_r+0x338>
 320c3ec:	d8802917 	ldw	r2,164(sp)
 320c3f0:	11000015 	stw	r4,0(r2)
 320c3f4:	003f7306 	br	320c1c4 <_dtoa_r+0xd0>
 320c3f8:	00a00034 	movhi	r2,32768
 320c3fc:	10bfffc4 	addi	r2,r2,-1
 320c400:	00c00044 	movi	r3,1
 320c404:	88aa703a 	and	r21,r17,r2
 320c408:	90c00015 	stw	r3,0(r18)
 320c40c:	003f5806 	br	320c170 <_dtoa_r+0x7c>
 320c410:	00800434 	movhi	r2,16
 320c414:	10bfffc4 	addi	r2,r2,-1
 320c418:	a884703a 	and	r2,r21,r2
 320c41c:	103fec1e 	bne	r2,zero,320c3d0 <_dtoa_r+0x2dc>
 320c420:	00c0c974 	movhi	r3,805
 320c424:	18f8bf04 	addi	r3,r3,-7428
 320c428:	003feb06 	br	320c3d8 <_dtoa_r+0x2e4>
 320c42c:	d8802917 	ldw	r2,164(sp)
 320c430:	19000204 	addi	r4,r3,8
 320c434:	11000015 	stw	r4,0(r2)
 320c438:	003f6206 	br	320c1c4 <_dtoa_r+0xd0>
 320c43c:	ddc00117 	ldw	r23,4(sp)
 320c440:	d8800217 	ldw	r2,8(sp)
 320c444:	01000804 	movi	r4,32
 320c448:	b8c10c84 	addi	r3,r23,1074
 320c44c:	18a3883a 	add	r17,r3,r2
 320c450:	2441b80e 	bge	r4,r17,320cb34 <_dtoa_r+0xa40>
 320c454:	00c01004 	movi	r3,64
 320c458:	1c47c83a 	sub	r3,r3,r17
 320c45c:	88bff804 	addi	r2,r17,-32
 320c460:	a8c6983a 	sll	r3,r21,r3
 320c464:	a084d83a 	srl	r2,r20,r2
 320c468:	1888b03a 	or	r4,r3,r2
 320c46c:	3213e3c0 	call	3213e3c <__floatunsidf>
 320c470:	1011883a 	mov	r8,r2
 320c474:	00bf8434 	movhi	r2,65040
 320c478:	01000044 	movi	r4,1
 320c47c:	10d3883a 	add	r9,r2,r3
 320c480:	8dbef344 	addi	r22,r17,-1075
 320c484:	d9000815 	stw	r4,32(sp)
 320c488:	003f6f06 	br	320c248 <_dtoa_r+0x154>
 320c48c:	d8001715 	stw	zero,92(sp)
 320c490:	04400044 	movi	r17,1
 320c494:	00bfffc4 	movi	r2,-1
 320c498:	00c00044 	movi	r3,1
 320c49c:	d8800e15 	stw	r2,56(sp)
 320c4a0:	d8002615 	stw	zero,152(sp)
 320c4a4:	d8800f15 	stw	r2,60(sp)
 320c4a8:	d8c00b15 	stw	r3,44(sp)
 320c4ac:	1021883a 	mov	r16,r2
 320c4b0:	d8801617 	ldw	r2,88(sp)
 320c4b4:	10001115 	stw	zero,68(r2)
 320c4b8:	d8801617 	ldw	r2,88(sp)
 320c4bc:	11401117 	ldw	r5,68(r2)
 320c4c0:	1009883a 	mov	r4,r2
 320c4c4:	320e2980 	call	320e298 <_Balloc>
 320c4c8:	d8c01617 	ldw	r3,88(sp)
 320c4cc:	d8800515 	stw	r2,20(sp)
 320c4d0:	18801015 	stw	r2,64(r3)
 320c4d4:	00800384 	movi	r2,14
 320c4d8:	14006836 	bltu	r2,r16,320c67c <_dtoa_r+0x588>
 320c4dc:	8805003a 	cmpeq	r2,r17,zero
 320c4e0:	1000661e 	bne	r2,zero,320c67c <_dtoa_r+0x588>
 320c4e4:	d9000d17 	ldw	r4,52(sp)
 320c4e8:	0102300e 	bge	zero,r4,320cdac <_dtoa_r+0xcb8>
 320c4ec:	208003cc 	andi	r2,r4,15
 320c4f0:	100490fa 	slli	r2,r2,3
 320c4f4:	2025d13a 	srai	r18,r4,4
 320c4f8:	00c0c974 	movhi	r3,805
 320c4fc:	18f8d304 	addi	r3,r3,-7348
 320c500:	10c5883a 	add	r2,r2,r3
 320c504:	90c0040c 	andi	r3,r18,16
 320c508:	14000017 	ldw	r16,0(r2)
 320c50c:	14400117 	ldw	r17,4(r2)
 320c510:	18036a1e 	bne	r3,zero,320d2bc <_dtoa_r+0x11c8>
 320c514:	05800084 	movi	r22,2
 320c518:	90001026 	beq	r18,zero,320c55c <_dtoa_r+0x468>
 320c51c:	04c0c974 	movhi	r19,805
 320c520:	9cf90504 	addi	r19,r19,-7148
 320c524:	9080004c 	andi	r2,r18,1
 320c528:	1005003a 	cmpeq	r2,r2,zero
 320c52c:	1000081e 	bne	r2,zero,320c550 <_dtoa_r+0x45c>
 320c530:	99800017 	ldw	r6,0(r19)
 320c534:	99c00117 	ldw	r7,4(r19)
 320c538:	880b883a 	mov	r5,r17
 320c53c:	8009883a 	mov	r4,r16
 320c540:	32132ac0 	call	32132ac <__muldf3>
 320c544:	1021883a 	mov	r16,r2
 320c548:	b5800044 	addi	r22,r22,1
 320c54c:	1823883a 	mov	r17,r3
 320c550:	9025d07a 	srai	r18,r18,1
 320c554:	9cc00204 	addi	r19,r19,8
 320c558:	903ff21e 	bne	r18,zero,320c524 <_dtoa_r+0x430>
 320c55c:	a80b883a 	mov	r5,r21
 320c560:	a009883a 	mov	r4,r20
 320c564:	880f883a 	mov	r7,r17
 320c568:	800d883a 	mov	r6,r16
 320c56c:	32136700 	call	3213670 <__divdf3>
 320c570:	1029883a 	mov	r20,r2
 320c574:	182b883a 	mov	r21,r3
 320c578:	d8c00c17 	ldw	r3,48(sp)
 320c57c:	1805003a 	cmpeq	r2,r3,zero
 320c580:	1000081e 	bne	r2,zero,320c5a4 <_dtoa_r+0x4b0>
 320c584:	0005883a 	mov	r2,zero
 320c588:	00cffc34 	movhi	r3,16368
 320c58c:	180f883a 	mov	r7,r3
 320c590:	a009883a 	mov	r4,r20
 320c594:	a80b883a 	mov	r5,r21
 320c598:	100d883a 	mov	r6,r2
 320c59c:	3213ae80 	call	3213ae8 <__ltdf2>
 320c5a0:	1003fe16 	blt	r2,zero,320d59c <_dtoa_r+0x14a8>
 320c5a4:	b009883a 	mov	r4,r22
 320c5a8:	3213bf80 	call	3213bf8 <__floatsidf>
 320c5ac:	180b883a 	mov	r5,r3
 320c5b0:	1009883a 	mov	r4,r2
 320c5b4:	a00d883a 	mov	r6,r20
 320c5b8:	a80f883a 	mov	r7,r21
 320c5bc:	32132ac0 	call	32132ac <__muldf3>
 320c5c0:	0011883a 	mov	r8,zero
 320c5c4:	02500734 	movhi	r9,16412
 320c5c8:	1009883a 	mov	r4,r2
 320c5cc:	180b883a 	mov	r5,r3
 320c5d0:	480f883a 	mov	r7,r9
 320c5d4:	400d883a 	mov	r6,r8
 320c5d8:	32132380 	call	3213238 <__adddf3>
 320c5dc:	d9000f17 	ldw	r4,60(sp)
 320c5e0:	102d883a 	mov	r22,r2
 320c5e4:	00bf3034 	movhi	r2,64704
 320c5e8:	18b9883a 	add	fp,r3,r2
 320c5ec:	e02f883a 	mov	r23,fp
 320c5f0:	20028f1e 	bne	r4,zero,320d030 <_dtoa_r+0xf3c>
 320c5f4:	0005883a 	mov	r2,zero
 320c5f8:	00d00534 	movhi	r3,16404
 320c5fc:	a009883a 	mov	r4,r20
 320c600:	a80b883a 	mov	r5,r21
 320c604:	180f883a 	mov	r7,r3
 320c608:	100d883a 	mov	r6,r2
 320c60c:	32131b80 	call	32131b8 <__subdf3>
 320c610:	1009883a 	mov	r4,r2
 320c614:	e00f883a 	mov	r7,fp
 320c618:	180b883a 	mov	r5,r3
 320c61c:	b00d883a 	mov	r6,r22
 320c620:	1025883a 	mov	r18,r2
 320c624:	1827883a 	mov	r19,r3
 320c628:	32139d80 	call	32139d8 <__gtdf2>
 320c62c:	00834f16 	blt	zero,r2,320d36c <_dtoa_r+0x1278>
 320c630:	e0e0003c 	xorhi	r3,fp,32768
 320c634:	9009883a 	mov	r4,r18
 320c638:	980b883a 	mov	r5,r19
 320c63c:	180f883a 	mov	r7,r3
 320c640:	b00d883a 	mov	r6,r22
 320c644:	3213ae80 	call	3213ae8 <__ltdf2>
 320c648:	1000080e 	bge	r2,zero,320c66c <_dtoa_r+0x578>
 320c64c:	0027883a 	mov	r19,zero
 320c650:	0025883a 	mov	r18,zero
 320c654:	d8802617 	ldw	r2,152(sp)
 320c658:	df000517 	ldw	fp,20(sp)
 320c65c:	d8000615 	stw	zero,24(sp)
 320c660:	0084303a 	nor	r2,zero,r2
 320c664:	d8800d15 	stw	r2,52(sp)
 320c668:	00019b06 	br	320ccd8 <_dtoa_r+0xbe4>
 320c66c:	d9801217 	ldw	r6,72(sp)
 320c670:	d8801317 	ldw	r2,76(sp)
 320c674:	3029883a 	mov	r20,r6
 320c678:	102b883a 	mov	r21,r2
 320c67c:	d8c00217 	ldw	r3,8(sp)
 320c680:	18008516 	blt	r3,zero,320c898 <_dtoa_r+0x7a4>
 320c684:	d9000d17 	ldw	r4,52(sp)
 320c688:	00800384 	movi	r2,14
 320c68c:	11008216 	blt	r2,r4,320c898 <_dtoa_r+0x7a4>
 320c690:	200490fa 	slli	r2,r4,3
 320c694:	d9802617 	ldw	r6,152(sp)
 320c698:	00c0c974 	movhi	r3,805
 320c69c:	18f8d304 	addi	r3,r3,-7348
 320c6a0:	10c5883a 	add	r2,r2,r3
 320c6a4:	14800017 	ldw	r18,0(r2)
 320c6a8:	14c00117 	ldw	r19,4(r2)
 320c6ac:	30031e16 	blt	r6,zero,320d328 <_dtoa_r+0x1234>
 320c6b0:	d9000517 	ldw	r4,20(sp)
 320c6b4:	d8c00f17 	ldw	r3,60(sp)
 320c6b8:	a823883a 	mov	r17,r21
 320c6bc:	a021883a 	mov	r16,r20
 320c6c0:	192b883a 	add	r21,r3,r4
 320c6c4:	2039883a 	mov	fp,r4
 320c6c8:	00000f06 	br	320c708 <_dtoa_r+0x614>
 320c6cc:	0005883a 	mov	r2,zero
 320c6d0:	00d00934 	movhi	r3,16420
 320c6d4:	5009883a 	mov	r4,r10
 320c6d8:	580b883a 	mov	r5,r11
 320c6dc:	180f883a 	mov	r7,r3
 320c6e0:	100d883a 	mov	r6,r2
 320c6e4:	32132ac0 	call	32132ac <__muldf3>
 320c6e8:	180b883a 	mov	r5,r3
 320c6ec:	000d883a 	mov	r6,zero
 320c6f0:	000f883a 	mov	r7,zero
 320c6f4:	1009883a 	mov	r4,r2
 320c6f8:	1021883a 	mov	r16,r2
 320c6fc:	1823883a 	mov	r17,r3
 320c700:	32139500 	call	3213950 <__nedf2>
 320c704:	10004526 	beq	r2,zero,320c81c <_dtoa_r+0x728>
 320c708:	900d883a 	mov	r6,r18
 320c70c:	980f883a 	mov	r7,r19
 320c710:	8009883a 	mov	r4,r16
 320c714:	880b883a 	mov	r5,r17
 320c718:	32136700 	call	3213670 <__divdf3>
 320c71c:	180b883a 	mov	r5,r3
 320c720:	1009883a 	mov	r4,r2
 320c724:	3213cf00 	call	3213cf0 <__fixdfsi>
 320c728:	1009883a 	mov	r4,r2
 320c72c:	1029883a 	mov	r20,r2
 320c730:	3213bf80 	call	3213bf8 <__floatsidf>
 320c734:	180f883a 	mov	r7,r3
 320c738:	9009883a 	mov	r4,r18
 320c73c:	980b883a 	mov	r5,r19
 320c740:	100d883a 	mov	r6,r2
 320c744:	32132ac0 	call	32132ac <__muldf3>
 320c748:	180f883a 	mov	r7,r3
 320c74c:	880b883a 	mov	r5,r17
 320c750:	8009883a 	mov	r4,r16
 320c754:	100d883a 	mov	r6,r2
 320c758:	32131b80 	call	32131b8 <__subdf3>
 320c75c:	1015883a 	mov	r10,r2
 320c760:	a0800c04 	addi	r2,r20,48
 320c764:	e0800005 	stb	r2,0(fp)
 320c768:	e7000044 	addi	fp,fp,1
 320c76c:	1817883a 	mov	r11,r3
 320c770:	e57fd61e 	bne	fp,r21,320c6cc <_dtoa_r+0x5d8>
 320c774:	500d883a 	mov	r6,r10
 320c778:	180f883a 	mov	r7,r3
 320c77c:	5009883a 	mov	r4,r10
 320c780:	180b883a 	mov	r5,r3
 320c784:	32132380 	call	3213238 <__adddf3>
 320c788:	100d883a 	mov	r6,r2
 320c78c:	9009883a 	mov	r4,r18
 320c790:	980b883a 	mov	r5,r19
 320c794:	180f883a 	mov	r7,r3
 320c798:	1021883a 	mov	r16,r2
 320c79c:	1823883a 	mov	r17,r3
 320c7a0:	3213ae80 	call	3213ae8 <__ltdf2>
 320c7a4:	10000816 	blt	r2,zero,320c7c8 <_dtoa_r+0x6d4>
 320c7a8:	980b883a 	mov	r5,r19
 320c7ac:	800d883a 	mov	r6,r16
 320c7b0:	880f883a 	mov	r7,r17
 320c7b4:	9009883a 	mov	r4,r18
 320c7b8:	32138c80 	call	32138c8 <__eqdf2>
 320c7bc:	1000171e 	bne	r2,zero,320c81c <_dtoa_r+0x728>
 320c7c0:	a080004c 	andi	r2,r20,1
 320c7c4:	10001526 	beq	r2,zero,320c81c <_dtoa_r+0x728>
 320c7c8:	d8800d17 	ldw	r2,52(sp)
 320c7cc:	d8800415 	stw	r2,16(sp)
 320c7d0:	e009883a 	mov	r4,fp
 320c7d4:	213fffc4 	addi	r4,r4,-1
 320c7d8:	20c00007 	ldb	r3,0(r4)
 320c7dc:	00800e44 	movi	r2,57
 320c7e0:	1880081e 	bne	r3,r2,320c804 <_dtoa_r+0x710>
 320c7e4:	d8800517 	ldw	r2,20(sp)
 320c7e8:	113ffa1e 	bne	r2,r4,320c7d4 <_dtoa_r+0x6e0>
 320c7ec:	d8c00417 	ldw	r3,16(sp)
 320c7f0:	d9800517 	ldw	r6,20(sp)
 320c7f4:	00800c04 	movi	r2,48
 320c7f8:	18c00044 	addi	r3,r3,1
 320c7fc:	d8c00415 	stw	r3,16(sp)
 320c800:	30800005 	stb	r2,0(r6)
 320c804:	20800003 	ldbu	r2,0(r4)
 320c808:	d8c00417 	ldw	r3,16(sp)
 320c80c:	27000044 	addi	fp,r4,1
 320c810:	10800044 	addi	r2,r2,1
 320c814:	d8c00d15 	stw	r3,52(sp)
 320c818:	20800005 	stb	r2,0(r4)
 320c81c:	d9001617 	ldw	r4,88(sp)
 320c820:	d9400717 	ldw	r5,28(sp)
 320c824:	320dd180 	call	320dd18 <_Bfree>
 320c828:	e0000005 	stb	zero,0(fp)
 320c82c:	d9800d17 	ldw	r6,52(sp)
 320c830:	d8c02717 	ldw	r3,156(sp)
 320c834:	d9002917 	ldw	r4,164(sp)
 320c838:	30800044 	addi	r2,r6,1
 320c83c:	18800015 	stw	r2,0(r3)
 320c840:	20029c26 	beq	r4,zero,320d2b4 <_dtoa_r+0x11c0>
 320c844:	d8c00517 	ldw	r3,20(sp)
 320c848:	27000015 	stw	fp,0(r4)
 320c84c:	003e5d06 	br	320c1c4 <_dtoa_r+0xd0>
 320c850:	d9800d17 	ldw	r6,52(sp)
 320c854:	00c0c974 	movhi	r3,805
 320c858:	18f8d304 	addi	r3,r3,-7348
 320c85c:	d9001217 	ldw	r4,72(sp)
 320c860:	300490fa 	slli	r2,r6,3
 320c864:	d9401317 	ldw	r5,76(sp)
 320c868:	10c5883a 	add	r2,r2,r3
 320c86c:	12000017 	ldw	r8,0(r2)
 320c870:	12400117 	ldw	r9,4(r2)
 320c874:	400d883a 	mov	r6,r8
 320c878:	480f883a 	mov	r7,r9
 320c87c:	3213ae80 	call	3213ae8 <__ltdf2>
 320c880:	1000030e 	bge	r2,zero,320c890 <_dtoa_r+0x79c>
 320c884:	d8800d17 	ldw	r2,52(sp)
 320c888:	10bfffc4 	addi	r2,r2,-1
 320c88c:	d8800d15 	stw	r2,52(sp)
 320c890:	d8000c15 	stw	zero,48(sp)
 320c894:	003ea806 	br	320c338 <_dtoa_r+0x244>
 320c898:	d9000b17 	ldw	r4,44(sp)
 320c89c:	202cc03a 	cmpne	r22,r4,zero
 320c8a0:	b000c71e 	bne	r22,zero,320cbc0 <_dtoa_r+0xacc>
 320c8a4:	dc001117 	ldw	r16,68(sp)
 320c8a8:	dc801017 	ldw	r18,64(sp)
 320c8ac:	0027883a 	mov	r19,zero
 320c8b0:	04000b0e 	bge	zero,r16,320c8e0 <_dtoa_r+0x7ec>
 320c8b4:	d8c00a17 	ldw	r3,40(sp)
 320c8b8:	00c0090e 	bge	zero,r3,320c8e0 <_dtoa_r+0x7ec>
 320c8bc:	8005883a 	mov	r2,r16
 320c8c0:	1c011316 	blt	r3,r16,320cd10 <_dtoa_r+0xc1c>
 320c8c4:	d9000a17 	ldw	r4,40(sp)
 320c8c8:	d9801117 	ldw	r6,68(sp)
 320c8cc:	80a1c83a 	sub	r16,r16,r2
 320c8d0:	2089c83a 	sub	r4,r4,r2
 320c8d4:	308dc83a 	sub	r6,r6,r2
 320c8d8:	d9000a15 	stw	r4,40(sp)
 320c8dc:	d9801115 	stw	r6,68(sp)
 320c8e0:	d8801017 	ldw	r2,64(sp)
 320c8e4:	0080150e 	bge	zero,r2,320c93c <_dtoa_r+0x848>
 320c8e8:	d8c00b17 	ldw	r3,44(sp)
 320c8ec:	1805003a 	cmpeq	r2,r3,zero
 320c8f0:	1001c91e 	bne	r2,zero,320d018 <_dtoa_r+0xf24>
 320c8f4:	04800e0e 	bge	zero,r18,320c930 <_dtoa_r+0x83c>
 320c8f8:	d9001617 	ldw	r4,88(sp)
 320c8fc:	980b883a 	mov	r5,r19
 320c900:	900d883a 	mov	r6,r18
 320c904:	320eacc0 	call	320eacc <__pow5mult>
 320c908:	d9001617 	ldw	r4,88(sp)
 320c90c:	d9800717 	ldw	r6,28(sp)
 320c910:	100b883a 	mov	r5,r2
 320c914:	1027883a 	mov	r19,r2
 320c918:	320e7a80 	call	320e7a8 <__multiply>
 320c91c:	d9001617 	ldw	r4,88(sp)
 320c920:	d9400717 	ldw	r5,28(sp)
 320c924:	1023883a 	mov	r17,r2
 320c928:	320dd180 	call	320dd18 <_Bfree>
 320c92c:	dc400715 	stw	r17,28(sp)
 320c930:	d9001017 	ldw	r4,64(sp)
 320c934:	248dc83a 	sub	r6,r4,r18
 320c938:	30010e1e 	bne	r6,zero,320cd74 <_dtoa_r+0xc80>
 320c93c:	d9001617 	ldw	r4,88(sp)
 320c940:	04400044 	movi	r17,1
 320c944:	880b883a 	mov	r5,r17
 320c948:	320e9900 	call	320e990 <__i2b>
 320c94c:	d9800917 	ldw	r6,36(sp)
 320c950:	1025883a 	mov	r18,r2
 320c954:	0180040e 	bge	zero,r6,320c968 <_dtoa_r+0x874>
 320c958:	d9001617 	ldw	r4,88(sp)
 320c95c:	100b883a 	mov	r5,r2
 320c960:	320eacc0 	call	320eacc <__pow5mult>
 320c964:	1025883a 	mov	r18,r2
 320c968:	d8801717 	ldw	r2,92(sp)
 320c96c:	8880f30e 	bge	r17,r2,320cd3c <_dtoa_r+0xc48>
 320c970:	0023883a 	mov	r17,zero
 320c974:	d9800917 	ldw	r6,36(sp)
 320c978:	30019e1e 	bne	r6,zero,320cff4 <_dtoa_r+0xf00>
 320c97c:	00c00044 	movi	r3,1
 320c980:	d9000a17 	ldw	r4,40(sp)
 320c984:	20c5883a 	add	r2,r4,r3
 320c988:	10c007cc 	andi	r3,r2,31
 320c98c:	1800841e 	bne	r3,zero,320cba0 <_dtoa_r+0xaac>
 320c990:	00800704 	movi	r2,28
 320c994:	d9000a17 	ldw	r4,40(sp)
 320c998:	d9801117 	ldw	r6,68(sp)
 320c99c:	80a1883a 	add	r16,r16,r2
 320c9a0:	2089883a 	add	r4,r4,r2
 320c9a4:	308d883a 	add	r6,r6,r2
 320c9a8:	d9000a15 	stw	r4,40(sp)
 320c9ac:	d9801115 	stw	r6,68(sp)
 320c9b0:	d8801117 	ldw	r2,68(sp)
 320c9b4:	0080050e 	bge	zero,r2,320c9cc <_dtoa_r+0x8d8>
 320c9b8:	d9400717 	ldw	r5,28(sp)
 320c9bc:	d9001617 	ldw	r4,88(sp)
 320c9c0:	100d883a 	mov	r6,r2
 320c9c4:	320e65c0 	call	320e65c <__lshift>
 320c9c8:	d8800715 	stw	r2,28(sp)
 320c9cc:	d8c00a17 	ldw	r3,40(sp)
 320c9d0:	00c0050e 	bge	zero,r3,320c9e8 <_dtoa_r+0x8f4>
 320c9d4:	d9001617 	ldw	r4,88(sp)
 320c9d8:	900b883a 	mov	r5,r18
 320c9dc:	180d883a 	mov	r6,r3
 320c9e0:	320e65c0 	call	320e65c <__lshift>
 320c9e4:	1025883a 	mov	r18,r2
 320c9e8:	d9000c17 	ldw	r4,48(sp)
 320c9ec:	2005003a 	cmpeq	r2,r4,zero
 320c9f0:	10016f26 	beq	r2,zero,320cfb0 <_dtoa_r+0xebc>
 320c9f4:	d9000f17 	ldw	r4,60(sp)
 320c9f8:	0102170e 	bge	zero,r4,320d258 <_dtoa_r+0x1164>
 320c9fc:	d9800b17 	ldw	r6,44(sp)
 320ca00:	3005003a 	cmpeq	r2,r6,zero
 320ca04:	1000881e 	bne	r2,zero,320cc28 <_dtoa_r+0xb34>
 320ca08:	0400050e 	bge	zero,r16,320ca20 <_dtoa_r+0x92c>
 320ca0c:	d9001617 	ldw	r4,88(sp)
 320ca10:	980b883a 	mov	r5,r19
 320ca14:	800d883a 	mov	r6,r16
 320ca18:	320e65c0 	call	320e65c <__lshift>
 320ca1c:	1027883a 	mov	r19,r2
 320ca20:	8804c03a 	cmpne	r2,r17,zero
 320ca24:	1002541e 	bne	r2,zero,320d378 <_dtoa_r+0x1284>
 320ca28:	980b883a 	mov	r5,r19
 320ca2c:	dd800517 	ldw	r22,20(sp)
 320ca30:	dcc00615 	stw	r19,24(sp)
 320ca34:	a700004c 	andi	fp,r20,1
 320ca38:	2827883a 	mov	r19,r5
 320ca3c:	d9000717 	ldw	r4,28(sp)
 320ca40:	900b883a 	mov	r5,r18
 320ca44:	320bedc0 	call	320bedc <quorem>
 320ca48:	d9000717 	ldw	r4,28(sp)
 320ca4c:	d9400617 	ldw	r5,24(sp)
 320ca50:	1023883a 	mov	r17,r2
 320ca54:	8dc00c04 	addi	r23,r17,48
 320ca58:	320de740 	call	320de74 <__mcmp>
 320ca5c:	d9001617 	ldw	r4,88(sp)
 320ca60:	900b883a 	mov	r5,r18
 320ca64:	980d883a 	mov	r6,r19
 320ca68:	1029883a 	mov	r20,r2
 320ca6c:	320e4d00 	call	320e4d0 <__mdiff>
 320ca70:	102b883a 	mov	r21,r2
 320ca74:	10800317 	ldw	r2,12(r2)
 320ca78:	1001281e 	bne	r2,zero,320cf1c <_dtoa_r+0xe28>
 320ca7c:	d9000717 	ldw	r4,28(sp)
 320ca80:	a80b883a 	mov	r5,r21
 320ca84:	320de740 	call	320de74 <__mcmp>
 320ca88:	d9001617 	ldw	r4,88(sp)
 320ca8c:	1021883a 	mov	r16,r2
 320ca90:	a80b883a 	mov	r5,r21
 320ca94:	320dd180 	call	320dd18 <_Bfree>
 320ca98:	8000041e 	bne	r16,zero,320caac <_dtoa_r+0x9b8>
 320ca9c:	d8801717 	ldw	r2,92(sp)
 320caa0:	1000021e 	bne	r2,zero,320caac <_dtoa_r+0x9b8>
 320caa4:	e004c03a 	cmpne	r2,fp,zero
 320caa8:	10011726 	beq	r2,zero,320cf08 <_dtoa_r+0xe14>
 320caac:	a0010616 	blt	r20,zero,320cec8 <_dtoa_r+0xdd4>
 320cab0:	a000041e 	bne	r20,zero,320cac4 <_dtoa_r+0x9d0>
 320cab4:	d8c01717 	ldw	r3,92(sp)
 320cab8:	1800021e 	bne	r3,zero,320cac4 <_dtoa_r+0x9d0>
 320cabc:	e004c03a 	cmpne	r2,fp,zero
 320cac0:	10010126 	beq	r2,zero,320cec8 <_dtoa_r+0xdd4>
 320cac4:	04023d16 	blt	zero,r16,320d3bc <_dtoa_r+0x12c8>
 320cac8:	b5c00005 	stb	r23,0(r22)
 320cacc:	d9800517 	ldw	r6,20(sp)
 320cad0:	d9000f17 	ldw	r4,60(sp)
 320cad4:	b5800044 	addi	r22,r22,1
 320cad8:	3105883a 	add	r2,r6,r4
 320cadc:	b0806526 	beq	r22,r2,320cc74 <_dtoa_r+0xb80>
 320cae0:	d9400717 	ldw	r5,28(sp)
 320cae4:	d9001617 	ldw	r4,88(sp)
 320cae8:	01800284 	movi	r6,10
 320caec:	000f883a 	mov	r7,zero
 320caf0:	320e9cc0 	call	320e9cc <__multadd>
 320caf4:	d8800715 	stw	r2,28(sp)
 320caf8:	d8800617 	ldw	r2,24(sp)
 320cafc:	14c10c26 	beq	r2,r19,320cf30 <_dtoa_r+0xe3c>
 320cb00:	d9400617 	ldw	r5,24(sp)
 320cb04:	d9001617 	ldw	r4,88(sp)
 320cb08:	01800284 	movi	r6,10
 320cb0c:	000f883a 	mov	r7,zero
 320cb10:	320e9cc0 	call	320e9cc <__multadd>
 320cb14:	d9001617 	ldw	r4,88(sp)
 320cb18:	980b883a 	mov	r5,r19
 320cb1c:	01800284 	movi	r6,10
 320cb20:	000f883a 	mov	r7,zero
 320cb24:	d8800615 	stw	r2,24(sp)
 320cb28:	320e9cc0 	call	320e9cc <__multadd>
 320cb2c:	1027883a 	mov	r19,r2
 320cb30:	003fc206 	br	320ca3c <_dtoa_r+0x948>
 320cb34:	2445c83a 	sub	r2,r4,r17
 320cb38:	a088983a 	sll	r4,r20,r2
 320cb3c:	003e4b06 	br	320c46c <_dtoa_r+0x378>
 320cb40:	01bfffc4 	movi	r6,-1
 320cb44:	00800044 	movi	r2,1
 320cb48:	d9800e15 	stw	r6,56(sp)
 320cb4c:	d9800f15 	stw	r6,60(sp)
 320cb50:	d8800b15 	stw	r2,44(sp)
 320cb54:	d8c01617 	ldw	r3,88(sp)
 320cb58:	008005c4 	movi	r2,23
 320cb5c:	18001115 	stw	zero,68(r3)
 320cb60:	1580082e 	bgeu	r2,r22,320cb84 <_dtoa_r+0xa90>
 320cb64:	00c00104 	movi	r3,4
 320cb68:	0009883a 	mov	r4,zero
 320cb6c:	18c7883a 	add	r3,r3,r3
 320cb70:	18800504 	addi	r2,r3,20
 320cb74:	21000044 	addi	r4,r4,1
 320cb78:	b0bffc2e 	bgeu	r22,r2,320cb6c <_dtoa_r+0xa78>
 320cb7c:	d9801617 	ldw	r6,88(sp)
 320cb80:	31001115 	stw	r4,68(r6)
 320cb84:	dc000f17 	ldw	r16,60(sp)
 320cb88:	003e4b06 	br	320c4b8 <_dtoa_r+0x3c4>
 320cb8c:	d9801717 	ldw	r6,92(sp)
 320cb90:	0023883a 	mov	r17,zero
 320cb94:	31bfff04 	addi	r6,r6,-4
 320cb98:	d9801715 	stw	r6,92(sp)
 320cb9c:	003df806 	br	320c380 <_dtoa_r+0x28c>
 320cba0:	00800804 	movi	r2,32
 320cba4:	10c9c83a 	sub	r4,r2,r3
 320cba8:	00c00104 	movi	r3,4
 320cbac:	19005a16 	blt	r3,r4,320cd18 <_dtoa_r+0xc24>
 320cbb0:	008000c4 	movi	r2,3
 320cbb4:	113f7e16 	blt	r2,r4,320c9b0 <_dtoa_r+0x8bc>
 320cbb8:	20800704 	addi	r2,r4,28
 320cbbc:	003f7506 	br	320c994 <_dtoa_r+0x8a0>
 320cbc0:	d9801717 	ldw	r6,92(sp)
 320cbc4:	00800044 	movi	r2,1
 320cbc8:	1180a10e 	bge	r2,r6,320ce50 <_dtoa_r+0xd5c>
 320cbcc:	d9800f17 	ldw	r6,60(sp)
 320cbd0:	d8c01017 	ldw	r3,64(sp)
 320cbd4:	30bfffc4 	addi	r2,r6,-1
 320cbd8:	1881c616 	blt	r3,r2,320d2f4 <_dtoa_r+0x1200>
 320cbdc:	18a5c83a 	sub	r18,r3,r2
 320cbe0:	d8800f17 	ldw	r2,60(sp)
 320cbe4:	10026216 	blt	r2,zero,320d570 <_dtoa_r+0x147c>
 320cbe8:	dc001117 	ldw	r16,68(sp)
 320cbec:	1007883a 	mov	r3,r2
 320cbf0:	d9800a17 	ldw	r6,40(sp)
 320cbf4:	d8801117 	ldw	r2,68(sp)
 320cbf8:	d9001617 	ldw	r4,88(sp)
 320cbfc:	30cd883a 	add	r6,r6,r3
 320cc00:	10c5883a 	add	r2,r2,r3
 320cc04:	01400044 	movi	r5,1
 320cc08:	d9800a15 	stw	r6,40(sp)
 320cc0c:	d8801115 	stw	r2,68(sp)
 320cc10:	320e9900 	call	320e990 <__i2b>
 320cc14:	1027883a 	mov	r19,r2
 320cc18:	003f2506 	br	320c8b0 <_dtoa_r+0x7bc>
 320cc1c:	00c0c974 	movhi	r3,805
 320cc20:	18f8ac04 	addi	r3,r3,-7504
 320cc24:	003d6706 	br	320c1c4 <_dtoa_r+0xd0>
 320cc28:	dd800517 	ldw	r22,20(sp)
 320cc2c:	04000044 	movi	r16,1
 320cc30:	00000706 	br	320cc50 <_dtoa_r+0xb5c>
 320cc34:	d9400717 	ldw	r5,28(sp)
 320cc38:	d9001617 	ldw	r4,88(sp)
 320cc3c:	01800284 	movi	r6,10
 320cc40:	000f883a 	mov	r7,zero
 320cc44:	320e9cc0 	call	320e9cc <__multadd>
 320cc48:	d8800715 	stw	r2,28(sp)
 320cc4c:	84000044 	addi	r16,r16,1
 320cc50:	d9000717 	ldw	r4,28(sp)
 320cc54:	900b883a 	mov	r5,r18
 320cc58:	320bedc0 	call	320bedc <quorem>
 320cc5c:	15c00c04 	addi	r23,r2,48
 320cc60:	b5c00005 	stb	r23,0(r22)
 320cc64:	d8c00f17 	ldw	r3,60(sp)
 320cc68:	b5800044 	addi	r22,r22,1
 320cc6c:	80fff116 	blt	r16,r3,320cc34 <_dtoa_r+0xb40>
 320cc70:	d8000615 	stw	zero,24(sp)
 320cc74:	d9400717 	ldw	r5,28(sp)
 320cc78:	d9001617 	ldw	r4,88(sp)
 320cc7c:	01800044 	movi	r6,1
 320cc80:	320e65c0 	call	320e65c <__lshift>
 320cc84:	1009883a 	mov	r4,r2
 320cc88:	900b883a 	mov	r5,r18
 320cc8c:	d8800715 	stw	r2,28(sp)
 320cc90:	320de740 	call	320de74 <__mcmp>
 320cc94:	00803c0e 	bge	zero,r2,320cd88 <_dtoa_r+0xc94>
 320cc98:	b009883a 	mov	r4,r22
 320cc9c:	213fffc4 	addi	r4,r4,-1
 320cca0:	21400003 	ldbu	r5,0(r4)
 320cca4:	00800e44 	movi	r2,57
 320cca8:	28c03fcc 	andi	r3,r5,255
 320ccac:	18c0201c 	xori	r3,r3,128
 320ccb0:	18ffe004 	addi	r3,r3,-128
 320ccb4:	1881981e 	bne	r3,r2,320d318 <_dtoa_r+0x1224>
 320ccb8:	d9800517 	ldw	r6,20(sp)
 320ccbc:	21bff71e 	bne	r4,r6,320cc9c <_dtoa_r+0xba8>
 320ccc0:	d8800d17 	ldw	r2,52(sp)
 320ccc4:	37000044 	addi	fp,r6,1
 320ccc8:	10800044 	addi	r2,r2,1
 320cccc:	d8800d15 	stw	r2,52(sp)
 320ccd0:	00800c44 	movi	r2,49
 320ccd4:	30800005 	stb	r2,0(r6)
 320ccd8:	d9001617 	ldw	r4,88(sp)
 320ccdc:	900b883a 	mov	r5,r18
 320cce0:	320dd180 	call	320dd18 <_Bfree>
 320cce4:	983ecd26 	beq	r19,zero,320c81c <_dtoa_r+0x728>
 320cce8:	d8c00617 	ldw	r3,24(sp)
 320ccec:	18000426 	beq	r3,zero,320cd00 <_dtoa_r+0xc0c>
 320ccf0:	1cc00326 	beq	r3,r19,320cd00 <_dtoa_r+0xc0c>
 320ccf4:	d9001617 	ldw	r4,88(sp)
 320ccf8:	180b883a 	mov	r5,r3
 320ccfc:	320dd180 	call	320dd18 <_Bfree>
 320cd00:	d9001617 	ldw	r4,88(sp)
 320cd04:	980b883a 	mov	r5,r19
 320cd08:	320dd180 	call	320dd18 <_Bfree>
 320cd0c:	003ec306 	br	320c81c <_dtoa_r+0x728>
 320cd10:	1805883a 	mov	r2,r3
 320cd14:	003eeb06 	br	320c8c4 <_dtoa_r+0x7d0>
 320cd18:	d9800a17 	ldw	r6,40(sp)
 320cd1c:	d8c01117 	ldw	r3,68(sp)
 320cd20:	20bfff04 	addi	r2,r4,-4
 320cd24:	308d883a 	add	r6,r6,r2
 320cd28:	1887883a 	add	r3,r3,r2
 320cd2c:	80a1883a 	add	r16,r16,r2
 320cd30:	d9800a15 	stw	r6,40(sp)
 320cd34:	d8c01115 	stw	r3,68(sp)
 320cd38:	003f1d06 	br	320c9b0 <_dtoa_r+0x8bc>
 320cd3c:	a03f0c1e 	bne	r20,zero,320c970 <_dtoa_r+0x87c>
 320cd40:	00800434 	movhi	r2,16
 320cd44:	10bfffc4 	addi	r2,r2,-1
 320cd48:	a884703a 	and	r2,r21,r2
 320cd4c:	103f081e 	bne	r2,zero,320c970 <_dtoa_r+0x87c>
 320cd50:	a89ffc2c 	andhi	r2,r21,32752
 320cd54:	103f0626 	beq	r2,zero,320c970 <_dtoa_r+0x87c>
 320cd58:	d8c01117 	ldw	r3,68(sp)
 320cd5c:	d9000a17 	ldw	r4,40(sp)
 320cd60:	18c00044 	addi	r3,r3,1
 320cd64:	21000044 	addi	r4,r4,1
 320cd68:	d8c01115 	stw	r3,68(sp)
 320cd6c:	d9000a15 	stw	r4,40(sp)
 320cd70:	003f0006 	br	320c974 <_dtoa_r+0x880>
 320cd74:	d9400717 	ldw	r5,28(sp)
 320cd78:	d9001617 	ldw	r4,88(sp)
 320cd7c:	320eacc0 	call	320eacc <__pow5mult>
 320cd80:	d8800715 	stw	r2,28(sp)
 320cd84:	003eed06 	br	320c93c <_dtoa_r+0x848>
 320cd88:	1000021e 	bne	r2,zero,320cd94 <_dtoa_r+0xca0>
 320cd8c:	b880004c 	andi	r2,r23,1
 320cd90:	103fc11e 	bne	r2,zero,320cc98 <_dtoa_r+0xba4>
 320cd94:	b5bfffc4 	addi	r22,r22,-1
 320cd98:	b0c00007 	ldb	r3,0(r22)
 320cd9c:	00800c04 	movi	r2,48
 320cda0:	18bffc26 	beq	r3,r2,320cd94 <_dtoa_r+0xca0>
 320cda4:	b7000044 	addi	fp,r22,1
 320cda8:	003fcb06 	br	320ccd8 <_dtoa_r+0xbe4>
 320cdac:	d9800d17 	ldw	r6,52(sp)
 320cdb0:	018fc83a 	sub	r7,zero,r6
 320cdb4:	3801f726 	beq	r7,zero,320d594 <_dtoa_r+0x14a0>
 320cdb8:	398003cc 	andi	r6,r7,15
 320cdbc:	300c90fa 	slli	r6,r6,3
 320cdc0:	0140c974 	movhi	r5,805
 320cdc4:	2978d304 	addi	r5,r5,-7348
 320cdc8:	d9001217 	ldw	r4,72(sp)
 320cdcc:	314d883a 	add	r6,r6,r5
 320cdd0:	30c00117 	ldw	r3,4(r6)
 320cdd4:	30800017 	ldw	r2,0(r6)
 320cdd8:	d9401317 	ldw	r5,76(sp)
 320cddc:	3821d13a 	srai	r16,r7,4
 320cde0:	100d883a 	mov	r6,r2
 320cde4:	180f883a 	mov	r7,r3
 320cde8:	32132ac0 	call	32132ac <__muldf3>
 320cdec:	1011883a 	mov	r8,r2
 320cdf0:	1813883a 	mov	r9,r3
 320cdf4:	1029883a 	mov	r20,r2
 320cdf8:	182b883a 	mov	r21,r3
 320cdfc:	8001e526 	beq	r16,zero,320d594 <_dtoa_r+0x14a0>
 320ce00:	05800084 	movi	r22,2
 320ce04:	0440c974 	movhi	r17,805
 320ce08:	8c790504 	addi	r17,r17,-7148
 320ce0c:	8080004c 	andi	r2,r16,1
 320ce10:	1005003a 	cmpeq	r2,r2,zero
 320ce14:	1000081e 	bne	r2,zero,320ce38 <_dtoa_r+0xd44>
 320ce18:	89800017 	ldw	r6,0(r17)
 320ce1c:	89c00117 	ldw	r7,4(r17)
 320ce20:	480b883a 	mov	r5,r9
 320ce24:	4009883a 	mov	r4,r8
 320ce28:	32132ac0 	call	32132ac <__muldf3>
 320ce2c:	1011883a 	mov	r8,r2
 320ce30:	b5800044 	addi	r22,r22,1
 320ce34:	1813883a 	mov	r9,r3
 320ce38:	8021d07a 	srai	r16,r16,1
 320ce3c:	8c400204 	addi	r17,r17,8
 320ce40:	803ff21e 	bne	r16,zero,320ce0c <_dtoa_r+0xd18>
 320ce44:	4029883a 	mov	r20,r8
 320ce48:	482b883a 	mov	r21,r9
 320ce4c:	003dca06 	br	320c578 <_dtoa_r+0x484>
 320ce50:	d9000817 	ldw	r4,32(sp)
 320ce54:	2005003a 	cmpeq	r2,r4,zero
 320ce58:	1001f61e 	bne	r2,zero,320d634 <_dtoa_r+0x1540>
 320ce5c:	dc001117 	ldw	r16,68(sp)
 320ce60:	dc801017 	ldw	r18,64(sp)
 320ce64:	18c10cc4 	addi	r3,r3,1075
 320ce68:	003f6106 	br	320cbf0 <_dtoa_r+0xafc>
 320ce6c:	d8000b15 	stw	zero,44(sp)
 320ce70:	d9802617 	ldw	r6,152(sp)
 320ce74:	d8c00d17 	ldw	r3,52(sp)
 320ce78:	30800044 	addi	r2,r6,1
 320ce7c:	18ad883a 	add	r22,r3,r2
 320ce80:	b13fffc4 	addi	r4,r22,-1
 320ce84:	d9000e15 	stw	r4,56(sp)
 320ce88:	0581f60e 	bge	zero,r22,320d664 <_dtoa_r+0x1570>
 320ce8c:	dd800f15 	stw	r22,60(sp)
 320ce90:	003f3006 	br	320cb54 <_dtoa_r+0xa60>
 320ce94:	d8000b15 	stw	zero,44(sp)
 320ce98:	d9002617 	ldw	r4,152(sp)
 320ce9c:	0101eb0e 	bge	zero,r4,320d64c <_dtoa_r+0x1558>
 320cea0:	202d883a 	mov	r22,r4
 320cea4:	d9000e15 	stw	r4,56(sp)
 320cea8:	d9000f15 	stw	r4,60(sp)
 320ceac:	003f2906 	br	320cb54 <_dtoa_r+0xa60>
 320ceb0:	01800044 	movi	r6,1
 320ceb4:	d9800b15 	stw	r6,44(sp)
 320ceb8:	003ff706 	br	320ce98 <_dtoa_r+0xda4>
 320cebc:	01000044 	movi	r4,1
 320cec0:	d9000b15 	stw	r4,44(sp)
 320cec4:	003fea06 	br	320ce70 <_dtoa_r+0xd7c>
 320cec8:	04000c0e 	bge	zero,r16,320cefc <_dtoa_r+0xe08>
 320cecc:	d9400717 	ldw	r5,28(sp)
 320ced0:	d9001617 	ldw	r4,88(sp)
 320ced4:	01800044 	movi	r6,1
 320ced8:	320e65c0 	call	320e65c <__lshift>
 320cedc:	1009883a 	mov	r4,r2
 320cee0:	900b883a 	mov	r5,r18
 320cee4:	d8800715 	stw	r2,28(sp)
 320cee8:	320de740 	call	320de74 <__mcmp>
 320ceec:	0081e00e 	bge	zero,r2,320d670 <_dtoa_r+0x157c>
 320cef0:	bdc00044 	addi	r23,r23,1
 320cef4:	00800e84 	movi	r2,58
 320cef8:	b881a226 	beq	r23,r2,320d584 <_dtoa_r+0x1490>
 320cefc:	b7000044 	addi	fp,r22,1
 320cf00:	b5c00005 	stb	r23,0(r22)
 320cf04:	003f7406 	br	320ccd8 <_dtoa_r+0xbe4>
 320cf08:	00800e44 	movi	r2,57
 320cf0c:	b8819d26 	beq	r23,r2,320d584 <_dtoa_r+0x1490>
 320cf10:	053ffa0e 	bge	zero,r20,320cefc <_dtoa_r+0xe08>
 320cf14:	8dc00c44 	addi	r23,r17,49
 320cf18:	003ff806 	br	320cefc <_dtoa_r+0xe08>
 320cf1c:	d9001617 	ldw	r4,88(sp)
 320cf20:	a80b883a 	mov	r5,r21
 320cf24:	04000044 	movi	r16,1
 320cf28:	320dd180 	call	320dd18 <_Bfree>
 320cf2c:	003edf06 	br	320caac <_dtoa_r+0x9b8>
 320cf30:	d9001617 	ldw	r4,88(sp)
 320cf34:	980b883a 	mov	r5,r19
 320cf38:	01800284 	movi	r6,10
 320cf3c:	000f883a 	mov	r7,zero
 320cf40:	320e9cc0 	call	320e9cc <__multadd>
 320cf44:	1027883a 	mov	r19,r2
 320cf48:	d8800615 	stw	r2,24(sp)
 320cf4c:	003ebb06 	br	320ca3c <_dtoa_r+0x948>
 320cf50:	d9801117 	ldw	r6,68(sp)
 320cf54:	d8800d17 	ldw	r2,52(sp)
 320cf58:	d8000915 	stw	zero,36(sp)
 320cf5c:	308dc83a 	sub	r6,r6,r2
 320cf60:	0087c83a 	sub	r3,zero,r2
 320cf64:	d9801115 	stw	r6,68(sp)
 320cf68:	d8c01015 	stw	r3,64(sp)
 320cf6c:	003cfe06 	br	320c368 <_dtoa_r+0x274>
 320cf70:	018dc83a 	sub	r6,zero,r6
 320cf74:	d9801115 	stw	r6,68(sp)
 320cf78:	d8000a15 	stw	zero,40(sp)
 320cf7c:	003cf306 	br	320c34c <_dtoa_r+0x258>
 320cf80:	d9000d17 	ldw	r4,52(sp)
 320cf84:	3213bf80 	call	3213bf8 <__floatsidf>
 320cf88:	880b883a 	mov	r5,r17
 320cf8c:	8009883a 	mov	r4,r16
 320cf90:	180f883a 	mov	r7,r3
 320cf94:	100d883a 	mov	r6,r2
 320cf98:	32139500 	call	3213950 <__nedf2>
 320cf9c:	103ce126 	beq	r2,zero,320c324 <_dtoa_r+0x230>
 320cfa0:	d9800d17 	ldw	r6,52(sp)
 320cfa4:	31bfffc4 	addi	r6,r6,-1
 320cfa8:	d9800d15 	stw	r6,52(sp)
 320cfac:	003cdd06 	br	320c324 <_dtoa_r+0x230>
 320cfb0:	d9000717 	ldw	r4,28(sp)
 320cfb4:	900b883a 	mov	r5,r18
 320cfb8:	320de740 	call	320de74 <__mcmp>
 320cfbc:	103e8d0e 	bge	r2,zero,320c9f4 <_dtoa_r+0x900>
 320cfc0:	d9400717 	ldw	r5,28(sp)
 320cfc4:	d9001617 	ldw	r4,88(sp)
 320cfc8:	01800284 	movi	r6,10
 320cfcc:	000f883a 	mov	r7,zero
 320cfd0:	320e9cc0 	call	320e9cc <__multadd>
 320cfd4:	d9800d17 	ldw	r6,52(sp)
 320cfd8:	d8800715 	stw	r2,28(sp)
 320cfdc:	31bfffc4 	addi	r6,r6,-1
 320cfe0:	d9800d15 	stw	r6,52(sp)
 320cfe4:	b001a71e 	bne	r22,zero,320d684 <_dtoa_r+0x1590>
 320cfe8:	d8800e17 	ldw	r2,56(sp)
 320cfec:	d8800f15 	stw	r2,60(sp)
 320cff0:	003e8006 	br	320c9f4 <_dtoa_r+0x900>
 320cff4:	90800417 	ldw	r2,16(r18)
 320cff8:	1085883a 	add	r2,r2,r2
 320cffc:	1085883a 	add	r2,r2,r2
 320d000:	1485883a 	add	r2,r2,r18
 320d004:	11000417 	ldw	r4,16(r2)
 320d008:	320dd400 	call	320dd40 <__hi0bits>
 320d00c:	00c00804 	movi	r3,32
 320d010:	1887c83a 	sub	r3,r3,r2
 320d014:	003e5a06 	br	320c980 <_dtoa_r+0x88c>
 320d018:	d9400717 	ldw	r5,28(sp)
 320d01c:	d9801017 	ldw	r6,64(sp)
 320d020:	d9001617 	ldw	r4,88(sp)
 320d024:	320eacc0 	call	320eacc <__pow5mult>
 320d028:	d8800715 	stw	r2,28(sp)
 320d02c:	003e4306 	br	320c93c <_dtoa_r+0x848>
 320d030:	d9800f17 	ldw	r6,60(sp)
 320d034:	d8800d17 	ldw	r2,52(sp)
 320d038:	d9800315 	stw	r6,12(sp)
 320d03c:	d8800415 	stw	r2,16(sp)
 320d040:	d8c00b17 	ldw	r3,44(sp)
 320d044:	1805003a 	cmpeq	r2,r3,zero
 320d048:	1000e21e 	bne	r2,zero,320d3d4 <_dtoa_r+0x12e0>
 320d04c:	d9000317 	ldw	r4,12(sp)
 320d050:	0005883a 	mov	r2,zero
 320d054:	00cff834 	movhi	r3,16352
 320d058:	200c90fa 	slli	r6,r4,3
 320d05c:	0100c974 	movhi	r4,805
 320d060:	2138d304 	addi	r4,r4,-7348
 320d064:	180b883a 	mov	r5,r3
 320d068:	310d883a 	add	r6,r6,r4
 320d06c:	327fff17 	ldw	r9,-4(r6)
 320d070:	323ffe17 	ldw	r8,-8(r6)
 320d074:	1009883a 	mov	r4,r2
 320d078:	480f883a 	mov	r7,r9
 320d07c:	400d883a 	mov	r6,r8
 320d080:	32136700 	call	3213670 <__divdf3>
 320d084:	180b883a 	mov	r5,r3
 320d088:	b00d883a 	mov	r6,r22
 320d08c:	b80f883a 	mov	r7,r23
 320d090:	1009883a 	mov	r4,r2
 320d094:	32131b80 	call	32131b8 <__subdf3>
 320d098:	a80b883a 	mov	r5,r21
 320d09c:	a009883a 	mov	r4,r20
 320d0a0:	d8c01915 	stw	r3,100(sp)
 320d0a4:	d8801815 	stw	r2,96(sp)
 320d0a8:	3213cf00 	call	3213cf0 <__fixdfsi>
 320d0ac:	1009883a 	mov	r4,r2
 320d0b0:	1027883a 	mov	r19,r2
 320d0b4:	3213bf80 	call	3213bf8 <__floatsidf>
 320d0b8:	a80b883a 	mov	r5,r21
 320d0bc:	a009883a 	mov	r4,r20
 320d0c0:	180f883a 	mov	r7,r3
 320d0c4:	100d883a 	mov	r6,r2
 320d0c8:	32131b80 	call	32131b8 <__subdf3>
 320d0cc:	d9801817 	ldw	r6,96(sp)
 320d0d0:	1823883a 	mov	r17,r3
 320d0d4:	d8801415 	stw	r2,80(sp)
 320d0d8:	302d883a 	mov	r22,r6
 320d0dc:	d9800517 	ldw	r6,20(sp)
 320d0e0:	9cc00c04 	addi	r19,r19,48
 320d0e4:	dc401515 	stw	r17,84(sp)
 320d0e8:	d8c01917 	ldw	r3,100(sp)
 320d0ec:	34c00005 	stb	r19,0(r6)
 320d0f0:	d8800517 	ldw	r2,20(sp)
 320d0f4:	d9401917 	ldw	r5,100(sp)
 320d0f8:	d9801417 	ldw	r6,80(sp)
 320d0fc:	b009883a 	mov	r4,r22
 320d100:	880f883a 	mov	r7,r17
 320d104:	182f883a 	mov	r23,r3
 320d108:	17000044 	addi	fp,r2,1
 320d10c:	32139d80 	call	32139d8 <__gtdf2>
 320d110:	00804e16 	blt	zero,r2,320d24c <_dtoa_r+0x1158>
 320d114:	d9801417 	ldw	r6,80(sp)
 320d118:	0005883a 	mov	r2,zero
 320d11c:	00cffc34 	movhi	r3,16368
 320d120:	180b883a 	mov	r5,r3
 320d124:	880f883a 	mov	r7,r17
 320d128:	1009883a 	mov	r4,r2
 320d12c:	32131b80 	call	32131b8 <__subdf3>
 320d130:	d9401917 	ldw	r5,100(sp)
 320d134:	180f883a 	mov	r7,r3
 320d138:	b009883a 	mov	r4,r22
 320d13c:	100d883a 	mov	r6,r2
 320d140:	32139d80 	call	32139d8 <__gtdf2>
 320d144:	00bda216 	blt	zero,r2,320c7d0 <_dtoa_r+0x6dc>
 320d148:	d8c00317 	ldw	r3,12(sp)
 320d14c:	00800044 	movi	r2,1
 320d150:	10c01216 	blt	r2,r3,320d19c <_dtoa_r+0x10a8>
 320d154:	003d4506 	br	320c66c <_dtoa_r+0x578>
 320d158:	d9801417 	ldw	r6,80(sp)
 320d15c:	0005883a 	mov	r2,zero
 320d160:	00cffc34 	movhi	r3,16368
 320d164:	180b883a 	mov	r5,r3
 320d168:	880f883a 	mov	r7,r17
 320d16c:	1009883a 	mov	r4,r2
 320d170:	32131b80 	call	32131b8 <__subdf3>
 320d174:	d9c01b17 	ldw	r7,108(sp)
 320d178:	180b883a 	mov	r5,r3
 320d17c:	1009883a 	mov	r4,r2
 320d180:	b00d883a 	mov	r6,r22
 320d184:	3213ae80 	call	3213ae8 <__ltdf2>
 320d188:	103d9116 	blt	r2,zero,320c7d0 <_dtoa_r+0x6dc>
 320d18c:	d9800517 	ldw	r6,20(sp)
 320d190:	d9000317 	ldw	r4,12(sp)
 320d194:	3105883a 	add	r2,r6,r4
 320d198:	e0bd3426 	beq	fp,r2,320c66c <_dtoa_r+0x578>
 320d19c:	04500934 	movhi	r17,16420
 320d1a0:	0021883a 	mov	r16,zero
 320d1a4:	b80b883a 	mov	r5,r23
 320d1a8:	b009883a 	mov	r4,r22
 320d1ac:	800d883a 	mov	r6,r16
 320d1b0:	880f883a 	mov	r7,r17
 320d1b4:	32132ac0 	call	32132ac <__muldf3>
 320d1b8:	d9401517 	ldw	r5,84(sp)
 320d1bc:	d9001417 	ldw	r4,80(sp)
 320d1c0:	880f883a 	mov	r7,r17
 320d1c4:	000d883a 	mov	r6,zero
 320d1c8:	d8801a15 	stw	r2,104(sp)
 320d1cc:	d8c01b15 	stw	r3,108(sp)
 320d1d0:	32132ac0 	call	32132ac <__muldf3>
 320d1d4:	180b883a 	mov	r5,r3
 320d1d8:	1009883a 	mov	r4,r2
 320d1dc:	1823883a 	mov	r17,r3
 320d1e0:	1021883a 	mov	r16,r2
 320d1e4:	3213cf00 	call	3213cf0 <__fixdfsi>
 320d1e8:	1009883a 	mov	r4,r2
 320d1ec:	102b883a 	mov	r21,r2
 320d1f0:	3213bf80 	call	3213bf8 <__floatsidf>
 320d1f4:	880b883a 	mov	r5,r17
 320d1f8:	8009883a 	mov	r4,r16
 320d1fc:	180f883a 	mov	r7,r3
 320d200:	100d883a 	mov	r6,r2
 320d204:	32131b80 	call	32131b8 <__subdf3>
 320d208:	1021883a 	mov	r16,r2
 320d20c:	d9001b17 	ldw	r4,108(sp)
 320d210:	1823883a 	mov	r17,r3
 320d214:	dc001415 	stw	r16,80(sp)
 320d218:	ad400c04 	addi	r21,r21,48
 320d21c:	dc401515 	stw	r17,84(sp)
 320d220:	d8801a17 	ldw	r2,104(sp)
 320d224:	e5400005 	stb	r21,0(fp)
 320d228:	202f883a 	mov	r23,r4
 320d22c:	d9c01b17 	ldw	r7,108(sp)
 320d230:	d9001417 	ldw	r4,80(sp)
 320d234:	880b883a 	mov	r5,r17
 320d238:	100d883a 	mov	r6,r2
 320d23c:	102d883a 	mov	r22,r2
 320d240:	e7000044 	addi	fp,fp,1
 320d244:	3213ae80 	call	3213ae8 <__ltdf2>
 320d248:	103fc30e 	bge	r2,zero,320d158 <_dtoa_r+0x1064>
 320d24c:	d9000417 	ldw	r4,16(sp)
 320d250:	d9000d15 	stw	r4,52(sp)
 320d254:	003d7106 	br	320c81c <_dtoa_r+0x728>
 320d258:	d9801717 	ldw	r6,92(sp)
 320d25c:	00800084 	movi	r2,2
 320d260:	11bde60e 	bge	r2,r6,320c9fc <_dtoa_r+0x908>
 320d264:	203cfb1e 	bne	r4,zero,320c654 <_dtoa_r+0x560>
 320d268:	d9001617 	ldw	r4,88(sp)
 320d26c:	900b883a 	mov	r5,r18
 320d270:	01800144 	movi	r6,5
 320d274:	000f883a 	mov	r7,zero
 320d278:	320e9cc0 	call	320e9cc <__multadd>
 320d27c:	d9000717 	ldw	r4,28(sp)
 320d280:	100b883a 	mov	r5,r2
 320d284:	1025883a 	mov	r18,r2
 320d288:	320de740 	call	320de74 <__mcmp>
 320d28c:	00bcf10e 	bge	zero,r2,320c654 <_dtoa_r+0x560>
 320d290:	d8c00d17 	ldw	r3,52(sp)
 320d294:	d9000517 	ldw	r4,20(sp)
 320d298:	d8000615 	stw	zero,24(sp)
 320d29c:	18c00044 	addi	r3,r3,1
 320d2a0:	d8c00d15 	stw	r3,52(sp)
 320d2a4:	00800c44 	movi	r2,49
 320d2a8:	27000044 	addi	fp,r4,1
 320d2ac:	20800005 	stb	r2,0(r4)
 320d2b0:	003e8906 	br	320ccd8 <_dtoa_r+0xbe4>
 320d2b4:	d8c00517 	ldw	r3,20(sp)
 320d2b8:	003bc206 	br	320c1c4 <_dtoa_r+0xd0>
 320d2bc:	0180c974 	movhi	r6,805
 320d2c0:	31b90504 	addi	r6,r6,-7148
 320d2c4:	30c00917 	ldw	r3,36(r6)
 320d2c8:	30800817 	ldw	r2,32(r6)
 320d2cc:	d9001217 	ldw	r4,72(sp)
 320d2d0:	d9401317 	ldw	r5,76(sp)
 320d2d4:	180f883a 	mov	r7,r3
 320d2d8:	100d883a 	mov	r6,r2
 320d2dc:	32136700 	call	3213670 <__divdf3>
 320d2e0:	948003cc 	andi	r18,r18,15
 320d2e4:	058000c4 	movi	r22,3
 320d2e8:	1029883a 	mov	r20,r2
 320d2ec:	182b883a 	mov	r21,r3
 320d2f0:	003c8906 	br	320c518 <_dtoa_r+0x424>
 320d2f4:	d9001017 	ldw	r4,64(sp)
 320d2f8:	d9800917 	ldw	r6,36(sp)
 320d2fc:	0025883a 	mov	r18,zero
 320d300:	1105c83a 	sub	r2,r2,r4
 320d304:	2089883a 	add	r4,r4,r2
 320d308:	308d883a 	add	r6,r6,r2
 320d30c:	d9001015 	stw	r4,64(sp)
 320d310:	d9800915 	stw	r6,36(sp)
 320d314:	003e3206 	br	320cbe0 <_dtoa_r+0xaec>
 320d318:	28800044 	addi	r2,r5,1
 320d31c:	27000044 	addi	fp,r4,1
 320d320:	20800005 	stb	r2,0(r4)
 320d324:	003e6c06 	br	320ccd8 <_dtoa_r+0xbe4>
 320d328:	d8800f17 	ldw	r2,60(sp)
 320d32c:	00bce016 	blt	zero,r2,320c6b0 <_dtoa_r+0x5bc>
 320d330:	d9800f17 	ldw	r6,60(sp)
 320d334:	303cc51e 	bne	r6,zero,320c64c <_dtoa_r+0x558>
 320d338:	0005883a 	mov	r2,zero
 320d33c:	00d00534 	movhi	r3,16404
 320d340:	980b883a 	mov	r5,r19
 320d344:	180f883a 	mov	r7,r3
 320d348:	9009883a 	mov	r4,r18
 320d34c:	100d883a 	mov	r6,r2
 320d350:	32132ac0 	call	32132ac <__muldf3>
 320d354:	180b883a 	mov	r5,r3
 320d358:	a80f883a 	mov	r7,r21
 320d35c:	1009883a 	mov	r4,r2
 320d360:	a00d883a 	mov	r6,r20
 320d364:	3213a600 	call	3213a60 <__gedf2>
 320d368:	103cb80e 	bge	r2,zero,320c64c <_dtoa_r+0x558>
 320d36c:	0027883a 	mov	r19,zero
 320d370:	0025883a 	mov	r18,zero
 320d374:	003fc606 	br	320d290 <_dtoa_r+0x119c>
 320d378:	99400117 	ldw	r5,4(r19)
 320d37c:	d9001617 	ldw	r4,88(sp)
 320d380:	320e2980 	call	320e298 <_Balloc>
 320d384:	99800417 	ldw	r6,16(r19)
 320d388:	11000304 	addi	r4,r2,12
 320d38c:	99400304 	addi	r5,r19,12
 320d390:	318d883a 	add	r6,r6,r6
 320d394:	318d883a 	add	r6,r6,r6
 320d398:	31800204 	addi	r6,r6,8
 320d39c:	1023883a 	mov	r17,r2
 320d3a0:	3206ad00 	call	3206ad0 <memcpy>
 320d3a4:	d9001617 	ldw	r4,88(sp)
 320d3a8:	880b883a 	mov	r5,r17
 320d3ac:	01800044 	movi	r6,1
 320d3b0:	320e65c0 	call	320e65c <__lshift>
 320d3b4:	100b883a 	mov	r5,r2
 320d3b8:	003d9c06 	br	320ca2c <_dtoa_r+0x938>
 320d3bc:	00800e44 	movi	r2,57
 320d3c0:	b8807026 	beq	r23,r2,320d584 <_dtoa_r+0x1490>
 320d3c4:	b8800044 	addi	r2,r23,1
 320d3c8:	b7000044 	addi	fp,r22,1
 320d3cc:	b0800005 	stb	r2,0(r22)
 320d3d0:	003e4106 	br	320ccd8 <_dtoa_r+0xbe4>
 320d3d4:	d8800317 	ldw	r2,12(sp)
 320d3d8:	0180c974 	movhi	r6,805
 320d3dc:	31b8d304 	addi	r6,r6,-7348
 320d3e0:	b009883a 	mov	r4,r22
 320d3e4:	100e90fa 	slli	r7,r2,3
 320d3e8:	b80b883a 	mov	r5,r23
 320d3ec:	398f883a 	add	r7,r7,r6
 320d3f0:	38bffe17 	ldw	r2,-8(r7)
 320d3f4:	d9800517 	ldw	r6,20(sp)
 320d3f8:	38ffff17 	ldw	r3,-4(r7)
 320d3fc:	37000044 	addi	fp,r6,1
 320d400:	180f883a 	mov	r7,r3
 320d404:	100d883a 	mov	r6,r2
 320d408:	32132ac0 	call	32132ac <__muldf3>
 320d40c:	a80b883a 	mov	r5,r21
 320d410:	a009883a 	mov	r4,r20
 320d414:	182f883a 	mov	r23,r3
 320d418:	102d883a 	mov	r22,r2
 320d41c:	3213cf00 	call	3213cf0 <__fixdfsi>
 320d420:	1009883a 	mov	r4,r2
 320d424:	1027883a 	mov	r19,r2
 320d428:	3213bf80 	call	3213bf8 <__floatsidf>
 320d42c:	a80b883a 	mov	r5,r21
 320d430:	a009883a 	mov	r4,r20
 320d434:	180f883a 	mov	r7,r3
 320d438:	100d883a 	mov	r6,r2
 320d43c:	32131b80 	call	32131b8 <__subdf3>
 320d440:	180b883a 	mov	r5,r3
 320d444:	d8c00517 	ldw	r3,20(sp)
 320d448:	9cc00c04 	addi	r19,r19,48
 320d44c:	1009883a 	mov	r4,r2
 320d450:	1cc00005 	stb	r19,0(r3)
 320d454:	2021883a 	mov	r16,r4
 320d458:	d9000317 	ldw	r4,12(sp)
 320d45c:	00800044 	movi	r2,1
 320d460:	2823883a 	mov	r17,r5
 320d464:	20802226 	beq	r4,r2,320d4f0 <_dtoa_r+0x13fc>
 320d468:	1029883a 	mov	r20,r2
 320d46c:	0005883a 	mov	r2,zero
 320d470:	00d00934 	movhi	r3,16420
 320d474:	180f883a 	mov	r7,r3
 320d478:	100d883a 	mov	r6,r2
 320d47c:	880b883a 	mov	r5,r17
 320d480:	8009883a 	mov	r4,r16
 320d484:	32132ac0 	call	32132ac <__muldf3>
 320d488:	180b883a 	mov	r5,r3
 320d48c:	1009883a 	mov	r4,r2
 320d490:	1823883a 	mov	r17,r3
 320d494:	1021883a 	mov	r16,r2
 320d498:	3213cf00 	call	3213cf0 <__fixdfsi>
 320d49c:	1009883a 	mov	r4,r2
 320d4a0:	102b883a 	mov	r21,r2
 320d4a4:	3213bf80 	call	3213bf8 <__floatsidf>
 320d4a8:	880b883a 	mov	r5,r17
 320d4ac:	8009883a 	mov	r4,r16
 320d4b0:	180f883a 	mov	r7,r3
 320d4b4:	100d883a 	mov	r6,r2
 320d4b8:	32131b80 	call	32131b8 <__subdf3>
 320d4bc:	180b883a 	mov	r5,r3
 320d4c0:	d8c00517 	ldw	r3,20(sp)
 320d4c4:	1009883a 	mov	r4,r2
 320d4c8:	ad400c04 	addi	r21,r21,48
 320d4cc:	1d05883a 	add	r2,r3,r20
 320d4d0:	15400005 	stb	r21,0(r2)
 320d4d4:	2021883a 	mov	r16,r4
 320d4d8:	d9000317 	ldw	r4,12(sp)
 320d4dc:	a5000044 	addi	r20,r20,1
 320d4e0:	2823883a 	mov	r17,r5
 320d4e4:	a13fe11e 	bne	r20,r4,320d46c <_dtoa_r+0x1378>
 320d4e8:	e505883a 	add	r2,fp,r20
 320d4ec:	173fffc4 	addi	fp,r2,-1
 320d4f0:	0025883a 	mov	r18,zero
 320d4f4:	04cff834 	movhi	r19,16352
 320d4f8:	b009883a 	mov	r4,r22
 320d4fc:	b80b883a 	mov	r5,r23
 320d500:	900d883a 	mov	r6,r18
 320d504:	980f883a 	mov	r7,r19
 320d508:	32132380 	call	3213238 <__adddf3>
 320d50c:	180b883a 	mov	r5,r3
 320d510:	1009883a 	mov	r4,r2
 320d514:	800d883a 	mov	r6,r16
 320d518:	880f883a 	mov	r7,r17
 320d51c:	3213ae80 	call	3213ae8 <__ltdf2>
 320d520:	103cab16 	blt	r2,zero,320c7d0 <_dtoa_r+0x6dc>
 320d524:	0009883a 	mov	r4,zero
 320d528:	980b883a 	mov	r5,r19
 320d52c:	b80f883a 	mov	r7,r23
 320d530:	b00d883a 	mov	r6,r22
 320d534:	32131b80 	call	32131b8 <__subdf3>
 320d538:	180b883a 	mov	r5,r3
 320d53c:	880f883a 	mov	r7,r17
 320d540:	1009883a 	mov	r4,r2
 320d544:	800d883a 	mov	r6,r16
 320d548:	32139d80 	call	32139d8 <__gtdf2>
 320d54c:	00bc470e 	bge	zero,r2,320c66c <_dtoa_r+0x578>
 320d550:	00c00c04 	movi	r3,48
 320d554:	e73fffc4 	addi	fp,fp,-1
 320d558:	e0800007 	ldb	r2,0(fp)
 320d55c:	10fffd26 	beq	r2,r3,320d554 <_dtoa_r+0x1460>
 320d560:	d9800417 	ldw	r6,16(sp)
 320d564:	e7000044 	addi	fp,fp,1
 320d568:	d9800d15 	stw	r6,52(sp)
 320d56c:	003cab06 	br	320c81c <_dtoa_r+0x728>
 320d570:	d8c00f17 	ldw	r3,60(sp)
 320d574:	d9001117 	ldw	r4,68(sp)
 320d578:	20e1c83a 	sub	r16,r4,r3
 320d57c:	0007883a 	mov	r3,zero
 320d580:	003d9b06 	br	320cbf0 <_dtoa_r+0xafc>
 320d584:	00800e44 	movi	r2,57
 320d588:	b0800005 	stb	r2,0(r22)
 320d58c:	b5800044 	addi	r22,r22,1
 320d590:	003dc106 	br	320cc98 <_dtoa_r+0xba4>
 320d594:	05800084 	movi	r22,2
 320d598:	003bf706 	br	320c578 <_dtoa_r+0x484>
 320d59c:	d9000f17 	ldw	r4,60(sp)
 320d5a0:	013c000e 	bge	zero,r4,320c5a4 <_dtoa_r+0x4b0>
 320d5a4:	d9800e17 	ldw	r6,56(sp)
 320d5a8:	01bc300e 	bge	zero,r6,320c66c <_dtoa_r+0x578>
 320d5ac:	0005883a 	mov	r2,zero
 320d5b0:	00d00934 	movhi	r3,16420
 320d5b4:	a80b883a 	mov	r5,r21
 320d5b8:	180f883a 	mov	r7,r3
 320d5bc:	a009883a 	mov	r4,r20
 320d5c0:	100d883a 	mov	r6,r2
 320d5c4:	32132ac0 	call	32132ac <__muldf3>
 320d5c8:	b1000044 	addi	r4,r22,1
 320d5cc:	1021883a 	mov	r16,r2
 320d5d0:	1823883a 	mov	r17,r3
 320d5d4:	3213bf80 	call	3213bf8 <__floatsidf>
 320d5d8:	880b883a 	mov	r5,r17
 320d5dc:	8009883a 	mov	r4,r16
 320d5e0:	180f883a 	mov	r7,r3
 320d5e4:	100d883a 	mov	r6,r2
 320d5e8:	32132ac0 	call	32132ac <__muldf3>
 320d5ec:	0011883a 	mov	r8,zero
 320d5f0:	02500734 	movhi	r9,16412
 320d5f4:	180b883a 	mov	r5,r3
 320d5f8:	480f883a 	mov	r7,r9
 320d5fc:	1009883a 	mov	r4,r2
 320d600:	400d883a 	mov	r6,r8
 320d604:	32132380 	call	3213238 <__adddf3>
 320d608:	102d883a 	mov	r22,r2
 320d60c:	00bf3034 	movhi	r2,64704
 320d610:	10ef883a 	add	r23,r2,r3
 320d614:	d8800d17 	ldw	r2,52(sp)
 320d618:	d8c00e17 	ldw	r3,56(sp)
 320d61c:	8029883a 	mov	r20,r16
 320d620:	10bfffc4 	addi	r2,r2,-1
 320d624:	882b883a 	mov	r21,r17
 320d628:	d8800415 	stw	r2,16(sp)
 320d62c:	d8c00315 	stw	r3,12(sp)
 320d630:	003e8306 	br	320d040 <_dtoa_r+0xf4c>
 320d634:	d8800117 	ldw	r2,4(sp)
 320d638:	dc001117 	ldw	r16,68(sp)
 320d63c:	dc801017 	ldw	r18,64(sp)
 320d640:	00c00d84 	movi	r3,54
 320d644:	1887c83a 	sub	r3,r3,r2
 320d648:	003d6906 	br	320cbf0 <_dtoa_r+0xafc>
 320d64c:	01800044 	movi	r6,1
 320d650:	3021883a 	mov	r16,r6
 320d654:	d9800f15 	stw	r6,60(sp)
 320d658:	d9802615 	stw	r6,152(sp)
 320d65c:	d9800e15 	stw	r6,56(sp)
 320d660:	003b9306 	br	320c4b0 <_dtoa_r+0x3bc>
 320d664:	b021883a 	mov	r16,r22
 320d668:	dd800f15 	stw	r22,60(sp)
 320d66c:	003b9006 	br	320c4b0 <_dtoa_r+0x3bc>
 320d670:	103e221e 	bne	r2,zero,320cefc <_dtoa_r+0xe08>
 320d674:	b880004c 	andi	r2,r23,1
 320d678:	1005003a 	cmpeq	r2,r2,zero
 320d67c:	103e1f1e 	bne	r2,zero,320cefc <_dtoa_r+0xe08>
 320d680:	003e1b06 	br	320cef0 <_dtoa_r+0xdfc>
 320d684:	d9001617 	ldw	r4,88(sp)
 320d688:	980b883a 	mov	r5,r19
 320d68c:	01800284 	movi	r6,10
 320d690:	000f883a 	mov	r7,zero
 320d694:	320e9cc0 	call	320e9cc <__multadd>
 320d698:	d8c00e17 	ldw	r3,56(sp)
 320d69c:	1027883a 	mov	r19,r2
 320d6a0:	d8c00f15 	stw	r3,60(sp)
 320d6a4:	003cd306 	br	320c9f4 <_dtoa_r+0x900>

0320d6a8 <__sflags>:
 320d6a8:	28c00007 	ldb	r3,0(r5)
 320d6ac:	00801c84 	movi	r2,114
 320d6b0:	18800926 	beq	r3,r2,320d6d8 <__sflags+0x30>
 320d6b4:	00801dc4 	movi	r2,119
 320d6b8:	18801426 	beq	r3,r2,320d70c <__sflags+0x64>
 320d6bc:	00801844 	movi	r2,97
 320d6c0:	18801626 	beq	r3,r2,320d71c <__sflags+0x74>
 320d6c4:	0007883a 	mov	r3,zero
 320d6c8:	00800584 	movi	r2,22
 320d6cc:	20800015 	stw	r2,0(r4)
 320d6d0:	1805883a 	mov	r2,r3
 320d6d4:	f800283a 	ret
 320d6d8:	000f883a 	mov	r7,zero
 320d6dc:	0011883a 	mov	r8,zero
 320d6e0:	00c00104 	movi	r3,4
 320d6e4:	28800047 	ldb	r2,1(r5)
 320d6e8:	10000426 	beq	r2,zero,320d6fc <__sflags+0x54>
 320d6ec:	01000ac4 	movi	r4,43
 320d6f0:	11000e26 	beq	r2,r4,320d72c <__sflags+0x84>
 320d6f4:	28800087 	ldb	r2,2(r5)
 320d6f8:	11000c26 	beq	r2,r4,320d72c <__sflags+0x84>
 320d6fc:	3a04b03a 	or	r2,r7,r8
 320d700:	30800015 	stw	r2,0(r6)
 320d704:	1805883a 	mov	r2,r3
 320d708:	f800283a 	ret
 320d70c:	01c00044 	movi	r7,1
 320d710:	02018004 	movi	r8,1536
 320d714:	00c00204 	movi	r3,8
 320d718:	003ff206 	br	320d6e4 <__sflags+0x3c>
 320d71c:	01c00044 	movi	r7,1
 320d720:	02008204 	movi	r8,520
 320d724:	00c04204 	movi	r3,264
 320d728:	003fee06 	br	320d6e4 <__sflags+0x3c>
 320d72c:	00bffcc4 	movi	r2,-13
 320d730:	1884703a 	and	r2,r3,r2
 320d734:	01c00084 	movi	r7,2
 320d738:	10c00414 	ori	r3,r2,16
 320d73c:	3a04b03a 	or	r2,r7,r8
 320d740:	30800015 	stw	r2,0(r6)
 320d744:	003fef06 	br	320d704 <__sflags+0x5c>

0320d748 <fputc>:
 320d748:	defffc04 	addi	sp,sp,-16
 320d74c:	dc800215 	stw	r18,8(sp)
 320d750:	0480c974 	movhi	r18,805
 320d754:	948a6304 	addi	r18,r18,10636
 320d758:	90c00017 	ldw	r3,0(r18)
 320d75c:	dc400115 	stw	r17,4(sp)
 320d760:	dc000015 	stw	r16,0(sp)
 320d764:	dfc00315 	stw	ra,12(sp)
 320d768:	2021883a 	mov	r16,r4
 320d76c:	2823883a 	mov	r17,r5
 320d770:	18000326 	beq	r3,zero,320d780 <fputc+0x38>
 320d774:	18800e17 	ldw	r2,56(r3)
 320d778:	1809883a 	mov	r4,r3
 320d77c:	10000926 	beq	r2,zero,320d7a4 <fputc+0x5c>
 320d780:	91000017 	ldw	r4,0(r18)
 320d784:	800b883a 	mov	r5,r16
 320d788:	880d883a 	mov	r6,r17
 320d78c:	dfc00317 	ldw	ra,12(sp)
 320d790:	dc800217 	ldw	r18,8(sp)
 320d794:	dc400117 	ldw	r17,4(sp)
 320d798:	dc000017 	ldw	r16,0(sp)
 320d79c:	dec00404 	addi	sp,sp,16
 320d7a0:	3206f5c1 	jmpi	3206f5c <_putc_r>
 320d7a4:	3204b8c0 	call	3204b8c <__sinit>
 320d7a8:	003ff506 	br	320d780 <fputc+0x38>

0320d7ac <_fputc_r>:
 320d7ac:	defffc04 	addi	sp,sp,-16
 320d7b0:	dc800215 	stw	r18,8(sp)
 320d7b4:	dc400115 	stw	r17,4(sp)
 320d7b8:	dc000015 	stw	r16,0(sp)
 320d7bc:	dfc00315 	stw	ra,12(sp)
 320d7c0:	2021883a 	mov	r16,r4
 320d7c4:	2823883a 	mov	r17,r5
 320d7c8:	3025883a 	mov	r18,r6
 320d7cc:	20000226 	beq	r4,zero,320d7d8 <_fputc_r+0x2c>
 320d7d0:	20800e17 	ldw	r2,56(r4)
 320d7d4:	10000926 	beq	r2,zero,320d7fc <_fputc_r+0x50>
 320d7d8:	8009883a 	mov	r4,r16
 320d7dc:	880b883a 	mov	r5,r17
 320d7e0:	900d883a 	mov	r6,r18
 320d7e4:	dfc00317 	ldw	ra,12(sp)
 320d7e8:	dc800217 	ldw	r18,8(sp)
 320d7ec:	dc400117 	ldw	r17,4(sp)
 320d7f0:	dc000017 	ldw	r16,0(sp)
 320d7f4:	dec00404 	addi	sp,sp,16
 320d7f8:	3206f5c1 	jmpi	3206f5c <_putc_r>
 320d7fc:	3204b8c0 	call	3204b8c <__sinit>
 320d800:	003ff506 	br	320d7d8 <_fputc_r+0x2c>

0320d804 <_fread_r>:
 320d804:	defff504 	addi	sp,sp,-44
 320d808:	ddc00815 	stw	r23,32(sp)
 320d80c:	39af383a 	mul	r23,r7,r6
 320d810:	df000915 	stw	fp,36(sp)
 320d814:	dd800715 	stw	r22,28(sp)
 320d818:	dcc00415 	stw	r19,16(sp)
 320d81c:	dc000115 	stw	r16,4(sp)
 320d820:	dfc00a15 	stw	ra,40(sp)
 320d824:	dd400615 	stw	r21,24(sp)
 320d828:	dd000515 	stw	r20,20(sp)
 320d82c:	dc800315 	stw	r18,12(sp)
 320d830:	dc400215 	stw	r17,8(sp)
 320d834:	d9800015 	stw	r6,0(sp)
 320d838:	3839883a 	mov	fp,r7
 320d83c:	2821883a 	mov	r16,r5
 320d840:	202d883a 	mov	r22,r4
 320d844:	dcc00b17 	ldw	r19,44(sp)
 320d848:	b8005926 	beq	r23,zero,320d9b0 <_fread_r+0x1ac>
 320d84c:	20000226 	beq	r4,zero,320d858 <_fread_r+0x54>
 320d850:	20800e17 	ldw	r2,56(r4)
 320d854:	10005826 	beq	r2,zero,320d9b8 <_fread_r+0x1b4>
 320d858:	9c400117 	ldw	r17,4(r19)
 320d85c:	88005916 	blt	r17,zero,320d9c4 <_fread_r+0x1c0>
 320d860:	9880030b 	ldhu	r2,12(r19)
 320d864:	8029883a 	mov	r20,r16
 320d868:	1080008c 	andi	r2,r2,2
 320d86c:	1000221e 	bne	r2,zero,320d8f8 <_fread_r+0xf4>
 320d870:	b825883a 	mov	r18,r23
 320d874:	00000106 	br	320d87c <_fread_r+0x78>
 320d878:	9c400117 	ldw	r17,4(r19)
 320d87c:	a009883a 	mov	r4,r20
 320d880:	880d883a 	mov	r6,r17
 320d884:	8c80542e 	bgeu	r17,r18,320d9d8 <_fread_r+0x1d4>
 320d888:	99400017 	ldw	r5,0(r19)
 320d88c:	a469883a 	add	r20,r20,r17
 320d890:	9465c83a 	sub	r18,r18,r17
 320d894:	3206ad00 	call	3206ad0 <memcpy>
 320d898:	98800017 	ldw	r2,0(r19)
 320d89c:	b009883a 	mov	r4,r22
 320d8a0:	980b883a 	mov	r5,r19
 320d8a4:	1461883a 	add	r16,r2,r17
 320d8a8:	9c000015 	stw	r16,0(r19)
 320d8ac:	32077100 	call	3207710 <__srefill_r>
 320d8b0:	103ff126 	beq	r2,zero,320d878 <_fread_r+0x74>
 320d8b4:	d9400017 	ldw	r5,0(sp)
 320d8b8:	bc89c83a 	sub	r4,r23,r18
 320d8bc:	32047c00 	call	32047c0 <__udivsi3>
 320d8c0:	1039883a 	mov	fp,r2
 320d8c4:	e005883a 	mov	r2,fp
 320d8c8:	dfc00a17 	ldw	ra,40(sp)
 320d8cc:	df000917 	ldw	fp,36(sp)
 320d8d0:	ddc00817 	ldw	r23,32(sp)
 320d8d4:	dd800717 	ldw	r22,28(sp)
 320d8d8:	dd400617 	ldw	r21,24(sp)
 320d8dc:	dd000517 	ldw	r20,20(sp)
 320d8e0:	dcc00417 	ldw	r19,16(sp)
 320d8e4:	dc800317 	ldw	r18,12(sp)
 320d8e8:	dc400217 	ldw	r17,8(sp)
 320d8ec:	dc000117 	ldw	r16,4(sp)
 320d8f0:	dec00b04 	addi	sp,sp,44
 320d8f4:	f800283a 	ret
 320d8f8:	b825883a 	mov	r18,r23
 320d8fc:	8dc03436 	bltu	r17,r23,320d9d0 <_fread_r+0x1cc>
 320d900:	99400017 	ldw	r5,0(r19)
 320d904:	a009883a 	mov	r4,r20
 320d908:	900d883a 	mov	r6,r18
 320d90c:	3206ad00 	call	3206ad0 <memcpy>
 320d910:	9c000017 	ldw	r16,0(r19)
 320d914:	98800117 	ldw	r2,4(r19)
 320d918:	99400c17 	ldw	r5,48(r19)
 320d91c:	84a1883a 	add	r16,r16,r18
 320d920:	14a3c83a 	sub	r17,r2,r18
 320d924:	a4ab883a 	add	r21,r20,r18
 320d928:	9c400115 	stw	r17,4(r19)
 320d92c:	9c000015 	stw	r16,0(r19)
 320d930:	bca9c83a 	sub	r20,r23,r18
 320d934:	28000826 	beq	r5,zero,320d958 <_fread_r+0x154>
 320d938:	a03fe226 	beq	r20,zero,320d8c4 <_fread_r+0xc0>
 320d93c:	98801004 	addi	r2,r19,64
 320d940:	28800326 	beq	r5,r2,320d950 <_fread_r+0x14c>
 320d944:	b009883a 	mov	r4,r22
 320d948:	32051100 	call	3205110 <_free_r>
 320d94c:	9c000017 	ldw	r16,0(r19)
 320d950:	98000c15 	stw	zero,48(r19)
 320d954:	00000106 	br	320d95c <_fread_r+0x158>
 320d958:	a03fda26 	beq	r20,zero,320d8c4 <_fread_r+0xc0>
 320d95c:	9c800417 	ldw	r18,16(r19)
 320d960:	9c400517 	ldw	r17,20(r19)
 320d964:	9d400015 	stw	r21,0(r19)
 320d968:	9d400415 	stw	r21,16(r19)
 320d96c:	9d000515 	stw	r20,20(r19)
 320d970:	b009883a 	mov	r4,r22
 320d974:	980b883a 	mov	r5,r19
 320d978:	32077100 	call	3207710 <__srefill_r>
 320d97c:	98c00117 	ldw	r3,4(r19)
 320d980:	9c800415 	stw	r18,16(r19)
 320d984:	9c400515 	stw	r17,20(r19)
 320d988:	a8eb883a 	add	r21,r21,r3
 320d98c:	9c000015 	stw	r16,0(r19)
 320d990:	a0e9c83a 	sub	r20,r20,r3
 320d994:	98000115 	stw	zero,4(r19)
 320d998:	103fef26 	beq	r2,zero,320d958 <_fread_r+0x154>
 320d99c:	d9400017 	ldw	r5,0(sp)
 320d9a0:	bd09c83a 	sub	r4,r23,r20
 320d9a4:	32047c00 	call	32047c0 <__udivsi3>
 320d9a8:	1039883a 	mov	fp,r2
 320d9ac:	003fc506 	br	320d8c4 <_fread_r+0xc0>
 320d9b0:	0039883a 	mov	fp,zero
 320d9b4:	003fc306 	br	320d8c4 <_fread_r+0xc0>
 320d9b8:	3204b8c0 	call	3204b8c <__sinit>
 320d9bc:	9c400117 	ldw	r17,4(r19)
 320d9c0:	883fa70e 	bge	r17,zero,320d860 <_fread_r+0x5c>
 320d9c4:	0023883a 	mov	r17,zero
 320d9c8:	98000115 	stw	zero,4(r19)
 320d9cc:	003fa406 	br	320d860 <_fread_r+0x5c>
 320d9d0:	8825883a 	mov	r18,r17
 320d9d4:	003fca06 	br	320d900 <_fread_r+0xfc>
 320d9d8:	99400017 	ldw	r5,0(r19)
 320d9dc:	900d883a 	mov	r6,r18
 320d9e0:	3206ad00 	call	3206ad0 <memcpy>
 320d9e4:	98c00117 	ldw	r3,4(r19)
 320d9e8:	98800017 	ldw	r2,0(r19)
 320d9ec:	1c87c83a 	sub	r3,r3,r18
 320d9f0:	1485883a 	add	r2,r2,r18
 320d9f4:	98800015 	stw	r2,0(r19)
 320d9f8:	98c00115 	stw	r3,4(r19)
 320d9fc:	003fb106 	br	320d8c4 <_fread_r+0xc0>

0320da00 <fread>:
 320da00:	0080c974 	movhi	r2,805
 320da04:	108a6304 	addi	r2,r2,10636
 320da08:	2017883a 	mov	r11,r4
 320da0c:	11000017 	ldw	r4,0(r2)
 320da10:	defffe04 	addi	sp,sp,-8
 320da14:	3013883a 	mov	r9,r6
 320da18:	2805883a 	mov	r2,r5
 320da1c:	d9c00015 	stw	r7,0(sp)
 320da20:	580b883a 	mov	r5,r11
 320da24:	100d883a 	mov	r6,r2
 320da28:	480f883a 	mov	r7,r9
 320da2c:	dfc00115 	stw	ra,4(sp)
 320da30:	320d8040 	call	320d804 <_fread_r>
 320da34:	dfc00117 	ldw	ra,4(sp)
 320da38:	dec00204 	addi	sp,sp,8
 320da3c:	f800283a 	ret

0320da40 <_isatty_r>:
 320da40:	defffd04 	addi	sp,sp,-12
 320da44:	dc000015 	stw	r16,0(sp)
 320da48:	0400c974 	movhi	r16,805
 320da4c:	8412f804 	addi	r16,r16,19424
 320da50:	dc400115 	stw	r17,4(sp)
 320da54:	80000015 	stw	zero,0(r16)
 320da58:	2023883a 	mov	r17,r4
 320da5c:	2809883a 	mov	r4,r5
 320da60:	dfc00215 	stw	ra,8(sp)
 320da64:	3214a640 	call	3214a64 <isatty>
 320da68:	1007883a 	mov	r3,r2
 320da6c:	00bfffc4 	movi	r2,-1
 320da70:	18800626 	beq	r3,r2,320da8c <_isatty_r+0x4c>
 320da74:	1805883a 	mov	r2,r3
 320da78:	dfc00217 	ldw	ra,8(sp)
 320da7c:	dc400117 	ldw	r17,4(sp)
 320da80:	dc000017 	ldw	r16,0(sp)
 320da84:	dec00304 	addi	sp,sp,12
 320da88:	f800283a 	ret
 320da8c:	80800017 	ldw	r2,0(r16)
 320da90:	103ff826 	beq	r2,zero,320da74 <_isatty_r+0x34>
 320da94:	88800015 	stw	r2,0(r17)
 320da98:	1805883a 	mov	r2,r3
 320da9c:	dfc00217 	ldw	ra,8(sp)
 320daa0:	dc400117 	ldw	r17,4(sp)
 320daa4:	dc000017 	ldw	r16,0(sp)
 320daa8:	dec00304 	addi	sp,sp,12
 320daac:	f800283a 	ret

0320dab0 <iswspace>:
 320dab0:	00803fc4 	movi	r2,255
 320dab4:	0007883a 	mov	r3,zero
 320dab8:	11000636 	bltu	r2,r4,320dad4 <iswspace+0x24>
 320dabc:	0080c974 	movhi	r2,805
 320dac0:	108a6204 	addi	r2,r2,10632
 320dac4:	10c00017 	ldw	r3,0(r2)
 320dac8:	1907883a 	add	r3,r3,r4
 320dacc:	18800003 	ldbu	r2,0(r3)
 320dad0:	10c0020c 	andi	r3,r2,8
 320dad4:	1805883a 	mov	r2,r3
 320dad8:	f800283a 	ret

0320dadc <__locale_charset>:
 320dadc:	d0a00617 	ldw	r2,-32744(gp)
 320dae0:	f800283a 	ret

0320dae4 <_localeconv_r>:
 320dae4:	0080c974 	movhi	r2,805
 320dae8:	10b8c704 	addi	r2,r2,-7396
 320daec:	f800283a 	ret

0320daf0 <localeconv>:
 320daf0:	0080c974 	movhi	r2,805
 320daf4:	108a6304 	addi	r2,r2,10636
 320daf8:	11000017 	ldw	r4,0(r2)
 320dafc:	320dae41 	jmpi	320dae4 <_localeconv_r>

0320db00 <_setlocale_r>:
 320db00:	defffc04 	addi	sp,sp,-16
 320db04:	00c0c974 	movhi	r3,805
 320db08:	18f6a904 	addi	r3,r3,-9564
 320db0c:	dc800215 	stw	r18,8(sp)
 320db10:	dc400115 	stw	r17,4(sp)
 320db14:	dc000015 	stw	r16,0(sp)
 320db18:	2023883a 	mov	r17,r4
 320db1c:	2825883a 	mov	r18,r5
 320db20:	dfc00315 	stw	ra,12(sp)
 320db24:	3021883a 	mov	r16,r6
 320db28:	3009883a 	mov	r4,r6
 320db2c:	180b883a 	mov	r5,r3
 320db30:	30000926 	beq	r6,zero,320db58 <_setlocale_r+0x58>
 320db34:	320eebc0 	call	320eebc <strcmp>
 320db38:	8009883a 	mov	r4,r16
 320db3c:	0140c974 	movhi	r5,805
 320db40:	2978a404 	addi	r5,r5,-7536
 320db44:	10000b1e 	bne	r2,zero,320db74 <_setlocale_r+0x74>
 320db48:	8c000d15 	stw	r16,52(r17)
 320db4c:	8c800c15 	stw	r18,48(r17)
 320db50:	00c0c974 	movhi	r3,805
 320db54:	18f6a904 	addi	r3,r3,-9564
 320db58:	1805883a 	mov	r2,r3
 320db5c:	dfc00317 	ldw	ra,12(sp)
 320db60:	dc800217 	ldw	r18,8(sp)
 320db64:	dc400117 	ldw	r17,4(sp)
 320db68:	dc000017 	ldw	r16,0(sp)
 320db6c:	dec00404 	addi	sp,sp,16
 320db70:	f800283a 	ret
 320db74:	320eebc0 	call	320eebc <strcmp>
 320db78:	0007883a 	mov	r3,zero
 320db7c:	103ff226 	beq	r2,zero,320db48 <_setlocale_r+0x48>
 320db80:	003ff506 	br	320db58 <_setlocale_r+0x58>

0320db84 <setlocale>:
 320db84:	0180c974 	movhi	r6,805
 320db88:	318a6304 	addi	r6,r6,10636
 320db8c:	2007883a 	mov	r3,r4
 320db90:	31000017 	ldw	r4,0(r6)
 320db94:	280d883a 	mov	r6,r5
 320db98:	180b883a 	mov	r5,r3
 320db9c:	320db001 	jmpi	320db00 <_setlocale_r>

0320dba0 <_lseek_r>:
 320dba0:	defffd04 	addi	sp,sp,-12
 320dba4:	dc000015 	stw	r16,0(sp)
 320dba8:	0400c974 	movhi	r16,805
 320dbac:	8412f804 	addi	r16,r16,19424
 320dbb0:	dc400115 	stw	r17,4(sp)
 320dbb4:	80000015 	stw	zero,0(r16)
 320dbb8:	2023883a 	mov	r17,r4
 320dbbc:	2809883a 	mov	r4,r5
 320dbc0:	300b883a 	mov	r5,r6
 320dbc4:	380d883a 	mov	r6,r7
 320dbc8:	dfc00215 	stw	ra,8(sp)
 320dbcc:	3214c700 	call	3214c70 <lseek>
 320dbd0:	1007883a 	mov	r3,r2
 320dbd4:	00bfffc4 	movi	r2,-1
 320dbd8:	18800626 	beq	r3,r2,320dbf4 <_lseek_r+0x54>
 320dbdc:	1805883a 	mov	r2,r3
 320dbe0:	dfc00217 	ldw	ra,8(sp)
 320dbe4:	dc400117 	ldw	r17,4(sp)
 320dbe8:	dc000017 	ldw	r16,0(sp)
 320dbec:	dec00304 	addi	sp,sp,12
 320dbf0:	f800283a 	ret
 320dbf4:	80800017 	ldw	r2,0(r16)
 320dbf8:	103ff826 	beq	r2,zero,320dbdc <_lseek_r+0x3c>
 320dbfc:	88800015 	stw	r2,0(r17)
 320dc00:	1805883a 	mov	r2,r3
 320dc04:	dfc00217 	ldw	ra,8(sp)
 320dc08:	dc400117 	ldw	r17,4(sp)
 320dc0c:	dc000017 	ldw	r16,0(sp)
 320dc10:	dec00304 	addi	sp,sp,12
 320dc14:	f800283a 	ret

0320dc18 <_mbrtowc_r>:
 320dc18:	defffc04 	addi	sp,sp,-16
 320dc1c:	dc400215 	stw	r17,8(sp)
 320dc20:	dc000115 	stw	r16,4(sp)
 320dc24:	dfc00315 	stw	ra,12(sp)
 320dc28:	dc000417 	ldw	r16,16(sp)
 320dc2c:	2023883a 	mov	r17,r4
 320dc30:	30000f26 	beq	r6,zero,320dc70 <_mbrtowc_r+0x58>
 320dc34:	dc000015 	stw	r16,0(sp)
 320dc38:	320dcd80 	call	320dcd8 <_mbtowc_r>
 320dc3c:	1007883a 	mov	r3,r2
 320dc40:	00bfffc4 	movi	r2,-1
 320dc44:	1809883a 	mov	r4,r3
 320dc48:	1880111e 	bne	r3,r2,320dc90 <_mbrtowc_r+0x78>
 320dc4c:	80000015 	stw	zero,0(r16)
 320dc50:	00802284 	movi	r2,138
 320dc54:	88800015 	stw	r2,0(r17)
 320dc58:	2005883a 	mov	r2,r4
 320dc5c:	dfc00317 	ldw	ra,12(sp)
 320dc60:	dc400217 	ldw	r17,8(sp)
 320dc64:	dc000117 	ldw	r16,4(sp)
 320dc68:	dec00404 	addi	sp,sp,16
 320dc6c:	f800283a 	ret
 320dc70:	000b883a 	mov	r5,zero
 320dc74:	0180c974 	movhi	r6,805
 320dc78:	31b8a404 	addi	r6,r6,-7536
 320dc7c:	01c00044 	movi	r7,1
 320dc80:	dc000015 	stw	r16,0(sp)
 320dc84:	320dcd80 	call	320dcd8 <_mbtowc_r>
 320dc88:	1007883a 	mov	r3,r2
 320dc8c:	003fec06 	br	320dc40 <_mbrtowc_r+0x28>
 320dc90:	1809883a 	mov	r4,r3
 320dc94:	003ff006 	br	320dc58 <_mbrtowc_r+0x40>

0320dc98 <mbrtowc>:
 320dc98:	0080c974 	movhi	r2,805
 320dc9c:	108a6304 	addi	r2,r2,10636
 320dca0:	2017883a 	mov	r11,r4
 320dca4:	11000017 	ldw	r4,0(r2)
 320dca8:	defffe04 	addi	sp,sp,-8
 320dcac:	3013883a 	mov	r9,r6
 320dcb0:	2805883a 	mov	r2,r5
 320dcb4:	d9c00015 	stw	r7,0(sp)
 320dcb8:	580b883a 	mov	r5,r11
 320dcbc:	100d883a 	mov	r6,r2
 320dcc0:	480f883a 	mov	r7,r9
 320dcc4:	dfc00115 	stw	ra,4(sp)
 320dcc8:	320dc180 	call	320dc18 <_mbrtowc_r>
 320dccc:	dfc00117 	ldw	ra,4(sp)
 320dcd0:	dec00204 	addi	sp,sp,8
 320dcd4:	f800283a 	ret

0320dcd8 <_mbtowc_r>:
 320dcd8:	deffff04 	addi	sp,sp,-4
 320dcdc:	0005883a 	mov	r2,zero
 320dce0:	28000326 	beq	r5,zero,320dcf0 <_mbtowc_r+0x18>
 320dce4:	3000041e 	bne	r6,zero,320dcf8 <_mbtowc_r+0x20>
 320dce8:	dec00104 	addi	sp,sp,4
 320dcec:	f800283a 	ret
 320dcf0:	d80b883a 	mov	r5,sp
 320dcf4:	303ffc26 	beq	r6,zero,320dce8 <_mbtowc_r+0x10>
 320dcf8:	00bfff84 	movi	r2,-2
 320dcfc:	383ffa26 	beq	r7,zero,320dce8 <_mbtowc_r+0x10>
 320dd00:	30800003 	ldbu	r2,0(r6)
 320dd04:	28800015 	stw	r2,0(r5)
 320dd08:	30c00003 	ldbu	r3,0(r6)
 320dd0c:	1804c03a 	cmpne	r2,r3,zero
 320dd10:	dec00104 	addi	sp,sp,4
 320dd14:	f800283a 	ret

0320dd18 <_Bfree>:
 320dd18:	28000826 	beq	r5,zero,320dd3c <_Bfree+0x24>
 320dd1c:	28800117 	ldw	r2,4(r5)
 320dd20:	21001317 	ldw	r4,76(r4)
 320dd24:	1085883a 	add	r2,r2,r2
 320dd28:	1085883a 	add	r2,r2,r2
 320dd2c:	1105883a 	add	r2,r2,r4
 320dd30:	10c00017 	ldw	r3,0(r2)
 320dd34:	28c00015 	stw	r3,0(r5)
 320dd38:	11400015 	stw	r5,0(r2)
 320dd3c:	f800283a 	ret

0320dd40 <__hi0bits>:
 320dd40:	20bfffec 	andhi	r2,r4,65535
 320dd44:	10001426 	beq	r2,zero,320dd98 <__hi0bits+0x58>
 320dd48:	0007883a 	mov	r3,zero
 320dd4c:	20bfc02c 	andhi	r2,r4,65280
 320dd50:	1000021e 	bne	r2,zero,320dd5c <__hi0bits+0x1c>
 320dd54:	2008923a 	slli	r4,r4,8
 320dd58:	18c00204 	addi	r3,r3,8
 320dd5c:	20bc002c 	andhi	r2,r4,61440
 320dd60:	1000021e 	bne	r2,zero,320dd6c <__hi0bits+0x2c>
 320dd64:	2008913a 	slli	r4,r4,4
 320dd68:	18c00104 	addi	r3,r3,4
 320dd6c:	20b0002c 	andhi	r2,r4,49152
 320dd70:	1000031e 	bne	r2,zero,320dd80 <__hi0bits+0x40>
 320dd74:	2105883a 	add	r2,r4,r4
 320dd78:	18c00084 	addi	r3,r3,2
 320dd7c:	1089883a 	add	r4,r2,r2
 320dd80:	20000316 	blt	r4,zero,320dd90 <__hi0bits+0x50>
 320dd84:	2090002c 	andhi	r2,r4,16384
 320dd88:	10000626 	beq	r2,zero,320dda4 <__hi0bits+0x64>
 320dd8c:	18c00044 	addi	r3,r3,1
 320dd90:	1805883a 	mov	r2,r3
 320dd94:	f800283a 	ret
 320dd98:	2008943a 	slli	r4,r4,16
 320dd9c:	00c00404 	movi	r3,16
 320dda0:	003fea06 	br	320dd4c <__hi0bits+0xc>
 320dda4:	00c00804 	movi	r3,32
 320dda8:	1805883a 	mov	r2,r3
 320ddac:	f800283a 	ret

0320ddb0 <__lo0bits>:
 320ddb0:	20c00017 	ldw	r3,0(r4)
 320ddb4:	188001cc 	andi	r2,r3,7
 320ddb8:	10000a26 	beq	r2,zero,320dde4 <__lo0bits+0x34>
 320ddbc:	1880004c 	andi	r2,r3,1
 320ddc0:	1005003a 	cmpeq	r2,r2,zero
 320ddc4:	10002126 	beq	r2,zero,320de4c <__lo0bits+0x9c>
 320ddc8:	1880008c 	andi	r2,r3,2
 320ddcc:	1000251e 	bne	r2,zero,320de64 <__lo0bits+0xb4>
 320ddd0:	1804d0ba 	srli	r2,r3,2
 320ddd4:	01400084 	movi	r5,2
 320ddd8:	20800015 	stw	r2,0(r4)
 320dddc:	2805883a 	mov	r2,r5
 320dde0:	f800283a 	ret
 320dde4:	18bfffcc 	andi	r2,r3,65535
 320dde8:	10001526 	beq	r2,zero,320de40 <__lo0bits+0x90>
 320ddec:	000b883a 	mov	r5,zero
 320ddf0:	18803fcc 	andi	r2,r3,255
 320ddf4:	1000021e 	bne	r2,zero,320de00 <__lo0bits+0x50>
 320ddf8:	1806d23a 	srli	r3,r3,8
 320ddfc:	29400204 	addi	r5,r5,8
 320de00:	188003cc 	andi	r2,r3,15
 320de04:	1000021e 	bne	r2,zero,320de10 <__lo0bits+0x60>
 320de08:	1806d13a 	srli	r3,r3,4
 320de0c:	29400104 	addi	r5,r5,4
 320de10:	188000cc 	andi	r2,r3,3
 320de14:	1000021e 	bne	r2,zero,320de20 <__lo0bits+0x70>
 320de18:	1806d0ba 	srli	r3,r3,2
 320de1c:	29400084 	addi	r5,r5,2
 320de20:	1880004c 	andi	r2,r3,1
 320de24:	1000031e 	bne	r2,zero,320de34 <__lo0bits+0x84>
 320de28:	1806d07a 	srli	r3,r3,1
 320de2c:	18000a26 	beq	r3,zero,320de58 <__lo0bits+0xa8>
 320de30:	29400044 	addi	r5,r5,1
 320de34:	2805883a 	mov	r2,r5
 320de38:	20c00015 	stw	r3,0(r4)
 320de3c:	f800283a 	ret
 320de40:	1806d43a 	srli	r3,r3,16
 320de44:	01400404 	movi	r5,16
 320de48:	003fe906 	br	320ddf0 <__lo0bits+0x40>
 320de4c:	000b883a 	mov	r5,zero
 320de50:	2805883a 	mov	r2,r5
 320de54:	f800283a 	ret
 320de58:	01400804 	movi	r5,32
 320de5c:	2805883a 	mov	r2,r5
 320de60:	f800283a 	ret
 320de64:	1804d07a 	srli	r2,r3,1
 320de68:	01400044 	movi	r5,1
 320de6c:	20800015 	stw	r2,0(r4)
 320de70:	003fda06 	br	320dddc <__lo0bits+0x2c>

0320de74 <__mcmp>:
 320de74:	20800417 	ldw	r2,16(r4)
 320de78:	28c00417 	ldw	r3,16(r5)
 320de7c:	10cfc83a 	sub	r7,r2,r3
 320de80:	38000c1e 	bne	r7,zero,320deb4 <__mcmp+0x40>
 320de84:	18c5883a 	add	r2,r3,r3
 320de88:	1085883a 	add	r2,r2,r2
 320de8c:	10c00504 	addi	r3,r2,20
 320de90:	21000504 	addi	r4,r4,20
 320de94:	28cb883a 	add	r5,r5,r3
 320de98:	2085883a 	add	r2,r4,r2
 320de9c:	10bfff04 	addi	r2,r2,-4
 320dea0:	297fff04 	addi	r5,r5,-4
 320dea4:	11800017 	ldw	r6,0(r2)
 320dea8:	28c00017 	ldw	r3,0(r5)
 320deac:	30c0031e 	bne	r6,r3,320debc <__mcmp+0x48>
 320deb0:	20bffa36 	bltu	r4,r2,320de9c <__mcmp+0x28>
 320deb4:	3805883a 	mov	r2,r7
 320deb8:	f800283a 	ret
 320debc:	30c00336 	bltu	r6,r3,320decc <__mcmp+0x58>
 320dec0:	01c00044 	movi	r7,1
 320dec4:	3805883a 	mov	r2,r7
 320dec8:	f800283a 	ret
 320decc:	01ffffc4 	movi	r7,-1
 320ded0:	003ff806 	br	320deb4 <__mcmp+0x40>

0320ded4 <__ulp>:
 320ded4:	295ffc2c 	andhi	r5,r5,32752
 320ded8:	013f3034 	movhi	r4,64704
 320dedc:	290b883a 	add	r5,r5,r4
 320dee0:	0145c83a 	sub	r2,zero,r5
 320dee4:	1007d53a 	srai	r3,r2,20
 320dee8:	000d883a 	mov	r6,zero
 320deec:	0140040e 	bge	zero,r5,320df00 <__ulp+0x2c>
 320def0:	280f883a 	mov	r7,r5
 320def4:	3807883a 	mov	r3,r7
 320def8:	3005883a 	mov	r2,r6
 320defc:	f800283a 	ret
 320df00:	008004c4 	movi	r2,19
 320df04:	193ffb04 	addi	r4,r3,-20
 320df08:	10c00c0e 	bge	r2,r3,320df3c <__ulp+0x68>
 320df0c:	008007c4 	movi	r2,31
 320df10:	1107c83a 	sub	r3,r2,r4
 320df14:	00800784 	movi	r2,30
 320df18:	01400044 	movi	r5,1
 320df1c:	11000216 	blt	r2,r4,320df28 <__ulp+0x54>
 320df20:	00800044 	movi	r2,1
 320df24:	10ca983a 	sll	r5,r2,r3
 320df28:	000f883a 	mov	r7,zero
 320df2c:	280d883a 	mov	r6,r5
 320df30:	3807883a 	mov	r3,r7
 320df34:	3005883a 	mov	r2,r6
 320df38:	f800283a 	ret
 320df3c:	00800234 	movhi	r2,8
 320df40:	10cfd83a 	sra	r7,r2,r3
 320df44:	000d883a 	mov	r6,zero
 320df48:	3005883a 	mov	r2,r6
 320df4c:	3807883a 	mov	r3,r7
 320df50:	f800283a 	ret

0320df54 <__b2d>:
 320df54:	20800417 	ldw	r2,16(r4)
 320df58:	defff904 	addi	sp,sp,-28
 320df5c:	dd000415 	stw	r20,16(sp)
 320df60:	1085883a 	add	r2,r2,r2
 320df64:	25000504 	addi	r20,r4,20
 320df68:	1085883a 	add	r2,r2,r2
 320df6c:	dc000015 	stw	r16,0(sp)
 320df70:	a0a1883a 	add	r16,r20,r2
 320df74:	dd400515 	stw	r21,20(sp)
 320df78:	857fff17 	ldw	r21,-4(r16)
 320df7c:	dc400115 	stw	r17,4(sp)
 320df80:	dfc00615 	stw	ra,24(sp)
 320df84:	a809883a 	mov	r4,r21
 320df88:	2823883a 	mov	r17,r5
 320df8c:	dcc00315 	stw	r19,12(sp)
 320df90:	dc800215 	stw	r18,8(sp)
 320df94:	320dd400 	call	320dd40 <__hi0bits>
 320df98:	100b883a 	mov	r5,r2
 320df9c:	00800804 	movi	r2,32
 320dfa0:	1145c83a 	sub	r2,r2,r5
 320dfa4:	88800015 	stw	r2,0(r17)
 320dfa8:	00800284 	movi	r2,10
 320dfac:	80ffff04 	addi	r3,r16,-4
 320dfb0:	11401416 	blt	r2,r5,320e004 <__b2d+0xb0>
 320dfb4:	008002c4 	movi	r2,11
 320dfb8:	1149c83a 	sub	r4,r2,r5
 320dfbc:	a0c02736 	bltu	r20,r3,320e05c <__b2d+0x108>
 320dfc0:	000d883a 	mov	r6,zero
 320dfc4:	28800544 	addi	r2,r5,21
 320dfc8:	a906d83a 	srl	r3,r21,r4
 320dfcc:	a884983a 	sll	r2,r21,r2
 320dfd0:	1ccffc34 	orhi	r19,r3,16368
 320dfd4:	11a4b03a 	or	r18,r2,r6
 320dfd8:	9005883a 	mov	r2,r18
 320dfdc:	9807883a 	mov	r3,r19
 320dfe0:	dfc00617 	ldw	ra,24(sp)
 320dfe4:	dd400517 	ldw	r21,20(sp)
 320dfe8:	dd000417 	ldw	r20,16(sp)
 320dfec:	dcc00317 	ldw	r19,12(sp)
 320dff0:	dc800217 	ldw	r18,8(sp)
 320dff4:	dc400117 	ldw	r17,4(sp)
 320dff8:	dc000017 	ldw	r16,0(sp)
 320dffc:	dec00704 	addi	sp,sp,28
 320e000:	f800283a 	ret
 320e004:	a0c00e36 	bltu	r20,r3,320e040 <__b2d+0xec>
 320e008:	293ffd44 	addi	r4,r5,-11
 320e00c:	000d883a 	mov	r6,zero
 320e010:	20000f26 	beq	r4,zero,320e050 <__b2d+0xfc>
 320e014:	00800804 	movi	r2,32
 320e018:	110bc83a 	sub	r5,r2,r4
 320e01c:	a0c01236 	bltu	r20,r3,320e068 <__b2d+0x114>
 320e020:	000f883a 	mov	r7,zero
 320e024:	a904983a 	sll	r2,r21,r4
 320e028:	3146d83a 	srl	r3,r6,r5
 320e02c:	3108983a 	sll	r4,r6,r4
 320e030:	108ffc34 	orhi	r2,r2,16368
 320e034:	18a6b03a 	or	r19,r3,r2
 320e038:	3924b03a 	or	r18,r7,r4
 320e03c:	003fe606 	br	320dfd8 <__b2d+0x84>
 320e040:	293ffd44 	addi	r4,r5,-11
 320e044:	81bffe17 	ldw	r6,-8(r16)
 320e048:	80fffe04 	addi	r3,r16,-8
 320e04c:	203ff11e 	bne	r4,zero,320e014 <__b2d+0xc0>
 320e050:	accffc34 	orhi	r19,r21,16368
 320e054:	3025883a 	mov	r18,r6
 320e058:	003fdf06 	br	320dfd8 <__b2d+0x84>
 320e05c:	18bfff17 	ldw	r2,-4(r3)
 320e060:	110cd83a 	srl	r6,r2,r4
 320e064:	003fd706 	br	320dfc4 <__b2d+0x70>
 320e068:	18bfff17 	ldw	r2,-4(r3)
 320e06c:	114ed83a 	srl	r7,r2,r5
 320e070:	003fec06 	br	320e024 <__b2d+0xd0>

0320e074 <__ratio>:
 320e074:	defff904 	addi	sp,sp,-28
 320e078:	dc400215 	stw	r17,8(sp)
 320e07c:	2823883a 	mov	r17,r5
 320e080:	d80b883a 	mov	r5,sp
 320e084:	dfc00615 	stw	ra,24(sp)
 320e088:	dd000515 	stw	r20,20(sp)
 320e08c:	dcc00415 	stw	r19,16(sp)
 320e090:	dc800315 	stw	r18,12(sp)
 320e094:	2025883a 	mov	r18,r4
 320e098:	320df540 	call	320df54 <__b2d>
 320e09c:	8809883a 	mov	r4,r17
 320e0a0:	d9400104 	addi	r5,sp,4
 320e0a4:	1027883a 	mov	r19,r2
 320e0a8:	1829883a 	mov	r20,r3
 320e0ac:	320df540 	call	320df54 <__b2d>
 320e0b0:	89000417 	ldw	r4,16(r17)
 320e0b4:	91c00417 	ldw	r7,16(r18)
 320e0b8:	d9800117 	ldw	r6,4(sp)
 320e0bc:	180b883a 	mov	r5,r3
 320e0c0:	390fc83a 	sub	r7,r7,r4
 320e0c4:	1009883a 	mov	r4,r2
 320e0c8:	d8800017 	ldw	r2,0(sp)
 320e0cc:	380e917a 	slli	r7,r7,5
 320e0d0:	2011883a 	mov	r8,r4
 320e0d4:	1185c83a 	sub	r2,r2,r6
 320e0d8:	11c5883a 	add	r2,r2,r7
 320e0dc:	1006953a 	slli	r3,r2,20
 320e0e0:	2813883a 	mov	r9,r5
 320e0e4:	00800d0e 	bge	zero,r2,320e11c <__ratio+0xa8>
 320e0e8:	1d29883a 	add	r20,r3,r20
 320e0ec:	a00b883a 	mov	r5,r20
 320e0f0:	480f883a 	mov	r7,r9
 320e0f4:	9809883a 	mov	r4,r19
 320e0f8:	400d883a 	mov	r6,r8
 320e0fc:	32136700 	call	3213670 <__divdf3>
 320e100:	dfc00617 	ldw	ra,24(sp)
 320e104:	dd000517 	ldw	r20,20(sp)
 320e108:	dcc00417 	ldw	r19,16(sp)
 320e10c:	dc800317 	ldw	r18,12(sp)
 320e110:	dc400217 	ldw	r17,8(sp)
 320e114:	dec00704 	addi	sp,sp,28
 320e118:	f800283a 	ret
 320e11c:	28d3c83a 	sub	r9,r5,r3
 320e120:	003ff206 	br	320e0ec <__ratio+0x78>

0320e124 <_mprec_log10>:
 320e124:	defffe04 	addi	sp,sp,-8
 320e128:	008005c4 	movi	r2,23
 320e12c:	dc000015 	stw	r16,0(sp)
 320e130:	dfc00115 	stw	ra,4(sp)
 320e134:	2021883a 	mov	r16,r4
 320e138:	11000c16 	blt	r2,r4,320e16c <_mprec_log10+0x48>
 320e13c:	200490fa 	slli	r2,r4,3
 320e140:	00c0c974 	movhi	r3,805
 320e144:	18f8d304 	addi	r3,r3,-7348
 320e148:	10c5883a 	add	r2,r2,r3
 320e14c:	12400117 	ldw	r9,4(r2)
 320e150:	12000017 	ldw	r8,0(r2)
 320e154:	4807883a 	mov	r3,r9
 320e158:	4005883a 	mov	r2,r8
 320e15c:	dfc00117 	ldw	ra,4(sp)
 320e160:	dc000017 	ldw	r16,0(sp)
 320e164:	dec00204 	addi	sp,sp,8
 320e168:	f800283a 	ret
 320e16c:	0011883a 	mov	r8,zero
 320e170:	024ffc34 	movhi	r9,16368
 320e174:	0005883a 	mov	r2,zero
 320e178:	00d00934 	movhi	r3,16420
 320e17c:	480b883a 	mov	r5,r9
 320e180:	4009883a 	mov	r4,r8
 320e184:	180f883a 	mov	r7,r3
 320e188:	100d883a 	mov	r6,r2
 320e18c:	32132ac0 	call	32132ac <__muldf3>
 320e190:	843fffc4 	addi	r16,r16,-1
 320e194:	1011883a 	mov	r8,r2
 320e198:	1813883a 	mov	r9,r3
 320e19c:	803ff51e 	bne	r16,zero,320e174 <_mprec_log10+0x50>
 320e1a0:	4005883a 	mov	r2,r8
 320e1a4:	4807883a 	mov	r3,r9
 320e1a8:	dfc00117 	ldw	ra,4(sp)
 320e1ac:	dc000017 	ldw	r16,0(sp)
 320e1b0:	dec00204 	addi	sp,sp,8
 320e1b4:	f800283a 	ret

0320e1b8 <__copybits>:
 320e1b8:	297fffc4 	addi	r5,r5,-1
 320e1bc:	30800417 	ldw	r2,16(r6)
 320e1c0:	280bd17a 	srai	r5,r5,5
 320e1c4:	31800504 	addi	r6,r6,20
 320e1c8:	1085883a 	add	r2,r2,r2
 320e1cc:	294b883a 	add	r5,r5,r5
 320e1d0:	294b883a 	add	r5,r5,r5
 320e1d4:	1085883a 	add	r2,r2,r2
 320e1d8:	290b883a 	add	r5,r5,r4
 320e1dc:	3087883a 	add	r3,r6,r2
 320e1e0:	29400104 	addi	r5,r5,4
 320e1e4:	30c0052e 	bgeu	r6,r3,320e1fc <__copybits+0x44>
 320e1e8:	30800017 	ldw	r2,0(r6)
 320e1ec:	31800104 	addi	r6,r6,4
 320e1f0:	20800015 	stw	r2,0(r4)
 320e1f4:	21000104 	addi	r4,r4,4
 320e1f8:	30fffb36 	bltu	r6,r3,320e1e8 <__copybits+0x30>
 320e1fc:	2140032e 	bgeu	r4,r5,320e20c <__copybits+0x54>
 320e200:	20000015 	stw	zero,0(r4)
 320e204:	21000104 	addi	r4,r4,4
 320e208:	217ffd36 	bltu	r4,r5,320e200 <__copybits+0x48>
 320e20c:	f800283a 	ret

0320e210 <__any_on>:
 320e210:	20800417 	ldw	r2,16(r4)
 320e214:	2807d17a 	srai	r3,r5,5
 320e218:	21000504 	addi	r4,r4,20
 320e21c:	10c00d0e 	bge	r2,r3,320e254 <__any_on+0x44>
 320e220:	1085883a 	add	r2,r2,r2
 320e224:	1085883a 	add	r2,r2,r2
 320e228:	208d883a 	add	r6,r4,r2
 320e22c:	2180182e 	bgeu	r4,r6,320e290 <__any_on+0x80>
 320e230:	30bfff17 	ldw	r2,-4(r6)
 320e234:	30ffff04 	addi	r3,r6,-4
 320e238:	1000041e 	bne	r2,zero,320e24c <__any_on+0x3c>
 320e23c:	20c0142e 	bgeu	r4,r3,320e290 <__any_on+0x80>
 320e240:	18ffff04 	addi	r3,r3,-4
 320e244:	18800017 	ldw	r2,0(r3)
 320e248:	103ffc26 	beq	r2,zero,320e23c <__any_on+0x2c>
 320e24c:	00800044 	movi	r2,1
 320e250:	f800283a 	ret
 320e254:	18800a0e 	bge	r3,r2,320e280 <__any_on+0x70>
 320e258:	294007cc 	andi	r5,r5,31
 320e25c:	28000826 	beq	r5,zero,320e280 <__any_on+0x70>
 320e260:	18c5883a 	add	r2,r3,r3
 320e264:	1085883a 	add	r2,r2,r2
 320e268:	208d883a 	add	r6,r4,r2
 320e26c:	30c00017 	ldw	r3,0(r6)
 320e270:	1944d83a 	srl	r2,r3,r5
 320e274:	1144983a 	sll	r2,r2,r5
 320e278:	18bff41e 	bne	r3,r2,320e24c <__any_on+0x3c>
 320e27c:	003feb06 	br	320e22c <__any_on+0x1c>
 320e280:	18c5883a 	add	r2,r3,r3
 320e284:	1085883a 	add	r2,r2,r2
 320e288:	208d883a 	add	r6,r4,r2
 320e28c:	003fe706 	br	320e22c <__any_on+0x1c>
 320e290:	0005883a 	mov	r2,zero
 320e294:	f800283a 	ret

0320e298 <_Balloc>:
 320e298:	20c01317 	ldw	r3,76(r4)
 320e29c:	defffb04 	addi	sp,sp,-20
 320e2a0:	dcc00315 	stw	r19,12(sp)
 320e2a4:	dc800215 	stw	r18,8(sp)
 320e2a8:	dfc00415 	stw	ra,16(sp)
 320e2ac:	2825883a 	mov	r18,r5
 320e2b0:	dc400115 	stw	r17,4(sp)
 320e2b4:	dc000015 	stw	r16,0(sp)
 320e2b8:	2027883a 	mov	r19,r4
 320e2bc:	01800404 	movi	r6,16
 320e2c0:	01400104 	movi	r5,4
 320e2c4:	18001726 	beq	r3,zero,320e324 <_Balloc+0x8c>
 320e2c8:	01400044 	movi	r5,1
 320e2cc:	9485883a 	add	r2,r18,r18
 320e2d0:	2ca2983a 	sll	r17,r5,r18
 320e2d4:	1085883a 	add	r2,r2,r2
 320e2d8:	10c7883a 	add	r3,r2,r3
 320e2dc:	1c000017 	ldw	r16,0(r3)
 320e2e0:	8c4d883a 	add	r6,r17,r17
 320e2e4:	318d883a 	add	r6,r6,r6
 320e2e8:	9809883a 	mov	r4,r19
 320e2ec:	31800504 	addi	r6,r6,20
 320e2f0:	80001226 	beq	r16,zero,320e33c <_Balloc+0xa4>
 320e2f4:	80800017 	ldw	r2,0(r16)
 320e2f8:	18800015 	stw	r2,0(r3)
 320e2fc:	80000415 	stw	zero,16(r16)
 320e300:	80000315 	stw	zero,12(r16)
 320e304:	8005883a 	mov	r2,r16
 320e308:	dfc00417 	ldw	ra,16(sp)
 320e30c:	dcc00317 	ldw	r19,12(sp)
 320e310:	dc800217 	ldw	r18,8(sp)
 320e314:	dc400117 	ldw	r17,4(sp)
 320e318:	dc000017 	ldw	r16,0(sp)
 320e31c:	dec00504 	addi	sp,sp,20
 320e320:	f800283a 	ret
 320e324:	321133c0 	call	321133c <_calloc_r>
 320e328:	1007883a 	mov	r3,r2
 320e32c:	0021883a 	mov	r16,zero
 320e330:	98801315 	stw	r2,76(r19)
 320e334:	103fe41e 	bne	r2,zero,320e2c8 <_Balloc+0x30>
 320e338:	003ff206 	br	320e304 <_Balloc+0x6c>
 320e33c:	321133c0 	call	321133c <_calloc_r>
 320e340:	103ff026 	beq	r2,zero,320e304 <_Balloc+0x6c>
 320e344:	1021883a 	mov	r16,r2
 320e348:	14800115 	stw	r18,4(r2)
 320e34c:	14400215 	stw	r17,8(r2)
 320e350:	003fea06 	br	320e2fc <_Balloc+0x64>

0320e354 <__d2b>:
 320e354:	defff504 	addi	sp,sp,-44
 320e358:	dcc00515 	stw	r19,20(sp)
 320e35c:	04c00044 	movi	r19,1
 320e360:	dc000215 	stw	r16,8(sp)
 320e364:	2821883a 	mov	r16,r5
 320e368:	980b883a 	mov	r5,r19
 320e36c:	ddc00915 	stw	r23,36(sp)
 320e370:	dd800815 	stw	r22,32(sp)
 320e374:	dd400715 	stw	r21,28(sp)
 320e378:	dd000615 	stw	r20,24(sp)
 320e37c:	dc800415 	stw	r18,16(sp)
 320e380:	dc400315 	stw	r17,12(sp)
 320e384:	dfc00a15 	stw	ra,40(sp)
 320e388:	3023883a 	mov	r17,r6
 320e38c:	382d883a 	mov	r22,r7
 320e390:	ddc00b17 	ldw	r23,44(sp)
 320e394:	320e2980 	call	320e298 <_Balloc>
 320e398:	1025883a 	mov	r18,r2
 320e39c:	00a00034 	movhi	r2,32768
 320e3a0:	10bfffc4 	addi	r2,r2,-1
 320e3a4:	8888703a 	and	r4,r17,r2
 320e3a8:	202ad53a 	srli	r21,r4,20
 320e3ac:	00800434 	movhi	r2,16
 320e3b0:	10bfffc4 	addi	r2,r2,-1
 320e3b4:	8886703a 	and	r3,r17,r2
 320e3b8:	a829003a 	cmpeq	r20,r21,zero
 320e3bc:	800b883a 	mov	r5,r16
 320e3c0:	d8c00115 	stw	r3,4(sp)
 320e3c4:	94000504 	addi	r16,r18,20
 320e3c8:	a000021e 	bne	r20,zero,320e3d4 <__d2b+0x80>
 320e3cc:	18c00434 	orhi	r3,r3,16
 320e3d0:	d8c00115 	stw	r3,4(sp)
 320e3d4:	28002726 	beq	r5,zero,320e474 <__d2b+0x120>
 320e3d8:	d809883a 	mov	r4,sp
 320e3dc:	d9400015 	stw	r5,0(sp)
 320e3e0:	320ddb00 	call	320ddb0 <__lo0bits>
 320e3e4:	100d883a 	mov	r6,r2
 320e3e8:	10003526 	beq	r2,zero,320e4c0 <__d2b+0x16c>
 320e3ec:	d8c00117 	ldw	r3,4(sp)
 320e3f0:	00800804 	movi	r2,32
 320e3f4:	1185c83a 	sub	r2,r2,r6
 320e3f8:	d9000017 	ldw	r4,0(sp)
 320e3fc:	1886983a 	sll	r3,r3,r2
 320e400:	1906b03a 	or	r3,r3,r4
 320e404:	90c00515 	stw	r3,20(r18)
 320e408:	d8c00117 	ldw	r3,4(sp)
 320e40c:	1986d83a 	srl	r3,r3,r6
 320e410:	d8c00115 	stw	r3,4(sp)
 320e414:	180b003a 	cmpeq	r5,r3,zero
 320e418:	00800084 	movi	r2,2
 320e41c:	114bc83a 	sub	r5,r2,r5
 320e420:	80c00115 	stw	r3,4(r16)
 320e424:	91400415 	stw	r5,16(r18)
 320e428:	a0001a1e 	bne	r20,zero,320e494 <__d2b+0x140>
 320e42c:	3545883a 	add	r2,r6,r21
 320e430:	10bef344 	addi	r2,r2,-1075
 320e434:	00c00d44 	movi	r3,53
 320e438:	b0800015 	stw	r2,0(r22)
 320e43c:	1987c83a 	sub	r3,r3,r6
 320e440:	b8c00015 	stw	r3,0(r23)
 320e444:	9005883a 	mov	r2,r18
 320e448:	dfc00a17 	ldw	ra,40(sp)
 320e44c:	ddc00917 	ldw	r23,36(sp)
 320e450:	dd800817 	ldw	r22,32(sp)
 320e454:	dd400717 	ldw	r21,28(sp)
 320e458:	dd000617 	ldw	r20,24(sp)
 320e45c:	dcc00517 	ldw	r19,20(sp)
 320e460:	dc800417 	ldw	r18,16(sp)
 320e464:	dc400317 	ldw	r17,12(sp)
 320e468:	dc000217 	ldw	r16,8(sp)
 320e46c:	dec00b04 	addi	sp,sp,44
 320e470:	f800283a 	ret
 320e474:	d9000104 	addi	r4,sp,4
 320e478:	320ddb00 	call	320ddb0 <__lo0bits>
 320e47c:	11800804 	addi	r6,r2,32
 320e480:	d8800117 	ldw	r2,4(sp)
 320e484:	94c00415 	stw	r19,16(r18)
 320e488:	980b883a 	mov	r5,r19
 320e48c:	90800515 	stw	r2,20(r18)
 320e490:	a03fe626 	beq	r20,zero,320e42c <__d2b+0xd8>
 320e494:	2945883a 	add	r2,r5,r5
 320e498:	1085883a 	add	r2,r2,r2
 320e49c:	1405883a 	add	r2,r2,r16
 320e4a0:	113fff17 	ldw	r4,-4(r2)
 320e4a4:	30fef384 	addi	r3,r6,-1074
 320e4a8:	2820917a 	slli	r16,r5,5
 320e4ac:	b0c00015 	stw	r3,0(r22)
 320e4b0:	320dd400 	call	320dd40 <__hi0bits>
 320e4b4:	80a1c83a 	sub	r16,r16,r2
 320e4b8:	bc000015 	stw	r16,0(r23)
 320e4bc:	003fe106 	br	320e444 <__d2b+0xf0>
 320e4c0:	d8800017 	ldw	r2,0(sp)
 320e4c4:	90800515 	stw	r2,20(r18)
 320e4c8:	d8c00117 	ldw	r3,4(sp)
 320e4cc:	003fd106 	br	320e414 <__d2b+0xc0>

0320e4d0 <__mdiff>:
 320e4d0:	defffb04 	addi	sp,sp,-20
 320e4d4:	dc000015 	stw	r16,0(sp)
 320e4d8:	2821883a 	mov	r16,r5
 320e4dc:	dc800215 	stw	r18,8(sp)
 320e4e0:	300b883a 	mov	r5,r6
 320e4e4:	2025883a 	mov	r18,r4
 320e4e8:	8009883a 	mov	r4,r16
 320e4ec:	dc400115 	stw	r17,4(sp)
 320e4f0:	dfc00415 	stw	ra,16(sp)
 320e4f4:	dcc00315 	stw	r19,12(sp)
 320e4f8:	3023883a 	mov	r17,r6
 320e4fc:	320de740 	call	320de74 <__mcmp>
 320e500:	10004226 	beq	r2,zero,320e60c <__mdiff+0x13c>
 320e504:	10005016 	blt	r2,zero,320e648 <__mdiff+0x178>
 320e508:	0027883a 	mov	r19,zero
 320e50c:	81400117 	ldw	r5,4(r16)
 320e510:	9009883a 	mov	r4,r18
 320e514:	320e2980 	call	320e298 <_Balloc>
 320e518:	1019883a 	mov	r12,r2
 320e51c:	82800417 	ldw	r10,16(r16)
 320e520:	88800417 	ldw	r2,16(r17)
 320e524:	81800504 	addi	r6,r16,20
 320e528:	5287883a 	add	r3,r10,r10
 320e52c:	1085883a 	add	r2,r2,r2
 320e530:	18c7883a 	add	r3,r3,r3
 320e534:	1085883a 	add	r2,r2,r2
 320e538:	8a000504 	addi	r8,r17,20
 320e53c:	64c00315 	stw	r19,12(r12)
 320e540:	30db883a 	add	r13,r6,r3
 320e544:	4097883a 	add	r11,r8,r2
 320e548:	61c00504 	addi	r7,r12,20
 320e54c:	0013883a 	mov	r9,zero
 320e550:	31000017 	ldw	r4,0(r6)
 320e554:	41400017 	ldw	r5,0(r8)
 320e558:	42000104 	addi	r8,r8,4
 320e55c:	20bfffcc 	andi	r2,r4,65535
 320e560:	28ffffcc 	andi	r3,r5,65535
 320e564:	10c5c83a 	sub	r2,r2,r3
 320e568:	1245883a 	add	r2,r2,r9
 320e56c:	2008d43a 	srli	r4,r4,16
 320e570:	280ad43a 	srli	r5,r5,16
 320e574:	1007d43a 	srai	r3,r2,16
 320e578:	3880000d 	sth	r2,0(r7)
 320e57c:	2149c83a 	sub	r4,r4,r5
 320e580:	20c9883a 	add	r4,r4,r3
 320e584:	3900008d 	sth	r4,2(r7)
 320e588:	31800104 	addi	r6,r6,4
 320e58c:	39c00104 	addi	r7,r7,4
 320e590:	2013d43a 	srai	r9,r4,16
 320e594:	42ffee36 	bltu	r8,r11,320e550 <__mdiff+0x80>
 320e598:	33400c2e 	bgeu	r6,r13,320e5cc <__mdiff+0xfc>
 320e59c:	30800017 	ldw	r2,0(r6)
 320e5a0:	31800104 	addi	r6,r6,4
 320e5a4:	10ffffcc 	andi	r3,r2,65535
 320e5a8:	1a47883a 	add	r3,r3,r9
 320e5ac:	1004d43a 	srli	r2,r2,16
 320e5b0:	1809d43a 	srai	r4,r3,16
 320e5b4:	38c0000d 	sth	r3,0(r7)
 320e5b8:	1105883a 	add	r2,r2,r4
 320e5bc:	3880008d 	sth	r2,2(r7)
 320e5c0:	1013d43a 	srai	r9,r2,16
 320e5c4:	39c00104 	addi	r7,r7,4
 320e5c8:	337ff436 	bltu	r6,r13,320e59c <__mdiff+0xcc>
 320e5cc:	38bfff17 	ldw	r2,-4(r7)
 320e5d0:	38ffff04 	addi	r3,r7,-4
 320e5d4:	1000041e 	bne	r2,zero,320e5e8 <__mdiff+0x118>
 320e5d8:	18ffff04 	addi	r3,r3,-4
 320e5dc:	18800017 	ldw	r2,0(r3)
 320e5e0:	52bfffc4 	addi	r10,r10,-1
 320e5e4:	103ffc26 	beq	r2,zero,320e5d8 <__mdiff+0x108>
 320e5e8:	6005883a 	mov	r2,r12
 320e5ec:	62800415 	stw	r10,16(r12)
 320e5f0:	dfc00417 	ldw	ra,16(sp)
 320e5f4:	dcc00317 	ldw	r19,12(sp)
 320e5f8:	dc800217 	ldw	r18,8(sp)
 320e5fc:	dc400117 	ldw	r17,4(sp)
 320e600:	dc000017 	ldw	r16,0(sp)
 320e604:	dec00504 	addi	sp,sp,20
 320e608:	f800283a 	ret
 320e60c:	9009883a 	mov	r4,r18
 320e610:	000b883a 	mov	r5,zero
 320e614:	320e2980 	call	320e298 <_Balloc>
 320e618:	1019883a 	mov	r12,r2
 320e61c:	00800044 	movi	r2,1
 320e620:	60800415 	stw	r2,16(r12)
 320e624:	6005883a 	mov	r2,r12
 320e628:	60000515 	stw	zero,20(r12)
 320e62c:	dfc00417 	ldw	ra,16(sp)
 320e630:	dcc00317 	ldw	r19,12(sp)
 320e634:	dc800217 	ldw	r18,8(sp)
 320e638:	dc400117 	ldw	r17,4(sp)
 320e63c:	dc000017 	ldw	r16,0(sp)
 320e640:	dec00504 	addi	sp,sp,20
 320e644:	f800283a 	ret
 320e648:	880d883a 	mov	r6,r17
 320e64c:	04c00044 	movi	r19,1
 320e650:	8023883a 	mov	r17,r16
 320e654:	3021883a 	mov	r16,r6
 320e658:	003fac06 	br	320e50c <__mdiff+0x3c>

0320e65c <__lshift>:
 320e65c:	defff904 	addi	sp,sp,-28
 320e660:	28800417 	ldw	r2,16(r5)
 320e664:	dc000015 	stw	r16,0(sp)
 320e668:	3021d17a 	srai	r16,r6,5
 320e66c:	28c00217 	ldw	r3,8(r5)
 320e670:	10800044 	addi	r2,r2,1
 320e674:	dc400115 	stw	r17,4(sp)
 320e678:	80a3883a 	add	r17,r16,r2
 320e67c:	dd400515 	stw	r21,20(sp)
 320e680:	dd000415 	stw	r20,16(sp)
 320e684:	dc800215 	stw	r18,8(sp)
 320e688:	dfc00615 	stw	ra,24(sp)
 320e68c:	2825883a 	mov	r18,r5
 320e690:	dcc00315 	stw	r19,12(sp)
 320e694:	3029883a 	mov	r20,r6
 320e698:	202b883a 	mov	r21,r4
 320e69c:	29400117 	ldw	r5,4(r5)
 320e6a0:	1c40030e 	bge	r3,r17,320e6b0 <__lshift+0x54>
 320e6a4:	18c7883a 	add	r3,r3,r3
 320e6a8:	29400044 	addi	r5,r5,1
 320e6ac:	1c7ffd16 	blt	r3,r17,320e6a4 <__lshift+0x48>
 320e6b0:	a809883a 	mov	r4,r21
 320e6b4:	320e2980 	call	320e298 <_Balloc>
 320e6b8:	1027883a 	mov	r19,r2
 320e6bc:	11400504 	addi	r5,r2,20
 320e6c0:	0400090e 	bge	zero,r16,320e6e8 <__lshift+0x8c>
 320e6c4:	2805883a 	mov	r2,r5
 320e6c8:	0007883a 	mov	r3,zero
 320e6cc:	18c00044 	addi	r3,r3,1
 320e6d0:	10000015 	stw	zero,0(r2)
 320e6d4:	10800104 	addi	r2,r2,4
 320e6d8:	80fffc1e 	bne	r16,r3,320e6cc <__lshift+0x70>
 320e6dc:	8405883a 	add	r2,r16,r16
 320e6e0:	1085883a 	add	r2,r2,r2
 320e6e4:	288b883a 	add	r5,r5,r2
 320e6e8:	90800417 	ldw	r2,16(r18)
 320e6ec:	91000504 	addi	r4,r18,20
 320e6f0:	a18007cc 	andi	r6,r20,31
 320e6f4:	1085883a 	add	r2,r2,r2
 320e6f8:	1085883a 	add	r2,r2,r2
 320e6fc:	208f883a 	add	r7,r4,r2
 320e700:	30001e26 	beq	r6,zero,320e77c <__lshift+0x120>
 320e704:	00800804 	movi	r2,32
 320e708:	1191c83a 	sub	r8,r2,r6
 320e70c:	0007883a 	mov	r3,zero
 320e710:	20800017 	ldw	r2,0(r4)
 320e714:	1184983a 	sll	r2,r2,r6
 320e718:	1884b03a 	or	r2,r3,r2
 320e71c:	28800015 	stw	r2,0(r5)
 320e720:	20c00017 	ldw	r3,0(r4)
 320e724:	21000104 	addi	r4,r4,4
 320e728:	29400104 	addi	r5,r5,4
 320e72c:	1a06d83a 	srl	r3,r3,r8
 320e730:	21fff736 	bltu	r4,r7,320e710 <__lshift+0xb4>
 320e734:	28c00015 	stw	r3,0(r5)
 320e738:	18000126 	beq	r3,zero,320e740 <__lshift+0xe4>
 320e73c:	8c400044 	addi	r17,r17,1
 320e740:	88bfffc4 	addi	r2,r17,-1
 320e744:	98800415 	stw	r2,16(r19)
 320e748:	a809883a 	mov	r4,r21
 320e74c:	900b883a 	mov	r5,r18
 320e750:	320dd180 	call	320dd18 <_Bfree>
 320e754:	9805883a 	mov	r2,r19
 320e758:	dfc00617 	ldw	ra,24(sp)
 320e75c:	dd400517 	ldw	r21,20(sp)
 320e760:	dd000417 	ldw	r20,16(sp)
 320e764:	dcc00317 	ldw	r19,12(sp)
 320e768:	dc800217 	ldw	r18,8(sp)
 320e76c:	dc400117 	ldw	r17,4(sp)
 320e770:	dc000017 	ldw	r16,0(sp)
 320e774:	dec00704 	addi	sp,sp,28
 320e778:	f800283a 	ret
 320e77c:	20800017 	ldw	r2,0(r4)
 320e780:	21000104 	addi	r4,r4,4
 320e784:	28800015 	stw	r2,0(r5)
 320e788:	29400104 	addi	r5,r5,4
 320e78c:	21ffec2e 	bgeu	r4,r7,320e740 <__lshift+0xe4>
 320e790:	20800017 	ldw	r2,0(r4)
 320e794:	21000104 	addi	r4,r4,4
 320e798:	28800015 	stw	r2,0(r5)
 320e79c:	29400104 	addi	r5,r5,4
 320e7a0:	21fff636 	bltu	r4,r7,320e77c <__lshift+0x120>
 320e7a4:	003fe606 	br	320e740 <__lshift+0xe4>

0320e7a8 <__multiply>:
 320e7a8:	defff904 	addi	sp,sp,-28
 320e7ac:	dcc00315 	stw	r19,12(sp)
 320e7b0:	dc800215 	stw	r18,8(sp)
 320e7b4:	2cc00417 	ldw	r19,16(r5)
 320e7b8:	34800417 	ldw	r18,16(r6)
 320e7bc:	dd000415 	stw	r20,16(sp)
 320e7c0:	dc400115 	stw	r17,4(sp)
 320e7c4:	dfc00615 	stw	ra,24(sp)
 320e7c8:	dd400515 	stw	r21,20(sp)
 320e7cc:	dc000015 	stw	r16,0(sp)
 320e7d0:	2823883a 	mov	r17,r5
 320e7d4:	3029883a 	mov	r20,r6
 320e7d8:	9c80040e 	bge	r19,r18,320e7ec <__multiply+0x44>
 320e7dc:	9027883a 	mov	r19,r18
 320e7e0:	2c800417 	ldw	r18,16(r5)
 320e7e4:	2829883a 	mov	r20,r5
 320e7e8:	3023883a 	mov	r17,r6
 320e7ec:	88800217 	ldw	r2,8(r17)
 320e7f0:	9ca1883a 	add	r16,r19,r18
 320e7f4:	89400117 	ldw	r5,4(r17)
 320e7f8:	1400010e 	bge	r2,r16,320e800 <__multiply+0x58>
 320e7fc:	29400044 	addi	r5,r5,1
 320e800:	320e2980 	call	320e298 <_Balloc>
 320e804:	102b883a 	mov	r21,r2
 320e808:	8405883a 	add	r2,r16,r16
 320e80c:	1085883a 	add	r2,r2,r2
 320e810:	a9000504 	addi	r4,r21,20
 320e814:	209d883a 	add	r14,r4,r2
 320e818:	2380042e 	bgeu	r4,r14,320e82c <__multiply+0x84>
 320e81c:	2005883a 	mov	r2,r4
 320e820:	10000015 	stw	zero,0(r2)
 320e824:	10800104 	addi	r2,r2,4
 320e828:	13bffd36 	bltu	r2,r14,320e820 <__multiply+0x78>
 320e82c:	9485883a 	add	r2,r18,r18
 320e830:	9cc7883a 	add	r3,r19,r19
 320e834:	a1800504 	addi	r6,r20,20
 320e838:	1085883a 	add	r2,r2,r2
 320e83c:	8b400504 	addi	r13,r17,20
 320e840:	18c7883a 	add	r3,r3,r3
 320e844:	309f883a 	add	r15,r6,r2
 320e848:	68d7883a 	add	r11,r13,r3
 320e84c:	33c03b2e 	bgeu	r6,r15,320e93c <__multiply+0x194>
 320e850:	2019883a 	mov	r12,r4
 320e854:	30800017 	ldw	r2,0(r6)
 320e858:	127fffcc 	andi	r9,r2,65535
 320e85c:	48001826 	beq	r9,zero,320e8c0 <__multiply+0x118>
 320e860:	6811883a 	mov	r8,r13
 320e864:	600f883a 	mov	r7,r12
 320e868:	0015883a 	mov	r10,zero
 320e86c:	40c00017 	ldw	r3,0(r8)
 320e870:	39400017 	ldw	r5,0(r7)
 320e874:	42000104 	addi	r8,r8,4
 320e878:	193fffcc 	andi	r4,r3,65535
 320e87c:	4909383a 	mul	r4,r9,r4
 320e880:	1806d43a 	srli	r3,r3,16
 320e884:	28bfffcc 	andi	r2,r5,65535
 320e888:	5085883a 	add	r2,r10,r2
 320e88c:	2089883a 	add	r4,r4,r2
 320e890:	48c7383a 	mul	r3,r9,r3
 320e894:	280ad43a 	srli	r5,r5,16
 320e898:	2004d43a 	srli	r2,r4,16
 320e89c:	3900000d 	sth	r4,0(r7)
 320e8a0:	1947883a 	add	r3,r3,r5
 320e8a4:	10c5883a 	add	r2,r2,r3
 320e8a8:	3880008d 	sth	r2,2(r7)
 320e8ac:	1014d43a 	srli	r10,r2,16
 320e8b0:	39c00104 	addi	r7,r7,4
 320e8b4:	42ffed36 	bltu	r8,r11,320e86c <__multiply+0xc4>
 320e8b8:	3a800015 	stw	r10,0(r7)
 320e8bc:	30800017 	ldw	r2,0(r6)
 320e8c0:	1012d43a 	srli	r9,r2,16
 320e8c4:	48001926 	beq	r9,zero,320e92c <__multiply+0x184>
 320e8c8:	60800017 	ldw	r2,0(r12)
 320e8cc:	6811883a 	mov	r8,r13
 320e8d0:	600f883a 	mov	r7,r12
 320e8d4:	0015883a 	mov	r10,zero
 320e8d8:	100b883a 	mov	r5,r2
 320e8dc:	41000017 	ldw	r4,0(r8)
 320e8e0:	2806d43a 	srli	r3,r5,16
 320e8e4:	3880000d 	sth	r2,0(r7)
 320e8e8:	20bfffcc 	andi	r2,r4,65535
 320e8ec:	4885383a 	mul	r2,r9,r2
 320e8f0:	50c7883a 	add	r3,r10,r3
 320e8f4:	2008d43a 	srli	r4,r4,16
 320e8f8:	10c5883a 	add	r2,r2,r3
 320e8fc:	3880008d 	sth	r2,2(r7)
 320e900:	39c00104 	addi	r7,r7,4
 320e904:	39400017 	ldw	r5,0(r7)
 320e908:	4909383a 	mul	r4,r9,r4
 320e90c:	1004d43a 	srli	r2,r2,16
 320e910:	28ffffcc 	andi	r3,r5,65535
 320e914:	20c9883a 	add	r4,r4,r3
 320e918:	1105883a 	add	r2,r2,r4
 320e91c:	42000104 	addi	r8,r8,4
 320e920:	1014d43a 	srli	r10,r2,16
 320e924:	42ffed36 	bltu	r8,r11,320e8dc <__multiply+0x134>
 320e928:	38800015 	stw	r2,0(r7)
 320e92c:	31800104 	addi	r6,r6,4
 320e930:	33c0022e 	bgeu	r6,r15,320e93c <__multiply+0x194>
 320e934:	63000104 	addi	r12,r12,4
 320e938:	003fc606 	br	320e854 <__multiply+0xac>
 320e93c:	0400090e 	bge	zero,r16,320e964 <__multiply+0x1bc>
 320e940:	70bfff17 	ldw	r2,-4(r14)
 320e944:	70ffff04 	addi	r3,r14,-4
 320e948:	10000326 	beq	r2,zero,320e958 <__multiply+0x1b0>
 320e94c:	00000506 	br	320e964 <__multiply+0x1bc>
 320e950:	18800017 	ldw	r2,0(r3)
 320e954:	1000031e 	bne	r2,zero,320e964 <__multiply+0x1bc>
 320e958:	843fffc4 	addi	r16,r16,-1
 320e95c:	18ffff04 	addi	r3,r3,-4
 320e960:	803ffb1e 	bne	r16,zero,320e950 <__multiply+0x1a8>
 320e964:	a805883a 	mov	r2,r21
 320e968:	ac000415 	stw	r16,16(r21)
 320e96c:	dfc00617 	ldw	ra,24(sp)
 320e970:	dd400517 	ldw	r21,20(sp)
 320e974:	dd000417 	ldw	r20,16(sp)
 320e978:	dcc00317 	ldw	r19,12(sp)
 320e97c:	dc800217 	ldw	r18,8(sp)
 320e980:	dc400117 	ldw	r17,4(sp)
 320e984:	dc000017 	ldw	r16,0(sp)
 320e988:	dec00704 	addi	sp,sp,28
 320e98c:	f800283a 	ret

0320e990 <__i2b>:
 320e990:	defffd04 	addi	sp,sp,-12
 320e994:	dc000015 	stw	r16,0(sp)
 320e998:	04000044 	movi	r16,1
 320e99c:	dc800115 	stw	r18,4(sp)
 320e9a0:	2825883a 	mov	r18,r5
 320e9a4:	800b883a 	mov	r5,r16
 320e9a8:	dfc00215 	stw	ra,8(sp)
 320e9ac:	320e2980 	call	320e298 <_Balloc>
 320e9b0:	14000415 	stw	r16,16(r2)
 320e9b4:	14800515 	stw	r18,20(r2)
 320e9b8:	dfc00217 	ldw	ra,8(sp)
 320e9bc:	dc800117 	ldw	r18,4(sp)
 320e9c0:	dc000017 	ldw	r16,0(sp)
 320e9c4:	dec00304 	addi	sp,sp,12
 320e9c8:	f800283a 	ret

0320e9cc <__multadd>:
 320e9cc:	defffa04 	addi	sp,sp,-24
 320e9d0:	dc800215 	stw	r18,8(sp)
 320e9d4:	2c800417 	ldw	r18,16(r5)
 320e9d8:	dd000415 	stw	r20,16(sp)
 320e9dc:	dcc00315 	stw	r19,12(sp)
 320e9e0:	dc000015 	stw	r16,0(sp)
 320e9e4:	dfc00515 	stw	ra,20(sp)
 320e9e8:	3821883a 	mov	r16,r7
 320e9ec:	dc400115 	stw	r17,4(sp)
 320e9f0:	2827883a 	mov	r19,r5
 320e9f4:	2029883a 	mov	r20,r4
 320e9f8:	2a000504 	addi	r8,r5,20
 320e9fc:	000f883a 	mov	r7,zero
 320ea00:	40800017 	ldw	r2,0(r8)
 320ea04:	39c00044 	addi	r7,r7,1
 320ea08:	10ffffcc 	andi	r3,r2,65535
 320ea0c:	1987383a 	mul	r3,r3,r6
 320ea10:	1004d43a 	srli	r2,r2,16
 320ea14:	1c07883a 	add	r3,r3,r16
 320ea18:	180ad43a 	srli	r5,r3,16
 320ea1c:	1185383a 	mul	r2,r2,r6
 320ea20:	18ffffcc 	andi	r3,r3,65535
 320ea24:	1145883a 	add	r2,r2,r5
 320ea28:	1008943a 	slli	r4,r2,16
 320ea2c:	1020d43a 	srli	r16,r2,16
 320ea30:	20c9883a 	add	r4,r4,r3
 320ea34:	41000015 	stw	r4,0(r8)
 320ea38:	42000104 	addi	r8,r8,4
 320ea3c:	3cbff016 	blt	r7,r18,320ea00 <__multadd+0x34>
 320ea40:	80000826 	beq	r16,zero,320ea64 <__multadd+0x98>
 320ea44:	98800217 	ldw	r2,8(r19)
 320ea48:	90800f0e 	bge	r18,r2,320ea88 <__multadd+0xbc>
 320ea4c:	9485883a 	add	r2,r18,r18
 320ea50:	1085883a 	add	r2,r2,r2
 320ea54:	14c5883a 	add	r2,r2,r19
 320ea58:	90c00044 	addi	r3,r18,1
 320ea5c:	14000515 	stw	r16,20(r2)
 320ea60:	98c00415 	stw	r3,16(r19)
 320ea64:	9805883a 	mov	r2,r19
 320ea68:	dfc00517 	ldw	ra,20(sp)
 320ea6c:	dd000417 	ldw	r20,16(sp)
 320ea70:	dcc00317 	ldw	r19,12(sp)
 320ea74:	dc800217 	ldw	r18,8(sp)
 320ea78:	dc400117 	ldw	r17,4(sp)
 320ea7c:	dc000017 	ldw	r16,0(sp)
 320ea80:	dec00604 	addi	sp,sp,24
 320ea84:	f800283a 	ret
 320ea88:	99400117 	ldw	r5,4(r19)
 320ea8c:	a009883a 	mov	r4,r20
 320ea90:	29400044 	addi	r5,r5,1
 320ea94:	320e2980 	call	320e298 <_Balloc>
 320ea98:	99800417 	ldw	r6,16(r19)
 320ea9c:	99400304 	addi	r5,r19,12
 320eaa0:	11000304 	addi	r4,r2,12
 320eaa4:	318d883a 	add	r6,r6,r6
 320eaa8:	318d883a 	add	r6,r6,r6
 320eaac:	31800204 	addi	r6,r6,8
 320eab0:	1023883a 	mov	r17,r2
 320eab4:	3206ad00 	call	3206ad0 <memcpy>
 320eab8:	980b883a 	mov	r5,r19
 320eabc:	a009883a 	mov	r4,r20
 320eac0:	320dd180 	call	320dd18 <_Bfree>
 320eac4:	8827883a 	mov	r19,r17
 320eac8:	003fe006 	br	320ea4c <__multadd+0x80>

0320eacc <__pow5mult>:
 320eacc:	defffa04 	addi	sp,sp,-24
 320ead0:	308000cc 	andi	r2,r6,3
 320ead4:	dd000415 	stw	r20,16(sp)
 320ead8:	dcc00315 	stw	r19,12(sp)
 320eadc:	dc000015 	stw	r16,0(sp)
 320eae0:	dfc00515 	stw	ra,20(sp)
 320eae4:	dc800215 	stw	r18,8(sp)
 320eae8:	dc400115 	stw	r17,4(sp)
 320eaec:	3021883a 	mov	r16,r6
 320eaf0:	2027883a 	mov	r19,r4
 320eaf4:	2829883a 	mov	r20,r5
 320eaf8:	10002b1e 	bne	r2,zero,320eba8 <__pow5mult+0xdc>
 320eafc:	8025d0ba 	srai	r18,r16,2
 320eb00:	90001b26 	beq	r18,zero,320eb70 <__pow5mult+0xa4>
 320eb04:	9c001217 	ldw	r16,72(r19)
 320eb08:	8000081e 	bne	r16,zero,320eb2c <__pow5mult+0x60>
 320eb0c:	00003006 	br	320ebd0 <__pow5mult+0x104>
 320eb10:	800b883a 	mov	r5,r16
 320eb14:	800d883a 	mov	r6,r16
 320eb18:	9809883a 	mov	r4,r19
 320eb1c:	90001426 	beq	r18,zero,320eb70 <__pow5mult+0xa4>
 320eb20:	80800017 	ldw	r2,0(r16)
 320eb24:	10001b26 	beq	r2,zero,320eb94 <__pow5mult+0xc8>
 320eb28:	1021883a 	mov	r16,r2
 320eb2c:	9080004c 	andi	r2,r18,1
 320eb30:	1005003a 	cmpeq	r2,r2,zero
 320eb34:	9025d07a 	srai	r18,r18,1
 320eb38:	800d883a 	mov	r6,r16
 320eb3c:	9809883a 	mov	r4,r19
 320eb40:	a00b883a 	mov	r5,r20
 320eb44:	103ff21e 	bne	r2,zero,320eb10 <__pow5mult+0x44>
 320eb48:	320e7a80 	call	320e7a8 <__multiply>
 320eb4c:	a00b883a 	mov	r5,r20
 320eb50:	9809883a 	mov	r4,r19
 320eb54:	1023883a 	mov	r17,r2
 320eb58:	320dd180 	call	320dd18 <_Bfree>
 320eb5c:	8829883a 	mov	r20,r17
 320eb60:	800b883a 	mov	r5,r16
 320eb64:	800d883a 	mov	r6,r16
 320eb68:	9809883a 	mov	r4,r19
 320eb6c:	903fec1e 	bne	r18,zero,320eb20 <__pow5mult+0x54>
 320eb70:	a005883a 	mov	r2,r20
 320eb74:	dfc00517 	ldw	ra,20(sp)
 320eb78:	dd000417 	ldw	r20,16(sp)
 320eb7c:	dcc00317 	ldw	r19,12(sp)
 320eb80:	dc800217 	ldw	r18,8(sp)
 320eb84:	dc400117 	ldw	r17,4(sp)
 320eb88:	dc000017 	ldw	r16,0(sp)
 320eb8c:	dec00604 	addi	sp,sp,24
 320eb90:	f800283a 	ret
 320eb94:	320e7a80 	call	320e7a8 <__multiply>
 320eb98:	80800015 	stw	r2,0(r16)
 320eb9c:	1021883a 	mov	r16,r2
 320eba0:	10000015 	stw	zero,0(r2)
 320eba4:	003fe106 	br	320eb2c <__pow5mult+0x60>
 320eba8:	1085883a 	add	r2,r2,r2
 320ebac:	00c0c974 	movhi	r3,805
 320ebb0:	18f91904 	addi	r3,r3,-7068
 320ebb4:	1085883a 	add	r2,r2,r2
 320ebb8:	10c5883a 	add	r2,r2,r3
 320ebbc:	11bfff17 	ldw	r6,-4(r2)
 320ebc0:	000f883a 	mov	r7,zero
 320ebc4:	320e9cc0 	call	320e9cc <__multadd>
 320ebc8:	1029883a 	mov	r20,r2
 320ebcc:	003fcb06 	br	320eafc <__pow5mult+0x30>
 320ebd0:	9809883a 	mov	r4,r19
 320ebd4:	01409c44 	movi	r5,625
 320ebd8:	320e9900 	call	320e990 <__i2b>
 320ebdc:	98801215 	stw	r2,72(r19)
 320ebe0:	1021883a 	mov	r16,r2
 320ebe4:	10000015 	stw	zero,0(r2)
 320ebe8:	003fd006 	br	320eb2c <__pow5mult+0x60>

0320ebec <__s2b>:
 320ebec:	defff904 	addi	sp,sp,-28
 320ebf0:	dcc00315 	stw	r19,12(sp)
 320ebf4:	dc800215 	stw	r18,8(sp)
 320ebf8:	2827883a 	mov	r19,r5
 320ebfc:	2025883a 	mov	r18,r4
 320ec00:	01400244 	movi	r5,9
 320ec04:	39000204 	addi	r4,r7,8
 320ec08:	dd000415 	stw	r20,16(sp)
 320ec0c:	dc400115 	stw	r17,4(sp)
 320ec10:	dfc00615 	stw	ra,24(sp)
 320ec14:	dd400515 	stw	r21,20(sp)
 320ec18:	dc000015 	stw	r16,0(sp)
 320ec1c:	3829883a 	mov	r20,r7
 320ec20:	3023883a 	mov	r17,r6
 320ec24:	32047000 	call	3204700 <__divsi3>
 320ec28:	00c00044 	movi	r3,1
 320ec2c:	1880350e 	bge	r3,r2,320ed04 <__s2b+0x118>
 320ec30:	000b883a 	mov	r5,zero
 320ec34:	18c7883a 	add	r3,r3,r3
 320ec38:	29400044 	addi	r5,r5,1
 320ec3c:	18bffd16 	blt	r3,r2,320ec34 <__s2b+0x48>
 320ec40:	9009883a 	mov	r4,r18
 320ec44:	320e2980 	call	320e298 <_Balloc>
 320ec48:	1011883a 	mov	r8,r2
 320ec4c:	d8800717 	ldw	r2,28(sp)
 320ec50:	00c00044 	movi	r3,1
 320ec54:	01800244 	movi	r6,9
 320ec58:	40800515 	stw	r2,20(r8)
 320ec5c:	40c00415 	stw	r3,16(r8)
 320ec60:	3440260e 	bge	r6,r17,320ecfc <__s2b+0x110>
 320ec64:	3021883a 	mov	r16,r6
 320ec68:	99ab883a 	add	r21,r19,r6
 320ec6c:	9c05883a 	add	r2,r19,r16
 320ec70:	11c00007 	ldb	r7,0(r2)
 320ec74:	400b883a 	mov	r5,r8
 320ec78:	9009883a 	mov	r4,r18
 320ec7c:	39fff404 	addi	r7,r7,-48
 320ec80:	01800284 	movi	r6,10
 320ec84:	320e9cc0 	call	320e9cc <__multadd>
 320ec88:	84000044 	addi	r16,r16,1
 320ec8c:	1011883a 	mov	r8,r2
 320ec90:	8c3ff61e 	bne	r17,r16,320ec6c <__s2b+0x80>
 320ec94:	ac45883a 	add	r2,r21,r17
 320ec98:	117ffe04 	addi	r5,r2,-8
 320ec9c:	880d883a 	mov	r6,r17
 320eca0:	35000c0e 	bge	r6,r20,320ecd4 <__s2b+0xe8>
 320eca4:	a185c83a 	sub	r2,r20,r6
 320eca8:	2821883a 	mov	r16,r5
 320ecac:	28a3883a 	add	r17,r5,r2
 320ecb0:	81c00007 	ldb	r7,0(r16)
 320ecb4:	400b883a 	mov	r5,r8
 320ecb8:	9009883a 	mov	r4,r18
 320ecbc:	39fff404 	addi	r7,r7,-48
 320ecc0:	01800284 	movi	r6,10
 320ecc4:	320e9cc0 	call	320e9cc <__multadd>
 320ecc8:	84000044 	addi	r16,r16,1
 320eccc:	1011883a 	mov	r8,r2
 320ecd0:	847ff71e 	bne	r16,r17,320ecb0 <__s2b+0xc4>
 320ecd4:	4005883a 	mov	r2,r8
 320ecd8:	dfc00617 	ldw	ra,24(sp)
 320ecdc:	dd400517 	ldw	r21,20(sp)
 320ece0:	dd000417 	ldw	r20,16(sp)
 320ece4:	dcc00317 	ldw	r19,12(sp)
 320ece8:	dc800217 	ldw	r18,8(sp)
 320ecec:	dc400117 	ldw	r17,4(sp)
 320ecf0:	dc000017 	ldw	r16,0(sp)
 320ecf4:	dec00704 	addi	sp,sp,28
 320ecf8:	f800283a 	ret
 320ecfc:	99400284 	addi	r5,r19,10
 320ed00:	003fe706 	br	320eca0 <__s2b+0xb4>
 320ed04:	000b883a 	mov	r5,zero
 320ed08:	003fcd06 	br	320ec40 <__s2b+0x54>

0320ed0c <_read_r>:
 320ed0c:	defffd04 	addi	sp,sp,-12
 320ed10:	dc000015 	stw	r16,0(sp)
 320ed14:	0400c974 	movhi	r16,805
 320ed18:	8412f804 	addi	r16,r16,19424
 320ed1c:	dc400115 	stw	r17,4(sp)
 320ed20:	80000015 	stw	zero,0(r16)
 320ed24:	2023883a 	mov	r17,r4
 320ed28:	2809883a 	mov	r4,r5
 320ed2c:	300b883a 	mov	r5,r6
 320ed30:	380d883a 	mov	r6,r7
 320ed34:	dfc00215 	stw	ra,8(sp)
 320ed38:	3222cd80 	call	3222cd8 <read>
 320ed3c:	1007883a 	mov	r3,r2
 320ed40:	00bfffc4 	movi	r2,-1
 320ed44:	18800626 	beq	r3,r2,320ed60 <_read_r+0x54>
 320ed48:	1805883a 	mov	r2,r3
 320ed4c:	dfc00217 	ldw	ra,8(sp)
 320ed50:	dc400117 	ldw	r17,4(sp)
 320ed54:	dc000017 	ldw	r16,0(sp)
 320ed58:	dec00304 	addi	sp,sp,12
 320ed5c:	f800283a 	ret
 320ed60:	80800017 	ldw	r2,0(r16)
 320ed64:	103ff826 	beq	r2,zero,320ed48 <_read_r+0x3c>
 320ed68:	88800015 	stw	r2,0(r17)
 320ed6c:	1805883a 	mov	r2,r3
 320ed70:	dfc00217 	ldw	ra,8(sp)
 320ed74:	dc400117 	ldw	r17,4(sp)
 320ed78:	dc000017 	ldw	r16,0(sp)
 320ed7c:	dec00304 	addi	sp,sp,12
 320ed80:	f800283a 	ret

0320ed84 <__isinfd>:
 320ed84:	200d883a 	mov	r6,r4
 320ed88:	0109c83a 	sub	r4,zero,r4
 320ed8c:	2188b03a 	or	r4,r4,r6
 320ed90:	2008d7fa 	srli	r4,r4,31
 320ed94:	00a00034 	movhi	r2,32768
 320ed98:	10bfffc4 	addi	r2,r2,-1
 320ed9c:	1144703a 	and	r2,r2,r5
 320eda0:	2088b03a 	or	r4,r4,r2
 320eda4:	009ffc34 	movhi	r2,32752
 320eda8:	1105c83a 	sub	r2,r2,r4
 320edac:	0087c83a 	sub	r3,zero,r2
 320edb0:	10c4b03a 	or	r2,r2,r3
 320edb4:	1004d7fa 	srli	r2,r2,31
 320edb8:	00c00044 	movi	r3,1
 320edbc:	1885c83a 	sub	r2,r3,r2
 320edc0:	f800283a 	ret

0320edc4 <__isnand>:
 320edc4:	200d883a 	mov	r6,r4
 320edc8:	0109c83a 	sub	r4,zero,r4
 320edcc:	2188b03a 	or	r4,r4,r6
 320edd0:	2008d7fa 	srli	r4,r4,31
 320edd4:	00a00034 	movhi	r2,32768
 320edd8:	10bfffc4 	addi	r2,r2,-1
 320eddc:	1144703a 	and	r2,r2,r5
 320ede0:	2088b03a 	or	r4,r4,r2
 320ede4:	009ffc34 	movhi	r2,32752
 320ede8:	1105c83a 	sub	r2,r2,r4
 320edec:	1004d7fa 	srli	r2,r2,31
 320edf0:	f800283a 	ret

0320edf4 <__sccl>:
 320edf4:	28c00003 	ldbu	r3,0(r5)
 320edf8:	00801784 	movi	r2,94
 320edfc:	2a000044 	addi	r8,r5,1
 320ee00:	18802526 	beq	r3,r2,320ee98 <__sccl+0xa4>
 320ee04:	180f883a 	mov	r7,r3
 320ee08:	0013883a 	mov	r9,zero
 320ee0c:	000d883a 	mov	r6,zero
 320ee10:	0007883a 	mov	r3,zero
 320ee14:	01404004 	movi	r5,256
 320ee18:	1905883a 	add	r2,r3,r4
 320ee1c:	18c00044 	addi	r3,r3,1
 320ee20:	11800005 	stb	r6,0(r2)
 320ee24:	197ffc1e 	bne	r3,r5,320ee18 <__sccl+0x24>
 320ee28:	38000c26 	beq	r7,zero,320ee5c <__sccl+0x68>
 320ee2c:	00800044 	movi	r2,1
 320ee30:	124dc83a 	sub	r6,r2,r9
 320ee34:	3905883a 	add	r2,r7,r4
 320ee38:	11800005 	stb	r6,0(r2)
 320ee3c:	41400044 	addi	r5,r8,1
 320ee40:	02400b44 	movi	r9,45
 320ee44:	02801744 	movi	r10,93
 320ee48:	28bfffc3 	ldbu	r2,-1(r5)
 320ee4c:	2811883a 	mov	r8,r5
 320ee50:	12400726 	beq	r2,r9,320ee70 <__sccl+0x7c>
 320ee54:	12800226 	beq	r2,r10,320ee60 <__sccl+0x6c>
 320ee58:	1000031e 	bne	r2,zero,320ee68 <__sccl+0x74>
 320ee5c:	423fffc4 	addi	r8,r8,-1
 320ee60:	4005883a 	mov	r2,r8
 320ee64:	f800283a 	ret
 320ee68:	100f883a 	mov	r7,r2
 320ee6c:	003ff106 	br	320ee34 <__sccl+0x40>
 320ee70:	28c00003 	ldbu	r3,0(r5)
 320ee74:	1a800d26 	beq	r3,r10,320eeac <__sccl+0xb8>
 320ee78:	19c00c16 	blt	r3,r7,320eeac <__sccl+0xb8>
 320ee7c:	21c5883a 	add	r2,r4,r7
 320ee80:	39c00044 	addi	r7,r7,1
 320ee84:	11800045 	stb	r6,1(r2)
 320ee88:	10800044 	addi	r2,r2,1
 320ee8c:	38fffc16 	blt	r7,r3,320ee80 <__sccl+0x8c>
 320ee90:	29400084 	addi	r5,r5,2
 320ee94:	003fec06 	br	320ee48 <__sccl+0x54>
 320ee98:	29c00043 	ldbu	r7,1(r5)
 320ee9c:	02400044 	movi	r9,1
 320eea0:	2a000084 	addi	r8,r5,2
 320eea4:	480d883a 	mov	r6,r9
 320eea8:	003fd906 	br	320ee10 <__sccl+0x1c>
 320eeac:	01c00b44 	movi	r7,45
 320eeb0:	003fe006 	br	320ee34 <__sccl+0x40>

0320eeb4 <nanf>:
 320eeb4:	009ff034 	movhi	r2,32704
 320eeb8:	f800283a 	ret

0320eebc <strcmp>:
 320eebc:	2144b03a 	or	r2,r4,r5
 320eec0:	108000cc 	andi	r2,r2,3
 320eec4:	10001d1e 	bne	r2,zero,320ef3c <strcmp+0x80>
 320eec8:	200f883a 	mov	r7,r4
 320eecc:	28800017 	ldw	r2,0(r5)
 320eed0:	21000017 	ldw	r4,0(r4)
 320eed4:	280d883a 	mov	r6,r5
 320eed8:	2080161e 	bne	r4,r2,320ef34 <strcmp+0x78>
 320eedc:	023fbff4 	movhi	r8,65279
 320eee0:	423fbfc4 	addi	r8,r8,-257
 320eee4:	2207883a 	add	r3,r4,r8
 320eee8:	01602074 	movhi	r5,32897
 320eeec:	29602004 	addi	r5,r5,-32640
 320eef0:	1946703a 	and	r3,r3,r5
 320eef4:	0104303a 	nor	r2,zero,r4
 320eef8:	10c4703a 	and	r2,r2,r3
 320eefc:	10001c1e 	bne	r2,zero,320ef70 <strcmp+0xb4>
 320ef00:	4013883a 	mov	r9,r8
 320ef04:	2811883a 	mov	r8,r5
 320ef08:	00000106 	br	320ef10 <strcmp+0x54>
 320ef0c:	1800181e 	bne	r3,zero,320ef70 <strcmp+0xb4>
 320ef10:	39c00104 	addi	r7,r7,4
 320ef14:	39000017 	ldw	r4,0(r7)
 320ef18:	31800104 	addi	r6,r6,4
 320ef1c:	31400017 	ldw	r5,0(r6)
 320ef20:	2245883a 	add	r2,r4,r9
 320ef24:	1204703a 	and	r2,r2,r8
 320ef28:	0106303a 	nor	r3,zero,r4
 320ef2c:	1886703a 	and	r3,r3,r2
 320ef30:	217ff626 	beq	r4,r5,320ef0c <strcmp+0x50>
 320ef34:	3809883a 	mov	r4,r7
 320ef38:	300b883a 	mov	r5,r6
 320ef3c:	20c00007 	ldb	r3,0(r4)
 320ef40:	1800051e 	bne	r3,zero,320ef58 <strcmp+0x9c>
 320ef44:	00000606 	br	320ef60 <strcmp+0xa4>
 320ef48:	21000044 	addi	r4,r4,1
 320ef4c:	20c00007 	ldb	r3,0(r4)
 320ef50:	29400044 	addi	r5,r5,1
 320ef54:	18000226 	beq	r3,zero,320ef60 <strcmp+0xa4>
 320ef58:	28800007 	ldb	r2,0(r5)
 320ef5c:	18bffa26 	beq	r3,r2,320ef48 <strcmp+0x8c>
 320ef60:	20c00003 	ldbu	r3,0(r4)
 320ef64:	28800003 	ldbu	r2,0(r5)
 320ef68:	1885c83a 	sub	r2,r3,r2
 320ef6c:	f800283a 	ret
 320ef70:	0005883a 	mov	r2,zero
 320ef74:	f800283a 	ret

0320ef78 <match>:
 320ef78:	21800017 	ldw	r6,0(r4)
 320ef7c:	01c01004 	movi	r7,64
 320ef80:	02001684 	movi	r8,90
 320ef84:	28800007 	ldb	r2,0(r5)
 320ef88:	29400044 	addi	r5,r5,1
 320ef8c:	10000826 	beq	r2,zero,320efb0 <match+0x38>
 320ef90:	31800044 	addi	r6,r6,1
 320ef94:	30c00007 	ldb	r3,0(r6)
 320ef98:	38c0020e 	bge	r7,r3,320efa4 <match+0x2c>
 320ef9c:	40c00116 	blt	r8,r3,320efa4 <match+0x2c>
 320efa0:	18c00804 	addi	r3,r3,32
 320efa4:	18bff726 	beq	r3,r2,320ef84 <match+0xc>
 320efa8:	0005883a 	mov	r2,zero
 320efac:	f800283a 	ret
 320efb0:	30800044 	addi	r2,r6,1
 320efb4:	20800015 	stw	r2,0(r4)
 320efb8:	00800044 	movi	r2,1
 320efbc:	f800283a 	ret

0320efc0 <_strtod_r>:
 320efc0:	deffde04 	addi	sp,sp,-136
 320efc4:	df002015 	stw	fp,128(sp)
 320efc8:	dd401d15 	stw	r21,116(sp)
 320efcc:	dc401915 	stw	r17,100(sp)
 320efd0:	dfc02115 	stw	ra,132(sp)
 320efd4:	ddc01f15 	stw	r23,124(sp)
 320efd8:	dd801e15 	stw	r22,120(sp)
 320efdc:	dd001c15 	stw	r20,112(sp)
 320efe0:	dcc01b15 	stw	r19,108(sp)
 320efe4:	dc801a15 	stw	r18,104(sp)
 320efe8:	dc001815 	stw	r16,96(sp)
 320efec:	2823883a 	mov	r17,r5
 320eff0:	202b883a 	mov	r21,r4
 320eff4:	d9801515 	stw	r6,84(sp)
 320eff8:	d8000915 	stw	zero,36(sp)
 320effc:	d8000a15 	stw	zero,40(sp)
 320f000:	d9400415 	stw	r5,16(sp)
 320f004:	df000904 	addi	fp,sp,36
 320f008:	da000417 	ldw	r8,16(sp)
 320f00c:	00800b44 	movi	r2,45
 320f010:	40c00003 	ldbu	r3,0(r8)
 320f014:	10c03536 	bltu	r2,r3,320f0ec <_strtod_r+0x12c>
 320f018:	18c5883a 	add	r2,r3,r3
 320f01c:	1085883a 	add	r2,r2,r2
 320f020:	00c0c874 	movhi	r3,801
 320f024:	18fc0d04 	addi	r3,r3,-4044
 320f028:	10c5883a 	add	r2,r2,r3
 320f02c:	11000017 	ldw	r4,0(r2)
 320f030:	2000683a 	jmp	r4
 320f034:	0320f228 	cmpgeui	r12,zero,33736
 320f038:	0320f0ec 	andhi	r12,zero,33731
 320f03c:	0320f0ec 	andhi	r12,zero,33731
 320f040:	0320f0ec 	andhi	r12,zero,33731
 320f044:	0320f0ec 	andhi	r12,zero,33731
 320f048:	0320f0ec 	andhi	r12,zero,33731
 320f04c:	0320f0ec 	andhi	r12,zero,33731
 320f050:	0320f0ec 	andhi	r12,zero,33731
 320f054:	0320f0ec 	andhi	r12,zero,33731
 320f058:	0320f540 	call	320f54 <OSCtxSw_SWITCH_PC+0x320f14>
 320f05c:	0320f540 	call	320f54 <OSCtxSw_SWITCH_PC+0x320f14>
 320f060:	0320f540 	call	320f54 <OSCtxSw_SWITCH_PC+0x320f14>
 320f064:	0320f540 	call	320f54 <OSCtxSw_SWITCH_PC+0x320f14>
 320f068:	0320f540 	call	320f54 <OSCtxSw_SWITCH_PC+0x320f14>
 320f06c:	0320f0ec 	andhi	r12,zero,33731
 320f070:	0320f0ec 	andhi	r12,zero,33731
 320f074:	0320f0ec 	andhi	r12,zero,33731
 320f078:	0320f0ec 	andhi	r12,zero,33731
 320f07c:	0320f0ec 	andhi	r12,zero,33731
 320f080:	0320f0ec 	andhi	r12,zero,33731
 320f084:	0320f0ec 	andhi	r12,zero,33731
 320f088:	0320f0ec 	andhi	r12,zero,33731
 320f08c:	0320f0ec 	andhi	r12,zero,33731
 320f090:	0320f0ec 	andhi	r12,zero,33731
 320f094:	0320f0ec 	andhi	r12,zero,33731
 320f098:	0320f0ec 	andhi	r12,zero,33731
 320f09c:	0320f0ec 	andhi	r12,zero,33731
 320f0a0:	0320f0ec 	andhi	r12,zero,33731
 320f0a4:	0320f0ec 	andhi	r12,zero,33731
 320f0a8:	0320f0ec 	andhi	r12,zero,33731
 320f0ac:	0320f0ec 	andhi	r12,zero,33731
 320f0b0:	0320f0ec 	andhi	r12,zero,33731
 320f0b4:	0320f540 	call	320f54 <OSCtxSw_SWITCH_PC+0x320f14>
 320f0b8:	0320f0ec 	andhi	r12,zero,33731
 320f0bc:	0320f0ec 	andhi	r12,zero,33731
 320f0c0:	0320f0ec 	andhi	r12,zero,33731
 320f0c4:	0320f0ec 	andhi	r12,zero,33731
 320f0c8:	0320f0ec 	andhi	r12,zero,33731
 320f0cc:	0320f0ec 	andhi	r12,zero,33731
 320f0d0:	0320f0ec 	andhi	r12,zero,33731
 320f0d4:	0320f0ec 	andhi	r12,zero,33731
 320f0d8:	0320f0ec 	andhi	r12,zero,33731
 320f0dc:	0320f0ec 	andhi	r12,zero,33731
 320f0e0:	0320f520 	cmpeqi	r12,zero,-31788
 320f0e4:	0320f0ec 	andhi	r12,zero,33731
 320f0e8:	0320f54c 	andi	r12,zero,33749
 320f0ec:	d8001115 	stw	zero,68(sp)
 320f0f0:	40c00007 	ldb	r3,0(r8)
 320f0f4:	00800c04 	movi	r2,48
 320f0f8:	1880d026 	beq	r3,r2,320f43c <_strtod_r+0x47c>
 320f0fc:	001f883a 	mov	r15,zero
 320f100:	41000007 	ldb	r4,0(r8)
 320f104:	00c00bc4 	movi	r3,47
 320f108:	402d883a 	mov	r22,r8
 320f10c:	1903470e 	bge	r3,r4,320fe2c <_strtod_r+0xe6c>
 320f110:	00800e44 	movi	r2,57
 320f114:	11034516 	blt	r2,r4,320fe2c <_strtod_r+0xe6c>
 320f118:	180f883a 	mov	r7,r3
 320f11c:	1013883a 	mov	r9,r2
 320f120:	4007883a 	mov	r3,r8
 320f124:	000d883a 	mov	r6,zero
 320f128:	0029883a 	mov	r20,zero
 320f12c:	0021883a 	mov	r16,zero
 320f130:	01400204 	movi	r5,8
 320f134:	028003c4 	movi	r10,15
 320f138:	29803116 	blt	r5,r6,320f200 <_strtod_r+0x240>
 320f13c:	a08002a4 	muli	r2,r20,10
 320f140:	1105883a 	add	r2,r2,r4
 320f144:	153ff404 	addi	r20,r2,-48
 320f148:	1a000044 	addi	r8,r3,1
 320f14c:	da000415 	stw	r8,16(sp)
 320f150:	41000007 	ldb	r4,0(r8)
 320f154:	31800044 	addi	r6,r6,1
 320f158:	4007883a 	mov	r3,r8
 320f15c:	3900010e 	bge	r7,r4,320f164 <_strtod_r+0x1a4>
 320f160:	493ff50e 	bge	r9,r4,320f138 <_strtod_r+0x178>
 320f164:	00800b84 	movi	r2,46
 320f168:	2080c126 	beq	r4,r2,320f470 <_strtod_r+0x4b0>
 320f16c:	3027883a 	mov	r19,r6
 320f170:	0025883a 	mov	r18,zero
 320f174:	0015883a 	mov	r10,zero
 320f178:	000f883a 	mov	r7,zero
 320f17c:	00801944 	movi	r2,101
 320f180:	20802426 	beq	r4,r2,320f214 <_strtod_r+0x254>
 320f184:	00801144 	movi	r2,69
 320f188:	20802226 	beq	r4,r2,320f214 <_strtod_r+0x254>
 320f18c:	9816c03a 	cmpne	r11,r19,zero
 320f190:	000b883a 	mov	r5,zero
 320f194:	5800631e 	bne	r11,zero,320f324 <_strtod_r+0x364>
 320f198:	3800c126 	beq	r7,zero,320f4a0 <_strtod_r+0x4e0>
 320f19c:	d8c01517 	ldw	r3,84(sp)
 320f1a0:	18000226 	beq	r3,zero,320f1ac <_strtod_r+0x1ec>
 320f1a4:	d8800417 	ldw	r2,16(sp)
 320f1a8:	18800015 	stw	r2,0(r3)
 320f1ac:	d9001117 	ldw	r4,68(sp)
 320f1b0:	2005003a 	cmpeq	r2,r4,zero
 320f1b4:	10001f1e 	bne	r2,zero,320f234 <_strtod_r+0x274>
 320f1b8:	e0800017 	ldw	r2,0(fp)
 320f1bc:	e0c00117 	ldw	r3,4(fp)
 320f1c0:	1009883a 	mov	r4,r2
 320f1c4:	1960003c 	xorhi	r5,r3,32768
 320f1c8:	2005883a 	mov	r2,r4
 320f1cc:	2807883a 	mov	r3,r5
 320f1d0:	dfc02117 	ldw	ra,132(sp)
 320f1d4:	df002017 	ldw	fp,128(sp)
 320f1d8:	ddc01f17 	ldw	r23,124(sp)
 320f1dc:	dd801e17 	ldw	r22,120(sp)
 320f1e0:	dd401d17 	ldw	r21,116(sp)
 320f1e4:	dd001c17 	ldw	r20,112(sp)
 320f1e8:	dcc01b17 	ldw	r19,108(sp)
 320f1ec:	dc801a17 	ldw	r18,104(sp)
 320f1f0:	dc401917 	ldw	r17,100(sp)
 320f1f4:	dc001817 	ldw	r16,96(sp)
 320f1f8:	dec02204 	addi	sp,sp,136
 320f1fc:	f800283a 	ret
 320f200:	51bfd116 	blt	r10,r6,320f148 <_strtod_r+0x188>
 320f204:	808002a4 	muli	r2,r16,10
 320f208:	1105883a 	add	r2,r2,r4
 320f20c:	143ff404 	addi	r16,r2,-48
 320f210:	003fcd06 	br	320f148 <_strtod_r+0x188>
 320f214:	9816c03a 	cmpne	r11,r19,zero
 320f218:	5800091e 	bne	r11,zero,320f240 <_strtod_r+0x280>
 320f21c:	3800081e 	bne	r7,zero,320f240 <_strtod_r+0x280>
 320f220:	7805003a 	cmpeq	r2,r15,zero
 320f224:	10000626 	beq	r2,zero,320f240 <_strtod_r+0x280>
 320f228:	d8001115 	stw	zero,68(sp)
 320f22c:	dc400415 	stw	r17,16(sp)
 320f230:	003fda06 	br	320f19c <_strtod_r+0x1dc>
 320f234:	e1000017 	ldw	r4,0(fp)
 320f238:	e1400117 	ldw	r5,4(fp)
 320f23c:	003fe206 	br	320f1c8 <_strtod_r+0x208>
 320f240:	dc400417 	ldw	r17,16(sp)
 320f244:	00800ac4 	movi	r2,43
 320f248:	8a000044 	addi	r8,r17,1
 320f24c:	da000415 	stw	r8,16(sp)
 320f250:	88c00047 	ldb	r3,1(r17)
 320f254:	4009883a 	mov	r4,r8
 320f258:	1880bf26 	beq	r3,r2,320f558 <_strtod_r+0x598>
 320f25c:	00800b44 	movi	r2,45
 320f260:	18834526 	beq	r3,r2,320ff78 <_strtod_r+0xfb8>
 320f264:	1809883a 	mov	r4,r3
 320f268:	20fff404 	addi	r3,r4,-48
 320f26c:	00800244 	movi	r2,9
 320f270:	001d883a 	mov	r14,zero
 320f274:	10c0bf36 	bltu	r2,r3,320f574 <_strtod_r+0x5b4>
 320f278:	00800c04 	movi	r2,48
 320f27c:	2080061e 	bne	r4,r2,320f298 <_strtod_r+0x2d8>
 320f280:	da000417 	ldw	r8,16(sp)
 320f284:	2005883a 	mov	r2,r4
 320f288:	42000044 	addi	r8,r8,1
 320f28c:	da000415 	stw	r8,16(sp)
 320f290:	41000007 	ldb	r4,0(r8)
 320f294:	20bffc26 	beq	r4,r2,320f288 <_strtod_r+0x2c8>
 320f298:	20fff3c4 	addi	r3,r4,-49
 320f29c:	00800204 	movi	r2,8
 320f2a0:	10ffbb36 	bltu	r2,r3,320f190 <_strtod_r+0x1d0>
 320f2a4:	da000417 	ldw	r8,16(sp)
 320f2a8:	227ff404 	addi	r9,r4,-48
 320f2ac:	03000bc4 	movi	r12,47
 320f2b0:	4007883a 	mov	r3,r8
 320f2b4:	42000044 	addi	r8,r8,1
 320f2b8:	da000415 	stw	r8,16(sp)
 320f2bc:	41000007 	ldb	r4,0(r8)
 320f2c0:	61000d0e 	bge	r12,r4,320f2f8 <_strtod_r+0x338>
 320f2c4:	00800e44 	movi	r2,57
 320f2c8:	11000b16 	blt	r2,r4,320f2f8 <_strtod_r+0x338>
 320f2cc:	601b883a 	mov	r13,r12
 320f2d0:	1019883a 	mov	r12,r2
 320f2d4:	00000106 	br	320f2dc <_strtod_r+0x31c>
 320f2d8:	61000716 	blt	r12,r4,320f2f8 <_strtod_r+0x338>
 320f2dc:	488002a4 	muli	r2,r9,10
 320f2e0:	42000044 	addi	r8,r8,1
 320f2e4:	da000415 	stw	r8,16(sp)
 320f2e8:	2085883a 	add	r2,r4,r2
 320f2ec:	41000007 	ldb	r4,0(r8)
 320f2f0:	127ff404 	addi	r9,r2,-48
 320f2f4:	693ff816 	blt	r13,r4,320f2d8 <_strtod_r+0x318>
 320f2f8:	40c7c83a 	sub	r3,r8,r3
 320f2fc:	00800204 	movi	r2,8
 320f300:	10c2e416 	blt	r2,r3,320fe94 <_strtod_r+0xed4>
 320f304:	009387c4 	movi	r2,19999
 320f308:	480b883a 	mov	r5,r9
 320f30c:	1240010e 	bge	r2,r9,320f314 <_strtod_r+0x354>
 320f310:	100b883a 	mov	r5,r2
 320f314:	7005003a 	cmpeq	r2,r14,zero
 320f318:	103f9e1e 	bne	r2,zero,320f194 <_strtod_r+0x1d4>
 320f31c:	014bc83a 	sub	r5,zero,r5
 320f320:	583f9d26 	beq	r11,zero,320f198 <_strtod_r+0x1d8>
 320f324:	2a8bc83a 	sub	r5,r5,r10
 320f328:	d9400f15 	stw	r5,60(sp)
 320f32c:	30007a1e 	bne	r6,zero,320f518 <_strtod_r+0x558>
 320f330:	dcc01215 	stw	r19,72(sp)
 320f334:	00800404 	movi	r2,16
 320f338:	9825883a 	mov	r18,r19
 320f33c:	14c0010e 	bge	r2,r19,320f344 <_strtod_r+0x384>
 320f340:	1025883a 	mov	r18,r2
 320f344:	a009883a 	mov	r4,r20
 320f348:	3213e3c0 	call	3213e3c <__floatunsidf>
 320f34c:	100f883a 	mov	r7,r2
 320f350:	e0800015 	stw	r2,0(fp)
 320f354:	00800244 	movi	r2,9
 320f358:	e0c00115 	stw	r3,4(fp)
 320f35c:	1480160e 	bge	r2,r18,320f3b8 <_strtod_r+0x3f8>
 320f360:	900c90fa 	slli	r6,r18,3
 320f364:	0100c974 	movhi	r4,805
 320f368:	2138d304 	addi	r4,r4,-7348
 320f36c:	180b883a 	mov	r5,r3
 320f370:	310d883a 	add	r6,r6,r4
 320f374:	30ffef17 	ldw	r3,-68(r6)
 320f378:	30bfee17 	ldw	r2,-72(r6)
 320f37c:	3809883a 	mov	r4,r7
 320f380:	180f883a 	mov	r7,r3
 320f384:	100d883a 	mov	r6,r2
 320f388:	32132ac0 	call	32132ac <__muldf3>
 320f38c:	8009883a 	mov	r4,r16
 320f390:	1823883a 	mov	r17,r3
 320f394:	1021883a 	mov	r16,r2
 320f398:	3213e3c0 	call	3213e3c <__floatunsidf>
 320f39c:	880b883a 	mov	r5,r17
 320f3a0:	180f883a 	mov	r7,r3
 320f3a4:	8009883a 	mov	r4,r16
 320f3a8:	100d883a 	mov	r6,r2
 320f3ac:	32132380 	call	3213238 <__adddf3>
 320f3b0:	e0c00115 	stw	r3,4(fp)
 320f3b4:	e0800015 	stw	r2,0(fp)
 320f3b8:	010003c4 	movi	r4,15
 320f3bc:	24c09816 	blt	r4,r19,320f620 <_strtod_r+0x660>
 320f3c0:	d9800f17 	ldw	r6,60(sp)
 320f3c4:	303f7526 	beq	r6,zero,320f19c <_strtod_r+0x1dc>
 320f3c8:	0183be0e 	bge	zero,r6,32102c4 <_strtod_r+0x1304>
 320f3cc:	00800584 	movi	r2,22
 320f3d0:	1182b20e 	bge	r2,r6,320fe9c <_strtod_r+0xedc>
 320f3d4:	d8c00f17 	ldw	r3,60(sp)
 320f3d8:	24e3c83a 	sub	r17,r4,r19
 320f3dc:	88800584 	addi	r2,r17,22
 320f3e0:	10c08f16 	blt	r2,r3,320f620 <_strtod_r+0x660>
 320f3e4:	880890fa 	slli	r4,r17,3
 320f3e8:	0400c974 	movhi	r16,805
 320f3ec:	8438d304 	addi	r16,r16,-7348
 320f3f0:	e0800017 	ldw	r2,0(fp)
 320f3f4:	2409883a 	add	r4,r4,r16
 320f3f8:	22000017 	ldw	r8,0(r4)
 320f3fc:	22400117 	ldw	r9,4(r4)
 320f400:	e0c00117 	ldw	r3,4(fp)
 320f404:	1009883a 	mov	r4,r2
 320f408:	480f883a 	mov	r7,r9
 320f40c:	180b883a 	mov	r5,r3
 320f410:	400d883a 	mov	r6,r8
 320f414:	32132ac0 	call	32132ac <__muldf3>
 320f418:	d9000f17 	ldw	r4,60(sp)
 320f41c:	180b883a 	mov	r5,r3
 320f420:	2455c83a 	sub	r10,r4,r17
 320f424:	501490fa 	slli	r10,r10,3
 320f428:	1009883a 	mov	r4,r2
 320f42c:	5415883a 	add	r10,r10,r16
 320f430:	52000017 	ldw	r8,0(r10)
 320f434:	52400117 	ldw	r9,4(r10)
 320f438:	0002a206 	br	320fec4 <_strtod_r+0xf04>
 320f43c:	40c00047 	ldb	r3,1(r8)
 320f440:	00801604 	movi	r2,88
 320f444:	18804e26 	beq	r3,r2,320f580 <_strtod_r+0x5c0>
 320f448:	00801e04 	movi	r2,120
 320f44c:	18804c26 	beq	r3,r2,320f580 <_strtod_r+0x5c0>
 320f450:	42000044 	addi	r8,r8,1
 320f454:	da000415 	stw	r8,16(sp)
 320f458:	40c00007 	ldb	r3,0(r8)
 320f45c:	00800c04 	movi	r2,48
 320f460:	18bffb26 	beq	r3,r2,320f450 <_strtod_r+0x490>
 320f464:	183f4d26 	beq	r3,zero,320f19c <_strtod_r+0x1dc>
 320f468:	03c00044 	movi	r15,1
 320f46c:	003f2406 	br	320f100 <_strtod_r+0x140>
 320f470:	42000044 	addi	r8,r8,1
 320f474:	da000415 	stw	r8,16(sp)
 320f478:	19000047 	ldb	r4,1(r3)
 320f47c:	3000b726 	beq	r6,zero,320f75c <_strtod_r+0x79c>
 320f480:	3027883a 	mov	r19,r6
 320f484:	0015883a 	mov	r10,zero
 320f488:	000f883a 	mov	r7,zero
 320f48c:	227ff404 	addi	r9,r4,-48
 320f490:	00800244 	movi	r2,9
 320f494:	1242592e 	bgeu	r2,r9,320fdfc <_strtod_r+0xe3c>
 320f498:	04800044 	movi	r18,1
 320f49c:	003f3706 	br	320f17c <_strtod_r+0x1bc>
 320f4a0:	7804c03a 	cmpne	r2,r15,zero
 320f4a4:	103f3d1e 	bne	r2,zero,320f19c <_strtod_r+0x1dc>
 320f4a8:	9004c03a 	cmpne	r2,r18,zero
 320f4ac:	103f5e1e 	bne	r2,zero,320f228 <_strtod_r+0x268>
 320f4b0:	00801384 	movi	r2,78
 320f4b4:	2083a226 	beq	r4,r2,3210340 <_strtod_r+0x1380>
 320f4b8:	11039d16 	blt	r2,r4,3210330 <_strtod_r+0x1370>
 320f4bc:	00801244 	movi	r2,73
 320f4c0:	20bf591e 	bne	r4,r2,320f228 <_strtod_r+0x268>
 320f4c4:	dc000404 	addi	r16,sp,16
 320f4c8:	8009883a 	mov	r4,r16
 320f4cc:	0140c974 	movhi	r5,805
 320f4d0:	29791c04 	addi	r5,r5,-7056
 320f4d4:	320ef780 	call	320ef78 <match>
 320f4d8:	103f5326 	beq	r2,zero,320f228 <_strtod_r+0x268>
 320f4dc:	d8800417 	ldw	r2,16(sp)
 320f4e0:	8009883a 	mov	r4,r16
 320f4e4:	0140c974 	movhi	r5,805
 320f4e8:	29791d04 	addi	r5,r5,-7052
 320f4ec:	123fffc4 	addi	r8,r2,-1
 320f4f0:	da000415 	stw	r8,16(sp)
 320f4f4:	320ef780 	call	320ef78 <match>
 320f4f8:	1000031e 	bne	r2,zero,320f508 <_strtod_r+0x548>
 320f4fc:	d8800417 	ldw	r2,16(sp)
 320f500:	12000044 	addi	r8,r2,1
 320f504:	da000415 	stw	r8,16(sp)
 320f508:	019ffc34 	movhi	r6,32752
 320f50c:	e1800115 	stw	r6,4(fp)
 320f510:	e0000015 	stw	zero,0(fp)
 320f514:	003f2106 	br	320f19c <_strtod_r+0x1dc>
 320f518:	d9801215 	stw	r6,72(sp)
 320f51c:	003f8506 	br	320f334 <_strtod_r+0x374>
 320f520:	d8001115 	stw	zero,68(sp)
 320f524:	42000044 	addi	r8,r8,1
 320f528:	da000415 	stw	r8,16(sp)
 320f52c:	40800007 	ldb	r2,0(r8)
 320f530:	103eef1e 	bne	r2,zero,320f0f0 <_strtod_r+0x130>
 320f534:	d8001115 	stw	zero,68(sp)
 320f538:	dc400415 	stw	r17,16(sp)
 320f53c:	003f1706 	br	320f19c <_strtod_r+0x1dc>
 320f540:	42000044 	addi	r8,r8,1
 320f544:	da000415 	stw	r8,16(sp)
 320f548:	003eaf06 	br	320f008 <_strtod_r+0x48>
 320f54c:	00800044 	movi	r2,1
 320f550:	d8801115 	stw	r2,68(sp)
 320f554:	003ff306 	br	320f524 <_strtod_r+0x564>
 320f558:	001d883a 	mov	r14,zero
 320f55c:	42000044 	addi	r8,r8,1
 320f560:	da000415 	stw	r8,16(sp)
 320f564:	21000047 	ldb	r4,1(r4)
 320f568:	00800244 	movi	r2,9
 320f56c:	20fff404 	addi	r3,r4,-48
 320f570:	10ff412e 	bgeu	r2,r3,320f278 <_strtod_r+0x2b8>
 320f574:	000b883a 	mov	r5,zero
 320f578:	dc400415 	stw	r17,16(sp)
 320f57c:	003f0506 	br	320f194 <_strtod_r+0x1d4>
 320f580:	d8c01117 	ldw	r3,68(sp)
 320f584:	0480c974 	movhi	r18,805
 320f588:	94848f04 	addi	r18,r18,4668
 320f58c:	d8800504 	addi	r2,sp,20
 320f590:	a809883a 	mov	r4,r21
 320f594:	d9400404 	addi	r5,sp,16
 320f598:	900d883a 	mov	r6,r18
 320f59c:	d9c00604 	addi	r7,sp,24
 320f5a0:	d8800015 	stw	r2,0(sp)
 320f5a4:	d8c00115 	stw	r3,4(sp)
 320f5a8:	321152c0 	call	321152c <__gethex>
 320f5ac:	140001cc 	andi	r16,r2,7
 320f5b0:	1027883a 	mov	r19,r2
 320f5b4:	803ef926 	beq	r16,zero,320f19c <_strtod_r+0x1dc>
 320f5b8:	05000184 	movi	r20,6
 320f5bc:	853f1a26 	beq	r16,r20,320f228 <_strtod_r+0x268>
 320f5c0:	d9800517 	ldw	r6,20(sp)
 320f5c4:	30000626 	beq	r6,zero,320f5e0 <_strtod_r+0x620>
 320f5c8:	91400017 	ldw	r5,0(r18)
 320f5cc:	d9000d04 	addi	r4,sp,52
 320f5d0:	320e1b80 	call	320e1b8 <__copybits>
 320f5d4:	d9400517 	ldw	r5,20(sp)
 320f5d8:	a809883a 	mov	r4,r21
 320f5dc:	320dd180 	call	320dd18 <_Bfree>
 320f5e0:	d9400617 	ldw	r5,24(sp)
 320f5e4:	a4024136 	bltu	r20,r16,320feec <_strtod_r+0xf2c>
 320f5e8:	8405883a 	add	r2,r16,r16
 320f5ec:	1085883a 	add	r2,r2,r2
 320f5f0:	00c0c874 	movhi	r3,801
 320f5f4:	18fd8104 	addi	r3,r3,-2556
 320f5f8:	10c5883a 	add	r2,r2,r3
 320f5fc:	11000017 	ldw	r4,0(r2)
 320f600:	2000683a 	jmp	r4
 320f604:	0320ff2c 	andhi	r12,zero,33788
 320f608:	0320ff38 	rdprs	r12,zero,-31748
 320f60c:	0320fedc 	xori	r12,zero,33787
 320f610:	0320ff04 	movi	r12,-31748
 320f614:	0320ff14 	movui	r12,33788
 320f618:	0320ff38 	rdprs	r12,zero,-31748
 320f61c:	0320ff2c 	andhi	r12,zero,33788
 320f620:	d8c00f17 	ldw	r3,60(sp)
 320f624:	9c85c83a 	sub	r2,r19,r18
 320f628:	18a1883a 	add	r16,r3,r2
 320f62c:	0402d00e 	bge	zero,r16,3210170 <_strtod_r+0x11b0>
 320f630:	814003cc 	andi	r5,r16,15
 320f634:	28000f26 	beq	r5,zero,320f674 <_strtod_r+0x6b4>
 320f638:	280a90fa 	slli	r5,r5,3
 320f63c:	0100c974 	movhi	r4,805
 320f640:	2138d304 	addi	r4,r4,-7348
 320f644:	e0800017 	ldw	r2,0(fp)
 320f648:	290b883a 	add	r5,r5,r4
 320f64c:	2a000017 	ldw	r8,0(r5)
 320f650:	e0c00117 	ldw	r3,4(fp)
 320f654:	2a400117 	ldw	r9,4(r5)
 320f658:	1009883a 	mov	r4,r2
 320f65c:	180b883a 	mov	r5,r3
 320f660:	480f883a 	mov	r7,r9
 320f664:	400d883a 	mov	r6,r8
 320f668:	32132ac0 	call	32132ac <__muldf3>
 320f66c:	e0c00115 	stw	r3,4(fp)
 320f670:	e0800015 	stw	r2,0(fp)
 320f674:	00bffc04 	movi	r2,-16
 320f678:	808c703a 	and	r6,r16,r2
 320f67c:	30005b26 	beq	r6,zero,320f7ec <_strtod_r+0x82c>
 320f680:	00804d04 	movi	r2,308
 320f684:	1181fd16 	blt	r2,r6,320fe7c <_strtod_r+0xebc>
 320f688:	3021d13a 	srai	r16,r6,4
 320f68c:	00800044 	movi	r2,1
 320f690:	1403610e 	bge	r2,r16,3210418 <_strtod_r+0x1458>
 320f694:	102f883a 	mov	r23,r2
 320f698:	0025883a 	mov	r18,zero
 320f69c:	0440c974 	movhi	r17,805
 320f6a0:	8c790504 	addi	r17,r17,-7148
 320f6a4:	8080004c 	andi	r2,r16,1
 320f6a8:	1005003a 	cmpeq	r2,r2,zero
 320f6ac:	1000091e 	bne	r2,zero,320f6d4 <_strtod_r+0x714>
 320f6b0:	e0800017 	ldw	r2,0(fp)
 320f6b4:	e0c00117 	ldw	r3,4(fp)
 320f6b8:	89800017 	ldw	r6,0(r17)
 320f6bc:	89c00117 	ldw	r7,4(r17)
 320f6c0:	180b883a 	mov	r5,r3
 320f6c4:	1009883a 	mov	r4,r2
 320f6c8:	32132ac0 	call	32132ac <__muldf3>
 320f6cc:	e0c00115 	stw	r3,4(fp)
 320f6d0:	e0800015 	stw	r2,0(fp)
 320f6d4:	8021d07a 	srai	r16,r16,1
 320f6d8:	94800044 	addi	r18,r18,1
 320f6dc:	8c400204 	addi	r17,r17,8
 320f6e0:	bc3ff016 	blt	r23,r16,320f6a4 <_strtod_r+0x6e4>
 320f6e4:	900e90fa 	slli	r7,r18,3
 320f6e8:	0180c974 	movhi	r6,805
 320f6ec:	31b90504 	addi	r6,r6,-7148
 320f6f0:	e2000117 	ldw	r8,4(fp)
 320f6f4:	398f883a 	add	r7,r7,r6
 320f6f8:	38800017 	ldw	r2,0(r7)
 320f6fc:	38c00117 	ldw	r3,4(r7)
 320f700:	e1000017 	ldw	r4,0(fp)
 320f704:	01bf2c34 	movhi	r6,64688
 320f708:	418d883a 	add	r6,r8,r6
 320f70c:	300b883a 	mov	r5,r6
 320f710:	180f883a 	mov	r7,r3
 320f714:	100d883a 	mov	r6,r2
 320f718:	32132ac0 	call	32132ac <__muldf3>
 320f71c:	1009883a 	mov	r4,r2
 320f720:	180b883a 	mov	r5,r3
 320f724:	199ffc2c 	andhi	r6,r3,32752
 320f728:	009f2834 	movhi	r2,31904
 320f72c:	e1000015 	stw	r4,0(fp)
 320f730:	e1400115 	stw	r5,4(fp)
 320f734:	1181d136 	bltu	r2,r6,320fe7c <_strtod_r+0xebc>
 320f738:	009f2434 	movhi	r2,31888
 320f73c:	1183202e 	bgeu	r2,r6,32103c0 <_strtod_r+0x1400>
 320f740:	d8001415 	stw	zero,80(sp)
 320f744:	019ffc34 	movhi	r6,32752
 320f748:	31bfffc4 	addi	r6,r6,-1
 320f74c:	01ffffc4 	movi	r7,-1
 320f750:	e1800115 	stw	r6,4(fp)
 320f754:	e1c00015 	stw	r7,0(fp)
 320f758:	00002506 	br	320f7f0 <_strtod_r+0x830>
 320f75c:	00800c04 	movi	r2,48
 320f760:	2083151e 	bne	r4,r2,32103b8 <_strtod_r+0x13f8>
 320f764:	2005883a 	mov	r2,r4
 320f768:	000f883a 	mov	r7,zero
 320f76c:	42000044 	addi	r8,r8,1
 320f770:	da000415 	stw	r8,16(sp)
 320f774:	41000007 	ldb	r4,0(r8)
 320f778:	39c00044 	addi	r7,r7,1
 320f77c:	20bffb26 	beq	r4,r2,320f76c <_strtod_r+0x7ac>
 320f780:	20fff3c4 	addi	r3,r4,-49
 320f784:	00800204 	movi	r2,8
 320f788:	10c1b836 	bltu	r2,r3,320fe6c <_strtod_r+0xeac>
 320f78c:	dd800417 	ldw	r22,16(sp)
 320f790:	3815883a 	mov	r10,r7
 320f794:	227ff404 	addi	r9,r4,-48
 320f798:	b011883a 	mov	r8,r22
 320f79c:	0027883a 	mov	r19,zero
 320f7a0:	01c00044 	movi	r7,1
 320f7a4:	4801fe26 	beq	r9,zero,320ffa0 <_strtod_r+0xfe0>
 320f7a8:	00800044 	movi	r2,1
 320f7ac:	51d5883a 	add	r10,r10,r7
 320f7b0:	11c31f0e 	bge	r2,r7,3210430 <_strtod_r+0x1470>
 320f7b4:	1009883a 	mov	r4,r2
 320f7b8:	9807883a 	mov	r3,r19
 320f7bc:	02c00204 	movi	r11,8
 320f7c0:	03000404 	movi	r12,16
 320f7c4:	00000306 	br	320f7d4 <_strtod_r+0x814>
 320f7c8:	a50002a4 	muli	r20,r20,10
 320f7cc:	21000044 	addi	r4,r4,1
 320f7d0:	21c1eb26 	beq	r4,r7,320ff80 <_strtod_r+0xfc0>
 320f7d4:	18c00044 	addi	r3,r3,1
 320f7d8:	18bfffc4 	addi	r2,r3,-1
 320f7dc:	58bffa0e 	bge	r11,r2,320f7c8 <_strtod_r+0x808>
 320f7e0:	60fffa16 	blt	r12,r3,320f7cc <_strtod_r+0x80c>
 320f7e4:	840002a4 	muli	r16,r16,10
 320f7e8:	003ff806 	br	320f7cc <_strtod_r+0x80c>
 320f7ec:	d8001415 	stw	zero,80(sp)
 320f7f0:	d9801217 	ldw	r6,72(sp)
 320f7f4:	a809883a 	mov	r4,r21
 320f7f8:	b00b883a 	mov	r5,r22
 320f7fc:	980f883a 	mov	r7,r19
 320f800:	dd000015 	stw	r20,0(sp)
 320f804:	320ebec0 	call	320ebec <__s2b>
 320f808:	d9800f17 	ldw	r6,60(sp)
 320f80c:	11000304 	addi	r4,r2,12
 320f810:	d8801015 	stw	r2,64(sp)
 320f814:	300c803a 	cmplt	r6,r6,zero
 320f818:	d9001715 	stw	r4,92(sp)
 320f81c:	d9801615 	stw	r6,88(sp)
 320f820:	d8801017 	ldw	r2,64(sp)
 320f824:	a809883a 	mov	r4,r21
 320f828:	11400117 	ldw	r5,4(r2)
 320f82c:	320e2980 	call	320e298 <_Balloc>
 320f830:	d8c01017 	ldw	r3,64(sp)
 320f834:	d9401717 	ldw	r5,92(sp)
 320f838:	11000304 	addi	r4,r2,12
 320f83c:	19800417 	ldw	r6,16(r3)
 320f840:	102f883a 	mov	r23,r2
 320f844:	318d883a 	add	r6,r6,r6
 320f848:	318d883a 	add	r6,r6,r6
 320f84c:	31800204 	addi	r6,r6,8
 320f850:	3206ad00 	call	3206ad0 <memcpy>
 320f854:	e2000017 	ldw	r8,0(fp)
 320f858:	e2400117 	ldw	r9,4(fp)
 320f85c:	d9800304 	addi	r6,sp,12
 320f860:	400b883a 	mov	r5,r8
 320f864:	a809883a 	mov	r4,r21
 320f868:	d9c00204 	addi	r7,sp,8
 320f86c:	d9800015 	stw	r6,0(sp)
 320f870:	480d883a 	mov	r6,r9
 320f874:	320e3540 	call	320e354 <__d2b>
 320f878:	a809883a 	mov	r4,r21
 320f87c:	01400044 	movi	r5,1
 320f880:	d8800515 	stw	r2,20(sp)
 320f884:	320e9900 	call	320e990 <__i2b>
 320f888:	102d883a 	mov	r22,r2
 320f88c:	d8801617 	ldw	r2,88(sp)
 320f890:	1001051e 	bne	r2,zero,320fca8 <_strtod_r+0xce8>
 320f894:	dd000f17 	ldw	r20,60(sp)
 320f898:	000f883a 	mov	r7,zero
 320f89c:	0013883a 	mov	r9,zero
 320f8a0:	a011883a 	mov	r8,r20
 320f8a4:	d8800217 	ldw	r2,8(sp)
 320f8a8:	1000fd16 	blt	r2,zero,320fca0 <_strtod_r+0xce0>
 320f8ac:	388f883a 	add	r7,r7,r2
 320f8b0:	d9801417 	ldw	r6,80(sp)
 320f8b4:	d9400317 	ldw	r5,12(sp)
 320f8b8:	00ff0084 	movi	r3,-1022
 320f8bc:	1189c83a 	sub	r4,r2,r6
 320f8c0:	2145883a 	add	r2,r4,r5
 320f8c4:	10bfffc4 	addi	r2,r2,-1
 320f8c8:	10c09f0e 	bge	r2,r3,320fb48 <_strtod_r+0xb88>
 320f8cc:	21810cc4 	addi	r6,r4,1075
 320f8d0:	d8c01417 	ldw	r3,80(sp)
 320f8d4:	4185883a 	add	r2,r8,r6
 320f8d8:	39a1883a 	add	r16,r7,r6
 320f8dc:	18a5883a 	add	r18,r3,r2
 320f8e0:	3807883a 	mov	r3,r7
 320f8e4:	81c0010e 	bge	r16,r7,320f8ec <_strtod_r+0x92c>
 320f8e8:	8007883a 	mov	r3,r16
 320f8ec:	9005883a 	mov	r2,r18
 320f8f0:	1c80010e 	bge	r3,r18,320f8f8 <_strtod_r+0x938>
 320f8f4:	1805883a 	mov	r2,r3
 320f8f8:	0080e70e 	bge	zero,r2,320fc98 <_strtod_r+0xcd8>
 320f8fc:	38a7c83a 	sub	r19,r7,r2
 320f900:	80a1c83a 	sub	r16,r16,r2
 320f904:	90a5c83a 	sub	r18,r18,r2
 320f908:	02400e0e 	bge	zero,r9,320f944 <_strtod_r+0x984>
 320f90c:	480d883a 	mov	r6,r9
 320f910:	b00b883a 	mov	r5,r22
 320f914:	a809883a 	mov	r4,r21
 320f918:	320eacc0 	call	320eacc <__pow5mult>
 320f91c:	d9800517 	ldw	r6,20(sp)
 320f920:	a809883a 	mov	r4,r21
 320f924:	100b883a 	mov	r5,r2
 320f928:	102d883a 	mov	r22,r2
 320f92c:	320e7a80 	call	320e7a8 <__multiply>
 320f930:	d9400517 	ldw	r5,20(sp)
 320f934:	1023883a 	mov	r17,r2
 320f938:	a809883a 	mov	r4,r21
 320f93c:	320dd180 	call	320dd18 <_Bfree>
 320f940:	dc400515 	stw	r17,20(sp)
 320f944:	0400050e 	bge	zero,r16,320f95c <_strtod_r+0x99c>
 320f948:	d9400517 	ldw	r5,20(sp)
 320f94c:	800d883a 	mov	r6,r16
 320f950:	a809883a 	mov	r4,r21
 320f954:	320e65c0 	call	320e65c <__lshift>
 320f958:	d8800515 	stw	r2,20(sp)
 320f95c:	a000741e 	bne	r20,zero,320fb30 <_strtod_r+0xb70>
 320f960:	0480050e 	bge	zero,r18,320f978 <_strtod_r+0x9b8>
 320f964:	b80b883a 	mov	r5,r23
 320f968:	900d883a 	mov	r6,r18
 320f96c:	a809883a 	mov	r4,r21
 320f970:	320e65c0 	call	320e65c <__lshift>
 320f974:	102f883a 	mov	r23,r2
 320f978:	04c0050e 	bge	zero,r19,320f990 <_strtod_r+0x9d0>
 320f97c:	b00b883a 	mov	r5,r22
 320f980:	980d883a 	mov	r6,r19
 320f984:	a809883a 	mov	r4,r21
 320f988:	320e65c0 	call	320e65c <__lshift>
 320f98c:	102d883a 	mov	r22,r2
 320f990:	d9400517 	ldw	r5,20(sp)
 320f994:	a809883a 	mov	r4,r21
 320f998:	b80d883a 	mov	r6,r23
 320f99c:	320e4d00 	call	320e4d0 <__mdiff>
 320f9a0:	11000317 	ldw	r4,12(r2)
 320f9a4:	b00b883a 	mov	r5,r22
 320f9a8:	10000315 	stw	zero,12(r2)
 320f9ac:	d9001315 	stw	r4,76(sp)
 320f9b0:	1009883a 	mov	r4,r2
 320f9b4:	1029883a 	mov	r20,r2
 320f9b8:	320de740 	call	320de74 <__mcmp>
 320f9bc:	10017c16 	blt	r2,zero,320ffb0 <_strtod_r+0xff0>
 320f9c0:	1001af26 	beq	r2,zero,3210080 <_strtod_r+0x10c0>
 320f9c4:	a009883a 	mov	r4,r20
 320f9c8:	b00b883a 	mov	r5,r22
 320f9cc:	320e0740 	call	320e074 <__ratio>
 320f9d0:	0011883a 	mov	r8,zero
 320f9d4:	02500034 	movhi	r9,16384
 320f9d8:	480f883a 	mov	r7,r9
 320f9dc:	1009883a 	mov	r4,r2
 320f9e0:	180b883a 	mov	r5,r3
 320f9e4:	400d883a 	mov	r6,r8
 320f9e8:	1021883a 	mov	r16,r2
 320f9ec:	1823883a 	mov	r17,r3
 320f9f0:	3213b700 	call	3213b70 <__ledf2>
 320f9f4:	00805716 	blt	zero,r2,320fb54 <_strtod_r+0xb94>
 320f9f8:	d9801317 	ldw	r6,76(sp)
 320f9fc:	3025003a 	cmpeq	r18,r6,zero
 320fa00:	90008b1e 	bne	r18,zero,320fc30 <_strtod_r+0xc70>
 320fa04:	008ffc34 	movhi	r2,16368
 320fa08:	0021883a 	mov	r16,zero
 320fa0c:	1023883a 	mov	r17,r2
 320fa10:	d8000715 	stw	zero,28(sp)
 320fa14:	d8800815 	stw	r2,32(sp)
 320fa18:	e1c00117 	ldw	r7,4(fp)
 320fa1c:	009ff834 	movhi	r2,32736
 320fa20:	3cdffc2c 	andhi	r19,r7,32752
 320fa24:	98805e26 	beq	r19,r2,320fba0 <_strtod_r+0xbe0>
 320fa28:	d8801417 	ldw	r2,80(sp)
 320fa2c:	10001b26 	beq	r2,zero,320fa9c <_strtod_r+0xadc>
 320fa30:	0081a834 	movhi	r2,1696
 320fa34:	14c01936 	bltu	r2,r19,320fa9c <_strtod_r+0xadc>
 320fa38:	00bff034 	movhi	r2,65472
 320fa3c:	00d07834 	movhi	r3,16864
 320fa40:	18ffffc4 	addi	r3,r3,-1
 320fa44:	180f883a 	mov	r7,r3
 320fa48:	8009883a 	mov	r4,r16
 320fa4c:	880b883a 	mov	r5,r17
 320fa50:	100d883a 	mov	r6,r2
 320fa54:	3213b700 	call	3213b70 <__ledf2>
 320fa58:	00800b16 	blt	zero,r2,320fa88 <_strtod_r+0xac8>
 320fa5c:	880b883a 	mov	r5,r17
 320fa60:	8009883a 	mov	r4,r16
 320fa64:	32120100 	call	3212010 <__fixunsdfsi>
 320fa68:	1000df1e 	bne	r2,zero,320fde8 <_strtod_r+0xe28>
 320fa6c:	0021883a 	mov	r16,zero
 320fa70:	044ffc34 	movhi	r17,16368
 320fa74:	9000d91e 	bne	r18,zero,320fddc <_strtod_r+0xe1c>
 320fa78:	8005883a 	mov	r2,r16
 320fa7c:	8807883a 	mov	r3,r17
 320fa80:	d8c00815 	stw	r3,32(sp)
 320fa84:	d8800715 	stw	r2,28(sp)
 320fa88:	d8800817 	ldw	r2,32(sp)
 320fa8c:	00c1ac34 	movhi	r3,1712
 320fa90:	14c5c83a 	sub	r2,r2,r19
 320fa94:	10c5883a 	add	r2,r2,r3
 320fa98:	d8800815 	stw	r2,32(sp)
 320fa9c:	e0800017 	ldw	r2,0(fp)
 320faa0:	e0c00117 	ldw	r3,4(fp)
 320faa4:	1009883a 	mov	r4,r2
 320faa8:	180b883a 	mov	r5,r3
 320faac:	320ded40 	call	320ded4 <__ulp>
 320fab0:	d9800717 	ldw	r6,28(sp)
 320fab4:	d9c00817 	ldw	r7,32(sp)
 320fab8:	180b883a 	mov	r5,r3
 320fabc:	1009883a 	mov	r4,r2
 320fac0:	32132ac0 	call	32132ac <__muldf3>
 320fac4:	e2000017 	ldw	r8,0(fp)
 320fac8:	e2400117 	ldw	r9,4(fp)
 320facc:	180b883a 	mov	r5,r3
 320fad0:	1009883a 	mov	r4,r2
 320fad4:	480f883a 	mov	r7,r9
 320fad8:	400d883a 	mov	r6,r8
 320fadc:	32132380 	call	3213238 <__adddf3>
 320fae0:	e0c00115 	stw	r3,4(fp)
 320fae4:	e0800015 	stw	r2,0(fp)
 320fae8:	d8c01417 	ldw	r3,80(sp)
 320faec:	e4800117 	ldw	r18,4(fp)
 320faf0:	1800021e 	bne	r3,zero,320fafc <_strtod_r+0xb3c>
 320faf4:	909ffc2c 	andhi	r2,r18,32752
 320faf8:	98807b26 	beq	r19,r2,320fce8 <_strtod_r+0xd28>
 320fafc:	d9400517 	ldw	r5,20(sp)
 320fb00:	a809883a 	mov	r4,r21
 320fb04:	320dd180 	call	320dd18 <_Bfree>
 320fb08:	a809883a 	mov	r4,r21
 320fb0c:	b80b883a 	mov	r5,r23
 320fb10:	320dd180 	call	320dd18 <_Bfree>
 320fb14:	a809883a 	mov	r4,r21
 320fb18:	b00b883a 	mov	r5,r22
 320fb1c:	320dd180 	call	320dd18 <_Bfree>
 320fb20:	a809883a 	mov	r4,r21
 320fb24:	a00b883a 	mov	r5,r20
 320fb28:	320dd180 	call	320dd18 <_Bfree>
 320fb2c:	003f3c06 	br	320f820 <_strtod_r+0x860>
 320fb30:	b80b883a 	mov	r5,r23
 320fb34:	a00d883a 	mov	r6,r20
 320fb38:	a809883a 	mov	r4,r21
 320fb3c:	320eacc0 	call	320eacc <__pow5mult>
 320fb40:	102f883a 	mov	r23,r2
 320fb44:	003f8606 	br	320f960 <_strtod_r+0x9a0>
 320fb48:	00800d84 	movi	r2,54
 320fb4c:	114dc83a 	sub	r6,r2,r5
 320fb50:	003f5f06 	br	320f8d0 <_strtod_r+0x910>
 320fb54:	0005883a 	mov	r2,zero
 320fb58:	00cff834 	movhi	r3,16352
 320fb5c:	880b883a 	mov	r5,r17
 320fb60:	8009883a 	mov	r4,r16
 320fb64:	100d883a 	mov	r6,r2
 320fb68:	180f883a 	mov	r7,r3
 320fb6c:	32132ac0 	call	32132ac <__muldf3>
 320fb70:	d9801317 	ldw	r6,76(sp)
 320fb74:	1021883a 	mov	r16,r2
 320fb78:	1823883a 	mov	r17,r3
 320fb7c:	3025003a 	cmpeq	r18,r6,zero
 320fb80:	90000126 	beq	r18,zero,320fb88 <_strtod_r+0xbc8>
 320fb84:	18e0003c 	xorhi	r3,r3,32768
 320fb88:	d8800715 	stw	r2,28(sp)
 320fb8c:	d8c00815 	stw	r3,32(sp)
 320fb90:	e1c00117 	ldw	r7,4(fp)
 320fb94:	009ff834 	movhi	r2,32736
 320fb98:	3cdffc2c 	andhi	r19,r7,32752
 320fb9c:	98bfa21e 	bne	r19,r2,320fa28 <_strtod_r+0xa68>
 320fba0:	e1000017 	ldw	r4,0(fp)
 320fba4:	01bf2c34 	movhi	r6,64688
 320fba8:	398d883a 	add	r6,r7,r6
 320fbac:	d9000b15 	stw	r4,44(sp)
 320fbb0:	d9c00c15 	stw	r7,48(sp)
 320fbb4:	300b883a 	mov	r5,r6
 320fbb8:	e1800115 	stw	r6,4(fp)
 320fbbc:	320ded40 	call	320ded4 <__ulp>
 320fbc0:	d9800717 	ldw	r6,28(sp)
 320fbc4:	d9c00817 	ldw	r7,32(sp)
 320fbc8:	180b883a 	mov	r5,r3
 320fbcc:	1009883a 	mov	r4,r2
 320fbd0:	32132ac0 	call	32132ac <__muldf3>
 320fbd4:	e2000017 	ldw	r8,0(fp)
 320fbd8:	e2400117 	ldw	r9,4(fp)
 320fbdc:	180b883a 	mov	r5,r3
 320fbe0:	1009883a 	mov	r4,r2
 320fbe4:	480f883a 	mov	r7,r9
 320fbe8:	400d883a 	mov	r6,r8
 320fbec:	32132380 	call	3213238 <__adddf3>
 320fbf0:	1009883a 	mov	r4,r2
 320fbf4:	180b883a 	mov	r5,r3
 320fbf8:	009f2834 	movhi	r2,31904
 320fbfc:	10bfffc4 	addi	r2,r2,-1
 320fc00:	18dffc2c 	andhi	r3,r3,32752
 320fc04:	e1000015 	stw	r4,0(fp)
 320fc08:	e1400115 	stw	r5,4(fp)
 320fc0c:	10c06f2e 	bgeu	r2,r3,320fdcc <_strtod_r+0xe0c>
 320fc10:	d8800c17 	ldw	r2,48(sp)
 320fc14:	011ffc34 	movhi	r4,32752
 320fc18:	213fffc4 	addi	r4,r4,-1
 320fc1c:	11007a26 	beq	r2,r4,320fe08 <_strtod_r+0xe48>
 320fc20:	01ffffc4 	movi	r7,-1
 320fc24:	e1000115 	stw	r4,4(fp)
 320fc28:	e1c00015 	stw	r7,0(fp)
 320fc2c:	003fb306 	br	320fafc <_strtod_r+0xb3c>
 320fc30:	e0c00017 	ldw	r3,0(fp)
 320fc34:	1800221e 	bne	r3,zero,320fcc0 <_strtod_r+0xd00>
 320fc38:	e0800117 	ldw	r2,4(fp)
 320fc3c:	00c00434 	movhi	r3,16
 320fc40:	18ffffc4 	addi	r3,r3,-1
 320fc44:	10c4703a 	and	r2,r2,r3
 320fc48:	1000211e 	bne	r2,zero,320fcd0 <_strtod_r+0xd10>
 320fc4c:	0005883a 	mov	r2,zero
 320fc50:	00cffc34 	movhi	r3,16368
 320fc54:	180f883a 	mov	r7,r3
 320fc58:	8009883a 	mov	r4,r16
 320fc5c:	880b883a 	mov	r5,r17
 320fc60:	100d883a 	mov	r6,r2
 320fc64:	3213ae80 	call	3213ae8 <__ltdf2>
 320fc68:	10013c16 	blt	r2,zero,321015c <_strtod_r+0x119c>
 320fc6c:	0005883a 	mov	r2,zero
 320fc70:	00cff834 	movhi	r3,16352
 320fc74:	880b883a 	mov	r5,r17
 320fc78:	8009883a 	mov	r4,r16
 320fc7c:	180f883a 	mov	r7,r3
 320fc80:	100d883a 	mov	r6,r2
 320fc84:	32132ac0 	call	32132ac <__muldf3>
 320fc88:	1823883a 	mov	r17,r3
 320fc8c:	1021883a 	mov	r16,r2
 320fc90:	18e0003c 	xorhi	r3,r3,32768
 320fc94:	003fbc06 	br	320fb88 <_strtod_r+0xbc8>
 320fc98:	3827883a 	mov	r19,r7
 320fc9c:	003f1a06 	br	320f908 <_strtod_r+0x948>
 320fca0:	4091c83a 	sub	r8,r8,r2
 320fca4:	003f0206 	br	320f8b0 <_strtod_r+0x8f0>
 320fca8:	d8c00f17 	ldw	r3,60(sp)
 320fcac:	0011883a 	mov	r8,zero
 320fcb0:	0029883a 	mov	r20,zero
 320fcb4:	00d3c83a 	sub	r9,zero,r3
 320fcb8:	480f883a 	mov	r7,r9
 320fcbc:	003ef906 	br	320f8a4 <_strtod_r+0x8e4>
 320fcc0:	00800044 	movi	r2,1
 320fcc4:	1880021e 	bne	r3,r2,320fcd0 <_strtod_r+0xd10>
 320fcc8:	e0800117 	ldw	r2,4(fp)
 320fccc:	1000a526 	beq	r2,zero,320ff64 <_strtod_r+0xfa4>
 320fcd0:	00affc34 	movhi	r2,49136
 320fcd4:	0021883a 	mov	r16,zero
 320fcd8:	044ffc34 	movhi	r17,16368
 320fcdc:	d8800815 	stw	r2,32(sp)
 320fce0:	d8000715 	stw	zero,28(sp)
 320fce4:	003f4c06 	br	320fa18 <_strtod_r+0xa58>
 320fce8:	880b883a 	mov	r5,r17
 320fcec:	8009883a 	mov	r4,r16
 320fcf0:	3213cf00 	call	3213cf0 <__fixdfsi>
 320fcf4:	1009883a 	mov	r4,r2
 320fcf8:	3213bf80 	call	3213bf8 <__floatsidf>
 320fcfc:	880b883a 	mov	r5,r17
 320fd00:	8009883a 	mov	r4,r16
 320fd04:	100d883a 	mov	r6,r2
 320fd08:	180f883a 	mov	r7,r3
 320fd0c:	32131b80 	call	32131b8 <__subdf3>
 320fd10:	d9001317 	ldw	r4,76(sp)
 320fd14:	100b883a 	mov	r5,r2
 320fd18:	180d883a 	mov	r6,r3
 320fd1c:	1021883a 	mov	r16,r2
 320fd20:	1823883a 	mov	r17,r3
 320fd24:	2000061e 	bne	r4,zero,320fd40 <_strtod_r+0xd80>
 320fd28:	e0800017 	ldw	r2,0(fp)
 320fd2c:	1000041e 	bne	r2,zero,320fd40 <_strtod_r+0xd80>
 320fd30:	00c00434 	movhi	r3,16
 320fd34:	18ffffc4 	addi	r3,r3,-1
 320fd38:	90c4703a 	and	r2,r18,r3
 320fd3c:	10004026 	beq	r2,zero,320fe40 <_strtod_r+0xe80>
 320fd40:	00a52834 	movhi	r2,38048
 320fd44:	108d6544 	addi	r2,r2,13717
 320fd48:	00cff834 	movhi	r3,16352
 320fd4c:	18ffffc4 	addi	r3,r3,-1
 320fd50:	180f883a 	mov	r7,r3
 320fd54:	8009883a 	mov	r4,r16
 320fd58:	880b883a 	mov	r5,r17
 320fd5c:	100d883a 	mov	r6,r2
 320fd60:	3213ae80 	call	3213ae8 <__ltdf2>
 320fd64:	10000916 	blt	r2,zero,320fd8c <_strtod_r+0xdcc>
 320fd68:	008d6c34 	movhi	r2,13744
 320fd6c:	10b94d44 	addi	r2,r2,-6859
 320fd70:	00cff834 	movhi	r3,16352
 320fd74:	880b883a 	mov	r5,r17
 320fd78:	180f883a 	mov	r7,r3
 320fd7c:	8009883a 	mov	r4,r16
 320fd80:	100d883a 	mov	r6,r2
 320fd84:	32139d80 	call	32139d8 <__gtdf2>
 320fd88:	00bf5c0e 	bge	zero,r2,320fafc <_strtod_r+0xb3c>
 320fd8c:	d9400517 	ldw	r5,20(sp)
 320fd90:	a809883a 	mov	r4,r21
 320fd94:	320dd180 	call	320dd18 <_Bfree>
 320fd98:	a809883a 	mov	r4,r21
 320fd9c:	b80b883a 	mov	r5,r23
 320fda0:	320dd180 	call	320dd18 <_Bfree>
 320fda4:	a809883a 	mov	r4,r21
 320fda8:	b00b883a 	mov	r5,r22
 320fdac:	320dd180 	call	320dd18 <_Bfree>
 320fdb0:	d9401017 	ldw	r5,64(sp)
 320fdb4:	a809883a 	mov	r4,r21
 320fdb8:	320dd180 	call	320dd18 <_Bfree>
 320fdbc:	a809883a 	mov	r4,r21
 320fdc0:	a00b883a 	mov	r5,r20
 320fdc4:	320dd180 	call	320dd18 <_Bfree>
 320fdc8:	003cf406 	br	320f19c <_strtod_r+0x1dc>
 320fdcc:	0080d434 	movhi	r2,848
 320fdd0:	288d883a 	add	r6,r5,r2
 320fdd4:	e1800115 	stw	r6,4(fp)
 320fdd8:	003f4306 	br	320fae8 <_strtod_r+0xb28>
 320fddc:	8005883a 	mov	r2,r16
 320fde0:	88e0003c 	xorhi	r3,r17,32768
 320fde4:	003f2606 	br	320fa80 <_strtod_r+0xac0>
 320fde8:	1009883a 	mov	r4,r2
 320fdec:	3213e3c0 	call	3213e3c <__floatunsidf>
 320fdf0:	1021883a 	mov	r16,r2
 320fdf4:	1823883a 	mov	r17,r3
 320fdf8:	003f1e06 	br	320fa74 <_strtod_r+0xab4>
 320fdfc:	da000417 	ldw	r8,16(sp)
 320fe00:	39c00044 	addi	r7,r7,1
 320fe04:	003e6706 	br	320f7a4 <_strtod_r+0x7e4>
 320fe08:	d8c00b17 	ldw	r3,44(sp)
 320fe0c:	00bfffc4 	movi	r2,-1
 320fe10:	18bf831e 	bne	r3,r2,320fc20 <_strtod_r+0xc60>
 320fe14:	00c00884 	movi	r3,34
 320fe18:	a8c00015 	stw	r3,0(r21)
 320fe1c:	009ffc34 	movhi	r2,32752
 320fe20:	e0800115 	stw	r2,4(fp)
 320fe24:	e0000015 	stw	zero,0(fp)
 320fe28:	003fd806 	br	320fd8c <_strtod_r+0xdcc>
 320fe2c:	4007883a 	mov	r3,r8
 320fe30:	000d883a 	mov	r6,zero
 320fe34:	0029883a 	mov	r20,zero
 320fe38:	0021883a 	mov	r16,zero
 320fe3c:	003cc906 	br	320f164 <_strtod_r+0x1a4>
 320fe40:	00a52834 	movhi	r2,38048
 320fe44:	108d6544 	addi	r2,r2,13717
 320fe48:	00cff434 	movhi	r3,16336
 320fe4c:	18ffffc4 	addi	r3,r3,-1
 320fe50:	2809883a 	mov	r4,r5
 320fe54:	180f883a 	mov	r7,r3
 320fe58:	300b883a 	mov	r5,r6
 320fe5c:	100d883a 	mov	r6,r2
 320fe60:	3213ae80 	call	3213ae8 <__ltdf2>
 320fe64:	103f250e 	bge	r2,zero,320fafc <_strtod_r+0xb3c>
 320fe68:	003fc806 	br	320fd8c <_strtod_r+0xdcc>
 320fe6c:	0027883a 	mov	r19,zero
 320fe70:	04800044 	movi	r18,1
 320fe74:	0015883a 	mov	r10,zero
 320fe78:	003cc006 	br	320f17c <_strtod_r+0x1bc>
 320fe7c:	00800884 	movi	r2,34
 320fe80:	a8800015 	stw	r2,0(r21)
 320fe84:	019ffc34 	movhi	r6,32752
 320fe88:	e1800115 	stw	r6,4(fp)
 320fe8c:	e0000015 	stw	zero,0(fp)
 320fe90:	003cc206 	br	320f19c <_strtod_r+0x1dc>
 320fe94:	015387c4 	movi	r5,19999
 320fe98:	003d1e06 	br	320f314 <_strtod_r+0x354>
 320fe9c:	300a90fa 	slli	r5,r6,3
 320fea0:	e0800017 	ldw	r2,0(fp)
 320fea4:	e0c00117 	ldw	r3,4(fp)
 320fea8:	0100c974 	movhi	r4,805
 320feac:	2138d304 	addi	r4,r4,-7348
 320feb0:	290b883a 	add	r5,r5,r4
 320feb4:	2a000017 	ldw	r8,0(r5)
 320feb8:	2a400117 	ldw	r9,4(r5)
 320febc:	1009883a 	mov	r4,r2
 320fec0:	180b883a 	mov	r5,r3
 320fec4:	480f883a 	mov	r7,r9
 320fec8:	400d883a 	mov	r6,r8
 320fecc:	32132ac0 	call	32132ac <__muldf3>
 320fed0:	e0c00115 	stw	r3,4(fp)
 320fed4:	e0800015 	stw	r2,0(fp)
 320fed8:	003cb006 	br	320f19c <_strtod_r+0x1dc>
 320fedc:	d8800d17 	ldw	r2,52(sp)
 320fee0:	e0800015 	stw	r2,0(fp)
 320fee4:	d8c00e17 	ldw	r3,56(sp)
 320fee8:	e0c00115 	stw	r3,4(fp)
 320feec:	9880020c 	andi	r2,r19,8
 320fef0:	103caa26 	beq	r2,zero,320f19c <_strtod_r+0x1dc>
 320fef4:	e0800117 	ldw	r2,4(fp)
 320fef8:	10a00034 	orhi	r2,r2,32768
 320fefc:	e0800115 	stw	r2,4(fp)
 320ff00:	003ca606 	br	320f19c <_strtod_r+0x1dc>
 320ff04:	009ffc34 	movhi	r2,32752
 320ff08:	e0800115 	stw	r2,4(fp)
 320ff0c:	e0000015 	stw	zero,0(fp)
 320ff10:	003ff606 	br	320feec <_strtod_r+0xf2c>
 320ff14:	00a00034 	movhi	r2,32768
 320ff18:	10bfffc4 	addi	r2,r2,-1
 320ff1c:	00ffffc4 	movi	r3,-1
 320ff20:	e0800115 	stw	r2,4(fp)
 320ff24:	e0c00015 	stw	r3,0(fp)
 320ff28:	003ff006 	br	320feec <_strtod_r+0xf2c>
 320ff2c:	e0000115 	stw	zero,4(fp)
 320ff30:	e0000015 	stw	zero,0(fp)
 320ff34:	003fed06 	br	320feec <_strtod_r+0xf2c>
 320ff38:	d8800e17 	ldw	r2,56(sp)
 320ff3c:	29010cc4 	addi	r4,r5,1075
 320ff40:	00fffc34 	movhi	r3,65520
 320ff44:	18ffffc4 	addi	r3,r3,-1
 320ff48:	2008953a 	slli	r4,r4,20
 320ff4c:	10c4703a 	and	r2,r2,r3
 320ff50:	d8c00d17 	ldw	r3,52(sp)
 320ff54:	1104b03a 	or	r2,r2,r4
 320ff58:	e0800115 	stw	r2,4(fp)
 320ff5c:	e0c00015 	stw	r3,0(fp)
 320ff60:	003fe206 	br	320feec <_strtod_r+0xf2c>
 320ff64:	00800884 	movi	r2,34
 320ff68:	a8800015 	stw	r2,0(r21)
 320ff6c:	e0000015 	stw	zero,0(fp)
 320ff70:	e0000115 	stw	zero,4(fp)
 320ff74:	003f8506 	br	320fd8c <_strtod_r+0xdcc>
 320ff78:	03800044 	movi	r14,1
 320ff7c:	003d7706 	br	320f55c <_strtod_r+0x59c>
 320ff80:	99c5883a 	add	r2,r19,r7
 320ff84:	11ffffc4 	addi	r7,r2,-1
 320ff88:	00800204 	movi	r2,8
 320ff8c:	3cc00044 	addi	r19,r7,1
 320ff90:	11c0df16 	blt	r2,r7,3210310 <_strtod_r+0x1350>
 320ff94:	a08002a4 	muli	r2,r20,10
 320ff98:	000f883a 	mov	r7,zero
 320ff9c:	1269883a 	add	r20,r2,r9
 320ffa0:	42000044 	addi	r8,r8,1
 320ffa4:	da000415 	stw	r8,16(sp)
 320ffa8:	41000007 	ldb	r4,0(r8)
 320ffac:	003d3706 	br	320f48c <_strtod_r+0x4cc>
 320ffb0:	d9801317 	ldw	r6,76(sp)
 320ffb4:	3000511e 	bne	r6,zero,32100fc <_strtod_r+0x113c>
 320ffb8:	e0800017 	ldw	r2,0(fp)
 320ffbc:	1000d81e 	bne	r2,zero,3210320 <_strtod_r+0x1360>
 320ffc0:	e0c00117 	ldw	r3,4(fp)
 320ffc4:	01000434 	movhi	r4,16
 320ffc8:	213fffc4 	addi	r4,r4,-1
 320ffcc:	1904703a 	and	r2,r3,r4
 320ffd0:	1000b01e 	bne	r2,zero,3210294 <_strtod_r+0x12d4>
 320ffd4:	18dffc2c 	andhi	r3,r3,32752
 320ffd8:	0081ac34 	movhi	r2,1712
 320ffdc:	10c1102e 	bgeu	r2,r3,3210420 <_strtod_r+0x1460>
 320ffe0:	a0800517 	ldw	r2,20(r20)
 320ffe4:	1000031e 	bne	r2,zero,320fff4 <_strtod_r+0x1034>
 320ffe8:	a0c00417 	ldw	r3,16(r20)
 320ffec:	00800044 	movi	r2,1
 320fff0:	10c0420e 	bge	r2,r3,32100fc <_strtod_r+0x113c>
 320fff4:	a00b883a 	mov	r5,r20
 320fff8:	a809883a 	mov	r4,r21
 320fffc:	01800044 	movi	r6,1
 3210000:	320e65c0 	call	320e65c <__lshift>
 3210004:	1009883a 	mov	r4,r2
 3210008:	b00b883a 	mov	r5,r22
 321000c:	1029883a 	mov	r20,r2
 3210010:	320de740 	call	320de74 <__mcmp>
 3210014:	0080c20e 	bge	zero,r2,3210320 <_strtod_r+0x1360>
 3210018:	e1800117 	ldw	r6,4(fp)
 321001c:	d9001417 	ldw	r4,80(sp)
 3210020:	2013003a 	cmpeq	r9,r4,zero
 3210024:	4800ef1e 	bne	r9,zero,32103e4 <_strtod_r+0x1424>
 3210028:	30dffc2c 	andhi	r3,r6,32752
 321002c:	0081ac34 	movhi	r2,1712
 3210030:	10c0ec36 	bltu	r2,r3,32103e4 <_strtod_r+0x1424>
 3210034:	0080dc34 	movhi	r2,880
 3210038:	10ffca2e 	bgeu	r2,r3,320ff64 <_strtod_r+0xfa4>
 321003c:	e0800017 	ldw	r2,0(fp)
 3210040:	e0c00117 	ldw	r3,4(fp)
 3210044:	020e5434 	movhi	r8,14672
 3210048:	000d883a 	mov	r6,zero
 321004c:	400f883a 	mov	r7,r8
 3210050:	180b883a 	mov	r5,r3
 3210054:	1009883a 	mov	r4,r2
 3210058:	da000c15 	stw	r8,48(sp)
 321005c:	d8000b15 	stw	zero,44(sp)
 3210060:	32132ac0 	call	32132ac <__muldf3>
 3210064:	e0800015 	stw	r2,0(fp)
 3210068:	e0c00115 	stw	r3,4(fp)
 321006c:	183f471e 	bne	r3,zero,320fd8c <_strtod_r+0xdcc>
 3210070:	103f461e 	bne	r2,zero,320fd8c <_strtod_r+0xdcc>
 3210074:	00800884 	movi	r2,34
 3210078:	a8800015 	stw	r2,0(r21)
 321007c:	003f4306 	br	320fd8c <_strtod_r+0xdcc>
 3210080:	d8801317 	ldw	r2,76(sp)
 3210084:	1025003a 	cmpeq	r18,r2,zero
 3210088:	9000861e 	bne	r18,zero,32102a4 <_strtod_r+0x12e4>
 321008c:	e1400117 	ldw	r5,4(fp)
 3210090:	00c00434 	movhi	r3,16
 3210094:	18ffffc4 	addi	r3,r3,-1
 3210098:	28c4703a 	and	r2,r5,r3
 321009c:	10c01b26 	beq	r2,r3,321010c <_strtod_r+0x114c>
 32100a0:	e1c00017 	ldw	r7,0(fp)
 32100a4:	3880004c 	andi	r2,r7,1
 32100a8:	1005003a 	cmpeq	r2,r2,zero
 32100ac:	1000791e 	bne	r2,zero,3210294 <_strtod_r+0x12d4>
 32100b0:	9000b126 	beq	r18,zero,3210378 <_strtod_r+0x13b8>
 32100b4:	e4400117 	ldw	r17,4(fp)
 32100b8:	3809883a 	mov	r4,r7
 32100bc:	3821883a 	mov	r16,r7
 32100c0:	880b883a 	mov	r5,r17
 32100c4:	320ded40 	call	320ded4 <__ulp>
 32100c8:	180f883a 	mov	r7,r3
 32100cc:	880b883a 	mov	r5,r17
 32100d0:	8009883a 	mov	r4,r16
 32100d4:	100d883a 	mov	r6,r2
 32100d8:	32131b80 	call	32131b8 <__subdf3>
 32100dc:	1009883a 	mov	r4,r2
 32100e0:	000d883a 	mov	r6,zero
 32100e4:	000f883a 	mov	r7,zero
 32100e8:	180b883a 	mov	r5,r3
 32100ec:	e0800015 	stw	r2,0(fp)
 32100f0:	e0c00115 	stw	r3,4(fp)
 32100f4:	32139500 	call	3213950 <__nedf2>
 32100f8:	103f9a26 	beq	r2,zero,320ff64 <_strtod_r+0xfa4>
 32100fc:	d9001417 	ldw	r4,80(sp)
 3210100:	2013003a 	cmpeq	r9,r4,zero
 3210104:	483f211e 	bne	r9,zero,320fd8c <_strtod_r+0xdcc>
 3210108:	003fcc06 	br	321003c <_strtod_r+0x107c>
 321010c:	d9001417 	ldw	r4,80(sp)
 3210110:	e1c00017 	ldw	r7,0(fp)
 3210114:	2013003a 	cmpeq	r9,r4,zero
 3210118:	4800bd1e 	bne	r9,zero,3210410 <_strtod_r+0x1450>
 321011c:	28dffc2c 	andhi	r3,r5,32752
 3210120:	0081a834 	movhi	r2,1696
 3210124:	10c0ba36 	bltu	r2,r3,3210410 <_strtod_r+0x1450>
 3210128:	1804d53a 	srli	r2,r3,20
 321012c:	00c01ac4 	movi	r3,107
 3210130:	013fffc4 	movi	r4,-1
 3210134:	1887c83a 	sub	r3,r3,r2
 3210138:	20c4983a 	sll	r2,r4,r3
 321013c:	11ffd91e 	bne	r2,r7,32100a4 <_strtod_r+0x10e4>
 3210140:	28dffc2c 	andhi	r3,r5,32752
 3210144:	00800434 	movhi	r2,16
 3210148:	188d883a 	add	r6,r3,r2
 321014c:	e1800115 	stw	r6,4(fp)
 3210150:	e0000015 	stw	zero,0(fp)
 3210154:	483f0d1e 	bne	r9,zero,320fd8c <_strtod_r+0xdcc>
 3210158:	003fb806 	br	321003c <_strtod_r+0x107c>
 321015c:	0021883a 	mov	r16,zero
 3210160:	0005883a 	mov	r2,zero
 3210164:	044ff834 	movhi	r17,16352
 3210168:	00eff834 	movhi	r3,49120
 321016c:	003e8606 	br	320fb88 <_strtod_r+0xbc8>
 3210170:	803d9e26 	beq	r16,zero,320f7ec <_strtod_r+0x82c>
 3210174:	0421c83a 	sub	r16,zero,r16
 3210178:	814003cc 	andi	r5,r16,15
 321017c:	28000f26 	beq	r5,zero,32101bc <_strtod_r+0x11fc>
 3210180:	280a90fa 	slli	r5,r5,3
 3210184:	0100c974 	movhi	r4,805
 3210188:	2138d304 	addi	r4,r4,-7348
 321018c:	e0800017 	ldw	r2,0(fp)
 3210190:	290b883a 	add	r5,r5,r4
 3210194:	2a000017 	ldw	r8,0(r5)
 3210198:	e0c00117 	ldw	r3,4(fp)
 321019c:	2a400117 	ldw	r9,4(r5)
 32101a0:	1009883a 	mov	r4,r2
 32101a4:	180b883a 	mov	r5,r3
 32101a8:	480f883a 	mov	r7,r9
 32101ac:	400d883a 	mov	r6,r8
 32101b0:	32136700 	call	3213670 <__divdf3>
 32101b4:	e0c00115 	stw	r3,4(fp)
 32101b8:	e0800015 	stw	r2,0(fp)
 32101bc:	8021d13a 	srai	r16,r16,4
 32101c0:	803d8a26 	beq	r16,zero,320f7ec <_strtod_r+0x82c>
 32101c4:	008007c4 	movi	r2,31
 32101c8:	14002d16 	blt	r2,r16,3210280 <_strtod_r+0x12c0>
 32101cc:	8080040c 	andi	r2,r16,16
 32101d0:	10009926 	beq	r2,zero,3210438 <_strtod_r+0x1478>
 32101d4:	00801a84 	movi	r2,106
 32101d8:	d8801415 	stw	r2,80(sp)
 32101dc:	0400110e 	bge	zero,r16,3210224 <_strtod_r+0x1264>
 32101e0:	0440c974 	movhi	r17,805
 32101e4:	8c792004 	addi	r17,r17,-7040
 32101e8:	8080004c 	andi	r2,r16,1
 32101ec:	1005003a 	cmpeq	r2,r2,zero
 32101f0:	1000091e 	bne	r2,zero,3210218 <_strtod_r+0x1258>
 32101f4:	e0800017 	ldw	r2,0(fp)
 32101f8:	e0c00117 	ldw	r3,4(fp)
 32101fc:	89800017 	ldw	r6,0(r17)
 3210200:	89c00117 	ldw	r7,4(r17)
 3210204:	180b883a 	mov	r5,r3
 3210208:	1009883a 	mov	r4,r2
 321020c:	32132ac0 	call	32132ac <__muldf3>
 3210210:	e0c00115 	stw	r3,4(fp)
 3210214:	e0800015 	stw	r2,0(fp)
 3210218:	8021d07a 	srai	r16,r16,1
 321021c:	8c400204 	addi	r17,r17,8
 3210220:	043ff116 	blt	zero,r16,32101e8 <_strtod_r+0x1228>
 3210224:	d8c01417 	ldw	r3,80(sp)
 3210228:	18000d26 	beq	r3,zero,3210260 <_strtod_r+0x12a0>
 321022c:	e1000117 	ldw	r4,4(fp)
 3210230:	00c01ac4 	movi	r3,107
 3210234:	209ffc2c 	andhi	r2,r4,32752
 3210238:	1004d53a 	srli	r2,r2,20
 321023c:	1887c83a 	sub	r3,r3,r2
 3210240:	00c0070e 	bge	zero,r3,3210260 <_strtod_r+0x12a0>
 3210244:	008007c4 	movi	r2,31
 3210248:	10c0900e 	bge	r2,r3,321048c <_strtod_r+0x14cc>
 321024c:	00800d04 	movi	r2,52
 3210250:	e0000015 	stw	zero,0(fp)
 3210254:	10c0870e 	bge	r2,r3,3210474 <_strtod_r+0x14b4>
 3210258:	0180dc34 	movhi	r6,880
 321025c:	e1800115 	stw	r6,4(fp)
 3210260:	e0800017 	ldw	r2,0(fp)
 3210264:	e0c00117 	ldw	r3,4(fp)
 3210268:	000d883a 	mov	r6,zero
 321026c:	000f883a 	mov	r7,zero
 3210270:	180b883a 	mov	r5,r3
 3210274:	1009883a 	mov	r4,r2
 3210278:	32139500 	call	3213950 <__nedf2>
 321027c:	103d5c1e 	bne	r2,zero,320f7f0 <_strtod_r+0x830>
 3210280:	00800884 	movi	r2,34
 3210284:	a8800015 	stw	r2,0(r21)
 3210288:	e0000015 	stw	zero,0(fp)
 321028c:	e0000115 	stw	zero,4(fp)
 3210290:	003bc206 	br	320f19c <_strtod_r+0x1dc>
 3210294:	d8801417 	ldw	r2,80(sp)
 3210298:	1013003a 	cmpeq	r9,r2,zero
 321029c:	483ebb1e 	bne	r9,zero,320fd8c <_strtod_r+0xdcc>
 32102a0:	003f6606 	br	321003c <_strtod_r+0x107c>
 32102a4:	e1800117 	ldw	r6,4(fp)
 32102a8:	00c00434 	movhi	r3,16
 32102ac:	18ffffc4 	addi	r3,r3,-1
 32102b0:	30c4703a 	and	r2,r6,r3
 32102b4:	103f7a1e 	bne	r2,zero,32100a0 <_strtod_r+0x10e0>
 32102b8:	e1c00017 	ldw	r7,0(fp)
 32102bc:	383f791e 	bne	r7,zero,32100a4 <_strtod_r+0x10e4>
 32102c0:	003f5606 	br	321001c <_strtod_r+0x105c>
 32102c4:	d9800f17 	ldw	r6,60(sp)
 32102c8:	00bffa84 	movi	r2,-22
 32102cc:	30bcd416 	blt	r6,r2,320f620 <_strtod_r+0x660>
 32102d0:	317ffe24 	muli	r5,r6,-8
 32102d4:	0100c974 	movhi	r4,805
 32102d8:	2138d304 	addi	r4,r4,-7348
 32102dc:	e0800017 	ldw	r2,0(fp)
 32102e0:	290b883a 	add	r5,r5,r4
 32102e4:	2a000017 	ldw	r8,0(r5)
 32102e8:	e0c00117 	ldw	r3,4(fp)
 32102ec:	2a400117 	ldw	r9,4(r5)
 32102f0:	1009883a 	mov	r4,r2
 32102f4:	180b883a 	mov	r5,r3
 32102f8:	480f883a 	mov	r7,r9
 32102fc:	400d883a 	mov	r6,r8
 3210300:	32136700 	call	3213670 <__divdf3>
 3210304:	e0c00115 	stw	r3,4(fp)
 3210308:	e0800015 	stw	r2,0(fp)
 321030c:	003ba306 	br	320f19c <_strtod_r+0x1dc>
 3210310:	00800404 	movi	r2,16
 3210314:	14c02f0e 	bge	r2,r19,32103d4 <_strtod_r+0x1414>
 3210318:	000f883a 	mov	r7,zero
 321031c:	003f2006 	br	320ffa0 <_strtod_r+0xfe0>
 3210320:	d9801417 	ldw	r6,80(sp)
 3210324:	3013003a 	cmpeq	r9,r6,zero
 3210328:	483e981e 	bne	r9,zero,320fd8c <_strtod_r+0xdcc>
 321032c:	003f4306 	br	321003c <_strtod_r+0x107c>
 3210330:	00801a44 	movi	r2,105
 3210334:	20bc6326 	beq	r4,r2,320f4c4 <_strtod_r+0x504>
 3210338:	00801b84 	movi	r2,110
 321033c:	20bbba1e 	bne	r4,r2,320f228 <_strtod_r+0x268>
 3210340:	dc000404 	addi	r16,sp,16
 3210344:	8009883a 	mov	r4,r16
 3210348:	0140c974 	movhi	r5,805
 321034c:	29791f04 	addi	r5,r5,-7044
 3210350:	320ef780 	call	320ef78 <match>
 3210354:	103bb426 	beq	r2,zero,320f228 <_strtod_r+0x268>
 3210358:	d8800417 	ldw	r2,16(sp)
 321035c:	00c00a04 	movi	r3,40
 3210360:	11000007 	ldb	r4,0(r2)
 3210364:	20c03626 	beq	r4,r3,3210440 <_strtod_r+0x1480>
 3210368:	01bffe34 	movhi	r6,65528
 321036c:	e1800115 	stw	r6,4(fp)
 3210370:	e0000015 	stw	zero,0(fp)
 3210374:	003b8906 	br	320f19c <_strtod_r+0x1dc>
 3210378:	e4400117 	ldw	r17,4(fp)
 321037c:	3809883a 	mov	r4,r7
 3210380:	3821883a 	mov	r16,r7
 3210384:	880b883a 	mov	r5,r17
 3210388:	320ded40 	call	320ded4 <__ulp>
 321038c:	100d883a 	mov	r6,r2
 3210390:	880b883a 	mov	r5,r17
 3210394:	180f883a 	mov	r7,r3
 3210398:	8009883a 	mov	r4,r16
 321039c:	32132380 	call	3213238 <__adddf3>
 32103a0:	d9801417 	ldw	r6,80(sp)
 32103a4:	e0c00115 	stw	r3,4(fp)
 32103a8:	e0800015 	stw	r2,0(fp)
 32103ac:	3013003a 	cmpeq	r9,r6,zero
 32103b0:	483e761e 	bne	r9,zero,320fd8c <_strtod_r+0xdcc>
 32103b4:	003f2106 	br	321003c <_strtod_r+0x107c>
 32103b8:	000f883a 	mov	r7,zero
 32103bc:	003cf006 	br	320f780 <_strtod_r+0x7c0>
 32103c0:	0080d434 	movhi	r2,848
 32103c4:	188d883a 	add	r6,r3,r2
 32103c8:	d8001415 	stw	zero,80(sp)
 32103cc:	e1800115 	stw	r6,4(fp)
 32103d0:	003d0706 	br	320f7f0 <_strtod_r+0x830>
 32103d4:	808002a4 	muli	r2,r16,10
 32103d8:	000f883a 	mov	r7,zero
 32103dc:	1261883a 	add	r16,r2,r9
 32103e0:	003eef06 	br	320ffa0 <_strtod_r+0xfe0>
 32103e4:	309ffc2c 	andhi	r2,r6,32752
 32103e8:	00fffc34 	movhi	r3,65520
 32103ec:	10c5883a 	add	r2,r2,r3
 32103f0:	00c00434 	movhi	r3,16
 32103f4:	18ffffc4 	addi	r3,r3,-1
 32103f8:	10ccb03a 	or	r6,r2,r3
 32103fc:	01ffffc4 	movi	r7,-1
 3210400:	e1800115 	stw	r6,4(fp)
 3210404:	e1c00015 	stw	r7,0(fp)
 3210408:	483e601e 	bne	r9,zero,320fd8c <_strtod_r+0xdcc>
 321040c:	003f0b06 	br	321003c <_strtod_r+0x107c>
 3210410:	00bfffc4 	movi	r2,-1
 3210414:	003f4906 	br	321013c <_strtod_r+0x117c>
 3210418:	0025883a 	mov	r18,zero
 321041c:	003cb106 	br	320f6e4 <_strtod_r+0x724>
 3210420:	d8c01417 	ldw	r3,80(sp)
 3210424:	1813003a 	cmpeq	r9,r3,zero
 3210428:	483e581e 	bne	r9,zero,320fd8c <_strtod_r+0xdcc>
 321042c:	003f0306 	br	321003c <_strtod_r+0x107c>
 3210430:	980f883a 	mov	r7,r19
 3210434:	003ed406 	br	320ff88 <_strtod_r+0xfc8>
 3210438:	d8001415 	stw	zero,80(sp)
 321043c:	003f6706 	br	32101dc <_strtod_r+0x121c>
 3210440:	8009883a 	mov	r4,r16
 3210444:	0140c974 	movhi	r5,805
 3210448:	29448a04 	addi	r5,r5,4648
 321044c:	d9800d04 	addi	r6,sp,52
 3210450:	3211d300 	call	3211d30 <__hexnan>
 3210454:	00c00144 	movi	r3,5
 3210458:	10ffc31e 	bne	r2,r3,3210368 <_strtod_r+0x13a8>
 321045c:	d8800e17 	ldw	r2,56(sp)
 3210460:	d9c00d17 	ldw	r7,52(sp)
 3210464:	119ffc34 	orhi	r6,r2,32752
 3210468:	e1800115 	stw	r6,4(fp)
 321046c:	e1c00015 	stw	r7,0(fp)
 3210470:	003b4a06 	br	320f19c <_strtod_r+0x1dc>
 3210474:	18fff804 	addi	r3,r3,-32
 3210478:	00bfffc4 	movi	r2,-1
 321047c:	10c4983a 	sll	r2,r2,r3
 3210480:	208c703a 	and	r6,r4,r2
 3210484:	e1800115 	stw	r6,4(fp)
 3210488:	003f7506 	br	3210260 <_strtod_r+0x12a0>
 321048c:	00bfffc4 	movi	r2,-1
 3210490:	10c4983a 	sll	r2,r2,r3
 3210494:	e0c00017 	ldw	r3,0(fp)
 3210498:	188e703a 	and	r7,r3,r2
 321049c:	e1c00015 	stw	r7,0(fp)
 32104a0:	003f6f06 	br	3210260 <_strtod_r+0x12a0>

032104a4 <strtof>:
 32104a4:	defffa04 	addi	sp,sp,-24
 32104a8:	dd000415 	stw	r20,16(sp)
 32104ac:	0500c974 	movhi	r20,805
 32104b0:	a50a6304 	addi	r20,r20,10636
 32104b4:	2007883a 	mov	r3,r4
 32104b8:	a1000017 	ldw	r4,0(r20)
 32104bc:	280d883a 	mov	r6,r5
 32104c0:	180b883a 	mov	r5,r3
 32104c4:	dfc00515 	stw	ra,20(sp)
 32104c8:	dcc00315 	stw	r19,12(sp)
 32104cc:	dc800215 	stw	r18,8(sp)
 32104d0:	dc400115 	stw	r17,4(sp)
 32104d4:	dc000015 	stw	r16,0(sp)
 32104d8:	320efc00 	call	320efc0 <_strtod_r>
 32104dc:	180b883a 	mov	r5,r3
 32104e0:	1009883a 	mov	r4,r2
 32104e4:	1823883a 	mov	r17,r3
 32104e8:	1021883a 	mov	r16,r2
 32104ec:	3213dc80 	call	3213dc8 <__truncdfsf2>
 32104f0:	1009883a 	mov	r4,r2
 32104f4:	000b883a 	mov	r5,zero
 32104f8:	1025883a 	mov	r18,r2
 32104fc:	1027883a 	mov	r19,r2
 3210500:	3212c400 	call	3212c40 <__nesf2>
 3210504:	000d883a 	mov	r6,zero
 3210508:	000f883a 	mov	r7,zero
 321050c:	8009883a 	mov	r4,r16
 3210510:	880b883a 	mov	r5,r17
 3210514:	10000e1e 	bne	r2,zero,3210550 <strtof+0xac>
 3210518:	32139500 	call	3213950 <__nedf2>
 321051c:	10000c26 	beq	r2,zero,3210550 <strtof+0xac>
 3210520:	a0c00017 	ldw	r3,0(r20)
 3210524:	00800884 	movi	r2,34
 3210528:	18800015 	stw	r2,0(r3)
 321052c:	9805883a 	mov	r2,r19
 3210530:	dfc00517 	ldw	ra,20(sp)
 3210534:	dd000417 	ldw	r20,16(sp)
 3210538:	dcc00317 	ldw	r19,12(sp)
 321053c:	dc800217 	ldw	r18,8(sp)
 3210540:	dc400117 	ldw	r17,4(sp)
 3210544:	dc000017 	ldw	r16,0(sp)
 3210548:	dec00604 	addi	sp,sp,24
 321054c:	f800283a 	ret
 3210550:	9009883a 	mov	r4,r18
 3210554:	015fe034 	movhi	r5,32640
 3210558:	297fffc4 	addi	r5,r5,-1
 321055c:	3212cb80 	call	3212cb8 <__gtsf2>
 3210560:	00ffffc4 	movi	r3,-1
 3210564:	011ffc34 	movhi	r4,32752
 3210568:	213fffc4 	addi	r4,r4,-1
 321056c:	200f883a 	mov	r7,r4
 3210570:	180d883a 	mov	r6,r3
 3210574:	8009883a 	mov	r4,r16
 3210578:	880b883a 	mov	r5,r17
 321057c:	00800f16 	blt	zero,r2,32105bc <strtof+0x118>
 3210580:	9009883a 	mov	r4,r18
 3210584:	017fe034 	movhi	r5,65408
 3210588:	297fffc4 	addi	r5,r5,-1
 321058c:	3212d300 	call	3212d30 <__ltsf2>
 3210590:	023fffc4 	movi	r8,-1
 3210594:	027ffc34 	movhi	r9,65520
 3210598:	4a7fffc4 	addi	r9,r9,-1
 321059c:	880b883a 	mov	r5,r17
 32105a0:	480f883a 	mov	r7,r9
 32105a4:	8009883a 	mov	r4,r16
 32105a8:	400d883a 	mov	r6,r8
 32105ac:	103fdf0e 	bge	r2,zero,321052c <strtof+0x88>
 32105b0:	3213ae80 	call	3213ae8 <__ltdf2>
 32105b4:	103fda0e 	bge	r2,zero,3210520 <strtof+0x7c>
 32105b8:	003fdc06 	br	321052c <strtof+0x88>
 32105bc:	32139d80 	call	32139d8 <__gtdf2>
 32105c0:	00bfd70e 	bge	zero,r2,3210520 <strtof+0x7c>
 32105c4:	003fee06 	br	3210580 <strtof+0xdc>

032105c8 <strtod>:
 32105c8:	0180c974 	movhi	r6,805
 32105cc:	318a6304 	addi	r6,r6,10636
 32105d0:	2007883a 	mov	r3,r4
 32105d4:	31000017 	ldw	r4,0(r6)
 32105d8:	280d883a 	mov	r6,r5
 32105dc:	180b883a 	mov	r5,r3
 32105e0:	320efc01 	jmpi	320efc0 <_strtod_r>

032105e4 <_strtol_r>:
 32105e4:	defff304 	addi	sp,sp,-52
 32105e8:	0080c974 	movhi	r2,805
 32105ec:	108a6204 	addi	r2,r2,10632
 32105f0:	dcc00615 	stw	r19,24(sp)
 32105f4:	14c00017 	ldw	r19,0(r2)
 32105f8:	ddc00a15 	stw	r23,40(sp)
 32105fc:	dc000315 	stw	r16,12(sp)
 3210600:	dfc00c15 	stw	ra,48(sp)
 3210604:	df000b15 	stw	fp,44(sp)
 3210608:	dd800915 	stw	r22,36(sp)
 321060c:	dd400815 	stw	r21,32(sp)
 3210610:	dd000715 	stw	r20,28(sp)
 3210614:	dc800515 	stw	r18,20(sp)
 3210618:	dc400415 	stw	r17,16(sp)
 321061c:	282f883a 	mov	r23,r5
 3210620:	d9000015 	stw	r4,0(sp)
 3210624:	d9800115 	stw	r6,4(sp)
 3210628:	2821883a 	mov	r16,r5
 321062c:	84400007 	ldb	r17,0(r16)
 3210630:	84000044 	addi	r16,r16,1
 3210634:	9c47883a 	add	r3,r19,r17
 3210638:	18800003 	ldbu	r2,0(r3)
 321063c:	1080020c 	andi	r2,r2,8
 3210640:	103ffa1e 	bne	r2,zero,321062c <_strtol_r+0x48>
 3210644:	00800b44 	movi	r2,45
 3210648:	88805c26 	beq	r17,r2,32107bc <_strtol_r+0x1d8>
 321064c:	00800ac4 	movi	r2,43
 3210650:	88805726 	beq	r17,r2,32107b0 <_strtol_r+0x1cc>
 3210654:	0039883a 	mov	fp,zero
 3210658:	3807003a 	cmpeq	r3,r7,zero
 321065c:	1800431e 	bne	r3,zero,321076c <_strtol_r+0x188>
 3210660:	00800404 	movi	r2,16
 3210664:	38804126 	beq	r7,r2,321076c <_strtol_r+0x188>
 3210668:	3829883a 	mov	r20,r7
 321066c:	e02cc03a 	cmpne	r22,fp,zero
 3210670:	b0004b1e 	bne	r22,zero,32107a0 <_strtol_r+0x1bc>
 3210674:	04a00034 	movhi	r18,32768
 3210678:	94bfffc4 	addi	r18,r18,-1
 321067c:	9009883a 	mov	r4,r18
 3210680:	a00b883a 	mov	r5,r20
 3210684:	d9c00215 	stw	r7,8(sp)
 3210688:	32047c80 	call	32047c8 <__umodsi3>
 321068c:	9009883a 	mov	r4,r18
 3210690:	a00b883a 	mov	r5,r20
 3210694:	102b883a 	mov	r21,r2
 3210698:	32047c00 	call	32047c0 <__udivsi3>
 321069c:	1011883a 	mov	r8,r2
 32106a0:	9c45883a 	add	r2,r19,r17
 32106a4:	11000003 	ldbu	r4,0(r2)
 32106a8:	000b883a 	mov	r5,zero
 32106ac:	000d883a 	mov	r6,zero
 32106b0:	20c0010c 	andi	r3,r4,4
 32106b4:	d9c00217 	ldw	r7,8(sp)
 32106b8:	18000e26 	beq	r3,zero,32106f4 <_strtol_r+0x110>
 32106bc:	88fff404 	addi	r3,r17,-48
 32106c0:	19c0140e 	bge	r3,r7,3210714 <_strtol_r+0x130>
 32106c4:	30003116 	blt	r6,zero,321078c <_strtol_r+0x1a8>
 32106c8:	41403036 	bltu	r8,r5,321078c <_strtol_r+0x1a8>
 32106cc:	2a002e26 	beq	r5,r8,3210788 <_strtol_r+0x1a4>
 32106d0:	2d05383a 	mul	r2,r5,r20
 32106d4:	01800044 	movi	r6,1
 32106d8:	10cb883a 	add	r5,r2,r3
 32106dc:	84400007 	ldb	r17,0(r16)
 32106e0:	84000044 	addi	r16,r16,1
 32106e4:	9c45883a 	add	r2,r19,r17
 32106e8:	11000003 	ldbu	r4,0(r2)
 32106ec:	20c0010c 	andi	r3,r4,4
 32106f0:	183ff21e 	bne	r3,zero,32106bc <_strtol_r+0xd8>
 32106f4:	208000cc 	andi	r2,r4,3
 32106f8:	10000626 	beq	r2,zero,3210714 <_strtol_r+0x130>
 32106fc:	2080004c 	andi	r2,r4,1
 3210700:	1005003a 	cmpeq	r2,r2,zero
 3210704:	1000231e 	bne	r2,zero,3210794 <_strtol_r+0x1b0>
 3210708:	00800dc4 	movi	r2,55
 321070c:	8887c83a 	sub	r3,r17,r2
 3210710:	19ffec16 	blt	r3,r7,32106c4 <_strtol_r+0xe0>
 3210714:	30002d16 	blt	r6,zero,32107cc <_strtol_r+0x1e8>
 3210718:	b000231e 	bne	r22,zero,32107a8 <_strtol_r+0x1c4>
 321071c:	2807883a 	mov	r3,r5
 3210720:	d8800117 	ldw	r2,4(sp)
 3210724:	10000426 	beq	r2,zero,3210738 <_strtol_r+0x154>
 3210728:	30000126 	beq	r6,zero,3210730 <_strtol_r+0x14c>
 321072c:	85ffffc4 	addi	r23,r16,-1
 3210730:	d9000117 	ldw	r4,4(sp)
 3210734:	25c00015 	stw	r23,0(r4)
 3210738:	1805883a 	mov	r2,r3
 321073c:	dfc00c17 	ldw	ra,48(sp)
 3210740:	df000b17 	ldw	fp,44(sp)
 3210744:	ddc00a17 	ldw	r23,40(sp)
 3210748:	dd800917 	ldw	r22,36(sp)
 321074c:	dd400817 	ldw	r21,32(sp)
 3210750:	dd000717 	ldw	r20,28(sp)
 3210754:	dcc00617 	ldw	r19,24(sp)
 3210758:	dc800517 	ldw	r18,20(sp)
 321075c:	dc400417 	ldw	r17,16(sp)
 3210760:	dc000317 	ldw	r16,12(sp)
 3210764:	dec00d04 	addi	sp,sp,52
 3210768:	f800283a 	ret
 321076c:	00800c04 	movi	r2,48
 3210770:	88801d26 	beq	r17,r2,32107e8 <_strtol_r+0x204>
 3210774:	183fbc26 	beq	r3,zero,3210668 <_strtol_r+0x84>
 3210778:	00800c04 	movi	r2,48
 321077c:	88802726 	beq	r17,r2,321081c <_strtol_r+0x238>
 3210780:	01c00284 	movi	r7,10
 3210784:	003fb806 	br	3210668 <_strtol_r+0x84>
 3210788:	a8ffd10e 	bge	r21,r3,32106d0 <_strtol_r+0xec>
 321078c:	01bfffc4 	movi	r6,-1
 3210790:	003fd206 	br	32106dc <_strtol_r+0xf8>
 3210794:	008015c4 	movi	r2,87
 3210798:	8887c83a 	sub	r3,r17,r2
 321079c:	003fdc06 	br	3210710 <_strtol_r+0x12c>
 32107a0:	04a00034 	movhi	r18,32768
 32107a4:	003fb506 	br	321067c <_strtol_r+0x98>
 32107a8:	0147c83a 	sub	r3,zero,r5
 32107ac:	003fdc06 	br	3210720 <_strtol_r+0x13c>
 32107b0:	84400007 	ldb	r17,0(r16)
 32107b4:	84000044 	addi	r16,r16,1
 32107b8:	003fa606 	br	3210654 <_strtol_r+0x70>
 32107bc:	84400007 	ldb	r17,0(r16)
 32107c0:	07000044 	movi	fp,1
 32107c4:	84000044 	addi	r16,r16,1
 32107c8:	003fa306 	br	3210658 <_strtol_r+0x74>
 32107cc:	e005003a 	cmpeq	r2,fp,zero
 32107d0:	10000f1e 	bne	r2,zero,3210810 <_strtol_r+0x22c>
 32107d4:	00e00034 	movhi	r3,32768
 32107d8:	d9000017 	ldw	r4,0(sp)
 32107dc:	00800884 	movi	r2,34
 32107e0:	20800015 	stw	r2,0(r4)
 32107e4:	003fce06 	br	3210720 <_strtol_r+0x13c>
 32107e8:	81000007 	ldb	r4,0(r16)
 32107ec:	00801e04 	movi	r2,120
 32107f0:	20800226 	beq	r4,r2,32107fc <_strtol_r+0x218>
 32107f4:	00801604 	movi	r2,88
 32107f8:	20bfde1e 	bne	r4,r2,3210774 <_strtol_r+0x190>
 32107fc:	84400047 	ldb	r17,1(r16)
 3210800:	01c00404 	movi	r7,16
 3210804:	84000084 	addi	r16,r16,2
 3210808:	3829883a 	mov	r20,r7
 321080c:	003f9706 	br	321066c <_strtol_r+0x88>
 3210810:	00e00034 	movhi	r3,32768
 3210814:	18ffffc4 	addi	r3,r3,-1
 3210818:	003fef06 	br	32107d8 <_strtol_r+0x1f4>
 321081c:	01c00204 	movi	r7,8
 3210820:	3829883a 	mov	r20,r7
 3210824:	003f9106 	br	321066c <_strtol_r+0x88>

03210828 <strtol>:
 3210828:	0080c974 	movhi	r2,805
 321082c:	108a6304 	addi	r2,r2,10636
 3210830:	2013883a 	mov	r9,r4
 3210834:	11000017 	ldw	r4,0(r2)
 3210838:	2805883a 	mov	r2,r5
 321083c:	300f883a 	mov	r7,r6
 3210840:	480b883a 	mov	r5,r9
 3210844:	100d883a 	mov	r6,r2
 3210848:	32105e41 	jmpi	32105e4 <_strtol_r>

0321084c <_strtoll_r>:
 321084c:	defff004 	addi	sp,sp,-64
 3210850:	0080c974 	movhi	r2,805
 3210854:	108a6204 	addi	r2,r2,10632
 3210858:	df000e15 	stw	fp,56(sp)
 321085c:	17000017 	ldw	fp,0(r2)
 3210860:	ddc00d15 	stw	r23,52(sp)
 3210864:	dd000a15 	stw	r20,40(sp)
 3210868:	dfc00f15 	stw	ra,60(sp)
 321086c:	dd800c15 	stw	r22,48(sp)
 3210870:	dd400b15 	stw	r21,44(sp)
 3210874:	dcc00915 	stw	r19,36(sp)
 3210878:	dc800815 	stw	r18,32(sp)
 321087c:	dc400715 	stw	r17,28(sp)
 3210880:	dc000615 	stw	r16,24(sp)
 3210884:	d9400315 	stw	r5,12(sp)
 3210888:	d9000215 	stw	r4,8(sp)
 321088c:	d9800415 	stw	r6,16(sp)
 3210890:	382f883a 	mov	r23,r7
 3210894:	2829883a 	mov	r20,r5
 3210898:	a4c00007 	ldb	r19,0(r20)
 321089c:	a5000044 	addi	r20,r20,1
 32108a0:	e4c7883a 	add	r3,fp,r19
 32108a4:	18800003 	ldbu	r2,0(r3)
 32108a8:	1080020c 	andi	r2,r2,8
 32108ac:	103ffa1e 	bne	r2,zero,3210898 <_strtoll_r+0x4c>
 32108b0:	00800b44 	movi	r2,45
 32108b4:	98808826 	beq	r19,r2,3210ad8 <_strtoll_r+0x28c>
 32108b8:	00800ac4 	movi	r2,43
 32108bc:	98808326 	beq	r19,r2,3210acc <_strtoll_r+0x280>
 32108c0:	d8000115 	stw	zero,4(sp)
 32108c4:	b807003a 	cmpeq	r3,r23,zero
 32108c8:	18005f1e 	bne	r3,zero,3210a48 <_strtoll_r+0x1fc>
 32108cc:	00800404 	movi	r2,16
 32108d0:	b8805d26 	beq	r23,r2,3210a48 <_strtoll_r+0x1fc>
 32108d4:	b82dd7fa 	srai	r22,r23,31
 32108d8:	b82b883a 	mov	r21,r23
 32108dc:	d8c00117 	ldw	r3,4(sp)
 32108e0:	1806c03a 	cmpne	r3,r3,zero
 32108e4:	d8c00515 	stw	r3,20(sp)
 32108e8:	1800631e 	bne	r3,zero,3210a78 <_strtoll_r+0x22c>
 32108ec:	043fffc4 	movi	r16,-1
 32108f0:	04600034 	movhi	r17,32768
 32108f4:	8c7fffc4 	addi	r17,r17,-1
 32108f8:	880b883a 	mov	r5,r17
 32108fc:	8009883a 	mov	r4,r16
 3210900:	a80d883a 	mov	r6,r21
 3210904:	b00f883a 	mov	r7,r22
 3210908:	32126900 	call	3212690 <__umoddi3>
 321090c:	880b883a 	mov	r5,r17
 3210910:	8009883a 	mov	r4,r16
 3210914:	b00f883a 	mov	r7,r22
 3210918:	a80d883a 	mov	r6,r21
 321091c:	d8800015 	stw	r2,0(sp)
 3210920:	32120b40 	call	32120b4 <__udivdi3>
 3210924:	1023883a 	mov	r17,r2
 3210928:	e4c5883a 	add	r2,fp,r19
 321092c:	11000003 	ldbu	r4,0(r2)
 3210930:	1825883a 	mov	r18,r3
 3210934:	0015883a 	mov	r10,zero
 3210938:	20c0010c 	andi	r3,r4,4
 321093c:	0017883a 	mov	r11,zero
 3210940:	000f883a 	mov	r7,zero
 3210944:	18001a26 	beq	r3,zero,32109b0 <_strtoll_r+0x164>
 3210948:	9c3ff404 	addi	r16,r19,-48
 321094c:	85c0200e 	bge	r16,r23,32109d0 <_strtoll_r+0x184>
 3210950:	38003b16 	blt	r7,zero,3210a40 <_strtoll_r+0x1f4>
 3210954:	92c03a36 	bltu	r18,r11,3210a40 <_strtoll_r+0x1f4>
 3210958:	5c803826 	beq	r11,r18,3210a3c <_strtoll_r+0x1f0>
 321095c:	54404c26 	beq	r10,r17,3210a90 <_strtoll_r+0x244>
 3210960:	580b883a 	mov	r5,r11
 3210964:	5009883a 	mov	r4,r10
 3210968:	a80d883a 	mov	r6,r21
 321096c:	b00f883a 	mov	r7,r22
 3210970:	3211f780 	call	3211f78 <__muldi3>
 3210974:	8013d7fa 	srai	r9,r16,31
 3210978:	100d883a 	mov	r6,r2
 321097c:	1405883a 	add	r2,r2,r16
 3210980:	118d803a 	cmpltu	r6,r2,r6
 3210984:	1a47883a 	add	r3,r3,r9
 3210988:	30cd883a 	add	r6,r6,r3
 321098c:	1015883a 	mov	r10,r2
 3210990:	3017883a 	mov	r11,r6
 3210994:	01c00044 	movi	r7,1
 3210998:	a4c00007 	ldb	r19,0(r20)
 321099c:	a5000044 	addi	r20,r20,1
 32109a0:	e4c5883a 	add	r2,fp,r19
 32109a4:	11000003 	ldbu	r4,0(r2)
 32109a8:	20c0010c 	andi	r3,r4,4
 32109ac:	183fe61e 	bne	r3,zero,3210948 <_strtoll_r+0xfc>
 32109b0:	208000cc 	andi	r2,r4,3
 32109b4:	10000626 	beq	r2,zero,32109d0 <_strtoll_r+0x184>
 32109b8:	2080004c 	andi	r2,r4,1
 32109bc:	1005003a 	cmpeq	r2,r2,zero
 32109c0:	1000301e 	bne	r2,zero,3210a84 <_strtoll_r+0x238>
 32109c4:	02000dc4 	movi	r8,55
 32109c8:	9a21c83a 	sub	r16,r19,r8
 32109cc:	85ffe016 	blt	r16,r23,3210950 <_strtoll_r+0x104>
 32109d0:	38004616 	blt	r7,zero,3210aec <_strtoll_r+0x2a0>
 32109d4:	d8800517 	ldw	r2,20(sp)
 32109d8:	1000341e 	bne	r2,zero,3210aac <_strtoll_r+0x260>
 32109dc:	500b883a 	mov	r5,r10
 32109e0:	580d883a 	mov	r6,r11
 32109e4:	d8c00417 	ldw	r3,16(sp)
 32109e8:	18000626 	beq	r3,zero,3210a04 <_strtoll_r+0x1b8>
 32109ec:	38000226 	beq	r7,zero,32109f8 <_strtoll_r+0x1ac>
 32109f0:	a53fffc4 	addi	r20,r20,-1
 32109f4:	dd000315 	stw	r20,12(sp)
 32109f8:	d8c00317 	ldw	r3,12(sp)
 32109fc:	d8800417 	ldw	r2,16(sp)
 3210a00:	10c00015 	stw	r3,0(r2)
 3210a04:	2805883a 	mov	r2,r5
 3210a08:	3007883a 	mov	r3,r6
 3210a0c:	dfc00f17 	ldw	ra,60(sp)
 3210a10:	df000e17 	ldw	fp,56(sp)
 3210a14:	ddc00d17 	ldw	r23,52(sp)
 3210a18:	dd800c17 	ldw	r22,48(sp)
 3210a1c:	dd400b17 	ldw	r21,44(sp)
 3210a20:	dd000a17 	ldw	r20,40(sp)
 3210a24:	dcc00917 	ldw	r19,36(sp)
 3210a28:	dc800817 	ldw	r18,32(sp)
 3210a2c:	dc400717 	ldw	r17,28(sp)
 3210a30:	dc000617 	ldw	r16,24(sp)
 3210a34:	dec01004 	addi	sp,sp,64
 3210a38:	f800283a 	ret
 3210a3c:	8abfc72e 	bgeu	r17,r10,321095c <_strtoll_r+0x110>
 3210a40:	01ffffc4 	movi	r7,-1
 3210a44:	003fd406 	br	3210998 <_strtoll_r+0x14c>
 3210a48:	00800c04 	movi	r2,48
 3210a4c:	98803226 	beq	r19,r2,3210b18 <_strtoll_r+0x2cc>
 3210a50:	183fa026 	beq	r3,zero,32108d4 <_strtoll_r+0x88>
 3210a54:	00800c04 	movi	r2,48
 3210a58:	98803e26 	beq	r19,r2,3210b54 <_strtoll_r+0x308>
 3210a5c:	d8c00117 	ldw	r3,4(sp)
 3210a60:	05c00284 	movi	r23,10
 3210a64:	b82b883a 	mov	r21,r23
 3210a68:	1806c03a 	cmpne	r3,r3,zero
 3210a6c:	002d883a 	mov	r22,zero
 3210a70:	d8c00515 	stw	r3,20(sp)
 3210a74:	183f9d26 	beq	r3,zero,32108ec <_strtoll_r+0xa0>
 3210a78:	0021883a 	mov	r16,zero
 3210a7c:	04600034 	movhi	r17,32768
 3210a80:	003f9d06 	br	32108f8 <_strtoll_r+0xac>
 3210a84:	020015c4 	movi	r8,87
 3210a88:	9a21c83a 	sub	r16,r19,r8
 3210a8c:	003fcf06 	br	32109cc <_strtoll_r+0x180>
 3210a90:	5cbfb31e 	bne	r11,r18,3210960 <_strtoll_r+0x114>
 3210a94:	d8800017 	ldw	r2,0(sp)
 3210a98:	143fb10e 	bge	r2,r16,3210960 <_strtoll_r+0x114>
 3210a9c:	8815883a 	mov	r10,r17
 3210aa0:	9017883a 	mov	r11,r18
 3210aa4:	01ffffc4 	movi	r7,-1
 3210aa8:	003fbb06 	br	3210998 <_strtoll_r+0x14c>
 3210aac:	0009883a 	mov	r4,zero
 3210ab0:	2285c83a 	sub	r2,r4,r10
 3210ab4:	2089803a 	cmpltu	r4,r4,r2
 3210ab8:	02c7c83a 	sub	r3,zero,r11
 3210abc:	1909c83a 	sub	r4,r3,r4
 3210ac0:	100b883a 	mov	r5,r2
 3210ac4:	200d883a 	mov	r6,r4
 3210ac8:	003fc606 	br	32109e4 <_strtoll_r+0x198>
 3210acc:	a4c00007 	ldb	r19,0(r20)
 3210ad0:	a5000044 	addi	r20,r20,1
 3210ad4:	003f7a06 	br	32108c0 <_strtoll_r+0x74>
 3210ad8:	a4c00007 	ldb	r19,0(r20)
 3210adc:	00800044 	movi	r2,1
 3210ae0:	a5000044 	addi	r20,r20,1
 3210ae4:	d8800115 	stw	r2,4(sp)
 3210ae8:	003f7606 	br	32108c4 <_strtoll_r+0x78>
 3210aec:	d8c00117 	ldw	r3,4(sp)
 3210af0:	1805003a 	cmpeq	r2,r3,zero
 3210af4:	1000131e 	bne	r2,zero,3210b44 <_strtoll_r+0x2f8>
 3210af8:	0005883a 	mov	r2,zero
 3210afc:	00e00034 	movhi	r3,32768
 3210b00:	100b883a 	mov	r5,r2
 3210b04:	180d883a 	mov	r6,r3
 3210b08:	d8c00217 	ldw	r3,8(sp)
 3210b0c:	00800884 	movi	r2,34
 3210b10:	18800015 	stw	r2,0(r3)
 3210b14:	003fb306 	br	32109e4 <_strtoll_r+0x198>
 3210b18:	a1000007 	ldb	r4,0(r20)
 3210b1c:	00801e04 	movi	r2,120
 3210b20:	20800226 	beq	r4,r2,3210b2c <_strtoll_r+0x2e0>
 3210b24:	00801604 	movi	r2,88
 3210b28:	20bfc91e 	bne	r4,r2,3210a50 <_strtoll_r+0x204>
 3210b2c:	a4c00047 	ldb	r19,1(r20)
 3210b30:	05c00404 	movi	r23,16
 3210b34:	b82b883a 	mov	r21,r23
 3210b38:	a5000084 	addi	r20,r20,2
 3210b3c:	002d883a 	mov	r22,zero
 3210b40:	003f6606 	br	32108dc <_strtoll_r+0x90>
 3210b44:	017fffc4 	movi	r5,-1
 3210b48:	01a00034 	movhi	r6,32768
 3210b4c:	31bfffc4 	addi	r6,r6,-1
 3210b50:	003fed06 	br	3210b08 <_strtoll_r+0x2bc>
 3210b54:	05c00204 	movi	r23,8
 3210b58:	b82b883a 	mov	r21,r23
 3210b5c:	002d883a 	mov	r22,zero
 3210b60:	003f5e06 	br	32108dc <_strtoll_r+0x90>

03210b64 <_strtoul_r>:
 3210b64:	defff604 	addi	sp,sp,-40
 3210b68:	0080c974 	movhi	r2,805
 3210b6c:	108a6204 	addi	r2,r2,10632
 3210b70:	dd000415 	stw	r20,16(sp)
 3210b74:	15000017 	ldw	r20,0(r2)
 3210b78:	ddc00715 	stw	r23,28(sp)
 3210b7c:	dd800615 	stw	r22,24(sp)
 3210b80:	dd400515 	stw	r21,20(sp)
 3210b84:	dc800215 	stw	r18,8(sp)
 3210b88:	dc000015 	stw	r16,0(sp)
 3210b8c:	dfc00915 	stw	ra,36(sp)
 3210b90:	df000815 	stw	fp,32(sp)
 3210b94:	dcc00315 	stw	r19,12(sp)
 3210b98:	dc400115 	stw	r17,4(sp)
 3210b9c:	282b883a 	mov	r21,r5
 3210ba0:	202f883a 	mov	r23,r4
 3210ba4:	302d883a 	mov	r22,r6
 3210ba8:	3825883a 	mov	r18,r7
 3210bac:	2821883a 	mov	r16,r5
 3210bb0:	84400007 	ldb	r17,0(r16)
 3210bb4:	84000044 	addi	r16,r16,1
 3210bb8:	a447883a 	add	r3,r20,r17
 3210bbc:	18800003 	ldbu	r2,0(r3)
 3210bc0:	1080020c 	andi	r2,r2,8
 3210bc4:	103ffa1e 	bne	r2,zero,3210bb0 <_strtoul_r+0x4c>
 3210bc8:	00800b44 	movi	r2,45
 3210bcc:	88805626 	beq	r17,r2,3210d28 <_strtoul_r+0x1c4>
 3210bd0:	00800ac4 	movi	r2,43
 3210bd4:	88805126 	beq	r17,r2,3210d1c <_strtoul_r+0x1b8>
 3210bd8:	0039883a 	mov	fp,zero
 3210bdc:	9007003a 	cmpeq	r3,r18,zero
 3210be0:	18003b1e 	bne	r3,zero,3210cd0 <_strtoul_r+0x16c>
 3210be4:	00800404 	movi	r2,16
 3210be8:	90803926 	beq	r18,r2,3210cd0 <_strtoul_r+0x16c>
 3210bec:	013fffc4 	movi	r4,-1
 3210bf0:	900b883a 	mov	r5,r18
 3210bf4:	32047c00 	call	32047c0 <__udivsi3>
 3210bf8:	013fffc4 	movi	r4,-1
 3210bfc:	900b883a 	mov	r5,r18
 3210c00:	1027883a 	mov	r19,r2
 3210c04:	32047c80 	call	32047c8 <__umodsi3>
 3210c08:	1011883a 	mov	r8,r2
 3210c0c:	900f883a 	mov	r7,r18
 3210c10:	a445883a 	add	r2,r20,r17
 3210c14:	11000003 	ldbu	r4,0(r2)
 3210c18:	000b883a 	mov	r5,zero
 3210c1c:	000d883a 	mov	r6,zero
 3210c20:	20c0010c 	andi	r3,r4,4
 3210c24:	18000e26 	beq	r3,zero,3210c60 <_strtoul_r+0xfc>
 3210c28:	88fff404 	addi	r3,r17,-48
 3210c2c:	1c80140e 	bge	r3,r18,3210c80 <_strtoul_r+0x11c>
 3210c30:	30003316 	blt	r6,zero,3210d00 <_strtoul_r+0x19c>
 3210c34:	99403236 	bltu	r19,r5,3210d00 <_strtoul_r+0x19c>
 3210c38:	2cc03026 	beq	r5,r19,3210cfc <_strtoul_r+0x198>
 3210c3c:	29c5383a 	mul	r2,r5,r7
 3210c40:	01800044 	movi	r6,1
 3210c44:	10cb883a 	add	r5,r2,r3
 3210c48:	84400007 	ldb	r17,0(r16)
 3210c4c:	84000044 	addi	r16,r16,1
 3210c50:	a445883a 	add	r2,r20,r17
 3210c54:	11000003 	ldbu	r4,0(r2)
 3210c58:	20c0010c 	andi	r3,r4,4
 3210c5c:	183ff21e 	bne	r3,zero,3210c28 <_strtoul_r+0xc4>
 3210c60:	208000cc 	andi	r2,r4,3
 3210c64:	10000626 	beq	r2,zero,3210c80 <_strtoul_r+0x11c>
 3210c68:	2080004c 	andi	r2,r4,1
 3210c6c:	1005003a 	cmpeq	r2,r2,zero
 3210c70:	1000251e 	bne	r2,zero,3210d08 <_strtoul_r+0x1a4>
 3210c74:	00800dc4 	movi	r2,55
 3210c78:	8887c83a 	sub	r3,r17,r2
 3210c7c:	1cbfec16 	blt	r3,r18,3210c30 <_strtoul_r+0xcc>
 3210c80:	3000400e 	bge	r6,zero,3210d84 <_strtoul_r+0x220>
 3210c84:	00800884 	movi	r2,34
 3210c88:	017fffc4 	movi	r5,-1
 3210c8c:	b8800015 	stw	r2,0(r23)
 3210c90:	b0000226 	beq	r22,zero,3210c9c <_strtoul_r+0x138>
 3210c94:	30001f1e 	bne	r6,zero,3210d14 <_strtoul_r+0x1b0>
 3210c98:	b5400015 	stw	r21,0(r22)
 3210c9c:	2805883a 	mov	r2,r5
 3210ca0:	dfc00917 	ldw	ra,36(sp)
 3210ca4:	df000817 	ldw	fp,32(sp)
 3210ca8:	ddc00717 	ldw	r23,28(sp)
 3210cac:	dd800617 	ldw	r22,24(sp)
 3210cb0:	dd400517 	ldw	r21,20(sp)
 3210cb4:	dd000417 	ldw	r20,16(sp)
 3210cb8:	dcc00317 	ldw	r19,12(sp)
 3210cbc:	dc800217 	ldw	r18,8(sp)
 3210cc0:	dc400117 	ldw	r17,4(sp)
 3210cc4:	dc000017 	ldw	r16,0(sp)
 3210cc8:	dec00a04 	addi	sp,sp,40
 3210ccc:	f800283a 	ret
 3210cd0:	00800c04 	movi	r2,48
 3210cd4:	88801826 	beq	r17,r2,3210d38 <_strtoul_r+0x1d4>
 3210cd8:	183fc426 	beq	r3,zero,3210bec <_strtoul_r+0x88>
 3210cdc:	00800c04 	movi	r2,48
 3210ce0:	88802226 	beq	r17,r2,3210d6c <_strtoul_r+0x208>
 3210ce4:	04800284 	movi	r18,10
 3210ce8:	900f883a 	mov	r7,r18
 3210cec:	04c666b4 	movhi	r19,6554
 3210cf0:	9ce66644 	addi	r19,r19,-26215
 3210cf4:	02000144 	movi	r8,5
 3210cf8:	003fc506 	br	3210c10 <_strtoul_r+0xac>
 3210cfc:	40ffcf0e 	bge	r8,r3,3210c3c <_strtoul_r+0xd8>
 3210d00:	01bfffc4 	movi	r6,-1
 3210d04:	003fd006 	br	3210c48 <_strtoul_r+0xe4>
 3210d08:	008015c4 	movi	r2,87
 3210d0c:	8887c83a 	sub	r3,r17,r2
 3210d10:	003fda06 	br	3210c7c <_strtoul_r+0x118>
 3210d14:	857fffc4 	addi	r21,r16,-1
 3210d18:	003fdf06 	br	3210c98 <_strtoul_r+0x134>
 3210d1c:	84400007 	ldb	r17,0(r16)
 3210d20:	84000044 	addi	r16,r16,1
 3210d24:	003fac06 	br	3210bd8 <_strtoul_r+0x74>
 3210d28:	84400007 	ldb	r17,0(r16)
 3210d2c:	07000044 	movi	fp,1
 3210d30:	84000044 	addi	r16,r16,1
 3210d34:	003fa906 	br	3210bdc <_strtoul_r+0x78>
 3210d38:	81000007 	ldb	r4,0(r16)
 3210d3c:	00801e04 	movi	r2,120
 3210d40:	20800226 	beq	r4,r2,3210d4c <_strtoul_r+0x1e8>
 3210d44:	00801604 	movi	r2,88
 3210d48:	20bfe31e 	bne	r4,r2,3210cd8 <_strtoul_r+0x174>
 3210d4c:	84400047 	ldb	r17,1(r16)
 3210d50:	04800404 	movi	r18,16
 3210d54:	84000084 	addi	r16,r16,2
 3210d58:	900f883a 	mov	r7,r18
 3210d5c:	04c40034 	movhi	r19,4096
 3210d60:	9cffffc4 	addi	r19,r19,-1
 3210d64:	020003c4 	movi	r8,15
 3210d68:	003fa906 	br	3210c10 <_strtoul_r+0xac>
 3210d6c:	04800204 	movi	r18,8
 3210d70:	900f883a 	mov	r7,r18
 3210d74:	04c80034 	movhi	r19,8192
 3210d78:	9cffffc4 	addi	r19,r19,-1
 3210d7c:	020001c4 	movi	r8,7
 3210d80:	003fa306 	br	3210c10 <_strtoul_r+0xac>
 3210d84:	e005003a 	cmpeq	r2,fp,zero
 3210d88:	103fc11e 	bne	r2,zero,3210c90 <_strtoul_r+0x12c>
 3210d8c:	014bc83a 	sub	r5,zero,r5
 3210d90:	003fbf06 	br	3210c90 <_strtoul_r+0x12c>

03210d94 <strtoul>:
 3210d94:	0080c974 	movhi	r2,805
 3210d98:	108a6304 	addi	r2,r2,10636
 3210d9c:	2013883a 	mov	r9,r4
 3210da0:	11000017 	ldw	r4,0(r2)
 3210da4:	2805883a 	mov	r2,r5
 3210da8:	300f883a 	mov	r7,r6
 3210dac:	480b883a 	mov	r5,r9
 3210db0:	100d883a 	mov	r6,r2
 3210db4:	3210b641 	jmpi	3210b64 <_strtoul_r>

03210db8 <_strtoull_r>:
 3210db8:	defff104 	addi	sp,sp,-60
 3210dbc:	0080c974 	movhi	r2,805
 3210dc0:	108a6204 	addi	r2,r2,10632
 3210dc4:	df000d15 	stw	fp,52(sp)
 3210dc8:	17000017 	ldw	fp,0(r2)
 3210dcc:	ddc00c15 	stw	r23,48(sp)
 3210dd0:	dcc00815 	stw	r19,32(sp)
 3210dd4:	dfc00e15 	stw	ra,56(sp)
 3210dd8:	dd800b15 	stw	r22,44(sp)
 3210ddc:	dd400a15 	stw	r21,40(sp)
 3210de0:	dd000915 	stw	r20,36(sp)
 3210de4:	dc800715 	stw	r18,28(sp)
 3210de8:	dc400615 	stw	r17,24(sp)
 3210dec:	dc000515 	stw	r16,20(sp)
 3210df0:	d9400215 	stw	r5,8(sp)
 3210df4:	d9000115 	stw	r4,4(sp)
 3210df8:	d9800315 	stw	r6,12(sp)
 3210dfc:	382f883a 	mov	r23,r7
 3210e00:	2827883a 	mov	r19,r5
 3210e04:	9d000007 	ldb	r20,0(r19)
 3210e08:	9cc00044 	addi	r19,r19,1
 3210e0c:	e507883a 	add	r3,fp,r20
 3210e10:	18800003 	ldbu	r2,0(r3)
 3210e14:	1080020c 	andi	r2,r2,8
 3210e18:	103ffa1e 	bne	r2,zero,3210e04 <_strtoull_r+0x4c>
 3210e1c:	00800b44 	movi	r2,45
 3210e20:	a0807a26 	beq	r20,r2,321100c <_strtoull_r+0x254>
 3210e24:	00800ac4 	movi	r2,43
 3210e28:	a0807526 	beq	r20,r2,3211000 <_strtoull_r+0x248>
 3210e2c:	d8000015 	stw	zero,0(sp)
 3210e30:	b807003a 	cmpeq	r3,r23,zero
 3210e34:	18005a1e 	bne	r3,zero,3210fa0 <_strtoull_r+0x1e8>
 3210e38:	00800404 	movi	r2,16
 3210e3c:	b8805826 	beq	r23,r2,3210fa0 <_strtoull_r+0x1e8>
 3210e40:	b82dd7fa 	srai	r22,r23,31
 3210e44:	043fffc4 	movi	r16,-1
 3210e48:	8009883a 	mov	r4,r16
 3210e4c:	800b883a 	mov	r5,r16
 3210e50:	b80d883a 	mov	r6,r23
 3210e54:	b00f883a 	mov	r7,r22
 3210e58:	32120b40 	call	32120b4 <__udivdi3>
 3210e5c:	8009883a 	mov	r4,r16
 3210e60:	800b883a 	mov	r5,r16
 3210e64:	b80d883a 	mov	r6,r23
 3210e68:	b00f883a 	mov	r7,r22
 3210e6c:	1023883a 	mov	r17,r2
 3210e70:	1825883a 	mov	r18,r3
 3210e74:	32126900 	call	3212690 <__umoddi3>
 3210e78:	b82b883a 	mov	r21,r23
 3210e7c:	1019883a 	mov	r12,r2
 3210e80:	e505883a 	add	r2,fp,r20
 3210e84:	11000003 	ldbu	r4,0(r2)
 3210e88:	0015883a 	mov	r10,zero
 3210e8c:	0017883a 	mov	r11,zero
 3210e90:	20c0010c 	andi	r3,r4,4
 3210e94:	000d883a 	mov	r6,zero
 3210e98:	18001c26 	beq	r3,zero,3210f0c <_strtoull_r+0x154>
 3210e9c:	a43ff404 	addi	r16,r20,-48
 3210ea0:	85c0220e 	bge	r16,r23,3210f2c <_strtoull_r+0x174>
 3210ea4:	30003c16 	blt	r6,zero,3210f98 <_strtoull_r+0x1e0>
 3210ea8:	92c03b36 	bltu	r18,r11,3210f98 <_strtoull_r+0x1e0>
 3210eac:	5c803926 	beq	r11,r18,3210f94 <_strtoull_r+0x1dc>
 3210eb0:	54404c26 	beq	r10,r17,3210fe4 <_strtoull_r+0x22c>
 3210eb4:	580b883a 	mov	r5,r11
 3210eb8:	5009883a 	mov	r4,r10
 3210ebc:	a80d883a 	mov	r6,r21
 3210ec0:	b00f883a 	mov	r7,r22
 3210ec4:	db000415 	stw	r12,16(sp)
 3210ec8:	3211f780 	call	3211f78 <__muldi3>
 3210ecc:	8013d7fa 	srai	r9,r16,31
 3210ed0:	100d883a 	mov	r6,r2
 3210ed4:	1405883a 	add	r2,r2,r16
 3210ed8:	118d803a 	cmpltu	r6,r2,r6
 3210edc:	1a47883a 	add	r3,r3,r9
 3210ee0:	db000417 	ldw	r12,16(sp)
 3210ee4:	30cd883a 	add	r6,r6,r3
 3210ee8:	3017883a 	mov	r11,r6
 3210eec:	1015883a 	mov	r10,r2
 3210ef0:	01800044 	movi	r6,1
 3210ef4:	9d000007 	ldb	r20,0(r19)
 3210ef8:	9cc00044 	addi	r19,r19,1
 3210efc:	e505883a 	add	r2,fp,r20
 3210f00:	11000003 	ldbu	r4,0(r2)
 3210f04:	20c0010c 	andi	r3,r4,4
 3210f08:	183fe41e 	bne	r3,zero,3210e9c <_strtoull_r+0xe4>
 3210f0c:	208000cc 	andi	r2,r4,3
 3210f10:	10000626 	beq	r2,zero,3210f2c <_strtoull_r+0x174>
 3210f14:	2080004c 	andi	r2,r4,1
 3210f18:	1005003a 	cmpeq	r2,r2,zero
 3210f1c:	10002e1e 	bne	r2,zero,3210fd8 <_strtoull_r+0x220>
 3210f20:	02000dc4 	movi	r8,55
 3210f24:	a221c83a 	sub	r16,r20,r8
 3210f28:	85ffde16 	blt	r16,r23,3210ea4 <_strtoull_r+0xec>
 3210f2c:	3000530e 	bge	r6,zero,321107c <_strtoull_r+0x2c4>
 3210f30:	d8c00117 	ldw	r3,4(sp)
 3210f34:	02bfffc4 	movi	r10,-1
 3210f38:	00800884 	movi	r2,34
 3210f3c:	5017883a 	mov	r11,r10
 3210f40:	18800015 	stw	r2,0(r3)
 3210f44:	d8800317 	ldw	r2,12(sp)
 3210f48:	10000426 	beq	r2,zero,3210f5c <_strtoull_r+0x1a4>
 3210f4c:	3000291e 	bne	r6,zero,3210ff4 <_strtoull_r+0x23c>
 3210f50:	d8800217 	ldw	r2,8(sp)
 3210f54:	d8c00317 	ldw	r3,12(sp)
 3210f58:	18800015 	stw	r2,0(r3)
 3210f5c:	5005883a 	mov	r2,r10
 3210f60:	5807883a 	mov	r3,r11
 3210f64:	dfc00e17 	ldw	ra,56(sp)
 3210f68:	df000d17 	ldw	fp,52(sp)
 3210f6c:	ddc00c17 	ldw	r23,48(sp)
 3210f70:	dd800b17 	ldw	r22,44(sp)
 3210f74:	dd400a17 	ldw	r21,40(sp)
 3210f78:	dd000917 	ldw	r20,36(sp)
 3210f7c:	dcc00817 	ldw	r19,32(sp)
 3210f80:	dc800717 	ldw	r18,28(sp)
 3210f84:	dc400617 	ldw	r17,24(sp)
 3210f88:	dc000517 	ldw	r16,20(sp)
 3210f8c:	dec00f04 	addi	sp,sp,60
 3210f90:	f800283a 	ret
 3210f94:	8abfc62e 	bgeu	r17,r10,3210eb0 <_strtoull_r+0xf8>
 3210f98:	01bfffc4 	movi	r6,-1
 3210f9c:	003fd506 	br	3210ef4 <_strtoull_r+0x13c>
 3210fa0:	00800c04 	movi	r2,48
 3210fa4:	a0801e26 	beq	r20,r2,3211020 <_strtoull_r+0x268>
 3210fa8:	183fa526 	beq	r3,zero,3210e40 <_strtoull_r+0x88>
 3210fac:	00800c04 	movi	r2,48
 3210fb0:	a0802a26 	beq	r20,r2,321105c <_strtoull_r+0x2a4>
 3210fb4:	05c00284 	movi	r23,10
 3210fb8:	b82b883a 	mov	r21,r23
 3210fbc:	046666b4 	movhi	r17,39322
 3210fc0:	8c666644 	addi	r17,r17,-26215
 3210fc4:	002d883a 	mov	r22,zero
 3210fc8:	048666b4 	movhi	r18,6554
 3210fcc:	94a66644 	addi	r18,r18,-26215
 3210fd0:	03000144 	movi	r12,5
 3210fd4:	003faa06 	br	3210e80 <_strtoull_r+0xc8>
 3210fd8:	020015c4 	movi	r8,87
 3210fdc:	a221c83a 	sub	r16,r20,r8
 3210fe0:	003fd106 	br	3210f28 <_strtoull_r+0x170>
 3210fe4:	5cbfb31e 	bne	r11,r18,3210eb4 <_strtoull_r+0xfc>
 3210fe8:	643fb20e 	bge	r12,r16,3210eb4 <_strtoull_r+0xfc>
 3210fec:	01bfffc4 	movi	r6,-1
 3210ff0:	003fc006 	br	3210ef4 <_strtoull_r+0x13c>
 3210ff4:	9cffffc4 	addi	r19,r19,-1
 3210ff8:	dcc00215 	stw	r19,8(sp)
 3210ffc:	003fd406 	br	3210f50 <_strtoull_r+0x198>
 3211000:	9d000007 	ldb	r20,0(r19)
 3211004:	9cc00044 	addi	r19,r19,1
 3211008:	003f8806 	br	3210e2c <_strtoull_r+0x74>
 321100c:	9d000007 	ldb	r20,0(r19)
 3211010:	00800044 	movi	r2,1
 3211014:	9cc00044 	addi	r19,r19,1
 3211018:	d8800015 	stw	r2,0(sp)
 321101c:	003f8406 	br	3210e30 <_strtoull_r+0x78>
 3211020:	99000007 	ldb	r4,0(r19)
 3211024:	00801e04 	movi	r2,120
 3211028:	20800226 	beq	r4,r2,3211034 <_strtoull_r+0x27c>
 321102c:	00801604 	movi	r2,88
 3211030:	20bfdd1e 	bne	r4,r2,3210fa8 <_strtoull_r+0x1f0>
 3211034:	9d000047 	ldb	r20,1(r19)
 3211038:	05c00404 	movi	r23,16
 321103c:	b82b883a 	mov	r21,r23
 3211040:	047fffc4 	movi	r17,-1
 3211044:	9cc00084 	addi	r19,r19,2
 3211048:	002d883a 	mov	r22,zero
 321104c:	04840034 	movhi	r18,4096
 3211050:	94bfffc4 	addi	r18,r18,-1
 3211054:	030003c4 	movi	r12,15
 3211058:	003f8906 	br	3210e80 <_strtoull_r+0xc8>
 321105c:	05c00204 	movi	r23,8
 3211060:	b82b883a 	mov	r21,r23
 3211064:	047fffc4 	movi	r17,-1
 3211068:	002d883a 	mov	r22,zero
 321106c:	04880034 	movhi	r18,8192
 3211070:	94bfffc4 	addi	r18,r18,-1
 3211074:	030001c4 	movi	r12,7
 3211078:	003f8106 	br	3210e80 <_strtoull_r+0xc8>
 321107c:	d8c00017 	ldw	r3,0(sp)
 3211080:	1805003a 	cmpeq	r2,r3,zero
 3211084:	103faf1e 	bne	r2,zero,3210f44 <_strtoull_r+0x18c>
 3211088:	0009883a 	mov	r4,zero
 321108c:	2285c83a 	sub	r2,r4,r10
 3211090:	02c7c83a 	sub	r3,zero,r11
 3211094:	2089803a 	cmpltu	r4,r4,r2
 3211098:	1909c83a 	sub	r4,r3,r4
 321109c:	1015883a 	mov	r10,r2
 32110a0:	2017883a 	mov	r11,r4
 32110a4:	003fa706 	br	3210f44 <_strtoull_r+0x18c>

032110a8 <__submore>:
 32110a8:	defffa04 	addi	sp,sp,-24
 32110ac:	28c00c17 	ldw	r3,48(r5)
 32110b0:	dc800215 	stw	r18,8(sp)
 32110b4:	2825883a 	mov	r18,r5
 32110b8:	dc000015 	stw	r16,0(sp)
 32110bc:	90801004 	addi	r2,r18,64
 32110c0:	04010004 	movi	r16,1024
 32110c4:	dfc00515 	stw	ra,20(sp)
 32110c8:	dd000415 	stw	r20,16(sp)
 32110cc:	dcc00315 	stw	r19,12(sp)
 32110d0:	dc400115 	stw	r17,4(sp)
 32110d4:	800b883a 	mov	r5,r16
 32110d8:	18801b26 	beq	r3,r2,3211148 <__submore+0xa0>
 32110dc:	94400d17 	ldw	r17,52(r18)
 32110e0:	180b883a 	mov	r5,r3
 32110e4:	8c69883a 	add	r20,r17,r17
 32110e8:	a00d883a 	mov	r6,r20
 32110ec:	320711c0 	call	320711c <_realloc_r>
 32110f0:	1467883a 	add	r19,r2,r17
 32110f4:	1021883a 	mov	r16,r2
 32110f8:	880d883a 	mov	r6,r17
 32110fc:	9809883a 	mov	r4,r19
 3211100:	100b883a 	mov	r5,r2
 3211104:	10000e26 	beq	r2,zero,3211140 <__submore+0x98>
 3211108:	3206ad00 	call	3206ad0 <memcpy>
 321110c:	000d883a 	mov	r6,zero
 3211110:	95000d15 	stw	r20,52(r18)
 3211114:	94c00015 	stw	r19,0(r18)
 3211118:	94000c15 	stw	r16,48(r18)
 321111c:	3005883a 	mov	r2,r6
 3211120:	dfc00517 	ldw	ra,20(sp)
 3211124:	dd000417 	ldw	r20,16(sp)
 3211128:	dcc00317 	ldw	r19,12(sp)
 321112c:	dc800217 	ldw	r18,8(sp)
 3211130:	dc400117 	ldw	r17,4(sp)
 3211134:	dc000017 	ldw	r16,0(sp)
 3211138:	dec00604 	addi	sp,sp,24
 321113c:	f800283a 	ret
 3211140:	01bfffc4 	movi	r6,-1
 3211144:	003ff506 	br	321111c <__submore+0x74>
 3211148:	32062ac0 	call	32062ac <_malloc_r>
 321114c:	1009883a 	mov	r4,r2
 3211150:	1140ff44 	addi	r5,r2,1021
 3211154:	000d883a 	mov	r6,zero
 3211158:	103ff926 	beq	r2,zero,3211140 <__submore+0x98>
 321115c:	90801083 	ldbu	r2,66(r18)
 3211160:	94000d15 	stw	r16,52(r18)
 3211164:	91000c15 	stw	r4,48(r18)
 3211168:	28800085 	stb	r2,2(r5)
 321116c:	90c01043 	ldbu	r3,65(r18)
 3211170:	28c00045 	stb	r3,1(r5)
 3211174:	90801003 	ldbu	r2,64(r18)
 3211178:	2080ff45 	stb	r2,1021(r4)
 321117c:	91400015 	stw	r5,0(r18)
 3211180:	003fe606 	br	321111c <__submore+0x74>

03211184 <_ungetc_r>:
 3211184:	defffc04 	addi	sp,sp,-16
 3211188:	00bfffc4 	movi	r2,-1
 321118c:	dc400215 	stw	r17,8(sp)
 3211190:	dc000115 	stw	r16,4(sp)
 3211194:	dfc00315 	stw	ra,12(sp)
 3211198:	2821883a 	mov	r16,r5
 321119c:	2023883a 	mov	r17,r4
 32111a0:	28801826 	beq	r5,r2,3211204 <_ungetc_r+0x80>
 32111a4:	20000226 	beq	r4,zero,32111b0 <_ungetc_r+0x2c>
 32111a8:	20800e17 	ldw	r2,56(r4)
 32111ac:	10001b26 	beq	r2,zero,321121c <_ungetc_r+0x98>
 32111b0:	3100030b 	ldhu	r4,12(r6)
 32111b4:	00bff7c4 	movi	r2,-33
 32111b8:	2084703a 	and	r2,r4,r2
 32111bc:	117fffcc 	andi	r5,r2,65535
 32111c0:	28c0010c 	andi	r3,r5,4
 32111c4:	1009883a 	mov	r4,r2
 32111c8:	3080030d 	sth	r2,12(r6)
 32111cc:	18003526 	beq	r3,zero,32112a4 <_ungetc_r+0x120>
 32111d0:	30800c17 	ldw	r2,48(r6)
 32111d4:	84003fcc 	andi	r16,r16,255
 32111d8:	10001426 	beq	r2,zero,321122c <_ungetc_r+0xa8>
 32111dc:	30c00117 	ldw	r3,4(r6)
 32111e0:	30800d17 	ldw	r2,52(r6)
 32111e4:	1880380e 	bge	r3,r2,32112c8 <_ungetc_r+0x144>
 32111e8:	30c00017 	ldw	r3,0(r6)
 32111ec:	19ffffc4 	addi	r7,r3,-1
 32111f0:	31c00015 	stw	r7,0(r6)
 32111f4:	1c3fffc5 	stb	r16,-1(r3)
 32111f8:	30800117 	ldw	r2,4(r6)
 32111fc:	10800044 	addi	r2,r2,1
 3211200:	30800115 	stw	r2,4(r6)
 3211204:	8005883a 	mov	r2,r16
 3211208:	dfc00317 	ldw	ra,12(sp)
 321120c:	dc400217 	ldw	r17,8(sp)
 3211210:	dc000117 	ldw	r16,4(sp)
 3211214:	dec00404 	addi	sp,sp,16
 3211218:	f800283a 	ret
 321121c:	d9800015 	stw	r6,0(sp)
 3211220:	3204b8c0 	call	3204b8c <__sinit>
 3211224:	d9800017 	ldw	r6,0(sp)
 3211228:	003fe106 	br	32111b0 <_ungetc_r+0x2c>
 321122c:	30800417 	ldw	r2,16(r6)
 3211230:	10002326 	beq	r2,zero,32112c0 <_ungetc_r+0x13c>
 3211234:	31c00017 	ldw	r7,0(r6)
 3211238:	11c0022e 	bgeu	r2,r7,3211244 <_ungetc_r+0xc0>
 321123c:	38bfffc3 	ldbu	r2,-1(r7)
 3211240:	80801226 	beq	r16,r2,321128c <_ungetc_r+0x108>
 3211244:	30c00117 	ldw	r3,4(r6)
 3211248:	00800044 	movi	r2,1
 321124c:	30800115 	stw	r2,4(r6)
 3211250:	008000c4 	movi	r2,3
 3211254:	31001004 	addi	r4,r6,64
 3211258:	31401084 	addi	r5,r6,66
 321125c:	30800d15 	stw	r2,52(r6)
 3211260:	8005883a 	mov	r2,r16
 3211264:	30c00f15 	stw	r3,60(r6)
 3211268:	31c00e15 	stw	r7,56(r6)
 321126c:	31000c15 	stw	r4,48(r6)
 3211270:	31400015 	stw	r5,0(r6)
 3211274:	34001085 	stb	r16,66(r6)
 3211278:	dfc00317 	ldw	ra,12(sp)
 321127c:	dc400217 	ldw	r17,8(sp)
 3211280:	dc000117 	ldw	r16,4(sp)
 3211284:	dec00404 	addi	sp,sp,16
 3211288:	f800283a 	ret
 321128c:	30800117 	ldw	r2,4(r6)
 3211290:	39ffffc4 	addi	r7,r7,-1
 3211294:	31c00015 	stw	r7,0(r6)
 3211298:	10800044 	addi	r2,r2,1
 321129c:	30800115 	stw	r2,4(r6)
 32112a0:	003fd806 	br	3211204 <_ungetc_r+0x80>
 32112a4:	2880040c 	andi	r2,r5,16
 32112a8:	10000d26 	beq	r2,zero,32112e0 <_ungetc_r+0x15c>
 32112ac:	2880020c 	andi	r2,r5,8
 32112b0:	10000d1e 	bne	r2,zero,32112e8 <_ungetc_r+0x164>
 32112b4:	20800114 	ori	r2,r4,4
 32112b8:	3080030d 	sth	r2,12(r6)
 32112bc:	003fc406 	br	32111d0 <_ungetc_r+0x4c>
 32112c0:	31c00017 	ldw	r7,0(r6)
 32112c4:	003fdf06 	br	3211244 <_ungetc_r+0xc0>
 32112c8:	300b883a 	mov	r5,r6
 32112cc:	8809883a 	mov	r4,r17
 32112d0:	d9800015 	stw	r6,0(sp)
 32112d4:	32110a80 	call	32110a8 <__submore>
 32112d8:	d9800017 	ldw	r6,0(sp)
 32112dc:	103fc226 	beq	r2,zero,32111e8 <_ungetc_r+0x64>
 32112e0:	043fffc4 	movi	r16,-1
 32112e4:	003fc706 	br	3211204 <_ungetc_r+0x80>
 32112e8:	300b883a 	mov	r5,r6
 32112ec:	8809883a 	mov	r4,r17
 32112f0:	d9800015 	stw	r6,0(sp)
 32112f4:	32048f40 	call	32048f4 <_fflush_r>
 32112f8:	d9800017 	ldw	r6,0(sp)
 32112fc:	103ff81e 	bne	r2,zero,32112e0 <_ungetc_r+0x15c>
 3211300:	3100030b 	ldhu	r4,12(r6)
 3211304:	00bffdc4 	movi	r2,-9
 3211308:	30000215 	stw	zero,8(r6)
 321130c:	2084703a 	and	r2,r4,r2
 3211310:	1009883a 	mov	r4,r2
 3211314:	3080030d 	sth	r2,12(r6)
 3211318:	30000615 	stw	zero,24(r6)
 321131c:	003fe506 	br	32112b4 <_ungetc_r+0x130>

03211320 <ungetc>:
 3211320:	0180c974 	movhi	r6,805
 3211324:	318a6304 	addi	r6,r6,10636
 3211328:	2007883a 	mov	r3,r4
 321132c:	31000017 	ldw	r4,0(r6)
 3211330:	280d883a 	mov	r6,r5
 3211334:	180b883a 	mov	r5,r3
 3211338:	32111841 	jmpi	3211184 <_ungetc_r>

0321133c <_calloc_r>:
 321133c:	298b383a 	mul	r5,r5,r6
 3211340:	defffe04 	addi	sp,sp,-8
 3211344:	dc000015 	stw	r16,0(sp)
 3211348:	dfc00115 	stw	ra,4(sp)
 321134c:	32062ac0 	call	32062ac <_malloc_r>
 3211350:	1021883a 	mov	r16,r2
 3211354:	01c00904 	movi	r7,36
 3211358:	10000d26 	beq	r2,zero,3211390 <_calloc_r+0x54>
 321135c:	10ffff17 	ldw	r3,-4(r2)
 3211360:	1009883a 	mov	r4,r2
 3211364:	00bfff04 	movi	r2,-4
 3211368:	1886703a 	and	r3,r3,r2
 321136c:	1887883a 	add	r3,r3,r2
 3211370:	180d883a 	mov	r6,r3
 3211374:	000b883a 	mov	r5,zero
 3211378:	38c01736 	bltu	r7,r3,32113d8 <_calloc_r+0x9c>
 321137c:	008004c4 	movi	r2,19
 3211380:	10c00836 	bltu	r2,r3,32113a4 <_calloc_r+0x68>
 3211384:	20000215 	stw	zero,8(r4)
 3211388:	20000015 	stw	zero,0(r4)
 321138c:	20000115 	stw	zero,4(r4)
 3211390:	8005883a 	mov	r2,r16
 3211394:	dfc00117 	ldw	ra,4(sp)
 3211398:	dc000017 	ldw	r16,0(sp)
 321139c:	dec00204 	addi	sp,sp,8
 32113a0:	f800283a 	ret
 32113a4:	008006c4 	movi	r2,27
 32113a8:	80000015 	stw	zero,0(r16)
 32113ac:	80000115 	stw	zero,4(r16)
 32113b0:	81000204 	addi	r4,r16,8
 32113b4:	10fff32e 	bgeu	r2,r3,3211384 <_calloc_r+0x48>
 32113b8:	80000215 	stw	zero,8(r16)
 32113bc:	80000315 	stw	zero,12(r16)
 32113c0:	81000404 	addi	r4,r16,16
 32113c4:	19ffef1e 	bne	r3,r7,3211384 <_calloc_r+0x48>
 32113c8:	81000604 	addi	r4,r16,24
 32113cc:	80000415 	stw	zero,16(r16)
 32113d0:	80000515 	stw	zero,20(r16)
 32113d4:	003feb06 	br	3211384 <_calloc_r+0x48>
 32113d8:	3206c500 	call	3206c50 <memset>
 32113dc:	8005883a 	mov	r2,r16
 32113e0:	dfc00117 	ldw	ra,4(sp)
 32113e4:	dc000017 	ldw	r16,0(sp)
 32113e8:	dec00204 	addi	sp,sp,8
 32113ec:	f800283a 	ret

032113f0 <htinit>:
 32113f0:	28800003 	ldbu	r2,0(r5)
 32113f4:	10000626 	beq	r2,zero,3211410 <htinit+0x20>
 32113f8:	1105883a 	add	r2,r2,r4
 32113fc:	11800005 	stb	r6,0(r2)
 3211400:	28800043 	ldbu	r2,1(r5)
 3211404:	31800044 	addi	r6,r6,1
 3211408:	29400044 	addi	r5,r5,1
 321140c:	103ffa1e 	bne	r2,zero,32113f8 <htinit+0x8>
 3211410:	f800283a 	ret

03211414 <__hexdig_init>:
 3211414:	defffd04 	addi	sp,sp,-12
 3211418:	dc400015 	stw	r17,0(sp)
 321141c:	0440c9b4 	movhi	r17,806
 3211420:	8c65b704 	addi	r17,r17,-26916
 3211424:	dcc00115 	stw	r19,4(sp)
 3211428:	8809883a 	mov	r4,r17
 321142c:	04c00684 	movi	r19,26
 3211430:	0140c974 	movhi	r5,805
 3211434:	29792a04 	addi	r5,r5,-7000
 3211438:	01800404 	movi	r6,16
 321143c:	dfc00215 	stw	ra,8(sp)
 3211440:	32113f00 	call	32113f0 <htinit>
 3211444:	980d883a 	mov	r6,r19
 3211448:	8809883a 	mov	r4,r17
 321144c:	0140c974 	movhi	r5,805
 3211450:	29792d04 	addi	r5,r5,-6988
 3211454:	32113f00 	call	32113f0 <htinit>
 3211458:	8809883a 	mov	r4,r17
 321145c:	980d883a 	mov	r6,r19
 3211460:	0140c974 	movhi	r5,805
 3211464:	29792f04 	addi	r5,r5,-6980
 3211468:	dfc00217 	ldw	ra,8(sp)
 321146c:	dcc00117 	ldw	r19,4(sp)
 3211470:	dc400017 	ldw	r17,0(sp)
 3211474:	dec00304 	addi	sp,sp,12
 3211478:	32113f01 	jmpi	32113f0 <htinit>

0321147c <rshift>:
 321147c:	2807d17a 	srai	r3,r5,5
 3211480:	20800417 	ldw	r2,16(r4)
 3211484:	22400504 	addi	r9,r4,20
 3211488:	480f883a 	mov	r7,r9
 321148c:	1880190e 	bge	r3,r2,32114f4 <rshift+0x78>
 3211490:	1085883a 	add	r2,r2,r2
 3211494:	18c7883a 	add	r3,r3,r3
 3211498:	1085883a 	add	r2,r2,r2
 321149c:	18c7883a 	add	r3,r3,r3
 32114a0:	294007cc 	andi	r5,r5,31
 32114a4:	4891883a 	add	r8,r9,r2
 32114a8:	48cd883a 	add	r6,r9,r3
 32114ac:	28001726 	beq	r5,zero,321150c <rshift+0x90>
 32114b0:	30c00017 	ldw	r3,0(r6)
 32114b4:	00800804 	movi	r2,32
 32114b8:	31800104 	addi	r6,r6,4
 32114bc:	1155c83a 	sub	r10,r2,r5
 32114c0:	1946d83a 	srl	r3,r3,r5
 32114c4:	3200092e 	bgeu	r6,r8,32114ec <rshift+0x70>
 32114c8:	30800017 	ldw	r2,0(r6)
 32114cc:	1284983a 	sll	r2,r2,r10
 32114d0:	10c4b03a 	or	r2,r2,r3
 32114d4:	38800015 	stw	r2,0(r7)
 32114d8:	30c00017 	ldw	r3,0(r6)
 32114dc:	31800104 	addi	r6,r6,4
 32114e0:	39c00104 	addi	r7,r7,4
 32114e4:	1946d83a 	srl	r3,r3,r5
 32114e8:	323ff736 	bltu	r6,r8,32114c8 <rshift+0x4c>
 32114ec:	38c00015 	stw	r3,0(r7)
 32114f0:	18000c1e 	bne	r3,zero,3211524 <rshift+0xa8>
 32114f4:	3a45c83a 	sub	r2,r7,r9
 32114f8:	1005d0ba 	srai	r2,r2,2
 32114fc:	20800415 	stw	r2,16(r4)
 3211500:	1000011e 	bne	r2,zero,3211508 <rshift+0x8c>
 3211504:	20000515 	stw	zero,20(r4)
 3211508:	f800283a 	ret
 321150c:	323ff92e 	bgeu	r6,r8,32114f4 <rshift+0x78>
 3211510:	30800017 	ldw	r2,0(r6)
 3211514:	31800104 	addi	r6,r6,4
 3211518:	38800015 	stw	r2,0(r7)
 321151c:	39c00104 	addi	r7,r7,4
 3211520:	003ffa06 	br	321150c <rshift+0x90>
 3211524:	39c00104 	addi	r7,r7,4
 3211528:	003ff206 	br	32114f4 <rshift+0x78>

0321152c <__gethex>:
 321152c:	defff304 	addi	sp,sp,-52
 3211530:	dd400815 	stw	r21,32(sp)
 3211534:	dd000715 	stw	r20,28(sp)
 3211538:	dcc00615 	stw	r19,24(sp)
 321153c:	dc400415 	stw	r17,16(sp)
 3211540:	dfc00c15 	stw	ra,48(sp)
 3211544:	df000b15 	stw	fp,44(sp)
 3211548:	ddc00a15 	stw	r23,40(sp)
 321154c:	dd800915 	stw	r22,36(sp)
 3211550:	dc800515 	stw	r18,20(sp)
 3211554:	dc000315 	stw	r16,12(sp)
 3211558:	0440c9b4 	movhi	r17,806
 321155c:	8c65b704 	addi	r17,r17,-26916
 3211560:	88800c03 	ldbu	r2,48(r17)
 3211564:	202b883a 	mov	r21,r4
 3211568:	2827883a 	mov	r19,r5
 321156c:	3029883a 	mov	r20,r6
 3211570:	d9c00115 	stw	r7,4(sp)
 3211574:	10006e26 	beq	r2,zero,3211730 <__gethex+0x204>
 3211578:	99800017 	ldw	r6,0(r19)
 321157c:	00800c04 	movi	r2,48
 3211580:	31000083 	ldbu	r4,2(r6)
 3211584:	30c00084 	addi	r3,r6,2
 3211588:	20806f1e 	bne	r4,r2,3211748 <__gethex+0x21c>
 321158c:	200b883a 	mov	r5,r4
 3211590:	3007883a 	mov	r3,r6
 3211594:	188000c3 	ldbu	r2,3(r3)
 3211598:	18c00044 	addi	r3,r3,1
 321159c:	1009883a 	mov	r4,r2
 32115a0:	117ffc26 	beq	r2,r5,3211594 <__gethex+0x68>
 32115a4:	1997c83a 	sub	r11,r3,r6
 32115a8:	19400084 	addi	r5,r3,2
 32115ac:	2445883a 	add	r2,r4,r17
 32115b0:	10c00003 	ldbu	r3,0(r2)
 32115b4:	18002d26 	beq	r3,zero,321166c <__gethex+0x140>
 32115b8:	29000003 	ldbu	r4,0(r5)
 32115bc:	2825883a 	mov	r18,r5
 32115c0:	000d883a 	mov	r6,zero
 32115c4:	0013883a 	mov	r9,zero
 32115c8:	21003fcc 	andi	r4,r4,255
 32115cc:	2445883a 	add	r2,r4,r17
 32115d0:	10c00003 	ldbu	r3,0(r2)
 32115d4:	18000526 	beq	r3,zero,32115ec <__gethex+0xc0>
 32115d8:	29400044 	addi	r5,r5,1
 32115dc:	29000003 	ldbu	r4,0(r5)
 32115e0:	2445883a 	add	r2,r4,r17
 32115e4:	10c00003 	ldbu	r3,0(r2)
 32115e8:	183ffb1e 	bne	r3,zero,32115d8 <__gethex+0xac>
 32115ec:	00800b84 	movi	r2,46
 32115f0:	20805826 	beq	r4,r2,3211754 <__gethex+0x228>
 32115f4:	30007a26 	beq	r6,zero,32117e0 <__gethex+0x2b4>
 32115f8:	2985c83a 	sub	r2,r5,r6
 32115fc:	1085883a 	add	r2,r2,r2
 3211600:	1085883a 	add	r2,r2,r2
 3211604:	00adc83a 	sub	r22,zero,r2
 3211608:	2821883a 	mov	r16,r5
 321160c:	80c00003 	ldbu	r3,0(r16)
 3211610:	00801404 	movi	r2,80
 3211614:	18801e26 	beq	r3,r2,3211690 <__gethex+0x164>
 3211618:	00801c04 	movi	r2,112
 321161c:	18801c26 	beq	r3,r2,3211690 <__gethex+0x164>
 3211620:	800d883a 	mov	r6,r16
 3211624:	4805003a 	cmpeq	r2,r9,zero
 3211628:	99800015 	stw	r6,0(r19)
 321162c:	1000861e 	bne	r2,zero,3211848 <__gethex+0x31c>
 3211630:	58003d26 	beq	r11,zero,3211728 <__gethex+0x1fc>
 3211634:	0025883a 	mov	r18,zero
 3211638:	9005883a 	mov	r2,r18
 321163c:	dfc00c17 	ldw	ra,48(sp)
 3211640:	df000b17 	ldw	fp,44(sp)
 3211644:	ddc00a17 	ldw	r23,40(sp)
 3211648:	dd800917 	ldw	r22,36(sp)
 321164c:	dd400817 	ldw	r21,32(sp)
 3211650:	dd000717 	ldw	r20,28(sp)
 3211654:	dcc00617 	ldw	r19,24(sp)
 3211658:	dc800517 	ldw	r18,20(sp)
 321165c:	dc400417 	ldw	r17,16(sp)
 3211660:	dc000317 	ldw	r16,12(sp)
 3211664:	dec00d04 	addi	sp,sp,52
 3211668:	f800283a 	ret
 321166c:	00800b84 	movi	r2,46
 3211670:	20804a26 	beq	r4,r2,321179c <__gethex+0x270>
 3211674:	2821883a 	mov	r16,r5
 3211678:	80c00003 	ldbu	r3,0(r16)
 321167c:	00801404 	movi	r2,80
 3211680:	2825883a 	mov	r18,r5
 3211684:	02400044 	movi	r9,1
 3211688:	002d883a 	mov	r22,zero
 321168c:	18bfe21e 	bne	r3,r2,3211618 <__gethex+0xec>
 3211690:	80c00043 	ldbu	r3,1(r16)
 3211694:	00800ac4 	movi	r2,43
 3211698:	81000044 	addi	r4,r16,1
 321169c:	18804a26 	beq	r3,r2,32117c8 <__gethex+0x29c>
 32116a0:	00800b44 	movi	r2,45
 32116a4:	18804c26 	beq	r3,r2,32117d8 <__gethex+0x2ac>
 32116a8:	0015883a 	mov	r10,zero
 32116ac:	1c45883a 	add	r2,r3,r17
 32116b0:	10800003 	ldbu	r2,0(r2)
 32116b4:	103fda26 	beq	r2,zero,3211620 <__gethex+0xf4>
 32116b8:	02000644 	movi	r8,25
 32116bc:	40bfd816 	blt	r8,r2,3211620 <__gethex+0xf4>
 32116c0:	20c00043 	ldbu	r3,1(r4)
 32116c4:	11fffc04 	addi	r7,r2,-16
 32116c8:	0080c9b4 	movhi	r2,806
 32116cc:	10a5b704 	addi	r2,r2,-26916
 32116d0:	1887883a 	add	r3,r3,r2
 32116d4:	18800003 	ldbu	r2,0(r3)
 32116d8:	21800044 	addi	r6,r4,1
 32116dc:	10000d26 	beq	r2,zero,3211714 <__gethex+0x1e8>
 32116e0:	100b883a 	mov	r5,r2
 32116e4:	4080020e 	bge	r8,r2,32116f0 <__gethex+0x1c4>
 32116e8:	00000a06 	br	3211714 <__gethex+0x1e8>
 32116ec:	41000916 	blt	r8,r4,3211714 <__gethex+0x1e8>
 32116f0:	31800044 	addi	r6,r6,1
 32116f4:	30800003 	ldbu	r2,0(r6)
 32116f8:	38c002a4 	muli	r3,r7,10
 32116fc:	1445883a 	add	r2,r2,r17
 3211700:	11000003 	ldbu	r4,0(r2)
 3211704:	1947883a 	add	r3,r3,r5
 3211708:	19fffc04 	addi	r7,r3,-16
 321170c:	200b883a 	mov	r5,r4
 3211710:	203ff61e 	bne	r4,zero,32116ec <__gethex+0x1c0>
 3211714:	5005003a 	cmpeq	r2,r10,zero
 3211718:	1000011e 	bne	r2,zero,3211720 <__gethex+0x1f4>
 321171c:	01cfc83a 	sub	r7,zero,r7
 3211720:	b1ed883a 	add	r22,r22,r7
 3211724:	003fbf06 	br	3211624 <__gethex+0xf8>
 3211728:	04800184 	movi	r18,6
 321172c:	003fc206 	br	3211638 <__gethex+0x10c>
 3211730:	32114140 	call	3211414 <__hexdig_init>
 3211734:	99800017 	ldw	r6,0(r19)
 3211738:	00800c04 	movi	r2,48
 321173c:	31000083 	ldbu	r4,2(r6)
 3211740:	30c00084 	addi	r3,r6,2
 3211744:	20bf9126 	beq	r4,r2,321158c <__gethex+0x60>
 3211748:	180b883a 	mov	r5,r3
 321174c:	0017883a 	mov	r11,zero
 3211750:	003f9606 	br	32115ac <__gethex+0x80>
 3211754:	303fa81e 	bne	r6,zero,32115f8 <__gethex+0xcc>
 3211758:	29400044 	addi	r5,r5,1
 321175c:	28800003 	ldbu	r2,0(r5)
 3211760:	1445883a 	add	r2,r2,r17
 3211764:	10c00003 	ldbu	r3,0(r2)
 3211768:	1800ad26 	beq	r3,zero,3211a20 <__gethex+0x4f4>
 321176c:	2809883a 	mov	r4,r5
 3211770:	21000044 	addi	r4,r4,1
 3211774:	20800003 	ldbu	r2,0(r4)
 3211778:	1445883a 	add	r2,r2,r17
 321177c:	10c00003 	ldbu	r3,0(r2)
 3211780:	183ffb1e 	bne	r3,zero,3211770 <__gethex+0x244>
 3211784:	2145c83a 	sub	r2,r4,r5
 3211788:	1085883a 	add	r2,r2,r2
 321178c:	1085883a 	add	r2,r2,r2
 3211790:	00adc83a 	sub	r22,zero,r2
 3211794:	200b883a 	mov	r5,r4
 3211798:	003f9b06 	br	3211608 <__gethex+0xdc>
 321179c:	29000043 	ldbu	r4,1(r5)
 32117a0:	0080c9b4 	movhi	r2,806
 32117a4:	10a5b704 	addi	r2,r2,-26916
 32117a8:	2c000044 	addi	r16,r5,1
 32117ac:	2085883a 	add	r2,r4,r2
 32117b0:	10c00003 	ldbu	r3,0(r2)
 32117b4:	18000d1e 	bne	r3,zero,32117ec <__gethex+0x2c0>
 32117b8:	2825883a 	mov	r18,r5
 32117bc:	02400044 	movi	r9,1
 32117c0:	002d883a 	mov	r22,zero
 32117c4:	003f9106 	br	321160c <__gethex+0xe0>
 32117c8:	0015883a 	mov	r10,zero
 32117cc:	21000044 	addi	r4,r4,1
 32117d0:	20c00003 	ldbu	r3,0(r4)
 32117d4:	003fb506 	br	32116ac <__gethex+0x180>
 32117d8:	02800044 	movi	r10,1
 32117dc:	003ffb06 	br	32117cc <__gethex+0x2a0>
 32117e0:	2821883a 	mov	r16,r5
 32117e4:	002d883a 	mov	r22,zero
 32117e8:	003f8806 	br	321160c <__gethex+0xe0>
 32117ec:	00800c04 	movi	r2,48
 32117f0:	20800e1e 	bne	r4,r2,321182c <__gethex+0x300>
 32117f4:	2007883a 	mov	r3,r4
 32117f8:	800b883a 	mov	r5,r16
 32117fc:	29400044 	addi	r5,r5,1
 3211800:	29000003 	ldbu	r4,0(r5)
 3211804:	20803fcc 	andi	r2,r4,255
 3211808:	10fffc26 	beq	r2,r3,32117fc <__gethex+0x2d0>
 321180c:	1445883a 	add	r2,r2,r17
 3211810:	10c00003 	ldbu	r3,0(r2)
 3211814:	1800071e 	bne	r3,zero,3211834 <__gethex+0x308>
 3211818:	02c00044 	movi	r11,1
 321181c:	800d883a 	mov	r6,r16
 3211820:	2825883a 	mov	r18,r5
 3211824:	5813883a 	mov	r9,r11
 3211828:	003f6706 	br	32115c8 <__gethex+0x9c>
 321182c:	81000003 	ldbu	r4,0(r16)
 3211830:	800b883a 	mov	r5,r16
 3211834:	800d883a 	mov	r6,r16
 3211838:	2825883a 	mov	r18,r5
 321183c:	02c00044 	movi	r11,1
 3211840:	0013883a 	mov	r9,zero
 3211844:	003f6006 	br	32115c8 <__gethex+0x9c>
 3211848:	8485c83a 	sub	r2,r16,r18
 321184c:	10bfffc4 	addi	r2,r2,-1
 3211850:	00c001c4 	movi	r3,7
 3211854:	1880700e 	bge	r3,r2,3211a18 <__gethex+0x4ec>
 3211858:	000b883a 	mov	r5,zero
 321185c:	1005d07a 	srai	r2,r2,1
 3211860:	29400044 	addi	r5,r5,1
 3211864:	18bffd16 	blt	r3,r2,321185c <__gethex+0x330>
 3211868:	a809883a 	mov	r4,r21
 321186c:	320e2980 	call	320e298 <_Balloc>
 3211870:	1027883a 	mov	r19,r2
 3211874:	10800504 	addi	r2,r2,20
 3211878:	d8800215 	stw	r2,8(sp)
 321187c:	9400522e 	bgeu	r18,r16,32119c8 <__gethex+0x49c>
 3211880:	da000217 	ldw	r8,8(sp)
 3211884:	800b883a 	mov	r5,r16
 3211888:	000f883a 	mov	r7,zero
 321188c:	0009883a 	mov	r4,zero
 3211890:	02400b84 	movi	r9,46
 3211894:	02800804 	movi	r10,32
 3211898:	297fffc4 	addi	r5,r5,-1
 321189c:	28c00003 	ldbu	r3,0(r5)
 32118a0:	1a400826 	beq	r3,r9,32118c4 <__gethex+0x398>
 32118a4:	380d883a 	mov	r6,r7
 32118a8:	3a802726 	beq	r7,r10,3211948 <__gethex+0x41c>
 32118ac:	39c00104 	addi	r7,r7,4
 32118b0:	1c47883a 	add	r3,r3,r17
 32118b4:	18800003 	ldbu	r2,0(r3)
 32118b8:	108003cc 	andi	r2,r2,15
 32118bc:	1184983a 	sll	r2,r2,r6
 32118c0:	2088b03a 	or	r4,r4,r2
 32118c4:	917ff436 	bltu	r18,r5,3211898 <__gethex+0x36c>
 32118c8:	d8c00217 	ldw	r3,8(sp)
 32118cc:	40800104 	addi	r2,r8,4
 32118d0:	41000015 	stw	r4,0(r8)
 32118d4:	10c5c83a 	sub	r2,r2,r3
 32118d8:	1021d0ba 	srai	r16,r2,2
 32118dc:	9c000415 	stw	r16,16(r19)
 32118e0:	320dd400 	call	320dd40 <__hi0bits>
 32118e4:	8006917a 	slli	r3,r16,5
 32118e8:	a5c00017 	ldw	r23,0(r20)
 32118ec:	1885c83a 	sub	r2,r3,r2
 32118f0:	b8801c16 	blt	r23,r2,3211964 <__gethex+0x438>
 32118f4:	15c00a16 	blt	r2,r23,3211920 <__gethex+0x3f4>
 32118f8:	0039883a 	mov	fp,zero
 32118fc:	a0800217 	ldw	r2,8(r20)
 3211900:	1580340e 	bge	r2,r22,32119d4 <__gethex+0x4a8>
 3211904:	a809883a 	mov	r4,r21
 3211908:	980b883a 	mov	r5,r19
 321190c:	320dd180 	call	320dd18 <_Bfree>
 3211910:	d8c00d17 	ldw	r3,52(sp)
 3211914:	048028c4 	movi	r18,163
 3211918:	18000015 	stw	zero,0(r3)
 321191c:	003f4606 	br	3211638 <__gethex+0x10c>
 3211920:	b8a1c83a 	sub	r16,r23,r2
 3211924:	980b883a 	mov	r5,r19
 3211928:	a809883a 	mov	r4,r21
 321192c:	800d883a 	mov	r6,r16
 3211930:	320e65c0 	call	320e65c <__lshift>
 3211934:	1027883a 	mov	r19,r2
 3211938:	b42dc83a 	sub	r22,r22,r16
 321193c:	10800504 	addi	r2,r2,20
 3211940:	d8800215 	stw	r2,8(sp)
 3211944:	003fec06 	br	32118f8 <__gethex+0x3cc>
 3211948:	41000015 	stw	r4,0(r8)
 321194c:	28c00003 	ldbu	r3,0(r5)
 3211950:	01c00104 	movi	r7,4
 3211954:	000d883a 	mov	r6,zero
 3211958:	41d1883a 	add	r8,r8,r7
 321195c:	0009883a 	mov	r4,zero
 3211960:	003fd306 	br	32118b0 <__gethex+0x384>
 3211964:	15e1c83a 	sub	r16,r2,r23
 3211968:	9809883a 	mov	r4,r19
 321196c:	800b883a 	mov	r5,r16
 3211970:	320e2100 	call	320e210 <__any_on>
 3211974:	1000061e 	bne	r2,zero,3211990 <__gethex+0x464>
 3211978:	0039883a 	mov	fp,zero
 321197c:	9809883a 	mov	r4,r19
 3211980:	800b883a 	mov	r5,r16
 3211984:	321147c0 	call	321147c <rshift>
 3211988:	b42d883a 	add	r22,r22,r16
 321198c:	003fdb06 	br	32118fc <__gethex+0x3d0>
 3211990:	817fffc4 	addi	r5,r16,-1
 3211994:	2805d17a 	srai	r2,r5,5
 3211998:	d8c00217 	ldw	r3,8(sp)
 321199c:	290007cc 	andi	r4,r5,31
 32119a0:	1085883a 	add	r2,r2,r2
 32119a4:	1085883a 	add	r2,r2,r2
 32119a8:	01800044 	movi	r6,1
 32119ac:	10c5883a 	add	r2,r2,r3
 32119b0:	3108983a 	sll	r4,r6,r4
 32119b4:	10c00017 	ldw	r3,0(r2)
 32119b8:	20c8703a 	and	r4,r4,r3
 32119bc:	20001a1e 	bne	r4,zero,3211a28 <__gethex+0x4fc>
 32119c0:	3039883a 	mov	fp,r6
 32119c4:	003fed06 	br	321197c <__gethex+0x450>
 32119c8:	1011883a 	mov	r8,r2
 32119cc:	0009883a 	mov	r4,zero
 32119d0:	003fbd06 	br	32118c8 <__gethex+0x39c>
 32119d4:	a1000117 	ldw	r4,4(r20)
 32119d8:	b1001a16 	blt	r22,r4,3211a44 <__gethex+0x518>
 32119dc:	04800044 	movi	r18,1
 32119e0:	e0000826 	beq	fp,zero,3211a04 <__gethex+0x4d8>
 32119e4:	a1000317 	ldw	r4,12(r20)
 32119e8:	00800084 	movi	r2,2
 32119ec:	20809426 	beq	r4,r2,3211c40 <__gethex+0x714>
 32119f0:	008000c4 	movi	r2,3
 32119f4:	20805826 	beq	r4,r2,3211b58 <__gethex+0x62c>
 32119f8:	00800044 	movi	r2,1
 32119fc:	20803f26 	beq	r4,r2,3211afc <__gethex+0x5d0>
 3211a00:	94800414 	ori	r18,r18,16
 3211a04:	d8800d17 	ldw	r2,52(sp)
 3211a08:	d8c00117 	ldw	r3,4(sp)
 3211a0c:	14c00015 	stw	r19,0(r2)
 3211a10:	1d800015 	stw	r22,0(r3)
 3211a14:	003f0806 	br	3211638 <__gethex+0x10c>
 3211a18:	000b883a 	mov	r5,zero
 3211a1c:	003f9206 	br	3211868 <__gethex+0x33c>
 3211a20:	002d883a 	mov	r22,zero
 3211a24:	003ef806 	br	3211608 <__gethex+0xdc>
 3211a28:	3140160e 	bge	r6,r5,3211a84 <__gethex+0x558>
 3211a2c:	9809883a 	mov	r4,r19
 3211a30:	817fff84 	addi	r5,r16,-2
 3211a34:	320e2100 	call	320e210 <__any_on>
 3211a38:	10001226 	beq	r2,zero,3211a84 <__gethex+0x558>
 3211a3c:	070000c4 	movi	fp,3
 3211a40:	003fce06 	br	321197c <__gethex+0x450>
 3211a44:	25a3c83a 	sub	r17,r4,r22
 3211a48:	8dc01016 	blt	r17,r23,3211a8c <__gethex+0x560>
 3211a4c:	a0c00317 	ldw	r3,12(r20)
 3211a50:	00800084 	movi	r2,2
 3211a54:	18809326 	beq	r3,r2,3211ca4 <__gethex+0x778>
 3211a58:	008000c4 	movi	r2,3
 3211a5c:	18808e26 	beq	r3,r2,3211c98 <__gethex+0x76c>
 3211a60:	00800044 	movi	r2,1
 3211a64:	18807b26 	beq	r3,r2,3211c54 <__gethex+0x728>
 3211a68:	a809883a 	mov	r4,r21
 3211a6c:	980b883a 	mov	r5,r19
 3211a70:	320dd180 	call	320dd18 <_Bfree>
 3211a74:	d8c00d17 	ldw	r3,52(sp)
 3211a78:	04801404 	movi	r18,80
 3211a7c:	18000015 	stw	zero,0(r3)
 3211a80:	003eed06 	br	3211638 <__gethex+0x10c>
 3211a84:	07000084 	movi	fp,2
 3211a88:	003fbc06 	br	321197c <__gethex+0x450>
 3211a8c:	8c3fffc4 	addi	r16,r17,-1
 3211a90:	e0001426 	beq	fp,zero,3211ae4 <__gethex+0x5b8>
 3211a94:	07000044 	movi	fp,1
 3211a98:	8005d17a 	srai	r2,r16,5
 3211a9c:	d8c00217 	ldw	r3,8(sp)
 3211aa0:	814007cc 	andi	r5,r16,31
 3211aa4:	1085883a 	add	r2,r2,r2
 3211aa8:	1085883a 	add	r2,r2,r2
 3211aac:	10c5883a 	add	r2,r2,r3
 3211ab0:	00c00044 	movi	r3,1
 3211ab4:	1946983a 	sll	r3,r3,r5
 3211ab8:	11000017 	ldw	r4,0(r2)
 3211abc:	1906703a 	and	r3,r3,r4
 3211ac0:	18000126 	beq	r3,zero,3211ac8 <__gethex+0x59c>
 3211ac4:	e7000094 	ori	fp,fp,2
 3211ac8:	880b883a 	mov	r5,r17
 3211acc:	9809883a 	mov	r4,r19
 3211ad0:	321147c0 	call	321147c <rshift>
 3211ad4:	a5800117 	ldw	r22,4(r20)
 3211ad8:	bc6fc83a 	sub	r23,r23,r17
 3211adc:	04800084 	movi	r18,2
 3211ae0:	003fbf06 	br	32119e0 <__gethex+0x4b4>
 3211ae4:	043fec0e 	bge	zero,r16,3211a98 <__gethex+0x56c>
 3211ae8:	9809883a 	mov	r4,r19
 3211aec:	800b883a 	mov	r5,r16
 3211af0:	320e2100 	call	320e210 <__any_on>
 3211af4:	1039883a 	mov	fp,r2
 3211af8:	003fe706 	br	3211a98 <__gethex+0x56c>
 3211afc:	e080008c 	andi	r2,fp,2
 3211b00:	103fbf26 	beq	r2,zero,3211a00 <__gethex+0x4d4>
 3211b04:	d8c00217 	ldw	r3,8(sp)
 3211b08:	18800017 	ldw	r2,0(r3)
 3211b0c:	e084b03a 	or	r2,fp,r2
 3211b10:	1104703a 	and	r2,r2,r4
 3211b14:	103fba26 	beq	r2,zero,3211a00 <__gethex+0x4d4>
 3211b18:	9c000417 	ldw	r16,16(r19)
 3211b1c:	d8c00217 	ldw	r3,8(sp)
 3211b20:	017fffc4 	movi	r5,-1
 3211b24:	8405883a 	add	r2,r16,r16
 3211b28:	10b9883a 	add	fp,r2,r2
 3211b2c:	1f09883a 	add	r4,r3,fp
 3211b30:	dc000015 	stw	r16,0(sp)
 3211b34:	00000306 	br	3211b44 <__gethex+0x618>
 3211b38:	18000015 	stw	zero,0(r3)
 3211b3c:	18c00104 	addi	r3,r3,4
 3211b40:	1900082e 	bgeu	r3,r4,3211b64 <__gethex+0x638>
 3211b44:	18800017 	ldw	r2,0(r3)
 3211b48:	117ffb26 	beq	r2,r5,3211b38 <__gethex+0x60c>
 3211b4c:	10800044 	addi	r2,r2,1
 3211b50:	18800015 	stw	r2,0(r3)
 3211b54:	00001f06 	br	3211bd4 <__gethex+0x6a8>
 3211b58:	d8800e17 	ldw	r2,56(sp)
 3211b5c:	103fa826 	beq	r2,zero,3211a00 <__gethex+0x4d4>
 3211b60:	003fed06 	br	3211b18 <__gethex+0x5ec>
 3211b64:	98800217 	ldw	r2,8(r19)
 3211b68:	80801316 	blt	r16,r2,3211bb8 <__gethex+0x68c>
 3211b6c:	99400117 	ldw	r5,4(r19)
 3211b70:	a809883a 	mov	r4,r21
 3211b74:	29400044 	addi	r5,r5,1
 3211b78:	320e2980 	call	320e298 <_Balloc>
 3211b7c:	99800417 	ldw	r6,16(r19)
 3211b80:	99400304 	addi	r5,r19,12
 3211b84:	11000304 	addi	r4,r2,12
 3211b88:	318d883a 	add	r6,r6,r6
 3211b8c:	318d883a 	add	r6,r6,r6
 3211b90:	31800204 	addi	r6,r6,8
 3211b94:	1023883a 	mov	r17,r2
 3211b98:	3206ad00 	call	3206ad0 <memcpy>
 3211b9c:	980b883a 	mov	r5,r19
 3211ba0:	a809883a 	mov	r4,r21
 3211ba4:	320dd180 	call	320dd18 <_Bfree>
 3211ba8:	8c000417 	ldw	r16,16(r17)
 3211bac:	88800504 	addi	r2,r17,20
 3211bb0:	8827883a 	mov	r19,r17
 3211bb4:	d8800215 	stw	r2,8(sp)
 3211bb8:	8405883a 	add	r2,r16,r16
 3211bbc:	1085883a 	add	r2,r2,r2
 3211bc0:	14c5883a 	add	r2,r2,r19
 3211bc4:	84000044 	addi	r16,r16,1
 3211bc8:	00c00044 	movi	r3,1
 3211bcc:	10c00515 	stw	r3,20(r2)
 3211bd0:	9c000415 	stw	r16,16(r19)
 3211bd4:	00800084 	movi	r2,2
 3211bd8:	90801426 	beq	r18,r2,3211c2c <__gethex+0x700>
 3211bdc:	d8800017 	ldw	r2,0(sp)
 3211be0:	14000b16 	blt	r2,r16,3211c10 <__gethex+0x6e4>
 3211be4:	bc0007cc 	andi	r16,r23,31
 3211be8:	8000021e 	bne	r16,zero,3211bf4 <__gethex+0x6c8>
 3211bec:	94800814 	ori	r18,r18,32
 3211bf0:	003f8406 	br	3211a04 <__gethex+0x4d8>
 3211bf4:	d8c00217 	ldw	r3,8(sp)
 3211bf8:	1f05883a 	add	r2,r3,fp
 3211bfc:	113fff17 	ldw	r4,-4(r2)
 3211c00:	320dd400 	call	320dd40 <__hi0bits>
 3211c04:	00c00804 	movi	r3,32
 3211c08:	1c07c83a 	sub	r3,r3,r16
 3211c0c:	10fff70e 	bge	r2,r3,3211bec <__gethex+0x6c0>
 3211c10:	9809883a 	mov	r4,r19
 3211c14:	01400044 	movi	r5,1
 3211c18:	321147c0 	call	321147c <rshift>
 3211c1c:	a0800217 	ldw	r2,8(r20)
 3211c20:	b5800044 	addi	r22,r22,1
 3211c24:	15bf3716 	blt	r2,r22,3211904 <__gethex+0x3d8>
 3211c28:	003ff006 	br	3211bec <__gethex+0x6c0>
 3211c2c:	a0800017 	ldw	r2,0(r20)
 3211c30:	10bfffc4 	addi	r2,r2,-1
 3211c34:	b8801e26 	beq	r23,r2,3211cb0 <__gethex+0x784>
 3211c38:	04800884 	movi	r18,34
 3211c3c:	003f7106 	br	3211a04 <__gethex+0x4d8>
 3211c40:	d8c00e17 	ldw	r3,56(sp)
 3211c44:	00800044 	movi	r2,1
 3211c48:	10c5c83a 	sub	r2,r2,r3
 3211c4c:	103f6c26 	beq	r2,zero,3211a00 <__gethex+0x4d4>
 3211c50:	003fb106 	br	3211b18 <__gethex+0x5ec>
 3211c54:	bc7f841e 	bne	r23,r17,3211a68 <__gethex+0x53c>
 3211c58:	1dc0050e 	bge	r3,r23,3211c70 <__gethex+0x744>
 3211c5c:	b8cbc83a 	sub	r5,r23,r3
 3211c60:	9809883a 	mov	r4,r19
 3211c64:	320e2100 	call	320e210 <__any_on>
 3211c68:	103f7f26 	beq	r2,zero,3211a68 <__gethex+0x53c>
 3211c6c:	a1000117 	ldw	r4,4(r20)
 3211c70:	d8800117 	ldw	r2,4(sp)
 3211c74:	d8c00217 	ldw	r3,8(sp)
 3211c78:	04000044 	movi	r16,1
 3211c7c:	11000015 	stw	r4,0(r2)
 3211c80:	d8800d17 	ldw	r2,52(sp)
 3211c84:	04801884 	movi	r18,98
 3211c88:	1c000015 	stw	r16,0(r3)
 3211c8c:	14c00015 	stw	r19,0(r2)
 3211c90:	9c000415 	stw	r16,16(r19)
 3211c94:	003e6806 	br	3211638 <__gethex+0x10c>
 3211c98:	d8c00e17 	ldw	r3,56(sp)
 3211c9c:	183f7226 	beq	r3,zero,3211a68 <__gethex+0x53c>
 3211ca0:	003ff306 	br	3211c70 <__gethex+0x744>
 3211ca4:	d8800e17 	ldw	r2,56(sp)
 3211ca8:	103ff126 	beq	r2,zero,3211c70 <__gethex+0x744>
 3211cac:	003f6e06 	br	3211a68 <__gethex+0x53c>
 3211cb0:	b805d17a 	srai	r2,r23,5
 3211cb4:	d8c00217 	ldw	r3,8(sp)
 3211cb8:	b94007cc 	andi	r5,r23,31
 3211cbc:	1085883a 	add	r2,r2,r2
 3211cc0:	1085883a 	add	r2,r2,r2
 3211cc4:	10c5883a 	add	r2,r2,r3
 3211cc8:	00c00044 	movi	r3,1
 3211ccc:	1946983a 	sll	r3,r3,r5
 3211cd0:	11000017 	ldw	r4,0(r2)
 3211cd4:	1906703a 	and	r3,r3,r4
 3211cd8:	183fd726 	beq	r3,zero,3211c38 <__gethex+0x70c>
 3211cdc:	04800844 	movi	r18,33
 3211ce0:	003f4806 	br	3211a04 <__gethex+0x4d8>

03211ce4 <L_shift>:
 3211ce4:	00800204 	movi	r2,8
 3211ce8:	1185c83a 	sub	r2,r2,r6
 3211cec:	1085883a 	add	r2,r2,r2
 3211cf0:	21c00017 	ldw	r7,0(r4)
 3211cf4:	1093883a 	add	r9,r2,r2
 3211cf8:	00800804 	movi	r2,32
 3211cfc:	200d883a 	mov	r6,r4
 3211d00:	1251c83a 	sub	r8,r2,r9
 3211d04:	31800104 	addi	r6,r6,4
 3211d08:	3805883a 	mov	r2,r7
 3211d0c:	31c00017 	ldw	r7,0(r6)
 3211d10:	3a08983a 	sll	r4,r7,r8
 3211d14:	3a46d83a 	srl	r3,r7,r9
 3211d18:	1104b03a 	or	r2,r2,r4
 3211d1c:	180f883a 	mov	r7,r3
 3211d20:	30bfff15 	stw	r2,-4(r6)
 3211d24:	30c00015 	stw	r3,0(r6)
 3211d28:	317ff636 	bltu	r6,r5,3211d04 <L_shift+0x20>
 3211d2c:	f800283a 	ret

03211d30 <__hexnan>:
 3211d30:	defff404 	addi	sp,sp,-48
 3211d34:	dd800815 	stw	r22,32(sp)
 3211d38:	0580c9b4 	movhi	r22,806
 3211d3c:	b5a5b704 	addi	r22,r22,-26916
 3211d40:	b0800c03 	ldbu	r2,48(r22)
 3211d44:	dcc00515 	stw	r19,20(sp)
 3211d48:	dc000215 	stw	r16,8(sp)
 3211d4c:	dfc00b15 	stw	ra,44(sp)
 3211d50:	df000a15 	stw	fp,40(sp)
 3211d54:	ddc00915 	stw	r23,36(sp)
 3211d58:	dd400715 	stw	r21,28(sp)
 3211d5c:	dd000615 	stw	r20,24(sp)
 3211d60:	dc800415 	stw	r18,16(sp)
 3211d64:	dc400315 	stw	r17,12(sp)
 3211d68:	d9000115 	stw	r4,4(sp)
 3211d6c:	2821883a 	mov	r16,r5
 3211d70:	3027883a 	mov	r19,r6
 3211d74:	10007426 	beq	r2,zero,3211f48 <__hexnan+0x218>
 3211d78:	80c00017 	ldw	r3,0(r16)
 3211d7c:	1805d17a 	srai	r2,r3,5
 3211d80:	18c007cc 	andi	r3,r3,31
 3211d84:	1839003a 	cmpeq	fp,r3,zero
 3211d88:	1085883a 	add	r2,r2,r2
 3211d8c:	1085883a 	add	r2,r2,r2
 3211d90:	d8c00015 	stw	r3,0(sp)
 3211d94:	14c5883a 	add	r2,r2,r19
 3211d98:	e000011e 	bne	fp,zero,3211da0 <__hexnan+0x70>
 3211d9c:	10800104 	addi	r2,r2,4
 3211da0:	d8c00117 	ldw	r3,4(sp)
 3211da4:	153fff04 	addi	r20,r2,-4
 3211da8:	a021883a 	mov	r16,r20
 3211dac:	1c400017 	ldw	r17,0(r3)
 3211db0:	a02b883a 	mov	r21,r20
 3211db4:	0025883a 	mov	r18,zero
 3211db8:	002f883a 	mov	r23,zero
 3211dbc:	000d883a 	mov	r6,zero
 3211dc0:	103fff15 	stw	zero,-4(r2)
 3211dc4:	8c400044 	addi	r17,r17,1
 3211dc8:	89000003 	ldbu	r4,0(r17)
 3211dcc:	20000e26 	beq	r4,zero,3211e08 <__hexnan+0xd8>
 3211dd0:	2585883a 	add	r2,r4,r22
 3211dd4:	10c00003 	ldbu	r3,0(r2)
 3211dd8:	18002e1e 	bne	r3,zero,3211e94 <__hexnan+0x164>
 3211ddc:	00800804 	movi	r2,32
 3211de0:	11005536 	bltu	r2,r4,3211f38 <__hexnan+0x208>
 3211de4:	bcbff70e 	bge	r23,r18,3211dc4 <__hexnan+0x94>
 3211de8:	8540022e 	bgeu	r16,r21,3211df4 <__hexnan+0xc4>
 3211dec:	008001c4 	movi	r2,7
 3211df0:	11803c0e 	bge	r2,r6,3211ee4 <__hexnan+0x1b4>
 3211df4:	9c003536 	bltu	r19,r16,3211ecc <__hexnan+0x19c>
 3211df8:	8c400044 	addi	r17,r17,1
 3211dfc:	89000003 	ldbu	r4,0(r17)
 3211e00:	01800204 	movi	r6,8
 3211e04:	203ff21e 	bne	r4,zero,3211dd0 <__hexnan+0xa0>
 3211e08:	90004d26 	beq	r18,zero,3211f40 <__hexnan+0x210>
 3211e0c:	85404336 	bltu	r16,r21,3211f1c <__hexnan+0x1ec>
 3211e10:	9c00382e 	bgeu	r19,r16,3211ef4 <__hexnan+0x1c4>
 3211e14:	9807883a 	mov	r3,r19
 3211e18:	80800017 	ldw	r2,0(r16)
 3211e1c:	84000104 	addi	r16,r16,4
 3211e20:	18800015 	stw	r2,0(r3)
 3211e24:	18c00104 	addi	r3,r3,4
 3211e28:	a43ffb2e 	bgeu	r20,r16,3211e18 <__hexnan+0xe8>
 3211e2c:	18000015 	stw	zero,0(r3)
 3211e30:	18c00104 	addi	r3,r3,4
 3211e34:	a0fffd2e 	bgeu	r20,r3,3211e2c <__hexnan+0xfc>
 3211e38:	a0800017 	ldw	r2,0(r20)
 3211e3c:	1000071e 	bne	r2,zero,3211e5c <__hexnan+0x12c>
 3211e40:	9d004326 	beq	r19,r20,3211f50 <__hexnan+0x220>
 3211e44:	a007883a 	mov	r3,r20
 3211e48:	00000106 	br	3211e50 <__hexnan+0x120>
 3211e4c:	98c04026 	beq	r19,r3,3211f50 <__hexnan+0x220>
 3211e50:	18ffff04 	addi	r3,r3,-4
 3211e54:	18800017 	ldw	r2,0(r3)
 3211e58:	103ffc26 	beq	r2,zero,3211e4c <__hexnan+0x11c>
 3211e5c:	00c00144 	movi	r3,5
 3211e60:	1805883a 	mov	r2,r3
 3211e64:	dfc00b17 	ldw	ra,44(sp)
 3211e68:	df000a17 	ldw	fp,40(sp)
 3211e6c:	ddc00917 	ldw	r23,36(sp)
 3211e70:	dd800817 	ldw	r22,32(sp)
 3211e74:	dd400717 	ldw	r21,28(sp)
 3211e78:	dd000617 	ldw	r20,24(sp)
 3211e7c:	dcc00517 	ldw	r19,20(sp)
 3211e80:	dc800417 	ldw	r18,16(sp)
 3211e84:	dc400317 	ldw	r17,12(sp)
 3211e88:	dc000217 	ldw	r16,8(sp)
 3211e8c:	dec00c04 	addi	sp,sp,48
 3211e90:	f800283a 	ret
 3211e94:	31800044 	addi	r6,r6,1
 3211e98:	00800204 	movi	r2,8
 3211e9c:	94800044 	addi	r18,r18,1
 3211ea0:	1180040e 	bge	r2,r6,3211eb4 <__hexnan+0x184>
 3211ea4:	9c3fc72e 	bgeu	r19,r16,3211dc4 <__hexnan+0x94>
 3211ea8:	843fff04 	addi	r16,r16,-4
 3211eac:	80000015 	stw	zero,0(r16)
 3211eb0:	01800044 	movi	r6,1
 3211eb4:	80800017 	ldw	r2,0(r16)
 3211eb8:	18c003cc 	andi	r3,r3,15
 3211ebc:	1004913a 	slli	r2,r2,4
 3211ec0:	10c4b03a 	or	r2,r2,r3
 3211ec4:	80800015 	stw	r2,0(r16)
 3211ec8:	003fbe06 	br	3211dc4 <__hexnan+0x94>
 3211ecc:	843fff04 	addi	r16,r16,-4
 3211ed0:	802b883a 	mov	r21,r16
 3211ed4:	902f883a 	mov	r23,r18
 3211ed8:	000d883a 	mov	r6,zero
 3211edc:	80000015 	stw	zero,0(r16)
 3211ee0:	003fb806 	br	3211dc4 <__hexnan+0x94>
 3211ee4:	8009883a 	mov	r4,r16
 3211ee8:	a80b883a 	mov	r5,r21
 3211eec:	3211ce40 	call	3211ce4 <L_shift>
 3211ef0:	003fc006 	br	3211df4 <__hexnan+0xc4>
 3211ef4:	e03fd01e 	bne	fp,zero,3211e38 <__hexnan+0x108>
 3211ef8:	d8c00017 	ldw	r3,0(sp)
 3211efc:	00800804 	movi	r2,32
 3211f00:	10c5c83a 	sub	r2,r2,r3
 3211f04:	00ffffc4 	movi	r3,-1
 3211f08:	1886d83a 	srl	r3,r3,r2
 3211f0c:	a0800017 	ldw	r2,0(r20)
 3211f10:	10c4703a 	and	r2,r2,r3
 3211f14:	a0800015 	stw	r2,0(r20)
 3211f18:	003fc806 	br	3211e3c <__hexnan+0x10c>
 3211f1c:	008001c4 	movi	r2,7
 3211f20:	11bfbb16 	blt	r2,r6,3211e10 <__hexnan+0xe0>
 3211f24:	a80b883a 	mov	r5,r21
 3211f28:	8009883a 	mov	r4,r16
 3211f2c:	3211ce40 	call	3211ce4 <L_shift>
 3211f30:	9c3ff02e 	bgeu	r19,r16,3211ef4 <__hexnan+0x1c4>
 3211f34:	003fb706 	br	3211e14 <__hexnan+0xe4>
 3211f38:	00800a44 	movi	r2,41
 3211f3c:	20800826 	beq	r4,r2,3211f60 <__hexnan+0x230>
 3211f40:	00c00104 	movi	r3,4
 3211f44:	003fc606 	br	3211e60 <__hexnan+0x130>
 3211f48:	32114140 	call	3211414 <__hexdig_init>
 3211f4c:	003f8a06 	br	3211d78 <__hexnan+0x48>
 3211f50:	00800044 	movi	r2,1
 3211f54:	00c00144 	movi	r3,5
 3211f58:	98800015 	stw	r2,0(r19)
 3211f5c:	003fc006 	br	3211e60 <__hexnan+0x130>
 3211f60:	903ff726 	beq	r18,zero,3211f40 <__hexnan+0x210>
 3211f64:	d8c00117 	ldw	r3,4(sp)
 3211f68:	88800044 	addi	r2,r17,1
 3211f6c:	18800015 	stw	r2,0(r3)
 3211f70:	857fa72e 	bgeu	r16,r21,3211e10 <__hexnan+0xe0>
 3211f74:	003fe906 	br	3211f1c <__hexnan+0x1ec>

03211f78 <__muldi3>:
 3211f78:	2011883a 	mov	r8,r4
 3211f7c:	427fffcc 	andi	r9,r8,65535
 3211f80:	4018d43a 	srli	r12,r8,16
 3211f84:	32bfffcc 	andi	r10,r6,65535
 3211f88:	3016d43a 	srli	r11,r6,16
 3211f8c:	4a85383a 	mul	r2,r9,r10
 3211f90:	6295383a 	mul	r10,r12,r10
 3211f94:	4ad3383a 	mul	r9,r9,r11
 3211f98:	113fffcc 	andi	r4,r2,65535
 3211f9c:	1004d43a 	srli	r2,r2,16
 3211fa0:	4a93883a 	add	r9,r9,r10
 3211fa4:	3807883a 	mov	r3,r7
 3211fa8:	1245883a 	add	r2,r2,r9
 3211fac:	280f883a 	mov	r7,r5
 3211fb0:	180b883a 	mov	r5,r3
 3211fb4:	1006943a 	slli	r3,r2,16
 3211fb8:	defffd04 	addi	sp,sp,-12
 3211fbc:	dc800215 	stw	r18,8(sp)
 3211fc0:	1907883a 	add	r3,r3,r4
 3211fc4:	dc400115 	stw	r17,4(sp)
 3211fc8:	dc000015 	stw	r16,0(sp)
 3211fcc:	4165383a 	mul	r18,r8,r5
 3211fd0:	31e3383a 	mul	r17,r6,r7
 3211fd4:	1012d43a 	srli	r9,r2,16
 3211fd8:	62d9383a 	mul	r12,r12,r11
 3211fdc:	181f883a 	mov	r15,r3
 3211fe0:	1280022e 	bgeu	r2,r10,3211fec <__muldi3+0x74>
 3211fe4:	00800074 	movhi	r2,1
 3211fe8:	6099883a 	add	r12,r12,r2
 3211fec:	624d883a 	add	r6,r12,r9
 3211ff0:	9187883a 	add	r3,r18,r6
 3211ff4:	88c7883a 	add	r3,r17,r3
 3211ff8:	7805883a 	mov	r2,r15
 3211ffc:	dc800217 	ldw	r18,8(sp)
 3212000:	dc400117 	ldw	r17,4(sp)
 3212004:	dc000017 	ldw	r16,0(sp)
 3212008:	dec00304 	addi	sp,sp,12
 321200c:	f800283a 	ret

03212010 <__fixunsdfsi>:
 3212010:	defffb04 	addi	sp,sp,-20
 3212014:	dc400115 	stw	r17,4(sp)
 3212018:	dc000015 	stw	r16,0(sp)
 321201c:	04507834 	movhi	r17,16864
 3212020:	0021883a 	mov	r16,zero
 3212024:	800d883a 	mov	r6,r16
 3212028:	880f883a 	mov	r7,r17
 321202c:	dcc00315 	stw	r19,12(sp)
 3212030:	dc800215 	stw	r18,8(sp)
 3212034:	2827883a 	mov	r19,r5
 3212038:	2025883a 	mov	r18,r4
 321203c:	dfc00415 	stw	ra,16(sp)
 3212040:	3213a600 	call	3213a60 <__gedf2>
 3212044:	000d883a 	mov	r6,zero
 3212048:	880f883a 	mov	r7,r17
 321204c:	980b883a 	mov	r5,r19
 3212050:	9009883a 	mov	r4,r18
 3212054:	10000d16 	blt	r2,zero,321208c <__fixunsdfsi+0x7c>
 3212058:	32131b80 	call	32131b8 <__subdf3>
 321205c:	180b883a 	mov	r5,r3
 3212060:	1009883a 	mov	r4,r2
 3212064:	3213cf00 	call	3213cf0 <__fixdfsi>
 3212068:	00e00034 	movhi	r3,32768
 321206c:	10c5883a 	add	r2,r2,r3
 3212070:	dfc00417 	ldw	ra,16(sp)
 3212074:	dcc00317 	ldw	r19,12(sp)
 3212078:	dc800217 	ldw	r18,8(sp)
 321207c:	dc400117 	ldw	r17,4(sp)
 3212080:	dc000017 	ldw	r16,0(sp)
 3212084:	dec00504 	addi	sp,sp,20
 3212088:	f800283a 	ret
 321208c:	980b883a 	mov	r5,r19
 3212090:	9009883a 	mov	r4,r18
 3212094:	3213cf00 	call	3213cf0 <__fixdfsi>
 3212098:	dfc00417 	ldw	ra,16(sp)
 321209c:	dcc00317 	ldw	r19,12(sp)
 32120a0:	dc800217 	ldw	r18,8(sp)
 32120a4:	dc400117 	ldw	r17,4(sp)
 32120a8:	dc000017 	ldw	r16,0(sp)
 32120ac:	dec00504 	addi	sp,sp,20
 32120b0:	f800283a 	ret

032120b4 <__udivdi3>:
 32120b4:	defff004 	addi	sp,sp,-64
 32120b8:	2005883a 	mov	r2,r4
 32120bc:	3011883a 	mov	r8,r6
 32120c0:	df000e15 	stw	fp,56(sp)
 32120c4:	dd000a15 	stw	r20,40(sp)
 32120c8:	dc000615 	stw	r16,24(sp)
 32120cc:	dfc00f15 	stw	ra,60(sp)
 32120d0:	ddc00d15 	stw	r23,52(sp)
 32120d4:	dd800c15 	stw	r22,48(sp)
 32120d8:	dd400b15 	stw	r21,44(sp)
 32120dc:	dcc00915 	stw	r19,36(sp)
 32120e0:	dc800815 	stw	r18,32(sp)
 32120e4:	dc400715 	stw	r17,28(sp)
 32120e8:	4021883a 	mov	r16,r8
 32120ec:	1039883a 	mov	fp,r2
 32120f0:	2829883a 	mov	r20,r5
 32120f4:	38003b1e 	bne	r7,zero,32121e4 <__udivdi3+0x130>
 32120f8:	2a005c36 	bltu	r5,r8,321226c <__udivdi3+0x1b8>
 32120fc:	4000a626 	beq	r8,zero,3212398 <__udivdi3+0x2e4>
 3212100:	00bfffd4 	movui	r2,65535
 3212104:	14009e36 	bltu	r2,r16,3212380 <__udivdi3+0x2cc>
 3212108:	00803fc4 	movi	r2,255
 321210c:	14013d36 	bltu	r2,r16,3212604 <__udivdi3+0x550>
 3212110:	000b883a 	mov	r5,zero
 3212114:	0005883a 	mov	r2,zero
 3212118:	8084d83a 	srl	r2,r16,r2
 321211c:	0100c974 	movhi	r4,805
 3212120:	21393604 	addi	r4,r4,-6952
 3212124:	01800804 	movi	r6,32
 3212128:	1105883a 	add	r2,r2,r4
 321212c:	10c00003 	ldbu	r3,0(r2)
 3212130:	28c7883a 	add	r3,r5,r3
 3212134:	30edc83a 	sub	r22,r6,r3
 3212138:	b000ee1e 	bne	r22,zero,32124f4 <__udivdi3+0x440>
 321213c:	802ad43a 	srli	r21,r16,16
 3212140:	00800044 	movi	r2,1
 3212144:	a423c83a 	sub	r17,r20,r16
 3212148:	85ffffcc 	andi	r23,r16,65535
 321214c:	d8800315 	stw	r2,12(sp)
 3212150:	8809883a 	mov	r4,r17
 3212154:	a80b883a 	mov	r5,r21
 3212158:	32047c00 	call	32047c0 <__udivsi3>
 321215c:	8809883a 	mov	r4,r17
 3212160:	a80b883a 	mov	r5,r21
 3212164:	102d883a 	mov	r22,r2
 3212168:	32047c80 	call	32047c8 <__umodsi3>
 321216c:	1004943a 	slli	r2,r2,16
 3212170:	e006d43a 	srli	r3,fp,16
 3212174:	bda3383a 	mul	r17,r23,r22
 3212178:	10c4b03a 	or	r2,r2,r3
 321217c:	1440042e 	bgeu	r2,r17,3212190 <__udivdi3+0xdc>
 3212180:	1405883a 	add	r2,r2,r16
 3212184:	b5bfffc4 	addi	r22,r22,-1
 3212188:	14000136 	bltu	r2,r16,3212190 <__udivdi3+0xdc>
 321218c:	14413d36 	bltu	r2,r17,3212684 <__udivdi3+0x5d0>
 3212190:	1463c83a 	sub	r17,r2,r17
 3212194:	8809883a 	mov	r4,r17
 3212198:	a80b883a 	mov	r5,r21
 321219c:	32047c00 	call	32047c0 <__udivsi3>
 32121a0:	8809883a 	mov	r4,r17
 32121a4:	a80b883a 	mov	r5,r21
 32121a8:	1029883a 	mov	r20,r2
 32121ac:	32047c80 	call	32047c8 <__umodsi3>
 32121b0:	1004943a 	slli	r2,r2,16
 32121b4:	bd09383a 	mul	r4,r23,r20
 32121b8:	e0ffffcc 	andi	r3,fp,65535
 32121bc:	10c4b03a 	or	r2,r2,r3
 32121c0:	1100042e 	bgeu	r2,r4,32121d4 <__udivdi3+0x120>
 32121c4:	8085883a 	add	r2,r16,r2
 32121c8:	a53fffc4 	addi	r20,r20,-1
 32121cc:	14000136 	bltu	r2,r16,32121d4 <__udivdi3+0x120>
 32121d0:	11012036 	bltu	r2,r4,3212654 <__udivdi3+0x5a0>
 32121d4:	b004943a 	slli	r2,r22,16
 32121d8:	d9000317 	ldw	r4,12(sp)
 32121dc:	a084b03a 	or	r2,r20,r2
 32121e0:	00001506 	br	3212238 <__udivdi3+0x184>
 32121e4:	380d883a 	mov	r6,r7
 32121e8:	29c06236 	bltu	r5,r7,3212374 <__udivdi3+0x2c0>
 32121ec:	00bfffd4 	movui	r2,65535
 32121f0:	11c05a36 	bltu	r2,r7,321235c <__udivdi3+0x2a8>
 32121f4:	00803fc4 	movi	r2,255
 32121f8:	11c0fc36 	bltu	r2,r7,32125ec <__udivdi3+0x538>
 32121fc:	000b883a 	mov	r5,zero
 3212200:	0005883a 	mov	r2,zero
 3212204:	3084d83a 	srl	r2,r6,r2
 3212208:	0100c974 	movhi	r4,805
 321220c:	21393604 	addi	r4,r4,-6952
 3212210:	01c00804 	movi	r7,32
 3212214:	1105883a 	add	r2,r2,r4
 3212218:	10c00003 	ldbu	r3,0(r2)
 321221c:	28c7883a 	add	r3,r5,r3
 3212220:	38efc83a 	sub	r23,r7,r3
 3212224:	b800691e 	bne	r23,zero,32123cc <__udivdi3+0x318>
 3212228:	35000136 	bltu	r6,r20,3212230 <__udivdi3+0x17c>
 321222c:	e4005136 	bltu	fp,r16,3212374 <__udivdi3+0x2c0>
 3212230:	00800044 	movi	r2,1
 3212234:	0009883a 	mov	r4,zero
 3212238:	2007883a 	mov	r3,r4
 321223c:	dfc00f17 	ldw	ra,60(sp)
 3212240:	df000e17 	ldw	fp,56(sp)
 3212244:	ddc00d17 	ldw	r23,52(sp)
 3212248:	dd800c17 	ldw	r22,48(sp)
 321224c:	dd400b17 	ldw	r21,44(sp)
 3212250:	dd000a17 	ldw	r20,40(sp)
 3212254:	dcc00917 	ldw	r19,36(sp)
 3212258:	dc800817 	ldw	r18,32(sp)
 321225c:	dc400717 	ldw	r17,28(sp)
 3212260:	dc000617 	ldw	r16,24(sp)
 3212264:	dec01004 	addi	sp,sp,64
 3212268:	f800283a 	ret
 321226c:	00bfffd4 	movui	r2,65535
 3212270:	12005036 	bltu	r2,r8,32123b4 <__udivdi3+0x300>
 3212274:	00803fc4 	movi	r2,255
 3212278:	1200e836 	bltu	r2,r8,321261c <__udivdi3+0x568>
 321227c:	000b883a 	mov	r5,zero
 3212280:	0005883a 	mov	r2,zero
 3212284:	8084d83a 	srl	r2,r16,r2
 3212288:	0100c974 	movhi	r4,805
 321228c:	21393604 	addi	r4,r4,-6952
 3212290:	01800804 	movi	r6,32
 3212294:	1105883a 	add	r2,r2,r4
 3212298:	10c00003 	ldbu	r3,0(r2)
 321229c:	28c7883a 	add	r3,r5,r3
 32122a0:	30cbc83a 	sub	r5,r6,r3
 32122a4:	28000626 	beq	r5,zero,32122c0 <__udivdi3+0x20c>
 32122a8:	3145c83a 	sub	r2,r6,r5
 32122ac:	e084d83a 	srl	r2,fp,r2
 32122b0:	a146983a 	sll	r3,r20,r5
 32122b4:	e178983a 	sll	fp,fp,r5
 32122b8:	8160983a 	sll	r16,r16,r5
 32122bc:	18a8b03a 	or	r20,r3,r2
 32122c0:	802ad43a 	srli	r21,r16,16
 32122c4:	a009883a 	mov	r4,r20
 32122c8:	85ffffcc 	andi	r23,r16,65535
 32122cc:	a80b883a 	mov	r5,r21
 32122d0:	32047c00 	call	32047c0 <__udivsi3>
 32122d4:	a009883a 	mov	r4,r20
 32122d8:	a80b883a 	mov	r5,r21
 32122dc:	102d883a 	mov	r22,r2
 32122e0:	32047c80 	call	32047c8 <__umodsi3>
 32122e4:	1004943a 	slli	r2,r2,16
 32122e8:	e006d43a 	srli	r3,fp,16
 32122ec:	bda3383a 	mul	r17,r23,r22
 32122f0:	10c4b03a 	or	r2,r2,r3
 32122f4:	1440042e 	bgeu	r2,r17,3212308 <__udivdi3+0x254>
 32122f8:	1405883a 	add	r2,r2,r16
 32122fc:	b5bfffc4 	addi	r22,r22,-1
 3212300:	14000136 	bltu	r2,r16,3212308 <__udivdi3+0x254>
 3212304:	1440d536 	bltu	r2,r17,321265c <__udivdi3+0x5a8>
 3212308:	1463c83a 	sub	r17,r2,r17
 321230c:	8809883a 	mov	r4,r17
 3212310:	a80b883a 	mov	r5,r21
 3212314:	32047c00 	call	32047c0 <__udivsi3>
 3212318:	8809883a 	mov	r4,r17
 321231c:	a80b883a 	mov	r5,r21
 3212320:	1029883a 	mov	r20,r2
 3212324:	32047c80 	call	32047c8 <__umodsi3>
 3212328:	1004943a 	slli	r2,r2,16
 321232c:	bd09383a 	mul	r4,r23,r20
 3212330:	e0ffffcc 	andi	r3,fp,65535
 3212334:	10c4b03a 	or	r2,r2,r3
 3212338:	1100042e 	bgeu	r2,r4,321234c <__udivdi3+0x298>
 321233c:	8085883a 	add	r2,r16,r2
 3212340:	a53fffc4 	addi	r20,r20,-1
 3212344:	14000136 	bltu	r2,r16,321234c <__udivdi3+0x298>
 3212348:	1100c736 	bltu	r2,r4,3212668 <__udivdi3+0x5b4>
 321234c:	b004943a 	slli	r2,r22,16
 3212350:	0009883a 	mov	r4,zero
 3212354:	a084b03a 	or	r2,r20,r2
 3212358:	003fb706 	br	3212238 <__udivdi3+0x184>
 321235c:	00804034 	movhi	r2,256
 3212360:	10bfffc4 	addi	r2,r2,-1
 3212364:	11c0a436 	bltu	r2,r7,32125f8 <__udivdi3+0x544>
 3212368:	01400404 	movi	r5,16
 321236c:	2805883a 	mov	r2,r5
 3212370:	003fa406 	br	3212204 <__udivdi3+0x150>
 3212374:	0005883a 	mov	r2,zero
 3212378:	0009883a 	mov	r4,zero
 321237c:	003fae06 	br	3212238 <__udivdi3+0x184>
 3212380:	00804034 	movhi	r2,256
 3212384:	10bfffc4 	addi	r2,r2,-1
 3212388:	1400a136 	bltu	r2,r16,3212610 <__udivdi3+0x55c>
 321238c:	01400404 	movi	r5,16
 3212390:	2805883a 	mov	r2,r5
 3212394:	003f6006 	br	3212118 <__udivdi3+0x64>
 3212398:	01000044 	movi	r4,1
 321239c:	000b883a 	mov	r5,zero
 32123a0:	32047c00 	call	32047c0 <__udivsi3>
 32123a4:	1021883a 	mov	r16,r2
 32123a8:	00bfffd4 	movui	r2,65535
 32123ac:	143ff436 	bltu	r2,r16,3212380 <__udivdi3+0x2cc>
 32123b0:	003f5506 	br	3212108 <__udivdi3+0x54>
 32123b4:	00804034 	movhi	r2,256
 32123b8:	10bfffc4 	addi	r2,r2,-1
 32123bc:	12009a36 	bltu	r2,r8,3212628 <__udivdi3+0x574>
 32123c0:	01400404 	movi	r5,16
 32123c4:	2805883a 	mov	r2,r5
 32123c8:	003fae06 	br	3212284 <__udivdi3+0x1d0>
 32123cc:	3dc5c83a 	sub	r2,r7,r23
 32123d0:	35c8983a 	sll	r4,r6,r23
 32123d4:	8086d83a 	srl	r3,r16,r2
 32123d8:	a0a2d83a 	srl	r17,r20,r2
 32123dc:	e084d83a 	srl	r2,fp,r2
 32123e0:	20eab03a 	or	r21,r4,r3
 32123e4:	a82cd43a 	srli	r22,r21,16
 32123e8:	a5c6983a 	sll	r3,r20,r23
 32123ec:	8809883a 	mov	r4,r17
 32123f0:	b00b883a 	mov	r5,r22
 32123f4:	1886b03a 	or	r3,r3,r2
 32123f8:	d8c00215 	stw	r3,8(sp)
 32123fc:	32047c00 	call	32047c0 <__udivsi3>
 3212400:	8809883a 	mov	r4,r17
 3212404:	b00b883a 	mov	r5,r22
 3212408:	1029883a 	mov	r20,r2
 321240c:	32047c80 	call	32047c8 <__umodsi3>
 3212410:	a8ffffcc 	andi	r3,r21,65535
 3212414:	d8c00515 	stw	r3,20(sp)
 3212418:	d9000217 	ldw	r4,8(sp)
 321241c:	d9400517 	ldw	r5,20(sp)
 3212420:	1004943a 	slli	r2,r2,16
 3212424:	2006d43a 	srli	r3,r4,16
 3212428:	85e0983a 	sll	r16,r16,r23
 321242c:	2d23383a 	mul	r17,r5,r20
 3212430:	10c4b03a 	or	r2,r2,r3
 3212434:	dc000015 	stw	r16,0(sp)
 3212438:	1440032e 	bgeu	r2,r17,3212448 <__udivdi3+0x394>
 321243c:	1545883a 	add	r2,r2,r21
 3212440:	a53fffc4 	addi	r20,r20,-1
 3212444:	15407f2e 	bgeu	r2,r21,3212644 <__udivdi3+0x590>
 3212448:	1463c83a 	sub	r17,r2,r17
 321244c:	8809883a 	mov	r4,r17
 3212450:	b00b883a 	mov	r5,r22
 3212454:	32047c00 	call	32047c0 <__udivsi3>
 3212458:	8809883a 	mov	r4,r17
 321245c:	b00b883a 	mov	r5,r22
 3212460:	1021883a 	mov	r16,r2
 3212464:	32047c80 	call	32047c8 <__umodsi3>
 3212468:	d8c00517 	ldw	r3,20(sp)
 321246c:	d9000217 	ldw	r4,8(sp)
 3212470:	1004943a 	slli	r2,r2,16
 3212474:	1c0f383a 	mul	r7,r3,r16
 3212478:	20ffffcc 	andi	r3,r4,65535
 321247c:	10e2b03a 	or	r17,r2,r3
 3212480:	89c0032e 	bgeu	r17,r7,3212490 <__udivdi3+0x3dc>
 3212484:	8d63883a 	add	r17,r17,r21
 3212488:	843fffc4 	addi	r16,r16,-1
 321248c:	8d40692e 	bgeu	r17,r21,3212634 <__udivdi3+0x580>
 3212490:	a008943a 	slli	r4,r20,16
 3212494:	d9400017 	ldw	r5,0(sp)
 3212498:	89e3c83a 	sub	r17,r17,r7
 321249c:	8110b03a 	or	r8,r16,r4
 32124a0:	280cd43a 	srli	r6,r5,16
 32124a4:	28ffffcc 	andi	r3,r5,65535
 32124a8:	40bfffcc 	andi	r2,r8,65535
 32124ac:	400ad43a 	srli	r5,r8,16
 32124b0:	10d3383a 	mul	r9,r2,r3
 32124b4:	1185383a 	mul	r2,r2,r6
 32124b8:	28c7383a 	mul	r3,r5,r3
 32124bc:	4808d43a 	srli	r4,r9,16
 32124c0:	298b383a 	mul	r5,r5,r6
 32124c4:	10c5883a 	add	r2,r2,r3
 32124c8:	2089883a 	add	r4,r4,r2
 32124cc:	20c0022e 	bgeu	r4,r3,32124d8 <__udivdi3+0x424>
 32124d0:	00800074 	movhi	r2,1
 32124d4:	288b883a 	add	r5,r5,r2
 32124d8:	2004d43a 	srli	r2,r4,16
 32124dc:	288b883a 	add	r5,r5,r2
 32124e0:	89403f36 	bltu	r17,r5,32125e0 <__udivdi3+0x52c>
 32124e4:	89403926 	beq	r17,r5,32125cc <__udivdi3+0x518>
 32124e8:	4005883a 	mov	r2,r8
 32124ec:	0009883a 	mov	r4,zero
 32124f0:	003f5106 	br	3212238 <__udivdi3+0x184>
 32124f4:	85a0983a 	sll	r16,r16,r22
 32124f8:	3585c83a 	sub	r2,r6,r22
 32124fc:	a0a2d83a 	srl	r17,r20,r2
 3212500:	802ad43a 	srli	r21,r16,16
 3212504:	e084d83a 	srl	r2,fp,r2
 3212508:	a586983a 	sll	r3,r20,r22
 321250c:	8809883a 	mov	r4,r17
 3212510:	a80b883a 	mov	r5,r21
 3212514:	1886b03a 	or	r3,r3,r2
 3212518:	d8c00115 	stw	r3,4(sp)
 321251c:	32047c00 	call	32047c0 <__udivsi3>
 3212520:	8809883a 	mov	r4,r17
 3212524:	a80b883a 	mov	r5,r21
 3212528:	d8800415 	stw	r2,16(sp)
 321252c:	32047c80 	call	32047c8 <__umodsi3>
 3212530:	d9000117 	ldw	r4,4(sp)
 3212534:	d9400417 	ldw	r5,16(sp)
 3212538:	1004943a 	slli	r2,r2,16
 321253c:	85ffffcc 	andi	r23,r16,65535
 3212540:	2006d43a 	srli	r3,r4,16
 3212544:	b963383a 	mul	r17,r23,r5
 3212548:	10c4b03a 	or	r2,r2,r3
 321254c:	1440042e 	bgeu	r2,r17,3212560 <__udivdi3+0x4ac>
 3212550:	297fffc4 	addi	r5,r5,-1
 3212554:	1405883a 	add	r2,r2,r16
 3212558:	d9400415 	stw	r5,16(sp)
 321255c:	1400442e 	bgeu	r2,r16,3212670 <__udivdi3+0x5bc>
 3212560:	1463c83a 	sub	r17,r2,r17
 3212564:	8809883a 	mov	r4,r17
 3212568:	a80b883a 	mov	r5,r21
 321256c:	32047c00 	call	32047c0 <__udivsi3>
 3212570:	8809883a 	mov	r4,r17
 3212574:	a80b883a 	mov	r5,r21
 3212578:	1029883a 	mov	r20,r2
 321257c:	32047c80 	call	32047c8 <__umodsi3>
 3212580:	d9400117 	ldw	r5,4(sp)
 3212584:	1004943a 	slli	r2,r2,16
 3212588:	bd09383a 	mul	r4,r23,r20
 321258c:	28ffffcc 	andi	r3,r5,65535
 3212590:	10c6b03a 	or	r3,r2,r3
 3212594:	1900062e 	bgeu	r3,r4,32125b0 <__udivdi3+0x4fc>
 3212598:	1c07883a 	add	r3,r3,r16
 321259c:	a53fffc4 	addi	r20,r20,-1
 32125a0:	1c000336 	bltu	r3,r16,32125b0 <__udivdi3+0x4fc>
 32125a4:	1900022e 	bgeu	r3,r4,32125b0 <__udivdi3+0x4fc>
 32125a8:	a53fffc4 	addi	r20,r20,-1
 32125ac:	1c07883a 	add	r3,r3,r16
 32125b0:	d9400417 	ldw	r5,16(sp)
 32125b4:	e5b8983a 	sll	fp,fp,r22
 32125b8:	1923c83a 	sub	r17,r3,r4
 32125bc:	2804943a 	slli	r2,r5,16
 32125c0:	a0a8b03a 	or	r20,r20,r2
 32125c4:	dd000315 	stw	r20,12(sp)
 32125c8:	003ee106 	br	3212150 <__udivdi3+0x9c>
 32125cc:	2004943a 	slli	r2,r4,16
 32125d0:	e5c8983a 	sll	r4,fp,r23
 32125d4:	48ffffcc 	andi	r3,r9,65535
 32125d8:	10c5883a 	add	r2,r2,r3
 32125dc:	20bfc22e 	bgeu	r4,r2,32124e8 <__udivdi3+0x434>
 32125e0:	40bfffc4 	addi	r2,r8,-1
 32125e4:	0009883a 	mov	r4,zero
 32125e8:	003f1306 	br	3212238 <__udivdi3+0x184>
 32125ec:	01400204 	movi	r5,8
 32125f0:	2805883a 	mov	r2,r5
 32125f4:	003f0306 	br	3212204 <__udivdi3+0x150>
 32125f8:	01400604 	movi	r5,24
 32125fc:	2805883a 	mov	r2,r5
 3212600:	003f0006 	br	3212204 <__udivdi3+0x150>
 3212604:	01400204 	movi	r5,8
 3212608:	2805883a 	mov	r2,r5
 321260c:	003ec206 	br	3212118 <__udivdi3+0x64>
 3212610:	01400604 	movi	r5,24
 3212614:	2805883a 	mov	r2,r5
 3212618:	003ebf06 	br	3212118 <__udivdi3+0x64>
 321261c:	01400204 	movi	r5,8
 3212620:	2805883a 	mov	r2,r5
 3212624:	003f1706 	br	3212284 <__udivdi3+0x1d0>
 3212628:	01400604 	movi	r5,24
 321262c:	2805883a 	mov	r2,r5
 3212630:	003f1406 	br	3212284 <__udivdi3+0x1d0>
 3212634:	89ff962e 	bgeu	r17,r7,3212490 <__udivdi3+0x3dc>
 3212638:	8d63883a 	add	r17,r17,r21
 321263c:	843fffc4 	addi	r16,r16,-1
 3212640:	003f9306 	br	3212490 <__udivdi3+0x3dc>
 3212644:	147f802e 	bgeu	r2,r17,3212448 <__udivdi3+0x394>
 3212648:	a53fffc4 	addi	r20,r20,-1
 321264c:	1545883a 	add	r2,r2,r21
 3212650:	003f7d06 	br	3212448 <__udivdi3+0x394>
 3212654:	a53fffc4 	addi	r20,r20,-1
 3212658:	003ede06 	br	32121d4 <__udivdi3+0x120>
 321265c:	b5bfffc4 	addi	r22,r22,-1
 3212660:	1405883a 	add	r2,r2,r16
 3212664:	003f2806 	br	3212308 <__udivdi3+0x254>
 3212668:	a53fffc4 	addi	r20,r20,-1
 321266c:	003f3706 	br	321234c <__udivdi3+0x298>
 3212670:	147fbb2e 	bgeu	r2,r17,3212560 <__udivdi3+0x4ac>
 3212674:	297fffc4 	addi	r5,r5,-1
 3212678:	1405883a 	add	r2,r2,r16
 321267c:	d9400415 	stw	r5,16(sp)
 3212680:	003fb706 	br	3212560 <__udivdi3+0x4ac>
 3212684:	b5bfffc4 	addi	r22,r22,-1
 3212688:	1405883a 	add	r2,r2,r16
 321268c:	003ec006 	br	3212190 <__udivdi3+0xdc>

03212690 <__umoddi3>:
 3212690:	defff104 	addi	sp,sp,-60
 3212694:	dd800b15 	stw	r22,44(sp)
 3212698:	dd000915 	stw	r20,36(sp)
 321269c:	dc000515 	stw	r16,20(sp)
 32126a0:	dfc00e15 	stw	ra,56(sp)
 32126a4:	df000d15 	stw	fp,52(sp)
 32126a8:	ddc00c15 	stw	r23,48(sp)
 32126ac:	dd400a15 	stw	r21,40(sp)
 32126b0:	dcc00815 	stw	r19,32(sp)
 32126b4:	dc800715 	stw	r18,28(sp)
 32126b8:	dc400615 	stw	r17,24(sp)
 32126bc:	3021883a 	mov	r16,r6
 32126c0:	202d883a 	mov	r22,r4
 32126c4:	2829883a 	mov	r20,r5
 32126c8:	38002b1e 	bne	r7,zero,3212778 <__umoddi3+0xe8>
 32126cc:	29805036 	bltu	r5,r6,3212810 <__umoddi3+0x180>
 32126d0:	30008a26 	beq	r6,zero,32128fc <__umoddi3+0x26c>
 32126d4:	00bfffd4 	movui	r2,65535
 32126d8:	14008236 	bltu	r2,r16,32128e4 <__umoddi3+0x254>
 32126dc:	00803fc4 	movi	r2,255
 32126e0:	14013636 	bltu	r2,r16,3212bbc <__umoddi3+0x52c>
 32126e4:	000b883a 	mov	r5,zero
 32126e8:	0005883a 	mov	r2,zero
 32126ec:	8084d83a 	srl	r2,r16,r2
 32126f0:	0100c974 	movhi	r4,805
 32126f4:	21393604 	addi	r4,r4,-6952
 32126f8:	01800804 	movi	r6,32
 32126fc:	1105883a 	add	r2,r2,r4
 3212700:	10c00003 	ldbu	r3,0(r2)
 3212704:	28c7883a 	add	r3,r5,r3
 3212708:	30efc83a 	sub	r23,r6,r3
 321270c:	b800941e 	bne	r23,zero,3212960 <__umoddi3+0x2d0>
 3212710:	802ad43a 	srli	r21,r16,16
 3212714:	a423c83a 	sub	r17,r20,r16
 3212718:	0039883a 	mov	fp,zero
 321271c:	853fffcc 	andi	r20,r16,65535
 3212720:	8809883a 	mov	r4,r17
 3212724:	a80b883a 	mov	r5,r21
 3212728:	32047c00 	call	32047c0 <__udivsi3>
 321272c:	8809883a 	mov	r4,r17
 3212730:	a80b883a 	mov	r5,r21
 3212734:	a0a3383a 	mul	r17,r20,r2
 3212738:	32047c80 	call	32047c8 <__umodsi3>
 321273c:	1004943a 	slli	r2,r2,16
 3212740:	b006d43a 	srli	r3,r22,16
 3212744:	10c4b03a 	or	r2,r2,r3
 3212748:	1440032e 	bgeu	r2,r17,3212758 <__umoddi3+0xc8>
 321274c:	1405883a 	add	r2,r2,r16
 3212750:	14000136 	bltu	r2,r16,3212758 <__umoddi3+0xc8>
 3212754:	14413536 	bltu	r2,r17,3212c2c <__umoddi3+0x59c>
 3212758:	1463c83a 	sub	r17,r2,r17
 321275c:	8809883a 	mov	r4,r17
 3212760:	a80b883a 	mov	r5,r21
 3212764:	32047c00 	call	32047c0 <__udivsi3>
 3212768:	8809883a 	mov	r4,r17
 321276c:	a0a3383a 	mul	r17,r20,r2
 3212770:	a80b883a 	mov	r5,r21
 3212774:	00004d06 	br	32128ac <__umoddi3+0x21c>
 3212778:	380d883a 	mov	r6,r7
 321277c:	29c0102e 	bgeu	r5,r7,32127c0 <__umoddi3+0x130>
 3212780:	2011883a 	mov	r8,r4
 3212784:	2813883a 	mov	r9,r5
 3212788:	4005883a 	mov	r2,r8
 321278c:	4807883a 	mov	r3,r9
 3212790:	dfc00e17 	ldw	ra,56(sp)
 3212794:	df000d17 	ldw	fp,52(sp)
 3212798:	ddc00c17 	ldw	r23,48(sp)
 321279c:	dd800b17 	ldw	r22,44(sp)
 32127a0:	dd400a17 	ldw	r21,40(sp)
 32127a4:	dd000917 	ldw	r20,36(sp)
 32127a8:	dcc00817 	ldw	r19,32(sp)
 32127ac:	dc800717 	ldw	r18,28(sp)
 32127b0:	dc400617 	ldw	r17,24(sp)
 32127b4:	dc000517 	ldw	r16,20(sp)
 32127b8:	dec00f04 	addi	sp,sp,60
 32127bc:	f800283a 	ret
 32127c0:	00bfffd4 	movui	r2,65535
 32127c4:	11c05a36 	bltu	r2,r7,3212930 <__umoddi3+0x2a0>
 32127c8:	00803fc4 	movi	r2,255
 32127cc:	11c0fe36 	bltu	r2,r7,3212bc8 <__umoddi3+0x538>
 32127d0:	000b883a 	mov	r5,zero
 32127d4:	0005883a 	mov	r2,zero
 32127d8:	3084d83a 	srl	r2,r6,r2
 32127dc:	0100c974 	movhi	r4,805
 32127e0:	21393604 	addi	r4,r4,-6952
 32127e4:	01c00804 	movi	r7,32
 32127e8:	1105883a 	add	r2,r2,r4
 32127ec:	10c00003 	ldbu	r3,0(r2)
 32127f0:	28c7883a 	add	r3,r5,r3
 32127f4:	38ebc83a 	sub	r21,r7,r3
 32127f8:	a800851e 	bne	r21,zero,3212a10 <__umoddi3+0x380>
 32127fc:	35005236 	bltu	r6,r20,3212948 <__umoddi3+0x2b8>
 3212800:	b400512e 	bgeu	r22,r16,3212948 <__umoddi3+0x2b8>
 3212804:	b011883a 	mov	r8,r22
 3212808:	a013883a 	mov	r9,r20
 321280c:	003fde06 	br	3212788 <__umoddi3+0xf8>
 3212810:	00bfffd4 	movui	r2,65535
 3212814:	11804036 	bltu	r2,r6,3212918 <__umoddi3+0x288>
 3212818:	00803fc4 	movi	r2,255
 321281c:	1180ed36 	bltu	r2,r6,3212bd4 <__umoddi3+0x544>
 3212820:	000b883a 	mov	r5,zero
 3212824:	0005883a 	mov	r2,zero
 3212828:	8084d83a 	srl	r2,r16,r2
 321282c:	0100c974 	movhi	r4,805
 3212830:	21393604 	addi	r4,r4,-6952
 3212834:	01800804 	movi	r6,32
 3212838:	1105883a 	add	r2,r2,r4
 321283c:	10c00003 	ldbu	r3,0(r2)
 3212840:	28c7883a 	add	r3,r5,r3
 3212844:	30c7c83a 	sub	r3,r6,r3
 3212848:	1800bf1e 	bne	r3,zero,3212b48 <__umoddi3+0x4b8>
 321284c:	0039883a 	mov	fp,zero
 3212850:	802ad43a 	srli	r21,r16,16
 3212854:	a009883a 	mov	r4,r20
 3212858:	85ffffcc 	andi	r23,r16,65535
 321285c:	a80b883a 	mov	r5,r21
 3212860:	32047c00 	call	32047c0 <__udivsi3>
 3212864:	a009883a 	mov	r4,r20
 3212868:	a80b883a 	mov	r5,r21
 321286c:	b8a3383a 	mul	r17,r23,r2
 3212870:	32047c80 	call	32047c8 <__umodsi3>
 3212874:	1004943a 	slli	r2,r2,16
 3212878:	b006d43a 	srli	r3,r22,16
 321287c:	10c4b03a 	or	r2,r2,r3
 3212880:	1440032e 	bgeu	r2,r17,3212890 <__umoddi3+0x200>
 3212884:	1405883a 	add	r2,r2,r16
 3212888:	14000136 	bltu	r2,r16,3212890 <__umoddi3+0x200>
 321288c:	1440e536 	bltu	r2,r17,3212c24 <__umoddi3+0x594>
 3212890:	1463c83a 	sub	r17,r2,r17
 3212894:	8809883a 	mov	r4,r17
 3212898:	a80b883a 	mov	r5,r21
 321289c:	32047c00 	call	32047c0 <__udivsi3>
 32128a0:	8809883a 	mov	r4,r17
 32128a4:	b8a3383a 	mul	r17,r23,r2
 32128a8:	a80b883a 	mov	r5,r21
 32128ac:	32047c80 	call	32047c8 <__umodsi3>
 32128b0:	1004943a 	slli	r2,r2,16
 32128b4:	b0ffffcc 	andi	r3,r22,65535
 32128b8:	10c4b03a 	or	r2,r2,r3
 32128bc:	1440042e 	bgeu	r2,r17,32128d0 <__umoddi3+0x240>
 32128c0:	1405883a 	add	r2,r2,r16
 32128c4:	14000236 	bltu	r2,r16,32128d0 <__umoddi3+0x240>
 32128c8:	1440012e 	bgeu	r2,r17,32128d0 <__umoddi3+0x240>
 32128cc:	1405883a 	add	r2,r2,r16
 32128d0:	1445c83a 	sub	r2,r2,r17
 32128d4:	1724d83a 	srl	r18,r2,fp
 32128d8:	0013883a 	mov	r9,zero
 32128dc:	9011883a 	mov	r8,r18
 32128e0:	003fa906 	br	3212788 <__umoddi3+0xf8>
 32128e4:	00804034 	movhi	r2,256
 32128e8:	10bfffc4 	addi	r2,r2,-1
 32128ec:	1400b036 	bltu	r2,r16,3212bb0 <__umoddi3+0x520>
 32128f0:	01400404 	movi	r5,16
 32128f4:	2805883a 	mov	r2,r5
 32128f8:	003f7c06 	br	32126ec <__umoddi3+0x5c>
 32128fc:	01000044 	movi	r4,1
 3212900:	000b883a 	mov	r5,zero
 3212904:	32047c00 	call	32047c0 <__udivsi3>
 3212908:	1021883a 	mov	r16,r2
 321290c:	00bfffd4 	movui	r2,65535
 3212910:	143ff436 	bltu	r2,r16,32128e4 <__umoddi3+0x254>
 3212914:	003f7106 	br	32126dc <__umoddi3+0x4c>
 3212918:	00804034 	movhi	r2,256
 321291c:	10bfffc4 	addi	r2,r2,-1
 3212920:	1180af36 	bltu	r2,r6,3212be0 <__umoddi3+0x550>
 3212924:	01400404 	movi	r5,16
 3212928:	2805883a 	mov	r2,r5
 321292c:	003fbe06 	br	3212828 <__umoddi3+0x198>
 3212930:	00804034 	movhi	r2,256
 3212934:	10bfffc4 	addi	r2,r2,-1
 3212938:	11c0ac36 	bltu	r2,r7,3212bec <__umoddi3+0x55c>
 321293c:	01400404 	movi	r5,16
 3212940:	2805883a 	mov	r2,r5
 3212944:	003fa406 	br	32127d8 <__umoddi3+0x148>
 3212948:	b409c83a 	sub	r4,r22,r16
 321294c:	b105803a 	cmpltu	r2,r22,r4
 3212950:	a187c83a 	sub	r3,r20,r6
 3212954:	18a9c83a 	sub	r20,r3,r2
 3212958:	202d883a 	mov	r22,r4
 321295c:	003fa906 	br	3212804 <__umoddi3+0x174>
 3212960:	85e0983a 	sll	r16,r16,r23
 3212964:	35c5c83a 	sub	r2,r6,r23
 3212968:	a0a2d83a 	srl	r17,r20,r2
 321296c:	802ad43a 	srli	r21,r16,16
 3212970:	b084d83a 	srl	r2,r22,r2
 3212974:	a5c6983a 	sll	r3,r20,r23
 3212978:	8809883a 	mov	r4,r17
 321297c:	a80b883a 	mov	r5,r21
 3212980:	1886b03a 	or	r3,r3,r2
 3212984:	d8c00115 	stw	r3,4(sp)
 3212988:	853fffcc 	andi	r20,r16,65535
 321298c:	32047c00 	call	32047c0 <__udivsi3>
 3212990:	8809883a 	mov	r4,r17
 3212994:	a80b883a 	mov	r5,r21
 3212998:	a0a3383a 	mul	r17,r20,r2
 321299c:	32047c80 	call	32047c8 <__umodsi3>
 32129a0:	d9000117 	ldw	r4,4(sp)
 32129a4:	1004943a 	slli	r2,r2,16
 32129a8:	b839883a 	mov	fp,r23
 32129ac:	2006d43a 	srli	r3,r4,16
 32129b0:	10c4b03a 	or	r2,r2,r3
 32129b4:	1440022e 	bgeu	r2,r17,32129c0 <__umoddi3+0x330>
 32129b8:	1405883a 	add	r2,r2,r16
 32129bc:	1400962e 	bgeu	r2,r16,3212c18 <__umoddi3+0x588>
 32129c0:	1463c83a 	sub	r17,r2,r17
 32129c4:	8809883a 	mov	r4,r17
 32129c8:	a80b883a 	mov	r5,r21
 32129cc:	32047c00 	call	32047c0 <__udivsi3>
 32129d0:	8809883a 	mov	r4,r17
 32129d4:	a80b883a 	mov	r5,r21
 32129d8:	a0a3383a 	mul	r17,r20,r2
 32129dc:	32047c80 	call	32047c8 <__umodsi3>
 32129e0:	d9400117 	ldw	r5,4(sp)
 32129e4:	1004943a 	slli	r2,r2,16
 32129e8:	28ffffcc 	andi	r3,r5,65535
 32129ec:	10c4b03a 	or	r2,r2,r3
 32129f0:	1440042e 	bgeu	r2,r17,3212a04 <__umoddi3+0x374>
 32129f4:	1405883a 	add	r2,r2,r16
 32129f8:	14000236 	bltu	r2,r16,3212a04 <__umoddi3+0x374>
 32129fc:	1440012e 	bgeu	r2,r17,3212a04 <__umoddi3+0x374>
 3212a00:	1405883a 	add	r2,r2,r16
 3212a04:	b5ec983a 	sll	r22,r22,r23
 3212a08:	1463c83a 	sub	r17,r2,r17
 3212a0c:	003f4406 	br	3212720 <__umoddi3+0x90>
 3212a10:	3d4fc83a 	sub	r7,r7,r21
 3212a14:	3546983a 	sll	r3,r6,r21
 3212a18:	81c4d83a 	srl	r2,r16,r7
 3212a1c:	a1e2d83a 	srl	r17,r20,r7
 3212a20:	a54c983a 	sll	r6,r20,r21
 3212a24:	18aeb03a 	or	r23,r3,r2
 3212a28:	b828d43a 	srli	r20,r23,16
 3212a2c:	b1c4d83a 	srl	r2,r22,r7
 3212a30:	8809883a 	mov	r4,r17
 3212a34:	a00b883a 	mov	r5,r20
 3212a38:	308cb03a 	or	r6,r6,r2
 3212a3c:	d9c00315 	stw	r7,12(sp)
 3212a40:	d9800215 	stw	r6,8(sp)
 3212a44:	32047c00 	call	32047c0 <__udivsi3>
 3212a48:	8809883a 	mov	r4,r17
 3212a4c:	a00b883a 	mov	r5,r20
 3212a50:	1039883a 	mov	fp,r2
 3212a54:	32047c80 	call	32047c8 <__umodsi3>
 3212a58:	b8ffffcc 	andi	r3,r23,65535
 3212a5c:	d8c00415 	stw	r3,16(sp)
 3212a60:	d9000217 	ldw	r4,8(sp)
 3212a64:	d9400417 	ldw	r5,16(sp)
 3212a68:	1004943a 	slli	r2,r2,16
 3212a6c:	2006d43a 	srli	r3,r4,16
 3212a70:	8560983a 	sll	r16,r16,r21
 3212a74:	2f23383a 	mul	r17,r5,fp
 3212a78:	10c4b03a 	or	r2,r2,r3
 3212a7c:	dc000015 	stw	r16,0(sp)
 3212a80:	b56c983a 	sll	r22,r22,r21
 3212a84:	1440032e 	bgeu	r2,r17,3212a94 <__umoddi3+0x404>
 3212a88:	15c5883a 	add	r2,r2,r23
 3212a8c:	e73fffc4 	addi	fp,fp,-1
 3212a90:	15c05d2e 	bgeu	r2,r23,3212c08 <__umoddi3+0x578>
 3212a94:	1463c83a 	sub	r17,r2,r17
 3212a98:	8809883a 	mov	r4,r17
 3212a9c:	a00b883a 	mov	r5,r20
 3212aa0:	32047c00 	call	32047c0 <__udivsi3>
 3212aa4:	8809883a 	mov	r4,r17
 3212aa8:	a00b883a 	mov	r5,r20
 3212aac:	1021883a 	mov	r16,r2
 3212ab0:	32047c80 	call	32047c8 <__umodsi3>
 3212ab4:	d8c00417 	ldw	r3,16(sp)
 3212ab8:	d9000217 	ldw	r4,8(sp)
 3212abc:	1004943a 	slli	r2,r2,16
 3212ac0:	1c23383a 	mul	r17,r3,r16
 3212ac4:	20ffffcc 	andi	r3,r4,65535
 3212ac8:	10ceb03a 	or	r7,r2,r3
 3212acc:	3c40032e 	bgeu	r7,r17,3212adc <__umoddi3+0x44c>
 3212ad0:	3dcf883a 	add	r7,r7,r23
 3212ad4:	843fffc4 	addi	r16,r16,-1
 3212ad8:	3dc0472e 	bgeu	r7,r23,3212bf8 <__umoddi3+0x568>
 3212adc:	e004943a 	slli	r2,fp,16
 3212ae0:	d9400017 	ldw	r5,0(sp)
 3212ae4:	3c4fc83a 	sub	r7,r7,r17
 3212ae8:	8084b03a 	or	r2,r16,r2
 3212aec:	28ffffcc 	andi	r3,r5,65535
 3212af0:	280cd43a 	srli	r6,r5,16
 3212af4:	100ad43a 	srli	r5,r2,16
 3212af8:	10bfffcc 	andi	r2,r2,65535
 3212afc:	10d1383a 	mul	r8,r2,r3
 3212b00:	28c7383a 	mul	r3,r5,r3
 3212b04:	1185383a 	mul	r2,r2,r6
 3212b08:	4008d43a 	srli	r4,r8,16
 3212b0c:	298b383a 	mul	r5,r5,r6
 3212b10:	10c5883a 	add	r2,r2,r3
 3212b14:	2089883a 	add	r4,r4,r2
 3212b18:	20c0022e 	bgeu	r4,r3,3212b24 <__umoddi3+0x494>
 3212b1c:	00800074 	movhi	r2,1
 3212b20:	288b883a 	add	r5,r5,r2
 3212b24:	2004d43a 	srli	r2,r4,16
 3212b28:	2008943a 	slli	r4,r4,16
 3212b2c:	40ffffcc 	andi	r3,r8,65535
 3212b30:	288b883a 	add	r5,r5,r2
 3212b34:	20c9883a 	add	r4,r4,r3
 3212b38:	39400b36 	bltu	r7,r5,3212b68 <__umoddi3+0x4d8>
 3212b3c:	39403d26 	beq	r7,r5,3212c34 <__umoddi3+0x5a4>
 3212b40:	394bc83a 	sub	r5,r7,r5
 3212b44:	00000f06 	br	3212b84 <__umoddi3+0x4f4>
 3212b48:	30c5c83a 	sub	r2,r6,r3
 3212b4c:	1839883a 	mov	fp,r3
 3212b50:	b084d83a 	srl	r2,r22,r2
 3212b54:	a0c6983a 	sll	r3,r20,r3
 3212b58:	8720983a 	sll	r16,r16,fp
 3212b5c:	b72c983a 	sll	r22,r22,fp
 3212b60:	18a8b03a 	or	r20,r3,r2
 3212b64:	003f3a06 	br	3212850 <__umoddi3+0x1c0>
 3212b68:	d8c00017 	ldw	r3,0(sp)
 3212b6c:	20c5c83a 	sub	r2,r4,r3
 3212b70:	2089803a 	cmpltu	r4,r4,r2
 3212b74:	2dc7c83a 	sub	r3,r5,r23
 3212b78:	1907c83a 	sub	r3,r3,r4
 3212b7c:	38cbc83a 	sub	r5,r7,r3
 3212b80:	1009883a 	mov	r4,r2
 3212b84:	b105c83a 	sub	r2,r22,r4
 3212b88:	b087803a 	cmpltu	r3,r22,r2
 3212b8c:	28c7c83a 	sub	r3,r5,r3
 3212b90:	d9400317 	ldw	r5,12(sp)
 3212b94:	1544d83a 	srl	r2,r2,r21
 3212b98:	1948983a 	sll	r4,r3,r5
 3212b9c:	1d46d83a 	srl	r3,r3,r21
 3212ba0:	20a4b03a 	or	r18,r4,r2
 3212ba4:	9011883a 	mov	r8,r18
 3212ba8:	1813883a 	mov	r9,r3
 3212bac:	003ef606 	br	3212788 <__umoddi3+0xf8>
 3212bb0:	01400604 	movi	r5,24
 3212bb4:	2805883a 	mov	r2,r5
 3212bb8:	003ecc06 	br	32126ec <__umoddi3+0x5c>
 3212bbc:	01400204 	movi	r5,8
 3212bc0:	2805883a 	mov	r2,r5
 3212bc4:	003ec906 	br	32126ec <__umoddi3+0x5c>
 3212bc8:	01400204 	movi	r5,8
 3212bcc:	2805883a 	mov	r2,r5
 3212bd0:	003f0106 	br	32127d8 <__umoddi3+0x148>
 3212bd4:	01400204 	movi	r5,8
 3212bd8:	2805883a 	mov	r2,r5
 3212bdc:	003f1206 	br	3212828 <__umoddi3+0x198>
 3212be0:	01400604 	movi	r5,24
 3212be4:	2805883a 	mov	r2,r5
 3212be8:	003f0f06 	br	3212828 <__umoddi3+0x198>
 3212bec:	01400604 	movi	r5,24
 3212bf0:	2805883a 	mov	r2,r5
 3212bf4:	003ef806 	br	32127d8 <__umoddi3+0x148>
 3212bf8:	3c7fb82e 	bgeu	r7,r17,3212adc <__umoddi3+0x44c>
 3212bfc:	843fffc4 	addi	r16,r16,-1
 3212c00:	3dcf883a 	add	r7,r7,r23
 3212c04:	003fb506 	br	3212adc <__umoddi3+0x44c>
 3212c08:	147fa22e 	bgeu	r2,r17,3212a94 <__umoddi3+0x404>
 3212c0c:	e73fffc4 	addi	fp,fp,-1
 3212c10:	15c5883a 	add	r2,r2,r23
 3212c14:	003f9f06 	br	3212a94 <__umoddi3+0x404>
 3212c18:	147f692e 	bgeu	r2,r17,32129c0 <__umoddi3+0x330>
 3212c1c:	1405883a 	add	r2,r2,r16
 3212c20:	003f6706 	br	32129c0 <__umoddi3+0x330>
 3212c24:	1405883a 	add	r2,r2,r16
 3212c28:	003f1906 	br	3212890 <__umoddi3+0x200>
 3212c2c:	1405883a 	add	r2,r2,r16
 3212c30:	003ec906 	br	3212758 <__umoddi3+0xc8>
 3212c34:	b13fcc36 	bltu	r22,r4,3212b68 <__umoddi3+0x4d8>
 3212c38:	000b883a 	mov	r5,zero
 3212c3c:	003fd106 	br	3212b84 <__umoddi3+0x4f4>

03212c40 <__nesf2>:
 3212c40:	defff304 	addi	sp,sp,-52
 3212c44:	dc400b15 	stw	r17,44(sp)
 3212c48:	dc400204 	addi	r17,sp,8
 3212c4c:	dc000a15 	stw	r16,40(sp)
 3212c50:	d9000015 	stw	r4,0(sp)
 3212c54:	d9400115 	stw	r5,4(sp)
 3212c58:	d809883a 	mov	r4,sp
 3212c5c:	880b883a 	mov	r5,r17
 3212c60:	dc000604 	addi	r16,sp,24
 3212c64:	dfc00c15 	stw	ra,48(sp)
 3212c68:	32140500 	call	3214050 <__unpack_f>
 3212c6c:	d9000104 	addi	r4,sp,4
 3212c70:	800b883a 	mov	r5,r16
 3212c74:	32140500 	call	3214050 <__unpack_f>
 3212c78:	d8800217 	ldw	r2,8(sp)
 3212c7c:	00c00044 	movi	r3,1
 3212c80:	180d883a 	mov	r6,r3
 3212c84:	1880062e 	bgeu	r3,r2,3212ca0 <__nesf2+0x60>
 3212c88:	d8800617 	ldw	r2,24(sp)
 3212c8c:	8809883a 	mov	r4,r17
 3212c90:	800b883a 	mov	r5,r16
 3212c94:	1880022e 	bgeu	r3,r2,3212ca0 <__nesf2+0x60>
 3212c98:	32141180 	call	3214118 <__fpcmp_parts_f>
 3212c9c:	100d883a 	mov	r6,r2
 3212ca0:	3005883a 	mov	r2,r6
 3212ca4:	dfc00c17 	ldw	ra,48(sp)
 3212ca8:	dc400b17 	ldw	r17,44(sp)
 3212cac:	dc000a17 	ldw	r16,40(sp)
 3212cb0:	dec00d04 	addi	sp,sp,52
 3212cb4:	f800283a 	ret

03212cb8 <__gtsf2>:
 3212cb8:	defff304 	addi	sp,sp,-52
 3212cbc:	dc400b15 	stw	r17,44(sp)
 3212cc0:	dc400204 	addi	r17,sp,8
 3212cc4:	dc000a15 	stw	r16,40(sp)
 3212cc8:	d9000015 	stw	r4,0(sp)
 3212ccc:	d9400115 	stw	r5,4(sp)
 3212cd0:	d809883a 	mov	r4,sp
 3212cd4:	880b883a 	mov	r5,r17
 3212cd8:	dc000604 	addi	r16,sp,24
 3212cdc:	dfc00c15 	stw	ra,48(sp)
 3212ce0:	32140500 	call	3214050 <__unpack_f>
 3212ce4:	d9000104 	addi	r4,sp,4
 3212ce8:	800b883a 	mov	r5,r16
 3212cec:	32140500 	call	3214050 <__unpack_f>
 3212cf0:	d8800217 	ldw	r2,8(sp)
 3212cf4:	00c00044 	movi	r3,1
 3212cf8:	01bfffc4 	movi	r6,-1
 3212cfc:	1880062e 	bgeu	r3,r2,3212d18 <__gtsf2+0x60>
 3212d00:	d8800617 	ldw	r2,24(sp)
 3212d04:	8809883a 	mov	r4,r17
 3212d08:	800b883a 	mov	r5,r16
 3212d0c:	1880022e 	bgeu	r3,r2,3212d18 <__gtsf2+0x60>
 3212d10:	32141180 	call	3214118 <__fpcmp_parts_f>
 3212d14:	100d883a 	mov	r6,r2
 3212d18:	3005883a 	mov	r2,r6
 3212d1c:	dfc00c17 	ldw	ra,48(sp)
 3212d20:	dc400b17 	ldw	r17,44(sp)
 3212d24:	dc000a17 	ldw	r16,40(sp)
 3212d28:	dec00d04 	addi	sp,sp,52
 3212d2c:	f800283a 	ret

03212d30 <__ltsf2>:
 3212d30:	defff304 	addi	sp,sp,-52
 3212d34:	dc400b15 	stw	r17,44(sp)
 3212d38:	dc400204 	addi	r17,sp,8
 3212d3c:	dc000a15 	stw	r16,40(sp)
 3212d40:	d9000015 	stw	r4,0(sp)
 3212d44:	d9400115 	stw	r5,4(sp)
 3212d48:	d809883a 	mov	r4,sp
 3212d4c:	880b883a 	mov	r5,r17
 3212d50:	dc000604 	addi	r16,sp,24
 3212d54:	dfc00c15 	stw	ra,48(sp)
 3212d58:	32140500 	call	3214050 <__unpack_f>
 3212d5c:	d9000104 	addi	r4,sp,4
 3212d60:	800b883a 	mov	r5,r16
 3212d64:	32140500 	call	3214050 <__unpack_f>
 3212d68:	d8800217 	ldw	r2,8(sp)
 3212d6c:	00c00044 	movi	r3,1
 3212d70:	180d883a 	mov	r6,r3
 3212d74:	1880062e 	bgeu	r3,r2,3212d90 <__ltsf2+0x60>
 3212d78:	d8800617 	ldw	r2,24(sp)
 3212d7c:	8809883a 	mov	r4,r17
 3212d80:	800b883a 	mov	r5,r16
 3212d84:	1880022e 	bgeu	r3,r2,3212d90 <__ltsf2+0x60>
 3212d88:	32141180 	call	3214118 <__fpcmp_parts_f>
 3212d8c:	100d883a 	mov	r6,r2
 3212d90:	3005883a 	mov	r2,r6
 3212d94:	dfc00c17 	ldw	ra,48(sp)
 3212d98:	dc400b17 	ldw	r17,44(sp)
 3212d9c:	dc000a17 	ldw	r16,40(sp)
 3212da0:	dec00d04 	addi	sp,sp,52
 3212da4:	f800283a 	ret

03212da8 <_fpadd_parts>:
 3212da8:	defff804 	addi	sp,sp,-32
 3212dac:	dcc00315 	stw	r19,12(sp)
 3212db0:	2027883a 	mov	r19,r4
 3212db4:	21000017 	ldw	r4,0(r4)
 3212db8:	00c00044 	movi	r3,1
 3212dbc:	dd400515 	stw	r21,20(sp)
 3212dc0:	dd000415 	stw	r20,16(sp)
 3212dc4:	ddc00715 	stw	r23,28(sp)
 3212dc8:	dd800615 	stw	r22,24(sp)
 3212dcc:	dc800215 	stw	r18,8(sp)
 3212dd0:	dc400115 	stw	r17,4(sp)
 3212dd4:	dc000015 	stw	r16,0(sp)
 3212dd8:	282b883a 	mov	r21,r5
 3212ddc:	3029883a 	mov	r20,r6
 3212de0:	1900632e 	bgeu	r3,r4,3212f70 <_fpadd_parts+0x1c8>
 3212de4:	28800017 	ldw	r2,0(r5)
 3212de8:	1880812e 	bgeu	r3,r2,3212ff0 <_fpadd_parts+0x248>
 3212dec:	00c00104 	movi	r3,4
 3212df0:	20c0dc26 	beq	r4,r3,3213164 <_fpadd_parts+0x3bc>
 3212df4:	10c07e26 	beq	r2,r3,3212ff0 <_fpadd_parts+0x248>
 3212df8:	00c00084 	movi	r3,2
 3212dfc:	10c06726 	beq	r2,r3,3212f9c <_fpadd_parts+0x1f4>
 3212e00:	20c07b26 	beq	r4,r3,3212ff0 <_fpadd_parts+0x248>
 3212e04:	9dc00217 	ldw	r23,8(r19)
 3212e08:	28c00217 	ldw	r3,8(r5)
 3212e0c:	9c400317 	ldw	r17,12(r19)
 3212e10:	2bc00317 	ldw	r15,12(r5)
 3212e14:	b8cdc83a 	sub	r6,r23,r3
 3212e18:	9c800417 	ldw	r18,16(r19)
 3212e1c:	2c000417 	ldw	r16,16(r5)
 3212e20:	3009883a 	mov	r4,r6
 3212e24:	30009716 	blt	r6,zero,3213084 <_fpadd_parts+0x2dc>
 3212e28:	00800fc4 	movi	r2,63
 3212e2c:	11806b16 	blt	r2,r6,3212fdc <_fpadd_parts+0x234>
 3212e30:	0100a40e 	bge	zero,r4,32130c4 <_fpadd_parts+0x31c>
 3212e34:	35bff804 	addi	r22,r6,-32
 3212e38:	b000bc16 	blt	r22,zero,321312c <_fpadd_parts+0x384>
 3212e3c:	8596d83a 	srl	r11,r16,r22
 3212e40:	0019883a 	mov	r12,zero
 3212e44:	0013883a 	mov	r9,zero
 3212e48:	01000044 	movi	r4,1
 3212e4c:	0015883a 	mov	r10,zero
 3212e50:	b000be16 	blt	r22,zero,321314c <_fpadd_parts+0x3a4>
 3212e54:	2590983a 	sll	r8,r4,r22
 3212e58:	000f883a 	mov	r7,zero
 3212e5c:	00bfffc4 	movi	r2,-1
 3212e60:	3889883a 	add	r4,r7,r2
 3212e64:	408b883a 	add	r5,r8,r2
 3212e68:	21cd803a 	cmpltu	r6,r4,r7
 3212e6c:	314b883a 	add	r5,r6,r5
 3212e70:	7904703a 	and	r2,r15,r4
 3212e74:	8146703a 	and	r3,r16,r5
 3212e78:	10c4b03a 	or	r2,r2,r3
 3212e7c:	10000226 	beq	r2,zero,3212e88 <_fpadd_parts+0xe0>
 3212e80:	02400044 	movi	r9,1
 3212e84:	0015883a 	mov	r10,zero
 3212e88:	5a5eb03a 	or	r15,r11,r9
 3212e8c:	62a0b03a 	or	r16,r12,r10
 3212e90:	99400117 	ldw	r5,4(r19)
 3212e94:	a8800117 	ldw	r2,4(r21)
 3212e98:	28806e26 	beq	r5,r2,3213054 <_fpadd_parts+0x2ac>
 3212e9c:	28006626 	beq	r5,zero,3213038 <_fpadd_parts+0x290>
 3212ea0:	7c45c83a 	sub	r2,r15,r17
 3212ea4:	7889803a 	cmpltu	r4,r15,r2
 3212ea8:	8487c83a 	sub	r3,r16,r18
 3212eac:	1909c83a 	sub	r4,r3,r4
 3212eb0:	100d883a 	mov	r6,r2
 3212eb4:	200f883a 	mov	r7,r4
 3212eb8:	38007716 	blt	r7,zero,3213098 <_fpadd_parts+0x2f0>
 3212ebc:	a5c00215 	stw	r23,8(r20)
 3212ec0:	a1c00415 	stw	r7,16(r20)
 3212ec4:	a0000115 	stw	zero,4(r20)
 3212ec8:	a1800315 	stw	r6,12(r20)
 3212ecc:	a2000317 	ldw	r8,12(r20)
 3212ed0:	a2400417 	ldw	r9,16(r20)
 3212ed4:	00bfffc4 	movi	r2,-1
 3212ed8:	408b883a 	add	r5,r8,r2
 3212edc:	2a09803a 	cmpltu	r4,r5,r8
 3212ee0:	488d883a 	add	r6,r9,r2
 3212ee4:	01c40034 	movhi	r7,4096
 3212ee8:	39ffffc4 	addi	r7,r7,-1
 3212eec:	218d883a 	add	r6,r4,r6
 3212ef0:	39801736 	bltu	r7,r6,3212f50 <_fpadd_parts+0x1a8>
 3212ef4:	31c06526 	beq	r6,r7,321308c <_fpadd_parts+0x2e4>
 3212ef8:	a3000217 	ldw	r12,8(r20)
 3212efc:	4209883a 	add	r4,r8,r8
 3212f00:	00bfffc4 	movi	r2,-1
 3212f04:	220f803a 	cmpltu	r7,r4,r8
 3212f08:	4a4b883a 	add	r5,r9,r9
 3212f0c:	394f883a 	add	r7,r7,r5
 3212f10:	2095883a 	add	r10,r4,r2
 3212f14:	3897883a 	add	r11,r7,r2
 3212f18:	510d803a 	cmpltu	r6,r10,r4
 3212f1c:	6099883a 	add	r12,r12,r2
 3212f20:	32d7883a 	add	r11,r6,r11
 3212f24:	00840034 	movhi	r2,4096
 3212f28:	10bfffc4 	addi	r2,r2,-1
 3212f2c:	2011883a 	mov	r8,r4
 3212f30:	3813883a 	mov	r9,r7
 3212f34:	a1000315 	stw	r4,12(r20)
 3212f38:	a1c00415 	stw	r7,16(r20)
 3212f3c:	a3000215 	stw	r12,8(r20)
 3212f40:	12c00336 	bltu	r2,r11,3212f50 <_fpadd_parts+0x1a8>
 3212f44:	58bfed1e 	bne	r11,r2,3212efc <_fpadd_parts+0x154>
 3212f48:	00bfff84 	movi	r2,-2
 3212f4c:	12bfeb2e 	bgeu	r2,r10,3212efc <_fpadd_parts+0x154>
 3212f50:	a2800417 	ldw	r10,16(r20)
 3212f54:	008000c4 	movi	r2,3
 3212f58:	00c80034 	movhi	r3,8192
 3212f5c:	18ffffc4 	addi	r3,r3,-1
 3212f60:	a2400317 	ldw	r9,12(r20)
 3212f64:	a0800015 	stw	r2,0(r20)
 3212f68:	1a802336 	bltu	r3,r10,3212ff8 <_fpadd_parts+0x250>
 3212f6c:	a027883a 	mov	r19,r20
 3212f70:	9805883a 	mov	r2,r19
 3212f74:	ddc00717 	ldw	r23,28(sp)
 3212f78:	dd800617 	ldw	r22,24(sp)
 3212f7c:	dd400517 	ldw	r21,20(sp)
 3212f80:	dd000417 	ldw	r20,16(sp)
 3212f84:	dcc00317 	ldw	r19,12(sp)
 3212f88:	dc800217 	ldw	r18,8(sp)
 3212f8c:	dc400117 	ldw	r17,4(sp)
 3212f90:	dc000017 	ldw	r16,0(sp)
 3212f94:	dec00804 	addi	sp,sp,32
 3212f98:	f800283a 	ret
 3212f9c:	20fff41e 	bne	r4,r3,3212f70 <_fpadd_parts+0x1c8>
 3212fa0:	31000015 	stw	r4,0(r6)
 3212fa4:	98800117 	ldw	r2,4(r19)
 3212fa8:	30800115 	stw	r2,4(r6)
 3212fac:	98c00217 	ldw	r3,8(r19)
 3212fb0:	30c00215 	stw	r3,8(r6)
 3212fb4:	98800317 	ldw	r2,12(r19)
 3212fb8:	30800315 	stw	r2,12(r6)
 3212fbc:	98c00417 	ldw	r3,16(r19)
 3212fc0:	30c00415 	stw	r3,16(r6)
 3212fc4:	98800117 	ldw	r2,4(r19)
 3212fc8:	28c00117 	ldw	r3,4(r5)
 3212fcc:	3027883a 	mov	r19,r6
 3212fd0:	10c4703a 	and	r2,r2,r3
 3212fd4:	30800115 	stw	r2,4(r6)
 3212fd8:	003fe506 	br	3212f70 <_fpadd_parts+0x1c8>
 3212fdc:	1dc02616 	blt	r3,r23,3213078 <_fpadd_parts+0x2d0>
 3212fe0:	0023883a 	mov	r17,zero
 3212fe4:	182f883a 	mov	r23,r3
 3212fe8:	0025883a 	mov	r18,zero
 3212fec:	003fa806 	br	3212e90 <_fpadd_parts+0xe8>
 3212ff0:	a827883a 	mov	r19,r21
 3212ff4:	003fde06 	br	3212f70 <_fpadd_parts+0x1c8>
 3212ff8:	01800044 	movi	r6,1
 3212ffc:	500497fa 	slli	r2,r10,31
 3213000:	4808d07a 	srli	r4,r9,1
 3213004:	518ad83a 	srl	r5,r10,r6
 3213008:	a2000217 	ldw	r8,8(r20)
 321300c:	1108b03a 	or	r4,r2,r4
 3213010:	0007883a 	mov	r3,zero
 3213014:	4984703a 	and	r2,r9,r6
 3213018:	208cb03a 	or	r6,r4,r2
 321301c:	28ceb03a 	or	r7,r5,r3
 3213020:	42000044 	addi	r8,r8,1
 3213024:	a027883a 	mov	r19,r20
 3213028:	a1c00415 	stw	r7,16(r20)
 321302c:	a2000215 	stw	r8,8(r20)
 3213030:	a1800315 	stw	r6,12(r20)
 3213034:	003fce06 	br	3212f70 <_fpadd_parts+0x1c8>
 3213038:	8bc5c83a 	sub	r2,r17,r15
 321303c:	8889803a 	cmpltu	r4,r17,r2
 3213040:	9407c83a 	sub	r3,r18,r16
 3213044:	1909c83a 	sub	r4,r3,r4
 3213048:	100d883a 	mov	r6,r2
 321304c:	200f883a 	mov	r7,r4
 3213050:	003f9906 	br	3212eb8 <_fpadd_parts+0x110>
 3213054:	7c45883a 	add	r2,r15,r17
 3213058:	13c9803a 	cmpltu	r4,r2,r15
 321305c:	8487883a 	add	r3,r16,r18
 3213060:	20c9883a 	add	r4,r4,r3
 3213064:	a1400115 	stw	r5,4(r20)
 3213068:	a5c00215 	stw	r23,8(r20)
 321306c:	a0800315 	stw	r2,12(r20)
 3213070:	a1000415 	stw	r4,16(r20)
 3213074:	003fb606 	br	3212f50 <_fpadd_parts+0x1a8>
 3213078:	001f883a 	mov	r15,zero
 321307c:	0021883a 	mov	r16,zero
 3213080:	003f8306 	br	3212e90 <_fpadd_parts+0xe8>
 3213084:	018dc83a 	sub	r6,zero,r6
 3213088:	003f6706 	br	3212e28 <_fpadd_parts+0x80>
 321308c:	00bfff84 	movi	r2,-2
 3213090:	117faf36 	bltu	r2,r5,3212f50 <_fpadd_parts+0x1a8>
 3213094:	003f9806 	br	3212ef8 <_fpadd_parts+0x150>
 3213098:	0005883a 	mov	r2,zero
 321309c:	1189c83a 	sub	r4,r2,r6
 32130a0:	1105803a 	cmpltu	r2,r2,r4
 32130a4:	01cbc83a 	sub	r5,zero,r7
 32130a8:	2885c83a 	sub	r2,r5,r2
 32130ac:	01800044 	movi	r6,1
 32130b0:	a1800115 	stw	r6,4(r20)
 32130b4:	a5c00215 	stw	r23,8(r20)
 32130b8:	a1000315 	stw	r4,12(r20)
 32130bc:	a0800415 	stw	r2,16(r20)
 32130c0:	003f8206 	br	3212ecc <_fpadd_parts+0x124>
 32130c4:	203f7226 	beq	r4,zero,3212e90 <_fpadd_parts+0xe8>
 32130c8:	35bff804 	addi	r22,r6,-32
 32130cc:	b9af883a 	add	r23,r23,r6
 32130d0:	b0003116 	blt	r22,zero,3213198 <_fpadd_parts+0x3f0>
 32130d4:	959ad83a 	srl	r13,r18,r22
 32130d8:	001d883a 	mov	r14,zero
 32130dc:	000f883a 	mov	r7,zero
 32130e0:	01000044 	movi	r4,1
 32130e4:	0011883a 	mov	r8,zero
 32130e8:	b0002516 	blt	r22,zero,3213180 <_fpadd_parts+0x3d8>
 32130ec:	2594983a 	sll	r10,r4,r22
 32130f0:	0013883a 	mov	r9,zero
 32130f4:	00bfffc4 	movi	r2,-1
 32130f8:	4889883a 	add	r4,r9,r2
 32130fc:	508b883a 	add	r5,r10,r2
 3213100:	224d803a 	cmpltu	r6,r4,r9
 3213104:	314b883a 	add	r5,r6,r5
 3213108:	8904703a 	and	r2,r17,r4
 321310c:	9146703a 	and	r3,r18,r5
 3213110:	10c4b03a 	or	r2,r2,r3
 3213114:	10000226 	beq	r2,zero,3213120 <_fpadd_parts+0x378>
 3213118:	01c00044 	movi	r7,1
 321311c:	0011883a 	mov	r8,zero
 3213120:	69e2b03a 	or	r17,r13,r7
 3213124:	7224b03a 	or	r18,r14,r8
 3213128:	003f5906 	br	3212e90 <_fpadd_parts+0xe8>
 321312c:	8407883a 	add	r3,r16,r16
 3213130:	008007c4 	movi	r2,31
 3213134:	1185c83a 	sub	r2,r2,r6
 3213138:	1886983a 	sll	r3,r3,r2
 321313c:	7996d83a 	srl	r11,r15,r6
 3213140:	8198d83a 	srl	r12,r16,r6
 3213144:	1ad6b03a 	or	r11,r3,r11
 3213148:	003f3e06 	br	3212e44 <_fpadd_parts+0x9c>
 321314c:	2006d07a 	srli	r3,r4,1
 3213150:	008007c4 	movi	r2,31
 3213154:	1185c83a 	sub	r2,r2,r6
 3213158:	1890d83a 	srl	r8,r3,r2
 321315c:	218e983a 	sll	r7,r4,r6
 3213160:	003f3e06 	br	3212e5c <_fpadd_parts+0xb4>
 3213164:	113f821e 	bne	r2,r4,3212f70 <_fpadd_parts+0x1c8>
 3213168:	28c00117 	ldw	r3,4(r5)
 321316c:	98800117 	ldw	r2,4(r19)
 3213170:	10ff7f26 	beq	r2,r3,3212f70 <_fpadd_parts+0x1c8>
 3213174:	04c0c974 	movhi	r19,805
 3213178:	9cf93104 	addi	r19,r19,-6972
 321317c:	003f7c06 	br	3212f70 <_fpadd_parts+0x1c8>
 3213180:	2006d07a 	srli	r3,r4,1
 3213184:	008007c4 	movi	r2,31
 3213188:	1185c83a 	sub	r2,r2,r6
 321318c:	1894d83a 	srl	r10,r3,r2
 3213190:	2192983a 	sll	r9,r4,r6
 3213194:	003fd706 	br	32130f4 <_fpadd_parts+0x34c>
 3213198:	9487883a 	add	r3,r18,r18
 321319c:	008007c4 	movi	r2,31
 32131a0:	1185c83a 	sub	r2,r2,r6
 32131a4:	1886983a 	sll	r3,r3,r2
 32131a8:	899ad83a 	srl	r13,r17,r6
 32131ac:	919cd83a 	srl	r14,r18,r6
 32131b0:	1b5ab03a 	or	r13,r3,r13
 32131b4:	003fc906 	br	32130dc <_fpadd_parts+0x334>

032131b8 <__subdf3>:
 32131b8:	deffea04 	addi	sp,sp,-88
 32131bc:	dcc01415 	stw	r19,80(sp)
 32131c0:	dcc00404 	addi	r19,sp,16
 32131c4:	2011883a 	mov	r8,r4
 32131c8:	2813883a 	mov	r9,r5
 32131cc:	dc401315 	stw	r17,76(sp)
 32131d0:	d809883a 	mov	r4,sp
 32131d4:	980b883a 	mov	r5,r19
 32131d8:	dc400904 	addi	r17,sp,36
 32131dc:	dfc01515 	stw	ra,84(sp)
 32131e0:	da400115 	stw	r9,4(sp)
 32131e4:	d9c00315 	stw	r7,12(sp)
 32131e8:	da000015 	stw	r8,0(sp)
 32131ec:	d9800215 	stw	r6,8(sp)
 32131f0:	32145000 	call	3214500 <__unpack_d>
 32131f4:	d9000204 	addi	r4,sp,8
 32131f8:	880b883a 	mov	r5,r17
 32131fc:	32145000 	call	3214500 <__unpack_d>
 3213200:	d8800a17 	ldw	r2,40(sp)
 3213204:	880b883a 	mov	r5,r17
 3213208:	9809883a 	mov	r4,r19
 321320c:	d9800e04 	addi	r6,sp,56
 3213210:	1080005c 	xori	r2,r2,1
 3213214:	d8800a15 	stw	r2,40(sp)
 3213218:	3212da80 	call	3212da8 <_fpadd_parts>
 321321c:	1009883a 	mov	r4,r2
 3213220:	32141ec0 	call	32141ec <__pack_d>
 3213224:	dfc01517 	ldw	ra,84(sp)
 3213228:	dcc01417 	ldw	r19,80(sp)
 321322c:	dc401317 	ldw	r17,76(sp)
 3213230:	dec01604 	addi	sp,sp,88
 3213234:	f800283a 	ret

03213238 <__adddf3>:
 3213238:	deffea04 	addi	sp,sp,-88
 321323c:	dcc01415 	stw	r19,80(sp)
 3213240:	dcc00404 	addi	r19,sp,16
 3213244:	2011883a 	mov	r8,r4
 3213248:	2813883a 	mov	r9,r5
 321324c:	dc401315 	stw	r17,76(sp)
 3213250:	d809883a 	mov	r4,sp
 3213254:	980b883a 	mov	r5,r19
 3213258:	dc400904 	addi	r17,sp,36
 321325c:	dfc01515 	stw	ra,84(sp)
 3213260:	da400115 	stw	r9,4(sp)
 3213264:	d9c00315 	stw	r7,12(sp)
 3213268:	da000015 	stw	r8,0(sp)
 321326c:	d9800215 	stw	r6,8(sp)
 3213270:	32145000 	call	3214500 <__unpack_d>
 3213274:	d9000204 	addi	r4,sp,8
 3213278:	880b883a 	mov	r5,r17
 321327c:	32145000 	call	3214500 <__unpack_d>
 3213280:	d9800e04 	addi	r6,sp,56
 3213284:	9809883a 	mov	r4,r19
 3213288:	880b883a 	mov	r5,r17
 321328c:	3212da80 	call	3212da8 <_fpadd_parts>
 3213290:	1009883a 	mov	r4,r2
 3213294:	32141ec0 	call	32141ec <__pack_d>
 3213298:	dfc01517 	ldw	ra,84(sp)
 321329c:	dcc01417 	ldw	r19,80(sp)
 32132a0:	dc401317 	ldw	r17,76(sp)
 32132a4:	dec01604 	addi	sp,sp,88
 32132a8:	f800283a 	ret

032132ac <__muldf3>:
 32132ac:	deffe004 	addi	sp,sp,-128
 32132b0:	dc401815 	stw	r17,96(sp)
 32132b4:	dc400404 	addi	r17,sp,16
 32132b8:	2011883a 	mov	r8,r4
 32132bc:	2813883a 	mov	r9,r5
 32132c0:	dc001715 	stw	r16,92(sp)
 32132c4:	d809883a 	mov	r4,sp
 32132c8:	880b883a 	mov	r5,r17
 32132cc:	dc000904 	addi	r16,sp,36
 32132d0:	dfc01f15 	stw	ra,124(sp)
 32132d4:	da400115 	stw	r9,4(sp)
 32132d8:	d9c00315 	stw	r7,12(sp)
 32132dc:	da000015 	stw	r8,0(sp)
 32132e0:	d9800215 	stw	r6,8(sp)
 32132e4:	ddc01e15 	stw	r23,120(sp)
 32132e8:	dd801d15 	stw	r22,116(sp)
 32132ec:	dd401c15 	stw	r21,112(sp)
 32132f0:	dd001b15 	stw	r20,108(sp)
 32132f4:	dcc01a15 	stw	r19,104(sp)
 32132f8:	dc801915 	stw	r18,100(sp)
 32132fc:	32145000 	call	3214500 <__unpack_d>
 3213300:	d9000204 	addi	r4,sp,8
 3213304:	800b883a 	mov	r5,r16
 3213308:	32145000 	call	3214500 <__unpack_d>
 321330c:	d9000417 	ldw	r4,16(sp)
 3213310:	00800044 	movi	r2,1
 3213314:	1100102e 	bgeu	r2,r4,3213358 <__muldf3+0xac>
 3213318:	d8c00917 	ldw	r3,36(sp)
 321331c:	10c0062e 	bgeu	r2,r3,3213338 <__muldf3+0x8c>
 3213320:	00800104 	movi	r2,4
 3213324:	20800a26 	beq	r4,r2,3213350 <__muldf3+0xa4>
 3213328:	1880cc26 	beq	r3,r2,321365c <__muldf3+0x3b0>
 321332c:	00800084 	movi	r2,2
 3213330:	20800926 	beq	r4,r2,3213358 <__muldf3+0xac>
 3213334:	1880191e 	bne	r3,r2,321339c <__muldf3+0xf0>
 3213338:	d8c00a17 	ldw	r3,40(sp)
 321333c:	d8800517 	ldw	r2,20(sp)
 3213340:	8009883a 	mov	r4,r16
 3213344:	10c4c03a 	cmpne	r2,r2,r3
 3213348:	d8800a15 	stw	r2,40(sp)
 321334c:	00000706 	br	321336c <__muldf3+0xc0>
 3213350:	00800084 	movi	r2,2
 3213354:	1880c326 	beq	r3,r2,3213664 <__muldf3+0x3b8>
 3213358:	d8800517 	ldw	r2,20(sp)
 321335c:	d8c00a17 	ldw	r3,40(sp)
 3213360:	8809883a 	mov	r4,r17
 3213364:	10c4c03a 	cmpne	r2,r2,r3
 3213368:	d8800515 	stw	r2,20(sp)
 321336c:	32141ec0 	call	32141ec <__pack_d>
 3213370:	dfc01f17 	ldw	ra,124(sp)
 3213374:	ddc01e17 	ldw	r23,120(sp)
 3213378:	dd801d17 	ldw	r22,116(sp)
 321337c:	dd401c17 	ldw	r21,112(sp)
 3213380:	dd001b17 	ldw	r20,108(sp)
 3213384:	dcc01a17 	ldw	r19,104(sp)
 3213388:	dc801917 	ldw	r18,100(sp)
 321338c:	dc401817 	ldw	r17,96(sp)
 3213390:	dc001717 	ldw	r16,92(sp)
 3213394:	dec02004 	addi	sp,sp,128
 3213398:	f800283a 	ret
 321339c:	dd800717 	ldw	r22,28(sp)
 32133a0:	dc800c17 	ldw	r18,48(sp)
 32133a4:	002b883a 	mov	r21,zero
 32133a8:	0023883a 	mov	r17,zero
 32133ac:	a80b883a 	mov	r5,r21
 32133b0:	b00d883a 	mov	r6,r22
 32133b4:	880f883a 	mov	r7,r17
 32133b8:	ddc00817 	ldw	r23,32(sp)
 32133bc:	dcc00d17 	ldw	r19,52(sp)
 32133c0:	9009883a 	mov	r4,r18
 32133c4:	3211f780 	call	3211f78 <__muldi3>
 32133c8:	001b883a 	mov	r13,zero
 32133cc:	680f883a 	mov	r7,r13
 32133d0:	b009883a 	mov	r4,r22
 32133d4:	000b883a 	mov	r5,zero
 32133d8:	980d883a 	mov	r6,r19
 32133dc:	b82d883a 	mov	r22,r23
 32133e0:	002f883a 	mov	r23,zero
 32133e4:	db401615 	stw	r13,88(sp)
 32133e8:	d8801315 	stw	r2,76(sp)
 32133ec:	d8c01415 	stw	r3,80(sp)
 32133f0:	dcc01515 	stw	r19,84(sp)
 32133f4:	3211f780 	call	3211f78 <__muldi3>
 32133f8:	b00d883a 	mov	r6,r22
 32133fc:	000b883a 	mov	r5,zero
 3213400:	9009883a 	mov	r4,r18
 3213404:	b80f883a 	mov	r7,r23
 3213408:	1021883a 	mov	r16,r2
 321340c:	1823883a 	mov	r17,r3
 3213410:	3211f780 	call	3211f78 <__muldi3>
 3213414:	8085883a 	add	r2,r16,r2
 3213418:	140d803a 	cmpltu	r6,r2,r16
 321341c:	88c7883a 	add	r3,r17,r3
 3213420:	30cd883a 	add	r6,r6,r3
 3213424:	1029883a 	mov	r20,r2
 3213428:	302b883a 	mov	r21,r6
 321342c:	da801317 	ldw	r10,76(sp)
 3213430:	dac01417 	ldw	r11,80(sp)
 3213434:	db001517 	ldw	r12,84(sp)
 3213438:	db401617 	ldw	r13,88(sp)
 321343c:	3440612e 	bgeu	r6,r17,32135c4 <__muldf3+0x318>
 3213440:	0009883a 	mov	r4,zero
 3213444:	5105883a 	add	r2,r10,r4
 3213448:	128d803a 	cmpltu	r6,r2,r10
 321344c:	5d07883a 	add	r3,r11,r20
 3213450:	30cd883a 	add	r6,r6,r3
 3213454:	0021883a 	mov	r16,zero
 3213458:	04400044 	movi	r17,1
 321345c:	1025883a 	mov	r18,r2
 3213460:	3027883a 	mov	r19,r6
 3213464:	32c06236 	bltu	r6,r11,32135f0 <__muldf3+0x344>
 3213468:	59807a26 	beq	r11,r6,3213654 <__muldf3+0x3a8>
 321346c:	680b883a 	mov	r5,r13
 3213470:	b80f883a 	mov	r7,r23
 3213474:	6009883a 	mov	r4,r12
 3213478:	b00d883a 	mov	r6,r22
 321347c:	3211f780 	call	3211f78 <__muldi3>
 3213480:	1009883a 	mov	r4,r2
 3213484:	000f883a 	mov	r7,zero
 3213488:	1545883a 	add	r2,r2,r21
 321348c:	1111803a 	cmpltu	r8,r2,r4
 3213490:	19c7883a 	add	r3,r3,r7
 3213494:	40c7883a 	add	r3,r8,r3
 3213498:	88cb883a 	add	r5,r17,r3
 321349c:	d8c00617 	ldw	r3,24(sp)
 32134a0:	8089883a 	add	r4,r16,r2
 32134a4:	d8800b17 	ldw	r2,44(sp)
 32134a8:	18c00104 	addi	r3,r3,4
 32134ac:	240d803a 	cmpltu	r6,r4,r16
 32134b0:	10c7883a 	add	r3,r2,r3
 32134b4:	2013883a 	mov	r9,r4
 32134b8:	d8800a17 	ldw	r2,40(sp)
 32134bc:	d9000517 	ldw	r4,20(sp)
 32134c0:	314d883a 	add	r6,r6,r5
 32134c4:	3015883a 	mov	r10,r6
 32134c8:	2088c03a 	cmpne	r4,r4,r2
 32134cc:	00880034 	movhi	r2,8192
 32134d0:	10bfffc4 	addi	r2,r2,-1
 32134d4:	d9000f15 	stw	r4,60(sp)
 32134d8:	d8c01015 	stw	r3,64(sp)
 32134dc:	1180162e 	bgeu	r2,r6,3213538 <__muldf3+0x28c>
 32134e0:	1811883a 	mov	r8,r3
 32134e4:	101f883a 	mov	r15,r2
 32134e8:	980497fa 	slli	r2,r19,31
 32134ec:	9016d07a 	srli	r11,r18,1
 32134f0:	500697fa 	slli	r3,r10,31
 32134f4:	480cd07a 	srli	r6,r9,1
 32134f8:	500ed07a 	srli	r7,r10,1
 32134fc:	12d6b03a 	or	r11,r2,r11
 3213500:	00800044 	movi	r2,1
 3213504:	198cb03a 	or	r6,r3,r6
 3213508:	4888703a 	and	r4,r9,r2
 321350c:	9818d07a 	srli	r12,r19,1
 3213510:	001b883a 	mov	r13,zero
 3213514:	03a00034 	movhi	r14,32768
 3213518:	3013883a 	mov	r9,r6
 321351c:	3815883a 	mov	r10,r7
 3213520:	4091883a 	add	r8,r8,r2
 3213524:	20000226 	beq	r4,zero,3213530 <__muldf3+0x284>
 3213528:	5b64b03a 	or	r18,r11,r13
 321352c:	63a6b03a 	or	r19,r12,r14
 3213530:	7abfed36 	bltu	r15,r10,32134e8 <__muldf3+0x23c>
 3213534:	da001015 	stw	r8,64(sp)
 3213538:	00840034 	movhi	r2,4096
 321353c:	10bfffc4 	addi	r2,r2,-1
 3213540:	12801436 	bltu	r2,r10,3213594 <__muldf3+0x2e8>
 3213544:	da001017 	ldw	r8,64(sp)
 3213548:	101f883a 	mov	r15,r2
 321354c:	4a45883a 	add	r2,r9,r9
 3213550:	124d803a 	cmpltu	r6,r2,r9
 3213554:	5287883a 	add	r3,r10,r10
 3213558:	9497883a 	add	r11,r18,r18
 321355c:	5c8f803a 	cmpltu	r7,r11,r18
 3213560:	9cd9883a 	add	r12,r19,r19
 3213564:	01000044 	movi	r4,1
 3213568:	30cd883a 	add	r6,r6,r3
 321356c:	3b0f883a 	add	r7,r7,r12
 3213570:	423fffc4 	addi	r8,r8,-1
 3213574:	1013883a 	mov	r9,r2
 3213578:	3015883a 	mov	r10,r6
 321357c:	111ab03a 	or	r13,r2,r4
 3213580:	98003016 	blt	r19,zero,3213644 <__muldf3+0x398>
 3213584:	5825883a 	mov	r18,r11
 3213588:	3827883a 	mov	r19,r7
 321358c:	7abfef2e 	bgeu	r15,r10,321354c <__muldf3+0x2a0>
 3213590:	da001015 	stw	r8,64(sp)
 3213594:	00803fc4 	movi	r2,255
 3213598:	488e703a 	and	r7,r9,r2
 321359c:	00802004 	movi	r2,128
 32135a0:	0007883a 	mov	r3,zero
 32135a4:	0011883a 	mov	r8,zero
 32135a8:	38801826 	beq	r7,r2,321360c <__muldf3+0x360>
 32135ac:	008000c4 	movi	r2,3
 32135b0:	d9000e04 	addi	r4,sp,56
 32135b4:	da801215 	stw	r10,72(sp)
 32135b8:	d8800e15 	stw	r2,56(sp)
 32135bc:	da401115 	stw	r9,68(sp)
 32135c0:	003f6a06 	br	321336c <__muldf3+0xc0>
 32135c4:	89802126 	beq	r17,r6,321364c <__muldf3+0x3a0>
 32135c8:	0009883a 	mov	r4,zero
 32135cc:	5105883a 	add	r2,r10,r4
 32135d0:	128d803a 	cmpltu	r6,r2,r10
 32135d4:	5d07883a 	add	r3,r11,r20
 32135d8:	30cd883a 	add	r6,r6,r3
 32135dc:	0021883a 	mov	r16,zero
 32135e0:	0023883a 	mov	r17,zero
 32135e4:	1025883a 	mov	r18,r2
 32135e8:	3027883a 	mov	r19,r6
 32135ec:	32ff9e2e 	bgeu	r6,r11,3213468 <__muldf3+0x1bc>
 32135f0:	00800044 	movi	r2,1
 32135f4:	8089883a 	add	r4,r16,r2
 32135f8:	240d803a 	cmpltu	r6,r4,r16
 32135fc:	344d883a 	add	r6,r6,r17
 3213600:	2021883a 	mov	r16,r4
 3213604:	3023883a 	mov	r17,r6
 3213608:	003f9806 	br	321346c <__muldf3+0x1c0>
 321360c:	403fe71e 	bne	r8,zero,32135ac <__muldf3+0x300>
 3213610:	01004004 	movi	r4,256
 3213614:	4904703a 	and	r2,r9,r4
 3213618:	10c4b03a 	or	r2,r2,r3
 321361c:	103fe31e 	bne	r2,zero,32135ac <__muldf3+0x300>
 3213620:	94c4b03a 	or	r2,r18,r19
 3213624:	103fe126 	beq	r2,zero,32135ac <__muldf3+0x300>
 3213628:	49c5883a 	add	r2,r9,r7
 321362c:	1251803a 	cmpltu	r8,r2,r9
 3213630:	4291883a 	add	r8,r8,r10
 3213634:	013fc004 	movi	r4,-256
 3213638:	1112703a 	and	r9,r2,r4
 321363c:	4015883a 	mov	r10,r8
 3213640:	003fda06 	br	32135ac <__muldf3+0x300>
 3213644:	6813883a 	mov	r9,r13
 3213648:	003fce06 	br	3213584 <__muldf3+0x2d8>
 321364c:	143f7c36 	bltu	r2,r16,3213440 <__muldf3+0x194>
 3213650:	003fdd06 	br	32135c8 <__muldf3+0x31c>
 3213654:	12bf852e 	bgeu	r2,r10,321346c <__muldf3+0x1c0>
 3213658:	003fe506 	br	32135f0 <__muldf3+0x344>
 321365c:	00800084 	movi	r2,2
 3213660:	20bf351e 	bne	r4,r2,3213338 <__muldf3+0x8c>
 3213664:	0100c974 	movhi	r4,805
 3213668:	21393104 	addi	r4,r4,-6972
 321366c:	003f3f06 	br	321336c <__muldf3+0xc0>

03213670 <__divdf3>:
 3213670:	deffed04 	addi	sp,sp,-76
 3213674:	dcc01115 	stw	r19,68(sp)
 3213678:	dcc00404 	addi	r19,sp,16
 321367c:	2011883a 	mov	r8,r4
 3213680:	2813883a 	mov	r9,r5
 3213684:	dc000e15 	stw	r16,56(sp)
 3213688:	d809883a 	mov	r4,sp
 321368c:	980b883a 	mov	r5,r19
 3213690:	dc000904 	addi	r16,sp,36
 3213694:	dfc01215 	stw	ra,72(sp)
 3213698:	da400115 	stw	r9,4(sp)
 321369c:	d9c00315 	stw	r7,12(sp)
 32136a0:	da000015 	stw	r8,0(sp)
 32136a4:	d9800215 	stw	r6,8(sp)
 32136a8:	dc801015 	stw	r18,64(sp)
 32136ac:	dc400f15 	stw	r17,60(sp)
 32136b0:	32145000 	call	3214500 <__unpack_d>
 32136b4:	d9000204 	addi	r4,sp,8
 32136b8:	800b883a 	mov	r5,r16
 32136bc:	32145000 	call	3214500 <__unpack_d>
 32136c0:	d9000417 	ldw	r4,16(sp)
 32136c4:	00800044 	movi	r2,1
 32136c8:	11000b2e 	bgeu	r2,r4,32136f8 <__divdf3+0x88>
 32136cc:	d9400917 	ldw	r5,36(sp)
 32136d0:	1140762e 	bgeu	r2,r5,32138ac <__divdf3+0x23c>
 32136d4:	d8800517 	ldw	r2,20(sp)
 32136d8:	d8c00a17 	ldw	r3,40(sp)
 32136dc:	01800104 	movi	r6,4
 32136e0:	10c4f03a 	xor	r2,r2,r3
 32136e4:	d8800515 	stw	r2,20(sp)
 32136e8:	21800226 	beq	r4,r6,32136f4 <__divdf3+0x84>
 32136ec:	00800084 	movi	r2,2
 32136f0:	2080141e 	bne	r4,r2,3213744 <__divdf3+0xd4>
 32136f4:	29000926 	beq	r5,r4,321371c <__divdf3+0xac>
 32136f8:	9809883a 	mov	r4,r19
 32136fc:	32141ec0 	call	32141ec <__pack_d>
 3213700:	dfc01217 	ldw	ra,72(sp)
 3213704:	dcc01117 	ldw	r19,68(sp)
 3213708:	dc801017 	ldw	r18,64(sp)
 321370c:	dc400f17 	ldw	r17,60(sp)
 3213710:	dc000e17 	ldw	r16,56(sp)
 3213714:	dec01304 	addi	sp,sp,76
 3213718:	f800283a 	ret
 321371c:	0100c974 	movhi	r4,805
 3213720:	21393104 	addi	r4,r4,-6972
 3213724:	32141ec0 	call	32141ec <__pack_d>
 3213728:	dfc01217 	ldw	ra,72(sp)
 321372c:	dcc01117 	ldw	r19,68(sp)
 3213730:	dc801017 	ldw	r18,64(sp)
 3213734:	dc400f17 	ldw	r17,60(sp)
 3213738:	dc000e17 	ldw	r16,56(sp)
 321373c:	dec01304 	addi	sp,sp,76
 3213740:	f800283a 	ret
 3213744:	29805b26 	beq	r5,r6,32138b4 <__divdf3+0x244>
 3213748:	28802d26 	beq	r5,r2,3213800 <__divdf3+0x190>
 321374c:	d8c00617 	ldw	r3,24(sp)
 3213750:	d8800b17 	ldw	r2,44(sp)
 3213754:	d9c00817 	ldw	r7,32(sp)
 3213758:	dc400d17 	ldw	r17,52(sp)
 321375c:	188bc83a 	sub	r5,r3,r2
 3213760:	d9800717 	ldw	r6,28(sp)
 3213764:	dc000c17 	ldw	r16,48(sp)
 3213768:	d9400615 	stw	r5,24(sp)
 321376c:	3c403836 	bltu	r7,r17,3213850 <__divdf3+0x1e0>
 3213770:	89c03626 	beq	r17,r7,321384c <__divdf3+0x1dc>
 3213774:	0015883a 	mov	r10,zero
 3213778:	001d883a 	mov	r14,zero
 321377c:	02c40034 	movhi	r11,4096
 3213780:	001f883a 	mov	r15,zero
 3213784:	003f883a 	mov	ra,zero
 3213788:	04800f44 	movi	r18,61
 321378c:	00000f06 	br	32137cc <__divdf3+0x15c>
 3213790:	601d883a 	mov	r14,r12
 3213794:	681f883a 	mov	r15,r13
 3213798:	400d883a 	mov	r6,r8
 321379c:	100f883a 	mov	r7,r2
 32137a0:	3191883a 	add	r8,r6,r6
 32137a4:	5808d07a 	srli	r4,r11,1
 32137a8:	4185803a 	cmpltu	r2,r8,r6
 32137ac:	39d3883a 	add	r9,r7,r7
 32137b0:	28c6b03a 	or	r3,r5,r3
 32137b4:	1245883a 	add	r2,r2,r9
 32137b8:	1815883a 	mov	r10,r3
 32137bc:	2017883a 	mov	r11,r4
 32137c0:	400d883a 	mov	r6,r8
 32137c4:	100f883a 	mov	r7,r2
 32137c8:	fc801726 	beq	ra,r18,3213828 <__divdf3+0x1b8>
 32137cc:	580a97fa 	slli	r5,r11,31
 32137d0:	5006d07a 	srli	r3,r10,1
 32137d4:	ffc00044 	addi	ra,ra,1
 32137d8:	3c7ff136 	bltu	r7,r17,32137a0 <__divdf3+0x130>
 32137dc:	3411c83a 	sub	r8,r6,r16
 32137e0:	3205803a 	cmpltu	r2,r6,r8
 32137e4:	3c53c83a 	sub	r9,r7,r17
 32137e8:	7298b03a 	or	r12,r14,r10
 32137ec:	7adab03a 	or	r13,r15,r11
 32137f0:	4885c83a 	sub	r2,r9,r2
 32137f4:	89ffe61e 	bne	r17,r7,3213790 <__divdf3+0x120>
 32137f8:	343fe936 	bltu	r6,r16,32137a0 <__divdf3+0x130>
 32137fc:	003fe406 	br	3213790 <__divdf3+0x120>
 3213800:	9809883a 	mov	r4,r19
 3213804:	d9800415 	stw	r6,16(sp)
 3213808:	32141ec0 	call	32141ec <__pack_d>
 321380c:	dfc01217 	ldw	ra,72(sp)
 3213810:	dcc01117 	ldw	r19,68(sp)
 3213814:	dc801017 	ldw	r18,64(sp)
 3213818:	dc400f17 	ldw	r17,60(sp)
 321381c:	dc000e17 	ldw	r16,56(sp)
 3213820:	dec01304 	addi	sp,sp,76
 3213824:	f800283a 	ret
 3213828:	00803fc4 	movi	r2,255
 321382c:	7090703a 	and	r8,r14,r2
 3213830:	00802004 	movi	r2,128
 3213834:	0007883a 	mov	r3,zero
 3213838:	0013883a 	mov	r9,zero
 321383c:	40800d26 	beq	r8,r2,3213874 <__divdf3+0x204>
 3213840:	dbc00815 	stw	r15,32(sp)
 3213844:	db800715 	stw	r14,28(sp)
 3213848:	003fab06 	br	32136f8 <__divdf3+0x88>
 321384c:	343fc92e 	bgeu	r6,r16,3213774 <__divdf3+0x104>
 3213850:	3185883a 	add	r2,r6,r6
 3213854:	1189803a 	cmpltu	r4,r2,r6
 3213858:	39c7883a 	add	r3,r7,r7
 321385c:	20c9883a 	add	r4,r4,r3
 3213860:	297fffc4 	addi	r5,r5,-1
 3213864:	100d883a 	mov	r6,r2
 3213868:	200f883a 	mov	r7,r4
 321386c:	d9400615 	stw	r5,24(sp)
 3213870:	003fc006 	br	3213774 <__divdf3+0x104>
 3213874:	483ff21e 	bne	r9,zero,3213840 <__divdf3+0x1d0>
 3213878:	01004004 	movi	r4,256
 321387c:	7104703a 	and	r2,r14,r4
 3213880:	10c4b03a 	or	r2,r2,r3
 3213884:	103fee1e 	bne	r2,zero,3213840 <__divdf3+0x1d0>
 3213888:	31c4b03a 	or	r2,r6,r7
 321388c:	103fec26 	beq	r2,zero,3213840 <__divdf3+0x1d0>
 3213890:	7205883a 	add	r2,r14,r8
 3213894:	1391803a 	cmpltu	r8,r2,r14
 3213898:	43d1883a 	add	r8,r8,r15
 321389c:	013fc004 	movi	r4,-256
 32138a0:	111c703a 	and	r14,r2,r4
 32138a4:	401f883a 	mov	r15,r8
 32138a8:	003fe506 	br	3213840 <__divdf3+0x1d0>
 32138ac:	8009883a 	mov	r4,r16
 32138b0:	003f9206 	br	32136fc <__divdf3+0x8c>
 32138b4:	9809883a 	mov	r4,r19
 32138b8:	d8000715 	stw	zero,28(sp)
 32138bc:	d8000815 	stw	zero,32(sp)
 32138c0:	d8000615 	stw	zero,24(sp)
 32138c4:	003f8d06 	br	32136fc <__divdf3+0x8c>

032138c8 <__eqdf2>:
 32138c8:	deffef04 	addi	sp,sp,-68
 32138cc:	dc400f15 	stw	r17,60(sp)
 32138d0:	dc400404 	addi	r17,sp,16
 32138d4:	2005883a 	mov	r2,r4
 32138d8:	2807883a 	mov	r3,r5
 32138dc:	dc000e15 	stw	r16,56(sp)
 32138e0:	d809883a 	mov	r4,sp
 32138e4:	880b883a 	mov	r5,r17
 32138e8:	dc000904 	addi	r16,sp,36
 32138ec:	d8c00115 	stw	r3,4(sp)
 32138f0:	d8800015 	stw	r2,0(sp)
 32138f4:	d9800215 	stw	r6,8(sp)
 32138f8:	dfc01015 	stw	ra,64(sp)
 32138fc:	d9c00315 	stw	r7,12(sp)
 3213900:	32145000 	call	3214500 <__unpack_d>
 3213904:	d9000204 	addi	r4,sp,8
 3213908:	800b883a 	mov	r5,r16
 321390c:	32145000 	call	3214500 <__unpack_d>
 3213910:	d8800417 	ldw	r2,16(sp)
 3213914:	00c00044 	movi	r3,1
 3213918:	180d883a 	mov	r6,r3
 321391c:	1880062e 	bgeu	r3,r2,3213938 <__eqdf2+0x70>
 3213920:	d8800917 	ldw	r2,36(sp)
 3213924:	8809883a 	mov	r4,r17
 3213928:	800b883a 	mov	r5,r16
 321392c:	1880022e 	bgeu	r3,r2,3213938 <__eqdf2+0x70>
 3213930:	32146380 	call	3214638 <__fpcmp_parts_d>
 3213934:	100d883a 	mov	r6,r2
 3213938:	3005883a 	mov	r2,r6
 321393c:	dfc01017 	ldw	ra,64(sp)
 3213940:	dc400f17 	ldw	r17,60(sp)
 3213944:	dc000e17 	ldw	r16,56(sp)
 3213948:	dec01104 	addi	sp,sp,68
 321394c:	f800283a 	ret

03213950 <__nedf2>:
 3213950:	deffef04 	addi	sp,sp,-68
 3213954:	dc400f15 	stw	r17,60(sp)
 3213958:	dc400404 	addi	r17,sp,16
 321395c:	2005883a 	mov	r2,r4
 3213960:	2807883a 	mov	r3,r5
 3213964:	dc000e15 	stw	r16,56(sp)
 3213968:	d809883a 	mov	r4,sp
 321396c:	880b883a 	mov	r5,r17
 3213970:	dc000904 	addi	r16,sp,36
 3213974:	d8c00115 	stw	r3,4(sp)
 3213978:	d8800015 	stw	r2,0(sp)
 321397c:	d9800215 	stw	r6,8(sp)
 3213980:	dfc01015 	stw	ra,64(sp)
 3213984:	d9c00315 	stw	r7,12(sp)
 3213988:	32145000 	call	3214500 <__unpack_d>
 321398c:	d9000204 	addi	r4,sp,8
 3213990:	800b883a 	mov	r5,r16
 3213994:	32145000 	call	3214500 <__unpack_d>
 3213998:	d8800417 	ldw	r2,16(sp)
 321399c:	00c00044 	movi	r3,1
 32139a0:	180d883a 	mov	r6,r3
 32139a4:	1880062e 	bgeu	r3,r2,32139c0 <__nedf2+0x70>
 32139a8:	d8800917 	ldw	r2,36(sp)
 32139ac:	8809883a 	mov	r4,r17
 32139b0:	800b883a 	mov	r5,r16
 32139b4:	1880022e 	bgeu	r3,r2,32139c0 <__nedf2+0x70>
 32139b8:	32146380 	call	3214638 <__fpcmp_parts_d>
 32139bc:	100d883a 	mov	r6,r2
 32139c0:	3005883a 	mov	r2,r6
 32139c4:	dfc01017 	ldw	ra,64(sp)
 32139c8:	dc400f17 	ldw	r17,60(sp)
 32139cc:	dc000e17 	ldw	r16,56(sp)
 32139d0:	dec01104 	addi	sp,sp,68
 32139d4:	f800283a 	ret

032139d8 <__gtdf2>:
 32139d8:	deffef04 	addi	sp,sp,-68
 32139dc:	dc400f15 	stw	r17,60(sp)
 32139e0:	dc400404 	addi	r17,sp,16
 32139e4:	2005883a 	mov	r2,r4
 32139e8:	2807883a 	mov	r3,r5
 32139ec:	dc000e15 	stw	r16,56(sp)
 32139f0:	d809883a 	mov	r4,sp
 32139f4:	880b883a 	mov	r5,r17
 32139f8:	dc000904 	addi	r16,sp,36
 32139fc:	d8c00115 	stw	r3,4(sp)
 3213a00:	d8800015 	stw	r2,0(sp)
 3213a04:	d9800215 	stw	r6,8(sp)
 3213a08:	dfc01015 	stw	ra,64(sp)
 3213a0c:	d9c00315 	stw	r7,12(sp)
 3213a10:	32145000 	call	3214500 <__unpack_d>
 3213a14:	d9000204 	addi	r4,sp,8
 3213a18:	800b883a 	mov	r5,r16
 3213a1c:	32145000 	call	3214500 <__unpack_d>
 3213a20:	d8800417 	ldw	r2,16(sp)
 3213a24:	00c00044 	movi	r3,1
 3213a28:	01bfffc4 	movi	r6,-1
 3213a2c:	1880062e 	bgeu	r3,r2,3213a48 <__gtdf2+0x70>
 3213a30:	d8800917 	ldw	r2,36(sp)
 3213a34:	8809883a 	mov	r4,r17
 3213a38:	800b883a 	mov	r5,r16
 3213a3c:	1880022e 	bgeu	r3,r2,3213a48 <__gtdf2+0x70>
 3213a40:	32146380 	call	3214638 <__fpcmp_parts_d>
 3213a44:	100d883a 	mov	r6,r2
 3213a48:	3005883a 	mov	r2,r6
 3213a4c:	dfc01017 	ldw	ra,64(sp)
 3213a50:	dc400f17 	ldw	r17,60(sp)
 3213a54:	dc000e17 	ldw	r16,56(sp)
 3213a58:	dec01104 	addi	sp,sp,68
 3213a5c:	f800283a 	ret

03213a60 <__gedf2>:
 3213a60:	deffef04 	addi	sp,sp,-68
 3213a64:	dc400f15 	stw	r17,60(sp)
 3213a68:	dc400404 	addi	r17,sp,16
 3213a6c:	2005883a 	mov	r2,r4
 3213a70:	2807883a 	mov	r3,r5
 3213a74:	dc000e15 	stw	r16,56(sp)
 3213a78:	d809883a 	mov	r4,sp
 3213a7c:	880b883a 	mov	r5,r17
 3213a80:	dc000904 	addi	r16,sp,36
 3213a84:	d8c00115 	stw	r3,4(sp)
 3213a88:	d8800015 	stw	r2,0(sp)
 3213a8c:	d9800215 	stw	r6,8(sp)
 3213a90:	dfc01015 	stw	ra,64(sp)
 3213a94:	d9c00315 	stw	r7,12(sp)
 3213a98:	32145000 	call	3214500 <__unpack_d>
 3213a9c:	d9000204 	addi	r4,sp,8
 3213aa0:	800b883a 	mov	r5,r16
 3213aa4:	32145000 	call	3214500 <__unpack_d>
 3213aa8:	d8800417 	ldw	r2,16(sp)
 3213aac:	00c00044 	movi	r3,1
 3213ab0:	01bfffc4 	movi	r6,-1
 3213ab4:	1880062e 	bgeu	r3,r2,3213ad0 <__gedf2+0x70>
 3213ab8:	d8800917 	ldw	r2,36(sp)
 3213abc:	8809883a 	mov	r4,r17
 3213ac0:	800b883a 	mov	r5,r16
 3213ac4:	1880022e 	bgeu	r3,r2,3213ad0 <__gedf2+0x70>
 3213ac8:	32146380 	call	3214638 <__fpcmp_parts_d>
 3213acc:	100d883a 	mov	r6,r2
 3213ad0:	3005883a 	mov	r2,r6
 3213ad4:	dfc01017 	ldw	ra,64(sp)
 3213ad8:	dc400f17 	ldw	r17,60(sp)
 3213adc:	dc000e17 	ldw	r16,56(sp)
 3213ae0:	dec01104 	addi	sp,sp,68
 3213ae4:	f800283a 	ret

03213ae8 <__ltdf2>:
 3213ae8:	deffef04 	addi	sp,sp,-68
 3213aec:	dc400f15 	stw	r17,60(sp)
 3213af0:	dc400404 	addi	r17,sp,16
 3213af4:	2005883a 	mov	r2,r4
 3213af8:	2807883a 	mov	r3,r5
 3213afc:	dc000e15 	stw	r16,56(sp)
 3213b00:	d809883a 	mov	r4,sp
 3213b04:	880b883a 	mov	r5,r17
 3213b08:	dc000904 	addi	r16,sp,36
 3213b0c:	d8c00115 	stw	r3,4(sp)
 3213b10:	d8800015 	stw	r2,0(sp)
 3213b14:	d9800215 	stw	r6,8(sp)
 3213b18:	dfc01015 	stw	ra,64(sp)
 3213b1c:	d9c00315 	stw	r7,12(sp)
 3213b20:	32145000 	call	3214500 <__unpack_d>
 3213b24:	d9000204 	addi	r4,sp,8
 3213b28:	800b883a 	mov	r5,r16
 3213b2c:	32145000 	call	3214500 <__unpack_d>
 3213b30:	d8800417 	ldw	r2,16(sp)
 3213b34:	00c00044 	movi	r3,1
 3213b38:	180d883a 	mov	r6,r3
 3213b3c:	1880062e 	bgeu	r3,r2,3213b58 <__ltdf2+0x70>
 3213b40:	d8800917 	ldw	r2,36(sp)
 3213b44:	8809883a 	mov	r4,r17
 3213b48:	800b883a 	mov	r5,r16
 3213b4c:	1880022e 	bgeu	r3,r2,3213b58 <__ltdf2+0x70>
 3213b50:	32146380 	call	3214638 <__fpcmp_parts_d>
 3213b54:	100d883a 	mov	r6,r2
 3213b58:	3005883a 	mov	r2,r6
 3213b5c:	dfc01017 	ldw	ra,64(sp)
 3213b60:	dc400f17 	ldw	r17,60(sp)
 3213b64:	dc000e17 	ldw	r16,56(sp)
 3213b68:	dec01104 	addi	sp,sp,68
 3213b6c:	f800283a 	ret

03213b70 <__ledf2>:
 3213b70:	deffef04 	addi	sp,sp,-68
 3213b74:	dc400f15 	stw	r17,60(sp)
 3213b78:	dc400404 	addi	r17,sp,16
 3213b7c:	2005883a 	mov	r2,r4
 3213b80:	2807883a 	mov	r3,r5
 3213b84:	dc000e15 	stw	r16,56(sp)
 3213b88:	d809883a 	mov	r4,sp
 3213b8c:	880b883a 	mov	r5,r17
 3213b90:	dc000904 	addi	r16,sp,36
 3213b94:	d8c00115 	stw	r3,4(sp)
 3213b98:	d8800015 	stw	r2,0(sp)
 3213b9c:	d9800215 	stw	r6,8(sp)
 3213ba0:	dfc01015 	stw	ra,64(sp)
 3213ba4:	d9c00315 	stw	r7,12(sp)
 3213ba8:	32145000 	call	3214500 <__unpack_d>
 3213bac:	d9000204 	addi	r4,sp,8
 3213bb0:	800b883a 	mov	r5,r16
 3213bb4:	32145000 	call	3214500 <__unpack_d>
 3213bb8:	d8800417 	ldw	r2,16(sp)
 3213bbc:	00c00044 	movi	r3,1
 3213bc0:	180d883a 	mov	r6,r3
 3213bc4:	1880062e 	bgeu	r3,r2,3213be0 <__ledf2+0x70>
 3213bc8:	d8800917 	ldw	r2,36(sp)
 3213bcc:	8809883a 	mov	r4,r17
 3213bd0:	800b883a 	mov	r5,r16
 3213bd4:	1880022e 	bgeu	r3,r2,3213be0 <__ledf2+0x70>
 3213bd8:	32146380 	call	3214638 <__fpcmp_parts_d>
 3213bdc:	100d883a 	mov	r6,r2
 3213be0:	3005883a 	mov	r2,r6
 3213be4:	dfc01017 	ldw	ra,64(sp)
 3213be8:	dc400f17 	ldw	r17,60(sp)
 3213bec:	dc000e17 	ldw	r16,56(sp)
 3213bf0:	dec01104 	addi	sp,sp,68
 3213bf4:	f800283a 	ret

03213bf8 <__floatsidf>:
 3213bf8:	2006d7fa 	srli	r3,r4,31
 3213bfc:	defff604 	addi	sp,sp,-40
 3213c00:	008000c4 	movi	r2,3
 3213c04:	dfc00915 	stw	ra,36(sp)
 3213c08:	dcc00815 	stw	r19,32(sp)
 3213c0c:	dc800715 	stw	r18,28(sp)
 3213c10:	dc400615 	stw	r17,24(sp)
 3213c14:	dc000515 	stw	r16,20(sp)
 3213c18:	d8800015 	stw	r2,0(sp)
 3213c1c:	d8c00115 	stw	r3,4(sp)
 3213c20:	20000f1e 	bne	r4,zero,3213c60 <__floatsidf+0x68>
 3213c24:	00800084 	movi	r2,2
 3213c28:	d8800015 	stw	r2,0(sp)
 3213c2c:	d809883a 	mov	r4,sp
 3213c30:	32141ec0 	call	32141ec <__pack_d>
 3213c34:	1009883a 	mov	r4,r2
 3213c38:	180b883a 	mov	r5,r3
 3213c3c:	2005883a 	mov	r2,r4
 3213c40:	2807883a 	mov	r3,r5
 3213c44:	dfc00917 	ldw	ra,36(sp)
 3213c48:	dcc00817 	ldw	r19,32(sp)
 3213c4c:	dc800717 	ldw	r18,28(sp)
 3213c50:	dc400617 	ldw	r17,24(sp)
 3213c54:	dc000517 	ldw	r16,20(sp)
 3213c58:	dec00a04 	addi	sp,sp,40
 3213c5c:	f800283a 	ret
 3213c60:	00800f04 	movi	r2,60
 3213c64:	1807003a 	cmpeq	r3,r3,zero
 3213c68:	d8800215 	stw	r2,8(sp)
 3213c6c:	18001126 	beq	r3,zero,3213cb4 <__floatsidf+0xbc>
 3213c70:	0027883a 	mov	r19,zero
 3213c74:	2025883a 	mov	r18,r4
 3213c78:	d9000315 	stw	r4,12(sp)
 3213c7c:	dcc00415 	stw	r19,16(sp)
 3213c80:	3213fd00 	call	3213fd0 <__clzsi2>
 3213c84:	11000744 	addi	r4,r2,29
 3213c88:	013fe80e 	bge	zero,r4,3213c2c <__floatsidf+0x34>
 3213c8c:	10bfff44 	addi	r2,r2,-3
 3213c90:	10000c16 	blt	r2,zero,3213cc4 <__floatsidf+0xcc>
 3213c94:	90a2983a 	sll	r17,r18,r2
 3213c98:	0021883a 	mov	r16,zero
 3213c9c:	d8800217 	ldw	r2,8(sp)
 3213ca0:	dc400415 	stw	r17,16(sp)
 3213ca4:	dc000315 	stw	r16,12(sp)
 3213ca8:	1105c83a 	sub	r2,r2,r4
 3213cac:	d8800215 	stw	r2,8(sp)
 3213cb0:	003fde06 	br	3213c2c <__floatsidf+0x34>
 3213cb4:	00a00034 	movhi	r2,32768
 3213cb8:	20800a26 	beq	r4,r2,3213ce4 <__floatsidf+0xec>
 3213cbc:	0109c83a 	sub	r4,zero,r4
 3213cc0:	003feb06 	br	3213c70 <__floatsidf+0x78>
 3213cc4:	9006d07a 	srli	r3,r18,1
 3213cc8:	008007c4 	movi	r2,31
 3213ccc:	1105c83a 	sub	r2,r2,r4
 3213cd0:	1886d83a 	srl	r3,r3,r2
 3213cd4:	9922983a 	sll	r17,r19,r4
 3213cd8:	9120983a 	sll	r16,r18,r4
 3213cdc:	1c62b03a 	or	r17,r3,r17
 3213ce0:	003fee06 	br	3213c9c <__floatsidf+0xa4>
 3213ce4:	0009883a 	mov	r4,zero
 3213ce8:	01707834 	movhi	r5,49632
 3213cec:	003fd306 	br	3213c3c <__floatsidf+0x44>

03213cf0 <__fixdfsi>:
 3213cf0:	defff804 	addi	sp,sp,-32
 3213cf4:	2005883a 	mov	r2,r4
 3213cf8:	2807883a 	mov	r3,r5
 3213cfc:	d809883a 	mov	r4,sp
 3213d00:	d9400204 	addi	r5,sp,8
 3213d04:	d8c00115 	stw	r3,4(sp)
 3213d08:	d8800015 	stw	r2,0(sp)
 3213d0c:	dfc00715 	stw	ra,28(sp)
 3213d10:	32145000 	call	3214500 <__unpack_d>
 3213d14:	d8c00217 	ldw	r3,8(sp)
 3213d18:	00800084 	movi	r2,2
 3213d1c:	1880051e 	bne	r3,r2,3213d34 <__fixdfsi+0x44>
 3213d20:	0007883a 	mov	r3,zero
 3213d24:	1805883a 	mov	r2,r3
 3213d28:	dfc00717 	ldw	ra,28(sp)
 3213d2c:	dec00804 	addi	sp,sp,32
 3213d30:	f800283a 	ret
 3213d34:	00800044 	movi	r2,1
 3213d38:	10fff92e 	bgeu	r2,r3,3213d20 <__fixdfsi+0x30>
 3213d3c:	00800104 	movi	r2,4
 3213d40:	18800426 	beq	r3,r2,3213d54 <__fixdfsi+0x64>
 3213d44:	d8c00417 	ldw	r3,16(sp)
 3213d48:	183ff516 	blt	r3,zero,3213d20 <__fixdfsi+0x30>
 3213d4c:	00800784 	movi	r2,30
 3213d50:	10c0080e 	bge	r2,r3,3213d74 <__fixdfsi+0x84>
 3213d54:	d8800317 	ldw	r2,12(sp)
 3213d58:	1000121e 	bne	r2,zero,3213da4 <__fixdfsi+0xb4>
 3213d5c:	00e00034 	movhi	r3,32768
 3213d60:	18ffffc4 	addi	r3,r3,-1
 3213d64:	1805883a 	mov	r2,r3
 3213d68:	dfc00717 	ldw	ra,28(sp)
 3213d6c:	dec00804 	addi	sp,sp,32
 3213d70:	f800283a 	ret
 3213d74:	00800f04 	movi	r2,60
 3213d78:	10d1c83a 	sub	r8,r2,r3
 3213d7c:	40bff804 	addi	r2,r8,-32
 3213d80:	d9800517 	ldw	r6,20(sp)
 3213d84:	d9c00617 	ldw	r7,24(sp)
 3213d88:	10000816 	blt	r2,zero,3213dac <__fixdfsi+0xbc>
 3213d8c:	3888d83a 	srl	r4,r7,r2
 3213d90:	d8800317 	ldw	r2,12(sp)
 3213d94:	2007883a 	mov	r3,r4
 3213d98:	103fe226 	beq	r2,zero,3213d24 <__fixdfsi+0x34>
 3213d9c:	0107c83a 	sub	r3,zero,r4
 3213da0:	003fe006 	br	3213d24 <__fixdfsi+0x34>
 3213da4:	00e00034 	movhi	r3,32768
 3213da8:	003fde06 	br	3213d24 <__fixdfsi+0x34>
 3213dac:	39c7883a 	add	r3,r7,r7
 3213db0:	008007c4 	movi	r2,31
 3213db4:	1205c83a 	sub	r2,r2,r8
 3213db8:	1886983a 	sll	r3,r3,r2
 3213dbc:	3208d83a 	srl	r4,r6,r8
 3213dc0:	1908b03a 	or	r4,r3,r4
 3213dc4:	003ff206 	br	3213d90 <__fixdfsi+0xa0>

03213dc8 <__truncdfsf2>:
 3213dc8:	defff804 	addi	sp,sp,-32
 3213dcc:	2005883a 	mov	r2,r4
 3213dd0:	2807883a 	mov	r3,r5
 3213dd4:	d809883a 	mov	r4,sp
 3213dd8:	d9400204 	addi	r5,sp,8
 3213ddc:	d8c00115 	stw	r3,4(sp)
 3213de0:	d8800015 	stw	r2,0(sp)
 3213de4:	dfc00715 	stw	ra,28(sp)
 3213de8:	32145000 	call	3214500 <__unpack_d>
 3213dec:	d9c00517 	ldw	r7,20(sp)
 3213df0:	da000617 	ldw	r8,24(sp)
 3213df4:	02d00034 	movhi	r11,16384
 3213df8:	5affffc4 	addi	r11,r11,-1
 3213dfc:	3812d7ba 	srli	r9,r7,30
 3213e00:	401a90ba 	slli	r13,r8,2
 3213e04:	3ac4703a 	and	r2,r7,r11
 3213e08:	0007883a 	mov	r3,zero
 3213e0c:	6a52b03a 	or	r9,r13,r9
 3213e10:	10c4b03a 	or	r2,r2,r3
 3213e14:	d9000217 	ldw	r4,8(sp)
 3213e18:	d9400317 	ldw	r5,12(sp)
 3213e1c:	d9800417 	ldw	r6,16(sp)
 3213e20:	480f883a 	mov	r7,r9
 3213e24:	10000126 	beq	r2,zero,3213e2c <__truncdfsf2+0x64>
 3213e28:	49c00054 	ori	r7,r9,1
 3213e2c:	32141c00 	call	32141c0 <__make_fp>
 3213e30:	dfc00717 	ldw	ra,28(sp)
 3213e34:	dec00804 	addi	sp,sp,32
 3213e38:	f800283a 	ret

03213e3c <__floatunsidf>:
 3213e3c:	defff204 	addi	sp,sp,-56
 3213e40:	dfc00d15 	stw	ra,52(sp)
 3213e44:	ddc00c15 	stw	r23,48(sp)
 3213e48:	dd800b15 	stw	r22,44(sp)
 3213e4c:	dd400a15 	stw	r21,40(sp)
 3213e50:	dd000915 	stw	r20,36(sp)
 3213e54:	dcc00815 	stw	r19,32(sp)
 3213e58:	dc800715 	stw	r18,28(sp)
 3213e5c:	dc400615 	stw	r17,24(sp)
 3213e60:	dc000515 	stw	r16,20(sp)
 3213e64:	d8000115 	stw	zero,4(sp)
 3213e68:	20000f1e 	bne	r4,zero,3213ea8 <__floatunsidf+0x6c>
 3213e6c:	00800084 	movi	r2,2
 3213e70:	d8800015 	stw	r2,0(sp)
 3213e74:	d809883a 	mov	r4,sp
 3213e78:	32141ec0 	call	32141ec <__pack_d>
 3213e7c:	dfc00d17 	ldw	ra,52(sp)
 3213e80:	ddc00c17 	ldw	r23,48(sp)
 3213e84:	dd800b17 	ldw	r22,44(sp)
 3213e88:	dd400a17 	ldw	r21,40(sp)
 3213e8c:	dd000917 	ldw	r20,36(sp)
 3213e90:	dcc00817 	ldw	r19,32(sp)
 3213e94:	dc800717 	ldw	r18,28(sp)
 3213e98:	dc400617 	ldw	r17,24(sp)
 3213e9c:	dc000517 	ldw	r16,20(sp)
 3213ea0:	dec00e04 	addi	sp,sp,56
 3213ea4:	f800283a 	ret
 3213ea8:	008000c4 	movi	r2,3
 3213eac:	00c00f04 	movi	r3,60
 3213eb0:	002f883a 	mov	r23,zero
 3213eb4:	202d883a 	mov	r22,r4
 3213eb8:	d8800015 	stw	r2,0(sp)
 3213ebc:	d8c00215 	stw	r3,8(sp)
 3213ec0:	d9000315 	stw	r4,12(sp)
 3213ec4:	ddc00415 	stw	r23,16(sp)
 3213ec8:	3213fd00 	call	3213fd0 <__clzsi2>
 3213ecc:	12400744 	addi	r9,r2,29
 3213ed0:	48000b16 	blt	r9,zero,3213f00 <__floatunsidf+0xc4>
 3213ed4:	483fe726 	beq	r9,zero,3213e74 <__floatunsidf+0x38>
 3213ed8:	10bfff44 	addi	r2,r2,-3
 3213edc:	10002e16 	blt	r2,zero,3213f98 <__floatunsidf+0x15c>
 3213ee0:	b0a2983a 	sll	r17,r22,r2
 3213ee4:	0021883a 	mov	r16,zero
 3213ee8:	d8800217 	ldw	r2,8(sp)
 3213eec:	dc400415 	stw	r17,16(sp)
 3213ef0:	dc000315 	stw	r16,12(sp)
 3213ef4:	1245c83a 	sub	r2,r2,r9
 3213ef8:	d8800215 	stw	r2,8(sp)
 3213efc:	003fdd06 	br	3213e74 <__floatunsidf+0x38>
 3213f00:	0255c83a 	sub	r10,zero,r9
 3213f04:	51bff804 	addi	r6,r10,-32
 3213f08:	30001b16 	blt	r6,zero,3213f78 <__floatunsidf+0x13c>
 3213f0c:	b9a8d83a 	srl	r20,r23,r6
 3213f10:	002b883a 	mov	r21,zero
 3213f14:	000f883a 	mov	r7,zero
 3213f18:	01000044 	movi	r4,1
 3213f1c:	0011883a 	mov	r8,zero
 3213f20:	30002516 	blt	r6,zero,3213fb8 <__floatunsidf+0x17c>
 3213f24:	21a6983a 	sll	r19,r4,r6
 3213f28:	0025883a 	mov	r18,zero
 3213f2c:	00bfffc4 	movi	r2,-1
 3213f30:	9089883a 	add	r4,r18,r2
 3213f34:	988b883a 	add	r5,r19,r2
 3213f38:	248d803a 	cmpltu	r6,r4,r18
 3213f3c:	314b883a 	add	r5,r6,r5
 3213f40:	b104703a 	and	r2,r22,r4
 3213f44:	b946703a 	and	r3,r23,r5
 3213f48:	10c4b03a 	or	r2,r2,r3
 3213f4c:	10000226 	beq	r2,zero,3213f58 <__floatunsidf+0x11c>
 3213f50:	01c00044 	movi	r7,1
 3213f54:	0011883a 	mov	r8,zero
 3213f58:	d9000217 	ldw	r4,8(sp)
 3213f5c:	a1c4b03a 	or	r2,r20,r7
 3213f60:	aa06b03a 	or	r3,r21,r8
 3213f64:	2249c83a 	sub	r4,r4,r9
 3213f68:	d8c00415 	stw	r3,16(sp)
 3213f6c:	d9000215 	stw	r4,8(sp)
 3213f70:	d8800315 	stw	r2,12(sp)
 3213f74:	003fbf06 	br	3213e74 <__floatunsidf+0x38>
 3213f78:	bdc7883a 	add	r3,r23,r23
 3213f7c:	008007c4 	movi	r2,31
 3213f80:	1285c83a 	sub	r2,r2,r10
 3213f84:	1886983a 	sll	r3,r3,r2
 3213f88:	b2a8d83a 	srl	r20,r22,r10
 3213f8c:	baaad83a 	srl	r21,r23,r10
 3213f90:	1d28b03a 	or	r20,r3,r20
 3213f94:	003fdf06 	br	3213f14 <__floatunsidf+0xd8>
 3213f98:	b006d07a 	srli	r3,r22,1
 3213f9c:	008007c4 	movi	r2,31
 3213fa0:	1245c83a 	sub	r2,r2,r9
 3213fa4:	1886d83a 	srl	r3,r3,r2
 3213fa8:	ba62983a 	sll	r17,r23,r9
 3213fac:	b260983a 	sll	r16,r22,r9
 3213fb0:	1c62b03a 	or	r17,r3,r17
 3213fb4:	003fcc06 	br	3213ee8 <__floatunsidf+0xac>
 3213fb8:	2006d07a 	srli	r3,r4,1
 3213fbc:	008007c4 	movi	r2,31
 3213fc0:	1285c83a 	sub	r2,r2,r10
 3213fc4:	18a6d83a 	srl	r19,r3,r2
 3213fc8:	22a4983a 	sll	r18,r4,r10
 3213fcc:	003fd706 	br	3213f2c <__floatunsidf+0xf0>

03213fd0 <__clzsi2>:
 3213fd0:	00bfffd4 	movui	r2,65535
 3213fd4:	11000e36 	bltu	r2,r4,3214010 <__clzsi2+0x40>
 3213fd8:	00803fc4 	movi	r2,255
 3213fdc:	01400204 	movi	r5,8
 3213fe0:	0007883a 	mov	r3,zero
 3213fe4:	11001036 	bltu	r2,r4,3214028 <__clzsi2+0x58>
 3213fe8:	000b883a 	mov	r5,zero
 3213fec:	20c6d83a 	srl	r3,r4,r3
 3213ff0:	0080c974 	movhi	r2,805
 3213ff4:	10b93604 	addi	r2,r2,-6952
 3213ff8:	1887883a 	add	r3,r3,r2
 3213ffc:	18800003 	ldbu	r2,0(r3)
 3214000:	00c00804 	movi	r3,32
 3214004:	2885883a 	add	r2,r5,r2
 3214008:	1885c83a 	sub	r2,r3,r2
 321400c:	f800283a 	ret
 3214010:	01400404 	movi	r5,16
 3214014:	00804034 	movhi	r2,256
 3214018:	10bfffc4 	addi	r2,r2,-1
 321401c:	2807883a 	mov	r3,r5
 3214020:	113ff22e 	bgeu	r2,r4,3213fec <__clzsi2+0x1c>
 3214024:	01400604 	movi	r5,24
 3214028:	2807883a 	mov	r3,r5
 321402c:	20c6d83a 	srl	r3,r4,r3
 3214030:	0080c974 	movhi	r2,805
 3214034:	10b93604 	addi	r2,r2,-6952
 3214038:	1887883a 	add	r3,r3,r2
 321403c:	18800003 	ldbu	r2,0(r3)
 3214040:	00c00804 	movi	r3,32
 3214044:	2885883a 	add	r2,r5,r2
 3214048:	1885c83a 	sub	r2,r3,r2
 321404c:	f800283a 	ret

03214050 <__unpack_f>:
 3214050:	21800017 	ldw	r6,0(r4)
 3214054:	00c02034 	movhi	r3,128
 3214058:	18ffffc4 	addi	r3,r3,-1
 321405c:	3004d5fa 	srli	r2,r6,23
 3214060:	3008d7fa 	srli	r4,r6,31
 3214064:	30ce703a 	and	r7,r6,r3
 3214068:	10c03fcc 	andi	r3,r2,255
 321406c:	29000115 	stw	r4,4(r5)
 3214070:	1800131e 	bne	r3,zero,32140c0 <__unpack_f+0x70>
 3214074:	38000f26 	beq	r7,zero,32140b4 <__unpack_f+0x64>
 3214078:	380691fa 	slli	r3,r7,7
 321407c:	01bfe084 	movi	r6,-126
 3214080:	008000c4 	movi	r2,3
 3214084:	01100034 	movhi	r4,16384
 3214088:	213fffc4 	addi	r4,r4,-1
 321408c:	28800015 	stw	r2,0(r5)
 3214090:	29800215 	stw	r6,8(r5)
 3214094:	20c00536 	bltu	r4,r3,32140ac <__unpack_f+0x5c>
 3214098:	3005883a 	mov	r2,r6
 321409c:	18c7883a 	add	r3,r3,r3
 32140a0:	10bfffc4 	addi	r2,r2,-1
 32140a4:	20fffd2e 	bgeu	r4,r3,321409c <__unpack_f+0x4c>
 32140a8:	28800215 	stw	r2,8(r5)
 32140ac:	28c00315 	stw	r3,12(r5)
 32140b0:	f800283a 	ret
 32140b4:	00800084 	movi	r2,2
 32140b8:	28800015 	stw	r2,0(r5)
 32140bc:	f800283a 	ret
 32140c0:	00803fc4 	movi	r2,255
 32140c4:	18800826 	beq	r3,r2,32140e8 <__unpack_f+0x98>
 32140c8:	380491fa 	slli	r2,r7,7
 32140cc:	18ffe044 	addi	r3,r3,-127
 32140d0:	28c00215 	stw	r3,8(r5)
 32140d4:	10900034 	orhi	r2,r2,16384
 32140d8:	28800315 	stw	r2,12(r5)
 32140dc:	008000c4 	movi	r2,3
 32140e0:	28800015 	stw	r2,0(r5)
 32140e4:	f800283a 	ret
 32140e8:	3800031e 	bne	r7,zero,32140f8 <__unpack_f+0xa8>
 32140ec:	00800104 	movi	r2,4
 32140f0:	28800015 	stw	r2,0(r5)
 32140f4:	f800283a 	ret
 32140f8:	3080042c 	andhi	r2,r6,16
 32140fc:	10000426 	beq	r2,zero,3214110 <__unpack_f+0xc0>
 3214100:	00800044 	movi	r2,1
 3214104:	28800015 	stw	r2,0(r5)
 3214108:	29c00315 	stw	r7,12(r5)
 321410c:	f800283a 	ret
 3214110:	28000015 	stw	zero,0(r5)
 3214114:	003ffc06 	br	3214108 <__unpack_f+0xb8>

03214118 <__fpcmp_parts_f>:
 3214118:	21800017 	ldw	r6,0(r4)
 321411c:	00c00044 	movi	r3,1
 3214120:	19800a2e 	bgeu	r3,r6,321414c <__fpcmp_parts_f+0x34>
 3214124:	28800017 	ldw	r2,0(r5)
 3214128:	1880082e 	bgeu	r3,r2,321414c <__fpcmp_parts_f+0x34>
 321412c:	00c00104 	movi	r3,4
 3214130:	30c01e26 	beq	r6,r3,32141ac <__fpcmp_parts_f+0x94>
 3214134:	10c01a26 	beq	r2,r3,32141a0 <__fpcmp_parts_f+0x88>
 3214138:	00c00084 	movi	r3,2
 321413c:	30c00526 	beq	r6,r3,3214154 <__fpcmp_parts_f+0x3c>
 3214140:	10c0071e 	bne	r2,r3,3214160 <__fpcmp_parts_f+0x48>
 3214144:	20800117 	ldw	r2,4(r4)
 3214148:	1000091e 	bne	r2,zero,3214170 <__fpcmp_parts_f+0x58>
 321414c:	00800044 	movi	r2,1
 3214150:	f800283a 	ret
 3214154:	10c0121e 	bne	r2,r3,32141a0 <__fpcmp_parts_f+0x88>
 3214158:	0005883a 	mov	r2,zero
 321415c:	f800283a 	ret
 3214160:	20c00117 	ldw	r3,4(r4)
 3214164:	28800117 	ldw	r2,4(r5)
 3214168:	18800326 	beq	r3,r2,3214178 <__fpcmp_parts_f+0x60>
 321416c:	183ff726 	beq	r3,zero,321414c <__fpcmp_parts_f+0x34>
 3214170:	00bfffc4 	movi	r2,-1
 3214174:	f800283a 	ret
 3214178:	21800217 	ldw	r6,8(r4)
 321417c:	28800217 	ldw	r2,8(r5)
 3214180:	11bffa16 	blt	r2,r6,321416c <__fpcmp_parts_f+0x54>
 3214184:	30800416 	blt	r6,r2,3214198 <__fpcmp_parts_f+0x80>
 3214188:	21000317 	ldw	r4,12(r4)
 321418c:	29400317 	ldw	r5,12(r5)
 3214190:	293ff636 	bltu	r5,r4,321416c <__fpcmp_parts_f+0x54>
 3214194:	217ff02e 	bgeu	r4,r5,3214158 <__fpcmp_parts_f+0x40>
 3214198:	183fec1e 	bne	r3,zero,321414c <__fpcmp_parts_f+0x34>
 321419c:	003ff406 	br	3214170 <__fpcmp_parts_f+0x58>
 32141a0:	28800117 	ldw	r2,4(r5)
 32141a4:	103fe91e 	bne	r2,zero,321414c <__fpcmp_parts_f+0x34>
 32141a8:	003ff106 	br	3214170 <__fpcmp_parts_f+0x58>
 32141ac:	11bfe51e 	bne	r2,r6,3214144 <__fpcmp_parts_f+0x2c>
 32141b0:	28c00117 	ldw	r3,4(r5)
 32141b4:	20800117 	ldw	r2,4(r4)
 32141b8:	1885c83a 	sub	r2,r3,r2
 32141bc:	f800283a 	ret

032141c0 <__make_fp>:
 32141c0:	defffb04 	addi	sp,sp,-20
 32141c4:	d9000015 	stw	r4,0(sp)
 32141c8:	d809883a 	mov	r4,sp
 32141cc:	dfc00415 	stw	ra,16(sp)
 32141d0:	d9400115 	stw	r5,4(sp)
 32141d4:	d9800215 	stw	r6,8(sp)
 32141d8:	d9c00315 	stw	r7,12(sp)
 32141dc:	32147000 	call	3214700 <__pack_f>
 32141e0:	dfc00417 	ldw	ra,16(sp)
 32141e4:	dec00504 	addi	sp,sp,20
 32141e8:	f800283a 	ret

032141ec <__pack_d>:
 32141ec:	20c00017 	ldw	r3,0(r4)
 32141f0:	defffd04 	addi	sp,sp,-12
 32141f4:	dc000015 	stw	r16,0(sp)
 32141f8:	dc800215 	stw	r18,8(sp)
 32141fc:	dc400115 	stw	r17,4(sp)
 3214200:	00800044 	movi	r2,1
 3214204:	22000317 	ldw	r8,12(r4)
 3214208:	001f883a 	mov	r15,zero
 321420c:	22400417 	ldw	r9,16(r4)
 3214210:	24000117 	ldw	r16,4(r4)
 3214214:	10c0552e 	bgeu	r2,r3,321436c <__pack_d+0x180>
 3214218:	00800104 	movi	r2,4
 321421c:	18804f26 	beq	r3,r2,321435c <__pack_d+0x170>
 3214220:	00800084 	movi	r2,2
 3214224:	18800226 	beq	r3,r2,3214230 <__pack_d+0x44>
 3214228:	4244b03a 	or	r2,r8,r9
 321422c:	10001a1e 	bne	r2,zero,3214298 <__pack_d+0xac>
 3214230:	000d883a 	mov	r6,zero
 3214234:	000f883a 	mov	r7,zero
 3214238:	0011883a 	mov	r8,zero
 321423c:	00800434 	movhi	r2,16
 3214240:	10bfffc4 	addi	r2,r2,-1
 3214244:	301d883a 	mov	r14,r6
 3214248:	3884703a 	and	r2,r7,r2
 321424c:	400a953a 	slli	r5,r8,20
 3214250:	79bffc2c 	andhi	r6,r15,65520
 3214254:	308cb03a 	or	r6,r6,r2
 3214258:	00e00434 	movhi	r3,32784
 321425c:	18ffffc4 	addi	r3,r3,-1
 3214260:	800497fa 	slli	r2,r16,31
 3214264:	30c6703a 	and	r3,r6,r3
 3214268:	1946b03a 	or	r3,r3,r5
 321426c:	01600034 	movhi	r5,32768
 3214270:	297fffc4 	addi	r5,r5,-1
 3214274:	194a703a 	and	r5,r3,r5
 3214278:	288ab03a 	or	r5,r5,r2
 321427c:	2807883a 	mov	r3,r5
 3214280:	7005883a 	mov	r2,r14
 3214284:	dc800217 	ldw	r18,8(sp)
 3214288:	dc400117 	ldw	r17,4(sp)
 321428c:	dc000017 	ldw	r16,0(sp)
 3214290:	dec00304 	addi	sp,sp,12
 3214294:	f800283a 	ret
 3214298:	21000217 	ldw	r4,8(r4)
 321429c:	00bf0084 	movi	r2,-1022
 32142a0:	20803f16 	blt	r4,r2,32143a0 <__pack_d+0x1b4>
 32142a4:	0080ffc4 	movi	r2,1023
 32142a8:	11002c16 	blt	r2,r4,321435c <__pack_d+0x170>
 32142ac:	00803fc4 	movi	r2,255
 32142b0:	408c703a 	and	r6,r8,r2
 32142b4:	00802004 	movi	r2,128
 32142b8:	0007883a 	mov	r3,zero
 32142bc:	000f883a 	mov	r7,zero
 32142c0:	2280ffc4 	addi	r10,r4,1023
 32142c4:	30801e26 	beq	r6,r2,3214340 <__pack_d+0x154>
 32142c8:	00801fc4 	movi	r2,127
 32142cc:	4089883a 	add	r4,r8,r2
 32142d0:	220d803a 	cmpltu	r6,r4,r8
 32142d4:	324d883a 	add	r6,r6,r9
 32142d8:	2011883a 	mov	r8,r4
 32142dc:	3013883a 	mov	r9,r6
 32142e0:	00880034 	movhi	r2,8192
 32142e4:	10bfffc4 	addi	r2,r2,-1
 32142e8:	12400d36 	bltu	r2,r9,3214320 <__pack_d+0x134>
 32142ec:	4804963a 	slli	r2,r9,24
 32142f0:	400cd23a 	srli	r6,r8,8
 32142f4:	480ed23a 	srli	r7,r9,8
 32142f8:	013fffc4 	movi	r4,-1
 32142fc:	118cb03a 	or	r6,r2,r6
 3214300:	01400434 	movhi	r5,16
 3214304:	297fffc4 	addi	r5,r5,-1
 3214308:	3104703a 	and	r2,r6,r4
 321430c:	3946703a 	and	r3,r7,r5
 3214310:	5201ffcc 	andi	r8,r10,2047
 3214314:	100d883a 	mov	r6,r2
 3214318:	180f883a 	mov	r7,r3
 321431c:	003fc706 	br	321423c <__pack_d+0x50>
 3214320:	480897fa 	slli	r4,r9,31
 3214324:	4004d07a 	srli	r2,r8,1
 3214328:	4806d07a 	srli	r3,r9,1
 321432c:	52800044 	addi	r10,r10,1
 3214330:	2084b03a 	or	r2,r4,r2
 3214334:	1011883a 	mov	r8,r2
 3214338:	1813883a 	mov	r9,r3
 321433c:	003feb06 	br	32142ec <__pack_d+0x100>
 3214340:	383fe11e 	bne	r7,zero,32142c8 <__pack_d+0xdc>
 3214344:	01004004 	movi	r4,256
 3214348:	4104703a 	and	r2,r8,r4
 321434c:	10c4b03a 	or	r2,r2,r3
 3214350:	103fe326 	beq	r2,zero,32142e0 <__pack_d+0xf4>
 3214354:	3005883a 	mov	r2,r6
 3214358:	003fdc06 	br	32142cc <__pack_d+0xe0>
 321435c:	000d883a 	mov	r6,zero
 3214360:	000f883a 	mov	r7,zero
 3214364:	0201ffc4 	movi	r8,2047
 3214368:	003fb406 	br	321423c <__pack_d+0x50>
 321436c:	0005883a 	mov	r2,zero
 3214370:	00c00234 	movhi	r3,8
 3214374:	408cb03a 	or	r6,r8,r2
 3214378:	48ceb03a 	or	r7,r9,r3
 321437c:	013fffc4 	movi	r4,-1
 3214380:	01400434 	movhi	r5,16
 3214384:	297fffc4 	addi	r5,r5,-1
 3214388:	3104703a 	and	r2,r6,r4
 321438c:	3946703a 	and	r3,r7,r5
 3214390:	100d883a 	mov	r6,r2
 3214394:	180f883a 	mov	r7,r3
 3214398:	0201ffc4 	movi	r8,2047
 321439c:	003fa706 	br	321423c <__pack_d+0x50>
 32143a0:	1109c83a 	sub	r4,r2,r4
 32143a4:	00800e04 	movi	r2,56
 32143a8:	11004316 	blt	r2,r4,32144b8 <__pack_d+0x2cc>
 32143ac:	21fff804 	addi	r7,r4,-32
 32143b0:	38004516 	blt	r7,zero,32144c8 <__pack_d+0x2dc>
 32143b4:	49d8d83a 	srl	r12,r9,r7
 32143b8:	001b883a 	mov	r13,zero
 32143bc:	0023883a 	mov	r17,zero
 32143c0:	01400044 	movi	r5,1
 32143c4:	0025883a 	mov	r18,zero
 32143c8:	38004716 	blt	r7,zero,32144e8 <__pack_d+0x2fc>
 32143cc:	29d6983a 	sll	r11,r5,r7
 32143d0:	0015883a 	mov	r10,zero
 32143d4:	00bfffc4 	movi	r2,-1
 32143d8:	5089883a 	add	r4,r10,r2
 32143dc:	588b883a 	add	r5,r11,r2
 32143e0:	228d803a 	cmpltu	r6,r4,r10
 32143e4:	314b883a 	add	r5,r6,r5
 32143e8:	4104703a 	and	r2,r8,r4
 32143ec:	4946703a 	and	r3,r9,r5
 32143f0:	10c4b03a 	or	r2,r2,r3
 32143f4:	10000226 	beq	r2,zero,3214400 <__pack_d+0x214>
 32143f8:	04400044 	movi	r17,1
 32143fc:	0025883a 	mov	r18,zero
 3214400:	00803fc4 	movi	r2,255
 3214404:	644eb03a 	or	r7,r12,r17
 3214408:	3892703a 	and	r9,r7,r2
 321440c:	00802004 	movi	r2,128
 3214410:	6c90b03a 	or	r8,r13,r18
 3214414:	0015883a 	mov	r10,zero
 3214418:	48801626 	beq	r9,r2,3214474 <__pack_d+0x288>
 321441c:	01001fc4 	movi	r4,127
 3214420:	3905883a 	add	r2,r7,r4
 3214424:	11cd803a 	cmpltu	r6,r2,r7
 3214428:	320d883a 	add	r6,r6,r8
 321442c:	100f883a 	mov	r7,r2
 3214430:	00840034 	movhi	r2,4096
 3214434:	10bfffc4 	addi	r2,r2,-1
 3214438:	3011883a 	mov	r8,r6
 321443c:	0007883a 	mov	r3,zero
 3214440:	11801b36 	bltu	r2,r6,32144b0 <__pack_d+0x2c4>
 3214444:	4004963a 	slli	r2,r8,24
 3214448:	3808d23a 	srli	r4,r7,8
 321444c:	400ad23a 	srli	r5,r8,8
 3214450:	1813883a 	mov	r9,r3
 3214454:	1108b03a 	or	r4,r2,r4
 3214458:	00bfffc4 	movi	r2,-1
 321445c:	00c00434 	movhi	r3,16
 3214460:	18ffffc4 	addi	r3,r3,-1
 3214464:	208c703a 	and	r6,r4,r2
 3214468:	28ce703a 	and	r7,r5,r3
 321446c:	4a01ffcc 	andi	r8,r9,2047
 3214470:	003f7206 	br	321423c <__pack_d+0x50>
 3214474:	503fe91e 	bne	r10,zero,321441c <__pack_d+0x230>
 3214478:	01004004 	movi	r4,256
 321447c:	3904703a 	and	r2,r7,r4
 3214480:	0007883a 	mov	r3,zero
 3214484:	10c4b03a 	or	r2,r2,r3
 3214488:	10000626 	beq	r2,zero,32144a4 <__pack_d+0x2b8>
 321448c:	3a45883a 	add	r2,r7,r9
 3214490:	11cd803a 	cmpltu	r6,r2,r7
 3214494:	320d883a 	add	r6,r6,r8
 3214498:	100f883a 	mov	r7,r2
 321449c:	3011883a 	mov	r8,r6
 32144a0:	0007883a 	mov	r3,zero
 32144a4:	00840034 	movhi	r2,4096
 32144a8:	10bfffc4 	addi	r2,r2,-1
 32144ac:	123fe52e 	bgeu	r2,r8,3214444 <__pack_d+0x258>
 32144b0:	00c00044 	movi	r3,1
 32144b4:	003fe306 	br	3214444 <__pack_d+0x258>
 32144b8:	0009883a 	mov	r4,zero
 32144bc:	0013883a 	mov	r9,zero
 32144c0:	000b883a 	mov	r5,zero
 32144c4:	003fe406 	br	3214458 <__pack_d+0x26c>
 32144c8:	4a47883a 	add	r3,r9,r9
 32144cc:	008007c4 	movi	r2,31
 32144d0:	1105c83a 	sub	r2,r2,r4
 32144d4:	1886983a 	sll	r3,r3,r2
 32144d8:	4118d83a 	srl	r12,r8,r4
 32144dc:	491ad83a 	srl	r13,r9,r4
 32144e0:	1b18b03a 	or	r12,r3,r12
 32144e4:	003fb506 	br	32143bc <__pack_d+0x1d0>
 32144e8:	2806d07a 	srli	r3,r5,1
 32144ec:	008007c4 	movi	r2,31
 32144f0:	1105c83a 	sub	r2,r2,r4
 32144f4:	1896d83a 	srl	r11,r3,r2
 32144f8:	2914983a 	sll	r10,r5,r4
 32144fc:	003fb506 	br	32143d4 <__pack_d+0x1e8>

03214500 <__unpack_d>:
 3214500:	20c00117 	ldw	r3,4(r4)
 3214504:	22400017 	ldw	r9,0(r4)
 3214508:	00800434 	movhi	r2,16
 321450c:	10bfffc4 	addi	r2,r2,-1
 3214510:	1808d53a 	srli	r4,r3,20
 3214514:	180cd7fa 	srli	r6,r3,31
 3214518:	1894703a 	and	r10,r3,r2
 321451c:	2201ffcc 	andi	r8,r4,2047
 3214520:	281b883a 	mov	r13,r5
 3214524:	4817883a 	mov	r11,r9
 3214528:	29800115 	stw	r6,4(r5)
 321452c:	5019883a 	mov	r12,r10
 3214530:	40001e1e 	bne	r8,zero,32145ac <__unpack_d+0xac>
 3214534:	4a84b03a 	or	r2,r9,r10
 3214538:	10001926 	beq	r2,zero,32145a0 <__unpack_d+0xa0>
 321453c:	4804d63a 	srli	r2,r9,24
 3214540:	500c923a 	slli	r6,r10,8
 3214544:	013f0084 	movi	r4,-1022
 3214548:	00c40034 	movhi	r3,4096
 321454c:	18ffffc4 	addi	r3,r3,-1
 3214550:	118cb03a 	or	r6,r2,r6
 3214554:	008000c4 	movi	r2,3
 3214558:	480a923a 	slli	r5,r9,8
 321455c:	68800015 	stw	r2,0(r13)
 3214560:	69000215 	stw	r4,8(r13)
 3214564:	19800b36 	bltu	r3,r6,3214594 <__unpack_d+0x94>
 3214568:	200f883a 	mov	r7,r4
 321456c:	1811883a 	mov	r8,r3
 3214570:	2945883a 	add	r2,r5,r5
 3214574:	1149803a 	cmpltu	r4,r2,r5
 3214578:	3187883a 	add	r3,r6,r6
 321457c:	20c9883a 	add	r4,r4,r3
 3214580:	100b883a 	mov	r5,r2
 3214584:	200d883a 	mov	r6,r4
 3214588:	39ffffc4 	addi	r7,r7,-1
 321458c:	413ff82e 	bgeu	r8,r4,3214570 <__unpack_d+0x70>
 3214590:	69c00215 	stw	r7,8(r13)
 3214594:	69800415 	stw	r6,16(r13)
 3214598:	69400315 	stw	r5,12(r13)
 321459c:	f800283a 	ret
 32145a0:	00800084 	movi	r2,2
 32145a4:	28800015 	stw	r2,0(r5)
 32145a8:	f800283a 	ret
 32145ac:	0081ffc4 	movi	r2,2047
 32145b0:	40800f26 	beq	r8,r2,32145f0 <__unpack_d+0xf0>
 32145b4:	480cd63a 	srli	r6,r9,24
 32145b8:	5006923a 	slli	r3,r10,8
 32145bc:	4804923a 	slli	r2,r9,8
 32145c0:	0009883a 	mov	r4,zero
 32145c4:	30c6b03a 	or	r3,r6,r3
 32145c8:	01440034 	movhi	r5,4096
 32145cc:	110cb03a 	or	r6,r2,r4
 32145d0:	423f0044 	addi	r8,r8,-1023
 32145d4:	194eb03a 	or	r7,r3,r5
 32145d8:	008000c4 	movi	r2,3
 32145dc:	69c00415 	stw	r7,16(r13)
 32145e0:	6a000215 	stw	r8,8(r13)
 32145e4:	68800015 	stw	r2,0(r13)
 32145e8:	69800315 	stw	r6,12(r13)
 32145ec:	f800283a 	ret
 32145f0:	4a84b03a 	or	r2,r9,r10
 32145f4:	1000031e 	bne	r2,zero,3214604 <__unpack_d+0x104>
 32145f8:	00800104 	movi	r2,4
 32145fc:	28800015 	stw	r2,0(r5)
 3214600:	f800283a 	ret
 3214604:	0009883a 	mov	r4,zero
 3214608:	01400234 	movhi	r5,8
 321460c:	4904703a 	and	r2,r9,r4
 3214610:	5146703a 	and	r3,r10,r5
 3214614:	10c4b03a 	or	r2,r2,r3
 3214618:	10000526 	beq	r2,zero,3214630 <__unpack_d+0x130>
 321461c:	00800044 	movi	r2,1
 3214620:	68800015 	stw	r2,0(r13)
 3214624:	6b000415 	stw	r12,16(r13)
 3214628:	6ac00315 	stw	r11,12(r13)
 321462c:	f800283a 	ret
 3214630:	68000015 	stw	zero,0(r13)
 3214634:	003ffb06 	br	3214624 <__unpack_d+0x124>

03214638 <__fpcmp_parts_d>:
 3214638:	21800017 	ldw	r6,0(r4)
 321463c:	00c00044 	movi	r3,1
 3214640:	19800a2e 	bgeu	r3,r6,321466c <__fpcmp_parts_d+0x34>
 3214644:	28800017 	ldw	r2,0(r5)
 3214648:	1880082e 	bgeu	r3,r2,321466c <__fpcmp_parts_d+0x34>
 321464c:	00c00104 	movi	r3,4
 3214650:	30c02626 	beq	r6,r3,32146ec <__fpcmp_parts_d+0xb4>
 3214654:	10c02226 	beq	r2,r3,32146e0 <__fpcmp_parts_d+0xa8>
 3214658:	00c00084 	movi	r3,2
 321465c:	30c00526 	beq	r6,r3,3214674 <__fpcmp_parts_d+0x3c>
 3214660:	10c0071e 	bne	r2,r3,3214680 <__fpcmp_parts_d+0x48>
 3214664:	20800117 	ldw	r2,4(r4)
 3214668:	1000091e 	bne	r2,zero,3214690 <__fpcmp_parts_d+0x58>
 321466c:	00800044 	movi	r2,1
 3214670:	f800283a 	ret
 3214674:	10c01a1e 	bne	r2,r3,32146e0 <__fpcmp_parts_d+0xa8>
 3214678:	0005883a 	mov	r2,zero
 321467c:	f800283a 	ret
 3214680:	22000117 	ldw	r8,4(r4)
 3214684:	28800117 	ldw	r2,4(r5)
 3214688:	40800326 	beq	r8,r2,3214698 <__fpcmp_parts_d+0x60>
 321468c:	403ff726 	beq	r8,zero,321466c <__fpcmp_parts_d+0x34>
 3214690:	00bfffc4 	movi	r2,-1
 3214694:	f800283a 	ret
 3214698:	20c00217 	ldw	r3,8(r4)
 321469c:	28800217 	ldw	r2,8(r5)
 32146a0:	10fffa16 	blt	r2,r3,321468c <__fpcmp_parts_d+0x54>
 32146a4:	18800916 	blt	r3,r2,32146cc <__fpcmp_parts_d+0x94>
 32146a8:	21c00417 	ldw	r7,16(r4)
 32146ac:	28c00417 	ldw	r3,16(r5)
 32146b0:	21800317 	ldw	r6,12(r4)
 32146b4:	28800317 	ldw	r2,12(r5)
 32146b8:	19fff436 	bltu	r3,r7,321468c <__fpcmp_parts_d+0x54>
 32146bc:	38c00526 	beq	r7,r3,32146d4 <__fpcmp_parts_d+0x9c>
 32146c0:	38c00236 	bltu	r7,r3,32146cc <__fpcmp_parts_d+0x94>
 32146c4:	19ffec1e 	bne	r3,r7,3214678 <__fpcmp_parts_d+0x40>
 32146c8:	30bfeb2e 	bgeu	r6,r2,3214678 <__fpcmp_parts_d+0x40>
 32146cc:	403fe71e 	bne	r8,zero,321466c <__fpcmp_parts_d+0x34>
 32146d0:	003fef06 	br	3214690 <__fpcmp_parts_d+0x58>
 32146d4:	11bffa2e 	bgeu	r2,r6,32146c0 <__fpcmp_parts_d+0x88>
 32146d8:	403fe426 	beq	r8,zero,321466c <__fpcmp_parts_d+0x34>
 32146dc:	003fec06 	br	3214690 <__fpcmp_parts_d+0x58>
 32146e0:	28800117 	ldw	r2,4(r5)
 32146e4:	103fe11e 	bne	r2,zero,321466c <__fpcmp_parts_d+0x34>
 32146e8:	003fe906 	br	3214690 <__fpcmp_parts_d+0x58>
 32146ec:	11bfdd1e 	bne	r2,r6,3214664 <__fpcmp_parts_d+0x2c>
 32146f0:	28c00117 	ldw	r3,4(r5)
 32146f4:	20800117 	ldw	r2,4(r4)
 32146f8:	1885c83a 	sub	r2,r3,r2
 32146fc:	f800283a 	ret

03214700 <__pack_f>:
 3214700:	20c00017 	ldw	r3,0(r4)
 3214704:	01c00044 	movi	r7,1
 3214708:	21800317 	ldw	r6,12(r4)
 321470c:	21400117 	ldw	r5,4(r4)
 3214710:	38c02d2e 	bgeu	r7,r3,32147c8 <__pack_f+0xc8>
 3214714:	00800104 	movi	r2,4
 3214718:	18802826 	beq	r3,r2,32147bc <__pack_f+0xbc>
 321471c:	00800084 	movi	r2,2
 3214720:	18800126 	beq	r3,r2,3214728 <__pack_f+0x28>
 3214724:	3000101e 	bne	r6,zero,3214768 <__pack_f+0x68>
 3214728:	000d883a 	mov	r6,zero
 321472c:	0007883a 	mov	r3,zero
 3214730:	19003fcc 	andi	r4,r3,255
 3214734:	200895fa 	slli	r4,r4,23
 3214738:	00c02034 	movhi	r3,128
 321473c:	18ffffc4 	addi	r3,r3,-1
 3214740:	30c6703a 	and	r3,r6,r3
 3214744:	10a0002c 	andhi	r2,r2,32768
 3214748:	10c4b03a 	or	r2,r2,r3
 321474c:	280a97fa 	slli	r5,r5,31
 3214750:	1104b03a 	or	r2,r2,r4
 3214754:	00e00034 	movhi	r3,32768
 3214758:	18ffffc4 	addi	r3,r3,-1
 321475c:	10c4703a 	and	r2,r2,r3
 3214760:	1144b03a 	or	r2,r2,r5
 3214764:	f800283a 	ret
 3214768:	21000217 	ldw	r4,8(r4)
 321476c:	00bfe084 	movi	r2,-126
 3214770:	20801b16 	blt	r4,r2,32147e0 <__pack_f+0xe0>
 3214774:	00801fc4 	movi	r2,127
 3214778:	11001016 	blt	r2,r4,32147bc <__pack_f+0xbc>
 321477c:	308e703a 	and	r7,r6,r2
 3214780:	2087883a 	add	r3,r4,r2
 3214784:	00801004 	movi	r2,64
 3214788:	38800526 	beq	r7,r2,32147a0 <__pack_f+0xa0>
 321478c:	31800fc4 	addi	r6,r6,63
 3214790:	30000716 	blt	r6,zero,32147b0 <__pack_f+0xb0>
 3214794:	300490ba 	slli	r2,r6,2
 3214798:	100cd27a 	srli	r6,r2,9
 321479c:	003fe406 	br	3214730 <__pack_f+0x30>
 32147a0:	3080200c 	andi	r2,r6,128
 32147a4:	103ffa26 	beq	r2,zero,3214790 <__pack_f+0x90>
 32147a8:	31cd883a 	add	r6,r6,r7
 32147ac:	003ff806 	br	3214790 <__pack_f+0x90>
 32147b0:	300cd07a 	srli	r6,r6,1
 32147b4:	18c00044 	addi	r3,r3,1
 32147b8:	003ff606 	br	3214794 <__pack_f+0x94>
 32147bc:	000d883a 	mov	r6,zero
 32147c0:	00ffffc4 	movi	r3,-1
 32147c4:	003fda06 	br	3214730 <__pack_f+0x30>
 32147c8:	31800434 	orhi	r6,r6,16
 32147cc:	00802034 	movhi	r2,128
 32147d0:	10bfffc4 	addi	r2,r2,-1
 32147d4:	308c703a 	and	r6,r6,r2
 32147d8:	00ffffc4 	movi	r3,-1
 32147dc:	003fd406 	br	3214730 <__pack_f+0x30>
 32147e0:	1109c83a 	sub	r4,r2,r4
 32147e4:	00800644 	movi	r2,25
 32147e8:	11001216 	blt	r2,r4,3214834 <__pack_f+0x134>
 32147ec:	3904983a 	sll	r2,r7,r4
 32147f0:	3106d83a 	srl	r3,r6,r4
 32147f4:	10bfffc4 	addi	r2,r2,-1
 32147f8:	3084703a 	and	r2,r6,r2
 32147fc:	1004c03a 	cmpne	r2,r2,zero
 3214800:	1886b03a 	or	r3,r3,r2
 3214804:	19001fcc 	andi	r4,r3,127
 3214808:	00801004 	movi	r2,64
 321480c:	20800c26 	beq	r4,r2,3214840 <__pack_f+0x140>
 3214810:	18c00fc4 	addi	r3,r3,63
 3214814:	00900034 	movhi	r2,16384
 3214818:	10bfffc4 	addi	r2,r2,-1
 321481c:	180cd1fa 	srli	r6,r3,7
 3214820:	10c7803a 	cmpltu	r3,r2,r3
 3214824:	00802034 	movhi	r2,128
 3214828:	10bfffc4 	addi	r2,r2,-1
 321482c:	308c703a 	and	r6,r6,r2
 3214830:	003fbf06 	br	3214730 <__pack_f+0x30>
 3214834:	0007883a 	mov	r3,zero
 3214838:	000d883a 	mov	r6,zero
 321483c:	003ff906 	br	3214824 <__pack_f+0x124>
 3214840:	1880200c 	andi	r2,r3,128
 3214844:	10000126 	beq	r2,zero,321484c <__pack_f+0x14c>
 3214848:	1907883a 	add	r3,r3,r4
 321484c:	180cd1fa 	srli	r6,r3,7
 3214850:	00900034 	movhi	r2,16384
 3214854:	10bfffc4 	addi	r2,r2,-1
 3214858:	10c7803a 	cmpltu	r3,r2,r3
 321485c:	003ff106 	br	3214824 <__pack_f+0x124>

03214860 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 3214860:	defffb04 	addi	sp,sp,-20
 3214864:	dfc00415 	stw	ra,16(sp)
 3214868:	df000315 	stw	fp,12(sp)
 321486c:	df000304 	addi	fp,sp,12
 3214870:	e13ffe15 	stw	r4,-8(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 3214874:	e13ffe17 	ldw	r4,-8(fp)
 3214878:	d1600704 	addi	r5,gp,-32740
 321487c:	323a8580 	call	323a858 <alt_find_dev>
 3214880:	e0bffd15 	stw	r2,-12(fp)

  if ((dev) && dev->open)
 3214884:	e0bffd17 	ldw	r2,-12(fp)
 3214888:	1005003a 	cmpeq	r2,r2,zero
 321488c:	10000b1e 	bne	r2,zero,32148bc <alt_flash_open_dev+0x5c>
 3214890:	e0bffd17 	ldw	r2,-12(fp)
 3214894:	10800317 	ldw	r2,12(r2)
 3214898:	1005003a 	cmpeq	r2,r2,zero
 321489c:	1000071e 	bne	r2,zero,32148bc <alt_flash_open_dev+0x5c>
  {
    return dev->open(dev, name);
 32148a0:	e0bffd17 	ldw	r2,-12(fp)
 32148a4:	10800317 	ldw	r2,12(r2)
 32148a8:	e13ffd17 	ldw	r4,-12(fp)
 32148ac:	e17ffe17 	ldw	r5,-8(fp)
 32148b0:	103ee83a 	callr	r2
 32148b4:	e0bfff15 	stw	r2,-4(fp)
 32148b8:	00000206 	br	32148c4 <alt_flash_open_dev+0x64>
  }

  return dev;
 32148bc:	e0bffd17 	ldw	r2,-12(fp)
 32148c0:	e0bfff15 	stw	r2,-4(fp)
 32148c4:	e0bfff17 	ldw	r2,-4(fp)
}
 32148c8:	e037883a 	mov	sp,fp
 32148cc:	dfc00117 	ldw	ra,4(sp)
 32148d0:	df000017 	ldw	fp,0(sp)
 32148d4:	dec00204 	addi	sp,sp,8
 32148d8:	f800283a 	ret

032148dc <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 32148dc:	defffd04 	addi	sp,sp,-12
 32148e0:	dfc00215 	stw	ra,8(sp)
 32148e4:	df000115 	stw	fp,4(sp)
 32148e8:	df000104 	addi	fp,sp,4
 32148ec:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 32148f0:	e0bfff17 	ldw	r2,-4(fp)
 32148f4:	1005003a 	cmpeq	r2,r2,zero
 32148f8:	1000081e 	bne	r2,zero,321491c <alt_flash_close_dev+0x40>
 32148fc:	e0bfff17 	ldw	r2,-4(fp)
 3214900:	10800417 	ldw	r2,16(r2)
 3214904:	1005003a 	cmpeq	r2,r2,zero
 3214908:	1000041e 	bne	r2,zero,321491c <alt_flash_close_dev+0x40>
  {
    fd->close(fd);
 321490c:	e0bfff17 	ldw	r2,-4(fp)
 3214910:	10800417 	ldw	r2,16(r2)
 3214914:	e13fff17 	ldw	r4,-4(fp)
 3214918:	103ee83a 	callr	r2
  }
  return;
}
 321491c:	e037883a 	mov	sp,fp
 3214920:	dfc00117 	ldw	ra,4(sp)
 3214924:	df000017 	ldw	fp,0(sp)
 3214928:	dec00204 	addi	sp,sp,8
 321492c:	f800283a 	ret

03214930 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 3214930:	defff904 	addi	sp,sp,-28
 3214934:	dfc00615 	stw	ra,24(sp)
 3214938:	df000515 	stw	fp,20(sp)
 321493c:	df000504 	addi	fp,sp,20
 3214940:	e13ffc15 	stw	r4,-16(fp)
 3214944:	e17ffd15 	stw	r5,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 3214948:	e0bffc17 	ldw	r2,-16(fp)
 321494c:	1004803a 	cmplt	r2,r2,zero
 3214950:	1000081e 	bne	r2,zero,3214974 <fstat+0x44>
 3214954:	e0bffc17 	ldw	r2,-16(fp)
 3214958:	10800324 	muli	r2,r2,12
 321495c:	1007883a 	mov	r3,r2
 3214960:	0080c974 	movhi	r2,805
 3214964:	10896e04 	addi	r2,r2,9656
 3214968:	1887883a 	add	r3,r3,r2
 321496c:	e0ffff15 	stw	r3,-4(fp)
 3214970:	00000106 	br	3214978 <fstat+0x48>
 3214974:	e03fff15 	stw	zero,-4(fp)
 3214978:	e0bfff17 	ldw	r2,-4(fp)
 321497c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 3214980:	e0bffb17 	ldw	r2,-20(fp)
 3214984:	1005003a 	cmpeq	r2,r2,zero
 3214988:	1000121e 	bne	r2,zero,32149d4 <fstat+0xa4>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 321498c:	e0bffb17 	ldw	r2,-20(fp)
 3214990:	10800017 	ldw	r2,0(r2)
 3214994:	10800817 	ldw	r2,32(r2)
 3214998:	1005003a 	cmpeq	r2,r2,zero
 321499c:	1000081e 	bne	r2,zero,32149c0 <fstat+0x90>
    {
      return fd->dev->fstat(fd, st);
 32149a0:	e0bffb17 	ldw	r2,-20(fp)
 32149a4:	10800017 	ldw	r2,0(r2)
 32149a8:	10800817 	ldw	r2,32(r2)
 32149ac:	e13ffb17 	ldw	r4,-20(fp)
 32149b0:	e17ffd17 	ldw	r5,-12(fp)
 32149b4:	103ee83a 	callr	r2
 32149b8:	e0bffe15 	stw	r2,-8(fp)
 32149bc:	00000b06 	br	32149ec <fstat+0xbc>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 32149c0:	e0fffd17 	ldw	r3,-12(fp)
 32149c4:	00880004 	movi	r2,8192
 32149c8:	18800115 	stw	r2,4(r3)
      return 0;
 32149cc:	e03ffe15 	stw	zero,-8(fp)
 32149d0:	00000606 	br	32149ec <fstat+0xbc>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 32149d4:	3214a040 	call	3214a04 <alt_get_errno>
 32149d8:	1007883a 	mov	r3,r2
 32149dc:	00801444 	movi	r2,81
 32149e0:	18800015 	stw	r2,0(r3)
    return -1;
 32149e4:	00bfffc4 	movi	r2,-1
 32149e8:	e0bffe15 	stw	r2,-8(fp)
 32149ec:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 32149f0:	e037883a 	mov	sp,fp
 32149f4:	dfc00117 	ldw	ra,4(sp)
 32149f8:	df000017 	ldw	fp,0(sp)
 32149fc:	dec00204 	addi	sp,sp,8
 3214a00:	f800283a 	ret

03214a04 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 3214a04:	defffd04 	addi	sp,sp,-12
 3214a08:	dfc00215 	stw	ra,8(sp)
 3214a0c:	df000115 	stw	fp,4(sp)
 3214a10:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 3214a14:	0080c974 	movhi	r2,805
 3214a18:	108aa504 	addi	r2,r2,10900
 3214a1c:	10800017 	ldw	r2,0(r2)
 3214a20:	1005003a 	cmpeq	r2,r2,zero
 3214a24:	1000061e 	bne	r2,zero,3214a40 <alt_get_errno+0x3c>
 3214a28:	0080c974 	movhi	r2,805
 3214a2c:	108aa504 	addi	r2,r2,10900
 3214a30:	10800017 	ldw	r2,0(r2)
 3214a34:	103ee83a 	callr	r2
 3214a38:	e0bfff15 	stw	r2,-4(fp)
 3214a3c:	00000306 	br	3214a4c <alt_get_errno+0x48>
 3214a40:	0080c974 	movhi	r2,805
 3214a44:	1092f804 	addi	r2,r2,19424
 3214a48:	e0bfff15 	stw	r2,-4(fp)
 3214a4c:	e0bfff17 	ldw	r2,-4(fp)
}
 3214a50:	e037883a 	mov	sp,fp
 3214a54:	dfc00117 	ldw	ra,4(sp)
 3214a58:	df000017 	ldw	fp,0(sp)
 3214a5c:	dec00204 	addi	sp,sp,8
 3214a60:	f800283a 	ret

03214a64 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 3214a64:	deffeb04 	addi	sp,sp,-84
 3214a68:	dfc01415 	stw	ra,80(sp)
 3214a6c:	df001315 	stw	fp,76(sp)
 3214a70:	df001304 	addi	fp,sp,76
 3214a74:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 3214a78:	e0bffd17 	ldw	r2,-12(fp)
 3214a7c:	1004803a 	cmplt	r2,r2,zero
 3214a80:	1000081e 	bne	r2,zero,3214aa4 <isatty+0x40>
 3214a84:	e0bffd17 	ldw	r2,-12(fp)
 3214a88:	10800324 	muli	r2,r2,12
 3214a8c:	1007883a 	mov	r3,r2
 3214a90:	0080c974 	movhi	r2,805
 3214a94:	10896e04 	addi	r2,r2,9656
 3214a98:	1887883a 	add	r3,r3,r2
 3214a9c:	e0ffff15 	stw	r3,-4(fp)
 3214aa0:	00000106 	br	3214aa8 <isatty+0x44>
 3214aa4:	e03fff15 	stw	zero,-4(fp)
 3214aa8:	e0bfff17 	ldw	r2,-4(fp)
 3214aac:	e0bfed15 	stw	r2,-76(fp)
  
  if (fd)
 3214ab0:	e0bfed17 	ldw	r2,-76(fp)
 3214ab4:	1005003a 	cmpeq	r2,r2,zero
 3214ab8:	10000f1e 	bne	r2,zero,3214af8 <isatty+0x94>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 3214abc:	e0bfed17 	ldw	r2,-76(fp)
 3214ac0:	10800017 	ldw	r2,0(r2)
 3214ac4:	10800817 	ldw	r2,32(r2)
 3214ac8:	1004c03a 	cmpne	r2,r2,zero
 3214acc:	1000031e 	bne	r2,zero,3214adc <isatty+0x78>
    {
      return 1;
 3214ad0:	00800044 	movi	r2,1
 3214ad4:	e0bffe15 	stw	r2,-8(fp)
 3214ad8:	00000c06 	br	3214b0c <isatty+0xa8>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 3214adc:	e17fee04 	addi	r5,fp,-72
 3214ae0:	e13ffd17 	ldw	r4,-12(fp)
 3214ae4:	32149300 	call	3214930 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 3214ae8:	e0bfef17 	ldw	r2,-68(fp)
 3214aec:	10880020 	cmpeqi	r2,r2,8192
 3214af0:	e0bffe15 	stw	r2,-8(fp)
 3214af4:	00000506 	br	3214b0c <isatty+0xa8>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 3214af8:	3214b240 	call	3214b24 <alt_get_errno>
 3214afc:	1007883a 	mov	r3,r2
 3214b00:	00801444 	movi	r2,81
 3214b04:	18800015 	stw	r2,0(r3)
    return 0;
 3214b08:	e03ffe15 	stw	zero,-8(fp)
 3214b0c:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 3214b10:	e037883a 	mov	sp,fp
 3214b14:	dfc00117 	ldw	ra,4(sp)
 3214b18:	df000017 	ldw	fp,0(sp)
 3214b1c:	dec00204 	addi	sp,sp,8
 3214b20:	f800283a 	ret

03214b24 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 3214b24:	defffd04 	addi	sp,sp,-12
 3214b28:	dfc00215 	stw	ra,8(sp)
 3214b2c:	df000115 	stw	fp,4(sp)
 3214b30:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 3214b34:	0080c974 	movhi	r2,805
 3214b38:	108aa504 	addi	r2,r2,10900
 3214b3c:	10800017 	ldw	r2,0(r2)
 3214b40:	1005003a 	cmpeq	r2,r2,zero
 3214b44:	1000061e 	bne	r2,zero,3214b60 <alt_get_errno+0x3c>
 3214b48:	0080c974 	movhi	r2,805
 3214b4c:	108aa504 	addi	r2,r2,10900
 3214b50:	10800017 	ldw	r2,0(r2)
 3214b54:	103ee83a 	callr	r2
 3214b58:	e0bfff15 	stw	r2,-4(fp)
 3214b5c:	00000306 	br	3214b6c <alt_get_errno+0x48>
 3214b60:	0080c974 	movhi	r2,805
 3214b64:	1092f804 	addi	r2,r2,19424
 3214b68:	e0bfff15 	stw	r2,-4(fp)
 3214b6c:	e0bfff17 	ldw	r2,-4(fp)
}
 3214b70:	e037883a 	mov	sp,fp
 3214b74:	dfc00117 	ldw	ra,4(sp)
 3214b78:	df000017 	ldw	fp,0(sp)
 3214b7c:	dec00204 	addi	sp,sp,8
 3214b80:	f800283a 	ret

03214b84 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 3214b84:	defffe04 	addi	sp,sp,-8
 3214b88:	dfc00115 	stw	ra,4(sp)
 3214b8c:	df000015 	stw	fp,0(sp)
 3214b90:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 3214b94:	0100c974 	movhi	r4,805
 3214b98:	210ab404 	addi	r4,r4,10960
 3214b9c:	0140c974 	movhi	r5,805
 3214ba0:	29427504 	addi	r5,r5,2516
 3214ba4:	0180c974 	movhi	r6,805
 3214ba8:	318ab404 	addi	r6,r6,10960
 3214bac:	3214c040 	call	3214c04 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 3214bb0:	0100c834 	movhi	r4,800
 3214bb4:	21000804 	addi	r4,r4,32
 3214bb8:	0140c834 	movhi	r5,800
 3214bbc:	29400804 	addi	r5,r5,32
 3214bc0:	0180c834 	movhi	r6,800
 3214bc4:	31807004 	addi	r6,r6,448
 3214bc8:	3214c040 	call	3214c04 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 3214bcc:	0100c974 	movhi	r4,805
 3214bd0:	2130db04 	addi	r4,r4,-15508
 3214bd4:	0140c974 	movhi	r5,805
 3214bd8:	2970db04 	addi	r5,r5,-15508
 3214bdc:	0180c974 	movhi	r6,805
 3214be0:	31827504 	addi	r6,r6,2516
 3214be4:	3214c040 	call	3214c04 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 3214be8:	323a60c0 	call	323a60c <alt_dcache_flush_all>
  alt_icache_flush_all();
 3214bec:	323ab000 	call	323ab00 <alt_icache_flush_all>
}
 3214bf0:	e037883a 	mov	sp,fp
 3214bf4:	dfc00117 	ldw	ra,4(sp)
 3214bf8:	df000017 	ldw	fp,0(sp)
 3214bfc:	dec00204 	addi	sp,sp,8
 3214c00:	f800283a 	ret

03214c04 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 3214c04:	defffc04 	addi	sp,sp,-16
 3214c08:	df000315 	stw	fp,12(sp)
 3214c0c:	df000304 	addi	fp,sp,12
 3214c10:	e13ffd15 	stw	r4,-12(fp)
 3214c14:	e17ffe15 	stw	r5,-8(fp)
 3214c18:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 3214c1c:	e0fffe17 	ldw	r3,-8(fp)
 3214c20:	e0bffd17 	ldw	r2,-12(fp)
 3214c24:	18800e26 	beq	r3,r2,3214c60 <alt_load_section+0x5c>
  {
    while( to != end )
 3214c28:	00000a06 	br	3214c54 <alt_load_section+0x50>
    {
      *to++ = *from++;
 3214c2c:	e0bffd17 	ldw	r2,-12(fp)
 3214c30:	10c00017 	ldw	r3,0(r2)
 3214c34:	e0bffe17 	ldw	r2,-8(fp)
 3214c38:	10c00015 	stw	r3,0(r2)
 3214c3c:	e0bffe17 	ldw	r2,-8(fp)
 3214c40:	10800104 	addi	r2,r2,4
 3214c44:	e0bffe15 	stw	r2,-8(fp)
 3214c48:	e0bffd17 	ldw	r2,-12(fp)
 3214c4c:	10800104 	addi	r2,r2,4
 3214c50:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 3214c54:	e0fffe17 	ldw	r3,-8(fp)
 3214c58:	e0bfff17 	ldw	r2,-4(fp)
 3214c5c:	18bff31e 	bne	r3,r2,3214c2c <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
 3214c60:	e037883a 	mov	sp,fp
 3214c64:	df000017 	ldw	fp,0(sp)
 3214c68:	dec00104 	addi	sp,sp,4
 3214c6c:	f800283a 	ret

03214c70 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 3214c70:	defff804 	addi	sp,sp,-32
 3214c74:	dfc00715 	stw	ra,28(sp)
 3214c78:	df000615 	stw	fp,24(sp)
 3214c7c:	df000604 	addi	fp,sp,24
 3214c80:	e13ffc15 	stw	r4,-16(fp)
 3214c84:	e17ffd15 	stw	r5,-12(fp)
 3214c88:	e1bffe15 	stw	r6,-8(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 3214c8c:	e03ffa15 	stw	zero,-24(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 3214c90:	e0bffc17 	ldw	r2,-16(fp)
 3214c94:	1004803a 	cmplt	r2,r2,zero
 3214c98:	1000081e 	bne	r2,zero,3214cbc <lseek+0x4c>
 3214c9c:	e0bffc17 	ldw	r2,-16(fp)
 3214ca0:	10800324 	muli	r2,r2,12
 3214ca4:	1007883a 	mov	r3,r2
 3214ca8:	0080c974 	movhi	r2,805
 3214cac:	10896e04 	addi	r2,r2,9656
 3214cb0:	1887883a 	add	r3,r3,r2
 3214cb4:	e0ffff15 	stw	r3,-4(fp)
 3214cb8:	00000106 	br	3214cc0 <lseek+0x50>
 3214cbc:	e03fff15 	stw	zero,-4(fp)
 3214cc0:	e0bfff17 	ldw	r2,-4(fp)
 3214cc4:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd) 
 3214cc8:	e0bffb17 	ldw	r2,-20(fp)
 3214ccc:	1005003a 	cmpeq	r2,r2,zero
 3214cd0:	1000111e 	bne	r2,zero,3214d18 <lseek+0xa8>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 3214cd4:	e0bffb17 	ldw	r2,-20(fp)
 3214cd8:	10800017 	ldw	r2,0(r2)
 3214cdc:	10800717 	ldw	r2,28(r2)
 3214ce0:	1005003a 	cmpeq	r2,r2,zero
 3214ce4:	1000091e 	bne	r2,zero,3214d0c <lseek+0x9c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 3214ce8:	e0bffb17 	ldw	r2,-20(fp)
 3214cec:	10800017 	ldw	r2,0(r2)
 3214cf0:	10800717 	ldw	r2,28(r2)
 3214cf4:	e13ffb17 	ldw	r4,-20(fp)
 3214cf8:	e17ffd17 	ldw	r5,-12(fp)
 3214cfc:	e1bffe17 	ldw	r6,-8(fp)
 3214d00:	103ee83a 	callr	r2
 3214d04:	e0bffa15 	stw	r2,-24(fp)
 3214d08:	00000506 	br	3214d20 <lseek+0xb0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 3214d0c:	00bfde84 	movi	r2,-134
 3214d10:	e0bffa15 	stw	r2,-24(fp)
 3214d14:	00000206 	br	3214d20 <lseek+0xb0>
    }
  }
  else  
  {
    rc = -EBADFD;
 3214d18:	00bfebc4 	movi	r2,-81
 3214d1c:	e0bffa15 	stw	r2,-24(fp)
  }

  if (rc < 0)
 3214d20:	e0bffa17 	ldw	r2,-24(fp)
 3214d24:	1004403a 	cmpge	r2,r2,zero
 3214d28:	1000071e 	bne	r2,zero,3214d48 <lseek+0xd8>
  {
    ALT_ERRNO = -rc;
 3214d2c:	3214d600 	call	3214d60 <alt_get_errno>
 3214d30:	1007883a 	mov	r3,r2
 3214d34:	e0bffa17 	ldw	r2,-24(fp)
 3214d38:	0085c83a 	sub	r2,zero,r2
 3214d3c:	18800015 	stw	r2,0(r3)
    rc = -1;
 3214d40:	00bfffc4 	movi	r2,-1
 3214d44:	e0bffa15 	stw	r2,-24(fp)
  }

  return rc;
 3214d48:	e0bffa17 	ldw	r2,-24(fp)
}
 3214d4c:	e037883a 	mov	sp,fp
 3214d50:	dfc00117 	ldw	ra,4(sp)
 3214d54:	df000017 	ldw	fp,0(sp)
 3214d58:	dec00204 	addi	sp,sp,8
 3214d5c:	f800283a 	ret

03214d60 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 3214d60:	defffd04 	addi	sp,sp,-12
 3214d64:	dfc00215 	stw	ra,8(sp)
 3214d68:	df000115 	stw	fp,4(sp)
 3214d6c:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 3214d70:	0080c974 	movhi	r2,805
 3214d74:	108aa504 	addi	r2,r2,10900
 3214d78:	10800017 	ldw	r2,0(r2)
 3214d7c:	1005003a 	cmpeq	r2,r2,zero
 3214d80:	1000061e 	bne	r2,zero,3214d9c <alt_get_errno+0x3c>
 3214d84:	0080c974 	movhi	r2,805
 3214d88:	108aa504 	addi	r2,r2,10900
 3214d8c:	10800017 	ldw	r2,0(r2)
 3214d90:	103ee83a 	callr	r2
 3214d94:	e0bfff15 	stw	r2,-4(fp)
 3214d98:	00000306 	br	3214da8 <alt_get_errno+0x48>
 3214d9c:	0080c974 	movhi	r2,805
 3214da0:	1092f804 	addi	r2,r2,19424
 3214da4:	e0bfff15 	stw	r2,-4(fp)
 3214da8:	e0bfff17 	ldw	r2,-4(fp)
}
 3214dac:	e037883a 	mov	sp,fp
 3214db0:	dfc00117 	ldw	ra,4(sp)
 3214db4:	df000017 	ldw	fp,0(sp)
 3214db8:	dec00204 	addi	sp,sp,8
 3214dbc:	f800283a 	ret

03214dc0 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 3214dc0:	defffb04 	addi	sp,sp,-20
 3214dc4:	dfc00415 	stw	ra,16(sp)
 3214dc8:	df000315 	stw	fp,12(sp)
 3214dcc:	df000304 	addi	fp,sp,12
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 3214dd0:	0009883a 	mov	r4,zero
 3214dd4:	321d8140 	call	321d814 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 3214dd8:	3215e700 	call	3215e70 <OSInit>
 3214ddc:	01000044 	movi	r4,1
 3214de0:	321ad340 	call	321ad34 <OSSemCreate>
 3214de4:	1007883a 	mov	r3,r2
 3214de8:	0080c974 	movhi	r2,805
 3214dec:	10930304 	addi	r2,r2,19468
 3214df0:	10c00015 	stw	r3,0(r2)
 3214df4:	01000044 	movi	r4,1
 3214df8:	321ad340 	call	321ad34 <OSSemCreate>
 3214dfc:	1007883a 	mov	r3,r2
 3214e00:	0080c974 	movhi	r2,805
 3214e04:	10930504 	addi	r2,r2,19476
 3214e08:	10c00015 	stw	r3,0(r2)
 3214e0c:	0080c974 	movhi	r2,805
 3214e10:	10934f04 	addi	r2,r2,19772
 3214e14:	e0bffd15 	stw	r2,-12(fp)
 3214e18:	00800044 	movi	r2,1
 3214e1c:	e0bffe0d 	sth	r2,-8(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 3214e20:	e13ffe0b 	ldhu	r4,-8(fp)
 3214e24:	321ad340 	call	321ad34 <OSSemCreate>
 3214e28:	1007883a 	mov	r3,r2
 3214e2c:	e0bffd17 	ldw	r2,-12(fp)
 3214e30:	10c00015 	stw	r3,0(r2)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 3214e34:	321d8480 	call	321d848 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 3214e38:	0100c974 	movhi	r4,805
 3214e3c:	21397604 	addi	r4,r4,-6696
 3214e40:	0140c974 	movhi	r5,805
 3214e44:	29797604 	addi	r5,r5,-6696
 3214e48:	0180c974 	movhi	r6,805
 3214e4c:	31b97604 	addi	r6,r6,-6696
 3214e50:	323abf40 	call	323abf4 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 3214e54:	323a7900 	call	323a790 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 3214e58:	0100c934 	movhi	r4,804
 3214e5c:	2129fd04 	addi	r4,r4,-22540
 3214e60:	324bc180 	call	324bc18 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 3214e64:	d1289d17 	ldw	r4,-23948(gp)
 3214e68:	d1689e17 	ldw	r5,-23944(gp)
 3214e6c:	d1a89f17 	ldw	r6,-23940(gp)
 3214e70:	32017800 	call	3201780 <main>
 3214e74:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 3214e78:	01000044 	movi	r4,1
 3214e7c:	3222b400 	call	3222b40 <close>
  exit (result);
 3214e80:	e13fff17 	ldw	r4,-4(fp)
 3214e84:	324bc600 	call	324bc60 <exit>

03214e88 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 3214e88:	defffc04 	addi	sp,sp,-16
 3214e8c:	df000315 	stw	fp,12(sp)
 3214e90:	df000304 	addi	fp,sp,12
 3214e94:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 3214e98:	e0bffe17 	ldw	r2,-8(fp)
 3214e9c:	10800217 	ldw	r2,8(r2)
 3214ea0:	10d00034 	orhi	r3,r2,16384
 3214ea4:	e0bffe17 	ldw	r2,-8(fp)
 3214ea8:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 3214eac:	e03ffd15 	stw	zero,-12(fp)
 3214eb0:	00002006 	br	3214f34 <alt_file_locked+0xac>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 3214eb4:	e0bffd17 	ldw	r2,-12(fp)
 3214eb8:	00c0c974 	movhi	r3,805
 3214ebc:	18c96e04 	addi	r3,r3,9656
 3214ec0:	10800324 	muli	r2,r2,12
 3214ec4:	10c5883a 	add	r2,r2,r3
 3214ec8:	10c00017 	ldw	r3,0(r2)
 3214ecc:	e0bffe17 	ldw	r2,-8(fp)
 3214ed0:	10800017 	ldw	r2,0(r2)
 3214ed4:	1880141e 	bne	r3,r2,3214f28 <alt_file_locked+0xa0>
 3214ed8:	e0bffd17 	ldw	r2,-12(fp)
 3214edc:	00c0c974 	movhi	r3,805
 3214ee0:	18c96e04 	addi	r3,r3,9656
 3214ee4:	10800324 	muli	r2,r2,12
 3214ee8:	10c5883a 	add	r2,r2,r3
 3214eec:	10800204 	addi	r2,r2,8
 3214ef0:	10800017 	ldw	r2,0(r2)
 3214ef4:	1004403a 	cmpge	r2,r2,zero
 3214ef8:	10000b1e 	bne	r2,zero,3214f28 <alt_file_locked+0xa0>
 3214efc:	e0bffd17 	ldw	r2,-12(fp)
 3214f00:	10800324 	muli	r2,r2,12
 3214f04:	1007883a 	mov	r3,r2
 3214f08:	0080c974 	movhi	r2,805
 3214f0c:	10896e04 	addi	r2,r2,9656
 3214f10:	1887883a 	add	r3,r3,r2
 3214f14:	e0bffe17 	ldw	r2,-8(fp)
 3214f18:	18800326 	beq	r3,r2,3214f28 <alt_file_locked+0xa0>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 3214f1c:	00bffcc4 	movi	r2,-13
 3214f20:	e0bfff15 	stw	r2,-4(fp)
 3214f24:	00000a06 	br	3214f50 <alt_file_locked+0xc8>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 3214f28:	e0bffd17 	ldw	r2,-12(fp)
 3214f2c:	10800044 	addi	r2,r2,1
 3214f30:	e0bffd15 	stw	r2,-12(fp)
 3214f34:	0080c974 	movhi	r2,805
 3214f38:	108aa404 	addi	r2,r2,10896
 3214f3c:	10800017 	ldw	r2,0(r2)
 3214f40:	1007883a 	mov	r3,r2
 3214f44:	e0bffd17 	ldw	r2,-12(fp)
 3214f48:	18bfda2e 	bgeu	r3,r2,3214eb4 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 3214f4c:	e03fff15 	stw	zero,-4(fp)
 3214f50:	e0bfff17 	ldw	r2,-4(fp)
}
 3214f54:	e037883a 	mov	sp,fp
 3214f58:	df000017 	ldw	fp,0(sp)
 3214f5c:	dec00104 	addi	sp,sp,4
 3214f60:	f800283a 	ret

03214f64 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 3214f64:	defff404 	addi	sp,sp,-48
 3214f68:	dfc00b15 	stw	ra,44(sp)
 3214f6c:	df000a15 	stw	fp,40(sp)
 3214f70:	df000a04 	addi	fp,sp,40
 3214f74:	e13ffb15 	stw	r4,-20(fp)
 3214f78:	e17ffc15 	stw	r5,-16(fp)
 3214f7c:	e1bffd15 	stw	r6,-12(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 3214f80:	00bfffc4 	movi	r2,-1
 3214f84:	e0bff815 	stw	r2,-32(fp)
  int status = -ENODEV;
 3214f88:	00bffb44 	movi	r2,-19
 3214f8c:	e0bff715 	stw	r2,-36(fp)
  int isafs = 0;
 3214f90:	e03ff615 	stw	zero,-40(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 3214f94:	e13ffb17 	ldw	r4,-20(fp)
 3214f98:	0140c974 	movhi	r5,805
 3214f9c:	294aa204 	addi	r5,r5,10888
 3214fa0:	323a8580 	call	323a858 <alt_find_dev>
 3214fa4:	e0bffa15 	stw	r2,-24(fp)
 3214fa8:	e0bffa17 	ldw	r2,-24(fp)
 3214fac:	1004c03a 	cmpne	r2,r2,zero
 3214fb0:	1000051e 	bne	r2,zero,3214fc8 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 3214fb4:	e13ffb17 	ldw	r4,-20(fp)
 3214fb8:	323a8ec0 	call	323a8ec <alt_find_file>
 3214fbc:	e0bffa15 	stw	r2,-24(fp)
    isafs = 1;
 3214fc0:	00800044 	movi	r2,1
 3214fc4:	e0bff615 	stw	r2,-40(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 3214fc8:	e0bffa17 	ldw	r2,-24(fp)
 3214fcc:	1005003a 	cmpeq	r2,r2,zero
 3214fd0:	1000301e 	bne	r2,zero,3215094 <open+0x130>
  {
    if ((index = alt_get_fd (dev)) < 0)
 3214fd4:	e13ffa17 	ldw	r4,-24(fp)
 3214fd8:	323aa0c0 	call	323aa0c <alt_get_fd>
 3214fdc:	e0bff815 	stw	r2,-32(fp)
 3214fe0:	e0bff817 	ldw	r2,-32(fp)
 3214fe4:	1004403a 	cmpge	r2,r2,zero
 3214fe8:	1000031e 	bne	r2,zero,3214ff8 <open+0x94>
    {
      status = index;
 3214fec:	e0bff817 	ldw	r2,-32(fp)
 3214ff0:	e0bff715 	stw	r2,-36(fp)
 3214ff4:	00002906 	br	321509c <open+0x138>
    }
    else
    {
      fd = &alt_fd_list[index];
 3214ff8:	e0bff817 	ldw	r2,-32(fp)
 3214ffc:	10800324 	muli	r2,r2,12
 3215000:	1007883a 	mov	r3,r2
 3215004:	0080c974 	movhi	r2,805
 3215008:	10896e04 	addi	r2,r2,9656
 321500c:	1885883a 	add	r2,r3,r2
 3215010:	e0bff915 	stw	r2,-28(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 3215014:	e0fffc17 	ldw	r3,-16(fp)
 3215018:	00900034 	movhi	r2,16384
 321501c:	10bfffc4 	addi	r2,r2,-1
 3215020:	1886703a 	and	r3,r3,r2
 3215024:	e0bff917 	ldw	r2,-28(fp)
 3215028:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 321502c:	e0bff617 	ldw	r2,-40(fp)
 3215030:	1004c03a 	cmpne	r2,r2,zero
 3215034:	1000061e 	bne	r2,zero,3215050 <open+0xec>
 3215038:	e13ff917 	ldw	r4,-28(fp)
 321503c:	3214e880 	call	3214e88 <alt_file_locked>
 3215040:	e0bff715 	stw	r2,-36(fp)
 3215044:	e0bff717 	ldw	r2,-36(fp)
 3215048:	1004803a 	cmplt	r2,r2,zero
 321504c:	1000131e 	bne	r2,zero,321509c <open+0x138>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 3215050:	e0bffa17 	ldw	r2,-24(fp)
 3215054:	10800317 	ldw	r2,12(r2)
 3215058:	1005003a 	cmpeq	r2,r2,zero
 321505c:	1000091e 	bne	r2,zero,3215084 <open+0x120>
 3215060:	e0bffa17 	ldw	r2,-24(fp)
 3215064:	10800317 	ldw	r2,12(r2)
 3215068:	e13ff917 	ldw	r4,-28(fp)
 321506c:	e17ffb17 	ldw	r5,-20(fp)
 3215070:	e1bffc17 	ldw	r6,-16(fp)
 3215074:	e1fffd17 	ldw	r7,-12(fp)
 3215078:	103ee83a 	callr	r2
 321507c:	e0bfff15 	stw	r2,-4(fp)
 3215080:	00000106 	br	3215088 <open+0x124>
 3215084:	e03fff15 	stw	zero,-4(fp)
 3215088:	e0bfff17 	ldw	r2,-4(fp)
 321508c:	e0bff715 	stw	r2,-36(fp)
 3215090:	00000206 	br	321509c <open+0x138>
      }
    }
  }
  else
  {
    status = -ENODEV;
 3215094:	00bffb44 	movi	r2,-19
 3215098:	e0bff715 	stw	r2,-36(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 321509c:	e0bff717 	ldw	r2,-36(fp)
 32150a0:	1004403a 	cmpge	r2,r2,zero
 32150a4:	1000091e 	bne	r2,zero,32150cc <open+0x168>
  {
    alt_release_fd (index);  
 32150a8:	e13ff817 	ldw	r4,-32(fp)
 32150ac:	321514c0 	call	321514c <alt_release_fd>
    ALT_ERRNO = -status;
 32150b0:	32150ec0 	call	32150ec <alt_get_errno>
 32150b4:	e0fff717 	ldw	r3,-36(fp)
 32150b8:	00c7c83a 	sub	r3,zero,r3
 32150bc:	10c00015 	stw	r3,0(r2)
    return -1;
 32150c0:	00bfffc4 	movi	r2,-1
 32150c4:	e0bffe15 	stw	r2,-8(fp)
 32150c8:	00000206 	br	32150d4 <open+0x170>
  }
  
  /* return the reference upon success */

  return index;
 32150cc:	e0bff817 	ldw	r2,-32(fp)
 32150d0:	e0bffe15 	stw	r2,-8(fp)
 32150d4:	e0bffe17 	ldw	r2,-8(fp)
}
 32150d8:	e037883a 	mov	sp,fp
 32150dc:	dfc00117 	ldw	ra,4(sp)
 32150e0:	df000017 	ldw	fp,0(sp)
 32150e4:	dec00204 	addi	sp,sp,8
 32150e8:	f800283a 	ret

032150ec <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 32150ec:	defffd04 	addi	sp,sp,-12
 32150f0:	dfc00215 	stw	ra,8(sp)
 32150f4:	df000115 	stw	fp,4(sp)
 32150f8:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 32150fc:	0080c974 	movhi	r2,805
 3215100:	108aa504 	addi	r2,r2,10900
 3215104:	10800017 	ldw	r2,0(r2)
 3215108:	1005003a 	cmpeq	r2,r2,zero
 321510c:	1000061e 	bne	r2,zero,3215128 <alt_get_errno+0x3c>
 3215110:	0080c974 	movhi	r2,805
 3215114:	108aa504 	addi	r2,r2,10900
 3215118:	10800017 	ldw	r2,0(r2)
 321511c:	103ee83a 	callr	r2
 3215120:	e0bfff15 	stw	r2,-4(fp)
 3215124:	00000306 	br	3215134 <alt_get_errno+0x48>
 3215128:	0080c974 	movhi	r2,805
 321512c:	1092f804 	addi	r2,r2,19424
 3215130:	e0bfff15 	stw	r2,-4(fp)
 3215134:	e0bfff17 	ldw	r2,-4(fp)
}
 3215138:	e037883a 	mov	sp,fp
 321513c:	dfc00117 	ldw	ra,4(sp)
 3215140:	df000017 	ldw	fp,0(sp)
 3215144:	dec00204 	addi	sp,sp,8
 3215148:	f800283a 	ret

0321514c <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 321514c:	defffe04 	addi	sp,sp,-8
 3215150:	df000115 	stw	fp,4(sp)
 3215154:	df000104 	addi	fp,sp,4
 3215158:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 321515c:	e0bfff17 	ldw	r2,-4(fp)
 3215160:	108000d0 	cmplti	r2,r2,3
 3215164:	10000d1e 	bne	r2,zero,321519c <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 3215168:	e0bfff17 	ldw	r2,-4(fp)
 321516c:	00c0c974 	movhi	r3,805
 3215170:	18c96e04 	addi	r3,r3,9656
 3215174:	10800324 	muli	r2,r2,12
 3215178:	10c5883a 	add	r2,r2,r3
 321517c:	10800204 	addi	r2,r2,8
 3215180:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 3215184:	e0bfff17 	ldw	r2,-4(fp)
 3215188:	00c0c974 	movhi	r3,805
 321518c:	18c96e04 	addi	r3,r3,9656
 3215190:	10800324 	muli	r2,r2,12
 3215194:	10c5883a 	add	r2,r2,r3
 3215198:	10000015 	stw	zero,0(r2)
  }
}
 321519c:	e037883a 	mov	sp,fp
 32151a0:	df000017 	ldw	fp,0(sp)
 32151a4:	dec00104 	addi	sp,sp,4
 32151a8:	f800283a 	ret

032151ac <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 32151ac:	defff804 	addi	sp,sp,-32
 32151b0:	df000715 	stw	fp,28(sp)
 32151b4:	df000704 	addi	fp,sp,28
 32151b8:	e13ffe15 	stw	r4,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32151bc:	0005303a 	rdctl	r2,status
 32151c0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32151c4:	e0fffb17 	ldw	r3,-20(fp)
 32151c8:	00bfff84 	movi	r2,-2
 32151cc:	1884703a 	and	r2,r3,r2
 32151d0:	1001703a 	wrctl	status,r2
  
  return context;
 32151d4:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 32151d8:	e0bffd15 	stw	r2,-12(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 32151dc:	d0a00917 	ldw	r2,-32732(gp)
 32151e0:	10c000c4 	addi	r3,r2,3
 32151e4:	00bfff04 	movi	r2,-4
 32151e8:	1884703a 	and	r2,r3,r2
 32151ec:	d0a00915 	stw	r2,-32732(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 32151f0:	d0e00917 	ldw	r3,-32732(gp)
 32151f4:	e0bffe17 	ldw	r2,-8(fp)
 32151f8:	1887883a 	add	r3,r3,r2
 32151fc:	0080d034 	movhi	r2,832
 3215200:	10800004 	addi	r2,r2,0
 3215204:	10c0072e 	bgeu	r2,r3,3215224 <sbrk+0x78>
 3215208:	e0bffd17 	ldw	r2,-12(fp)
 321520c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215210:	e0bffa17 	ldw	r2,-24(fp)
 3215214:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 3215218:	00bfffc4 	movi	r2,-1
 321521c:	e0bfff15 	stw	r2,-4(fp)
 3215220:	00000c06 	br	3215254 <sbrk+0xa8>
  }
#endif

  prev_heap_end = heap_end; 
 3215224:	d0a00917 	ldw	r2,-32732(gp)
 3215228:	e0bffc15 	stw	r2,-16(fp)
  heap_end += incr; 
 321522c:	d0e00917 	ldw	r3,-32732(gp)
 3215230:	e0bffe17 	ldw	r2,-8(fp)
 3215234:	1885883a 	add	r2,r3,r2
 3215238:	d0a00915 	stw	r2,-32732(gp)
 321523c:	e0bffd17 	ldw	r2,-12(fp)
 3215240:	e0bff915 	stw	r2,-28(fp)
 3215244:	e0bff917 	ldw	r2,-28(fp)
 3215248:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 321524c:	e0bffc17 	ldw	r2,-16(fp)
 3215250:	e0bfff15 	stw	r2,-4(fp)
 3215254:	e0bfff17 	ldw	r2,-4(fp)
} 
 3215258:	e037883a 	mov	sp,fp
 321525c:	df000017 	ldw	fp,0(sp)
 3215260:	dec00104 	addi	sp,sp,4
 3215264:	f800283a 	ret

03215268 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
 3215268:	deffdf04 	addi	sp,sp,-132
 321526c:	dfc02015 	stw	ra,128(sp)
 3215270:	df001f15 	stw	fp,124(sp)
 3215274:	df001f04 	addi	fp,sp,124
 3215278:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 321527c:	e17fe204 	addi	r5,fp,-120
 3215280:	01003fc4 	movi	r4,255
 3215284:	321d0bc0 	call	321d0bc <OSTaskQuery>
 3215288:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 321528c:	e0bffe83 	ldbu	r2,-6(fp)
 3215290:	10803fcc 	andi	r2,r2,255
 3215294:	1004c03a 	cmpne	r2,r2,zero
 3215298:	1000191e 	bne	r2,zero,3215300 <__env_lock+0x98>
    return;

  id = tcb.OSTCBPrio;
 321529c:	e0bfee83 	ldbu	r2,-70(fp)
 32152a0:	10803fcc 	andi	r2,r2,255
 32152a4:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
 32152a8:	d128a117 	ldw	r4,-23932(gp)
 32152ac:	e17ffd04 	addi	r5,fp,-12
 32152b0:	321b6080 	call	321b608 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
 32152b4:	e0bffe43 	ldbu	r2,-7(fp)
 32152b8:	10803fcc 	andi	r2,r2,255
 32152bc:	1005003a 	cmpeq	r2,r2,zero
 32152c0:	1000071e 	bne	r2,zero,32152e0 <__env_lock+0x78>
 32152c4:	d0e00a17 	ldw	r3,-32728(gp)
 32152c8:	e0bfe117 	ldw	r2,-124(fp)
 32152cc:	10c0041e 	bne	r2,r3,32152e0 <__env_lock+0x78>
  {
    /* we do; just count the recursion */

    locks++;
 32152d0:	d0a8a017 	ldw	r2,-23936(gp)
 32152d4:	10800044 	addi	r2,r2,1
 32152d8:	d0a8a015 	stw	r2,-23936(gp)
  id = tcb.OSTCBPrio;
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
  if( semdata.OSEventGrp && id == lockid ) 
 32152dc:	00000806 	br	3215300 <__env_lock+0x98>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
 32152e0:	d128a117 	ldw	r4,-23932(gp)
 32152e4:	e1bffe84 	addi	r6,fp,-6
 32152e8:	000b883a 	mov	r5,zero
 32152ec:	321b0e80 	call	321b0e8 <OSSemPend>
    locks  = 1;
 32152f0:	00800044 	movi	r2,1
 32152f4:	d0a8a015 	stw	r2,-23936(gp)
    lockid = id;
 32152f8:	e0bfe117 	ldw	r2,-124(fp)
 32152fc:	d0a00a15 	stw	r2,-32728(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 3215300:	e037883a 	mov	sp,fp
 3215304:	dfc00117 	ldw	ra,4(sp)
 3215308:	df000017 	ldw	fp,0(sp)
 321530c:	dec00204 	addi	sp,sp,8
 3215310:	f800283a 	ret

03215314 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
 3215314:	defffd04 	addi	sp,sp,-12
 3215318:	dfc00215 	stw	ra,8(sp)
 321531c:	df000115 	stw	fp,4(sp)
 3215320:	df000104 	addi	fp,sp,4
 3215324:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
 3215328:	d0a8a017 	ldw	r2,-23936(gp)
 321532c:	1005003a 	cmpeq	r2,r2,zero
 3215330:	10000a1e 	bne	r2,zero,321535c <__env_unlock+0x48>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
 3215334:	d0a8a017 	ldw	r2,-23936(gp)
 3215338:	10bfffc4 	addi	r2,r2,-1
 321533c:	d0a8a015 	stw	r2,-23936(gp)
 3215340:	d0a8a017 	ldw	r2,-23936(gp)
 3215344:	1004c03a 	cmpne	r2,r2,zero
 3215348:	1000041e 	bne	r2,zero,321535c <__env_unlock+0x48>
  {
    lockid = -1;
 321534c:	00bfffc4 	movi	r2,-1
 3215350:	d0a00a15 	stw	r2,-32728(gp)
    OSSemPost( alt_envsem );
 3215354:	d128a117 	ldw	r4,-23932(gp)
 3215358:	321b4e00 	call	321b4e0 <OSSemPost>
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 321535c:	e037883a 	mov	sp,fp
 3215360:	dfc00117 	ldw	ra,4(sp)
 3215364:	df000017 	ldw	fp,0(sp)
 3215368:	dec00204 	addi	sp,sp,8
 321536c:	f800283a 	ret

03215370 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
 3215370:	deffdb04 	addi	sp,sp,-148
 3215374:	dfc02415 	stw	ra,144(sp)
 3215378:	df002315 	stw	fp,140(sp)
 321537c:	df002304 	addi	fp,sp,140
 3215380:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3215384:	e03fe015 	stw	zero,-128(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
 3215388:	0080c974 	movhi	r2,805
 321538c:	10930644 	addi	r2,r2,19481
 3215390:	10800003 	ldbu	r2,0(r2)
 3215394:	10803fcc 	andi	r2,r2,255
 3215398:	10800058 	cmpnei	r2,r2,1
 321539c:	1000311e 	bne	r2,zero,3215464 <__malloc_lock+0xf4>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 32153a0:	e17fe204 	addi	r5,fp,-120
 32153a4:	01003fc4 	movi	r4,255
 32153a8:	321d0bc0 	call	321d0bc <OSTaskQuery>
 32153ac:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 32153b0:	e0bffe83 	ldbu	r2,-6(fp)
 32153b4:	10803fcc 	andi	r2,r2,255
 32153b8:	1004c03a 	cmpne	r2,r2,zero
 32153bc:	1000291e 	bne	r2,zero,3215464 <__malloc_lock+0xf4>
    return;

  id = tcb.OSTCBPrio;
 32153c0:	e0bfee83 	ldbu	r2,-70(fp)
 32153c4:	10803fcc 	andi	r2,r2,255
 32153c8:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
 32153cc:	d128a317 	ldw	r4,-23924(gp)
 32153d0:	e17ffd04 	addi	r5,fp,-12
 32153d4:	321b6080 	call	321b608 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32153d8:	0005303a 	rdctl	r2,status
 32153dc:	e0bfdf15 	stw	r2,-132(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32153e0:	e0ffdf17 	ldw	r3,-132(fp)
 32153e4:	00bfff84 	movi	r2,-2
 32153e8:	1884703a 	and	r2,r3,r2
 32153ec:	1001703a 	wrctl	status,r2
  
  return context;
 32153f0:	e0bfdf17 	ldw	r2,-132(fp)
  
  OS_ENTER_CRITICAL();
 32153f4:	e0bfe015 	stw	r2,-128(fp)

  if( !semdata.OSCnt && id == lockid ) 
 32153f8:	e0bffd0b 	ldhu	r2,-12(fp)
 32153fc:	10bfffcc 	andi	r2,r2,65535
 3215400:	1004c03a 	cmpne	r2,r2,zero
 3215404:	10000b1e 	bne	r2,zero,3215434 <__malloc_lock+0xc4>
 3215408:	d0e00b17 	ldw	r3,-32724(gp)
 321540c:	e0bfe117 	ldw	r2,-124(fp)
 3215410:	10c0081e 	bne	r2,r3,3215434 <__malloc_lock+0xc4>
  {
    /* we do; just count the recursion */
    locks++;
 3215414:	d0a8a217 	ldw	r2,-23928(gp)
 3215418:	10800044 	addi	r2,r2,1
 321541c:	d0a8a215 	stw	r2,-23928(gp)
 3215420:	e0bfe017 	ldw	r2,-128(fp)
 3215424:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215428:	e0bfde17 	ldw	r2,-136(fp)
 321542c:	1001703a 	wrctl	status,r2

  OSSemQuery( alt_heapsem, &semdata );
  
  OS_ENTER_CRITICAL();

  if( !semdata.OSCnt && id == lockid ) 
 3215430:	00000c06 	br	3215464 <__malloc_lock+0xf4>
 3215434:	e0bfe017 	ldw	r2,-128(fp)
 3215438:	e0bfdd15 	stw	r2,-140(fp)
 321543c:	e0bfdd17 	ldw	r2,-140(fp)
 3215440:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
 3215444:	d128a317 	ldw	r4,-23924(gp)
 3215448:	e1bffe84 	addi	r6,fp,-6
 321544c:	000b883a 	mov	r5,zero
 3215450:	321b0e80 	call	321b0e8 <OSSemPend>
    locks  = 1;
 3215454:	00800044 	movi	r2,1
 3215458:	d0a8a215 	stw	r2,-23928(gp)
    lockid = id;
 321545c:	e0bfe117 	ldw	r2,-124(fp)
 3215460:	d0a00b15 	stw	r2,-32724(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 3215464:	e037883a 	mov	sp,fp
 3215468:	dfc00117 	ldw	ra,4(sp)
 321546c:	df000017 	ldw	fp,0(sp)
 3215470:	dec00204 	addi	sp,sp,8
 3215474:	f800283a 	ret

03215478 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 3215478:	defff804 	addi	sp,sp,-32
 321547c:	dfc00715 	stw	ra,28(sp)
 3215480:	df000615 	stw	fp,24(sp)
 3215484:	df000604 	addi	fp,sp,24
 3215488:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 321548c:	e03ffe15 	stw	zero,-8(fp)
#endif 

  if (OSRunning != OS_TRUE)
 3215490:	0080c974 	movhi	r2,805
 3215494:	10930644 	addi	r2,r2,19481
 3215498:	10800003 	ldbu	r2,0(r2)
 321549c:	10803fcc 	andi	r2,r2,255
 32154a0:	10800058 	cmpnei	r2,r2,1
 32154a4:	1000231e 	bne	r2,zero,3215534 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32154a8:	0005303a 	rdctl	r2,status
 32154ac:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32154b0:	e0fffd17 	ldw	r3,-12(fp)
 32154b4:	00bfff84 	movi	r2,-2
 32154b8:	1884703a 	and	r2,r3,r2
 32154bc:	1001703a 	wrctl	status,r2
  
  return context;
 32154c0:	e0bffd17 	ldw	r2,-12(fp)
      return;

  OS_ENTER_CRITICAL();
 32154c4:	e0bffe15 	stw	r2,-8(fp)
  if (locks == 0)
 32154c8:	d0a8a217 	ldw	r2,-23928(gp)
 32154cc:	1004c03a 	cmpne	r2,r2,zero
 32154d0:	1000051e 	bne	r2,zero,32154e8 <__malloc_unlock+0x70>
 32154d4:	e0bffe17 	ldw	r2,-8(fp)
 32154d8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 32154dc:	e0bffc17 	ldw	r2,-16(fp)
 32154e0:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
 32154e4:	00001306 	br	3215534 <__malloc_unlock+0xbc>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
 32154e8:	d0a8a217 	ldw	r2,-23928(gp)
 32154ec:	10bfffc4 	addi	r2,r2,-1
 32154f0:	d0a8a215 	stw	r2,-23928(gp)
 32154f4:	d0a8a217 	ldw	r2,-23928(gp)
 32154f8:	1004c03a 	cmpne	r2,r2,zero
 32154fc:	1000091e 	bne	r2,zero,3215524 <__malloc_unlock+0xac>
  {
    lockid = -1;
 3215500:	00bfffc4 	movi	r2,-1
 3215504:	d0a00b15 	stw	r2,-32724(gp)
 3215508:	e0bffe17 	ldw	r2,-8(fp)
 321550c:	e0bffb15 	stw	r2,-20(fp)
 3215510:	e0bffb17 	ldw	r2,-20(fp)
 3215514:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
 3215518:	d128a317 	ldw	r4,-23924(gp)
 321551c:	321b4e00 	call	321b4e0 <OSSemPost>
 3215520:	00000406 	br	3215534 <__malloc_unlock+0xbc>
 3215524:	e0bffe17 	ldw	r2,-8(fp)
 3215528:	e0bffa15 	stw	r2,-24(fp)
 321552c:	e0bffa17 	ldw	r2,-24(fp)
 3215530:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 3215534:	e037883a 	mov	sp,fp
 3215538:	dfc00117 	ldw	ra,4(sp)
 321553c:	df000017 	ldw	fp,0(sp)
 3215540:	dec00204 	addi	sp,sp,8
 3215544:	f800283a 	ret

03215548 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 3215548:	defff604 	addi	sp,sp,-40
 321554c:	dfc00915 	stw	ra,36(sp)
 3215550:	df000815 	stw	fp,32(sp)
 3215554:	df000804 	addi	fp,sp,32
 3215558:	e13ffc15 	stw	r4,-16(fp)
 321555c:	e17ffd15 	stw	r5,-12(fp)
 3215560:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3215564:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 3215568:	e0bffe17 	ldw	r2,-8(fp)
 321556c:	1004c03a 	cmpne	r2,r2,zero
 3215570:	1000021e 	bne	r2,zero,321557c <OSEventNameGet+0x34>
        return (0);
 3215574:	e03fff15 	stw	zero,-4(fp)
 3215578:	00003906 	br	3215660 <OSEventNameGet+0x118>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 321557c:	e0bffc17 	ldw	r2,-16(fp)
 3215580:	1004c03a 	cmpne	r2,r2,zero
 3215584:	1000051e 	bne	r2,zero,321559c <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 3215588:	e0fffe17 	ldw	r3,-8(fp)
 321558c:	00800104 	movi	r2,4
 3215590:	18800005 	stb	r2,0(r3)
        return (0);
 3215594:	e03fff15 	stw	zero,-4(fp)
 3215598:	00003106 	br	3215660 <OSEventNameGet+0x118>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 321559c:	e0bffd17 	ldw	r2,-12(fp)
 32155a0:	1004c03a 	cmpne	r2,r2,zero
 32155a4:	1000051e 	bne	r2,zero,32155bc <OSEventNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 32155a8:	e0fffe17 	ldw	r3,-8(fp)
 32155ac:	00800304 	movi	r2,12
 32155b0:	18800005 	stb	r2,0(r3)
        return (0);
 32155b4:	e03fff15 	stw	zero,-4(fp)
 32155b8:	00002906 	br	3215660 <OSEventNameGet+0x118>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 32155bc:	d0a8b203 	ldbu	r2,-23864(gp)
 32155c0:	10803fcc 	andi	r2,r2,255
 32155c4:	1005003a 	cmpeq	r2,r2,zero
 32155c8:	1000051e 	bne	r2,zero,32155e0 <OSEventNameGet+0x98>
        *perr  = OS_ERR_NAME_GET_ISR;
 32155cc:	e0fffe17 	ldw	r3,-8(fp)
 32155d0:	00800444 	movi	r2,17
 32155d4:	18800005 	stb	r2,0(r3)
        return (0);
 32155d8:	e03fff15 	stw	zero,-4(fp)
 32155dc:	00002006 	br	3215660 <OSEventNameGet+0x118>
    }
    switch (pevent->OSEventType) {
 32155e0:	e0bffc17 	ldw	r2,-16(fp)
 32155e4:	10800003 	ldbu	r2,0(r2)
 32155e8:	10803fcc 	andi	r2,r2,255
 32155ec:	10bfffc4 	addi	r2,r2,-1
 32155f0:	10800128 	cmpgeui	r2,r2,4
 32155f4:	1000161e 	bne	r2,zero,3215650 <OSEventNameGet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32155f8:	0005303a 	rdctl	r2,status
 32155fc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3215600:	e0fff917 	ldw	r3,-28(fp)
 3215604:	00bfff84 	movi	r2,-2
 3215608:	1884703a 	and	r2,r3,r2
 321560c:	1001703a 	wrctl	status,r2
  
  return context;
 3215610:	e0bff917 	ldw	r2,-28(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
 3215614:	e0bffa15 	stw	r2,-24(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
 3215618:	e0bffc17 	ldw	r2,-16(fp)
 321561c:	11400384 	addi	r5,r2,14
 3215620:	e13ffd17 	ldw	r4,-12(fp)
 3215624:	32170cc0 	call	32170cc <OS_StrCopy>
 3215628:	e0bffb05 	stb	r2,-20(fp)
 321562c:	e0bffa17 	ldw	r2,-24(fp)
 3215630:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215634:	e0bff817 	ldw	r2,-32(fp)
 3215638:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 321563c:	e0bffe17 	ldw	r2,-8(fp)
 3215640:	10000005 	stb	zero,0(r2)
    return (len);
 3215644:	e0bffb03 	ldbu	r2,-20(fp)
 3215648:	e0bfff15 	stw	r2,-4(fp)
 321564c:	00000406 	br	3215660 <OSEventNameGet+0x118>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 3215650:	e0fffe17 	ldw	r3,-8(fp)
 3215654:	00800044 	movi	r2,1
 3215658:	18800005 	stb	r2,0(r3)
             return (0);
 321565c:	e03fff15 	stw	zero,-4(fp)
 3215660:	e0bfff17 	ldw	r2,-4(fp)
    OS_ENTER_CRITICAL();
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return (len);
}
 3215664:	e037883a 	mov	sp,fp
 3215668:	dfc00117 	ldw	ra,4(sp)
 321566c:	df000017 	ldw	fp,0(sp)
 3215670:	dec00204 	addi	sp,sp,8
 3215674:	f800283a 	ret

03215678 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 3215678:	defff604 	addi	sp,sp,-40
 321567c:	dfc00915 	stw	ra,36(sp)
 3215680:	df000815 	stw	fp,32(sp)
 3215684:	df000804 	addi	fp,sp,32
 3215688:	e13ffd15 	stw	r4,-12(fp)
 321568c:	e17ffe15 	stw	r5,-8(fp)
 3215690:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3215694:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 3215698:	e0bfff17 	ldw	r2,-4(fp)
 321569c:	1005003a 	cmpeq	r2,r2,zero
 32156a0:	1000411e 	bne	r2,zero,32157a8 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 32156a4:	e0bffd17 	ldw	r2,-12(fp)
 32156a8:	1004c03a 	cmpne	r2,r2,zero
 32156ac:	1000041e 	bne	r2,zero,32156c0 <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
 32156b0:	e0ffff17 	ldw	r3,-4(fp)
 32156b4:	00800104 	movi	r2,4
 32156b8:	18800005 	stb	r2,0(r3)
        return;
 32156bc:	00003a06 	br	32157a8 <OSEventNameSet+0x130>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 32156c0:	e0bffe17 	ldw	r2,-8(fp)
 32156c4:	1004c03a 	cmpne	r2,r2,zero
 32156c8:	1000041e 	bne	r2,zero,32156dc <OSEventNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 32156cc:	e0ffff17 	ldw	r3,-4(fp)
 32156d0:	00800304 	movi	r2,12
 32156d4:	18800005 	stb	r2,0(r3)
        return;
 32156d8:	00003306 	br	32157a8 <OSEventNameSet+0x130>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 32156dc:	d0a8b203 	ldbu	r2,-23864(gp)
 32156e0:	10803fcc 	andi	r2,r2,255
 32156e4:	1005003a 	cmpeq	r2,r2,zero
 32156e8:	1000041e 	bne	r2,zero,32156fc <OSEventNameSet+0x84>
        *perr = OS_ERR_NAME_SET_ISR;
 32156ec:	e0ffff17 	ldw	r3,-4(fp)
 32156f0:	00800484 	movi	r2,18
 32156f4:	18800005 	stb	r2,0(r3)
        return;
 32156f8:	00002b06 	br	32157a8 <OSEventNameSet+0x130>
    }
    switch (pevent->OSEventType) {
 32156fc:	e0bffd17 	ldw	r2,-12(fp)
 3215700:	10800003 	ldbu	r2,0(r2)
 3215704:	10803fcc 	andi	r2,r2,255
 3215708:	10bfffc4 	addi	r2,r2,-1
 321570c:	10800128 	cmpgeui	r2,r2,4
 3215710:	10000f1e 	bne	r2,zero,3215750 <OSEventNameSet+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3215714:	0005303a 	rdctl	r2,status
 3215718:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321571c:	e0fffa17 	ldw	r3,-24(fp)
 3215720:	00bfff84 	movi	r2,-2
 3215724:	1884703a 	and	r2,r3,r2
 3215728:	1001703a 	wrctl	status,r2
  
  return context;
 321572c:	e0bffa17 	ldw	r2,-24(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
 3215730:	e0bffb15 	stw	r2,-20(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
 3215734:	e13ffe17 	ldw	r4,-8(fp)
 3215738:	321714c0 	call	321714c <OS_StrLen>
 321573c:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
 3215740:	e0bffc03 	ldbu	r2,-16(fp)
 3215744:	10800828 	cmpgeui	r2,r2,32
 3215748:	1000051e 	bne	r2,zero,3215760 <OSEventNameSet+0xe8>
 321574c:	00000c06 	br	3215780 <OSEventNameSet+0x108>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 3215750:	e0ffff17 	ldw	r3,-4(fp)
 3215754:	00800044 	movi	r2,1
 3215758:	18800005 	stb	r2,0(r3)
             return;
 321575c:	00001206 	br	32157a8 <OSEventNameSet+0x130>
 3215760:	e0bffb17 	ldw	r2,-20(fp)
 3215764:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215768:	e0bff917 	ldw	r2,-28(fp)
 321576c:	1001703a 	wrctl	status,r2
    }
    OS_ENTER_CRITICAL();
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
 3215770:	e0ffff17 	ldw	r3,-4(fp)
 3215774:	008002c4 	movi	r2,11
 3215778:	18800005 	stb	r2,0(r3)
        return;
 321577c:	00000a06 	br	32157a8 <OSEventNameSet+0x130>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
 3215780:	e0bffd17 	ldw	r2,-12(fp)
 3215784:	11000384 	addi	r4,r2,14
 3215788:	e17ffe17 	ldw	r5,-8(fp)
 321578c:	32170cc0 	call	32170cc <OS_StrCopy>
 3215790:	e0bffb17 	ldw	r2,-20(fp)
 3215794:	e0bff815 	stw	r2,-32(fp)
 3215798:	e0bff817 	ldw	r2,-32(fp)
 321579c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 32157a0:	e0bfff17 	ldw	r2,-4(fp)
 32157a4:	10000005 	stb	zero,0(r2)
}
 32157a8:	e037883a 	mov	sp,fp
 32157ac:	dfc00117 	ldw	ra,4(sp)
 32157b0:	df000017 	ldw	fp,0(sp)
 32157b4:	dec00204 	addi	sp,sp,8
 32157b8:	f800283a 	ret

032157bc <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
 32157bc:	deffe704 	addi	sp,sp,-100
 32157c0:	dfc01815 	stw	ra,96(sp)
 32157c4:	df001715 	stw	fp,92(sp)
 32157c8:	df001704 	addi	fp,sp,92
 32157cc:	e13ff615 	stw	r4,-40(fp)
 32157d0:	e17ff715 	stw	r5,-36(fp)
 32157d4:	e1bff815 	stw	r6,-32(fp)
 32157d8:	e1fff90d 	sth	r7,-28(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
 32157dc:	e03ff015 	stw	zero,-64(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
 32157e0:	e0800217 	ldw	r2,8(fp)
 32157e4:	1004c03a 	cmpne	r2,r2,zero
 32157e8:	1000021e 	bne	r2,zero,32157f4 <OSEventPendMulti+0x38>
        return (0);
 32157ec:	e03fff15 	stw	zero,-4(fp)
 32157f0:	00019906 	br	3215e58 <OSEventPendMulti+0x69c>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
 32157f4:	e0bff617 	ldw	r2,-40(fp)
 32157f8:	1004c03a 	cmpne	r2,r2,zero
 32157fc:	1000051e 	bne	r2,zero,3215814 <OSEventPendMulti+0x58>
       *perr =  OS_ERR_PEVENT_NULL;
 3215800:	e0c00217 	ldw	r3,8(fp)
 3215804:	00800104 	movi	r2,4
 3215808:	18800005 	stb	r2,0(r3)
        return (0);
 321580c:	e03fff15 	stw	zero,-4(fp)
 3215810:	00019106 	br	3215e58 <OSEventPendMulti+0x69c>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
 3215814:	e0bff717 	ldw	r2,-36(fp)
 3215818:	1004c03a 	cmpne	r2,r2,zero
 321581c:	1000051e 	bne	r2,zero,3215834 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
 3215820:	e0c00217 	ldw	r3,8(fp)
 3215824:	00800104 	movi	r2,4
 3215828:	18800005 	stb	r2,0(r3)
        return (0);
 321582c:	e03fff15 	stw	zero,-4(fp)
 3215830:	00018906 	br	3215e58 <OSEventPendMulti+0x69c>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
 3215834:	e0bff817 	ldw	r2,-32(fp)
 3215838:	1004c03a 	cmpne	r2,r2,zero
 321583c:	1000051e 	bne	r2,zero,3215854 <OSEventPendMulti+0x98>
       *perr =  OS_ERR_PEVENT_NULL;
 3215840:	e0c00217 	ldw	r3,8(fp)
 3215844:	00800104 	movi	r2,4
 3215848:	18800005 	stb	r2,0(r3)
        return (0);
 321584c:	e03fff15 	stw	zero,-4(fp)
 3215850:	00018106 	br	3215e58 <OSEventPendMulti+0x69c>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
 3215854:	e0bff717 	ldw	r2,-36(fp)
 3215858:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
 321585c:	e0bff617 	ldw	r2,-40(fp)
 3215860:	e0bff515 	stw	r2,-44(fp)
    pevent      = *pevents;
 3215864:	e0bff517 	ldw	r2,-44(fp)
 3215868:	10800017 	ldw	r2,0(r2)
 321586c:	e0bff415 	stw	r2,-48(fp)
    while  (pevent != (OS_EVENT *)0) {
 3215870:	00001806 	br	32158d4 <OSEventPendMulti+0x118>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
 3215874:	e0bff417 	ldw	r2,-48(fp)
 3215878:	10800003 	ldbu	r2,0(r2)
 321587c:	10803fcc 	andi	r2,r2,255
 3215880:	e0bffe15 	stw	r2,-8(fp)
 3215884:	e0fffe17 	ldw	r3,-8(fp)
 3215888:	188000a0 	cmpeqi	r2,r3,2
 321588c:	10000b1e 	bne	r2,zero,32158bc <OSEventPendMulti+0x100>
 3215890:	e0fffe17 	ldw	r3,-8(fp)
 3215894:	188000e0 	cmpeqi	r2,r3,3
 3215898:	1000081e 	bne	r2,zero,32158bc <OSEventPendMulti+0x100>
 321589c:	e0fffe17 	ldw	r3,-8(fp)
 32158a0:	18800060 	cmpeqi	r2,r3,1
 32158a4:	1000051e 	bne	r2,zero,32158bc <OSEventPendMulti+0x100>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
 32158a8:	e0c00217 	ldw	r3,8(fp)
 32158ac:	00800044 	movi	r2,1
 32158b0:	18800005 	stb	r2,0(r3)
                 return (0);
 32158b4:	e03fff15 	stw	zero,-4(fp)
 32158b8:	00016706 	br	3215e58 <OSEventPendMulti+0x69c>
        }
        pevents++;
 32158bc:	e0bff517 	ldw	r2,-44(fp)
 32158c0:	10800104 	addi	r2,r2,4
 32158c4:	e0bff515 	stw	r2,-44(fp)
        pevent = *pevents;
 32158c8:	e0bff517 	ldw	r2,-44(fp)
 32158cc:	10800017 	ldw	r2,0(r2)
 32158d0:	e0bff415 	stw	r2,-48(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
 32158d4:	e0bff417 	ldw	r2,-48(fp)
 32158d8:	1004c03a 	cmpne	r2,r2,zero
 32158dc:	103fe51e 	bne	r2,zero,3215874 <OSEventPendMulti+0xb8>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
 32158e0:	d0a8b203 	ldbu	r2,-23864(gp)
 32158e4:	10803fcc 	andi	r2,r2,255
 32158e8:	1005003a 	cmpeq	r2,r2,zero
 32158ec:	1000051e 	bne	r2,zero,3215904 <OSEventPendMulti+0x148>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
 32158f0:	e0c00217 	ldw	r3,8(fp)
 32158f4:	00800084 	movi	r2,2
 32158f8:	18800005 	stb	r2,0(r3)
        return (0);
 32158fc:	e03fff15 	stw	zero,-4(fp)
 3215900:	00015506 	br	3215e58 <OSEventPendMulti+0x69c>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
 3215904:	d0a8a403 	ldbu	r2,-23920(gp)
 3215908:	10803fcc 	andi	r2,r2,255
 321590c:	1005003a 	cmpeq	r2,r2,zero
 3215910:	1000051e 	bne	r2,zero,3215928 <OSEventPendMulti+0x16c>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
 3215914:	e0c00217 	ldw	r3,8(fp)
 3215918:	00800344 	movi	r2,13
 321591c:	18800005 	stb	r2,0(r3)
        return (0);
 3215920:	e03fff15 	stw	zero,-4(fp)
 3215924:	00014c06 	br	3215e58 <OSEventPendMulti+0x69c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3215928:	0005303a 	rdctl	r2,status
 321592c:	e0bfef15 	stw	r2,-68(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3215930:	e0ffef17 	ldw	r3,-68(fp)
 3215934:	00bfff84 	movi	r2,-2
 3215938:	1884703a 	and	r2,r3,r2
 321593c:	1001703a 	wrctl	status,r2
  
  return context;
 3215940:	e0bfef17 	ldw	r2,-68(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
 3215944:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
 3215948:	e03ff205 	stb	zero,-56(fp)
    events_rdy_nbr =  0;
 321594c:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
 3215950:	e03ff105 	stb	zero,-60(fp)
    pevents        =  pevents_pend;
 3215954:	e0bff617 	ldw	r2,-40(fp)
 3215958:	e0bff515 	stw	r2,-44(fp)
    pevent         = *pevents;
 321595c:	e0bff517 	ldw	r2,-44(fp)
 3215960:	10800017 	ldw	r2,0(r2)
 3215964:	e0bff415 	stw	r2,-48(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 3215968:	00008f06 	br	3215ba8 <OSEventPendMulti+0x3ec>
        switch (pevent->OSEventType) {
 321596c:	e0bff417 	ldw	r2,-48(fp)
 3215970:	10800003 	ldbu	r2,0(r2)
 3215974:	10803fcc 	andi	r2,r2,255
 3215978:	e0bffd15 	stw	r2,-12(fp)
 321597c:	e0fffd17 	ldw	r3,-12(fp)
 3215980:	188000a0 	cmpeqi	r2,r3,2
 3215984:	1000441e 	bne	r2,zero,3215a98 <OSEventPendMulti+0x2dc>
 3215988:	e0fffd17 	ldw	r3,-12(fp)
 321598c:	188000e0 	cmpeqi	r2,r3,3
 3215990:	1000041e 	bne	r2,zero,32159a4 <OSEventPendMulti+0x1e8>
 3215994:	e0fffd17 	ldw	r3,-12(fp)
 3215998:	18800060 	cmpeqi	r2,r3,1
 321599c:	1000211e 	bne	r2,zero,3215a24 <OSEventPendMulti+0x268>
 32159a0:	00006f06 	br	3215b60 <OSEventPendMulti+0x3a4>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
 32159a4:	e0bff417 	ldw	r2,-48(fp)
 32159a8:	1080020b 	ldhu	r2,8(r2)
 32159ac:	10bfffcc 	andi	r2,r2,65535
 32159b0:	1005003a 	cmpeq	r2,r2,zero
 32159b4:	1000171e 	bne	r2,zero,3215a14 <OSEventPendMulti+0x258>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
 32159b8:	e0bff417 	ldw	r2,-48(fp)
 32159bc:	1080020b 	ldhu	r2,8(r2)
 32159c0:	10bfffc4 	addi	r2,r2,-1
 32159c4:	1007883a 	mov	r3,r2
 32159c8:	e0bff417 	ldw	r2,-48(fp)
 32159cc:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
 32159d0:	e0fff717 	ldw	r3,-36(fp)
 32159d4:	e0bff417 	ldw	r2,-48(fp)
 32159d8:	18800015 	stw	r2,0(r3)
 32159dc:	e0bff717 	ldw	r2,-36(fp)
 32159e0:	10800104 	addi	r2,r2,4
 32159e4:	e0bff715 	stw	r2,-36(fp)
                      events_rdy   =  OS_TRUE;
 32159e8:	00800044 	movi	r2,1
 32159ec:	e0bff205 	stb	r2,-56(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
 32159f0:	e0bff817 	ldw	r2,-32(fp)
 32159f4:	10000015 	stw	zero,0(r2)
 32159f8:	e0bff817 	ldw	r2,-32(fp)
 32159fc:	10800104 	addi	r2,r2,4
 3215a00:	e0bff815 	stw	r2,-32(fp)
                      events_rdy_nbr++;
 3215a04:	e0bff18b 	ldhu	r2,-58(fp)
 3215a08:	10800044 	addi	r2,r2,1
 3215a0c:	e0bff18d 	sth	r2,-58(fp)
 3215a10:	00005f06 	br	3215b90 <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
 3215a14:	e0bff103 	ldbu	r2,-60(fp)
 3215a18:	10800054 	ori	r2,r2,1
 3215a1c:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 3215a20:	00005b06 	br	3215b90 <OSEventPendMulti+0x3d4>
#endif

#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
 3215a24:	e0bff417 	ldw	r2,-48(fp)
 3215a28:	10800117 	ldw	r2,4(r2)
 3215a2c:	1005003a 	cmpeq	r2,r2,zero
 3215a30:	1000151e 	bne	r2,zero,3215a88 <OSEventPendMulti+0x2cc>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
 3215a34:	e0bff417 	ldw	r2,-48(fp)
 3215a38:	10c00117 	ldw	r3,4(r2)
 3215a3c:	e0bff817 	ldw	r2,-32(fp)
 3215a40:	10c00015 	stw	r3,0(r2)
 3215a44:	e0bff817 	ldw	r2,-32(fp)
 3215a48:	10800104 	addi	r2,r2,4
 3215a4c:	e0bff815 	stw	r2,-32(fp)
                     pevent->OSEventPtr  = (void *)0;
 3215a50:	e0bff417 	ldw	r2,-48(fp)
 3215a54:	10000115 	stw	zero,4(r2)
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
 3215a58:	e0fff717 	ldw	r3,-36(fp)
 3215a5c:	e0bff417 	ldw	r2,-48(fp)
 3215a60:	18800015 	stw	r2,0(r3)
 3215a64:	e0bff717 	ldw	r2,-36(fp)
 3215a68:	10800104 	addi	r2,r2,4
 3215a6c:	e0bff715 	stw	r2,-36(fp)
                      events_rdy         =  OS_TRUE;
 3215a70:	00800044 	movi	r2,1
 3215a74:	e0bff205 	stb	r2,-56(fp)
                      events_rdy_nbr++;
 3215a78:	e0bff18b 	ldhu	r2,-58(fp)
 3215a7c:	10800044 	addi	r2,r2,1
 3215a80:	e0bff18d 	sth	r2,-58(fp)
 3215a84:	00004206 	br	3215b90 <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
 3215a88:	e0bff103 	ldbu	r2,-60(fp)
 3215a8c:	10800094 	ori	r2,r2,2
 3215a90:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 3215a94:	00003e06 	br	3215b90 <OSEventPendMulti+0x3d4>
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
 3215a98:	e0bff417 	ldw	r2,-48(fp)
 3215a9c:	10800117 	ldw	r2,4(r2)
 3215aa0:	e0bff315 	stw	r2,-52(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
 3215aa4:	e0bff317 	ldw	r2,-52(fp)
 3215aa8:	1080058b 	ldhu	r2,22(r2)
 3215aac:	10bfffcc 	andi	r2,r2,65535
 3215ab0:	1005003a 	cmpeq	r2,r2,zero
 3215ab4:	1000261e 	bne	r2,zero,3215b50 <OSEventPendMulti+0x394>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
 3215ab8:	e0bff317 	ldw	r2,-52(fp)
 3215abc:	11000417 	ldw	r4,16(r2)
 3215ac0:	20c00017 	ldw	r3,0(r4)
 3215ac4:	e0bff817 	ldw	r2,-32(fp)
 3215ac8:	10c00015 	stw	r3,0(r2)
 3215acc:	e0bff817 	ldw	r2,-32(fp)
 3215ad0:	10800104 	addi	r2,r2,4
 3215ad4:	e0bff815 	stw	r2,-32(fp)
 3215ad8:	20c00104 	addi	r3,r4,4
 3215adc:	e0bff317 	ldw	r2,-52(fp)
 3215ae0:	10c00415 	stw	r3,16(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
 3215ae4:	e0bff317 	ldw	r2,-52(fp)
 3215ae8:	10c00417 	ldw	r3,16(r2)
 3215aec:	e0bff317 	ldw	r2,-52(fp)
 3215af0:	10800217 	ldw	r2,8(r2)
 3215af4:	1880041e 	bne	r3,r2,3215b08 <OSEventPendMulti+0x34c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
 3215af8:	e0bff317 	ldw	r2,-52(fp)
 3215afc:	10c00117 	ldw	r3,4(r2)
 3215b00:	e0bff317 	ldw	r2,-52(fp)
 3215b04:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
 3215b08:	e0bff317 	ldw	r2,-52(fp)
 3215b0c:	1080058b 	ldhu	r2,22(r2)
 3215b10:	10bfffc4 	addi	r2,r2,-1
 3215b14:	1007883a 	mov	r3,r2
 3215b18:	e0bff317 	ldw	r2,-52(fp)
 3215b1c:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
 3215b20:	e0fff717 	ldw	r3,-36(fp)
 3215b24:	e0bff417 	ldw	r2,-48(fp)
 3215b28:	18800015 	stw	r2,0(r3)
 3215b2c:	e0bff717 	ldw	r2,-36(fp)
 3215b30:	10800104 	addi	r2,r2,4
 3215b34:	e0bff715 	stw	r2,-36(fp)
                      events_rdy   = OS_TRUE;
 3215b38:	00800044 	movi	r2,1
 3215b3c:	e0bff205 	stb	r2,-56(fp)
                      events_rdy_nbr++;
 3215b40:	e0bff18b 	ldhu	r2,-58(fp)
 3215b44:	10800044 	addi	r2,r2,1
 3215b48:	e0bff18d 	sth	r2,-58(fp)
 3215b4c:	00001006 	br	3215b90 <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
 3215b50:	e0bff103 	ldbu	r2,-60(fp)
 3215b54:	10800114 	ori	r2,r2,4
 3215b58:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 3215b5c:	00000c06 	br	3215b90 <OSEventPendMulti+0x3d4>
 3215b60:	e0bff017 	ldw	r2,-64(fp)
 3215b64:	e0bfee15 	stw	r2,-72(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215b68:	e0bfee17 	ldw	r2,-72(fp)
 3215b6c:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
 3215b70:	e0bff717 	ldw	r2,-36(fp)
 3215b74:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
 3215b78:	e0c00217 	ldw	r3,8(fp)
 3215b7c:	00800044 	movi	r2,1
 3215b80:	18800005 	stb	r2,0(r3)
                 return (events_rdy_nbr);
 3215b84:	e0bff18b 	ldhu	r2,-58(fp)
 3215b88:	e0bfff15 	stw	r2,-4(fp)
 3215b8c:	0000b206 	br	3215e58 <OSEventPendMulti+0x69c>
        }
        pevents++;
 3215b90:	e0bff517 	ldw	r2,-44(fp)
 3215b94:	10800104 	addi	r2,r2,4
 3215b98:	e0bff515 	stw	r2,-44(fp)
        pevent = *pevents;
 3215b9c:	e0bff517 	ldw	r2,-44(fp)
 3215ba0:	10800017 	ldw	r2,0(r2)
 3215ba4:	e0bff415 	stw	r2,-48(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 3215ba8:	e0bff417 	ldw	r2,-48(fp)
 3215bac:	1004c03a 	cmpne	r2,r2,zero
 3215bb0:	103f6e1e 	bne	r2,zero,321596c <OSEventPendMulti+0x1b0>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
 3215bb4:	e0bff203 	ldbu	r2,-56(fp)
 3215bb8:	10800058 	cmpnei	r2,r2,1
 3215bbc:	10000b1e 	bne	r2,zero,3215bec <OSEventPendMulti+0x430>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
 3215bc0:	e0bff717 	ldw	r2,-36(fp)
 3215bc4:	10000015 	stw	zero,0(r2)
 3215bc8:	e0bff017 	ldw	r2,-64(fp)
 3215bcc:	e0bfed15 	stw	r2,-76(fp)
 3215bd0:	e0bfed17 	ldw	r2,-76(fp)
 3215bd4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
 3215bd8:	e0800217 	ldw	r2,8(fp)
 3215bdc:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
 3215be0:	e0fff18b 	ldhu	r3,-58(fp)
 3215be4:	e0ffff15 	stw	r3,-4(fp)
 3215be8:	00009b06 	br	3215e58 <OSEventPendMulti+0x69c>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
 3215bec:	d128b317 	ldw	r4,-23860(gp)
 3215bf0:	d0a8b317 	ldw	r2,-23860(gp)
 3215bf4:	10c00c03 	ldbu	r3,48(r2)
 3215bf8:	e0bff103 	ldbu	r2,-60(fp)
 3215bfc:	1884b03a 	or	r2,r3,r2
 3215c00:	1007883a 	mov	r3,r2
 3215c04:	00bfe004 	movi	r2,-128
 3215c08:	1884b03a 	or	r2,r3,r2
 3215c0c:	20800c05 	stb	r2,48(r4)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 3215c10:	d0a8b317 	ldw	r2,-23860(gp)
 3215c14:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
 3215c18:	d0e8b317 	ldw	r3,-23860(gp)
 3215c1c:	e0bff90b 	ldhu	r2,-28(fp)
 3215c20:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
 3215c24:	e13ff617 	ldw	r4,-40(fp)
 3215c28:	32167ec0 	call	32167ec <OS_EventTaskWaitMulti>
 3215c2c:	e0bff017 	ldw	r2,-64(fp)
 3215c30:	e0bfec15 	stw	r2,-80(fp)
 3215c34:	e0bfec17 	ldw	r2,-80(fp)
 3215c38:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
 3215c3c:	3216f880 	call	3216f88 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3215c40:	0005303a 	rdctl	r2,status
 3215c44:	e0bfeb15 	stw	r2,-84(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3215c48:	e0ffeb17 	ldw	r3,-84(fp)
 3215c4c:	00bfff84 	movi	r2,-2
 3215c50:	1884703a 	and	r2,r3,r2
 3215c54:	1001703a 	wrctl	status,r2
  
  return context;
 3215c58:	e0bfeb17 	ldw	r2,-84(fp)
    OS_ENTER_CRITICAL();
 3215c5c:	e0bff015 	stw	r2,-64(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
 3215c60:	d0a8b317 	ldw	r2,-23860(gp)
 3215c64:	10800c43 	ldbu	r2,49(r2)
 3215c68:	10803fcc 	andi	r2,r2,255
 3215c6c:	e0bffc15 	stw	r2,-16(fp)
 3215c70:	e0fffc17 	ldw	r3,-16(fp)
 3215c74:	1805003a 	cmpeq	r2,r3,zero
 3215c78:	1000041e 	bne	r2,zero,3215c8c <OSEventPendMulti+0x4d0>
 3215c7c:	e0fffc17 	ldw	r3,-16(fp)
 3215c80:	188000a0 	cmpeqi	r2,r3,2
 3215c84:	1000011e 	bne	r2,zero,3215c8c <OSEventPendMulti+0x4d0>
 3215c88:	00001906 	br	3215cf0 <OSEventPendMulti+0x534>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
 3215c8c:	d0a8b317 	ldw	r2,-23860(gp)
 3215c90:	10800717 	ldw	r2,28(r2)
 3215c94:	e0bff415 	stw	r2,-48(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
 3215c98:	e0bff417 	ldw	r2,-48(fp)
 3215c9c:	1005003a 	cmpeq	r2,r2,zero
 3215ca0:	10000c1e 	bne	r2,zero,3215cd4 <OSEventPendMulti+0x518>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
 3215ca4:	e0fff717 	ldw	r3,-36(fp)
 3215ca8:	e0bff417 	ldw	r2,-48(fp)
 3215cac:	18800015 	stw	r2,0(r3)
 3215cb0:	e0bff717 	ldw	r2,-36(fp)
 3215cb4:	10800104 	addi	r2,r2,4
 3215cb8:	e0bff715 	stw	r2,-36(fp)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
 3215cbc:	e0bff717 	ldw	r2,-36(fp)
 3215cc0:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
 3215cc4:	e0bff18b 	ldhu	r2,-58(fp)
 3215cc8:	10800044 	addi	r2,r2,1
 3215ccc:	e0bff18d 	sth	r2,-58(fp)
 3215cd0:	00000a06 	br	3215cfc <OSEventPendMulti+0x540>

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
 3215cd4:	d0a8b317 	ldw	r2,-23860(gp)
 3215cd8:	00c00044 	movi	r3,1
 3215cdc:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 3215ce0:	d128b317 	ldw	r4,-23860(gp)
 3215ce4:	e17ff617 	ldw	r5,-40(fp)
 3215ce8:	32169f80 	call	32169f8 <OS_EventTaskRemoveMulti>
             }
			 break;
 3215cec:	00000306 	br	3215cfc <OSEventPendMulti+0x540>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 3215cf0:	d128b317 	ldw	r4,-23860(gp)
 3215cf4:	e17ff617 	ldw	r5,-40(fp)
 3215cf8:	32169f80 	call	32169f8 <OS_EventTaskRemoveMulti>
             break;
    }

    switch (OSTCBCur->OSTCBStatPend) {
 3215cfc:	d0a8b317 	ldw	r2,-23860(gp)
 3215d00:	10800c43 	ldbu	r2,49(r2)
 3215d04:	10803fcc 	andi	r2,r2,255
 3215d08:	e0bffb15 	stw	r2,-20(fp)
 3215d0c:	e0fffb17 	ldw	r3,-20(fp)
 3215d10:	1805003a 	cmpeq	r2,r3,zero
 3215d14:	1000041e 	bne	r2,zero,3215d28 <OSEventPendMulti+0x56c>
 3215d18:	e0fffb17 	ldw	r3,-20(fp)
 3215d1c:	188000a0 	cmpeqi	r2,r3,2
 3215d20:	10002c1e 	bne	r2,zero,3215dd4 <OSEventPendMulti+0x618>
 3215d24:	00003406 	br	3215df8 <OSEventPendMulti+0x63c>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
 3215d28:	e0bff417 	ldw	r2,-48(fp)
 3215d2c:	10800003 	ldbu	r2,0(r2)
 3215d30:	10803fcc 	andi	r2,r2,255
 3215d34:	e0bffa15 	stw	r2,-24(fp)
 3215d38:	e0fffa17 	ldw	r3,-24(fp)
 3215d3c:	18800050 	cmplti	r2,r3,1
 3215d40:	1000151e 	bne	r2,zero,3215d98 <OSEventPendMulti+0x5dc>
 3215d44:	e0fffa17 	ldw	r3,-24(fp)
 3215d48:	188000d0 	cmplti	r2,r3,3
 3215d4c:	10000a1e 	bne	r2,zero,3215d78 <OSEventPendMulti+0x5bc>
 3215d50:	e0fffa17 	ldw	r3,-24(fp)
 3215d54:	188000e0 	cmpeqi	r2,r3,3
 3215d58:	1000011e 	bne	r2,zero,3215d60 <OSEventPendMulti+0x5a4>
 3215d5c:	00000e06 	br	3215d98 <OSEventPendMulti+0x5dc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
 3215d60:	e0bff817 	ldw	r2,-32(fp)
 3215d64:	10000015 	stw	zero,0(r2)
 3215d68:	e0bff817 	ldw	r2,-32(fp)
 3215d6c:	10800104 	addi	r2,r2,4
 3215d70:	e0bff815 	stw	r2,-32(fp)
                      break;
 3215d74:	00001406 	br	3215dc8 <OSEventPendMulti+0x60c>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
 3215d78:	d0a8b317 	ldw	r2,-23860(gp)
 3215d7c:	10c00917 	ldw	r3,36(r2)
 3215d80:	e0bff817 	ldw	r2,-32(fp)
 3215d84:	10c00015 	stw	r3,0(r2)
 3215d88:	e0bff817 	ldw	r2,-32(fp)
 3215d8c:	10800104 	addi	r2,r2,4
 3215d90:	e0bff815 	stw	r2,-32(fp)
                      break;
 3215d94:	00000c06 	br	3215dc8 <OSEventPendMulti+0x60c>
 3215d98:	e0bff017 	ldw	r2,-64(fp)
 3215d9c:	e0bfea15 	stw	r2,-88(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215da0:	e0bfea17 	ldw	r2,-88(fp)
 3215da4:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
 3215da8:	e0bff717 	ldw	r2,-36(fp)
 3215dac:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
 3215db0:	e0c00217 	ldw	r3,8(fp)
 3215db4:	00800044 	movi	r2,1
 3215db8:	18800005 	stb	r2,0(r3)
                      return (events_rdy_nbr);
 3215dbc:	e0bff18b 	ldhu	r2,-58(fp)
 3215dc0:	e0bfff15 	stw	r2,-4(fp)
 3215dc4:	00002406 	br	3215e58 <OSEventPendMulti+0x69c>
             }
            *perr = OS_ERR_NONE;
 3215dc8:	e0800217 	ldw	r2,8(fp)
 3215dcc:	10000005 	stb	zero,0(r2)
             break;
 3215dd0:	00001106 	br	3215e18 <OSEventPendMulti+0x65c>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
 3215dd4:	e0bff817 	ldw	r2,-32(fp)
 3215dd8:	10000015 	stw	zero,0(r2)
 3215ddc:	e0bff817 	ldw	r2,-32(fp)
 3215de0:	10800104 	addi	r2,r2,4
 3215de4:	e0bff815 	stw	r2,-32(fp)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
 3215de8:	e0c00217 	ldw	r3,8(fp)
 3215dec:	00800384 	movi	r2,14
 3215df0:	18800005 	stb	r2,0(r3)
             break;
 3215df4:	00000806 	br	3215e18 <OSEventPendMulti+0x65c>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
 3215df8:	e0bff817 	ldw	r2,-32(fp)
 3215dfc:	10000015 	stw	zero,0(r2)
 3215e00:	e0bff817 	ldw	r2,-32(fp)
 3215e04:	10800104 	addi	r2,r2,4
 3215e08:	e0bff815 	stw	r2,-32(fp)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
 3215e0c:	e0c00217 	ldw	r3,8(fp)
 3215e10:	00800284 	movi	r2,10
 3215e14:	18800005 	stb	r2,0(r3)
             break;
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
 3215e18:	d0a8b317 	ldw	r2,-23860(gp)
 3215e1c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
 3215e20:	d0a8b317 	ldw	r2,-23860(gp)
 3215e24:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
 3215e28:	d0a8b317 	ldw	r2,-23860(gp)
 3215e2c:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 3215e30:	d0a8b317 	ldw	r2,-23860(gp)
 3215e34:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
 3215e38:	d0a8b317 	ldw	r2,-23860(gp)
 3215e3c:	10000915 	stw	zero,36(r2)
 3215e40:	e0bff017 	ldw	r2,-64(fp)
 3215e44:	e0bfe915 	stw	r2,-92(fp)
 3215e48:	e0bfe917 	ldw	r2,-92(fp)
 3215e4c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
 3215e50:	e0fff18b 	ldhu	r3,-58(fp)
 3215e54:	e0ffff15 	stw	r3,-4(fp)
 3215e58:	e0bfff17 	ldw	r2,-4(fp)
}
 3215e5c:	e037883a 	mov	sp,fp
 3215e60:	dfc00117 	ldw	ra,4(sp)
 3215e64:	df000017 	ldw	fp,0(sp)
 3215e68:	dec00204 	addi	sp,sp,8
 3215e6c:	f800283a 	ret

03215e70 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
 3215e70:	defffe04 	addi	sp,sp,-8
 3215e74:	dfc00115 	stw	ra,4(sp)
 3215e78:	df000015 	stw	fp,0(sp)
 3215e7c:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
 3215e80:	323b9040 	call	323b904 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
 3215e84:	3216c400 	call	3216c40 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
 3215e88:	3216c840 	call	3216c84 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
 3215e8c:	3216de80 	call	3216de8 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
 3215e90:	3216b640 	call	3216b64 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
 3215e94:	3218e980 	call	3218e98 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
 3215e98:	32198700 	call	3219870 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
 3215e9c:	321abc80 	call	321abc8 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
 3215ea0:	3216cf00 	call	3216cf0 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
 3215ea4:	3216d6c0 	call	3216d6c <OS_InitTaskStat>

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
 3215ea8:	323b9200 	call	323b920 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
 3215eac:	32176700 	call	3217670 <OSDebugInit>
#endif
}
 3215eb0:	e037883a 	mov	sp,fp
 3215eb4:	dfc00117 	ldw	ra,4(sp)
 3215eb8:	df000017 	ldw	fp,0(sp)
 3215ebc:	dec00204 	addi	sp,sp,8
 3215ec0:	f800283a 	ret

03215ec4 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
 3215ec4:	defffc04 	addi	sp,sp,-16
 3215ec8:	df000315 	stw	fp,12(sp)
 3215ecc:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 3215ed0:	e03fff15 	stw	zero,-4(fp)
#endif

    if (OSRunning == OS_TRUE) {
 3215ed4:	d0a8a443 	ldbu	r2,-23919(gp)
 3215ed8:	10803fcc 	andi	r2,r2,255
 3215edc:	10800058 	cmpnei	r2,r2,1
 3215ee0:	1000131e 	bne	r2,zero,3215f30 <OSIntEnter+0x6c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3215ee4:	0005303a 	rdctl	r2,status
 3215ee8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3215eec:	e0fffe17 	ldw	r3,-8(fp)
 3215ef0:	00bfff84 	movi	r2,-2
 3215ef4:	1884703a 	and	r2,r3,r2
 3215ef8:	1001703a 	wrctl	status,r2
  
  return context;
 3215efc:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 3215f00:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting < 255u) {
 3215f04:	d0a8b203 	ldbu	r2,-23864(gp)
 3215f08:	10803fcc 	andi	r2,r2,255
 3215f0c:	10803fe0 	cmpeqi	r2,r2,255
 3215f10:	1000031e 	bne	r2,zero,3215f20 <OSIntEnter+0x5c>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
 3215f14:	d0a8b203 	ldbu	r2,-23864(gp)
 3215f18:	10800044 	addi	r2,r2,1
 3215f1c:	d0a8b205 	stb	r2,-23864(gp)
 3215f20:	e0bfff17 	ldw	r2,-4(fp)
 3215f24:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3215f28:	e0bffd17 	ldw	r2,-12(fp)
 3215f2c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
    }
}
 3215f30:	e037883a 	mov	sp,fp
 3215f34:	df000017 	ldw	fp,0(sp)
 3215f38:	dec00104 	addi	sp,sp,4
 3215f3c:	f800283a 	ret

03215f40 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
 3215f40:	defffb04 	addi	sp,sp,-20
 3215f44:	dfc00415 	stw	ra,16(sp)
 3215f48:	df000315 	stw	fp,12(sp)
 3215f4c:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 3215f50:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {
 3215f54:	d0a8a443 	ldbu	r2,-23919(gp)
 3215f58:	10803fcc 	andi	r2,r2,255
 3215f5c:	10800058 	cmpnei	r2,r2,1
 3215f60:	1000321e 	bne	r2,zero,321602c <OSIntExit+0xec>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3215f64:	0005303a 	rdctl	r2,status
 3215f68:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3215f6c:	e0fffe17 	ldw	r3,-8(fp)
 3215f70:	00bfff84 	movi	r2,-2
 3215f74:	1884703a 	and	r2,r3,r2
 3215f78:	1001703a 	wrctl	status,r2
  
  return context;
 3215f7c:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 3215f80:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
 3215f84:	d0a8b203 	ldbu	r2,-23864(gp)
 3215f88:	10803fcc 	andi	r2,r2,255
 3215f8c:	1005003a 	cmpeq	r2,r2,zero
 3215f90:	1000031e 	bne	r2,zero,3215fa0 <OSIntExit+0x60>
            OSIntNesting--;
 3215f94:	d0a8b203 	ldbu	r2,-23864(gp)
 3215f98:	10bfffc4 	addi	r2,r2,-1
 3215f9c:	d0a8b205 	stb	r2,-23864(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
 3215fa0:	d0a8b203 	ldbu	r2,-23864(gp)
 3215fa4:	10803fcc 	andi	r2,r2,255
 3215fa8:	1004c03a 	cmpne	r2,r2,zero
 3215fac:	10001b1e 	bne	r2,zero,321601c <OSIntExit+0xdc>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
 3215fb0:	d0a8a403 	ldbu	r2,-23920(gp)
 3215fb4:	10803fcc 	andi	r2,r2,255
 3215fb8:	1004c03a 	cmpne	r2,r2,zero
 3215fbc:	1000171e 	bne	r2,zero,321601c <OSIntExit+0xdc>
                OS_SchedNew();
 3215fc0:	321705c0 	call	321705c <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
 3215fc4:	d0a8a603 	ldbu	r2,-23912(gp)
 3215fc8:	d0e8a643 	ldbu	r3,-23911(gp)
 3215fcc:	11003fcc 	andi	r4,r2,255
 3215fd0:	18803fcc 	andi	r2,r3,255
 3215fd4:	20801126 	beq	r4,r2,321601c <OSIntExit+0xdc>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
 3215fd8:	d0a8a603 	ldbu	r2,-23912(gp)
 3215fdc:	10803fcc 	andi	r2,r2,255
 3215fe0:	00c0c9b4 	movhi	r3,806
 3215fe4:	18f26b04 	addi	r3,r3,-13908
 3215fe8:	1085883a 	add	r2,r2,r2
 3215fec:	1085883a 	add	r2,r2,r2
 3215ff0:	10c5883a 	add	r2,r2,r3
 3215ff4:	10800017 	ldw	r2,0(r2)
 3215ff8:	d0a8ae15 	stw	r2,-23880(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
 3215ffc:	d0e8ae17 	ldw	r3,-23880(gp)
 3216000:	18800e17 	ldw	r2,56(r3)
 3216004:	10800044 	addi	r2,r2,1
 3216008:	18800e15 	stw	r2,56(r3)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
 321600c:	d0a8a917 	ldw	r2,-23900(gp)
 3216010:	10800044 	addi	r2,r2,1
 3216014:	d0a8a915 	stw	r2,-23900(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
 3216018:	323b4840 	call	323b484 <OSCtxSw>
 321601c:	e0bfff17 	ldw	r2,-4(fp)
 3216020:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3216024:	e0bffd17 	ldw	r2,-12(fp)
 3216028:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 321602c:	e037883a 	mov	sp,fp
 3216030:	dfc00117 	ldw	ra,4(sp)
 3216034:	df000017 	ldw	fp,0(sp)
 3216038:	dec00204 	addi	sp,sp,8
 321603c:	f800283a 	ret

03216040 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
 3216040:	defffc04 	addi	sp,sp,-16
 3216044:	df000315 	stw	fp,12(sp)
 3216048:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 321604c:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
 3216050:	d0a8a443 	ldbu	r2,-23919(gp)
 3216054:	10803fcc 	andi	r2,r2,255
 3216058:	10800058 	cmpnei	r2,r2,1
 321605c:	1000171e 	bne	r2,zero,32160bc <OSSchedLock+0x7c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3216060:	0005303a 	rdctl	r2,status
 3216064:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3216068:	e0fffe17 	ldw	r3,-8(fp)
 321606c:	00bfff84 	movi	r2,-2
 3216070:	1884703a 	and	r2,r3,r2
 3216074:	1001703a 	wrctl	status,r2
  
  return context;
 3216078:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 321607c:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
 3216080:	d0a8b203 	ldbu	r2,-23864(gp)
 3216084:	10803fcc 	andi	r2,r2,255
 3216088:	1004c03a 	cmpne	r2,r2,zero
 321608c:	1000071e 	bne	r2,zero,32160ac <OSSchedLock+0x6c>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
 3216090:	d0a8a403 	ldbu	r2,-23920(gp)
 3216094:	10803fcc 	andi	r2,r2,255
 3216098:	10803fe0 	cmpeqi	r2,r2,255
 321609c:	1000031e 	bne	r2,zero,32160ac <OSSchedLock+0x6c>
                OSLockNesting++;                 /* Increment lock nesting level                       */
 32160a0:	d0a8a403 	ldbu	r2,-23920(gp)
 32160a4:	10800044 	addi	r2,r2,1
 32160a8:	d0a8a405 	stb	r2,-23920(gp)
 32160ac:	e0bfff17 	ldw	r2,-4(fp)
 32160b0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 32160b4:	e0bffd17 	ldw	r2,-12(fp)
 32160b8:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 32160bc:	e037883a 	mov	sp,fp
 32160c0:	df000017 	ldw	fp,0(sp)
 32160c4:	dec00104 	addi	sp,sp,4
 32160c8:	f800283a 	ret

032160cc <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
 32160cc:	defff804 	addi	sp,sp,-32
 32160d0:	dfc00715 	stw	ra,28(sp)
 32160d4:	df000615 	stw	fp,24(sp)
 32160d8:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 32160dc:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
 32160e0:	d0a8a443 	ldbu	r2,-23919(gp)
 32160e4:	10803fcc 	andi	r2,r2,255
 32160e8:	10800058 	cmpnei	r2,r2,1
 32160ec:	10002b1e 	bne	r2,zero,321619c <OSSchedUnlock+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32160f0:	0005303a 	rdctl	r2,status
 32160f4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32160f8:	e0fffe17 	ldw	r3,-8(fp)
 32160fc:	00bfff84 	movi	r2,-2
 3216100:	1884703a 	and	r2,r3,r2
 3216104:	1001703a 	wrctl	status,r2
  
  return context;
 3216108:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 321610c:	e0bfff15 	stw	r2,-4(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
 3216110:	d0a8a403 	ldbu	r2,-23920(gp)
 3216114:	10803fcc 	andi	r2,r2,255
 3216118:	1005003a 	cmpeq	r2,r2,zero
 321611c:	10001b1e 	bne	r2,zero,321618c <OSSchedUnlock+0xc0>
            OSLockNesting--;                               /* Decrement lock nesting level             */
 3216120:	d0a8a403 	ldbu	r2,-23920(gp)
 3216124:	10bfffc4 	addi	r2,r2,-1
 3216128:	d0a8a405 	stb	r2,-23920(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
 321612c:	d0a8a403 	ldbu	r2,-23920(gp)
 3216130:	10803fcc 	andi	r2,r2,255
 3216134:	1004c03a 	cmpne	r2,r2,zero
 3216138:	10000f1e 	bne	r2,zero,3216178 <OSSchedUnlock+0xac>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
 321613c:	d0a8b203 	ldbu	r2,-23864(gp)
 3216140:	10803fcc 	andi	r2,r2,255
 3216144:	1004c03a 	cmpne	r2,r2,zero
 3216148:	1000061e 	bne	r2,zero,3216164 <OSSchedUnlock+0x98>
 321614c:	e0bfff17 	ldw	r2,-4(fp)
 3216150:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3216154:	e0bffd17 	ldw	r2,-12(fp)
 3216158:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
 321615c:	3216f880 	call	3216f88 <OS_Sched>
 3216160:	00000e06 	br	321619c <OSSchedUnlock+0xd0>
 3216164:	e0bfff17 	ldw	r2,-4(fp)
 3216168:	e0bffc15 	stw	r2,-16(fp)
 321616c:	e0bffc17 	ldw	r2,-16(fp)
 3216170:	1001703a 	wrctl	status,r2
 3216174:	00000906 	br	321619c <OSSchedUnlock+0xd0>
 3216178:	e0bfff17 	ldw	r2,-4(fp)
 321617c:	e0bffb15 	stw	r2,-20(fp)
 3216180:	e0bffb17 	ldw	r2,-20(fp)
 3216184:	1001703a 	wrctl	status,r2
 3216188:	00000406 	br	321619c <OSSchedUnlock+0xd0>
 321618c:	e0bfff17 	ldw	r2,-4(fp)
 3216190:	e0bffa15 	stw	r2,-24(fp)
 3216194:	e0bffa17 	ldw	r2,-24(fp)
 3216198:	1001703a 	wrctl	status,r2
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
 321619c:	e037883a 	mov	sp,fp
 32161a0:	dfc00117 	ldw	ra,4(sp)
 32161a4:	df000017 	ldw	fp,0(sp)
 32161a8:	dec00204 	addi	sp,sp,8
 32161ac:	f800283a 	ret

032161b0 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
 32161b0:	defffe04 	addi	sp,sp,-8
 32161b4:	dfc00115 	stw	ra,4(sp)
 32161b8:	df000015 	stw	fp,0(sp)
 32161bc:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
 32161c0:	d0a8a443 	ldbu	r2,-23919(gp)
 32161c4:	10803fcc 	andi	r2,r2,255
 32161c8:	1004c03a 	cmpne	r2,r2,zero
 32161cc:	10000f1e 	bne	r2,zero,321620c <OSStart+0x5c>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
 32161d0:	321705c0 	call	321705c <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
 32161d4:	d0a8a603 	ldbu	r2,-23912(gp)
 32161d8:	d0a8a645 	stb	r2,-23911(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
 32161dc:	d0a8a603 	ldbu	r2,-23912(gp)
 32161e0:	10803fcc 	andi	r2,r2,255
 32161e4:	00c0c9b4 	movhi	r3,806
 32161e8:	18f26b04 	addi	r3,r3,-13908
 32161ec:	1085883a 	add	r2,r2,r2
 32161f0:	1085883a 	add	r2,r2,r2
 32161f4:	10c5883a 	add	r2,r2,r3
 32161f8:	10800017 	ldw	r2,0(r2)
 32161fc:	d0a8ae15 	stw	r2,-23880(gp)
        OSTCBCur      = OSTCBHighRdy;
 3216200:	d0a8ae17 	ldw	r2,-23880(gp)
 3216204:	d0a8b315 	stw	r2,-23860(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
 3216208:	323b5100 	call	323b510 <OSStartHighRdy>
    }
}
 321620c:	e037883a 	mov	sp,fp
 3216210:	dfc00117 	ldw	ra,4(sp)
 3216214:	df000017 	ldw	fp,0(sp)
 3216218:	dec00204 	addi	sp,sp,8
 321621c:	f800283a 	ret

03216220 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
 3216220:	defff904 	addi	sp,sp,-28
 3216224:	dfc00615 	stw	ra,24(sp)
 3216228:	df000515 	stw	fp,20(sp)
 321622c:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3216230:	e03fff15 	stw	zero,-4(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
 3216234:	01000084 	movi	r4,2
 3216238:	321d27c0 	call	321d27c <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321623c:	0005303a 	rdctl	r2,status
 3216240:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3216244:	e0fffe17 	ldw	r3,-8(fp)
 3216248:	00bfff84 	movi	r2,-2
 321624c:	1884703a 	and	r2,r3,r2
 3216250:	1001703a 	wrctl	status,r2
  
  return context;
 3216254:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
 3216258:	e0bfff15 	stw	r2,-4(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
 321625c:	d028a515 	stw	zero,-23916(gp)
 3216260:	e0bfff17 	ldw	r2,-4(fp)
 3216264:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3216268:	e0bffd17 	ldw	r2,-12(fp)
 321626c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
 3216270:	01001904 	movi	r4,100
 3216274:	321d27c0 	call	321d27c <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3216278:	0005303a 	rdctl	r2,status
 321627c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3216280:	e0fffc17 	ldw	r3,-16(fp)
 3216284:	00bfff84 	movi	r2,-2
 3216288:	1884703a 	and	r2,r3,r2
 321628c:	1001703a 	wrctl	status,r2
  
  return context;
 3216290:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
 3216294:	e0bfff15 	stw	r2,-4(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
 3216298:	d0a8a517 	ldw	r2,-23916(gp)
 321629c:	d0a8aa15 	stw	r2,-23896(gp)
    OSStatRdy    = OS_TRUE;
 32162a0:	00800044 	movi	r2,1
 32162a4:	d0a8b605 	stb	r2,-23848(gp)
 32162a8:	e0bfff17 	ldw	r2,-4(fp)
 32162ac:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 32162b0:	e0bffb17 	ldw	r2,-20(fp)
 32162b4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 32162b8:	e037883a 	mov	sp,fp
 32162bc:	dfc00117 	ldw	ra,4(sp)
 32162c0:	df000017 	ldw	fp,0(sp)
 32162c4:	dec00204 	addi	sp,sp,8
 32162c8:	f800283a 	ret

032162cc <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
 32162cc:	defff604 	addi	sp,sp,-40
 32162d0:	dfc00915 	stw	ra,36(sp)
 32162d4:	df000815 	stw	fp,32(sp)
 32162d8:	df000804 	addi	fp,sp,32
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 32162dc:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
 32162e0:	323b8dc0 	call	323b8dc <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32162e4:	0005303a 	rdctl	r2,status
 32162e8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32162ec:	e0fffb17 	ldw	r3,-20(fp)
 32162f0:	00bfff84 	movi	r2,-2
 32162f4:	1884703a 	and	r2,r3,r2
 32162f8:	1001703a 	wrctl	status,r2
  
  return context;
 32162fc:	e0bffb17 	ldw	r2,-20(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
 3216300:	e0bffc15 	stw	r2,-16(fp)
    OSTime++;
 3216304:	d0a8b417 	ldw	r2,-23856(gp)
 3216308:	10800044 	addi	r2,r2,1
 321630c:	d0a8b415 	stw	r2,-23856(gp)
 3216310:	e0bffc17 	ldw	r2,-16(fp)
 3216314:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3216318:	e0bffa17 	ldw	r2,-24(fp)
 321631c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
 3216320:	d0a8a443 	ldbu	r2,-23919(gp)
 3216324:	10803fcc 	andi	r2,r2,255
 3216328:	10800058 	cmpnei	r2,r2,1
 321632c:	1000721e 	bne	r2,zero,32164f8 <OSTimeTick+0x22c>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
 3216330:	d0a8a803 	ldbu	r2,-23904(gp)
 3216334:	10803fcc 	andi	r2,r2,255
 3216338:	e0bfff15 	stw	r2,-4(fp)
 321633c:	e0ffff17 	ldw	r3,-4(fp)
 3216340:	18800060 	cmpeqi	r2,r3,1
 3216344:	10000a1e 	bne	r2,zero,3216370 <OSTimeTick+0xa4>
 3216348:	e0ffff17 	ldw	r3,-4(fp)
 321634c:	188000a0 	cmpeqi	r2,r3,2
 3216350:	1000091e 	bne	r2,zero,3216378 <OSTimeTick+0xac>
 3216354:	e0ffff17 	ldw	r3,-4(fp)
 3216358:	1805003a 	cmpeq	r2,r3,zero
 321635c:	1000011e 	bne	r2,zero,3216364 <OSTimeTick+0x98>
 3216360:	00000a06 	br	321638c <OSTimeTick+0xc0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
 3216364:	00800044 	movi	r2,1
 3216368:	e0bffd05 	stb	r2,-12(fp)
                 break;
 321636c:	00000a06 	br	3216398 <OSTimeTick+0xcc>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
 3216370:	e03ffd05 	stb	zero,-12(fp)
                 break;
 3216374:	00000806 	br	3216398 <OSTimeTick+0xcc>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
 3216378:	00800044 	movi	r2,1
 321637c:	e0bffd05 	stb	r2,-12(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
 3216380:	00800044 	movi	r2,1
 3216384:	d0a8a805 	stb	r2,-23904(gp)
                 break;
 3216388:	00000306 	br	3216398 <OSTimeTick+0xcc>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
 321638c:	00800044 	movi	r2,1
 3216390:	e0bffd05 	stb	r2,-12(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
 3216394:	d028a805 	stb	zero,-23904(gp)
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
 3216398:	e0bffd03 	ldbu	r2,-12(fp)
 321639c:	1005003a 	cmpeq	r2,r2,zero
 32163a0:	1000551e 	bne	r2,zero,32164f8 <OSTimeTick+0x22c>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
 32163a4:	d0a8a717 	ldw	r2,-23908(gp)
 32163a8:	e0bffe15 	stw	r2,-8(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 32163ac:	00004d06 	br	32164e4 <OSTimeTick+0x218>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32163b0:	0005303a 	rdctl	r2,status
 32163b4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32163b8:	e0fff917 	ldw	r3,-28(fp)
 32163bc:	00bfff84 	movi	r2,-2
 32163c0:	1884703a 	and	r2,r3,r2
 32163c4:	1001703a 	wrctl	status,r2
  
  return context;
 32163c8:	e0bff917 	ldw	r2,-28(fp)
            OS_ENTER_CRITICAL();
 32163cc:	e0bffc15 	stw	r2,-16(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
 32163d0:	e0bffe17 	ldw	r2,-8(fp)
 32163d4:	10800b8b 	ldhu	r2,46(r2)
 32163d8:	10bfffcc 	andi	r2,r2,65535
 32163dc:	1005003a 	cmpeq	r2,r2,zero
 32163e0:	1000391e 	bne	r2,zero,32164c8 <OSTimeTick+0x1fc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
 32163e4:	e0bffe17 	ldw	r2,-8(fp)
 32163e8:	10800b8b 	ldhu	r2,46(r2)
 32163ec:	10bfffc4 	addi	r2,r2,-1
 32163f0:	1007883a 	mov	r3,r2
 32163f4:	e0bffe17 	ldw	r2,-8(fp)
 32163f8:	10c00b8d 	sth	r3,46(r2)
 32163fc:	e0bffe17 	ldw	r2,-8(fp)
 3216400:	10800b8b 	ldhu	r2,46(r2)
 3216404:	10bfffcc 	andi	r2,r2,65535
 3216408:	1004c03a 	cmpne	r2,r2,zero
 321640c:	10002e1e 	bne	r2,zero,32164c8 <OSTimeTick+0x1fc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 3216410:	e0bffe17 	ldw	r2,-8(fp)
 3216414:	10800c03 	ldbu	r2,48(r2)
 3216418:	10803fcc 	andi	r2,r2,255
 321641c:	10800dcc 	andi	r2,r2,55
 3216420:	1005003a 	cmpeq	r2,r2,zero
 3216424:	10000b1e 	bne	r2,zero,3216454 <OSTimeTick+0x188>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
 3216428:	e0bffe17 	ldw	r2,-8(fp)
 321642c:	10c00c03 	ldbu	r3,48(r2)
 3216430:	00bff204 	movi	r2,-56
 3216434:	1884703a 	and	r2,r3,r2
 3216438:	1007883a 	mov	r3,r2
 321643c:	e0bffe17 	ldw	r2,-8(fp)
 3216440:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
 3216444:	e0fffe17 	ldw	r3,-8(fp)
 3216448:	00800044 	movi	r2,1
 321644c:	18800c45 	stb	r2,49(r3)
 3216450:	00000206 	br	321645c <OSTimeTick+0x190>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 3216454:	e0bffe17 	ldw	r2,-8(fp)
 3216458:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
 321645c:	e0bffe17 	ldw	r2,-8(fp)
 3216460:	10800c03 	ldbu	r2,48(r2)
 3216464:	10803fcc 	andi	r2,r2,255
 3216468:	1080020c 	andi	r2,r2,8
 321646c:	1004c03a 	cmpne	r2,r2,zero
 3216470:	1000151e 	bne	r2,zero,32164c8 <OSTimeTick+0x1fc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
 3216474:	e0bffe17 	ldw	r2,-8(fp)
 3216478:	10c00d83 	ldbu	r3,54(r2)
 321647c:	d0a8b003 	ldbu	r2,-23872(gp)
 3216480:	1884b03a 	or	r2,r3,r2
 3216484:	d0a8b005 	stb	r2,-23872(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 3216488:	e0bffe17 	ldw	r2,-8(fp)
 321648c:	10800d03 	ldbu	r2,52(r2)
 3216490:	11003fcc 	andi	r4,r2,255
 3216494:	e0bffe17 	ldw	r2,-8(fp)
 3216498:	10800d03 	ldbu	r2,52(r2)
 321649c:	10c03fcc 	andi	r3,r2,255
 32164a0:	d0a8b044 	addi	r2,gp,-23871
 32164a4:	1885883a 	add	r2,r3,r2
 32164a8:	10c00003 	ldbu	r3,0(r2)
 32164ac:	e0bffe17 	ldw	r2,-8(fp)
 32164b0:	10800d43 	ldbu	r2,53(r2)
 32164b4:	1884b03a 	or	r2,r3,r2
 32164b8:	1007883a 	mov	r3,r2
 32164bc:	d0a8b044 	addi	r2,gp,-23871
 32164c0:	2085883a 	add	r2,r4,r2
 32164c4:	10c00005 	stb	r3,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
 32164c8:	e0bffe17 	ldw	r2,-8(fp)
 32164cc:	10800517 	ldw	r2,20(r2)
 32164d0:	e0bffe15 	stw	r2,-8(fp)
 32164d4:	e0bffc17 	ldw	r2,-16(fp)
 32164d8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 32164dc:	e0bff817 	ldw	r2,-32(fp)
 32164e0:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 32164e4:	e0bffe17 	ldw	r2,-8(fp)
 32164e8:	10800c83 	ldbu	r2,50(r2)
 32164ec:	10803fcc 	andi	r2,r2,255
 32164f0:	10800518 	cmpnei	r2,r2,20
 32164f4:	103fae1e 	bne	r2,zero,32163b0 <OSTimeTick+0xe4>
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
 32164f8:	e037883a 	mov	sp,fp
 32164fc:	dfc00117 	ldw	ra,4(sp)
 3216500:	df000017 	ldw	fp,0(sp)
 3216504:	dec00204 	addi	sp,sp,8
 3216508:	f800283a 	ret

0321650c <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
 321650c:	deffff04 	addi	sp,sp,-4
 3216510:	df000015 	stw	fp,0(sp)
 3216514:	d839883a 	mov	fp,sp
    return (OS_VERSION);
 3216518:	00804784 	movi	r2,286
}
 321651c:	e037883a 	mov	sp,fp
 3216520:	df000017 	ldw	fp,0(sp)
 3216524:	dec00104 	addi	sp,sp,4
 3216528:	f800283a 	ret

0321652c <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
 321652c:	deffff04 	addi	sp,sp,-4
 3216530:	df000015 	stw	fp,0(sp)
 3216534:	d839883a 	mov	fp,sp
}
 3216538:	e037883a 	mov	sp,fp
 321653c:	df000017 	ldw	fp,0(sp)
 3216540:	dec00104 	addi	sp,sp,4
 3216544:	f800283a 	ret

03216548 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
 3216548:	defff804 	addi	sp,sp,-32
 321654c:	dfc00715 	stw	ra,28(sp)
 3216550:	df000615 	stw	fp,24(sp)
 3216554:	df000604 	addi	fp,sp,24
 3216558:	e13ffc15 	stw	r4,-16(fp)
 321655c:	e17ffd15 	stw	r5,-12(fp)
 3216560:	e1bffe05 	stb	r6,-8(fp)
 3216564:	e1ffff05 	stb	r7,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
 3216568:	e0bffc17 	ldw	r2,-16(fp)
 321656c:	10800283 	ldbu	r2,10(r2)
 3216570:	10c03fcc 	andi	r3,r2,255
 3216574:	0080c974 	movhi	r2,805
 3216578:	10b97a04 	addi	r2,r2,-6680
 321657c:	10c5883a 	add	r2,r2,r3
 3216580:	10800003 	ldbu	r2,0(r2)
 3216584:	e0bffa85 	stb	r2,-22(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
 3216588:	e0fffa83 	ldbu	r3,-22(fp)
 321658c:	e0bffc17 	ldw	r2,-16(fp)
 3216590:	1885883a 	add	r2,r3,r2
 3216594:	10800204 	addi	r2,r2,8
 3216598:	108000c3 	ldbu	r2,3(r2)
 321659c:	10c03fcc 	andi	r3,r2,255
 32165a0:	0080c974 	movhi	r2,805
 32165a4:	10b97a04 	addi	r2,r2,-6680
 32165a8:	10c5883a 	add	r2,r2,r3
 32165ac:	10800003 	ldbu	r2,0(r2)
 32165b0:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
 32165b4:	e0bffa83 	ldbu	r2,-22(fp)
 32165b8:	100490fa 	slli	r2,r2,3
 32165bc:	1007883a 	mov	r3,r2
 32165c0:	e0bffa43 	ldbu	r2,-23(fp)
 32165c4:	1885883a 	add	r2,r3,r2
 32165c8:	e0bffa05 	stb	r2,-24(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
 32165cc:	e0bffa03 	ldbu	r2,-24(fp)
 32165d0:	00c0c9b4 	movhi	r3,806
 32165d4:	18f26b04 	addi	r3,r3,-13908
 32165d8:	1085883a 	add	r2,r2,r2
 32165dc:	1085883a 	add	r2,r2,r2
 32165e0:	10c5883a 	add	r2,r2,r3
 32165e4:	10800017 	ldw	r2,0(r2)
 32165e8:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
 32165ec:	e0bffb17 	ldw	r2,-20(fp)
 32165f0:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
 32165f4:	e0fffb17 	ldw	r3,-20(fp)
 32165f8:	e0bffd17 	ldw	r2,-12(fp)
 32165fc:	18800915 	stw	r2,36(r3)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
 3216600:	e0bffb17 	ldw	r2,-20(fp)
 3216604:	10800c03 	ldbu	r2,48(r2)
 3216608:	1007883a 	mov	r3,r2
 321660c:	e0bffe03 	ldbu	r2,-8(fp)
 3216610:	0084303a 	nor	r2,zero,r2
 3216614:	1884703a 	and	r2,r3,r2
 3216618:	1007883a 	mov	r3,r2
 321661c:	e0bffb17 	ldw	r2,-20(fp)
 3216620:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
 3216624:	e0fffb17 	ldw	r3,-20(fp)
 3216628:	e0bfff03 	ldbu	r2,-4(fp)
 321662c:	18800c45 	stb	r2,49(r3)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
 3216630:	e0bffb17 	ldw	r2,-20(fp)
 3216634:	10800c03 	ldbu	r2,48(r2)
 3216638:	10803fcc 	andi	r2,r2,255
 321663c:	1080020c 	andi	r2,r2,8
 3216640:	1004c03a 	cmpne	r2,r2,zero
 3216644:	1000111e 	bne	r2,zero,321668c <OS_EventTaskRdy+0x144>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
 3216648:	e0bffb17 	ldw	r2,-20(fp)
 321664c:	10c00d83 	ldbu	r3,54(r2)
 3216650:	d0a8b003 	ldbu	r2,-23872(gp)
 3216654:	1884b03a 	or	r2,r3,r2
 3216658:	d0a8b005 	stb	r2,-23872(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
 321665c:	e13ffa83 	ldbu	r4,-22(fp)
 3216660:	e0fffa83 	ldbu	r3,-22(fp)
 3216664:	d0a8b044 	addi	r2,gp,-23871
 3216668:	1885883a 	add	r2,r3,r2
 321666c:	10c00003 	ldbu	r3,0(r2)
 3216670:	e0bffb17 	ldw	r2,-20(fp)
 3216674:	10800d43 	ldbu	r2,53(r2)
 3216678:	1884b03a 	or	r2,r3,r2
 321667c:	1007883a 	mov	r3,r2
 3216680:	d0a8b044 	addi	r2,gp,-23871
 3216684:	2085883a 	add	r2,r4,r2
 3216688:	10c00005 	stb	r3,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
 321668c:	e13ffb17 	ldw	r4,-20(fp)
 3216690:	e17ffc17 	ldw	r5,-16(fp)
 3216694:	32169400 	call	3216940 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
 3216698:	e0bffb17 	ldw	r2,-20(fp)
 321669c:	10800817 	ldw	r2,32(r2)
 32166a0:	1005003a 	cmpeq	r2,r2,zero
 32166a4:	1000071e 	bne	r2,zero,32166c4 <OS_EventTaskRdy+0x17c>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 32166a8:	e0bffb17 	ldw	r2,-20(fp)
 32166ac:	11400817 	ldw	r5,32(r2)
 32166b0:	e13ffb17 	ldw	r4,-20(fp)
 32166b4:	32169f80 	call	32169f8 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
 32166b8:	e0fffb17 	ldw	r3,-20(fp)
 32166bc:	e0bffc17 	ldw	r2,-16(fp)
 32166c0:	18800715 	stw	r2,28(r3)
    }
#endif

    return (prio);
 32166c4:	e0bffa03 	ldbu	r2,-24(fp)
}
 32166c8:	e037883a 	mov	sp,fp
 32166cc:	dfc00117 	ldw	ra,4(sp)
 32166d0:	df000017 	ldw	fp,0(sp)
 32166d4:	dec00204 	addi	sp,sp,8
 32166d8:	f800283a 	ret

032166dc <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
 32166dc:	defffd04 	addi	sp,sp,-12
 32166e0:	df000215 	stw	fp,8(sp)
 32166e4:	df000204 	addi	fp,sp,8
 32166e8:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
 32166ec:	d0e8b317 	ldw	r3,-23860(gp)
 32166f0:	e0bfff17 	ldw	r2,-4(fp)
 32166f4:	18800715 	stw	r2,28(r3)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
 32166f8:	d0a8b317 	ldw	r2,-23860(gp)
 32166fc:	10800d03 	ldbu	r2,52(r2)
 3216700:	11003fcc 	andi	r4,r2,255
 3216704:	d0a8b317 	ldw	r2,-23860(gp)
 3216708:	10800d03 	ldbu	r2,52(r2)
 321670c:	10c03fcc 	andi	r3,r2,255
 3216710:	e0bfff17 	ldw	r2,-4(fp)
 3216714:	1885883a 	add	r2,r3,r2
 3216718:	10800204 	addi	r2,r2,8
 321671c:	10c000c3 	ldbu	r3,3(r2)
 3216720:	d0a8b317 	ldw	r2,-23860(gp)
 3216724:	10800d43 	ldbu	r2,53(r2)
 3216728:	1884b03a 	or	r2,r3,r2
 321672c:	1007883a 	mov	r3,r2
 3216730:	e0bfff17 	ldw	r2,-4(fp)
 3216734:	2085883a 	add	r2,r4,r2
 3216738:	10800204 	addi	r2,r2,8
 321673c:	10c000c5 	stb	r3,3(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 3216740:	e0bfff17 	ldw	r2,-4(fp)
 3216744:	10c00283 	ldbu	r3,10(r2)
 3216748:	d0a8b317 	ldw	r2,-23860(gp)
 321674c:	10800d83 	ldbu	r2,54(r2)
 3216750:	1884b03a 	or	r2,r3,r2
 3216754:	1007883a 	mov	r3,r2
 3216758:	e0bfff17 	ldw	r2,-4(fp)
 321675c:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 3216760:	d0a8b317 	ldw	r2,-23860(gp)
 3216764:	10800d03 	ldbu	r2,52(r2)
 3216768:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 321676c:	e13ffe03 	ldbu	r4,-8(fp)
 3216770:	e0fffe03 	ldbu	r3,-8(fp)
 3216774:	d0a8b044 	addi	r2,gp,-23871
 3216778:	1885883a 	add	r2,r3,r2
 321677c:	10800003 	ldbu	r2,0(r2)
 3216780:	1007883a 	mov	r3,r2
 3216784:	d0a8b317 	ldw	r2,-23860(gp)
 3216788:	10800d43 	ldbu	r2,53(r2)
 321678c:	0084303a 	nor	r2,zero,r2
 3216790:	1884703a 	and	r2,r3,r2
 3216794:	1007883a 	mov	r3,r2
 3216798:	d0a8b044 	addi	r2,gp,-23871
 321679c:	2085883a 	add	r2,r4,r2
 32167a0:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 32167a4:	e0fffe03 	ldbu	r3,-8(fp)
 32167a8:	d0a8b044 	addi	r2,gp,-23871
 32167ac:	1885883a 	add	r2,r3,r2
 32167b0:	10800003 	ldbu	r2,0(r2)
 32167b4:	10803fcc 	andi	r2,r2,255
 32167b8:	1004c03a 	cmpne	r2,r2,zero
 32167bc:	1000071e 	bne	r2,zero,32167dc <OS_EventTaskWait+0x100>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 32167c0:	d0a8b317 	ldw	r2,-23860(gp)
 32167c4:	10800d83 	ldbu	r2,54(r2)
 32167c8:	0084303a 	nor	r2,zero,r2
 32167cc:	1007883a 	mov	r3,r2
 32167d0:	d0a8b003 	ldbu	r2,-23872(gp)
 32167d4:	1884703a 	and	r2,r3,r2
 32167d8:	d0a8b005 	stb	r2,-23872(gp)
    }
}
 32167dc:	e037883a 	mov	sp,fp
 32167e0:	df000017 	ldw	fp,0(sp)
 32167e4:	dec00104 	addi	sp,sp,4
 32167e8:	f800283a 	ret

032167ec <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
 32167ec:	defffb04 	addi	sp,sp,-20
 32167f0:	df000415 	stw	fp,16(sp)
 32167f4:	df000404 	addi	fp,sp,16
 32167f8:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
 32167fc:	d0a8b317 	ldw	r2,-23860(gp)
 3216800:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
 3216804:	d0e8b317 	ldw	r3,-23860(gp)
 3216808:	e0bfff17 	ldw	r2,-4(fp)
 321680c:	18800815 	stw	r2,32(r3)

    pevents =  pevents_wait;
 3216810:	e0bfff17 	ldw	r2,-4(fp)
 3216814:	e0bffe15 	stw	r2,-8(fp)
    pevent  = *pevents;
 3216818:	e0bffe17 	ldw	r2,-8(fp)
 321681c:	10800017 	ldw	r2,0(r2)
 3216820:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 3216824:	00002006 	br	32168a8 <OS_EventTaskWaitMulti+0xbc>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
 3216828:	d0a8b317 	ldw	r2,-23860(gp)
 321682c:	10800d03 	ldbu	r2,52(r2)
 3216830:	11003fcc 	andi	r4,r2,255
 3216834:	d0a8b317 	ldw	r2,-23860(gp)
 3216838:	10800d03 	ldbu	r2,52(r2)
 321683c:	10c03fcc 	andi	r3,r2,255
 3216840:	e0bffd17 	ldw	r2,-12(fp)
 3216844:	1885883a 	add	r2,r3,r2
 3216848:	10800204 	addi	r2,r2,8
 321684c:	10c000c3 	ldbu	r3,3(r2)
 3216850:	d0a8b317 	ldw	r2,-23860(gp)
 3216854:	10800d43 	ldbu	r2,53(r2)
 3216858:	1884b03a 	or	r2,r3,r2
 321685c:	1007883a 	mov	r3,r2
 3216860:	e0bffd17 	ldw	r2,-12(fp)
 3216864:	2085883a 	add	r2,r4,r2
 3216868:	10800204 	addi	r2,r2,8
 321686c:	10c000c5 	stb	r3,3(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 3216870:	e0bffd17 	ldw	r2,-12(fp)
 3216874:	10c00283 	ldbu	r3,10(r2)
 3216878:	d0a8b317 	ldw	r2,-23860(gp)
 321687c:	10800d83 	ldbu	r2,54(r2)
 3216880:	1884b03a 	or	r2,r3,r2
 3216884:	1007883a 	mov	r3,r2
 3216888:	e0bffd17 	ldw	r2,-12(fp)
 321688c:	10c00285 	stb	r3,10(r2)
        pevents++;
 3216890:	e0bffe17 	ldw	r2,-8(fp)
 3216894:	10800104 	addi	r2,r2,4
 3216898:	e0bffe15 	stw	r2,-8(fp)
        pevent = *pevents;
 321689c:	e0bffe17 	ldw	r2,-8(fp)
 32168a0:	10800017 	ldw	r2,0(r2)
 32168a4:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 32168a8:	e0bffd17 	ldw	r2,-12(fp)
 32168ac:	1004c03a 	cmpne	r2,r2,zero
 32168b0:	103fdd1e 	bne	r2,zero,3216828 <OS_EventTaskWaitMulti+0x3c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 32168b4:	d0a8b317 	ldw	r2,-23860(gp)
 32168b8:	10800d03 	ldbu	r2,52(r2)
 32168bc:	e0bffc05 	stb	r2,-16(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 32168c0:	e13ffc03 	ldbu	r4,-16(fp)
 32168c4:	e0fffc03 	ldbu	r3,-16(fp)
 32168c8:	d0a8b044 	addi	r2,gp,-23871
 32168cc:	1885883a 	add	r2,r3,r2
 32168d0:	10800003 	ldbu	r2,0(r2)
 32168d4:	1007883a 	mov	r3,r2
 32168d8:	d0a8b317 	ldw	r2,-23860(gp)
 32168dc:	10800d43 	ldbu	r2,53(r2)
 32168e0:	0084303a 	nor	r2,zero,r2
 32168e4:	1884703a 	and	r2,r3,r2
 32168e8:	1007883a 	mov	r3,r2
 32168ec:	d0a8b044 	addi	r2,gp,-23871
 32168f0:	2085883a 	add	r2,r4,r2
 32168f4:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 32168f8:	e0fffc03 	ldbu	r3,-16(fp)
 32168fc:	d0a8b044 	addi	r2,gp,-23871
 3216900:	1885883a 	add	r2,r3,r2
 3216904:	10800003 	ldbu	r2,0(r2)
 3216908:	10803fcc 	andi	r2,r2,255
 321690c:	1004c03a 	cmpne	r2,r2,zero
 3216910:	1000071e 	bne	r2,zero,3216930 <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 3216914:	d0a8b317 	ldw	r2,-23860(gp)
 3216918:	10800d83 	ldbu	r2,54(r2)
 321691c:	0084303a 	nor	r2,zero,r2
 3216920:	1007883a 	mov	r3,r2
 3216924:	d0a8b003 	ldbu	r2,-23872(gp)
 3216928:	1884703a 	and	r2,r3,r2
 321692c:	d0a8b005 	stb	r2,-23872(gp)
    }
}
 3216930:	e037883a 	mov	sp,fp
 3216934:	df000017 	ldw	fp,0(sp)
 3216938:	dec00104 	addi	sp,sp,4
 321693c:	f800283a 	ret

03216940 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
 3216940:	defffc04 	addi	sp,sp,-16
 3216944:	df000315 	stw	fp,12(sp)
 3216948:	df000304 	addi	fp,sp,12
 321694c:	e13ffe15 	stw	r4,-8(fp)
 3216950:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
 3216954:	e0bffe17 	ldw	r2,-8(fp)
 3216958:	10800d03 	ldbu	r2,52(r2)
 321695c:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
 3216960:	e13ffd03 	ldbu	r4,-12(fp)
 3216964:	e0fffd03 	ldbu	r3,-12(fp)
 3216968:	e0bfff17 	ldw	r2,-4(fp)
 321696c:	1885883a 	add	r2,r3,r2
 3216970:	10800204 	addi	r2,r2,8
 3216974:	108000c3 	ldbu	r2,3(r2)
 3216978:	1007883a 	mov	r3,r2
 321697c:	e0bffe17 	ldw	r2,-8(fp)
 3216980:	10800d43 	ldbu	r2,53(r2)
 3216984:	0084303a 	nor	r2,zero,r2
 3216988:	1884703a 	and	r2,r3,r2
 321698c:	1007883a 	mov	r3,r2
 3216990:	e0bfff17 	ldw	r2,-4(fp)
 3216994:	2085883a 	add	r2,r4,r2
 3216998:	10800204 	addi	r2,r2,8
 321699c:	10c000c5 	stb	r3,3(r2)
    if (pevent->OSEventTbl[y] == 0) {
 32169a0:	e0fffd03 	ldbu	r3,-12(fp)
 32169a4:	e0bfff17 	ldw	r2,-4(fp)
 32169a8:	1885883a 	add	r2,r3,r2
 32169ac:	10800204 	addi	r2,r2,8
 32169b0:	108000c3 	ldbu	r2,3(r2)
 32169b4:	10803fcc 	andi	r2,r2,255
 32169b8:	1004c03a 	cmpne	r2,r2,zero
 32169bc:	10000a1e 	bne	r2,zero,32169e8 <OS_EventTaskRemove+0xa8>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
 32169c0:	e0bfff17 	ldw	r2,-4(fp)
 32169c4:	10800283 	ldbu	r2,10(r2)
 32169c8:	1007883a 	mov	r3,r2
 32169cc:	e0bffe17 	ldw	r2,-8(fp)
 32169d0:	10800d83 	ldbu	r2,54(r2)
 32169d4:	0084303a 	nor	r2,zero,r2
 32169d8:	1884703a 	and	r2,r3,r2
 32169dc:	1007883a 	mov	r3,r2
 32169e0:	e0bfff17 	ldw	r2,-4(fp)
 32169e4:	10c00285 	stb	r3,10(r2)
    }
}
 32169e8:	e037883a 	mov	sp,fp
 32169ec:	df000017 	ldw	fp,0(sp)
 32169f0:	dec00104 	addi	sp,sp,4
 32169f4:	f800283a 	ret

032169f8 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
 32169f8:	defffa04 	addi	sp,sp,-24
 32169fc:	df000515 	stw	fp,20(sp)
 3216a00:	df000504 	addi	fp,sp,20
 3216a04:	e13ffe15 	stw	r4,-8(fp)
 3216a08:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
 3216a0c:	e0bffe17 	ldw	r2,-8(fp)
 3216a10:	10800d03 	ldbu	r2,52(r2)
 3216a14:	e0bffb85 	stb	r2,-18(fp)
    bity    =  ptcb->OSTCBBitY;
 3216a18:	e0bffe17 	ldw	r2,-8(fp)
 3216a1c:	10800d83 	ldbu	r2,54(r2)
 3216a20:	e0bffb45 	stb	r2,-19(fp)
    bitx    =  ptcb->OSTCBBitX;
 3216a24:	e0bffe17 	ldw	r2,-8(fp)
 3216a28:	10800d43 	ldbu	r2,53(r2)
 3216a2c:	e0bffb05 	stb	r2,-20(fp)
    pevents =  pevents_multi;
 3216a30:	e0bfff17 	ldw	r2,-4(fp)
 3216a34:	e0bffd15 	stw	r2,-12(fp)
    pevent  = *pevents;
 3216a38:	e0bffd17 	ldw	r2,-12(fp)
 3216a3c:	10800017 	ldw	r2,0(r2)
 3216a40:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 3216a44:	00002606 	br	3216ae0 <OS_EventTaskRemoveMulti+0xe8>
        pevent->OSEventTbl[y]  &= ~bitx;
 3216a48:	e13ffb83 	ldbu	r4,-18(fp)
 3216a4c:	e0fffb83 	ldbu	r3,-18(fp)
 3216a50:	e0bffc17 	ldw	r2,-16(fp)
 3216a54:	1885883a 	add	r2,r3,r2
 3216a58:	10800204 	addi	r2,r2,8
 3216a5c:	108000c3 	ldbu	r2,3(r2)
 3216a60:	1007883a 	mov	r3,r2
 3216a64:	e0bffb03 	ldbu	r2,-20(fp)
 3216a68:	0084303a 	nor	r2,zero,r2
 3216a6c:	1884703a 	and	r2,r3,r2
 3216a70:	1007883a 	mov	r3,r2
 3216a74:	e0bffc17 	ldw	r2,-16(fp)
 3216a78:	2085883a 	add	r2,r4,r2
 3216a7c:	10800204 	addi	r2,r2,8
 3216a80:	10c000c5 	stb	r3,3(r2)
        if (pevent->OSEventTbl[y] == 0) {
 3216a84:	e0fffb83 	ldbu	r3,-18(fp)
 3216a88:	e0bffc17 	ldw	r2,-16(fp)
 3216a8c:	1885883a 	add	r2,r3,r2
 3216a90:	10800204 	addi	r2,r2,8
 3216a94:	108000c3 	ldbu	r2,3(r2)
 3216a98:	10803fcc 	andi	r2,r2,255
 3216a9c:	1004c03a 	cmpne	r2,r2,zero
 3216aa0:	1000091e 	bne	r2,zero,3216ac8 <OS_EventTaskRemoveMulti+0xd0>
            pevent->OSEventGrp &= ~bity;
 3216aa4:	e0bffc17 	ldw	r2,-16(fp)
 3216aa8:	10800283 	ldbu	r2,10(r2)
 3216aac:	1007883a 	mov	r3,r2
 3216ab0:	e0bffb43 	ldbu	r2,-19(fp)
 3216ab4:	0084303a 	nor	r2,zero,r2
 3216ab8:	1884703a 	and	r2,r3,r2
 3216abc:	1007883a 	mov	r3,r2
 3216ac0:	e0bffc17 	ldw	r2,-16(fp)
 3216ac4:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
 3216ac8:	e0bffd17 	ldw	r2,-12(fp)
 3216acc:	10800104 	addi	r2,r2,4
 3216ad0:	e0bffd15 	stw	r2,-12(fp)
        pevent = *pevents;
 3216ad4:	e0bffd17 	ldw	r2,-12(fp)
 3216ad8:	10800017 	ldw	r2,0(r2)
 3216adc:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 3216ae0:	e0bffc17 	ldw	r2,-16(fp)
 3216ae4:	1004c03a 	cmpne	r2,r2,zero
 3216ae8:	103fd71e 	bne	r2,zero,3216a48 <OS_EventTaskRemoveMulti+0x50>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
 3216aec:	e037883a 	mov	sp,fp
 3216af0:	df000017 	ldw	fp,0(sp)
 3216af4:	dec00104 	addi	sp,sp,4
 3216af8:	f800283a 	ret

03216afc <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
 3216afc:	defffc04 	addi	sp,sp,-16
 3216b00:	df000315 	stw	fp,12(sp)
 3216b04:	df000304 	addi	fp,sp,12
 3216b08:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
 3216b0c:	e0bfff17 	ldw	r2,-4(fp)
 3216b10:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
 3216b14:	e0bfff17 	ldw	r2,-4(fp)
 3216b18:	108002c4 	addi	r2,r2,11
 3216b1c:	e0bffe15 	stw	r2,-8(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 3216b20:	e03ffd05 	stb	zero,-12(fp)
 3216b24:	00000806 	br	3216b48 <OS_EventWaitListInit+0x4c>
        *ptbl++ = 0;
 3216b28:	e0bffe17 	ldw	r2,-8(fp)
 3216b2c:	10000005 	stb	zero,0(r2)
 3216b30:	e0bffe17 	ldw	r2,-8(fp)
 3216b34:	10800044 	addi	r2,r2,1
 3216b38:	e0bffe15 	stw	r2,-8(fp)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 3216b3c:	e0bffd03 	ldbu	r2,-12(fp)
 3216b40:	10800044 	addi	r2,r2,1
 3216b44:	e0bffd05 	stb	r2,-12(fp)
 3216b48:	e0bffd03 	ldbu	r2,-12(fp)
 3216b4c:	108000f0 	cmpltui	r2,r2,3
 3216b50:	103ff51e 	bne	r2,zero,3216b28 <OS_EventWaitListInit+0x2c>
        *ptbl++ = 0;
    }
}
 3216b54:	e037883a 	mov	sp,fp
 3216b58:	df000017 	ldw	fp,0(sp)
 3216b5c:	dec00104 	addi	sp,sp,4
 3216b60:	f800283a 	ret

03216b64 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
 3216b64:	defffb04 	addi	sp,sp,-20
 3216b68:	dfc00415 	stw	ra,16(sp)
 3216b6c:	df000315 	stw	fp,12(sp)
 3216b70:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
 3216b74:	0100c9b4 	movhi	r4,806
 3216b78:	212e5704 	addi	r4,r4,-18084
 3216b7c:	0142d004 	movi	r5,2880
 3216b80:	3216ec80 	call	3216ec8 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
 3216b84:	0080c9b4 	movhi	r2,806
 3216b88:	10ae5704 	addi	r2,r2,-18084
 3216b8c:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
 3216b90:	0080c9b4 	movhi	r2,806
 3216b94:	10ae6304 	addi	r2,r2,-18036
 3216b98:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 3216b9c:	e03fff0d 	sth	zero,-4(fp)
 3216ba0:	00001306 	br	3216bf0 <OS_InitEventList+0x8c>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
 3216ba4:	e0bffe17 	ldw	r2,-8(fp)
 3216ba8:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
 3216bac:	e0fffe17 	ldw	r3,-8(fp)
 3216bb0:	e0bffd17 	ldw	r2,-12(fp)
 3216bb4:	18800115 	stw	r2,4(r3)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
 3216bb8:	e0fffe17 	ldw	r3,-8(fp)
 3216bbc:	00800fc4 	movi	r2,63
 3216bc0:	18800385 	stb	r2,14(r3)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
 3216bc4:	e0bffe17 	ldw	r2,-8(fp)
 3216bc8:	100003c5 	stb	zero,15(r2)
#endif
        pevent1++;
 3216bcc:	e0bffe17 	ldw	r2,-8(fp)
 3216bd0:	10800c04 	addi	r2,r2,48
 3216bd4:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
 3216bd8:	e0bffd17 	ldw	r2,-12(fp)
 3216bdc:	10800c04 	addi	r2,r2,48
 3216be0:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 3216be4:	e0bfff0b 	ldhu	r2,-4(fp)
 3216be8:	10800044 	addi	r2,r2,1
 3216bec:	e0bfff0d 	sth	r2,-4(fp)
 3216bf0:	e0bfff0b 	ldhu	r2,-4(fp)
 3216bf4:	10800ef0 	cmpltui	r2,r2,59
 3216bf8:	103fea1e 	bne	r2,zero,3216ba4 <OS_InitEventList+0x40>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
 3216bfc:	e0bffe17 	ldw	r2,-8(fp)
 3216c00:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
 3216c04:	e0bffe17 	ldw	r2,-8(fp)
 3216c08:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
 3216c0c:	e0fffe17 	ldw	r3,-8(fp)
 3216c10:	00800fc4 	movi	r2,63
 3216c14:	18800385 	stb	r2,14(r3)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
 3216c18:	e0bffe17 	ldw	r2,-8(fp)
 3216c1c:	100003c5 	stb	zero,15(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
 3216c20:	0080c9b4 	movhi	r2,806
 3216c24:	10ae5704 	addi	r2,r2,-18084
 3216c28:	d0a8b115 	stw	r2,-23868(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
 3216c2c:	e037883a 	mov	sp,fp
 3216c30:	dfc00117 	ldw	ra,4(sp)
 3216c34:	df000017 	ldw	fp,0(sp)
 3216c38:	dec00204 	addi	sp,sp,8
 3216c3c:	f800283a 	ret

03216c40 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
 3216c40:	deffff04 	addi	sp,sp,-4
 3216c44:	df000015 	stw	fp,0(sp)
 3216c48:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
 3216c4c:	d028b415 	stw	zero,-23856(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
 3216c50:	d028b205 	stb	zero,-23864(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
 3216c54:	d028a405 	stb	zero,-23920(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
 3216c58:	d028ac45 	stb	zero,-23887(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
 3216c5c:	d028a445 	stb	zero,-23919(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
 3216c60:	d028a915 	stw	zero,-23900(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
 3216c64:	d028a515 	stw	zero,-23916(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
 3216c68:	d028b715 	stw	zero,-23844(gp)
    OSIdleCtrMax  = 0L;
 3216c6c:	d028aa15 	stw	zero,-23896(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
 3216c70:	d028b605 	stb	zero,-23848(gp)
#endif
}
 3216c74:	e037883a 	mov	sp,fp
 3216c78:	df000017 	ldw	fp,0(sp)
 3216c7c:	dec00104 	addi	sp,sp,4
 3216c80:	f800283a 	ret

03216c84 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
 3216c84:	defffd04 	addi	sp,sp,-12
 3216c88:	df000215 	stw	fp,8(sp)
 3216c8c:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
 3216c90:	d028b005 	stb	zero,-23872(gp)
    prdytbl       = &OSRdyTbl[0];
 3216c94:	d0a8b044 	addi	r2,gp,-23871
 3216c98:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 3216c9c:	e03fff05 	stb	zero,-4(fp)
 3216ca0:	00000806 	br	3216cc4 <OS_InitRdyList+0x40>
        *prdytbl++ = 0;
 3216ca4:	e0bffe17 	ldw	r2,-8(fp)
 3216ca8:	10000005 	stb	zero,0(r2)
 3216cac:	e0bffe17 	ldw	r2,-8(fp)
 3216cb0:	10800044 	addi	r2,r2,1
 3216cb4:	e0bffe15 	stw	r2,-8(fp)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 3216cb8:	e0bfff03 	ldbu	r2,-4(fp)
 3216cbc:	10800044 	addi	r2,r2,1
 3216cc0:	e0bfff05 	stb	r2,-4(fp)
 3216cc4:	e0bfff03 	ldbu	r2,-4(fp)
 3216cc8:	108000f0 	cmpltui	r2,r2,3
 3216ccc:	103ff51e 	bne	r2,zero,3216ca4 <OS_InitRdyList+0x20>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
 3216cd0:	d028a645 	stb	zero,-23911(gp)
    OSPrioHighRdy = 0;
 3216cd4:	d028a605 	stb	zero,-23912(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
 3216cd8:	d028ae15 	stw	zero,-23880(gp)
    OSTCBCur      = (OS_TCB *)0;
 3216cdc:	d028b315 	stw	zero,-23860(gp)
}
 3216ce0:	e037883a 	mov	sp,fp
 3216ce4:	df000017 	ldw	fp,0(sp)
 3216ce8:	dec00104 	addi	sp,sp,4
 3216cec:	f800283a 	ret

03216cf0 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
 3216cf0:	defff804 	addi	sp,sp,-32
 3216cf4:	dfc00715 	stw	ra,28(sp)
 3216cf8:	df000615 	stw	fp,24(sp)
 3216cfc:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
 3216d00:	0180c9b4 	movhi	r6,806
 3216d04:	31ae5604 	addi	r6,r6,-18088
 3216d08:	00bfffd4 	movui	r2,65535
 3216d0c:	d8800015 	stw	r2,0(sp)
 3216d10:	0080c9b4 	movhi	r2,806
 3216d14:	10ac5704 	addi	r2,r2,-20132
 3216d18:	d8800115 	stw	r2,4(sp)
 3216d1c:	00808004 	movi	r2,512
 3216d20:	d8800215 	stw	r2,8(sp)
 3216d24:	d8000315 	stw	zero,12(sp)
 3216d28:	008000c4 	movi	r2,3
 3216d2c:	d8800415 	stw	r2,16(sp)
 3216d30:	0100c874 	movhi	r4,801
 3216d34:	211c6904 	addi	r4,r4,29092
 3216d38:	000b883a 	mov	r5,zero
 3216d3c:	01c00504 	movi	r7,20
 3216d40:	321bf840 	call	321bf84 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
 3216d44:	0140c974 	movhi	r5,805
 3216d48:	2979ba04 	addi	r5,r5,-6424
 3216d4c:	01000504 	movi	r4,20
 3216d50:	e1bfff04 	addi	r6,fp,-4
 3216d54:	321c8b80 	call	321c8b8 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
 3216d58:	e037883a 	mov	sp,fp
 3216d5c:	dfc00117 	ldw	ra,4(sp)
 3216d60:	df000017 	ldw	fp,0(sp)
 3216d64:	dec00204 	addi	sp,sp,8
 3216d68:	f800283a 	ret

03216d6c <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
 3216d6c:	defff804 	addi	sp,sp,-32
 3216d70:	dfc00715 	stw	ra,28(sp)
 3216d74:	df000615 	stw	fp,24(sp)
 3216d78:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
 3216d7c:	0180c9b4 	movhi	r6,806
 3216d80:	31abde04 	addi	r6,r6,-20616
 3216d84:	00bfff94 	movui	r2,65534
 3216d88:	d8800015 	stw	r2,0(sp)
 3216d8c:	0080c9b4 	movhi	r2,806
 3216d90:	10a9df04 	addi	r2,r2,-22660
 3216d94:	d8800115 	stw	r2,4(sp)
 3216d98:	00808004 	movi	r2,512
 3216d9c:	d8800215 	stw	r2,8(sp)
 3216da0:	d8000315 	stw	zero,12(sp)
 3216da4:	008000c4 	movi	r2,3
 3216da8:	d8800415 	stw	r2,16(sp)
 3216dac:	0100c874 	movhi	r4,801
 3216db0:	211c8004 	addi	r4,r4,29184
 3216db4:	000b883a 	mov	r5,zero
 3216db8:	01c004c4 	movi	r7,19
 3216dbc:	321bf840 	call	321bf84 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
 3216dc0:	0140c974 	movhi	r5,805
 3216dc4:	2979be04 	addi	r5,r5,-6408
 3216dc8:	010004c4 	movi	r4,19
 3216dcc:	e1bfff04 	addi	r6,fp,-4
 3216dd0:	321c8b80 	call	321c8b8 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
 3216dd4:	e037883a 	mov	sp,fp
 3216dd8:	dfc00117 	ldw	ra,4(sp)
 3216ddc:	df000017 	ldw	fp,0(sp)
 3216de0:	dec00204 	addi	sp,sp,8
 3216de4:	f800283a 	ret

03216de8 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
 3216de8:	defffb04 	addi	sp,sp,-20
 3216dec:	dfc00415 	stw	ra,16(sp)
 3216df0:	df000315 	stw	fp,12(sp)
 3216df4:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
 3216df8:	0100c9b4 	movhi	r4,806
 3216dfc:	21312704 	addi	r4,r4,-15204
 3216e00:	01414404 	movi	r5,1296
 3216e04:	3216ec80 	call	3216ec8 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
 3216e08:	0100c9b4 	movhi	r4,806
 3216e0c:	21326b04 	addi	r4,r4,-13908
 3216e10:	01401504 	movi	r5,84
 3216e14:	3216ec80 	call	3216ec8 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
 3216e18:	0080c9b4 	movhi	r2,806
 3216e1c:	10b12704 	addi	r2,r2,-15204
 3216e20:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
 3216e24:	0080c9b4 	movhi	r2,806
 3216e28:	10b14204 	addi	r2,r2,-15096
 3216e2c:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 3216e30:	e03fff05 	stb	zero,-4(fp)
 3216e34:	00001106 	br	3216e7c <OS_InitTCBList+0x94>
        ptcb1->OSTCBNext = ptcb2;
 3216e38:	e0fffe17 	ldw	r3,-8(fp)
 3216e3c:	e0bffd17 	ldw	r2,-12(fp)
 3216e40:	18800515 	stw	r2,20(r3)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
 3216e44:	e0fffe17 	ldw	r3,-8(fp)
 3216e48:	00800fc4 	movi	r2,63
 3216e4c:	18801305 	stb	r2,76(r3)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 3216e50:	e0bffe17 	ldw	r2,-8(fp)
 3216e54:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
 3216e58:	e0bffe17 	ldw	r2,-8(fp)
 3216e5c:	10801b04 	addi	r2,r2,108
 3216e60:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
 3216e64:	e0bffd17 	ldw	r2,-12(fp)
 3216e68:	10801b04 	addi	r2,r2,108
 3216e6c:	e0bffd15 	stw	r2,-12(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 3216e70:	e0bfff03 	ldbu	r2,-4(fp)
 3216e74:	10800044 	addi	r2,r2,1
 3216e78:	e0bfff05 	stb	r2,-4(fp)
 3216e7c:	e0bfff03 	ldbu	r2,-4(fp)
 3216e80:	108002f0 	cmpltui	r2,r2,11
 3216e84:	103fec1e 	bne	r2,zero,3216e38 <OS_InitTCBList+0x50>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
 3216e88:	e0bffe17 	ldw	r2,-8(fp)
 3216e8c:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
 3216e90:	e0fffe17 	ldw	r3,-8(fp)
 3216e94:	00800fc4 	movi	r2,63
 3216e98:	18801305 	stb	r2,76(r3)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 3216e9c:	e0bffe17 	ldw	r2,-8(fp)
 3216ea0:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
 3216ea4:	d028a715 	stw	zero,-23908(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
 3216ea8:	0080c9b4 	movhi	r2,806
 3216eac:	10b12704 	addi	r2,r2,-15204
 3216eb0:	d0a8ab15 	stw	r2,-23892(gp)
}
 3216eb4:	e037883a 	mov	sp,fp
 3216eb8:	dfc00117 	ldw	ra,4(sp)
 3216ebc:	df000017 	ldw	fp,0(sp)
 3216ec0:	dec00204 	addi	sp,sp,8
 3216ec4:	f800283a 	ret

03216ec8 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
 3216ec8:	defffd04 	addi	sp,sp,-12
 3216ecc:	df000215 	stw	fp,8(sp)
 3216ed0:	df000204 	addi	fp,sp,8
 3216ed4:	e13ffe15 	stw	r4,-8(fp)
 3216ed8:	e17fff0d 	sth	r5,-4(fp)
    while (size > 0) {
 3216edc:	00000806 	br	3216f00 <OS_MemClr+0x38>
        *pdest++ = (INT8U)0;
 3216ee0:	e0bffe17 	ldw	r2,-8(fp)
 3216ee4:	10000005 	stb	zero,0(r2)
 3216ee8:	e0bffe17 	ldw	r2,-8(fp)
 3216eec:	10800044 	addi	r2,r2,1
 3216ef0:	e0bffe15 	stw	r2,-8(fp)
        size--;
 3216ef4:	e0bfff0b 	ldhu	r2,-4(fp)
 3216ef8:	10bfffc4 	addi	r2,r2,-1
 3216efc:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
 3216f00:	e0bfff0b 	ldhu	r2,-4(fp)
 3216f04:	1004c03a 	cmpne	r2,r2,zero
 3216f08:	103ff51e 	bne	r2,zero,3216ee0 <OS_MemClr+0x18>
        *pdest++ = (INT8U)0;
        size--;
    }
}
 3216f0c:	e037883a 	mov	sp,fp
 3216f10:	df000017 	ldw	fp,0(sp)
 3216f14:	dec00104 	addi	sp,sp,4
 3216f18:	f800283a 	ret

03216f1c <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
 3216f1c:	defffc04 	addi	sp,sp,-16
 3216f20:	df000315 	stw	fp,12(sp)
 3216f24:	df000304 	addi	fp,sp,12
 3216f28:	e13ffd15 	stw	r4,-12(fp)
 3216f2c:	e17ffe15 	stw	r5,-8(fp)
 3216f30:	e1bfff0d 	sth	r6,-4(fp)
    while (size > 0) {
 3216f34:	00000d06 	br	3216f6c <OS_MemCopy+0x50>
        *pdest++ = *psrc++;
 3216f38:	e0bffe17 	ldw	r2,-8(fp)
 3216f3c:	10c00003 	ldbu	r3,0(r2)
 3216f40:	e0bffd17 	ldw	r2,-12(fp)
 3216f44:	10c00005 	stb	r3,0(r2)
 3216f48:	e0bffd17 	ldw	r2,-12(fp)
 3216f4c:	10800044 	addi	r2,r2,1
 3216f50:	e0bffd15 	stw	r2,-12(fp)
 3216f54:	e0bffe17 	ldw	r2,-8(fp)
 3216f58:	10800044 	addi	r2,r2,1
 3216f5c:	e0bffe15 	stw	r2,-8(fp)
        size--;
 3216f60:	e0bfff0b 	ldhu	r2,-4(fp)
 3216f64:	10bfffc4 	addi	r2,r2,-1
 3216f68:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
 3216f6c:	e0bfff0b 	ldhu	r2,-4(fp)
 3216f70:	1004c03a 	cmpne	r2,r2,zero
 3216f74:	103ff01e 	bne	r2,zero,3216f38 <OS_MemCopy+0x1c>
        *pdest++ = *psrc++;
        size--;
    }
}
 3216f78:	e037883a 	mov	sp,fp
 3216f7c:	df000017 	ldw	fp,0(sp)
 3216f80:	dec00104 	addi	sp,sp,4
 3216f84:	f800283a 	ret

03216f88 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
 3216f88:	defffb04 	addi	sp,sp,-20
 3216f8c:	dfc00415 	stw	ra,16(sp)
 3216f90:	df000315 	stw	fp,12(sp)
 3216f94:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 3216f98:	e03fff15 	stw	zero,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3216f9c:	0005303a 	rdctl	r2,status
 3216fa0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3216fa4:	e0fffe17 	ldw	r3,-8(fp)
 3216fa8:	00bfff84 	movi	r2,-2
 3216fac:	1884703a 	and	r2,r3,r2
 3216fb0:	1001703a 	wrctl	status,r2
  
  return context;
 3216fb4:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 3216fb8:	e0bfff15 	stw	r2,-4(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
 3216fbc:	d0a8b203 	ldbu	r2,-23864(gp)
 3216fc0:	10803fcc 	andi	r2,r2,255
 3216fc4:	1004c03a 	cmpne	r2,r2,zero
 3216fc8:	10001b1e 	bne	r2,zero,3217038 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
 3216fcc:	d0a8a403 	ldbu	r2,-23920(gp)
 3216fd0:	10803fcc 	andi	r2,r2,255
 3216fd4:	1004c03a 	cmpne	r2,r2,zero
 3216fd8:	1000171e 	bne	r2,zero,3217038 <OS_Sched+0xb0>
            OS_SchedNew();
 3216fdc:	321705c0 	call	321705c <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
 3216fe0:	d0a8a603 	ldbu	r2,-23912(gp)
 3216fe4:	d0e8a643 	ldbu	r3,-23911(gp)
 3216fe8:	11003fcc 	andi	r4,r2,255
 3216fec:	18803fcc 	andi	r2,r3,255
 3216ff0:	20801126 	beq	r4,r2,3217038 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
 3216ff4:	d0a8a603 	ldbu	r2,-23912(gp)
 3216ff8:	10803fcc 	andi	r2,r2,255
 3216ffc:	00c0c9b4 	movhi	r3,806
 3217000:	18f26b04 	addi	r3,r3,-13908
 3217004:	1085883a 	add	r2,r2,r2
 3217008:	1085883a 	add	r2,r2,r2
 321700c:	10c5883a 	add	r2,r2,r3
 3217010:	10800017 	ldw	r2,0(r2)
 3217014:	d0a8ae15 	stw	r2,-23880(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
 3217018:	d0e8ae17 	ldw	r3,-23880(gp)
 321701c:	18800e17 	ldw	r2,56(r3)
 3217020:	10800044 	addi	r2,r2,1
 3217024:	18800e15 	stw	r2,56(r3)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
 3217028:	d0a8a917 	ldw	r2,-23900(gp)
 321702c:	10800044 	addi	r2,r2,1
 3217030:	d0a8a915 	stw	r2,-23900(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
 3217034:	323b4840 	call	323b484 <OSCtxSw>
 3217038:	e0bfff17 	ldw	r2,-4(fp)
 321703c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3217040:	e0bffd17 	ldw	r2,-12(fp)
 3217044:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
 3217048:	e037883a 	mov	sp,fp
 321704c:	dfc00117 	ldw	ra,4(sp)
 3217050:	df000017 	ldw	fp,0(sp)
 3217054:	dec00204 	addi	sp,sp,8
 3217058:	f800283a 	ret

0321705c <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
 321705c:	defffe04 	addi	sp,sp,-8
 3217060:	df000115 	stw	fp,4(sp)
 3217064:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
 3217068:	d0a8b003 	ldbu	r2,-23872(gp)
 321706c:	10c03fcc 	andi	r3,r2,255
 3217070:	0080c974 	movhi	r2,805
 3217074:	10b97a04 	addi	r2,r2,-6680
 3217078:	10c5883a 	add	r2,r2,r3
 321707c:	10800003 	ldbu	r2,0(r2)
 3217080:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
 3217084:	e0bfff03 	ldbu	r2,-4(fp)
 3217088:	100490fa 	slli	r2,r2,3
 321708c:	1009883a 	mov	r4,r2
 3217090:	e0ffff03 	ldbu	r3,-4(fp)
 3217094:	d0a8b044 	addi	r2,gp,-23871
 3217098:	1885883a 	add	r2,r3,r2
 321709c:	10800003 	ldbu	r2,0(r2)
 32170a0:	10c03fcc 	andi	r3,r2,255
 32170a4:	0080c974 	movhi	r2,805
 32170a8:	10b97a04 	addi	r2,r2,-6680
 32170ac:	10c5883a 	add	r2,r2,r3
 32170b0:	10800003 	ldbu	r2,0(r2)
 32170b4:	2085883a 	add	r2,r4,r2
 32170b8:	d0a8a605 	stb	r2,-23912(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
 32170bc:	e037883a 	mov	sp,fp
 32170c0:	df000017 	ldw	fp,0(sp)
 32170c4:	dec00104 	addi	sp,sp,4
 32170c8:	f800283a 	ret

032170cc <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
 32170cc:	defffc04 	addi	sp,sp,-16
 32170d0:	df000315 	stw	fp,12(sp)
 32170d4:	df000304 	addi	fp,sp,12
 32170d8:	e13ffe15 	stw	r4,-8(fp)
 32170dc:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
 32170e0:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
 32170e4:	00000d06 	br	321711c <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
 32170e8:	e0bfff17 	ldw	r2,-4(fp)
 32170ec:	10c00003 	ldbu	r3,0(r2)
 32170f0:	e0bffe17 	ldw	r2,-8(fp)
 32170f4:	10c00005 	stb	r3,0(r2)
 32170f8:	e0bffe17 	ldw	r2,-8(fp)
 32170fc:	10800044 	addi	r2,r2,1
 3217100:	e0bffe15 	stw	r2,-8(fp)
 3217104:	e0bfff17 	ldw	r2,-4(fp)
 3217108:	10800044 	addi	r2,r2,1
 321710c:	e0bfff15 	stw	r2,-4(fp)
        len++;
 3217110:	e0bffd03 	ldbu	r2,-12(fp)
 3217114:	10800044 	addi	r2,r2,1
 3217118:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 321711c:	e0bfff17 	ldw	r2,-4(fp)
 3217120:	10800003 	ldbu	r2,0(r2)
 3217124:	10803fcc 	andi	r2,r2,255
 3217128:	1004c03a 	cmpne	r2,r2,zero
 321712c:	103fee1e 	bne	r2,zero,32170e8 <OS_StrCopy+0x1c>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
 3217130:	e0bffe17 	ldw	r2,-8(fp)
 3217134:	10000005 	stb	zero,0(r2)
    return (len);
 3217138:	e0bffd03 	ldbu	r2,-12(fp)
}
 321713c:	e037883a 	mov	sp,fp
 3217140:	df000017 	ldw	fp,0(sp)
 3217144:	dec00104 	addi	sp,sp,4
 3217148:	f800283a 	ret

0321714c <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
 321714c:	defffd04 	addi	sp,sp,-12
 3217150:	df000215 	stw	fp,8(sp)
 3217154:	df000204 	addi	fp,sp,8
 3217158:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
 321715c:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
 3217160:	00000606 	br	321717c <OS_StrLen+0x30>
        psrc++;
 3217164:	e0bfff17 	ldw	r2,-4(fp)
 3217168:	10800044 	addi	r2,r2,1
 321716c:	e0bfff15 	stw	r2,-4(fp)
        len++;
 3217170:	e0bffe03 	ldbu	r2,-8(fp)
 3217174:	10800044 	addi	r2,r2,1
 3217178:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 321717c:	e0bfff17 	ldw	r2,-4(fp)
 3217180:	10800003 	ldbu	r2,0(r2)
 3217184:	10803fcc 	andi	r2,r2,255
 3217188:	1004c03a 	cmpne	r2,r2,zero
 321718c:	103ff51e 	bne	r2,zero,3217164 <OS_StrLen+0x18>
        psrc++;
        len++;
    }
    return (len);
 3217190:	e0bffe03 	ldbu	r2,-8(fp)
}
 3217194:	e037883a 	mov	sp,fp
 3217198:	df000017 	ldw	fp,0(sp)
 321719c:	dec00104 	addi	sp,sp,4
 32171a0:	f800283a 	ret

032171a4 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
 32171a4:	defffa04 	addi	sp,sp,-24
 32171a8:	dfc00515 	stw	ra,20(sp)
 32171ac:	df000415 	stw	fp,16(sp)
 32171b0:	df000404 	addi	fp,sp,16
 32171b4:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 32171b8:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32171bc:	0005303a 	rdctl	r2,status
 32171c0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32171c4:	e0fffd17 	ldw	r3,-12(fp)
 32171c8:	00bfff84 	movi	r2,-2
 32171cc:	1884703a 	and	r2,r3,r2
 32171d0:	1001703a 	wrctl	status,r2
  
  return context;
 32171d4:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
 32171d8:	e0bffe15 	stw	r2,-8(fp)
        OSIdleCtr++;
 32171dc:	d0a8a517 	ldw	r2,-23916(gp)
 32171e0:	10800044 	addi	r2,r2,1
 32171e4:	d0a8a515 	stw	r2,-23916(gp)
 32171e8:	e0bffe17 	ldw	r2,-8(fp)
 32171ec:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 32171f0:	e0bffc17 	ldw	r2,-16(fp)
 32171f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
 32171f8:	323b93c0 	call	323b93c <OSTaskIdleHook>
    }
 32171fc:	003fef06 	br	32171bc <OS_TaskIdle+0x18>

03217200 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
 3217200:	defffa04 	addi	sp,sp,-24
 3217204:	dfc00515 	stw	ra,20(sp)
 3217208:	df000415 	stw	fp,16(sp)
 321720c:	df000404 	addi	fp,sp,16
 3217210:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3217214:	e03ffe15 	stw	zero,-8(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 3217218:	00000206 	br	3217224 <OS_TaskStat+0x24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
 321721c:	01003204 	movi	r4,200
 3217220:	321d27c0 	call	321d27c <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 3217224:	d0a8b603 	ldbu	r2,-23848(gp)
 3217228:	10803fcc 	andi	r2,r2,255
 321722c:	1005003a 	cmpeq	r2,r2,zero
 3217230:	103ffa1e 	bne	r2,zero,321721c <OS_TaskStat+0x1c>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
 3217234:	d128aa17 	ldw	r4,-23896(gp)
 3217238:	01401904 	movi	r5,100
 321723c:	32047c00 	call	32047c0 <__udivsi3>
 3217240:	d0a8aa15 	stw	r2,-23896(gp)
    if (OSIdleCtrMax == 0L) {
 3217244:	d0a8aa17 	ldw	r2,-23896(gp)
 3217248:	1004c03a 	cmpne	r2,r2,zero
 321724c:	1000031e 	bne	r2,zero,321725c <OS_TaskStat+0x5c>
        OSCPUUsage = 0;
 3217250:	d028ac05 	stb	zero,-23888(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
 3217254:	01003fc4 	movi	r4,255
 3217258:	321ce900 	call	321ce90 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321725c:	0005303a 	rdctl	r2,status
 3217260:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3217264:	e0fffd17 	ldw	r3,-12(fp)
 3217268:	00bfff84 	movi	r2,-2
 321726c:	1884703a 	and	r2,r3,r2
 3217270:	1001703a 	wrctl	status,r2
  
  return context;
 3217274:	e0bffd17 	ldw	r2,-12(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
 3217278:	e0bffe15 	stw	r2,-8(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
 321727c:	d0a8a517 	ldw	r2,-23916(gp)
 3217280:	d0a8b715 	stw	r2,-23844(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
 3217284:	d028a515 	stw	zero,-23916(gp)
 3217288:	e0bffe17 	ldw	r2,-8(fp)
 321728c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3217290:	e0bffc17 	ldw	r2,-16(fp)
 3217294:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
 3217298:	d128b717 	ldw	r4,-23844(gp)
 321729c:	d168aa17 	ldw	r5,-23896(gp)
 32172a0:	32047c00 	call	32047c0 <__udivsi3>
 32172a4:	1007883a 	mov	r3,r2
 32172a8:	00801904 	movi	r2,100
 32172ac:	10c5c83a 	sub	r2,r2,r3
 32172b0:	d0a8ac05 	stb	r2,-23888(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
 32172b4:	323b8c00 	call	323b8c0 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
 32172b8:	32172c80 	call	32172c8 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
 32172bc:	01001904 	movi	r4,100
 32172c0:	321d27c0 	call	321d27c <OSTimeDly>
    }
 32172c4:	003fe506 	br	321725c <OS_TaskStat+0x5c>

032172c8 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
 32172c8:	defffa04 	addi	sp,sp,-24
 32172cc:	dfc00515 	stw	ra,20(sp)
 32172d0:	df000415 	stw	fp,16(sp)
 32172d4:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 32172d8:	e03ffc05 	stb	zero,-16(fp)
 32172dc:	00002406 	br	3217370 <OS_TaskStatStkChk+0xa8>
        err = OSTaskStkChk(prio, &stk_data);
 32172e0:	e13ffc03 	ldbu	r4,-16(fp)
 32172e4:	e17ffe04 	addi	r5,fp,-8
 32172e8:	321cc940 	call	321cc94 <OSTaskStkChk>
 32172ec:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
 32172f0:	e0bffc43 	ldbu	r2,-15(fp)
 32172f4:	1004c03a 	cmpne	r2,r2,zero
 32172f8:	10001a1e 	bne	r2,zero,3217364 <OS_TaskStatStkChk+0x9c>
            ptcb = OSTCBPrioTbl[prio];
 32172fc:	e0bffc03 	ldbu	r2,-16(fp)
 3217300:	00c0c9b4 	movhi	r3,806
 3217304:	18f26b04 	addi	r3,r3,-13908
 3217308:	1085883a 	add	r2,r2,r2
 321730c:	1085883a 	add	r2,r2,r2
 3217310:	10c5883a 	add	r2,r2,r3
 3217314:	10800017 	ldw	r2,0(r2)
 3217318:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
 321731c:	e0bffd17 	ldw	r2,-12(fp)
 3217320:	1005003a 	cmpeq	r2,r2,zero
 3217324:	10000f1e 	bne	r2,zero,3217364 <OS_TaskStatStkChk+0x9c>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
 3217328:	e0bffd17 	ldw	r2,-12(fp)
 321732c:	10800060 	cmpeqi	r2,r2,1
 3217330:	10000c1e 	bne	r2,zero,3217364 <OS_TaskStatStkChk+0x9c>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
 3217334:	e0bffd17 	ldw	r2,-12(fp)
 3217338:	10c00217 	ldw	r3,8(r2)
 321733c:	e0bffd17 	ldw	r2,-12(fp)
 3217340:	10800317 	ldw	r2,12(r2)
 3217344:	1085883a 	add	r2,r2,r2
 3217348:	1085883a 	add	r2,r2,r2
 321734c:	1887883a 	add	r3,r3,r2
 3217350:	e0bffd17 	ldw	r2,-12(fp)
 3217354:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
 3217358:	e0ffff17 	ldw	r3,-4(fp)
 321735c:	e0bffd17 	ldw	r2,-12(fp)
 3217360:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 3217364:	e0bffc03 	ldbu	r2,-16(fp)
 3217368:	10800044 	addi	r2,r2,1
 321736c:	e0bffc05 	stb	r2,-16(fp)
 3217370:	e0bffc03 	ldbu	r2,-16(fp)
 3217374:	10800570 	cmpltui	r2,r2,21
 3217378:	103fd91e 	bne	r2,zero,32172e0 <OS_TaskStatStkChk+0x18>
#endif
                }
            }
        }
    }
}
 321737c:	e037883a 	mov	sp,fp
 3217380:	dfc00117 	ldw	ra,4(sp)
 3217384:	df000017 	ldw	fp,0(sp)
 3217388:	dec00204 	addi	sp,sp,8
 321738c:	f800283a 	ret

03217390 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
 3217390:	defff104 	addi	sp,sp,-60
 3217394:	dfc00e15 	stw	ra,56(sp)
 3217398:	df000d15 	stw	fp,52(sp)
 321739c:	df000d04 	addi	fp,sp,52
 32173a0:	e17ffb15 	stw	r5,-20(fp)
 32173a4:	e1bffc15 	stw	r6,-16(fp)
 32173a8:	e0800417 	ldw	r2,16(fp)
 32173ac:	e13ffa05 	stb	r4,-24(fp)
 32173b0:	e1fffd0d 	sth	r7,-12(fp)
 32173b4:	e0bffe0d 	sth	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 32173b8:	e03ff815 	stw	zero,-32(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32173bc:	0005303a 	rdctl	r2,status
 32173c0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32173c4:	e0fff717 	ldw	r3,-36(fp)
 32173c8:	00bfff84 	movi	r2,-2
 32173cc:	1884703a 	and	r2,r3,r2
 32173d0:	1001703a 	wrctl	status,r2
  
  return context;
 32173d4:	e0bff717 	ldw	r2,-36(fp)
#endif



    OS_ENTER_CRITICAL();
 32173d8:	e0bff815 	stw	r2,-32(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
 32173dc:	d0a8ab17 	ldw	r2,-23892(gp)
 32173e0:	e0bff915 	stw	r2,-28(fp)
    if (ptcb != (OS_TCB *)0) {
 32173e4:	e0bff917 	ldw	r2,-28(fp)
 32173e8:	1005003a 	cmpeq	r2,r2,zero
 32173ec:	1000941e 	bne	r2,zero,3217640 <OS_TCBInit+0x2b0>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
 32173f0:	e0bff917 	ldw	r2,-28(fp)
 32173f4:	10800517 	ldw	r2,20(r2)
 32173f8:	d0a8ab15 	stw	r2,-23892(gp)
 32173fc:	e0bff817 	ldw	r2,-32(fp)
 3217400:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3217404:	e0bff617 	ldw	r2,-40(fp)
 3217408:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
 321740c:	e0fff917 	ldw	r3,-28(fp)
 3217410:	e0bffb17 	ldw	r2,-20(fp)
 3217414:	18800015 	stw	r2,0(r3)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
 3217418:	e0fff917 	ldw	r3,-28(fp)
 321741c:	e0bffa03 	ldbu	r2,-24(fp)
 3217420:	18800c85 	stb	r2,50(r3)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
 3217424:	e0bff917 	ldw	r2,-28(fp)
 3217428:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
 321742c:	e0bff917 	ldw	r2,-28(fp)
 3217430:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
 3217434:	e0bff917 	ldw	r2,-28(fp)
 3217438:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
 321743c:	e0fff917 	ldw	r3,-28(fp)
 3217440:	e0800317 	ldw	r2,12(fp)
 3217444:	18800115 	stw	r2,4(r3)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
 3217448:	e0fff917 	ldw	r3,-28(fp)
 321744c:	e0800217 	ldw	r2,8(fp)
 3217450:	18800315 	stw	r2,12(r3)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
 3217454:	e0fff917 	ldw	r3,-28(fp)
 3217458:	e0bffc17 	ldw	r2,-16(fp)
 321745c:	18800215 	stw	r2,8(r3)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
 3217460:	e0fff917 	ldw	r3,-28(fp)
 3217464:	e0bffe0b 	ldhu	r2,-8(fp)
 3217468:	1880040d 	sth	r2,16(r3)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
 321746c:	e0fff917 	ldw	r3,-28(fp)
 3217470:	e0bffd0b 	ldhu	r2,-12(fp)
 3217474:	1880048d 	sth	r2,18(r3)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
 3217478:	e0bff917 	ldw	r2,-28(fp)
 321747c:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
 3217480:	e0bffa03 	ldbu	r2,-24(fp)
 3217484:	1004d0fa 	srli	r2,r2,3
 3217488:	1007883a 	mov	r3,r2
 321748c:	e0bff917 	ldw	r2,-28(fp)
 3217490:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
 3217494:	e0bffa03 	ldbu	r2,-24(fp)
 3217498:	108001cc 	andi	r2,r2,7
 321749c:	1007883a 	mov	r3,r2
 32174a0:	e0bff917 	ldw	r2,-28(fp)
 32174a4:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
 32174a8:	e0bff917 	ldw	r2,-28(fp)
 32174ac:	10800d03 	ldbu	r2,52(r2)
 32174b0:	10c03fcc 	andi	r3,r2,255
 32174b4:	00800044 	movi	r2,1
 32174b8:	10c4983a 	sll	r2,r2,r3
 32174bc:	1007883a 	mov	r3,r2
 32174c0:	e0bff917 	ldw	r2,-28(fp)
 32174c4:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
 32174c8:	e0bff917 	ldw	r2,-28(fp)
 32174cc:	10800cc3 	ldbu	r2,51(r2)
 32174d0:	10c03fcc 	andi	r3,r2,255
 32174d4:	00800044 	movi	r2,1
 32174d8:	10c4983a 	sll	r2,r2,r3
 32174dc:	1007883a 	mov	r3,r2
 32174e0:	e0bff917 	ldw	r2,-28(fp)
 32174e4:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
 32174e8:	e0bff917 	ldw	r2,-28(fp)
 32174ec:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
 32174f0:	e0bff917 	ldw	r2,-28(fp)
 32174f4:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
 32174f8:	e0bff917 	ldw	r2,-28(fp)
 32174fc:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
 3217500:	e0bff917 	ldw	r2,-28(fp)
 3217504:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
 3217508:	e0bff917 	ldw	r2,-28(fp)
 321750c:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
 3217510:	e0bff917 	ldw	r2,-28(fp)
 3217514:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
 3217518:	e0bff917 	ldw	r2,-28(fp)
 321751c:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
 3217520:	e0bff917 	ldw	r2,-28(fp)
 3217524:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
 3217528:	e0bff917 	ldw	r2,-28(fp)
 321752c:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
 3217530:	e0fff917 	ldw	r3,-28(fp)
 3217534:	00800fc4 	movi	r2,63
 3217538:	18801305 	stb	r2,76(r3)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 321753c:	e0bff917 	ldw	r2,-28(fp)
 3217540:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
 3217544:	e13ff917 	ldw	r4,-28(fp)
 3217548:	323b9580 	call	323b958 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
 321754c:	e13ff917 	ldw	r4,-28(fp)
 3217550:	323b8640 	call	323b864 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3217554:	0005303a 	rdctl	r2,status
 3217558:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321755c:	e0fff517 	ldw	r3,-44(fp)
 3217560:	00bfff84 	movi	r2,-2
 3217564:	1884703a 	and	r2,r3,r2
 3217568:	1001703a 	wrctl	status,r2
  
  return context;
 321756c:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
 3217570:	e0bff815 	stw	r2,-32(fp)
        OSTCBPrioTbl[prio] = ptcb;
 3217574:	e0bffa03 	ldbu	r2,-24(fp)
 3217578:	00c0c9b4 	movhi	r3,806
 321757c:	18f26b04 	addi	r3,r3,-13908
 3217580:	1085883a 	add	r2,r2,r2
 3217584:	1085883a 	add	r2,r2,r2
 3217588:	10c7883a 	add	r3,r2,r3
 321758c:	e0bff917 	ldw	r2,-28(fp)
 3217590:	18800015 	stw	r2,0(r3)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
 3217594:	d0e8a717 	ldw	r3,-23908(gp)
 3217598:	e0bff917 	ldw	r2,-28(fp)
 321759c:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
 32175a0:	e0bff917 	ldw	r2,-28(fp)
 32175a4:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
 32175a8:	d0a8a717 	ldw	r2,-23908(gp)
 32175ac:	1005003a 	cmpeq	r2,r2,zero
 32175b0:	1000031e 	bne	r2,zero,32175c0 <OS_TCBInit+0x230>
            OSTCBList->OSTCBPrev = ptcb;
 32175b4:	d0e8a717 	ldw	r3,-23908(gp)
 32175b8:	e0bff917 	ldw	r2,-28(fp)
 32175bc:	18800615 	stw	r2,24(r3)
        }
        OSTCBList               = ptcb;
 32175c0:	e0bff917 	ldw	r2,-28(fp)
 32175c4:	d0a8a715 	stw	r2,-23908(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
 32175c8:	e0bff917 	ldw	r2,-28(fp)
 32175cc:	10c00d83 	ldbu	r3,54(r2)
 32175d0:	d0a8b003 	ldbu	r2,-23872(gp)
 32175d4:	1884b03a 	or	r2,r3,r2
 32175d8:	d0a8b005 	stb	r2,-23872(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 32175dc:	e0bff917 	ldw	r2,-28(fp)
 32175e0:	10800d03 	ldbu	r2,52(r2)
 32175e4:	11003fcc 	andi	r4,r2,255
 32175e8:	e0bff917 	ldw	r2,-28(fp)
 32175ec:	10800d03 	ldbu	r2,52(r2)
 32175f0:	10c03fcc 	andi	r3,r2,255
 32175f4:	d0a8b044 	addi	r2,gp,-23871
 32175f8:	1885883a 	add	r2,r3,r2
 32175fc:	10c00003 	ldbu	r3,0(r2)
 3217600:	e0bff917 	ldw	r2,-28(fp)
 3217604:	10800d43 	ldbu	r2,53(r2)
 3217608:	1884b03a 	or	r2,r3,r2
 321760c:	1007883a 	mov	r3,r2
 3217610:	d0a8b044 	addi	r2,gp,-23871
 3217614:	2085883a 	add	r2,r4,r2
 3217618:	10c00005 	stb	r3,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
 321761c:	d0a8ac43 	ldbu	r2,-23887(gp)
 3217620:	10800044 	addi	r2,r2,1
 3217624:	d0a8ac45 	stb	r2,-23887(gp)
 3217628:	e0bff817 	ldw	r2,-32(fp)
 321762c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3217630:	e0bff417 	ldw	r2,-48(fp)
 3217634:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 3217638:	e03fff15 	stw	zero,-4(fp)
 321763c:	00000606 	br	3217658 <OS_TCBInit+0x2c8>
 3217640:	e0bff817 	ldw	r2,-32(fp)
 3217644:	e0bff315 	stw	r2,-52(fp)
 3217648:	e0bff317 	ldw	r2,-52(fp)
 321764c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
 3217650:	00801084 	movi	r2,66
 3217654:	e0bfff15 	stw	r2,-4(fp)
 3217658:	e0bfff17 	ldw	r2,-4(fp)
}
 321765c:	e037883a 	mov	sp,fp
 3217660:	dfc00117 	ldw	ra,4(sp)
 3217664:	df000017 	ldw	fp,0(sp)
 3217668:	dec00204 	addi	sp,sp,8
 321766c:	f800283a 	ret

03217670 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
 3217670:	defffe04 	addi	sp,sp,-8
 3217674:	df000115 	stw	fp,4(sp)
 3217678:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
 321767c:	d0a00c04 	addi	r2,gp,-32720
 3217680:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
 3217684:	d0a00d04 	addi	r2,gp,-32716
 3217688:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
 321768c:	d0a00e84 	addi	r2,gp,-32710
 3217690:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
 3217694:	d0a00f04 	addi	r2,gp,-32708
 3217698:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
 321769c:	d0a00e04 	addi	r2,gp,-32712
 32176a0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
 32176a4:	d0a00f84 	addi	r2,gp,-32706
 32176a8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
 32176ac:	d0a01004 	addi	r2,gp,-32704
 32176b0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
 32176b4:	d0a01084 	addi	r2,gp,-32702
 32176b8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
 32176bc:	d0a01104 	addi	r2,gp,-32700
 32176c0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
 32176c4:	d0a01184 	addi	r2,gp,-32698
 32176c8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
 32176cc:	d0a01204 	addi	r2,gp,-32696
 32176d0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
 32176d4:	d0a01284 	addi	r2,gp,-32694
 32176d8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
 32176dc:	d0a01304 	addi	r2,gp,-32692
 32176e0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
 32176e4:	d0a01384 	addi	r2,gp,-32690
 32176e8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
 32176ec:	d0a01404 	addi	r2,gp,-32688
 32176f0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
 32176f4:	d0a01484 	addi	r2,gp,-32686
 32176f8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
 32176fc:	d0a01504 	addi	r2,gp,-32684
 3217700:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
 3217704:	d0a01584 	addi	r2,gp,-32682
 3217708:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
 321770c:	d0a01604 	addi	r2,gp,-32680
 3217710:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
 3217714:	d0a01684 	addi	r2,gp,-32678
 3217718:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
 321771c:	d0a01704 	addi	r2,gp,-32676
 3217720:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
 3217724:	d0a01784 	addi	r2,gp,-32674
 3217728:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
 321772c:	d0a01804 	addi	r2,gp,-32672
 3217730:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
 3217734:	d0a01884 	addi	r2,gp,-32670
 3217738:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
 321773c:	d0a01904 	addi	r2,gp,-32668
 3217740:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
 3217744:	d0a01984 	addi	r2,gp,-32666
 3217748:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
 321774c:	d0a01a04 	addi	r2,gp,-32664
 3217750:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
 3217754:	d0a01a84 	addi	r2,gp,-32662
 3217758:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
 321775c:	d0a01b04 	addi	r2,gp,-32660
 3217760:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
 3217764:	d0a01b84 	addi	r2,gp,-32658
 3217768:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
 321776c:	d0a01c04 	addi	r2,gp,-32656
 3217770:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
 3217774:	d0a01c84 	addi	r2,gp,-32654
 3217778:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
 321777c:	d0a01d04 	addi	r2,gp,-32652
 3217780:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
 3217784:	d0a01d84 	addi	r2,gp,-32650
 3217788:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
 321778c:	d0a01e04 	addi	r2,gp,-32648
 3217790:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
 3217794:	d0a01e84 	addi	r2,gp,-32646
 3217798:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
 321779c:	d0a01f04 	addi	r2,gp,-32644
 32177a0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
 32177a4:	d0a01f84 	addi	r2,gp,-32642
 32177a8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
 32177ac:	d0a02004 	addi	r2,gp,-32640
 32177b0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
 32177b4:	d0a02084 	addi	r2,gp,-32638
 32177b8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
 32177bc:	d0a02104 	addi	r2,gp,-32636
 32177c0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
 32177c4:	d0a02184 	addi	r2,gp,-32634
 32177c8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
 32177cc:	d0a02204 	addi	r2,gp,-32632
 32177d0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
 32177d4:	d0a02284 	addi	r2,gp,-32630
 32177d8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
    ptemp = (void *)&OSTmrWheelTblSize;
#endif

    ptemp = (void *)&OSVersionNbr;
 32177dc:	d0a02304 	addi	r2,gp,-32628
 32177e0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
 32177e4:	d0a02804 	addi	r2,gp,-32608
 32177e8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
 32177ec:	e037883a 	mov	sp,fp
 32177f0:	df000017 	ldw	fp,0(sp)
 32177f4:	dec00104 	addi	sp,sp,4
 32177f8:	f800283a 	ret

032177fc <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
 32177fc:	defff104 	addi	sp,sp,-60
 3217800:	df000e15 	stw	fp,56(sp)
 3217804:	df000e04 	addi	fp,sp,56
 3217808:	e13ffa15 	stw	r4,-24(fp)
 321780c:	e1fffd15 	stw	r7,-12(fp)
 3217810:	e17ffb0d 	sth	r5,-20(fp)
 3217814:	e1bffc05 	stb	r6,-16(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 3217818:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 321781c:	e0bffd17 	ldw	r2,-12(fp)
 3217820:	1004c03a 	cmpne	r2,r2,zero
 3217824:	1000021e 	bne	r2,zero,3217830 <OSFlagAccept+0x34>
        return ((OS_FLAGS)0);
 3217828:	e03fff15 	stw	zero,-4(fp)
 321782c:	0000bb06 	br	3217b1c <OSFlagAccept+0x320>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 3217830:	e0bffa17 	ldw	r2,-24(fp)
 3217834:	1004c03a 	cmpne	r2,r2,zero
 3217838:	1000051e 	bne	r2,zero,3217850 <OSFlagAccept+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 321783c:	e0fffd17 	ldw	r3,-12(fp)
 3217840:	00801b84 	movi	r2,110
 3217844:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 3217848:	e03fff15 	stw	zero,-4(fp)
 321784c:	0000b306 	br	3217b1c <OSFlagAccept+0x320>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 3217850:	e0bffa17 	ldw	r2,-24(fp)
 3217854:	10800003 	ldbu	r2,0(r2)
 3217858:	10803fcc 	andi	r2,r2,255
 321785c:	10800160 	cmpeqi	r2,r2,5
 3217860:	1000051e 	bne	r2,zero,3217878 <OSFlagAccept+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 3217864:	e0fffd17 	ldw	r3,-12(fp)
 3217868:	00800044 	movi	r2,1
 321786c:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 3217870:	e03fff15 	stw	zero,-4(fp)
 3217874:	0000a906 	br	3217b1c <OSFlagAccept+0x320>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 3217878:	e0fffc03 	ldbu	r3,-16(fp)
 321787c:	00bfe004 	movi	r2,-128
 3217880:	1884703a 	and	r2,r3,r2
 3217884:	e0bff945 	stb	r2,-27(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
 3217888:	e0bff943 	ldbu	r2,-27(fp)
 321788c:	1005003a 	cmpeq	r2,r2,zero
 3217890:	1000061e 	bne	r2,zero,32178ac <OSFlagAccept+0xb0>
        wait_type &= ~OS_FLAG_CONSUME;
 3217894:	e0bffc03 	ldbu	r2,-16(fp)
 3217898:	10801fcc 	andi	r2,r2,127
 321789c:	e0bffc05 	stb	r2,-16(fp)
        consume    = OS_TRUE;
 32178a0:	00800044 	movi	r2,1
 32178a4:	e0bff905 	stb	r2,-28(fp)
 32178a8:	00000106 	br	32178b0 <OSFlagAccept+0xb4>
    } else {
        consume    = OS_FALSE;
 32178ac:	e03ff905 	stb	zero,-28(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
 32178b0:	e0bffd17 	ldw	r2,-12(fp)
 32178b4:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32178b8:	0005303a 	rdctl	r2,status
 32178bc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32178c0:	e0fff717 	ldw	r3,-36(fp)
 32178c4:	00bfff84 	movi	r2,-2
 32178c8:	1884703a 	and	r2,r3,r2
 32178cc:	1001703a 	wrctl	status,r2
  
  return context;
 32178d0:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 32178d4:	e0bff815 	stw	r2,-32(fp)
    switch (wait_type) {
 32178d8:	e0bffc03 	ldbu	r2,-16(fp)
 32178dc:	e0bffe15 	stw	r2,-8(fp)
 32178e0:	e0fffe17 	ldw	r3,-8(fp)
 32178e4:	18800060 	cmpeqi	r2,r3,1
 32178e8:	1000651e 	bne	r2,zero,3217a80 <OSFlagAccept+0x284>
 32178ec:	e0fffe17 	ldw	r3,-8(fp)
 32178f0:	18800088 	cmpgei	r2,r3,2
 32178f4:	1000041e 	bne	r2,zero,3217908 <OSFlagAccept+0x10c>
 32178f8:	e0fffe17 	ldw	r3,-8(fp)
 32178fc:	1805003a 	cmpeq	r2,r3,zero
 3217900:	1000421e 	bne	r2,zero,3217a0c <OSFlagAccept+0x210>
 3217904:	00007b06 	br	3217af4 <OSFlagAccept+0x2f8>
 3217908:	e0fffe17 	ldw	r3,-8(fp)
 321790c:	188000a0 	cmpeqi	r2,r3,2
 3217910:	1000041e 	bne	r2,zero,3217924 <OSFlagAccept+0x128>
 3217914:	e0fffe17 	ldw	r3,-8(fp)
 3217918:	188000e0 	cmpeqi	r2,r3,3
 321791c:	10001e1e 	bne	r2,zero,3217998 <OSFlagAccept+0x19c>
 3217920:	00007406 	br	3217af4 <OSFlagAccept+0x2f8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 3217924:	e0bffa17 	ldw	r2,-24(fp)
 3217928:	10c0020b 	ldhu	r3,8(r2)
 321792c:	e0bffb0b 	ldhu	r2,-20(fp)
 3217930:	1884703a 	and	r2,r3,r2
 3217934:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 3217938:	e0fff98b 	ldhu	r3,-26(fp)
 321793c:	e0bffb0b 	ldhu	r2,-20(fp)
 3217940:	18800d1e 	bne	r3,r2,3217978 <OSFlagAccept+0x17c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 3217944:	e0bff903 	ldbu	r2,-28(fp)
 3217948:	10800058 	cmpnei	r2,r2,1
 321794c:	10000d1e 	bne	r2,zero,3217984 <OSFlagAccept+0x188>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 3217950:	e0bffa17 	ldw	r2,-24(fp)
 3217954:	1080020b 	ldhu	r2,8(r2)
 3217958:	1007883a 	mov	r3,r2
 321795c:	e0bff98b 	ldhu	r2,-26(fp)
 3217960:	0084303a 	nor	r2,zero,r2
 3217964:	1884703a 	and	r2,r3,r2
 3217968:	1007883a 	mov	r3,r2
 321796c:	e0bffa17 	ldw	r2,-24(fp)
 3217970:	10c0020d 	sth	r3,8(r2)
 3217974:	00000306 	br	3217984 <OSFlagAccept+0x188>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 3217978:	e0fffd17 	ldw	r3,-12(fp)
 321797c:	00801c04 	movi	r2,112
 3217980:	18800005 	stb	r2,0(r3)
 3217984:	e0bff817 	ldw	r2,-32(fp)
 3217988:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321798c:	e0bff617 	ldw	r2,-40(fp)
 3217990:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 3217994:	00005f06 	br	3217b14 <OSFlagAccept+0x318>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 3217998:	e0bffa17 	ldw	r2,-24(fp)
 321799c:	10c0020b 	ldhu	r3,8(r2)
 32179a0:	e0bffb0b 	ldhu	r2,-20(fp)
 32179a4:	1884703a 	and	r2,r3,r2
 32179a8:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 32179ac:	e0bff98b 	ldhu	r2,-26(fp)
 32179b0:	1005003a 	cmpeq	r2,r2,zero
 32179b4:	10000d1e 	bne	r2,zero,32179ec <OSFlagAccept+0x1f0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 32179b8:	e0bff903 	ldbu	r2,-28(fp)
 32179bc:	10800058 	cmpnei	r2,r2,1
 32179c0:	10000d1e 	bne	r2,zero,32179f8 <OSFlagAccept+0x1fc>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 32179c4:	e0bffa17 	ldw	r2,-24(fp)
 32179c8:	1080020b 	ldhu	r2,8(r2)
 32179cc:	1007883a 	mov	r3,r2
 32179d0:	e0bff98b 	ldhu	r2,-26(fp)
 32179d4:	0084303a 	nor	r2,zero,r2
 32179d8:	1884703a 	and	r2,r3,r2
 32179dc:	1007883a 	mov	r3,r2
 32179e0:	e0bffa17 	ldw	r2,-24(fp)
 32179e4:	10c0020d 	sth	r3,8(r2)
 32179e8:	00000306 	br	32179f8 <OSFlagAccept+0x1fc>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 32179ec:	e0fffd17 	ldw	r3,-12(fp)
 32179f0:	00801c04 	movi	r2,112
 32179f4:	18800005 	stb	r2,0(r3)
 32179f8:	e0bff817 	ldw	r2,-32(fp)
 32179fc:	e0bff515 	stw	r2,-44(fp)
 3217a00:	e0bff517 	ldw	r2,-44(fp)
 3217a04:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 3217a08:	00004206 	br	3217b14 <OSFlagAccept+0x318>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 3217a0c:	e0bffa17 	ldw	r2,-24(fp)
 3217a10:	1080020b 	ldhu	r2,8(r2)
 3217a14:	0084303a 	nor	r2,zero,r2
 3217a18:	1007883a 	mov	r3,r2
 3217a1c:	e0bffb0b 	ldhu	r2,-20(fp)
 3217a20:	1884703a 	and	r2,r3,r2
 3217a24:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 3217a28:	e0fff98b 	ldhu	r3,-26(fp)
 3217a2c:	e0bffb0b 	ldhu	r2,-20(fp)
 3217a30:	18800b1e 	bne	r3,r2,3217a60 <OSFlagAccept+0x264>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 3217a34:	e0bff903 	ldbu	r2,-28(fp)
 3217a38:	10800058 	cmpnei	r2,r2,1
 3217a3c:	10000b1e 	bne	r2,zero,3217a6c <OSFlagAccept+0x270>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 3217a40:	e0bffa17 	ldw	r2,-24(fp)
 3217a44:	10c0020b 	ldhu	r3,8(r2)
 3217a48:	e0bff98b 	ldhu	r2,-26(fp)
 3217a4c:	1884b03a 	or	r2,r3,r2
 3217a50:	1007883a 	mov	r3,r2
 3217a54:	e0bffa17 	ldw	r2,-24(fp)
 3217a58:	10c0020d 	sth	r3,8(r2)
 3217a5c:	00000306 	br	3217a6c <OSFlagAccept+0x270>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 3217a60:	e0fffd17 	ldw	r3,-12(fp)
 3217a64:	00801c04 	movi	r2,112
 3217a68:	18800005 	stb	r2,0(r3)
 3217a6c:	e0bff817 	ldw	r2,-32(fp)
 3217a70:	e0bff415 	stw	r2,-48(fp)
 3217a74:	e0bff417 	ldw	r2,-48(fp)
 3217a78:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 3217a7c:	00002506 	br	3217b14 <OSFlagAccept+0x318>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 3217a80:	e0bffa17 	ldw	r2,-24(fp)
 3217a84:	1080020b 	ldhu	r2,8(r2)
 3217a88:	0084303a 	nor	r2,zero,r2
 3217a8c:	1007883a 	mov	r3,r2
 3217a90:	e0bffb0b 	ldhu	r2,-20(fp)
 3217a94:	1884703a 	and	r2,r3,r2
 3217a98:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 3217a9c:	e0bff98b 	ldhu	r2,-26(fp)
 3217aa0:	1005003a 	cmpeq	r2,r2,zero
 3217aa4:	10000b1e 	bne	r2,zero,3217ad4 <OSFlagAccept+0x2d8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 3217aa8:	e0bff903 	ldbu	r2,-28(fp)
 3217aac:	10800058 	cmpnei	r2,r2,1
 3217ab0:	10000b1e 	bne	r2,zero,3217ae0 <OSFlagAccept+0x2e4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 3217ab4:	e0bffa17 	ldw	r2,-24(fp)
 3217ab8:	10c0020b 	ldhu	r3,8(r2)
 3217abc:	e0bff98b 	ldhu	r2,-26(fp)
 3217ac0:	1884b03a 	or	r2,r3,r2
 3217ac4:	1007883a 	mov	r3,r2
 3217ac8:	e0bffa17 	ldw	r2,-24(fp)
 3217acc:	10c0020d 	sth	r3,8(r2)
 3217ad0:	00000306 	br	3217ae0 <OSFlagAccept+0x2e4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 3217ad4:	e0fffd17 	ldw	r3,-12(fp)
 3217ad8:	00801c04 	movi	r2,112
 3217adc:	18800005 	stb	r2,0(r3)
 3217ae0:	e0bff817 	ldw	r2,-32(fp)
 3217ae4:	e0bff315 	stw	r2,-52(fp)
 3217ae8:	e0bff317 	ldw	r2,-52(fp)
 3217aec:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 3217af0:	00000806 	br	3217b14 <OSFlagAccept+0x318>
 3217af4:	e0bff817 	ldw	r2,-32(fp)
 3217af8:	e0bff215 	stw	r2,-56(fp)
 3217afc:	e0bff217 	ldw	r2,-56(fp)
 3217b00:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 3217b04:	e03ff98d 	sth	zero,-26(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
 3217b08:	e0fffd17 	ldw	r3,-12(fp)
 3217b0c:	00801bc4 	movi	r2,111
 3217b10:	18800005 	stb	r2,0(r3)
             break;
    }
    return (flags_rdy);
 3217b14:	e0bff98b 	ldhu	r2,-26(fp)
 3217b18:	e0bfff15 	stw	r2,-4(fp)
 3217b1c:	e0bfff17 	ldw	r2,-4(fp)
}
 3217b20:	e037883a 	mov	sp,fp
 3217b24:	df000017 	ldw	fp,0(sp)
 3217b28:	dec00104 	addi	sp,sp,4
 3217b2c:	f800283a 	ret

03217b30 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
 3217b30:	defff704 	addi	sp,sp,-36
 3217b34:	df000815 	stw	fp,32(sp)
 3217b38:	df000804 	addi	fp,sp,32
 3217b3c:	e17ffe15 	stw	r5,-8(fp)
 3217b40:	e13ffd0d 	sth	r4,-12(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
 3217b44:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
 3217b48:	e0bffe17 	ldw	r2,-8(fp)
 3217b4c:	1004c03a 	cmpne	r2,r2,zero
 3217b50:	1000021e 	bne	r2,zero,3217b5c <OSFlagCreate+0x2c>
        return ((OS_FLAG_GRP *)0);
 3217b54:	e03fff15 	stw	zero,-4(fp)
 3217b58:	00003f06 	br	3217c58 <OSFlagCreate+0x128>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
 3217b5c:	0080c974 	movhi	r2,805
 3217b60:	10931404 	addi	r2,r2,19536
 3217b64:	10800003 	ldbu	r2,0(r2)
 3217b68:	10803fcc 	andi	r2,r2,255
 3217b6c:	1005003a 	cmpeq	r2,r2,zero
 3217b70:	1000051e 	bne	r2,zero,3217b88 <OSFlagCreate+0x58>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
 3217b74:	e0fffe17 	ldw	r3,-8(fp)
 3217b78:	00800404 	movi	r2,16
 3217b7c:	18800005 	stb	r2,0(r3)
        return ((OS_FLAG_GRP *)0);
 3217b80:	e03fff15 	stw	zero,-4(fp)
 3217b84:	00003406 	br	3217c58 <OSFlagCreate+0x128>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3217b88:	0005303a 	rdctl	r2,status
 3217b8c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3217b90:	e0fffa17 	ldw	r3,-24(fp)
 3217b94:	00bfff84 	movi	r2,-2
 3217b98:	1884703a 	and	r2,r3,r2
 3217b9c:	1001703a 	wrctl	status,r2
  
  return context;
 3217ba0:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 3217ba4:	e0bffb15 	stw	r2,-20(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
 3217ba8:	0080c974 	movhi	r2,805
 3217bac:	10931704 	addi	r2,r2,19548
 3217bb0:	10800017 	ldw	r2,0(r2)
 3217bb4:	e0bffc15 	stw	r2,-16(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
 3217bb8:	e0bffc17 	ldw	r2,-16(fp)
 3217bbc:	1005003a 	cmpeq	r2,r2,zero
 3217bc0:	10001c1e 	bne	r2,zero,3217c34 <OSFlagCreate+0x104>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
 3217bc4:	0080c974 	movhi	r2,805
 3217bc8:	10931704 	addi	r2,r2,19548
 3217bcc:	10800017 	ldw	r2,0(r2)
 3217bd0:	10800117 	ldw	r2,4(r2)
 3217bd4:	1007883a 	mov	r3,r2
 3217bd8:	0080c974 	movhi	r2,805
 3217bdc:	10931704 	addi	r2,r2,19548
 3217be0:	10c00015 	stw	r3,0(r2)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
 3217be4:	e0fffc17 	ldw	r3,-16(fp)
 3217be8:	00800144 	movi	r2,5
 3217bec:	18800005 	stb	r2,0(r3)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
 3217bf0:	e0fffc17 	ldw	r3,-16(fp)
 3217bf4:	e0bffd0b 	ldhu	r2,-12(fp)
 3217bf8:	1880020d 	sth	r2,8(r3)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
 3217bfc:	e0bffc17 	ldw	r2,-16(fp)
 3217c00:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
 3217c04:	e0fffc17 	ldw	r3,-16(fp)
 3217c08:	00800fc4 	movi	r2,63
 3217c0c:	18800285 	stb	r2,10(r3)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 3217c10:	e0bffc17 	ldw	r2,-16(fp)
 3217c14:	100002c5 	stb	zero,11(r2)
 3217c18:	e0bffb17 	ldw	r2,-20(fp)
 3217c1c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3217c20:	e0bff917 	ldw	r2,-28(fp)
 3217c24:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
 3217c28:	e0bffe17 	ldw	r2,-8(fp)
 3217c2c:	10000005 	stb	zero,0(r2)
 3217c30:	00000706 	br	3217c50 <OSFlagCreate+0x120>
 3217c34:	e0bffb17 	ldw	r2,-20(fp)
 3217c38:	e0bff815 	stw	r2,-32(fp)
 3217c3c:	e0bff817 	ldw	r2,-32(fp)
 3217c40:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
 3217c44:	e0fffe17 	ldw	r3,-8(fp)
 3217c48:	00801c84 	movi	r2,114
 3217c4c:	18800005 	stb	r2,0(r3)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
 3217c50:	e0bffc17 	ldw	r2,-16(fp)
 3217c54:	e0bfff15 	stw	r2,-4(fp)
 3217c58:	e0bfff17 	ldw	r2,-4(fp)
}
 3217c5c:	e037883a 	mov	sp,fp
 3217c60:	df000017 	ldw	fp,0(sp)
 3217c64:	dec00104 	addi	sp,sp,4
 3217c68:	f800283a 	ret

03217c6c <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
 3217c6c:	defff004 	addi	sp,sp,-64
 3217c70:	dfc00f15 	stw	ra,60(sp)
 3217c74:	df000e15 	stw	fp,56(sp)
 3217c78:	df000e04 	addi	fp,sp,56
 3217c7c:	e13ffb15 	stw	r4,-20(fp)
 3217c80:	e1bffd15 	stw	r6,-12(fp)
 3217c84:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 3217c88:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 3217c8c:	e0bffd17 	ldw	r2,-12(fp)
 3217c90:	1004c03a 	cmpne	r2,r2,zero
 3217c94:	1000031e 	bne	r2,zero,3217ca4 <OSFlagDel+0x38>
        return (pgrp);
 3217c98:	e0bffb17 	ldw	r2,-20(fp)
 3217c9c:	e0bfff15 	stw	r2,-4(fp)
 3217ca0:	00009606 	br	3217efc <OSFlagDel+0x290>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 3217ca4:	e0bffb17 	ldw	r2,-20(fp)
 3217ca8:	1004c03a 	cmpne	r2,r2,zero
 3217cac:	1000061e 	bne	r2,zero,3217cc8 <OSFlagDel+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 3217cb0:	e0fffd17 	ldw	r3,-12(fp)
 3217cb4:	00801b84 	movi	r2,110
 3217cb8:	18800005 	stb	r2,0(r3)
        return (pgrp);
 3217cbc:	e0fffb17 	ldw	r3,-20(fp)
 3217cc0:	e0ffff15 	stw	r3,-4(fp)
 3217cc4:	00008d06 	br	3217efc <OSFlagDel+0x290>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 3217cc8:	0080c974 	movhi	r2,805
 3217ccc:	10931404 	addi	r2,r2,19536
 3217cd0:	10800003 	ldbu	r2,0(r2)
 3217cd4:	10803fcc 	andi	r2,r2,255
 3217cd8:	1005003a 	cmpeq	r2,r2,zero
 3217cdc:	1000061e 	bne	r2,zero,3217cf8 <OSFlagDel+0x8c>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 3217ce0:	e0fffd17 	ldw	r3,-12(fp)
 3217ce4:	008003c4 	movi	r2,15
 3217ce8:	18800005 	stb	r2,0(r3)
        return (pgrp);
 3217cec:	e0bffb17 	ldw	r2,-20(fp)
 3217cf0:	e0bfff15 	stw	r2,-4(fp)
 3217cf4:	00008106 	br	3217efc <OSFlagDel+0x290>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
 3217cf8:	e0bffb17 	ldw	r2,-20(fp)
 3217cfc:	10800003 	ldbu	r2,0(r2)
 3217d00:	10803fcc 	andi	r2,r2,255
 3217d04:	10800160 	cmpeqi	r2,r2,5
 3217d08:	1000061e 	bne	r2,zero,3217d24 <OSFlagDel+0xb8>
        *perr = OS_ERR_EVENT_TYPE;
 3217d0c:	e0fffd17 	ldw	r3,-12(fp)
 3217d10:	00800044 	movi	r2,1
 3217d14:	18800005 	stb	r2,0(r3)
        return (pgrp);
 3217d18:	e0fffb17 	ldw	r3,-20(fp)
 3217d1c:	e0ffff15 	stw	r3,-4(fp)
 3217d20:	00007606 	br	3217efc <OSFlagDel+0x290>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3217d24:	0005303a 	rdctl	r2,status
 3217d28:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3217d2c:	e0fff617 	ldw	r3,-40(fp)
 3217d30:	00bfff84 	movi	r2,-2
 3217d34:	1884703a 	and	r2,r3,r2
 3217d38:	1001703a 	wrctl	status,r2
  
  return context;
 3217d3c:	e0bff617 	ldw	r2,-40(fp)
    }
    OS_ENTER_CRITICAL();
 3217d40:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
 3217d44:	e0bffb17 	ldw	r2,-20(fp)
 3217d48:	10800117 	ldw	r2,4(r2)
 3217d4c:	1005003a 	cmpeq	r2,r2,zero
 3217d50:	1000031e 	bne	r2,zero,3217d60 <OSFlagDel+0xf4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 3217d54:	00800044 	movi	r2,1
 3217d58:	e0bffa05 	stb	r2,-24(fp)
 3217d5c:	00000106 	br	3217d64 <OSFlagDel+0xf8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 3217d60:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 3217d64:	e0bffc03 	ldbu	r2,-16(fp)
 3217d68:	e0bffe15 	stw	r2,-8(fp)
 3217d6c:	e0fffe17 	ldw	r3,-8(fp)
 3217d70:	1805003a 	cmpeq	r2,r3,zero
 3217d74:	1000041e 	bne	r2,zero,3217d88 <OSFlagDel+0x11c>
 3217d78:	e0fffe17 	ldw	r3,-8(fp)
 3217d7c:	18800060 	cmpeqi	r2,r3,1
 3217d80:	1000281e 	bne	r2,zero,3217e24 <OSFlagDel+0x1b8>
 3217d84:	00005206 	br	3217ed0 <OSFlagDel+0x264>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
 3217d88:	e0bffa03 	ldbu	r2,-24(fp)
 3217d8c:	1004c03a 	cmpne	r2,r2,zero
 3217d90:	10001a1e 	bne	r2,zero,3217dfc <OSFlagDel+0x190>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
 3217d94:	e0fffb17 	ldw	r3,-20(fp)
 3217d98:	00800fc4 	movi	r2,63
 3217d9c:	18800285 	stb	r2,10(r3)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 3217da0:	e0bffb17 	ldw	r2,-20(fp)
 3217da4:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 3217da8:	e0bffb17 	ldw	r2,-20(fp)
 3217dac:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
 3217db0:	0080c974 	movhi	r2,805
 3217db4:	10931704 	addi	r2,r2,19548
 3217db8:	10c00017 	ldw	r3,0(r2)
 3217dbc:	e0bffb17 	ldw	r2,-20(fp)
 3217dc0:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
 3217dc4:	e0bffb17 	ldw	r2,-20(fp)
 3217dc8:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
 3217dcc:	00c0c974 	movhi	r3,805
 3217dd0:	18d31704 	addi	r3,r3,19548
 3217dd4:	e0bffb17 	ldw	r2,-20(fp)
 3217dd8:	18800015 	stw	r2,0(r3)
 3217ddc:	e0bff717 	ldw	r2,-36(fp)
 3217de0:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3217de4:	e0bff517 	ldw	r2,-44(fp)
 3217de8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
 3217dec:	e0bffd17 	ldw	r2,-12(fp)
 3217df0:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
 3217df4:	e03ff815 	stw	zero,-32(fp)
 3217df8:	00003e06 	br	3217ef4 <OSFlagDel+0x288>
 3217dfc:	e0bff717 	ldw	r2,-36(fp)
 3217e00:	e0bff415 	stw	r2,-48(fp)
 3217e04:	e0bff417 	ldw	r2,-48(fp)
 3217e08:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
 3217e0c:	e0fffd17 	ldw	r3,-12(fp)
 3217e10:	00801244 	movi	r2,73
 3217e14:	18800005 	stb	r2,0(r3)
                 pgrp_return          = pgrp;
 3217e18:	e0bffb17 	ldw	r2,-20(fp)
 3217e1c:	e0bff815 	stw	r2,-32(fp)
             }
             break;
 3217e20:	00003406 	br	3217ef4 <OSFlagDel+0x288>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 3217e24:	e0bffb17 	ldw	r2,-20(fp)
 3217e28:	10800117 	ldw	r2,4(r2)
 3217e2c:	e0bff915 	stw	r2,-28(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 3217e30:	00000606 	br	3217e4c <OSFlagDel+0x1e0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
 3217e34:	e13ff917 	ldw	r4,-28(fp)
 3217e38:	000b883a 	mov	r5,zero
 3217e3c:	3218f7c0 	call	3218f7c <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 3217e40:	e0bff917 	ldw	r2,-28(fp)
 3217e44:	10800017 	ldw	r2,0(r2)
 3217e48:	e0bff915 	stw	r2,-28(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 3217e4c:	e0bff917 	ldw	r2,-28(fp)
 3217e50:	1004c03a 	cmpne	r2,r2,zero
 3217e54:	103ff71e 	bne	r2,zero,3217e34 <OSFlagDel+0x1c8>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
 3217e58:	e0fffb17 	ldw	r3,-20(fp)
 3217e5c:	00800fc4 	movi	r2,63
 3217e60:	18800285 	stb	r2,10(r3)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 3217e64:	e0bffb17 	ldw	r2,-20(fp)
 3217e68:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 3217e6c:	e0bffb17 	ldw	r2,-20(fp)
 3217e70:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
 3217e74:	0080c974 	movhi	r2,805
 3217e78:	10931704 	addi	r2,r2,19548
 3217e7c:	10c00017 	ldw	r3,0(r2)
 3217e80:	e0bffb17 	ldw	r2,-20(fp)
 3217e84:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
 3217e88:	e0bffb17 	ldw	r2,-20(fp)
 3217e8c:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
 3217e90:	00c0c974 	movhi	r3,805
 3217e94:	18d31704 	addi	r3,r3,19548
 3217e98:	e0bffb17 	ldw	r2,-20(fp)
 3217e9c:	18800015 	stw	r2,0(r3)
 3217ea0:	e0bff717 	ldw	r2,-36(fp)
 3217ea4:	e0bff315 	stw	r2,-52(fp)
 3217ea8:	e0bff317 	ldw	r2,-52(fp)
 3217eac:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 3217eb0:	e0bffa03 	ldbu	r2,-24(fp)
 3217eb4:	10800058 	cmpnei	r2,r2,1
 3217eb8:	1000011e 	bne	r2,zero,3217ec0 <OSFlagDel+0x254>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 3217ebc:	3216f880 	call	3216f88 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
 3217ec0:	e0bffd17 	ldw	r2,-12(fp)
 3217ec4:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
 3217ec8:	e03ff815 	stw	zero,-32(fp)
             break;
 3217ecc:	00000906 	br	3217ef4 <OSFlagDel+0x288>
 3217ed0:	e0bff717 	ldw	r2,-36(fp)
 3217ed4:	e0bff215 	stw	r2,-56(fp)
 3217ed8:	e0bff217 	ldw	r2,-56(fp)
 3217edc:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
 3217ee0:	e0fffd17 	ldw	r3,-12(fp)
 3217ee4:	008001c4 	movi	r2,7
 3217ee8:	18800005 	stb	r2,0(r3)
             pgrp_return          = pgrp;
 3217eec:	e0bffb17 	ldw	r2,-20(fp)
 3217ef0:	e0bff815 	stw	r2,-32(fp)
             break;
    }
    return (pgrp_return);
 3217ef4:	e0bff817 	ldw	r2,-32(fp)
 3217ef8:	e0bfff15 	stw	r2,-4(fp)
 3217efc:	e0bfff17 	ldw	r2,-4(fp)
}
 3217f00:	e037883a 	mov	sp,fp
 3217f04:	dfc00117 	ldw	ra,4(sp)
 3217f08:	df000017 	ldw	fp,0(sp)
 3217f0c:	dec00204 	addi	sp,sp,8
 3217f10:	f800283a 	ret

03217f14 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 3217f14:	defff504 	addi	sp,sp,-44
 3217f18:	dfc00a15 	stw	ra,40(sp)
 3217f1c:	df000915 	stw	fp,36(sp)
 3217f20:	df000904 	addi	fp,sp,36
 3217f24:	e13ffc15 	stw	r4,-16(fp)
 3217f28:	e17ffd15 	stw	r5,-12(fp)
 3217f2c:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3217f30:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 3217f34:	e0bffe17 	ldw	r2,-8(fp)
 3217f38:	1004c03a 	cmpne	r2,r2,zero
 3217f3c:	1000021e 	bne	r2,zero,3217f48 <OSFlagNameGet+0x34>
        return (0);
 3217f40:	e03fff15 	stw	zero,-4(fp)
 3217f44:	00003e06 	br	3218040 <OSFlagNameGet+0x12c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 3217f48:	e0bffc17 	ldw	r2,-16(fp)
 3217f4c:	1004c03a 	cmpne	r2,r2,zero
 3217f50:	1000051e 	bne	r2,zero,3217f68 <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 3217f54:	e0fffe17 	ldw	r3,-8(fp)
 3217f58:	00801b84 	movi	r2,110
 3217f5c:	18800005 	stb	r2,0(r3)
        return (0);
 3217f60:	e03fff15 	stw	zero,-4(fp)
 3217f64:	00003606 	br	3218040 <OSFlagNameGet+0x12c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 3217f68:	e0bffd17 	ldw	r2,-12(fp)
 3217f6c:	1004c03a 	cmpne	r2,r2,zero
 3217f70:	1000051e 	bne	r2,zero,3217f88 <OSFlagNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 3217f74:	e0fffe17 	ldw	r3,-8(fp)
 3217f78:	00800304 	movi	r2,12
 3217f7c:	18800005 	stb	r2,0(r3)
        return (0);
 3217f80:	e03fff15 	stw	zero,-4(fp)
 3217f84:	00002e06 	br	3218040 <OSFlagNameGet+0x12c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 3217f88:	0080c974 	movhi	r2,805
 3217f8c:	10931404 	addi	r2,r2,19536
 3217f90:	10800003 	ldbu	r2,0(r2)
 3217f94:	10803fcc 	andi	r2,r2,255
 3217f98:	1005003a 	cmpeq	r2,r2,zero
 3217f9c:	1000051e 	bne	r2,zero,3217fb4 <OSFlagNameGet+0xa0>
        *perr = OS_ERR_NAME_GET_ISR;
 3217fa0:	e0fffe17 	ldw	r3,-8(fp)
 3217fa4:	00800444 	movi	r2,17
 3217fa8:	18800005 	stb	r2,0(r3)
        return (0);
 3217fac:	e03fff15 	stw	zero,-4(fp)
 3217fb0:	00002306 	br	3218040 <OSFlagNameGet+0x12c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3217fb4:	0005303a 	rdctl	r2,status
 3217fb8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3217fbc:	e0fff917 	ldw	r3,-28(fp)
 3217fc0:	00bfff84 	movi	r2,-2
 3217fc4:	1884703a 	and	r2,r3,r2
 3217fc8:	1001703a 	wrctl	status,r2
  
  return context;
 3217fcc:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 3217fd0:	e0bffa15 	stw	r2,-24(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 3217fd4:	e0bffc17 	ldw	r2,-16(fp)
 3217fd8:	10800003 	ldbu	r2,0(r2)
 3217fdc:	10803fcc 	andi	r2,r2,255
 3217fe0:	10800160 	cmpeqi	r2,r2,5
 3217fe4:	1000091e 	bne	r2,zero,321800c <OSFlagNameGet+0xf8>
 3217fe8:	e0bffa17 	ldw	r2,-24(fp)
 3217fec:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3217ff0:	e0bff817 	ldw	r2,-32(fp)
 3217ff4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 3217ff8:	e0fffe17 	ldw	r3,-8(fp)
 3217ffc:	00800044 	movi	r2,1
 3218000:	18800005 	stb	r2,0(r3)
        return (0);
 3218004:	e03fff15 	stw	zero,-4(fp)
 3218008:	00000d06 	br	3218040 <OSFlagNameGet+0x12c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
 321800c:	e0bffc17 	ldw	r2,-16(fp)
 3218010:	11400284 	addi	r5,r2,10
 3218014:	e13ffd17 	ldw	r4,-12(fp)
 3218018:	32170cc0 	call	32170cc <OS_StrCopy>
 321801c:	e0bffb05 	stb	r2,-20(fp)
 3218020:	e0bffa17 	ldw	r2,-24(fp)
 3218024:	e0bff715 	stw	r2,-36(fp)
 3218028:	e0bff717 	ldw	r2,-36(fp)
 321802c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 3218030:	e0bffe17 	ldw	r2,-8(fp)
 3218034:	10000005 	stb	zero,0(r2)
    return (len);
 3218038:	e0bffb03 	ldbu	r2,-20(fp)
 321803c:	e0bfff15 	stw	r2,-4(fp)
 3218040:	e0bfff17 	ldw	r2,-4(fp)
}
 3218044:	e037883a 	mov	sp,fp
 3218048:	dfc00117 	ldw	ra,4(sp)
 321804c:	df000017 	ldw	fp,0(sp)
 3218050:	dec00204 	addi	sp,sp,8
 3218054:	f800283a 	ret

03218058 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 3218058:	defff504 	addi	sp,sp,-44
 321805c:	dfc00a15 	stw	ra,40(sp)
 3218060:	df000915 	stw	fp,36(sp)
 3218064:	df000904 	addi	fp,sp,36
 3218068:	e13ffd15 	stw	r4,-12(fp)
 321806c:	e17ffe15 	stw	r5,-8(fp)
 3218070:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3218074:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 3218078:	e0bfff17 	ldw	r2,-4(fp)
 321807c:	1005003a 	cmpeq	r2,r2,zero
 3218080:	1000451e 	bne	r2,zero,3218198 <OSFlagNameSet+0x140>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 3218084:	e0bffd17 	ldw	r2,-12(fp)
 3218088:	1004c03a 	cmpne	r2,r2,zero
 321808c:	1000041e 	bne	r2,zero,32180a0 <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 3218090:	e0ffff17 	ldw	r3,-4(fp)
 3218094:	00801b84 	movi	r2,110
 3218098:	18800005 	stb	r2,0(r3)
        return;
 321809c:	00003e06 	br	3218198 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 32180a0:	e0bffe17 	ldw	r2,-8(fp)
 32180a4:	1004c03a 	cmpne	r2,r2,zero
 32180a8:	1000041e 	bne	r2,zero,32180bc <OSFlagNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 32180ac:	e0ffff17 	ldw	r3,-4(fp)
 32180b0:	00800304 	movi	r2,12
 32180b4:	18800005 	stb	r2,0(r3)
        return;
 32180b8:	00003706 	br	3218198 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 32180bc:	0080c974 	movhi	r2,805
 32180c0:	10931404 	addi	r2,r2,19536
 32180c4:	10800003 	ldbu	r2,0(r2)
 32180c8:	10803fcc 	andi	r2,r2,255
 32180cc:	1005003a 	cmpeq	r2,r2,zero
 32180d0:	1000041e 	bne	r2,zero,32180e4 <OSFlagNameSet+0x8c>
        *perr = OS_ERR_NAME_SET_ISR;
 32180d4:	e0ffff17 	ldw	r3,-4(fp)
 32180d8:	00800484 	movi	r2,18
 32180dc:	18800005 	stb	r2,0(r3)
        return;
 32180e0:	00002d06 	br	3218198 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32180e4:	0005303a 	rdctl	r2,status
 32180e8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32180ec:	e0fffa17 	ldw	r3,-24(fp)
 32180f0:	00bfff84 	movi	r2,-2
 32180f4:	1884703a 	and	r2,r3,r2
 32180f8:	1001703a 	wrctl	status,r2
  
  return context;
 32180fc:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 3218100:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 3218104:	e0bffd17 	ldw	r2,-12(fp)
 3218108:	10800003 	ldbu	r2,0(r2)
 321810c:	10803fcc 	andi	r2,r2,255
 3218110:	10800160 	cmpeqi	r2,r2,5
 3218114:	1000081e 	bne	r2,zero,3218138 <OSFlagNameSet+0xe0>
 3218118:	e0bffb17 	ldw	r2,-20(fp)
 321811c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3218120:	e0bff917 	ldw	r2,-28(fp)
 3218124:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 3218128:	e0ffff17 	ldw	r3,-4(fp)
 321812c:	00800044 	movi	r2,1
 3218130:	18800005 	stb	r2,0(r3)
        return;
 3218134:	00001806 	br	3218198 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 3218138:	e13ffe17 	ldw	r4,-8(fp)
 321813c:	321714c0 	call	321714c <OS_StrLen>
 3218140:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
 3218144:	e0bffc03 	ldbu	r2,-16(fp)
 3218148:	10800830 	cmpltui	r2,r2,32
 321814c:	1000081e 	bne	r2,zero,3218170 <OSFlagNameSet+0x118>
 3218150:	e0bffb17 	ldw	r2,-20(fp)
 3218154:	e0bff815 	stw	r2,-32(fp)
 3218158:	e0bff817 	ldw	r2,-32(fp)
 321815c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
 3218160:	e0ffff17 	ldw	r3,-4(fp)
 3218164:	00801cc4 	movi	r2,115
 3218168:	18800005 	stb	r2,0(r3)
        return;
 321816c:	00000a06 	br	3218198 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
 3218170:	e0bffd17 	ldw	r2,-12(fp)
 3218174:	11000284 	addi	r4,r2,10
 3218178:	e17ffe17 	ldw	r5,-8(fp)
 321817c:	32170cc0 	call	32170cc <OS_StrCopy>
 3218180:	e0bffb17 	ldw	r2,-20(fp)
 3218184:	e0bff715 	stw	r2,-36(fp)
 3218188:	e0bff717 	ldw	r2,-36(fp)
 321818c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 3218190:	e0bfff17 	ldw	r2,-4(fp)
 3218194:	10000005 	stb	zero,0(r2)
    return;
}
 3218198:	e037883a 	mov	sp,fp
 321819c:	dfc00117 	ldw	ra,4(sp)
 32181a0:	df000017 	ldw	fp,0(sp)
 32181a4:	dec00204 	addi	sp,sp,8
 32181a8:	f800283a 	ret

032181ac <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
 32181ac:	deffe004 	addi	sp,sp,-128
 32181b0:	dfc01f15 	stw	ra,124(sp)
 32181b4:	df001e15 	stw	fp,120(sp)
 32181b8:	df001e04 	addi	fp,sp,120
 32181bc:	e13ff915 	stw	r4,-28(fp)
 32181c0:	e17ffa0d 	sth	r5,-24(fp)
 32181c4:	e1bffb05 	stb	r6,-20(fp)
 32181c8:	e1fffc0d 	sth	r7,-16(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 32181cc:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 32181d0:	e0800217 	ldw	r2,8(fp)
 32181d4:	1004c03a 	cmpne	r2,r2,zero
 32181d8:	1000021e 	bne	r2,zero,32181e4 <OSFlagPend+0x38>
        return ((OS_FLAGS)0);
 32181dc:	e03fff15 	stw	zero,-4(fp)
 32181e0:	00017d06 	br	32187d8 <OSFlagPend+0x62c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 32181e4:	e0bff917 	ldw	r2,-28(fp)
 32181e8:	1004c03a 	cmpne	r2,r2,zero
 32181ec:	1000051e 	bne	r2,zero,3218204 <OSFlagPend+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 32181f0:	e0c00217 	ldw	r3,8(fp)
 32181f4:	00801b84 	movi	r2,110
 32181f8:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 32181fc:	e03fff15 	stw	zero,-4(fp)
 3218200:	00017506 	br	32187d8 <OSFlagPend+0x62c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 3218204:	0080c974 	movhi	r2,805
 3218208:	10931404 	addi	r2,r2,19536
 321820c:	10800003 	ldbu	r2,0(r2)
 3218210:	10803fcc 	andi	r2,r2,255
 3218214:	1005003a 	cmpeq	r2,r2,zero
 3218218:	1000051e 	bne	r2,zero,3218230 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
 321821c:	e0c00217 	ldw	r3,8(fp)
 3218220:	00800084 	movi	r2,2
 3218224:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 3218228:	e03fff15 	stw	zero,-4(fp)
 321822c:	00016a06 	br	32187d8 <OSFlagPend+0x62c>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
 3218230:	0080c974 	movhi	r2,805
 3218234:	10930604 	addi	r2,r2,19480
 3218238:	10800003 	ldbu	r2,0(r2)
 321823c:	10803fcc 	andi	r2,r2,255
 3218240:	1005003a 	cmpeq	r2,r2,zero
 3218244:	1000051e 	bne	r2,zero,321825c <OSFlagPend+0xb0>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
 3218248:	e0c00217 	ldw	r3,8(fp)
 321824c:	00800344 	movi	r2,13
 3218250:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 3218254:	e03fff15 	stw	zero,-4(fp)
 3218258:	00015f06 	br	32187d8 <OSFlagPend+0x62c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 321825c:	e0bff917 	ldw	r2,-28(fp)
 3218260:	10800003 	ldbu	r2,0(r2)
 3218264:	10803fcc 	andi	r2,r2,255
 3218268:	10800160 	cmpeqi	r2,r2,5
 321826c:	1000051e 	bne	r2,zero,3218284 <OSFlagPend+0xd8>
        *perr = OS_ERR_EVENT_TYPE;
 3218270:	e0c00217 	ldw	r3,8(fp)
 3218274:	00800044 	movi	r2,1
 3218278:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 321827c:	e03fff15 	stw	zero,-4(fp)
 3218280:	00015506 	br	32187d8 <OSFlagPend+0x62c>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 3218284:	e0fffb03 	ldbu	r3,-20(fp)
 3218288:	00bfe004 	movi	r2,-128
 321828c:	1884703a 	and	r2,r3,r2
 3218290:	e0bff285 	stb	r2,-54(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
 3218294:	e0bff283 	ldbu	r2,-54(fp)
 3218298:	1005003a 	cmpeq	r2,r2,zero
 321829c:	1000071e 	bne	r2,zero,32182bc <OSFlagPend+0x110>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
 32182a0:	00c01fc4 	movi	r3,127
 32182a4:	e0bffb03 	ldbu	r2,-20(fp)
 32182a8:	10c4703a 	and	r2,r2,r3
 32182ac:	e0bffb05 	stb	r2,-20(fp)
        consume    = OS_TRUE;
 32182b0:	00800044 	movi	r2,1
 32182b4:	e0bff205 	stb	r2,-56(fp)
 32182b8:	00000106 	br	32182c0 <OSFlagPend+0x114>
    } else {
        consume    = OS_FALSE;
 32182bc:	e03ff205 	stb	zero,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32182c0:	0005303a 	rdctl	r2,status
 32182c4:	e0bff015 	stw	r2,-64(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32182c8:	e0fff017 	ldw	r3,-64(fp)
 32182cc:	00bfff84 	movi	r2,-2
 32182d0:	1884703a 	and	r2,r3,r2
 32182d4:	1001703a 	wrctl	status,r2
  
  return context;
 32182d8:	e0bff017 	ldw	r2,-64(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 32182dc:	e0bff115 	stw	r2,-60(fp)
    switch (wait_type) {
 32182e0:	e0bffb03 	ldbu	r2,-20(fp)
 32182e4:	e0bffe15 	stw	r2,-8(fp)
 32182e8:	e0fffe17 	ldw	r3,-8(fp)
 32182ec:	18800060 	cmpeqi	r2,r3,1
 32182f0:	1000981e 	bne	r2,zero,3218554 <OSFlagPend+0x3a8>
 32182f4:	e0fffe17 	ldw	r3,-8(fp)
 32182f8:	18800088 	cmpgei	r2,r3,2
 32182fc:	1000041e 	bne	r2,zero,3218310 <OSFlagPend+0x164>
 3218300:	e0fffe17 	ldw	r3,-8(fp)
 3218304:	1805003a 	cmpeq	r2,r3,zero
 3218308:	1000641e 	bne	r2,zero,321849c <OSFlagPend+0x2f0>
 321830c:	0000bf06 	br	321860c <OSFlagPend+0x460>
 3218310:	e0fffe17 	ldw	r3,-8(fp)
 3218314:	188000a0 	cmpeqi	r2,r3,2
 3218318:	1000041e 	bne	r2,zero,321832c <OSFlagPend+0x180>
 321831c:	e0fffe17 	ldw	r3,-8(fp)
 3218320:	188000e0 	cmpeqi	r2,r3,3
 3218324:	10002f1e 	bne	r2,zero,32183e4 <OSFlagPend+0x238>
 3218328:	0000b806 	br	321860c <OSFlagPend+0x460>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
 321832c:	e0bff917 	ldw	r2,-28(fp)
 3218330:	10c0020b 	ldhu	r3,8(r2)
 3218334:	e0bffa0b 	ldhu	r2,-24(fp)
 3218338:	1884703a 	and	r2,r3,r2
 321833c:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 3218340:	e0fff30b 	ldhu	r3,-52(fp)
 3218344:	e0bffa0b 	ldhu	r2,-24(fp)
 3218348:	18801a1e 	bne	r3,r2,32183b4 <OSFlagPend+0x208>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 321834c:	e0bff203 	ldbu	r2,-56(fp)
 3218350:	10800058 	cmpnei	r2,r2,1
 3218354:	1000091e 	bne	r2,zero,321837c <OSFlagPend+0x1d0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 3218358:	e0bff917 	ldw	r2,-28(fp)
 321835c:	1080020b 	ldhu	r2,8(r2)
 3218360:	1007883a 	mov	r3,r2
 3218364:	e0bff30b 	ldhu	r2,-52(fp)
 3218368:	0084303a 	nor	r2,zero,r2
 321836c:	1884703a 	and	r2,r3,r2
 3218370:	1007883a 	mov	r3,r2
 3218374:	e0bff917 	ldw	r2,-28(fp)
 3218378:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 321837c:	0080c974 	movhi	r2,805
 3218380:	10931504 	addi	r2,r2,19540
 3218384:	10c00017 	ldw	r3,0(r2)
 3218388:	e0bff30b 	ldhu	r2,-52(fp)
 321838c:	18800b0d 	sth	r2,44(r3)
 3218390:	e0bff117 	ldw	r2,-60(fp)
 3218394:	e0bfef15 	stw	r2,-68(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3218398:	e0bfef17 	ldw	r2,-68(fp)
 321839c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 32183a0:	e0800217 	ldw	r2,8(fp)
 32183a4:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 32183a8:	e0bff30b 	ldhu	r2,-52(fp)
 32183ac:	e0bfff15 	stw	r2,-4(fp)
 32183b0:	00010906 	br	32187d8 <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 32183b4:	e1bffa0b 	ldhu	r6,-24(fp)
 32183b8:	e1fffb03 	ldbu	r7,-20(fp)
 32183bc:	e0bffc0b 	ldhu	r2,-16(fp)
 32183c0:	e17ff404 	addi	r5,fp,-48
 32183c4:	d8800015 	stw	r2,0(sp)
 32183c8:	e13ff917 	ldw	r4,-28(fp)
 32183cc:	3218cd40 	call	3218cd4 <OS_FlagBlock>
 32183d0:	e0bff117 	ldw	r2,-60(fp)
 32183d4:	e0bfee15 	stw	r2,-72(fp)
 32183d8:	e0bfee17 	ldw	r2,-72(fp)
 32183dc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 32183e0:	00009506 	br	3218638 <OSFlagPend+0x48c>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
 32183e4:	e0bff917 	ldw	r2,-28(fp)
 32183e8:	10c0020b 	ldhu	r3,8(r2)
 32183ec:	e0bffa0b 	ldhu	r2,-24(fp)
 32183f0:	1884703a 	and	r2,r3,r2
 32183f4:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 32183f8:	e0bff30b 	ldhu	r2,-52(fp)
 32183fc:	1005003a 	cmpeq	r2,r2,zero
 3218400:	10001a1e 	bne	r2,zero,321846c <OSFlagPend+0x2c0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 3218404:	e0bff203 	ldbu	r2,-56(fp)
 3218408:	10800058 	cmpnei	r2,r2,1
 321840c:	1000091e 	bne	r2,zero,3218434 <OSFlagPend+0x288>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 3218410:	e0bff917 	ldw	r2,-28(fp)
 3218414:	1080020b 	ldhu	r2,8(r2)
 3218418:	1007883a 	mov	r3,r2
 321841c:	e0bff30b 	ldhu	r2,-52(fp)
 3218420:	0084303a 	nor	r2,zero,r2
 3218424:	1884703a 	and	r2,r3,r2
 3218428:	1007883a 	mov	r3,r2
 321842c:	e0bff917 	ldw	r2,-28(fp)
 3218430:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 3218434:	0080c974 	movhi	r2,805
 3218438:	10931504 	addi	r2,r2,19540
 321843c:	10c00017 	ldw	r3,0(r2)
 3218440:	e0bff30b 	ldhu	r2,-52(fp)
 3218444:	18800b0d 	sth	r2,44(r3)
 3218448:	e0bff117 	ldw	r2,-60(fp)
 321844c:	e0bfed15 	stw	r2,-76(fp)
 3218450:	e0bfed17 	ldw	r2,-76(fp)
 3218454:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 3218458:	e0800217 	ldw	r2,8(fp)
 321845c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 3218460:	e0fff30b 	ldhu	r3,-52(fp)
 3218464:	e0ffff15 	stw	r3,-4(fp)
 3218468:	0000db06 	br	32187d8 <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 321846c:	e1bffa0b 	ldhu	r6,-24(fp)
 3218470:	e1fffb03 	ldbu	r7,-20(fp)
 3218474:	e0bffc0b 	ldhu	r2,-16(fp)
 3218478:	e17ff404 	addi	r5,fp,-48
 321847c:	d8800015 	stw	r2,0(sp)
 3218480:	e13ff917 	ldw	r4,-28(fp)
 3218484:	3218cd40 	call	3218cd4 <OS_FlagBlock>
 3218488:	e0bff117 	ldw	r2,-60(fp)
 321848c:	e0bfec15 	stw	r2,-80(fp)
 3218490:	e0bfec17 	ldw	r2,-80(fp)
 3218494:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 3218498:	00006706 	br	3218638 <OSFlagPend+0x48c>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 321849c:	e0bff917 	ldw	r2,-28(fp)
 32184a0:	1080020b 	ldhu	r2,8(r2)
 32184a4:	0084303a 	nor	r2,zero,r2
 32184a8:	1007883a 	mov	r3,r2
 32184ac:	e0bffa0b 	ldhu	r2,-24(fp)
 32184b0:	1884703a 	and	r2,r3,r2
 32184b4:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 32184b8:	e0fff30b 	ldhu	r3,-52(fp)
 32184bc:	e0bffa0b 	ldhu	r2,-24(fp)
 32184c0:	1880181e 	bne	r3,r2,3218524 <OSFlagPend+0x378>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 32184c4:	e0bff203 	ldbu	r2,-56(fp)
 32184c8:	10800058 	cmpnei	r2,r2,1
 32184cc:	1000071e 	bne	r2,zero,32184ec <OSFlagPend+0x340>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 32184d0:	e0bff917 	ldw	r2,-28(fp)
 32184d4:	10c0020b 	ldhu	r3,8(r2)
 32184d8:	e0bff30b 	ldhu	r2,-52(fp)
 32184dc:	1884b03a 	or	r2,r3,r2
 32184e0:	1007883a 	mov	r3,r2
 32184e4:	e0bff917 	ldw	r2,-28(fp)
 32184e8:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 32184ec:	0080c974 	movhi	r2,805
 32184f0:	10931504 	addi	r2,r2,19540
 32184f4:	10c00017 	ldw	r3,0(r2)
 32184f8:	e0bff30b 	ldhu	r2,-52(fp)
 32184fc:	18800b0d 	sth	r2,44(r3)
 3218500:	e0bff117 	ldw	r2,-60(fp)
 3218504:	e0bfeb15 	stw	r2,-84(fp)
 3218508:	e0bfeb17 	ldw	r2,-84(fp)
 321850c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 3218510:	e0800217 	ldw	r2,8(fp)
 3218514:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 3218518:	e0bff30b 	ldhu	r2,-52(fp)
 321851c:	e0bfff15 	stw	r2,-4(fp)
 3218520:	0000ad06 	br	32187d8 <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 3218524:	e1bffa0b 	ldhu	r6,-24(fp)
 3218528:	e1fffb03 	ldbu	r7,-20(fp)
 321852c:	e0bffc0b 	ldhu	r2,-16(fp)
 3218530:	e17ff404 	addi	r5,fp,-48
 3218534:	d8800015 	stw	r2,0(sp)
 3218538:	e13ff917 	ldw	r4,-28(fp)
 321853c:	3218cd40 	call	3218cd4 <OS_FlagBlock>
 3218540:	e0bff117 	ldw	r2,-60(fp)
 3218544:	e0bfea15 	stw	r2,-88(fp)
 3218548:	e0bfea17 	ldw	r2,-88(fp)
 321854c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 3218550:	00003906 	br	3218638 <OSFlagPend+0x48c>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 3218554:	e0bff917 	ldw	r2,-28(fp)
 3218558:	1080020b 	ldhu	r2,8(r2)
 321855c:	0084303a 	nor	r2,zero,r2
 3218560:	1007883a 	mov	r3,r2
 3218564:	e0bffa0b 	ldhu	r2,-24(fp)
 3218568:	1884703a 	and	r2,r3,r2
 321856c:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 3218570:	e0bff30b 	ldhu	r2,-52(fp)
 3218574:	1005003a 	cmpeq	r2,r2,zero
 3218578:	1000181e 	bne	r2,zero,32185dc <OSFlagPend+0x430>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 321857c:	e0bff203 	ldbu	r2,-56(fp)
 3218580:	10800058 	cmpnei	r2,r2,1
 3218584:	1000071e 	bne	r2,zero,32185a4 <OSFlagPend+0x3f8>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 3218588:	e0bff917 	ldw	r2,-28(fp)
 321858c:	10c0020b 	ldhu	r3,8(r2)
 3218590:	e0bff30b 	ldhu	r2,-52(fp)
 3218594:	1884b03a 	or	r2,r3,r2
 3218598:	1007883a 	mov	r3,r2
 321859c:	e0bff917 	ldw	r2,-28(fp)
 32185a0:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 32185a4:	0080c974 	movhi	r2,805
 32185a8:	10931504 	addi	r2,r2,19540
 32185ac:	10c00017 	ldw	r3,0(r2)
 32185b0:	e0bff30b 	ldhu	r2,-52(fp)
 32185b4:	18800b0d 	sth	r2,44(r3)
 32185b8:	e0bff117 	ldw	r2,-60(fp)
 32185bc:	e0bfe915 	stw	r2,-92(fp)
 32185c0:	e0bfe917 	ldw	r2,-92(fp)
 32185c4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 32185c8:	e0800217 	ldw	r2,8(fp)
 32185cc:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 32185d0:	e0fff30b 	ldhu	r3,-52(fp)
 32185d4:	e0ffff15 	stw	r3,-4(fp)
 32185d8:	00007f06 	br	32187d8 <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 32185dc:	e1bffa0b 	ldhu	r6,-24(fp)
 32185e0:	e1fffb03 	ldbu	r7,-20(fp)
 32185e4:	e0bffc0b 	ldhu	r2,-16(fp)
 32185e8:	e17ff404 	addi	r5,fp,-48
 32185ec:	d8800015 	stw	r2,0(sp)
 32185f0:	e13ff917 	ldw	r4,-28(fp)
 32185f4:	3218cd40 	call	3218cd4 <OS_FlagBlock>
 32185f8:	e0bff117 	ldw	r2,-60(fp)
 32185fc:	e0bfe815 	stw	r2,-96(fp)
 3218600:	e0bfe817 	ldw	r2,-96(fp)
 3218604:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 3218608:	00000b06 	br	3218638 <OSFlagPend+0x48c>
 321860c:	e0bff117 	ldw	r2,-60(fp)
 3218610:	e0bfe715 	stw	r2,-100(fp)
 3218614:	e0bfe717 	ldw	r2,-100(fp)
 3218618:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 321861c:	e03ff30d 	sth	zero,-52(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
 3218620:	e0c00217 	ldw	r3,8(fp)
 3218624:	00801bc4 	movi	r2,111
 3218628:	18800005 	stb	r2,0(r3)
             return (flags_rdy);
 321862c:	e0bff30b 	ldhu	r2,-52(fp)
 3218630:	e0bfff15 	stw	r2,-4(fp)
 3218634:	00006806 	br	32187d8 <OSFlagPend+0x62c>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
 3218638:	3216f880 	call	3216f88 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321863c:	0005303a 	rdctl	r2,status
 3218640:	e0bfe615 	stw	r2,-104(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3218644:	e0ffe617 	ldw	r3,-104(fp)
 3218648:	00bfff84 	movi	r2,-2
 321864c:	1884703a 	and	r2,r3,r2
 3218650:	1001703a 	wrctl	status,r2
  
  return context;
 3218654:	e0bfe617 	ldw	r2,-104(fp)
    OS_ENTER_CRITICAL();
 3218658:	e0bff115 	stw	r2,-60(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
 321865c:	0080c974 	movhi	r2,805
 3218660:	10931504 	addi	r2,r2,19540
 3218664:	10800017 	ldw	r2,0(r2)
 3218668:	10800c43 	ldbu	r2,49(r2)
 321866c:	10803fcc 	andi	r2,r2,255
 3218670:	1005003a 	cmpeq	r2,r2,zero
 3218674:	1000221e 	bne	r2,zero,3218700 <OSFlagPend+0x554>
        pend_stat                = OSTCBCur->OSTCBStatPend;
 3218678:	0080c974 	movhi	r2,805
 321867c:	10931504 	addi	r2,r2,19540
 3218680:	10800017 	ldw	r2,0(r2)
 3218684:	10800c43 	ldbu	r2,49(r2)
 3218688:	e0bff245 	stb	r2,-55(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 321868c:	0080c974 	movhi	r2,805
 3218690:	10931504 	addi	r2,r2,19540
 3218694:	10800017 	ldw	r2,0(r2)
 3218698:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
 321869c:	e13ff404 	addi	r4,fp,-48
 32186a0:	321908c0 	call	321908c <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
 32186a4:	0080c974 	movhi	r2,805
 32186a8:	10931504 	addi	r2,r2,19540
 32186ac:	10800017 	ldw	r2,0(r2)
 32186b0:	10000c05 	stb	zero,48(r2)
 32186b4:	e0bff117 	ldw	r2,-60(fp)
 32186b8:	e0bfe515 	stw	r2,-108(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 32186bc:	e0bfe517 	ldw	r2,-108(fp)
 32186c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
 32186c4:	e03ff30d 	sth	zero,-52(fp)
        switch (pend_stat) {
 32186c8:	e0bff243 	ldbu	r2,-55(fp)
 32186cc:	108000a0 	cmpeqi	r2,r2,2
 32186d0:	1000011e 	bne	r2,zero,32186d8 <OSFlagPend+0x52c>
 32186d4:	00000406 	br	32186e8 <OSFlagPend+0x53c>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
 32186d8:	e0c00217 	ldw	r3,8(fp)
 32186dc:	00800384 	movi	r2,14
 32186e0:	18800005 	stb	r2,0(r3)
                 break;
 32186e4:	00000306 	br	32186f4 <OSFlagPend+0x548>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
 32186e8:	e0c00217 	ldw	r3,8(fp)
 32186ec:	00800284 	movi	r2,10
 32186f0:	18800005 	stb	r2,0(r3)
                 break;
        }
        return (flags_rdy);
 32186f4:	e0fff30b 	ldhu	r3,-52(fp)
 32186f8:	e0ffff15 	stw	r3,-4(fp)
 32186fc:	00003606 	br	32187d8 <OSFlagPend+0x62c>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
 3218700:	0080c974 	movhi	r2,805
 3218704:	10931504 	addi	r2,r2,19540
 3218708:	10800017 	ldw	r2,0(r2)
 321870c:	10800b0b 	ldhu	r2,44(r2)
 3218710:	e0bff30d 	sth	r2,-52(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
 3218714:	e0bff203 	ldbu	r2,-56(fp)
 3218718:	10800058 	cmpnei	r2,r2,1
 321871c:	1000261e 	bne	r2,zero,32187b8 <OSFlagPend+0x60c>
        switch (wait_type) {
 3218720:	e0bffb03 	ldbu	r2,-20(fp)
 3218724:	e0bffd15 	stw	r2,-12(fp)
 3218728:	e0fffd17 	ldw	r3,-12(fp)
 321872c:	1804803a 	cmplt	r2,r3,zero
 3218730:	1000181e 	bne	r2,zero,3218794 <OSFlagPend+0x5e8>
 3218734:	e0fffd17 	ldw	r3,-12(fp)
 3218738:	18800090 	cmplti	r2,r3,2
 321873c:	10000d1e 	bne	r2,zero,3218774 <OSFlagPend+0x5c8>
 3218740:	e0fffd17 	ldw	r3,-12(fp)
 3218744:	18800108 	cmpgei	r2,r3,4
 3218748:	1000121e 	bne	r2,zero,3218794 <OSFlagPend+0x5e8>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
 321874c:	e0bff917 	ldw	r2,-28(fp)
 3218750:	1080020b 	ldhu	r2,8(r2)
 3218754:	1007883a 	mov	r3,r2
 3218758:	e0bff30b 	ldhu	r2,-52(fp)
 321875c:	0084303a 	nor	r2,zero,r2
 3218760:	1884703a 	and	r2,r3,r2
 3218764:	1007883a 	mov	r3,r2
 3218768:	e0bff917 	ldw	r2,-28(fp)
 321876c:	10c0020d 	sth	r3,8(r2)
                 break;
 3218770:	00001106 	br	32187b8 <OSFlagPend+0x60c>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
 3218774:	e0bff917 	ldw	r2,-28(fp)
 3218778:	10c0020b 	ldhu	r3,8(r2)
 321877c:	e0bff30b 	ldhu	r2,-52(fp)
 3218780:	1884b03a 	or	r2,r3,r2
 3218784:	1007883a 	mov	r3,r2
 3218788:	e0bff917 	ldw	r2,-28(fp)
 321878c:	10c0020d 	sth	r3,8(r2)
                 break;
 3218790:	00000906 	br	32187b8 <OSFlagPend+0x60c>
 3218794:	e0bff117 	ldw	r2,-60(fp)
 3218798:	e0bfe415 	stw	r2,-112(fp)
 321879c:	e0bfe417 	ldw	r2,-112(fp)
 32187a0:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 32187a4:	e0c00217 	ldw	r3,8(fp)
 32187a8:	00801bc4 	movi	r2,111
 32187ac:	18800005 	stb	r2,0(r3)
                 return ((OS_FLAGS)0);
 32187b0:	e03fff15 	stw	zero,-4(fp)
 32187b4:	00000806 	br	32187d8 <OSFlagPend+0x62c>
 32187b8:	e0bff117 	ldw	r2,-60(fp)
 32187bc:	e0bfe315 	stw	r2,-116(fp)
 32187c0:	e0bfe317 	ldw	r2,-116(fp)
 32187c4:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
 32187c8:	e0800217 	ldw	r2,8(fp)
 32187cc:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
 32187d0:	e0bff30b 	ldhu	r2,-52(fp)
 32187d4:	e0bfff15 	stw	r2,-4(fp)
 32187d8:	e0bfff17 	ldw	r2,-4(fp)
}
 32187dc:	e037883a 	mov	sp,fp
 32187e0:	dfc00117 	ldw	ra,4(sp)
 32187e4:	df000017 	ldw	fp,0(sp)
 32187e8:	dec00204 	addi	sp,sp,8
 32187ec:	f800283a 	ret

032187f0 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
 32187f0:	defffb04 	addi	sp,sp,-20
 32187f4:	df000415 	stw	fp,16(sp)
 32187f8:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 32187fc:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3218800:	0005303a 	rdctl	r2,status
 3218804:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3218808:	e0fffd17 	ldw	r3,-12(fp)
 321880c:	00bfff84 	movi	r2,-2
 3218810:	1884703a 	and	r2,r3,r2
 3218814:	1001703a 	wrctl	status,r2
  
  return context;
 3218818:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 321881c:	e0bffe15 	stw	r2,-8(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
 3218820:	0080c974 	movhi	r2,805
 3218824:	10931504 	addi	r2,r2,19540
 3218828:	10800017 	ldw	r2,0(r2)
 321882c:	10800b0b 	ldhu	r2,44(r2)
 3218830:	e0bfff0d 	sth	r2,-4(fp)
 3218834:	e0bffe17 	ldw	r2,-8(fp)
 3218838:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321883c:	e0bffc17 	ldw	r2,-16(fp)
 3218840:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
 3218844:	e0bfff0b 	ldhu	r2,-4(fp)
}
 3218848:	e037883a 	mov	sp,fp
 321884c:	df000017 	ldw	fp,0(sp)
 3218850:	dec00104 	addi	sp,sp,4
 3218854:	f800283a 	ret

03218858 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
 3218858:	deffed04 	addi	sp,sp,-76
 321885c:	dfc01215 	stw	ra,72(sp)
 3218860:	df001115 	stw	fp,68(sp)
 3218864:	df001104 	addi	fp,sp,68
 3218868:	e13ff915 	stw	r4,-28(fp)
 321886c:	e1fffc15 	stw	r7,-16(fp)
 3218870:	e17ffa0d 	sth	r5,-24(fp)
 3218874:	e1bffb05 	stb	r6,-20(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
 3218878:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 321887c:	e0bffc17 	ldw	r2,-16(fp)
 3218880:	1004c03a 	cmpne	r2,r2,zero
 3218884:	1000021e 	bne	r2,zero,3218890 <OSFlagPost+0x38>
        return ((OS_FLAGS)0);
 3218888:	e03fff15 	stw	zero,-4(fp)
 321888c:	0000d606 	br	3218be8 <OSFlagPost+0x390>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
 3218890:	e0bff917 	ldw	r2,-28(fp)
 3218894:	1004c03a 	cmpne	r2,r2,zero
 3218898:	1000051e 	bne	r2,zero,32188b0 <OSFlagPost+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 321889c:	e0fffc17 	ldw	r3,-16(fp)
 32188a0:	00801b84 	movi	r2,110
 32188a4:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 32188a8:	e03fff15 	stw	zero,-4(fp)
 32188ac:	0000ce06 	br	3218be8 <OSFlagPost+0x390>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
 32188b0:	e0bff917 	ldw	r2,-28(fp)
 32188b4:	10800003 	ldbu	r2,0(r2)
 32188b8:	10803fcc 	andi	r2,r2,255
 32188bc:	10800160 	cmpeqi	r2,r2,5
 32188c0:	1000051e 	bne	r2,zero,32188d8 <OSFlagPost+0x80>
        *perr = OS_ERR_EVENT_TYPE;
 32188c4:	e0fffc17 	ldw	r3,-16(fp)
 32188c8:	00800044 	movi	r2,1
 32188cc:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 32188d0:	e03fff15 	stw	zero,-4(fp)
 32188d4:	0000c406 	br	3218be8 <OSFlagPost+0x390>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32188d8:	0005303a 	rdctl	r2,status
 32188dc:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32188e0:	e0fff417 	ldw	r3,-48(fp)
 32188e4:	00bfff84 	movi	r2,-2
 32188e8:	1884703a 	and	r2,r3,r2
 32188ec:	1001703a 	wrctl	status,r2
  
  return context;
 32188f0:	e0bff417 	ldw	r2,-48(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 32188f4:	e0bff515 	stw	r2,-44(fp)
    switch (opt) {
 32188f8:	e0bffb03 	ldbu	r2,-20(fp)
 32188fc:	e0bffe15 	stw	r2,-8(fp)
 3218900:	e0fffe17 	ldw	r3,-8(fp)
 3218904:	1805003a 	cmpeq	r2,r3,zero
 3218908:	1000041e 	bne	r2,zero,321891c <OSFlagPost+0xc4>
 321890c:	e0fffe17 	ldw	r3,-8(fp)
 3218910:	18800060 	cmpeqi	r2,r3,1
 3218914:	10000b1e 	bne	r2,zero,3218944 <OSFlagPost+0xec>
 3218918:	00001206 	br	3218964 <OSFlagPost+0x10c>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
 321891c:	e0bff917 	ldw	r2,-28(fp)
 3218920:	1080020b 	ldhu	r2,8(r2)
 3218924:	1007883a 	mov	r3,r2
 3218928:	e0bffa0b 	ldhu	r2,-24(fp)
 321892c:	0084303a 	nor	r2,zero,r2
 3218930:	1884703a 	and	r2,r3,r2
 3218934:	1007883a 	mov	r3,r2
 3218938:	e0bff917 	ldw	r2,-28(fp)
 321893c:	10c0020d 	sth	r3,8(r2)
             break;
 3218940:	00001106 	br	3218988 <OSFlagPost+0x130>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
 3218944:	e0bff917 	ldw	r2,-28(fp)
 3218948:	10c0020b 	ldhu	r3,8(r2)
 321894c:	e0bffa0b 	ldhu	r2,-24(fp)
 3218950:	1884b03a 	or	r2,r3,r2
 3218954:	1007883a 	mov	r3,r2
 3218958:	e0bff917 	ldw	r2,-28(fp)
 321895c:	10c0020d 	sth	r3,8(r2)
             break;
 3218960:	00000906 	br	3218988 <OSFlagPost+0x130>
 3218964:	e0bff517 	ldw	r2,-44(fp)
 3218968:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321896c:	e0bff317 	ldw	r2,-52(fp)
 3218970:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
 3218974:	e0fffc17 	ldw	r3,-16(fp)
 3218978:	00801c44 	movi	r2,113
 321897c:	18800005 	stb	r2,0(r3)
             return ((OS_FLAGS)0);
 3218980:	e03fff15 	stw	zero,-4(fp)
 3218984:	00009806 	br	3218be8 <OSFlagPost+0x390>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
 3218988:	e03ff785 	stb	zero,-34(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 321898c:	e0bff917 	ldw	r2,-28(fp)
 3218990:	10800117 	ldw	r2,4(r2)
 3218994:	e0bff815 	stw	r2,-32(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 3218998:	00007506 	br	3218b70 <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
 321899c:	e0bff817 	ldw	r2,-32(fp)
 32189a0:	10800483 	ldbu	r2,18(r2)
 32189a4:	10803fcc 	andi	r2,r2,255
 32189a8:	e0bffd15 	stw	r2,-12(fp)
 32189ac:	e0fffd17 	ldw	r3,-12(fp)
 32189b0:	18800060 	cmpeqi	r2,r3,1
 32189b4:	10004d1e 	bne	r2,zero,3218aec <OSFlagPost+0x294>
 32189b8:	e0fffd17 	ldw	r3,-12(fp)
 32189bc:	18800088 	cmpgei	r2,r3,2
 32189c0:	1000041e 	bne	r2,zero,32189d4 <OSFlagPost+0x17c>
 32189c4:	e0fffd17 	ldw	r3,-12(fp)
 32189c8:	1805003a 	cmpeq	r2,r3,zero
 32189cc:	1000301e 	bne	r2,zero,3218a90 <OSFlagPost+0x238>
 32189d0:	00005b06 	br	3218b40 <OSFlagPost+0x2e8>
 32189d4:	e0fffd17 	ldw	r3,-12(fp)
 32189d8:	188000a0 	cmpeqi	r2,r3,2
 32189dc:	1000041e 	bne	r2,zero,32189f0 <OSFlagPost+0x198>
 32189e0:	e0fffd17 	ldw	r3,-12(fp)
 32189e4:	188000e0 	cmpeqi	r2,r3,3
 32189e8:	1000161e 	bne	r2,zero,3218a44 <OSFlagPost+0x1ec>
 32189ec:	00005406 	br	3218b40 <OSFlagPost+0x2e8>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 32189f0:	e0bff917 	ldw	r2,-28(fp)
 32189f4:	10c0020b 	ldhu	r3,8(r2)
 32189f8:	e0bff817 	ldw	r2,-32(fp)
 32189fc:	1080040b 	ldhu	r2,16(r2)
 3218a00:	1884703a 	and	r2,r3,r2
 3218a04:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 3218a08:	e0bff817 	ldw	r2,-32(fp)
 3218a0c:	1080040b 	ldhu	r2,16(r2)
 3218a10:	10ffffcc 	andi	r3,r2,65535
 3218a14:	e0bff68b 	ldhu	r2,-38(fp)
 3218a18:	1880521e 	bne	r3,r2,3218b64 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 3218a1c:	e17ff68b 	ldhu	r5,-38(fp)
 3218a20:	e13ff817 	ldw	r4,-32(fp)
 3218a24:	3218f7c0 	call	3218f7c <OS_FlagTaskRdy>
 3218a28:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 3218a2c:	e0bff603 	ldbu	r2,-40(fp)
 3218a30:	10800058 	cmpnei	r2,r2,1
 3218a34:	10004b1e 	bne	r2,zero,3218b64 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 3218a38:	00800044 	movi	r2,1
 3218a3c:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 3218a40:	00004806 	br	3218b64 <OSFlagPost+0x30c>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 3218a44:	e0bff917 	ldw	r2,-28(fp)
 3218a48:	10c0020b 	ldhu	r3,8(r2)
 3218a4c:	e0bff817 	ldw	r2,-32(fp)
 3218a50:	1080040b 	ldhu	r2,16(r2)
 3218a54:	1884703a 	and	r2,r3,r2
 3218a58:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 3218a5c:	e0bff68b 	ldhu	r2,-38(fp)
 3218a60:	1005003a 	cmpeq	r2,r2,zero
 3218a64:	10003f1e 	bne	r2,zero,3218b64 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 3218a68:	e17ff68b 	ldhu	r5,-38(fp)
 3218a6c:	e13ff817 	ldw	r4,-32(fp)
 3218a70:	3218f7c0 	call	3218f7c <OS_FlagTaskRdy>
 3218a74:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 3218a78:	e0bff603 	ldbu	r2,-40(fp)
 3218a7c:	10800058 	cmpnei	r2,r2,1
 3218a80:	1000381e 	bne	r2,zero,3218b64 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 3218a84:	00800044 	movi	r2,1
 3218a88:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 3218a8c:	00003506 	br	3218b64 <OSFlagPost+0x30c>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 3218a90:	e0bff917 	ldw	r2,-28(fp)
 3218a94:	1080020b 	ldhu	r2,8(r2)
 3218a98:	0084303a 	nor	r2,zero,r2
 3218a9c:	1007883a 	mov	r3,r2
 3218aa0:	e0bff817 	ldw	r2,-32(fp)
 3218aa4:	1080040b 	ldhu	r2,16(r2)
 3218aa8:	1884703a 	and	r2,r3,r2
 3218aac:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 3218ab0:	e0bff817 	ldw	r2,-32(fp)
 3218ab4:	1080040b 	ldhu	r2,16(r2)
 3218ab8:	10ffffcc 	andi	r3,r2,65535
 3218abc:	e0bff68b 	ldhu	r2,-38(fp)
 3218ac0:	1880281e 	bne	r3,r2,3218b64 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 3218ac4:	e17ff68b 	ldhu	r5,-38(fp)
 3218ac8:	e13ff817 	ldw	r4,-32(fp)
 3218acc:	3218f7c0 	call	3218f7c <OS_FlagTaskRdy>
 3218ad0:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 3218ad4:	e0bff603 	ldbu	r2,-40(fp)
 3218ad8:	10800058 	cmpnei	r2,r2,1
 3218adc:	1000211e 	bne	r2,zero,3218b64 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 3218ae0:	00800044 	movi	r2,1
 3218ae4:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 3218ae8:	00001e06 	br	3218b64 <OSFlagPost+0x30c>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 3218aec:	e0bff917 	ldw	r2,-28(fp)
 3218af0:	1080020b 	ldhu	r2,8(r2)
 3218af4:	0084303a 	nor	r2,zero,r2
 3218af8:	1007883a 	mov	r3,r2
 3218afc:	e0bff817 	ldw	r2,-32(fp)
 3218b00:	1080040b 	ldhu	r2,16(r2)
 3218b04:	1884703a 	and	r2,r3,r2
 3218b08:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 3218b0c:	e0bff68b 	ldhu	r2,-38(fp)
 3218b10:	1005003a 	cmpeq	r2,r2,zero
 3218b14:	1000131e 	bne	r2,zero,3218b64 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 3218b18:	e17ff68b 	ldhu	r5,-38(fp)
 3218b1c:	e13ff817 	ldw	r4,-32(fp)
 3218b20:	3218f7c0 	call	3218f7c <OS_FlagTaskRdy>
 3218b24:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 3218b28:	e0bff603 	ldbu	r2,-40(fp)
 3218b2c:	10800058 	cmpnei	r2,r2,1
 3218b30:	10000c1e 	bne	r2,zero,3218b64 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 3218b34:	00800044 	movi	r2,1
 3218b38:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 3218b3c:	00000906 	br	3218b64 <OSFlagPost+0x30c>
 3218b40:	e0bff517 	ldw	r2,-44(fp)
 3218b44:	e0bff215 	stw	r2,-56(fp)
 3218b48:	e0bff217 	ldw	r2,-56(fp)
 3218b4c:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 3218b50:	e0fffc17 	ldw	r3,-16(fp)
 3218b54:	00801bc4 	movi	r2,111
 3218b58:	18800005 	stb	r2,0(r3)
                 return ((OS_FLAGS)0);
 3218b5c:	e03fff15 	stw	zero,-4(fp)
 3218b60:	00002106 	br	3218be8 <OSFlagPost+0x390>
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
 3218b64:	e0bff817 	ldw	r2,-32(fp)
 3218b68:	10800017 	ldw	r2,0(r2)
 3218b6c:	e0bff815 	stw	r2,-32(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 3218b70:	e0bff817 	ldw	r2,-32(fp)
 3218b74:	1004c03a 	cmpne	r2,r2,zero
 3218b78:	103f881e 	bne	r2,zero,321899c <OSFlagPost+0x144>
 3218b7c:	e0bff517 	ldw	r2,-44(fp)
 3218b80:	e0bff115 	stw	r2,-60(fp)
 3218b84:	e0bff117 	ldw	r2,-60(fp)
 3218b88:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
 3218b8c:	e0bff783 	ldbu	r2,-34(fp)
 3218b90:	10800058 	cmpnei	r2,r2,1
 3218b94:	1000011e 	bne	r2,zero,3218b9c <OSFlagPost+0x344>
        OS_Sched();
 3218b98:	3216f880 	call	3216f88 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3218b9c:	0005303a 	rdctl	r2,status
 3218ba0:	e0bff015 	stw	r2,-64(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3218ba4:	e0fff017 	ldw	r3,-64(fp)
 3218ba8:	00bfff84 	movi	r2,-2
 3218bac:	1884703a 	and	r2,r3,r2
 3218bb0:	1001703a 	wrctl	status,r2
  
  return context;
 3218bb4:	e0bff017 	ldw	r2,-64(fp)
    }
    OS_ENTER_CRITICAL();
 3218bb8:	e0bff515 	stw	r2,-44(fp)
    flags_cur = pgrp->OSFlagFlags;
 3218bbc:	e0bff917 	ldw	r2,-28(fp)
 3218bc0:	1080020b 	ldhu	r2,8(r2)
 3218bc4:	e0bff70d 	sth	r2,-36(fp)
 3218bc8:	e0bff517 	ldw	r2,-44(fp)
 3218bcc:	e0bfef15 	stw	r2,-68(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3218bd0:	e0bfef17 	ldw	r2,-68(fp)
 3218bd4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
 3218bd8:	e0bffc17 	ldw	r2,-16(fp)
 3218bdc:	10000005 	stb	zero,0(r2)
    return (flags_cur);
 3218be0:	e0bff70b 	ldhu	r2,-36(fp)
 3218be4:	e0bfff15 	stw	r2,-4(fp)
 3218be8:	e0bfff17 	ldw	r2,-4(fp)
}
 3218bec:	e037883a 	mov	sp,fp
 3218bf0:	dfc00117 	ldw	ra,4(sp)
 3218bf4:	df000017 	ldw	fp,0(sp)
 3218bf8:	dec00204 	addi	sp,sp,8
 3218bfc:	f800283a 	ret

03218c00 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
 3218c00:	defff804 	addi	sp,sp,-32
 3218c04:	df000715 	stw	fp,28(sp)
 3218c08:	df000704 	addi	fp,sp,28
 3218c0c:	e13ffd15 	stw	r4,-12(fp)
 3218c10:	e17ffe15 	stw	r5,-8(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
 3218c14:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
 3218c18:	e0bffe17 	ldw	r2,-8(fp)
 3218c1c:	1004c03a 	cmpne	r2,r2,zero
 3218c20:	1000021e 	bne	r2,zero,3218c2c <OSFlagQuery+0x2c>
        return ((OS_FLAGS)0);
 3218c24:	e03fff15 	stw	zero,-4(fp)
 3218c28:	00002506 	br	3218cc0 <OSFlagQuery+0xc0>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
 3218c2c:	e0bffd17 	ldw	r2,-12(fp)
 3218c30:	1004c03a 	cmpne	r2,r2,zero
 3218c34:	1000051e 	bne	r2,zero,3218c4c <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 3218c38:	e0fffe17 	ldw	r3,-8(fp)
 3218c3c:	00801b84 	movi	r2,110
 3218c40:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 3218c44:	e03fff15 	stw	zero,-4(fp)
 3218c48:	00001d06 	br	3218cc0 <OSFlagQuery+0xc0>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
 3218c4c:	e0bffd17 	ldw	r2,-12(fp)
 3218c50:	10800003 	ldbu	r2,0(r2)
 3218c54:	10803fcc 	andi	r2,r2,255
 3218c58:	10800160 	cmpeqi	r2,r2,5
 3218c5c:	1000051e 	bne	r2,zero,3218c74 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
 3218c60:	e0fffe17 	ldw	r3,-8(fp)
 3218c64:	00800044 	movi	r2,1
 3218c68:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 3218c6c:	e03fff15 	stw	zero,-4(fp)
 3218c70:	00001306 	br	3218cc0 <OSFlagQuery+0xc0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3218c74:	0005303a 	rdctl	r2,status
 3218c78:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3218c7c:	e0fffa17 	ldw	r3,-24(fp)
 3218c80:	00bfff84 	movi	r2,-2
 3218c84:	1884703a 	and	r2,r3,r2
 3218c88:	1001703a 	wrctl	status,r2
  
  return context;
 3218c8c:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 3218c90:	e0bffb15 	stw	r2,-20(fp)
    flags = pgrp->OSFlagFlags;
 3218c94:	e0bffd17 	ldw	r2,-12(fp)
 3218c98:	1080020b 	ldhu	r2,8(r2)
 3218c9c:	e0bffc0d 	sth	r2,-16(fp)
 3218ca0:	e0bffb17 	ldw	r2,-20(fp)
 3218ca4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3218ca8:	e0bff917 	ldw	r2,-28(fp)
 3218cac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 3218cb0:	e0bffe17 	ldw	r2,-8(fp)
 3218cb4:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
 3218cb8:	e0bffc0b 	ldhu	r2,-16(fp)
 3218cbc:	e0bfff15 	stw	r2,-4(fp)
 3218cc0:	e0bfff17 	ldw	r2,-4(fp)
}
 3218cc4:	e037883a 	mov	sp,fp
 3218cc8:	df000017 	ldw	fp,0(sp)
 3218ccc:	dec00104 	addi	sp,sp,4
 3218cd0:	f800283a 	ret

03218cd4 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
 3218cd4:	defff804 	addi	sp,sp,-32
 3218cd8:	df000715 	stw	fp,28(sp)
 3218cdc:	df000704 	addi	fp,sp,28
 3218ce0:	e13ffb15 	stw	r4,-20(fp)
 3218ce4:	e17ffc15 	stw	r5,-16(fp)
 3218ce8:	e0800117 	ldw	r2,4(fp)
 3218cec:	e1bffd0d 	sth	r6,-12(fp)
 3218cf0:	e1fffe05 	stb	r7,-8(fp)
 3218cf4:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
 3218cf8:	0080c974 	movhi	r2,805
 3218cfc:	10931504 	addi	r2,r2,19540
 3218d00:	10c00017 	ldw	r3,0(r2)
 3218d04:	0080c974 	movhi	r2,805
 3218d08:	10931504 	addi	r2,r2,19540
 3218d0c:	10800017 	ldw	r2,0(r2)
 3218d10:	10800c03 	ldbu	r2,48(r2)
 3218d14:	10800814 	ori	r2,r2,32
 3218d18:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
 3218d1c:	0080c974 	movhi	r2,805
 3218d20:	10931504 	addi	r2,r2,19540
 3218d24:	10800017 	ldw	r2,0(r2)
 3218d28:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
 3218d2c:	0080c974 	movhi	r2,805
 3218d30:	10931504 	addi	r2,r2,19540
 3218d34:	10c00017 	ldw	r3,0(r2)
 3218d38:	e0bfff0b 	ldhu	r2,-4(fp)
 3218d3c:	18800b8d 	sth	r2,46(r3)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
 3218d40:	0080c974 	movhi	r2,805
 3218d44:	10931504 	addi	r2,r2,19540
 3218d48:	10c00017 	ldw	r3,0(r2)
 3218d4c:	e0bffc17 	ldw	r2,-16(fp)
 3218d50:	18800a15 	stw	r2,40(r3)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
 3218d54:	e0fffc17 	ldw	r3,-16(fp)
 3218d58:	e0bffd0b 	ldhu	r2,-12(fp)
 3218d5c:	1880040d 	sth	r2,16(r3)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
 3218d60:	e0fffc17 	ldw	r3,-16(fp)
 3218d64:	e0bffe03 	ldbu	r2,-8(fp)
 3218d68:	18800485 	stb	r2,18(r3)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
 3218d6c:	0080c974 	movhi	r2,805
 3218d70:	10931504 	addi	r2,r2,19540
 3218d74:	10c00017 	ldw	r3,0(r2)
 3218d78:	e0bffc17 	ldw	r2,-16(fp)
 3218d7c:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
 3218d80:	e0bffb17 	ldw	r2,-20(fp)
 3218d84:	10c00117 	ldw	r3,4(r2)
 3218d88:	e0bffc17 	ldw	r2,-16(fp)
 3218d8c:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
 3218d90:	e0bffc17 	ldw	r2,-16(fp)
 3218d94:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
 3218d98:	e0fffc17 	ldw	r3,-16(fp)
 3218d9c:	e0bffb17 	ldw	r2,-20(fp)
 3218da0:	18800315 	stw	r2,12(r3)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 3218da4:	e0bffb17 	ldw	r2,-20(fp)
 3218da8:	10800117 	ldw	r2,4(r2)
 3218dac:	e0bffa15 	stw	r2,-24(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
 3218db0:	e0bffa17 	ldw	r2,-24(fp)
 3218db4:	1005003a 	cmpeq	r2,r2,zero
 3218db8:	1000031e 	bne	r2,zero,3218dc8 <OS_FlagBlock+0xf4>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
 3218dbc:	e0fffa17 	ldw	r3,-24(fp)
 3218dc0:	e0bffc17 	ldw	r2,-16(fp)
 3218dc4:	18800115 	stw	r2,4(r3)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
 3218dc8:	e0fffb17 	ldw	r3,-20(fp)
 3218dcc:	e0bffc17 	ldw	r2,-16(fp)
 3218dd0:	18800115 	stw	r2,4(r3)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
 3218dd4:	0080c974 	movhi	r2,805
 3218dd8:	10931504 	addi	r2,r2,19540
 3218ddc:	10800017 	ldw	r2,0(r2)
 3218de0:	10800d03 	ldbu	r2,52(r2)
 3218de4:	e0bff905 	stb	r2,-28(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 3218de8:	e13ff903 	ldbu	r4,-28(fp)
 3218dec:	e0fff903 	ldbu	r3,-28(fp)
 3218df0:	0080c974 	movhi	r2,805
 3218df4:	10931244 	addi	r2,r2,19529
 3218df8:	10c5883a 	add	r2,r2,r3
 3218dfc:	10800003 	ldbu	r2,0(r2)
 3218e00:	1007883a 	mov	r3,r2
 3218e04:	0080c974 	movhi	r2,805
 3218e08:	10931504 	addi	r2,r2,19540
 3218e0c:	10800017 	ldw	r2,0(r2)
 3218e10:	10800d43 	ldbu	r2,53(r2)
 3218e14:	0084303a 	nor	r2,zero,r2
 3218e18:	1884703a 	and	r2,r3,r2
 3218e1c:	1007883a 	mov	r3,r2
 3218e20:	0080c974 	movhi	r2,805
 3218e24:	10931244 	addi	r2,r2,19529
 3218e28:	1105883a 	add	r2,r2,r4
 3218e2c:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0x00) {
 3218e30:	e0fff903 	ldbu	r3,-28(fp)
 3218e34:	0080c974 	movhi	r2,805
 3218e38:	10931244 	addi	r2,r2,19529
 3218e3c:	10c5883a 	add	r2,r2,r3
 3218e40:	10800003 	ldbu	r2,0(r2)
 3218e44:	10803fcc 	andi	r2,r2,255
 3218e48:	1004c03a 	cmpne	r2,r2,zero
 3218e4c:	10000e1e 	bne	r2,zero,3218e88 <OS_FlagBlock+0x1b4>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 3218e50:	0080c974 	movhi	r2,805
 3218e54:	10931504 	addi	r2,r2,19540
 3218e58:	10800017 	ldw	r2,0(r2)
 3218e5c:	10800d83 	ldbu	r2,54(r2)
 3218e60:	0084303a 	nor	r2,zero,r2
 3218e64:	1007883a 	mov	r3,r2
 3218e68:	0080c974 	movhi	r2,805
 3218e6c:	10931204 	addi	r2,r2,19528
 3218e70:	10800003 	ldbu	r2,0(r2)
 3218e74:	1884703a 	and	r2,r3,r2
 3218e78:	1007883a 	mov	r3,r2
 3218e7c:	0080c974 	movhi	r2,805
 3218e80:	10931204 	addi	r2,r2,19528
 3218e84:	10c00005 	stb	r3,0(r2)
    }
}
 3218e88:	e037883a 	mov	sp,fp
 3218e8c:	df000017 	ldw	fp,0(sp)
 3218e90:	dec00104 	addi	sp,sp,4
 3218e94:	f800283a 	ret

03218e98 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
 3218e98:	defffb04 	addi	sp,sp,-20
 3218e9c:	dfc00415 	stw	ra,16(sp)
 3218ea0:	df000315 	stw	fp,12(sp)
 3218ea4:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
 3218ea8:	0100c9b4 	movhi	r4,806
 3218eac:	2125f704 	addi	r4,r4,-26660
 3218eb0:	0140dc04 	movi	r5,880
 3218eb4:	3216ec80 	call	3216ec8 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
 3218eb8:	0080c9b4 	movhi	r2,806
 3218ebc:	10a5f704 	addi	r2,r2,-26660
 3218ec0:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
 3218ec4:	0080c9b4 	movhi	r2,806
 3218ec8:	10a60204 	addi	r2,r2,-26616
 3218ecc:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 3218ed0:	e03fff0d 	sth	zero,-4(fp)
 3218ed4:	00001306 	br	3218f24 <OS_FlagInit+0x8c>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 3218ed8:	e0bffe17 	ldw	r2,-8(fp)
 3218edc:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
 3218ee0:	e0fffe17 	ldw	r3,-8(fp)
 3218ee4:	e0bffd17 	ldw	r2,-12(fp)
 3218ee8:	18800115 	stw	r2,4(r3)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
 3218eec:	e0fffe17 	ldw	r3,-8(fp)
 3218ef0:	00800fc4 	movi	r2,63
 3218ef4:	18800285 	stb	r2,10(r3)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 3218ef8:	e0bffe17 	ldw	r2,-8(fp)
 3218efc:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
 3218f00:	e0bffe17 	ldw	r2,-8(fp)
 3218f04:	10800b04 	addi	r2,r2,44
 3218f08:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
 3218f0c:	e0bffd17 	ldw	r2,-12(fp)
 3218f10:	10800b04 	addi	r2,r2,44
 3218f14:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 3218f18:	e0bfff0b 	ldhu	r2,-4(fp)
 3218f1c:	10800044 	addi	r2,r2,1
 3218f20:	e0bfff0d 	sth	r2,-4(fp)
 3218f24:	e0bfff0b 	ldhu	r2,-4(fp)
 3218f28:	108004f0 	cmpltui	r2,r2,19
 3218f2c:	103fea1e 	bne	r2,zero,3218ed8 <OS_FlagInit+0x40>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 3218f30:	e0bffe17 	ldw	r2,-8(fp)
 3218f34:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
 3218f38:	e0bffe17 	ldw	r2,-8(fp)
 3218f3c:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
 3218f40:	e0fffe17 	ldw	r3,-8(fp)
 3218f44:	00800fc4 	movi	r2,63
 3218f48:	18800285 	stb	r2,10(r3)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 3218f4c:	e0bffe17 	ldw	r2,-8(fp)
 3218f50:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
 3218f54:	00c0c974 	movhi	r3,805
 3218f58:	18d31704 	addi	r3,r3,19548
 3218f5c:	0080c9b4 	movhi	r2,806
 3218f60:	10a5f704 	addi	r2,r2,-26660
 3218f64:	18800015 	stw	r2,0(r3)
#endif
}
 3218f68:	e037883a 	mov	sp,fp
 3218f6c:	dfc00117 	ldw	ra,4(sp)
 3218f70:	df000017 	ldw	fp,0(sp)
 3218f74:	dec00204 	addi	sp,sp,8
 3218f78:	f800283a 	ret

03218f7c <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
 3218f7c:	defffa04 	addi	sp,sp,-24
 3218f80:	dfc00515 	stw	ra,20(sp)
 3218f84:	df000415 	stw	fp,16(sp)
 3218f88:	df000404 	addi	fp,sp,16
 3218f8c:	e13ffe15 	stw	r4,-8(fp)
 3218f90:	e17fff0d 	sth	r5,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
 3218f94:	e0bffe17 	ldw	r2,-8(fp)
 3218f98:	10800217 	ldw	r2,8(r2)
 3218f9c:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
 3218fa0:	e0bffd17 	ldw	r2,-12(fp)
 3218fa4:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
 3218fa8:	e0fffd17 	ldw	r3,-12(fp)
 3218fac:	e0bfff0b 	ldhu	r2,-4(fp)
 3218fb0:	18800b0d 	sth	r2,44(r3)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
 3218fb4:	e0bffd17 	ldw	r2,-12(fp)
 3218fb8:	10c00c03 	ldbu	r3,48(r2)
 3218fbc:	00bff7c4 	movi	r2,-33
 3218fc0:	1884703a 	and	r2,r3,r2
 3218fc4:	1007883a 	mov	r3,r2
 3218fc8:	e0bffd17 	ldw	r2,-12(fp)
 3218fcc:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
 3218fd0:	e0bffd17 	ldw	r2,-12(fp)
 3218fd4:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
 3218fd8:	e0bffd17 	ldw	r2,-12(fp)
 3218fdc:	10800c03 	ldbu	r2,48(r2)
 3218fe0:	10803fcc 	andi	r2,r2,255
 3218fe4:	1004c03a 	cmpne	r2,r2,zero
 3218fe8:	10001f1e 	bne	r2,zero,3219068 <OS_FlagTaskRdy+0xec>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
 3218fec:	e0bffd17 	ldw	r2,-12(fp)
 3218ff0:	10c00d83 	ldbu	r3,54(r2)
 3218ff4:	0080c974 	movhi	r2,805
 3218ff8:	10931204 	addi	r2,r2,19528
 3218ffc:	10800003 	ldbu	r2,0(r2)
 3219000:	1884b03a 	or	r2,r3,r2
 3219004:	1007883a 	mov	r3,r2
 3219008:	0080c974 	movhi	r2,805
 321900c:	10931204 	addi	r2,r2,19528
 3219010:	10c00005 	stb	r3,0(r2)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 3219014:	e0bffd17 	ldw	r2,-12(fp)
 3219018:	10800d03 	ldbu	r2,52(r2)
 321901c:	11003fcc 	andi	r4,r2,255
 3219020:	e0bffd17 	ldw	r2,-12(fp)
 3219024:	10800d03 	ldbu	r2,52(r2)
 3219028:	10c03fcc 	andi	r3,r2,255
 321902c:	0080c974 	movhi	r2,805
 3219030:	10931244 	addi	r2,r2,19529
 3219034:	10c5883a 	add	r2,r2,r3
 3219038:	10c00003 	ldbu	r3,0(r2)
 321903c:	e0bffd17 	ldw	r2,-12(fp)
 3219040:	10800d43 	ldbu	r2,53(r2)
 3219044:	1884b03a 	or	r2,r3,r2
 3219048:	1007883a 	mov	r3,r2
 321904c:	0080c974 	movhi	r2,805
 3219050:	10931244 	addi	r2,r2,19529
 3219054:	1105883a 	add	r2,r2,r4
 3219058:	10c00005 	stb	r3,0(r2)
        sched                   = OS_TRUE;
 321905c:	00800044 	movi	r2,1
 3219060:	e0bffc05 	stb	r2,-16(fp)
 3219064:	00000106 	br	321906c <OS_FlagTaskRdy+0xf0>
    } else {
        sched                   = OS_FALSE;
 3219068:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
 321906c:	e13ffe17 	ldw	r4,-8(fp)
 3219070:	321908c0 	call	321908c <OS_FlagUnlink>
    return (sched);
 3219074:	e0bffc03 	ldbu	r2,-16(fp)
}
 3219078:	e037883a 	mov	sp,fp
 321907c:	dfc00117 	ldw	ra,4(sp)
 3219080:	df000017 	ldw	fp,0(sp)
 3219084:	dec00204 	addi	sp,sp,8
 3219088:	f800283a 	ret

0321908c <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
 321908c:	defffa04 	addi	sp,sp,-24
 3219090:	df000515 	stw	fp,20(sp)
 3219094:	df000504 	addi	fp,sp,20
 3219098:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
 321909c:	e0bfff17 	ldw	r2,-4(fp)
 32190a0:	10800117 	ldw	r2,4(r2)
 32190a4:	e0bffc15 	stw	r2,-16(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 32190a8:	e0bfff17 	ldw	r2,-4(fp)
 32190ac:	10800017 	ldw	r2,0(r2)
 32190b0:	e0bffb15 	stw	r2,-20(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
 32190b4:	e0bffc17 	ldw	r2,-16(fp)
 32190b8:	1004c03a 	cmpne	r2,r2,zero
 32190bc:	10000c1e 	bne	r2,zero,32190f0 <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
 32190c0:	e0bfff17 	ldw	r2,-4(fp)
 32190c4:	10800317 	ldw	r2,12(r2)
 32190c8:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
 32190cc:	e0fffd17 	ldw	r3,-12(fp)
 32190d0:	e0bffb17 	ldw	r2,-20(fp)
 32190d4:	18800115 	stw	r2,4(r3)
        if (pnode_next != (OS_FLAG_NODE *)0) {
 32190d8:	e0bffb17 	ldw	r2,-20(fp)
 32190dc:	1005003a 	cmpeq	r2,r2,zero
 32190e0:	10000c1e 	bne	r2,zero,3219114 <OS_FlagUnlink+0x88>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
 32190e4:	e0bffb17 	ldw	r2,-20(fp)
 32190e8:	10000115 	stw	zero,4(r2)
 32190ec:	00000906 	br	3219114 <OS_FlagUnlink+0x88>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
 32190f0:	e0fffc17 	ldw	r3,-16(fp)
 32190f4:	e0bffb17 	ldw	r2,-20(fp)
 32190f8:	18800015 	stw	r2,0(r3)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
 32190fc:	e0bffb17 	ldw	r2,-20(fp)
 3219100:	1005003a 	cmpeq	r2,r2,zero
 3219104:	1000031e 	bne	r2,zero,3219114 <OS_FlagUnlink+0x88>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
 3219108:	e0fffb17 	ldw	r3,-20(fp)
 321910c:	e0bffc17 	ldw	r2,-16(fp)
 3219110:	18800115 	stw	r2,4(r3)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
 3219114:	e0bfff17 	ldw	r2,-4(fp)
 3219118:	10800217 	ldw	r2,8(r2)
 321911c:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
 3219120:	e0bffe17 	ldw	r2,-8(fp)
 3219124:	10000a15 	stw	zero,40(r2)
#endif
}
 3219128:	e037883a 	mov	sp,fp
 321912c:	df000017 	ldw	fp,0(sp)
 3219130:	dec00104 	addi	sp,sp,4
 3219134:	f800283a 	ret

03219138 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
 3219138:	defff304 	addi	sp,sp,-52
 321913c:	df000c15 	stw	fp,48(sp)
 3219140:	df000c04 	addi	fp,sp,48
 3219144:	e13ffb15 	stw	r4,-20(fp)
 3219148:	e17ffc15 	stw	r5,-16(fp)
 321914c:	e1bffd15 	stw	r6,-12(fp)
 3219150:	e1fffe15 	stw	r7,-8(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 3219154:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 3219158:	e0bffe17 	ldw	r2,-8(fp)
 321915c:	1004c03a 	cmpne	r2,r2,zero
 3219160:	1000021e 	bne	r2,zero,321916c <OSMemCreate+0x34>
        return ((OS_MEM *)0);
 3219164:	e03fff15 	stw	zero,-4(fp)
 3219168:	00007506 	br	3219340 <OSMemCreate+0x208>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
 321916c:	e0bffb17 	ldw	r2,-20(fp)
 3219170:	1004c03a 	cmpne	r2,r2,zero
 3219174:	1000051e 	bne	r2,zero,321918c <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 3219178:	e0fffe17 	ldw	r3,-8(fp)
 321917c:	00801884 	movi	r2,98
 3219180:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 3219184:	e03fff15 	stw	zero,-4(fp)
 3219188:	00006d06 	br	3219340 <OSMemCreate+0x208>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
 321918c:	e0bffb17 	ldw	r2,-20(fp)
 3219190:	108000cc 	andi	r2,r2,3
 3219194:	1005003a 	cmpeq	r2,r2,zero
 3219198:	1000051e 	bne	r2,zero,32191b0 <OSMemCreate+0x78>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 321919c:	e0fffe17 	ldw	r3,-8(fp)
 32191a0:	00801884 	movi	r2,98
 32191a4:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 32191a8:	e03fff15 	stw	zero,-4(fp)
 32191ac:	00006406 	br	3219340 <OSMemCreate+0x208>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
 32191b0:	e0bffc17 	ldw	r2,-16(fp)
 32191b4:	108000a8 	cmpgeui	r2,r2,2
 32191b8:	1000051e 	bne	r2,zero,32191d0 <OSMemCreate+0x98>
        *perr = OS_ERR_MEM_INVALID_BLKS;
 32191bc:	e0fffe17 	ldw	r3,-8(fp)
 32191c0:	008016c4 	movi	r2,91
 32191c4:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 32191c8:	e03fff15 	stw	zero,-4(fp)
 32191cc:	00005c06 	br	3219340 <OSMemCreate+0x208>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
 32191d0:	e0bffd17 	ldw	r2,-12(fp)
 32191d4:	10800128 	cmpgeui	r2,r2,4
 32191d8:	1000051e 	bne	r2,zero,32191f0 <OSMemCreate+0xb8>
        *perr = OS_ERR_MEM_INVALID_SIZE;
 32191dc:	e0fffe17 	ldw	r3,-8(fp)
 32191e0:	00801704 	movi	r2,92
 32191e4:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 32191e8:	e03fff15 	stw	zero,-4(fp)
 32191ec:	00005406 	br	3219340 <OSMemCreate+0x208>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32191f0:	0005303a 	rdctl	r2,status
 32191f4:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32191f8:	e0fff517 	ldw	r3,-44(fp)
 32191fc:	00bfff84 	movi	r2,-2
 3219200:	1884703a 	and	r2,r3,r2
 3219204:	1001703a 	wrctl	status,r2
  
  return context;
 3219208:	e0bff517 	ldw	r2,-44(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 321920c:	e0bff615 	stw	r2,-40(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
 3219210:	0080c974 	movhi	r2,805
 3219214:	10930f04 	addi	r2,r2,19516
 3219218:	10800017 	ldw	r2,0(r2)
 321921c:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
 3219220:	0080c974 	movhi	r2,805
 3219224:	10930f04 	addi	r2,r2,19516
 3219228:	10800017 	ldw	r2,0(r2)
 321922c:	1005003a 	cmpeq	r2,r2,zero
 3219230:	1000081e 	bne	r2,zero,3219254 <OSMemCreate+0x11c>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
 3219234:	0080c974 	movhi	r2,805
 3219238:	10930f04 	addi	r2,r2,19516
 321923c:	10800017 	ldw	r2,0(r2)
 3219240:	10800117 	ldw	r2,4(r2)
 3219244:	1007883a 	mov	r3,r2
 3219248:	0080c974 	movhi	r2,805
 321924c:	10930f04 	addi	r2,r2,19516
 3219250:	10c00015 	stw	r3,0(r2)
 3219254:	e0bff617 	ldw	r2,-40(fp)
 3219258:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321925c:	e0bff417 	ldw	r2,-48(fp)
 3219260:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
 3219264:	e0bffa17 	ldw	r2,-24(fp)
 3219268:	1004c03a 	cmpne	r2,r2,zero
 321926c:	1000051e 	bne	r2,zero,3219284 <OSMemCreate+0x14c>
        *perr = OS_ERR_MEM_INVALID_PART;
 3219270:	e0fffe17 	ldw	r3,-8(fp)
 3219274:	00801684 	movi	r2,90
 3219278:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 321927c:	e03fff15 	stw	zero,-4(fp)
 3219280:	00002f06 	br	3219340 <OSMemCreate+0x208>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
 3219284:	e0bffb17 	ldw	r2,-20(fp)
 3219288:	e0bff815 	stw	r2,-32(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
 321928c:	e0bffb17 	ldw	r2,-20(fp)
 3219290:	1007883a 	mov	r3,r2
 3219294:	e0bffd17 	ldw	r2,-12(fp)
 3219298:	1885883a 	add	r2,r3,r2
 321929c:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < (nblks - 1); i++) {
 32192a0:	e03ff715 	stw	zero,-36(fp)
 32192a4:	00000d06 	br	32192dc <OSMemCreate+0x1a4>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
 32192a8:	e0fff817 	ldw	r3,-32(fp)
 32192ac:	e0bff917 	ldw	r2,-28(fp)
 32192b0:	18800015 	stw	r2,0(r3)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
 32192b4:	e0bff917 	ldw	r2,-28(fp)
 32192b8:	e0bff815 	stw	r2,-32(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
 32192bc:	e0bff917 	ldw	r2,-28(fp)
 32192c0:	1007883a 	mov	r3,r2
 32192c4:	e0bffd17 	ldw	r2,-12(fp)
 32192c8:	1885883a 	add	r2,r3,r2
 32192cc:	e0bff915 	stw	r2,-28(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
 32192d0:	e0bff717 	ldw	r2,-36(fp)
 32192d4:	10800044 	addi	r2,r2,1
 32192d8:	e0bff715 	stw	r2,-36(fp)
 32192dc:	e0bffc17 	ldw	r2,-16(fp)
 32192e0:	10ffffc4 	addi	r3,r2,-1
 32192e4:	e0bff717 	ldw	r2,-36(fp)
 32192e8:	10ffef36 	bltu	r2,r3,32192a8 <OSMemCreate+0x170>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
 32192ec:	e0bff817 	ldw	r2,-32(fp)
 32192f0:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
 32192f4:	e0fffa17 	ldw	r3,-24(fp)
 32192f8:	e0bffb17 	ldw	r2,-20(fp)
 32192fc:	18800015 	stw	r2,0(r3)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
 3219300:	e0fffa17 	ldw	r3,-24(fp)
 3219304:	e0bffb17 	ldw	r2,-20(fp)
 3219308:	18800115 	stw	r2,4(r3)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
 321930c:	e0fffa17 	ldw	r3,-24(fp)
 3219310:	e0bffc17 	ldw	r2,-16(fp)
 3219314:	18800415 	stw	r2,16(r3)
    pmem->OSMemNBlks    = nblks;
 3219318:	e0fffa17 	ldw	r3,-24(fp)
 321931c:	e0bffc17 	ldw	r2,-16(fp)
 3219320:	18800315 	stw	r2,12(r3)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
 3219324:	e0fffa17 	ldw	r3,-24(fp)
 3219328:	e0bffd17 	ldw	r2,-12(fp)
 321932c:	18800215 	stw	r2,8(r3)
    *perr               = OS_ERR_NONE;
 3219330:	e0bffe17 	ldw	r2,-8(fp)
 3219334:	10000005 	stb	zero,0(r2)
    return (pmem);
 3219338:	e0bffa17 	ldw	r2,-24(fp)
 321933c:	e0bfff15 	stw	r2,-4(fp)
 3219340:	e0bfff17 	ldw	r2,-4(fp)
}
 3219344:	e037883a 	mov	sp,fp
 3219348:	df000017 	ldw	fp,0(sp)
 321934c:	dec00104 	addi	sp,sp,4
 3219350:	f800283a 	ret

03219354 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
 3219354:	defff704 	addi	sp,sp,-36
 3219358:	df000815 	stw	fp,32(sp)
 321935c:	df000804 	addi	fp,sp,32
 3219360:	e13ffd15 	stw	r4,-12(fp)
 3219364:	e17ffe15 	stw	r5,-8(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 3219368:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 321936c:	e0bffe17 	ldw	r2,-8(fp)
 3219370:	1004c03a 	cmpne	r2,r2,zero
 3219374:	1000021e 	bne	r2,zero,3219380 <OSMemGet+0x2c>
        return ((void *)0);
 3219378:	e03fff15 	stw	zero,-4(fp)
 321937c:	00003106 	br	3219444 <OSMemGet+0xf0>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
 3219380:	e0bffd17 	ldw	r2,-12(fp)
 3219384:	1004c03a 	cmpne	r2,r2,zero
 3219388:	1000051e 	bne	r2,zero,32193a0 <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 321938c:	e0fffe17 	ldw	r3,-8(fp)
 3219390:	00801804 	movi	r2,96
 3219394:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 3219398:	e03fff15 	stw	zero,-4(fp)
 321939c:	00002906 	br	3219444 <OSMemGet+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32193a0:	0005303a 	rdctl	r2,status
 32193a4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32193a8:	e0fffa17 	ldw	r3,-24(fp)
 32193ac:	00bfff84 	movi	r2,-2
 32193b0:	1884703a 	and	r2,r3,r2
 32193b4:	1001703a 	wrctl	status,r2
  
  return context;
 32193b8:	e0bffa17 	ldw	r2,-24(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 32193bc:	e0bffb15 	stw	r2,-20(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
 32193c0:	e0bffd17 	ldw	r2,-12(fp)
 32193c4:	10800417 	ldw	r2,16(r2)
 32193c8:	1005003a 	cmpeq	r2,r2,zero
 32193cc:	1000151e 	bne	r2,zero,3219424 <OSMemGet+0xd0>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
 32193d0:	e0bffd17 	ldw	r2,-12(fp)
 32193d4:	10800117 	ldw	r2,4(r2)
 32193d8:	e0bffc15 	stw	r2,-16(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
 32193dc:	e0bffc17 	ldw	r2,-16(fp)
 32193e0:	10c00017 	ldw	r3,0(r2)
 32193e4:	e0bffd17 	ldw	r2,-12(fp)
 32193e8:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
 32193ec:	e0bffd17 	ldw	r2,-12(fp)
 32193f0:	10800417 	ldw	r2,16(r2)
 32193f4:	10ffffc4 	addi	r3,r2,-1
 32193f8:	e0bffd17 	ldw	r2,-12(fp)
 32193fc:	10c00415 	stw	r3,16(r2)
 3219400:	e0bffb17 	ldw	r2,-20(fp)
 3219404:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3219408:	e0bff917 	ldw	r2,-28(fp)
 321940c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
 3219410:	e0bffe17 	ldw	r2,-8(fp)
 3219414:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
 3219418:	e0bffc17 	ldw	r2,-16(fp)
 321941c:	e0bfff15 	stw	r2,-4(fp)
 3219420:	00000806 	br	3219444 <OSMemGet+0xf0>
 3219424:	e0bffb17 	ldw	r2,-20(fp)
 3219428:	e0bff815 	stw	r2,-32(fp)
 321942c:	e0bff817 	ldw	r2,-32(fp)
 3219430:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
 3219434:	e0fffe17 	ldw	r3,-8(fp)
 3219438:	00801744 	movi	r2,93
 321943c:	18800005 	stb	r2,0(r3)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
 3219440:	e03fff15 	stw	zero,-4(fp)
 3219444:	e0bfff17 	ldw	r2,-4(fp)
}
 3219448:	e037883a 	mov	sp,fp
 321944c:	df000017 	ldw	fp,0(sp)
 3219450:	dec00104 	addi	sp,sp,4
 3219454:	f800283a 	ret

03219458 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 3219458:	defff604 	addi	sp,sp,-40
 321945c:	dfc00915 	stw	ra,36(sp)
 3219460:	df000815 	stw	fp,32(sp)
 3219464:	df000804 	addi	fp,sp,32
 3219468:	e13ffc15 	stw	r4,-16(fp)
 321946c:	e17ffd15 	stw	r5,-12(fp)
 3219470:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3219474:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 3219478:	e0bffe17 	ldw	r2,-8(fp)
 321947c:	1004c03a 	cmpne	r2,r2,zero
 3219480:	1000021e 	bne	r2,zero,321948c <OSMemNameGet+0x34>
        return (0);
 3219484:	e03fff15 	stw	zero,-4(fp)
 3219488:	00003006 	br	321954c <OSMemNameGet+0xf4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 321948c:	e0bffc17 	ldw	r2,-16(fp)
 3219490:	1004c03a 	cmpne	r2,r2,zero
 3219494:	1000051e 	bne	r2,zero,32194ac <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 3219498:	e0fffe17 	ldw	r3,-8(fp)
 321949c:	00801804 	movi	r2,96
 32194a0:	18800005 	stb	r2,0(r3)
        return (0);
 32194a4:	e03fff15 	stw	zero,-4(fp)
 32194a8:	00002806 	br	321954c <OSMemNameGet+0xf4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 32194ac:	e0bffd17 	ldw	r2,-12(fp)
 32194b0:	1004c03a 	cmpne	r2,r2,zero
 32194b4:	1000051e 	bne	r2,zero,32194cc <OSMemNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 32194b8:	e0fffe17 	ldw	r3,-8(fp)
 32194bc:	00800304 	movi	r2,12
 32194c0:	18800005 	stb	r2,0(r3)
        return (0);
 32194c4:	e03fff15 	stw	zero,-4(fp)
 32194c8:	00002006 	br	321954c <OSMemNameGet+0xf4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 32194cc:	0080c974 	movhi	r2,805
 32194d0:	10931404 	addi	r2,r2,19536
 32194d4:	10800003 	ldbu	r2,0(r2)
 32194d8:	10803fcc 	andi	r2,r2,255
 32194dc:	1005003a 	cmpeq	r2,r2,zero
 32194e0:	1000051e 	bne	r2,zero,32194f8 <OSMemNameGet+0xa0>
        *perr = OS_ERR_NAME_GET_ISR;
 32194e4:	e0fffe17 	ldw	r3,-8(fp)
 32194e8:	00800444 	movi	r2,17
 32194ec:	18800005 	stb	r2,0(r3)
        return (0);
 32194f0:	e03fff15 	stw	zero,-4(fp)
 32194f4:	00001506 	br	321954c <OSMemNameGet+0xf4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32194f8:	0005303a 	rdctl	r2,status
 32194fc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3219500:	e0fff917 	ldw	r3,-28(fp)
 3219504:	00bfff84 	movi	r2,-2
 3219508:	1884703a 	and	r2,r3,r2
 321950c:	1001703a 	wrctl	status,r2
  
  return context;
 3219510:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 3219514:	e0bffa15 	stw	r2,-24(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
 3219518:	e0bffc17 	ldw	r2,-16(fp)
 321951c:	11400504 	addi	r5,r2,20
 3219520:	e13ffd17 	ldw	r4,-12(fp)
 3219524:	32170cc0 	call	32170cc <OS_StrCopy>
 3219528:	e0bffb05 	stb	r2,-20(fp)
 321952c:	e0bffa17 	ldw	r2,-24(fp)
 3219530:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3219534:	e0bff817 	ldw	r2,-32(fp)
 3219538:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 321953c:	e0bffe17 	ldw	r2,-8(fp)
 3219540:	10000005 	stb	zero,0(r2)
    return (len);
 3219544:	e0bffb03 	ldbu	r2,-20(fp)
 3219548:	e0bfff15 	stw	r2,-4(fp)
 321954c:	e0bfff17 	ldw	r2,-4(fp)
}
 3219550:	e037883a 	mov	sp,fp
 3219554:	dfc00117 	ldw	ra,4(sp)
 3219558:	df000017 	ldw	fp,0(sp)
 321955c:	dec00204 	addi	sp,sp,8
 3219560:	f800283a 	ret

03219564 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 3219564:	defff604 	addi	sp,sp,-40
 3219568:	dfc00915 	stw	ra,36(sp)
 321956c:	df000815 	stw	fp,32(sp)
 3219570:	df000804 	addi	fp,sp,32
 3219574:	e13ffd15 	stw	r4,-12(fp)
 3219578:	e17ffe15 	stw	r5,-8(fp)
 321957c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3219580:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 3219584:	e0bfff17 	ldw	r2,-4(fp)
 3219588:	1005003a 	cmpeq	r2,r2,zero
 321958c:	1000381e 	bne	r2,zero,3219670 <OSMemNameSet+0x10c>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 3219590:	e0bffd17 	ldw	r2,-12(fp)
 3219594:	1004c03a 	cmpne	r2,r2,zero
 3219598:	1000041e 	bne	r2,zero,32195ac <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 321959c:	e0ffff17 	ldw	r3,-4(fp)
 32195a0:	00801804 	movi	r2,96
 32195a4:	18800005 	stb	r2,0(r3)
        return;
 32195a8:	00003106 	br	3219670 <OSMemNameSet+0x10c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 32195ac:	e0bffe17 	ldw	r2,-8(fp)
 32195b0:	1004c03a 	cmpne	r2,r2,zero
 32195b4:	1000041e 	bne	r2,zero,32195c8 <OSMemNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 32195b8:	e0ffff17 	ldw	r3,-4(fp)
 32195bc:	00800304 	movi	r2,12
 32195c0:	18800005 	stb	r2,0(r3)
        return;
 32195c4:	00002a06 	br	3219670 <OSMemNameSet+0x10c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 32195c8:	0080c974 	movhi	r2,805
 32195cc:	10931404 	addi	r2,r2,19536
 32195d0:	10800003 	ldbu	r2,0(r2)
 32195d4:	10803fcc 	andi	r2,r2,255
 32195d8:	1005003a 	cmpeq	r2,r2,zero
 32195dc:	1000041e 	bne	r2,zero,32195f0 <OSMemNameSet+0x8c>
        *perr = OS_ERR_NAME_SET_ISR;
 32195e0:	e0ffff17 	ldw	r3,-4(fp)
 32195e4:	00800484 	movi	r2,18
 32195e8:	18800005 	stb	r2,0(r3)
        return;
 32195ec:	00002006 	br	3219670 <OSMemNameSet+0x10c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32195f0:	0005303a 	rdctl	r2,status
 32195f4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32195f8:	e0fffa17 	ldw	r3,-24(fp)
 32195fc:	00bfff84 	movi	r2,-2
 3219600:	1884703a 	and	r2,r3,r2
 3219604:	1001703a 	wrctl	status,r2
  
  return context;
 3219608:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 321960c:	e0bffb15 	stw	r2,-20(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 3219610:	e13ffe17 	ldw	r4,-8(fp)
 3219614:	321714c0 	call	321714c <OS_StrLen>
 3219618:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
 321961c:	e0bffc03 	ldbu	r2,-16(fp)
 3219620:	10800830 	cmpltui	r2,r2,32
 3219624:	1000081e 	bne	r2,zero,3219648 <OSMemNameSet+0xe4>
 3219628:	e0bffb17 	ldw	r2,-20(fp)
 321962c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3219630:	e0bff917 	ldw	r2,-28(fp)
 3219634:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
 3219638:	e0ffff17 	ldw	r3,-4(fp)
 321963c:	008018c4 	movi	r2,99
 3219640:	18800005 	stb	r2,0(r3)
        return;
 3219644:	00000a06 	br	3219670 <OSMemNameSet+0x10c>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
 3219648:	e0bffd17 	ldw	r2,-12(fp)
 321964c:	11000504 	addi	r4,r2,20
 3219650:	e17ffe17 	ldw	r5,-8(fp)
 3219654:	32170cc0 	call	32170cc <OS_StrCopy>
 3219658:	e0bffb17 	ldw	r2,-20(fp)
 321965c:	e0bff815 	stw	r2,-32(fp)
 3219660:	e0bff817 	ldw	r2,-32(fp)
 3219664:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 3219668:	e0bfff17 	ldw	r2,-4(fp)
 321966c:	10000005 	stb	zero,0(r2)
}
 3219670:	e037883a 	mov	sp,fp
 3219674:	dfc00117 	ldw	ra,4(sp)
 3219678:	df000017 	ldw	fp,0(sp)
 321967c:	dec00204 	addi	sp,sp,8
 3219680:	f800283a 	ret

03219684 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
 3219684:	defff804 	addi	sp,sp,-32
 3219688:	df000715 	stw	fp,28(sp)
 321968c:	df000704 	addi	fp,sp,28
 3219690:	e13ffd15 	stw	r4,-12(fp)
 3219694:	e17ffe15 	stw	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3219698:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 321969c:	e0bffd17 	ldw	r2,-12(fp)
 32196a0:	1004c03a 	cmpne	r2,r2,zero
 32196a4:	1000031e 	bne	r2,zero,32196b4 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
 32196a8:	00801804 	movi	r2,96
 32196ac:	e0bfff15 	stw	r2,-4(fp)
 32196b0:	00002b06 	br	3219760 <OSMemPut+0xdc>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
 32196b4:	e0bffe17 	ldw	r2,-8(fp)
 32196b8:	1004c03a 	cmpne	r2,r2,zero
 32196bc:	1000031e 	bne	r2,zero,32196cc <OSMemPut+0x48>
        return (OS_ERR_MEM_INVALID_PBLK);
 32196c0:	008017c4 	movi	r2,95
 32196c4:	e0bfff15 	stw	r2,-4(fp)
 32196c8:	00002506 	br	3219760 <OSMemPut+0xdc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32196cc:	0005303a 	rdctl	r2,status
 32196d0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32196d4:	e0fffb17 	ldw	r3,-20(fp)
 32196d8:	00bfff84 	movi	r2,-2
 32196dc:	1884703a 	and	r2,r3,r2
 32196e0:	1001703a 	wrctl	status,r2
  
  return context;
 32196e4:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 32196e8:	e0bffc15 	stw	r2,-16(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
 32196ec:	e0bffd17 	ldw	r2,-12(fp)
 32196f0:	10c00417 	ldw	r3,16(r2)
 32196f4:	e0bffd17 	ldw	r2,-12(fp)
 32196f8:	10800317 	ldw	r2,12(r2)
 32196fc:	18800736 	bltu	r3,r2,321971c <OSMemPut+0x98>
 3219700:	e0bffc17 	ldw	r2,-16(fp)
 3219704:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3219708:	e0bffa17 	ldw	r2,-24(fp)
 321970c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
 3219710:	00801784 	movi	r2,94
 3219714:	e0bfff15 	stw	r2,-4(fp)
 3219718:	00001106 	br	3219760 <OSMemPut+0xdc>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
 321971c:	e0fffe17 	ldw	r3,-8(fp)
 3219720:	e0bffd17 	ldw	r2,-12(fp)
 3219724:	10800117 	ldw	r2,4(r2)
 3219728:	18800015 	stw	r2,0(r3)
    pmem->OSMemFreeList = pblk;
 321972c:	e0fffd17 	ldw	r3,-12(fp)
 3219730:	e0bffe17 	ldw	r2,-8(fp)
 3219734:	18800115 	stw	r2,4(r3)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
 3219738:	e0bffd17 	ldw	r2,-12(fp)
 321973c:	10800417 	ldw	r2,16(r2)
 3219740:	10c00044 	addi	r3,r2,1
 3219744:	e0bffd17 	ldw	r2,-12(fp)
 3219748:	10c00415 	stw	r3,16(r2)
 321974c:	e0bffc17 	ldw	r2,-16(fp)
 3219750:	e0bff915 	stw	r2,-28(fp)
 3219754:	e0bff917 	ldw	r2,-28(fp)
 3219758:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
 321975c:	e03fff15 	stw	zero,-4(fp)
 3219760:	e0bfff17 	ldw	r2,-4(fp)
}
 3219764:	e037883a 	mov	sp,fp
 3219768:	df000017 	ldw	fp,0(sp)
 321976c:	dec00104 	addi	sp,sp,4
 3219770:	f800283a 	ret

03219774 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
 3219774:	defff904 	addi	sp,sp,-28
 3219778:	df000615 	stw	fp,24(sp)
 321977c:	df000604 	addi	fp,sp,24
 3219780:	e13ffd15 	stw	r4,-12(fp)
 3219784:	e17ffe15 	stw	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3219788:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 321978c:	e0bffd17 	ldw	r2,-12(fp)
 3219790:	1004c03a 	cmpne	r2,r2,zero
 3219794:	1000031e 	bne	r2,zero,32197a4 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
 3219798:	00801804 	movi	r2,96
 321979c:	e0bfff15 	stw	r2,-4(fp)
 32197a0:	00002e06 	br	321985c <OSMemQuery+0xe8>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
 32197a4:	e0bffe17 	ldw	r2,-8(fp)
 32197a8:	1004c03a 	cmpne	r2,r2,zero
 32197ac:	1000031e 	bne	r2,zero,32197bc <OSMemQuery+0x48>
        return (OS_ERR_MEM_INVALID_PDATA);
 32197b0:	00801844 	movi	r2,97
 32197b4:	e0bfff15 	stw	r2,-4(fp)
 32197b8:	00002806 	br	321985c <OSMemQuery+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32197bc:	0005303a 	rdctl	r2,status
 32197c0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32197c4:	e0fffb17 	ldw	r3,-20(fp)
 32197c8:	00bfff84 	movi	r2,-2
 32197cc:	1884703a 	and	r2,r3,r2
 32197d0:	1001703a 	wrctl	status,r2
  
  return context;
 32197d4:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 32197d8:	e0bffc15 	stw	r2,-16(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
 32197dc:	e0bffd17 	ldw	r2,-12(fp)
 32197e0:	10c00017 	ldw	r3,0(r2)
 32197e4:	e0bffe17 	ldw	r2,-8(fp)
 32197e8:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
 32197ec:	e0bffd17 	ldw	r2,-12(fp)
 32197f0:	10c00117 	ldw	r3,4(r2)
 32197f4:	e0bffe17 	ldw	r2,-8(fp)
 32197f8:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
 32197fc:	e0bffd17 	ldw	r2,-12(fp)
 3219800:	10c00217 	ldw	r3,8(r2)
 3219804:	e0bffe17 	ldw	r2,-8(fp)
 3219808:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
 321980c:	e0bffd17 	ldw	r2,-12(fp)
 3219810:	10c00317 	ldw	r3,12(r2)
 3219814:	e0bffe17 	ldw	r2,-8(fp)
 3219818:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
 321981c:	e0bffd17 	ldw	r2,-12(fp)
 3219820:	10c00417 	ldw	r3,16(r2)
 3219824:	e0bffe17 	ldw	r2,-8(fp)
 3219828:	10c00415 	stw	r3,16(r2)
 321982c:	e0bffc17 	ldw	r2,-16(fp)
 3219830:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3219834:	e0bffa17 	ldw	r2,-24(fp)
 3219838:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
 321983c:	e0bffe17 	ldw	r2,-8(fp)
 3219840:	10c00317 	ldw	r3,12(r2)
 3219844:	e0bffe17 	ldw	r2,-8(fp)
 3219848:	10800417 	ldw	r2,16(r2)
 321984c:	1887c83a 	sub	r3,r3,r2
 3219850:	e0bffe17 	ldw	r2,-8(fp)
 3219854:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
 3219858:	e03fff15 	stw	zero,-4(fp)
 321985c:	e0bfff17 	ldw	r2,-4(fp)
}
 3219860:	e037883a 	mov	sp,fp
 3219864:	df000017 	ldw	fp,0(sp)
 3219868:	dec00104 	addi	sp,sp,4
 321986c:	f800283a 	ret

03219870 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
 3219870:	defffc04 	addi	sp,sp,-16
 3219874:	dfc00315 	stw	ra,12(sp)
 3219878:	df000215 	stw	fp,8(sp)
 321987c:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
 3219880:	0100c9b4 	movhi	r4,806
 3219884:	2126d304 	addi	r4,r4,-25780
 3219888:	01430c04 	movi	r5,3120
 321988c:	3216ec80 	call	3216ec8 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
 3219890:	0080c9b4 	movhi	r2,806
 3219894:	10a6d304 	addi	r2,r2,-25780
 3219898:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 321989c:	e03ffe0d 	sth	zero,-8(fp)
 32198a0:	00001306 	br	32198f0 <OS_MemInit+0x80>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
 32198a4:	e0bffe0b 	ldhu	r2,-8(fp)
 32198a8:	10800d24 	muli	r2,r2,52
 32198ac:	1007883a 	mov	r3,r2
 32198b0:	0080c9b4 	movhi	r2,806
 32198b4:	10a6e004 	addi	r2,r2,-25728
 32198b8:	1887883a 	add	r3,r3,r2
 32198bc:	e0bfff17 	ldw	r2,-4(fp)
 32198c0:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
 32198c4:	e0ffff17 	ldw	r3,-4(fp)
 32198c8:	00800fc4 	movi	r2,63
 32198cc:	18800505 	stb	r2,20(r3)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
 32198d0:	e0bfff17 	ldw	r2,-4(fp)
 32198d4:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
 32198d8:	e0bfff17 	ldw	r2,-4(fp)
 32198dc:	10800d04 	addi	r2,r2,52
 32198e0:	e0bfff15 	stw	r2,-4(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 32198e4:	e0bffe0b 	ldhu	r2,-8(fp)
 32198e8:	10800044 	addi	r2,r2,1
 32198ec:	e0bffe0d 	sth	r2,-8(fp)
 32198f0:	e0bffe0b 	ldhu	r2,-8(fp)
 32198f4:	10800ef0 	cmpltui	r2,r2,59
 32198f8:	103fea1e 	bne	r2,zero,32198a4 <OS_MemInit+0x34>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
 32198fc:	e0bfff17 	ldw	r2,-4(fp)
 3219900:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
 3219904:	e0ffff17 	ldw	r3,-4(fp)
 3219908:	00800fc4 	movi	r2,63
 321990c:	18800505 	stb	r2,20(r3)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
 3219910:	e0bfff17 	ldw	r2,-4(fp)
 3219914:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
 3219918:	00c0c974 	movhi	r3,805
 321991c:	18d30f04 	addi	r3,r3,19516
 3219920:	0080c9b4 	movhi	r2,806
 3219924:	10a6d304 	addi	r2,r2,-25780
 3219928:	18800015 	stw	r2,0(r3)
#endif
}
 321992c:	e037883a 	mov	sp,fp
 3219930:	dfc00117 	ldw	ra,4(sp)
 3219934:	df000017 	ldw	fp,0(sp)
 3219938:	dec00204 	addi	sp,sp,8
 321993c:	f800283a 	ret

03219940 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
 3219940:	defff704 	addi	sp,sp,-36
 3219944:	df000815 	stw	fp,32(sp)
 3219948:	df000804 	addi	fp,sp,32
 321994c:	e13ffd15 	stw	r4,-12(fp)
 3219950:	e17ffe15 	stw	r5,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3219954:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 3219958:	e0bffe17 	ldw	r2,-8(fp)
 321995c:	1004c03a 	cmpne	r2,r2,zero
 3219960:	1000021e 	bne	r2,zero,321996c <OSQAccept+0x2c>
        return ((void *)0);
 3219964:	e03fff15 	stw	zero,-4(fp)
 3219968:	00004506 	br	3219a80 <OSQAccept+0x140>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 321996c:	e0bffd17 	ldw	r2,-12(fp)
 3219970:	1004c03a 	cmpne	r2,r2,zero
 3219974:	1000051e 	bne	r2,zero,321998c <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
 3219978:	e0fffe17 	ldw	r3,-8(fp)
 321997c:	00800104 	movi	r2,4
 3219980:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 3219984:	e03fff15 	stw	zero,-4(fp)
 3219988:	00003d06 	br	3219a80 <OSQAccept+0x140>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 321998c:	e0bffd17 	ldw	r2,-12(fp)
 3219990:	10800003 	ldbu	r2,0(r2)
 3219994:	10803fcc 	andi	r2,r2,255
 3219998:	108000a0 	cmpeqi	r2,r2,2
 321999c:	1000051e 	bne	r2,zero,32199b4 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
 32199a0:	e0fffe17 	ldw	r3,-8(fp)
 32199a4:	00800044 	movi	r2,1
 32199a8:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 32199ac:	e03fff15 	stw	zero,-4(fp)
 32199b0:	00003306 	br	3219a80 <OSQAccept+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32199b4:	0005303a 	rdctl	r2,status
 32199b8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32199bc:	e0fff917 	ldw	r3,-28(fp)
 32199c0:	00bfff84 	movi	r2,-2
 32199c4:	1884703a 	and	r2,r3,r2
 32199c8:	1001703a 	wrctl	status,r2
  
  return context;
 32199cc:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 32199d0:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 32199d4:	e0bffd17 	ldw	r2,-12(fp)
 32199d8:	10800117 	ldw	r2,4(r2)
 32199dc:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 32199e0:	e0bffb17 	ldw	r2,-20(fp)
 32199e4:	1080058b 	ldhu	r2,22(r2)
 32199e8:	10bfffcc 	andi	r2,r2,65535
 32199ec:	1005003a 	cmpeq	r2,r2,zero
 32199f0:	1000191e 	bne	r2,zero,3219a58 <OSQAccept+0x118>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 32199f4:	e0bffb17 	ldw	r2,-20(fp)
 32199f8:	10c00417 	ldw	r3,16(r2)
 32199fc:	18800017 	ldw	r2,0(r3)
 3219a00:	e0bffc15 	stw	r2,-16(fp)
 3219a04:	18c00104 	addi	r3,r3,4
 3219a08:	e0bffb17 	ldw	r2,-20(fp)
 3219a0c:	10c00415 	stw	r3,16(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 3219a10:	e0bffb17 	ldw	r2,-20(fp)
 3219a14:	1080058b 	ldhu	r2,22(r2)
 3219a18:	10bfffc4 	addi	r2,r2,-1
 3219a1c:	1007883a 	mov	r3,r2
 3219a20:	e0bffb17 	ldw	r2,-20(fp)
 3219a24:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 3219a28:	e0bffb17 	ldw	r2,-20(fp)
 3219a2c:	10c00417 	ldw	r3,16(r2)
 3219a30:	e0bffb17 	ldw	r2,-20(fp)
 3219a34:	10800217 	ldw	r2,8(r2)
 3219a38:	1880041e 	bne	r3,r2,3219a4c <OSQAccept+0x10c>
            pq->OSQOut = pq->OSQStart;
 3219a3c:	e0bffb17 	ldw	r2,-20(fp)
 3219a40:	10c00117 	ldw	r3,4(r2)
 3219a44:	e0bffb17 	ldw	r2,-20(fp)
 3219a48:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
 3219a4c:	e0bffe17 	ldw	r2,-8(fp)
 3219a50:	10000005 	stb	zero,0(r2)
 3219a54:	00000406 	br	3219a68 <OSQAccept+0x128>
    } else {
        *perr = OS_ERR_Q_EMPTY;
 3219a58:	e0fffe17 	ldw	r3,-8(fp)
 3219a5c:	008007c4 	movi	r2,31
 3219a60:	18800005 	stb	r2,0(r3)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
 3219a64:	e03ffc15 	stw	zero,-16(fp)
 3219a68:	e0bffa17 	ldw	r2,-24(fp)
 3219a6c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3219a70:	e0bff817 	ldw	r2,-32(fp)
 3219a74:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
 3219a78:	e0bffc17 	ldw	r2,-16(fp)
 3219a7c:	e0bfff15 	stw	r2,-4(fp)
 3219a80:	e0bfff17 	ldw	r2,-4(fp)
}
 3219a84:	e037883a 	mov	sp,fp
 3219a88:	df000017 	ldw	fp,0(sp)
 3219a8c:	dec00104 	addi	sp,sp,4
 3219a90:	f800283a 	ret

03219a94 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
 3219a94:	defff304 	addi	sp,sp,-52
 3219a98:	dfc00c15 	stw	ra,48(sp)
 3219a9c:	df000b15 	stw	fp,44(sp)
 3219aa0:	df000b04 	addi	fp,sp,44
 3219aa4:	e13ffd15 	stw	r4,-12(fp)
 3219aa8:	e17ffe0d 	sth	r5,-8(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 3219aac:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 3219ab0:	0080c974 	movhi	r2,805
 3219ab4:	10931404 	addi	r2,r2,19536
 3219ab8:	10800003 	ldbu	r2,0(r2)
 3219abc:	10803fcc 	andi	r2,r2,255
 3219ac0:	1005003a 	cmpeq	r2,r2,zero
 3219ac4:	1000021e 	bne	r2,zero,3219ad0 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 3219ac8:	e03fff15 	stw	zero,-4(fp)
 3219acc:	00007006 	br	3219c90 <OSQCreate+0x1fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3219ad0:	0005303a 	rdctl	r2,status
 3219ad4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3219ad8:	e0fff917 	ldw	r3,-28(fp)
 3219adc:	00bfff84 	movi	r2,-2
 3219ae0:	1884703a 	and	r2,r3,r2
 3219ae4:	1001703a 	wrctl	status,r2
  
  return context;
 3219ae8:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 3219aec:	e0bffa15 	stw	r2,-24(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
 3219af0:	0080c974 	movhi	r2,805
 3219af4:	10931304 	addi	r2,r2,19532
 3219af8:	10800017 	ldw	r2,0(r2)
 3219afc:	e0bffc15 	stw	r2,-16(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 3219b00:	0080c974 	movhi	r2,805
 3219b04:	10931304 	addi	r2,r2,19532
 3219b08:	10800017 	ldw	r2,0(r2)
 3219b0c:	1005003a 	cmpeq	r2,r2,zero
 3219b10:	1000081e 	bne	r2,zero,3219b34 <OSQCreate+0xa0>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 3219b14:	0080c974 	movhi	r2,805
 3219b18:	10931304 	addi	r2,r2,19532
 3219b1c:	10800017 	ldw	r2,0(r2)
 3219b20:	10800117 	ldw	r2,4(r2)
 3219b24:	1007883a 	mov	r3,r2
 3219b28:	0080c974 	movhi	r2,805
 3219b2c:	10931304 	addi	r2,r2,19532
 3219b30:	10c00015 	stw	r3,0(r2)
 3219b34:	e0bffa17 	ldw	r2,-24(fp)
 3219b38:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3219b3c:	e0bff817 	ldw	r2,-32(fp)
 3219b40:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
 3219b44:	e0bffc17 	ldw	r2,-16(fp)
 3219b48:	1005003a 	cmpeq	r2,r2,zero
 3219b4c:	10004e1e 	bne	r2,zero,3219c88 <OSQCreate+0x1f4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3219b50:	0005303a 	rdctl	r2,status
 3219b54:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3219b58:	e0fff717 	ldw	r3,-36(fp)
 3219b5c:	00bfff84 	movi	r2,-2
 3219b60:	1884703a 	and	r2,r3,r2
 3219b64:	1001703a 	wrctl	status,r2
  
  return context;
 3219b68:	e0bff717 	ldw	r2,-36(fp)
        OS_ENTER_CRITICAL();
 3219b6c:	e0bffa15 	stw	r2,-24(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
 3219b70:	0080c974 	movhi	r2,805
 3219b74:	10931104 	addi	r2,r2,19524
 3219b78:	10800017 	ldw	r2,0(r2)
 3219b7c:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
 3219b80:	e0bffb17 	ldw	r2,-20(fp)
 3219b84:	1005003a 	cmpeq	r2,r2,zero
 3219b88:	1000311e 	bne	r2,zero,3219c50 <OSQCreate+0x1bc>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
 3219b8c:	0080c974 	movhi	r2,805
 3219b90:	10931104 	addi	r2,r2,19524
 3219b94:	10800017 	ldw	r2,0(r2)
 3219b98:	10c00017 	ldw	r3,0(r2)
 3219b9c:	0080c974 	movhi	r2,805
 3219ba0:	10931104 	addi	r2,r2,19524
 3219ba4:	10c00015 	stw	r3,0(r2)
 3219ba8:	e0bffa17 	ldw	r2,-24(fp)
 3219bac:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3219bb0:	e0bff617 	ldw	r2,-40(fp)
 3219bb4:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
 3219bb8:	e0fffb17 	ldw	r3,-20(fp)
 3219bbc:	e0bffd17 	ldw	r2,-12(fp)
 3219bc0:	18800115 	stw	r2,4(r3)
            pq->OSQEnd             = &start[size];
 3219bc4:	e0bffe0b 	ldhu	r2,-8(fp)
 3219bc8:	1085883a 	add	r2,r2,r2
 3219bcc:	1085883a 	add	r2,r2,r2
 3219bd0:	1007883a 	mov	r3,r2
 3219bd4:	e0bffd17 	ldw	r2,-12(fp)
 3219bd8:	1887883a 	add	r3,r3,r2
 3219bdc:	e0bffb17 	ldw	r2,-20(fp)
 3219be0:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
 3219be4:	e0fffb17 	ldw	r3,-20(fp)
 3219be8:	e0bffd17 	ldw	r2,-12(fp)
 3219bec:	18800315 	stw	r2,12(r3)
            pq->OSQOut             = start;
 3219bf0:	e0fffb17 	ldw	r3,-20(fp)
 3219bf4:	e0bffd17 	ldw	r2,-12(fp)
 3219bf8:	18800415 	stw	r2,16(r3)
            pq->OSQSize            = size;
 3219bfc:	e0fffb17 	ldw	r3,-20(fp)
 3219c00:	e0bffe0b 	ldhu	r2,-8(fp)
 3219c04:	1880050d 	sth	r2,20(r3)
            pq->OSQEntries         = 0;
 3219c08:	e0bffb17 	ldw	r2,-20(fp)
 3219c0c:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
 3219c10:	e0fffc17 	ldw	r3,-16(fp)
 3219c14:	00800084 	movi	r2,2
 3219c18:	18800005 	stb	r2,0(r3)
            pevent->OSEventCnt     = 0;
 3219c1c:	e0bffc17 	ldw	r2,-16(fp)
 3219c20:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
 3219c24:	e0fffc17 	ldw	r3,-16(fp)
 3219c28:	e0bffb17 	ldw	r2,-20(fp)
 3219c2c:	18800115 	stw	r2,4(r3)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
 3219c30:	e0fffc17 	ldw	r3,-16(fp)
 3219c34:	00800fc4 	movi	r2,63
 3219c38:	18800385 	stb	r2,14(r3)
            pevent->OSEventName[1] = OS_ASCII_NUL;
 3219c3c:	e0bffc17 	ldw	r2,-16(fp)
 3219c40:	100003c5 	stb	zero,15(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
 3219c44:	e13ffc17 	ldw	r4,-16(fp)
 3219c48:	3216afc0 	call	3216afc <OS_EventWaitListInit>
 3219c4c:	00000e06 	br	3219c88 <OSQCreate+0x1f4>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
 3219c50:	0080c974 	movhi	r2,805
 3219c54:	10931304 	addi	r2,r2,19532
 3219c58:	10c00017 	ldw	r3,0(r2)
 3219c5c:	e0bffc17 	ldw	r2,-16(fp)
 3219c60:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
 3219c64:	00c0c974 	movhi	r3,805
 3219c68:	18d31304 	addi	r3,r3,19532
 3219c6c:	e0bffc17 	ldw	r2,-16(fp)
 3219c70:	18800015 	stw	r2,0(r3)
 3219c74:	e0bffa17 	ldw	r2,-24(fp)
 3219c78:	e0bff515 	stw	r2,-44(fp)
 3219c7c:	e0bff517 	ldw	r2,-44(fp)
 3219c80:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
 3219c84:	e03ffc15 	stw	zero,-16(fp)
        }
    }
    return (pevent);
 3219c88:	e0bffc17 	ldw	r2,-16(fp)
 3219c8c:	e0bfff15 	stw	r2,-4(fp)
 3219c90:	e0bfff17 	ldw	r2,-4(fp)
}
 3219c94:	e037883a 	mov	sp,fp
 3219c98:	dfc00117 	ldw	ra,4(sp)
 3219c9c:	df000017 	ldw	fp,0(sp)
 3219ca0:	dec00204 	addi	sp,sp,8
 3219ca4:	f800283a 	ret

03219ca8 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 3219ca8:	defff004 	addi	sp,sp,-64
 3219cac:	dfc00f15 	stw	ra,60(sp)
 3219cb0:	df000e15 	stw	fp,56(sp)
 3219cb4:	df000e04 	addi	fp,sp,56
 3219cb8:	e13ffb15 	stw	r4,-20(fp)
 3219cbc:	e1bffd15 	stw	r6,-12(fp)
 3219cc0:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 3219cc4:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 3219cc8:	e0bffd17 	ldw	r2,-12(fp)
 3219ccc:	1004c03a 	cmpne	r2,r2,zero
 3219cd0:	1000031e 	bne	r2,zero,3219ce0 <OSQDel+0x38>
        return (pevent);
 3219cd4:	e0bffb17 	ldw	r2,-20(fp)
 3219cd8:	e0bfff15 	stw	r2,-4(fp)
 3219cdc:	0000ac06 	br	3219f90 <OSQDel+0x2e8>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 3219ce0:	e0bffb17 	ldw	r2,-20(fp)
 3219ce4:	1004c03a 	cmpne	r2,r2,zero
 3219ce8:	1000061e 	bne	r2,zero,3219d04 <OSQDel+0x5c>
        *perr = OS_ERR_PEVENT_NULL;
 3219cec:	e0fffd17 	ldw	r3,-12(fp)
 3219cf0:	00800104 	movi	r2,4
 3219cf4:	18800005 	stb	r2,0(r3)
        return (pevent);
 3219cf8:	e0fffb17 	ldw	r3,-20(fp)
 3219cfc:	e0ffff15 	stw	r3,-4(fp)
 3219d00:	0000a306 	br	3219f90 <OSQDel+0x2e8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 3219d04:	e0bffb17 	ldw	r2,-20(fp)
 3219d08:	10800003 	ldbu	r2,0(r2)
 3219d0c:	10803fcc 	andi	r2,r2,255
 3219d10:	108000a0 	cmpeqi	r2,r2,2
 3219d14:	1000061e 	bne	r2,zero,3219d30 <OSQDel+0x88>
        *perr = OS_ERR_EVENT_TYPE;
 3219d18:	e0fffd17 	ldw	r3,-12(fp)
 3219d1c:	00800044 	movi	r2,1
 3219d20:	18800005 	stb	r2,0(r3)
        return (pevent);
 3219d24:	e0bffb17 	ldw	r2,-20(fp)
 3219d28:	e0bfff15 	stw	r2,-4(fp)
 3219d2c:	00009806 	br	3219f90 <OSQDel+0x2e8>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 3219d30:	0080c974 	movhi	r2,805
 3219d34:	10931404 	addi	r2,r2,19536
 3219d38:	10800003 	ldbu	r2,0(r2)
 3219d3c:	10803fcc 	andi	r2,r2,255
 3219d40:	1005003a 	cmpeq	r2,r2,zero
 3219d44:	1000061e 	bne	r2,zero,3219d60 <OSQDel+0xb8>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 3219d48:	e0fffd17 	ldw	r3,-12(fp)
 3219d4c:	008003c4 	movi	r2,15
 3219d50:	18800005 	stb	r2,0(r3)
        return (pevent);
 3219d54:	e0fffb17 	ldw	r3,-20(fp)
 3219d58:	e0ffff15 	stw	r3,-4(fp)
 3219d5c:	00008c06 	br	3219f90 <OSQDel+0x2e8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3219d60:	0005303a 	rdctl	r2,status
 3219d64:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3219d68:	e0fff617 	ldw	r3,-40(fp)
 3219d6c:	00bfff84 	movi	r2,-2
 3219d70:	1884703a 	and	r2,r3,r2
 3219d74:	1001703a 	wrctl	status,r2
  
  return context;
 3219d78:	e0bff617 	ldw	r2,-40(fp)
    }
    OS_ENTER_CRITICAL();
 3219d7c:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
 3219d80:	e0bffb17 	ldw	r2,-20(fp)
 3219d84:	10800283 	ldbu	r2,10(r2)
 3219d88:	10803fcc 	andi	r2,r2,255
 3219d8c:	1005003a 	cmpeq	r2,r2,zero
 3219d90:	1000031e 	bne	r2,zero,3219da0 <OSQDel+0xf8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 3219d94:	00800044 	movi	r2,1
 3219d98:	e0bffa05 	stb	r2,-24(fp)
 3219d9c:	00000106 	br	3219da4 <OSQDel+0xfc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 3219da0:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 3219da4:	e0bffc03 	ldbu	r2,-16(fp)
 3219da8:	e0bffe15 	stw	r2,-8(fp)
 3219dac:	e0fffe17 	ldw	r3,-8(fp)
 3219db0:	1805003a 	cmpeq	r2,r3,zero
 3219db4:	1000041e 	bne	r2,zero,3219dc8 <OSQDel+0x120>
 3219db8:	e0fffe17 	ldw	r3,-8(fp)
 3219dbc:	18800060 	cmpeqi	r2,r3,1
 3219dc0:	1000391e 	bne	r2,zero,3219ea8 <OSQDel+0x200>
 3219dc4:	00006706 	br	3219f64 <OSQDel+0x2bc>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
 3219dc8:	e0bffa03 	ldbu	r2,-24(fp)
 3219dcc:	1004c03a 	cmpne	r2,r2,zero
 3219dd0:	1000261e 	bne	r2,zero,3219e6c <OSQDel+0x1c4>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 3219dd4:	e0fffb17 	ldw	r3,-20(fp)
 3219dd8:	00800fc4 	movi	r2,63
 3219ddc:	18800385 	stb	r2,14(r3)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 3219de0:	e0bffb17 	ldw	r2,-20(fp)
 3219de4:	100003c5 	stb	zero,15(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
 3219de8:	e0bffb17 	ldw	r2,-20(fp)
 3219dec:	10800117 	ldw	r2,4(r2)
 3219df0:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
 3219df4:	0080c974 	movhi	r2,805
 3219df8:	10931104 	addi	r2,r2,19524
 3219dfc:	10c00017 	ldw	r3,0(r2)
 3219e00:	e0bff817 	ldw	r2,-32(fp)
 3219e04:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
 3219e08:	00c0c974 	movhi	r3,805
 3219e0c:	18d31104 	addi	r3,r3,19524
 3219e10:	e0bff817 	ldw	r2,-32(fp)
 3219e14:	18800015 	stw	r2,0(r3)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 3219e18:	e0bffb17 	ldw	r2,-20(fp)
 3219e1c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 3219e20:	0080c974 	movhi	r2,805
 3219e24:	10931304 	addi	r2,r2,19532
 3219e28:	10c00017 	ldw	r3,0(r2)
 3219e2c:	e0bffb17 	ldw	r2,-20(fp)
 3219e30:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 3219e34:	e0bffb17 	ldw	r2,-20(fp)
 3219e38:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 3219e3c:	00c0c974 	movhi	r3,805
 3219e40:	18d31304 	addi	r3,r3,19532
 3219e44:	e0bffb17 	ldw	r2,-20(fp)
 3219e48:	18800015 	stw	r2,0(r3)
 3219e4c:	e0bff717 	ldw	r2,-36(fp)
 3219e50:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3219e54:	e0bff517 	ldw	r2,-44(fp)
 3219e58:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 3219e5c:	e0bffd17 	ldw	r2,-12(fp)
 3219e60:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
 3219e64:	e03ff915 	stw	zero,-28(fp)
 3219e68:	00004706 	br	3219f88 <OSQDel+0x2e0>
 3219e6c:	e0bff717 	ldw	r2,-36(fp)
 3219e70:	e0bff415 	stw	r2,-48(fp)
 3219e74:	e0bff417 	ldw	r2,-48(fp)
 3219e78:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 3219e7c:	e0fffd17 	ldw	r3,-12(fp)
 3219e80:	00801244 	movi	r2,73
 3219e84:	18800005 	stb	r2,0(r3)
                 pevent_return          = pevent;
 3219e88:	e0bffb17 	ldw	r2,-20(fp)
 3219e8c:	e0bff915 	stw	r2,-28(fp)
             }
             break;
 3219e90:	00003d06 	br	3219f88 <OSQDel+0x2e0>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
 3219e94:	e13ffb17 	ldw	r4,-20(fp)
 3219e98:	000b883a 	mov	r5,zero
 3219e9c:	01800104 	movi	r6,4
 3219ea0:	000f883a 	mov	r7,zero
 3219ea4:	32165480 	call	3216548 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
 3219ea8:	e0bffb17 	ldw	r2,-20(fp)
 3219eac:	10800283 	ldbu	r2,10(r2)
 3219eb0:	10803fcc 	andi	r2,r2,255
 3219eb4:	1004c03a 	cmpne	r2,r2,zero
 3219eb8:	103ff61e 	bne	r2,zero,3219e94 <OSQDel+0x1ec>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 3219ebc:	e0fffb17 	ldw	r3,-20(fp)
 3219ec0:	00800fc4 	movi	r2,63
 3219ec4:	18800385 	stb	r2,14(r3)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 3219ec8:	e0bffb17 	ldw	r2,-20(fp)
 3219ecc:	100003c5 	stb	zero,15(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
 3219ed0:	e0bffb17 	ldw	r2,-20(fp)
 3219ed4:	10800117 	ldw	r2,4(r2)
 3219ed8:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
 3219edc:	0080c974 	movhi	r2,805
 3219ee0:	10931104 	addi	r2,r2,19524
 3219ee4:	10c00017 	ldw	r3,0(r2)
 3219ee8:	e0bff817 	ldw	r2,-32(fp)
 3219eec:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
 3219ef0:	00c0c974 	movhi	r3,805
 3219ef4:	18d31104 	addi	r3,r3,19524
 3219ef8:	e0bff817 	ldw	r2,-32(fp)
 3219efc:	18800015 	stw	r2,0(r3)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 3219f00:	e0bffb17 	ldw	r2,-20(fp)
 3219f04:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 3219f08:	0080c974 	movhi	r2,805
 3219f0c:	10931304 	addi	r2,r2,19532
 3219f10:	10c00017 	ldw	r3,0(r2)
 3219f14:	e0bffb17 	ldw	r2,-20(fp)
 3219f18:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 3219f1c:	e0bffb17 	ldw	r2,-20(fp)
 3219f20:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 3219f24:	00c0c974 	movhi	r3,805
 3219f28:	18d31304 	addi	r3,r3,19532
 3219f2c:	e0bffb17 	ldw	r2,-20(fp)
 3219f30:	18800015 	stw	r2,0(r3)
 3219f34:	e0bff717 	ldw	r2,-36(fp)
 3219f38:	e0bff315 	stw	r2,-52(fp)
 3219f3c:	e0bff317 	ldw	r2,-52(fp)
 3219f40:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 3219f44:	e0bffa03 	ldbu	r2,-24(fp)
 3219f48:	10800058 	cmpnei	r2,r2,1
 3219f4c:	1000011e 	bne	r2,zero,3219f54 <OSQDel+0x2ac>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 3219f50:	3216f880 	call	3216f88 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 3219f54:	e0bffd17 	ldw	r2,-12(fp)
 3219f58:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
 3219f5c:	e03ff915 	stw	zero,-28(fp)
             break;
 3219f60:	00000906 	br	3219f88 <OSQDel+0x2e0>
 3219f64:	e0bff717 	ldw	r2,-36(fp)
 3219f68:	e0bff215 	stw	r2,-56(fp)
 3219f6c:	e0bff217 	ldw	r2,-56(fp)
 3219f70:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 3219f74:	e0fffd17 	ldw	r3,-12(fp)
 3219f78:	008001c4 	movi	r2,7
 3219f7c:	18800005 	stb	r2,0(r3)
             pevent_return          = pevent;
 3219f80:	e0bffb17 	ldw	r2,-20(fp)
 3219f84:	e0bff915 	stw	r2,-28(fp)
             break;
    }
    return (pevent_return);
 3219f88:	e0bff917 	ldw	r2,-28(fp)
 3219f8c:	e0bfff15 	stw	r2,-4(fp)
 3219f90:	e0bfff17 	ldw	r2,-4(fp)
}
 3219f94:	e037883a 	mov	sp,fp
 3219f98:	dfc00117 	ldw	ra,4(sp)
 3219f9c:	df000017 	ldw	fp,0(sp)
 3219fa0:	dec00204 	addi	sp,sp,8
 3219fa4:	f800283a 	ret

03219fa8 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
 3219fa8:	defff904 	addi	sp,sp,-28
 3219fac:	df000615 	stw	fp,24(sp)
 3219fb0:	df000604 	addi	fp,sp,24
 3219fb4:	e13ffe15 	stw	r4,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 3219fb8:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 3219fbc:	e0bffe17 	ldw	r2,-8(fp)
 3219fc0:	1004c03a 	cmpne	r2,r2,zero
 3219fc4:	1000031e 	bne	r2,zero,3219fd4 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
 3219fc8:	00800104 	movi	r2,4
 3219fcc:	e0bfff15 	stw	r2,-4(fp)
 3219fd0:	00002206 	br	321a05c <OSQFlush+0xb4>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 3219fd4:	e0bffe17 	ldw	r2,-8(fp)
 3219fd8:	10800003 	ldbu	r2,0(r2)
 3219fdc:	10803fcc 	andi	r2,r2,255
 3219fe0:	108000a0 	cmpeqi	r2,r2,2
 3219fe4:	1000031e 	bne	r2,zero,3219ff4 <OSQFlush+0x4c>
        return (OS_ERR_EVENT_TYPE);
 3219fe8:	00800044 	movi	r2,1
 3219fec:	e0bfff15 	stw	r2,-4(fp)
 3219ff0:	00001a06 	br	321a05c <OSQFlush+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3219ff4:	0005303a 	rdctl	r2,status
 3219ff8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3219ffc:	e0fffb17 	ldw	r3,-20(fp)
 321a000:	00bfff84 	movi	r2,-2
 321a004:	1884703a 	and	r2,r3,r2
 321a008:	1001703a 	wrctl	status,r2
  
  return context;
 321a00c:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 321a010:	e0bffc15 	stw	r2,-16(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
 321a014:	e0bffe17 	ldw	r2,-8(fp)
 321a018:	10800117 	ldw	r2,4(r2)
 321a01c:	e0bffd15 	stw	r2,-12(fp)
    pq->OSQIn      = pq->OSQStart;
 321a020:	e0bffd17 	ldw	r2,-12(fp)
 321a024:	10c00117 	ldw	r3,4(r2)
 321a028:	e0bffd17 	ldw	r2,-12(fp)
 321a02c:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
 321a030:	e0bffd17 	ldw	r2,-12(fp)
 321a034:	10c00117 	ldw	r3,4(r2)
 321a038:	e0bffd17 	ldw	r2,-12(fp)
 321a03c:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
 321a040:	e0bffd17 	ldw	r2,-12(fp)
 321a044:	1000058d 	sth	zero,22(r2)
 321a048:	e0bffc17 	ldw	r2,-16(fp)
 321a04c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321a050:	e0bffa17 	ldw	r2,-24(fp)
 321a054:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 321a058:	e03fff15 	stw	zero,-4(fp)
 321a05c:	e0bfff17 	ldw	r2,-4(fp)
}
 321a060:	e037883a 	mov	sp,fp
 321a064:	df000017 	ldw	fp,0(sp)
 321a068:	dec00104 	addi	sp,sp,4
 321a06c:	f800283a 	ret

0321a070 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 321a070:	defff104 	addi	sp,sp,-60
 321a074:	dfc00e15 	stw	ra,56(sp)
 321a078:	df000d15 	stw	fp,52(sp)
 321a07c:	df000d04 	addi	fp,sp,52
 321a080:	e13ffb15 	stw	r4,-20(fp)
 321a084:	e1bffd15 	stw	r6,-12(fp)
 321a088:	e17ffc0d 	sth	r5,-16(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 321a08c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 321a090:	e0bffd17 	ldw	r2,-12(fp)
 321a094:	1004c03a 	cmpne	r2,r2,zero
 321a098:	1000021e 	bne	r2,zero,321a0a4 <OSQPend+0x34>
        return ((void *)0);
 321a09c:	e03fff15 	stw	zero,-4(fp)
 321a0a0:	0000b506 	br	321a378 <OSQPend+0x308>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 321a0a4:	e0bffb17 	ldw	r2,-20(fp)
 321a0a8:	1004c03a 	cmpne	r2,r2,zero
 321a0ac:	1000051e 	bne	r2,zero,321a0c4 <OSQPend+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 321a0b0:	e0fffd17 	ldw	r3,-12(fp)
 321a0b4:	00800104 	movi	r2,4
 321a0b8:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 321a0bc:	e03fff15 	stw	zero,-4(fp)
 321a0c0:	0000ad06 	br	321a378 <OSQPend+0x308>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 321a0c4:	e0bffb17 	ldw	r2,-20(fp)
 321a0c8:	10800003 	ldbu	r2,0(r2)
 321a0cc:	10803fcc 	andi	r2,r2,255
 321a0d0:	108000a0 	cmpeqi	r2,r2,2
 321a0d4:	1000051e 	bne	r2,zero,321a0ec <OSQPend+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 321a0d8:	e0fffd17 	ldw	r3,-12(fp)
 321a0dc:	00800044 	movi	r2,1
 321a0e0:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 321a0e4:	e03fff15 	stw	zero,-4(fp)
 321a0e8:	0000a306 	br	321a378 <OSQPend+0x308>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 321a0ec:	0080c974 	movhi	r2,805
 321a0f0:	10931404 	addi	r2,r2,19536
 321a0f4:	10800003 	ldbu	r2,0(r2)
 321a0f8:	10803fcc 	andi	r2,r2,255
 321a0fc:	1005003a 	cmpeq	r2,r2,zero
 321a100:	1000051e 	bne	r2,zero,321a118 <OSQPend+0xa8>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
 321a104:	e0fffd17 	ldw	r3,-12(fp)
 321a108:	00800084 	movi	r2,2
 321a10c:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 321a110:	e03fff15 	stw	zero,-4(fp)
 321a114:	00009806 	br	321a378 <OSQPend+0x308>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
 321a118:	0080c974 	movhi	r2,805
 321a11c:	10930604 	addi	r2,r2,19480
 321a120:	10800003 	ldbu	r2,0(r2)
 321a124:	10803fcc 	andi	r2,r2,255
 321a128:	1005003a 	cmpeq	r2,r2,zero
 321a12c:	1000051e 	bne	r2,zero,321a144 <OSQPend+0xd4>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
 321a130:	e0fffd17 	ldw	r3,-12(fp)
 321a134:	00800344 	movi	r2,13
 321a138:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 321a13c:	e03fff15 	stw	zero,-4(fp)
 321a140:	00008d06 	br	321a378 <OSQPend+0x308>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321a144:	0005303a 	rdctl	r2,status
 321a148:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321a14c:	e0fff717 	ldw	r3,-36(fp)
 321a150:	00bfff84 	movi	r2,-2
 321a154:	1884703a 	and	r2,r3,r2
 321a158:	1001703a 	wrctl	status,r2
  
  return context;
 321a15c:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 321a160:	e0bff815 	stw	r2,-32(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 321a164:	e0bffb17 	ldw	r2,-20(fp)
 321a168:	10800117 	ldw	r2,4(r2)
 321a16c:	e0bff915 	stw	r2,-28(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 321a170:	e0bff917 	ldw	r2,-28(fp)
 321a174:	1080058b 	ldhu	r2,22(r2)
 321a178:	10bfffcc 	andi	r2,r2,65535
 321a17c:	1005003a 	cmpeq	r2,r2,zero
 321a180:	10001f1e 	bne	r2,zero,321a200 <OSQPend+0x190>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 321a184:	e0bff917 	ldw	r2,-28(fp)
 321a188:	10c00417 	ldw	r3,16(r2)
 321a18c:	18800017 	ldw	r2,0(r3)
 321a190:	e0bffa15 	stw	r2,-24(fp)
 321a194:	18c00104 	addi	r3,r3,4
 321a198:	e0bff917 	ldw	r2,-28(fp)
 321a19c:	10c00415 	stw	r3,16(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 321a1a0:	e0bff917 	ldw	r2,-28(fp)
 321a1a4:	1080058b 	ldhu	r2,22(r2)
 321a1a8:	10bfffc4 	addi	r2,r2,-1
 321a1ac:	1007883a 	mov	r3,r2
 321a1b0:	e0bff917 	ldw	r2,-28(fp)
 321a1b4:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 321a1b8:	e0bff917 	ldw	r2,-28(fp)
 321a1bc:	10c00417 	ldw	r3,16(r2)
 321a1c0:	e0bff917 	ldw	r2,-28(fp)
 321a1c4:	10800217 	ldw	r2,8(r2)
 321a1c8:	1880041e 	bne	r3,r2,321a1dc <OSQPend+0x16c>
            pq->OSQOut = pq->OSQStart;
 321a1cc:	e0bff917 	ldw	r2,-28(fp)
 321a1d0:	10c00117 	ldw	r3,4(r2)
 321a1d4:	e0bff917 	ldw	r2,-28(fp)
 321a1d8:	10c00415 	stw	r3,16(r2)
 321a1dc:	e0bff817 	ldw	r2,-32(fp)
 321a1e0:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321a1e4:	e0bff617 	ldw	r2,-40(fp)
 321a1e8:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 321a1ec:	e0bffd17 	ldw	r2,-12(fp)
 321a1f0:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
 321a1f4:	e0bffa17 	ldw	r2,-24(fp)
 321a1f8:	e0bfff15 	stw	r2,-4(fp)
 321a1fc:	00005e06 	br	321a378 <OSQPend+0x308>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
 321a200:	0080c974 	movhi	r2,805
 321a204:	10931504 	addi	r2,r2,19540
 321a208:	10c00017 	ldw	r3,0(r2)
 321a20c:	0080c974 	movhi	r2,805
 321a210:	10931504 	addi	r2,r2,19540
 321a214:	10800017 	ldw	r2,0(r2)
 321a218:	10800c03 	ldbu	r2,48(r2)
 321a21c:	10800114 	ori	r2,r2,4
 321a220:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 321a224:	0080c974 	movhi	r2,805
 321a228:	10931504 	addi	r2,r2,19540
 321a22c:	10800017 	ldw	r2,0(r2)
 321a230:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
 321a234:	0080c974 	movhi	r2,805
 321a238:	10931504 	addi	r2,r2,19540
 321a23c:	10c00017 	ldw	r3,0(r2)
 321a240:	e0bffc0b 	ldhu	r2,-16(fp)
 321a244:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
 321a248:	e13ffb17 	ldw	r4,-20(fp)
 321a24c:	32166dc0 	call	32166dc <OS_EventTaskWait>
 321a250:	e0bff817 	ldw	r2,-32(fp)
 321a254:	e0bff515 	stw	r2,-44(fp)
 321a258:	e0bff517 	ldw	r2,-44(fp)
 321a25c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
 321a260:	3216f880 	call	3216f88 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321a264:	0005303a 	rdctl	r2,status
 321a268:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321a26c:	e0fff417 	ldw	r3,-48(fp)
 321a270:	00bfff84 	movi	r2,-2
 321a274:	1884703a 	and	r2,r3,r2
 321a278:	1001703a 	wrctl	status,r2
  
  return context;
 321a27c:	e0bff417 	ldw	r2,-48(fp)
    OS_ENTER_CRITICAL();
 321a280:	e0bff815 	stw	r2,-32(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 321a284:	0080c974 	movhi	r2,805
 321a288:	10931504 	addi	r2,r2,19540
 321a28c:	10800017 	ldw	r2,0(r2)
 321a290:	10800c43 	ldbu	r2,49(r2)
 321a294:	10803fcc 	andi	r2,r2,255
 321a298:	e0bffe15 	stw	r2,-8(fp)
 321a29c:	e0fffe17 	ldw	r3,-8(fp)
 321a2a0:	1805003a 	cmpeq	r2,r3,zero
 321a2a4:	1000041e 	bne	r2,zero,321a2b8 <OSQPend+0x248>
 321a2a8:	e0fffe17 	ldw	r3,-8(fp)
 321a2ac:	188000a0 	cmpeqi	r2,r3,2
 321a2b0:	1000091e 	bne	r2,zero,321a2d8 <OSQPend+0x268>
 321a2b4:	00000d06 	br	321a2ec <OSQPend+0x27c>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
 321a2b8:	0080c974 	movhi	r2,805
 321a2bc:	10931504 	addi	r2,r2,19540
 321a2c0:	10800017 	ldw	r2,0(r2)
 321a2c4:	10800917 	ldw	r2,36(r2)
 321a2c8:	e0bffa15 	stw	r2,-24(fp)
            *perr =  OS_ERR_NONE;
 321a2cc:	e0bffd17 	ldw	r2,-12(fp)
 321a2d0:	10000005 	stb	zero,0(r2)
             break;
 321a2d4:	00000e06 	br	321a310 <OSQPend+0x2a0>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
 321a2d8:	e03ffa15 	stw	zero,-24(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 321a2dc:	e0fffd17 	ldw	r3,-12(fp)
 321a2e0:	00800384 	movi	r2,14
 321a2e4:	18800005 	stb	r2,0(r3)
             break;
 321a2e8:	00000906 	br	321a310 <OSQPend+0x2a0>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
 321a2ec:	0080c974 	movhi	r2,805
 321a2f0:	10931504 	addi	r2,r2,19540
 321a2f4:	11000017 	ldw	r4,0(r2)
 321a2f8:	e17ffb17 	ldw	r5,-20(fp)
 321a2fc:	32169400 	call	3216940 <OS_EventTaskRemove>
             pmsg = (void *)0;
 321a300:	e03ffa15 	stw	zero,-24(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 321a304:	e0fffd17 	ldw	r3,-12(fp)
 321a308:	00800284 	movi	r2,10
 321a30c:	18800005 	stb	r2,0(r3)
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 321a310:	0080c974 	movhi	r2,805
 321a314:	10931504 	addi	r2,r2,19540
 321a318:	10800017 	ldw	r2,0(r2)
 321a31c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 321a320:	0080c974 	movhi	r2,805
 321a324:	10931504 	addi	r2,r2,19540
 321a328:	10800017 	ldw	r2,0(r2)
 321a32c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 321a330:	0080c974 	movhi	r2,805
 321a334:	10931504 	addi	r2,r2,19540
 321a338:	10800017 	ldw	r2,0(r2)
 321a33c:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 321a340:	0080c974 	movhi	r2,805
 321a344:	10931504 	addi	r2,r2,19540
 321a348:	10800017 	ldw	r2,0(r2)
 321a34c:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
 321a350:	0080c974 	movhi	r2,805
 321a354:	10931504 	addi	r2,r2,19540
 321a358:	10800017 	ldw	r2,0(r2)
 321a35c:	10000915 	stw	zero,36(r2)
 321a360:	e0bff817 	ldw	r2,-32(fp)
 321a364:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321a368:	e0bff317 	ldw	r2,-52(fp)
 321a36c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
 321a370:	e0bffa17 	ldw	r2,-24(fp)
 321a374:	e0bfff15 	stw	r2,-4(fp)
 321a378:	e0bfff17 	ldw	r2,-4(fp)
}
 321a37c:	e037883a 	mov	sp,fp
 321a380:	dfc00117 	ldw	ra,4(sp)
 321a384:	df000017 	ldw	fp,0(sp)
 321a388:	dec00204 	addi	sp,sp,8
 321a38c:	f800283a 	ret

0321a390 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 321a390:	defff504 	addi	sp,sp,-44
 321a394:	dfc00a15 	stw	ra,40(sp)
 321a398:	df000915 	stw	fp,36(sp)
 321a39c:	df000904 	addi	fp,sp,36
 321a3a0:	e13ffc15 	stw	r4,-16(fp)
 321a3a4:	e1bffe15 	stw	r6,-8(fp)
 321a3a8:	e17ffd05 	stb	r5,-12(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 321a3ac:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 321a3b0:	e0bffe17 	ldw	r2,-8(fp)
 321a3b4:	1004c03a 	cmpne	r2,r2,zero
 321a3b8:	1000021e 	bne	r2,zero,321a3c4 <OSQPendAbort+0x34>
        return (0);
 321a3bc:	e03fff15 	stw	zero,-4(fp)
 321a3c0:	00004c06 	br	321a4f4 <OSQPendAbort+0x164>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 321a3c4:	e0bffc17 	ldw	r2,-16(fp)
 321a3c8:	1004c03a 	cmpne	r2,r2,zero
 321a3cc:	1000051e 	bne	r2,zero,321a3e4 <OSQPendAbort+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 321a3d0:	e0fffe17 	ldw	r3,-8(fp)
 321a3d4:	00800104 	movi	r2,4
 321a3d8:	18800005 	stb	r2,0(r3)
        return (0);
 321a3dc:	e03fff15 	stw	zero,-4(fp)
 321a3e0:	00004406 	br	321a4f4 <OSQPendAbort+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 321a3e4:	e0bffc17 	ldw	r2,-16(fp)
 321a3e8:	10800003 	ldbu	r2,0(r2)
 321a3ec:	10803fcc 	andi	r2,r2,255
 321a3f0:	108000a0 	cmpeqi	r2,r2,2
 321a3f4:	1000051e 	bne	r2,zero,321a40c <OSQPendAbort+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 321a3f8:	e0fffe17 	ldw	r3,-8(fp)
 321a3fc:	00800044 	movi	r2,1
 321a400:	18800005 	stb	r2,0(r3)
        return (0);
 321a404:	e03fff15 	stw	zero,-4(fp)
 321a408:	00003a06 	br	321a4f4 <OSQPendAbort+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321a40c:	0005303a 	rdctl	r2,status
 321a410:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321a414:	e0fff917 	ldw	r3,-28(fp)
 321a418:	00bfff84 	movi	r2,-2
 321a41c:	1884703a 	and	r2,r3,r2
 321a420:	1001703a 	wrctl	status,r2
  
  return context;
 321a424:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 321a428:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
 321a42c:	e0bffc17 	ldw	r2,-16(fp)
 321a430:	10800283 	ldbu	r2,10(r2)
 321a434:	10803fcc 	andi	r2,r2,255
 321a438:	1005003a 	cmpeq	r2,r2,zero
 321a43c:	1000261e 	bne	r2,zero,321a4d8 <OSQPendAbort+0x148>
        nbr_tasks = 0;
 321a440:	e03ffb05 	stb	zero,-20(fp)
        switch (opt) {
 321a444:	e0bffd03 	ldbu	r2,-12(fp)
 321a448:	10800060 	cmpeqi	r2,r2,1
 321a44c:	1000091e 	bne	r2,zero,321a474 <OSQPendAbort+0xe4>
 321a450:	00000e06 	br	321a48c <OSQPendAbort+0xfc>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 321a454:	e13ffc17 	ldw	r4,-16(fp)
 321a458:	000b883a 	mov	r5,zero
 321a45c:	01800104 	movi	r6,4
 321a460:	01c00084 	movi	r7,2
 321a464:	32165480 	call	3216548 <OS_EventTaskRdy>
                     nbr_tasks++;
 321a468:	e0bffb03 	ldbu	r2,-20(fp)
 321a46c:	10800044 	addi	r2,r2,1
 321a470:	e0bffb05 	stb	r2,-20(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 321a474:	e0bffc17 	ldw	r2,-16(fp)
 321a478:	10800283 	ldbu	r2,10(r2)
 321a47c:	10803fcc 	andi	r2,r2,255
 321a480:	1004c03a 	cmpne	r2,r2,zero
 321a484:	103ff31e 	bne	r2,zero,321a454 <OSQPendAbort+0xc4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 321a488:	00000806 	br	321a4ac <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 321a48c:	e13ffc17 	ldw	r4,-16(fp)
 321a490:	000b883a 	mov	r5,zero
 321a494:	01800104 	movi	r6,4
 321a498:	01c00084 	movi	r7,2
 321a49c:	32165480 	call	3216548 <OS_EventTaskRdy>
                 nbr_tasks++;
 321a4a0:	e0bffb03 	ldbu	r2,-20(fp)
 321a4a4:	10800044 	addi	r2,r2,1
 321a4a8:	e0bffb05 	stb	r2,-20(fp)
 321a4ac:	e0bffa17 	ldw	r2,-24(fp)
 321a4b0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321a4b4:	e0bff817 	ldw	r2,-32(fp)
 321a4b8:	1001703a 	wrctl	status,r2
                 break;
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
 321a4bc:	3216f880 	call	3216f88 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 321a4c0:	e0fffe17 	ldw	r3,-8(fp)
 321a4c4:	00800384 	movi	r2,14
 321a4c8:	18800005 	stb	r2,0(r3)
        return (nbr_tasks);
 321a4cc:	e0bffb03 	ldbu	r2,-20(fp)
 321a4d0:	e0bfff15 	stw	r2,-4(fp)
 321a4d4:	00000706 	br	321a4f4 <OSQPendAbort+0x164>
 321a4d8:	e0bffa17 	ldw	r2,-24(fp)
 321a4dc:	e0bff715 	stw	r2,-36(fp)
 321a4e0:	e0bff717 	ldw	r2,-36(fp)
 321a4e4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 321a4e8:	e0bffe17 	ldw	r2,-8(fp)
 321a4ec:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
 321a4f0:	e03fff15 	stw	zero,-4(fp)
 321a4f4:	e0bfff17 	ldw	r2,-4(fp)
}
 321a4f8:	e037883a 	mov	sp,fp
 321a4fc:	dfc00117 	ldw	ra,4(sp)
 321a500:	df000017 	ldw	fp,0(sp)
 321a504:	dec00204 	addi	sp,sp,8
 321a508:	f800283a 	ret

0321a50c <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
 321a50c:	defff504 	addi	sp,sp,-44
 321a510:	dfc00a15 	stw	ra,40(sp)
 321a514:	df000915 	stw	fp,36(sp)
 321a518:	df000904 	addi	fp,sp,36
 321a51c:	e13ffd15 	stw	r4,-12(fp)
 321a520:	e17ffe15 	stw	r5,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 321a524:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 321a528:	e0bffd17 	ldw	r2,-12(fp)
 321a52c:	1004c03a 	cmpne	r2,r2,zero
 321a530:	1000031e 	bne	r2,zero,321a540 <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
 321a534:	00800104 	movi	r2,4
 321a538:	e0bfff15 	stw	r2,-4(fp)
 321a53c:	00004d06 	br	321a674 <OSQPost+0x168>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 321a540:	e0bffd17 	ldw	r2,-12(fp)
 321a544:	10800003 	ldbu	r2,0(r2)
 321a548:	10803fcc 	andi	r2,r2,255
 321a54c:	108000a0 	cmpeqi	r2,r2,2
 321a550:	1000031e 	bne	r2,zero,321a560 <OSQPost+0x54>
        return (OS_ERR_EVENT_TYPE);
 321a554:	00800044 	movi	r2,1
 321a558:	e0bfff15 	stw	r2,-4(fp)
 321a55c:	00004506 	br	321a674 <OSQPost+0x168>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321a560:	0005303a 	rdctl	r2,status
 321a564:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321a568:	e0fffa17 	ldw	r3,-24(fp)
 321a56c:	00bfff84 	movi	r2,-2
 321a570:	1884703a 	and	r2,r3,r2
 321a574:	1001703a 	wrctl	status,r2
  
  return context;
 321a578:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 321a57c:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
 321a580:	e0bffd17 	ldw	r2,-12(fp)
 321a584:	10800283 	ldbu	r2,10(r2)
 321a588:	10803fcc 	andi	r2,r2,255
 321a58c:	1005003a 	cmpeq	r2,r2,zero
 321a590:	10000c1e 	bne	r2,zero,321a5c4 <OSQPost+0xb8>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 321a594:	e13ffd17 	ldw	r4,-12(fp)
 321a598:	e17ffe17 	ldw	r5,-8(fp)
 321a59c:	01800104 	movi	r6,4
 321a5a0:	000f883a 	mov	r7,zero
 321a5a4:	32165480 	call	3216548 <OS_EventTaskRdy>
 321a5a8:	e0bffb17 	ldw	r2,-20(fp)
 321a5ac:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321a5b0:	e0bff917 	ldw	r2,-28(fp)
 321a5b4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
 321a5b8:	3216f880 	call	3216f88 <OS_Sched>
        return (OS_ERR_NONE);
 321a5bc:	e03fff15 	stw	zero,-4(fp)
 321a5c0:	00002c06 	br	321a674 <OSQPost+0x168>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
 321a5c4:	e0bffd17 	ldw	r2,-12(fp)
 321a5c8:	10800117 	ldw	r2,4(r2)
 321a5cc:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
 321a5d0:	e0bffc17 	ldw	r2,-16(fp)
 321a5d4:	10c0058b 	ldhu	r3,22(r2)
 321a5d8:	e0bffc17 	ldw	r2,-16(fp)
 321a5dc:	1080050b 	ldhu	r2,20(r2)
 321a5e0:	18ffffcc 	andi	r3,r3,65535
 321a5e4:	10bfffcc 	andi	r2,r2,65535
 321a5e8:	18800736 	bltu	r3,r2,321a608 <OSQPost+0xfc>
 321a5ec:	e0bffb17 	ldw	r2,-20(fp)
 321a5f0:	e0bff815 	stw	r2,-32(fp)
 321a5f4:	e0bff817 	ldw	r2,-32(fp)
 321a5f8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 321a5fc:	00800784 	movi	r2,30
 321a600:	e0bfff15 	stw	r2,-4(fp)
 321a604:	00001b06 	br	321a674 <OSQPost+0x168>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
 321a608:	e0bffc17 	ldw	r2,-16(fp)
 321a60c:	10c00317 	ldw	r3,12(r2)
 321a610:	e0bffe17 	ldw	r2,-8(fp)
 321a614:	18800015 	stw	r2,0(r3)
 321a618:	18c00104 	addi	r3,r3,4
 321a61c:	e0bffc17 	ldw	r2,-16(fp)
 321a620:	10c00315 	stw	r3,12(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
 321a624:	e0bffc17 	ldw	r2,-16(fp)
 321a628:	1080058b 	ldhu	r2,22(r2)
 321a62c:	10800044 	addi	r2,r2,1
 321a630:	1007883a 	mov	r3,r2
 321a634:	e0bffc17 	ldw	r2,-16(fp)
 321a638:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
 321a63c:	e0bffc17 	ldw	r2,-16(fp)
 321a640:	10c00317 	ldw	r3,12(r2)
 321a644:	e0bffc17 	ldw	r2,-16(fp)
 321a648:	10800217 	ldw	r2,8(r2)
 321a64c:	1880041e 	bne	r3,r2,321a660 <OSQPost+0x154>
        pq->OSQIn = pq->OSQStart;
 321a650:	e0bffc17 	ldw	r2,-16(fp)
 321a654:	10c00117 	ldw	r3,4(r2)
 321a658:	e0bffc17 	ldw	r2,-16(fp)
 321a65c:	10c00315 	stw	r3,12(r2)
 321a660:	e0bffb17 	ldw	r2,-20(fp)
 321a664:	e0bff715 	stw	r2,-36(fp)
 321a668:	e0bff717 	ldw	r2,-36(fp)
 321a66c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 321a670:	e03fff15 	stw	zero,-4(fp)
 321a674:	e0bfff17 	ldw	r2,-4(fp)
}
 321a678:	e037883a 	mov	sp,fp
 321a67c:	dfc00117 	ldw	ra,4(sp)
 321a680:	df000017 	ldw	fp,0(sp)
 321a684:	dec00204 	addi	sp,sp,8
 321a688:	f800283a 	ret

0321a68c <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
 321a68c:	defff504 	addi	sp,sp,-44
 321a690:	dfc00a15 	stw	ra,40(sp)
 321a694:	df000915 	stw	fp,36(sp)
 321a698:	df000904 	addi	fp,sp,36
 321a69c:	e13ffd15 	stw	r4,-12(fp)
 321a6a0:	e17ffe15 	stw	r5,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 321a6a4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 321a6a8:	e0bffd17 	ldw	r2,-12(fp)
 321a6ac:	1004c03a 	cmpne	r2,r2,zero
 321a6b0:	1000031e 	bne	r2,zero,321a6c0 <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
 321a6b4:	00800104 	movi	r2,4
 321a6b8:	e0bfff15 	stw	r2,-4(fp)
 321a6bc:	00004f06 	br	321a7fc <OSQPostFront+0x170>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 321a6c0:	e0bffd17 	ldw	r2,-12(fp)
 321a6c4:	10800003 	ldbu	r2,0(r2)
 321a6c8:	10803fcc 	andi	r2,r2,255
 321a6cc:	108000a0 	cmpeqi	r2,r2,2
 321a6d0:	1000031e 	bne	r2,zero,321a6e0 <OSQPostFront+0x54>
        return (OS_ERR_EVENT_TYPE);
 321a6d4:	00800044 	movi	r2,1
 321a6d8:	e0bfff15 	stw	r2,-4(fp)
 321a6dc:	00004706 	br	321a7fc <OSQPostFront+0x170>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321a6e0:	0005303a 	rdctl	r2,status
 321a6e4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321a6e8:	e0fffa17 	ldw	r3,-24(fp)
 321a6ec:	00bfff84 	movi	r2,-2
 321a6f0:	1884703a 	and	r2,r3,r2
 321a6f4:	1001703a 	wrctl	status,r2
  
  return context;
 321a6f8:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 321a6fc:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
 321a700:	e0bffd17 	ldw	r2,-12(fp)
 321a704:	10800283 	ldbu	r2,10(r2)
 321a708:	10803fcc 	andi	r2,r2,255
 321a70c:	1005003a 	cmpeq	r2,r2,zero
 321a710:	10000c1e 	bne	r2,zero,321a744 <OSQPostFront+0xb8>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 321a714:	e13ffd17 	ldw	r4,-12(fp)
 321a718:	e17ffe17 	ldw	r5,-8(fp)
 321a71c:	01800104 	movi	r6,4
 321a720:	000f883a 	mov	r7,zero
 321a724:	32165480 	call	3216548 <OS_EventTaskRdy>
 321a728:	e0bffb17 	ldw	r2,-20(fp)
 321a72c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321a730:	e0bff917 	ldw	r2,-28(fp)
 321a734:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
 321a738:	3216f880 	call	3216f88 <OS_Sched>
        return (OS_ERR_NONE);
 321a73c:	e03fff15 	stw	zero,-4(fp)
 321a740:	00002e06 	br	321a7fc <OSQPostFront+0x170>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 321a744:	e0bffd17 	ldw	r2,-12(fp)
 321a748:	10800117 	ldw	r2,4(r2)
 321a74c:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 321a750:	e0bffc17 	ldw	r2,-16(fp)
 321a754:	10c0058b 	ldhu	r3,22(r2)
 321a758:	e0bffc17 	ldw	r2,-16(fp)
 321a75c:	1080050b 	ldhu	r2,20(r2)
 321a760:	18ffffcc 	andi	r3,r3,65535
 321a764:	10bfffcc 	andi	r2,r2,65535
 321a768:	18800736 	bltu	r3,r2,321a788 <OSQPostFront+0xfc>
 321a76c:	e0bffb17 	ldw	r2,-20(fp)
 321a770:	e0bff815 	stw	r2,-32(fp)
 321a774:	e0bff817 	ldw	r2,-32(fp)
 321a778:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 321a77c:	00800784 	movi	r2,30
 321a780:	e0bfff15 	stw	r2,-4(fp)
 321a784:	00001d06 	br	321a7fc <OSQPostFront+0x170>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
 321a788:	e0bffc17 	ldw	r2,-16(fp)
 321a78c:	10c00417 	ldw	r3,16(r2)
 321a790:	e0bffc17 	ldw	r2,-16(fp)
 321a794:	10800117 	ldw	r2,4(r2)
 321a798:	1880041e 	bne	r3,r2,321a7ac <OSQPostFront+0x120>
        pq->OSQOut = pq->OSQEnd;
 321a79c:	e0bffc17 	ldw	r2,-16(fp)
 321a7a0:	10c00217 	ldw	r3,8(r2)
 321a7a4:	e0bffc17 	ldw	r2,-16(fp)
 321a7a8:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
 321a7ac:	e0bffc17 	ldw	r2,-16(fp)
 321a7b0:	10800417 	ldw	r2,16(r2)
 321a7b4:	10ffff04 	addi	r3,r2,-4
 321a7b8:	e0bffc17 	ldw	r2,-16(fp)
 321a7bc:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
 321a7c0:	e0bffc17 	ldw	r2,-16(fp)
 321a7c4:	10c00417 	ldw	r3,16(r2)
 321a7c8:	e0bffe17 	ldw	r2,-8(fp)
 321a7cc:	18800015 	stw	r2,0(r3)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 321a7d0:	e0bffc17 	ldw	r2,-16(fp)
 321a7d4:	1080058b 	ldhu	r2,22(r2)
 321a7d8:	10800044 	addi	r2,r2,1
 321a7dc:	1007883a 	mov	r3,r2
 321a7e0:	e0bffc17 	ldw	r2,-16(fp)
 321a7e4:	10c0058d 	sth	r3,22(r2)
 321a7e8:	e0bffb17 	ldw	r2,-20(fp)
 321a7ec:	e0bff715 	stw	r2,-36(fp)
 321a7f0:	e0bff717 	ldw	r2,-36(fp)
 321a7f4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 321a7f8:	e03fff15 	stw	zero,-4(fp)
 321a7fc:	e0bfff17 	ldw	r2,-4(fp)
}
 321a800:	e037883a 	mov	sp,fp
 321a804:	dfc00117 	ldw	ra,4(sp)
 321a808:	df000017 	ldw	fp,0(sp)
 321a80c:	dec00204 	addi	sp,sp,8
 321a810:	f800283a 	ret

0321a814 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
 321a814:	defff404 	addi	sp,sp,-48
 321a818:	dfc00b15 	stw	ra,44(sp)
 321a81c:	df000a15 	stw	fp,40(sp)
 321a820:	df000a04 	addi	fp,sp,40
 321a824:	e13ffc15 	stw	r4,-16(fp)
 321a828:	e17ffd15 	stw	r5,-12(fp)
 321a82c:	e1bffe05 	stb	r6,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 321a830:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 321a834:	e0bffc17 	ldw	r2,-16(fp)
 321a838:	1004c03a 	cmpne	r2,r2,zero
 321a83c:	1000031e 	bne	r2,zero,321a84c <OSQPostOpt+0x38>
        return (OS_ERR_PEVENT_NULL);
 321a840:	00800104 	movi	r2,4
 321a844:	e0bfff15 	stw	r2,-4(fp)
 321a848:	00007906 	br	321aa30 <OSQPostOpt+0x21c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 321a84c:	e0bffc17 	ldw	r2,-16(fp)
 321a850:	10800003 	ldbu	r2,0(r2)
 321a854:	10803fcc 	andi	r2,r2,255
 321a858:	108000a0 	cmpeqi	r2,r2,2
 321a85c:	1000031e 	bne	r2,zero,321a86c <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
 321a860:	00800044 	movi	r2,1
 321a864:	e0bfff15 	stw	r2,-4(fp)
 321a868:	00007106 	br	321aa30 <OSQPostOpt+0x21c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321a86c:	0005303a 	rdctl	r2,status
 321a870:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321a874:	e0fff917 	ldw	r3,-28(fp)
 321a878:	00bfff84 	movi	r2,-2
 321a87c:	1884703a 	and	r2,r3,r2
 321a880:	1001703a 	wrctl	status,r2
  
  return context;
 321a884:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 321a888:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
 321a88c:	e0bffc17 	ldw	r2,-16(fp)
 321a890:	10800283 	ldbu	r2,10(r2)
 321a894:	10803fcc 	andi	r2,r2,255
 321a898:	1005003a 	cmpeq	r2,r2,zero
 321a89c:	1000211e 	bne	r2,zero,321a924 <OSQPostOpt+0x110>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
 321a8a0:	e0bffe03 	ldbu	r2,-8(fp)
 321a8a4:	1080004c 	andi	r2,r2,1
 321a8a8:	10803fcc 	andi	r2,r2,255
 321a8ac:	1005003a 	cmpeq	r2,r2,zero
 321a8b0:	10000c1e 	bne	r2,zero,321a8e4 <OSQPostOpt+0xd0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 321a8b4:	00000506 	br	321a8cc <OSQPostOpt+0xb8>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 321a8b8:	e13ffc17 	ldw	r4,-16(fp)
 321a8bc:	e17ffd17 	ldw	r5,-12(fp)
 321a8c0:	01800104 	movi	r6,4
 321a8c4:	000f883a 	mov	r7,zero
 321a8c8:	32165480 	call	3216548 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 321a8cc:	e0bffc17 	ldw	r2,-16(fp)
 321a8d0:	10800283 	ldbu	r2,10(r2)
 321a8d4:	10803fcc 	andi	r2,r2,255
 321a8d8:	1004c03a 	cmpne	r2,r2,zero
 321a8dc:	103ff61e 	bne	r2,zero,321a8b8 <OSQPostOpt+0xa4>
 321a8e0:	00000506 	br	321a8f8 <OSQPostOpt+0xe4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 321a8e4:	e13ffc17 	ldw	r4,-16(fp)
 321a8e8:	e17ffd17 	ldw	r5,-12(fp)
 321a8ec:	01800104 	movi	r6,4
 321a8f0:	000f883a 	mov	r7,zero
 321a8f4:	32165480 	call	3216548 <OS_EventTaskRdy>
 321a8f8:	e0bffa17 	ldw	r2,-24(fp)
 321a8fc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321a900:	e0bff817 	ldw	r2,-32(fp)
 321a904:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
 321a908:	e0bffe03 	ldbu	r2,-8(fp)
 321a90c:	1080010c 	andi	r2,r2,4
 321a910:	1004c03a 	cmpne	r2,r2,zero
 321a914:	1000011e 	bne	r2,zero,321a91c <OSQPostOpt+0x108>
            OS_Sched();                               /* Find highest priority task ready to run       */
 321a918:	3216f880 	call	3216f88 <OS_Sched>
        }
        return (OS_ERR_NONE);
 321a91c:	e03fff15 	stw	zero,-4(fp)
 321a920:	00004306 	br	321aa30 <OSQPostOpt+0x21c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 321a924:	e0bffc17 	ldw	r2,-16(fp)
 321a928:	10800117 	ldw	r2,4(r2)
 321a92c:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 321a930:	e0bffb17 	ldw	r2,-20(fp)
 321a934:	10c0058b 	ldhu	r3,22(r2)
 321a938:	e0bffb17 	ldw	r2,-20(fp)
 321a93c:	1080050b 	ldhu	r2,20(r2)
 321a940:	18ffffcc 	andi	r3,r3,65535
 321a944:	10bfffcc 	andi	r2,r2,65535
 321a948:	18800736 	bltu	r3,r2,321a968 <OSQPostOpt+0x154>
 321a94c:	e0bffa17 	ldw	r2,-24(fp)
 321a950:	e0bff715 	stw	r2,-36(fp)
 321a954:	e0bff717 	ldw	r2,-36(fp)
 321a958:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 321a95c:	00800784 	movi	r2,30
 321a960:	e0bfff15 	stw	r2,-4(fp)
 321a964:	00003206 	br	321aa30 <OSQPostOpt+0x21c>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
 321a968:	e0bffe03 	ldbu	r2,-8(fp)
 321a96c:	1080008c 	andi	r2,r2,2
 321a970:	1005003a 	cmpeq	r2,r2,zero
 321a974:	1000131e 	bne	r2,zero,321a9c4 <OSQPostOpt+0x1b0>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
 321a978:	e0bffb17 	ldw	r2,-20(fp)
 321a97c:	10c00417 	ldw	r3,16(r2)
 321a980:	e0bffb17 	ldw	r2,-20(fp)
 321a984:	10800117 	ldw	r2,4(r2)
 321a988:	1880041e 	bne	r3,r2,321a99c <OSQPostOpt+0x188>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
 321a98c:	e0bffb17 	ldw	r2,-20(fp)
 321a990:	10c00217 	ldw	r3,8(r2)
 321a994:	e0bffb17 	ldw	r2,-20(fp)
 321a998:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
 321a99c:	e0bffb17 	ldw	r2,-20(fp)
 321a9a0:	10800417 	ldw	r2,16(r2)
 321a9a4:	10ffff04 	addi	r3,r2,-4
 321a9a8:	e0bffb17 	ldw	r2,-20(fp)
 321a9ac:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
 321a9b0:	e0bffb17 	ldw	r2,-20(fp)
 321a9b4:	10c00417 	ldw	r3,16(r2)
 321a9b8:	e0bffd17 	ldw	r2,-12(fp)
 321a9bc:	18800015 	stw	r2,0(r3)
 321a9c0:	00001006 	br	321aa04 <OSQPostOpt+0x1f0>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
 321a9c4:	e0bffb17 	ldw	r2,-20(fp)
 321a9c8:	10c00317 	ldw	r3,12(r2)
 321a9cc:	e0bffd17 	ldw	r2,-12(fp)
 321a9d0:	18800015 	stw	r2,0(r3)
 321a9d4:	18c00104 	addi	r3,r3,4
 321a9d8:	e0bffb17 	ldw	r2,-20(fp)
 321a9dc:	10c00315 	stw	r3,12(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
 321a9e0:	e0bffb17 	ldw	r2,-20(fp)
 321a9e4:	10c00317 	ldw	r3,12(r2)
 321a9e8:	e0bffb17 	ldw	r2,-20(fp)
 321a9ec:	10800217 	ldw	r2,8(r2)
 321a9f0:	1880041e 	bne	r3,r2,321aa04 <OSQPostOpt+0x1f0>
            pq->OSQIn = pq->OSQStart;
 321a9f4:	e0bffb17 	ldw	r2,-20(fp)
 321a9f8:	10c00117 	ldw	r3,4(r2)
 321a9fc:	e0bffb17 	ldw	r2,-20(fp)
 321aa00:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 321aa04:	e0bffb17 	ldw	r2,-20(fp)
 321aa08:	1080058b 	ldhu	r2,22(r2)
 321aa0c:	10800044 	addi	r2,r2,1
 321aa10:	1007883a 	mov	r3,r2
 321aa14:	e0bffb17 	ldw	r2,-20(fp)
 321aa18:	10c0058d 	sth	r3,22(r2)
 321aa1c:	e0bffa17 	ldw	r2,-24(fp)
 321aa20:	e0bff615 	stw	r2,-40(fp)
 321aa24:	e0bff617 	ldw	r2,-40(fp)
 321aa28:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 321aa2c:	e03fff15 	stw	zero,-4(fp)
 321aa30:	e0bfff17 	ldw	r2,-4(fp)
}
 321aa34:	e037883a 	mov	sp,fp
 321aa38:	dfc00117 	ldw	ra,4(sp)
 321aa3c:	df000017 	ldw	fp,0(sp)
 321aa40:	dec00204 	addi	sp,sp,8
 321aa44:	f800283a 	ret

0321aa48 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
 321aa48:	defff504 	addi	sp,sp,-44
 321aa4c:	df000a15 	stw	fp,40(sp)
 321aa50:	df000a04 	addi	fp,sp,40
 321aa54:	e13ffd15 	stw	r4,-12(fp)
 321aa58:	e17ffe15 	stw	r5,-8(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 321aa5c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 321aa60:	e0bffd17 	ldw	r2,-12(fp)
 321aa64:	1004c03a 	cmpne	r2,r2,zero
 321aa68:	1000031e 	bne	r2,zero,321aa78 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
 321aa6c:	00800104 	movi	r2,4
 321aa70:	e0bfff15 	stw	r2,-4(fp)
 321aa74:	00004f06 	br	321abb4 <OSQQuery+0x16c>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
 321aa78:	e0bffe17 	ldw	r2,-8(fp)
 321aa7c:	1004c03a 	cmpne	r2,r2,zero
 321aa80:	1000031e 	bne	r2,zero,321aa90 <OSQQuery+0x48>
        return (OS_ERR_PDATA_NULL);
 321aa84:	00800244 	movi	r2,9
 321aa88:	e0bfff15 	stw	r2,-4(fp)
 321aa8c:	00004906 	br	321abb4 <OSQQuery+0x16c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 321aa90:	e0bffd17 	ldw	r2,-12(fp)
 321aa94:	10800003 	ldbu	r2,0(r2)
 321aa98:	10803fcc 	andi	r2,r2,255
 321aa9c:	108000a0 	cmpeqi	r2,r2,2
 321aaa0:	1000031e 	bne	r2,zero,321aab0 <OSQQuery+0x68>
        return (OS_ERR_EVENT_TYPE);
 321aaa4:	00800044 	movi	r2,1
 321aaa8:	e0bfff15 	stw	r2,-4(fp)
 321aaac:	00004106 	br	321abb4 <OSQQuery+0x16c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321aab0:	0005303a 	rdctl	r2,status
 321aab4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321aab8:	e0fff717 	ldw	r3,-36(fp)
 321aabc:	00bfff84 	movi	r2,-2
 321aac0:	1884703a 	and	r2,r3,r2
 321aac4:	1001703a 	wrctl	status,r2
  
  return context;
 321aac8:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 321aacc:	e0bff815 	stw	r2,-32(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
 321aad0:	e0bffd17 	ldw	r2,-12(fp)
 321aad4:	10c00283 	ldbu	r3,10(r2)
 321aad8:	e0bffe17 	ldw	r2,-8(fp)
 321aadc:	10c002c5 	stb	r3,11(r2)
    psrc                 = &pevent->OSEventTbl[0];
 321aae0:	e0bffd17 	ldw	r2,-12(fp)
 321aae4:	108002c4 	addi	r2,r2,11
 321aae8:	e0bffa15 	stw	r2,-24(fp)
    pdest                = &p_q_data->OSEventTbl[0];
 321aaec:	e0bffe17 	ldw	r2,-8(fp)
 321aaf0:	10800204 	addi	r2,r2,8
 321aaf4:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 321aaf8:	e03ffb05 	stb	zero,-20(fp)
 321aafc:	00000d06 	br	321ab34 <OSQQuery+0xec>
        *pdest++ = *psrc++;
 321ab00:	e0bffa17 	ldw	r2,-24(fp)
 321ab04:	10c00003 	ldbu	r3,0(r2)
 321ab08:	e0bff917 	ldw	r2,-28(fp)
 321ab0c:	10c00005 	stb	r3,0(r2)
 321ab10:	e0bff917 	ldw	r2,-28(fp)
 321ab14:	10800044 	addi	r2,r2,1
 321ab18:	e0bff915 	stw	r2,-28(fp)
 321ab1c:	e0bffa17 	ldw	r2,-24(fp)
 321ab20:	10800044 	addi	r2,r2,1
 321ab24:	e0bffa15 	stw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 321ab28:	e0bffb03 	ldbu	r2,-20(fp)
 321ab2c:	10800044 	addi	r2,r2,1
 321ab30:	e0bffb05 	stb	r2,-20(fp)
 321ab34:	e0bffb03 	ldbu	r2,-20(fp)
 321ab38:	108000f0 	cmpltui	r2,r2,3
 321ab3c:	103ff01e 	bne	r2,zero,321ab00 <OSQQuery+0xb8>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
 321ab40:	e0bffd17 	ldw	r2,-12(fp)
 321ab44:	10800117 	ldw	r2,4(r2)
 321ab48:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
 321ab4c:	e0bffc17 	ldw	r2,-16(fp)
 321ab50:	1080058b 	ldhu	r2,22(r2)
 321ab54:	10bfffcc 	andi	r2,r2,65535
 321ab58:	1005003a 	cmpeq	r2,r2,zero
 321ab5c:	1000061e 	bne	r2,zero,321ab78 <OSQQuery+0x130>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
 321ab60:	e0bffc17 	ldw	r2,-16(fp)
 321ab64:	10800417 	ldw	r2,16(r2)
 321ab68:	10c00017 	ldw	r3,0(r2)
 321ab6c:	e0bffe17 	ldw	r2,-8(fp)
 321ab70:	10c00015 	stw	r3,0(r2)
 321ab74:	00000206 	br	321ab80 <OSQQuery+0x138>
    } else {
        p_q_data->OSMsg = (void *)0;
 321ab78:	e0bffe17 	ldw	r2,-8(fp)
 321ab7c:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
 321ab80:	e0bffc17 	ldw	r2,-16(fp)
 321ab84:	10c0058b 	ldhu	r3,22(r2)
 321ab88:	e0bffe17 	ldw	r2,-8(fp)
 321ab8c:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
 321ab90:	e0bffc17 	ldw	r2,-16(fp)
 321ab94:	10c0050b 	ldhu	r3,20(r2)
 321ab98:	e0bffe17 	ldw	r2,-8(fp)
 321ab9c:	10c0018d 	sth	r3,6(r2)
 321aba0:	e0bff817 	ldw	r2,-32(fp)
 321aba4:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321aba8:	e0bff617 	ldw	r2,-40(fp)
 321abac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 321abb0:	e03fff15 	stw	zero,-4(fp)
 321abb4:	e0bfff17 	ldw	r2,-4(fp)
}
 321abb8:	e037883a 	mov	sp,fp
 321abbc:	df000017 	ldw	fp,0(sp)
 321abc0:	dec00104 	addi	sp,sp,4
 321abc4:	f800283a 	ret

0321abc8 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
 321abc8:	defffb04 	addi	sp,sp,-20
 321abcc:	dfc00415 	stw	ra,16(sp)
 321abd0:	df000315 	stw	fp,12(sp)
 321abd4:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
 321abd8:	0100c9b4 	movhi	r4,806
 321abdc:	212bdf04 	addi	r4,r4,-20612
 321abe0:	01407804 	movi	r5,480
 321abe4:	3216ec80 	call	3216ec8 <OS_MemClr>
    pq1 = &OSQTbl[0];
 321abe8:	0080c9b4 	movhi	r2,806
 321abec:	10abdf04 	addi	r2,r2,-20612
 321abf0:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
 321abf4:	0080c9b4 	movhi	r2,806
 321abf8:	10abe504 	addi	r2,r2,-20588
 321abfc:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 321ac00:	e03fff0d 	sth	zero,-4(fp)
 321ac04:	00000c06 	br	321ac38 <OS_QInit+0x70>
        pq1->OSQPtr = pq2;
 321ac08:	e0fffe17 	ldw	r3,-8(fp)
 321ac0c:	e0bffd17 	ldw	r2,-12(fp)
 321ac10:	18800015 	stw	r2,0(r3)
        pq1++;
 321ac14:	e0bffe17 	ldw	r2,-8(fp)
 321ac18:	10800604 	addi	r2,r2,24
 321ac1c:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
 321ac20:	e0bffd17 	ldw	r2,-12(fp)
 321ac24:	10800604 	addi	r2,r2,24
 321ac28:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 321ac2c:	e0bfff0b 	ldhu	r2,-4(fp)
 321ac30:	10800044 	addi	r2,r2,1
 321ac34:	e0bfff0d 	sth	r2,-4(fp)
 321ac38:	e0bfff0b 	ldhu	r2,-4(fp)
 321ac3c:	108004f0 	cmpltui	r2,r2,19
 321ac40:	103ff11e 	bne	r2,zero,321ac08 <OS_QInit+0x40>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
 321ac44:	e0bffe17 	ldw	r2,-8(fp)
 321ac48:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
 321ac4c:	00c0c974 	movhi	r3,805
 321ac50:	18d31104 	addi	r3,r3,19524
 321ac54:	0080c9b4 	movhi	r2,806
 321ac58:	10abdf04 	addi	r2,r2,-20612
 321ac5c:	18800015 	stw	r2,0(r3)
#endif
}
 321ac60:	e037883a 	mov	sp,fp
 321ac64:	dfc00117 	ldw	ra,4(sp)
 321ac68:	df000017 	ldw	fp,0(sp)
 321ac6c:	dec00204 	addi	sp,sp,8
 321ac70:	f800283a 	ret

0321ac74 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
 321ac74:	defff904 	addi	sp,sp,-28
 321ac78:	df000615 	stw	fp,24(sp)
 321ac7c:	df000604 	addi	fp,sp,24
 321ac80:	e13ffe15 	stw	r4,-8(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 321ac84:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 321ac88:	e0bffe17 	ldw	r2,-8(fp)
 321ac8c:	1004c03a 	cmpne	r2,r2,zero
 321ac90:	1000021e 	bne	r2,zero,321ac9c <OSSemAccept+0x28>
        return (0);
 321ac94:	e03fff15 	stw	zero,-4(fp)
 321ac98:	00002106 	br	321ad20 <OSSemAccept+0xac>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 321ac9c:	e0bffe17 	ldw	r2,-8(fp)
 321aca0:	10800003 	ldbu	r2,0(r2)
 321aca4:	10803fcc 	andi	r2,r2,255
 321aca8:	108000e0 	cmpeqi	r2,r2,3
 321acac:	1000021e 	bne	r2,zero,321acb8 <OSSemAccept+0x44>
        return (0);
 321acb0:	e03fff15 	stw	zero,-4(fp)
 321acb4:	00001a06 	br	321ad20 <OSSemAccept+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321acb8:	0005303a 	rdctl	r2,status
 321acbc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321acc0:	e0fffb17 	ldw	r3,-20(fp)
 321acc4:	00bfff84 	movi	r2,-2
 321acc8:	1884703a 	and	r2,r3,r2
 321accc:	1001703a 	wrctl	status,r2
  
  return context;
 321acd0:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 321acd4:	e0bffc15 	stw	r2,-16(fp)
    cnt = pevent->OSEventCnt;
 321acd8:	e0bffe17 	ldw	r2,-8(fp)
 321acdc:	1080020b 	ldhu	r2,8(r2)
 321ace0:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
 321ace4:	e0bffd0b 	ldhu	r2,-12(fp)
 321ace8:	1005003a 	cmpeq	r2,r2,zero
 321acec:	1000061e 	bne	r2,zero,321ad08 <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
 321acf0:	e0bffe17 	ldw	r2,-8(fp)
 321acf4:	1080020b 	ldhu	r2,8(r2)
 321acf8:	10bfffc4 	addi	r2,r2,-1
 321acfc:	1007883a 	mov	r3,r2
 321ad00:	e0bffe17 	ldw	r2,-8(fp)
 321ad04:	10c0020d 	sth	r3,8(r2)
 321ad08:	e0bffc17 	ldw	r2,-16(fp)
 321ad0c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321ad10:	e0bffa17 	ldw	r2,-24(fp)
 321ad14:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
 321ad18:	e0bffd0b 	ldhu	r2,-12(fp)
 321ad1c:	e0bfff15 	stw	r2,-4(fp)
 321ad20:	e0bfff17 	ldw	r2,-4(fp)
}
 321ad24:	e037883a 	mov	sp,fp
 321ad28:	df000017 	ldw	fp,0(sp)
 321ad2c:	dec00104 	addi	sp,sp,4
 321ad30:	f800283a 	ret

0321ad34 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
 321ad34:	defff804 	addi	sp,sp,-32
 321ad38:	dfc00715 	stw	ra,28(sp)
 321ad3c:	df000615 	stw	fp,24(sp)
 321ad40:	df000604 	addi	fp,sp,24
 321ad44:	e13ffe0d 	sth	r4,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 321ad48:	e03ffc15 	stw	zero,-16(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 321ad4c:	0080c974 	movhi	r2,805
 321ad50:	10931404 	addi	r2,r2,19536
 321ad54:	10800003 	ldbu	r2,0(r2)
 321ad58:	10803fcc 	andi	r2,r2,255
 321ad5c:	1005003a 	cmpeq	r2,r2,zero
 321ad60:	1000021e 	bne	r2,zero,321ad6c <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
 321ad64:	e03fff15 	stw	zero,-4(fp)
 321ad68:	00003106 	br	321ae30 <OSSemCreate+0xfc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321ad6c:	0005303a 	rdctl	r2,status
 321ad70:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321ad74:	e0fffb17 	ldw	r3,-20(fp)
 321ad78:	00bfff84 	movi	r2,-2
 321ad7c:	1884703a 	and	r2,r3,r2
 321ad80:	1001703a 	wrctl	status,r2
  
  return context;
 321ad84:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 321ad88:	e0bffc15 	stw	r2,-16(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
 321ad8c:	0080c974 	movhi	r2,805
 321ad90:	10931304 	addi	r2,r2,19532
 321ad94:	10800017 	ldw	r2,0(r2)
 321ad98:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
 321ad9c:	0080c974 	movhi	r2,805
 321ada0:	10931304 	addi	r2,r2,19532
 321ada4:	10800017 	ldw	r2,0(r2)
 321ada8:	1005003a 	cmpeq	r2,r2,zero
 321adac:	1000081e 	bne	r2,zero,321add0 <OSSemCreate+0x9c>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 321adb0:	0080c974 	movhi	r2,805
 321adb4:	10931304 	addi	r2,r2,19532
 321adb8:	10800017 	ldw	r2,0(r2)
 321adbc:	10800117 	ldw	r2,4(r2)
 321adc0:	1007883a 	mov	r3,r2
 321adc4:	0080c974 	movhi	r2,805
 321adc8:	10931304 	addi	r2,r2,19532
 321adcc:	10c00015 	stw	r3,0(r2)
 321add0:	e0bffc17 	ldw	r2,-16(fp)
 321add4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321add8:	e0bffa17 	ldw	r2,-24(fp)
 321addc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
 321ade0:	e0bffd17 	ldw	r2,-12(fp)
 321ade4:	1005003a 	cmpeq	r2,r2,zero
 321ade8:	10000f1e 	bne	r2,zero,321ae28 <OSSemCreate+0xf4>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
 321adec:	e0fffd17 	ldw	r3,-12(fp)
 321adf0:	008000c4 	movi	r2,3
 321adf4:	18800005 	stb	r2,0(r3)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
 321adf8:	e0fffd17 	ldw	r3,-12(fp)
 321adfc:	e0bffe0b 	ldhu	r2,-8(fp)
 321ae00:	1880020d 	sth	r2,8(r3)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
 321ae04:	e0bffd17 	ldw	r2,-12(fp)
 321ae08:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
 321ae0c:	e0fffd17 	ldw	r3,-12(fp)
 321ae10:	00800fc4 	movi	r2,63
 321ae14:	18800385 	stb	r2,14(r3)
        pevent->OSEventName[1] = OS_ASCII_NUL;
 321ae18:	e0bffd17 	ldw	r2,-12(fp)
 321ae1c:	100003c5 	stb	zero,15(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
 321ae20:	e13ffd17 	ldw	r4,-12(fp)
 321ae24:	3216afc0 	call	3216afc <OS_EventWaitListInit>
    }
    return (pevent);
 321ae28:	e0bffd17 	ldw	r2,-12(fp)
 321ae2c:	e0bfff15 	stw	r2,-4(fp)
 321ae30:	e0bfff17 	ldw	r2,-4(fp)
}
 321ae34:	e037883a 	mov	sp,fp
 321ae38:	dfc00117 	ldw	ra,4(sp)
 321ae3c:	df000017 	ldw	fp,0(sp)
 321ae40:	dec00204 	addi	sp,sp,8
 321ae44:	f800283a 	ret

0321ae48 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 321ae48:	defff104 	addi	sp,sp,-60
 321ae4c:	dfc00e15 	stw	ra,56(sp)
 321ae50:	df000d15 	stw	fp,52(sp)
 321ae54:	df000d04 	addi	fp,sp,52
 321ae58:	e13ffb15 	stw	r4,-20(fp)
 321ae5c:	e1bffd15 	stw	r6,-12(fp)
 321ae60:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 321ae64:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 321ae68:	e0bffd17 	ldw	r2,-12(fp)
 321ae6c:	1004c03a 	cmpne	r2,r2,zero
 321ae70:	1000031e 	bne	r2,zero,321ae80 <OSSemDel+0x38>
        return (pevent);
 321ae74:	e0bffb17 	ldw	r2,-20(fp)
 321ae78:	e0bfff15 	stw	r2,-4(fp)
 321ae7c:	00009406 	br	321b0d0 <OSSemDel+0x288>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 321ae80:	e0bffb17 	ldw	r2,-20(fp)
 321ae84:	1004c03a 	cmpne	r2,r2,zero
 321ae88:	1000061e 	bne	r2,zero,321aea4 <OSSemDel+0x5c>
        *perr = OS_ERR_PEVENT_NULL;
 321ae8c:	e0fffd17 	ldw	r3,-12(fp)
 321ae90:	00800104 	movi	r2,4
 321ae94:	18800005 	stb	r2,0(r3)
        return (pevent);
 321ae98:	e0fffb17 	ldw	r3,-20(fp)
 321ae9c:	e0ffff15 	stw	r3,-4(fp)
 321aea0:	00008b06 	br	321b0d0 <OSSemDel+0x288>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 321aea4:	e0bffb17 	ldw	r2,-20(fp)
 321aea8:	10800003 	ldbu	r2,0(r2)
 321aeac:	10803fcc 	andi	r2,r2,255
 321aeb0:	108000e0 	cmpeqi	r2,r2,3
 321aeb4:	1000061e 	bne	r2,zero,321aed0 <OSSemDel+0x88>
        *perr = OS_ERR_EVENT_TYPE;
 321aeb8:	e0fffd17 	ldw	r3,-12(fp)
 321aebc:	00800044 	movi	r2,1
 321aec0:	18800005 	stb	r2,0(r3)
        return (pevent);
 321aec4:	e0bffb17 	ldw	r2,-20(fp)
 321aec8:	e0bfff15 	stw	r2,-4(fp)
 321aecc:	00008006 	br	321b0d0 <OSSemDel+0x288>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 321aed0:	0080c974 	movhi	r2,805
 321aed4:	10931404 	addi	r2,r2,19536
 321aed8:	10800003 	ldbu	r2,0(r2)
 321aedc:	10803fcc 	andi	r2,r2,255
 321aee0:	1005003a 	cmpeq	r2,r2,zero
 321aee4:	1000061e 	bne	r2,zero,321af00 <OSSemDel+0xb8>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 321aee8:	e0fffd17 	ldw	r3,-12(fp)
 321aeec:	008003c4 	movi	r2,15
 321aef0:	18800005 	stb	r2,0(r3)
        return (pevent);
 321aef4:	e0fffb17 	ldw	r3,-20(fp)
 321aef8:	e0ffff15 	stw	r3,-4(fp)
 321aefc:	00007406 	br	321b0d0 <OSSemDel+0x288>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321af00:	0005303a 	rdctl	r2,status
 321af04:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321af08:	e0fff717 	ldw	r3,-36(fp)
 321af0c:	00bfff84 	movi	r2,-2
 321af10:	1884703a 	and	r2,r3,r2
 321af14:	1001703a 	wrctl	status,r2
  
  return context;
 321af18:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 321af1c:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
 321af20:	e0bffb17 	ldw	r2,-20(fp)
 321af24:	10800283 	ldbu	r2,10(r2)
 321af28:	10803fcc 	andi	r2,r2,255
 321af2c:	1005003a 	cmpeq	r2,r2,zero
 321af30:	1000031e 	bne	r2,zero,321af40 <OSSemDel+0xf8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 321af34:	00800044 	movi	r2,1
 321af38:	e0bffa05 	stb	r2,-24(fp)
 321af3c:	00000106 	br	321af44 <OSSemDel+0xfc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 321af40:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 321af44:	e0bffc03 	ldbu	r2,-16(fp)
 321af48:	e0bffe15 	stw	r2,-8(fp)
 321af4c:	e0fffe17 	ldw	r3,-8(fp)
 321af50:	1805003a 	cmpeq	r2,r3,zero
 321af54:	1000041e 	bne	r2,zero,321af68 <OSSemDel+0x120>
 321af58:	e0fffe17 	ldw	r3,-8(fp)
 321af5c:	18800060 	cmpeqi	r2,r3,1
 321af60:	10002d1e 	bne	r2,zero,321b018 <OSSemDel+0x1d0>
 321af64:	00004f06 	br	321b0a4 <OSSemDel+0x25c>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
 321af68:	e0bffa03 	ldbu	r2,-24(fp)
 321af6c:	1004c03a 	cmpne	r2,r2,zero
 321af70:	10001a1e 	bne	r2,zero,321afdc <OSSemDel+0x194>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 321af74:	e0fffb17 	ldw	r3,-20(fp)
 321af78:	00800fc4 	movi	r2,63
 321af7c:	18800385 	stb	r2,14(r3)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 321af80:	e0bffb17 	ldw	r2,-20(fp)
 321af84:	100003c5 	stb	zero,15(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 321af88:	e0bffb17 	ldw	r2,-20(fp)
 321af8c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 321af90:	0080c974 	movhi	r2,805
 321af94:	10931304 	addi	r2,r2,19532
 321af98:	10c00017 	ldw	r3,0(r2)
 321af9c:	e0bffb17 	ldw	r2,-20(fp)
 321afa0:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 321afa4:	e0bffb17 	ldw	r2,-20(fp)
 321afa8:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 321afac:	00c0c974 	movhi	r3,805
 321afb0:	18d31304 	addi	r3,r3,19532
 321afb4:	e0bffb17 	ldw	r2,-20(fp)
 321afb8:	18800015 	stw	r2,0(r3)
 321afbc:	e0bff817 	ldw	r2,-32(fp)
 321afc0:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321afc4:	e0bff617 	ldw	r2,-40(fp)
 321afc8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 321afcc:	e0bffd17 	ldw	r2,-12(fp)
 321afd0:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
 321afd4:	e03ff915 	stw	zero,-28(fp)
 321afd8:	00003b06 	br	321b0c8 <OSSemDel+0x280>
 321afdc:	e0bff817 	ldw	r2,-32(fp)
 321afe0:	e0bff515 	stw	r2,-44(fp)
 321afe4:	e0bff517 	ldw	r2,-44(fp)
 321afe8:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 321afec:	e0fffd17 	ldw	r3,-12(fp)
 321aff0:	00801244 	movi	r2,73
 321aff4:	18800005 	stb	r2,0(r3)
                 pevent_return          = pevent;
 321aff8:	e0bffb17 	ldw	r2,-20(fp)
 321affc:	e0bff915 	stw	r2,-28(fp)
             }
             break;
 321b000:	00003106 	br	321b0c8 <OSSemDel+0x280>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 321b004:	e13ffb17 	ldw	r4,-20(fp)
 321b008:	000b883a 	mov	r5,zero
 321b00c:	01800044 	movi	r6,1
 321b010:	000f883a 	mov	r7,zero
 321b014:	32165480 	call	3216548 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
 321b018:	e0bffb17 	ldw	r2,-20(fp)
 321b01c:	10800283 	ldbu	r2,10(r2)
 321b020:	10803fcc 	andi	r2,r2,255
 321b024:	1004c03a 	cmpne	r2,r2,zero
 321b028:	103ff61e 	bne	r2,zero,321b004 <OSSemDel+0x1bc>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 321b02c:	e0fffb17 	ldw	r3,-20(fp)
 321b030:	00800fc4 	movi	r2,63
 321b034:	18800385 	stb	r2,14(r3)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 321b038:	e0bffb17 	ldw	r2,-20(fp)
 321b03c:	100003c5 	stb	zero,15(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 321b040:	e0bffb17 	ldw	r2,-20(fp)
 321b044:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 321b048:	0080c974 	movhi	r2,805
 321b04c:	10931304 	addi	r2,r2,19532
 321b050:	10c00017 	ldw	r3,0(r2)
 321b054:	e0bffb17 	ldw	r2,-20(fp)
 321b058:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 321b05c:	e0bffb17 	ldw	r2,-20(fp)
 321b060:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 321b064:	00c0c974 	movhi	r3,805
 321b068:	18d31304 	addi	r3,r3,19532
 321b06c:	e0bffb17 	ldw	r2,-20(fp)
 321b070:	18800015 	stw	r2,0(r3)
 321b074:	e0bff817 	ldw	r2,-32(fp)
 321b078:	e0bff415 	stw	r2,-48(fp)
 321b07c:	e0bff417 	ldw	r2,-48(fp)
 321b080:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 321b084:	e0bffa03 	ldbu	r2,-24(fp)
 321b088:	10800058 	cmpnei	r2,r2,1
 321b08c:	1000011e 	bne	r2,zero,321b094 <OSSemDel+0x24c>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 321b090:	3216f880 	call	3216f88 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 321b094:	e0bffd17 	ldw	r2,-12(fp)
 321b098:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
 321b09c:	e03ff915 	stw	zero,-28(fp)
             break;
 321b0a0:	00000906 	br	321b0c8 <OSSemDel+0x280>
 321b0a4:	e0bff817 	ldw	r2,-32(fp)
 321b0a8:	e0bff315 	stw	r2,-52(fp)
 321b0ac:	e0bff317 	ldw	r2,-52(fp)
 321b0b0:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 321b0b4:	e0fffd17 	ldw	r3,-12(fp)
 321b0b8:	008001c4 	movi	r2,7
 321b0bc:	18800005 	stb	r2,0(r3)
             pevent_return          = pevent;
 321b0c0:	e0bffb17 	ldw	r2,-20(fp)
 321b0c4:	e0bff915 	stw	r2,-28(fp)
             break;
    }
    return (pevent_return);
 321b0c8:	e0bff917 	ldw	r2,-28(fp)
 321b0cc:	e0bfff15 	stw	r2,-4(fp)
 321b0d0:	e0bfff17 	ldw	r2,-4(fp)
}
 321b0d4:	e037883a 	mov	sp,fp
 321b0d8:	dfc00117 	ldw	ra,4(sp)
 321b0dc:	df000017 	ldw	fp,0(sp)
 321b0e0:	dec00204 	addi	sp,sp,8
 321b0e4:	f800283a 	ret

0321b0e8 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 321b0e8:	defff404 	addi	sp,sp,-48
 321b0ec:	dfc00b15 	stw	ra,44(sp)
 321b0f0:	df000a15 	stw	fp,40(sp)
 321b0f4:	df000a04 	addi	fp,sp,40
 321b0f8:	e13ffc15 	stw	r4,-16(fp)
 321b0fc:	e1bffe15 	stw	r6,-8(fp)
 321b100:	e17ffd0d 	sth	r5,-12(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 321b104:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 321b108:	e0bffe17 	ldw	r2,-8(fp)
 321b10c:	1005003a 	cmpeq	r2,r2,zero
 321b110:	10008f1e 	bne	r2,zero,321b350 <OSSemPend+0x268>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 321b114:	e0bffc17 	ldw	r2,-16(fp)
 321b118:	1004c03a 	cmpne	r2,r2,zero
 321b11c:	1000041e 	bne	r2,zero,321b130 <OSSemPend+0x48>
        *perr = OS_ERR_PEVENT_NULL;
 321b120:	e0fffe17 	ldw	r3,-8(fp)
 321b124:	00800104 	movi	r2,4
 321b128:	18800005 	stb	r2,0(r3)
        return;
 321b12c:	00008806 	br	321b350 <OSSemPend+0x268>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 321b130:	e0bffc17 	ldw	r2,-16(fp)
 321b134:	10800003 	ldbu	r2,0(r2)
 321b138:	10803fcc 	andi	r2,r2,255
 321b13c:	108000e0 	cmpeqi	r2,r2,3
 321b140:	1000041e 	bne	r2,zero,321b154 <OSSemPend+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 321b144:	e0fffe17 	ldw	r3,-8(fp)
 321b148:	00800044 	movi	r2,1
 321b14c:	18800005 	stb	r2,0(r3)
        return;
 321b150:	00007f06 	br	321b350 <OSSemPend+0x268>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 321b154:	0080c974 	movhi	r2,805
 321b158:	10931404 	addi	r2,r2,19536
 321b15c:	10800003 	ldbu	r2,0(r2)
 321b160:	10803fcc 	andi	r2,r2,255
 321b164:	1005003a 	cmpeq	r2,r2,zero
 321b168:	1000041e 	bne	r2,zero,321b17c <OSSemPend+0x94>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
 321b16c:	e0fffe17 	ldw	r3,-8(fp)
 321b170:	00800084 	movi	r2,2
 321b174:	18800005 	stb	r2,0(r3)
        return;
 321b178:	00007506 	br	321b350 <OSSemPend+0x268>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
 321b17c:	0080c974 	movhi	r2,805
 321b180:	10930604 	addi	r2,r2,19480
 321b184:	10800003 	ldbu	r2,0(r2)
 321b188:	10803fcc 	andi	r2,r2,255
 321b18c:	1005003a 	cmpeq	r2,r2,zero
 321b190:	1000041e 	bne	r2,zero,321b1a4 <OSSemPend+0xbc>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
 321b194:	e0fffe17 	ldw	r3,-8(fp)
 321b198:	00800344 	movi	r2,13
 321b19c:	18800005 	stb	r2,0(r3)
        return;
 321b1a0:	00006b06 	br	321b350 <OSSemPend+0x268>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321b1a4:	0005303a 	rdctl	r2,status
 321b1a8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321b1ac:	e0fffa17 	ldw	r3,-24(fp)
 321b1b0:	00bfff84 	movi	r2,-2
 321b1b4:	1884703a 	and	r2,r3,r2
 321b1b8:	1001703a 	wrctl	status,r2
  
  return context;
 321b1bc:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 321b1c0:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
 321b1c4:	e0bffc17 	ldw	r2,-16(fp)
 321b1c8:	1080020b 	ldhu	r2,8(r2)
 321b1cc:	10bfffcc 	andi	r2,r2,65535
 321b1d0:	1005003a 	cmpeq	r2,r2,zero
 321b1d4:	10000d1e 	bne	r2,zero,321b20c <OSSemPend+0x124>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
 321b1d8:	e0bffc17 	ldw	r2,-16(fp)
 321b1dc:	1080020b 	ldhu	r2,8(r2)
 321b1e0:	10bfffc4 	addi	r2,r2,-1
 321b1e4:	1007883a 	mov	r3,r2
 321b1e8:	e0bffc17 	ldw	r2,-16(fp)
 321b1ec:	10c0020d 	sth	r3,8(r2)
 321b1f0:	e0bffb17 	ldw	r2,-20(fp)
 321b1f4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321b1f8:	e0bff917 	ldw	r2,-28(fp)
 321b1fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 321b200:	e0bffe17 	ldw	r2,-8(fp)
 321b204:	10000005 	stb	zero,0(r2)
        return;
 321b208:	00005106 	br	321b350 <OSSemPend+0x268>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
 321b20c:	0080c974 	movhi	r2,805
 321b210:	10931504 	addi	r2,r2,19540
 321b214:	10c00017 	ldw	r3,0(r2)
 321b218:	0080c974 	movhi	r2,805
 321b21c:	10931504 	addi	r2,r2,19540
 321b220:	10800017 	ldw	r2,0(r2)
 321b224:	10800c03 	ldbu	r2,48(r2)
 321b228:	10800054 	ori	r2,r2,1
 321b22c:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 321b230:	0080c974 	movhi	r2,805
 321b234:	10931504 	addi	r2,r2,19540
 321b238:	10800017 	ldw	r2,0(r2)
 321b23c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
 321b240:	0080c974 	movhi	r2,805
 321b244:	10931504 	addi	r2,r2,19540
 321b248:	10c00017 	ldw	r3,0(r2)
 321b24c:	e0bffd0b 	ldhu	r2,-12(fp)
 321b250:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 321b254:	e13ffc17 	ldw	r4,-16(fp)
 321b258:	32166dc0 	call	32166dc <OS_EventTaskWait>
 321b25c:	e0bffb17 	ldw	r2,-20(fp)
 321b260:	e0bff815 	stw	r2,-32(fp)
 321b264:	e0bff817 	ldw	r2,-32(fp)
 321b268:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
 321b26c:	3216f880 	call	3216f88 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321b270:	0005303a 	rdctl	r2,status
 321b274:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321b278:	e0fff717 	ldw	r3,-36(fp)
 321b27c:	00bfff84 	movi	r2,-2
 321b280:	1884703a 	and	r2,r3,r2
 321b284:	1001703a 	wrctl	status,r2
  
  return context;
 321b288:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 321b28c:	e0bffb15 	stw	r2,-20(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 321b290:	0080c974 	movhi	r2,805
 321b294:	10931504 	addi	r2,r2,19540
 321b298:	10800017 	ldw	r2,0(r2)
 321b29c:	10800c43 	ldbu	r2,49(r2)
 321b2a0:	10803fcc 	andi	r2,r2,255
 321b2a4:	e0bfff15 	stw	r2,-4(fp)
 321b2a8:	e0ffff17 	ldw	r3,-4(fp)
 321b2ac:	1805003a 	cmpeq	r2,r3,zero
 321b2b0:	1000041e 	bne	r2,zero,321b2c4 <OSSemPend+0x1dc>
 321b2b4:	e0ffff17 	ldw	r3,-4(fp)
 321b2b8:	188000a0 	cmpeqi	r2,r3,2
 321b2bc:	1000041e 	bne	r2,zero,321b2d0 <OSSemPend+0x1e8>
 321b2c0:	00000706 	br	321b2e0 <OSSemPend+0x1f8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
 321b2c4:	e0bffe17 	ldw	r2,-8(fp)
 321b2c8:	10000005 	stb	zero,0(r2)
             break;
 321b2cc:	00000c06 	br	321b300 <OSSemPend+0x218>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 321b2d0:	e0fffe17 	ldw	r3,-8(fp)
 321b2d4:	00800384 	movi	r2,14
 321b2d8:	18800005 	stb	r2,0(r3)
             break;
 321b2dc:	00000806 	br	321b300 <OSSemPend+0x218>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
 321b2e0:	0080c974 	movhi	r2,805
 321b2e4:	10931504 	addi	r2,r2,19540
 321b2e8:	11000017 	ldw	r4,0(r2)
 321b2ec:	e17ffc17 	ldw	r5,-16(fp)
 321b2f0:	32169400 	call	3216940 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 321b2f4:	e0fffe17 	ldw	r3,-8(fp)
 321b2f8:	00800284 	movi	r2,10
 321b2fc:	18800005 	stb	r2,0(r3)
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 321b300:	0080c974 	movhi	r2,805
 321b304:	10931504 	addi	r2,r2,19540
 321b308:	10800017 	ldw	r2,0(r2)
 321b30c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 321b310:	0080c974 	movhi	r2,805
 321b314:	10931504 	addi	r2,r2,19540
 321b318:	10800017 	ldw	r2,0(r2)
 321b31c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 321b320:	0080c974 	movhi	r2,805
 321b324:	10931504 	addi	r2,r2,19540
 321b328:	10800017 	ldw	r2,0(r2)
 321b32c:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 321b330:	0080c974 	movhi	r2,805
 321b334:	10931504 	addi	r2,r2,19540
 321b338:	10800017 	ldw	r2,0(r2)
 321b33c:	10000815 	stw	zero,32(r2)
 321b340:	e0bffb17 	ldw	r2,-20(fp)
 321b344:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321b348:	e0bff617 	ldw	r2,-40(fp)
 321b34c:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
}
 321b350:	e037883a 	mov	sp,fp
 321b354:	dfc00117 	ldw	ra,4(sp)
 321b358:	df000017 	ldw	fp,0(sp)
 321b35c:	dec00204 	addi	sp,sp,8
 321b360:	f800283a 	ret

0321b364 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 321b364:	defff504 	addi	sp,sp,-44
 321b368:	dfc00a15 	stw	ra,40(sp)
 321b36c:	df000915 	stw	fp,36(sp)
 321b370:	df000904 	addi	fp,sp,36
 321b374:	e13ffc15 	stw	r4,-16(fp)
 321b378:	e1bffe15 	stw	r6,-8(fp)
 321b37c:	e17ffd05 	stb	r5,-12(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 321b380:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 321b384:	e0bffe17 	ldw	r2,-8(fp)
 321b388:	1004c03a 	cmpne	r2,r2,zero
 321b38c:	1000021e 	bne	r2,zero,321b398 <OSSemPendAbort+0x34>
        return (0);
 321b390:	e03fff15 	stw	zero,-4(fp)
 321b394:	00004c06 	br	321b4c8 <OSSemPendAbort+0x164>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 321b398:	e0bffc17 	ldw	r2,-16(fp)
 321b39c:	1004c03a 	cmpne	r2,r2,zero
 321b3a0:	1000051e 	bne	r2,zero,321b3b8 <OSSemPendAbort+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 321b3a4:	e0fffe17 	ldw	r3,-8(fp)
 321b3a8:	00800104 	movi	r2,4
 321b3ac:	18800005 	stb	r2,0(r3)
        return (0);
 321b3b0:	e03fff15 	stw	zero,-4(fp)
 321b3b4:	00004406 	br	321b4c8 <OSSemPendAbort+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 321b3b8:	e0bffc17 	ldw	r2,-16(fp)
 321b3bc:	10800003 	ldbu	r2,0(r2)
 321b3c0:	10803fcc 	andi	r2,r2,255
 321b3c4:	108000e0 	cmpeqi	r2,r2,3
 321b3c8:	1000051e 	bne	r2,zero,321b3e0 <OSSemPendAbort+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 321b3cc:	e0fffe17 	ldw	r3,-8(fp)
 321b3d0:	00800044 	movi	r2,1
 321b3d4:	18800005 	stb	r2,0(r3)
        return (0);
 321b3d8:	e03fff15 	stw	zero,-4(fp)
 321b3dc:	00003a06 	br	321b4c8 <OSSemPendAbort+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321b3e0:	0005303a 	rdctl	r2,status
 321b3e4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321b3e8:	e0fff917 	ldw	r3,-28(fp)
 321b3ec:	00bfff84 	movi	r2,-2
 321b3f0:	1884703a 	and	r2,r3,r2
 321b3f4:	1001703a 	wrctl	status,r2
  
  return context;
 321b3f8:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 321b3fc:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
 321b400:	e0bffc17 	ldw	r2,-16(fp)
 321b404:	10800283 	ldbu	r2,10(r2)
 321b408:	10803fcc 	andi	r2,r2,255
 321b40c:	1005003a 	cmpeq	r2,r2,zero
 321b410:	1000261e 	bne	r2,zero,321b4ac <OSSemPendAbort+0x148>
        nbr_tasks = 0;
 321b414:	e03ffb05 	stb	zero,-20(fp)
        switch (opt) {
 321b418:	e0bffd03 	ldbu	r2,-12(fp)
 321b41c:	10800060 	cmpeqi	r2,r2,1
 321b420:	1000091e 	bne	r2,zero,321b448 <OSSemPendAbort+0xe4>
 321b424:	00000e06 	br	321b460 <OSSemPendAbort+0xfc>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 321b428:	e13ffc17 	ldw	r4,-16(fp)
 321b42c:	000b883a 	mov	r5,zero
 321b430:	01800044 	movi	r6,1
 321b434:	01c00084 	movi	r7,2
 321b438:	32165480 	call	3216548 <OS_EventTaskRdy>
                     nbr_tasks++;
 321b43c:	e0bffb03 	ldbu	r2,-20(fp)
 321b440:	10800044 	addi	r2,r2,1
 321b444:	e0bffb05 	stb	r2,-20(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 321b448:	e0bffc17 	ldw	r2,-16(fp)
 321b44c:	10800283 	ldbu	r2,10(r2)
 321b450:	10803fcc 	andi	r2,r2,255
 321b454:	1004c03a 	cmpne	r2,r2,zero
 321b458:	103ff31e 	bne	r2,zero,321b428 <OSSemPendAbort+0xc4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 321b45c:	00000806 	br	321b480 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 321b460:	e13ffc17 	ldw	r4,-16(fp)
 321b464:	000b883a 	mov	r5,zero
 321b468:	01800044 	movi	r6,1
 321b46c:	01c00084 	movi	r7,2
 321b470:	32165480 	call	3216548 <OS_EventTaskRdy>
                 nbr_tasks++;
 321b474:	e0bffb03 	ldbu	r2,-20(fp)
 321b478:	10800044 	addi	r2,r2,1
 321b47c:	e0bffb05 	stb	r2,-20(fp)
 321b480:	e0bffa17 	ldw	r2,-24(fp)
 321b484:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321b488:	e0bff817 	ldw	r2,-32(fp)
 321b48c:	1001703a 	wrctl	status,r2
                 break;
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 321b490:	3216f880 	call	3216f88 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 321b494:	e0fffe17 	ldw	r3,-8(fp)
 321b498:	00800384 	movi	r2,14
 321b49c:	18800005 	stb	r2,0(r3)
        return (nbr_tasks);
 321b4a0:	e0bffb03 	ldbu	r2,-20(fp)
 321b4a4:	e0bfff15 	stw	r2,-4(fp)
 321b4a8:	00000706 	br	321b4c8 <OSSemPendAbort+0x164>
 321b4ac:	e0bffa17 	ldw	r2,-24(fp)
 321b4b0:	e0bff715 	stw	r2,-36(fp)
 321b4b4:	e0bff717 	ldw	r2,-36(fp)
 321b4b8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 321b4bc:	e0bffe17 	ldw	r2,-8(fp)
 321b4c0:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
 321b4c4:	e03fff15 	stw	zero,-4(fp)
 321b4c8:	e0bfff17 	ldw	r2,-4(fp)
}
 321b4cc:	e037883a 	mov	sp,fp
 321b4d0:	dfc00117 	ldw	ra,4(sp)
 321b4d4:	df000017 	ldw	fp,0(sp)
 321b4d8:	dec00204 	addi	sp,sp,8
 321b4dc:	f800283a 	ret

0321b4e0 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
 321b4e0:	defff704 	addi	sp,sp,-36
 321b4e4:	dfc00815 	stw	ra,32(sp)
 321b4e8:	df000715 	stw	fp,28(sp)
 321b4ec:	df000704 	addi	fp,sp,28
 321b4f0:	e13ffe15 	stw	r4,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 321b4f4:	e03ffd15 	stw	zero,-12(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 321b4f8:	e0bffe17 	ldw	r2,-8(fp)
 321b4fc:	1004c03a 	cmpne	r2,r2,zero
 321b500:	1000031e 	bne	r2,zero,321b510 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
 321b504:	00800104 	movi	r2,4
 321b508:	e0bfff15 	stw	r2,-4(fp)
 321b50c:	00003806 	br	321b5f0 <OSSemPost+0x110>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 321b510:	e0bffe17 	ldw	r2,-8(fp)
 321b514:	10800003 	ldbu	r2,0(r2)
 321b518:	10803fcc 	andi	r2,r2,255
 321b51c:	108000e0 	cmpeqi	r2,r2,3
 321b520:	1000031e 	bne	r2,zero,321b530 <OSSemPost+0x50>
        return (OS_ERR_EVENT_TYPE);
 321b524:	00800044 	movi	r2,1
 321b528:	e0bfff15 	stw	r2,-4(fp)
 321b52c:	00003006 	br	321b5f0 <OSSemPost+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321b530:	0005303a 	rdctl	r2,status
 321b534:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321b538:	e0fffc17 	ldw	r3,-16(fp)
 321b53c:	00bfff84 	movi	r2,-2
 321b540:	1884703a 	and	r2,r3,r2
 321b544:	1001703a 	wrctl	status,r2
  
  return context;
 321b548:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 321b54c:	e0bffd15 	stw	r2,-12(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
 321b550:	e0bffe17 	ldw	r2,-8(fp)
 321b554:	10800283 	ldbu	r2,10(r2)
 321b558:	10803fcc 	andi	r2,r2,255
 321b55c:	1005003a 	cmpeq	r2,r2,zero
 321b560:	10000c1e 	bne	r2,zero,321b594 <OSSemPost+0xb4>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 321b564:	e13ffe17 	ldw	r4,-8(fp)
 321b568:	000b883a 	mov	r5,zero
 321b56c:	01800044 	movi	r6,1
 321b570:	000f883a 	mov	r7,zero
 321b574:	32165480 	call	3216548 <OS_EventTaskRdy>
 321b578:	e0bffd17 	ldw	r2,-12(fp)
 321b57c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321b580:	e0bffb17 	ldw	r2,-20(fp)
 321b584:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 321b588:	3216f880 	call	3216f88 <OS_Sched>
        return (OS_ERR_NONE);
 321b58c:	e03fff15 	stw	zero,-4(fp)
 321b590:	00001706 	br	321b5f0 <OSSemPost+0x110>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
 321b594:	e0bffe17 	ldw	r2,-8(fp)
 321b598:	1080020b 	ldhu	r2,8(r2)
 321b59c:	10ffffcc 	andi	r3,r2,65535
 321b5a0:	00bfffd4 	movui	r2,65535
 321b5a4:	18800c26 	beq	r3,r2,321b5d8 <OSSemPost+0xf8>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
 321b5a8:	e0bffe17 	ldw	r2,-8(fp)
 321b5ac:	1080020b 	ldhu	r2,8(r2)
 321b5b0:	10800044 	addi	r2,r2,1
 321b5b4:	1007883a 	mov	r3,r2
 321b5b8:	e0bffe17 	ldw	r2,-8(fp)
 321b5bc:	10c0020d 	sth	r3,8(r2)
 321b5c0:	e0bffd17 	ldw	r2,-12(fp)
 321b5c4:	e0bffa15 	stw	r2,-24(fp)
 321b5c8:	e0bffa17 	ldw	r2,-24(fp)
 321b5cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 321b5d0:	e03fff15 	stw	zero,-4(fp)
 321b5d4:	00000606 	br	321b5f0 <OSSemPost+0x110>
 321b5d8:	e0bffd17 	ldw	r2,-12(fp)
 321b5dc:	e0bff915 	stw	r2,-28(fp)
 321b5e0:	e0bff917 	ldw	r2,-28(fp)
 321b5e4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
 321b5e8:	00800c84 	movi	r2,50
 321b5ec:	e0bfff15 	stw	r2,-4(fp)
 321b5f0:	e0bfff17 	ldw	r2,-4(fp)
}
 321b5f4:	e037883a 	mov	sp,fp
 321b5f8:	dfc00117 	ldw	ra,4(sp)
 321b5fc:	df000017 	ldw	fp,0(sp)
 321b600:	dec00204 	addi	sp,sp,8
 321b604:	f800283a 	ret

0321b608 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
 321b608:	defff604 	addi	sp,sp,-40
 321b60c:	df000915 	stw	fp,36(sp)
 321b610:	df000904 	addi	fp,sp,36
 321b614:	e13ffd15 	stw	r4,-12(fp)
 321b618:	e17ffe15 	stw	r5,-8(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 321b61c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 321b620:	e0bffd17 	ldw	r2,-12(fp)
 321b624:	1004c03a 	cmpne	r2,r2,zero
 321b628:	1000031e 	bne	r2,zero,321b638 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
 321b62c:	00800104 	movi	r2,4
 321b630:	e0bfff15 	stw	r2,-4(fp)
 321b634:	00003b06 	br	321b724 <OSSemQuery+0x11c>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
 321b638:	e0bffe17 	ldw	r2,-8(fp)
 321b63c:	1004c03a 	cmpne	r2,r2,zero
 321b640:	1000031e 	bne	r2,zero,321b650 <OSSemQuery+0x48>
        return (OS_ERR_PDATA_NULL);
 321b644:	00800244 	movi	r2,9
 321b648:	e0bfff15 	stw	r2,-4(fp)
 321b64c:	00003506 	br	321b724 <OSSemQuery+0x11c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 321b650:	e0bffd17 	ldw	r2,-12(fp)
 321b654:	10800003 	ldbu	r2,0(r2)
 321b658:	10803fcc 	andi	r2,r2,255
 321b65c:	108000e0 	cmpeqi	r2,r2,3
 321b660:	1000031e 	bne	r2,zero,321b670 <OSSemQuery+0x68>
        return (OS_ERR_EVENT_TYPE);
 321b664:	00800044 	movi	r2,1
 321b668:	e0bfff15 	stw	r2,-4(fp)
 321b66c:	00002d06 	br	321b724 <OSSemQuery+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321b670:	0005303a 	rdctl	r2,status
 321b674:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321b678:	e0fff817 	ldw	r3,-32(fp)
 321b67c:	00bfff84 	movi	r2,-2
 321b680:	1884703a 	and	r2,r3,r2
 321b684:	1001703a 	wrctl	status,r2
  
  return context;
 321b688:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 321b68c:	e0bff915 	stw	r2,-28(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
 321b690:	e0bffd17 	ldw	r2,-12(fp)
 321b694:	10c00283 	ldbu	r3,10(r2)
 321b698:	e0bffe17 	ldw	r2,-8(fp)
 321b69c:	10c00145 	stb	r3,5(r2)
    psrc                   = &pevent->OSEventTbl[0];
 321b6a0:	e0bffd17 	ldw	r2,-12(fp)
 321b6a4:	108002c4 	addi	r2,r2,11
 321b6a8:	e0bffc15 	stw	r2,-16(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
 321b6ac:	e0bffe17 	ldw	r2,-8(fp)
 321b6b0:	10800084 	addi	r2,r2,2
 321b6b4:	e0bffb15 	stw	r2,-20(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 321b6b8:	e03ffa05 	stb	zero,-24(fp)
 321b6bc:	00000d06 	br	321b6f4 <OSSemQuery+0xec>
        *pdest++ = *psrc++;
 321b6c0:	e0bffc17 	ldw	r2,-16(fp)
 321b6c4:	10c00003 	ldbu	r3,0(r2)
 321b6c8:	e0bffb17 	ldw	r2,-20(fp)
 321b6cc:	10c00005 	stb	r3,0(r2)
 321b6d0:	e0bffb17 	ldw	r2,-20(fp)
 321b6d4:	10800044 	addi	r2,r2,1
 321b6d8:	e0bffb15 	stw	r2,-20(fp)
 321b6dc:	e0bffc17 	ldw	r2,-16(fp)
 321b6e0:	10800044 	addi	r2,r2,1
 321b6e4:	e0bffc15 	stw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 321b6e8:	e0bffa03 	ldbu	r2,-24(fp)
 321b6ec:	10800044 	addi	r2,r2,1
 321b6f0:	e0bffa05 	stb	r2,-24(fp)
 321b6f4:	e0bffa03 	ldbu	r2,-24(fp)
 321b6f8:	108000f0 	cmpltui	r2,r2,3
 321b6fc:	103ff01e 	bne	r2,zero,321b6c0 <OSSemQuery+0xb8>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
 321b700:	e0bffd17 	ldw	r2,-12(fp)
 321b704:	10c0020b 	ldhu	r3,8(r2)
 321b708:	e0bffe17 	ldw	r2,-8(fp)
 321b70c:	10c0000d 	sth	r3,0(r2)
 321b710:	e0bff917 	ldw	r2,-28(fp)
 321b714:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321b718:	e0bff717 	ldw	r2,-36(fp)
 321b71c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 321b720:	e03fff15 	stw	zero,-4(fp)
 321b724:	e0bfff17 	ldw	r2,-4(fp)
}
 321b728:	e037883a 	mov	sp,fp
 321b72c:	df000017 	ldw	fp,0(sp)
 321b730:	dec00104 	addi	sp,sp,4
 321b734:	f800283a 	ret

0321b738 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
 321b738:	defff904 	addi	sp,sp,-28
 321b73c:	df000615 	stw	fp,24(sp)
 321b740:	df000604 	addi	fp,sp,24
 321b744:	e13ffd15 	stw	r4,-12(fp)
 321b748:	e1bfff15 	stw	r6,-4(fp)
 321b74c:	e17ffe0d 	sth	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 321b750:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 321b754:	e0bfff17 	ldw	r2,-4(fp)
 321b758:	1005003a 	cmpeq	r2,r2,zero
 321b75c:	1000331e 	bne	r2,zero,321b82c <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 321b760:	e0bffd17 	ldw	r2,-12(fp)
 321b764:	1004c03a 	cmpne	r2,r2,zero
 321b768:	1000041e 	bne	r2,zero,321b77c <OSSemSet+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 321b76c:	e0ffff17 	ldw	r3,-4(fp)
 321b770:	00800104 	movi	r2,4
 321b774:	18800005 	stb	r2,0(r3)
        return;
 321b778:	00002c06 	br	321b82c <OSSemSet+0xf4>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 321b77c:	e0bffd17 	ldw	r2,-12(fp)
 321b780:	10800003 	ldbu	r2,0(r2)
 321b784:	10803fcc 	andi	r2,r2,255
 321b788:	108000e0 	cmpeqi	r2,r2,3
 321b78c:	1000041e 	bne	r2,zero,321b7a0 <OSSemSet+0x68>
        *perr = OS_ERR_EVENT_TYPE;
 321b790:	e0ffff17 	ldw	r3,-4(fp)
 321b794:	00800044 	movi	r2,1
 321b798:	18800005 	stb	r2,0(r3)
        return;
 321b79c:	00002306 	br	321b82c <OSSemSet+0xf4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321b7a0:	0005303a 	rdctl	r2,status
 321b7a4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321b7a8:	e0fffb17 	ldw	r3,-20(fp)
 321b7ac:	00bfff84 	movi	r2,-2
 321b7b0:	1884703a 	and	r2,r3,r2
 321b7b4:	1001703a 	wrctl	status,r2
  
  return context;
 321b7b8:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 321b7bc:	e0bffc15 	stw	r2,-16(fp)
    *perr = OS_ERR_NONE;
 321b7c0:	e0bfff17 	ldw	r2,-4(fp)
 321b7c4:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
 321b7c8:	e0bffd17 	ldw	r2,-12(fp)
 321b7cc:	1080020b 	ldhu	r2,8(r2)
 321b7d0:	10bfffcc 	andi	r2,r2,65535
 321b7d4:	1005003a 	cmpeq	r2,r2,zero
 321b7d8:	1000041e 	bne	r2,zero,321b7ec <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
 321b7dc:	e0fffd17 	ldw	r3,-12(fp)
 321b7e0:	e0bffe0b 	ldhu	r2,-8(fp)
 321b7e4:	1880020d 	sth	r2,8(r3)
 321b7e8:	00000c06 	br	321b81c <OSSemSet+0xe4>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
 321b7ec:	e0bffd17 	ldw	r2,-12(fp)
 321b7f0:	10800283 	ldbu	r2,10(r2)
 321b7f4:	10803fcc 	andi	r2,r2,255
 321b7f8:	1004c03a 	cmpne	r2,r2,zero
 321b7fc:	1000041e 	bne	r2,zero,321b810 <OSSemSet+0xd8>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
 321b800:	e0fffd17 	ldw	r3,-12(fp)
 321b804:	e0bffe0b 	ldhu	r2,-8(fp)
 321b808:	1880020d 	sth	r2,8(r3)
 321b80c:	00000306 	br	321b81c <OSSemSet+0xe4>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
 321b810:	e0ffff17 	ldw	r3,-4(fp)
 321b814:	00801244 	movi	r2,73
 321b818:	18800005 	stb	r2,0(r3)
 321b81c:	e0bffc17 	ldw	r2,-16(fp)
 321b820:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321b824:	e0bffa17 	ldw	r2,-24(fp)
 321b828:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
}
 321b82c:	e037883a 	mov	sp,fp
 321b830:	df000017 	ldw	fp,0(sp)
 321b834:	dec00104 	addi	sp,sp,4
 321b838:	f800283a 	ret

0321b83c <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
 321b83c:	defff004 	addi	sp,sp,-64
 321b840:	dfc00f15 	stw	ra,60(sp)
 321b844:	df000e15 	stw	fp,56(sp)
 321b848:	df000e04 	addi	fp,sp,56
 321b84c:	e13ffd05 	stb	r4,-12(fp)
 321b850:	e17ffe05 	stb	r5,-8(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
 321b854:	e03ff715 	stw	zero,-36(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
 321b858:	e0bffd03 	ldbu	r2,-12(fp)
 321b85c:	10800530 	cmpltui	r2,r2,20
 321b860:	1000061e 	bne	r2,zero,321b87c <OSTaskChangePrio+0x40>
        if (oldprio != OS_PRIO_SELF) {
 321b864:	e0bffd03 	ldbu	r2,-12(fp)
 321b868:	10803fe0 	cmpeqi	r2,r2,255
 321b86c:	1000031e 	bne	r2,zero,321b87c <OSTaskChangePrio+0x40>
            return (OS_ERR_PRIO_INVALID);
 321b870:	00800a84 	movi	r2,42
 321b874:	e0bfff15 	stw	r2,-4(fp)
 321b878:	00014706 	br	321bd98 <OSTaskChangePrio+0x55c>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
 321b87c:	e0bffe03 	ldbu	r2,-8(fp)
 321b880:	10800530 	cmpltui	r2,r2,20
 321b884:	1000031e 	bne	r2,zero,321b894 <OSTaskChangePrio+0x58>
        return (OS_ERR_PRIO_INVALID);
 321b888:	00800a84 	movi	r2,42
 321b88c:	e0bfff15 	stw	r2,-4(fp)
 321b890:	00014106 	br	321bd98 <OSTaskChangePrio+0x55c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321b894:	0005303a 	rdctl	r2,status
 321b898:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321b89c:	e0fff617 	ldw	r3,-40(fp)
 321b8a0:	00bfff84 	movi	r2,-2
 321b8a4:	1884703a 	and	r2,r3,r2
 321b8a8:	1001703a 	wrctl	status,r2
  
  return context;
 321b8ac:	e0bff617 	ldw	r2,-40(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 321b8b0:	e0bff715 	stw	r2,-36(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
 321b8b4:	e0bffe03 	ldbu	r2,-8(fp)
 321b8b8:	00c0c9b4 	movhi	r3,806
 321b8bc:	18f26b04 	addi	r3,r3,-13908
 321b8c0:	1085883a 	add	r2,r2,r2
 321b8c4:	1085883a 	add	r2,r2,r2
 321b8c8:	10c5883a 	add	r2,r2,r3
 321b8cc:	10800017 	ldw	r2,0(r2)
 321b8d0:	1005003a 	cmpeq	r2,r2,zero
 321b8d4:	1000071e 	bne	r2,zero,321b8f4 <OSTaskChangePrio+0xb8>
 321b8d8:	e0bff717 	ldw	r2,-36(fp)
 321b8dc:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321b8e0:	e0bff517 	ldw	r2,-44(fp)
 321b8e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
 321b8e8:	00800a04 	movi	r2,40
 321b8ec:	e0bfff15 	stw	r2,-4(fp)
 321b8f0:	00012906 	br	321bd98 <OSTaskChangePrio+0x55c>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
 321b8f4:	e0bffd03 	ldbu	r2,-12(fp)
 321b8f8:	10803fd8 	cmpnei	r2,r2,255
 321b8fc:	1000051e 	bne	r2,zero,321b914 <OSTaskChangePrio+0xd8>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
 321b900:	0080c974 	movhi	r2,805
 321b904:	10931504 	addi	r2,r2,19540
 321b908:	10800017 	ldw	r2,0(r2)
 321b90c:	10800c83 	ldbu	r2,50(r2)
 321b910:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
 321b914:	e0bffd03 	ldbu	r2,-12(fp)
 321b918:	00c0c9b4 	movhi	r3,806
 321b91c:	18f26b04 	addi	r3,r3,-13908
 321b920:	1085883a 	add	r2,r2,r2
 321b924:	1085883a 	add	r2,r2,r2
 321b928:	10c5883a 	add	r2,r2,r3
 321b92c:	10800017 	ldw	r2,0(r2)
 321b930:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
 321b934:	e0bffa17 	ldw	r2,-24(fp)
 321b938:	1004c03a 	cmpne	r2,r2,zero
 321b93c:	1000071e 	bne	r2,zero,321b95c <OSTaskChangePrio+0x120>
 321b940:	e0bff717 	ldw	r2,-36(fp)
 321b944:	e0bff415 	stw	r2,-48(fp)
 321b948:	e0bff417 	ldw	r2,-48(fp)
 321b94c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
 321b950:	00800a44 	movi	r2,41
 321b954:	e0bfff15 	stw	r2,-4(fp)
 321b958:	00010f06 	br	321bd98 <OSTaskChangePrio+0x55c>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
 321b95c:	e0bffa17 	ldw	r2,-24(fp)
 321b960:	10800058 	cmpnei	r2,r2,1
 321b964:	1000071e 	bne	r2,zero,321b984 <OSTaskChangePrio+0x148>
 321b968:	e0bff717 	ldw	r2,-36(fp)
 321b96c:	e0bff315 	stw	r2,-52(fp)
 321b970:	e0bff317 	ldw	r2,-52(fp)
 321b974:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
 321b978:	008010c4 	movi	r2,67
 321b97c:	e0bfff15 	stw	r2,-4(fp)
 321b980:	00010506 	br	321bd98 <OSTaskChangePrio+0x55c>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
 321b984:	e0bffe03 	ldbu	r2,-8(fp)
 321b988:	1004d0fa 	srli	r2,r2,3
 321b98c:	e0bff985 	stb	r2,-26(fp)
    x_new                 = (INT8U)(newprio & 0x07);
 321b990:	e0bffe03 	ldbu	r2,-8(fp)
 321b994:	108001cc 	andi	r2,r2,7
 321b998:	e0bff945 	stb	r2,-27(fp)
    bity_new              = (INT8U)(1 << y_new);
 321b99c:	e0fff983 	ldbu	r3,-26(fp)
 321b9a0:	00800044 	movi	r2,1
 321b9a4:	10c4983a 	sll	r2,r2,r3
 321b9a8:	e0bff8c5 	stb	r2,-29(fp)
    bitx_new              = (INT8U)(1 << x_new);
 321b9ac:	e0fff943 	ldbu	r3,-27(fp)
 321b9b0:	00800044 	movi	r2,1
 321b9b4:	10c4983a 	sll	r2,r2,r3
 321b9b8:	e0bff885 	stb	r2,-30(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
 321b9bc:	e0bffd03 	ldbu	r2,-12(fp)
 321b9c0:	00c0c9b4 	movhi	r3,806
 321b9c4:	18f26b04 	addi	r3,r3,-13908
 321b9c8:	1085883a 	add	r2,r2,r2
 321b9cc:	1085883a 	add	r2,r2,r2
 321b9d0:	10c5883a 	add	r2,r2,r3
 321b9d4:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
 321b9d8:	e0bffe03 	ldbu	r2,-8(fp)
 321b9dc:	00c0c9b4 	movhi	r3,806
 321b9e0:	18f26b04 	addi	r3,r3,-13908
 321b9e4:	1085883a 	add	r2,r2,r2
 321b9e8:	1085883a 	add	r2,r2,r2
 321b9ec:	10c7883a 	add	r3,r2,r3
 321b9f0:	e0bffa17 	ldw	r2,-24(fp)
 321b9f4:	18800015 	stw	r2,0(r3)
    y_old                 =  ptcb->OSTCBY;
 321b9f8:	e0bffa17 	ldw	r2,-24(fp)
 321b9fc:	10800d03 	ldbu	r2,52(r2)
 321ba00:	e0bff905 	stb	r2,-28(fp)
    bity_old              =  ptcb->OSTCBBitY;
 321ba04:	e0bffa17 	ldw	r2,-24(fp)
 321ba08:	10800d83 	ldbu	r2,54(r2)
 321ba0c:	e0bff845 	stb	r2,-31(fp)
    bitx_old              =  ptcb->OSTCBBitX;
 321ba10:	e0bffa17 	ldw	r2,-24(fp)
 321ba14:	10800d43 	ldbu	r2,53(r2)
 321ba18:	e0bff805 	stb	r2,-32(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
 321ba1c:	e0fff903 	ldbu	r3,-28(fp)
 321ba20:	0080c974 	movhi	r2,805
 321ba24:	10931244 	addi	r2,r2,19529
 321ba28:	10c5883a 	add	r2,r2,r3
 321ba2c:	10c00003 	ldbu	r3,0(r2)
 321ba30:	e0bff803 	ldbu	r2,-32(fp)
 321ba34:	1884703a 	and	r2,r3,r2
 321ba38:	10803fcc 	andi	r2,r2,255
 321ba3c:	1005003a 	cmpeq	r2,r2,zero
 321ba40:	1000381e 	bne	r2,zero,321bb24 <OSTaskChangePrio+0x2e8>
         OSRdyTbl[y_old] &= ~bitx_old;
 321ba44:	e13ff903 	ldbu	r4,-28(fp)
 321ba48:	e0fff903 	ldbu	r3,-28(fp)
 321ba4c:	0080c974 	movhi	r2,805
 321ba50:	10931244 	addi	r2,r2,19529
 321ba54:	10c5883a 	add	r2,r2,r3
 321ba58:	10800003 	ldbu	r2,0(r2)
 321ba5c:	1007883a 	mov	r3,r2
 321ba60:	e0bff803 	ldbu	r2,-32(fp)
 321ba64:	0084303a 	nor	r2,zero,r2
 321ba68:	1884703a 	and	r2,r3,r2
 321ba6c:	1007883a 	mov	r3,r2
 321ba70:	0080c974 	movhi	r2,805
 321ba74:	10931244 	addi	r2,r2,19529
 321ba78:	1105883a 	add	r2,r2,r4
 321ba7c:	10c00005 	stb	r3,0(r2)
         if (OSRdyTbl[y_old] == 0) {
 321ba80:	e0fff903 	ldbu	r3,-28(fp)
 321ba84:	0080c974 	movhi	r2,805
 321ba88:	10931244 	addi	r2,r2,19529
 321ba8c:	10c5883a 	add	r2,r2,r3
 321ba90:	10800003 	ldbu	r2,0(r2)
 321ba94:	10803fcc 	andi	r2,r2,255
 321ba98:	1004c03a 	cmpne	r2,r2,zero
 321ba9c:	10000b1e 	bne	r2,zero,321bacc <OSTaskChangePrio+0x290>
             OSRdyGrp &= ~bity_old;
 321baa0:	e0bff843 	ldbu	r2,-31(fp)
 321baa4:	0084303a 	nor	r2,zero,r2
 321baa8:	1007883a 	mov	r3,r2
 321baac:	0080c974 	movhi	r2,805
 321bab0:	10931204 	addi	r2,r2,19528
 321bab4:	10800003 	ldbu	r2,0(r2)
 321bab8:	1884703a 	and	r2,r3,r2
 321babc:	1007883a 	mov	r3,r2
 321bac0:	0080c974 	movhi	r2,805
 321bac4:	10931204 	addi	r2,r2,19528
 321bac8:	10c00005 	stb	r3,0(r2)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
 321bacc:	0080c974 	movhi	r2,805
 321bad0:	10931204 	addi	r2,r2,19528
 321bad4:	10c00003 	ldbu	r3,0(r2)
 321bad8:	e0bff8c3 	ldbu	r2,-29(fp)
 321badc:	1884b03a 	or	r2,r3,r2
 321bae0:	1007883a 	mov	r3,r2
 321bae4:	0080c974 	movhi	r2,805
 321bae8:	10931204 	addi	r2,r2,19528
 321baec:	10c00005 	stb	r3,0(r2)
         OSRdyTbl[y_new] |= bitx_new;
 321baf0:	e13ff983 	ldbu	r4,-26(fp)
 321baf4:	e0fff983 	ldbu	r3,-26(fp)
 321baf8:	0080c974 	movhi	r2,805
 321bafc:	10931244 	addi	r2,r2,19529
 321bb00:	10c5883a 	add	r2,r2,r3
 321bb04:	10c00003 	ldbu	r3,0(r2)
 321bb08:	e0bff883 	ldbu	r2,-30(fp)
 321bb0c:	1884b03a 	or	r2,r3,r2
 321bb10:	1007883a 	mov	r3,r2
 321bb14:	0080c974 	movhi	r2,805
 321bb18:	10931244 	addi	r2,r2,19529
 321bb1c:	1105883a 	add	r2,r2,r4
 321bb20:	10c00005 	stb	r3,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
 321bb24:	e0bffa17 	ldw	r2,-24(fp)
 321bb28:	10800717 	ldw	r2,28(r2)
 321bb2c:	e0bffc15 	stw	r2,-16(fp)
    if (pevent != (OS_EVENT *)0) {
 321bb30:	e0bffc17 	ldw	r2,-16(fp)
 321bb34:	1005003a 	cmpeq	r2,r2,zero
 321bb38:	1000341e 	bne	r2,zero,321bc0c <OSTaskChangePrio+0x3d0>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
 321bb3c:	e13ff903 	ldbu	r4,-28(fp)
 321bb40:	e0fff903 	ldbu	r3,-28(fp)
 321bb44:	e0bffc17 	ldw	r2,-16(fp)
 321bb48:	1885883a 	add	r2,r3,r2
 321bb4c:	10800204 	addi	r2,r2,8
 321bb50:	108000c3 	ldbu	r2,3(r2)
 321bb54:	1007883a 	mov	r3,r2
 321bb58:	e0bff803 	ldbu	r2,-32(fp)
 321bb5c:	0084303a 	nor	r2,zero,r2
 321bb60:	1884703a 	and	r2,r3,r2
 321bb64:	1007883a 	mov	r3,r2
 321bb68:	e0bffc17 	ldw	r2,-16(fp)
 321bb6c:	2085883a 	add	r2,r4,r2
 321bb70:	10800204 	addi	r2,r2,8
 321bb74:	10c000c5 	stb	r3,3(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
 321bb78:	e0fff903 	ldbu	r3,-28(fp)
 321bb7c:	e0bffc17 	ldw	r2,-16(fp)
 321bb80:	1885883a 	add	r2,r3,r2
 321bb84:	10800204 	addi	r2,r2,8
 321bb88:	108000c3 	ldbu	r2,3(r2)
 321bb8c:	10803fcc 	andi	r2,r2,255
 321bb90:	1004c03a 	cmpne	r2,r2,zero
 321bb94:	1000091e 	bne	r2,zero,321bbbc <OSTaskChangePrio+0x380>
            pevent->OSEventGrp    &= ~bity_old;
 321bb98:	e0bffc17 	ldw	r2,-16(fp)
 321bb9c:	10800283 	ldbu	r2,10(r2)
 321bba0:	1007883a 	mov	r3,r2
 321bba4:	e0bff843 	ldbu	r2,-31(fp)
 321bba8:	0084303a 	nor	r2,zero,r2
 321bbac:	1884703a 	and	r2,r3,r2
 321bbb0:	1007883a 	mov	r3,r2
 321bbb4:	e0bffc17 	ldw	r2,-16(fp)
 321bbb8:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
 321bbbc:	e0bffc17 	ldw	r2,-16(fp)
 321bbc0:	10c00283 	ldbu	r3,10(r2)
 321bbc4:	e0bff8c3 	ldbu	r2,-29(fp)
 321bbc8:	1884b03a 	or	r2,r3,r2
 321bbcc:	1007883a 	mov	r3,r2
 321bbd0:	e0bffc17 	ldw	r2,-16(fp)
 321bbd4:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
 321bbd8:	e13ff983 	ldbu	r4,-26(fp)
 321bbdc:	e0fff983 	ldbu	r3,-26(fp)
 321bbe0:	e0bffc17 	ldw	r2,-16(fp)
 321bbe4:	1885883a 	add	r2,r3,r2
 321bbe8:	10800204 	addi	r2,r2,8
 321bbec:	10c000c3 	ldbu	r3,3(r2)
 321bbf0:	e0bff883 	ldbu	r2,-30(fp)
 321bbf4:	1884b03a 	or	r2,r3,r2
 321bbf8:	1007883a 	mov	r3,r2
 321bbfc:	e0bffc17 	ldw	r2,-16(fp)
 321bc00:	2085883a 	add	r2,r4,r2
 321bc04:	10800204 	addi	r2,r2,8
 321bc08:	10c000c5 	stb	r3,3(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
 321bc0c:	e0bffa17 	ldw	r2,-24(fp)
 321bc10:	10800817 	ldw	r2,32(r2)
 321bc14:	1005003a 	cmpeq	r2,r2,zero
 321bc18:	1000441e 	bne	r2,zero,321bd2c <OSTaskChangePrio+0x4f0>
        pevents =  ptcb->OSTCBEventMultiPtr;
 321bc1c:	e0bffa17 	ldw	r2,-24(fp)
 321bc20:	10800817 	ldw	r2,32(r2)
 321bc24:	e0bffb15 	stw	r2,-20(fp)
        pevent  = *pevents;
 321bc28:	e0bffb17 	ldw	r2,-20(fp)
 321bc2c:	10800017 	ldw	r2,0(r2)
 321bc30:	e0bffc15 	stw	r2,-16(fp)
        while (pevent != (OS_EVENT *)0) {
 321bc34:	00003a06 	br	321bd20 <OSTaskChangePrio+0x4e4>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
 321bc38:	e13ff903 	ldbu	r4,-28(fp)
 321bc3c:	e0fff903 	ldbu	r3,-28(fp)
 321bc40:	e0bffc17 	ldw	r2,-16(fp)
 321bc44:	1885883a 	add	r2,r3,r2
 321bc48:	10800204 	addi	r2,r2,8
 321bc4c:	108000c3 	ldbu	r2,3(r2)
 321bc50:	1007883a 	mov	r3,r2
 321bc54:	e0bff803 	ldbu	r2,-32(fp)
 321bc58:	0084303a 	nor	r2,zero,r2
 321bc5c:	1884703a 	and	r2,r3,r2
 321bc60:	1007883a 	mov	r3,r2
 321bc64:	e0bffc17 	ldw	r2,-16(fp)
 321bc68:	2085883a 	add	r2,r4,r2
 321bc6c:	10800204 	addi	r2,r2,8
 321bc70:	10c000c5 	stb	r3,3(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
 321bc74:	e0fff903 	ldbu	r3,-28(fp)
 321bc78:	e0bffc17 	ldw	r2,-16(fp)
 321bc7c:	1885883a 	add	r2,r3,r2
 321bc80:	10800204 	addi	r2,r2,8
 321bc84:	108000c3 	ldbu	r2,3(r2)
 321bc88:	10803fcc 	andi	r2,r2,255
 321bc8c:	1004c03a 	cmpne	r2,r2,zero
 321bc90:	1000091e 	bne	r2,zero,321bcb8 <OSTaskChangePrio+0x47c>
                pevent->OSEventGrp    &= ~bity_old;
 321bc94:	e0bffc17 	ldw	r2,-16(fp)
 321bc98:	10800283 	ldbu	r2,10(r2)
 321bc9c:	1007883a 	mov	r3,r2
 321bca0:	e0bff843 	ldbu	r2,-31(fp)
 321bca4:	0084303a 	nor	r2,zero,r2
 321bca8:	1884703a 	and	r2,r3,r2
 321bcac:	1007883a 	mov	r3,r2
 321bcb0:	e0bffc17 	ldw	r2,-16(fp)
 321bcb4:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
 321bcb8:	e0bffc17 	ldw	r2,-16(fp)
 321bcbc:	10c00283 	ldbu	r3,10(r2)
 321bcc0:	e0bff8c3 	ldbu	r2,-29(fp)
 321bcc4:	1884b03a 	or	r2,r3,r2
 321bcc8:	1007883a 	mov	r3,r2
 321bccc:	e0bffc17 	ldw	r2,-16(fp)
 321bcd0:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
 321bcd4:	e13ff983 	ldbu	r4,-26(fp)
 321bcd8:	e0fff983 	ldbu	r3,-26(fp)
 321bcdc:	e0bffc17 	ldw	r2,-16(fp)
 321bce0:	1885883a 	add	r2,r3,r2
 321bce4:	10800204 	addi	r2,r2,8
 321bce8:	10c000c3 	ldbu	r3,3(r2)
 321bcec:	e0bff883 	ldbu	r2,-30(fp)
 321bcf0:	1884b03a 	or	r2,r3,r2
 321bcf4:	1007883a 	mov	r3,r2
 321bcf8:	e0bffc17 	ldw	r2,-16(fp)
 321bcfc:	2085883a 	add	r2,r4,r2
 321bd00:	10800204 	addi	r2,r2,8
 321bd04:	10c000c5 	stb	r3,3(r2)
            pevents++;
 321bd08:	e0bffb17 	ldw	r2,-20(fp)
 321bd0c:	10800104 	addi	r2,r2,4
 321bd10:	e0bffb15 	stw	r2,-20(fp)
            pevent                     = *pevents;
 321bd14:	e0bffb17 	ldw	r2,-20(fp)
 321bd18:	10800017 	ldw	r2,0(r2)
 321bd1c:	e0bffc15 	stw	r2,-16(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
 321bd20:	e0bffc17 	ldw	r2,-16(fp)
 321bd24:	1004c03a 	cmpne	r2,r2,zero
 321bd28:	103fc31e 	bne	r2,zero,321bc38 <OSTaskChangePrio+0x3fc>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
 321bd2c:	e0fffa17 	ldw	r3,-24(fp)
 321bd30:	e0bffe03 	ldbu	r2,-8(fp)
 321bd34:	18800c85 	stb	r2,50(r3)
    ptcb->OSTCBY    = y_new;
 321bd38:	e0fffa17 	ldw	r3,-24(fp)
 321bd3c:	e0bff983 	ldbu	r2,-26(fp)
 321bd40:	18800d05 	stb	r2,52(r3)
    ptcb->OSTCBX    = x_new;
 321bd44:	e0fffa17 	ldw	r3,-24(fp)
 321bd48:	e0bff943 	ldbu	r2,-27(fp)
 321bd4c:	18800cc5 	stb	r2,51(r3)
    ptcb->OSTCBBitY = bity_new;
 321bd50:	e0fffa17 	ldw	r3,-24(fp)
 321bd54:	e0bff8c3 	ldbu	r2,-29(fp)
 321bd58:	18800d85 	stb	r2,54(r3)
    ptcb->OSTCBBitX = bitx_new;
 321bd5c:	e0fffa17 	ldw	r3,-24(fp)
 321bd60:	e0bff883 	ldbu	r2,-30(fp)
 321bd64:	18800d45 	stb	r2,53(r3)
 321bd68:	e0bff717 	ldw	r2,-36(fp)
 321bd6c:	e0bff215 	stw	r2,-56(fp)
 321bd70:	e0bff217 	ldw	r2,-56(fp)
 321bd74:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 321bd78:	0080c974 	movhi	r2,805
 321bd7c:	10930644 	addi	r2,r2,19481
 321bd80:	10800003 	ldbu	r2,0(r2)
 321bd84:	10803fcc 	andi	r2,r2,255
 321bd88:	10800058 	cmpnei	r2,r2,1
 321bd8c:	1000011e 	bne	r2,zero,321bd94 <OSTaskChangePrio+0x558>
        OS_Sched();                                         /* Find new highest priority task          */
 321bd90:	3216f880 	call	3216f88 <OS_Sched>
    }
    return (OS_ERR_NONE);
 321bd94:	e03fff15 	stw	zero,-4(fp)
 321bd98:	e0bfff17 	ldw	r2,-4(fp)
}
 321bd9c:	e037883a 	mov	sp,fp
 321bda0:	dfc00117 	ldw	ra,4(sp)
 321bda4:	df000017 	ldw	fp,0(sp)
 321bda8:	dec00204 	addi	sp,sp,8
 321bdac:	f800283a 	ret

0321bdb0 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
 321bdb0:	deffed04 	addi	sp,sp,-76
 321bdb4:	dfc01215 	stw	ra,72(sp)
 321bdb8:	df001115 	stw	fp,68(sp)
 321bdbc:	df001104 	addi	fp,sp,68
 321bdc0:	e13ffb15 	stw	r4,-20(fp)
 321bdc4:	e17ffc15 	stw	r5,-16(fp)
 321bdc8:	e1bffd15 	stw	r6,-12(fp)
 321bdcc:	e1fffe05 	stb	r7,-8(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 321bdd0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 321bdd4:	e0bffe03 	ldbu	r2,-8(fp)
 321bdd8:	10800570 	cmpltui	r2,r2,21
 321bddc:	1000031e 	bne	r2,zero,321bdec <OSTaskCreate+0x3c>
        return (OS_ERR_PRIO_INVALID);
 321bde0:	00800a84 	movi	r2,42
 321bde4:	e0bfff15 	stw	r2,-4(fp)
 321bde8:	00006006 	br	321bf6c <OSTaskCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321bdec:	0005303a 	rdctl	r2,status
 321bdf0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321bdf4:	e0fff717 	ldw	r3,-36(fp)
 321bdf8:	00bfff84 	movi	r2,-2
 321bdfc:	1884703a 	and	r2,r3,r2
 321be00:	1001703a 	wrctl	status,r2
  
  return context;
 321be04:	e0bff717 	ldw	r2,-36(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 321be08:	e0bff815 	stw	r2,-32(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 321be0c:	0080c974 	movhi	r2,805
 321be10:	10931404 	addi	r2,r2,19536
 321be14:	10800003 	ldbu	r2,0(r2)
 321be18:	10803fcc 	andi	r2,r2,255
 321be1c:	1005003a 	cmpeq	r2,r2,zero
 321be20:	1000071e 	bne	r2,zero,321be40 <OSTaskCreate+0x90>
 321be24:	e0bff817 	ldw	r2,-32(fp)
 321be28:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321be2c:	e0bff617 	ldw	r2,-40(fp)
 321be30:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 321be34:	00800f04 	movi	r2,60
 321be38:	e0bfff15 	stw	r2,-4(fp)
 321be3c:	00004b06 	br	321bf6c <OSTaskCreate+0x1bc>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 321be40:	e0bffe03 	ldbu	r2,-8(fp)
 321be44:	00c0c9b4 	movhi	r3,806
 321be48:	18f26b04 	addi	r3,r3,-13908
 321be4c:	1085883a 	add	r2,r2,r2
 321be50:	1085883a 	add	r2,r2,r2
 321be54:	10c5883a 	add	r2,r2,r3
 321be58:	10800017 	ldw	r2,0(r2)
 321be5c:	1004c03a 	cmpne	r2,r2,zero
 321be60:	10003c1e 	bne	r2,zero,321bf54 <OSTaskCreate+0x1a4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 321be64:	e0bffe03 	ldbu	r2,-8(fp)
 321be68:	00c0c9b4 	movhi	r3,806
 321be6c:	18f26b04 	addi	r3,r3,-13908
 321be70:	1085883a 	add	r2,r2,r2
 321be74:	1085883a 	add	r2,r2,r2
 321be78:	10c7883a 	add	r3,r2,r3
 321be7c:	00800044 	movi	r2,1
 321be80:	18800015 	stw	r2,0(r3)
 321be84:	e0bff817 	ldw	r2,-32(fp)
 321be88:	e0bff515 	stw	r2,-44(fp)
 321be8c:	e0bff517 	ldw	r2,-44(fp)
 321be90:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
 321be94:	e13ffb17 	ldw	r4,-20(fp)
 321be98:	e17ffc17 	ldw	r5,-16(fp)
 321be9c:	e1bffd17 	ldw	r6,-12(fp)
 321bea0:	000f883a 	mov	r7,zero
 321bea4:	323b5540 	call	323b554 <OSTaskStkInit>
 321bea8:	e0bffa15 	stw	r2,-24(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
 321beac:	e13ffe03 	ldbu	r4,-8(fp)
 321beb0:	d8000015 	stw	zero,0(sp)
 321beb4:	d8000115 	stw	zero,4(sp)
 321beb8:	d8000215 	stw	zero,8(sp)
 321bebc:	e17ffa17 	ldw	r5,-24(fp)
 321bec0:	000d883a 	mov	r6,zero
 321bec4:	000f883a 	mov	r7,zero
 321bec8:	32173900 	call	3217390 <OS_TCBInit>
 321becc:	e0bff905 	stb	r2,-28(fp)
        if (err == OS_ERR_NONE) {
 321bed0:	e0bff903 	ldbu	r2,-28(fp)
 321bed4:	1004c03a 	cmpne	r2,r2,zero
 321bed8:	1000081e 	bne	r2,zero,321befc <OSTaskCreate+0x14c>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
 321bedc:	0080c974 	movhi	r2,805
 321bee0:	10930644 	addi	r2,r2,19481
 321bee4:	10800003 	ldbu	r2,0(r2)
 321bee8:	10803fcc 	andi	r2,r2,255
 321beec:	10800058 	cmpnei	r2,r2,1
 321bef0:	1000151e 	bne	r2,zero,321bf48 <OSTaskCreate+0x198>
                OS_Sched();
 321bef4:	3216f880 	call	3216f88 <OS_Sched>
 321bef8:	00001306 	br	321bf48 <OSTaskCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321befc:	0005303a 	rdctl	r2,status
 321bf00:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321bf04:	e0fff417 	ldw	r3,-48(fp)
 321bf08:	00bfff84 	movi	r2,-2
 321bf0c:	1884703a 	and	r2,r3,r2
 321bf10:	1001703a 	wrctl	status,r2
  
  return context;
 321bf14:	e0bff417 	ldw	r2,-48(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 321bf18:	e0bff815 	stw	r2,-32(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
 321bf1c:	e0bffe03 	ldbu	r2,-8(fp)
 321bf20:	00c0c9b4 	movhi	r3,806
 321bf24:	18f26b04 	addi	r3,r3,-13908
 321bf28:	1085883a 	add	r2,r2,r2
 321bf2c:	1085883a 	add	r2,r2,r2
 321bf30:	10c5883a 	add	r2,r2,r3
 321bf34:	10000015 	stw	zero,0(r2)
 321bf38:	e0bff817 	ldw	r2,-32(fp)
 321bf3c:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321bf40:	e0bff317 	ldw	r2,-52(fp)
 321bf44:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 321bf48:	e0bff903 	ldbu	r2,-28(fp)
 321bf4c:	e0bfff15 	stw	r2,-4(fp)
 321bf50:	00000606 	br	321bf6c <OSTaskCreate+0x1bc>
 321bf54:	e0bff817 	ldw	r2,-32(fp)
 321bf58:	e0bff215 	stw	r2,-56(fp)
 321bf5c:	e0bff217 	ldw	r2,-56(fp)
 321bf60:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 321bf64:	00800a04 	movi	r2,40
 321bf68:	e0bfff15 	stw	r2,-4(fp)
 321bf6c:	e0bfff17 	ldw	r2,-4(fp)
}
 321bf70:	e037883a 	mov	sp,fp
 321bf74:	dfc00117 	ldw	ra,4(sp)
 321bf78:	df000017 	ldw	fp,0(sp)
 321bf7c:	dec00204 	addi	sp,sp,8
 321bf80:	f800283a 	ret

0321bf84 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
 321bf84:	deffeb04 	addi	sp,sp,-84
 321bf88:	dfc01415 	stw	ra,80(sp)
 321bf8c:	df001315 	stw	fp,76(sp)
 321bf90:	df001304 	addi	fp,sp,76
 321bf94:	e13ff915 	stw	r4,-28(fp)
 321bf98:	e17ffa15 	stw	r5,-24(fp)
 321bf9c:	e1bffb15 	stw	r6,-20(fp)
 321bfa0:	e0800217 	ldw	r2,8(fp)
 321bfa4:	e0c00617 	ldw	r3,24(fp)
 321bfa8:	e1fffc05 	stb	r7,-16(fp)
 321bfac:	e0bffd0d 	sth	r2,-12(fp)
 321bfb0:	e0fffe0d 	sth	r3,-8(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 321bfb4:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 321bfb8:	e0bffc03 	ldbu	r2,-16(fp)
 321bfbc:	10800570 	cmpltui	r2,r2,21
 321bfc0:	1000031e 	bne	r2,zero,321bfd0 <OSTaskCreateExt+0x4c>
        return (OS_ERR_PRIO_INVALID);
 321bfc4:	00800a84 	movi	r2,42
 321bfc8:	e0bfff15 	stw	r2,-4(fp)
 321bfcc:	00006706 	br	321c16c <OSTaskCreateExt+0x1e8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321bfd0:	0005303a 	rdctl	r2,status
 321bfd4:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321bfd8:	e0fff517 	ldw	r3,-44(fp)
 321bfdc:	00bfff84 	movi	r2,-2
 321bfe0:	1884703a 	and	r2,r3,r2
 321bfe4:	1001703a 	wrctl	status,r2
  
  return context;
 321bfe8:	e0bff517 	ldw	r2,-44(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 321bfec:	e0bff615 	stw	r2,-40(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 321bff0:	0080c974 	movhi	r2,805
 321bff4:	10931404 	addi	r2,r2,19536
 321bff8:	10800003 	ldbu	r2,0(r2)
 321bffc:	10803fcc 	andi	r2,r2,255
 321c000:	1005003a 	cmpeq	r2,r2,zero
 321c004:	1000071e 	bne	r2,zero,321c024 <OSTaskCreateExt+0xa0>
 321c008:	e0bff617 	ldw	r2,-40(fp)
 321c00c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321c010:	e0bff417 	ldw	r2,-48(fp)
 321c014:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 321c018:	00800f04 	movi	r2,60
 321c01c:	e0bfff15 	stw	r2,-4(fp)
 321c020:	00005206 	br	321c16c <OSTaskCreateExt+0x1e8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 321c024:	e0bffc03 	ldbu	r2,-16(fp)
 321c028:	00c0c9b4 	movhi	r3,806
 321c02c:	18f26b04 	addi	r3,r3,-13908
 321c030:	1085883a 	add	r2,r2,r2
 321c034:	1085883a 	add	r2,r2,r2
 321c038:	10c5883a 	add	r2,r2,r3
 321c03c:	10800017 	ldw	r2,0(r2)
 321c040:	1004c03a 	cmpne	r2,r2,zero
 321c044:	1000431e 	bne	r2,zero,321c154 <OSTaskCreateExt+0x1d0>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 321c048:	e0bffc03 	ldbu	r2,-16(fp)
 321c04c:	00c0c9b4 	movhi	r3,806
 321c050:	18f26b04 	addi	r3,r3,-13908
 321c054:	1085883a 	add	r2,r2,r2
 321c058:	1085883a 	add	r2,r2,r2
 321c05c:	10c7883a 	add	r3,r2,r3
 321c060:	00800044 	movi	r2,1
 321c064:	18800015 	stw	r2,0(r3)
 321c068:	e0bff617 	ldw	r2,-40(fp)
 321c06c:	e0bff315 	stw	r2,-52(fp)
 321c070:	e0bff317 	ldw	r2,-52(fp)
 321c074:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
 321c078:	e1bffe0b 	ldhu	r6,-8(fp)
 321c07c:	e1000317 	ldw	r4,12(fp)
 321c080:	e1400417 	ldw	r5,16(fp)
 321c084:	321d2000 	call	321d200 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
 321c088:	e1fffe0b 	ldhu	r7,-8(fp)
 321c08c:	e13ff917 	ldw	r4,-28(fp)
 321c090:	e17ffa17 	ldw	r5,-24(fp)
 321c094:	e1bffb17 	ldw	r6,-20(fp)
 321c098:	323b5540 	call	323b554 <OSTaskStkInit>
 321c09c:	e0bff815 	stw	r2,-32(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
 321c0a0:	e13ffc03 	ldbu	r4,-16(fp)
 321c0a4:	e1fffd0b 	ldhu	r7,-12(fp)
 321c0a8:	e0fffe0b 	ldhu	r3,-8(fp)
 321c0ac:	e0800417 	ldw	r2,16(fp)
 321c0b0:	d8800015 	stw	r2,0(sp)
 321c0b4:	e0800517 	ldw	r2,20(fp)
 321c0b8:	d8800115 	stw	r2,4(sp)
 321c0bc:	d8c00215 	stw	r3,8(sp)
 321c0c0:	e17ff817 	ldw	r5,-32(fp)
 321c0c4:	e1800317 	ldw	r6,12(fp)
 321c0c8:	32173900 	call	3217390 <OS_TCBInit>
 321c0cc:	e0bff705 	stb	r2,-36(fp)
        if (err == OS_ERR_NONE) {
 321c0d0:	e0bff703 	ldbu	r2,-36(fp)
 321c0d4:	1004c03a 	cmpne	r2,r2,zero
 321c0d8:	1000081e 	bne	r2,zero,321c0fc <OSTaskCreateExt+0x178>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
 321c0dc:	0080c974 	movhi	r2,805
 321c0e0:	10930644 	addi	r2,r2,19481
 321c0e4:	10800003 	ldbu	r2,0(r2)
 321c0e8:	10803fcc 	andi	r2,r2,255
 321c0ec:	10800058 	cmpnei	r2,r2,1
 321c0f0:	1000151e 	bne	r2,zero,321c148 <OSTaskCreateExt+0x1c4>
                OS_Sched();
 321c0f4:	3216f880 	call	3216f88 <OS_Sched>
 321c0f8:	00001306 	br	321c148 <OSTaskCreateExt+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321c0fc:	0005303a 	rdctl	r2,status
 321c100:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321c104:	e0fff217 	ldw	r3,-56(fp)
 321c108:	00bfff84 	movi	r2,-2
 321c10c:	1884703a 	and	r2,r3,r2
 321c110:	1001703a 	wrctl	status,r2
  
  return context;
 321c114:	e0bff217 	ldw	r2,-56(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 321c118:	e0bff615 	stw	r2,-40(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
 321c11c:	e0bffc03 	ldbu	r2,-16(fp)
 321c120:	00c0c9b4 	movhi	r3,806
 321c124:	18f26b04 	addi	r3,r3,-13908
 321c128:	1085883a 	add	r2,r2,r2
 321c12c:	1085883a 	add	r2,r2,r2
 321c130:	10c5883a 	add	r2,r2,r3
 321c134:	10000015 	stw	zero,0(r2)
 321c138:	e0bff617 	ldw	r2,-40(fp)
 321c13c:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321c140:	e0bff117 	ldw	r2,-60(fp)
 321c144:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 321c148:	e0bff703 	ldbu	r2,-36(fp)
 321c14c:	e0bfff15 	stw	r2,-4(fp)
 321c150:	00000606 	br	321c16c <OSTaskCreateExt+0x1e8>
 321c154:	e0bff617 	ldw	r2,-40(fp)
 321c158:	e0bff015 	stw	r2,-64(fp)
 321c15c:	e0bff017 	ldw	r2,-64(fp)
 321c160:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 321c164:	00800a04 	movi	r2,40
 321c168:	e0bfff15 	stw	r2,-4(fp)
 321c16c:	e0bfff17 	ldw	r2,-4(fp)
}
 321c170:	e037883a 	mov	sp,fp
 321c174:	dfc00117 	ldw	ra,4(sp)
 321c178:	df000017 	ldw	fp,0(sp)
 321c17c:	dec00204 	addi	sp,sp,8
 321c180:	f800283a 	ret

0321c184 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
 321c184:	defff304 	addi	sp,sp,-52
 321c188:	dfc00c15 	stw	ra,48(sp)
 321c18c:	df000b15 	stw	fp,44(sp)
 321c190:	df000b04 	addi	fp,sp,44
 321c194:	e13ffe05 	stb	r4,-8(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
 321c198:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
 321c19c:	0080c974 	movhi	r2,805
 321c1a0:	10931404 	addi	r2,r2,19536
 321c1a4:	10800003 	ldbu	r2,0(r2)
 321c1a8:	10803fcc 	andi	r2,r2,255
 321c1ac:	1005003a 	cmpeq	r2,r2,zero
 321c1b0:	1000031e 	bne	r2,zero,321c1c0 <OSTaskDel+0x3c>
        return (OS_ERR_TASK_DEL_ISR);
 321c1b4:	00801004 	movi	r2,64
 321c1b8:	e0bfff15 	stw	r2,-4(fp)
 321c1bc:	0000ee06 	br	321c578 <OSTaskDel+0x3f4>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
 321c1c0:	e0bffe03 	ldbu	r2,-8(fp)
 321c1c4:	10800518 	cmpnei	r2,r2,20
 321c1c8:	1000031e 	bne	r2,zero,321c1d8 <OSTaskDel+0x54>
        return (OS_ERR_TASK_DEL_IDLE);
 321c1cc:	00800f84 	movi	r2,62
 321c1d0:	e0bfff15 	stw	r2,-4(fp)
 321c1d4:	0000e806 	br	321c578 <OSTaskDel+0x3f4>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
 321c1d8:	e0bffe03 	ldbu	r2,-8(fp)
 321c1dc:	10800530 	cmpltui	r2,r2,20
 321c1e0:	1000061e 	bne	r2,zero,321c1fc <OSTaskDel+0x78>
        if (prio != OS_PRIO_SELF) {
 321c1e4:	e0bffe03 	ldbu	r2,-8(fp)
 321c1e8:	10803fe0 	cmpeqi	r2,r2,255
 321c1ec:	1000031e 	bne	r2,zero,321c1fc <OSTaskDel+0x78>
            return (OS_ERR_PRIO_INVALID);
 321c1f0:	00800a84 	movi	r2,42
 321c1f4:	e0bfff15 	stw	r2,-4(fp)
 321c1f8:	0000df06 	br	321c578 <OSTaskDel+0x3f4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321c1fc:	0005303a 	rdctl	r2,status
 321c200:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321c204:	e0fffa17 	ldw	r3,-24(fp)
 321c208:	00bfff84 	movi	r2,-2
 321c20c:	1884703a 	and	r2,r3,r2
 321c210:	1001703a 	wrctl	status,r2
  
  return context;
 321c214:	e0bffa17 	ldw	r2,-24(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
 321c218:	e0bffb15 	stw	r2,-20(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
 321c21c:	e0bffe03 	ldbu	r2,-8(fp)
 321c220:	10803fd8 	cmpnei	r2,r2,255
 321c224:	1000051e 	bne	r2,zero,321c23c <OSTaskDel+0xb8>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
 321c228:	0080c974 	movhi	r2,805
 321c22c:	10931504 	addi	r2,r2,19540
 321c230:	10800017 	ldw	r2,0(r2)
 321c234:	10800c83 	ldbu	r2,50(r2)
 321c238:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 321c23c:	e0bffe03 	ldbu	r2,-8(fp)
 321c240:	00c0c9b4 	movhi	r3,806
 321c244:	18f26b04 	addi	r3,r3,-13908
 321c248:	1085883a 	add	r2,r2,r2
 321c24c:	1085883a 	add	r2,r2,r2
 321c250:	10c5883a 	add	r2,r2,r3
 321c254:	10800017 	ldw	r2,0(r2)
 321c258:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
 321c25c:	e0bffc17 	ldw	r2,-16(fp)
 321c260:	1004c03a 	cmpne	r2,r2,zero
 321c264:	1000071e 	bne	r2,zero,321c284 <OSTaskDel+0x100>
 321c268:	e0bffb17 	ldw	r2,-20(fp)
 321c26c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321c270:	e0bff917 	ldw	r2,-28(fp)
 321c274:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 321c278:	008010c4 	movi	r2,67
 321c27c:	e0bfff15 	stw	r2,-4(fp)
 321c280:	0000bd06 	br	321c578 <OSTaskDel+0x3f4>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
 321c284:	e0bffc17 	ldw	r2,-16(fp)
 321c288:	10800058 	cmpnei	r2,r2,1
 321c28c:	1000071e 	bne	r2,zero,321c2ac <OSTaskDel+0x128>
 321c290:	e0bffb17 	ldw	r2,-20(fp)
 321c294:	e0bff815 	stw	r2,-32(fp)
 321c298:	e0bff817 	ldw	r2,-32(fp)
 321c29c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 321c2a0:	00800f44 	movi	r2,61
 321c2a4:	e0bfff15 	stw	r2,-4(fp)
 321c2a8:	0000b306 	br	321c578 <OSTaskDel+0x3f4>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
 321c2ac:	e0bffc17 	ldw	r2,-16(fp)
 321c2b0:	10800d03 	ldbu	r2,52(r2)
 321c2b4:	11003fcc 	andi	r4,r2,255
 321c2b8:	e0bffc17 	ldw	r2,-16(fp)
 321c2bc:	10800d03 	ldbu	r2,52(r2)
 321c2c0:	10c03fcc 	andi	r3,r2,255
 321c2c4:	0080c974 	movhi	r2,805
 321c2c8:	10931244 	addi	r2,r2,19529
 321c2cc:	10c5883a 	add	r2,r2,r3
 321c2d0:	10800003 	ldbu	r2,0(r2)
 321c2d4:	1007883a 	mov	r3,r2
 321c2d8:	e0bffc17 	ldw	r2,-16(fp)
 321c2dc:	10800d43 	ldbu	r2,53(r2)
 321c2e0:	0084303a 	nor	r2,zero,r2
 321c2e4:	1884703a 	and	r2,r3,r2
 321c2e8:	1007883a 	mov	r3,r2
 321c2ec:	0080c974 	movhi	r2,805
 321c2f0:	10931244 	addi	r2,r2,19529
 321c2f4:	1105883a 	add	r2,r2,r4
 321c2f8:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
 321c2fc:	e0bffc17 	ldw	r2,-16(fp)
 321c300:	10800d03 	ldbu	r2,52(r2)
 321c304:	10c03fcc 	andi	r3,r2,255
 321c308:	0080c974 	movhi	r2,805
 321c30c:	10931244 	addi	r2,r2,19529
 321c310:	10c5883a 	add	r2,r2,r3
 321c314:	10800003 	ldbu	r2,0(r2)
 321c318:	10803fcc 	andi	r2,r2,255
 321c31c:	1004c03a 	cmpne	r2,r2,zero
 321c320:	10000c1e 	bne	r2,zero,321c354 <OSTaskDel+0x1d0>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
 321c324:	e0bffc17 	ldw	r2,-16(fp)
 321c328:	10800d83 	ldbu	r2,54(r2)
 321c32c:	0084303a 	nor	r2,zero,r2
 321c330:	1007883a 	mov	r3,r2
 321c334:	0080c974 	movhi	r2,805
 321c338:	10931204 	addi	r2,r2,19528
 321c33c:	10800003 	ldbu	r2,0(r2)
 321c340:	1884703a 	and	r2,r3,r2
 321c344:	1007883a 	mov	r3,r2
 321c348:	0080c974 	movhi	r2,805
 321c34c:	10931204 	addi	r2,r2,19528
 321c350:	10c00005 	stb	r3,0(r2)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
 321c354:	e0bffc17 	ldw	r2,-16(fp)
 321c358:	10800717 	ldw	r2,28(r2)
 321c35c:	1005003a 	cmpeq	r2,r2,zero
 321c360:	1000041e 	bne	r2,zero,321c374 <OSTaskDel+0x1f0>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
 321c364:	e0bffc17 	ldw	r2,-16(fp)
 321c368:	11400717 	ldw	r5,28(r2)
 321c36c:	e13ffc17 	ldw	r4,-16(fp)
 321c370:	32169400 	call	3216940 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
 321c374:	e0bffc17 	ldw	r2,-16(fp)
 321c378:	10800817 	ldw	r2,32(r2)
 321c37c:	1005003a 	cmpeq	r2,r2,zero
 321c380:	1000041e 	bne	r2,zero,321c394 <OSTaskDel+0x210>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 321c384:	e0bffc17 	ldw	r2,-16(fp)
 321c388:	11400817 	ldw	r5,32(r2)
 321c38c:	e13ffc17 	ldw	r4,-16(fp)
 321c390:	32169f80 	call	32169f8 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
 321c394:	e0bffc17 	ldw	r2,-16(fp)
 321c398:	10800a17 	ldw	r2,40(r2)
 321c39c:	e0bffd15 	stw	r2,-12(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
 321c3a0:	e0bffd17 	ldw	r2,-12(fp)
 321c3a4:	1005003a 	cmpeq	r2,r2,zero
 321c3a8:	1000021e 	bne	r2,zero,321c3b4 <OSTaskDel+0x230>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
 321c3ac:	e13ffd17 	ldw	r4,-12(fp)
 321c3b0:	321908c0 	call	321908c <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
 321c3b4:	e0bffc17 	ldw	r2,-16(fp)
 321c3b8:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
 321c3bc:	e0bffc17 	ldw	r2,-16(fp)
 321c3c0:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 321c3c4:	e0bffc17 	ldw	r2,-16(fp)
 321c3c8:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
 321c3cc:	0080c974 	movhi	r2,805
 321c3d0:	10930604 	addi	r2,r2,19480
 321c3d4:	10800003 	ldbu	r2,0(r2)
 321c3d8:	10803fcc 	andi	r2,r2,255
 321c3dc:	10803fe0 	cmpeqi	r2,r2,255
 321c3e0:	1000081e 	bne	r2,zero,321c404 <OSTaskDel+0x280>
        OSLockNesting++;
 321c3e4:	0080c974 	movhi	r2,805
 321c3e8:	10930604 	addi	r2,r2,19480
 321c3ec:	10800003 	ldbu	r2,0(r2)
 321c3f0:	10800044 	addi	r2,r2,1
 321c3f4:	1007883a 	mov	r3,r2
 321c3f8:	0080c974 	movhi	r2,805
 321c3fc:	10930604 	addi	r2,r2,19480
 321c400:	10c00005 	stb	r3,0(r2)
 321c404:	e0bffb17 	ldw	r2,-20(fp)
 321c408:	e0bff715 	stw	r2,-36(fp)
 321c40c:	e0bff717 	ldw	r2,-36(fp)
 321c410:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
 321c414:	321652c0 	call	321652c <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321c418:	0005303a 	rdctl	r2,status
 321c41c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321c420:	e0fff617 	ldw	r3,-40(fp)
 321c424:	00bfff84 	movi	r2,-2
 321c428:	1884703a 	and	r2,r3,r2
 321c42c:	1001703a 	wrctl	status,r2
  
  return context;
 321c430:	e0bff617 	ldw	r2,-40(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
 321c434:	e0bffb15 	stw	r2,-20(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
 321c438:	0080c974 	movhi	r2,805
 321c43c:	10930604 	addi	r2,r2,19480
 321c440:	10800003 	ldbu	r2,0(r2)
 321c444:	10803fcc 	andi	r2,r2,255
 321c448:	1005003a 	cmpeq	r2,r2,zero
 321c44c:	1000081e 	bne	r2,zero,321c470 <OSTaskDel+0x2ec>
        OSLockNesting--;
 321c450:	0080c974 	movhi	r2,805
 321c454:	10930604 	addi	r2,r2,19480
 321c458:	10800003 	ldbu	r2,0(r2)
 321c45c:	10bfffc4 	addi	r2,r2,-1
 321c460:	1007883a 	mov	r3,r2
 321c464:	0080c974 	movhi	r2,805
 321c468:	10930604 	addi	r2,r2,19480
 321c46c:	10c00005 	stb	r3,0(r2)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
 321c470:	e13ffc17 	ldw	r4,-16(fp)
 321c474:	323b8840 	call	323b884 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
 321c478:	0080c974 	movhi	r2,805
 321c47c:	10930e44 	addi	r2,r2,19513
 321c480:	10800003 	ldbu	r2,0(r2)
 321c484:	10bfffc4 	addi	r2,r2,-1
 321c488:	1007883a 	mov	r3,r2
 321c48c:	0080c974 	movhi	r2,805
 321c490:	10930e44 	addi	r2,r2,19513
 321c494:	10c00005 	stb	r3,0(r2)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
 321c498:	e0bffe03 	ldbu	r2,-8(fp)
 321c49c:	00c0c9b4 	movhi	r3,806
 321c4a0:	18f26b04 	addi	r3,r3,-13908
 321c4a4:	1085883a 	add	r2,r2,r2
 321c4a8:	1085883a 	add	r2,r2,r2
 321c4ac:	10c5883a 	add	r2,r2,r3
 321c4b0:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
 321c4b4:	e0bffc17 	ldw	r2,-16(fp)
 321c4b8:	10800617 	ldw	r2,24(r2)
 321c4bc:	1004c03a 	cmpne	r2,r2,zero
 321c4c0:	1000091e 	bne	r2,zero,321c4e8 <OSTaskDel+0x364>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
 321c4c4:	e0bffc17 	ldw	r2,-16(fp)
 321c4c8:	10800517 	ldw	r2,20(r2)
 321c4cc:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
 321c4d0:	e0bffc17 	ldw	r2,-16(fp)
 321c4d4:	10c00517 	ldw	r3,20(r2)
 321c4d8:	0080c974 	movhi	r2,805
 321c4dc:	10930904 	addi	r2,r2,19492
 321c4e0:	10c00015 	stw	r3,0(r2)
 321c4e4:	00000a06 	br	321c510 <OSTaskDel+0x38c>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
 321c4e8:	e0bffc17 	ldw	r2,-16(fp)
 321c4ec:	10c00617 	ldw	r3,24(r2)
 321c4f0:	e0bffc17 	ldw	r2,-16(fp)
 321c4f4:	10800517 	ldw	r2,20(r2)
 321c4f8:	18800515 	stw	r2,20(r3)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
 321c4fc:	e0bffc17 	ldw	r2,-16(fp)
 321c500:	10c00517 	ldw	r3,20(r2)
 321c504:	e0bffc17 	ldw	r2,-16(fp)
 321c508:	10800617 	ldw	r2,24(r2)
 321c50c:	18800615 	stw	r2,24(r3)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
 321c510:	0080c974 	movhi	r2,805
 321c514:	10930d04 	addi	r2,r2,19508
 321c518:	10c00017 	ldw	r3,0(r2)
 321c51c:	e0bffc17 	ldw	r2,-16(fp)
 321c520:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
 321c524:	00c0c974 	movhi	r3,805
 321c528:	18d30d04 	addi	r3,r3,19508
 321c52c:	e0bffc17 	ldw	r2,-16(fp)
 321c530:	18800015 	stw	r2,0(r3)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
 321c534:	e0fffc17 	ldw	r3,-16(fp)
 321c538:	00800fc4 	movi	r2,63
 321c53c:	18801305 	stb	r2,76(r3)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 321c540:	e0bffc17 	ldw	r2,-16(fp)
 321c544:	10001345 	stb	zero,77(r2)
 321c548:	e0bffb17 	ldw	r2,-20(fp)
 321c54c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321c550:	e0bff517 	ldw	r2,-44(fp)
 321c554:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 321c558:	0080c974 	movhi	r2,805
 321c55c:	10930644 	addi	r2,r2,19481
 321c560:	10800003 	ldbu	r2,0(r2)
 321c564:	10803fcc 	andi	r2,r2,255
 321c568:	10800058 	cmpnei	r2,r2,1
 321c56c:	1000011e 	bne	r2,zero,321c574 <OSTaskDel+0x3f0>
        OS_Sched();                                     /* Find new highest priority task              */
 321c570:	3216f880 	call	3216f88 <OS_Sched>
    }
    return (OS_ERR_NONE);
 321c574:	e03fff15 	stw	zero,-4(fp)
 321c578:	e0bfff17 	ldw	r2,-4(fp)
}
 321c57c:	e037883a 	mov	sp,fp
 321c580:	dfc00117 	ldw	ra,4(sp)
 321c584:	df000017 	ldw	fp,0(sp)
 321c588:	dec00204 	addi	sp,sp,8
 321c58c:	f800283a 	ret

0321c590 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
 321c590:	defff404 	addi	sp,sp,-48
 321c594:	df000b15 	stw	fp,44(sp)
 321c598:	df000b04 	addi	fp,sp,44
 321c59c:	e13ffe05 	stb	r4,-8(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 321c5a0:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
 321c5a4:	e0bffe03 	ldbu	r2,-8(fp)
 321c5a8:	10800518 	cmpnei	r2,r2,20
 321c5ac:	1000031e 	bne	r2,zero,321c5bc <OSTaskDelReq+0x2c>
        return (OS_ERR_TASK_DEL_IDLE);
 321c5b0:	00800f84 	movi	r2,62
 321c5b4:	e0bfff15 	stw	r2,-4(fp)
 321c5b8:	00004c06 	br	321c6ec <OSTaskDelReq+0x15c>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 321c5bc:	e0bffe03 	ldbu	r2,-8(fp)
 321c5c0:	10800530 	cmpltui	r2,r2,20
 321c5c4:	1000061e 	bne	r2,zero,321c5e0 <OSTaskDelReq+0x50>
        if (prio != OS_PRIO_SELF) {
 321c5c8:	e0bffe03 	ldbu	r2,-8(fp)
 321c5cc:	10803fe0 	cmpeqi	r2,r2,255
 321c5d0:	1000031e 	bne	r2,zero,321c5e0 <OSTaskDelReq+0x50>
            return (OS_ERR_PRIO_INVALID);
 321c5d4:	00800a84 	movi	r2,42
 321c5d8:	e0bfff15 	stw	r2,-4(fp)
 321c5dc:	00004306 	br	321c6ec <OSTaskDelReq+0x15c>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
 321c5e0:	e0bffe03 	ldbu	r2,-8(fp)
 321c5e4:	10803fd8 	cmpnei	r2,r2,255
 321c5e8:	1000141e 	bne	r2,zero,321c63c <OSTaskDelReq+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321c5ec:	0005303a 	rdctl	r2,status
 321c5f0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321c5f4:	e0fffa17 	ldw	r3,-24(fp)
 321c5f8:	00bfff84 	movi	r2,-2
 321c5fc:	1884703a 	and	r2,r3,r2
 321c600:	1001703a 	wrctl	status,r2
  
  return context;
 321c604:	e0bffa17 	ldw	r2,-24(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
 321c608:	e0bffb15 	stw	r2,-20(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
 321c60c:	0080c974 	movhi	r2,805
 321c610:	10931504 	addi	r2,r2,19540
 321c614:	10800017 	ldw	r2,0(r2)
 321c618:	10800dc3 	ldbu	r2,55(r2)
 321c61c:	e0bffd05 	stb	r2,-12(fp)
 321c620:	e0bffb17 	ldw	r2,-20(fp)
 321c624:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321c628:	e0bff917 	ldw	r2,-28(fp)
 321c62c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
 321c630:	e0bffd03 	ldbu	r2,-12(fp)
 321c634:	e0bfff15 	stw	r2,-4(fp)
 321c638:	00002c06 	br	321c6ec <OSTaskDelReq+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321c63c:	0005303a 	rdctl	r2,status
 321c640:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321c644:	e0fff817 	ldw	r3,-32(fp)
 321c648:	00bfff84 	movi	r2,-2
 321c64c:	1884703a 	and	r2,r3,r2
 321c650:	1001703a 	wrctl	status,r2
  
  return context;
 321c654:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 321c658:	e0bffb15 	stw	r2,-20(fp)
    ptcb = OSTCBPrioTbl[prio];
 321c65c:	e0bffe03 	ldbu	r2,-8(fp)
 321c660:	00c0c9b4 	movhi	r3,806
 321c664:	18f26b04 	addi	r3,r3,-13908
 321c668:	1085883a 	add	r2,r2,r2
 321c66c:	1085883a 	add	r2,r2,r2
 321c670:	10c5883a 	add	r2,r2,r3
 321c674:	10800017 	ldw	r2,0(r2)
 321c678:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
 321c67c:	e0bffc17 	ldw	r2,-16(fp)
 321c680:	1004c03a 	cmpne	r2,r2,zero
 321c684:	1000071e 	bne	r2,zero,321c6a4 <OSTaskDelReq+0x114>
 321c688:	e0bffb17 	ldw	r2,-20(fp)
 321c68c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321c690:	e0bff717 	ldw	r2,-36(fp)
 321c694:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
 321c698:	008010c4 	movi	r2,67
 321c69c:	e0bfff15 	stw	r2,-4(fp)
 321c6a0:	00001206 	br	321c6ec <OSTaskDelReq+0x15c>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
 321c6a4:	e0bffc17 	ldw	r2,-16(fp)
 321c6a8:	10800058 	cmpnei	r2,r2,1
 321c6ac:	1000071e 	bne	r2,zero,321c6cc <OSTaskDelReq+0x13c>
 321c6b0:	e0bffb17 	ldw	r2,-20(fp)
 321c6b4:	e0bff615 	stw	r2,-40(fp)
 321c6b8:	e0bff617 	ldw	r2,-40(fp)
 321c6bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 321c6c0:	00800f44 	movi	r2,61
 321c6c4:	e0bfff15 	stw	r2,-4(fp)
 321c6c8:	00000806 	br	321c6ec <OSTaskDelReq+0x15c>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
 321c6cc:	e0fffc17 	ldw	r3,-16(fp)
 321c6d0:	00800fc4 	movi	r2,63
 321c6d4:	18800dc5 	stb	r2,55(r3)
 321c6d8:	e0bffb17 	ldw	r2,-20(fp)
 321c6dc:	e0bff515 	stw	r2,-44(fp)
 321c6e0:	e0bff517 	ldw	r2,-44(fp)
 321c6e4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 321c6e8:	e03fff15 	stw	zero,-4(fp)
 321c6ec:	e0bfff17 	ldw	r2,-4(fp)
}
 321c6f0:	e037883a 	mov	sp,fp
 321c6f4:	df000017 	ldw	fp,0(sp)
 321c6f8:	dec00104 	addi	sp,sp,4
 321c6fc:	f800283a 	ret

0321c700 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
 321c700:	defff304 	addi	sp,sp,-52
 321c704:	dfc00c15 	stw	ra,48(sp)
 321c708:	df000b15 	stw	fp,44(sp)
 321c70c:	df000b04 	addi	fp,sp,44
 321c710:	e17ffd15 	stw	r5,-12(fp)
 321c714:	e1bffe15 	stw	r6,-8(fp)
 321c718:	e13ffc05 	stb	r4,-16(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
 321c71c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
 321c720:	e0bffe17 	ldw	r2,-8(fp)
 321c724:	1004c03a 	cmpne	r2,r2,zero
 321c728:	1000021e 	bne	r2,zero,321c734 <OSTaskNameGet+0x34>
        return (0);
 321c72c:	e03fff15 	stw	zero,-4(fp)
 321c730:	00005b06 	br	321c8a0 <OSTaskNameGet+0x1a0>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
 321c734:	e0bffc03 	ldbu	r2,-16(fp)
 321c738:	10800570 	cmpltui	r2,r2,21
 321c73c:	1000081e 	bne	r2,zero,321c760 <OSTaskNameGet+0x60>
        if (prio != OS_PRIO_SELF) {
 321c740:	e0bffc03 	ldbu	r2,-16(fp)
 321c744:	10803fe0 	cmpeqi	r2,r2,255
 321c748:	1000051e 	bne	r2,zero,321c760 <OSTaskNameGet+0x60>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
 321c74c:	e0fffe17 	ldw	r3,-8(fp)
 321c750:	00800a84 	movi	r2,42
 321c754:	18800005 	stb	r2,0(r3)
            return (0);
 321c758:	e03fff15 	stw	zero,-4(fp)
 321c75c:	00005006 	br	321c8a0 <OSTaskNameGet+0x1a0>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
 321c760:	e0bffd17 	ldw	r2,-12(fp)
 321c764:	1004c03a 	cmpne	r2,r2,zero
 321c768:	1000051e 	bne	r2,zero,321c780 <OSTaskNameGet+0x80>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
 321c76c:	e0fffe17 	ldw	r3,-8(fp)
 321c770:	00800304 	movi	r2,12
 321c774:	18800005 	stb	r2,0(r3)
        return (0);
 321c778:	e03fff15 	stw	zero,-4(fp)
 321c77c:	00004806 	br	321c8a0 <OSTaskNameGet+0x1a0>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
 321c780:	0080c974 	movhi	r2,805
 321c784:	10931404 	addi	r2,r2,19536
 321c788:	10800003 	ldbu	r2,0(r2)
 321c78c:	10803fcc 	andi	r2,r2,255
 321c790:	1005003a 	cmpeq	r2,r2,zero
 321c794:	1000051e 	bne	r2,zero,321c7ac <OSTaskNameGet+0xac>
        *perr = OS_ERR_NAME_GET_ISR;
 321c798:	e0fffe17 	ldw	r3,-8(fp)
 321c79c:	00800444 	movi	r2,17
 321c7a0:	18800005 	stb	r2,0(r3)
        return (0);
 321c7a4:	e03fff15 	stw	zero,-4(fp)
 321c7a8:	00003d06 	br	321c8a0 <OSTaskNameGet+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321c7ac:	0005303a 	rdctl	r2,status
 321c7b0:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321c7b4:	e0fff817 	ldw	r3,-32(fp)
 321c7b8:	00bfff84 	movi	r2,-2
 321c7bc:	1884703a 	and	r2,r3,r2
 321c7c0:	1001703a 	wrctl	status,r2
  
  return context;
 321c7c4:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 321c7c8:	e0bff915 	stw	r2,-28(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
 321c7cc:	e0bffc03 	ldbu	r2,-16(fp)
 321c7d0:	10803fd8 	cmpnei	r2,r2,255
 321c7d4:	1000051e 	bne	r2,zero,321c7ec <OSTaskNameGet+0xec>
        prio = OSTCBCur->OSTCBPrio;
 321c7d8:	0080c974 	movhi	r2,805
 321c7dc:	10931504 	addi	r2,r2,19540
 321c7e0:	10800017 	ldw	r2,0(r2)
 321c7e4:	10800c83 	ldbu	r2,50(r2)
 321c7e8:	e0bffc05 	stb	r2,-16(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 321c7ec:	e0bffc03 	ldbu	r2,-16(fp)
 321c7f0:	00c0c9b4 	movhi	r3,806
 321c7f4:	18f26b04 	addi	r3,r3,-13908
 321c7f8:	1085883a 	add	r2,r2,r2
 321c7fc:	1085883a 	add	r2,r2,r2
 321c800:	10c5883a 	add	r2,r2,r3
 321c804:	10800017 	ldw	r2,0(r2)
 321c808:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
 321c80c:	e0bffb17 	ldw	r2,-20(fp)
 321c810:	1004c03a 	cmpne	r2,r2,zero
 321c814:	1000091e 	bne	r2,zero,321c83c <OSTaskNameGet+0x13c>
 321c818:	e0bff917 	ldw	r2,-28(fp)
 321c81c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321c820:	e0bff717 	ldw	r2,-36(fp)
 321c824:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
 321c828:	e0fffe17 	ldw	r3,-8(fp)
 321c82c:	008010c4 	movi	r2,67
 321c830:	18800005 	stb	r2,0(r3)
        return (0);
 321c834:	e03fff15 	stw	zero,-4(fp)
 321c838:	00001906 	br	321c8a0 <OSTaskNameGet+0x1a0>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
 321c83c:	e0bffb17 	ldw	r2,-20(fp)
 321c840:	10800058 	cmpnei	r2,r2,1
 321c844:	1000091e 	bne	r2,zero,321c86c <OSTaskNameGet+0x16c>
 321c848:	e0bff917 	ldw	r2,-28(fp)
 321c84c:	e0bff615 	stw	r2,-40(fp)
 321c850:	e0bff617 	ldw	r2,-40(fp)
 321c854:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
 321c858:	e0fffe17 	ldw	r3,-8(fp)
 321c85c:	008010c4 	movi	r2,67
 321c860:	18800005 	stb	r2,0(r3)
        return (0);
 321c864:	e03fff15 	stw	zero,-4(fp)
 321c868:	00000d06 	br	321c8a0 <OSTaskNameGet+0x1a0>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
 321c86c:	e0bffb17 	ldw	r2,-20(fp)
 321c870:	11401304 	addi	r5,r2,76
 321c874:	e13ffd17 	ldw	r4,-12(fp)
 321c878:	32170cc0 	call	32170cc <OS_StrCopy>
 321c87c:	e0bffa05 	stb	r2,-24(fp)
 321c880:	e0bff917 	ldw	r2,-28(fp)
 321c884:	e0bff515 	stw	r2,-44(fp)
 321c888:	e0bff517 	ldw	r2,-44(fp)
 321c88c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 321c890:	e0bffe17 	ldw	r2,-8(fp)
 321c894:	10000005 	stb	zero,0(r2)
    return (len);
 321c898:	e0bffa03 	ldbu	r2,-24(fp)
 321c89c:	e0bfff15 	stw	r2,-4(fp)
 321c8a0:	e0bfff17 	ldw	r2,-4(fp)
}
 321c8a4:	e037883a 	mov	sp,fp
 321c8a8:	dfc00117 	ldw	ra,4(sp)
 321c8ac:	df000017 	ldw	fp,0(sp)
 321c8b0:	dec00204 	addi	sp,sp,8
 321c8b4:	f800283a 	ret

0321c8b8 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
 321c8b8:	defff304 	addi	sp,sp,-52
 321c8bc:	dfc00c15 	stw	ra,48(sp)
 321c8c0:	df000b15 	stw	fp,44(sp)
 321c8c4:	df000b04 	addi	fp,sp,44
 321c8c8:	e17ffe15 	stw	r5,-8(fp)
 321c8cc:	e1bfff15 	stw	r6,-4(fp)
 321c8d0:	e13ffd05 	stb	r4,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 321c8d4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 321c8d8:	e0bfff17 	ldw	r2,-4(fp)
 321c8dc:	1005003a 	cmpeq	r2,r2,zero
 321c8e0:	1000611e 	bne	r2,zero,321ca68 <OSTaskNameSet+0x1b0>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
 321c8e4:	e0bffd03 	ldbu	r2,-12(fp)
 321c8e8:	10800570 	cmpltui	r2,r2,21
 321c8ec:	1000071e 	bne	r2,zero,321c90c <OSTaskNameSet+0x54>
        if (prio != OS_PRIO_SELF) {
 321c8f0:	e0bffd03 	ldbu	r2,-12(fp)
 321c8f4:	10803fe0 	cmpeqi	r2,r2,255
 321c8f8:	1000041e 	bne	r2,zero,321c90c <OSTaskNameSet+0x54>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
 321c8fc:	e0ffff17 	ldw	r3,-4(fp)
 321c900:	00800a84 	movi	r2,42
 321c904:	18800005 	stb	r2,0(r3)
            return;
 321c908:	00005706 	br	321ca68 <OSTaskNameSet+0x1b0>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
 321c90c:	e0bffe17 	ldw	r2,-8(fp)
 321c910:	1004c03a 	cmpne	r2,r2,zero
 321c914:	1000041e 	bne	r2,zero,321c928 <OSTaskNameSet+0x70>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
 321c918:	e0ffff17 	ldw	r3,-4(fp)
 321c91c:	00800304 	movi	r2,12
 321c920:	18800005 	stb	r2,0(r3)
        return;
 321c924:	00005006 	br	321ca68 <OSTaskNameSet+0x1b0>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
 321c928:	0080c974 	movhi	r2,805
 321c92c:	10931404 	addi	r2,r2,19536
 321c930:	10800003 	ldbu	r2,0(r2)
 321c934:	10803fcc 	andi	r2,r2,255
 321c938:	1005003a 	cmpeq	r2,r2,zero
 321c93c:	1000041e 	bne	r2,zero,321c950 <OSTaskNameSet+0x98>
        *perr = OS_ERR_NAME_SET_ISR;
 321c940:	e0ffff17 	ldw	r3,-4(fp)
 321c944:	00800484 	movi	r2,18
 321c948:	18800005 	stb	r2,0(r3)
        return;
 321c94c:	00004606 	br	321ca68 <OSTaskNameSet+0x1b0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321c950:	0005303a 	rdctl	r2,status
 321c954:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321c958:	e0fff917 	ldw	r3,-28(fp)
 321c95c:	00bfff84 	movi	r2,-2
 321c960:	1884703a 	and	r2,r3,r2
 321c964:	1001703a 	wrctl	status,r2
  
  return context;
 321c968:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 321c96c:	e0bffa15 	stw	r2,-24(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
 321c970:	e0bffd03 	ldbu	r2,-12(fp)
 321c974:	10803fd8 	cmpnei	r2,r2,255
 321c978:	1000051e 	bne	r2,zero,321c990 <OSTaskNameSet+0xd8>
        prio = OSTCBCur->OSTCBPrio;
 321c97c:	0080c974 	movhi	r2,805
 321c980:	10931504 	addi	r2,r2,19540
 321c984:	10800017 	ldw	r2,0(r2)
 321c988:	10800c83 	ldbu	r2,50(r2)
 321c98c:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 321c990:	e0bffd03 	ldbu	r2,-12(fp)
 321c994:	00c0c9b4 	movhi	r3,806
 321c998:	18f26b04 	addi	r3,r3,-13908
 321c99c:	1085883a 	add	r2,r2,r2
 321c9a0:	1085883a 	add	r2,r2,r2
 321c9a4:	10c5883a 	add	r2,r2,r3
 321c9a8:	10800017 	ldw	r2,0(r2)
 321c9ac:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
 321c9b0:	e0bffb17 	ldw	r2,-20(fp)
 321c9b4:	1004c03a 	cmpne	r2,r2,zero
 321c9b8:	1000081e 	bne	r2,zero,321c9dc <OSTaskNameSet+0x124>
 321c9bc:	e0bffa17 	ldw	r2,-24(fp)
 321c9c0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321c9c4:	e0bff817 	ldw	r2,-32(fp)
 321c9c8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
 321c9cc:	e0ffff17 	ldw	r3,-4(fp)
 321c9d0:	008010c4 	movi	r2,67
 321c9d4:	18800005 	stb	r2,0(r3)
        return;
 321c9d8:	00002306 	br	321ca68 <OSTaskNameSet+0x1b0>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
 321c9dc:	e0bffb17 	ldw	r2,-20(fp)
 321c9e0:	10800058 	cmpnei	r2,r2,1
 321c9e4:	1000081e 	bne	r2,zero,321ca08 <OSTaskNameSet+0x150>
 321c9e8:	e0bffa17 	ldw	r2,-24(fp)
 321c9ec:	e0bff715 	stw	r2,-36(fp)
 321c9f0:	e0bff717 	ldw	r2,-36(fp)
 321c9f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
 321c9f8:	e0ffff17 	ldw	r3,-4(fp)
 321c9fc:	008010c4 	movi	r2,67
 321ca00:	18800005 	stb	r2,0(r3)
        return;
 321ca04:	00001806 	br	321ca68 <OSTaskNameSet+0x1b0>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
 321ca08:	e13ffe17 	ldw	r4,-8(fp)
 321ca0c:	321714c0 	call	321714c <OS_StrLen>
 321ca10:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
 321ca14:	e0bffc03 	ldbu	r2,-16(fp)
 321ca18:	10800830 	cmpltui	r2,r2,32
 321ca1c:	1000081e 	bne	r2,zero,321ca40 <OSTaskNameSet+0x188>
 321ca20:	e0bffa17 	ldw	r2,-24(fp)
 321ca24:	e0bff615 	stw	r2,-40(fp)
 321ca28:	e0bff617 	ldw	r2,-40(fp)
 321ca2c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
 321ca30:	e0ffff17 	ldw	r3,-4(fp)
 321ca34:	00801044 	movi	r2,65
 321ca38:	18800005 	stb	r2,0(r3)
        return;
 321ca3c:	00000a06 	br	321ca68 <OSTaskNameSet+0x1b0>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
 321ca40:	e0bffb17 	ldw	r2,-20(fp)
 321ca44:	11001304 	addi	r4,r2,76
 321ca48:	e17ffe17 	ldw	r5,-8(fp)
 321ca4c:	32170cc0 	call	32170cc <OS_StrCopy>
 321ca50:	e0bffa17 	ldw	r2,-24(fp)
 321ca54:	e0bff515 	stw	r2,-44(fp)
 321ca58:	e0bff517 	ldw	r2,-44(fp)
 321ca5c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 321ca60:	e0bfff17 	ldw	r2,-4(fp)
 321ca64:	10000005 	stb	zero,0(r2)
}
 321ca68:	e037883a 	mov	sp,fp
 321ca6c:	dfc00117 	ldw	ra,4(sp)
 321ca70:	df000017 	ldw	fp,0(sp)
 321ca74:	dec00204 	addi	sp,sp,8
 321ca78:	f800283a 	ret

0321ca7c <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
 321ca7c:	defff304 	addi	sp,sp,-52
 321ca80:	dfc00c15 	stw	ra,48(sp)
 321ca84:	df000b15 	stw	fp,44(sp)
 321ca88:	df000b04 	addi	fp,sp,44
 321ca8c:	e13ffe05 	stb	r4,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 321ca90:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
 321ca94:	e0bffe03 	ldbu	r2,-8(fp)
 321ca98:	10800530 	cmpltui	r2,r2,20
 321ca9c:	1000031e 	bne	r2,zero,321caac <OSTaskResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 321caa0:	00800a84 	movi	r2,42
 321caa4:	e0bfff15 	stw	r2,-4(fp)
 321caa8:	00007406 	br	321cc7c <OSTaskResume+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321caac:	0005303a 	rdctl	r2,status
 321cab0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321cab4:	e0fffb17 	ldw	r3,-20(fp)
 321cab8:	00bfff84 	movi	r2,-2
 321cabc:	1884703a 	and	r2,r3,r2
 321cac0:	1001703a 	wrctl	status,r2
  
  return context;
 321cac4:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 321cac8:	e0bffc15 	stw	r2,-16(fp)
    ptcb = OSTCBPrioTbl[prio];
 321cacc:	e0bffe03 	ldbu	r2,-8(fp)
 321cad0:	00c0c9b4 	movhi	r3,806
 321cad4:	18f26b04 	addi	r3,r3,-13908
 321cad8:	1085883a 	add	r2,r2,r2
 321cadc:	1085883a 	add	r2,r2,r2
 321cae0:	10c5883a 	add	r2,r2,r3
 321cae4:	10800017 	ldw	r2,0(r2)
 321cae8:	e0bffd15 	stw	r2,-12(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
 321caec:	e0bffd17 	ldw	r2,-12(fp)
 321caf0:	1004c03a 	cmpne	r2,r2,zero
 321caf4:	1000071e 	bne	r2,zero,321cb14 <OSTaskResume+0x98>
 321caf8:	e0bffc17 	ldw	r2,-16(fp)
 321cafc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321cb00:	e0bffa17 	ldw	r2,-24(fp)
 321cb04:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
 321cb08:	00801184 	movi	r2,70
 321cb0c:	e0bfff15 	stw	r2,-4(fp)
 321cb10:	00005a06 	br	321cc7c <OSTaskResume+0x200>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
 321cb14:	e0bffd17 	ldw	r2,-12(fp)
 321cb18:	10800058 	cmpnei	r2,r2,1
 321cb1c:	1000071e 	bne	r2,zero,321cb3c <OSTaskResume+0xc0>
 321cb20:	e0bffc17 	ldw	r2,-16(fp)
 321cb24:	e0bff915 	stw	r2,-28(fp)
 321cb28:	e0bff917 	ldw	r2,-28(fp)
 321cb2c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 321cb30:	008010c4 	movi	r2,67
 321cb34:	e0bfff15 	stw	r2,-4(fp)
 321cb38:	00005006 	br	321cc7c <OSTaskResume+0x200>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
 321cb3c:	e0bffd17 	ldw	r2,-12(fp)
 321cb40:	10800c03 	ldbu	r2,48(r2)
 321cb44:	10803fcc 	andi	r2,r2,255
 321cb48:	1080020c 	andi	r2,r2,8
 321cb4c:	1005003a 	cmpeq	r2,r2,zero
 321cb50:	1000441e 	bne	r2,zero,321cc64 <OSTaskResume+0x1e8>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
 321cb54:	e0bffd17 	ldw	r2,-12(fp)
 321cb58:	10c00c03 	ldbu	r3,48(r2)
 321cb5c:	00bffdc4 	movi	r2,-9
 321cb60:	1884703a 	and	r2,r3,r2
 321cb64:	1007883a 	mov	r3,r2
 321cb68:	e0bffd17 	ldw	r2,-12(fp)
 321cb6c:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
 321cb70:	e0bffd17 	ldw	r2,-12(fp)
 321cb74:	10800c03 	ldbu	r2,48(r2)
 321cb78:	10803fcc 	andi	r2,r2,255
 321cb7c:	1004c03a 	cmpne	r2,r2,zero
 321cb80:	1000321e 	bne	r2,zero,321cc4c <OSTaskResume+0x1d0>
            if (ptcb->OSTCBDly == 0) {
 321cb84:	e0bffd17 	ldw	r2,-12(fp)
 321cb88:	10800b8b 	ldhu	r2,46(r2)
 321cb8c:	10bfffcc 	andi	r2,r2,65535
 321cb90:	1004c03a 	cmpne	r2,r2,zero
 321cb94:	1000281e 	bne	r2,zero,321cc38 <OSTaskResume+0x1bc>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
 321cb98:	e0bffd17 	ldw	r2,-12(fp)
 321cb9c:	10c00d83 	ldbu	r3,54(r2)
 321cba0:	0080c974 	movhi	r2,805
 321cba4:	10931204 	addi	r2,r2,19528
 321cba8:	10800003 	ldbu	r2,0(r2)
 321cbac:	1884b03a 	or	r2,r3,r2
 321cbb0:	1007883a 	mov	r3,r2
 321cbb4:	0080c974 	movhi	r2,805
 321cbb8:	10931204 	addi	r2,r2,19528
 321cbbc:	10c00005 	stb	r3,0(r2)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 321cbc0:	e0bffd17 	ldw	r2,-12(fp)
 321cbc4:	10800d03 	ldbu	r2,52(r2)
 321cbc8:	11003fcc 	andi	r4,r2,255
 321cbcc:	e0bffd17 	ldw	r2,-12(fp)
 321cbd0:	10800d03 	ldbu	r2,52(r2)
 321cbd4:	10c03fcc 	andi	r3,r2,255
 321cbd8:	0080c974 	movhi	r2,805
 321cbdc:	10931244 	addi	r2,r2,19529
 321cbe0:	10c5883a 	add	r2,r2,r3
 321cbe4:	10c00003 	ldbu	r3,0(r2)
 321cbe8:	e0bffd17 	ldw	r2,-12(fp)
 321cbec:	10800d43 	ldbu	r2,53(r2)
 321cbf0:	1884b03a 	or	r2,r3,r2
 321cbf4:	1007883a 	mov	r3,r2
 321cbf8:	0080c974 	movhi	r2,805
 321cbfc:	10931244 	addi	r2,r2,19529
 321cc00:	1105883a 	add	r2,r2,r4
 321cc04:	10c00005 	stb	r3,0(r2)
 321cc08:	e0bffc17 	ldw	r2,-16(fp)
 321cc0c:	e0bff815 	stw	r2,-32(fp)
 321cc10:	e0bff817 	ldw	r2,-32(fp)
 321cc14:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
 321cc18:	0080c974 	movhi	r2,805
 321cc1c:	10930644 	addi	r2,r2,19481
 321cc20:	10800003 	ldbu	r2,0(r2)
 321cc24:	10803fcc 	andi	r2,r2,255
 321cc28:	10800058 	cmpnei	r2,r2,1
 321cc2c:	10000b1e 	bne	r2,zero,321cc5c <OSTaskResume+0x1e0>
                    OS_Sched();                               /* Find new highest priority task        */
 321cc30:	3216f880 	call	3216f88 <OS_Sched>
 321cc34:	00000906 	br	321cc5c <OSTaskResume+0x1e0>
 321cc38:	e0bffc17 	ldw	r2,-16(fp)
 321cc3c:	e0bff715 	stw	r2,-36(fp)
 321cc40:	e0bff717 	ldw	r2,-36(fp)
 321cc44:	1001703a 	wrctl	status,r2
 321cc48:	00000406 	br	321cc5c <OSTaskResume+0x1e0>
 321cc4c:	e0bffc17 	ldw	r2,-16(fp)
 321cc50:	e0bff615 	stw	r2,-40(fp)
 321cc54:	e0bff617 	ldw	r2,-40(fp)
 321cc58:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
 321cc5c:	e03fff15 	stw	zero,-4(fp)
 321cc60:	00000606 	br	321cc7c <OSTaskResume+0x200>
 321cc64:	e0bffc17 	ldw	r2,-16(fp)
 321cc68:	e0bff515 	stw	r2,-44(fp)
 321cc6c:	e0bff517 	ldw	r2,-44(fp)
 321cc70:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
 321cc74:	00801104 	movi	r2,68
 321cc78:	e0bfff15 	stw	r2,-4(fp)
 321cc7c:	e0bfff17 	ldw	r2,-4(fp)
}
 321cc80:	e037883a 	mov	sp,fp
 321cc84:	dfc00117 	ldw	ra,4(sp)
 321cc88:	df000017 	ldw	fp,0(sp)
 321cc8c:	dec00204 	addi	sp,sp,8
 321cc90:	f800283a 	ret

0321cc94 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
 321cc94:	defff204 	addi	sp,sp,-56
 321cc98:	df000d15 	stw	fp,52(sp)
 321cc9c:	df000d04 	addi	fp,sp,52
 321cca0:	e17ffe15 	stw	r5,-8(fp)
 321cca4:	e13ffd05 	stb	r4,-12(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 321cca8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
 321ccac:	e0bffd03 	ldbu	r2,-12(fp)
 321ccb0:	10800570 	cmpltui	r2,r2,21
 321ccb4:	1000061e 	bne	r2,zero,321ccd0 <OSTaskStkChk+0x3c>
        if (prio != OS_PRIO_SELF) {
 321ccb8:	e0bffd03 	ldbu	r2,-12(fp)
 321ccbc:	10803fe0 	cmpeqi	r2,r2,255
 321ccc0:	1000031e 	bne	r2,zero,321ccd0 <OSTaskStkChk+0x3c>
            return (OS_ERR_PRIO_INVALID);
 321ccc4:	00800a84 	movi	r2,42
 321ccc8:	e0bfff15 	stw	r2,-4(fp)
 321cccc:	00006b06 	br	321ce7c <OSTaskStkChk+0x1e8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
 321ccd0:	e0bffe17 	ldw	r2,-8(fp)
 321ccd4:	1004c03a 	cmpne	r2,r2,zero
 321ccd8:	1000031e 	bne	r2,zero,321cce8 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
 321ccdc:	00800244 	movi	r2,9
 321cce0:	e0bfff15 	stw	r2,-4(fp)
 321cce4:	00006506 	br	321ce7c <OSTaskStkChk+0x1e8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
 321cce8:	e0bffe17 	ldw	r2,-8(fp)
 321ccec:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
 321ccf0:	e0bffe17 	ldw	r2,-8(fp)
 321ccf4:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321ccf8:	0005303a 	rdctl	r2,status
 321ccfc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321cd00:	e0fff717 	ldw	r3,-36(fp)
 321cd04:	00bfff84 	movi	r2,-2
 321cd08:	1884703a 	and	r2,r3,r2
 321cd0c:	1001703a 	wrctl	status,r2
  
  return context;
 321cd10:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 321cd14:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
 321cd18:	e0bffd03 	ldbu	r2,-12(fp)
 321cd1c:	10803fd8 	cmpnei	r2,r2,255
 321cd20:	1000051e 	bne	r2,zero,321cd38 <OSTaskStkChk+0xa4>
        prio = OSTCBCur->OSTCBPrio;
 321cd24:	0080c974 	movhi	r2,805
 321cd28:	10931504 	addi	r2,r2,19540
 321cd2c:	10800017 	ldw	r2,0(r2)
 321cd30:	10800c83 	ldbu	r2,50(r2)
 321cd34:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 321cd38:	e0bffd03 	ldbu	r2,-12(fp)
 321cd3c:	00c0c9b4 	movhi	r3,806
 321cd40:	18f26b04 	addi	r3,r3,-13908
 321cd44:	1085883a 	add	r2,r2,r2
 321cd48:	1085883a 	add	r2,r2,r2
 321cd4c:	10c5883a 	add	r2,r2,r3
 321cd50:	10800017 	ldw	r2,0(r2)
 321cd54:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
 321cd58:	e0bffc17 	ldw	r2,-16(fp)
 321cd5c:	1004c03a 	cmpne	r2,r2,zero
 321cd60:	1000071e 	bne	r2,zero,321cd80 <OSTaskStkChk+0xec>
 321cd64:	e0bff817 	ldw	r2,-32(fp)
 321cd68:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321cd6c:	e0bff617 	ldw	r2,-40(fp)
 321cd70:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 321cd74:	008010c4 	movi	r2,67
 321cd78:	e0bfff15 	stw	r2,-4(fp)
 321cd7c:	00003f06 	br	321ce7c <OSTaskStkChk+0x1e8>
    }
    if (ptcb == OS_TCB_RESERVED) {
 321cd80:	e0bffc17 	ldw	r2,-16(fp)
 321cd84:	10800058 	cmpnei	r2,r2,1
 321cd88:	1000071e 	bne	r2,zero,321cda8 <OSTaskStkChk+0x114>
 321cd8c:	e0bff817 	ldw	r2,-32(fp)
 321cd90:	e0bff515 	stw	r2,-44(fp)
 321cd94:	e0bff517 	ldw	r2,-44(fp)
 321cd98:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 321cd9c:	008010c4 	movi	r2,67
 321cda0:	e0bfff15 	stw	r2,-4(fp)
 321cda4:	00003506 	br	321ce7c <OSTaskStkChk+0x1e8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
 321cda8:	e0bffc17 	ldw	r2,-16(fp)
 321cdac:	1080040b 	ldhu	r2,16(r2)
 321cdb0:	10bfffcc 	andi	r2,r2,65535
 321cdb4:	1080004c 	andi	r2,r2,1
 321cdb8:	1004c03a 	cmpne	r2,r2,zero
 321cdbc:	1000071e 	bne	r2,zero,321cddc <OSTaskStkChk+0x148>
 321cdc0:	e0bff817 	ldw	r2,-32(fp)
 321cdc4:	e0bff415 	stw	r2,-48(fp)
 321cdc8:	e0bff417 	ldw	r2,-48(fp)
 321cdcc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
 321cdd0:	00801144 	movi	r2,69
 321cdd4:	e0bfff15 	stw	r2,-4(fp)
 321cdd8:	00002806 	br	321ce7c <OSTaskStkChk+0x1e8>
    }
    nfree = 0;
 321cddc:	e03ffa15 	stw	zero,-24(fp)
    size  = ptcb->OSTCBStkSize;
 321cde0:	e0bffc17 	ldw	r2,-16(fp)
 321cde4:	10800317 	ldw	r2,12(r2)
 321cde8:	e0bff915 	stw	r2,-28(fp)
    pchk  = ptcb->OSTCBStkBottom;
 321cdec:	e0bffc17 	ldw	r2,-16(fp)
 321cdf0:	10800217 	ldw	r2,8(r2)
 321cdf4:	e0bffb15 	stw	r2,-20(fp)
 321cdf8:	e0bff817 	ldw	r2,-32(fp)
 321cdfc:	e0bff315 	stw	r2,-52(fp)
 321ce00:	e0bff317 	ldw	r2,-52(fp)
 321ce04:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 321ce08:	00000306 	br	321ce18 <OSTaskStkChk+0x184>
        nfree++;
 321ce0c:	e0bffa17 	ldw	r2,-24(fp)
 321ce10:	10800044 	addi	r2,r2,1
 321ce14:	e0bffa15 	stw	r2,-24(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 321ce18:	e0bffb17 	ldw	r2,-20(fp)
 321ce1c:	10800017 	ldw	r2,0(r2)
 321ce20:	1005003a 	cmpeq	r2,r2,zero
 321ce24:	1007883a 	mov	r3,r2
 321ce28:	e0bffb17 	ldw	r2,-20(fp)
 321ce2c:	10800104 	addi	r2,r2,4
 321ce30:	e0bffb15 	stw	r2,-20(fp)
 321ce34:	18803fcc 	andi	r2,r3,255
 321ce38:	1004c03a 	cmpne	r2,r2,zero
 321ce3c:	103ff31e 	bne	r2,zero,321ce0c <OSTaskStkChk+0x178>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
 321ce40:	e0bffa17 	ldw	r2,-24(fp)
 321ce44:	1085883a 	add	r2,r2,r2
 321ce48:	1085883a 	add	r2,r2,r2
 321ce4c:	1007883a 	mov	r3,r2
 321ce50:	e0bffe17 	ldw	r2,-8(fp)
 321ce54:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
 321ce58:	e0fff917 	ldw	r3,-28(fp)
 321ce5c:	e0bffa17 	ldw	r2,-24(fp)
 321ce60:	1885c83a 	sub	r2,r3,r2
 321ce64:	1085883a 	add	r2,r2,r2
 321ce68:	1085883a 	add	r2,r2,r2
 321ce6c:	1007883a 	mov	r3,r2
 321ce70:	e0bffe17 	ldw	r2,-8(fp)
 321ce74:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
 321ce78:	e03fff15 	stw	zero,-4(fp)
 321ce7c:	e0bfff17 	ldw	r2,-4(fp)
}
 321ce80:	e037883a 	mov	sp,fp
 321ce84:	df000017 	ldw	fp,0(sp)
 321ce88:	dec00104 	addi	sp,sp,4
 321ce8c:	f800283a 	ret

0321ce90 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
 321ce90:	defff404 	addi	sp,sp,-48
 321ce94:	dfc00b15 	stw	ra,44(sp)
 321ce98:	df000a15 	stw	fp,40(sp)
 321ce9c:	df000a04 	addi	fp,sp,40
 321cea0:	e13ffe05 	stb	r4,-8(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 321cea4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
 321cea8:	e0bffe03 	ldbu	r2,-8(fp)
 321ceac:	10800518 	cmpnei	r2,r2,20
 321ceb0:	1000031e 	bne	r2,zero,321cec0 <OSTaskSuspend+0x30>
        return (OS_ERR_TASK_SUSPEND_IDLE);
 321ceb4:	008011c4 	movi	r2,71
 321ceb8:	e0bfff15 	stw	r2,-4(fp)
 321cebc:	00007906 	br	321d0a4 <OSTaskSuspend+0x214>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 321cec0:	e0bffe03 	ldbu	r2,-8(fp)
 321cec4:	10800530 	cmpltui	r2,r2,20
 321cec8:	1000061e 	bne	r2,zero,321cee4 <OSTaskSuspend+0x54>
        if (prio != OS_PRIO_SELF) {
 321cecc:	e0bffe03 	ldbu	r2,-8(fp)
 321ced0:	10803fe0 	cmpeqi	r2,r2,255
 321ced4:	1000031e 	bne	r2,zero,321cee4 <OSTaskSuspend+0x54>
            return (OS_ERR_PRIO_INVALID);
 321ced8:	00800a84 	movi	r2,42
 321cedc:	e0bfff15 	stw	r2,-4(fp)
 321cee0:	00007006 	br	321d0a4 <OSTaskSuspend+0x214>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321cee4:	0005303a 	rdctl	r2,status
 321cee8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321ceec:	e0fff917 	ldw	r3,-28(fp)
 321cef0:	00bfff84 	movi	r2,-2
 321cef4:	1884703a 	and	r2,r3,r2
 321cef8:	1001703a 	wrctl	status,r2
  
  return context;
 321cefc:	e0bff917 	ldw	r2,-28(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
 321cf00:	e0bffa15 	stw	r2,-24(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
 321cf04:	e0bffe03 	ldbu	r2,-8(fp)
 321cf08:	10803fd8 	cmpnei	r2,r2,255
 321cf0c:	1000081e 	bne	r2,zero,321cf30 <OSTaskSuspend+0xa0>
        prio = OSTCBCur->OSTCBPrio;
 321cf10:	0080c974 	movhi	r2,805
 321cf14:	10931504 	addi	r2,r2,19540
 321cf18:	10800017 	ldw	r2,0(r2)
 321cf1c:	10800c83 	ldbu	r2,50(r2)
 321cf20:	e0bffe05 	stb	r2,-8(fp)
        self = OS_TRUE;
 321cf24:	00800044 	movi	r2,1
 321cf28:	e0bffd05 	stb	r2,-12(fp)
 321cf2c:	00000b06 	br	321cf5c <OSTaskSuspend+0xcc>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
 321cf30:	0080c974 	movhi	r2,805
 321cf34:	10931504 	addi	r2,r2,19540
 321cf38:	10800017 	ldw	r2,0(r2)
 321cf3c:	10800c83 	ldbu	r2,50(r2)
 321cf40:	10c03fcc 	andi	r3,r2,255
 321cf44:	e0bffe03 	ldbu	r2,-8(fp)
 321cf48:	1880031e 	bne	r3,r2,321cf58 <OSTaskSuspend+0xc8>
        self = OS_TRUE;
 321cf4c:	00800044 	movi	r2,1
 321cf50:	e0bffd05 	stb	r2,-12(fp)
 321cf54:	00000106 	br	321cf5c <OSTaskSuspend+0xcc>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
 321cf58:	e03ffd05 	stb	zero,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 321cf5c:	e0bffe03 	ldbu	r2,-8(fp)
 321cf60:	00c0c9b4 	movhi	r3,806
 321cf64:	18f26b04 	addi	r3,r3,-13908
 321cf68:	1085883a 	add	r2,r2,r2
 321cf6c:	1085883a 	add	r2,r2,r2
 321cf70:	10c5883a 	add	r2,r2,r3
 321cf74:	10800017 	ldw	r2,0(r2)
 321cf78:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
 321cf7c:	e0bffc17 	ldw	r2,-16(fp)
 321cf80:	1004c03a 	cmpne	r2,r2,zero
 321cf84:	1000071e 	bne	r2,zero,321cfa4 <OSTaskSuspend+0x114>
 321cf88:	e0bffa17 	ldw	r2,-24(fp)
 321cf8c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321cf90:	e0bff817 	ldw	r2,-32(fp)
 321cf94:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
 321cf98:	00801204 	movi	r2,72
 321cf9c:	e0bfff15 	stw	r2,-4(fp)
 321cfa0:	00004006 	br	321d0a4 <OSTaskSuspend+0x214>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
 321cfa4:	e0bffc17 	ldw	r2,-16(fp)
 321cfa8:	10800058 	cmpnei	r2,r2,1
 321cfac:	1000071e 	bne	r2,zero,321cfcc <OSTaskSuspend+0x13c>
 321cfb0:	e0bffa17 	ldw	r2,-24(fp)
 321cfb4:	e0bff715 	stw	r2,-36(fp)
 321cfb8:	e0bff717 	ldw	r2,-36(fp)
 321cfbc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 321cfc0:	008010c4 	movi	r2,67
 321cfc4:	e0bfff15 	stw	r2,-4(fp)
 321cfc8:	00003606 	br	321d0a4 <OSTaskSuspend+0x214>
    }
    y            = ptcb->OSTCBY;
 321cfcc:	e0bffc17 	ldw	r2,-16(fp)
 321cfd0:	10800d03 	ldbu	r2,52(r2)
 321cfd4:	e0bffb05 	stb	r2,-20(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
 321cfd8:	e13ffb03 	ldbu	r4,-20(fp)
 321cfdc:	e0fffb03 	ldbu	r3,-20(fp)
 321cfe0:	0080c974 	movhi	r2,805
 321cfe4:	10931244 	addi	r2,r2,19529
 321cfe8:	10c5883a 	add	r2,r2,r3
 321cfec:	10800003 	ldbu	r2,0(r2)
 321cff0:	1007883a 	mov	r3,r2
 321cff4:	e0bffc17 	ldw	r2,-16(fp)
 321cff8:	10800d43 	ldbu	r2,53(r2)
 321cffc:	0084303a 	nor	r2,zero,r2
 321d000:	1884703a 	and	r2,r3,r2
 321d004:	1007883a 	mov	r3,r2
 321d008:	0080c974 	movhi	r2,805
 321d00c:	10931244 	addi	r2,r2,19529
 321d010:	1105883a 	add	r2,r2,r4
 321d014:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 321d018:	e0fffb03 	ldbu	r3,-20(fp)
 321d01c:	0080c974 	movhi	r2,805
 321d020:	10931244 	addi	r2,r2,19529
 321d024:	10c5883a 	add	r2,r2,r3
 321d028:	10800003 	ldbu	r2,0(r2)
 321d02c:	10803fcc 	andi	r2,r2,255
 321d030:	1004c03a 	cmpne	r2,r2,zero
 321d034:	10000c1e 	bne	r2,zero,321d068 <OSTaskSuspend+0x1d8>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
 321d038:	e0bffc17 	ldw	r2,-16(fp)
 321d03c:	10800d83 	ldbu	r2,54(r2)
 321d040:	0084303a 	nor	r2,zero,r2
 321d044:	1007883a 	mov	r3,r2
 321d048:	0080c974 	movhi	r2,805
 321d04c:	10931204 	addi	r2,r2,19528
 321d050:	10800003 	ldbu	r2,0(r2)
 321d054:	1884703a 	and	r2,r3,r2
 321d058:	1007883a 	mov	r3,r2
 321d05c:	0080c974 	movhi	r2,805
 321d060:	10931204 	addi	r2,r2,19528
 321d064:	10c00005 	stb	r3,0(r2)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
 321d068:	e0bffc17 	ldw	r2,-16(fp)
 321d06c:	10800c03 	ldbu	r2,48(r2)
 321d070:	10800214 	ori	r2,r2,8
 321d074:	1007883a 	mov	r3,r2
 321d078:	e0bffc17 	ldw	r2,-16(fp)
 321d07c:	10c00c05 	stb	r3,48(r2)
 321d080:	e0bffa17 	ldw	r2,-24(fp)
 321d084:	e0bff615 	stw	r2,-40(fp)
 321d088:	e0bff617 	ldw	r2,-40(fp)
 321d08c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
 321d090:	e0bffd03 	ldbu	r2,-12(fp)
 321d094:	10800058 	cmpnei	r2,r2,1
 321d098:	1000011e 	bne	r2,zero,321d0a0 <OSTaskSuspend+0x210>
        OS_Sched();                                             /* Find new highest priority task      */
 321d09c:	3216f880 	call	3216f88 <OS_Sched>
    }
    return (OS_ERR_NONE);
 321d0a0:	e03fff15 	stw	zero,-4(fp)
 321d0a4:	e0bfff17 	ldw	r2,-4(fp)
}
 321d0a8:	e037883a 	mov	sp,fp
 321d0ac:	dfc00117 	ldw	ra,4(sp)
 321d0b0:	df000017 	ldw	fp,0(sp)
 321d0b4:	dec00204 	addi	sp,sp,8
 321d0b8:	f800283a 	ret

0321d0bc <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
 321d0bc:	defff504 	addi	sp,sp,-44
 321d0c0:	dfc00a15 	stw	ra,40(sp)
 321d0c4:	df000915 	stw	fp,36(sp)
 321d0c8:	df000904 	addi	fp,sp,36
 321d0cc:	e17ffe15 	stw	r5,-8(fp)
 321d0d0:	e13ffd05 	stb	r4,-12(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 321d0d4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
 321d0d8:	e0bffd03 	ldbu	r2,-12(fp)
 321d0dc:	10800570 	cmpltui	r2,r2,21
 321d0e0:	1000061e 	bne	r2,zero,321d0fc <OSTaskQuery+0x40>
        if (prio != OS_PRIO_SELF) {
 321d0e4:	e0bffd03 	ldbu	r2,-12(fp)
 321d0e8:	10803fe0 	cmpeqi	r2,r2,255
 321d0ec:	1000031e 	bne	r2,zero,321d0fc <OSTaskQuery+0x40>
            return (OS_ERR_PRIO_INVALID);
 321d0f0:	00800a84 	movi	r2,42
 321d0f4:	e0bfff15 	stw	r2,-4(fp)
 321d0f8:	00003b06 	br	321d1e8 <OSTaskQuery+0x12c>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
 321d0fc:	e0bffe17 	ldw	r2,-8(fp)
 321d100:	1004c03a 	cmpne	r2,r2,zero
 321d104:	1000031e 	bne	r2,zero,321d114 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
 321d108:	00800244 	movi	r2,9
 321d10c:	e0bfff15 	stw	r2,-4(fp)
 321d110:	00003506 	br	321d1e8 <OSTaskQuery+0x12c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321d114:	0005303a 	rdctl	r2,status
 321d118:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321d11c:	e0fffa17 	ldw	r3,-24(fp)
 321d120:	00bfff84 	movi	r2,-2
 321d124:	1884703a 	and	r2,r3,r2
 321d128:	1001703a 	wrctl	status,r2
  
  return context;
 321d12c:	e0bffa17 	ldw	r2,-24(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 321d130:	e0bffb15 	stw	r2,-20(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
 321d134:	e0bffd03 	ldbu	r2,-12(fp)
 321d138:	10803fd8 	cmpnei	r2,r2,255
 321d13c:	1000051e 	bne	r2,zero,321d154 <OSTaskQuery+0x98>
        prio = OSTCBCur->OSTCBPrio;
 321d140:	0080c974 	movhi	r2,805
 321d144:	10931504 	addi	r2,r2,19540
 321d148:	10800017 	ldw	r2,0(r2)
 321d14c:	10800c83 	ldbu	r2,50(r2)
 321d150:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 321d154:	e0bffd03 	ldbu	r2,-12(fp)
 321d158:	00c0c9b4 	movhi	r3,806
 321d15c:	18f26b04 	addi	r3,r3,-13908
 321d160:	1085883a 	add	r2,r2,r2
 321d164:	1085883a 	add	r2,r2,r2
 321d168:	10c5883a 	add	r2,r2,r3
 321d16c:	10800017 	ldw	r2,0(r2)
 321d170:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
 321d174:	e0bffc17 	ldw	r2,-16(fp)
 321d178:	1004c03a 	cmpne	r2,r2,zero
 321d17c:	1000071e 	bne	r2,zero,321d19c <OSTaskQuery+0xe0>
 321d180:	e0bffb17 	ldw	r2,-20(fp)
 321d184:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321d188:	e0bff917 	ldw	r2,-28(fp)
 321d18c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
 321d190:	00800a44 	movi	r2,41
 321d194:	e0bfff15 	stw	r2,-4(fp)
 321d198:	00001306 	br	321d1e8 <OSTaskQuery+0x12c>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
 321d19c:	e0bffc17 	ldw	r2,-16(fp)
 321d1a0:	10800058 	cmpnei	r2,r2,1
 321d1a4:	1000071e 	bne	r2,zero,321d1c4 <OSTaskQuery+0x108>
 321d1a8:	e0bffb17 	ldw	r2,-20(fp)
 321d1ac:	e0bff815 	stw	r2,-32(fp)
 321d1b0:	e0bff817 	ldw	r2,-32(fp)
 321d1b4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 321d1b8:	008010c4 	movi	r2,67
 321d1bc:	e0bfff15 	stw	r2,-4(fp)
 321d1c0:	00000906 	br	321d1e8 <OSTaskQuery+0x12c>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
 321d1c4:	e13ffe17 	ldw	r4,-8(fp)
 321d1c8:	e17ffc17 	ldw	r5,-16(fp)
 321d1cc:	01801b04 	movi	r6,108
 321d1d0:	3216f1c0 	call	3216f1c <OS_MemCopy>
 321d1d4:	e0bffb17 	ldw	r2,-20(fp)
 321d1d8:	e0bff715 	stw	r2,-36(fp)
 321d1dc:	e0bff717 	ldw	r2,-36(fp)
 321d1e0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 321d1e4:	e03fff15 	stw	zero,-4(fp)
 321d1e8:	e0bfff17 	ldw	r2,-4(fp)
}
 321d1ec:	e037883a 	mov	sp,fp
 321d1f0:	dfc00117 	ldw	ra,4(sp)
 321d1f4:	df000017 	ldw	fp,0(sp)
 321d1f8:	dec00204 	addi	sp,sp,8
 321d1fc:	f800283a 	ret

0321d200 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
 321d200:	defffc04 	addi	sp,sp,-16
 321d204:	df000315 	stw	fp,12(sp)
 321d208:	df000304 	addi	fp,sp,12
 321d20c:	e13ffd15 	stw	r4,-12(fp)
 321d210:	e17ffe15 	stw	r5,-8(fp)
 321d214:	e1bfff0d 	sth	r6,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
 321d218:	e0bfff0b 	ldhu	r2,-4(fp)
 321d21c:	1080004c 	andi	r2,r2,1
 321d220:	10803fcc 	andi	r2,r2,255
 321d224:	1005003a 	cmpeq	r2,r2,zero
 321d228:	1000101e 	bne	r2,zero,321d26c <OS_TaskStkClr+0x6c>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
 321d22c:	e0bfff0b 	ldhu	r2,-4(fp)
 321d230:	1080008c 	andi	r2,r2,2
 321d234:	1005003a 	cmpeq	r2,r2,zero
 321d238:	10000c1e 	bne	r2,zero,321d26c <OS_TaskStkClr+0x6c>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 321d23c:	00000806 	br	321d260 <OS_TaskStkClr+0x60>
                size--;
 321d240:	e0bffe17 	ldw	r2,-8(fp)
 321d244:	10bfffc4 	addi	r2,r2,-1
 321d248:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
 321d24c:	e0bffd17 	ldw	r2,-12(fp)
 321d250:	10000015 	stw	zero,0(r2)
 321d254:	e0bffd17 	ldw	r2,-12(fp)
 321d258:	10800104 	addi	r2,r2,4
 321d25c:	e0bffd15 	stw	r2,-12(fp)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 321d260:	e0bffe17 	ldw	r2,-8(fp)
 321d264:	1004c03a 	cmpne	r2,r2,zero
 321d268:	103ff51e 	bne	r2,zero,321d240 <OS_TaskStkClr+0x40>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
 321d26c:	e037883a 	mov	sp,fp
 321d270:	df000017 	ldw	fp,0(sp)
 321d274:	dec00104 	addi	sp,sp,4
 321d278:	f800283a 	ret

0321d27c <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
 321d27c:	defff904 	addi	sp,sp,-28
 321d280:	dfc00615 	stw	ra,24(sp)
 321d284:	df000515 	stw	fp,20(sp)
 321d288:	df000504 	addi	fp,sp,20
 321d28c:	e13fff0d 	sth	r4,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 321d290:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 321d294:	0080c974 	movhi	r2,805
 321d298:	10931404 	addi	r2,r2,19536
 321d29c:	10800003 	ldbu	r2,0(r2)
 321d2a0:	10803fcc 	andi	r2,r2,255
 321d2a4:	1004c03a 	cmpne	r2,r2,zero
 321d2a8:	1000421e 	bne	r2,zero,321d3b4 <OSTimeDly+0x138>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
 321d2ac:	e0bfff0b 	ldhu	r2,-4(fp)
 321d2b0:	1005003a 	cmpeq	r2,r2,zero
 321d2b4:	10003f1e 	bne	r2,zero,321d3b4 <OSTimeDly+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321d2b8:	0005303a 	rdctl	r2,status
 321d2bc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321d2c0:	e0fffc17 	ldw	r3,-16(fp)
 321d2c4:	00bfff84 	movi	r2,-2
 321d2c8:	1884703a 	and	r2,r3,r2
 321d2cc:	1001703a 	wrctl	status,r2
  
  return context;
 321d2d0:	e0bffc17 	ldw	r2,-16(fp)
        OS_ENTER_CRITICAL();
 321d2d4:	e0bffd15 	stw	r2,-12(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
 321d2d8:	0080c974 	movhi	r2,805
 321d2dc:	10931504 	addi	r2,r2,19540
 321d2e0:	10800017 	ldw	r2,0(r2)
 321d2e4:	10800d03 	ldbu	r2,52(r2)
 321d2e8:	e0bffe05 	stb	r2,-8(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 321d2ec:	e13ffe03 	ldbu	r4,-8(fp)
 321d2f0:	e0fffe03 	ldbu	r3,-8(fp)
 321d2f4:	0080c974 	movhi	r2,805
 321d2f8:	10931244 	addi	r2,r2,19529
 321d2fc:	10c5883a 	add	r2,r2,r3
 321d300:	10800003 	ldbu	r2,0(r2)
 321d304:	1007883a 	mov	r3,r2
 321d308:	0080c974 	movhi	r2,805
 321d30c:	10931504 	addi	r2,r2,19540
 321d310:	10800017 	ldw	r2,0(r2)
 321d314:	10800d43 	ldbu	r2,53(r2)
 321d318:	0084303a 	nor	r2,zero,r2
 321d31c:	1884703a 	and	r2,r3,r2
 321d320:	1007883a 	mov	r3,r2
 321d324:	0080c974 	movhi	r2,805
 321d328:	10931244 	addi	r2,r2,19529
 321d32c:	1105883a 	add	r2,r2,r4
 321d330:	10c00005 	stb	r3,0(r2)
        if (OSRdyTbl[y] == 0) {
 321d334:	e0fffe03 	ldbu	r3,-8(fp)
 321d338:	0080c974 	movhi	r2,805
 321d33c:	10931244 	addi	r2,r2,19529
 321d340:	10c5883a 	add	r2,r2,r3
 321d344:	10800003 	ldbu	r2,0(r2)
 321d348:	10803fcc 	andi	r2,r2,255
 321d34c:	1004c03a 	cmpne	r2,r2,zero
 321d350:	10000e1e 	bne	r2,zero,321d38c <OSTimeDly+0x110>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 321d354:	0080c974 	movhi	r2,805
 321d358:	10931504 	addi	r2,r2,19540
 321d35c:	10800017 	ldw	r2,0(r2)
 321d360:	10800d83 	ldbu	r2,54(r2)
 321d364:	0084303a 	nor	r2,zero,r2
 321d368:	1007883a 	mov	r3,r2
 321d36c:	0080c974 	movhi	r2,805
 321d370:	10931204 	addi	r2,r2,19528
 321d374:	10800003 	ldbu	r2,0(r2)
 321d378:	1884703a 	and	r2,r3,r2
 321d37c:	1007883a 	mov	r3,r2
 321d380:	0080c974 	movhi	r2,805
 321d384:	10931204 	addi	r2,r2,19528
 321d388:	10c00005 	stb	r3,0(r2)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
 321d38c:	0080c974 	movhi	r2,805
 321d390:	10931504 	addi	r2,r2,19540
 321d394:	10c00017 	ldw	r3,0(r2)
 321d398:	e0bfff0b 	ldhu	r2,-4(fp)
 321d39c:	18800b8d 	sth	r2,46(r3)
 321d3a0:	e0bffd17 	ldw	r2,-12(fp)
 321d3a4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321d3a8:	e0bffb17 	ldw	r2,-20(fp)
 321d3ac:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
 321d3b0:	3216f880 	call	3216f88 <OS_Sched>
    }
}
 321d3b4:	e037883a 	mov	sp,fp
 321d3b8:	dfc00117 	ldw	ra,4(sp)
 321d3bc:	df000017 	ldw	fp,0(sp)
 321d3c0:	dec00204 	addi	sp,sp,8
 321d3c4:	f800283a 	ret

0321d3c8 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
 321d3c8:	defff604 	addi	sp,sp,-40
 321d3cc:	dfc00915 	stw	ra,36(sp)
 321d3d0:	df000815 	stw	fp,32(sp)
 321d3d4:	dc000715 	stw	r16,28(sp)
 321d3d8:	df000704 	addi	fp,sp,28
 321d3dc:	e13ffb05 	stb	r4,-20(fp)
 321d3e0:	e17ffc05 	stb	r5,-16(fp)
 321d3e4:	e1bffd05 	stb	r6,-12(fp)
 321d3e8:	e1fffe0d 	sth	r7,-8(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 321d3ec:	0080c974 	movhi	r2,805
 321d3f0:	10931404 	addi	r2,r2,19536
 321d3f4:	10800003 	ldbu	r2,0(r2)
 321d3f8:	10803fcc 	andi	r2,r2,255
 321d3fc:	1005003a 	cmpeq	r2,r2,zero
 321d400:	1000031e 	bne	r2,zero,321d410 <OSTimeDlyHMSM+0x48>
        return (OS_ERR_TIME_DLY_ISR);
 321d404:	00801544 	movi	r2,85
 321d408:	e0bfff15 	stw	r2,-4(fp)
 321d40c:	00004406 	br	321d520 <OSTimeDlyHMSM+0x158>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
 321d410:	e0bffb03 	ldbu	r2,-20(fp)
 321d414:	1004c03a 	cmpne	r2,r2,zero
 321d418:	10000c1e 	bne	r2,zero,321d44c <OSTimeDlyHMSM+0x84>
        if (minutes == 0) {
 321d41c:	e0bffc03 	ldbu	r2,-16(fp)
 321d420:	1004c03a 	cmpne	r2,r2,zero
 321d424:	1000091e 	bne	r2,zero,321d44c <OSTimeDlyHMSM+0x84>
            if (seconds == 0) {
 321d428:	e0bffd03 	ldbu	r2,-12(fp)
 321d42c:	1004c03a 	cmpne	r2,r2,zero
 321d430:	1000061e 	bne	r2,zero,321d44c <OSTimeDlyHMSM+0x84>
                if (ms == 0) {
 321d434:	e0bffe0b 	ldhu	r2,-8(fp)
 321d438:	1004c03a 	cmpne	r2,r2,zero
 321d43c:	1000031e 	bne	r2,zero,321d44c <OSTimeDlyHMSM+0x84>
                    return (OS_ERR_TIME_ZERO_DLY);
 321d440:	00801504 	movi	r2,84
 321d444:	e0bfff15 	stw	r2,-4(fp)
 321d448:	00003506 	br	321d520 <OSTimeDlyHMSM+0x158>
                }
            }
        }
    }
    if (minutes > 59) {
 321d44c:	e0bffc03 	ldbu	r2,-16(fp)
 321d450:	10800f30 	cmpltui	r2,r2,60
 321d454:	1000031e 	bne	r2,zero,321d464 <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
 321d458:	00801444 	movi	r2,81
 321d45c:	e0bfff15 	stw	r2,-4(fp)
 321d460:	00002f06 	br	321d520 <OSTimeDlyHMSM+0x158>
    }
    if (seconds > 59) {
 321d464:	e0bffd03 	ldbu	r2,-12(fp)
 321d468:	10800f30 	cmpltui	r2,r2,60
 321d46c:	1000031e 	bne	r2,zero,321d47c <OSTimeDlyHMSM+0xb4>
        return (OS_ERR_TIME_INVALID_SECONDS);
 321d470:	00801484 	movi	r2,82
 321d474:	e0bfff15 	stw	r2,-4(fp)
 321d478:	00002906 	br	321d520 <OSTimeDlyHMSM+0x158>
    }
    if (ms > 999) {
 321d47c:	e0bffe0b 	ldhu	r2,-8(fp)
 321d480:	1080fa30 	cmpltui	r2,r2,1000
 321d484:	1000031e 	bne	r2,zero,321d494 <OSTimeDlyHMSM+0xcc>
        return (OS_ERR_TIME_INVALID_MS);
 321d488:	008014c4 	movi	r2,83
 321d48c:	e0bfff15 	stw	r2,-4(fp)
 321d490:	00002306 	br	321d520 <OSTimeDlyHMSM+0x158>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 321d494:	e0bffb03 	ldbu	r2,-20(fp)
 321d498:	10c38424 	muli	r3,r2,3600
 321d49c:	e0bffc03 	ldbu	r2,-16(fp)
 321d4a0:	10800f24 	muli	r2,r2,60
 321d4a4:	1887883a 	add	r3,r3,r2
 321d4a8:	e0bffd03 	ldbu	r2,-12(fp)
 321d4ac:	1885883a 	add	r2,r3,r2
 321d4b0:	1400fa24 	muli	r16,r2,1000
 321d4b4:	e0bffe0b 	ldhu	r2,-8(fp)
 321d4b8:	1100fa24 	muli	r4,r2,1000
 321d4bc:	0140fa04 	movi	r5,1000
 321d4c0:	32047c00 	call	32047c0 <__udivsi3>
 321d4c4:	8085883a 	add	r2,r16,r2
 321d4c8:	e0bffa15 	stw	r2,-24(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
 321d4cc:	e0bffa17 	ldw	r2,-24(fp)
 321d4d0:	1004d43a 	srli	r2,r2,16
 321d4d4:	e0bff90d 	sth	r2,-28(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
 321d4d8:	e0bffa17 	ldw	r2,-24(fp)
 321d4dc:	10bfffcc 	andi	r2,r2,65535
 321d4e0:	e0bffa15 	stw	r2,-24(fp)
    OSTimeDly((INT16U)ticks);
 321d4e4:	e0bffa17 	ldw	r2,-24(fp)
 321d4e8:	113fffcc 	andi	r4,r2,65535
 321d4ec:	321d27c0 	call	321d27c <OSTimeDly>
    while (loops > 0) {
 321d4f0:	00000706 	br	321d510 <OSTimeDlyHMSM+0x148>
        OSTimeDly((INT16U)32768u);
 321d4f4:	01200014 	movui	r4,32768
 321d4f8:	321d27c0 	call	321d27c <OSTimeDly>
        OSTimeDly((INT16U)32768u);
 321d4fc:	01200014 	movui	r4,32768
 321d500:	321d27c0 	call	321d27c <OSTimeDly>
        loops--;
 321d504:	e0bff90b 	ldhu	r2,-28(fp)
 321d508:	10bfffc4 	addi	r2,r2,-1
 321d50c:	e0bff90d 	sth	r2,-28(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
 321d510:	e0bff90b 	ldhu	r2,-28(fp)
 321d514:	1004c03a 	cmpne	r2,r2,zero
 321d518:	103ff61e 	bne	r2,zero,321d4f4 <OSTimeDlyHMSM+0x12c>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
 321d51c:	e03fff15 	stw	zero,-4(fp)
 321d520:	e0bfff17 	ldw	r2,-4(fp)
}
 321d524:	e037883a 	mov	sp,fp
 321d528:	dfc00217 	ldw	ra,8(sp)
 321d52c:	df000117 	ldw	fp,4(sp)
 321d530:	dc000017 	ldw	r16,0(sp)
 321d534:	dec00304 	addi	sp,sp,12
 321d538:	f800283a 	ret

0321d53c <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
 321d53c:	defff404 	addi	sp,sp,-48
 321d540:	dfc00b15 	stw	ra,44(sp)
 321d544:	df000a15 	stw	fp,40(sp)
 321d548:	df000a04 	addi	fp,sp,40
 321d54c:	e13ffe05 	stb	r4,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 321d550:	e03ffc15 	stw	zero,-16(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
 321d554:	e0bffe03 	ldbu	r2,-8(fp)
 321d558:	10800530 	cmpltui	r2,r2,20
 321d55c:	1000031e 	bne	r2,zero,321d56c <OSTimeDlyResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 321d560:	00800a84 	movi	r2,42
 321d564:	e0bfff15 	stw	r2,-4(fp)
 321d568:	00007206 	br	321d734 <OSTimeDlyResume+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321d56c:	0005303a 	rdctl	r2,status
 321d570:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321d574:	e0fffb17 	ldw	r3,-20(fp)
 321d578:	00bfff84 	movi	r2,-2
 321d57c:	1884703a 	and	r2,r3,r2
 321d580:	1001703a 	wrctl	status,r2
  
  return context;
 321d584:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 321d588:	e0bffc15 	stw	r2,-16(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
 321d58c:	e0bffe03 	ldbu	r2,-8(fp)
 321d590:	00c0c9b4 	movhi	r3,806
 321d594:	18f26b04 	addi	r3,r3,-13908
 321d598:	1085883a 	add	r2,r2,r2
 321d59c:	1085883a 	add	r2,r2,r2
 321d5a0:	10c5883a 	add	r2,r2,r3
 321d5a4:	10800017 	ldw	r2,0(r2)
 321d5a8:	e0bffd15 	stw	r2,-12(fp)
    if (ptcb == (OS_TCB *)0) {
 321d5ac:	e0bffd17 	ldw	r2,-12(fp)
 321d5b0:	1004c03a 	cmpne	r2,r2,zero
 321d5b4:	1000071e 	bne	r2,zero,321d5d4 <OSTimeDlyResume+0x98>
 321d5b8:	e0bffc17 	ldw	r2,-16(fp)
 321d5bc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321d5c0:	e0bffa17 	ldw	r2,-24(fp)
 321d5c4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 321d5c8:	008010c4 	movi	r2,67
 321d5cc:	e0bfff15 	stw	r2,-4(fp)
 321d5d0:	00005806 	br	321d734 <OSTimeDlyResume+0x1f8>
    }
    if (ptcb == OS_TCB_RESERVED) {
 321d5d4:	e0bffd17 	ldw	r2,-12(fp)
 321d5d8:	10800058 	cmpnei	r2,r2,1
 321d5dc:	1000071e 	bne	r2,zero,321d5fc <OSTimeDlyResume+0xc0>
 321d5e0:	e0bffc17 	ldw	r2,-16(fp)
 321d5e4:	e0bff915 	stw	r2,-28(fp)
 321d5e8:	e0bff917 	ldw	r2,-28(fp)
 321d5ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 321d5f0:	008010c4 	movi	r2,67
 321d5f4:	e0bfff15 	stw	r2,-4(fp)
 321d5f8:	00004e06 	br	321d734 <OSTimeDlyResume+0x1f8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
 321d5fc:	e0bffd17 	ldw	r2,-12(fp)
 321d600:	10800b8b 	ldhu	r2,46(r2)
 321d604:	10bfffcc 	andi	r2,r2,65535
 321d608:	1004c03a 	cmpne	r2,r2,zero
 321d60c:	1000071e 	bne	r2,zero,321d62c <OSTimeDlyResume+0xf0>
 321d610:	e0bffc17 	ldw	r2,-16(fp)
 321d614:	e0bff815 	stw	r2,-32(fp)
 321d618:	e0bff817 	ldw	r2,-32(fp)
 321d61c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
 321d620:	00801404 	movi	r2,80
 321d624:	e0bfff15 	stw	r2,-4(fp)
 321d628:	00004206 	br	321d734 <OSTimeDlyResume+0x1f8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
 321d62c:	e0bffd17 	ldw	r2,-12(fp)
 321d630:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 321d634:	e0bffd17 	ldw	r2,-12(fp)
 321d638:	10800c03 	ldbu	r2,48(r2)
 321d63c:	10803fcc 	andi	r2,r2,255
 321d640:	10800dcc 	andi	r2,r2,55
 321d644:	1005003a 	cmpeq	r2,r2,zero
 321d648:	10000b1e 	bne	r2,zero,321d678 <OSTimeDlyResume+0x13c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
 321d64c:	e0bffd17 	ldw	r2,-12(fp)
 321d650:	10c00c03 	ldbu	r3,48(r2)
 321d654:	00bff204 	movi	r2,-56
 321d658:	1884703a 	and	r2,r3,r2
 321d65c:	1007883a 	mov	r3,r2
 321d660:	e0bffd17 	ldw	r2,-12(fp)
 321d664:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
 321d668:	e0fffd17 	ldw	r3,-12(fp)
 321d66c:	00800044 	movi	r2,1
 321d670:	18800c45 	stb	r2,49(r3)
 321d674:	00000206 	br	321d680 <OSTimeDlyResume+0x144>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
 321d678:	e0bffd17 	ldw	r2,-12(fp)
 321d67c:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
 321d680:	e0bffd17 	ldw	r2,-12(fp)
 321d684:	10800c03 	ldbu	r2,48(r2)
 321d688:	10803fcc 	andi	r2,r2,255
 321d68c:	1080020c 	andi	r2,r2,8
 321d690:	1004c03a 	cmpne	r2,r2,zero
 321d694:	1000221e 	bne	r2,zero,321d720 <OSTimeDlyResume+0x1e4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
 321d698:	e0bffd17 	ldw	r2,-12(fp)
 321d69c:	10c00d83 	ldbu	r3,54(r2)
 321d6a0:	0080c974 	movhi	r2,805
 321d6a4:	10931204 	addi	r2,r2,19528
 321d6a8:	10800003 	ldbu	r2,0(r2)
 321d6ac:	1884b03a 	or	r2,r3,r2
 321d6b0:	1007883a 	mov	r3,r2
 321d6b4:	0080c974 	movhi	r2,805
 321d6b8:	10931204 	addi	r2,r2,19528
 321d6bc:	10c00005 	stb	r3,0(r2)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 321d6c0:	e0bffd17 	ldw	r2,-12(fp)
 321d6c4:	10800d03 	ldbu	r2,52(r2)
 321d6c8:	11003fcc 	andi	r4,r2,255
 321d6cc:	e0bffd17 	ldw	r2,-12(fp)
 321d6d0:	10800d03 	ldbu	r2,52(r2)
 321d6d4:	10c03fcc 	andi	r3,r2,255
 321d6d8:	0080c974 	movhi	r2,805
 321d6dc:	10931244 	addi	r2,r2,19529
 321d6e0:	10c5883a 	add	r2,r2,r3
 321d6e4:	10c00003 	ldbu	r3,0(r2)
 321d6e8:	e0bffd17 	ldw	r2,-12(fp)
 321d6ec:	10800d43 	ldbu	r2,53(r2)
 321d6f0:	1884b03a 	or	r2,r3,r2
 321d6f4:	1007883a 	mov	r3,r2
 321d6f8:	0080c974 	movhi	r2,805
 321d6fc:	10931244 	addi	r2,r2,19529
 321d700:	1105883a 	add	r2,r2,r4
 321d704:	10c00005 	stb	r3,0(r2)
 321d708:	e0bffc17 	ldw	r2,-16(fp)
 321d70c:	e0bff715 	stw	r2,-36(fp)
 321d710:	e0bff717 	ldw	r2,-36(fp)
 321d714:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
 321d718:	3216f880 	call	3216f88 <OS_Sched>
 321d71c:	00000406 	br	321d730 <OSTimeDlyResume+0x1f4>
 321d720:	e0bffc17 	ldw	r2,-16(fp)
 321d724:	e0bff615 	stw	r2,-40(fp)
 321d728:	e0bff617 	ldw	r2,-40(fp)
 321d72c:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
 321d730:	e03fff15 	stw	zero,-4(fp)
 321d734:	e0bfff17 	ldw	r2,-4(fp)
}
 321d738:	e037883a 	mov	sp,fp
 321d73c:	dfc00117 	ldw	ra,4(sp)
 321d740:	df000017 	ldw	fp,0(sp)
 321d744:	dec00204 	addi	sp,sp,8
 321d748:	f800283a 	ret

0321d74c <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
 321d74c:	defffb04 	addi	sp,sp,-20
 321d750:	df000415 	stw	fp,16(sp)
 321d754:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 321d758:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321d75c:	0005303a 	rdctl	r2,status
 321d760:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321d764:	e0fffd17 	ldw	r3,-12(fp)
 321d768:	00bfff84 	movi	r2,-2
 321d76c:	1884703a 	and	r2,r3,r2
 321d770:	1001703a 	wrctl	status,r2
  
  return context;
 321d774:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 321d778:	e0bffe15 	stw	r2,-8(fp)
    ticks = OSTime;
 321d77c:	0080c974 	movhi	r2,805
 321d780:	10931604 	addi	r2,r2,19544
 321d784:	10800017 	ldw	r2,0(r2)
 321d788:	e0bfff15 	stw	r2,-4(fp)
 321d78c:	e0bffe17 	ldw	r2,-8(fp)
 321d790:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321d794:	e0bffc17 	ldw	r2,-16(fp)
 321d798:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
 321d79c:	e0bfff17 	ldw	r2,-4(fp)
}
 321d7a0:	e037883a 	mov	sp,fp
 321d7a4:	df000017 	ldw	fp,0(sp)
 321d7a8:	dec00104 	addi	sp,sp,4
 321d7ac:	f800283a 	ret

0321d7b0 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
 321d7b0:	defffb04 	addi	sp,sp,-20
 321d7b4:	df000415 	stw	fp,16(sp)
 321d7b8:	df000404 	addi	fp,sp,16
 321d7bc:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 321d7c0:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 321d7c4:	0005303a 	rdctl	r2,status
 321d7c8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 321d7cc:	e0fffd17 	ldw	r3,-12(fp)
 321d7d0:	00bfff84 	movi	r2,-2
 321d7d4:	1884703a 	and	r2,r3,r2
 321d7d8:	1001703a 	wrctl	status,r2
  
  return context;
 321d7dc:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 321d7e0:	e0bffe15 	stw	r2,-8(fp)
    OSTime = ticks;
 321d7e4:	00c0c974 	movhi	r3,805
 321d7e8:	18d31604 	addi	r3,r3,19544
 321d7ec:	e0bfff17 	ldw	r2,-4(fp)
 321d7f0:	18800015 	stw	r2,0(r3)
 321d7f4:	e0bffe17 	ldw	r2,-8(fp)
 321d7f8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 321d7fc:	e0bffc17 	ldw	r2,-16(fp)
 321d800:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 321d804:	e037883a 	mov	sp,fp
 321d808:	df000017 	ldw	fp,0(sp)
 321d80c:	dec00104 	addi	sp,sp,4
 321d810:	f800283a 	ret

0321d814 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 321d814:	defffd04 	addi	sp,sp,-12
 321d818:	dfc00215 	stw	ra,8(sp)
 321d81c:	df000115 	stw	fp,4(sp)
 321d820:	df000104 	addi	fp,sp,4
 321d824:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_IRQ_INIT ( CPU, cpu);
 321d828:	323b4640 	call	323b464 <altera_nios2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 321d82c:	00800044 	movi	r2,1
 321d830:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 321d834:	e037883a 	mov	sp,fp
 321d838:	dfc00117 	ldw	ra,4(sp)
 321d83c:	df000017 	ldw	fp,0(sp)
 321d840:	dec00204 	addi	sp,sp,8
 321d844:	f800283a 	ret

0321d848 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 321d848:	defffc04 	addi	sp,sp,-16
 321d84c:	dfc00315 	stw	ra,12(sp)
 321d850:	df000215 	stw	fp,8(sp)
 321d854:	df000204 	addi	fp,sp,8
    ALTERA_AVALON_TIMER_INIT ( TIMER, timer);
 321d858:	01004034 	movhi	r4,256
 321d85c:	21018004 	addi	r4,r4,1536
 321d860:	000b883a 	mov	r5,zero
 321d864:	01800044 	movi	r6,1
 321d868:	01c0fa04 	movi	r7,1000
 321d86c:	32214200 	call	3221420 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_CFI_FLASH_INIT ( EXT_FLASH, ext_flash);
 321d870:	0100c974 	movhi	r4,805
 321d874:	21049404 	addi	r4,r4,4688
 321d878:	321d9500 	call	321d950 <alt_flash_cfi_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
 321d87c:	0100c974 	movhi	r4,805
 321d880:	2104d404 	addi	r4,r4,4944
 321d884:	000b883a 	mov	r5,zero
 321d888:	000d883a 	mov	r6,zero
 321d88c:	321f8080 	call	321f808 <altera_avalon_jtag_uart_init>
 321d890:	0100c974 	movhi	r4,805
 321d894:	2104ca04 	addi	r4,r4,4904
 321d898:	321d9180 	call	321d918 <alt_dev_reg>
    ALTERA_AVALON_LCD_16207_INIT ( LCD, lcd);
 321d89c:	0100c974 	movhi	r4,805
 321d8a0:	2108ef04 	addi	r4,r4,9148
 321d8a4:	32211f00 	call	32211f0 <altera_avalon_lcd_16207_init>
 321d8a8:	0100c974 	movhi	r4,805
 321d8ac:	2108e504 	addi	r4,r4,9108
 321d8b0:	321d9180 	call	321d918 <alt_dev_reg>
 321d8b4:	0080c974 	movhi	r2,805
 321d8b8:	108a8c04 	addi	r2,r2,10800
 321d8bc:	e0bffe15 	stw	r2,-8(fp)
 321d8c0:	0080c974 	movhi	r2,805
 321d8c4:	10892e04 	addi	r2,r2,9400
 321d8c8:	e0bfff15 	stw	r2,-4(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 321d8cc:	e0ffff17 	ldw	r3,-4(fp)
 321d8d0:	e0bffe17 	ldw	r2,-8(fp)
 321d8d4:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 321d8d8:	e0bffe17 	ldw	r2,-8(fp)
 321d8dc:	10c00017 	ldw	r3,0(r2)
 321d8e0:	e0bfff17 	ldw	r2,-4(fp)
 321d8e4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 321d8e8:	e0bffe17 	ldw	r2,-8(fp)
 321d8ec:	10c00017 	ldw	r3,0(r2)
 321d8f0:	e0bfff17 	ldw	r2,-4(fp)
 321d8f4:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 321d8f8:	e0fffe17 	ldw	r3,-8(fp)
 321d8fc:	e0bfff17 	ldw	r2,-4(fp)
 321d900:	18800015 	stw	r2,0(r3)
    ALTERA_AVALON_SYSID_INIT ( SYSID, sysid);
    ETH_OCM_INIT ( ETH_OCM_0, eth_ocm_0);
}
 321d904:	e037883a 	mov	sp,fp
 321d908:	dfc00117 	ldw	ra,4(sp)
 321d90c:	df000017 	ldw	fp,0(sp)
 321d910:	dec00204 	addi	sp,sp,8
 321d914:	f800283a 	ret

0321d918 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 321d918:	defffd04 	addi	sp,sp,-12
 321d91c:	dfc00215 	stw	ra,8(sp)
 321d920:	df000115 	stw	fp,4(sp)
 321d924:	df000104 	addi	fp,sp,4
 321d928:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 321d92c:	e13fff17 	ldw	r4,-4(fp)
 321d930:	0140c974 	movhi	r5,805
 321d934:	294aa204 	addi	r5,r5,10888
 321d938:	323a67c0 	call	323a67c <alt_dev_llist_insert>
}
 321d93c:	e037883a 	mov	sp,fp
 321d940:	dfc00117 	ldw	ra,4(sp)
 321d944:	df000017 	ldw	fp,0(sp)
 321d948:	dec00204 	addi	sp,sp,8
 321d94c:	f800283a 	ret

0321d950 <alt_flash_cfi_init>:
 * Read the CFI table and fill out the alt_flash_cfi_dev structure with all the 
 * information we need to program the flash.
 * 
 */
int alt_flash_cfi_init( alt_flash_cfi_dev* flash  )
{
 321d950:	defffc04 	addi	sp,sp,-16
 321d954:	dfc00315 	stw	ra,12(sp)
 321d958:	df000215 	stw	fp,8(sp)
 321d95c:	df000204 	addi	fp,sp,8
 321d960:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 321d964:	e03ffe15 	stw	zero,-8(fp)
 
  ret_code = alt_read_cfi_width( flash );
 321d968:	e13fff17 	ldw	r4,-4(fp)
 321d96c:	321ee380 	call	321ee38 <alt_read_cfi_width>
 321d970:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 321d974:	e0bffe17 	ldw	r2,-8(fp)
 321d978:	1004c03a 	cmpne	r2,r2,zero
 321d97c:	1000031e 	bne	r2,zero,321d98c <alt_flash_cfi_init+0x3c>
    ret_code = alt_set_flash_width_func( flash );
 321d980:	e13fff17 	ldw	r4,-4(fp)
 321d984:	321e5500 	call	321e550 <alt_set_flash_width_func>
 321d988:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 321d98c:	e0bffe17 	ldw	r2,-8(fp)
 321d990:	1004c03a 	cmpne	r2,r2,zero
 321d994:	1000031e 	bne	r2,zero,321d9a4 <alt_flash_cfi_init+0x54>
    ret_code = alt_read_cfi_table( flash );
 321d998:	e13fff17 	ldw	r4,-4(fp)
 321d99c:	321e8580 	call	321e858 <alt_read_cfi_table>
 321d9a0:	e0bffe15 	stw	r2,-8(fp)

  if (!ret_code) 
 321d9a4:	e0bffe17 	ldw	r2,-8(fp)
 321d9a8:	1004c03a 	cmpne	r2,r2,zero
 321d9ac:	1000031e 	bne	r2,zero,321d9bc <alt_flash_cfi_init+0x6c>
    ret_code = alt_set_flash_algorithm_func( flash);
 321d9b0:	e13fff17 	ldw	r4,-4(fp)
 321d9b4:	321e7300 	call	321e730 <alt_set_flash_algorithm_func>
 321d9b8:	e0bffe15 	stw	r2,-8(fp)

  /*
  *  Register this device as a valid flash device type
  */ 
  if (!ret_code)
 321d9bc:	e0bffe17 	ldw	r2,-8(fp)
 321d9c0:	1004c03a 	cmpne	r2,r2,zero
 321d9c4:	1000031e 	bne	r2,zero,321d9d4 <alt_flash_cfi_init+0x84>
    ret_code = alt_flash_device_register(&(flash->dev));
 321d9c8:	e13fff17 	ldw	r4,-4(fp)
 321d9cc:	321d9ec0 	call	321d9ec <alt_flash_device_register>
 321d9d0:	e0bffe15 	stw	r2,-8(fp)
 
  return ret_code;
 321d9d4:	e0bffe17 	ldw	r2,-8(fp)
}
 321d9d8:	e037883a 	mov	sp,fp
 321d9dc:	dfc00117 	ldw	ra,4(sp)
 321d9e0:	df000017 	ldw	fp,0(sp)
 321d9e4:	dec00204 	addi	sp,sp,8
 321d9e8:	f800283a 	ret

0321d9ec <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
 321d9ec:	defffd04 	addi	sp,sp,-12
 321d9f0:	dfc00215 	stw	ra,8(sp)
 321d9f4:	df000115 	stw	fp,4(sp)
 321d9f8:	df000104 	addi	fp,sp,4
 321d9fc:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
 321da00:	e13fff17 	ldw	r4,-4(fp)
 321da04:	0140c974 	movhi	r5,805
 321da08:	294a6904 	addi	r5,r5,10660
 321da0c:	323a67c0 	call	323a67c <alt_dev_llist_insert>
}
 321da10:	e037883a 	mov	sp,fp
 321da14:	dfc00117 	ldw	ra,4(sp)
 321da18:	df000017 	ldw	fp,0(sp)
 321da1c:	dec00204 	addi	sp,sp,8
 321da20:	f800283a 	ret

0321da24 <alt_flash_cfi_write>:
 * large buffer to tie up in our programming library, when not all users will 
 * want that functionality.
 */
 int alt_flash_cfi_write( alt_flash_dev* flash_info, int offset, 
                          const void* src_addr, int length )
 {
 321da24:	deffef04 	addi	sp,sp,-68
 321da28:	dfc01015 	stw	ra,64(sp)
 321da2c:	df000f15 	stw	fp,60(sp)
 321da30:	df000f04 	addi	fp,sp,60
 321da34:	e13ffa15 	stw	r4,-24(fp)
 321da38:	e17ffb15 	stw	r5,-20(fp)
 321da3c:	e1bffc15 	stw	r6,-16(fp)
 321da40:	e1fffd15 	stw	r7,-12(fp)
  int         ret_code = 0;
 321da44:	e03ff915 	stw	zero,-28(fp)
  int         i,j;
  int         data_to_write;
  int         full_length = length;
 321da48:	e0bffd17 	ldw	r2,-12(fp)
 321da4c:	e0bff515 	stw	r2,-44(fp)
  int         current_offset;
  int         start_offset = offset;
 321da50:	e0bffb17 	ldw	r2,-20(fp)
 321da54:	e0bff315 	stw	r2,-52(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 321da58:	e0bffa17 	ldw	r2,-24(fp)
 321da5c:	e0bff215 	stw	r2,-56(fp)

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 321da60:	e03ff815 	stw	zero,-32(fp)
 321da64:	00008e06 	br	321dca0 <alt_flash_cfi_write+0x27c>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash->dev.region_info[i].offset) &&
 321da68:	e0bff817 	ldw	r2,-32(fp)
 321da6c:	e0fff217 	ldw	r3,-56(fp)
 321da70:	1004913a 	slli	r2,r2,4
 321da74:	10c5883a 	add	r2,r2,r3
 321da78:	10800d04 	addi	r2,r2,52
 321da7c:	10c00017 	ldw	r3,0(r2)
 321da80:	e0bffb17 	ldw	r2,-20(fp)
 321da84:	10c08316 	blt	r2,r3,321dc94 <alt_flash_cfi_write+0x270>
 321da88:	e0bff817 	ldw	r2,-32(fp)
 321da8c:	e0fff217 	ldw	r3,-56(fp)
 321da90:	1004913a 	slli	r2,r2,4
 321da94:	10c5883a 	add	r2,r2,r3
 321da98:	10800d04 	addi	r2,r2,52
 321da9c:	11000017 	ldw	r4,0(r2)
 321daa0:	e0bff817 	ldw	r2,-32(fp)
 321daa4:	e0fff217 	ldw	r3,-56(fp)
 321daa8:	1004913a 	slli	r2,r2,4
 321daac:	10c5883a 	add	r2,r2,r3
 321dab0:	10800e04 	addi	r2,r2,56
 321dab4:	10800017 	ldw	r2,0(r2)
 321dab8:	2087883a 	add	r3,r4,r2
 321dabc:	e0bffb17 	ldw	r2,-20(fp)
 321dac0:	10c0740e 	bge	r2,r3,321dc94 <alt_flash_cfi_write+0x270>
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;
 321dac4:	e0bff817 	ldw	r2,-32(fp)
 321dac8:	e0fff217 	ldw	r3,-56(fp)
 321dacc:	1004913a 	slli	r2,r2,4
 321dad0:	10c5883a 	add	r2,r2,r3
 321dad4:	10800d04 	addi	r2,r2,52
 321dad8:	10800017 	ldw	r2,0(r2)
 321dadc:	e0bff415 	stw	r2,-48(fp)

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 321dae0:	e03ff715 	stw	zero,-36(fp)
 321dae4:	00006306 	br	321dc74 <alt_flash_cfi_write+0x250>
      {
        if ((offset >= current_offset ) && 
 321dae8:	e0fffb17 	ldw	r3,-20(fp)
 321daec:	e0bff417 	ldw	r2,-48(fp)
 321daf0:	18805416 	blt	r3,r2,321dc44 <alt_flash_cfi_write+0x220>
 321daf4:	e0bff817 	ldw	r2,-32(fp)
 321daf8:	e0fff217 	ldw	r3,-56(fp)
 321dafc:	1004913a 	slli	r2,r2,4
 321db00:	10c5883a 	add	r2,r2,r3
 321db04:	10801004 	addi	r2,r2,64
 321db08:	10c00017 	ldw	r3,0(r2)
 321db0c:	e0bff417 	ldw	r2,-48(fp)
 321db10:	1887883a 	add	r3,r3,r2
 321db14:	e0bffb17 	ldw	r2,-20(fp)
 321db18:	10c04a0e 	bge	r2,r3,321dc44 <alt_flash_cfi_write+0x220>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash->dev.region_info[i].block_size 
 321db1c:	e0bff817 	ldw	r2,-32(fp)
 321db20:	e0fff217 	ldw	r3,-56(fp)
 321db24:	1004913a 	slli	r2,r2,4
 321db28:	10c5883a 	add	r2,r2,r3
 321db2c:	10801004 	addi	r2,r2,64
 321db30:	10c00017 	ldw	r3,0(r2)
 321db34:	e0bff417 	ldw	r2,-48(fp)
 321db38:	1887883a 	add	r3,r3,r2
 321db3c:	e0bffb17 	ldw	r2,-20(fp)
 321db40:	1885c83a 	sub	r2,r3,r2
 321db44:	e0bff615 	stw	r2,-40(fp)
                            - offset); 
          data_to_write = MIN(data_to_write, length);
 321db48:	e0bff617 	ldw	r2,-40(fp)
 321db4c:	e0bfff15 	stw	r2,-4(fp)
 321db50:	e0fffd17 	ldw	r3,-12(fp)
 321db54:	e0fffe15 	stw	r3,-8(fp)
 321db58:	e0bfff17 	ldw	r2,-4(fp)
 321db5c:	e0fffe17 	ldw	r3,-8(fp)
 321db60:	10c0020e 	bge	r2,r3,321db6c <alt_flash_cfi_write+0x148>
 321db64:	e0bfff17 	ldw	r2,-4(fp)
 321db68:	e0bffe15 	stw	r2,-8(fp)
 321db6c:	e0fffe17 	ldw	r3,-8(fp)
 321db70:	e0fff615 	stw	r3,-40(fp)
          if(memcmp(src_addr, 
 321db74:	e0bff217 	ldw	r2,-56(fp)
 321db78:	10800a17 	ldw	r2,40(r2)
 321db7c:	1007883a 	mov	r3,r2
 321db80:	e0bffb17 	ldw	r2,-20(fp)
 321db84:	188b883a 	add	r5,r3,r2
 321db88:	e1bff617 	ldw	r6,-40(fp)
 321db8c:	e13ffc17 	ldw	r4,-16(fp)
 321db90:	324bcc00 	call	324bcc0 <memcmp>
 321db94:	1005003a 	cmpeq	r2,r2,zero
 321db98:	1000131e 	bne	r2,zero,321dbe8 <alt_flash_cfi_write+0x1c4>
                    (alt_u8*)flash->dev.base_addr+offset,
                    data_to_write))
          {
            ret_code = (*flash->dev.erase_block)( &flash->dev, current_offset);
 321db9c:	e0bff217 	ldw	r2,-56(fp)
 321dba0:	10800817 	ldw	r2,32(r2)
 321dba4:	e13ff217 	ldw	r4,-56(fp)
 321dba8:	e17ff417 	ldw	r5,-48(fp)
 321dbac:	103ee83a 	callr	r2
 321dbb0:	e0bff915 	stw	r2,-28(fp)

            if (!ret_code)
 321dbb4:	e0bff917 	ldw	r2,-28(fp)
 321dbb8:	1004c03a 	cmpne	r2,r2,zero
 321dbbc:	10000a1e 	bne	r2,zero,321dbe8 <alt_flash_cfi_write+0x1c4>
            {
              ret_code = (*flash->dev.write_block)( 
 321dbc0:	e0bff217 	ldw	r2,-56(fp)
 321dbc4:	10c00917 	ldw	r3,36(r2)
 321dbc8:	e13ff217 	ldw	r4,-56(fp)
 321dbcc:	e0bff617 	ldw	r2,-40(fp)
 321dbd0:	d8800015 	stw	r2,0(sp)
 321dbd4:	e17ff417 	ldw	r5,-48(fp)
 321dbd8:	e1bffb17 	ldw	r6,-20(fp)
 321dbdc:	e1fffc17 	ldw	r7,-16(fp)
 321dbe0:	183ee83a 	callr	r3
 321dbe4:	e0bff915 	stw	r2,-28(fp)
                                                  data_to_write);
            }
          }    
    
          /* Was this the last block? */    
          if ((length == data_to_write) || ret_code)
 321dbe8:	e0fffd17 	ldw	r3,-12(fp)
 321dbec:	e0bff617 	ldw	r2,-40(fp)
 321dbf0:	18802f26 	beq	r3,r2,321dcb0 <alt_flash_cfi_write+0x28c>
 321dbf4:	e0bff917 	ldw	r2,-28(fp)
 321dbf8:	1004c03a 	cmpne	r2,r2,zero
 321dbfc:	10002c1e 	bne	r2,zero,321dcb0 <alt_flash_cfi_write+0x28c>
          {
            goto finished;
          }
          
          length -= data_to_write;
 321dc00:	e0fffd17 	ldw	r3,-12(fp)
 321dc04:	e0bff617 	ldw	r2,-40(fp)
 321dc08:	1885c83a 	sub	r2,r3,r2
 321dc0c:	e0bffd15 	stw	r2,-12(fp)
          offset = current_offset + flash->dev.region_info[i].block_size;
 321dc10:	e0bff817 	ldw	r2,-32(fp)
 321dc14:	e0fff217 	ldw	r3,-56(fp)
 321dc18:	1004913a 	slli	r2,r2,4
 321dc1c:	10c5883a 	add	r2,r2,r3
 321dc20:	10801004 	addi	r2,r2,64
 321dc24:	10c00017 	ldw	r3,0(r2)
 321dc28:	e0bff417 	ldw	r2,-48(fp)
 321dc2c:	1885883a 	add	r2,r3,r2
 321dc30:	e0bffb15 	stw	r2,-20(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
 321dc34:	e0fffc17 	ldw	r3,-16(fp)
 321dc38:	e0bff617 	ldw	r2,-40(fp)
 321dc3c:	1885883a 	add	r2,r3,r2
 321dc40:	e0bffc15 	stw	r2,-16(fp)
        }
        current_offset += flash->dev.region_info[i].block_size;
 321dc44:	e0bff817 	ldw	r2,-32(fp)
 321dc48:	e0fff217 	ldw	r3,-56(fp)
 321dc4c:	1004913a 	slli	r2,r2,4
 321dc50:	10c5883a 	add	r2,r2,r3
 321dc54:	10801004 	addi	r2,r2,64
 321dc58:	10c00017 	ldw	r3,0(r2)
 321dc5c:	e0bff417 	ldw	r2,-48(fp)
 321dc60:	10c5883a 	add	r2,r2,r3
 321dc64:	e0bff415 	stw	r2,-48(fp)
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 321dc68:	e0bff717 	ldw	r2,-36(fp)
 321dc6c:	10800044 	addi	r2,r2,1
 321dc70:	e0bff715 	stw	r2,-36(fp)
 321dc74:	e0bff817 	ldw	r2,-32(fp)
 321dc78:	e0fff217 	ldw	r3,-56(fp)
 321dc7c:	1004913a 	slli	r2,r2,4
 321dc80:	10c5883a 	add	r2,r2,r3
 321dc84:	10800f04 	addi	r2,r2,60
 321dc88:	10c00017 	ldw	r3,0(r2)
 321dc8c:	e0bff717 	ldw	r2,-36(fp)
 321dc90:	10ff9516 	blt	r2,r3,321dae8 <alt_flash_cfi_write+0xc4>
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 321dc94:	e0bff817 	ldw	r2,-32(fp)
 321dc98:	10800044 	addi	r2,r2,1
 321dc9c:	e0bff815 	stw	r2,-32(fp)
 321dca0:	e0bff217 	ldw	r2,-56(fp)
 321dca4:	10c00c17 	ldw	r3,48(r2)
 321dca8:	e0bff817 	ldw	r2,-32(fp)
 321dcac:	10ff6e16 	blt	r2,r3,321da68 <alt_flash_cfi_write+0x44>
      }     
    } 
  }
finished:    

  alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
 321dcb0:	e0bff217 	ldw	r2,-56(fp)
 321dcb4:	10800a17 	ldw	r2,40(r2)
 321dcb8:	1007883a 	mov	r3,r2
 321dcbc:	e0bff317 	ldw	r2,-52(fp)
 321dcc0:	1889883a 	add	r4,r3,r2
 321dcc4:	e17ff517 	ldw	r5,-44(fp)
 321dcc8:	323a5940 	call	323a594 <alt_dcache_flush>
  return ret_code;
 321dccc:	e0bff917 	ldw	r2,-28(fp)
}
 321dcd0:	e037883a 	mov	sp,fp
 321dcd4:	dfc00117 	ldw	ra,4(sp)
 321dcd8:	df000017 	ldw	fp,0(sp)
 321dcdc:	dec00204 	addi	sp,sp,8
 321dce0:	f800283a 	ret

0321dce4 <alt_flash_cfi_get_info>:
 * 
 *  Pass the table of erase blocks to the user
 */
int alt_flash_cfi_get_info( alt_flash_fd* fd, flash_region** info, 
                            int* number_of_regions)
{
 321dce4:	defffa04 	addi	sp,sp,-24
 321dce8:	df000515 	stw	fp,20(sp)
 321dcec:	df000504 	addi	fp,sp,20
 321dcf0:	e13ffd15 	stw	r4,-12(fp)
 321dcf4:	e17ffe15 	stw	r5,-8(fp)
 321dcf8:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 321dcfc:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_dev* flash = (alt_flash_dev*)fd;
 321dd00:	e0bffd17 	ldw	r2,-12(fp)
 321dd04:	e0bffb15 	stw	r2,-20(fp)

  *number_of_regions = flash->number_of_regions;
 321dd08:	e0bffb17 	ldw	r2,-20(fp)
 321dd0c:	10c00c17 	ldw	r3,48(r2)
 321dd10:	e0bfff17 	ldw	r2,-4(fp)
 321dd14:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
 321dd18:	e0bffb17 	ldw	r2,-20(fp)
 321dd1c:	10800c17 	ldw	r2,48(r2)
 321dd20:	1004c03a 	cmpne	r2,r2,zero
 321dd24:	1000031e 	bne	r2,zero,321dd34 <alt_flash_cfi_get_info+0x50>
  {
    ret_code = -EIO;
 321dd28:	00bffec4 	movi	r2,-5
 321dd2c:	e0bffc15 	stw	r2,-16(fp)
 321dd30:	00000b06 	br	321dd60 <alt_flash_cfi_get_info+0x7c>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 321dd34:	e0bffb17 	ldw	r2,-20(fp)
 321dd38:	10800c17 	ldw	r2,48(r2)
 321dd3c:	10800250 	cmplti	r2,r2,9
 321dd40:	1000031e 	bne	r2,zero,321dd50 <alt_flash_cfi_get_info+0x6c>
  {
    ret_code = -ENOMEM;
 321dd44:	00bffd04 	movi	r2,-12
 321dd48:	e0bffc15 	stw	r2,-16(fp)
 321dd4c:	00000406 	br	321dd60 <alt_flash_cfi_get_info+0x7c>
  }
  else
  {
    *info = &flash->region_info[0];
 321dd50:	e0bffb17 	ldw	r2,-20(fp)
 321dd54:	10c00d04 	addi	r3,r2,52
 321dd58:	e0bffe17 	ldw	r2,-8(fp)
 321dd5c:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
 321dd60:	e0bffc17 	ldw	r2,-16(fp)
}
 321dd64:	e037883a 	mov	sp,fp
 321dd68:	df000017 	ldw	fp,0(sp)
 321dd6c:	dec00104 	addi	sp,sp,4
 321dd70:	f800283a 	ret

0321dd74 <alt_flash_cfi_read>:
 *  Read from an area in flash, you could use memcopy yourself
 *  for these flash types, but we're trying to be generic and future proof
 */
int alt_flash_cfi_read( alt_flash_dev* flash_info, int offset, 
                        void* dest_addr, int length )
{
 321dd74:	defff904 	addi	sp,sp,-28
 321dd78:	dfc00615 	stw	ra,24(sp)
 321dd7c:	df000515 	stw	fp,20(sp)
 321dd80:	df000504 	addi	fp,sp,20
 321dd84:	e13ffc15 	stw	r4,-16(fp)
 321dd88:	e17ffd15 	stw	r5,-12(fp)
 321dd8c:	e1bffe15 	stw	r6,-8(fp)
 321dd90:	e1ffff15 	stw	r7,-4(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 321dd94:	e0bffc17 	ldw	r2,-16(fp)
 321dd98:	e0bffb15 	stw	r2,-20(fp)
  memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
 321dd9c:	e0bffb17 	ldw	r2,-20(fp)
 321dda0:	10800a17 	ldw	r2,40(r2)
 321dda4:	1007883a 	mov	r3,r2
 321dda8:	e0bffd17 	ldw	r2,-12(fp)
 321ddac:	1887883a 	add	r3,r3,r2
 321ddb0:	e1bfff17 	ldw	r6,-4(fp)
 321ddb4:	e0bffe17 	ldw	r2,-8(fp)
 321ddb8:	1009883a 	mov	r4,r2
 321ddbc:	180b883a 	mov	r5,r3
 321ddc0:	3206ad00 	call	3206ad0 <memcpy>
  return 0;
 321ddc4:	0005883a 	mov	r2,zero
}
 321ddc8:	e037883a 	mov	sp,fp
 321ddcc:	dfc00117 	ldw	ra,4(sp)
 321ddd0:	df000017 	ldw	fp,0(sp)
 321ddd4:	dec00204 	addi	sp,sp,8
 321ddd8:	f800283a 	ret

0321dddc <alt_write_value_to_flash>:
* It writes the largest word size that the flash can support
* so if it's an 8 bit flash it writes bytes
* 16 bit half word etc.
*/
void alt_write_value_to_flash(alt_flash_cfi_dev* flash, int offset, const alt_u8* src_addr)
{
 321dddc:	defffa04 	addi	sp,sp,-24
 321dde0:	df000515 	stw	fp,20(sp)
 321dde4:	df000504 	addi	fp,sp,20
 321dde8:	e13ffd15 	stw	r4,-12(fp)
 321ddec:	e17ffe15 	stw	r5,-8(fp)
 321ddf0:	e1bfff15 	stw	r6,-4(fp)
  alt_u16 half_word_value;
  alt_u32 word_value;

  if (flash->mode_width == 1)
 321ddf4:	e0bffd17 	ldw	r2,-12(fp)
 321ddf8:	10802e17 	ldw	r2,184(r2)
 321ddfc:	10800058 	cmpnei	r2,r2,1
 321de00:	10000b1e 	bne	r2,zero,321de30 <alt_write_value_to_flash+0x54>
  {
    IOWR_8DIRECT(flash->dev.base_addr, offset, *src_addr);
 321de04:	e0bffd17 	ldw	r2,-12(fp)
 321de08:	10800a17 	ldw	r2,40(r2)
 321de0c:	1007883a 	mov	r3,r2
 321de10:	e0bffe17 	ldw	r2,-8(fp)
 321de14:	1889883a 	add	r4,r3,r2
 321de18:	e0bfff17 	ldw	r2,-4(fp)
 321de1c:	10800003 	ldbu	r2,0(r2)
 321de20:	10c03fcc 	andi	r3,r2,255
 321de24:	2005883a 	mov	r2,r4
 321de28:	10c00025 	stbio	r3,0(r2)
 321de2c:	00004006 	br	321df30 <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 2)
 321de30:	e0bffd17 	ldw	r2,-12(fp)
 321de34:	10802e17 	ldw	r2,184(r2)
 321de38:	10800098 	cmpnei	r2,r2,2
 321de3c:	1000151e 	bne	r2,zero,321de94 <alt_write_value_to_flash+0xb8>
  {
    half_word_value = (alt_u16)(*src_addr);
 321de40:	e0bfff17 	ldw	r2,-4(fp)
 321de44:	10800003 	ldbu	r2,0(r2)
 321de48:	10803fcc 	andi	r2,r2,255
 321de4c:	e0bffc0d 	sth	r2,-16(fp)
    half_word_value |= (alt_u16)(*(src_addr + 1)) << 8;
 321de50:	e0bfff17 	ldw	r2,-4(fp)
 321de54:	10800044 	addi	r2,r2,1
 321de58:	10800003 	ldbu	r2,0(r2)
 321de5c:	10803fcc 	andi	r2,r2,255
 321de60:	1004923a 	slli	r2,r2,8
 321de64:	1007883a 	mov	r3,r2
 321de68:	e0bffc0b 	ldhu	r2,-16(fp)
 321de6c:	1884b03a 	or	r2,r3,r2
 321de70:	e0bffc0d 	sth	r2,-16(fp)
    IOWR_16DIRECT(flash->dev.base_addr, offset, half_word_value);
 321de74:	e0bffd17 	ldw	r2,-12(fp)
 321de78:	10800a17 	ldw	r2,40(r2)
 321de7c:	1007883a 	mov	r3,r2
 321de80:	e0bffe17 	ldw	r2,-8(fp)
 321de84:	1885883a 	add	r2,r3,r2
 321de88:	e0fffc0b 	ldhu	r3,-16(fp)
 321de8c:	10c0002d 	sthio	r3,0(r2)
 321de90:	00002706 	br	321df30 <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 4)
 321de94:	e0bffd17 	ldw	r2,-12(fp)
 321de98:	10802e17 	ldw	r2,184(r2)
 321de9c:	10800118 	cmpnei	r2,r2,4
 321dea0:	1000231e 	bne	r2,zero,321df30 <alt_write_value_to_flash+0x154>
  {
    word_value = (alt_u32)(*src_addr);
 321dea4:	e0bfff17 	ldw	r2,-4(fp)
 321dea8:	10800003 	ldbu	r2,0(r2)
 321deac:	10803fcc 	andi	r2,r2,255
 321deb0:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 1)) << 8);
 321deb4:	e0bfff17 	ldw	r2,-4(fp)
 321deb8:	10800044 	addi	r2,r2,1
 321debc:	10800003 	ldbu	r2,0(r2)
 321dec0:	10803fcc 	andi	r2,r2,255
 321dec4:	1006923a 	slli	r3,r2,8
 321dec8:	e0bffb17 	ldw	r2,-20(fp)
 321decc:	10c4b03a 	or	r2,r2,r3
 321ded0:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 2)) << 16);
 321ded4:	e0bfff17 	ldw	r2,-4(fp)
 321ded8:	10800084 	addi	r2,r2,2
 321dedc:	10800003 	ldbu	r2,0(r2)
 321dee0:	10803fcc 	andi	r2,r2,255
 321dee4:	1006943a 	slli	r3,r2,16
 321dee8:	e0bffb17 	ldw	r2,-20(fp)
 321deec:	10c4b03a 	or	r2,r2,r3
 321def0:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 3)) << 24);
 321def4:	e0bfff17 	ldw	r2,-4(fp)
 321def8:	108000c4 	addi	r2,r2,3
 321defc:	10800003 	ldbu	r2,0(r2)
 321df00:	10803fcc 	andi	r2,r2,255
 321df04:	1006963a 	slli	r3,r2,24
 321df08:	e0bffb17 	ldw	r2,-20(fp)
 321df0c:	10c4b03a 	or	r2,r2,r3
 321df10:	e0bffb15 	stw	r2,-20(fp)
    IOWR_32DIRECT(flash->dev.base_addr, offset, word_value);
 321df14:	e0bffd17 	ldw	r2,-12(fp)
 321df18:	10800a17 	ldw	r2,40(r2)
 321df1c:	1007883a 	mov	r3,r2
 321df20:	e0bffe17 	ldw	r2,-8(fp)
 321df24:	1885883a 	add	r2,r3,r2
 321df28:	e0fffb17 	ldw	r3,-20(fp)
 321df2c:	10c00035 	stwio	r3,0(r2)
  }

  return;
}
 321df30:	e037883a 	mov	sp,fp
 321df34:	df000017 	ldw	fp,0(sp)
 321df38:	dec00104 	addi	sp,sp,4
 321df3c:	f800283a 	ret

0321df40 <alt_flash_program_block>:
*/
int alt_flash_program_block(  alt_flash_cfi_dev* flash, const int offset, 
                        const alt_u8* src_addr, 
                        const int length,
                        alt_program_word_fn program_word_func)
{
 321df40:	defff304 	addi	sp,sp,-52
 321df44:	dfc00c15 	stw	ra,48(sp)
 321df48:	df000b15 	stw	fp,44(sp)
 321df4c:	df000b04 	addi	fp,sp,44
 321df50:	e13ffc15 	stw	r4,-16(fp)
 321df54:	e17ffd15 	stw	r5,-12(fp)
 321df58:	e1bffe15 	stw	r6,-8(fp)
 321df5c:	e1ffff15 	stw	r7,-4(fp)
  int     ret_code = 0;
 321df60:	e03ffa15 	stw	zero,-24(fp)

  /*
   * First take care of any writes which are on none native boundaries
   * as far as the flash is concerned.
   */
  bytes_to_preserve = ((int)((alt_u8*)flash->dev.base_addr + offset) % 
 321df64:	e0bffc17 	ldw	r2,-16(fp)
 321df68:	10800a17 	ldw	r2,40(r2)
 321df6c:	1007883a 	mov	r3,r2
 321df70:	e0bffd17 	ldw	r2,-12(fp)
 321df74:	1885883a 	add	r2,r3,r2
 321df78:	1009883a 	mov	r4,r2
 321df7c:	e0bffc17 	ldw	r2,-16(fp)
 321df80:	11402e17 	ldw	r5,184(r2)
 321df84:	32047600 	call	3204760 <__modsi3>
 321df88:	e0bff915 	stw	r2,-28(fp)
                      flash->mode_width);
  if ( bytes_to_preserve != 0)
 321df8c:	e0bff917 	ldw	r2,-28(fp)
 321df90:	1005003a 	cmpeq	r2,r2,zero
 321df94:	10003a1e 	bne	r2,zero,321e080 <alt_flash_program_block+0x140>
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
 321df98:	e0bffc17 	ldw	r2,-16(fp)
 321df9c:	10c02e17 	ldw	r3,184(r2)
 321dfa0:	e0bff917 	ldw	r2,-28(fp)
 321dfa4:	1885c83a 	sub	r2,r3,r2
 321dfa8:	e0bff815 	stw	r2,-32(fp)
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 321dfac:	e03ff615 	stw	zero,-40(fp)
 321dfb0:	00001206 	br	321dffc <alt_flash_program_block+0xbc>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
 321dfb4:	e17ff617 	ldw	r5,-40(fp)
 321dfb8:	e0bffc17 	ldw	r2,-16(fp)
 321dfbc:	10800a17 	ldw	r2,40(r2)
 321dfc0:	1009883a 	mov	r4,r2
 321dfc4:	e0fffd17 	ldw	r3,-12(fp)
 321dfc8:	e0bff917 	ldw	r2,-28(fp)
 321dfcc:	1887c83a 	sub	r3,r3,r2
 321dfd0:	e0bff617 	ldw	r2,-40(fp)
 321dfd4:	1885883a 	add	r2,r3,r2
 321dfd8:	2085883a 	add	r2,r4,r2
 321dfdc:	10800023 	ldbuio	r2,0(r2)
 321dfe0:	1007883a 	mov	r3,r2
 321dfe4:	e0bffb04 	addi	r2,fp,-20
 321dfe8:	1145883a 	add	r2,r2,r5
 321dfec:	10c00005 	stb	r3,0(r2)
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 321dff0:	e0bff617 	ldw	r2,-40(fp)
 321dff4:	10800044 	addi	r2,r2,1
 321dff8:	e0bff615 	stw	r2,-40(fp)
 321dffc:	e0fff617 	ldw	r3,-40(fp)
 321e000:	e0bff917 	ldw	r2,-28(fp)
 321e004:	18bfeb16 	blt	r3,r2,321dfb4 <alt_flash_program_block+0x74>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 321e008:	e03ff615 	stw	zero,-40(fp)
 321e00c:	00000e06 	br	321e048 <alt_flash_program_block+0x108>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
 321e010:	e0fff917 	ldw	r3,-28(fp)
 321e014:	e0bff617 	ldw	r2,-40(fp)
 321e018:	1889883a 	add	r4,r3,r2
 321e01c:	e0bff617 	ldw	r2,-40(fp)
 321e020:	1007883a 	mov	r3,r2
 321e024:	e0bffe17 	ldw	r2,-8(fp)
 321e028:	1885883a 	add	r2,r3,r2
 321e02c:	10c00003 	ldbu	r3,0(r2)
 321e030:	e0bffb04 	addi	r2,fp,-20
 321e034:	1105883a 	add	r2,r2,r4
 321e038:	10c00005 	stb	r3,0(r2)
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 321e03c:	e0bff617 	ldw	r2,-40(fp)
 321e040:	10800044 	addi	r2,r2,1
 321e044:	e0bff615 	stw	r2,-40(fp)
 321e048:	e0fff617 	ldw	r3,-40(fp)
 321e04c:	e0bff817 	ldw	r2,-32(fp)
 321e050:	18bfef16 	blt	r3,r2,321e010 <alt_flash_program_block+0xd0>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
    }
    
    ret_code = (*program_word_func)(flash, offset-bytes_to_preserve, unaligned);
 321e054:	e0fffd17 	ldw	r3,-12(fp)
 321e058:	e0bff917 	ldw	r2,-28(fp)
 321e05c:	188bc83a 	sub	r5,r3,r2
 321e060:	e1bffb04 	addi	r6,fp,-20
 321e064:	e0800217 	ldw	r2,8(fp)
 321e068:	e13ffc17 	ldw	r4,-16(fp)
 321e06c:	103ee83a 	callr	r2
 321e070:	e0bffa15 	stw	r2,-24(fp)
    i = unaligned_bytes;
 321e074:	e0bff817 	ldw	r2,-32(fp)
 321e078:	e0bff615 	stw	r2,-40(fp)
 321e07c:	00000106 	br	321e084 <alt_flash_program_block+0x144>
  }
  else
  {
    i = 0;
 321e080:	e03ff615 	stw	zero,-40(fp)
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
 321e084:	e0fffd17 	ldw	r3,-12(fp)
 321e088:	e0bfff17 	ldw	r2,-4(fp)
 321e08c:	1889883a 	add	r4,r3,r2
 321e090:	e0bffc17 	ldw	r2,-16(fp)
 321e094:	11402e17 	ldw	r5,184(r2)
 321e098:	32047600 	call	3204760 <__modsi3>
 321e09c:	e0bff715 	stw	r2,-36(fp)
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 321e0a0:	00001006 	br	321e0e4 <alt_flash_program_block+0x1a4>
  {
    ret_code = (*program_word_func)(flash, offset+i, src_addr+i);
 321e0a4:	e0fffd17 	ldw	r3,-12(fp)
 321e0a8:	e0bff617 	ldw	r2,-40(fp)
 321e0ac:	188b883a 	add	r5,r3,r2
 321e0b0:	e0bff617 	ldw	r2,-40(fp)
 321e0b4:	1007883a 	mov	r3,r2
 321e0b8:	e0bffe17 	ldw	r2,-8(fp)
 321e0bc:	188d883a 	add	r6,r3,r2
 321e0c0:	e0800217 	ldw	r2,8(fp)
 321e0c4:	e13ffc17 	ldw	r4,-16(fp)
 321e0c8:	103ee83a 	callr	r2
 321e0cc:	e0bffa15 	stw	r2,-24(fp)
    i += flash->mode_width;     
 321e0d0:	e0bffc17 	ldw	r2,-16(fp)
 321e0d4:	10c02e17 	ldw	r3,184(r2)
 321e0d8:	e0bff617 	ldw	r2,-40(fp)
 321e0dc:	10c5883a 	add	r2,r2,r3
 321e0e0:	e0bff615 	stw	r2,-40(fp)
  {
    i = 0;
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 321e0e4:	e0bffa17 	ldw	r2,-24(fp)
 321e0e8:	1004c03a 	cmpne	r2,r2,zero
 321e0ec:	1000051e 	bne	r2,zero,321e104 <alt_flash_program_block+0x1c4>
 321e0f0:	e0ffff17 	ldw	r3,-4(fp)
 321e0f4:	e0bff717 	ldw	r2,-36(fp)
 321e0f8:	1887c83a 	sub	r3,r3,r2
 321e0fc:	e0bff617 	ldw	r2,-40(fp)
 321e100:	10ffe816 	blt	r2,r3,321e0a4 <alt_flash_program_block+0x164>

  /*
   * Now take care of any writes at the end of the buffer which are on none 
   * native boundaries as far as the flash is concerned.
   */
  if (unaligned_end_bytes && !ret_code)
 321e104:	e0bff717 	ldw	r2,-36(fp)
 321e108:	1005003a 	cmpeq	r2,r2,zero
 321e10c:	10003c1e 	bne	r2,zero,321e200 <alt_flash_program_block+0x2c0>
 321e110:	e0bffa17 	ldw	r2,-24(fp)
 321e114:	1004c03a 	cmpne	r2,r2,zero
 321e118:	1000391e 	bne	r2,zero,321e200 <alt_flash_program_block+0x2c0>
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
 321e11c:	e0bffc17 	ldw	r2,-16(fp)
 321e120:	10c02e17 	ldw	r3,184(r2)
 321e124:	e0bff717 	ldw	r2,-36(fp)
 321e128:	1885c83a 	sub	r2,r3,r2
 321e12c:	e0bff915 	stw	r2,-28(fp)
    
    for (j=0;j<unaligned_end_bytes;j++)
 321e130:	e03ff515 	stw	zero,-44(fp)
 321e134:	00000e06 	br	321e170 <alt_flash_program_block+0x230>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
 321e138:	e13ff517 	ldw	r4,-44(fp)
 321e13c:	e0bff617 	ldw	r2,-40(fp)
 321e140:	1007883a 	mov	r3,r2
 321e144:	e0bffe17 	ldw	r2,-8(fp)
 321e148:	1887883a 	add	r3,r3,r2
 321e14c:	e0bff517 	ldw	r2,-44(fp)
 321e150:	1885883a 	add	r2,r3,r2
 321e154:	10c00003 	ldbu	r3,0(r2)
 321e158:	e0bffb04 	addi	r2,fp,-20
 321e15c:	1105883a 	add	r2,r2,r4
 321e160:	10c00005 	stb	r3,0(r2)
   */
  if (unaligned_end_bytes && !ret_code)
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
    
    for (j=0;j<unaligned_end_bytes;j++)
 321e164:	e0bff517 	ldw	r2,-44(fp)
 321e168:	10800044 	addi	r2,r2,1
 321e16c:	e0bff515 	stw	r2,-44(fp)
 321e170:	e0fff517 	ldw	r3,-44(fp)
 321e174:	e0bff717 	ldw	r2,-36(fp)
 321e178:	18bfef16 	blt	r3,r2,321e138 <alt_flash_program_block+0x1f8>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 321e17c:	e03ff515 	stw	zero,-44(fp)
 321e180:	00001406 	br	321e1d4 <alt_flash_program_block+0x294>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
 321e184:	e0fff717 	ldw	r3,-36(fp)
 321e188:	e0bff517 	ldw	r2,-44(fp)
 321e18c:	188b883a 	add	r5,r3,r2
 321e190:	e0bffc17 	ldw	r2,-16(fp)
 321e194:	10800a17 	ldw	r2,40(r2)
 321e198:	1009883a 	mov	r4,r2
 321e19c:	e0fffd17 	ldw	r3,-12(fp)
 321e1a0:	e0bfff17 	ldw	r2,-4(fp)
 321e1a4:	1887883a 	add	r3,r3,r2
 321e1a8:	e0bff517 	ldw	r2,-44(fp)
 321e1ac:	1885883a 	add	r2,r3,r2
 321e1b0:	2085883a 	add	r2,r4,r2
 321e1b4:	10800023 	ldbuio	r2,0(r2)
 321e1b8:	1007883a 	mov	r3,r2
 321e1bc:	e0bffb04 	addi	r2,fp,-20
 321e1c0:	1145883a 	add	r2,r2,r5
 321e1c4:	10c00005 	stb	r3,0(r2)
    for (j=0;j<unaligned_end_bytes;j++)
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 321e1c8:	e0bff517 	ldw	r2,-44(fp)
 321e1cc:	10800044 	addi	r2,r2,1
 321e1d0:	e0bff515 	stw	r2,-44(fp)
 321e1d4:	e0fff517 	ldw	r3,-44(fp)
 321e1d8:	e0bff917 	ldw	r2,-28(fp)
 321e1dc:	18bfe916 	blt	r3,r2,321e184 <alt_flash_program_block+0x244>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
                                                      offset+length+j);
    }

    ret_code = (*program_word_func)(flash, offset+i, unaligned);      
 321e1e0:	e0fffd17 	ldw	r3,-12(fp)
 321e1e4:	e0bff617 	ldw	r2,-40(fp)
 321e1e8:	188b883a 	add	r5,r3,r2
 321e1ec:	e1bffb04 	addi	r6,fp,-20
 321e1f0:	e0800217 	ldw	r2,8(fp)
 321e1f4:	e13ffc17 	ldw	r4,-16(fp)
 321e1f8:	103ee83a 	callr	r2
 321e1fc:	e0bffa15 	stw	r2,-24(fp)
  }

  return ret_code;
 321e200:	e0bffa17 	ldw	r2,-24(fp)
}
 321e204:	e037883a 	mov	sp,fp
 321e208:	dfc00117 	ldw	ra,4(sp)
 321e20c:	df000017 	ldw	fp,0(sp)
 321e210:	dec00204 	addi	sp,sp,8
 321e214:	f800283a 	ret

0321e218 <alt_read_query_entry_8bit>:

/*
 *  Read an 8 bit value from the CFI query table in flash
 */
alt_u8 alt_read_query_entry_8bit( alt_flash_cfi_dev* flash, int address)
{
 321e218:	defffd04 	addi	sp,sp,-12
 321e21c:	df000215 	stw	fp,8(sp)
 321e220:	df000204 	addi	fp,sp,8
 321e224:	e13ffe15 	stw	r4,-8(fp)
 321e228:	e17fff15 	stw	r5,-4(fp)
  return IORD_8DIRECT((alt_u8*)flash->dev.base_addr, address);
 321e22c:	e0bffe17 	ldw	r2,-8(fp)
 321e230:	10800a17 	ldw	r2,40(r2)
 321e234:	1007883a 	mov	r3,r2
 321e238:	e0bfff17 	ldw	r2,-4(fp)
 321e23c:	1885883a 	add	r2,r3,r2
 321e240:	10800023 	ldbuio	r2,0(r2)
 321e244:	10803fcc 	andi	r2,r2,255
}
 321e248:	e037883a 	mov	sp,fp
 321e24c:	df000017 	ldw	fp,0(sp)
 321e250:	dec00104 	addi	sp,sp,4
 321e254:	f800283a 	ret

0321e258 <alt_read_query_entry_16bit>:

alt_u8 alt_read_query_entry_16bit( alt_flash_cfi_dev* flash, int address)
{
 321e258:	defffd04 	addi	sp,sp,-12
 321e25c:	df000215 	stw	fp,8(sp)
 321e260:	df000204 	addi	fp,sp,8
 321e264:	e13ffe15 	stw	r4,-8(fp)
 321e268:	e17fff15 	stw	r5,-4(fp)
  return (IORD_16DIRECT((alt_u8*)flash->dev.base_addr, address*2) & 0xff);
 321e26c:	e0bffe17 	ldw	r2,-8(fp)
 321e270:	10800a17 	ldw	r2,40(r2)
 321e274:	1007883a 	mov	r3,r2
 321e278:	e0bfff17 	ldw	r2,-4(fp)
 321e27c:	1085883a 	add	r2,r2,r2
 321e280:	1885883a 	add	r2,r3,r2
 321e284:	1080002b 	ldhuio	r2,0(r2)
 321e288:	10803fcc 	andi	r2,r2,255
}
 321e28c:	e037883a 	mov	sp,fp
 321e290:	df000017 	ldw	fp,0(sp)
 321e294:	dec00104 	addi	sp,sp,4
 321e298:	f800283a 	ret

0321e29c <alt_read_query_entry_32bit>:

alt_u8 alt_read_query_entry_32bit( alt_flash_cfi_dev* flash, int address)
{
 321e29c:	defffd04 	addi	sp,sp,-12
 321e2a0:	df000215 	stw	fp,8(sp)
 321e2a4:	df000204 	addi	fp,sp,8
 321e2a8:	e13ffe15 	stw	r4,-8(fp)
 321e2ac:	e17fff15 	stw	r5,-4(fp)
  return (IORD_32DIRECT((alt_u8*)flash->dev.base_addr, address*4) & 0xff);
 321e2b0:	e0bffe17 	ldw	r2,-8(fp)
 321e2b4:	10800a17 	ldw	r2,40(r2)
 321e2b8:	1007883a 	mov	r3,r2
 321e2bc:	e0bfff17 	ldw	r2,-4(fp)
 321e2c0:	1085883a 	add	r2,r2,r2
 321e2c4:	1085883a 	add	r2,r2,r2
 321e2c8:	1885883a 	add	r2,r3,r2
 321e2cc:	10800037 	ldwio	r2,0(r2)
 321e2d0:	10803fcc 	andi	r2,r2,255
}
 321e2d4:	e037883a 	mov	sp,fp
 321e2d8:	df000017 	ldw	fp,0(sp)
 321e2dc:	dec00104 	addi	sp,sp,4
 321e2e0:	f800283a 	ret

0321e2e4 <alt_write_flash_command_8bit_device_8bit_mode>:

/*
 * Write an 8 bit command to a flash
 */
void alt_write_flash_command_8bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 321e2e4:	defffc04 	addi	sp,sp,-16
 321e2e8:	df000315 	stw	fp,12(sp)
 321e2ec:	df000304 	addi	fp,sp,12
 321e2f0:	e13ffd15 	stw	r4,-12(fp)
 321e2f4:	e17ffe15 	stw	r5,-8(fp)
 321e2f8:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset, value);
 321e2fc:	e0fffd17 	ldw	r3,-12(fp)
 321e300:	e0bffe17 	ldw	r2,-8(fp)
 321e304:	1885883a 	add	r2,r3,r2
 321e308:	e0ffff03 	ldbu	r3,-4(fp)
 321e30c:	10c00025 	stbio	r3,0(r2)
  return;
}
 321e310:	e037883a 	mov	sp,fp
 321e314:	df000017 	ldw	fp,0(sp)
 321e318:	dec00104 	addi	sp,sp,4
 321e31c:	f800283a 	ret

0321e320 <alt_write_flash_command_16bit_device_8bit_mode>:

void alt_write_flash_command_16bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 321e320:	defffc04 	addi	sp,sp,-16
 321e324:	df000315 	stw	fp,12(sp)
 321e328:	df000304 	addi	fp,sp,12
 321e32c:	e13ffd15 	stw	r4,-12(fp)
 321e330:	e17ffe15 	stw	r5,-8(fp)
 321e334:	e1bfff05 	stb	r6,-4(fp)
  if (offset % 2)
 321e338:	e0bffe17 	ldw	r2,-8(fp)
 321e33c:	1080004c 	andi	r2,r2,1
 321e340:	10803fcc 	andi	r2,r2,255
 321e344:	1005003a 	cmpeq	r2,r2,zero
 321e348:	1000081e 	bne	r2,zero,321e36c <alt_write_flash_command_16bit_device_8bit_mode+0x4c>
  {
    IOWR_8DIRECT(base_addr, offset*2, value);
 321e34c:	e0bffe17 	ldw	r2,-8(fp)
 321e350:	1085883a 	add	r2,r2,r2
 321e354:	1007883a 	mov	r3,r2
 321e358:	e0bffd17 	ldw	r2,-12(fp)
 321e35c:	1885883a 	add	r2,r3,r2
 321e360:	e0ffff03 	ldbu	r3,-4(fp)
 321e364:	10c00025 	stbio	r3,0(r2)
 321e368:	00000806 	br	321e38c <alt_write_flash_command_16bit_device_8bit_mode+0x6c>
  }
  else
  {
    IOWR_8DIRECT(base_addr, (offset*2)+1, value);
 321e36c:	e0bffe17 	ldw	r2,-8(fp)
 321e370:	1085883a 	add	r2,r2,r2
 321e374:	1007883a 	mov	r3,r2
 321e378:	e0bffd17 	ldw	r2,-12(fp)
 321e37c:	1885883a 	add	r2,r3,r2
 321e380:	10800044 	addi	r2,r2,1
 321e384:	e0ffff03 	ldbu	r3,-4(fp)
 321e388:	10c00025 	stbio	r3,0(r2)
  }
  return;
}
 321e38c:	e037883a 	mov	sp,fp
 321e390:	df000017 	ldw	fp,0(sp)
 321e394:	dec00104 	addi	sp,sp,4
 321e398:	f800283a 	ret

0321e39c <alt_write_flash_command_32bit_device_8bit_mode>:

void alt_write_flash_command_32bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 321e39c:	defffc04 	addi	sp,sp,-16
 321e3a0:	df000315 	stw	fp,12(sp)
 321e3a4:	df000304 	addi	fp,sp,12
 321e3a8:	e13ffd15 	stw	r4,-12(fp)
 321e3ac:	e17ffe15 	stw	r5,-8(fp)
 321e3b0:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset*4, value);
 321e3b4:	e0bffe17 	ldw	r2,-8(fp)
 321e3b8:	1085883a 	add	r2,r2,r2
 321e3bc:	1085883a 	add	r2,r2,r2
 321e3c0:	1007883a 	mov	r3,r2
 321e3c4:	e0bffd17 	ldw	r2,-12(fp)
 321e3c8:	1885883a 	add	r2,r3,r2
 321e3cc:	e0ffff03 	ldbu	r3,-4(fp)
 321e3d0:	10c00025 	stbio	r3,0(r2)
  return;
}
 321e3d4:	e037883a 	mov	sp,fp
 321e3d8:	df000017 	ldw	fp,0(sp)
 321e3dc:	dec00104 	addi	sp,sp,4
 321e3e0:	f800283a 	ret

0321e3e4 <alt_write_flash_command_16bit_device_16bit_mode>:

void alt_write_flash_command_16bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 321e3e4:	defffc04 	addi	sp,sp,-16
 321e3e8:	df000315 	stw	fp,12(sp)
 321e3ec:	df000304 	addi	fp,sp,12
 321e3f0:	e13ffd15 	stw	r4,-12(fp)
 321e3f4:	e17ffe15 	stw	r5,-8(fp)
 321e3f8:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*2, ((alt_u16)value)& 0x00ff);
 321e3fc:	e0bffe17 	ldw	r2,-8(fp)
 321e400:	1085883a 	add	r2,r2,r2
 321e404:	1007883a 	mov	r3,r2
 321e408:	e0bffd17 	ldw	r2,-12(fp)
 321e40c:	1885883a 	add	r2,r3,r2
 321e410:	e0ffff03 	ldbu	r3,-4(fp)
 321e414:	10c0002d 	sthio	r3,0(r2)
  return;
}
 321e418:	e037883a 	mov	sp,fp
 321e41c:	df000017 	ldw	fp,0(sp)
 321e420:	dec00104 	addi	sp,sp,4
 321e424:	f800283a 	ret

0321e428 <alt_write_flash_command_32bit_device_16bit_mode>:

void alt_write_flash_command_32bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 321e428:	defffc04 	addi	sp,sp,-16
 321e42c:	df000315 	stw	fp,12(sp)
 321e430:	df000304 	addi	fp,sp,12
 321e434:	e13ffd15 	stw	r4,-12(fp)
 321e438:	e17ffe15 	stw	r5,-8(fp)
 321e43c:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*4, ((alt_u16)value)& 0x00ff);
 321e440:	e0bffe17 	ldw	r2,-8(fp)
 321e444:	1085883a 	add	r2,r2,r2
 321e448:	1085883a 	add	r2,r2,r2
 321e44c:	1007883a 	mov	r3,r2
 321e450:	e0bffd17 	ldw	r2,-12(fp)
 321e454:	1885883a 	add	r2,r3,r2
 321e458:	e0ffff03 	ldbu	r3,-4(fp)
 321e45c:	10c0002d 	sthio	r3,0(r2)
  return;
}
 321e460:	e037883a 	mov	sp,fp
 321e464:	df000017 	ldw	fp,0(sp)
 321e468:	dec00104 	addi	sp,sp,4
 321e46c:	f800283a 	ret

0321e470 <alt_write_flash_command_32bit_device_32bit_mode>:

void alt_write_flash_command_32bit_device_32bit_mode( void* base_addr, int offset, alt_u8 value)
{
 321e470:	defffc04 	addi	sp,sp,-16
 321e474:	df000315 	stw	fp,12(sp)
 321e478:	df000304 	addi	fp,sp,12
 321e47c:	e13ffd15 	stw	r4,-12(fp)
 321e480:	e17ffe15 	stw	r5,-8(fp)
 321e484:	e1bfff05 	stb	r6,-4(fp)
  IOWR_32DIRECT(base_addr, offset*4, ((alt_u32)value)& 0x000000ff);
 321e488:	e0bffe17 	ldw	r2,-8(fp)
 321e48c:	1085883a 	add	r2,r2,r2
 321e490:	1085883a 	add	r2,r2,r2
 321e494:	1007883a 	mov	r3,r2
 321e498:	e0bffd17 	ldw	r2,-12(fp)
 321e49c:	1885883a 	add	r2,r3,r2
 321e4a0:	e0ffff03 	ldbu	r3,-4(fp)
 321e4a4:	10c00035 	stwio	r3,0(r2)
  return;
}
 321e4a8:	e037883a 	mov	sp,fp
 321e4ac:	df000017 	ldw	fp,0(sp)
 321e4b0:	dec00104 	addi	sp,sp,4
 321e4b4:	f800283a 	ret

0321e4b8 <alt_write_native_8bit>:

/*
 * Write the value passed to the flash
 */
void alt_write_native_8bit( void* address, alt_u32 value)
{
 321e4b8:	defffd04 	addi	sp,sp,-12
 321e4bc:	df000215 	stw	fp,8(sp)
 321e4c0:	df000204 	addi	fp,sp,8
 321e4c4:	e13ffe15 	stw	r4,-8(fp)
 321e4c8:	e17fff15 	stw	r5,-4(fp)
  IOWR_8DIRECT(address, 0, (alt_u8)(value&0xff));
 321e4cc:	e0bfff17 	ldw	r2,-4(fp)
 321e4d0:	10c03fcc 	andi	r3,r2,255
 321e4d4:	e0bffe17 	ldw	r2,-8(fp)
 321e4d8:	10c00025 	stbio	r3,0(r2)
  return;
}
 321e4dc:	e037883a 	mov	sp,fp
 321e4e0:	df000017 	ldw	fp,0(sp)
 321e4e4:	dec00104 	addi	sp,sp,4
 321e4e8:	f800283a 	ret

0321e4ec <alt_write_native_16bit>:

void alt_write_native_16bit( void* address, alt_u32 value)
{
 321e4ec:	defffd04 	addi	sp,sp,-12
 321e4f0:	df000215 	stw	fp,8(sp)
 321e4f4:	df000204 	addi	fp,sp,8
 321e4f8:	e13ffe15 	stw	r4,-8(fp)
 321e4fc:	e17fff15 	stw	r5,-4(fp)
  IOWR_16DIRECT(address, 0, ((alt_u16)value)& 0xffff);
 321e500:	e0bfff17 	ldw	r2,-4(fp)
 321e504:	10ffffcc 	andi	r3,r2,65535
 321e508:	e0bffe17 	ldw	r2,-8(fp)
 321e50c:	10c0002d 	sthio	r3,0(r2)
  return;
}
 321e510:	e037883a 	mov	sp,fp
 321e514:	df000017 	ldw	fp,0(sp)
 321e518:	dec00104 	addi	sp,sp,4
 321e51c:	f800283a 	ret

0321e520 <alt_write_native_32bit>:

void alt_write_native_32bit( void* address, alt_u32 value)
{
 321e520:	defffd04 	addi	sp,sp,-12
 321e524:	df000215 	stw	fp,8(sp)
 321e528:	df000204 	addi	fp,sp,8
 321e52c:	e13ffe15 	stw	r4,-8(fp)
 321e530:	e17fff15 	stw	r5,-4(fp)
  IOWR_32DIRECT(address, 0, value);
 321e534:	e0ffff17 	ldw	r3,-4(fp)
 321e538:	e0bffe17 	ldw	r2,-8(fp)
 321e53c:	10c00035 	stwio	r3,0(r2)
  return;
}
 321e540:	e037883a 	mov	sp,fp
 321e544:	df000017 	ldw	fp,0(sp)
 321e548:	dec00104 	addi	sp,sp,4
 321e54c:	f800283a 	ret

0321e550 <alt_set_flash_width_func>:
 * 
 * Setup the function pointers for writing a byte to the flash for the width
 * of the device
 */
int alt_set_flash_width_func( alt_flash_cfi_dev* flash)
{ 
 321e550:	defffb04 	addi	sp,sp,-20
 321e554:	df000415 	stw	fp,16(sp)
 321e558:	df000404 	addi	fp,sp,16
 321e55c:	e13ffd15 	stw	r4,-12(fp)
  int ret_code = 0;
 321e560:	e03ffc15 	stw	zero,-16(fp)
  
  switch(flash->mode_width)
 321e564:	e0bffd17 	ldw	r2,-12(fp)
 321e568:	10802e17 	ldw	r2,184(r2)
 321e56c:	e0bfff15 	stw	r2,-4(fp)
 321e570:	e0ffff17 	ldw	r3,-4(fp)
 321e574:	188000a0 	cmpeqi	r2,r3,2
 321e578:	1000261e 	bne	r2,zero,321e614 <alt_set_flash_width_func+0xc4>
 321e57c:	e0ffff17 	ldw	r3,-4(fp)
 321e580:	18800120 	cmpeqi	r2,r3,4
 321e584:	1000391e 	bne	r2,zero,321e66c <alt_set_flash_width_func+0x11c>
 321e588:	e0ffff17 	ldw	r3,-4(fp)
 321e58c:	18800060 	cmpeqi	r2,r3,1
 321e590:	1000011e 	bne	r2,zero,321e598 <alt_set_flash_width_func+0x48>
 321e594:	00003e06 	br	321e690 <alt_set_flash_width_func+0x140>
  {
    case 1:
    {
      flash->write_native = alt_write_native_8bit;
 321e598:	e0fffd17 	ldw	r3,-12(fp)
 321e59c:	0080c8b4 	movhi	r2,802
 321e5a0:	10b92e04 	addi	r2,r2,-6984
 321e5a4:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 1)
 321e5a8:	e0bffd17 	ldw	r2,-12(fp)
 321e5ac:	10802f17 	ldw	r2,188(r2)
 321e5b0:	10800058 	cmpnei	r2,r2,1
 321e5b4:	1000051e 	bne	r2,zero,321e5cc <alt_set_flash_width_func+0x7c>
      {
        flash->write_command = alt_write_flash_command_8bit_device_8bit_mode;
 321e5b8:	e0fffd17 	ldw	r3,-12(fp)
 321e5bc:	0080c8b4 	movhi	r2,802
 321e5c0:	10b8b904 	addi	r2,r2,-7452
 321e5c4:	18803315 	stw	r2,204(r3)
 321e5c8:	00003306 	br	321e698 <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 2)
 321e5cc:	e0bffd17 	ldw	r2,-12(fp)
 321e5d0:	10802f17 	ldw	r2,188(r2)
 321e5d4:	10800098 	cmpnei	r2,r2,2
 321e5d8:	1000051e 	bne	r2,zero,321e5f0 <alt_set_flash_width_func+0xa0>
      {
        flash->write_command = alt_write_flash_command_16bit_device_8bit_mode;
 321e5dc:	e0fffd17 	ldw	r3,-12(fp)
 321e5e0:	0080c8b4 	movhi	r2,802
 321e5e4:	10b8c804 	addi	r2,r2,-7392
 321e5e8:	18803315 	stw	r2,204(r3)
 321e5ec:	00002a06 	br	321e698 <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 321e5f0:	e0bffd17 	ldw	r2,-12(fp)
 321e5f4:	10802f17 	ldw	r2,188(r2)
 321e5f8:	10800118 	cmpnei	r2,r2,4
 321e5fc:	1000261e 	bne	r2,zero,321e698 <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_8bit_mode;
 321e600:	e0fffd17 	ldw	r3,-12(fp)
 321e604:	0080c8b4 	movhi	r2,802
 321e608:	10b8e704 	addi	r2,r2,-7268
 321e60c:	18803315 	stw	r2,204(r3)
      }
      break;
 321e610:	00002106 	br	321e698 <alt_set_flash_width_func+0x148>
    }
    case 2:
    {
      flash->write_native = alt_write_native_16bit;
 321e614:	e0fffd17 	ldw	r3,-12(fp)
 321e618:	0080c8b4 	movhi	r2,802
 321e61c:	10b93b04 	addi	r2,r2,-6932
 321e620:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 2)
 321e624:	e0bffd17 	ldw	r2,-12(fp)
 321e628:	10802f17 	ldw	r2,188(r2)
 321e62c:	10800098 	cmpnei	r2,r2,2
 321e630:	1000051e 	bne	r2,zero,321e648 <alt_set_flash_width_func+0xf8>
      {
        flash->write_command = alt_write_flash_command_16bit_device_16bit_mode;
 321e634:	e0fffd17 	ldw	r3,-12(fp)
 321e638:	0080c8b4 	movhi	r2,802
 321e63c:	10b8f904 	addi	r2,r2,-7196
 321e640:	18803315 	stw	r2,204(r3)
 321e644:	00001406 	br	321e698 <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 321e648:	e0bffd17 	ldw	r2,-12(fp)
 321e64c:	10802f17 	ldw	r2,188(r2)
 321e650:	10800118 	cmpnei	r2,r2,4
 321e654:	1000101e 	bne	r2,zero,321e698 <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_16bit_mode;
 321e658:	e0fffd17 	ldw	r3,-12(fp)
 321e65c:	0080c8b4 	movhi	r2,802
 321e660:	10b90a04 	addi	r2,r2,-7128
 321e664:	18803315 	stw	r2,204(r3)
      }

      break;
 321e668:	00000b06 	br	321e698 <alt_set_flash_width_func+0x148>
    }
    case 4:
    {
      flash->write_native = alt_write_native_32bit;
 321e66c:	e0fffd17 	ldw	r3,-12(fp)
 321e670:	0080c8b4 	movhi	r2,802
 321e674:	10b94804 	addi	r2,r2,-6880
 321e678:	18803515 	stw	r2,212(r3)
      flash->write_command = alt_write_flash_command_32bit_device_32bit_mode;
 321e67c:	e0fffd17 	ldw	r3,-12(fp)
 321e680:	0080c8b4 	movhi	r2,802
 321e684:	10b91c04 	addi	r2,r2,-7056
 321e688:	18803315 	stw	r2,204(r3)
      break;
 321e68c:	00000206 	br	321e698 <alt_set_flash_width_func+0x148>
    }
    default:
    {
      ret_code = -EACCES;
 321e690:	00bffcc4 	movi	r2,-13
 321e694:	e0bffc15 	stw	r2,-16(fp)
    }
  }

  if (!ret_code)
 321e698:	e0bffc17 	ldw	r2,-16(fp)
 321e69c:	1004c03a 	cmpne	r2,r2,zero
 321e6a0:	10001e1e 	bne	r2,zero,321e71c <alt_set_flash_width_func+0x1cc>
  {
    switch(flash->device_width)
 321e6a4:	e0bffd17 	ldw	r2,-12(fp)
 321e6a8:	10802f17 	ldw	r2,188(r2)
 321e6ac:	e0bffe15 	stw	r2,-8(fp)
 321e6b0:	e0fffe17 	ldw	r3,-8(fp)
 321e6b4:	188000a0 	cmpeqi	r2,r3,2
 321e6b8:	10000c1e 	bne	r2,zero,321e6ec <alt_set_flash_width_func+0x19c>
 321e6bc:	e0fffe17 	ldw	r3,-8(fp)
 321e6c0:	18800120 	cmpeqi	r2,r3,4
 321e6c4:	10000e1e 	bne	r2,zero,321e700 <alt_set_flash_width_func+0x1b0>
 321e6c8:	e0fffe17 	ldw	r3,-8(fp)
 321e6cc:	18800060 	cmpeqi	r2,r3,1
 321e6d0:	1000011e 	bne	r2,zero,321e6d8 <alt_set_flash_width_func+0x188>
 321e6d4:	00000f06 	br	321e714 <alt_set_flash_width_func+0x1c4>
    {
      case 1:
      {
        flash->read_query = alt_read_query_entry_8bit;
 321e6d8:	e0fffd17 	ldw	r3,-12(fp)
 321e6dc:	0080c8b4 	movhi	r2,802
 321e6e0:	10b88604 	addi	r2,r2,-7656
 321e6e4:	18803415 	stw	r2,208(r3)
        break;
 321e6e8:	00000c06 	br	321e71c <alt_set_flash_width_func+0x1cc>
      }
      case 2:
      {
        flash->read_query = alt_read_query_entry_16bit;
 321e6ec:	e0fffd17 	ldw	r3,-12(fp)
 321e6f0:	0080c8b4 	movhi	r2,802
 321e6f4:	10b89604 	addi	r2,r2,-7592
 321e6f8:	18803415 	stw	r2,208(r3)
        break;
 321e6fc:	00000706 	br	321e71c <alt_set_flash_width_func+0x1cc>
      }
      case 4:
      {
        flash->read_query = alt_read_query_entry_32bit;
 321e700:	e0fffd17 	ldw	r3,-12(fp)
 321e704:	0080c8b4 	movhi	r2,802
 321e708:	10b8a704 	addi	r2,r2,-7524
 321e70c:	18803415 	stw	r2,208(r3)
        break;
 321e710:	00000206 	br	321e71c <alt_set_flash_width_func+0x1cc>
      }
      default:
      {
        ret_code = -EACCES;
 321e714:	00bffcc4 	movi	r2,-13
 321e718:	e0bffc15 	stw	r2,-16(fp)
      }
    }
  }

  return ret_code;
 321e71c:	e0bffc17 	ldw	r2,-16(fp)
}
 321e720:	e037883a 	mov	sp,fp
 321e724:	df000017 	ldw	fp,0(sp)
 321e728:	dec00104 	addi	sp,sp,4
 321e72c:	f800283a 	ret

0321e730 <alt_set_flash_algorithm_func>:
 * 
 * Setup the function pointers to the functions for this algorithm
 * 
 */
int alt_set_flash_algorithm_func( alt_flash_cfi_dev* flash)
{
 321e730:	defffc04 	addi	sp,sp,-16
 321e734:	df000315 	stw	fp,12(sp)
 321e738:	df000304 	addi	fp,sp,12
 321e73c:	e13ffe15 	stw	r4,-8(fp)
  int ret_code = 0;
 321e740:	e03ffd15 	stw	zero,-12(fp)
 
  switch(flash->algorithm)
 321e744:	e0bffe17 	ldw	r2,-8(fp)
 321e748:	10802d17 	ldw	r2,180(r2)
 321e74c:	e0bfff15 	stw	r2,-4(fp)
 321e750:	e0ffff17 	ldw	r3,-4(fp)
 321e754:	188000a0 	cmpeqi	r2,r3,2
 321e758:	1000071e 	bne	r2,zero,321e778 <alt_set_flash_algorithm_func+0x48>
 321e75c:	e0ffff17 	ldw	r3,-4(fp)
 321e760:	188000e0 	cmpeqi	r2,r3,3
 321e764:	10000d1e 	bne	r2,zero,321e79c <alt_set_flash_algorithm_func+0x6c>
 321e768:	e0ffff17 	ldw	r3,-4(fp)
 321e76c:	18800060 	cmpeqi	r2,r3,1
 321e770:	10000a1e 	bne	r2,zero,321e79c <alt_set_flash_algorithm_func+0x6c>
 321e774:	00001206 	br	321e7c0 <alt_set_flash_algorithm_func+0x90>
  {
    case CFI_ALG_AMD:
    {
      flash->dev.erase_block = alt_erase_block_amd;
 321e778:	e0fffe17 	ldw	r3,-8(fp)
 321e77c:	0080c934 	movhi	r2,804
 321e780:	10ae7804 	addi	r2,r2,-17952
 321e784:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_amd;
 321e788:	e0fffe17 	ldw	r3,-8(fp)
 321e78c:	0080c934 	movhi	r2,804
 321e790:	10ae5e04 	addi	r2,r2,-18056
 321e794:	18800915 	stw	r2,36(r3)
      break;
 321e798:	00000b06 	br	321e7c8 <alt_set_flash_algorithm_func+0x98>
    }
    case CFI_ALG_INTEL:
    case CFI_ALG_INTEL_STRATA:
    {
      flash->dev.erase_block = alt_erase_block_intel;
 321e79c:	e0fffe17 	ldw	r3,-8(fp)
 321e7a0:	0080c934 	movhi	r2,804
 321e7a4:	10af9704 	addi	r2,r2,-16804
 321e7a8:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_intel;
 321e7ac:	e0fffe17 	ldw	r3,-8(fp)
 321e7b0:	0080c934 	movhi	r2,804
 321e7b4:	10af7604 	addi	r2,r2,-16936
 321e7b8:	18800915 	stw	r2,36(r3)
      break;
 321e7bc:	00000206 	br	321e7c8 <alt_set_flash_algorithm_func+0x98>
    }
    default:
    {
      ret_code = -EIO;
 321e7c0:	00bffec4 	movi	r2,-5
 321e7c4:	e0bffd15 	stw	r2,-12(fp)
    }
  } 
  return ret_code;  
 321e7c8:	e0bffd17 	ldw	r2,-12(fp)
}
 321e7cc:	e037883a 	mov	sp,fp
 321e7d0:	df000017 	ldw	fp,0(sp)
 321e7d4:	dec00104 	addi	sp,sp,4
 321e7d8:	f800283a 	ret

0321e7dc <alt_read_16bit_query_entry>:
 * read_16bit_query_entry
 * 
 * Read a 16 bit entry from the CFI Query table
 */
static alt_u16 alt_read_16bit_query_entry(alt_flash_cfi_dev* flash, int address)
{
 321e7dc:	defffb04 	addi	sp,sp,-20
 321e7e0:	dfc00415 	stw	ra,16(sp)
 321e7e4:	df000315 	stw	fp,12(sp)
 321e7e8:	df000304 	addi	fp,sp,12
 321e7ec:	e13ffe15 	stw	r4,-8(fp)
 321e7f0:	e17fff15 	stw	r5,-4(fp)
  alt_u16 ret_code;

  ret_code = (*flash->read_query)( flash, address);
 321e7f4:	e0bffe17 	ldw	r2,-8(fp)
 321e7f8:	10803417 	ldw	r2,208(r2)
 321e7fc:	e13ffe17 	ldw	r4,-8(fp)
 321e800:	e17fff17 	ldw	r5,-4(fp)
 321e804:	103ee83a 	callr	r2
 321e808:	10803fcc 	andi	r2,r2,255
 321e80c:	e0bffd0d 	sth	r2,-12(fp)
  ret_code |= (((int)(*flash->read_query)(flash, address+1)) << 8);                   
 321e810:	e0bffe17 	ldw	r2,-8(fp)
 321e814:	10c03417 	ldw	r3,208(r2)
 321e818:	e0bfff17 	ldw	r2,-4(fp)
 321e81c:	11400044 	addi	r5,r2,1
 321e820:	e13ffe17 	ldw	r4,-8(fp)
 321e824:	183ee83a 	callr	r3
 321e828:	10803fcc 	andi	r2,r2,255
 321e82c:	1004923a 	slli	r2,r2,8
 321e830:	1007883a 	mov	r3,r2
 321e834:	e0bffd0b 	ldhu	r2,-12(fp)
 321e838:	1884b03a 	or	r2,r3,r2
 321e83c:	e0bffd0d 	sth	r2,-12(fp)

  return ret_code;
 321e840:	e0bffd0b 	ldhu	r2,-12(fp)
}
 321e844:	e037883a 	mov	sp,fp
 321e848:	dfc00117 	ldw	ra,4(sp)
 321e84c:	df000017 	ldw	fp,0(sp)
 321e850:	dec00204 	addi	sp,sp,8
 321e854:	f800283a 	ret

0321e858 <alt_read_cfi_table>:
 * read_cfi_table
 * 
 * Read the CFI Table
 */
int alt_read_cfi_table(alt_flash_cfi_dev* flash)
{
 321e858:	defff104 	addi	sp,sp,-60
 321e85c:	dfc00e15 	stw	ra,56(sp)
 321e860:	df000d15 	stw	fp,52(sp)
 321e864:	dc000c15 	stw	r16,48(sp)
 321e868:	df000c04 	addi	fp,sp,48
 321e86c:	e13ffe15 	stw	r4,-8(fp)
  int   i,j;
  int   device_size;
  int   ret_code = 0;
 321e870:	e03ffa15 	stw	zero,-24(fp)
  int   size = 0;
 321e874:	e03ff915 	stw	zero,-28(fp)
  int   swap;
  int   typical_timeout;
  int   max_timeout;
  int   offset = 0;
 321e878:	e03ff515 	stw	zero,-44(fp)
   
  /*
  * Check that the Primary Vendor Specific table
  * starts with the letters PRI                                                         
  */
  ret_code = alt_check_primary_table(flash);
 321e87c:	e13ffe17 	ldw	r4,-8(fp)
 321e880:	321f5e40 	call	321f5e4 <alt_check_primary_table>
 321e884:	e0bffa15 	stw	r2,-24(fp)

  if (!ret_code)
 321e888:	e0bffa17 	ldw	r2,-24(fp)
 321e88c:	1004c03a 	cmpne	r2,r2,zero
 321e890:	1001621e 	bne	r2,zero,321ee1c <alt_read_cfi_table+0x5c4>
  {
    flash->algorithm = (*flash->read_query)(flash, 0x13);
 321e894:	e0bffe17 	ldw	r2,-8(fp)
 321e898:	10803417 	ldw	r2,208(r2)
 321e89c:	e13ffe17 	ldw	r4,-8(fp)
 321e8a0:	014004c4 	movi	r5,19
 321e8a4:	103ee83a 	callr	r2
 321e8a8:	10c03fcc 	andi	r3,r2,255
 321e8ac:	e0bffe17 	ldw	r2,-8(fp)
 321e8b0:	10c02d15 	stw	r3,180(r2)
  
    /* 
     * Let's read the write timeout values from the flash 
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
 321e8b4:	e0bffe17 	ldw	r2,-8(fp)
 321e8b8:	10803417 	ldw	r2,208(r2)
 321e8bc:	e13ffe17 	ldw	r4,-8(fp)
 321e8c0:	014007c4 	movi	r5,31
 321e8c4:	103ee83a 	callr	r2
 321e8c8:	10803fcc 	andi	r2,r2,255
 321e8cc:	e0bff715 	stw	r2,-36(fp)
    max_timeout = (*flash->read_query)( flash, 0x23);
 321e8d0:	e0bffe17 	ldw	r2,-8(fp)
 321e8d4:	10803417 	ldw	r2,208(r2)
 321e8d8:	e13ffe17 	ldw	r4,-8(fp)
 321e8dc:	014008c4 	movi	r5,35
 321e8e0:	103ee83a 	callr	r2
 321e8e4:	10803fcc 	andi	r2,r2,255
 321e8e8:	e0bff615 	stw	r2,-40(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 321e8ec:	e0bff717 	ldw	r2,-36(fp)
 321e8f0:	1005003a 	cmpeq	r2,r2,zero
 321e8f4:	1000031e 	bne	r2,zero,321e904 <alt_read_cfi_table+0xac>
 321e8f8:	e0bff617 	ldw	r2,-40(fp)
 321e8fc:	1004c03a 	cmpne	r2,r2,zero
 321e900:	1000041e 	bne	r2,zero,321e914 <alt_read_cfi_table+0xbc>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
 321e904:	e0fffe17 	ldw	r3,-8(fp)
 321e908:	0080fa04 	movi	r2,1000
 321e90c:	18803015 	stw	r2,192(r3)
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
    max_timeout = (*flash->read_query)( flash, 0x23);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 321e910:	00000706 	br	321e930 <alt_read_cfi_table+0xd8>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
    }
    else
    {
      flash->write_timeout = (1 << typical_timeout) * (1 << max_timeout);
 321e914:	00c00044 	movi	r3,1
 321e918:	e0bff717 	ldw	r2,-36(fp)
 321e91c:	1886983a 	sll	r3,r3,r2
 321e920:	e0bff617 	ldw	r2,-40(fp)
 321e924:	1886983a 	sll	r3,r3,r2
 321e928:	e0bffe17 	ldw	r2,-8(fp)
 321e92c:	10c03015 	stw	r3,192(r2)
    }
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
 321e930:	e0bffe17 	ldw	r2,-8(fp)
 321e934:	10803417 	ldw	r2,208(r2)
 321e938:	e13ffe17 	ldw	r4,-8(fp)
 321e93c:	01400844 	movi	r5,33
 321e940:	103ee83a 	callr	r2
 321e944:	10803fcc 	andi	r2,r2,255
 321e948:	e0bff715 	stw	r2,-36(fp)
    max_timeout = (*flash->read_query)( flash, 0x25);
 321e94c:	e0bffe17 	ldw	r2,-8(fp)
 321e950:	10803417 	ldw	r2,208(r2)
 321e954:	e13ffe17 	ldw	r4,-8(fp)
 321e958:	01400944 	movi	r5,37
 321e95c:	103ee83a 	callr	r2
 321e960:	10803fcc 	andi	r2,r2,255
 321e964:	e0bff615 	stw	r2,-40(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 321e968:	e0bff717 	ldw	r2,-36(fp)
 321e96c:	1005003a 	cmpeq	r2,r2,zero
 321e970:	1000031e 	bne	r2,zero,321e980 <alt_read_cfi_table+0x128>
 321e974:	e0bff617 	ldw	r2,-40(fp)
 321e978:	1004c03a 	cmpne	r2,r2,zero
 321e97c:	1000051e 	bne	r2,zero,321e994 <alt_read_cfi_table+0x13c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
 321e980:	e0fffe17 	ldw	r3,-8(fp)
 321e984:	00804c74 	movhi	r2,305
 321e988:	108b4004 	addi	r2,r2,11520
 321e98c:	18803115 	stw	r2,196(r3)
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
    max_timeout = (*flash->read_query)( flash, 0x25);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 321e990:	00000806 	br	321e9b4 <alt_read_cfi_table+0x15c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
    }
    else
    {
      flash->erase_timeout = (1 << typical_timeout) * (1 << max_timeout) * 1000;
 321e994:	00c00044 	movi	r3,1
 321e998:	e0bff717 	ldw	r2,-36(fp)
 321e99c:	1886983a 	sll	r3,r3,r2
 321e9a0:	e0bff617 	ldw	r2,-40(fp)
 321e9a4:	1884983a 	sll	r2,r3,r2
 321e9a8:	10c0fa24 	muli	r3,r2,1000
 321e9ac:	e0bffe17 	ldw	r2,-8(fp)
 321e9b0:	10c03115 	stw	r3,196(r2)
    }
   
    device_size = 0x1 << (*flash->read_query)( flash, 0x27);
 321e9b4:	e0bffe17 	ldw	r2,-8(fp)
 321e9b8:	10803417 	ldw	r2,208(r2)
 321e9bc:	e13ffe17 	ldw	r4,-8(fp)
 321e9c0:	014009c4 	movi	r5,39
 321e9c4:	103ee83a 	callr	r2
 321e9c8:	10c03fcc 	andi	r3,r2,255
 321e9cc:	00800044 	movi	r2,1
 321e9d0:	10c4983a 	sll	r2,r2,r3
 321e9d4:	e0bffb15 	stw	r2,-20(fp)
  
    flash->dev.number_of_regions = (*flash->read_query)(flash, 0x2c);
 321e9d8:	e0bffe17 	ldw	r2,-8(fp)
 321e9dc:	10803417 	ldw	r2,208(r2)
 321e9e0:	e13ffe17 	ldw	r4,-8(fp)
 321e9e4:	01400b04 	movi	r5,44
 321e9e8:	103ee83a 	callr	r2
 321e9ec:	10c03fcc 	andi	r3,r2,255
 321e9f0:	e0bffe17 	ldw	r2,-8(fp)
 321e9f4:	10c00c15 	stw	r3,48(r2)
    
    if (flash->dev.number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 321e9f8:	e0bffe17 	ldw	r2,-8(fp)
 321e9fc:	10800c17 	ldw	r2,48(r2)
 321ea00:	10800250 	cmplti	r2,r2,9
 321ea04:	1000031e 	bne	r2,zero,321ea14 <alt_read_cfi_table+0x1bc>
    {
      ret_code = -ENOMEM;
 321ea08:	00bffd04 	movi	r2,-12
 321ea0c:	e0bffa15 	stw	r2,-24(fp)
 321ea10:	00005e06 	br	321eb8c <alt_read_cfi_table+0x334>
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 321ea14:	e03ffd15 	stw	zero,-12(fp)
 321ea18:	00005306 	br	321eb68 <alt_read_cfi_table+0x310>
      {
        flash->dev.region_info[i].number_of_blocks =  alt_read_16bit_query_entry( 
 321ea1c:	e43ffd17 	ldw	r16,-12(fp)
 321ea20:	e0bffd17 	ldw	r2,-12(fp)
 321ea24:	1085883a 	add	r2,r2,r2
 321ea28:	1085883a 	add	r2,r2,r2
 321ea2c:	11400b44 	addi	r5,r2,45
 321ea30:	e13ffe17 	ldw	r4,-8(fp)
 321ea34:	321e7dc0 	call	321e7dc <alt_read_16bit_query_entry>
 321ea38:	113fffcc 	andi	r4,r2,65535
 321ea3c:	e0fffe17 	ldw	r3,-8(fp)
 321ea40:	8004913a 	slli	r2,r16,4
 321ea44:	10c5883a 	add	r2,r2,r3
 321ea48:	10800f04 	addi	r2,r2,60
 321ea4c:	11000015 	stw	r4,0(r2)
                                                            flash,
                                                            (0x2D+i*4));
        flash->dev.region_info[i].number_of_blocks += 1; 
 321ea50:	e17ffd17 	ldw	r5,-12(fp)
 321ea54:	e0bffd17 	ldw	r2,-12(fp)
 321ea58:	e0fffe17 	ldw	r3,-8(fp)
 321ea5c:	1004913a 	slli	r2,r2,4
 321ea60:	10c5883a 	add	r2,r2,r3
 321ea64:	10800f04 	addi	r2,r2,60
 321ea68:	10800017 	ldw	r2,0(r2)
 321ea6c:	11000044 	addi	r4,r2,1
 321ea70:	e0fffe17 	ldw	r3,-8(fp)
 321ea74:	2804913a 	slli	r2,r5,4
 321ea78:	10c5883a 	add	r2,r2,r3
 321ea7c:	10800f04 	addi	r2,r2,60
 321ea80:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].block_size =  alt_read_16bit_query_entry( flash, 
 321ea84:	e43ffd17 	ldw	r16,-12(fp)
 321ea88:	e0bffd17 	ldw	r2,-12(fp)
 321ea8c:	1085883a 	add	r2,r2,r2
 321ea90:	1085883a 	add	r2,r2,r2
 321ea94:	11400bc4 	addi	r5,r2,47
 321ea98:	e13ffe17 	ldw	r4,-8(fp)
 321ea9c:	321e7dc0 	call	321e7dc <alt_read_16bit_query_entry>
 321eaa0:	113fffcc 	andi	r4,r2,65535
 321eaa4:	e0fffe17 	ldw	r3,-8(fp)
 321eaa8:	8004913a 	slli	r2,r16,4
 321eaac:	10c5883a 	add	r2,r2,r3
 321eab0:	10801004 	addi	r2,r2,64
 321eab4:	11000015 	stw	r4,0(r2)
                                                              (0x2F+i*4));
        flash->dev.region_info[i].block_size *= 256;
 321eab8:	e17ffd17 	ldw	r5,-12(fp)
 321eabc:	e0bffd17 	ldw	r2,-12(fp)
 321eac0:	e0fffe17 	ldw	r3,-8(fp)
 321eac4:	1004913a 	slli	r2,r2,4
 321eac8:	10c5883a 	add	r2,r2,r3
 321eacc:	10801004 	addi	r2,r2,64
 321ead0:	10800017 	ldw	r2,0(r2)
 321ead4:	1008923a 	slli	r4,r2,8
 321ead8:	e0fffe17 	ldw	r3,-8(fp)
 321eadc:	2804913a 	slli	r2,r5,4
 321eae0:	10c5883a 	add	r2,r2,r3
 321eae4:	10801004 	addi	r2,r2,64
 321eae8:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].region_size = 
 321eaec:	e17ffd17 	ldw	r5,-12(fp)
 321eaf0:	e0bffd17 	ldw	r2,-12(fp)
 321eaf4:	e0fffe17 	ldw	r3,-8(fp)
 321eaf8:	1004913a 	slli	r2,r2,4
 321eafc:	10c5883a 	add	r2,r2,r3
 321eb00:	10800f04 	addi	r2,r2,60
 321eb04:	11000017 	ldw	r4,0(r2)
 321eb08:	e0bffd17 	ldw	r2,-12(fp)
 321eb0c:	e0fffe17 	ldw	r3,-8(fp)
 321eb10:	1004913a 	slli	r2,r2,4
 321eb14:	10c5883a 	add	r2,r2,r3
 321eb18:	10801004 	addi	r2,r2,64
 321eb1c:	10800017 	ldw	r2,0(r2)
 321eb20:	2089383a 	mul	r4,r4,r2
 321eb24:	e0fffe17 	ldw	r3,-8(fp)
 321eb28:	2804913a 	slli	r2,r5,4
 321eb2c:	10c5883a 	add	r2,r2,r3
 321eb30:	10800e04 	addi	r2,r2,56
 321eb34:	11000015 	stw	r4,0(r2)
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
 321eb38:	e0bffd17 	ldw	r2,-12(fp)
 321eb3c:	e0fffe17 	ldw	r3,-8(fp)
 321eb40:	1004913a 	slli	r2,r2,4
 321eb44:	10c5883a 	add	r2,r2,r3
 321eb48:	10800e04 	addi	r2,r2,56
 321eb4c:	10c00017 	ldw	r3,0(r2)
 321eb50:	e0bff917 	ldw	r2,-28(fp)
 321eb54:	10c5883a 	add	r2,r2,r3
 321eb58:	e0bff915 	stw	r2,-28(fp)
    {
      ret_code = -ENOMEM;
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 321eb5c:	e0bffd17 	ldw	r2,-12(fp)
 321eb60:	10800044 	addi	r2,r2,1
 321eb64:	e0bffd15 	stw	r2,-12(fp)
 321eb68:	e0bffe17 	ldw	r2,-8(fp)
 321eb6c:	10c00c17 	ldw	r3,48(r2)
 321eb70:	e0bffd17 	ldw	r2,-12(fp)
 321eb74:	10ffa916 	blt	r2,r3,321ea1c <alt_read_cfi_table+0x1c4>
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
      }
       
      if (size != device_size)
 321eb78:	e0fff917 	ldw	r3,-28(fp)
 321eb7c:	e0bffb17 	ldw	r2,-20(fp)
 321eb80:	18800226 	beq	r3,r2,321eb8c <alt_read_cfi_table+0x334>
      {
        ret_code = -ENODEV;
 321eb84:	00bffb44 	movi	r2,-19
 321eb88:	e0bffa15 	stw	r2,-24(fp)
      }
    }
    
    boot_mode = (*flash->read_query)( flash, flash->primary_address + 0xf);
 321eb8c:	e0bffe17 	ldw	r2,-8(fp)
 321eb90:	10c03417 	ldw	r3,208(r2)
 321eb94:	e0bffe17 	ldw	r2,-8(fp)
 321eb98:	10803217 	ldw	r2,200(r2)
 321eb9c:	114003c4 	addi	r5,r2,15
 321eba0:	e13ffe17 	ldw	r4,-8(fp)
 321eba4:	183ee83a 	callr	r3
 321eba8:	e0bff405 	stb	r2,-48(fp)
     * Intel Flash parts describe the sections in the order they appear
     * for AMD they just put all the small ones first then the bigger ones
     * So if it's a top boot part we have to reverse the order of the sectors
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
 321ebac:	e0bffe17 	ldw	r2,-8(fp)
 321ebb0:	10802d17 	ldw	r2,180(r2)
 321ebb4:	10800098 	cmpnei	r2,r2,2
 321ebb8:	1000601e 	bne	r2,zero,321ed3c <alt_read_cfi_table+0x4e4>
 321ebbc:	e0bff403 	ldbu	r2,-48(fp)
 321ebc0:	108000d8 	cmpnei	r2,r2,3
 321ebc4:	10005d1e 	bne	r2,zero,321ed3c <alt_read_cfi_table+0x4e4>
    {
      for(i=flash->dev.number_of_regions-1, j=0;
 321ebc8:	e0bffe17 	ldw	r2,-8(fp)
 321ebcc:	10800c17 	ldw	r2,48(r2)
 321ebd0:	10bfffc4 	addi	r2,r2,-1
 321ebd4:	e0bffd15 	stw	r2,-12(fp)
 321ebd8:	e03ffc15 	stw	zero,-16(fp)
          j<=i;i--,j++)
 321ebdc:	00005406 	br	321ed30 <alt_read_cfi_table+0x4d8>
      {
        swap = flash->dev.region_info[i].region_size;
 321ebe0:	e0bffd17 	ldw	r2,-12(fp)
 321ebe4:	e0fffe17 	ldw	r3,-8(fp)
 321ebe8:	1004913a 	slli	r2,r2,4
 321ebec:	10c5883a 	add	r2,r2,r3
 321ebf0:	10800e04 	addi	r2,r2,56
 321ebf4:	10800017 	ldw	r2,0(r2)
 321ebf8:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].region_size =  
 321ebfc:	e17ffd17 	ldw	r5,-12(fp)
 321ec00:	e0bffc17 	ldw	r2,-16(fp)
 321ec04:	e0fffe17 	ldw	r3,-8(fp)
 321ec08:	1004913a 	slli	r2,r2,4
 321ec0c:	10c5883a 	add	r2,r2,r3
 321ec10:	10800e04 	addi	r2,r2,56
 321ec14:	11000017 	ldw	r4,0(r2)
 321ec18:	e0fffe17 	ldw	r3,-8(fp)
 321ec1c:	2804913a 	slli	r2,r5,4
 321ec20:	10c5883a 	add	r2,r2,r3
 321ec24:	10800e04 	addi	r2,r2,56
 321ec28:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].region_size;
        flash->dev.region_info[j].region_size = swap;
 321ec2c:	e0bffc17 	ldw	r2,-16(fp)
 321ec30:	e0fffe17 	ldw	r3,-8(fp)
 321ec34:	1004913a 	slli	r2,r2,4
 321ec38:	10c5883a 	add	r2,r2,r3
 321ec3c:	10c00e04 	addi	r3,r2,56
 321ec40:	e0bff817 	ldw	r2,-32(fp)
 321ec44:	18800015 	stw	r2,0(r3)

        swap = flash->dev.region_info[i].block_size;
 321ec48:	e0bffd17 	ldw	r2,-12(fp)
 321ec4c:	e0fffe17 	ldw	r3,-8(fp)
 321ec50:	1004913a 	slli	r2,r2,4
 321ec54:	10c5883a 	add	r2,r2,r3
 321ec58:	10801004 	addi	r2,r2,64
 321ec5c:	10800017 	ldw	r2,0(r2)
 321ec60:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].block_size =  
 321ec64:	e17ffd17 	ldw	r5,-12(fp)
 321ec68:	e0bffc17 	ldw	r2,-16(fp)
 321ec6c:	e0fffe17 	ldw	r3,-8(fp)
 321ec70:	1004913a 	slli	r2,r2,4
 321ec74:	10c5883a 	add	r2,r2,r3
 321ec78:	10801004 	addi	r2,r2,64
 321ec7c:	11000017 	ldw	r4,0(r2)
 321ec80:	e0fffe17 	ldw	r3,-8(fp)
 321ec84:	2804913a 	slli	r2,r5,4
 321ec88:	10c5883a 	add	r2,r2,r3
 321ec8c:	10801004 	addi	r2,r2,64
 321ec90:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].block_size;
        flash->dev.region_info[j].block_size = swap;
 321ec94:	e0bffc17 	ldw	r2,-16(fp)
 321ec98:	e0fffe17 	ldw	r3,-8(fp)
 321ec9c:	1004913a 	slli	r2,r2,4
 321eca0:	10c5883a 	add	r2,r2,r3
 321eca4:	10c01004 	addi	r3,r2,64
 321eca8:	e0bff817 	ldw	r2,-32(fp)
 321ecac:	18800015 	stw	r2,0(r3)
 
        swap = flash->dev.region_info[i].number_of_blocks;
 321ecb0:	e0bffd17 	ldw	r2,-12(fp)
 321ecb4:	e0fffe17 	ldw	r3,-8(fp)
 321ecb8:	1004913a 	slli	r2,r2,4
 321ecbc:	10c5883a 	add	r2,r2,r3
 321ecc0:	10800f04 	addi	r2,r2,60
 321ecc4:	10800017 	ldw	r2,0(r2)
 321ecc8:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].number_of_blocks =  
 321eccc:	e17ffd17 	ldw	r5,-12(fp)
 321ecd0:	e0bffc17 	ldw	r2,-16(fp)
 321ecd4:	e0fffe17 	ldw	r3,-8(fp)
 321ecd8:	1004913a 	slli	r2,r2,4
 321ecdc:	10c5883a 	add	r2,r2,r3
 321ece0:	10800f04 	addi	r2,r2,60
 321ece4:	11000017 	ldw	r4,0(r2)
 321ece8:	e0fffe17 	ldw	r3,-8(fp)
 321ecec:	2804913a 	slli	r2,r5,4
 321ecf0:	10c5883a 	add	r2,r2,r3
 321ecf4:	10800f04 	addi	r2,r2,60
 321ecf8:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].number_of_blocks;
        flash->dev.region_info[j].number_of_blocks = swap;
 321ecfc:	e0bffc17 	ldw	r2,-16(fp)
 321ed00:	e0fffe17 	ldw	r3,-8(fp)
 321ed04:	1004913a 	slli	r2,r2,4
 321ed08:	10c5883a 	add	r2,r2,r3
 321ed0c:	10c00f04 	addi	r3,r2,60
 321ed10:	e0bff817 	ldw	r2,-32(fp)
 321ed14:	18800015 	stw	r2,0(r3)
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
    {
      for(i=flash->dev.number_of_regions-1, j=0;
          j<=i;i--,j++)
 321ed18:	e0bffd17 	ldw	r2,-12(fp)
 321ed1c:	10bfffc4 	addi	r2,r2,-1
 321ed20:	e0bffd15 	stw	r2,-12(fp)
 321ed24:	e0bffc17 	ldw	r2,-16(fp)
 321ed28:	10800044 	addi	r2,r2,1
 321ed2c:	e0bffc15 	stw	r2,-16(fp)
 321ed30:	e0fffc17 	ldw	r3,-16(fp)
 321ed34:	e0bffd17 	ldw	r2,-12(fp)
 321ed38:	10ffa90e 	bge	r2,r3,321ebe0 <alt_read_cfi_table+0x388>
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 321ed3c:	e03ffd15 	stw	zero,-12(fp)
 321ed40:	00001306 	br	321ed90 <alt_read_cfi_table+0x538>
    {
      flash->dev.region_info[i].offset = offset;
 321ed44:	e0bffd17 	ldw	r2,-12(fp)
 321ed48:	e0fffe17 	ldw	r3,-8(fp)
 321ed4c:	1004913a 	slli	r2,r2,4
 321ed50:	10c5883a 	add	r2,r2,r3
 321ed54:	10c00d04 	addi	r3,r2,52
 321ed58:	e0bff517 	ldw	r2,-44(fp)
 321ed5c:	18800015 	stw	r2,0(r3)
      offset += flash->dev.region_info[i].region_size;
 321ed60:	e0bffd17 	ldw	r2,-12(fp)
 321ed64:	e0fffe17 	ldw	r3,-8(fp)
 321ed68:	1004913a 	slli	r2,r2,4
 321ed6c:	10c5883a 	add	r2,r2,r3
 321ed70:	10800e04 	addi	r2,r2,56
 321ed74:	10c00017 	ldw	r3,0(r2)
 321ed78:	e0bff517 	ldw	r2,-44(fp)
 321ed7c:	10c5883a 	add	r2,r2,r3
 321ed80:	e0bff515 	stw	r2,-44(fp)
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 321ed84:	e0bffd17 	ldw	r2,-12(fp)
 321ed88:	10800044 	addi	r2,r2,1
 321ed8c:	e0bffd15 	stw	r2,-12(fp)
 321ed90:	e0bffe17 	ldw	r2,-8(fp)
 321ed94:	10c00c17 	ldw	r3,48(r2)
 321ed98:	e0bffd17 	ldw	r2,-12(fp)
 321ed9c:	10ffe916 	blt	r2,r3,321ed44 <alt_read_cfi_table+0x4ec>
    {
      flash->dev.region_info[i].offset = offset;
      offset += flash->dev.region_info[i].region_size;
    }

    switch(flash->algorithm)
 321eda0:	e0bffe17 	ldw	r2,-8(fp)
 321eda4:	10802d17 	ldw	r2,180(r2)
 321eda8:	e0bfff15 	stw	r2,-4(fp)
 321edac:	e0ffff17 	ldw	r3,-4(fp)
 321edb0:	188000a0 	cmpeqi	r2,r3,2
 321edb4:	1000071e 	bne	r2,zero,321edd4 <alt_read_cfi_table+0x57c>
 321edb8:	e0ffff17 	ldw	r3,-4(fp)
 321edbc:	188000e0 	cmpeqi	r2,r3,3
 321edc0:	10000c1e 	bne	r2,zero,321edf4 <alt_read_cfi_table+0x59c>
 321edc4:	e0ffff17 	ldw	r3,-4(fp)
 321edc8:	18800060 	cmpeqi	r2,r3,1
 321edcc:	1000091e 	bne	r2,zero,321edf4 <alt_read_cfi_table+0x59c>
 321edd0:	00001006 	br	321ee14 <alt_read_cfi_table+0x5bc>
    {
      case CFI_ALG_AMD:
      {
        (*flash->write_command)(flash->dev.base_addr, 
 321edd4:	e0bffe17 	ldw	r2,-8(fp)
 321edd8:	10c03317 	ldw	r3,204(r2)
 321eddc:	e0bffe17 	ldw	r2,-8(fp)
 321ede0:	11000a17 	ldw	r4,40(r2)
 321ede4:	01401544 	movi	r5,85
 321ede8:	01803c04 	movi	r6,240
 321edec:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_AMD_MODE);
        break;
 321edf0:	00000a06 	br	321ee1c <alt_read_cfi_table+0x5c4>
      }
      case CFI_ALG_INTEL:
      case CFI_ALG_INTEL_STRATA:
      {
        (*flash->write_command)(flash->dev.base_addr, 
 321edf4:	e0bffe17 	ldw	r2,-8(fp)
 321edf8:	10c03317 	ldw	r3,204(r2)
 321edfc:	e0bffe17 	ldw	r2,-8(fp)
 321ee00:	11000a17 	ldw	r4,40(r2)
 321ee04:	01401544 	movi	r5,85
 321ee08:	01803fc4 	movi	r6,255
 321ee0c:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_INTEL_MODE);
        break;
 321ee10:	00000206 	br	321ee1c <alt_read_cfi_table+0x5c4>
      }
      default:
      {
        ret_code = -EIO;
 321ee14:	00bffec4 	movi	r2,-5
 321ee18:	e0bffa15 	stw	r2,-24(fp)
      }
    } 
  }  

  return ret_code;
 321ee1c:	e0bffa17 	ldw	r2,-24(fp)
}
 321ee20:	e037883a 	mov	sp,fp
 321ee24:	dfc00217 	ldw	ra,8(sp)
 321ee28:	df000117 	ldw	fp,4(sp)
 321ee2c:	dc000017 	ldw	r16,0(sp)
 321ee30:	dec00304 	addi	sp,sp,12
 321ee34:	f800283a 	ret

0321ee38 <alt_read_cfi_width>:
 * 
 * Work out the width of the device we're talking to and sanity check that we  
 * can read the CFI and the Primary Vendor specific Table
 */
int alt_read_cfi_width(alt_flash_cfi_dev* flash)
{
 321ee38:	defff704 	addi	sp,sp,-36
 321ee3c:	dfc00815 	stw	ra,32(sp)
 321ee40:	df000715 	stw	fp,28(sp)
 321ee44:	df000704 	addi	fp,sp,28
 321ee48:	e13fff15 	stw	r4,-4(fp)
  int i;
  alt_u8 byte_id[12];
  alt_u16 iface;
  int ret_code = 0;
 321ee4c:	e03ff915 	stw	zero,-28(fp)

  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 321ee50:	e0bfff17 	ldw	r2,-4(fp)
 321ee54:	11000a17 	ldw	r4,40(r2)
 321ee58:	01401544 	movi	r5,85
 321ee5c:	01802604 	movi	r6,152
 321ee60:	321e2e40 	call	321e2e4 <alt_write_flash_command_8bit_device_8bit_mode>

  for(i=0;i<3;i++)
 321ee64:	e03ffb15 	stw	zero,-20(fp)
 321ee68:	00000f06 	br	321eea8 <alt_read_cfi_width+0x70>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
 321ee6c:	e13ffb17 	ldw	r4,-20(fp)
 321ee70:	e0bfff17 	ldw	r2,-4(fp)
 321ee74:	10800a17 	ldw	r2,40(r2)
 321ee78:	1007883a 	mov	r3,r2
 321ee7c:	e0bffb17 	ldw	r2,-20(fp)
 321ee80:	1885883a 	add	r2,r3,r2
 321ee84:	10800404 	addi	r2,r2,16
 321ee88:	10800023 	ldbuio	r2,0(r2)
 321ee8c:	1007883a 	mov	r3,r2
 321ee90:	e0bffc04 	addi	r2,fp,-16
 321ee94:	1105883a 	add	r2,r2,r4
 321ee98:	10c00005 	stb	r3,0(r2)
  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);

  for(i=0;i<3;i++)
 321ee9c:	e0bffb17 	ldw	r2,-20(fp)
 321eea0:	10800044 	addi	r2,r2,1
 321eea4:	e0bffb15 	stw	r2,-20(fp)
 321eea8:	e0bffb17 	ldw	r2,-20(fp)
 321eeac:	108000d0 	cmplti	r2,r2,3
 321eeb0:	103fee1e 	bne	r2,zero,321ee6c <alt_read_cfi_width+0x34>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 321eeb4:	e0bffc03 	ldbu	r2,-16(fp)
 321eeb8:	10803fcc 	andi	r2,r2,255
 321eebc:	10801458 	cmpnei	r2,r2,81
 321eec0:	10001d1e 	bne	r2,zero,321ef38 <alt_read_cfi_width+0x100>
 321eec4:	e0bffc43 	ldbu	r2,-15(fp)
 321eec8:	10803fcc 	andi	r2,r2,255
 321eecc:	10801498 	cmpnei	r2,r2,82
 321eed0:	1000191e 	bne	r2,zero,321ef38 <alt_read_cfi_width+0x100>
 321eed4:	e0bffc83 	ldbu	r2,-14(fp)
 321eed8:	10803fcc 	andi	r2,r2,255
 321eedc:	10801658 	cmpnei	r2,r2,89
 321eee0:	1000151e 	bne	r2,zero,321ef38 <alt_read_cfi_width+0x100>
      (byte_id[1] == 'R') &&
      (byte_id[2] == 'Y'))
  {
    flash->mode_width = 1;
 321eee4:	e0ffff17 	ldw	r3,-4(fp)
 321eee8:	00800044 	movi	r2,1
 321eeec:	18802e15 	stw	r2,184(r3)
    flash->device_width = 1; 
 321eef0:	e0ffff17 	ldw	r3,-4(fp)
 321eef4:	00800044 	movi	r2,1
 321eef8:	18802f15 	stw	r2,188(r3)
    iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR);
 321eefc:	e0bfff17 	ldw	r2,-4(fp)
 321ef00:	10800a17 	ldw	r2,40(r2)
 321ef04:	10800a04 	addi	r2,r2,40
 321ef08:	1080002b 	ldhuio	r2,0(r2)
 321ef0c:	e0bffa0d 	sth	r2,-24(fp)
    iface += 1;
 321ef10:	e0bffa0b 	ldhu	r2,-24(fp)
 321ef14:	10800044 	addi	r2,r2,1
 321ef18:	e0bffa0d 	sth	r2,-24(fp)
    if (!(iface & 0x1))
 321ef1c:	e0bffa0b 	ldhu	r2,-24(fp)
 321ef20:	1080004c 	andi	r2,r2,1
 321ef24:	1004c03a 	cmpne	r2,r2,zero
 321ef28:	1001a81e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
    {
      ret_code = -ENODEV;
 321ef2c:	00bffb44 	movi	r2,-19
 321ef30:	e0bff915 	stw	r2,-28(fp)
  for(i=0;i<3;i++)
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 321ef34:	0001a506 	br	321f5cc <alt_read_cfi_width+0x794>
  else
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 321ef38:	e0bfff17 	ldw	r2,-4(fp)
 321ef3c:	11000a17 	ldw	r4,40(r2)
 321ef40:	01401544 	movi	r5,85
 321ef44:	01802604 	movi	r6,152
 321ef48:	321e3200 	call	321e320 <alt_write_flash_command_16bit_device_8bit_mode>
    for(i=0;i<6;i++)
 321ef4c:	e03ffb15 	stw	zero,-20(fp)
 321ef50:	00000f06 	br	321ef90 <alt_read_cfi_width+0x158>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 321ef54:	e13ffb17 	ldw	r4,-20(fp)
 321ef58:	e0bfff17 	ldw	r2,-4(fp)
 321ef5c:	10800a17 	ldw	r2,40(r2)
 321ef60:	1007883a 	mov	r3,r2
 321ef64:	e0bffb17 	ldw	r2,-20(fp)
 321ef68:	1885883a 	add	r2,r3,r2
 321ef6c:	10800804 	addi	r2,r2,32
 321ef70:	10800023 	ldbuio	r2,0(r2)
 321ef74:	1007883a 	mov	r3,r2
 321ef78:	e0bffc04 	addi	r2,fp,-16
 321ef7c:	1105883a 	add	r2,r2,r4
 321ef80:	10c00005 	stb	r3,0(r2)
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
    for(i=0;i<6;i++)
 321ef84:	e0bffb17 	ldw	r2,-20(fp)
 321ef88:	10800044 	addi	r2,r2,1
 321ef8c:	e0bffb15 	stw	r2,-20(fp)
 321ef90:	e0bffb17 	ldw	r2,-20(fp)
 321ef94:	10800190 	cmplti	r2,r2,6
 321ef98:	103fee1e 	bne	r2,zero,321ef54 <alt_read_cfi_width+0x11c>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 321ef9c:	e0bffc03 	ldbu	r2,-16(fp)
 321efa0:	10803fcc 	andi	r2,r2,255
 321efa4:	10801458 	cmpnei	r2,r2,81
 321efa8:	1000291e 	bne	r2,zero,321f050 <alt_read_cfi_width+0x218>
 321efac:	e0bffc43 	ldbu	r2,-15(fp)
 321efb0:	10803fcc 	andi	r2,r2,255
 321efb4:	10801458 	cmpnei	r2,r2,81
 321efb8:	1000251e 	bne	r2,zero,321f050 <alt_read_cfi_width+0x218>
 321efbc:	e0bffc83 	ldbu	r2,-14(fp)
 321efc0:	10803fcc 	andi	r2,r2,255
 321efc4:	10801498 	cmpnei	r2,r2,82
 321efc8:	1000211e 	bne	r2,zero,321f050 <alt_read_cfi_width+0x218>
 321efcc:	e0bffcc3 	ldbu	r2,-13(fp)
 321efd0:	10803fcc 	andi	r2,r2,255
 321efd4:	10801498 	cmpnei	r2,r2,82
 321efd8:	10001d1e 	bne	r2,zero,321f050 <alt_read_cfi_width+0x218>
 321efdc:	e0bffd03 	ldbu	r2,-12(fp)
 321efe0:	10803fcc 	andi	r2,r2,255
 321efe4:	10801658 	cmpnei	r2,r2,89
 321efe8:	1000191e 	bne	r2,zero,321f050 <alt_read_cfi_width+0x218>
 321efec:	e0bffd43 	ldbu	r2,-11(fp)
 321eff0:	10803fcc 	andi	r2,r2,255
 321eff4:	10801658 	cmpnei	r2,r2,89
 321eff8:	1000151e 	bne	r2,zero,321f050 <alt_read_cfi_width+0x218>
        (byte_id[2] == 'R') &&
        (byte_id[3] == 'R') && 
        (byte_id[4] == 'Y') && 
        (byte_id[5] == 'Y'))
    {
      flash->mode_width = 1;
 321effc:	e0ffff17 	ldw	r3,-4(fp)
 321f000:	00800044 	movi	r2,1
 321f004:	18802e15 	stw	r2,184(r3)
      flash->device_width = 2; 
 321f008:	e0ffff17 	ldw	r3,-4(fp)
 321f00c:	00800084 	movi	r2,2
 321f010:	18802f15 	stw	r2,188(r3)
      iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 321f014:	e0bfff17 	ldw	r2,-4(fp)
 321f018:	10800a17 	ldw	r2,40(r2)
 321f01c:	10801404 	addi	r2,r2,80
 321f020:	1080002b 	ldhuio	r2,0(r2)
 321f024:	e0bffa0d 	sth	r2,-24(fp)
      iface += 1;
 321f028:	e0bffa0b 	ldhu	r2,-24(fp)
 321f02c:	10800044 	addi	r2,r2,1
 321f030:	e0bffa0d 	sth	r2,-24(fp)
      if (!(iface & 0x1))
 321f034:	e0bffa0b 	ldhu	r2,-24(fp)
 321f038:	1080004c 	andi	r2,r2,1
 321f03c:	1004c03a 	cmpne	r2,r2,zero
 321f040:	1001621e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
      {
        ret_code = -ENODEV;
 321f044:	00bffb44 	movi	r2,-19
 321f048:	e0bff915 	stw	r2,-28(fp)
    for(i=0;i<6;i++)
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 321f04c:	00015f06 	br	321f5cc <alt_read_cfi_width+0x794>
    else
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 321f050:	e0bfff17 	ldw	r2,-4(fp)
 321f054:	11000a17 	ldw	r4,40(r2)
 321f058:	01401544 	movi	r5,85
 321f05c:	01802604 	movi	r6,152
 321f060:	321e3e40 	call	321e3e4 <alt_write_flash_command_16bit_device_16bit_mode>
      for(i=0;i<6;i++)
 321f064:	e03ffb15 	stw	zero,-20(fp)
 321f068:	00000f06 	br	321f0a8 <alt_read_cfi_width+0x270>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 321f06c:	e13ffb17 	ldw	r4,-20(fp)
 321f070:	e0bfff17 	ldw	r2,-4(fp)
 321f074:	10800a17 	ldw	r2,40(r2)
 321f078:	1007883a 	mov	r3,r2
 321f07c:	e0bffb17 	ldw	r2,-20(fp)
 321f080:	1885883a 	add	r2,r3,r2
 321f084:	10800804 	addi	r2,r2,32
 321f088:	10800023 	ldbuio	r2,0(r2)
 321f08c:	1007883a 	mov	r3,r2
 321f090:	e0bffc04 	addi	r2,fp,-16
 321f094:	1105883a 	add	r2,r2,r4
 321f098:	10c00005 	stb	r3,0(r2)
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
      for(i=0;i<6;i++)
 321f09c:	e0bffb17 	ldw	r2,-20(fp)
 321f0a0:	10800044 	addi	r2,r2,1
 321f0a4:	e0bffb15 	stw	r2,-20(fp)
 321f0a8:	e0bffb17 	ldw	r2,-20(fp)
 321f0ac:	10800190 	cmplti	r2,r2,6
 321f0b0:	103fee1e 	bne	r2,zero,321f06c <alt_read_cfi_width+0x234>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 321f0b4:	e0bffc03 	ldbu	r2,-16(fp)
 321f0b8:	10803fcc 	andi	r2,r2,255
 321f0bc:	10801458 	cmpnei	r2,r2,81
 321f0c0:	1000291e 	bne	r2,zero,321f168 <alt_read_cfi_width+0x330>
 321f0c4:	e0bffc43 	ldbu	r2,-15(fp)
 321f0c8:	10803fcc 	andi	r2,r2,255
 321f0cc:	1004c03a 	cmpne	r2,r2,zero
 321f0d0:	1000251e 	bne	r2,zero,321f168 <alt_read_cfi_width+0x330>
 321f0d4:	e0bffc83 	ldbu	r2,-14(fp)
 321f0d8:	10803fcc 	andi	r2,r2,255
 321f0dc:	10801498 	cmpnei	r2,r2,82
 321f0e0:	1000211e 	bne	r2,zero,321f168 <alt_read_cfi_width+0x330>
 321f0e4:	e0bffcc3 	ldbu	r2,-13(fp)
 321f0e8:	10803fcc 	andi	r2,r2,255
 321f0ec:	1004c03a 	cmpne	r2,r2,zero
 321f0f0:	10001d1e 	bne	r2,zero,321f168 <alt_read_cfi_width+0x330>
 321f0f4:	e0bffd03 	ldbu	r2,-12(fp)
 321f0f8:	10803fcc 	andi	r2,r2,255
 321f0fc:	10801658 	cmpnei	r2,r2,89
 321f100:	1000191e 	bne	r2,zero,321f168 <alt_read_cfi_width+0x330>
 321f104:	e0bffd43 	ldbu	r2,-11(fp)
 321f108:	10803fcc 	andi	r2,r2,255
 321f10c:	1004c03a 	cmpne	r2,r2,zero
 321f110:	1000151e 	bne	r2,zero,321f168 <alt_read_cfi_width+0x330>
          (byte_id[2] == 'R') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'Y') && 
          (byte_id[5] == '\0'))
      {
        flash->mode_width = 2;
 321f114:	e0ffff17 	ldw	r3,-4(fp)
 321f118:	00800084 	movi	r2,2
 321f11c:	18802e15 	stw	r2,184(r3)
        flash->device_width = 2; 
 321f120:	e0ffff17 	ldw	r3,-4(fp)
 321f124:	00800084 	movi	r2,2
 321f128:	18802f15 	stw	r2,188(r3)
        iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 321f12c:	e0bfff17 	ldw	r2,-4(fp)
 321f130:	10800a17 	ldw	r2,40(r2)
 321f134:	10801404 	addi	r2,r2,80
 321f138:	1080002b 	ldhuio	r2,0(r2)
 321f13c:	e0bffa0d 	sth	r2,-24(fp)
        iface += 1;
 321f140:	e0bffa0b 	ldhu	r2,-24(fp)
 321f144:	10800044 	addi	r2,r2,1
 321f148:	e0bffa0d 	sth	r2,-24(fp)
        if (!(iface & 0x2))
 321f14c:	e0bffa0b 	ldhu	r2,-24(fp)
 321f150:	1080008c 	andi	r2,r2,2
 321f154:	1004c03a 	cmpne	r2,r2,zero
 321f158:	10011c1e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
        {
          ret_code = -ENODEV;
 321f15c:	00bffb44 	movi	r2,-19
 321f160:	e0bff915 	stw	r2,-28(fp)
      for(i=0;i<6;i++)
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 321f164:	00011906 	br	321f5cc <alt_read_cfi_width+0x794>
      else
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 321f168:	e0bfff17 	ldw	r2,-4(fp)
 321f16c:	11000a17 	ldw	r4,40(r2)
 321f170:	01401544 	movi	r5,85
 321f174:	01802604 	movi	r6,152
 321f178:	321e4700 	call	321e470 <alt_write_flash_command_32bit_device_32bit_mode>
        for(i=0;i<12;i++)
 321f17c:	e03ffb15 	stw	zero,-20(fp)
 321f180:	00000f06 	br	321f1c0 <alt_read_cfi_width+0x388>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 321f184:	e13ffb17 	ldw	r4,-20(fp)
 321f188:	e0bfff17 	ldw	r2,-4(fp)
 321f18c:	10800a17 	ldw	r2,40(r2)
 321f190:	1007883a 	mov	r3,r2
 321f194:	e0bffb17 	ldw	r2,-20(fp)
 321f198:	1885883a 	add	r2,r3,r2
 321f19c:	10801004 	addi	r2,r2,64
 321f1a0:	10800023 	ldbuio	r2,0(r2)
 321f1a4:	1007883a 	mov	r3,r2
 321f1a8:	e0bffc04 	addi	r2,fp,-16
 321f1ac:	1105883a 	add	r2,r2,r4
 321f1b0:	10c00005 	stb	r3,0(r2)
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
        for(i=0;i<12;i++)
 321f1b4:	e0bffb17 	ldw	r2,-20(fp)
 321f1b8:	10800044 	addi	r2,r2,1
 321f1bc:	e0bffb15 	stw	r2,-20(fp)
 321f1c0:	e0bffb17 	ldw	r2,-20(fp)
 321f1c4:	10800310 	cmplti	r2,r2,12
 321f1c8:	103fee1e 	bne	r2,zero,321f184 <alt_read_cfi_width+0x34c>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 321f1cc:	e0bffc03 	ldbu	r2,-16(fp)
 321f1d0:	10803fcc 	andi	r2,r2,255
 321f1d4:	10801458 	cmpnei	r2,r2,81
 321f1d8:	1000411e 	bne	r2,zero,321f2e0 <alt_read_cfi_width+0x4a8>
 321f1dc:	e0bffc43 	ldbu	r2,-15(fp)
 321f1e0:	10803fcc 	andi	r2,r2,255
 321f1e4:	1004c03a 	cmpne	r2,r2,zero
 321f1e8:	10003d1e 	bne	r2,zero,321f2e0 <alt_read_cfi_width+0x4a8>
 321f1ec:	e0bffc83 	ldbu	r2,-14(fp)
 321f1f0:	10803fcc 	andi	r2,r2,255
 321f1f4:	1004c03a 	cmpne	r2,r2,zero
 321f1f8:	1000391e 	bne	r2,zero,321f2e0 <alt_read_cfi_width+0x4a8>
 321f1fc:	e0bffcc3 	ldbu	r2,-13(fp)
 321f200:	10803fcc 	andi	r2,r2,255
 321f204:	1004c03a 	cmpne	r2,r2,zero
 321f208:	1000351e 	bne	r2,zero,321f2e0 <alt_read_cfi_width+0x4a8>
 321f20c:	e0bffd03 	ldbu	r2,-12(fp)
 321f210:	10803fcc 	andi	r2,r2,255
 321f214:	10801498 	cmpnei	r2,r2,82
 321f218:	1000311e 	bne	r2,zero,321f2e0 <alt_read_cfi_width+0x4a8>
 321f21c:	e0bffd43 	ldbu	r2,-11(fp)
 321f220:	10803fcc 	andi	r2,r2,255
 321f224:	1004c03a 	cmpne	r2,r2,zero
 321f228:	10002d1e 	bne	r2,zero,321f2e0 <alt_read_cfi_width+0x4a8>
 321f22c:	e0bffd83 	ldbu	r2,-10(fp)
 321f230:	10803fcc 	andi	r2,r2,255
 321f234:	1004c03a 	cmpne	r2,r2,zero
 321f238:	1000291e 	bne	r2,zero,321f2e0 <alt_read_cfi_width+0x4a8>
 321f23c:	e0bffdc3 	ldbu	r2,-9(fp)
 321f240:	10803fcc 	andi	r2,r2,255
 321f244:	1004c03a 	cmpne	r2,r2,zero
 321f248:	1000251e 	bne	r2,zero,321f2e0 <alt_read_cfi_width+0x4a8>
 321f24c:	e0bffe03 	ldbu	r2,-8(fp)
 321f250:	10803fcc 	andi	r2,r2,255
 321f254:	10801658 	cmpnei	r2,r2,89
 321f258:	1000211e 	bne	r2,zero,321f2e0 <alt_read_cfi_width+0x4a8>
 321f25c:	e0bffe43 	ldbu	r2,-7(fp)
 321f260:	10803fcc 	andi	r2,r2,255
 321f264:	1004c03a 	cmpne	r2,r2,zero
 321f268:	10001d1e 	bne	r2,zero,321f2e0 <alt_read_cfi_width+0x4a8>
 321f26c:	e0bffe83 	ldbu	r2,-6(fp)
 321f270:	10803fcc 	andi	r2,r2,255
 321f274:	1004c03a 	cmpne	r2,r2,zero
 321f278:	1000191e 	bne	r2,zero,321f2e0 <alt_read_cfi_width+0x4a8>
 321f27c:	e0bffec3 	ldbu	r2,-5(fp)
 321f280:	10803fcc 	andi	r2,r2,255
 321f284:	1004c03a 	cmpne	r2,r2,zero
 321f288:	1000151e 	bne	r2,zero,321f2e0 <alt_read_cfi_width+0x4a8>
          (byte_id[8] == 'Y') && 
          (byte_id[9] == '\0') && 
          (byte_id[10] == '\0') && 
          (byte_id[11] == '\0'))
        {
          flash->mode_width = 4;
 321f28c:	e0ffff17 	ldw	r3,-4(fp)
 321f290:	00800104 	movi	r2,4
 321f294:	18802e15 	stw	r2,184(r3)
          flash->device_width = 4; 
 321f298:	e0ffff17 	ldw	r3,-4(fp)
 321f29c:	00800104 	movi	r2,4
 321f2a0:	18802f15 	stw	r2,188(r3)
          iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 321f2a4:	e0bfff17 	ldw	r2,-4(fp)
 321f2a8:	10800a17 	ldw	r2,40(r2)
 321f2ac:	10802804 	addi	r2,r2,160
 321f2b0:	10800037 	ldwio	r2,0(r2)
 321f2b4:	e0bffa0d 	sth	r2,-24(fp)
          iface += 1;
 321f2b8:	e0bffa0b 	ldhu	r2,-24(fp)
 321f2bc:	10800044 	addi	r2,r2,1
 321f2c0:	e0bffa0d 	sth	r2,-24(fp)
          if (!(iface & 0x4))
 321f2c4:	e0bffa0b 	ldhu	r2,-24(fp)
 321f2c8:	1080010c 	andi	r2,r2,4
 321f2cc:	1004c03a 	cmpne	r2,r2,zero
 321f2d0:	1000be1e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
          {
            ret_code = -ENODEV;
 321f2d4:	00bffb44 	movi	r2,-19
 321f2d8:	e0bff915 	stw	r2,-28(fp)
        for(i=0;i<12;i++)
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 321f2dc:	0000bb06 	br	321f5cc <alt_read_cfi_width+0x794>
        else
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 321f2e0:	e0bfff17 	ldw	r2,-4(fp)
 321f2e4:	11000a17 	ldw	r4,40(r2)
 321f2e8:	01401544 	movi	r5,85
 321f2ec:	01802604 	movi	r6,152
 321f2f0:	321e4280 	call	321e428 <alt_write_flash_command_32bit_device_16bit_mode>
          for(i=0;i<12;i++)
 321f2f4:	e03ffb15 	stw	zero,-20(fp)
 321f2f8:	00000f06 	br	321f338 <alt_read_cfi_width+0x500>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 321f2fc:	e13ffb17 	ldw	r4,-20(fp)
 321f300:	e0bfff17 	ldw	r2,-4(fp)
 321f304:	10800a17 	ldw	r2,40(r2)
 321f308:	1007883a 	mov	r3,r2
 321f30c:	e0bffb17 	ldw	r2,-20(fp)
 321f310:	1885883a 	add	r2,r3,r2
 321f314:	10801004 	addi	r2,r2,64
 321f318:	10800023 	ldbuio	r2,0(r2)
 321f31c:	1007883a 	mov	r3,r2
 321f320:	e0bffc04 	addi	r2,fp,-16
 321f324:	1105883a 	add	r2,r2,r4
 321f328:	10c00005 	stb	r3,0(r2)
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
          for(i=0;i<12;i++)
 321f32c:	e0bffb17 	ldw	r2,-20(fp)
 321f330:	10800044 	addi	r2,r2,1
 321f334:	e0bffb15 	stw	r2,-20(fp)
 321f338:	e0bffb17 	ldw	r2,-20(fp)
 321f33c:	10800310 	cmplti	r2,r2,12
 321f340:	103fee1e 	bne	r2,zero,321f2fc <alt_read_cfi_width+0x4c4>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 321f344:	e0bffc03 	ldbu	r2,-16(fp)
 321f348:	10803fcc 	andi	r2,r2,255
 321f34c:	10801458 	cmpnei	r2,r2,81
 321f350:	1000411e 	bne	r2,zero,321f458 <alt_read_cfi_width+0x620>
 321f354:	e0bffc43 	ldbu	r2,-15(fp)
 321f358:	10803fcc 	andi	r2,r2,255
 321f35c:	1004c03a 	cmpne	r2,r2,zero
 321f360:	10003d1e 	bne	r2,zero,321f458 <alt_read_cfi_width+0x620>
 321f364:	e0bffc83 	ldbu	r2,-14(fp)
 321f368:	10803fcc 	andi	r2,r2,255
 321f36c:	10801458 	cmpnei	r2,r2,81
 321f370:	1000391e 	bne	r2,zero,321f458 <alt_read_cfi_width+0x620>
 321f374:	e0bffcc3 	ldbu	r2,-13(fp)
 321f378:	10803fcc 	andi	r2,r2,255
 321f37c:	1004c03a 	cmpne	r2,r2,zero
 321f380:	1000351e 	bne	r2,zero,321f458 <alt_read_cfi_width+0x620>
 321f384:	e0bffd03 	ldbu	r2,-12(fp)
 321f388:	10803fcc 	andi	r2,r2,255
 321f38c:	10801498 	cmpnei	r2,r2,82
 321f390:	1000311e 	bne	r2,zero,321f458 <alt_read_cfi_width+0x620>
 321f394:	e0bffd43 	ldbu	r2,-11(fp)
 321f398:	10803fcc 	andi	r2,r2,255
 321f39c:	1004c03a 	cmpne	r2,r2,zero
 321f3a0:	10002d1e 	bne	r2,zero,321f458 <alt_read_cfi_width+0x620>
 321f3a4:	e0bffd83 	ldbu	r2,-10(fp)
 321f3a8:	10803fcc 	andi	r2,r2,255
 321f3ac:	10801498 	cmpnei	r2,r2,82
 321f3b0:	1000291e 	bne	r2,zero,321f458 <alt_read_cfi_width+0x620>
 321f3b4:	e0bffdc3 	ldbu	r2,-9(fp)
 321f3b8:	10803fcc 	andi	r2,r2,255
 321f3bc:	1004c03a 	cmpne	r2,r2,zero
 321f3c0:	1000251e 	bne	r2,zero,321f458 <alt_read_cfi_width+0x620>
 321f3c4:	e0bffe03 	ldbu	r2,-8(fp)
 321f3c8:	10803fcc 	andi	r2,r2,255
 321f3cc:	10801658 	cmpnei	r2,r2,89
 321f3d0:	1000211e 	bne	r2,zero,321f458 <alt_read_cfi_width+0x620>
 321f3d4:	e0bffe43 	ldbu	r2,-7(fp)
 321f3d8:	10803fcc 	andi	r2,r2,255
 321f3dc:	1004c03a 	cmpne	r2,r2,zero
 321f3e0:	10001d1e 	bne	r2,zero,321f458 <alt_read_cfi_width+0x620>
 321f3e4:	e0bffe83 	ldbu	r2,-6(fp)
 321f3e8:	10803fcc 	andi	r2,r2,255
 321f3ec:	10801658 	cmpnei	r2,r2,89
 321f3f0:	1000191e 	bne	r2,zero,321f458 <alt_read_cfi_width+0x620>
 321f3f4:	e0bffec3 	ldbu	r2,-5(fp)
 321f3f8:	10803fcc 	andi	r2,r2,255
 321f3fc:	1004c03a 	cmpne	r2,r2,zero
 321f400:	1000151e 	bne	r2,zero,321f458 <alt_read_cfi_width+0x620>
              (byte_id[8] == 'Y') &&
              (byte_id[9] == '\0') &&
              (byte_id[10] == 'Y') &&
              (byte_id[11] == '\0'))
          {
            flash->mode_width = 2;
 321f404:	e0ffff17 	ldw	r3,-4(fp)
 321f408:	00800084 	movi	r2,2
 321f40c:	18802e15 	stw	r2,184(r3)
            flash->device_width = 4; 
 321f410:	e0ffff17 	ldw	r3,-4(fp)
 321f414:	00800104 	movi	r2,4
 321f418:	18802f15 	stw	r2,188(r3)
            iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 321f41c:	e0bfff17 	ldw	r2,-4(fp)
 321f420:	10800a17 	ldw	r2,40(r2)
 321f424:	10802804 	addi	r2,r2,160
 321f428:	10800037 	ldwio	r2,0(r2)
 321f42c:	e0bffa0d 	sth	r2,-24(fp)
            iface += 1;
 321f430:	e0bffa0b 	ldhu	r2,-24(fp)
 321f434:	10800044 	addi	r2,r2,1
 321f438:	e0bffa0d 	sth	r2,-24(fp)
            if (!(iface & 0x4))
 321f43c:	e0bffa0b 	ldhu	r2,-24(fp)
 321f440:	1080010c 	andi	r2,r2,4
 321f444:	1004c03a 	cmpne	r2,r2,zero
 321f448:	1000601e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
            {
              ret_code = -ENODEV;
 321f44c:	00bffb44 	movi	r2,-19
 321f450:	e0bff915 	stw	r2,-28(fp)
          for(i=0;i<12;i++)
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 321f454:	00005d06 	br	321f5cc <alt_read_cfi_width+0x794>
          else
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 321f458:	e0bfff17 	ldw	r2,-4(fp)
 321f45c:	11000a17 	ldw	r4,40(r2)
 321f460:	01401544 	movi	r5,85
 321f464:	01802604 	movi	r6,152
 321f468:	321e39c0 	call	321e39c <alt_write_flash_command_32bit_device_8bit_mode>
            for(i=0;i<12;i++)
 321f46c:	e03ffb15 	stw	zero,-20(fp)
 321f470:	00000f06 	br	321f4b0 <alt_read_cfi_width+0x678>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 321f474:	e13ffb17 	ldw	r4,-20(fp)
 321f478:	e0bfff17 	ldw	r2,-4(fp)
 321f47c:	10800a17 	ldw	r2,40(r2)
 321f480:	1007883a 	mov	r3,r2
 321f484:	e0bffb17 	ldw	r2,-20(fp)
 321f488:	1885883a 	add	r2,r3,r2
 321f48c:	10801004 	addi	r2,r2,64
 321f490:	10800023 	ldbuio	r2,0(r2)
 321f494:	1007883a 	mov	r3,r2
 321f498:	e0bffc04 	addi	r2,fp,-16
 321f49c:	1105883a 	add	r2,r2,r4
 321f4a0:	10c00005 	stb	r3,0(r2)
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
            for(i=0;i<12;i++)
 321f4a4:	e0bffb17 	ldw	r2,-20(fp)
 321f4a8:	10800044 	addi	r2,r2,1
 321f4ac:	e0bffb15 	stw	r2,-20(fp)
 321f4b0:	e0bffb17 	ldw	r2,-20(fp)
 321f4b4:	10800310 	cmplti	r2,r2,12
 321f4b8:	103fee1e 	bne	r2,zero,321f474 <alt_read_cfi_width+0x63c>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
 321f4bc:	e0bffc03 	ldbu	r2,-16(fp)
 321f4c0:	10803fcc 	andi	r2,r2,255
 321f4c4:	10801458 	cmpnei	r2,r2,81
 321f4c8:	1000401e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
 321f4cc:	e0bffc43 	ldbu	r2,-15(fp)
 321f4d0:	10803fcc 	andi	r2,r2,255
 321f4d4:	10801458 	cmpnei	r2,r2,81
 321f4d8:	10003c1e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
 321f4dc:	e0bffc83 	ldbu	r2,-14(fp)
 321f4e0:	10803fcc 	andi	r2,r2,255
 321f4e4:	10801458 	cmpnei	r2,r2,81
 321f4e8:	1000381e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
 321f4ec:	e0bffcc3 	ldbu	r2,-13(fp)
 321f4f0:	10803fcc 	andi	r2,r2,255
 321f4f4:	10801458 	cmpnei	r2,r2,81
 321f4f8:	1000341e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
 321f4fc:	e0bffd03 	ldbu	r2,-12(fp)
 321f500:	10803fcc 	andi	r2,r2,255
 321f504:	10801498 	cmpnei	r2,r2,82
 321f508:	1000301e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
 321f50c:	e0bffd43 	ldbu	r2,-11(fp)
 321f510:	10803fcc 	andi	r2,r2,255
 321f514:	10801498 	cmpnei	r2,r2,82
 321f518:	10002c1e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
 321f51c:	e0bffd83 	ldbu	r2,-10(fp)
 321f520:	10803fcc 	andi	r2,r2,255
 321f524:	10801498 	cmpnei	r2,r2,82
 321f528:	1000281e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
 321f52c:	e0bffdc3 	ldbu	r2,-9(fp)
 321f530:	10803fcc 	andi	r2,r2,255
 321f534:	10801498 	cmpnei	r2,r2,82
 321f538:	1000241e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
 321f53c:	e0bffe03 	ldbu	r2,-8(fp)
 321f540:	10803fcc 	andi	r2,r2,255
 321f544:	10801658 	cmpnei	r2,r2,89
 321f548:	1000201e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
 321f54c:	e0bffe43 	ldbu	r2,-7(fp)
 321f550:	10803fcc 	andi	r2,r2,255
 321f554:	10801658 	cmpnei	r2,r2,89
 321f558:	10001c1e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
 321f55c:	e0bffe83 	ldbu	r2,-6(fp)
 321f560:	10803fcc 	andi	r2,r2,255
 321f564:	10801658 	cmpnei	r2,r2,89
 321f568:	1000181e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
 321f56c:	e0bffec3 	ldbu	r2,-5(fp)
 321f570:	10803fcc 	andi	r2,r2,255
 321f574:	10801658 	cmpnei	r2,r2,89
 321f578:	1000141e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
                (byte_id[8] == 'Y') && 
                (byte_id[9] == 'Y') && 
                (byte_id[10] == 'Y') && 
                (byte_id[11] == 'Y'))
            {
              flash->mode_width = 1;
 321f57c:	e0ffff17 	ldw	r3,-4(fp)
 321f580:	00800044 	movi	r2,1
 321f584:	18802e15 	stw	r2,184(r3)
              flash->device_width = 4; 
 321f588:	e0ffff17 	ldw	r3,-4(fp)
 321f58c:	00800104 	movi	r2,4
 321f590:	18802f15 	stw	r2,188(r3)
              iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 321f594:	e0bfff17 	ldw	r2,-4(fp)
 321f598:	10800a17 	ldw	r2,40(r2)
 321f59c:	10802804 	addi	r2,r2,160
 321f5a0:	10800037 	ldwio	r2,0(r2)
 321f5a4:	e0bffa0d 	sth	r2,-24(fp)
              iface += 1;
 321f5a8:	e0bffa0b 	ldhu	r2,-24(fp)
 321f5ac:	10800044 	addi	r2,r2,1
 321f5b0:	e0bffa0d 	sth	r2,-24(fp)
              if (!(iface & 0x4))
 321f5b4:	e0bffa0b 	ldhu	r2,-24(fp)
 321f5b8:	1080010c 	andi	r2,r2,4
 321f5bc:	1004c03a 	cmpne	r2,r2,zero
 321f5c0:	1000021e 	bne	r2,zero,321f5cc <alt_read_cfi_width+0x794>
              {
                ret_code = -ENODEV;
 321f5c4:	00bffb44 	movi	r2,-19
 321f5c8:	e0bff915 	stw	r2,-28(fp)
        }
      }
    }
  }
  
  return ret_code;
 321f5cc:	e0bff917 	ldw	r2,-28(fp)
}
 321f5d0:	e037883a 	mov	sp,fp
 321f5d4:	dfc00117 	ldw	ra,4(sp)
 321f5d8:	df000017 	ldw	fp,0(sp)
 321f5dc:	dec00204 	addi	sp,sp,8
 321f5e0:	f800283a 	ret

0321f5e4 <alt_check_primary_table>:
 * 
 * Check that the primary Vendor table starts with the 
 * correct pattern
 */
int alt_check_primary_table(alt_flash_cfi_dev* flash)
{
 321f5e4:	defff904 	addi	sp,sp,-28
 321f5e8:	dfc00615 	stw	ra,24(sp)
 321f5ec:	df000515 	stw	fp,20(sp)
 321f5f0:	dc000415 	stw	r16,16(sp)
 321f5f4:	df000404 	addi	fp,sp,16
 321f5f8:	e13fff15 	stw	r4,-4(fp)
  int i;
  int ret_code = 0;
 321f5fc:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
 321f600:	e13fff17 	ldw	r4,-4(fp)
 321f604:	01400544 	movi	r5,21
 321f608:	321e7dc0 	call	321e7dc <alt_read_16bit_query_entry>
 321f60c:	10ffffcc 	andi	r3,r2,65535
 321f610:	e0bfff17 	ldw	r2,-4(fp)
 321f614:	10c03215 	stw	r3,200(r2)
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 321f618:	e03ffd15 	stw	zero,-12(fp)
 321f61c:	00001006 	br	321f660 <alt_check_primary_table+0x7c>
  {
    primary_query_string[i] = 
 321f620:	e43ffd17 	ldw	r16,-12(fp)
 321f624:	e0bfff17 	ldw	r2,-4(fp)
 321f628:	11803417 	ldw	r6,208(r2)
 321f62c:	e0bfff17 	ldw	r2,-4(fp)
 321f630:	10c03217 	ldw	r3,200(r2)
 321f634:	e0bffd17 	ldw	r2,-12(fp)
 321f638:	188b883a 	add	r5,r3,r2
 321f63c:	e13fff17 	ldw	r4,-4(fp)
 321f640:	303ee83a 	callr	r6
 321f644:	1007883a 	mov	r3,r2
 321f648:	e0bffe04 	addi	r2,fp,-8
 321f64c:	1405883a 	add	r2,r2,r16
 321f650:	10c00005 	stb	r3,0(r2)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 321f654:	e0bffd17 	ldw	r2,-12(fp)
 321f658:	10800044 	addi	r2,r2,1
 321f65c:	e0bffd15 	stw	r2,-12(fp)
 321f660:	e0bffd17 	ldw	r2,-12(fp)
 321f664:	108000d0 	cmplti	r2,r2,3
 321f668:	103fed1e 	bne	r2,zero,321f620 <alt_check_primary_table+0x3c>
  {
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
  }
    
  if ((primary_query_string[0] != 'P') ||
 321f66c:	e0bffe03 	ldbu	r2,-8(fp)
 321f670:	10803fcc 	andi	r2,r2,255
 321f674:	10801418 	cmpnei	r2,r2,80
 321f678:	1000081e 	bne	r2,zero,321f69c <alt_check_primary_table+0xb8>
 321f67c:	e0bffe43 	ldbu	r2,-7(fp)
 321f680:	10803fcc 	andi	r2,r2,255
 321f684:	10801498 	cmpnei	r2,r2,82
 321f688:	1000041e 	bne	r2,zero,321f69c <alt_check_primary_table+0xb8>
 321f68c:	e0bffe83 	ldbu	r2,-6(fp)
 321f690:	10803fcc 	andi	r2,r2,255
 321f694:	10801260 	cmpeqi	r2,r2,73
 321f698:	1000021e 	bne	r2,zero,321f6a4 <alt_check_primary_table+0xc0>
      (primary_query_string[1] != 'R') ||
      (primary_query_string[2] != 'I'))
  {
    ret_code = -ENODEV;
 321f69c:	00bffb44 	movi	r2,-19
 321f6a0:	e0bffc15 	stw	r2,-16(fp)
  }
  
  return ret_code;
 321f6a4:	e0bffc17 	ldw	r2,-16(fp)
}
 321f6a8:	e037883a 	mov	sp,fp
 321f6ac:	dfc00217 	ldw	ra,8(sp)
 321f6b0:	df000117 	ldw	fp,4(sp)
 321f6b4:	dc000017 	ldw	r16,0(sp)
 321f6b8:	dec00304 	addi	sp,sp,12
 321f6bc:	f800283a 	ret

0321f6c0 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 321f6c0:	defffa04 	addi	sp,sp,-24
 321f6c4:	dfc00515 	stw	ra,20(sp)
 321f6c8:	df000415 	stw	fp,16(sp)
 321f6cc:	df000404 	addi	fp,sp,16
 321f6d0:	e13ffd15 	stw	r4,-12(fp)
 321f6d4:	e17ffe15 	stw	r5,-8(fp)
 321f6d8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 321f6dc:	e0bffd17 	ldw	r2,-12(fp)
 321f6e0:	10800017 	ldw	r2,0(r2)
 321f6e4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 321f6e8:	e0bffc17 	ldw	r2,-16(fp)
 321f6ec:	11000a04 	addi	r4,r2,40
 321f6f0:	e0bffd17 	ldw	r2,-12(fp)
 321f6f4:	11c00217 	ldw	r7,8(r2)
 321f6f8:	e17ffe17 	ldw	r5,-8(fp)
 321f6fc:	e1bfff17 	ldw	r6,-4(fp)
 321f700:	321fe7c0 	call	321fe7c <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 321f704:	e037883a 	mov	sp,fp
 321f708:	dfc00117 	ldw	ra,4(sp)
 321f70c:	df000017 	ldw	fp,0(sp)
 321f710:	dec00204 	addi	sp,sp,8
 321f714:	f800283a 	ret

0321f718 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 321f718:	defffa04 	addi	sp,sp,-24
 321f71c:	dfc00515 	stw	ra,20(sp)
 321f720:	df000415 	stw	fp,16(sp)
 321f724:	df000404 	addi	fp,sp,16
 321f728:	e13ffd15 	stw	r4,-12(fp)
 321f72c:	e17ffe15 	stw	r5,-8(fp)
 321f730:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 321f734:	e0bffd17 	ldw	r2,-12(fp)
 321f738:	10800017 	ldw	r2,0(r2)
 321f73c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 321f740:	e0bffc17 	ldw	r2,-16(fp)
 321f744:	11000a04 	addi	r4,r2,40
 321f748:	e0bffd17 	ldw	r2,-12(fp)
 321f74c:	11c00217 	ldw	r7,8(r2)
 321f750:	e17ffe17 	ldw	r5,-8(fp)
 321f754:	e1bfff17 	ldw	r6,-4(fp)
 321f758:	322013c0 	call	322013c <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 321f75c:	e037883a 	mov	sp,fp
 321f760:	dfc00117 	ldw	ra,4(sp)
 321f764:	df000017 	ldw	fp,0(sp)
 321f768:	dec00204 	addi	sp,sp,8
 321f76c:	f800283a 	ret

0321f770 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 321f770:	defffc04 	addi	sp,sp,-16
 321f774:	dfc00315 	stw	ra,12(sp)
 321f778:	df000215 	stw	fp,8(sp)
 321f77c:	df000204 	addi	fp,sp,8
 321f780:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 321f784:	e0bfff17 	ldw	r2,-4(fp)
 321f788:	10800017 	ldw	r2,0(r2)
 321f78c:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 321f790:	e0bffe17 	ldw	r2,-8(fp)
 321f794:	11000a04 	addi	r4,r2,40
 321f798:	e0bfff17 	ldw	r2,-4(fp)
 321f79c:	11400217 	ldw	r5,8(r2)
 321f7a0:	321fd140 	call	321fd14 <altera_avalon_jtag_uart_close>
}
 321f7a4:	e037883a 	mov	sp,fp
 321f7a8:	dfc00117 	ldw	ra,4(sp)
 321f7ac:	df000017 	ldw	fp,0(sp)
 321f7b0:	dec00204 	addi	sp,sp,8
 321f7b4:	f800283a 	ret

0321f7b8 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 321f7b8:	defffa04 	addi	sp,sp,-24
 321f7bc:	dfc00515 	stw	ra,20(sp)
 321f7c0:	df000415 	stw	fp,16(sp)
 321f7c4:	df000404 	addi	fp,sp,16
 321f7c8:	e13ffd15 	stw	r4,-12(fp)
 321f7cc:	e17ffe15 	stw	r5,-8(fp)
 321f7d0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 321f7d4:	e0bffd17 	ldw	r2,-12(fp)
 321f7d8:	10800017 	ldw	r2,0(r2)
 321f7dc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 321f7e0:	e0bffc17 	ldw	r2,-16(fp)
 321f7e4:	11000a04 	addi	r4,r2,40
 321f7e8:	e17ffe17 	ldw	r5,-8(fp)
 321f7ec:	e1bfff17 	ldw	r6,-4(fp)
 321f7f0:	321fd880 	call	321fd88 <altera_avalon_jtag_uart_ioctl>
}
 321f7f4:	e037883a 	mov	sp,fp
 321f7f8:	dfc00117 	ldw	ra,4(sp)
 321f7fc:	df000017 	ldw	fp,0(sp)
 321f800:	dec00204 	addi	sp,sp,8
 321f804:	f800283a 	ret

0321f808 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 321f808:	defff504 	addi	sp,sp,-44
 321f80c:	dfc00a15 	stw	ra,40(sp)
 321f810:	df000915 	stw	fp,36(sp)
 321f814:	df000904 	addi	fp,sp,36
 321f818:	e13ffd15 	stw	r4,-12(fp)
 321f81c:	e17ffe15 	stw	r5,-8(fp)
 321f820:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
 321f824:	e0bffd17 	ldw	r2,-12(fp)
 321f828:	10800c04 	addi	r2,r2,48
 321f82c:	e0bffb15 	stw	r2,-20(fp)
 321f830:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
 321f834:	e13ffc0b 	ldhu	r4,-16(fp)
 321f838:	e17ffc84 	addi	r5,fp,-14
 321f83c:	3217b300 	call	3217b30 <OSFlagCreate>
 321f840:	1007883a 	mov	r3,r2
 321f844:	e0bffb17 	ldw	r2,-20(fp)
 321f848:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
 321f84c:	e0bffd17 	ldw	r2,-12(fp)
 321f850:	10800a04 	addi	r2,r2,40
 321f854:	e0bff915 	stw	r2,-28(fp)
 321f858:	00800044 	movi	r2,1
 321f85c:	e0bffa0d 	sth	r2,-24(fp)
 321f860:	e13ffa0b 	ldhu	r4,-24(fp)
 321f864:	321ad340 	call	321ad34 <OSSemCreate>
 321f868:	1007883a 	mov	r3,r2
 321f86c:	e0bff917 	ldw	r2,-28(fp)
 321f870:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
 321f874:	e0bffd17 	ldw	r2,-12(fp)
 321f878:	10800b04 	addi	r2,r2,44
 321f87c:	e0bff715 	stw	r2,-36(fp)
 321f880:	00800044 	movi	r2,1
 321f884:	e0bff80d 	sth	r2,-32(fp)
 321f888:	e13ff80b 	ldhu	r4,-32(fp)
 321f88c:	321ad340 	call	321ad34 <OSSemCreate>
 321f890:	1007883a 	mov	r3,r2
 321f894:	e0bff717 	ldw	r2,-36(fp)
 321f898:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 321f89c:	e0fffd17 	ldw	r3,-12(fp)
 321f8a0:	00800044 	movi	r2,1
 321f8a4:	18800815 	stw	r2,32(r3)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 321f8a8:	e0bffd17 	ldw	r2,-12(fp)
 321f8ac:	10800017 	ldw	r2,0(r2)
 321f8b0:	11000104 	addi	r4,r2,4
 321f8b4:	e0bffd17 	ldw	r2,-12(fp)
 321f8b8:	10800817 	ldw	r2,32(r2)
 321f8bc:	1007883a 	mov	r3,r2
 321f8c0:	2005883a 	mov	r2,r4
 321f8c4:	10c00035 	stwio	r3,0(r2)
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
                      sp, NULL);
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
 321f8c8:	e13fff17 	ldw	r4,-4(fp)
 321f8cc:	e17ffd17 	ldw	r5,-12(fp)
 321f8d0:	0180c8b4 	movhi	r6,802
 321f8d4:	31be4e04 	addi	r6,r6,-1736
 321f8d8:	323ac6c0 	call	323ac6c <alt_irq_register>
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 321f8dc:	e0bffd17 	ldw	r2,-12(fp)
 321f8e0:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 321f8e4:	e0bffd17 	ldw	r2,-12(fp)
 321f8e8:	11000204 	addi	r4,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 321f8ec:	0080c974 	movhi	r2,805
 321f8f0:	10935104 	addi	r2,r2,19780
 321f8f4:	10800017 	ldw	r2,0(r2)
 321f8f8:	100b883a 	mov	r5,r2
 321f8fc:	0180c8b4 	movhi	r6,802
 321f900:	31bf0004 	addi	r6,r6,-1024
 321f904:	e1fffd17 	ldw	r7,-12(fp)
 321f908:	323a2e40 	call	323a2e4 <alt_alarm_start>
 321f90c:	1004403a 	cmpge	r2,r2,zero
 321f910:	1000041e 	bne	r2,zero,321f924 <altera_avalon_jtag_uart_init+0x11c>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 321f914:	e0fffd17 	ldw	r3,-12(fp)
 321f918:	00a00034 	movhi	r2,32768
 321f91c:	10bfffc4 	addi	r2,r2,-1
 321f920:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 321f924:	e037883a 	mov	sp,fp
 321f928:	dfc00117 	ldw	ra,4(sp)
 321f92c:	df000017 	ldw	fp,0(sp)
 321f930:	dec00204 	addi	sp,sp,8
 321f934:	f800283a 	ret

0321f938 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 321f938:	defff104 	addi	sp,sp,-60
 321f93c:	dfc00e15 	stw	ra,56(sp)
 321f940:	df000d15 	stw	fp,52(sp)
 321f944:	df000d04 	addi	fp,sp,52
 321f948:	e13ffe15 	stw	r4,-8(fp)
 321f94c:	e17fff15 	stw	r5,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 321f950:	e0bffe17 	ldw	r2,-8(fp)
 321f954:	e0bffc15 	stw	r2,-16(fp)
  unsigned int base = sp->base;
 321f958:	e0bffc17 	ldw	r2,-16(fp)
 321f95c:	10800017 	ldw	r2,0(r2)
 321f960:	e0bffb15 	stw	r2,-20(fp)
 321f964:	00000006 	br	321f968 <altera_avalon_jtag_uart_irq+0x30>
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 321f968:	e0bffb17 	ldw	r2,-20(fp)
 321f96c:	10800104 	addi	r2,r2,4
 321f970:	10800037 	ldwio	r2,0(r2)
 321f974:	e0bffa15 	stw	r2,-24(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 321f978:	e0bffa17 	ldw	r2,-24(fp)
 321f97c:	1080c00c 	andi	r2,r2,768
 321f980:	1005003a 	cmpeq	r2,r2,zero
 321f984:	1000991e 	bne	r2,zero,321fbec <altera_avalon_jtag_uart_irq+0x2b4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 321f988:	e0bffa17 	ldw	r2,-24(fp)
 321f98c:	1080400c 	andi	r2,r2,256
 321f990:	1005003a 	cmpeq	r2,r2,zero
 321f994:	1000481e 	bne	r2,zero,321fab8 <altera_avalon_jtag_uart_irq+0x180>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 321f998:	00800074 	movhi	r2,1
 321f99c:	e0bff915 	stw	r2,-28(fp)
 321f9a0:	00000006 	br	321f9a4 <altera_avalon_jtag_uart_irq+0x6c>
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 321f9a4:	e0bffc17 	ldw	r2,-16(fp)
 321f9a8:	10800d17 	ldw	r2,52(r2)
 321f9ac:	10800044 	addi	r2,r2,1
 321f9b0:	1081ffcc 	andi	r2,r2,2047
 321f9b4:	e0bff815 	stw	r2,-32(fp)
        if (next == sp->rx_out)
 321f9b8:	e0bffc17 	ldw	r2,-16(fp)
 321f9bc:	10c00e17 	ldw	r3,56(r2)
 321f9c0:	e0bff817 	ldw	r2,-32(fp)
 321f9c4:	18802826 	beq	r3,r2,321fa68 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 321f9c8:	e0bffb17 	ldw	r2,-20(fp)
 321f9cc:	10800037 	ldwio	r2,0(r2)
 321f9d0:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 321f9d4:	e0bff917 	ldw	r2,-28(fp)
 321f9d8:	10a0000c 	andi	r2,r2,32768
 321f9dc:	1005003a 	cmpeq	r2,r2,zero
 321f9e0:	1000211e 	bne	r2,zero,321fa68 <altera_avalon_jtag_uart_irq+0x130>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 321f9e4:	e0bffc17 	ldw	r2,-16(fp)
 321f9e8:	10c00d17 	ldw	r3,52(r2)
 321f9ec:	e0bff917 	ldw	r2,-28(fp)
 321f9f0:	1009883a 	mov	r4,r2
 321f9f4:	e0bffc17 	ldw	r2,-16(fp)
 321f9f8:	1885883a 	add	r2,r3,r2
 321f9fc:	10801104 	addi	r2,r2,68
 321fa00:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 321fa04:	e0bffc17 	ldw	r2,-16(fp)
 321fa08:	10800d17 	ldw	r2,52(r2)
 321fa0c:	10800044 	addi	r2,r2,1
 321fa10:	10c1ffcc 	andi	r3,r2,2047
 321fa14:	e0bffc17 	ldw	r2,-16(fp)
 321fa18:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
 321fa1c:	e0bffc17 	ldw	r2,-16(fp)
 321fa20:	10800c17 	ldw	r2,48(r2)
 321fa24:	e0bff515 	stw	r2,-44(fp)
 321fa28:	00800044 	movi	r2,1
 321fa2c:	e0bff60d 	sth	r2,-40(fp)
 321fa30:	00800044 	movi	r2,1
 321fa34:	e0bff685 	stb	r2,-38(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 321fa38:	0080c974 	movhi	r2,805
 321fa3c:	10930644 	addi	r2,r2,19481
 321fa40:	10800003 	ldbu	r2,0(r2)
 321fa44:	10803fcc 	andi	r2,r2,255
 321fa48:	1005003a 	cmpeq	r2,r2,zero
 321fa4c:	103fd51e 	bne	r2,zero,321f9a4 <altera_avalon_jtag_uart_irq+0x6c>
  {
    OSFlagPost (group, flags, opt, &err);
 321fa50:	e17ff60b 	ldhu	r5,-40(fp)
 321fa54:	e1bff683 	ldbu	r6,-38(fp)
 321fa58:	e1fffd04 	addi	r7,fp,-12
 321fa5c:	e13ff517 	ldw	r4,-44(fp)
 321fa60:	32188580 	call	3218858 <OSFlagPost>
    return err;
 321fa64:	003fcf06 	br	321f9a4 <altera_avalon_jtag_uart_irq+0x6c>
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 321fa68:	e0bff917 	ldw	r2,-28(fp)
 321fa6c:	10bfffec 	andhi	r2,r2,65535
 321fa70:	1005003a 	cmpeq	r2,r2,zero
 321fa74:	1000101e 	bne	r2,zero,321fab8 <altera_avalon_jtag_uart_irq+0x180>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 321fa78:	e0bffc17 	ldw	r2,-16(fp)
 321fa7c:	10c00817 	ldw	r3,32(r2)
 321fa80:	00bfff84 	movi	r2,-2
 321fa84:	1886703a 	and	r3,r3,r2
 321fa88:	e0bffc17 	ldw	r2,-16(fp)
 321fa8c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 321fa90:	e0bffb17 	ldw	r2,-20(fp)
 321fa94:	11000104 	addi	r4,r2,4
 321fa98:	e0bffc17 	ldw	r2,-16(fp)
 321fa9c:	10800817 	ldw	r2,32(r2)
 321faa0:	1007883a 	mov	r3,r2
 321faa4:	2005883a 	mov	r2,r4
 321faa8:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 321faac:	e0bffb17 	ldw	r2,-20(fp)
 321fab0:	10800104 	addi	r2,r2,4
 321fab4:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 321fab8:	e0bffa17 	ldw	r2,-24(fp)
 321fabc:	1080800c 	andi	r2,r2,512
 321fac0:	1005003a 	cmpeq	r2,r2,zero
 321fac4:	103fa81e 	bne	r2,zero,321f968 <altera_avalon_jtag_uart_irq+0x30>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 321fac8:	e0bffa17 	ldw	r2,-24(fp)
 321facc:	10bfffec 	andhi	r2,r2,65535
 321fad0:	1004d43a 	srli	r2,r2,16
 321fad4:	e0bff715 	stw	r2,-36(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 321fad8:	00002706 	br	321fb78 <altera_avalon_jtag_uart_irq+0x240>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 321fadc:	e13ffb17 	ldw	r4,-20(fp)
 321fae0:	e0bffc17 	ldw	r2,-16(fp)
 321fae4:	10c01017 	ldw	r3,64(r2)
 321fae8:	e0bffc17 	ldw	r2,-16(fp)
 321faec:	1885883a 	add	r2,r3,r2
 321faf0:	10821104 	addi	r2,r2,2116
 321faf4:	10800003 	ldbu	r2,0(r2)
 321faf8:	10c03fcc 	andi	r3,r2,255
 321fafc:	18c0201c 	xori	r3,r3,128
 321fb00:	18ffe004 	addi	r3,r3,-128
 321fb04:	2005883a 	mov	r2,r4
 321fb08:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 321fb0c:	e0bffc17 	ldw	r2,-16(fp)
 321fb10:	10801017 	ldw	r2,64(r2)
 321fb14:	10800044 	addi	r2,r2,1
 321fb18:	10c1ffcc 	andi	r3,r2,2047
 321fb1c:	e0bffc17 	ldw	r2,-16(fp)
 321fb20:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
 321fb24:	e0bffc17 	ldw	r2,-16(fp)
 321fb28:	10800c17 	ldw	r2,48(r2)
 321fb2c:	e0bff315 	stw	r2,-52(fp)
 321fb30:	00800084 	movi	r2,2
 321fb34:	e0bff40d 	sth	r2,-48(fp)
 321fb38:	00800044 	movi	r2,1
 321fb3c:	e0bff485 	stb	r2,-46(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 321fb40:	0080c974 	movhi	r2,805
 321fb44:	10930644 	addi	r2,r2,19481
 321fb48:	10800003 	ldbu	r2,0(r2)
 321fb4c:	10803fcc 	andi	r2,r2,255
 321fb50:	1005003a 	cmpeq	r2,r2,zero
 321fb54:	1000051e 	bne	r2,zero,321fb6c <altera_avalon_jtag_uart_irq+0x234>
  {
    OSFlagPost (group, flags, opt, &err);
 321fb58:	e17ff40b 	ldhu	r5,-48(fp)
 321fb5c:	e1bff483 	ldbu	r6,-46(fp)
 321fb60:	e1fffd44 	addi	r7,fp,-11
 321fb64:	e13ff317 	ldw	r4,-52(fp)
 321fb68:	32188580 	call	3218858 <OSFlagPost>

        space--;
 321fb6c:	e0bff717 	ldw	r2,-36(fp)
 321fb70:	10bfffc4 	addi	r2,r2,-1
 321fb74:	e0bff715 	stw	r2,-36(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 321fb78:	e0bff717 	ldw	r2,-36(fp)
 321fb7c:	1005003a 	cmpeq	r2,r2,zero
 321fb80:	1000051e 	bne	r2,zero,321fb98 <altera_avalon_jtag_uart_irq+0x260>
 321fb84:	e0bffc17 	ldw	r2,-16(fp)
 321fb88:	10c01017 	ldw	r3,64(r2)
 321fb8c:	e0bffc17 	ldw	r2,-16(fp)
 321fb90:	10800f17 	ldw	r2,60(r2)
 321fb94:	18bfd11e 	bne	r3,r2,321fadc <altera_avalon_jtag_uart_irq+0x1a4>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 321fb98:	e0bff717 	ldw	r2,-36(fp)
 321fb9c:	1005003a 	cmpeq	r2,r2,zero
 321fba0:	103f711e 	bne	r2,zero,321f968 <altera_avalon_jtag_uart_irq+0x30>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 321fba4:	e0bffc17 	ldw	r2,-16(fp)
 321fba8:	10c00817 	ldw	r3,32(r2)
 321fbac:	00bfff44 	movi	r2,-3
 321fbb0:	1886703a 	and	r3,r3,r2
 321fbb4:	e0bffc17 	ldw	r2,-16(fp)
 321fbb8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 321fbbc:	e0bffc17 	ldw	r2,-16(fp)
 321fbc0:	10800017 	ldw	r2,0(r2)
 321fbc4:	11000104 	addi	r4,r2,4
 321fbc8:	e0bffc17 	ldw	r2,-16(fp)
 321fbcc:	10800817 	ldw	r2,32(r2)
 321fbd0:	1007883a 	mov	r3,r2
 321fbd4:	2005883a 	mov	r2,r4
 321fbd8:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 321fbdc:	e0bffb17 	ldw	r2,-20(fp)
 321fbe0:	10800104 	addi	r2,r2,4
 321fbe4:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 321fbe8:	003f5f06 	br	321f968 <altera_avalon_jtag_uart_irq+0x30>
}
 321fbec:	e037883a 	mov	sp,fp
 321fbf0:	dfc00117 	ldw	ra,4(sp)
 321fbf4:	df000017 	ldw	fp,0(sp)
 321fbf8:	dec00204 	addi	sp,sp,8
 321fbfc:	f800283a 	ret

0321fc00 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 321fc00:	defff804 	addi	sp,sp,-32
 321fc04:	dfc00715 	stw	ra,28(sp)
 321fc08:	df000615 	stw	fp,24(sp)
 321fc0c:	df000604 	addi	fp,sp,24
 321fc10:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 321fc14:	e0bfff17 	ldw	r2,-4(fp)
 321fc18:	e0bffd15 	stw	r2,-12(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 321fc1c:	e0bffd17 	ldw	r2,-12(fp)
 321fc20:	10800017 	ldw	r2,0(r2)
 321fc24:	10800104 	addi	r2,r2,4
 321fc28:	10800037 	ldwio	r2,0(r2)
 321fc2c:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 321fc30:	e0bffc17 	ldw	r2,-16(fp)
 321fc34:	1081000c 	andi	r2,r2,1024
 321fc38:	1005003a 	cmpeq	r2,r2,zero
 321fc3c:	10000c1e 	bne	r2,zero,321fc70 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 321fc40:	e0bffd17 	ldw	r2,-12(fp)
 321fc44:	10800017 	ldw	r2,0(r2)
 321fc48:	11000104 	addi	r4,r2,4
 321fc4c:	e0bffd17 	ldw	r2,-12(fp)
 321fc50:	10800817 	ldw	r2,32(r2)
 321fc54:	10810014 	ori	r2,r2,1024
 321fc58:	1007883a 	mov	r3,r2
 321fc5c:	2005883a 	mov	r2,r4
 321fc60:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
 321fc64:	e0bffd17 	ldw	r2,-12(fp)
 321fc68:	10000915 	stw	zero,36(r2)
 321fc6c:	00002106 	br	321fcf4 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 321fc70:	e0bffd17 	ldw	r2,-12(fp)
 321fc74:	10c00917 	ldw	r3,36(r2)
 321fc78:	00a00034 	movhi	r2,32768
 321fc7c:	10bfff04 	addi	r2,r2,-4
 321fc80:	10c01c36 	bltu	r2,r3,321fcf4 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
 321fc84:	e0bffd17 	ldw	r2,-12(fp)
 321fc88:	10800917 	ldw	r2,36(r2)
 321fc8c:	10c00044 	addi	r3,r2,1
 321fc90:	e0bffd17 	ldw	r2,-12(fp)
 321fc94:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
 321fc98:	e0bffd17 	ldw	r2,-12(fp)
 321fc9c:	10c00917 	ldw	r3,36(r2)
 321fca0:	e0bffd17 	ldw	r2,-12(fp)
 321fca4:	10800117 	ldw	r2,4(r2)
 321fca8:	18801236 	bltu	r3,r2,321fcf4 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
 321fcac:	e0bffd17 	ldw	r2,-12(fp)
 321fcb0:	10800c17 	ldw	r2,48(r2)
 321fcb4:	e0bffa15 	stw	r2,-24(fp)
 321fcb8:	00800104 	movi	r2,4
 321fcbc:	e0bffb0d 	sth	r2,-20(fp)
 321fcc0:	00800044 	movi	r2,1
 321fcc4:	e0bffb85 	stb	r2,-18(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 321fcc8:	0080c974 	movhi	r2,805
 321fccc:	10930644 	addi	r2,r2,19481
 321fcd0:	10800003 	ldbu	r2,0(r2)
 321fcd4:	10803fcc 	andi	r2,r2,255
 321fcd8:	1005003a 	cmpeq	r2,r2,zero
 321fcdc:	1000051e 	bne	r2,zero,321fcf4 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
 321fce0:	e17ffb0b 	ldhu	r5,-20(fp)
 321fce4:	e1bffb83 	ldbu	r6,-18(fp)
 321fce8:	e1fffe04 	addi	r7,fp,-8
 321fcec:	e13ffa17 	ldw	r4,-24(fp)
 321fcf0:	32188580 	call	3218858 <OSFlagPost>
 321fcf4:	0080c974 	movhi	r2,805
 321fcf8:	10935104 	addi	r2,r2,19780
 321fcfc:	10800017 	ldw	r2,0(r2)
    }
  }

  return alt_ticks_per_second();
}
 321fd00:	e037883a 	mov	sp,fp
 321fd04:	dfc00117 	ldw	ra,4(sp)
 321fd08:	df000017 	ldw	fp,0(sp)
 321fd0c:	dec00204 	addi	sp,sp,8
 321fd10:	f800283a 	ret

0321fd14 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 321fd14:	defffc04 	addi	sp,sp,-16
 321fd18:	df000315 	stw	fp,12(sp)
 321fd1c:	df000304 	addi	fp,sp,12
 321fd20:	e13ffd15 	stw	r4,-12(fp)
 321fd24:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 321fd28:	00000706 	br	321fd48 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
 321fd2c:	e0bffe17 	ldw	r2,-8(fp)
 321fd30:	1090000c 	andi	r2,r2,16384
 321fd34:	1005003a 	cmpeq	r2,r2,zero
 321fd38:	1000031e 	bne	r2,zero,321fd48 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
 321fd3c:	00bffd44 	movi	r2,-11
 321fd40:	e0bfff15 	stw	r2,-4(fp)
 321fd44:	00000b06 	br	321fd74 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 321fd48:	e0bffd17 	ldw	r2,-12(fp)
 321fd4c:	10c01017 	ldw	r3,64(r2)
 321fd50:	e0bffd17 	ldw	r2,-12(fp)
 321fd54:	10800f17 	ldw	r2,60(r2)
 321fd58:	18800526 	beq	r3,r2,321fd70 <altera_avalon_jtag_uart_close+0x5c>
 321fd5c:	e0bffd17 	ldw	r2,-12(fp)
 321fd60:	10c00917 	ldw	r3,36(r2)
 321fd64:	e0bffd17 	ldw	r2,-12(fp)
 321fd68:	10800117 	ldw	r2,4(r2)
 321fd6c:	18bfef36 	bltu	r3,r2,321fd2c <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 321fd70:	e03fff15 	stw	zero,-4(fp)
 321fd74:	e0bfff17 	ldw	r2,-4(fp)
}
 321fd78:	e037883a 	mov	sp,fp
 321fd7c:	df000017 	ldw	fp,0(sp)
 321fd80:	dec00104 	addi	sp,sp,4
 321fd84:	f800283a 	ret

0321fd88 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 321fd88:	defff804 	addi	sp,sp,-32
 321fd8c:	df000715 	stw	fp,28(sp)
 321fd90:	df000704 	addi	fp,sp,28
 321fd94:	e13ffb15 	stw	r4,-20(fp)
 321fd98:	e17ffc15 	stw	r5,-16(fp)
 321fd9c:	e1bffd15 	stw	r6,-12(fp)
  int rc = -ENOTTY;
 321fda0:	00bff9c4 	movi	r2,-25
 321fda4:	e0bffa15 	stw	r2,-24(fp)

  switch (req)
 321fda8:	e0bffc17 	ldw	r2,-16(fp)
 321fdac:	e0bfff15 	stw	r2,-4(fp)
 321fdb0:	e0ffff17 	ldw	r3,-4(fp)
 321fdb4:	189a8060 	cmpeqi	r2,r3,27137
 321fdb8:	1000041e 	bne	r2,zero,321fdcc <altera_avalon_jtag_uart_ioctl+0x44>
 321fdbc:	e0ffff17 	ldw	r3,-4(fp)
 321fdc0:	189a80a0 	cmpeqi	r2,r3,27138
 321fdc4:	10001b1e 	bne	r2,zero,321fe34 <altera_avalon_jtag_uart_ioctl+0xac>
 321fdc8:	00002706 	br	321fe68 <altera_avalon_jtag_uart_ioctl+0xe0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 321fdcc:	e0bffb17 	ldw	r2,-20(fp)
 321fdd0:	10c00117 	ldw	r3,4(r2)
 321fdd4:	00a00034 	movhi	r2,32768
 321fdd8:	10bfffc4 	addi	r2,r2,-1
 321fddc:	18802226 	beq	r3,r2,321fe68 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
 321fde0:	e0bffd17 	ldw	r2,-12(fp)
 321fde4:	10800017 	ldw	r2,0(r2)
 321fde8:	e0bff915 	stw	r2,-28(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 321fdec:	e0bff917 	ldw	r2,-28(fp)
 321fdf0:	10800090 	cmplti	r2,r2,2
 321fdf4:	1000071e 	bne	r2,zero,321fe14 <altera_avalon_jtag_uart_ioctl+0x8c>
 321fdf8:	e0fff917 	ldw	r3,-28(fp)
 321fdfc:	00a00034 	movhi	r2,32768
 321fe00:	10bfffc4 	addi	r2,r2,-1
 321fe04:	18800326 	beq	r3,r2,321fe14 <altera_avalon_jtag_uart_ioctl+0x8c>
 321fe08:	e0bff917 	ldw	r2,-28(fp)
 321fe0c:	e0bffe15 	stw	r2,-8(fp)
 321fe10:	00000306 	br	321fe20 <altera_avalon_jtag_uart_ioctl+0x98>
 321fe14:	00e00034 	movhi	r3,32768
 321fe18:	18ffff84 	addi	r3,r3,-2
 321fe1c:	e0fffe15 	stw	r3,-8(fp)
 321fe20:	e0bffb17 	ldw	r2,-20(fp)
 321fe24:	e0fffe17 	ldw	r3,-8(fp)
 321fe28:	10c00115 	stw	r3,4(r2)
      rc = 0;
 321fe2c:	e03ffa15 	stw	zero,-24(fp)
    }
    break;
 321fe30:	00000d06 	br	321fe68 <altera_avalon_jtag_uart_ioctl+0xe0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 321fe34:	e0bffb17 	ldw	r2,-20(fp)
 321fe38:	10c00117 	ldw	r3,4(r2)
 321fe3c:	00a00034 	movhi	r2,32768
 321fe40:	10bfffc4 	addi	r2,r2,-1
 321fe44:	18800826 	beq	r3,r2,321fe68 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 321fe48:	e13ffd17 	ldw	r4,-12(fp)
 321fe4c:	e0bffb17 	ldw	r2,-20(fp)
 321fe50:	10c00917 	ldw	r3,36(r2)
 321fe54:	e0bffb17 	ldw	r2,-20(fp)
 321fe58:	10800117 	ldw	r2,4(r2)
 321fe5c:	1885803a 	cmpltu	r2,r3,r2
 321fe60:	20800015 	stw	r2,0(r4)
      rc = 0;
 321fe64:	e03ffa15 	stw	zero,-24(fp)

  default:
    break;
  }

  return rc;
 321fe68:	e0bffa17 	ldw	r2,-24(fp)
}
 321fe6c:	e037883a 	mov	sp,fp
 321fe70:	df000017 	ldw	fp,0(sp)
 321fe74:	dec00104 	addi	sp,sp,4
 321fe78:	f800283a 	ret

0321fe7c <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 321fe7c:	deffeb04 	addi	sp,sp,-84
 321fe80:	dfc01415 	stw	ra,80(sp)
 321fe84:	df001315 	stw	fp,76(sp)
 321fe88:	df001304 	addi	fp,sp,76
 321fe8c:	e13ffb15 	stw	r4,-20(fp)
 321fe90:	e17ffc15 	stw	r5,-16(fp)
 321fe94:	e1bffd15 	stw	r6,-12(fp)
 321fe98:	e1fffe15 	stw	r7,-8(fp)
  char * ptr = buffer;
 321fe9c:	e0bffc17 	ldw	r2,-16(fp)
 321fea0:	e0bff915 	stw	r2,-28(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
 321fea4:	e0bffb17 	ldw	r2,-20(fp)
 321fea8:	10800a17 	ldw	r2,40(r2)
 321feac:	e0bff315 	stw	r2,-52(fp)
 321feb0:	e03ff40d 	sth	zero,-48(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 321feb4:	e17ff40b 	ldhu	r5,-48(fp)
 321feb8:	e1bffa44 	addi	r6,fp,-23
 321febc:	e13ff317 	ldw	r4,-52(fp)
 321fec0:	321b0e80 	call	321b0e8 <OSSemPend>

  while (space > 0)
 321fec4:	00006406 	br	3220058 <altera_avalon_jtag_uart_read+0x1dc>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 321fec8:	e0bffb17 	ldw	r2,-20(fp)
 321fecc:	10800d17 	ldw	r2,52(r2)
 321fed0:	e0bff615 	stw	r2,-40(fp)
      out = sp->rx_out;
 321fed4:	e0bffb17 	ldw	r2,-20(fp)
 321fed8:	10800e17 	ldw	r2,56(r2)
 321fedc:	e0bff515 	stw	r2,-44(fp)

      if (in >= out)
 321fee0:	e0fff617 	ldw	r3,-40(fp)
 321fee4:	e0bff517 	ldw	r2,-44(fp)
 321fee8:	18800536 	bltu	r3,r2,321ff00 <altera_avalon_jtag_uart_read+0x84>
        n = in - out;
 321feec:	e0bff617 	ldw	r2,-40(fp)
 321fef0:	e0fff517 	ldw	r3,-44(fp)
 321fef4:	10c5c83a 	sub	r2,r2,r3
 321fef8:	e0bff715 	stw	r2,-36(fp)
 321fefc:	00000406 	br	321ff10 <altera_avalon_jtag_uart_read+0x94>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 321ff00:	00820004 	movi	r2,2048
 321ff04:	e0fff517 	ldw	r3,-44(fp)
 321ff08:	10c5c83a 	sub	r2,r2,r3
 321ff0c:	e0bff715 	stw	r2,-36(fp)

      if (n == 0)
 321ff10:	e0bff717 	ldw	r2,-36(fp)
 321ff14:	1005003a 	cmpeq	r2,r2,zero
 321ff18:	10001f1e 	bne	r2,zero,321ff98 <altera_avalon_jtag_uart_read+0x11c>
        break; /* No more data available */

      if (n > space)
 321ff1c:	e0fffd17 	ldw	r3,-12(fp)
 321ff20:	e0bff717 	ldw	r2,-36(fp)
 321ff24:	1880022e 	bgeu	r3,r2,321ff30 <altera_avalon_jtag_uart_read+0xb4>
        n = space;
 321ff28:	e0bffd17 	ldw	r2,-12(fp)
 321ff2c:	e0bff715 	stw	r2,-36(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 321ff30:	e0bffb17 	ldw	r2,-20(fp)
 321ff34:	10c01104 	addi	r3,r2,68
 321ff38:	e0bff517 	ldw	r2,-44(fp)
 321ff3c:	1887883a 	add	r3,r3,r2
 321ff40:	e0bff917 	ldw	r2,-28(fp)
 321ff44:	1009883a 	mov	r4,r2
 321ff48:	180b883a 	mov	r5,r3
 321ff4c:	e1bff717 	ldw	r6,-36(fp)
 321ff50:	3206ad00 	call	3206ad0 <memcpy>
      ptr   += n;
 321ff54:	e0fff717 	ldw	r3,-36(fp)
 321ff58:	e0bff917 	ldw	r2,-28(fp)
 321ff5c:	10c5883a 	add	r2,r2,r3
 321ff60:	e0bff915 	stw	r2,-28(fp)
      space -= n;
 321ff64:	e0fffd17 	ldw	r3,-12(fp)
 321ff68:	e0bff717 	ldw	r2,-36(fp)
 321ff6c:	1885c83a 	sub	r2,r3,r2
 321ff70:	e0bffd15 	stw	r2,-12(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 321ff74:	e0fff517 	ldw	r3,-44(fp)
 321ff78:	e0bff717 	ldw	r2,-36(fp)
 321ff7c:	1885883a 	add	r2,r3,r2
 321ff80:	10c1ffcc 	andi	r3,r2,2047
 321ff84:	e0bffb17 	ldw	r2,-20(fp)
 321ff88:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
 321ff8c:	e0bffd17 	ldw	r2,-12(fp)
 321ff90:	10800048 	cmpgei	r2,r2,1
 321ff94:	103fcc1e 	bne	r2,zero,321fec8 <altera_avalon_jtag_uart_read+0x4c>

    /* If we read any data then return it */
    if (ptr != buffer)
 321ff98:	e0fff917 	ldw	r3,-28(fp)
 321ff9c:	e0bffc17 	ldw	r2,-16(fp)
 321ffa0:	1880301e 	bne	r3,r2,3220064 <altera_avalon_jtag_uart_read+0x1e8>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 321ffa4:	e0bffe17 	ldw	r2,-8(fp)
 321ffa8:	1090000c 	andi	r2,r2,16384
 321ffac:	1004c03a 	cmpne	r2,r2,zero
 321ffb0:	10002c1e 	bne	r2,zero,3220064 <altera_avalon_jtag_uart_read+0x1e8>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
 321ffb4:	0080c974 	movhi	r2,805
 321ffb8:	10930644 	addi	r2,r2,19481
 321ffbc:	10800003 	ldbu	r2,0(r2)
 321ffc0:	10803fcc 	andi	r2,r2,255
 321ffc4:	10800058 	cmpnei	r2,r2,1
 321ffc8:	1000161e 	bne	r2,zero,3220024 <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
 321ffcc:	e0bffb17 	ldw	r2,-20(fp)
 321ffd0:	10800c17 	ldw	r2,48(r2)
 321ffd4:	e0bff015 	stw	r2,-64(fp)
 321ffd8:	00800144 	movi	r2,5
 321ffdc:	e0bff10d 	sth	r2,-60(fp)
 321ffe0:	00bfe0c4 	movi	r2,-125
 321ffe4:	e0bff185 	stb	r2,-58(fp)
 321ffe8:	e03ff20d 	sth	zero,-56(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 321ffec:	0080c974 	movhi	r2,805
 321fff0:	10930644 	addi	r2,r2,19481
 321fff4:	10800003 	ldbu	r2,0(r2)
 321fff8:	10803fcc 	andi	r2,r2,255
 321fffc:	1005003a 	cmpeq	r2,r2,zero
 3220000:	1000111e 	bne	r2,zero,3220048 <altera_avalon_jtag_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 3220004:	e17ff10b 	ldhu	r5,-60(fp)
 3220008:	e1bff183 	ldbu	r6,-58(fp)
 322000c:	e1fff20b 	ldhu	r7,-56(fp)
 3220010:	e0bffa04 	addi	r2,fp,-24
 3220014:	d8800015 	stw	r2,0(sp)
 3220018:	e13ff017 	ldw	r4,-64(fp)
 322001c:	32181ac0 	call	32181ac <OSFlagPend>
    return err;
 3220020:	00000906 	br	3220048 <altera_avalon_jtag_uart_read+0x1cc>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 3220024:	e0bffb17 	ldw	r2,-20(fp)
 3220028:	10c00d17 	ldw	r3,52(r2)
 322002c:	e0bff617 	ldw	r2,-40(fp)
 3220030:	1880051e 	bne	r3,r2,3220048 <altera_avalon_jtag_uart_read+0x1cc>
 3220034:	e0bffb17 	ldw	r2,-20(fp)
 3220038:	10c00917 	ldw	r3,36(r2)
 322003c:	e0bffb17 	ldw	r2,-20(fp)
 3220040:	10800117 	ldw	r2,4(r2)
 3220044:	18bff736 	bltu	r3,r2,3220024 <altera_avalon_jtag_uart_read+0x1a8>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 3220048:	e0bffb17 	ldw	r2,-20(fp)
 322004c:	10c00d17 	ldw	r3,52(r2)
 3220050:	e0bff617 	ldw	r2,-40(fp)
 3220054:	18800326 	beq	r3,r2,3220064 <altera_avalon_jtag_uart_read+0x1e8>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 3220058:	e0bffd17 	ldw	r2,-12(fp)
 322005c:	10800048 	cmpgei	r2,r2,1
 3220060:	103f991e 	bne	r2,zero,321fec8 <altera_avalon_jtag_uart_read+0x4c>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 3220064:	e0bffb17 	ldw	r2,-20(fp)
 3220068:	11000a17 	ldw	r4,40(r2)
 322006c:	321b4e00 	call	321b4e0 <OSSemPost>

  if (ptr != buffer)
 3220070:	e0fff917 	ldw	r3,-28(fp)
 3220074:	e0bffc17 	ldw	r2,-16(fp)
 3220078:	18801926 	beq	r3,r2,32200e0 <altera_avalon_jtag_uart_read+0x264>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 322007c:	0005303a 	rdctl	r2,status
 3220080:	e0bfef15 	stw	r2,-68(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3220084:	e0ffef17 	ldw	r3,-68(fp)
 3220088:	00bfff84 	movi	r2,-2
 322008c:	1884703a 	and	r2,r3,r2
 3220090:	1001703a 	wrctl	status,r2
  
  return context;
 3220094:	e0bfef17 	ldw	r2,-68(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 3220098:	e0bff815 	stw	r2,-32(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 322009c:	e0bffb17 	ldw	r2,-20(fp)
 32200a0:	10800817 	ldw	r2,32(r2)
 32200a4:	10c00054 	ori	r3,r2,1
 32200a8:	e0bffb17 	ldw	r2,-20(fp)
 32200ac:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 32200b0:	e0bffb17 	ldw	r2,-20(fp)
 32200b4:	10800017 	ldw	r2,0(r2)
 32200b8:	11000104 	addi	r4,r2,4
 32200bc:	e0bffb17 	ldw	r2,-20(fp)
 32200c0:	10800817 	ldw	r2,32(r2)
 32200c4:	1007883a 	mov	r3,r2
 32200c8:	2005883a 	mov	r2,r4
 32200cc:	10c00035 	stwio	r3,0(r2)
 32200d0:	e0bff817 	ldw	r2,-32(fp)
 32200d4:	e0bfee15 	stw	r2,-72(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 32200d8:	e0bfee17 	ldw	r2,-72(fp)
 32200dc:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 32200e0:	e0fff917 	ldw	r3,-28(fp)
 32200e4:	e0bffc17 	ldw	r2,-16(fp)
 32200e8:	18800526 	beq	r3,r2,3220100 <altera_avalon_jtag_uart_read+0x284>
    return ptr - buffer;
 32200ec:	e0fff917 	ldw	r3,-28(fp)
 32200f0:	e0bffc17 	ldw	r2,-16(fp)
 32200f4:	1887c83a 	sub	r3,r3,r2
 32200f8:	e0ffff15 	stw	r3,-4(fp)
 32200fc:	00000906 	br	3220124 <altera_avalon_jtag_uart_read+0x2a8>
  else if (flags & O_NONBLOCK)
 3220100:	e0bffe17 	ldw	r2,-8(fp)
 3220104:	1090000c 	andi	r2,r2,16384
 3220108:	1005003a 	cmpeq	r2,r2,zero
 322010c:	1000031e 	bne	r2,zero,322011c <altera_avalon_jtag_uart_read+0x2a0>
    return -EWOULDBLOCK;
 3220110:	00bffd44 	movi	r2,-11
 3220114:	e0bfff15 	stw	r2,-4(fp)
 3220118:	00000206 	br	3220124 <altera_avalon_jtag_uart_read+0x2a8>
  else
    return -EIO;
 322011c:	00bffec4 	movi	r2,-5
 3220120:	e0bfff15 	stw	r2,-4(fp)
 3220124:	e0bfff17 	ldw	r2,-4(fp)
}
 3220128:	e037883a 	mov	sp,fp
 322012c:	dfc00117 	ldw	ra,4(sp)
 3220130:	df000017 	ldw	fp,0(sp)
 3220134:	dec00204 	addi	sp,sp,8
 3220138:	f800283a 	ret

0322013c <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 322013c:	deffeb04 	addi	sp,sp,-84
 3220140:	dfc01415 	stw	ra,80(sp)
 3220144:	df001315 	stw	fp,76(sp)
 3220148:	df001304 	addi	fp,sp,76
 322014c:	e13ffb15 	stw	r4,-20(fp)
 3220150:	e17ffc15 	stw	r5,-16(fp)
 3220154:	e1bffd15 	stw	r6,-12(fp)
 3220158:	e1fffe15 	stw	r7,-8(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 322015c:	e03ff815 	stw	zero,-32(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 3220160:	e0bffc17 	ldw	r2,-16(fp)
 3220164:	e0bff515 	stw	r2,-44(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
 3220168:	e0bffb17 	ldw	r2,-20(fp)
 322016c:	10800b17 	ldw	r2,44(r2)
 3220170:	e0bff315 	stw	r2,-52(fp)
 3220174:	e03ff40d 	sth	zero,-48(fp)
 3220178:	e17ff40b 	ldhu	r5,-48(fp)
 322017c:	e1bffa04 	addi	r6,fp,-24
 3220180:	e13ff317 	ldw	r4,-52(fp)
 3220184:	321b0e80 	call	321b0e8 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 3220188:	00003a06 	br	3220274 <altera_avalon_jtag_uart_write+0x138>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 322018c:	e0bffb17 	ldw	r2,-20(fp)
 3220190:	10800f17 	ldw	r2,60(r2)
 3220194:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
 3220198:	e0bffb17 	ldw	r2,-20(fp)
 322019c:	10801017 	ldw	r2,64(r2)
 32201a0:	e0bff815 	stw	r2,-32(fp)

      if (in < out)
 32201a4:	e0fff917 	ldw	r3,-28(fp)
 32201a8:	e0bff817 	ldw	r2,-32(fp)
 32201ac:	1880062e 	bgeu	r3,r2,32201c8 <altera_avalon_jtag_uart_write+0x8c>
        n = out - 1 - in;
 32201b0:	e0fff817 	ldw	r3,-32(fp)
 32201b4:	e0bff917 	ldw	r2,-28(fp)
 32201b8:	1885c83a 	sub	r2,r3,r2
 32201bc:	10bfffc4 	addi	r2,r2,-1
 32201c0:	e0bff715 	stw	r2,-36(fp)
 32201c4:	00000c06 	br	32201f8 <altera_avalon_jtag_uart_write+0xbc>
      else if (out > 0)
 32201c8:	e0bff817 	ldw	r2,-32(fp)
 32201cc:	1005003a 	cmpeq	r2,r2,zero
 32201d0:	1000051e 	bne	r2,zero,32201e8 <altera_avalon_jtag_uart_write+0xac>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 32201d4:	00820004 	movi	r2,2048
 32201d8:	e0fff917 	ldw	r3,-28(fp)
 32201dc:	10c5c83a 	sub	r2,r2,r3
 32201e0:	e0bff715 	stw	r2,-36(fp)
 32201e4:	00000406 	br	32201f8 <altera_avalon_jtag_uart_write+0xbc>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 32201e8:	0081ffc4 	movi	r2,2047
 32201ec:	e0fff917 	ldw	r3,-28(fp)
 32201f0:	10c5c83a 	sub	r2,r2,r3
 32201f4:	e0bff715 	stw	r2,-36(fp)

      if (n == 0)
 32201f8:	e0bff717 	ldw	r2,-36(fp)
 32201fc:	1005003a 	cmpeq	r2,r2,zero
 3220200:	10001f1e 	bne	r2,zero,3220280 <altera_avalon_jtag_uart_write+0x144>
        break;

      if (n > count)
 3220204:	e0fffd17 	ldw	r3,-12(fp)
 3220208:	e0bff717 	ldw	r2,-36(fp)
 322020c:	1880022e 	bgeu	r3,r2,3220218 <altera_avalon_jtag_uart_write+0xdc>
        n = count;
 3220210:	e0bffd17 	ldw	r2,-12(fp)
 3220214:	e0bff715 	stw	r2,-36(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 3220218:	e0bffb17 	ldw	r2,-20(fp)
 322021c:	10c21104 	addi	r3,r2,2116
 3220220:	e0bff917 	ldw	r2,-28(fp)
 3220224:	1885883a 	add	r2,r3,r2
 3220228:	e0fffc17 	ldw	r3,-16(fp)
 322022c:	1009883a 	mov	r4,r2
 3220230:	180b883a 	mov	r5,r3
 3220234:	e1bff717 	ldw	r6,-36(fp)
 3220238:	3206ad00 	call	3206ad0 <memcpy>
      ptr   += n;
 322023c:	e0fff717 	ldw	r3,-36(fp)
 3220240:	e0bffc17 	ldw	r2,-16(fp)
 3220244:	10c5883a 	add	r2,r2,r3
 3220248:	e0bffc15 	stw	r2,-16(fp)
      count -= n;
 322024c:	e0fffd17 	ldw	r3,-12(fp)
 3220250:	e0bff717 	ldw	r2,-36(fp)
 3220254:	1885c83a 	sub	r2,r3,r2
 3220258:	e0bffd15 	stw	r2,-12(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 322025c:	e0fff917 	ldw	r3,-28(fp)
 3220260:	e0bff717 	ldw	r2,-36(fp)
 3220264:	1885883a 	add	r2,r3,r2
 3220268:	10c1ffcc 	andi	r3,r2,2047
 322026c:	e0bffb17 	ldw	r2,-20(fp)
 3220270:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 3220274:	e0bffd17 	ldw	r2,-12(fp)
 3220278:	10800048 	cmpgei	r2,r2,1
 322027c:	103fc31e 	bne	r2,zero,322018c <altera_avalon_jtag_uart_write+0x50>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3220280:	0005303a 	rdctl	r2,status
 3220284:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3220288:	e0fff217 	ldw	r3,-56(fp)
 322028c:	00bfff84 	movi	r2,-2
 3220290:	1884703a 	and	r2,r3,r2
 3220294:	1001703a 	wrctl	status,r2
  
  return context;
 3220298:	e0bff217 	ldw	r2,-56(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 322029c:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 32202a0:	e0bffb17 	ldw	r2,-20(fp)
 32202a4:	10800817 	ldw	r2,32(r2)
 32202a8:	10c00094 	ori	r3,r2,2
 32202ac:	e0bffb17 	ldw	r2,-20(fp)
 32202b0:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 32202b4:	e0bffb17 	ldw	r2,-20(fp)
 32202b8:	10800017 	ldw	r2,0(r2)
 32202bc:	11000104 	addi	r4,r2,4
 32202c0:	e0bffb17 	ldw	r2,-20(fp)
 32202c4:	10800817 	ldw	r2,32(r2)
 32202c8:	1007883a 	mov	r3,r2
 32202cc:	2005883a 	mov	r2,r4
 32202d0:	10c00035 	stwio	r3,0(r2)
 32202d4:	e0bff617 	ldw	r2,-40(fp)
 32202d8:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 32202dc:	e0bff117 	ldw	r2,-60(fp)
 32202e0:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 32202e4:	e0bffd17 	ldw	r2,-12(fp)
 32202e8:	10800050 	cmplti	r2,r2,1
 32202ec:	10002d1e 	bne	r2,zero,32203a4 <altera_avalon_jtag_uart_write+0x268>
    {
      if (flags & O_NONBLOCK)
 32202f0:	e0bffe17 	ldw	r2,-8(fp)
 32202f4:	1090000c 	andi	r2,r2,16384
 32202f8:	1004c03a 	cmpne	r2,r2,zero
 32202fc:	10002c1e 	bne	r2,zero,32203b0 <altera_avalon_jtag_uart_write+0x274>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
 3220300:	0080c974 	movhi	r2,805
 3220304:	10930644 	addi	r2,r2,19481
 3220308:	10800003 	ldbu	r2,0(r2)
 322030c:	10803fcc 	andi	r2,r2,255
 3220310:	10800058 	cmpnei	r2,r2,1
 3220314:	1000161e 	bne	r2,zero,3220370 <altera_avalon_jtag_uart_write+0x234>
         * When running in a multi-threaded mode, we pend on the write event
         * flag set or the timeout flag in the isr. This avoids wasting CPU
         * cycles waiting in this thread, when we could be doing something
         * more profitable elsewhere.
         */
        ALT_FLAG_PEND (sp->events,
 3220318:	e0bffb17 	ldw	r2,-20(fp)
 322031c:	10800c17 	ldw	r2,48(r2)
 3220320:	e0bfee15 	stw	r2,-72(fp)
 3220324:	00800184 	movi	r2,6
 3220328:	e0bfef0d 	sth	r2,-68(fp)
 322032c:	00bfe0c4 	movi	r2,-125
 3220330:	e0bfef85 	stb	r2,-66(fp)
 3220334:	e03ff00d 	sth	zero,-64(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 3220338:	0080c974 	movhi	r2,805
 322033c:	10930644 	addi	r2,r2,19481
 3220340:	10800003 	ldbu	r2,0(r2)
 3220344:	10803fcc 	andi	r2,r2,255
 3220348:	1005003a 	cmpeq	r2,r2,zero
 322034c:	1000111e 	bne	r2,zero,3220394 <altera_avalon_jtag_uart_write+0x258>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 3220350:	e17fef0b 	ldhu	r5,-68(fp)
 3220354:	e1bfef83 	ldbu	r6,-66(fp)
 3220358:	e1fff00b 	ldhu	r7,-64(fp)
 322035c:	e0bffa44 	addi	r2,fp,-23
 3220360:	d8800015 	stw	r2,0(sp)
 3220364:	e13fee17 	ldw	r4,-72(fp)
 3220368:	32181ac0 	call	32181ac <OSFlagPend>
    return err;
 322036c:	00000906 	br	3220394 <altera_avalon_jtag_uart_write+0x258>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 3220370:	e0bffb17 	ldw	r2,-20(fp)
 3220374:	10c01017 	ldw	r3,64(r2)
 3220378:	e0bff817 	ldw	r2,-32(fp)
 322037c:	1880051e 	bne	r3,r2,3220394 <altera_avalon_jtag_uart_write+0x258>
 3220380:	e0bffb17 	ldw	r2,-20(fp)
 3220384:	10c00917 	ldw	r3,36(r2)
 3220388:	e0bffb17 	ldw	r2,-20(fp)
 322038c:	10800117 	ldw	r2,4(r2)
 3220390:	18bff736 	bltu	r3,r2,3220370 <altera_avalon_jtag_uart_write+0x234>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
 3220394:	e0bffb17 	ldw	r2,-20(fp)
 3220398:	10c01017 	ldw	r3,64(r2)
 322039c:	e0bff817 	ldw	r2,-32(fp)
 32203a0:	18800326 	beq	r3,r2,32203b0 <altera_avalon_jtag_uart_write+0x274>
        break;
    }
  }
  while (count > 0);
 32203a4:	e0bffd17 	ldw	r2,-12(fp)
 32203a8:	10800048 	cmpgei	r2,r2,1
 32203ac:	103fb11e 	bne	r2,zero,3220274 <altera_avalon_jtag_uart_write+0x138>

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
 32203b0:	e0bffb17 	ldw	r2,-20(fp)
 32203b4:	11000b17 	ldw	r4,44(r2)
 32203b8:	321b4e00 	call	321b4e0 <OSSemPost>

  if (ptr != start)
 32203bc:	e0fffc17 	ldw	r3,-16(fp)
 32203c0:	e0bff517 	ldw	r2,-44(fp)
 32203c4:	18800526 	beq	r3,r2,32203dc <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
 32203c8:	e0fffc17 	ldw	r3,-16(fp)
 32203cc:	e0bff517 	ldw	r2,-44(fp)
 32203d0:	1887c83a 	sub	r3,r3,r2
 32203d4:	e0ffff15 	stw	r3,-4(fp)
 32203d8:	00000906 	br	3220400 <altera_avalon_jtag_uart_write+0x2c4>
  else if (flags & O_NONBLOCK)
 32203dc:	e0bffe17 	ldw	r2,-8(fp)
 32203e0:	1090000c 	andi	r2,r2,16384
 32203e4:	1005003a 	cmpeq	r2,r2,zero
 32203e8:	1000031e 	bne	r2,zero,32203f8 <altera_avalon_jtag_uart_write+0x2bc>
    return -EWOULDBLOCK;
 32203ec:	00bffd44 	movi	r2,-11
 32203f0:	e0bfff15 	stw	r2,-4(fp)
 32203f4:	00000206 	br	3220400 <altera_avalon_jtag_uart_write+0x2c4>
  else
    return -EIO; /* Host not connected */
 32203f8:	00bffec4 	movi	r2,-5
 32203fc:	e0bfff15 	stw	r2,-4(fp)
 3220400:	e0bfff17 	ldw	r2,-4(fp)
}
 3220404:	e037883a 	mov	sp,fp
 3220408:	dfc00117 	ldw	ra,4(sp)
 322040c:	df000017 	ldw	fp,0(sp)
 3220410:	dec00204 	addi	sp,sp,8
 3220414:	f800283a 	ret

03220418 <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(altera_avalon_lcd_16207_state* sp, 
  unsigned char command)
{
 3220418:	defffa04 	addi	sp,sp,-24
 322041c:	dfc00515 	stw	ra,20(sp)
 3220420:	df000415 	stw	fp,16(sp)
 3220424:	df000404 	addi	fp,sp,16
 3220428:	e13ffe15 	stw	r4,-8(fp)
 322042c:	e17fff05 	stb	r5,-4(fp)
  unsigned int base = sp->base;
 3220430:	e0bffe17 	ldw	r2,-8(fp)
 3220434:	10800017 	ldw	r2,0(r2)
 3220438:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 322043c:	008003f4 	movhi	r2,15
 3220440:	10909004 	addi	r2,r2,16960
 3220444:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 3220448:	e0bffe17 	ldw	r2,-8(fp)
 322044c:	10800803 	ldbu	r2,32(r2)
 3220450:	10803fcc 	andi	r2,r2,255
 3220454:	1080201c 	xori	r2,r2,128
 3220458:	10bfe004 	addi	r2,r2,-128
 322045c:	1004c03a 	cmpne	r2,r2,zero
 3220460:	1000161e 	bne	r2,zero,32204bc <lcd_write_command+0xa4>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 3220464:	00000a06 	br	3220490 <lcd_write_command+0x78>
    if (--i == 0)
 3220468:	e0bffc17 	ldw	r2,-16(fp)
 322046c:	10bfffc4 	addi	r2,r2,-1
 3220470:	e0bffc15 	stw	r2,-16(fp)
 3220474:	e0bffc17 	ldw	r2,-16(fp)
 3220478:	1004c03a 	cmpne	r2,r2,zero
 322047c:	1000041e 	bne	r2,zero,3220490 <lcd_write_command+0x78>
    {
      sp->broken = 1;
 3220480:	e0fffe17 	ldw	r3,-8(fp)
 3220484:	00800044 	movi	r2,1
 3220488:	18800805 	stb	r2,32(r3)
      return;
 322048c:	00000b06 	br	32204bc <lcd_write_command+0xa4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 3220490:	e0bffd17 	ldw	r2,-12(fp)
 3220494:	10800104 	addi	r2,r2,4
 3220498:	10800037 	ldwio	r2,0(r2)
 322049c:	1080200c 	andi	r2,r2,128
 32204a0:	1004c03a 	cmpne	r2,r2,zero
 32204a4:	103ff01e 	bne	r2,zero,3220468 <lcd_write_command+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 32204a8:	01001904 	movi	r4,100
 32204ac:	323b1cc0 	call	323b1cc <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
 32204b0:	e0bffd17 	ldw	r2,-12(fp)
 32204b4:	e0ffff03 	ldbu	r3,-4(fp)
 32204b8:	10c00035 	stwio	r3,0(r2)
}
 32204bc:	e037883a 	mov	sp,fp
 32204c0:	dfc00117 	ldw	ra,4(sp)
 32204c4:	df000017 	ldw	fp,0(sp)
 32204c8:	dec00204 	addi	sp,sp,8
 32204cc:	f800283a 	ret

032204d0 <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(altera_avalon_lcd_16207_state* sp, 
  unsigned char data)
{
 32204d0:	defffa04 	addi	sp,sp,-24
 32204d4:	dfc00515 	stw	ra,20(sp)
 32204d8:	df000415 	stw	fp,16(sp)
 32204dc:	df000404 	addi	fp,sp,16
 32204e0:	e13ffe15 	stw	r4,-8(fp)
 32204e4:	e17fff05 	stb	r5,-4(fp)
  unsigned int base = sp->base;
 32204e8:	e0bffe17 	ldw	r2,-8(fp)
 32204ec:	10800017 	ldw	r2,0(r2)
 32204f0:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 32204f4:	008003f4 	movhi	r2,15
 32204f8:	10909004 	addi	r2,r2,16960
 32204fc:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 3220500:	e0bffe17 	ldw	r2,-8(fp)
 3220504:	10800803 	ldbu	r2,32(r2)
 3220508:	10803fcc 	andi	r2,r2,255
 322050c:	1080201c 	xori	r2,r2,128
 3220510:	10bfe004 	addi	r2,r2,-128
 3220514:	1004c03a 	cmpne	r2,r2,zero
 3220518:	10001d1e 	bne	r2,zero,3220590 <lcd_write_data+0xc0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 322051c:	00000a06 	br	3220548 <lcd_write_data+0x78>
    if (--i == 0)
 3220520:	e0bffc17 	ldw	r2,-16(fp)
 3220524:	10bfffc4 	addi	r2,r2,-1
 3220528:	e0bffc15 	stw	r2,-16(fp)
 322052c:	e0bffc17 	ldw	r2,-16(fp)
 3220530:	1004c03a 	cmpne	r2,r2,zero
 3220534:	1000041e 	bne	r2,zero,3220548 <lcd_write_data+0x78>
    {
      sp->broken = 1;
 3220538:	e0fffe17 	ldw	r3,-8(fp)
 322053c:	00800044 	movi	r2,1
 3220540:	18800805 	stb	r2,32(r3)
      return;
 3220544:	00001206 	br	3220590 <lcd_write_data+0xc0>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 3220548:	e0bffd17 	ldw	r2,-12(fp)
 322054c:	10800104 	addi	r2,r2,4
 3220550:	10800037 	ldwio	r2,0(r2)
 3220554:	1080200c 	andi	r2,r2,128
 3220558:	1004c03a 	cmpne	r2,r2,zero
 322055c:	103ff01e 	bne	r2,zero,3220520 <lcd_write_data+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 3220560:	01001904 	movi	r4,100
 3220564:	323b1cc0 	call	323b1cc <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);
 3220568:	e0bffd17 	ldw	r2,-12(fp)
 322056c:	10800204 	addi	r2,r2,8
 3220570:	e0ffff03 	ldbu	r3,-4(fp)
 3220574:	10c00035 	stwio	r3,0(r2)

  sp->address++;
 3220578:	e0bffe17 	ldw	r2,-8(fp)
 322057c:	108008c3 	ldbu	r2,35(r2)
 3220580:	10800044 	addi	r2,r2,1
 3220584:	1007883a 	mov	r3,r2
 3220588:	e0bffe17 	ldw	r2,-8(fp)
 322058c:	10c008c5 	stb	r3,35(r2)
}
 3220590:	e037883a 	mov	sp,fp
 3220594:	dfc00117 	ldw	ra,4(sp)
 3220598:	df000017 	ldw	fp,0(sp)
 322059c:	dec00204 	addi	sp,sp,8
 32205a0:	f800283a 	ret

032205a4 <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(altera_avalon_lcd_16207_state* sp)
{
 32205a4:	defffc04 	addi	sp,sp,-16
 32205a8:	dfc00315 	stw	ra,12(sp)
 32205ac:	df000215 	stw	fp,8(sp)
 32205b0:	df000204 	addi	fp,sp,8
 32205b4:	e13fff15 	stw	r4,-4(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
 32205b8:	e13fff17 	ldw	r4,-4(fp)
 32205bc:	01400044 	movi	r5,1
 32205c0:	32204180 	call	3220418 <lcd_write_command>

  sp->x = 0;
 32205c4:	e0bfff17 	ldw	r2,-4(fp)
 32205c8:	10000845 	stb	zero,33(r2)
  sp->y = 0;
 32205cc:	e0bfff17 	ldw	r2,-4(fp)
 32205d0:	10000885 	stb	zero,34(r2)
  sp->address = 0;
 32205d4:	e0bfff17 	ldw	r2,-4(fp)
 32205d8:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 32205dc:	e03ffe15 	stw	zero,-8(fp)
 32205e0:	00001906 	br	3220648 <lcd_clear_screen+0xa4>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
 32205e4:	e0bffe17 	ldw	r2,-8(fp)
 32205e8:	108018e4 	muli	r2,r2,99
 32205ec:	10c01004 	addi	r3,r2,64
 32205f0:	e0bfff17 	ldw	r2,-4(fp)
 32205f4:	1889883a 	add	r4,r3,r2
 32205f8:	01400804 	movi	r5,32
 32205fc:	01801444 	movi	r6,81
 3220600:	3206c500 	call	3206c50 <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
 3220604:	e0bffe17 	ldw	r2,-8(fp)
 3220608:	108018e4 	muli	r2,r2,99
 322060c:	10c00c04 	addi	r3,r2,48
 3220610:	e0bfff17 	ldw	r2,-4(fp)
 3220614:	1889883a 	add	r4,r3,r2
 3220618:	01400804 	movi	r5,32
 322061c:	01800404 	movi	r6,16
 3220620:	3206c500 	call	3206c50 <memset>
    sp->line[y].width = 0;
 3220624:	e0bffe17 	ldw	r2,-8(fp)
 3220628:	e0ffff17 	ldw	r3,-4(fp)
 322062c:	108018e4 	muli	r2,r2,99
 3220630:	10c5883a 	add	r2,r2,r3
 3220634:	10802404 	addi	r2,r2,144
 3220638:	10000045 	stb	zero,1(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 322063c:	e0bffe17 	ldw	r2,-8(fp)
 3220640:	10800044 	addi	r2,r2,1
 3220644:	e0bffe15 	stw	r2,-8(fp)
 3220648:	e0bffe17 	ldw	r2,-8(fp)
 322064c:	10800090 	cmplti	r2,r2,2
 3220650:	103fe41e 	bne	r2,zero,32205e4 <lcd_clear_screen+0x40>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
 3220654:	e037883a 	mov	sp,fp
 3220658:	dfc00117 	ldw	ra,4(sp)
 322065c:	df000017 	ldw	fp,0(sp)
 3220660:	dec00204 	addi	sp,sp,8
 3220664:	f800283a 	ret

03220668 <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(altera_avalon_lcd_16207_state* sp)
{
 3220668:	defff604 	addi	sp,sp,-40
 322066c:	dfc00915 	stw	ra,36(sp)
 3220670:	df000815 	stw	fp,32(sp)
 3220674:	dc000715 	stw	r16,28(sp)
 3220678:	df000704 	addi	fp,sp,28
 322067c:	e13fff15 	stw	r4,-4(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
 3220680:	e0bfff17 	ldw	r2,-4(fp)
 3220684:	10800943 	ldbu	r2,37(r2)
 3220688:	10803fcc 	andi	r2,r2,255
 322068c:	1080201c 	xori	r2,r2,128
 3220690:	10bfe004 	addi	r2,r2,-128
 3220694:	e0bffc15 	stw	r2,-16(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 3220698:	e03ffe15 	stw	zero,-8(fp)
 322069c:	00006406 	br	3220830 <lcd_repaint_screen+0x1c8>
  {
    int width  = sp->line[y].width;
 32206a0:	e0bffe17 	ldw	r2,-8(fp)
 32206a4:	e0ffff17 	ldw	r3,-4(fp)
 32206a8:	108018e4 	muli	r2,r2,99
 32206ac:	10c5883a 	add	r2,r2,r3
 32206b0:	10802404 	addi	r2,r2,144
 32206b4:	10800043 	ldbu	r2,1(r2)
 32206b8:	10803fcc 	andi	r2,r2,255
 32206bc:	1080201c 	xori	r2,r2,128
 32206c0:	10bfe004 	addi	r2,r2,-128
 32206c4:	e0bffb15 	stw	r2,-20(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
 32206c8:	e0bffe17 	ldw	r2,-8(fp)
 32206cc:	e0ffff17 	ldw	r3,-4(fp)
 32206d0:	108018e4 	muli	r2,r2,99
 32206d4:	10c5883a 	add	r2,r2,r3
 32206d8:	10802404 	addi	r2,r2,144
 32206dc:	10800083 	ldbu	r2,2(r2)
 32206e0:	10c03fcc 	andi	r3,r2,255
 32206e4:	e0bffc17 	ldw	r2,-16(fp)
 32206e8:	1885383a 	mul	r2,r3,r2
 32206ec:	1005d23a 	srai	r2,r2,8
 32206f0:	e0bffa15 	stw	r2,-24(fp)
    if (offset >= width)
 32206f4:	e0fffa17 	ldw	r3,-24(fp)
 32206f8:	e0bffb17 	ldw	r2,-20(fp)
 32206fc:	18800116 	blt	r3,r2,3220704 <lcd_repaint_screen+0x9c>
      offset = 0;
 3220700:	e03ffa15 	stw	zero,-24(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 3220704:	e03ffd15 	stw	zero,-12(fp)
 3220708:	00004306 	br	3220818 <lcd_repaint_screen+0x1b0>
    {
      char c = sp->line[y].data[(x + offset) % width];
 322070c:	e43ffe17 	ldw	r16,-8(fp)
 3220710:	e0fffd17 	ldw	r3,-12(fp)
 3220714:	e0bffa17 	ldw	r2,-24(fp)
 3220718:	1889883a 	add	r4,r3,r2
 322071c:	e17ffb17 	ldw	r5,-20(fp)
 3220720:	32047600 	call	3204760 <__modsi3>
 3220724:	1009883a 	mov	r4,r2
 3220728:	e0ffff17 	ldw	r3,-4(fp)
 322072c:	808018e4 	muli	r2,r16,99
 3220730:	10c5883a 	add	r2,r2,r3
 3220734:	1105883a 	add	r2,r2,r4
 3220738:	10801004 	addi	r2,r2,64
 322073c:	10800003 	ldbu	r2,0(r2)
 3220740:	e0bff945 	stb	r2,-27(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
 3220744:	e0bffe17 	ldw	r2,-8(fp)
 3220748:	e13ffd17 	ldw	r4,-12(fp)
 322074c:	e0ffff17 	ldw	r3,-4(fp)
 3220750:	108018e4 	muli	r2,r2,99
 3220754:	10c5883a 	add	r2,r2,r3
 3220758:	1105883a 	add	r2,r2,r4
 322075c:	10800c04 	addi	r2,r2,48
 3220760:	10800003 	ldbu	r2,0(r2)
 3220764:	10c03fcc 	andi	r3,r2,255
 3220768:	18c0201c 	xori	r3,r3,128
 322076c:	18ffe004 	addi	r3,r3,-128
 3220770:	e0bff947 	ldb	r2,-27(fp)
 3220774:	18802526 	beq	r3,r2,322080c <lcd_repaint_screen+0x1a4>
      {
        unsigned char address = x + colstart[y];
 3220778:	e0fffe17 	ldw	r3,-8(fp)
 322077c:	d0a02904 	addi	r2,gp,-32604
 3220780:	1885883a 	add	r2,r3,r2
 3220784:	10800003 	ldbu	r2,0(r2)
 3220788:	1007883a 	mov	r3,r2
 322078c:	e0bffd17 	ldw	r2,-12(fp)
 3220790:	1885883a 	add	r2,r3,r2
 3220794:	e0bff905 	stb	r2,-28(fp)

        if (address != sp->address)
 3220798:	e0fff903 	ldbu	r3,-28(fp)
 322079c:	e0bfff17 	ldw	r2,-4(fp)
 32207a0:	108008c3 	ldbu	r2,35(r2)
 32207a4:	10803fcc 	andi	r2,r2,255
 32207a8:	1080201c 	xori	r2,r2,128
 32207ac:	10bfe004 	addi	r2,r2,-128
 32207b0:	18800926 	beq	r3,r2,32207d8 <lcd_repaint_screen+0x170>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
 32207b4:	e0fff903 	ldbu	r3,-28(fp)
 32207b8:	00bfe004 	movi	r2,-128
 32207bc:	1884b03a 	or	r2,r3,r2
 32207c0:	11403fcc 	andi	r5,r2,255
 32207c4:	e13fff17 	ldw	r4,-4(fp)
 32207c8:	32204180 	call	3220418 <lcd_write_command>
          sp->address = address;
 32207cc:	e0fff903 	ldbu	r3,-28(fp)
 32207d0:	e0bfff17 	ldw	r2,-4(fp)
 32207d4:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
 32207d8:	e0bff943 	ldbu	r2,-27(fp)
 32207dc:	11403fcc 	andi	r5,r2,255
 32207e0:	e13fff17 	ldw	r4,-4(fp)
 32207e4:	32204d00 	call	32204d0 <lcd_write_data>
        sp->line[y].visible[x] = c;
 32207e8:	e0bffe17 	ldw	r2,-8(fp)
 32207ec:	e13ffd17 	ldw	r4,-12(fp)
 32207f0:	e0ffff17 	ldw	r3,-4(fp)
 32207f4:	108018e4 	muli	r2,r2,99
 32207f8:	10c5883a 	add	r2,r2,r3
 32207fc:	1105883a 	add	r2,r2,r4
 3220800:	10c00c04 	addi	r3,r2,48
 3220804:	e0bff943 	ldbu	r2,-27(fp)
 3220808:	18800005 	stb	r2,0(r3)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 322080c:	e0bffd17 	ldw	r2,-12(fp)
 3220810:	10800044 	addi	r2,r2,1
 3220814:	e0bffd15 	stw	r2,-12(fp)
 3220818:	e0bffd17 	ldw	r2,-12(fp)
 322081c:	10800410 	cmplti	r2,r2,16
 3220820:	103fba1e 	bne	r2,zero,322070c <lcd_repaint_screen+0xa4>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 3220824:	e0bffe17 	ldw	r2,-8(fp)
 3220828:	10800044 	addi	r2,r2,1
 322082c:	e0bffe15 	stw	r2,-8(fp)
 3220830:	e0bffe17 	ldw	r2,-8(fp)
 3220834:	10800090 	cmplti	r2,r2,2
 3220838:	103f991e 	bne	r2,zero,32206a0 <lcd_repaint_screen+0x38>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
 322083c:	e037883a 	mov	sp,fp
 3220840:	dfc00217 	ldw	ra,8(sp)
 3220844:	df000117 	ldw	fp,4(sp)
 3220848:	dc000017 	ldw	r16,0(sp)
 322084c:	dec00304 	addi	sp,sp,12
 3220850:	f800283a 	ret

03220854 <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
 3220854:	defffc04 	addi	sp,sp,-16
 3220858:	dfc00315 	stw	ra,12(sp)
 322085c:	df000215 	stw	fp,8(sp)
 3220860:	df000204 	addi	fp,sp,8
 3220864:	e13fff15 	stw	r4,-4(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 3220868:	e03ffe15 	stw	zero,-8(fp)
 322086c:	00001d06 	br	32208e4 <lcd_scroll_up+0x90>
  {
    if (y < ALT_LCD_HEIGHT-1)
 3220870:	e0bffe17 	ldw	r2,-8(fp)
 3220874:	10800048 	cmpgei	r2,r2,1
 3220878:	10000f1e 	bne	r2,zero,32208b8 <lcd_scroll_up+0x64>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
 322087c:	e0bffe17 	ldw	r2,-8(fp)
 3220880:	108018e4 	muli	r2,r2,99
 3220884:	10c01004 	addi	r3,r2,64
 3220888:	e0bfff17 	ldw	r2,-4(fp)
 322088c:	1889883a 	add	r4,r3,r2
 3220890:	e0bffe17 	ldw	r2,-8(fp)
 3220894:	10800044 	addi	r2,r2,1
 3220898:	108018e4 	muli	r2,r2,99
 322089c:	10c01004 	addi	r3,r2,64
 32208a0:	e0bfff17 	ldw	r2,-4(fp)
 32208a4:	1885883a 	add	r2,r3,r2
 32208a8:	100b883a 	mov	r5,r2
 32208ac:	01801404 	movi	r6,80
 32208b0:	3206ad00 	call	3206ad0 <memcpy>
 32208b4:	00000806 	br	32208d8 <lcd_scroll_up+0x84>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
 32208b8:	e0bffe17 	ldw	r2,-8(fp)
 32208bc:	108018e4 	muli	r2,r2,99
 32208c0:	10c01004 	addi	r3,r2,64
 32208c4:	e0bfff17 	ldw	r2,-4(fp)
 32208c8:	1889883a 	add	r4,r3,r2
 32208cc:	01400804 	movi	r5,32
 32208d0:	01801404 	movi	r6,80
 32208d4:	3206c500 	call	3206c50 <memset>

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 32208d8:	e0bffe17 	ldw	r2,-8(fp)
 32208dc:	10800044 	addi	r2,r2,1
 32208e0:	e0bffe15 	stw	r2,-8(fp)
 32208e4:	e0bffe17 	ldw	r2,-8(fp)
 32208e8:	10800090 	cmplti	r2,r2,2
 32208ec:	103fe01e 	bne	r2,zero,3220870 <lcd_scroll_up+0x1c>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
 32208f0:	e0bfff17 	ldw	r2,-4(fp)
 32208f4:	10800883 	ldbu	r2,34(r2)
 32208f8:	10bfffc4 	addi	r2,r2,-1
 32208fc:	1007883a 	mov	r3,r2
 3220900:	e0bfff17 	ldw	r2,-4(fp)
 3220904:	10c00885 	stb	r3,34(r2)
}
 3220908:	e037883a 	mov	sp,fp
 322090c:	dfc00117 	ldw	ra,4(sp)
 3220910:	df000017 	ldw	fp,0(sp)
 3220914:	dec00204 	addi	sp,sp,8
 3220918:	f800283a 	ret

0322091c <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(altera_avalon_lcd_16207_state* sp, char c)
{
 322091c:	defff804 	addi	sp,sp,-32
 3220920:	dfc00715 	stw	ra,28(sp)
 3220924:	df000615 	stw	fp,24(sp)
 3220928:	df000604 	addi	fp,sp,24
 322092c:	e13ffd15 	stw	r4,-12(fp)
 3220930:	e17ffe05 	stb	r5,-8(fp)
  int parm1 = 0, parm2 = 0;
 3220934:	e03ffc15 	stw	zero,-16(fp)
 3220938:	e03ffb15 	stw	zero,-20(fp)

  if (sp->escape[0] == '[')
 322093c:	e0bffd17 	ldw	r2,-12(fp)
 3220940:	10800a03 	ldbu	r2,40(r2)
 3220944:	10803fcc 	andi	r2,r2,255
 3220948:	1080201c 	xori	r2,r2,128
 322094c:	10bfe004 	addi	r2,r2,-128
 3220950:	108016d8 	cmpnei	r2,r2,91
 3220954:	1000491e 	bne	r2,zero,3220a7c <lcd_handle_escape+0x160>
  {
    char * ptr = sp->escape+1;
 3220958:	e0bffd17 	ldw	r2,-12(fp)
 322095c:	10800a04 	addi	r2,r2,40
 3220960:	10800044 	addi	r2,r2,1
 3220964:	e0bffa15 	stw	r2,-24(fp)
    while (isdigit(*ptr))
 3220968:	00000d06 	br	32209a0 <lcd_handle_escape+0x84>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
 322096c:	e0bffc17 	ldw	r2,-16(fp)
 3220970:	10c002a4 	muli	r3,r2,10
 3220974:	e0bffa17 	ldw	r2,-24(fp)
 3220978:	10800003 	ldbu	r2,0(r2)
 322097c:	10803fcc 	andi	r2,r2,255
 3220980:	1080201c 	xori	r2,r2,128
 3220984:	10bfe004 	addi	r2,r2,-128
 3220988:	1885883a 	add	r2,r3,r2
 322098c:	10bff404 	addi	r2,r2,-48
 3220990:	e0bffc15 	stw	r2,-16(fp)
 3220994:	e0bffa17 	ldw	r2,-24(fp)
 3220998:	10800044 	addi	r2,r2,1
 322099c:	e0bffa15 	stw	r2,-24(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
 32209a0:	e0bffa17 	ldw	r2,-24(fp)
 32209a4:	10800003 	ldbu	r2,0(r2)
 32209a8:	10803fcc 	andi	r2,r2,255
 32209ac:	1080201c 	xori	r2,r2,128
 32209b0:	10bfe004 	addi	r2,r2,-128
 32209b4:	1007883a 	mov	r3,r2
 32209b8:	0080c974 	movhi	r2,805
 32209bc:	108a6204 	addi	r2,r2,10632
 32209c0:	10800017 	ldw	r2,0(r2)
 32209c4:	1885883a 	add	r2,r3,r2
 32209c8:	10800003 	ldbu	r2,0(r2)
 32209cc:	10803fcc 	andi	r2,r2,255
 32209d0:	1080010c 	andi	r2,r2,4
 32209d4:	1004c03a 	cmpne	r2,r2,zero
 32209d8:	103fe41e 	bne	r2,zero,322096c <lcd_handle_escape+0x50>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
 32209dc:	e0bffa17 	ldw	r2,-24(fp)
 32209e0:	10800003 	ldbu	r2,0(r2)
 32209e4:	10803fcc 	andi	r2,r2,255
 32209e8:	1080201c 	xori	r2,r2,128
 32209ec:	10bfe004 	addi	r2,r2,-128
 32209f0:	10800ed8 	cmpnei	r2,r2,59
 32209f4:	1000231e 	bne	r2,zero,3220a84 <lcd_handle_escape+0x168>
    {
      ptr++;
 32209f8:	e0bffa17 	ldw	r2,-24(fp)
 32209fc:	10800044 	addi	r2,r2,1
 3220a00:	e0bffa15 	stw	r2,-24(fp)
      while (isdigit(*ptr))
 3220a04:	00000d06 	br	3220a3c <lcd_handle_escape+0x120>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
 3220a08:	e0bffb17 	ldw	r2,-20(fp)
 3220a0c:	10c002a4 	muli	r3,r2,10
 3220a10:	e0bffa17 	ldw	r2,-24(fp)
 3220a14:	10800003 	ldbu	r2,0(r2)
 3220a18:	10803fcc 	andi	r2,r2,255
 3220a1c:	1080201c 	xori	r2,r2,128
 3220a20:	10bfe004 	addi	r2,r2,-128
 3220a24:	1885883a 	add	r2,r3,r2
 3220a28:	10bff404 	addi	r2,r2,-48
 3220a2c:	e0bffb15 	stw	r2,-20(fp)
 3220a30:	e0bffa17 	ldw	r2,-24(fp)
 3220a34:	10800044 	addi	r2,r2,1
 3220a38:	e0bffa15 	stw	r2,-24(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
 3220a3c:	e0bffa17 	ldw	r2,-24(fp)
 3220a40:	10800003 	ldbu	r2,0(r2)
 3220a44:	10803fcc 	andi	r2,r2,255
 3220a48:	1080201c 	xori	r2,r2,128
 3220a4c:	10bfe004 	addi	r2,r2,-128
 3220a50:	1007883a 	mov	r3,r2
 3220a54:	0080c974 	movhi	r2,805
 3220a58:	108a6204 	addi	r2,r2,10632
 3220a5c:	10800017 	ldw	r2,0(r2)
 3220a60:	1885883a 	add	r2,r3,r2
 3220a64:	10800003 	ldbu	r2,0(r2)
 3220a68:	10803fcc 	andi	r2,r2,255
 3220a6c:	1080010c 	andi	r2,r2,4
 3220a70:	1004c03a 	cmpne	r2,r2,zero
 3220a74:	103fe41e 	bne	r2,zero,3220a08 <lcd_handle_escape+0xec>
 3220a78:	00000206 	br	3220a84 <lcd_handle_escape+0x168>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
 3220a7c:	00bfffc4 	movi	r2,-1
 3220a80:	e0bffc15 	stw	r2,-16(fp)

  switch (c)
 3220a84:	e0bffe07 	ldb	r2,-8(fp)
 3220a88:	e0bfff15 	stw	r2,-4(fp)
 3220a8c:	e0ffff17 	ldw	r3,-4(fp)
 3220a90:	188012a0 	cmpeqi	r2,r3,74
 3220a94:	10002f1e 	bne	r2,zero,3220b54 <lcd_handle_escape+0x238>
 3220a98:	e0ffff17 	ldw	r3,-4(fp)
 3220a9c:	188012c8 	cmpgei	r2,r3,75
 3220aa0:	1000041e 	bne	r2,zero,3220ab4 <lcd_handle_escape+0x198>
 3220aa4:	e0ffff17 	ldw	r3,-4(fp)
 3220aa8:	18801220 	cmpeqi	r2,r3,72
 3220aac:	1000081e 	bne	r2,zero,3220ad0 <lcd_handle_escape+0x1b4>
 3220ab0:	00004906 	br	3220bd8 <lcd_handle_escape+0x2bc>
 3220ab4:	e0ffff17 	ldw	r3,-4(fp)
 3220ab8:	188012e0 	cmpeqi	r2,r3,75
 3220abc:	10002b1e 	bne	r2,zero,3220b6c <lcd_handle_escape+0x250>
 3220ac0:	e0ffff17 	ldw	r3,-4(fp)
 3220ac4:	188019a0 	cmpeqi	r2,r3,102
 3220ac8:	1000011e 	bne	r2,zero,3220ad0 <lcd_handle_escape+0x1b4>
 3220acc:	00004206 	br	3220bd8 <lcd_handle_escape+0x2bc>
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
 3220ad0:	e0bffb17 	ldw	r2,-20(fp)
 3220ad4:	10800050 	cmplti	r2,r2,1
 3220ad8:	1000051e 	bne	r2,zero,3220af0 <lcd_handle_escape+0x1d4>
      sp->x = parm2 - 1;
 3220adc:	e0bffb17 	ldw	r2,-20(fp)
 3220ae0:	10bfffc4 	addi	r2,r2,-1
 3220ae4:	1007883a 	mov	r3,r2
 3220ae8:	e0bffd17 	ldw	r2,-12(fp)
 3220aec:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
 3220af0:	e0bffc17 	ldw	r2,-16(fp)
 3220af4:	10800050 	cmplti	r2,r2,1
 3220af8:	1000371e 	bne	r2,zero,3220bd8 <lcd_handle_escape+0x2bc>
    {
      sp->y = parm1 - 1;
 3220afc:	e0bffc17 	ldw	r2,-16(fp)
 3220b00:	10bfffc4 	addi	r2,r2,-1
 3220b04:	1007883a 	mov	r3,r2
 3220b08:	e0bffd17 	ldw	r2,-12(fp)
 3220b0c:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
 3220b10:	e0bffd17 	ldw	r2,-12(fp)
 3220b14:	10800883 	ldbu	r2,34(r2)
 3220b18:	10803fcc 	andi	r2,r2,255
 3220b1c:	10800170 	cmpltui	r2,r2,5
 3220b20:	1000061e 	bne	r2,zero,3220b3c <lcd_handle_escape+0x220>
        sp->y = ALT_LCD_HEIGHT * 2;
 3220b24:	e0fffd17 	ldw	r3,-12(fp)
 3220b28:	00800104 	movi	r2,4
 3220b2c:	18800885 	stb	r2,34(r3)
      while (sp->y > ALT_LCD_HEIGHT)
 3220b30:	00000206 	br	3220b3c <lcd_handle_escape+0x220>
        lcd_scroll_up(sp);
 3220b34:	e13ffd17 	ldw	r4,-12(fp)
 3220b38:	32208540 	call	3220854 <lcd_scroll_up>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
 3220b3c:	e0bffd17 	ldw	r2,-12(fp)
 3220b40:	10800883 	ldbu	r2,34(r2)
 3220b44:	10803fcc 	andi	r2,r2,255
 3220b48:	108000e8 	cmpgeui	r2,r2,3
 3220b4c:	103ff91e 	bne	r2,zero,3220b34 <lcd_handle_escape+0x218>
        lcd_scroll_up(sp);
    }
    break;
 3220b50:	00002106 	br	3220bd8 <lcd_handle_escape+0x2bc>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
 3220b54:	e0bffc17 	ldw	r2,-16(fp)
 3220b58:	10800098 	cmpnei	r2,r2,2
 3220b5c:	10001e1e 	bne	r2,zero,3220bd8 <lcd_handle_escape+0x2bc>
      lcd_clear_screen(sp);
 3220b60:	e13ffd17 	ldw	r4,-12(fp)
 3220b64:	32205a40 	call	32205a4 <lcd_clear_screen>
    break;
 3220b68:	00001b06 	br	3220bd8 <lcd_handle_escape+0x2bc>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
 3220b6c:	e0bffc17 	ldw	r2,-16(fp)
 3220b70:	10800048 	cmpgei	r2,r2,1
 3220b74:	1000181e 	bne	r2,zero,3220bd8 <lcd_handle_escape+0x2bc>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 3220b78:	e0bffd17 	ldw	r2,-12(fp)
 3220b7c:	10800843 	ldbu	r2,33(r2)
 3220b80:	10803fcc 	andi	r2,r2,255
 3220b84:	10801428 	cmpgeui	r2,r2,80
 3220b88:	1000131e 	bne	r2,zero,3220bd8 <lcd_handle_escape+0x2bc>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
 3220b8c:	e0bffd17 	ldw	r2,-12(fp)
 3220b90:	10800883 	ldbu	r2,34(r2)
 3220b94:	10803fcc 	andi	r2,r2,255
 3220b98:	108018e4 	muli	r2,r2,99
 3220b9c:	10c01004 	addi	r3,r2,64
 3220ba0:	e0bffd17 	ldw	r2,-12(fp)
 3220ba4:	1887883a 	add	r3,r3,r2
 3220ba8:	e0bffd17 	ldw	r2,-12(fp)
 3220bac:	10800843 	ldbu	r2,33(r2)
 3220bb0:	10803fcc 	andi	r2,r2,255
 3220bb4:	1889883a 	add	r4,r3,r2
 3220bb8:	e0bffd17 	ldw	r2,-12(fp)
 3220bbc:	10800843 	ldbu	r2,33(r2)
 3220bc0:	10c03fcc 	andi	r3,r2,255
 3220bc4:	00801404 	movi	r2,80
 3220bc8:	10c5c83a 	sub	r2,r2,r3
 3220bcc:	100d883a 	mov	r6,r2
 3220bd0:	01400804 	movi	r5,32
 3220bd4:	3206c500 	call	3206c50 <memset>
    }
    break;
  }
}
 3220bd8:	e037883a 	mov	sp,fp
 3220bdc:	dfc00117 	ldw	ra,4(sp)
 3220be0:	df000017 	ldw	fp,0(sp)
 3220be4:	dec00204 	addi	sp,sp,8
 3220be8:	f800283a 	ret

03220bec <altera_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp, 
  const char* ptr, int len, int flags)
{
 3220bec:	deffef04 	addi	sp,sp,-68
 3220bf0:	dfc01015 	stw	ra,64(sp)
 3220bf4:	df000f15 	stw	fp,60(sp)
 3220bf8:	dc000e15 	stw	r16,56(sp)
 3220bfc:	df000e04 	addi	fp,sp,56
 3220c00:	e13ffc15 	stw	r4,-16(fp)
 3220c04:	e17ffd15 	stw	r5,-12(fp)
 3220c08:	e1bffe15 	stw	r6,-8(fp)
 3220c0c:	e1ffff15 	stw	r7,-4(fp)
  const char* end = ptr + len;
 3220c10:	e0bffe17 	ldw	r2,-8(fp)
 3220c14:	1007883a 	mov	r3,r2
 3220c18:	e0bffd17 	ldw	r2,-12(fp)
 3220c1c:	10c5883a 	add	r2,r2,r3
 3220c20:	e0bffa15 	stw	r2,-24(fp)

  /* When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
 3220c24:	e0bffc17 	ldw	r2,-16(fp)
 3220c28:	10803e17 	ldw	r2,248(r2)
 3220c2c:	e0bff215 	stw	r2,-56(fp)
 3220c30:	e03ff30d 	sth	zero,-52(fp)
 3220c34:	e17ff30b 	ldhu	r5,-52(fp)
 3220c38:	e1bffb04 	addi	r6,fp,-20
 3220c3c:	e13ff217 	ldw	r4,-56(fp)
 3220c40:	321b0e80 	call	321b0e8 <OSSemPend>

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
 3220c44:	e0fffc17 	ldw	r3,-16(fp)
 3220c48:	00800044 	movi	r2,1
 3220c4c:	188009c5 	stb	r2,39(r3)

  for ( ; ptr < end ; ptr++)
 3220c50:	0000a206 	br	3220edc <altera_avalon_lcd_16207_write+0x2f0>
  {
    char c = *ptr;
 3220c54:	e0bffd17 	ldw	r2,-12(fp)
 3220c58:	10800003 	ldbu	r2,0(r2)
 3220c5c:	e0bff705 	stb	r2,-36(fp)

    if (sp->esccount >= 0)
 3220c60:	e0bffc17 	ldw	r2,-16(fp)
 3220c64:	10800903 	ldbu	r2,36(r2)
 3220c68:	10803fcc 	andi	r2,r2,255
 3220c6c:	1080201c 	xori	r2,r2,128
 3220c70:	10bfe004 	addi	r2,r2,-128
 3220c74:	1004803a 	cmplt	r2,r2,zero
 3220c78:	10003b1e 	bne	r2,zero,3220d68 <altera_avalon_lcd_16207_write+0x17c>
    {
      unsigned int esccount = sp->esccount;
 3220c7c:	e0bffc17 	ldw	r2,-16(fp)
 3220c80:	10800903 	ldbu	r2,36(r2)
 3220c84:	10803fcc 	andi	r2,r2,255
 3220c88:	1080201c 	xori	r2,r2,128
 3220c8c:	10bfe004 	addi	r2,r2,-128
 3220c90:	e0bff615 	stw	r2,-40(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 3220c94:	e0bff617 	ldw	r2,-40(fp)
 3220c98:	1004c03a 	cmpne	r2,r2,zero
 3220c9c:	1000031e 	bne	r2,zero,3220cac <altera_avalon_lcd_16207_write+0xc0>
 3220ca0:	e0bff707 	ldb	r2,-36(fp)
 3220ca4:	108016d8 	cmpnei	r2,r2,91
 3220ca8:	1000111e 	bne	r2,zero,3220cf0 <altera_avalon_lcd_16207_write+0x104>
 3220cac:	e0bff617 	ldw	r2,-40(fp)
 3220cb0:	1005003a 	cmpeq	r2,r2,zero
 3220cb4:	10001a1e 	bne	r2,zero,3220d20 <altera_avalon_lcd_16207_write+0x134>
 3220cb8:	e0bff707 	ldb	r2,-36(fp)
 3220cbc:	1007883a 	mov	r3,r2
 3220cc0:	0080c974 	movhi	r2,805
 3220cc4:	108a6204 	addi	r2,r2,10632
 3220cc8:	10800017 	ldw	r2,0(r2)
 3220ccc:	1885883a 	add	r2,r3,r2
 3220cd0:	10800003 	ldbu	r2,0(r2)
 3220cd4:	10803fcc 	andi	r2,r2,255
 3220cd8:	1080010c 	andi	r2,r2,4
 3220cdc:	1004c03a 	cmpne	r2,r2,zero
 3220ce0:	10000f1e 	bne	r2,zero,3220d20 <altera_avalon_lcd_16207_write+0x134>
 3220ce4:	e0bff707 	ldb	r2,-36(fp)
 3220ce8:	10800ee0 	cmpeqi	r2,r2,59
 3220cec:	10000c1e 	bne	r2,zero,3220d20 <altera_avalon_lcd_16207_write+0x134>
          (esccount > 0 && !isdigit(c) && c != ';'))
      {
        sp->escape[esccount] = 0;
 3220cf0:	e0fff617 	ldw	r3,-40(fp)
 3220cf4:	e0bffc17 	ldw	r2,-16(fp)
 3220cf8:	1885883a 	add	r2,r3,r2
 3220cfc:	10800a04 	addi	r2,r2,40
 3220d00:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
 3220d04:	e17ff707 	ldb	r5,-36(fp)
 3220d08:	e13ffc17 	ldw	r4,-16(fp)
 3220d0c:	322091c0 	call	322091c <lcd_handle_escape>

        sp->esccount = -1;
 3220d10:	e0fffc17 	ldw	r3,-16(fp)
 3220d14:	00bfffc4 	movi	r2,-1
 3220d18:	18800905 	stb	r2,36(r3)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 3220d1c:	00006c06 	br	3220ed0 <altera_avalon_lcd_16207_write+0x2e4>

        lcd_handle_escape(sp, c);

        sp->esccount = -1;
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
 3220d20:	e0bffc17 	ldw	r2,-16(fp)
 3220d24:	10800903 	ldbu	r2,36(r2)
 3220d28:	10803fcc 	andi	r2,r2,255
 3220d2c:	108001e8 	cmpgeui	r2,r2,7
 3220d30:	1000671e 	bne	r2,zero,3220ed0 <altera_avalon_lcd_16207_write+0x2e4>
      {
        sp->escape[esccount] = c;
 3220d34:	e0fff617 	ldw	r3,-40(fp)
 3220d38:	e0bffc17 	ldw	r2,-16(fp)
 3220d3c:	1885883a 	add	r2,r3,r2
 3220d40:	10c00a04 	addi	r3,r2,40
 3220d44:	e0bff703 	ldbu	r2,-36(fp)
 3220d48:	18800005 	stb	r2,0(r3)
        sp->esccount++;
 3220d4c:	e0bffc17 	ldw	r2,-16(fp)
 3220d50:	10800903 	ldbu	r2,36(r2)
 3220d54:	10800044 	addi	r2,r2,1
 3220d58:	1007883a 	mov	r3,r2
 3220d5c:	e0bffc17 	ldw	r2,-16(fp)
 3220d60:	10c00905 	stb	r3,36(r2)
 3220d64:	00005a06 	br	3220ed0 <altera_avalon_lcd_16207_write+0x2e4>
      }
    }
    else if (c == 27) /* ESC */
 3220d68:	e0bff707 	ldb	r2,-36(fp)
 3220d6c:	108006d8 	cmpnei	r2,r2,27
 3220d70:	1000031e 	bne	r2,zero,3220d80 <altera_avalon_lcd_16207_write+0x194>
    {
      sp->esccount = 0;
 3220d74:	e0bffc17 	ldw	r2,-16(fp)
 3220d78:	10000905 	stb	zero,36(r2)
 3220d7c:	00005406 	br	3220ed0 <altera_avalon_lcd_16207_write+0x2e4>
    }
    else if (c == '\r')
 3220d80:	e0bff707 	ldb	r2,-36(fp)
 3220d84:	10800358 	cmpnei	r2,r2,13
 3220d88:	1000031e 	bne	r2,zero,3220d98 <altera_avalon_lcd_16207_write+0x1ac>
    {
      sp->x = 0;
 3220d8c:	e0bffc17 	ldw	r2,-16(fp)
 3220d90:	10000845 	stb	zero,33(r2)
 3220d94:	00004e06 	br	3220ed0 <altera_avalon_lcd_16207_write+0x2e4>
    }
    else if (c == '\n')
 3220d98:	e0bff707 	ldb	r2,-36(fp)
 3220d9c:	10800298 	cmpnei	r2,r2,10
 3220da0:	1000101e 	bne	r2,zero,3220de4 <altera_avalon_lcd_16207_write+0x1f8>
    {
      sp->x = 0;
 3220da4:	e0bffc17 	ldw	r2,-16(fp)
 3220da8:	10000845 	stb	zero,33(r2)
      sp->y++;
 3220dac:	e0bffc17 	ldw	r2,-16(fp)
 3220db0:	10800883 	ldbu	r2,34(r2)
 3220db4:	10800044 	addi	r2,r2,1
 3220db8:	1007883a 	mov	r3,r2
 3220dbc:	e0bffc17 	ldw	r2,-16(fp)
 3220dc0:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
 3220dc4:	e0bffc17 	ldw	r2,-16(fp)
 3220dc8:	10800883 	ldbu	r2,34(r2)
 3220dcc:	10803fcc 	andi	r2,r2,255
 3220dd0:	108000f0 	cmpltui	r2,r2,3
 3220dd4:	10003e1e 	bne	r2,zero,3220ed0 <altera_avalon_lcd_16207_write+0x2e4>
        lcd_scroll_up(sp);
 3220dd8:	e13ffc17 	ldw	r4,-16(fp)
 3220ddc:	32208540 	call	3220854 <lcd_scroll_up>
 3220de0:	00003b06 	br	3220ed0 <altera_avalon_lcd_16207_write+0x2e4>
    }
    else if (c == '\b')
 3220de4:	e0bff707 	ldb	r2,-36(fp)
 3220de8:	10800218 	cmpnei	r2,r2,8
 3220dec:	10000c1e 	bne	r2,zero,3220e20 <altera_avalon_lcd_16207_write+0x234>
    {
      if (sp->x > 0)
 3220df0:	e0bffc17 	ldw	r2,-16(fp)
 3220df4:	10800843 	ldbu	r2,33(r2)
 3220df8:	10803fcc 	andi	r2,r2,255
 3220dfc:	1005003a 	cmpeq	r2,r2,zero
 3220e00:	1000331e 	bne	r2,zero,3220ed0 <altera_avalon_lcd_16207_write+0x2e4>
        sp->x--;
 3220e04:	e0bffc17 	ldw	r2,-16(fp)
 3220e08:	10800843 	ldbu	r2,33(r2)
 3220e0c:	10bfffc4 	addi	r2,r2,-1
 3220e10:	1007883a 	mov	r3,r2
 3220e14:	e0bffc17 	ldw	r2,-16(fp)
 3220e18:	10c00845 	stb	r3,33(r2)
 3220e1c:	00002c06 	br	3220ed0 <altera_avalon_lcd_16207_write+0x2e4>
    }
    else if (isprint(c))
 3220e20:	e0bff707 	ldb	r2,-36(fp)
 3220e24:	1007883a 	mov	r3,r2
 3220e28:	0080c974 	movhi	r2,805
 3220e2c:	108a6204 	addi	r2,r2,10632
 3220e30:	10800017 	ldw	r2,0(r2)
 3220e34:	1885883a 	add	r2,r3,r2
 3220e38:	10800003 	ldbu	r2,0(r2)
 3220e3c:	10803fcc 	andi	r2,r2,255
 3220e40:	1080201c 	xori	r2,r2,128
 3220e44:	10bfe004 	addi	r2,r2,-128
 3220e48:	108025cc 	andi	r2,r2,151
 3220e4c:	1005003a 	cmpeq	r2,r2,zero
 3220e50:	10001f1e 	bne	r2,zero,3220ed0 <altera_avalon_lcd_16207_write+0x2e4>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
 3220e54:	e0bffc17 	ldw	r2,-16(fp)
 3220e58:	10800883 	ldbu	r2,34(r2)
 3220e5c:	10803fcc 	andi	r2,r2,255
 3220e60:	108000b0 	cmpltui	r2,r2,2
 3220e64:	1000021e 	bne	r2,zero,3220e70 <altera_avalon_lcd_16207_write+0x284>
        lcd_scroll_up(sp);
 3220e68:	e13ffc17 	ldw	r4,-16(fp)
 3220e6c:	32208540 	call	3220854 <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 3220e70:	e0bffc17 	ldw	r2,-16(fp)
 3220e74:	10800843 	ldbu	r2,33(r2)
 3220e78:	10803fcc 	andi	r2,r2,255
 3220e7c:	10801428 	cmpgeui	r2,r2,80
 3220e80:	10000d1e 	bne	r2,zero,3220eb8 <altera_avalon_lcd_16207_write+0x2cc>
        sp->line[sp->y].data[sp->x] = c;
 3220e84:	e0bffc17 	ldw	r2,-16(fp)
 3220e88:	10800883 	ldbu	r2,34(r2)
 3220e8c:	11003fcc 	andi	r4,r2,255
 3220e90:	e0bffc17 	ldw	r2,-16(fp)
 3220e94:	10800843 	ldbu	r2,33(r2)
 3220e98:	11403fcc 	andi	r5,r2,255
 3220e9c:	e0fffc17 	ldw	r3,-16(fp)
 3220ea0:	208018e4 	muli	r2,r4,99
 3220ea4:	10c5883a 	add	r2,r2,r3
 3220ea8:	1145883a 	add	r2,r2,r5
 3220eac:	10c01004 	addi	r3,r2,64
 3220eb0:	e0bff703 	ldbu	r2,-36(fp)
 3220eb4:	18800005 	stb	r2,0(r3)

      sp->x++;
 3220eb8:	e0bffc17 	ldw	r2,-16(fp)
 3220ebc:	10800843 	ldbu	r2,33(r2)
 3220ec0:	10800044 	addi	r2,r2,1
 3220ec4:	1007883a 	mov	r3,r2
 3220ec8:	e0bffc17 	ldw	r2,-16(fp)
 3220ecc:	10c00845 	stb	r3,33(r2)

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
 3220ed0:	e0bffd17 	ldw	r2,-12(fp)
 3220ed4:	10800044 	addi	r2,r2,1
 3220ed8:	e0bffd15 	stw	r2,-12(fp)
 3220edc:	e0fffd17 	ldw	r3,-12(fp)
 3220ee0:	e0bffa17 	ldw	r2,-24(fp)
 3220ee4:	18bf5b36 	bltu	r3,r2,3220c54 <altera_avalon_lcd_16207_write+0x68>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
 3220ee8:	00800404 	movi	r2,16
 3220eec:	e0bff815 	stw	r2,-32(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 3220ef0:	e03ff915 	stw	zero,-28(fp)
 3220ef4:	00003606 	br	3220fd0 <altera_avalon_lcd_16207_write+0x3e4>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 3220ef8:	00801404 	movi	r2,80
 3220efc:	e0bff515 	stw	r2,-44(fp)
 3220f00:	00001106 	br	3220f48 <altera_avalon_lcd_16207_write+0x35c>
      if (sp->line[y].data[width-1] != ' ')
 3220f04:	e13ff917 	ldw	r4,-28(fp)
 3220f08:	e0bff517 	ldw	r2,-44(fp)
 3220f0c:	117fffc4 	addi	r5,r2,-1
 3220f10:	e0fffc17 	ldw	r3,-16(fp)
 3220f14:	208018e4 	muli	r2,r4,99
 3220f18:	10c5883a 	add	r2,r2,r3
 3220f1c:	1145883a 	add	r2,r2,r5
 3220f20:	10801004 	addi	r2,r2,64
 3220f24:	10800003 	ldbu	r2,0(r2)
 3220f28:	10803fcc 	andi	r2,r2,255
 3220f2c:	1080201c 	xori	r2,r2,128
 3220f30:	10bfe004 	addi	r2,r2,-128
 3220f34:	10800818 	cmpnei	r2,r2,32
 3220f38:	1000061e 	bne	r2,zero,3220f54 <altera_avalon_lcd_16207_write+0x368>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 3220f3c:	e0bff517 	ldw	r2,-44(fp)
 3220f40:	10bfffc4 	addi	r2,r2,-1
 3220f44:	e0bff515 	stw	r2,-44(fp)
 3220f48:	e0bff517 	ldw	r2,-44(fp)
 3220f4c:	10800048 	cmpgei	r2,r2,1
 3220f50:	103fec1e 	bne	r2,zero,3220f04 <altera_avalon_lcd_16207_write+0x318>

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
 3220f54:	e0bff517 	ldw	r2,-44(fp)
 3220f58:	10800448 	cmpgei	r2,r2,17
 3220f5c:	1000031e 	bne	r2,zero,3220f6c <altera_avalon_lcd_16207_write+0x380>
      width = ALT_LCD_WIDTH;
 3220f60:	00800404 	movi	r2,16
 3220f64:	e0bff515 	stw	r2,-44(fp)
 3220f68:	00000306 	br	3220f78 <altera_avalon_lcd_16207_write+0x38c>
    else
      width++;
 3220f6c:	e0bff517 	ldw	r2,-44(fp)
 3220f70:	10800044 	addi	r2,r2,1
 3220f74:	e0bff515 	stw	r2,-44(fp)

    sp->line[y].width = width;
 3220f78:	e13ff917 	ldw	r4,-28(fp)
 3220f7c:	e0bff517 	ldw	r2,-44(fp)
 3220f80:	100b883a 	mov	r5,r2
 3220f84:	e0fffc17 	ldw	r3,-16(fp)
 3220f88:	208018e4 	muli	r2,r4,99
 3220f8c:	10c5883a 	add	r2,r2,r3
 3220f90:	10802404 	addi	r2,r2,144
 3220f94:	11400045 	stb	r5,1(r2)
    if (widthmax < width)
 3220f98:	e0fff817 	ldw	r3,-32(fp)
 3220f9c:	e0bff517 	ldw	r2,-44(fp)
 3220fa0:	1880020e 	bge	r3,r2,3220fac <altera_avalon_lcd_16207_write+0x3c0>
      widthmax = width;
 3220fa4:	e0bff517 	ldw	r2,-44(fp)
 3220fa8:	e0bff815 	stw	r2,-32(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
 3220fac:	e0bff917 	ldw	r2,-28(fp)
 3220fb0:	e0fffc17 	ldw	r3,-16(fp)
 3220fb4:	108018e4 	muli	r2,r2,99
 3220fb8:	10c5883a 	add	r2,r2,r3
 3220fbc:	10802404 	addi	r2,r2,144
 3220fc0:	10000085 	stb	zero,2(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 3220fc4:	e0bff917 	ldw	r2,-28(fp)
 3220fc8:	10800044 	addi	r2,r2,1
 3220fcc:	e0bff915 	stw	r2,-28(fp)
 3220fd0:	e0bff917 	ldw	r2,-28(fp)
 3220fd4:	10800090 	cmplti	r2,r2,2
 3220fd8:	103fc71e 	bne	r2,zero,3220ef8 <altera_avalon_lcd_16207_write+0x30c>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
 3220fdc:	e0bff817 	ldw	r2,-32(fp)
 3220fe0:	10800448 	cmpgei	r2,r2,17
 3220fe4:	1000031e 	bne	r2,zero,3220ff4 <altera_avalon_lcd_16207_write+0x408>
    sp->scrollmax = 0;
 3220fe8:	e0bffc17 	ldw	r2,-16(fp)
 3220fec:	10000985 	stb	zero,38(r2)
 3220ff0:	00002d06 	br	32210a8 <altera_avalon_lcd_16207_write+0x4bc>
  else
  {
    widthmax *= 2;
 3220ff4:	e0bff817 	ldw	r2,-32(fp)
 3220ff8:	1085883a 	add	r2,r2,r2
 3220ffc:	e0bff815 	stw	r2,-32(fp)
    sp->scrollmax = widthmax;
 3221000:	e0bff817 	ldw	r2,-32(fp)
 3221004:	1007883a 	mov	r3,r2
 3221008:	e0bffc17 	ldw	r2,-16(fp)
 322100c:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 3221010:	e03ff915 	stw	zero,-28(fp)
 3221014:	00002106 	br	322109c <altera_avalon_lcd_16207_write+0x4b0>
      if (sp->line[y].width > ALT_LCD_WIDTH)
 3221018:	e0bff917 	ldw	r2,-28(fp)
 322101c:	e0fffc17 	ldw	r3,-16(fp)
 3221020:	108018e4 	muli	r2,r2,99
 3221024:	10c5883a 	add	r2,r2,r3
 3221028:	10802404 	addi	r2,r2,144
 322102c:	10800043 	ldbu	r2,1(r2)
 3221030:	10803fcc 	andi	r2,r2,255
 3221034:	1080201c 	xori	r2,r2,128
 3221038:	10bfe004 	addi	r2,r2,-128
 322103c:	10800450 	cmplti	r2,r2,17
 3221040:	1000131e 	bne	r2,zero,3221090 <altera_avalon_lcd_16207_write+0x4a4>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
 3221044:	e43ff917 	ldw	r16,-28(fp)
 3221048:	e0bff917 	ldw	r2,-28(fp)
 322104c:	e0fffc17 	ldw	r3,-16(fp)
 3221050:	108018e4 	muli	r2,r2,99
 3221054:	10c5883a 	add	r2,r2,r3
 3221058:	10802404 	addi	r2,r2,144
 322105c:	10800043 	ldbu	r2,1(r2)
 3221060:	10803fcc 	andi	r2,r2,255
 3221064:	1080201c 	xori	r2,r2,128
 3221068:	10bfe004 	addi	r2,r2,-128
 322106c:	1008923a 	slli	r4,r2,8
 3221070:	e17ff817 	ldw	r5,-32(fp)
 3221074:	32047000 	call	3204700 <__divsi3>
 3221078:	1009883a 	mov	r4,r2
 322107c:	e0fffc17 	ldw	r3,-16(fp)
 3221080:	808018e4 	muli	r2,r16,99
 3221084:	10c5883a 	add	r2,r2,r3
 3221088:	10802404 	addi	r2,r2,144
 322108c:	11000085 	stb	r4,2(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 3221090:	e0bff917 	ldw	r2,-28(fp)
 3221094:	10800044 	addi	r2,r2,1
 3221098:	e0bff915 	stw	r2,-28(fp)
 322109c:	e0bff917 	ldw	r2,-28(fp)
 32210a0:	10800090 	cmplti	r2,r2,2
 32210a4:	103fdc1e 	bne	r2,zero,3221018 <altera_avalon_lcd_16207_write+0x42c>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
 32210a8:	e0bffc17 	ldw	r2,-16(fp)
 32210ac:	10800943 	ldbu	r2,37(r2)
 32210b0:	10803fcc 	andi	r2,r2,255
 32210b4:	1080201c 	xori	r2,r2,128
 32210b8:	10bfe004 	addi	r2,r2,-128
 32210bc:	e0bff415 	stw	r2,-48(fp)

    lcd_repaint_screen(sp);
 32210c0:	e13ffc17 	ldw	r4,-16(fp)
 32210c4:	32206680 	call	3220668 <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
 32210c8:	e0bffc17 	ldw	r2,-16(fp)
 32210cc:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
 32210d0:	e0bffc17 	ldw	r2,-16(fp)
 32210d4:	10800943 	ldbu	r2,37(r2)
 32210d8:	10c03fcc 	andi	r3,r2,255
 32210dc:	18c0201c 	xori	r3,r3,128
 32210e0:	18ffe004 	addi	r3,r3,-128
 32210e4:	e0bff417 	ldw	r2,-48(fp)
 32210e8:	18800426 	beq	r3,r2,32210fc <altera_avalon_lcd_16207_write+0x510>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
 32210ec:	e0fffc17 	ldw	r3,-16(fp)
 32210f0:	00800044 	movi	r2,1
 32210f4:	188009c5 	stb	r2,39(r3)
  }
 32210f8:	003feb06 	br	32210a8 <altera_avalon_lcd_16207_write+0x4bc>

  /* Now that access to the display is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
 32210fc:	e0bffc17 	ldw	r2,-16(fp)
 3221100:	11003e17 	ldw	r4,248(r2)
 3221104:	321b4e00 	call	321b4e0 <OSSemPost>

  return len;
 3221108:	e0bffe17 	ldw	r2,-8(fp)
}
 322110c:	e037883a 	mov	sp,fp
 3221110:	dfc00217 	ldw	ra,8(sp)
 3221114:	df000117 	ldw	fp,4(sp)
 3221118:	dc000017 	ldw	r16,0(sp)
 322111c:	dec00304 	addi	sp,sp,12
 3221120:	f800283a 	ret

03221124 <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context) 
{
 3221124:	defffc04 	addi	sp,sp,-16
 3221128:	dfc00315 	stw	ra,12(sp)
 322112c:	df000215 	stw	fp,8(sp)
 3221130:	df000204 	addi	fp,sp,8
 3221134:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_lcd_16207_state* sp = (altera_avalon_lcd_16207_state*)context;
 3221138:	e0bfff17 	ldw	r2,-4(fp)
 322113c:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
 3221140:	e0bffe17 	ldw	r2,-8(fp)
 3221144:	10800943 	ldbu	r2,37(r2)
 3221148:	10803fcc 	andi	r2,r2,255
 322114c:	1080201c 	xori	r2,r2,128
 3221150:	10bfe004 	addi	r2,r2,-128
 3221154:	10c00044 	addi	r3,r2,1
 3221158:	e0bffe17 	ldw	r2,-8(fp)
 322115c:	10800983 	ldbu	r2,38(r2)
 3221160:	10803fcc 	andi	r2,r2,255
 3221164:	1080201c 	xori	r2,r2,128
 3221168:	10bfe004 	addi	r2,r2,-128
 322116c:	18800316 	blt	r3,r2,322117c <alt_lcd_16207_timeout+0x58>
    sp->scrollpos = 0;
 3221170:	e0bffe17 	ldw	r2,-8(fp)
 3221174:	10000945 	stb	zero,37(r2)
 3221178:	00000606 	br	3221194 <alt_lcd_16207_timeout+0x70>
  else
    sp->scrollpos = sp->scrollpos + 1;
 322117c:	e0bffe17 	ldw	r2,-8(fp)
 3221180:	10800943 	ldbu	r2,37(r2)
 3221184:	10800044 	addi	r2,r2,1
 3221188:	1007883a 	mov	r3,r2
 322118c:	e0bffe17 	ldw	r2,-8(fp)
 3221190:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
 3221194:	e0bffe17 	ldw	r2,-8(fp)
 3221198:	10800983 	ldbu	r2,38(r2)
 322119c:	10803fcc 	andi	r2,r2,255
 32211a0:	1080201c 	xori	r2,r2,128
 32211a4:	10bfe004 	addi	r2,r2,-128
 32211a8:	10800050 	cmplti	r2,r2,1
 32211ac:	1000091e 	bne	r2,zero,32211d4 <alt_lcd_16207_timeout+0xb0>
 32211b0:	e0bffe17 	ldw	r2,-8(fp)
 32211b4:	108009c3 	ldbu	r2,39(r2)
 32211b8:	10803fcc 	andi	r2,r2,255
 32211bc:	1080201c 	xori	r2,r2,128
 32211c0:	10bfe004 	addi	r2,r2,-128
 32211c4:	1004c03a 	cmpne	r2,r2,zero
 32211c8:	1000021e 	bne	r2,zero,32211d4 <alt_lcd_16207_timeout+0xb0>
    lcd_repaint_screen(sp);
 32211cc:	e13ffe17 	ldw	r4,-8(fp)
 32211d0:	32206680 	call	3220668 <lcd_repaint_screen>

  return sp->period;
 32211d4:	e0bffe17 	ldw	r2,-8(fp)
 32211d8:	10800717 	ldw	r2,28(r2)
}
 32211dc:	e037883a 	mov	sp,fp
 32211e0:	dfc00117 	ldw	ra,4(sp)
 32211e4:	df000017 	ldw	fp,0(sp)
 32211e8:	dec00204 	addi	sp,sp,8
 32211ec:	f800283a 	ret

032211f0 <altera_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void altera_avalon_lcd_16207_init(altera_avalon_lcd_16207_state* sp)
{
 32211f0:	defffa04 	addi	sp,sp,-24
 32211f4:	dfc00515 	stw	ra,20(sp)
 32211f8:	df000415 	stw	fp,16(sp)
 32211fc:	df000404 	addi	fp,sp,16
 3221200:	e13fff15 	stw	r4,-4(fp)
  unsigned int base = sp->base;
 3221204:	e0bfff17 	ldw	r2,-4(fp)
 3221208:	10800017 	ldw	r2,0(r2)
 322120c:	e0bffe15 	stw	r2,-8(fp)

  /* Mark the device as functional */
  sp->broken = 0;
 3221210:	e0bfff17 	ldw	r2,-4(fp)
 3221214:	10000805 	stb	zero,32(r2)

  ALT_SEM_CREATE (&sp->write_lock, 1);
 3221218:	e0bfff17 	ldw	r2,-4(fp)
 322121c:	10803e04 	addi	r2,r2,248
 3221220:	e0bffc15 	stw	r2,-16(fp)
 3221224:	00800044 	movi	r2,1
 3221228:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 322122c:	e13ffd0b 	ldhu	r4,-12(fp)
 3221230:	321ad340 	call	321ad34 <OSSemCreate>
 3221234:	1007883a 	mov	r3,r2
 3221238:	e0bffc17 	ldw	r2,-16(fp)
 322123c:	10c00015 	stw	r3,0(r2)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
 3221240:	010ea604 	movi	r4,15000
 3221244:	323b1cc0 	call	323b1cc <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 3221248:	e0bffe17 	ldw	r2,-8(fp)
 322124c:	1007883a 	mov	r3,r2
 3221250:	00800c04 	movi	r2,48
 3221254:	18800035 	stwio	r2,0(r3)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);  
 3221258:	01040104 	movi	r4,4100
 322125c:	323b1cc0 	call	323b1cc <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 3221260:	e0bffe17 	ldw	r2,-8(fp)
 3221264:	1007883a 	mov	r3,r2
 3221268:	00800c04 	movi	r2,48
 322126c:	18800035 	stwio	r2,0(r3)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
 3221270:	0100fa04 	movi	r4,1000
 3221274:	323b1cc0 	call	323b1cc <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 3221278:	e0bffe17 	ldw	r2,-8(fp)
 322127c:	1007883a 	mov	r3,r2
 3221280:	00800c04 	movi	r2,48
 3221284:	18800035 	stwio	r2,0(r3)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
 3221288:	e13fff17 	ldw	r4,-4(fp)
 322128c:	01400e04 	movi	r5,56
 3221290:	32204180 	call	3220418 <lcd_write_command>
  
  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
 3221294:	e13fff17 	ldw	r4,-4(fp)
 3221298:	01400204 	movi	r5,8
 322129c:	32204180 	call	3220418 <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
 32212a0:	e13fff17 	ldw	r4,-4(fp)
 32212a4:	32205a40 	call	32205a4 <lcd_clear_screen>
  
  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
 32212a8:	e13fff17 	ldw	r4,-4(fp)
 32212ac:	01400184 	movi	r5,6
 32212b0:	32204180 	call	3220418 <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
 32212b4:	e13fff17 	ldw	r4,-4(fp)
 32212b8:	01400304 	movi	r5,12
 32212bc:	32204180 	call	3220418 <lcd_write_command>

  sp->esccount = -1;
 32212c0:	e0ffff17 	ldw	r3,-4(fp)
 32212c4:	00bfffc4 	movi	r2,-1
 32212c8:	18800905 	stb	r2,36(r3)
  memset(sp->escape, 0, sizeof(sp->escape));
 32212cc:	e0bfff17 	ldw	r2,-4(fp)
 32212d0:	11000a04 	addi	r4,r2,40
 32212d4:	000b883a 	mov	r5,zero
 32212d8:	01800204 	movi	r6,8
 32212dc:	3206c500 	call	3206c50 <memset>

  sp->scrollpos = 0;
 32212e0:	e0bfff17 	ldw	r2,-4(fp)
 32212e4:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
 32212e8:	e0bfff17 	ldw	r2,-4(fp)
 32212ec:	10000985 	stb	zero,38(r2)
  sp->active = 0;
 32212f0:	e0bfff17 	ldw	r2,-4(fp)
 32212f4:	100009c5 	stb	zero,39(r2)
 32212f8:	0080c974 	movhi	r2,805
 32212fc:	10935104 	addi	r2,r2,19780
 3221300:	10800017 	ldw	r2,0(r2)
 3221304:	1009883a 	mov	r4,r2

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
 3221308:	01400284 	movi	r5,10
 322130c:	32047c00 	call	32047c0 <__udivsi3>
 3221310:	1007883a 	mov	r3,r2
 3221314:	e0bfff17 	ldw	r2,-4(fp)
 3221318:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
 322131c:	e0bfff17 	ldw	r2,-4(fp)
 3221320:	11000104 	addi	r4,r2,4
 3221324:	e0bfff17 	ldw	r2,-4(fp)
 3221328:	10800717 	ldw	r2,28(r2)
 322132c:	100b883a 	mov	r5,r2
 3221330:	0180c8b4 	movhi	r6,802
 3221334:	31844904 	addi	r6,r6,4388
 3221338:	e1ffff17 	ldw	r7,-4(fp)
 322133c:	323a2e40 	call	323a2e4 <alt_alarm_start>
}
 3221340:	e037883a 	mov	sp,fp
 3221344:	dfc00117 	ldw	ra,4(sp)
 3221348:	df000017 	ldw	fp,0(sp)
 322134c:	dec00204 	addi	sp,sp,8
 3221350:	f800283a 	ret

03221354 <altera_avalon_lcd_16207_write_fd>:
extern int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp,
  const char* ptr, int count, int flags);

int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
 3221354:	defffa04 	addi	sp,sp,-24
 3221358:	dfc00515 	stw	ra,20(sp)
 322135c:	df000415 	stw	fp,16(sp)
 3221360:	df000404 	addi	fp,sp,16
 3221364:	e13ffd15 	stw	r4,-12(fp)
 3221368:	e17ffe15 	stw	r5,-8(fp)
 322136c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 
 3221370:	e0bffd17 	ldw	r2,-12(fp)
 3221374:	10800017 	ldw	r2,0(r2)
 3221378:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
 322137c:	e0bffc17 	ldw	r2,-16(fp)
 3221380:	11000a04 	addi	r4,r2,40
 3221384:	e0bffd17 	ldw	r2,-12(fp)
 3221388:	11c00217 	ldw	r7,8(r2)
 322138c:	e17ffe17 	ldw	r5,-8(fp)
 3221390:	e1bfff17 	ldw	r6,-4(fp)
 3221394:	3220bec0 	call	3220bec <altera_avalon_lcd_16207_write>
      fd->fd_flags);
}
 3221398:	e037883a 	mov	sp,fp
 322139c:	dfc00117 	ldw	ra,4(sp)
 32213a0:	df000017 	ldw	fp,0(sp)
 32213a4:	dec00204 	addi	sp,sp,8
 32213a8:	f800283a 	ret

032213ac <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 32213ac:	defff904 	addi	sp,sp,-28
 32213b0:	dfc00615 	stw	ra,24(sp)
 32213b4:	df000515 	stw	fp,20(sp)
 32213b8:	df000504 	addi	fp,sp,20
 32213bc:	e13ffe15 	stw	r4,-8(fp)
 32213c0:	e17fff15 	stw	r5,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 32213c4:	e0bffe17 	ldw	r2,-8(fp)
 32213c8:	10000035 	stwio	zero,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 32213cc:	e0bffe17 	ldw	r2,-8(fp)
 32213d0:	10800104 	addi	r2,r2,4
 32213d4:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 32213d8:	0005303a 	rdctl	r2,status
 32213dc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 32213e0:	e0fffc17 	ldw	r3,-16(fp)
 32213e4:	00bfff84 	movi	r2,-2
 32213e8:	1884703a 	and	r2,r3,r2
 32213ec:	1001703a 	wrctl	status,r2
  
  return context;
 32213f0:	e0bffc17 	ldw	r2,-16(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 32213f4:	e0bffd15 	stw	r2,-12(fp)
  alt_tick ();
 32213f8:	323b0bc0 	call	323b0bc <alt_tick>
 32213fc:	e0bffd17 	ldw	r2,-12(fp)
 3221400:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3221404:	e0bffb17 	ldw	r2,-20(fp)
 3221408:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 322140c:	e037883a 	mov	sp,fp
 3221410:	dfc00117 	ldw	ra,4(sp)
 3221414:	df000017 	ldw	fp,0(sp)
 3221418:	dec00204 	addi	sp,sp,8
 322141c:	f800283a 	ret

03221420 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 3221420:	defff904 	addi	sp,sp,-28
 3221424:	dfc00615 	stw	ra,24(sp)
 3221428:	df000515 	stw	fp,20(sp)
 322142c:	df000504 	addi	fp,sp,20
 3221430:	e13ffc15 	stw	r4,-16(fp)
 3221434:	e17ffd15 	stw	r5,-12(fp)
 3221438:	e1bffe15 	stw	r6,-8(fp)
 322143c:	e1ffff15 	stw	r7,-4(fp)
 3221440:	e0bfff17 	ldw	r2,-4(fp)
 3221444:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 3221448:	0080c974 	movhi	r2,805
 322144c:	10935104 	addi	r2,r2,19780
 3221450:	10800017 	ldw	r2,0(r2)
 3221454:	1004c03a 	cmpne	r2,r2,zero
 3221458:	1000041e 	bne	r2,zero,322146c <alt_avalon_timer_sc_init+0x4c>
  {
    _alt_tick_rate = nticks;
 322145c:	00c0c974 	movhi	r3,805
 3221460:	18d35104 	addi	r3,r3,19780
 3221464:	e0bffb17 	ldw	r2,-20(fp)
 3221468:	18800015 	stw	r2,0(r3)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 322146c:	e0bffc17 	ldw	r2,-16(fp)
 3221470:	10800104 	addi	r2,r2,4
 3221474:	1007883a 	mov	r3,r2
 3221478:	008001c4 	movi	r2,7
 322147c:	18800035 	stwio	r2,0(r3)
  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
 3221480:	e13ffe17 	ldw	r4,-8(fp)
 3221484:	e17ffc17 	ldw	r5,-16(fp)
 3221488:	0180c8b4 	movhi	r6,802
 322148c:	3184eb04 	addi	r6,r6,5036
 3221490:	323ac6c0 	call	323ac6c <alt_irq_register>
#endif  
}
 3221494:	e037883a 	mov	sp,fp
 3221498:	dfc00117 	ldw	ra,4(sp)
 322149c:	df000017 	ldw	fp,0(sp)
 32214a0:	dec00204 	addi	sp,sp,8
 32214a4:	f800283a 	ret

032214a8 <locator_init>:
#include <stdio.h>

#include "avalon_locator.h"

void locator_init(LOCATOR *sp, void *base)
{
 32214a8:	defffd04 	addi	sp,sp,-12
 32214ac:	df000215 	stw	fp,8(sp)
 32214b0:	df000204 	addi	fp,sp,8
 32214b4:	e13ffe15 	stw	r4,-8(fp)
 32214b8:	e17fff15 	stw	r5,-4(fp)
	sp->base = base;
 32214bc:	e0fffe17 	ldw	r3,-8(fp)
 32214c0:	e0bfff17 	ldw	r2,-4(fp)
 32214c4:	18800015 	stw	r2,0(r3)
	sp->id = 0;
 32214c8:	e0bffe17 	ldw	r2,-8(fp)
 32214cc:	10000115 	stw	zero,4(r2)
	sp->active = 0;
 32214d0:	e0bffe17 	ldw	r2,-8(fp)
 32214d4:	10000215 	stw	zero,8(r2)
}
 32214d8:	e037883a 	mov	sp,fp
 32214dc:	df000017 	ldw	fp,0(sp)
 32214e0:	dec00104 	addi	sp,sp,4
 32214e4:	f800283a 	ret

032214e8 <get_current_corners>:

/* Gets the current corners list of the identified peripheral. */
int get_current_corners(LOCATOR *sp, char *char_buffer)
{
 32214e8:	deffeb04 	addi	sp,sp,-84
 32214ec:	dfc01415 	stw	ra,80(sp)
 32214f0:	df001315 	stw	fp,76(sp)
 32214f4:	dc401215 	stw	r17,72(sp)
 32214f8:	dc001115 	stw	r16,68(sp)
 32214fc:	df001104 	addi	fp,sp,68
 3221500:	e13ffe15 	stw	r4,-8(fp)
 3221504:	e17fff15 	stw	r5,-4(fp)
	int nchars = 0;
 3221508:	e03ffd15 	stw	zero,-12(fp)

	if (sp->active) {
 322150c:	e0bffe17 	ldw	r2,-8(fp)
 3221510:	10800217 	ldw	r2,8(r2)
 3221514:	1005003a 	cmpeq	r2,r2,zero
 3221518:	1000541e 	bne	r2,zero,322166c <get_current_corners+0x184>
		nchars = sprintf(char_buffer,
 322151c:	e0bffe17 	ldw	r2,-8(fp)
 3221520:	10800017 	ldw	r2,0(r2)
 3221524:	10800c04 	addi	r2,r2,48
 3221528:	11800037 	ldwio	r6,0(r2)
 322152c:	e0bffe17 	ldw	r2,-8(fp)
 3221530:	10800017 	ldw	r2,0(r2)
 3221534:	10800e04 	addi	r2,r2,56
 3221538:	11c00037 	ldwio	r7,0(r2)
 322153c:	e0bffe17 	ldw	r2,-8(fp)
 3221540:	10800017 	ldw	r2,0(r2)
 3221544:	10801004 	addi	r2,r2,64
 3221548:	10c00037 	ldwio	r3,0(r2)
 322154c:	e0bffe17 	ldw	r2,-8(fp)
 3221550:	10800017 	ldw	r2,0(r2)
 3221554:	10801204 	addi	r2,r2,72
 3221558:	11000037 	ldwio	r4,0(r2)
 322155c:	e0bffe17 	ldw	r2,-8(fp)
 3221560:	10800017 	ldw	r2,0(r2)
 3221564:	10801404 	addi	r2,r2,80
 3221568:	11400037 	ldwio	r5,0(r2)
 322156c:	e0bffe17 	ldw	r2,-8(fp)
 3221570:	10800017 	ldw	r2,0(r2)
 3221574:	10801604 	addi	r2,r2,88
 3221578:	12000037 	ldwio	r8,0(r2)
 322157c:	e0bffe17 	ldw	r2,-8(fp)
 3221580:	10800017 	ldw	r2,0(r2)
 3221584:	10801804 	addi	r2,r2,96
 3221588:	12400037 	ldwio	r9,0(r2)
 322158c:	e0bffe17 	ldw	r2,-8(fp)
 3221590:	10800017 	ldw	r2,0(r2)
 3221594:	10801a04 	addi	r2,r2,104
 3221598:	12800037 	ldwio	r10,0(r2)
 322159c:	e0bffe17 	ldw	r2,-8(fp)
 32215a0:	10800017 	ldw	r2,0(r2)
 32215a4:	10801c04 	addi	r2,r2,112
 32215a8:	12c00037 	ldwio	r11,0(r2)
 32215ac:	e0bffe17 	ldw	r2,-8(fp)
 32215b0:	10800017 	ldw	r2,0(r2)
 32215b4:	10801e04 	addi	r2,r2,120
 32215b8:	13000037 	ldwio	r12,0(r2)
 32215bc:	e0bffe17 	ldw	r2,-8(fp)
 32215c0:	10800017 	ldw	r2,0(r2)
 32215c4:	10802004 	addi	r2,r2,128
 32215c8:	13400037 	ldwio	r13,0(r2)
 32215cc:	e0bffe17 	ldw	r2,-8(fp)
 32215d0:	10800017 	ldw	r2,0(r2)
 32215d4:	10802204 	addi	r2,r2,136
 32215d8:	13800037 	ldwio	r14,0(r2)
 32215dc:	e0bffe17 	ldw	r2,-8(fp)
 32215e0:	10800017 	ldw	r2,0(r2)
 32215e4:	10802404 	addi	r2,r2,144
 32215e8:	13c00037 	ldwio	r15,0(r2)
 32215ec:	e0bffe17 	ldw	r2,-8(fp)
 32215f0:	10800017 	ldw	r2,0(r2)
 32215f4:	10802604 	addi	r2,r2,152
 32215f8:	14000037 	ldwio	r16,0(r2)
 32215fc:	e0bffe17 	ldw	r2,-8(fp)
 3221600:	10800017 	ldw	r2,0(r2)
 3221604:	10802804 	addi	r2,r2,160
 3221608:	14400037 	ldwio	r17,0(r2)
 322160c:	e0bffe17 	ldw	r2,-8(fp)
 3221610:	10800017 	ldw	r2,0(r2)
 3221614:	10802a04 	addi	r2,r2,168
 3221618:	10800037 	ldwio	r2,0(r2)
 322161c:	d8c00015 	stw	r3,0(sp)
 3221620:	d9000115 	stw	r4,4(sp)
 3221624:	d9400215 	stw	r5,8(sp)
 3221628:	da000315 	stw	r8,12(sp)
 322162c:	da400415 	stw	r9,16(sp)
 3221630:	da800515 	stw	r10,20(sp)
 3221634:	dac00615 	stw	r11,24(sp)
 3221638:	db000715 	stw	r12,28(sp)
 322163c:	db400815 	stw	r13,32(sp)
 3221640:	db800915 	stw	r14,36(sp)
 3221644:	dbc00a15 	stw	r15,40(sp)
 3221648:	dc000b15 	stw	r16,44(sp)
 322164c:	dc400c15 	stw	r17,48(sp)
 3221650:	d8800d15 	stw	r2,52(sp)
 3221654:	e13fff17 	ldw	r4,-4(fp)
 3221658:	0140c974 	movhi	r5,805
 322165c:	2979d104 	addi	r5,r5,-6332
 3221660:	32079c00 	call	32079c0 <sprintf>
 3221664:	e0bffd15 	stw	r2,-12(fp)
 3221668:	00000806 	br	322168c <get_current_corners+0x1a4>
		     	         IORD_LOCATION_P6_X(sp->base), IORD_LOCATION_P6_Y(sp->base),
		     	         IORD_LOCATION_P7_X(sp->base), IORD_LOCATION_P7_Y(sp->base),
		     	         IORD_LOCATION_P8_X(sp->base), IORD_LOCATION_P8_Y(sp->base));
	}
	else {
		nchars = sprintf(char_buffer, "()");
 322166c:	e0ffff17 	ldw	r3,-4(fp)
 3221670:	00800a04 	movi	r2,40
 3221674:	18800005 	stb	r2,0(r3)
 3221678:	00800a44 	movi	r2,41
 322167c:	18800045 	stb	r2,1(r3)
 3221680:	18000085 	stb	zero,2(r3)
 3221684:	00800084 	movi	r2,2
 3221688:	e0bffd15 	stw	r2,-12(fp)
	}

	return nchars;
 322168c:	e0bffd17 	ldw	r2,-12(fp)
}
 3221690:	e037883a 	mov	sp,fp
 3221694:	dfc00317 	ldw	ra,12(sp)
 3221698:	df000217 	ldw	fp,8(sp)
 322169c:	dc400117 	ldw	r17,4(sp)
 32216a0:	dc000017 	ldw	r16,0(sp)
 32216a4:	dec00404 	addi	sp,sp,16
 32216a8:	f800283a 	ret

032216ac <set_search_window>:

/* Sets the search window of the locator device. */
int set_search_window(LOCATOR *sp, char *char_buffer, int x, int y, int width, int height)
{
 32216ac:	defff704 	addi	sp,sp,-36
 32216b0:	dfc00815 	stw	ra,32(sp)
 32216b4:	df000715 	stw	fp,28(sp)
 32216b8:	df000704 	addi	fp,sp,28
 32216bc:	e13ffc15 	stw	r4,-16(fp)
 32216c0:	e17ffd15 	stw	r5,-12(fp)
 32216c4:	e1bffe15 	stw	r6,-8(fp)
 32216c8:	e1ffff15 	stw	r7,-4(fp)
	IOWR_LOCATOR_X(sp->base, x);
 32216cc:	e0bffc17 	ldw	r2,-16(fp)
 32216d0:	10800017 	ldw	r2,0(r2)
 32216d4:	10800404 	addi	r2,r2,16
 32216d8:	1007883a 	mov	r3,r2
 32216dc:	e0bffe17 	ldw	r2,-8(fp)
 32216e0:	18800035 	stwio	r2,0(r3)
	IOWR_LOCATOR_Y(sp->base, y);
 32216e4:	e0bffc17 	ldw	r2,-16(fp)
 32216e8:	10800017 	ldw	r2,0(r2)
 32216ec:	10800604 	addi	r2,r2,24
 32216f0:	1007883a 	mov	r3,r2
 32216f4:	e0bfff17 	ldw	r2,-4(fp)
 32216f8:	18800035 	stwio	r2,0(r3)
	IOWR_LOCATOR_WIDTH(sp->base, width);
 32216fc:	e0bffc17 	ldw	r2,-16(fp)
 3221700:	10800017 	ldw	r2,0(r2)
 3221704:	10800804 	addi	r2,r2,32
 3221708:	1007883a 	mov	r3,r2
 322170c:	e0800217 	ldw	r2,8(fp)
 3221710:	18800035 	stwio	r2,0(r3)
	IOWR_LOCATOR_HEIGHT(sp->base, height);
 3221714:	e0bffc17 	ldw	r2,-16(fp)
 3221718:	10800017 	ldw	r2,0(r2)
 322171c:	10800a04 	addi	r2,r2,40
 3221720:	1007883a 	mov	r3,r2
 3221724:	e0800317 	ldw	r2,12(fp)
 3221728:	18800035 	stwio	r2,0(r3)
	IOWR_LOCATOR_SW(sp->base, 1);
 322172c:	e0bffc17 	ldw	r2,-16(fp)
 3221730:	10800017 	ldw	r2,0(r2)
 3221734:	10800304 	addi	r2,r2,12
 3221738:	1007883a 	mov	r3,r2
 322173c:	00800044 	movi	r2,1
 3221740:	18800035 	stwio	r2,0(r3)
	IOWR_LOCATOR_SW(sp->base, 0);
 3221744:	e0bffc17 	ldw	r2,-16(fp)
 3221748:	10800017 	ldw	r2,0(r2)
 322174c:	10800304 	addi	r2,r2,12
 3221750:	10000035 	stwio	zero,0(r2)
	IOWR_LOCATOR_ENABLE(sp->base);
 3221754:	e0bffc17 	ldw	r2,-16(fp)
 3221758:	10800017 	ldw	r2,0(r2)
 322175c:	1007883a 	mov	r3,r2
 3221760:	00800044 	movi	r2,1
 3221764:	18800035 	stwio	r2,0(r3)

	int nchars = 0;
 3221768:	e03ffb15 	stw	zero,-20(fp)
	nchars = sprintf(char_buffer, "(%i,%i,%i,%i)", x, y, width, height);
 322176c:	e0800217 	ldw	r2,8(fp)
 3221770:	d8800015 	stw	r2,0(sp)
 3221774:	e0800317 	ldw	r2,12(fp)
 3221778:	d8800115 	stw	r2,4(sp)
 322177c:	e13ffd17 	ldw	r4,-12(fp)
 3221780:	0140c974 	movhi	r5,805
 3221784:	2979e204 	addi	r5,r5,-6264
 3221788:	e1bffe17 	ldw	r6,-8(fp)
 322178c:	e1ffff17 	ldw	r7,-4(fp)
 3221790:	32079c00 	call	32079c0 <sprintf>
 3221794:	e0bffb15 	stw	r2,-20(fp)
	return nchars;
 3221798:	e0bffb17 	ldw	r2,-20(fp)
}
 322179c:	e037883a 	mov	sp,fp
 32217a0:	dfc00117 	ldw	ra,4(sp)
 32217a4:	df000017 	ldw	fp,0(sp)
 32217a8:	dec00204 	addi	sp,sp,8
 32217ac:	f800283a 	ret

032217b0 <get_search_window>:

/* Gets the search window of the locator device. */
int get_search_window(LOCATOR *sp, char *char_buffer)
{
 32217b0:	defff504 	addi	sp,sp,-44
 32217b4:	dfc00a15 	stw	ra,40(sp)
 32217b8:	df000915 	stw	fp,36(sp)
 32217bc:	df000904 	addi	fp,sp,36
 32217c0:	e13ffe15 	stw	r4,-8(fp)
 32217c4:	e17fff15 	stw	r5,-4(fp)
	int x = IORD_LOCATOR_X(sp->base);
 32217c8:	e0bffe17 	ldw	r2,-8(fp)
 32217cc:	10800017 	ldw	r2,0(r2)
 32217d0:	10800404 	addi	r2,r2,16
 32217d4:	10800037 	ldwio	r2,0(r2)
 32217d8:	e0bffd15 	stw	r2,-12(fp)
	int y = IORD_LOCATOR_Y(sp->base);
 32217dc:	e0bffe17 	ldw	r2,-8(fp)
 32217e0:	10800017 	ldw	r2,0(r2)
 32217e4:	10800604 	addi	r2,r2,24
 32217e8:	10800037 	ldwio	r2,0(r2)
 32217ec:	e0bffc15 	stw	r2,-16(fp)
	int width = IORD_LOCATOR_WIDTH(sp->base);
 32217f0:	e0bffe17 	ldw	r2,-8(fp)
 32217f4:	10800017 	ldw	r2,0(r2)
 32217f8:	10800804 	addi	r2,r2,32
 32217fc:	10800037 	ldwio	r2,0(r2)
 3221800:	e0bffb15 	stw	r2,-20(fp)
	int height = IORD_LOCATOR_HEIGHT(sp->base);
 3221804:	e0bffe17 	ldw	r2,-8(fp)
 3221808:	10800017 	ldw	r2,0(r2)
 322180c:	10800a04 	addi	r2,r2,40
 3221810:	10800037 	ldwio	r2,0(r2)
 3221814:	e0bffa15 	stw	r2,-24(fp)

	int nchars = 0;
 3221818:	e03ff915 	stw	zero,-28(fp)
	nchars = sprintf(char_buffer, "((%i,%i),(%i,%i))", x, y, width, height);
 322181c:	e0bffb17 	ldw	r2,-20(fp)
 3221820:	d8800015 	stw	r2,0(sp)
 3221824:	e0bffa17 	ldw	r2,-24(fp)
 3221828:	d8800115 	stw	r2,4(sp)
 322182c:	e13fff17 	ldw	r4,-4(fp)
 3221830:	0140c974 	movhi	r5,805
 3221834:	2979e604 	addi	r5,r5,-6248
 3221838:	e1bffd17 	ldw	r6,-12(fp)
 322183c:	e1fffc17 	ldw	r7,-16(fp)
 3221840:	32079c00 	call	32079c0 <sprintf>
 3221844:	e0bff915 	stw	r2,-28(fp)

	return nchars;
 3221848:	e0bff917 	ldw	r2,-28(fp)
}
 322184c:	e037883a 	mov	sp,fp
 3221850:	dfc00117 	ldw	ra,4(sp)
 3221854:	df000017 	ldw	fp,0(sp)
 3221858:	dec00204 	addi	sp,sp,8
 322185c:	f800283a 	ret

03221860 <eth_ocm_prep>:
 * Prepare ethernet MAC.
 *
 * @param ins_dev   Pointer to associated alt_iniche_dev struct
 * @return
 */
error_t eth_ocm_prep(alt_iniche_dev *ins_dev){
 3221860:	defff904 	addi	sp,sp,-28
 3221864:	dfc00615 	stw	ra,24(sp)
 3221868:	df000515 	stw	fp,20(sp)
 322186c:	dc000415 	stw	r16,16(sp)
 3221870:	df000404 	addi	fp,sp,16
 3221874:	e13fff15 	stw	r4,-4(fp)
    NET ifp;
    int index;
    eth_ocm_dev *dev;

    index = ins_dev->if_num;
 3221878:	e0bfff17 	ldw	r2,-4(fp)
 322187c:	10800517 	ldw	r2,20(r2)
 3221880:	e0bffd15 	stw	r2,-12(fp)
    dev = (eth_ocm_dev *)ins_dev;
 3221884:	e0bfff17 	ldw	r2,-4(fp)
 3221888:	e0bffc15 	stw	r2,-16(fp)
    //Status message
    dprintf("eth_ocm_prep\n");
    #endif // if ETH_OCM_DBG_LVL

    //create eth_ocm_info struct
    dev->info = (eth_ocm_info *)malloc(sizeof(eth_ocm_info));
 322188c:	01001004 	movi	r4,64
 3221890:	324bcac0 	call	324bcac <malloc>
 3221894:	1007883a 	mov	r3,r2
 3221898:	e0bffc17 	ldw	r2,-16(fp)
 322189c:	10c01115 	stw	r3,68(r2)
    dev->info->sem = 0; //initialize semaphore
 32218a0:	e0bffc17 	ldw	r2,-16(fp)
 32218a4:	10801117 	ldw	r2,68(r2)
 32218a8:	10000305 	stb	zero,12(r2)
    dev->info->rx_pkts = (PACKET *)(malloc(sizeof(PACKET) * ETH_OCM_RX_DESC_COUNT));
 32218ac:	e0bffc17 	ldw	r2,-16(fp)
 32218b0:	14001117 	ldw	r16,68(r2)
 32218b4:	01000104 	movi	r4,4
 32218b8:	324bcac0 	call	324bcac <malloc>
 32218bc:	80800415 	stw	r2,16(r16)


    ifp = nets[index];
 32218c0:	e0bffd17 	ldw	r2,-12(fp)
 32218c4:	00c0c9b4 	movhi	r3,806
 32218c8:	18f34504 	addi	r3,r3,-13036
 32218cc:	1085883a 	add	r2,r2,r2
 32218d0:	1085883a 	add	r2,r2,r2
 32218d4:	10c5883a 	add	r2,r2,r3
 32218d8:	10800017 	ldw	r2,0(r2)
 32218dc:	e0bffe15 	stw	r2,-8(fp)
    ifp->n_mib->ifAdminStatus = ETH_OCM_STATUS_DOWN;    
 32218e0:	e0bffe17 	ldw	r2,-8(fp)
 32218e4:	10c02717 	ldw	r3,156(r2)
 32218e8:	00800084 	movi	r2,2
 32218ec:	18800615 	stw	r2,24(r3)
    ifp->n_mib->ifOperStatus =  ETH_OCM_STATUS_DOWN;
 32218f0:	e0bffe17 	ldw	r2,-8(fp)
 32218f4:	10c02717 	ldw	r3,156(r2)
 32218f8:	00800084 	movi	r2,2
 32218fc:	18800715 	stw	r2,28(r3)
    ifp->n_mib->ifLastChange =  cticks * (100/TPS);     //timestamp
 3221900:	e0bffe17 	ldw	r2,-8(fp)
 3221904:	10802717 	ldw	r2,156(r2)
 3221908:	10000815 	stw	zero,32(r2)
    ifp->n_mib->ifPhysAddress = (u_char*)dev->info->mac_addr;
 322190c:	e0bffe17 	ldw	r2,-8(fp)
 3221910:	10c02717 	ldw	r3,156(r2)
 3221914:	e0bffc17 	ldw	r2,-16(fp)
 3221918:	10801117 	ldw	r2,68(r2)
 322191c:	18800515 	stw	r2,20(r3)
    ifp->n_mib->ifDescr =       (u_char*)"Opencores 10/100 ethernet MAC";
 3221920:	e0bffe17 	ldw	r2,-8(fp)
 3221924:	10c02717 	ldw	r3,156(r2)
 3221928:	0080c974 	movhi	r2,805
 322192c:	10b9eb04 	addi	r2,r2,-6228
 3221930:	18800115 	stw	r2,4(r3)
    ifp->n_lnh =                ETHHDR_SIZE;            /* ethernet header size. */
 3221934:	e0fffe17 	ldw	r3,-8(fp)
 3221938:	00800404 	movi	r2,16
 322193c:	18800815 	stw	r2,32(r3)
    ifp->n_hal =                ETH_OCM_MAC_ADDR_LEN;   /* MAC address length */
 3221940:	e0fffe17 	ldw	r3,-8(fp)
 3221944:	00800184 	movi	r2,6
 3221948:	18801115 	stw	r2,68(r3)
    ifp->n_mib->ifType =        ETHERNET;               /* device type */
 322194c:	e0bffe17 	ldw	r2,-8(fp)
 3221950:	10c02717 	ldw	r3,156(r2)
 3221954:	00800184 	movi	r2,6
 3221958:	18800215 	stw	r2,8(r3)
    ifp->n_mtu =                ETH_OCM_MAX_MTU;        /* max frame size */
 322195c:	e0fffe17 	ldw	r3,-8(fp)
 3221960:	00817b84 	movi	r2,1518
 3221964:	18800915 	stw	r2,36(r3)

    /* install our hardware driver routines */
    ifp->n_init =       eth_ocm_init;
 3221968:	e0fffe17 	ldw	r3,-8(fp)
 322196c:	0080c8b4 	movhi	r2,802
 3221970:	10868704 	addi	r2,r2,6684
 3221974:	18800215 	stw	r2,8(r3)
    #ifndef ETH_OCM_SYNC_TX
    ifp->pkt_send =     eth_ocm_pkt_send;
 3221978:	e0fffe17 	ldw	r3,-8(fp)
 322197c:	0080c8b4 	movhi	r2,802
 3221980:	10876c04 	addi	r2,r2,7600
 3221984:	18800415 	stw	r2,16(r3)
    ifp->raw_send =     NULL;
 3221988:	e0bffe17 	ldw	r2,-8(fp)
 322198c:	10000315 	stw	zero,12(r2)
    #else
    ifp->pkt_send =     NULL;
    ifp->raw_send =     eth_ocm_raw_send;
    #endif // ifndef ETH_OCM_SYNC_TX
    ifp->n_close =      eth_ocm_close;
 3221990:	e0fffe17 	ldw	r3,-8(fp)
 3221994:	0080c8b4 	movhi	r2,802
 3221998:	108a9604 	addi	r2,r2,10840
 322199c:	18800515 	stw	r2,20(r3)
    ifp->n_stats =      eth_ocm_stats;
 32219a0:	e0fffe17 	ldw	r3,-8(fp)
 32219a4:	0080c8b4 	movhi	r2,802
 32219a8:	108a3b04 	addi	r2,r2,10476
 32219ac:	18800715 	stw	r2,28(r3)

#ifdef IP_V6
      ifp->n_flags |= (NF_NBPROT | NF_IPV6);
#else
      ifp->n_flags |= NF_NBPROT;
 32219b0:	e0bffe17 	ldw	r2,-8(fp)
 32219b4:	10802a17 	ldw	r2,168(r2)
 32219b8:	10c00214 	ori	r3,r2,8
 32219bc:	e0bffe17 	ldw	r2,-8(fp)
 32219c0:	10c02a15 	stw	r3,168(r2)
#endif

    /* set cross-pointers between iface and eth_ocm structs */
    dev->info->netp = ifp;
 32219c4:	e0bffc17 	ldw	r2,-16(fp)
 32219c8:	10c01117 	ldw	r3,68(r2)
 32219cc:	e0bffe17 	ldw	r2,-8(fp)
 32219d0:	18800215 	stw	r2,8(r3)
    ifp->n_local = (void*)(dev);
 32219d4:	e0fffe17 	ldw	r3,-8(fp)
 32219d8:	e0bffc17 	ldw	r2,-16(fp)
 32219dc:	18802815 	stw	r2,160(r3)

    /* get the MAC address. */
    get_mac_addr(ifp, dev->info->mac_addr);
 32219e0:	e0bffc17 	ldw	r2,-16(fp)
 32219e4:	10801117 	ldw	r2,68(r2)
 32219e8:	100b883a 	mov	r5,r2
 32219ec:	e13ffe17 	ldw	r4,-8(fp)
 32219f0:	32017fc0 	call	32017fc <get_mac_addr>

    index++;
 32219f4:	e0bffd17 	ldw	r2,-12(fp)
 32219f8:	10800044 	addi	r2,r2,1
 32219fc:	e0bffd15 	stw	r2,-12(fp)
    return index;
 3221a00:	e0bffd17 	ldw	r2,-12(fp)
}
 3221a04:	e037883a 	mov	sp,fp
 3221a08:	dfc00217 	ldw	ra,8(sp)
 3221a0c:	df000117 	ldw	fp,4(sp)
 3221a10:	dc000017 	ldw	r16,0(sp)
 3221a14:	dec00304 	addi	sp,sp,12
 3221a18:	f800283a 	ret

03221a1c <eth_ocm_init>:
/**
 * Initializes the Opencores ethernet MAC. Called by InterNiche stack
 *
 * @param 
 */
int eth_ocm_init(int iface){
 3221a1c:	defff604 	addi	sp,sp,-40
 3221a20:	dfc00915 	stw	ra,36(sp)
 3221a24:	df000815 	stw	fp,32(sp)
 3221a28:	df000804 	addi	fp,sp,32
 3221a2c:	e13fff15 	stw	r4,-4(fp)
    int status = SUCCESS;
 3221a30:	e03ffe15 	stw	zero,-8(fp)

    #if (ETH_OCM_DBG_LVL >= 1)
    dprintf("[eth_ocm_init]\n");
    #endif
    //get the ifp first
    ifp = nets[iface];
 3221a34:	e0bfff17 	ldw	r2,-4(fp)
 3221a38:	00c0c9b4 	movhi	r3,806
 3221a3c:	18f34504 	addi	r3,r3,-13036
 3221a40:	1085883a 	add	r2,r2,r2
 3221a44:	1085883a 	add	r2,r2,r2
 3221a48:	10c5883a 	add	r2,r2,r3
 3221a4c:	10800017 	ldw	r2,0(r2)
 3221a50:	e0bffb15 	stw	r2,-20(fp)
    //now get the info pointer
    dev = (eth_ocm_dev *)ifp->n_local;
 3221a54:	e0bffb17 	ldw	r2,-20(fp)
 3221a58:	10802817 	ldw	r2,160(r2)
 3221a5c:	e0bffa15 	stw	r2,-24(fp)
    info = dev->info;
 3221a60:	e0bffa17 	ldw	r2,-24(fp)
 3221a64:	10801117 	ldw	r2,68(r2)
 3221a68:	e0bff915 	stw	r2,-28(fp)
    regs = dev->regs;
 3221a6c:	e0bffa17 	ldw	r2,-24(fp)
 3221a70:	10800a17 	ldw	r2,40(r2)
 3221a74:	e0bff815 	stw	r2,-32(fp)

    //Reset Descriptors (supposedly this can be done while in reset)
    for(temp=ETH_OCM_DESC_START;temp<ETH_OCM_DESC_END;temp++)
 3221a78:	00804004 	movi	r2,256
 3221a7c:	e0bffc15 	stw	r2,-16(fp)
 3221a80:	00000b06 	br	3221ab0 <eth_ocm_init+0x94>
        IOWR(dev->base, temp, 0);
 3221a84:	e0bffa17 	ldw	r2,-24(fp)
 3221a88:	10800717 	ldw	r2,28(r2)
 3221a8c:	1007883a 	mov	r3,r2
 3221a90:	e0bffc17 	ldw	r2,-16(fp)
 3221a94:	1085883a 	add	r2,r2,r2
 3221a98:	1085883a 	add	r2,r2,r2
 3221a9c:	1885883a 	add	r2,r3,r2
 3221aa0:	10000035 	stwio	zero,0(r2)
    dev = (eth_ocm_dev *)ifp->n_local;
    info = dev->info;
    regs = dev->regs;

    //Reset Descriptors (supposedly this can be done while in reset)
    for(temp=ETH_OCM_DESC_START;temp<ETH_OCM_DESC_END;temp++)
 3221aa4:	e0bffc17 	ldw	r2,-16(fp)
 3221aa8:	10800044 	addi	r2,r2,1
 3221aac:	e0bffc15 	stw	r2,-16(fp)
 3221ab0:	e0bffc17 	ldw	r2,-16(fp)
 3221ab4:	10807fd0 	cmplti	r2,r2,511
 3221ab8:	103ff21e 	bne	r2,zero,3221a84 <eth_ocm_init+0x68>
        IOWR(dev->base, temp, 0);

    //Let's disable the MAC until everything else is set up
    regs->moder = 0;
 3221abc:	e0bff817 	ldw	r2,-32(fp)
 3221ac0:	10000015 	stw	zero,0(r2)

    //Determine the number of RX descriptors
    regs->tx_bd_num = ETH_OCM_TX_DESC_COUNT; //Set TX descriptor count in MAC    
 3221ac4:	e0fff817 	ldw	r3,-32(fp)
 3221ac8:	00800044 	movi	r2,1
 3221acc:	18800815 	stw	r2,32(r3)
    info->cur_tx_desc = 0;
 3221ad0:	e0bff917 	ldw	r2,-28(fp)
 3221ad4:	10000345 	stb	zero,13(r2)
    info->cur_rx_desc = 0;
 3221ad8:	e0bff917 	ldw	r2,-28(fp)
 3221adc:	10000385 	stb	zero,14(r2)
    #ifndef ETH_OCM_SYNC_TX
    info->next_tx_desc = 0;
 3221ae0:	e0bff917 	ldw	r2,-28(fp)
 3221ae4:	10000f05 	stb	zero,60(r2)
    info->next_tx_desc_rdy = 1;
 3221ae8:	e0fff917 	ldw	r3,-28(fp)
 3221aec:	00800044 	movi	r2,1
 3221af0:	18800f45 	stb	r2,61(r3)
    //Initialize queues
    dev->info->tosend.q_head = dev->info->tosend.q_tail = NULL;
 3221af4:	e0bffa17 	ldw	r2,-24(fp)
 3221af8:	10c01117 	ldw	r3,68(r2)
 3221afc:	e0bffa17 	ldw	r2,-24(fp)
 3221b00:	10801117 	ldw	r2,68(r2)
 3221b04:	10000615 	stw	zero,24(r2)
 3221b08:	10800617 	ldw	r2,24(r2)
 3221b0c:	18800515 	stw	r2,20(r3)
    dev->info->tosend.q_max = dev->info->tosend.q_min = dev->info->tosend.q_len = 0;
 3221b10:	e0bffa17 	ldw	r2,-24(fp)
 3221b14:	11001117 	ldw	r4,68(r2)
 3221b18:	e0bffa17 	ldw	r2,-24(fp)
 3221b1c:	10c01117 	ldw	r3,68(r2)
 3221b20:	e0bffa17 	ldw	r2,-24(fp)
 3221b24:	10801117 	ldw	r2,68(r2)
 3221b28:	10000715 	stw	zero,28(r2)
 3221b2c:	10800717 	ldw	r2,28(r2)
 3221b30:	18800915 	stw	r2,36(r3)
 3221b34:	18800917 	ldw	r2,36(r3)
 3221b38:	20800815 	stw	r2,32(r4)
    dev->info->sending.q_head = dev->info->sending.q_tail = NULL;
 3221b3c:	e0bffa17 	ldw	r2,-24(fp)
 3221b40:	10c01117 	ldw	r3,68(r2)
 3221b44:	e0bffa17 	ldw	r2,-24(fp)
 3221b48:	10801117 	ldw	r2,68(r2)
 3221b4c:	10000b15 	stw	zero,44(r2)
 3221b50:	10800b17 	ldw	r2,44(r2)
 3221b54:	18800a15 	stw	r2,40(r3)
    dev->info->sending.q_max = dev->info->sending.q_min = dev->info->sending.q_len = 0;
 3221b58:	e0bffa17 	ldw	r2,-24(fp)
 3221b5c:	11001117 	ldw	r4,68(r2)
 3221b60:	e0bffa17 	ldw	r2,-24(fp)
 3221b64:	10c01117 	ldw	r3,68(r2)
 3221b68:	e0bffa17 	ldw	r2,-24(fp)
 3221b6c:	10801117 	ldw	r2,68(r2)
 3221b70:	10000c15 	stw	zero,48(r2)
 3221b74:	10800c17 	ldw	r2,48(r2)
 3221b78:	18800e15 	stw	r2,56(r3)
 3221b7c:	18800e17 	ldw	r2,56(r3)
 3221b80:	20800d15 	stw	r2,52(r4)
    #endif

    /* perform any necessary PHY setup */
    //Let's set the MDIO interface up to run at 4MHz.
    temp = dev->clk_div;
 3221b84:	e0bffa17 	ldw	r2,-24(fp)
 3221b88:	10800917 	ldw	r2,36(r2)
 3221b8c:	e0bffc15 	stw	r2,-16(fp)
    if(temp < 2)
 3221b90:	e0bffc17 	ldw	r2,-16(fp)
 3221b94:	10800088 	cmpgei	r2,r2,2
 3221b98:	1000021e 	bne	r2,zero,3221ba4 <eth_ocm_init+0x188>
        temp = 2;
 3221b9c:	00800084 	movi	r2,2
 3221ba0:	e0bffc15 	stw	r2,-16(fp)
    temp += 1;
 3221ba4:	e0bffc17 	ldw	r2,-16(fp)
 3221ba8:	10800044 	addi	r2,r2,1
 3221bac:	e0bffc15 	stw	r2,-16(fp)
    temp &= 0xFFFFFFFE;   //only even numbers allowed
 3221bb0:	e0fffc17 	ldw	r3,-16(fp)
 3221bb4:	00bfff84 	movi	r2,-2
 3221bb8:	1884703a 	and	r2,r3,r2
 3221bbc:	e0bffc15 	stw	r2,-16(fp)
    regs->miimoder = temp;
 3221bc0:	e0fffc17 	ldw	r3,-16(fp)
 3221bc4:	e0bff817 	ldw	r2,-32(fp)
 3221bc8:	10c00a15 	stw	r3,40(r2)
    regs->miicommand = 0;
 3221bcc:	e0bff817 	ldw	r2,-32(fp)
 3221bd0:	10000b15 	stw	zero,44(r2)
    //Find out if we should run in duplex or not
    duplex = eth_ocm_phy_init(dev);
 3221bd4:	e13ffa17 	ldw	r4,-24(fp)
 3221bd8:	323c4a40 	call	323c4a4 <eth_ocm_phy_init>
 3221bdc:	e0bffd15 	stw	r2,-12(fp)

    if(duplex)
 3221be0:	e0bffd17 	ldw	r2,-12(fp)
 3221be4:	1005003a 	cmpeq	r2,r2,zero
 3221be8:	1000021e 	bne	r2,zero,3221bf4 <eth_ocm_init+0x1d8>
        duplex = ETH_OCM_MODER_FULLD_MSK;
 3221bec:	00810004 	movi	r2,1024
 3221bf0:	e0bffd15 	stw	r2,-12(fp)

    // Configure MAC options
    // Interrupt sources
    regs->int_mask = ETH_OCM_DEFAULT_INTERRUPT_MASK; //Interrupt on receive
 3221bf4:	e0fff817 	ldw	r3,-32(fp)
 3221bf8:	008007c4 	movi	r2,31
 3221bfc:	18800215 	stw	r2,8(r3)
    // Clear any existing interrupts
    regs->int_source = 0xFFFFFFFF;
 3221c00:	e0fff817 	ldw	r3,-32(fp)
 3221c04:	00bfffc4 	movi	r2,-1
 3221c08:	18800115 	stw	r2,4(r3)

    // Inter-packet gap 
    if(duplex)
 3221c0c:	e0bffd17 	ldw	r2,-12(fp)
 3221c10:	1005003a 	cmpeq	r2,r2,zero
 3221c14:	1000041e 	bne	r2,zero,3221c28 <eth_ocm_init+0x20c>
        regs->ipgt = ETH_OCM_FULL_DUPLEX_IPGT; 
 3221c18:	e0fff817 	ldw	r3,-32(fp)
 3221c1c:	00800544 	movi	r2,21
 3221c20:	18800315 	stw	r2,12(r3)
 3221c24:	00000306 	br	3221c34 <eth_ocm_init+0x218>
    else
        regs->ipgt = ETH_OCM_HALF_DUPLEX_IPGT;
 3221c28:	e0fff817 	ldw	r3,-32(fp)
 3221c2c:	00800484 	movi	r2,18
 3221c30:	18800315 	stw	r2,12(r3)

    //Let's set the defaults just because they've bitten us before
    regs->ipgr2     = 0x0000000C;
 3221c34:	e0fff817 	ldw	r3,-32(fp)
 3221c38:	00800304 	movi	r2,12
 3221c3c:	18800515 	stw	r2,20(r3)
    regs->ipgr2     = 0x00000012;
 3221c40:	e0fff817 	ldw	r3,-32(fp)
 3221c44:	00800484 	movi	r2,18
 3221c48:	18800515 	stw	r2,20(r3)
    regs->packetlen = 0x00400600;  //Min and Max frame sizes
 3221c4c:	e0fff817 	ldw	r3,-32(fp)
 3221c50:	00801034 	movhi	r2,64
 3221c54:	10818004 	addi	r2,r2,1536
 3221c58:	18800615 	stw	r2,24(r3)
    regs->collconf  = 0x000F003F;
 3221c5c:	e0fff817 	ldw	r3,-32(fp)
 3221c60:	008003f4 	movhi	r2,15
 3221c64:	10800fc4 	addi	r2,r2,63
 3221c68:	18800715 	stw	r2,28(r3)
    regs->ctrlmoder = 0x00000000;
 3221c6c:	e0bff817 	ldw	r2,-32(fp)
 3221c70:	10000915 	stw	zero,36(r2)
            "%02x:%02x:%02x:%02x:%02x:%02x\n",
            info->mac_addr[0],info->mac_addr[1],info->mac_addr[2],
            info->mac_addr[3],info->mac_addr[4],info->mac_addr[5]);
    #endif // if ETH_OCM_DBG_LVL
    //Configure the MAC address
    regs->mac_addr0 =
 3221c74:	e0bff917 	ldw	r2,-28(fp)
 3221c78:	10800143 	ldbu	r2,5(r2)
 3221c7c:	10c03fcc 	andi	r3,r2,255
 3221c80:	e0bff917 	ldw	r2,-28(fp)
 3221c84:	10800103 	ldbu	r2,4(r2)
 3221c88:	10803fcc 	andi	r2,r2,255
 3221c8c:	1004923a 	slli	r2,r2,8
 3221c90:	1886b03a 	or	r3,r3,r2
 3221c94:	e0bff917 	ldw	r2,-28(fp)
 3221c98:	108000c3 	ldbu	r2,3(r2)
 3221c9c:	10803fcc 	andi	r2,r2,255
 3221ca0:	1004943a 	slli	r2,r2,16
 3221ca4:	1886b03a 	or	r3,r3,r2
 3221ca8:	e0bff917 	ldw	r2,-28(fp)
 3221cac:	10800083 	ldbu	r2,2(r2)
 3221cb0:	10803fcc 	andi	r2,r2,255
 3221cb4:	1004963a 	slli	r2,r2,24
 3221cb8:	1884b03a 	or	r2,r3,r2
 3221cbc:	1007883a 	mov	r3,r2
 3221cc0:	e0bff817 	ldw	r2,-32(fp)
 3221cc4:	10c01015 	stw	r3,64(r2)
            ( ((int)info->mac_addr[5])         |
             (((int)info->mac_addr[4]) << 8)   |
             (((int)info->mac_addr[3]) << 16)  |
             (((int)info->mac_addr[2]) << 24)  );

    regs->mac_addr1 =
 3221cc8:	e0bff917 	ldw	r2,-28(fp)
 3221ccc:	10800043 	ldbu	r2,1(r2)
 3221cd0:	10c03fcc 	andi	r3,r2,255
 3221cd4:	e0bff917 	ldw	r2,-28(fp)
 3221cd8:	10800003 	ldbu	r2,0(r2)
 3221cdc:	10803fcc 	andi	r2,r2,255
 3221ce0:	1004923a 	slli	r2,r2,8
 3221ce4:	1884b03a 	or	r2,r3,r2
 3221ce8:	1007883a 	mov	r3,r2
 3221cec:	e0bff817 	ldw	r2,-32(fp)
 3221cf0:	10c01115 	stw	r3,68(r2)
            ( ((int)((unsigned char)info->mac_addr[1]))         |
             (((int)((unsigned char)info->mac_addr[0])) << 8)   );


    //Enable MAC
    regs->moder = (
 3221cf4:	e0bffd17 	ldw	r2,-12(fp)
 3221cf8:	10a800d4 	ori	r2,r2,40963
 3221cfc:	1007883a 	mov	r3,r2
 3221d00:	e0bff817 	ldw	r2,-32(fp)
 3221d04:	10c00015 	stw	r3,0(r2)
    #if (ETH_OCM_DBG_LVL >= 1)
    dprintf("\nOpencores MAC post-init: MODER = 0x%08x\n", (int)regs->moder);
    #endif // if ETH_OCM_DBG

   /* status = UP */
   nets[iface]->n_mib->ifAdminStatus = ETH_OCM_STATUS_UP;
 3221d08:	e0bfff17 	ldw	r2,-4(fp)
 3221d0c:	00c0c9b4 	movhi	r3,806
 3221d10:	18f34504 	addi	r3,r3,-13036
 3221d14:	1085883a 	add	r2,r2,r2
 3221d18:	1085883a 	add	r2,r2,r2
 3221d1c:	10c5883a 	add	r2,r2,r3
 3221d20:	10800017 	ldw	r2,0(r2)
 3221d24:	10c02717 	ldw	r3,156(r2)
 3221d28:	00800044 	movi	r2,1
 3221d2c:	18800615 	stw	r2,24(r3)
   nets[iface]->n_mib->ifOperStatus = ETH_OCM_STATUS_UP;
 3221d30:	e0bfff17 	ldw	r2,-4(fp)
 3221d34:	00c0c9b4 	movhi	r3,806
 3221d38:	18f34504 	addi	r3,r3,-13036
 3221d3c:	1085883a 	add	r2,r2,r2
 3221d40:	1085883a 	add	r2,r2,r2
 3221d44:	10c5883a 	add	r2,r2,r3
 3221d48:	10800017 	ldw	r2,0(r2)
 3221d4c:	10c02717 	ldw	r3,156(r2)
 3221d50:	00800044 	movi	r2,1
 3221d54:	18800715 	stw	r2,28(r3)

   //register ISR interrupt handler
   temp = alt_irq_register(dev->irq, dev, eth_ocm_isr);
 3221d58:	e0bffa17 	ldw	r2,-24(fp)
 3221d5c:	10800b03 	ldbu	r2,44(r2)
 3221d60:	11003fcc 	andi	r4,r2,255
 3221d64:	e17ffa17 	ldw	r5,-24(fp)
 3221d68:	0180c8b4 	movhi	r6,802
 3221d6c:	3188b004 	addi	r6,r6,8896
 3221d70:	323ac6c0 	call	323ac6c <alt_irq_register>
 3221d74:	e0bffc15 	stw	r2,-16(fp)
   if(temp)
 3221d78:	e0bffc17 	ldw	r2,-16(fp)
 3221d7c:	1005003a 	cmpeq	r2,r2,zero
 3221d80:	1000031e 	bne	r2,zero,3221d90 <eth_ocm_init+0x374>
       dprintf("[eth_ocm_init] Failed to register RX ISR\n");
 3221d84:	0100c974 	movhi	r4,805
 3221d88:	2139f304 	addi	r4,r4,-6196
 3221d8c:	32071080 	call	3207108 <puts>
   //Setup the first read transfer
   eth_ocm_read_init(dev);
 3221d90:	e13ffa17 	ldw	r4,-24(fp)
 3221d94:	32223b40 	call	32223b4 <eth_ocm_read_init>

   return status;   //MAC is ready to rock and roll
 3221d98:	e0bffe17 	ldw	r2,-8(fp)
}
 3221d9c:	e037883a 	mov	sp,fp
 3221da0:	dfc00117 	ldw	ra,4(sp)
 3221da4:	df000017 	ldw	fp,0(sp)
 3221da8:	dec00204 	addi	sp,sp,8
 3221dac:	f800283a 	ret

03221db0 <eth_ocm_pkt_send>:
//End of eth_ocm_init function


#ifndef ETH_OCM_SYNC_TX
int eth_ocm_pkt_send(PACKET pkt){
 3221db0:	defff604 	addi	sp,sp,-40
 3221db4:	dfc00915 	stw	ra,36(sp)
 3221db8:	df000815 	stw	fp,32(sp)
 3221dbc:	df000804 	addi	fp,sp,32
 3221dc0:	e13fff15 	stw	r4,-4(fp)
    int result;
#ifdef UCOS_II
    int cpu_sr;
#endif

    dev = (eth_ocm_dev *)pkt->net->n_local;
 3221dc4:	e0bfff17 	ldw	r2,-4(fp)
 3221dc8:	10800617 	ldw	r2,24(r2)
 3221dcc:	10802817 	ldw	r2,160(r2)
 3221dd0:	e0bffe15 	stw	r2,-8(fp)
    info = dev->info;
 3221dd4:	e0bffe17 	ldw	r2,-8(fp)
 3221dd8:	10801117 	ldw	r2,68(r2)
 3221ddc:	e0bffd15 	stw	r2,-12(fp)
    regs = dev->regs;
 3221de0:	e0bffe17 	ldw	r2,-8(fp)
 3221de4:	10800a17 	ldw	r2,40(r2)
 3221de8:	e0bffc15 	stw	r2,-16(fp)
    result = SUCCESS;
 3221dec:	e03ffb15 	stw	zero,-20(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 3221df0:	0005303a 	rdctl	r2,status
 3221df4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 3221df8:	e0fff917 	ldw	r3,-28(fp)
 3221dfc:	00bfff84 	movi	r2,-2
 3221e00:	1884703a 	and	r2,r3,r2
 3221e04:	1001703a 	wrctl	status,r2
  
  return context;
 3221e08:	e0bff917 	ldw	r2,-28(fp)

    OS_ENTER_CRITICAL();    //disable interrupts
 3221e0c:	e0bffa15 	stw	r2,-24(fp)

    putq(&info->tosend, (qp)pkt);
 3221e10:	e0bffd17 	ldw	r2,-12(fp)
 3221e14:	11000504 	addi	r4,r2,20
 3221e18:	e17fff17 	ldw	r5,-4(fp)
 3221e1c:	322a8800 	call	322a880 <putq>
    eth_ocm_tx_isr(dev);
 3221e20:	e13ffe17 	ldw	r4,-8(fp)
 3221e24:	32220040 	call	3222004 <eth_ocm_tx_isr>
 3221e28:	e0bffa17 	ldw	r2,-24(fp)
 3221e2c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 3221e30:	e0bff817 	ldw	r2,-32(fp)
 3221e34:	1001703a 	wrctl	status,r2
        putq(&info->tosend, (qp)pkt);
    }
    */

    OS_EXIT_CRITICAL();     //reenable interrupts
    return SUCCESS;
 3221e38:	0005883a 	mov	r2,zero
}
 3221e3c:	e037883a 	mov	sp,fp
 3221e40:	dfc00117 	ldw	ra,4(sp)
 3221e44:	df000017 	ldw	fp,0(sp)
 3221e48:	dec00204 	addi	sp,sp,8
 3221e4c:	f800283a 	ret

03221e50 <eth_ocm_low_send>:
 *  @param data
 *  @param data_bytes
 *
 *  @return 0 if Successful, negative otherwise
 */
int eth_ocm_low_send(NET net, char *data, unsigned data_bytes){
 3221e50:	defff404 	addi	sp,sp,-48
 3221e54:	dfc00b15 	stw	ra,44(sp)
 3221e58:	df000a15 	stw	fp,40(sp)
 3221e5c:	df000a04 	addi	fp,sp,40
 3221e60:	e13ffc15 	stw	r4,-16(fp)
 3221e64:	e17ffd15 	stw	r5,-12(fp)
 3221e68:	e1bffe15 	stw	r6,-8(fp)
    eth_ocm_dev *dev;
    eth_ocm_info *info;
    eth_ocm_regs *regs;
    alt_u8 *buf;

    dev = (eth_ocm_dev *)net->n_local;
 3221e6c:	e0bffc17 	ldw	r2,-16(fp)
 3221e70:	10802817 	ldw	r2,160(r2)
 3221e74:	e0bff915 	stw	r2,-28(fp)
    info = dev->info;
 3221e78:	e0bff917 	ldw	r2,-28(fp)
 3221e7c:	10801117 	ldw	r2,68(r2)
 3221e80:	e0bff815 	stw	r2,-32(fp)
    regs = dev->regs;
 3221e84:	e0bff917 	ldw	r2,-28(fp)
 3221e88:	10800a17 	ldw	r2,40(r2)
 3221e8c:	e0bff715 	stw	r2,-36(fp)
    len = data_bytes - ETHHDR_BIAS;
 3221e90:	e0bffe17 	ldw	r2,-8(fp)
 3221e94:	10bfff84 	addi	r2,r2,-2
 3221e98:	e0bffa15 	stw	r2,-24(fp)
    result = SUCCESS;
 3221e9c:	e03ffb15 	stw	zero,-20(fp)

    //Check to see if someone is nesting send calls (BAD!)
    if(info->sem){
 3221ea0:	e0bff817 	ldw	r2,-32(fp)
 3221ea4:	10800303 	ldbu	r2,12(r2)
 3221ea8:	10803fcc 	andi	r2,r2,255
 3221eac:	1005003a 	cmpeq	r2,r2,zero
 3221eb0:	1000061e 	bne	r2,zero,3221ecc <eth_ocm_low_send+0x7c>
       dprintf("[eth_ocm_low_send] ERROR: Nested low send call\n");
 3221eb4:	0100c974 	movhi	r4,805
 3221eb8:	2139fe04 	addi	r4,r4,-6152
 3221ebc:	32071080 	call	3207108 <puts>
       return ENP_RESOURCE;
 3221ec0:	00bffa84 	movi	r2,-22
 3221ec4:	e0bfff15 	stw	r2,-4(fp)
 3221ec8:	00004806 	br	3221fec <eth_ocm_low_send+0x19c>
    }
    //Grab the semaphore
    info->sem = 1;
 3221ecc:	e0fff817 	ldw	r3,-32(fp)
 3221ed0:	00800044 	movi	r2,1
 3221ed4:	18800305 	stb	r2,12(r3)
    // clear bit-31 before passing it to SGDMA Driver
    buf = (alt_u8 *)alt_remap_cached( (volatile void *)data, 4);
 3221ed8:	e13ffd17 	ldw	r4,-12(fp)
 3221edc:	01400104 	movi	r5,4
 3221ee0:	323afac0 	call	323afac <alt_remap_cached>
 3221ee4:	e0bff615 	stw	r2,-40(fp)
    //advance the pointer beyond the header bias
    buf = (alt_u8 *)((unsigned int)buf + ETHHDR_BIAS);
 3221ee8:	e0bff617 	ldw	r2,-40(fp)
 3221eec:	10800084 	addi	r2,r2,2
 3221ef0:	e0bff615 	stw	r2,-40(fp)

    //Some error checks first
    if(len < ETH_OCM_MIN_MTU)
 3221ef4:	e0bffa17 	ldw	r2,-24(fp)
 3221ef8:	10800128 	cmpgeui	r2,r2,4
 3221efc:	1000021e 	bne	r2,zero,3221f08 <eth_ocm_low_send+0xb8>
        result = -1;        //packet too small
 3221f00:	00bfffc4 	movi	r2,-1
 3221f04:	e0bffb15 	stw	r2,-20(fp)
    if(len > ETH_OCM_MAX_MTU)
 3221f08:	e0bffa17 	ldw	r2,-24(fp)
 3221f0c:	10817bf0 	cmpltui	r2,r2,1519
 3221f10:	1000021e 	bne	r2,zero,3221f1c <eth_ocm_low_send+0xcc>
        result = -EFBIG;    //packet too big
 3221f14:	00bff944 	movi	r2,-27
 3221f18:	e0bffb15 	stw	r2,-20(fp)
    if(regs->txdescs[info->next_tx_desc].ctrl & ETH_OCM_TXDESC_READY_MSK)
 3221f1c:	e0bff817 	ldw	r2,-32(fp)
 3221f20:	10800f03 	ldbu	r2,60(r2)
 3221f24:	10803fcc 	andi	r2,r2,255
 3221f28:	e0fff717 	ldw	r3,-36(fp)
 3221f2c:	100490fa 	slli	r2,r2,3
 3221f30:	10c5883a 	add	r2,r2,r3
 3221f34:	10810004 	addi	r2,r2,1024
 3221f38:	10800017 	ldw	r2,0(r2)
 3221f3c:	10a0000c 	andi	r2,r2,32768
 3221f40:	1005003a 	cmpeq	r2,r2,zero
 3221f44:	1000021e 	bne	r2,zero,3221f50 <eth_ocm_low_send+0x100>
        result = -EBUSY;    //DMA not available
 3221f48:	00bffc04 	movi	r2,-16
 3221f4c:	e0bffb15 	stw	r2,-20(fp)

    if(result == SUCCESS){
 3221f50:	e0bffb17 	ldw	r2,-20(fp)
 3221f54:	1004c03a 	cmpne	r2,r2,zero
 3221f58:	1000201e 	bne	r2,zero,3221fdc <eth_ocm_low_send+0x18c>
        //Write pointer to descriptor
        regs->txdescs[info->next_tx_desc].ptr = (unsigned int)buf;
 3221f5c:	e0bff817 	ldw	r2,-32(fp)
 3221f60:	10800f03 	ldbu	r2,60(r2)
 3221f64:	11003fcc 	andi	r4,r2,255
 3221f68:	e0bff617 	ldw	r2,-40(fp)
 3221f6c:	100b883a 	mov	r5,r2
 3221f70:	e0fff717 	ldw	r3,-36(fp)
 3221f74:	200490fa 	slli	r2,r4,3
 3221f78:	10c5883a 	add	r2,r2,r3
 3221f7c:	10810104 	addi	r2,r2,1028
 3221f80:	11400015 	stw	r5,0(r2)
        //Write length and setup transfer
        result = ((len << ETH_OCM_TXDESC_LEN_OFST)  |
 3221f84:	e0bffa17 	ldw	r2,-24(fp)
 3221f88:	1004943a 	slli	r2,r2,16
 3221f8c:	10b60014 	ori	r2,r2,55296
 3221f90:	e0bffb15 	stw	r2,-20(fp)
                 ETH_OCM_TXDESC_READY_MSK           |
                 ETH_OCM_TXDESC_IRQ_MSK             |
                 ETH_OCM_TXDESC_PAD_MSK             |
                 ETH_OCM_TXDESC_CRC_MSK);
        //See if wrap flag should be set
        if(info->next_tx_desc == (ETH_OCM_TX_DESC_COUNT - 1))
 3221f94:	e0bff817 	ldw	r2,-32(fp)
 3221f98:	10800f03 	ldbu	r2,60(r2)
 3221f9c:	10803fcc 	andi	r2,r2,255
 3221fa0:	1004c03a 	cmpne	r2,r2,zero
 3221fa4:	1000031e 	bne	r2,zero,3221fb4 <eth_ocm_low_send+0x164>
            result |= ETH_OCM_TXDESC_WRAP_MSK;
 3221fa8:	e0bffb17 	ldw	r2,-20(fp)
 3221fac:	10880014 	ori	r2,r2,8192
 3221fb0:	e0bffb15 	stw	r2,-20(fp)
        //Write descriptor
        regs->txdescs[info->next_tx_desc].ctrl = result;
 3221fb4:	e0bff817 	ldw	r2,-32(fp)
 3221fb8:	10800f03 	ldbu	r2,60(r2)
 3221fbc:	10803fcc 	andi	r2,r2,255
 3221fc0:	e13ffb17 	ldw	r4,-20(fp)
 3221fc4:	e0fff717 	ldw	r3,-36(fp)
 3221fc8:	100490fa 	slli	r2,r2,3
 3221fcc:	10c5883a 	add	r2,r2,r3
 3221fd0:	10810004 	addi	r2,r2,1024
 3221fd4:	11000015 	stw	r4,0(r2)
        #if (ETH_OCM_DBG_LVL >= 5)
            dprintf("[eth_ocm_low_send] Sent packet with descriptor 0x%08x\n", result);
        #endif
        result = SUCCESS;
 3221fd8:	e03ffb15 	stw	zero,-20(fp)
    }

    info->sem = 0;
 3221fdc:	e0bff817 	ldw	r2,-32(fp)
 3221fe0:	10000305 	stb	zero,12(r2)
    return result;
 3221fe4:	e0bffb17 	ldw	r2,-20(fp)
 3221fe8:	e0bfff15 	stw	r2,-4(fp)
 3221fec:	e0bfff17 	ldw	r2,-4(fp)
}
 3221ff0:	e037883a 	mov	sp,fp
 3221ff4:	dfc00117 	ldw	ra,4(sp)
 3221ff8:	df000017 	ldw	fp,0(sp)
 3221ffc:	dec00204 	addi	sp,sp,8
 3222000:	f800283a 	ret

03222004 <eth_ocm_tx_isr>:

void    eth_ocm_tx_isr(eth_ocm_dev *dev){
 3222004:	defff904 	addi	sp,sp,-28
 3222008:	dfc00615 	stw	ra,24(sp)
 322200c:	df000515 	stw	fp,20(sp)
 3222010:	df000504 	addi	fp,sp,20
 3222014:	e13fff15 	stw	r4,-4(fp)
    eth_ocm_info *info;
    eth_ocm_regs *regs;
    int result;
    PACKET pkt;

    info = dev->info;
 3222018:	e0bfff17 	ldw	r2,-4(fp)
 322201c:	10801117 	ldw	r2,68(r2)
 3222020:	e0bffe15 	stw	r2,-8(fp)
    regs = dev->regs;
 3222024:	e0bfff17 	ldw	r2,-4(fp)
 3222028:	10800a17 	ldw	r2,40(r2)
 322202c:	e0bffd15 	stw	r2,-12(fp)

    //First we need to process all finished descriptors
    while(  info->sending.q_len>0 
 3222030:	00003c06 	br	3222124 <eth_ocm_tx_isr+0x120>
            && ((info->cur_tx_desc != info->next_tx_desc) || !info->next_tx_desc_rdy)
            && !(regs->txdescs[info->cur_tx_desc].ctrl & ETH_OCM_TXDESC_READY_MSK)){ 
    
        //Get the packet
        pkt = (PACKET)getq(&info->sending);
 3222034:	e0bffe17 	ldw	r2,-8(fp)
 3222038:	11000a04 	addi	r4,r2,40
 322203c:	322a7b80 	call	322a7b8 <getq>
 3222040:	e0bffb15 	stw	r2,-20(fp)

        //Get transmit result from descriptor
        result = regs->txdescs[info->cur_tx_desc].ctrl;
 3222044:	e0bffe17 	ldw	r2,-8(fp)
 3222048:	10800343 	ldbu	r2,13(r2)
 322204c:	10803fcc 	andi	r2,r2,255
 3222050:	e0fffd17 	ldw	r3,-12(fp)
 3222054:	100490fa 	slli	r2,r2,3
 3222058:	10c5883a 	add	r2,r2,r3
 322205c:	10810004 	addi	r2,r2,1024
 3222060:	10800017 	ldw	r2,0(r2)
 3222064:	e0bffc15 	stw	r2,-16(fp)

        //Check for errors
        if(result & 
 3222068:	e0bffc17 	ldw	r2,-16(fp)
 322206c:	1080434c 	andi	r2,r2,269
 3222070:	1005003a 	cmpeq	r2,r2,zero
 3222074:	1000071e 	bne	r2,zero,3222094 <eth_ocm_tx_isr+0x90>
            ETH_OCM_TXDESC_LC_MSK       |
            ETH_OCM_TXDESC_CS_MSK)){
            #if (ETH_OCM_DBG_LVL >= 2)
            dprintf("[eth_ocm_tx_isr] Transmit error 0x%x\n", result);
            #endif // if ETH_OCM_DBG_LVL
            pkt->net->n_mib->ifOutDiscards++; //increment TX discard counter
 3222078:	e0bffb17 	ldw	r2,-20(fp)
 322207c:	10800617 	ldw	r2,24(r2)
 3222080:	10c02717 	ldw	r3,156(r2)
 3222084:	18801217 	ldw	r2,72(r3)
 3222088:	10800044 	addi	r2,r2,1
 322208c:	18801215 	stw	r2,72(r3)
 3222090:	00001206 	br	32220dc <eth_ocm_tx_isr+0xd8>
        else{
            #if (ETH_OCM_DBG_LVL >= 5)
            if(result & ETH_OCM_TXDESC_RTRY_MSK)
                dprintf("[eth_ocm_tx_isr] Transmit retries: %d\n", (result & ETH_OCM_TXDESC_RTRY_MSK)>>ETH_OCM_TXDESC_RTRY_OFST);
            #endif
            pkt->net->n_mib->ifOutOctets += pkt->nb_plen;
 3222094:	e0bffb17 	ldw	r2,-20(fp)
 3222098:	10800617 	ldw	r2,24(r2)
 322209c:	11002717 	ldw	r4,156(r2)
 32220a0:	e0bffb17 	ldw	r2,-20(fp)
 32220a4:	10800617 	ldw	r2,24(r2)
 32220a8:	10802717 	ldw	r2,156(r2)
 32220ac:	10c00f17 	ldw	r3,60(r2)
 32220b0:	e0bffb17 	ldw	r2,-20(fp)
 32220b4:	10800417 	ldw	r2,16(r2)
 32220b8:	1885883a 	add	r2,r3,r2
 32220bc:	20800f15 	stw	r2,60(r4)
            pkt->net->n_mib->ifOutUcastPkts++;
 32220c0:	e0bffb17 	ldw	r2,-20(fp)
 32220c4:	10800617 	ldw	r2,24(r2)
 32220c8:	10c02717 	ldw	r3,156(r2)
 32220cc:	18801017 	ldw	r2,64(r3)
 32220d0:	10800044 	addi	r2,r2,1
 32220d4:	18801015 	stw	r2,64(r3)
            result = 0;
 32220d8:	e03ffc15 	stw	zero,-16(fp)
        }

        //free the packet
        pk_free(pkt);
 32220dc:	e13ffb17 	ldw	r4,-20(fp)
 32220e0:	322a6400 	call	322a640 <pk_free>

        //Increment the current descriptor pointer
        info->cur_tx_desc++;
 32220e4:	e0bffe17 	ldw	r2,-8(fp)
 32220e8:	10800343 	ldbu	r2,13(r2)
 32220ec:	10800044 	addi	r2,r2,1
 32220f0:	1007883a 	mov	r3,r2
 32220f4:	e0bffe17 	ldw	r2,-8(fp)
 32220f8:	10c00345 	stb	r3,13(r2)
        if(info->cur_tx_desc == ETH_OCM_TX_DESC_COUNT)
 32220fc:	e0bffe17 	ldw	r2,-8(fp)
 3222100:	10800343 	ldbu	r2,13(r2)
 3222104:	10803fcc 	andi	r2,r2,255
 3222108:	10800058 	cmpnei	r2,r2,1
 322210c:	1000021e 	bne	r2,zero,3222118 <eth_ocm_tx_isr+0x114>
            info->cur_tx_desc = 0;
 3222110:	e0bffe17 	ldw	r2,-8(fp)
 3222114:	10000345 	stb	zero,13(r2)
        //Whatever the next descriptor is it's ready now
        info->next_tx_desc_rdy = 1;
 3222118:	e0fffe17 	ldw	r3,-8(fp)
 322211c:	00800044 	movi	r2,1
 3222120:	18800f45 	stb	r2,61(r3)

    info = dev->info;
    regs = dev->regs;

    //First we need to process all finished descriptors
    while(  info->sending.q_len>0 
 3222124:	e0bffe17 	ldw	r2,-8(fp)
 3222128:	10800c17 	ldw	r2,48(r2)
 322212c:	10800050 	cmplti	r2,r2,1
 3222130:	10004a1e 	bne	r2,zero,322225c <eth_ocm_tx_isr+0x258>
 3222134:	e0bffe17 	ldw	r2,-8(fp)
 3222138:	10c00343 	ldbu	r3,13(r2)
 322213c:	e0bffe17 	ldw	r2,-8(fp)
 3222140:	10800f03 	ldbu	r2,60(r2)
 3222144:	18c03fcc 	andi	r3,r3,255
 3222148:	10803fcc 	andi	r2,r2,255
 322214c:	1880051e 	bne	r3,r2,3222164 <eth_ocm_tx_isr+0x160>
 3222150:	e0bffe17 	ldw	r2,-8(fp)
 3222154:	10800f43 	ldbu	r2,61(r2)
 3222158:	10803fcc 	andi	r2,r2,255
 322215c:	1004c03a 	cmpne	r2,r2,zero
 3222160:	10003e1e 	bne	r2,zero,322225c <eth_ocm_tx_isr+0x258>
 3222164:	e0bffe17 	ldw	r2,-8(fp)
 3222168:	10800343 	ldbu	r2,13(r2)
 322216c:	10803fcc 	andi	r2,r2,255
 3222170:	e0fffd17 	ldw	r3,-12(fp)
 3222174:	100490fa 	slli	r2,r2,3
 3222178:	10c5883a 	add	r2,r2,r3
 322217c:	10810004 	addi	r2,r2,1024
 3222180:	10800017 	ldw	r2,0(r2)
 3222184:	10a0000c 	andi	r2,r2,32768
 3222188:	1005003a 	cmpeq	r2,r2,zero
 322218c:	103fa91e 	bne	r2,zero,3222034 <eth_ocm_tx_isr+0x30>
        //Whatever the next descriptor is it's ready now
        info->next_tx_desc_rdy = 1;
    }

    //Now we can send any queued packets
    while( info->next_tx_desc_rdy
 3222190:	00003206 	br	322225c <eth_ocm_tx_isr+0x258>
            && info->tosend.q_len>0
            && !(regs->txdescs[info->next_tx_desc].ctrl & ETH_OCM_TXDESC_READY_MSK) ){

        //Get the packet to be send
        pkt = (PACKET)getq(&info->tosend);
 3222194:	e0bffe17 	ldw	r2,-8(fp)
 3222198:	11000504 	addi	r4,r2,20
 322219c:	322a7b80 	call	322a7b8 <getq>
 32221a0:	e0bffb15 	stw	r2,-20(fp)

        result = eth_ocm_low_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 32221a4:	e0bffb17 	ldw	r2,-20(fp)
 32221a8:	11000617 	ldw	r4,24(r2)
 32221ac:	e0bffb17 	ldw	r2,-20(fp)
 32221b0:	11400317 	ldw	r5,12(r2)
 32221b4:	e0bffb17 	ldw	r2,-20(fp)
 32221b8:	11800417 	ldw	r6,16(r2)
 32221bc:	3221e500 	call	3221e50 <eth_ocm_low_send>
 32221c0:	e0bffc15 	stw	r2,-16(fp)
        //If setup failed, free the packet and move on.
        if(result != SUCCESS){
 32221c4:	e0bffc17 	ldw	r2,-16(fp)
 32221c8:	1005003a 	cmpeq	r2,r2,zero
 32221cc:	1000091e 	bne	r2,zero,32221f4 <eth_ocm_tx_isr+0x1f0>
            pkt->net->n_mib->ifOutDiscards++;
 32221d0:	e0bffb17 	ldw	r2,-20(fp)
 32221d4:	10800617 	ldw	r2,24(r2)
 32221d8:	10c02717 	ldw	r3,156(r2)
 32221dc:	18801217 	ldw	r2,72(r3)
 32221e0:	10800044 	addi	r2,r2,1
 32221e4:	18801215 	stw	r2,72(r3)
            pk_free(pkt);
 32221e8:	e13ffb17 	ldw	r4,-20(fp)
 32221ec:	322a6400 	call	322a640 <pk_free>
 32221f0:	00001a06 	br	322225c <eth_ocm_tx_isr+0x258>
        }
        else{ //Transfer was successfully setup
            info->next_tx_desc++;
 32221f4:	e0bffe17 	ldw	r2,-8(fp)
 32221f8:	10800f03 	ldbu	r2,60(r2)
 32221fc:	10800044 	addi	r2,r2,1
 3222200:	1007883a 	mov	r3,r2
 3222204:	e0bffe17 	ldw	r2,-8(fp)
 3222208:	10c00f05 	stb	r3,60(r2)
            if(info->next_tx_desc == ETH_OCM_TX_DESC_COUNT)
 322220c:	e0bffe17 	ldw	r2,-8(fp)
 3222210:	10800f03 	ldbu	r2,60(r2)
 3222214:	10803fcc 	andi	r2,r2,255
 3222218:	10800058 	cmpnei	r2,r2,1
 322221c:	1000021e 	bne	r2,zero,3222228 <eth_ocm_tx_isr+0x224>
                info->next_tx_desc = 0;
 3222220:	e0bffe17 	ldw	r2,-8(fp)
 3222224:	10000f05 	stb	zero,60(r2)
            //See if all descriptor are in use
            if(info->next_tx_desc == info->cur_tx_desc)
 3222228:	e0bffe17 	ldw	r2,-8(fp)
 322222c:	10c00f03 	ldbu	r3,60(r2)
 3222230:	e0bffe17 	ldw	r2,-8(fp)
 3222234:	10800343 	ldbu	r2,13(r2)
 3222238:	18c03fcc 	andi	r3,r3,255
 322223c:	10803fcc 	andi	r2,r2,255
 3222240:	1880021e 	bne	r3,r2,322224c <eth_ocm_tx_isr+0x248>
                info->next_tx_desc_rdy = 0;
 3222244:	e0bffe17 	ldw	r2,-8(fp)
 3222248:	10000f45 	stb	zero,61(r2)
            //Put the packet in the sending queue
            putq(&info->sending, (qp)pkt);
 322224c:	e0bffe17 	ldw	r2,-8(fp)
 3222250:	11000a04 	addi	r4,r2,40
 3222254:	e17ffb17 	ldw	r5,-20(fp)
 3222258:	322a8800 	call	322a880 <putq>
        //Whatever the next descriptor is it's ready now
        info->next_tx_desc_rdy = 1;
    }

    //Now we can send any queued packets
    while( info->next_tx_desc_rdy
 322225c:	e0bffe17 	ldw	r2,-8(fp)
 3222260:	10800f43 	ldbu	r2,61(r2)
 3222264:	10803fcc 	andi	r2,r2,255
 3222268:	1005003a 	cmpeq	r2,r2,zero
 322226c:	10000f1e 	bne	r2,zero,32222ac <eth_ocm_tx_isr+0x2a8>
 3222270:	e0bffe17 	ldw	r2,-8(fp)
 3222274:	10800717 	ldw	r2,28(r2)
 3222278:	10800050 	cmplti	r2,r2,1
 322227c:	10000b1e 	bne	r2,zero,32222ac <eth_ocm_tx_isr+0x2a8>
 3222280:	e0bffe17 	ldw	r2,-8(fp)
 3222284:	10800f03 	ldbu	r2,60(r2)
 3222288:	10803fcc 	andi	r2,r2,255
 322228c:	e0fffd17 	ldw	r3,-12(fp)
 3222290:	100490fa 	slli	r2,r2,3
 3222294:	10c5883a 	add	r2,r2,r3
 3222298:	10810004 	addi	r2,r2,1024
 322229c:	10800017 	ldw	r2,0(r2)
 32222a0:	10a0000c 	andi	r2,r2,32768
 32222a4:	1005003a 	cmpeq	r2,r2,zero
 32222a8:	103fba1e 	bne	r2,zero,3222194 <eth_ocm_tx_isr+0x190>
                info->next_tx_desc_rdy = 0;
            //Put the packet in the sending queue
            putq(&info->sending, (qp)pkt);
        }
    }
}
 32222ac:	e037883a 	mov	sp,fp
 32222b0:	dfc00117 	ldw	ra,4(sp)
 32222b4:	df000017 	ldw	fp,0(sp)
 32222b8:	dec00204 	addi	sp,sp,8
 32222bc:	f800283a 	ret

032222c0 <eth_ocm_isr>:
 * Receive ISR (interrupt service routine)
 *
 * @param  context  - context of the Opencores MAC instance
 * @param  id       - IRQ number 
 */
void eth_ocm_isr(void *context, alt_u32 id){
 32222c0:	defff904 	addi	sp,sp,-28
 32222c4:	dfc00615 	stw	ra,24(sp)
 32222c8:	df000515 	stw	fp,20(sp)
 32222cc:	df000504 	addi	fp,sp,20
 32222d0:	e13ffe15 	stw	r4,-8(fp)
 32222d4:	e17fff15 	stw	r5,-4(fp)
    eth_ocm_dev *dev;
    eth_ocm_regs *regs;
    int result;

    dev = (eth_ocm_dev *)context;
 32222d8:	e0bffe17 	ldw	r2,-8(fp)
 32222dc:	e0bffd15 	stw	r2,-12(fp)
    regs = dev->regs;
 32222e0:	e0bffd17 	ldw	r2,-12(fp)
 32222e4:	10800a17 	ldw	r2,40(r2)
 32222e8:	e0bffc15 	stw	r2,-16(fp)

    //Read the interrupt source
    result = regs->int_source;
 32222ec:	e0bffc17 	ldw	r2,-16(fp)
 32222f0:	10800117 	ldw	r2,4(r2)
 32222f4:	e0bffb15 	stw	r2,-20(fp)
    while(result){
 32222f8:	00002606 	br	3222394 <eth_ocm_isr+0xd4>
        //Clear interrupt flags immediately. Only clear the ones that
        //have been set. We do this in case another one has occured since
        //we read it.
        regs->int_source = result;  //clear interrupts
 32222fc:	e0fffb17 	ldw	r3,-20(fp)
 3222300:	e0bffc17 	ldw	r2,-16(fp)
 3222304:	10c00115 	stw	r3,4(r2)

        //Check for receive flags
        if(result & (ETH_OCM_INT_MASK_RXB_MSK | ETH_OCM_INT_MASK_RXE_MSK)){
 3222308:	e0bffb17 	ldw	r2,-20(fp)
 322230c:	1080030c 	andi	r2,r2,12
 3222310:	1005003a 	cmpeq	r2,r2,zero
 3222314:	10000b1e 	bne	r2,zero,3222344 <eth_ocm_isr+0x84>
            //Call the receive function. This will set up a new transfer
            eth_ocm_rx_isr(dev);
 3222318:	e13ffd17 	ldw	r4,-12(fp)
 322231c:	32225900 	call	3222590 <eth_ocm_rx_isr>
            //Check to see if there is something in the stack's received queue
            if ((rcvdq.q_len) > 0){
 3222320:	0080c9b4 	movhi	r2,806
 3222324:	10b28004 	addi	r2,r2,-13824
 3222328:	10800217 	ldw	r2,8(r2)
 322232c:	10800050 	cmplti	r2,r2,1
 3222330:	1000041e 	bne	r2,zero,3222344 <eth_ocm_isr+0x84>
                SignalPktDemux(); 
 3222334:	0080c974 	movhi	r2,805
 3222338:	10934404 	addi	r2,r2,19728
 322233c:	11000017 	ldw	r4,0(r2)
 3222340:	321b4e00 	call	321b4e0 <OSSemPost>
            }
        }
       
        //Check for busy flag
        if(result & ETH_OCM_INT_MASK_BUSY_MSK){
 3222344:	e0bffb17 	ldw	r2,-20(fp)
 3222348:	1080040c 	andi	r2,r2,16
 322234c:	1005003a 	cmpeq	r2,r2,zero
 3222350:	1000071e 	bne	r2,zero,3222370 <eth_ocm_isr+0xb0>
        #if (ETH_OCM_DBG_LVL >= 3)        
            dprintf("Frame dropped: too busy to receive\n");
        #endif
            dev->info->netp->n_mib->ifInDiscards++;
 3222354:	e0bffd17 	ldw	r2,-12(fp)
 3222358:	10801117 	ldw	r2,68(r2)
 322235c:	10800217 	ldw	r2,8(r2)
 3222360:	10c02717 	ldw	r3,156(r2)
 3222364:	18800c17 	ldw	r2,48(r3)
 3222368:	10800044 	addi	r2,r2,1
 322236c:	18800c15 	stw	r2,48(r3)
        }

        #ifndef ETH_OCM_SYNC_TX
        //Check for transmit flags
        if(result & (ETH_OCM_INT_MASK_TXE_MSK | ETH_OCM_INT_MASK_TXB_MSK)){
 3222370:	e0bffb17 	ldw	r2,-20(fp)
 3222374:	108000cc 	andi	r2,r2,3
 3222378:	1005003a 	cmpeq	r2,r2,zero
 322237c:	1000021e 	bne	r2,zero,3222388 <eth_ocm_isr+0xc8>
            eth_ocm_tx_isr(dev);
 3222380:	e13ffd17 	ldw	r4,-12(fp)
 3222384:	32220040 	call	3222004 <eth_ocm_tx_isr>
        }
        #endif //ifndef ETH_OCM_SYNC_TX


        //See if any interrupts have been set
        result = regs->int_source;
 3222388:	e0bffc17 	ldw	r2,-16(fp)
 322238c:	10800117 	ldw	r2,4(r2)
 3222390:	e0bffb15 	stw	r2,-20(fp)
    dev = (eth_ocm_dev *)context;
    regs = dev->regs;

    //Read the interrupt source
    result = regs->int_source;
    while(result){
 3222394:	e0bffb17 	ldw	r2,-20(fp)
 3222398:	1004c03a 	cmpne	r2,r2,zero
 322239c:	103fd71e 	bne	r2,zero,32222fc <eth_ocm_isr+0x3c>


        //See if any interrupts have been set
        result = regs->int_source;
    }
}
 32223a0:	e037883a 	mov	sp,fp
 32223a4:	dfc00117 	ldw	ra,4(sp)
 32223a8:	df000017 	ldw	fp,0(sp)
 32223ac:	dec00204 	addi	sp,sp,8
 32223b0:	f800283a 	ret

032223b4 <eth_ocm_read_init>:


/**
 *  Set up the first receive transfer
 */
static int eth_ocm_read_init(eth_ocm_dev *dev){
 32223b4:	defff504 	addi	sp,sp,-44
 32223b8:	dfc00a15 	stw	ra,40(sp)
 32223bc:	df000915 	stw	fp,36(sp)
 32223c0:	dc000815 	stw	r16,32(sp)
 32223c4:	df000804 	addi	fp,sp,32
 32223c8:	e13ffe15 	stw	r4,-8(fp)
    alt_u8 *buf_ptr;
    PACKET *pkts;
    alt_u32 temp;
    int i;

    info = dev->info;
 32223cc:	e0bffe17 	ldw	r2,-8(fp)
 32223d0:	10801117 	ldw	r2,68(r2)
 32223d4:	e0bffd15 	stw	r2,-12(fp)
    regs = dev->regs;
 32223d8:	e0bffe17 	ldw	r2,-8(fp)
 32223dc:	10800a17 	ldw	r2,40(r2)
 32223e0:	e0bffc15 	stw	r2,-16(fp)
    pkts = info->rx_pkts;
 32223e4:	e0bffd17 	ldw	r2,-12(fp)
 32223e8:	10800417 	ldw	r2,16(r2)
 32223ec:	e0bffa15 	stw	r2,-24(fp)


    //allocate a packet for every descriptor
    for(i=0;i<ETH_OCM_RX_DESC_COUNT;i++){
 32223f0:	e03ff815 	stw	zero,-32(fp)
 32223f4:	00005b06 	br	3222564 <eth_ocm_read_init+0x1b0>
        pkts[i] = pk_alloc(ETH_OCM_BUF_ALLOC_SIZE);
 32223f8:	e0bff817 	ldw	r2,-32(fp)
 32223fc:	1085883a 	add	r2,r2,r2
 3222400:	1085883a 	add	r2,r2,r2
 3222404:	1007883a 	mov	r3,r2
 3222408:	e0bffa17 	ldw	r2,-24(fp)
 322240c:	18a1883a 	add	r16,r3,r2
 3222410:	01018004 	movi	r4,1536
 3222414:	322a2ac0 	call	322a2ac <pk_alloc>
 3222418:	80800015 	stw	r2,0(r16)
        if (!pkts[i]){  // couldn't get a free buffer for rx 
 322241c:	e0bff817 	ldw	r2,-32(fp)
 3222420:	1085883a 	add	r2,r2,r2
 3222424:	1085883a 	add	r2,r2,r2
 3222428:	1007883a 	mov	r3,r2
 322242c:	e0bffa17 	ldw	r2,-24(fp)
 3222430:	1885883a 	add	r2,r3,r2
 3222434:	10800017 	ldw	r2,0(r2)
 3222438:	1004c03a 	cmpne	r2,r2,zero
 322243c:	1000061e 	bne	r2,zero,3222458 <eth_ocm_read_init+0xa4>
            dprintf("[eth_ocm_read_init] Fatal error: Unable to allocte ETH_OCM_RX_DESC_COUNT buffers\n");
 3222440:	0100c974 	movhi	r4,805
 3222444:	213a0a04 	addi	r4,r4,-6104
 3222448:	32071080 	call	3207108 <puts>
            return ENP_NOBUFFER;
 322244c:	00bffac4 	movi	r2,-21
 3222450:	e0bfff15 	stw	r2,-4(fp)
 3222454:	00004706 	br	3222574 <eth_ocm_read_init+0x1c0>
        }

        // ensure bit-31 of pkt_array[i]->nb_buff is clear before passing
        buf_ptr = (alt_u8*)alt_remap_cached ((volatile void*) pkts[i]->nb_buff, 4);
 3222458:	e0bff817 	ldw	r2,-32(fp)
 322245c:	1085883a 	add	r2,r2,r2
 3222460:	1085883a 	add	r2,r2,r2
 3222464:	1007883a 	mov	r3,r2
 3222468:	e0bffa17 	ldw	r2,-24(fp)
 322246c:	1885883a 	add	r2,r3,r2
 3222470:	10800017 	ldw	r2,0(r2)
 3222474:	11000117 	ldw	r4,4(r2)
 3222478:	01400104 	movi	r5,4
 322247c:	323afac0 	call	323afac <alt_remap_cached>
 3222480:	e0bffb15 	stw	r2,-20(fp)
        //shift the actual write location over by ETHHDR_BIAS (see ipport.h)
        buf_ptr = (alt_u8*)(((unsigned int)buf_ptr) + ETHHDR_BIAS);
 3222484:	e0bffb17 	ldw	r2,-20(fp)
 3222488:	10800084 	addi	r2,r2,2
 322248c:	e0bffb15 	stw	r2,-20(fp)

        if(!(regs->rxdescs[i].ctrl & ETH_OCM_RXDESC_EMPTY_MSK)){
 3222490:	e0bff817 	ldw	r2,-32(fp)
 3222494:	e0fffc17 	ldw	r3,-16(fp)
 3222498:	100490fa 	slli	r2,r2,3
 322249c:	10c5883a 	add	r2,r2,r3
 32224a0:	10810204 	addi	r2,r2,1032
 32224a4:	10800017 	ldw	r2,0(r2)
 32224a8:	10a0000c 	andi	r2,r2,32768
 32224ac:	1004c03a 	cmpne	r2,r2,zero
 32224b0:	10001b1e 	bne	r2,zero,3222520 <eth_ocm_read_init+0x16c>
            //Write pointer
            regs->rxdescs[i].ptr = (alt_u32)buf_ptr;
 32224b4:	e13ff817 	ldw	r4,-32(fp)
 32224b8:	e0bffb17 	ldw	r2,-20(fp)
 32224bc:	100b883a 	mov	r5,r2
 32224c0:	e0fffc17 	ldw	r3,-16(fp)
 32224c4:	200490fa 	slli	r2,r4,3
 32224c8:	10c5883a 	add	r2,r2,r3
 32224cc:	10810304 	addi	r2,r2,1036
 32224d0:	11400015 	stw	r5,0(r2)
            //Write the control register to start the transfer
            temp = ETH_OCM_RXDESC_EMPTY_MSK | ETH_OCM_RXDESC_IRQ_MSK;
 32224d4:	00b00014 	movui	r2,49152
 32224d8:	e0bff915 	stw	r2,-28(fp)
            if(i == (ETH_OCM_RX_DESC_COUNT - 1))
 32224dc:	e0bff817 	ldw	r2,-32(fp)
 32224e0:	1004c03a 	cmpne	r2,r2,zero
 32224e4:	1000031e 	bne	r2,zero,32224f4 <eth_ocm_read_init+0x140>
                temp |= ETH_OCM_RXDESC_WRAP_MSK;
 32224e8:	e0bff917 	ldw	r2,-28(fp)
 32224ec:	10880014 	ori	r2,r2,8192
 32224f0:	e0bff915 	stw	r2,-28(fp)
            regs->rxdescs[i].ctrl = temp; 
 32224f4:	e0bff817 	ldw	r2,-32(fp)
 32224f8:	e0fffc17 	ldw	r3,-16(fp)
 32224fc:	100490fa 	slli	r2,r2,3
 3222500:	10c5883a 	add	r2,r2,r3
 3222504:	10c10204 	addi	r3,r2,1032
 3222508:	e0bff917 	ldw	r2,-28(fp)
 322250c:	18800015 	stw	r2,0(r3)
    regs = dev->regs;
    pkts = info->rx_pkts;


    //allocate a packet for every descriptor
    for(i=0;i<ETH_OCM_RX_DESC_COUNT;i++){
 3222510:	e0bff817 	ldw	r2,-32(fp)
 3222514:	10800044 	addi	r2,r2,1
 3222518:	e0bff815 	stw	r2,-32(fp)
 322251c:	00001106 	br	3222564 <eth_ocm_read_init+0x1b0>
            if(i == (ETH_OCM_RX_DESC_COUNT - 1))
                temp |= ETH_OCM_RXDESC_WRAP_MSK;
            regs->rxdescs[i].ctrl = temp; 
        }
        else{
            dprintf("[eth_ocm_read_init] Fatal error: RX descriptor unavailable.\n");
 3222520:	0100c974 	movhi	r4,805
 3222524:	213a1f04 	addi	r4,r4,-6020
 3222528:	32071080 	call	3207108 <puts>
            dprintf("[eth_ocm_read_init] Descriptor %u = 0x%08x\n", i, (int)regs->rxdescs[i].ctrl);
 322252c:	e0bff817 	ldw	r2,-32(fp)
 3222530:	e0fffc17 	ldw	r3,-16(fp)
 3222534:	100490fa 	slli	r2,r2,3
 3222538:	10c5883a 	add	r2,r2,r3
 322253c:	10810204 	addi	r2,r2,1032
 3222540:	10800017 	ldw	r2,0(r2)
 3222544:	100d883a 	mov	r6,r2
 3222548:	0100c974 	movhi	r4,805
 322254c:	213a2e04 	addi	r4,r4,-5960
 3222550:	e17ff817 	ldw	r5,-32(fp)
 3222554:	3206de00 	call	3206de0 <printf>
            return ENP_RESOURCE;
 3222558:	00bffa84 	movi	r2,-22
 322255c:	e0bfff15 	stw	r2,-4(fp)
 3222560:	00000406 	br	3222574 <eth_ocm_read_init+0x1c0>
    regs = dev->regs;
    pkts = info->rx_pkts;


    //allocate a packet for every descriptor
    for(i=0;i<ETH_OCM_RX_DESC_COUNT;i++){
 3222564:	e0bff817 	ldw	r2,-32(fp)
 3222568:	10800050 	cmplti	r2,r2,1
 322256c:	103fa21e 	bne	r2,zero,32223f8 <eth_ocm_read_init+0x44>
            dprintf("[eth_ocm_read_init] Descriptor %u = 0x%08x\n", i, (int)regs->rxdescs[i].ctrl);
            return ENP_RESOURCE;
        }
    }

    return SUCCESS;
 3222570:	e03fff15 	stw	zero,-4(fp)
 3222574:	e0bfff17 	ldw	r2,-4(fp)
}
 3222578:	e037883a 	mov	sp,fp
 322257c:	dfc00217 	ldw	ra,8(sp)
 3222580:	df000117 	ldw	fp,4(sp)
 3222584:	dc000017 	ldw	r16,0(sp)
 3222588:	dec00304 	addi	sp,sp,12
 322258c:	f800283a 	ret

03222590 <eth_ocm_rx_isr>:
 * Schedules another RX transfer
 *
 * @return SUCCESS on success
 */
static int eth_ocm_rx_isr(eth_ocm_dev *dev)
{
 3222590:	defff404 	addi	sp,sp,-48
 3222594:	dfc00b15 	stw	ra,44(sp)
 3222598:	df000a15 	stw	fp,40(sp)
 322259c:	df000a04 	addi	fp,sp,40
 32225a0:	e13fff15 	stw	r4,-4(fp)
    alt_u8 cur;
    PACKET pkt;
    PACKET *pkts;
    alt_u8 *buf_ptr;

    info = dev->info;
 32225a4:	e0bfff17 	ldw	r2,-4(fp)
 32225a8:	10801117 	ldw	r2,68(r2)
 32225ac:	e0bffe15 	stw	r2,-8(fp)
    regs = dev->regs;
 32225b0:	e0bfff17 	ldw	r2,-4(fp)
 32225b4:	10800a17 	ldw	r2,40(r2)
 32225b8:	e0bffd15 	stw	r2,-12(fp)
    pkts = info->rx_pkts;
 32225bc:	e0bffe17 	ldw	r2,-8(fp)
 32225c0:	10800417 	ldw	r2,16(r2)
 32225c4:	e0bff715 	stw	r2,-36(fp)
    cur = info->cur_rx_desc;
 32225c8:	e0bffe17 	ldw	r2,-8(fp)
 32225cc:	10800383 	ldbu	r2,14(r2)
 32225d0:	e0bff905 	stb	r2,-28(fp)

    stat = regs->rxdescs[cur].ctrl;
 32225d4:	e0bff903 	ldbu	r2,-28(fp)
 32225d8:	e0fffd17 	ldw	r3,-12(fp)
 32225dc:	100490fa 	slli	r2,r2,3
 32225e0:	10c5883a 	add	r2,r2,r3
 32225e4:	10810204 	addi	r2,r2,1032
 32225e8:	10800017 	ldw	r2,0(r2)
 32225ec:	e0bffa15 	stw	r2,-24(fp)

    //We'll process as many descriptors as are ready
    while(!(stat & ETH_OCM_RXDESC_EMPTY_MSK)){
 32225f0:	0000b106 	br	32228b8 <eth_ocm_rx_isr+0x328>

        #if (ETH_OCM_DBG_LVL >= 5)
        dprintf("[eth_ocm_rx_isr] Received packet with status 0x%08x\n",stat);
        #endif // if ETH_OCM_DBG_LVL

        pklen = stat & ETH_OCM_RXDESC_LEN_MSK;
 32225f4:	e0bffa17 	ldw	r2,-24(fp)
 32225f8:	10bfffec 	andhi	r2,r2,65535
 32225fc:	e0bffb15 	stw	r2,-20(fp)
        pklen = pklen >> ETH_OCM_RXDESC_LEN_OFST;
 3222600:	e0bffb17 	ldw	r2,-20(fp)
 3222604:	1005d43a 	srai	r2,r2,16
 3222608:	e0bffb15 	stw	r2,-20(fp)

        //Increment received byte count
        info->netp->n_mib->ifInOctets += (u_long)pklen;
 322260c:	e0bffe17 	ldw	r2,-8(fp)
 3222610:	10800217 	ldw	r2,8(r2)
 3222614:	11002717 	ldw	r4,156(r2)
 3222618:	e0bffe17 	ldw	r2,-8(fp)
 322261c:	10800217 	ldw	r2,8(r2)
 3222620:	10802717 	ldw	r2,156(r2)
 3222624:	10c00917 	ldw	r3,36(r2)
 3222628:	e0bffb17 	ldw	r2,-20(fp)
 322262c:	1885883a 	add	r2,r3,r2
 3222630:	20800915 	stw	r2,36(r4)

        pkts[cur]->nb_prot = pkts[cur]->nb_buff + ETHHDR_SIZE;
 3222634:	e0bff903 	ldbu	r2,-28(fp)
 3222638:	1085883a 	add	r2,r2,r2
 322263c:	1085883a 	add	r2,r2,r2
 3222640:	1007883a 	mov	r3,r2
 3222644:	e0bff717 	ldw	r2,-36(fp)
 3222648:	1885883a 	add	r2,r3,r2
 322264c:	11000017 	ldw	r4,0(r2)
 3222650:	e0bff903 	ldbu	r2,-28(fp)
 3222654:	1085883a 	add	r2,r2,r2
 3222658:	1085883a 	add	r2,r2,r2
 322265c:	1007883a 	mov	r3,r2
 3222660:	e0bff717 	ldw	r2,-36(fp)
 3222664:	1885883a 	add	r2,r3,r2
 3222668:	10800017 	ldw	r2,0(r2)
 322266c:	10800117 	ldw	r2,4(r2)
 3222670:	10800404 	addi	r2,r2,16
 3222674:	20800315 	stw	r2,12(r4)
        pkts[cur]->nb_plen = pklen - (14 + 4); //Packet length minus (header + CRC)
 3222678:	e0bff903 	ldbu	r2,-28(fp)
 322267c:	1085883a 	add	r2,r2,r2
 3222680:	1085883a 	add	r2,r2,r2
 3222684:	1007883a 	mov	r3,r2
 3222688:	e0bff717 	ldw	r2,-36(fp)
 322268c:	1885883a 	add	r2,r3,r2
 3222690:	10c00017 	ldw	r3,0(r2)
 3222694:	e0bffb17 	ldw	r2,-20(fp)
 3222698:	10bffb84 	addi	r2,r2,-18
 322269c:	18800415 	stw	r2,16(r3)
        pkts[cur]->nb_tstamp = cticks;
 32226a0:	e0bff903 	ldbu	r2,-28(fp)
 32226a4:	1085883a 	add	r2,r2,r2
 32226a8:	1085883a 	add	r2,r2,r2
 32226ac:	1007883a 	mov	r3,r2
 32226b0:	e0bff717 	ldw	r2,-36(fp)
 32226b4:	1885883a 	add	r2,r3,r2
 32226b8:	10c00017 	ldw	r3,0(r2)
 32226bc:	0080c974 	movhi	r2,805
 32226c0:	10934104 	addi	r2,r2,19716
 32226c4:	10800017 	ldw	r2,0(r2)
 32226c8:	18800515 	stw	r2,20(r3)
        pkts[cur]->net = info->netp;
 32226cc:	e0bff903 	ldbu	r2,-28(fp)
 32226d0:	1085883a 	add	r2,r2,r2
 32226d4:	1085883a 	add	r2,r2,r2
 32226d8:	1007883a 	mov	r3,r2
 32226dc:	e0bff717 	ldw	r2,-36(fp)
 32226e0:	1885883a 	add	r2,r3,r2
 32226e4:	10c00017 	ldw	r3,0(r2)
 32226e8:	e0bffe17 	ldw	r2,-8(fp)
 32226ec:	10800217 	ldw	r2,8(r2)
 32226f0:	18800615 	stw	r2,24(r3)

        // set packet type for demux routine
        eth = (struct ethhdr *)(pkts[cur]->nb_buff + ETHHDR_BIAS);
 32226f4:	e0bff903 	ldbu	r2,-28(fp)
 32226f8:	1085883a 	add	r2,r2,r2
 32226fc:	1085883a 	add	r2,r2,r2
 3222700:	1007883a 	mov	r3,r2
 3222704:	e0bff717 	ldw	r2,-36(fp)
 3222708:	1885883a 	add	r2,r3,r2
 322270c:	10800017 	ldw	r2,0(r2)
 3222710:	10800117 	ldw	r2,4(r2)
 3222714:	10800084 	addi	r2,r2,2
 3222718:	e0bffc15 	stw	r2,-16(fp)
        pkts[cur]->type = eth->e_type;
 322271c:	e0bff903 	ldbu	r2,-28(fp)
 3222720:	1085883a 	add	r2,r2,r2
 3222724:	1085883a 	add	r2,r2,r2
 3222728:	1007883a 	mov	r3,r2
 322272c:	e0bff717 	ldw	r2,-36(fp)
 3222730:	1885883a 	add	r2,r3,r2
 3222734:	10c00017 	ldw	r3,0(r2)
 3222738:	e0bffc17 	ldw	r2,-16(fp)
 322273c:	1080030b 	ldhu	r2,12(r2)
 3222740:	1880080d 	sth	r2,32(r3)

        if (!(stat & ETH_OCM_RXDESC_ERROR_MSK)){
 3222744:	e0bffa17 	ldw	r2,-24(fp)
 3222748:	10801fcc 	andi	r2,r2,127
 322274c:	1004c03a 	cmpne	r2,r2,zero
 3222750:	1000201e 	bne	r2,zero,32227d4 <eth_ocm_rx_isr+0x244>
            pkt = pk_alloc(ETH_OCM_BUF_ALLOC_SIZE);
 3222754:	01018004 	movi	r4,1536
 3222758:	322a2ac0 	call	322a2ac <pk_alloc>
 322275c:	e0bff815 	stw	r2,-32(fp)
            if (!pkt){  // couldn't get a free buffer for rx 
 3222760:	e0bff817 	ldw	r2,-32(fp)
 3222764:	1004c03a 	cmpne	r2,r2,zero
 3222768:	1000071e 	bne	r2,zero,3222788 <eth_ocm_rx_isr+0x1f8>
              #if (ETH_OCM_DBG_LVL >= 4)
              dprintf("[eth_ocm_rx_isr] No free RX buffers (Swamping the NicheStack)\n");
              #endif // if ETH_OCM_DBG_LVL
              info->netp->n_mib->ifInDiscards++;
 322276c:	e0bffe17 	ldw	r2,-8(fp)
 3222770:	10800217 	ldw	r2,8(r2)
 3222774:	10c02717 	ldw	r3,156(r2)
 3222778:	18800c17 	ldw	r2,48(r3)
 322277c:	10800044 	addi	r2,r2,1
 3222780:	18800c15 	stw	r2,48(r3)
 3222784:	00001906 	br	32227ec <eth_ocm_rx_isr+0x25c>
            }
            else{
              putq(&rcvdq, pkts[cur]);
 3222788:	e0bff903 	ldbu	r2,-28(fp)
 322278c:	1085883a 	add	r2,r2,r2
 3222790:	1085883a 	add	r2,r2,r2
 3222794:	1007883a 	mov	r3,r2
 3222798:	e0bff717 	ldw	r2,-36(fp)
 322279c:	1885883a 	add	r2,r3,r2
 32227a0:	11400017 	ldw	r5,0(r2)
 32227a4:	0100c9b4 	movhi	r4,806
 32227a8:	21328004 	addi	r4,r4,-13824
 32227ac:	322a8800 	call	322a880 <putq>
              pkts[cur] = pkt;
 32227b0:	e0bff903 	ldbu	r2,-28(fp)
 32227b4:	1085883a 	add	r2,r2,r2
 32227b8:	1085883a 	add	r2,r2,r2
 32227bc:	1007883a 	mov	r3,r2
 32227c0:	e0bff717 	ldw	r2,-36(fp)
 32227c4:	1887883a 	add	r3,r3,r2
 32227c8:	e0bff817 	ldw	r2,-32(fp)
 32227cc:	18800015 	stw	r2,0(r3)
 32227d0:	00000606 	br	32227ec <eth_ocm_rx_isr+0x25c>
        }
        else{
            #if (ETH_OCM_DBG_LVL >= 3)
            dprintf("[eth_ocm_rx_isr] Frame discarded due to errors: 0x%08x!\n", (unsigned)stat);
            #endif // if ETH_OCM_DBG_LVL
            info->netp->n_mib->ifInDiscards++;
 32227d4:	e0bffe17 	ldw	r2,-8(fp)
 32227d8:	10800217 	ldw	r2,8(r2)
 32227dc:	10c02717 	ldw	r3,156(r2)
 32227e0:	18800c17 	ldw	r2,48(r3)
 32227e4:	10800044 	addi	r2,r2,1
 32227e8:	18800c15 	stw	r2,48(r3)
        }

        // ensure bit-31 of pkt_array[]->nb_buff is clear before passing
        // to DMA Driver
        buf_ptr = (alt_u8*)alt_remap_cached ((volatile void*) pkts[cur]->nb_buff, 4);
 32227ec:	e0bff903 	ldbu	r2,-28(fp)
 32227f0:	1085883a 	add	r2,r2,r2
 32227f4:	1085883a 	add	r2,r2,r2
 32227f8:	1007883a 	mov	r3,r2
 32227fc:	e0bff717 	ldw	r2,-36(fp)
 3222800:	1885883a 	add	r2,r3,r2
 3222804:	10800017 	ldw	r2,0(r2)
 3222808:	11000117 	ldw	r4,4(r2)
 322280c:	01400104 	movi	r5,4
 3222810:	323afac0 	call	323afac <alt_remap_cached>
 3222814:	e0bff615 	stw	r2,-40(fp)
        //shift the actual write location over by ETHHDR_BIAS (see ipport.h)
        buf_ptr = (alt_u8*)((unsigned int)buf_ptr + ETHHDR_BIAS);
 3222818:	e0bff617 	ldw	r2,-40(fp)
 322281c:	10800084 	addi	r2,r2,2
 3222820:	e0bff615 	stw	r2,-40(fp)

        //Write pointer
        regs->rxdescs[cur].ptr = (unsigned int)buf_ptr; 
 3222824:	e13ff903 	ldbu	r4,-28(fp)
 3222828:	e0bff617 	ldw	r2,-40(fp)
 322282c:	100b883a 	mov	r5,r2
 3222830:	e0fffd17 	ldw	r3,-12(fp)
 3222834:	200490fa 	slli	r2,r4,3
 3222838:	10c5883a 	add	r2,r2,r3
 322283c:	10810304 	addi	r2,r2,1036
 3222840:	11400015 	stw	r5,0(r2)
        //Write the control register to start the transfer
        stat = ETH_OCM_RXDESC_EMPTY_MSK | ETH_OCM_RXDESC_IRQ_MSK;
 3222844:	00b00014 	movui	r2,49152
 3222848:	e0bffa15 	stw	r2,-24(fp)
        if(cur == (ETH_OCM_RX_DESC_COUNT - 1))
 322284c:	e0bff903 	ldbu	r2,-28(fp)
 3222850:	1004c03a 	cmpne	r2,r2,zero
 3222854:	1000031e 	bne	r2,zero,3222864 <eth_ocm_rx_isr+0x2d4>
            stat |= ETH_OCM_RXDESC_WRAP_MSK;
 3222858:	e0bffa17 	ldw	r2,-24(fp)
 322285c:	10880014 	ori	r2,r2,8192
 3222860:	e0bffa15 	stw	r2,-24(fp)
        regs->rxdescs[cur].ctrl = stat;
 3222864:	e0bff903 	ldbu	r2,-28(fp)
 3222868:	e0fffd17 	ldw	r3,-12(fp)
 322286c:	100490fa 	slli	r2,r2,3
 3222870:	10c5883a 	add	r2,r2,r3
 3222874:	10c10204 	addi	r3,r2,1032
 3222878:	e0bffa17 	ldw	r2,-24(fp)
 322287c:	18800015 	stw	r2,0(r3)
        
        //increment current descriptor counter
        cur++;
 3222880:	e0bff903 	ldbu	r2,-28(fp)
 3222884:	10800044 	addi	r2,r2,1
 3222888:	e0bff905 	stb	r2,-28(fp)
        if(cur == ETH_OCM_RX_DESC_COUNT)
 322288c:	e0bff903 	ldbu	r2,-28(fp)
 3222890:	10800058 	cmpnei	r2,r2,1
 3222894:	1000011e 	bne	r2,zero,322289c <eth_ocm_rx_isr+0x30c>
            cur = 0;
 3222898:	e03ff905 	stb	zero,-28(fp)
        //get new descriptors status
        stat = regs->rxdescs[cur].ctrl;
 322289c:	e0bff903 	ldbu	r2,-28(fp)
 32228a0:	e0fffd17 	ldw	r3,-12(fp)
 32228a4:	100490fa 	slli	r2,r2,3
 32228a8:	10c5883a 	add	r2,r2,r3
 32228ac:	10810204 	addi	r2,r2,1032
 32228b0:	10800017 	ldw	r2,0(r2)
 32228b4:	e0bffa15 	stw	r2,-24(fp)
    cur = info->cur_rx_desc;

    stat = regs->rxdescs[cur].ctrl;

    //We'll process as many descriptors as are ready
    while(!(stat & ETH_OCM_RXDESC_EMPTY_MSK)){
 32228b8:	e0bffa17 	ldw	r2,-24(fp)
 32228bc:	10a0000c 	andi	r2,r2,32768
 32228c0:	1005003a 	cmpeq	r2,r2,zero
 32228c4:	103f4b1e 	bne	r2,zero,32225f4 <eth_ocm_rx_isr+0x64>
        if(cur == ETH_OCM_RX_DESC_COUNT)
            cur = 0;
        //get new descriptors status
        stat = regs->rxdescs[cur].ctrl;
    }
    info->cur_rx_desc = cur;        
 32228c8:	e0fffe17 	ldw	r3,-8(fp)
 32228cc:	e0bff903 	ldbu	r2,-28(fp)
 32228d0:	18800385 	stb	r2,14(r3)

    return SUCCESS;
 32228d4:	0005883a 	mov	r2,zero
}
 32228d8:	e037883a 	mov	sp,fp
 32228dc:	dfc00117 	ldw	ra,4(sp)
 32228e0:	df000017 	ldw	fp,0(sp)
 32228e4:	dec00204 	addi	sp,sp,8
 32228e8:	f800283a 	ret

032228ec <eth_ocm_stats>:

void eth_ocm_stats(void *pio, int iface) {
 32228ec:	defff804 	addi	sp,sp,-32
 32228f0:	dfc00715 	stw	ra,28(sp)
 32228f4:	df000615 	stw	fp,24(sp)
 32228f8:	df000604 	addi	fp,sp,24
 32228fc:	e13ffe15 	stw	r4,-8(fp)
 3222900:	e17fff15 	stw	r5,-4(fp)
    eth_ocm_dev *dev;
    eth_ocm_regs *regs;
    int i;

    //get the ifp first
    ifp = nets[iface];
 3222904:	e0bfff17 	ldw	r2,-4(fp)
 3222908:	00c0c9b4 	movhi	r3,806
 322290c:	18f34504 	addi	r3,r3,-13036
 3222910:	1085883a 	add	r2,r2,r2
 3222914:	1085883a 	add	r2,r2,r2
 3222918:	10c5883a 	add	r2,r2,r3
 322291c:	10800017 	ldw	r2,0(r2)
 3222920:	e0bffd15 	stw	r2,-12(fp)
    dev = (eth_ocm_dev *)ifp->n_local;
 3222924:	e0bffd17 	ldw	r2,-12(fp)
 3222928:	10802817 	ldw	r2,160(r2)
 322292c:	e0bffc15 	stw	r2,-16(fp)
    regs = dev->regs;
 3222930:	e0bffc17 	ldw	r2,-16(fp)
 3222934:	10800a17 	ldw	r2,40(r2)
 3222938:	e0bffb15 	stw	r2,-20(fp)

    #ifndef ETH_OCM_SYNC_TX
    ns_printf(pio, "ToSend queue: max:%d, current:%d\n", 
 322293c:	e0bffc17 	ldw	r2,-16(fp)
 3222940:	10801117 	ldw	r2,68(r2)
 3222944:	11800817 	ldw	r6,32(r2)
 3222948:	e0bffc17 	ldw	r2,-16(fp)
 322294c:	10801117 	ldw	r2,68(r2)
 3222950:	11c00717 	ldw	r7,28(r2)
 3222954:	e13ffe17 	ldw	r4,-8(fp)
 3222958:	0140c974 	movhi	r5,805
 322295c:	297a3904 	addi	r5,r5,-5916
 3222960:	322637c0 	call	322637c <ns_printf>
            dev->info->tosend.q_max,
            dev->info->tosend.q_len);

    ns_printf(pio, "Sendng queue: max:%d, current:%d\n", 
 3222964:	e0bffc17 	ldw	r2,-16(fp)
 3222968:	10801117 	ldw	r2,68(r2)
 322296c:	11800d17 	ldw	r6,52(r2)
 3222970:	e0bffc17 	ldw	r2,-16(fp)
 3222974:	10801117 	ldw	r2,68(r2)
 3222978:	11c00c17 	ldw	r7,48(r2)
 322297c:	e13ffe17 	ldw	r4,-8(fp)
 3222980:	0140c974 	movhi	r5,805
 3222984:	297a4204 	addi	r5,r5,-5880
 3222988:	322637c0 	call	322637c <ns_printf>
            dev->info->sending.q_max,
            dev->info->sending.q_len);
    #endif //ifndef ETH_OCM_SYNC_TX

    ns_printf(pio, "TX Descriptor status:\n");
 322298c:	e13ffe17 	ldw	r4,-8(fp)
 3222990:	0140c974 	movhi	r5,805
 3222994:	297a4b04 	addi	r5,r5,-5844
 3222998:	322637c0 	call	322637c <ns_printf>
    for(i=0;i<ETH_OCM_TX_DESC_COUNT;i++){
 322299c:	e03ffa15 	stw	zero,-24(fp)
 32229a0:	00000e06 	br	32229dc <eth_ocm_stats+0xf0>
        ns_printf(pio,"     %3d: 0x%08x\n", i, regs->txdescs[i].ctrl);
 32229a4:	e0bffa17 	ldw	r2,-24(fp)
 32229a8:	e0fffb17 	ldw	r3,-20(fp)
 32229ac:	100490fa 	slli	r2,r2,3
 32229b0:	10c5883a 	add	r2,r2,r3
 32229b4:	10810004 	addi	r2,r2,1024
 32229b8:	11c00017 	ldw	r7,0(r2)
 32229bc:	e13ffe17 	ldw	r4,-8(fp)
 32229c0:	0140c974 	movhi	r5,805
 32229c4:	297a5104 	addi	r5,r5,-5820
 32229c8:	e1bffa17 	ldw	r6,-24(fp)
 32229cc:	322637c0 	call	322637c <ns_printf>
            dev->info->sending.q_max,
            dev->info->sending.q_len);
    #endif //ifndef ETH_OCM_SYNC_TX

    ns_printf(pio, "TX Descriptor status:\n");
    for(i=0;i<ETH_OCM_TX_DESC_COUNT;i++){
 32229d0:	e0bffa17 	ldw	r2,-24(fp)
 32229d4:	10800044 	addi	r2,r2,1
 32229d8:	e0bffa15 	stw	r2,-24(fp)
 32229dc:	e0bffa17 	ldw	r2,-24(fp)
 32229e0:	10800050 	cmplti	r2,r2,1
 32229e4:	103fef1e 	bne	r2,zero,32229a4 <eth_ocm_stats+0xb8>
        ns_printf(pio,"     %3d: 0x%08x\n", i, regs->txdescs[i].ctrl);
    }

    ns_printf(pio, "RX Descriptor status:\n");
 32229e8:	e13ffe17 	ldw	r4,-8(fp)
 32229ec:	0140c974 	movhi	r5,805
 32229f0:	297a5604 	addi	r5,r5,-5800
 32229f4:	322637c0 	call	322637c <ns_printf>
    for(i=0;i<ETH_OCM_RX_DESC_COUNT;i++){
 32229f8:	e03ffa15 	stw	zero,-24(fp)
 32229fc:	00000e06 	br	3222a38 <eth_ocm_stats+0x14c>
        ns_printf(pio,"     %3d: 0x%08x\n", i, regs->rxdescs[i].ctrl);
 3222a00:	e0bffa17 	ldw	r2,-24(fp)
 3222a04:	e0fffb17 	ldw	r3,-20(fp)
 3222a08:	100490fa 	slli	r2,r2,3
 3222a0c:	10c5883a 	add	r2,r2,r3
 3222a10:	10810204 	addi	r2,r2,1032
 3222a14:	11c00017 	ldw	r7,0(r2)
 3222a18:	e13ffe17 	ldw	r4,-8(fp)
 3222a1c:	0140c974 	movhi	r5,805
 3222a20:	297a5104 	addi	r5,r5,-5820
 3222a24:	e1bffa17 	ldw	r6,-24(fp)
 3222a28:	322637c0 	call	322637c <ns_printf>
    for(i=0;i<ETH_OCM_TX_DESC_COUNT;i++){
        ns_printf(pio,"     %3d: 0x%08x\n", i, regs->txdescs[i].ctrl);
    }

    ns_printf(pio, "RX Descriptor status:\n");
    for(i=0;i<ETH_OCM_RX_DESC_COUNT;i++){
 3222a2c:	e0bffa17 	ldw	r2,-24(fp)
 3222a30:	10800044 	addi	r2,r2,1
 3222a34:	e0bffa15 	stw	r2,-24(fp)
 3222a38:	e0bffa17 	ldw	r2,-24(fp)
 3222a3c:	10800050 	cmplti	r2,r2,1
 3222a40:	103fef1e 	bne	r2,zero,3222a00 <eth_ocm_stats+0x114>
        ns_printf(pio,"     %3d: 0x%08x\n", i, regs->rxdescs[i].ctrl);
    }


}
 3222a44:	e037883a 	mov	sp,fp
 3222a48:	dfc00117 	ldw	ra,4(sp)
 3222a4c:	df000017 	ldw	fp,0(sp)
 3222a50:	dec00204 	addi	sp,sp,8
 3222a54:	f800283a 	ret

03222a58 <eth_ocm_close>:
 *
 * @param  iface    index of the NET interface associated with the Opencores MAC.
 * @return SUCCESS
 */
int eth_ocm_close(int iface)
{
 3222a58:	defff904 	addi	sp,sp,-28
 3222a5c:	dfc00615 	stw	ra,24(sp)
 3222a60:	df000515 	stw	fp,20(sp)
 3222a64:	df000504 	addi	fp,sp,20
 3222a68:	e13ffe15 	stw	r4,-8(fp)
  int err;
  NET ifp;
  eth_ocm_dev *dev;

  /* status = down */
  ifp = nets[iface];
 3222a6c:	e0bffe17 	ldw	r2,-8(fp)
 3222a70:	00c0c9b4 	movhi	r3,806
 3222a74:	18f34504 	addi	r3,r3,-13036
 3222a78:	1085883a 	add	r2,r2,r2
 3222a7c:	1085883a 	add	r2,r2,r2
 3222a80:	10c5883a 	add	r2,r2,r3
 3222a84:	10800017 	ldw	r2,0(r2)
 3222a88:	e0bffc15 	stw	r2,-16(fp)
  dev = (eth_ocm_dev *)ifp->n_local;
 3222a8c:	e0bffc17 	ldw	r2,-16(fp)
 3222a90:	10802817 	ldw	r2,160(r2)
 3222a94:	e0bffb15 	stw	r2,-20(fp)

  ifp->n_mib->ifAdminStatus = ETH_OCM_STATUS_DOWN;
 3222a98:	e0bffc17 	ldw	r2,-16(fp)
 3222a9c:	10c02717 	ldw	r3,156(r2)
 3222aa0:	00800084 	movi	r2,2
 3222aa4:	18800615 	stw	r2,24(r3)

  /* disable the interrupt in the OS*/
  err = alt_irq_register (dev->irq, 0, NULL);
 3222aa8:	e0bffb17 	ldw	r2,-20(fp)
 3222aac:	10800b03 	ldbu	r2,44(r2)
 3222ab0:	11003fcc 	andi	r4,r2,255
 3222ab4:	000b883a 	mov	r5,zero
 3222ab8:	000d883a 	mov	r6,zero
 3222abc:	323ac6c0 	call	323ac6c <alt_irq_register>
 3222ac0:	e0bffd15 	stw	r2,-12(fp)
  if (err){
 3222ac4:	e0bffd17 	ldw	r2,-12(fp)
 3222ac8:	1005003a 	cmpeq	r2,r2,zero
 3222acc:	1000071e 	bne	r2,zero,3222aec <eth_ocm_close+0x94>
    dprintf("[eth_ocm_close] Could not unregister interrupt, error = %d\n",err);
 3222ad0:	0100c974 	movhi	r4,805
 3222ad4:	213a5c04 	addi	r4,r4,-5776
 3222ad8:	e17ffd17 	ldw	r5,-12(fp)
 3222adc:	3206de00 	call	3206de0 <printf>
    return err;
 3222ae0:	e0bffd17 	ldw	r2,-12(fp)
 3222ae4:	e0bfff15 	stw	r2,-4(fp)
 3222ae8:	00000f06 	br	3222b28 <eth_ocm_close+0xd0>
  }

  // Shut down the MAC
  IOWR_ETH_OCM_MODER(dev->base, 0);
 3222aec:	e0bffb17 	ldw	r2,-20(fp)
 3222af0:	10800717 	ldw	r2,28(r2)
 3222af4:	10000035 	stwio	zero,0(r2)

  /* status = down */
  ifp->n_mib->ifOperStatus = ETH_OCM_STATUS_DOWN;
 3222af8:	e0bffc17 	ldw	r2,-16(fp)
 3222afc:	10c02717 	ldw	r3,156(r2)
 3222b00:	00800084 	movi	r2,2
 3222b04:	18800715 	stw	r2,28(r3)
  //deallocate memory for the eth_ocm_info struct allocated in eth_ocm_prep
  free(dev->info->rx_pkts);
 3222b08:	e0bffb17 	ldw	r2,-20(fp)
 3222b0c:	10801117 	ldw	r2,68(r2)
 3222b10:	11000417 	ldw	r4,16(r2)
 3222b14:	324bc980 	call	324bc98 <free>
  free(dev->info);
 3222b18:	e0bffb17 	ldw	r2,-20(fp)
 3222b1c:	11001117 	ldw	r4,68(r2)
 3222b20:	324bc980 	call	324bc98 <free>

  return SUCCESS;
 3222b24:	e03fff15 	stw	zero,-4(fp)
 3222b28:	e0bfff17 	ldw	r2,-4(fp)
}
 3222b2c:	e037883a 	mov	sp,fp
 3222b30:	dfc00117 	ldw	ra,4(sp)
 3222b34:	df000017 	ldw	fp,0(sp)
 3222b38:	dec00204 	addi	sp,sp,8
 3222b3c:	f800283a 	ret

03222b40 <close>:
 * (for files and device drivers) or the InterNiche soclose() function for
 * sockets.
 */
 
int close (int fd)
{
 3222b40:	defffc04 	addi	sp,sp,-16
 3222b44:	dfc00315 	stw	ra,12(sp)
 3222b48:	df000215 	stw	fp,8(sp)
 3222b4c:	df000204 	addi	fp,sp,8
 3222b50:	e13ffe15 	stw	r4,-8(fp)
  return (fd < ALT_MAX_FD) ? alt_close (fd) : t_socketclose ((long) fd);
 3222b54:	e0bffe17 	ldw	r2,-8(fp)
 3222b58:	10800808 	cmpgei	r2,r2,32
 3222b5c:	1000041e 	bne	r2,zero,3222b70 <close+0x30>
 3222b60:	e13ffe17 	ldw	r4,-8(fp)
 3222b64:	323a4380 	call	323a438 <alt_close>
 3222b68:	e0bfff15 	stw	r2,-4(fp)
 3222b6c:	00000306 	br	3222b7c <close+0x3c>
 3222b70:	e13ffe17 	ldw	r4,-8(fp)
 3222b74:	322f5200 	call	322f520 <t_socketclose>
 3222b78:	e0bfff15 	stw	r2,-4(fp)
 3222b7c:	e0bfff17 	ldw	r2,-4(fp)
}
 3222b80:	e037883a 	mov	sp,fp
 3222b84:	dfc00117 	ldw	ra,4(sp)
 3222b88:	df000017 	ldw	fp,0(sp)
 3222b8c:	dec00204 	addi	sp,sp,8
 3222b90:	f800283a 	ret

03222b94 <iniche_devices_init>:
 * total number of interfaces after initialization.
 */

int iniche_devices_init(
    int                         if_count)
{
 3222b94:	defff504 	addi	sp,sp,-44
 3222b98:	dfc00a15 	stw	ra,40(sp)
 3222b9c:	df000915 	stw	fp,36(sp)
 3222ba0:	df000904 	addi	fp,sp,36
 3222ba4:	e13fff15 	stw	r4,-4(fp)
                                netmask,
                                gw;
    int                         use_dhcp;

    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
 3222ba8:	d0a02a17 	ldw	r2,-32600(gp)
 3222bac:	e0bffa15 	stw	r2,-24(fp)
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));
 3222bb0:	d0a02a04 	addi	r2,gp,-32600
 3222bb4:	e0bff915 	stw	r2,-28(fp)

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 3222bb8:	00003e06 	br	3222cb4 <iniche_devices_init+0x120>
    {
        /* Initialize the InterNiche device data record. */
        p_dev->p_driver_data = p_dev;
 3222bbc:	e0fffa17 	ldw	r3,-24(fp)
 3222bc0:	e0bffa17 	ldw	r2,-24(fp)
 3222bc4:	18800415 	stw	r2,16(r3)
        p_dev->if_num = if_count;
 3222bc8:	e0fffa17 	ldw	r3,-24(fp)
 3222bcc:	e0bfff17 	ldw	r2,-4(fp)
 3222bd0:	18800515 	stw	r2,20(r3)
        p_dev->p_net = nets[p_dev->if_num];
 3222bd4:	e0bffa17 	ldw	r2,-24(fp)
 3222bd8:	10800517 	ldw	r2,20(r2)
 3222bdc:	00c0c9b4 	movhi	r3,806
 3222be0:	18f34504 	addi	r3,r3,-13036
 3222be4:	1085883a 	add	r2,r2,r2
 3222be8:	1085883a 	add	r2,r2,r2
 3222bec:	10c5883a 	add	r2,r2,r3
 3222bf0:	10c00017 	ldw	r3,0(r2)
 3222bf4:	e0bffa17 	ldw	r2,-24(fp)
 3222bf8:	10c00615 	stw	r3,24(r2)

        /* Perform device specific initialization. */
        (*(p_dev->init_func))(p_dev);
 3222bfc:	e0bffa17 	ldw	r2,-24(fp)
 3222c00:	10800317 	ldw	r2,12(r2)
 3222c04:	e13ffa17 	ldw	r4,-24(fp)
 3222c08:	103ee83a 	callr	r2

        /* Get the interface IP address. */
        p_net = p_dev->p_net;
 3222c0c:	e0bffa17 	ldw	r2,-24(fp)
 3222c10:	10800617 	ldw	r2,24(r2)
 3222c14:	e0bff815 	stw	r2,-32(fp)
                
        if (get_ip_addr(p_dev, &ipaddr, &netmask, &gw, &use_dhcp))
 3222c18:	e17ffb04 	addi	r5,fp,-20
 3222c1c:	e1bffc04 	addi	r6,fp,-16
 3222c20:	e1fffd04 	addi	r7,fp,-12
 3222c24:	e0bffe04 	addi	r2,fp,-8
 3222c28:	d8800015 	stw	r2,0(sp)
 3222c2c:	e13ffa17 	ldw	r4,-24(fp)
 3222c30:	32018fc0 	call	32018fc <get_ip_addr>
 3222c34:	1005003a 	cmpeq	r2,r2,zero
 3222c38:	1000181e 	bne	r2,zero,3222c9c <iniche_devices_init+0x108>
            /* 
             * OR in the DHCP flag, if enabled. This will allow any
             * application-specific flag setting in get_ip_addr(), such 
             * as enabling AUTOIP, to occur 
             */
            if (use_dhcp) {
 3222c3c:	e0bffe17 	ldw	r2,-8(fp)
 3222c40:	1005003a 	cmpeq	r2,r2,zero
 3222c44:	1000051e 	bne	r2,zero,3222c5c <iniche_devices_init+0xc8>
                p_net->n_flags |= NF_DHCPC;
 3222c48:	e0bff817 	ldw	r2,-32(fp)
 3222c4c:	10802a17 	ldw	r2,168(r2)
 3222c50:	10c04014 	ori	r3,r2,256
 3222c54:	e0bff817 	ldw	r2,-32(fp)
 3222c58:	10c02a15 	stw	r3,168(r2)
            }
#endif
            p_net->n_ipaddr = ipaddr;
 3222c5c:	e0fffb17 	ldw	r3,-20(fp)
 3222c60:	e0bff817 	ldw	r2,-32(fp)
 3222c64:	10c00a15 	stw	r3,40(r2)
            p_net->snmask = netmask;
 3222c68:	e0fffc17 	ldw	r3,-16(fp)
 3222c6c:	e0bff817 	ldw	r2,-32(fp)
 3222c70:	10c00c15 	stw	r3,48(r2)
            p_net->n_defgw = gw;
 3222c74:	e0fffd17 	ldw	r3,-12(fp)
 3222c78:	e0bff817 	ldw	r2,-32(fp)
 3222c7c:	10c00d15 	stw	r3,52(r2)
#ifdef IP_MULTICAST
	    p_net->n_mcastlist = mcastlist;
 3222c80:	e0fff817 	ldw	r3,-32(fp)
 3222c84:	0080c934 	movhi	r2,804
 3222c88:	10b2f304 	addi	r2,r2,-13364
 3222c8c:	18802b15 	stw	r2,172(r3)
#if defined (IGMP_V1) || defined (IGMP_V2)
            p_net->igmp_oper_mode = IGMP_MODE_DEFAULT;
 3222c90:	e0fff817 	ldw	r3,-32(fp)
 3222c94:	00800084 	movi	r2,2
 3222c98:	18802f05 	stb	r2,188(r3)
#endif  /* IGMPv1 or IGMPv2 */
#endif  /* IP_MULTICAST */
        }

        /* Initialize next device. */
        if_count++;
 3222c9c:	e0bfff17 	ldw	r2,-4(fp)
 3222ca0:	10800044 	addi	r2,r2,1
 3222ca4:	e0bfff15 	stw	r2,-4(fp)
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
 3222ca8:	e0bffa17 	ldw	r2,-24(fp)
 3222cac:	10800017 	ldw	r2,0(r2)
 3222cb0:	e0bffa15 	stw	r2,-24(fp)
    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 3222cb4:	e0fffa17 	ldw	r3,-24(fp)
 3222cb8:	e0bff917 	ldw	r2,-28(fp)
 3222cbc:	18bfbf1e 	bne	r3,r2,3222bbc <iniche_devices_init+0x28>
        /* Initialize next device. */
        if_count++;
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
    }

    return (if_count);
 3222cc0:	e0bfff17 	ldw	r2,-4(fp)
}
 3222cc4:	e037883a 	mov	sp,fp
 3222cc8:	dfc00117 	ldw	ra,4(sp)
 3222ccc:	df000017 	ldw	fp,0(sp)
 3222cd0:	dec00204 	addi	sp,sp,8
 3222cd4:	f800283a 	ret

03222cd8 <read>:
 * (for files and device drivers) or the InterNiche recvfrom() function for
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
 3222cd8:	defff804 	addi	sp,sp,-32
 3222cdc:	dfc00715 	stw	ra,28(sp)
 3222ce0:	df000615 	stw	fp,24(sp)
 3222ce4:	df000604 	addi	fp,sp,24
 3222ce8:	e13ffc15 	stw	r4,-16(fp)
 3222cec:	e17ffd15 	stw	r5,-12(fp)
 3222cf0:	e1bffe15 	stw	r6,-8(fp)
  return (fd < ALT_MAX_FD) ? alt_read (fd, ptr, len)
 3222cf4:	e0bffc17 	ldw	r2,-16(fp)
 3222cf8:	10800808 	cmpgei	r2,r2,32
 3222cfc:	1000061e 	bne	r2,zero,3222d18 <read+0x40>
 3222d00:	e13ffc17 	ldw	r4,-16(fp)
 3222d04:	e17ffd17 	ldw	r5,-12(fp)
 3222d08:	e1bffe17 	ldw	r6,-8(fp)
 3222d0c:	323ae2c0 	call	323ae2c <alt_read>
 3222d10:	e0bfff15 	stw	r2,-4(fp)
 3222d14:	00000806 	br	3222d38 <read+0x60>
 3222d18:	e1bffe17 	ldw	r6,-8(fp)
 3222d1c:	d8000015 	stw	zero,0(sp)
 3222d20:	d8000115 	stw	zero,4(sp)
 3222d24:	e13ffc17 	ldw	r4,-16(fp)
 3222d28:	e17ffd17 	ldw	r5,-12(fp)
 3222d2c:	000f883a 	mov	r7,zero
 3222d30:	32258f80 	call	32258f8 <bsd_recvfrom>
 3222d34:	e0bfff15 	stw	r2,-4(fp)
 3222d38:	e0bfff17 	ldw	r2,-4(fp)
                           : recvfrom(fd, ptr, len, 0, NULL, NULL);
}
 3222d3c:	e037883a 	mov	sp,fp
 3222d40:	dfc00117 	ldw	ra,4(sp)
 3222d44:	df000017 	ldw	fp,0(sp)
 3222d48:	dec00204 	addi	sp,sp,8
 3222d4c:	f800283a 	ret

03222d50 <write>:
 * This implementation vectors requests to either the HAL alt_write() function 
 * (for files and device drivers) or the InterNiche send() function for sockets.
 */

int write (int fd, const void *ptr, size_t len)
{
 3222d50:	defffa04 	addi	sp,sp,-24
 3222d54:	dfc00515 	stw	ra,20(sp)
 3222d58:	df000415 	stw	fp,16(sp)
 3222d5c:	df000404 	addi	fp,sp,16
 3222d60:	e13ffc15 	stw	r4,-16(fp)
 3222d64:	e17ffd15 	stw	r5,-12(fp)
 3222d68:	e1bffe15 	stw	r6,-8(fp)
  if (fd < ALT_MAX_FD)
 3222d6c:	e0bffc17 	ldw	r2,-16(fp)
 3222d70:	10800808 	cmpgei	r2,r2,32
 3222d74:	1000061e 	bne	r2,zero,3222d90 <write+0x40>
  {
    return alt_write (fd, ptr, len);
 3222d78:	e13ffc17 	ldw	r4,-16(fp)
 3222d7c:	e17ffd17 	ldw	r5,-12(fp)
 3222d80:	e1bffe17 	ldw	r6,-8(fp)
 3222d84:	323b2e40 	call	323b2e4 <alt_write>
 3222d88:	e0bfff15 	stw	r2,-4(fp)
 3222d8c:	00000606 	br	3222da8 <write+0x58>
  }
  else
  { 
    return send (fd, (void*) ptr, len, 0);
 3222d90:	e17ffd17 	ldw	r5,-12(fp)
 3222d94:	e1bffe17 	ldw	r6,-8(fp)
 3222d98:	e13ffc17 	ldw	r4,-16(fp)
 3222d9c:	000f883a 	mov	r7,zero
 3222da0:	322f2140 	call	322f214 <t_send>
 3222da4:	e0bfff15 	stw	r2,-4(fp)
 3222da8:	e0bfff17 	ldw	r2,-4(fp)
  }  
}
 3222dac:	e037883a 	mov	sp,fp
 3222db0:	dfc00117 	ldw	ra,4(sp)
 3222db4:	df000017 	ldw	fp,0(sp)
 3222db8:	dec00204 	addi	sp,sp,8
 3222dbc:	f800283a 	ret

03222dc0 <Netinit>:
 * a non-zero error code
 */

int
Netinit()
{
 3222dc0:	defff704 	addi	sp,sp,-36
 3222dc4:	dfc00815 	stw	ra,32(sp)
 3222dc8:	df000715 	stw	fp,28(sp)
 3222dcc:	df000704 	addi	fp,sp,28
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 3222dd0:	e03ffa15 	stw	zero,-24(fp)
 3222dd4:	00005806 	br	3222f38 <Netinit+0x178>
   {
      /* sanity check on mtu, et.al. We added this because earlier 
       * drivers were sloppy about setting them, but new
       * logic depends on these sizes.
       */
      if (nets[i]->n_mib->ifType == ETHERNET)   /* ethernet? */
 3222dd8:	e0bffa17 	ldw	r2,-24(fp)
 3222ddc:	00c0c9b4 	movhi	r3,806
 3222de0:	18f34504 	addi	r3,r3,-13036
 3222de4:	1085883a 	add	r2,r2,r2
 3222de8:	1085883a 	add	r2,r2,r2
 3222dec:	10c5883a 	add	r2,r2,r3
 3222df0:	10800017 	ldw	r2,0(r2)
 3222df4:	10802717 	ldw	r2,156(r2)
 3222df8:	10800217 	ldw	r2,8(r2)
 3222dfc:	10800198 	cmpnei	r2,r2,6
 3222e00:	1000261e 	bne	r2,zero,3222e9c <Netinit+0xdc>
      {
         if (nets[i]->n_mtu == 0)   /* let device code override */
 3222e04:	e0bffa17 	ldw	r2,-24(fp)
 3222e08:	00c0c9b4 	movhi	r3,806
 3222e0c:	18f34504 	addi	r3,r3,-13036
 3222e10:	1085883a 	add	r2,r2,r2
 3222e14:	1085883a 	add	r2,r2,r2
 3222e18:	10c5883a 	add	r2,r2,r3
 3222e1c:	10800017 	ldw	r2,0(r2)
 3222e20:	10800917 	ldw	r2,36(r2)
 3222e24:	1004c03a 	cmpne	r2,r2,zero
 3222e28:	1000091e 	bne	r2,zero,3222e50 <Netinit+0x90>
            nets[i]->n_mtu = 1514;
 3222e2c:	e0bffa17 	ldw	r2,-24(fp)
 3222e30:	00c0c9b4 	movhi	r3,806
 3222e34:	18f34504 	addi	r3,r3,-13036
 3222e38:	1085883a 	add	r2,r2,r2
 3222e3c:	1085883a 	add	r2,r2,r2
 3222e40:	10c5883a 	add	r2,r2,r3
 3222e44:	10c00017 	ldw	r3,0(r2)
 3222e48:	00817a84 	movi	r2,1514
 3222e4c:	18800915 	stw	r2,36(r3)

         if (nets[i]->n_lnh == 0)
 3222e50:	e0bffa17 	ldw	r2,-24(fp)
 3222e54:	00c0c9b4 	movhi	r3,806
 3222e58:	18f34504 	addi	r3,r3,-13036
 3222e5c:	1085883a 	add	r2,r2,r2
 3222e60:	1085883a 	add	r2,r2,r2
 3222e64:	10c5883a 	add	r2,r2,r3
 3222e68:	10800017 	ldw	r2,0(r2)
 3222e6c:	10800817 	ldw	r2,32(r2)
 3222e70:	1004c03a 	cmpne	r2,r2,zero
 3222e74:	1000091e 	bne	r2,zero,3222e9c <Netinit+0xdc>
         {
#ifdef IEEE_802_3
            nets[i]->n_lnh = ETHHDR_SIZE + sizeof(struct snap_hdr);
#else
            nets[i]->n_lnh = ETHHDR_SIZE;
 3222e78:	e0bffa17 	ldw	r2,-24(fp)
 3222e7c:	00c0c9b4 	movhi	r3,806
 3222e80:	18f34504 	addi	r3,r3,-13036
 3222e84:	1085883a 	add	r2,r2,r2
 3222e88:	1085883a 	add	r2,r2,r2
 3222e8c:	10c5883a 	add	r2,r2,r3
 3222e90:	10c00017 	ldw	r3,0(r2)
 3222e94:	00800404 	movi	r2,16
 3222e98:	18800815 	stw	r2,32(r3)
      {
         continue;
      }
#endif   /* IP_V6 */

      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
 3222e9c:	e0bffa17 	ldw	r2,-24(fp)
 3222ea0:	00c0c9b4 	movhi	r3,806
 3222ea4:	18f34504 	addi	r3,r3,-13036
 3222ea8:	1085883a 	add	r2,r2,r2
 3222eac:	1085883a 	add	r2,r2,r2
 3222eb0:	10c5883a 	add	r2,r2,r3
 3222eb4:	10800017 	ldw	r2,0(r2)
 3222eb8:	10800817 	ldw	r2,32(r2)
 3222ebc:	d0e8b817 	ldw	r3,-23840(gp)
 3222ec0:	e0ffff15 	stw	r3,-4(fp)
 3222ec4:	e0bffe15 	stw	r2,-8(fp)
 3222ec8:	e0bffe17 	ldw	r2,-8(fp)
 3222ecc:	e0ffff17 	ldw	r3,-4(fp)
 3222ed0:	10c0020e 	bge	r2,r3,3222edc <Netinit+0x11c>
 3222ed4:	e0bfff17 	ldw	r2,-4(fp)
 3222ed8:	e0bffe15 	stw	r2,-8(fp)
 3222edc:	e0fffe17 	ldw	r3,-8(fp)
 3222ee0:	d0e8b815 	stw	r3,-23840(gp)
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
 3222ee4:	e0bffa17 	ldw	r2,-24(fp)
 3222ee8:	00c0c9b4 	movhi	r3,806
 3222eec:	18f34504 	addi	r3,r3,-13036
 3222ef0:	1085883a 	add	r2,r2,r2
 3222ef4:	1085883a 	add	r2,r2,r2
 3222ef8:	10c5883a 	add	r2,r2,r3
 3222efc:	10800017 	ldw	r2,0(r2)
 3222f00:	10800917 	ldw	r2,36(r2)
 3222f04:	d0e8b917 	ldw	r3,-23836(gp)
 3222f08:	e0fffd15 	stw	r3,-12(fp)
 3222f0c:	e0bffc15 	stw	r2,-16(fp)
 3222f10:	e0bffc17 	ldw	r2,-16(fp)
 3222f14:	e0fffd17 	ldw	r3,-12(fp)
 3222f18:	10c0020e 	bge	r2,r3,3222f24 <Netinit+0x164>
 3222f1c:	e0bffd17 	ldw	r2,-12(fp)
 3222f20:	e0bffc15 	stw	r2,-16(fp)
 3222f24:	e0fffc17 	ldw	r3,-16(fp)
 3222f28:	d0e8b915 	stw	r3,-23836(gp)
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 3222f2c:	e0bffa17 	ldw	r2,-24(fp)
 3222f30:	10800044 	addi	r2,r2,1
 3222f34:	e0bffa15 	stw	r2,-24(fp)
 3222f38:	0080c974 	movhi	r2,805
 3222f3c:	10931d04 	addi	r2,r2,19572
 3222f40:	10800017 	ldw	r2,0(r2)
 3222f44:	1007883a 	mov	r3,r2
 3222f48:	e0bffa17 	ldw	r2,-24(fp)
 3222f4c:	10ffa216 	blt	r2,r3,3222dd8 <Netinit+0x18>
      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
   }

   /* set up the received packet queue */
   rcvdq.q_head = rcvdq.q_tail = NULL;
 3222f50:	0080c9b4 	movhi	r2,806
 3222f54:	10b28004 	addi	r2,r2,-13824
 3222f58:	10000115 	stw	zero,4(r2)
 3222f5c:	0080c9b4 	movhi	r2,806
 3222f60:	10b28004 	addi	r2,r2,-13824
 3222f64:	10c00117 	ldw	r3,4(r2)
 3222f68:	0080c9b4 	movhi	r2,806
 3222f6c:	10b28004 	addi	r2,r2,-13824
 3222f70:	10c00015 	stw	r3,0(r2)
   rcvdq.q_max = rcvdq.q_min = rcvdq.q_len = 0;
 3222f74:	0080c9b4 	movhi	r2,806
 3222f78:	10b28004 	addi	r2,r2,-13824
 3222f7c:	10000215 	stw	zero,8(r2)
 3222f80:	0080c9b4 	movhi	r2,806
 3222f84:	10b28004 	addi	r2,r2,-13824
 3222f88:	10c00217 	ldw	r3,8(r2)
 3222f8c:	0080c9b4 	movhi	r2,806
 3222f90:	10b28004 	addi	r2,r2,-13824
 3222f94:	10c00415 	stw	r3,16(r2)
 3222f98:	0080c9b4 	movhi	r2,806
 3222f9c:	10b28004 	addi	r2,r2,-13824
 3222fa0:	10c00417 	ldw	r3,16(r2)
 3222fa4:	0080c9b4 	movhi	r2,806
 3222fa8:	10b28004 	addi	r2,r2,-13824
 3222fac:	10c00315 	stw	r3,12(r2)

   /* initialize freeq */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 3222fb0:	01000084 	movi	r4,2
 3222fb4:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   e = pk_init();
 3222fb8:	322a01c0 	call	322a01c <pk_init>
 3222fbc:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3222fc0:	01000084 	movi	r4,2
 3222fc4:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   if (e)   /* report error (memory ran out?) */
 3222fc8:	e0bff917 	ldw	r2,-28(fp)
 3222fcc:	1005003a 	cmpeq	r2,r2,zero
 3222fd0:	1000031e 	bne	r2,zero,3222fe0 <Netinit+0x220>
      return e;
 3222fd4:	e0bff917 	ldw	r2,-28(fp)
 3222fd8:	e0bffb15 	stw	r2,-20(fp)
 3222fdc:	00010506 	br	32233f4 <Netinit+0x634>

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */
 3222fe0:	0100c8b4 	movhi	r4,802
 3222fe4:	210d5b04 	addi	r4,r4,13676
 3222fe8:	3223f800 	call	3223f80 <exit_hook>

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 3222fec:	e03ffa15 	stw	zero,-24(fp)
 3222ff0:	0000f906 	br	32233d8 <Netinit+0x618>
   {
      if (nets[i]->n_init != NULL)  /* If iface has init routine... */
 3222ff4:	e0bffa17 	ldw	r2,-24(fp)
 3222ff8:	00c0c9b4 	movhi	r3,806
 3222ffc:	18f34504 	addi	r3,r3,-13036
 3223000:	1085883a 	add	r2,r2,r2
 3223004:	1085883a 	add	r2,r2,r2
 3223008:	10c5883a 	add	r2,r2,r3
 322300c:	10800017 	ldw	r2,0(r2)
 3223010:	10800217 	ldw	r2,8(r2)
 3223014:	1005003a 	cmpeq	r2,r2,zero
 3223018:	1000931e 	bne	r2,zero,3223268 <Netinit+0x4a8>
      {
         if ((e = (*nets[i]->n_init)(i)) != 0)  /* call init routine */
 322301c:	e0bffa17 	ldw	r2,-24(fp)
 3223020:	00c0c9b4 	movhi	r3,806
 3223024:	18f34504 	addi	r3,r3,-13036
 3223028:	1085883a 	add	r2,r2,r2
 322302c:	1085883a 	add	r2,r2,r2
 3223030:	10c5883a 	add	r2,r2,r3
 3223034:	10800017 	ldw	r2,0(r2)
 3223038:	10800217 	ldw	r2,8(r2)
 322303c:	e13ffa17 	ldw	r4,-24(fp)
 3223040:	103ee83a 	callr	r2
 3223044:	e0bff915 	stw	r2,-28(fp)
 3223048:	e0bff917 	ldw	r2,-28(fp)
 322304c:	1005003a 	cmpeq	r2,r2,zero
 3223050:	1000101e 	bne	r2,zero,3223094 <Netinit+0x2d4>
         {
            dprintf("init error %d on net[%d]\n", e, i);
 3223054:	0100c974 	movhi	r4,805
 3223058:	213a6b04 	addi	r4,r4,-5716
 322305c:	e17ff917 	ldw	r5,-28(fp)
 3223060:	e1bffa17 	ldw	r6,-24(fp)
 3223064:	3206de00 	call	3206de0 <printf>
            nets[i]->n_mib->ifOperStatus = NI_DOWN;
 3223068:	e0bffa17 	ldw	r2,-24(fp)
 322306c:	00c0c9b4 	movhi	r3,806
 3223070:	18f34504 	addi	r3,r3,-13036
 3223074:	1085883a 	add	r2,r2,r2
 3223078:	1085883a 	add	r2,r2,r2
 322307c:	10c5883a 	add	r2,r2,r3
 3223080:	10800017 	ldw	r2,0(r2)
 3223084:	10c02717 	ldw	r3,156(r2)
 3223088:	00800084 	movi	r2,2
 322308c:	18800715 	stw	r2,28(r3)
            continue;   /* ignore ifaces which fail */
 3223090:	0000ce06 	br	32233cc <Netinit+0x60c>
         }
         /* If interface is ethernet, set bcast flag bit. This
          * should really be done by the init routine, but we handle it
          * here to support MAC drivers which predate the flags field.
          */
         if(nets[i]->n_mib->ifType == ETHERNET)
 3223094:	e0bffa17 	ldw	r2,-24(fp)
 3223098:	00c0c9b4 	movhi	r3,806
 322309c:	18f34504 	addi	r3,r3,-13036
 32230a0:	1085883a 	add	r2,r2,r2
 32230a4:	1085883a 	add	r2,r2,r2
 32230a8:	10c5883a 	add	r2,r2,r3
 32230ac:	10800017 	ldw	r2,0(r2)
 32230b0:	10802717 	ldw	r2,156(r2)
 32230b4:	10800217 	ldw	r2,8(r2)
 32230b8:	10800198 	cmpnei	r2,r2,6
 32230bc:	1000111e 	bne	r2,zero,3223104 <Netinit+0x344>
            nets[i]->n_flags |= NF_BCAST;
 32230c0:	e0bffa17 	ldw	r2,-24(fp)
 32230c4:	00c0c9b4 	movhi	r3,806
 32230c8:	18f34504 	addi	r3,r3,-13036
 32230cc:	1085883a 	add	r2,r2,r2
 32230d0:	1085883a 	add	r2,r2,r2
 32230d4:	10c5883a 	add	r2,r2,r3
 32230d8:	11000017 	ldw	r4,0(r2)
 32230dc:	e0bffa17 	ldw	r2,-24(fp)
 32230e0:	00c0c9b4 	movhi	r3,806
 32230e4:	18f34504 	addi	r3,r3,-13036
 32230e8:	1085883a 	add	r2,r2,r2
 32230ec:	1085883a 	add	r2,r2,r2
 32230f0:	10c5883a 	add	r2,r2,r3
 32230f4:	10800017 	ldw	r2,0(r2)
 32230f8:	10802a17 	ldw	r2,168(r2)
 32230fc:	10800054 	ori	r2,r2,1
 3223100:	20802a15 	stw	r2,168(r4)

         /* set ifAdminStatus in case init() routine forgot to. IfOperStatus
          * is not nessecarily up at this point, as in the case of a modem which
          * is now in autoanswer mode.
          */
         nets[i]->n_mib->ifAdminStatus = NI_UP;
 3223104:	e0bffa17 	ldw	r2,-24(fp)
 3223108:	00c0c9b4 	movhi	r3,806
 322310c:	18f34504 	addi	r3,r3,-13036
 3223110:	1085883a 	add	r2,r2,r2
 3223114:	1085883a 	add	r2,r2,r2
 3223118:	10c5883a 	add	r2,r2,r3
 322311c:	10800017 	ldw	r2,0(r2)
 3223120:	10c02717 	ldw	r3,156(r2)
 3223124:	00800044 	movi	r2,1
 3223128:	18800615 	stw	r2,24(r3)

         /* assign default names to unnamed ifaces */
         if(nets[i]->name[0] == 0)     /* no name set by prep or init */
 322312c:	e0bffa17 	ldw	r2,-24(fp)
 3223130:	00c0c9b4 	movhi	r3,806
 3223134:	18f34504 	addi	r3,r3,-13036
 3223138:	1085883a 	add	r2,r2,r2
 322313c:	1085883a 	add	r2,r2,r2
 3223140:	10c5883a 	add	r2,r2,r3
 3223144:	10800017 	ldw	r2,0(r2)
 3223148:	10800103 	ldbu	r2,4(r2)
 322314c:	10803fcc 	andi	r2,r2,255
 3223150:	1080201c 	xori	r2,r2,128
 3223154:	10bfe004 	addi	r2,r2,-128
 3223158:	1004c03a 	cmpne	r2,r2,zero
 322315c:	1000421e 	bne	r2,zero,3223268 <Netinit+0x4a8>
         {
            if(nets[i]->n_mib->ifType == ETHERNET)
 3223160:	e0bffa17 	ldw	r2,-24(fp)
 3223164:	00c0c9b4 	movhi	r3,806
 3223168:	18f34504 	addi	r3,r3,-13036
 322316c:	1085883a 	add	r2,r2,r2
 3223170:	1085883a 	add	r2,r2,r2
 3223174:	10c5883a 	add	r2,r2,r3
 3223178:	10800017 	ldw	r2,0(r2)
 322317c:	10802717 	ldw	r2,156(r2)
 3223180:	10800217 	ldw	r2,8(r2)
 3223184:	10800198 	cmpnei	r2,r2,6
 3223188:	1000131e 	bne	r2,zero,32231d8 <Netinit+0x418>
            {
               nets[i]->name[0] = 'e';    /* "et1", "et2", etc. */
 322318c:	e0bffa17 	ldw	r2,-24(fp)
 3223190:	00c0c9b4 	movhi	r3,806
 3223194:	18f34504 	addi	r3,r3,-13036
 3223198:	1085883a 	add	r2,r2,r2
 322319c:	1085883a 	add	r2,r2,r2
 32231a0:	10c5883a 	add	r2,r2,r3
 32231a4:	10c00017 	ldw	r3,0(r2)
 32231a8:	00801944 	movi	r2,101
 32231ac:	18800105 	stb	r2,4(r3)
               nets[i]->name[1] = 't';
 32231b0:	e0bffa17 	ldw	r2,-24(fp)
 32231b4:	00c0c9b4 	movhi	r3,806
 32231b8:	18f34504 	addi	r3,r3,-13036
 32231bc:	1085883a 	add	r2,r2,r2
 32231c0:	1085883a 	add	r2,r2,r2
 32231c4:	10c5883a 	add	r2,r2,r3
 32231c8:	10c00017 	ldw	r3,0(r2)
 32231cc:	00801d04 	movi	r2,116
 32231d0:	18800145 	stb	r2,5(r3)
 32231d4:	00001206 	br	3223220 <Netinit+0x460>
            }
            else
            {
               nets[i]->name[0] = 'i';    /* "if1", "if2", etc. */
 32231d8:	e0bffa17 	ldw	r2,-24(fp)
 32231dc:	00c0c9b4 	movhi	r3,806
 32231e0:	18f34504 	addi	r3,r3,-13036
 32231e4:	1085883a 	add	r2,r2,r2
 32231e8:	1085883a 	add	r2,r2,r2
 32231ec:	10c5883a 	add	r2,r2,r3
 32231f0:	10c00017 	ldw	r3,0(r2)
 32231f4:	00801a44 	movi	r2,105
 32231f8:	18800105 	stb	r2,4(r3)
               nets[i]->name[1] = 'f';
 32231fc:	e0bffa17 	ldw	r2,-24(fp)
 3223200:	00c0c9b4 	movhi	r3,806
 3223204:	18f34504 	addi	r3,r3,-13036
 3223208:	1085883a 	add	r2,r2,r2
 322320c:	1085883a 	add	r2,r2,r2
 3223210:	10c5883a 	add	r2,r2,r3
 3223214:	10c00017 	ldw	r3,0(r2)
 3223218:	00801984 	movi	r2,102
 322321c:	18800145 	stb	r2,5(r3)
            }
            nets[i]->name[2] = (char)(i + '1');
 3223220:	e0bffa17 	ldw	r2,-24(fp)
 3223224:	00c0c9b4 	movhi	r3,806
 3223228:	18f34504 	addi	r3,r3,-13036
 322322c:	1085883a 	add	r2,r2,r2
 3223230:	1085883a 	add	r2,r2,r2
 3223234:	10c5883a 	add	r2,r2,r3
 3223238:	10c00017 	ldw	r3,0(r2)
 322323c:	e0bffa17 	ldw	r2,-24(fp)
 3223240:	10800c44 	addi	r2,r2,49
 3223244:	18800185 	stb	r2,6(r3)
            nets[i]->name[3] = '\0';
 3223248:	e0bffa17 	ldw	r2,-24(fp)
 322324c:	00c0c9b4 	movhi	r3,806
 3223250:	18f34504 	addi	r3,r3,-13036
 3223254:	1085883a 	add	r2,r2,r2
 3223258:	1085883a 	add	r2,r2,r2
 322325c:	10c5883a 	add	r2,r2,r3
 3223260:	10800017 	ldw	r2,0(r2)
 3223264:	100001c5 	stb	zero,7(r2)
         }
      }
      /* check on subnet routing - if no mask then make one */
      fixup_subnet_mask(i);      /* make mask for this net */
 3223268:	e13ffa17 	ldw	r4,-24(fp)
 322326c:	322340c0 	call	322340c <fixup_subnet_mask>

      /* build broadcast addresses */
      if(nets[i]->n_ipaddr != 0)
 3223270:	e0bffa17 	ldw	r2,-24(fp)
 3223274:	00c0c9b4 	movhi	r3,806
 3223278:	18f34504 	addi	r3,r3,-13036
 322327c:	1085883a 	add	r2,r2,r2
 3223280:	1085883a 	add	r2,r2,r2
 3223284:	10c5883a 	add	r2,r2,r3
 3223288:	10800017 	ldw	r2,0(r2)
 322328c:	10800a17 	ldw	r2,40(r2)
 3223290:	1005003a 	cmpeq	r2,r2,zero
 3223294:	10004d1e 	bne	r2,zero,32233cc <Netinit+0x60c>
      {
         nets[i]->n_netbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 3223298:	e0bffa17 	ldw	r2,-24(fp)
 322329c:	00c0c9b4 	movhi	r3,806
 32232a0:	18f34504 	addi	r3,r3,-13036
 32232a4:	1085883a 	add	r2,r2,r2
 32232a8:	1085883a 	add	r2,r2,r2
 32232ac:	10c5883a 	add	r2,r2,r3
 32232b0:	11400017 	ldw	r5,0(r2)
 32232b4:	e0bffa17 	ldw	r2,-24(fp)
 32232b8:	00c0c9b4 	movhi	r3,806
 32232bc:	18f34504 	addi	r3,r3,-13036
 32232c0:	1085883a 	add	r2,r2,r2
 32232c4:	1085883a 	add	r2,r2,r2
 32232c8:	10c5883a 	add	r2,r2,r3
 32232cc:	10800017 	ldw	r2,0(r2)
 32232d0:	11000a17 	ldw	r4,40(r2)
 32232d4:	e0bffa17 	ldw	r2,-24(fp)
 32232d8:	00c0c9b4 	movhi	r3,806
 32232dc:	18f34504 	addi	r3,r3,-13036
 32232e0:	1085883a 	add	r2,r2,r2
 32232e4:	1085883a 	add	r2,r2,r2
 32232e8:	10c5883a 	add	r2,r2,r3
 32232ec:	10800017 	ldw	r2,0(r2)
 32232f0:	10800c17 	ldw	r2,48(r2)
 32232f4:	0084303a 	nor	r2,zero,r2
 32232f8:	2084b03a 	or	r2,r4,r2
 32232fc:	28800e15 	stw	r2,56(r5)
         nets[i]->n_netbr42 = nets[i]->n_ipaddr & nets[i]->snmask;
 3223300:	e0bffa17 	ldw	r2,-24(fp)
 3223304:	00c0c9b4 	movhi	r3,806
 3223308:	18f34504 	addi	r3,r3,-13036
 322330c:	1085883a 	add	r2,r2,r2
 3223310:	1085883a 	add	r2,r2,r2
 3223314:	10c5883a 	add	r2,r2,r3
 3223318:	11400017 	ldw	r5,0(r2)
 322331c:	e0bffa17 	ldw	r2,-24(fp)
 3223320:	00c0c9b4 	movhi	r3,806
 3223324:	18f34504 	addi	r3,r3,-13036
 3223328:	1085883a 	add	r2,r2,r2
 322332c:	1085883a 	add	r2,r2,r2
 3223330:	10c5883a 	add	r2,r2,r3
 3223334:	10800017 	ldw	r2,0(r2)
 3223338:	11000a17 	ldw	r4,40(r2)
 322333c:	e0bffa17 	ldw	r2,-24(fp)
 3223340:	00c0c9b4 	movhi	r3,806
 3223344:	18f34504 	addi	r3,r3,-13036
 3223348:	1085883a 	add	r2,r2,r2
 322334c:	1085883a 	add	r2,r2,r2
 3223350:	10c5883a 	add	r2,r2,r3
 3223354:	10800017 	ldw	r2,0(r2)
 3223358:	10800c17 	ldw	r2,48(r2)
 322335c:	2084703a 	and	r2,r4,r2
 3223360:	28800f15 	stw	r2,60(r5)
         nets[i]->n_subnetbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 3223364:	e0bffa17 	ldw	r2,-24(fp)
 3223368:	00c0c9b4 	movhi	r3,806
 322336c:	18f34504 	addi	r3,r3,-13036
 3223370:	1085883a 	add	r2,r2,r2
 3223374:	1085883a 	add	r2,r2,r2
 3223378:	10c5883a 	add	r2,r2,r3
 322337c:	11400017 	ldw	r5,0(r2)
 3223380:	e0bffa17 	ldw	r2,-24(fp)
 3223384:	00c0c9b4 	movhi	r3,806
 3223388:	18f34504 	addi	r3,r3,-13036
 322338c:	1085883a 	add	r2,r2,r2
 3223390:	1085883a 	add	r2,r2,r2
 3223394:	10c5883a 	add	r2,r2,r3
 3223398:	10800017 	ldw	r2,0(r2)
 322339c:	11000a17 	ldw	r4,40(r2)
 32233a0:	e0bffa17 	ldw	r2,-24(fp)
 32233a4:	00c0c9b4 	movhi	r3,806
 32233a8:	18f34504 	addi	r3,r3,-13036
 32233ac:	1085883a 	add	r2,r2,r2
 32233b0:	1085883a 	add	r2,r2,r2
 32233b4:	10c5883a 	add	r2,r2,r3
 32233b8:	10800017 	ldw	r2,0(r2)
 32233bc:	10800c17 	ldw	r2,48(r2)
 32233c0:	0084303a 	nor	r2,zero,r2
 32233c4:	2084b03a 	or	r2,r4,r2
 32233c8:	28801015 	stw	r2,64(r5)

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 32233cc:	e0bffa17 	ldw	r2,-24(fp)
 32233d0:	10800044 	addi	r2,r2,1
 32233d4:	e0bffa15 	stw	r2,-24(fp)
 32233d8:	0080c974 	movhi	r2,805
 32233dc:	10931d04 	addi	r2,r2,19572
 32233e0:	10800017 	ldw	r2,0(r2)
 32233e4:	1007883a 	mov	r3,r2
 32233e8:	e0bffa17 	ldw	r2,-24(fp)
 32233ec:	10ff0116 	blt	r2,r3,3222ff4 <Netinit+0x234>
#if defined(DYNAMIC_IFACES) && defined(IN_MENUS)
   /* Install dynamic iface menu */
   install_menu(&dynif_menu[0]);
#endif /* DYNAMIC_IFACES && IN_MENUS */

   return(0);
 32233f0:	e03ffb15 	stw	zero,-20(fp)
 32233f4:	e0bffb17 	ldw	r2,-20(fp)
}
 32233f8:	e037883a 	mov	sp,fp
 32233fc:	dfc00117 	ldw	ra,4(sp)
 3223400:	df000017 	ldw	fp,0(sp)
 3223404:	dec00204 	addi	sp,sp,8
 3223408:	f800283a 	ret

0322340c <fixup_subnet_mask>:
 * RETURNS: 
 */

void
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
 322340c:	defffc04 	addi	sp,sp,-16
 3223410:	dfc00315 	stw	ra,12(sp)
 3223414:	df000215 	stw	fp,8(sp)
 3223418:	df000204 	addi	fp,sp,8
 322341c:	e13fff15 	stw	r4,-4(fp)
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
 3223420:	e0bfff17 	ldw	r2,-4(fp)
 3223424:	00c0c9b4 	movhi	r3,806
 3223428:	18f34504 	addi	r3,r3,-13036
 322342c:	1085883a 	add	r2,r2,r2
 3223430:	1085883a 	add	r2,r2,r2
 3223434:	10c5883a 	add	r2,r2,r3
 3223438:	10800017 	ldw	r2,0(r2)
 322343c:	10800c17 	ldw	r2,48(r2)
 3223440:	1004c03a 	cmpne	r2,r2,zero
 3223444:	1000441e 	bne	r2,zero,3223558 <fixup_subnet_mask+0x14c>
      return;

   /* things depending on IP address class: */
   if ((nets[netnum]->n_ipaddr & AMASK) == AADDR)
 3223448:	e0bfff17 	ldw	r2,-4(fp)
 322344c:	00c0c9b4 	movhi	r3,806
 3223450:	18f34504 	addi	r3,r3,-13036
 3223454:	1085883a 	add	r2,r2,r2
 3223458:	1085883a 	add	r2,r2,r2
 322345c:	10c5883a 	add	r2,r2,r3
 3223460:	10800017 	ldw	r2,0(r2)
 3223464:	10800a17 	ldw	r2,40(r2)
 3223468:	1080200c 	andi	r2,r2,128
 322346c:	1004c03a 	cmpne	r2,r2,zero
 3223470:	1000031e 	bne	r2,zero,3223480 <fixup_subnet_mask+0x74>
      smask = 0xFF000000L;
 3223474:	00bfc034 	movhi	r2,65280
 3223478:	e0bffe15 	stw	r2,-8(fp)
 322347c:	00001f06 	br	32234fc <fixup_subnet_mask+0xf0>
   else if((nets[netnum]->n_ipaddr & BMASK) == BADDR)
 3223480:	e0bfff17 	ldw	r2,-4(fp)
 3223484:	00c0c9b4 	movhi	r3,806
 3223488:	18f34504 	addi	r3,r3,-13036
 322348c:	1085883a 	add	r2,r2,r2
 3223490:	1085883a 	add	r2,r2,r2
 3223494:	10c5883a 	add	r2,r2,r3
 3223498:	10800017 	ldw	r2,0(r2)
 322349c:	10800a17 	ldw	r2,40(r2)
 32234a0:	1080300c 	andi	r2,r2,192
 32234a4:	10802018 	cmpnei	r2,r2,128
 32234a8:	1000031e 	bne	r2,zero,32234b8 <fixup_subnet_mask+0xac>
      smask = 0xFFFF0000L;
 32234ac:	00bffff4 	movhi	r2,65535
 32234b0:	e0bffe15 	stw	r2,-8(fp)
 32234b4:	00001106 	br	32234fc <fixup_subnet_mask+0xf0>
   else if((nets[netnum]->n_ipaddr & CMASK) == CADDR)
 32234b8:	e0bfff17 	ldw	r2,-4(fp)
 32234bc:	00c0c9b4 	movhi	r3,806
 32234c0:	18f34504 	addi	r3,r3,-13036
 32234c4:	1085883a 	add	r2,r2,r2
 32234c8:	1085883a 	add	r2,r2,r2
 32234cc:	10c5883a 	add	r2,r2,r3
 32234d0:	10800017 	ldw	r2,0(r2)
 32234d4:	10800a17 	ldw	r2,40(r2)
 32234d8:	1080380c 	andi	r2,r2,224
 32234dc:	10803018 	cmpnei	r2,r2,192
 32234e0:	1000031e 	bne	r2,zero,32234f0 <fixup_subnet_mask+0xe4>
      smask = 0xFFFFFF00L;
 32234e4:	00bfc004 	movi	r2,-256
 32234e8:	e0bffe15 	stw	r2,-8(fp)
 32234ec:	00000306 	br	32234fc <fixup_subnet_mask+0xf0>
   else
   {
      dtrap();    /* bad logic or setup values */
 32234f0:	322aef00 	call	322aef0 <dtrap>
      smask = 0xFFFFFF00L;
 32234f4:	00bfc004 	movi	r2,-256
 32234f8:	e0bffe15 	stw	r2,-8(fp)
   }
   nets[netnum]->snmask = htonl(smask);
 32234fc:	e0bfff17 	ldw	r2,-4(fp)
 3223500:	00c0c9b4 	movhi	r3,806
 3223504:	18f34504 	addi	r3,r3,-13036
 3223508:	1085883a 	add	r2,r2,r2
 322350c:	1085883a 	add	r2,r2,r2
 3223510:	10c5883a 	add	r2,r2,r3
 3223514:	11000017 	ldw	r4,0(r2)
 3223518:	e0bffe17 	ldw	r2,-8(fp)
 322351c:	1004d63a 	srli	r2,r2,24
 3223520:	10c03fcc 	andi	r3,r2,255
 3223524:	e0bffe17 	ldw	r2,-8(fp)
 3223528:	1004d23a 	srli	r2,r2,8
 322352c:	10bfc00c 	andi	r2,r2,65280
 3223530:	1886b03a 	or	r3,r3,r2
 3223534:	e0bffe17 	ldw	r2,-8(fp)
 3223538:	10bfc00c 	andi	r2,r2,65280
 322353c:	1004923a 	slli	r2,r2,8
 3223540:	1886b03a 	or	r3,r3,r2
 3223544:	e0bffe17 	ldw	r2,-8(fp)
 3223548:	10803fcc 	andi	r2,r2,255
 322354c:	1004963a 	slli	r2,r2,24
 3223550:	1884b03a 	or	r2,r3,r2
 3223554:	20800c15 	stw	r2,48(r4)
}
 3223558:	e037883a 	mov	sp,fp
 322355c:	dfc00117 	ldw	ra,4(sp)
 3223560:	df000017 	ldw	fp,0(sp)
 3223564:	dec00204 	addi	sp,sp,8
 3223568:	f800283a 	ret

0322356c <netclose>:
 * RETURNS: 
 */

void
netclose()
{
 322356c:	defffc04 	addi	sp,sp,-16
 3223570:	dfc00315 	stw	ra,12(sp)
 3223574:	df000215 	stw	fp,8(sp)
 3223578:	df000204 	addi	fp,sp,8
   NET ifp;
   int index = 0;
 322357c:	e03ffe15 	stw	zero,-8(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
 3223580:	d0a8ba17 	ldw	r2,-23832(gp)
 3223584:	1080010c 	andi	r2,r2,4
 3223588:	1005003a 	cmpeq	r2,r2,zero
 322358c:	1000031e 	bne	r2,zero,322359c <netclose+0x30>
 3223590:	0100c974 	movhi	r4,805
 3223594:	213a7204 	addi	r4,r4,-5688
 3223598:	32071080 	call	3207108 <puts>
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 322359c:	0080c9b4 	movhi	r2,806
 32235a0:	10b54604 	addi	r2,r2,-10984
 32235a4:	10800017 	ldw	r2,0(r2)
 32235a8:	e0bfff15 	stw	r2,-4(fp)
 32235ac:	00002106 	br	3223634 <netclose+0xc8>
   {
      if (ifp->n_close)
 32235b0:	e0bfff17 	ldw	r2,-4(fp)
 32235b4:	10800517 	ldw	r2,20(r2)
 32235b8:	1005003a 	cmpeq	r2,r2,zero
 32235bc:	10000e1e 	bne	r2,zero,32235f8 <netclose+0x8c>
      {
         dprintf("netclose: closing iface %s\n", ifp->n_mib->ifDescr);
 32235c0:	e0bfff17 	ldw	r2,-4(fp)
 32235c4:	10802717 	ldw	r2,156(r2)
 32235c8:	11400117 	ldw	r5,4(r2)
 32235cc:	0100c974 	movhi	r4,805
 32235d0:	213a7704 	addi	r4,r4,-5668
 32235d4:	3206de00 	call	3206de0 <printf>
         (*(ifp->n_close))(index++);
 32235d8:	e0bfff17 	ldw	r2,-4(fp)
 32235dc:	10c00517 	ldw	r3,20(r2)
 32235e0:	e13ffe17 	ldw	r4,-8(fp)
 32235e4:	e0bffe17 	ldw	r2,-8(fp)
 32235e8:	10800044 	addi	r2,r2,1
 32235ec:	e0bffe15 	stw	r2,-8(fp)
 32235f0:	183ee83a 	callr	r3
 32235f4:	00000c06 	br	3223628 <netclose+0xbc>
      }
      else
      {
#ifdef NPDEBUG
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
 32235f8:	d0a8ba17 	ldw	r2,-23832(gp)
 32235fc:	1080010c 	andi	r2,r2,4
 3223600:	1005003a 	cmpeq	r2,r2,zero
 3223604:	1000051e 	bne	r2,zero,322361c <netclose+0xb0>
 3223608:	e0bfff17 	ldw	r2,-4(fp)
 322360c:	11400104 	addi	r5,r2,4
 3223610:	0100c974 	movhi	r4,805
 3223614:	213a7e04 	addi	r4,r4,-5640
 3223618:	3206de00 	call	3206de0 <printf>
#endif
         index++;
 322361c:	e0bffe17 	ldw	r2,-8(fp)
 3223620:	10800044 	addi	r2,r2,1
 3223624:	e0bffe15 	stw	r2,-8(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 3223628:	e0bfff17 	ldw	r2,-4(fp)
 322362c:	10800017 	ldw	r2,0(r2)
 3223630:	e0bfff15 	stw	r2,-4(fp)
 3223634:	e0bfff17 	ldw	r2,-4(fp)
 3223638:	1004c03a 	cmpne	r2,r2,zero
 322363c:	103fdc1e 	bne	r2,zero,32235b0 <netclose+0x44>
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
#endif
         index++;
      }
   }
}
 3223640:	e037883a 	mov	sp,fp
 3223644:	dfc00117 	ldw	ra,4(sp)
 3223648:	df000017 	ldw	fp,0(sp)
 322364c:	dec00204 	addi	sp,sp,8
 3223650:	f800283a 	ret

03223654 <pktdemux>:
 * RETURNS: void
 */

void
pktdemux()
{
 3223654:	defff804 	addi	sp,sp,-32
 3223658:	dfc00715 	stw	ra,28(sp)
 322365c:	df000615 	stw	fp,24(sp)
 3223660:	df000604 	addi	fp,sp,24
   NET      ifc;                /* interface packet came from */
   IFMIB    mib;
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */
 3223664:	e03ffb15 	stw	zero,-20(fp)

   while (rcvdq.q_len)
 3223668:	0000e506 	br	3223a00 <pktdemux+0x3ac>
   {
      /* If we are low on free packets, don't hog CPU cycles */
      if (pkts++ > bigfreeq.q_len)
 322366c:	0080c9b4 	movhi	r2,806
 3223670:	10b3ec04 	addi	r2,r2,-12368
 3223674:	10c00217 	ldw	r3,8(r2)
 3223678:	e0bffb17 	ldw	r2,-20(fp)
 322367c:	1884803a 	cmplt	r2,r3,r2
 3223680:	1007883a 	mov	r3,r2
 3223684:	e0bffb17 	ldw	r2,-20(fp)
 3223688:	10800044 	addi	r2,r2,1
 322368c:	e0bffb15 	stw	r2,-20(fp)
 3223690:	18803fcc 	andi	r2,r3,255
 3223694:	1005003a 	cmpeq	r2,r2,zero
 3223698:	1000021e 	bne	r2,zero,32236a4 <pktdemux+0x50>
      {
#ifdef SUPERLOOP
         return;        /* don't hog stack on superloop */
#else    /* SUPERLOOP */
         tk_yield(); /* let application tasks process received packets */
 322369c:	3226ddc0 	call	3226ddc <tk_yield>
         pkts = 0;   /* reset counter */
 32236a0:	e03ffb15 	stw	zero,-20(fp)
#endif   /* SUPERLOOP else */
      }

      /* If we get receive interupt from the net during this
      lock, the MAC driver needs to wait or reschedule */
      LOCK_NET_RESOURCE(RXQ_RESID);
 32236a4:	01000044 	movi	r4,1
 32236a8:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pkt = (PACKET)q_deq(&rcvdq);
 32236ac:	0100c9b4 	movhi	r4,806
 32236b0:	21328004 	addi	r4,r4,-13824
 32236b4:	322a7b80 	call	322a7b8 <getq>
 32236b8:	e0bffe15 	stw	r2,-8(fp)
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 32236bc:	01000044 	movi	r4,1
 32236c0:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      if (!pkt) panic("pktdemux: got null pkt");
 32236c4:	e0bffe17 	ldw	r2,-8(fp)
 32236c8:	1004c03a 	cmpne	r2,r2,zero
 32236cc:	1000031e 	bne	r2,zero,32236dc <pktdemux+0x88>
 32236d0:	0100c974 	movhi	r4,805
 32236d4:	213a8504 	addi	r4,r4,-5612
 32236d8:	32261540 	call	3226154 <panic>
      ifc = pkt->net;
 32236dc:	e0bffe17 	ldw	r2,-8(fp)
 32236e0:	10800617 	ldw	r2,24(r2)
 32236e4:	e0bffd15 	stw	r2,-12(fp)

      mib = ifc->n_mib;
 32236e8:	e0bffd17 	ldw	r2,-12(fp)
 32236ec:	10802717 	ldw	r2,156(r2)
 32236f0:	e0bffc15 	stw	r2,-16(fp)
      /* maintain mib stats for unicast and broadcast */
      if (isbcast(ifc, (u_char*)pkt->nb_buff + ETHHDR_BIAS))
 32236f4:	e0bffe17 	ldw	r2,-8(fp)
 32236f8:	10800117 	ldw	r2,4(r2)
 32236fc:	11400084 	addi	r5,r2,2
 3223700:	e13ffd17 	ldw	r4,-12(fp)
 3223704:	323e7400 	call	323e740 <isbcast>
 3223708:	1005003a 	cmpeq	r2,r2,zero
 322370c:	1000061e 	bne	r2,zero,3223728 <pktdemux+0xd4>
         mib->ifInNUcastPkts++;
 3223710:	e0bffc17 	ldw	r2,-16(fp)
 3223714:	10800b17 	ldw	r2,44(r2)
 3223718:	10c00044 	addi	r3,r2,1
 322371c:	e0bffc17 	ldw	r2,-16(fp)
 3223720:	10c00b15 	stw	r3,44(r2)
 3223724:	00000506 	br	322373c <pktdemux+0xe8>
      else
         mib->ifInUcastPkts++;
 3223728:	e0bffc17 	ldw	r2,-16(fp)
 322372c:	10800a17 	ldw	r2,40(r2)
 3223730:	10c00044 	addi	r3,r2,1
 3223734:	e0bffc17 	ldw	r2,-16(fp)
 3223738:	10c00a15 	stw	r3,40(r2)

      if(mib->ifAdminStatus == NI_DOWN)
 322373c:	e0bffc17 	ldw	r2,-16(fp)
 3223740:	10800617 	ldw	r2,24(r2)
 3223744:	10800098 	cmpnei	r2,r2,2
 3223748:	10000c1e 	bne	r2,zero,322377c <pktdemux+0x128>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 322374c:	01000084 	movi	r4,2
 3223750:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pk_free(pkt);  /* dump packet from downed interface */
 3223754:	e13ffe17 	ldw	r4,-8(fp)
 3223758:	322a6400 	call	322a640 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322375c:	01000084 	movi	r4,2
 3223760:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         mib->ifInDiscards++;
 3223764:	e0bffc17 	ldw	r2,-16(fp)
 3223768:	10800c17 	ldw	r2,48(r2)
 322376c:	10c00044 	addi	r3,r2,1
 3223770:	e0bffc17 	ldw	r2,-16(fp)
 3223774:	10c00c15 	stw	r3,48(r2)
         continue;      /* next packet */
 3223778:	0000a106 	br	3223a00 <pktdemux+0x3ac>
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 322377c:	e0bffe17 	ldw	r2,-8(fp)
 3223780:	10800117 	ldw	r2,4(r2)
 3223784:	10bfff04 	addi	r2,r2,-4
 3223788:	10800003 	ldbu	r2,0(r2)
 322378c:	10803fcc 	andi	r2,r2,255
 3223790:	1080201c 	xori	r2,r2,128
 3223794:	10bfe004 	addi	r2,r2,-128
 3223798:	10801358 	cmpnei	r2,r2,77
 322379c:	10000b1e 	bne	r2,zero,32237cc <pktdemux+0x178>
 32237a0:	e0bffe17 	ldw	r2,-8(fp)
 32237a4:	10c00117 	ldw	r3,4(r2)
 32237a8:	e0bffe17 	ldw	r2,-8(fp)
 32237ac:	10800217 	ldw	r2,8(r2)
 32237b0:	1885883a 	add	r2,r3,r2
 32237b4:	10800003 	ldbu	r2,0(r2)
 32237b8:	10803fcc 	andi	r2,r2,255
 32237bc:	1080201c 	xori	r2,r2,128
 32237c0:	10bfe004 	addi	r2,r2,-128
 32237c4:	10801360 	cmpeqi	r2,r2,77
 32237c8:	1000041e 	bne	r2,zero,32237dc <pktdemux+0x188>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
      {
         dtrap();
 32237cc:	322aef00 	call	322aef0 <dtrap>
         panic("pktdemux: corrupt pkt");
 32237d0:	0100c974 	movhi	r4,805
 32237d4:	213a8b04 	addi	r4,r4,-5588
 32237d8:	32261540 	call	3226154 <panic>
         }
      }
#endif   /* LOSSY_IO */

      /* see if driver set pkt->nb_prot and pkt->type */
      if((ifc->n_flags & NF_NBPROT) == 0)
 32237dc:	e0bffd17 	ldw	r2,-12(fp)
 32237e0:	10802a17 	ldw	r2,168(r2)
 32237e4:	1080020c 	andi	r2,r2,8
 32237e8:	1004c03a 	cmpne	r2,r2,zero
 32237ec:	10004d1e 	bne	r2,zero,3223924 <pktdemux+0x2d0>
          * probably the right thing to do, but because of this historic
          * inconsistency we don't try to fix it here - the longer size
          * turns out to be harmless since the IP layer fixes the size
          * based on the IP header length field.
          */
         switch(ifc->n_mib->ifType)
 32237f0:	e0bffd17 	ldw	r2,-12(fp)
 32237f4:	10802717 	ldw	r2,156(r2)
 32237f8:	10800217 	ldw	r2,8(r2)
 32237fc:	108001a0 	cmpeqi	r2,r2,6
 3223800:	1000011e 	bne	r2,zero,3223808 <pktdemux+0x1b4>
 3223804:	00003a06 	br	32238f0 <pktdemux+0x29c>
         {
         case ETHERNET:
            /* get pointer to ethernet header */
            eth = (pkt->nb_buff + ETHHDR_BIAS);
 3223808:	e0bffe17 	ldw	r2,-8(fp)
 322380c:	10800117 	ldw	r2,4(r2)
 3223810:	10800084 	addi	r2,r2,2
 3223814:	e0bffa15 	stw	r2,-24(fp)
            {
               pkt->type = htons((unshort)ET_TYPE_GET(eth));
               pkt->nb_prot = pkt->nb_buff + ETHHDR_SIZE;
            }
#else
            pkt->type = htons((unshort)ET_TYPE_GET(eth));
 3223818:	e0bffa17 	ldw	r2,-24(fp)
 322381c:	10800304 	addi	r2,r2,12
 3223820:	10800003 	ldbu	r2,0(r2)
 3223824:	10803fcc 	andi	r2,r2,255
 3223828:	1080201c 	xori	r2,r2,128
 322382c:	10bfe004 	addi	r2,r2,-128
 3223830:	1004923a 	slli	r2,r2,8
 3223834:	1007883a 	mov	r3,r2
 3223838:	e0bffa17 	ldw	r2,-24(fp)
 322383c:	10800344 	addi	r2,r2,13
 3223840:	10800003 	ldbu	r2,0(r2)
 3223844:	10803fcc 	andi	r2,r2,255
 3223848:	1080201c 	xori	r2,r2,128
 322384c:	10bfe004 	addi	r2,r2,-128
 3223850:	10803fcc 	andi	r2,r2,255
 3223854:	1885883a 	add	r2,r3,r2
 3223858:	10bfffcc 	andi	r2,r2,65535
 322385c:	1004d23a 	srli	r2,r2,8
 3223860:	10803fcc 	andi	r2,r2,255
 3223864:	1009883a 	mov	r4,r2
 3223868:	e0bffa17 	ldw	r2,-24(fp)
 322386c:	10800304 	addi	r2,r2,12
 3223870:	10800003 	ldbu	r2,0(r2)
 3223874:	10803fcc 	andi	r2,r2,255
 3223878:	1080201c 	xori	r2,r2,128
 322387c:	10bfe004 	addi	r2,r2,-128
 3223880:	1004923a 	slli	r2,r2,8
 3223884:	1007883a 	mov	r3,r2
 3223888:	e0bffa17 	ldw	r2,-24(fp)
 322388c:	10800344 	addi	r2,r2,13
 3223890:	10800003 	ldbu	r2,0(r2)
 3223894:	10803fcc 	andi	r2,r2,255
 3223898:	1080201c 	xori	r2,r2,128
 322389c:	10bfe004 	addi	r2,r2,-128
 32238a0:	10803fcc 	andi	r2,r2,255
 32238a4:	1885883a 	add	r2,r3,r2
 32238a8:	10bfffcc 	andi	r2,r2,65535
 32238ac:	1004923a 	slli	r2,r2,8
 32238b0:	1007883a 	mov	r3,r2
 32238b4:	00bfc004 	movi	r2,-256
 32238b8:	1884703a 	and	r2,r3,r2
 32238bc:	2084b03a 	or	r2,r4,r2
 32238c0:	1007883a 	mov	r3,r2
 32238c4:	e0bffe17 	ldw	r2,-8(fp)
 32238c8:	10c0080d 	sth	r3,32(r2)
            pkt->nb_prot = pkt->nb_buff + pkt->net->n_lnh;
 32238cc:	e0bffe17 	ldw	r2,-8(fp)
 32238d0:	10c00117 	ldw	r3,4(r2)
 32238d4:	e0bffe17 	ldw	r2,-8(fp)
 32238d8:	10800617 	ldw	r2,24(r2)
 32238dc:	10800817 	ldw	r2,32(r2)
 32238e0:	1887883a 	add	r3,r3,r2
 32238e4:	e0bffe17 	ldw	r2,-8(fp)
 32238e8:	10c00315 	stw	r3,12(r2)
#endif   /* IEEE_802_3 */
            break;
 32238ec:	00000d06 	br	3223924 <pktdemux+0x2d0>
         case PPPOE:
            /* do not change type yet, for PPPoE */
            break;
#endif   /* USE_PPPOE */
         default:    /* driver bug? */
            dprintf("pktdemux: bad Iface type %ld\n",ifc->n_mib->ifType);
 32238f0:	e0bffd17 	ldw	r2,-12(fp)
 32238f4:	10802717 	ldw	r2,156(r2)
 32238f8:	11400217 	ldw	r5,8(r2)
 32238fc:	0100c974 	movhi	r4,805
 3223900:	213a9104 	addi	r4,r4,-5564
 3223904:	3206de00 	call	3206de0 <printf>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 3223908:	01000084 	movi	r4,2
 322390c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
            pk_free(pkt);
 3223910:	e13ffe17 	ldw	r4,-8(fp)
 3223914:	322a6400 	call	322a640 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3223918:	01000084 	movi	r4,2
 322391c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
            continue;
 3223920:	00003706 	br	3223a00 <pktdemux+0x3ac>
         }
      }

      /* pkt->nb_prot and pkt->type are now set. pass pkt to upper layer */
      switch(pkt->type)
 3223924:	e0bffe17 	ldw	r2,-8(fp)
 3223928:	1080080b 	ldhu	r2,32(r2)
 322392c:	10bfffcc 	andi	r2,r2,65535
 3223930:	e0bfff15 	stw	r2,-4(fp)
 3223934:	e0ffff17 	ldw	r3,-4(fp)
 3223938:	18800220 	cmpeqi	r2,r3,8
 322393c:	1000041e 	bne	r2,zero,3223950 <pktdemux+0x2fc>
 3223940:	e0ffff17 	ldw	r3,-4(fp)
 3223944:	18818220 	cmpeqi	r2,r3,1544
 3223948:	1000081e 	bne	r2,zero,322396c <pktdemux+0x318>
 322394c:	00000e06 	br	3223988 <pktdemux+0x334>
      {
      case IPTP:     /* IP type */
         LOCK_NET_RESOURCE(NET_RESID);
 3223950:	0009883a 	mov	r4,zero
 3223954:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
#ifdef SHARED_IPADDRS
         add_share_route(pkt);
#endif /* SHARED_IPADDRS */
#ifdef IP_V4
         ip_rcv(pkt);
 3223958:	e13ffe17 	ldw	r4,-8(fp)
 322395c:	32429940 	call	3242994 <ip_rcv>
            /* don't care, it's IPv4 */
            LOCK_NET_RESOURCE(FREEQ_RESID);
            pk_free(pkt);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif
		UNLOCK_NET_RESOURCE(NET_RESID);
 3223960:	0009883a 	mov	r4,zero
 3223964:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         break;
 3223968:	00002506 	br	3223a00 <pktdemux+0x3ac>
#ifdef INCLUDE_ARP
      case ARPTP:       /* ARP type */
         LOCK_NET_RESOURCE(NET_RESID);
 322396c:	0009883a 	mov	r4,zero
 3223970:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         arprcv(pkt);
 3223974:	e13ffe17 	ldw	r4,-8(fp)
 3223978:	323ded00 	call	323ded0 <arprcv>
         UNLOCK_NET_RESOURCE(NET_RESID);
 322397c:	0009883a 	mov	r4,zero
 3223980:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         break;
 3223984:	00001e06 	br	3223a00 <pktdemux+0x3ac>
         UNLOCK_NET_RESOURCE(NET_RESID);
         break;
#endif
      default:
#ifdef NPDEBUG
         if (NDEBUG & UPCTRACE)
 3223988:	d0a8ba17 	ldw	r2,-23832(gp)
 322398c:	1081000c 	andi	r2,r2,1024
 3223990:	1005003a 	cmpeq	r2,r2,zero
 3223994:	10000f1e 	bne	r2,zero,32239d4 <pktdemux+0x380>
            dprintf("pktdemux: bad pkt type 0x%04x\n", ntohs(pkt->type));
 3223998:	e0bffe17 	ldw	r2,-8(fp)
 322399c:	1080080b 	ldhu	r2,32(r2)
 32239a0:	10bfffcc 	andi	r2,r2,65535
 32239a4:	1004d23a 	srli	r2,r2,8
 32239a8:	10bfffcc 	andi	r2,r2,65535
 32239ac:	10c03fcc 	andi	r3,r2,255
 32239b0:	e0bffe17 	ldw	r2,-8(fp)
 32239b4:	1080080b 	ldhu	r2,32(r2)
 32239b8:	10bfffcc 	andi	r2,r2,65535
 32239bc:	1004923a 	slli	r2,r2,8
 32239c0:	10bfc00c 	andi	r2,r2,65280
 32239c4:	188ab03a 	or	r5,r3,r2
 32239c8:	0100c974 	movhi	r4,805
 32239cc:	213a9904 	addi	r4,r4,-5532
 32239d0:	3206de00 	call	3206de0 <printf>
#endif   /* NPDEBUG */
         ifc->n_mib->ifInUnknownProtos++;
 32239d4:	e0bffd17 	ldw	r2,-12(fp)
 32239d8:	10c02717 	ldw	r3,156(r2)
 32239dc:	18800e17 	ldw	r2,56(r3)
 32239e0:	10800044 	addi	r2,r2,1
 32239e4:	18800e15 	stw	r2,56(r3)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 32239e8:	01000084 	movi	r4,2
 32239ec:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pk_free(pkt);           /* return to free buffer */
 32239f0:	e13ffe17 	ldw	r4,-8(fp)
 32239f4:	322a6400 	call	322a640 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32239f8:	01000084 	movi	r4,2
 32239fc:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */

   while (rcvdq.q_len)
 3223a00:	0080c9b4 	movhi	r2,806
 3223a04:	10b28004 	addi	r2,r2,-13824
 3223a08:	10800217 	ldw	r2,8(r2)
 3223a0c:	1004c03a 	cmpne	r2,r2,zero
 3223a10:	103f161e 	bne	r2,zero,322366c <pktdemux+0x18>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         break;
      }
      continue;
   }
}
 3223a14:	e037883a 	mov	sp,fp
 3223a18:	dfc00117 	ldw	ra,4(sp)
 3223a1c:	df000017 	ldw	fp,0(sp)
 3223a20:	dec00204 	addi	sp,sp,8
 3223a24:	f800283a 	ret

03223a28 <c_older>:
 * RETURNS: the older of the two passed tick counts
 */

u_long
c_older(u_long ct1, u_long ct2)
{
 3223a28:	defffc04 	addi	sp,sp,-16
 3223a2c:	df000315 	stw	fp,12(sp)
 3223a30:	df000304 	addi	fp,sp,12
 3223a34:	e13ffd15 	stw	r4,-12(fp)
 3223a38:	e17ffe15 	stw	r5,-8(fp)

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 3223a3c:	0080c974 	movhi	r2,805
 3223a40:	10934104 	addi	r2,r2,19716
 3223a44:	10800017 	ldw	r2,0(r2)
 3223a48:	1004403a 	cmpge	r2,r2,zero
 3223a4c:	1000141e 	bne	r2,zero,3223aa0 <c_older+0x78>
 3223a50:	0080c974 	movhi	r2,805
 3223a54:	10934104 	addi	r2,r2,19716
 3223a58:	10c00017 	ldw	r3,0(r2)
 3223a5c:	e0bffd17 	ldw	r2,-12(fp)
 3223a60:	18800536 	bltu	r3,r2,3223a78 <c_older+0x50>
 3223a64:	0080c974 	movhi	r2,805
 3223a68:	10934104 	addi	r2,r2,19716
 3223a6c:	10c00017 	ldw	r3,0(r2)
 3223a70:	e0bffe17 	ldw	r2,-8(fp)
 3223a74:	18800a2e 	bgeu	r3,r2,3223aa0 <c_older+0x78>
 3223a78:	0080c974 	movhi	r2,805
 3223a7c:	10934104 	addi	r2,r2,19716
 3223a80:	10c00017 	ldw	r3,0(r2)
 3223a84:	e0bffd17 	ldw	r2,-12(fp)
 3223a88:	10c00e36 	bltu	r2,r3,3223ac4 <c_older+0x9c>
 3223a8c:	0080c974 	movhi	r2,805
 3223a90:	10934104 	addi	r2,r2,19716
 3223a94:	10c00017 	ldw	r3,0(r2)
 3223a98:	e0bffe17 	ldw	r2,-8(fp)
 3223a9c:	10c00936 	bltu	r2,r3,3223ac4 <c_older+0x9c>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
   {
      if (ct1 < ct2)
 3223aa0:	e0fffd17 	ldw	r3,-12(fp)
 3223aa4:	e0bffe17 	ldw	r2,-8(fp)
 3223aa8:	1880032e 	bgeu	r3,r2,3223ab8 <c_older+0x90>
         return(ct1);      /* then smaller is oldest */
 3223aac:	e0bffd17 	ldw	r2,-12(fp)
 3223ab0:	e0bfff15 	stw	r2,-4(fp)
 3223ab4:	00000b06 	br	3223ae4 <c_older+0xbc>
      else 
         return(ct2);
 3223ab8:	e0bffe17 	ldw	r2,-8(fp)
 3223abc:	e0bfff15 	stw	r2,-4(fp)
 3223ac0:	00000806 	br	3223ae4 <c_older+0xbc>
   }

   /* else one is less than cticks, and one is greater.
   the larger value is then the oldest */
   if (ct1 >= ct2)
 3223ac4:	e0fffd17 	ldw	r3,-12(fp)
 3223ac8:	e0bffe17 	ldw	r2,-8(fp)
 3223acc:	18800336 	bltu	r3,r2,3223adc <c_older+0xb4>
      return(ct1);
 3223ad0:	e0bffd17 	ldw	r2,-12(fp)
 3223ad4:	e0bfff15 	stw	r2,-4(fp)
 3223ad8:	00000206 	br	3223ae4 <c_older+0xbc>
   else
      return(ct2);
 3223adc:	e0bffe17 	ldw	r2,-8(fp)
 3223ae0:	e0bfff15 	stw	r2,-4(fp)
 3223ae4:	e0bfff17 	ldw	r2,-4(fp)
}
 3223ae8:	e037883a 	mov	sp,fp
 3223aec:	df000017 	ldw	fp,0(sp)
 3223af0:	dec00104 	addi	sp,sp,4
 3223af4:	f800283a 	ret

03223af8 <ip2mac>:
 */

int
ip2mac(PACKET pkt,         /* the packet itself, all set but for dest MAC address */
   ip_addr  dest_ip)    /* the IP host or gateway to get MAC addr for */
{
 3223af8:	defffa04 	addi	sp,sp,-24
 3223afc:	dfc00515 	stw	ra,20(sp)
 3223b00:	df000415 	stw	fp,16(sp)
 3223b04:	df000404 	addi	fp,sp,16
 3223b08:	e13ffd15 	stw	r4,-12(fp)
 3223b0c:	e17ffe15 	stw	r5,-8(fp)
   IFMIB ifmib = pkt->net->n_mib;   /* mib info for this interface */
 3223b10:	e0bffd17 	ldw	r2,-12(fp)
 3223b14:	10800617 	ldw	r2,24(r2)
 3223b18:	10802717 	ldw	r2,156(r2)
 3223b1c:	e0bffc15 	stw	r2,-16(fp)

   /* Always punt if iface ifAdminStatus is DOWN. ifOperStatus may 
    * be down too, but our packet may be the event required to bring 
    * it up - so don't worry about ifOperStatus here.
    */
   if(ifmib->ifAdminStatus == NI_DOWN)
 3223b20:	e0bffc17 	ldw	r2,-16(fp)
 3223b24:	10800617 	ldw	r2,24(r2)
 3223b28:	10800098 	cmpnei	r2,r2,2
 3223b2c:	1000091e 	bne	r2,zero,3223b54 <ip2mac+0x5c>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 3223b30:	01000084 	movi	r4,2
 3223b34:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 3223b38:	e13ffd17 	ldw	r4,-12(fp)
 3223b3c:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3223b40:	01000084 	movi	r4,2
 3223b44:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return(ENP_NO_ROUTE);
 3223b48:	00bff7c4 	movi	r2,-33
 3223b4c:	e0bfff15 	stw	r2,-4(fp)
 3223b50:	00004c06 	br	3223c84 <ip2mac+0x18c>
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 3223b54:	e0bffd17 	ldw	r2,-12(fp)
 3223b58:	10800617 	ldw	r2,24(r2)
 3223b5c:	10800817 	ldw	r2,32(r2)
 3223b60:	1005003a 	cmpeq	r2,r2,zero
 3223b64:	1000081e 	bne	r2,zero,3223b88 <ip2mac+0x90>
 3223b68:	e0bffc17 	ldw	r2,-16(fp)
 3223b6c:	10800217 	ldw	r2,8(r2)
 3223b70:	108005e0 	cmpeqi	r2,r2,23
 3223b74:	1000041e 	bne	r2,zero,3223b88 <ip2mac+0x90>
 3223b78:	e0bffc17 	ldw	r2,-16(fp)
 3223b7c:	10800217 	ldw	r2,8(r2)
 3223b80:	10800718 	cmpnei	r2,r2,28
 3223b84:	1000291e 	bne	r2,zero,3223c2c <ip2mac+0x134>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
       (ifmib->ifType == SLIP))
   {
      ifmib->ifOutUcastPkts++;   /* maintain MIB counters */
 3223b88:	e0bffc17 	ldw	r2,-16(fp)
 3223b8c:	10801017 	ldw	r2,64(r2)
 3223b90:	10c00044 	addi	r3,r2,1
 3223b94:	e0bffc17 	ldw	r2,-16(fp)
 3223b98:	10c01015 	stw	r3,64(r2)
      ifmib->ifOutOctets += pkt->nb_plen;
 3223b9c:	e0bffc17 	ldw	r2,-16(fp)
 3223ba0:	10c00f17 	ldw	r3,60(r2)
 3223ba4:	e0bffd17 	ldw	r2,-12(fp)
 3223ba8:	10800417 	ldw	r2,16(r2)
 3223bac:	1887883a 	add	r3,r3,r2
 3223bb0:	e0bffc17 	ldw	r2,-16(fp)
 3223bb4:	10c00f15 	stw	r3,60(r2)

      /* send packet on media */
      if (pkt->net->pkt_send) /* favor using packet send */
 3223bb8:	e0bffd17 	ldw	r2,-12(fp)
 3223bbc:	10800617 	ldw	r2,24(r2)
 3223bc0:	10800417 	ldw	r2,16(r2)
 3223bc4:	1005003a 	cmpeq	r2,r2,zero
 3223bc8:	1000061e 	bne	r2,zero,3223be4 <ip2mac+0xec>
         pkt->net->pkt_send(pkt);   /* pkt will be freed by MAC code */
 3223bcc:	e0bffd17 	ldw	r2,-12(fp)
 3223bd0:	10800617 	ldw	r2,24(r2)
 3223bd4:	10800417 	ldw	r2,16(r2)
 3223bd8:	e13ffd17 	ldw	r4,-12(fp)
 3223bdc:	103ee83a 	callr	r2
 3223be0:	00001006 	br	3223c24 <ip2mac+0x12c>
      else  /* no packet send; try raw send */
      {
         pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 3223be4:	e0bffd17 	ldw	r2,-12(fp)
 3223be8:	10800617 	ldw	r2,24(r2)
 3223bec:	10c00317 	ldw	r3,12(r2)
 3223bf0:	e0bffd17 	ldw	r2,-12(fp)
 3223bf4:	11000617 	ldw	r4,24(r2)
 3223bf8:	e0bffd17 	ldw	r2,-12(fp)
 3223bfc:	11400317 	ldw	r5,12(r2)
 3223c00:	e0bffd17 	ldw	r2,-12(fp)
 3223c04:	11800417 	ldw	r6,16(r2)
 3223c08:	183ee83a 	callr	r3
         LOCK_NET_RESOURCE(FREEQ_RESID);
 3223c0c:	01000084 	movi	r4,2
 3223c10:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 3223c14:	e13ffd17 	ldw	r4,-12(fp)
 3223c18:	322a6400 	call	322a640 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3223c1c:	01000084 	movi	r4,2
 3223c20:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      }
      return(SUCCESS);
 3223c24:	e03fff15 	stw	zero,-4(fp)
 3223c28:	00001606 	br	3223c84 <ip2mac+0x18c>
   }

   /* don't allow unicast sends if NIC iface has no IP address. This
    * is to prevent DHCP clients from sending prior to assignment.
    */
   if (pkt->net->n_ipaddr == 0L)
 3223c2c:	e0bffd17 	ldw	r2,-12(fp)
 3223c30:	10800617 	ldw	r2,24(r2)
 3223c34:	10800a17 	ldw	r2,40(r2)
 3223c38:	1004c03a 	cmpne	r2,r2,zero
 3223c3c:	10000d1e 	bne	r2,zero,3223c74 <ip2mac+0x17c>
   {
      if (pkt->fhost != 0xFFFFFFFF) /* check for broadcast packet */
 3223c40:	e0bffd17 	ldw	r2,-12(fp)
 3223c44:	10800717 	ldw	r2,28(r2)
 3223c48:	10bfffe0 	cmpeqi	r2,r2,-1
 3223c4c:	1000091e 	bne	r2,zero,3223c74 <ip2mac+0x17c>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 3223c50:	01000084 	movi	r4,2
 3223c54:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 3223c58:	e13ffd17 	ldw	r4,-12(fp)
 3223c5c:	322a6400 	call	322a640 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3223c60:	01000084 	movi	r4,2
 3223c64:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         return ENP_SENDERR;
 3223c68:	00bff884 	movi	r2,-30
 3223c6c:	e0bfff15 	stw	r2,-4(fp)
 3223c70:	00000406 	br	3223c84 <ip2mac+0x18c>
      }
   }

#ifdef INCLUDE_ARP   /* must be ethernet or token ring */
   return(send_via_arp(pkt, dest_ip));
 3223c74:	e13ffd17 	ldw	r4,-12(fp)
 3223c78:	e17ffe17 	ldw	r5,-8(fp)
 3223c7c:	323e1300 	call	323e130 <send_via_arp>
 3223c80:	e0bfff15 	stw	r2,-4(fp)
 3223c84:	e0bfff17 	ldw	r2,-4(fp)
#else
   dtrap();    /* Bad option combination? */
   return ENP_NO_IFACE; /* sent to unknown interface type */
#endif   /* INCLUDE_ARP */
}
 3223c88:	e037883a 	mov	sp,fp
 3223c8c:	dfc00117 	ldw	ra,4(sp)
 3223c90:	df000017 	ldw	fp,0(sp)
 3223c94:	dec00204 	addi	sp,sp,8
 3223c98:	f800283a 	ret

03223c9c <ip_startup>:
 * RETURNS: returns NULL if OK, or text of an error message 
 */

char *   
ip_startup()
{
 3223c9c:	defffb04 	addi	sp,sp,-20
 3223ca0:	dfc00415 	stw	ra,16(sp)
 3223ca4:	df000315 	stw	fp,12(sp)
 3223ca8:	df000304 	addi	fp,sp,12
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 3223cac:	e03ffd15 	stw	zero,-12(fp)
 3223cb0:	00002a06 	br	3223d5c <ip_startup+0xc0>
   {
      nets[i] = &netstatic[i];   /* set up array of pointers */
 3223cb4:	e13ffd17 	ldw	r4,-12(fp)
 3223cb8:	e0bffd17 	ldw	r2,-12(fp)
 3223cbc:	10803024 	muli	r2,r2,192
 3223cc0:	1007883a 	mov	r3,r2
 3223cc4:	0080c9b4 	movhi	r2,806
 3223cc8:	10b28504 	addi	r2,r2,-13804
 3223ccc:	188b883a 	add	r5,r3,r2
 3223cd0:	00c0c9b4 	movhi	r3,806
 3223cd4:	18f34504 	addi	r3,r3,-13036
 3223cd8:	2105883a 	add	r2,r4,r4
 3223cdc:	1085883a 	add	r2,r2,r2
 3223ce0:	10c5883a 	add	r2,r2,r3
 3223ce4:	11400015 	stw	r5,0(r2)
      nets[i]->n_mib = &nets[i]->mib;   /* set mib pointer */
 3223ce8:	e0bffd17 	ldw	r2,-12(fp)
 3223cec:	00c0c9b4 	movhi	r3,806
 3223cf0:	18f34504 	addi	r3,r3,-13036
 3223cf4:	1085883a 	add	r2,r2,r2
 3223cf8:	1085883a 	add	r2,r2,r2
 3223cfc:	10c5883a 	add	r2,r2,r3
 3223d00:	11000017 	ldw	r4,0(r2)
 3223d04:	e0bffd17 	ldw	r2,-12(fp)
 3223d08:	00c0c9b4 	movhi	r3,806
 3223d0c:	18f34504 	addi	r3,r3,-13036
 3223d10:	1085883a 	add	r2,r2,r2
 3223d14:	1085883a 	add	r2,r2,r2
 3223d18:	10c5883a 	add	r2,r2,r3
 3223d1c:	10800017 	ldw	r2,0(r2)
 3223d20:	10801204 	addi	r2,r2,72
 3223d24:	20802715 	stw	r2,156(r4)

      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
 3223d28:	e0bffd17 	ldw	r2,-12(fp)
 3223d2c:	00c0c9b4 	movhi	r3,806
 3223d30:	18f34504 	addi	r3,r3,-13036
 3223d34:	1085883a 	add	r2,r2,r2
 3223d38:	1085883a 	add	r2,r2,r2
 3223d3c:	10c5883a 	add	r2,r2,r3
 3223d40:	11400017 	ldw	r5,0(r2)
 3223d44:	0100c9b4 	movhi	r4,806
 3223d48:	21354604 	addi	r4,r4,-10984
 3223d4c:	322a8800 	call	322a880 <putq>
{
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 3223d50:	e0bffd17 	ldw	r2,-12(fp)
 3223d54:	10800044 	addi	r2,r2,1
 3223d58:	e0bffd15 	stw	r2,-12(fp)
 3223d5c:	e0bffd17 	ldw	r2,-12(fp)
 3223d60:	10800110 	cmplti	r2,r2,4
 3223d64:	103fd31e 	bne	r2,zero,3223cb4 <ip_startup+0x18>
      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
   }

   /* call port routine to locate and init network interfaces. */
   ifNumber = (unsigned)prep_ifaces(ifNumber);
 3223d68:	d0a8bb17 	ldw	r2,-23828(gp)
 3223d6c:	1009883a 	mov	r4,r2
 3223d70:	3243ac00 	call	3243ac0 <prep_ifaces>
 3223d74:	d0a8bb15 	stw	r2,-23828(gp)

   if (ifNumber < 1)    /* no static interfaces? */
 3223d78:	d0a8bb17 	ldw	r2,-23828(gp)
 3223d7c:	1004c03a 	cmpne	r2,r2,zero
 3223d80:	1000041e 	bne	r2,zero,3223d94 <ip_startup+0xf8>
#ifdef DYNAMIC_IFACES
      /* print a debug message and hope user knows what he's doing */
      dprintf("unable to find any working interfaces");
#else /* static ifaces only */
      /* no static and no dynamic interfaces is probably a bug... */
      return("unable to find any working interfaces");
 3223d84:	0080c974 	movhi	r2,805
 3223d88:	10baaa04 	addi	r2,r2,-5464
 3223d8c:	e0bfff15 	stw	r2,-4(fp)
 3223d90:	00007506 	br	3223f68 <ip_startup+0x2cc>
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 3223d94:	d0a8bb17 	ldw	r2,-23828(gp)
 3223d98:	e0bffd15 	stw	r2,-12(fp)
 3223d9c:	00001506 	br	3223df4 <ip_startup+0x158>
   {
      qdel(&netlist, (qp)nets[i]);  /* remove from queue */
 3223da0:	e0bffd17 	ldw	r2,-12(fp)
 3223da4:	00c0c9b4 	movhi	r3,806
 3223da8:	18f34504 	addi	r3,r3,-13036
 3223dac:	1085883a 	add	r2,r2,r2
 3223db0:	1085883a 	add	r2,r2,r2
 3223db4:	10c5883a 	add	r2,r2,r3
 3223db8:	10800017 	ldw	r2,0(r2)
 3223dbc:	100b883a 	mov	r5,r2
 3223dc0:	0100c9b4 	movhi	r4,806
 3223dc4:	21354604 	addi	r4,r4,-10984
 3223dc8:	322a9300 	call	322a930 <qdel>
      nets[i] = NULL;               /* remove from array */
 3223dcc:	e0bffd17 	ldw	r2,-12(fp)
 3223dd0:	00c0c9b4 	movhi	r3,806
 3223dd4:	18f34504 	addi	r3,r3,-13036
 3223dd8:	1085883a 	add	r2,r2,r2
 3223ddc:	1085883a 	add	r2,r2,r2
 3223de0:	10c5883a 	add	r2,r2,r3
 3223de4:	10000015 	stw	zero,0(r2)
      return("unable to find any working interfaces");
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 3223de8:	e0bffd17 	ldw	r2,-12(fp)
 3223dec:	10800044 	addi	r2,r2,1
 3223df0:	e0bffd15 	stw	r2,-12(fp)
 3223df4:	e0bffd17 	ldw	r2,-12(fp)
 3223df8:	10800110 	cmplti	r2,r2,4
 3223dfc:	103fe81e 	bne	r2,zero,3223da0 <ip_startup+0x104>
   /* The sequence of events when initing the net & interface systems 
    * is very important. Be very carefull about altering the order of 
    * the following statements. 
    */
   /* once these are done, we should call ip_exit before quiting IP */
   clock_init();           /* start clock system */
 3223e00:	322b02c0 	call	322b02c <clock_init>
   exit_hook(clock_c);
 3223e04:	0100c8f4 	movhi	r4,803
 3223e08:	212c1a04 	addi	r4,r4,-20376
 3223e0c:	3223f800 	call	3223f80 <exit_hook>

   e = Netinit();    /* start net interface(s) */
 3223e10:	3222dc00 	call	3222dc0 <Netinit>
 3223e14:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 3223e18:	e0bffe17 	ldw	r2,-8(fp)
 3223e1c:	1005003a 	cmpeq	r2,r2,zero
 3223e20:	1000041e 	bne	r2,zero,3223e34 <ip_startup+0x198>
   {
      return("unable to initialize net");
 3223e24:	0080c974 	movhi	r2,805
 3223e28:	10bab404 	addi	r2,r2,-5424
 3223e2c:	e0bfff15 	stw	r2,-4(fp)
 3223e30:	00004d06 	br	3223f68 <ip_startup+0x2cc>
   }

#ifdef INCLUDE_ARP
   e = etainit();          /* startup ARP layer */
 3223e34:	323d21c0 	call	323d21c <etainit>
 3223e38:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 3223e3c:	e0bffe17 	ldw	r2,-8(fp)
 3223e40:	1005003a 	cmpeq	r2,r2,zero
 3223e44:	1000051e 	bne	r2,zero,3223e5c <ip_startup+0x1c0>
   {
      ip_exit();
 3223e48:	3223fec0 	call	3223fec <ip_exit>
      return("unable to initialize arp");
 3223e4c:	0080c974 	movhi	r2,805
 3223e50:	10babb04 	addi	r2,r2,-5396
 3223e54:	e0bfff15 	stw	r2,-4(fp)
 3223e58:	00004306 	br	3223f68 <ip_startup+0x2cc>
   }
#endif

#ifdef IP_V4
   e = ip_init();       /* start up IP layer */
 3223e5c:	323e9540 	call	323e954 <ip_init>
 3223e60:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 3223e64:	e0bffe17 	ldw	r2,-8(fp)
 3223e68:	1005003a 	cmpeq	r2,r2,zero
 3223e6c:	1000051e 	bne	r2,zero,3223e84 <ip_startup+0x1e8>
   {
      ip_exit();
 3223e70:	3223fec0 	call	3223fec <ip_exit>
      return("unable to initialize IP");
 3223e74:	0080c974 	movhi	r2,805
 3223e78:	10bac204 	addi	r2,r2,-5368
 3223e7c:	e0bfff15 	stw	r2,-4(fp)
 3223e80:	00003906 	br	3223f68 <ip_startup+0x2cc>

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Join the All hosts group on every interface that IP multicast is
    * supported
    */
   e = igmp_init();         /* Initialize igmp */
 3223e84:	322414c0 	call	322414c <igmp_init>
 3223e88:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 3223e8c:	e0bffe17 	ldw	r2,-8(fp)
 3223e90:	1005003a 	cmpeq	r2,r2,zero
 3223e94:	1000041e 	bne	r2,zero,3223ea8 <ip_startup+0x20c>
   {
      ip_exit();
 3223e98:	3223fec0 	call	3223fec <ip_exit>
      return(ipmcfail_str);
 3223e9c:	d0a02c17 	ldw	r2,-32592(gp)
 3223ea0:	e0bfff15 	stw	r2,-4(fp)
 3223ea4:	00003006 	br	3223f68 <ip_startup+0x2cc>
   }

   for (i = 0; i < (int)ifNumber; i++)
 3223ea8:	e03ffd15 	stw	zero,-12(fp)
 3223eac:	00001e06 	br	3223f28 <ip_startup+0x28c>
   {
      if (nets[i]->n_mcastlist != NULL)
 3223eb0:	e0bffd17 	ldw	r2,-12(fp)
 3223eb4:	00c0c9b4 	movhi	r3,806
 3223eb8:	18f34504 	addi	r3,r3,-13036
 3223ebc:	1085883a 	add	r2,r2,r2
 3223ec0:	1085883a 	add	r2,r2,r2
 3223ec4:	10c5883a 	add	r2,r2,r3
 3223ec8:	10800017 	ldw	r2,0(r2)
 3223ecc:	10802b17 	ldw	r2,172(r2)
 3223ed0:	1005003a 	cmpeq	r2,r2,zero
 3223ed4:	1000111e 	bne	r2,zero,3223f1c <ip_startup+0x280>
         if ((in_addmulti(&igmp_all_hosts_group, nets[i], 4) == NULL))
 3223ed8:	e0bffd17 	ldw	r2,-12(fp)
 3223edc:	00c0c9b4 	movhi	r3,806
 3223ee0:	18f34504 	addi	r3,r3,-13036
 3223ee4:	1085883a 	add	r2,r2,r2
 3223ee8:	1085883a 	add	r2,r2,r2
 3223eec:	10c5883a 	add	r2,r2,r3
 3223ef0:	11400017 	ldw	r5,0(r2)
 3223ef4:	0100c974 	movhi	r4,805
 3223ef8:	21132104 	addi	r4,r4,19588
 3223efc:	01800104 	movi	r6,4
 3223f00:	32437d00 	call	32437d0 <in_addmulti>
 3223f04:	1004c03a 	cmpne	r2,r2,zero
 3223f08:	1000041e 	bne	r2,zero,3223f1c <ip_startup+0x280>
      {
         ip_exit();
 3223f0c:	3223fec0 	call	3223fec <ip_exit>
         return(ipmcfail_str);
 3223f10:	d0a02c17 	ldw	r2,-32592(gp)
 3223f14:	e0bfff15 	stw	r2,-4(fp)
 3223f18:	00001306 	br	3223f68 <ip_startup+0x2cc>
   {
      ip_exit();
      return(ipmcfail_str);
   }

   for (i = 0; i < (int)ifNumber; i++)
 3223f1c:	e0bffd17 	ldw	r2,-12(fp)
 3223f20:	10800044 	addi	r2,r2,1
 3223f24:	e0bffd15 	stw	r2,-12(fp)
 3223f28:	d0a8bb17 	ldw	r2,-23828(gp)
 3223f2c:	1007883a 	mov	r3,r2
 3223f30:	e0bffd17 	ldw	r2,-12(fp)
 3223f34:	10ffde16 	blt	r2,r3,3223eb0 <ip_startup+0x214>
      }
   }
#endif /* IP_MULTICAST and (IGMPv1 or IGMPv2) */   

#ifdef INCLUDE_TCP
   e = tcpinit();
 3223f38:	32395780 	call	3239578 <tcpinit>
 3223f3c:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 3223f40:	e0bffe17 	ldw	r2,-8(fp)
 3223f44:	1005003a 	cmpeq	r2,r2,zero
 3223f48:	1000051e 	bne	r2,zero,3223f60 <ip_startup+0x2c4>
   {
      ip_exit();
 3223f4c:	3223fec0 	call	3223fec <ip_exit>
      return("unable to initialize TCP");
 3223f50:	0080c974 	movhi	r2,805
 3223f54:	10bac804 	addi	r2,r2,-5344
 3223f58:	e0bfff15 	stw	r2,-4(fp)
 3223f5c:	00000206 	br	3223f68 <ip_startup+0x2cc>
   /* setup event map for (UDP and TCP) socket library's events (such as 
    * those used by tcp_sleep () and tcp_wakeup ()).  These events either 
    * map into operating system primitives such as events or semaphores, 
    * or into task suspend and task resume mechanisms.
    */
   evtmap_setup ();
 3223f60:	3243b7c0 	call	3243b7c <evtmap_setup>
      return("unable to initialize IP Filter table");
   else
      exit_hook(ipf_cleanup);
#endif

   return(NULL);     /* we got through with no errors */
 3223f64:	e03fff15 	stw	zero,-4(fp)
 3223f68:	e0bfff17 	ldw	r2,-4(fp)
}
 3223f6c:	e037883a 	mov	sp,fp
 3223f70:	dfc00117 	ldw	ra,4(sp)
 3223f74:	df000017 	ldw	fp,0(sp)
 3223f78:	dec00204 	addi	sp,sp,8
 3223f7c:	f800283a 	ret

03223f80 <exit_hook>:
 * RETURNS: 
 */

void
exit_hook(void (*func)(void))
{
 3223f80:	defffd04 	addi	sp,sp,-12
 3223f84:	dfc00215 	stw	ra,8(sp)
 3223f88:	df000115 	stw	fp,4(sp)
 3223f8c:	df000104 	addi	fp,sp,4
 3223f90:	e13fff15 	stw	r4,-4(fp)
   if (nclosers >= (NUMCLOSERS-1))
 3223f94:	d0a8bc17 	ldw	r2,-23824(gp)
 3223f98:	10800390 	cmplti	r2,r2,14
 3223f9c:	1000031e 	bne	r2,zero,3223fac <exit_hook+0x2c>
      panic("exit_hook");
 3223fa0:	0100c974 	movhi	r4,805
 3223fa4:	213acf04 	addi	r4,r4,-5316
 3223fa8:	32261540 	call	3226154 <panic>

   closers[++nclosers] = func;
 3223fac:	d0a8bc17 	ldw	r2,-23824(gp)
 3223fb0:	10800044 	addi	r2,r2,1
 3223fb4:	d0a8bc15 	stw	r2,-23824(gp)
 3223fb8:	d0a8bc17 	ldw	r2,-23824(gp)
 3223fbc:	00c0c974 	movhi	r3,805
 3223fc0:	18d58504 	addi	r3,r3,22036
 3223fc4:	1085883a 	add	r2,r2,r2
 3223fc8:	1085883a 	add	r2,r2,r2
 3223fcc:	10c7883a 	add	r3,r2,r3
 3223fd0:	e0bfff17 	ldw	r2,-4(fp)
 3223fd4:	18800015 	stw	r2,0(r3)
}
 3223fd8:	e037883a 	mov	sp,fp
 3223fdc:	dfc00117 	ldw	ra,4(sp)
 3223fe0:	df000017 	ldw	fp,0(sp)
 3223fe4:	dec00204 	addi	sp,sp,8
 3223fe8:	f800283a 	ret

03223fec <ip_exit>:
 * RETURNS: void
 */

void
ip_exit()
{
 3223fec:	defffd04 	addi	sp,sp,-12
 3223ff0:	dfc00215 	stw	ra,8(sp)
 3223ff4:	df000115 	stw	fp,4(sp)
 3223ff8:	df000104 	addi	fp,sp,4
   int   n;

   for (n=nclosers; n; n--)
 3223ffc:	d0a8bc17 	ldw	r2,-23824(gp)
 3224000:	e0bfff15 	stw	r2,-4(fp)
 3224004:	00002506 	br	322409c <ip_exit+0xb0>
   {
#ifdef NPDEBUG
      dprintf("ip_exit: calling func %p\n", closers[n]);
 3224008:	e0bfff17 	ldw	r2,-4(fp)
 322400c:	00c0c974 	movhi	r3,805
 3224010:	18d58504 	addi	r3,r3,22036
 3224014:	1085883a 	add	r2,r2,r2
 3224018:	1085883a 	add	r2,r2,r2
 322401c:	10c5883a 	add	r2,r2,r3
 3224020:	11400017 	ldw	r5,0(r2)
 3224024:	0100c974 	movhi	r4,805
 3224028:	213ad204 	addi	r4,r4,-5304
 322402c:	3206de00 	call	3206de0 <printf>
#endif
      if(closers[n])
 3224030:	e0bfff17 	ldw	r2,-4(fp)
 3224034:	00c0c974 	movhi	r3,805
 3224038:	18d58504 	addi	r3,r3,22036
 322403c:	1085883a 	add	r2,r2,r2
 3224040:	1085883a 	add	r2,r2,r2
 3224044:	10c5883a 	add	r2,r2,r3
 3224048:	10800017 	ldw	r2,0(r2)
 322404c:	1005003a 	cmpeq	r2,r2,zero
 3224050:	10000f1e 	bne	r2,zero,3224090 <ip_exit+0xa4>
      {
         (*closers[n])();
 3224054:	e0bfff17 	ldw	r2,-4(fp)
 3224058:	00c0c974 	movhi	r3,805
 322405c:	18d58504 	addi	r3,r3,22036
 3224060:	1085883a 	add	r2,r2,r2
 3224064:	1085883a 	add	r2,r2,r2
 3224068:	10c5883a 	add	r2,r2,r3
 322406c:	10800017 	ldw	r2,0(r2)
 3224070:	103ee83a 	callr	r2
         closers[n] = NULL;
 3224074:	e0bfff17 	ldw	r2,-4(fp)
 3224078:	00c0c974 	movhi	r3,805
 322407c:	18d58504 	addi	r3,r3,22036
 3224080:	1085883a 	add	r2,r2,r2
 3224084:	1085883a 	add	r2,r2,r2
 3224088:	10c5883a 	add	r2,r2,r3
 322408c:	10000015 	stw	zero,0(r2)
void
ip_exit()
{
   int   n;

   for (n=nclosers; n; n--)
 3224090:	e0bfff17 	ldw	r2,-4(fp)
 3224094:	10bfffc4 	addi	r2,r2,-1
 3224098:	e0bfff15 	stw	r2,-4(fp)
 322409c:	e0bfff17 	ldw	r2,-4(fp)
 32240a0:	1004c03a 	cmpne	r2,r2,zero
 32240a4:	103fd81e 	bne	r2,zero,3224008 <ip_exit+0x1c>
      {
         (*closers[n])();
         closers[n] = NULL;
      }
   }
}
 32240a8:	e037883a 	mov	sp,fp
 32240ac:	dfc00117 	ldw	ra,4(sp)
 32240b0:	df000017 	ldw	fp,0(sp)
 32240b4:	dec00204 	addi	sp,sp,8
 32240b8:	f800283a 	ret

032240bc <if_netnumber>:
 * RETURNS: net index for passed net pointer
 */

int
if_netnumber(NET nptr)
{
 32240bc:	defffa04 	addi	sp,sp,-24
 32240c0:	dfc00515 	stw	ra,20(sp)
 32240c4:	df000415 	stw	fp,16(sp)
 32240c8:	df000404 	addi	fp,sp,16
 32240cc:	e13ffe15 	stw	r4,-8(fp)
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 32240d0:	0080c9b4 	movhi	r2,806
 32240d4:	10b54604 	addi	r2,r2,-10984
 32240d8:	10800017 	ldw	r2,0(r2)
 32240dc:	e0bffc15 	stw	r2,-16(fp)
 32240e0:	e03ffd15 	stw	zero,-12(fp)
 32240e4:	00000c06 	br	3224118 <if_netnumber+0x5c>
   {
      if(ifp == nptr)
 32240e8:	e0fffc17 	ldw	r3,-16(fp)
 32240ec:	e0bffe17 	ldw	r2,-8(fp)
 32240f0:	1880031e 	bne	r3,r2,3224100 <if_netnumber+0x44>
        return (int)i;
 32240f4:	e0bffd17 	ldw	r2,-12(fp)
 32240f8:	e0bfff15 	stw	r2,-4(fp)
 32240fc:	00000d06 	br	3224134 <if_netnumber+0x78>
if_netnumber(NET nptr)
{
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 3224100:	e0bffc17 	ldw	r2,-16(fp)
 3224104:	10800017 	ldw	r2,0(r2)
 3224108:	e0bffc15 	stw	r2,-16(fp)
 322410c:	e0bffd17 	ldw	r2,-12(fp)
 3224110:	10800044 	addi	r2,r2,1
 3224114:	e0bffd15 	stw	r2,-12(fp)
 3224118:	e0bffc17 	ldw	r2,-16(fp)
 322411c:	1004c03a 	cmpne	r2,r2,zero
 3224120:	103ff11e 	bne	r2,zero,32240e8 <if_netnumber+0x2c>
   {
      if(ifp == nptr)
        return (int)i;
   }

   panic("bad net ptr");
 3224124:	0100c974 	movhi	r4,805
 3224128:	213ad904 	addi	r4,r4,-5276
 322412c:	32261540 	call	3226154 <panic>
   return 0;
 3224130:	e03fff15 	stw	zero,-4(fp)
 3224134:	e0bfff17 	ldw	r2,-4(fp)
}
 3224138:	e037883a 	mov	sp,fp
 322413c:	dfc00117 	ldw	ra,4(sp)
 3224140:	df000017 	ldw	fp,0(sp)
 3224144:	dec00204 	addi	sp,sp,8
 3224148:	f800283a 	ret

0322414c <igmp_init>:
 *
 * OUTPUT: None.
 */

int igmp_init(void)
{
 322414c:	defffe04 	addi	sp,sp,-8
 3224150:	df000115 	stw	fp,4(sp)
 3224154:	df000104 	addi	fp,sp,4
   NET ifp;

   /*
    * To avoid byte-swapping the same value over and over again.
    */
   igmp_all_hosts_group = htonl(INADDR_ALLHOSTS_GROUP);
 3224158:	00804034 	movhi	r2,256
 322415c:	10803804 	addi	r2,r2,224
 3224160:	d0a8bf15 	stw	r2,-23812(gp)
   igmp_all_rtrs_group = htonl(INADDR_ALLRTRS_GROUP);
 3224164:	00808034 	movhi	r2,512
 3224168:	10803804 	addi	r2,r2,224
 322416c:	d0a8c015 	stw	r2,-23808(gp)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 3224170:	0080c9b4 	movhi	r2,806
 3224174:	10b54604 	addi	r2,r2,-10984
 3224178:	10800017 	ldw	r2,0(r2)
 322417c:	e0bfff15 	stw	r2,-4(fp)
 3224180:	00001006 	br	32241c4 <igmp_init+0x78>
   {
      if (ifp->igmp_oper_mode == IGMP_MODE_V1)
 3224184:	e0bfff17 	ldw	r2,-4(fp)
 3224188:	10802f03 	ldbu	r2,188(r2)
 322418c:	10803fcc 	andi	r2,r2,255
 3224190:	10800058 	cmpnei	r2,r2,1
 3224194:	1000041e 	bne	r2,zero,32241a8 <igmp_init+0x5c>
      {
         ifp->igmpv1_rtr_present = 1;
 3224198:	e0ffff17 	ldw	r3,-4(fp)
 322419c:	00800044 	movi	r2,1
 32241a0:	18802d05 	stb	r2,180(r3)
 32241a4:	00000406 	br	32241b8 <igmp_init+0x6c>
      }
      else
      {
         ifp->igmpv1_rtr_present = 0;
 32241a8:	e0bfff17 	ldw	r2,-4(fp)
 32241ac:	10002d05 	stb	zero,180(r2)
         /* not really required, only referred to if IGMPv1 router is 
          * "present" */
         ifp->igmpv1_query_rcvd_time = 0;
 32241b0:	e0bfff17 	ldw	r2,-4(fp)
 32241b4:	10002e15 	stw	zero,184(r2)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 32241b8:	e0bfff17 	ldw	r2,-4(fp)
 32241bc:	10800017 	ldw	r2,0(r2)
 32241c0:	e0bfff15 	stw	r2,-4(fp)
 32241c4:	e0bfff17 	ldw	r2,-4(fp)
 32241c8:	1004c03a 	cmpne	r2,r2,zero
 32241cc:	103fed1e 	bne	r2,zero,3224184 <igmp_init+0x38>
   }

   /*
    * Call igmp_fasttimo PR_FASTHZ (5) times per second
    */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 32241d0:	0080c974 	movhi	r2,805
 32241d4:	10934104 	addi	r2,r2,19716
 32241d8:	10800017 	ldw	r2,0(r2)
 32241dc:	10803204 	addi	r2,r2,200
 32241e0:	d0a8be15 	stw	r2,-23816(gp)

   /* there are no timers running initially */
   igmp_timers_are_running = 0;
 32241e4:	d028bd15 	stw	zero,-23820(gp)

   return IGMP_OK;
 32241e8:	0005883a 	mov	r2,zero
}
 32241ec:	e037883a 	mov	sp,fp
 32241f0:	df000017 	ldw	fp,0(sp)
 32241f4:	dec00104 	addi	sp,sp,4
 32241f8:	f800283a 	ret

032241fc <igmp_input>:
 * returned if the operating mode is not correctly configured
 * to a valid IGMP operating mode.
 */

int igmp_input (PACKET p)
{
 32241fc:	defff904 	addi	sp,sp,-28
 3224200:	dfc00615 	stw	ra,24(sp)
 3224204:	df000515 	stw	fp,20(sp)
 3224208:	df000504 	addi	fp,sp,20
 322420c:	e13ffd15 	stw	r4,-12(fp)
   u_char mode;
   int rc;
     
   ++igmpstats.igmp_total_rcvd;
 3224210:	0080c9b4 	movhi	r2,806
 3224214:	10b34904 	addi	r2,r2,-13020
 3224218:	10800017 	ldw	r2,0(r2)
 322421c:	10c00044 	addi	r3,r2,1
 3224220:	0080c9b4 	movhi	r2,806
 3224224:	10b34904 	addi	r2,r2,-13020
 3224228:	10c00015 	stw	r3,0(r2)
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 322422c:	e13ffd17 	ldw	r4,-12(fp)
 3224230:	3224a200 	call	3224a20 <igmp_validate>
 3224234:	e0bffb15 	stw	r2,-20(fp)
 3224238:	e0bffb17 	ldw	r2,-20(fp)
 322423c:	1004c03a 	cmpne	r2,r2,zero
 3224240:	10001e1e 	bne	r2,zero,32242bc <igmp_input+0xc0>

   /* determine the operating mode for IGMP on the ingress link */
   mode = p->net->igmp_oper_mode;
 3224244:	e0bffd17 	ldw	r2,-12(fp)
 3224248:	10800617 	ldw	r2,24(r2)
 322424c:	10802f03 	ldbu	r2,188(r2)
 3224250:	e0bffc05 	stb	r2,-16(fp)
   
   /* feed packet to IGMPv1 or IGMPv2 code based on the operating
    * mode of the ingress link */
   switch (mode)
 3224254:	e0bffc03 	ldbu	r2,-16(fp)
 3224258:	e0bfff15 	stw	r2,-4(fp)
 322425c:	e0ffff17 	ldw	r3,-4(fp)
 3224260:	18800060 	cmpeqi	r2,r3,1
 3224264:	1000041e 	bne	r2,zero,3224278 <igmp_input+0x7c>
 3224268:	e0ffff17 	ldw	r3,-4(fp)
 322426c:	188000a0 	cmpeqi	r2,r3,2
 3224270:	1000051e 	bne	r2,zero,3224288 <igmp_input+0x8c>
 3224274:	00000806 	br	3224298 <igmp_input+0x9c>
   {
#ifdef IGMP_V1   
      case IGMP_MODE_V1:   
         return (igmpv1_input (p)); 
 3224278:	e13ffd17 	ldw	r4,-12(fp)
 322427c:	32456200 	call	3245620 <igmpv1_input>
 3224280:	e0bffe15 	stw	r2,-8(fp)
 3224284:	00001506 	br	32242dc <igmp_input+0xe0>
#endif
#ifdef IGMP_V2         
      case IGMP_MODE_V2:       
         return (igmpv2_input (p));
 3224288:	e13ffd17 	ldw	r4,-12(fp)
 322428c:	32459080 	call	3245908 <igmpv2_input>
 3224290:	e0bffe15 	stw	r2,-8(fp)
 3224294:	00001106 	br	32242dc <igmp_input+0xe0>
#endif
      default:
         ++igmpstats.igmp_bad_oper_mode;     
 3224298:	0080c9b4 	movhi	r2,806
 322429c:	10b34904 	addi	r2,r2,-13020
 32242a0:	10800d17 	ldw	r2,52(r2)
 32242a4:	10c00044 	addi	r3,r2,1
 32242a8:	0080c9b4 	movhi	r2,806
 32242ac:	10b34904 	addi	r2,r2,-13020
 32242b0:	10c00d15 	stw	r3,52(r2)
         rc = IGMP_ERR;
 32242b4:	00bfffc4 	movi	r2,-1
 32242b8:	e0bffb15 	stw	r2,-20(fp)
         break;
   }
   
end:   
   /* return packet buffer back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 32242bc:	01000084 	movi	r4,2
 32242c0:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   pk_free(p);
 32242c4:	e13ffd17 	ldw	r4,-12(fp)
 32242c8:	322a6400 	call	322a640 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32242cc:	01000084 	movi	r4,2
 32242d0:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      
   return rc;
 32242d4:	e0bffb17 	ldw	r2,-20(fp)
 32242d8:	e0bffe15 	stw	r2,-8(fp)
 32242dc:	e0bffe17 	ldw	r2,-8(fp)
}
 32242e0:	e037883a 	mov	sp,fp
 32242e4:	dfc00117 	ldw	ra,4(sp)
 32242e8:	df000017 	ldw	fp,0(sp)
 32242ec:	dec00204 	addi	sp,sp,8
 32242f0:	f800283a 	ret

032242f4 <igmp_fasttimo>:
 *
 * OUTPUT: None.
 */

void igmp_fasttimo (void)
{
 32242f4:	defffc04 	addi	sp,sp,-16
 32242f8:	dfc00315 	stw	ra,12(sp)
 32242fc:	df000215 	stw	fp,8(sp)
 3224300:	df000204 	addi	fp,sp,8
   struct in_multi * inm;
   NET ifp;
     
   LOCK_NET_RESOURCE (NET_RESID);
 3224304:	0009883a 	mov	r4,zero
 3224308:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   
   /*
    * Quick check to see if any work needs to be done, in order
    * to minimize the overhead of fasttimo processing.
    */
   if (!igmp_timers_are_running)
 322430c:	d0a8bd17 	ldw	r2,-23820(gp)
 3224310:	1004c03a 	cmpne	r2,r2,zero
 3224314:	1000031e 	bne	r2,zero,3224324 <igmp_fasttimo+0x30>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
 3224318:	0009883a 	mov	r4,zero
 322431c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return;
 3224320:	00005606 	br	322447c <igmp_fasttimo+0x188>
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3224324:	0080c9b4 	movhi	r2,806
 3224328:	10b54604 	addi	r2,r2,-10984
 322432c:	10800017 	ldw	r2,0(r2)
 3224330:	e0bffe15 	stw	r2,-8(fp)
 3224334:	00004706 	br	3224454 <igmp_fasttimo+0x160>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 3224338:	e0bffe17 	ldw	r2,-8(fp)
 322433c:	10802c17 	ldw	r2,176(r2)
 3224340:	e0bfff15 	stw	r2,-4(fp)
 3224344:	00003d06 	br	322443c <igmp_fasttimo+0x148>
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
 3224348:	e0bfff17 	ldw	r2,-4(fp)
 322434c:	10800017 	ldw	r2,0(r2)
 3224350:	1005003a 	cmpeq	r2,r2,zero
 3224354:	1000361e 	bne	r2,zero,3224430 <igmp_fasttimo+0x13c>
               continue;

         if (inm->inm_timer == 0)   /* timer not set */
 3224358:	e0bfff17 	ldw	r2,-4(fp)
 322435c:	10800317 	ldw	r2,12(r2)
 3224360:	1005003a 	cmpeq	r2,r2,zero
 3224364:	1000321e 	bne	r2,zero,3224430 <igmp_fasttimo+0x13c>
         {
            /* do nothing */
         }
         else if (--inm->inm_timer == 0)  /* timer expired */
 3224368:	e0bfff17 	ldw	r2,-4(fp)
 322436c:	10800317 	ldw	r2,12(r2)
 3224370:	10ffffc4 	addi	r3,r2,-1
 3224374:	e0bfff17 	ldw	r2,-4(fp)
 3224378:	10c00315 	stw	r3,12(r2)
 322437c:	e0bfff17 	ldw	r2,-4(fp)
 3224380:	10800317 	ldw	r2,12(r2)
 3224384:	1004c03a 	cmpne	r2,r2,zero
 3224388:	1000291e 	bne	r2,zero,3224430 <igmp_fasttimo+0x13c>
         {
            /* send membership report in appropriate format */
            if (ifp->igmpv1_rtr_present)
 322438c:	e0bffe17 	ldw	r2,-8(fp)
 3224390:	10802d03 	ldbu	r2,180(r2)
 3224394:	10803fcc 	andi	r2,r2,255
 3224398:	1005003a 	cmpeq	r2,r2,zero
 322439c:	1000041e 	bne	r2,zero,32243b0 <igmp_fasttimo+0xbc>
            {
               /* always true for IGMPv1, may be true for IGMPv2 */
               igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 32243a0:	01000484 	movi	r4,18
 32243a4:	e17fff17 	ldw	r5,-4(fp)
 32243a8:	32244900 	call	3224490 <igmp_send>
 32243ac:	00000306 	br	32243bc <igmp_fasttimo+0xc8>
            }
            else
            {
               igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 32243b0:	01000584 	movi	r4,22
 32243b4:	e17fff17 	ldw	r5,-4(fp)
 32243b8:	32244900 	call	3224490 <igmp_send>

            /* for IGMPv2, indicate that we were the last to send 
             * a Report for this multicast group (relevant for 
             * IGMPv2 only).  also check to see if we should mark 
             * the IGMPv1 router as "absent". */
            if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 32243bc:	e0bffe17 	ldw	r2,-8(fp)
 32243c0:	10802f03 	ldbu	r2,188(r2)
 32243c4:	10803fcc 	andi	r2,r2,255
 32243c8:	10800098 	cmpnei	r2,r2,2
 32243cc:	1000151e 	bne	r2,zero,3224424 <igmp_fasttimo+0x130>
            {
               inm->last2send_report = IGMP_TRUE;
 32243d0:	e0ffff17 	ldw	r3,-4(fp)
 32243d4:	00800044 	movi	r2,1
 32243d8:	18800405 	stb	r2,16(r3)
               
               if (ifp->igmpv1_rtr_present)
 32243dc:	e0bffe17 	ldw	r2,-8(fp)
 32243e0:	10802d03 	ldbu	r2,180(r2)
 32243e4:	10803fcc 	andi	r2,r2,255
 32243e8:	1005003a 	cmpeq	r2,r2,zero
 32243ec:	10000d1e 	bne	r2,zero,3224424 <igmp_fasttimo+0x130>
               {
                  if (cticks > (ifp->igmpv1_query_rcvd_time + (IGMPv1_RTR_PRESENT_TMO * TPS)))
 32243f0:	e0bffe17 	ldw	r2,-8(fp)
 32243f4:	10c02e17 	ldw	r3,184(r2)
 32243f8:	008001b4 	movhi	r2,6
 32243fc:	1086a004 	addi	r2,r2,6784
 3224400:	1887883a 	add	r3,r3,r2
 3224404:	0080c974 	movhi	r2,805
 3224408:	10934104 	addi	r2,r2,19716
 322440c:	10800017 	ldw	r2,0(r2)
 3224410:	1880042e 	bgeu	r3,r2,3224424 <igmp_fasttimo+0x130>
                     /* we haven't heard from the IGMPv1 router for a duration
                      * greater than or equal to Version 1 Router Present Timeout 
                      * (400 seconds), and will now update the igmpv1_rtr_present 
                      * variable to reflect that.
                      */
                     ifp->igmpv1_rtr_present = IGMP_FALSE;
 3224414:	e0bffe17 	ldw	r2,-8(fp)
 3224418:	10002d05 	stb	zero,180(r2)
                     ifp->igmpv1_query_rcvd_time = 0;
 322441c:	e0bffe17 	ldw	r2,-8(fp)
 3224420:	10002e15 	stw	zero,184(r2)
                  }
               }  
            }

            /* decrement the count of running IGMP timers */
            --igmp_timers_are_running;
 3224424:	d0a8bd17 	ldw	r2,-23820(gp)
 3224428:	10bfffc4 	addi	r2,r2,-1
 322442c:	d0a8bd15 	stw	r2,-23820(gp)
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 3224430:	e0bfff17 	ldw	r2,-4(fp)
 3224434:	10800517 	ldw	r2,20(r2)
 3224438:	e0bfff15 	stw	r2,-4(fp)
 322443c:	e0bfff17 	ldw	r2,-4(fp)
 3224440:	1004c03a 	cmpne	r2,r2,zero
 3224444:	103fc01e 	bne	r2,zero,3224348 <igmp_fasttimo+0x54>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3224448:	e0bffe17 	ldw	r2,-8(fp)
 322444c:	10800017 	ldw	r2,0(r2)
 3224450:	e0bffe15 	stw	r2,-8(fp)
 3224454:	e0bffe17 	ldw	r2,-8(fp)
 3224458:	1004c03a 	cmpne	r2,r2,zero
 322445c:	103fb61e 	bne	r2,zero,3224338 <igmp_fasttimo+0x44>
      }     
   }

   /* Setup time for the next call into igmp_fasttimo ()
    * (200 ms later). */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 3224460:	0080c974 	movhi	r2,805
 3224464:	10934104 	addi	r2,r2,19716
 3224468:	10800017 	ldw	r2,0(r2)
 322446c:	10803204 	addi	r2,r2,200
 3224470:	d0a8be15 	stw	r2,-23816(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 3224474:	0009883a 	mov	r4,zero
 3224478:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   
   return;
}
 322447c:	e037883a 	mov	sp,fp
 3224480:	dfc00117 	ldw	ra,4(sp)
 3224484:	df000017 	ldw	fp,0(sp)
 3224488:	dec00204 	addi	sp,sp,8
 322448c:	f800283a 	ret

03224490 <igmp_send>:
 *
 * OUTPUT: None.
 */

void igmp_send (u_char type, struct in_multi * inm)
{
 3224490:	deffdd04 	addi	sp,sp,-140
 3224494:	dfc02215 	stw	ra,136(sp)
 3224498:	df002115 	stw	fp,132(sp)
 322449c:	df002104 	addi	fp,sp,132
 32244a0:	e17fff15 	stw	r5,-4(fp)
 32244a4:	e13ffe05 	stb	r4,-8(fp)
   struct ip_moptions * imop;
   struct ip_moptions simo;
   struct ip * pip;
   int i;
   u_char * tmpp;
   u_char opts [2] = {IP_RTR_ALERT_OPT, EOL_OPT};
 32244a8:	00800504 	movi	r2,20
 32244ac:	e0bffd05 	stb	r2,-12(fp)
 32244b0:	e03ffd45 	stb	zero,-11(fp)
   u_char reqd_len;

   /* compute length of buffer required for outgoing packet.
    * also account for the length of the IP Router Alert 
    * option, if required. */   
   reqd_len = MaxLnh + sizeof (struct ip) + sizeof (struct igmp);
 32244b4:	0080c974 	movhi	r2,805
 32244b8:	10931a04 	addi	r2,r2,19560
 32244bc:	10800017 	ldw	r2,0(r2)
 32244c0:	10800704 	addi	r2,r2,28
 32244c4:	e0bfdf05 	stb	r2,-132(fp)
   if ((type == IGMPv2_LEAVE_GROUP) || 
 32244c8:	e0bffe03 	ldbu	r2,-8(fp)
 32244cc:	108005e0 	cmpeqi	r2,r2,23
 32244d0:	1000031e 	bne	r2,zero,32244e0 <igmp_send+0x50>
 32244d4:	e0bffe03 	ldbu	r2,-8(fp)
 32244d8:	10800598 	cmpnei	r2,r2,22
 32244dc:	1000031e 	bne	r2,zero,32244ec <igmp_send+0x5c>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      reqd_len += IP_RTR_ALERT_OPT_SIZE;
 32244e0:	e0bfdf03 	ldbu	r2,-132(fp)
 32244e4:	10800104 	addi	r2,r2,4
 32244e8:	e0bfdf05 	stb	r2,-132(fp)
   }

   /* obtain a packet to send the IGMP message */
   LOCK_NET_RESOURCE (FREEQ_RESID);
 32244ec:	01000084 	movi	r4,2
 32244f0:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   p = pk_alloc (reqd_len);
 32244f4:	e13fdf03 	ldbu	r4,-132(fp)
 32244f8:	322a2ac0 	call	322a2ac <pk_alloc>
 32244fc:	e0bfe615 	stw	r2,-104(fp)
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3224500:	01000084 	movi	r4,2
 3224504:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   
   /* log an error and return if the allocation fails */   
   if (!p)
 3224508:	e0bfe617 	ldw	r2,-104(fp)
 322450c:	1004c03a 	cmpne	r2,r2,zero
 3224510:	1000081e 	bne	r2,zero,3224534 <igmp_send+0xa4>
   {
      ++igmpstats.igmp_pkt_alloc_fail;
 3224514:	0080c9b4 	movhi	r2,806
 3224518:	10b34904 	addi	r2,r2,-13020
 322451c:	10800c17 	ldw	r2,48(r2)
 3224520:	10c00044 	addi	r3,r2,1
 3224524:	0080c9b4 	movhi	r2,806
 3224528:	10b34904 	addi	r2,r2,-13020
 322452c:	10c00c15 	stw	r3,48(r2)
      return;
 3224530:	00007c06 	br	3224724 <igmp_send+0x294>
   }

   /* Need to fill in the source and destination ip addresses */
   pip = (struct ip *) p->nb_prot;
 3224534:	e0bfe617 	ldw	r2,-104(fp)
 3224538:	10800317 	ldw	r2,12(r2)
 322453c:	e0bfe315 	stw	r2,-116(fp)
   pip->ip_src = inm->inm_netp->n_ipaddr;
 3224540:	e0bfff17 	ldw	r2,-4(fp)
 3224544:	10800117 	ldw	r2,4(r2)
 3224548:	10c00a17 	ldw	r3,40(r2)
 322454c:	e0bfe317 	ldw	r2,-116(fp)
 3224550:	10c00315 	stw	r3,12(r2)
   /* Leave Group messages are sent to the all-routers multicast group */
   if (type == IGMPv2_LEAVE_GROUP)
 3224554:	e0bffe03 	ldbu	r2,-8(fp)
 3224558:	108005d8 	cmpnei	r2,r2,23
 322455c:	1000041e 	bne	r2,zero,3224570 <igmp_send+0xe0>
   {
      /* igmp_all_rtrs_group is already in network byte order */
      pip->ip_dest = igmp_all_rtrs_group;
 3224560:	d0e8c017 	ldw	r3,-23808(gp)
 3224564:	e0bfe317 	ldw	r2,-116(fp)
 3224568:	10c00415 	stw	r3,16(r2)
 322456c:	00000406 	br	3224580 <igmp_send+0xf0>
   }
   else
      pip->ip_dest = inm->inm_addr;
 3224570:	e0bfff17 	ldw	r2,-4(fp)
 3224574:	10c00017 	ldw	r3,0(r2)
 3224578:	e0bfe317 	ldw	r2,-116(fp)
 322457c:	10c00415 	stw	r3,16(r2)
   
   p->fhost = pip->ip_dest;
 3224580:	e0bfe317 	ldw	r2,-116(fp)
 3224584:	10c00417 	ldw	r3,16(r2)
 3224588:	e0bfe617 	ldw	r2,-104(fp)
 322458c:	10c00715 	stw	r3,28(r2)

   tmpp = (((u_char *) p->nb_prot) + sizeof (struct ip));
 3224590:	e0bfe617 	ldw	r2,-104(fp)
 3224594:	10800317 	ldw	r2,12(r2)
 3224598:	10800504 	addi	r2,r2,20
 322459c:	e0bfe115 	stw	r2,-124(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 32245a0:	e0bffe03 	ldbu	r2,-8(fp)
 32245a4:	108005e0 	cmpeqi	r2,r2,23
 32245a8:	1000031e 	bne	r2,zero,32245b8 <igmp_send+0x128>
 32245ac:	e0bffe03 	ldbu	r2,-8(fp)
 32245b0:	10800598 	cmpnei	r2,r2,22
 32245b4:	1000061e 	bne	r2,zero,32245d0 <igmp_send+0x140>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      /* provide space for ip_write2 () to write option-related data */
      tmpp += IP_RTR_ALERT_OPT_SIZE;
 32245b8:	e0bfe117 	ldw	r2,-124(fp)
 32245bc:	10800104 	addi	r2,r2,4
 32245c0:	e0bfe115 	stw	r2,-124(fp)
      optp = &(opts [0]); /* one option (IP Router Alert) */
 32245c4:	e0bffd04 	addi	r2,fp,-12
 32245c8:	e0bfe015 	stw	r2,-128(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 32245cc:	00000306 	br	32245dc <igmp_send+0x14c>
      tmpp += IP_RTR_ALERT_OPT_SIZE;
      optp = &(opts [0]); /* one option (IP Router Alert) */
   }
   /* outgoing packet does not require any options */
   else 
      optp = &(opts [1]);
 32245d0:	e0bffd04 	addi	r2,fp,-12
 32245d4:	10800044 	addi	r2,r2,1
 32245d8:	e0bfe015 	stw	r2,-128(fp)
   /* point to the start of the IGMP header */
   igmp = (struct igmp *) tmpp;
 32245dc:	e0bfe117 	ldw	r2,-124(fp)
 32245e0:	e0bfe515 	stw	r2,-108(fp)
   
   igmp->igmp_type = type;
 32245e4:	e0ffe517 	ldw	r3,-108(fp)
 32245e8:	e0bffe03 	ldbu	r2,-8(fp)
 32245ec:	18800005 	stb	r2,0(r3)
   igmp->igmp_code = 0;
 32245f0:	e0bfe517 	ldw	r2,-108(fp)
 32245f4:	10000045 	stb	zero,1(r2)
   
   /* all messages (Report or Leave) have Group Address field 
    * set to the group being reported or left */
   igmp->igmp_group = inm->inm_addr;
 32245f8:	e0bfff17 	ldw	r2,-4(fp)
 32245fc:	10c00017 	ldw	r3,0(r2)
 3224600:	e0bfe517 	ldw	r2,-108(fp)
 3224604:	10c00115 	stw	r3,4(r2)
   igmp->igmp_cksum = 0;
 3224608:	e0bfe517 	ldw	r2,-108(fp)
 322460c:	1000008d 	sth	zero,2(r2)
   igmp->igmp_cksum = ~cksum((void*)igmp, IGMP_MINLEN>>1);
 3224610:	e13fe517 	ldw	r4,-108(fp)
 3224614:	01400104 	movi	r5,4
 3224618:	3225d5c0 	call	3225d5c <cksum>
 322461c:	0084303a 	nor	r2,zero,r2
 3224620:	1007883a 	mov	r3,r2
 3224624:	e0bfe517 	ldw	r2,-108(fp)
 3224628:	10c0008d 	sth	r3,2(r2)

   imop = &simo;
 322462c:	e0bfe704 	addi	r2,fp,-100
 3224630:	e0bfe415 	stw	r2,-112(fp)
   MEMSET(imop, 0, sizeof(simo));
 3224634:	e0bfe417 	ldw	r2,-112(fp)
 3224638:	1009883a 	mov	r4,r2
 322463c:	01801604 	movi	r6,88
 3224640:	000b883a 	mov	r5,zero
 3224644:	3206c500 	call	3206c50 <memset>
   imop->imo_multicast_netp = inm->inm_netp;
 3224648:	e0bfff17 	ldw	r2,-4(fp)
 322464c:	10c00117 	ldw	r3,4(r2)
 3224650:	e0bfe417 	ldw	r2,-112(fp)
 3224654:	10c00015 	stw	r3,0(r2)
   imop->imo_multicast_ttl = 1;
 3224658:	e0ffe417 	ldw	r3,-112(fp)
 322465c:	00800044 	movi	r2,1
 3224660:	18800105 	stb	r2,4(r3)
   /* we do not want our own reports to be looped back */
   imop->imo_multicast_loop = 0;
 3224664:	e0bfe417 	ldw	r2,-112(fp)
 3224668:	10000145 	stb	zero,5(r2)

   /* set nb_prot to point to the beginning of the IGMP data,
    * and nb_plen to the length of the IGMP data, and attach
    * the multicast options structure to the outgoing packet */
   p->nb_prot = (char *) tmpp;
 322466c:	e0ffe117 	ldw	r3,-124(fp)
 3224670:	e0bfe617 	ldw	r2,-104(fp)
 3224674:	10c00315 	stw	r3,12(r2)
   p->nb_plen = sizeof(struct igmp);
 3224678:	e0ffe617 	ldw	r3,-104(fp)
 322467c:	00800204 	movi	r2,8
 3224680:	18800415 	stw	r2,16(r3)
   p->imo = imop;
 3224684:	e0ffe617 	ldw	r3,-104(fp)
 3224688:	e0bfe417 	ldw	r2,-112(fp)
 322468c:	18800b15 	stw	r2,44(r3)
   
   i = ip_write2 (IGMP_PROT, p, optp);
 3224690:	01000084 	movi	r4,2
 3224694:	e17fe617 	ldw	r5,-104(fp)
 3224698:	e1bfe017 	ldw	r6,-128(fp)
 322469c:	323f5bc0 	call	323f5bc <ip_write2>
 32246a0:	e0bfe215 	stw	r2,-120(fp)

   if (type == IGMPv2_LEAVE_GROUP)
 32246a4:	e0bffe03 	ldbu	r2,-8(fp)
 32246a8:	108005d8 	cmpnei	r2,r2,23
 32246ac:	1000081e 	bne	r2,zero,32246d0 <igmp_send+0x240>
      ++igmpstats.igmpv2mode_v2_leave_msgs_sent;
 32246b0:	0080c9b4 	movhi	r2,806
 32246b4:	10b34904 	addi	r2,r2,-13020
 32246b8:	10801717 	ldw	r2,92(r2)
 32246bc:	10c00044 	addi	r3,r2,1
 32246c0:	0080c9b4 	movhi	r2,806
 32246c4:	10b34904 	addi	r2,r2,-13020
 32246c8:	10c01715 	stw	r3,92(r2)
 32246cc:	00001506 	br	3224724 <igmp_send+0x294>
   else if (type == IGMPv2_MEMBERSHIP_REPORT)
 32246d0:	e0bffe03 	ldbu	r2,-8(fp)
 32246d4:	10800598 	cmpnei	r2,r2,22
 32246d8:	1000081e 	bne	r2,zero,32246fc <igmp_send+0x26c>
      ++igmpstats.igmpv2mode_v2_reports_sent;
 32246dc:	0080c9b4 	movhi	r2,806
 32246e0:	10b34904 	addi	r2,r2,-13020
 32246e4:	10801817 	ldw	r2,96(r2)
 32246e8:	10c00044 	addi	r3,r2,1
 32246ec:	0080c9b4 	movhi	r2,806
 32246f0:	10b34904 	addi	r2,r2,-13020
 32246f4:	10c01815 	stw	r3,96(r2)
 32246f8:	00000a06 	br	3224724 <igmp_send+0x294>
   else if (type == IGMP_HOST_MEMBERSHIP_REPORT)
 32246fc:	e0bffe03 	ldbu	r2,-8(fp)
 3224700:	10800498 	cmpnei	r2,r2,18
 3224704:	1000071e 	bne	r2,zero,3224724 <igmp_send+0x294>
      ++igmpstats.igmp_v1_reports_sent;
 3224708:	0080c9b4 	movhi	r2,806
 322470c:	10b34904 	addi	r2,r2,-13020
 3224710:	10801617 	ldw	r2,88(r2)
 3224714:	10c00044 	addi	r3,r2,1
 3224718:	0080c9b4 	movhi	r2,806
 322471c:	10b34904 	addi	r2,r2,-13020
 3224720:	10c01615 	stw	r3,88(r2)
}
 3224724:	e037883a 	mov	sp,fp
 3224728:	dfc00117 	ldw	ra,4(sp)
 322472c:	df000017 	ldw	fp,0(sp)
 3224730:	dec00204 	addi	sp,sp,8
 3224734:	f800283a 	ret

03224738 <igmp_joingroup>:
 *
 * OUTPUT: None.
 */
 
void igmp_joingroup(struct in_multi * inm)
{
 3224738:	defffc04 	addi	sp,sp,-16
 322473c:	dfc00315 	stw	ra,12(sp)
 3224740:	df000215 	stw	fp,8(sp)
 3224744:	df000204 	addi	fp,sp,8
 3224748:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   /* extract the network interface to which this multicast
    * address is "attached" */
   ifp = inm->inm_netp;
 322474c:	e0bfff17 	ldw	r2,-4(fp)
 3224750:	10800117 	ldw	r2,4(r2)
 3224754:	e0bffe15 	stw	r2,-8(fp)

   if (inm->inm_addr == igmp_all_hosts_group)
 3224758:	e0bfff17 	ldw	r2,-4(fp)
 322475c:	10c00017 	ldw	r3,0(r2)
 3224760:	d0a8bf17 	ldw	r2,-23812(gp)
 3224764:	1880031e 	bne	r3,r2,3224774 <igmp_joingroup+0x3c>
   {
      inm->inm_timer = 0;
 3224768:	e0bfff17 	ldw	r2,-4(fp)
 322476c:	10000315 	stw	zero,12(r2)
 3224770:	00008706 	br	3224990 <igmp_joingroup+0x258>
   }
   else 
   {
      /* send unsolicited membership report in appropriate format */
      if (ifp->igmpv1_rtr_present)
 3224774:	e0bffe17 	ldw	r2,-8(fp)
 3224778:	10802d03 	ldbu	r2,180(r2)
 322477c:	10803fcc 	andi	r2,r2,255
 3224780:	1005003a 	cmpeq	r2,r2,zero
 3224784:	10003c1e 	bne	r2,zero,3224878 <igmp_joingroup+0x140>
      {
         /* always true for IGMPv1, may be true for IGMPv2 */
         igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 3224788:	01000484 	movi	r4,18
 322478c:	e17fff17 	ldw	r5,-4(fp)
 3224790:	32244900 	call	3224490 <igmp_send>
         /* set a delay timer (with a duration of 
          * IGMP_MAX_HOST_REPORT_DELAY) for a second unsolicited report */
         inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 3224794:	0080c9b4 	movhi	r2,806
 3224798:	10b54b04 	addi	r2,r2,-10964
 322479c:	11000217 	ldw	r4,8(r2)
 32247a0:	0080c9b4 	movhi	r2,806
 32247a4:	10b34504 	addi	r2,r2,-13036
 32247a8:	10800017 	ldw	r2,0(r2)
 32247ac:	10800a17 	ldw	r2,40(r2)
 32247b0:	1004d63a 	srli	r2,r2,24
 32247b4:	10c03fcc 	andi	r3,r2,255
 32247b8:	0080c9b4 	movhi	r2,806
 32247bc:	10b34504 	addi	r2,r2,-13036
 32247c0:	10800017 	ldw	r2,0(r2)
 32247c4:	10800a17 	ldw	r2,40(r2)
 32247c8:	1004d23a 	srli	r2,r2,8
 32247cc:	10bfc00c 	andi	r2,r2,65280
 32247d0:	1886b03a 	or	r3,r3,r2
 32247d4:	0080c9b4 	movhi	r2,806
 32247d8:	10b34504 	addi	r2,r2,-13036
 32247dc:	10800017 	ldw	r2,0(r2)
 32247e0:	10800a17 	ldw	r2,40(r2)
 32247e4:	10bfc00c 	andi	r2,r2,65280
 32247e8:	1004923a 	slli	r2,r2,8
 32247ec:	1886b03a 	or	r3,r3,r2
 32247f0:	0080c9b4 	movhi	r2,806
 32247f4:	10b34504 	addi	r2,r2,-13036
 32247f8:	10800017 	ldw	r2,0(r2)
 32247fc:	10800a17 	ldw	r2,40(r2)
 3224800:	10803fcc 	andi	r2,r2,255
 3224804:	1004963a 	slli	r2,r2,24
 3224808:	1884b03a 	or	r2,r3,r2
 322480c:	2089883a 	add	r4,r4,r2
 3224810:	e0bfff17 	ldw	r2,-4(fp)
 3224814:	10800017 	ldw	r2,0(r2)
 3224818:	1004d63a 	srli	r2,r2,24
 322481c:	10c03fcc 	andi	r3,r2,255
 3224820:	e0bfff17 	ldw	r2,-4(fp)
 3224824:	10800017 	ldw	r2,0(r2)
 3224828:	1004d23a 	srli	r2,r2,8
 322482c:	10bfc00c 	andi	r2,r2,65280
 3224830:	1886b03a 	or	r3,r3,r2
 3224834:	e0bfff17 	ldw	r2,-4(fp)
 3224838:	10800017 	ldw	r2,0(r2)
 322483c:	10bfc00c 	andi	r2,r2,65280
 3224840:	1004923a 	slli	r2,r2,8
 3224844:	1886b03a 	or	r3,r3,r2
 3224848:	e0bfff17 	ldw	r2,-4(fp)
 322484c:	10800017 	ldw	r2,0(r2)
 3224850:	10803fcc 	andi	r2,r2,255
 3224854:	1004963a 	slli	r2,r2,24
 3224858:	1884b03a 	or	r2,r3,r2
 322485c:	2089883a 	add	r4,r4,r2
 3224860:	01400c84 	movi	r5,50
 3224864:	32047c80 	call	32047c8 <__umodsi3>
 3224868:	10c00044 	addi	r3,r2,1
 322486c:	e0bfff17 	ldw	r2,-4(fp)
 3224870:	10c00315 	stw	r3,12(r2)
 3224874:	00003b06 	br	3224964 <igmp_joingroup+0x22c>
      }
      else
      {
         igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 3224878:	01000584 	movi	r4,22
 322487c:	e17fff17 	ldw	r5,-4(fp)
 3224880:	32244900 	call	3224490 <igmp_send>
         /* the delay time duration is the Unsolicited Report Interval */
         inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY ((UNSOLIC_RPT_INTERVAL * PR_FASTHZ), inm->inm_addr);
 3224884:	0080c9b4 	movhi	r2,806
 3224888:	10b54b04 	addi	r2,r2,-10964
 322488c:	11000217 	ldw	r4,8(r2)
 3224890:	0080c9b4 	movhi	r2,806
 3224894:	10b34504 	addi	r2,r2,-13036
 3224898:	10800017 	ldw	r2,0(r2)
 322489c:	10800a17 	ldw	r2,40(r2)
 32248a0:	1004d63a 	srli	r2,r2,24
 32248a4:	10c03fcc 	andi	r3,r2,255
 32248a8:	0080c9b4 	movhi	r2,806
 32248ac:	10b34504 	addi	r2,r2,-13036
 32248b0:	10800017 	ldw	r2,0(r2)
 32248b4:	10800a17 	ldw	r2,40(r2)
 32248b8:	1004d23a 	srli	r2,r2,8
 32248bc:	10bfc00c 	andi	r2,r2,65280
 32248c0:	1886b03a 	or	r3,r3,r2
 32248c4:	0080c9b4 	movhi	r2,806
 32248c8:	10b34504 	addi	r2,r2,-13036
 32248cc:	10800017 	ldw	r2,0(r2)
 32248d0:	10800a17 	ldw	r2,40(r2)
 32248d4:	10bfc00c 	andi	r2,r2,65280
 32248d8:	1004923a 	slli	r2,r2,8
 32248dc:	1886b03a 	or	r3,r3,r2
 32248e0:	0080c9b4 	movhi	r2,806
 32248e4:	10b34504 	addi	r2,r2,-13036
 32248e8:	10800017 	ldw	r2,0(r2)
 32248ec:	10800a17 	ldw	r2,40(r2)
 32248f0:	10803fcc 	andi	r2,r2,255
 32248f4:	1004963a 	slli	r2,r2,24
 32248f8:	1884b03a 	or	r2,r3,r2
 32248fc:	2089883a 	add	r4,r4,r2
 3224900:	e0bfff17 	ldw	r2,-4(fp)
 3224904:	10800017 	ldw	r2,0(r2)
 3224908:	1004d63a 	srli	r2,r2,24
 322490c:	10c03fcc 	andi	r3,r2,255
 3224910:	e0bfff17 	ldw	r2,-4(fp)
 3224914:	10800017 	ldw	r2,0(r2)
 3224918:	1004d23a 	srli	r2,r2,8
 322491c:	10bfc00c 	andi	r2,r2,65280
 3224920:	1886b03a 	or	r3,r3,r2
 3224924:	e0bfff17 	ldw	r2,-4(fp)
 3224928:	10800017 	ldw	r2,0(r2)
 322492c:	10bfc00c 	andi	r2,r2,65280
 3224930:	1004923a 	slli	r2,r2,8
 3224934:	1886b03a 	or	r3,r3,r2
 3224938:	e0bfff17 	ldw	r2,-4(fp)
 322493c:	10800017 	ldw	r2,0(r2)
 3224940:	10803fcc 	andi	r2,r2,255
 3224944:	1004963a 	slli	r2,r2,24
 3224948:	1884b03a 	or	r2,r3,r2
 322494c:	2089883a 	add	r4,r4,r2
 3224950:	01400c84 	movi	r5,50
 3224954:	32047c80 	call	32047c8 <__umodsi3>
 3224958:	10c00044 	addi	r3,r2,1
 322495c:	e0bfff17 	ldw	r2,-4(fp)
 3224960:	10c00315 	stw	r3,12(r2)
      }
      
      /* for IGMPv2, indicate that we were the last to send 
       * a Report for this multicast group (relevant for 
       * IGMPv2 only). */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 3224964:	e0bffe17 	ldw	r2,-8(fp)
 3224968:	10802f03 	ldbu	r2,188(r2)
 322496c:	10803fcc 	andi	r2,r2,255
 3224970:	10800098 	cmpnei	r2,r2,2
 3224974:	1000031e 	bne	r2,zero,3224984 <igmp_joingroup+0x24c>
      {
         inm->last2send_report = IGMP_TRUE;
 3224978:	e0ffff17 	ldw	r3,-4(fp)
 322497c:	00800044 	movi	r2,1
 3224980:	18800405 	stb	r2,16(r3)
      }

      ++igmp_timers_are_running;
 3224984:	d0a8bd17 	ldw	r2,-23820(gp)
 3224988:	10800044 	addi	r2,r2,1
 322498c:	d0a8bd15 	stw	r2,-23820(gp)
   }
   
   return;
}     
 3224990:	e037883a 	mov	sp,fp
 3224994:	dfc00117 	ldw	ra,4(sp)
 3224998:	df000017 	ldw	fp,0(sp)
 322499c:	dec00204 	addi	sp,sp,8
 32249a0:	f800283a 	ret

032249a4 <igmp_leavegroup>:
 *
 * OUTPUT: None.
 */

void igmp_leavegroup (struct in_multi * inm)
{
 32249a4:	defffc04 	addi	sp,sp,-16
 32249a8:	dfc00315 	stw	ra,12(sp)
 32249ac:	df000215 	stw	fp,8(sp)
 32249b0:	df000204 	addi	fp,sp,8
 32249b4:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = inm->inm_netp;
 32249b8:	e0bfff17 	ldw	r2,-4(fp)
 32249bc:	10800117 	ldw	r2,4(r2)
 32249c0:	e0bffe15 	stw	r2,-8(fp)

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 32249c4:	e0bffe17 	ldw	r2,-8(fp)
 32249c8:	10802f03 	ldbu	r2,188(r2)
 32249cc:	10803fcc 	andi	r2,r2,255
 32249d0:	10800098 	cmpnei	r2,r2,2
 32249d4:	10000d1e 	bne	r2,zero,3224a0c <igmp_leavegroup+0x68>
 32249d8:	e0bffe17 	ldw	r2,-8(fp)
 32249dc:	10802d03 	ldbu	r2,180(r2)
 32249e0:	10803fcc 	andi	r2,r2,255
 32249e4:	1004c03a 	cmpne	r2,r2,zero
 32249e8:	1000081e 	bne	r2,zero,3224a0c <igmp_leavegroup+0x68>
       !ifp->igmpv1_rtr_present)
   {
      if (inm->last2send_report == IGMP_TRUE)
 32249ec:	e0bfff17 	ldw	r2,-4(fp)
 32249f0:	10800403 	ldbu	r2,16(r2)
 32249f4:	10803fcc 	andi	r2,r2,255
 32249f8:	10800058 	cmpnei	r2,r2,1
 32249fc:	1000031e 	bne	r2,zero,3224a0c <igmp_leavegroup+0x68>
         igmp_send (IGMPv2_LEAVE_GROUP, inm);
 3224a00:	010005c4 	movi	r4,23
 3224a04:	e17fff17 	ldw	r5,-4(fp)
 3224a08:	32244900 	call	3224490 <igmp_send>
   }
   
   return;
}
 3224a0c:	e037883a 	mov	sp,fp
 3224a10:	dfc00117 	ldw	ra,4(sp)
 3224a14:	df000017 	ldw	fp,0(sp)
 3224a18:	dec00204 	addi	sp,sp,8
 3224a1c:	f800283a 	ret

03224a20 <igmp_validate>:
 *         validation fails; otherwise, it returns
 *         IGMP_OK.
 */

int igmp_validate (PACKET p)
{
 3224a20:	defff504 	addi	sp,sp,-44
 3224a24:	dfc00a15 	stw	ra,40(sp)
 3224a28:	df000915 	stw	fp,36(sp)
 3224a2c:	df000904 	addi	fp,sp,36
 3224a30:	e13ffe15 	stw	r4,-8(fp)
   u_short xsum;  
   u_char type;
   ip_addr mcgrp_addr;
   u_char resp_time;

   pip = ip_head (p);
 3224a34:	e0bffe17 	ldw	r2,-8(fp)
 3224a38:	10800317 	ldw	r2,12(r2)
 3224a3c:	e0bffd15 	stw	r2,-12(fp)

   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */
   igmplen = p->nb_plen - ip_hlen (pip);
 3224a40:	e0bffe17 	ldw	r2,-8(fp)
 3224a44:	10c00417 	ldw	r3,16(r2)
 3224a48:	e0bffd17 	ldw	r2,-12(fp)
 3224a4c:	10800003 	ldbu	r2,0(r2)
 3224a50:	10803fcc 	andi	r2,r2,255
 3224a54:	108003cc 	andi	r2,r2,15
 3224a58:	1085883a 	add	r2,r2,r2
 3224a5c:	1085883a 	add	r2,r2,r2
 3224a60:	1885c83a 	sub	r2,r3,r2
 3224a64:	e0bffc15 	stw	r2,-16(fp)

   /* validate length (IGMP_MINLEN is 8 bytes) */
   if (igmplen != IGMP_MINLEN) 
 3224a68:	e0bffc17 	ldw	r2,-16(fp)
 3224a6c:	10800220 	cmpeqi	r2,r2,8
 3224a70:	10000a1e 	bne	r2,zero,3224a9c <igmp_validate+0x7c>
   {
      ++igmpstats.igmp_badlen_rcvd;
 3224a74:	0080c9b4 	movhi	r2,806
 3224a78:	10b34904 	addi	r2,r2,-13020
 3224a7c:	10800a17 	ldw	r2,40(r2)
 3224a80:	10c00044 	addi	r3,r2,1
 3224a84:	0080c9b4 	movhi	r2,806
 3224a88:	10b34904 	addi	r2,r2,-13020
 3224a8c:	10c00a15 	stw	r3,40(r2)
      return ENP_BAD_HEADER;
 3224a90:	00bff804 	movi	r2,-32
 3224a94:	e0bfff15 	stw	r2,-4(fp)
 3224a98:	0000b206 	br	3224d64 <igmp_validate+0x344>
   }

   /* validate checksum */
   igmp = (struct igmp *) (ip_data (pip));
 3224a9c:	e0bffd17 	ldw	r2,-12(fp)
 3224aa0:	10800003 	ldbu	r2,0(r2)
 3224aa4:	10803fcc 	andi	r2,r2,255
 3224aa8:	108003cc 	andi	r2,r2,15
 3224aac:	1085883a 	add	r2,r2,r2
 3224ab0:	1085883a 	add	r2,r2,r2
 3224ab4:	1007883a 	mov	r3,r2
 3224ab8:	e0bffd17 	ldw	r2,-12(fp)
 3224abc:	1885883a 	add	r2,r3,r2
 3224ac0:	e0bffb15 	stw	r2,-20(fp)
   osum = igmp->igmp_cksum;
 3224ac4:	e0bffb17 	ldw	r2,-20(fp)
 3224ac8:	1080008b 	ldhu	r2,2(r2)
 3224acc:	e0bffa0d 	sth	r2,-24(fp)
   igmp->igmp_cksum = 0;
 3224ad0:	e0bffb17 	ldw	r2,-20(fp)
 3224ad4:	1000008d 	sth	zero,2(r2)
   xsum = ~cksum(igmp, igmplen>>1);
 3224ad8:	e0bffc17 	ldw	r2,-16(fp)
 3224adc:	1005d07a 	srai	r2,r2,1
 3224ae0:	100b883a 	mov	r5,r2
 3224ae4:	e13ffb17 	ldw	r4,-20(fp)
 3224ae8:	3225d5c0 	call	3225d5c <cksum>
 3224aec:	0084303a 	nor	r2,zero,r2
 3224af0:	e0bff98d 	sth	r2,-26(fp)
   if (xsum != osum)
 3224af4:	e0fff98b 	ldhu	r3,-26(fp)
 3224af8:	e0bffa0b 	ldhu	r2,-24(fp)
 3224afc:	18800d26 	beq	r3,r2,3224b34 <igmp_validate+0x114>
   {
      igmp->igmp_cksum = osum;
 3224b00:	e0fffb17 	ldw	r3,-20(fp)
 3224b04:	e0bffa0b 	ldhu	r2,-24(fp)
 3224b08:	1880008d 	sth	r2,2(r3)
      ++igmpstats.igmp_badsum_rcvd;
 3224b0c:	0080c9b4 	movhi	r2,806
 3224b10:	10b34904 	addi	r2,r2,-13020
 3224b14:	10800b17 	ldw	r2,44(r2)
 3224b18:	10c00044 	addi	r3,r2,1
 3224b1c:	0080c9b4 	movhi	r2,806
 3224b20:	10b34904 	addi	r2,r2,-13020
 3224b24:	10c00b15 	stw	r3,44(r2)
      return ENP_BAD_HEADER;
 3224b28:	00bff804 	movi	r2,-32
 3224b2c:	e0bfff15 	stw	r2,-4(fp)
 3224b30:	00008c06 	br	3224d64 <igmp_validate+0x344>
   }
   
   /* extract the IGMP packet type, Group Address, and Max Response Time 
    * (unused for IGMPv1) fields from received packet */
   type = igmp->igmp_type;
 3224b34:	e0bffb17 	ldw	r2,-20(fp)
 3224b38:	10800003 	ldbu	r2,0(r2)
 3224b3c:	e0bff905 	stb	r2,-28(fp)
   mcgrp_addr = ntohl(igmp->igmp_group); 
 3224b40:	e0bffb17 	ldw	r2,-20(fp)
 3224b44:	10800117 	ldw	r2,4(r2)
 3224b48:	1004d63a 	srli	r2,r2,24
 3224b4c:	10c03fcc 	andi	r3,r2,255
 3224b50:	e0bffb17 	ldw	r2,-20(fp)
 3224b54:	10800117 	ldw	r2,4(r2)
 3224b58:	1004d23a 	srli	r2,r2,8
 3224b5c:	10bfc00c 	andi	r2,r2,65280
 3224b60:	1886b03a 	or	r3,r3,r2
 3224b64:	e0bffb17 	ldw	r2,-20(fp)
 3224b68:	10800117 	ldw	r2,4(r2)
 3224b6c:	10bfc00c 	andi	r2,r2,65280
 3224b70:	1004923a 	slli	r2,r2,8
 3224b74:	1886b03a 	or	r3,r3,r2
 3224b78:	e0bffb17 	ldw	r2,-20(fp)
 3224b7c:	10800117 	ldw	r2,4(r2)
 3224b80:	10803fcc 	andi	r2,r2,255
 3224b84:	1004963a 	slli	r2,r2,24
 3224b88:	1884b03a 	or	r2,r3,r2
 3224b8c:	e0bff815 	stw	r2,-32(fp)
   resp_time = igmp->igmp_code;
 3224b90:	e0bffb17 	ldw	r2,-20(fp)
 3224b94:	10800043 	ldbu	r2,1(r2)
 3224b98:	e0bff705 	stb	r2,-36(fp)
      
   if (type == IGMP_HOST_MEMBERSHIP_QUERY)
 3224b9c:	e0bff903 	ldbu	r2,-28(fp)
 3224ba0:	10800458 	cmpnei	r2,r2,17
 3224ba4:	1000381e 	bne	r2,zero,3224c88 <igmp_validate+0x268>
   {
      if ((resp_time == 0) || /* IGMPv1 Query */
 3224ba8:	e0bff703 	ldbu	r2,-36(fp)
 3224bac:	1005003a 	cmpeq	r2,r2,zero
 3224bb0:	1000061e 	bne	r2,zero,3224bcc <igmp_validate+0x1ac>
 3224bb4:	e0bff703 	ldbu	r2,-36(fp)
 3224bb8:	1005003a 	cmpeq	r2,r2,zero
 3224bbc:	1000111e 	bne	r2,zero,3224c04 <igmp_validate+0x1e4>
 3224bc0:	e0bff817 	ldw	r2,-32(fp)
 3224bc4:	1004c03a 	cmpne	r2,r2,zero
 3224bc8:	10000e1e 	bne	r2,zero,3224c04 <igmp_validate+0x1e4>
          ((resp_time > 0) && (mcgrp_addr == 0))) /* IGMPv2 General Query */     
      {
         /* if this is a IGMPv1 Host Membership Query or a IGMPv2 
          * General Query, it must be addressed to the all-hosts 
          * group */
         if (pip->ip_dest != igmp_all_hosts_group) 
 3224bcc:	e0bffd17 	ldw	r2,-12(fp)
 3224bd0:	10c00417 	ldw	r3,16(r2)
 3224bd4:	d0a8bf17 	ldw	r2,-23812(gp)
 3224bd8:	18800a26 	beq	r3,r2,3224c04 <igmp_validate+0x1e4>
         {
            ++igmpstats.igmp_bad_queries_rcvd;
 3224bdc:	0080c9b4 	movhi	r2,806
 3224be0:	10b34904 	addi	r2,r2,-13020
 3224be4:	10800e17 	ldw	r2,56(r2)
 3224be8:	10c00044 	addi	r3,r2,1
 3224bec:	0080c9b4 	movhi	r2,806
 3224bf0:	10b34904 	addi	r2,r2,-13020
 3224bf4:	10c00e15 	stw	r3,56(r2)
            return ENP_BAD_HEADER;
 3224bf8:	00bff804 	movi	r2,-32
 3224bfc:	e0bfff15 	stw	r2,-4(fp)
 3224c00:	00005806 	br	3224d64 <igmp_validate+0x344>
         }     
      }
      
      if ((resp_time > 0) && (mcgrp_addr != 0))
 3224c04:	e0bff703 	ldbu	r2,-36(fp)
 3224c08:	1005003a 	cmpeq	r2,r2,zero
 3224c0c:	10001e1e 	bne	r2,zero,3224c88 <igmp_validate+0x268>
 3224c10:	e0bff817 	ldw	r2,-32(fp)
 3224c14:	1005003a 	cmpeq	r2,r2,zero
 3224c18:	10001b1e 	bne	r2,zero,3224c88 <igmp_validate+0x268>
      {
         /* this is a IGMPv2 Group-Specific Query. */
         if (p->net->igmp_oper_mode == IGMP_MODE_V1)
 3224c1c:	e0bffe17 	ldw	r2,-8(fp)
 3224c20:	10800617 	ldw	r2,24(r2)
 3224c24:	10802f03 	ldbu	r2,188(r2)
 3224c28:	10803fcc 	andi	r2,r2,255
 3224c2c:	10800058 	cmpnei	r2,r2,1
 3224c30:	1000031e 	bne	r2,zero,3224c40 <igmp_validate+0x220>
         {
            /* IGMPv1 code does not understand a IGMPv2 Group-
             * Specific Query */
            return ENP_BAD_HEADER; 
 3224c34:	00bff804 	movi	r2,-32
 3224c38:	e0bfff15 	stw	r2,-4(fp)
 3224c3c:	00004906 	br	3224d64 <igmp_validate+0x344>
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 3224c40:	e0bff817 	ldw	r2,-32(fp)
 3224c44:	10fc002c 	andhi	r3,r2,61440
 3224c48:	00b80034 	movhi	r2,57344
 3224c4c:	1880041e 	bne	r3,r2,3224c60 <igmp_validate+0x240>
 3224c50:	e0bffb17 	ldw	r2,-20(fp)
 3224c54:	10c00117 	ldw	r3,4(r2)
 3224c58:	d0a8bf17 	ldw	r2,-23812(gp)
 3224c5c:	18800a1e 	bne	r3,r2,3224c88 <igmp_validate+0x268>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
         {
            ++igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd;
 3224c60:	0080c9b4 	movhi	r2,806
 3224c64:	10b34904 	addi	r2,r2,-13020
 3224c68:	10801117 	ldw	r2,68(r2)
 3224c6c:	10c00044 	addi	r3,r2,1
 3224c70:	0080c9b4 	movhi	r2,806
 3224c74:	10b34904 	addi	r2,r2,-13020
 3224c78:	10c01115 	stw	r3,68(r2)
            /* caller will free received packet */
            return ENP_BAD_HEADER;
 3224c7c:	00bff804 	movi	r2,-32
 3224c80:	e0bfff15 	stw	r2,-4(fp)
 3224c84:	00003706 	br	3224d64 <igmp_validate+0x344>
   
   /* check to ensure that a received IGMPv1 or v2 Report has the 
    * same IP host group address in its IP destination field and 
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
 3224c88:	e0bff903 	ldbu	r2,-28(fp)
 3224c8c:	108004a0 	cmpeqi	r2,r2,18
 3224c90:	1000031e 	bne	r2,zero,3224ca0 <igmp_validate+0x280>
 3224c94:	e0bff903 	ldbu	r2,-28(fp)
 3224c98:	10800598 	cmpnei	r2,r2,22
 3224c9c:	1000131e 	bne	r2,zero,3224cec <igmp_validate+0x2cc>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 3224ca0:	e0bffb17 	ldw	r2,-20(fp)
 3224ca4:	10c00117 	ldw	r3,4(r2)
 3224ca8:	e0bffd17 	ldw	r2,-12(fp)
 3224cac:	10800417 	ldw	r2,16(r2)
 3224cb0:	1880041e 	bne	r3,r2,3224cc4 <igmp_validate+0x2a4>
 3224cb4:	e0bff817 	ldw	r2,-32(fp)
 3224cb8:	10fc002c 	andhi	r3,r2,61440
 3224cbc:	00b80034 	movhi	r2,57344
 3224cc0:	18800a26 	beq	r3,r2,3224cec <igmp_validate+0x2cc>
          (!IN_MULTICAST(mcgrp_addr)))
      {
         ++igmpstats.igmp_bad_reports_rcvd;
 3224cc4:	0080c9b4 	movhi	r2,806
 3224cc8:	10b34904 	addi	r2,r2,-13020
 3224ccc:	10800f17 	ldw	r2,60(r2)
 3224cd0:	10c00044 	addi	r3,r2,1
 3224cd4:	0080c9b4 	movhi	r2,806
 3224cd8:	10b34904 	addi	r2,r2,-13020
 3224cdc:	10c00f15 	stw	r3,60(r2)
         return ENP_BAD_HEADER;    
 3224ce0:	00bff804 	movi	r2,-32
 3224ce4:	e0bfff15 	stw	r2,-4(fp)
 3224ce8:	00001e06 	br	3224d64 <igmp_validate+0x344>

    * Version 1 Host Membership Reports and Version 1 Host Membership Query
    * packets will not be checked for the IP Router Alert option.
    */
#ifdef IGMP_V2    
   if ((type == IGMPv2_LEAVE_GROUP) || 
 3224cec:	e0bff903 	ldbu	r2,-28(fp)
 3224cf0:	108005e0 	cmpeqi	r2,r2,23
 3224cf4:	10000b1e 	bne	r2,zero,3224d24 <igmp_validate+0x304>
 3224cf8:	e0bff903 	ldbu	r2,-28(fp)
 3224cfc:	108005a0 	cmpeqi	r2,r2,22
 3224d00:	1000081e 	bne	r2,zero,3224d24 <igmp_validate+0x304>
 3224d04:	e0bff903 	ldbu	r2,-28(fp)
 3224d08:	10800458 	cmpnei	r2,r2,17
 3224d0c:	1000141e 	bne	r2,zero,3224d60 <igmp_validate+0x340>
 3224d10:	e0bffb17 	ldw	r2,-20(fp)
 3224d14:	10800043 	ldbu	r2,1(r2)
 3224d18:	10803fcc 	andi	r2,r2,255
 3224d1c:	1005003a 	cmpeq	r2,r2,zero
 3224d20:	10000f1e 	bne	r2,zero,3224d60 <igmp_validate+0x340>
       (type == IGMPv2_MEMBERSHIP_REPORT) ||
       ((type == IGMP_HOST_MEMBERSHIP_QUERY) && (igmp->igmp_code > 0)))
       
   {
      if (!igmpv2_chk4_rtr_alert_opt (pip))
 3224d24:	e13ffd17 	ldw	r4,-12(fp)
 3224d28:	3245f580 	call	3245f58 <igmpv2_chk4_rtr_alert_opt>
 3224d2c:	10803fcc 	andi	r2,r2,255
 3224d30:	1004c03a 	cmpne	r2,r2,zero
 3224d34:	10000a1e 	bne	r2,zero,3224d60 <igmp_validate+0x340>
      { 
         ++igmpstats.igmpv2mode_v2_rtr_alert_missing;
 3224d38:	0080c9b4 	movhi	r2,806
 3224d3c:	10b34904 	addi	r2,r2,-13020
 3224d40:	10801417 	ldw	r2,80(r2)
 3224d44:	10c00044 	addi	r3,r2,1
 3224d48:	0080c9b4 	movhi	r2,806
 3224d4c:	10b34904 	addi	r2,r2,-13020
 3224d50:	10c01415 	stw	r3,80(r2)
         return ENP_BAD_HEADER;
 3224d54:	00bff804 	movi	r2,-32
 3224d58:	e0bfff15 	stw	r2,-4(fp)
 3224d5c:	00000106 	br	3224d64 <igmp_validate+0x344>
      }
   }
#endif   

   /* validation successful */
   return IGMP_OK;
 3224d60:	e03fff15 	stw	zero,-4(fp)
 3224d64:	e0bfff17 	ldw	r2,-4(fp)
}
 3224d68:	e037883a 	mov	sp,fp
 3224d6c:	dfc00117 	ldw	ra,4(sp)
 3224d70:	df000017 	ldw	fp,0(sp)
 3224d74:	dec00204 	addi	sp,sp,8
 3224d78:	f800283a 	ret

03224d7c <igmp_print_stats>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */
   
int igmp_print_stats (void * pio)
{  
 3224d7c:	defff504 	addi	sp,sp,-44
 3224d80:	dfc00a15 	stw	ra,40(sp)
 3224d84:	df000915 	stw	fp,36(sp)
 3224d88:	df000904 	addi	fp,sp,36
 3224d8c:	e13ffa15 	stw	r4,-24(fp)
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3224d90:	0080c9b4 	movhi	r2,806
 3224d94:	10b54604 	addi	r2,r2,-10984
 3224d98:	10800017 	ldw	r2,0(r2)
 3224d9c:	e0bff915 	stw	r2,-28(fp)
 3224da0:	00004506 	br	3224eb8 <igmp_print_stats+0x13c>
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 3224da4:	e0bff917 	ldw	r2,-28(fp)
 3224da8:	10800104 	addi	r2,r2,4
 3224dac:	e0bfff15 	stw	r2,-4(fp)
 3224db0:	e0bff917 	ldw	r2,-28(fp)
 3224db4:	10802f03 	ldbu	r2,188(r2)
 3224db8:	10803fcc 	andi	r2,r2,255
 3224dbc:	e0bffe15 	stw	r2,-8(fp)
 3224dc0:	e0bff917 	ldw	r2,-28(fp)
 3224dc4:	10802f03 	ldbu	r2,188(r2)
 3224dc8:	10803fcc 	andi	r2,r2,255
 3224dcc:	10800058 	cmpnei	r2,r2,1
 3224dd0:	1000041e 	bne	r2,zero,3224de4 <igmp_print_stats+0x68>
 3224dd4:	0080c974 	movhi	r2,805
 3224dd8:	10badc04 	addi	r2,r2,-5264
 3224ddc:	e0bffd15 	stw	r2,-12(fp)
 3224de0:	00000306 	br	3224df0 <igmp_print_stats+0x74>
 3224de4:	0080c974 	movhi	r2,805
 3224de8:	10badd04 	addi	r2,r2,-5260
 3224dec:	e0bffd15 	stw	r2,-12(fp)
 3224df0:	e0bffd17 	ldw	r2,-12(fp)
 3224df4:	d8800015 	stw	r2,0(sp)
 3224df8:	e13ffa17 	ldw	r4,-24(fp)
 3224dfc:	0140c974 	movhi	r5,805
 3224e00:	297ade04 	addi	r5,r5,-5256
 3224e04:	e1bfff17 	ldw	r6,-4(fp)
 3224e08:	e1fffe17 	ldw	r7,-8(fp)
 3224e0c:	322637c0 	call	322637c <ns_printf>
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 3224e10:	e0bff917 	ldw	r2,-28(fp)
 3224e14:	10802f03 	ldbu	r2,188(r2)
 3224e18:	10803fcc 	andi	r2,r2,255
 3224e1c:	10800098 	cmpnei	r2,r2,2
 3224e20:	10001e1e 	bne	r2,zero,3224e9c <igmp_print_stats+0x120>
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 3224e24:	e0bff917 	ldw	r2,-28(fp)
 3224e28:	10802d03 	ldbu	r2,180(r2)
 3224e2c:	10803fcc 	andi	r2,r2,255
 3224e30:	e0bffc15 	stw	r2,-16(fp)
 3224e34:	e0bff917 	ldw	r2,-28(fp)
 3224e38:	10802d03 	ldbu	r2,180(r2)
 3224e3c:	10803fcc 	andi	r2,r2,255
 3224e40:	10800058 	cmpnei	r2,r2,1
 3224e44:	1000041e 	bne	r2,zero,3224e58 <igmp_print_stats+0xdc>
 3224e48:	0080c974 	movhi	r2,805
 3224e4c:	10bae304 	addi	r2,r2,-5236
 3224e50:	e0bffb15 	stw	r2,-20(fp)
 3224e54:	00000306 	br	3224e64 <igmp_print_stats+0xe8>
 3224e58:	0080c974 	movhi	r2,805
 3224e5c:	10bae504 	addi	r2,r2,-5228
 3224e60:	e0bffb15 	stw	r2,-20(fp)
 3224e64:	e0bff917 	ldw	r2,-28(fp)
 3224e68:	10c02e17 	ldw	r3,184(r2)
 3224e6c:	0080c974 	movhi	r2,805
 3224e70:	10934104 	addi	r2,r2,19716
 3224e74:	10800017 	ldw	r2,0(r2)
 3224e78:	d8c00015 	stw	r3,0(sp)
 3224e7c:	d8800115 	stw	r2,4(sp)
 3224e80:	e13ffa17 	ldw	r4,-24(fp)
 3224e84:	0140c974 	movhi	r5,805
 3224e88:	297ae704 	addi	r5,r5,-5220
 3224e8c:	e1bffc17 	ldw	r6,-16(fp)
 3224e90:	e1fffb17 	ldw	r7,-20(fp)
 3224e94:	322637c0 	call	322637c <ns_printf>
 3224e98:	00000406 	br	3224eac <igmp_print_stats+0x130>
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
                    ifp->igmpv1_query_rcvd_time,
                    cticks);
      }
      else ns_printf (pio, "\n");
 3224e9c:	e13ffa17 	ldw	r4,-24(fp)
 3224ea0:	0140c974 	movhi	r5,805
 3224ea4:	297af204 	addi	r5,r5,-5176
 3224ea8:	322637c0 	call	322637c <ns_printf>
   
int igmp_print_stats (void * pio)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3224eac:	e0bff917 	ldw	r2,-28(fp)
 3224eb0:	10800017 	ldw	r2,0(r2)
 3224eb4:	e0bff915 	stw	r2,-28(fp)
 3224eb8:	e0bff917 	ldw	r2,-28(fp)
 3224ebc:	1004c03a 	cmpne	r2,r2,zero
 3224ec0:	103fb81e 	bne	r2,zero,3224da4 <igmp_print_stats+0x28>
      }
      else ns_printf (pio, "\n");
   }   

   /* rx and timer statistics */
   ns_printf (pio, "[Rx ] IGMP messages rcvd: %lu, timers running: %lu\n", igmpstats.igmp_total_rcvd, igmp_timers_are_running);
 3224ec4:	0080c9b4 	movhi	r2,806
 3224ec8:	10b34904 	addi	r2,r2,-13020
 3224ecc:	11800017 	ldw	r6,0(r2)
 3224ed0:	d1e8bd17 	ldw	r7,-23820(gp)
 3224ed4:	e13ffa17 	ldw	r4,-24(fp)
 3224ed8:	0140c974 	movhi	r5,805
 3224edc:	297af304 	addi	r5,r5,-5172
 3224ee0:	322637c0 	call	322637c <ns_printf>
   
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v1-mode links): %lu\n", igmpstats.igmpv1mode_v1_queries_rcvd);
 3224ee4:	0080c9b4 	movhi	r2,806
 3224ee8:	10b34904 	addi	r2,r2,-13020
 3224eec:	11800117 	ldw	r6,4(r2)
 3224ef0:	e13ffa17 	ldw	r4,-24(fp)
 3224ef4:	0140c974 	movhi	r5,805
 3224ef8:	297b0004 	addi	r5,r5,-5120
 3224efc:	322637c0 	call	322637c <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Reports rcvd: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd);
 3224f00:	0080c9b4 	movhi	r2,806
 3224f04:	10b34904 	addi	r2,r2,-13020
 3224f08:	11800217 	ldw	r6,8(r2)
 3224f0c:	e13ffa17 	ldw	r4,-24(fp)
 3224f10:	0140c974 	movhi	r5,805
 3224f14:	297b1104 	addi	r5,r5,-5052
 3224f18:	322637c0 	call	322637c <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer);
 3224f1c:	0080c9b4 	movhi	r2,806
 3224f20:	10b34904 	addi	r2,r2,-13020
 3224f24:	11800317 	ldw	r6,12(r2)
 3224f28:	e13ffa17 	ldw	r4,-24(fp)
 3224f2c:	0140c974 	movhi	r5,805
 3224f30:	297b1d04 	addi	r5,r5,-5004
 3224f34:	322637c0 	call	322637c <ns_printf>
      
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v2-mode links): %lu\n", igmpstats.igmpv2mode_v1_queries_rcvd);
 3224f38:	0080c9b4 	movhi	r2,806
 3224f3c:	10b34904 	addi	r2,r2,-13020
 3224f40:	11800417 	ldw	r6,16(r2)
 3224f44:	e13ffa17 	ldw	r4,-24(fp)
 3224f48:	0140c974 	movhi	r5,805
 3224f4c:	297b3004 	addi	r5,r5,-4928
 3224f50:	322637c0 	call	322637c <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 General Queries rcvd: %lu, Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_general_queries_rcvd, igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd);
 3224f54:	0080c9b4 	movhi	r2,806
 3224f58:	10b34904 	addi	r2,r2,-13020
 3224f5c:	11800517 	ldw	r6,20(r2)
 3224f60:	0080c9b4 	movhi	r2,806
 3224f64:	10b34904 	addi	r2,r2,-13020
 3224f68:	11c00617 	ldw	r7,24(r2)
 3224f6c:	e13ffa17 	ldw	r4,-24(fp)
 3224f70:	0140c974 	movhi	r5,805
 3224f74:	297b4104 	addi	r5,r5,-4860
 3224f78:	322637c0 	call	322637c <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer);   
 3224f7c:	0080c9b4 	movhi	r2,806
 3224f80:	10b34904 	addi	r2,r2,-13020
 3224f84:	11800717 	ldw	r6,28(r2)
 3224f88:	e13ffa17 	ldw	r4,-24(fp)
 3224f8c:	0140c974 	movhi	r5,805
 3224f90:	297b1d04 	addi	r5,r5,-5004
 3224f94:	322637c0 	call	322637c <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd with no local timer: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_no_timer);
 3224f98:	0080c9b4 	movhi	r2,806
 3224f9c:	10b34904 	addi	r2,r2,-13020
 3224fa0:	11800817 	ldw	r6,32(r2)
 3224fa4:	e13ffa17 	ldw	r4,-24(fp)
 3224fa8:	0140c974 	movhi	r5,805
 3224fac:	297b5404 	addi	r5,r5,-4784
 3224fb0:	322637c0 	call	322637c <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 Leave Group messages rcvd: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_rcvd);
 3224fb4:	0080c9b4 	movhi	r2,806
 3224fb8:	10b34904 	addi	r2,r2,-13020
 3224fbc:	11800917 	ldw	r6,36(r2)
 3224fc0:	e13ffa17 	ldw	r4,-24(fp)
 3224fc4:	0140c974 	movhi	r5,805
 3224fc8:	297b6504 	addi	r5,r5,-4716
 3224fcc:	322637c0 	call	322637c <ns_printf>
   
   /* tx statistics */
   ns_printf (pio, "[Tx ] IGMPv2 Leave Group messages sent: %lu, Membership Reports sent: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_sent, igmpstats.igmpv2mode_v2_reports_sent);
 3224fd0:	0080c9b4 	movhi	r2,806
 3224fd4:	10b34904 	addi	r2,r2,-13020
 3224fd8:	11801717 	ldw	r6,92(r2)
 3224fdc:	0080c9b4 	movhi	r2,806
 3224fe0:	10b34904 	addi	r2,r2,-13020
 3224fe4:	11c01817 	ldw	r7,96(r2)
 3224fe8:	e13ffa17 	ldw	r4,-24(fp)
 3224fec:	0140c974 	movhi	r5,805
 3224ff0:	297b7104 	addi	r5,r5,-4668
 3224ff4:	322637c0 	call	322637c <ns_printf>
   ns_printf (pio, "[Tx ] IGMPv1 Host Membership Reports sent: %lu\n", igmpstats.igmp_v1_reports_sent);
 3224ff8:	0080c9b4 	movhi	r2,806
 3224ffc:	10b34904 	addi	r2,r2,-13020
 3225000:	11801617 	ldw	r6,88(r2)
 3225004:	e13ffa17 	ldw	r4,-24(fp)
 3225008:	0140c974 	movhi	r5,805
 322500c:	297b8404 	addi	r5,r5,-4592
 3225010:	322637c0 	call	322637c <ns_printf>

   /* error statistics */
   ns_printf (pio, "[Err] IGMP packets rcvd with bad length: %lu\n", igmpstats.igmp_badlen_rcvd);
 3225014:	0080c9b4 	movhi	r2,806
 3225018:	10b34904 	addi	r2,r2,-13020
 322501c:	11800a17 	ldw	r6,40(r2)
 3225020:	e13ffa17 	ldw	r4,-24(fp)
 3225024:	0140c974 	movhi	r5,805
 3225028:	297b9004 	addi	r5,r5,-4544
 322502c:	322637c0 	call	322637c <ns_printf>
   ns_printf (pio, "[Err] IGMP packets rcvd with bad checksum: %lu\n", igmpstats.igmp_badsum_rcvd);
 3225030:	0080c9b4 	movhi	r2,806
 3225034:	10b34904 	addi	r2,r2,-13020
 3225038:	11800b17 	ldw	r6,44(r2)
 322503c:	e13ffa17 	ldw	r4,-24(fp)
 3225040:	0140c974 	movhi	r5,805
 3225044:	297b9c04 	addi	r5,r5,-4496
 3225048:	322637c0 	call	322637c <ns_printf>
   ns_printf (pio, "[Err] Packet buffer allocation failures: %lu, Bad IGMP Oper Mode config: %lu\n",igmpstats.igmp_pkt_alloc_fail, igmpstats.igmp_bad_oper_mode);
 322504c:	0080c9b4 	movhi	r2,806
 3225050:	10b34904 	addi	r2,r2,-13020
 3225054:	11800c17 	ldw	r6,48(r2)
 3225058:	0080c9b4 	movhi	r2,806
 322505c:	10b34904 	addi	r2,r2,-13020
 3225060:	11c00d17 	ldw	r7,52(r2)
 3225064:	e13ffa17 	ldw	r4,-24(fp)
 3225068:	0140c974 	movhi	r5,805
 322506c:	297ba804 	addi	r5,r5,-4448
 3225070:	322637c0 	call	322637c <ns_printf>
   ns_printf (pio, "[Err] Bad IGMP Queries rcvd: %lu, Bad IGMP Reports rcvd: %lu\n", igmpstats.igmp_bad_queries_rcvd, igmpstats.igmp_bad_reports_rcvd); 
 3225074:	0080c9b4 	movhi	r2,806
 3225078:	10b34904 	addi	r2,r2,-13020
 322507c:	11800e17 	ldw	r6,56(r2)
 3225080:	0080c9b4 	movhi	r2,806
 3225084:	10b34904 	addi	r2,r2,-13020
 3225088:	11c00f17 	ldw	r7,60(r2)
 322508c:	e13ffa17 	ldw	r4,-24(fp)
 3225090:	0140c974 	movhi	r5,805
 3225094:	297bbc04 	addi	r5,r5,-4368
 3225098:	322637c0 	call	322637c <ns_printf>
   ns_printf (pio, "[Err] Bad IGMPv2 Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd);
 322509c:	0080c9b4 	movhi	r2,806
 32250a0:	10b34904 	addi	r2,r2,-13020
 32250a4:	11801117 	ldw	r6,68(r2)
 32250a8:	e13ffa17 	ldw	r4,-24(fp)
 32250ac:	0140c974 	movhi	r5,805
 32250b0:	297bcc04 	addi	r5,r5,-4304
 32250b4:	322637c0 	call	322637c <ns_printf>
   ns_printf (pio, "[Err] IGMPv2 Group-Specific Queries rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd);
 32250b8:	0080c9b4 	movhi	r2,806
 32250bc:	10b34904 	addi	r2,r2,-13020
 32250c0:	11801217 	ldw	r6,72(r2)
 32250c4:	e13ffa17 	ldw	r4,-24(fp)
 32250c8:	0140c974 	movhi	r5,805
 32250cc:	297bd904 	addi	r5,r5,-4252
 32250d0:	322637c0 	call	322637c <ns_printf>
   ns_printf (pio, "[Err] IGMP Membership Reports rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd);
 32250d4:	0080c9b4 	movhi	r2,806
 32250d8:	10b34904 	addi	r2,r2,-13020
 32250dc:	11801317 	ldw	r6,76(r2)
 32250e0:	e13ffa17 	ldw	r4,-24(fp)
 32250e4:	0140c974 	movhi	r5,805
 32250e8:	297bec04 	addi	r5,r5,-4176
 32250ec:	322637c0 	call	322637c <ns_printf>
   ns_printf (pio, "[Err] Number of IGMPv2 messages rcvd without Router Alert option: %lu\n", igmpstats.igmpv2mode_v2_rtr_alert_missing); 
 32250f0:	0080c9b4 	movhi	r2,806
 32250f4:	10b34904 	addi	r2,r2,-13020
 32250f8:	11801417 	ldw	r6,80(r2)
 32250fc:	e13ffa17 	ldw	r4,-24(fp)
 3225100:	0140c974 	movhi	r5,805
 3225104:	297bfd04 	addi	r5,r5,-4108
 3225108:	322637c0 	call	322637c <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v1-mode links: %lu\n", igmpstats.igmpv1mode_unknown_pkttype);
 322510c:	0080c9b4 	movhi	r2,806
 3225110:	10b34904 	addi	r2,r2,-13020
 3225114:	11801017 	ldw	r6,64(r2)
 3225118:	e13ffa17 	ldw	r4,-24(fp)
 322511c:	0140c974 	movhi	r5,805
 3225120:	297c0f04 	addi	r5,r5,-4036
 3225124:	322637c0 	call	322637c <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v2-mode links: %lu\n", igmpstats.igmpv2mode_unknown_pkttype);
 3225128:	0080c9b4 	movhi	r2,806
 322512c:	10b34904 	addi	r2,r2,-13020
 3225130:	11801517 	ldw	r6,84(r2)
 3225134:	e13ffa17 	ldw	r4,-24(fp)
 3225138:	0140c974 	movhi	r5,805
 322513c:	297c1f04 	addi	r5,r5,-3972
 3225140:	322637c0 	call	322637c <ns_printf>
   
   return IGMP_OK;
 3225144:	0005883a 	mov	r2,zero
}
 3225148:	e037883a 	mov	sp,fp
 322514c:	dfc00117 	ldw	ra,4(sp)
 3225150:	df000017 	ldw	fp,0(sp)
 3225154:	dec00204 	addi	sp,sp,8
 3225158:	f800283a 	ret

0322515c <bsd_accept>:
 *          The error is available via bsd_errno(s).
 */
BSD_SOCKET
bsd_accept(BSD_SOCKET s,
           struct sockaddr * addr, int * addrlen)
{
 322515c:	defff304 	addi	sp,sp,-52
 3225160:	dfc00c15 	stw	ra,48(sp)
 3225164:	df000b15 	stw	fp,44(sp)
 3225168:	df000b04 	addi	fp,sp,44
 322516c:	e13ffc15 	stw	r4,-16(fp)
 3225170:	e17ffd15 	stw	r5,-12(fp)
 3225174:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr laddr;
   long lret;

   so = LONG2SO(s);
 3225178:	e0bffc17 	ldw	r2,-16(fp)
 322517c:	10bff804 	addi	r2,r2,-32
 3225180:	1085883a 	add	r2,r2,r2
 3225184:	1085883a 	add	r2,r2,r2
 3225188:	e0bff715 	stw	r2,-36(fp)
   SOC_CHECK(so);
 322518c:	0080c9b4 	movhi	r2,806
 3225190:	10b48204 	addi	r2,r2,-11768
 3225194:	e0bff515 	stw	r2,-44(fp)
 3225198:	00000606 	br	32251b4 <bsd_accept+0x58>
 322519c:	e0fff517 	ldw	r3,-44(fp)
 32251a0:	e0bff717 	ldw	r2,-36(fp)
 32251a4:	18800626 	beq	r3,r2,32251c0 <bsd_accept+0x64>
 32251a8:	e0bff517 	ldw	r2,-44(fp)
 32251ac:	10800017 	ldw	r2,0(r2)
 32251b0:	e0bff515 	stw	r2,-44(fp)
 32251b4:	e0bff517 	ldw	r2,-44(fp)
 32251b8:	1004c03a 	cmpne	r2,r2,zero
 32251bc:	103ff71e 	bne	r2,zero,322519c <bsd_accept+0x40>
 32251c0:	e0fff517 	ldw	r3,-44(fp)
 32251c4:	e0bff717 	ldw	r2,-36(fp)
 32251c8:	18800426 	beq	r3,r2,32251dc <bsd_accept+0x80>
 32251cc:	322aef00 	call	322aef0 <dtrap>
 32251d0:	00bfffc4 	movi	r2,-1
 32251d4:	e0bfff15 	stw	r2,-4(fp)
 32251d8:	00002806 	br	322527c <bsd_accept+0x120>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (addr != NULL)
 32251dc:	e0bffd17 	ldw	r2,-12(fp)
 32251e0:	1005003a 	cmpeq	r2,r2,zero
 32251e4:	1000091e 	bne	r2,zero,322520c <bsd_accept+0xb0>
   {
      if (addrlen == 0)
 32251e8:	e0bffe17 	ldw	r2,-8(fp)
 32251ec:	1004c03a 	cmpne	r2,r2,zero
 32251f0:	1000061e 	bne	r2,zero,322520c <bsd_accept+0xb0>
      {
         so->so_error = EFAULT;
 32251f4:	e0fff717 	ldw	r3,-36(fp)
 32251f8:	00800384 	movi	r2,14
 32251fc:	18800615 	stw	r2,24(r3)
         return -1;
 3225200:	00bfffc4 	movi	r2,-1
 3225204:	e0bfff15 	stw	r2,-4(fp)
 3225208:	00001c06 	br	322527c <bsd_accept+0x120>
      }
   }

   lret = t_accept(s, &laddr, addrlen);
 322520c:	e17ff804 	addi	r5,fp,-32
 3225210:	e13ffc17 	ldw	r4,-16(fp)
 3225214:	e1bffe17 	ldw	r6,-8(fp)
 3225218:	322e2640 	call	322e264 <t_accept>
 322521c:	e0bff615 	stw	r2,-40(fp)
    * address: copy the peer's address back into the buffer, but limit
    * the copy to the lesser of the buffer's length and sizeof(struct
    * sockaddr_in), which is all that t_accept() can return as a peer
    * address.  
    */
   if ((lret != -1) && (addr != NULL))
 3225220:	e0bff617 	ldw	r2,-40(fp)
 3225224:	10bfffe0 	cmpeqi	r2,r2,-1
 3225228:	1000121e 	bne	r2,zero,3225274 <bsd_accept+0x118>
 322522c:	e0bffd17 	ldw	r2,-12(fp)
 3225230:	1005003a 	cmpeq	r2,r2,zero
 3225234:	10000f1e 	bne	r2,zero,3225274 <bsd_accept+0x118>
   {
      if (*addrlen > sizeof(struct sockaddr_in))
 3225238:	e0bffe17 	ldw	r2,-8(fp)
 322523c:	10800017 	ldw	r2,0(r2)
 3225240:	10800470 	cmpltui	r2,r2,17
 3225244:	1000031e 	bne	r2,zero,3225254 <bsd_accept+0xf8>
         *addrlen = sizeof(struct sockaddr_in);
 3225248:	e0fffe17 	ldw	r3,-8(fp)
 322524c:	00800404 	movi	r2,16
 3225250:	18800015 	stw	r2,0(r3)
      MEMCPY(addr, &laddr, *addrlen);
 3225254:	e0bffe17 	ldw	r2,-8(fp)
 3225258:	10800017 	ldw	r2,0(r2)
 322525c:	100d883a 	mov	r6,r2
 3225260:	e0bffd17 	ldw	r2,-12(fp)
 3225264:	e0fff804 	addi	r3,fp,-32
 3225268:	1009883a 	mov	r4,r2
 322526c:	180b883a 	mov	r5,r3
 3225270:	3206ad00 	call	3206ad0 <memcpy>
   }

   return lret;
 3225274:	e0bff617 	ldw	r2,-40(fp)
 3225278:	e0bfff15 	stw	r2,-4(fp)
 322527c:	e0bfff17 	ldw	r2,-4(fp)
}
 3225280:	e037883a 	mov	sp,fp
 3225284:	dfc00117 	ldw	ra,4(sp)
 3225288:	df000017 	ldw	fp,0(sp)
 322528c:	dec00204 	addi	sp,sp,8
 3225290:	f800283a 	ret

03225294 <bsd_getpeername>:
 *          available via bsd_errno(s).
 */
int
bsd_getpeername(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 3225294:	defff204 	addi	sp,sp,-56
 3225298:	dfc00d15 	stw	ra,52(sp)
 322529c:	df000c15 	stw	fp,48(sp)
 32252a0:	df000c04 	addi	fp,sp,48
 32252a4:	e13ffc15 	stw	r4,-16(fp)
 32252a8:	e17ffd15 	stw	r5,-12(fp)
 32252ac:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 32252b0:	e0bffc17 	ldw	r2,-16(fp)
 32252b4:	10bff804 	addi	r2,r2,-32
 32252b8:	1085883a 	add	r2,r2,r2
 32252bc:	1085883a 	add	r2,r2,r2
 32252c0:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 32252c4:	0080c9b4 	movhi	r2,806
 32252c8:	10b48204 	addi	r2,r2,-11768
 32252cc:	e0bff415 	stw	r2,-48(fp)
 32252d0:	00000606 	br	32252ec <bsd_getpeername+0x58>
 32252d4:	e0fff417 	ldw	r3,-48(fp)
 32252d8:	e0bff617 	ldw	r2,-40(fp)
 32252dc:	18800626 	beq	r3,r2,32252f8 <bsd_getpeername+0x64>
 32252e0:	e0bff417 	ldw	r2,-48(fp)
 32252e4:	10800017 	ldw	r2,0(r2)
 32252e8:	e0bff415 	stw	r2,-48(fp)
 32252ec:	e0bff417 	ldw	r2,-48(fp)
 32252f0:	1004c03a 	cmpne	r2,r2,zero
 32252f4:	103ff71e 	bne	r2,zero,32252d4 <bsd_getpeername+0x40>
 32252f8:	e0fff417 	ldw	r3,-48(fp)
 32252fc:	e0bff617 	ldw	r2,-40(fp)
 3225300:	18800426 	beq	r3,r2,3225314 <bsd_getpeername+0x80>
 3225304:	322aef00 	call	322aef0 <dtrap>
 3225308:	00bfffc4 	movi	r2,-1
 322530c:	e0bfff15 	stw	r2,-4(fp)
 3225310:	00002506 	br	32253a8 <bsd_getpeername+0x114>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 3225314:	e0bffe17 	ldw	r2,-8(fp)
 3225318:	1004c03a 	cmpne	r2,r2,zero
 322531c:	1000061e 	bne	r2,zero,3225338 <bsd_getpeername+0xa4>
   {
      so->so_error = EFAULT;
 3225320:	e0fff617 	ldw	r3,-40(fp)
 3225324:	00800384 	movi	r2,14
 3225328:	18800615 	stw	r2,24(r3)
      return -1;
 322532c:	00bfffc4 	movi	r2,-1
 3225330:	e0bfff15 	stw	r2,-4(fp)
 3225334:	00001c06 	br	32253a8 <bsd_getpeername+0x114>
   }
   lnamelen = *namelen;
 3225338:	e0bffe17 	ldw	r2,-8(fp)
 322533c:	10800017 	ldw	r2,0(r2)
 3225340:	e0bffb15 	stw	r2,-20(fp)

   lret = t_getpeername(s, &lname, &lnamelen);
 3225344:	e17ff704 	addi	r5,fp,-36
 3225348:	e1bffb04 	addi	r6,fp,-20
 322534c:	e13ffc17 	ldw	r4,-16(fp)
 3225350:	322e7a40 	call	322e7a4 <t_getpeername>
 3225354:	e0bff515 	stw	r2,-44(fp)
    * t_getpeername() can return as a peer address, and pass the
    * copied length back to the caller.  
    * For IPV6 addresses, or for dual IPV4/IPV6 stack, 
    * the max size is sizeof(struct sockaddr_in6)
    */
   if (lret != -1)
 3225358:	e0bff517 	ldw	r2,-44(fp)
 322535c:	10bfffe0 	cmpeqi	r2,r2,-1
 3225360:	10000f1e 	bne	r2,zero,32253a0 <bsd_getpeername+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 3225364:	e0bffb17 	ldw	r2,-20(fp)
 3225368:	10800470 	cmpltui	r2,r2,17
 322536c:	1000021e 	bne	r2,zero,3225378 <bsd_getpeername+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 3225370:	00800404 	movi	r2,16
 3225374:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(name, &lname, lnamelen);
 3225378:	e0bffb17 	ldw	r2,-20(fp)
 322537c:	100d883a 	mov	r6,r2
 3225380:	e0bffd17 	ldw	r2,-12(fp)
 3225384:	e0fff704 	addi	r3,fp,-36
 3225388:	1009883a 	mov	r4,r2
 322538c:	180b883a 	mov	r5,r3
 3225390:	3206ad00 	call	3206ad0 <memcpy>
      *namelen = lnamelen;
 3225394:	e0fffb17 	ldw	r3,-20(fp)
 3225398:	e0bffe17 	ldw	r2,-8(fp)
 322539c:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 32253a0:	e0bff517 	ldw	r2,-44(fp)
 32253a4:	e0bfff15 	stw	r2,-4(fp)
 32253a8:	e0bfff17 	ldw	r2,-4(fp)
}
 32253ac:	e037883a 	mov	sp,fp
 32253b0:	dfc00117 	ldw	ra,4(sp)
 32253b4:	df000017 	ldw	fp,0(sp)
 32253b8:	dec00204 	addi	sp,sp,8
 32253bc:	f800283a 	ret

032253c0 <bsd_getsockname>:
 *          available via bsd_errno(s).
 */
int
bsd_getsockname(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 32253c0:	defff204 	addi	sp,sp,-56
 32253c4:	dfc00d15 	stw	ra,52(sp)
 32253c8:	df000c15 	stw	fp,48(sp)
 32253cc:	df000c04 	addi	fp,sp,48
 32253d0:	e13ffc15 	stw	r4,-16(fp)
 32253d4:	e17ffd15 	stw	r5,-12(fp)
 32253d8:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 32253dc:	e0bffc17 	ldw	r2,-16(fp)
 32253e0:	10bff804 	addi	r2,r2,-32
 32253e4:	1085883a 	add	r2,r2,r2
 32253e8:	1085883a 	add	r2,r2,r2
 32253ec:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 32253f0:	0080c9b4 	movhi	r2,806
 32253f4:	10b48204 	addi	r2,r2,-11768
 32253f8:	e0bff415 	stw	r2,-48(fp)
 32253fc:	00000606 	br	3225418 <bsd_getsockname+0x58>
 3225400:	e0fff417 	ldw	r3,-48(fp)
 3225404:	e0bff617 	ldw	r2,-40(fp)
 3225408:	18800626 	beq	r3,r2,3225424 <bsd_getsockname+0x64>
 322540c:	e0bff417 	ldw	r2,-48(fp)
 3225410:	10800017 	ldw	r2,0(r2)
 3225414:	e0bff415 	stw	r2,-48(fp)
 3225418:	e0bff417 	ldw	r2,-48(fp)
 322541c:	1004c03a 	cmpne	r2,r2,zero
 3225420:	103ff71e 	bne	r2,zero,3225400 <bsd_getsockname+0x40>
 3225424:	e0fff417 	ldw	r3,-48(fp)
 3225428:	e0bff617 	ldw	r2,-40(fp)
 322542c:	18800426 	beq	r3,r2,3225440 <bsd_getsockname+0x80>
 3225430:	322aef00 	call	322aef0 <dtrap>
 3225434:	00bfffc4 	movi	r2,-1
 3225438:	e0bfff15 	stw	r2,-4(fp)
 322543c:	00002506 	br	32254d4 <bsd_getsockname+0x114>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 3225440:	e0bffe17 	ldw	r2,-8(fp)
 3225444:	1004c03a 	cmpne	r2,r2,zero
 3225448:	1000061e 	bne	r2,zero,3225464 <bsd_getsockname+0xa4>
   {
      so->so_error = EFAULT;
 322544c:	e0fff617 	ldw	r3,-40(fp)
 3225450:	00800384 	movi	r2,14
 3225454:	18800615 	stw	r2,24(r3)
      return -1;
 3225458:	00bfffc4 	movi	r2,-1
 322545c:	e0bfff15 	stw	r2,-4(fp)
 3225460:	00001c06 	br	32254d4 <bsd_getsockname+0x114>
   }
   lnamelen = *namelen;
 3225464:	e0bffe17 	ldw	r2,-8(fp)
 3225468:	10800017 	ldw	r2,0(r2)
 322546c:	e0bffb15 	stw	r2,-20(fp)

   lret = t_getsockname(s, &lname, &lnamelen);
 3225470:	e17ff704 	addi	r5,fp,-36
 3225474:	e1bffb04 	addi	r6,fp,-20
 3225478:	e13ffc17 	ldw	r4,-16(fp)
 322547c:	322e7e80 	call	322e7e8 <t_getsockname>
 3225480:	e0bff515 	stw	r2,-44(fp)
    * copied length back to the caller.  
    * For IPV6 addresses, or for a dual IPV4/IPV6 stack, 
    * the max size copied is sizeof(struct sockaddr_in6)
    *
    */
   if (lret != -1)
 3225484:	e0bff517 	ldw	r2,-44(fp)
 3225488:	10bfffe0 	cmpeqi	r2,r2,-1
 322548c:	10000f1e 	bne	r2,zero,32254cc <bsd_getsockname+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 3225490:	e0bffb17 	ldw	r2,-20(fp)
 3225494:	10800470 	cmpltui	r2,r2,17
 3225498:	1000021e 	bne	r2,zero,32254a4 <bsd_getsockname+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 322549c:	00800404 	movi	r2,16
 32254a0:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);
#endif
      MEMCPY(name, &lname, lnamelen);
 32254a4:	e0bffb17 	ldw	r2,-20(fp)
 32254a8:	100d883a 	mov	r6,r2
 32254ac:	e0bffd17 	ldw	r2,-12(fp)
 32254b0:	e0fff704 	addi	r3,fp,-36
 32254b4:	1009883a 	mov	r4,r2
 32254b8:	180b883a 	mov	r5,r3
 32254bc:	3206ad00 	call	3206ad0 <memcpy>
      *namelen = lnamelen;
 32254c0:	e0fffb17 	ldw	r3,-20(fp)
 32254c4:	e0bffe17 	ldw	r2,-8(fp)
 32254c8:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 32254cc:	e0bff517 	ldw	r2,-44(fp)
 32254d0:	e0bfff15 	stw	r2,-4(fp)
 32254d4:	e0bfff17 	ldw	r2,-4(fp)
}
 32254d8:	e037883a 	mov	sp,fp
 32254dc:	dfc00117 	ldw	ra,4(sp)
 32254e0:	df000017 	ldw	fp,0(sp)
 32254e4:	dec00204 	addi	sp,sp,8
 32254e8:	f800283a 	ret

032254ec <bsd_i_sockoptlen>:
 * RETURNS: minimum length of the named socket option, in bytes
 */
int 
bsd_i_sockoptlen(int level,
                 int name)
{
 32254ec:	defffb04 	addi	sp,sp,-20
 32254f0:	df000415 	stw	fp,16(sp)
 32254f4:	df000404 	addi	fp,sp,16
 32254f8:	e13ffc15 	stw	r4,-16(fp)
 32254fc:	e17ffd15 	stw	r5,-12(fp)
   USE_ARG(level);

   switch (name)
 3225500:	e0bffd17 	ldw	r2,-12(fp)
 3225504:	e0bfff15 	stw	r2,-4(fp)
 3225508:	e0ffff17 	ldw	r3,-4(fp)
 322550c:	18802020 	cmpeqi	r2,r3,128
 3225510:	1000491e 	bne	r2,zero,3225638 <bsd_i_sockoptlen+0x14c>
 3225514:	e0ffff17 	ldw	r3,-4(fp)
 3225518:	18802048 	cmpgei	r2,r3,129
 322551c:	1000251e 	bne	r2,zero,32255b4 <bsd_i_sockoptlen+0xc8>
 3225520:	e0ffff17 	ldw	r3,-4(fp)
 3225524:	18800308 	cmpgei	r2,r3,12
 3225528:	1000141e 	bne	r2,zero,322557c <bsd_i_sockoptlen+0x90>
 322552c:	e0ffff17 	ldw	r3,-4(fp)
 3225530:	18800288 	cmpgei	r2,r3,10
 3225534:	10004c1e 	bne	r2,zero,3225668 <bsd_i_sockoptlen+0x17c>
 3225538:	e0ffff17 	ldw	r3,-4(fp)
 322553c:	18800120 	cmpeqi	r2,r3,4
 3225540:	1000431e 	bne	r2,zero,3225650 <bsd_i_sockoptlen+0x164>
 3225544:	e0ffff17 	ldw	r3,-4(fp)
 3225548:	18800148 	cmpgei	r2,r3,5
 322554c:	1000041e 	bne	r2,zero,3225560 <bsd_i_sockoptlen+0x74>
 3225550:	e0ffff17 	ldw	r3,-4(fp)
 3225554:	188000e0 	cmpeqi	r2,r3,3
 3225558:	1000491e 	bne	r2,zero,3225680 <bsd_i_sockoptlen+0x194>
 322555c:	00004b06 	br	322568c <bsd_i_sockoptlen+0x1a0>
 3225560:	e0ffff17 	ldw	r3,-4(fp)
 3225564:	18800220 	cmpeqi	r2,r3,8
 3225568:	1000391e 	bne	r2,zero,3225650 <bsd_i_sockoptlen+0x164>
 322556c:	e0ffff17 	ldw	r3,-4(fp)
 3225570:	18800260 	cmpeqi	r2,r3,9
 3225574:	1000391e 	bne	r2,zero,322565c <bsd_i_sockoptlen+0x170>
 3225578:	00004406 	br	322568c <bsd_i_sockoptlen+0x1a0>
 322557c:	e0ffff17 	ldw	r3,-4(fp)
 3225580:	18800420 	cmpeqi	r2,r3,16
 3225584:	1000321e 	bne	r2,zero,3225650 <bsd_i_sockoptlen+0x164>
 3225588:	e0ffff17 	ldw	r3,-4(fp)
 322558c:	18800448 	cmpgei	r2,r3,17
 3225590:	1000041e 	bne	r2,zero,32255a4 <bsd_i_sockoptlen+0xb8>
 3225594:	e0ffff17 	ldw	r3,-4(fp)
 3225598:	18800388 	cmpgei	r2,r3,14
 322559c:	10003b1e 	bne	r2,zero,322568c <bsd_i_sockoptlen+0x1a0>
 32255a0:	00003406 	br	3225674 <bsd_i_sockoptlen+0x188>
 32255a4:	e0ffff17 	ldw	r3,-4(fp)
 32255a8:	18800820 	cmpeqi	r2,r3,32
 32255ac:	1000281e 	bne	r2,zero,3225650 <bsd_i_sockoptlen+0x164>
 32255b0:	00003606 	br	322568c <bsd_i_sockoptlen+0x1a0>
 32255b4:	e0ffff17 	ldw	r3,-4(fp)
 32255b8:	188401c8 	cmpgei	r2,r3,4103
 32255bc:	10000e1e 	bne	r2,zero,32255f8 <bsd_i_sockoptlen+0x10c>
 32255c0:	e0ffff17 	ldw	r3,-4(fp)
 32255c4:	18840148 	cmpgei	r2,r3,4101
 32255c8:	10001e1e 	bne	r2,zero,3225644 <bsd_i_sockoptlen+0x158>
 32255cc:	e0ffff17 	ldw	r3,-4(fp)
 32255d0:	18804020 	cmpeqi	r2,r3,256
 32255d4:	10001e1e 	bne	r2,zero,3225650 <bsd_i_sockoptlen+0x164>
 32255d8:	e0ffff17 	ldw	r3,-4(fp)
 32255dc:	18804010 	cmplti	r2,r3,256
 32255e0:	10002a1e 	bne	r2,zero,322568c <bsd_i_sockoptlen+0x1a0>
 32255e4:	e0ffff17 	ldw	r3,-4(fp)
 32255e8:	18bbffc4 	addi	r2,r3,-4097
 32255ec:	108000a8 	cmpgeui	r2,r2,2
 32255f0:	1000261e 	bne	r2,zero,322568c <bsd_i_sockoptlen+0x1a0>
 32255f4:	00001606 	br	3225650 <bsd_i_sockoptlen+0x164>
 32255f8:	e0ffff17 	ldw	r3,-4(fp)
 32255fc:	18840588 	cmpgei	r2,r3,4118
 3225600:	1000071e 	bne	r2,zero,3225620 <bsd_i_sockoptlen+0x134>
 3225604:	e0ffff17 	ldw	r3,-4(fp)
 3225608:	18840508 	cmpgei	r2,r3,4116
 322560c:	1000081e 	bne	r2,zero,3225630 <bsd_i_sockoptlen+0x144>
 3225610:	e0ffff17 	ldw	r3,-4(fp)
 3225614:	18840248 	cmpgei	r2,r3,4105
 3225618:	10001c1e 	bne	r2,zero,322568c <bsd_i_sockoptlen+0x1a0>
 322561c:	00000c06 	br	3225650 <bsd_i_sockoptlen+0x164>
 3225620:	e0ffff17 	ldw	r3,-4(fp)
 3225624:	188405a0 	cmpeqi	r2,r3,4118
 3225628:	1000091e 	bne	r2,zero,3225650 <bsd_i_sockoptlen+0x164>
 322562c:	00001706 	br	322568c <bsd_i_sockoptlen+0x1a0>
   {
   case SO_BIO:
   case SO_NBIO:
      /* these don't use an option value */
      return 0;
 3225630:	e03ffe15 	stw	zero,-8(fp)
 3225634:	00001606 	br	3225690 <bsd_i_sockoptlen+0x1a4>
   case SO_LINGER:
      /* this option is a struct linger */
      return sizeof(struct linger);
 3225638:	00800204 	movi	r2,8
 322563c:	e0bffe15 	stw	r2,-8(fp)
 3225640:	00001306 	br	3225690 <bsd_i_sockoptlen+0x1a4>
   case SO_RCVTIMEO:
   case SO_SNDTIMEO:
      /* these options are type short */
      return sizeof(short);
 3225644:	00c00084 	movi	r3,2
 3225648:	e0fffe15 	stw	r3,-8(fp)
 322564c:	00001006 	br	3225690 <bsd_i_sockoptlen+0x1a4>
   case SO_RCVBUF:
   case SO_NONBLOCK:
   case SO_ERROR:
   case SO_TYPE:
      /* these options are type int */
      return sizeof(int);
 3225650:	00800104 	movi	r2,4
 3225654:	e0bffe15 	stw	r2,-8(fp)
 3225658:	00000d06 	br	3225690 <bsd_i_sockoptlen+0x1a4>
      return sizeof(int (*)());
#endif /* TCP_ZEROCOPY */
#ifdef IP_MULTICAST
   case IP_MULTICAST_IF:
      /* this option is type ip_addr */
      return sizeof(ip_addr);
 322565c:	00c00104 	movi	r3,4
 3225660:	e0fffe15 	stw	r3,-8(fp)
 3225664:	00000a06 	br	3225690 <bsd_i_sockoptlen+0x1a4>
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      /* these options are type u_char */
      return sizeof(u_char);
 3225668:	00800044 	movi	r2,1
 322566c:	e0bffe15 	stw	r2,-8(fp)
 3225670:	00000706 	br	3225690 <bsd_i_sockoptlen+0x1a4>
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      /* these options are struct ip_mreq */
      return sizeof(struct ip_mreq);
 3225674:	00c00204 	movi	r3,8
 3225678:	e0fffe15 	stw	r3,-8(fp)
 322567c:	00000406 	br	3225690 <bsd_i_sockoptlen+0x1a4>
 * IP_TTL_OPT == SOREUSEADDR. This causes a build erro
 * due to duplicate cases. Removing this one. They both
 * return the same value (sizeof(int)).
 */
  // case IP_TTL_OPT:
      return sizeof(int);
 3225680:	00800104 	movi	r2,4
 3225684:	e0bffe15 	stw	r2,-8(fp)
 3225688:	00000106 	br	3225690 <bsd_i_sockoptlen+0x1a4>
   default:
      /* we don't know what type these options are */
      return 0;
 322568c:	e03ffe15 	stw	zero,-8(fp)
 3225690:	e0bffe17 	ldw	r2,-8(fp)
   }
   
}
 3225694:	e037883a 	mov	sp,fp
 3225698:	df000017 	ldw	fp,0(sp)
 322569c:	dec00104 	addi	sp,sp,4
 32256a0:	f800283a 	ret

032256a4 <bsd_getsockopt>:
int
bsd_getsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int * optlen)
{
 32256a4:	defff404 	addi	sp,sp,-48
 32256a8:	dfc00b15 	stw	ra,44(sp)
 32256ac:	df000a15 	stw	fp,40(sp)
 32256b0:	df000a04 	addi	fp,sp,40
 32256b4:	e13ffb15 	stw	r4,-20(fp)
 32256b8:	e17ffc15 	stw	r5,-16(fp)
 32256bc:	e1bffd15 	stw	r6,-12(fp)
 32256c0:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;
   int loptlen;
   int e;

   so = LONG2SO(s);
 32256c4:	e0bffb17 	ldw	r2,-20(fp)
 32256c8:	10bff804 	addi	r2,r2,-32
 32256cc:	1085883a 	add	r2,r2,r2
 32256d0:	1085883a 	add	r2,r2,r2
 32256d4:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 32256d8:	0080c9b4 	movhi	r2,806
 32256dc:	10b48204 	addi	r2,r2,-11768
 32256e0:	e0bff715 	stw	r2,-36(fp)
 32256e4:	00000606 	br	3225700 <bsd_getsockopt+0x5c>
 32256e8:	e0fff717 	ldw	r3,-36(fp)
 32256ec:	e0bffa17 	ldw	r2,-24(fp)
 32256f0:	18800626 	beq	r3,r2,322570c <bsd_getsockopt+0x68>
 32256f4:	e0bff717 	ldw	r2,-36(fp)
 32256f8:	10800017 	ldw	r2,0(r2)
 32256fc:	e0bff715 	stw	r2,-36(fp)
 3225700:	e0bff717 	ldw	r2,-36(fp)
 3225704:	1004c03a 	cmpne	r2,r2,zero
 3225708:	103ff71e 	bne	r2,zero,32256e8 <bsd_getsockopt+0x44>
 322570c:	e0fff717 	ldw	r3,-36(fp)
 3225710:	e0bffa17 	ldw	r2,-24(fp)
 3225714:	18800426 	beq	r3,r2,3225728 <bsd_getsockopt+0x84>
 3225718:	322aef00 	call	322aef0 <dtrap>
 322571c:	00bfffc4 	movi	r2,-1
 3225720:	e0bfff15 	stw	r2,-4(fp)
 3225724:	00002106 	br	32257ac <bsd_getsockopt+0x108>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   loptlen = bsd_i_sockoptlen(level, name);
 3225728:	e13ffc17 	ldw	r4,-16(fp)
 322572c:	e17ffd17 	ldw	r5,-12(fp)
 3225730:	32254ec0 	call	32254ec <bsd_i_sockoptlen>
 3225734:	e0bff915 	stw	r2,-28(fp)
   if ((optlen == NULL) || (*optlen < loptlen))
 3225738:	e0800217 	ldw	r2,8(fp)
 322573c:	1005003a 	cmpeq	r2,r2,zero
 3225740:	1000041e 	bne	r2,zero,3225754 <bsd_getsockopt+0xb0>
 3225744:	e0800217 	ldw	r2,8(fp)
 3225748:	10c00017 	ldw	r3,0(r2)
 322574c:	e0bff917 	ldw	r2,-28(fp)
 3225750:	1880060e 	bge	r3,r2,322576c <bsd_getsockopt+0xc8>
   {
      so->so_error = EFAULT;
 3225754:	e0fffa17 	ldw	r3,-24(fp)
 3225758:	00800384 	movi	r2,14
 322575c:	18800615 	stw	r2,24(r3)
      return -1;
 3225760:	00bfffc4 	movi	r2,-1
 3225764:	e0bfff15 	stw	r2,-4(fp)
 3225768:	00001006 	br	32257ac <bsd_getsockopt+0x108>
   }

   e = t_getsockopt(s, level, name, opt, loptlen);
 322576c:	e0bff917 	ldw	r2,-28(fp)
 3225770:	d8800015 	stw	r2,0(sp)
 3225774:	e13ffb17 	ldw	r4,-20(fp)
 3225778:	e17ffc17 	ldw	r5,-16(fp)
 322577c:	e1bffd17 	ldw	r6,-12(fp)
 3225780:	e1fffe17 	ldw	r7,-8(fp)
 3225784:	322ec040 	call	322ec04 <t_getsockopt>
 3225788:	e0bff815 	stw	r2,-32(fp)

   /* if it worked, copy the option length back for the caller's use */
   if (e == 0)
 322578c:	e0bff817 	ldw	r2,-32(fp)
 3225790:	1004c03a 	cmpne	r2,r2,zero
 3225794:	1000031e 	bne	r2,zero,32257a4 <bsd_getsockopt+0x100>
   {
      *optlen = loptlen;
 3225798:	e0c00217 	ldw	r3,8(fp)
 322579c:	e0bff917 	ldw	r2,-28(fp)
 32257a0:	18800015 	stw	r2,0(r3)
   }

   return e;
 32257a4:	e0bff817 	ldw	r2,-32(fp)
 32257a8:	e0bfff15 	stw	r2,-4(fp)
 32257ac:	e0bfff17 	ldw	r2,-4(fp)
   
}
 32257b0:	e037883a 	mov	sp,fp
 32257b4:	dfc00117 	ldw	ra,4(sp)
 32257b8:	df000017 	ldw	fp,0(sp)
 32257bc:	dec00204 	addi	sp,sp,8
 32257c0:	f800283a 	ret

032257c4 <bsd_ioctl>:
 *          available via bsd_errno(s).
 */
int
bsd_ioctl(BSD_SOCKET s, 
          unsigned long request, ...)
{
 32257c4:	defff404 	addi	sp,sp,-48
 32257c8:	dfc00915 	stw	ra,36(sp)
 32257cc:	df000815 	stw	fp,32(sp)
 32257d0:	df000804 	addi	fp,sp,32
 32257d4:	e13ffd15 	stw	r4,-12(fp)
 32257d8:	e1800215 	stw	r6,8(fp)
 32257dc:	e1c00315 	stw	r7,12(fp)
 32257e0:	e17ffe15 	stw	r5,-8(fp)
   struct socket * so;
   va_list argptr;
   int iarg;

   so = LONG2SO(s);
 32257e4:	e0bffd17 	ldw	r2,-12(fp)
 32257e8:	10bff804 	addi	r2,r2,-32
 32257ec:	1085883a 	add	r2,r2,r2
 32257f0:	1085883a 	add	r2,r2,r2
 32257f4:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 32257f8:	0080c9b4 	movhi	r2,806
 32257fc:	10b48204 	addi	r2,r2,-11768
 3225800:	e0bff915 	stw	r2,-28(fp)
 3225804:	00000606 	br	3225820 <bsd_ioctl+0x5c>
 3225808:	e0fff917 	ldw	r3,-28(fp)
 322580c:	e0bffa17 	ldw	r2,-24(fp)
 3225810:	18800626 	beq	r3,r2,322582c <bsd_ioctl+0x68>
 3225814:	e0bff917 	ldw	r2,-28(fp)
 3225818:	10800017 	ldw	r2,0(r2)
 322581c:	e0bff915 	stw	r2,-28(fp)
 3225820:	e0bff917 	ldw	r2,-28(fp)
 3225824:	1004c03a 	cmpne	r2,r2,zero
 3225828:	103ff71e 	bne	r2,zero,3225808 <bsd_ioctl+0x44>
 322582c:	e0fff917 	ldw	r3,-28(fp)
 3225830:	e0bffa17 	ldw	r2,-24(fp)
 3225834:	18800426 	beq	r3,r2,3225848 <bsd_ioctl+0x84>
 3225838:	322aef00 	call	322aef0 <dtrap>
 322583c:	00bfffc4 	movi	r2,-1
 3225840:	e0bfff15 	stw	r2,-4(fp)
 3225844:	00001a06 	br	32258b0 <bsd_ioctl+0xec>

   va_start(argptr, request);
 3225848:	e0800204 	addi	r2,fp,8
 322584c:	e0bffb15 	stw	r2,-20(fp)

   switch (request)
 3225850:	e0bffe17 	ldw	r2,-8(fp)
 3225854:	108405a0 	cmpeqi	r2,r2,4118
 3225858:	1000011e 	bne	r2,zero,3225860 <bsd_ioctl+0x9c>
 322585c:	00000f06 	br	322589c <bsd_ioctl+0xd8>
   {
   case FIONBIO:
      iarg = va_arg(argptr, int);
 3225860:	e0fffb17 	ldw	r3,-20(fp)
 3225864:	18800104 	addi	r2,r3,4
 3225868:	e0bffb15 	stw	r2,-20(fp)
 322586c:	1805883a 	mov	r2,r3
 3225870:	10800017 	ldw	r2,0(r2)
 3225874:	e0bffc15 	stw	r2,-16(fp)
      va_end(argptr);
      return t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, &iarg, sizeof(iarg));
 3225878:	e1fffc04 	addi	r7,fp,-16
 322587c:	00800104 	movi	r2,4
 3225880:	d8800015 	stw	r2,0(sp)
 3225884:	e13ffd17 	ldw	r4,-12(fp)
 3225888:	017fffc4 	movi	r5,-1
 322588c:	01840584 	movi	r6,4118
 3225890:	322ea280 	call	322ea28 <t_setsockopt>
 3225894:	e0bfff15 	stw	r2,-4(fp)
 3225898:	00000506 	br	32258b0 <bsd_ioctl+0xec>
   default:
      so->so_error = EINVAL;
 322589c:	e0fffa17 	ldw	r3,-24(fp)
 32258a0:	00800584 	movi	r2,22
 32258a4:	18800615 	stw	r2,24(r3)
      return -1;
 32258a8:	00bfffc4 	movi	r2,-1
 32258ac:	e0bfff15 	stw	r2,-4(fp)
 32258b0:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 32258b4:	e037883a 	mov	sp,fp
 32258b8:	dfc00117 	ldw	ra,4(sp)
 32258bc:	df000017 	ldw	fp,0(sp)
 32258c0:	dec00404 	addi	sp,sp,16
 32258c4:	f800283a 	ret

032258c8 <bsd_inet_ntoa>:
 * RETURNS: pointer to null-terminated string containing dotted-decimal
 *          printable representation of in
 */
char *
bsd_inet_ntoa(struct in_addr in)
{
 32258c8:	defffd04 	addi	sp,sp,-12
 32258cc:	dfc00215 	stw	ra,8(sp)
 32258d0:	df000115 	stw	fp,4(sp)
 32258d4:	df000104 	addi	fp,sp,4
 32258d8:	e13fff15 	stw	r4,-4(fp)
   return print_ipad(in.s_addr);
 32258dc:	e13fff17 	ldw	r4,-4(fp)
 32258e0:	3225fb40 	call	3225fb4 <print_ipad>
}
 32258e4:	e037883a 	mov	sp,fp
 32258e8:	dfc00117 	ldw	ra,4(sp)
 32258ec:	df000017 	ldw	fp,0(sp)
 32258f0:	dec00204 	addi	sp,sp,8
 32258f4:	f800283a 	ret

032258f8 <bsd_recvfrom>:
bsd_recvfrom(BSD_SOCKET s,
             void * buf,
             BSD_SIZE_T len,
             int flags,
             struct sockaddr * from, int * fromlen)
{
 32258f8:	deffef04 	addi	sp,sp,-68
 32258fc:	dfc01015 	stw	ra,64(sp)
 3225900:	df000f15 	stw	fp,60(sp)
 3225904:	df000f04 	addi	fp,sp,60
 3225908:	e13ffb15 	stw	r4,-20(fp)
 322590c:	e17ffc15 	stw	r5,-16(fp)
 3225910:	e1bffd15 	stw	r6,-12(fp)
 3225914:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;
   struct sockaddr lfrom;
   int lfromlen = 0;
 3225918:	e03ffa15 	stw	zero,-24(fp)
   int lret;

   so = LONG2SO(s);
 322591c:	e0bffb17 	ldw	r2,-20(fp)
 3225920:	10bff804 	addi	r2,r2,-32
 3225924:	1085883a 	add	r2,r2,r2
 3225928:	1085883a 	add	r2,r2,r2
 322592c:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 3225930:	0080c9b4 	movhi	r2,806
 3225934:	10b48204 	addi	r2,r2,-11768
 3225938:	e0bff315 	stw	r2,-52(fp)
 322593c:	00000606 	br	3225958 <bsd_recvfrom+0x60>
 3225940:	e0fff317 	ldw	r3,-52(fp)
 3225944:	e0bff517 	ldw	r2,-44(fp)
 3225948:	18800626 	beq	r3,r2,3225964 <bsd_recvfrom+0x6c>
 322594c:	e0bff317 	ldw	r2,-52(fp)
 3225950:	10800017 	ldw	r2,0(r2)
 3225954:	e0bff315 	stw	r2,-52(fp)
 3225958:	e0bff317 	ldw	r2,-52(fp)
 322595c:	1004c03a 	cmpne	r2,r2,zero
 3225960:	103ff71e 	bne	r2,zero,3225940 <bsd_recvfrom+0x48>
 3225964:	e0fff317 	ldw	r3,-52(fp)
 3225968:	e0bff517 	ldw	r2,-44(fp)
 322596c:	18800426 	beq	r3,r2,3225980 <bsd_recvfrom+0x88>
 3225970:	322aef00 	call	322aef0 <dtrap>
 3225974:	00bfffc4 	movi	r2,-1
 3225978:	e0bfff15 	stw	r2,-4(fp)
 322597c:	00003006 	br	3225a40 <bsd_recvfrom+0x148>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (from != NULL)
 3225980:	e0800217 	ldw	r2,8(fp)
 3225984:	1005003a 	cmpeq	r2,r2,zero
 3225988:	10000c1e 	bne	r2,zero,32259bc <bsd_recvfrom+0xc4>
   {
      if (fromlen == NULL)
 322598c:	e0800317 	ldw	r2,12(fp)
 3225990:	1004c03a 	cmpne	r2,r2,zero
 3225994:	1000061e 	bne	r2,zero,32259b0 <bsd_recvfrom+0xb8>
      {
         so->so_error = EFAULT;
 3225998:	e0fff517 	ldw	r3,-44(fp)
 322599c:	00800384 	movi	r2,14
 32259a0:	18800615 	stw	r2,24(r3)
         return -1;
 32259a4:	00bfffc4 	movi	r2,-1
 32259a8:	e0bfff15 	stw	r2,-4(fp)
 32259ac:	00002406 	br	3225a40 <bsd_recvfrom+0x148>
      }
      lfromlen = *fromlen;
 32259b0:	e0800317 	ldw	r2,12(fp)
 32259b4:	10800017 	ldw	r2,0(r2)
 32259b8:	e0bffa15 	stw	r2,-24(fp)
   }

   lret = t_recvfrom(s, (char *)buf, len, flags, &lfrom, &lfromlen );
 32259bc:	e17ffc17 	ldw	r5,-16(fp)
 32259c0:	e0bff604 	addi	r2,fp,-40
 32259c4:	d8800015 	stw	r2,0(sp)
 32259c8:	e0bffa04 	addi	r2,fp,-24
 32259cc:	d8800115 	stw	r2,4(sp)
 32259d0:	e13ffb17 	ldw	r4,-20(fp)
 32259d4:	e1bffd17 	ldw	r6,-12(fp)
 32259d8:	e1fffe17 	ldw	r7,-8(fp)
 32259dc:	322ee980 	call	322ee98 <t_recvfrom>
 32259e0:	e0bff415 	stw	r2,-48(fp)
    * sockaddr_in), which is all that t_recvfrom() can return as a peer
    * name.
    * For IPV6 addresses or dual IPV4/IPV6 stack, the max size copied
    * is sizeof(struct sockaddr_in6)
    */
   if ((lret != -1) && (from != NULL))
 32259e4:	e0bff417 	ldw	r2,-48(fp)
 32259e8:	10bfffe0 	cmpeqi	r2,r2,-1
 32259ec:	1000121e 	bne	r2,zero,3225a38 <bsd_recvfrom+0x140>
 32259f0:	e0800217 	ldw	r2,8(fp)
 32259f4:	1005003a 	cmpeq	r2,r2,zero
 32259f8:	10000f1e 	bne	r2,zero,3225a38 <bsd_recvfrom+0x140>
   {
#ifndef IP_V6
      if (lfromlen > sizeof(struct sockaddr_in))
 32259fc:	e0bffa17 	ldw	r2,-24(fp)
 3225a00:	10800470 	cmpltui	r2,r2,17
 3225a04:	1000021e 	bne	r2,zero,3225a10 <bsd_recvfrom+0x118>
         lfromlen = sizeof(struct sockaddr_in);
 3225a08:	00800404 	movi	r2,16
 3225a0c:	e0bffa15 	stw	r2,-24(fp)
#else
      if (lfromlen > sizeof(struct sockaddr_in6))
         lfromlen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(from, &lfrom, lfromlen);
 3225a10:	e0bffa17 	ldw	r2,-24(fp)
 3225a14:	100d883a 	mov	r6,r2
 3225a18:	e0800217 	ldw	r2,8(fp)
 3225a1c:	e0fff604 	addi	r3,fp,-40
 3225a20:	1009883a 	mov	r4,r2
 3225a24:	180b883a 	mov	r5,r3
 3225a28:	3206ad00 	call	3206ad0 <memcpy>
      *fromlen = lfromlen;
 3225a2c:	e0fffa17 	ldw	r3,-24(fp)
 3225a30:	e0800317 	ldw	r2,12(fp)
 3225a34:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 3225a38:	e0bff417 	ldw	r2,-48(fp)
 3225a3c:	e0bfff15 	stw	r2,-4(fp)
 3225a40:	e0bfff17 	ldw	r2,-4(fp)
}
 3225a44:	e037883a 	mov	sp,fp
 3225a48:	dfc00117 	ldw	ra,4(sp)
 3225a4c:	df000017 	ldw	fp,0(sp)
 3225a50:	dec00204 	addi	sp,sp,8
 3225a54:	f800283a 	ret

03225a58 <bsd_select>:
bsd_select(int nfds,
           fd_set * readfds,
           fd_set * writefds,
           fd_set * exceptfds,
           BSD_TIMEVAL_T * timeout)
{
 3225a58:	defff804 	addi	sp,sp,-32
 3225a5c:	dfc00715 	stw	ra,28(sp)
 3225a60:	df000615 	stw	fp,24(sp)
 3225a64:	df000604 	addi	fp,sp,24
 3225a68:	e13ffc15 	stw	r4,-16(fp)
 3225a6c:	e17ffd15 	stw	r5,-12(fp)
 3225a70:	e1bffe15 	stw	r6,-8(fp)
 3225a74:	e1ffff15 	stw	r7,-4(fp)
   long ltv;    /* timeout expressed in ticks */
   long tps;    /* local copy of TPS */

   USE_ARG(nfds);

   if (timeout != NULL)
 3225a78:	e0800217 	ldw	r2,8(fp)
 3225a7c:	1005003a 	cmpeq	r2,r2,zero
 3225a80:	1000431e 	bne	r2,zero,3225b90 <bsd_select+0x138>
       * million (i.e. any number of microseconds up to one second).
       * So we scale tv_usec from microseconds to something reasonable
       * based on TPS, multiply it by TPS, then scale it the rest of
       * the way to ticks-per-second.
       */
      tps = TPS;
 3225a84:	0080fa04 	movi	r2,1000
 3225a88:	e0bffa15 	stw	r2,-24(fp)
      if (tps >= 1000)
 3225a8c:	e0bffa17 	ldw	r2,-24(fp)
 3225a90:	1080fa10 	cmplti	r2,r2,1000
 3225a94:	10000c1e 	bne	r2,zero,3225ac8 <bsd_select+0x70>
      {
         ltv = (((timeout->tv_usec + 50) / 100) * tps) / 10000;
 3225a98:	e0800217 	ldw	r2,8(fp)
 3225a9c:	10800117 	ldw	r2,4(r2)
 3225aa0:	11000c84 	addi	r4,r2,50
 3225aa4:	01401904 	movi	r5,100
 3225aa8:	32047000 	call	3204700 <__divsi3>
 3225aac:	1007883a 	mov	r3,r2
 3225ab0:	e0bffa17 	ldw	r2,-24(fp)
 3225ab4:	1889383a 	mul	r4,r3,r2
 3225ab8:	0149c404 	movi	r5,10000
 3225abc:	32047000 	call	3204700 <__divsi3>
 3225ac0:	e0bffb15 	stw	r2,-20(fp)
 3225ac4:	00002b06 	br	3225b74 <bsd_select+0x11c>
      }
      else if (tps >= 100)
 3225ac8:	e0bffa17 	ldw	r2,-24(fp)
 3225acc:	10801910 	cmplti	r2,r2,100
 3225ad0:	10000c1e 	bne	r2,zero,3225b04 <bsd_select+0xac>
      {
         ltv = (((timeout->tv_usec + 500) / 1000) * tps) / 1000;
 3225ad4:	e0800217 	ldw	r2,8(fp)
 3225ad8:	10800117 	ldw	r2,4(r2)
 3225adc:	11007d04 	addi	r4,r2,500
 3225ae0:	0140fa04 	movi	r5,1000
 3225ae4:	32047000 	call	3204700 <__divsi3>
 3225ae8:	1007883a 	mov	r3,r2
 3225aec:	e0bffa17 	ldw	r2,-24(fp)
 3225af0:	1889383a 	mul	r4,r3,r2
 3225af4:	0140fa04 	movi	r5,1000
 3225af8:	32047000 	call	3204700 <__divsi3>
 3225afc:	e0bffb15 	stw	r2,-20(fp)
 3225b00:	00001c06 	br	3225b74 <bsd_select+0x11c>
      }
      else if (tps >= 10)
 3225b04:	e0bffa17 	ldw	r2,-24(fp)
 3225b08:	10800290 	cmplti	r2,r2,10
 3225b0c:	10000c1e 	bne	r2,zero,3225b40 <bsd_select+0xe8>
      {
         ltv = (((timeout->tv_usec + 5000) / 10000) * tps) / 100;
 3225b10:	e0800217 	ldw	r2,8(fp)
 3225b14:	10800117 	ldw	r2,4(r2)
 3225b18:	1104e204 	addi	r4,r2,5000
 3225b1c:	0149c404 	movi	r5,10000
 3225b20:	32047000 	call	3204700 <__divsi3>
 3225b24:	1007883a 	mov	r3,r2
 3225b28:	e0bffa17 	ldw	r2,-24(fp)
 3225b2c:	1889383a 	mul	r4,r3,r2
 3225b30:	01401904 	movi	r5,100
 3225b34:	32047000 	call	3204700 <__divsi3>
 3225b38:	e0bffb15 	stw	r2,-20(fp)
 3225b3c:	00000d06 	br	3225b74 <bsd_select+0x11c>
      }
      else
      {
         ltv = (((timeout->tv_usec + 50000) / 100000) * tps) / 10;
 3225b40:	e0800217 	ldw	r2,8(fp)
 3225b44:	10c00117 	ldw	r3,4(r2)
 3225b48:	00b0d414 	movui	r2,50000
 3225b4c:	1889883a 	add	r4,r3,r2
 3225b50:	014000b4 	movhi	r5,2
 3225b54:	2961a804 	addi	r5,r5,-31072
 3225b58:	32047000 	call	3204700 <__divsi3>
 3225b5c:	1007883a 	mov	r3,r2
 3225b60:	e0bffa17 	ldw	r2,-24(fp)
 3225b64:	1889383a 	mul	r4,r3,r2
 3225b68:	01400284 	movi	r5,10
 3225b6c:	32047000 	call	3204700 <__divsi3>
 3225b70:	e0bffb15 	stw	r2,-20(fp)
      }
      ltv += (timeout->tv_sec * TPS);
 3225b74:	e0800217 	ldw	r2,8(fp)
 3225b78:	10800017 	ldw	r2,0(r2)
 3225b7c:	10c0fa24 	muli	r3,r2,1000
 3225b80:	e0bffb17 	ldw	r2,-20(fp)
 3225b84:	1885883a 	add	r2,r3,r2
 3225b88:	e0bffb15 	stw	r2,-20(fp)
 3225b8c:	00000206 	br	3225b98 <bsd_select+0x140>
   }
   else {
      /*
       * NULL timeout: wait indefinitely in t_select()
       */
      ltv = -1;
 3225b90:	00bfffc4 	movi	r2,-1
 3225b94:	e0bffb15 	stw	r2,-20(fp)
   }

   return (t_select(readfds, writefds, exceptfds, ltv));
 3225b98:	e13ffd17 	ldw	r4,-12(fp)
 3225b9c:	e17ffe17 	ldw	r5,-8(fp)
 3225ba0:	e1bfff17 	ldw	r6,-4(fp)
 3225ba4:	e1fffb17 	ldw	r7,-20(fp)
 3225ba8:	3232db00 	call	3232db0 <t_select>
}
 3225bac:	e037883a 	mov	sp,fp
 3225bb0:	dfc00117 	ldw	ra,4(sp)
 3225bb4:	df000017 	ldw	fp,0(sp)
 3225bb8:	dec00204 	addi	sp,sp,8
 3225bbc:	f800283a 	ret

03225bc0 <bsd_setsockopt>:
int 
bsd_setsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int optlen)
{
 3225bc0:	defff604 	addi	sp,sp,-40
 3225bc4:	dfc00915 	stw	ra,36(sp)
 3225bc8:	df000815 	stw	fp,32(sp)
 3225bcc:	df000804 	addi	fp,sp,32
 3225bd0:	e13ffb15 	stw	r4,-20(fp)
 3225bd4:	e17ffc15 	stw	r5,-16(fp)
 3225bd8:	e1bffd15 	stw	r6,-12(fp)
 3225bdc:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;

   so = LONG2SO(s);
 3225be0:	e0bffb17 	ldw	r2,-20(fp)
 3225be4:	10bff804 	addi	r2,r2,-32
 3225be8:	1085883a 	add	r2,r2,r2
 3225bec:	1085883a 	add	r2,r2,r2
 3225bf0:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 3225bf4:	0080c9b4 	movhi	r2,806
 3225bf8:	10b48204 	addi	r2,r2,-11768
 3225bfc:	e0bff915 	stw	r2,-28(fp)
 3225c00:	00000606 	br	3225c1c <bsd_setsockopt+0x5c>
 3225c04:	e0fff917 	ldw	r3,-28(fp)
 3225c08:	e0bffa17 	ldw	r2,-24(fp)
 3225c0c:	18800626 	beq	r3,r2,3225c28 <bsd_setsockopt+0x68>
 3225c10:	e0bff917 	ldw	r2,-28(fp)
 3225c14:	10800017 	ldw	r2,0(r2)
 3225c18:	e0bff915 	stw	r2,-28(fp)
 3225c1c:	e0bff917 	ldw	r2,-28(fp)
 3225c20:	1004c03a 	cmpne	r2,r2,zero
 3225c24:	103ff71e 	bne	r2,zero,3225c04 <bsd_setsockopt+0x44>
 3225c28:	e0fff917 	ldw	r3,-28(fp)
 3225c2c:	e0bffa17 	ldw	r2,-24(fp)
 3225c30:	18800426 	beq	r3,r2,3225c44 <bsd_setsockopt+0x84>
 3225c34:	322aef00 	call	322aef0 <dtrap>
 3225c38:	00bfffc4 	movi	r2,-1
 3225c3c:	e0bfff15 	stw	r2,-4(fp)
 3225c40:	00001406 	br	3225c94 <bsd_setsockopt+0xd4>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   if (optlen < bsd_i_sockoptlen(level, name))
 3225c44:	e13ffc17 	ldw	r4,-16(fp)
 3225c48:	e17ffd17 	ldw	r5,-12(fp)
 3225c4c:	32254ec0 	call	32254ec <bsd_i_sockoptlen>
 3225c50:	1007883a 	mov	r3,r2
 3225c54:	e0800217 	ldw	r2,8(fp)
 3225c58:	10c0060e 	bge	r2,r3,3225c74 <bsd_setsockopt+0xb4>
   {
      so->so_error = EFAULT;
 3225c5c:	e0fffa17 	ldw	r3,-24(fp)
 3225c60:	00800384 	movi	r2,14
 3225c64:	18800615 	stw	r2,24(r3)
      return -1;
 3225c68:	00bfffc4 	movi	r2,-1
 3225c6c:	e0bfff15 	stw	r2,-4(fp)
 3225c70:	00000806 	br	3225c94 <bsd_setsockopt+0xd4>
   }

   return t_setsockopt(s, level, name, opt, optlen);
 3225c74:	e0800217 	ldw	r2,8(fp)
 3225c78:	d8800015 	stw	r2,0(sp)
 3225c7c:	e13ffb17 	ldw	r4,-20(fp)
 3225c80:	e17ffc17 	ldw	r5,-16(fp)
 3225c84:	e1bffd17 	ldw	r6,-12(fp)
 3225c88:	e1fffe17 	ldw	r7,-8(fp)
 3225c8c:	322ea280 	call	322ea28 <t_setsockopt>
 3225c90:	e0bfff15 	stw	r2,-4(fp)
 3225c94:	e0bfff17 	ldw	r2,-4(fp)
}
 3225c98:	e037883a 	mov	sp,fp
 3225c9c:	dfc00117 	ldw	ra,4(sp)
 3225ca0:	df000017 	ldw	fp,0(sp)
 3225ca4:	dec00204 	addi	sp,sp,8
 3225ca8:	f800283a 	ret

03225cac <ccksum>:
 * be done in 16-bit chunks.
 */

unsigned short
ccksum (void *ptr, unsigned words)
{
 3225cac:	defffa04 	addi	sp,sp,-24
 3225cb0:	df000515 	stw	fp,20(sp)
 3225cb4:	df000504 	addi	fp,sp,20
 3225cb8:	e13ffe15 	stw	r4,-8(fp)
 3225cbc:	e17fff15 	stw	r5,-4(fp)
   unsigned short *addr = (unsigned short *)ptr;
 3225cc0:	e0bffe17 	ldw	r2,-8(fp)
 3225cc4:	e0bffd15 	stw	r2,-12(fp)
   unsigned long sum = 0;
 3225cc8:	e03ffc15 	stw	zero,-16(fp)
   int count = (int)words;
 3225ccc:	e0bfff17 	ldw	r2,-4(fp)
 3225cd0:	e0bffb15 	stw	r2,-20(fp)

   while (--count >= 0)
 3225cd4:	00000906 	br	3225cfc <ccksum+0x50>
   {
      /*  This is the inner loop */
      sum += *addr++;
 3225cd8:	e0bffd17 	ldw	r2,-12(fp)
 3225cdc:	1080000b 	ldhu	r2,0(r2)
 3225ce0:	10ffffcc 	andi	r3,r2,65535
 3225ce4:	e0bffc17 	ldw	r2,-16(fp)
 3225ce8:	10c5883a 	add	r2,r2,r3
 3225cec:	e0bffc15 	stw	r2,-16(fp)
 3225cf0:	e0bffd17 	ldw	r2,-12(fp)
 3225cf4:	10800084 	addi	r2,r2,2
 3225cf8:	e0bffd15 	stw	r2,-12(fp)
{
   unsigned short *addr = (unsigned short *)ptr;
   unsigned long sum = 0;
   int count = (int)words;

   while (--count >= 0)
 3225cfc:	e0bffb17 	ldw	r2,-20(fp)
 3225d00:	10bfffc4 	addi	r2,r2,-1
 3225d04:	e0bffb15 	stw	r2,-20(fp)
 3225d08:	e0bffb17 	ldw	r2,-20(fp)
 3225d0c:	1004403a 	cmpge	r2,r2,zero
 3225d10:	103ff11e 	bne	r2,zero,3225cd8 <ccksum+0x2c>
      /*  This is the inner loop */
      sum += *addr++;
   }

   /*  Fold 32-bit sum to 16 bits */
   sum = (sum & 0xffff) + (sum >> 16);
 3225d14:	e0bffc17 	ldw	r2,-16(fp)
 3225d18:	10ffffcc 	andi	r3,r2,65535
 3225d1c:	e0bffc17 	ldw	r2,-16(fp)
 3225d20:	1004d43a 	srli	r2,r2,16
 3225d24:	1885883a 	add	r2,r3,r2
 3225d28:	e0bffc15 	stw	r2,-16(fp)
   sum = (sum & 0xffff) + (sum >> 16);
 3225d2c:	e0bffc17 	ldw	r2,-16(fp)
 3225d30:	10ffffcc 	andi	r3,r2,65535
 3225d34:	e0bffc17 	ldw	r2,-16(fp)
 3225d38:	1004d43a 	srli	r2,r2,16
 3225d3c:	1885883a 	add	r2,r3,r2
 3225d40:	e0bffc15 	stw	r2,-16(fp)

   /* checksum = ~sum; *//* removed for MIT IP stack */
   return ((unsigned short)sum);
 3225d44:	e0bffc17 	ldw	r2,-16(fp)
 3225d48:	10bfffcc 	andi	r2,r2,65535
}
 3225d4c:	e037883a 	mov	sp,fp
 3225d50:	df000017 	ldw	fp,0(sp)
 3225d54:	dec00104 	addi	sp,sp,4
 3225d58:	f800283a 	ret

03225d5c <cksum>:
 *    3 = user-supplied alternate implementation
 */

unsigned short
cksum (void *ptr, unsigned count)
{
 3225d5c:	defffb04 	addi	sp,sp,-20
 3225d60:	dfc00415 	stw	ra,16(sp)
 3225d64:	df000315 	stw	fp,12(sp)
 3225d68:	df000304 	addi	fp,sp,12
 3225d6c:	e13ffd15 	stw	r4,-12(fp)
 3225d70:	e17ffe15 	stw	r5,-8(fp)
   switch (cksum_select)
 3225d74:	d0a02d17 	ldw	r2,-32588(gp)
 3225d78:	108000a0 	cmpeqi	r2,r2,2
 3225d7c:	1000061e 	bne	r2,zero,3225d98 <cksum+0x3c>
   {
      case 1:
      default:
         return (ccksum(ptr, count));
 3225d80:	e13ffd17 	ldw	r4,-12(fp)
 3225d84:	e17ffe17 	ldw	r5,-8(fp)
 3225d88:	3225cac0 	call	3225cac <ccksum>
 3225d8c:	10bfffcc 	andi	r2,r2,65535
 3225d90:	e0bfff15 	stw	r2,-4(fp)
 3225d94:	00000506 	br	3225dac <cksum+0x50>
 #ifndef C_CHECKSUM
      case 2:
         return (asm_cksum(ptr, count));
 3225d98:	e13ffd17 	ldw	r4,-12(fp)
 3225d9c:	e17ffe17 	ldw	r5,-8(fp)
 3225da0:	322ad5c0 	call	322ad5c <asm_cksum>
 3225da4:	10bfffcc 	andi	r2,r2,65535
 3225da8:	e0bfff15 	stw	r2,-4(fp)
 3225dac:	e0bfff17 	ldw	r2,-4(fp)
#else
#endif
         return (alt_cksum(ptr, count));
#endif
   }
}
 3225db0:	e037883a 	mov	sp,fp
 3225db4:	dfc00117 	ldw	ra,4(sp)
 3225db8:	df000017 	ldw	fp,0(sp)
 3225dbc:	dec00204 	addi	sp,sp,8
 3225dc0:	f800283a 	ret

03225dc4 <do_trap>:
 * RETURNS: 0
 */

int
do_trap(void)
{
 3225dc4:	defffe04 	addi	sp,sp,-8
 3225dc8:	dfc00115 	stw	ra,4(sp)
 3225dcc:	df000015 	stw	fp,0(sp)
 3225dd0:	d839883a 	mov	fp,sp
   dtrap();
 3225dd4:	322aef00 	call	322aef0 <dtrap>
   return 0;
 3225dd8:	0005883a 	mov	r2,zero
}
 3225ddc:	e037883a 	mov	sp,fp
 3225de0:	dfc00117 	ldw	ra,4(sp)
 3225de4:	df000017 	ldw	fp,0(sp)
 3225de8:	dec00204 	addi	sp,sp,8
 3225dec:	f800283a 	ret

03225df0 <nextarg>:
 * RETURNS:  pointer to next arg in string 
 */

char *   
nextarg(char * argp)
{
 3225df0:	defffe04 	addi	sp,sp,-8
 3225df4:	df000115 	stw	fp,4(sp)
 3225df8:	df000104 	addi	fp,sp,4
 3225dfc:	e13fff15 	stw	r4,-4(fp)
   while (*argp > ' ')argp++; /* scan past current arg */
 3225e00:	00000306 	br	3225e10 <nextarg+0x20>
 3225e04:	e0bfff17 	ldw	r2,-4(fp)
 3225e08:	10800044 	addi	r2,r2,1
 3225e0c:	e0bfff15 	stw	r2,-4(fp)
 3225e10:	e0bfff17 	ldw	r2,-4(fp)
 3225e14:	10800003 	ldbu	r2,0(r2)
 3225e18:	10803fcc 	andi	r2,r2,255
 3225e1c:	1080201c 	xori	r2,r2,128
 3225e20:	10bfe004 	addi	r2,r2,-128
 3225e24:	10800848 	cmpgei	r2,r2,33
 3225e28:	103ff61e 	bne	r2,zero,3225e04 <nextarg+0x14>
      while (*argp == ' ')argp++;   /* scan past spaces */
 3225e2c:	00000306 	br	3225e3c <nextarg+0x4c>
 3225e30:	e0bfff17 	ldw	r2,-4(fp)
 3225e34:	10800044 	addi	r2,r2,1
 3225e38:	e0bfff15 	stw	r2,-4(fp)
 3225e3c:	e0bfff17 	ldw	r2,-4(fp)
 3225e40:	10800003 	ldbu	r2,0(r2)
 3225e44:	10803fcc 	andi	r2,r2,255
 3225e48:	1080201c 	xori	r2,r2,128
 3225e4c:	10bfe004 	addi	r2,r2,-128
 3225e50:	10800820 	cmpeqi	r2,r2,32
 3225e54:	103ff61e 	bne	r2,zero,3225e30 <nextarg+0x40>
      return (argp);
 3225e58:	e0bfff17 	ldw	r2,-4(fp)
}
 3225e5c:	e037883a 	mov	sp,fp
 3225e60:	df000017 	ldw	fp,0(sp)
 3225e64:	dec00104 	addi	sp,sp,4
 3225e68:	f800283a 	ret

03225e6c <hexdump>:

#define  HEX_BYTES_PER_LINE   16

void
hexdump(void * pio, void * buffer, unsigned len)
{
 3225e6c:	defff704 	addi	sp,sp,-36
 3225e70:	dfc00815 	stw	ra,32(sp)
 3225e74:	df000715 	stw	fp,28(sp)
 3225e78:	df000704 	addi	fp,sp,28
 3225e7c:	e13ffc15 	stw	r4,-16(fp)
 3225e80:	e17ffd15 	stw	r5,-12(fp)
 3225e84:	e1bffe15 	stw	r6,-8(fp)
   u_char * data  =  (u_char *)buffer;
 3225e88:	e0bffd17 	ldw	r2,-12(fp)
 3225e8c:	e0bffb15 	stw	r2,-20(fp)
   unsigned int count;
   char  c;

   while (len)
 3225e90:	00004006 	br	3225f94 <hexdump+0x128>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 3225e94:	e03ffa15 	stw	zero,-24(fp)
 3225e98:	00000c06 	br	3225ecc <hexdump+0x60>
         ns_printf(pio, "%02x ", *(data + count));
 3225e9c:	e0fffa17 	ldw	r3,-24(fp)
 3225ea0:	e0bffb17 	ldw	r2,-20(fp)
 3225ea4:	1885883a 	add	r2,r3,r2
 3225ea8:	10800003 	ldbu	r2,0(r2)
 3225eac:	11803fcc 	andi	r6,r2,255
 3225eb0:	e13ffc17 	ldw	r4,-16(fp)
 3225eb4:	0140c974 	movhi	r5,805
 3225eb8:	297c2f04 	addi	r5,r5,-3908
 3225ebc:	322637c0 	call	322637c <ns_printf>
   char  c;

   while (len)
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 3225ec0:	e0bffa17 	ldw	r2,-24(fp)
 3225ec4:	10800044 	addi	r2,r2,1
 3225ec8:	e0bffa15 	stw	r2,-24(fp)
 3225ecc:	e0bffa17 	ldw	r2,-24(fp)
 3225ed0:	10800428 	cmpgeui	r2,r2,16
 3225ed4:	1000031e 	bne	r2,zero,3225ee4 <hexdump+0x78>
 3225ed8:	e0fffa17 	ldw	r3,-24(fp)
 3225edc:	e0bffe17 	ldw	r2,-8(fp)
 3225ee0:	18bfee36 	bltu	r3,r2,3225e9c <hexdump+0x30>
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 3225ee4:	e03ffa15 	stw	zero,-24(fp)
 3225ee8:	00001806 	br	3225f4c <hexdump+0xe0>
      {
         c = *(data + count);
 3225eec:	e0fffa17 	ldw	r3,-24(fp)
 3225ef0:	e0bffb17 	ldw	r2,-20(fp)
 3225ef4:	1885883a 	add	r2,r3,r2
 3225ef8:	10800003 	ldbu	r2,0(r2)
 3225efc:	e0bff905 	stb	r2,-28(fp)
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
 3225f00:	e0bff907 	ldb	r2,-28(fp)
 3225f04:	10800810 	cmplti	r2,r2,32
 3225f08:	1000061e 	bne	r2,zero,3225f24 <hexdump+0xb8>
 3225f0c:	e0bff907 	ldb	r2,-28(fp)
 3225f10:	10801fe0 	cmpeqi	r2,r2,127
 3225f14:	1000031e 	bne	r2,zero,3225f24 <hexdump+0xb8>
 3225f18:	e0bff907 	ldb	r2,-28(fp)
 3225f1c:	e0bfff15 	stw	r2,-4(fp)
 3225f20:	00000206 	br	3225f2c <hexdump+0xc0>
 3225f24:	00800b84 	movi	r2,46
 3225f28:	e0bfff15 	stw	r2,-4(fp)
 3225f2c:	e13ffc17 	ldw	r4,-16(fp)
 3225f30:	0140c974 	movhi	r5,805
 3225f34:	297c3104 	addi	r5,r5,-3900
 3225f38:	e1bfff17 	ldw	r6,-4(fp)
 3225f3c:	322637c0 	call	322637c <ns_printf>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 3225f40:	e0bffa17 	ldw	r2,-24(fp)
 3225f44:	10800044 	addi	r2,r2,1
 3225f48:	e0bffa15 	stw	r2,-24(fp)
 3225f4c:	e0bffa17 	ldw	r2,-24(fp)
 3225f50:	10800428 	cmpgeui	r2,r2,16
 3225f54:	1000031e 	bne	r2,zero,3225f64 <hexdump+0xf8>
 3225f58:	e0fffa17 	ldw	r3,-24(fp)
 3225f5c:	e0bffe17 	ldw	r2,-8(fp)
 3225f60:	18bfe236 	bltu	r3,r2,3225eec <hexdump+0x80>
      {
         c = *(data + count);
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
      }
      ns_printf(pio,"\n");
 3225f64:	e13ffc17 	ldw	r4,-16(fp)
 3225f68:	0140c974 	movhi	r5,805
 3225f6c:	297c3204 	addi	r5,r5,-3896
 3225f70:	322637c0 	call	322637c <ns_printf>
      len -= count;
 3225f74:	e0fffe17 	ldw	r3,-8(fp)
 3225f78:	e0bffa17 	ldw	r2,-24(fp)
 3225f7c:	1885c83a 	sub	r2,r3,r2
 3225f80:	e0bffe15 	stw	r2,-8(fp)
      data += count;
 3225f84:	e0fffa17 	ldw	r3,-24(fp)
 3225f88:	e0bffb17 	ldw	r2,-20(fp)
 3225f8c:	10c5883a 	add	r2,r2,r3
 3225f90:	e0bffb15 	stw	r2,-20(fp)
{
   u_char * data  =  (u_char *)buffer;
   unsigned int count;
   char  c;

   while (len)
 3225f94:	e0bffe17 	ldw	r2,-8(fp)
 3225f98:	1004c03a 	cmpne	r2,r2,zero
 3225f9c:	103fbd1e 	bne	r2,zero,3225e94 <hexdump+0x28>
      }
      ns_printf(pio,"\n");
      len -= count;
      data += count;
   }
}
 3225fa0:	e037883a 	mov	sp,fp
 3225fa4:	dfc00117 	ldw	ra,4(sp)
 3225fa8:	df000017 	ldw	fp,0(sp)
 3225fac:	dec00204 	addi	sp,sp,8
 3225fb0:	f800283a 	ret

03225fb4 <print_ipad>:

char     ipreturn[18];     /* buffer for return */

char *   
print_ipad(unsigned long ipaddr)
{
 3225fb4:	defffa04 	addi	sp,sp,-24
 3225fb8:	dfc00515 	stw	ra,20(sp)
 3225fbc:	df000415 	stw	fp,16(sp)
 3225fc0:	df000404 	addi	fp,sp,16
 3225fc4:	e13fff15 	stw	r4,-4(fp)
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
 3225fc8:	e0bfff17 	ldw	r2,-4(fp)
 3225fcc:	e0bffe15 	stw	r2,-8(fp)
   sprintf(ipreturn, "%u.%u.%u.%u", 
 3225fd0:	e0bffe03 	ldbu	r2,-8(fp)
 3225fd4:	11803fcc 	andi	r6,r2,255
 3225fd8:	e0bffe43 	ldbu	r2,-7(fp)
 3225fdc:	11c03fcc 	andi	r7,r2,255
 3225fe0:	e0bffe83 	ldbu	r2,-6(fp)
 3225fe4:	10c03fcc 	andi	r3,r2,255
 3225fe8:	e0bffec3 	ldbu	r2,-5(fp)
 3225fec:	10803fcc 	andi	r2,r2,255
 3225ff0:	d8c00015 	stw	r3,0(sp)
 3225ff4:	d8800115 	stw	r2,4(sp)
 3225ff8:	0100c9b4 	movhi	r4,806
 3225ffc:	21336684 	addi	r4,r4,-12902
 3226000:	0140c974 	movhi	r5,805
 3226004:	297c3304 	addi	r5,r5,-3892
 3226008:	32079c00 	call	32079c0 <sprintf>
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);

   return ipreturn;
 322600c:	0080c9b4 	movhi	r2,806
 3226010:	10b36684 	addi	r2,r2,-12902
}
 3226014:	e037883a 	mov	sp,fp
 3226018:	dfc00117 	ldw	ra,4(sp)
 322601c:	df000017 	ldw	fp,0(sp)
 3226020:	dec00204 	addi	sp,sp,8
 3226024:	f800283a 	ret

03226028 <print_uptime>:

static char tistring[24];     /* buffer for return */

char *   
print_uptime(unsigned long timetick)
{
 3226028:	defff804 	addi	sp,sp,-32
 322602c:	dfc00715 	stw	ra,28(sp)
 3226030:	df000615 	stw	fp,24(sp)
 3226034:	df000604 	addi	fp,sp,24
 3226038:	e13fff15 	stw	r4,-4(fp)
   unsigned seconds, minutes, hours;

   timetick = timetick/100;   /* turn timetick into seconds */
 322603c:	e13fff17 	ldw	r4,-4(fp)
 3226040:	01401904 	movi	r5,100
 3226044:	32047c00 	call	32047c0 <__udivsi3>
 3226048:	e0bfff15 	stw	r2,-4(fp)
   seconds = (unsigned)(timetick%60);
 322604c:	e13fff17 	ldw	r4,-4(fp)
 3226050:	01400f04 	movi	r5,60
 3226054:	32047c80 	call	32047c8 <__umodsi3>
 3226058:	e0bffe15 	stw	r2,-8(fp)
   timetick = timetick/60;    /* turn timetick into minutes */
 322605c:	e13fff17 	ldw	r4,-4(fp)
 3226060:	01400f04 	movi	r5,60
 3226064:	32047c00 	call	32047c0 <__udivsi3>
 3226068:	e0bfff15 	stw	r2,-4(fp)
   minutes = (unsigned)(timetick%60);
 322606c:	e13fff17 	ldw	r4,-4(fp)
 3226070:	01400f04 	movi	r5,60
 3226074:	32047c80 	call	32047c8 <__umodsi3>
 3226078:	e0bffd15 	stw	r2,-12(fp)
   timetick = timetick/60;    /* turn timetick into hours */
 322607c:	e13fff17 	ldw	r4,-4(fp)
 3226080:	01400f04 	movi	r5,60
 3226084:	32047c00 	call	32047c0 <__udivsi3>
 3226088:	e0bfff15 	stw	r2,-4(fp)
   hours = (unsigned)(timetick%24);
 322608c:	e13fff17 	ldw	r4,-4(fp)
 3226090:	01400604 	movi	r5,24
 3226094:	32047c80 	call	32047c8 <__umodsi3>
 3226098:	e0bffc15 	stw	r2,-16(fp)
   timetick = timetick/24;    /* turn timetick into days */
 322609c:	e13fff17 	ldw	r4,-4(fp)
 32260a0:	01400604 	movi	r5,24
 32260a4:	32047c00 	call	32047c0 <__udivsi3>
 32260a8:	e0bfff15 	stw	r2,-4(fp)

   if (timetick)  /* Is there a whole number of days? */
 32260ac:	e0bfff17 	ldw	r2,-4(fp)
 32260b0:	1005003a 	cmpeq	r2,r2,zero
 32260b4:	10000c1e 	bne	r2,zero,32260e8 <print_uptime+0xc0>
      sprintf(tistring, "%ld days, %dh:%dm:%ds", 
 32260b8:	e0bffd17 	ldw	r2,-12(fp)
 32260bc:	d8800015 	stw	r2,0(sp)
 32260c0:	e0bffe17 	ldw	r2,-8(fp)
 32260c4:	d8800115 	stw	r2,4(sp)
 32260c8:	0100c974 	movhi	r4,805
 32260cc:	21159404 	addi	r4,r4,22096
 32260d0:	0140c974 	movhi	r5,805
 32260d4:	297c3604 	addi	r5,r5,-3880
 32260d8:	e1bfff17 	ldw	r6,-4(fp)
 32260dc:	e1fffc17 	ldw	r7,-16(fp)
 32260e0:	32079c00 	call	32079c0 <sprintf>
 32260e4:	00001406 	br	3226138 <print_uptime+0x110>
    timetick, hours, minutes, seconds);
   else if (hours)
 32260e8:	e0bffc17 	ldw	r2,-16(fp)
 32260ec:	1005003a 	cmpeq	r2,r2,zero
 32260f0:	10000a1e 	bne	r2,zero,322611c <print_uptime+0xf4>
      sprintf(tistring, "%d hours, %dm:%ds", hours, minutes, seconds);
 32260f4:	e0bffe17 	ldw	r2,-8(fp)
 32260f8:	d8800015 	stw	r2,0(sp)
 32260fc:	0100c974 	movhi	r4,805
 3226100:	21159404 	addi	r4,r4,22096
 3226104:	0140c974 	movhi	r5,805
 3226108:	297c3c04 	addi	r5,r5,-3856
 322610c:	e1bffc17 	ldw	r6,-16(fp)
 3226110:	e1fffd17 	ldw	r7,-12(fp)
 3226114:	32079c00 	call	32079c0 <sprintf>
 3226118:	00000706 	br	3226138 <print_uptime+0x110>
   else
      sprintf(tistring, "%d minutes, %d sec.", minutes, seconds);
 322611c:	0100c974 	movhi	r4,805
 3226120:	21159404 	addi	r4,r4,22096
 3226124:	0140c974 	movhi	r5,805
 3226128:	297c4104 	addi	r5,r5,-3836
 322612c:	e1bffd17 	ldw	r6,-12(fp)
 3226130:	e1fffe17 	ldw	r7,-8(fp)
 3226134:	32079c00 	call	32079c0 <sprintf>
   return tistring;
 3226138:	0080c974 	movhi	r2,805
 322613c:	10959404 	addi	r2,r2,22096
}
 3226140:	e037883a 	mov	sp,fp
 3226144:	dfc00117 	ldw	ra,4(sp)
 3226148:	df000017 	ldw	fp,0(sp)
 322614c:	dec00204 	addi	sp,sp,8
 3226150:	f800283a 	ret

03226154 <panic>:
/* allow to be ifdeffed out on systems which already have a panic */
#ifndef PANIC_ALREADY

void
panic(char * msg)
{
 3226154:	defffd04 	addi	sp,sp,-12
 3226158:	dfc00215 	stw	ra,8(sp)
 322615c:	df000115 	stw	fp,4(sp)
 3226160:	df000104 	addi	fp,sp,4
 3226164:	e13fff15 	stw	r4,-4(fp)
   dprintf("panic: %s\n", msg);
 3226168:	0100c974 	movhi	r4,805
 322616c:	213c4604 	addi	r4,r4,-3816
 3226170:	e17fff17 	ldw	r5,-4(fp)
 3226174:	3206de00 	call	3206de0 <printf>
   dtrap();                   /* try to hook debugger */
 3226178:	322aef00 	call	322aef0 <dtrap>
   netexit(1);                /* try to clean up */
 322617c:	01000044 	movi	r4,1
 3226180:	3243b540 	call	3243b54 <netexit>
}
 3226184:	e037883a 	mov	sp,fp
 3226188:	dfc00117 	ldw	ra,4(sp)
 322618c:	df000017 	ldw	fp,0(sp)
 3226190:	dec00204 	addi	sp,sp,8
 3226194:	f800283a 	ret

03226198 <print_eth>:

char     eth_prt_buf[18];  /* buffer for return */

char *   
print_eth(char * addr, char spacer)
{
 3226198:	defffb04 	addi	sp,sp,-20
 322619c:	df000415 	stw	fp,16(sp)
 32261a0:	df000404 	addi	fp,sp,16
 32261a4:	e13ffe15 	stw	r4,-8(fp)
 32261a8:	e17fff05 	stb	r5,-4(fp)
   int   i;
   char *   out   =  eth_prt_buf;
 32261ac:	0080c9b4 	movhi	r2,806
 32261b0:	10b36204 	addi	r2,r2,-12920
 32261b4:	e0bffc15 	stw	r2,-16(fp)

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 32261b8:	e03ffd15 	stw	zero,-12(fp)
 32261bc:	00004406 	br	32262d0 <print_eth+0x138>
   {
      /* high nibble */
      *out = (char)(((*addr >> 4) & 0x0f) + 0x30);
 32261c0:	e0bffe17 	ldw	r2,-8(fp)
 32261c4:	10800003 	ldbu	r2,0(r2)
 32261c8:	10803fcc 	andi	r2,r2,255
 32261cc:	1080201c 	xori	r2,r2,128
 32261d0:	10bfe004 	addi	r2,r2,-128
 32261d4:	1005d13a 	srai	r2,r2,4
 32261d8:	108003cc 	andi	r2,r2,15
 32261dc:	10800c04 	addi	r2,r2,48
 32261e0:	1007883a 	mov	r3,r2
 32261e4:	e0bffc17 	ldw	r2,-16(fp)
 32261e8:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 32261ec:	e0bffc17 	ldw	r2,-16(fp)
 32261f0:	10800003 	ldbu	r2,0(r2)
 32261f4:	10803fcc 	andi	r2,r2,255
 32261f8:	1080201c 	xori	r2,r2,128
 32261fc:	10bfe004 	addi	r2,r2,-128
 3226200:	10800e90 	cmplti	r2,r2,58
 3226204:	1000061e 	bne	r2,zero,3226220 <print_eth+0x88>
         (*out) += 7;
 3226208:	e0bffc17 	ldw	r2,-16(fp)
 322620c:	10800003 	ldbu	r2,0(r2)
 3226210:	108001c4 	addi	r2,r2,7
 3226214:	1007883a 	mov	r3,r2
 3226218:	e0bffc17 	ldw	r2,-16(fp)
 322621c:	10c00005 	stb	r3,0(r2)
      out++;
 3226220:	e0bffc17 	ldw	r2,-16(fp)
 3226224:	10800044 	addi	r2,r2,1
 3226228:	e0bffc15 	stw	r2,-16(fp)

      /* low nibble */
      *out = (char)((*addr & 0x0f) + 0x30);  /* low nibble to digit */
 322622c:	e0bffe17 	ldw	r2,-8(fp)
 3226230:	10800003 	ldbu	r2,0(r2)
 3226234:	108003cc 	andi	r2,r2,15
 3226238:	10800c04 	addi	r2,r2,48
 322623c:	1007883a 	mov	r3,r2
 3226240:	e0bffc17 	ldw	r2,-16(fp)
 3226244:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 3226248:	e0bffc17 	ldw	r2,-16(fp)
 322624c:	10800003 	ldbu	r2,0(r2)
 3226250:	10803fcc 	andi	r2,r2,255
 3226254:	1080201c 	xori	r2,r2,128
 3226258:	10bfe004 	addi	r2,r2,-128
 322625c:	10800e90 	cmplti	r2,r2,58
 3226260:	1000061e 	bne	r2,zero,322627c <print_eth+0xe4>
         (*out) += 7;   /* eg 0x3a -> 0x41 ('A') */
 3226264:	e0bffc17 	ldw	r2,-16(fp)
 3226268:	10800003 	ldbu	r2,0(r2)
 322626c:	108001c4 	addi	r2,r2,7
 3226270:	1007883a 	mov	r3,r2
 3226274:	e0bffc17 	ldw	r2,-16(fp)
 3226278:	10c00005 	stb	r3,0(r2)
      out++;
 322627c:	e0bffc17 	ldw	r2,-16(fp)
 3226280:	10800044 	addi	r2,r2,1
 3226284:	e0bffc15 	stw	r2,-16(fp)

      /* optional spacer character */
      if (spacer && i < 5)
 3226288:	e0bfff07 	ldb	r2,-4(fp)
 322628c:	1005003a 	cmpeq	r2,r2,zero
 3226290:	1000091e 	bne	r2,zero,32262b8 <print_eth+0x120>
 3226294:	e0bffd17 	ldw	r2,-12(fp)
 3226298:	10800148 	cmpgei	r2,r2,5
 322629c:	1000061e 	bne	r2,zero,32262b8 <print_eth+0x120>
         *out++ = spacer;
 32262a0:	e0fffc17 	ldw	r3,-16(fp)
 32262a4:	e0bfff03 	ldbu	r2,-4(fp)
 32262a8:	18800005 	stb	r2,0(r3)
 32262ac:	e0bffc17 	ldw	r2,-16(fp)
 32262b0:	10800044 	addi	r2,r2,1
 32262b4:	e0bffc15 	stw	r2,-16(fp)
      addr++;
 32262b8:	e0bffe17 	ldw	r2,-8(fp)
 32262bc:	10800044 	addi	r2,r2,1
 32262c0:	e0bffe15 	stw	r2,-8(fp)
{
   int   i;
   char *   out   =  eth_prt_buf;

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 32262c4:	e0bffd17 	ldw	r2,-12(fp)
 32262c8:	10800044 	addi	r2,r2,1
 32262cc:	e0bffd15 	stw	r2,-12(fp)
 32262d0:	e0bffd17 	ldw	r2,-12(fp)
 32262d4:	10800190 	cmplti	r2,r2,6
 32262d8:	103fb91e 	bne	r2,zero,32261c0 <print_eth+0x28>
      /* optional spacer character */
      if (spacer && i < 5)
         *out++ = spacer;
      addr++;
   }
   *out = 0;
 32262dc:	e0bffc17 	ldw	r2,-16(fp)
 32262e0:	10000005 	stb	zero,0(r2)
   return eth_prt_buf;
 32262e4:	0080c9b4 	movhi	r2,806
 32262e8:	10b36204 	addi	r2,r2,-12920
}
 32262ec:	e037883a 	mov	sp,fp
 32262f0:	df000017 	ldw	fp,0(sp)
 32262f4:	dec00104 	addi	sp,sp,4
 32262f8:	f800283a 	ret

032262fc <uslash>:
 * RETURNS:  pointer to formatted text
 */

char *   
uslash(char * path)
{
 32262fc:	defffd04 	addi	sp,sp,-12
 3226300:	df000215 	stw	fp,8(sp)
 3226304:	df000204 	addi	fp,sp,8
 3226308:	e13fff15 	stw	r4,-4(fp)
   char *   cp;

   for (cp = path; *cp; cp++)
 322630c:	e0bfff17 	ldw	r2,-4(fp)
 3226310:	e0bffe15 	stw	r2,-8(fp)
 3226314:	00000d06 	br	322634c <uslash+0x50>
      if (*cp == '\\')
 3226318:	e0bffe17 	ldw	r2,-8(fp)
 322631c:	10800003 	ldbu	r2,0(r2)
 3226320:	10803fcc 	andi	r2,r2,255
 3226324:	1080201c 	xori	r2,r2,128
 3226328:	10bfe004 	addi	r2,r2,-128
 322632c:	10801718 	cmpnei	r2,r2,92
 3226330:	1000031e 	bne	r2,zero,3226340 <uslash+0x44>
      *cp = '/';
 3226334:	e0fffe17 	ldw	r3,-8(fp)
 3226338:	00800bc4 	movi	r2,47
 322633c:	18800005 	stb	r2,0(r3)
char *   
uslash(char * path)
{
   char *   cp;

   for (cp = path; *cp; cp++)
 3226340:	e0bffe17 	ldw	r2,-8(fp)
 3226344:	10800044 	addi	r2,r2,1
 3226348:	e0bffe15 	stw	r2,-8(fp)
 322634c:	e0bffe17 	ldw	r2,-8(fp)
 3226350:	10800003 	ldbu	r2,0(r2)
 3226354:	10803fcc 	andi	r2,r2,255
 3226358:	1080201c 	xori	r2,r2,128
 322635c:	10bfe004 	addi	r2,r2,-128
 3226360:	1004c03a 	cmpne	r2,r2,zero
 3226364:	103fec1e 	bne	r2,zero,3226318 <uslash+0x1c>
      if (*cp == '\\')
      *cp = '/';
   return path;
 3226368:	e0bfff17 	ldw	r2,-4(fp)
}
 322636c:	e037883a 	mov	sp,fp
 3226370:	df000017 	ldw	fp,0(sp)
 3226374:	dec00104 	addi	sp,sp,4
 3226378:	f800283a 	ret

0322637c <ns_printf>:
 */
#ifndef ns_printf

int 
ns_printf(void * vio, char * format, ...)
{
 322637c:	defff204 	addi	sp,sp,-56
 3226380:	dfc00b15 	stw	ra,44(sp)
 3226384:	df000a15 	stw	fp,40(sp)
 3226388:	dc400915 	stw	r17,36(sp)
 322638c:	dc000815 	stw	r16,32(sp)
 3226390:	df000804 	addi	fp,sp,32
 3226394:	e13ffd15 	stw	r4,-12(fp)
 3226398:	e1800415 	stw	r6,16(fp)
 322639c:	e1c00515 	stw	r7,20(fp)
 32263a0:	e17ffe15 	stw	r5,-8(fp)
   char *   outbuf=NULL;
 32263a4:	e03ffb15 	stw	zero,-20(fp)
   int   ret_value   ;
   int   buf_size =  MAXIOSIZE   ;
 32263a8:	00802704 	movi	r2,156
 32263ac:	e0bff915 	stw	r2,-28(fp)
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 32263b0:	e0bffd17 	ldw	r2,-12(fp)
 32263b4:	e0bff815 	stw	r2,-32(fp)
   int * next_arg=(int *)  &format;
   next_arg +=  sizeof(char *)/sizeof(int) ;
#endif   /* NATIVE_PRINTF || PRINTF_STRING */

   /* a NULL pio means just dump the output to stdout */
   if (pio == NULL)
 32263b8:	e0bff817 	ldw	r2,-32(fp)
 32263bc:	1004c03a 	cmpne	r2,r2,zero
 32263c0:	1000091e 	bne	r2,zero,32263e8 <ns_printf+0x6c>
   {
#ifdef NATIVE_PRINTF
      /* use the target system's ANSI routines */
      va_start(argList,format);
 32263c4:	e0800404 	addi	r2,fp,16
 32263c8:	e0bffc15 	stw	r2,-16(fp)
      ret_value = vprintf(format,argList);
 32263cc:	e17ffc17 	ldw	r5,-16(fp)
 32263d0:	e13ffe17 	ldw	r4,-8(fp)
 32263d4:	324bf800 	call	324bf80 <vprintf>
 32263d8:	e0bffa15 	stw	r2,-24(fp)
      va_end(argList);
      return ret_value;
 32263dc:	e0bffa17 	ldw	r2,-24(fp)
 32263e0:	e0bfff15 	stw	r2,-4(fp)
 32263e4:	00003e06 	br	32264e0 <ns_printf+0x164>
      return strlen(format);
#endif   /* NATIVE_PRINTF */
   }

   /* Check if the output function is set */
   if (pio->out == NULL)
 32263e8:	e0bff817 	ldw	r2,-32(fp)
 32263ec:	10800117 	ldw	r2,4(r2)
 32263f0:	1004c03a 	cmpne	r2,r2,zero
 32263f4:	1000031e 	bne	r2,zero,3226404 <ns_printf+0x88>
   {
      /* Programming mistake. Output function not set. */
      return -1;
 32263f8:	00bfffc4 	movi	r2,-1
 32263fc:	e0bfff15 	stw	r2,-4(fp)
 3226400:	00003706 	br	32264e0 <ns_printf+0x164>

   /* Allocate memory for the output string 
    * If the format string is greater than MAXIOSIZE, then
    * we surely need to allocate a bigger block
    */
   ret_value = strlen(format); 
 3226404:	e13ffe17 	ldw	r4,-8(fp)
 3226408:	32084480 	call	3208448 <strlen>
 322640c:	e0bffa15 	stw	r2,-24(fp)
   if (ret_value >= MAXIOSIZE)
 3226410:	e0bffa17 	ldw	r2,-24(fp)
 3226414:	10802710 	cmplti	r2,r2,156
 3226418:	1000041e 	bne	r2,zero,322642c <ns_printf+0xb0>
   {
      buf_size += ret_value ;
 322641c:	e0bff917 	ldw	r2,-28(fp)
 3226420:	e0fffa17 	ldw	r3,-24(fp)
 3226424:	10c5883a 	add	r2,r2,r3
 3226428:	e0bff915 	stw	r2,-28(fp)
   }

   outbuf=(char *)npalloc(buf_size); 
 322642c:	e13ff917 	ldw	r4,-28(fp)
 3226430:	322b9340 	call	322b934 <npalloc>
 3226434:	e0bffb15 	stw	r2,-20(fp)

   if (outbuf == NULL)
 3226438:	e0bffb17 	ldw	r2,-20(fp)
 322643c:	1004c03a 	cmpne	r2,r2,zero
 3226440:	1000031e 	bne	r2,zero,3226450 <ns_printf+0xd4>
   {
      return -2;
 3226444:	00bfff84 	movi	r2,-2
 3226448:	e0bfff15 	stw	r2,-4(fp)
 322644c:	00002406 	br	32264e0 <ns_printf+0x164>

   /* Now populate the output string */

#ifdef NATIVE_PRINTF
   /* use the target system's ANSI routines */
   va_start(argList,format);
 3226450:	e0800404 	addi	r2,fp,16
 3226454:	e0bffc15 	stw	r2,-16(fp)
   ret_value = vsprintf(outbuf,format,argList);
 3226458:	e1bffc17 	ldw	r6,-16(fp)
 322645c:	e13ffb17 	ldw	r4,-20(fp)
 3226460:	e17ffe17 	ldw	r5,-8(fp)
 3226464:	324bff00 	call	324bff0 <vsprintf>
 3226468:	e0bffa15 	stw	r2,-24(fp)
#endif   /* PRINTF_STDARG */
#endif   /* NATIVE_PRINTF */

#ifdef NATIVE_PRINTF
   /* Check if we have overwritten the output buffer */
   if ((int)strlen(outbuf) > buf_size)
 322646c:	e13ffb17 	ldw	r4,-20(fp)
 3226470:	32084480 	call	3208448 <strlen>
 3226474:	1007883a 	mov	r3,r2
 3226478:	e0bff917 	ldw	r2,-28(fp)
 322647c:	10c0080e 	bge	r2,r3,32264a0 <ns_printf+0x124>
       */
      /* Yes , we have overwritten. Truncate the output string.
       * Some memory in the heap has been corrupted, but it is too
       * late to rectify.
       */
      panic("ns_printf:Buffer overflow");
 3226480:	0100c974 	movhi	r4,805
 3226484:	213c4904 	addi	r4,r4,-3804
 3226488:	32261540 	call	3226154 <panic>
      outbuf[buf_size-1]=0;   /* Null terminate the string */
 322648c:	e0fff917 	ldw	r3,-28(fp)
 3226490:	e0bffb17 	ldw	r2,-20(fp)
 3226494:	1885883a 	add	r2,r3,r2
 3226498:	10bfffc4 	addi	r2,r2,-1
 322649c:	10000005 	stb	zero,0(r2)
   }
#endif

   ret_value =(pio->out)(pio->id,outbuf,strlen(outbuf)) ;
 32264a0:	e0bff817 	ldw	r2,-32(fp)
 32264a4:	14400117 	ldw	r17,4(r2)
 32264a8:	e0bff817 	ldw	r2,-32(fp)
 32264ac:	14000217 	ldw	r16,8(r2)
 32264b0:	e13ffb17 	ldw	r4,-20(fp)
 32264b4:	32084480 	call	3208448 <strlen>
 32264b8:	100d883a 	mov	r6,r2
 32264bc:	8009883a 	mov	r4,r16
 32264c0:	e17ffb17 	ldw	r5,-20(fp)
 32264c4:	883ee83a 	callr	r17
 32264c8:	e0bffa15 	stw	r2,-24(fp)

   /* Free memory for the output string */
   npfree(outbuf); 
 32264cc:	e13ffb17 	ldw	r4,-20(fp)
 32264d0:	322ba280 	call	322ba28 <npfree>

   /* since ns_printf() can get called repeatedly down in the bowels 
    * of a single command interpretting function, spin tk_yield() so 
    * that some packets get a chance to get received 
    */
   tk_yield();
 32264d4:	3226ddc0 	call	3226ddc <tk_yield>

   return ret_value ;
 32264d8:	e0bffa17 	ldw	r2,-24(fp)
 32264dc:	e0bfff15 	stw	r2,-4(fp)
 32264e0:	e0bfff17 	ldw	r2,-4(fp)
}
 32264e4:	e037883a 	mov	sp,fp
 32264e8:	dfc00317 	ldw	ra,12(sp)
 32264ec:	df000217 	ldw	fp,8(sp)
 32264f0:	dc400117 	ldw	r17,4(sp)
 32264f4:	dc000017 	ldw	r16,0(sp)
 32264f8:	dec00604 	addi	sp,sp,24
 32264fc:	f800283a 	ret

03226500 <std_out>:
 *
 * RETURNS: Number of bytes send to standard output. 
 */

int std_out(long s, char * buf, int len)
{
 3226500:	defffb04 	addi	sp,sp,-20
 3226504:	dfc00415 	stw	ra,16(sp)
 3226508:	df000315 	stw	fp,12(sp)
 322650c:	df000304 	addi	fp,sp,12
 3226510:	e13ffd15 	stw	r4,-12(fp)
 3226514:	e17ffe15 	stw	r5,-8(fp)
 3226518:	e1bfff15 	stw	r6,-4(fp)
   /* puts(buf); - This does newline expansion return 
    * write(0,buf,len); - This doesn't printf(buf); - This has 
    * problems when printf format strings (eg %s) is part of data. 
    */
   printf("%s",buf);
 322651c:	0100c974 	movhi	r4,805
 3226520:	213c5004 	addi	r4,r4,-3776
 3226524:	e17ffe17 	ldw	r5,-8(fp)
 3226528:	3206de00 	call	3206de0 <printf>
   USE_ARG(s);
   return len;
 322652c:	e0bfff17 	ldw	r2,-4(fp)
}
 3226530:	e037883a 	mov	sp,fp
 3226534:	dfc00117 	ldw	ra,4(sp)
 3226538:	df000017 	ldw	fp,0(sp)
 322653c:	dec00204 	addi	sp,sp,8
 3226540:	f800283a 	ret

03226544 <con_page>:
 * RETURNS: 1 if we got a break, 0 to keep printing
 */

int
con_page(void * vio, int lines)
{
 3226544:	defff904 	addi	sp,sp,-28
 3226548:	dfc00615 	stw	ra,24(sp)
 322654c:	df000515 	stw	fp,20(sp)
 3226550:	df000504 	addi	fp,sp,20
 3226554:	e13ffd15 	stw	r4,-12(fp)
 3226558:	e17ffe15 	stw	r5,-8(fp)
   int   ch;
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 322655c:	e0bffd17 	ldw	r2,-12(fp)
 3226560:	e0bffb15 	stw	r2,-20(fp)

   if (lines % 20 == 0)   /* Time to get user input */
 3226564:	e13ffe17 	ldw	r4,-8(fp)
 3226568:	01400504 	movi	r5,20
 322656c:	32047600 	call	3204760 <__modsi3>
 3226570:	1004c03a 	cmpne	r2,r2,zero
 3226574:	1000281e 	bne	r2,zero,3226618 <con_page+0xd4>
   {
      if (pio && pio->getch)   /*if i/p func is supplied*/
 3226578:	e0bffb17 	ldw	r2,-20(fp)
 322657c:	1005003a 	cmpeq	r2,r2,zero
 3226580:	1000251e 	bne	r2,zero,3226618 <con_page+0xd4>
 3226584:	e0bffb17 	ldw	r2,-20(fp)
 3226588:	10800317 	ldw	r2,12(r2)
 322658c:	1005003a 	cmpeq	r2,r2,zero
 3226590:	1000211e 	bne	r2,zero,3226618 <con_page+0xd4>
      {
         ns_printf(pio,"....press any key for more (ESC to break)....");
 3226594:	e13ffb17 	ldw	r4,-20(fp)
 3226598:	0140c974 	movhi	r5,805
 322659c:	297c5104 	addi	r5,r5,-3772
 32265a0:	322637c0 	call	322637c <ns_printf>

         do 
         {
            ch = (pio->getch)(pio->id);
 32265a4:	e0bffb17 	ldw	r2,-20(fp)
 32265a8:	10c00317 	ldw	r3,12(r2)
 32265ac:	e0bffb17 	ldw	r2,-20(fp)
 32265b0:	11000217 	ldw	r4,8(r2)
 32265b4:	183ee83a 	callr	r3
 32265b8:	e0bffc15 	stw	r2,-16(fp)
            if (ch == 0)
 32265bc:	e0bffc17 	ldw	r2,-16(fp)
 32265c0:	1004c03a 	cmpne	r2,r2,zero
 32265c4:	1000011e 	bne	r2,zero,32265cc <con_page+0x88>
               tk_yield();    /* Give timeslice to other processes */
 32265c8:	3226ddc0 	call	3226ddc <tk_yield>
         } while (ch == 0) ;
 32265cc:	e0bffc17 	ldw	r2,-16(fp)
 32265d0:	1005003a 	cmpeq	r2,r2,zero
 32265d4:	103ff31e 	bne	r2,zero,32265a4 <con_page+0x60>

            /* if there is fatal error, we don't want to do any I/O */
         if (ch == -1)   /* fatal error */
 32265d8:	e0bffc17 	ldw	r2,-16(fp)
 32265dc:	10bfffd8 	cmpnei	r2,r2,-1
 32265e0:	1000031e 	bne	r2,zero,32265f0 <con_page+0xac>
            return 1 ;
 32265e4:	00800044 	movi	r2,1
 32265e8:	e0bfff15 	stw	r2,-4(fp)
 32265ec:	00000b06 	br	322661c <con_page+0xd8>

         ns_printf(pio,"\n");
 32265f0:	e13ffb17 	ldw	r4,-20(fp)
 32265f4:	0140c974 	movhi	r5,805
 32265f8:	297c3204 	addi	r5,r5,-3896
 32265fc:	322637c0 	call	322637c <ns_printf>
         if (ch == 27)   /* ESC key pressed */
 3226600:	e0bffc17 	ldw	r2,-16(fp)
 3226604:	108006d8 	cmpnei	r2,r2,27
 3226608:	1000031e 	bne	r2,zero,3226618 <con_page+0xd4>
            return 1 ;
 322660c:	00800044 	movi	r2,1
 3226610:	e0bfff15 	stw	r2,-4(fp)
 3226614:	00000106 	br	322661c <con_page+0xd8>
      }
   }
   return  0;
 3226618:	e03fff15 	stw	zero,-4(fp)
 322661c:	e0bfff17 	ldw	r2,-4(fp)
}
 3226620:	e037883a 	mov	sp,fp
 3226624:	dfc00117 	ldw	ra,4(sp)
 3226628:	df000017 	ldw	fp,0(sp)
 322662c:	dec00204 	addi	sp,sp,8
 3226630:	f800283a 	ret

03226634 <parse_args>:

char **parse_args(char *buf, int argc, int *pargc_index)
{
 3226634:	defff604 	addi	sp,sp,-40
 3226638:	dfc00915 	stw	ra,36(sp)
 322663c:	df000815 	stw	fp,32(sp)
 3226640:	df000804 	addi	fp,sp,32
 3226644:	e13ffc15 	stw	r4,-16(fp)
 3226648:	e17ffd15 	stw	r5,-12(fp)
 322664c:	e1bffe15 	stw	r6,-8(fp)
   /* This routine assumes buf is a null terminated string */
   int i;
   int len;
   char *bp = buf;
 3226650:	e0bffc17 	ldw	r2,-16(fp)
 3226654:	e0bff915 	stw	r2,-28(fp)
   char **pargv = NULL;
 3226658:	e03ff815 	stw	zero,-32(fp)
   *pargc_index = 0;
 322665c:	e0bffe17 	ldw	r2,-8(fp)
 3226660:	10000015 	stw	zero,0(r2)
   if (buf == NULL)
 3226664:	e0bffc17 	ldw	r2,-16(fp)
 3226668:	1004c03a 	cmpne	r2,r2,zero
 322666c:	1000021e 	bne	r2,zero,3226678 <parse_args+0x44>
   {
      return (NULL);
 3226670:	e03fff15 	stw	zero,-4(fp)
 3226674:	00007406 	br	3226848 <parse_args+0x214>
   }
   len = strlen(buf);
 3226678:	e13ffc17 	ldw	r4,-16(fp)
 322667c:	32084480 	call	3208448 <strlen>
 3226680:	e0bffa15 	stw	r2,-24(fp)
   if (len <= 0)
 3226684:	e0bffa17 	ldw	r2,-24(fp)
 3226688:	10800048 	cmpgei	r2,r2,1
 322668c:	1000021e 	bne	r2,zero,3226698 <parse_args+0x64>
   {
      return (NULL);
 3226690:	e03fff15 	stw	zero,-4(fp)
 3226694:	00006c06 	br	3226848 <parse_args+0x214>
   }
   pargv = (char **) npalloc(argc * sizeof(char *));
 3226698:	e0bffd17 	ldw	r2,-12(fp)
 322669c:	1085883a 	add	r2,r2,r2
 32266a0:	1085883a 	add	r2,r2,r2
 32266a4:	1009883a 	mov	r4,r2
 32266a8:	322b9340 	call	322b934 <npalloc>
 32266ac:	e0bff815 	stw	r2,-32(fp)
   if (pargv == NULL)
 32266b0:	e0bff817 	ldw	r2,-32(fp)
 32266b4:	1004c03a 	cmpne	r2,r2,zero
 32266b8:	1000051e 	bne	r2,zero,32266d0 <parse_args+0x9c>
   {
      return (NULL);
 32266bc:	e03fff15 	stw	zero,-4(fp)
 32266c0:	00006106 	br	3226848 <parse_args+0x214>
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
 32266c4:	e0bff917 	ldw	r2,-28(fp)
 32266c8:	10800044 	addi	r2,r2,1
 32266cc:	e0bff915 	stw	r2,-28(fp)
   if (pargv == NULL)
   {
      return (NULL);
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
 32266d0:	e0bff917 	ldw	r2,-28(fp)
 32266d4:	10800003 	ldbu	r2,0(r2)
 32266d8:	10803fcc 	andi	r2,r2,255
 32266dc:	1080201c 	xori	r2,r2,128
 32266e0:	10bfe004 	addi	r2,r2,-128
 32266e4:	10800820 	cmpeqi	r2,r2,32
 32266e8:	103ff61e 	bne	r2,zero,32266c4 <parse_args+0x90>
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 32266ec:	00003206 	br	32267b8 <parse_args+0x184>
   {
      pargv[(*pargc_index)] = bp;
 32266f0:	e0bffe17 	ldw	r2,-8(fp)
 32266f4:	10800017 	ldw	r2,0(r2)
 32266f8:	1085883a 	add	r2,r2,r2
 32266fc:	1085883a 	add	r2,r2,r2
 3226700:	1007883a 	mov	r3,r2
 3226704:	e0bff817 	ldw	r2,-32(fp)
 3226708:	1887883a 	add	r3,r3,r2
 322670c:	e0bff917 	ldw	r2,-28(fp)
 3226710:	18800015 	stw	r2,0(r3)
      (*pargc_index)++;
 3226714:	e0bffe17 	ldw	r2,-8(fp)
 3226718:	10800017 	ldw	r2,0(r2)
 322671c:	10c00044 	addi	r3,r2,1
 3226720:	e0bffe17 	ldw	r2,-8(fp)
 3226724:	10c00015 	stw	r3,0(r2)
      while (*bp != ' ' && *bp != '\0')
 3226728:	00000306 	br	3226738 <parse_args+0x104>
      {
         bp++; 
 322672c:	e0bff917 	ldw	r2,-28(fp)
 3226730:	10800044 	addi	r2,r2,1
 3226734:	e0bff915 	stw	r2,-28(fp)
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
   {
      pargv[(*pargc_index)] = bp;
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
 3226738:	e0bff917 	ldw	r2,-28(fp)
 322673c:	10800003 	ldbu	r2,0(r2)
 3226740:	10803fcc 	andi	r2,r2,255
 3226744:	1080201c 	xori	r2,r2,128
 3226748:	10bfe004 	addi	r2,r2,-128
 322674c:	10800820 	cmpeqi	r2,r2,32
 3226750:	10000b1e 	bne	r2,zero,3226780 <parse_args+0x14c>
 3226754:	e0bff917 	ldw	r2,-28(fp)
 3226758:	10800003 	ldbu	r2,0(r2)
 322675c:	10803fcc 	andi	r2,r2,255
 3226760:	1080201c 	xori	r2,r2,128
 3226764:	10bfe004 	addi	r2,r2,-128
 3226768:	1004c03a 	cmpne	r2,r2,zero
 322676c:	103fef1e 	bne	r2,zero,322672c <parse_args+0xf8>
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 3226770:	00000306 	br	3226780 <parse_args+0x14c>
      {
         bp++; 
 3226774:	e0bff917 	ldw	r2,-28(fp)
 3226778:	10800044 	addi	r2,r2,1
 322677c:	e0bff915 	stw	r2,-28(fp)
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 3226780:	e0bff917 	ldw	r2,-28(fp)
 3226784:	10800003 	ldbu	r2,0(r2)
 3226788:	10803fcc 	andi	r2,r2,255
 322678c:	1080201c 	xori	r2,r2,128
 3226790:	10bfe004 	addi	r2,r2,-128
 3226794:	10800818 	cmpnei	r2,r2,32
 3226798:	1000071e 	bne	r2,zero,32267b8 <parse_args+0x184>
 322679c:	e0bff917 	ldw	r2,-28(fp)
 32267a0:	10800003 	ldbu	r2,0(r2)
 32267a4:	10803fcc 	andi	r2,r2,255
 32267a8:	1080201c 	xori	r2,r2,128
 32267ac:	10bfe004 	addi	r2,r2,-128
 32267b0:	1004c03a 	cmpne	r2,r2,zero
 32267b4:	103fef1e 	bne	r2,zero,3226774 <parse_args+0x140>
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 32267b8:	e0bff917 	ldw	r2,-28(fp)
 32267bc:	10800003 	ldbu	r2,0(r2)
 32267c0:	10803fcc 	andi	r2,r2,255
 32267c4:	1080201c 	xori	r2,r2,128
 32267c8:	10bfe004 	addi	r2,r2,-128
 32267cc:	1005003a 	cmpeq	r2,r2,zero
 32267d0:	1000041e 	bne	r2,zero,32267e4 <parse_args+0x1b0>
 32267d4:	e0bffe17 	ldw	r2,-8(fp)
 32267d8:	10c00017 	ldw	r3,0(r2)
 32267dc:	e0bffd17 	ldw	r2,-12(fp)
 32267e0:	18bfc316 	blt	r3,r2,32266f0 <parse_args+0xbc>
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 32267e4:	e03ffb15 	stw	zero,-20(fp)
 32267e8:	00001206 	br	3226834 <parse_args+0x200>
   {
      if (buf[i] == ' ')
 32267ec:	e0bffb17 	ldw	r2,-20(fp)
 32267f0:	1007883a 	mov	r3,r2
 32267f4:	e0bffc17 	ldw	r2,-16(fp)
 32267f8:	1885883a 	add	r2,r3,r2
 32267fc:	10800003 	ldbu	r2,0(r2)
 3226800:	10803fcc 	andi	r2,r2,255
 3226804:	1080201c 	xori	r2,r2,128
 3226808:	10bfe004 	addi	r2,r2,-128
 322680c:	10800818 	cmpnei	r2,r2,32
 3226810:	1000051e 	bne	r2,zero,3226828 <parse_args+0x1f4>
         buf[i] = '\0';
 3226814:	e0bffb17 	ldw	r2,-20(fp)
 3226818:	1007883a 	mov	r3,r2
 322681c:	e0bffc17 	ldw	r2,-16(fp)
 3226820:	1885883a 	add	r2,r3,r2
 3226824:	10000005 	stb	zero,0(r2)
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 3226828:	e0bffb17 	ldw	r2,-20(fp)
 322682c:	10800044 	addi	r2,r2,1
 3226830:	e0bffb15 	stw	r2,-20(fp)
 3226834:	e0fffb17 	ldw	r3,-20(fp)
 3226838:	e0bffa17 	ldw	r2,-24(fp)
 322683c:	18bfeb16 	blt	r3,r2,32267ec <parse_args+0x1b8>
   {
      printf("pargv[%d] = %s\n", i, pargv[i]);
   }
#endif

   return (pargv);
 3226840:	e0bff817 	ldw	r2,-32(fp)
 3226844:	e0bfff15 	stw	r2,-4(fp)
 3226848:	e0bfff17 	ldw	r2,-4(fp)
}
 322684c:	e037883a 	mov	sp,fp
 3226850:	dfc00117 	ldw	ra,4(sp)
 3226854:	df000017 	ldw	fp,0(sp)
 3226858:	dec00204 	addi	sp,sp,8
 322685c:	f800283a 	ret

03226860 <netmain>:
 * RETURNS: 
 */

int
netmain(void)
{
 3226860:	defffb04 	addi	sp,sp,-20
 3226864:	dfc00415 	stw	ra,16(sp)
 3226868:	df000315 	stw	fp,12(sp)
 322686c:	df000304 	addi	fp,sp,12
   int   i;
   int   e;

   iniche_net_ready = FALSE;
 3226870:	d028c315 	stw	zero,-23796(gp)

   e = prep_modules();
 3226874:	323cbf00 	call	323cbf0 <prep_modules>
 3226878:	e0bffd15 	stw	r2,-12(fp)

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 322687c:	e03ffe15 	stw	zero,-8(fp)
 3226880:	00001c06 	br	32268f4 <netmain+0x94>
   {
      e = TK_NEWTASK(&nettasks[i]);
 3226884:	e0bffe17 	ldw	r2,-8(fp)
 3226888:	10800624 	muli	r2,r2,24
 322688c:	1007883a 	mov	r3,r2
 3226890:	0080c974 	movhi	r2,805
 3226894:	10894004 	addi	r2,r2,9472
 3226898:	1889883a 	add	r4,r3,r2
 322689c:	322b2d80 	call	322b2d8 <TK_NEWTASK>
 32268a0:	e0bffd15 	stw	r2,-12(fp)
      if (e != 0)
 32268a4:	e0bffd17 	ldw	r2,-12(fp)
 32268a8:	1005003a 	cmpeq	r2,r2,zero
 32268ac:	10000e1e 	bne	r2,zero,32268e8 <netmain+0x88>
      {
         dprintf("task create error\n");
 32268b0:	0100c974 	movhi	r4,805
 32268b4:	213c6304 	addi	r4,r4,-3700
 32268b8:	32071080 	call	3207108 <puts>
         panic((char *)&nettasks[i].name);
 32268bc:	e0bffe17 	ldw	r2,-8(fp)
 32268c0:	10800624 	muli	r2,r2,24
 32268c4:	10c00104 	addi	r3,r2,4
 32268c8:	0080c974 	movhi	r2,805
 32268cc:	10894004 	addi	r2,r2,9472
 32268d0:	1885883a 	add	r2,r3,r2
 32268d4:	1009883a 	mov	r4,r2
 32268d8:	32261540 	call	3226154 <panic>
         return -1;  /* compiler warnings */
 32268dc:	00bfffc4 	movi	r2,-1
 32268e0:	e0bfff15 	stw	r2,-4(fp)
 32268e4:	00001506 	br	322693c <netmain+0xdc>
   iniche_net_ready = FALSE;

   e = prep_modules();

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 32268e8:	e0bffe17 	ldw	r2,-8(fp)
 32268ec:	10800044 	addi	r2,r2,1
 32268f0:	e0bffe15 	stw	r2,-8(fp)
 32268f4:	d0e02e17 	ldw	r3,-32584(gp)
 32268f8:	e0bffe17 	ldw	r2,-8(fp)
 32268fc:	10ffe116 	blt	r2,r3,3226884 <netmain+0x24>
         panic((char *)&nettasks[i].name);
         return -1;  /* compiler warnings */
      }
   }
   
   e = create_apptasks();
 3226900:	323d0c80 	call	323d0c8 <create_apptasks>
 3226904:	e0bffd15 	stw	r2,-12(fp)
   if (e != 0) 
 3226908:	e0bffd17 	ldw	r2,-12(fp)
 322690c:	1005003a 	cmpeq	r2,r2,zero
 3226910:	1000091e 	bne	r2,zero,3226938 <netmain+0xd8>
   {
      dprintf("task create error\n");
 3226914:	0100c974 	movhi	r4,805
 3226918:	213c6304 	addi	r4,r4,-3700
 322691c:	32071080 	call	3207108 <puts>
      panic("netmain");
 3226920:	0100c974 	movhi	r4,805
 3226924:	213c6804 	addi	r4,r4,-3680
 3226928:	32261540 	call	3226154 <panic>
      return -1;  /* compiler warnings */
 322692c:	00bfffc4 	movi	r2,-1
 3226930:	e0bfff15 	stw	r2,-4(fp)
 3226934:	00000106 	br	322693c <netmain+0xdc>
#ifdef MAIN_TASK_IS_NET
   tk_netmain(TK_NETMAINPARM);
   panic("net task return");
   return -1;
#else
   return 0;
 3226938:	e03fff15 	stw	zero,-4(fp)
 322693c:	e0bfff17 	ldw	r2,-4(fp)
#endif
#endif   /* NO_INET_STACK */
}
 3226940:	e037883a 	mov	sp,fp
 3226944:	dfc00117 	ldw	ra,4(sp)
 3226948:	df000017 	ldw	fp,0(sp)
 322694c:	dec00204 	addi	sp,sp,8
 3226950:	f800283a 	ret

03226954 <tk_netmain>:
 * RETURNS: n/a
 */

#ifndef NO_INET_STACK
TK_ENTRY(tk_netmain)
{
 3226954:	defffc04 	addi	sp,sp,-16
 3226958:	dfc00315 	stw	ra,12(sp)
 322695c:	df000215 	stw	fp,8(sp)
 3226960:	df000204 	addi	fp,sp,8
 3226964:	e13fff15 	stw	r4,-4(fp)
   netmain_init(); /* initialize all modules */
 3226968:	323c8740 	call	323c874 <netmain_init>

   iniche_net_ready = TRUE;    /* let the other threads spin */
 322696c:	00800044 	movi	r2,1
 3226970:	d0a8c315 	stw	r2,-23796(gp)
 3226974:	00000006 	br	3226978 <tk_netmain+0x24>

   for (;;)
   {
      TK_NETRX_BLOCK();
 3226978:	0080c974 	movhi	r2,805
 322697c:	10934404 	addi	r2,r2,19728
 3226980:	11000017 	ldw	r4,0(r2)
 3226984:	0140fa04 	movi	r5,1000
 3226988:	e1bffe04 	addi	r6,fp,-8
 322698c:	321b0e80 	call	321b0e8 <OSSemPend>
 3226990:	e0bffe03 	ldbu	r2,-8(fp)
 3226994:	10803fcc 	andi	r2,r2,255
 3226998:	1005003a 	cmpeq	r2,r2,zero
 322699c:	1000051e 	bne	r2,zero,32269b4 <tk_netmain+0x60>
 32269a0:	e0bffe03 	ldbu	r2,-8(fp)
 32269a4:	10803fcc 	andi	r2,r2,255
 32269a8:	108002a0 	cmpeqi	r2,r2,10
 32269ac:	1000011e 	bne	r2,zero,32269b4 <tk_netmain+0x60>
 32269b0:	322aef00 	call	322aef0 <dtrap>
      netmain_wakes++;  /* count wakeups */
 32269b4:	d0a8c117 	ldw	r2,-23804(gp)
 32269b8:	10800044 	addi	r2,r2,1
 32269bc:	d0a8c115 	stw	r2,-23804(gp)

      /* see if there's newly received network packets */
      if (rcvdq.q_len)
 32269c0:	0080c9b4 	movhi	r2,806
 32269c4:	10b28004 	addi	r2,r2,-13824
 32269c8:	10800217 	ldw	r2,8(r2)
 32269cc:	1005003a 	cmpeq	r2,r2,zero
 32269d0:	103fe91e 	bne	r2,zero,3226978 <tk_netmain+0x24>
         pktdemux();
 32269d4:	32236540 	call	3223654 <pktdemux>
       * vital to a clean shutdown 
       */
#ifdef USE_LCD
      update_display();
#endif
   }
 32269d8:	003fe706 	br	3226978 <tk_netmain+0x24>

032269dc <tk_nettick>:
extern   int dhc_second(void);
#endif

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
 32269dc:	defffd04 	addi	sp,sp,-12
 32269e0:	dfc00215 	stw	ra,8(sp)
 32269e4:	df000115 	stw	fp,4(sp)
 32269e8:	df000104 	addi	fp,sp,4
 32269ec:	e13fff15 	stw	r4,-4(fp)
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 32269f0:	00000306 	br	3226a00 <tk_nettick+0x24>
       * request and then we receive a NAK. At this point the DHCP
       * client is reset to INIT state and dhc_second() needs to be
       * run to restart it.
       */
#ifdef DHCP_CLIENT
      dhc_second();
 32269f4:	32295480 	call	3229548 <dhc_second>
#endif
      TK_SLEEP(1);
 32269f8:	01000084 	movi	r4,2
 32269fc:	321d27c0 	call	321d27c <OSTimeDly>

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 3226a00:	d0a8c317 	ldw	r2,-23796(gp)
 3226a04:	1005003a 	cmpeq	r2,r2,zero
 3226a08:	103ffa1e 	bne	r2,zero,32269f4 <tk_nettick+0x18>
      TK_SLEEP(1);
   }

   for (;;)
   {
      TK_SLEEP(SYS_SHORT_SLEEP);
 3226a0c:	01000084 	movi	r4,2
 3226a10:	321d27c0 	call	321d27c <OSTimeDly>
      nettick_wakes++;  /* count wakeups */
 3226a14:	d0a8c217 	ldw	r2,-23800(gp)
 3226a18:	10800044 	addi	r2,r2,1
 3226a1c:	d0a8c215 	stw	r2,-23800(gp)
      inet_timer();  /* let various timeouts occur */
 3226a20:	323cc480 	call	323cc48 <inet_timer>
      /* do not kill timers on net_system_exit. They may be
       * vital to a clean shutdown 
       */
   }
 3226a24:	003ff906 	br	3226a0c <tk_nettick+0x30>

03226a28 <TK_OSTimeDly>:
u_char   TK_OSTaskQuery(void);



void TK_OSTimeDly(void)
{
 3226a28:	defffe04 	addi	sp,sp,-8
 3226a2c:	dfc00115 	stw	ra,4(sp)
 3226a30:	df000015 	stw	fp,0(sp)
 3226a34:	d839883a 	mov	fp,sp
   OSTimeDly(2);
 3226a38:	01000084 	movi	r4,2
 3226a3c:	321d27c0 	call	321d27c <OSTimeDly>
}
 3226a40:	e037883a 	mov	sp,fp
 3226a44:	dfc00117 	ldw	ra,4(sp)
 3226a48:	df000017 	ldw	fp,0(sp)
 3226a4c:	dec00204 	addi	sp,sp,8
 3226a50:	f800283a 	ret

03226a54 <TK_OSTaskResume>:



void TK_OSTaskResume(u_char * Id)
{
 3226a54:	defffc04 	addi	sp,sp,-16
 3226a58:	dfc00315 	stw	ra,12(sp)
 3226a5c:	df000215 	stw	fp,8(sp)
 3226a60:	df000204 	addi	fp,sp,8
 3226a64:	e13fff15 	stw	r4,-4(fp)
INT8U err;

   err = OSTaskResume(*Id);
 3226a68:	e0bfff17 	ldw	r2,-4(fp)
 3226a6c:	10800003 	ldbu	r2,0(r2)
 3226a70:	11003fcc 	andi	r4,r2,255
 3226a74:	321ca7c0 	call	321ca7c <OSTaskResume>
 3226a78:	e0bffe05 	stb	r2,-8(fp)
   
#ifdef NPDEBUG
   if ((err != OS_NO_ERR) && (err != OS_TASK_NOT_SUSPENDED))
 3226a7c:	e0bffe03 	ldbu	r2,-8(fp)
 3226a80:	1005003a 	cmpeq	r2,r2,zero
 3226a84:	10000a1e 	bne	r2,zero,3226ab0 <TK_OSTaskResume+0x5c>
 3226a88:	e0bffe03 	ldbu	r2,-8(fp)
 3226a8c:	10801120 	cmpeqi	r2,r2,68
 3226a90:	1000071e 	bne	r2,zero,3226ab0 <TK_OSTaskResume+0x5c>
   {
      dprintf("ChronOS API call failure, to Resume Suspended Task!\n");
 3226a94:	0100c974 	movhi	r4,805
 3226a98:	213c6a04 	addi	r4,r4,-3672
 3226a9c:	32071080 	call	3207108 <puts>
      dtrap();
 3226aa0:	322aef00 	call	322aef0 <dtrap>
      panic("TK_OSTaskResume");      
 3226aa4:	0100c974 	movhi	r4,805
 3226aa8:	213c7704 	addi	r4,r4,-3620
 3226aac:	32261540 	call	3226154 <panic>
   }
#endif
}
 3226ab0:	e037883a 	mov	sp,fp
 3226ab4:	dfc00117 	ldw	ra,4(sp)
 3226ab8:	df000017 	ldw	fp,0(sp)
 3226abc:	dec00204 	addi	sp,sp,8
 3226ac0:	f800283a 	ret

03226ac4 <tcp_sleep>:
 *
 * RETURN: none
 */
void
tcp_sleep(void * event)
{
 3226ac4:	defffb04 	addi	sp,sp,-20
 3226ac8:	dfc00415 	stw	ra,16(sp)
 3226acc:	df000315 	stw	fp,12(sp)
 3226ad0:	df000304 	addi	fp,sp,12
 3226ad4:	e13fff15 	stw	r4,-4(fp)
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 3226ad8:	e03ffd15 	stw	zero,-12(fp)
 3226adc:	00005006 	br	3226c20 <tcp_sleep+0x15c>
   {
      if (global_TCPwakeup_set[i].soc_event == NULL)
 3226ae0:	e0bffd17 	ldw	r2,-12(fp)
 3226ae4:	00c0c9b4 	movhi	r3,806
 3226ae8:	18f43004 	addi	r3,r3,-12096
 3226aec:	10800324 	muli	r2,r2,12
 3226af0:	10c5883a 	add	r2,r2,r3
 3226af4:	10800104 	addi	r2,r2,4
 3226af8:	10800017 	ldw	r2,0(r2)
 3226afc:	1004c03a 	cmpne	r2,r2,zero
 3226b00:	1000441e 	bne	r2,zero,3226c14 <tcp_sleep+0x150>
      {
         global_TCPwakeup_set[i].soc_event = event;
 3226b04:	e0bffd17 	ldw	r2,-12(fp)
 3226b08:	00c0c9b4 	movhi	r3,806
 3226b0c:	18f43004 	addi	r3,r3,-12096
 3226b10:	10800324 	muli	r2,r2,12
 3226b14:	10c5883a 	add	r2,r2,r3
 3226b18:	10c00104 	addi	r3,r2,4
 3226b1c:	e0bfff17 	ldw	r2,-4(fp)
 3226b20:	18800015 	stw	r2,0(r3)
         global_TCPwakeup_set[i].ctick = cticks;
 3226b24:	e13ffd17 	ldw	r4,-12(fp)
 3226b28:	0080c974 	movhi	r2,805
 3226b2c:	10934104 	addi	r2,r2,19716
 3226b30:	11400017 	ldw	r5,0(r2)
 3226b34:	00c0c9b4 	movhi	r3,806
 3226b38:	18f43004 	addi	r3,r3,-12096
 3226b3c:	20800324 	muli	r2,r4,12
 3226b40:	10c5883a 	add	r2,r2,r3
 3226b44:	11400015 	stw	r5,0(r2)
         if (i > global_TCPwakeup_setIndx)
 3226b48:	0080c974 	movhi	r2,805
 3226b4c:	10934004 	addi	r2,r2,19712
 3226b50:	10c00017 	ldw	r3,0(r2)
 3226b54:	e0bffd17 	ldw	r2,-12(fp)
 3226b58:	1880040e 	bge	r3,r2,3226b6c <tcp_sleep+0xa8>
            global_TCPwakeup_setIndx = i;
 3226b5c:	00c0c974 	movhi	r3,805
 3226b60:	18d34004 	addi	r3,r3,19712
 3226b64:	e0bffd17 	ldw	r2,-12(fp)
 3226b68:	18800015 	stw	r2,0(r3)

         tcp_sleep_count++;
 3226b6c:	0080c974 	movhi	r2,805
 3226b70:	10933c04 	addi	r2,r2,19696
 3226b74:	10800017 	ldw	r2,0(r2)
 3226b78:	10c00044 	addi	r3,r2,1
 3226b7c:	0080c974 	movhi	r2,805
 3226b80:	10933c04 	addi	r2,r2,19696
 3226b84:	10c00015 	stw	r3,0(r2)

         /* Give up the lock before going to sleep. This can
          * potentially cause a context switch to the task
          * signaling the event.
          */
         UNLOCK_NET_RESOURCE(NET_RESID);
 3226b88:	0009883a 	mov	r4,zero
 3226b8c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

         /* don't wait forever in case we miss the event */
         OSSemPend(global_TCPwakeup_set[i].semaphore, TPS, &err);
 3226b90:	e0bffd17 	ldw	r2,-12(fp)
 3226b94:	00c0c9b4 	movhi	r3,806
 3226b98:	18f43004 	addi	r3,r3,-12096
 3226b9c:	10800324 	muli	r2,r2,12
 3226ba0:	10c5883a 	add	r2,r2,r3
 3226ba4:	10800204 	addi	r2,r2,8
 3226ba8:	11000017 	ldw	r4,0(r2)
 3226bac:	e1bffe04 	addi	r6,fp,-8
 3226bb0:	0140fa04 	movi	r5,1000
 3226bb4:	321b0e80 	call	321b0e8 <OSSemPend>
         if (err == 10)
 3226bb8:	e0bffe03 	ldbu	r2,-8(fp)
 3226bbc:	10803fcc 	andi	r2,r2,255
 3226bc0:	10800298 	cmpnei	r2,r2,10
 3226bc4:	1000101e 	bne	r2,zero,3226c08 <tcp_sleep+0x144>
         {
            ++tcp_sleep_timeout;
 3226bc8:	d0a8c517 	ldw	r2,-23788(gp)
 3226bcc:	10800044 	addi	r2,r2,1
 3226bd0:	d0a8c515 	stw	r2,-23788(gp)

            /* clear the entry */
            global_TCPwakeup_set[i].ctick = 0;
 3226bd4:	e0bffd17 	ldw	r2,-12(fp)
 3226bd8:	00c0c9b4 	movhi	r3,806
 3226bdc:	18f43004 	addi	r3,r3,-12096
 3226be0:	10800324 	muli	r2,r2,12
 3226be4:	10c5883a 	add	r2,r2,r3
 3226be8:	10000015 	stw	zero,0(r2)
            global_TCPwakeup_set[i].soc_event = NULL;
 3226bec:	e0bffd17 	ldw	r2,-12(fp)
 3226bf0:	00c0c9b4 	movhi	r3,806
 3226bf4:	18f43004 	addi	r3,r3,-12096
 3226bf8:	10800324 	muli	r2,r2,12
 3226bfc:	10c5883a 	add	r2,r2,r3
 3226c00:	10800104 	addi	r2,r2,4
 3226c04:	10000015 	stw	zero,0(r2)
         }

         /* Regain the lock */
         LOCK_NET_RESOURCE(NET_RESID);
 3226c08:	0009883a 	mov	r4,zero
 3226c0c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         return;
 3226c10:	00000f06 	br	3226c50 <tcp_sleep+0x18c>
tcp_sleep(void * event)
{
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 3226c14:	e0bffd17 	ldw	r2,-12(fp)
 3226c18:	10800044 	addi	r2,r2,1
 3226c1c:	e0bffd15 	stw	r2,-12(fp)
 3226c20:	e0bffd17 	ldw	r2,-12(fp)
 3226c24:	10800510 	cmplti	r2,r2,20
 3226c28:	103fad1e 	bne	r2,zero,3226ae0 <tcp_sleep+0x1c>

   /* The table is full. Try calling TK_YIELD() and hope for the best.
    * The user should increase the size of the table.
    * We'll record the max index for debugging purposes.
    */
   global_TCPwakeup_setIndx = i;
 3226c2c:	00c0c974 	movhi	r3,805
 3226c30:	18d34004 	addi	r3,r3,19712
 3226c34:	e0bffd17 	ldw	r2,-12(fp)
 3226c38:	18800015 	stw	r2,0(r3)

   UNLOCK_NET_RESOURCE(NET_RESID);
 3226c3c:	0009883a 	mov	r4,zero
 3226c40:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   TK_YIELD();
 3226c44:	3226ddc0 	call	3226ddc <tk_yield>
   LOCK_NET_RESOURCE(NET_RESID);
 3226c48:	0009883a 	mov	r4,zero
 3226c4c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
}
 3226c50:	e037883a 	mov	sp,fp
 3226c54:	dfc00117 	ldw	ra,4(sp)
 3226c58:	df000017 	ldw	fp,0(sp)
 3226c5c:	dec00204 	addi	sp,sp,8
 3226c60:	f800283a 	ret

03226c64 <tcp_wakeup>:
 *
 * RETURN: none
 */
void
tcp_wakeup(void *event)
{
 3226c64:	defffc04 	addi	sp,sp,-16
 3226c68:	dfc00315 	stw	ra,12(sp)
 3226c6c:	df000215 	stw	fp,8(sp)
 3226c70:	df000204 	addi	fp,sp,8
 3226c74:	e13fff15 	stw	r4,-4(fp)
   int i;

   OSSchedLock();
 3226c78:	32160400 	call	3216040 <OSSchedLock>

   for (i = 0; i < GLOBWAKE_SZ; i++)
 3226c7c:	e03ffe15 	stw	zero,-8(fp)
 3226c80:	00003006 	br	3226d44 <tcp_wakeup+0xe0>
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 3226c84:	e0bffe17 	ldw	r2,-8(fp)
 3226c88:	00c0c9b4 	movhi	r3,806
 3226c8c:	18f43004 	addi	r3,r3,-12096
 3226c90:	10800324 	muli	r2,r2,12
 3226c94:	10c5883a 	add	r2,r2,r3
 3226c98:	10800017 	ldw	r2,0(r2)
 3226c9c:	1005003a 	cmpeq	r2,r2,zero
 3226ca0:	1000251e 	bne	r2,zero,3226d38 <tcp_wakeup+0xd4>
 3226ca4:	e0bffe17 	ldw	r2,-8(fp)
 3226ca8:	00c0c9b4 	movhi	r3,806
 3226cac:	18f43004 	addi	r3,r3,-12096
 3226cb0:	10800324 	muli	r2,r2,12
 3226cb4:	10c5883a 	add	r2,r2,r3
 3226cb8:	10800104 	addi	r2,r2,4
 3226cbc:	10c00017 	ldw	r3,0(r2)
 3226cc0:	e0bfff17 	ldw	r2,-4(fp)
 3226cc4:	18801c1e 	bne	r3,r2,3226d38 <tcp_wakeup+0xd4>
          (global_TCPwakeup_set[i].soc_event == event))
      {
         /* signal the event */
         OSSemPost(global_TCPwakeup_set[i].semaphore);
 3226cc8:	e0bffe17 	ldw	r2,-8(fp)
 3226ccc:	00c0c9b4 	movhi	r3,806
 3226cd0:	18f43004 	addi	r3,r3,-12096
 3226cd4:	10800324 	muli	r2,r2,12
 3226cd8:	10c5883a 	add	r2,r2,r3
 3226cdc:	10800204 	addi	r2,r2,8
 3226ce0:	11000017 	ldw	r4,0(r2)
 3226ce4:	321b4e00 	call	321b4e0 <OSSemPost>

         /* clear the entry */
         global_TCPwakeup_set[i].ctick = 0;
 3226ce8:	e0bffe17 	ldw	r2,-8(fp)
 3226cec:	00c0c9b4 	movhi	r3,806
 3226cf0:	18f43004 	addi	r3,r3,-12096
 3226cf4:	10800324 	muli	r2,r2,12
 3226cf8:	10c5883a 	add	r2,r2,r3
 3226cfc:	10000015 	stw	zero,0(r2)
         global_TCPwakeup_set[i].soc_event = NULL;
 3226d00:	e0bffe17 	ldw	r2,-8(fp)
 3226d04:	00c0c9b4 	movhi	r3,806
 3226d08:	18f43004 	addi	r3,r3,-12096
 3226d0c:	10800324 	muli	r2,r2,12
 3226d10:	10c5883a 	add	r2,r2,r3
 3226d14:	10800104 	addi	r2,r2,4
 3226d18:	10000015 	stw	zero,0(r2)

         tcp_wakeup_count++;
 3226d1c:	0080c974 	movhi	r2,805
 3226d20:	10933d04 	addi	r2,r2,19700
 3226d24:	10800017 	ldw	r2,0(r2)
 3226d28:	10c00044 	addi	r3,r2,1
 3226d2c:	0080c974 	movhi	r2,805
 3226d30:	10933d04 	addi	r2,r2,19700
 3226d34:	10c00015 	stw	r3,0(r2)
{
   int i;

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
 3226d38:	e0bffe17 	ldw	r2,-8(fp)
 3226d3c:	10800044 	addi	r2,r2,1
 3226d40:	e0bffe15 	stw	r2,-8(fp)
 3226d44:	e0bffe17 	ldw	r2,-8(fp)
 3226d48:	10800510 	cmplti	r2,r2,20
 3226d4c:	103fcd1e 	bne	r2,zero,3226c84 <tcp_wakeup+0x20>

         tcp_wakeup_count++;
      }
   }

   OSSchedUnlock();
 3226d50:	32160cc0 	call	32160cc <OSSchedUnlock>
}
 3226d54:	e037883a 	mov	sp,fp
 3226d58:	dfc00117 	ldw	ra,4(sp)
 3226d5c:	df000017 	ldw	fp,0(sp)
 3226d60:	dec00204 	addi	sp,sp,8
 3226d64:	f800283a 	ret

03226d68 <TK_OSTaskQuery>:



u_char TK_OSTaskQuery(void)
{
 3226d68:	deffe104 	addi	sp,sp,-124
 3226d6c:	dfc01e15 	stw	ra,120(sp)
 3226d70:	df001d15 	stw	fp,116(sp)
 3226d74:	df001d04 	addi	fp,sp,116
   OS_TCB task_data;
   INT8U err, task_prio;

   err = OSTaskQuery(OS_PRIO_SELF, &task_data);
 3226d78:	e17fe404 	addi	r5,fp,-112
 3226d7c:	01003fc4 	movi	r4,255
 3226d80:	321d0bc0 	call	321d0bc <OSTaskQuery>
 3226d84:	e0bfe345 	stb	r2,-115(fp)

   if (err == OS_NO_ERR)
 3226d88:	e0bfe343 	ldbu	r2,-115(fp)
 3226d8c:	1004c03a 	cmpne	r2,r2,zero
 3226d90:	1000051e 	bne	r2,zero,3226da8 <TK_OSTaskQuery+0x40>
   {
      task_prio = task_data.OSTCBPrio;
 3226d94:	e0bff083 	ldbu	r2,-62(fp)
 3226d98:	e0bfe305 	stb	r2,-116(fp)
      dprintf("ChronOS API call failure, unable to identify task!");
      panic("TK_OSTaskQuery");
      return 0;
   }
   
   return task_prio;
 3226d9c:	e0bfe303 	ldbu	r2,-116(fp)
 3226da0:	e0bfff15 	stw	r2,-4(fp)
 3226da4:	00000706 	br	3226dc4 <TK_OSTaskQuery+0x5c>
   {
      task_prio = task_data.OSTCBPrio;
   }
   else
   {
      dprintf("ChronOS API call failure, unable to identify task!");
 3226da8:	0100c974 	movhi	r4,805
 3226dac:	213c7b04 	addi	r4,r4,-3604
 3226db0:	3206de00 	call	3206de0 <printf>
      panic("TK_OSTaskQuery");
 3226db4:	0100c974 	movhi	r4,805
 3226db8:	213c8804 	addi	r4,r4,-3552
 3226dbc:	32261540 	call	3226154 <panic>
      return 0;
 3226dc0:	e03fff15 	stw	zero,-4(fp)
 3226dc4:	e0bfff17 	ldw	r2,-4(fp)
   }
   
   return task_prio;
}
 3226dc8:	e037883a 	mov	sp,fp
 3226dcc:	dfc00117 	ldw	ra,4(sp)
 3226dd0:	df000017 	ldw	fp,0(sp)
 3226dd4:	dec00204 	addi	sp,sp,8
 3226dd8:	f800283a 	ret

03226ddc <tk_yield>:



void
tk_yield(void)
{
 3226ddc:	defffe04 	addi	sp,sp,-8
 3226de0:	dfc00115 	stw	ra,4(sp)
 3226de4:	df000015 	stw	fp,0(sp)
 3226de8:	d839883a 	mov	fp,sp
   /* To ensure cycles to the lower priority tasks we should really
    * delay by two ticks, but that really hurts performance on some
    * long-tick targets. One tick works better overall....
    */
   OSTimeDly(1);
 3226dec:	01000044 	movi	r4,1
 3226df0:	321d27c0 	call	321d27c <OSTimeDly>
}
 3226df4:	e037883a 	mov	sp,fp
 3226df8:	dfc00117 	ldw	ra,4(sp)
 3226dfc:	df000017 	ldw	fp,0(sp)
 3226e00:	dec00204 	addi	sp,sp,8
 3226e04:	f800283a 	ret

03226e08 <tk_stats>:
extern struct inet_taskinfo * nettask;
extern int num_net_tasks;

int
tk_stats(void * pio)
{
 3226e08:	deffef04 	addi	sp,sp,-68
 3226e0c:	dfc01015 	stw	ra,64(sp)
 3226e10:	df000f15 	stw	fp,60(sp)
 3226e14:	df000f04 	addi	fp,sp,60
 3226e18:	e13fff15 	stw	r4,-4(fp)
   int      stackuse;
   char     name[OS_TASK_NAME_SIZE+1];
   INT8U    err;
   

   ns_printf(pio, "ChronOS RTOS stats:\n");
 3226e1c:	e13fff17 	ldw	r4,-4(fp)
 3226e20:	0140c974 	movhi	r5,805
 3226e24:	297c8c04 	addi	r5,r5,-3536
 3226e28:	322637c0 	call	322637c <ns_printf>

#ifdef NO_INICHE_EXTENSIONS
   ns_printf(pio, "Context switches; Delay:  %lu\n",
 3226e2c:	0080c974 	movhi	r2,805
 3226e30:	10930b04 	addi	r2,r2,19500
 3226e34:	11800017 	ldw	r6,0(r2)
 3226e38:	e13fff17 	ldw	r4,-4(fp)
 3226e3c:	0140c974 	movhi	r5,805
 3226e40:	297c9204 	addi	r5,r5,-3512
 3226e44:	322637c0 	call	322637c <ns_printf>
#else
   ns_printf(pio, "Context switches; Delay:  %lu, Interrupt: %lu\n",
      OSCtxSwCtr, OSCtxIntCtr);
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");
 3226e48:	e13fff17 	ldw	r4,-4(fp)
 3226e4c:	0140c974 	movhi	r5,805
 3226e50:	297c9a04 	addi	r5,r5,-3480
 3226e54:	322637c0 	call	322637c <ns_printf>

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 3226e58:	e03ff515 	stw	zero,-44(fp)
 3226e5c:	00005106 	br	3226fa4 <tk_stats+0x19c>
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
 3226e60:	e0bff517 	ldw	r2,-44(fp)
 3226e64:	00c0c9b4 	movhi	r3,806
 3226e68:	18f26b04 	addi	r3,r3,-13908
 3226e6c:	1085883a 	add	r2,r2,r2
 3226e70:	1085883a 	add	r2,r2,r2
 3226e74:	10c5883a 	add	r2,r2,r3
 3226e78:	10800017 	ldw	r2,0(r2)
 3226e7c:	e0bff415 	stw	r2,-48(fp)
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
 3226e80:	e0bff417 	ldw	r2,-48(fp)
 3226e84:	1005003a 	cmpeq	r2,r2,zero
 3226e88:	1000431e 	bne	r2,zero,3226f98 <tk_stats+0x190>
 3226e8c:	e0bff417 	ldw	r2,-48(fp)
 3226e90:	10800060 	cmpeqi	r2,r2,1
 3226e94:	1000401e 	bne	r2,zero,3226f98 <tk_stats+0x190>
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);
 3226e98:	e0bff417 	ldw	r2,-48(fp)
 3226e9c:	10800c83 	ldbu	r2,50(r2)
 3226ea0:	11003fcc 	andi	r4,r2,255
 3226ea4:	e17ff604 	addi	r5,fp,-40
 3226ea8:	e1bffe44 	addi	r6,fp,-7
 3226eac:	321c7000 	call	321c700 <OSTaskNameGet>

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 3226eb0:	e0bff417 	ldw	r2,-48(fp)
 3226eb4:	10800c83 	ldbu	r2,50(r2)
 3226eb8:	11c03fcc 	andi	r7,r2,255
 3226ebc:	e0bff417 	ldw	r2,-48(fp)
 3226ec0:	10800c03 	ldbu	r2,48(r2)
 3226ec4:	10803fcc 	andi	r2,r2,255
 3226ec8:	e1bff604 	addi	r6,fp,-40
 3226ecc:	d8800015 	stw	r2,0(sp)
 3226ed0:	e13fff17 	ldw	r4,-4(fp)
 3226ed4:	0140c974 	movhi	r5,805
 3226ed8:	297caa04 	addi	r5,r5,-3416
 3226edc:	322637c0 	call	322637c <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 3226ee0:	e0bff417 	ldw	r2,-48(fp)
 3226ee4:	10800217 	ldw	r2,8(r2)
 3226ee8:	1005003a 	cmpeq	r2,r2,zero
 3226eec:	1000261e 	bne	r2,zero,3226f88 <tk_stats+0x180>
 3226ef0:	e0bff417 	ldw	r2,-48(fp)
 3226ef4:	10800317 	ldw	r2,12(r2)
 3226ef8:	1005003a 	cmpeq	r2,r2,zero
 3226efc:	1000221e 	bne	r2,zero,3226f88 <tk_stats+0x180>
      {
         sp = tcb->OSTCBStkBottom + 1;
 3226f00:	e0bff417 	ldw	r2,-48(fp)
 3226f04:	10800217 	ldw	r2,8(r2)
 3226f08:	10800104 	addi	r2,r2,4
 3226f0c:	e0bff315 	stw	r2,-52(fp)
         while(*sp == 0)
 3226f10:	00000306 	br	3226f20 <tk_stats+0x118>
            sp++;
 3226f14:	e0bff317 	ldw	r2,-52(fp)
 3226f18:	10800104 	addi	r2,r2,4
 3226f1c:	e0bff315 	stw	r2,-52(fp)
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
      {
         sp = tcb->OSTCBStkBottom + 1;
         while(*sp == 0)
 3226f20:	e0bff317 	ldw	r2,-52(fp)
 3226f24:	10800017 	ldw	r2,0(r2)
 3226f28:	1005003a 	cmpeq	r2,r2,zero
 3226f2c:	103ff91e 	bne	r2,zero,3226f14 <tk_stats+0x10c>
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
 3226f30:	e0bff417 	ldw	r2,-48(fp)
 3226f34:	11000317 	ldw	r4,12(r2)
 3226f38:	e0fff317 	ldw	r3,-52(fp)
 3226f3c:	e0bff417 	ldw	r2,-48(fp)
 3226f40:	10800217 	ldw	r2,8(r2)
 3226f44:	1885c83a 	sub	r2,r3,r2
 3226f48:	1005d0ba 	srai	r2,r2,2
 3226f4c:	2085c83a 	sub	r2,r4,r2
 3226f50:	1085883a 	add	r2,r2,r2
 3226f54:	1085883a 	add	r2,r2,r2
 3226f58:	e0bff215 	stw	r2,-56(fp)
         ns_printf(pio, "%6d,      %6d\n",
 3226f5c:	e0bff417 	ldw	r2,-48(fp)
 3226f60:	10800317 	ldw	r2,12(r2)
 3226f64:	1085883a 	add	r2,r2,r2
 3226f68:	1085883a 	add	r2,r2,r2
 3226f6c:	100d883a 	mov	r6,r2
 3226f70:	e13fff17 	ldw	r4,-4(fp)
 3226f74:	0140c974 	movhi	r5,805
 3226f78:	297cb204 	addi	r5,r5,-3384
 3226f7c:	e1fff217 	ldw	r7,-56(fp)
 3226f80:	322637c0 	call	322637c <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 3226f84:	00000406 	br	3226f98 <tk_stats+0x190>
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
      }
      else
#endif
      {
         ns_printf(pio, "No stack data\n");
 3226f88:	e13fff17 	ldw	r4,-4(fp)
 3226f8c:	0140c974 	movhi	r5,805
 3226f90:	297cb604 	addi	r5,r5,-3368
 3226f94:	322637c0 	call	322637c <ns_printf>
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 3226f98:	e0bff517 	ldw	r2,-44(fp)
 3226f9c:	10800044 	addi	r2,r2,1
 3226fa0:	e0bff515 	stw	r2,-44(fp)
 3226fa4:	e0bff517 	ldw	r2,-44(fp)
 3226fa8:	10800550 	cmplti	r2,r2,21
 3226fac:	103fac1e 	bne	r2,zero,3226e60 <tk_stats+0x58>
      {
         ns_printf(pio, "No stack data\n");
      }
   }

   ns_printf(pio, "tcp_sleep_count = %lu, tcp_wakeup_count = %lu\n",
 3226fb0:	0080c974 	movhi	r2,805
 3226fb4:	10933c04 	addi	r2,r2,19696
 3226fb8:	11800017 	ldw	r6,0(r2)
 3226fbc:	0080c974 	movhi	r2,805
 3226fc0:	10933d04 	addi	r2,r2,19700
 3226fc4:	11c00017 	ldw	r7,0(r2)
 3226fc8:	e13fff17 	ldw	r4,-4(fp)
 3226fcc:	0140c974 	movhi	r5,805
 3226fd0:	297cba04 	addi	r5,r5,-3352
 3226fd4:	322637c0 	call	322637c <ns_printf>
                  tcp_sleep_count, tcp_wakeup_count);
   ns_printf(pio, "global_TCPwakeup_setIndx = %d, tcp_sleep_timeout = %lu\n",
 3226fd8:	0080c974 	movhi	r2,805
 3226fdc:	10934004 	addi	r2,r2,19712
 3226fe0:	11800017 	ldw	r6,0(r2)
 3226fe4:	d1e8c517 	ldw	r7,-23788(gp)
 3226fe8:	e13fff17 	ldw	r4,-4(fp)
 3226fec:	0140c974 	movhi	r5,805
 3226ff0:	297cc604 	addi	r5,r5,-3304
 3226ff4:	322637c0 	call	322637c <ns_printf>
                  global_TCPwakeup_setIndx, tcp_sleep_timeout);

   return 0;
 3226ff8:	0005883a 	mov	r2,zero
}
 3226ffc:	e037883a 	mov	sp,fp
 3227000:	dfc00117 	ldw	ra,4(sp)
 3227004:	df000017 	ldw	fp,0(sp)
 3227008:	dec00204 	addi	sp,sp,8
 322700c:	f800283a 	ret

03227010 <dhc_get_srv_ipaddr>:
 * RETURNS: 
 */

ip_addr 
dhc_get_srv_ipaddr(u_char *options /* after magic cookie */) 
{
 3227010:	defffa04 	addi	sp,sp,-24
 3227014:	dfc00515 	stw	ra,20(sp)
 3227018:	df000415 	stw	fp,16(sp)
 322701c:	df000404 	addi	fp,sp,16
 3227020:	e13fff15 	stw	r4,-4(fp)
    u_char * opts;
    u_char   optlen;
   ip_addr srv_ipaddr = 0;
 3227024:	e03ffc15 	stw	zero,-16(fp)

   if ((opts = find_opt(DHOP_SERVER, options)) != NULL) 
 3227028:	01000d84 	movi	r4,54
 322702c:	e17fff17 	ldw	r5,-4(fp)
 3227030:	3229f500 	call	3229f50 <find_opt>
 3227034:	e0bffe15 	stw	r2,-8(fp)
 3227038:	e0bffe17 	ldw	r2,-8(fp)
 322703c:	1005003a 	cmpeq	r2,r2,zero
 3227040:	1000111e 	bne	r2,zero,3227088 <dhc_get_srv_ipaddr+0x78>
   {
      opts++;
 3227044:	e0bffe17 	ldw	r2,-8(fp)
 3227048:	10800044 	addi	r2,r2,1
 322704c:	e0bffe15 	stw	r2,-8(fp)
      optlen = *opts;
 3227050:	e0bffe17 	ldw	r2,-8(fp)
 3227054:	10800003 	ldbu	r2,0(r2)
 3227058:	e0bffd05 	stb	r2,-12(fp)
      opts++;
 322705c:	e0bffe17 	ldw	r2,-8(fp)
 3227060:	10800044 	addi	r2,r2,1
 3227064:	e0bffe15 	stw	r2,-8(fp)
      srv_ipaddr = dh_getlong(opts);
 3227068:	e13ffe17 	ldw	r4,-8(fp)
 322706c:	32291c00 	call	32291c0 <dh_getlong>
 3227070:	e0bffc15 	stw	r2,-16(fp)
      opts += optlen;
 3227074:	e0bffd03 	ldbu	r2,-12(fp)
 3227078:	1007883a 	mov	r3,r2
 322707c:	e0bffe17 	ldw	r2,-8(fp)
 3227080:	10c5883a 	add	r2,r2,r3
 3227084:	e0bffe15 	stw	r2,-8(fp)
   }

   return (srv_ipaddr);
 3227088:	e0bffc17 	ldw	r2,-16(fp)
} 
 322708c:	e037883a 	mov	sp,fp
 3227090:	dfc00117 	ldw	ra,4(sp)
 3227094:	df000017 	ldw	fp,0(sp)
 3227098:	dec00204 	addi	sp,sp,8
 322709c:	f800283a 	ret

032270a0 <dhc_init>:
 * RETURNS: Returns 0 if OK, else negative error code from net.h file 
 */

int
dhc_init(void)
{
 32270a0:	defffb04 	addi	sp,sp,-20
 32270a4:	dfc00415 	stw	ra,16(sp)
 32270a8:	df000315 	stw	fp,12(sp)
 32270ac:	df000304 	addi	fp,sp,12
   int   i;

   /* open UDP connection to receive incoming DHCP replys */
   dhc_conn = udp_open(0L,    /* wildcard foriegn host */
 32270b0:	00bfff44 	movi	r2,-3
 32270b4:	d8800015 	stw	r2,0(sp)
 32270b8:	0009883a 	mov	r4,zero
 32270bc:	014010c4 	movi	r5,67
 32270c0:	01801104 	movi	r6,68
 32270c4:	01c0c8b4 	movhi	r7,802
 32270c8:	39dc6804 	addi	r7,r7,29088
 32270cc:	322aa400 	call	322aa40 <udp_open>
 32270d0:	d0a8c615 	stw	r2,-23784(gp)
      BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT,
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
 32270d4:	d0a8c617 	ldw	r2,-23784(gp)
 32270d8:	1004c03a 	cmpne	r2,r2,zero
 32270dc:	1000031e 	bne	r2,zero,32270ec <dhc_init+0x4c>
      return ENP_RESOURCE;
 32270e0:	00bffa84 	movi	r2,-22
 32270e4:	e0bfff15 	stw	r2,-4(fp)
 32270e8:	00001606 	br	3227144 <dhc_init+0xa4>

   for (i = 0; i < MAXNETS; i++)
 32270ec:	e03ffe15 	stw	zero,-8(fp)
 32270f0:	00001006 	br	3227134 <dhc_init+0x94>
   {
      dhc_states[i].state = DHCS_UNUSED;
 32270f4:	e0bffe17 	ldw	r2,-8(fp)
 32270f8:	00c0c9b4 	movhi	r3,806
 32270fc:	18f36b04 	addi	r3,r3,-12884
 3227100:	10800f24 	muli	r2,r2,60
 3227104:	10c5883a 	add	r2,r2,r3
 3227108:	10000015 	stw	zero,0(r2)
      dhc_states[i].tries = 0;
 322710c:	e0bffe17 	ldw	r2,-8(fp)
 3227110:	00c0c9b4 	movhi	r3,806
 3227114:	18f36b04 	addi	r3,r3,-12884
 3227118:	10800f24 	muli	r2,r2,60
 322711c:	10c5883a 	add	r2,r2,r3
 3227120:	10800104 	addi	r2,r2,4
 3227124:	10000015 	stw	zero,0(r2)
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
      return ENP_RESOURCE;

   for (i = 0; i < MAXNETS; i++)
 3227128:	e0bffe17 	ldw	r2,-8(fp)
 322712c:	10800044 	addi	r2,r2,1
 3227130:	e0bffe15 	stw	r2,-8(fp)
 3227134:	e0bffe17 	ldw	r2,-8(fp)
 3227138:	10800110 	cmplti	r2,r2,4
 322713c:	103fed1e 	bne	r2,zero,32270f4 <dhc_init+0x54>
   {
      dhc_states[i].state = DHCS_UNUSED;
      dhc_states[i].tries = 0;
   }

   return 0;
 3227140:	e03fff15 	stw	zero,-4(fp)
 3227144:	e0bfff17 	ldw	r2,-4(fp)
}
 3227148:	e037883a 	mov	sp,fp
 322714c:	dfc00117 	ldw	ra,4(sp)
 3227150:	df000017 	ldw	fp,0(sp)
 3227154:	dec00204 	addi	sp,sp,8
 3227158:	f800283a 	ret

0322715c <dhc_set_callback>:
 * RETURNS: 
 */

void
dhc_set_callback(int iface, int (*routine)(int,int) )
{
 322715c:	defffd04 	addi	sp,sp,-12
 3227160:	df000215 	stw	fp,8(sp)
 3227164:	df000204 	addi	fp,sp,8
 3227168:	e13ffe15 	stw	r4,-8(fp)
 322716c:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].callback = routine;
 3227170:	e0bffe17 	ldw	r2,-8(fp)
 3227174:	00c0c9b4 	movhi	r3,806
 3227178:	18f36b04 	addi	r3,r3,-12884
 322717c:	10800f24 	muli	r2,r2,60
 3227180:	10c5883a 	add	r2,r2,r3
 3227184:	10c00e04 	addi	r3,r2,56
 3227188:	e0bfff17 	ldw	r2,-4(fp)
 322718c:	18800015 	stw	r2,0(r3)
}
 3227190:	e037883a 	mov	sp,fp
 3227194:	df000017 	ldw	fp,0(sp)
 3227198:	dec00104 	addi	sp,sp,4
 322719c:	f800283a 	ret

032271a0 <dhc_upcall>:
 * returned
 */

int
dhc_upcall(PACKET pkt, void * data)
{
 32271a0:	defff204 	addi	sp,sp,-56
 32271a4:	dfc00d15 	stw	ra,52(sp)
 32271a8:	df000c15 	stw	fp,48(sp)
 32271ac:	dc000b15 	stw	r16,44(sp)
 32271b0:	df000b04 	addi	fp,sp,44
 32271b4:	e13ffb15 	stw	r4,-20(fp)
 32271b8:	e17ffc15 	stw	r5,-16(fp)
   struct bootp * bp;
   int      len      =  pkt->nb_plen;  /* len of UDP data - the bootp/dhcp struct */
 32271bc:	e0bffb17 	ldw	r2,-20(fp)
 32271c0:	10800417 	ldw	r2,16(r2)
 32271c4:	e0bff915 	stw	r2,-28(fp)
   int      dhcptype =  0;    /* DHCP type - not valid if bootp */
 32271c8:	e03ff815 	stw	zero,-32(fp)
   int      e;
   int      iface;
   u_char * opts;          /* scratch options pointer */

   if (data != DHCPDATA)
 32271cc:	e0bffc17 	ldw	r2,-16(fp)
 32271d0:	10bfff60 	cmpeqi	r2,r2,-3
 32271d4:	1000041e 	bne	r2,zero,32271e8 <dhc_upcall+0x48>
   {
      dtrap();
 32271d8:	322aef00 	call	322aef0 <dtrap>
      return ENP_LOGIC;    /* internal logic error */
 32271dc:	00bffd44 	movi	r2,-11
 32271e0:	e0bffe15 	stw	r2,-8(fp)
 32271e4:	0001f306 	br	32279b4 <dhc_upcall+0x814>
   }

   /* punt if packet didn't come in a net we sent on */
   iface = net_num(pkt->net);
 32271e8:	e0bffb17 	ldw	r2,-20(fp)
 32271ec:	11000617 	ldw	r4,24(r2)
 32271f0:	32240bc0 	call	32240bc <if_netnumber>
 32271f4:	e0bff615 	stw	r2,-40(fp)
   if (dhc_states[iface].state == DHCS_UNUSED)
 32271f8:	e0bff617 	ldw	r2,-40(fp)
 32271fc:	00c0c9b4 	movhi	r3,806
 3227200:	18f36b04 	addi	r3,r3,-12884
 3227204:	10800f24 	muli	r2,r2,60
 3227208:	10c5883a 	add	r2,r2,r3
 322720c:	10800017 	ldw	r2,0(r2)
 3227210:	1004c03a 	cmpne	r2,r2,zero
 3227214:	1000031e 	bne	r2,zero,3227224 <dhc_upcall+0x84>
      return ENP_NOT_MINE;
 3227218:	00c00084 	movi	r3,2
 322721c:	e0fffe15 	stw	r3,-8(fp)
 3227220:	0001e406 	br	32279b4 <dhc_upcall+0x814>

   bp = (struct bootp *)pkt->nb_prot;
 3227224:	e0bffb17 	ldw	r2,-20(fp)
 3227228:	10800317 	ldw	r2,12(r2)
 322722c:	e0bffa15 	stw	r2,-24(fp)

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
 3227230:	e0bff917 	ldw	r2,-28(fp)
 3227234:	10803b30 	cmpltui	r2,r2,236
 3227238:	10000b1e 	bne	r2,zero,3227268 <dhc_upcall+0xc8>
 322723c:	e0bffa17 	ldw	r2,-24(fp)
 3227240:	10800003 	ldbu	r2,0(r2)
 3227244:	10803fcc 	andi	r2,r2,255
 3227248:	10800098 	cmpnei	r2,r2,2
 322724c:	1000061e 	bne	r2,zero,3227268 <dhc_upcall+0xc8>
 3227250:	e0bffa17 	ldw	r2,-24(fp)
 3227254:	10803b04 	addi	r2,r2,236
 3227258:	10c00017 	ldw	r3,0(r2)
 322725c:	0098d534 	movhi	r2,25428
 3227260:	10a098c4 	addi	r2,r2,-32157
 3227264:	18800726 	beq	r3,r2,3227284 <dhc_upcall+0xe4>
       (bp->op != BOOTREPLY) ||
       (*(u_long*)(&bp->options) != RFC1084_MAGIC_COOKIE))
   {
      dtrap();
 3227268:	322aef00 	call	322aef0 <dtrap>
      dsc_errors++;
 322726c:	d0a8c717 	ldw	r2,-23780(gp)
 3227270:	10800044 	addi	r2,r2,1
 3227274:	d0a8c715 	stw	r2,-23780(gp)
      return ENP_NOT_MINE;
 3227278:	01000084 	movi	r4,2
 322727c:	e13ffe15 	stw	r4,-8(fp)
 3227280:	0001cc06 	br	32279b4 <dhc_upcall+0x814>
   }

   /* punt offers or replys which are not for me */
   if(MEMCMP(bp->chaddr, pkt->net->mib.ifPhysAddress, pkt->net->n_hal))
 3227284:	e0bffa17 	ldw	r2,-24(fp)
 3227288:	11000704 	addi	r4,r2,28
 322728c:	e0bffb17 	ldw	r2,-20(fp)
 3227290:	10800617 	ldw	r2,24(r2)
 3227294:	11401717 	ldw	r5,92(r2)
 3227298:	e0bffb17 	ldw	r2,-20(fp)
 322729c:	10800617 	ldw	r2,24(r2)
 32272a0:	11801117 	ldw	r6,68(r2)
 32272a4:	324bcc00 	call	324bcc0 <memcmp>
 32272a8:	1005003a 	cmpeq	r2,r2,zero
 32272ac:	1000031e 	bne	r2,zero,32272bc <dhc_upcall+0x11c>
      return ENP_NOT_MINE;    /* not an error, just ignore it */
 32272b0:	00800084 	movi	r2,2
 32272b4:	e0bffe15 	stw	r2,-8(fp)
 32272b8:	0001be06 	br	32279b4 <dhc_upcall+0x814>

   /* see if it's full DHCP or plain bootp by looking for dhcp type option */
   opts = find_opt(DHOP_TYPE ,&bp->options[4]);
 32272bc:	e0bffa17 	ldw	r2,-24(fp)
 32272c0:	10803b04 	addi	r2,r2,236
 32272c4:	11400104 	addi	r5,r2,4
 32272c8:	01000d44 	movi	r4,53
 32272cc:	3229f500 	call	3229f50 <find_opt>
 32272d0:	e0bff515 	stw	r2,-44(fp)
   if (opts && *opts == DHOP_TYPE)
 32272d4:	e0bff517 	ldw	r2,-44(fp)
 32272d8:	1005003a 	cmpeq	r2,r2,zero
 32272dc:	1000101e 	bne	r2,zero,3227320 <dhc_upcall+0x180>
 32272e0:	e0bff517 	ldw	r2,-44(fp)
 32272e4:	10800003 	ldbu	r2,0(r2)
 32272e8:	10803fcc 	andi	r2,r2,255
 32272ec:	10800d58 	cmpnei	r2,r2,53
 32272f0:	10000b1e 	bne	r2,zero,3227320 <dhc_upcall+0x180>
   {
      dhcptype = *(opts+2);
 32272f4:	e0bff517 	ldw	r2,-44(fp)
 32272f8:	10800084 	addi	r2,r2,2
 32272fc:	10800003 	ldbu	r2,0(r2)
 3227300:	10803fcc 	andi	r2,r2,255
 3227304:	e0bff815 	stw	r2,-32(fp)
      bp->op |= ISDHCP;       /* tag packet for isdhcp() macro */
 3227308:	e0bffa17 	ldw	r2,-24(fp)
 322730c:	10800003 	ldbu	r2,0(r2)
 3227310:	10800114 	ori	r2,r2,4
 3227314:	1007883a 	mov	r3,r2
 3227318:	e0bffa17 	ldw	r2,-24(fp)
 322731c:	10c00005 	stb	r3,0(r2)
   }

   if (isdhcp(bp))
 3227320:	e0bffa17 	ldw	r2,-24(fp)
 3227324:	10800003 	ldbu	r2,0(r2)
 3227328:	10803fcc 	andi	r2,r2,255
 322732c:	1080010c 	andi	r2,r2,4
 3227330:	1005003a 	cmpeq	r2,r2,zero
 3227334:	10017e1e 	bne	r2,zero,3227930 <dhc_upcall+0x790>
   {
      switch (dhcptype)
 3227338:	e0fff817 	ldw	r3,-32(fp)
 322733c:	e0ffff15 	stw	r3,-4(fp)
 3227340:	e13fff17 	ldw	r4,-4(fp)
 3227344:	20800148 	cmpgei	r2,r4,5
 3227348:	1000071e 	bne	r2,zero,3227368 <dhc_upcall+0x1c8>
 322734c:	e0ffff17 	ldw	r3,-4(fp)
 3227350:	188000c8 	cmpgei	r2,r3,3
 3227354:	1000081e 	bne	r2,zero,3227378 <dhc_upcall+0x1d8>
 3227358:	e13fff17 	ldw	r4,-4(fp)
 322735c:	20800060 	cmpeqi	r2,r4,1
 3227360:	1000051e 	bne	r2,zero,3227378 <dhc_upcall+0x1d8>
 3227364:	00000a06 	br	3227390 <dhc_upcall+0x1f0>
 3227368:	e0ffff17 	ldw	r3,-4(fp)
 322736c:	188001e0 	cmpeqi	r2,r3,7
 3227370:	1000011e 	bne	r2,zero,3227378 <dhc_upcall+0x1d8>
 3227374:	00000606 	br	3227390 <dhc_upcall+0x1f0>
      {
      case DHCP_DISCOVER:
      case DHCP_REQUEST:
      case DHCP_DECLINE:
      case DHCP_RELEASE:
         dsc_errors++;     /* these should only be upcalled to a server */
 3227378:	d0a8c717 	ldw	r2,-23780(gp)
 322737c:	10800044 	addi	r2,r2,1
 3227380:	d0a8c715 	stw	r2,-23780(gp)
         return ENP_NOT_MINE;
 3227384:	01000084 	movi	r4,2
 3227388:	e13ffe15 	stw	r4,-8(fp)
 322738c:	00018906 	br	32279b4 <dhc_upcall+0x814>
      }

      switch (dhc_states[iface].state)
 3227390:	e0bff617 	ldw	r2,-40(fp)
 3227394:	00c0c9b4 	movhi	r3,806
 3227398:	18f36b04 	addi	r3,r3,-12884
 322739c:	10800f24 	muli	r2,r2,60
 32273a0:	10c5883a 	add	r2,r2,r3
 32273a4:	10800017 	ldw	r2,0(r2)
 32273a8:	e0bffd15 	stw	r2,-12(fp)
 32273ac:	e0fffd17 	ldw	r3,-12(fp)
 32273b0:	18800268 	cmpgeui	r2,r3,9
 32273b4:	1001541e 	bne	r2,zero,3227908 <dhc_upcall+0x768>
 32273b8:	e13ffd17 	ldw	r4,-12(fp)
 32273bc:	e13ffd17 	ldw	r4,-12(fp)
 32273c0:	2105883a 	add	r2,r4,r4
 32273c4:	1087883a 	add	r3,r2,r2
 32273c8:	0080c8b4 	movhi	r2,802
 32273cc:	109cf704 	addi	r2,r2,29660
 32273d0:	1885883a 	add	r2,r3,r2
 32273d4:	10800017 	ldw	r2,0(r2)
 32273d8:	1000683a 	jmp	r2
 32273dc:	03227908 	cmpgei	r12,zero,-30236
 32273e0:	03227400 	call	322740 <OSCtxSw_SWITCH_PC+0x322700>
 32273e4:	03227400 	call	322740 <OSCtxSw_SWITCH_PC+0x322700>
 32273e8:	03227654 	movui	r12,35289
 32273ec:	03227418 	cmpnei	r12,zero,-30256
 32273f0:	0322759c 	xori	r12,zero,35286
 32273f4:	03227400 	call	322740 <OSCtxSw_SWITCH_PC+0x322700>
 32273f8:	0322759c 	xori	r12,zero,35286
 32273fc:	0322759c 	xori	r12,zero,35286
      case DHCS_INITREBOOT:
         /* How can we receive any response when we never sent one */
      case DHCS_BOUND:
         /* If there are multiple DHCP Servers, and one of them is slow
            in responding, we might get OFFER pkts when are in BOUND state */
         dsc_errors++;     /* these should only be upcalled to a server */
 3227400:	d0a8c717 	ldw	r2,-23780(gp)
 3227404:	10800044 	addi	r2,r2,1
 3227408:	d0a8c715 	stw	r2,-23780(gp)
         return ENP_NOT_MINE;
 322740c:	00800084 	movi	r2,2
 3227410:	e0bffe15 	stw	r2,-8(fp)
 3227414:	00016706 	br	32279b4 <dhc_upcall+0x814>
      case DHCS_SELECTING:
         /* We will respond to the first offer packet that we receive ) */
         if ( dhcptype == DHCP_OFFER ) /* got offer back from server */
 3227418:	e0bff817 	ldw	r2,-32(fp)
 322741c:	10800098 	cmpnei	r2,r2,2
 3227420:	1000521e 	bne	r2,zero,322756c <dhc_upcall+0x3cc>
         {
            dsc_offers++;
 3227424:	d0a8c917 	ldw	r2,-23772(gp)
 3227428:	10800044 	addi	r2,r2,1
 322742c:	d0a8c915 	stw	r2,-23772(gp)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]);
 3227430:	e43ff617 	ldw	r16,-40(fp)
 3227434:	e0bffa17 	ldw	r2,-24(fp)
 3227438:	10803b04 	addi	r2,r2,236
 322743c:	11000104 	addi	r4,r2,4
 3227440:	32270100 	call	3227010 <dhc_get_srv_ipaddr>
 3227444:	1009883a 	mov	r4,r2
 3227448:	00c0c9b4 	movhi	r3,806
 322744c:	18f36b04 	addi	r3,r3,-12884
 3227450:	80800f24 	muli	r2,r16,60
 3227454:	10c5883a 	add	r2,r2,r3
 3227458:	10800d04 	addi	r2,r2,52
 322745c:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 3227460:	e0bff617 	ldw	r2,-40(fp)
 3227464:	00c0c9b4 	movhi	r3,806
 3227468:	18f36b04 	addi	r3,r3,-12884
 322746c:	10800f24 	muli	r2,r2,60
 3227470:	10c5883a 	add	r2,r2,r3
 3227474:	10800d04 	addi	r2,r2,52
 3227478:	10800017 	ldw	r2,0(r2)
 322747c:	1004c03a 	cmpne	r2,r2,zero
 3227480:	10000d1e 	bne	r2,zero,32274b8 <dhc_upcall+0x318>
            {
               dtrap(); /* didn't receive server-identifier option */
 3227484:	322aef00 	call	322aef0 <dtrap>
               dsc_errors++;
 3227488:	d0a8c717 	ldw	r2,-23780(gp)
 322748c:	10800044 	addi	r2,r2,1
 3227490:	d0a8c715 	stw	r2,-23780(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 3227494:	e13ff617 	ldw	r4,-40(fp)
 3227498:	e0bffb17 	ldw	r2,-20(fp)
 322749c:	11400717 	ldw	r5,28(r2)
 32274a0:	00c0c9b4 	movhi	r3,806
 32274a4:	18f36b04 	addi	r3,r3,-12884
 32274a8:	20800f24 	muli	r2,r4,60
 32274ac:	10c5883a 	add	r2,r2,r3
 32274b0:	10800d04 	addi	r2,r2,52
 32274b4:	11400015 	stw	r5,0(r2)
            }

            if (bp->hops)
 32274b8:	e0bffa17 	ldw	r2,-24(fp)
 32274bc:	108000c3 	ldbu	r2,3(r2)
 32274c0:	10803fcc 	andi	r2,r2,255
 32274c4:	1005003a 	cmpeq	r2,r2,zero
 32274c8:	10000a1e 	bne	r2,zero,32274f4 <dhc_upcall+0x354>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 32274cc:	e13ff617 	ldw	r4,-40(fp)
 32274d0:	e0bffb17 	ldw	r2,-20(fp)
 32274d4:	11400717 	ldw	r5,28(r2)
 32274d8:	00c0c9b4 	movhi	r3,806
 32274dc:	18f36b04 	addi	r3,r3,-12884
 32274e0:	20800f24 	muli	r2,r4,60
 32274e4:	10c5883a 	add	r2,r2,r3
 32274e8:	10800c04 	addi	r2,r2,48
 32274ec:	11400015 	stw	r5,0(r2)
 32274f0:	00000706 	br	3227510 <dhc_upcall+0x370>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 32274f4:	e0bff617 	ldw	r2,-40(fp)
 32274f8:	00c0c9b4 	movhi	r3,806
 32274fc:	18f36b04 	addi	r3,r3,-12884
 3227500:	10800f24 	muli	r2,r2,60
 3227504:	10c5883a 	add	r2,r2,r3
 3227508:	10800c04 	addi	r2,r2,48
 322750c:	10000015 	stw	zero,0(r2)

            e = dhc_rx_offer(iface,bp,pkt->nb_plen);     /* send request */
 3227510:	e0bffb17 	ldw	r2,-20(fp)
 3227514:	11800417 	ldw	r6,16(r2)
 3227518:	e13ff617 	ldw	r4,-40(fp)
 322751c:	e17ffa17 	ldw	r5,-24(fp)
 3227520:	32281040 	call	3228104 <dhc_rx_offer>
 3227524:	e0bff715 	stw	r2,-36(fp)
            if (e)
 3227528:	e0bff717 	ldw	r2,-36(fp)
 322752c:	1005003a 	cmpeq	r2,r2,zero
 3227530:	10000a1e 	bne	r2,zero,322755c <dhc_upcall+0x3bc>
            {
               dsc_errors++;
 3227534:	d0a8c717 	ldw	r2,-23780(gp)
 3227538:	10800044 	addi	r2,r2,1
 322753c:	d0a8c715 	stw	r2,-23780(gp)
               dhc_set_state(iface,DHCS_INIT);
 3227540:	e13ff617 	ldw	r4,-40(fp)
 3227544:	01400044 	movi	r5,1
 3227548:	3229ea00 	call	3229ea0 <dhc_set_state>
               dtrap();
 322754c:	322aef00 	call	322aef0 <dtrap>
               return ENP_NOT_MINE;
 3227550:	00c00084 	movi	r3,2
 3227554:	e0fffe15 	stw	r3,-8(fp)
 3227558:	00011606 	br	32279b4 <dhc_upcall+0x814>
            }
            else
               dhc_set_state(iface,DHCS_REQUESTING);
 322755c:	e13ff617 	ldw	r4,-40(fp)
 3227560:	01400144 	movi	r5,5
 3227564:	3229ea00 	call	3229ea0 <dhc_set_state>
            dsc_errors++;
            if ( dhcptype == DHCP_NAK ) 
               dsc_naks++;
            return ENP_NOT_MINE;
         }
         break;
 3227568:	00010f06 	br	32279a8 <dhc_upcall+0x808>
             * Report an error and remain in SELECTING state, so that 
             * an OFFER packet from another DHCP server can be 
             * accepted. If we timeout waiting for a OFFER packet, 
             * then dhc_second() will transition to DHCS_INIT state. 
             */
            dsc_errors++;
 322756c:	d0a8c717 	ldw	r2,-23780(gp)
 3227570:	10800044 	addi	r2,r2,1
 3227574:	d0a8c715 	stw	r2,-23780(gp)
            if ( dhcptype == DHCP_NAK ) 
 3227578:	e0bff817 	ldw	r2,-32(fp)
 322757c:	10800198 	cmpnei	r2,r2,6
 3227580:	1000031e 	bne	r2,zero,3227590 <dhc_upcall+0x3f0>
               dsc_naks++;
 3227584:	d0a8cf17 	ldw	r2,-23748(gp)
 3227588:	10800044 	addi	r2,r2,1
 322758c:	d0a8cf15 	stw	r2,-23748(gp)
            return ENP_NOT_MINE;
 3227590:	01000084 	movi	r4,2
 3227594:	e13ffe15 	stw	r4,-8(fp)
 3227598:	00010606 	br	32279b4 <dhc_upcall+0x814>
      case DHCS_RENEWING:
         /* If the ACK/NACK is not from the same server which sent 
          * the OFFER packet, then discard it. in DHCS_REBOOTING 
          * state, srv_ipaddr is 0. Hence don't check in that state 
          */
         if ( dhc_states[iface].srv_ipaddr != 
 322759c:	e0bff617 	ldw	r2,-40(fp)
 32275a0:	00c0c9b4 	movhi	r3,806
 32275a4:	18f36b04 	addi	r3,r3,-12884
 32275a8:	10800f24 	muli	r2,r2,60
 32275ac:	10c5883a 	add	r2,r2,r3
 32275b0:	10800d04 	addi	r2,r2,52
 32275b4:	14000017 	ldw	r16,0(r2)
 32275b8:	e0bffa17 	ldw	r2,-24(fp)
 32275bc:	10803b04 	addi	r2,r2,236
 32275c0:	11000104 	addi	r4,r2,4
 32275c4:	32270100 	call	3227010 <dhc_get_srv_ipaddr>
 32275c8:	80800626 	beq	r16,r2,32275e4 <dhc_upcall+0x444>
             dhc_get_srv_ipaddr(&bp->options[4]) )
         {
            dsc_errors++;
 32275cc:	d0a8c717 	ldw	r2,-23780(gp)
 32275d0:	10800044 	addi	r2,r2,1
 32275d4:	d0a8c715 	stw	r2,-23780(gp)
            return ENP_NOT_MINE;
 32275d8:	00800084 	movi	r2,2
 32275dc:	e0bffe15 	stw	r2,-8(fp)
 32275e0:	0000f406 	br	32279b4 <dhc_upcall+0x814>
         }
         if (dhc_states[iface].rly_ipaddr &&
 32275e4:	e0bff617 	ldw	r2,-40(fp)
 32275e8:	00c0c9b4 	movhi	r3,806
 32275ec:	18f36b04 	addi	r3,r3,-12884
 32275f0:	10800f24 	muli	r2,r2,60
 32275f4:	10c5883a 	add	r2,r2,r3
 32275f8:	10800c04 	addi	r2,r2,48
 32275fc:	10800017 	ldw	r2,0(r2)
 3227600:	1005003a 	cmpeq	r2,r2,zero
 3227604:	1000131e 	bne	r2,zero,3227654 <dhc_upcall+0x4b4>
 3227608:	e0bff617 	ldw	r2,-40(fp)
 322760c:	00c0c9b4 	movhi	r3,806
 3227610:	18f36b04 	addi	r3,r3,-12884
 3227614:	10800f24 	muli	r2,r2,60
 3227618:	10c5883a 	add	r2,r2,r3
 322761c:	10800c04 	addi	r2,r2,48
 3227620:	10c00017 	ldw	r3,0(r2)
 3227624:	e0bffb17 	ldw	r2,-20(fp)
 3227628:	10800717 	ldw	r2,28(r2)
 322762c:	18800926 	beq	r3,r2,3227654 <dhc_upcall+0x4b4>
            (dhc_states[iface].rly_ipaddr != pkt->fhost))
         {
            dsc_rlyerrs++;
 3227630:	d0a8d217 	ldw	r2,-23736(gp)
 3227634:	10800044 	addi	r2,r2,1
 3227638:	d0a8d215 	stw	r2,-23736(gp)
            dsc_errors++;
 322763c:	d0a8c717 	ldw	r2,-23780(gp)
 3227640:	10800044 	addi	r2,r2,1
 3227644:	d0a8c715 	stw	r2,-23780(gp)
            return ENP_NOT_MINE;
 3227648:	00c00084 	movi	r3,2
 322764c:	e0fffe15 	stw	r3,-8(fp)
 3227650:	0000d806 	br	32279b4 <dhc_upcall+0x814>
         }
      case DHCS_REBOOTING:
         if ( dhcptype == DHCP_ACK )   /* Server OKed our request */
 3227654:	e0bff817 	ldw	r2,-32(fp)
 3227658:	10800158 	cmpnei	r2,r2,5
 322765c:	1000891e 	bne	r2,zero,3227884 <dhc_upcall+0x6e4>
         {
            dsc_acks++;
 3227660:	d0a8cb17 	ldw	r2,-23764(gp)
 3227664:	10800044 	addi	r2,r2,1
 3227668:	d0a8cb15 	stw	r2,-23764(gp)
            dhc_extract_opts(iface,&bp->options[4]);
 322766c:	e0bffa17 	ldw	r2,-24(fp)
 3227670:	10803b04 	addi	r2,r2,236
 3227674:	11400104 	addi	r5,r2,4
 3227678:	e13ff617 	ldw	r4,-40(fp)
 322767c:	322928c0 	call	322928c <dhc_extract_opts>
            if ( dhc_states[iface].lease == DHC_INFINITY )
 3227680:	e0bff617 	ldw	r2,-40(fp)
 3227684:	00c0c9b4 	movhi	r3,806
 3227688:	18f36b04 	addi	r3,r3,-12884
 322768c:	10800f24 	muli	r2,r2,60
 3227690:	10c5883a 	add	r2,r2,r3
 3227694:	10800504 	addi	r2,r2,20
 3227698:	10800017 	ldw	r2,0(r2)
 322769c:	10bfffd8 	cmpnei	r2,r2,-1
 32276a0:	1000111e 	bne	r2,zero,32276e8 <dhc_upcall+0x548>
            {
               dhc_states[iface].t1 = DHC_INFINITY ;
 32276a4:	e0bff617 	ldw	r2,-40(fp)
 32276a8:	00c0c9b4 	movhi	r3,806
 32276ac:	18f36b04 	addi	r3,r3,-12884
 32276b0:	10800f24 	muli	r2,r2,60
 32276b4:	10c5883a 	add	r2,r2,r3
 32276b8:	10c00604 	addi	r3,r2,24
 32276bc:	00bfffc4 	movi	r2,-1
 32276c0:	18800015 	stw	r2,0(r3)
               dhc_states[iface].t2 = DHC_INFINITY ;
 32276c4:	e0bff617 	ldw	r2,-40(fp)
 32276c8:	00c0c9b4 	movhi	r3,806
 32276cc:	18f36b04 	addi	r3,r3,-12884
 32276d0:	10800f24 	muli	r2,r2,60
 32276d4:	10c5883a 	add	r2,r2,r3
 32276d8:	10c00704 	addi	r3,r2,28
 32276dc:	00bfffc4 	movi	r2,-1
 32276e0:	18800015 	stw	r2,0(r3)
 32276e4:	00001f06 	br	3227764 <dhc_upcall+0x5c4>
            }
            else
            {
               dhc_states[iface].t1 = dhc_states[iface].lease/2     ;
 32276e8:	e17ff617 	ldw	r5,-40(fp)
 32276ec:	e0bff617 	ldw	r2,-40(fp)
 32276f0:	00c0c9b4 	movhi	r3,806
 32276f4:	18f36b04 	addi	r3,r3,-12884
 32276f8:	10800f24 	muli	r2,r2,60
 32276fc:	10c5883a 	add	r2,r2,r3
 3227700:	10800504 	addi	r2,r2,20
 3227704:	10800017 	ldw	r2,0(r2)
 3227708:	1008d07a 	srli	r4,r2,1
 322770c:	00c0c9b4 	movhi	r3,806
 3227710:	18f36b04 	addi	r3,r3,-12884
 3227714:	28800f24 	muli	r2,r5,60
 3227718:	10c5883a 	add	r2,r2,r3
 322771c:	10800604 	addi	r2,r2,24
 3227720:	11000015 	stw	r4,0(r2)
               dhc_states[iface].t2 = (dhc_states[iface].lease/8)*7 ;
 3227724:	e17ff617 	ldw	r5,-40(fp)
 3227728:	e0bff617 	ldw	r2,-40(fp)
 322772c:	00c0c9b4 	movhi	r3,806
 3227730:	18f36b04 	addi	r3,r3,-12884
 3227734:	10800f24 	muli	r2,r2,60
 3227738:	10c5883a 	add	r2,r2,r3
 322773c:	10800504 	addi	r2,r2,20
 3227740:	10800017 	ldw	r2,0(r2)
 3227744:	1004d0fa 	srli	r2,r2,3
 3227748:	110001e4 	muli	r4,r2,7
 322774c:	00c0c9b4 	movhi	r3,806
 3227750:	18f36b04 	addi	r3,r3,-12884
 3227754:	28800f24 	muli	r2,r5,60
 3227758:	10c5883a 	add	r2,r2,r3
 322775c:	10800704 	addi	r2,r2,28
 3227760:	11000015 	stw	r4,0(r2)
            }
            dhc_states[iface].lease_start = cticks;   /* to calc lease expiry */
 3227764:	e13ff617 	ldw	r4,-40(fp)
 3227768:	0080c974 	movhi	r2,805
 322776c:	10934104 	addi	r2,r2,19716
 3227770:	11400017 	ldw	r5,0(r2)
 3227774:	00c0c9b4 	movhi	r3,806
 3227778:	18f36b04 	addi	r3,r3,-12884
 322777c:	20800f24 	muli	r2,r4,60
 3227780:	10c5883a 	add	r2,r2,r3
 3227784:	10800804 	addi	r2,r2,32
 3227788:	11400015 	stw	r5,0(r2)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]); 
 322778c:	e43ff617 	ldw	r16,-40(fp)
 3227790:	e0bffa17 	ldw	r2,-24(fp)
 3227794:	10803b04 	addi	r2,r2,236
 3227798:	11000104 	addi	r4,r2,4
 322779c:	32270100 	call	3227010 <dhc_get_srv_ipaddr>
 32277a0:	1009883a 	mov	r4,r2
 32277a4:	00c0c9b4 	movhi	r3,806
 32277a8:	18f36b04 	addi	r3,r3,-12884
 32277ac:	80800f24 	muli	r2,r16,60
 32277b0:	10c5883a 	add	r2,r2,r3
 32277b4:	10800d04 	addi	r2,r2,52
 32277b8:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 32277bc:	e0bff617 	ldw	r2,-40(fp)
 32277c0:	00c0c9b4 	movhi	r3,806
 32277c4:	18f36b04 	addi	r3,r3,-12884
 32277c8:	10800f24 	muli	r2,r2,60
 32277cc:	10c5883a 	add	r2,r2,r3
 32277d0:	10800d04 	addi	r2,r2,52
 32277d4:	10800017 	ldw	r2,0(r2)
 32277d8:	1004c03a 	cmpne	r2,r2,zero
 32277dc:	10000d1e 	bne	r2,zero,3227814 <dhc_upcall+0x674>
            {
               dtrap(); /* didn't receive server-identifier option */
 32277e0:	322aef00 	call	322aef0 <dtrap>
               dsc_errors++;
 32277e4:	d0a8c717 	ldw	r2,-23780(gp)
 32277e8:	10800044 	addi	r2,r2,1
 32277ec:	d0a8c715 	stw	r2,-23780(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 32277f0:	e13ff617 	ldw	r4,-40(fp)
 32277f4:	e0bffb17 	ldw	r2,-20(fp)
 32277f8:	11400717 	ldw	r5,28(r2)
 32277fc:	00c0c9b4 	movhi	r3,806
 3227800:	18f36b04 	addi	r3,r3,-12884
 3227804:	20800f24 	muli	r2,r4,60
 3227808:	10c5883a 	add	r2,r2,r3
 322780c:	10800d04 	addi	r2,r2,52
 3227810:	11400015 	stw	r5,0(r2)
            }
            if (bp->hops)
 3227814:	e0bffa17 	ldw	r2,-24(fp)
 3227818:	108000c3 	ldbu	r2,3(r2)
 322781c:	10803fcc 	andi	r2,r2,255
 3227820:	1005003a 	cmpeq	r2,r2,zero
 3227824:	10000a1e 	bne	r2,zero,3227850 <dhc_upcall+0x6b0>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 3227828:	e13ff617 	ldw	r4,-40(fp)
 322782c:	e0bffb17 	ldw	r2,-20(fp)
 3227830:	11400717 	ldw	r5,28(r2)
 3227834:	00c0c9b4 	movhi	r3,806
 3227838:	18f36b04 	addi	r3,r3,-12884
 322783c:	20800f24 	muli	r2,r4,60
 3227840:	10c5883a 	add	r2,r2,r3
 3227844:	10800c04 	addi	r2,r2,48
 3227848:	11400015 	stw	r5,0(r2)
 322784c:	00000706 	br	322786c <dhc_upcall+0x6cc>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 3227850:	e0bff617 	ldw	r2,-40(fp)
 3227854:	00c0c9b4 	movhi	r3,806
 3227858:	18f36b04 	addi	r3,r3,-12884
 322785c:	10800f24 	muli	r2,r2,60
 3227860:	10c5883a 	add	r2,r2,r3
 3227864:	10800c04 	addi	r2,r2,48
 3227868:	10000015 	stw	zero,0(r2)

            dhc_setip(iface);
 322786c:	e13ff617 	ldw	r4,-40(fp)
 3227870:	3228d440 	call	3228d44 <dhc_setip>
            dhc_set_state(iface,DHCS_BOUND);
 3227874:	e13ff617 	ldw	r4,-40(fp)
 3227878:	01400184 	movi	r5,6
 322787c:	3229ea00 	call	3229ea0 <dhc_set_state>
 3227880:	00004906 	br	32279a8 <dhc_upcall+0x808>
         }
         else if ( dhcptype == DHCP_NAK ) /* Server denied our request */
 3227884:	e0bff817 	ldw	r2,-32(fp)
 3227888:	10800198 	cmpnei	r2,r2,6
 322788c:	1000071e 	bne	r2,zero,32278ac <dhc_upcall+0x70c>
         {
            dhc_set_state(iface,DHCS_INIT);
 3227890:	e13ff617 	ldw	r4,-40(fp)
 3227894:	01400044 	movi	r5,1
 3227898:	3229ea00 	call	3229ea0 <dhc_set_state>
            dsc_naks++;
 322789c:	d0a8cf17 	ldw	r2,-23748(gp)
 32278a0:	10800044 	addi	r2,r2,1
 32278a4:	d0a8cf15 	stw	r2,-23748(gp)
 32278a8:	00003f06 	br	32279a8 <dhc_upcall+0x808>
         {
            /* In REQUESTING state, we might receive a retransmitted
             * OFFER, which we should discard, but it's not an error,
             * so we log it.
             */
            if ((dhc_states[iface].state == DHCS_REQUESTING) &&
 32278ac:	e0bff617 	ldw	r2,-40(fp)
 32278b0:	00c0c9b4 	movhi	r3,806
 32278b4:	18f36b04 	addi	r3,r3,-12884
 32278b8:	10800f24 	muli	r2,r2,60
 32278bc:	10c5883a 	add	r2,r2,r3
 32278c0:	10800017 	ldw	r2,0(r2)
 32278c4:	10800158 	cmpnei	r2,r2,5
 32278c8:	1000091e 	bne	r2,zero,32278f0 <dhc_upcall+0x750>
 32278cc:	e0bff817 	ldw	r2,-32(fp)
 32278d0:	10800098 	cmpnei	r2,r2,2
 32278d4:	1000061e 	bne	r2,zero,32278f0 <dhc_upcall+0x750>
                (dhcptype == DHCP_OFFER))
            {
               dsc_offers++;
 32278d8:	d0a8c917 	ldw	r2,-23772(gp)
 32278dc:	10800044 	addi	r2,r2,1
 32278e0:	d0a8c915 	stw	r2,-23772(gp)
               return ENP_NOT_MINE;
 32278e4:	01000084 	movi	r4,2
 32278e8:	e13ffe15 	stw	r4,-8(fp)
 32278ec:	00003106 	br	32279b4 <dhc_upcall+0x814>
             * only receive ACK or NAK, and in REQUESTING state we
             * should only receive ACK or NAK or OFFER; these are
             * accounted for above, so we log whatever this is as an
             * error and discard it with no change to our state.
             */
            dsc_errors++;
 32278f0:	d0a8c717 	ldw	r2,-23780(gp)
 32278f4:	10800044 	addi	r2,r2,1
 32278f8:	d0a8c715 	stw	r2,-23780(gp)
            return ENP_NOT_MINE;
 32278fc:	00800084 	movi	r2,2
 3227900:	e0bffe15 	stw	r2,-8(fp)
 3227904:	00002b06 	br	32279b4 <dhc_upcall+0x814>
         }
         break;
      default:    /* bad state */
         dtrap();
 3227908:	322aef00 	call	322aef0 <dtrap>
         dhc_set_state(iface,DHCS_INIT);
 322790c:	e13ff617 	ldw	r4,-40(fp)
 3227910:	01400044 	movi	r5,1
 3227914:	3229ea00 	call	3229ea0 <dhc_set_state>
         dsc_errors++;
 3227918:	d0a8c717 	ldw	r2,-23780(gp)
 322791c:	10800044 	addi	r2,r2,1
 3227920:	d0a8c715 	stw	r2,-23780(gp)
         return -1;
 3227924:	00ffffc4 	movi	r3,-1
 3227928:	e0fffe15 	stw	r3,-8(fp)
 322792c:	00002106 	br	32279b4 <dhc_upcall+0x814>
      }
   }
   else     /* plain bootp reply */
   {
      dsc_bpreplys++;
 3227930:	d0a8cc17 	ldw	r2,-23760(gp)
 3227934:	10800044 	addi	r2,r2,1
 3227938:	d0a8cc15 	stw	r2,-23760(gp)
      dhc_extract_opts(iface,&bp->options[4]);
 322793c:	e0bffa17 	ldw	r2,-24(fp)
 3227940:	10803b04 	addi	r2,r2,236
 3227944:	11400104 	addi	r5,r2,4
 3227948:	e13ff617 	ldw	r4,-40(fp)
 322794c:	322928c0 	call	322928c <dhc_extract_opts>
      dhc_states[iface].ipaddr = bp->yiaddr;
 3227950:	e13ff617 	ldw	r4,-40(fp)
 3227954:	e0bffa17 	ldw	r2,-24(fp)
 3227958:	11400417 	ldw	r5,16(r2)
 322795c:	00c0c9b4 	movhi	r3,806
 3227960:	18f36b04 	addi	r3,r3,-12884
 3227964:	20800f24 	muli	r2,r4,60
 3227968:	10c5883a 	add	r2,r2,r3
 322796c:	10800904 	addi	r2,r2,36
 3227970:	11400015 	stw	r5,0(r2)
      dhc_setip(iface);
 3227974:	e13ff617 	ldw	r4,-40(fp)
 3227978:	3228d440 	call	3228d44 <dhc_setip>

      /* Set values so that DHCP State Machine remains happy */
      dhc_set_state(iface,DHCS_BOUND);
 322797c:	e13ff617 	ldw	r4,-40(fp)
 3227980:	01400184 	movi	r5,6
 3227984:	3229ea00 	call	3229ea0 <dhc_set_state>
      dhc_states[iface].t1    = DHC_INFINITY ;
 3227988:	e0bff617 	ldw	r2,-40(fp)
 322798c:	00c0c9b4 	movhi	r3,806
 3227990:	18f36b04 	addi	r3,r3,-12884
 3227994:	10800f24 	muli	r2,r2,60
 3227998:	10c5883a 	add	r2,r2,r3
 322799c:	10c00604 	addi	r3,r2,24
 32279a0:	00bfffc4 	movi	r2,-1
 32279a4:	18800015 	stw	r2,0(r3)
   }

   udp_free(pkt);
 32279a8:	e13ffb17 	ldw	r4,-20(fp)
 32279ac:	32455e00 	call	32455e0 <udp_free>
   return 0;
 32279b0:	e03ffe15 	stw	zero,-8(fp)
 32279b4:	e0bffe17 	ldw	r2,-8(fp)
}
 32279b8:	e037883a 	mov	sp,fp
 32279bc:	dfc00217 	ldw	ra,8(sp)
 32279c0:	df000117 	ldw	fp,4(sp)
 32279c4:	dc000017 	ldw	r16,0(sp)
 32279c8:	dec00304 	addi	sp,sp,12
 32279cc:	f800283a 	ret

032279d0 <dhc_buildheader>:
 * RETURNS: Returns 0 on success, else an ENP_ error code. 
 */

int
dhc_buildheader(int iface, struct bootp * outbp)
{
 32279d0:	defff804 	addi	sp,sp,-32
 32279d4:	dfc00715 	stw	ra,28(sp)
 32279d8:	df000615 	stw	fp,24(sp)
 32279dc:	df000604 	addi	fp,sp,24
 32279e0:	e13ffb15 	stw	r4,-20(fp)
 32279e4:	e17ffc15 	stw	r5,-16(fp)
   int   addrlen;    /* length of hardware address */

   MEMSET(outbp, 0, sizeof(struct bootp));   /* most of this is 0 anyway */
 32279e8:	e0bffc17 	ldw	r2,-16(fp)
 32279ec:	1009883a 	mov	r4,r2
 32279f0:	01804b04 	movi	r6,300
 32279f4:	000b883a 	mov	r5,zero
 32279f8:	3206c500 	call	3206c50 <memset>
   outbp->op = BOOTREQUEST;
 32279fc:	e0fffc17 	ldw	r3,-16(fp)
 3227a00:	00800044 	movi	r2,1
 3227a04:	18800005 	stb	r2,0(r3)

   /* map SNMPish hardware types into bootp types */
   switch (nets[iface]->n_mib->ifType)
 3227a08:	e0bffb17 	ldw	r2,-20(fp)
 3227a0c:	00c0c9b4 	movhi	r3,806
 3227a10:	18f34504 	addi	r3,r3,-13036
 3227a14:	1085883a 	add	r2,r2,r2
 3227a18:	1085883a 	add	r2,r2,r2
 3227a1c:	10c5883a 	add	r2,r2,r3
 3227a20:	10800017 	ldw	r2,0(r2)
 3227a24:	10802717 	ldw	r2,156(r2)
 3227a28:	10800217 	ldw	r2,8(r2)
 3227a2c:	e0bfff15 	stw	r2,-4(fp)
 3227a30:	e0ffff17 	ldw	r3,-4(fp)
 3227a34:	188005e0 	cmpeqi	r2,r3,23
 3227a38:	10000b1e 	bne	r2,zero,3227a68 <dhc_buildheader+0x98>
 3227a3c:	e0ffff17 	ldw	r3,-4(fp)
 3227a40:	18800720 	cmpeqi	r2,r3,28
 3227a44:	1000081e 	bne	r2,zero,3227a68 <dhc_buildheader+0x98>
 3227a48:	e0ffff17 	ldw	r3,-4(fp)
 3227a4c:	188001a0 	cmpeqi	r2,r3,6
 3227a50:	1000011e 	bne	r2,zero,3227a58 <dhc_buildheader+0x88>
 3227a54:	00000806 	br	3227a78 <dhc_buildheader+0xa8>
   {
   case ETHERNET:       /* ETHERNET defined in net.h */
      outbp->htype = ETHHWTYPE;  /* defined in dhcp.h */
 3227a58:	e0fffc17 	ldw	r3,-16(fp)
 3227a5c:	00800044 	movi	r2,1
 3227a60:	18800045 	stb	r2,1(r3)
   break;
 3227a64:	00000806 	br	3227a88 <dhc_buildheader+0xb8>
   case PPP:
   case SLIP:
      outbp->htype = LINEHWTYPE;    /* line type for PPP or SLIP */
 3227a68:	e0fffc17 	ldw	r3,-16(fp)
 3227a6c:	00800504 	movi	r2,20
 3227a70:	18800045 	stb	r2,1(r3)
   break;
 3227a74:	00000406 	br	3227a88 <dhc_buildheader+0xb8>
      default:
      dtrap();
 3227a78:	322aef00 	call	322aef0 <dtrap>
      return ENP_LOGIC;             /* this shouldn't happen */
 3227a7c:	00bffd44 	movi	r2,-11
 3227a80:	e0bffe15 	stw	r2,-8(fp)
 3227a84:	00005306 	br	3227bd4 <dhc_buildheader+0x204>
   }

   addrlen = min(16, nets[iface]->n_hal);
 3227a88:	e0bffb17 	ldw	r2,-20(fp)
 3227a8c:	00c0c9b4 	movhi	r3,806
 3227a90:	18f34504 	addi	r3,r3,-13036
 3227a94:	1085883a 	add	r2,r2,r2
 3227a98:	1085883a 	add	r2,r2,r2
 3227a9c:	10c5883a 	add	r2,r2,r3
 3227aa0:	10800017 	ldw	r2,0(r2)
 3227aa4:	10801117 	ldw	r2,68(r2)
 3227aa8:	e0bffd15 	stw	r2,-12(fp)
 3227aac:	e0fffd17 	ldw	r3,-12(fp)
 3227ab0:	18800470 	cmpltui	r2,r3,17
 3227ab4:	1000021e 	bne	r2,zero,3227ac0 <dhc_buildheader+0xf0>
 3227ab8:	00800404 	movi	r2,16
 3227abc:	e0bffd15 	stw	r2,-12(fp)
 3227ac0:	e0fffd17 	ldw	r3,-12(fp)
 3227ac4:	e0fffa15 	stw	r3,-24(fp)
   outbp->hlen = (u_char)addrlen;
 3227ac8:	e0bffa17 	ldw	r2,-24(fp)
 3227acc:	1007883a 	mov	r3,r2
 3227ad0:	e0bffc17 	ldw	r2,-16(fp)
 3227ad4:	10c00085 	stb	r3,2(r2)
   outbp->hops = 0;
 3227ad8:	e0bffc17 	ldw	r2,-16(fp)
 3227adc:	100000c5 	stb	zero,3(r2)
   if(dhc_states[iface].state == DHCS_RENEWING) 
 3227ae0:	e0bffb17 	ldw	r2,-20(fp)
 3227ae4:	00c0c9b4 	movhi	r3,806
 3227ae8:	18f36b04 	addi	r3,r3,-12884
 3227aec:	10800f24 	muli	r2,r2,60
 3227af0:	10c5883a 	add	r2,r2,r3
 3227af4:	10800017 	ldw	r2,0(r2)
 3227af8:	108001d8 	cmpnei	r2,r2,7
 3227afc:	1000031e 	bne	r2,zero,3227b0c <dhc_buildheader+0x13c>
      outbp->flags = 0; /* Renewing needs unicast */
 3227b00:	e0bffc17 	ldw	r2,-16(fp)
 3227b04:	1000028d 	sth	zero,10(r2)
 3227b08:	00000306 	br	3227b18 <dhc_buildheader+0x148>
   else
      outbp->flags = htons(DHC_BCASTFLAG); /* Othwise broadcast */
 3227b0c:	e0fffc17 	ldw	r3,-16(fp)
 3227b10:	00802004 	movi	r2,128
 3227b14:	1880028d 	sth	r2,10(r3)
   outbp->xid = dhc_states[iface].xid;
 3227b18:	e0bffb17 	ldw	r2,-20(fp)
 3227b1c:	00c0c9b4 	movhi	r3,806
 3227b20:	18f36b04 	addi	r3,r3,-12884
 3227b24:	10800f24 	muli	r2,r2,60
 3227b28:	10c5883a 	add	r2,r2,r3
 3227b2c:	10800204 	addi	r2,r2,8
 3227b30:	10c00017 	ldw	r3,0(r2)
 3227b34:	e0bffc17 	ldw	r2,-16(fp)
 3227b38:	10c00115 	stw	r3,4(r2)
   outbp->secs = dhc_states[iface].secs;
 3227b3c:	e0bffb17 	ldw	r2,-20(fp)
 3227b40:	00c0c9b4 	movhi	r3,806
 3227b44:	18f36b04 	addi	r3,r3,-12884
 3227b48:	10800f24 	muli	r2,r2,60
 3227b4c:	10c5883a 	add	r2,r2,r3
 3227b50:	10800304 	addi	r2,r2,12
 3227b54:	10c0000b 	ldhu	r3,0(r2)
 3227b58:	e0bffc17 	ldw	r2,-16(fp)
 3227b5c:	10c0020d 	sth	r3,8(r2)
#ifdef NPDEBUG
   /* make sure net[] has a MAC address, even if length is zero */
   if(nets[iface]->mib.ifPhysAddress == NULL)
 3227b60:	e0bffb17 	ldw	r2,-20(fp)
 3227b64:	00c0c9b4 	movhi	r3,806
 3227b68:	18f34504 	addi	r3,r3,-13036
 3227b6c:	1085883a 	add	r2,r2,r2
 3227b70:	1085883a 	add	r2,r2,r2
 3227b74:	10c5883a 	add	r2,r2,r3
 3227b78:	10800017 	ldw	r2,0(r2)
 3227b7c:	10801717 	ldw	r2,92(r2)
 3227b80:	1004c03a 	cmpne	r2,r2,zero
 3227b84:	1000041e 	bne	r2,zero,3227b98 <dhc_buildheader+0x1c8>
   {
      dtrap();
 3227b88:	322aef00 	call	322aef0 <dtrap>
      return ENP_LOGIC;
 3227b8c:	00bffd44 	movi	r2,-11
 3227b90:	e0bffe15 	stw	r2,-8(fp)
 3227b94:	00000f06 	br	3227bd4 <dhc_buildheader+0x204>
   }
#endif
   MEMCPY(outbp->chaddr, nets[iface]->mib.ifPhysAddress, addrlen);
 3227b98:	e0bffc17 	ldw	r2,-16(fp)
 3227b9c:	11000704 	addi	r4,r2,28
 3227ba0:	e0bffb17 	ldw	r2,-20(fp)
 3227ba4:	00c0c9b4 	movhi	r3,806
 3227ba8:	18f34504 	addi	r3,r3,-13036
 3227bac:	1085883a 	add	r2,r2,r2
 3227bb0:	1085883a 	add	r2,r2,r2
 3227bb4:	10c5883a 	add	r2,r2,r3
 3227bb8:	10800017 	ldw	r2,0(r2)
 3227bbc:	10801717 	ldw	r2,92(r2)
 3227bc0:	e0fffa17 	ldw	r3,-24(fp)
 3227bc4:	100b883a 	mov	r5,r2
 3227bc8:	180d883a 	mov	r6,r3
 3227bcc:	3206ad00 	call	3206ad0 <memcpy>

   /* return success */
   return 0;
 3227bd0:	e03ffe15 	stw	zero,-8(fp)
 3227bd4:	e0bffe17 	ldw	r2,-8(fp)
}
 3227bd8:	e037883a 	mov	sp,fp
 3227bdc:	dfc00117 	ldw	ra,4(sp)
 3227be0:	df000017 	ldw	fp,0(sp)
 3227be4:	dec00204 	addi	sp,sp,8
 3227be8:	f800283a 	ret

03227bec <dhc_discover>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_discover(int iface)
{
 3227bec:	defff404 	addi	sp,sp,-48
 3227bf0:	dfc00b15 	stw	ra,44(sp)
 3227bf4:	df000a15 	stw	fp,40(sp)
 3227bf8:	dc000915 	stw	r16,36(sp)
 3227bfc:	df000904 	addi	fp,sp,36
 3227c00:	e13ffe15 	stw	r4,-8(fp)
   u_char * opts;       /* scratch pointer to DHCP options field */
   long     leasetime;
   int      e;

   /* get a UDP packet buffer for DHCP sending */
   pkt = udp_alloc(sizeof(struct bootp), 0);
 3227c04:	01004b04 	movi	r4,300
 3227c08:	000b883a 	mov	r5,zero
 3227c0c:	32454f40 	call	32454f4 <udp_alloc>
 3227c10:	e0bffb15 	stw	r2,-20(fp)
   if (!pkt) 
 3227c14:	e0bffb17 	ldw	r2,-20(fp)
 3227c18:	1004c03a 	cmpne	r2,r2,zero
 3227c1c:	1000031e 	bne	r2,zero,3227c2c <dhc_discover+0x40>
      return ENP_NOMEM;
 3227c20:	00bffb04 	movi	r2,-20
 3227c24:	e0bfff15 	stw	r2,-4(fp)
 3227c28:	00012f06 	br	32280e8 <dhc_discover+0x4fc>
   pkt->nb_plen = sizeof(struct bootp);
 3227c2c:	e0fffb17 	ldw	r3,-20(fp)
 3227c30:	00804b04 	movi	r2,300
 3227c34:	18800415 	stw	r2,16(r3)

   /* start a new DHCP transaction */
   dhc_states[iface].xid = xids++;
 3227c38:	e0bffe17 	ldw	r2,-8(fp)
 3227c3c:	d1202f17 	ldw	r4,-32580(gp)
 3227c40:	200b883a 	mov	r5,r4
 3227c44:	00c0c9b4 	movhi	r3,806
 3227c48:	18f36b04 	addi	r3,r3,-12884
 3227c4c:	10800f24 	muli	r2,r2,60
 3227c50:	10c5883a 	add	r2,r2,r3
 3227c54:	10800204 	addi	r2,r2,8
 3227c58:	11400015 	stw	r5,0(r2)
 3227c5c:	20800044 	addi	r2,r4,1
 3227c60:	d0a02f15 	stw	r2,-32580(gp)
   dhc_states[iface].secs = (unsigned short)(sysuptime()/100L);
 3227c64:	e43ffe17 	ldw	r16,-8(fp)
 3227c68:	323cb440 	call	323cb44 <sysuptime>
 3227c6c:	1009883a 	mov	r4,r2
 3227c70:	01401904 	movi	r5,100
 3227c74:	32047c00 	call	32047c0 <__udivsi3>
 3227c78:	1009883a 	mov	r4,r2
 3227c7c:	00c0c9b4 	movhi	r3,806
 3227c80:	18f36b04 	addi	r3,r3,-12884
 3227c84:	80800f24 	muli	r2,r16,60
 3227c88:	10c5883a 	add	r2,r2,r3
 3227c8c:	10800304 	addi	r2,r2,12
 3227c90:	1100000d 	sth	r4,0(r2)

   /* set up DHCP/BOOTP header in buffer */
   outbp = (struct bootp *)pkt->nb_prot;     /* overlay bootp struct on buffer */
 3227c94:	e0bffb17 	ldw	r2,-20(fp)
 3227c98:	10800317 	ldw	r2,12(r2)
 3227c9c:	e0bffa15 	stw	r2,-24(fp)
   e = dhc_buildheader(iface,outbp);
 3227ca0:	e13ffe17 	ldw	r4,-8(fp)
 3227ca4:	e17ffa17 	ldw	r5,-24(fp)
 3227ca8:	32279d00 	call	32279d0 <dhc_buildheader>
 3227cac:	e0bff815 	stw	r2,-32(fp)
   if (e)
 3227cb0:	e0bff817 	ldw	r2,-32(fp)
 3227cb4:	1005003a 	cmpeq	r2,r2,zero
 3227cb8:	1000031e 	bne	r2,zero,3227cc8 <dhc_discover+0xdc>
      return e;
 3227cbc:	e0bff817 	ldw	r2,-32(fp)
 3227cc0:	e0bfff15 	stw	r2,-4(fp)
 3227cc4:	00010806 	br	32280e8 <dhc_discover+0x4fc>

   /* and turn it into a DHCP DISCOVER packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 3227cc8:	e0bffa17 	ldw	r2,-24(fp)
 3227ccc:	10803b04 	addi	r2,r2,236
 3227cd0:	1007883a 	mov	r3,r2
 3227cd4:	0098d534 	movhi	r2,25428
 3227cd8:	10a098c4 	addi	r2,r2,-32157
 3227cdc:	18800015 	stw	r2,0(r3)
   opts = &outbp->options[4];    /* encode options after cookie */
 3227ce0:	e0bffa17 	ldw	r2,-24(fp)
 3227ce4:	10803b04 	addi	r2,r2,236
 3227ce8:	10800104 	addi	r2,r2,4
 3227cec:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHOP_TYPE;
 3227cf0:	e0fff917 	ldw	r3,-28(fp)
 3227cf4:	00800d44 	movi	r2,53
 3227cf8:	18800005 	stb	r2,0(r3)
 3227cfc:	e0bff917 	ldw	r2,-28(fp)
 3227d00:	10800044 	addi	r2,r2,1
 3227d04:	e0bff915 	stw	r2,-28(fp)
   *opts++ = 1;   /* length of option field */
 3227d08:	e0fff917 	ldw	r3,-28(fp)
 3227d0c:	00800044 	movi	r2,1
 3227d10:	18800005 	stb	r2,0(r3)
 3227d14:	e0bff917 	ldw	r2,-28(fp)
 3227d18:	10800044 	addi	r2,r2,1
 3227d1c:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHCP_DISCOVER;
 3227d20:	e0fff917 	ldw	r3,-28(fp)
 3227d24:	00800044 	movi	r2,1
 3227d28:	18800005 	stb	r2,0(r3)
 3227d2c:	e0bff917 	ldw	r2,-28(fp)
 3227d30:	10800044 	addi	r2,r2,1
 3227d34:	e0bff915 	stw	r2,-28(fp)
   leasetime = -1L ;    /* ask for infinite lease */
 3227d38:	00bfffc4 	movi	r2,-1
 3227d3c:	e0bffc15 	stw	r2,-16(fp)
   PUT_IP_OPT(opts, DHOP_LEASE, leasetime);
 3227d40:	e0fff917 	ldw	r3,-28(fp)
 3227d44:	00800cc4 	movi	r2,51
 3227d48:	18800005 	stb	r2,0(r3)
 3227d4c:	e0bff917 	ldw	r2,-28(fp)
 3227d50:	10800044 	addi	r2,r2,1
 3227d54:	e0bff915 	stw	r2,-28(fp)
 3227d58:	e0fff917 	ldw	r3,-28(fp)
 3227d5c:	00800104 	movi	r2,4
 3227d60:	18800005 	stb	r2,0(r3)
 3227d64:	e0bff917 	ldw	r2,-28(fp)
 3227d68:	10800044 	addi	r2,r2,1
 3227d6c:	e0bff915 	stw	r2,-28(fp)
 3227d70:	e0bff917 	ldw	r2,-28(fp)
 3227d74:	10c000c4 	addi	r3,r2,3
 3227d78:	e0bffc04 	addi	r2,fp,-16
 3227d7c:	10800003 	ldbu	r2,0(r2)
 3227d80:	18800005 	stb	r2,0(r3)
 3227d84:	e0bff917 	ldw	r2,-28(fp)
 3227d88:	10c00084 	addi	r3,r2,2
 3227d8c:	e0bffc04 	addi	r2,fp,-16
 3227d90:	10800044 	addi	r2,r2,1
 3227d94:	10800003 	ldbu	r2,0(r2)
 3227d98:	18800005 	stb	r2,0(r3)
 3227d9c:	e0bff917 	ldw	r2,-28(fp)
 3227da0:	10c00044 	addi	r3,r2,1
 3227da4:	e0bffc04 	addi	r2,fp,-16
 3227da8:	10800084 	addi	r2,r2,2
 3227dac:	10800003 	ldbu	r2,0(r2)
 3227db0:	18800005 	stb	r2,0(r3)
 3227db4:	e0bffc04 	addi	r2,fp,-16
 3227db8:	108000c4 	addi	r2,r2,3
 3227dbc:	10800003 	ldbu	r2,0(r2)
 3227dc0:	1007883a 	mov	r3,r2
 3227dc4:	e0bff917 	ldw	r2,-28(fp)
 3227dc8:	10c00005 	stb	r3,0(r2)
 3227dcc:	e0bff917 	ldw	r2,-28(fp)
 3227dd0:	10800104 	addi	r2,r2,4
 3227dd4:	e0bff915 	stw	r2,-28(fp)

   /* if we already have an IP address, try to get it from the server */
   if (nets[iface]->n_ipaddr != 0)
 3227dd8:	e0bffe17 	ldw	r2,-8(fp)
 3227ddc:	00c0c9b4 	movhi	r3,806
 3227de0:	18f34504 	addi	r3,r3,-13036
 3227de4:	1085883a 	add	r2,r2,r2
 3227de8:	1085883a 	add	r2,r2,r2
 3227dec:	10c5883a 	add	r2,r2,r3
 3227df0:	10800017 	ldw	r2,0(r2)
 3227df4:	10800a17 	ldw	r2,40(r2)
 3227df8:	1005003a 	cmpeq	r2,r2,zero
 3227dfc:	1000521e 	bne	r2,zero,3227f48 <dhc_discover+0x35c>
   {
      ip_addr my_ip = htonl(nets[iface]->n_ipaddr);
 3227e00:	e0bffe17 	ldw	r2,-8(fp)
 3227e04:	00c0c9b4 	movhi	r3,806
 3227e08:	18f34504 	addi	r3,r3,-13036
 3227e0c:	1085883a 	add	r2,r2,r2
 3227e10:	1085883a 	add	r2,r2,r2
 3227e14:	10c5883a 	add	r2,r2,r3
 3227e18:	10800017 	ldw	r2,0(r2)
 3227e1c:	10800a17 	ldw	r2,40(r2)
 3227e20:	1004d63a 	srli	r2,r2,24
 3227e24:	11003fcc 	andi	r4,r2,255
 3227e28:	e0bffe17 	ldw	r2,-8(fp)
 3227e2c:	00c0c9b4 	movhi	r3,806
 3227e30:	18f34504 	addi	r3,r3,-13036
 3227e34:	1085883a 	add	r2,r2,r2
 3227e38:	1085883a 	add	r2,r2,r2
 3227e3c:	10c5883a 	add	r2,r2,r3
 3227e40:	10800017 	ldw	r2,0(r2)
 3227e44:	10800a17 	ldw	r2,40(r2)
 3227e48:	1004d23a 	srli	r2,r2,8
 3227e4c:	10bfc00c 	andi	r2,r2,65280
 3227e50:	2088b03a 	or	r4,r4,r2
 3227e54:	e0bffe17 	ldw	r2,-8(fp)
 3227e58:	00c0c9b4 	movhi	r3,806
 3227e5c:	18f34504 	addi	r3,r3,-13036
 3227e60:	1085883a 	add	r2,r2,r2
 3227e64:	1085883a 	add	r2,r2,r2
 3227e68:	10c5883a 	add	r2,r2,r3
 3227e6c:	10800017 	ldw	r2,0(r2)
 3227e70:	10800a17 	ldw	r2,40(r2)
 3227e74:	10bfc00c 	andi	r2,r2,65280
 3227e78:	1004923a 	slli	r2,r2,8
 3227e7c:	2088b03a 	or	r4,r4,r2
 3227e80:	e0bffe17 	ldw	r2,-8(fp)
 3227e84:	00c0c9b4 	movhi	r3,806
 3227e88:	18f34504 	addi	r3,r3,-13036
 3227e8c:	1085883a 	add	r2,r2,r2
 3227e90:	1085883a 	add	r2,r2,r2
 3227e94:	10c5883a 	add	r2,r2,r3
 3227e98:	10800017 	ldw	r2,0(r2)
 3227e9c:	10800a17 	ldw	r2,40(r2)
 3227ea0:	10803fcc 	andi	r2,r2,255
 3227ea4:	1004963a 	slli	r2,r2,24
 3227ea8:	2084b03a 	or	r2,r4,r2
 3227eac:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, my_ip);
 3227eb0:	e0fff917 	ldw	r3,-28(fp)
 3227eb4:	00800c84 	movi	r2,50
 3227eb8:	18800005 	stb	r2,0(r3)
 3227ebc:	e0bff917 	ldw	r2,-28(fp)
 3227ec0:	10800044 	addi	r2,r2,1
 3227ec4:	e0bff915 	stw	r2,-28(fp)
 3227ec8:	e0fff917 	ldw	r3,-28(fp)
 3227ecc:	00800104 	movi	r2,4
 3227ed0:	18800005 	stb	r2,0(r3)
 3227ed4:	e0bff917 	ldw	r2,-28(fp)
 3227ed8:	10800044 	addi	r2,r2,1
 3227edc:	e0bff915 	stw	r2,-28(fp)
 3227ee0:	e0bff917 	ldw	r2,-28(fp)
 3227ee4:	10c000c4 	addi	r3,r2,3
 3227ee8:	e0bffd04 	addi	r2,fp,-12
 3227eec:	10800003 	ldbu	r2,0(r2)
 3227ef0:	18800005 	stb	r2,0(r3)
 3227ef4:	e0bff917 	ldw	r2,-28(fp)
 3227ef8:	10c00084 	addi	r3,r2,2
 3227efc:	e0bffd04 	addi	r2,fp,-12
 3227f00:	10800044 	addi	r2,r2,1
 3227f04:	10800003 	ldbu	r2,0(r2)
 3227f08:	18800005 	stb	r2,0(r3)
 3227f0c:	e0bff917 	ldw	r2,-28(fp)
 3227f10:	10c00044 	addi	r3,r2,1
 3227f14:	e0bffd04 	addi	r2,fp,-12
 3227f18:	10800084 	addi	r2,r2,2
 3227f1c:	10800003 	ldbu	r2,0(r2)
 3227f20:	18800005 	stb	r2,0(r3)
 3227f24:	e0bffd04 	addi	r2,fp,-12
 3227f28:	108000c4 	addi	r2,r2,3
 3227f2c:	10800003 	ldbu	r2,0(r2)
 3227f30:	1007883a 	mov	r3,r2
 3227f34:	e0bff917 	ldw	r2,-28(fp)
 3227f38:	10c00005 	stb	r3,0(r2)
 3227f3c:	e0bff917 	ldw	r2,-28(fp)
 3227f40:	10800104 	addi	r2,r2,4
 3227f44:	e0bff915 	stw	r2,-28(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 3227f48:	d0a03117 	ldw	r2,-32572(gp)
 3227f4c:	10800050 	cmplti	r2,r2,1
 3227f50:	10001e1e 	bne	r2,zero,3227fcc <dhc_discover+0x3e0>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 3227f54:	e0fff917 	ldw	r3,-28(fp)
 3227f58:	00800dc4 	movi	r2,55
 3227f5c:	18800005 	stb	r2,0(r3)
 3227f60:	e0bff917 	ldw	r2,-28(fp)
 3227f64:	10800044 	addi	r2,r2,1
 3227f68:	e0bff915 	stw	r2,-28(fp)
      *opts++ = (u_char)reqlist_len ;
 3227f6c:	d0a03117 	ldw	r2,-32572(gp)
 3227f70:	1007883a 	mov	r3,r2
 3227f74:	e0bff917 	ldw	r2,-28(fp)
 3227f78:	10c00005 	stb	r3,0(r2)
 3227f7c:	e0bff917 	ldw	r2,-28(fp)
 3227f80:	10800044 	addi	r2,r2,1
 3227f84:	e0bff915 	stw	r2,-28(fp)

      for (i=0 ; i < reqlist_len ; i++ )
 3227f88:	e03ff715 	stw	zero,-36(fp)
 3227f8c:	00000c06 	br	3227fc0 <dhc_discover+0x3d4>
         *opts++ = reqlist[i];
 3227f90:	e0fff717 	ldw	r3,-36(fp)
 3227f94:	d0a03004 	addi	r2,gp,-32576
 3227f98:	1885883a 	add	r2,r3,r2
 3227f9c:	10c00003 	ldbu	r3,0(r2)
 3227fa0:	e0bff917 	ldw	r2,-28(fp)
 3227fa4:	10c00005 	stb	r3,0(r2)
 3227fa8:	e0bff917 	ldw	r2,-28(fp)
 3227fac:	10800044 	addi	r2,r2,1
 3227fb0:	e0bff915 	stw	r2,-28(fp)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 3227fb4:	e0bff717 	ldw	r2,-36(fp)
 3227fb8:	10800044 	addi	r2,r2,1
 3227fbc:	e0bff715 	stw	r2,-36(fp)
 3227fc0:	d0e03117 	ldw	r3,-32572(gp)
 3227fc4:	e0bff717 	ldw	r2,-36(fp)
 3227fc8:	10fff116 	blt	r2,r3,3227f90 <dhc_discover+0x3a4>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   *opts++ = DHOP_END;
 3227fcc:	e0fff917 	ldw	r3,-28(fp)
 3227fd0:	00bfffc4 	movi	r2,-1
 3227fd4:	18800005 	stb	r2,0(r3)
 3227fd8:	e0bff917 	ldw	r2,-28(fp)
 3227fdc:	10800044 	addi	r2,r2,1
 3227fe0:	e0bff915 	stw	r2,-28(fp)

   /* last_tick needs to be set in case we are doing a retry. It 
    * prevents dhc_second from calling us to do another retry while 
    * we are stuck 
    */
   dhc_states[iface].last_tick = cticks;
 3227fe4:	e13ffe17 	ldw	r4,-8(fp)
 3227fe8:	0080c974 	movhi	r2,805
 3227fec:	10934104 	addi	r2,r2,19716
 3227ff0:	11400017 	ldw	r5,0(r2)
 3227ff4:	00c0c9b4 	movhi	r3,806
 3227ff8:	18f36b04 	addi	r3,r3,-12884
 3227ffc:	20800f24 	muli	r2,r4,60
 3228000:	10c5883a 	add	r2,r2,r3
 3228004:	10800404 	addi	r2,r2,16
 3228008:	11400015 	stw	r5,0(r2)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast discovery request */
 322800c:	e0fffb17 	ldw	r3,-20(fp)
 3228010:	00bfffc4 	movi	r2,-1
 3228014:	18800715 	stw	r2,28(r3)
   pkt->net = nets[iface];    /* send out caller spec'ed net */
 3228018:	e0bffe17 	ldw	r2,-8(fp)
 322801c:	00c0c9b4 	movhi	r3,806
 3228020:	18f34504 	addi	r3,r3,-13036
 3228024:	1085883a 	add	r2,r2,r2
 3228028:	1085883a 	add	r2,r2,r2
 322802c:	10c5883a 	add	r2,r2,r3
 3228030:	10c00017 	ldw	r3,0(r2)
 3228034:	e0bffb17 	ldw	r2,-20(fp)
 3228038:	10c00615 	stw	r3,24(r2)

   /* we need to change the DHCP state before sending to avoid a 
    * race condition with the expected reply 
    */
   if (dhc_states[iface].state != DHCS_SELECTING)
 322803c:	e0bffe17 	ldw	r2,-8(fp)
 3228040:	00c0c9b4 	movhi	r3,806
 3228044:	18f36b04 	addi	r3,r3,-12884
 3228048:	10800f24 	muli	r2,r2,60
 322804c:	10c5883a 	add	r2,r2,r3
 3228050:	10800017 	ldw	r2,0(r2)
 3228054:	10800120 	cmpeqi	r2,r2,4
 3228058:	1000031e 	bne	r2,zero,3228068 <dhc_discover+0x47c>
      dhc_set_state(iface, DHCS_SELECTING);
 322805c:	e13ffe17 	ldw	r4,-8(fp)
 3228060:	01400104 	movi	r5,4
 3228064:	3229ea00 	call	3229ea0 <dhc_set_state>

   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 3228068:	010010c4 	movi	r4,67
 322806c:	01401104 	movi	r5,68
 3228070:	e1bffb17 	ldw	r6,-20(fp)
 3228074:	324503c0 	call	324503c <udp_send>
   dsc_discovers++;
 3228078:	d0a8c817 	ldw	r2,-23776(gp)
 322807c:	10800044 	addi	r2,r2,1
 3228080:	d0a8c815 	stw	r2,-23776(gp)

   /* state info is the same even if udp_send() failed */
   dhc_states[iface].last_tick = cticks;     /* set this again, post udp_send */
 3228084:	e13ffe17 	ldw	r4,-8(fp)
 3228088:	0080c974 	movhi	r2,805
 322808c:	10934104 	addi	r2,r2,19716
 3228090:	11400017 	ldw	r5,0(r2)
 3228094:	00c0c9b4 	movhi	r3,806
 3228098:	18f36b04 	addi	r3,r3,-12884
 322809c:	20800f24 	muli	r2,r4,60
 32280a0:	10c5883a 	add	r2,r2,r3
 32280a4:	10800404 	addi	r2,r2,16
 32280a8:	11400015 	stw	r5,0(r2)
   dhc_states[iface].tries++;
 32280ac:	e17ffe17 	ldw	r5,-8(fp)
 32280b0:	00c0c9b4 	movhi	r3,806
 32280b4:	18f36b04 	addi	r3,r3,-12884
 32280b8:	28800f24 	muli	r2,r5,60
 32280bc:	10c5883a 	add	r2,r2,r3
 32280c0:	10800104 	addi	r2,r2,4
 32280c4:	10800017 	ldw	r2,0(r2)
 32280c8:	11000044 	addi	r4,r2,1
 32280cc:	00c0c9b4 	movhi	r3,806
 32280d0:	18f36b04 	addi	r3,r3,-12884
 32280d4:	28800f24 	muli	r2,r5,60
 32280d8:	10c5883a 	add	r2,r2,r3
 32280dc:	10800104 	addi	r2,r2,4
 32280e0:	11000015 	stw	r4,0(r2)

   return 0;
 32280e4:	e03fff15 	stw	zero,-4(fp)
 32280e8:	e0bfff17 	ldw	r2,-4(fp)
}
 32280ec:	e037883a 	mov	sp,fp
 32280f0:	dfc00217 	ldw	ra,8(sp)
 32280f4:	df000117 	ldw	fp,4(sp)
 32280f8:	dc000017 	ldw	r16,0(sp)
 32280fc:	dec00304 	addi	sp,sp,12
 3228100:	f800283a 	ret

03228104 <dhc_rx_offer>:
 * RETURNS: 0 if OK, else ENP_ error
 */

int
dhc_rx_offer(int iface, struct bootp * bp, unsigned bplen)
{
 3228104:	defff804 	addi	sp,sp,-32
 3228108:	dfc00715 	stw	ra,28(sp)
 322810c:	df000615 	stw	fp,24(sp)
 3228110:	df000604 	addi	fp,sp,24
 3228114:	e13ffc15 	stw	r4,-16(fp)
 3228118:	e17ffd15 	stw	r5,-12(fp)
 322811c:	e1bffe15 	stw	r6,-8(fp)
   u_char * opts;
   int   e;

   if (dhc_states[iface].xid != bp->xid)
 3228120:	e0bffc17 	ldw	r2,-16(fp)
 3228124:	00c0c9b4 	movhi	r3,806
 3228128:	18f36b04 	addi	r3,r3,-12884
 322812c:	10800f24 	muli	r2,r2,60
 3228130:	10c5883a 	add	r2,r2,r3
 3228134:	10800204 	addi	r2,r2,8
 3228138:	10c00017 	ldw	r3,0(r2)
 322813c:	e0bffd17 	ldw	r2,-12(fp)
 3228140:	10800117 	ldw	r2,4(r2)
 3228144:	18800326 	beq	r3,r2,3228154 <dhc_rx_offer+0x50>
      return ENP_NOT_MINE;
 3228148:	00800084 	movi	r2,2
 322814c:	e0bfff15 	stw	r2,-4(fp)
 3228150:	00002706 	br	32281f0 <dhc_rx_offer+0xec>

   opts = &bp->options[4];    /* examine options after cookie */
 3228154:	e0bffd17 	ldw	r2,-12(fp)
 3228158:	10803b04 	addi	r2,r2,236
 322815c:	10800104 	addi	r2,r2,4
 3228160:	e0bffb15 	stw	r2,-20(fp)
   e = dhc_extract_opts(iface,opts);
 3228164:	e13ffc17 	ldw	r4,-16(fp)
 3228168:	e17ffb17 	ldw	r5,-20(fp)
 322816c:	322928c0 	call	322928c <dhc_extract_opts>
 3228170:	e0bffa15 	stw	r2,-24(fp)
   if (e)   /* parse error? */
 3228174:	e0bffa17 	ldw	r2,-24(fp)
 3228178:	1005003a 	cmpeq	r2,r2,zero
 322817c:	1000041e 	bne	r2,zero,3228190 <dhc_rx_offer+0x8c>
   {
      dtrap();
 3228180:	322aef00 	call	322aef0 <dtrap>
      return e;
 3228184:	e0bffa17 	ldw	r2,-24(fp)
 3228188:	e0bfff15 	stw	r2,-4(fp)
 322818c:	00001806 	br	32281f0 <dhc_rx_offer+0xec>
   }
   if (!bp->yiaddr)  /* require an IP address */
 3228190:	e0bffd17 	ldw	r2,-12(fp)
 3228194:	10800417 	ldw	r2,16(r2)
 3228198:	1004c03a 	cmpne	r2,r2,zero
 322819c:	1000071e 	bne	r2,zero,32281bc <dhc_rx_offer+0xb8>
   {
      dhc_decline(iface,bp, bplen);
 32281a0:	e13ffc17 	ldw	r4,-16(fp)
 32281a4:	e17ffd17 	ldw	r5,-12(fp)
 32281a8:	e1bffe17 	ldw	r6,-8(fp)
 32281ac:	32290a80 	call	32290a8 <dhc_decline>
      return ENP_NOT_MINE;
 32281b0:	00800084 	movi	r2,2
 32281b4:	e0bfff15 	stw	r2,-4(fp)
 32281b8:	00000d06 	br	32281f0 <dhc_rx_offer+0xec>
   }
   dhc_states[iface].ipaddr = bp->yiaddr;
 32281bc:	e13ffc17 	ldw	r4,-16(fp)
 32281c0:	e0bffd17 	ldw	r2,-12(fp)
 32281c4:	11400417 	ldw	r5,16(r2)
 32281c8:	00c0c9b4 	movhi	r3,806
 32281cc:	18f36b04 	addi	r3,r3,-12884
 32281d0:	20800f24 	muli	r2,r4,60
 32281d4:	10c5883a 	add	r2,r2,r3
 32281d8:	10800904 	addi	r2,r2,36
 32281dc:	11400015 	stw	r5,0(r2)

   /* if we got here, we must like the offer -- send a DHCP REQUEST */
   return (dhc_request(iface,FALSE));
 32281e0:	e13ffc17 	ldw	r4,-16(fp)
 32281e4:	000b883a 	mov	r5,zero
 32281e8:	32282080 	call	3228208 <dhc_request>
 32281ec:	e0bfff15 	stw	r2,-4(fp)
 32281f0:	e0bfff17 	ldw	r2,-4(fp)
}
 32281f4:	e037883a 	mov	sp,fp
 32281f8:	dfc00117 	ldw	ra,4(sp)
 32281fc:	df000017 	ldw	fp,0(sp)
 3228200:	dec00204 	addi	sp,sp,8
 3228204:	f800283a 	ret

03228208 <dhc_request>:
 * RETURNS:  Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_request(int iface,int xid_flag)
{
 3228208:	defff304 	addi	sp,sp,-52
 322820c:	dfc00c15 	stw	ra,48(sp)
 3228210:	df000b15 	stw	fp,44(sp)
 3228214:	df000b04 	addi	fp,sp,44
 3228218:	e13ffd15 	stw	r4,-12(fp)
 322821c:	e17ffe15 	stw	r5,-8(fp)
   u_char  *   opts; /* scratch pointer to DHCP options field */
   ip_addr opt_ip;      /* IP address temporary */
   int      e;       /* error holder */

   /* get a UDP packet buffer for sending DHCP request */
   pkt = udp_alloc(sizeof(struct bootp) + DHCP_OPTSIZE - BOOTP_OPTSIZE, 0);
 3228220:	01008904 	movi	r4,548
 3228224:	000b883a 	mov	r5,zero
 3228228:	32454f40 	call	32454f4 <udp_alloc>
 322822c:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 3228230:	e0bffa17 	ldw	r2,-24(fp)
 3228234:	1004c03a 	cmpne	r2,r2,zero
 3228238:	1000031e 	bne	r2,zero,3228248 <dhc_request+0x40>
      return ENP_NOMEM;
 322823c:	00bffb04 	movi	r2,-20
 3228240:	e0bfff15 	stw	r2,-4(fp)
 3228244:	0002b906 	br	3228d2c <dhc_request+0xb24>
   pkt->nb_plen = sizeof(struct bootp) - BOOTP_OPTSIZE;
 3228248:	e0fffa17 	ldw	r3,-24(fp)
 322824c:	00803b04 	movi	r2,236
 3228250:	18800415 	stw	r2,16(r3)

   if ( xid_flag == TRUE )
 3228254:	e0bffe17 	ldw	r2,-8(fp)
 3228258:	10800058 	cmpnei	r2,r2,1
 322825c:	1000121e 	bne	r2,zero,32282a8 <dhc_request+0xa0>
   {
      dhc_states[iface].xid  = xids++;
 3228260:	e0bffd17 	ldw	r2,-12(fp)
 3228264:	d1202f17 	ldw	r4,-32580(gp)
 3228268:	200b883a 	mov	r5,r4
 322826c:	00c0c9b4 	movhi	r3,806
 3228270:	18f36b04 	addi	r3,r3,-12884
 3228274:	10800f24 	muli	r2,r2,60
 3228278:	10c5883a 	add	r2,r2,r3
 322827c:	10800204 	addi	r2,r2,8
 3228280:	11400015 	stw	r5,0(r2)
 3228284:	20800044 	addi	r2,r4,1
 3228288:	d0a02f15 	stw	r2,-32580(gp)
      dhc_states[iface].secs = 0;
 322828c:	e0bffd17 	ldw	r2,-12(fp)
 3228290:	00c0c9b4 	movhi	r3,806
 3228294:	18f36b04 	addi	r3,r3,-12884
 3228298:	10800f24 	muli	r2,r2,60
 322829c:	10c5883a 	add	r2,r2,r3
 32282a0:	10800304 	addi	r2,r2,12
 32282a4:	1000000d 	sth	zero,0(r2)
   }

   /* build a BOOTP request header */
   outbp = (struct bootp *)pkt->nb_prot;
 32282a8:	e0bffa17 	ldw	r2,-24(fp)
 32282ac:	10800317 	ldw	r2,12(r2)
 32282b0:	e0bffb15 	stw	r2,-20(fp)
   e     = dhc_buildheader(iface,outbp);
 32282b4:	e13ffd17 	ldw	r4,-12(fp)
 32282b8:	e17ffb17 	ldw	r5,-20(fp)
 32282bc:	32279d00 	call	32279d0 <dhc_buildheader>
 32282c0:	e0bff815 	stw	r2,-32(fp)
   if (e)
 32282c4:	e0bff817 	ldw	r2,-32(fp)
 32282c8:	1005003a 	cmpeq	r2,r2,zero
 32282cc:	1000031e 	bne	r2,zero,32282dc <dhc_request+0xd4>
      return e;
 32282d0:	e0bff817 	ldw	r2,-32(fp)
 32282d4:	e0bfff15 	stw	r2,-4(fp)
 32282d8:	00029406 	br	3228d2c <dhc_request+0xb24>

   /* turn it into a DHCP REQUEST packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 32282dc:	e0bffb17 	ldw	r2,-20(fp)
 32282e0:	10803b04 	addi	r2,r2,236
 32282e4:	1007883a 	mov	r3,r2
 32282e8:	0098d534 	movhi	r2,25428
 32282ec:	10a098c4 	addi	r2,r2,-32157
 32282f0:	18800015 	stw	r2,0(r3)
   opts    = &outbp->options[4];    /* encode options after cookie */
 32282f4:	e0bffb17 	ldw	r2,-20(fp)
 32282f8:	10803b04 	addi	r2,r2,236
 32282fc:	10800104 	addi	r2,r2,4
 3228300:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHOP_TYPE;
 3228304:	e0fff917 	ldw	r3,-28(fp)
 3228308:	00800d44 	movi	r2,53
 322830c:	18800005 	stb	r2,0(r3)
 3228310:	e0bff917 	ldw	r2,-28(fp)
 3228314:	10800044 	addi	r2,r2,1
 3228318:	e0bff915 	stw	r2,-28(fp)
   *opts++ = 1;   /* length of option field */
 322831c:	e0fff917 	ldw	r3,-28(fp)
 3228320:	00800044 	movi	r2,1
 3228324:	18800005 	stb	r2,0(r3)
 3228328:	e0bff917 	ldw	r2,-28(fp)
 322832c:	10800044 	addi	r2,r2,1
 3228330:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHCP_REQUEST;
 3228334:	e0fff917 	ldw	r3,-28(fp)
 3228338:	008000c4 	movi	r2,3
 322833c:	18800005 	stb	r2,0(r3)
 3228340:	e0bff917 	ldw	r2,-28(fp)
 3228344:	10800044 	addi	r2,r2,1
 3228348:	e0bff915 	stw	r2,-28(fp)

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 322834c:	e0bffd17 	ldw	r2,-12(fp)
 3228350:	00c0c9b4 	movhi	r3,806
 3228354:	18f36b04 	addi	r3,r3,-12884
 3228358:	10800f24 	muli	r2,r2,60
 322835c:	10c5883a 	add	r2,r2,r3
 3228360:	10800017 	ldw	r2,0(r2)
 3228364:	10800120 	cmpeqi	r2,r2,4
 3228368:	1000181e 	bne	r2,zero,32283cc <dhc_request+0x1c4>
 322836c:	e0bffd17 	ldw	r2,-12(fp)
 3228370:	00c0c9b4 	movhi	r3,806
 3228374:	18f36b04 	addi	r3,r3,-12884
 3228378:	10800f24 	muli	r2,r2,60
 322837c:	10c5883a 	add	r2,r2,r3
 3228380:	10800017 	ldw	r2,0(r2)
 3228384:	10800160 	cmpeqi	r2,r2,5
 3228388:	1000101e 	bne	r2,zero,32283cc <dhc_request+0x1c4>
 322838c:	e0bffd17 	ldw	r2,-12(fp)
 3228390:	00c0c9b4 	movhi	r3,806
 3228394:	18f36b04 	addi	r3,r3,-12884
 3228398:	10800f24 	muli	r2,r2,60
 322839c:	10c5883a 	add	r2,r2,r3
 32283a0:	10800017 	ldw	r2,0(r2)
 32283a4:	108000e0 	cmpeqi	r2,r2,3
 32283a8:	1000081e 	bne	r2,zero,32283cc <dhc_request+0x1c4>
 32283ac:	e0bffd17 	ldw	r2,-12(fp)
 32283b0:	00c0c9b4 	movhi	r3,806
 32283b4:	18f36b04 	addi	r3,r3,-12884
 32283b8:	10800f24 	muli	r2,r2,60
 32283bc:	10c5883a 	add	r2,r2,r3
 32283c0:	10800017 	ldw	r2,0(r2)
 32283c4:	10800098 	cmpnei	r2,r2,2
 32283c8:	10004e1e 	bne	r2,zero,3228504 <dhc_request+0x2fc>
       (dhc_states[iface].state == DHCS_REQUESTING) ||
       (dhc_states[iface].state == DHCS_REBOOTING) ||
       (dhc_states[iface].state == DHCS_INITREBOOT))
   {
      opt_ip = ntohl(dhc_states[iface].ipaddr);
 32283cc:	e0bffd17 	ldw	r2,-12(fp)
 32283d0:	00c0c9b4 	movhi	r3,806
 32283d4:	18f36b04 	addi	r3,r3,-12884
 32283d8:	10800f24 	muli	r2,r2,60
 32283dc:	10c5883a 	add	r2,r2,r3
 32283e0:	10800904 	addi	r2,r2,36
 32283e4:	10800017 	ldw	r2,0(r2)
 32283e8:	1004d63a 	srli	r2,r2,24
 32283ec:	11003fcc 	andi	r4,r2,255
 32283f0:	e0bffd17 	ldw	r2,-12(fp)
 32283f4:	00c0c9b4 	movhi	r3,806
 32283f8:	18f36b04 	addi	r3,r3,-12884
 32283fc:	10800f24 	muli	r2,r2,60
 3228400:	10c5883a 	add	r2,r2,r3
 3228404:	10800904 	addi	r2,r2,36
 3228408:	10800017 	ldw	r2,0(r2)
 322840c:	1004d23a 	srli	r2,r2,8
 3228410:	10bfc00c 	andi	r2,r2,65280
 3228414:	2088b03a 	or	r4,r4,r2
 3228418:	e0bffd17 	ldw	r2,-12(fp)
 322841c:	00c0c9b4 	movhi	r3,806
 3228420:	18f36b04 	addi	r3,r3,-12884
 3228424:	10800f24 	muli	r2,r2,60
 3228428:	10c5883a 	add	r2,r2,r3
 322842c:	10800904 	addi	r2,r2,36
 3228430:	10800017 	ldw	r2,0(r2)
 3228434:	10bfc00c 	andi	r2,r2,65280
 3228438:	1004923a 	slli	r2,r2,8
 322843c:	2088b03a 	or	r4,r4,r2
 3228440:	e0bffd17 	ldw	r2,-12(fp)
 3228444:	00c0c9b4 	movhi	r3,806
 3228448:	18f36b04 	addi	r3,r3,-12884
 322844c:	10800f24 	muli	r2,r2,60
 3228450:	10c5883a 	add	r2,r2,r3
 3228454:	10800904 	addi	r2,r2,36
 3228458:	10800017 	ldw	r2,0(r2)
 322845c:	10803fcc 	andi	r2,r2,255
 3228460:	1004963a 	slli	r2,r2,24
 3228464:	2084b03a 	or	r2,r4,r2
 3228468:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, opt_ip);
 322846c:	e0fff917 	ldw	r3,-28(fp)
 3228470:	00800c84 	movi	r2,50
 3228474:	18800005 	stb	r2,0(r3)
 3228478:	e0bff917 	ldw	r2,-28(fp)
 322847c:	10800044 	addi	r2,r2,1
 3228480:	e0bff915 	stw	r2,-28(fp)
 3228484:	e0fff917 	ldw	r3,-28(fp)
 3228488:	00800104 	movi	r2,4
 322848c:	18800005 	stb	r2,0(r3)
 3228490:	e0bff917 	ldw	r2,-28(fp)
 3228494:	10800044 	addi	r2,r2,1
 3228498:	e0bff915 	stw	r2,-28(fp)
 322849c:	e0bff917 	ldw	r2,-28(fp)
 32284a0:	10c000c4 	addi	r3,r2,3
 32284a4:	e0bffc04 	addi	r2,fp,-16
 32284a8:	10800003 	ldbu	r2,0(r2)
 32284ac:	18800005 	stb	r2,0(r3)
 32284b0:	e0bff917 	ldw	r2,-28(fp)
 32284b4:	10c00084 	addi	r3,r2,2
 32284b8:	e0bffc04 	addi	r2,fp,-16
 32284bc:	10800044 	addi	r2,r2,1
 32284c0:	10800003 	ldbu	r2,0(r2)
 32284c4:	18800005 	stb	r2,0(r3)
 32284c8:	e0bff917 	ldw	r2,-28(fp)
 32284cc:	10c00044 	addi	r3,r2,1
 32284d0:	e0bffc04 	addi	r2,fp,-16
 32284d4:	10800084 	addi	r2,r2,2
 32284d8:	10800003 	ldbu	r2,0(r2)
 32284dc:	18800005 	stb	r2,0(r3)
 32284e0:	e0bffc04 	addi	r2,fp,-16
 32284e4:	108000c4 	addi	r2,r2,3
 32284e8:	10800003 	ldbu	r2,0(r2)
 32284ec:	1007883a 	mov	r3,r2
 32284f0:	e0bff917 	ldw	r2,-28(fp)
 32284f4:	10c00005 	stb	r3,0(r2)
 32284f8:	e0bff917 	ldw	r2,-28(fp)
 32284fc:	10800104 	addi	r2,r2,4
 3228500:	e0bff915 	stw	r2,-28(fp)
   }
   if (dhc_states[iface].snmask)
 3228504:	e0bffd17 	ldw	r2,-12(fp)
 3228508:	00c0c9b4 	movhi	r3,806
 322850c:	18f36b04 	addi	r3,r3,-12884
 3228510:	10800f24 	muli	r2,r2,60
 3228514:	10c5883a 	add	r2,r2,r3
 3228518:	10800a04 	addi	r2,r2,40
 322851c:	10800017 	ldw	r2,0(r2)
 3228520:	1005003a 	cmpeq	r2,r2,zero
 3228524:	10004e1e 	bne	r2,zero,3228660 <dhc_request+0x458>
   {
      opt_ip = ntohl(dhc_states[iface].snmask);
 3228528:	e0bffd17 	ldw	r2,-12(fp)
 322852c:	00c0c9b4 	movhi	r3,806
 3228530:	18f36b04 	addi	r3,r3,-12884
 3228534:	10800f24 	muli	r2,r2,60
 3228538:	10c5883a 	add	r2,r2,r3
 322853c:	10800a04 	addi	r2,r2,40
 3228540:	10800017 	ldw	r2,0(r2)
 3228544:	1004d63a 	srli	r2,r2,24
 3228548:	11003fcc 	andi	r4,r2,255
 322854c:	e0bffd17 	ldw	r2,-12(fp)
 3228550:	00c0c9b4 	movhi	r3,806
 3228554:	18f36b04 	addi	r3,r3,-12884
 3228558:	10800f24 	muli	r2,r2,60
 322855c:	10c5883a 	add	r2,r2,r3
 3228560:	10800a04 	addi	r2,r2,40
 3228564:	10800017 	ldw	r2,0(r2)
 3228568:	1004d23a 	srli	r2,r2,8
 322856c:	10bfc00c 	andi	r2,r2,65280
 3228570:	2088b03a 	or	r4,r4,r2
 3228574:	e0bffd17 	ldw	r2,-12(fp)
 3228578:	00c0c9b4 	movhi	r3,806
 322857c:	18f36b04 	addi	r3,r3,-12884
 3228580:	10800f24 	muli	r2,r2,60
 3228584:	10c5883a 	add	r2,r2,r3
 3228588:	10800a04 	addi	r2,r2,40
 322858c:	10800017 	ldw	r2,0(r2)
 3228590:	10bfc00c 	andi	r2,r2,65280
 3228594:	1004923a 	slli	r2,r2,8
 3228598:	2088b03a 	or	r4,r4,r2
 322859c:	e0bffd17 	ldw	r2,-12(fp)
 32285a0:	00c0c9b4 	movhi	r3,806
 32285a4:	18f36b04 	addi	r3,r3,-12884
 32285a8:	10800f24 	muli	r2,r2,60
 32285ac:	10c5883a 	add	r2,r2,r3
 32285b0:	10800a04 	addi	r2,r2,40
 32285b4:	10800017 	ldw	r2,0(r2)
 32285b8:	10803fcc 	andi	r2,r2,255
 32285bc:	1004963a 	slli	r2,r2,24
 32285c0:	2084b03a 	or	r2,r4,r2
 32285c4:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_SNMASK, opt_ip);
 32285c8:	e0fff917 	ldw	r3,-28(fp)
 32285cc:	00800044 	movi	r2,1
 32285d0:	18800005 	stb	r2,0(r3)
 32285d4:	e0bff917 	ldw	r2,-28(fp)
 32285d8:	10800044 	addi	r2,r2,1
 32285dc:	e0bff915 	stw	r2,-28(fp)
 32285e0:	e0fff917 	ldw	r3,-28(fp)
 32285e4:	00800104 	movi	r2,4
 32285e8:	18800005 	stb	r2,0(r3)
 32285ec:	e0bff917 	ldw	r2,-28(fp)
 32285f0:	10800044 	addi	r2,r2,1
 32285f4:	e0bff915 	stw	r2,-28(fp)
 32285f8:	e0bff917 	ldw	r2,-28(fp)
 32285fc:	10c000c4 	addi	r3,r2,3
 3228600:	e0bffc04 	addi	r2,fp,-16
 3228604:	10800003 	ldbu	r2,0(r2)
 3228608:	18800005 	stb	r2,0(r3)
 322860c:	e0bff917 	ldw	r2,-28(fp)
 3228610:	10c00084 	addi	r3,r2,2
 3228614:	e0bffc04 	addi	r2,fp,-16
 3228618:	10800044 	addi	r2,r2,1
 322861c:	10800003 	ldbu	r2,0(r2)
 3228620:	18800005 	stb	r2,0(r3)
 3228624:	e0bff917 	ldw	r2,-28(fp)
 3228628:	10c00044 	addi	r3,r2,1
 322862c:	e0bffc04 	addi	r2,fp,-16
 3228630:	10800084 	addi	r2,r2,2
 3228634:	10800003 	ldbu	r2,0(r2)
 3228638:	18800005 	stb	r2,0(r3)
 322863c:	e0bffc04 	addi	r2,fp,-16
 3228640:	108000c4 	addi	r2,r2,3
 3228644:	10800003 	ldbu	r2,0(r2)
 3228648:	1007883a 	mov	r3,r2
 322864c:	e0bff917 	ldw	r2,-28(fp)
 3228650:	10c00005 	stb	r3,0(r2)
 3228654:	e0bff917 	ldw	r2,-28(fp)
 3228658:	10800104 	addi	r2,r2,4
 322865c:	e0bff915 	stw	r2,-28(fp)
   }
   if (dhc_states[iface].defgw)
 3228660:	e0bffd17 	ldw	r2,-12(fp)
 3228664:	00c0c9b4 	movhi	r3,806
 3228668:	18f36b04 	addi	r3,r3,-12884
 322866c:	10800f24 	muli	r2,r2,60
 3228670:	10c5883a 	add	r2,r2,r3
 3228674:	10800b04 	addi	r2,r2,44
 3228678:	10800017 	ldw	r2,0(r2)
 322867c:	1005003a 	cmpeq	r2,r2,zero
 3228680:	10004e1e 	bne	r2,zero,32287bc <dhc_request+0x5b4>
   {
      opt_ip = ntohl(dhc_states[iface].defgw);
 3228684:	e0bffd17 	ldw	r2,-12(fp)
 3228688:	00c0c9b4 	movhi	r3,806
 322868c:	18f36b04 	addi	r3,r3,-12884
 3228690:	10800f24 	muli	r2,r2,60
 3228694:	10c5883a 	add	r2,r2,r3
 3228698:	10800b04 	addi	r2,r2,44
 322869c:	10800017 	ldw	r2,0(r2)
 32286a0:	1004d63a 	srli	r2,r2,24
 32286a4:	11003fcc 	andi	r4,r2,255
 32286a8:	e0bffd17 	ldw	r2,-12(fp)
 32286ac:	00c0c9b4 	movhi	r3,806
 32286b0:	18f36b04 	addi	r3,r3,-12884
 32286b4:	10800f24 	muli	r2,r2,60
 32286b8:	10c5883a 	add	r2,r2,r3
 32286bc:	10800b04 	addi	r2,r2,44
 32286c0:	10800017 	ldw	r2,0(r2)
 32286c4:	1004d23a 	srli	r2,r2,8
 32286c8:	10bfc00c 	andi	r2,r2,65280
 32286cc:	2088b03a 	or	r4,r4,r2
 32286d0:	e0bffd17 	ldw	r2,-12(fp)
 32286d4:	00c0c9b4 	movhi	r3,806
 32286d8:	18f36b04 	addi	r3,r3,-12884
 32286dc:	10800f24 	muli	r2,r2,60
 32286e0:	10c5883a 	add	r2,r2,r3
 32286e4:	10800b04 	addi	r2,r2,44
 32286e8:	10800017 	ldw	r2,0(r2)
 32286ec:	10bfc00c 	andi	r2,r2,65280
 32286f0:	1004923a 	slli	r2,r2,8
 32286f4:	2088b03a 	or	r4,r4,r2
 32286f8:	e0bffd17 	ldw	r2,-12(fp)
 32286fc:	00c0c9b4 	movhi	r3,806
 3228700:	18f36b04 	addi	r3,r3,-12884
 3228704:	10800f24 	muli	r2,r2,60
 3228708:	10c5883a 	add	r2,r2,r3
 322870c:	10800b04 	addi	r2,r2,44
 3228710:	10800017 	ldw	r2,0(r2)
 3228714:	10803fcc 	andi	r2,r2,255
 3228718:	1004963a 	slli	r2,r2,24
 322871c:	2084b03a 	or	r2,r4,r2
 3228720:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_ROUTER, opt_ip);
 3228724:	e0fff917 	ldw	r3,-28(fp)
 3228728:	008000c4 	movi	r2,3
 322872c:	18800005 	stb	r2,0(r3)
 3228730:	e0bff917 	ldw	r2,-28(fp)
 3228734:	10800044 	addi	r2,r2,1
 3228738:	e0bff915 	stw	r2,-28(fp)
 322873c:	e0fff917 	ldw	r3,-28(fp)
 3228740:	00800104 	movi	r2,4
 3228744:	18800005 	stb	r2,0(r3)
 3228748:	e0bff917 	ldw	r2,-28(fp)
 322874c:	10800044 	addi	r2,r2,1
 3228750:	e0bff915 	stw	r2,-28(fp)
 3228754:	e0bff917 	ldw	r2,-28(fp)
 3228758:	10c000c4 	addi	r3,r2,3
 322875c:	e0bffc04 	addi	r2,fp,-16
 3228760:	10800003 	ldbu	r2,0(r2)
 3228764:	18800005 	stb	r2,0(r3)
 3228768:	e0bff917 	ldw	r2,-28(fp)
 322876c:	10c00084 	addi	r3,r2,2
 3228770:	e0bffc04 	addi	r2,fp,-16
 3228774:	10800044 	addi	r2,r2,1
 3228778:	10800003 	ldbu	r2,0(r2)
 322877c:	18800005 	stb	r2,0(r3)
 3228780:	e0bff917 	ldw	r2,-28(fp)
 3228784:	10c00044 	addi	r3,r2,1
 3228788:	e0bffc04 	addi	r2,fp,-16
 322878c:	10800084 	addi	r2,r2,2
 3228790:	10800003 	ldbu	r2,0(r2)
 3228794:	18800005 	stb	r2,0(r3)
 3228798:	e0bffc04 	addi	r2,fp,-16
 322879c:	108000c4 	addi	r2,r2,3
 32287a0:	10800003 	ldbu	r2,0(r2)
 32287a4:	1007883a 	mov	r3,r2
 32287a8:	e0bff917 	ldw	r2,-28(fp)
 32287ac:	10c00005 	stb	r3,0(r2)
 32287b0:	e0bff917 	ldw	r2,-28(fp)
 32287b4:	10800104 	addi	r2,r2,4
 32287b8:	e0bff915 	stw	r2,-28(fp)
         }
      }
   }
#endif

   if (dhc_states[iface].lease)
 32287bc:	e0bffd17 	ldw	r2,-12(fp)
 32287c0:	00c0c9b4 	movhi	r3,806
 32287c4:	18f36b04 	addi	r3,r3,-12884
 32287c8:	10800f24 	muli	r2,r2,60
 32287cc:	10c5883a 	add	r2,r2,r3
 32287d0:	10800504 	addi	r2,r2,20
 32287d4:	10800017 	ldw	r2,0(r2)
 32287d8:	1005003a 	cmpeq	r2,r2,zero
 32287dc:	10003a1e 	bne	r2,zero,32288c8 <dhc_request+0x6c0>
   {
      PUT_IP_OPT(opts, DHOP_LEASE, dhc_states[iface].lease);
 32287e0:	e0fff917 	ldw	r3,-28(fp)
 32287e4:	00800cc4 	movi	r2,51
 32287e8:	18800005 	stb	r2,0(r3)
 32287ec:	e0bff917 	ldw	r2,-28(fp)
 32287f0:	10800044 	addi	r2,r2,1
 32287f4:	e0bff915 	stw	r2,-28(fp)
 32287f8:	e0fff917 	ldw	r3,-28(fp)
 32287fc:	00800104 	movi	r2,4
 3228800:	18800005 	stb	r2,0(r3)
 3228804:	e0bff917 	ldw	r2,-28(fp)
 3228808:	10800044 	addi	r2,r2,1
 322880c:	e0bff915 	stw	r2,-28(fp)
 3228810:	e0bff917 	ldw	r2,-28(fp)
 3228814:	110000c4 	addi	r4,r2,3
 3228818:	e0bffd17 	ldw	r2,-12(fp)
 322881c:	10800f24 	muli	r2,r2,60
 3228820:	10c00504 	addi	r3,r2,20
 3228824:	0080c9b4 	movhi	r2,806
 3228828:	10b36b04 	addi	r2,r2,-12884
 322882c:	1885883a 	add	r2,r3,r2
 3228830:	10800003 	ldbu	r2,0(r2)
 3228834:	20800005 	stb	r2,0(r4)
 3228838:	e0bff917 	ldw	r2,-28(fp)
 322883c:	11000084 	addi	r4,r2,2
 3228840:	e0bffd17 	ldw	r2,-12(fp)
 3228844:	10800f24 	muli	r2,r2,60
 3228848:	10c00504 	addi	r3,r2,20
 322884c:	0080c9b4 	movhi	r2,806
 3228850:	10b36b04 	addi	r2,r2,-12884
 3228854:	1885883a 	add	r2,r3,r2
 3228858:	10800044 	addi	r2,r2,1
 322885c:	10800003 	ldbu	r2,0(r2)
 3228860:	20800005 	stb	r2,0(r4)
 3228864:	e0bff917 	ldw	r2,-28(fp)
 3228868:	11000044 	addi	r4,r2,1
 322886c:	e0bffd17 	ldw	r2,-12(fp)
 3228870:	10800f24 	muli	r2,r2,60
 3228874:	10c00504 	addi	r3,r2,20
 3228878:	0080c9b4 	movhi	r2,806
 322887c:	10b36b04 	addi	r2,r2,-12884
 3228880:	1885883a 	add	r2,r3,r2
 3228884:	10800084 	addi	r2,r2,2
 3228888:	10800003 	ldbu	r2,0(r2)
 322888c:	20800005 	stb	r2,0(r4)
 3228890:	e0bffd17 	ldw	r2,-12(fp)
 3228894:	10800f24 	muli	r2,r2,60
 3228898:	10c00504 	addi	r3,r2,20
 322889c:	0080c9b4 	movhi	r2,806
 32288a0:	10b36b04 	addi	r2,r2,-12884
 32288a4:	1885883a 	add	r2,r3,r2
 32288a8:	108000c4 	addi	r2,r2,3
 32288ac:	10800003 	ldbu	r2,0(r2)
 32288b0:	1007883a 	mov	r3,r2
 32288b4:	e0bff917 	ldw	r2,-28(fp)
 32288b8:	10c00005 	stb	r3,0(r2)
 32288bc:	e0bff917 	ldw	r2,-28(fp)
 32288c0:	10800104 	addi	r2,r2,4
 32288c4:	e0bff915 	stw	r2,-28(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 32288c8:	d0a03117 	ldw	r2,-32572(gp)
 32288cc:	10800050 	cmplti	r2,r2,1
 32288d0:	10001e1e 	bne	r2,zero,322894c <dhc_request+0x744>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 32288d4:	e0fff917 	ldw	r3,-28(fp)
 32288d8:	00800dc4 	movi	r2,55
 32288dc:	18800005 	stb	r2,0(r3)
 32288e0:	e0bff917 	ldw	r2,-28(fp)
 32288e4:	10800044 	addi	r2,r2,1
 32288e8:	e0bff915 	stw	r2,-28(fp)
      *opts++ = (u_char)reqlist_len ;
 32288ec:	d0a03117 	ldw	r2,-32572(gp)
 32288f0:	1007883a 	mov	r3,r2
 32288f4:	e0bff917 	ldw	r2,-28(fp)
 32288f8:	10c00005 	stb	r3,0(r2)
 32288fc:	e0bff917 	ldw	r2,-28(fp)
 3228900:	10800044 	addi	r2,r2,1
 3228904:	e0bff915 	stw	r2,-28(fp)

      for (i=0 ; i < reqlist_len ; i++ )
 3228908:	e03ff715 	stw	zero,-36(fp)
 322890c:	00000c06 	br	3228940 <dhc_request+0x738>
         *opts++ = reqlist[i];
 3228910:	e0fff717 	ldw	r3,-36(fp)
 3228914:	d0a03004 	addi	r2,gp,-32576
 3228918:	1885883a 	add	r2,r3,r2
 322891c:	10c00003 	ldbu	r3,0(r2)
 3228920:	e0bff917 	ldw	r2,-28(fp)
 3228924:	10c00005 	stb	r3,0(r2)
 3228928:	e0bff917 	ldw	r2,-28(fp)
 322892c:	10800044 	addi	r2,r2,1
 3228930:	e0bff915 	stw	r2,-28(fp)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 3228934:	e0bff717 	ldw	r2,-36(fp)
 3228938:	10800044 	addi	r2,r2,1
 322893c:	e0bff715 	stw	r2,-36(fp)
 3228940:	d0e03117 	ldw	r3,-32572(gp)
 3228944:	e0bff717 	ldw	r2,-36(fp)
 3228948:	10fff116 	blt	r2,r3,3228910 <dhc_request+0x708>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   /* only set client IP address (ours) when renewing or rebinding */
   if ((dhc_states[iface].state == DHCS_RENEWING)
 322894c:	e0bffd17 	ldw	r2,-12(fp)
 3228950:	00c0c9b4 	movhi	r3,806
 3228954:	18f36b04 	addi	r3,r3,-12884
 3228958:	10800f24 	muli	r2,r2,60
 322895c:	10c5883a 	add	r2,r2,r3
 3228960:	10800017 	ldw	r2,0(r2)
 3228964:	108001e0 	cmpeqi	r2,r2,7
 3228968:	1000081e 	bne	r2,zero,322898c <dhc_request+0x784>
 322896c:	e0bffd17 	ldw	r2,-12(fp)
 3228970:	00c0c9b4 	movhi	r3,806
 3228974:	18f36b04 	addi	r3,r3,-12884
 3228978:	10800f24 	muli	r2,r2,60
 322897c:	10c5883a 	add	r2,r2,r3
 3228980:	10800017 	ldw	r2,0(r2)
 3228984:	10800218 	cmpnei	r2,r2,8
 3228988:	10000a1e 	bne	r2,zero,32289b4 <dhc_request+0x7ac>
       || (dhc_states[iface].state == DHCS_REBINDING))
   {
      outbp->ciaddr = nets[iface]->n_ipaddr;
 322898c:	e0bffd17 	ldw	r2,-12(fp)
 3228990:	00c0c9b4 	movhi	r3,806
 3228994:	18f34504 	addi	r3,r3,-13036
 3228998:	1085883a 	add	r2,r2,r2
 322899c:	1085883a 	add	r2,r2,r2
 32289a0:	10c5883a 	add	r2,r2,r3
 32289a4:	10800017 	ldw	r2,0(r2)
 32289a8:	10c00a17 	ldw	r3,40(r2)
 32289ac:	e0bffb17 	ldw	r2,-20(fp)
 32289b0:	10c00315 	stw	r3,12(r2)
    * "Client inserts the address of the selected server in 'server 
    * identifier'. . . ." RFC 951, p. 4 definition of 'siaddr' is 
    * "server IP address; returned in bootreply by server." 
    */
   /* Only include server identifier option when selecting a server. */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 32289b4:	e0bffd17 	ldw	r2,-12(fp)
 32289b8:	00c0c9b4 	movhi	r3,806
 32289bc:	18f36b04 	addi	r3,r3,-12884
 32289c0:	10800f24 	muli	r2,r2,60
 32289c4:	10c5883a 	add	r2,r2,r3
 32289c8:	10800017 	ldw	r2,0(r2)
 32289cc:	10800120 	cmpeqi	r2,r2,4
 32289d0:	1000081e 	bne	r2,zero,32289f4 <dhc_request+0x7ec>
 32289d4:	e0bffd17 	ldw	r2,-12(fp)
 32289d8:	00c0c9b4 	movhi	r3,806
 32289dc:	18f36b04 	addi	r3,r3,-12884
 32289e0:	10800f24 	muli	r2,r2,60
 32289e4:	10c5883a 	add	r2,r2,r3
 32289e8:	10800017 	ldw	r2,0(r2)
 32289ec:	10800158 	cmpnei	r2,r2,5
 32289f0:	10004e1e 	bne	r2,zero,3228b2c <dhc_request+0x924>
       (dhc_states[iface].state == DHCS_REQUESTING))
   {
      opt_ip = ntohl(dhc_states[iface].srv_ipaddr);
 32289f4:	e0bffd17 	ldw	r2,-12(fp)
 32289f8:	00c0c9b4 	movhi	r3,806
 32289fc:	18f36b04 	addi	r3,r3,-12884
 3228a00:	10800f24 	muli	r2,r2,60
 3228a04:	10c5883a 	add	r2,r2,r3
 3228a08:	10800d04 	addi	r2,r2,52
 3228a0c:	10800017 	ldw	r2,0(r2)
 3228a10:	1004d63a 	srli	r2,r2,24
 3228a14:	11003fcc 	andi	r4,r2,255
 3228a18:	e0bffd17 	ldw	r2,-12(fp)
 3228a1c:	00c0c9b4 	movhi	r3,806
 3228a20:	18f36b04 	addi	r3,r3,-12884
 3228a24:	10800f24 	muli	r2,r2,60
 3228a28:	10c5883a 	add	r2,r2,r3
 3228a2c:	10800d04 	addi	r2,r2,52
 3228a30:	10800017 	ldw	r2,0(r2)
 3228a34:	1004d23a 	srli	r2,r2,8
 3228a38:	10bfc00c 	andi	r2,r2,65280
 3228a3c:	2088b03a 	or	r4,r4,r2
 3228a40:	e0bffd17 	ldw	r2,-12(fp)
 3228a44:	00c0c9b4 	movhi	r3,806
 3228a48:	18f36b04 	addi	r3,r3,-12884
 3228a4c:	10800f24 	muli	r2,r2,60
 3228a50:	10c5883a 	add	r2,r2,r3
 3228a54:	10800d04 	addi	r2,r2,52
 3228a58:	10800017 	ldw	r2,0(r2)
 3228a5c:	10bfc00c 	andi	r2,r2,65280
 3228a60:	1004923a 	slli	r2,r2,8
 3228a64:	2088b03a 	or	r4,r4,r2
 3228a68:	e0bffd17 	ldw	r2,-12(fp)
 3228a6c:	00c0c9b4 	movhi	r3,806
 3228a70:	18f36b04 	addi	r3,r3,-12884
 3228a74:	10800f24 	muli	r2,r2,60
 3228a78:	10c5883a 	add	r2,r2,r3
 3228a7c:	10800d04 	addi	r2,r2,52
 3228a80:	10800017 	ldw	r2,0(r2)
 3228a84:	10803fcc 	andi	r2,r2,255
 3228a88:	1004963a 	slli	r2,r2,24
 3228a8c:	2084b03a 	or	r2,r4,r2
 3228a90:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_SERVER, opt_ip);
 3228a94:	e0fff917 	ldw	r3,-28(fp)
 3228a98:	00800d84 	movi	r2,54
 3228a9c:	18800005 	stb	r2,0(r3)
 3228aa0:	e0bff917 	ldw	r2,-28(fp)
 3228aa4:	10800044 	addi	r2,r2,1
 3228aa8:	e0bff915 	stw	r2,-28(fp)
 3228aac:	e0fff917 	ldw	r3,-28(fp)
 3228ab0:	00800104 	movi	r2,4
 3228ab4:	18800005 	stb	r2,0(r3)
 3228ab8:	e0bff917 	ldw	r2,-28(fp)
 3228abc:	10800044 	addi	r2,r2,1
 3228ac0:	e0bff915 	stw	r2,-28(fp)
 3228ac4:	e0bff917 	ldw	r2,-28(fp)
 3228ac8:	10c000c4 	addi	r3,r2,3
 3228acc:	e0bffc04 	addi	r2,fp,-16
 3228ad0:	10800003 	ldbu	r2,0(r2)
 3228ad4:	18800005 	stb	r2,0(r3)
 3228ad8:	e0bff917 	ldw	r2,-28(fp)
 3228adc:	10c00084 	addi	r3,r2,2
 3228ae0:	e0bffc04 	addi	r2,fp,-16
 3228ae4:	10800044 	addi	r2,r2,1
 3228ae8:	10800003 	ldbu	r2,0(r2)
 3228aec:	18800005 	stb	r2,0(r3)
 3228af0:	e0bff917 	ldw	r2,-28(fp)
 3228af4:	10c00044 	addi	r3,r2,1
 3228af8:	e0bffc04 	addi	r2,fp,-16
 3228afc:	10800084 	addi	r2,r2,2
 3228b00:	10800003 	ldbu	r2,0(r2)
 3228b04:	18800005 	stb	r2,0(r3)
 3228b08:	e0bffc04 	addi	r2,fp,-16
 3228b0c:	108000c4 	addi	r2,r2,3
 3228b10:	10800003 	ldbu	r2,0(r2)
 3228b14:	1007883a 	mov	r3,r2
 3228b18:	e0bff917 	ldw	r2,-28(fp)
 3228b1c:	10c00005 	stb	r3,0(r2)
 3228b20:	e0bff917 	ldw	r2,-28(fp)
 3228b24:	10800104 	addi	r2,r2,4
 3228b28:	e0bff915 	stw	r2,-28(fp)
   /* add hostname (code 12) */
   PUT_STRING_OPT(opts, 12, dhc_hostname()); 
#endif /* USE_AUTOIP */

   /* Client Fully Qualified Domain Name */
   PUT_STRING_OPT(opts, 81, DC_DOMAINNAME); 
 3228b2c:	e0fff917 	ldw	r3,-28(fp)
 3228b30:	00801444 	movi	r2,81
 3228b34:	18800005 	stb	r2,0(r3)
 3228b38:	e0bff917 	ldw	r2,-28(fp)
 3228b3c:	10800044 	addi	r2,r2,1
 3228b40:	e0bff915 	stw	r2,-28(fp)
 3228b44:	00800184 	movi	r2,6
 3228b48:	e0bff615 	stw	r2,-40(fp)
 3228b4c:	e0bff617 	ldw	r2,-40(fp)
 3228b50:	1007883a 	mov	r3,r2
 3228b54:	e0bff917 	ldw	r2,-28(fp)
 3228b58:	10c00005 	stb	r3,0(r2)
 3228b5c:	e0bff917 	ldw	r2,-28(fp)
 3228b60:	10800044 	addi	r2,r2,1
 3228b64:	e0bff915 	stw	r2,-28(fp)
 3228b68:	e13ff917 	ldw	r4,-28(fp)
 3228b6c:	e1bff617 	ldw	r6,-40(fp)
 3228b70:	0140c974 	movhi	r5,805
 3228b74:	297cd404 	addi	r5,r5,-3248
 3228b78:	324beb00 	call	324beb0 <strncpy>
 3228b7c:	e0bff617 	ldw	r2,-40(fp)
 3228b80:	1007883a 	mov	r3,r2
 3228b84:	e0bff917 	ldw	r2,-28(fp)
 3228b88:	10c5883a 	add	r2,r2,r3
 3228b8c:	e0bff915 	stw	r2,-28(fp)
   /* Vendor Class Identifier */
   PUT_STRING_OPT(opts, 60, name); 
 3228b90:	e0fff917 	ldw	r3,-28(fp)
 3228b94:	00800f04 	movi	r2,60
 3228b98:	18800005 	stb	r2,0(r3)
 3228b9c:	e0bff917 	ldw	r2,-28(fp)
 3228ba0:	10800044 	addi	r2,r2,1
 3228ba4:	e0bff915 	stw	r2,-28(fp)
 3228ba8:	0080c974 	movhi	r2,805
 3228bac:	108aa904 	addi	r2,r2,10916
 3228bb0:	11000017 	ldw	r4,0(r2)
 3228bb4:	32084480 	call	3208448 <strlen>
 3228bb8:	e0bff515 	stw	r2,-44(fp)
 3228bbc:	e0bff517 	ldw	r2,-44(fp)
 3228bc0:	1007883a 	mov	r3,r2
 3228bc4:	e0bff917 	ldw	r2,-28(fp)
 3228bc8:	10c00005 	stb	r3,0(r2)
 3228bcc:	e0bff917 	ldw	r2,-28(fp)
 3228bd0:	10800044 	addi	r2,r2,1
 3228bd4:	e0bff915 	stw	r2,-28(fp)
 3228bd8:	e13ff917 	ldw	r4,-28(fp)
 3228bdc:	0080c974 	movhi	r2,805
 3228be0:	108aa904 	addi	r2,r2,10916
 3228be4:	11400017 	ldw	r5,0(r2)
 3228be8:	e1bff517 	ldw	r6,-44(fp)
 3228bec:	324beb00 	call	324beb0 <strncpy>
 3228bf0:	e0bff517 	ldw	r2,-44(fp)
 3228bf4:	1007883a 	mov	r3,r2
 3228bf8:	e0bff917 	ldw	r2,-28(fp)
 3228bfc:	10c5883a 	add	r2,r2,r3
 3228c00:	e0bff915 	stw	r2,-28(fp)

   *opts++ = DHOP_END;  /* Mark the end of options */
 3228c04:	e0fff917 	ldw	r3,-28(fp)
 3228c08:	00bfffc4 	movi	r2,-1
 3228c0c:	18800005 	stb	r2,0(r3)
 3228c10:	e0bff917 	ldw	r2,-28(fp)
 3228c14:	10800044 	addi	r2,r2,1
 3228c18:	e0bff915 	stw	r2,-28(fp)

   /* figure out whether to send via unicast or broadcast */
   if (dhc_states[iface].state == DHCS_RENEWING)
 3228c1c:	e0bffd17 	ldw	r2,-12(fp)
 3228c20:	00c0c9b4 	movhi	r3,806
 3228c24:	18f36b04 	addi	r3,r3,-12884
 3228c28:	10800f24 	muli	r2,r2,60
 3228c2c:	10c5883a 	add	r2,r2,r3
 3228c30:	10800017 	ldw	r2,0(r2)
 3228c34:	108001d8 	cmpnei	r2,r2,7
 3228c38:	10000a1e 	bne	r2,zero,3228c64 <dhc_request+0xa5c>
   {
      pkt->fhost = dhc_states[iface].srv_ipaddr;
 3228c3c:	e0bffd17 	ldw	r2,-12(fp)
 3228c40:	00c0c9b4 	movhi	r3,806
 3228c44:	18f36b04 	addi	r3,r3,-12884
 3228c48:	10800f24 	muli	r2,r2,60
 3228c4c:	10c5883a 	add	r2,r2,r3
 3228c50:	10800d04 	addi	r2,r2,52
 3228c54:	10c00017 	ldw	r3,0(r2)
 3228c58:	e0bffa17 	ldw	r2,-24(fp)
 3228c5c:	10c00715 	stw	r3,28(r2)
 3228c60:	00000306 	br	3228c70 <dhc_request+0xa68>
   }
   else
   {
      pkt->fhost = 0xFFFFFFFF;   /* broadcast request */
 3228c64:	e0fffa17 	ldw	r3,-24(fp)
 3228c68:	00bfffc4 	movi	r2,-1
 3228c6c:	18800715 	stw	r2,28(r3)
   }

   pkt->net = nets[iface];    /* send out caller spec'ed net */
 3228c70:	e0bffd17 	ldw	r2,-12(fp)
 3228c74:	00c0c9b4 	movhi	r3,806
 3228c78:	18f34504 	addi	r3,r3,-13036
 3228c7c:	1085883a 	add	r2,r2,r2
 3228c80:	1085883a 	add	r2,r2,r2
 3228c84:	10c5883a 	add	r2,r2,r3
 3228c88:	10c00017 	ldw	r3,0(r2)
 3228c8c:	e0bffa17 	ldw	r2,-24(fp)
 3228c90:	10c00615 	stw	r3,24(r2)
   pkt->nb_plen = (char *)opts - (char *)outbp;
 3228c94:	e0fff917 	ldw	r3,-28(fp)
 3228c98:	e0bffb17 	ldw	r2,-20(fp)
 3228c9c:	1885c83a 	sub	r2,r3,r2
 3228ca0:	1007883a 	mov	r3,r2
 3228ca4:	e0bffa17 	ldw	r2,-24(fp)
 3228ca8:	10c00415 	stw	r3,16(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 3228cac:	010010c4 	movi	r4,67
 3228cb0:	01401104 	movi	r5,68
 3228cb4:	e1bffa17 	ldw	r6,-24(fp)
 3228cb8:	324503c0 	call	324503c <udp_send>
   dsc_requests++;
 3228cbc:	d0a8ca17 	ldw	r2,-23768(gp)
 3228cc0:	10800044 	addi	r2,r2,1
 3228cc4:	d0a8ca15 	stw	r2,-23768(gp)

   dhc_states[iface].last_tick = cticks;
 3228cc8:	e13ffd17 	ldw	r4,-12(fp)
 3228ccc:	0080c974 	movhi	r2,805
 3228cd0:	10934104 	addi	r2,r2,19716
 3228cd4:	11400017 	ldw	r5,0(r2)
 3228cd8:	00c0c9b4 	movhi	r3,806
 3228cdc:	18f36b04 	addi	r3,r3,-12884
 3228ce0:	20800f24 	muli	r2,r4,60
 3228ce4:	10c5883a 	add	r2,r2,r3
 3228ce8:	10800404 	addi	r2,r2,16
 3228cec:	11400015 	stw	r5,0(r2)
   dhc_states[iface].tries++;
 3228cf0:	e17ffd17 	ldw	r5,-12(fp)
 3228cf4:	00c0c9b4 	movhi	r3,806
 3228cf8:	18f36b04 	addi	r3,r3,-12884
 3228cfc:	28800f24 	muli	r2,r5,60
 3228d00:	10c5883a 	add	r2,r2,r3
 3228d04:	10800104 	addi	r2,r2,4
 3228d08:	10800017 	ldw	r2,0(r2)
 3228d0c:	11000044 	addi	r4,r2,1
 3228d10:	00c0c9b4 	movhi	r3,806
 3228d14:	18f36b04 	addi	r3,r3,-12884
 3228d18:	28800f24 	muli	r2,r5,60
 3228d1c:	10c5883a 	add	r2,r2,r3
 3228d20:	10800104 	addi	r2,r2,4
 3228d24:	11000015 	stw	r4,0(r2)

   return 0;   /* return OK code */
 3228d28:	e03fff15 	stw	zero,-4(fp)
 3228d2c:	e0bfff17 	ldw	r2,-4(fp)
}
 3228d30:	e037883a 	mov	sp,fp
 3228d34:	dfc00117 	ldw	ra,4(sp)
 3228d38:	df000017 	ldw	fp,0(sp)
 3228d3c:	dec00204 	addi	sp,sp,8
 3228d40:	f800283a 	ret

03228d44 <dhc_setip>:
 * RETURNS: Returns 0 if ok, else non-zero ENP error.
 */

int
dhc_setip(int iface)
{
 3228d44:	defffd04 	addi	sp,sp,-12
 3228d48:	dfc00215 	stw	ra,8(sp)
 3228d4c:	df000115 	stw	fp,4(sp)
 3228d50:	df000104 	addi	fp,sp,4
 3228d54:	e13fff15 	stw	r4,-4(fp)
   nets[iface]->n_ipaddr = dhc_states[iface].ipaddr;
 3228d58:	e0bfff17 	ldw	r2,-4(fp)
 3228d5c:	00c0c9b4 	movhi	r3,806
 3228d60:	18f34504 	addi	r3,r3,-13036
 3228d64:	1085883a 	add	r2,r2,r2
 3228d68:	1085883a 	add	r2,r2,r2
 3228d6c:	10c5883a 	add	r2,r2,r3
 3228d70:	11000017 	ldw	r4,0(r2)
 3228d74:	e0bfff17 	ldw	r2,-4(fp)
 3228d78:	00c0c9b4 	movhi	r3,806
 3228d7c:	18f36b04 	addi	r3,r3,-12884
 3228d80:	10800f24 	muli	r2,r2,60
 3228d84:	10c5883a 	add	r2,r2,r3
 3228d88:	10800904 	addi	r2,r2,36
 3228d8c:	10800017 	ldw	r2,0(r2)
 3228d90:	20800a15 	stw	r2,40(r4)
   nets[iface]->snmask   = dhc_states[iface].snmask;
 3228d94:	e0bfff17 	ldw	r2,-4(fp)
 3228d98:	00c0c9b4 	movhi	r3,806
 3228d9c:	18f34504 	addi	r3,r3,-13036
 3228da0:	1085883a 	add	r2,r2,r2
 3228da4:	1085883a 	add	r2,r2,r2
 3228da8:	10c5883a 	add	r2,r2,r3
 3228dac:	11000017 	ldw	r4,0(r2)
 3228db0:	e0bfff17 	ldw	r2,-4(fp)
 3228db4:	00c0c9b4 	movhi	r3,806
 3228db8:	18f36b04 	addi	r3,r3,-12884
 3228dbc:	10800f24 	muli	r2,r2,60
 3228dc0:	10c5883a 	add	r2,r2,r3
 3228dc4:	10800a04 	addi	r2,r2,40
 3228dc8:	10800017 	ldw	r2,0(r2)
 3228dcc:	20800c15 	stw	r2,48(r4)
   nets[iface]->n_defgw  = dhc_states[iface].defgw;
 3228dd0:	e0bfff17 	ldw	r2,-4(fp)
 3228dd4:	00c0c9b4 	movhi	r3,806
 3228dd8:	18f34504 	addi	r3,r3,-13036
 3228ddc:	1085883a 	add	r2,r2,r2
 3228de0:	1085883a 	add	r2,r2,r2
 3228de4:	10c5883a 	add	r2,r2,r3
 3228de8:	11000017 	ldw	r4,0(r2)
 3228dec:	e0bfff17 	ldw	r2,-4(fp)
 3228df0:	00c0c9b4 	movhi	r3,806
 3228df4:	18f36b04 	addi	r3,r3,-12884
 3228df8:	10800f24 	muli	r2,r2,60
 3228dfc:	10c5883a 	add	r2,r2,r3
 3228e00:	10800b04 	addi	r2,r2,44
 3228e04:	10800017 	ldw	r2,0(r2)
 3228e08:	20800d15 	stw	r2,52(r4)

   if ( nets[iface]->snmask == 0 )
 3228e0c:	e0bfff17 	ldw	r2,-4(fp)
 3228e10:	00c0c9b4 	movhi	r3,806
 3228e14:	18f34504 	addi	r3,r3,-13036
 3228e18:	1085883a 	add	r2,r2,r2
 3228e1c:	1085883a 	add	r2,r2,r2
 3228e20:	10c5883a 	add	r2,r2,r3
 3228e24:	10800017 	ldw	r2,0(r2)
 3228e28:	10800c17 	ldw	r2,48(r2)
 3228e2c:	1004c03a 	cmpne	r2,r2,zero
 3228e30:	1000111e 	bne	r2,zero,3228e78 <dhc_setip+0x134>
   {
      fixup_subnet_mask(iface);
 3228e34:	e13fff17 	ldw	r4,-4(fp)
 3228e38:	322340c0 	call	322340c <fixup_subnet_mask>
      dhc_states[iface].snmask = nets[iface]->snmask; 
 3228e3c:	e17fff17 	ldw	r5,-4(fp)
 3228e40:	e0bfff17 	ldw	r2,-4(fp)
 3228e44:	00c0c9b4 	movhi	r3,806
 3228e48:	18f34504 	addi	r3,r3,-13036
 3228e4c:	1085883a 	add	r2,r2,r2
 3228e50:	1085883a 	add	r2,r2,r2
 3228e54:	10c5883a 	add	r2,r2,r3
 3228e58:	10800017 	ldw	r2,0(r2)
 3228e5c:	11000c17 	ldw	r4,48(r2)
 3228e60:	00c0c9b4 	movhi	r3,806
 3228e64:	18f36b04 	addi	r3,r3,-12884
 3228e68:	28800f24 	muli	r2,r5,60
 3228e6c:	10c5883a 	add	r2,r2,r3
 3228e70:	10800a04 	addi	r2,r2,40
 3228e74:	11000015 	stw	r4,0(r2)
   }

   /* fixup broadcast addresses */
   nets[iface]->n_netbr    = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 3228e78:	e0bfff17 	ldw	r2,-4(fp)
 3228e7c:	00c0c9b4 	movhi	r3,806
 3228e80:	18f34504 	addi	r3,r3,-13036
 3228e84:	1085883a 	add	r2,r2,r2
 3228e88:	1085883a 	add	r2,r2,r2
 3228e8c:	10c5883a 	add	r2,r2,r3
 3228e90:	11400017 	ldw	r5,0(r2)
 3228e94:	e0bfff17 	ldw	r2,-4(fp)
 3228e98:	00c0c9b4 	movhi	r3,806
 3228e9c:	18f34504 	addi	r3,r3,-13036
 3228ea0:	1085883a 	add	r2,r2,r2
 3228ea4:	1085883a 	add	r2,r2,r2
 3228ea8:	10c5883a 	add	r2,r2,r3
 3228eac:	10800017 	ldw	r2,0(r2)
 3228eb0:	11000a17 	ldw	r4,40(r2)
 3228eb4:	e0bfff17 	ldw	r2,-4(fp)
 3228eb8:	00c0c9b4 	movhi	r3,806
 3228ebc:	18f34504 	addi	r3,r3,-13036
 3228ec0:	1085883a 	add	r2,r2,r2
 3228ec4:	1085883a 	add	r2,r2,r2
 3228ec8:	10c5883a 	add	r2,r2,r3
 3228ecc:	10800017 	ldw	r2,0(r2)
 3228ed0:	10800c17 	ldw	r2,48(r2)
 3228ed4:	0084303a 	nor	r2,zero,r2
 3228ed8:	2084b03a 	or	r2,r4,r2
 3228edc:	28800e15 	stw	r2,56(r5)
   nets[iface]->n_netbr42  = nets[iface]->n_ipaddr &  nets[iface]->snmask;
 3228ee0:	e0bfff17 	ldw	r2,-4(fp)
 3228ee4:	00c0c9b4 	movhi	r3,806
 3228ee8:	18f34504 	addi	r3,r3,-13036
 3228eec:	1085883a 	add	r2,r2,r2
 3228ef0:	1085883a 	add	r2,r2,r2
 3228ef4:	10c5883a 	add	r2,r2,r3
 3228ef8:	11400017 	ldw	r5,0(r2)
 3228efc:	e0bfff17 	ldw	r2,-4(fp)
 3228f00:	00c0c9b4 	movhi	r3,806
 3228f04:	18f34504 	addi	r3,r3,-13036
 3228f08:	1085883a 	add	r2,r2,r2
 3228f0c:	1085883a 	add	r2,r2,r2
 3228f10:	10c5883a 	add	r2,r2,r3
 3228f14:	10800017 	ldw	r2,0(r2)
 3228f18:	11000a17 	ldw	r4,40(r2)
 3228f1c:	e0bfff17 	ldw	r2,-4(fp)
 3228f20:	00c0c9b4 	movhi	r3,806
 3228f24:	18f34504 	addi	r3,r3,-13036
 3228f28:	1085883a 	add	r2,r2,r2
 3228f2c:	1085883a 	add	r2,r2,r2
 3228f30:	10c5883a 	add	r2,r2,r3
 3228f34:	10800017 	ldw	r2,0(r2)
 3228f38:	10800c17 	ldw	r2,48(r2)
 3228f3c:	2084703a 	and	r2,r4,r2
 3228f40:	28800f15 	stw	r2,60(r5)
   nets[iface]->n_subnetbr = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 3228f44:	e0bfff17 	ldw	r2,-4(fp)
 3228f48:	00c0c9b4 	movhi	r3,806
 3228f4c:	18f34504 	addi	r3,r3,-13036
 3228f50:	1085883a 	add	r2,r2,r2
 3228f54:	1085883a 	add	r2,r2,r2
 3228f58:	10c5883a 	add	r2,r2,r3
 3228f5c:	11400017 	ldw	r5,0(r2)
 3228f60:	e0bfff17 	ldw	r2,-4(fp)
 3228f64:	00c0c9b4 	movhi	r3,806
 3228f68:	18f34504 	addi	r3,r3,-13036
 3228f6c:	1085883a 	add	r2,r2,r2
 3228f70:	1085883a 	add	r2,r2,r2
 3228f74:	10c5883a 	add	r2,r2,r3
 3228f78:	10800017 	ldw	r2,0(r2)
 3228f7c:	11000a17 	ldw	r4,40(r2)
 3228f80:	e0bfff17 	ldw	r2,-4(fp)
 3228f84:	00c0c9b4 	movhi	r3,806
 3228f88:	18f34504 	addi	r3,r3,-13036
 3228f8c:	1085883a 	add	r2,r2,r2
 3228f90:	1085883a 	add	r2,r2,r2
 3228f94:	10c5883a 	add	r2,r2,r3
 3228f98:	10800017 	ldw	r2,0(r2)
 3228f9c:	10800c17 	ldw	r2,48(r2)
 3228fa0:	0084303a 	nor	r2,zero,r2
 3228fa4:	2084b03a 	or	r2,r4,r2
 3228fa8:	28801015 	stw	r2,64(r5)

   return 0;   /* return OK code */
 3228fac:	0005883a 	mov	r2,zero
}
 3228fb0:	e037883a 	mov	sp,fp
 3228fb4:	dfc00117 	ldw	ra,4(sp)
 3228fb8:	df000017 	ldw	fp,0(sp)
 3228fbc:	dec00204 	addi	sp,sp,8
 3228fc0:	f800283a 	ret

03228fc4 <dhc_resetip>:
 * RETURNS: Returns 0 if ok, else non-zero error. 
 */

int
dhc_resetip(int iface)
{
 3228fc4:	defffe04 	addi	sp,sp,-8
 3228fc8:	df000115 	stw	fp,4(sp)
 3228fcc:	df000104 	addi	fp,sp,4
 3228fd0:	e13fff15 	stw	r4,-4(fp)
   /* reset the ipaddress */
   nets[iface]->n_ipaddr = 0;
 3228fd4:	e0bfff17 	ldw	r2,-4(fp)
 3228fd8:	00c0c9b4 	movhi	r3,806
 3228fdc:	18f34504 	addi	r3,r3,-13036
 3228fe0:	1085883a 	add	r2,r2,r2
 3228fe4:	1085883a 	add	r2,r2,r2
 3228fe8:	10c5883a 	add	r2,r2,r3
 3228fec:	10800017 	ldw	r2,0(r2)
 3228ff0:	10000a15 	stw	zero,40(r2)
   nets[iface]->snmask   = 0;
 3228ff4:	e0bfff17 	ldw	r2,-4(fp)
 3228ff8:	00c0c9b4 	movhi	r3,806
 3228ffc:	18f34504 	addi	r3,r3,-13036
 3229000:	1085883a 	add	r2,r2,r2
 3229004:	1085883a 	add	r2,r2,r2
 3229008:	10c5883a 	add	r2,r2,r3
 322900c:	10800017 	ldw	r2,0(r2)
 3229010:	10000c15 	stw	zero,48(r2)
   nets[iface]->n_defgw  = 0;
 3229014:	e0bfff17 	ldw	r2,-4(fp)
 3229018:	00c0c9b4 	movhi	r3,806
 322901c:	18f34504 	addi	r3,r3,-13036
 3229020:	1085883a 	add	r2,r2,r2
 3229024:	1085883a 	add	r2,r2,r2
 3229028:	10c5883a 	add	r2,r2,r3
 322902c:	10800017 	ldw	r2,0(r2)
 3229030:	10000d15 	stw	zero,52(r2)

   /* reset the broadcast addresses */
   nets[iface]->n_netbr    = 0;
 3229034:	e0bfff17 	ldw	r2,-4(fp)
 3229038:	00c0c9b4 	movhi	r3,806
 322903c:	18f34504 	addi	r3,r3,-13036
 3229040:	1085883a 	add	r2,r2,r2
 3229044:	1085883a 	add	r2,r2,r2
 3229048:	10c5883a 	add	r2,r2,r3
 322904c:	10800017 	ldw	r2,0(r2)
 3229050:	10000e15 	stw	zero,56(r2)
   nets[iface]->n_netbr42  = 0;
 3229054:	e0bfff17 	ldw	r2,-4(fp)
 3229058:	00c0c9b4 	movhi	r3,806
 322905c:	18f34504 	addi	r3,r3,-13036
 3229060:	1085883a 	add	r2,r2,r2
 3229064:	1085883a 	add	r2,r2,r2
 3229068:	10c5883a 	add	r2,r2,r3
 322906c:	10800017 	ldw	r2,0(r2)
 3229070:	10000f15 	stw	zero,60(r2)
   nets[iface]->n_subnetbr = 0;
 3229074:	e0bfff17 	ldw	r2,-4(fp)
 3229078:	00c0c9b4 	movhi	r3,806
 322907c:	18f34504 	addi	r3,r3,-13036
 3229080:	1085883a 	add	r2,r2,r2
 3229084:	1085883a 	add	r2,r2,r2
 3229088:	10c5883a 	add	r2,r2,r3
 322908c:	10800017 	ldw	r2,0(r2)
 3229090:	10001015 	stw	zero,64(r2)

   return 0;   /* return OK code */
 3229094:	0005883a 	mov	r2,zero
}
 3229098:	e037883a 	mov	sp,fp
 322909c:	df000017 	ldw	fp,0(sp)
 32290a0:	dec00104 	addi	sp,sp,4
 32290a4:	f800283a 	ret

032290a8 <dhc_decline>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_decline(int iface,struct bootp * bp, unsigned bplen)
{
 32290a8:	defff704 	addi	sp,sp,-36
 32290ac:	dfc00815 	stw	ra,32(sp)
 32290b0:	df000715 	stw	fp,28(sp)
 32290b4:	df000704 	addi	fp,sp,28
 32290b8:	e13ffc15 	stw	r4,-16(fp)
 32290bc:	e17ffd15 	stw	r5,-12(fp)
 32290c0:	e1bffe15 	stw	r6,-8(fp)
   struct bootp * outbp;
   PACKET pkt;
   u_char * opts;    /* scratch pointer to DHCP options field */

   /* get a UDP packet buffer for sending DHCP */
   pkt = udp_alloc(bplen, 0);
 32290c4:	e13ffe17 	ldw	r4,-8(fp)
 32290c8:	000b883a 	mov	r5,zero
 32290cc:	32454f40 	call	32454f4 <udp_alloc>
 32290d0:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 32290d4:	e0bffa17 	ldw	r2,-24(fp)
 32290d8:	1004c03a 	cmpne	r2,r2,zero
 32290dc:	1000031e 	bne	r2,zero,32290ec <dhc_decline+0x44>
      return ENP_NOMEM;
 32290e0:	00bffb04 	movi	r2,-20
 32290e4:	e0bfff15 	stw	r2,-4(fp)
 32290e8:	00002f06 	br	32291a8 <dhc_decline+0x100>
   pkt->nb_plen = bplen;
 32290ec:	e0fffa17 	ldw	r3,-24(fp)
 32290f0:	e0bffe17 	ldw	r2,-8(fp)
 32290f4:	18800415 	stw	r2,16(r3)

   outbp = (struct bootp *)pkt->nb_prot;
 32290f8:	e0bffa17 	ldw	r2,-24(fp)
 32290fc:	10800317 	ldw	r2,12(r2)
 3229100:	e0bffb15 	stw	r2,-20(fp)
   MEMCPY(outbp, bp, bplen);
 3229104:	e0bffb17 	ldw	r2,-20(fp)
 3229108:	e0fffd17 	ldw	r3,-12(fp)
 322910c:	1009883a 	mov	r4,r2
 3229110:	180b883a 	mov	r5,r3
 3229114:	e1bffe17 	ldw	r6,-8(fp)
 3229118:	3206ad00 	call	3206ad0 <memcpy>
   outbp->op = BOOTREQUEST;
 322911c:	e0fffb17 	ldw	r3,-20(fp)
 3229120:	00800044 	movi	r2,1
 3229124:	18800005 	stb	r2,0(r3)

   /* find DHCP TYPE option so we can overwrite it */   
   opts = find_opt(DHOP_TYPE, &outbp->options[4]);
 3229128:	e0bffb17 	ldw	r2,-20(fp)
 322912c:	10803b04 	addi	r2,r2,236
 3229130:	11400104 	addi	r5,r2,4
 3229134:	01000d44 	movi	r4,53
 3229138:	3229f500 	call	3229f50 <find_opt>
 322913c:	e0bff915 	stw	r2,-28(fp)
   opts += 2;     /* point to actual op code */
 3229140:	e0bff917 	ldw	r2,-28(fp)
 3229144:	10800084 	addi	r2,r2,2
 3229148:	e0bff915 	stw	r2,-28(fp)
   *opts = DHCP_DECLINE;   /* overwrite op code */
 322914c:	e0fff917 	ldw	r3,-28(fp)
 3229150:	00800104 	movi	r2,4
 3229154:	18800005 	stb	r2,0(r3)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast decline pkt */
 3229158:	e0fffa17 	ldw	r3,-24(fp)
 322915c:	00bfffc4 	movi	r2,-1
 3229160:	18800715 	stw	r2,28(r3)
   pkt->net = nets[iface];    /* send out caller speced net */
 3229164:	e0bffc17 	ldw	r2,-16(fp)
 3229168:	00c0c9b4 	movhi	r3,806
 322916c:	18f34504 	addi	r3,r3,-13036
 3229170:	1085883a 	add	r2,r2,r2
 3229174:	1085883a 	add	r2,r2,r2
 3229178:	10c5883a 	add	r2,r2,r3
 322917c:	10c00017 	ldw	r3,0(r2)
 3229180:	e0bffa17 	ldw	r2,-24(fp)
 3229184:	10c00615 	stw	r3,24(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 3229188:	010010c4 	movi	r4,67
 322918c:	01401104 	movi	r5,68
 3229190:	e1bffa17 	ldw	r6,-24(fp)
 3229194:	324503c0 	call	324503c <udp_send>
   dsc_declines++;   /* count declines sent */
 3229198:	d0a8cd17 	ldw	r2,-23756(gp)
 322919c:	10800044 	addi	r2,r2,1
 32291a0:	d0a8cd15 	stw	r2,-23756(gp)
   return 0;
 32291a4:	e03fff15 	stw	zero,-4(fp)
 32291a8:	e0bfff17 	ldw	r2,-4(fp)
}
 32291ac:	e037883a 	mov	sp,fp
 32291b0:	dfc00117 	ldw	ra,4(sp)
 32291b4:	df000017 	ldw	fp,0(sp)
 32291b8:	dec00204 	addi	sp,sp,8
 32291bc:	f800283a 	ret

032291c0 <dh_getlong>:
 *
 * RETURNS: the extracted 32 bit value
 */

static   long dh_getlong( u_char *ptr )
{
 32291c0:	defffc04 	addi	sp,sp,-16
 32291c4:	df000315 	stw	fp,12(sp)
 32291c8:	df000304 	addi	fp,sp,12
 32291cc:	e13fff15 	stw	r4,-4(fp)
     long  v;
     u_char * p2 =  (u_char *)&v;
 32291d0:	e0bffe04 	addi	r2,fp,-8
 32291d4:	e0bffd15 	stw	r2,-12(fp)

   *p2++ = *ptr++;
 32291d8:	e0bfff17 	ldw	r2,-4(fp)
 32291dc:	10c00003 	ldbu	r3,0(r2)
 32291e0:	e0bffd17 	ldw	r2,-12(fp)
 32291e4:	10c00005 	stb	r3,0(r2)
 32291e8:	e0bffd17 	ldw	r2,-12(fp)
 32291ec:	10800044 	addi	r2,r2,1
 32291f0:	e0bffd15 	stw	r2,-12(fp)
 32291f4:	e0bfff17 	ldw	r2,-4(fp)
 32291f8:	10800044 	addi	r2,r2,1
 32291fc:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 3229200:	e0bfff17 	ldw	r2,-4(fp)
 3229204:	10c00003 	ldbu	r3,0(r2)
 3229208:	e0bffd17 	ldw	r2,-12(fp)
 322920c:	10c00005 	stb	r3,0(r2)
 3229210:	e0bffd17 	ldw	r2,-12(fp)
 3229214:	10800044 	addi	r2,r2,1
 3229218:	e0bffd15 	stw	r2,-12(fp)
 322921c:	e0bfff17 	ldw	r2,-4(fp)
 3229220:	10800044 	addi	r2,r2,1
 3229224:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 3229228:	e0bfff17 	ldw	r2,-4(fp)
 322922c:	10c00003 	ldbu	r3,0(r2)
 3229230:	e0bffd17 	ldw	r2,-12(fp)
 3229234:	10c00005 	stb	r3,0(r2)
 3229238:	e0bffd17 	ldw	r2,-12(fp)
 322923c:	10800044 	addi	r2,r2,1
 3229240:	e0bffd15 	stw	r2,-12(fp)
 3229244:	e0bfff17 	ldw	r2,-4(fp)
 3229248:	10800044 	addi	r2,r2,1
 322924c:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 3229250:	e0bfff17 	ldw	r2,-4(fp)
 3229254:	10c00003 	ldbu	r3,0(r2)
 3229258:	e0bffd17 	ldw	r2,-12(fp)
 322925c:	10c00005 	stb	r3,0(r2)
 3229260:	e0bffd17 	ldw	r2,-12(fp)
 3229264:	10800044 	addi	r2,r2,1
 3229268:	e0bffd15 	stw	r2,-12(fp)
 322926c:	e0bfff17 	ldw	r2,-4(fp)
 3229270:	10800044 	addi	r2,r2,1
 3229274:	e0bfff15 	stw	r2,-4(fp)

   return v;
 3229278:	e0bffe17 	ldw	r2,-8(fp)
}
 322927c:	e037883a 	mov	sp,fp
 3229280:	df000017 	ldw	fp,0(sp)
 3229284:	dec00104 	addi	sp,sp,4
 3229288:	f800283a 	ret

0322928c <dhc_extract_opts>:
 * of the options passed were filled in with good values. 
 */

int
dhc_extract_opts(int iface, u_char *opts)
{
 322928c:	defff604 	addi	sp,sp,-40
 3229290:	dfc00915 	stw	ra,36(sp)
 3229294:	df000815 	stw	fp,32(sp)
 3229298:	dc400715 	stw	r17,28(sp)
 322929c:	dc000615 	stw	r16,24(sp)
 32292a0:	df000604 	addi	fp,sp,24
 32292a4:	e13ffc15 	stw	r4,-16(fp)
 32292a8:	e17ffd15 	stw	r5,-12(fp)
   u_char *end = opts + DHCP_OPTSIZE;  /* limit scope of search */
 32292ac:	e0bffd17 	ldw	r2,-12(fp)
 32292b0:	10804e04 	addi	r2,r2,312
 32292b4:	e0bffb15 	stw	r2,-20(fp)
   u_char optlen;

   /* first, clear the options */
   dhc_states[iface].snmask = 0; 
 32292b8:	e0bffc17 	ldw	r2,-16(fp)
 32292bc:	00c0c9b4 	movhi	r3,806
 32292c0:	18f36b04 	addi	r3,r3,-12884
 32292c4:	10800f24 	muli	r2,r2,60
 32292c8:	10c5883a 	add	r2,r2,r3
 32292cc:	10800a04 	addi	r2,r2,40
 32292d0:	10000015 	stw	zero,0(r2)
   dhc_states[iface].defgw = 0; 
 32292d4:	e0bffc17 	ldw	r2,-16(fp)
 32292d8:	00c0c9b4 	movhi	r3,806
 32292dc:	18f36b04 	addi	r3,r3,-12884
 32292e0:	10800f24 	muli	r2,r2,60
 32292e4:	10c5883a 	add	r2,r2,r3
 32292e8:	10800b04 	addi	r2,r2,44
 32292ec:	10000015 	stw	zero,0(r2)
   dhc_states[iface].lease = 0; 
 32292f0:	e0bffc17 	ldw	r2,-16(fp)
 32292f4:	00c0c9b4 	movhi	r3,806
 32292f8:	18f36b04 	addi	r3,r3,-12884
 32292fc:	10800f24 	muli	r2,r2,60
 3229300:	10c5883a 	add	r2,r2,r3
 3229304:	10800504 	addi	r2,r2,20
 3229308:	10000015 	stw	zero,0(r2)
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 322930c:	00008006 	br	3229510 <dhc_extract_opts+0x284>
   {
      switch (*opts++)
 3229310:	e0bffd17 	ldw	r2,-12(fp)
 3229314:	10800003 	ldbu	r2,0(r2)
 3229318:	10803fcc 	andi	r2,r2,255
 322931c:	e0bfff15 	stw	r2,-4(fp)
 3229320:	e0bffd17 	ldw	r2,-12(fp)
 3229324:	10800044 	addi	r2,r2,1
 3229328:	e0bffd15 	stw	r2,-12(fp)
 322932c:	e0ffff17 	ldw	r3,-4(fp)
 3229330:	188000e0 	cmpeqi	r2,r3,3
 3229334:	1000271e 	bne	r2,zero,32293d4 <dhc_extract_opts+0x148>
 3229338:	e0ffff17 	ldw	r3,-4(fp)
 322933c:	18800108 	cmpgei	r2,r3,4
 3229340:	1000071e 	bne	r2,zero,3229360 <dhc_extract_opts+0xd4>
 3229344:	e0ffff17 	ldw	r3,-4(fp)
 3229348:	1805003a 	cmpeq	r2,r3,zero
 322934c:	1000701e 	bne	r2,zero,3229510 <dhc_extract_opts+0x284>
 3229350:	e0ffff17 	ldw	r3,-4(fp)
 3229354:	18800060 	cmpeqi	r2,r3,1
 3229358:	10000d1e 	bne	r2,zero,3229390 <dhc_extract_opts+0x104>
 322935c:	00006406 	br	32294f0 <dhc_extract_opts+0x264>
 3229360:	e0ffff17 	ldw	r3,-4(fp)
 3229364:	18800ce0 	cmpeqi	r2,r3,51
 3229368:	1000331e 	bne	r2,zero,3229438 <dhc_extract_opts+0x1ac>
 322936c:	e0ffff17 	ldw	r3,-4(fp)
 3229370:	18803fe0 	cmpeqi	r2,r3,255
 3229374:	1000041e 	bne	r2,zero,3229388 <dhc_extract_opts+0xfc>
 3229378:	e0ffff17 	ldw	r3,-4(fp)
 322937c:	188001a0 	cmpeqi	r2,r3,6
 3229380:	10004f1e 	bne	r2,zero,32294c0 <dhc_extract_opts+0x234>
 3229384:	00005a06 	br	32294f0 <dhc_extract_opts+0x264>
      {
      case DHOP_PAD:
         break;
      case DHOP_END:
         return 0;   /* only good exit point */
 3229388:	e03ffe15 	stw	zero,-8(fp)
 322938c:	00006606 	br	3229528 <dhc_extract_opts+0x29c>
      case DHOP_SNMASK:
         opts++;
 3229390:	e0bffd17 	ldw	r2,-12(fp)
 3229394:	10800044 	addi	r2,r2,1
 3229398:	e0bffd15 	stw	r2,-12(fp)
         dhc_states[iface].snmask = dh_getlong(opts);
 322939c:	e43ffc17 	ldw	r16,-16(fp)
 32293a0:	e13ffd17 	ldw	r4,-12(fp)
 32293a4:	32291c00 	call	32291c0 <dh_getlong>
 32293a8:	1009883a 	mov	r4,r2
 32293ac:	00c0c9b4 	movhi	r3,806
 32293b0:	18f36b04 	addi	r3,r3,-12884
 32293b4:	80800f24 	muli	r2,r16,60
 32293b8:	10c5883a 	add	r2,r2,r3
 32293bc:	10800a04 	addi	r2,r2,40
 32293c0:	11000015 	stw	r4,0(r2)
         opts += 4;
 32293c4:	e0bffd17 	ldw	r2,-12(fp)
 32293c8:	10800104 	addi	r2,r2,4
 32293cc:	e0bffd15 	stw	r2,-12(fp)
         break;
 32293d0:	00004f06 	br	3229510 <dhc_extract_opts+0x284>
      case DHOP_ROUTER:
         optlen = *opts++;
 32293d4:	e0bffd17 	ldw	r2,-12(fp)
 32293d8:	10800003 	ldbu	r2,0(r2)
 32293dc:	e0bffa05 	stb	r2,-24(fp)
 32293e0:	e0bffd17 	ldw	r2,-12(fp)
 32293e4:	10800044 	addi	r2,r2,1
 32293e8:	e0bffd15 	stw	r2,-12(fp)
         if (optlen >= 4)
 32293ec:	e0bffa03 	ldbu	r2,-24(fp)
 32293f0:	10800130 	cmpltui	r2,r2,4
 32293f4:	10000a1e 	bne	r2,zero,3229420 <dhc_extract_opts+0x194>
            dhc_states[iface].defgw = dh_getlong(opts);
 32293f8:	e43ffc17 	ldw	r16,-16(fp)
 32293fc:	e13ffd17 	ldw	r4,-12(fp)
 3229400:	32291c00 	call	32291c0 <dh_getlong>
 3229404:	1009883a 	mov	r4,r2
 3229408:	00c0c9b4 	movhi	r3,806
 322940c:	18f36b04 	addi	r3,r3,-12884
 3229410:	80800f24 	muli	r2,r16,60
 3229414:	10c5883a 	add	r2,r2,r3
 3229418:	10800b04 	addi	r2,r2,44
 322941c:	11000015 	stw	r4,0(r2)
         opts += optlen;
 3229420:	e0bffa03 	ldbu	r2,-24(fp)
 3229424:	1007883a 	mov	r3,r2
 3229428:	e0bffd17 	ldw	r2,-12(fp)
 322942c:	10c5883a 	add	r2,r2,r3
 3229430:	e0bffd15 	stw	r2,-12(fp)
         break;
 3229434:	00003606 	br	3229510 <dhc_extract_opts+0x284>
      case DHOP_LEASE:
         opts++;
 3229438:	e0bffd17 	ldw	r2,-12(fp)
 322943c:	10800044 	addi	r2,r2,1
 3229440:	e0bffd15 	stw	r2,-12(fp)
         dhc_states[iface].lease = htonl(dh_getlong(opts));
 3229444:	e47ffc17 	ldw	r17,-16(fp)
 3229448:	e13ffd17 	ldw	r4,-12(fp)
 322944c:	32291c00 	call	32291c0 <dh_getlong>
 3229450:	1005d63a 	srai	r2,r2,24
 3229454:	14003fcc 	andi	r16,r2,255
 3229458:	e13ffd17 	ldw	r4,-12(fp)
 322945c:	32291c00 	call	32291c0 <dh_getlong>
 3229460:	1005d23a 	srai	r2,r2,8
 3229464:	10bfc00c 	andi	r2,r2,65280
 3229468:	80a0b03a 	or	r16,r16,r2
 322946c:	e13ffd17 	ldw	r4,-12(fp)
 3229470:	32291c00 	call	32291c0 <dh_getlong>
 3229474:	10bfc00c 	andi	r2,r2,65280
 3229478:	1004923a 	slli	r2,r2,8
 322947c:	80a0b03a 	or	r16,r16,r2
 3229480:	e13ffd17 	ldw	r4,-12(fp)
 3229484:	32291c00 	call	32291c0 <dh_getlong>
 3229488:	10803fcc 	andi	r2,r2,255
 322948c:	1004963a 	slli	r2,r2,24
 3229490:	8084b03a 	or	r2,r16,r2
 3229494:	1009883a 	mov	r4,r2
 3229498:	00c0c9b4 	movhi	r3,806
 322949c:	18f36b04 	addi	r3,r3,-12884
 32294a0:	88800f24 	muli	r2,r17,60
 32294a4:	10c5883a 	add	r2,r2,r3
 32294a8:	10800504 	addi	r2,r2,20
 32294ac:	11000015 	stw	r4,0(r2)
         opts += 4;
 32294b0:	e0bffd17 	ldw	r2,-12(fp)
 32294b4:	10800104 	addi	r2,r2,4
 32294b8:	e0bffd15 	stw	r2,-12(fp)
         break;
 32294bc:	00001406 	br	3229510 <dhc_extract_opts+0x284>
      case DHOP_DNSRV:
         optlen = *opts++;
 32294c0:	e0bffd17 	ldw	r2,-12(fp)
 32294c4:	10800003 	ldbu	r2,0(r2)
 32294c8:	e0bffa05 	stb	r2,-24(fp)
 32294cc:	e0bffd17 	ldw	r2,-12(fp)
 32294d0:	10800044 	addi	r2,r2,1
 32294d4:	e0bffd15 	stw	r2,-12(fp)
               opts += 4;
               i++;
            }
         }
#endif   /* DHC_MAXDNSRVS */
         opts += optlen;
 32294d8:	e0bffa03 	ldbu	r2,-24(fp)
 32294dc:	1007883a 	mov	r3,r2
 32294e0:	e0bffd17 	ldw	r2,-12(fp)
 32294e4:	10c5883a 	add	r2,r2,r3
 32294e8:	e0bffd15 	stw	r2,-12(fp)
         break;
 32294ec:	00000806 	br	3229510 <dhc_extract_opts+0x284>
      default:
         opts += ((*opts) + 1);
 32294f0:	e0bffd17 	ldw	r2,-12(fp)
 32294f4:	10800003 	ldbu	r2,0(r2)
 32294f8:	10803fcc 	andi	r2,r2,255
 32294fc:	1007883a 	mov	r3,r2
 3229500:	e0bffd17 	ldw	r2,-12(fp)
 3229504:	1885883a 	add	r2,r3,r2
 3229508:	10800044 	addi	r2,r2,1
 322950c:	e0bffd15 	stw	r2,-12(fp)
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 3229510:	e0fffd17 	ldw	r3,-12(fp)
 3229514:	e0bffb17 	ldw	r2,-20(fp)
 3229518:	10ff7d2e 	bgeu	r2,r3,3229310 <dhc_extract_opts+0x84>
      default:
         opts += ((*opts) + 1);
         break;
      }
   }
   dtrap();
 322951c:	322aef00 	call	322aef0 <dtrap>
   return -1;
 3229520:	00bfffc4 	movi	r2,-1
 3229524:	e0bffe15 	stw	r2,-8(fp)
 3229528:	e0bffe17 	ldw	r2,-8(fp)
}
 322952c:	e037883a 	mov	sp,fp
 3229530:	dfc00317 	ldw	ra,12(sp)
 3229534:	df000217 	ldw	fp,8(sp)
 3229538:	dc400117 	ldw	r17,4(sp)
 322953c:	dc000017 	ldw	r16,0(sp)
 3229540:	dec00404 	addi	sp,sp,16
 3229544:	f800283a 	ret

03229548 <dhc_second>:
 * RETURNS: Returns 0 or ENP_ error code 
 */

int
dhc_second(void)
{
 3229548:	defff704 	addi	sp,sp,-36
 322954c:	dfc00815 	stw	ra,32(sp)
 3229550:	df000715 	stw	fp,28(sp)
 3229554:	df000704 	addi	fp,sp,28
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 3229558:	e03ffc15 	stw	zero,-16(fp)
 322955c:	00015706 	br	3229abc <dhc_second+0x574>
   {
      switch (dhc_states[iface].state)
 3229560:	e0bffc17 	ldw	r2,-16(fp)
 3229564:	00c0c9b4 	movhi	r3,806
 3229568:	18f36b04 	addi	r3,r3,-12884
 322956c:	10800f24 	muli	r2,r2,60
 3229570:	10c5883a 	add	r2,r2,r3
 3229574:	10800017 	ldw	r2,0(r2)
 3229578:	e0bfff15 	stw	r2,-4(fp)
 322957c:	e0ffff17 	ldw	r3,-4(fp)
 3229580:	18800268 	cmpgeui	r2,r3,9
 3229584:	10014a1e 	bne	r2,zero,3229ab0 <dhc_second+0x568>
 3229588:	e13fff17 	ldw	r4,-4(fp)
 322958c:	e13fff17 	ldw	r4,-4(fp)
 3229590:	2105883a 	add	r2,r4,r4
 3229594:	1087883a 	add	r3,r2,r2
 3229598:	0080c8f4 	movhi	r2,803
 322959c:	10a56b04 	addi	r2,r2,-27220
 32295a0:	1885883a 	add	r2,r3,r2
 32295a4:	10800017 	ldw	r2,0(r2)
 32295a8:	1000683a 	jmp	r2
 32295ac:	03229ab0 	cmpltui	r12,zero,35434
 32295b0:	032295d0 	cmplti	r12,zero,-30121
 32295b4:	03229608 	cmpgei	r12,zero,-30120
 32295b8:	03229640 	call	322964 <OSCtxSw_SWITCH_PC+0x322924>
 32295bc:	03229640 	call	322964 <OSCtxSw_SWITCH_PC+0x322924>
 32295c0:	03229640 	call	322964 <OSCtxSw_SWITCH_PC+0x322924>
 32295c4:	032298a4 	muli	r12,zero,-30110
 32295c8:	0322995c 	xori	r12,zero,35429
 32295cc:	03229770 	cmpltui	r12,zero,35421
      {
      case DHCS_INIT:         /* Send a discover packet */
         e = dhc_discover(iface);
 32295d0:	e13ffc17 	ldw	r4,-16(fp)
 32295d4:	3227bec0 	call	3227bec <dhc_discover>
 32295d8:	e0bffa15 	stw	r2,-24(fp)
         /* Error while sending a discover packet */
         if (e)
 32295dc:	e0bffa17 	ldw	r2,-24(fp)
 32295e0:	1005003a 	cmpeq	r2,r2,zero
 32295e4:	1000041e 	bne	r2,zero,32295f8 <dhc_second+0xb0>
         {
            dtrap();
 32295e8:	322aef00 	call	322aef0 <dtrap>
            return e;
 32295ec:	e0bffa17 	ldw	r2,-24(fp)
 32295f0:	e0bffe15 	stw	r2,-8(fp)
 32295f4:	00013506 	br	3229acc <dhc_second+0x584>
         }
         dhc_set_state(iface,DHCS_SELECTING);
 32295f8:	e13ffc17 	ldw	r4,-16(fp)
 32295fc:	01400104 	movi	r5,4
 3229600:	3229ea00 	call	3229ea0 <dhc_set_state>
         break;
 3229604:	00012a06 	br	3229ab0 <dhc_second+0x568>
      case DHCS_INITREBOOT:   /* Send a request packet */
         e = dhc_reclaim(iface);
 3229608:	e13ffc17 	ldw	r4,-16(fp)
 322960c:	3229b6c0 	call	3229b6c <dhc_reclaim>
 3229610:	e0bffa15 	stw	r2,-24(fp)
         if (e)
 3229614:	e0bffa17 	ldw	r2,-24(fp)
 3229618:	1005003a 	cmpeq	r2,r2,zero
 322961c:	1000041e 	bne	r2,zero,3229630 <dhc_second+0xe8>
         {
            dtrap();
 3229620:	322aef00 	call	322aef0 <dtrap>
            return e;
 3229624:	e0fffa17 	ldw	r3,-24(fp)
 3229628:	e0fffe15 	stw	r3,-8(fp)
 322962c:	00012706 	br	3229acc <dhc_second+0x584>
         }
         dhc_set_state(iface,DHCS_REBOOTING);
 3229630:	e13ffc17 	ldw	r4,-16(fp)
 3229634:	014000c4 	movi	r5,3
 3229638:	3229ea00 	call	3229ea0 <dhc_set_state>
         break;
 322963c:	00011c06 	br	3229ab0 <dhc_second+0x568>
         /* Send discover packet on timeout */
      case DHCS_REBOOTING:
      case DHCS_REQUESTING:
         /* Discovery timeout = DHC_RETRY_TMO secs * (2 ** retries), max 64 */

         tries = dhc_states[iface].tries ;
 3229640:	e0bffc17 	ldw	r2,-16(fp)
 3229644:	00c0c9b4 	movhi	r3,806
 3229648:	18f36b04 	addi	r3,r3,-12884
 322964c:	10800f24 	muli	r2,r2,60
 3229650:	10c5883a 	add	r2,r2,r3
 3229654:	10800104 	addi	r2,r2,4
 3229658:	10800017 	ldw	r2,0(r2)
 322965c:	e0bffb15 	stw	r2,-20(fp)

         /* Set the exponential count */
         if ( tries >= DHC_MAX_TRIES) 
 3229660:	e0bffb17 	ldw	r2,-20(fp)
 3229664:	10800110 	cmplti	r2,r2,4
 3229668:	1000021e 	bne	r2,zero,3229674 <dhc_second+0x12c>
            tries= DHC_MAX_TRIES;
 322966c:	00800104 	movi	r2,4
 3229670:	e0bffb15 	stw	r2,-20(fp)
         if ( cticks > (dhc_states[iface].last_tick + 
 3229674:	e0bffc17 	ldw	r2,-16(fp)
 3229678:	00c0c9b4 	movhi	r3,806
 322967c:	18f36b04 	addi	r3,r3,-12884
 3229680:	10800f24 	muli	r2,r2,60
 3229684:	10c5883a 	add	r2,r2,r3
 3229688:	10800404 	addi	r2,r2,16
 322968c:	11000017 	ldw	r4,0(r2)
 3229690:	00c3e804 	movi	r3,4000
 3229694:	e0bffb17 	ldw	r2,-20(fp)
 3229698:	1884983a 	sll	r2,r3,r2
 322969c:	2087883a 	add	r3,r4,r2
 32296a0:	0080c974 	movhi	r2,805
 32296a4:	10934104 	addi	r2,r2,19716
 32296a8:	10800017 	ldw	r2,0(r2)
 32296ac:	18801c2e 	bgeu	r3,r2,3229720 <dhc_second+0x1d8>
             (((u_long) (DHC_RETRY_TMO*TPS)) << tries ) ) )
         {
            /* Timeout while waiting for a OFFER/ACK/NAK. Retransmit */
            switch(dhc_states[iface].state)
 32296b0:	e0bffc17 	ldw	r2,-16(fp)
 32296b4:	00c0c9b4 	movhi	r3,806
 32296b8:	18f36b04 	addi	r3,r3,-12884
 32296bc:	10800f24 	muli	r2,r2,60
 32296c0:	10c5883a 	add	r2,r2,r3
 32296c4:	10800017 	ldw	r2,0(r2)
 32296c8:	e0bffd15 	stw	r2,-12(fp)
 32296cc:	e13ffd17 	ldw	r4,-12(fp)
 32296d0:	20800120 	cmpeqi	r2,r4,4
 32296d4:	1000071e 	bne	r2,zero,32296f4 <dhc_second+0x1ac>
 32296d8:	e0fffd17 	ldw	r3,-12(fp)
 32296dc:	18800160 	cmpeqi	r2,r3,5
 32296e0:	1000071e 	bne	r2,zero,3229700 <dhc_second+0x1b8>
 32296e4:	e13ffd17 	ldw	r4,-12(fp)
 32296e8:	208000e0 	cmpeqi	r2,r4,3
 32296ec:	1000081e 	bne	r2,zero,3229710 <dhc_second+0x1c8>
 32296f0:	00000a06 	br	322971c <dhc_second+0x1d4>
            {
            case DHCS_SELECTING:
               dhc_discover(iface);
 32296f4:	e13ffc17 	ldw	r4,-16(fp)
 32296f8:	3227bec0 	call	3227bec <dhc_discover>
               break;
 32296fc:	00000806 	br	3229720 <dhc_second+0x1d8>
            case DHCS_REQUESTING:
               dhc_request(iface,FALSE);
 3229700:	e13ffc17 	ldw	r4,-16(fp)
 3229704:	000b883a 	mov	r5,zero
 3229708:	32282080 	call	3228208 <dhc_request>
               break;
 322970c:	00000406 	br	3229720 <dhc_second+0x1d8>
            case DHCS_REBOOTING:
               dhc_reclaim(iface);
 3229710:	e13ffc17 	ldw	r4,-16(fp)
 3229714:	3229b6c0 	call	3229b6c <dhc_reclaim>
               break;
 3229718:	00000106 	br	3229720 <dhc_second+0x1d8>
            default:
               dtrap(); /* bogus state */
 322971c:	322aef00 	call	322aef0 <dtrap>
               break;
            }
         }
         if ( tries == DHC_MAX_TRIES && 
 3229720:	e0bffb17 	ldw	r2,-20(fp)
 3229724:	10800118 	cmpnei	r2,r2,4
 3229728:	1000e11e 	bne	r2,zero,3229ab0 <dhc_second+0x568>
 322972c:	e0bffc17 	ldw	r2,-16(fp)
 3229730:	00c0c9b4 	movhi	r3,806
 3229734:	18f36b04 	addi	r3,r3,-12884
 3229738:	10800f24 	muli	r2,r2,60
 322973c:	10c5883a 	add	r2,r2,r3
 3229740:	10800017 	ldw	r2,0(r2)
 3229744:	10800120 	cmpeqi	r2,r2,4
 3229748:	1000d91e 	bne	r2,zero,3229ab0 <dhc_second+0x568>
             (dhc_states[iface].state !=DHCS_SELECTING) )
         {
            /* We have tried enough. Restart from INIT state */
            dhc_set_state(iface,DHCS_RESTARTING);
 322974c:	e13ffc17 	ldw	r4,-16(fp)
 3229750:	01400244 	movi	r5,9
 3229754:	3229ea00 	call	3229ea0 <dhc_set_state>
            dhc_resetip(iface);
 3229758:	e13ffc17 	ldw	r4,-16(fp)
 322975c:	3228fc40 	call	3228fc4 <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 3229760:	e13ffc17 	ldw	r4,-16(fp)
 3229764:	01400044 	movi	r5,1
 3229768:	3229ea00 	call	3229ea0 <dhc_set_state>
         }
         break;
 322976c:	0000d006 	br	3229ab0 <dhc_second+0x568>
      case DHCS_REBINDING:
         /* Check for timeout. Retry if we didn't get a ACK/NAK response. */

         if ( (dhc_states[iface].lease*TPS+dhc_states[iface].lease_start) > cticks )
 3229770:	e0bffc17 	ldw	r2,-16(fp)
 3229774:	00c0c9b4 	movhi	r3,806
 3229778:	18f36b04 	addi	r3,r3,-12884
 322977c:	10800f24 	muli	r2,r2,60
 3229780:	10c5883a 	add	r2,r2,r3
 3229784:	10800504 	addi	r2,r2,20
 3229788:	10800017 	ldw	r2,0(r2)
 322978c:	1100fa24 	muli	r4,r2,1000
 3229790:	e0bffc17 	ldw	r2,-16(fp)
 3229794:	00c0c9b4 	movhi	r3,806
 3229798:	18f36b04 	addi	r3,r3,-12884
 322979c:	10800f24 	muli	r2,r2,60
 32297a0:	10c5883a 	add	r2,r2,r3
 32297a4:	10800804 	addi	r2,r2,32
 32297a8:	10800017 	ldw	r2,0(r2)
 32297ac:	2087883a 	add	r3,r4,r2
 32297b0:	0080c974 	movhi	r2,805
 32297b4:	10934104 	addi	r2,r2,19716
 32297b8:	10800017 	ldw	r2,0(r2)
 32297bc:	10c0302e 	bgeu	r2,r3,3229880 <dhc_second+0x338>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 32297c0:	e0bffc17 	ldw	r2,-16(fp)
 32297c4:	00c0c9b4 	movhi	r3,806
 32297c8:	18f36b04 	addi	r3,r3,-12884
 32297cc:	10800f24 	muli	r2,r2,60
 32297d0:	10c5883a 	add	r2,r2,r3
 32297d4:	10800804 	addi	r2,r2,32
 32297d8:	11000017 	ldw	r4,0(r2)
 32297dc:	e0bffc17 	ldw	r2,-16(fp)
 32297e0:	00c0c9b4 	movhi	r3,806
 32297e4:	18f36b04 	addi	r3,r3,-12884
 32297e8:	10800f24 	muli	r2,r2,60
 32297ec:	10c5883a 	add	r2,r2,r3
 32297f0:	10800504 	addi	r2,r2,20
 32297f4:	10800017 	ldw	r2,0(r2)
 32297f8:	1080fa24 	muli	r2,r2,1000
 32297fc:	2089883a 	add	r4,r4,r2
 3229800:	e0bffc17 	ldw	r2,-16(fp)
 3229804:	00c0c9b4 	movhi	r3,806
 3229808:	18f36b04 	addi	r3,r3,-12884
 322980c:	10800f24 	muli	r2,r2,60
 3229810:	10c5883a 	add	r2,r2,r3
 3229814:	10800404 	addi	r2,r2,16
 3229818:	10800017 	ldw	r2,0(r2)
 322981c:	2085c83a 	sub	r2,r4,r2
 3229820:	1004d07a 	srli	r2,r2,1
 3229824:	e0bff915 	stw	r2,-28(fp)
             dhc_states[iface].lease*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 3229828:	e0fff917 	ldw	r3,-28(fp)
 322982c:	00ba97d4 	movui	r2,59999
 3229830:	10c00236 	bltu	r2,r3,322983c <dhc_second+0x2f4>
               half_time = 60*TPS;
 3229834:	00ba9814 	movui	r2,60000
 3229838:	e0bff915 	stw	r2,-28(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 322983c:	e0bffc17 	ldw	r2,-16(fp)
 3229840:	00c0c9b4 	movhi	r3,806
 3229844:	18f36b04 	addi	r3,r3,-12884
 3229848:	10800f24 	muli	r2,r2,60
 322984c:	10c5883a 	add	r2,r2,r3
 3229850:	10800404 	addi	r2,r2,16
 3229854:	10c00017 	ldw	r3,0(r2)
 3229858:	e0bff917 	ldw	r2,-28(fp)
 322985c:	1887883a 	add	r3,r3,r2
 3229860:	0080c974 	movhi	r2,805
 3229864:	10934104 	addi	r2,r2,19716
 3229868:	10800017 	ldw	r2,0(r2)
 322986c:	1880902e 	bgeu	r3,r2,3229ab0 <dhc_second+0x568>
            {
               dhc_request(iface,FALSE);
 3229870:	e13ffc17 	ldw	r4,-16(fp)
 3229874:	000b883a 	mov	r5,zero
 3229878:	32282080 	call	3228208 <dhc_request>
 322987c:	00008c06 	br	3229ab0 <dhc_second+0x568>
            }
         }
         else
         {
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
 3229880:	e13ffc17 	ldw	r4,-16(fp)
 3229884:	01400244 	movi	r5,9
 3229888:	3229ea00 	call	3229ea0 <dhc_set_state>
            dhc_resetip(iface);
 322988c:	e13ffc17 	ldw	r4,-16(fp)
 3229890:	3228fc40 	call	3228fc4 <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 3229894:	e13ffc17 	ldw	r4,-16(fp)
 3229898:	01400044 	movi	r5,1
 322989c:	3229ea00 	call	3229ea0 <dhc_set_state>
         }
         break;
 32298a0:	00008306 	br	3229ab0 <dhc_second+0x568>

      case DHCS_BOUND:
         /* Test for lease expiry. The RENEW timer. */
         if ( (dhc_states[iface].t1 != DHC_INFINITY) &&
 32298a4:	e0bffc17 	ldw	r2,-16(fp)
 32298a8:	00c0c9b4 	movhi	r3,806
 32298ac:	18f36b04 	addi	r3,r3,-12884
 32298b0:	10800f24 	muli	r2,r2,60
 32298b4:	10c5883a 	add	r2,r2,r3
 32298b8:	10800604 	addi	r2,r2,24
 32298bc:	10800017 	ldw	r2,0(r2)
 32298c0:	10bfffe0 	cmpeqi	r2,r2,-1
 32298c4:	10007a1e 	bne	r2,zero,3229ab0 <dhc_second+0x568>
 32298c8:	e0bffc17 	ldw	r2,-16(fp)
 32298cc:	00c0c9b4 	movhi	r3,806
 32298d0:	18f36b04 	addi	r3,r3,-12884
 32298d4:	10800f24 	muli	r2,r2,60
 32298d8:	10c5883a 	add	r2,r2,r3
 32298dc:	10800604 	addi	r2,r2,24
 32298e0:	10800017 	ldw	r2,0(r2)
 32298e4:	1100fa24 	muli	r4,r2,1000
 32298e8:	e0bffc17 	ldw	r2,-16(fp)
 32298ec:	00c0c9b4 	movhi	r3,806
 32298f0:	18f36b04 	addi	r3,r3,-12884
 32298f4:	10800f24 	muli	r2,r2,60
 32298f8:	10c5883a 	add	r2,r2,r3
 32298fc:	10800804 	addi	r2,r2,32
 3229900:	10800017 	ldw	r2,0(r2)
 3229904:	2087883a 	add	r3,r4,r2
 3229908:	0080c974 	movhi	r2,805
 322990c:	10934104 	addi	r2,r2,19716
 3229910:	10800017 	ldw	r2,0(r2)
 3229914:	1880662e 	bgeu	r3,r2,3229ab0 <dhc_second+0x568>
             (((dhc_states[iface].t1*TPS)+dhc_states[iface].lease_start) < cticks ) )
         {
            /* Time to renew. Send a UNICAST to the DHCP server */
            dhc_set_state(iface,DHCS_RENEWING);
 3229918:	e13ffc17 	ldw	r4,-16(fp)
 322991c:	014001c4 	movi	r5,7
 3229920:	3229ea00 	call	3229ea0 <dhc_set_state>
            e = dhc_reclaim(iface); /* unicast */ 
 3229924:	e13ffc17 	ldw	r4,-16(fp)
 3229928:	3229b6c0 	call	3229b6c <dhc_reclaim>
 322992c:	e0bffa15 	stw	r2,-24(fp)
            if (e)
 3229930:	e0bffa17 	ldw	r2,-24(fp)
 3229934:	1005003a 	cmpeq	r2,r2,zero
 3229938:	1000041e 	bne	r2,zero,322994c <dhc_second+0x404>
            {
               dtrap();
 322993c:	322aef00 	call	322aef0 <dtrap>
               return e;
 3229940:	e0bffa17 	ldw	r2,-24(fp)
 3229944:	e0bffe15 	stw	r2,-8(fp)
 3229948:	00006006 	br	3229acc <dhc_second+0x584>
            }
            dsc_renew++;
 322994c:	d0a8d017 	ldw	r2,-23744(gp)
 3229950:	10800044 	addi	r2,r2,1
 3229954:	d0a8d015 	stw	r2,-23744(gp)
         }
         break;
 3229958:	00005506 	br	3229ab0 <dhc_second+0x568>
      case DHCS_RENEWING:
         /* Test for lease expiry. The REBIND timer. */
         if ( (dhc_states[iface].t2*TPS+dhc_states[iface].lease_start) > cticks )
 322995c:	e0bffc17 	ldw	r2,-16(fp)
 3229960:	00c0c9b4 	movhi	r3,806
 3229964:	18f36b04 	addi	r3,r3,-12884
 3229968:	10800f24 	muli	r2,r2,60
 322996c:	10c5883a 	add	r2,r2,r3
 3229970:	10800704 	addi	r2,r2,28
 3229974:	10800017 	ldw	r2,0(r2)
 3229978:	1100fa24 	muli	r4,r2,1000
 322997c:	e0bffc17 	ldw	r2,-16(fp)
 3229980:	00c0c9b4 	movhi	r3,806
 3229984:	18f36b04 	addi	r3,r3,-12884
 3229988:	10800f24 	muli	r2,r2,60
 322998c:	10c5883a 	add	r2,r2,r3
 3229990:	10800804 	addi	r2,r2,32
 3229994:	10800017 	ldw	r2,0(r2)
 3229998:	2087883a 	add	r3,r4,r2
 322999c:	0080c974 	movhi	r2,805
 32299a0:	10934104 	addi	r2,r2,19716
 32299a4:	10800017 	ldw	r2,0(r2)
 32299a8:	10c0302e 	bgeu	r2,r3,3229a6c <dhc_second+0x524>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 32299ac:	e0bffc17 	ldw	r2,-16(fp)
 32299b0:	00c0c9b4 	movhi	r3,806
 32299b4:	18f36b04 	addi	r3,r3,-12884
 32299b8:	10800f24 	muli	r2,r2,60
 32299bc:	10c5883a 	add	r2,r2,r3
 32299c0:	10800804 	addi	r2,r2,32
 32299c4:	11000017 	ldw	r4,0(r2)
 32299c8:	e0bffc17 	ldw	r2,-16(fp)
 32299cc:	00c0c9b4 	movhi	r3,806
 32299d0:	18f36b04 	addi	r3,r3,-12884
 32299d4:	10800f24 	muli	r2,r2,60
 32299d8:	10c5883a 	add	r2,r2,r3
 32299dc:	10800704 	addi	r2,r2,28
 32299e0:	10800017 	ldw	r2,0(r2)
 32299e4:	1080fa24 	muli	r2,r2,1000
 32299e8:	2089883a 	add	r4,r4,r2
 32299ec:	e0bffc17 	ldw	r2,-16(fp)
 32299f0:	00c0c9b4 	movhi	r3,806
 32299f4:	18f36b04 	addi	r3,r3,-12884
 32299f8:	10800f24 	muli	r2,r2,60
 32299fc:	10c5883a 	add	r2,r2,r3
 3229a00:	10800404 	addi	r2,r2,16
 3229a04:	10800017 	ldw	r2,0(r2)
 3229a08:	2085c83a 	sub	r2,r4,r2
 3229a0c:	1004d07a 	srli	r2,r2,1
 3229a10:	e0bff915 	stw	r2,-28(fp)
             dhc_states[iface].t2*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 3229a14:	e0fff917 	ldw	r3,-28(fp)
 3229a18:	00ba97d4 	movui	r2,59999
 3229a1c:	10c00236 	bltu	r2,r3,3229a28 <dhc_second+0x4e0>
               half_time = 60*TPS;
 3229a20:	00ba9814 	movui	r2,60000
 3229a24:	e0bff915 	stw	r2,-28(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 3229a28:	e0bffc17 	ldw	r2,-16(fp)
 3229a2c:	00c0c9b4 	movhi	r3,806
 3229a30:	18f36b04 	addi	r3,r3,-12884
 3229a34:	10800f24 	muli	r2,r2,60
 3229a38:	10c5883a 	add	r2,r2,r3
 3229a3c:	10800404 	addi	r2,r2,16
 3229a40:	10c00017 	ldw	r3,0(r2)
 3229a44:	e0bff917 	ldw	r2,-28(fp)
 3229a48:	1887883a 	add	r3,r3,r2
 3229a4c:	0080c974 	movhi	r2,805
 3229a50:	10934104 	addi	r2,r2,19716
 3229a54:	10800017 	ldw	r2,0(r2)
 3229a58:	1880152e 	bgeu	r3,r2,3229ab0 <dhc_second+0x568>
            {
               dhc_request(iface,FALSE);
 3229a5c:	e13ffc17 	ldw	r4,-16(fp)
 3229a60:	000b883a 	mov	r5,zero
 3229a64:	32282080 	call	3228208 <dhc_request>
 3229a68:	00001106 	br	3229ab0 <dhc_second+0x568>
         {
            /* No Response has come from the Server that assigned our 
             * IP. Hence send a broadcast packet to see if we can 
             * lease this IP from some other server 
             */
            dhc_set_state(iface,DHCS_REBINDING);
 3229a6c:	e13ffc17 	ldw	r4,-16(fp)
 3229a70:	01400204 	movi	r5,8
 3229a74:	3229ea00 	call	3229ea0 <dhc_set_state>
            e = dhc_request(iface,TRUE);  /* broadcast */
 3229a78:	e13ffc17 	ldw	r4,-16(fp)
 3229a7c:	01400044 	movi	r5,1
 3229a80:	32282080 	call	3228208 <dhc_request>
 3229a84:	e0bffa15 	stw	r2,-24(fp)
            if (e)
 3229a88:	e0bffa17 	ldw	r2,-24(fp)
 3229a8c:	1005003a 	cmpeq	r2,r2,zero
 3229a90:	1000041e 	bne	r2,zero,3229aa4 <dhc_second+0x55c>
            {
               dtrap();
 3229a94:	322aef00 	call	322aef0 <dtrap>
               return e;
 3229a98:	e0fffa17 	ldw	r3,-24(fp)
 3229a9c:	e0fffe15 	stw	r3,-8(fp)
 3229aa0:	00000a06 	br	3229acc <dhc_second+0x584>
            }
            dsc_rebind++;
 3229aa4:	d0a8d117 	ldw	r2,-23740(gp)
 3229aa8:	10800044 	addi	r2,r2,1
 3229aac:	d0a8d115 	stw	r2,-23740(gp)
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 3229ab0:	e0bffc17 	ldw	r2,-16(fp)
 3229ab4:	10800044 	addi	r2,r2,1
 3229ab8:	e0bffc15 	stw	r2,-16(fp)
 3229abc:	e0bffc17 	ldw	r2,-16(fp)
 3229ac0:	10800110 	cmplti	r2,r2,4
 3229ac4:	103ea61e 	bne	r2,zero,3229560 <dhc_second+0x18>
      case DHCS_UNUSED:
      default:
         continue;
      }
   }
   return 0;
 3229ac8:	e03ffe15 	stw	zero,-8(fp)
 3229acc:	e0bffe17 	ldw	r2,-8(fp)
}
 3229ad0:	e037883a 	mov	sp,fp
 3229ad4:	dfc00117 	ldw	ra,4(sp)
 3229ad8:	df000017 	ldw	fp,0(sp)
 3229adc:	dec00204 	addi	sp,sp,8
 3229ae0:	f800283a 	ret

03229ae4 <dhc_halt>:
 * RETURNS: void
 */

void
dhc_halt(int iface)
{
 3229ae4:	defffd04 	addi	sp,sp,-12
 3229ae8:	dfc00215 	stw	ra,8(sp)
 3229aec:	df000115 	stw	fp,4(sp)
 3229af0:	df000104 	addi	fp,sp,4
 3229af4:	e13fff15 	stw	r4,-4(fp)
   if (iface < 0 || iface > MAXNETS)
 3229af8:	e0bfff17 	ldw	r2,-4(fp)
 3229afc:	1004803a 	cmplt	r2,r2,zero
 3229b00:	1000031e 	bne	r2,zero,3229b10 <dhc_halt+0x2c>
 3229b04:	e0bfff17 	ldw	r2,-4(fp)
 3229b08:	10800150 	cmplti	r2,r2,5
 3229b0c:	1000021e 	bne	r2,zero,3229b18 <dhc_halt+0x34>
   {
      dtrap();
 3229b10:	322aef00 	call	322aef0 <dtrap>
      return;
 3229b14:	00001006 	br	3229b58 <dhc_halt+0x74>
   }
   /* clear dhc_states entry - (kills retrys) */
   MEMSET(&dhc_states[iface], 0, sizeof(struct dhc_state));
 3229b18:	e0bfff17 	ldw	r2,-4(fp)
 3229b1c:	10800f24 	muli	r2,r2,60
 3229b20:	1007883a 	mov	r3,r2
 3229b24:	0080c9b4 	movhi	r2,806
 3229b28:	10b36b04 	addi	r2,r2,-12884
 3229b2c:	1885883a 	add	r2,r3,r2
 3229b30:	1009883a 	mov	r4,r2
 3229b34:	01800f04 	movi	r6,60
 3229b38:	000b883a 	mov	r5,zero
 3229b3c:	3206c500 	call	3206c50 <memset>
   dhc_states[iface].state = DHCS_UNUSED;
 3229b40:	e0bfff17 	ldw	r2,-4(fp)
 3229b44:	00c0c9b4 	movhi	r3,806
 3229b48:	18f36b04 	addi	r3,r3,-12884
 3229b4c:	10800f24 	muli	r2,r2,60
 3229b50:	10c5883a 	add	r2,r2,r3
 3229b54:	10000015 	stw	zero,0(r2)
}
 3229b58:	e037883a 	mov	sp,fp
 3229b5c:	dfc00117 	ldw	ra,4(sp)
 3229b60:	df000017 	ldw	fp,0(sp)
 3229b64:	dec00204 	addi	sp,sp,8
 3229b68:	f800283a 	ret

03229b6c <dhc_reclaim>:
 * RETURNS: Returns 0 if DHCP request was sent OK, else non-zero error. 
 */

int   
dhc_reclaim(int iface)
{
 3229b6c:	defffb04 	addi	sp,sp,-20
 3229b70:	dfc00415 	stw	ra,16(sp)
 3229b74:	df000315 	stw	fp,12(sp)
 3229b78:	df000304 	addi	fp,sp,12
 3229b7c:	e13ffe15 	stw	r4,-8(fp)
   /* punt if IP address is not set */
   if (nets[iface]->n_ipaddr == 0L)
 3229b80:	e0bffe17 	ldw	r2,-8(fp)
 3229b84:	00c0c9b4 	movhi	r3,806
 3229b88:	18f34504 	addi	r3,r3,-13036
 3229b8c:	1085883a 	add	r2,r2,r2
 3229b90:	1085883a 	add	r2,r2,r2
 3229b94:	10c5883a 	add	r2,r2,r3
 3229b98:	10800017 	ldw	r2,0(r2)
 3229b9c:	10800a17 	ldw	r2,40(r2)
 3229ba0:	1004c03a 	cmpne	r2,r2,zero
 3229ba4:	1000041e 	bne	r2,zero,3229bb8 <dhc_reclaim+0x4c>
   {
      dtrap();    /* programming bug? */
 3229ba8:	322aef00 	call	322aef0 <dtrap>
      return ENP_LOGIC;
 3229bac:	00bffd44 	movi	r2,-11
 3229bb0:	e0bfff15 	stw	r2,-4(fp)
 3229bb4:	00005b06 	br	3229d24 <dhc_reclaim+0x1b8>
   }

   dhc_states[iface].ipaddr = nets[iface]->n_ipaddr;
 3229bb8:	e17ffe17 	ldw	r5,-8(fp)
 3229bbc:	e0bffe17 	ldw	r2,-8(fp)
 3229bc0:	00c0c9b4 	movhi	r3,806
 3229bc4:	18f34504 	addi	r3,r3,-13036
 3229bc8:	1085883a 	add	r2,r2,r2
 3229bcc:	1085883a 	add	r2,r2,r2
 3229bd0:	10c5883a 	add	r2,r2,r3
 3229bd4:	10800017 	ldw	r2,0(r2)
 3229bd8:	11000a17 	ldw	r4,40(r2)
 3229bdc:	00c0c9b4 	movhi	r3,806
 3229be0:	18f36b04 	addi	r3,r3,-12884
 3229be4:	28800f24 	muli	r2,r5,60
 3229be8:	10c5883a 	add	r2,r2,r3
 3229bec:	10800904 	addi	r2,r2,36
 3229bf0:	11000015 	stw	r4,0(r2)
   dhc_states[iface].snmask = nets[iface]->snmask;
 3229bf4:	e17ffe17 	ldw	r5,-8(fp)
 3229bf8:	e0bffe17 	ldw	r2,-8(fp)
 3229bfc:	00c0c9b4 	movhi	r3,806
 3229c00:	18f34504 	addi	r3,r3,-13036
 3229c04:	1085883a 	add	r2,r2,r2
 3229c08:	1085883a 	add	r2,r2,r2
 3229c0c:	10c5883a 	add	r2,r2,r3
 3229c10:	10800017 	ldw	r2,0(r2)
 3229c14:	11000c17 	ldw	r4,48(r2)
 3229c18:	00c0c9b4 	movhi	r3,806
 3229c1c:	18f36b04 	addi	r3,r3,-12884
 3229c20:	28800f24 	muli	r2,r5,60
 3229c24:	10c5883a 	add	r2,r2,r3
 3229c28:	10800a04 	addi	r2,r2,40
 3229c2c:	11000015 	stw	r4,0(r2)
   dhc_states[iface].defgw  = nets[iface]->n_defgw;
 3229c30:	e17ffe17 	ldw	r5,-8(fp)
 3229c34:	e0bffe17 	ldw	r2,-8(fp)
 3229c38:	00c0c9b4 	movhi	r3,806
 3229c3c:	18f34504 	addi	r3,r3,-13036
 3229c40:	1085883a 	add	r2,r2,r2
 3229c44:	1085883a 	add	r2,r2,r2
 3229c48:	10c5883a 	add	r2,r2,r3
 3229c4c:	10800017 	ldw	r2,0(r2)
 3229c50:	11000d17 	ldw	r4,52(r2)
 3229c54:	00c0c9b4 	movhi	r3,806
 3229c58:	18f36b04 	addi	r3,r3,-12884
 3229c5c:	28800f24 	muli	r2,r5,60
 3229c60:	10c5883a 	add	r2,r2,r3
 3229c64:	10800b04 	addi	r2,r2,44
 3229c68:	11000015 	stw	r4,0(r2)

#ifdef IP_ROUTING
   /* If the DHCP Server is on other network, route the request
    * from the same DHCP relay agent. To do that, add a route.
    */
   if (dhc_states[iface].rly_ipaddr)
 3229c6c:	e0bffe17 	ldw	r2,-8(fp)
 3229c70:	00c0c9b4 	movhi	r3,806
 3229c74:	18f36b04 	addi	r3,r3,-12884
 3229c78:	10800f24 	muli	r2,r2,60
 3229c7c:	10c5883a 	add	r2,r2,r3
 3229c80:	10800c04 	addi	r2,r2,48
 3229c84:	10800017 	ldw	r2,0(r2)
 3229c88:	1005003a 	cmpeq	r2,r2,zero
 3229c8c:	1000211e 	bne	r2,zero,3229d14 <dhc_reclaim+0x1a8>
   {
      if (dhc_states[iface].srv_ipaddr)
 3229c90:	e0bffe17 	ldw	r2,-8(fp)
 3229c94:	00c0c9b4 	movhi	r3,806
 3229c98:	18f36b04 	addi	r3,r3,-12884
 3229c9c:	10800f24 	muli	r2,r2,60
 3229ca0:	10c5883a 	add	r2,r2,r3
 3229ca4:	10800d04 	addi	r2,r2,52
 3229ca8:	10800017 	ldw	r2,0(r2)
 3229cac:	1005003a 	cmpeq	r2,r2,zero
 3229cb0:	1000171e 	bne	r2,zero,3229d10 <dhc_reclaim+0x1a4>
      {
         /* yes, earlier negotiation was done via a relay agent */
         if ( !add_route(dhc_states[iface].srv_ipaddr, 0xFFFFFFFF,
 3229cb4:	e0bffe17 	ldw	r2,-8(fp)
 3229cb8:	00c0c9b4 	movhi	r3,806
 3229cbc:	18f36b04 	addi	r3,r3,-12884
 3229cc0:	10800f24 	muli	r2,r2,60
 3229cc4:	10c5883a 	add	r2,r2,r3
 3229cc8:	10800d04 	addi	r2,r2,52
 3229ccc:	11000017 	ldw	r4,0(r2)
 3229cd0:	e0bffe17 	ldw	r2,-8(fp)
 3229cd4:	00c0c9b4 	movhi	r3,806
 3229cd8:	18f36b04 	addi	r3,r3,-12884
 3229cdc:	10800f24 	muli	r2,r2,60
 3229ce0:	10c5883a 	add	r2,r2,r3
 3229ce4:	10800c04 	addi	r2,r2,48
 3229ce8:	11800017 	ldw	r6,0(r2)
 3229cec:	00800084 	movi	r2,2
 3229cf0:	d8800015 	stw	r2,0(sp)
 3229cf4:	017fffc4 	movi	r5,-1
 3229cf8:	e1fffe17 	ldw	r7,-8(fp)
 3229cfc:	32442780 	call	3244278 <add_route>
 3229d00:	1004c03a 	cmpne	r2,r2,zero
 3229d04:	1000031e 	bne	r2,zero,3229d14 <dhc_reclaim+0x1a8>
             dhc_states[iface].rly_ipaddr, iface, IPRP_LOCAL))
         {
            /* route was not added. check this case */
            dtrap(); 
 3229d08:	322aef00 	call	322aef0 <dtrap>
 3229d0c:	00000106 	br	3229d14 <dhc_reclaim+0x1a8>
      else
      {
         /* DHCP relay IP address is set, but DHCP Server IP address is
          * not set ! How can this happen ?
          */
         dtrap();
 3229d10:	322aef00 	call	322aef0 <dtrap>
      }
   }
#endif  /* IP_ROUTING */

   /* send the request */
   return(dhc_request(iface,TRUE));  
 3229d14:	e13ffe17 	ldw	r4,-8(fp)
 3229d18:	01400044 	movi	r5,1
 3229d1c:	32282080 	call	3228208 <dhc_request>
 3229d20:	e0bfff15 	stw	r2,-4(fp)
 3229d24:	e0bfff17 	ldw	r2,-4(fp)
}
 3229d28:	e037883a 	mov	sp,fp
 3229d2c:	dfc00117 	ldw	ra,4(sp)
 3229d30:	df000017 	ldw	fp,0(sp)
 3229d34:	dec00204 	addi	sp,sp,8
 3229d38:	f800283a 	ret

03229d3c <dhc_state_init>:
 * RETURNS: void
 */

void 
dhc_state_init(int iface, int init_flag)
{
 3229d3c:	defffa04 	addi	sp,sp,-24
 3229d40:	dfc00515 	stw	ra,20(sp)
 3229d44:	df000415 	stw	fp,16(sp)
 3229d48:	df000404 	addi	fp,sp,16
 3229d4c:	e13ffd15 	stw	r4,-12(fp)
 3229d50:	e17ffe15 	stw	r5,-8(fp)
   int state = (init_flag == TRUE) ? DHCS_INIT : DHCS_INITREBOOT;
 3229d54:	e0bffe17 	ldw	r2,-8(fp)
 3229d58:	10800058 	cmpnei	r2,r2,1
 3229d5c:	1000031e 	bne	r2,zero,3229d6c <dhc_state_init+0x30>
 3229d60:	00800044 	movi	r2,1
 3229d64:	e0bfff15 	stw	r2,-4(fp)
 3229d68:	00000206 	br	3229d74 <dhc_state_init+0x38>
 3229d6c:	00800084 	movi	r2,2
 3229d70:	e0bfff15 	stw	r2,-4(fp)
 3229d74:	e0bfff17 	ldw	r2,-4(fp)
 3229d78:	e0bffc15 	stw	r2,-16(fp)
   
   dhc_set_state(iface, state);
 3229d7c:	e13ffd17 	ldw	r4,-12(fp)
 3229d80:	e17ffc17 	ldw	r5,-16(fp)
 3229d84:	3229ea00 	call	3229ea0 <dhc_set_state>
}
 3229d88:	e037883a 	mov	sp,fp
 3229d8c:	dfc00117 	ldw	ra,4(sp)
 3229d90:	df000017 	ldw	fp,0(sp)
 3229d94:	dec00204 	addi	sp,sp,8
 3229d98:	f800283a 	ret

03229d9c <dhc_alldone>:
 * otherwise. 
 */

int 
dhc_alldone(void)
{
 3229d9c:	defffd04 	addi	sp,sp,-12
 3229da0:	df000215 	stw	fp,8(sp)
 3229da4:	df000204 	addi	fp,sp,8
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 3229da8:	e03ffe15 	stw	zero,-8(fp)
 3229dac:	00001506 	br	3229e04 <dhc_alldone+0x68>
   {
      if ( ( dhc_states[i].state == DHCS_UNUSED ) || 
 3229db0:	e0bffe17 	ldw	r2,-8(fp)
 3229db4:	00c0c9b4 	movhi	r3,806
 3229db8:	18f36b04 	addi	r3,r3,-12884
 3229dbc:	10800f24 	muli	r2,r2,60
 3229dc0:	10c5883a 	add	r2,r2,r3
 3229dc4:	10800017 	ldw	r2,0(r2)
 3229dc8:	1005003a 	cmpeq	r2,r2,zero
 3229dcc:	10000a1e 	bne	r2,zero,3229df8 <dhc_alldone+0x5c>
 3229dd0:	e0bffe17 	ldw	r2,-8(fp)
 3229dd4:	00c0c9b4 	movhi	r3,806
 3229dd8:	18f36b04 	addi	r3,r3,-12884
 3229ddc:	10800f24 	muli	r2,r2,60
 3229de0:	10c5883a 	add	r2,r2,r3
 3229de4:	10800017 	ldw	r2,0(r2)
 3229de8:	108001a0 	cmpeqi	r2,r2,6
 3229dec:	1000021e 	bne	r2,zero,3229df8 <dhc_alldone+0x5c>
      {
         continue ;
      }
      else
      {
         return FALSE ;
 3229df0:	e03fff15 	stw	zero,-4(fp)
 3229df4:	00000806 	br	3229e18 <dhc_alldone+0x7c>

int 
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 3229df8:	e0bffe17 	ldw	r2,-8(fp)
 3229dfc:	10800044 	addi	r2,r2,1
 3229e00:	e0bffe15 	stw	r2,-8(fp)
 3229e04:	e0bffe17 	ldw	r2,-8(fp)
 3229e08:	10800110 	cmplti	r2,r2,4
 3229e0c:	103fe81e 	bne	r2,zero,3229db0 <dhc_alldone+0x14>
      else
      {
         return FALSE ;
      }
   }
   return TRUE ;
 3229e10:	00800044 	movi	r2,1
 3229e14:	e0bfff15 	stw	r2,-4(fp)
 3229e18:	e0bfff17 	ldw	r2,-4(fp)
}
 3229e1c:	e037883a 	mov	sp,fp
 3229e20:	df000017 	ldw	fp,0(sp)
 3229e24:	dec00104 	addi	sp,sp,4
 3229e28:	f800283a 	ret

03229e2c <dhc_ifacedone>:
 * RETURNS: 
 */

int 
dhc_ifacedone(int iface)
{
 3229e2c:	defffd04 	addi	sp,sp,-12
 3229e30:	df000215 	stw	fp,8(sp)
 3229e34:	df000204 	addi	fp,sp,8
 3229e38:	e13ffe15 	stw	r4,-8(fp)
   if ( ( dhc_states[iface].state == DHCS_UNUSED ) || 
 3229e3c:	e0bffe17 	ldw	r2,-8(fp)
 3229e40:	00c0c9b4 	movhi	r3,806
 3229e44:	18f36b04 	addi	r3,r3,-12884
 3229e48:	10800f24 	muli	r2,r2,60
 3229e4c:	10c5883a 	add	r2,r2,r3
 3229e50:	10800017 	ldw	r2,0(r2)
 3229e54:	1005003a 	cmpeq	r2,r2,zero
 3229e58:	1000081e 	bne	r2,zero,3229e7c <dhc_ifacedone+0x50>
 3229e5c:	e0bffe17 	ldw	r2,-8(fp)
 3229e60:	00c0c9b4 	movhi	r3,806
 3229e64:	18f36b04 	addi	r3,r3,-12884
 3229e68:	10800f24 	muli	r2,r2,60
 3229e6c:	10c5883a 	add	r2,r2,r3
 3229e70:	10800017 	ldw	r2,0(r2)
 3229e74:	10800198 	cmpnei	r2,r2,6
 3229e78:	1000031e 	bne	r2,zero,3229e88 <dhc_ifacedone+0x5c>
       ( dhc_states[iface].state == DHCS_BOUND  )  )
   {
      return TRUE ;
 3229e7c:	00800044 	movi	r2,1
 3229e80:	e0bfff15 	stw	r2,-4(fp)
 3229e84:	00000106 	br	3229e8c <dhc_ifacedone+0x60>
   }
   else
   {
      return FALSE ;
 3229e88:	e03fff15 	stw	zero,-4(fp)
 3229e8c:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 3229e90:	e037883a 	mov	sp,fp
 3229e94:	df000017 	ldw	fp,0(sp)
 3229e98:	dec00104 	addi	sp,sp,4
 3229e9c:	f800283a 	ret

03229ea0 <dhc_set_state>:
 *
 * RETURNS: 
 */

void dhc_set_state(int iface, int state)
{
 3229ea0:	defffc04 	addi	sp,sp,-16
 3229ea4:	dfc00315 	stw	ra,12(sp)
 3229ea8:	df000215 	stw	fp,8(sp)
 3229eac:	df000204 	addi	fp,sp,8
 3229eb0:	e13ffe15 	stw	r4,-8(fp)
 3229eb4:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].state = state; /* Set the new state */
 3229eb8:	e0bffe17 	ldw	r2,-8(fp)
 3229ebc:	e13fff17 	ldw	r4,-4(fp)
 3229ec0:	00c0c9b4 	movhi	r3,806
 3229ec4:	18f36b04 	addi	r3,r3,-12884
 3229ec8:	10800f24 	muli	r2,r2,60
 3229ecc:	10c5883a 	add	r2,r2,r3
 3229ed0:	11000015 	stw	r4,0(r2)
   dhc_states[iface].tries = 0;     /* Reset the number of tries */
 3229ed4:	e0bffe17 	ldw	r2,-8(fp)
 3229ed8:	00c0c9b4 	movhi	r3,806
 3229edc:	18f36b04 	addi	r3,r3,-12884
 3229ee0:	10800f24 	muli	r2,r2,60
 3229ee4:	10c5883a 	add	r2,r2,r3
 3229ee8:	10800104 	addi	r2,r2,4
 3229eec:	10000015 	stw	zero,0(r2)

   /* If callback is set, call it */
   if (dhc_states[iface].callback)
 3229ef0:	e0bffe17 	ldw	r2,-8(fp)
 3229ef4:	00c0c9b4 	movhi	r3,806
 3229ef8:	18f36b04 	addi	r3,r3,-12884
 3229efc:	10800f24 	muli	r2,r2,60
 3229f00:	10c5883a 	add	r2,r2,r3
 3229f04:	10800e04 	addi	r2,r2,56
 3229f08:	10800017 	ldw	r2,0(r2)
 3229f0c:	1005003a 	cmpeq	r2,r2,zero
 3229f10:	10000a1e 	bne	r2,zero,3229f3c <dhc_set_state+0x9c>
      dhc_states[iface].callback(iface,state);
 3229f14:	e0bffe17 	ldw	r2,-8(fp)
 3229f18:	00c0c9b4 	movhi	r3,806
 3229f1c:	18f36b04 	addi	r3,r3,-12884
 3229f20:	10800f24 	muli	r2,r2,60
 3229f24:	10c5883a 	add	r2,r2,r3
 3229f28:	10800e04 	addi	r2,r2,56
 3229f2c:	10800017 	ldw	r2,0(r2)
 3229f30:	e13ffe17 	ldw	r4,-8(fp)
 3229f34:	e17fff17 	ldw	r5,-4(fp)
 3229f38:	103ee83a 	callr	r2
}
 3229f3c:	e037883a 	mov	sp,fp
 3229f40:	dfc00117 	ldw	ra,4(sp)
 3229f44:	df000017 	ldw	fp,0(sp)
 3229f48:	dec00204 	addi	sp,sp,8
 3229f4c:	f800283a 	ret

03229f50 <find_opt>:
 * RETURNS:  Return pointer to that code if found, NULL if not found.
 */

u_char * 
find_opt(u_char opcode, u_char * opts)
{
 3229f50:	defffb04 	addi	sp,sp,-20
 3229f54:	df000415 	stw	fp,16(sp)
 3229f58:	df000404 	addi	fp,sp,16
 3229f5c:	e17ffe15 	stw	r5,-8(fp)
 3229f60:	e13ffd05 	stb	r4,-12(fp)
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */
 3229f64:	e0bffe17 	ldw	r2,-8(fp)
 3229f68:	10804e04 	addi	r2,r2,312
 3229f6c:	e0bffc15 	stw	r2,-16(fp)

   while (opts < end)
 3229f70:	00002106 	br	3229ff8 <find_opt+0xa8>
   {
      if (*opts == opcode) /* found it */
 3229f74:	e0bffe17 	ldw	r2,-8(fp)
 3229f78:	10800003 	ldbu	r2,0(r2)
 3229f7c:	10c03fcc 	andi	r3,r2,255
 3229f80:	e0bffd03 	ldbu	r2,-12(fp)
 3229f84:	1880031e 	bne	r3,r2,3229f94 <find_opt+0x44>
         return opts;
 3229f88:	e0bffe17 	ldw	r2,-8(fp)
 3229f8c:	e0bfff15 	stw	r2,-4(fp)
 3229f90:	00001d06 	br	322a008 <find_opt+0xb8>
      if (*opts == DHOP_END)  /* end of options; opcode not found */
 3229f94:	e0bffe17 	ldw	r2,-8(fp)
 3229f98:	10800003 	ldbu	r2,0(r2)
 3229f9c:	10803fcc 	andi	r2,r2,255
 3229fa0:	10803fd8 	cmpnei	r2,r2,255
 3229fa4:	1000021e 	bne	r2,zero,3229fb0 <find_opt+0x60>
         return NULL;
 3229fa8:	e03fff15 	stw	zero,-4(fp)
 3229fac:	00001606 	br	322a008 <find_opt+0xb8>
      if (*opts == DHOP_PAD)  /* PAD has only 1 byte */
 3229fb0:	e0bffe17 	ldw	r2,-8(fp)
 3229fb4:	10800003 	ldbu	r2,0(r2)
 3229fb8:	10803fcc 	andi	r2,r2,255
 3229fbc:	1004c03a 	cmpne	r2,r2,zero
 3229fc0:	1000041e 	bne	r2,zero,3229fd4 <find_opt+0x84>
         opts++;
 3229fc4:	e0bffe17 	ldw	r2,-8(fp)
 3229fc8:	10800044 	addi	r2,r2,1
 3229fcc:	e0bffe15 	stw	r2,-8(fp)
 3229fd0:	00000906 	br	3229ff8 <find_opt+0xa8>
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
 3229fd4:	e0bffe17 	ldw	r2,-8(fp)
 3229fd8:	10800044 	addi	r2,r2,1
 3229fdc:	10800003 	ldbu	r2,0(r2)
 3229fe0:	10803fcc 	andi	r2,r2,255
 3229fe4:	1007883a 	mov	r3,r2
 3229fe8:	e0bffe17 	ldw	r2,-8(fp)
 3229fec:	1885883a 	add	r2,r3,r2
 3229ff0:	10800084 	addi	r2,r2,2
 3229ff4:	e0bffe15 	stw	r2,-8(fp)
u_char * 
find_opt(u_char opcode, u_char * opts)
{
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */

   while (opts < end)
 3229ff8:	e0fffe17 	ldw	r3,-8(fp)
 3229ffc:	e0bffc17 	ldw	r2,-16(fp)
 322a000:	18bfdc36 	bltu	r3,r2,3229f74 <find_opt+0x24>
         opts++;
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
   }
   /* no DHOP_END option?? */
   return NULL;
 322a004:	e03fff15 	stw	zero,-4(fp)
 322a008:	e0bfff17 	ldw	r2,-4(fp)
}
 322a00c:	e037883a 	mov	sp,fp
 322a010:	df000017 	ldw	fp,0(sp)
 322a014:	dec00104 	addi	sp,sp,4
 322a018:	f800283a 	ret

0322a01c <pk_init>:
 * for a PACKET buffer or a data buffer fails, or if there is an inconsistency
 * between (bigbufs + lilbufs) and MAXPACKETS) it returns -1. 
 */

int pk_init (void)
{
 322a01c:	defff704 	addi	sp,sp,-36
 322a020:	dfc00815 	stw	ra,32(sp)
 322a024:	df000715 	stw	fp,28(sp)
 322a028:	df000704 	addi	fp,sp,28
   PACKET packet;
   unsigned i;
   unsigned numpkts = bigbufs + lilbufs;
 322a02c:	d0a03417 	ldw	r2,-32560(gp)
 322a030:	d0e03217 	ldw	r3,-32568(gp)
 322a034:	10c5883a 	add	r2,r2,r3
 322a038:	e0bffc15 	stw	r2,-16(fp)
   u_char align_req;
   
#ifdef ALIGN_BUFS
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
 322a03c:	e03ffb05 	stb	zero,-20(fp)
#endif

   for (i = 0; i < numpkts; i++)
 322a040:	e03ffd15 	stw	zero,-12(fp)
 322a044:	00007e06 	br	322a240 <pk_init+0x224>
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
 322a048:	01000d04 	movi	r4,52
 322a04c:	322b9340 	call	322b934 <npalloc>
 322a050:	e0bffe15 	stw	r2,-8(fp)
      if (packet == NULL)
 322a054:	e0bffe17 	ldw	r2,-8(fp)
 322a058:	1005003a 	cmpeq	r2,r2,zero
 322a05c:	1000871e 	bne	r2,zero,322a27c <pk_init+0x260>
         goto no_pkt_buf;

#ifdef NPDEBUG
      if (i >= MAXPACKETS)
 322a060:	e0bffd17 	ldw	r2,-12(fp)
 322a064:	10800f30 	cmpltui	r2,r2,60
 322a068:	1000061e 	bne	r2,zero,322a084 <pk_init+0x68>
      {
         dprintf("pk_init: bad define\n");
 322a06c:	0100c974 	movhi	r4,805
 322a070:	213cd604 	addi	r4,r4,-3240
 322a074:	32071080 	call	3207108 <puts>
         return -1;
 322a078:	00bfffc4 	movi	r2,-1
 322a07c:	e0bfff15 	stw	r2,-4(fp)
 322a080:	00008406 	br	322a294 <pk_init+0x278>
      }
      pktlog[i] = packet;     /* save for debugging */
 322a084:	e0bffd17 	ldw	r2,-12(fp)
 322a088:	00c0c9b4 	movhi	r3,806
 322a08c:	18f3b004 	addi	r3,r3,-12608
 322a090:	1085883a 	add	r2,r2,r2
 322a094:	1085883a 	add	r2,r2,r2
 322a098:	10c7883a 	add	r3,r2,r3
 322a09c:	e0bffe17 	ldw	r2,-8(fp)
 322a0a0:	18800015 	stw	r2,0(r3)
#endif

      packet->nb_tstamp = 0L;
 322a0a4:	e0bffe17 	ldw	r2,-8(fp)
 322a0a8:	10000515 	stw	zero,20(r2)

      if (i < bigbufs)
 322a0ac:	d0e03417 	ldw	r3,-32560(gp)
 322a0b0:	e0bffd17 	ldw	r2,-12(fp)
 322a0b4:	10c0302e 	bgeu	r2,r3,322a178 <pk_init+0x15c>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
 322a0b8:	d0a03517 	ldw	r2,-32556(gp)
 322a0bc:	11000144 	addi	r4,r2,5
 322a0c0:	322bae00 	call	322bae0 <ncpalloc>
 322a0c4:	1007883a 	mov	r3,r2
 322a0c8:	e0bffe17 	ldw	r2,-8(fp)
 322a0cc:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 322a0d0:	e0bffe17 	ldw	r2,-8(fp)
 322a0d4:	10800117 	ldw	r2,4(r2)
 322a0d8:	1005003a 	cmpeq	r2,r2,zero
 322a0dc:	1000671e 	bne	r2,zero,322a27c <pk_init+0x260>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 322a0e0:	e03ffa15 	stw	zero,-24(fp)
 322a0e4:	00000906 	br	322a10c <pk_init+0xf0>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 322a0e8:	e0bffe17 	ldw	r2,-8(fp)
 322a0ec:	10c00117 	ldw	r3,4(r2)
 322a0f0:	e0bffa17 	ldw	r2,-24(fp)
 322a0f4:	1887883a 	add	r3,r3,r2
 322a0f8:	00801344 	movi	r2,77
 322a0fc:	18800005 	stb	r2,0(r3)
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 322a100:	e0bffa17 	ldw	r2,-24(fp)
 322a104:	10800044 	addi	r2,r2,1
 322a108:	e0bffa15 	stw	r2,-24(fp)
 322a10c:	e0bffa17 	ldw	r2,-24(fp)
 322a110:	10800110 	cmplti	r2,r2,4
 322a114:	103ff41e 	bne	r2,zero,322a0e8 <pk_init+0xcc>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + bigbufsiz + ALIGN_TYPE) = 'M';
 322a118:	e0bffe17 	ldw	r2,-8(fp)
 322a11c:	10c00117 	ldw	r3,4(r2)
 322a120:	d0a03517 	ldw	r2,-32556(gp)
 322a124:	1885883a 	add	r2,r3,r2
 322a128:	10c00104 	addi	r3,r2,4
 322a12c:	00801344 	movi	r2,77
 322a130:	18800005 	stb	r2,0(r3)
            packet->nb_buff += ALIGN_TYPE;   /* bump buf past MMs */
 322a134:	e0bffe17 	ldw	r2,-8(fp)
 322a138:	10800117 	ldw	r2,4(r2)
 322a13c:	10c00104 	addi	r3,r2,4
 322a140:	e0bffe17 	ldw	r2,-8(fp)
 322a144:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 322a148:	e0bffe17 	ldw	r2,-8(fp)
 322a14c:	10800117 	ldw	r2,4(r2)
 322a150:	1005003a 	cmpeq	r2,r2,zero
 322a154:	1000491e 	bne	r2,zero,322a27c <pk_init+0x260>
            goto no_pkt_buf;
         packet->nb_blen = bigbufsiz;
 322a158:	d0e03517 	ldw	r3,-32556(gp)
 322a15c:	e0bffe17 	ldw	r2,-8(fp)
 322a160:	10c00215 	stw	r3,8(r2)
         q_add(&bigfreeq, packet);        /* save it in big pkt free queue */
 322a164:	0100c9b4 	movhi	r4,806
 322a168:	2133ec04 	addi	r4,r4,-12368
 322a16c:	e17ffe17 	ldw	r5,-8(fp)
 322a170:	322a8800 	call	322a880 <putq>
 322a174:	00002f06 	br	322a234 <pk_init+0x218>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
 322a178:	d0a03317 	ldw	r2,-32564(gp)
 322a17c:	11000144 	addi	r4,r2,5
 322a180:	322bae00 	call	322bae0 <ncpalloc>
 322a184:	1007883a 	mov	r3,r2
 322a188:	e0bffe17 	ldw	r2,-8(fp)
 322a18c:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 322a190:	e0bffe17 	ldw	r2,-8(fp)
 322a194:	10800117 	ldw	r2,4(r2)
 322a198:	1005003a 	cmpeq	r2,r2,zero
 322a19c:	1000371e 	bne	r2,zero,322a27c <pk_init+0x260>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 322a1a0:	e03ff915 	stw	zero,-28(fp)
 322a1a4:	00000906 	br	322a1cc <pk_init+0x1b0>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 322a1a8:	e0bffe17 	ldw	r2,-8(fp)
 322a1ac:	10c00117 	ldw	r3,4(r2)
 322a1b0:	e0bff917 	ldw	r2,-28(fp)
 322a1b4:	1887883a 	add	r3,r3,r2
 322a1b8:	00801344 	movi	r2,77
 322a1bc:	18800005 	stb	r2,0(r3)
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 322a1c0:	e0bff917 	ldw	r2,-28(fp)
 322a1c4:	10800044 	addi	r2,r2,1
 322a1c8:	e0bff915 	stw	r2,-28(fp)
 322a1cc:	e0bff917 	ldw	r2,-28(fp)
 322a1d0:	10800110 	cmplti	r2,r2,4
 322a1d4:	103ff41e 	bne	r2,zero,322a1a8 <pk_init+0x18c>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + lilbufsiz + ALIGN_TYPE) = 'M';
 322a1d8:	e0bffe17 	ldw	r2,-8(fp)
 322a1dc:	10c00117 	ldw	r3,4(r2)
 322a1e0:	d0a03317 	ldw	r2,-32564(gp)
 322a1e4:	1885883a 	add	r2,r3,r2
 322a1e8:	10c00104 	addi	r3,r2,4
 322a1ec:	00801344 	movi	r2,77
 322a1f0:	18800005 	stb	r2,0(r3)
            packet->nb_buff += ALIGN_TYPE;
 322a1f4:	e0bffe17 	ldw	r2,-8(fp)
 322a1f8:	10800117 	ldw	r2,4(r2)
 322a1fc:	10c00104 	addi	r3,r2,4
 322a200:	e0bffe17 	ldw	r2,-8(fp)
 322a204:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 322a208:	e0bffe17 	ldw	r2,-8(fp)
 322a20c:	10800117 	ldw	r2,4(r2)
 322a210:	1005003a 	cmpeq	r2,r2,zero
 322a214:	1000191e 	bne	r2,zero,322a27c <pk_init+0x260>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
 322a218:	d0e03317 	ldw	r3,-32564(gp)
 322a21c:	e0bffe17 	ldw	r2,-8(fp)
 322a220:	10c00215 	stw	r3,8(r2)
         q_add(&lilfreeq, packet);        /* save it in little free queue */
 322a224:	0100c9b4 	movhi	r4,806
 322a228:	2133a704 	addi	r4,r4,-12644
 322a22c:	e17ffe17 	ldw	r5,-8(fp)
 322a230:	322a8800 	call	322a880 <putq>
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
#endif

   for (i = 0; i < numpkts; i++)
 322a234:	e0bffd17 	ldw	r2,-12(fp)
 322a238:	10800044 	addi	r2,r2,1
 322a23c:	e0bffd15 	stw	r2,-12(fp)
 322a240:	e0fffd17 	ldw	r3,-12(fp)
 322a244:	e0bffc17 	ldw	r2,-16(fp)
 322a248:	18bf7f36 	bltu	r3,r2,322a048 <pk_init+0x2c>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
         q_add(&lilfreeq, packet);        /* save it in little free queue */
      }
   }
   bigfreeq.q_min = bigbufs;
 322a24c:	d0a03417 	ldw	r2,-32560(gp)
 322a250:	1007883a 	mov	r3,r2
 322a254:	0080c9b4 	movhi	r2,806
 322a258:	10b3ec04 	addi	r2,r2,-12368
 322a25c:	10c00415 	stw	r3,16(r2)
   lilfreeq.q_min = lilbufs;
 322a260:	d0a03217 	ldw	r2,-32568(gp)
 322a264:	1007883a 	mov	r3,r2
 322a268:	0080c9b4 	movhi	r2,806
 322a26c:	10b3a704 	addi	r2,r2,-12644
 322a270:	10c00415 	stw	r3,16(r2)
   heap_curr_mem_hi_watermark = 0;
   /* set the heap's access type to blocking */
   heap_type = HEAP_ACCESS_BLOCKING;
#endif

   return 0;
 322a274:	e03fff15 	stw	zero,-4(fp)
 322a278:	00000606 	br	322a294 <pk_init+0x278>

no_pkt_buf:
#ifdef NPDEBUG
   dprintf("Netinit: calloc failed getting buffer %d\n", i);
 322a27c:	0100c974 	movhi	r4,805
 322a280:	213cdb04 	addi	r4,r4,-3220
 322a284:	e17ffd17 	ldw	r5,-12(fp)
 322a288:	3206de00 	call	3206de0 <printf>
#endif
   return(-1);
 322a28c:	00bfffc4 	movi	r2,-1
 322a290:	e0bfff15 	stw	r2,-4(fp)
 322a294:	e0bfff17 	ldw	r2,-4(fp)
}
 322a298:	e037883a 	mov	sp,fp
 322a29c:	dfc00117 	ldw	ra,4(sp)
 322a2a0:	df000017 	ldw	fp,0(sp)
 322a2a4:	dec00204 	addi	sp,sp,8
 322a2a8:	f800283a 	ret

0322a2ac <pk_alloc>:
 * OUTPUT: 0 if the request cannot be satisfied, or a pointer to the struct
 * netbuf structure that corresponds to the just allocated data buffer.
 */

PACKET pk_alloc(unsigned len)
{
 322a2ac:	defffb04 	addi	sp,sp,-20
 322a2b0:	dfc00415 	stw	ra,16(sp)
 322a2b4:	df000315 	stw	fp,12(sp)
 322a2b8:	df000304 	addi	fp,sp,12
 322a2bc:	e13ffe15 	stw	r4,-8(fp)
   PACKET p;

   if (len > bigbufsiz) /* caller wants oversize buffer? */
 322a2c0:	d0e03517 	ldw	r3,-32556(gp)
 322a2c4:	e0bffe17 	ldw	r2,-8(fp)
 322a2c8:	1880022e 	bgeu	r3,r2,322a2d4 <pk_alloc+0x28>
   {
#ifdef HEAPBUFS
      if ((p = pk_alloc_heapbuf (len)) == NULL)
         return NULL;
#else
      return(NULL);
 322a2cc:	e03fff15 	stw	zero,-4(fp)
 322a2d0:	00002706 	br	322a370 <pk_alloc+0xc4>
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 322a2d4:	d0e03317 	ldw	r3,-32564(gp)
 322a2d8:	e0bffe17 	ldw	r2,-8(fp)
 322a2dc:	18800536 	bltu	r3,r2,322a2f4 <pk_alloc+0x48>
 322a2e0:	0080c9b4 	movhi	r2,806
 322a2e4:	10b3a704 	addi	r2,r2,-12644
 322a2e8:	10800217 	ldw	r2,8(r2)
 322a2ec:	1004c03a 	cmpne	r2,r2,zero
 322a2f0:	1000051e 	bne	r2,zero,322a308 <pk_alloc+0x5c>
         p = (PACKET)getq(&bigfreeq);
 322a2f4:	0100c9b4 	movhi	r4,806
 322a2f8:	2133ec04 	addi	r4,r4,-12368
 322a2fc:	322a7b80 	call	322a7b8 <getq>
 322a300:	e0bffd15 	stw	r2,-12(fp)
      return(NULL);
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 322a304:	00000406 	br	322a318 <pk_alloc+0x6c>
         p = (PACKET)getq(&bigfreeq);
      else
         p = (PACKET)getq(&lilfreeq);
 322a308:	0100c9b4 	movhi	r4,806
 322a30c:	2133a704 	addi	r4,r4,-12644
 322a310:	322a7b80 	call	322a7b8 <getq>
 322a314:	e0bffd15 	stw	r2,-12(fp)

      if (!p)
 322a318:	e0bffd17 	ldw	r2,-12(fp)
 322a31c:	1004c03a 	cmpne	r2,r2,zero
 322a320:	1000021e 	bne	r2,zero,322a32c <pk_alloc+0x80>
         return NULL;
 322a324:	e03fff15 	stw	zero,-4(fp)
 322a328:	00001106 	br	322a370 <pk_alloc+0xc4>
   }

   p->nb_prot = p->nb_buff + MaxLnh;   /* point past biggest mac header */
 322a32c:	e0bffd17 	ldw	r2,-12(fp)
 322a330:	10c00117 	ldw	r3,4(r2)
 322a334:	0080c974 	movhi	r2,805
 322a338:	10931a04 	addi	r2,r2,19560
 322a33c:	10800017 	ldw	r2,0(r2)
 322a340:	1887883a 	add	r3,r3,r2
 322a344:	e0bffd17 	ldw	r2,-12(fp)
 322a348:	10c00315 	stw	r3,12(r2)
   p->nb_plen = 0;   /* no protocol data there yet */
 322a34c:	e0bffd17 	ldw	r2,-12(fp)
 322a350:	10000415 	stw	zero,16(r2)
   p->net = NULL;
 322a354:	e0bffd17 	ldw	r2,-12(fp)
 322a358:	10000615 	stw	zero,24(r2)
   p->nexthop = NULL;      /* no next hop  */
   p->nb_pmtu = 1240;      /* Set minimum IPv6 Path MTU */
#endif   /* IP_V6 */
#endif /* LINKED_PKTS */

   p->inuse = 1;  /* initially buffer in use by 1 user */
 322a35c:	e0fffd17 	ldw	r3,-12(fp)
 322a360:	00800044 	movi	r2,1
 322a364:	18800915 	stw	r2,36(r3)

   /* note that 'type' and 'fhost' fields are not set in pk_alloc () */
   return(p);
 322a368:	e0bffd17 	ldw	r2,-12(fp)
 322a36c:	e0bfff15 	stw	r2,-4(fp)
 322a370:	e0bfff17 	ldw	r2,-4(fp)
}
 322a374:	e037883a 	mov	sp,fp
 322a378:	dfc00117 	ldw	ra,4(sp)
 322a37c:	df000017 	ldw	fp,0(sp)
 322a380:	dec00204 	addi	sp,sp,8
 322a384:	f800283a 	ret

0322a388 <pk_validate>:
 * OUTPUT: 0 if the buffer being freed was successfully validated, or
 * -1 if the validation failed.
 */

int pk_validate(PACKET pkt)   /* check if pk_free() can free the pkt */
{
 322a388:	defffa04 	addi	sp,sp,-24
 322a38c:	dfc00515 	stw	ra,20(sp)
 322a390:	df000415 	stw	fp,16(sp)
 322a394:	df000404 	addi	fp,sp,16
 322a398:	e13ffe15 	stw	r4,-8(fp)
   /* If packet link is non-zero, then this packet is
    * part of a chain and deleted this packet would break
    * the chain and cause memory leak for subsequent pkts.
    * Note that heapbufs do not use the 'next' field at all.
    */
   if ((pkt->next) && (pkt->inuse >= 1))
 322a39c:	e0bffe17 	ldw	r2,-8(fp)
 322a3a0:	10800017 	ldw	r2,0(r2)
 322a3a4:	1005003a 	cmpeq	r2,r2,zero
 322a3a8:	1000101e 	bne	r2,zero,322a3ec <pk_validate+0x64>
 322a3ac:	e0bffe17 	ldw	r2,-8(fp)
 322a3b0:	10800917 	ldw	r2,36(r2)
 322a3b4:	1005003a 	cmpeq	r2,r2,zero
 322a3b8:	10000c1e 	bne	r2,zero,322a3ec <pk_validate+0x64>
   {
      INCR_SHARED_VAR (memestats, INCONSISTENT_LOCATION_ERR, 1);   
 322a3bc:	322b0f00 	call	322b0f0 <irq_Mask>
 322a3c0:	0080c9b4 	movhi	r2,806
 322a3c4:	10b3ac04 	addi	r2,r2,-12624
 322a3c8:	10800317 	ldw	r2,12(r2)
 322a3cc:	10c00044 	addi	r3,r2,1
 322a3d0:	0080c9b4 	movhi	r2,806
 322a3d4:	10b3ac04 	addi	r2,r2,-12624
 322a3d8:	10c00315 	stw	r3,12(r2)
 322a3dc:	322b14c0 	call	322b14c <irq_Unmask>
      return -1;
 322a3e0:	00bfffc4 	movi	r2,-1
 322a3e4:	e0bfff15 	stw	r2,-4(fp)
 322a3e8:	00008f06 	br	322a628 <pk_validate+0x2a0>
   }
   else  
#endif /* HEAPBUFS */
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
 322a3ec:	e0bffe17 	ldw	r2,-8(fp)
 322a3f0:	10c00217 	ldw	r3,8(r2)
 322a3f4:	d0a03517 	ldw	r2,-32556(gp)
 322a3f8:	1880221e 	bne	r3,r2,322a484 <pk_validate+0xfc>
      {
         ENTER_CRIT_SECTION(&bigfreeq);
 322a3fc:	322b0f00 	call	322b0f0 <irq_Mask>
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 322a400:	0080c9b4 	movhi	r2,806
 322a404:	10b3ec04 	addi	r2,r2,-12368
 322a408:	10800017 	ldw	r2,0(r2)
 322a40c:	e0bffd15 	stw	r2,-12(fp)
 322a410:	00001706 	br	322a470 <pk_validate+0xe8>
            if (p == pkt)
 322a414:	e0fffd17 	ldw	r3,-12(fp)
 322a418:	e0bffe17 	ldw	r2,-8(fp)
 322a41c:	1880111e 	bne	r3,r2,322a464 <pk_validate+0xdc>
            {
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
 322a420:	0100c974 	movhi	r4,805
 322a424:	213ce604 	addi	r4,r4,-3176
 322a428:	e17ffe17 	ldw	r5,-8(fp)
 322a42c:	3206de00 	call	3206de0 <printf>
               EXIT_CRIT_SECTION(&bigfreeq);
 322a430:	322b14c0 	call	322b14c <irq_Unmask>
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 322a434:	322b0f00 	call	322b0f0 <irq_Mask>
 322a438:	0080c9b4 	movhi	r2,806
 322a43c:	10b3ac04 	addi	r2,r2,-12624
 322a440:	10800217 	ldw	r2,8(r2)
 322a444:	10c00044 	addi	r3,r2,1
 322a448:	0080c9b4 	movhi	r2,806
 322a44c:	10b3ac04 	addi	r2,r2,-12624
 322a450:	10c00215 	stw	r3,8(r2)
 322a454:	322b14c0 	call	322b14c <irq_Unmask>
               return -1;
 322a458:	00bfffc4 	movi	r2,-1
 322a45c:	e0bfff15 	stw	r2,-4(fp)
 322a460:	00007106 	br	322a628 <pk_validate+0x2a0>
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
      {
         ENTER_CRIT_SECTION(&bigfreeq);
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 322a464:	e0bffd17 	ldw	r2,-12(fp)
 322a468:	10800017 	ldw	r2,0(r2)
 322a46c:	e0bffd15 	stw	r2,-12(fp)
 322a470:	e0bffd17 	ldw	r2,-12(fp)
 322a474:	1004c03a 	cmpne	r2,r2,zero
 322a478:	103fe61e 	bne	r2,zero,322a414 <pk_validate+0x8c>
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
               EXIT_CRIT_SECTION(&bigfreeq);
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
               return -1;
            }
         EXIT_CRIT_SECTION(&bigfreeq);
 322a47c:	322b14c0 	call	322b14c <irq_Unmask>
 322a480:	00003206 	br	322a54c <pk_validate+0x1c4>
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
 322a484:	e0bffe17 	ldw	r2,-8(fp)
 322a488:	10c00217 	ldw	r3,8(r2)
 322a48c:	d0a03317 	ldw	r2,-32564(gp)
 322a490:	1880221e 	bne	r3,r2,322a51c <pk_validate+0x194>
      {
         ENTER_CRIT_SECTION(&lilfreeq);
 322a494:	322b0f00 	call	322b0f0 <irq_Mask>
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 322a498:	0080c9b4 	movhi	r2,806
 322a49c:	10b3a704 	addi	r2,r2,-12644
 322a4a0:	10800017 	ldw	r2,0(r2)
 322a4a4:	e0bffd15 	stw	r2,-12(fp)
 322a4a8:	00001706 	br	322a508 <pk_validate+0x180>
            if (p == pkt)
 322a4ac:	e0fffd17 	ldw	r3,-12(fp)
 322a4b0:	e0bffe17 	ldw	r2,-8(fp)
 322a4b4:	1880111e 	bne	r3,r2,322a4fc <pk_validate+0x174>
         {
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
 322a4b8:	0100c974 	movhi	r4,805
 322a4bc:	213cf004 	addi	r4,r4,-3136
 322a4c0:	e17ffe17 	ldw	r5,-8(fp)
 322a4c4:	3206de00 	call	3206de0 <printf>
            EXIT_CRIT_SECTION(&lilfreeq);
 322a4c8:	322b14c0 	call	322b14c <irq_Unmask>
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 322a4cc:	322b0f00 	call	322b0f0 <irq_Mask>
 322a4d0:	0080c9b4 	movhi	r2,806
 322a4d4:	10b3ac04 	addi	r2,r2,-12624
 322a4d8:	10800217 	ldw	r2,8(r2)
 322a4dc:	10c00044 	addi	r3,r2,1
 322a4e0:	0080c9b4 	movhi	r2,806
 322a4e4:	10b3ac04 	addi	r2,r2,-12624
 322a4e8:	10c00215 	stw	r3,8(r2)
 322a4ec:	322b14c0 	call	322b14c <irq_Unmask>
            return -1;
 322a4f0:	00bfffc4 	movi	r2,-1
 322a4f4:	e0bfff15 	stw	r2,-4(fp)
 322a4f8:	00004b06 	br	322a628 <pk_validate+0x2a0>
         EXIT_CRIT_SECTION(&bigfreeq);
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
      {
         ENTER_CRIT_SECTION(&lilfreeq);
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 322a4fc:	e0bffd17 	ldw	r2,-12(fp)
 322a500:	10800017 	ldw	r2,0(r2)
 322a504:	e0bffd15 	stw	r2,-12(fp)
 322a508:	e0bffd17 	ldw	r2,-12(fp)
 322a50c:	1004c03a 	cmpne	r2,r2,zero
 322a510:	103fe61e 	bne	r2,zero,322a4ac <pk_validate+0x124>
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
            EXIT_CRIT_SECTION(&lilfreeq);
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
            return -1;
         }
         EXIT_CRIT_SECTION(&lilfreeq);
 322a514:	322b14c0 	call	322b14c <irq_Unmask>
 322a518:	00000c06 	br	322a54c <pk_validate+0x1c4>
      }
      else
      {
         /* log an error */
         INCR_SHARED_VAR (memestats, BAD_REGULAR_BUF_LEN_ERR, 1);
 322a51c:	322b0f00 	call	322b0f0 <irq_Mask>
 322a520:	0080c9b4 	movhi	r2,806
 322a524:	10b3ac04 	addi	r2,r2,-12624
 322a528:	10800017 	ldw	r2,0(r2)
 322a52c:	10c00044 	addi	r3,r2,1
 322a530:	0080c9b4 	movhi	r2,806
 322a534:	10b3ac04 	addi	r2,r2,-12624
 322a538:	10c00015 	stw	r3,0(r2)
 322a53c:	322b14c0 	call	322b14c <irq_Unmask>
         return -1;
 322a540:	00bfffc4 	movi	r2,-1
 322a544:	e0bfff15 	stw	r2,-4(fp)
 322a548:	00003706 	br	322a628 <pk_validate+0x2a0>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 322a54c:	00800104 	movi	r2,4
 322a550:	e0bffc15 	stw	r2,-16(fp)
 322a554:	00001906 	br	322a5bc <pk_validate+0x234>
   {
      if (*(pkt->nb_buff - j) != 'M')
 322a558:	e0bffe17 	ldw	r2,-8(fp)
 322a55c:	10c00117 	ldw	r3,4(r2)
 322a560:	e0bffc17 	ldw	r2,-16(fp)
 322a564:	1885c83a 	sub	r2,r3,r2
 322a568:	10800003 	ldbu	r2,0(r2)
 322a56c:	10803fcc 	andi	r2,r2,255
 322a570:	1080201c 	xori	r2,r2,128
 322a574:	10bfe004 	addi	r2,r2,-128
 322a578:	10801360 	cmpeqi	r2,r2,77
 322a57c:	10000c1e 	bne	r2,zero,322a5b0 <pk_validate+0x228>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 322a580:	322b0f00 	call	322b0f0 <irq_Mask>
 322a584:	0080c9b4 	movhi	r2,806
 322a588:	10b3ac04 	addi	r2,r2,-12624
 322a58c:	10800117 	ldw	r2,4(r2)
 322a590:	10c00044 	addi	r3,r2,1
 322a594:	0080c9b4 	movhi	r2,806
 322a598:	10b3ac04 	addi	r2,r2,-12624
 322a59c:	10c00115 	stw	r3,4(r2)
 322a5a0:	322b14c0 	call	322b14c <irq_Unmask>
         return -1;
 322a5a4:	00bfffc4 	movi	r2,-1
 322a5a8:	e0bfff15 	stw	r2,-4(fp)
 322a5ac:	00001e06 	br	322a628 <pk_validate+0x2a0>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 322a5b0:	e0bffc17 	ldw	r2,-16(fp)
 322a5b4:	10bfffc4 	addi	r2,r2,-1
 322a5b8:	e0bffc15 	stw	r2,-16(fp)
 322a5bc:	e0bffc17 	ldw	r2,-16(fp)
 322a5c0:	10800048 	cmpgei	r2,r2,1
 322a5c4:	103fe41e 	bne	r2,zero,322a558 <pk_validate+0x1d0>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
         return -1;
      }
   }
   if (*(pkt->nb_buff + pkt->nb_blen) != 'M')
 322a5c8:	e0bffe17 	ldw	r2,-8(fp)
 322a5cc:	10c00117 	ldw	r3,4(r2)
 322a5d0:	e0bffe17 	ldw	r2,-8(fp)
 322a5d4:	10800217 	ldw	r2,8(r2)
 322a5d8:	1885883a 	add	r2,r3,r2
 322a5dc:	10800003 	ldbu	r2,0(r2)
 322a5e0:	10803fcc 	andi	r2,r2,255
 322a5e4:	1080201c 	xori	r2,r2,128
 322a5e8:	10bfe004 	addi	r2,r2,-128
 322a5ec:	10801360 	cmpeqi	r2,r2,77
 322a5f0:	10000c1e 	bne	r2,zero,322a624 <pk_validate+0x29c>
   {
      INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 322a5f4:	322b0f00 	call	322b0f0 <irq_Mask>
 322a5f8:	0080c9b4 	movhi	r2,806
 322a5fc:	10b3ac04 	addi	r2,r2,-12624
 322a600:	10800117 	ldw	r2,4(r2)
 322a604:	10c00044 	addi	r3,r2,1
 322a608:	0080c9b4 	movhi	r2,806
 322a60c:	10b3ac04 	addi	r2,r2,-12624
 322a610:	10c00115 	stw	r3,4(r2)
 322a614:	322b14c0 	call	322b14c <irq_Unmask>
      return -1;
 322a618:	00bfffc4 	movi	r2,-1
 322a61c:	e0bfff15 	stw	r2,-4(fp)
 322a620:	00000106 	br	322a628 <pk_validate+0x2a0>
   }
#endif /* NPDEBUG */

   return 0;
 322a624:	e03fff15 	stw	zero,-4(fp)
 322a628:	e0bfff17 	ldw	r2,-4(fp)
}
 322a62c:	e037883a 	mov	sp,fp
 322a630:	dfc00117 	ldw	ra,4(sp)
 322a634:	df000017 	ldw	fp,0(sp)
 322a638:	dec00204 	addi	sp,sp,8
 322a63c:	f800283a 	ret

0322a640 <pk_free>:
 *
 * OUTPUT: None.
 */

void pk_free(PACKET pkt)   /* PACKET to place in free queue */
{
 322a640:	defffc04 	addi	sp,sp,-16
 322a644:	dfc00315 	stw	ra,12(sp)
 322a648:	df000215 	stw	fp,8(sp)
 322a64c:	df000204 	addi	fp,sp,8
 322a650:	e13fff15 	stw	r4,-4(fp)
      PACKET pknext;
      pknext = pkt->pk_next;
#endif /* LINKED_PKTS */

      /* validate the pkt before freeing */
      e = pk_validate(pkt);
 322a654:	e13fff17 	ldw	r4,-4(fp)
 322a658:	322a3880 	call	322a388 <pk_validate>
 322a65c:	e0bffe15 	stw	r2,-8(fp)
      if (e)
 322a660:	e0bffe17 	ldw	r2,-8(fp)
 322a664:	1004c03a 	cmpne	r2,r2,zero
 322a668:	10001b1e 	bne	r2,zero,322a6d8 <pk_free+0x98>
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
 322a66c:	e0bfff17 	ldw	r2,-4(fp)
 322a670:	10c00917 	ldw	r3,36(r2)
 322a674:	188000a8 	cmpgeui	r2,r3,2
 322a678:	1009883a 	mov	r4,r2
 322a67c:	18ffffc4 	addi	r3,r3,-1
 322a680:	e0bfff17 	ldw	r2,-4(fp)
 322a684:	10c00915 	stw	r3,36(r2)
 322a688:	20803fcc 	andi	r2,r4,255
 322a68c:	1004c03a 	cmpne	r2,r2,zero
 322a690:	1000111e 	bne	r2,zero,322a6d8 <pk_free+0x98>
         pk_free_heapbuf (pkt);
      }
      else 
#endif /* HEAPBUFS */
      {
         if (pkt->nb_blen == bigbufsiz)
 322a694:	e0bfff17 	ldw	r2,-4(fp)
 322a698:	10c00217 	ldw	r3,8(r2)
 322a69c:	d0a03517 	ldw	r2,-32556(gp)
 322a6a0:	1880051e 	bne	r3,r2,322a6b8 <pk_free+0x78>
            q_add(&bigfreeq, (qp)pkt);
 322a6a4:	e17fff17 	ldw	r5,-4(fp)
 322a6a8:	0100c9b4 	movhi	r4,806
 322a6ac:	2133ec04 	addi	r4,r4,-12368
 322a6b0:	322a8800 	call	322a880 <putq>
 322a6b4:	00000806 	br	322a6d8 <pk_free+0x98>
         else if (pkt->nb_blen == lilbufsiz)
 322a6b8:	e0bfff17 	ldw	r2,-4(fp)
 322a6bc:	10c00217 	ldw	r3,8(r2)
 322a6c0:	d0a03317 	ldw	r2,-32564(gp)
 322a6c4:	1880041e 	bne	r3,r2,322a6d8 <pk_free+0x98>
            q_add(&lilfreeq, (qp)pkt);
 322a6c8:	e17fff17 	ldw	r5,-4(fp)
 322a6cc:	0100c9b4 	movhi	r4,806
 322a6d0:	2133a704 	addi	r4,r4,-12644
 322a6d4:	322a8800 	call	322a880 <putq>
#ifdef LINKED_PKTS
      pkt = pknext;
   }
#endif 

}
 322a6d8:	e037883a 	mov	sp,fp
 322a6dc:	dfc00117 	ldw	ra,4(sp)
 322a6e0:	df000017 	ldw	fp,0(sp)
 322a6e4:	dec00204 	addi	sp,sp,8
 322a6e8:	f800283a 	ret

0322a6ec <pk_get_max_intrsafe_buf_len>:
 *
 * OUTPUT: This function always returns the length of a big buffer (bigbufsiz).
 */

unsigned pk_get_max_intrsafe_buf_len(void)
{
 322a6ec:	deffff04 	addi	sp,sp,-4
 322a6f0:	df000015 	stw	fp,0(sp)
 322a6f4:	d839883a 	mov	fp,sp
   return bigbufsiz;
 322a6f8:	d0a03517 	ldw	r2,-32556(gp)
}
 322a6fc:	e037883a 	mov	sp,fp
 322a700:	df000017 	ldw	fp,0(sp)
 322a704:	dec00104 	addi	sp,sp,4
 322a708:	f800283a 	ret

0322a70c <dump_buf_estats>:
 *
 * OUTPUT: This function always returns 0.
 */

int dump_buf_estats (void * pio)
{
 322a70c:	defff904 	addi	sp,sp,-28
 322a710:	dfc00615 	stw	ra,24(sp)
 322a714:	df000515 	stw	fp,20(sp)
 322a718:	df000504 	addi	fp,sp,20
 322a71c:	e13fff15 	stw	r4,-4(fp)
   u_long mlocal [MEMERR_NUM_STATS];

   LOCK_NET_RESOURCE(FREEQ_RESID);
 322a720:	01000084 	movi	r4,2
 322a724:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   ENTER_CRIT_SECTION(&memestats);
 322a728:	322b0f00 	call	322b0f0 <irq_Mask>
   MEMCPY (&mlocal, &memestats, sizeof(memestats));
 322a72c:	00c0c9b4 	movhi	r3,806
 322a730:	18f3ac04 	addi	r3,r3,-12624
 322a734:	18800017 	ldw	r2,0(r3)
 322a738:	e0bffb15 	stw	r2,-20(fp)
 322a73c:	18800117 	ldw	r2,4(r3)
 322a740:	e0bffc15 	stw	r2,-16(fp)
 322a744:	18800217 	ldw	r2,8(r3)
 322a748:	e0bffd15 	stw	r2,-12(fp)
 322a74c:	18800317 	ldw	r2,12(r3)
 322a750:	e0bffe15 	stw	r2,-8(fp)
   EXIT_CRIT_SECTION(&memestats);
 322a754:	322b14c0 	call	322b14c <irq_Unmask>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322a758:	01000084 	movi	r4,2
 322a75c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   ns_printf(pio, "Regular buffer error statistics:\n");
 322a760:	e13fff17 	ldw	r4,-4(fp)
 322a764:	0140c974 	movhi	r5,805
 322a768:	297cfa04 	addi	r5,r5,-3096
 322a76c:	322637c0 	call	322637c <ns_printf>
   ns_printf(pio, "Bad buffer length %lu, Guard band violations %lu\n",mlocal[BAD_REGULAR_BUF_LEN_ERR],mlocal[GUARD_BAND_VIOLATED_ERR]);
 322a770:	e1bffb17 	ldw	r6,-20(fp)
 322a774:	e1fffc17 	ldw	r7,-16(fp)
 322a778:	e13fff17 	ldw	r4,-4(fp)
 322a77c:	0140c974 	movhi	r5,805
 322a780:	297d0304 	addi	r5,r5,-3060
 322a784:	322637c0 	call	322637c <ns_printf>
   ns_printf(pio, "Multiple frees %lu, Inconsistent location %lu\n",mlocal[MULTIPLE_FREE_ERR],mlocal[INCONSISTENT_LOCATION_ERR]);
 322a788:	e1bffd17 	ldw	r6,-12(fp)
 322a78c:	e1fffe17 	ldw	r7,-8(fp)
 322a790:	e13fff17 	ldw	r4,-4(fp)
 322a794:	0140c974 	movhi	r5,805
 322a798:	297d1004 	addi	r5,r5,-3008
 322a79c:	322637c0 	call	322637c <ns_printf>

   return 0;
 322a7a0:	0005883a 	mov	r2,zero
}
 322a7a4:	e037883a 	mov	sp,fp
 322a7a8:	dfc00117 	ldw	ra,4(sp)
 322a7ac:	df000017 	ldw	fp,0(sp)
 322a7b0:	dec00204 	addi	sp,sp,8
 322a7b4:	f800283a 	ret

0322a7b8 <getq>:
 * RETURNS: pointer to the first element if any, or 0 if the queue is empty.
 */

void*
getq(queue * q)
{
 322a7b8:	defffb04 	addi	sp,sp,-20
 322a7bc:	dfc00415 	stw	ra,16(sp)
 322a7c0:	df000315 	stw	fp,12(sp)
 322a7c4:	df000304 	addi	fp,sp,12
 322a7c8:	e13ffe15 	stw	r4,-8(fp)
   q_elt   temp;        /* temp for result */


   ENTER_CRIT_SECTION(q);     /* shut off ints, save old state */   
 322a7cc:	322b0f00 	call	322b0f0 <irq_Mask>

   LOCKNET_CHECK(q);          /* make sure queue is protected */

   if ((temp = q->q_head) == 0)  /* queue empty? */
 322a7d0:	e0bffe17 	ldw	r2,-8(fp)
 322a7d4:	10800017 	ldw	r2,0(r2)
 322a7d8:	e0bffd15 	stw	r2,-12(fp)
 322a7dc:	e0bffd17 	ldw	r2,-12(fp)
 322a7e0:	1004c03a 	cmpne	r2,r2,zero
 322a7e4:	1000031e 	bne	r2,zero,322a7f4 <getq+0x3c>
   {
      EXIT_CRIT_SECTION(q);
 322a7e8:	322b14c0 	call	322b14c <irq_Unmask>
      return (0);             /* yes, show none */
 322a7ec:	e03fff15 	stw	zero,-4(fp)
 322a7f0:	00001d06 	br	322a868 <getq+0xb0>
   }

   q->q_head = temp->qe_next; /* else unlink */
 322a7f4:	e0bffd17 	ldw	r2,-12(fp)
 322a7f8:	10c00017 	ldw	r3,0(r2)
 322a7fc:	e0bffe17 	ldw	r2,-8(fp)
 322a800:	10c00015 	stw	r3,0(r2)
   temp->qe_next = 0;         /* avoid dangling pointers */
 322a804:	e0bffd17 	ldw	r2,-12(fp)
 322a808:	10000015 	stw	zero,0(r2)
   if (q->q_head == 0)        /* queue empty? */
 322a80c:	e0bffe17 	ldw	r2,-8(fp)
 322a810:	10800017 	ldw	r2,0(r2)
 322a814:	1004c03a 	cmpne	r2,r2,zero
 322a818:	1000021e 	bne	r2,zero,322a824 <getq+0x6c>
      q->q_tail = 0;          /* yes, update tail pointer too */
 322a81c:	e0bffe17 	ldw	r2,-8(fp)
 322a820:	10000115 	stw	zero,4(r2)
   q->q_len--;                /* update queue length */
 322a824:	e0bffe17 	ldw	r2,-8(fp)
 322a828:	10800217 	ldw	r2,8(r2)
 322a82c:	10ffffc4 	addi	r3,r2,-1
 322a830:	e0bffe17 	ldw	r2,-8(fp)
 322a834:	10c00215 	stw	r3,8(r2)
   if (q->q_len < q->q_min)
 322a838:	e0bffe17 	ldw	r2,-8(fp)
 322a83c:	10c00217 	ldw	r3,8(r2)
 322a840:	e0bffe17 	ldw	r2,-8(fp)
 322a844:	10800417 	ldw	r2,16(r2)
 322a848:	1880040e 	bge	r3,r2,322a85c <getq+0xa4>
      q->q_min = q->q_len;
 322a84c:	e0bffe17 	ldw	r2,-8(fp)
 322a850:	10c00217 	ldw	r3,8(r2)
 322a854:	e0bffe17 	ldw	r2,-8(fp)
 322a858:	10c00415 	stw	r3,16(r2)

   QUEUE_CHECK(q);         /* make sure queue is not corrupted */

   EXIT_CRIT_SECTION(q);   /* restore caller's int state */
 322a85c:	322b14c0 	call	322b14c <irq_Unmask>

   return ((void*)temp);
 322a860:	e0bffd17 	ldw	r2,-12(fp)
 322a864:	e0bfff15 	stw	r2,-4(fp)
 322a868:	e0bfff17 	ldw	r2,-4(fp)
}
 322a86c:	e037883a 	mov	sp,fp
 322a870:	dfc00117 	ldw	ra,4(sp)
 322a874:	df000017 	ldw	fp,0(sp)
 322a878:	dec00204 	addi	sp,sp,8
 322a87c:	f800283a 	ret

0322a880 <putq>:

void
putq(
   queue   *   q,       /* the queue */
   void *   elt)        /* element to delete */
{
 322a880:	defffc04 	addi	sp,sp,-16
 322a884:	dfc00315 	stw	ra,12(sp)
 322a888:	df000215 	stw	fp,8(sp)
 322a88c:	df000204 	addi	fp,sp,8
 322a890:	e13ffe15 	stw	r4,-8(fp)
 322a894:	e17fff15 	stw	r5,-4(fp)
   ENTER_CRIT_SECTION(q);
 322a898:	322b0f00 	call	322b0f0 <irq_Mask>
   LOCKNET_CHECK(q);       /* make sure queue is protected */
   q_addt(q, (qp)elt);     /* use macro to do work */
 322a89c:	e0bfff17 	ldw	r2,-4(fp)
 322a8a0:	10000015 	stw	zero,0(r2)
 322a8a4:	e0bffe17 	ldw	r2,-8(fp)
 322a8a8:	10800017 	ldw	r2,0(r2)
 322a8ac:	1004c03a 	cmpne	r2,r2,zero
 322a8b0:	1000041e 	bne	r2,zero,322a8c4 <putq+0x44>
 322a8b4:	e0ffff17 	ldw	r3,-4(fp)
 322a8b8:	e0bffe17 	ldw	r2,-8(fp)
 322a8bc:	10c00015 	stw	r3,0(r2)
 322a8c0:	00000406 	br	322a8d4 <putq+0x54>
 322a8c4:	e0bffe17 	ldw	r2,-8(fp)
 322a8c8:	10c00117 	ldw	r3,4(r2)
 322a8cc:	e0bfff17 	ldw	r2,-4(fp)
 322a8d0:	18800015 	stw	r2,0(r3)
 322a8d4:	e0ffff17 	ldw	r3,-4(fp)
 322a8d8:	e0bffe17 	ldw	r2,-8(fp)
 322a8dc:	10c00115 	stw	r3,4(r2)
 322a8e0:	e0bffe17 	ldw	r2,-8(fp)
 322a8e4:	10800217 	ldw	r2,8(r2)
 322a8e8:	10c00044 	addi	r3,r2,1
 322a8ec:	e0bffe17 	ldw	r2,-8(fp)
 322a8f0:	10c00215 	stw	r3,8(r2)
 322a8f4:	e0bffe17 	ldw	r2,-8(fp)
 322a8f8:	10c00217 	ldw	r3,8(r2)
 322a8fc:	e0bffe17 	ldw	r2,-8(fp)
 322a900:	10800317 	ldw	r2,12(r2)
 322a904:	10c0040e 	bge	r2,r3,322a918 <putq+0x98>
 322a908:	e0bffe17 	ldw	r2,-8(fp)
 322a90c:	10c00217 	ldw	r3,8(r2)
 322a910:	e0bffe17 	ldw	r2,-8(fp)
 322a914:	10c00315 	stw	r3,12(r2)
   QUEUE_CHECK(q);         /* make sure queue is not corrupted */
   EXIT_CRIT_SECTION(q);   /* restore int state */
 322a918:	322b14c0 	call	322b14c <irq_Unmask>
}
 322a91c:	e037883a 	mov	sp,fp
 322a920:	dfc00117 	ldw	ra,4(sp)
 322a924:	df000017 	ldw	fp,0(sp)
 322a928:	dec00204 	addi	sp,sp,8
 322a92c:	f800283a 	ret

0322a930 <qdel>:
 * RETURNS: Return pointer to queue member if found, else NULL. 
 */

qp
qdel(queue * q, void * elt)
{
 322a930:	defff904 	addi	sp,sp,-28
 322a934:	dfc00615 	stw	ra,24(sp)
 322a938:	df000515 	stw	fp,20(sp)
 322a93c:	df000504 	addi	fp,sp,20
 322a940:	e13ffd15 	stw	r4,-12(fp)
 322a944:	e17ffe15 	stw	r5,-8(fp)
   qp qptr;
   qp qlast;

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
 322a948:	322b0f00 	call	322b0f0 <irq_Mask>
   qptr = q->q_head;
 322a94c:	e0bffd17 	ldw	r2,-12(fp)
 322a950:	10800017 	ldw	r2,0(r2)
 322a954:	e0bffc15 	stw	r2,-16(fp)
   qlast = NULL;
 322a958:	e03ffb15 	stw	zero,-20(fp)
   while (qptr)
 322a95c:	00002d06 	br	322aa14 <qdel+0xe4>
   {
      if (qptr == (qp)elt)
 322a960:	e0fffe17 	ldw	r3,-8(fp)
 322a964:	e0bffc17 	ldw	r2,-16(fp)
 322a968:	10c0251e 	bne	r2,r3,322aa00 <qdel+0xd0>
      {
         /* found our item; dequeue it */
         if (qlast)
 322a96c:	e0bffb17 	ldw	r2,-20(fp)
 322a970:	1005003a 	cmpeq	r2,r2,zero
 322a974:	1000051e 	bne	r2,zero,322a98c <qdel+0x5c>
            qlast->qe_next = qptr->qe_next;
 322a978:	e0bffc17 	ldw	r2,-16(fp)
 322a97c:	10c00017 	ldw	r3,0(r2)
 322a980:	e0bffb17 	ldw	r2,-20(fp)
 322a984:	10c00015 	stw	r3,0(r2)
 322a988:	00000406 	br	322a99c <qdel+0x6c>
         else     /* item was at head of queqe */
            q->q_head = qptr->qe_next;
 322a98c:	e0bffc17 	ldw	r2,-16(fp)
 322a990:	10c00017 	ldw	r3,0(r2)
 322a994:	e0bffd17 	ldw	r2,-12(fp)
 322a998:	10c00015 	stw	r3,0(r2)

         /* fix queue tail pointer if needed */
         if (q->q_tail == (qp)elt)
 322a99c:	e0bffd17 	ldw	r2,-12(fp)
 322a9a0:	10c00117 	ldw	r3,4(r2)
 322a9a4:	e0bffe17 	ldw	r2,-8(fp)
 322a9a8:	1880031e 	bne	r3,r2,322a9b8 <qdel+0x88>
            q->q_tail = qlast;
 322a9ac:	e0fffd17 	ldw	r3,-12(fp)
 322a9b0:	e0bffb17 	ldw	r2,-20(fp)
 322a9b4:	18800115 	stw	r2,4(r3)

         /* fix queue counters */
         q->q_len--;
 322a9b8:	e0bffd17 	ldw	r2,-12(fp)
 322a9bc:	10800217 	ldw	r2,8(r2)
 322a9c0:	10ffffc4 	addi	r3,r2,-1
 322a9c4:	e0bffd17 	ldw	r2,-12(fp)
 322a9c8:	10c00215 	stw	r3,8(r2)
         if (q->q_len < q->q_min)
 322a9cc:	e0bffd17 	ldw	r2,-12(fp)
 322a9d0:	10c00217 	ldw	r3,8(r2)
 322a9d4:	e0bffd17 	ldw	r2,-12(fp)
 322a9d8:	10800417 	ldw	r2,16(r2)
 322a9dc:	1880040e 	bge	r3,r2,322a9f0 <qdel+0xc0>
            q->q_min = q->q_len;
 322a9e0:	e0bffd17 	ldw	r2,-12(fp)
 322a9e4:	10c00217 	ldw	r3,8(r2)
 322a9e8:	e0bffd17 	ldw	r2,-12(fp)
 322a9ec:	10c00415 	stw	r3,16(r2)
         EXIT_CRIT_SECTION(q);   /* restore int state */
 322a9f0:	322b14c0 	call	322b14c <irq_Unmask>
         return (qp)elt;   /* success exit point */
 322a9f4:	e0bffe17 	ldw	r2,-8(fp)
 322a9f8:	e0bfff15 	stw	r2,-4(fp)
 322a9fc:	00000a06 	br	322aa28 <qdel+0xf8>
      }
      qlast = qptr;
 322aa00:	e0bffc17 	ldw	r2,-16(fp)
 322aa04:	e0bffb15 	stw	r2,-20(fp)
      qptr = qptr->qe_next;
 322aa08:	e0bffc17 	ldw	r2,-16(fp)
 322aa0c:	10800017 	ldw	r2,0(r2)
 322aa10:	e0bffc15 	stw	r2,-16(fp)

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
   qptr = q->q_head;
   qlast = NULL;
   while (qptr)
 322aa14:	e0bffc17 	ldw	r2,-16(fp)
 322aa18:	1004c03a 	cmpne	r2,r2,zero
 322aa1c:	103fd01e 	bne	r2,zero,322a960 <qdel+0x30>
         return (qp)elt;   /* success exit point */
      }
      qlast = qptr;
      qptr = qptr->qe_next;
   }
   EXIT_CRIT_SECTION(q);   /* restore int state */
 322aa20:	322b14c0 	call	322b14c <irq_Unmask>
   return NULL;   /* item not found in queue */
 322aa24:	e03fff15 	stw	zero,-4(fp)
 322aa28:	e0bfff17 	ldw	r2,-4(fp)
}
 322aa2c:	e037883a 	mov	sp,fp
 322aa30:	dfc00117 	ldw	ra,4(sp)
 322aa34:	df000017 	ldw	fp,0(sp)
 322aa38:	dec00204 	addi	sp,sp,8
 322aa3c:	f800283a 	ret

0322aa40 <udp_open>:
   ip_addr  fhost,      /* foreign host, 0L for any */
   unshort  fsock,      /* foreign socket, 0 for any */
   unshort  lsock,      /* local socket */
   int (*handler)(PACKET, void*),   /* rcv upcall */
   void *   data)       /* random data, returned on upcalls to aid demuxing */
{
 322aa40:	defff304 	addi	sp,sp,-52
 322aa44:	dfc00c15 	stw	ra,48(sp)
 322aa48:	df000b15 	stw	fp,44(sp)
 322aa4c:	df000b04 	addi	fp,sp,44
 322aa50:	e13ffb15 	stw	r4,-20(fp)
 322aa54:	e1fffe15 	stw	r7,-8(fp)
 322aa58:	e17ffc0d 	sth	r5,-16(fp)
 322aa5c:	e1bffd0d 	sth	r6,-12(fp)
/*
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
 322aa60:	0080c974 	movhi	r2,805
 322aa64:	10931c04 	addi	r2,r2,19568
 322aa68:	10800017 	ldw	r2,0(r2)
 322aa6c:	1080010c 	andi	r2,r2,4
 322aa70:	1005003a 	cmpeq	r2,r2,zero
 322aa74:	1000171e 	bne	r2,zero,322aad4 <udp_open+0x94>
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 322aa78:	e0bffb17 	ldw	r2,-20(fp)
 322aa7c:	11803fcc 	andi	r6,r2,255
 322aa80:	e0bffb17 	ldw	r2,-20(fp)
 322aa84:	1004d23a 	srli	r2,r2,8
 322aa88:	11c03fcc 	andi	r7,r2,255
 322aa8c:	e0bffb17 	ldw	r2,-20(fp)
 322aa90:	1004d43a 	srli	r2,r2,16
 322aa94:	12003fcc 	andi	r8,r2,255
 322aa98:	e0bffb17 	ldw	r2,-20(fp)
 322aa9c:	1006d63a 	srli	r3,r2,24
 322aaa0:	e13ffd0b 	ldhu	r4,-12(fp)
 322aaa4:	e17ffc0b 	ldhu	r5,-16(fp)
 322aaa8:	e0800217 	ldw	r2,8(fp)
 322aaac:	d8c00015 	stw	r3,0(sp)
 322aab0:	d9000115 	stw	r4,4(sp)
 322aab4:	d9400215 	stw	r5,8(sp)
 322aab8:	d8800315 	stw	r2,12(sp)
 322aabc:	0100c974 	movhi	r4,805
 322aac0:	213d1c04 	addi	r4,r4,-2960
 322aac4:	300b883a 	mov	r5,r6
 322aac8:	380d883a 	mov	r6,r7
 322aacc:	400f883a 	mov	r7,r8
 322aad0:	3206de00 	call	3206de0 <printf>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 322aad4:	0009883a 	mov	r4,zero
 322aad8:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   ocon = NULL;
 322aadc:	e03ff915 	stw	zero,-28(fp)
   for (con = firstudp; con; con = con->u_next)
 322aae0:	d0a8d317 	ldw	r2,-23732(gp)
 322aae4:	e0bffa15 	stw	r2,-24(fp)
 322aae8:	00002406 	br	322ab7c <udp_open+0x13c>
   {
      ocon = con;       /* remember last con in list */
 322aaec:	e0bffa17 	ldw	r2,-24(fp)
 322aaf0:	e0bff915 	stw	r2,-28(fp)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 322aaf4:	e0bffa17 	ldw	r2,-24(fp)
 322aaf8:	1080018b 	ldhu	r2,6(r2)
 322aafc:	10ffffcc 	andi	r3,r2,65535
 322ab00:	e0bffd0b 	ldhu	r2,-12(fp)
 322ab04:	18801a1e 	bne	r3,r2,322ab70 <udp_open+0x130>
 322ab08:	e0bffa17 	ldw	r2,-24(fp)
 322ab0c:	1080020b 	ldhu	r2,8(r2)
 322ab10:	10ffffcc 	andi	r3,r2,65535
 322ab14:	e0bffc0b 	ldhu	r2,-16(fp)
 322ab18:	1880151e 	bne	r3,r2,322ab70 <udp_open+0x130>
 322ab1c:	e0bffa17 	ldw	r2,-24(fp)
 322ab20:	10800317 	ldw	r2,12(r2)
 322ab24:	1004c03a 	cmpne	r2,r2,zero
 322ab28:	1000111e 	bne	r2,zero,322ab70 <udp_open+0x130>
 322ab2c:	e0bffa17 	ldw	r2,-24(fp)
 322ab30:	10c00417 	ldw	r3,16(r2)
 322ab34:	e0bffb17 	ldw	r2,-20(fp)
 322ab38:	18800d1e 	bne	r3,r2,322ab70 <udp_open+0x130>
          con->u_lhost == 0 && con->u_fhost == fhost)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (INFOMSG|PROTERR))
 322ab3c:	0080c974 	movhi	r2,805
 322ab40:	10931c04 	addi	r2,r2,19568
 322ab44:	10800017 	ldw	r2,0(r2)
 322ab48:	1080050c 	andi	r2,r2,20
 322ab4c:	1005003a 	cmpeq	r2,r2,zero
 322ab50:	1000031e 	bne	r2,zero,322ab60 <udp_open+0x120>
            dprintf("UDP: Connection already exists.\n");
 322ab54:	0100c974 	movhi	r4,805
 322ab58:	213d2b04 	addi	r4,r4,-2900
 322ab5c:	32071080 	call	3207108 <puts>
#endif
         UNLOCK_NET_RESOURCE(NET_RESID);
 322ab60:	0009883a 	mov	r4,zero
 322ab64:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         return(NULL);
 322ab68:	e03fff15 	stw	zero,-4(fp)
 322ab6c:	00003c06 	br	322ac60 <udp_open+0x220>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
   ocon = NULL;
   for (con = firstudp; con; con = con->u_next)
 322ab70:	e0bffa17 	ldw	r2,-24(fp)
 322ab74:	10800017 	ldw	r2,0(r2)
 322ab78:	e0bffa15 	stw	r2,-24(fp)
 322ab7c:	e0bffa17 	ldw	r2,-24(fp)
 322ab80:	1004c03a 	cmpne	r2,r2,zero
 322ab84:	103fd91e 	bne	r2,zero,322aaec <udp_open+0xac>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return(NULL);
      }
   }

   con = (UDPCONN)UC_ALLOC(sizeof(struct udp_conn));
 322ab88:	01000804 	movi	r4,32
 322ab8c:	322b9340 	call	322b934 <npalloc>
 322ab90:	e0bffa15 	stw	r2,-24(fp)
   if (con == 0)
 322ab94:	e0bffa17 	ldw	r2,-24(fp)
 322ab98:	1004c03a 	cmpne	r2,r2,zero
 322ab9c:	10000d1e 	bne	r2,zero,322abd4 <udp_open+0x194>
   {
#ifdef   NPDEBUG
      if (NDEBUG & INFOMSG)
 322aba0:	0080c974 	movhi	r2,805
 322aba4:	10931c04 	addi	r2,r2,19568
 322aba8:	10800017 	ldw	r2,0(r2)
 322abac:	1080010c 	andi	r2,r2,4
 322abb0:	1005003a 	cmpeq	r2,r2,zero
 322abb4:	1000031e 	bne	r2,zero,322abc4 <udp_open+0x184>
         dprintf("UDP: Couldn't allocate conn storage.\n");
 322abb8:	0100c974 	movhi	r4,805
 322abbc:	213d3304 	addi	r4,r4,-2868
 322abc0:	32071080 	call	3207108 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 322abc4:	0009883a 	mov	r4,zero
 322abc8:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return(NULL);
 322abcc:	e03fff15 	stw	zero,-4(fp)
 322abd0:	00002306 	br	322ac60 <udp_open+0x220>
   }

   if (ocon)   /* ocon is end of list */
 322abd4:	e0bff917 	ldw	r2,-28(fp)
 322abd8:	1005003a 	cmpeq	r2,r2,zero
 322abdc:	1000041e 	bne	r2,zero,322abf0 <udp_open+0x1b0>
      ocon->u_next = con;  /* add new connection to end */
 322abe0:	e0fff917 	ldw	r3,-28(fp)
 322abe4:	e0bffa17 	ldw	r2,-24(fp)
 322abe8:	18800015 	stw	r2,0(r3)
 322abec:	00000206 	br	322abf8 <udp_open+0x1b8>
   else  /* no list, start one */
      firstudp = con;
 322abf0:	e0bffa17 	ldw	r2,-24(fp)
 322abf4:	d0a8d315 	stw	r2,-23732(gp)

   con->u_next = 0;
 322abf8:	e0bffa17 	ldw	r2,-24(fp)
 322abfc:	10000015 	stw	zero,0(r2)

   con->u_lport = lsock;      /* fill in connection info */
 322ac00:	e0fffa17 	ldw	r3,-24(fp)
 322ac04:	e0bffd0b 	ldhu	r2,-12(fp)
 322ac08:	1880018d 	sth	r2,6(r3)
   con->u_fport = fsock;
 322ac0c:	e0fffa17 	ldw	r3,-24(fp)
 322ac10:	e0bffc0b 	ldhu	r2,-16(fp)
 322ac14:	1880020d 	sth	r2,8(r3)
   con->u_lhost = 0;
 322ac18:	e0bffa17 	ldw	r2,-24(fp)
 322ac1c:	10000315 	stw	zero,12(r2)
   con->u_fhost = fhost;
 322ac20:	e0fffa17 	ldw	r3,-24(fp)
 322ac24:	e0bffb17 	ldw	r2,-20(fp)
 322ac28:	18800415 	stw	r2,16(r3)
   con->u_rcv   = handler;
 322ac2c:	e0fffa17 	ldw	r3,-24(fp)
 322ac30:	e0bffe17 	ldw	r2,-8(fp)
 322ac34:	18800515 	stw	r2,20(r3)
   con->u_data  = data;
 322ac38:	e0fffa17 	ldw	r3,-24(fp)
 322ac3c:	e0800217 	ldw	r2,8(fp)
 322ac40:	18800615 	stw	r2,24(r3)
   con->u_flags = UDPCF_V4;
 322ac44:	e0fffa17 	ldw	r3,-24(fp)
 322ac48:	00800044 	movi	r2,1
 322ac4c:	1880010d 	sth	r2,4(r3)

   UNLOCK_NET_RESOURCE(NET_RESID);
 322ac50:	0009883a 	mov	r4,zero
 322ac54:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   return(con);
 322ac58:	e0bffa17 	ldw	r2,-24(fp)
 322ac5c:	e0bfff15 	stw	r2,-4(fp)
 322ac60:	e0bfff17 	ldw	r2,-4(fp)
}
 322ac64:	e037883a 	mov	sp,fp
 322ac68:	dfc00117 	ldw	ra,4(sp)
 322ac6c:	df000017 	ldw	fp,0(sp)
 322ac70:	dec00204 	addi	sp,sp,8
 322ac74:	f800283a 	ret

0322ac78 <udp_close>:
 * RETURNS: void
 */

void
udp_close(UDPCONN con)
{
 322ac78:	defffb04 	addi	sp,sp,-20
 322ac7c:	dfc00415 	stw	ra,16(sp)
 322ac80:	df000315 	stw	fp,12(sp)
 322ac84:	df000304 	addi	fp,sp,12
 322ac88:	e13fff15 	stw	r4,-4(fp)
   UDPCONN pcon;
   UDPCONN lcon;

#ifdef NPDEBUG
   if ((con == NULL) || (firstudp == NULL))
 322ac8c:	e0bfff17 	ldw	r2,-4(fp)
 322ac90:	1005003a 	cmpeq	r2,r2,zero
 322ac94:	1000031e 	bne	r2,zero,322aca4 <udp_close+0x2c>
 322ac98:	d0a8d317 	ldw	r2,-23732(gp)
 322ac9c:	1004c03a 	cmpne	r2,r2,zero
 322aca0:	1000021e 	bne	r2,zero,322acac <udp_close+0x34>
   {
      dtrap(); /* bad programming! */
 322aca4:	322aef00 	call	322aef0 <dtrap>
      return;
 322aca8:	00002706 	br	322ad48 <udp_close+0xd0>
   }
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 322acac:	0009883a 	mov	r4,zero
 322acb0:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
 322acb4:	e03ffd15 	stw	zero,-12(fp)
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 322acb8:	d0a8d317 	ldw	r2,-23732(gp)
 322acbc:	e0bffe15 	stw	r2,-8(fp)
 322acc0:	00000806 	br	322ace4 <udp_close+0x6c>
   {
      if (pcon == con)  /* found connection to delete */
 322acc4:	e0fffe17 	ldw	r3,-8(fp)
 322acc8:	e0bfff17 	ldw	r2,-4(fp)
 322accc:	18800826 	beq	r3,r2,322acf0 <udp_close+0x78>
      break;
      lcon = pcon;   /* remember last connection */
 322acd0:	e0bffe17 	ldw	r2,-8(fp)
 322acd4:	e0bffd15 	stw	r2,-12(fp)
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 322acd8:	e0bffe17 	ldw	r2,-8(fp)
 322acdc:	10800017 	ldw	r2,0(r2)
 322ace0:	e0bffe15 	stw	r2,-8(fp)
 322ace4:	e0bffe17 	ldw	r2,-8(fp)
 322ace8:	1004c03a 	cmpne	r2,r2,zero
 322acec:	103ff51e 	bne	r2,zero,322acc4 <udp_close+0x4c>
      if (pcon == con)  /* found connection to delete */
      break;
      lcon = pcon;   /* remember last connection */
   }

   if (!pcon)
 322acf0:	e0bffe17 	ldw	r2,-8(fp)
 322acf4:	1004c03a 	cmpne	r2,r2,zero
 322acf8:	1000041e 	bne	r2,zero,322ad0c <udp_close+0x94>
   {
      dtrap(); /* prog error - connenction not in list */
 322acfc:	322aef00 	call	322aef0 <dtrap>
      UNLOCK_NET_RESOURCE(NET_RESID);
 322ad00:	0009883a 	mov	r4,zero
 322ad04:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return;
 322ad08:	00000f06 	br	322ad48 <udp_close+0xd0>
   }

   if (lcon)   /* in con is not head of list */
 322ad0c:	e0bffd17 	ldw	r2,-12(fp)
 322ad10:	1005003a 	cmpeq	r2,r2,zero
 322ad14:	1000051e 	bne	r2,zero,322ad2c <udp_close+0xb4>
      lcon->u_next = con->u_next;   /* unlink */
 322ad18:	e0bfff17 	ldw	r2,-4(fp)
 322ad1c:	10c00017 	ldw	r3,0(r2)
 322ad20:	e0bffd17 	ldw	r2,-12(fp)
 322ad24:	10c00015 	stw	r3,0(r2)
 322ad28:	00000306 	br	322ad38 <udp_close+0xc0>
   else
      firstudp = con->u_next; /* remove from head */
 322ad2c:	e0bfff17 	ldw	r2,-4(fp)
 322ad30:	10800017 	ldw	r2,0(r2)
 322ad34:	d0a8d315 	stw	r2,-23732(gp)

   UC_FREE(con);  /* free memory for structure */
 322ad38:	e13fff17 	ldw	r4,-4(fp)
 322ad3c:	322ba280 	call	322ba28 <npfree>
   UNLOCK_NET_RESOURCE(NET_RESID);
 322ad40:	0009883a 	mov	r4,zero
 322ad44:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
}
 322ad48:	e037883a 	mov	sp,fp
 322ad4c:	dfc00117 	ldw	ra,4(sp)
 322ad50:	df000017 	ldw	fp,0(sp)
 322ad54:	dec00204 	addi	sp,sp,8
 322ad58:	f800283a 	ret

0322ad5c <asm_cksum>:
      .text

      .global	  asm_cksum

asm_cksum:
      mov   r2, zero		       /* accumulator = 0 */
 322ad5c:	0005883a 	mov	r2,zero
      ble   r5, zero, done	       /* count <= 0 ? */
 322ad60:	0140620e 	bge	zero,r5,322aeec <done>

      mov   r6, zero		       /* carry accumulator */
 322ad64:	000d883a 	mov	r6,zero

      andi  r3, r4, 2		       /* ptr 32-bit aligned? */
 322ad68:	20c0008c 	andi	r3,r4,2
      beq   r3, zero, asm1
 322ad6c:	18000326 	beq	r3,zero,322ad7c <asm1>
      ldhu  r2, (r4)		       /* no - process first 16-bits */
 322ad70:	2080000b 	ldhu	r2,0(r4)
      addi  r4, r4, 2
 322ad74:	21000084 	addi	r4,r4,2
      subi  r5, r5, 1
 322ad78:	297fffc4 	addi	r5,r5,-1

0322ad7c <asm1>:
 322ad7c:	02c0c8f4 	movhi	r11,803
/*
 * adjust ptr by ((count/2) mod 16) * 4 bytes
 * jump to location: loop0 - (count/2 mod 16) * 4 instructions
 */
asm1:
      movia r11, loop0
 322ad80:	5aebaa04 	addi	r11,r11,-20824
      andi  r9, r5, 1		       /* r9 = last halfword flag */
 322ad84:	2a40004c 	andi	r9,r5,1
      srai  r5, r5, 1		       /* count = number of words */
 322ad88:	280bd07a 	srai	r5,r5,1
      andi  r10, r5, 0xf	       /* modulo 16 */
 322ad8c:	2a8003cc 	andi	r10,r5,15
      slli  r10, r10, 2		       /*      * 4 bytes per word */
 322ad90:	501490ba 	slli	r10,r10,2
      add   r4, r10, r4		       /* adjust ptr */
 322ad94:	5109883a 	add	r4,r10,r4
      slli  r10, r10, 2		       /*      * 4 instructions per 4 bytes */
 322ad98:	501490ba 	slli	r10,r10,2
      sub   r11, r11, r10
 322ad9c:	5a97c83a 	sub	r11,r11,r10
      jmp   r11
 322ada0:	5800683a 	jmp	r11

0322ada4 <loop>:
      
loop:
      addi  r4, r4, 64		       /* increment data pointer */
 322ada4:	21001004 	addi	r4,r4,64

      ldw   r7, -64(r4)
 322ada8:	21fff017 	ldw	r7,-64(r4)
      add   r2, r7, r2
 322adac:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322adb0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322adb4:	418d883a 	add	r6,r8,r6

      ldw   r7, -60(r4)
 322adb8:	21fff117 	ldw	r7,-60(r4)
      add   r2, r7, r2
 322adbc:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322adc0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322adc4:	418d883a 	add	r6,r8,r6

      ldw   r7, -56(r4)
 322adc8:	21fff217 	ldw	r7,-56(r4)
      add   r2, r7, r2
 322adcc:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322add0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322add4:	418d883a 	add	r6,r8,r6

      ldw   r7, -52(r4)
 322add8:	21fff317 	ldw	r7,-52(r4)
      add   r2, r7, r2
 322addc:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322ade0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322ade4:	418d883a 	add	r6,r8,r6

      ldw   r7, -48(r4)
 322ade8:	21fff417 	ldw	r7,-48(r4)
      add   r2, r7, r2
 322adec:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322adf0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322adf4:	418d883a 	add	r6,r8,r6

      ldw   r7, -44(r4)
 322adf8:	21fff517 	ldw	r7,-44(r4)
      add   r2, r7, r2
 322adfc:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322ae00:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322ae04:	418d883a 	add	r6,r8,r6

      ldw   r7, -40(r4)
 322ae08:	21fff617 	ldw	r7,-40(r4)
      add   r2, r7, r2
 322ae0c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322ae10:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322ae14:	418d883a 	add	r6,r8,r6

      ldw   r7, -36(r4)
 322ae18:	21fff717 	ldw	r7,-36(r4)
      add   r2, r7, r2
 322ae1c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322ae20:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322ae24:	418d883a 	add	r6,r8,r6

      ldw   r7, -32(r4)
 322ae28:	21fff817 	ldw	r7,-32(r4)
      add   r2, r7, r2
 322ae2c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322ae30:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322ae34:	418d883a 	add	r6,r8,r6

      ldw   r7, -28(r4)
 322ae38:	21fff917 	ldw	r7,-28(r4)
      add   r2, r7, r2
 322ae3c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322ae40:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322ae44:	418d883a 	add	r6,r8,r6

      ldw   r7, -24(r4)
 322ae48:	21fffa17 	ldw	r7,-24(r4)
      add   r2, r7, r2
 322ae4c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322ae50:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322ae54:	418d883a 	add	r6,r8,r6

      ldw   r7, -20(r4)
 322ae58:	21fffb17 	ldw	r7,-20(r4)
      add   r2, r7, r2
 322ae5c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322ae60:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322ae64:	418d883a 	add	r6,r8,r6

      ldw   r7, -16(r4)
 322ae68:	21fffc17 	ldw	r7,-16(r4)
      add   r2, r7, r2
 322ae6c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322ae70:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322ae74:	418d883a 	add	r6,r8,r6

      ldw   r7, -12(r4)
 322ae78:	21fffd17 	ldw	r7,-12(r4)
      add   r2, r7, r2
 322ae7c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322ae80:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322ae84:	418d883a 	add	r6,r8,r6

      ldw   r7, -8(r4)
 322ae88:	21fffe17 	ldw	r7,-8(r4)
      add   r2, r7, r2
 322ae8c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322ae90:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322ae94:	418d883a 	add	r6,r8,r6

      ldw   r7, -4(r4)
 322ae98:	21ffff17 	ldw	r7,-4(r4)
      add   r2, r7, r2
 322ae9c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322aea0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322aea4:	418d883a 	add	r6,r8,r6

0322aea8 <loop0>:
loop0:
      subi  r5, r5, 16
 322aea8:	297ffc04 	addi	r5,r5,-16
      bge   r5, zero, loop
 322aeac:	283fbd0e 	bge	r5,zero,322ada4 <loop>
/*
 * process last halfword (if any)
 */
      beq   r9, zero, fold
 322aeb0:	48000426 	beq	r9,zero,322aec4 <fold>
      ldhu  r7, 0(r4)
 322aeb4:	21c0000b 	ldhu	r7,0(r4)
      add   r2, r7, r2
 322aeb8:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 322aebc:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 322aec0:	418d883a 	add	r6,r8,r6

0322aec4 <fold>:
      
fold:
      srli  r7, r2, 16
 322aec4:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 322aec8:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add the upper and lower halfwords */
 322aecc:	3885883a 	add	r2,r7,r2
      add   r2, r6, r2		    /* add the carries */
 322aed0:	3085883a 	add	r2,r6,r2
/* the accumulator is 18 bits */
      srli  r7, r2, 16
 322aed4:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 322aed8:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add 2 carry bits to lower halfword */
 322aedc:	3885883a 	add	r2,r7,r2
/* the accumulator is 17 bits */
      srli  r7, r2, 16
 322aee0:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 322aee4:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add carry to lower halfword */
 322aee8:	3885883a 	add	r2,r7,r2

0322aeec <done>:

done:
      ret			    		/* r2 = 16-bit checksum */
 322aeec:	f800283a 	ret

0322aef0 <dtrap>:
void irq_Unmask(void);

/* dtrap() - function to trap to debugger */
void
dtrap(void)
{
 322aef0:	defffe04 	addi	sp,sp,-8
 322aef4:	dfc00115 	stw	ra,4(sp)
 322aef8:	df000015 	stw	fp,0(sp)
 322aefc:	d839883a 	mov	fp,sp
   printf("dtrap - needs breakpoint\n");
 322af00:	0100c974 	movhi	r4,805
 322af04:	213d3d04 	addi	r4,r4,-2828
 322af08:	32071080 	call	3207108 <puts>
}
 322af0c:	e037883a 	mov	sp,fp
 322af10:	dfc00117 	ldw	ra,4(sp)
 322af14:	df000017 	ldw	fp,0(sp)
 322af18:	dec00204 	addi	sp,sp,8
 322af1c:	f800283a 	ret

0322af20 <kbhit>:

int
kbhit()
{
 322af20:	defffc04 	addi	sp,sp,-16
 322af24:	dfc00315 	stw	ra,12(sp)
 322af28:	df000215 	stw	fp,8(sp)
 322af2c:	df000204 	addi	fp,sp,8
   static int kbd_init = 0;
   int   kb;
   
   if (!kbd_init)
 322af30:	d0a8d417 	ldw	r2,-23728(gp)
 322af34:	1004c03a 	cmpne	r2,r2,zero
 322af38:	10000c1e 	bne	r2,zero,322af6c <kbhit+0x4c>
      /* we really should read the flags, OR in O_NONBLOCK, and write
       * the flags back to STDIN, but the NIOS-II/HAL implementation
       * will only let us modify O_NONBLOCK and O_APPEND, so we'll
       * just write the new flag value.
       */
      if (fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK) != 0)
 322af3c:	0009883a 	mov	r4,zero
 322af40:	01400104 	movi	r5,4
 322af44:	01900004 	movi	r6,16384
 322af48:	323d16c0 	call	323d16c <fcntl>
 322af4c:	1005003a 	cmpeq	r2,r2,zero
 322af50:	1000041e 	bne	r2,zero,322af64 <kbhit+0x44>
      {
         printf("F_SETFL failed.\n");
 322af54:	0100c974 	movhi	r4,805
 322af58:	213d4404 	addi	r4,r4,-2800
 322af5c:	32071080 	call	3207108 <puts>
         dtrap();
 322af60:	322aef00 	call	322aef0 <dtrap>
      }
      kbd_init = 1; 
 322af64:	00800044 	movi	r2,1
 322af68:	d0a8d415 	stw	r2,-23728(gp)
   }

   /* we have to do a read to see if there is a character available.
    * we save the character, if there was one, to be read later. */
   if (kb_last == EOF)
 322af6c:	d0a03617 	ldw	r2,-32552(gp)
 322af70:	10bfffd8 	cmpnei	r2,r2,-1
 322af74:	10000d1e 	bne	r2,zero,322afac <kbhit+0x8c>
   {
      kb = getchar();
 322af78:	0080c974 	movhi	r2,805
 322af7c:	108a6304 	addi	r2,r2,10636
 322af80:	10800017 	ldw	r2,0(r2)
 322af84:	11000117 	ldw	r4,4(r2)
 322af88:	3205ff00 	call	3205ff0 <getc>
 322af8c:	e0bffe15 	stw	r2,-8(fp)
      if (kb < 0)       /* any error means no character present */
 322af90:	e0bffe17 	ldw	r2,-8(fp)
 322af94:	1004403a 	cmpge	r2,r2,zero
 322af98:	1000021e 	bne	r2,zero,322afa4 <kbhit+0x84>
         return (FALSE);
 322af9c:	e03fff15 	stw	zero,-4(fp)
 322afa0:	00000406 	br	322afb4 <kbhit+0x94>
         
      /* there was a character, and we read it. */
      kb_last = kb;
 322afa4:	e0bffe17 	ldw	r2,-8(fp)
 322afa8:	d0a03615 	stw	r2,-32552(gp)
   }

   return (TRUE);
 322afac:	00800044 	movi	r2,1
 322afb0:	e0bfff15 	stw	r2,-4(fp)
 322afb4:	e0bfff17 	ldw	r2,-4(fp)
}
 322afb8:	e037883a 	mov	sp,fp
 322afbc:	dfc00117 	ldw	ra,4(sp)
 322afc0:	df000017 	ldw	fp,0(sp)
 322afc4:	dec00204 	addi	sp,sp,8
 322afc8:	f800283a 	ret

0322afcc <getch>:

int 
getch()
{
 322afcc:	defffd04 	addi	sp,sp,-12
 322afd0:	dfc00215 	stw	ra,8(sp)
 322afd4:	df000115 	stw	fp,4(sp)
 322afd8:	df000104 	addi	fp,sp,4
int chr;

   if(kb_last != EOF)
 322afdc:	d0a03617 	ldw	r2,-32552(gp)
 322afe0:	10bfffe0 	cmpeqi	r2,r2,-1
 322afe4:	1000051e 	bne	r2,zero,322affc <getch+0x30>
   {
      chr = kb_last;
 322afe8:	d0a03617 	ldw	r2,-32552(gp)
 322afec:	e0bfff15 	stw	r2,-4(fp)
      kb_last = EOF;
 322aff0:	00bfffc4 	movi	r2,-1
 322aff4:	d0a03615 	stw	r2,-32552(gp)
 322aff8:	00000606 	br	322b014 <getch+0x48>
   }
   else
      chr = getchar();
 322affc:	0080c974 	movhi	r2,805
 322b000:	108a6304 	addi	r2,r2,10636
 322b004:	10800017 	ldw	r2,0(r2)
 322b008:	11000117 	ldw	r4,4(r2)
 322b00c:	3205ff00 	call	3205ff0 <getc>
 322b010:	e0bfff15 	stw	r2,-4(fp)

   return chr;
 322b014:	e0bfff17 	ldw	r2,-4(fp)
}
 322b018:	e037883a 	mov	sp,fp
 322b01c:	dfc00117 	ldw	ra,4(sp)
 322b020:	df000017 	ldw	fp,0(sp)
 322b024:	dec00204 	addi	sp,sp,8
 322b028:	f800283a 	ret

0322b02c <clock_init>:
int OS_TPS;
int cticks_factor;
int cticks_initialized = 0;

void clock_init(void)
{
 322b02c:	deffff04 	addi	sp,sp,-4
 322b030:	df000015 	stw	fp,0(sp)
 322b034:	d839883a 	mov	fp,sp
   OS_TPS = OS_TICKS_PER_SEC;
 322b038:	0080fa04 	movi	r2,1000
 322b03c:	d0a8d915 	stw	r2,-23708(gp)
   cticks_factor = 0;
 322b040:	d028d815 	stw	zero,-23712(gp)
   cticks = 0;
 322b044:	0080c974 	movhi	r2,805
 322b048:	10934104 	addi	r2,r2,19716
 322b04c:	10000015 	stw	zero,0(r2)
   cticks_initialized = 1;
 322b050:	00800044 	movi	r2,1
 322b054:	d0a8d515 	stw	r2,-23724(gp)
}
 322b058:	e037883a 	mov	sp,fp
 322b05c:	df000017 	ldw	fp,0(sp)
 322b060:	dec00104 	addi	sp,sp,4
 322b064:	f800283a 	ret

0322b068 <clock_c>:

/* undo effects of clock_init (i.e. restore ISR vector) 
 * NO OP since using RTOS's timer.
 */
void clock_c(void)
{
 322b068:	deffff04 	addi	sp,sp,-4
 322b06c:	df000015 	stw	fp,0(sp)
 322b070:	d839883a 	mov	fp,sp
   /* null */ ;
}
 322b074:	e037883a 	mov	sp,fp
 322b078:	df000017 	ldw	fp,0(sp)
 322b07c:	dec00104 	addi	sp,sp,4
 322b080:	f800283a 	ret

0322b084 <cticks_hook>:
 * Use the uCOS-II/Altera HAL BSP's timer and scale cticks as per TPS.
 */

void
cticks_hook(void)
{
 322b084:	deffff04 	addi	sp,sp,-4
 322b088:	df000015 	stw	fp,0(sp)
 322b08c:	d839883a 	mov	fp,sp
   if (cticks_initialized) 
 322b090:	d0a8d517 	ldw	r2,-23724(gp)
 322b094:	1005003a 	cmpeq	r2,r2,zero
 322b098:	1000111e 	bne	r2,zero,322b0e0 <cticks_hook+0x5c>
   {
      cticks_factor += TPS;
 322b09c:	d0a8d817 	ldw	r2,-23712(gp)
 322b0a0:	1080fa04 	addi	r2,r2,1000
 322b0a4:	d0a8d815 	stw	r2,-23712(gp)
      if (cticks_factor >= OS_TPS)
 322b0a8:	d0e8d817 	ldw	r3,-23712(gp)
 322b0ac:	d0a8d917 	ldw	r2,-23708(gp)
 322b0b0:	18800b16 	blt	r3,r2,322b0e0 <cticks_hook+0x5c>
      {
         cticks++;
 322b0b4:	0080c974 	movhi	r2,805
 322b0b8:	10934104 	addi	r2,r2,19716
 322b0bc:	10800017 	ldw	r2,0(r2)
 322b0c0:	10c00044 	addi	r3,r2,1
 322b0c4:	0080c974 	movhi	r2,805
 322b0c8:	10934104 	addi	r2,r2,19716
 322b0cc:	10c00015 	stw	r3,0(r2)
         cticks_factor -= OS_TPS;
 322b0d0:	d0e8d817 	ldw	r3,-23712(gp)
 322b0d4:	d0a8d917 	ldw	r2,-23708(gp)
 322b0d8:	1885c83a 	sub	r2,r3,r2
 322b0dc:	d0a8d815 	stw	r2,-23712(gp)
#ifdef USE_LCD
         update_display();
#endif
      }
   }
}
 322b0e0:	e037883a 	mov	sp,fp
 322b0e4:	df000017 	ldw	fp,0(sp)
 322b0e8:	dec00104 	addi	sp,sp,4
 322b0ec:	f800283a 	ret

0322b0f0 <irq_Mask>:
 * ENTER_CRIT_SECTION() and enable them in EXIT_CRIT_SECTION()
 * because calls to ENTER_CRIT_SECTION() can be nested."
 */
void
irq_Mask(void)
{
 322b0f0:	defffd04 	addi	sp,sp,-12
 322b0f4:	df000215 	stw	fp,8(sp)
 322b0f8:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 322b0fc:	0005303a 	rdctl	r2,status
 322b100:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 322b104:	e0fffe17 	ldw	r3,-8(fp)
 322b108:	00bfff84 	movi	r2,-2
 322b10c:	1884703a 	and	r2,r3,r2
 322b110:	1001703a 	wrctl	status,r2
  
  return context;
 322b114:	e0bffe17 	ldw	r2,-8(fp)
   alt_irq_context  local_cpu_statusreg;

   local_cpu_statusreg = alt_irq_disable_all();
 322b118:	e0bfff15 	stw	r2,-4(fp)
	
   if (++irq_level == 1)
 322b11c:	d0a8d617 	ldw	r2,-23720(gp)
 322b120:	10800044 	addi	r2,r2,1
 322b124:	d0a8d615 	stw	r2,-23720(gp)
 322b128:	d0a8d617 	ldw	r2,-23720(gp)
 322b12c:	10800058 	cmpnei	r2,r2,1
 322b130:	1000021e 	bne	r2,zero,322b13c <irq_Mask+0x4c>
   {
      cpu_statusreg = local_cpu_statusreg;
 322b134:	e0bfff17 	ldw	r2,-4(fp)
 322b138:	d0a8d715 	stw	r2,-23716(gp)
   }
}
 322b13c:	e037883a 	mov	sp,fp
 322b140:	df000017 	ldw	fp,0(sp)
 322b144:	dec00104 	addi	sp,sp,4
 322b148:	f800283a 	ret

0322b14c <irq_Unmask>:


/* Re-Enable Interrupts */
void
irq_Unmask(void)
{
 322b14c:	defffe04 	addi	sp,sp,-8
 322b150:	df000115 	stw	fp,4(sp)
 322b154:	df000104 	addi	fp,sp,4
   if (--irq_level == 0)
 322b158:	d0a8d617 	ldw	r2,-23720(gp)
 322b15c:	10bfffc4 	addi	r2,r2,-1
 322b160:	d0a8d615 	stw	r2,-23720(gp)
 322b164:	d0a8d617 	ldw	r2,-23720(gp)
 322b168:	1004c03a 	cmpne	r2,r2,zero
 322b16c:	1000041e 	bne	r2,zero,322b180 <irq_Unmask+0x34>
   {
      alt_irq_enable_all(cpu_statusreg);
 322b170:	d0a8d717 	ldw	r2,-23716(gp)
 322b174:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 322b178:	e0bfff17 	ldw	r2,-4(fp)
 322b17c:	1001703a 	wrctl	status,r2
   }
}
 322b180:	e037883a 	mov	sp,fp
 322b184:	df000017 	ldw	fp,0(sp)
 322b188:	dec00104 	addi	sp,sp,4
 322b18c:	f800283a 	ret

0322b190 <LOCK_NET_RESOURCE>:
extern void irq_Mask(void);
extern void irq_Unmask(void);

void
LOCK_NET_RESOURCE(int resid)
{
 322b190:	defffb04 	addi	sp,sp,-20
 322b194:	dfc00415 	stw	ra,16(sp)
 322b198:	df000315 	stw	fp,12(sp)
 322b19c:	df000304 	addi	fp,sp,12
 322b1a0:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 322b1a4:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 322b1a8:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 322b1ac:	e0bfff17 	ldw	r2,-4(fp)
 322b1b0:	1004803a 	cmplt	r2,r2,zero
 322b1b4:	1000201e 	bne	r2,zero,322b238 <LOCK_NET_RESOURCE+0xa8>
 322b1b8:	e0bfff17 	ldw	r2,-4(fp)
 322b1bc:	10800408 	cmpgei	r2,r2,16
 322b1c0:	10001d1e 	bne	r2,zero,322b238 <LOCK_NET_RESOURCE+0xa8>
   {
      do
      {
         OSSemPend(resid_semaphore[resid], 0, &error);
 322b1c4:	e0bfff17 	ldw	r2,-4(fp)
 322b1c8:	00c0c9b4 	movhi	r3,806
 322b1cc:	18f46c04 	addi	r3,r3,-11856
 322b1d0:	1085883a 	add	r2,r2,r2
 322b1d4:	1085883a 	add	r2,r2,r2
 322b1d8:	10c5883a 	add	r2,r2,r3
 322b1dc:	11000017 	ldw	r4,0(r2)
 322b1e0:	e1bffe04 	addi	r6,fp,-8
 322b1e4:	000b883a 	mov	r5,zero
 322b1e8:	321b0e80 	call	321b0e8 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 322b1ec:	e0bffe03 	ldbu	r2,-8(fp)
 322b1f0:	10803fcc 	andi	r2,r2,255
 322b1f4:	10800298 	cmpnei	r2,r2,10
 322b1f8:	10000a1e 	bne	r2,zero,322b224 <LOCK_NET_RESOURCE+0x94>
 322b1fc:	e0bffd17 	ldw	r2,-12(fp)
 322b200:	10800044 	addi	r2,r2,1
 322b204:	e0bffd15 	stw	r2,-12(fp)
 322b208:	e0bffd17 	ldw	r2,-12(fp)
 322b20c:	1080fa50 	cmplti	r2,r2,1001
 322b210:	1000041e 	bne	r2,zero,322b224 <LOCK_NET_RESOURCE+0x94>
         {
            panic("lock NET");   /* fatal */
 322b214:	0100c974 	movhi	r4,805
 322b218:	213d4804 	addi	r4,r4,-2784
 322b21c:	32261540 	call	3226154 <panic>
            return;
 322b220:	00000606 	br	322b23c <LOCK_NET_RESOURCE+0xac>
         }
      } while (error == 10);
 322b224:	e0bffe03 	ldbu	r2,-8(fp)
 322b228:	10803fcc 	andi	r2,r2,255
 322b22c:	108002a0 	cmpeqi	r2,r2,10
 322b230:	103fe41e 	bne	r2,zero,322b1c4 <LOCK_NET_RESOURCE+0x34>
LOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;
   int   errct = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 322b234:	00000106 	br	322b23c <LOCK_NET_RESOURCE+0xac>
            return;
         }
      } while (error == 10);
   }
   else
      dtrap();
 322b238:	322aef00 	call	322aef0 <dtrap>
}
 322b23c:	e037883a 	mov	sp,fp
 322b240:	dfc00117 	ldw	ra,4(sp)
 322b244:	df000017 	ldw	fp,0(sp)
 322b248:	dec00204 	addi	sp,sp,8
 322b24c:	f800283a 	ret

0322b250 <UNLOCK_NET_RESOURCE>:

void
UNLOCK_NET_RESOURCE(int resid)
{
 322b250:	defffc04 	addi	sp,sp,-16
 322b254:	dfc00315 	stw	ra,12(sp)
 322b258:	df000215 	stw	fp,8(sp)
 322b25c:	df000204 	addi	fp,sp,8
 322b260:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 322b264:	e03ffe05 	stb	zero,-8(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 322b268:	e0bfff17 	ldw	r2,-4(fp)
 322b26c:	1004803a 	cmplt	r2,r2,zero
 322b270:	1000131e 	bne	r2,zero,322b2c0 <UNLOCK_NET_RESOURCE+0x70>
 322b274:	e0bfff17 	ldw	r2,-4(fp)
 322b278:	10800408 	cmpgei	r2,r2,16
 322b27c:	1000101e 	bne	r2,zero,322b2c0 <UNLOCK_NET_RESOURCE+0x70>
   {
      error = OSSemPost(resid_semaphore[resid]);
 322b280:	e0bfff17 	ldw	r2,-4(fp)
 322b284:	00c0c9b4 	movhi	r3,806
 322b288:	18f46c04 	addi	r3,r3,-11856
 322b28c:	1085883a 	add	r2,r2,r2
 322b290:	1085883a 	add	r2,r2,r2
 322b294:	10c5883a 	add	r2,r2,r3
 322b298:	11000017 	ldw	r4,0(r2)
 322b29c:	321b4e00 	call	321b4e0 <OSSemPost>
 322b2a0:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 322b2a4:	e0bffe03 	ldbu	r2,-8(fp)
 322b2a8:	1005003a 	cmpeq	r2,r2,zero
 322b2ac:	1000051e 	bne	r2,zero,322b2c4 <UNLOCK_NET_RESOURCE+0x74>
      {
         panic("unlock NET");
 322b2b0:	0100c974 	movhi	r4,805
 322b2b4:	213d4b04 	addi	r4,r4,-2772
 322b2b8:	32261540 	call	3226154 <panic>
void
UNLOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 322b2bc:	00000106 	br	322b2c4 <UNLOCK_NET_RESOURCE+0x74>
      {
         panic("unlock NET");
      }
   }
   else
      dtrap();
 322b2c0:	322aef00 	call	322aef0 <dtrap>
}
 322b2c4:	e037883a 	mov	sp,fp
 322b2c8:	dfc00117 	ldw	ra,4(sp)
 322b2cc:	df000017 	ldw	fp,0(sp)
 322b2d0:	dec00204 	addi	sp,sp,8
 322b2d4:	f800283a 	ret

0322b2d8 <TK_NEWTASK>:
extern long     nettick_wakes;


int
TK_NEWTASK(struct inet_taskinfo * nettask)
{
 322b2d8:	deffed04 	addi	sp,sp,-76
 322b2dc:	dfc01215 	stw	ra,72(sp)
 322b2e0:	df001115 	stw	fp,68(sp)
 322b2e4:	df001104 	addi	fp,sp,68
 322b2e8:	e13ffe15 	stw	r4,-8(fp)
   INT8U    error;
   OS_STK * stack;

   stack = (OS_STK*)npalloc(nettask->stacksize);
 322b2ec:	e0bffe17 	ldw	r2,-8(fp)
 322b2f0:	10800417 	ldw	r2,16(r2)
 322b2f4:	1009883a 	mov	r4,r2
 322b2f8:	322b9340 	call	322b934 <npalloc>
 322b2fc:	e0bff415 	stw	r2,-48(fp)
   if(!stack)
 322b300:	e0bff417 	ldw	r2,-48(fp)
 322b304:	1004c03a 	cmpne	r2,r2,zero
 322b308:	1000031e 	bne	r2,zero,322b318 <TK_NEWTASK+0x40>
      panic("stack alloc");
 322b30c:	0100c974 	movhi	r4,805
 322b310:	213d4e04 	addi	r4,r4,-2760
 322b314:	32261540 	call	3226154 <panic>

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 322b318:	e0bffe17 	ldw	r2,-8(fp)
 322b31c:	11400217 	ldw	r5,8(r2)
 322b320:	e0bffe17 	ldw	r2,-8(fp)
 322b324:	10800417 	ldw	r2,16(r2)
 322b328:	1004d0ba 	srli	r2,r2,2
 322b32c:	1085883a 	add	r2,r2,r2
 322b330:	1085883a 	add	r2,r2,r2
 322b334:	1007883a 	mov	r3,r2
 322b338:	e0bff417 	ldw	r2,-48(fp)
 322b33c:	1885883a 	add	r2,r3,r2
 322b340:	11bfff04 	addi	r6,r2,-4
 322b344:	e0bffe17 	ldw	r2,-8(fp)
 322b348:	10800317 	ldw	r2,12(r2)
 322b34c:	11c03fcc 	andi	r7,r2,255
 322b350:	e0bffe17 	ldw	r2,-8(fp)
 322b354:	10800317 	ldw	r2,12(r2)
 322b358:	10ffffcc 	andi	r3,r2,65535
 322b35c:	e0bffe17 	ldw	r2,-8(fp)
 322b360:	10800417 	ldw	r2,16(r2)
 322b364:	1008d0ba 	srli	r4,r2,2
 322b368:	d8c00015 	stw	r3,0(sp)
 322b36c:	e0bff417 	ldw	r2,-48(fp)
 322b370:	d8800115 	stw	r2,4(sp)
 322b374:	d9000215 	stw	r4,8(sp)
 322b378:	d8000315 	stw	zero,12(sp)
 322b37c:	008000c4 	movi	r2,3
 322b380:	d8800415 	stw	r2,16(sp)
 322b384:	2809883a 	mov	r4,r5
 322b388:	000b883a 	mov	r5,zero
 322b38c:	321bf840 	call	321bf84 <OSTaskCreateExt>
 322b390:	e0bff505 	stb	r2,-44(fp)
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority);
#endif
   /* If we go here, then there's another task using our priority */
   /* Tell the user and exit with an error */
   if (error == OS_PRIO_EXIST)
 322b394:	e0bff503 	ldbu	r2,-44(fp)
 322b398:	10803fcc 	andi	r2,r2,255
 322b39c:	10800a18 	cmpnei	r2,r2,40
 322b3a0:	1000161e 	bne	r2,zero,322b3fc <TK_NEWTASK+0x124>
   { 
     char curr_task[OS_TASK_NAME_SIZE];
     INT8U err;
     OSTaskNameGet(nettask->priority, curr_task, &err);
 322b3a4:	e0bffe17 	ldw	r2,-8(fp)
 322b3a8:	10800317 	ldw	r2,12(r2)
 322b3ac:	11003fcc 	andi	r4,r2,255
 322b3b0:	e17ff584 	addi	r5,fp,-42
 322b3b4:	e1bff544 	addi	r6,fp,-43
 322b3b8:	321c7000 	call	321c700 <OSTaskNameGet>
     curr_task[OS_TASK_NAME_SIZE-1]=0;
 322b3bc:	e03ffd45 	stb	zero,-11(fp)
    
     printf("Priority requested for task \"%s\" (Prio:%d) conflicts with "\
 322b3c0:	e0bffe17 	ldw	r2,-8(fp)
 322b3c4:	11400117 	ldw	r5,4(r2)
 322b3c8:	e0bffe17 	ldw	r2,-8(fp)
 322b3cc:	11800317 	ldw	r6,12(r2)
 322b3d0:	e0bffe17 	ldw	r2,-8(fp)
 322b3d4:	10800317 	ldw	r2,12(r2)
 322b3d8:	e1fff584 	addi	r7,fp,-42
 322b3dc:	d8800015 	stw	r2,0(sp)
 322b3e0:	0100c974 	movhi	r4,805
 322b3e4:	213d5104 	addi	r4,r4,-2748
 322b3e8:	3206de00 	call	3206de0 <printf>
            "already running task \"%s\" (Prio: %d)\n",
             nettask->name, nettask->priority, curr_task, nettask->priority);
             
     printf("You may wish to check your task priority settings in "\
 322b3ec:	0100c974 	movhi	r4,805
 322b3f0:	213d6904 	addi	r4,r4,-2652
 322b3f4:	32071080 	call	3207108 <puts>
 322b3f8:	00001e06 	br	322b474 <TK_NEWTASK+0x19c>
            "\"<bsp path>\\iniche\\src\\h\\nios2\\ipport.h\" against "\
            "the priority settings in your application and recompile.\n\n");
   }
   else if (error == OS_PRIO_INVALID)
 322b3fc:	e0bff503 	ldbu	r2,-44(fp)
 322b400:	10803fcc 	andi	r2,r2,255
 322b404:	10800a98 	cmpnei	r2,r2,42
 322b408:	10000c1e 	bne	r2,zero,322b43c <TK_NEWTASK+0x164>
   {
     printf("Priority requested for task \"%s\" (Prio:%d) exceeds "\
 322b40c:	e0bffe17 	ldw	r2,-8(fp)
 322b410:	11400117 	ldw	r5,4(r2)
 322b414:	e0bffe17 	ldw	r2,-8(fp)
 322b418:	11800317 	ldw	r6,12(r2)
 322b41c:	0100c974 	movhi	r4,805
 322b420:	213d9104 	addi	r4,r4,-2492
 322b424:	01c00504 	movi	r7,20
 322b428:	3206de00 	call	3206de0 <printf>
            "available priority levels in the system (OS_LOWEST_PRIO = %d)\n\n",
             nettask->name, nettask->priority, OS_LOWEST_PRIO);
             
     printf("Please modify the tasks priority level, or modify the "\
 322b42c:	0100c974 	movhi	r4,805
 322b430:	213dae04 	addi	r4,r4,-2376
 322b434:	32071080 	call	3207108 <puts>
 322b438:	00000e06 	br	322b474 <TK_NEWTASK+0x19c>
            "\"Lowest assignable priority\" setting in the MicroC/OS-II "\
            "component\n");
   }
   else if (error != OS_NO_ERR)
 322b43c:	e0bff503 	ldbu	r2,-44(fp)
 322b440:	10803fcc 	andi	r2,r2,255
 322b444:	1005003a 	cmpeq	r2,r2,zero
 322b448:	10000a1e 	bne	r2,zero,322b474 <TK_NEWTASK+0x19c>
   {                          /* All other errors are fatal */
      printf("Task create error /(MicroC/OS-II error code:%d/) on %s\n",
 322b44c:	e0bff503 	ldbu	r2,-44(fp)
 322b450:	11403fcc 	andi	r5,r2,255
 322b454:	e0bffe17 	ldw	r2,-8(fp)
 322b458:	11800117 	ldw	r6,4(r2)
 322b45c:	0100c974 	movhi	r4,805
 322b460:	213dcd04 	addi	r4,r4,-2252
 322b464:	3206de00 	call	3206de0 <printf>
             error, nettask->name);
      return (-1);
 322b468:	00bfffc4 	movi	r2,-1
 322b46c:	e0bfff15 	stw	r2,-4(fp)
 322b470:	00001806 	br	322b4d4 <TK_NEWTASK+0x1fc>
   }

   /* Include the task name, so that uc/osII (os aware) debuggers can
    * display it.
    */
   OSTaskNameSet(nettask->priority, &nettask->name[0], &error);
 322b474:	e0bffe17 	ldw	r2,-8(fp)
 322b478:	10800317 	ldw	r2,12(r2)
 322b47c:	11003fcc 	andi	r4,r2,255
 322b480:	e0bffe17 	ldw	r2,-8(fp)
 322b484:	10800117 	ldw	r2,4(r2)
 322b488:	100b883a 	mov	r5,r2
 322b48c:	e1bff504 	addi	r6,fp,-44
 322b490:	321c8b80 	call	321c8b8 <OSTaskNameSet>

   nettask->stackbase = (char*)stack;
 322b494:	e0fff417 	ldw	r3,-48(fp)
 322b498:	e0bffe17 	ldw	r2,-8(fp)
 322b49c:	10c00515 	stw	r3,20(r2)
   *nettask->tk_ptr = (INT8U)nettask->priority;  
 322b4a0:	e0bffe17 	ldw	r2,-8(fp)
 322b4a4:	10c00017 	ldw	r3,0(r2)
 322b4a8:	e0bffe17 	ldw	r2,-8(fp)
 322b4ac:	10800317 	ldw	r2,12(r2)
 322b4b0:	18800005 	stb	r2,0(r3)

   printf("Created \"%s\" task (Prio: %d)\n",
 322b4b4:	e0bffe17 	ldw	r2,-8(fp)
 322b4b8:	11400117 	ldw	r5,4(r2)
 322b4bc:	e0bffe17 	ldw	r2,-8(fp)
 322b4c0:	11800317 	ldw	r6,12(r2)
 322b4c4:	0100c974 	movhi	r4,805
 322b4c8:	213ddb04 	addi	r4,r4,-2196
 322b4cc:	3206de00 	call	3206de0 <printf>
         (char *)nettask->name, nettask->priority);

   return (0);
 322b4d0:	e03fff15 	stw	zero,-4(fp)
 322b4d4:	e0bfff17 	ldw	r2,-4(fp)
}
 322b4d8:	e037883a 	mov	sp,fp
 322b4dc:	dfc00117 	ldw	ra,4(sp)
 322b4e0:	df000017 	ldw	fp,0(sp)
 322b4e4:	dec00204 	addi	sp,sp,8
 322b4e8:	f800283a 	ret

0322b4ec <wait_app_sem>:
 * event (e.g., configuration inputs from user, initiation of a new session,
 * or a periodic timeout notification.
 */
void
wait_app_sem(unsigned long semid)
{
 322b4ec:	defffb04 	addi	sp,sp,-20
 322b4f0:	dfc00415 	stw	ra,16(sp)
 322b4f4:	df000315 	stw	fp,12(sp)
 322b4f8:	df000304 	addi	fp,sp,12
 322b4fc:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 322b500:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 322b504:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= semid) && (semid <= MAX_SEMID))
 322b508:	e0bfff17 	ldw	r2,-4(fp)
 322b50c:	108001a8 	cmpgeui	r2,r2,6
 322b510:	10001d1e 	bne	r2,zero,322b588 <wait_app_sem+0x9c>
   {
      do
      {
         OSSemPend(app_semaphore[semid], 0, &error);
 322b514:	e0bfff17 	ldw	r2,-4(fp)
 322b518:	00c0c9b4 	movhi	r3,806
 322b51c:	18f47c04 	addi	r3,r3,-11792
 322b520:	1085883a 	add	r2,r2,r2
 322b524:	1085883a 	add	r2,r2,r2
 322b528:	10c5883a 	add	r2,r2,r3
 322b52c:	11000017 	ldw	r4,0(r2)
 322b530:	e1bffe04 	addi	r6,fp,-8
 322b534:	000b883a 	mov	r5,zero
 322b538:	321b0e80 	call	321b0e8 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 322b53c:	e0bffe03 	ldbu	r2,-8(fp)
 322b540:	10803fcc 	andi	r2,r2,255
 322b544:	10800298 	cmpnei	r2,r2,10
 322b548:	10000a1e 	bne	r2,zero,322b574 <wait_app_sem+0x88>
 322b54c:	e0bffd17 	ldw	r2,-12(fp)
 322b550:	10800044 	addi	r2,r2,1
 322b554:	e0bffd15 	stw	r2,-12(fp)
 322b558:	e0bffd17 	ldw	r2,-12(fp)
 322b55c:	1080fa50 	cmplti	r2,r2,1001
 322b560:	1000041e 	bne	r2,zero,322b574 <wait_app_sem+0x88>
         {
            panic("lock NET");   /* fatal */
 322b564:	0100c974 	movhi	r4,805
 322b568:	213d4804 	addi	r4,r4,-2784
 322b56c:	32261540 	call	3226154 <panic>
            return;
 322b570:	00000606 	br	322b58c <wait_app_sem+0xa0>
         }
      } while (error == 10);
 322b574:	e0bffe03 	ldbu	r2,-8(fp)
 322b578:	10803fcc 	andi	r2,r2,255
 322b57c:	108002a0 	cmpeqi	r2,r2,10
 322b580:	103fe41e 	bne	r2,zero,322b514 <wait_app_sem+0x28>
 322b584:	00000106 	br	322b58c <wait_app_sem+0xa0>
   }
   else
      dtrap();
 322b588:	322aef00 	call	322aef0 <dtrap>
}
 322b58c:	e037883a 	mov	sp,fp
 322b590:	dfc00117 	ldw	ra,4(sp)
 322b594:	df000017 	ldw	fp,0(sp)
 322b598:	dec00204 	addi	sp,sp,8
 322b59c:	f800283a 	ret

0322b5a0 <post_app_sem>:
 * notification. It signals the corresponding application event.
 */

void
post_app_sem(unsigned long semid)
{
 322b5a0:	defffc04 	addi	sp,sp,-16
 322b5a4:	dfc00315 	stw	ra,12(sp)
 322b5a8:	df000215 	stw	fp,8(sp)
 322b5ac:	df000204 	addi	fp,sp,8
 322b5b0:	e13fff15 	stw	r4,-4(fp)
   INT8U error;

   if ((0 <= semid) && (semid <= MAX_SEMID))
 322b5b4:	e0bfff17 	ldw	r2,-4(fp)
 322b5b8:	108001a8 	cmpgeui	r2,r2,6
 322b5bc:	1000101e 	bne	r2,zero,322b600 <post_app_sem+0x60>
   {
      error = OSSemPost(app_semaphore[semid]);
 322b5c0:	e0bfff17 	ldw	r2,-4(fp)
 322b5c4:	00c0c9b4 	movhi	r3,806
 322b5c8:	18f47c04 	addi	r3,r3,-11792
 322b5cc:	1085883a 	add	r2,r2,r2
 322b5d0:	1085883a 	add	r2,r2,r2
 322b5d4:	10c5883a 	add	r2,r2,r3
 322b5d8:	11000017 	ldw	r4,0(r2)
 322b5dc:	321b4e00 	call	321b4e0 <OSSemPost>
 322b5e0:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 322b5e4:	e0bffe03 	ldbu	r2,-8(fp)
 322b5e8:	1005003a 	cmpeq	r2,r2,zero
 322b5ec:	1000051e 	bne	r2,zero,322b604 <post_app_sem+0x64>
      {
         panic("unlock NET");
 322b5f0:	0100c974 	movhi	r4,805
 322b5f4:	213d4b04 	addi	r4,r4,-2772
 322b5f8:	32261540 	call	3226154 <panic>
 322b5fc:	00000106 	br	322b604 <post_app_sem+0x64>
      }
   }
   else
      dtrap();
 322b600:	322aef00 	call	322aef0 <dtrap>
}
 322b604:	e037883a 	mov	sp,fp
 322b608:	dfc00117 	ldw	ra,4(sp)
 322b60c:	df000017 	ldw	fp,0(sp)
 322b610:	dec00204 	addi	sp,sp,8
 322b614:	f800283a 	ret

0322b618 <alt_iniche_init>:
#ifndef SUPERLOOP

extern OS_EVENT *resid_semaphore[MAX_RESID+1];

void alt_iniche_init(void)
{
 322b618:	defffc04 	addi	sp,sp,-16
 322b61c:	dfc00315 	stw	ra,12(sp)
 322b620:	df000215 	stw	fp,8(sp)
 322b624:	dc000115 	stw	r16,4(sp)
 322b628:	df000104 	addi	fp,sp,4
   int i;

   /* initialize the npalloc() heap semaphore */
   mheap_sem_ptr = OSSemCreate(1);
 322b62c:	01000044 	movi	r4,1
 322b630:	321ad340 	call	321ad34 <OSSemCreate>
 322b634:	d0a8e115 	stw	r2,-23676(gp)
   if (!mheap_sem_ptr)
 322b638:	d0a8e117 	ldw	r2,-23676(gp)
 322b63c:	1004c03a 	cmpne	r2,r2,zero
 322b640:	1000031e 	bne	r2,zero,322b650 <alt_iniche_init+0x38>
      panic("mheap_sem_ptr create err"); 
 322b644:	0100c974 	movhi	r4,805
 322b648:	213de304 	addi	r4,r4,-2164
 322b64c:	32261540 	call	3226154 <panic>

   rcvdq_sem_ptr = OSSemCreate(0);
 322b650:	0009883a 	mov	r4,zero
 322b654:	321ad340 	call	321ad34 <OSSemCreate>
 322b658:	d0a8e215 	stw	r2,-23672(gp)
   if (!rcvdq_sem_ptr)
 322b65c:	d0a8e217 	ldw	r2,-23672(gp)
 322b660:	1004c03a 	cmpne	r2,r2,zero
 322b664:	1000031e 	bne	r2,zero,322b674 <alt_iniche_init+0x5c>
      panic("rcvdq_sem_ptr create err"); 
 322b668:	0100c974 	movhi	r4,805
 322b66c:	213dea04 	addi	r4,r4,-2136
 322b670:	32261540 	call	3226154 <panic>

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 322b674:	e03fff15 	stw	zero,-4(fp)
 322b678:	00001906 	br	322b6e0 <alt_iniche_init+0xc8>
   {
      resid_semaphore[i] = OSSemCreate(1);
 322b67c:	e43fff17 	ldw	r16,-4(fp)
 322b680:	01000044 	movi	r4,1
 322b684:	321ad340 	call	321ad34 <OSSemCreate>
 322b688:	1009883a 	mov	r4,r2
 322b68c:	00c0c9b4 	movhi	r3,806
 322b690:	18f46c04 	addi	r3,r3,-11856
 322b694:	8405883a 	add	r2,r16,r16
 322b698:	1085883a 	add	r2,r2,r2
 322b69c:	10c5883a 	add	r2,r2,r3
 322b6a0:	11000015 	stw	r4,0(r2)
      if (!resid_semaphore[i])
 322b6a4:	e0bfff17 	ldw	r2,-4(fp)
 322b6a8:	00c0c9b4 	movhi	r3,806
 322b6ac:	18f46c04 	addi	r3,r3,-11856
 322b6b0:	1085883a 	add	r2,r2,r2
 322b6b4:	1085883a 	add	r2,r2,r2
 322b6b8:	10c5883a 	add	r2,r2,r3
 322b6bc:	10800017 	ldw	r2,0(r2)
 322b6c0:	1004c03a 	cmpne	r2,r2,zero
 322b6c4:	1000031e 	bne	r2,zero,322b6d4 <alt_iniche_init+0xbc>
         panic("resid_semaphore create err");  
 322b6c8:	0100c974 	movhi	r4,805
 322b6cc:	213df104 	addi	r4,r4,-2108
 322b6d0:	32261540 	call	3226154 <panic>
   rcvdq_sem_ptr = OSSemCreate(0);
   if (!rcvdq_sem_ptr)
      panic("rcvdq_sem_ptr create err"); 

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 322b6d4:	e0bfff17 	ldw	r2,-4(fp)
 322b6d8:	10800044 	addi	r2,r2,1
 322b6dc:	e0bfff15 	stw	r2,-4(fp)
 322b6e0:	e0bfff17 	ldw	r2,-4(fp)
 322b6e4:	10800410 	cmplti	r2,r2,16
 322b6e8:	103fe41e 	bne	r2,zero,322b67c <alt_iniche_init+0x64>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 322b6ec:	e03fff15 	stw	zero,-4(fp)
 322b6f0:	00001906 	br	322b758 <alt_iniche_init+0x140>
   {
      app_semaphore[i] = OSSemCreate(1);
 322b6f4:	e43fff17 	ldw	r16,-4(fp)
 322b6f8:	01000044 	movi	r4,1
 322b6fc:	321ad340 	call	321ad34 <OSSemCreate>
 322b700:	1009883a 	mov	r4,r2
 322b704:	00c0c9b4 	movhi	r3,806
 322b708:	18f47c04 	addi	r3,r3,-11792
 322b70c:	8405883a 	add	r2,r16,r16
 322b710:	1085883a 	add	r2,r2,r2
 322b714:	10c5883a 	add	r2,r2,r3
 322b718:	11000015 	stw	r4,0(r2)
      if (!app_semaphore[i])
 322b71c:	e0bfff17 	ldw	r2,-4(fp)
 322b720:	00c0c9b4 	movhi	r3,806
 322b724:	18f47c04 	addi	r3,r3,-11792
 322b728:	1085883a 	add	r2,r2,r2
 322b72c:	1085883a 	add	r2,r2,r2
 322b730:	10c5883a 	add	r2,r2,r3
 322b734:	10800017 	ldw	r2,0(r2)
 322b738:	1004c03a 	cmpne	r2,r2,zero
 322b73c:	1000031e 	bne	r2,zero,322b74c <alt_iniche_init+0x134>
         panic("app_semaphore create err");  
 322b740:	0100c974 	movhi	r4,805
 322b744:	213df804 	addi	r4,r4,-2080
 322b748:	32261540 	call	3226154 <panic>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 322b74c:	e0bfff17 	ldw	r2,-4(fp)
 322b750:	10800044 	addi	r2,r2,1
 322b754:	e0bfff15 	stw	r2,-4(fp)
 322b758:	e0bfff17 	ldw	r2,-4(fp)
 322b75c:	10800190 	cmplti	r2,r2,6
 322b760:	103fe41e 	bne	r2,zero,322b6f4 <alt_iniche_init+0xdc>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 322b764:	e03fff15 	stw	zero,-4(fp)
 322b768:	00002606 	br	322b804 <alt_iniche_init+0x1ec>
   {
      global_TCPwakeup_set[i].ctick = 0;
 322b76c:	e0bfff17 	ldw	r2,-4(fp)
 322b770:	00c0c9b4 	movhi	r3,806
 322b774:	18f43004 	addi	r3,r3,-12096
 322b778:	10800324 	muli	r2,r2,12
 322b77c:	10c5883a 	add	r2,r2,r3
 322b780:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].soc_event = NULL;
 322b784:	e0bfff17 	ldw	r2,-4(fp)
 322b788:	00c0c9b4 	movhi	r3,806
 322b78c:	18f43004 	addi	r3,r3,-12096
 322b790:	10800324 	muli	r2,r2,12
 322b794:	10c5883a 	add	r2,r2,r3
 322b798:	10800104 	addi	r2,r2,4
 322b79c:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
 322b7a0:	e43fff17 	ldw	r16,-4(fp)
 322b7a4:	0009883a 	mov	r4,zero
 322b7a8:	321ad340 	call	321ad34 <OSSemCreate>
 322b7ac:	1009883a 	mov	r4,r2
 322b7b0:	00c0c9b4 	movhi	r3,806
 322b7b4:	18f43004 	addi	r3,r3,-12096
 322b7b8:	80800324 	muli	r2,r16,12
 322b7bc:	10c5883a 	add	r2,r2,r3
 322b7c0:	10800204 	addi	r2,r2,8
 322b7c4:	11000015 	stw	r4,0(r2)
      if (!global_TCPwakeup_set[i].semaphore)
 322b7c8:	e0bfff17 	ldw	r2,-4(fp)
 322b7cc:	00c0c9b4 	movhi	r3,806
 322b7d0:	18f43004 	addi	r3,r3,-12096
 322b7d4:	10800324 	muli	r2,r2,12
 322b7d8:	10c5883a 	add	r2,r2,r3
 322b7dc:	10800204 	addi	r2,r2,8
 322b7e0:	10800017 	ldw	r2,0(r2)
 322b7e4:	1004c03a 	cmpne	r2,r2,zero
 322b7e8:	1000031e 	bne	r2,zero,322b7f8 <alt_iniche_init+0x1e0>
         panic("globwake_semaphore create err");  
 322b7ec:	0100c974 	movhi	r4,805
 322b7f0:	213dff04 	addi	r4,r4,-2052
 322b7f4:	32261540 	call	3226154 <panic>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 322b7f8:	e0bfff17 	ldw	r2,-4(fp)
 322b7fc:	10800044 	addi	r2,r2,1
 322b800:	e0bfff15 	stw	r2,-4(fp)
 322b804:	e0bfff17 	ldw	r2,-4(fp)
 322b808:	10800510 	cmplti	r2,r2,20
 322b80c:	103fd71e 	bne	r2,zero,322b76c <alt_iniche_init+0x154>
      global_TCPwakeup_set[i].soc_event = NULL;
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
      if (!global_TCPwakeup_set[i].semaphore)
         panic("globwake_semaphore create err");  
   }
   global_TCPwakeup_setIndx = 0;
 322b810:	0080c974 	movhi	r2,805
 322b814:	10934004 	addi	r2,r2,19712
 322b818:	10000015 	stw	zero,0(r2)
#endif  /* TCPWAKE_RTOS */
}
 322b81c:	e037883a 	mov	sp,fp
 322b820:	dfc00217 	ldw	ra,8(sp)
 322b824:	df000117 	ldw	fp,4(sp)
 322b828:	dc000017 	ldw	r16,0(sp)
 322b82c:	dec00304 	addi	sp,sp,12
 322b830:	f800283a 	ret

0322b834 <pre_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
pre_task_setup()
{
 322b834:	deffff04 	addi	sp,sp,-4
 322b838:	df000015 	stw	fp,0(sp)
 322b83c:	d839883a 	mov	fp,sp
   write_leds(0);
   write_7seg_raw(0x0000);
#endif

   /* preset buffer counts; may be overridden from command line */
   bigbufs = MAXBIGPKTS;
 322b840:	00c0c974 	movhi	r3,805
 322b844:	18ca9604 	addi	r3,r3,10840
 322b848:	00800784 	movi	r2,30
 322b84c:	18800015 	stw	r2,0(r3)
   lilbufs = MAXLILPKTS;
 322b850:	00c0c974 	movhi	r3,805
 322b854:	18ca9404 	addi	r3,r3,10832
 322b858:	00800784 	movi	r2,30
 322b85c:	18800015 	stw	r2,0(r3)
   bigbufsiz = BIGBUFSIZE;
 322b860:	00c0c974 	movhi	r3,805
 322b864:	18ca9704 	addi	r3,r3,10844
 322b868:	00818004 	movi	r2,1536
 322b86c:	18800015 	stw	r2,0(r3)
   lilbufsiz = LILBUFSIZE;
 322b870:	00c0c974 	movhi	r3,805
 322b874:	18ca9504 	addi	r3,r3,10836
 322b878:	00802004 	movi	r2,128
 322b87c:	18800015 	stw	r2,0(r3)

   /* Install callback to prep_armintcp from prep_ifaces() */
   port_prep = prep_armintcp;
 322b880:	00c0c974 	movhi	r3,805
 322b884:	18d36304 	addi	r3,r3,19852
 322b888:	0080c8f4 	movhi	r2,803
 322b88c:	10ae3204 	addi	r2,r2,-18232
 322b890:	18800015 	stw	r2,0(r3)
#endif   /* NOTDEF */

#endif   /* USE_PPP */


   return NULL;
 322b894:	0005883a 	mov	r2,zero
}
 322b898:	e037883a 	mov	sp,fp
 322b89c:	df000017 	ldw	fp,0(sp)
 322b8a0:	dec00104 	addi	sp,sp,4
 322b8a4:	f800283a 	ret

0322b8a8 <post_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
post_task_setup()
{
 322b8a8:	deffff04 	addi	sp,sp,-4
 322b8ac:	df000015 	stw	fp,0(sp)
 322b8b0:	d839883a 	mov	fp,sp
   return NULL;
 322b8b4:	0005883a 	mov	r2,zero
}
 322b8b8:	e037883a 	mov	sp,fp
 322b8bc:	df000017 	ldw	fp,0(sp)
 322b8c0:	dec00104 	addi	sp,sp,4
 322b8c4:	f800283a 	ret

0322b8c8 <prep_armintcp>:

#endif  /* INCLUDE_NVPARMS */

int 
prep_armintcp(int ifaces_found)
{
 322b8c8:	defffd04 	addi	sp,sp,-12
 322b8cc:	dfc00215 	stw	ra,8(sp)
 322b8d0:	df000115 	stw	fp,4(sp)
 322b8d4:	df000104 	addi	fp,sp,4
 322b8d8:	e13fff15 	stw	r4,-4(fp)
 * Call iniche_devices_init, in alt_iniche_dev.c, 
 * to step through all devices and all their respective
 * low-level initialization routines.
 */
#ifdef ALT_INICHE
   ifaces_found = iniche_devices_init(ifaces_found);
 322b8dc:	e13fff17 	ldw	r4,-4(fp)
 322b8e0:	3222b940 	call	3222b94 <iniche_devices_init>
 322b8e4:	e0bfff15 	stw	r2,-4(fp)

#ifdef USE_SLIP
   ifaces_found = prep_slip(ifaces_found);
#endif

   return ifaces_found;
 322b8e8:	e0bfff17 	ldw	r2,-4(fp)
}
 322b8ec:	e037883a 	mov	sp,fp
 322b8f0:	dfc00117 	ldw	ra,4(sp)
 322b8f4:	df000017 	ldw	fp,0(sp)
 322b8f8:	dec00204 	addi	sp,sp,8
 322b8fc:	f800283a 	ret

0322b900 <calloc2>:
 * There is already a function called calloc1() in memio.c,
 * hence use a different function name.
 */
char * 
calloc2(unsigned size)
{
 322b900:	defffd04 	addi	sp,sp,-12
 322b904:	dfc00215 	stw	ra,8(sp)
 322b908:	df000115 	stw	fp,4(sp)
 322b90c:	df000104 	addi	fp,sp,4
 322b910:	e13fff15 	stw	r4,-4(fp)
   return (calloc(1,size));
 322b914:	01000044 	movi	r4,1
 322b918:	e17fff17 	ldw	r5,-4(fp)
 322b91c:	324bc440 	call	324bc44 <calloc>
}
 322b920:	e037883a 	mov	sp,fp
 322b924:	dfc00117 	ldw	ra,4(sp)
 322b928:	df000017 	ldw	fp,0(sp)
 322b92c:	dec00204 	addi	sp,sp,8
 322b930:	f800283a 	ret

0322b934 <npalloc>:


char *
npalloc(unsigned size)
{
 322b934:	defff904 	addi	sp,sp,-28
 322b938:	dfc00615 	stw	ra,24(sp)
 322b93c:	df000515 	stw	fp,20(sp)
 322b940:	df000504 	addi	fp,sp,20
 322b944:	e13ffe15 	stw	r4,-8(fp)
#ifdef UCOS_II
   INT8U err;
#endif

#ifdef UCOS_II
   OSSemPend(mheap_sem_ptr, 0, &err);
 322b948:	d128e117 	ldw	r4,-23676(gp)
 322b94c:	e1bffd04 	addi	r6,fp,-12
 322b950:	000b883a 	mov	r5,zero
 322b954:	321b0e80 	call	321b0e8 <OSSemPend>
   if(err)
 322b958:	e0bffd03 	ldbu	r2,-12(fp)
 322b95c:	10803fcc 	andi	r2,r2,255
 322b960:	1005003a 	cmpeq	r2,r2,zero
 322b964:	1000181e 	bne	r2,zero,322b9c8 <npalloc+0x94>
   {
      int errct = 0;
 322b968:	e03ffb15 	stw	zero,-20(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 322b96c:	00001206 	br	322b9b8 <npalloc+0x84>
      {
         if(errct++ > 1000)
 322b970:	e0bffb17 	ldw	r2,-20(fp)
 322b974:	1080fa48 	cmpgei	r2,r2,1001
 322b978:	1007883a 	mov	r3,r2
 322b97c:	e0bffb17 	ldw	r2,-20(fp)
 322b980:	10800044 	addi	r2,r2,1
 322b984:	e0bffb15 	stw	r2,-20(fp)
 322b988:	18803fcc 	andi	r2,r3,255
 322b98c:	1005003a 	cmpeq	r2,r2,zero
 322b990:	1000051e 	bne	r2,zero,322b9a8 <npalloc+0x74>
         {
            panic("npalloc");    /* fatal? */
 322b994:	0100c974 	movhi	r4,805
 322b998:	213e0704 	addi	r4,r4,-2020
 322b99c:	32261540 	call	3226154 <panic>
            return NULL;
 322b9a0:	e03fff15 	stw	zero,-4(fp)
 322b9a4:	00001a06 	br	322ba10 <npalloc+0xdc>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 322b9a8:	d128e117 	ldw	r4,-23676(gp)
 322b9ac:	e1bffd04 	addi	r6,fp,-12
 322b9b0:	000b883a 	mov	r5,zero
 322b9b4:	321b0e80 	call	321b0e8 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 322b9b8:	e0bffd03 	ldbu	r2,-12(fp)
 322b9bc:	10803fcc 	andi	r2,r2,255
 322b9c0:	108002a0 	cmpeqi	r2,r2,10
 322b9c4:	103fea1e 	bne	r2,zero,322b970 <npalloc+0x3c>
#endif

#ifdef   MEM_WRAPPERS
   ptr = wrap_alloc(size, calloc2);
#else
   ptr = calloc2(size);
 322b9c8:	e13ffe17 	ldw	r4,-8(fp)
 322b9cc:	322b9000 	call	322b900 <calloc2>
 322b9d0:	e0bffc15 	stw	r2,-16(fp)
#endif

#ifdef UCOS_II 
   err = OSSemPost(mheap_sem_ptr);
 322b9d4:	d128e117 	ldw	r4,-23676(gp)
 322b9d8:	321b4e00 	call	321b4e0 <OSSemPost>
 322b9dc:	e0bffd05 	stb	r2,-12(fp)
#endif
   
   if(!ptr)
 322b9e0:	e0bffc17 	ldw	r2,-16(fp)
 322b9e4:	1004c03a 	cmpne	r2,r2,zero
 322b9e8:	1000021e 	bne	r2,zero,322b9f4 <npalloc+0xc0>
      return NULL;
 322b9ec:	e03fff15 	stw	zero,-4(fp)
 322b9f0:	00000706 	br	322ba10 <npalloc+0xdc>

   MEMSET(ptr, 0, size);
 322b9f4:	e0bffc17 	ldw	r2,-16(fp)
 322b9f8:	1009883a 	mov	r4,r2
 322b9fc:	e1bffe17 	ldw	r6,-8(fp)
 322ba00:	000b883a 	mov	r5,zero
 322ba04:	3206c500 	call	3206c50 <memset>
   return ptr;      
 322ba08:	e0bffc17 	ldw	r2,-16(fp)
 322ba0c:	e0bfff15 	stw	r2,-4(fp)
 322ba10:	e0bfff17 	ldw	r2,-4(fp)
}
 322ba14:	e037883a 	mov	sp,fp
 322ba18:	dfc00117 	ldw	ra,4(sp)
 322ba1c:	df000017 	ldw	fp,0(sp)
 322ba20:	dec00204 	addi	sp,sp,8
 322ba24:	f800283a 	ret

0322ba28 <npfree>:

void
npfree(void * ptr)
{
 322ba28:	defffb04 	addi	sp,sp,-20
 322ba2c:	dfc00415 	stw	ra,16(sp)
 322ba30:	df000315 	stw	fp,12(sp)
 322ba34:	df000304 	addi	fp,sp,12
 322ba38:	e13fff15 	stw	r4,-4(fp)
#ifdef UCOS_II
   INT8U err;

   OSSemPend(mheap_sem_ptr, 0, &err);
 322ba3c:	d128e117 	ldw	r4,-23676(gp)
 322ba40:	e1bffe04 	addi	r6,fp,-8
 322ba44:	000b883a 	mov	r5,zero
 322ba48:	321b0e80 	call	321b0e8 <OSSemPend>
   if (err)
 322ba4c:	e0bffe03 	ldbu	r2,-8(fp)
 322ba50:	10803fcc 	andi	r2,r2,255
 322ba54:	1005003a 	cmpeq	r2,r2,zero
 322ba58:	1000171e 	bne	r2,zero,322bab8 <npfree+0x90>
   {
      int errct = 0;
 322ba5c:	e03ffd15 	stw	zero,-12(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 322ba60:	00001106 	br	322baa8 <npfree+0x80>
      {
         if (errct++ > 1000)
 322ba64:	e0bffd17 	ldw	r2,-12(fp)
 322ba68:	1080fa48 	cmpgei	r2,r2,1001
 322ba6c:	1007883a 	mov	r3,r2
 322ba70:	e0bffd17 	ldw	r2,-12(fp)
 322ba74:	10800044 	addi	r2,r2,1
 322ba78:	e0bffd15 	stw	r2,-12(fp)
 322ba7c:	18803fcc 	andi	r2,r3,255
 322ba80:	1005003a 	cmpeq	r2,r2,zero
 322ba84:	1000041e 	bne	r2,zero,322ba98 <npfree+0x70>
         {
            panic("npfree");    /* fatal? */
 322ba88:	0100c974 	movhi	r4,805
 322ba8c:	213e0904 	addi	r4,r4,-2012
 322ba90:	32261540 	call	3226154 <panic>
            return;
 322ba94:	00000d06 	br	322bacc <npfree+0xa4>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 322ba98:	d128e117 	ldw	r4,-23676(gp)
 322ba9c:	e1bffe04 	addi	r6,fp,-8
 322baa0:	000b883a 	mov	r5,zero
 322baa4:	321b0e80 	call	321b0e8 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 322baa8:	e0bffe03 	ldbu	r2,-8(fp)
 322baac:	10803fcc 	andi	r2,r2,255
 322bab0:	108002a0 	cmpeqi	r2,r2,10
 322bab4:	103feb1e 	bne	r2,zero,322ba64 <npfree+0x3c>
   }
   
#ifdef   MEM_WRAPPERS
   wrap_free((char*)ptr, free);
#else
   free(ptr);
 322bab8:	e13fff17 	ldw	r4,-4(fp)
 322babc:	324bc980 	call	324bc98 <free>
#endif

   err = OSSemPost(mheap_sem_ptr);
 322bac0:	d128e117 	ldw	r4,-23676(gp)
 322bac4:	321b4e00 	call	321b4e0 <OSSemPost>
 322bac8:	e0bffe05 	stb	r2,-8(fp)
 */
   free(ptr);
#endif
#endif

}
 322bacc:	e037883a 	mov	sp,fp
 322bad0:	dfc00117 	ldw	ra,4(sp)
 322bad4:	df000017 	ldw	fp,0(sp)
 322bad8:	dec00204 	addi	sp,sp,8
 322badc:	f800283a 	ret

0322bae0 <ncpalloc>:
 * contains macro definitions that assign specific memory
 * allocation calls to these routines.
 */
#ifdef ALT_INICHE
char * ncpalloc(unsigned size)
{
 322bae0:	defffc04 	addi	sp,sp,-16
 322bae4:	dfc00315 	stw	ra,12(sp)
 322bae8:	df000215 	stw	fp,8(sp)
 322baec:	df000204 	addi	fp,sp,8
 322baf0:	e13fff15 	stw	r4,-4(fp)
   char *ptr = npalloc(size);
 322baf4:	e13fff17 	ldw	r4,-4(fp)
 322baf8:	322b9340 	call	322b934 <npalloc>
 322bafc:	e0bffe15 	stw	r2,-8(fp)

   if(ptr) {
 322bb00:	e0bffe17 	ldw	r2,-8(fp)
 322bb04:	1005003a 	cmpeq	r2,r2,zero
 322bb08:	1000041e 	bne	r2,zero,322bb1c <ncpalloc+0x3c>
      ptr = (char *) alt_remap_uncached(ptr, size);
 322bb0c:	e13ffe17 	ldw	r4,-8(fp)
 322bb10:	e17fff17 	ldw	r5,-4(fp)
 322bb14:	323afe40 	call	323afe4 <alt_remap_uncached>
 322bb18:	e0bffe15 	stw	r2,-8(fp)
   }

   return ptr;
 322bb1c:	e0bffe17 	ldw	r2,-8(fp)
}
 322bb20:	e037883a 	mov	sp,fp
 322bb24:	dfc00117 	ldw	ra,4(sp)
 322bb28:	df000017 	ldw	fp,0(sp)
 322bb2c:	dec00204 	addi	sp,sp,8
 322bb30:	f800283a 	ret

0322bb34 <ncpfree>:

void ncpfree(void *ptr)
{
 322bb34:	defffd04 	addi	sp,sp,-12
 322bb38:	dfc00215 	stw	ra,8(sp)
 322bb3c:	df000115 	stw	fp,4(sp)
 322bb40:	df000104 	addi	fp,sp,4
 322bb44:	e13fff15 	stw	r4,-4(fp)
   if(ptr) {
 322bb48:	e0bfff17 	ldw	r2,-4(fp)
 322bb4c:	1005003a 	cmpeq	r2,r2,zero
 322bb50:	1000061e 	bne	r2,zero,322bb6c <ncpfree+0x38>
      ptr = alt_remap_cached(ptr, sizeof(ptr));
 322bb54:	e13fff17 	ldw	r4,-4(fp)
 322bb58:	01400104 	movi	r5,4
 322bb5c:	323afac0 	call	323afac <alt_remap_cached>
 322bb60:	e0bfff15 	stw	r2,-4(fp)
      npfree(ptr);
 322bb64:	e13fff17 	ldw	r4,-4(fp)
 322bb68:	322ba280 	call	322ba28 <npfree>
   }
}
 322bb6c:	e037883a 	mov	sp,fp
 322bb70:	dfc00117 	ldw	ra,4(sp)
 322bb74:	df000017 	ldw	fp,0(sp)
 322bb78:	dec00204 	addi	sp,sp,8
 322bb7c:	f800283a 	ret

0322bb80 <pffindtype>:
 * RETURNS: 
 */

struct protosw *  
pffindtype(int domain, int type)
{
 322bb80:	defffb04 	addi	sp,sp,-20
 322bb84:	dfc00415 	stw	ra,16(sp)
 322bb88:	df000315 	stw	fp,12(sp)
 322bb8c:	df000304 	addi	fp,sp,12
 322bb90:	e13ffd15 	stw	r4,-12(fp)
 322bb94:	e17ffe15 	stw	r5,-8(fp)

   /* check that the passed domain is vaid for the build */
   if (domain != AF_INET)
 322bb98:	e0bffd17 	ldw	r2,-12(fp)
 322bb9c:	108000a0 	cmpeqi	r2,r2,2
 322bba0:	1000031e 	bne	r2,zero,322bbb0 <pffindtype+0x30>
   {
#ifdef IP_V6
      if(domain != AF_INET6)
#endif
      {
         dtrap();    /* programming error */
 322bba4:	322aef00 	call	322aef0 <dtrap>
         return NULL;
 322bba8:	e03fff15 	stw	zero,-4(fp)
 322bbac:	00001606 	br	322bc08 <pffindtype+0x88>
      }
   }

   if (type == SOCK_STREAM)
 322bbb0:	e0bffe17 	ldw	r2,-8(fp)
 322bbb4:	10800058 	cmpnei	r2,r2,1
 322bbb8:	1000041e 	bne	r2,zero,322bbcc <pffindtype+0x4c>
      return &tcp_protosw;
 322bbbc:	0080c974 	movhi	r2,805
 322bbc0:	10894c04 	addi	r2,r2,9520
 322bbc4:	e0bfff15 	stw	r2,-4(fp)
 322bbc8:	00000f06 	br	322bc08 <pffindtype+0x88>
#ifdef UDP_SOCKETS
   else if(type == SOCK_DGRAM)
 322bbcc:	e0bffe17 	ldw	r2,-8(fp)
 322bbd0:	10800098 	cmpnei	r2,r2,2
 322bbd4:	1000041e 	bne	r2,zero,322bbe8 <pffindtype+0x68>
      return &udp_protosw;
 322bbd8:	0080c974 	movhi	r2,805
 322bbdc:	10895204 	addi	r2,r2,9544
 322bbe0:	e0bfff15 	stw	r2,-4(fp)
 322bbe4:	00000806 	br	322bc08 <pffindtype+0x88>
#endif   /* UDP_SOCKETS */
#ifdef IP_RAW
   else if(type == SOCK_RAW)
 322bbe8:	e0bffe17 	ldw	r2,-8(fp)
 322bbec:	108000d8 	cmpnei	r2,r2,3
 322bbf0:	1000041e 	bne	r2,zero,322bc04 <pffindtype+0x84>
      return &rawip_protosw;
 322bbf4:	0080c974 	movhi	r2,805
 322bbf8:	10895804 	addi	r2,r2,9568
 322bbfc:	e0bfff15 	stw	r2,-4(fp)
 322bc00:	00000106 	br	322bc08 <pffindtype+0x88>
#endif  /* IP_RAW */
   else
      return NULL;
 322bc04:	e03fff15 	stw	zero,-4(fp)
 322bc08:	e0bfff17 	ldw	r2,-4(fp)
}
 322bc0c:	e037883a 	mov	sp,fp
 322bc10:	dfc00117 	ldw	ra,4(sp)
 322bc14:	df000017 	ldw	fp,0(sp)
 322bc18:	dec00204 	addi	sp,sp,8
 322bc1c:	f800283a 	ret

0322bc20 <pffindproto>:
 * RETURNS: 
 */

struct protosw *  
pffindproto(int domain, int protocol, int type)
{
 322bc20:	defff904 	addi	sp,sp,-28
 322bc24:	dfc00615 	stw	ra,24(sp)
 322bc28:	df000515 	stw	fp,20(sp)
 322bc2c:	df000504 	addi	fp,sp,20
 322bc30:	e13ffb15 	stw	r4,-20(fp)
 322bc34:	e17ffc15 	stw	r5,-16(fp)
 322bc38:	e1bffd15 	stw	r6,-12(fp)
#ifdef IP_RAW
   if (type == SOCK_RAW)
 322bc3c:	e0bffd17 	ldw	r2,-12(fp)
 322bc40:	108000d8 	cmpnei	r2,r2,3
 322bc44:	1000051e 	bne	r2,zero,322bc5c <pffindproto+0x3c>
      return(pffindtype(domain, type));
 322bc48:	e13ffb17 	ldw	r4,-20(fp)
 322bc4c:	e17ffd17 	ldw	r5,-12(fp)
 322bc50:	322bb800 	call	322bb80 <pffindtype>
 322bc54:	e0bffe15 	stw	r2,-8(fp)
 322bc58:	00001f06 	br	322bcd8 <pffindproto+0xb8>
#endif

   switch (protocol)
 322bc5c:	e0bffc17 	ldw	r2,-16(fp)
 322bc60:	e0bfff15 	stw	r2,-4(fp)
 322bc64:	e0ffff17 	ldw	r3,-4(fp)
 322bc68:	188001a0 	cmpeqi	r2,r3,6
 322bc6c:	1000071e 	bne	r2,zero,322bc8c <pffindproto+0x6c>
 322bc70:	e0ffff17 	ldw	r3,-4(fp)
 322bc74:	18800460 	cmpeqi	r2,r3,17
 322bc78:	10000a1e 	bne	r2,zero,322bca4 <pffindproto+0x84>
 322bc7c:	e0ffff17 	ldw	r3,-4(fp)
 322bc80:	1805003a 	cmpeq	r2,r3,zero
 322bc84:	1000101e 	bne	r2,zero,322bcc8 <pffindproto+0xa8>
 322bc88:	00000c06 	br	322bcbc <pffindproto+0x9c>
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
 322bc8c:	e0bffd17 	ldw	r2,-12(fp)
 322bc90:	10800060 	cmpeqi	r2,r2,1
 322bc94:	10000c1e 	bne	r2,zero,322bcc8 <pffindproto+0xa8>
         break;
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
 322bc98:	322aef00 	call	322aef0 <dtrap>
      return NULL;
 322bc9c:	e03ffe15 	stw	zero,-8(fp)
 322bca0:	00000d06 	br	322bcd8 <pffindproto+0xb8>
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
 322bca4:	e0bffd17 	ldw	r2,-12(fp)
 322bca8:	108000a0 	cmpeqi	r2,r2,2
 322bcac:	1000061e 	bne	r2,zero,322bcc8 <pffindproto+0xa8>
         break;
      /* IPPROTO_UDP protocol on non-SOCK_DGRAM type socket */
      dtrap();
 322bcb0:	322aef00 	call	322aef0 <dtrap>
      return NULL;
 322bcb4:	e03ffe15 	stw	zero,-8(fp)
 322bcb8:	00000706 	br	322bcd8 <pffindproto+0xb8>
   case 0:
      /* let protocol default based on socket type */
      break;
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
 322bcbc:	322aef00 	call	322aef0 <dtrap>
      return NULL;
 322bcc0:	e03ffe15 	stw	zero,-8(fp)
 322bcc4:	00000406 	br	322bcd8 <pffindproto+0xb8>
   }
   return(pffindtype(domain, type));   /* map to findtype */
 322bcc8:	e13ffb17 	ldw	r4,-20(fp)
 322bccc:	e17ffd17 	ldw	r5,-12(fp)
 322bcd0:	322bb800 	call	322bb80 <pffindtype>
 322bcd4:	e0bffe15 	stw	r2,-8(fp)
 322bcd8:	e0bffe17 	ldw	r2,-8(fp)
}
 322bcdc:	e037883a 	mov	sp,fp
 322bce0:	dfc00117 	ldw	ra,4(sp)
 322bce4:	df000017 	ldw	fp,0(sp)
 322bce8:	dec00204 	addi	sp,sp,8
 322bcec:	f800283a 	ret

0322bcf0 <m_getnbuf>:
 * RETURNS: 
 */

struct mbuf *  
m_getnbuf(int type, int len)
{
 322bcf0:	defff904 	addi	sp,sp,-28
 322bcf4:	dfc00615 	stw	ra,24(sp)
 322bcf8:	df000515 	stw	fp,20(sp)
 322bcfc:	df000504 	addi	fp,sp,20
 322bd00:	e13ffd15 	stw	r4,-12(fp)
 322bd04:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m;
   PACKET pkt = NULL;
 322bd08:	e03ffb15 	stw	zero,-20(fp)

#ifdef NPDEBUG
   if (type < MT_RXDATA || type > MT_IFADDR)
 322bd0c:	e0bffd17 	ldw	r2,-12(fp)
 322bd10:	10800050 	cmplti	r2,r2,1
 322bd14:	1000031e 	bne	r2,zero,322bd24 <m_getnbuf+0x34>
 322bd18:	e0bffd17 	ldw	r2,-12(fp)
 322bd1c:	10800390 	cmplti	r2,r2,14
 322bd20:	1000011e 	bne	r2,zero,322bd28 <m_getnbuf+0x38>
   {
      dtrap(); /* is this OK? */
 322bd24:	322aef00 	call	322aef0 <dtrap>
   }
#endif

   /* if caller has data (len >= 0), we need to allocate 
    * a packet buffer; else all we need is the mbuf */
   if (len != 0)
 322bd28:	e0bffe17 	ldw	r2,-8(fp)
 322bd2c:	1005003a 	cmpeq	r2,r2,zero
 322bd30:	10000e1e 	bne	r2,zero,322bd6c <m_getnbuf+0x7c>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 322bd34:	01000084 	movi	r4,2
 322bd38:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pkt = pk_alloc(len + HDRSLEN);
 322bd3c:	e0bffe17 	ldw	r2,-8(fp)
 322bd40:	10800e04 	addi	r2,r2,56
 322bd44:	1009883a 	mov	r4,r2
 322bd48:	322a2ac0 	call	322a2ac <pk_alloc>
 322bd4c:	e0bffb15 	stw	r2,-20(fp)

      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322bd50:	01000084 	movi	r4,2
 322bd54:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      if (!pkt)
 322bd58:	e0bffb17 	ldw	r2,-20(fp)
 322bd5c:	1004c03a 	cmpne	r2,r2,zero
 322bd60:	1000021e 	bne	r2,zero,322bd6c <m_getnbuf+0x7c>
         return NULL;
 322bd64:	e03fff15 	stw	zero,-4(fp)
 322bd68:	00004506 	br	322be80 <m_getnbuf+0x190>
   }

   m = (struct mbuf *)getq(&mfreeq);
 322bd6c:	0100c9b4 	movhi	r4,806
 322bd70:	21349b04 	addi	r4,r4,-11668
 322bd74:	322a7b80 	call	322a7b8 <getq>
 322bd78:	e0bffc15 	stw	r2,-16(fp)
   if (!m)
 322bd7c:	e0bffc17 	ldw	r2,-16(fp)
 322bd80:	1004c03a 	cmpne	r2,r2,zero
 322bd84:	10000b1e 	bne	r2,zero,322bdb4 <m_getnbuf+0xc4>
   {
      if (pkt) 
 322bd88:	e0bffb17 	ldw	r2,-20(fp)
 322bd8c:	1005003a 	cmpeq	r2,r2,zero
 322bd90:	1000061e 	bne	r2,zero,322bdac <m_getnbuf+0xbc>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 322bd94:	01000084 	movi	r4,2
 322bd98:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 322bd9c:	e13ffb17 	ldw	r4,-20(fp)
 322bda0:	322a6400 	call	322a640 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322bda4:	01000084 	movi	r4,2
 322bda8:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      }
      return NULL;
 322bdac:	e03fff15 	stw	zero,-4(fp)
 322bdb0:	00003306 	br	322be80 <m_getnbuf+0x190>
   }
   m->m_type = type;
 322bdb4:	e0fffc17 	ldw	r3,-16(fp)
 322bdb8:	e0bffd17 	ldw	r2,-12(fp)
 322bdbc:	18800815 	stw	r2,32(r3)
   if (len == 0)
 322bdc0:	e0bffe17 	ldw	r2,-8(fp)
 322bdc4:	1004c03a 	cmpne	r2,r2,zero
 322bdc8:	1000071e 	bne	r2,zero,322bde8 <m_getnbuf+0xf8>
   {
      m->pkt = NULL;
 322bdcc:	e0bffc17 	ldw	r2,-16(fp)
 322bdd0:	10000115 	stw	zero,4(r2)
      m->m_base = NULL;    /* caller better fill these in! */
 322bdd4:	e0bffc17 	ldw	r2,-16(fp)
 322bdd8:	10000415 	stw	zero,16(r2)
      m->m_memsz = 0;
 322bddc:	e0bffc17 	ldw	r2,-16(fp)
 322bde0:	10000515 	stw	zero,20(r2)
 322bde4:	00001506 	br	322be3c <m_getnbuf+0x14c>
   }
   else
   {
      m->pkt = pkt;
 322bde8:	e0fffc17 	ldw	r3,-16(fp)
 322bdec:	e0bffb17 	ldw	r2,-20(fp)
 322bdf0:	18800115 	stw	r2,4(r3)
      /* set m_data to the part where tcp data should go */
      m->m_base = m->m_data = pkt->nb_prot = pkt->nb_buff + HDRSLEN;
 322bdf4:	e0bffb17 	ldw	r2,-20(fp)
 322bdf8:	10800117 	ldw	r2,4(r2)
 322bdfc:	10c00e04 	addi	r3,r2,56
 322be00:	e0bffb17 	ldw	r2,-20(fp)
 322be04:	10c00315 	stw	r3,12(r2)
 322be08:	e0bffb17 	ldw	r2,-20(fp)
 322be0c:	10c00317 	ldw	r3,12(r2)
 322be10:	e0bffc17 	ldw	r2,-16(fp)
 322be14:	10c00315 	stw	r3,12(r2)
 322be18:	e0bffc17 	ldw	r2,-16(fp)
 322be1c:	10c00317 	ldw	r3,12(r2)
 322be20:	e0bffc17 	ldw	r2,-16(fp)
 322be24:	10c00415 	stw	r3,16(r2)
      m->m_memsz = pkt->nb_blen - HDRSLEN;
 322be28:	e0bffb17 	ldw	r2,-20(fp)
 322be2c:	10800217 	ldw	r2,8(r2)
 322be30:	10fff204 	addi	r3,r2,-56
 322be34:	e0bffc17 	ldw	r2,-16(fp)
 322be38:	10c00515 	stw	r3,20(r2)
   }
   m->m_len = 0;
 322be3c:	e0bffc17 	ldw	r2,-16(fp)
 322be40:	10000215 	stw	zero,8(r2)
   m->m_next = m->m_act = NULL;
 322be44:	e0bffc17 	ldw	r2,-16(fp)
 322be48:	10000715 	stw	zero,28(r2)
 322be4c:	e0bffc17 	ldw	r2,-16(fp)
 322be50:	10c00717 	ldw	r3,28(r2)
 322be54:	e0bffc17 	ldw	r2,-16(fp)
 322be58:	10c00615 	stw	r3,24(r2)
   mbstat.allocs++;        /* maintain local statistics */
 322be5c:	d0a8e517 	ldw	r2,-23660(gp)
 322be60:	10800044 	addi	r2,r2,1
 322be64:	d0a8e515 	stw	r2,-23660(gp)
   putq(&mbufq, (qp)m);
 322be68:	e17ffc17 	ldw	r5,-16(fp)
 322be6c:	0100c9b4 	movhi	r4,806
 322be70:	21349604 	addi	r4,r4,-11688
 322be74:	322a8800 	call	322a880 <putq>
   return m;
 322be78:	e0bffc17 	ldw	r2,-16(fp)
 322be7c:	e0bfff15 	stw	r2,-4(fp)
 322be80:	e0bfff17 	ldw	r2,-4(fp)
}
 322be84:	e037883a 	mov	sp,fp
 322be88:	dfc00117 	ldw	ra,4(sp)
 322be8c:	df000017 	ldw	fp,0(sp)
 322be90:	dec00204 	addi	sp,sp,8
 322be94:	f800283a 	ret

0322be98 <m_free>:
 */


struct mbuf *  
m_free(struct mbuf * m)
{
 322be98:	defffb04 	addi	sp,sp,-20
 322be9c:	dfc00415 	stw	ra,16(sp)
 322bea0:	df000315 	stw	fp,12(sp)
 322bea4:	df000304 	addi	fp,sp,12
 322bea8:	e13ffe15 	stw	r4,-8(fp)
   struct mbuf *  nextptr;

#ifdef NPDEBUG
   if (mbufq.q_len < 1)
 322beac:	0080c9b4 	movhi	r2,806
 322beb0:	10b49604 	addi	r2,r2,-11688
 322beb4:	10800217 	ldw	r2,8(r2)
 322beb8:	10800048 	cmpgei	r2,r2,1
 322bebc:	1000031e 	bne	r2,zero,322becc <m_free+0x34>
      panic("mfree: q_len");
 322bec0:	0100c974 	movhi	r4,805
 322bec4:	213e0b04 	addi	r4,r4,-2004
 322bec8:	32261540 	call	3226154 <panic>

   if (m->m_type < MT_RXDATA || m->m_type > MT_IFADDR)
 322becc:	e0bffe17 	ldw	r2,-8(fp)
 322bed0:	10800817 	ldw	r2,32(r2)
 322bed4:	10800050 	cmplti	r2,r2,1
 322bed8:	1000041e 	bne	r2,zero,322beec <m_free+0x54>
 322bedc:	e0bffe17 	ldw	r2,-8(fp)
 322bee0:	10800817 	ldw	r2,32(r2)
 322bee4:	10800390 	cmplti	r2,r2,14
 322bee8:	10000c1e 	bne	r2,zero,322bf1c <m_free+0x84>
   {
      if (m->m_type == MT_FREE)
 322beec:	e0bffe17 	ldw	r2,-8(fp)
 322bef0:	10800817 	ldw	r2,32(r2)
 322bef4:	1004c03a 	cmpne	r2,r2,zero
 322bef8:	1000051e 	bne	r2,zero,322bf10 <m_free+0x78>
      {
         dtrap(); /* debug double free of mbuf by tcp_in() */
 322befc:	322aef00 	call	322aef0 <dtrap>
         return m->m_next; /* seems harmless, though.... */
 322bf00:	e0bffe17 	ldw	r2,-8(fp)
 322bf04:	10800617 	ldw	r2,24(r2)
 322bf08:	e0bfff15 	stw	r2,-4(fp)
 322bf0c:	00002906 	br	322bfb4 <m_free+0x11c>
      }
      else
         panic("m_free: type");
 322bf10:	0100c974 	movhi	r4,805
 322bf14:	213e0f04 	addi	r4,r4,-1988
 322bf18:	32261540 	call	3226154 <panic>
   }
#endif   /* NPDEBUG */

   nextptr = m->m_next;    /* remember value to return */
 322bf1c:	e0bffe17 	ldw	r2,-8(fp)
 322bf20:	10800617 	ldw	r2,24(r2)
 322bf24:	e0bffd15 	stw	r2,-12(fp)

   if (qdel(&mbufq, m) == NULL)
 322bf28:	0100c9b4 	movhi	r4,806
 322bf2c:	21349604 	addi	r4,r4,-11688
 322bf30:	e17ffe17 	ldw	r5,-8(fp)
 322bf34:	322a9300 	call	322a930 <qdel>
 322bf38:	1004c03a 	cmpne	r2,r2,zero
 322bf3c:	1000031e 	bne	r2,zero,322bf4c <m_free+0xb4>
      panic("m_free: missing");
 322bf40:	0100c974 	movhi	r4,805
 322bf44:	213e1304 	addi	r4,r4,-1972
 322bf48:	32261540 	call	3226154 <panic>

   m->m_type = MT_FREE;    /* this may seem silly, but helps error checking */
 322bf4c:	e0bffe17 	ldw	r2,-8(fp)
 322bf50:	10000815 	stw	zero,32(r2)

   if (m->pkt)
 322bf54:	e0bffe17 	ldw	r2,-8(fp)
 322bf58:	10800117 	ldw	r2,4(r2)
 322bf5c:	1005003a 	cmpeq	r2,r2,zero
 322bf60:	1000071e 	bne	r2,zero,322bf80 <m_free+0xe8>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 322bf64:	01000084 	movi	r4,2
 322bf68:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(m->pkt);     /* free up the netport buffer */
 322bf6c:	e0bffe17 	ldw	r2,-8(fp)
 322bf70:	11000117 	ldw	r4,4(r2)
 322bf74:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322bf78:	01000084 	movi	r4,2
 322bf7c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   }
   mbstat.frees++;
 322bf80:	0080c974 	movhi	r2,805
 322bf84:	10934804 	addi	r2,r2,19744
 322bf88:	10800017 	ldw	r2,0(r2)
 322bf8c:	10c00044 	addi	r3,r2,1
 322bf90:	0080c974 	movhi	r2,805
 322bf94:	10934804 	addi	r2,r2,19744
 322bf98:	10c00015 	stw	r3,0(r2)
   putq(&mfreeq, (qp)m);
 322bf9c:	e17ffe17 	ldw	r5,-8(fp)
 322bfa0:	0100c9b4 	movhi	r4,806
 322bfa4:	21349b04 	addi	r4,r4,-11668
 322bfa8:	322a8800 	call	322a880 <putq>
   return nextptr;
 322bfac:	e0bffd17 	ldw	r2,-12(fp)
 322bfb0:	e0bfff15 	stw	r2,-4(fp)
 322bfb4:	e0bfff17 	ldw	r2,-4(fp)
}
 322bfb8:	e037883a 	mov	sp,fp
 322bfbc:	dfc00117 	ldw	ra,4(sp)
 322bfc0:	df000017 	ldw	fp,0(sp)
 322bfc4:	dec00204 	addi	sp,sp,8
 322bfc8:	f800283a 	ret

0322bfcc <m_freem>:
 * RETURNS: 
 */

void
m_freem(struct mbuf * m)
{
 322bfcc:	defffd04 	addi	sp,sp,-12
 322bfd0:	dfc00215 	stw	ra,8(sp)
 322bfd4:	df000115 	stw	fp,4(sp)
 322bfd8:	df000104 	addi	fp,sp,4
 322bfdc:	e13fff15 	stw	r4,-4(fp)
   while (m != NULL)
 322bfe0:	00000306 	br	322bff0 <m_freem+0x24>
      m = m_free(m);
 322bfe4:	e13fff17 	ldw	r4,-4(fp)
 322bfe8:	322be980 	call	322be98 <m_free>
 322bfec:	e0bfff15 	stw	r2,-4(fp)
 */

void
m_freem(struct mbuf * m)
{
   while (m != NULL)
 322bff0:	e0bfff17 	ldw	r2,-4(fp)
 322bff4:	1004c03a 	cmpne	r2,r2,zero
 322bff8:	103ffa1e 	bne	r2,zero,322bfe4 <m_freem+0x18>
      m = m_free(m);
}
 322bffc:	e037883a 	mov	sp,fp
 322c000:	dfc00117 	ldw	ra,4(sp)
 322c004:	df000017 	ldw	fp,0(sp)
 322c008:	dec00204 	addi	sp,sp,8
 322c00c:	f800283a 	ret

0322c010 <m_copy>:
 * RETURNS: 
 */

struct mbuf *  
m_copy(struct mbuf * m, int off, int len)
{
 322c010:	defff404 	addi	sp,sp,-48
 322c014:	dfc00b15 	stw	ra,44(sp)
 322c018:	df000a15 	stw	fp,40(sp)
 322c01c:	df000a04 	addi	fp,sp,40
 322c020:	e13ffa15 	stw	r4,-24(fp)
 322c024:	e17ffb15 	stw	r5,-20(fp)
 322c028:	e1bffc15 	stw	r6,-16(fp)
   struct mbuf *  nb, * head, *  tail;
   int   tocopy;

   if (len == 0)  /* nothing to do */
 322c02c:	e0bffc17 	ldw	r2,-16(fp)
 322c030:	1004c03a 	cmpne	r2,r2,zero
 322c034:	1000021e 	bne	r2,zero,322c040 <m_copy+0x30>
      return NULL;
 322c038:	e03ffd15 	stw	zero,-12(fp)
 322c03c:	0000b706 	br	322c31c <m_copy+0x30c>

#ifdef NPDEBUG
   /* sanity test parms */
   if (off < 0 || (len < 0 && len != M_COPYALL))
 322c040:	e0bffb17 	ldw	r2,-20(fp)
 322c044:	1004803a 	cmplt	r2,r2,zero
 322c048:	1000061e 	bne	r2,zero,322c064 <m_copy+0x54>
 322c04c:	e0bffc17 	ldw	r2,-16(fp)
 322c050:	1004403a 	cmpge	r2,r2,zero
 322c054:	1000191e 	bne	r2,zero,322c0bc <m_copy+0xac>
 322c058:	e0bffc17 	ldw	r2,-16(fp)
 322c05c:	10bfffe0 	cmpeqi	r2,r2,-1
 322c060:	1000161e 	bne	r2,zero,322c0bc <m_copy+0xac>
   {
      dtrap();
 322c064:	322aef00 	call	322aef0 <dtrap>
      return NULL;
 322c068:	e03ffd15 	stw	zero,-12(fp)
 322c06c:	0000ab06 	br	322c31c <m_copy+0x30c>
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
   {
      if (!m)
 322c070:	e0bffa17 	ldw	r2,-24(fp)
 322c074:	1004c03a 	cmpne	r2,r2,zero
 322c078:	1000031e 	bne	r2,zero,322c088 <m_copy+0x78>
      {
         dtrap();
 322c07c:	322aef00 	call	322aef0 <dtrap>
         return NULL;
 322c080:	e03ffd15 	stw	zero,-12(fp)
 322c084:	0000a506 	br	322c31c <m_copy+0x30c>
      }
      if (off < (int)m->m_len)
 322c088:	e0bffa17 	ldw	r2,-24(fp)
 322c08c:	10800217 	ldw	r2,8(r2)
 322c090:	1007883a 	mov	r3,r2
 322c094:	e0bffb17 	ldw	r2,-20(fp)
 322c098:	10c00b16 	blt	r2,r3,322c0c8 <m_copy+0xb8>
         break;
      off -= m->m_len;
 322c09c:	e0fffb17 	ldw	r3,-20(fp)
 322c0a0:	e0bffa17 	ldw	r2,-24(fp)
 322c0a4:	10800217 	ldw	r2,8(r2)
 322c0a8:	1885c83a 	sub	r2,r3,r2
 322c0ac:	e0bffb15 	stw	r2,-20(fp)
      m = m->m_next;
 322c0b0:	e0bffa17 	ldw	r2,-24(fp)
 322c0b4:	10800617 	ldw	r2,24(r2)
 322c0b8:	e0bffa15 	stw	r2,-24(fp)
      return NULL;
   }
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
 322c0bc:	e0bffb17 	ldw	r2,-20(fp)
 322c0c0:	10800048 	cmpgei	r2,r2,1
 322c0c4:	103fea1e 	bne	r2,zero,322c070 <m_copy+0x60>
         break;
      off -= m->m_len;
      m = m->m_next;
   }

   head = tail = NULL;
 322c0c8:	e03ff715 	stw	zero,-36(fp)
 322c0cc:	e0bff717 	ldw	r2,-36(fp)
 322c0d0:	e0bff815 	stw	r2,-32(fp)

   while (len > 0)
 322c0d4:	00008806 	br	322c2f8 <m_copy+0x2e8>
   {
      if (m == NULL) /* at end of queue? */
 322c0d8:	e0bffa17 	ldw	r2,-24(fp)
 322c0dc:	1004c03a 	cmpne	r2,r2,zero
 322c0e0:	1000051e 	bne	r2,zero,322c0f8 <m_copy+0xe8>
      {
         panic("m_copy: bad len");
 322c0e4:	0100c974 	movhi	r4,805
 322c0e8:	213e1704 	addi	r4,r4,-1956
 322c0ec:	32261540 	call	3226154 <panic>
         return NULL;
 322c0f0:	e03ffd15 	stw	zero,-12(fp)
 322c0f4:	00008906 	br	322c31c <m_copy+0x30c>
      }
      tocopy = (int)MIN(len, (int)(m->m_len - off));
 322c0f8:	e0bffa17 	ldw	r2,-24(fp)
 322c0fc:	10c00217 	ldw	r3,8(r2)
 322c100:	e0bffb17 	ldw	r2,-20(fp)
 322c104:	1885c83a 	sub	r2,r3,r2
 322c108:	e0fffc17 	ldw	r3,-16(fp)
 322c10c:	e0ffff15 	stw	r3,-4(fp)
 322c110:	e0bffe15 	stw	r2,-8(fp)
 322c114:	e0bfff17 	ldw	r2,-4(fp)
 322c118:	e0fffe17 	ldw	r3,-8(fp)
 322c11c:	10c0020e 	bge	r2,r3,322c128 <m_copy+0x118>
 322c120:	e0bfff17 	ldw	r2,-4(fp)
 322c124:	e0bffe15 	stw	r2,-8(fp)
 322c128:	e0fffe17 	ldw	r3,-8(fp)
 322c12c:	e0fff615 	stw	r3,-40(fp)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 322c130:	e0bffb17 	ldw	r2,-20(fp)
 322c134:	108000cc 	andi	r2,r2,3
 322c138:	1004c03a 	cmpne	r2,r2,zero
 322c13c:	1000051e 	bne	r2,zero,322c154 <m_copy+0x144>
 322c140:	e0bffa17 	ldw	r2,-24(fp)
 322c144:	10800117 	ldw	r2,4(r2)
 322c148:	10800917 	ldw	r2,36(r2)
 322c14c:	10800060 	cmpeqi	r2,r2,1
 322c150:	1000251e 	bne	r2,zero,322c1e8 <m_copy+0x1d8>
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
 322c154:	e0bffa17 	ldw	r2,-24(fp)
 322c158:	11000817 	ldw	r4,32(r2)
 322c15c:	e17ff617 	ldw	r5,-40(fp)
 322c160:	322bcf00 	call	322bcf0 <m_getnbuf>
 322c164:	e0bff915 	stw	r2,-28(fp)
 322c168:	e0bff917 	ldw	r2,-28(fp)
 322c16c:	1005003a 	cmpeq	r2,r2,zero
 322c170:	1000671e 	bne	r2,zero,322c310 <m_copy+0x300>
            goto nospace;
         MEMCPY(nb->m_data, m->m_data+off, tocopy);
 322c174:	e0bff917 	ldw	r2,-28(fp)
 322c178:	11000317 	ldw	r4,12(r2)
 322c17c:	e0bffa17 	ldw	r2,-24(fp)
 322c180:	10c00317 	ldw	r3,12(r2)
 322c184:	e0bffb17 	ldw	r2,-20(fp)
 322c188:	1885883a 	add	r2,r3,r2
 322c18c:	e0fff617 	ldw	r3,-40(fp)
 322c190:	100b883a 	mov	r5,r2
 322c194:	180d883a 	mov	r6,r3
 322c198:	3206ad00 	call	3206ad0 <memcpy>
         nb->m_len = tocopy;  /* set length of data we just moved into new mbuf */
 322c19c:	e0fff617 	ldw	r3,-40(fp)
 322c1a0:	e0bff917 	ldw	r2,-28(fp)
 322c1a4:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mcopies++;
 322c1a8:	0080c9b4 	movhi	r2,806
 322c1ac:	10b4b504 	addi	r2,r2,-11564
 322c1b0:	10802e17 	ldw	r2,184(r2)
 322c1b4:	10c00044 	addi	r3,r2,1
 322c1b8:	0080c9b4 	movhi	r2,806
 322c1bc:	10b4b504 	addi	r2,r2,-11564
 322c1c0:	10c02e15 	stw	r3,184(r2)
         tcpstat.tcps_mcopiedbytes += tocopy;
 322c1c4:	0080c9b4 	movhi	r2,806
 322c1c8:	10b4b504 	addi	r2,r2,-11564
 322c1cc:	10c03017 	ldw	r3,192(r2)
 322c1d0:	e0bff617 	ldw	r2,-40(fp)
 322c1d4:	1887883a 	add	r3,r3,r2
 322c1d8:	0080c9b4 	movhi	r2,806
 322c1dc:	10b4b504 	addi	r2,r2,-11564
 322c1e0:	10c03015 	stw	r3,192(r2)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 322c1e4:	00003106 	br	322c2ac <m_copy+0x29c>
      {
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
 322c1e8:	e0bffa17 	ldw	r2,-24(fp)
 322c1ec:	11000817 	ldw	r4,32(r2)
 322c1f0:	000b883a 	mov	r5,zero
 322c1f4:	322bcf00 	call	322bcf0 <m_getnbuf>
 322c1f8:	e0bff915 	stw	r2,-28(fp)
 322c1fc:	e0bff917 	ldw	r2,-28(fp)
 322c200:	1005003a 	cmpeq	r2,r2,zero
 322c204:	1000421e 	bne	r2,zero,322c310 <m_copy+0x300>
            goto nospace;

         m->pkt->inuse++;     /* bump pkt use count to clone it */
 322c208:	e0bffa17 	ldw	r2,-24(fp)
 322c20c:	10c00117 	ldw	r3,4(r2)
 322c210:	18800917 	ldw	r2,36(r3)
 322c214:	10800044 	addi	r2,r2,1
 322c218:	18800915 	stw	r2,36(r3)

         /* set up new mbuf with pointers to cloned packet */
         nb->pkt = m->pkt;
 322c21c:	e0bffa17 	ldw	r2,-24(fp)
 322c220:	10c00117 	ldw	r3,4(r2)
 322c224:	e0bff917 	ldw	r2,-28(fp)
 322c228:	10c00115 	stw	r3,4(r2)
         nb->m_base = m->m_base;
 322c22c:	e0bffa17 	ldw	r2,-24(fp)
 322c230:	10c00417 	ldw	r3,16(r2)
 322c234:	e0bff917 	ldw	r2,-28(fp)
 322c238:	10c00415 	stw	r3,16(r2)
         nb->m_memsz = m->m_memsz;
 322c23c:	e0bffa17 	ldw	r2,-24(fp)
 322c240:	10c00517 	ldw	r3,20(r2)
 322c244:	e0bff917 	ldw	r2,-28(fp)
 322c248:	10c00515 	stw	r3,20(r2)
         nb->m_data = m->m_data + off;
 322c24c:	e0bffa17 	ldw	r2,-24(fp)
 322c250:	10c00317 	ldw	r3,12(r2)
 322c254:	e0bffb17 	ldw	r2,-20(fp)
 322c258:	1887883a 	add	r3,r3,r2
 322c25c:	e0bff917 	ldw	r2,-28(fp)
 322c260:	10c00315 	stw	r3,12(r2)
         nb->m_len = tocopy;
 322c264:	e0fff617 	ldw	r3,-40(fp)
 322c268:	e0bff917 	ldw	r2,-28(fp)
 322c26c:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mclones++;
 322c270:	0080c9b4 	movhi	r2,806
 322c274:	10b4b504 	addi	r2,r2,-11564
 322c278:	10802f17 	ldw	r2,188(r2)
 322c27c:	10c00044 	addi	r3,r2,1
 322c280:	0080c9b4 	movhi	r2,806
 322c284:	10b4b504 	addi	r2,r2,-11564
 322c288:	10c02f15 	stw	r3,188(r2)
         tcpstat.tcps_mclonedbytes += tocopy;
 322c28c:	0080c9b4 	movhi	r2,806
 322c290:	10b4b504 	addi	r2,r2,-11564
 322c294:	10c03117 	ldw	r3,196(r2)
 322c298:	e0bff617 	ldw	r2,-40(fp)
 322c29c:	1887883a 	add	r3,r3,r2
 322c2a0:	0080c9b4 	movhi	r2,806
 322c2a4:	10b4b504 	addi	r2,r2,-11564
 322c2a8:	10c03115 	stw	r3,196(r2)
      }

      len -= tocopy;
 322c2ac:	e0fffc17 	ldw	r3,-16(fp)
 322c2b0:	e0bff617 	ldw	r2,-40(fp)
 322c2b4:	1885c83a 	sub	r2,r3,r2
 322c2b8:	e0bffc15 	stw	r2,-16(fp)
      off = 0;
 322c2bc:	e03ffb15 	stw	zero,-20(fp)
      if (tail)      /* head & tail are set by first pass thru loop */
 322c2c0:	e0bff717 	ldw	r2,-36(fp)
 322c2c4:	1005003a 	cmpeq	r2,r2,zero
 322c2c8:	1000041e 	bne	r2,zero,322c2dc <m_copy+0x2cc>
         tail->m_next = nb;
 322c2cc:	e0fff717 	ldw	r3,-36(fp)
 322c2d0:	e0bff917 	ldw	r2,-28(fp)
 322c2d4:	18800615 	stw	r2,24(r3)
 322c2d8:	00000206 	br	322c2e4 <m_copy+0x2d4>
      else
         head = nb;
 322c2dc:	e0bff917 	ldw	r2,-28(fp)
 322c2e0:	e0bff815 	stw	r2,-32(fp)
      tail = nb;     /* always make new mbuf the tail */
 322c2e4:	e0bff917 	ldw	r2,-28(fp)
 322c2e8:	e0bff715 	stw	r2,-36(fp)
      m = m->m_next;
 322c2ec:	e0bffa17 	ldw	r2,-24(fp)
 322c2f0:	10800617 	ldw	r2,24(r2)
 322c2f4:	e0bffa15 	stw	r2,-24(fp)
      m = m->m_next;
   }

   head = tail = NULL;

   while (len > 0)
 322c2f8:	e0bffc17 	ldw	r2,-16(fp)
 322c2fc:	10800048 	cmpgei	r2,r2,1
 322c300:	103f751e 	bne	r2,zero,322c0d8 <m_copy+0xc8>
      tail = nb;     /* always make new mbuf the tail */
      m = m->m_next;

   }

   return head;
 322c304:	e0bff817 	ldw	r2,-32(fp)
 322c308:	e0bffd15 	stw	r2,-12(fp)
 322c30c:	00000306 	br	322c31c <m_copy+0x30c>

nospace:
   m_freem (head);
 322c310:	e13ff817 	ldw	r4,-32(fp)
 322c314:	322bfcc0 	call	322bfcc <m_freem>
   return NULL;
 322c318:	e03ffd15 	stw	zero,-12(fp)
 322c31c:	e0bffd17 	ldw	r2,-12(fp)
}
 322c320:	e037883a 	mov	sp,fp
 322c324:	dfc00117 	ldw	ra,4(sp)
 322c328:	df000017 	ldw	fp,0(sp)
 322c32c:	dec00204 	addi	sp,sp,8
 322c330:	f800283a 	ret

0322c334 <m_adj>:
 * RETURNS: 
 */

void
m_adj(struct mbuf * mp, int len)
{
 322c334:	defffb04 	addi	sp,sp,-20
 322c338:	df000415 	stw	fp,16(sp)
 322c33c:	df000404 	addi	fp,sp,16
 322c340:	e13ffe15 	stw	r4,-8(fp)
 322c344:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
 322c348:	e0bffe17 	ldw	r2,-8(fp)
 322c34c:	e0bffd15 	stw	r2,-12(fp)
 322c350:	e0bffd17 	ldw	r2,-12(fp)
 322c354:	1005003a 	cmpeq	r2,r2,zero
 322c358:	1000661e 	bne	r2,zero,322c4f4 <m_adj+0x1c0>
      return;

   if (len >= 0) 
 322c35c:	e0bfff17 	ldw	r2,-4(fp)
 322c360:	1004803a 	cmplt	r2,r2,zero
 322c364:	1000241e 	bne	r2,zero,322c3f8 <m_adj+0xc4>
   {
      while (m != NULL && len > 0) 
 322c368:	00001c06 	br	322c3dc <m_adj+0xa8>
      {
         if (m->m_len <= (unsigned)len)
 322c36c:	e0bffd17 	ldw	r2,-12(fp)
 322c370:	10c00217 	ldw	r3,8(r2)
 322c374:	e0bfff17 	ldw	r2,-4(fp)
 322c378:	10c00b36 	bltu	r2,r3,322c3a8 <m_adj+0x74>
         {
            len -= m->m_len;
 322c37c:	e0ffff17 	ldw	r3,-4(fp)
 322c380:	e0bffd17 	ldw	r2,-12(fp)
 322c384:	10800217 	ldw	r2,8(r2)
 322c388:	1885c83a 	sub	r2,r3,r2
 322c38c:	e0bfff15 	stw	r2,-4(fp)
            m->m_len = 0;
 322c390:	e0bffd17 	ldw	r2,-12(fp)
 322c394:	10000215 	stw	zero,8(r2)
            m = m->m_next;
 322c398:	e0bffd17 	ldw	r2,-12(fp)
 322c39c:	10800617 	ldw	r2,24(r2)
 322c3a0:	e0bffd15 	stw	r2,-12(fp)
 322c3a4:	00000d06 	br	322c3dc <m_adj+0xa8>
         }
         else
         {
            m->m_len -= len;
 322c3a8:	e0bffd17 	ldw	r2,-12(fp)
 322c3ac:	10c00217 	ldw	r3,8(r2)
 322c3b0:	e0bfff17 	ldw	r2,-4(fp)
 322c3b4:	1887c83a 	sub	r3,r3,r2
 322c3b8:	e0bffd17 	ldw	r2,-12(fp)
 322c3bc:	10c00215 	stw	r3,8(r2)
            m->m_data += len;
 322c3c0:	e0bffd17 	ldw	r2,-12(fp)
 322c3c4:	10c00317 	ldw	r3,12(r2)
 322c3c8:	e0bfff17 	ldw	r2,-4(fp)
 322c3cc:	1887883a 	add	r3,r3,r2
 322c3d0:	e0bffd17 	ldw	r2,-12(fp)
 322c3d4:	10c00315 	stw	r3,12(r2)
            break;
 322c3d8:	00004606 	br	322c4f4 <m_adj+0x1c0>
   if ((m = mp) == NULL)
      return;

   if (len >= 0) 
   {
      while (m != NULL && len > 0) 
 322c3dc:	e0bffd17 	ldw	r2,-12(fp)
 322c3e0:	1005003a 	cmpeq	r2,r2,zero
 322c3e4:	1000431e 	bne	r2,zero,322c4f4 <m_adj+0x1c0>
 322c3e8:	e0bfff17 	ldw	r2,-4(fp)
 322c3ec:	10800048 	cmpgei	r2,r2,1
 322c3f0:	103fde1e 	bne	r2,zero,322c36c <m_adj+0x38>
 322c3f4:	00003f06 	br	322c4f4 <m_adj+0x1c0>
       * calculating its length and finding the last mbuf.
       * If the adjustment only affects this mbuf, then just
       * adjust and return.  Otherwise, rescan and truncate
       * after the remaining size.
       */
      len = -len;
 322c3f8:	e0bfff17 	ldw	r2,-4(fp)
 322c3fc:	0085c83a 	sub	r2,zero,r2
 322c400:	e0bfff15 	stw	r2,-4(fp)
      count = 0;
 322c404:	e03ffc15 	stw	zero,-16(fp)
      for (;;) 
      {
         count += m->m_len;
 322c408:	e0bffd17 	ldw	r2,-12(fp)
 322c40c:	10c00217 	ldw	r3,8(r2)
 322c410:	e0bffc17 	ldw	r2,-16(fp)
 322c414:	1885883a 	add	r2,r3,r2
 322c418:	e0bffc15 	stw	r2,-16(fp)
         if (m->m_next == (struct mbuf *)0)
 322c41c:	e0bffd17 	ldw	r2,-12(fp)
 322c420:	10800617 	ldw	r2,24(r2)
 322c424:	1005003a 	cmpeq	r2,r2,zero
 322c428:	1000041e 	bne	r2,zero,322c43c <m_adj+0x108>
            break;
         m = m->m_next;
 322c42c:	e0bffd17 	ldw	r2,-12(fp)
 322c430:	10800617 	ldw	r2,24(r2)
 322c434:	e0bffd15 	stw	r2,-12(fp)
      }
 322c438:	003ff306 	br	322c408 <m_adj+0xd4>
      if (m->m_len >= (unsigned)len)
 322c43c:	e0bffd17 	ldw	r2,-12(fp)
 322c440:	10c00217 	ldw	r3,8(r2)
 322c444:	e0bfff17 	ldw	r2,-4(fp)
 322c448:	18800736 	bltu	r3,r2,322c468 <m_adj+0x134>
      {
         m->m_len -= len;
 322c44c:	e0bffd17 	ldw	r2,-12(fp)
 322c450:	10c00217 	ldw	r3,8(r2)
 322c454:	e0bfff17 	ldw	r2,-4(fp)
 322c458:	1887c83a 	sub	r3,r3,r2
 322c45c:	e0bffd17 	ldw	r2,-12(fp)
 322c460:	10c00215 	stw	r3,8(r2)
         return;
 322c464:	00002306 	br	322c4f4 <m_adj+0x1c0>
      }
      count -= len;
 322c468:	e0fffc17 	ldw	r3,-16(fp)
 322c46c:	e0bfff17 	ldw	r2,-4(fp)
 322c470:	1885c83a 	sub	r2,r3,r2
 322c474:	e0bffc15 	stw	r2,-16(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 322c478:	e0bffe17 	ldw	r2,-8(fp)
 322c47c:	e0bffd15 	stw	r2,-12(fp)
 322c480:	00001006 	br	322c4c4 <m_adj+0x190>
      {
         if (m->m_len >= (unsigned)count)
 322c484:	e0bffd17 	ldw	r2,-12(fp)
 322c488:	10c00217 	ldw	r3,8(r2)
 322c48c:	e0bffc17 	ldw	r2,-16(fp)
 322c490:	18800436 	bltu	r3,r2,322c4a4 <m_adj+0x170>
         {
            m->m_len = count;
 322c494:	e0fffc17 	ldw	r3,-16(fp)
 322c498:	e0bffd17 	ldw	r2,-12(fp)
 322c49c:	10c00215 	stw	r3,8(r2)
            break;
 322c4a0:	00000e06 	br	322c4dc <m_adj+0x1a8>
         }
         count -= m->m_len;
 322c4a4:	e0fffc17 	ldw	r3,-16(fp)
 322c4a8:	e0bffd17 	ldw	r2,-12(fp)
 322c4ac:	10800217 	ldw	r2,8(r2)
 322c4b0:	1885c83a 	sub	r2,r3,r2
 322c4b4:	e0bffc15 	stw	r2,-16(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 322c4b8:	e0bffd17 	ldw	r2,-12(fp)
 322c4bc:	10800617 	ldw	r2,24(r2)
 322c4c0:	e0bffd15 	stw	r2,-12(fp)
 322c4c4:	e0bffd17 	ldw	r2,-12(fp)
 322c4c8:	1004c03a 	cmpne	r2,r2,zero
 322c4cc:	103fed1e 	bne	r2,zero,322c484 <m_adj+0x150>
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 322c4d0:	00000206 	br	322c4dc <m_adj+0x1a8>
         m->m_len = 0;
 322c4d4:	e0bffd17 	ldw	r2,-12(fp)
 322c4d8:	10000215 	stw	zero,8(r2)
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 322c4dc:	e0bffd17 	ldw	r2,-12(fp)
 322c4e0:	10800617 	ldw	r2,24(r2)
 322c4e4:	e0bffd15 	stw	r2,-12(fp)
 322c4e8:	e0bffd17 	ldw	r2,-12(fp)
 322c4ec:	1004c03a 	cmpne	r2,r2,zero
 322c4f0:	103ff81e 	bne	r2,zero,322c4d4 <m_adj+0x1a0>
         m->m_len = 0;
   }
}
 322c4f4:	e037883a 	mov	sp,fp
 322c4f8:	df000017 	ldw	fp,0(sp)
 322c4fc:	dec00104 	addi	sp,sp,4
 322c500:	f800283a 	ret

0322c504 <mbuf_len>:
 * RETURNS: 
 */

int
mbuf_len (struct mbuf * m)
{
 322c504:	defffd04 	addi	sp,sp,-12
 322c508:	df000215 	stw	fp,8(sp)
 322c50c:	df000204 	addi	fp,sp,8
 322c510:	e13fff15 	stw	r4,-4(fp)
   int   len   =  0;
 322c514:	e03ffe15 	stw	zero,-8(fp)

   while (m)
 322c518:	00000806 	br	322c53c <mbuf_len+0x38>
   {
      len += m->m_len;
 322c51c:	e0bfff17 	ldw	r2,-4(fp)
 322c520:	10c00217 	ldw	r3,8(r2)
 322c524:	e0bffe17 	ldw	r2,-8(fp)
 322c528:	1885883a 	add	r2,r3,r2
 322c52c:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 322c530:	e0bfff17 	ldw	r2,-4(fp)
 322c534:	10800617 	ldw	r2,24(r2)
 322c538:	e0bfff15 	stw	r2,-4(fp)
int
mbuf_len (struct mbuf * m)
{
   int   len   =  0;

   while (m)
 322c53c:	e0bfff17 	ldw	r2,-4(fp)
 322c540:	1004c03a 	cmpne	r2,r2,zero
 322c544:	103ff51e 	bne	r2,zero,322c51c <mbuf_len+0x18>
   {
      len += m->m_len;
      m = m->m_next;
   }
   return len;
 322c548:	e0bffe17 	ldw	r2,-8(fp)
}
 322c54c:	e037883a 	mov	sp,fp
 322c550:	df000017 	ldw	fp,0(sp)
 322c554:	dec00104 	addi	sp,sp,4
 322c558:	f800283a 	ret

0322c55c <dtom>:
 * RETURNS: 
 */

struct mbuf *  
dtom(void * data)
{
 322c55c:	defffa04 	addi	sp,sp,-24
 322c560:	dfc00515 	stw	ra,20(sp)
 322c564:	df000415 	stw	fp,16(sp)
 322c568:	df000404 	addi	fp,sp,16
 322c56c:	e13ffe15 	stw	r4,-8(fp)
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 322c570:	0080c9b4 	movhi	r2,806
 322c574:	10b49604 	addi	r2,r2,-11688
 322c578:	10800017 	ldw	r2,0(r2)
 322c57c:	e0bffd15 	stw	r2,-12(fp)
 322c580:	00001306 	br	322c5d0 <dtom+0x74>
   {
      m = (struct mbuf *)qptr;
 322c584:	e0bffd17 	ldw	r2,-12(fp)
 322c588:	e0bffc15 	stw	r2,-16(fp)

      if (IN_RANGE(m->m_base, m->m_memsz, (char*)data))
 322c58c:	e0bffc17 	ldw	r2,-16(fp)
 322c590:	10c00417 	ldw	r3,16(r2)
 322c594:	e0bffe17 	ldw	r2,-8(fp)
 322c598:	10c00a36 	bltu	r2,r3,322c5c4 <dtom+0x68>
 322c59c:	e0bffc17 	ldw	r2,-16(fp)
 322c5a0:	10c00417 	ldw	r3,16(r2)
 322c5a4:	e0bffc17 	ldw	r2,-16(fp)
 322c5a8:	10800517 	ldw	r2,20(r2)
 322c5ac:	1887883a 	add	r3,r3,r2
 322c5b0:	e0bffe17 	ldw	r2,-8(fp)
 322c5b4:	10c0032e 	bgeu	r2,r3,322c5c4 <dtom+0x68>
         return (struct mbuf *)qptr;
 322c5b8:	e0bffd17 	ldw	r2,-12(fp)
 322c5bc:	e0bfff15 	stw	r2,-4(fp)
 322c5c0:	00000a06 	br	322c5ec <dtom+0x90>
dtom(void * data)
{
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 322c5c4:	e0bffd17 	ldw	r2,-12(fp)
 322c5c8:	10800017 	ldw	r2,0(r2)
 322c5cc:	e0bffd15 	stw	r2,-12(fp)
 322c5d0:	e0bffd17 	ldw	r2,-12(fp)
 322c5d4:	1004c03a 	cmpne	r2,r2,zero
 322c5d8:	103fea1e 	bne	r2,zero,322c584 <dtom+0x28>
      else
         continue;

   }

   panic("dtom");    /* data not found in any "in use" mbuf */
 322c5dc:	0100c974 	movhi	r4,805
 322c5e0:	213e1b04 	addi	r4,r4,-1940
 322c5e4:	32261540 	call	3226154 <panic>
   return NULL;
 322c5e8:	e03fff15 	stw	zero,-4(fp)
 322c5ec:	e0bfff17 	ldw	r2,-4(fp)
}
 322c5f0:	e037883a 	mov	sp,fp
 322c5f4:	dfc00117 	ldw	ra,4(sp)
 322c5f8:	df000017 	ldw	fp,0(sp)
 322c5fc:	dec00204 	addi	sp,sp,8
 322c600:	f800283a 	ret

0322c604 <remque>:
};


void
remque (void * arg)
{
 322c604:	defffd04 	addi	sp,sp,-12
 322c608:	df000215 	stw	fp,8(sp)
 322c60c:	df000204 	addi	fp,sp,8
 322c610:	e13fff15 	stw	r4,-4(fp)
   struct bsdq *  old;

   old = (struct bsdq *)arg;
 322c614:	e0bfff17 	ldw	r2,-4(fp)
 322c618:	e0bffe15 	stw	r2,-8(fp)
   if (!old->prev) return;
 322c61c:	e0bffe17 	ldw	r2,-8(fp)
 322c620:	10800117 	ldw	r2,4(r2)
 322c624:	1005003a 	cmpeq	r2,r2,zero
 322c628:	10000e1e 	bne	r2,zero,322c664 <remque+0x60>
      old->prev->next = old->next;
 322c62c:	e0bffe17 	ldw	r2,-8(fp)
 322c630:	10c00117 	ldw	r3,4(r2)
 322c634:	e0bffe17 	ldw	r2,-8(fp)
 322c638:	10800017 	ldw	r2,0(r2)
 322c63c:	18800015 	stw	r2,0(r3)
   if (old->next)
 322c640:	e0bffe17 	ldw	r2,-8(fp)
 322c644:	10800017 	ldw	r2,0(r2)
 322c648:	1005003a 	cmpeq	r2,r2,zero
 322c64c:	1000051e 	bne	r2,zero,322c664 <remque+0x60>
      old->next->prev = old->prev;
 322c650:	e0bffe17 	ldw	r2,-8(fp)
 322c654:	10c00017 	ldw	r3,0(r2)
 322c658:	e0bffe17 	ldw	r2,-8(fp)
 322c65c:	10800117 	ldw	r2,4(r2)
 322c660:	18800115 	stw	r2,4(r3)
}
 322c664:	e037883a 	mov	sp,fp
 322c668:	df000017 	ldw	fp,0(sp)
 322c66c:	dec00104 	addi	sp,sp,4
 322c670:	f800283a 	ret

0322c674 <insque>:
 * RETURNS: 
 */

void
insque(void * n, void * p)
{
 322c674:	defffb04 	addi	sp,sp,-20
 322c678:	df000415 	stw	fp,16(sp)
 322c67c:	df000404 	addi	fp,sp,16
 322c680:	e13ffe15 	stw	r4,-8(fp)
 322c684:	e17fff15 	stw	r5,-4(fp)
   struct bsdq *  newe, *  prev;

   newe = (struct bsdq *)n;
 322c688:	e0bffe17 	ldw	r2,-8(fp)
 322c68c:	e0bffd15 	stw	r2,-12(fp)
   prev = (struct bsdq *)p;
 322c690:	e0bfff17 	ldw	r2,-4(fp)
 322c694:	e0bffc15 	stw	r2,-16(fp)
   newe->next = prev->next;
 322c698:	e0bffc17 	ldw	r2,-16(fp)
 322c69c:	10c00017 	ldw	r3,0(r2)
 322c6a0:	e0bffd17 	ldw	r2,-12(fp)
 322c6a4:	10c00015 	stw	r3,0(r2)
   newe->prev = prev;
 322c6a8:	e0fffd17 	ldw	r3,-12(fp)
 322c6ac:	e0bffc17 	ldw	r2,-16(fp)
 322c6b0:	18800115 	stw	r2,4(r3)
   prev->next = newe;
 322c6b4:	e0fffc17 	ldw	r3,-16(fp)
 322c6b8:	e0bffd17 	ldw	r2,-12(fp)
 322c6bc:	18800015 	stw	r2,0(r3)
   if (newe->next)
 322c6c0:	e0bffd17 	ldw	r2,-12(fp)
 322c6c4:	10800017 	ldw	r2,0(r2)
 322c6c8:	1005003a 	cmpeq	r2,r2,zero
 322c6cc:	1000041e 	bne	r2,zero,322c6e0 <insque+0x6c>
      newe->next->prev = newe;
 322c6d0:	e0bffd17 	ldw	r2,-12(fp)
 322c6d4:	10c00017 	ldw	r3,0(r2)
 322c6d8:	e0bffd17 	ldw	r2,-12(fp)
 322c6dc:	18800115 	stw	r2,4(r3)
}
 322c6e0:	e037883a 	mov	sp,fp
 322c6e4:	df000017 	ldw	fp,0(sp)
 322c6e8:	dec00104 	addi	sp,sp,4
 322c6ec:	f800283a 	ret

0322c6f0 <nptcp_init>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
nptcp_init()
{
 322c6f0:	defffb04 	addi	sp,sp,-20
 322c6f4:	dfc00415 	stw	ra,16(sp)
 322c6f8:	df000315 	stw	fp,12(sp)
 322c6fc:	df000304 	addi	fp,sp,12
    * buffers, soreceive() can't complete and the packet buffers stay 
    * on the queue, so we allocate 3 extra mbufs in the hope that 
    * this will allow soreceive() to complete and free up the packet 
    * buffers. yes, its kind of an ugly hack and 3 is a wild guess.
    */
   unsigned bufcount = (lilbufs + bigbufs) * 2 + 3;
 322c700:	0080c974 	movhi	r2,805
 322c704:	108a9404 	addi	r2,r2,10832
 322c708:	10c00017 	ldw	r3,0(r2)
 322c70c:	0080c974 	movhi	r2,805
 322c710:	108a9604 	addi	r2,r2,10840
 322c714:	10800017 	ldw	r2,0(r2)
 322c718:	1885883a 	add	r2,r3,r2
 322c71c:	1085883a 	add	r2,r2,r2
 322c720:	108000c4 	addi	r2,r2,3
 322c724:	e0bffe15 	stw	r2,-8(fp)
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
 322c728:	0080c9b4 	movhi	r2,806
 322c72c:	10b48204 	addi	r2,r2,-11768
 322c730:	10000015 	stw	zero,0(r2)
 322c734:	10000115 	stw	zero,4(r2)
 322c738:	10000215 	stw	zero,8(r2)
 322c73c:	10000315 	stw	zero,12(r2)
 322c740:	10000415 	stw	zero,16(r2)
   MEMSET(&mbufq, 0, sizeof(mbufq));
 322c744:	0080c9b4 	movhi	r2,806
 322c748:	10b49604 	addi	r2,r2,-11688
 322c74c:	10000015 	stw	zero,0(r2)
 322c750:	10000115 	stw	zero,4(r2)
 322c754:	10000215 	stw	zero,8(r2)
 322c758:	10000315 	stw	zero,12(r2)
 322c75c:	10000415 	stw	zero,16(r2)
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
 322c760:	0080c9b4 	movhi	r2,806
 322c764:	10b49b04 	addi	r2,r2,-11668
 322c768:	10000015 	stw	zero,0(r2)
 322c76c:	10000115 	stw	zero,4(r2)
 322c770:	10000215 	stw	zero,8(r2)
 322c774:	10000315 	stw	zero,12(r2)
 322c778:	10000415 	stw	zero,16(r2)
   for (i = 0; i < (int)bufcount; i++)
 322c77c:	e03fff15 	stw	zero,-4(fp)
 322c780:	00001606 	br	322c7dc <nptcp_init+0xec>
   {
      m = MBU_ALLOC(sizeof(struct mbuf));
 322c784:	01000904 	movi	r4,36
 322c788:	322b9340 	call	322b934 <npalloc>
 322c78c:	e0bffd15 	stw	r2,-12(fp)
      if (!m)  /* malloc error, bail out */
 322c790:	e0bffd17 	ldw	r2,-12(fp)
 322c794:	1004c03a 	cmpne	r2,r2,zero
 322c798:	1000031e 	bne	r2,zero,322c7a8 <nptcp_init+0xb8>
         panic("tcpinit");
 322c79c:	0100c974 	movhi	r4,805
 322c7a0:	213e1d04 	addi	r4,r4,-1932
 322c7a4:	32261540 	call	3226154 <panic>
      m->m_type = MT_FREE;
 322c7a8:	e0bffd17 	ldw	r2,-12(fp)
 322c7ac:	10000815 	stw	zero,32(r2)
      m->m_len = 0;
 322c7b0:	e0bffd17 	ldw	r2,-12(fp)
 322c7b4:	10000215 	stw	zero,8(r2)
      m->m_data = NULL;
 322c7b8:	e0bffd17 	ldw	r2,-12(fp)
 322c7bc:	10000315 	stw	zero,12(r2)
      putq(&mfreeq, (qp)m);
 322c7c0:	e17ffd17 	ldw	r5,-12(fp)
 322c7c4:	0100c9b4 	movhi	r4,806
 322c7c8:	21349b04 	addi	r4,r4,-11668
 322c7cc:	322a8800 	call	322a880 <putq>
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
   MEMSET(&mbufq, 0, sizeof(mbufq));
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
   for (i = 0; i < (int)bufcount; i++)
 322c7d0:	e0bfff17 	ldw	r2,-4(fp)
 322c7d4:	10800044 	addi	r2,r2,1
 322c7d8:	e0bfff15 	stw	r2,-4(fp)
 322c7dc:	e0fffe17 	ldw	r3,-8(fp)
 322c7e0:	e0bfff17 	ldw	r2,-4(fp)
 322c7e4:	10ffe716 	blt	r2,r3,322c784 <nptcp_init+0x94>
      m->m_type = MT_FREE;
      m->m_len = 0;
      m->m_data = NULL;
      putq(&mfreeq, (qp)m);
   }
   mfreeq.q_min = (int)bufcount;   /* this should match q_max and q_len */
 322c7e8:	e0fffe17 	ldw	r3,-8(fp)
 322c7ec:	0080c9b4 	movhi	r2,806
 322c7f0:	10b49b04 	addi	r2,r2,-11668
 322c7f4:	10c00415 	stw	r3,16(r2)
   tcpmib.tcpRtoAlgorithm = 4;     /* Van Jacobson's algorithm */
   tcpmib.tcpRtoMin = TCPTV_MIN * 1000;      /* PR_SLOWHZ */
   tcpmib.tcpRtoMax = TCPTV_REXMTMAX * 1000; /* PR_SLOWHZ */
#endif

   tcp_init();    /* call the BSD init in tcp_usr.c */
 322c7f8:	3237a0c0 	call	3237a0c <tcp_init>

#ifdef TCP_MENUS
   install_menu(&tcpmenu[0]);
#endif   /* IN_MENUS */

   return 0;   /* good return */
 322c7fc:	0005883a 	mov	r2,zero
}
 322c800:	e037883a 	mov	sp,fp
 322c804:	dfc00117 	ldw	ra,4(sp)
 322c808:	df000017 	ldw	fp,0(sp)
 322c80c:	dec00204 	addi	sp,sp,8
 322c810:	f800283a 	ret

0322c814 <tcp_rcv>:

#ifdef IP_V4
 
int
tcp_rcv(PACKET pkt)     /* NOTE: pkt has nb_prot pointing to IP header */
{
 322c814:	defff804 	addi	sp,sp,-32
 322c818:	dfc00715 	stw	ra,28(sp)
 322c81c:	df000615 	stw	fp,24(sp)
 322c820:	df000604 	addi	fp,sp,24
 322c824:	e13ffe15 	stw	r4,-8(fp)

   /* For TCP, the netport IP layer is modified to set nb_prot to the 
    * start of the IP header (not TCP). We need to do some further
    * mods which the BSD code expects:
    */
   bip = (struct ip *)pkt->nb_prot;    /* get ip header */
 322c828:	e0bffe17 	ldw	r2,-8(fp)
 322c82c:	10800317 	ldw	r2,12(r2)
 322c830:	e0bffc15 	stw	r2,-16(fp)
   len = ntohs(bip->ip_len);  /* get length in local endian */
 322c834:	e0bffc17 	ldw	r2,-16(fp)
 322c838:	1080008b 	ldhu	r2,2(r2)
 322c83c:	10bfffcc 	andi	r2,r2,65535
 322c840:	1004d23a 	srli	r2,r2,8
 322c844:	10803fcc 	andi	r2,r2,255
 322c848:	1009883a 	mov	r4,r2
 322c84c:	e0bffc17 	ldw	r2,-16(fp)
 322c850:	1080008b 	ldhu	r2,2(r2)
 322c854:	10bfffcc 	andi	r2,r2,65535
 322c858:	1004923a 	slli	r2,r2,8
 322c85c:	1007883a 	mov	r3,r2
 322c860:	00bfc004 	movi	r2,-256
 322c864:	1884703a 	and	r2,r3,r2
 322c868:	2084b03a 	or	r2,r4,r2
 322c86c:	e0bffa0d 	sth	r2,-24(fp)

   /* verify checksum of received packet */

   tcpp = (struct tcphdr *)ip_data(bip);
 322c870:	e0bffc17 	ldw	r2,-16(fp)
 322c874:	10800003 	ldbu	r2,0(r2)
 322c878:	10803fcc 	andi	r2,r2,255
 322c87c:	108003cc 	andi	r2,r2,15
 322c880:	1085883a 	add	r2,r2,r2
 322c884:	1085883a 	add	r2,r2,r2
 322c888:	1007883a 	mov	r3,r2
 322c88c:	e0bffc17 	ldw	r2,-16(fp)
 322c890:	1885883a 	add	r2,r3,r2
 322c894:	e0bffb15 	stw	r2,-20(fp)
   if (tcp_cksum(bip) != tcpp->th_sum)
 322c898:	e13ffc17 	ldw	r4,-16(fp)
 322c89c:	32480180 	call	3248018 <tcp_cksum>
 322c8a0:	1007883a 	mov	r3,r2
 322c8a4:	e0bffb17 	ldw	r2,-20(fp)
 322c8a8:	1080040b 	ldhu	r2,16(r2)
 322c8ac:	18ffffcc 	andi	r3,r3,65535
 322c8b0:	10bfffcc 	andi	r2,r2,65535
 322c8b4:	18801726 	beq	r3,r2,322c914 <tcp_rcv+0x100>
   {
      TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 322c8b8:	0080c9b4 	movhi	r2,806
 322c8bc:	10b48704 	addi	r2,r2,-11748
 322c8c0:	10800d17 	ldw	r2,52(r2)
 322c8c4:	10c00044 	addi	r3,r2,1
 322c8c8:	0080c9b4 	movhi	r2,806
 322c8cc:	10b48704 	addi	r2,r2,-11748
 322c8d0:	10c00d15 	stw	r3,52(r2)
      tcpstat.tcps_rcvbadsum++;  /* keep BSD stats */
 322c8d4:	0080c9b4 	movhi	r2,806
 322c8d8:	10b4b504 	addi	r2,r2,-11564
 322c8dc:	10801c17 	ldw	r2,112(r2)
 322c8e0:	10c00044 	addi	r3,r2,1
 322c8e4:	0080c9b4 	movhi	r2,806
 322c8e8:	10b4b504 	addi	r2,r2,-11564
 322c8ec:	10c01c15 	stw	r3,112(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 322c8f0:	01000084 	movi	r4,2
 322c8f4:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(pkt);  /* punt packet */
 322c8f8:	e13ffe17 	ldw	r4,-8(fp)
 322c8fc:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322c900:	01000084 	movi	r4,2
 322c904:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 322c908:	00bff804 	movi	r2,-32
 322c90c:	e0bfff15 	stw	r2,-4(fp)
 322c910:	00003506 	br	322c9e8 <tcp_rcv+0x1d4>
   }

   m_in = m_getnbuf(MT_RXDATA, 0);
 322c914:	01000044 	movi	r4,1
 322c918:	000b883a 	mov	r5,zero
 322c91c:	322bcf00 	call	322bcf0 <m_getnbuf>
 322c920:	e0bffd15 	stw	r2,-12(fp)
   if (!m_in){
 322c924:	e0bffd17 	ldw	r2,-12(fp)
 322c928:	1004c03a 	cmpne	r2,r2,zero
 322c92c:	1000091e 	bne	r2,zero,322c954 <tcp_rcv+0x140>
      LOCK_NET_RESOURCE(FREEQ_RESID);
 322c930:	01000084 	movi	r4,2
 322c934:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 322c938:	e13ffe17 	ldw	r4,-8(fp)
 322c93c:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322c940:	01000084 	movi	r4,2
 322c944:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;  
 322c948:	00bffa84 	movi	r2,-22
 322c94c:	e0bfff15 	stw	r2,-4(fp)
 322c950:	00002506 	br	322c9e8 <tcp_rcv+0x1d4>
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);      /* measure time in TCP */

   /* subtract IP header length from total IP packet length */
   len -= ((unshort)(bip->ip_ver_ihl & 0x0f) << 2);
 322c954:	e0bffc17 	ldw	r2,-16(fp)
 322c958:	10800003 	ldbu	r2,0(r2)
 322c95c:	10803fcc 	andi	r2,r2,255
 322c960:	108003cc 	andi	r2,r2,15
 322c964:	1085883a 	add	r2,r2,r2
 322c968:	1085883a 	add	r2,r2,r2
 322c96c:	1007883a 	mov	r3,r2
 322c970:	e0bffa0b 	ldhu	r2,-24(fp)
 322c974:	10c5c83a 	sub	r2,r2,r3
 322c978:	e0bffa0d 	sth	r2,-24(fp)
   bip->ip_len = len;   /* put TCP length in struct for TCP code to use */
 322c97c:	e0fffc17 	ldw	r3,-16(fp)
 322c980:	e0bffa0b 	ldhu	r2,-24(fp)
 322c984:	1880008d 	sth	r2,2(r3)

   /* set mbuf to point to start of IP header (not TCP) */
   m_in->pkt = pkt;
 322c988:	e0fffd17 	ldw	r3,-12(fp)
 322c98c:	e0bffe17 	ldw	r2,-8(fp)
 322c990:	18800115 	stw	r2,4(r3)
   m_in->m_data = pkt->nb_prot;
 322c994:	e0bffe17 	ldw	r2,-8(fp)
 322c998:	10c00317 	ldw	r3,12(r2)
 322c99c:	e0bffd17 	ldw	r2,-12(fp)
 322c9a0:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 322c9a4:	e0bffe17 	ldw	r2,-8(fp)
 322c9a8:	10c00417 	ldw	r3,16(r2)
 322c9ac:	e0bffd17 	ldw	r2,-12(fp)
 322c9b0:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;     /* ??? */
 322c9b4:	e0bffe17 	ldw	r2,-8(fp)
 322c9b8:	10c00117 	ldw	r3,4(r2)
 322c9bc:	e0bffd17 	ldw	r2,-12(fp)
 322c9c0:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;    /* ??? */
 322c9c4:	e0bffe17 	ldw	r2,-8(fp)
 322c9c8:	10c00217 	ldw	r3,8(r2)
 322c9cc:	e0bffd17 	ldw	r2,-12(fp)
 322c9d0:	10c00515 	stw	r3,20(r2)

   tcp_input(m_in, pkt->net);
 322c9d4:	e0bffe17 	ldw	r2,-8(fp)
 322c9d8:	11400617 	ldw	r5,24(r2)
 322c9dc:	e13ffd17 	ldw	r4,-12(fp)
 322c9e0:	3233acc0 	call	3233acc <tcp_input>

   IN_PROFILER(PF_TCP, PF_EXIT);      /* measure time in TCP */

   return 0;
 322c9e4:	e03fff15 	stw	zero,-4(fp)
 322c9e8:	e0bfff17 	ldw	r2,-4(fp)
}
 322c9ec:	e037883a 	mov	sp,fp
 322c9f0:	dfc00117 	ldw	ra,4(sp)
 322c9f4:	df000017 	ldw	fp,0(sp)
 322c9f8:	dec00204 	addi	sp,sp,8
 322c9fc:	f800283a 	ret

0322ca00 <ip_output>:
 * RETURNS: 
 */

int
ip_output(struct mbuf * data, struct   ip_socopts * so_optsPack) /* mbuf chain with data to send */
{
 322ca00:	defff304 	addi	sp,sp,-52
 322ca04:	dfc00c15 	stw	ra,48(sp)
 322ca08:	df000b15 	stw	fp,44(sp)
 322ca0c:	df000b04 	addi	fp,sp,44
 322ca10:	e13ffd15 	stw	r4,-12(fp)
 322ca14:	e17ffe15 	stw	r5,-8(fp)
    * little copying as possible. Typically the mbufs will be either 
    * 1) a single mbuf with iptcp header info only (e.g.tcp ACK 
    * packet), or 2) iptcp header with data mbuf chained to it, or 3) 
    * #2) with a tiny option data mbuf between header and data. 
    */
   if ((data->m_next))
 322ca18:	e0bffd17 	ldw	r2,-12(fp)
 322ca1c:	10800617 	ldw	r2,24(r2)
 322ca20:	1005003a 	cmpeq	r2,r2,zero
 322ca24:	1001101e 	bne	r2,zero,322ce68 <ip_output+0x468>
   {
      m1 = data;
 322ca28:	e0bffd17 	ldw	r2,-12(fp)
 322ca2c:	e0bff915 	stw	r2,-28(fp)
      m2 = data->m_next;
 322ca30:	e0bffd17 	ldw	r2,-12(fp)
 322ca34:	10800617 	ldw	r2,24(r2)
 322ca38:	e0bff815 	stw	r2,-32(fp)

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 322ca3c:	00003406 	br	322cb10 <ip_output+0x110>
      {
         pkt = m1->pkt;
 322ca40:	e0bff917 	ldw	r2,-28(fp)
 322ca44:	10800117 	ldw	r2,4(r2)
 322ca48:	e0bffa15 	stw	r2,-24(fp)
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 322ca4c:	e0bffa17 	ldw	r2,-24(fp)
 322ca50:	10c00117 	ldw	r3,4(r2)
 322ca54:	e0bffa17 	ldw	r2,-24(fp)
 322ca58:	10800217 	ldw	r2,8(r2)
 322ca5c:	1889883a 	add	r4,r3,r2
 322ca60:	e0bff917 	ldw	r2,-28(fp)
 322ca64:	10c00317 	ldw	r3,12(r2)
 322ca68:	e0bff917 	ldw	r2,-28(fp)
 322ca6c:	10800217 	ldw	r2,8(r2)
 322ca70:	1887883a 	add	r3,r3,r2
 322ca74:	e0bff817 	ldw	r2,-32(fp)
 322ca78:	10800217 	ldw	r2,8(r2)
 322ca7c:	1885883a 	add	r2,r3,r2
 322ca80:	1100822e 	bgeu	r2,r4,322cc8c <ip_output+0x28c>
             (m1->m_data + m1->m_len + m2->m_len))
         {
            MEMCPY((m1->m_data + m1->m_len), m2->m_data, m2->m_len);
 322ca84:	e0bff917 	ldw	r2,-28(fp)
 322ca88:	10c00317 	ldw	r3,12(r2)
 322ca8c:	e0bff917 	ldw	r2,-28(fp)
 322ca90:	10800217 	ldw	r2,8(r2)
 322ca94:	1887883a 	add	r3,r3,r2
 322ca98:	e0bff817 	ldw	r2,-32(fp)
 322ca9c:	11400317 	ldw	r5,12(r2)
 322caa0:	e0bff817 	ldw	r2,-32(fp)
 322caa4:	10800217 	ldw	r2,8(r2)
 322caa8:	1809883a 	mov	r4,r3
 322caac:	100d883a 	mov	r6,r2
 322cab0:	3206ad00 	call	3206ad0 <memcpy>
            m1->m_len += m2->m_len;
 322cab4:	e0bff917 	ldw	r2,-28(fp)
 322cab8:	10c00217 	ldw	r3,8(r2)
 322cabc:	e0bff817 	ldw	r2,-32(fp)
 322cac0:	10800217 	ldw	r2,8(r2)
 322cac4:	1887883a 	add	r3,r3,r2
 322cac8:	e0bff917 	ldw	r2,-28(fp)
 322cacc:	10c00215 	stw	r3,8(r2)
            m1->m_next = m2->m_next;
 322cad0:	e0bff817 	ldw	r2,-32(fp)
 322cad4:	10c00617 	ldw	r3,24(r2)
 322cad8:	e0bff917 	ldw	r2,-28(fp)
 322cadc:	10c00615 	stw	r3,24(r2)
            m_free(m2);    /* free this m2.... */
 322cae0:	e13ff817 	ldw	r4,-32(fp)
 322cae4:	322be980 	call	322be98 <m_free>
            m2 = m1->m_next;  /* ...and thread the next one */
 322cae8:	e0bff917 	ldw	r2,-28(fp)
 322caec:	10800617 	ldw	r2,24(r2)
 322caf0:	e0bff815 	stw	r2,-32(fp)
            tcpstat.tcps_oappends++;
 322caf4:	0080c9b4 	movhi	r2,806
 322caf8:	10b4b504 	addi	r2,r2,-11564
 322cafc:	10803317 	ldw	r2,204(r2)
 322cb00:	10c00044 	addi	r3,r2,1
 322cb04:	0080c9b4 	movhi	r2,806
 322cb08:	10b4b504 	addi	r2,r2,-11564
 322cb0c:	10c03315 	stw	r3,204(r2)
   {
      m1 = data;
      m2 = data->m_next;

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 322cb10:	e0bff817 	ldw	r2,-32(fp)
 322cb14:	1005003a 	cmpeq	r2,r2,zero
 322cb18:	10005c1e 	bne	r2,zero,322cc8c <ip_output+0x28c>
 322cb1c:	e0bff817 	ldw	r2,-32(fp)
 322cb20:	10800217 	ldw	r2,8(r2)
 322cb24:	108002b0 	cmpltui	r2,r2,10
 322cb28:	103fc51e 	bne	r2,zero,322ca40 <ip_output+0x40>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 322cb2c:	00005706 	br	322cc8c <ip_output+0x28c>
      {
         /* try prepending m1 to m2, first see if it fits: */
         e = m2->m_data - m2->pkt->nb_buff;  /* e is prepend space */
 322cb30:	e0bff817 	ldw	r2,-32(fp)
 322cb34:	10800317 	ldw	r2,12(r2)
 322cb38:	1007883a 	mov	r3,r2
 322cb3c:	e0bff817 	ldw	r2,-32(fp)
 322cb40:	10800117 	ldw	r2,4(r2)
 322cb44:	10800117 	ldw	r2,4(r2)
 322cb48:	1885c83a 	sub	r2,r3,r2
 322cb4c:	e0bff615 	stw	r2,-40(fp)
         if (e < MaxLnh)
 322cb50:	0080c974 	movhi	r2,805
 322cb54:	10931a04 	addi	r2,r2,19560
 322cb58:	10c00017 	ldw	r3,0(r2)
 322cb5c:	e0bff617 	ldw	r2,-40(fp)
 322cb60:	10c00a0e 	bge	r2,r3,322cb8c <ip_output+0x18c>
         { 
#ifdef NPDEBUG
            dprintf("nptcp: MaxLnh:%d, e:%d\n", MaxLnh, e);
 322cb64:	0080c974 	movhi	r2,805
 322cb68:	10931a04 	addi	r2,r2,19560
 322cb6c:	11400017 	ldw	r5,0(r2)
 322cb70:	0100c974 	movhi	r4,805
 322cb74:	213e1f04 	addi	r4,r4,-1924
 322cb78:	e1bff617 	ldw	r6,-40(fp)
 322cb7c:	3206de00 	call	3206de0 <printf>
#endif
            panic("tcp_out:mbuf-nbuf");   /* sanity check */
 322cb80:	0100c974 	movhi	r4,805
 322cb84:	213e2504 	addi	r4,r4,-1900
 322cb88:	32261540 	call	3226154 <panic>
         }

         if ((m1->m_len < (unsigned)(e - MaxLnh))  /* leave room for MAC */
 322cb8c:	e0bff917 	ldw	r2,-28(fp)
 322cb90:	11000217 	ldw	r4,8(r2)
 322cb94:	0080c974 	movhi	r2,805
 322cb98:	10931a04 	addi	r2,r2,19560
 322cb9c:	10c00017 	ldw	r3,0(r2)
 322cba0:	e0bff617 	ldw	r2,-40(fp)
 322cba4:	10c5c83a 	sub	r2,r2,r3
 322cba8:	20803b2e 	bgeu	r4,r2,322cc98 <ip_output+0x298>
 322cbac:	e0bff917 	ldw	r2,-28(fp)
 322cbb0:	10800217 	ldw	r2,8(r2)
 322cbb4:	108000cc 	andi	r2,r2,3
 322cbb8:	1004c03a 	cmpne	r2,r2,zero
 322cbbc:	1000361e 	bne	r2,zero,322cc98 <ip_output+0x298>
 322cbc0:	e0bff817 	ldw	r2,-32(fp)
 322cbc4:	10800317 	ldw	r2,12(r2)
 322cbc8:	1007883a 	mov	r3,r2
 322cbcc:	e0bff817 	ldw	r2,-32(fp)
 322cbd0:	10800117 	ldw	r2,4(r2)
 322cbd4:	10800117 	ldw	r2,4(r2)
 322cbd8:	1885c83a 	sub	r2,r3,r2
 322cbdc:	10800e18 	cmpnei	r2,r2,56
 322cbe0:	10002d1e 	bne	r2,zero,322cc98 <ip_output+0x298>
             && ((m1->m_len & (ALIGN_TYPE - 1)) == 0)  /* and stay aligned */
             && ((m2->m_data - m2->pkt->nb_buff) == HDRSLEN))   /* be at start */
         {
            MEMCPY((m2->m_data - m1->m_len), m1->m_data, m1->m_len);
 322cbe4:	e0bff817 	ldw	r2,-32(fp)
 322cbe8:	10c00317 	ldw	r3,12(r2)
 322cbec:	e0bff917 	ldw	r2,-28(fp)
 322cbf0:	10800217 	ldw	r2,8(r2)
 322cbf4:	1887c83a 	sub	r3,r3,r2
 322cbf8:	e0bff917 	ldw	r2,-28(fp)
 322cbfc:	11400317 	ldw	r5,12(r2)
 322cc00:	e0bff917 	ldw	r2,-28(fp)
 322cc04:	10800217 	ldw	r2,8(r2)
 322cc08:	1809883a 	mov	r4,r3
 322cc0c:	100d883a 	mov	r6,r2
 322cc10:	3206ad00 	call	3206ad0 <memcpy>
            m2->m_data -= m1->m_len;   /* fix target to reflect prepend */
 322cc14:	e0bff817 	ldw	r2,-32(fp)
 322cc18:	10c00317 	ldw	r3,12(r2)
 322cc1c:	e0bff917 	ldw	r2,-28(fp)
 322cc20:	10800217 	ldw	r2,8(r2)
 322cc24:	1887c83a 	sub	r3,r3,r2
 322cc28:	e0bff817 	ldw	r2,-32(fp)
 322cc2c:	10c00315 	stw	r3,12(r2)
            m2->m_len += m1->m_len;
 322cc30:	e0bff817 	ldw	r2,-32(fp)
 322cc34:	10c00217 	ldw	r3,8(r2)
 322cc38:	e0bff917 	ldw	r2,-28(fp)
 322cc3c:	10800217 	ldw	r2,8(r2)
 322cc40:	1887883a 	add	r3,r3,r2
 322cc44:	e0bff817 	ldw	r2,-32(fp)
 322cc48:	10c00215 	stw	r3,8(r2)
            m_free(m1);    /* free head (copied) mbuf */
 322cc4c:	e13ff917 	ldw	r4,-28(fp)
 322cc50:	322be980 	call	322be98 <m_free>
            data = m1 = m2;   /* move other mbufs up the chain */
 322cc54:	e0bff817 	ldw	r2,-32(fp)
 322cc58:	e0bff915 	stw	r2,-28(fp)
 322cc5c:	e0bff917 	ldw	r2,-28(fp)
 322cc60:	e0bffd15 	stw	r2,-12(fp)
            m2 = m2->m_next;  /* loop to while(m2) test */
 322cc64:	e0bff817 	ldw	r2,-32(fp)
 322cc68:	10800617 	ldw	r2,24(r2)
 322cc6c:	e0bff815 	stw	r2,-32(fp)
            tcpstat.tcps_oprepends++;
 322cc70:	0080c9b4 	movhi	r2,806
 322cc74:	10b4b504 	addi	r2,r2,-11564
 322cc78:	10803217 	ldw	r2,200(r2)
 322cc7c:	10c00044 	addi	r3,r2,1
 322cc80:	0080c9b4 	movhi	r2,806
 322cc84:	10b4b504 	addi	r2,r2,-11564
 322cc88:	10c03215 	stw	r3,200(r2)
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 322cc8c:	e0bff817 	ldw	r2,-32(fp)
 322cc90:	1004c03a 	cmpne	r2,r2,zero
 322cc94:	103fa61e 	bne	r2,zero,322cb30 <ip_output+0x130>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      if (m2)  /* If all else fails, brute force copy: */
 322cc98:	e0bff817 	ldw	r2,-32(fp)
 322cc9c:	1005003a 	cmpeq	r2,r2,zero
 322cca0:	1000711e 	bne	r2,zero,322ce68 <ip_output+0x468>
      {
         total = 0;
 322cca4:	e03ff515 	stw	zero,-44(fp)
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 322cca8:	e0bff917 	ldw	r2,-28(fp)
 322ccac:	e0bff715 	stw	r2,-36(fp)
 322ccb0:	00000806 	br	322ccd4 <ip_output+0x2d4>
            total += mtmp->m_len;
 322ccb4:	e0bff717 	ldw	r2,-36(fp)
 322ccb8:	10c00217 	ldw	r3,8(r2)
 322ccbc:	e0bff517 	ldw	r2,-44(fp)
 322ccc0:	1885883a 	add	r2,r3,r2
 322ccc4:	e0bff515 	stw	r2,-44(fp)
      }

      if (m2)  /* If all else fails, brute force copy: */
      {
         total = 0;
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 322ccc8:	e0bff717 	ldw	r2,-36(fp)
 322cccc:	10800617 	ldw	r2,24(r2)
 322ccd0:	e0bff715 	stw	r2,-36(fp)
 322ccd4:	e0bff717 	ldw	r2,-36(fp)
 322ccd8:	1004c03a 	cmpne	r2,r2,zero
 322ccdc:	103ff51e 	bne	r2,zero,322ccb4 <ip_output+0x2b4>
            total += mtmp->m_len;
         LOCK_NET_RESOURCE(FREEQ_RESID);
 322cce0:	01000084 	movi	r4,2
 322cce4:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pkt = pk_alloc(total + HDRSLEN);
 322cce8:	e0bff517 	ldw	r2,-44(fp)
 322ccec:	10800e04 	addi	r2,r2,56
 322ccf0:	1009883a 	mov	r4,r2
 322ccf4:	322a2ac0 	call	322a2ac <pk_alloc>
 322ccf8:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322ccfc:	01000084 	movi	r4,2
 322cd00:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         if (!pkt)
 322cd04:	e0bffa17 	ldw	r2,-24(fp)
 322cd08:	1004c03a 	cmpne	r2,r2,zero
 322cd0c:	1000031e 	bne	r2,zero,322cd1c <ip_output+0x31c>
            return ENOBUFS;
 322cd10:	00801a44 	movi	r2,105
 322cd14:	e0bfff15 	stw	r2,-4(fp)
 322cd18:	0000b106 	br	322cfe0 <ip_output+0x5e0>
         pkt->nb_prot = pkt->nb_buff + MaxLnh;
 322cd1c:	e0bffa17 	ldw	r2,-24(fp)
 322cd20:	10c00117 	ldw	r3,4(r2)
 322cd24:	0080c974 	movhi	r2,805
 322cd28:	10931a04 	addi	r2,r2,19560
 322cd2c:	10800017 	ldw	r2,0(r2)
 322cd30:	1887883a 	add	r3,r3,r2
 322cd34:	e0bffa17 	ldw	r2,-24(fp)
 322cd38:	10c00315 	stw	r3,12(r2)

         mtmp = m1;
 322cd3c:	e0bff917 	ldw	r2,-28(fp)
 322cd40:	e0bff715 	stw	r2,-36(fp)
         while (mtmp)
 322cd44:	00002806 	br	322cde8 <ip_output+0x3e8>
         {
            MEMCPY(pkt->nb_prot, mtmp->m_data, mtmp->m_len);
 322cd48:	e0bffa17 	ldw	r2,-24(fp)
 322cd4c:	10c00317 	ldw	r3,12(r2)
 322cd50:	e0bff717 	ldw	r2,-36(fp)
 322cd54:	11400317 	ldw	r5,12(r2)
 322cd58:	e0bff717 	ldw	r2,-36(fp)
 322cd5c:	10800217 	ldw	r2,8(r2)
 322cd60:	1809883a 	mov	r4,r3
 322cd64:	100d883a 	mov	r6,r2
 322cd68:	3206ad00 	call	3206ad0 <memcpy>
            pkt->nb_prot += mtmp->m_len;
 322cd6c:	e0bffa17 	ldw	r2,-24(fp)
 322cd70:	10c00317 	ldw	r3,12(r2)
 322cd74:	e0bff717 	ldw	r2,-36(fp)
 322cd78:	10800217 	ldw	r2,8(r2)
 322cd7c:	1887883a 	add	r3,r3,r2
 322cd80:	e0bffa17 	ldw	r2,-24(fp)
 322cd84:	10c00315 	stw	r3,12(r2)
            pkt->nb_plen += mtmp->m_len;
 322cd88:	e0bffa17 	ldw	r2,-24(fp)
 322cd8c:	10c00417 	ldw	r3,16(r2)
 322cd90:	e0bff717 	ldw	r2,-36(fp)
 322cd94:	10800217 	ldw	r2,8(r2)
 322cd98:	1887883a 	add	r3,r3,r2
 322cd9c:	e0bffa17 	ldw	r2,-24(fp)
 322cda0:	10c00415 	stw	r3,16(r2)
            m2 = mtmp;
 322cda4:	e0bff717 	ldw	r2,-36(fp)
 322cda8:	e0bff815 	stw	r2,-32(fp)
            mtmp = mtmp->m_next;
 322cdac:	e0bff717 	ldw	r2,-36(fp)
 322cdb0:	10800617 	ldw	r2,24(r2)
 322cdb4:	e0bff715 	stw	r2,-36(fp)
            if (m2 != data)   /* save original head */
 322cdb8:	e0fff817 	ldw	r3,-32(fp)
 322cdbc:	e0bffd17 	ldw	r2,-12(fp)
 322cdc0:	18800226 	beq	r3,r2,322cdcc <ip_output+0x3cc>
               m_free(m2);
 322cdc4:	e13ff817 	ldw	r4,-32(fp)
 322cdc8:	322be980 	call	322be98 <m_free>
            tcpstat.tcps_ocopies++;
 322cdcc:	0080c9b4 	movhi	r2,806
 322cdd0:	10b4b504 	addi	r2,r2,-11564
 322cdd4:	10803417 	ldw	r2,208(r2)
 322cdd8:	10c00044 	addi	r3,r2,1
 322cddc:	0080c9b4 	movhi	r2,806
 322cde0:	10b4b504 	addi	r2,r2,-11564
 322cde4:	10c03415 	stw	r3,208(r2)
         if (!pkt)
            return ENOBUFS;
         pkt->nb_prot = pkt->nb_buff + MaxLnh;

         mtmp = m1;
         while (mtmp)
 322cde8:	e0bff717 	ldw	r2,-36(fp)
 322cdec:	1004c03a 	cmpne	r2,r2,zero
 322cdf0:	103fd51e 	bne	r2,zero,322cd48 <ip_output+0x348>
            mtmp = mtmp->m_next;
            if (m2 != data)   /* save original head */
               m_free(m2);
            tcpstat.tcps_ocopies++;
         }
         pkt->nb_prot -= total;     /* fix data pointer */
 322cdf4:	e0bffa17 	ldw	r2,-24(fp)
 322cdf8:	10c00317 	ldw	r3,12(r2)
 322cdfc:	e0bff517 	ldw	r2,-44(fp)
 322ce00:	1887c83a 	sub	r3,r3,r2
 322ce04:	e0bffa17 	ldw	r2,-24(fp)
 322ce08:	10c00315 	stw	r3,12(r2)

         /* release the original mbufs packet install the new one */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 322ce0c:	01000084 	movi	r4,2
 322ce10:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pk_free(data->pkt);
 322ce14:	e0bffd17 	ldw	r2,-12(fp)
 322ce18:	11000117 	ldw	r4,4(r2)
 322ce1c:	322a6400 	call	322a640 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322ce20:	01000084 	movi	r4,2
 322ce24:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         data->pkt = pkt;
 322ce28:	e0fffd17 	ldw	r3,-12(fp)
 322ce2c:	e0bffa17 	ldw	r2,-24(fp)
 322ce30:	18800115 	stw	r2,4(r3)
         data->m_len = pkt->nb_plen;
 322ce34:	e0bffa17 	ldw	r2,-24(fp)
 322ce38:	10c00417 	ldw	r3,16(r2)
 322ce3c:	e0bffd17 	ldw	r2,-12(fp)
 322ce40:	10c00215 	stw	r3,8(r2)
         data->m_next = NULL;
 322ce44:	e0bffd17 	ldw	r2,-12(fp)
 322ce48:	10000615 	stw	zero,24(r2)
         data->m_data = pkt->nb_prot;
 322ce4c:	e0bffa17 	ldw	r2,-24(fp)
 322ce50:	10c00317 	ldw	r3,12(r2)
 322ce54:	e0bffd17 	ldw	r2,-12(fp)
 322ce58:	10c00315 	stw	r3,12(r2)
         data->m_len = total;
 322ce5c:	e0fff517 	ldw	r3,-44(fp)
 322ce60:	e0bffd17 	ldw	r2,-12(fp)
 322ce64:	10c00215 	stw	r3,8(r2)
      }
   }

   if ((data->m_data < (data->pkt->nb_buff + MaxLnh)))
 322ce68:	e0bffd17 	ldw	r2,-12(fp)
 322ce6c:	11000317 	ldw	r4,12(r2)
 322ce70:	e0bffd17 	ldw	r2,-12(fp)
 322ce74:	10800117 	ldw	r2,4(r2)
 322ce78:	10c00117 	ldw	r3,4(r2)
 322ce7c:	0080c974 	movhi	r2,805
 322ce80:	10931a04 	addi	r2,r2,19560
 322ce84:	10800017 	ldw	r2,0(r2)
 322ce88:	1885883a 	add	r2,r3,r2
 322ce8c:	2080032e 	bgeu	r4,r2,322ce9c <ip_output+0x49c>
      panic("ip_output: overflow");
 322ce90:	0100c974 	movhi	r4,805
 322ce94:	213e2a04 	addi	r4,r4,-1880
 322ce98:	32261540 	call	3226154 <panic>

   pkt = data->pkt;
 322ce9c:	e0bffd17 	ldw	r2,-12(fp)
 322cea0:	10800117 	ldw	r2,4(r2)
 322cea4:	e0bffa15 	stw	r2,-24(fp)

   /* do we have options? */
   if (so_optsPack)
 322cea8:	e0bffe17 	ldw	r2,-8(fp)
 322ceac:	1005003a 	cmpeq	r2,r2,zero
 322ceb0:	1000031e 	bne	r2,zero,322cec0 <ip_output+0x4c0>
	   pkt->soxopts = so_optsPack;   /* yup */
 322ceb4:	e0fffa17 	ldw	r3,-24(fp)
 322ceb8:	e0bffe17 	ldw	r2,-8(fp)
 322cebc:	18800c15 	stw	r2,48(r3)
      panic("ip_output: no so_optsPack for the IPv6 scope");     
   }
#endif

   /* fill in dest host for IP layer */
   bip = (struct ip *)data->m_data;
 322cec0:	e0bffd17 	ldw	r2,-12(fp)
 322cec4:	10800317 	ldw	r2,12(r2)
 322cec8:	e0bffc15 	stw	r2,-16(fp)
   pkt->fhost = bip->ip_dest;
 322cecc:	e0bffc17 	ldw	r2,-16(fp)
 322ced0:	10c00417 	ldw	r3,16(r2)
 322ced4:	e0bffa17 	ldw	r2,-24(fp)
 322ced8:	10c00715 	stw	r3,28(r2)

   /* make enough IP header for cksum calculation */
   bip->ip_ver_ihl = 0x45;
 322cedc:	e0fffc17 	ldw	r3,-16(fp)
 322cee0:	00801144 	movi	r2,69
 322cee4:	18800005 	stb	r2,0(r3)
   bip->ip_len = htons(bip->ip_len);   /* make net endian for calculation */
 322cee8:	e0bffc17 	ldw	r2,-16(fp)
 322ceec:	1080008b 	ldhu	r2,2(r2)
 322cef0:	10bfffcc 	andi	r2,r2,65535
 322cef4:	1004d23a 	srli	r2,r2,8
 322cef8:	10803fcc 	andi	r2,r2,255
 322cefc:	1009883a 	mov	r4,r2
 322cf00:	e0bffc17 	ldw	r2,-16(fp)
 322cf04:	1080008b 	ldhu	r2,2(r2)
 322cf08:	10bfffcc 	andi	r2,r2,65535
 322cf0c:	1004923a 	slli	r2,r2,8
 322cf10:	1007883a 	mov	r3,r2
 322cf14:	00bfc004 	movi	r2,-256
 322cf18:	1884703a 	and	r2,r3,r2
 322cf1c:	2084b03a 	or	r2,r4,r2
 322cf20:	1007883a 	mov	r3,r2
 322cf24:	e0bffc17 	ldw	r2,-16(fp)
 322cf28:	10c0008d 	sth	r3,2(r2)
   tcpp = (struct tcphdr *)ip_data(bip);
 322cf2c:	e0bffc17 	ldw	r2,-16(fp)
 322cf30:	10800003 	ldbu	r2,0(r2)
 322cf34:	10803fcc 	andi	r2,r2,255
 322cf38:	108003cc 	andi	r2,r2,15
 322cf3c:	1085883a 	add	r2,r2,r2
 322cf40:	1085883a 	add	r2,r2,r2
 322cf44:	1007883a 	mov	r3,r2
 322cf48:	e0bffc17 	ldw	r2,-16(fp)
 322cf4c:	1885883a 	add	r2,r3,r2
 322cf50:	e0bffb15 	stw	r2,-20(fp)
#ifdef CSUM_DEMO
   if (!(tcpp->th_flags & TH_SYN))
   tcpp->th_flags |= TH_PUSH;     /* force the PSH flag in TCP hdr */
#endif
   tcpp->th_sum = tcp_cksum(bip);
 322cf54:	e13ffc17 	ldw	r4,-16(fp)
 322cf58:	32480180 	call	3248018 <tcp_cksum>
 322cf5c:	1007883a 	mov	r3,r2
 322cf60:	e0bffb17 	ldw	r2,-20(fp)
 322cf64:	10c0040d 	sth	r3,16(r2)

   pkt->nb_prot = (char*)(bip + 1);    /* point past IP header */
 322cf68:	e0bffc17 	ldw	r2,-16(fp)
 322cf6c:	10800504 	addi	r2,r2,20
 322cf70:	1007883a 	mov	r3,r2
 322cf74:	e0bffa17 	ldw	r2,-24(fp)
 322cf78:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen = data->m_len - sizeof(struct ip);
 322cf7c:	e0bffd17 	ldw	r2,-12(fp)
 322cf80:	10800217 	ldw	r2,8(r2)
 322cf84:	10fffb04 	addi	r3,r2,-20
 322cf88:	e0bffa17 	ldw	r2,-24(fp)
 322cf8c:	10c00415 	stw	r3,16(r2)

   e = ip_write(IPPROTO_TCP, pkt);
 322cf90:	01000184 	movi	r4,6
 322cf94:	e17ffa17 	ldw	r5,-24(fp)
 322cf98:	323f3740 	call	323f374 <ip_write>
 322cf9c:	e0bff615 	stw	r2,-40(fp)

   /* ip_write() is now responsable for data->pkt, so... */
   data->pkt = NULL;
 322cfa0:	e0bffd17 	ldw	r2,-12(fp)
 322cfa4:	10000115 	stw	zero,4(r2)
   m_freem(data);
 322cfa8:	e13ffd17 	ldw	r4,-12(fp)
 322cfac:	322bfcc0 	call	322bfcc <m_freem>

   if (e < 0)
 322cfb0:	e0bff617 	ldw	r2,-40(fp)
 322cfb4:	1004403a 	cmpge	r2,r2,zero
 322cfb8:	1000081e 	bne	r2,zero,322cfdc <ip_output+0x5dc>
   {
      /* don't report dropped sends, it causes socket applications to 
      bail when a TCP retry will fix the problem */
      if (e == SEND_DROPPED)
 322cfbc:	e0bff617 	ldw	r2,-40(fp)
 322cfc0:	10bffa98 	cmpnei	r2,r2,-22
 322cfc4:	1000021e 	bne	r2,zero,322cfd0 <ip_output+0x5d0>
         return 0;
 322cfc8:	e03fff15 	stw	zero,-4(fp)
 322cfcc:	00000406 	br	322cfe0 <ip_output+0x5e0>
      return e;
 322cfd0:	e0bff617 	ldw	r2,-40(fp)
 322cfd4:	e0bfff15 	stw	r2,-4(fp)
 322cfd8:	00000106 	br	322cfe0 <ip_output+0x5e0>
   }
   else
      return 0;
 322cfdc:	e03fff15 	stw	zero,-4(fp)
 322cfe0:	e0bfff17 	ldw	r2,-4(fp)
}
 322cfe4:	e037883a 	mov	sp,fp
 322cfe8:	dfc00117 	ldw	ra,4(sp)
 322cfec:	df000017 	ldw	fp,0(sp)
 322cff0:	dec00204 	addi	sp,sp,8
 322cff4:	f800283a 	ret

0322cff8 <in_broadcast>:
 * RETURNS: TRUE if broadcast, else FALSE
 */

int
in_broadcast(u_long ipaddr)   /* passed in net endian */
{
 322cff8:	defffd04 	addi	sp,sp,-12
 322cffc:	df000215 	stw	fp,8(sp)
 322d000:	df000204 	addi	fp,sp,8
 322d004:	e13ffe15 	stw	r4,-8(fp)
   if (ipaddr == 0xffffffff)
 322d008:	e0bffe17 	ldw	r2,-8(fp)
 322d00c:	10bfffd8 	cmpnei	r2,r2,-1
 322d010:	1000031e 	bne	r2,zero,322d020 <in_broadcast+0x28>
      return TRUE;
 322d014:	00800044 	movi	r2,1
 322d018:	e0bfff15 	stw	r2,-4(fp)
 322d01c:	00000106 	br	322d024 <in_broadcast+0x2c>

   return FALSE;
 322d020:	e03fff15 	stw	zero,-4(fp)
 322d024:	e0bfff17 	ldw	r2,-4(fp)
}
 322d028:	e037883a 	mov	sp,fp
 322d02c:	df000017 	ldw	fp,0(sp)
 322d030:	dec00104 	addi	sp,sp,4
 322d034:	f800283a 	ret

0322d038 <np_stripoptions>:
 * RETURNS: void
 */

void
np_stripoptions(struct ip * ti, struct mbuf * m)
{
 322d038:	defffb04 	addi	sp,sp,-20
 322d03c:	dfc00415 	stw	ra,16(sp)
 322d040:	df000315 	stw	fp,12(sp)
 322d044:	df000304 	addi	fp,sp,12
 322d048:	e13ffe15 	stw	r4,-8(fp)
 322d04c:	e17fff15 	stw	r5,-4(fp)
   int   ihlen;

   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;
 322d050:	e0bffe17 	ldw	r2,-8(fp)
 322d054:	10800003 	ldbu	r2,0(r2)
 322d058:	10803fcc 	andi	r2,r2,255
 322d05c:	108003cc 	andi	r2,r2,15
 322d060:	1085883a 	add	r2,r2,r2
 322d064:	1085883a 	add	r2,r2,r2
 322d068:	e0bffd15 	stw	r2,-12(fp)

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
 322d06c:	e0bffd17 	ldw	r2,-12(fp)
 322d070:	10800550 	cmplti	r2,r2,21
 322d074:	1000251e 	bne	r2,zero,322d10c <np_stripoptions+0xd4>
      return;

   /* figure out how much to strip: we want to keep the 20-octet IP header */
   ihlen -= 20;
 322d078:	e0bffd17 	ldw	r2,-12(fp)
 322d07c:	10bffb04 	addi	r2,r2,-20
 322d080:	e0bffd15 	stw	r2,-12(fp)

   /* remove the stripped options from the IP datagram length */
   ti->ip_len -= ihlen;
 322d084:	e0bffe17 	ldw	r2,-8(fp)
 322d088:	10c0008b 	ldhu	r3,2(r2)
 322d08c:	e0bffd17 	ldw	r2,-12(fp)
 322d090:	1885c83a 	sub	r2,r3,r2
 322d094:	1007883a 	mov	r3,r2
 322d098:	e0bffe17 	ldw	r2,-8(fp)
 322d09c:	10c0008d 	sth	r3,2(r2)

   /* and from the IP header length (which will be 5*4 octets long) */
   ti->ip_ver_ihl = (ti->ip_ver_ihl & 0xf0) | 5;
 322d0a0:	e0bffe17 	ldw	r2,-8(fp)
 322d0a4:	10800003 	ldbu	r2,0(r2)
 322d0a8:	1007883a 	mov	r3,r2
 322d0ac:	00bffc04 	movi	r2,-16
 322d0b0:	1884703a 	and	r2,r3,r2
 322d0b4:	10800154 	ori	r2,r2,5
 322d0b8:	1007883a 	mov	r3,r2
 322d0bc:	e0bffe17 	ldw	r2,-8(fp)
 322d0c0:	10c00005 	stb	r3,0(r2)

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
 322d0c4:	e0fffe17 	ldw	r3,-8(fp)
 322d0c8:	e0bffd17 	ldw	r2,-12(fp)
 322d0cc:	1889883a 	add	r4,r3,r2
 322d0d0:	e17ffe17 	ldw	r5,-8(fp)
 322d0d4:	01800504 	movi	r6,20
 322d0d8:	3206b700 	call	3206b70 <memmove>
   m->m_len -= ihlen;
 322d0dc:	e0bfff17 	ldw	r2,-4(fp)
 322d0e0:	10c00217 	ldw	r3,8(r2)
 322d0e4:	e0bffd17 	ldw	r2,-12(fp)
 322d0e8:	1887c83a 	sub	r3,r3,r2
 322d0ec:	e0bfff17 	ldw	r2,-4(fp)
 322d0f0:	10c00215 	stw	r3,8(r2)
   m->m_data += ihlen;
 322d0f4:	e0bfff17 	ldw	r2,-4(fp)
 322d0f8:	10c00317 	ldw	r3,12(r2)
 322d0fc:	e0bffd17 	ldw	r2,-12(fp)
 322d100:	1887883a 	add	r3,r3,r2
 322d104:	e0bfff17 	ldw	r2,-4(fp)
 322d108:	10c00315 	stw	r3,12(r2)
}
 322d10c:	e037883a 	mov	sp,fp
 322d110:	dfc00117 	ldw	ra,4(sp)
 322d114:	df000017 	ldw	fp,0(sp)
 322d118:	dec00204 	addi	sp,sp,8
 322d11c:	f800283a 	ret

0322d120 <so_icmpdu>:
 * RETURNS: 
 */

void
so_icmpdu(PACKET p, struct destun * pdp)
{
 322d120:	defff304 	addi	sp,sp,-52
 322d124:	dfc00c15 	stw	ra,48(sp)
 322d128:	df000b15 	stw	fp,44(sp)
 322d12c:	df000b04 	addi	fp,sp,44
 322d130:	e13ffe15 	stw	r4,-8(fp)
 322d134:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;
   struct socket *   so;
   struct tcpcb * tp;

   /* extract information about packet which generated DU */
   fhost = htonl(pdp->dip.ip_dest);
 322d138:	e0bfff17 	ldw	r2,-4(fp)
 322d13c:	10800617 	ldw	r2,24(r2)
 322d140:	1004d63a 	srli	r2,r2,24
 322d144:	10c03fcc 	andi	r3,r2,255
 322d148:	e0bfff17 	ldw	r2,-4(fp)
 322d14c:	10800617 	ldw	r2,24(r2)
 322d150:	1004d23a 	srli	r2,r2,8
 322d154:	10bfc00c 	andi	r2,r2,65280
 322d158:	1886b03a 	or	r3,r3,r2
 322d15c:	e0bfff17 	ldw	r2,-4(fp)
 322d160:	10800617 	ldw	r2,24(r2)
 322d164:	10bfc00c 	andi	r2,r2,65280
 322d168:	1004923a 	slli	r2,r2,8
 322d16c:	1886b03a 	or	r3,r3,r2
 322d170:	e0bfff17 	ldw	r2,-4(fp)
 322d174:	10800617 	ldw	r2,24(r2)
 322d178:	10803fcc 	andi	r2,r2,255
 322d17c:	1004963a 	slli	r2,r2,24
 322d180:	1884b03a 	or	r2,r3,r2
 322d184:	e0bffc15 	stw	r2,-16(fp)
   lhost = htonl(pdp->dip.ip_src);
 322d188:	e0bfff17 	ldw	r2,-4(fp)
 322d18c:	10800517 	ldw	r2,20(r2)
 322d190:	1004d63a 	srli	r2,r2,24
 322d194:	10c03fcc 	andi	r3,r2,255
 322d198:	e0bfff17 	ldw	r2,-4(fp)
 322d19c:	10800517 	ldw	r2,20(r2)
 322d1a0:	1004d23a 	srli	r2,r2,8
 322d1a4:	10bfc00c 	andi	r2,r2,65280
 322d1a8:	1886b03a 	or	r3,r3,r2
 322d1ac:	e0bfff17 	ldw	r2,-4(fp)
 322d1b0:	10800517 	ldw	r2,20(r2)
 322d1b4:	10bfc00c 	andi	r2,r2,65280
 322d1b8:	1004923a 	slli	r2,r2,8
 322d1bc:	1886b03a 	or	r3,r3,r2
 322d1c0:	e0bfff17 	ldw	r2,-4(fp)
 322d1c4:	10800517 	ldw	r2,20(r2)
 322d1c8:	10803fcc 	andi	r2,r2,255
 322d1cc:	1004963a 	slli	r2,r2,24
 322d1d0:	1884b03a 	or	r2,r3,r2
 322d1d4:	e0bffd15 	stw	r2,-12(fp)
   lport = htons(*(unshort*)(&pdp->ddata[0]));
 322d1d8:	e0bfff17 	ldw	r2,-4(fp)
 322d1dc:	10800704 	addi	r2,r2,28
 322d1e0:	1080000b 	ldhu	r2,0(r2)
 322d1e4:	10bfffcc 	andi	r2,r2,65535
 322d1e8:	1004d23a 	srli	r2,r2,8
 322d1ec:	10803fcc 	andi	r2,r2,255
 322d1f0:	1009883a 	mov	r4,r2
 322d1f4:	e0bfff17 	ldw	r2,-4(fp)
 322d1f8:	10800704 	addi	r2,r2,28
 322d1fc:	1080000b 	ldhu	r2,0(r2)
 322d200:	10bfffcc 	andi	r2,r2,65535
 322d204:	1004923a 	slli	r2,r2,8
 322d208:	1007883a 	mov	r3,r2
 322d20c:	00bfc004 	movi	r2,-256
 322d210:	1884703a 	and	r2,r3,r2
 322d214:	2084b03a 	or	r2,r4,r2
 322d218:	e0bffb0d 	sth	r2,-20(fp)
   fport = htons(*(unshort*)(&pdp->ddata[2]));
 322d21c:	e0bfff17 	ldw	r2,-4(fp)
 322d220:	10800704 	addi	r2,r2,28
 322d224:	10800084 	addi	r2,r2,2
 322d228:	1080000b 	ldhu	r2,0(r2)
 322d22c:	10bfffcc 	andi	r2,r2,65535
 322d230:	1004d23a 	srli	r2,r2,8
 322d234:	10803fcc 	andi	r2,r2,255
 322d238:	1009883a 	mov	r4,r2
 322d23c:	e0bfff17 	ldw	r2,-4(fp)
 322d240:	10800704 	addi	r2,r2,28
 322d244:	10800084 	addi	r2,r2,2
 322d248:	1080000b 	ldhu	r2,0(r2)
 322d24c:	10bfffcc 	andi	r2,r2,65535
 322d250:	1004923a 	slli	r2,r2,8
 322d254:	1007883a 	mov	r3,r2
 322d258:	00bfc004 	movi	r2,-256
 322d25c:	1884703a 	and	r2,r3,r2
 322d260:	2084b03a 	or	r2,r4,r2
 322d264:	e0bffb8d 	sth	r2,-18(fp)
#ifndef IP_PMTU
   /* if it's a datagram-too-big message, ignore it -- As the
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
 322d268:	e0bfff17 	ldw	r2,-4(fp)
 322d26c:	10800043 	ldbu	r2,1(r2)
 322d270:	10803fcc 	andi	r2,r2,255
 322d274:	1080201c 	xori	r2,r2,128
 322d278:	10bfe004 	addi	r2,r2,-128
 322d27c:	10800120 	cmpeqi	r2,r2,4
 322d280:	1000721e 	bne	r2,zero,322d44c <so_icmpdu+0x32c>
       goto done;
    }
#endif   /* IP_PMTU */

   /* if it's a TCP connection, clean it up */
   if (pdp->dip.ip_prot == TCPTP)
 322d284:	e0bfff17 	ldw	r2,-4(fp)
 322d288:	10800443 	ldbu	r2,17(r2)
 322d28c:	10803fcc 	andi	r2,r2,255
 322d290:	10800198 	cmpnei	r2,r2,6
 322d294:	1000241e 	bne	r2,zero,322d328 <so_icmpdu+0x208>
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
 322d298:	e1bffb8b 	ldhu	r6,-18(fp)
 322d29c:	e0bffb0b 	ldhu	r2,-20(fp)
 322d2a0:	d8800015 	stw	r2,0(sp)
 322d2a4:	00800044 	movi	r2,1
 322d2a8:	d8800115 	stw	r2,4(sp)
 322d2ac:	0100c9b4 	movhi	r4,806
 322d2b0:	2134aa04 	addi	r4,r4,-11608
 322d2b4:	e17ffc17 	ldw	r5,-16(fp)
 322d2b8:	e1fffd17 	ldw	r7,-12(fp)
 322d2bc:	32488880 	call	3248888 <in_pcblookup>
 322d2c0:	e0bffa15 	stw	r2,-24(fp)
      if (inp == 0)
 322d2c4:	e0bffa17 	ldw	r2,-24(fp)
 322d2c8:	1005003a 	cmpeq	r2,r2,zero
 322d2cc:	10005f1e 	bne	r2,zero,322d44c <so_icmpdu+0x32c>
         goto done;
      so = inp->inp_socket;
 322d2d0:	e0bffa17 	ldw	r2,-24(fp)
 322d2d4:	10800817 	ldw	r2,32(r2)
 322d2d8:	e0bff915 	stw	r2,-28(fp)
      if (so == 0)
 322d2dc:	e0bff917 	ldw	r2,-28(fp)
 322d2e0:	1005003a 	cmpeq	r2,r2,zero
 322d2e4:	1000591e 	bne	r2,zero,322d44c <so_icmpdu+0x32c>
         goto done;
      tp = intotcpcb(inp);
 322d2e8:	e0bffa17 	ldw	r2,-24(fp)
 322d2ec:	10800917 	ldw	r2,36(r2)
 322d2f0:	e0bff815 	stw	r2,-32(fp)
      if (tp)
 322d2f4:	e0bff817 	ldw	r2,-32(fp)
 322d2f8:	1005003a 	cmpeq	r2,r2,zero
 322d2fc:	1000061e 	bne	r2,zero,322d318 <so_icmpdu+0x1f8>
      {
         if (tp->t_state <= TCPS_LISTEN)
 322d300:	e0bff817 	ldw	r2,-32(fp)
 322d304:	10800217 	ldw	r2,8(r2)
 322d308:	10800090 	cmplti	r2,r2,2
 322d30c:	10004f1e 	bne	r2,zero,322d44c <so_icmpdu+0x32c>
               goto done;
        }
   }
#endif

         tcp_close(tp);
 322d310:	e13ff817 	ldw	r4,-32(fp)
 322d314:	32381c80 	call	32381c8 <tcp_close>
      }
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 322d318:	e0fff917 	ldw	r3,-28(fp)
 322d31c:	00801bc4 	movi	r2,111
 322d320:	18800615 	stw	r2,24(r3)
 322d324:	00004906 	br	322d44c <so_icmpdu+0x32c>
   }   
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
 322d328:	e0bfff17 	ldw	r2,-4(fp)
 322d32c:	10800443 	ldbu	r2,17(r2)
 322d330:	10803fcc 	andi	r2,r2,255
 322d334:	10800458 	cmpnei	r2,r2,17
 322d338:	1000441e 	bne	r2,zero,322d44c <so_icmpdu+0x32c>
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 322d33c:	0080c974 	movhi	r2,805
 322d340:	10933504 	addi	r2,r2,19668
 322d344:	10800017 	ldw	r2,0(r2)
 322d348:	e0bff715 	stw	r2,-36(fp)
 322d34c:	00002406 	br	322d3e0 <so_icmpdu+0x2c0>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 322d350:	e0bff717 	ldw	r2,-36(fp)
 322d354:	1080020b 	ldhu	r2,8(r2)
 322d358:	10ffffcc 	andi	r3,r2,65535
 322d35c:	e0bffb8b 	ldhu	r2,-18(fp)
 322d360:	18800526 	beq	r3,r2,322d378 <so_icmpdu+0x258>
 322d364:	e0bff717 	ldw	r2,-36(fp)
 322d368:	1080020b 	ldhu	r2,8(r2)
 322d36c:	10bfffcc 	andi	r2,r2,65535
 322d370:	1004c03a 	cmpne	r2,r2,zero
 322d374:	1000171e 	bne	r2,zero,322d3d4 <so_icmpdu+0x2b4>
 322d378:	e0bff717 	ldw	r2,-36(fp)
 322d37c:	11000417 	ldw	r4,16(r2)
 322d380:	e0bffc17 	ldw	r2,-16(fp)
 322d384:	1004d63a 	srli	r2,r2,24
 322d388:	10c03fcc 	andi	r3,r2,255
 322d38c:	e0bffc17 	ldw	r2,-16(fp)
 322d390:	1004d23a 	srli	r2,r2,8
 322d394:	10bfc00c 	andi	r2,r2,65280
 322d398:	1886b03a 	or	r3,r3,r2
 322d39c:	e0bffc17 	ldw	r2,-16(fp)
 322d3a0:	10bfc00c 	andi	r2,r2,65280
 322d3a4:	1004923a 	slli	r2,r2,8
 322d3a8:	1886b03a 	or	r3,r3,r2
 322d3ac:	e0bffc17 	ldw	r2,-16(fp)
 322d3b0:	10803fcc 	andi	r2,r2,255
 322d3b4:	1004963a 	slli	r2,r2,24
 322d3b8:	1884b03a 	or	r2,r3,r2
 322d3bc:	2080051e 	bne	r4,r2,322d3d4 <so_icmpdu+0x2b4>
 322d3c0:	e0bff717 	ldw	r2,-36(fp)
 322d3c4:	1080018b 	ldhu	r2,6(r2)
 322d3c8:	10ffffcc 	andi	r3,r2,65535
 322d3cc:	e0bffb0b 	ldhu	r2,-20(fp)
 322d3d0:	18800626 	beq	r3,r2,322d3ec <so_icmpdu+0x2cc>
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 322d3d4:	e0bff717 	ldw	r2,-36(fp)
 322d3d8:	10800017 	ldw	r2,0(r2)
 322d3dc:	e0bff715 	stw	r2,-36(fp)
 322d3e0:	e0bff717 	ldw	r2,-36(fp)
 322d3e4:	1004c03a 	cmpne	r2,r2,zero
 322d3e8:	103fd91e 	bne	r2,zero,322d350 <so_icmpdu+0x230>
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
         }
      if (!tmp) 
 322d3ec:	e0bff717 	ldw	r2,-36(fp)
 322d3f0:	1005003a 	cmpeq	r2,r2,zero
 322d3f4:	1000151e 	bne	r2,zero,322d44c <so_icmpdu+0x32c>
         goto done;
      so = (struct socket *)tmp->u_data;
 322d3f8:	e0bff717 	ldw	r2,-36(fp)
 322d3fc:	10800617 	ldw	r2,24(r2)
 322d400:	e0bff915 	stw	r2,-28(fp)
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
 322d404:	e0bff917 	ldw	r2,-28(fp)
 322d408:	10800983 	ldbu	r2,38(r2)
 322d40c:	10803fcc 	andi	r2,r2,255
 322d410:	1080201c 	xori	r2,r2,128
 322d414:	10bfe004 	addi	r2,r2,-128
 322d418:	10800098 	cmpnei	r2,r2,2
 322d41c:	10000b1e 	bne	r2,zero,322d44c <so_icmpdu+0x32c>
         goto done;
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 322d420:	e0fff917 	ldw	r3,-28(fp)
 322d424:	00801bc4 	movi	r2,111
 322d428:	18800615 	stw	r2,24(r3)
      /* do a select() notify on socket here */
      sorwakeup(so);
 322d42c:	e0bff917 	ldw	r2,-28(fp)
 322d430:	11400a04 	addi	r5,r2,40
 322d434:	e13ff917 	ldw	r4,-28(fp)
 322d438:	32322700 	call	3232270 <sbwakeup>
      sowwakeup(so);
 322d43c:	e0bff917 	ldw	r2,-28(fp)
 322d440:	11401204 	addi	r5,r2,72
 322d444:	e13ff917 	ldw	r4,-28(fp)
 322d448:	32322700 	call	3232270 <sbwakeup>
   if (pdp->dcode == DSTFRAG)
      pmtucache_set(pdp->dip.ip_dest, htons(pdp->dno2));
#endif   /* IP_PMTU */

done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
 322d44c:	01000084 	movi	r4,2
 322d450:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   pk_free(p); /* done with original packet */
 322d454:	e13ffe17 	ldw	r4,-8(fp)
 322d458:	322a6400 	call	322a640 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 322d45c:	01000084 	movi	r4,2
 322d460:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   return;
}
 322d464:	e037883a 	mov	sp,fp
 322d468:	dfc00117 	ldw	ra,4(sp)
 322d46c:	df000017 	ldw	fp,0(sp)
 322d470:	dec00204 	addi	sp,sp,8
 322d474:	f800283a 	ret

0322d478 <tcp_tick>:
unsigned long nextslow = 0L;     /* next slow tcp timer time */
static int in_tcptick = 0;       /* reentry gaurd */

void
tcp_tick()
{
 322d478:	defffe04 	addi	sp,sp,-8
 322d47c:	dfc00115 	stw	ra,4(sp)
 322d480:	df000015 	stw	fp,0(sp)
 322d484:	d839883a 	mov	fp,sp
   /* guard against re-entry */
   if (in_tcptick)
 322d488:	d0a8e417 	ldw	r2,-23664(gp)
 322d48c:	1004c03a 	cmpne	r2,r2,zero
 322d490:	1000151e 	bne	r2,zero,322d4e8 <tcp_tick+0x70>
      return;
   in_tcptick++;
 322d494:	d0a8e417 	ldw	r2,-23664(gp)
 322d498:	10800044 	addi	r2,r2,1
 322d49c:	d0a8e415 	stw	r2,-23664(gp)

   LOCK_NET_RESOURCE(NET_RESID);
 322d4a0:	0009883a 	mov	r4,zero
 322d4a4:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>

   if (cticks >= nextslow) /* time to do it again */
 322d4a8:	0080c974 	movhi	r2,805
 322d4ac:	10934104 	addi	r2,r2,19716
 322d4b0:	10c00017 	ldw	r3,0(r2)
 322d4b4:	d0a8e317 	ldw	r2,-23668(gp)
 322d4b8:	18800636 	bltu	r3,r2,322d4d4 <tcp_tick+0x5c>
   {
      tcp_slowtimo();      /* call routine in BSD tcp_timr.c */
 322d4bc:	32383f40 	call	32383f4 <tcp_slowtimo>
#ifdef CSUM_DEMO
      nextslow = cticks + (TPS/5);  /* another 200 ms */
#else
      nextslow = cticks + (TPS/2);  /* another 500 ms */
 322d4c0:	0080c974 	movhi	r2,805
 322d4c4:	10934104 	addi	r2,r2,19716
 322d4c8:	10800017 	ldw	r2,0(r2)
 322d4cc:	10807d04 	addi	r2,r2,500
 322d4d0:	d0a8e315 	stw	r2,-23668(gp)

#ifdef DO_DELAY_ACKS
   tcp_fasttimo();
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);
 322d4d4:	0009883a 	mov	r4,zero
 322d4d8:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   in_tcptick--;
 322d4dc:	d0a8e417 	ldw	r2,-23664(gp)
 322d4e0:	10bfffc4 	addi	r2,r2,-1
 322d4e4:	d0a8e415 	stw	r2,-23664(gp)
}
 322d4e8:	e037883a 	mov	sp,fp
 322d4ec:	dfc00117 	ldw	ra,4(sp)
 322d4f0:	df000017 	ldw	fp,0(sp)
 322d4f4:	dec00204 	addi	sp,sp,8
 322d4f8:	f800283a 	ret

0322d4fc <rawip_lookup>:
 *          or NULL if no matching raw IP endpoint is found.
 */

struct ipraw_ep *
rawip_lookup(struct socket * so)
{
 322d4fc:	defffc04 	addi	sp,sp,-16
 322d500:	df000315 	stw	fp,12(sp)
 322d504:	df000304 	addi	fp,sp,12
 322d508:	e13ffe15 	stw	r4,-8(fp)
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 322d50c:	0080c974 	movhi	r2,805
 322d510:	10936804 	addi	r2,r2,19872
 322d514:	10800017 	ldw	r2,0(r2)
 322d518:	e0bffd15 	stw	r2,-12(fp)
 322d51c:	00000a06 	br	322d548 <rawip_lookup+0x4c>
      if (tmp->ipr_data == (void*)so)
 322d520:	e0bffd17 	ldw	r2,-12(fp)
 322d524:	10c00417 	ldw	r3,16(r2)
 322d528:	e0bffe17 	ldw	r2,-8(fp)
 322d52c:	1880031e 	bne	r3,r2,322d53c <rawip_lookup+0x40>
      return (tmp);
 322d530:	e0bffd17 	ldw	r2,-12(fp)
 322d534:	e0bfff15 	stw	r2,-4(fp)
 322d538:	00000706 	br	322d558 <rawip_lookup+0x5c>
struct ipraw_ep *
rawip_lookup(struct socket * so)
{
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 322d53c:	e0bffd17 	ldw	r2,-12(fp)
 322d540:	10800017 	ldw	r2,0(r2)
 322d544:	e0bffd15 	stw	r2,-12(fp)
 322d548:	e0bffd17 	ldw	r2,-12(fp)
 322d54c:	1004c03a 	cmpne	r2,r2,zero
 322d550:	103ff31e 	bne	r2,zero,322d520 <rawip_lookup+0x24>
      if (tmp->ipr_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 322d554:	e03fff15 	stw	zero,-4(fp)
 322d558:	e0bfff17 	ldw	r2,-4(fp)
}
 322d55c:	e037883a 	mov	sp,fp
 322d560:	df000017 	ldw	fp,0(sp)
 322d564:	dec00104 	addi	sp,sp,4
 322d568:	f800283a 	ret

0322d56c <rawip_soinput>:
 *          indicates that the packet has not been accepted.
 */

int
rawip_soinput(PACKET pkt, void * so_ptr)
{
 322d56c:	defff404 	addi	sp,sp,-48
 322d570:	dfc00b15 	stw	ra,44(sp)
 322d574:	df000a15 	stw	fp,40(sp)
 322d578:	df000a04 	addi	fp,sp,40
 322d57c:	e13ffd15 	stw	r4,-12(fp)
 322d580:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 322d584:	e0bffe17 	ldw	r2,-8(fp)
 322d588:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;

   LOCK_NET_RESOURCE(NET_RESID); 
 322d58c:	0009883a 	mov	r4,zero
 322d590:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 322d594:	e0bff717 	ldw	r2,-36(fp)
 322d598:	10c00a17 	ldw	r3,40(r2)
 322d59c:	e0bffd17 	ldw	r2,-12(fp)
 322d5a0:	10800417 	ldw	r2,16(r2)
 322d5a4:	1887883a 	add	r3,r3,r2
 322d5a8:	e0bff717 	ldw	r2,-36(fp)
 322d5ac:	10800b17 	ldw	r2,44(r2)
 322d5b0:	18800536 	bltu	r3,r2,322d5c8 <rawip_soinput+0x5c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 322d5b4:	0009883a 	mov	r4,zero
 322d5b8:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 322d5bc:	00801a44 	movi	r2,105
 322d5c0:	e0bfff15 	stw	r2,-4(fp)
 322d5c4:	00005806 	br	322d728 <rawip_soinput+0x1bc>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 322d5c8:	01000044 	movi	r4,1
 322d5cc:	000b883a 	mov	r5,zero
 322d5d0:	322bcf00 	call	322bcf0 <m_getnbuf>
 322d5d4:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 322d5d8:	e0bff817 	ldw	r2,-32(fp)
 322d5dc:	1004c03a 	cmpne	r2,r2,zero
 322d5e0:	1000051e 	bne	r2,zero,322d5f8 <rawip_soinput+0x8c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 322d5e4:	0009883a 	mov	r4,zero
 322d5e8:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 322d5ec:	00801a44 	movi	r2,105
 322d5f0:	e0bfff15 	stw	r2,-4(fp)
 322d5f4:	00004c06 	br	322d728 <rawip_soinput+0x1bc>
   }

   /* set data mbuf to point to start of IP header */
   m_in->pkt = pkt;
 322d5f8:	e0fff817 	ldw	r3,-32(fp)
 322d5fc:	e0bffd17 	ldw	r2,-12(fp)
 322d600:	18800115 	stw	r2,4(r3)
   m_in->m_base = pkt->nb_buff;
 322d604:	e0bffd17 	ldw	r2,-12(fp)
 322d608:	10c00117 	ldw	r3,4(r2)
 322d60c:	e0bff817 	ldw	r2,-32(fp)
 322d610:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 322d614:	e0bffd17 	ldw	r2,-12(fp)
 322d618:	10c00217 	ldw	r3,8(r2)
 322d61c:	e0bff817 	ldw	r2,-32(fp)
 322d620:	10c00515 	stw	r3,20(r2)
   m_in->m_data = pkt->nb_prot;
 322d624:	e0bffd17 	ldw	r2,-12(fp)
 322d628:	10c00317 	ldw	r3,12(r2)
 322d62c:	e0bff817 	ldw	r2,-32(fp)
 322d630:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 322d634:	e0bffd17 	ldw	r2,-12(fp)
 322d638:	10c00417 	ldw	r3,16(r2)
 322d63c:	e0bff817 	ldw	r2,-32(fp)
 322d640:	10c00215 	stw	r3,8(r2)

   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
 322d644:	e0bff717 	ldw	r2,-36(fp)
 322d648:	10800417 	ldw	r2,16(r2)
 322d64c:	1088000c 	andi	r2,r2,8192
 322d650:	1004c03a 	cmpne	r2,r2,zero
 322d654:	1000141e 	bne	r2,zero,322d6a8 <rawip_soinput+0x13c>
   {
      unsigned int ihl = 
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
 322d658:	e0bffd17 	ldw	r2,-12(fp)
 322d65c:	10800317 	ldw	r2,12(r2)
 322d660:	10800003 	ldbu	r2,0(r2)
 322d664:	10803fcc 	andi	r2,r2,255
 322d668:	108003cc 	andi	r2,r2,15
 322d66c:	1085883a 	add	r2,r2,r2
 322d670:	1085883a 	add	r2,r2,r2
 322d674:	e0bff615 	stw	r2,-40(fp)
      m_in->m_data += ihl;
 322d678:	e0bff817 	ldw	r2,-32(fp)
 322d67c:	10c00317 	ldw	r3,12(r2)
 322d680:	e0bff617 	ldw	r2,-40(fp)
 322d684:	1887883a 	add	r3,r3,r2
 322d688:	e0bff817 	ldw	r2,-32(fp)
 322d68c:	10c00315 	stw	r3,12(r2)
      m_in->m_len -= ihl;
 322d690:	e0bff817 	ldw	r2,-32(fp)
 322d694:	10c00217 	ldw	r3,8(r2)
 322d698:	e0bff617 	ldw	r2,-40(fp)
 322d69c:	1887c83a 	sub	r3,r3,r2
 322d6a0:	e0bff817 	ldw	r2,-32(fp)
 322d6a4:	10c00215 	stw	r3,8(r2)
   }

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 322d6a8:	e0bffd17 	ldw	r2,-12(fp)
 322d6ac:	10800717 	ldw	r2,28(r2)
 322d6b0:	e0bffa15 	stw	r2,-24(fp)
   sin.sin_port = 0;
 322d6b4:	e03ff98d 	sth	zero,-26(fp)
   sin.sin_family = AF_INET;
 322d6b8:	00800084 	movi	r2,2
 322d6bc:	e0bff90d 	sth	r2,-28(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 322d6c0:	e0bff717 	ldw	r2,-36(fp)
 322d6c4:	11000a04 	addi	r4,r2,40
 322d6c8:	e17ff904 	addi	r5,fp,-28
 322d6cc:	e1bff817 	ldw	r6,-32(fp)
 322d6d0:	32325bc0 	call	32325bc <sbappendaddr>
 322d6d4:	1004c03a 	cmpne	r2,r2,zero
 322d6d8:	1000091e 	bne	r2,zero,322d700 <rawip_soinput+0x194>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       * underlying stack
       */
      m_in->pkt = NULL;
 322d6dc:	e0bff817 	ldw	r2,-32(fp)
 322d6e0:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 322d6e4:	e13ff817 	ldw	r4,-32(fp)
 322d6e8:	322be980 	call	322be98 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 322d6ec:	0009883a 	mov	r4,zero
 322d6f0:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 322d6f4:	00801a44 	movi	r2,105
 322d6f8:	e0bfff15 	stw	r2,-4(fp)
 322d6fc:	00000a06 	br	322d728 <rawip_soinput+0x1bc>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 322d700:	e0bff717 	ldw	r2,-36(fp)
 322d704:	11000a04 	addi	r4,r2,40
 322d708:	3226c640 	call	3226c64 <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 322d70c:	e0bff717 	ldw	r2,-36(fp)
 322d710:	11400a04 	addi	r5,r2,40
 322d714:	e13ff717 	ldw	r4,-36(fp)
 322d718:	32322700 	call	3232270 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 322d71c:	0009883a 	mov	r4,zero
 322d720:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   return 0;
 322d724:	e03fff15 	stw	zero,-4(fp)
 322d728:	e0bfff17 	ldw	r2,-4(fp)
}
 322d72c:	e037883a 	mov	sp,fp
 322d730:	dfc00117 	ldw	ra,4(sp)
 322d734:	df000017 	ldw	fp,0(sp)
 322d738:	dec00204 	addi	sp,sp,8
 322d73c:	f800283a 	ret

0322d740 <rawip_usrreq>:

int
rawip_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 322d740:	deffee04 	addi	sp,sp,-72
 322d744:	dfc01115 	stw	ra,68(sp)
 322d748:	df001015 	stw	fp,64(sp)
 322d74c:	dc000f15 	stw	r16,60(sp)
 322d750:	df000f04 	addi	fp,sp,60
 322d754:	e13ffc15 	stw	r4,-16(fp)
 322d758:	e17ffd15 	stw	r5,-12(fp)
 322d75c:	e1bffe15 	stw	r6,-8(fp)
   u_char prot;
   struct ip * pip;
   int   req;
   NET   ifp;     /* ptr to network interface structure */

   req = so->so_req;    /* get request from socket struct */
 322d760:	e0bffc17 	ldw	r2,-16(fp)
 322d764:	10800717 	ldw	r2,28(r2)
 322d768:	e0bff315 	stw	r2,-52(fp)

   switch (req) 
 322d76c:	e0bff317 	ldw	r2,-52(fp)
 322d770:	10800468 	cmpgeui	r2,r2,17
 322d774:	1001e31e 	bne	r2,zero,322df04 <rawip_usrreq+0x7c4>
 322d778:	e0bff317 	ldw	r2,-52(fp)
 322d77c:	1085883a 	add	r2,r2,r2
 322d780:	1087883a 	add	r3,r2,r2
 322d784:	0080c8f4 	movhi	r2,803
 322d788:	10b5e604 	addi	r2,r2,-10344
 322d78c:	1885883a 	add	r2,r3,r2
 322d790:	10800017 	ldw	r2,0(r2)
 322d794:	1000683a 	jmp	r2
 322d798:	0322d7dc 	xori	r12,zero,35679
 322d79c:	0322d864 	muli	r12,zero,-29855
 322d7a0:	0322d8a8 	cmpgeui	r12,zero,35682
 322d7a4:	0322df04 	movi	r12,-29828
 322d7a8:	0322d8a8 	cmpgeui	r12,zero,35682
 322d7ac:	0322df04 	movi	r12,-29828
 322d7b0:	0322def8 	rdprs	r12,zero,-29829
 322d7b4:	0322df04 	movi	r12,-29828
 322d7b8:	0322def8 	rdprs	r12,zero,-29829
 322d7bc:	0322da5c 	xori	r12,zero,35689
 322d7c0:	0322df04 	movi	r12,-29828
 322d7c4:	0322df04 	movi	r12,-29828
 322d7c8:	0322df04 	movi	r12,-29828
 322d7cc:	0322df04 	movi	r12,-29828
 322d7d0:	0322df04 	movi	r12,-29828
 322d7d4:	0322de4c 	andi	r12,zero,35705
 322d7d8:	0322de4c 	andi	r12,zero,35705
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
 322d7dc:	e0bffc17 	ldw	r2,-16(fp)
 322d7e0:	10800417 	ldw	r2,16(r2)
 322d7e4:	1108000c 	andi	r4,r2,8192
 322d7e8:	32440980 	call	3244098 <ip_raw_maxalloc>
 322d7ec:	1007883a 	mov	r3,r2
 322d7f0:	e0bffc17 	ldw	r2,-16(fp)
 322d7f4:	10c01315 	stw	r3,76(r2)
 322d7f8:	e0bffc17 	ldw	r2,-16(fp)
 322d7fc:	10c01317 	ldw	r3,76(r2)
 322d800:	e0bffc17 	ldw	r2,-16(fp)
 322d804:	10c00b15 	stw	r3,44(r2)
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
      /* make a raw IP endpoint */
      prot = (u_char)(MBUF2LONG(nam));
 322d808:	e0bffe17 	ldw	r2,-8(fp)
 322d80c:	e0bff505 	stb	r2,-44(fp)
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 322d810:	0009883a 	mov	r4,zero
 322d814:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      ep = ip_raw_open(prot, 0L, 0L, rawip_soinput, so);
 322d818:	e13ff503 	ldbu	r4,-44(fp)
 322d81c:	e0bffc17 	ldw	r2,-16(fp)
 322d820:	d8800015 	stw	r2,0(sp)
 322d824:	000b883a 	mov	r5,zero
 322d828:	000d883a 	mov	r6,zero
 322d82c:	01c0c8f4 	movhi	r7,803
 322d830:	39f55b04 	addi	r7,r7,-10900
 322d834:	3243ba40 	call	3243ba4 <ip_raw_open>
 322d838:	e0bff815 	stw	r2,-32(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 322d83c:	0009883a 	mov	r4,zero
 322d840:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      if (!ep)
 322d844:	e0bff817 	ldw	r2,-32(fp)
 322d848:	1004c03a 	cmpne	r2,r2,zero
 322d84c:	1000031e 	bne	r2,zero,322d85c <rawip_usrreq+0x11c>
         return(EINVAL);
 322d850:	00800584 	movi	r2,22
 322d854:	e0bfff15 	stw	r2,-4(fp)
 322d858:	0001ac06 	br	322df0c <rawip_usrreq+0x7cc>
      return 0;
 322d85c:	e03fff15 	stw	zero,-4(fp)
 322d860:	0001aa06 	br	322df0c <rawip_usrreq+0x7cc>
   case PRU_DETACH:
      /* delete the raw IP endpoint */
      ep = rawip_lookup(so);
 322d864:	e13ffc17 	ldw	r4,-16(fp)
 322d868:	322d4fc0 	call	322d4fc <rawip_lookup>
 322d86c:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 322d870:	e0bff817 	ldw	r2,-32(fp)
 322d874:	1004c03a 	cmpne	r2,r2,zero
 322d878:	1000031e 	bne	r2,zero,322d888 <rawip_usrreq+0x148>
         return(EINVAL);
 322d87c:	00800584 	movi	r2,22
 322d880:	e0bfff15 	stw	r2,-4(fp)
 322d884:	0001a106 	br	322df0c <rawip_usrreq+0x7cc>
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 322d888:	0009883a 	mov	r4,zero
 322d88c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      ip_raw_close(ep);
 322d890:	e13ff817 	ldw	r4,-32(fp)
 322d894:	3243c940 	call	3243c94 <ip_raw_close>
      LOCK_NET_RESOURCE(NET_RESID);
 322d898:	0009883a 	mov	r4,zero
 322d89c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      return 0;
 322d8a0:	e03fff15 	stw	zero,-4(fp)
 322d8a4:	00019906 	br	322df0c <rawip_usrreq+0x7cc>
       * a default address for sending
       */
      /* fall through to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 322d8a8:	e0bffe17 	ldw	r2,-8(fp)
 322d8ac:	1004c03a 	cmpne	r2,r2,zero
 322d8b0:	1000031e 	bne	r2,zero,322d8c0 <rawip_usrreq+0x180>
         return(EINVAL);
 322d8b4:	00800584 	movi	r2,22
 322d8b8:	e0bfff15 	stw	r2,-4(fp)
 322d8bc:	00019306 	br	322df0c <rawip_usrreq+0x7cc>
      sin = mtod(nam, struct sockaddr_in *);
 322d8c0:	e0bffe17 	ldw	r2,-8(fp)
 322d8c4:	10800317 	ldw	r2,12(r2)
 322d8c8:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 322d8cc:	e0bff917 	ldw	r2,-28(fp)
 322d8d0:	1004c03a 	cmpne	r2,r2,zero
 322d8d4:	1000031e 	bne	r2,zero,322d8e4 <rawip_usrreq+0x1a4>
         return(EINVAL);
 322d8d8:	00800584 	movi	r2,22
 322d8dc:	e0bfff15 	stw	r2,-4(fp)
 322d8e0:	00018a06 	br	322df0c <rawip_usrreq+0x7cc>
      if (nam->m_len != sizeof (*sin))
 322d8e4:	e0bffe17 	ldw	r2,-8(fp)
 322d8e8:	10800217 	ldw	r2,8(r2)
 322d8ec:	10800420 	cmpeqi	r2,r2,16
 322d8f0:	1000031e 	bne	r2,zero,322d900 <rawip_usrreq+0x1c0>
         return(EINVAL);
 322d8f4:	00800584 	movi	r2,22
 322d8f8:	e0bfff15 	stw	r2,-4(fp)
 322d8fc:	00018306 	br	322df0c <rawip_usrreq+0x7cc>
      ep = rawip_lookup(so);
 322d900:	e13ffc17 	ldw	r4,-16(fp)
 322d904:	322d4fc0 	call	322d4fc <rawip_lookup>
 322d908:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 322d90c:	e0bff817 	ldw	r2,-32(fp)
 322d910:	1004c03a 	cmpne	r2,r2,zero
 322d914:	1000031e 	bne	r2,zero,322d924 <rawip_usrreq+0x1e4>
         return(EINVAL);
 322d918:	00800584 	movi	r2,22
 322d91c:	e0bfff15 	stw	r2,-4(fp)
 322d920:	00017a06 	br	322df0c <rawip_usrreq+0x7cc>
      if (req == PRU_BIND)
 322d924:	e0bff317 	ldw	r2,-52(fp)
 322d928:	10800098 	cmpnei	r2,r2,2
 322d92c:	1000221e 	bne	r2,zero,322d9b8 <rawip_usrreq+0x278>
          * if the caller-supplied address is INADDR_ANY,
          * don't bind to a specific address; else, 
          * make sure the caller-supplied address is
          * an interface IP address and if so, bind to that
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 322d930:	e0bff917 	ldw	r2,-28(fp)
 322d934:	10800117 	ldw	r2,4(r2)
 322d938:	1004c03a 	cmpne	r2,r2,zero
 322d93c:	1000021e 	bne	r2,zero,322d948 <rawip_usrreq+0x208>
         {
            lhost = 0L;
 322d940:	e03ff615 	stw	zero,-40(fp)
 322d944:	00001806 	br	322d9a8 <rawip_usrreq+0x268>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
 322d948:	e0bff917 	ldw	r2,-28(fp)
 322d94c:	10800117 	ldw	r2,4(r2)
 322d950:	e0bff615 	stw	r2,-40(fp)
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 322d954:	0080c9b4 	movhi	r2,806
 322d958:	10b54604 	addi	r2,r2,-10984
 322d95c:	10800017 	ldw	r2,0(r2)
 322d960:	e0bff215 	stw	r2,-56(fp)
 322d964:	00000706 	br	322d984 <rawip_usrreq+0x244>
               if (ifp->n_ipaddr == lhost)
 322d968:	e0bff217 	ldw	r2,-56(fp)
 322d96c:	10c00a17 	ldw	r3,40(r2)
 322d970:	e0bff617 	ldw	r2,-40(fp)
 322d974:	18800626 	beq	r3,r2,322d990 <rawip_usrreq+0x250>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 322d978:	e0bff217 	ldw	r2,-56(fp)
 322d97c:	10800017 	ldw	r2,0(r2)
 322d980:	e0bff215 	stw	r2,-56(fp)
 322d984:	e0bff217 	ldw	r2,-56(fp)
 322d988:	1004c03a 	cmpne	r2,r2,zero
 322d98c:	103ff61e 	bne	r2,zero,322d968 <rawip_usrreq+0x228>
               if (ifp->n_ipaddr == lhost)
                  break;
            if (ifp == NULL)
 322d990:	e0bff217 	ldw	r2,-56(fp)
 322d994:	1004c03a 	cmpne	r2,r2,zero
 322d998:	1000031e 	bne	r2,zero,322d9a8 <rawip_usrreq+0x268>
               return(EADDRNOTAVAIL);
 322d99c:	00801f44 	movi	r2,125
 322d9a0:	e0bfff15 	stw	r2,-4(fp)
 322d9a4:	00015906 	br	322df0c <rawip_usrreq+0x7cc>
         }

         /* bind the endpoint */
         ep->ipr_laddr = lhost;
 322d9a8:	e0fff817 	ldw	r3,-32(fp)
 322d9ac:	e0bff617 	ldw	r2,-40(fp)
 322d9b0:	18800115 	stw	r2,4(r3)
 322d9b4:	00002706 	br	322da54 <rawip_usrreq+0x314>
          *
          * if the caller-supplied address is INADDR_ANY,
          * use the wildcard address; else, use the caller-
          * supplied address
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 322d9b8:	e0bff917 	ldw	r2,-28(fp)
 322d9bc:	10800117 	ldw	r2,4(r2)
 322d9c0:	1004c03a 	cmpne	r2,r2,zero
 322d9c4:	1000021e 	bne	r2,zero,322d9d0 <rawip_usrreq+0x290>
            fhost = 0L;
 322d9c8:	e03ff715 	stw	zero,-36(fp)
 322d9cc:	00000306 	br	322d9dc <rawip_usrreq+0x29c>
         else
            fhost = sin->sin_addr.s_addr;
 322d9d0:	e0bff917 	ldw	r2,-28(fp)
 322d9d4:	10800117 	ldw	r2,4(r2)
 322d9d8:	e0bff715 	stw	r2,-36(fp)
         /* connect the IP endpoint */
         ep->ipr_faddr = fhost;
 322d9dc:	e0fff817 	ldw	r3,-32(fp)
 322d9e0:	e0bff717 	ldw	r2,-36(fp)
 322d9e4:	18800215 	stw	r2,8(r3)
         /* mark the socket as connected or disconnected, as appropriate */
         if (fhost != 0L) {
 322d9e8:	e0bff717 	ldw	r2,-36(fp)
 322d9ec:	1005003a 	cmpeq	r2,r2,zero
 322d9f0:	10000e1e 	bne	r2,zero,322da2c <rawip_usrreq+0x2ec>
            so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 322d9f4:	e0bffc17 	ldw	r2,-16(fp)
 322d9f8:	10c0088b 	ldhu	r3,34(r2)
 322d9fc:	00bffcc4 	movi	r2,-13
 322da00:	1884703a 	and	r2,r3,r2
 322da04:	1007883a 	mov	r3,r2
 322da08:	e0bffc17 	ldw	r2,-16(fp)
 322da0c:	10c0088d 	sth	r3,34(r2)
            so->so_state |= SS_ISCONNECTED;
 322da10:	e0bffc17 	ldw	r2,-16(fp)
 322da14:	1080088b 	ldhu	r2,34(r2)
 322da18:	10800094 	ori	r2,r2,2
 322da1c:	1007883a 	mov	r3,r2
 322da20:	e0bffc17 	ldw	r2,-16(fp)
 322da24:	10c0088d 	sth	r3,34(r2)
 322da28:	00000706 	br	322da48 <rawip_usrreq+0x308>
         }
         else
         {
            so->so_state &= ~SS_ISCONNECTED;
 322da2c:	e0bffc17 	ldw	r2,-16(fp)
 322da30:	10c0088b 	ldhu	r3,34(r2)
 322da34:	00bfff44 	movi	r2,-3
 322da38:	1884703a 	and	r2,r3,r2
 322da3c:	1007883a 	mov	r3,r2
 322da40:	e0bffc17 	ldw	r2,-16(fp)
 322da44:	10c0088d 	sth	r3,34(r2)
         }
         /* since socket was in listen state, packets may be queued */
         sbflush(&so->so_rcv);   /* dump these now */
 322da48:	e0bffc17 	ldw	r2,-16(fp)
 322da4c:	11000a04 	addi	r4,r2,40
 322da50:	32329ac0 	call	32329ac <sbflush>
      }
      return 0;
 322da54:	e03fff15 	stw	zero,-4(fp)
 322da58:	00012c06 	br	322df0c <rawip_usrreq+0x7cc>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 322da5c:	e0bffd17 	ldw	r2,-12(fp)
 322da60:	1004c03a 	cmpne	r2,r2,zero
 322da64:	1000031e 	bne	r2,zero,322da74 <rawip_usrreq+0x334>
         return(EINVAL);
 322da68:	00800584 	movi	r2,22
 322da6c:	e0bfff15 	stw	r2,-4(fp)
 322da70:	00012606 	br	322df0c <rawip_usrreq+0x7cc>

      ep = rawip_lookup(so);
 322da74:	e13ffc17 	ldw	r4,-16(fp)
 322da78:	322d4fc0 	call	322d4fc <rawip_lookup>
 322da7c:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 322da80:	e0bff817 	ldw	r2,-32(fp)
 322da84:	1004c03a 	cmpne	r2,r2,zero
 322da88:	1000051e 	bne	r2,zero,322daa0 <rawip_usrreq+0x360>
      {
         m_free(m);
 322da8c:	e13ffd17 	ldw	r4,-12(fp)
 322da90:	322be980 	call	322be98 <m_free>
         /* may be bogus socket, but more likely the connection may 
         have closed due to ICMP dest unreachable from other side. */
         return(ECONNREFUSED);
 322da94:	00801bc4 	movi	r2,111
 322da98:	e0bfff15 	stw	r2,-4(fp)
 322da9c:	00011b06 	br	322df0c <rawip_usrreq+0x7cc>
      }

      if (nam == NULL)  /* no sendto() info passed, must be send() */
 322daa0:	e0bffe17 	ldw	r2,-8(fp)
 322daa4:	1004c03a 	cmpne	r2,r2,zero
 322daa8:	10000d1e 	bne	r2,zero,322dae0 <rawip_usrreq+0x3a0>
      {
         if (!(so->so_state & SS_ISCONNECTED))
 322daac:	e0bffc17 	ldw	r2,-16(fp)
 322dab0:	1080088b 	ldhu	r2,34(r2)
 322dab4:	10bfffcc 	andi	r2,r2,65535
 322dab8:	1080008c 	andi	r2,r2,2
 322dabc:	1004c03a 	cmpne	r2,r2,zero
 322dac0:	1000031e 	bne	r2,zero,322dad0 <rawip_usrreq+0x390>
            return (ENOTCONN);
 322dac4:	00802004 	movi	r2,128
 322dac8:	e0bfff15 	stw	r2,-4(fp)
 322dacc:	00010f06 	br	322df0c <rawip_usrreq+0x7cc>
         fhost = ep->ipr_faddr;
 322dad0:	e0bff817 	ldw	r2,-32(fp)
 322dad4:	10800217 	ldw	r2,8(r2)
 322dad8:	e0bff715 	stw	r2,-36(fp)
 322dadc:	00001706 	br	322db3c <rawip_usrreq+0x3fc>
      }
      else 
      {
         if (so->so_state & SS_ISCONNECTED)
 322dae0:	e0bffc17 	ldw	r2,-16(fp)
 322dae4:	1080088b 	ldhu	r2,34(r2)
 322dae8:	10bfffcc 	andi	r2,r2,65535
 322daec:	1080008c 	andi	r2,r2,2
 322daf0:	1005003a 	cmpeq	r2,r2,zero
 322daf4:	1000031e 	bne	r2,zero,322db04 <rawip_usrreq+0x3c4>
            return (EISCONN);
 322daf8:	00801fc4 	movi	r2,127
 322dafc:	e0bfff15 	stw	r2,-4(fp)
 322db00:	00010206 	br	322df0c <rawip_usrreq+0x7cc>
         if (nam->m_len != sizeof (*sin))
 322db04:	e0bffe17 	ldw	r2,-8(fp)
 322db08:	10800217 	ldw	r2,8(r2)
 322db0c:	10800420 	cmpeqi	r2,r2,16
 322db10:	1000041e 	bne	r2,zero,322db24 <rawip_usrreq+0x3e4>
         {
            dtrap();
 322db14:	322aef00 	call	322aef0 <dtrap>
            return (EINVAL);
 322db18:	00800584 	movi	r2,22
 322db1c:	e0bfff15 	stw	r2,-4(fp)
 322db20:	0000fa06 	br	322df0c <rawip_usrreq+0x7cc>
         }
         sin = mtod(nam, struct sockaddr_in *);
 322db24:	e0bffe17 	ldw	r2,-8(fp)
 322db28:	10800317 	ldw	r2,12(r2)
 322db2c:	e0bff915 	stw	r2,-28(fp)
         fhost = sin->sin_addr.s_addr;
 322db30:	e0bff917 	ldw	r2,-28(fp)
 322db34:	10800117 	ldw	r2,4(r2)
 322db38:	e0bff715 	stw	r2,-36(fp)

      /* since our pkt->nb_buff size is tied to max packet size, we 
       * assume our raw IP datagrams are always in one mbuf and that the 
       * mbuf -- but check anyway
       */
      if (m->m_len > (unsigned)ip_raw_maxalloc(so->so_options & SO_HDRINCL))
 322db3c:	e0bffd17 	ldw	r2,-12(fp)
 322db40:	14000217 	ldw	r16,8(r2)
 322db44:	e0bffc17 	ldw	r2,-16(fp)
 322db48:	10800417 	ldw	r2,16(r2)
 322db4c:	1108000c 	andi	r4,r2,8192
 322db50:	32440980 	call	3244098 <ip_raw_maxalloc>
 322db54:	1400042e 	bgeu	r2,r16,322db68 <rawip_usrreq+0x428>
      {
         dtrap(); /* should never happen */
 322db58:	322aef00 	call	322aef0 <dtrap>
         return EMSGSIZE;  /* try to recover */
 322db5c:	00801e84 	movi	r2,122
 322db60:	e0bfff15 	stw	r2,-4(fp)
 322db64:	0000e906 	br	322df0c <rawip_usrreq+0x7cc>
      }
      /* get a packet buffer for send */
      pkt = ip_raw_alloc(m->m_len, so->so_options & SO_HDRINCL);
 322db68:	e0bffd17 	ldw	r2,-12(fp)
 322db6c:	10800217 	ldw	r2,8(r2)
 322db70:	1009883a 	mov	r4,r2
 322db74:	e0bffc17 	ldw	r2,-16(fp)
 322db78:	10800417 	ldw	r2,16(r2)
 322db7c:	1148000c 	andi	r5,r2,8192
 322db80:	3243f8c0 	call	3243f8c <ip_raw_alloc>
 322db84:	e0bffa15 	stw	r2,-24(fp)
      if (!pkt)
 322db88:	e0bffa17 	ldw	r2,-24(fp)
 322db8c:	1004c03a 	cmpne	r2,r2,zero
 322db90:	1000051e 	bne	r2,zero,322dba8 <rawip_usrreq+0x468>
      {
         m_free(m);
 322db94:	e13ffd17 	ldw	r4,-12(fp)
 322db98:	322be980 	call	322be98 <m_free>
         return ENOBUFS;   /* report buffer shortages */
 322db9c:	00801a44 	movi	r2,105
 322dba0:	e0bfff15 	stw	r2,-4(fp)
 322dba4:	0000d906 	br	322df0c <rawip_usrreq+0x7cc>
      }
      MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 322dba8:	e0bffa17 	ldw	r2,-24(fp)
 322dbac:	10c00317 	ldw	r3,12(r2)
 322dbb0:	e0bffd17 	ldw	r2,-12(fp)
 322dbb4:	11400317 	ldw	r5,12(r2)
 322dbb8:	e0bffd17 	ldw	r2,-12(fp)
 322dbbc:	10800217 	ldw	r2,8(r2)
 322dbc0:	1809883a 	mov	r4,r3
 322dbc4:	100d883a 	mov	r6,r2
 322dbc8:	3206ad00 	call	3206ad0 <memcpy>
      pkt->nb_plen = m->m_len;
 322dbcc:	e0bffd17 	ldw	r2,-12(fp)
 322dbd0:	10c00217 	ldw	r3,8(r2)
 322dbd4:	e0bffa17 	ldw	r2,-24(fp)
 322dbd8:	10c00415 	stw	r3,16(r2)
      /* finished with mbuf, free it now */
      m_free(m);
 322dbdc:	e13ffd17 	ldw	r4,-12(fp)
 322dbe0:	322be980 	call	322be98 <m_free>
      pkt->fhost = fhost;
 322dbe4:	e0fffa17 	ldw	r3,-24(fp)
 322dbe8:	e0bff717 	ldw	r2,-36(fp)
 322dbec:	18800715 	stw	r2,28(r3)
       * is up; if (after all that) we don't have an interface then we
       * fail with error EADDRNOTAVAIL; and finally, if we're built
       * for a single-homed configuration where there's only one
       * interface, we might as well use it, so we do.  
       */
      if (fhost == 0xffffffff)
 322dbf0:	e0bff717 	ldw	r2,-36(fp)
 322dbf4:	10bfffd8 	cmpnei	r2,r2,-1
 322dbf8:	10004f1e 	bne	r2,zero,322dd38 <rawip_usrreq+0x5f8>
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
 322dbfc:	e0bff817 	ldw	r2,-32(fp)
 322dc00:	10800117 	ldw	r2,4(r2)
 322dc04:	1005003a 	cmpeq	r2,r2,zero
 322dc08:	1000111e 	bne	r2,zero,322dc50 <rawip_usrreq+0x510>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 322dc0c:	0080c9b4 	movhi	r2,806
 322dc10:	10b54604 	addi	r2,r2,-10984
 322dc14:	10800017 	ldw	r2,0(r2)
 322dc18:	e0bff215 	stw	r2,-56(fp)
 322dc1c:	00000806 	br	322dc40 <rawip_usrreq+0x500>
               if (ifp->n_ipaddr == ep->ipr_laddr)
 322dc20:	e0bff217 	ldw	r2,-56(fp)
 322dc24:	10c00a17 	ldw	r3,40(r2)
 322dc28:	e0bff817 	ldw	r2,-32(fp)
 322dc2c:	10800117 	ldw	r2,4(r2)
 322dc30:	18802126 	beq	r3,r2,322dcb8 <rawip_usrreq+0x578>
      if (fhost == 0xffffffff)
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 322dc34:	e0bff217 	ldw	r2,-56(fp)
 322dc38:	10800017 	ldw	r2,0(r2)
 322dc3c:	e0bff215 	stw	r2,-56(fp)
 322dc40:	e0bff217 	ldw	r2,-56(fp)
 322dc44:	1004c03a 	cmpne	r2,r2,zero
 322dc48:	103ff51e 	bne	r2,zero,322dc20 <rawip_usrreq+0x4e0>
 322dc4c:	00001a06 	br	322dcb8 <rawip_usrreq+0x578>
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 322dc50:	0080c9b4 	movhi	r2,806
 322dc54:	10b54604 	addi	r2,r2,-10984
 322dc58:	10800017 	ldw	r2,0(r2)
 322dc5c:	e0bff215 	stw	r2,-56(fp)
 322dc60:	00001206 	br	322dcac <rawip_usrreq+0x56c>
               if ((ifp->n_flags & NF_BCAST) &&
 322dc64:	e0bff217 	ldw	r2,-56(fp)
 322dc68:	10802a17 	ldw	r2,168(r2)
 322dc6c:	1080004c 	andi	r2,r2,1
 322dc70:	10803fcc 	andi	r2,r2,255
 322dc74:	1005003a 	cmpeq	r2,r2,zero
 322dc78:	1000091e 	bne	r2,zero,322dca0 <rawip_usrreq+0x560>
 322dc7c:	e0bff217 	ldw	r2,-56(fp)
 322dc80:	10802717 	ldw	r2,156(r2)
 322dc84:	1005003a 	cmpeq	r2,r2,zero
 322dc88:	1000051e 	bne	r2,zero,322dca0 <rawip_usrreq+0x560>
 322dc8c:	e0bff217 	ldw	r2,-56(fp)
 322dc90:	10802717 	ldw	r2,156(r2)
 322dc94:	10800617 	ldw	r2,24(r2)
 322dc98:	10800060 	cmpeqi	r2,r2,1
 322dc9c:	1000061e 	bne	r2,zero,322dcb8 <rawip_usrreq+0x578>
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 322dca0:	e0bff217 	ldw	r2,-56(fp)
 322dca4:	10800017 	ldw	r2,0(r2)
 322dca8:	e0bff215 	stw	r2,-56(fp)
 322dcac:	e0bff217 	ldw	r2,-56(fp)
 322dcb0:	1004c03a 	cmpne	r2,r2,zero
 322dcb4:	103feb1e 	bne	r2,zero,322dc64 <rawip_usrreq+0x524>
               if ((ifp->n_flags & NF_BCAST) &&
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
 322dcb8:	e0bff217 	ldw	r2,-56(fp)
 322dcbc:	1004c03a 	cmpne	r2,r2,zero
 322dcc0:	10001a1e 	bne	r2,zero,322dd2c <rawip_usrreq+0x5ec>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 322dcc4:	0080c9b4 	movhi	r2,806
 322dcc8:	10b54604 	addi	r2,r2,-10984
 322dccc:	10800017 	ldw	r2,0(r2)
 322dcd0:	e0bff215 	stw	r2,-56(fp)
 322dcd4:	00000c06 	br	322dd08 <rawip_usrreq+0x5c8>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 322dcd8:	e0bff217 	ldw	r2,-56(fp)
 322dcdc:	10802717 	ldw	r2,156(r2)
 322dce0:	1005003a 	cmpeq	r2,r2,zero
 322dce4:	1000051e 	bne	r2,zero,322dcfc <rawip_usrreq+0x5bc>
 322dce8:	e0bff217 	ldw	r2,-56(fp)
 322dcec:	10802717 	ldw	r2,156(r2)
 322dcf0:	10800617 	ldw	r2,24(r2)
 322dcf4:	10800060 	cmpeqi	r2,r2,1
 322dcf8:	1000061e 	bne	r2,zero,322dd14 <rawip_usrreq+0x5d4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 322dcfc:	e0bff217 	ldw	r2,-56(fp)
 322dd00:	10800017 	ldw	r2,0(r2)
 322dd04:	e0bff215 	stw	r2,-56(fp)
 322dd08:	e0bff217 	ldw	r2,-56(fp)
 322dd0c:	1004c03a 	cmpne	r2,r2,zero
 322dd10:	103ff11e 	bne	r2,zero,322dcd8 <rawip_usrreq+0x598>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
            if (ifp == NULL)
 322dd14:	e0bff217 	ldw	r2,-56(fp)
 322dd18:	1004c03a 	cmpne	r2,r2,zero
 322dd1c:	1000031e 	bne	r2,zero,322dd2c <rawip_usrreq+0x5ec>
               return(EADDRNOTAVAIL);
 322dd20:	00801f44 	movi	r2,125
 322dd24:	e0bfff15 	stw	r2,-4(fp)
 322dd28:	00007806 	br	322df0c <rawip_usrreq+0x7cc>
         }
         pkt->net = ifp;
 322dd2c:	e0fffa17 	ldw	r3,-24(fp)
 322dd30:	e0bff217 	ldw	r2,-56(fp)
 322dd34:	18800615 	stw	r2,24(r3)
#ifdef IP_MULTICAST

      /* If the socket has an IP moptions structure for multicast options,
       * place a pointer to this structure in the PACKET structure.
       */
      if (so->inp_moptions)
 322dd38:	e0bffc17 	ldw	r2,-16(fp)
 322dd3c:	10800317 	ldw	r2,12(r2)
 322dd40:	1005003a 	cmpeq	r2,r2,zero
 322dd44:	1000041e 	bne	r2,zero,322dd58 <rawip_usrreq+0x618>
         pkt->imo = so->inp_moptions;
 322dd48:	e0bffc17 	ldw	r2,-16(fp)
 322dd4c:	10c00317 	ldw	r3,12(r2)
 322dd50:	e0bffa17 	ldw	r2,-24(fp)
 322dd54:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

      if (so->so_options & SO_HDRINCL)
 322dd58:	e0bffc17 	ldw	r2,-16(fp)
 322dd5c:	10800417 	ldw	r2,16(r2)
 322dd60:	1088000c 	andi	r2,r2,8192
 322dd64:	1005003a 	cmpeq	r2,r2,zero
 322dd68:	1000081e 	bne	r2,zero,322dd8c <rawip_usrreq+0x64c>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 322dd6c:	0009883a 	mov	r4,zero
 322dd70:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         e = ip_raw_write(pkt);
 322dd74:	e13ffa17 	ldw	r4,-24(fp)
 322dd78:	323f96c0 	call	323f96c <ip_raw_write>
 322dd7c:	e0bffb15 	stw	r2,-20(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 322dd80:	0009883a 	mov	r4,zero
 322dd84:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
 322dd88:	00002806 	br	322de2c <rawip_usrreq+0x6ec>
      }
      else
      {
         pip = (struct ip *)(pkt->nb_prot - IPHSIZ);
 322dd8c:	e0bffa17 	ldw	r2,-24(fp)
 322dd90:	10800317 	ldw	r2,12(r2)
 322dd94:	10bffb04 	addi	r2,r2,-20
 322dd98:	e0bff415 	stw	r2,-48(fp)
         if (ep->ipr_laddr)
 322dd9c:	e0bff817 	ldw	r2,-32(fp)
 322dda0:	10800117 	ldw	r2,4(r2)
 322dda4:	1005003a 	cmpeq	r2,r2,zero
 322dda8:	1000051e 	bne	r2,zero,322ddc0 <rawip_usrreq+0x680>
            pip->ip_src = ep->ipr_laddr;
 322ddac:	e0bff817 	ldw	r2,-32(fp)
 322ddb0:	10c00117 	ldw	r3,4(r2)
 322ddb4:	e0bff417 	ldw	r2,-48(fp)
 322ddb8:	10c00315 	stw	r3,12(r2)
 322ddbc:	00000e06 	br	322ddf8 <rawip_usrreq+0x6b8>
         else
         {
            if (fhost == 0xffffffff)
 322ddc0:	e0bff717 	ldw	r2,-36(fp)
 322ddc4:	10bfffd8 	cmpnei	r2,r2,-1
 322ddc8:	1000061e 	bne	r2,zero,322dde4 <rawip_usrreq+0x6a4>
               pip->ip_src = pkt->net->n_ipaddr;
 322ddcc:	e0bffa17 	ldw	r2,-24(fp)
 322ddd0:	10800617 	ldw	r2,24(r2)
 322ddd4:	10c00a17 	ldw	r3,40(r2)
 322ddd8:	e0bff417 	ldw	r2,-48(fp)
 322dddc:	10c00315 	stw	r3,12(r2)
 322dde0:	00000506 	br	322ddf8 <rawip_usrreq+0x6b8>
            else
               pip->ip_src = ip_mymach(fhost);
 322dde4:	e13ff717 	ldw	r4,-36(fp)
 322dde8:	32404f00 	call	32404f0 <ip_mymach>
 322ddec:	1007883a 	mov	r3,r2
 322ddf0:	e0bff417 	ldw	r2,-48(fp)
 322ddf4:	10c00315 	stw	r3,12(r2)
         }
         pip->ip_dest = fhost;
 322ddf8:	e0fff417 	ldw	r3,-48(fp)
 322ddfc:	e0bff717 	ldw	r2,-36(fp)
 322de00:	18800415 	stw	r2,16(r3)
         UNLOCK_NET_RESOURCE(NET_RESID);
 322de04:	0009883a 	mov	r4,zero
 322de08:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         e = ip_write(ep->ipr_prot, pkt);
 322de0c:	e0bff817 	ldw	r2,-32(fp)
 322de10:	10800503 	ldbu	r2,20(r2)
 322de14:	11003fcc 	andi	r4,r2,255
 322de18:	e17ffa17 	ldw	r5,-24(fp)
 322de1c:	323f3740 	call	323f374 <ip_write>
 322de20:	e0bffb15 	stw	r2,-20(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 322de24:	0009883a 	mov	r4,zero
 322de28:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      }         
      if (e < 0) 
 322de2c:	e0bffb17 	ldw	r2,-20(fp)
 322de30:	1004403a 	cmpge	r2,r2,zero
 322de34:	1000031e 	bne	r2,zero,322de44 <rawip_usrreq+0x704>
         return(e);
 322de38:	e0bffb17 	ldw	r2,-20(fp)
 322de3c:	e0bfff15 	stw	r2,-4(fp)
 322de40:	00003206 	br	322df0c <rawip_usrreq+0x7cc>
      return 0;
 322de44:	e03fff15 	stw	zero,-4(fp)
 322de48:	00003006 	br	322df0c <rawip_usrreq+0x7cc>
   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 322de4c:	e0bffe17 	ldw	r2,-8(fp)
 322de50:	1004c03a 	cmpne	r2,r2,zero
 322de54:	1000031e 	bne	r2,zero,322de64 <rawip_usrreq+0x724>
         return(EINVAL);
 322de58:	00800584 	movi	r2,22
 322de5c:	e0bfff15 	stw	r2,-4(fp)
 322de60:	00002a06 	br	322df0c <rawip_usrreq+0x7cc>
      sin = mtod(nam, struct sockaddr_in *);
 322de64:	e0bffe17 	ldw	r2,-8(fp)
 322de68:	10800317 	ldw	r2,12(r2)
 322de6c:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 322de70:	e0bff917 	ldw	r2,-28(fp)
 322de74:	1004c03a 	cmpne	r2,r2,zero
 322de78:	1000031e 	bne	r2,zero,322de88 <rawip_usrreq+0x748>
         return(EINVAL);
 322de7c:	00800584 	movi	r2,22
 322de80:	e0bfff15 	stw	r2,-4(fp)
 322de84:	00002106 	br	322df0c <rawip_usrreq+0x7cc>
      ep = rawip_lookup(so);
 322de88:	e13ffc17 	ldw	r4,-16(fp)
 322de8c:	322d4fc0 	call	322d4fc <rawip_lookup>
 322de90:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 322de94:	e0bff817 	ldw	r2,-32(fp)
 322de98:	1004c03a 	cmpne	r2,r2,zero
 322de9c:	1000031e 	bne	r2,zero,322deac <rawip_usrreq+0x76c>
         return(EINVAL);
 322dea0:	00800584 	movi	r2,22
 322dea4:	e0bfff15 	stw	r2,-4(fp)
 322dea8:	00001806 	br	322df0c <rawip_usrreq+0x7cc>
      sin->sin_port = 0;
 322deac:	e0bff917 	ldw	r2,-28(fp)
 322deb0:	1000008d 	sth	zero,2(r2)
      nam->m_len = sizeof(*sin);
 322deb4:	e0fffe17 	ldw	r3,-8(fp)
 322deb8:	00800404 	movi	r2,16
 322debc:	18800215 	stw	r2,8(r3)
      if (req == PRU_SOCKADDR)
 322dec0:	e0bff317 	ldw	r2,-52(fp)
 322dec4:	108003d8 	cmpnei	r2,r2,15
 322dec8:	1000051e 	bne	r2,zero,322dee0 <rawip_usrreq+0x7a0>
      {
         sin->sin_addr.s_addr = ep->ipr_laddr;
 322decc:	e0bff817 	ldw	r2,-32(fp)
 322ded0:	10c00117 	ldw	r3,4(r2)
 322ded4:	e0bff917 	ldw	r2,-28(fp)
 322ded8:	10c00115 	stw	r3,4(r2)
 322dedc:	00000406 	br	322def0 <rawip_usrreq+0x7b0>
      }
      else /* PRU_PEERADDR */
      {
         sin->sin_addr.s_addr = ep->ipr_faddr;
 322dee0:	e0bff817 	ldw	r2,-32(fp)
 322dee4:	10c00217 	ldw	r3,8(r2)
 322dee8:	e0bff917 	ldw	r2,-28(fp)
 322deec:	10c00115 	stw	r3,4(r2)
      }
      return 0;
 322def0:	e03fff15 	stw	zero,-4(fp)
 322def4:	00000506 	br	322df0c <rawip_usrreq+0x7cc>
   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 322def8:	322aef00 	call	322aef0 <dtrap>
      return 0;
 322defc:	e03fff15 	stw	zero,-4(fp)
 322df00:	00000206 	br	322df0c <rawip_usrreq+0x7cc>
   case PRU_LISTEN:     /* don't support these for raw IP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 322df04:	008017c4 	movi	r2,95
 322df08:	e0bfff15 	stw	r2,-4(fp)
 322df0c:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 322df10:	e037883a 	mov	sp,fp
 322df14:	dfc00217 	ldw	ra,8(sp)
 322df18:	df000117 	ldw	fp,4(sp)
 322df1c:	dc000017 	ldw	r16,0(sp)
 322df20:	dec00304 	addi	sp,sp,12
 322df24:	f800283a 	ret

0322df28 <DOMAIN_CHECK>:
 */

#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
 322df28:	defffc04 	addi	sp,sp,-16
 322df2c:	dfc00315 	stw	ra,12(sp)
 322df30:	df000215 	stw	fp,8(sp)
 322df34:	df000204 	addi	fp,sp,8
 322df38:	e13ffe15 	stw	r4,-8(fp)
 322df3c:	e17fff15 	stw	r5,-4(fp)
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 322df40:	e0bffe17 	ldw	r2,-8(fp)
 322df44:	10800517 	ldw	r2,20(r2)
 322df48:	10800098 	cmpnei	r2,r2,2
 322df4c:	1000041e 	bne	r2,zero,322df60 <DOMAIN_CHECK+0x38>
 322df50:	e0bfff17 	ldw	r2,-4(fp)
 322df54:	10800428 	cmpgeui	r2,r2,16
 322df58:	1000011e 	bne	r2,zero,322df60 <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
   {
      dtrap(); /* programmer passed wrong structure */
 322df5c:	322aef00 	call	322aef0 <dtrap>
      (size != sizeof(struct sockaddr_in6)))
   {
      dtrap(); /* programmer passed wrong structure */
   }
#endif   /* IP_V6 */
}
 322df60:	e037883a 	mov	sp,fp
 322df64:	dfc00117 	ldw	ra,4(sp)
 322df68:	df000017 	ldw	fp,0(sp)
 322df6c:	dec00204 	addi	sp,sp,8
 322df70:	f800283a 	ret

0322df74 <t_socket>:

long
t_socket(int family, 
   int   type, 
   int   proto)
{
 322df74:	defff904 	addi	sp,sp,-28
 322df78:	dfc00615 	stw	ra,24(sp)
 322df7c:	df000515 	stw	fp,20(sp)
 322df80:	df000504 	addi	fp,sp,20
 322df84:	e13ffc15 	stw	r4,-16(fp)
 322df88:	e17ffd15 	stw	r5,-12(fp)
 322df8c:	e1bffe15 	stw	r6,-8(fp)
   struct socket *   so;

   INET_TRACE (INETM_SOCKET, ("SOCK:sock:family %d, typ %d, proto %d\n",
    family, type, proto));
   LOCK_NET_RESOURCE(NET_RESID);
 322df90:	0009883a 	mov	r4,zero
 322df94:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   if ((so = socreate (family, type, proto)) == NULL) 
 322df98:	e13ffc17 	ldw	r4,-16(fp)
 322df9c:	e17ffd17 	ldw	r5,-12(fp)
 322dfa0:	e1bffe17 	ldw	r6,-8(fp)
 322dfa4:	322f7240 	call	322f724 <socreate>
 322dfa8:	e0bffb15 	stw	r2,-20(fp)
 322dfac:	e0bffb17 	ldw	r2,-20(fp)
 322dfb0:	1004c03a 	cmpne	r2,r2,zero
 322dfb4:	1000051e 	bne	r2,zero,322dfcc <t_socket+0x58>
   {  /* can't really return error info since no socket.... */
      UNLOCK_NET_RESOURCE(NET_RESID);
 322dfb8:	0009883a 	mov	r4,zero
 322dfbc:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 322dfc0:	00bfffc4 	movi	r2,-1
 322dfc4:	e0bfff15 	stw	r2,-4(fp)
 322dfc8:	00000806 	br	322dfec <t_socket+0x78>
   }
   SOC_RANGE(so);
   so->so_error = 0;
 322dfcc:	e0bffb17 	ldw	r2,-20(fp)
 322dfd0:	10000615 	stw	zero,24(r2)
   UNLOCK_NET_RESOURCE(NET_RESID);
 322dfd4:	0009883a 	mov	r4,zero
 322dfd8:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   return SO2LONG(so);
 322dfdc:	e0bffb17 	ldw	r2,-20(fp)
 322dfe0:	1004d0ba 	srli	r2,r2,2
 322dfe4:	10800804 	addi	r2,r2,32
 322dfe8:	e0bfff15 	stw	r2,-4(fp)
 322dfec:	e0bfff17 	ldw	r2,-4(fp)
}
 322dff0:	e037883a 	mov	sp,fp
 322dff4:	dfc00117 	ldw	ra,4(sp)
 322dff8:	df000017 	ldw	fp,0(sp)
 322dffc:	dec00204 	addi	sp,sp,8
 322e000:	f800283a 	ret

0322e004 <t_bind>:

int
t_bind (long s, 
   struct sockaddr * addr,
   int addrlen)
{
 322e004:	defff104 	addi	sp,sp,-60
 322e008:	dfc00e15 	stw	ra,56(sp)
 322e00c:	df000d15 	stw	fp,52(sp)
 322e010:	df000d04 	addi	fp,sp,52
 322e014:	e13ffc15 	stw	r4,-16(fp)
 322e018:	e17ffd15 	stw	r5,-12(fp)
 322e01c:	e1bffe15 	stw	r6,-8(fp)
   struct sockaddr   sa;
   struct sockaddr * sap;
   struct socket *   so;
   int               err;

   so = LONG2SO(s);  /* convert long to socket */
 322e020:	e0bffc17 	ldw	r2,-16(fp)
 322e024:	10bff804 	addi	r2,r2,-32
 322e028:	1085883a 	add	r2,r2,r2
 322e02c:	1085883a 	add	r2,r2,r2
 322e030:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 322e034:	0080c9b4 	movhi	r2,806
 322e038:	10b48204 	addi	r2,r2,-11768
 322e03c:	e0bff315 	stw	r2,-52(fp)
 322e040:	00000606 	br	322e05c <t_bind+0x58>
 322e044:	e0fff317 	ldw	r3,-52(fp)
 322e048:	e0bff517 	ldw	r2,-44(fp)
 322e04c:	18800626 	beq	r3,r2,322e068 <t_bind+0x64>
 322e050:	e0bff317 	ldw	r2,-52(fp)
 322e054:	10800017 	ldw	r2,0(r2)
 322e058:	e0bff315 	stw	r2,-52(fp)
 322e05c:	e0bff317 	ldw	r2,-52(fp)
 322e060:	1004c03a 	cmpne	r2,r2,zero
 322e064:	103ff71e 	bne	r2,zero,322e044 <t_bind+0x40>
 322e068:	e0fff317 	ldw	r3,-52(fp)
 322e06c:	e0bff517 	ldw	r2,-44(fp)
 322e070:	18800426 	beq	r3,r2,322e084 <t_bind+0x80>
 322e074:	322aef00 	call	322aef0 <dtrap>
 322e078:	00bfffc4 	movi	r2,-1
 322e07c:	e0bfff15 	stw	r2,-4(fp)
 322e080:	00003906 	br	322e168 <t_bind+0x164>
   DOMAIN_CHECK(so, addrlen);
 322e084:	e13ff517 	ldw	r4,-44(fp)
 322e088:	e17ffe17 	ldw	r5,-8(fp)
 322e08c:	322df280 	call	322df28 <DOMAIN_CHECK>

   so->so_error = 0;
 322e090:	e0bff517 	ldw	r2,-44(fp)
 322e094:	10000615 	stw	zero,24(r2)
   if (addr == (struct sockaddr *)NULL) 
 322e098:	e0bffd17 	ldw	r2,-12(fp)
 322e09c:	1004c03a 	cmpne	r2,r2,zero
 322e0a0:	10000d1e 	bne	r2,zero,322e0d8 <t_bind+0xd4>
   {
      MEMSET ((void *)&sa, 0, sizeof(sa));
 322e0a4:	e0bff804 	addi	r2,fp,-32
 322e0a8:	10000015 	stw	zero,0(r2)
 322e0ac:	10000115 	stw	zero,4(r2)
 322e0b0:	10000215 	stw	zero,8(r2)
 322e0b4:	10000315 	stw	zero,12(r2)
      addrlen = sizeof(sa);
 322e0b8:	00800404 	movi	r2,16
 322e0bc:	e0bffe15 	stw	r2,-8(fp)
      sa.sa_family = so->so_domain;
 322e0c0:	e0bff517 	ldw	r2,-44(fp)
 322e0c4:	10800517 	ldw	r2,20(r2)
 322e0c8:	e0bff80d 	sth	r2,-32(fp)
      sap = &sa;
 322e0cc:	e0bff804 	addi	r2,fp,-32
 322e0d0:	e0bff615 	stw	r2,-40(fp)
 322e0d4:	00000206 	br	322e0e0 <t_bind+0xdc>
   } else
      sap = addr;
 322e0d8:	e0bffd17 	ldw	r2,-12(fp)
 322e0dc:	e0bff615 	stw	r2,-40(fp)

   if ((nam = sockargs (sap, addrlen, MT_SONAME)) == NULL) 
 322e0e0:	e13ff617 	ldw	r4,-40(fp)
 322e0e4:	e17ffe17 	ldw	r5,-8(fp)
 322e0e8:	01800244 	movi	r6,9
 322e0ec:	322f5f00 	call	322f5f0 <sockargs>
 322e0f0:	e0bff715 	stw	r2,-36(fp)
 322e0f4:	e0bff717 	ldw	r2,-36(fp)
 322e0f8:	1004c03a 	cmpne	r2,r2,zero
 322e0fc:	1000061e 	bne	r2,zero,322e118 <t_bind+0x114>
   {
      so->so_error = ENOMEM;
 322e100:	e0fff517 	ldw	r3,-44(fp)
 322e104:	00800304 	movi	r2,12
 322e108:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322e10c:	00bfffc4 	movi	r2,-1
 322e110:	e0bfff15 	stw	r2,-4(fp)
 322e114:	00001406 	br	322e168 <t_bind+0x164>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 322e118:	0009883a 	mov	r4,zero
 322e11c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   err = sobind (so, nam);
 322e120:	e13ff517 	ldw	r4,-44(fp)
 322e124:	e17ff717 	ldw	r5,-36(fp)
 322e128:	322f8f00 	call	322f8f0 <sobind>
 322e12c:	e0bff415 	stw	r2,-48(fp)
   m_freem(nam);
 322e130:	e13ff717 	ldw	r4,-36(fp)
 322e134:	322bfcc0 	call	322bfcc <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 322e138:	0009883a 	mov	r4,zero
 322e13c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   if (err) 
 322e140:	e0bff417 	ldw	r2,-48(fp)
 322e144:	1005003a 	cmpeq	r2,r2,zero
 322e148:	1000061e 	bne	r2,zero,322e164 <t_bind+0x160>
   {
      so->so_error = err;
 322e14c:	e0fff517 	ldw	r3,-44(fp)
 322e150:	e0bff417 	ldw	r2,-48(fp)
 322e154:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322e158:	00bfffc4 	movi	r2,-1
 322e15c:	e0bfff15 	stw	r2,-4(fp)
 322e160:	00000106 	br	322e168 <t_bind+0x164>
   }
   return 0;
 322e164:	e03fff15 	stw	zero,-4(fp)
 322e168:	e0bfff17 	ldw	r2,-4(fp)
}
 322e16c:	e037883a 	mov	sp,fp
 322e170:	dfc00117 	ldw	ra,4(sp)
 322e174:	df000017 	ldw	fp,0(sp)
 322e178:	dec00204 	addi	sp,sp,8
 322e17c:	f800283a 	ret

0322e180 <t_listen>:
 */

int
t_listen(long s, 
   int   backlog)
{
 322e180:	defff804 	addi	sp,sp,-32
 322e184:	dfc00715 	stw	ra,28(sp)
 322e188:	df000615 	stw	fp,24(sp)
 322e18c:	df000604 	addi	fp,sp,24
 322e190:	e13ffd15 	stw	r4,-12(fp)
 322e194:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);  /* convert long to socket */
 322e198:	e0bffd17 	ldw	r2,-12(fp)
 322e19c:	10bff804 	addi	r2,r2,-32
 322e1a0:	1085883a 	add	r2,r2,r2
 322e1a4:	1085883a 	add	r2,r2,r2
 322e1a8:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 322e1ac:	0080c9b4 	movhi	r2,806
 322e1b0:	10b48204 	addi	r2,r2,-11768
 322e1b4:	e0bffa15 	stw	r2,-24(fp)
 322e1b8:	00000606 	br	322e1d4 <t_listen+0x54>
 322e1bc:	e0fffa17 	ldw	r3,-24(fp)
 322e1c0:	e0bffc17 	ldw	r2,-16(fp)
 322e1c4:	18800626 	beq	r3,r2,322e1e0 <t_listen+0x60>
 322e1c8:	e0bffa17 	ldw	r2,-24(fp)
 322e1cc:	10800017 	ldw	r2,0(r2)
 322e1d0:	e0bffa15 	stw	r2,-24(fp)
 322e1d4:	e0bffa17 	ldw	r2,-24(fp)
 322e1d8:	1004c03a 	cmpne	r2,r2,zero
 322e1dc:	103ff71e 	bne	r2,zero,322e1bc <t_listen+0x3c>
 322e1e0:	e0fffa17 	ldw	r3,-24(fp)
 322e1e4:	e0bffc17 	ldw	r2,-16(fp)
 322e1e8:	18800426 	beq	r3,r2,322e1fc <t_listen+0x7c>
 322e1ec:	322aef00 	call	322aef0 <dtrap>
 322e1f0:	00bfffc4 	movi	r2,-1
 322e1f4:	e0bfff15 	stw	r2,-4(fp)
 322e1f8:	00001406 	br	322e24c <t_listen+0xcc>
   so->so_error = 0;
 322e1fc:	e0bffc17 	ldw	r2,-16(fp)
 322e200:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("SOCK:listen:qlen %d\n", backlog));

   LOCK_NET_RESOURCE(NET_RESID);
 322e204:	0009883a 	mov	r4,zero
 322e208:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   err = solisten (so, backlog);
 322e20c:	e13ffc17 	ldw	r4,-16(fp)
 322e210:	e17ffe17 	ldw	r5,-8(fp)
 322e214:	322f94c0 	call	322f94c <solisten>
 322e218:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 322e21c:	0009883a 	mov	r4,zero
 322e220:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 322e224:	e0bffb17 	ldw	r2,-20(fp)
 322e228:	1005003a 	cmpeq	r2,r2,zero
 322e22c:	1000061e 	bne	r2,zero,322e248 <t_listen+0xc8>
   {
      so->so_error = err;
 322e230:	e0fffc17 	ldw	r3,-16(fp)
 322e234:	e0bffb17 	ldw	r2,-20(fp)
 322e238:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322e23c:	00bfffc4 	movi	r2,-1
 322e240:	e0bfff15 	stw	r2,-4(fp)
 322e244:	00000106 	br	322e24c <t_listen+0xcc>
   }
   return 0;
 322e248:	e03fff15 	stw	zero,-4(fp)
 322e24c:	e0bfff17 	ldw	r2,-4(fp)
}
 322e250:	e037883a 	mov	sp,fp
 322e254:	dfc00117 	ldw	ra,4(sp)
 322e258:	df000017 	ldw	fp,0(sp)
 322e25c:	dec00204 	addi	sp,sp,8
 322e260:	f800283a 	ret

0322e264 <t_accept>:

long
t_accept(long s, 
   struct sockaddr * addr,
   int * addrlen)
{
 322e264:	defff604 	addi	sp,sp,-40
 322e268:	dfc00915 	stw	ra,36(sp)
 322e26c:	df000815 	stw	fp,32(sp)
 322e270:	df000804 	addi	fp,sp,32
 322e274:	e13ffc15 	stw	r4,-16(fp)
 322e278:	e17ffd15 	stw	r5,-12(fp)
 322e27c:	e1bffe15 	stw	r6,-8(fp)
   char logbuf[10];
#endif
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 322e280:	e0bffc17 	ldw	r2,-16(fp)
 322e284:	10bff804 	addi	r2,r2,-32
 322e288:	1085883a 	add	r2,r2,r2
 322e28c:	1085883a 	add	r2,r2,r2
 322e290:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 322e294:	0080c9b4 	movhi	r2,806
 322e298:	10b48204 	addi	r2,r2,-11768
 322e29c:	e0bff915 	stw	r2,-28(fp)
 322e2a0:	00000606 	br	322e2bc <t_accept+0x58>
 322e2a4:	e0fff917 	ldw	r3,-28(fp)
 322e2a8:	e0bffb17 	ldw	r2,-20(fp)
 322e2ac:	18800626 	beq	r3,r2,322e2c8 <t_accept+0x64>
 322e2b0:	e0bff917 	ldw	r2,-28(fp)
 322e2b4:	10800017 	ldw	r2,0(r2)
 322e2b8:	e0bff915 	stw	r2,-28(fp)
 322e2bc:	e0bff917 	ldw	r2,-28(fp)
 322e2c0:	1004c03a 	cmpne	r2,r2,zero
 322e2c4:	103ff71e 	bne	r2,zero,322e2a4 <t_accept+0x40>
 322e2c8:	e0fff917 	ldw	r3,-28(fp)
 322e2cc:	e0bffb17 	ldw	r2,-20(fp)
 322e2d0:	18800426 	beq	r3,r2,322e2e4 <t_accept+0x80>
 322e2d4:	322aef00 	call	322aef0 <dtrap>
 322e2d8:	00bfffc4 	movi	r2,-1
 322e2dc:	e0bfff15 	stw	r2,-4(fp)
 322e2e0:	00008006 	br	322e4e4 <t_accept+0x280>
   DOMAIN_CHECK(so, *addrlen);
 322e2e4:	e0bffe17 	ldw	r2,-8(fp)
 322e2e8:	11400017 	ldw	r5,0(r2)
 322e2ec:	e13ffb17 	ldw	r4,-20(fp)
 322e2f0:	322df280 	call	322df28 <DOMAIN_CHECK>

   so->so_error = 0;
 322e2f4:	e0bffb17 	ldw	r2,-20(fp)
 322e2f8:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
      ("INET:accept:so %x so_qlen %d so_state %x\n", so, so->so_qlen, so->so_state));
   if ((so->so_options & SO_ACCEPTCONN) == 0)
 322e2fc:	e0bffb17 	ldw	r2,-20(fp)
 322e300:	10800417 	ldw	r2,16(r2)
 322e304:	1080008c 	andi	r2,r2,2
 322e308:	1004c03a 	cmpne	r2,r2,zero
 322e30c:	1000061e 	bne	r2,zero,322e328 <t_accept+0xc4>
   {
      so->so_error = EINVAL;
 322e310:	e0fffb17 	ldw	r3,-20(fp)
 322e314:	00800584 	movi	r2,22
 322e318:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 322e31c:	00bfffc4 	movi	r2,-1
 322e320:	e0bfff15 	stw	r2,-4(fp)
 322e324:	00006f06 	br	322e4e4 <t_accept+0x280>
   }
   if ((so->so_state & SS_NBIO) && so->so_qlen == 0)
 322e328:	e0bffb17 	ldw	r2,-20(fp)
 322e32c:	1080088b 	ldhu	r2,34(r2)
 322e330:	10bfffcc 	andi	r2,r2,65535
 322e334:	1080400c 	andi	r2,r2,256
 322e338:	1005003a 	cmpeq	r2,r2,zero
 322e33c:	10000d1e 	bne	r2,zero,322e374 <t_accept+0x110>
 322e340:	e0bffb17 	ldw	r2,-20(fp)
 322e344:	10801e43 	ldbu	r2,121(r2)
 322e348:	10803fcc 	andi	r2,r2,255
 322e34c:	1080201c 	xori	r2,r2,128
 322e350:	10bfe004 	addi	r2,r2,-128
 322e354:	1004c03a 	cmpne	r2,r2,zero
 322e358:	1000061e 	bne	r2,zero,322e374 <t_accept+0x110>
   {
      so->so_error = EWOULDBLOCK;
 322e35c:	e0fffb17 	ldw	r3,-20(fp)
 322e360:	008002c4 	movi	r2,11
 322e364:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 322e368:	00bfffc4 	movi	r2,-1
 322e36c:	e0bfff15 	stw	r2,-4(fp)
 322e370:	00005c06 	br	322e4e4 <t_accept+0x280>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 322e374:	0009883a 	mov	r4,zero
 322e378:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   while (so->so_qlen == 0 && so->so_error == 0)
 322e37c:	00001206 	br	322e3c8 <t_accept+0x164>
   {
      if (so->so_state & SS_CANTRCVMORE)
 322e380:	e0bffb17 	ldw	r2,-20(fp)
 322e384:	1080088b 	ldhu	r2,34(r2)
 322e388:	10bfffcc 	andi	r2,r2,65535
 322e38c:	1080080c 	andi	r2,r2,32
 322e390:	1005003a 	cmpeq	r2,r2,zero
 322e394:	1000081e 	bne	r2,zero,322e3b8 <t_accept+0x154>
      {
         so->so_error = ECONNABORTED;
 322e398:	e0fffb17 	ldw	r3,-20(fp)
 322e39c:	00801c44 	movi	r2,113
 322e3a0:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE(NET_RESID);
 322e3a4:	0009883a 	mov	r4,zero
 322e3a8:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 322e3ac:	00bfffc4 	movi	r2,-1
 322e3b0:	e0bfff15 	stw	r2,-4(fp)
 322e3b4:	00004b06 	br	322e4e4 <t_accept+0x280>
      }
      tcp_sleep ((char *)&so->so_timeo);
 322e3b8:	e0bffb17 	ldw	r2,-20(fp)
 322e3bc:	10800904 	addi	r2,r2,36
 322e3c0:	1009883a 	mov	r4,r2
 322e3c4:	3226ac40 	call	3226ac4 <tcp_sleep>
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
   }
   LOCK_NET_RESOURCE(NET_RESID);
   while (so->so_qlen == 0 && so->so_error == 0)
 322e3c8:	e0bffb17 	ldw	r2,-20(fp)
 322e3cc:	10801e43 	ldbu	r2,121(r2)
 322e3d0:	10803fcc 	andi	r2,r2,255
 322e3d4:	1080201c 	xori	r2,r2,128
 322e3d8:	10bfe004 	addi	r2,r2,-128
 322e3dc:	1004c03a 	cmpne	r2,r2,zero
 322e3e0:	1000041e 	bne	r2,zero,322e3f4 <t_accept+0x190>
 322e3e4:	e0bffb17 	ldw	r2,-20(fp)
 322e3e8:	10800617 	ldw	r2,24(r2)
 322e3ec:	1005003a 	cmpeq	r2,r2,zero
 322e3f0:	103fe31e 	bne	r2,zero,322e380 <t_accept+0x11c>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return SOCKET_ERROR;
      }
      tcp_sleep ((char *)&so->so_timeo);
   }
   if (so->so_error)
 322e3f4:	e0bffb17 	ldw	r2,-20(fp)
 322e3f8:	10800617 	ldw	r2,24(r2)
 322e3fc:	1005003a 	cmpeq	r2,r2,zero
 322e400:	1000051e 	bne	r2,zero,322e418 <t_accept+0x1b4>
   {
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 322e404:	0009883a 	mov	r4,zero
 322e408:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 322e40c:	00bfffc4 	movi	r2,-1
 322e410:	e0bfff15 	stw	r2,-4(fp)
 322e414:	00003306 	br	322e4e4 <t_accept+0x280>
   }
   nam = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 322e418:	01000244 	movi	r4,9
 322e41c:	01400404 	movi	r5,16
 322e420:	322bcf00 	call	322bcf0 <m_getnbuf>
 322e424:	e0bffa15 	stw	r2,-24(fp)
   if (nam == NULL) 
 322e428:	e0bffa17 	ldw	r2,-24(fp)
 322e42c:	1004c03a 	cmpne	r2,r2,zero
 322e430:	1000081e 	bne	r2,zero,322e454 <t_accept+0x1f0>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 322e434:	0009883a 	mov	r4,zero
 322e438:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      so->so_error = ENOMEM;
 322e43c:	e0fffb17 	ldw	r3,-20(fp)
 322e440:	00800304 	movi	r2,12
 322e444:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 322e448:	00bfffc4 	movi	r2,-1
 322e44c:	e0bfff15 	stw	r2,-4(fp)
 322e450:	00002406 	br	322e4e4 <t_accept+0x280>
   }
   { 
      struct socket *aso = so->so_q;
 322e454:	e0bffb17 	ldw	r2,-20(fp)
 322e458:	10801d17 	ldw	r2,116(r2)
 322e45c:	e0bff815 	stw	r2,-32(fp)
      if (soqremque (aso, 1) == 0)
 322e460:	e13ff817 	ldw	r4,-32(fp)
 322e464:	01400044 	movi	r5,1
 322e468:	32320100 	call	3232010 <soqremque>
 322e46c:	1004c03a 	cmpne	r2,r2,zero
 322e470:	1000031e 	bne	r2,zero,322e480 <t_accept+0x21c>
         panic("accept");
 322e474:	0100c974 	movhi	r4,805
 322e478:	213e2f04 	addi	r4,r4,-1860
 322e47c:	32261540 	call	3226154 <panic>
      so = aso;
 322e480:	e0bff817 	ldw	r2,-32(fp)
 322e484:	e0bffb15 	stw	r2,-20(fp)
   }
   (void)soaccept (so, nam);
 322e488:	e13ffb17 	ldw	r4,-20(fp)
 322e48c:	e17ffa17 	ldw	r5,-24(fp)
 322e490:	322feb00 	call	322feb0 <soaccept>
      INET_TRACE (INETM_SOCKET, ("INET:accept:done so %lx port %d addr %lx\n",
       so, sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_INET */
   /* return the addressing info in the passed structure */
   if (addr != NULL)
 322e494:	e0bffd17 	ldw	r2,-12(fp)
 322e498:	1005003a 	cmpeq	r2,r2,zero
 322e49c:	1000091e 	bne	r2,zero,322e4c4 <t_accept+0x260>
      MEMCPY(addr, nam->m_data, *addrlen);
 322e4a0:	e0bffa17 	ldw	r2,-24(fp)
 322e4a4:	11400317 	ldw	r5,12(r2)
 322e4a8:	e0bffe17 	ldw	r2,-8(fp)
 322e4ac:	10800017 	ldw	r2,0(r2)
 322e4b0:	1007883a 	mov	r3,r2
 322e4b4:	e0bffd17 	ldw	r2,-12(fp)
 322e4b8:	1009883a 	mov	r4,r2
 322e4bc:	180d883a 	mov	r6,r3
 322e4c0:	3206ad00 	call	3206ad0 <memcpy>
   m_freem (nam);
 322e4c4:	e13ffa17 	ldw	r4,-24(fp)
 322e4c8:	322bfcc0 	call	322bfcc <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 322e4cc:	0009883a 	mov	r4,zero
 322e4d0:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   SOC_RANGE(so);
   return SO2LONG(so);
 322e4d4:	e0bffb17 	ldw	r2,-20(fp)
 322e4d8:	1004d0ba 	srli	r2,r2,2
 322e4dc:	10800804 	addi	r2,r2,32
 322e4e0:	e0bfff15 	stw	r2,-4(fp)
 322e4e4:	e0bfff17 	ldw	r2,-4(fp)
}
 322e4e8:	e037883a 	mov	sp,fp
 322e4ec:	dfc00117 	ldw	ra,4(sp)
 322e4f0:	df000017 	ldw	fp,0(sp)
 322e4f4:	dec00204 	addi	sp,sp,8
 322e4f8:	f800283a 	ret

0322e4fc <t_connect>:

int
t_connect(long s, 
   struct sockaddr * addr,
   int   addrlen)
{
 322e4fc:	defff704 	addi	sp,sp,-36
 322e500:	dfc00815 	stw	ra,32(sp)
 322e504:	df000715 	stw	fp,28(sp)
 322e508:	df000704 	addi	fp,sp,28
 322e50c:	e13ffc15 	stw	r4,-16(fp)
 322e510:	e17ffd15 	stw	r5,-12(fp)
 322e514:	e1bffe15 	stw	r6,-8(fp)
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 322e518:	e0bffc17 	ldw	r2,-16(fp)
 322e51c:	10bff804 	addi	r2,r2,-32
 322e520:	1085883a 	add	r2,r2,r2
 322e524:	1085883a 	add	r2,r2,r2
 322e528:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 322e52c:	0080c9b4 	movhi	r2,806
 322e530:	10b48204 	addi	r2,r2,-11768
 322e534:	e0bff915 	stw	r2,-28(fp)
 322e538:	00000606 	br	322e554 <t_connect+0x58>
 322e53c:	e0fff917 	ldw	r3,-28(fp)
 322e540:	e0bffb17 	ldw	r2,-20(fp)
 322e544:	18800626 	beq	r3,r2,322e560 <t_connect+0x64>
 322e548:	e0bff917 	ldw	r2,-28(fp)
 322e54c:	10800017 	ldw	r2,0(r2)
 322e550:	e0bff915 	stw	r2,-28(fp)
 322e554:	e0bff917 	ldw	r2,-28(fp)
 322e558:	1004c03a 	cmpne	r2,r2,zero
 322e55c:	103ff71e 	bne	r2,zero,322e53c <t_connect+0x40>
 322e560:	e0fff917 	ldw	r3,-28(fp)
 322e564:	e0bffb17 	ldw	r2,-20(fp)
 322e568:	18800426 	beq	r3,r2,322e57c <t_connect+0x80>
 322e56c:	322aef00 	call	322aef0 <dtrap>
 322e570:	00bfffc4 	movi	r2,-1
 322e574:	e0bfff15 	stw	r2,-4(fp)
 322e578:	00008406 	br	322e78c <t_connect+0x290>
   DOMAIN_CHECK(so, addrlen);
 322e57c:	e13ffb17 	ldw	r4,-20(fp)
 322e580:	e17ffe17 	ldw	r5,-8(fp)
 322e584:	322df280 	call	322df28 <DOMAIN_CHECK>

#ifdef NB_CONNECT
   /* need to test non blocking connect bits in case this is a 
      poll of a previous request */
   if (so->so_state & SS_NBIO)
 322e588:	e0bffb17 	ldw	r2,-20(fp)
 322e58c:	1080088b 	ldhu	r2,34(r2)
 322e590:	10bfffcc 	andi	r2,r2,65535
 322e594:	1080400c 	andi	r2,r2,256
 322e598:	1005003a 	cmpeq	r2,r2,zero
 322e59c:	10002a1e 	bne	r2,zero,322e648 <t_connect+0x14c>
   {
      if (so->so_state & SS_ISCONNECTING) /* still trying */
 322e5a0:	e0bffb17 	ldw	r2,-20(fp)
 322e5a4:	1080088b 	ldhu	r2,34(r2)
 322e5a8:	10bfffcc 	andi	r2,r2,65535
 322e5ac:	1080010c 	andi	r2,r2,4
 322e5b0:	1005003a 	cmpeq	r2,r2,zero
 322e5b4:	1000061e 	bne	r2,zero,322e5d0 <t_connect+0xd4>
      {
         so->so_error = EINPROGRESS;
 322e5b8:	e0fffb17 	ldw	r3,-20(fp)
 322e5bc:	00801dc4 	movi	r2,119
 322e5c0:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 322e5c4:	00bfffc4 	movi	r2,-1
 322e5c8:	e0bfff15 	stw	r2,-4(fp)
 322e5cc:	00006f06 	br	322e78c <t_connect+0x290>
      }
      if (so->so_state & SS_ISCONNECTED)  /* connected OK */
 322e5d0:	e0bffb17 	ldw	r2,-20(fp)
 322e5d4:	1080088b 	ldhu	r2,34(r2)
 322e5d8:	10bfffcc 	andi	r2,r2,65535
 322e5dc:	1080008c 	andi	r2,r2,2
 322e5e0:	1005003a 	cmpeq	r2,r2,zero
 322e5e4:	1000041e 	bne	r2,zero,322e5f8 <t_connect+0xfc>
      {
         so->so_error = 0;
 322e5e8:	e0bffb17 	ldw	r2,-20(fp)
 322e5ec:	10000615 	stw	zero,24(r2)
         return 0;
 322e5f0:	e03fff15 	stw	zero,-4(fp)
 322e5f4:	00006506 	br	322e78c <t_connect+0x290>
      }
      if (so->so_state & SS_WASCONNECTING)
 322e5f8:	e0bffb17 	ldw	r2,-20(fp)
 322e5fc:	1080088b 	ldhu	r2,34(r2)
 322e600:	10bfffcc 	andi	r2,r2,65535
 322e604:	1088000c 	andi	r2,r2,8192
 322e608:	1005003a 	cmpeq	r2,r2,zero
 322e60c:	10000e1e 	bne	r2,zero,322e648 <t_connect+0x14c>
      {
         so->so_state &= ~SS_WASCONNECTING;
 322e610:	e0bffb17 	ldw	r2,-20(fp)
 322e614:	10c0088b 	ldhu	r3,34(r2)
 322e618:	00b7ffc4 	movi	r2,-8193
 322e61c:	1884703a 	and	r2,r3,r2
 322e620:	1007883a 	mov	r3,r2
 322e624:	e0bffb17 	ldw	r2,-20(fp)
 322e628:	10c0088d 	sth	r3,34(r2)
         if (so->so_error) /* connect error - maybe timeout */
 322e62c:	e0bffb17 	ldw	r2,-20(fp)
 322e630:	10800617 	ldw	r2,24(r2)
 322e634:	1005003a 	cmpeq	r2,r2,zero
 322e638:	1000031e 	bne	r2,zero,322e648 <t_connect+0x14c>
            return SOCKET_ERROR;
 322e63c:	00bfffc4 	movi	r2,-1
 322e640:	e0bfff15 	stw	r2,-4(fp)
 322e644:	00005106 	br	322e78c <t_connect+0x290>
      }
   }
#endif   /*  NB_CONNECT */

   so->so_error = 0;
 322e648:	e0bffb17 	ldw	r2,-20(fp)
 322e64c:	10000615 	stw	zero,24(r2)

   if ((nam = sockargs (addr, addrlen, MT_SONAME))
 322e650:	e13ffd17 	ldw	r4,-12(fp)
 322e654:	e17ffe17 	ldw	r5,-8(fp)
 322e658:	01800244 	movi	r6,9
 322e65c:	322f5f00 	call	322f5f0 <sockargs>
 322e660:	e0bffa15 	stw	r2,-24(fp)
 322e664:	e0bffa17 	ldw	r2,-24(fp)
 322e668:	1004c03a 	cmpne	r2,r2,zero
 322e66c:	1000061e 	bne	r2,zero,322e688 <t_connect+0x18c>
       == NULL)
   {
      so->so_error = ENOMEM;
 322e670:	e0fffb17 	ldw	r3,-20(fp)
 322e674:	00800304 	movi	r2,12
 322e678:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322e67c:	00bfffc4 	movi	r2,-1
 322e680:	e0bfff15 	stw	r2,-4(fp)
 322e684:	00004106 	br	322e78c <t_connect+0x290>
      INET_TRACE (INETM_SOCKET, ("INET: connect, port %d addr %lx\n",
       sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 322e688:	0009883a 	mov	r4,zero
 322e68c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   if ((so->so_error = soconnect (so, nam)) != 0)
 322e690:	e13ffb17 	ldw	r4,-20(fp)
 322e694:	e17ffa17 	ldw	r5,-24(fp)
 322e698:	322ff4c0 	call	322ff4c <soconnect>
 322e69c:	1007883a 	mov	r3,r2
 322e6a0:	e0bffb17 	ldw	r2,-20(fp)
 322e6a4:	10c00615 	stw	r3,24(r2)
 322e6a8:	e0bffb17 	ldw	r2,-20(fp)
 322e6ac:	10800617 	ldw	r2,24(r2)
 322e6b0:	1004c03a 	cmpne	r2,r2,zero
 322e6b4:	10001e1e 	bne	r2,zero,322e730 <t_connect+0x234>
      goto bad;

#ifdef NB_CONNECT
   /* need to test non blocking connect bits after soconnect() call */
   if ((so->so_state & SS_NBIO)&& (so->so_state & SS_ISCONNECTING))
 322e6b8:	e0bffb17 	ldw	r2,-20(fp)
 322e6bc:	1080088b 	ldhu	r2,34(r2)
 322e6c0:	10bfffcc 	andi	r2,r2,65535
 322e6c4:	1080400c 	andi	r2,r2,256
 322e6c8:	1005003a 	cmpeq	r2,r2,zero
 322e6cc:	10000e1e 	bne	r2,zero,322e708 <t_connect+0x20c>
 322e6d0:	e0bffb17 	ldw	r2,-20(fp)
 322e6d4:	1080088b 	ldhu	r2,34(r2)
 322e6d8:	10bfffcc 	andi	r2,r2,65535
 322e6dc:	1080010c 	andi	r2,r2,4
 322e6e0:	1005003a 	cmpeq	r2,r2,zero
 322e6e4:	1000081e 	bne	r2,zero,322e708 <t_connect+0x20c>
   {
      so->so_error = EINPROGRESS;
 322e6e8:	e0fffb17 	ldw	r3,-20(fp)
 322e6ec:	00801dc4 	movi	r2,119
 322e6f0:	18800615 	stw	r2,24(r3)
      goto bad;
 322e6f4:	00000e06 	br	322e730 <t_connect+0x234>
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
 322e6f8:	e0bffb17 	ldw	r2,-20(fp)
 322e6fc:	10800904 	addi	r2,r2,36
 322e700:	1009883a 	mov	r4,r2
 322e704:	3226ac40 	call	3226ac4 <tcp_sleep>
   }
#endif   /*  NB_CONNECT */
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
 322e708:	e0bffb17 	ldw	r2,-20(fp)
 322e70c:	1080088b 	ldhu	r2,34(r2)
 322e710:	10bfffcc 	andi	r2,r2,65535
 322e714:	1080010c 	andi	r2,r2,4
 322e718:	1005003a 	cmpeq	r2,r2,zero
 322e71c:	1000041e 	bne	r2,zero,322e730 <t_connect+0x234>
 322e720:	e0bffb17 	ldw	r2,-20(fp)
 322e724:	10800617 	ldw	r2,24(r2)
 322e728:	1005003a 	cmpeq	r2,r2,zero
 322e72c:	103ff21e 	bne	r2,zero,322e6f8 <t_connect+0x1fc>
   {
      tcp_sleep ((char *)&so->so_timeo);
   }
bad:
   if (so->so_error != EINPROGRESS)
 322e730:	e0bffb17 	ldw	r2,-20(fp)
 322e734:	10800617 	ldw	r2,24(r2)
 322e738:	10801de0 	cmpeqi	r2,r2,119
 322e73c:	1000071e 	bne	r2,zero,322e75c <t_connect+0x260>
      so->so_state &= ~(SS_ISCONNECTING|SS_WASCONNECTING);
 322e740:	e0bffb17 	ldw	r2,-20(fp)
 322e744:	10c0088b 	ldhu	r3,34(r2)
 322e748:	00b7fec4 	movi	r2,-8197
 322e74c:	1884703a 	and	r2,r3,r2
 322e750:	1007883a 	mov	r3,r2
 322e754:	e0bffb17 	ldw	r2,-20(fp)
 322e758:	10c0088d 	sth	r3,34(r2)
   m_freem (nam);
 322e75c:	e13ffa17 	ldw	r4,-24(fp)
 322e760:	322bfcc0 	call	322bfcc <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 322e764:	0009883a 	mov	r4,zero
 322e768:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   if (so->so_error)
 322e76c:	e0bffb17 	ldw	r2,-20(fp)
 322e770:	10800617 	ldw	r2,24(r2)
 322e774:	1005003a 	cmpeq	r2,r2,zero
 322e778:	1000031e 	bne	r2,zero,322e788 <t_connect+0x28c>
   {
/*      printf("t_connect(): so_error = %d\n", so->so_error);*/
      return SOCKET_ERROR;
 322e77c:	00bfffc4 	movi	r2,-1
 322e780:	e0bfff15 	stw	r2,-4(fp)
 322e784:	00000106 	br	322e78c <t_connect+0x290>

   }
      return 0;
 322e788:	e03fff15 	stw	zero,-4(fp)
 322e78c:	e0bfff17 	ldw	r2,-4(fp)
}
 322e790:	e037883a 	mov	sp,fp
 322e794:	dfc00117 	ldw	ra,4(sp)
 322e798:	df000017 	ldw	fp,0(sp)
 322e79c:	dec00204 	addi	sp,sp,8
 322e7a0:	f800283a 	ret

0322e7a4 <t_getpeername>:
 * RETURNS: 
 */

int
t_getpeername(long s, struct sockaddr * addr, int * addrlen)
{
 322e7a4:	defffb04 	addi	sp,sp,-20
 322e7a8:	dfc00415 	stw	ra,16(sp)
 322e7ac:	df000315 	stw	fp,12(sp)
 322e7b0:	df000304 	addi	fp,sp,12
 322e7b4:	e13ffd15 	stw	r4,-12(fp)
 322e7b8:	e17ffe15 	stw	r5,-8(fp)
 322e7bc:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_PEERADDR));
 322e7c0:	e13ffd17 	ldw	r4,-12(fp)
 322e7c4:	e17ffe17 	ldw	r5,-8(fp)
 322e7c8:	e1bfff17 	ldw	r6,-4(fp)
 322e7cc:	01c00404 	movi	r7,16
 322e7d0:	322e82c0 	call	322e82c <t_getname>
}
 322e7d4:	e037883a 	mov	sp,fp
 322e7d8:	dfc00117 	ldw	ra,4(sp)
 322e7dc:	df000017 	ldw	fp,0(sp)
 322e7e0:	dec00204 	addi	sp,sp,8
 322e7e4:	f800283a 	ret

0322e7e8 <t_getsockname>:
 * RETURNS: 
 */

int 
t_getsockname(long s, struct sockaddr * addr, int * addrlen)
{
 322e7e8:	defffb04 	addi	sp,sp,-20
 322e7ec:	dfc00415 	stw	ra,16(sp)
 322e7f0:	df000315 	stw	fp,12(sp)
 322e7f4:	df000304 	addi	fp,sp,12
 322e7f8:	e13ffd15 	stw	r4,-12(fp)
 322e7fc:	e17ffe15 	stw	r5,-8(fp)
 322e800:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_SOCKADDR));
 322e804:	e13ffd17 	ldw	r4,-12(fp)
 322e808:	e17ffe17 	ldw	r5,-8(fp)
 322e80c:	e1bfff17 	ldw	r6,-4(fp)
 322e810:	01c003c4 	movi	r7,15
 322e814:	322e82c0 	call	322e82c <t_getname>
}
 322e818:	e037883a 	mov	sp,fp
 322e81c:	dfc00117 	ldw	ra,4(sp)
 322e820:	df000017 	ldw	fp,0(sp)
 322e824:	dec00204 	addi	sp,sp,8
 322e828:	f800283a 	ret

0322e82c <t_getname>:
 * RETURNS: 
 */

static int
t_getname(long s, struct sockaddr * addr, int * addrlen, int opcode)
{
 322e82c:	defff504 	addi	sp,sp,-44
 322e830:	dfc00a15 	stw	ra,40(sp)
 322e834:	df000915 	stw	fp,36(sp)
 322e838:	df000904 	addi	fp,sp,36
 322e83c:	e13ffb15 	stw	r4,-20(fp)
 322e840:	e17ffc15 	stw	r5,-16(fp)
 322e844:	e1bffd15 	stw	r6,-12(fp)
 322e848:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   struct mbuf *  m;
   int   err;

   so = LONG2SO(s);
 322e84c:	e0bffb17 	ldw	r2,-20(fp)
 322e850:	10bff804 	addi	r2,r2,-32
 322e854:	1085883a 	add	r2,r2,r2
 322e858:	1085883a 	add	r2,r2,r2
 322e85c:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 322e860:	0080c9b4 	movhi	r2,806
 322e864:	10b48204 	addi	r2,r2,-11768
 322e868:	e0bff715 	stw	r2,-36(fp)
 322e86c:	00000606 	br	322e888 <t_getname+0x5c>
 322e870:	e0fff717 	ldw	r3,-36(fp)
 322e874:	e0bffa17 	ldw	r2,-24(fp)
 322e878:	18800626 	beq	r3,r2,322e894 <t_getname+0x68>
 322e87c:	e0bff717 	ldw	r2,-36(fp)
 322e880:	10800017 	ldw	r2,0(r2)
 322e884:	e0bff715 	stw	r2,-36(fp)
 322e888:	e0bff717 	ldw	r2,-36(fp)
 322e88c:	1004c03a 	cmpne	r2,r2,zero
 322e890:	103ff71e 	bne	r2,zero,322e870 <t_getname+0x44>
 322e894:	e0fff717 	ldw	r3,-36(fp)
 322e898:	e0bffa17 	ldw	r2,-24(fp)
 322e89c:	18800426 	beq	r3,r2,322e8b0 <t_getname+0x84>
 322e8a0:	322aef00 	call	322aef0 <dtrap>
 322e8a4:	00bfffc4 	movi	r2,-1
 322e8a8:	e0bfff15 	stw	r2,-4(fp)
 322e8ac:	00005806 	br	322ea10 <t_getname+0x1e4>

   so->so_error = 0;
 322e8b0:	e0bffa17 	ldw	r2,-24(fp)
 322e8b4:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:get[sock|peer]name so %x\n", so));
   if((opcode == PRU_PEERADDR) && (so->so_state & SS_ISCONNECTED) == 0)
 322e8b8:	e0bffe17 	ldw	r2,-8(fp)
 322e8bc:	10800418 	cmpnei	r2,r2,16
 322e8c0:	10000c1e 	bne	r2,zero,322e8f4 <t_getname+0xc8>
 322e8c4:	e0bffa17 	ldw	r2,-24(fp)
 322e8c8:	1080088b 	ldhu	r2,34(r2)
 322e8cc:	10bfffcc 	andi	r2,r2,65535
 322e8d0:	1080008c 	andi	r2,r2,2
 322e8d4:	1004c03a 	cmpne	r2,r2,zero
 322e8d8:	1000061e 	bne	r2,zero,322e8f4 <t_getname+0xc8>
   {
      so->so_error = ENOTCONN;
 322e8dc:	e0fffa17 	ldw	r3,-24(fp)
 322e8e0:	00802004 	movi	r2,128
 322e8e4:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322e8e8:	00bfffc4 	movi	r2,-1
 322e8ec:	e0bfff15 	stw	r2,-4(fp)
 322e8f0:	00004706 	br	322ea10 <t_getname+0x1e4>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 322e8f4:	0009883a 	mov	r4,zero
 322e8f8:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 322e8fc:	01000244 	movi	r4,9
 322e900:	01400404 	movi	r5,16
 322e904:	322bcf00 	call	322bcf0 <m_getnbuf>
 322e908:	e0bff915 	stw	r2,-28(fp)
   if (m == NULL) 
 322e90c:	e0bff917 	ldw	r2,-28(fp)
 322e910:	1004c03a 	cmpne	r2,r2,zero
 322e914:	1000081e 	bne	r2,zero,322e938 <t_getname+0x10c>
   {
      so->so_error = ENOMEM;
 322e918:	e0fffa17 	ldw	r3,-24(fp)
 322e91c:	00800304 	movi	r2,12
 322e920:	18800615 	stw	r2,24(r3)
      UNLOCK_NET_RESOURCE(NET_RESID);
 322e924:	0009883a 	mov	r4,zero
 322e928:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 322e92c:	00bfffc4 	movi	r2,-1
 322e930:	e0bfff15 	stw	r2,-4(fp)
 322e934:	00003606 	br	322ea10 <t_getname+0x1e4>
   }
   so->so_req = opcode;
 322e938:	e0fffa17 	ldw	r3,-24(fp)
 322e93c:	e0bffe17 	ldw	r2,-8(fp)
 322e940:	18800715 	stw	r2,28(r3)
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
 322e944:	e0bffa17 	ldw	r2,-24(fp)
 322e948:	10800217 	ldw	r2,8(r2)
 322e94c:	10800317 	ldw	r2,12(r2)
 322e950:	e13ffa17 	ldw	r4,-24(fp)
 322e954:	000b883a 	mov	r5,zero
 322e958:	e1bff917 	ldw	r6,-28(fp)
 322e95c:	103ee83a 	callr	r2
 322e960:	e0bff815 	stw	r2,-32(fp)
 322e964:	e0bff817 	ldw	r2,-32(fp)
 322e968:	1004c03a 	cmpne	r2,r2,zero
 322e96c:	10001a1e 	bne	r2,zero,322e9d8 <t_getname+0x1ac>
      goto bad;

#ifdef IP_V4
   if(so->so_domain == AF_INET)
 322e970:	e0bffa17 	ldw	r2,-24(fp)
 322e974:	10800517 	ldw	r2,20(r2)
 322e978:	10800098 	cmpnei	r2,r2,2
 322e97c:	1000161e 	bne	r2,zero,322e9d8 <t_getname+0x1ac>
   {
      if(*addrlen < sizeof(struct sockaddr_in))
 322e980:	e0bffd17 	ldw	r2,-12(fp)
 322e984:	10800017 	ldw	r2,0(r2)
 322e988:	10800428 	cmpgeui	r2,r2,16
 322e98c:	1000081e 	bne	r2,zero,322e9b0 <t_getname+0x184>
      {
         dtrap();    /* programming error */
 322e990:	322aef00 	call	322aef0 <dtrap>
         m_freem(m);
 322e994:	e13ff917 	ldw	r4,-28(fp)
 322e998:	322bfcc0 	call	322bfcc <m_freem>
         UNLOCK_NET_RESOURCE(NET_RESID);
 322e99c:	0009883a 	mov	r4,zero
 322e9a0:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         return EINVAL;
 322e9a4:	00800584 	movi	r2,22
 322e9a8:	e0bfff15 	stw	r2,-4(fp)
 322e9ac:	00001806 	br	322ea10 <t_getname+0x1e4>
      }
      MEMCPY(addr, m->m_data, sizeof(struct sockaddr_in));
 322e9b0:	e0bff917 	ldw	r2,-28(fp)
 322e9b4:	10c00317 	ldw	r3,12(r2)
 322e9b8:	e0bffc17 	ldw	r2,-16(fp)
 322e9bc:	1009883a 	mov	r4,r2
 322e9c0:	180b883a 	mov	r5,r3
 322e9c4:	01800404 	movi	r6,16
 322e9c8:	3206ad00 	call	3206ad0 <memcpy>
      *addrlen = sizeof(struct sockaddr_in);
 322e9cc:	e0fffd17 	ldw	r3,-12(fp)
 322e9d0:	00800404 	movi	r2,16
 322e9d4:	18800015 	stw	r2,0(r3)
   }
#endif   /* IP_V6 */


bad:
   m_freem(m);
 322e9d8:	e13ff917 	ldw	r4,-28(fp)
 322e9dc:	322bfcc0 	call	322bfcc <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 322e9e0:	0009883a 	mov	r4,zero
 322e9e4:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   if (err) 
 322e9e8:	e0bff817 	ldw	r2,-32(fp)
 322e9ec:	1005003a 	cmpeq	r2,r2,zero
 322e9f0:	1000061e 	bne	r2,zero,322ea0c <t_getname+0x1e0>
   {
      so->so_error = err;
 322e9f4:	e0fffa17 	ldw	r3,-24(fp)
 322e9f8:	e0bff817 	ldw	r2,-32(fp)
 322e9fc:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322ea00:	00bfffc4 	movi	r2,-1
 322ea04:	e0bfff15 	stw	r2,-4(fp)
 322ea08:	00000106 	br	322ea10 <t_getname+0x1e4>
   }
   return 0;
 322ea0c:	e03fff15 	stw	zero,-4(fp)
 322ea10:	e0bfff17 	ldw	r2,-4(fp)
}
 322ea14:	e037883a 	mov	sp,fp
 322ea18:	dfc00117 	ldw	ra,4(sp)
 322ea1c:	df000017 	ldw	fp,0(sp)
 322ea20:	dec00204 	addi	sp,sp,8
 322ea24:	f800283a 	ret

0322ea28 <t_setsockopt>:
t_setsockopt(long s,
   int   level,
   int   name,
   void * arg,
   int arglen)
{
 322ea28:	defff604 	addi	sp,sp,-40
 322ea2c:	dfc00915 	stw	ra,36(sp)
 322ea30:	df000815 	stw	fp,32(sp)
 322ea34:	df000804 	addi	fp,sp,32
 322ea38:	e13ffb15 	stw	r4,-20(fp)
 322ea3c:	e17ffc15 	stw	r5,-16(fp)
 322ea40:	e1bffd15 	stw	r6,-12(fp)
 322ea44:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 322ea48:	e0bffb17 	ldw	r2,-20(fp)
 322ea4c:	10bff804 	addi	r2,r2,-32
 322ea50:	1085883a 	add	r2,r2,r2
 322ea54:	1085883a 	add	r2,r2,r2
 322ea58:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 322ea5c:	0080c9b4 	movhi	r2,806
 322ea60:	10b48204 	addi	r2,r2,-11768
 322ea64:	e0bff815 	stw	r2,-32(fp)
 322ea68:	00000606 	br	322ea84 <t_setsockopt+0x5c>
 322ea6c:	e0fff817 	ldw	r3,-32(fp)
 322ea70:	e0bffa17 	ldw	r2,-24(fp)
 322ea74:	18800626 	beq	r3,r2,322ea90 <t_setsockopt+0x68>
 322ea78:	e0bff817 	ldw	r2,-32(fp)
 322ea7c:	10800017 	ldw	r2,0(r2)
 322ea80:	e0bff815 	stw	r2,-32(fp)
 322ea84:	e0bff817 	ldw	r2,-32(fp)
 322ea88:	1004c03a 	cmpne	r2,r2,zero
 322ea8c:	103ff71e 	bne	r2,zero,322ea6c <t_setsockopt+0x44>
 322ea90:	e0fff817 	ldw	r3,-32(fp)
 322ea94:	e0bffa17 	ldw	r2,-24(fp)
 322ea98:	18800426 	beq	r3,r2,322eaac <t_setsockopt+0x84>
 322ea9c:	322aef00 	call	322aef0 <dtrap>
 322eaa0:	00bfffc4 	movi	r2,-1
 322eaa4:	e0bfff15 	stw	r2,-4(fp)
 322eaa8:	00005006 	br	322ebec <t_setsockopt+0x1c4>
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 322eaac:	0009883a 	mov	r4,zero
 322eab0:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>

   so->so_error = 0;
 322eab4:	e0bffa17 	ldw	r2,-24(fp)
 322eab8:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
    ("INET: setsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 322eabc:	e0bffc17 	ldw	r2,-16(fp)
 322eac0:	10800060 	cmpeqi	r2,r2,1
 322eac4:	1000101e 	bne	r2,zero,322eb08 <t_setsockopt+0xe0>
   {
      if ((err = sosetopt (so, name, arg)) != 0) 
 322eac8:	e13ffa17 	ldw	r4,-24(fp)
 322eacc:	e17ffd17 	ldw	r5,-12(fp)
 322ead0:	e1bffe17 	ldw	r6,-8(fp)
 322ead4:	32310540 	call	3231054 <sosetopt>
 322ead8:	e0bff915 	stw	r2,-28(fp)
 322eadc:	e0bff917 	ldw	r2,-28(fp)
 322eae0:	1005003a 	cmpeq	r2,r2,zero
 322eae4:	10003e1e 	bne	r2,zero,322ebe0 <t_setsockopt+0x1b8>
      {
         so->so_error = err;
 322eae8:	e0fffa17 	ldw	r3,-24(fp)
 322eaec:	e0bff917 	ldw	r2,-28(fp)
 322eaf0:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE (NET_RESID);
 322eaf4:	0009883a 	mov	r4,zero
 322eaf8:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 322eafc:	00bfffc4 	movi	r2,-1
 322eb00:	e0bfff15 	stw	r2,-4(fp)
 322eb04:	00003906 	br	322ebec <t_setsockopt+0x1c4>
   {
   /* level 1 options are for the IP packet level.
    * the info is carried in the socket CB, then put 
    * into the PACKET.
    */
      if (!so->so_optsPack)
 322eb08:	e0bffa17 	ldw	r2,-24(fp)
 322eb0c:	10801f17 	ldw	r2,124(r2)
 322eb10:	1004c03a 	cmpne	r2,r2,zero
 322eb14:	1000111e 	bne	r2,zero,322eb5c <t_setsockopt+0x134>
      {
         so->so_optsPack = (struct ip_socopts *) SOCOPT_ALLOC (sizeof(struct ip_socopts *));
 322eb18:	01000104 	movi	r4,4
 322eb1c:	322b9340 	call	322b934 <npalloc>
 322eb20:	1007883a 	mov	r3,r2
 322eb24:	e0bffa17 	ldw	r2,-24(fp)
 322eb28:	10c01f15 	stw	r3,124(r2)
         if (!so->so_optsPack) 
 322eb2c:	e0bffa17 	ldw	r2,-24(fp)
 322eb30:	10801f17 	ldw	r2,124(r2)
 322eb34:	1004c03a 	cmpne	r2,r2,zero
 322eb38:	1000081e 	bne	r2,zero,322eb5c <t_setsockopt+0x134>
         {
            so->so_error = ENOMEM;
 322eb3c:	e0fffa17 	ldw	r3,-24(fp)
 322eb40:	00800304 	movi	r2,12
 322eb44:	18800615 	stw	r2,24(r3)
            UNLOCK_NET_RESOURCE (NET_RESID);
 322eb48:	0009883a 	mov	r4,zero
 322eb4c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
            return SOCKET_ERROR;
 322eb50:	00bfffc4 	movi	r2,-1
 322eb54:	e0bfff15 	stw	r2,-4(fp)
 322eb58:	00002406 	br	322ebec <t_setsockopt+0x1c4>
         }
      }
      
      if (name == IP_TTL_OPT)
 322eb5c:	e0bffd17 	ldw	r2,-12(fp)
 322eb60:	10800118 	cmpnei	r2,r2,4
 322eb64:	1000061e 	bne	r2,zero,322eb80 <t_setsockopt+0x158>
         so->so_optsPack->ip_ttl = (u_char)(*(int *)arg);
 322eb68:	e0bffa17 	ldw	r2,-24(fp)
 322eb6c:	10c01f17 	ldw	r3,124(r2)
 322eb70:	e0bffe17 	ldw	r2,-8(fp)
 322eb74:	10800017 	ldw	r2,0(r2)
 322eb78:	18800045 	stb	r2,1(r3)
 322eb7c:	00001806 	br	322ebe0 <t_setsockopt+0x1b8>
      else
      if (name == IP_TOS)
 322eb80:	e0bffd17 	ldw	r2,-12(fp)
 322eb84:	108000d8 	cmpnei	r2,r2,3
 322eb88:	1000061e 	bne	r2,zero,322eba4 <t_setsockopt+0x17c>
         so->so_optsPack->ip_tos = (u_char)(*(int *)arg);
 322eb8c:	e0bffa17 	ldw	r2,-24(fp)
 322eb90:	10c01f17 	ldw	r3,124(r2)
 322eb94:	e0bffe17 	ldw	r2,-8(fp)
 322eb98:	10800017 	ldw	r2,0(r2)
 322eb9c:	18800005 	stb	r2,0(r3)
 322eba0:	00000f06 	br	322ebe0 <t_setsockopt+0x1b8>
	   else
	   if (name == IP_SCOPEID)
 322eba4:	e0bffd17 	ldw	r2,-12(fp)
 322eba8:	10800398 	cmpnei	r2,r2,14
 322ebac:	1000071e 	bne	r2,zero,322ebcc <t_setsockopt+0x1a4>
            so->so_optsPack->ip_scopeid = (u_char)(*(u_int *)arg);
 322ebb0:	e0bffa17 	ldw	r2,-24(fp)
 322ebb4:	10c01f17 	ldw	r3,124(r2)
 322ebb8:	e0bffe17 	ldw	r2,-8(fp)
 322ebbc:	10800017 	ldw	r2,0(r2)
 322ebc0:	10803fcc 	andi	r2,r2,255
 322ebc4:	18800115 	stw	r2,4(r3)
 322ebc8:	00000506 	br	322ebe0 <t_setsockopt+0x1b8>
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 322ebcc:	0009883a 	mov	r4,zero
 322ebd0:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 322ebd4:	00bfffc4 	movi	r2,-1
 322ebd8:	e0bfff15 	stw	r2,-4(fp)
 322ebdc:	00000306 	br	322ebec <t_setsockopt+0x1c4>
      }   
   }

   UNLOCK_NET_RESOURCE (NET_RESID);
 322ebe0:	0009883a 	mov	r4,zero
 322ebe4:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   return 0;
 322ebe8:	e03fff15 	stw	zero,-4(fp)
 322ebec:	e0bfff17 	ldw	r2,-4(fp)
}
 322ebf0:	e037883a 	mov	sp,fp
 322ebf4:	dfc00117 	ldw	ra,4(sp)
 322ebf8:	df000017 	ldw	fp,0(sp)
 322ebfc:	dec00204 	addi	sp,sp,8
 322ec00:	f800283a 	ret

0322ec04 <t_getsockopt>:
   int   level,
   int   name,
   void *   arg,
   int   arglen)

{
 322ec04:	defff604 	addi	sp,sp,-40
 322ec08:	dfc00915 	stw	ra,36(sp)
 322ec0c:	df000815 	stw	fp,32(sp)
 322ec10:	df000804 	addi	fp,sp,32
 322ec14:	e13ffb15 	stw	r4,-20(fp)
 322ec18:	e17ffc15 	stw	r5,-16(fp)
 322ec1c:	e1bffd15 	stw	r6,-12(fp)
 322ec20:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 322ec24:	e0bffb17 	ldw	r2,-20(fp)
 322ec28:	10bff804 	addi	r2,r2,-32
 322ec2c:	1085883a 	add	r2,r2,r2
 322ec30:	1085883a 	add	r2,r2,r2
 322ec34:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 322ec38:	0080c9b4 	movhi	r2,806
 322ec3c:	10b48204 	addi	r2,r2,-11768
 322ec40:	e0bff815 	stw	r2,-32(fp)
 322ec44:	00000606 	br	322ec60 <t_getsockopt+0x5c>
 322ec48:	e0fff817 	ldw	r3,-32(fp)
 322ec4c:	e0bffa17 	ldw	r2,-24(fp)
 322ec50:	18800626 	beq	r3,r2,322ec6c <t_getsockopt+0x68>
 322ec54:	e0bff817 	ldw	r2,-32(fp)
 322ec58:	10800017 	ldw	r2,0(r2)
 322ec5c:	e0bff815 	stw	r2,-32(fp)
 322ec60:	e0bff817 	ldw	r2,-32(fp)
 322ec64:	1004c03a 	cmpne	r2,r2,zero
 322ec68:	103ff71e 	bne	r2,zero,322ec48 <t_getsockopt+0x44>
 322ec6c:	e0fff817 	ldw	r3,-32(fp)
 322ec70:	e0bffa17 	ldw	r2,-24(fp)
 322ec74:	18800426 	beq	r3,r2,322ec88 <t_getsockopt+0x84>
 322ec78:	322aef00 	call	322aef0 <dtrap>
 322ec7c:	00bfffc4 	movi	r2,-1
 322ec80:	e0bfff15 	stw	r2,-4(fp)
 322ec84:	00004206 	br	322ed90 <t_getsockopt+0x18c>
   USE_ARG(level);
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 322ec88:	0009883a 	mov	r4,zero
 322ec8c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   INET_TRACE (INETM_SOCKET,
    ("INET: getsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 322ec90:	e0bffc17 	ldw	r2,-16(fp)
 322ec94:	10800060 	cmpeqi	r2,r2,1
 322ec98:	1000101e 	bne	r2,zero,322ecdc <t_getsockopt+0xd8>
   {
      if ((err = sogetopt (so, name, arg)) != 0) 
 322ec9c:	e13ffa17 	ldw	r4,-24(fp)
 322eca0:	e17ffd17 	ldw	r5,-12(fp)
 322eca4:	e1bffe17 	ldw	r6,-8(fp)
 322eca8:	32315140 	call	3231514 <sogetopt>
 322ecac:	e0bff915 	stw	r2,-28(fp)
 322ecb0:	e0bff917 	ldw	r2,-28(fp)
 322ecb4:	1005003a 	cmpeq	r2,r2,zero
 322ecb8:	1000301e 	bne	r2,zero,322ed7c <t_getsockopt+0x178>
      {
         so->so_error = err;
 322ecbc:	e0fffa17 	ldw	r3,-24(fp)
 322ecc0:	e0bff917 	ldw	r2,-28(fp)
 322ecc4:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE (NET_RESID);
 322ecc8:	0009883a 	mov	r4,zero
 322eccc:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 322ecd0:	00bfffc4 	movi	r2,-1
 322ecd4:	e0bfff15 	stw	r2,-4(fp)
 322ecd8:	00002d06 	br	322ed90 <t_getsockopt+0x18c>
   {
      /* level 1 options are for the IP packet level.
       * the info is carried in the socket CB, then put 
       * into the PACKET.
       */
      if (name == IP_TTL_OPT)
 322ecdc:	e0bffd17 	ldw	r2,-12(fp)
 322ece0:	10800118 	cmpnei	r2,r2,4
 322ece4:	10000f1e 	bne	r2,zero,322ed24 <t_getsockopt+0x120>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TTL;
 322ece8:	e0bffa17 	ldw	r2,-24(fp)
 322ecec:	10801f17 	ldw	r2,124(r2)
 322ecf0:	1004c03a 	cmpne	r2,r2,zero
 322ecf4:	1000041e 	bne	r2,zero,322ed08 <t_getsockopt+0x104>
 322ecf8:	e0fffe17 	ldw	r3,-8(fp)
 322ecfc:	00801004 	movi	r2,64
 322ed00:	18800015 	stw	r2,0(r3)
 322ed04:	00001d06 	br	322ed7c <t_getsockopt+0x178>
         else *(int *)arg = (int)so->so_optsPack->ip_ttl;
 322ed08:	e0fffe17 	ldw	r3,-8(fp)
 322ed0c:	e0bffa17 	ldw	r2,-24(fp)
 322ed10:	10801f17 	ldw	r2,124(r2)
 322ed14:	10800043 	ldbu	r2,1(r2)
 322ed18:	10803fcc 	andi	r2,r2,255
 322ed1c:	18800015 	stw	r2,0(r3)
 322ed20:	00001606 	br	322ed7c <t_getsockopt+0x178>
      }
      else if (name == IP_TOS)
 322ed24:	e0bffd17 	ldw	r2,-12(fp)
 322ed28:	108000d8 	cmpnei	r2,r2,3
 322ed2c:	10000e1e 	bne	r2,zero,322ed68 <t_getsockopt+0x164>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TOS_DEFVAL;
 322ed30:	e0bffa17 	ldw	r2,-24(fp)
 322ed34:	10801f17 	ldw	r2,124(r2)
 322ed38:	1004c03a 	cmpne	r2,r2,zero
 322ed3c:	1000031e 	bne	r2,zero,322ed4c <t_getsockopt+0x148>
 322ed40:	e0bffe17 	ldw	r2,-8(fp)
 322ed44:	10000015 	stw	zero,0(r2)
 322ed48:	00000c06 	br	322ed7c <t_getsockopt+0x178>
         else *(int *)arg = (int)so->so_optsPack->ip_tos;
 322ed4c:	e0fffe17 	ldw	r3,-8(fp)
 322ed50:	e0bffa17 	ldw	r2,-24(fp)
 322ed54:	10801f17 	ldw	r2,124(r2)
 322ed58:	10800003 	ldbu	r2,0(r2)
 322ed5c:	10803fcc 	andi	r2,r2,255
 322ed60:	18800015 	stw	r2,0(r3)
 322ed64:	00000506 	br	322ed7c <t_getsockopt+0x178>
      }
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 322ed68:	0009883a 	mov	r4,zero
 322ed6c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 322ed70:	00bfffc4 	movi	r2,-1
 322ed74:	e0bfff15 	stw	r2,-4(fp)
 322ed78:	00000506 	br	322ed90 <t_getsockopt+0x18c>
      }
   }   
   so->so_error = 0;
 322ed7c:	e0bffa17 	ldw	r2,-24(fp)
 322ed80:	10000615 	stw	zero,24(r2)

   UNLOCK_NET_RESOURCE (NET_RESID);
 322ed84:	0009883a 	mov	r4,zero
 322ed88:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   return 0;
 322ed8c:	e03fff15 	stw	zero,-4(fp)
 322ed90:	e0bfff17 	ldw	r2,-4(fp)
}
 322ed94:	e037883a 	mov	sp,fp
 322ed98:	dfc00117 	ldw	ra,4(sp)
 322ed9c:	df000017 	ldw	fp,0(sp)
 322eda0:	dec00204 	addi	sp,sp,8
 322eda4:	f800283a 	ret

0322eda8 <t_recv>:
int
t_recv (long s, 
   char *   buf,
   int   len, 
   int   flag)
{
 322eda8:	defff504 	addi	sp,sp,-44
 322edac:	dfc00a15 	stw	ra,40(sp)
 322edb0:	df000915 	stw	fp,36(sp)
 322edb4:	df000904 	addi	fp,sp,36
 322edb8:	e13ffb15 	stw	r4,-20(fp)
 322edbc:	e17ffc15 	stw	r5,-16(fp)
 322edc0:	e1bffd15 	stw	r6,-12(fp)
 322edc4:	e1fffe15 	stw	r7,-8(fp)
#ifdef SOCKDEBUG
   char logbuf[10];
#endif
   struct socket *   so;
   int   err;
   int   sendlen = len;
 322edc8:	e0bffd17 	ldw	r2,-12(fp)
 322edcc:	e0bff815 	stw	r2,-32(fp)

   so = LONG2SO(s);
 322edd0:	e0bffb17 	ldw	r2,-20(fp)
 322edd4:	10bff804 	addi	r2,r2,-32
 322edd8:	1085883a 	add	r2,r2,r2
 322eddc:	1085883a 	add	r2,r2,r2
 322ede0:	e0bffa15 	stw	r2,-24(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 322ede4:	e0bffa17 	ldw	r2,-24(fp)
 322ede8:	1080088b 	ldhu	r2,34(r2)
 322edec:	10bfffcc 	andi	r2,r2,65535
 322edf0:	1080038c 	andi	r2,r2,14
 322edf4:	108000a0 	cmpeqi	r2,r2,2
 322edf8:	1000061e 	bne	r2,zero,322ee14 <t_recv+0x6c>
   {
      so->so_error = EPIPE;
 322edfc:	e0fffa17 	ldw	r3,-24(fp)
 322ee00:	00800804 	movi	r2,32
 322ee04:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 322ee08:	00bfffc4 	movi	r2,-1
 322ee0c:	e0bfff15 	stw	r2,-4(fp)
 322ee10:	00001b06 	br	322ee80 <t_recv+0xd8>
   }
   so->so_error = 0;
 322ee14:	e0bffa17 	ldw	r2,-24(fp)
 322ee18:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 322ee1c:	0009883a 	mov	r4,zero
 322ee20:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   IN_PROFILER(PF_TCP, PF_ENTRY);        /* measure time in TCP */
   INET_TRACE (INETM_IO, ("INET:recv: so %x, len %d\n", so, len));
   err = soreceive(so, NULL, buf, &len, flag);
 322ee24:	e1fffd04 	addi	r7,fp,-12
 322ee28:	e0bffe17 	ldw	r2,-8(fp)
 322ee2c:	d8800015 	stw	r2,0(sp)
 322ee30:	e13ffa17 	ldw	r4,-24(fp)
 322ee34:	000b883a 	mov	r5,zero
 322ee38:	e1bffc17 	ldw	r6,-16(fp)
 322ee3c:	32306c80 	call	32306c8 <soreceive>
 322ee40:	e0bff915 	stw	r2,-28(fp)
   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   UNLOCK_NET_RESOURCE(NET_RESID);
 322ee44:	0009883a 	mov	r4,zero
 322ee48:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   if(err)
 322ee4c:	e0bff917 	ldw	r2,-28(fp)
 322ee50:	1005003a 	cmpeq	r2,r2,zero
 322ee54:	1000061e 	bne	r2,zero,322ee70 <t_recv+0xc8>
   {
      so->so_error = err;
 322ee58:	e0fffa17 	ldw	r3,-24(fp)
 322ee5c:	e0bff917 	ldw	r2,-28(fp)
 322ee60:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 322ee64:	00bfffc4 	movi	r2,-1
 322ee68:	e0bfff15 	stw	r2,-4(fp)
 322ee6c:	00000406 	br	322ee80 <t_recv+0xd8>
   }

   /* return bytes we sent - the amount we wanted to send minus
    * the amount left in the buffer.
    */
   return (sendlen - len);
 322ee70:	e0fffd17 	ldw	r3,-12(fp)
 322ee74:	e0bff817 	ldw	r2,-32(fp)
 322ee78:	10c5c83a 	sub	r2,r2,r3
 322ee7c:	e0bfff15 	stw	r2,-4(fp)
 322ee80:	e0bfff17 	ldw	r2,-4(fp)
}
 322ee84:	e037883a 	mov	sp,fp
 322ee88:	dfc00117 	ldw	ra,4(sp)
 322ee8c:	df000017 	ldw	fp,0(sp)
 322ee90:	dec00204 	addi	sp,sp,8
 322ee94:	f800283a 	ret

0322ee98 <t_recvfrom>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * from,
   int * fromlen)
{
 322ee98:	defff304 	addi	sp,sp,-52
 322ee9c:	dfc00c15 	stw	ra,48(sp)
 322eea0:	df000b15 	stw	fp,44(sp)
 322eea4:	df000b04 	addi	fp,sp,44
 322eea8:	e13ffb15 	stw	r4,-20(fp)
 322eeac:	e17ffc15 	stw	r5,-16(fp)
 322eeb0:	e1bffd15 	stw	r6,-12(fp)
 322eeb4:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   struct mbuf *     sender = NULL;
 322eeb8:	e03ffa15 	stw	zero,-24(fp)
   int   err;
   int   sendlen = len;
 322eebc:	e0bffd17 	ldw	r2,-12(fp)
 322eec0:	e0bff715 	stw	r2,-36(fp)

   so = LONG2SO(s);
 322eec4:	e0bffb17 	ldw	r2,-20(fp)
 322eec8:	10bff804 	addi	r2,r2,-32
 322eecc:	1085883a 	add	r2,r2,r2
 322eed0:	1085883a 	add	r2,r2,r2
 322eed4:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 322eed8:	0080c9b4 	movhi	r2,806
 322eedc:	10b48204 	addi	r2,r2,-11768
 322eee0:	e0bff615 	stw	r2,-40(fp)
 322eee4:	00000606 	br	322ef00 <t_recvfrom+0x68>
 322eee8:	e0fff617 	ldw	r3,-40(fp)
 322eeec:	e0bff917 	ldw	r2,-28(fp)
 322eef0:	18800626 	beq	r3,r2,322ef0c <t_recvfrom+0x74>
 322eef4:	e0bff617 	ldw	r2,-40(fp)
 322eef8:	10800017 	ldw	r2,0(r2)
 322eefc:	e0bff615 	stw	r2,-40(fp)
 322ef00:	e0bff617 	ldw	r2,-40(fp)
 322ef04:	1004c03a 	cmpne	r2,r2,zero
 322ef08:	103ff71e 	bne	r2,zero,322eee8 <t_recvfrom+0x50>
 322ef0c:	e0fff617 	ldw	r3,-40(fp)
 322ef10:	e0bff917 	ldw	r2,-28(fp)
 322ef14:	18800426 	beq	r3,r2,322ef28 <t_recvfrom+0x90>
 322ef18:	322aef00 	call	322aef0 <dtrap>
 322ef1c:	00bfffc4 	movi	r2,-1
 322ef20:	e0bfff15 	stw	r2,-4(fp)
 322ef24:	00002a06 	br	322efd0 <t_recvfrom+0x138>
   so->so_error = 0;
 322ef28:	e0bff917 	ldw	r2,-28(fp)
 322ef2c:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 322ef30:	0009883a 	mov	r4,zero
 322ef34:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>

   err = soreceive(so, &sender, buf, &len, flags);
 322ef38:	e17ffa04 	addi	r5,fp,-24
 322ef3c:	e1fffd04 	addi	r7,fp,-12
 322ef40:	e0bffe17 	ldw	r2,-8(fp)
 322ef44:	d8800015 	stw	r2,0(sp)
 322ef48:	e13ff917 	ldw	r4,-28(fp)
 322ef4c:	e1bffc17 	ldw	r6,-16(fp)
 322ef50:	32306c80 	call	32306c8 <soreceive>
 322ef54:	e0bff815 	stw	r2,-32(fp)

   /* copy sender info from mbuf to sockaddr */
   if (sender)
 322ef58:	e0bffa17 	ldw	r2,-24(fp)
 322ef5c:	1005003a 	cmpeq	r2,r2,zero
 322ef60:	10000c1e 	bne	r2,zero,322ef94 <t_recvfrom+0xfc>
   {
      MEMCPY(from, (mtod(sender, struct sockaddr *)), *fromlen );
 322ef64:	e0bffa17 	ldw	r2,-24(fp)
 322ef68:	10800317 	ldw	r2,12(r2)
 322ef6c:	100b883a 	mov	r5,r2
 322ef70:	e0800317 	ldw	r2,12(fp)
 322ef74:	10800017 	ldw	r2,0(r2)
 322ef78:	1007883a 	mov	r3,r2
 322ef7c:	e0800217 	ldw	r2,8(fp)
 322ef80:	1009883a 	mov	r4,r2
 322ef84:	180d883a 	mov	r6,r3
 322ef88:	3206ad00 	call	3206ad0 <memcpy>
      m_freem (sender);
 322ef8c:	e13ffa17 	ldw	r4,-24(fp)
 322ef90:	322bfcc0 	call	322bfcc <m_freem>
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 322ef94:	0009883a 	mov	r4,zero
 322ef98:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   if(err)
 322ef9c:	e0bff817 	ldw	r2,-32(fp)
 322efa0:	1005003a 	cmpeq	r2,r2,zero
 322efa4:	1000061e 	bne	r2,zero,322efc0 <t_recvfrom+0x128>
   {
      so->so_error = err;
 322efa8:	e0fff917 	ldw	r3,-28(fp)
 322efac:	e0bff817 	ldw	r2,-32(fp)
 322efb0:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322efb4:	00bfffc4 	movi	r2,-1
 322efb8:	e0bfff15 	stw	r2,-4(fp)
 322efbc:	00000406 	br	322efd0 <t_recvfrom+0x138>
   }

   /* OK return: amount of data actually sent */
   return (sendlen - len);
 322efc0:	e0fffd17 	ldw	r3,-12(fp)
 322efc4:	e0bff717 	ldw	r2,-36(fp)
 322efc8:	10c5c83a 	sub	r2,r2,r3
 322efcc:	e0bfff15 	stw	r2,-4(fp)
 322efd0:	e0bfff17 	ldw	r2,-4(fp)
}
 322efd4:	e037883a 	mov	sp,fp
 322efd8:	dfc00117 	ldw	ra,4(sp)
 322efdc:	df000017 	ldw	fp,0(sp)
 322efe0:	dec00204 	addi	sp,sp,8
 322efe4:	f800283a 	ret

0322efe8 <t_sendto>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * to,
   int   tolen)
{
 322efe8:	defff204 	addi	sp,sp,-56
 322efec:	dfc00d15 	stw	ra,52(sp)
 322eff0:	df000c15 	stw	fp,48(sp)
 322eff4:	df000c04 	addi	fp,sp,48
 322eff8:	e13ffa15 	stw	r4,-24(fp)
 322effc:	e17ffb15 	stw	r5,-20(fp)
 322f000:	e1bffc15 	stw	r6,-16(fp)
 322f004:	e1fffd15 	stw	r7,-12(fp)
   struct socket *   so;
   int   sendlen;
   int   err;
   struct mbuf *     name;

   so = LONG2SO(s);
 322f008:	e0bffa17 	ldw	r2,-24(fp)
 322f00c:	10bff804 	addi	r2,r2,-32
 322f010:	1085883a 	add	r2,r2,r2
 322f014:	1085883a 	add	r2,r2,r2
 322f018:	e0bff815 	stw	r2,-32(fp)
   SOC_CHECK(so);
 322f01c:	0080c9b4 	movhi	r2,806
 322f020:	10b48204 	addi	r2,r2,-11768
 322f024:	e0bff515 	stw	r2,-44(fp)
 322f028:	00000606 	br	322f044 <t_sendto+0x5c>
 322f02c:	e0fff517 	ldw	r3,-44(fp)
 322f030:	e0bff817 	ldw	r2,-32(fp)
 322f034:	18800626 	beq	r3,r2,322f050 <t_sendto+0x68>
 322f038:	e0bff517 	ldw	r2,-44(fp)
 322f03c:	10800017 	ldw	r2,0(r2)
 322f040:	e0bff515 	stw	r2,-44(fp)
 322f044:	e0bff517 	ldw	r2,-44(fp)
 322f048:	1004c03a 	cmpne	r2,r2,zero
 322f04c:	103ff71e 	bne	r2,zero,322f02c <t_sendto+0x44>
 322f050:	e0fff517 	ldw	r3,-44(fp)
 322f054:	e0bff817 	ldw	r2,-32(fp)
 322f058:	18800426 	beq	r3,r2,322f06c <t_sendto+0x84>
 322f05c:	322aef00 	call	322aef0 <dtrap>
 322f060:	00bfffc4 	movi	r2,-1
 322f064:	e0bfff15 	stw	r2,-4(fp)
 322f068:	00006406 	br	322f1fc <t_sendto+0x214>
   so->so_error = 0;
 322f06c:	e0bff817 	ldw	r2,-32(fp)
 322f070:	10000615 	stw	zero,24(r2)

   switch (so->so_type)
 322f074:	e0bff817 	ldw	r2,-32(fp)
 322f078:	10800983 	ldbu	r2,38(r2)
 322f07c:	10803fcc 	andi	r2,r2,255
 322f080:	1080201c 	xori	r2,r2,128
 322f084:	10bfe004 	addi	r2,r2,-128
 322f088:	e0bffe15 	stw	r2,-8(fp)
 322f08c:	e0fffe17 	ldw	r3,-8(fp)
 322f090:	188000a0 	cmpeqi	r2,r3,2
 322f094:	10000e1e 	bne	r2,zero,322f0d0 <t_sendto+0xe8>
 322f098:	e0fffe17 	ldw	r3,-8(fp)
 322f09c:	188000e0 	cmpeqi	r2,r3,3
 322f0a0:	10000e1e 	bne	r2,zero,322f0dc <t_sendto+0xf4>
 322f0a4:	e0fffe17 	ldw	r3,-8(fp)
 322f0a8:	18800060 	cmpeqi	r2,r3,1
 322f0ac:	1000011e 	bne	r2,zero,322f0b4 <t_sendto+0xcc>
 322f0b0:	00001006 	br	322f0f4 <t_sendto+0x10c>
   {
   case SOCK_STREAM:
      /* this is a stream socket, so pass this request through
       * t_send() for its large-send support.
       */
      return t_send(s, buf, len, flags);
 322f0b4:	e13ffa17 	ldw	r4,-24(fp)
 322f0b8:	e17ffb17 	ldw	r5,-20(fp)
 322f0bc:	e1bffc17 	ldw	r6,-16(fp)
 322f0c0:	e1fffd17 	ldw	r7,-12(fp)
 322f0c4:	322f2140 	call	322f214 <t_send>
 322f0c8:	e0bfff15 	stw	r2,-4(fp)
 322f0cc:	00004b06 	br	322f1fc <t_sendto+0x214>
      /*NOTREACHED*/
   case SOCK_DGRAM:
      /* datagram (UDP) socket -- prepare to check length */
      sendlen = udp_maxalloc();
 322f0d0:	32455b40 	call	32455b4 <udp_maxalloc>
 322f0d4:	e0bff915 	stw	r2,-28(fp)
      break;
 322f0d8:	00000d06 	br	322f110 <t_sendto+0x128>
#ifdef IP_RAW
   case SOCK_RAW:
      /* raw socket -- prepare to check length */
      sendlen = ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 322f0dc:	e0bff817 	ldw	r2,-32(fp)
 322f0e0:	10800417 	ldw	r2,16(r2)
 322f0e4:	1108000c 	andi	r4,r2,8192
 322f0e8:	32440980 	call	3244098 <ip_raw_maxalloc>
 322f0ec:	e0bff915 	stw	r2,-28(fp)
      break;
 322f0f0:	00000706 	br	322f110 <t_sendto+0x128>
#endif /* IP_RAW */
   default:
      /* socket has unknown type */
      dtrap();
 322f0f4:	322aef00 	call	322aef0 <dtrap>
      so->so_error = EFAULT;
 322f0f8:	e0fff817 	ldw	r3,-32(fp)
 322f0fc:	00800384 	movi	r2,14
 322f100:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322f104:	00bfffc4 	movi	r2,-1
 322f108:	e0bfff15 	stw	r2,-4(fp)
 322f10c:	00003b06 	br	322f1fc <t_sendto+0x214>
   /* fall through for non-stream sockets: SOCK_DGRAM (UDP) and
    * SOCK_RAW (raw IP)
    */

   /* check length against underlying stack's maximum */
   if (len > sendlen)
 322f110:	e0fff917 	ldw	r3,-28(fp)
 322f114:	e0bffc17 	ldw	r2,-16(fp)
 322f118:	1880060e 	bge	r3,r2,322f134 <t_sendto+0x14c>
   {
      so->so_error = EMSGSIZE;
 322f11c:	e0fff817 	ldw	r3,-32(fp)
 322f120:	00801e84 	movi	r2,122
 322f124:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322f128:	00ffffc4 	movi	r3,-1
 322f12c:	e0ffff15 	stw	r3,-4(fp)
 322f130:	00003206 	br	322f1fc <t_sendto+0x214>
   /* if a sockaddr was passed, wrap it in an mbuf and pas it into the
    * bowels of the BSD code; else assume this is a bound UDP socket
    * and this call came from t_send() below.
    */

   if (to)  /* sockaddr was passed */
 322f134:	e0800217 	ldw	r2,8(fp)
 322f138:	1005003a 	cmpeq	r2,r2,zero
 322f13c:	10000e1e 	bne	r2,zero,322f178 <t_sendto+0x190>
   {
      name = sockargs(to, tolen, MT_SONAME);
 322f140:	e1000217 	ldw	r4,8(fp)
 322f144:	e1400317 	ldw	r5,12(fp)
 322f148:	01800244 	movi	r6,9
 322f14c:	322f5f00 	call	322f5f0 <sockargs>
 322f150:	e0bff615 	stw	r2,-40(fp)
      if(name == NULL)
 322f154:	e0bff617 	ldw	r2,-40(fp)
 322f158:	1004c03a 	cmpne	r2,r2,zero
 322f15c:	1000071e 	bne	r2,zero,322f17c <t_sendto+0x194>
      {
         so->so_error = ENOMEM;
 322f160:	e0fff817 	ldw	r3,-32(fp)
 322f164:	00800304 	movi	r2,12
 322f168:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 322f16c:	00bfffc4 	movi	r2,-1
 322f170:	e0bfff15 	stw	r2,-4(fp)
 322f174:	00002106 	br	322f1fc <t_sendto+0x214>
      }
   }
   else     /* hope user called bind() first... */
      name = NULL;
 322f178:	e03ff615 	stw	zero,-40(fp)
   
   sendlen = len;
 322f17c:	e0bffc17 	ldw	r2,-16(fp)
 322f180:	e0bff915 	stw	r2,-28(fp)

   LOCK_NET_RESOURCE(NET_RESID);
 322f184:	0009883a 	mov	r4,zero
 322f188:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>

   err = sosend (so, name, buf, &sendlen, flags);
 322f18c:	e1fff904 	addi	r7,fp,-28
 322f190:	e0bffd17 	ldw	r2,-12(fp)
 322f194:	d8800015 	stw	r2,0(sp)
 322f198:	e13ff817 	ldw	r4,-32(fp)
 322f19c:	e17ff617 	ldw	r5,-40(fp)
 322f1a0:	e1bffb17 	ldw	r6,-20(fp)
 322f1a4:	32300c00 	call	32300c0 <sosend>
 322f1a8:	e0bff715 	stw	r2,-36(fp)

   if (name)
 322f1ac:	e0bff617 	ldw	r2,-40(fp)
 322f1b0:	1005003a 	cmpeq	r2,r2,zero
 322f1b4:	1000021e 	bne	r2,zero,322f1c0 <t_sendto+0x1d8>
      m_freem(name);
 322f1b8:	e13ff617 	ldw	r4,-40(fp)
 322f1bc:	322bfcc0 	call	322bfcc <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 322f1c0:	0009883a 	mov	r4,zero
 322f1c4:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 322f1c8:	e0bff717 	ldw	r2,-36(fp)
 322f1cc:	1005003a 	cmpeq	r2,r2,zero
 322f1d0:	1000061e 	bne	r2,zero,322f1ec <t_sendto+0x204>
   {
      so->so_error = err;
 322f1d4:	e0fff817 	ldw	r3,-32(fp)
 322f1d8:	e0bff717 	ldw	r2,-36(fp)
 322f1dc:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322f1e0:	00ffffc4 	movi	r3,-1
 322f1e4:	e0ffff15 	stw	r3,-4(fp)
 322f1e8:	00000406 	br	322f1fc <t_sendto+0x214>
   }

   return (len - sendlen);
 322f1ec:	e0fff917 	ldw	r3,-28(fp)
 322f1f0:	e0bffc17 	ldw	r2,-16(fp)
 322f1f4:	10c5c83a 	sub	r2,r2,r3
 322f1f8:	e0bfff15 	stw	r2,-4(fp)
 322f1fc:	e0bfff17 	ldw	r2,-4(fp)
}
 322f200:	e037883a 	mov	sp,fp
 322f204:	dfc00117 	ldw	ra,4(sp)
 322f208:	df000017 	ldw	fp,0(sp)
 322f20c:	dec00204 	addi	sp,sp,8
 322f210:	f800283a 	ret

0322f214 <t_send>:
int
t_send(long s, 
   char *   buf,
   int      len, 
   int      flags)
{
 322f214:	defff004 	addi	sp,sp,-64
 322f218:	dfc00f15 	stw	ra,60(sp)
 322f21c:	df000e15 	stw	fp,56(sp)
 322f220:	df000e04 	addi	fp,sp,56
 322f224:	e13ffb15 	stw	r4,-20(fp)
 322f228:	e17ffc15 	stw	r5,-16(fp)
 322f22c:	e1bffd15 	stw	r6,-12(fp)
 322f230:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   e;       /* error holder */
   int   total_sent  =  0;
 322f234:	e03ff715 	stw	zero,-36(fp)
   int   maxpkt;
   int   sendlen;
   int   sent;

   so = LONG2SO(s);
 322f238:	e0bffb17 	ldw	r2,-20(fp)
 322f23c:	10bff804 	addi	r2,r2,-32
 322f240:	1085883a 	add	r2,r2,r2
 322f244:	1085883a 	add	r2,r2,r2
 322f248:	e0bff915 	stw	r2,-28(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 322f24c:	e0bff917 	ldw	r2,-28(fp)
 322f250:	1080088b 	ldhu	r2,34(r2)
 322f254:	10bfffcc 	andi	r2,r2,65535
 322f258:	1080038c 	andi	r2,r2,14
 322f25c:	108000a0 	cmpeqi	r2,r2,2
 322f260:	1000061e 	bne	r2,zero,322f27c <t_send+0x68>
   {
      so->so_error = EPIPE;
 322f264:	e0fff917 	ldw	r3,-28(fp)
 322f268:	00800804 	movi	r2,32
 322f26c:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322f270:	00bfffc4 	movi	r2,-1
 322f274:	e0bfff15 	stw	r2,-4(fp)
 322f278:	00006a06 	br	322f424 <t_send+0x210>
   }
   so->so_error = 0;
 322f27c:	e0bff917 	ldw	r2,-28(fp)
 322f280:	10000615 	stw	zero,24(r2)

   /* If this is not a stream socket, assume it is bound and pass to
    * t_sendto() with a null sockaddr
    */
   if (so->so_type != SOCK_STREAM)
 322f284:	e0bff917 	ldw	r2,-28(fp)
 322f288:	10800983 	ldbu	r2,38(r2)
 322f28c:	10803fcc 	andi	r2,r2,255
 322f290:	1080201c 	xori	r2,r2,128
 322f294:	10bfe004 	addi	r2,r2,-128
 322f298:	10800060 	cmpeqi	r2,r2,1
 322f29c:	1000091e 	bne	r2,zero,322f2c4 <t_send+0xb0>
      return(t_sendto(s, buf, len, flags, NULL, 0));
 322f2a0:	d8000015 	stw	zero,0(sp)
 322f2a4:	d8000115 	stw	zero,4(sp)
 322f2a8:	e13ffb17 	ldw	r4,-20(fp)
 322f2ac:	e17ffc17 	ldw	r5,-16(fp)
 322f2b0:	e1bffd17 	ldw	r6,-12(fp)
 322f2b4:	e1fffe17 	ldw	r7,-8(fp)
 322f2b8:	322efe80 	call	322efe8 <t_sendto>
 322f2bc:	e0bfff15 	stw	r2,-4(fp)
 322f2c0:	00005806 	br	322f424 <t_send+0x210>

   maxpkt = TCP_MSS;
 322f2c4:	00816d04 	movi	r2,1460
 322f2c8:	e0bff615 	stw	r2,-40(fp)
   if(so->so_pcb)
 322f2cc:	e0bff917 	ldw	r2,-28(fp)
 322f2d0:	10800117 	ldw	r2,4(r2)
 322f2d4:	1005003a 	cmpeq	r2,r2,zero
 322f2d8:	10004d1e 	bne	r2,zero,322f410 <t_send+0x1fc>
   { 
      struct tcpcb * tp;
      tp = intotcpcb(so->so_pcb);   /* get tcp structure with mss */
 322f2dc:	e0bff917 	ldw	r2,-28(fp)
 322f2e0:	10800117 	ldw	r2,4(r2)
 322f2e4:	10800917 	ldw	r2,36(r2)
 322f2e8:	e0bff415 	stw	r2,-48(fp)
      if(tp->t_maxseg)              /* Make sure it's set */
 322f2ec:	e0bff417 	ldw	r2,-48(fp)
 322f2f0:	10800a0b 	ldhu	r2,40(r2)
 322f2f4:	10bfffcc 	andi	r2,r2,65535
 322f2f8:	1005003a 	cmpeq	r2,r2,zero
 322f2fc:	1000441e 	bne	r2,zero,322f410 <t_send+0x1fc>
         maxpkt = tp->t_maxseg;
 322f300:	e0bff417 	ldw	r2,-48(fp)
 322f304:	10800a0b 	ldhu	r2,40(r2)
 322f308:	10bfffcc 	andi	r2,r2,65535
 322f30c:	e0bff615 	stw	r2,-40(fp)
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 322f310:	00003f06 	br	322f410 <t_send+0x1fc>
   {
      if (len > maxpkt)
 322f314:	e0fffd17 	ldw	r3,-12(fp)
 322f318:	e0bff617 	ldw	r2,-40(fp)
 322f31c:	10c0030e 	bge	r2,r3,322f32c <t_send+0x118>
         sendlen = maxpkt;  /* take biggest block we can */
 322f320:	e0bff617 	ldw	r2,-40(fp)
 322f324:	e0bffa15 	stw	r2,-24(fp)
 322f328:	00000206 	br	322f334 <t_send+0x120>
      else
         sendlen = len;
 322f32c:	e0bffd17 	ldw	r2,-12(fp)
 322f330:	e0bffa15 	stw	r2,-24(fp)
      sent = sendlen;
 322f334:	e0bffa17 	ldw	r2,-24(fp)
 322f338:	e0bff515 	stw	r2,-44(fp)

      LOCK_NET_RESOURCE(NET_RESID);
 322f33c:	0009883a 	mov	r4,zero
 322f340:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      e = sosend (so, NULL, buf, &sendlen, flags);
 322f344:	e1fffa04 	addi	r7,fp,-24
 322f348:	e0bffe17 	ldw	r2,-8(fp)
 322f34c:	d8800015 	stw	r2,0(sp)
 322f350:	e13ff917 	ldw	r4,-28(fp)
 322f354:	000b883a 	mov	r5,zero
 322f358:	e1bffc17 	ldw	r6,-16(fp)
 322f35c:	32300c00 	call	32300c0 <sosend>
 322f360:	e0bff815 	stw	r2,-32(fp)
      UNLOCK_NET_RESOURCE(NET_RESID);
 322f364:	0009883a 	mov	r4,zero
 322f368:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
 
      if (e != 0)  /* sock_sendit failed? */
 322f36c:	e0bff817 	ldw	r2,-32(fp)
 322f370:	1005003a 	cmpeq	r2,r2,zero
 322f374:	1000121e 	bne	r2,zero,322f3c0 <t_send+0x1ac>
      {
         /* if we simply ran out of bufs, report back to caller. */
         if ((e == ENOBUFS) || (e == EWOULDBLOCK))
 322f378:	e0bff817 	ldw	r2,-32(fp)
 322f37c:	10801a60 	cmpeqi	r2,r2,105
 322f380:	1000031e 	bne	r2,zero,322f390 <t_send+0x17c>
 322f384:	e0bff817 	ldw	r2,-32(fp)
 322f388:	108002d8 	cmpnei	r2,r2,11
 322f38c:	1000061e 	bne	r2,zero,322f3a8 <t_send+0x194>
            /* if we actually sent something before running out
             * of buffers, report what we sent; 
             * else, report the error and let the application 
             * retry the call later
             */
            if (total_sent != 0)
 322f390:	e0bff717 	ldw	r2,-36(fp)
 322f394:	1005003a 	cmpeq	r2,r2,zero
 322f398:	1000031e 	bne	r2,zero,322f3a8 <t_send+0x194>
            {
               so->so_error = 0;
 322f39c:	e0bff917 	ldw	r2,-28(fp)
 322f3a0:	10000615 	stw	zero,24(r2)
               break;      /* break out of while(len) loop */
 322f3a4:	00001d06 	br	322f41c <t_send+0x208>
            }
         }
         so->so_error = e;
 322f3a8:	e0fff917 	ldw	r3,-28(fp)
 322f3ac:	e0bff817 	ldw	r2,-32(fp)
 322f3b0:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 322f3b4:	00bfffc4 	movi	r2,-1
 322f3b8:	e0bfff15 	stw	r2,-4(fp)
 322f3bc:	00001906 	br	322f424 <t_send+0x210>
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
 322f3c0:	e0bffa17 	ldw	r2,-24(fp)
 322f3c4:	1004c03a 	cmpne	r2,r2,zero
 322f3c8:	1000141e 	bne	r2,zero,322f41c <t_send+0x208>
         break;         /* break out of while(len) loop */

      /* adjust numbers & pointers, and go do next send loop */
      sent -= sendlen;        /* subtract anything that didn't get sent */
 322f3cc:	e0fffa17 	ldw	r3,-24(fp)
 322f3d0:	e0bff517 	ldw	r2,-44(fp)
 322f3d4:	10c5c83a 	sub	r2,r2,r3
 322f3d8:	e0bff515 	stw	r2,-44(fp)
      buf += sent;
 322f3dc:	e0bff517 	ldw	r2,-44(fp)
 322f3e0:	1007883a 	mov	r3,r2
 322f3e4:	e0bffc17 	ldw	r2,-16(fp)
 322f3e8:	10c5883a 	add	r2,r2,r3
 322f3ec:	e0bffc15 	stw	r2,-16(fp)
      len -= sent;
 322f3f0:	e0fffd17 	ldw	r3,-12(fp)
 322f3f4:	e0bff517 	ldw	r2,-44(fp)
 322f3f8:	1885c83a 	sub	r2,r3,r2
 322f3fc:	e0bffd15 	stw	r2,-12(fp)
      total_sent += sent;
 322f400:	e0fff717 	ldw	r3,-36(fp)
 322f404:	e0bff517 	ldw	r2,-44(fp)
 322f408:	1885883a 	add	r2,r3,r2
 322f40c:	e0bff715 	stw	r2,-36(fp)
         maxpkt = tp->t_maxseg;
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 322f410:	e0bffd17 	ldw	r2,-12(fp)
 322f414:	1004c03a 	cmpne	r2,r2,zero
 322f418:	103fbe1e 	bne	r2,zero,322f314 <t_send+0x100>
      len -= sent;
      total_sent += sent;
   }

   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   return total_sent;
 322f41c:	e0bff717 	ldw	r2,-36(fp)
 322f420:	e0bfff15 	stw	r2,-4(fp)
 322f424:	e0bfff17 	ldw	r2,-4(fp)
}
 322f428:	e037883a 	mov	sp,fp
 322f42c:	dfc00117 	ldw	ra,4(sp)
 322f430:	df000017 	ldw	fp,0(sp)
 322f434:	dec00204 	addi	sp,sp,8
 322f438:	f800283a 	ret

0322f43c <t_shutdown>:
 * RETURNS: 
 */

int
t_shutdown(long s, int   how)
{
 322f43c:	defff804 	addi	sp,sp,-32
 322f440:	dfc00715 	stw	ra,28(sp)
 322f444:	df000615 	stw	fp,24(sp)
 322f448:	df000604 	addi	fp,sp,24
 322f44c:	e13ffd15 	stw	r4,-12(fp)
 322f450:	e17ffe15 	stw	r5,-8(fp)
   struct socket *so;
   int   err;

   so = LONG2SO(s);
 322f454:	e0bffd17 	ldw	r2,-12(fp)
 322f458:	10bff804 	addi	r2,r2,-32
 322f45c:	1085883a 	add	r2,r2,r2
 322f460:	1085883a 	add	r2,r2,r2
 322f464:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 322f468:	0080c9b4 	movhi	r2,806
 322f46c:	10b48204 	addi	r2,r2,-11768
 322f470:	e0bffa15 	stw	r2,-24(fp)
 322f474:	00000606 	br	322f490 <t_shutdown+0x54>
 322f478:	e0fffa17 	ldw	r3,-24(fp)
 322f47c:	e0bffc17 	ldw	r2,-16(fp)
 322f480:	18800626 	beq	r3,r2,322f49c <t_shutdown+0x60>
 322f484:	e0bffa17 	ldw	r2,-24(fp)
 322f488:	10800017 	ldw	r2,0(r2)
 322f48c:	e0bffa15 	stw	r2,-24(fp)
 322f490:	e0bffa17 	ldw	r2,-24(fp)
 322f494:	1004c03a 	cmpne	r2,r2,zero
 322f498:	103ff71e 	bne	r2,zero,322f478 <t_shutdown+0x3c>
 322f49c:	e0fffa17 	ldw	r3,-24(fp)
 322f4a0:	e0bffc17 	ldw	r2,-16(fp)
 322f4a4:	18800426 	beq	r3,r2,322f4b8 <t_shutdown+0x7c>
 322f4a8:	322aef00 	call	322aef0 <dtrap>
 322f4ac:	00bfffc4 	movi	r2,-1
 322f4b0:	e0bfff15 	stw	r2,-4(fp)
 322f4b4:	00001406 	br	322f508 <t_shutdown+0xcc>
   so->so_error = 0;
 322f4b8:	e0bffc17 	ldw	r2,-16(fp)
 322f4bc:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:shutdown so %x how %d\n", so, how));

   LOCK_NET_RESOURCE(NET_RESID);
 322f4c0:	0009883a 	mov	r4,zero
 322f4c4:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   err = soshutdown(so, how);
 322f4c8:	e13ffc17 	ldw	r4,-16(fp)
 322f4cc:	e17ffe17 	ldw	r5,-8(fp)
 322f4d0:	3230eac0 	call	3230eac <soshutdown>
 322f4d4:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 322f4d8:	0009883a 	mov	r4,zero
 322f4dc:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 322f4e0:	e0bffb17 	ldw	r2,-20(fp)
 322f4e4:	1005003a 	cmpeq	r2,r2,zero
 322f4e8:	1000061e 	bne	r2,zero,322f504 <t_shutdown+0xc8>
   {
      so->so_error = err;
 322f4ec:	e0fffc17 	ldw	r3,-16(fp)
 322f4f0:	e0bffb17 	ldw	r2,-20(fp)
 322f4f4:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 322f4f8:	00bfffc4 	movi	r2,-1
 322f4fc:	e0bfff15 	stw	r2,-4(fp)
 322f500:	00000106 	br	322f508 <t_shutdown+0xcc>
   }
   return 0;
 322f504:	e03fff15 	stw	zero,-4(fp)
 322f508:	e0bfff17 	ldw	r2,-4(fp)
}
 322f50c:	e037883a 	mov	sp,fp
 322f510:	dfc00117 	ldw	ra,4(sp)
 322f514:	df000017 	ldw	fp,0(sp)
 322f518:	dec00204 	addi	sp,sp,8
 322f51c:	f800283a 	ret

0322f520 <t_socketclose>:
 * RETURNS: 
 */

int
t_socketclose(long s)
{
 322f520:	defff904 	addi	sp,sp,-28
 322f524:	dfc00615 	stw	ra,24(sp)
 322f528:	df000515 	stw	fp,20(sp)
 322f52c:	df000504 	addi	fp,sp,20
 322f530:	e13ffe15 	stw	r4,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 322f534:	e0bffe17 	ldw	r2,-8(fp)
 322f538:	10bff804 	addi	r2,r2,-32
 322f53c:	1085883a 	add	r2,r2,r2
 322f540:	1085883a 	add	r2,r2,r2
 322f544:	e0bffd15 	stw	r2,-12(fp)
   SOC_CHECK(so);
 322f548:	0080c9b4 	movhi	r2,806
 322f54c:	10b48204 	addi	r2,r2,-11768
 322f550:	e0bffb15 	stw	r2,-20(fp)
 322f554:	00000606 	br	322f570 <t_socketclose+0x50>
 322f558:	e0fffb17 	ldw	r3,-20(fp)
 322f55c:	e0bffd17 	ldw	r2,-12(fp)
 322f560:	18800626 	beq	r3,r2,322f57c <t_socketclose+0x5c>
 322f564:	e0bffb17 	ldw	r2,-20(fp)
 322f568:	10800017 	ldw	r2,0(r2)
 322f56c:	e0bffb15 	stw	r2,-20(fp)
 322f570:	e0bffb17 	ldw	r2,-20(fp)
 322f574:	1004c03a 	cmpne	r2,r2,zero
 322f578:	103ff71e 	bne	r2,zero,322f558 <t_socketclose+0x38>
 322f57c:	e0fffb17 	ldw	r3,-20(fp)
 322f580:	e0bffd17 	ldw	r2,-12(fp)
 322f584:	18800426 	beq	r3,r2,322f598 <t_socketclose+0x78>
 322f588:	322aef00 	call	322aef0 <dtrap>
 322f58c:	00bfffc4 	movi	r2,-1
 322f590:	e0bfff15 	stw	r2,-4(fp)
 322f594:	00001006 	br	322f5d8 <t_socketclose+0xb8>
   so->so_error = 0;
 322f598:	e0bffd17 	ldw	r2,-12(fp)
 322f59c:	10000615 	stw	zero,24(r2)
   INET_TRACE ((INETM_CLOSE|INETM_SOCKET), ("INET:close, so %lx\n",so));

   LOCK_NET_RESOURCE(NET_RESID);
 322f5a0:	0009883a 	mov	r4,zero
 322f5a4:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   err = soclose(so);
 322f5a8:	e13ffd17 	ldw	r4,-12(fp)
 322f5ac:	322fb6c0 	call	322fb6c <soclose>
 322f5b0:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 322f5b4:	0009883a 	mov	r4,zero
 322f5b8:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 322f5bc:	e0bffc17 	ldw	r2,-16(fp)
 322f5c0:	1005003a 	cmpeq	r2,r2,zero
 322f5c4:	1000031e 	bne	r2,zero,322f5d4 <t_socketclose+0xb4>
   {
      /* do not do the following assignment since the socket structure
         addressed by so has been freed by this point, jharan 12-10-98 */
      /*      so->so_error = err;   */
      return SOCKET_ERROR;
 322f5c8:	00bfffc4 	movi	r2,-1
 322f5cc:	e0bfff15 	stw	r2,-4(fp)
 322f5d0:	00000106 	br	322f5d8 <t_socketclose+0xb8>
   }
   return 0;
 322f5d4:	e03fff15 	stw	zero,-4(fp)
 322f5d8:	e0bfff17 	ldw	r2,-4(fp)
}
 322f5dc:	e037883a 	mov	sp,fp
 322f5e0:	dfc00117 	ldw	ra,4(sp)
 322f5e4:	df000017 	ldw	fp,0(sp)
 322f5e8:	dec00204 	addi	sp,sp,8
 322f5ec:	f800283a 	ret

0322f5f0 <sockargs>:

static struct mbuf  * 
sockargs (void * arg, 
   int   arglen, 
   int   type)
{
 322f5f0:	defff904 	addi	sp,sp,-28
 322f5f4:	dfc00615 	stw	ra,24(sp)
 322f5f8:	df000515 	stw	fp,20(sp)
 322f5fc:	df000504 	addi	fp,sp,20
 322f600:	e13ffc15 	stw	r4,-16(fp)
 322f604:	e17ffd15 	stw	r5,-12(fp)
 322f608:	e1bffe15 	stw	r6,-8(fp)
   struct mbuf *  m;

   LOCK_NET_RESOURCE(NET_RESID);    /* protect mfreeq */
 322f60c:	0009883a 	mov	r4,zero
 322f610:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   m = m_getwithdata (type, arglen);
 322f614:	e13ffe17 	ldw	r4,-8(fp)
 322f618:	e17ffd17 	ldw	r5,-12(fp)
 322f61c:	322bcf00 	call	322bcf0 <m_getnbuf>
 322f620:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 322f624:	0009883a 	mov	r4,zero
 322f628:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   if (m == NULL)
 322f62c:	e0bffb17 	ldw	r2,-20(fp)
 322f630:	1004c03a 	cmpne	r2,r2,zero
 322f634:	1000021e 	bne	r2,zero,322f640 <sockargs+0x50>
      return NULL;
 322f638:	e03fff15 	stw	zero,-4(fp)
 322f63c:	00000c06 	br	322f670 <sockargs+0x80>
   m->m_len = arglen;
 322f640:	e0fffd17 	ldw	r3,-12(fp)
 322f644:	e0bffb17 	ldw	r2,-20(fp)
 322f648:	10c00215 	stw	r3,8(r2)
   MEMCPY(mtod (m, char *), arg, arglen);
 322f64c:	e0bffb17 	ldw	r2,-20(fp)
 322f650:	10c00317 	ldw	r3,12(r2)
 322f654:	e1bffd17 	ldw	r6,-12(fp)
 322f658:	e0bffc17 	ldw	r2,-16(fp)
 322f65c:	1809883a 	mov	r4,r3
 322f660:	100b883a 	mov	r5,r2
 322f664:	3206ad00 	call	3206ad0 <memcpy>
   return m;
 322f668:	e0bffb17 	ldw	r2,-20(fp)
 322f66c:	e0bfff15 	stw	r2,-4(fp)
 322f670:	e0bfff17 	ldw	r2,-4(fp)
}
 322f674:	e037883a 	mov	sp,fp
 322f678:	dfc00117 	ldw	ra,4(sp)
 322f67c:	df000017 	ldw	fp,0(sp)
 322f680:	dec00204 	addi	sp,sp,8
 322f684:	f800283a 	ret

0322f688 <t_errno>:
 *                            ENOTSOCK if socket not found
 */

int
t_errno(long s)
{
 322f688:	defffa04 	addi	sp,sp,-24
 322f68c:	dfc00515 	stw	ra,20(sp)
 322f690:	df000415 	stw	fp,16(sp)
 322f694:	df000404 	addi	fp,sp,16
 322f698:	e13fff15 	stw	r4,-4(fp)
   struct socket *so = LONG2SO(s);
 322f69c:	e0bfff17 	ldw	r2,-4(fp)
 322f6a0:	10bff804 	addi	r2,r2,-32
 322f6a4:	1085883a 	add	r2,r2,r2
 322f6a8:	1085883a 	add	r2,r2,r2
 322f6ac:	e0bffe15 	stw	r2,-8(fp)
   struct socket *tmp;
   int errcode = ENOTSOCK;
 322f6b0:	00801b04 	movi	r2,108
 322f6b4:	e0bffc15 	stw	r2,-16(fp)

   LOCK_NET_RESOURCE(NET_RESID);    /* protect soq */
 322f6b8:	0009883a 	mov	r4,zero
 322f6bc:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 322f6c0:	0080c9b4 	movhi	r2,806
 322f6c4:	10b48204 	addi	r2,r2,-11768
 322f6c8:	e0bffd15 	stw	r2,-12(fp)
 322f6cc:	00000a06 	br	322f6f8 <t_errno+0x70>
   {
      if (tmp == so)  /* found socket, return error */
 322f6d0:	e0fffd17 	ldw	r3,-12(fp)
 322f6d4:	e0bffe17 	ldw	r2,-8(fp)
 322f6d8:	1880041e 	bne	r3,r2,322f6ec <t_errno+0x64>
      {
         errcode = so->so_error;
 322f6dc:	e0bffe17 	ldw	r2,-8(fp)
 322f6e0:	10800617 	ldw	r2,24(r2)
 322f6e4:	e0bffc15 	stw	r2,-16(fp)
         break;
 322f6e8:	00000606 	br	322f704 <t_errno+0x7c>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 322f6ec:	e0bffd17 	ldw	r2,-12(fp)
 322f6f0:	10800017 	ldw	r2,0(r2)
 322f6f4:	e0bffd15 	stw	r2,-12(fp)
 322f6f8:	e0bffd17 	ldw	r2,-12(fp)
 322f6fc:	1004c03a 	cmpne	r2,r2,zero
 322f700:	103ff31e 	bne	r2,zero,322f6d0 <t_errno+0x48>
         errcode = so->so_error;
         break;
      }
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 322f704:	0009883a 	mov	r4,zero
 322f708:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   return errcode;
 322f70c:	e0bffc17 	ldw	r2,-16(fp)
}
 322f710:	e037883a 	mov	sp,fp
 322f714:	dfc00117 	ldw	ra,4(sp)
 322f718:	df000017 	ldw	fp,0(sp)
 322f71c:	dec00204 	addi	sp,sp,8
 322f720:	f800283a 	ret

0322f724 <socreate>:
 * RETURNS: 
 */

struct socket *   
socreate (int dom, int type, int proto)
{
 322f724:	defff604 	addi	sp,sp,-40
 322f728:	dfc00915 	stw	ra,36(sp)
 322f72c:	df000815 	stw	fp,32(sp)
 322f730:	df000804 	addi	fp,sp,32
 322f734:	e13ffc15 	stw	r4,-16(fp)
 322f738:	e17ffd15 	stw	r5,-12(fp)
 322f73c:	e1bffe15 	stw	r6,-8(fp)
   struct protosw *prp;
   struct socket *so;
   int   error;
   int rc;

   if (proto)
 322f740:	e0bffe17 	ldw	r2,-8(fp)
 322f744:	1005003a 	cmpeq	r2,r2,zero
 322f748:	1000061e 	bne	r2,zero,322f764 <socreate+0x40>
      prp = pffindproto(dom, proto, type);
 322f74c:	e13ffc17 	ldw	r4,-16(fp)
 322f750:	e17ffe17 	ldw	r5,-8(fp)
 322f754:	e1bffd17 	ldw	r6,-12(fp)
 322f758:	322bc200 	call	322bc20 <pffindproto>
 322f75c:	e0bffb15 	stw	r2,-20(fp)
 322f760:	00000406 	br	322f774 <socreate+0x50>
   else
      prp = pffindtype(dom, type);
 322f764:	e13ffc17 	ldw	r4,-16(fp)
 322f768:	e17ffd17 	ldw	r5,-12(fp)
 322f76c:	322bb800 	call	322bb80 <pffindtype>
 322f770:	e0bffb15 	stw	r2,-20(fp)
   if (prp == 0)
 322f774:	e0bffb17 	ldw	r2,-20(fp)
 322f778:	1004c03a 	cmpne	r2,r2,zero
 322f77c:	1000021e 	bne	r2,zero,322f788 <socreate+0x64>
      return NULL;
 322f780:	e03fff15 	stw	zero,-4(fp)
 322f784:	00005406 	br	322f8d8 <socreate+0x1b4>
   if (prp->pr_type != type)
 322f788:	e0bffb17 	ldw	r2,-20(fp)
 322f78c:	1080000b 	ldhu	r2,0(r2)
 322f790:	10ffffcc 	andi	r3,r2,65535
 322f794:	18e0001c 	xori	r3,r3,32768
 322f798:	18e00004 	addi	r3,r3,-32768
 322f79c:	e0bffd17 	ldw	r2,-12(fp)
 322f7a0:	18800226 	beq	r3,r2,322f7ac <socreate+0x88>
      return NULL;
 322f7a4:	e03fff15 	stw	zero,-4(fp)
 322f7a8:	00004b06 	br	322f8d8 <socreate+0x1b4>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 322f7ac:	01002104 	movi	r4,132
 322f7b0:	322b9340 	call	322b934 <npalloc>
 322f7b4:	e0bffa15 	stw	r2,-24(fp)
 322f7b8:	e0bffa17 	ldw	r2,-24(fp)
 322f7bc:	1004c03a 	cmpne	r2,r2,zero
 322f7c0:	1000021e 	bne	r2,zero,322f7cc <socreate+0xa8>
      return NULL;
 322f7c4:	e03fff15 	stw	zero,-4(fp)
 322f7c8:	00004306 	br	322f8d8 <socreate+0x1b4>
   so->next = NULL;
 322f7cc:	e0bffa17 	ldw	r2,-24(fp)
 322f7d0:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);
 322f7d4:	e17ffa17 	ldw	r5,-24(fp)
 322f7d8:	0100c9b4 	movhi	r4,806
 322f7dc:	21348204 	addi	r4,r4,-11768
 322f7e0:	322a8800 	call	322a880 <putq>

   so->so_options = socket_defaults;
 322f7e4:	d0a0380b 	ldhu	r2,-32544(gp)
 322f7e8:	10ffffcc 	andi	r3,r2,65535
 322f7ec:	e0bffa17 	ldw	r2,-24(fp)
 322f7f0:	10c00415 	stw	r3,16(r2)
   so->so_domain = dom;
 322f7f4:	e0fffa17 	ldw	r3,-24(fp)
 322f7f8:	e0bffc17 	ldw	r2,-16(fp)
 322f7fc:	18800515 	stw	r2,20(r3)
   so->so_state = 0;
 322f800:	e0bffa17 	ldw	r2,-24(fp)
 322f804:	1000088d 	sth	zero,34(r2)
   so->so_type = (char)type;
 322f808:	e0bffd17 	ldw	r2,-12(fp)
 322f80c:	1007883a 	mov	r3,r2
 322f810:	e0bffa17 	ldw	r2,-24(fp)
 322f814:	10c00985 	stb	r3,38(r2)
   so->so_proto = prp;
 322f818:	e0fffa17 	ldw	r3,-24(fp)
 322f81c:	e0bffb17 	ldw	r2,-20(fp)
 322f820:	18800215 	stw	r2,8(r3)

#ifdef IP_MULTICAST
   so->inp_moptions = NULL;
 322f824:	e0bffa17 	ldw	r2,-24(fp)
 322f828:	10000315 	stw	zero,12(r2)
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
 322f82c:	e0bffa17 	ldw	r2,-24(fp)
 322f830:	10000715 	stw	zero,28(r2)
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
 322f834:	e0bffb17 	ldw	r2,-20(fp)
 322f838:	10800317 	ldw	r2,12(r2)
 322f83c:	e1bffe17 	ldw	r6,-8(fp)
 322f840:	e13ffa17 	ldw	r4,-24(fp)
 322f844:	000b883a 	mov	r5,zero
 322f848:	103ee83a 	callr	r2
 322f84c:	e0bff915 	stw	r2,-28(fp)
   if (error) goto bad;
 322f850:	e0bff917 	ldw	r2,-28(fp)
 322f854:	1004c03a 	cmpne	r2,r2,zero
 322f858:	10000f1e 	bne	r2,zero,322f898 <socreate+0x174>

   if (so_evtmap)
 322f85c:	0080c974 	movhi	r2,805
 322f860:	10936704 	addi	r2,r2,19868
 322f864:	10800003 	ldbu	r2,0(r2)
 322f868:	10803fcc 	andi	r2,r2,255
 322f86c:	1005003a 	cmpeq	r2,r2,zero
 322f870:	1000171e 	bne	r2,zero,322f8d0 <socreate+0x1ac>
   {                       
      rc = (*so_evtmap_create) (so);
 322f874:	0080c974 	movhi	r2,805
 322f878:	10936504 	addi	r2,r2,19860
 322f87c:	10800017 	ldw	r2,0(r2)
 322f880:	e13ffa17 	ldw	r4,-24(fp)
 322f884:	103ee83a 	callr	r2
 322f888:	e0bff815 	stw	r2,-32(fp)
      if (rc != 0)
 322f88c:	e0bff817 	ldw	r2,-32(fp)
 322f890:	1005003a 	cmpeq	r2,r2,zero
 322f894:	10000a1e 	bne	r2,zero,322f8c0 <socreate+0x19c>
      {
bad:   
         so->so_state |= SS_NOFDREF;
 322f898:	e0bffa17 	ldw	r2,-24(fp)
 322f89c:	1080088b 	ldhu	r2,34(r2)
 322f8a0:	10800054 	ori	r2,r2,1
 322f8a4:	1007883a 	mov	r3,r2
 322f8a8:	e0bffa17 	ldw	r2,-24(fp)
 322f8ac:	10c0088d 	sth	r3,34(r2)
         sofree (so);
 322f8b0:	e13ffa17 	ldw	r4,-24(fp)
 322f8b4:	322fa3c0 	call	322fa3c <sofree>
         return NULL;   
 322f8b8:	e03fff15 	stw	zero,-4(fp)
 322f8bc:	00000606 	br	322f8d8 <socreate+0x1b4>
      /*
       * Altera Niche Stack Nios port modification:
       * Remove (void *) cast since -> owner is now TK_OBJECT
       * to fix build warning.
       */
      so->owner = TK_THIS;
 322f8c0:	3226d680 	call	3226d68 <TK_OSTaskQuery>
 322f8c4:	1007883a 	mov	r3,r2
 322f8c8:	e0bffa17 	ldw	r2,-24(fp)
 322f8cc:	10c02005 	stb	r3,128(r2)
   }

   return so;
 322f8d0:	e0bffa17 	ldw	r2,-24(fp)
 322f8d4:	e0bfff15 	stw	r2,-4(fp)
 322f8d8:	e0bfff17 	ldw	r2,-4(fp)
}
 322f8dc:	e037883a 	mov	sp,fp
 322f8e0:	dfc00117 	ldw	ra,4(sp)
 322f8e4:	df000017 	ldw	fp,0(sp)
 322f8e8:	dec00204 	addi	sp,sp,8
 322f8ec:	f800283a 	ret

0322f8f0 <sobind>:
 */

int
sobind(struct socket * so, 
   struct mbuf *  nam)
{
 322f8f0:	defffb04 	addi	sp,sp,-20
 322f8f4:	dfc00415 	stw	ra,16(sp)
 322f8f8:	df000315 	stw	fp,12(sp)
 322f8fc:	df000304 	addi	fp,sp,12
 322f900:	e13ffe15 	stw	r4,-8(fp)
 322f904:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_BIND;
 322f908:	e0fffe17 	ldw	r3,-8(fp)
 322f90c:	00800084 	movi	r2,2
 322f910:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 322f914:	e0bffe17 	ldw	r2,-8(fp)
 322f918:	10800217 	ldw	r2,8(r2)
 322f91c:	10800317 	ldw	r2,12(r2)
 322f920:	e13ffe17 	ldw	r4,-8(fp)
 322f924:	000b883a 	mov	r5,zero
 322f928:	e1bfff17 	ldw	r6,-4(fp)
 322f92c:	103ee83a 	callr	r2
 322f930:	e0bffd15 	stw	r2,-12(fp)
   return (error);
 322f934:	e0bffd17 	ldw	r2,-12(fp)
}
 322f938:	e037883a 	mov	sp,fp
 322f93c:	dfc00117 	ldw	ra,4(sp)
 322f940:	df000017 	ldw	fp,0(sp)
 322f944:	dec00204 	addi	sp,sp,8
 322f948:	f800283a 	ret

0322f94c <solisten>:
 */

int
solisten(struct socket * so, 
   int   backlog)
{
 322f94c:	defff904 	addi	sp,sp,-28
 322f950:	dfc00615 	stw	ra,24(sp)
 322f954:	df000515 	stw	fp,20(sp)
 322f958:	df000504 	addi	fp,sp,20
 322f95c:	e13ffc15 	stw	r4,-16(fp)
 322f960:	e17ffd15 	stw	r5,-12(fp)
   int   error;

   so->so_req = PRU_LISTEN;
 322f964:	e0fffc17 	ldw	r3,-16(fp)
 322f968:	008000c4 	movi	r2,3
 322f96c:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so,
 322f970:	e0bffc17 	ldw	r2,-16(fp)
 322f974:	10800217 	ldw	r2,8(r2)
 322f978:	10800317 	ldw	r2,12(r2)
 322f97c:	e13ffc17 	ldw	r4,-16(fp)
 322f980:	000b883a 	mov	r5,zero
 322f984:	000d883a 	mov	r6,zero
 322f988:	103ee83a 	callr	r2
 322f98c:	e0bffb15 	stw	r2,-20(fp)
    (struct mbuf *)0, (struct mbuf *)0);
   if (error) 
 322f990:	e0bffb17 	ldw	r2,-20(fp)
 322f994:	1005003a 	cmpeq	r2,r2,zero
 322f998:	1000031e 	bne	r2,zero,322f9a8 <solisten+0x5c>
   {
      return (error);
 322f99c:	e0bffb17 	ldw	r2,-20(fp)
 322f9a0:	e0bfff15 	stw	r2,-4(fp)
 322f9a4:	00001f06 	br	322fa24 <solisten+0xd8>
   }
   if (so->so_q == 0) 
 322f9a8:	e0bffc17 	ldw	r2,-16(fp)
 322f9ac:	10801d17 	ldw	r2,116(r2)
 322f9b0:	1004c03a 	cmpne	r2,r2,zero
 322f9b4:	10000b1e 	bne	r2,zero,322f9e4 <solisten+0x98>
   {
      so->so_q = so;
 322f9b8:	e0fffc17 	ldw	r3,-16(fp)
 322f9bc:	e0bffc17 	ldw	r2,-16(fp)
 322f9c0:	18801d15 	stw	r2,116(r3)
      so->so_q0 = so;
 322f9c4:	e0fffc17 	ldw	r3,-16(fp)
 322f9c8:	e0bffc17 	ldw	r2,-16(fp)
 322f9cc:	18801c15 	stw	r2,112(r3)
      so->so_options |= SO_ACCEPTCONN;
 322f9d0:	e0bffc17 	ldw	r2,-16(fp)
 322f9d4:	10800417 	ldw	r2,16(r2)
 322f9d8:	10c00094 	ori	r3,r2,2
 322f9dc:	e0bffc17 	ldw	r2,-16(fp)
 322f9e0:	10c00415 	stw	r3,16(r2)
   }
   if (backlog < 0)
 322f9e4:	e0bffd17 	ldw	r2,-12(fp)
 322f9e8:	1004403a 	cmpge	r2,r2,zero
 322f9ec:	1000011e 	bne	r2,zero,322f9f4 <solisten+0xa8>
      backlog = 0;
 322f9f0:	e03ffd15 	stw	zero,-12(fp)
   so->so_qlimit = (char)MIN(backlog, SOMAXCONN);
 322f9f4:	e0fffd17 	ldw	r3,-12(fp)
 322f9f8:	e0fffe15 	stw	r3,-8(fp)
 322f9fc:	e0fffe17 	ldw	r3,-8(fp)
 322fa00:	18800190 	cmplti	r2,r3,6
 322fa04:	1000021e 	bne	r2,zero,322fa10 <solisten+0xc4>
 322fa08:	00800144 	movi	r2,5
 322fa0c:	e0bffe15 	stw	r2,-8(fp)
 322fa10:	e0bffe17 	ldw	r2,-8(fp)
 322fa14:	1007883a 	mov	r3,r2
 322fa18:	e0bffc17 	ldw	r2,-16(fp)
 322fa1c:	10c01e85 	stb	r3,122(r2)
   return 0;
 322fa20:	e03fff15 	stw	zero,-4(fp)
 322fa24:	e0bfff17 	ldw	r2,-4(fp)
}
 322fa28:	e037883a 	mov	sp,fp
 322fa2c:	dfc00117 	ldw	ra,4(sp)
 322fa30:	df000017 	ldw	fp,0(sp)
 322fa34:	dec00204 	addi	sp,sp,8
 322fa38:	f800283a 	ret

0322fa3c <sofree>:
 * RETURNS: 
 */

void
sofree(struct socket * so)
{
 322fa3c:	defffd04 	addi	sp,sp,-12
 322fa40:	dfc00215 	stw	ra,8(sp)
 322fa44:	df000115 	stw	fp,4(sp)
 322fa48:	df000104 	addi	fp,sp,4
 322fa4c:	e13fff15 	stw	r4,-4(fp)
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
 322fa50:	e0bfff17 	ldw	r2,-4(fp)
 322fa54:	10800117 	ldw	r2,4(r2)
 322fa58:	1004c03a 	cmpne	r2,r2,zero
 322fa5c:	10003e1e 	bne	r2,zero,322fb58 <sofree+0x11c>
 322fa60:	e0bfff17 	ldw	r2,-4(fp)
 322fa64:	1080088b 	ldhu	r2,34(r2)
 322fa68:	10bfffcc 	andi	r2,r2,65535
 322fa6c:	1080004c 	andi	r2,r2,1
 322fa70:	1004c03a 	cmpne	r2,r2,zero
 322fa74:	1000011e 	bne	r2,zero,322fa7c <sofree+0x40>
      return;
 322fa78:	00003706 	br	322fb58 <sofree+0x11c>
   if (so->so_head) 
 322fa7c:	e0bfff17 	ldw	r2,-4(fp)
 322fa80:	10801b17 	ldw	r2,108(r2)
 322fa84:	1005003a 	cmpeq	r2,r2,zero
 322fa88:	10000f1e 	bne	r2,zero,322fac8 <sofree+0x8c>
   {
      if (!soqremque(so, 0) && !soqremque(so, 1))
 322fa8c:	e13fff17 	ldw	r4,-4(fp)
 322fa90:	000b883a 	mov	r5,zero
 322fa94:	32320100 	call	3232010 <soqremque>
 322fa98:	1004c03a 	cmpne	r2,r2,zero
 322fa9c:	1000081e 	bne	r2,zero,322fac0 <sofree+0x84>
 322faa0:	e13fff17 	ldw	r4,-4(fp)
 322faa4:	01400044 	movi	r5,1
 322faa8:	32320100 	call	3232010 <soqremque>
 322faac:	1004c03a 	cmpne	r2,r2,zero
 322fab0:	1000031e 	bne	r2,zero,322fac0 <sofree+0x84>
         panic("sofree");
 322fab4:	0100c974 	movhi	r4,805
 322fab8:	213e3104 	addi	r4,r4,-1852
 322fabc:	32261540 	call	3226154 <panic>
      so->so_head = 0;
 322fac0:	e0bfff17 	ldw	r2,-4(fp)
 322fac4:	10001b15 	stw	zero,108(r2)
   }
   sbrelease(&so->so_snd);
 322fac8:	e0bfff17 	ldw	r2,-4(fp)
 322facc:	11001204 	addi	r4,r2,72
 322fad0:	32323ec0 	call	32323ec <sbrelease>
   sorflush(so);
 322fad4:	e13fff17 	ldw	r4,-4(fp)
 322fad8:	3230f540 	call	3230f54 <sorflush>
      _socket_free_entry (so);
#endif   /* SAVE_SOCK_ENDPOINTS */

#ifdef IP_MULTICAST
   /* multicast opts? */
   if (so->inp_moptions)
 322fadc:	e0bfff17 	ldw	r2,-4(fp)
 322fae0:	10800317 	ldw	r2,12(r2)
 322fae4:	1005003a 	cmpeq	r2,r2,zero
 322fae8:	1000031e 	bne	r2,zero,322faf8 <sofree+0xbc>
	   ip_freemoptions(so->inp_moptions);
 322faec:	e0bfff17 	ldw	r2,-4(fp)
 322faf0:	11000317 	ldw	r4,12(r2)
 322faf4:	32469400 	call	3246940 <ip_freemoptions>
#endif   /* IP_MULTICAST */

   /* IP_TOS opts? */
   if (so->so_optsPack)
 322faf8:	e0bfff17 	ldw	r2,-4(fp)
 322fafc:	10801f17 	ldw	r2,124(r2)
 322fb00:	1005003a 	cmpeq	r2,r2,zero
 322fb04:	1000031e 	bne	r2,zero,322fb14 <sofree+0xd8>
      SOCOPT_FREE(so->so_optsPack);
 322fb08:	e0bfff17 	ldw	r2,-4(fp)
 322fb0c:	11001f17 	ldw	r4,124(r2)
 322fb10:	322ba280 	call	322ba28 <npfree>
	   
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 322fb14:	0100c9b4 	movhi	r4,806
 322fb18:	21348204 	addi	r4,r4,-11768
 322fb1c:	e17fff17 	ldw	r5,-4(fp)
 322fb20:	322a9300 	call	322a930 <qdel>
   
   if (so_evtmap)  
 322fb24:	0080c974 	movhi	r2,805
 322fb28:	10936704 	addi	r2,r2,19868
 322fb2c:	10800003 	ldbu	r2,0(r2)
 322fb30:	10803fcc 	andi	r2,r2,255
 322fb34:	1005003a 	cmpeq	r2,r2,zero
 322fb38:	1000051e 	bne	r2,zero,322fb50 <sofree+0x114>
      (*so_evtmap_delete) (so);
 322fb3c:	0080c974 	movhi	r2,805
 322fb40:	10936604 	addi	r2,r2,19864
 322fb44:	10800017 	ldw	r2,0(r2)
 322fb48:	e13fff17 	ldw	r4,-4(fp)
 322fb4c:	103ee83a 	callr	r2
   
   SOC_FREE(so);
 322fb50:	e13fff17 	ldw	r4,-4(fp)
 322fb54:	322ba280 	call	322ba28 <npfree>
}
 322fb58:	e037883a 	mov	sp,fp
 322fb5c:	dfc00117 	ldw	ra,4(sp)
 322fb60:	df000017 	ldw	fp,0(sp)
 322fb64:	dec00204 	addi	sp,sp,8
 322fb68:	f800283a 	ret

0322fb6c <soclose>:
 * RETURNS: 
 */

int
soclose(struct socket * so)
{
 322fb6c:	defff804 	addi	sp,sp,-32
 322fb70:	dfc00715 	stw	ra,28(sp)
 322fb74:	df000615 	stw	fp,24(sp)
 322fb78:	df000604 	addi	fp,sp,24
 322fb7c:	e13ffe15 	stw	r4,-8(fp)
   int   error =  0;
 322fb80:	e03ffd15 	stw	zero,-12(fp)
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 322fb84:	0080c9b4 	movhi	r2,806
 322fb88:	10b48204 	addi	r2,r2,-11768
 322fb8c:	10800017 	ldw	r2,0(r2)
 322fb90:	e0bffc15 	stw	r2,-16(fp)
 322fb94:	00000606 	br	322fbb0 <soclose+0x44>
   {
      if (so == tmpso)
 322fb98:	e0fffe17 	ldw	r3,-8(fp)
 322fb9c:	e0bffc17 	ldw	r2,-16(fp)
 322fba0:	18800626 	beq	r3,r2,322fbbc <soclose+0x50>
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 322fba4:	e0bffc17 	ldw	r2,-16(fp)
 322fba8:	10800017 	ldw	r2,0(r2)
 322fbac:	e0bffc15 	stw	r2,-16(fp)
 322fbb0:	e0bffc17 	ldw	r2,-16(fp)
 322fbb4:	1004c03a 	cmpne	r2,r2,zero
 322fbb8:	103ff71e 	bne	r2,zero,322fb98 <soclose+0x2c>
   {
      if (so == tmpso)
         break;
   }
   if ( tmpso == NULL)
 322fbbc:	e0bffc17 	ldw	r2,-16(fp)
 322fbc0:	1004c03a 	cmpne	r2,r2,zero
 322fbc4:	1000031e 	bne	r2,zero,322fbd4 <soclose+0x68>
      return EINVAL;
 322fbc8:	00800584 	movi	r2,22
 322fbcc:	e0bfff15 	stw	r2,-4(fp)
 322fbd0:	00009d06 	br	322fe48 <soclose+0x2dc>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
 322fbd4:	e0bffe17 	ldw	r2,-8(fp)
 322fbd8:	10800417 	ldw	r2,16(r2)
 322fbdc:	1080008c 	andi	r2,r2,2
 322fbe0:	1005003a 	cmpeq	r2,r2,zero
 322fbe4:	1000101e 	bne	r2,zero,322fc28 <soclose+0xbc>
   {
      while (so->so_q0 != so)
 322fbe8:	00000306 	br	322fbf8 <soclose+0x8c>
         (void) soabort(so->so_q0);
 322fbec:	e0bffe17 	ldw	r2,-8(fp)
 322fbf0:	11001c17 	ldw	r4,112(r2)
 322fbf4:	322fe600 	call	322fe60 <soabort>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
 322fbf8:	e0bffe17 	ldw	r2,-8(fp)
 322fbfc:	10c01c17 	ldw	r3,112(r2)
 322fc00:	e0bffe17 	ldw	r2,-8(fp)
 322fc04:	18bff91e 	bne	r3,r2,322fbec <soclose+0x80>
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 322fc08:	00000306 	br	322fc18 <soclose+0xac>
         (void) soabort(so->so_q);
 322fc0c:	e0bffe17 	ldw	r2,-8(fp)
 322fc10:	11001d17 	ldw	r4,116(r2)
 322fc14:	322fe600 	call	322fe60 <soabort>
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 322fc18:	e0bffe17 	ldw	r2,-8(fp)
 322fc1c:	10c01d17 	ldw	r3,116(r2)
 322fc20:	e0bffe17 	ldw	r2,-8(fp)
 322fc24:	18bff91e 	bne	r3,r2,322fc0c <soclose+0xa0>
         (void) soabort(so->so_q);
   }
   /* for datagram-oriented sockets, dispense with further tests */
   if (so->so_type != SOCK_STREAM)
 322fc28:	e0bffe17 	ldw	r2,-8(fp)
 322fc2c:	10800983 	ldbu	r2,38(r2)
 322fc30:	10803fcc 	andi	r2,r2,255
 322fc34:	1080201c 	xori	r2,r2,128
 322fc38:	10bfe004 	addi	r2,r2,-128
 322fc3c:	10800060 	cmpeqi	r2,r2,1
 322fc40:	10000c1e 	bne	r2,zero,322fc74 <soclose+0x108>
   { 
      so->so_req = PRU_DETACH;
 322fc44:	e0fffe17 	ldw	r3,-8(fp)
 322fc48:	00800044 	movi	r2,1
 322fc4c:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so,
 322fc50:	e0bffe17 	ldw	r2,-8(fp)
 322fc54:	10800217 	ldw	r2,8(r2)
 322fc58:	10800317 	ldw	r2,12(r2)
 322fc5c:	e13ffe17 	ldw	r4,-8(fp)
 322fc60:	000b883a 	mov	r5,zero
 322fc64:	000d883a 	mov	r6,zero
 322fc68:	103ee83a 	callr	r2
 322fc6c:	e0bffd15 	stw	r2,-12(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
 322fc70:	00006306 	br	322fe00 <soclose+0x294>
   }

   if (so->so_pcb == 0)
 322fc74:	e0bffe17 	ldw	r2,-8(fp)
 322fc78:	10800117 	ldw	r2,4(r2)
 322fc7c:	1005003a 	cmpeq	r2,r2,zero
 322fc80:	10005f1e 	bne	r2,zero,322fe00 <soclose+0x294>
      goto discard;
   if (so->so_state & SS_ISCONNECTED) 
 322fc84:	e0bffe17 	ldw	r2,-8(fp)
 322fc88:	1080088b 	ldhu	r2,34(r2)
 322fc8c:	10bfffcc 	andi	r2,r2,65535
 322fc90:	1080008c 	andi	r2,r2,2
 322fc94:	1005003a 	cmpeq	r2,r2,zero
 322fc98:	1000451e 	bne	r2,zero,322fdb0 <soclose+0x244>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
 322fc9c:	e0bffe17 	ldw	r2,-8(fp)
 322fca0:	1080088b 	ldhu	r2,34(r2)
 322fca4:	10bfffcc 	andi	r2,r2,65535
 322fca8:	1080020c 	andi	r2,r2,8
 322fcac:	1004c03a 	cmpne	r2,r2,zero
 322fcb0:	1000061e 	bne	r2,zero,322fccc <soclose+0x160>
      {
         error = sodisconnect(so);
 322fcb4:	e13ffe17 	ldw	r4,-8(fp)
 322fcb8:	32300200 	call	3230020 <sodisconnect>
 322fcbc:	e0bffd15 	stw	r2,-12(fp)
         if (error)
 322fcc0:	e0bffd17 	ldw	r2,-12(fp)
 322fcc4:	1004c03a 	cmpne	r2,r2,zero
 322fcc8:	1000391e 	bne	r2,zero,322fdb0 <soclose+0x244>
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
 322fccc:	e0bffe17 	ldw	r2,-8(fp)
 322fcd0:	10800417 	ldw	r2,16(r2)
 322fcd4:	1080200c 	andi	r2,r2,128
 322fcd8:	1005003a 	cmpeq	r2,r2,zero
 322fcdc:	1000281e 	bne	r2,zero,322fd80 <soclose+0x214>
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 322fce0:	e0bffe17 	ldw	r2,-8(fp)
 322fce4:	1080088b 	ldhu	r2,34(r2)
 322fce8:	10bfffcc 	andi	r2,r2,65535
 322fcec:	1080020c 	andi	r2,r2,8
 322fcf0:	1005003a 	cmpeq	r2,r2,zero
 322fcf4:	1000061e 	bne	r2,zero,322fd10 <soclose+0x1a4>
 322fcf8:	e0bffe17 	ldw	r2,-8(fp)
 322fcfc:	1080088b 	ldhu	r2,34(r2)
 322fd00:	10bfffcc 	andi	r2,r2,65535
 322fd04:	1080400c 	andi	r2,r2,256
 322fd08:	1004c03a 	cmpne	r2,r2,zero
 322fd0c:	1000281e 	bne	r2,zero,322fdb0 <soclose+0x244>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
 322fd10:	e0bffe17 	ldw	r2,-8(fp)
 322fd14:	1080080b 	ldhu	r2,32(r2)
 322fd18:	10bfffcc 	andi	r2,r2,65535
 322fd1c:	10a0001c 	xori	r2,r2,32768
 322fd20:	10a00004 	addi	r2,r2,-32768
 322fd24:	10c0fa24 	muli	r3,r2,1000
 322fd28:	0080c974 	movhi	r2,805
 322fd2c:	10934104 	addi	r2,r2,19716
 322fd30:	10800017 	ldw	r2,0(r2)
 322fd34:	1885883a 	add	r2,r3,r2
 322fd38:	e0bffb15 	stw	r2,-20(fp)
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 322fd3c:	00000406 	br	322fd50 <soclose+0x1e4>
         {
            tcp_sleep((char *)&so->so_timeo);
 322fd40:	e0bffe17 	ldw	r2,-8(fp)
 322fd44:	10800904 	addi	r2,r2,36
 322fd48:	1009883a 	mov	r4,r2
 322fd4c:	3226ac40 	call	3226ac4 <tcp_sleep>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 322fd50:	e0bffe17 	ldw	r2,-8(fp)
 322fd54:	1080088b 	ldhu	r2,34(r2)
 322fd58:	10bfffcc 	andi	r2,r2,65535
 322fd5c:	1080008c 	andi	r2,r2,2
 322fd60:	1005003a 	cmpeq	r2,r2,zero
 322fd64:	1000121e 	bne	r2,zero,322fdb0 <soclose+0x244>
 322fd68:	0080c974 	movhi	r2,805
 322fd6c:	10934104 	addi	r2,r2,19716
 322fd70:	10c00017 	ldw	r3,0(r2)
 322fd74:	e0bffb17 	ldw	r2,-20(fp)
 322fd78:	18bff136 	bltu	r3,r2,322fd40 <soclose+0x1d4>
 322fd7c:	00000c06 	br	322fdb0 <soclose+0x244>
      {
         /* If socket still has send data just return now, leaving the 
          * socket intact so the data can be sent. Socket should be cleaned
          * up later by timers.
          */
         if(so->so_snd.sb_cc)
 322fd80:	e0bffe17 	ldw	r2,-8(fp)
 322fd84:	10801217 	ldw	r2,72(r2)
 322fd88:	1005003a 	cmpeq	r2,r2,zero
 322fd8c:	1000081e 	bne	r2,zero,322fdb0 <soclose+0x244>
         {
            so->so_state |= SS_NOFDREF;   /* mark as OK to close */
 322fd90:	e0bffe17 	ldw	r2,-8(fp)
 322fd94:	1080088b 	ldhu	r2,34(r2)
 322fd98:	10800054 	ori	r2,r2,1
 322fd9c:	1007883a 	mov	r3,r2
 322fda0:	e0bffe17 	ldw	r2,-8(fp)
 322fda4:	10c0088d 	sth	r3,34(r2)
            return 0;
 322fda8:	e03fff15 	stw	zero,-4(fp)
 322fdac:	00002606 	br	322fe48 <soclose+0x2dc>
         }
      }
   }
drop:
   if (so->so_pcb) 
 322fdb0:	e0bffe17 	ldw	r2,-8(fp)
 322fdb4:	10800117 	ldw	r2,4(r2)
 322fdb8:	1005003a 	cmpeq	r2,r2,zero
 322fdbc:	1000101e 	bne	r2,zero,322fe00 <soclose+0x294>
   {
      int   error2;
      so->so_req = PRU_DETACH;
 322fdc0:	e0fffe17 	ldw	r3,-8(fp)
 322fdc4:	00800044 	movi	r2,1
 322fdc8:	18800715 	stw	r2,28(r3)
      error2 = (*so->so_proto->pr_usrreq)(so,
 322fdcc:	e0bffe17 	ldw	r2,-8(fp)
 322fdd0:	10800217 	ldw	r2,8(r2)
 322fdd4:	10800317 	ldw	r2,12(r2)
 322fdd8:	e13ffe17 	ldw	r4,-8(fp)
 322fddc:	000b883a 	mov	r5,zero
 322fde0:	000d883a 	mov	r6,zero
 322fde4:	103ee83a 	callr	r2
 322fde8:	e0bffa15 	stw	r2,-24(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
 322fdec:	e0bffd17 	ldw	r2,-12(fp)
 322fdf0:	1004c03a 	cmpne	r2,r2,zero
 322fdf4:	1000021e 	bne	r2,zero,322fe00 <soclose+0x294>
         error = error2;
 322fdf8:	e0bffa17 	ldw	r2,-24(fp)
 322fdfc:	e0bffd15 	stw	r2,-12(fp)
   }
discard:
   if (so->so_state & SS_NOFDREF)
 322fe00:	e0bffe17 	ldw	r2,-8(fp)
 322fe04:	1080088b 	ldhu	r2,34(r2)
 322fe08:	10bfffcc 	andi	r2,r2,65535
 322fe0c:	1080004c 	andi	r2,r2,1
 322fe10:	10803fcc 	andi	r2,r2,255
 322fe14:	1005003a 	cmpeq	r2,r2,zero
 322fe18:	1000011e 	bne	r2,zero,322fe20 <soclose+0x2b4>
   {
      /* panic("soclose");  - non-fatal - degrade to dtrap() for now */
      dtrap();
 322fe1c:	322aef00 	call	322aef0 <dtrap>
   }
   so->so_state |= SS_NOFDREF;
 322fe20:	e0bffe17 	ldw	r2,-8(fp)
 322fe24:	1080088b 	ldhu	r2,34(r2)
 322fe28:	10800054 	ori	r2,r2,1
 322fe2c:	1007883a 	mov	r3,r2
 322fe30:	e0bffe17 	ldw	r2,-8(fp)
 322fe34:	10c0088d 	sth	r3,34(r2)
   sofree(so);
 322fe38:	e13ffe17 	ldw	r4,-8(fp)
 322fe3c:	322fa3c0 	call	322fa3c <sofree>
   return (error);
 322fe40:	e0bffd17 	ldw	r2,-12(fp)
 322fe44:	e0bfff15 	stw	r2,-4(fp)
 322fe48:	e0bfff17 	ldw	r2,-4(fp)
}
 322fe4c:	e037883a 	mov	sp,fp
 322fe50:	dfc00117 	ldw	ra,4(sp)
 322fe54:	df000017 	ldw	fp,0(sp)
 322fe58:	dec00204 	addi	sp,sp,8
 322fe5c:	f800283a 	ret

0322fe60 <soabort>:
 * RETURNS: 
 */

int
soabort(struct socket * so)
{
 322fe60:	defffd04 	addi	sp,sp,-12
 322fe64:	dfc00215 	stw	ra,8(sp)
 322fe68:	df000115 	stw	fp,4(sp)
 322fe6c:	df000104 	addi	fp,sp,4
 322fe70:	e13fff15 	stw	r4,-4(fp)
   so->so_req = PRU_ABORT;
 322fe74:	e0ffff17 	ldw	r3,-4(fp)
 322fe78:	00800284 	movi	r2,10
 322fe7c:	18800715 	stw	r2,28(r3)
   return(*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 322fe80:	e0bfff17 	ldw	r2,-4(fp)
 322fe84:	10800217 	ldw	r2,8(r2)
 322fe88:	10800317 	ldw	r2,12(r2)
 322fe8c:	e13fff17 	ldw	r4,-4(fp)
 322fe90:	000b883a 	mov	r5,zero
 322fe94:	000d883a 	mov	r6,zero
 322fe98:	103ee83a 	callr	r2
}
 322fe9c:	e037883a 	mov	sp,fp
 322fea0:	dfc00117 	ldw	ra,4(sp)
 322fea4:	df000017 	ldw	fp,0(sp)
 322fea8:	dec00204 	addi	sp,sp,8
 322feac:	f800283a 	ret

0322feb0 <soaccept>:
 */

int
soaccept(struct socket * so, 
   struct mbuf *  nam)
{
 322feb0:	defffb04 	addi	sp,sp,-20
 322feb4:	dfc00415 	stw	ra,16(sp)
 322feb8:	df000315 	stw	fp,12(sp)
 322febc:	df000304 	addi	fp,sp,12
 322fec0:	e13ffe15 	stw	r4,-8(fp)
 322fec4:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if ((so->so_state & SS_NOFDREF) == 0)
 322fec8:	e0bffe17 	ldw	r2,-8(fp)
 322fecc:	1080088b 	ldhu	r2,34(r2)
 322fed0:	10bfffcc 	andi	r2,r2,65535
 322fed4:	1080004c 	andi	r2,r2,1
 322fed8:	1004c03a 	cmpne	r2,r2,zero
 322fedc:	1000031e 	bne	r2,zero,322feec <soaccept+0x3c>
      panic("soaccept");
 322fee0:	0100c974 	movhi	r4,805
 322fee4:	213e3304 	addi	r4,r4,-1844
 322fee8:	32261540 	call	3226154 <panic>
   so->so_state &= ~SS_NOFDREF;
 322feec:	e0bffe17 	ldw	r2,-8(fp)
 322fef0:	10c0088b 	ldhu	r3,34(r2)
 322fef4:	00bfff84 	movi	r2,-2
 322fef8:	1884703a 	and	r2,r3,r2
 322fefc:	1007883a 	mov	r3,r2
 322ff00:	e0bffe17 	ldw	r2,-8(fp)
 322ff04:	10c0088d 	sth	r3,34(r2)
   so->so_req = PRU_ACCEPT;
 322ff08:	e0fffe17 	ldw	r3,-8(fp)
 322ff0c:	00800144 	movi	r2,5
 322ff10:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 322ff14:	e0bffe17 	ldw	r2,-8(fp)
 322ff18:	10800217 	ldw	r2,8(r2)
 322ff1c:	10800317 	ldw	r2,12(r2)
 322ff20:	e13ffe17 	ldw	r4,-8(fp)
 322ff24:	000b883a 	mov	r5,zero
 322ff28:	e1bfff17 	ldw	r6,-4(fp)
 322ff2c:	103ee83a 	callr	r2
 322ff30:	e0bffd15 	stw	r2,-12(fp)

   return (error);
 322ff34:	e0bffd17 	ldw	r2,-12(fp)
}
 322ff38:	e037883a 	mov	sp,fp
 322ff3c:	dfc00117 	ldw	ra,4(sp)
 322ff40:	df000017 	ldw	fp,0(sp)
 322ff44:	dec00204 	addi	sp,sp,8
 322ff48:	f800283a 	ret

0322ff4c <soconnect>:
 */

int
soconnect(struct socket * so, 
   struct mbuf *  nam)
{
 322ff4c:	defffa04 	addi	sp,sp,-24
 322ff50:	dfc00515 	stw	ra,20(sp)
 322ff54:	df000415 	stw	fp,16(sp)
 322ff58:	df000404 	addi	fp,sp,16
 322ff5c:	e13ffd15 	stw	r4,-12(fp)
 322ff60:	e17ffe15 	stw	r5,-8(fp)
   int   error;

   if (so->so_options & SO_ACCEPTCONN)
 322ff64:	e0bffd17 	ldw	r2,-12(fp)
 322ff68:	10800417 	ldw	r2,16(r2)
 322ff6c:	1080008c 	andi	r2,r2,2
 322ff70:	1005003a 	cmpeq	r2,r2,zero
 322ff74:	1000031e 	bne	r2,zero,322ff84 <soconnect+0x38>
      return (EOPNOTSUPP);
 322ff78:	008017c4 	movi	r2,95
 322ff7c:	e0bfff15 	stw	r2,-4(fp)
 322ff80:	00002106 	br	3230008 <soconnect+0xbc>
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 322ff84:	e0bffd17 	ldw	r2,-12(fp)
 322ff88:	1080088b 	ldhu	r2,34(r2)
 322ff8c:	10bfffcc 	andi	r2,r2,65535
 322ff90:	1080018c 	andi	r2,r2,6
 322ff94:	1005003a 	cmpeq	r2,r2,zero
 322ff98:	10000e1e 	bne	r2,zero,322ffd4 <soconnect+0x88>
 322ff9c:	e0bffd17 	ldw	r2,-12(fp)
 322ffa0:	10800217 	ldw	r2,8(r2)
 322ffa4:	1080010b 	ldhu	r2,4(r2)
 322ffa8:	10bfffcc 	andi	r2,r2,65535
 322ffac:	1080010c 	andi	r2,r2,4
 322ffb0:	1004c03a 	cmpne	r2,r2,zero
 322ffb4:	1000041e 	bne	r2,zero,322ffc8 <soconnect+0x7c>
 322ffb8:	e13ffd17 	ldw	r4,-12(fp)
 322ffbc:	32300200 	call	3230020 <sodisconnect>
 322ffc0:	1005003a 	cmpeq	r2,r2,zero
 322ffc4:	1000031e 	bne	r2,zero,322ffd4 <soconnect+0x88>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
       (sodisconnect(so) != 0)))
   {
      error = EISCONN;
 322ffc8:	00801fc4 	movi	r2,127
 322ffcc:	e0bffc15 	stw	r2,-16(fp)
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 322ffd0:	00000b06 	br	3230000 <soconnect+0xb4>
   {
      error = EISCONN;
   }
   else
   {
      so->so_req = PRU_CONNECT;
 322ffd4:	e0fffd17 	ldw	r3,-12(fp)
 322ffd8:	00800104 	movi	r2,4
 322ffdc:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 322ffe0:	e0bffd17 	ldw	r2,-12(fp)
 322ffe4:	10800217 	ldw	r2,8(r2)
 322ffe8:	10800317 	ldw	r2,12(r2)
 322ffec:	e13ffd17 	ldw	r4,-12(fp)
 322fff0:	000b883a 	mov	r5,zero
 322fff4:	e1bffe17 	ldw	r6,-8(fp)
 322fff8:	103ee83a 	callr	r2
 322fffc:	e0bffc15 	stw	r2,-16(fp)
   }
   return error;
 3230000:	e0bffc17 	ldw	r2,-16(fp)
 3230004:	e0bfff15 	stw	r2,-4(fp)
 3230008:	e0bfff17 	ldw	r2,-4(fp)
}
 323000c:	e037883a 	mov	sp,fp
 3230010:	dfc00117 	ldw	ra,4(sp)
 3230014:	df000017 	ldw	fp,0(sp)
 3230018:	dec00204 	addi	sp,sp,8
 323001c:	f800283a 	ret

03230020 <sodisconnect>:
 * RETURNS: 
 */

int
sodisconnect(struct socket * so)
{
 3230020:	defffc04 	addi	sp,sp,-16
 3230024:	dfc00315 	stw	ra,12(sp)
 3230028:	df000215 	stw	fp,8(sp)
 323002c:	df000204 	addi	fp,sp,8
 3230030:	e13fff15 	stw	r4,-4(fp)
   int   error;

   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sodisconnect, so %lx so_state %x\n", so, so->so_state));

   if ((so->so_state & SS_ISCONNECTED) == 0) 
 3230034:	e0bfff17 	ldw	r2,-4(fp)
 3230038:	1080088b 	ldhu	r2,34(r2)
 323003c:	10bfffcc 	andi	r2,r2,65535
 3230040:	1080008c 	andi	r2,r2,2
 3230044:	1004c03a 	cmpne	r2,r2,zero
 3230048:	1000031e 	bne	r2,zero,3230058 <sodisconnect+0x38>
   {
      error = ENOTCONN;
 323004c:	00802004 	movi	r2,128
 3230050:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 3230054:	00001406 	br	32300a8 <sodisconnect+0x88>
   }
   if (so->so_state & SS_ISDISCONNECTING) 
 3230058:	e0bfff17 	ldw	r2,-4(fp)
 323005c:	1080088b 	ldhu	r2,34(r2)
 3230060:	10bfffcc 	andi	r2,r2,65535
 3230064:	1080020c 	andi	r2,r2,8
 3230068:	1005003a 	cmpeq	r2,r2,zero
 323006c:	1000031e 	bne	r2,zero,323007c <sodisconnect+0x5c>
   {
      error = EALREADY;
 3230070:	00801e04 	movi	r2,120
 3230074:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 3230078:	00000b06 	br	32300a8 <sodisconnect+0x88>
   }
   so->so_req = PRU_DISCONNECT;
 323007c:	e0ffff17 	ldw	r3,-4(fp)
 3230080:	00800184 	movi	r2,6
 3230084:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 3230088:	e0bfff17 	ldw	r2,-4(fp)
 323008c:	10800217 	ldw	r2,8(r2)
 3230090:	10800317 	ldw	r2,12(r2)
 3230094:	e13fff17 	ldw	r4,-4(fp)
 3230098:	000b883a 	mov	r5,zero
 323009c:	000d883a 	mov	r6,zero
 32300a0:	103ee83a 	callr	r2
 32300a4:	e0bffe15 	stw	r2,-8(fp)

bad:
   return (error);
 32300a8:	e0bffe17 	ldw	r2,-8(fp)
}
 32300ac:	e037883a 	mov	sp,fp
 32300b0:	dfc00117 	ldw	ra,4(sp)
 32300b4:	df000017 	ldw	fp,0(sp)
 32300b8:	dec00204 	addi	sp,sp,8
 32300bc:	f800283a 	ret

032300c0 <sosend>:
sosend(struct socket *so, 
       struct mbuf *nam,      /* sockaddr, if UDP socket, NULL if TCP */
       char  *data,           /* data to send */
       int   *data_length,    /* IN/OUT  length of (remaining) data */
       int   flags)
{
 32300c0:	deffee04 	addi	sp,sp,-72
 32300c4:	dfc01115 	stw	ra,68(sp)
 32300c8:	df001015 	stw	fp,64(sp)
 32300cc:	df001004 	addi	fp,sp,64
 32300d0:	e13ff815 	stw	r4,-32(fp)
 32300d4:	e17ff915 	stw	r5,-28(fp)
 32300d8:	e1bffa15 	stw	r6,-24(fp)
 32300dc:	e1fffb15 	stw	r7,-20(fp)
   struct mbuf *head = (struct mbuf *)NULL;
 32300e0:	e03ff715 	stw	zero,-36(fp)
   struct mbuf *m;
   int   space;
   int   resid;
   int   len;
   int   error = 0;
 32300e4:	e03ff215 	stw	zero,-56(fp)
   int   dontroute;
   int   first = 1;
 32300e8:	00800044 	movi	r2,1
 32300ec:	e0bff015 	stw	r2,-64(fp)

   resid = *data_length;
 32300f0:	e0bffb17 	ldw	r2,-20(fp)
 32300f4:	10800017 	ldw	r2,0(r2)
 32300f8:	e0bff415 	stw	r2,-48(fp)
    * However, space must be signed, as it might be less than 0
    * if we over-committed, and we must use a signed comparison
    * of space and resid.  On the other hand, a negative resid
    * causes us to loop sending 0-length segments to the protocol.
    */
   if (resid < 0)
 32300fc:	e0bff417 	ldw	r2,-48(fp)
 3230100:	1004403a 	cmpge	r2,r2,zero
 3230104:	1000031e 	bne	r2,zero,3230114 <sosend+0x54>
      return (EINVAL);
 3230108:	00800584 	movi	r2,22
 323010c:	e0bfff15 	stw	r2,-4(fp)
 3230110:	00016706 	br	32306b0 <sosend+0x5f0>

   INET_TRACE (INETM_IO, ("INET:sosend: so %lx resid %d sb_hiwat %d so_state %x\n",
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
 3230114:	e0bff817 	ldw	r2,-32(fp)
 3230118:	10800217 	ldw	r2,8(r2)
 323011c:	1080010b 	ldhu	r2,4(r2)
 3230120:	10bfffcc 	andi	r2,r2,65535
 3230124:	1080004c 	andi	r2,r2,1
 3230128:	10803fcc 	andi	r2,r2,255
 323012c:	1005003a 	cmpeq	r2,r2,zero
 3230130:	1000081e 	bne	r2,zero,3230154 <sosend+0x94>
 3230134:	e0bff817 	ldw	r2,-32(fp)
 3230138:	10801317 	ldw	r2,76(r2)
 323013c:	1007883a 	mov	r3,r2
 3230140:	e0bff417 	ldw	r2,-48(fp)
 3230144:	1880030e 	bge	r3,r2,3230154 <sosend+0x94>
      return (EMSGSIZE);
 3230148:	00c01e84 	movi	r3,122
 323014c:	e0ffff15 	stw	r3,-4(fp)
 3230150:	00015706 	br	32306b0 <sosend+0x5f0>

   dontroute = (flags & MSG_DONTROUTE) &&
 3230154:	e0800217 	ldw	r2,8(fp)
 3230158:	1080010c 	andi	r2,r2,4
 323015c:	1005003a 	cmpeq	r2,r2,zero
 3230160:	1000111e 	bne	r2,zero,32301a8 <sosend+0xe8>
 3230164:	e0bff817 	ldw	r2,-32(fp)
 3230168:	10800417 	ldw	r2,16(r2)
 323016c:	1080040c 	andi	r2,r2,16
 3230170:	1004c03a 	cmpne	r2,r2,zero
 3230174:	10000c1e 	bne	r2,zero,32301a8 <sosend+0xe8>
 3230178:	e0bff817 	ldw	r2,-32(fp)
 323017c:	10800217 	ldw	r2,8(r2)
 3230180:	1080010b 	ldhu	r2,4(r2)
 3230184:	10bfffcc 	andi	r2,r2,65535
 3230188:	1080004c 	andi	r2,r2,1
 323018c:	1080005c 	xori	r2,r2,1
 3230190:	10803fcc 	andi	r2,r2,255
 3230194:	1004c03a 	cmpne	r2,r2,zero
 3230198:	1000031e 	bne	r2,zero,32301a8 <sosend+0xe8>
 323019c:	00800044 	movi	r2,1
 32301a0:	e0bffe15 	stw	r2,-8(fp)
 32301a4:	00000106 	br	32301ac <sosend+0xec>
 32301a8:	e03ffe15 	stw	zero,-8(fp)
 32301ac:	e0fffe17 	ldw	r3,-8(fp)
 32301b0:	e0fff115 	stw	r3,-60(fp)
               (so->so_proto->pr_flags & PR_ATOMIC);

#define     snderr(errno)     {  error =  errno;   goto  release; }

restart:
   sblock(&so->so_snd);
 32301b4:	00000406 	br	32301c8 <sosend+0x108>
 32301b8:	e0bff817 	ldw	r2,-32(fp)
 32301bc:	10801904 	addi	r2,r2,100
 32301c0:	1009883a 	mov	r4,r2
 32301c4:	3226ac40 	call	3226ac4 <tcp_sleep>
 32301c8:	e0bff817 	ldw	r2,-32(fp)
 32301cc:	1080190b 	ldhu	r2,100(r2)
 32301d0:	10bfffcc 	andi	r2,r2,65535
 32301d4:	1080004c 	andi	r2,r2,1
 32301d8:	10803fcc 	andi	r2,r2,255
 32301dc:	1004c03a 	cmpne	r2,r2,zero
 32301e0:	103ff51e 	bne	r2,zero,32301b8 <sosend+0xf8>
 32301e4:	e0bff817 	ldw	r2,-32(fp)
 32301e8:	1080190b 	ldhu	r2,100(r2)
 32301ec:	10800054 	ori	r2,r2,1
 32301f0:	1007883a 	mov	r3,r2
 32301f4:	e0bff817 	ldw	r2,-32(fp)
 32301f8:	10c0190d 	sth	r3,100(r2)
   do 
   {
      if (so->so_error) 
 32301fc:	e0bff817 	ldw	r2,-32(fp)
 3230200:	10800617 	ldw	r2,24(r2)
 3230204:	1005003a 	cmpeq	r2,r2,zero
 3230208:	1000061e 	bne	r2,zero,3230224 <sosend+0x164>
      {
         error = so->so_error;
 323020c:	e0bff817 	ldw	r2,-32(fp)
 3230210:	10800617 	ldw	r2,24(r2)
 3230214:	e0bff215 	stw	r2,-56(fp)
         so->so_error = 0;          /* ??? */
 3230218:	e0bff817 	ldw	r2,-32(fp)
 323021c:	10000615 	stw	zero,24(r2)
         goto release;
 3230220:	00011106 	br	3230668 <sosend+0x5a8>
      }
      if (so->so_state & SS_CANTSENDMORE)
 3230224:	e0bff817 	ldw	r2,-32(fp)
 3230228:	1080088b 	ldhu	r2,34(r2)
 323022c:	10bfffcc 	andi	r2,r2,65535
 3230230:	1080040c 	andi	r2,r2,16
 3230234:	1005003a 	cmpeq	r2,r2,zero
 3230238:	1000031e 	bne	r2,zero,3230248 <sosend+0x188>
         snderr(EPIPE);
 323023c:	00800804 	movi	r2,32
 3230240:	e0bff215 	stw	r2,-56(fp)
 3230244:	00010806 	br	3230668 <sosend+0x5a8>
      if ((so->so_state & SS_ISCONNECTED) == 0) 
 3230248:	e0bff817 	ldw	r2,-32(fp)
 323024c:	1080088b 	ldhu	r2,34(r2)
 3230250:	10bfffcc 	andi	r2,r2,65535
 3230254:	1080008c 	andi	r2,r2,2
 3230258:	1004c03a 	cmpne	r2,r2,zero
 323025c:	1000101e 	bne	r2,zero,32302a0 <sosend+0x1e0>
      {
         if (so->so_proto->pr_flags & PR_CONNREQUIRED)
 3230260:	e0bff817 	ldw	r2,-32(fp)
 3230264:	10800217 	ldw	r2,8(r2)
 3230268:	1080010b 	ldhu	r2,4(r2)
 323026c:	10bfffcc 	andi	r2,r2,65535
 3230270:	1080010c 	andi	r2,r2,4
 3230274:	1005003a 	cmpeq	r2,r2,zero
 3230278:	1000031e 	bne	r2,zero,3230288 <sosend+0x1c8>
            snderr(ENOTCONN);
 323027c:	00802004 	movi	r2,128
 3230280:	e0bff215 	stw	r2,-56(fp)
 3230284:	0000f806 	br	3230668 <sosend+0x5a8>
         if (nam == 0)
 3230288:	e0bff917 	ldw	r2,-28(fp)
 323028c:	1004c03a 	cmpne	r2,r2,zero
 3230290:	1000031e 	bne	r2,zero,32302a0 <sosend+0x1e0>
            snderr(EDESTADDRREQ);
 3230294:	00801e44 	movi	r2,121
 3230298:	e0bff215 	stw	r2,-56(fp)
 323029c:	0000f206 	br	3230668 <sosend+0x5a8>
      }
      if (flags & MSG_OOB)
 32302a0:	e0800217 	ldw	r2,8(fp)
 32302a4:	1080004c 	andi	r2,r2,1
 32302a8:	10803fcc 	andi	r2,r2,255
 32302ac:	1005003a 	cmpeq	r2,r2,zero
 32302b0:	1000031e 	bne	r2,zero,32302c0 <sosend+0x200>
         space = 1024;
 32302b4:	00810004 	movi	r2,1024
 32302b8:	e0bff515 	stw	r2,-44(fp)
 32302bc:	00005106 	br	3230404 <sosend+0x344>
      else 
      {
         space = (int)sbspace(&so->so_snd);
 32302c0:	e0bff817 	ldw	r2,-32(fp)
 32302c4:	10801317 	ldw	r2,76(r2)
 32302c8:	1007883a 	mov	r3,r2
 32302cc:	e0bff817 	ldw	r2,-32(fp)
 32302d0:	10801217 	ldw	r2,72(r2)
 32302d4:	1885c83a 	sub	r2,r3,r2
 32302d8:	1004803a 	cmplt	r2,r2,zero
 32302dc:	1000071e 	bne	r2,zero,32302fc <sosend+0x23c>
 32302e0:	e0bff817 	ldw	r2,-32(fp)
 32302e4:	10c01317 	ldw	r3,76(r2)
 32302e8:	e0bff817 	ldw	r2,-32(fp)
 32302ec:	10801217 	ldw	r2,72(r2)
 32302f0:	1885c83a 	sub	r2,r3,r2
 32302f4:	e0bffd15 	stw	r2,-12(fp)
 32302f8:	00000106 	br	3230300 <sosend+0x240>
 32302fc:	e03ffd15 	stw	zero,-12(fp)
 3230300:	e0bffd17 	ldw	r2,-12(fp)
 3230304:	e0bff515 	stw	r2,-44(fp)
         if ((sosendallatonce(so) && (space < resid)) ||
 3230308:	e0bff817 	ldw	r2,-32(fp)
 323030c:	10800217 	ldw	r2,8(r2)
 3230310:	1080010b 	ldhu	r2,4(r2)
 3230314:	10bfffcc 	andi	r2,r2,65535
 3230318:	1080004c 	andi	r2,r2,1
 323031c:	1080005c 	xori	r2,r2,1
 3230320:	10803fcc 	andi	r2,r2,255
 3230324:	1004c03a 	cmpne	r2,r2,zero
 3230328:	1000031e 	bne	r2,zero,3230338 <sosend+0x278>
 323032c:	e0fff517 	ldw	r3,-44(fp)
 3230330:	e0bff417 	ldw	r2,-48(fp)
 3230334:	18801416 	blt	r3,r2,3230388 <sosend+0x2c8>
 3230338:	e0bff417 	ldw	r2,-48(fp)
 323033c:	10815e10 	cmplti	r2,r2,1400
 3230340:	1000301e 	bne	r2,zero,3230404 <sosend+0x344>
 3230344:	e0bff517 	ldw	r2,-44(fp)
 3230348:	10815e08 	cmpgei	r2,r2,1400
 323034c:	10002d1e 	bne	r2,zero,3230404 <sosend+0x344>
 3230350:	e0bff817 	ldw	r2,-32(fp)
 3230354:	10801217 	ldw	r2,72(r2)
 3230358:	10815e30 	cmpltui	r2,r2,1400
 323035c:	1000291e 	bne	r2,zero,3230404 <sosend+0x344>
 3230360:	e0bff817 	ldw	r2,-32(fp)
 3230364:	1080088b 	ldhu	r2,34(r2)
 3230368:	10bfffcc 	andi	r2,r2,65535
 323036c:	1080400c 	andi	r2,r2,256
 3230370:	1004c03a 	cmpne	r2,r2,zero
 3230374:	1000231e 	bne	r2,zero,3230404 <sosend+0x344>
 3230378:	e0800217 	ldw	r2,8(fp)
 323037c:	1080080c 	andi	r2,r2,32
 3230380:	1004c03a 	cmpne	r2,r2,zero
 3230384:	10001f1e 	bne	r2,zero,3230404 <sosend+0x344>
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
              ((flags & MSG_DONTWAIT) == 0)))
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 3230388:	e0bff817 	ldw	r2,-32(fp)
 323038c:	1080088b 	ldhu	r2,34(r2)
 3230390:	10bfffcc 	andi	r2,r2,65535
 3230394:	1080400c 	andi	r2,r2,256
 3230398:	1004c03a 	cmpne	r2,r2,zero
 323039c:	1000041e 	bne	r2,zero,32303b0 <sosend+0x2f0>
 32303a0:	e0800217 	ldw	r2,8(fp)
 32303a4:	1080080c 	andi	r2,r2,32
 32303a8:	1005003a 	cmpeq	r2,r2,zero
 32303ac:	1000061e 	bne	r2,zero,32303c8 <sosend+0x308>
            {
               if (first)
 32303b0:	e0bff017 	ldw	r2,-64(fp)
 32303b4:	1005003a 	cmpeq	r2,r2,zero
 32303b8:	1000ab1e 	bne	r2,zero,3230668 <sosend+0x5a8>
                  error = EWOULDBLOCK;
 32303bc:	008002c4 	movi	r2,11
 32303c0:	e0bff215 	stw	r2,-56(fp)
               goto release;
 32303c4:	0000a806 	br	3230668 <sosend+0x5a8>
            }
            sbunlock(&so->so_snd);
 32303c8:	e0bff817 	ldw	r2,-32(fp)
 32303cc:	10c0190b 	ldhu	r3,100(r2)
 32303d0:	00bfff84 	movi	r2,-2
 32303d4:	1884703a 	and	r2,r3,r2
 32303d8:	1007883a 	mov	r3,r2
 32303dc:	e0bff817 	ldw	r2,-32(fp)
 32303e0:	10c0190d 	sth	r3,100(r2)
 32303e4:	e0bff817 	ldw	r2,-32(fp)
 32303e8:	10801904 	addi	r2,r2,100
 32303ec:	1009883a 	mov	r4,r2
 32303f0:	3226c640 	call	3226c64 <tcp_wakeup>
            sbwait(&so->so_snd);
 32303f4:	e0bff817 	ldw	r2,-32(fp)
 32303f8:	11001204 	addi	r4,r2,72
 32303fc:	32322080 	call	3232208 <sbwait>
            goto restart;
 3230400:	003f7106 	br	32301c8 <sosend+0x108>
         }
      }
      if ( space <= 0 ) 
 3230404:	e0bff517 	ldw	r2,-44(fp)
 3230408:	10800048 	cmpgei	r2,r2,1
 323040c:	1000651e 	bne	r2,zero,32305a4 <sosend+0x4e4>
      {
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 3230410:	e0bff817 	ldw	r2,-32(fp)
 3230414:	1080088b 	ldhu	r2,34(r2)
 3230418:	10bfffcc 	andi	r2,r2,65535
 323041c:	1080400c 	andi	r2,r2,256
 3230420:	1004c03a 	cmpne	r2,r2,zero
 3230424:	1000041e 	bne	r2,zero,3230438 <sosend+0x378>
 3230428:	e0800217 	ldw	r2,8(fp)
 323042c:	1080080c 	andi	r2,r2,32
 3230430:	1005003a 	cmpeq	r2,r2,zero
 3230434:	1000061e 	bne	r2,zero,3230450 <sosend+0x390>
         {
            if (first)     /* report first error */
 3230438:	e0bff017 	ldw	r2,-64(fp)
 323043c:	1005003a 	cmpeq	r2,r2,zero
 3230440:	1000891e 	bne	r2,zero,3230668 <sosend+0x5a8>
               error = EWOULDBLOCK;
 3230444:	008002c4 	movi	r2,11
 3230448:	e0bff215 	stw	r2,-56(fp)
            goto release;
 323044c:	00008606 	br	3230668 <sosend+0x5a8>
         }
         /* If blocking socket, let someone else run */
         sbunlock(&so->so_snd);
 3230450:	e0bff817 	ldw	r2,-32(fp)
 3230454:	10c0190b 	ldhu	r3,100(r2)
 3230458:	00bfff84 	movi	r2,-2
 323045c:	1884703a 	and	r2,r3,r2
 3230460:	1007883a 	mov	r3,r2
 3230464:	e0bff817 	ldw	r2,-32(fp)
 3230468:	10c0190d 	sth	r3,100(r2)
 323046c:	e0bff817 	ldw	r2,-32(fp)
 3230470:	10801904 	addi	r2,r2,100
 3230474:	1009883a 	mov	r4,r2
 3230478:	3226c640 	call	3226c64 <tcp_wakeup>
         sbwait(&so->so_snd);
 323047c:	e0bff817 	ldw	r2,-32(fp)
 3230480:	11001204 	addi	r4,r2,72
 3230484:	32322080 	call	3232208 <sbwait>
         goto restart;
 3230488:	003f4f06 	br	32301c8 <sosend+0x108>
      }

      while (space > 0) 
      {
         len = resid;
 323048c:	e0bff417 	ldw	r2,-48(fp)
 3230490:	e0bff315 	stw	r2,-52(fp)
         if ( so->so_type == SOCK_STREAM )
 3230494:	e0bff817 	ldw	r2,-32(fp)
 3230498:	10800983 	ldbu	r2,38(r2)
 323049c:	10803fcc 	andi	r2,r2,255
 32304a0:	1080201c 	xori	r2,r2,128
 32304a4:	10bfe004 	addi	r2,r2,-128
 32304a8:	10800058 	cmpnei	r2,r2,1
 32304ac:	1000181e 	bne	r2,zero,3230510 <sosend+0x450>
         {
            m = m_getwithdata(MT_TXDATA, len);
 32304b0:	01000084 	movi	r4,2
 32304b4:	e17ff317 	ldw	r5,-52(fp)
 32304b8:	322bcf00 	call	322bcf0 <m_getnbuf>
 32304bc:	e0bff615 	stw	r2,-40(fp)
            if (!m)   
 32304c0:	e0bff617 	ldw	r2,-40(fp)
 32304c4:	1004c03a 	cmpne	r2,r2,zero
 32304c8:	1000031e 	bne	r2,zero,32304d8 <sosend+0x418>
               snderr(ENOBUFS);
 32304cc:	00801a44 	movi	r2,105
 32304d0:	e0bff215 	stw	r2,-56(fp)
 32304d4:	00006406 	br	3230668 <sosend+0x5a8>
            MEMCPY(m->m_data, data, len);
 32304d8:	e0bff617 	ldw	r2,-40(fp)
 32304dc:	10c00317 	ldw	r3,12(r2)
 32304e0:	e1bff317 	ldw	r6,-52(fp)
 32304e4:	e0bffa17 	ldw	r2,-24(fp)
 32304e8:	1809883a 	mov	r4,r3
 32304ec:	100b883a 	mov	r5,r2
 32304f0:	3206ad00 	call	3206ad0 <memcpy>
            so->so_snd.sb_flags |= SB_MBCOMP;   /* allow compression */
 32304f4:	e0bff817 	ldw	r2,-32(fp)
 32304f8:	1080190b 	ldhu	r2,100(r2)
 32304fc:	10802014 	ori	r2,r2,128
 3230500:	1007883a 	mov	r3,r2
 3230504:	e0bff817 	ldw	r2,-32(fp)
 3230508:	10c0190d 	sth	r3,100(r2)
 323050c:	00000706 	br	323052c <sosend+0x46c>
         }
         else
         {
            m = m_get (M_WAIT, MT_TXDATA);
 3230510:	01000084 	movi	r4,2
 3230514:	000b883a 	mov	r5,zero
 3230518:	322bcf00 	call	322bcf0 <m_getnbuf>
 323051c:	e0bff615 	stw	r2,-40(fp)
            m->m_data = data;
 3230520:	e0fff617 	ldw	r3,-40(fp)
 3230524:	e0bffa17 	ldw	r2,-24(fp)
 3230528:	18800315 	stw	r2,12(r3)
         }
         INET_TRACE (INETM_IO,
          ("sosend:got %d bytes so %lx mlen %d, off %d mtod %x\n",
             len, so, m->m_len, m->m_off, mtod (m, caddr_t)));

         *data_length -= len;
 323052c:	e0bffb17 	ldw	r2,-20(fp)
 3230530:	10c00017 	ldw	r3,0(r2)
 3230534:	e0bff317 	ldw	r2,-52(fp)
 3230538:	1887c83a 	sub	r3,r3,r2
 323053c:	e0bffb17 	ldw	r2,-20(fp)
 3230540:	10c00015 	stw	r3,0(r2)
         resid -= len;
 3230544:	e0fff417 	ldw	r3,-48(fp)
 3230548:	e0bff317 	ldw	r2,-52(fp)
 323054c:	1885c83a 	sub	r2,r3,r2
 3230550:	e0bff415 	stw	r2,-48(fp)
         data += len;
 3230554:	e0bff317 	ldw	r2,-52(fp)
 3230558:	1007883a 	mov	r3,r2
 323055c:	e0bffa17 	ldw	r2,-24(fp)
 3230560:	10c5883a 	add	r2,r2,r3
 3230564:	e0bffa15 	stw	r2,-24(fp)
         m->m_len = len;
 3230568:	e0fff317 	ldw	r3,-52(fp)
 323056c:	e0bff617 	ldw	r2,-40(fp)
 3230570:	10c00215 	stw	r3,8(r2)
         if (head == (struct mbuf *)NULL)
 3230574:	e0bff717 	ldw	r2,-36(fp)
 3230578:	1004c03a 	cmpne	r2,r2,zero
 323057c:	1000021e 	bne	r2,zero,3230588 <sosend+0x4c8>
            head = m;
 3230580:	e0bff617 	ldw	r2,-40(fp)
 3230584:	e0bff715 	stw	r2,-36(fp)
         if (error)
 3230588:	e0bff217 	ldw	r2,-56(fp)
 323058c:	1004c03a 	cmpne	r2,r2,zero
 3230590:	1000351e 	bne	r2,zero,3230668 <sosend+0x5a8>
            goto release;
         if (*data_length <= 0)
 3230594:	e0bffb17 	ldw	r2,-20(fp)
 3230598:	10800017 	ldw	r2,0(r2)
 323059c:	10800050 	cmplti	r2,r2,1
 32305a0:	1000031e 	bne	r2,zero,32305b0 <sosend+0x4f0>
         sbunlock(&so->so_snd);
         sbwait(&so->so_snd);
         goto restart;
      }

      while (space > 0) 
 32305a4:	e0bff517 	ldw	r2,-44(fp)
 32305a8:	10800048 	cmpgei	r2,r2,1
 32305ac:	103fb71e 	bne	r2,zero,323048c <sosend+0x3cc>
            goto release;
         if (*data_length <= 0)
            break;
      }

      if (dontroute)
 32305b0:	e0bff117 	ldw	r2,-60(fp)
 32305b4:	1005003a 	cmpeq	r2,r2,zero
 32305b8:	1000051e 	bne	r2,zero,32305d0 <sosend+0x510>
         so->so_options |= SO_DONTROUTE;
 32305bc:	e0bff817 	ldw	r2,-32(fp)
 32305c0:	10800417 	ldw	r2,16(r2)
 32305c4:	10c00414 	ori	r3,r2,16
 32305c8:	e0bff817 	ldw	r2,-32(fp)
 32305cc:	10c00415 	stw	r3,16(r2)

      so->so_req = (flags & MSG_OOB) ? PRU_SENDOOB : PRU_SEND;
 32305d0:	e0800217 	ldw	r2,8(fp)
 32305d4:	1080004c 	andi	r2,r2,1
 32305d8:	10803fcc 	andi	r2,r2,255
 32305dc:	1005003a 	cmpeq	r2,r2,zero
 32305e0:	1000031e 	bne	r2,zero,32305f0 <sosend+0x530>
 32305e4:	00c00384 	movi	r3,14
 32305e8:	e0fffc15 	stw	r3,-16(fp)
 32305ec:	00000206 	br	32305f8 <sosend+0x538>
 32305f0:	00800244 	movi	r2,9
 32305f4:	e0bffc15 	stw	r2,-16(fp)
 32305f8:	e0bff817 	ldw	r2,-32(fp)
 32305fc:	e0fffc17 	ldw	r3,-16(fp)
 3230600:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so, head, nam);
 3230604:	e0bff817 	ldw	r2,-32(fp)
 3230608:	10800217 	ldw	r2,8(r2)
 323060c:	10800317 	ldw	r2,12(r2)
 3230610:	e13ff817 	ldw	r4,-32(fp)
 3230614:	e17ff717 	ldw	r5,-36(fp)
 3230618:	e1bff917 	ldw	r6,-28(fp)
 323061c:	103ee83a 	callr	r2
 3230620:	e0bff215 	stw	r2,-56(fp)

      if (dontroute)
 3230624:	e0bff117 	ldw	r2,-60(fp)
 3230628:	1005003a 	cmpeq	r2,r2,zero
 323062c:	1000061e 	bne	r2,zero,3230648 <sosend+0x588>
         so->so_options &= ~SO_DONTROUTE;
 3230630:	e0bff817 	ldw	r2,-32(fp)
 3230634:	10c00417 	ldw	r3,16(r2)
 3230638:	00bffbc4 	movi	r2,-17
 323063c:	1886703a 	and	r3,r3,r2
 3230640:	e0bff817 	ldw	r2,-32(fp)
 3230644:	10c00415 	stw	r3,16(r2)

      head = (struct mbuf *)NULL;
 3230648:	e03ff715 	stw	zero,-36(fp)
      first = 0;
 323064c:	e03ff015 	stw	zero,-64(fp)
   } while ((resid != 0) && (error == 0));
 3230650:	e0bff417 	ldw	r2,-48(fp)
 3230654:	1005003a 	cmpeq	r2,r2,zero
 3230658:	1000031e 	bne	r2,zero,3230668 <sosend+0x5a8>
 323065c:	e0bff217 	ldw	r2,-56(fp)
 3230660:	1005003a 	cmpeq	r2,r2,zero
 3230664:	103ee51e 	bne	r2,zero,32301fc <sosend+0x13c>

release:
   sbunlock(&so->so_snd);  
 3230668:	e0bff817 	ldw	r2,-32(fp)
 323066c:	10c0190b 	ldhu	r3,100(r2)
 3230670:	00bfff84 	movi	r2,-2
 3230674:	1884703a 	and	r2,r3,r2
 3230678:	1007883a 	mov	r3,r2
 323067c:	e0bff817 	ldw	r2,-32(fp)
 3230680:	10c0190d 	sth	r3,100(r2)
 3230684:	e0bff817 	ldw	r2,-32(fp)
 3230688:	10801904 	addi	r2,r2,100
 323068c:	1009883a 	mov	r4,r2
 3230690:	3226c640 	call	3226c64 <tcp_wakeup>
   if (head)
 3230694:	e0bff717 	ldw	r2,-36(fp)
 3230698:	1005003a 	cmpeq	r2,r2,zero
 323069c:	1000021e 	bne	r2,zero,32306a8 <sosend+0x5e8>
      m_freem(head);
 32306a0:	e13ff717 	ldw	r4,-36(fp)
 32306a4:	322bfcc0 	call	322bfcc <m_freem>
   return error;
 32306a8:	e0bff217 	ldw	r2,-56(fp)
 32306ac:	e0bfff15 	stw	r2,-4(fp)
 32306b0:	e0bfff17 	ldw	r2,-4(fp)
}
 32306b4:	e037883a 	mov	sp,fp
 32306b8:	dfc00117 	ldw	ra,4(sp)
 32306bc:	df000017 	ldw	fp,0(sp)
 32306c0:	dec00204 	addi	sp,sp,8
 32306c4:	f800283a 	ret

032306c8 <soreceive>:
soreceive(struct socket * so, 
   struct mbuf **aname,
   char * data,
   int * datalen,
   int   flags)
{
 32306c8:	defff104 	addi	sp,sp,-60
 32306cc:	dfc00e15 	stw	ra,56(sp)
 32306d0:	df000d15 	stw	fp,52(sp)
 32306d4:	df000d04 	addi	fp,sp,52
 32306d8:	e13ffb15 	stw	r4,-20(fp)
 32306dc:	e17ffc15 	stw	r5,-16(fp)
 32306e0:	e1bffd15 	stw	r6,-12(fp)
 32306e4:	e1fffe15 	stw	r7,-8(fp)
   struct mbuf *  m;
   int   len;
   int   error =  0;
 32306e8:	e03ff815 	stw	zero,-32(fp)
   int   offset;
   struct protosw *  pr =  so->so_proto;
 32306ec:	e0bffb17 	ldw	r2,-20(fp)
 32306f0:	10800217 	ldw	r2,8(r2)
 32306f4:	e0bff615 	stw	r2,-40(fp)
   struct mbuf *  nextrecord;
   int   moff;
   int   lflags;

   if (aname)
 32306f8:	e0bffc17 	ldw	r2,-16(fp)
 32306fc:	1005003a 	cmpeq	r2,r2,zero
 3230700:	1000021e 	bne	r2,zero,323070c <soreceive+0x44>
      *aname = 0;
 3230704:	e0bffc17 	ldw	r2,-16(fp)
 3230708:	10000015 	stw	zero,0(r2)
   if (flags & MSG_OOB) 
 323070c:	e0800217 	ldw	r2,8(fp)
 3230710:	1080004c 	andi	r2,r2,1
 3230714:	10803fcc 	andi	r2,r2,255
 3230718:	1005003a 	cmpeq	r2,r2,zero
 323071c:	10004d1e 	bne	r2,zero,3230854 <soreceive+0x18c>
   {
      m = m_get (M_WAIT, MT_RXDATA);
 3230720:	01000044 	movi	r4,1
 3230724:	000b883a 	mov	r5,zero
 3230728:	322bcf00 	call	322bcf0 <m_getnbuf>
 323072c:	e0bffa15 	stw	r2,-24(fp)
      if (m == NULL)
 3230730:	e0bffa17 	ldw	r2,-24(fp)
 3230734:	1004c03a 	cmpne	r2,r2,zero
 3230738:	1000031e 	bne	r2,zero,3230748 <soreceive+0x80>
         return ENOBUFS;
 323073c:	00801a44 	movi	r2,105
 3230740:	e0bfff15 	stw	r2,-4(fp)
 3230744:	0001d306 	br	3230e94 <soreceive+0x7cc>
      lflags = flags & MSG_PEEK;
 3230748:	e0800217 	ldw	r2,8(fp)
 323074c:	1080008c 	andi	r2,r2,2
 3230750:	e0bff315 	stw	r2,-52(fp)

      so->so_req = PRU_RCVOOB;
 3230754:	e0fffb17 	ldw	r3,-20(fp)
 3230758:	00800344 	movi	r2,13
 323075c:	18800715 	stw	r2,28(r3)
      error = (*pr->pr_usrreq)(so, m, LONG2MBUF((long)lflags));
 3230760:	e0bff617 	ldw	r2,-40(fp)
 3230764:	10800317 	ldw	r2,12(r2)
 3230768:	e1bff317 	ldw	r6,-52(fp)
 323076c:	e13ffb17 	ldw	r4,-20(fp)
 3230770:	e17ffa17 	ldw	r5,-24(fp)
 3230774:	103ee83a 	callr	r2
 3230778:	e0bff815 	stw	r2,-32(fp)
      if (error == 0)
 323077c:	e0bff817 	ldw	r2,-32(fp)
 3230780:	1004c03a 	cmpne	r2,r2,zero
 3230784:	1000271e 	bne	r2,zero,3230824 <soreceive+0x15c>
      {
         do 
         {
            len = *datalen;
 3230788:	e0bffe17 	ldw	r2,-8(fp)
 323078c:	10800017 	ldw	r2,0(r2)
 3230790:	e0bff915 	stw	r2,-28(fp)
            if (len > (int)m->m_len)
 3230794:	e0bffa17 	ldw	r2,-24(fp)
 3230798:	10800217 	ldw	r2,8(r2)
 323079c:	1007883a 	mov	r3,r2
 32307a0:	e0bff917 	ldw	r2,-28(fp)
 32307a4:	1880030e 	bge	r3,r2,32307b4 <soreceive+0xec>
               len = m->m_len;
 32307a8:	e0bffa17 	ldw	r2,-24(fp)
 32307ac:	10800217 	ldw	r2,8(r2)
 32307b0:	e0bff915 	stw	r2,-28(fp)

            MEMCPY(data, mtod(m, char*), len);
 32307b4:	e0bffa17 	ldw	r2,-24(fp)
 32307b8:	10c00317 	ldw	r3,12(r2)
 32307bc:	e1bff917 	ldw	r6,-28(fp)
 32307c0:	e0bffd17 	ldw	r2,-12(fp)
 32307c4:	1009883a 	mov	r4,r2
 32307c8:	180b883a 	mov	r5,r3
 32307cc:	3206ad00 	call	3206ad0 <memcpy>
            data += len;
 32307d0:	e0bff917 	ldw	r2,-28(fp)
 32307d4:	1007883a 	mov	r3,r2
 32307d8:	e0bffd17 	ldw	r2,-12(fp)
 32307dc:	10c5883a 	add	r2,r2,r3
 32307e0:	e0bffd15 	stw	r2,-12(fp)
            *datalen = len;
 32307e4:	e0fffe17 	ldw	r3,-8(fp)
 32307e8:	e0bff917 	ldw	r2,-28(fp)
 32307ec:	18800015 	stw	r2,0(r3)
            m = m_free(m);
 32307f0:	e13ffa17 	ldw	r4,-24(fp)
 32307f4:	322be980 	call	322be98 <m_free>
 32307f8:	e0bffa15 	stw	r2,-24(fp)
         } while (*datalen && (error == 0) && m);
 32307fc:	e0bffe17 	ldw	r2,-8(fp)
 3230800:	10800017 	ldw	r2,0(r2)
 3230804:	1005003a 	cmpeq	r2,r2,zero
 3230808:	1000061e 	bne	r2,zero,3230824 <soreceive+0x15c>
 323080c:	e0bff817 	ldw	r2,-32(fp)
 3230810:	1004c03a 	cmpne	r2,r2,zero
 3230814:	1000031e 	bne	r2,zero,3230824 <soreceive+0x15c>
 3230818:	e0bffa17 	ldw	r2,-24(fp)
 323081c:	1004c03a 	cmpne	r2,r2,zero
 3230820:	103fd91e 	bne	r2,zero,3230788 <soreceive+0xc0>
      }

      if (m)
 3230824:	e0bffa17 	ldw	r2,-24(fp)
 3230828:	1005003a 	cmpeq	r2,r2,zero
 323082c:	1000021e 	bne	r2,zero,3230838 <soreceive+0x170>
         m_freem(m);
 3230830:	e13ffa17 	ldw	r4,-24(fp)
 3230834:	322bfcc0 	call	322bfcc <m_freem>
      return (error);
 3230838:	e0bff817 	ldw	r2,-32(fp)
 323083c:	e0bfff15 	stw	r2,-4(fp)
 3230840:	00019406 	br	3230e94 <soreceive+0x7cc>
   }

restart:
   sblock (&so->so_rcv);
 3230844:	e0bffb17 	ldw	r2,-20(fp)
 3230848:	10801104 	addi	r2,r2,68
 323084c:	1009883a 	mov	r4,r2
 3230850:	3226ac40 	call	3226ac4 <tcp_sleep>
 3230854:	e0bffb17 	ldw	r2,-20(fp)
 3230858:	1080110b 	ldhu	r2,68(r2)
 323085c:	10bfffcc 	andi	r2,r2,65535
 3230860:	1080004c 	andi	r2,r2,1
 3230864:	10803fcc 	andi	r2,r2,255
 3230868:	1004c03a 	cmpne	r2,r2,zero
 323086c:	103ff51e 	bne	r2,zero,3230844 <soreceive+0x17c>
 3230870:	e0bffb17 	ldw	r2,-20(fp)
 3230874:	1080110b 	ldhu	r2,68(r2)
 3230878:	10800054 	ori	r2,r2,1
 323087c:	1007883a 	mov	r3,r2
 3230880:	e0bffb17 	ldw	r2,-20(fp)
 3230884:	10c0110d 	sth	r3,68(r2)
   INET_TRACE (INETM_IO,
    ("INET:soreceive sbcc %d soerror %d so_state %d *datalen %d\n",
    so->so_rcv.sb_cc, so->so_error, so->so_state, *datalen));

   /* If no data is ready, see if we should wait or return */
   if (so->so_rcv.sb_cc == 0) 
 3230888:	e0bffb17 	ldw	r2,-20(fp)
 323088c:	10800a17 	ldw	r2,40(r2)
 3230890:	1004c03a 	cmpne	r2,r2,zero
 3230894:	1000401e 	bne	r2,zero,3230998 <soreceive+0x2d0>
   {
      if (so->so_error) 
 3230898:	e0bffb17 	ldw	r2,-20(fp)
 323089c:	10800617 	ldw	r2,24(r2)
 32308a0:	1005003a 	cmpeq	r2,r2,zero
 32308a4:	1000061e 	bne	r2,zero,32308c0 <soreceive+0x1f8>
      {
         error = so->so_error;
 32308a8:	e0bffb17 	ldw	r2,-20(fp)
 32308ac:	10800617 	ldw	r2,24(r2)
 32308b0:	e0bff815 	stw	r2,-32(fp)
         so->so_error = 0;
 32308b4:	e0bffb17 	ldw	r2,-20(fp)
 32308b8:	10000615 	stw	zero,24(r2)
         goto release;
 32308bc:	00016806 	br	3230e60 <soreceive+0x798>
      }
      if (so->so_state & SS_CANTRCVMORE)
 32308c0:	e0bffb17 	ldw	r2,-20(fp)
 32308c4:	1080088b 	ldhu	r2,34(r2)
 32308c8:	10bfffcc 	andi	r2,r2,65535
 32308cc:	1080080c 	andi	r2,r2,32
 32308d0:	1004c03a 	cmpne	r2,r2,zero
 32308d4:	1001621e 	bne	r2,zero,3230e60 <soreceive+0x798>
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 32308d8:	e0bffb17 	ldw	r2,-20(fp)
 32308dc:	1080088b 	ldhu	r2,34(r2)
 32308e0:	10bfffcc 	andi	r2,r2,65535
 32308e4:	1080008c 	andi	r2,r2,2
 32308e8:	1004c03a 	cmpne	r2,r2,zero
 32308ec:	10000a1e 	bne	r2,zero,3230918 <soreceive+0x250>
 32308f0:	e0bffb17 	ldw	r2,-20(fp)
 32308f4:	10800217 	ldw	r2,8(r2)
 32308f8:	1080010b 	ldhu	r2,4(r2)
 32308fc:	10bfffcc 	andi	r2,r2,65535
 3230900:	1080010c 	andi	r2,r2,4
 3230904:	1005003a 	cmpeq	r2,r2,zero
 3230908:	1000031e 	bne	r2,zero,3230918 <soreceive+0x250>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
      {
         error = ENOTCONN;
 323090c:	00802004 	movi	r2,128
 3230910:	e0bff815 	stw	r2,-32(fp)
         goto release;
 3230914:	00015206 	br	3230e60 <soreceive+0x798>
      }
      if (*datalen == 0)
 3230918:	e0bffe17 	ldw	r2,-8(fp)
 323091c:	10800017 	ldw	r2,0(r2)
 3230920:	1005003a 	cmpeq	r2,r2,zero
 3230924:	10014e1e 	bne	r2,zero,3230e60 <soreceive+0x798>
         goto release;
      if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT)) 
 3230928:	e0bffb17 	ldw	r2,-20(fp)
 323092c:	1080088b 	ldhu	r2,34(r2)
 3230930:	10bfffcc 	andi	r2,r2,65535
 3230934:	1080400c 	andi	r2,r2,256
 3230938:	1004c03a 	cmpne	r2,r2,zero
 323093c:	1000041e 	bne	r2,zero,3230950 <soreceive+0x288>
 3230940:	e0800217 	ldw	r2,8(fp)
 3230944:	1080080c 	andi	r2,r2,32
 3230948:	1005003a 	cmpeq	r2,r2,zero
 323094c:	1000031e 	bne	r2,zero,323095c <soreceive+0x294>
      {
         error = EWOULDBLOCK;
 3230950:	008002c4 	movi	r2,11
 3230954:	e0bff815 	stw	r2,-32(fp)
         goto release;
 3230958:	00014106 	br	3230e60 <soreceive+0x798>
      }
      sbunlock(&so->so_rcv);
 323095c:	e0bffb17 	ldw	r2,-20(fp)
 3230960:	10c0110b 	ldhu	r3,68(r2)
 3230964:	00bfff84 	movi	r2,-2
 3230968:	1884703a 	and	r2,r3,r2
 323096c:	1007883a 	mov	r3,r2
 3230970:	e0bffb17 	ldw	r2,-20(fp)
 3230974:	10c0110d 	sth	r3,68(r2)
 3230978:	e0bffb17 	ldw	r2,-20(fp)
 323097c:	10801104 	addi	r2,r2,68
 3230980:	1009883a 	mov	r4,r2
 3230984:	3226c640 	call	3226c64 <tcp_wakeup>
      sbwait(&so->so_rcv);
 3230988:	e0bffb17 	ldw	r2,-20(fp)
 323098c:	11000a04 	addi	r4,r2,40
 3230990:	32322080 	call	3232208 <sbwait>
      goto restart;
 3230994:	003faf06 	br	3230854 <soreceive+0x18c>
   }
   m = so->so_rcv.sb_mb;
 3230998:	e0bffb17 	ldw	r2,-20(fp)
 323099c:	10801017 	ldw	r2,64(r2)
 32309a0:	e0bffa15 	stw	r2,-24(fp)
   if (m == 0)
 32309a4:	e0bffa17 	ldw	r2,-24(fp)
 32309a8:	1004c03a 	cmpne	r2,r2,zero
 32309ac:	1000031e 	bne	r2,zero,32309bc <soreceive+0x2f4>
      panic("sorecv 1");
 32309b0:	0100c974 	movhi	r4,805
 32309b4:	213e3604 	addi	r4,r4,-1832
 32309b8:	32261540 	call	3226154 <panic>
   nextrecord = m->m_act;
 32309bc:	e0bffa17 	ldw	r2,-24(fp)
 32309c0:	10800717 	ldw	r2,28(r2)
 32309c4:	e0bff515 	stw	r2,-44(fp)
   if (pr->pr_flags & PR_ADDR) 
 32309c8:	e0bff617 	ldw	r2,-40(fp)
 32309cc:	1080010b 	ldhu	r2,4(r2)
 32309d0:	10bfffcc 	andi	r2,r2,65535
 32309d4:	1080008c 	andi	r2,r2,2
 32309d8:	1005003a 	cmpeq	r2,r2,zero
 32309dc:	1000451e 	bne	r2,zero,3230af4 <soreceive+0x42c>
   {
      if (m->m_type != MT_SONAME) 
 32309e0:	e0bffa17 	ldw	r2,-24(fp)
 32309e4:	10800817 	ldw	r2,32(r2)
 32309e8:	10800260 	cmpeqi	r2,r2,9
 32309ec:	1000081e 	bne	r2,zero,3230a10 <soreceive+0x348>
      {
         dprintf ("sorecv:type %d not nam", m->m_type);
 32309f0:	e0bffa17 	ldw	r2,-24(fp)
 32309f4:	11400817 	ldw	r5,32(r2)
 32309f8:	0100c974 	movhi	r4,805
 32309fc:	213e3904 	addi	r4,r4,-1820
 3230a00:	3206de00 	call	3206de0 <printf>
         panic("sorecv 2");
 3230a04:	0100c974 	movhi	r4,805
 3230a08:	213e3f04 	addi	r4,r4,-1796
 3230a0c:	32261540 	call	3226154 <panic>
      }
      if (flags & MSG_PEEK) 
 3230a10:	e0800217 	ldw	r2,8(fp)
 3230a14:	1080008c 	andi	r2,r2,2
 3230a18:	1005003a 	cmpeq	r2,r2,zero
 3230a1c:	1000101e 	bne	r2,zero,3230a60 <soreceive+0x398>
      {
         if (aname)
 3230a20:	e0bffc17 	ldw	r2,-16(fp)
 3230a24:	1005003a 	cmpeq	r2,r2,zero
 3230a28:	1000091e 	bne	r2,zero,3230a50 <soreceive+0x388>
            *aname = m_copy (m, 0, m->m_len);
 3230a2c:	e0bffa17 	ldw	r2,-24(fp)
 3230a30:	10800217 	ldw	r2,8(r2)
 3230a34:	100d883a 	mov	r6,r2
 3230a38:	e13ffa17 	ldw	r4,-24(fp)
 3230a3c:	000b883a 	mov	r5,zero
 3230a40:	322c0100 	call	322c010 <m_copy>
 3230a44:	1007883a 	mov	r3,r2
 3230a48:	e0bffc17 	ldw	r2,-16(fp)
 3230a4c:	10c00015 	stw	r3,0(r2)
         m = m->m_next;
 3230a50:	e0bffa17 	ldw	r2,-24(fp)
 3230a54:	10800617 	ldw	r2,24(r2)
 3230a58:	e0bffa15 	stw	r2,-24(fp)
 3230a5c:	00002506 	br	3230af4 <soreceive+0x42c>
      } else 
      {
         sbfree (&so->so_rcv, m);
 3230a60:	e0bffb17 	ldw	r2,-20(fp)
 3230a64:	10c00a17 	ldw	r3,40(r2)
 3230a68:	e0bffa17 	ldw	r2,-24(fp)
 3230a6c:	10800217 	ldw	r2,8(r2)
 3230a70:	1887c83a 	sub	r3,r3,r2
 3230a74:	e0bffb17 	ldw	r2,-20(fp)
 3230a78:	10c00a15 	stw	r3,40(r2)
         if (aname) 
 3230a7c:	e0bffc17 	ldw	r2,-16(fp)
 3230a80:	1005003a 	cmpeq	r2,r2,zero
 3230a84:	10000d1e 	bne	r2,zero,3230abc <soreceive+0x3f4>
         {
            *aname = m;
 3230a88:	e0fffc17 	ldw	r3,-16(fp)
 3230a8c:	e0bffa17 	ldw	r2,-24(fp)
 3230a90:	18800015 	stw	r2,0(r3)
            m = m->m_next;
 3230a94:	e0bffa17 	ldw	r2,-24(fp)
 3230a98:	10800617 	ldw	r2,24(r2)
 3230a9c:	e0bffa15 	stw	r2,-24(fp)
            (*aname)->m_next = 0;
 3230aa0:	e0bffc17 	ldw	r2,-16(fp)
 3230aa4:	10800017 	ldw	r2,0(r2)
 3230aa8:	10000615 	stw	zero,24(r2)
            so->so_rcv.sb_mb = m;
 3230aac:	e0fffb17 	ldw	r3,-20(fp)
 3230ab0:	e0bffa17 	ldw	r2,-24(fp)
 3230ab4:	18801015 	stw	r2,64(r3)
 3230ab8:	00000806 	br	3230adc <soreceive+0x414>
         } else 
         {
            MFREE(m, so->so_rcv.sb_mb);
 3230abc:	e13ffa17 	ldw	r4,-24(fp)
 3230ac0:	322be980 	call	322be98 <m_free>
 3230ac4:	1007883a 	mov	r3,r2
 3230ac8:	e0bffb17 	ldw	r2,-20(fp)
 3230acc:	10c01015 	stw	r3,64(r2)
            m = so->so_rcv.sb_mb;
 3230ad0:	e0bffb17 	ldw	r2,-20(fp)
 3230ad4:	10801017 	ldw	r2,64(r2)
 3230ad8:	e0bffa15 	stw	r2,-24(fp)
         }
         if (m)
 3230adc:	e0bffa17 	ldw	r2,-24(fp)
 3230ae0:	1005003a 	cmpeq	r2,r2,zero
 3230ae4:	1000031e 	bne	r2,zero,3230af4 <soreceive+0x42c>
            m->m_act = nextrecord;
 3230ae8:	e0fffa17 	ldw	r3,-24(fp)
 3230aec:	e0bff517 	ldw	r2,-44(fp)
 3230af0:	18800715 	stw	r2,28(r3)
      }
   }
   moff = 0;
 3230af4:	e03ff415 	stw	zero,-48(fp)
   offset = 0;
 3230af8:	e03ff715 	stw	zero,-36(fp)
   while (m && (*datalen > 0) && (error == 0))
 3230afc:	0000a606 	br	3230d98 <soreceive+0x6d0>
   {
      if (m->m_type != MT_RXDATA && m->m_type != MT_HEADER)
 3230b00:	e0bffa17 	ldw	r2,-24(fp)
 3230b04:	10800817 	ldw	r2,32(r2)
 3230b08:	10800060 	cmpeqi	r2,r2,1
 3230b0c:	1000071e 	bne	r2,zero,3230b2c <soreceive+0x464>
 3230b10:	e0bffa17 	ldw	r2,-24(fp)
 3230b14:	10800817 	ldw	r2,32(r2)
 3230b18:	108000e0 	cmpeqi	r2,r2,3
 3230b1c:	1000031e 	bne	r2,zero,3230b2c <soreceive+0x464>
         panic("sorecv 3");
 3230b20:	0100c974 	movhi	r4,805
 3230b24:	213e4204 	addi	r4,r4,-1784
 3230b28:	32261540 	call	3226154 <panic>
      len = *datalen;
 3230b2c:	e0bffe17 	ldw	r2,-8(fp)
 3230b30:	10800017 	ldw	r2,0(r2)
 3230b34:	e0bff915 	stw	r2,-28(fp)
      so->so_state &= ~SS_RCVATMARK;
 3230b38:	e0bffb17 	ldw	r2,-20(fp)
 3230b3c:	10c0088b 	ldhu	r3,34(r2)
 3230b40:	00bfefc4 	movi	r2,-65
 3230b44:	1884703a 	and	r2,r3,r2
 3230b48:	1007883a 	mov	r3,r2
 3230b4c:	e0bffb17 	ldw	r2,-20(fp)
 3230b50:	10c0088d 	sth	r3,34(r2)
      if (so->so_oobmark && (len > (int)(so->so_oobmark - offset)))
 3230b54:	e0bffb17 	ldw	r2,-20(fp)
 3230b58:	10801a17 	ldw	r2,104(r2)
 3230b5c:	1005003a 	cmpeq	r2,r2,zero
 3230b60:	10000c1e 	bne	r2,zero,3230b94 <soreceive+0x4cc>
 3230b64:	e0bffb17 	ldw	r2,-20(fp)
 3230b68:	10c01a17 	ldw	r3,104(r2)
 3230b6c:	e0bff717 	ldw	r2,-36(fp)
 3230b70:	1885c83a 	sub	r2,r3,r2
 3230b74:	1007883a 	mov	r3,r2
 3230b78:	e0bff917 	ldw	r2,-28(fp)
 3230b7c:	1880050e 	bge	r3,r2,3230b94 <soreceive+0x4cc>
         len = (int)(so->so_oobmark - offset);
 3230b80:	e0bffb17 	ldw	r2,-20(fp)
 3230b84:	10c01a17 	ldw	r3,104(r2)
 3230b88:	e0bff717 	ldw	r2,-36(fp)
 3230b8c:	1885c83a 	sub	r2,r3,r2
 3230b90:	e0bff915 	stw	r2,-28(fp)
      if (len > (int)(m->m_len - moff))
 3230b94:	e0bffa17 	ldw	r2,-24(fp)
 3230b98:	10c00217 	ldw	r3,8(r2)
 3230b9c:	e0bff417 	ldw	r2,-48(fp)
 3230ba0:	1885c83a 	sub	r2,r3,r2
 3230ba4:	1007883a 	mov	r3,r2
 3230ba8:	e0bff917 	ldw	r2,-28(fp)
 3230bac:	1880050e 	bge	r3,r2,3230bc4 <soreceive+0x4fc>
         len = m->m_len - moff;
 3230bb0:	e0bffa17 	ldw	r2,-24(fp)
 3230bb4:	10c00217 	ldw	r3,8(r2)
 3230bb8:	e0bff417 	ldw	r2,-48(fp)
 3230bbc:	1885c83a 	sub	r2,r3,r2
 3230bc0:	e0bff915 	stw	r2,-28(fp)
       * it points to next record) when we drop priority;
       * we must note any additions to the sockbuf when we
       * block interrupts again.
       */

      MEMCPY(data, (mtod(m, char *) + moff), len);
 3230bc4:	e0bffa17 	ldw	r2,-24(fp)
 3230bc8:	10c00317 	ldw	r3,12(r2)
 3230bcc:	e0bff417 	ldw	r2,-48(fp)
 3230bd0:	1887883a 	add	r3,r3,r2
 3230bd4:	e1bff917 	ldw	r6,-28(fp)
 3230bd8:	e0bffd17 	ldw	r2,-12(fp)
 3230bdc:	1009883a 	mov	r4,r2
 3230be0:	180b883a 	mov	r5,r3
 3230be4:	3206ad00 	call	3206ad0 <memcpy>
      data += len;
 3230be8:	e0bff917 	ldw	r2,-28(fp)
 3230bec:	1007883a 	mov	r3,r2
 3230bf0:	e0bffd17 	ldw	r2,-12(fp)
 3230bf4:	10c5883a 	add	r2,r2,r3
 3230bf8:	e0bffd15 	stw	r2,-12(fp)
      *datalen -= len;
 3230bfc:	e0bffe17 	ldw	r2,-8(fp)
 3230c00:	10c00017 	ldw	r3,0(r2)
 3230c04:	e0bff917 	ldw	r2,-28(fp)
 3230c08:	1887c83a 	sub	r3,r3,r2
 3230c0c:	e0bffe17 	ldw	r2,-8(fp)
 3230c10:	10c00015 	stw	r3,0(r2)

      if (len == (int)(m->m_len - moff))
 3230c14:	e0bffa17 	ldw	r2,-24(fp)
 3230c18:	10c00217 	ldw	r3,8(r2)
 3230c1c:	e0bff417 	ldw	r2,-48(fp)
 3230c20:	1885c83a 	sub	r2,r3,r2
 3230c24:	1007883a 	mov	r3,r2
 3230c28:	e0bff917 	ldw	r2,-28(fp)
 3230c2c:	1880221e 	bne	r3,r2,3230cb8 <soreceive+0x5f0>
      {
         if (flags & MSG_PEEK) 
 3230c30:	e0800217 	ldw	r2,8(fp)
 3230c34:	1080008c 	andi	r2,r2,2
 3230c38:	1005003a 	cmpeq	r2,r2,zero
 3230c3c:	1000051e 	bne	r2,zero,3230c54 <soreceive+0x58c>
         {
            m = m->m_next;
 3230c40:	e0bffa17 	ldw	r2,-24(fp)
 3230c44:	10800617 	ldw	r2,24(r2)
 3230c48:	e0bffa15 	stw	r2,-24(fp)
            moff = 0;
 3230c4c:	e03ff415 	stw	zero,-48(fp)
 3230c50:	00003406 	br	3230d24 <soreceive+0x65c>
         } else 
         {
            nextrecord = m->m_act;
 3230c54:	e0bffa17 	ldw	r2,-24(fp)
 3230c58:	10800717 	ldw	r2,28(r2)
 3230c5c:	e0bff515 	stw	r2,-44(fp)
            sbfree(&so->so_rcv, m);
 3230c60:	e0bffb17 	ldw	r2,-20(fp)
 3230c64:	10c00a17 	ldw	r3,40(r2)
 3230c68:	e0bffa17 	ldw	r2,-24(fp)
 3230c6c:	10800217 	ldw	r2,8(r2)
 3230c70:	1887c83a 	sub	r3,r3,r2
 3230c74:	e0bffb17 	ldw	r2,-20(fp)
 3230c78:	10c00a15 	stw	r3,40(r2)
            {
               MFREE(m, so->so_rcv.sb_mb);
 3230c7c:	e13ffa17 	ldw	r4,-24(fp)
 3230c80:	322be980 	call	322be98 <m_free>
 3230c84:	1007883a 	mov	r3,r2
 3230c88:	e0bffb17 	ldw	r2,-20(fp)
 3230c8c:	10c01015 	stw	r3,64(r2)
               m = so->so_rcv.sb_mb;
 3230c90:	e0bffb17 	ldw	r2,-20(fp)
 3230c94:	10801017 	ldw	r2,64(r2)
 3230c98:	e0bffa15 	stw	r2,-24(fp)
            }
            if (m)
 3230c9c:	e0bffa17 	ldw	r2,-24(fp)
 3230ca0:	1005003a 	cmpeq	r2,r2,zero
 3230ca4:	10001f1e 	bne	r2,zero,3230d24 <soreceive+0x65c>
               m->m_act = nextrecord;
 3230ca8:	e0fffa17 	ldw	r3,-24(fp)
 3230cac:	e0bff517 	ldw	r2,-44(fp)
 3230cb0:	18800715 	stw	r2,28(r3)
 3230cb4:	00001b06 	br	3230d24 <soreceive+0x65c>
         }
      } else 
      {
         if (flags & MSG_PEEK)
 3230cb8:	e0800217 	ldw	r2,8(fp)
 3230cbc:	1080008c 	andi	r2,r2,2
 3230cc0:	1005003a 	cmpeq	r2,r2,zero
 3230cc4:	1000051e 	bne	r2,zero,3230cdc <soreceive+0x614>
            moff += len;
 3230cc8:	e0bff417 	ldw	r2,-48(fp)
 3230ccc:	e0fff917 	ldw	r3,-28(fp)
 3230cd0:	10c5883a 	add	r2,r2,r3
 3230cd4:	e0bff415 	stw	r2,-48(fp)
 3230cd8:	00001206 	br	3230d24 <soreceive+0x65c>
         else 
         {
            m->m_data += len;
 3230cdc:	e0bffa17 	ldw	r2,-24(fp)
 3230ce0:	10c00317 	ldw	r3,12(r2)
 3230ce4:	e0bff917 	ldw	r2,-28(fp)
 3230ce8:	1887883a 	add	r3,r3,r2
 3230cec:	e0bffa17 	ldw	r2,-24(fp)
 3230cf0:	10c00315 	stw	r3,12(r2)
            m->m_len -= len;
 3230cf4:	e0bffa17 	ldw	r2,-24(fp)
 3230cf8:	10c00217 	ldw	r3,8(r2)
 3230cfc:	e0bff917 	ldw	r2,-28(fp)
 3230d00:	1887c83a 	sub	r3,r3,r2
 3230d04:	e0bffa17 	ldw	r2,-24(fp)
 3230d08:	10c00215 	stw	r3,8(r2)
            so->so_rcv.sb_cc -= len;
 3230d0c:	e0bffb17 	ldw	r2,-20(fp)
 3230d10:	10c00a17 	ldw	r3,40(r2)
 3230d14:	e0bff917 	ldw	r2,-28(fp)
 3230d18:	1887c83a 	sub	r3,r3,r2
 3230d1c:	e0bffb17 	ldw	r2,-20(fp)
 3230d20:	10c00a15 	stw	r3,40(r2)
         }
      }
      if (so->so_oobmark) 
 3230d24:	e0bffb17 	ldw	r2,-20(fp)
 3230d28:	10801a17 	ldw	r2,104(r2)
 3230d2c:	1005003a 	cmpeq	r2,r2,zero
 3230d30:	1000191e 	bne	r2,zero,3230d98 <soreceive+0x6d0>
      {
         if ((flags & MSG_PEEK) == 0) 
 3230d34:	e0800217 	ldw	r2,8(fp)
 3230d38:	1080008c 	andi	r2,r2,2
 3230d3c:	1004c03a 	cmpne	r2,r2,zero
 3230d40:	1000111e 	bne	r2,zero,3230d88 <soreceive+0x6c0>
         {
            so->so_oobmark -= len;
 3230d44:	e0bffb17 	ldw	r2,-20(fp)
 3230d48:	10c01a17 	ldw	r3,104(r2)
 3230d4c:	e0bff917 	ldw	r2,-28(fp)
 3230d50:	1887c83a 	sub	r3,r3,r2
 3230d54:	e0bffb17 	ldw	r2,-20(fp)
 3230d58:	10c01a15 	stw	r3,104(r2)
            if (so->so_oobmark == 0) 
 3230d5c:	e0bffb17 	ldw	r2,-20(fp)
 3230d60:	10801a17 	ldw	r2,104(r2)
 3230d64:	1004c03a 	cmpne	r2,r2,zero
 3230d68:	10000b1e 	bne	r2,zero,3230d98 <soreceive+0x6d0>
            {
               so->so_state |= SS_RCVATMARK;
 3230d6c:	e0bffb17 	ldw	r2,-20(fp)
 3230d70:	1080088b 	ldhu	r2,34(r2)
 3230d74:	10801014 	ori	r2,r2,64
 3230d78:	1007883a 	mov	r3,r2
 3230d7c:	e0bffb17 	ldw	r2,-20(fp)
 3230d80:	10c0088d 	sth	r3,34(r2)
               break;
 3230d84:	00000e06 	br	3230dc0 <soreceive+0x6f8>
            }
         } else
            offset += len;
 3230d88:	e0bff717 	ldw	r2,-36(fp)
 3230d8c:	e0fff917 	ldw	r3,-28(fp)
 3230d90:	10c5883a 	add	r2,r2,r3
 3230d94:	e0bff715 	stw	r2,-36(fp)
            m->m_act = nextrecord;
      }
   }
   moff = 0;
   offset = 0;
   while (m && (*datalen > 0) && (error == 0))
 3230d98:	e0bffa17 	ldw	r2,-24(fp)
 3230d9c:	1005003a 	cmpeq	r2,r2,zero
 3230da0:	1000071e 	bne	r2,zero,3230dc0 <soreceive+0x6f8>
 3230da4:	e0bffe17 	ldw	r2,-8(fp)
 3230da8:	10800017 	ldw	r2,0(r2)
 3230dac:	10800050 	cmplti	r2,r2,1
 3230db0:	1000031e 	bne	r2,zero,3230dc0 <soreceive+0x6f8>
 3230db4:	e0bff817 	ldw	r2,-32(fp)
 3230db8:	1005003a 	cmpeq	r2,r2,zero
 3230dbc:	103f501e 	bne	r2,zero,3230b00 <soreceive+0x438>
         } else
            offset += len;
      }
   }

   if ((flags & MSG_PEEK) == 0) 
 3230dc0:	e0800217 	ldw	r2,8(fp)
 3230dc4:	1080008c 	andi	r2,r2,2
 3230dc8:	1004c03a 	cmpne	r2,r2,zero
 3230dcc:	1000241e 	bne	r2,zero,3230e60 <soreceive+0x798>
   {
      if (m == 0)
 3230dd0:	e0bffa17 	ldw	r2,-24(fp)
 3230dd4:	1004c03a 	cmpne	r2,r2,zero
 3230dd8:	1000041e 	bne	r2,zero,3230dec <soreceive+0x724>
         so->so_rcv.sb_mb = nextrecord;
 3230ddc:	e0fffb17 	ldw	r3,-20(fp)
 3230de0:	e0bff517 	ldw	r2,-44(fp)
 3230de4:	18801015 	stw	r2,64(r3)
 3230de8:	00000a06 	br	3230e14 <soreceive+0x74c>
      else if (pr->pr_flags & PR_ATOMIC)
 3230dec:	e0bff617 	ldw	r2,-40(fp)
 3230df0:	1080010b 	ldhu	r2,4(r2)
 3230df4:	10bfffcc 	andi	r2,r2,65535
 3230df8:	1080004c 	andi	r2,r2,1
 3230dfc:	10803fcc 	andi	r2,r2,255
 3230e00:	1005003a 	cmpeq	r2,r2,zero
 3230e04:	1000031e 	bne	r2,zero,3230e14 <soreceive+0x74c>
         (void) sbdroprecord(&so->so_rcv);
 3230e08:	e0bffb17 	ldw	r2,-20(fp)
 3230e0c:	11000a04 	addi	r4,r2,40
 3230e10:	3232d1c0 	call	3232d1c <sbdroprecord>
      if (pr->pr_flags & PR_WANTRCVD && so->so_pcb)
 3230e14:	e0bff617 	ldw	r2,-40(fp)
 3230e18:	1080010b 	ldhu	r2,4(r2)
 3230e1c:	10bfffcc 	andi	r2,r2,65535
 3230e20:	1080020c 	andi	r2,r2,8
 3230e24:	1005003a 	cmpeq	r2,r2,zero
 3230e28:	10000d1e 	bne	r2,zero,3230e60 <soreceive+0x798>
 3230e2c:	e0bffb17 	ldw	r2,-20(fp)
 3230e30:	10800117 	ldw	r2,4(r2)
 3230e34:	1005003a 	cmpeq	r2,r2,zero
 3230e38:	1000091e 	bne	r2,zero,3230e60 <soreceive+0x798>
      {
         so->so_req = PRU_RCVD;
 3230e3c:	e0fffb17 	ldw	r3,-20(fp)
 3230e40:	00800204 	movi	r2,8
 3230e44:	18800715 	stw	r2,28(r3)
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
 3230e48:	e0bff617 	ldw	r2,-40(fp)
 3230e4c:	10800317 	ldw	r2,12(r2)
 3230e50:	e13ffb17 	ldw	r4,-20(fp)
 3230e54:	000b883a 	mov	r5,zero
 3230e58:	000d883a 	mov	r6,zero
 3230e5c:	103ee83a 	callr	r2
          (struct mbuf *)0);
      }
   }
release:
   sbunlock(&so->so_rcv);
 3230e60:	e0bffb17 	ldw	r2,-20(fp)
 3230e64:	10c0110b 	ldhu	r3,68(r2)
 3230e68:	00bfff84 	movi	r2,-2
 3230e6c:	1884703a 	and	r2,r3,r2
 3230e70:	1007883a 	mov	r3,r2
 3230e74:	e0bffb17 	ldw	r2,-20(fp)
 3230e78:	10c0110d 	sth	r3,68(r2)
 3230e7c:	e0bffb17 	ldw	r2,-20(fp)
 3230e80:	10801104 	addi	r2,r2,68
 3230e84:	1009883a 	mov	r4,r2
 3230e88:	3226c640 	call	3226c64 <tcp_wakeup>
   return (error);
 3230e8c:	e0bff817 	ldw	r2,-32(fp)
 3230e90:	e0bfff15 	stw	r2,-4(fp)
 3230e94:	e0bfff17 	ldw	r2,-4(fp)
}
 3230e98:	e037883a 	mov	sp,fp
 3230e9c:	dfc00117 	ldw	ra,4(sp)
 3230ea0:	df000017 	ldw	fp,0(sp)
 3230ea4:	dec00204 	addi	sp,sp,8
 3230ea8:	f800283a 	ret

03230eac <soshutdown>:
 *
 * RETURNS: int               0 if successful, else error code
 */
int
soshutdown(struct socket *so, int how)
{
 3230eac:	defffb04 	addi	sp,sp,-20
 3230eb0:	dfc00415 	stw	ra,16(sp)
 3230eb4:	df000315 	stw	fp,12(sp)
 3230eb8:	df000304 	addi	fp,sp,12
 3230ebc:	e13ffd15 	stw	r4,-12(fp)
 3230ec0:	e17ffe15 	stw	r5,-8(fp)
   how++;   /* convert 0,1,2 into 1,2,3 */
 3230ec4:	e0bffe17 	ldw	r2,-8(fp)
 3230ec8:	10800044 	addi	r2,r2,1
 3230ecc:	e0bffe15 	stw	r2,-8(fp)
   if (how & 1)   /* caller wanted READ or BOTH */
 3230ed0:	e0bffe17 	ldw	r2,-8(fp)
 3230ed4:	1080004c 	andi	r2,r2,1
 3230ed8:	10803fcc 	andi	r2,r2,255
 3230edc:	1005003a 	cmpeq	r2,r2,zero
 3230ee0:	1000021e 	bne	r2,zero,3230eec <soshutdown+0x40>
      sorflush(so);
 3230ee4:	e13ffd17 	ldw	r4,-12(fp)
 3230ee8:	3230f540 	call	3230f54 <sorflush>

   if (how & 2)   /* caller wanted WRITE or BOTH */
 3230eec:	e0bffe17 	ldw	r2,-8(fp)
 3230ef0:	1080008c 	andi	r2,r2,2
 3230ef4:	1005003a 	cmpeq	r2,r2,zero
 3230ef8:	10000f1e 	bne	r2,zero,3230f38 <soshutdown+0x8c>
   {
      sbflush(&so->so_snd); /* flush the socket send queue */
 3230efc:	e0bffd17 	ldw	r2,-12(fp)
 3230f00:	11001204 	addi	r4,r2,72
 3230f04:	32329ac0 	call	32329ac <sbflush>
      so->so_req = PRU_SHUTDOWN;
 3230f08:	e0fffd17 	ldw	r3,-12(fp)
 3230f0c:	008001c4 	movi	r2,7
 3230f10:	18800715 	stw	r2,28(r3)
      return ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0));
 3230f14:	e0bffd17 	ldw	r2,-12(fp)
 3230f18:	10800217 	ldw	r2,8(r2)
 3230f1c:	10800317 	ldw	r2,12(r2)
 3230f20:	e13ffd17 	ldw	r4,-12(fp)
 3230f24:	000b883a 	mov	r5,zero
 3230f28:	000d883a 	mov	r6,zero
 3230f2c:	103ee83a 	callr	r2
 3230f30:	e0bfff15 	stw	r2,-4(fp)
 3230f34:	00000106 	br	3230f3c <soshutdown+0x90>
   }

   return 0;
 3230f38:	e03fff15 	stw	zero,-4(fp)
 3230f3c:	e0bfff17 	ldw	r2,-4(fp)
}
 3230f40:	e037883a 	mov	sp,fp
 3230f44:	dfc00117 	ldw	ra,4(sp)
 3230f48:	df000017 	ldw	fp,0(sp)
 3230f4c:	dec00204 	addi	sp,sp,8
 3230f50:	f800283a 	ret

03230f54 <sorflush>:
 * socket receive buffer is discarded. Wakeup any processes waiting
 * on the socket.
 */
void
sorflush(struct socket * so)
{
 3230f54:	defffb04 	addi	sp,sp,-20
 3230f58:	dfc00415 	stw	ra,16(sp)
 3230f5c:	df000315 	stw	fp,12(sp)
 3230f60:	df000304 	addi	fp,sp,12
 3230f64:	e13fff15 	stw	r4,-4(fp)
   struct sockbuf *sb =  &so->so_rcv;
 3230f68:	e0bfff17 	ldw	r2,-4(fp)
 3230f6c:	10800a04 	addi	r2,r2,40
 3230f70:	e0bffe15 	stw	r2,-8(fp)
   int   s;

   sblock(sb);
 3230f74:	00000406 	br	3230f88 <sorflush+0x34>
 3230f78:	e0bffe17 	ldw	r2,-8(fp)
 3230f7c:	10800704 	addi	r2,r2,28
 3230f80:	1009883a 	mov	r4,r2
 3230f84:	3226ac40 	call	3226ac4 <tcp_sleep>
 3230f88:	e0bffe17 	ldw	r2,-8(fp)
 3230f8c:	1080070b 	ldhu	r2,28(r2)
 3230f90:	10bfffcc 	andi	r2,r2,65535
 3230f94:	1080004c 	andi	r2,r2,1
 3230f98:	10803fcc 	andi	r2,r2,255
 3230f9c:	1004c03a 	cmpne	r2,r2,zero
 3230fa0:	103ff51e 	bne	r2,zero,3230f78 <sorflush+0x24>
 3230fa4:	e0bffe17 	ldw	r2,-8(fp)
 3230fa8:	1080070b 	ldhu	r2,28(r2)
 3230fac:	10800054 	ori	r2,r2,1
 3230fb0:	1007883a 	mov	r3,r2
 3230fb4:	e0bffe17 	ldw	r2,-8(fp)
 3230fb8:	10c0070d 	sth	r3,28(r2)
   socantrcvmore(so);
 3230fbc:	e13fff17 	ldw	r4,-4(fp)
 3230fc0:	32321800 	call	3232180 <socantrcvmore>
   sbunlock(sb);
 3230fc4:	e0bffe17 	ldw	r2,-8(fp)
 3230fc8:	10c0070b 	ldhu	r3,28(r2)
 3230fcc:	00bfff84 	movi	r2,-2
 3230fd0:	1884703a 	and	r2,r3,r2
 3230fd4:	1007883a 	mov	r3,r2
 3230fd8:	e0bffe17 	ldw	r2,-8(fp)
 3230fdc:	10c0070d 	sth	r3,28(r2)
 3230fe0:	e0bffe17 	ldw	r2,-8(fp)
 3230fe4:	10800704 	addi	r2,r2,28
 3230fe8:	1009883a 	mov	r4,r2
 3230fec:	3226c640 	call	3226c64 <tcp_wakeup>
   sbrelease(sb);
 3230ff0:	e13ffe17 	ldw	r4,-8(fp)
 3230ff4:	32323ec0 	call	32323ec <sbrelease>
   MEMSET((char *)sb, 0, sizeof (*sb));
 3230ff8:	e0bffe17 	ldw	r2,-8(fp)
 3230ffc:	1009883a 	mov	r4,r2
 3231000:	01800804 	movi	r6,32
 3231004:	000b883a 	mov	r5,zero
 3231008:	3206c500 	call	3206c50 <memset>
   s = so->so_error;
 323100c:	e0bfff17 	ldw	r2,-4(fp)
 3231010:	10800617 	ldw	r2,24(r2)
 3231014:	e0bffd15 	stw	r2,-12(fp)
   so->so_error = ESHUTDOWN;
 3231018:	e0ffff17 	ldw	r3,-4(fp)
 323101c:	00801b84 	movi	r2,110
 3231020:	18800615 	stw	r2,24(r3)
   sorwakeup(so);
 3231024:	e0bfff17 	ldw	r2,-4(fp)
 3231028:	11400a04 	addi	r5,r2,40
 323102c:	e13fff17 	ldw	r4,-4(fp)
 3231030:	32322700 	call	3232270 <sbwakeup>
   so->so_error = s;
 3231034:	e0ffff17 	ldw	r3,-4(fp)
 3231038:	e0bffd17 	ldw	r2,-12(fp)
 323103c:	18800615 	stw	r2,24(r3)
}
 3231040:	e037883a 	mov	sp,fp
 3231044:	dfc00117 	ldw	ra,4(sp)
 3231048:	df000017 	ldw	fp,0(sp)
 323104c:	dec00204 	addi	sp,sp,8
 3231050:	f800283a 	ret

03231054 <sosetopt>:

int
sosetopt(struct socket * so, 
   int   optname,
   void *   arg)
{
 3231054:	defff404 	addi	sp,sp,-48
 3231058:	dfc00b15 	stw	ra,44(sp)
 323105c:	df000a15 	stw	fp,40(sp)
 3231060:	df000a04 	addi	fp,sp,40
 3231064:	e13ffb15 	stw	r4,-20(fp)
 3231068:	e17ffc15 	stw	r5,-16(fp)
 323106c:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 3231070:	e03ffa15 	stw	zero,-24(fp)

   switch (optname) 
 3231074:	e0bffc17 	ldw	r2,-16(fp)
 3231078:	e0bfff15 	stw	r2,-4(fp)
 323107c:	e0ffff17 	ldw	r3,-4(fp)
 3231080:	18808020 	cmpeqi	r2,r3,512
 3231084:	1000521e 	bne	r2,zero,32311d0 <sosetopt+0x17c>
 3231088:	e0ffff17 	ldw	r3,-4(fp)
 323108c:	18808048 	cmpgei	r2,r3,513
 3231090:	1000211e 	bne	r2,zero,3231118 <sosetopt+0xc4>
 3231094:	e0ffff17 	ldw	r3,-4(fp)
 3231098:	18800388 	cmpgei	r2,r3,14
 323109c:	10000d1e 	bne	r2,zero,32310d4 <sosetopt+0x80>
 32310a0:	e0ffff17 	ldw	r3,-4(fp)
 32310a4:	18800248 	cmpgei	r2,r3,9
 32310a8:	10009d1e 	bne	r2,zero,3231320 <sosetopt+0x2cc>
 32310ac:	e0ffff17 	ldw	r3,-4(fp)
 32310b0:	18800120 	cmpeqi	r2,r3,4
 32310b4:	1000461e 	bne	r2,zero,32311d0 <sosetopt+0x17c>
 32310b8:	e0ffff17 	ldw	r3,-4(fp)
 32310bc:	18800220 	cmpeqi	r2,r3,8
 32310c0:	1000431e 	bne	r2,zero,32311d0 <sosetopt+0x17c>
 32310c4:	e0ffff17 	ldw	r3,-4(fp)
 32310c8:	188000a0 	cmpeqi	r2,r3,2
 32310cc:	10009a1e 	bne	r2,zero,3231338 <sosetopt+0x2e4>
 32310d0:	00010806 	br	32314f4 <sosetopt+0x4a0>
 32310d4:	e0ffff17 	ldw	r3,-4(fp)
 32310d8:	18800820 	cmpeqi	r2,r3,32
 32310dc:	10003c1e 	bne	r2,zero,32311d0 <sosetopt+0x17c>
 32310e0:	e0ffff17 	ldw	r3,-4(fp)
 32310e4:	18800848 	cmpgei	r2,r3,33
 32310e8:	1000041e 	bne	r2,zero,32310fc <sosetopt+0xa8>
 32310ec:	e0ffff17 	ldw	r3,-4(fp)
 32310f0:	18800420 	cmpeqi	r2,r3,16
 32310f4:	1000361e 	bne	r2,zero,32311d0 <sosetopt+0x17c>
 32310f8:	0000fe06 	br	32314f4 <sosetopt+0x4a0>
 32310fc:	e0ffff17 	ldw	r3,-4(fp)
 3231100:	18802020 	cmpeqi	r2,r3,128
 3231104:	10002d1e 	bne	r2,zero,32311bc <sosetopt+0x168>
 3231108:	e0ffff17 	ldw	r3,-4(fp)
 323110c:	18804020 	cmpeqi	r2,r3,256
 3231110:	10002f1e 	bne	r2,zero,32311d0 <sosetopt+0x17c>
 3231114:	0000f706 	br	32314f4 <sosetopt+0x4a0>
 3231118:	e0ffff17 	ldw	r3,-4(fp)
 323111c:	18840520 	cmpeqi	r2,r3,4116
 3231120:	1000571e 	bne	r2,zero,3231280 <sosetopt+0x22c>
 3231124:	e0ffff17 	ldw	r3,-4(fp)
 3231128:	18840548 	cmpgei	r2,r3,4117
 323112c:	10000f1e 	bne	r2,zero,323116c <sosetopt+0x118>
 3231130:	e0ffff17 	ldw	r3,-4(fp)
 3231134:	188401a0 	cmpeqi	r2,r3,4102
 3231138:	10004c1e 	bne	r2,zero,323126c <sosetopt+0x218>
 323113c:	e0ffff17 	ldw	r3,-4(fp)
 3231140:	188401c8 	cmpgei	r2,r3,4103
 3231144:	1000051e 	bne	r2,zero,323115c <sosetopt+0x108>
 3231148:	e0ffff17 	ldw	r3,-4(fp)
 323114c:	18bbffc4 	addi	r2,r3,-4097
 3231150:	108000a8 	cmpgeui	r2,r2,2
 3231154:	1000e71e 	bne	r2,zero,32314f4 <sosetopt+0x4a0>
 3231158:	00003006 	br	323121c <sosetopt+0x1c8>
 323115c:	e0ffff17 	ldw	r3,-4(fp)
 3231160:	18840420 	cmpeqi	r2,r3,4112
 3231164:	1000ba1e 	bne	r2,zero,3231450 <sosetopt+0x3fc>
 3231168:	0000e206 	br	32314f4 <sosetopt+0x4a0>
 323116c:	e0ffff17 	ldw	r3,-4(fp)
 3231170:	188800e0 	cmpeqi	r2,r3,8195
 3231174:	1000b61e 	bne	r2,zero,3231450 <sosetopt+0x3fc>
 3231178:	e0ffff17 	ldw	r3,-4(fp)
 323117c:	18880108 	cmpgei	r2,r3,8196
 3231180:	1000071e 	bne	r2,zero,32311a0 <sosetopt+0x14c>
 3231184:	e0ffff17 	ldw	r3,-4(fp)
 3231188:	18840560 	cmpeqi	r2,r3,4117
 323118c:	1000431e 	bne	r2,zero,323129c <sosetopt+0x248>
 3231190:	e0ffff17 	ldw	r3,-4(fp)
 3231194:	188405a0 	cmpeqi	r2,r3,4118
 3231198:	1000481e 	bne	r2,zero,32312bc <sosetopt+0x268>
 323119c:	0000d506 	br	32314f4 <sosetopt+0x4a0>
 32311a0:	e0ffff17 	ldw	r3,-4(fp)
 32311a4:	18880120 	cmpeqi	r2,r3,8196
 32311a8:	10007a1e 	bne	r2,zero,3231394 <sosetopt+0x340>
 32311ac:	e0ffff17 	ldw	r3,-4(fp)
 32311b0:	18900020 	cmpeqi	r2,r3,16384
 32311b4:	1000061e 	bne	r2,zero,32311d0 <sosetopt+0x17c>
 32311b8:	0000ce06 	br	32314f4 <sosetopt+0x4a0>
   {
   case SO_LINGER:
      so->so_linger = (short)((struct linger *)arg)->l_linger;
 32311bc:	e0bffd17 	ldw	r2,-12(fp)
 32311c0:	10800117 	ldw	r2,4(r2)
 32311c4:	1007883a 	mov	r3,r2
 32311c8:	e0bffb17 	ldw	r2,-20(fp)
 32311cc:	10c0080d 	sth	r3,32(r2)
   case SO_TCPSACK:
   case SO_NOSLOWSTART:
#ifdef SUPPORT_SO_FULLMSS
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
 32311d0:	e0bffd17 	ldw	r2,-12(fp)
 32311d4:	10800017 	ldw	r2,0(r2)
 32311d8:	1005003a 	cmpeq	r2,r2,zero
 32311dc:	1000071e 	bne	r2,zero,32311fc <sosetopt+0x1a8>
         so->so_options |= optname;
 32311e0:	e0bffb17 	ldw	r2,-20(fp)
 32311e4:	10c00417 	ldw	r3,16(r2)
 32311e8:	e0bffc17 	ldw	r2,-16(fp)
 32311ec:	1886b03a 	or	r3,r3,r2
 32311f0:	e0bffb17 	ldw	r2,-20(fp)
 32311f4:	10c00415 	stw	r3,16(r2)
 32311f8:	0000c006 	br	32314fc <sosetopt+0x4a8>
      else
         so->so_options &= ~optname;
 32311fc:	e0bffb17 	ldw	r2,-20(fp)
 3231200:	10c00417 	ldw	r3,16(r2)
 3231204:	e0bffc17 	ldw	r2,-16(fp)
 3231208:	0084303a 	nor	r2,zero,r2
 323120c:	1886703a 	and	r3,r3,r2
 3231210:	e0bffb17 	ldw	r2,-20(fp)
 3231214:	10c00415 	stw	r3,16(r2)
      break;
 3231218:	0000b806 	br	32314fc <sosetopt+0x4a8>
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 323121c:	e0bffc17 	ldw	r2,-16(fp)
 3231220:	10840058 	cmpnei	r2,r2,4097
 3231224:	1000041e 	bne	r2,zero,3231238 <sosetopt+0x1e4>
 3231228:	e0bffb17 	ldw	r2,-20(fp)
 323122c:	10801204 	addi	r2,r2,72
 3231230:	e0bffe15 	stw	r2,-8(fp)
 3231234:	00000306 	br	3231244 <sosetopt+0x1f0>
 3231238:	e0bffb17 	ldw	r2,-20(fp)
 323123c:	10800a04 	addi	r2,r2,40
 3231240:	e0bffe15 	stw	r2,-8(fp)
 3231244:	e0bffd17 	ldw	r2,-12(fp)
 3231248:	10800017 	ldw	r2,0(r2)
 323124c:	100b883a 	mov	r5,r2
 3231250:	e13ffe17 	ldw	r4,-8(fp)
 3231254:	323238c0 	call	323238c <sbreserve>
 3231258:	1004c03a 	cmpne	r2,r2,zero
 323125c:	1000a71e 	bne	r2,zero,32314fc <sosetopt+0x4a8>
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
 3231260:	00801a44 	movi	r2,105
 3231264:	e0bffa15 	stw	r2,-24(fp)
         goto bad;
 3231268:	0000a406 	br	32314fc <sosetopt+0x4a8>
      }
      break;

   case SO_RCVTIMEO:
      so->so_rcv.sb_timeo = *(short *)arg;
 323126c:	e0bffd17 	ldw	r2,-12(fp)
 3231270:	10c0000b 	ldhu	r3,0(r2)
 3231274:	e0bffb17 	ldw	r2,-20(fp)
 3231278:	10c0118d 	sth	r3,70(r2)
      break;
 323127c:	00009f06 	br	32314fc <sosetopt+0x4a8>

   case SO_NBIO:     /* set socket into NON-blocking mode */
      so->so_state |= SS_NBIO;
 3231280:	e0bffb17 	ldw	r2,-20(fp)
 3231284:	1080088b 	ldhu	r2,34(r2)
 3231288:	10804014 	ori	r2,r2,256
 323128c:	1007883a 	mov	r3,r2
 3231290:	e0bffb17 	ldw	r2,-20(fp)
 3231294:	10c0088d 	sth	r3,34(r2)
      break;
 3231298:	00009806 	br	32314fc <sosetopt+0x4a8>

   case SO_BIO:   /* set socket into blocking mode */
      so->so_state &= ~SS_NBIO;
 323129c:	e0bffb17 	ldw	r2,-20(fp)
 32312a0:	10c0088b 	ldhu	r3,34(r2)
 32312a4:	00bfbfc4 	movi	r2,-257
 32312a8:	1884703a 	and	r2,r3,r2
 32312ac:	1007883a 	mov	r3,r2
 32312b0:	e0bffb17 	ldw	r2,-20(fp)
 32312b4:	10c0088d 	sth	r3,34(r2)
      break;
 32312b8:	00009006 	br	32314fc <sosetopt+0x4a8>

   case SO_NONBLOCK:    /* set blocking mode according to arg */
      /* sanity check the arg parameter */
      if (!arg)
 32312bc:	e0bffd17 	ldw	r2,-12(fp)
 32312c0:	1004c03a 	cmpne	r2,r2,zero
 32312c4:	1000031e 	bne	r2,zero,32312d4 <sosetopt+0x280>
      {
         error = ENP_PARAM;
 32312c8:	00bffd84 	movi	r2,-10
 32312cc:	e0bffa15 	stw	r2,-24(fp)
         break;
 32312d0:	00008a06 	br	32314fc <sosetopt+0x4a8>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 32312d4:	e0bffd17 	ldw	r2,-12(fp)
 32312d8:	10800017 	ldw	r2,0(r2)
 32312dc:	1005003a 	cmpeq	r2,r2,zero
 32312e0:	1000071e 	bne	r2,zero,3231300 <sosetopt+0x2ac>
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
 32312e4:	e0bffb17 	ldw	r2,-20(fp)
 32312e8:	1080088b 	ldhu	r2,34(r2)
 32312ec:	10804014 	ori	r2,r2,256
 32312f0:	1007883a 	mov	r3,r2
 32312f4:	e0bffb17 	ldw	r2,-20(fp)
 32312f8:	10c0088d 	sth	r3,34(r2)
 32312fc:	00007f06 	br	32314fc <sosetopt+0x4a8>
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
 3231300:	e0bffb17 	ldw	r2,-20(fp)
 3231304:	10c0088b 	ldhu	r3,34(r2)
 3231308:	00bfbfc4 	movi	r2,-257
 323130c:	1884703a 	and	r2,r3,r2
 3231310:	1007883a 	mov	r3,r2
 3231314:	e0bffb17 	ldw	r2,-20(fp)
 3231318:	10c0088d 	sth	r3,34(r2)
      break;
 323131c:	00007706 	br	32314fc <sosetopt+0x4a8>
   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      error = ip_setmoptions(optname, so, arg);
 3231320:	e13ffc17 	ldw	r4,-16(fp)
 3231324:	e17ffb17 	ldw	r5,-20(fp)
 3231328:	e1bffd17 	ldw	r6,-12(fp)
 323132c:	32462100 	call	3246210 <ip_setmoptions>
 3231330:	e0bffa15 	stw	r2,-24(fp)
      break;
 3231334:	00007106 	br	32314fc <sosetopt+0x4a8>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 3231338:	e0bffd17 	ldw	r2,-12(fp)
 323133c:	1004c03a 	cmpne	r2,r2,zero
 3231340:	1000031e 	bne	r2,zero,3231350 <sosetopt+0x2fc>
      {
         error = ENP_PARAM;
 3231344:	00bffd84 	movi	r2,-10
 3231348:	e0bffa15 	stw	r2,-24(fp)
         break;
 323134c:	00006b06 	br	32314fc <sosetopt+0x4a8>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
 3231350:	e0bffd17 	ldw	r2,-12(fp)
 3231354:	10800017 	ldw	r2,0(r2)
 3231358:	1005003a 	cmpeq	r2,r2,zero
 323135c:	1000061e 	bne	r2,zero,3231378 <sosetopt+0x324>
         so->so_options |= SO_HDRINCL;
 3231360:	e0bffb17 	ldw	r2,-20(fp)
 3231364:	10800417 	ldw	r2,16(r2)
 3231368:	10c80014 	ori	r3,r2,8192
 323136c:	e0bffb17 	ldw	r2,-20(fp)
 3231370:	10c00415 	stw	r3,16(r2)
 3231374:	00006106 	br	32314fc <sosetopt+0x4a8>
      else
         so->so_options &= ~SO_HDRINCL;
 3231378:	e0bffb17 	ldw	r2,-20(fp)
 323137c:	10c00417 	ldw	r3,16(r2)
 3231380:	00b7ffc4 	movi	r2,-8193
 3231384:	1886703a 	and	r3,r3,r2
 3231388:	e0bffb17 	ldw	r2,-20(fp)
 323138c:	10c00415 	stw	r3,16(r2)
      break;
 3231390:	00005a06 	br	32314fc <sosetopt+0x4a8>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 3231394:	e0bffb17 	ldw	r2,-20(fp)
 3231398:	10800983 	ldbu	r2,38(r2)
 323139c:	10803fcc 	andi	r2,r2,255
 32313a0:	1080201c 	xori	r2,r2,128
 32313a4:	10bfe004 	addi	r2,r2,-128
 32313a8:	10800060 	cmpeqi	r2,r2,1
 32313ac:	1000031e 	bne	r2,zero,32313bc <sosetopt+0x368>
      {
         error = EINVAL;
 32313b0:	00800584 	movi	r2,22
 32313b4:	e0bffa15 	stw	r2,-24(fp)
         break;
 32313b8:	00005006 	br	32314fc <sosetopt+0x4a8>
      }
      inp = (struct inpcb *)(so->so_pcb);
 32313bc:	e0bffb17 	ldw	r2,-20(fp)
 32313c0:	10800117 	ldw	r2,4(r2)
 32313c4:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 32313c8:	e0bff917 	ldw	r2,-28(fp)
 32313cc:	10800917 	ldw	r2,36(r2)
 32313d0:	e0bff815 	stw	r2,-32(fp)
      if(!tp)
 32313d4:	e0bff817 	ldw	r2,-32(fp)
 32313d8:	1004c03a 	cmpne	r2,r2,zero
 32313dc:	1000031e 	bne	r2,zero,32313ec <sosetopt+0x398>
      {
         error = ENOTCONN;
 32313e0:	00802004 	movi	r2,128
 32313e4:	e0bffa15 	stw	r2,-24(fp)
         break;
 32313e8:	00004406 	br	32314fc <sosetopt+0x4a8>
      }
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 32313ec:	e0bffd17 	ldw	r2,-12(fp)
 32313f0:	1004c03a 	cmpne	r2,r2,zero
 32313f4:	1000031e 	bne	r2,zero,3231404 <sosetopt+0x3b0>
      {
         error = ENP_PARAM;
 32313f8:	00bffd84 	movi	r2,-10
 32313fc:	e0bffa15 	stw	r2,-24(fp)
         break;
 3231400:	00003e06 	br	32314fc <sosetopt+0x4a8>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 3231404:	e0bffd17 	ldw	r2,-12(fp)
 3231408:	10800017 	ldw	r2,0(r2)
 323140c:	1005003a 	cmpeq	r2,r2,zero
 3231410:	1000071e 	bne	r2,zero,3231430 <sosetopt+0x3dc>
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
 3231414:	e0bff817 	ldw	r2,-32(fp)
 3231418:	10800b0b 	ldhu	r2,44(r2)
 323141c:	10800114 	ori	r2,r2,4
 3231420:	1007883a 	mov	r3,r2
 3231424:	e0bff817 	ldw	r2,-32(fp)
 3231428:	10c00b0d 	sth	r3,44(r2)
 323142c:	00003306 	br	32314fc <sosetopt+0x4a8>
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */
 3231430:	e0bff817 	ldw	r2,-32(fp)
 3231434:	10c00b0b 	ldhu	r3,44(r2)
 3231438:	00bffec4 	movi	r2,-5
 323143c:	1884703a 	and	r2,r3,r2
 3231440:	1007883a 	mov	r3,r2
 3231444:	e0bff817 	ldw	r2,-32(fp)
 3231448:	10c00b0d 	sth	r3,44(r2)

      break;
 323144c:	00002b06 	br	32314fc <sosetopt+0x4a8>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 3231450:	e0bffb17 	ldw	r2,-20(fp)
 3231454:	10800983 	ldbu	r2,38(r2)
 3231458:	10803fcc 	andi	r2,r2,255
 323145c:	1080201c 	xori	r2,r2,128
 3231460:	10bfe004 	addi	r2,r2,-128
 3231464:	10800060 	cmpeqi	r2,r2,1
 3231468:	1000031e 	bne	r2,zero,3231478 <sosetopt+0x424>
      {
         error = EINVAL;
 323146c:	00800584 	movi	r2,22
 3231470:	e0bffa15 	stw	r2,-24(fp)
         break;
 3231474:	00002106 	br	32314fc <sosetopt+0x4a8>
      }
      inp = (struct inpcb *)(so->so_pcb);
 3231478:	e0bffb17 	ldw	r2,-20(fp)
 323147c:	10800117 	ldw	r2,4(r2)
 3231480:	e0bff715 	stw	r2,-36(fp)
      tp = intotcpcb(inp);
 3231484:	e0bff717 	ldw	r2,-36(fp)
 3231488:	10800917 	ldw	r2,36(r2)
 323148c:	e0bff615 	stw	r2,-40(fp)
      if(!tp)
 3231490:	e0bff617 	ldw	r2,-40(fp)
 3231494:	1004c03a 	cmpne	r2,r2,zero
 3231498:	1000031e 	bne	r2,zero,32314a8 <sosetopt+0x454>
      {
         error = ENOTCONN;
 323149c:	00802004 	movi	r2,128
 32314a0:	e0bffa15 	stw	r2,-24(fp)
         break;
 32314a4:	00001506 	br	32314fc <sosetopt+0x4a8>
      }
      if (tp->t_state != TCPS_CLOSED)
 32314a8:	e0bff617 	ldw	r2,-40(fp)
 32314ac:	10800217 	ldw	r2,8(r2)
 32314b0:	1005003a 	cmpeq	r2,r2,zero
 32314b4:	1000031e 	bne	r2,zero,32314c4 <sosetopt+0x470>
      {
         error = EINVAL;
 32314b8:	00800584 	movi	r2,22
 32314bc:	e0bffa15 	stw	r2,-24(fp)
         break;
 32314c0:	00000e06 	br	32314fc <sosetopt+0x4a8>
      }
      tp->t_maxseg = *(int*)(arg);    /* set TCP MSS */
 32314c4:	e0bffd17 	ldw	r2,-12(fp)
 32314c8:	10800017 	ldw	r2,0(r2)
 32314cc:	1007883a 	mov	r3,r2
 32314d0:	e0bff617 	ldw	r2,-40(fp)
 32314d4:	10c00a0d 	sth	r3,40(r2)
      tp->t_flags |= TF_MAXSEG;   /* mark as user set max seg */
 32314d8:	e0bff617 	ldw	r2,-40(fp)
 32314dc:	10800b0b 	ldhu	r2,44(r2)
 32314e0:	10810014 	ori	r2,r2,1024
 32314e4:	1007883a 	mov	r3,r2
 32314e8:	e0bff617 	ldw	r2,-40(fp)
 32314ec:	10c00b0d 	sth	r3,44(r2)
      break;
 32314f0:	00000206 	br	32314fc <sosetopt+0x4a8>
   }
   default:
      error = ENOPROTOOPT;
 32314f4:	00801b44 	movi	r2,109
 32314f8:	e0bffa15 	stw	r2,-24(fp)
      break;
   }
bad:
   return (error);
 32314fc:	e0bffa17 	ldw	r2,-24(fp)
}
 3231500:	e037883a 	mov	sp,fp
 3231504:	dfc00117 	ldw	ra,4(sp)
 3231508:	df000017 	ldw	fp,0(sp)
 323150c:	dec00204 	addi	sp,sp,8
 3231510:	f800283a 	ret

03231514 <sogetopt>:

int
sogetopt(struct socket * so, 
   int   optname,
   void *   val)
{
 3231514:	defff304 	addi	sp,sp,-52
 3231518:	dfc00c15 	stw	ra,48(sp)
 323151c:	df000b15 	stw	fp,44(sp)
 3231520:	df000b04 	addi	fp,sp,44
 3231524:	e13ffb15 	stw	r4,-20(fp)
 3231528:	e17ffc15 	stw	r5,-16(fp)
 323152c:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 3231530:	e03ffa15 	stw	zero,-24(fp)

   /* sanity check the val parameter */
   if (!val)
 3231534:	e0bffd17 	ldw	r2,-12(fp)
 3231538:	1004c03a 	cmpne	r2,r2,zero
 323153c:	1000031e 	bne	r2,zero,323154c <sogetopt+0x38>
   {
      return ENP_PARAM;
 3231540:	00bffd84 	movi	r2,-10
 3231544:	e0bffe15 	stw	r2,-8(fp)
 3231548:	00013c06 	br	3231a3c <sogetopt+0x528>
   }

   switch (optname) 
 323154c:	e0fffc17 	ldw	r3,-16(fp)
 3231550:	e0ffff15 	stw	r3,-4(fp)
 3231554:	e0ffff17 	ldw	r3,-4(fp)
 3231558:	188400e0 	cmpeqi	r2,r3,4099
 323155c:	10008f1e 	bne	r2,zero,323179c <sogetopt+0x288>
 3231560:	e0ffff17 	ldw	r3,-4(fp)
 3231564:	18840108 	cmpgei	r2,r3,4100
 3231568:	10002e1e 	bne	r2,zero,3231624 <sogetopt+0x110>
 323156c:	e0ffff17 	ldw	r3,-4(fp)
 3231570:	18800420 	cmpeqi	r2,r3,16
 3231574:	1000821e 	bne	r2,zero,3231780 <sogetopt+0x26c>
 3231578:	e0ffff17 	ldw	r3,-4(fp)
 323157c:	18800448 	cmpgei	r2,r3,17
 3231580:	1000111e 	bne	r2,zero,32315c8 <sogetopt+0xb4>
 3231584:	e0ffff17 	ldw	r3,-4(fp)
 3231588:	18800220 	cmpeqi	r2,r3,8
 323158c:	10007c1e 	bne	r2,zero,3231780 <sogetopt+0x26c>
 3231590:	e0ffff17 	ldw	r3,-4(fp)
 3231594:	18800248 	cmpgei	r2,r3,9
 3231598:	1000071e 	bne	r2,zero,32315b8 <sogetopt+0xa4>
 323159c:	e0ffff17 	ldw	r3,-4(fp)
 32315a0:	188000a0 	cmpeqi	r2,r3,2
 32315a4:	1000eb1e 	bne	r2,zero,3231954 <sogetopt+0x440>
 32315a8:	e0ffff17 	ldw	r3,-4(fp)
 32315ac:	18800120 	cmpeqi	r2,r3,4
 32315b0:	1000731e 	bne	r2,zero,3231780 <sogetopt+0x26c>
 32315b4:	00011c06 	br	3231a28 <sogetopt+0x514>
 32315b8:	e0ffff17 	ldw	r3,-4(fp)
 32315bc:	18800308 	cmpgei	r2,r3,12
 32315c0:	1001191e 	bne	r2,zero,3231a28 <sogetopt+0x514>
 32315c4:	0000dd06 	br	323193c <sogetopt+0x428>
 32315c8:	e0ffff17 	ldw	r3,-4(fp)
 32315cc:	18804020 	cmpeqi	r2,r3,256
 32315d0:	10006b1e 	bne	r2,zero,3231780 <sogetopt+0x26c>
 32315d4:	e0ffff17 	ldw	r3,-4(fp)
 32315d8:	18804048 	cmpgei	r2,r3,257
 32315dc:	1000071e 	bne	r2,zero,32315fc <sogetopt+0xe8>
 32315e0:	e0ffff17 	ldw	r3,-4(fp)
 32315e4:	18800820 	cmpeqi	r2,r3,32
 32315e8:	1000651e 	bne	r2,zero,3231780 <sogetopt+0x26c>
 32315ec:	e0ffff17 	ldw	r3,-4(fp)
 32315f0:	18802020 	cmpeqi	r2,r3,128
 32315f4:	1000531e 	bne	r2,zero,3231744 <sogetopt+0x230>
 32315f8:	00010b06 	br	3231a28 <sogetopt+0x514>
 32315fc:	e0ffff17 	ldw	r3,-4(fp)
 3231600:	18840060 	cmpeqi	r2,r3,4097
 3231604:	10006f1e 	bne	r2,zero,32317c4 <sogetopt+0x2b0>
 3231608:	e0ffff17 	ldw	r3,-4(fp)
 323160c:	18840088 	cmpgei	r2,r3,4098
 3231610:	1000711e 	bne	r2,zero,32317d8 <sogetopt+0x2c4>
 3231614:	e0ffff17 	ldw	r3,-4(fp)
 3231618:	18808020 	cmpeqi	r2,r3,512
 323161c:	1000581e 	bne	r2,zero,3231780 <sogetopt+0x26c>
 3231620:	00010106 	br	3231a28 <sogetopt+0x514>
 3231624:	e0ffff17 	ldw	r3,-4(fp)
 3231628:	18840420 	cmpeqi	r2,r3,4112
 323162c:	1000881e 	bne	r2,zero,3231850 <sogetopt+0x33c>
 3231630:	e0ffff17 	ldw	r3,-4(fp)
 3231634:	18840448 	cmpgei	r2,r3,4113
 3231638:	1000171e 	bne	r2,zero,3231698 <sogetopt+0x184>
 323163c:	e0ffff17 	ldw	r3,-4(fp)
 3231640:	188401a0 	cmpeqi	r2,r3,4102
 3231644:	1000a31e 	bne	r2,zero,32318d4 <sogetopt+0x3c0>
 3231648:	e0ffff17 	ldw	r3,-4(fp)
 323164c:	188401c8 	cmpgei	r2,r3,4103
 3231650:	1000071e 	bne	r2,zero,3231670 <sogetopt+0x15c>
 3231654:	e0ffff17 	ldw	r3,-4(fp)
 3231658:	18840120 	cmpeqi	r2,r3,4100
 323165c:	1000541e 	bne	r2,zero,32317b0 <sogetopt+0x29c>
 3231660:	e0ffff17 	ldw	r3,-4(fp)
 3231664:	18840160 	cmpeqi	r2,r3,4101
 3231668:	1000951e 	bne	r2,zero,32318c0 <sogetopt+0x3ac>
 323166c:	0000ee06 	br	3231a28 <sogetopt+0x514>
 3231670:	e0ffff17 	ldw	r3,-4(fp)
 3231674:	18840220 	cmpeqi	r2,r3,4104
 3231678:	1000661e 	bne	r2,zero,3231814 <sogetopt+0x300>
 323167c:	e0ffff17 	ldw	r3,-4(fp)
 3231680:	18840210 	cmplti	r2,r3,4104
 3231684:	10006b1e 	bne	r2,zero,3231834 <sogetopt+0x320>
 3231688:	e0ffff17 	ldw	r3,-4(fp)
 323168c:	18840260 	cmpeqi	r2,r3,4105
 3231690:	1000951e 	bne	r2,zero,32318e8 <sogetopt+0x3d4>
 3231694:	0000e406 	br	3231a28 <sogetopt+0x514>
 3231698:	e0ffff17 	ldw	r3,-4(fp)
 323169c:	188404e0 	cmpeqi	r2,r3,4115
 32316a0:	1000141e 	bne	r2,zero,32316f4 <sogetopt+0x1e0>
 32316a4:	e0ffff17 	ldw	r3,-4(fp)
 32316a8:	18840508 	cmpgei	r2,r3,4116
 32316ac:	1000071e 	bne	r2,zero,32316cc <sogetopt+0x1b8>
 32316b0:	e0ffff17 	ldw	r3,-4(fp)
 32316b4:	18840460 	cmpeqi	r2,r3,4113
 32316b8:	10004c1e 	bne	r2,zero,32317ec <sogetopt+0x2d8>
 32316bc:	e0ffff17 	ldw	r3,-4(fp)
 32316c0:	188404a0 	cmpeqi	r2,r3,4114
 32316c4:	10004e1e 	bne	r2,zero,3231800 <sogetopt+0x2ec>
 32316c8:	0000d706 	br	3231a28 <sogetopt+0x514>
 32316cc:	e0ffff17 	ldw	r3,-4(fp)
 32316d0:	188800e0 	cmpeqi	r2,r3,8195
 32316d4:	10005e1e 	bne	r2,zero,3231850 <sogetopt+0x33c>
 32316d8:	e0ffff17 	ldw	r3,-4(fp)
 32316dc:	18880120 	cmpeqi	r2,r3,8196
 32316e0:	1000a81e 	bne	r2,zero,3231984 <sogetopt+0x470>
 32316e4:	e0ffff17 	ldw	r3,-4(fp)
 32316e8:	188405a0 	cmpeqi	r2,r3,4118
 32316ec:	1000861e 	bne	r2,zero,3231908 <sogetopt+0x3f4>
 32316f0:	0000cd06 	br	3231a28 <sogetopt+0x514>
   {
   case SO_MYADDR:
      /* Get my IP address. */
      if (so->so_state & SS_ISCONNECTED)
 32316f4:	e0bffb17 	ldw	r2,-20(fp)
 32316f8:	1080088b 	ldhu	r2,34(r2)
 32316fc:	10bfffcc 	andi	r2,r2,65535
 3231700:	1080008c 	andi	r2,r2,2
 3231704:	1005003a 	cmpeq	r2,r2,zero
 3231708:	1000071e 	bne	r2,zero,3231728 <sogetopt+0x214>
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
 323170c:	e0fffd17 	ldw	r3,-12(fp)
 3231710:	e0bffb17 	ldw	r2,-20(fp)
 3231714:	10800117 	ldw	r2,4(r2)
 3231718:	10800a17 	ldw	r2,40(r2)
 323171c:	10800a17 	ldw	r2,40(r2)
 3231720:	18800015 	stw	r2,0(r3)
 3231724:	0000c306 	br	3231a34 <sogetopt+0x520>
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
 3231728:	e0fffd17 	ldw	r3,-12(fp)
 323172c:	0080c9b4 	movhi	r2,806
 3231730:	10b34504 	addi	r2,r2,-13036
 3231734:	10800017 	ldw	r2,0(r2)
 3231738:	10800a17 	ldw	r2,40(r2)
 323173c:	18800015 	stw	r2,0(r3)
      break;
 3231740:	0000bc06 	br	3231a34 <sogetopt+0x520>
   case SO_LINGER:
      {
         struct linger *   l  =  (struct  linger *)val;
 3231744:	e0bffd17 	ldw	r2,-12(fp)
 3231748:	e0bff915 	stw	r2,-28(fp)
         l->l_onoff = so->so_options & SO_LINGER;
 323174c:	e0bffb17 	ldw	r2,-20(fp)
 3231750:	10800417 	ldw	r2,16(r2)
 3231754:	10c0200c 	andi	r3,r2,128
 3231758:	e0bff917 	ldw	r2,-28(fp)
 323175c:	10c00015 	stw	r3,0(r2)
         l->l_linger = so->so_linger;
 3231760:	e0bffb17 	ldw	r2,-20(fp)
 3231764:	1080080b 	ldhu	r2,32(r2)
 3231768:	10ffffcc 	andi	r3,r2,65535
 323176c:	18e0001c 	xori	r3,r3,32768
 3231770:	18e00004 	addi	r3,r3,-32768
 3231774:	e0bff917 	ldw	r2,-28(fp)
 3231778:	10c00115 	stw	r3,4(r2)
      }
      break;
 323177c:	0000ad06 	br	3231a34 <sogetopt+0x520>
   case SO_OOBINLINE:
   case SO_DONTROUTE:
   case SO_REUSEADDR:
   case SO_BROADCAST:
   case SO_TCPSACK:
      *(int *)val = so->so_options & optname;
 3231780:	e13ffd17 	ldw	r4,-12(fp)
 3231784:	e0bffb17 	ldw	r2,-20(fp)
 3231788:	10c00417 	ldw	r3,16(r2)
 323178c:	e0bffc17 	ldw	r2,-16(fp)
 3231790:	1884703a 	and	r2,r3,r2
 3231794:	20800015 	stw	r2,0(r4)
      break;
 3231798:	0000a606 	br	3231a34 <sogetopt+0x520>

   case SO_SNDLOWAT:
      *(int *)val = (int)so->so_snd.sb_lowat;
 323179c:	e0fffd17 	ldw	r3,-12(fp)
 32317a0:	e0bffb17 	ldw	r2,-20(fp)
 32317a4:	10801617 	ldw	r2,88(r2)
 32317a8:	18800015 	stw	r2,0(r3)
      break;
 32317ac:	0000a106 	br	3231a34 <sogetopt+0x520>

   case SO_RCVLOWAT:
      *(int *)val = (int)so->so_rcv.sb_lowat;
 32317b0:	e0fffd17 	ldw	r3,-12(fp)
 32317b4:	e0bffb17 	ldw	r2,-20(fp)
 32317b8:	10800e17 	ldw	r2,56(r2)
 32317bc:	18800015 	stw	r2,0(r3)
      break;
 32317c0:	00009c06 	br	3231a34 <sogetopt+0x520>

   case SO_SNDBUF:
      *(int *)val = (int)so->so_snd.sb_hiwat;
 32317c4:	e0fffd17 	ldw	r3,-12(fp)
 32317c8:	e0bffb17 	ldw	r2,-20(fp)
 32317cc:	10801317 	ldw	r2,76(r2)
 32317d0:	18800015 	stw	r2,0(r3)
      break;
 32317d4:	00009706 	br	3231a34 <sogetopt+0x520>

   case SO_RCVBUF:
      *(int *)val = (int)so->so_rcv.sb_hiwat;
 32317d8:	e0fffd17 	ldw	r3,-12(fp)
 32317dc:	e0bffb17 	ldw	r2,-20(fp)
 32317e0:	10800b17 	ldw	r2,44(r2)
 32317e4:	18800015 	stw	r2,0(r3)
      break;
 32317e8:	00009206 	br	3231a34 <sogetopt+0x520>

   case SO_RXDATA:   /* added, JB */
      *(int *)val = (int)so->so_rcv.sb_cc;
 32317ec:	e0fffd17 	ldw	r3,-12(fp)
 32317f0:	e0bffb17 	ldw	r2,-20(fp)
 32317f4:	10800a17 	ldw	r2,40(r2)
 32317f8:	18800015 	stw	r2,0(r3)
      break;
 32317fc:	00008d06 	br	3231a34 <sogetopt+0x520>

   case SO_TXDATA:   /* added for rel 1.8 */
      *(int *)val = (int)so->so_snd.sb_cc;
 3231800:	e0fffd17 	ldw	r3,-12(fp)
 3231804:	e0bffb17 	ldw	r2,-20(fp)
 3231808:	10801217 	ldw	r2,72(r2)
 323180c:	18800015 	stw	r2,0(r3)
      break;
 3231810:	00008806 	br	3231a34 <sogetopt+0x520>

   case SO_TYPE:
      *(int *)val = so->so_type;
 3231814:	e0fffd17 	ldw	r3,-12(fp)
 3231818:	e0bffb17 	ldw	r2,-20(fp)
 323181c:	10800983 	ldbu	r2,38(r2)
 3231820:	10803fcc 	andi	r2,r2,255
 3231824:	1080201c 	xori	r2,r2,128
 3231828:	10bfe004 	addi	r2,r2,-128
 323182c:	18800015 	stw	r2,0(r3)
      break;
 3231830:	00008006 	br	3231a34 <sogetopt+0x520>

   case SO_ERROR:
      *(int *)val = so->so_error;
 3231834:	e0fffd17 	ldw	r3,-12(fp)
 3231838:	e0bffb17 	ldw	r2,-20(fp)
 323183c:	10800617 	ldw	r2,24(r2)
 3231840:	18800015 	stw	r2,0(r3)
      so->so_error = 0;
 3231844:	e0bffb17 	ldw	r2,-20(fp)
 3231848:	10000615 	stw	zero,24(r2)
      break;
 323184c:	00007906 	br	3231a34 <sogetopt+0x520>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 3231850:	e0bffb17 	ldw	r2,-20(fp)
 3231854:	10800983 	ldbu	r2,38(r2)
 3231858:	10803fcc 	andi	r2,r2,255
 323185c:	1080201c 	xori	r2,r2,128
 3231860:	10bfe004 	addi	r2,r2,-128
 3231864:	10800060 	cmpeqi	r2,r2,1
 3231868:	1000031e 	bne	r2,zero,3231878 <sogetopt+0x364>
      {
         error = EINVAL;
 323186c:	00800584 	movi	r2,22
 3231870:	e0bffa15 	stw	r2,-24(fp)
         break;
 3231874:	00006f06 	br	3231a34 <sogetopt+0x520>
      }
      inp = (struct inpcb *)(so->so_pcb);
 3231878:	e0bffb17 	ldw	r2,-20(fp)
 323187c:	10800117 	ldw	r2,4(r2)
 3231880:	e0bff815 	stw	r2,-32(fp)
      tp = intotcpcb(inp);
 3231884:	e0bff817 	ldw	r2,-32(fp)
 3231888:	10800917 	ldw	r2,36(r2)
 323188c:	e0bff715 	stw	r2,-36(fp)
      if(!tp)
 3231890:	e0bff717 	ldw	r2,-36(fp)
 3231894:	1004c03a 	cmpne	r2,r2,zero
 3231898:	1000031e 	bne	r2,zero,32318a8 <sogetopt+0x394>
      {
         error = ENOTCONN;
 323189c:	00802004 	movi	r2,128
 32318a0:	e0bffa15 	stw	r2,-24(fp)
         break;
 32318a4:	00006306 	br	3231a34 <sogetopt+0x520>
      }
      *(int *)val = tp->t_maxseg;     /* Fill in TCP MSS for current socket */
 32318a8:	e0fffd17 	ldw	r3,-12(fp)
 32318ac:	e0bff717 	ldw	r2,-36(fp)
 32318b0:	10800a0b 	ldhu	r2,40(r2)
 32318b4:	10bfffcc 	andi	r2,r2,65535
 32318b8:	18800015 	stw	r2,0(r3)
      break;
 32318bc:	00005d06 	br	3231a34 <sogetopt+0x520>
   }
 
   case SO_SNDTIMEO:
      *(short*)val = so->so_snd.sb_timeo;
 32318c0:	e0bffd17 	ldw	r2,-12(fp)
 32318c4:	e0fffb17 	ldw	r3,-20(fp)
 32318c8:	18c0198b 	ldhu	r3,102(r3)
 32318cc:	10c0000d 	sth	r3,0(r2)
      break;
 32318d0:	00005806 	br	3231a34 <sogetopt+0x520>

   case SO_RCVTIMEO:
      *(short*)val = so->so_rcv.sb_timeo;
 32318d4:	e0bffd17 	ldw	r2,-12(fp)
 32318d8:	e0fffb17 	ldw	r3,-20(fp)
 32318dc:	18c0118b 	ldhu	r3,70(r3)
 32318e0:	10c0000d 	sth	r3,0(r2)
      break;
 32318e4:	00005306 	br	3231a34 <sogetopt+0x520>

   case SO_HOPCNT:
      *(int *)val = so->so_hopcnt;
 32318e8:	e0fffd17 	ldw	r3,-12(fp)
 32318ec:	e0bffb17 	ldw	r2,-20(fp)
 32318f0:	108009c3 	ldbu	r2,39(r2)
 32318f4:	10803fcc 	andi	r2,r2,255
 32318f8:	1080201c 	xori	r2,r2,128
 32318fc:	10bfe004 	addi	r2,r2,-128
 3231900:	18800015 	stw	r2,0(r3)
      break;
 3231904:	00004b06 	br	3231a34 <sogetopt+0x520>

   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
 3231908:	e0bffb17 	ldw	r2,-20(fp)
 323190c:	1080088b 	ldhu	r2,34(r2)
 3231910:	10bfffcc 	andi	r2,r2,65535
 3231914:	1080400c 	andi	r2,r2,256
 3231918:	1005003a 	cmpeq	r2,r2,zero
 323191c:	1000041e 	bne	r2,zero,3231930 <sogetopt+0x41c>
         *(int *)val = 1;   /* return 1 in val */
 3231920:	e0fffd17 	ldw	r3,-12(fp)
 3231924:	00800044 	movi	r2,1
 3231928:	18800015 	stw	r2,0(r3)
 323192c:	00004106 	br	3231a34 <sogetopt+0x520>
      else
         *(int *)val = 0;     /* return 0 in val */
 3231930:	e0bffd17 	ldw	r2,-12(fp)
 3231934:	10000015 	stw	zero,0(r2)
      break;
 3231938:	00003e06 	br	3231a34 <sogetopt+0x520>
#ifdef IP_MULTICAST

   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      error = ip_getmoptions(optname, so, val);
 323193c:	e13ffc17 	ldw	r4,-16(fp)
 3231940:	e17ffb17 	ldw	r5,-20(fp)
 3231944:	e1bffd17 	ldw	r6,-12(fp)
 3231948:	32468000 	call	3246800 <ip_getmoptions>
 323194c:	e0bffa15 	stw	r2,-24(fp)
      break;
 3231950:	00003806 	br	3231a34 <sogetopt+0x520>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
 3231954:	e0bffb17 	ldw	r2,-20(fp)
 3231958:	10800417 	ldw	r2,16(r2)
 323195c:	1088000c 	andi	r2,r2,8192
 3231960:	1005003a 	cmpeq	r2,r2,zero
 3231964:	1000041e 	bne	r2,zero,3231978 <sogetopt+0x464>
         *(int *)val = 1;
 3231968:	e0fffd17 	ldw	r3,-12(fp)
 323196c:	00800044 	movi	r2,1
 3231970:	18800015 	stw	r2,0(r3)
 3231974:	00002f06 	br	3231a34 <sogetopt+0x520>
      else
         *(int *)val = 0;
 3231978:	e0bffd17 	ldw	r2,-12(fp)
 323197c:	10000015 	stw	zero,0(r2)
      break;
 3231980:	00002c06 	br	3231a34 <sogetopt+0x520>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 3231984:	e0bffb17 	ldw	r2,-20(fp)
 3231988:	10800983 	ldbu	r2,38(r2)
 323198c:	10803fcc 	andi	r2,r2,255
 3231990:	1080201c 	xori	r2,r2,128
 3231994:	10bfe004 	addi	r2,r2,-128
 3231998:	10800060 	cmpeqi	r2,r2,1
 323199c:	1000031e 	bne	r2,zero,32319ac <sogetopt+0x498>
      {
         error = EINVAL;
 32319a0:	00800584 	movi	r2,22
 32319a4:	e0bffa15 	stw	r2,-24(fp)
         break;
 32319a8:	00002206 	br	3231a34 <sogetopt+0x520>
      }
      inp = (struct inpcb *)(so->so_pcb);
 32319ac:	e0bffb17 	ldw	r2,-20(fp)
 32319b0:	10800117 	ldw	r2,4(r2)
 32319b4:	e0bff615 	stw	r2,-40(fp)
      tp = intotcpcb(inp);
 32319b8:	e0bff617 	ldw	r2,-40(fp)
 32319bc:	10800917 	ldw	r2,36(r2)
 32319c0:	e0bff515 	stw	r2,-44(fp)
      if (!tp)
 32319c4:	e0bff517 	ldw	r2,-44(fp)
 32319c8:	1004c03a 	cmpne	r2,r2,zero
 32319cc:	1000031e 	bne	r2,zero,32319dc <sogetopt+0x4c8>
      {
         error = ENOTCONN;
 32319d0:	00802004 	movi	r2,128
 32319d4:	e0bffa15 	stw	r2,-24(fp)
         break;
 32319d8:	00001606 	br	3231a34 <sogetopt+0x520>
      }
      /* try to make sure that the argument pointer is valid */
      if (val == NULL)
 32319dc:	e0bffd17 	ldw	r2,-12(fp)
 32319e0:	1004c03a 	cmpne	r2,r2,zero
 32319e4:	1000031e 	bne	r2,zero,32319f4 <sogetopt+0x4e0>
      {
         error = ENP_PARAM;
 32319e8:	00bffd84 	movi	r2,-10
 32319ec:	e0bffa15 	stw	r2,-24(fp)
         break;
 32319f0:	00001006 	br	3231a34 <sogetopt+0x520>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
 32319f4:	e0bff517 	ldw	r2,-44(fp)
 32319f8:	10800b0b 	ldhu	r2,44(r2)
 32319fc:	10bfffcc 	andi	r2,r2,65535
 3231a00:	1080010c 	andi	r2,r2,4
 3231a04:	1005003a 	cmpeq	r2,r2,zero
 3231a08:	1000041e 	bne	r2,zero,3231a1c <sogetopt+0x508>
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
 3231a0c:	e0fffd17 	ldw	r3,-12(fp)
 3231a10:	00800044 	movi	r2,1
 3231a14:	18800015 	stw	r2,0(r3)
 3231a18:	00000606 	br	3231a34 <sogetopt+0x520>
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */
 3231a1c:	e0bffd17 	ldw	r2,-12(fp)
 3231a20:	10000015 	stw	zero,0(r2)

      break;
 3231a24:	00000306 	br	3231a34 <sogetopt+0x520>
   }

   default:
      return ENOPROTOOPT;
 3231a28:	00801b44 	movi	r2,109
 3231a2c:	e0bffe15 	stw	r2,-8(fp)
 3231a30:	00000206 	br	3231a3c <sogetopt+0x528>
   }
   return error;     /* no error */
 3231a34:	e0fffa17 	ldw	r3,-24(fp)
 3231a38:	e0fffe15 	stw	r3,-8(fp)
 3231a3c:	e0bffe17 	ldw	r2,-8(fp)
}
 3231a40:	e037883a 	mov	sp,fp
 3231a44:	dfc00117 	ldw	ra,4(sp)
 3231a48:	df000017 	ldw	fp,0(sp)
 3231a4c:	dec00204 	addi	sp,sp,8
 3231a50:	f800283a 	ret

03231a54 <sohasoutofband>:
 * RETURNS: 
 */

void
sohasoutofband(struct socket * so)
{
 3231a54:	defffd04 	addi	sp,sp,-12
 3231a58:	dfc00215 	stw	ra,8(sp)
 3231a5c:	df000115 	stw	fp,4(sp)
 3231a60:	df000104 	addi	fp,sp,4
 3231a64:	e13fff15 	stw	r4,-4(fp)
   so->so_error = EHAVEOOB;   /* WILL be picked up by the socket */
 3231a68:	e0ffff17 	ldw	r3,-4(fp)
 3231a6c:	00803644 	movi	r2,217
 3231a70:	18800615 	stw	r2,24(r3)
   sorwakeup (so);
 3231a74:	e0bfff17 	ldw	r2,-4(fp)
 3231a78:	11400a04 	addi	r5,r2,40
 3231a7c:	e13fff17 	ldw	r4,-4(fp)
 3231a80:	32322700 	call	3232270 <sbwakeup>
}
 3231a84:	e037883a 	mov	sp,fp
 3231a88:	dfc00117 	ldw	ra,4(sp)
 3231a8c:	df000017 	ldw	fp,0(sp)
 3231a90:	dec00204 	addi	sp,sp,8
 3231a94:	f800283a 	ret

03231a98 <soisconnecting>:
 * RETURNS: 
 */

void
soisconnecting(struct socket * so)
{
 3231a98:	defffd04 	addi	sp,sp,-12
 3231a9c:	dfc00215 	stw	ra,8(sp)
 3231aa0:	df000115 	stw	fp,4(sp)
 3231aa4:	df000104 	addi	fp,sp,4
 3231aa8:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~(SS_ISCONNECTED|SS_ISDISCONNECTING);
 3231aac:	e0bfff17 	ldw	r2,-4(fp)
 3231ab0:	10c0088b 	ldhu	r3,34(r2)
 3231ab4:	00bffd44 	movi	r2,-11
 3231ab8:	1884703a 	and	r2,r3,r2
 3231abc:	1007883a 	mov	r3,r2
 3231ac0:	e0bfff17 	ldw	r2,-4(fp)
 3231ac4:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTING;
 3231ac8:	e0bfff17 	ldw	r2,-4(fp)
 3231acc:	1080088b 	ldhu	r2,34(r2)
 3231ad0:	10800114 	ori	r2,r2,4
 3231ad4:	1007883a 	mov	r3,r2
 3231ad8:	e0bfff17 	ldw	r2,-4(fp)
 3231adc:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 3231ae0:	e0bfff17 	ldw	r2,-4(fp)
 3231ae4:	10800904 	addi	r2,r2,36
 3231ae8:	1009883a 	mov	r4,r2
 3231aec:	3226c640 	call	3226c64 <tcp_wakeup>
}
 3231af0:	e037883a 	mov	sp,fp
 3231af4:	dfc00117 	ldw	ra,4(sp)
 3231af8:	df000017 	ldw	fp,0(sp)
 3231afc:	dec00204 	addi	sp,sp,8
 3231b00:	f800283a 	ret

03231b04 <soisconnected>:
 * RETURNS: 
 */

void
soisconnected(struct socket * so)
{
 3231b04:	defffc04 	addi	sp,sp,-16
 3231b08:	dfc00315 	stw	ra,12(sp)
 3231b0c:	df000215 	stw	fp,8(sp)
 3231b10:	df000204 	addi	fp,sp,8
 3231b14:	e13fff15 	stw	r4,-4(fp)
   struct socket *   head  =  so->so_head;
 3231b18:	e0bfff17 	ldw	r2,-4(fp)
 3231b1c:	10801b17 	ldw	r2,108(r2)
 3231b20:	e0bffe15 	stw	r2,-8(fp)

   if (head) 
 3231b24:	e0bffe17 	ldw	r2,-8(fp)
 3231b28:	1005003a 	cmpeq	r2,r2,zero
 3231b2c:	1000141e 	bne	r2,zero,3231b80 <soisconnected+0x7c>
   {
      if (soqremque(so, 0) == 0)
 3231b30:	e13fff17 	ldw	r4,-4(fp)
 3231b34:	000b883a 	mov	r5,zero
 3231b38:	32320100 	call	3232010 <soqremque>
 3231b3c:	1004c03a 	cmpne	r2,r2,zero
 3231b40:	1000031e 	bne	r2,zero,3231b50 <soisconnected+0x4c>
         panic("soisconnected");
 3231b44:	0100c974 	movhi	r4,805
 3231b48:	213e4504 	addi	r4,r4,-1772
 3231b4c:	32261540 	call	3226154 <panic>
      soqinsque(head, so, 1);
 3231b50:	e13ffe17 	ldw	r4,-8(fp)
 3231b54:	e17fff17 	ldw	r5,-4(fp)
 3231b58:	01800044 	movi	r6,1
 3231b5c:	3231f640 	call	3231f64 <soqinsque>
      sorwakeup(head);
 3231b60:	e0bffe17 	ldw	r2,-8(fp)
 3231b64:	11400a04 	addi	r5,r2,40
 3231b68:	e13ffe17 	ldw	r4,-8(fp)
 3231b6c:	32322700 	call	3232270 <sbwakeup>
      tcp_wakeup ((char *)&head->so_timeo);
 3231b70:	e0bffe17 	ldw	r2,-8(fp)
 3231b74:	10800904 	addi	r2,r2,36
 3231b78:	1009883a 	mov	r4,r2
 3231b7c:	3226c640 	call	3226c64 <tcp_wakeup>
   }

   so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 3231b80:	e0bfff17 	ldw	r2,-4(fp)
 3231b84:	10c0088b 	ldhu	r3,34(r2)
 3231b88:	00bffcc4 	movi	r2,-13
 3231b8c:	1884703a 	and	r2,r3,r2
 3231b90:	1007883a 	mov	r3,r2
 3231b94:	e0bfff17 	ldw	r2,-4(fp)
 3231b98:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTED;
 3231b9c:	e0bfff17 	ldw	r2,-4(fp)
 3231ba0:	1080088b 	ldhu	r2,34(r2)
 3231ba4:	10800094 	ori	r2,r2,2
 3231ba8:	1007883a 	mov	r3,r2
 3231bac:	e0bfff17 	ldw	r2,-4(fp)
 3231bb0:	10c0088d 	sth	r3,34(r2)
   so->so_error = 0;
 3231bb4:	e0bfff17 	ldw	r2,-4(fp)
 3231bb8:	10000615 	stw	zero,24(r2)
   tcp_wakeup  ((char *)&so->so_timeo);
 3231bbc:	e0bfff17 	ldw	r2,-4(fp)
 3231bc0:	10800904 	addi	r2,r2,36
 3231bc4:	1009883a 	mov	r4,r2
 3231bc8:	3226c640 	call	3226c64 <tcp_wakeup>
   sorwakeup (so);
 3231bcc:	e0bfff17 	ldw	r2,-4(fp)
 3231bd0:	11400a04 	addi	r5,r2,40
 3231bd4:	e13fff17 	ldw	r4,-4(fp)
 3231bd8:	32322700 	call	3232270 <sbwakeup>
   sowwakeup (so);
 3231bdc:	e0bfff17 	ldw	r2,-4(fp)
 3231be0:	11401204 	addi	r5,r2,72
 3231be4:	e13fff17 	ldw	r4,-4(fp)
 3231be8:	32322700 	call	3232270 <sbwakeup>
}
 3231bec:	e037883a 	mov	sp,fp
 3231bf0:	dfc00117 	ldw	ra,4(sp)
 3231bf4:	df000017 	ldw	fp,0(sp)
 3231bf8:	dec00204 	addi	sp,sp,8
 3231bfc:	f800283a 	ret

03231c00 <soisdisconnecting>:
 * RETURNS: 
 */

void
soisdisconnecting(struct socket * so)
{
 3231c00:	defffd04 	addi	sp,sp,-12
 3231c04:	dfc00215 	stw	ra,8(sp)
 3231c08:	df000115 	stw	fp,4(sp)
 3231c0c:	df000104 	addi	fp,sp,4
 3231c10:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~SS_ISCONNECTING;
 3231c14:	e0bfff17 	ldw	r2,-4(fp)
 3231c18:	10c0088b 	ldhu	r3,34(r2)
 3231c1c:	00bffec4 	movi	r2,-5
 3231c20:	1884703a 	and	r2,r3,r2
 3231c24:	1007883a 	mov	r3,r2
 3231c28:	e0bfff17 	ldw	r2,-4(fp)
 3231c2c:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_ISDISCONNECTING|SS_CANTRCVMORE|SS_CANTSENDMORE);
 3231c30:	e0bfff17 	ldw	r2,-4(fp)
 3231c34:	1080088b 	ldhu	r2,34(r2)
 3231c38:	10800e14 	ori	r2,r2,56
 3231c3c:	1007883a 	mov	r3,r2
 3231c40:	e0bfff17 	ldw	r2,-4(fp)
 3231c44:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup  ((char *)&so->so_timeo);   
 3231c48:	e0bfff17 	ldw	r2,-4(fp)
 3231c4c:	10800904 	addi	r2,r2,36
 3231c50:	1009883a 	mov	r4,r2
 3231c54:	3226c640 	call	3226c64 <tcp_wakeup>
   sowwakeup (so);
 3231c58:	e0bfff17 	ldw	r2,-4(fp)
 3231c5c:	11401204 	addi	r5,r2,72
 3231c60:	e13fff17 	ldw	r4,-4(fp)
 3231c64:	32322700 	call	3232270 <sbwakeup>
   sorwakeup (so);
 3231c68:	e0bfff17 	ldw	r2,-4(fp)
 3231c6c:	11400a04 	addi	r5,r2,40
 3231c70:	e13fff17 	ldw	r4,-4(fp)
 3231c74:	32322700 	call	3232270 <sbwakeup>
}
 3231c78:	e037883a 	mov	sp,fp
 3231c7c:	dfc00117 	ldw	ra,4(sp)
 3231c80:	df000017 	ldw	fp,0(sp)
 3231c84:	dec00204 	addi	sp,sp,8
 3231c88:	f800283a 	ret

03231c8c <soisdisconnected>:
 * RETURNS: 
 */

void
soisdisconnected(struct socket * so)
{
 3231c8c:	defffd04 	addi	sp,sp,-12
 3231c90:	dfc00215 	stw	ra,8(sp)
 3231c94:	df000115 	stw	fp,4(sp)
 3231c98:	df000104 	addi	fp,sp,4
 3231c9c:	e13fff15 	stw	r4,-4(fp)
   if (so->so_state & SS_ISCONNECTING)
 3231ca0:	e0bfff17 	ldw	r2,-4(fp)
 3231ca4:	1080088b 	ldhu	r2,34(r2)
 3231ca8:	10bfffcc 	andi	r2,r2,65535
 3231cac:	1080010c 	andi	r2,r2,4
 3231cb0:	1005003a 	cmpeq	r2,r2,zero
 3231cb4:	1000061e 	bne	r2,zero,3231cd0 <soisdisconnected+0x44>
      so->so_state |= SS_WASCONNECTING;
 3231cb8:	e0bfff17 	ldw	r2,-4(fp)
 3231cbc:	1080088b 	ldhu	r2,34(r2)
 3231cc0:	10880014 	ori	r2,r2,8192
 3231cc4:	1007883a 	mov	r3,r2
 3231cc8:	e0bfff17 	ldw	r2,-4(fp)
 3231ccc:	10c0088d 	sth	r3,34(r2)
   so->so_state &= ~(SS_ISCONNECTING|SS_ISCONNECTED|SS_ISDISCONNECTING);
 3231cd0:	e0bfff17 	ldw	r2,-4(fp)
 3231cd4:	10c0088b 	ldhu	r3,34(r2)
 3231cd8:	00bffc44 	movi	r2,-15
 3231cdc:	1884703a 	and	r2,r3,r2
 3231ce0:	1007883a 	mov	r3,r2
 3231ce4:	e0bfff17 	ldw	r2,-4(fp)
 3231ce8:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_CANTRCVMORE|SS_CANTSENDMORE);
 3231cec:	e0bfff17 	ldw	r2,-4(fp)
 3231cf0:	1080088b 	ldhu	r2,34(r2)
 3231cf4:	10800c14 	ori	r2,r2,48
 3231cf8:	1007883a 	mov	r3,r2
 3231cfc:	e0bfff17 	ldw	r2,-4(fp)
 3231d00:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 3231d04:	e0bfff17 	ldw	r2,-4(fp)
 3231d08:	10800904 	addi	r2,r2,36
 3231d0c:	1009883a 	mov	r4,r2
 3231d10:	3226c640 	call	3226c64 <tcp_wakeup>
   sowwakeup (so);
 3231d14:	e0bfff17 	ldw	r2,-4(fp)
 3231d18:	11401204 	addi	r5,r2,72
 3231d1c:	e13fff17 	ldw	r4,-4(fp)
 3231d20:	32322700 	call	3232270 <sbwakeup>
   sorwakeup (so);
 3231d24:	e0bfff17 	ldw	r2,-4(fp)
 3231d28:	11400a04 	addi	r5,r2,40
 3231d2c:	e13fff17 	ldw	r4,-4(fp)
 3231d30:	32322700 	call	3232270 <sbwakeup>
}
 3231d34:	e037883a 	mov	sp,fp
 3231d38:	dfc00117 	ldw	ra,4(sp)
 3231d3c:	df000017 	ldw	fp,0(sp)
 3231d40:	dec00204 	addi	sp,sp,8
 3231d44:	f800283a 	ret

03231d48 <sonewconn>:
 * RETURNS: 
 */

struct socket *   
sonewconn(struct socket * head)
{
 3231d48:	defffa04 	addi	sp,sp,-24
 3231d4c:	dfc00515 	stw	ra,20(sp)
 3231d50:	df000415 	stw	fp,16(sp)
 3231d54:	df000404 	addi	fp,sp,16
 3231d58:	e13ffe15 	stw	r4,-8(fp)
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
 3231d5c:	e0bffe17 	ldw	r2,-8(fp)
 3231d60:	10801e43 	ldbu	r2,121(r2)
 3231d64:	10c03fcc 	andi	r3,r2,255
 3231d68:	18c0201c 	xori	r3,r3,128
 3231d6c:	18ffe004 	addi	r3,r3,-128
 3231d70:	e0bffe17 	ldw	r2,-8(fp)
 3231d74:	10801e03 	ldbu	r2,120(r2)
 3231d78:	10803fcc 	andi	r2,r2,255
 3231d7c:	1080201c 	xori	r2,r2,128
 3231d80:	10bfe004 	addi	r2,r2,-128
 3231d84:	1889883a 	add	r4,r3,r2
 3231d88:	e0bffe17 	ldw	r2,-8(fp)
 3231d8c:	10801e83 	ldbu	r2,122(r2)
 3231d90:	10c03fcc 	andi	r3,r2,255
 3231d94:	18c0201c 	xori	r3,r3,128
 3231d98:	18ffe004 	addi	r3,r3,-128
 3231d9c:	1805883a 	mov	r2,r3
 3231da0:	1085883a 	add	r2,r2,r2
 3231da4:	10c7883a 	add	r3,r2,r3
 3231da8:	1804d7fa 	srli	r2,r3,31
 3231dac:	10c5883a 	add	r2,r2,r3
 3231db0:	1005d07a 	srai	r2,r2,1
 3231db4:	11006416 	blt	r2,r4,3231f48 <sonewconn+0x200>
      goto bad;
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 3231db8:	01002104 	movi	r4,132
 3231dbc:	322b9340 	call	322b934 <npalloc>
 3231dc0:	e0bffd15 	stw	r2,-12(fp)
 3231dc4:	e0bffd17 	ldw	r2,-12(fp)
 3231dc8:	1005003a 	cmpeq	r2,r2,zero
 3231dcc:	10005e1e 	bne	r2,zero,3231f48 <sonewconn+0x200>
      goto bad;
   so->next = NULL;
 3231dd0:	e0bffd17 	ldw	r2,-12(fp)
 3231dd4:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);      /* Place newly created socket in a queue */
 3231dd8:	e17ffd17 	ldw	r5,-12(fp)
 3231ddc:	0100c9b4 	movhi	r4,806
 3231de0:	21348204 	addi	r4,r4,-11768
 3231de4:	322a8800 	call	322a880 <putq>
   so->so_type = head->so_type;
 3231de8:	e0bffe17 	ldw	r2,-8(fp)
 3231dec:	10c00983 	ldbu	r3,38(r2)
 3231df0:	e0bffd17 	ldw	r2,-12(fp)
 3231df4:	10c00985 	stb	r3,38(r2)
   so->so_options = head->so_options &~ (unshort)SO_ACCEPTCONN;
 3231df8:	e0bffe17 	ldw	r2,-8(fp)
 3231dfc:	10c00417 	ldw	r3,16(r2)
 3231e00:	00bfff44 	movi	r2,-3
 3231e04:	1886703a 	and	r3,r3,r2
 3231e08:	e0bffd17 	ldw	r2,-12(fp)
 3231e0c:	10c00415 	stw	r3,16(r2)
   so->so_linger = head->so_linger;
 3231e10:	e0bffe17 	ldw	r2,-8(fp)
 3231e14:	10c0080b 	ldhu	r3,32(r2)
 3231e18:	e0bffd17 	ldw	r2,-12(fp)
 3231e1c:	10c0080d 	sth	r3,32(r2)
   so->so_state = head->so_state | (unshort)SS_NOFDREF;
 3231e20:	e0bffe17 	ldw	r2,-8(fp)
 3231e24:	1080088b 	ldhu	r2,34(r2)
 3231e28:	10800054 	ori	r2,r2,1
 3231e2c:	1007883a 	mov	r3,r2
 3231e30:	e0bffd17 	ldw	r2,-12(fp)
 3231e34:	10c0088d 	sth	r3,34(r2)
   so->so_proto = head->so_proto;
 3231e38:	e0bffe17 	ldw	r2,-8(fp)
 3231e3c:	10c00217 	ldw	r3,8(r2)
 3231e40:	e0bffd17 	ldw	r2,-12(fp)
 3231e44:	10c00215 	stw	r3,8(r2)
   so->so_timeo = head->so_timeo;
 3231e48:	e0bffe17 	ldw	r2,-8(fp)
 3231e4c:	10c0090b 	ldhu	r3,36(r2)
 3231e50:	e0bffd17 	ldw	r2,-12(fp)
 3231e54:	10c0090d 	sth	r3,36(r2)
   so->so_rcv.sb_hiwat = (u_int)tcp_recvspace;
 3231e58:	0080c974 	movhi	r2,805
 3231e5c:	108a9f04 	addi	r2,r2,10876
 3231e60:	10c00017 	ldw	r3,0(r2)
 3231e64:	e0bffd17 	ldw	r2,-12(fp)
 3231e68:	10c00b15 	stw	r3,44(r2)
   so->so_snd.sb_hiwat = (u_int)tcp_sendspace;
 3231e6c:	0080c974 	movhi	r2,805
 3231e70:	108a9e04 	addi	r2,r2,10872
 3231e74:	10c00017 	ldw	r3,0(r2)
 3231e78:	e0bffd17 	ldw	r2,-12(fp)
 3231e7c:	10c01315 	stw	r3,76(r2)
   soqinsque (head, so, 0);
 3231e80:	e13ffe17 	ldw	r4,-8(fp)
 3231e84:	e17ffd17 	ldw	r5,-12(fp)
 3231e88:	000d883a 	mov	r6,zero
 3231e8c:	3231f640 	call	3231f64 <soqinsque>
   so->so_req = PRU_ATTACH;
 3231e90:	e0bffd17 	ldw	r2,-12(fp)
 3231e94:	10000715 	stw	zero,28(r2)
   so->so_domain = head->so_domain;
 3231e98:	e0bffe17 	ldw	r2,-8(fp)
 3231e9c:	10c00517 	ldw	r3,20(r2)
 3231ea0:	e0bffd17 	ldw	r2,-12(fp)
 3231ea4:	10c00515 	stw	r3,20(r2)

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
 3231ea8:	e0bffd17 	ldw	r2,-12(fp)
 3231eac:	10800217 	ldw	r2,8(r2)
 3231eb0:	10800317 	ldw	r2,12(r2)
 3231eb4:	e13ffd17 	ldw	r4,-12(fp)
 3231eb8:	000b883a 	mov	r5,zero
 3231ebc:	000d883a 	mov	r6,zero
 3231ec0:	103ee83a 	callr	r2
 3231ec4:	1004c03a 	cmpne	r2,r2,zero
 3231ec8:	1000161e 	bne	r2,zero,3231f24 <sonewconn+0x1dc>
      goto bad2;
   if (so_evtmap)
 3231ecc:	0080c974 	movhi	r2,805
 3231ed0:	10936704 	addi	r2,r2,19868
 3231ed4:	10800003 	ldbu	r2,0(r2)
 3231ed8:	10803fcc 	andi	r2,r2,255
 3231edc:	1005003a 	cmpeq	r2,r2,zero
 3231ee0:	10000d1e 	bne	r2,zero,3231f18 <sonewconn+0x1d0>
   {
      rc = (*so_evtmap_create) (so);                       
 3231ee4:	0080c974 	movhi	r2,805
 3231ee8:	10936504 	addi	r2,r2,19860
 3231eec:	10800017 	ldw	r2,0(r2)
 3231ef0:	e13ffd17 	ldw	r4,-12(fp)
 3231ef4:	103ee83a 	callr	r2
 3231ef8:	e0bffc15 	stw	r2,-16(fp)
      if (rc != 0) goto bad2;
 3231efc:	e0bffc17 	ldw	r2,-16(fp)
 3231f00:	1004c03a 	cmpne	r2,r2,zero
 3231f04:	1000071e 	bne	r2,zero,3231f24 <sonewconn+0x1dc>
      so->owner = head->owner;
 3231f08:	e0bffe17 	ldw	r2,-8(fp)
 3231f0c:	10c02003 	ldbu	r3,128(r2)
 3231f10:	e0bffd17 	ldw	r2,-12(fp)
 3231f14:	10c02005 	stb	r3,128(r2)
   }
   return (so);
 3231f18:	e0bffd17 	ldw	r2,-12(fp)
 3231f1c:	e0bfff15 	stw	r2,-4(fp)
 3231f20:	00000a06 	br	3231f4c <sonewconn+0x204>
   
bad2:
   (void) soqremque (so, 0);
 3231f24:	e13ffd17 	ldw	r4,-12(fp)
 3231f28:	000b883a 	mov	r5,zero
 3231f2c:	32320100 	call	3232010 <soqremque>
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 3231f30:	0100c9b4 	movhi	r4,806
 3231f34:	21348204 	addi	r4,r4,-11768
 3231f38:	e17ffd17 	ldw	r5,-12(fp)
 3231f3c:	322a9300 	call	322a930 <qdel>
   SOC_FREE(so);  /* Free the socket structure */
 3231f40:	e13ffd17 	ldw	r4,-12(fp)
 3231f44:	322ba280 	call	322ba28 <npfree>
bad:
   return ((struct socket *)0);
 3231f48:	e03fff15 	stw	zero,-4(fp)
 3231f4c:	e0bfff17 	ldw	r2,-4(fp)
}
 3231f50:	e037883a 	mov	sp,fp
 3231f54:	dfc00117 	ldw	ra,4(sp)
 3231f58:	df000017 	ldw	fp,0(sp)
 3231f5c:	dec00204 	addi	sp,sp,8
 3231f60:	f800283a 	ret

03231f64 <soqinsque>:

void
soqinsque(struct socket * head, 
   struct socket *   so,
   int   q)
{
 3231f64:	defffc04 	addi	sp,sp,-16
 3231f68:	df000315 	stw	fp,12(sp)
 3231f6c:	df000304 	addi	fp,sp,12
 3231f70:	e13ffd15 	stw	r4,-12(fp)
 3231f74:	e17ffe15 	stw	r5,-8(fp)
 3231f78:	e1bfff15 	stw	r6,-4(fp)
   so->so_head = head;
 3231f7c:	e0fffe17 	ldw	r3,-8(fp)
 3231f80:	e0bffd17 	ldw	r2,-12(fp)
 3231f84:	18801b15 	stw	r2,108(r3)
   if (q == 0) 
 3231f88:	e0bfff17 	ldw	r2,-4(fp)
 3231f8c:	1004c03a 	cmpne	r2,r2,zero
 3231f90:	10000e1e 	bne	r2,zero,3231fcc <soqinsque+0x68>
   {
      head->so_q0len++;
 3231f94:	e0bffd17 	ldw	r2,-12(fp)
 3231f98:	10801e03 	ldbu	r2,120(r2)
 3231f9c:	10800044 	addi	r2,r2,1
 3231fa0:	1007883a 	mov	r3,r2
 3231fa4:	e0bffd17 	ldw	r2,-12(fp)
 3231fa8:	10c01e05 	stb	r3,120(r2)
      so->so_q0 = head->so_q0;
 3231fac:	e0bffd17 	ldw	r2,-12(fp)
 3231fb0:	10c01c17 	ldw	r3,112(r2)
 3231fb4:	e0bffe17 	ldw	r2,-8(fp)
 3231fb8:	10c01c15 	stw	r3,112(r2)
      head->so_q0 = so;
 3231fbc:	e0fffd17 	ldw	r3,-12(fp)
 3231fc0:	e0bffe17 	ldw	r2,-8(fp)
 3231fc4:	18801c15 	stw	r2,112(r3)
 3231fc8:	00000d06 	br	3232000 <soqinsque+0x9c>
   } else 
   {
      head->so_qlen++;
 3231fcc:	e0bffd17 	ldw	r2,-12(fp)
 3231fd0:	10801e43 	ldbu	r2,121(r2)
 3231fd4:	10800044 	addi	r2,r2,1
 3231fd8:	1007883a 	mov	r3,r2
 3231fdc:	e0bffd17 	ldw	r2,-12(fp)
 3231fe0:	10c01e45 	stb	r3,121(r2)
      so->so_q = head->so_q;
 3231fe4:	e0bffd17 	ldw	r2,-12(fp)
 3231fe8:	10c01d17 	ldw	r3,116(r2)
 3231fec:	e0bffe17 	ldw	r2,-8(fp)
 3231ff0:	10c01d15 	stw	r3,116(r2)
      head->so_q = so;
 3231ff4:	e0fffd17 	ldw	r3,-12(fp)
 3231ff8:	e0bffe17 	ldw	r2,-8(fp)
 3231ffc:	18801d15 	stw	r2,116(r3)
   }
}
 3232000:	e037883a 	mov	sp,fp
 3232004:	df000017 	ldw	fp,0(sp)
 3232008:	dec00104 	addi	sp,sp,4
 323200c:	f800283a 	ret

03232010 <soqremque>:
 * RETURNS: 
 */

int
soqremque(struct socket * so, int q)
{
 3232010:	defff804 	addi	sp,sp,-32
 3232014:	df000715 	stw	fp,28(sp)
 3232018:	df000704 	addi	fp,sp,28
 323201c:	e13ffc15 	stw	r4,-16(fp)
 3232020:	e17ffd15 	stw	r5,-12(fp)
   struct socket *   head, *  prev, *  next;

   head = so->so_head;
 3232024:	e0bffc17 	ldw	r2,-16(fp)
 3232028:	10801b17 	ldw	r2,108(r2)
 323202c:	e0bffb15 	stw	r2,-20(fp)
   prev = head;
 3232030:	e0bffb17 	ldw	r2,-20(fp)
 3232034:	e0bffa15 	stw	r2,-24(fp)
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
 3232038:	e0bffd17 	ldw	r2,-12(fp)
 323203c:	1005003a 	cmpeq	r2,r2,zero
 3232040:	1000041e 	bne	r2,zero,3232054 <soqremque+0x44>
 3232044:	e0bffa17 	ldw	r2,-24(fp)
 3232048:	10801d17 	ldw	r2,116(r2)
 323204c:	e0bfff15 	stw	r2,-4(fp)
 3232050:	00000306 	br	3232060 <soqremque+0x50>
 3232054:	e0bffa17 	ldw	r2,-24(fp)
 3232058:	10801c17 	ldw	r2,112(r2)
 323205c:	e0bfff15 	stw	r2,-4(fp)
 3232060:	e0bfff17 	ldw	r2,-4(fp)
 3232064:	e0bff915 	stw	r2,-28(fp)
      if (next == so)
 3232068:	e0fff917 	ldw	r3,-28(fp)
 323206c:	e0bffc17 	ldw	r2,-16(fp)
 3232070:	18800826 	beq	r3,r2,3232094 <soqremque+0x84>
         break;
      if (next == head)
 3232074:	e0fff917 	ldw	r3,-28(fp)
 3232078:	e0bffb17 	ldw	r2,-20(fp)
 323207c:	1880021e 	bne	r3,r2,3232088 <soqremque+0x78>
         return (0);
 3232080:	e03ffe15 	stw	zero,-8(fp)
 3232084:	00002506 	br	323211c <soqremque+0x10c>
      prev = next;
 3232088:	e0bff917 	ldw	r2,-28(fp)
 323208c:	e0bffa15 	stw	r2,-24(fp)
   }
 3232090:	003fe906 	br	3232038 <soqremque+0x28>
   if (q == 0) 
 3232094:	e0bffd17 	ldw	r2,-12(fp)
 3232098:	1004c03a 	cmpne	r2,r2,zero
 323209c:	10000b1e 	bne	r2,zero,32320cc <soqremque+0xbc>
   {
      prev->so_q0 = next->so_q0;
 32320a0:	e0bff917 	ldw	r2,-28(fp)
 32320a4:	10c01c17 	ldw	r3,112(r2)
 32320a8:	e0bffa17 	ldw	r2,-24(fp)
 32320ac:	10c01c15 	stw	r3,112(r2)
      head->so_q0len--;
 32320b0:	e0bffb17 	ldw	r2,-20(fp)
 32320b4:	10801e03 	ldbu	r2,120(r2)
 32320b8:	10bfffc4 	addi	r2,r2,-1
 32320bc:	1007883a 	mov	r3,r2
 32320c0:	e0bffb17 	ldw	r2,-20(fp)
 32320c4:	10c01e05 	stb	r3,120(r2)
 32320c8:	00000a06 	br	32320f4 <soqremque+0xe4>
   } else 
   {
      prev->so_q = next->so_q;
 32320cc:	e0bff917 	ldw	r2,-28(fp)
 32320d0:	10c01d17 	ldw	r3,116(r2)
 32320d4:	e0bffa17 	ldw	r2,-24(fp)
 32320d8:	10c01d15 	stw	r3,116(r2)
      head->so_qlen--;
 32320dc:	e0bffb17 	ldw	r2,-20(fp)
 32320e0:	10801e43 	ldbu	r2,121(r2)
 32320e4:	10bfffc4 	addi	r2,r2,-1
 32320e8:	1007883a 	mov	r3,r2
 32320ec:	e0bffb17 	ldw	r2,-20(fp)
 32320f0:	10c01e45 	stb	r3,121(r2)
   }
   next->so_q0 = next->so_q = 0;
 32320f4:	e0bff917 	ldw	r2,-28(fp)
 32320f8:	10001d15 	stw	zero,116(r2)
 32320fc:	e0bff917 	ldw	r2,-28(fp)
 3232100:	10c01d17 	ldw	r3,116(r2)
 3232104:	e0bff917 	ldw	r2,-28(fp)
 3232108:	10c01c15 	stw	r3,112(r2)
   next->so_head = 0;
 323210c:	e0bff917 	ldw	r2,-28(fp)
 3232110:	10001b15 	stw	zero,108(r2)
   return 1;
 3232114:	00800044 	movi	r2,1
 3232118:	e0bffe15 	stw	r2,-8(fp)
 323211c:	e0bffe17 	ldw	r2,-8(fp)
}
 3232120:	e037883a 	mov	sp,fp
 3232124:	df000017 	ldw	fp,0(sp)
 3232128:	dec00104 	addi	sp,sp,4
 323212c:	f800283a 	ret

03232130 <socantsendmore>:
 * RETURNS: 
 */

void
socantsendmore(struct socket * so)
{
 3232130:	defffd04 	addi	sp,sp,-12
 3232134:	dfc00215 	stw	ra,8(sp)
 3232138:	df000115 	stw	fp,4(sp)
 323213c:	df000104 	addi	fp,sp,4
 3232140:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTSENDMORE;
 3232144:	e0bfff17 	ldw	r2,-4(fp)
 3232148:	1080088b 	ldhu	r2,34(r2)
 323214c:	10800414 	ori	r2,r2,16
 3232150:	1007883a 	mov	r3,r2
 3232154:	e0bfff17 	ldw	r2,-4(fp)
 3232158:	10c0088d 	sth	r3,34(r2)
   sowwakeup(so);
 323215c:	e0bfff17 	ldw	r2,-4(fp)
 3232160:	11401204 	addi	r5,r2,72
 3232164:	e13fff17 	ldw	r4,-4(fp)
 3232168:	32322700 	call	3232270 <sbwakeup>
}
 323216c:	e037883a 	mov	sp,fp
 3232170:	dfc00117 	ldw	ra,4(sp)
 3232174:	df000017 	ldw	fp,0(sp)
 3232178:	dec00204 	addi	sp,sp,8
 323217c:	f800283a 	ret

03232180 <socantrcvmore>:
 * RETURNS: 
 */

void
socantrcvmore(struct socket * so)
{
 3232180:	defffd04 	addi	sp,sp,-12
 3232184:	dfc00215 	stw	ra,8(sp)
 3232188:	df000115 	stw	fp,4(sp)
 323218c:	df000104 	addi	fp,sp,4
 3232190:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTRCVMORE;
 3232194:	e0bfff17 	ldw	r2,-4(fp)
 3232198:	1080088b 	ldhu	r2,34(r2)
 323219c:	10800814 	ori	r2,r2,32
 32321a0:	1007883a 	mov	r3,r2
 32321a4:	e0bfff17 	ldw	r2,-4(fp)
 32321a8:	10c0088d 	sth	r3,34(r2)
   sorwakeup(so);
 32321ac:	e0bfff17 	ldw	r2,-4(fp)
 32321b0:	11400a04 	addi	r5,r2,40
 32321b4:	e13fff17 	ldw	r4,-4(fp)
 32321b8:	32322700 	call	3232270 <sbwakeup>
}
 32321bc:	e037883a 	mov	sp,fp
 32321c0:	dfc00117 	ldw	ra,4(sp)
 32321c4:	df000017 	ldw	fp,0(sp)
 32321c8:	dec00204 	addi	sp,sp,8
 32321cc:	f800283a 	ret

032321d0 <sbselqueue>:
 * RETURNS: 
 */

void
sbselqueue(struct sockbuf * sb)
{
 32321d0:	defffe04 	addi	sp,sp,-8
 32321d4:	df000115 	stw	fp,4(sp)
 32321d8:	df000104 	addi	fp,sp,4
 32321dc:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_SEL;
 32321e0:	e0bfff17 	ldw	r2,-4(fp)
 32321e4:	1080070b 	ldhu	r2,28(r2)
 32321e8:	10800214 	ori	r2,r2,8
 32321ec:	1007883a 	mov	r3,r2
 32321f0:	e0bfff17 	ldw	r2,-4(fp)
 32321f4:	10c0070d 	sth	r3,28(r2)
}
 32321f8:	e037883a 	mov	sp,fp
 32321fc:	df000017 	ldw	fp,0(sp)
 3232200:	dec00104 	addi	sp,sp,4
 3232204:	f800283a 	ret

03232208 <sbwait>:
 * RETURNS: 
 */

void
sbwait(struct sockbuf * sb)
{
 3232208:	defffd04 	addi	sp,sp,-12
 323220c:	dfc00215 	stw	ra,8(sp)
 3232210:	df000115 	stw	fp,4(sp)
 3232214:	df000104 	addi	fp,sp,4
 3232218:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_WAIT;
 323221c:	e0bfff17 	ldw	r2,-4(fp)
 3232220:	1080070b 	ldhu	r2,28(r2)
 3232224:	10800114 	ori	r2,r2,4
 3232228:	1007883a 	mov	r3,r2
 323222c:	e0bfff17 	ldw	r2,-4(fp)
 3232230:	10c0070d 	sth	r3,28(r2)
   tcp_sleep ((char *)&sb->sb_cc);
 3232234:	e0bfff17 	ldw	r2,-4(fp)
 3232238:	1009883a 	mov	r4,r2
 323223c:	3226ac40 	call	3226ac4 <tcp_sleep>
   sb->sb_flags &= ~SB_WAIT;
 3232240:	e0bfff17 	ldw	r2,-4(fp)
 3232244:	10c0070b 	ldhu	r3,28(r2)
 3232248:	00bffec4 	movi	r2,-5
 323224c:	1884703a 	and	r2,r3,r2
 3232250:	1007883a 	mov	r3,r2
 3232254:	e0bfff17 	ldw	r2,-4(fp)
 3232258:	10c0070d 	sth	r3,28(r2)
}
 323225c:	e037883a 	mov	sp,fp
 3232260:	dfc00117 	ldw	ra,4(sp)
 3232264:	df000017 	ldw	fp,0(sp)
 3232268:	dec00204 	addi	sp,sp,8
 323226c:	f800283a 	ret

03232270 <sbwakeup>:
 * RETURNS: 
 */

void
sbwakeup(struct socket * so, struct sockbuf * sb)
{
 3232270:	defffc04 	addi	sp,sp,-16
 3232274:	dfc00315 	stw	ra,12(sp)
 3232278:	df000215 	stw	fp,8(sp)
 323227c:	df000204 	addi	fp,sp,8
 3232280:	e13ffe15 	stw	r4,-8(fp)
 3232284:	e17fff15 	stw	r5,-4(fp)
   if (sb->sb_flags & SB_SEL) 
 3232288:	e0bfff17 	ldw	r2,-4(fp)
 323228c:	1080070b 	ldhu	r2,28(r2)
 3232290:	10bfffcc 	andi	r2,r2,65535
 3232294:	1080020c 	andi	r2,r2,8
 3232298:	1005003a 	cmpeq	r2,r2,zero
 323229c:	10000d1e 	bne	r2,zero,32322d4 <sbwakeup+0x64>
   {
      select_wait = 0;
 32322a0:	0080c974 	movhi	r2,805
 32322a4:	10934904 	addi	r2,r2,19748
 32322a8:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
      tcp_wakeup ((char *)&select_wait);
 32322ac:	0100c974 	movhi	r4,805
 32322b0:	21134904 	addi	r4,r4,19748
 32322b4:	3226c640 	call	3226c64 <tcp_wakeup>
#else
      tcp_wakeup2 (so->owner);
#endif      
      sb->sb_flags &= ~SB_SEL;
 32322b8:	e0bfff17 	ldw	r2,-4(fp)
 32322bc:	10c0070b 	ldhu	r3,28(r2)
 32322c0:	00bffdc4 	movi	r2,-9
 32322c4:	1884703a 	and	r2,r3,r2
 32322c8:	1007883a 	mov	r3,r2
 32322cc:	e0bfff17 	ldw	r2,-4(fp)
 32322d0:	10c0070d 	sth	r3,28(r2)
#ifdef SOCK_WAKEALWAYS  /* Always wake the socket? */
   /* Systems Like Green Hills Integrity RTOS, need to process socket
      input even if looks like no one is blocked on the socket */
   tcp_wakeup ((char *)&sb->sb_cc); /* signal wake on socket */
#else /* older BSD style code - only call tcp_wakeup if blocked */
   if (sb->sb_flags & SB_WAIT)   /* is sockbuf's WAIT flag set? */
 32322d4:	e0bfff17 	ldw	r2,-4(fp)
 32322d8:	1080070b 	ldhu	r2,28(r2)
 32322dc:	10bfffcc 	andi	r2,r2,65535
 32322e0:	1080010c 	andi	r2,r2,4
 32322e4:	1005003a 	cmpeq	r2,r2,zero
 32322e8:	1000031e 	bne	r2,zero,32322f8 <sbwakeup+0x88>
   {
      tcp_wakeup ((char *)&sb->sb_cc);   /* call port wakeup routine */
 32322ec:	e0bfff17 	ldw	r2,-4(fp)
 32322f0:	1009883a 	mov	r4,r2
 32322f4:	3226c640 	call	3226c64 <tcp_wakeup>
   }
#endif   /* SOCK_WAKEALWAYS */
}
 32322f8:	e037883a 	mov	sp,fp
 32322fc:	dfc00117 	ldw	ra,4(sp)
 3232300:	df000017 	ldw	fp,0(sp)
 3232304:	dec00204 	addi	sp,sp,8
 3232308:	f800283a 	ret

0323230c <soreserve>:

int
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
 323230c:	defffa04 	addi	sp,sp,-24
 3232310:	dfc00515 	stw	ra,20(sp)
 3232314:	df000415 	stw	fp,16(sp)
 3232318:	df000404 	addi	fp,sp,16
 323231c:	e13ffc15 	stw	r4,-16(fp)
 3232320:	e17ffd15 	stw	r5,-12(fp)
 3232324:	e1bffe15 	stw	r6,-8(fp)
   if (sbreserve(&so->so_snd, sndcc) == 0)
 3232328:	e0bffc17 	ldw	r2,-16(fp)
 323232c:	11001204 	addi	r4,r2,72
 3232330:	e17ffd17 	ldw	r5,-12(fp)
 3232334:	323238c0 	call	323238c <sbreserve>
 3232338:	1005003a 	cmpeq	r2,r2,zero
 323233c:	10000b1e 	bne	r2,zero,323236c <soreserve+0x60>
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
 3232340:	e0bffc17 	ldw	r2,-16(fp)
 3232344:	11000a04 	addi	r4,r2,40
 3232348:	e17ffe17 	ldw	r5,-8(fp)
 323234c:	323238c0 	call	323238c <sbreserve>
 3232350:	1005003a 	cmpeq	r2,r2,zero
 3232354:	1000021e 	bne	r2,zero,3232360 <soreserve+0x54>
      goto bad2;
   return (0);
 3232358:	e03fff15 	stw	zero,-4(fp)
 323235c:	00000506 	br	3232374 <soreserve+0x68>
bad2:
   sbrelease(&so->so_snd);
 3232360:	e0bffc17 	ldw	r2,-16(fp)
 3232364:	11001204 	addi	r4,r2,72
 3232368:	32323ec0 	call	32323ec <sbrelease>
bad:
   return (ENOBUFS);
 323236c:	00801a44 	movi	r2,105
 3232370:	e0bfff15 	stw	r2,-4(fp)
 3232374:	e0bfff17 	ldw	r2,-4(fp)
}
 3232378:	e037883a 	mov	sp,fp
 323237c:	dfc00117 	ldw	ra,4(sp)
 3232380:	df000017 	ldw	fp,0(sp)
 3232384:	dec00204 	addi	sp,sp,8
 3232388:	f800283a 	ret

0323238c <sbreserve>:
 * RETURNS: 
 */

int
sbreserve(struct sockbuf * sb, u_long cc)
{
 323238c:	defffc04 	addi	sp,sp,-16
 3232390:	df000315 	stw	fp,12(sp)
 3232394:	df000304 	addi	fp,sp,12
 3232398:	e13ffd15 	stw	r4,-12(fp)
 323239c:	e17ffe15 	stw	r5,-8(fp)
#ifdef COMPILER_32BIT
   if (cc > (u_long)SB_MAX * CLBYTES / (2 * MSIZE + CLBYTES))
      return (0);
#endif
   sb->sb_hiwat = cc;
 32323a0:	e0fffd17 	ldw	r3,-12(fp)
 32323a4:	e0bffe17 	ldw	r2,-8(fp)
 32323a8:	18800115 	stw	r2,4(r3)
   sb->sb_mbmax = MIN(cc * 2, SB_MAX);
 32323ac:	e0bffe17 	ldw	r2,-8(fp)
 32323b0:	1085883a 	add	r2,r2,r2
 32323b4:	e0bfff15 	stw	r2,-4(fp)
 32323b8:	e0ffff17 	ldw	r3,-4(fp)
 32323bc:	18900070 	cmpltui	r2,r3,16385
 32323c0:	1000021e 	bne	r2,zero,32323cc <sbreserve+0x40>
 32323c4:	00900004 	movi	r2,16384
 32323c8:	e0bfff15 	stw	r2,-4(fp)
 32323cc:	e0bffd17 	ldw	r2,-12(fp)
 32323d0:	e0ffff17 	ldw	r3,-4(fp)
 32323d4:	10c00315 	stw	r3,12(r2)
   return (1);
 32323d8:	00800044 	movi	r2,1
}
 32323dc:	e037883a 	mov	sp,fp
 32323e0:	df000017 	ldw	fp,0(sp)
 32323e4:	dec00104 	addi	sp,sp,4
 32323e8:	f800283a 	ret

032323ec <sbrelease>:
 * RETURNS: 
 */

void
sbrelease(struct sockbuf * sb)
{
 32323ec:	defffd04 	addi	sp,sp,-12
 32323f0:	dfc00215 	stw	ra,8(sp)
 32323f4:	df000115 	stw	fp,4(sp)
 32323f8:	df000104 	addi	fp,sp,4
 32323fc:	e13fff15 	stw	r4,-4(fp)
   sbflush(sb);
 3232400:	e13fff17 	ldw	r4,-4(fp)
 3232404:	32329ac0 	call	32329ac <sbflush>
   sb->sb_hiwat = sb->sb_mbmax = 0;
 3232408:	e0bfff17 	ldw	r2,-4(fp)
 323240c:	10000315 	stw	zero,12(r2)
 3232410:	e0bfff17 	ldw	r2,-4(fp)
 3232414:	10c00317 	ldw	r3,12(r2)
 3232418:	e0bfff17 	ldw	r2,-4(fp)
 323241c:	10c00115 	stw	r3,4(r2)
}
 3232420:	e037883a 	mov	sp,fp
 3232424:	dfc00117 	ldw	ra,4(sp)
 3232428:	df000017 	ldw	fp,0(sp)
 323242c:	dec00204 	addi	sp,sp,8
 3232430:	f800283a 	ret

03232434 <sbappend>:
 * RETURNS: 
 */

void
sbappend(struct sockbuf * sb, struct mbuf * m)
{
 3232434:	defffb04 	addi	sp,sp,-20
 3232438:	dfc00415 	stw	ra,16(sp)
 323243c:	df000315 	stw	fp,12(sp)
 3232440:	df000304 	addi	fp,sp,12
 3232444:	e13ffe15 	stw	r4,-8(fp)
 3232448:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  n;

   if (m == 0)
 323244c:	e0bfff17 	ldw	r2,-4(fp)
 3232450:	1005003a 	cmpeq	r2,r2,zero
 3232454:	10001c1e 	bne	r2,zero,32324c8 <sbappend+0x94>
      return;
   ENTER_CRIT_SECTION(sb);
 3232458:	322b0f00 	call	322b0f0 <irq_Mask>
   if ((n = sb->sb_mb) != NULL) 
 323245c:	e0bffe17 	ldw	r2,-8(fp)
 3232460:	10800617 	ldw	r2,24(r2)
 3232464:	e0bffd15 	stw	r2,-12(fp)
 3232468:	e0bffd17 	ldw	r2,-12(fp)
 323246c:	1005003a 	cmpeq	r2,r2,zero
 3232470:	1000101e 	bne	r2,zero,32324b4 <sbappend+0x80>
   {
      while (n->m_act)
 3232474:	00000306 	br	3232484 <sbappend+0x50>
         n = n->m_act;
 3232478:	e0bffd17 	ldw	r2,-12(fp)
 323247c:	10800717 	ldw	r2,28(r2)
 3232480:	e0bffd15 	stw	r2,-12(fp)
   if (m == 0)
      return;
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 3232484:	e0bffd17 	ldw	r2,-12(fp)
 3232488:	10800717 	ldw	r2,28(r2)
 323248c:	1004c03a 	cmpne	r2,r2,zero
 3232490:	103ff91e 	bne	r2,zero,3232478 <sbappend+0x44>
         n = n->m_act;
      while (n->m_next)
 3232494:	00000306 	br	32324a4 <sbappend+0x70>
         n = n->m_next;
 3232498:	e0bffd17 	ldw	r2,-12(fp)
 323249c:	10800617 	ldw	r2,24(r2)
 32324a0:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
         n = n->m_act;
      while (n->m_next)
 32324a4:	e0bffd17 	ldw	r2,-12(fp)
 32324a8:	10800617 	ldw	r2,24(r2)
 32324ac:	1004c03a 	cmpne	r2,r2,zero
 32324b0:	103ff91e 	bne	r2,zero,3232498 <sbappend+0x64>
         n = n->m_next;
   }
   sbcompress(sb, m, n);
 32324b4:	e13ffe17 	ldw	r4,-8(fp)
 32324b8:	e17fff17 	ldw	r5,-4(fp)
 32324bc:	e1bffd17 	ldw	r6,-12(fp)
 32324c0:	32327c40 	call	32327c4 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 32324c4:	322b14c0 	call	322b14c <irq_Unmask>
}
 32324c8:	e037883a 	mov	sp,fp
 32324cc:	dfc00117 	ldw	ra,4(sp)
 32324d0:	df000017 	ldw	fp,0(sp)
 32324d4:	dec00204 	addi	sp,sp,8
 32324d8:	f800283a 	ret

032324dc <sbappendrecord>:
 */

void
sbappendrecord(struct sockbuf * sb, 
   struct mbuf *  m0)
{
 32324dc:	defffb04 	addi	sp,sp,-20
 32324e0:	dfc00415 	stw	ra,16(sp)
 32324e4:	df000315 	stw	fp,12(sp)
 32324e8:	df000304 	addi	fp,sp,12
 32324ec:	e13ffe15 	stw	r4,-8(fp)
 32324f0:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;

   if (m0 == 0)
 32324f4:	e0bfff17 	ldw	r2,-4(fp)
 32324f8:	1005003a 	cmpeq	r2,r2,zero
 32324fc:	10002a1e 	bne	r2,zero,32325a8 <sbappendrecord+0xcc>
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
 3232500:	322b0f00 	call	322b0f0 <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 3232504:	e0bffe17 	ldw	r2,-8(fp)
 3232508:	10800617 	ldw	r2,24(r2)
 323250c:	e0bffd15 	stw	r2,-12(fp)
 3232510:	e0bffd17 	ldw	r2,-12(fp)
 3232514:	1005003a 	cmpeq	r2,r2,zero
 3232518:	1000081e 	bne	r2,zero,323253c <sbappendrecord+0x60>
      while (m->m_act)
 323251c:	00000306 	br	323252c <sbappendrecord+0x50>
      m = m->m_act;
 3232520:	e0bffd17 	ldw	r2,-12(fp)
 3232524:	10800717 	ldw	r2,28(r2)
 3232528:	e0bffd15 	stw	r2,-12(fp)

   if (m0 == 0)
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
   if ((m = sb->sb_mb) != NULL)
      while (m->m_act)
 323252c:	e0bffd17 	ldw	r2,-12(fp)
 3232530:	10800717 	ldw	r2,28(r2)
 3232534:	1004c03a 	cmpne	r2,r2,zero
 3232538:	103ff91e 	bne	r2,zero,3232520 <sbappendrecord+0x44>
      m = m->m_act;
   /*
    * Put the first mbuf on the queue.
    * Note this permits zero length records.
    */
   sballoc(sb, m0);
 323253c:	e0bffe17 	ldw	r2,-8(fp)
 3232540:	10c00017 	ldw	r3,0(r2)
 3232544:	e0bfff17 	ldw	r2,-4(fp)
 3232548:	10800217 	ldw	r2,8(r2)
 323254c:	1887883a 	add	r3,r3,r2
 3232550:	e0bffe17 	ldw	r2,-8(fp)
 3232554:	10c00015 	stw	r3,0(r2)
   if (m)
 3232558:	e0bffd17 	ldw	r2,-12(fp)
 323255c:	1005003a 	cmpeq	r2,r2,zero
 3232560:	1000041e 	bne	r2,zero,3232574 <sbappendrecord+0x98>
      m->m_act = m0;
 3232564:	e0fffd17 	ldw	r3,-12(fp)
 3232568:	e0bfff17 	ldw	r2,-4(fp)
 323256c:	18800715 	stw	r2,28(r3)
 3232570:	00000306 	br	3232580 <sbappendrecord+0xa4>
   else
      sb->sb_mb = m0;
 3232574:	e0fffe17 	ldw	r3,-8(fp)
 3232578:	e0bfff17 	ldw	r2,-4(fp)
 323257c:	18800615 	stw	r2,24(r3)
   m = m0->m_next;
 3232580:	e0bfff17 	ldw	r2,-4(fp)
 3232584:	10800617 	ldw	r2,24(r2)
 3232588:	e0bffd15 	stw	r2,-12(fp)
   m0->m_next = 0;
 323258c:	e0bfff17 	ldw	r2,-4(fp)
 3232590:	10000615 	stw	zero,24(r2)
   sbcompress(sb, m, m0);
 3232594:	e13ffe17 	ldw	r4,-8(fp)
 3232598:	e17ffd17 	ldw	r5,-12(fp)
 323259c:	e1bfff17 	ldw	r6,-4(fp)
 32325a0:	32327c40 	call	32327c4 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 32325a4:	322b14c0 	call	322b14c <irq_Unmask>
}
 32325a8:	e037883a 	mov	sp,fp
 32325ac:	dfc00117 	ldw	ra,4(sp)
 32325b0:	df000017 	ldw	fp,0(sp)
 32325b4:	dec00204 	addi	sp,sp,8
 32325b8:	f800283a 	ret

032325bc <sbappendaddr>:

int
sbappendaddr(struct sockbuf * sb, 
   struct sockaddr * asa,
   struct mbuf *  m0)
{
 32325bc:	defff604 	addi	sp,sp,-40
 32325c0:	dfc00915 	stw	ra,36(sp)
 32325c4:	df000815 	stw	fp,32(sp)
 32325c8:	df000804 	addi	fp,sp,32
 32325cc:	e13ffb15 	stw	r4,-20(fp)
 32325d0:	e17ffc15 	stw	r5,-16(fp)
 32325d4:	e1bffd15 	stw	r6,-12(fp)
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);
 32325d8:	00800404 	movi	r2,16
 32325dc:	e0bff815 	stw	r2,-32(fp)

   ENTER_CRIT_SECTION(sb);
 32325e0:	322b0f00 	call	322b0f0 <irq_Mask>
   for (m = m0; m; m = m->m_next)
 32325e4:	e0bffd17 	ldw	r2,-12(fp)
 32325e8:	e0bffa15 	stw	r2,-24(fp)
 32325ec:	00000806 	br	3232610 <sbappendaddr+0x54>
      space += m->m_len;
 32325f0:	e0bffa17 	ldw	r2,-24(fp)
 32325f4:	10c00217 	ldw	r3,8(r2)
 32325f8:	e0bff817 	ldw	r2,-32(fp)
 32325fc:	1885883a 	add	r2,r3,r2
 3232600:	e0bff815 	stw	r2,-32(fp)
{
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);

   ENTER_CRIT_SECTION(sb);
   for (m = m0; m; m = m->m_next)
 3232604:	e0bffa17 	ldw	r2,-24(fp)
 3232608:	10800617 	ldw	r2,24(r2)
 323260c:	e0bffa15 	stw	r2,-24(fp)
 3232610:	e0bffa17 	ldw	r2,-24(fp)
 3232614:	1004c03a 	cmpne	r2,r2,zero
 3232618:	103ff51e 	bne	r2,zero,32325f0 <sbappendaddr+0x34>
      space += m->m_len;
   if (space > (int)sbspace(sb))
 323261c:	e0bffb17 	ldw	r2,-20(fp)
 3232620:	10800117 	ldw	r2,4(r2)
 3232624:	1007883a 	mov	r3,r2
 3232628:	e0bffb17 	ldw	r2,-20(fp)
 323262c:	10800017 	ldw	r2,0(r2)
 3232630:	1885c83a 	sub	r2,r3,r2
 3232634:	1004803a 	cmplt	r2,r2,zero
 3232638:	1000071e 	bne	r2,zero,3232658 <sbappendaddr+0x9c>
 323263c:	e0bffb17 	ldw	r2,-20(fp)
 3232640:	10c00117 	ldw	r3,4(r2)
 3232644:	e0bffb17 	ldw	r2,-20(fp)
 3232648:	10800017 	ldw	r2,0(r2)
 323264c:	1885c83a 	sub	r2,r3,r2
 3232650:	e0bfff15 	stw	r2,-4(fp)
 3232654:	00000106 	br	323265c <sbappendaddr+0xa0>
 3232658:	e03fff15 	stw	zero,-4(fp)
 323265c:	e0bff817 	ldw	r2,-32(fp)
 3232660:	e0ffff17 	ldw	r3,-4(fp)
 3232664:	1880030e 	bge	r3,r2,3232674 <sbappendaddr+0xb8>
   {
      EXIT_CRIT_SECTION(sb);
 3232668:	322b14c0 	call	322b14c <irq_Unmask>
      return (0);
 323266c:	e03ffe15 	stw	zero,-8(fp)
 3232670:	00004e06 	br	32327ac <sbappendaddr+0x1f0>
   }
   if ((m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr))) == NULL)
 3232674:	01000244 	movi	r4,9
 3232678:	01400404 	movi	r5,16
 323267c:	322bcf00 	call	322bcf0 <m_getnbuf>
 3232680:	e0bffa15 	stw	r2,-24(fp)
 3232684:	e0bffa17 	ldw	r2,-24(fp)
 3232688:	1004c03a 	cmpne	r2,r2,zero
 323268c:	1000031e 	bne	r2,zero,323269c <sbappendaddr+0xe0>
   {
      EXIT_CRIT_SECTION(sb);
 3232690:	322b14c0 	call	322b14c <irq_Unmask>
      return 0;
 3232694:	e03ffe15 	stw	zero,-8(fp)
 3232698:	00004406 	br	32327ac <sbappendaddr+0x1f0>
   }
   *mtod(m, struct sockaddr *) = *asa;
 323269c:	e0bffa17 	ldw	r2,-24(fp)
 32326a0:	10800317 	ldw	r2,12(r2)
 32326a4:	1009883a 	mov	r4,r2
 32326a8:	e0fffc17 	ldw	r3,-16(fp)
 32326ac:	1880000b 	ldhu	r2,0(r3)
 32326b0:	2080000d 	sth	r2,0(r4)
 32326b4:	1880008b 	ldhu	r2,2(r3)
 32326b8:	2080008d 	sth	r2,2(r4)
 32326bc:	1880010b 	ldhu	r2,4(r3)
 32326c0:	2080010d 	sth	r2,4(r4)
 32326c4:	1880018b 	ldhu	r2,6(r3)
 32326c8:	2080018d 	sth	r2,6(r4)
 32326cc:	1880020b 	ldhu	r2,8(r3)
 32326d0:	2080020d 	sth	r2,8(r4)
 32326d4:	1880028b 	ldhu	r2,10(r3)
 32326d8:	2080028d 	sth	r2,10(r4)
 32326dc:	1880030b 	ldhu	r2,12(r3)
 32326e0:	2080030d 	sth	r2,12(r4)
 32326e4:	1880038b 	ldhu	r2,14(r3)
 32326e8:	2080038d 	sth	r2,14(r4)
   m->m_len = sizeof (*asa);
 32326ec:	e0fffa17 	ldw	r3,-24(fp)
 32326f0:	00800404 	movi	r2,16
 32326f4:	18800215 	stw	r2,8(r3)
   sballoc (sb, m);
 32326f8:	e0bffb17 	ldw	r2,-20(fp)
 32326fc:	10c00017 	ldw	r3,0(r2)
 3232700:	e0bffa17 	ldw	r2,-24(fp)
 3232704:	10800217 	ldw	r2,8(r2)
 3232708:	1887883a 	add	r3,r3,r2
 323270c:	e0bffb17 	ldw	r2,-20(fp)
 3232710:	10c00015 	stw	r3,0(r2)
   if ((n = sb->sb_mb) != NULL) 
 3232714:	e0bffb17 	ldw	r2,-20(fp)
 3232718:	10800617 	ldw	r2,24(r2)
 323271c:	e0bff915 	stw	r2,-28(fp)
 3232720:	e0bff917 	ldw	r2,-28(fp)
 3232724:	1005003a 	cmpeq	r2,r2,zero
 3232728:	10000c1e 	bne	r2,zero,323275c <sbappendaddr+0x1a0>
   {
      while (n->m_act)
 323272c:	00000306 	br	323273c <sbappendaddr+0x180>
         n = n->m_act;
 3232730:	e0bff917 	ldw	r2,-28(fp)
 3232734:	10800717 	ldw	r2,28(r2)
 3232738:	e0bff915 	stw	r2,-28(fp)
   *mtod(m, struct sockaddr *) = *asa;
   m->m_len = sizeof (*asa);
   sballoc (sb, m);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 323273c:	e0bff917 	ldw	r2,-28(fp)
 3232740:	10800717 	ldw	r2,28(r2)
 3232744:	1004c03a 	cmpne	r2,r2,zero
 3232748:	103ff91e 	bne	r2,zero,3232730 <sbappendaddr+0x174>
         n = n->m_act;
      n->m_act = m;
 323274c:	e0fff917 	ldw	r3,-28(fp)
 3232750:	e0bffa17 	ldw	r2,-24(fp)
 3232754:	18800715 	stw	r2,28(r3)
 3232758:	00000306 	br	3232768 <sbappendaddr+0x1ac>
   } else
      sb->sb_mb = m;
 323275c:	e0fffb17 	ldw	r3,-20(fp)
 3232760:	e0bffa17 	ldw	r2,-24(fp)
 3232764:	18800615 	stw	r2,24(r3)
   if (m->m_next)
 3232768:	e0bffa17 	ldw	r2,-24(fp)
 323276c:	10800617 	ldw	r2,24(r2)
 3232770:	1005003a 	cmpeq	r2,r2,zero
 3232774:	1000031e 	bne	r2,zero,3232784 <sbappendaddr+0x1c8>
      m = m->m_next;
 3232778:	e0bffa17 	ldw	r2,-24(fp)
 323277c:	10800617 	ldw	r2,24(r2)
 3232780:	e0bffa15 	stw	r2,-24(fp)
   if (m0)
 3232784:	e0bffd17 	ldw	r2,-12(fp)
 3232788:	1005003a 	cmpeq	r2,r2,zero
 323278c:	1000041e 	bne	r2,zero,32327a0 <sbappendaddr+0x1e4>
      sbcompress(sb, m0, m);
 3232790:	e13ffb17 	ldw	r4,-20(fp)
 3232794:	e17ffd17 	ldw	r5,-12(fp)
 3232798:	e1bffa17 	ldw	r6,-24(fp)
 323279c:	32327c40 	call	32327c4 <sbcompress>

   EXIT_CRIT_SECTION(sb);
 32327a0:	322b14c0 	call	322b14c <irq_Unmask>
   return (1);
 32327a4:	00800044 	movi	r2,1
 32327a8:	e0bffe15 	stw	r2,-8(fp)
 32327ac:	e0bffe17 	ldw	r2,-8(fp)
}
 32327b0:	e037883a 	mov	sp,fp
 32327b4:	dfc00117 	ldw	ra,4(sp)
 32327b8:	df000017 	ldw	fp,0(sp)
 32327bc:	dec00204 	addi	sp,sp,8
 32327c0:	f800283a 	ret

032327c4 <sbcompress>:

void
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{
 32327c4:	defffb04 	addi	sp,sp,-20
 32327c8:	dfc00415 	stw	ra,16(sp)
 32327cc:	df000315 	stw	fp,12(sp)
 32327d0:	df000304 	addi	fp,sp,12
 32327d4:	e13ffd15 	stw	r4,-12(fp)
 32327d8:	e17ffe15 	stw	r5,-8(fp)
 32327dc:	e1bfff15 	stw	r6,-4(fp)

   while (m) 
 32327e0:	00006a06 	br	323298c <sbcompress+0x1c8>
   {
      if (m->m_len == 0) 
 32327e4:	e0bffe17 	ldw	r2,-8(fp)
 32327e8:	10800217 	ldw	r2,8(r2)
 32327ec:	1004c03a 	cmpne	r2,r2,zero
 32327f0:	1000041e 	bne	r2,zero,3232804 <sbcompress+0x40>
      {
         m = m_free(m);
 32327f4:	e13ffe17 	ldw	r4,-8(fp)
 32327f8:	322be980 	call	322be98 <m_free>
 32327fc:	e0bffe15 	stw	r2,-8(fp)
         continue;
 3232800:	00006206 	br	323298c <sbcompress+0x1c8>
      }
      if (m->m_type != MT_RXDATA && 
 3232804:	e0bffe17 	ldw	r2,-8(fp)
 3232808:	10800817 	ldw	r2,32(r2)
 323280c:	10800060 	cmpeqi	r2,r2,1
 3232810:	1000101e 	bne	r2,zero,3232854 <sbcompress+0x90>
 3232814:	e0bffe17 	ldw	r2,-8(fp)
 3232818:	10800817 	ldw	r2,32(r2)
 323281c:	108000a0 	cmpeqi	r2,r2,2
 3232820:	10000c1e 	bne	r2,zero,3232854 <sbcompress+0x90>
 3232824:	e0bffe17 	ldw	r2,-8(fp)
 3232828:	10800817 	ldw	r2,32(r2)
 323282c:	10800260 	cmpeqi	r2,r2,9
 3232830:	1000081e 	bne	r2,zero,3232854 <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
          m->m_type != MT_SONAME) 
      {
         dprintf ("sbcomp:bad type %d\n", m->m_type);
 3232834:	e0bffe17 	ldw	r2,-8(fp)
 3232838:	11400817 	ldw	r5,32(r2)
 323283c:	0100c974 	movhi	r4,805
 3232840:	213e4904 	addi	r4,r4,-1756
 3232844:	3206de00 	call	3206de0 <printf>
         panic ("sbcomp:bad");
 3232848:	0100c974 	movhi	r4,805
 323284c:	213e4e04 	addi	r4,r4,-1736
 3232850:	32261540 	call	3226154 <panic>
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 3232854:	e0bfff17 	ldw	r2,-4(fp)
 3232858:	1005003a 	cmpeq	r2,r2,zero
 323285c:	1000331e 	bne	r2,zero,323292c <sbcompress+0x168>
 3232860:	e0bffd17 	ldw	r2,-12(fp)
 3232864:	1080070b 	ldhu	r2,28(r2)
 3232868:	10bfffcc 	andi	r2,r2,65535
 323286c:	1080200c 	andi	r2,r2,128
 3232870:	1005003a 	cmpeq	r2,r2,zero
 3232874:	10002d1e 	bne	r2,zero,323292c <sbcompress+0x168>
 3232878:	e0bfff17 	ldw	r2,-4(fp)
 323287c:	10c00217 	ldw	r3,8(r2)
 3232880:	e0bffe17 	ldw	r2,-8(fp)
 3232884:	10800217 	ldw	r2,8(r2)
 3232888:	188b883a 	add	r5,r3,r2
 323288c:	e0bfff17 	ldw	r2,-4(fp)
 3232890:	11000517 	ldw	r4,20(r2)
 3232894:	e0bfff17 	ldw	r2,-4(fp)
 3232898:	10800317 	ldw	r2,12(r2)
 323289c:	1007883a 	mov	r3,r2
 32328a0:	e0bfff17 	ldw	r2,-4(fp)
 32328a4:	10800417 	ldw	r2,16(r2)
 32328a8:	1885c83a 	sub	r2,r3,r2
 32328ac:	2085c83a 	sub	r2,r4,r2
 32328b0:	28801e2e 	bgeu	r5,r2,323292c <sbcompress+0x168>
          ((n->m_len + m->m_len) <
          n->m_memsz - (n->m_data - n->m_base) ) ) 
      {
         MEMCPY(n->m_data+n->m_len, m->m_data, m->m_len);
 32328b4:	e0bfff17 	ldw	r2,-4(fp)
 32328b8:	10c00317 	ldw	r3,12(r2)
 32328bc:	e0bfff17 	ldw	r2,-4(fp)
 32328c0:	10800217 	ldw	r2,8(r2)
 32328c4:	1887883a 	add	r3,r3,r2
 32328c8:	e0bffe17 	ldw	r2,-8(fp)
 32328cc:	11400317 	ldw	r5,12(r2)
 32328d0:	e0bffe17 	ldw	r2,-8(fp)
 32328d4:	10800217 	ldw	r2,8(r2)
 32328d8:	1809883a 	mov	r4,r3
 32328dc:	100d883a 	mov	r6,r2
 32328e0:	3206ad00 	call	3206ad0 <memcpy>
         sballoc(sb, m);
 32328e4:	e0bffd17 	ldw	r2,-12(fp)
 32328e8:	10c00017 	ldw	r3,0(r2)
 32328ec:	e0bffe17 	ldw	r2,-8(fp)
 32328f0:	10800217 	ldw	r2,8(r2)
 32328f4:	1887883a 	add	r3,r3,r2
 32328f8:	e0bffd17 	ldw	r2,-12(fp)
 32328fc:	10c00015 	stw	r3,0(r2)
         n->m_len += m->m_len;
 3232900:	e0bfff17 	ldw	r2,-4(fp)
 3232904:	10c00217 	ldw	r3,8(r2)
 3232908:	e0bffe17 	ldw	r2,-8(fp)
 323290c:	10800217 	ldw	r2,8(r2)
 3232910:	1887883a 	add	r3,r3,r2
 3232914:	e0bfff17 	ldw	r2,-4(fp)
 3232918:	10c00215 	stw	r3,8(r2)
         m = m_free(m);
 323291c:	e13ffe17 	ldw	r4,-8(fp)
 3232920:	322be980 	call	322be98 <m_free>
 3232924:	e0bffe15 	stw	r2,-8(fp)
         continue;
 3232928:	00001806 	br	323298c <sbcompress+0x1c8>
      }
      sballoc(sb, m);
 323292c:	e0bffd17 	ldw	r2,-12(fp)
 3232930:	10c00017 	ldw	r3,0(r2)
 3232934:	e0bffe17 	ldw	r2,-8(fp)
 3232938:	10800217 	ldw	r2,8(r2)
 323293c:	1887883a 	add	r3,r3,r2
 3232940:	e0bffd17 	ldw	r2,-12(fp)
 3232944:	10c00015 	stw	r3,0(r2)
      if (n)
 3232948:	e0bfff17 	ldw	r2,-4(fp)
 323294c:	1005003a 	cmpeq	r2,r2,zero
 3232950:	1000041e 	bne	r2,zero,3232964 <sbcompress+0x1a0>
         n->m_next = m;
 3232954:	e0ffff17 	ldw	r3,-4(fp)
 3232958:	e0bffe17 	ldw	r2,-8(fp)
 323295c:	18800615 	stw	r2,24(r3)
 3232960:	00000306 	br	3232970 <sbcompress+0x1ac>
      else
         sb->sb_mb = m;
 3232964:	e0fffd17 	ldw	r3,-12(fp)
 3232968:	e0bffe17 	ldw	r2,-8(fp)
 323296c:	18800615 	stw	r2,24(r3)
      n = m;
 3232970:	e0bffe17 	ldw	r2,-8(fp)
 3232974:	e0bfff15 	stw	r2,-4(fp)
      m = m->m_next;
 3232978:	e0bffe17 	ldw	r2,-8(fp)
 323297c:	10800617 	ldw	r2,24(r2)
 3232980:	e0bffe15 	stw	r2,-8(fp)
      n->m_next = 0;
 3232984:	e0bfff17 	ldw	r2,-4(fp)
 3232988:	10000615 	stw	zero,24(r2)
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{

   while (m) 
 323298c:	e0bffe17 	ldw	r2,-8(fp)
 3232990:	1004c03a 	cmpne	r2,r2,zero
 3232994:	103f931e 	bne	r2,zero,32327e4 <sbcompress+0x20>
         sb->sb_mb = m;
      n = m;
      m = m->m_next;
      n->m_next = 0;
   }
}
 3232998:	e037883a 	mov	sp,fp
 323299c:	dfc00117 	ldw	ra,4(sp)
 32329a0:	df000017 	ldw	fp,0(sp)
 32329a4:	dec00204 	addi	sp,sp,8
 32329a8:	f800283a 	ret

032329ac <sbflush>:
 * RETURNS: 
 */

void
sbflush(struct sockbuf * sb)
{
 32329ac:	defffd04 	addi	sp,sp,-12
 32329b0:	dfc00215 	stw	ra,8(sp)
 32329b4:	df000115 	stw	fp,4(sp)
 32329b8:	df000104 	addi	fp,sp,4
 32329bc:	e13fff15 	stw	r4,-4(fp)
   ENTER_CRIT_SECTION(sb);
 32329c0:	322b0f00 	call	322b0f0 <irq_Mask>
   if (sb->sb_flags & SB_LOCK)
 32329c4:	e0bfff17 	ldw	r2,-4(fp)
 32329c8:	1080070b 	ldhu	r2,28(r2)
 32329cc:	10bfffcc 	andi	r2,r2,65535
 32329d0:	1080004c 	andi	r2,r2,1
 32329d4:	10803fcc 	andi	r2,r2,255
 32329d8:	1005003a 	cmpeq	r2,r2,zero
 32329dc:	1000091e 	bne	r2,zero,3232a04 <sbflush+0x58>
      panic("sbflush");
 32329e0:	0100c974 	movhi	r4,805
 32329e4:	213e5104 	addi	r4,r4,-1724
 32329e8:	32261540 	call	3226154 <panic>
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 32329ec:	00000506 	br	3232a04 <sbflush+0x58>
      sbdrop (sb, (int)sb->sb_cc);
 32329f0:	e0bfff17 	ldw	r2,-4(fp)
 32329f4:	10800017 	ldw	r2,0(r2)
 32329f8:	100b883a 	mov	r5,r2
 32329fc:	e13fff17 	ldw	r4,-4(fp)
 3232a00:	3232a3c0 	call	3232a3c <sbdrop>
sbflush(struct sockbuf * sb)
{
   ENTER_CRIT_SECTION(sb);
   if (sb->sb_flags & SB_LOCK)
      panic("sbflush");
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 3232a04:	e0bfff17 	ldw	r2,-4(fp)
 3232a08:	10800217 	ldw	r2,8(r2)
 3232a0c:	1004c03a 	cmpne	r2,r2,zero
 3232a10:	103ff71e 	bne	r2,zero,32329f0 <sbflush+0x44>
 3232a14:	e0bfff17 	ldw	r2,-4(fp)
 3232a18:	10800017 	ldw	r2,0(r2)
 3232a1c:	1004c03a 	cmpne	r2,r2,zero
 3232a20:	103ff31e 	bne	r2,zero,32329f0 <sbflush+0x44>
      sbdrop (sb, (int)sb->sb_cc);
   EXIT_CRIT_SECTION(sb);
 3232a24:	322b14c0 	call	322b14c <irq_Unmask>
}
 3232a28:	e037883a 	mov	sp,fp
 3232a2c:	dfc00117 	ldw	ra,4(sp)
 3232a30:	df000017 	ldw	fp,0(sp)
 3232a34:	dec00204 	addi	sp,sp,8
 3232a38:	f800283a 	ret

03232a3c <sbdrop>:
 * RETURNS: 
 */

void
sbdrop(struct sockbuf * sb, int len)
{
 3232a3c:	defff904 	addi	sp,sp,-28
 3232a40:	dfc00615 	stw	ra,24(sp)
 3232a44:	df000515 	stw	fp,20(sp)
 3232a48:	df000504 	addi	fp,sp,20
 3232a4c:	e13ffe15 	stw	r4,-8(fp)
 3232a50:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m, *  mn;
   struct mbuf *  next;

   ENTER_CRIT_SECTION(sb);
 3232a54:	322b0f00 	call	322b0f0 <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 3232a58:	e0bffe17 	ldw	r2,-8(fp)
 3232a5c:	10800617 	ldw	r2,24(r2)
 3232a60:	e0bffd15 	stw	r2,-12(fp)
 3232a64:	e0bffd17 	ldw	r2,-12(fp)
 3232a68:	1005003a 	cmpeq	r2,r2,zero
 3232a6c:	1000041e 	bne	r2,zero,3232a80 <sbdrop+0x44>
      next = m->m_act;
 3232a70:	e0bffd17 	ldw	r2,-12(fp)
 3232a74:	10800717 	ldw	r2,28(r2)
 3232a78:	e0bffb15 	stw	r2,-20(fp)
 3232a7c:	00003906 	br	3232b64 <sbdrop+0x128>
   else
      next = NULL;
 3232a80:	e03ffb15 	stw	zero,-20(fp)
   while (len > 0) 
 3232a84:	00003706 	br	3232b64 <sbdrop+0x128>
   {
      if (m == 0) 
 3232a88:	e0bffd17 	ldw	r2,-12(fp)
 3232a8c:	1004c03a 	cmpne	r2,r2,zero
 3232a90:	10000c1e 	bne	r2,zero,3232ac4 <sbdrop+0x88>
      {
         if (next == 0)
 3232a94:	e0bffb17 	ldw	r2,-20(fp)
 3232a98:	1004c03a 	cmpne	r2,r2,zero
 3232a9c:	1000031e 	bne	r2,zero,3232aac <sbdrop+0x70>
            panic("sbdrop");
 3232aa0:	0100c974 	movhi	r4,805
 3232aa4:	213e5304 	addi	r4,r4,-1716
 3232aa8:	32261540 	call	3226154 <panic>
         m = next;
 3232aac:	e0bffb17 	ldw	r2,-20(fp)
 3232ab0:	e0bffd15 	stw	r2,-12(fp)
         next = m->m_act;
 3232ab4:	e0bffd17 	ldw	r2,-12(fp)
 3232ab8:	10800717 	ldw	r2,28(r2)
 3232abc:	e0bffb15 	stw	r2,-20(fp)
         continue;
 3232ac0:	00002806 	br	3232b64 <sbdrop+0x128>
      }
      if (m->m_len > (unsigned)len) 
 3232ac4:	e0bffd17 	ldw	r2,-12(fp)
 3232ac8:	10c00217 	ldw	r3,8(r2)
 3232acc:	e0bfff17 	ldw	r2,-4(fp)
 3232ad0:	10c0132e 	bgeu	r2,r3,3232b20 <sbdrop+0xe4>
      {
         m->m_len -= len;
 3232ad4:	e0bffd17 	ldw	r2,-12(fp)
 3232ad8:	10c00217 	ldw	r3,8(r2)
 3232adc:	e0bfff17 	ldw	r2,-4(fp)
 3232ae0:	1887c83a 	sub	r3,r3,r2
 3232ae4:	e0bffd17 	ldw	r2,-12(fp)
 3232ae8:	10c00215 	stw	r3,8(r2)
         m->m_data += len;
 3232aec:	e0bffd17 	ldw	r2,-12(fp)
 3232af0:	10c00317 	ldw	r3,12(r2)
 3232af4:	e0bfff17 	ldw	r2,-4(fp)
 3232af8:	1887883a 	add	r3,r3,r2
 3232afc:	e0bffd17 	ldw	r2,-12(fp)
 3232b00:	10c00315 	stw	r3,12(r2)
         sb->sb_cc -= len;
 3232b04:	e0bffe17 	ldw	r2,-8(fp)
 3232b08:	10c00017 	ldw	r3,0(r2)
 3232b0c:	e0bfff17 	ldw	r2,-4(fp)
 3232b10:	1887c83a 	sub	r3,r3,r2
 3232b14:	e0bffe17 	ldw	r2,-8(fp)
 3232b18:	10c00015 	stw	r3,0(r2)
         break;
 3232b1c:	00002106 	br	3232ba4 <sbdrop+0x168>
      }
      len -= m->m_len;
 3232b20:	e0ffff17 	ldw	r3,-4(fp)
 3232b24:	e0bffd17 	ldw	r2,-12(fp)
 3232b28:	10800217 	ldw	r2,8(r2)
 3232b2c:	1885c83a 	sub	r2,r3,r2
 3232b30:	e0bfff15 	stw	r2,-4(fp)
      sbfree (sb, m);
 3232b34:	e0bffe17 	ldw	r2,-8(fp)
 3232b38:	10c00017 	ldw	r3,0(r2)
 3232b3c:	e0bffd17 	ldw	r2,-12(fp)
 3232b40:	10800217 	ldw	r2,8(r2)
 3232b44:	1887c83a 	sub	r3,r3,r2
 3232b48:	e0bffe17 	ldw	r2,-8(fp)
 3232b4c:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 3232b50:	e13ffd17 	ldw	r4,-12(fp)
 3232b54:	322be980 	call	322be98 <m_free>
 3232b58:	e0bffc15 	stw	r2,-16(fp)
      m = mn;
 3232b5c:	e0bffc17 	ldw	r2,-16(fp)
 3232b60:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((m = sb->sb_mb) != NULL)
      next = m->m_act;
   else
      next = NULL;
   while (len > 0) 
 3232b64:	e0bfff17 	ldw	r2,-4(fp)
 3232b68:	10800048 	cmpgei	r2,r2,1
 3232b6c:	103fc61e 	bne	r2,zero,3232a88 <sbdrop+0x4c>
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 3232b70:	00000c06 	br	3232ba4 <sbdrop+0x168>
   {
      sbfree(sb, m);
 3232b74:	e0bffe17 	ldw	r2,-8(fp)
 3232b78:	10c00017 	ldw	r3,0(r2)
 3232b7c:	e0bffd17 	ldw	r2,-12(fp)
 3232b80:	10800217 	ldw	r2,8(r2)
 3232b84:	1887c83a 	sub	r3,r3,r2
 3232b88:	e0bffe17 	ldw	r2,-8(fp)
 3232b8c:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 3232b90:	e13ffd17 	ldw	r4,-12(fp)
 3232b94:	322be980 	call	322be98 <m_free>
 3232b98:	e0bffc15 	stw	r2,-16(fp)
      m = mn;
 3232b9c:	e0bffc17 	ldw	r2,-16(fp)
 3232ba0:	e0bffd15 	stw	r2,-12(fp)
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 3232ba4:	e0bffd17 	ldw	r2,-12(fp)
 3232ba8:	1005003a 	cmpeq	r2,r2,zero
 3232bac:	1000041e 	bne	r2,zero,3232bc0 <sbdrop+0x184>
 3232bb0:	e0bffd17 	ldw	r2,-12(fp)
 3232bb4:	10800217 	ldw	r2,8(r2)
 3232bb8:	1005003a 	cmpeq	r2,r2,zero
 3232bbc:	103fed1e 	bne	r2,zero,3232b74 <sbdrop+0x138>
   {
      sbfree(sb, m);
      MFREE(m, mn);
      m = mn;
   }
   if (m) 
 3232bc0:	e0bffd17 	ldw	r2,-12(fp)
 3232bc4:	1005003a 	cmpeq	r2,r2,zero
 3232bc8:	1000071e 	bne	r2,zero,3232be8 <sbdrop+0x1ac>
   {
      sb->sb_mb = m;
 3232bcc:	e0fffe17 	ldw	r3,-8(fp)
 3232bd0:	e0bffd17 	ldw	r2,-12(fp)
 3232bd4:	18800615 	stw	r2,24(r3)
      m->m_act = next;
 3232bd8:	e0fffd17 	ldw	r3,-12(fp)
 3232bdc:	e0bffb17 	ldw	r2,-20(fp)
 3232be0:	18800715 	stw	r2,28(r3)
 3232be4:	00000306 	br	3232bf4 <sbdrop+0x1b8>
   } else
      sb->sb_mb = next;
 3232be8:	e0fffe17 	ldw	r3,-8(fp)
 3232bec:	e0bffb17 	ldw	r2,-20(fp)
 3232bf0:	18800615 	stw	r2,24(r3)
   EXIT_CRIT_SECTION(sb);
 3232bf4:	322b14c0 	call	322b14c <irq_Unmask>
}
 3232bf8:	e037883a 	mov	sp,fp
 3232bfc:	dfc00117 	ldw	ra,4(sp)
 3232c00:	df000017 	ldw	fp,0(sp)
 3232c04:	dec00204 	addi	sp,sp,8
 3232c08:	f800283a 	ret

03232c0c <sbdropend>:
 * RETURNS: 
 */

void
sbdropend(struct sockbuf * sb, struct mbuf * m)
{
 3232c0c:	defff904 	addi	sp,sp,-28
 3232c10:	dfc00615 	stw	ra,24(sp)
 3232c14:	df000515 	stw	fp,20(sp)
 3232c18:	df000504 	addi	fp,sp,20
 3232c1c:	e13ffe15 	stw	r4,-8(fp)
 3232c20:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  nmb, *   pmb;
   int   len;
   ENTER_CRIT_SECTION(sb);
 3232c24:	322b0f00 	call	322b0f0 <irq_Mask>
   len = mbuf_len(m);
 3232c28:	e13fff17 	ldw	r4,-4(fp)
 3232c2c:	322c5040 	call	322c504 <mbuf_len>
 3232c30:	e0bffb15 	stw	r2,-20(fp)
   if (len > 0)
 3232c34:	e0bffb17 	ldw	r2,-20(fp)
 3232c38:	10800050 	cmplti	r2,r2,1
 3232c3c:	1000051e 	bne	r2,zero,3232c54 <sbdropend+0x48>
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
 3232c40:	e0bffe17 	ldw	r2,-8(fp)
 3232c44:	11000617 	ldw	r4,24(r2)
 3232c48:	e0bffb17 	ldw	r2,-20(fp)
 3232c4c:	008bc83a 	sub	r5,zero,r2
 3232c50:	322c3340 	call	322c334 <m_adj>
   nmb = sb->sb_mb;
 3232c54:	e0bffe17 	ldw	r2,-8(fp)
 3232c58:	10800617 	ldw	r2,24(r2)
 3232c5c:	e0bffd15 	stw	r2,-12(fp)
   pmb = NULL;
 3232c60:	e03ffc15 	stw	zero,-16(fp)
   if (sb->sb_mb->m_len == 0)
 3232c64:	e0bffe17 	ldw	r2,-8(fp)
 3232c68:	10800617 	ldw	r2,24(r2)
 3232c6c:	10800217 	ldw	r2,8(r2)
 3232c70:	1004c03a 	cmpne	r2,r2,zero
 3232c74:	1000081e 	bne	r2,zero,3232c98 <sbdropend+0x8c>
      sb->sb_mb = NULL;
 3232c78:	e0bffe17 	ldw	r2,-8(fp)
 3232c7c:	10000615 	stw	zero,24(r2)
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 3232c80:	00000506 	br	3232c98 <sbdropend+0x8c>
   {
      pmb = nmb;  /* Remember previous */
 3232c84:	e0bffd17 	ldw	r2,-12(fp)
 3232c88:	e0bffc15 	stw	r2,-16(fp)
      nmb = nmb->m_next;    
 3232c8c:	e0bffd17 	ldw	r2,-12(fp)
 3232c90:	10800617 	ldw	r2,24(r2)
 3232c94:	e0bffd15 	stw	r2,-12(fp)
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
   nmb = sb->sb_mb;
   pmb = NULL;
   if (sb->sb_mb->m_len == 0)
      sb->sb_mb = NULL;
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 3232c98:	e0bffd17 	ldw	r2,-12(fp)
 3232c9c:	1005003a 	cmpeq	r2,r2,zero
 3232ca0:	1000041e 	bne	r2,zero,3232cb4 <sbdropend+0xa8>
 3232ca4:	e0bffd17 	ldw	r2,-12(fp)
 3232ca8:	10800217 	ldw	r2,8(r2)
 3232cac:	1004c03a 	cmpne	r2,r2,zero
 3232cb0:	103ff41e 	bne	r2,zero,3232c84 <sbdropend+0x78>
   {
      pmb = nmb;  /* Remember previous */
      nmb = nmb->m_next;    
   }
   if (nmb && (nmb->m_len == 0)) /* Assume once 0 len found, all the rest */
 3232cb4:	e0bffd17 	ldw	r2,-12(fp)
 3232cb8:	1005003a 	cmpeq	r2,r2,zero
 3232cbc:	10000b1e 	bne	r2,zero,3232cec <sbdropend+0xe0>
 3232cc0:	e0bffd17 	ldw	r2,-12(fp)
 3232cc4:	10800217 	ldw	r2,8(r2)
 3232cc8:	1004c03a 	cmpne	r2,r2,zero
 3232ccc:	1000071e 	bne	r2,zero,3232cec <sbdropend+0xe0>
   {                             /* are zeroes */ 
      if (pmb != NULL)
 3232cd0:	e0bffc17 	ldw	r2,-16(fp)
 3232cd4:	1005003a 	cmpeq	r2,r2,zero
 3232cd8:	1000021e 	bne	r2,zero,3232ce4 <sbdropend+0xd8>
         pmb->m_next = NULL;
 3232cdc:	e0bffc17 	ldw	r2,-16(fp)
 3232ce0:	10000615 	stw	zero,24(r2)
      m_freem(nmb);            
 3232ce4:	e13ffd17 	ldw	r4,-12(fp)
 3232ce8:	322bfcc0 	call	322bfcc <m_freem>
   }
   sb->sb_cc -= len;       /* Do a sbfree using the len */
 3232cec:	e0bffe17 	ldw	r2,-8(fp)
 3232cf0:	10c00017 	ldw	r3,0(r2)
 3232cf4:	e0bffb17 	ldw	r2,-20(fp)
 3232cf8:	1887c83a 	sub	r3,r3,r2
 3232cfc:	e0bffe17 	ldw	r2,-8(fp)
 3232d00:	10c00015 	stw	r3,0(r2)
   EXIT_CRIT_SECTION(sb);
 3232d04:	322b14c0 	call	322b14c <irq_Unmask>
}
 3232d08:	e037883a 	mov	sp,fp
 3232d0c:	dfc00117 	ldw	ra,4(sp)
 3232d10:	df000017 	ldw	fp,0(sp)
 3232d14:	dec00204 	addi	sp,sp,8
 3232d18:	f800283a 	ret

03232d1c <sbdroprecord>:
 * RETURNS: 
 */

void
sbdroprecord(struct sockbuf * sb)
{
 3232d1c:	defffb04 	addi	sp,sp,-20
 3232d20:	dfc00415 	stw	ra,16(sp)
 3232d24:	df000315 	stw	fp,12(sp)
 3232d28:	df000304 	addi	fp,sp,12
 3232d2c:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  m, *  mn;

   ENTER_CRIT_SECTION(sb);
 3232d30:	322b0f00 	call	322b0f0 <irq_Mask>
   m = sb->sb_mb;
 3232d34:	e0bfff17 	ldw	r2,-4(fp)
 3232d38:	10800617 	ldw	r2,24(r2)
 3232d3c:	e0bffe15 	stw	r2,-8(fp)
   if (m)
 3232d40:	e0bffe17 	ldw	r2,-8(fp)
 3232d44:	1005003a 	cmpeq	r2,r2,zero
 3232d48:	1000131e 	bne	r2,zero,3232d98 <sbdroprecord+0x7c>
   {  sb->sb_mb = m->m_act;
 3232d4c:	e0bffe17 	ldw	r2,-8(fp)
 3232d50:	10c00717 	ldw	r3,28(r2)
 3232d54:	e0bfff17 	ldw	r2,-4(fp)
 3232d58:	10c00615 	stw	r3,24(r2)
      do 
      {  sbfree(sb, m);
 3232d5c:	e0bfff17 	ldw	r2,-4(fp)
 3232d60:	10c00017 	ldw	r3,0(r2)
 3232d64:	e0bffe17 	ldw	r2,-8(fp)
 3232d68:	10800217 	ldw	r2,8(r2)
 3232d6c:	1887c83a 	sub	r3,r3,r2
 3232d70:	e0bfff17 	ldw	r2,-4(fp)
 3232d74:	10c00015 	stw	r3,0(r2)
         MFREE(m, mn);
 3232d78:	e13ffe17 	ldw	r4,-8(fp)
 3232d7c:	322be980 	call	322be98 <m_free>
 3232d80:	e0bffd15 	stw	r2,-12(fp)
      } while ((m = mn) != NULL);
 3232d84:	e0bffd17 	ldw	r2,-12(fp)
 3232d88:	e0bffe15 	stw	r2,-8(fp)
 3232d8c:	e0bffe17 	ldw	r2,-8(fp)
 3232d90:	1004c03a 	cmpne	r2,r2,zero
 3232d94:	103ff11e 	bne	r2,zero,3232d5c <sbdroprecord+0x40>
         }
   EXIT_CRIT_SECTION(sb);
 3232d98:	322b14c0 	call	322b14c <irq_Unmask>
}
 3232d9c:	e037883a 	mov	sp,fp
 3232da0:	dfc00117 	ldw	ra,4(sp)
 3232da4:	df000017 	ldw	fp,0(sp)
 3232da8:	dec00204 	addi	sp,sp,8
 3232dac:	f800283a 	ret

03232db0 <t_select>:
int
t_select(fd_set * in,   /* lists of sockets to watch */
   fd_set * out,
   fd_set * ex,
   long  tv)   /* ticks to wait */
{
 3232db0:	defe7204 	addi	sp,sp,-1592
 3232db4:	dfc18d15 	stw	ra,1588(sp)
 3232db8:	df018c15 	stw	fp,1584(sp)
 3232dbc:	df018c04 	addi	fp,sp,1584
 3232dc0:	e13ffc15 	stw	r4,-16(fp)
 3232dc4:	e17ffd15 	stw	r5,-12(fp)
 3232dc8:	e1bffe15 	stw	r6,-8(fp)
 3232dcc:	e1ffff15 	stw	r7,-4(fp)
   fd_set obits[3], ibits [3];
   u_long   tmo;
   int   retval   =  0;
 3232dd0:	e03e7415 	stw	zero,-1584(fp)

   MEMSET(&obits, 0, sizeof(obits));
 3232dd4:	e0be7604 	addi	r2,fp,-1576
 3232dd8:	1009883a 	mov	r4,r2
 3232ddc:	0180c304 	movi	r6,780
 3232de0:	000b883a 	mov	r5,zero
 3232de4:	3206c500 	call	3206c50 <memset>
   MEMSET(&ibits, 0, sizeof(ibits));
 3232de8:	e0bf3904 	addi	r2,fp,-796
 3232dec:	1009883a 	mov	r4,r2
 3232df0:	0180c304 	movi	r6,780
 3232df4:	000b883a 	mov	r5,zero
 3232df8:	3206c500 	call	3206c50 <memset>

   if (in)
 3232dfc:	e0bffc17 	ldw	r2,-16(fp)
 3232e00:	1005003a 	cmpeq	r2,r2,zero
 3232e04:	1000061e 	bne	r2,zero,3232e20 <t_select+0x70>
      MEMCPY(&ibits[0], in, sizeof(fd_set));
 3232e08:	e0bf3904 	addi	r2,fp,-796
 3232e0c:	e0fffc17 	ldw	r3,-16(fp)
 3232e10:	1009883a 	mov	r4,r2
 3232e14:	180b883a 	mov	r5,r3
 3232e18:	01804104 	movi	r6,260
 3232e1c:	3206ad00 	call	3206ad0 <memcpy>
   if (out)
 3232e20:	e0bffd17 	ldw	r2,-12(fp)
 3232e24:	1005003a 	cmpeq	r2,r2,zero
 3232e28:	1000071e 	bne	r2,zero,3232e48 <t_select+0x98>
      MEMCPY(&ibits[1], out, sizeof(fd_set));
 3232e2c:	e0bf3904 	addi	r2,fp,-796
 3232e30:	10804104 	addi	r2,r2,260
 3232e34:	e0fffd17 	ldw	r3,-12(fp)
 3232e38:	1009883a 	mov	r4,r2
 3232e3c:	180b883a 	mov	r5,r3
 3232e40:	01804104 	movi	r6,260
 3232e44:	3206ad00 	call	3206ad0 <memcpy>
   if (ex)
 3232e48:	e0bffe17 	ldw	r2,-8(fp)
 3232e4c:	1005003a 	cmpeq	r2,r2,zero
 3232e50:	1000071e 	bne	r2,zero,3232e70 <t_select+0xc0>
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
 3232e54:	e0bf3904 	addi	r2,fp,-796
 3232e58:	10808204 	addi	r2,r2,520
 3232e5c:	e0fffe17 	ldw	r3,-8(fp)
 3232e60:	1009883a 	mov	r4,r2
 3232e64:	180b883a 	mov	r5,r3
 3232e68:	01804104 	movi	r6,260
 3232e6c:	3206ad00 	call	3206ad0 <memcpy>
   tmo = cticks + tv;
 3232e70:	0080c974 	movhi	r2,805
 3232e74:	10934104 	addi	r2,r2,19716
 3232e78:	10c00017 	ldw	r3,0(r2)
 3232e7c:	e0bfff17 	ldw	r2,-4(fp)
 3232e80:	1885883a 	add	r2,r3,r2
 3232e84:	e0be7515 	stw	r2,-1580(fp)

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 3232e88:	e0bf3917 	ldw	r2,-796(fp)
 3232e8c:	1004c03a 	cmpne	r2,r2,zero
 3232e90:	10000e1e 	bne	r2,zero,3232ecc <t_select+0x11c>
 3232e94:	e0bf7a17 	ldw	r2,-536(fp)
 3232e98:	1004c03a 	cmpne	r2,r2,zero
 3232e9c:	10000b1e 	bne	r2,zero,3232ecc <t_select+0x11c>
 3232ea0:	e0bfbb17 	ldw	r2,-276(fp)
 3232ea4:	1004c03a 	cmpne	r2,r2,zero
 3232ea8:	1000081e 	bne	r2,zero,3232ecc <t_select+0x11c>
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 3232eac:	e0bfff17 	ldw	r2,-4(fp)
 3232eb0:	10800050 	cmplti	r2,r2,1
 3232eb4:	1000201e 	bne	r2,zero,3232f38 <t_select+0x188>
         while (tmo > cticks)
         {
            tk_yield();
         }
#else
         TK_SLEEP(tv);
 3232eb8:	e0bfff17 	ldw	r2,-4(fp)
 3232ebc:	10800044 	addi	r2,r2,1
 3232ec0:	113fffcc 	andi	r4,r2,65535
 3232ec4:	321d27c0 	call	321d27c <OSTimeDly>
   if (ex)
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
   tmo = cticks + tv;

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 3232ec8:	00001b06 	br	3232f38 <t_select+0x188>

      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
 3232ecc:	0009883a 	mov	r4,zero
 3232ed0:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      while ((retval = sock_selscan(ibits, obits)) == 0)
 3232ed4:	00000f06 	br	3232f14 <t_select+0x164>
      {
         if (tv != -1L) 
 3232ed8:	e0bfff17 	ldw	r2,-4(fp)
 3232edc:	10bfffe0 	cmpeqi	r2,r2,-1
 3232ee0:	1000051e 	bne	r2,zero,3232ef8 <t_select+0x148>
         {
            if (tmo <= cticks)
 3232ee4:	0080c974 	movhi	r2,805
 3232ee8:	10934104 	addi	r2,r2,19716
 3232eec:	10c00017 	ldw	r3,0(r2)
 3232ef0:	e0be7517 	ldw	r2,-1580(fp)
 3232ef4:	18800e2e 	bgeu	r3,r2,3232f30 <t_select+0x180>
               break;
         }
         select_wait = 1;
 3232ef8:	00c0c974 	movhi	r3,805
 3232efc:	18d34904 	addi	r3,r3,19748
 3232f00:	00800044 	movi	r2,1
 3232f04:	1880000d 	sth	r2,0(r3)
         tcp_sleep (&select_wait);
 3232f08:	0100c974 	movhi	r4,805
 3232f0c:	21134904 	addi	r4,r4,19748
 3232f10:	3226ac40 	call	3226ac4 <tcp_sleep>
      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
      while ((retval = sock_selscan(ibits, obits)) == 0)
 3232f14:	e13f3904 	addi	r4,fp,-796
 3232f18:	e17e7604 	addi	r5,fp,-1576
 3232f1c:	3232fd00 	call	3232fd0 <sock_selscan>
 3232f20:	e0be7415 	stw	r2,-1584(fp)
 3232f24:	e0be7417 	ldw	r2,-1584(fp)
 3232f28:	1005003a 	cmpeq	r2,r2,zero
 3232f2c:	103fea1e 	bne	r2,zero,3232ed8 <t_select+0x128>
               break;
         }
         select_wait = 1;
         tcp_sleep (&select_wait);
      }
      UNLOCK_NET_RESOURCE(NET_RESID);
 3232f30:	0009883a 	mov	r4,zero
 3232f34:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   }

   if (retval >= 0)
 3232f38:	e0be7417 	ldw	r2,-1584(fp)
 3232f3c:	1004803a 	cmplt	r2,r2,zero
 3232f40:	10001d1e 	bne	r2,zero,3232fb8 <t_select+0x208>
   {
      if (in)
 3232f44:	e0bffc17 	ldw	r2,-16(fp)
 3232f48:	1005003a 	cmpeq	r2,r2,zero
 3232f4c:	1000061e 	bne	r2,zero,3232f68 <t_select+0x1b8>
         MEMCPY(in, &obits[0], sizeof(fd_set));
 3232f50:	e0bffc17 	ldw	r2,-16(fp)
 3232f54:	e0fe7604 	addi	r3,fp,-1576
 3232f58:	1009883a 	mov	r4,r2
 3232f5c:	180b883a 	mov	r5,r3
 3232f60:	01804104 	movi	r6,260
 3232f64:	3206ad00 	call	3206ad0 <memcpy>
      if (out)
 3232f68:	e0bffd17 	ldw	r2,-12(fp)
 3232f6c:	1005003a 	cmpeq	r2,r2,zero
 3232f70:	1000071e 	bne	r2,zero,3232f90 <t_select+0x1e0>
         MEMCPY(out, &obits[1], sizeof(fd_set));
 3232f74:	e0be7604 	addi	r2,fp,-1576
 3232f78:	10c04104 	addi	r3,r2,260
 3232f7c:	e0bffd17 	ldw	r2,-12(fp)
 3232f80:	1009883a 	mov	r4,r2
 3232f84:	180b883a 	mov	r5,r3
 3232f88:	01804104 	movi	r6,260
 3232f8c:	3206ad00 	call	3206ad0 <memcpy>
      if (ex)
 3232f90:	e0bffe17 	ldw	r2,-8(fp)
 3232f94:	1005003a 	cmpeq	r2,r2,zero
 3232f98:	1000071e 	bne	r2,zero,3232fb8 <t_select+0x208>
         MEMCPY(ex, &obits[2], sizeof(fd_set));
 3232f9c:	e0be7604 	addi	r2,fp,-1576
 3232fa0:	10c08204 	addi	r3,r2,520
 3232fa4:	e0bffe17 	ldw	r2,-8(fp)
 3232fa8:	1009883a 	mov	r4,r2
 3232fac:	180b883a 	mov	r5,r3
 3232fb0:	01804104 	movi	r6,260
 3232fb4:	3206ad00 	call	3206ad0 <memcpy>
   }
   return retval;
 3232fb8:	e0be7417 	ldw	r2,-1584(fp)
}
 3232fbc:	e037883a 	mov	sp,fp
 3232fc0:	dfc00117 	ldw	ra,4(sp)
 3232fc4:	df000017 	ldw	fp,0(sp)
 3232fc8:	dec00204 	addi	sp,sp,8
 3232fcc:	f800283a 	ret

03232fd0 <sock_selscan>:
 * RETURNS: 
 */

int
sock_selscan(fd_set * ibits, fd_set * obits)
{
 3232fd0:	defff504 	addi	sp,sp,-44
 3232fd4:	dfc00a15 	stw	ra,40(sp)
 3232fd8:	df000915 	stw	fp,36(sp)
 3232fdc:	df000904 	addi	fp,sp,36
 3232fe0:	e13ffd15 	stw	r4,-12(fp)
 3232fe4:	e17ffe15 	stw	r5,-8(fp)
   fd_set *in, *out;
   int   which;
   int   sock;
   int   flag  =  0;
 3232fe8:	e03ff815 	stw	zero,-32(fp)
   int   num_sel  =  0;
 3232fec:	e03ff715 	stw	zero,-36(fp)

   for (which = 0; which < 3; which++)
 3232ff0:	e03ffa15 	stw	zero,-24(fp)
 3232ff4:	00004306 	br	3233104 <sock_selscan+0x134>
   {
      switch (which)
 3232ff8:	e0bffa17 	ldw	r2,-24(fp)
 3232ffc:	e0bfff15 	stw	r2,-4(fp)
 3233000:	e0ffff17 	ldw	r3,-4(fp)
 3233004:	18800060 	cmpeqi	r2,r3,1
 3233008:	10000a1e 	bne	r2,zero,3233034 <sock_selscan+0x64>
 323300c:	e0ffff17 	ldw	r3,-4(fp)
 3233010:	188000a0 	cmpeqi	r2,r3,2
 3233014:	10000a1e 	bne	r2,zero,3233040 <sock_selscan+0x70>
 3233018:	e0ffff17 	ldw	r3,-4(fp)
 323301c:	1805003a 	cmpeq	r2,r3,zero
 3233020:	1000011e 	bne	r2,zero,3233028 <sock_selscan+0x58>
 3233024:	00000706 	br	3233044 <sock_selscan+0x74>
      {
      case 0:
         flag = SOREAD; break;
 3233028:	00800044 	movi	r2,1
 323302c:	e0bff815 	stw	r2,-32(fp)
 3233030:	00000406 	br	3233044 <sock_selscan+0x74>

      case 1:
         flag = SOWRITE; break;
 3233034:	00800084 	movi	r2,2
 3233038:	e0bff815 	stw	r2,-32(fp)
 323303c:	00000106 	br	3233044 <sock_selscan+0x74>

      case 2:
         flag = 0; break;
 3233040:	e03ff815 	stw	zero,-32(fp)
      }
      in = &ibits [which];
 3233044:	e0bffa17 	ldw	r2,-24(fp)
 3233048:	10804124 	muli	r2,r2,260
 323304c:	1007883a 	mov	r3,r2
 3233050:	e0bffd17 	ldw	r2,-12(fp)
 3233054:	1885883a 	add	r2,r3,r2
 3233058:	e0bffc15 	stw	r2,-16(fp)
      out = &obits [which];
 323305c:	e0bffa17 	ldw	r2,-24(fp)
 3233060:	10804124 	muli	r2,r2,260
 3233064:	1007883a 	mov	r3,r2
 3233068:	e0bffe17 	ldw	r2,-8(fp)
 323306c:	1885883a 	add	r2,r3,r2
 3233070:	e0bffb15 	stw	r2,-20(fp)
      for (sock = 0; sock < (int)in->fd_count; sock++)
 3233074:	e03ff915 	stw	zero,-28(fp)
 3233078:	00001a06 	br	32330e4 <sock_selscan+0x114>
      {
         if (sock_select (in->fd_array[sock], flag))
 323307c:	e0bff917 	ldw	r2,-28(fp)
 3233080:	e0fffc17 	ldw	r3,-16(fp)
 3233084:	1085883a 	add	r2,r2,r2
 3233088:	1085883a 	add	r2,r2,r2
 323308c:	10c5883a 	add	r2,r2,r3
 3233090:	10800104 	addi	r2,r2,4
 3233094:	11000017 	ldw	r4,0(r2)
 3233098:	e17ff817 	ldw	r5,-32(fp)
 323309c:	32331280 	call	3233128 <sock_select>
 32330a0:	1005003a 	cmpeq	r2,r2,zero
 32330a4:	10000c1e 	bne	r2,zero,32330d8 <sock_selscan+0x108>
         {
            FD_SET(in->fd_array[sock], out);
 32330a8:	e0bff917 	ldw	r2,-28(fp)
 32330ac:	e0fffc17 	ldw	r3,-16(fp)
 32330b0:	1085883a 	add	r2,r2,r2
 32330b4:	1085883a 	add	r2,r2,r2
 32330b8:	10c5883a 	add	r2,r2,r3
 32330bc:	10800104 	addi	r2,r2,4
 32330c0:	11000017 	ldw	r4,0(r2)
 32330c4:	e17ffb17 	ldw	r5,-20(fp)
 32330c8:	32335600 	call	3233560 <ifd_set>
            num_sel++;
 32330cc:	e0bff717 	ldw	r2,-36(fp)
 32330d0:	10800044 	addi	r2,r2,1
 32330d4:	e0bff715 	stw	r2,-36(fp)
      case 2:
         flag = 0; break;
      }
      in = &ibits [which];
      out = &obits [which];
      for (sock = 0; sock < (int)in->fd_count; sock++)
 32330d8:	e0bff917 	ldw	r2,-28(fp)
 32330dc:	10800044 	addi	r2,r2,1
 32330e0:	e0bff915 	stw	r2,-28(fp)
 32330e4:	e0bffc17 	ldw	r2,-16(fp)
 32330e8:	10800017 	ldw	r2,0(r2)
 32330ec:	1007883a 	mov	r3,r2
 32330f0:	e0bff917 	ldw	r2,-28(fp)
 32330f4:	10ffe116 	blt	r2,r3,323307c <sock_selscan+0xac>
   int   which;
   int   sock;
   int   flag  =  0;
   int   num_sel  =  0;

   for (which = 0; which < 3; which++)
 32330f8:	e0bffa17 	ldw	r2,-24(fp)
 32330fc:	10800044 	addi	r2,r2,1
 3233100:	e0bffa15 	stw	r2,-24(fp)
 3233104:	e0bffa17 	ldw	r2,-24(fp)
 3233108:	108000d0 	cmplti	r2,r2,3
 323310c:	103fba1e 	bne	r2,zero,3232ff8 <sock_selscan+0x28>
            FD_SET(in->fd_array[sock], out);
            num_sel++;
         }
      }
   }
   return num_sel;
 3233110:	e0bff717 	ldw	r2,-36(fp)
}
 3233114:	e037883a 	mov	sp,fp
 3233118:	dfc00117 	ldw	ra,4(sp)
 323311c:	df000017 	ldw	fp,0(sp)
 3233120:	dec00204 	addi	sp,sp,8
 3233124:	f800283a 	ret

03233128 <sock_select>:
 * RETURNS: 
 */

int
sock_select(long sock, int flag)
{
 3233128:	defff904 	addi	sp,sp,-28
 323312c:	dfc00615 	stw	ra,24(sp)
 3233130:	df000515 	stw	fp,20(sp)
 3233134:	df000504 	addi	fp,sp,20
 3233138:	e13ffd15 	stw	r4,-12(fp)
 323313c:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so;
   int   ready =  0;
 3233140:	e03ffb15 	stw	zero,-20(fp)

   so = LONG2SO(sock);
 3233144:	e0bffd17 	ldw	r2,-12(fp)
 3233148:	10bff804 	addi	r2,r2,-32
 323314c:	1085883a 	add	r2,r2,r2
 3233150:	1085883a 	add	r2,r2,r2
 3233154:	e0bffc15 	stw	r2,-16(fp)

   switch (flag) 
 3233158:	e0bffe17 	ldw	r2,-8(fp)
 323315c:	e0bfff15 	stw	r2,-4(fp)
 3233160:	e0ffff17 	ldw	r3,-4(fp)
 3233164:	18800060 	cmpeqi	r2,r3,1
 3233168:	1000071e 	bne	r2,zero,3233188 <sock_select+0x60>
 323316c:	e0ffff17 	ldw	r3,-4(fp)
 3233170:	188000a0 	cmpeqi	r2,r3,2
 3233174:	1000251e 	bne	r2,zero,323320c <sock_select+0xe4>
 3233178:	e0ffff17 	ldw	r3,-4(fp)
 323317c:	1805003a 	cmpeq	r2,r3,zero
 3233180:	1000491e 	bne	r2,zero,32332a8 <sock_select+0x180>
 3233184:	00006706 	br	3233324 <sock_select+0x1fc>
   {
   case SOREAD:
      /* can we read something from so? */
      if (so->so_rcv.sb_cc)
 3233188:	e0bffc17 	ldw	r2,-16(fp)
 323318c:	10800a17 	ldw	r2,40(r2)
 3233190:	1005003a 	cmpeq	r2,r2,zero
 3233194:	1000031e 	bne	r2,zero,32331a4 <sock_select+0x7c>
      {
         ready = 1;
 3233198:	00800044 	movi	r2,1
 323319c:	e0bffb15 	stw	r2,-20(fp)
         break;
 32331a0:	00006006 	br	3233324 <sock_select+0x1fc>
      }
      if (so->so_state & SS_CANTRCVMORE)
 32331a4:	e0bffc17 	ldw	r2,-16(fp)
 32331a8:	1080088b 	ldhu	r2,34(r2)
 32331ac:	10bfffcc 	andi	r2,r2,65535
 32331b0:	1080080c 	andi	r2,r2,32
 32331b4:	1005003a 	cmpeq	r2,r2,zero
 32331b8:	1000031e 	bne	r2,zero,32331c8 <sock_select+0xa0>
      {  ready = 1;
 32331bc:	00800044 	movi	r2,1
 32331c0:	e0bffb15 	stw	r2,-20(fp)
         break;
 32331c4:	00005706 	br	3233324 <sock_select+0x1fc>
      }
      if (so->so_qlen)  /* attach is ready */
 32331c8:	e0bffc17 	ldw	r2,-16(fp)
 32331cc:	10801e43 	ldbu	r2,121(r2)
 32331d0:	10803fcc 	andi	r2,r2,255
 32331d4:	1080201c 	xori	r2,r2,128
 32331d8:	10bfe004 	addi	r2,r2,-128
 32331dc:	1005003a 	cmpeq	r2,r2,zero
 32331e0:	1000031e 	bne	r2,zero,32331f0 <sock_select+0xc8>
      {
         ready = 1;
 32331e4:	00800044 	movi	r2,1
 32331e8:	e0bffb15 	stw	r2,-20(fp)
         break;
 32331ec:	00004d06 	br	3233324 <sock_select+0x1fc>
         }
      }
#endif   /* TCP_ZEROCOPY */

      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
 32331f0:	e0bffc17 	ldw	r2,-16(fp)
 32331f4:	1080110b 	ldhu	r2,68(r2)
 32331f8:	10800214 	ori	r2,r2,8
 32331fc:	1007883a 	mov	r3,r2
 3233200:	e0bffc17 	ldw	r2,-16(fp)
 3233204:	10c0110d 	sth	r3,68(r2)
      break;
 3233208:	00004606 	br	3233324 <sock_select+0x1fc>

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 323320c:	e0bffc17 	ldw	r2,-16(fp)
 3233210:	10801317 	ldw	r2,76(r2)
 3233214:	1007883a 	mov	r3,r2
 3233218:	e0bffc17 	ldw	r2,-16(fp)
 323321c:	10801217 	ldw	r2,72(r2)
 3233220:	1885c83a 	sub	r2,r3,r2
 3233224:	1004803a 	cmplt	r2,r2,zero
 3233228:	10001b1e 	bne	r2,zero,3233298 <sock_select+0x170>
 323322c:	e0bffc17 	ldw	r2,-16(fp)
 3233230:	10c01317 	ldw	r3,76(r2)
 3233234:	e0bffc17 	ldw	r2,-16(fp)
 3233238:	10801217 	ldw	r2,72(r2)
 323323c:	18801626 	beq	r3,r2,3233298 <sock_select+0x170>
 3233240:	e0bffc17 	ldw	r2,-16(fp)
 3233244:	1080088b 	ldhu	r2,34(r2)
 3233248:	10bfffcc 	andi	r2,r2,65535
 323324c:	1080008c 	andi	r2,r2,2
 3233250:	1004c03a 	cmpne	r2,r2,zero
 3233254:	10000d1e 	bne	r2,zero,323328c <sock_select+0x164>
 3233258:	e0bffc17 	ldw	r2,-16(fp)
 323325c:	10800217 	ldw	r2,8(r2)
 3233260:	1080010b 	ldhu	r2,4(r2)
 3233264:	10bfffcc 	andi	r2,r2,65535
 3233268:	1080010c 	andi	r2,r2,4
 323326c:	1005003a 	cmpeq	r2,r2,zero
 3233270:	1000061e 	bne	r2,zero,323328c <sock_select+0x164>
 3233274:	e0bffc17 	ldw	r2,-16(fp)
 3233278:	1080088b 	ldhu	r2,34(r2)
 323327c:	10bfffcc 	andi	r2,r2,65535
 3233280:	1080040c 	andi	r2,r2,16
 3233284:	1005003a 	cmpeq	r2,r2,zero
 3233288:	1000031e 	bne	r2,zero,3233298 <sock_select+0x170>
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
           ((so)->so_state & SS_CANTSENDMORE)))
      {
         ready = 1;
 323328c:	00800044 	movi	r2,1
 3233290:	e0bffb15 	stw	r2,-20(fp)
         break;
 3233294:	00002306 	br	3233324 <sock_select+0x1fc>
      }
      sbselqueue (&so->so_snd);
 3233298:	e0bffc17 	ldw	r2,-16(fp)
 323329c:	11001204 	addi	r4,r2,72
 32332a0:	32321d00 	call	32321d0 <sbselqueue>
      break;
 32332a4:	00001f06 	br	3233324 <sock_select+0x1fc>

   case 0:
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
 32332a8:	e0bffc17 	ldw	r2,-16(fp)
 32332ac:	10801a17 	ldw	r2,104(r2)
 32332b0:	1004c03a 	cmpne	r2,r2,zero
 32332b4:	1000061e 	bne	r2,zero,32332d0 <sock_select+0x1a8>
 32332b8:	e0bffc17 	ldw	r2,-16(fp)
 32332bc:	1080088b 	ldhu	r2,34(r2)
 32332c0:	10bfffcc 	andi	r2,r2,65535
 32332c4:	1080100c 	andi	r2,r2,64
 32332c8:	1005003a 	cmpeq	r2,r2,zero
 32332cc:	1000031e 	bne	r2,zero,32332dc <sock_select+0x1b4>
      {
         ready = 1;
 32332d0:	00800044 	movi	r2,1
 32332d4:	e0bffb15 	stw	r2,-20(fp)
         break;
 32332d8:	00001206 	br	3233324 <sock_select+0x1fc>
      }
      if (so->so_error &&
 32332dc:	e0bffc17 	ldw	r2,-16(fp)
 32332e0:	10800617 	ldw	r2,24(r2)
 32332e4:	1005003a 	cmpeq	r2,r2,zero
 32332e8:	10000b1e 	bne	r2,zero,3233318 <sock_select+0x1f0>
 32332ec:	e0bffc17 	ldw	r2,-16(fp)
 32332f0:	10800617 	ldw	r2,24(r2)
 32332f4:	10801de0 	cmpeqi	r2,r2,119
 32332f8:	1000071e 	bne	r2,zero,3233318 <sock_select+0x1f0>
 32332fc:	e0bffc17 	ldw	r2,-16(fp)
 3233300:	10800617 	ldw	r2,24(r2)
 3233304:	108002e0 	cmpeqi	r2,r2,11
 3233308:	1000031e 	bne	r2,zero,3233318 <sock_select+0x1f0>
          (so->so_error != EINPROGRESS) &&
          (so->so_error != EWOULDBLOCK))
      {
         ready = 1;
 323330c:	00800044 	movi	r2,1
 3233310:	e0bffb15 	stw	r2,-20(fp)
         break;
 3233314:	00000306 	br	3233324 <sock_select+0x1fc>
      }
      sbselqueue(&so->so_rcv);
 3233318:	e0bffc17 	ldw	r2,-16(fp)
 323331c:	11000a04 	addi	r4,r2,40
 3233320:	32321d00 	call	32321d0 <sbselqueue>
      break;
   }

   return ready;
 3233324:	e0bffb17 	ldw	r2,-20(fp)
}
 3233328:	e037883a 	mov	sp,fp
 323332c:	dfc00117 	ldw	ra,4(sp)
 3233330:	df000017 	ldw	fp,0(sp)
 3233334:	dec00204 	addi	sp,sp,8
 3233338:	f800283a 	ret

0323333c <in_pcbnotify>:
void
in_pcbnotify(struct inpcb * head, 
   struct in_addr *  dst,
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
 323333c:	defff804 	addi	sp,sp,-32
 3233340:	dfc00715 	stw	ra,28(sp)
 3233344:	df000615 	stw	fp,24(sp)
 3233348:	df000604 	addi	fp,sp,24
 323334c:	e13ffc15 	stw	r4,-16(fp)
 3233350:	e17ffd15 	stw	r5,-12(fp)
 3233354:	e1bffe15 	stw	r6,-8(fp)
 3233358:	e1ffff15 	stw	r7,-4(fp)
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 323335c:	e0bffc17 	ldw	r2,-16(fp)
 3233360:	10800017 	ldw	r2,0(r2)
 3233364:	e0bffb15 	stw	r2,-20(fp)
 3233368:	00001f06 	br	32333e8 <in_pcbnotify+0xac>
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 323336c:	e0bffb17 	ldw	r2,-20(fp)
 3233370:	10c00317 	ldw	r3,12(r2)
 3233374:	e0bffd17 	ldw	r2,-12(fp)
 3233378:	10800017 	ldw	r2,0(r2)
 323337c:	1880041e 	bne	r3,r2,3233390 <in_pcbnotify+0x54>
 3233380:	e0bffb17 	ldw	r2,-20(fp)
 3233384:	10800817 	ldw	r2,32(r2)
 3233388:	1004c03a 	cmpne	r2,r2,zero
 323338c:	1000041e 	bne	r2,zero,32333a0 <in_pcbnotify+0x64>
          inp->inp_socket == 0) 
      {
         inp = inp->inp_next;
 3233390:	e0bffb17 	ldw	r2,-20(fp)
 3233394:	10800017 	ldw	r2,0(r2)
 3233398:	e0bffb15 	stw	r2,-20(fp)
         continue;
 323339c:	00001206 	br	32333e8 <in_pcbnotify+0xac>
      }
      if (errnum) 
 32333a0:	e0bffe17 	ldw	r2,-8(fp)
 32333a4:	1005003a 	cmpeq	r2,r2,zero
 32333a8:	1000041e 	bne	r2,zero,32333bc <in_pcbnotify+0x80>
         inp->inp_socket->so_error = errnum;
 32333ac:	e0bffb17 	ldw	r2,-20(fp)
 32333b0:	10c00817 	ldw	r3,32(r2)
 32333b4:	e0bffe17 	ldw	r2,-8(fp)
 32333b8:	18800615 	stw	r2,24(r3)
      oinp = inp;
 32333bc:	e0bffb17 	ldw	r2,-20(fp)
 32333c0:	e0bffa15 	stw	r2,-24(fp)
      inp = inp->inp_next;
 32333c4:	e0bffb17 	ldw	r2,-20(fp)
 32333c8:	10800017 	ldw	r2,0(r2)
 32333cc:	e0bffb15 	stw	r2,-20(fp)
      if (notify)
 32333d0:	e0bfff17 	ldw	r2,-4(fp)
 32333d4:	1005003a 	cmpeq	r2,r2,zero
 32333d8:	1000031e 	bne	r2,zero,32333e8 <in_pcbnotify+0xac>
         (*notify)(oinp);
 32333dc:	e0bfff17 	ldw	r2,-4(fp)
 32333e0:	e13ffa17 	ldw	r4,-24(fp)
 32333e4:	103ee83a 	callr	r2
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 32333e8:	e0fffb17 	ldw	r3,-20(fp)
 32333ec:	e0bffc17 	ldw	r2,-16(fp)
 32333f0:	18bfde1e 	bne	r3,r2,323336c <in_pcbnotify+0x30>
      oinp = inp;
      inp = inp->inp_next;
      if (notify)
         (*notify)(oinp);
   }
}
 32333f4:	e037883a 	mov	sp,fp
 32333f8:	dfc00117 	ldw	ra,4(sp)
 32333fc:	df000017 	ldw	fp,0(sp)
 3233400:	dec00204 	addi	sp,sp,8
 3233404:	f800283a 	ret

03233408 <tcp_notify>:
 * RETURNS: 
 */

void
tcp_notify(struct inpcb * inp)
{
 3233408:	defffd04 	addi	sp,sp,-12
 323340c:	dfc00215 	stw	ra,8(sp)
 3233410:	df000115 	stw	fp,4(sp)
 3233414:	df000104 	addi	fp,sp,4
 3233418:	e13fff15 	stw	r4,-4(fp)
   tcp_wakeup(&inp->inp_socket->so_timeo);
 323341c:	e0bfff17 	ldw	r2,-4(fp)
 3233420:	10800817 	ldw	r2,32(r2)
 3233424:	11000904 	addi	r4,r2,36
 3233428:	3226c640 	call	3226c64 <tcp_wakeup>
   sorwakeup(inp->inp_socket);
 323342c:	e0bfff17 	ldw	r2,-4(fp)
 3233430:	11000817 	ldw	r4,32(r2)
 3233434:	e0bfff17 	ldw	r2,-4(fp)
 3233438:	10800817 	ldw	r2,32(r2)
 323343c:	11400a04 	addi	r5,r2,40
 3233440:	32322700 	call	3232270 <sbwakeup>
   sowwakeup(inp->inp_socket);
 3233444:	e0bfff17 	ldw	r2,-4(fp)
 3233448:	11000817 	ldw	r4,32(r2)
 323344c:	e0bfff17 	ldw	r2,-4(fp)
 3233450:	10800817 	ldw	r2,32(r2)
 3233454:	11401204 	addi	r5,r2,72
 3233458:	32322700 	call	3232270 <sbwakeup>
}
 323345c:	e037883a 	mov	sp,fp
 3233460:	dfc00117 	ldw	ra,4(sp)
 3233464:	df000017 	ldw	fp,0(sp)
 3233468:	dec00204 	addi	sp,sp,8
 323346c:	f800283a 	ret

03233470 <ifd_clr>:
 * compacts the fd_set.
 */

void
ifd_clr(long sock, fd_set *set)
{
 3233470:	defffb04 	addi	sp,sp,-20
 3233474:	dfc00415 	stw	ra,16(sp)
 3233478:	df000315 	stw	fp,12(sp)
 323347c:	df000304 	addi	fp,sp,12
 3233480:	e13ffe15 	stw	r4,-8(fp)
 3233484:	e17fff15 	stw	r5,-4(fp)
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 3233488:	e03ffd15 	stw	zero,-12(fp)
 323348c:	00002a06 	br	3233538 <ifd_clr+0xc8>
   {
      if (set->fd_array[i] == sock)
 3233490:	e0bffd17 	ldw	r2,-12(fp)
 3233494:	e0ffff17 	ldw	r3,-4(fp)
 3233498:	1085883a 	add	r2,r2,r2
 323349c:	1085883a 	add	r2,r2,r2
 32334a0:	10c5883a 	add	r2,r2,r3
 32334a4:	10800104 	addi	r2,r2,4
 32334a8:	10c00017 	ldw	r3,0(r2)
 32334ac:	e0bffe17 	ldw	r2,-8(fp)
 32334b0:	18801e1e 	bne	r3,r2,323352c <ifd_clr+0xbc>
      {
         while (i + 1 < set->fd_count)
 32334b4:	00001206 	br	3233500 <ifd_clr+0x90>
         {
            set->fd_array[i] = set->fd_array[i + 1];
 32334b8:	e13ffd17 	ldw	r4,-12(fp)
 32334bc:	e0bffd17 	ldw	r2,-12(fp)
 32334c0:	10800044 	addi	r2,r2,1
 32334c4:	e0ffff17 	ldw	r3,-4(fp)
 32334c8:	1085883a 	add	r2,r2,r2
 32334cc:	1085883a 	add	r2,r2,r2
 32334d0:	10c5883a 	add	r2,r2,r3
 32334d4:	10800104 	addi	r2,r2,4
 32334d8:	11400017 	ldw	r5,0(r2)
 32334dc:	e0ffff17 	ldw	r3,-4(fp)
 32334e0:	2105883a 	add	r2,r4,r4
 32334e4:	1085883a 	add	r2,r2,r2
 32334e8:	10c5883a 	add	r2,r2,r3
 32334ec:	10800104 	addi	r2,r2,4
 32334f0:	11400015 	stw	r5,0(r2)
            i++;
 32334f4:	e0bffd17 	ldw	r2,-12(fp)
 32334f8:	10800044 	addi	r2,r2,1
 32334fc:	e0bffd15 	stw	r2,-12(fp)

   for (i = 0; i < set->fd_count ; i++) 
   {
      if (set->fd_array[i] == sock)
      {
         while (i + 1 < set->fd_count)
 3233500:	e0bffd17 	ldw	r2,-12(fp)
 3233504:	10c00044 	addi	r3,r2,1
 3233508:	e0bfff17 	ldw	r2,-4(fp)
 323350c:	10800017 	ldw	r2,0(r2)
 3233510:	18bfe936 	bltu	r3,r2,32334b8 <ifd_clr+0x48>
         {
            set->fd_array[i] = set->fd_array[i + 1];
            i++;
         }
         set->fd_count--;
 3233514:	e0bfff17 	ldw	r2,-4(fp)
 3233518:	10800017 	ldw	r2,0(r2)
 323351c:	10ffffc4 	addi	r3,r2,-1
 3233520:	e0bfff17 	ldw	r2,-4(fp)
 3233524:	10c00015 	stw	r3,0(r2)
         return;
 3233528:	00000806 	br	323354c <ifd_clr+0xdc>
void
ifd_clr(long sock, fd_set *set)
{
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 323352c:	e0bffd17 	ldw	r2,-12(fp)
 3233530:	10800044 	addi	r2,r2,1
 3233534:	e0bffd15 	stw	r2,-12(fp)
 3233538:	e0bfff17 	ldw	r2,-4(fp)
 323353c:	10c00017 	ldw	r3,0(r2)
 3233540:	e0bffd17 	ldw	r2,-12(fp)
 3233544:	10ffd236 	bltu	r2,r3,3233490 <ifd_clr+0x20>
         return;
      }
   }

#ifdef NPDEBUG
   dtrap(); /* socket wasn't found in array */
 3233548:	322aef00 	call	322aef0 <dtrap>
#endif
}
 323354c:	e037883a 	mov	sp,fp
 3233550:	dfc00117 	ldw	ra,4(sp)
 3233554:	df000017 	ldw	fp,0(sp)
 3233558:	dec00204 	addi	sp,sp,8
 323355c:	f800283a 	ret

03233560 <ifd_set>:
 * called if the fd_set structure is already full.
 */

void
ifd_set(long sock, fd_set *set)
{
 3233560:	defffc04 	addi	sp,sp,-16
 3233564:	dfc00315 	stw	ra,12(sp)
 3233568:	df000215 	stw	fp,8(sp)
 323356c:	df000204 	addi	fp,sp,8
 3233570:	e13ffe15 	stw	r4,-8(fp)
 3233574:	e17fff15 	stw	r5,-4(fp)
   if (set->fd_count < FD_SETSIZE)
 3233578:	e0bfff17 	ldw	r2,-4(fp)
 323357c:	10800017 	ldw	r2,0(r2)
 3233580:	10801028 	cmpgeui	r2,r2,64
 3233584:	10000d1e 	bne	r2,zero,32335bc <ifd_set+0x5c>
      set->fd_array[set->fd_count++] = sock;
 3233588:	e0bfff17 	ldw	r2,-4(fp)
 323358c:	10c00017 	ldw	r3,0(r2)
 3233590:	e13fff17 	ldw	r4,-4(fp)
 3233594:	18c5883a 	add	r2,r3,r3
 3233598:	1085883a 	add	r2,r2,r2
 323359c:	1105883a 	add	r2,r2,r4
 32335a0:	11000104 	addi	r4,r2,4
 32335a4:	e0bffe17 	ldw	r2,-8(fp)
 32335a8:	20800015 	stw	r2,0(r4)
 32335ac:	18c00044 	addi	r3,r3,1
 32335b0:	e0bfff17 	ldw	r2,-4(fp)
 32335b4:	10c00015 	stw	r3,0(r2)
 32335b8:	00000106 	br	32335c0 <ifd_set+0x60>
#ifdef NPDEBUG
   else
      dtrap();
 32335bc:	322aef00 	call	322aef0 <dtrap>
#endif
}
 32335c0:	e037883a 	mov	sp,fp
 32335c4:	dfc00117 	ldw	ra,4(sp)
 32335c8:	df000017 	ldw	fp,0(sp)
 32335cc:	dec00204 	addi	sp,sp,8
 32335d0:	f800283a 	ret

032335d4 <ifd_isset>:
 * Tests if a socket is a member of a file descriptor set.
 */

int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
 32335d4:	defffb04 	addi	sp,sp,-20
 32335d8:	df000415 	stw	fp,16(sp)
 32335dc:	df000404 	addi	fp,sp,16
 32335e0:	e13ffd15 	stw	r4,-12(fp)
 32335e4:	e17ffe15 	stw	r5,-8(fp)
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 32335e8:	e03ffc15 	stw	zero,-16(fp)
 32335ec:	00000f06 	br	323362c <ifd_isset+0x58>
   {
      if (set->fd_array[i] == sock)
 32335f0:	e0bffc17 	ldw	r2,-16(fp)
 32335f4:	e0fffe17 	ldw	r3,-8(fp)
 32335f8:	1085883a 	add	r2,r2,r2
 32335fc:	1085883a 	add	r2,r2,r2
 3233600:	10c5883a 	add	r2,r2,r3
 3233604:	10800104 	addi	r2,r2,4
 3233608:	10c00017 	ldw	r3,0(r2)
 323360c:	e0bffd17 	ldw	r2,-12(fp)
 3233610:	1880031e 	bne	r3,r2,3233620 <ifd_isset+0x4c>
         return TRUE;
 3233614:	00800044 	movi	r2,1
 3233618:	e0bfff15 	stw	r2,-4(fp)
 323361c:	00000806 	br	3233640 <ifd_isset+0x6c>
int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 3233620:	e0bffc17 	ldw	r2,-16(fp)
 3233624:	10800044 	addi	r2,r2,1
 3233628:	e0bffc15 	stw	r2,-16(fp)
 323362c:	e0bffe17 	ldw	r2,-8(fp)
 3233630:	10c00017 	ldw	r3,0(r2)
 3233634:	e0bffc17 	ldw	r2,-16(fp)
 3233638:	10ffed36 	bltu	r2,r3,32335f0 <ifd_isset+0x1c>
   {
      if (set->fd_array[i] == sock)
         return TRUE;
   }
   return FALSE;
 323363c:	e03fff15 	stw	zero,-4(fp)
 3233640:	e0bfff17 	ldw	r2,-4(fp)
}
 3233644:	e037883a 	mov	sp,fp
 3233648:	df000017 	ldw	fp,0(sp)
 323364c:	dec00104 	addi	sp,sp,4
 3233650:	f800283a 	ret

03233654 <ifd_get>:
 * NOTE: This is not part of the original FD_XXX() functionality.
 */

long
ifd_get(unsigned i, fd_set *set)
{
 3233654:	defffb04 	addi	sp,sp,-20
 3233658:	dfc00415 	stw	ra,16(sp)
 323365c:	df000315 	stw	fp,12(sp)
 3233660:	df000304 	addi	fp,sp,12
 3233664:	e13ffd15 	stw	r4,-12(fp)
 3233668:	e17ffe15 	stw	r5,-8(fp)
   if (i < set->fd_count)
 323366c:	e0bffe17 	ldw	r2,-8(fp)
 3233670:	10c00017 	ldw	r3,0(r2)
 3233674:	e0bffd17 	ldw	r2,-12(fp)
 3233678:	10c0092e 	bgeu	r2,r3,32336a0 <ifd_get+0x4c>
      return set->fd_array[i];
 323367c:	e0bffd17 	ldw	r2,-12(fp)
 3233680:	e0fffe17 	ldw	r3,-8(fp)
 3233684:	1085883a 	add	r2,r2,r2
 3233688:	1085883a 	add	r2,r2,r2
 323368c:	10c5883a 	add	r2,r2,r3
 3233690:	10800104 	addi	r2,r2,4
 3233694:	10800017 	ldw	r2,0(r2)
 3233698:	e0bfff15 	stw	r2,-4(fp)
 323369c:	00000306 	br	32336ac <ifd_get+0x58>
   else
   {
#ifdef NPDEBUG
      dtrap();
 32336a0:	322aef00 	call	322aef0 <dtrap>
#endif
      return INVALID_SOCKET;
 32336a4:	00bfffc4 	movi	r2,-1
 32336a8:	e0bfff15 	stw	r2,-4(fp)
 32336ac:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 32336b0:	e037883a 	mov	sp,fp
 32336b4:	dfc00117 	ldw	ra,4(sp)
 32336b8:	df000017 	ldw	fp,0(sp)
 32336bc:	dec00204 	addi	sp,sp,8
 32336c0:	f800283a 	ret

032336c4 <tcp_reass>:

int
tcp_reass(struct tcpcb * tp, 
   struct tcpiphdr * ti,
   struct mbuf *  ti_mbuf)
{
 32336c4:	defff404 	addi	sp,sp,-48
 32336c8:	dfc00b15 	stw	ra,44(sp)
 32336cc:	df000a15 	stw	fp,40(sp)
 32336d0:	df000a04 	addi	fp,sp,40
 32336d4:	e13ffc15 	stw	r4,-16(fp)
 32336d8:	e17ffd15 	stw	r5,-12(fp)
 32336dc:	e1bffe15 	stw	r6,-8(fp)
   struct tcpiphdr * q;
   struct socket *   so =  tp->t_inpcb->inp_socket;
 32336e0:	e0bffc17 	ldw	r2,-16(fp)
 32336e4:	10800d17 	ldw	r2,52(r2)
 32336e8:	10800817 	ldw	r2,32(r2)
 32336ec:	e0bffa15 	stw	r2,-24(fp)

   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
 32336f0:	e0bffd17 	ldw	r2,-12(fp)
 32336f4:	1005003a 	cmpeq	r2,r2,zero
 32336f8:	10009c1e 	bne	r2,zero,323396c <tcp_reass+0x2a8>
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 32336fc:	e0bffc17 	ldw	r2,-16(fp)
 3233700:	10800017 	ldw	r2,0(r2)
 3233704:	e0bffb15 	stw	r2,-20(fp)
 3233708:	00000a06 	br	3233734 <tcp_reass+0x70>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
 323370c:	e0bffb17 	ldw	r2,-20(fp)
 3233710:	10c00617 	ldw	r3,24(r2)
 3233714:	e0bffd17 	ldw	r2,-12(fp)
 3233718:	10800617 	ldw	r2,24(r2)
 323371c:	1885c83a 	sub	r2,r3,r2
 3233720:	10800048 	cmpgei	r2,r2,1
 3233724:	1000061e 	bne	r2,zero,3233740 <tcp_reass+0x7c>

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
       q = (struct tcpiphdr *)q->ti_next)
 3233728:	e0bffb17 	ldw	r2,-20(fp)
 323372c:	10800017 	ldw	r2,0(r2)
 3233730:	e0bffb15 	stw	r2,-20(fp)
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 3233734:	e0fffc17 	ldw	r3,-16(fp)
 3233738:	e0bffb17 	ldw	r2,-20(fp)
 323373c:	10fff31e 	bne	r2,r3,323370c <tcp_reass+0x48>
   /*
    * If there is a preceding segment, it may provide some of
    * our data already.  If so, drop the data from the incoming
    * segment.  If it provides all of our data, drop us.
    */
   if ((struct tcpiphdr *)q->ti_prev != (struct tcpiphdr *)tp) 
 3233740:	e0bffb17 	ldw	r2,-20(fp)
 3233744:	10800117 	ldw	r2,4(r2)
 3233748:	1007883a 	mov	r3,r2
 323374c:	e0bffc17 	ldw	r2,-16(fp)
 3233750:	18803c26 	beq	r3,r2,3233844 <tcp_reass+0x180>
   {
      long  i;
      q = (struct tcpiphdr *)q->ti_prev;
 3233754:	e0bffb17 	ldw	r2,-20(fp)
 3233758:	10800117 	ldw	r2,4(r2)
 323375c:	e0bffb15 	stw	r2,-20(fp)
      /* conversion to int (in i) handles seq wraparound */
      i = q->ti_seq + q->ti_len - ti->ti_seq;
 3233760:	e0bffb17 	ldw	r2,-20(fp)
 3233764:	10c00617 	ldw	r3,24(r2)
 3233768:	e0bffb17 	ldw	r2,-20(fp)
 323376c:	1080028b 	ldhu	r2,10(r2)
 3233770:	10bfffcc 	andi	r2,r2,65535
 3233774:	1887883a 	add	r3,r3,r2
 3233778:	e0bffd17 	ldw	r2,-12(fp)
 323377c:	10800617 	ldw	r2,24(r2)
 3233780:	1885c83a 	sub	r2,r3,r2
 3233784:	e0bff715 	stw	r2,-36(fp)
      if (i > 0) 
 3233788:	e0bff717 	ldw	r2,-36(fp)
 323378c:	10800050 	cmplti	r2,r2,1
 3233790:	1000291e 	bne	r2,zero,3233838 <tcp_reass+0x174>
      {
         if (i >= (long)ti->ti_len) 
 3233794:	e0bffd17 	ldw	r2,-12(fp)
 3233798:	1080028b 	ldhu	r2,10(r2)
 323379c:	10ffffcc 	andi	r3,r2,65535
 32337a0:	e0bff717 	ldw	r2,-36(fp)
 32337a4:	10c01416 	blt	r2,r3,32337f8 <tcp_reass+0x134>
         {
            tcpstat.tcps_rcvduppack++;
 32337a8:	0080c9b4 	movhi	r2,806
 32337ac:	10b4b504 	addi	r2,r2,-11564
 32337b0:	10801f17 	ldw	r2,124(r2)
 32337b4:	10c00044 	addi	r3,r2,1
 32337b8:	0080c9b4 	movhi	r2,806
 32337bc:	10b4b504 	addi	r2,r2,-11564
 32337c0:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
 32337c4:	0080c9b4 	movhi	r2,806
 32337c8:	10b4b504 	addi	r2,r2,-11564
 32337cc:	10c02017 	ldw	r3,128(r2)
 32337d0:	e0bffd17 	ldw	r2,-12(fp)
 32337d4:	1080028b 	ldhu	r2,10(r2)
 32337d8:	10bfffcc 	andi	r2,r2,65535
 32337dc:	1887883a 	add	r3,r3,r2
 32337e0:	0080c9b4 	movhi	r2,806
 32337e4:	10b4b504 	addi	r2,r2,-11564
 32337e8:	10c02015 	stw	r3,128(r2)
            GOTO_DROP;
 32337ec:	008025c4 	movi	r2,151
 32337f0:	d0a8e915 	stw	r2,-23644(gp)
 32337f4:	0000ac06 	br	3233aa8 <tcp_reass+0x3e4>
         }
         m_adj (ti_mbuf, (int)i);
 32337f8:	e13ffe17 	ldw	r4,-8(fp)
 32337fc:	e17ff717 	ldw	r5,-36(fp)
 3233800:	322c3340 	call	322c334 <m_adj>
         ti->ti_len -= (short)i;
 3233804:	e0bffd17 	ldw	r2,-12(fp)
 3233808:	10c0028b 	ldhu	r3,10(r2)
 323380c:	e0bff717 	ldw	r2,-36(fp)
 3233810:	1885c83a 	sub	r2,r3,r2
 3233814:	1007883a 	mov	r3,r2
 3233818:	e0bffd17 	ldw	r2,-12(fp)
 323381c:	10c0028d 	sth	r3,10(r2)
         ti->ti_seq += (tcp_seq)i;
 3233820:	e0bffd17 	ldw	r2,-12(fp)
 3233824:	10c00617 	ldw	r3,24(r2)
 3233828:	e0bff717 	ldw	r2,-36(fp)
 323382c:	1887883a 	add	r3,r3,r2
 3233830:	e0bffd17 	ldw	r2,-12(fp)
 3233834:	10c00615 	stw	r3,24(r2)
      }
      q = (struct tcpiphdr *)(q->ti_next);
 3233838:	e0bffb17 	ldw	r2,-20(fp)
 323383c:	10800017 	ldw	r2,0(r2)
 3233840:	e0bffb15 	stw	r2,-20(fp)
   }
   tcpstat.tcps_rcvoopack++;
 3233844:	0080c9b4 	movhi	r2,806
 3233848:	10b4b504 	addi	r2,r2,-11564
 323384c:	10802317 	ldw	r2,140(r2)
 3233850:	10c00044 	addi	r3,r2,1
 3233854:	0080c9b4 	movhi	r2,806
 3233858:	10b4b504 	addi	r2,r2,-11564
 323385c:	10c02315 	stw	r3,140(r2)
   tcpstat.tcps_rcvoobyte += ti->ti_len;
 3233860:	0080c9b4 	movhi	r2,806
 3233864:	10b4b504 	addi	r2,r2,-11564
 3233868:	10c02417 	ldw	r3,144(r2)
 323386c:	e0bffd17 	ldw	r2,-12(fp)
 3233870:	1080028b 	ldhu	r2,10(r2)
 3233874:	10bfffcc 	andi	r2,r2,65535
 3233878:	1887883a 	add	r3,r3,r2
 323387c:	0080c9b4 	movhi	r2,806
 3233880:	10b4b504 	addi	r2,r2,-11564
 3233884:	10c02415 	stw	r3,144(r2)

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 3233888:	00003106 	br	3233950 <tcp_reass+0x28c>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
 323388c:	e0bffd17 	ldw	r2,-12(fp)
 3233890:	10c00617 	ldw	r3,24(r2)
 3233894:	e0bffd17 	ldw	r2,-12(fp)
 3233898:	1080028b 	ldhu	r2,10(r2)
 323389c:	10bfffcc 	andi	r2,r2,65535
 32338a0:	1887883a 	add	r3,r3,r2
 32338a4:	e0bffb17 	ldw	r2,-20(fp)
 32338a8:	10800617 	ldw	r2,24(r2)
 32338ac:	1885c83a 	sub	r2,r3,r2
 32338b0:	e0bff615 	stw	r2,-40(fp)
      if (i <= 0)
 32338b4:	e0bff617 	ldw	r2,-40(fp)
 32338b8:	10800050 	cmplti	r2,r2,1
 32338bc:	1000271e 	bne	r2,zero,323395c <tcp_reass+0x298>
         break;
      if (i < (int)(q->ti_len))
 32338c0:	e0bffb17 	ldw	r2,-20(fp)
 32338c4:	1080028b 	ldhu	r2,10(r2)
 32338c8:	10ffffcc 	andi	r3,r2,65535
 32338cc:	e0bff617 	ldw	r2,-40(fp)
 32338d0:	10c0130e 	bge	r2,r3,3233920 <tcp_reass+0x25c>
      {
         q->ti_seq += i;
 32338d4:	e0bffb17 	ldw	r2,-20(fp)
 32338d8:	10c00617 	ldw	r3,24(r2)
 32338dc:	e0bff617 	ldw	r2,-40(fp)
 32338e0:	1887883a 	add	r3,r3,r2
 32338e4:	e0bffb17 	ldw	r2,-20(fp)
 32338e8:	10c00615 	stw	r3,24(r2)
         q->ti_len -= (u_short)i;
 32338ec:	e0bffb17 	ldw	r2,-20(fp)
 32338f0:	10c0028b 	ldhu	r3,10(r2)
 32338f4:	e0bff617 	ldw	r2,-40(fp)
 32338f8:	1885c83a 	sub	r2,r3,r2
 32338fc:	1007883a 	mov	r3,r2
 3233900:	e0bffb17 	ldw	r2,-20(fp)
 3233904:	10c0028d 	sth	r3,10(r2)
         m_adj (dtom(q), (int)i);
 3233908:	e13ffb17 	ldw	r4,-20(fp)
 323390c:	322c55c0 	call	322c55c <dtom>
 3233910:	1009883a 	mov	r4,r2
 3233914:	e17ff617 	ldw	r5,-40(fp)
 3233918:	322c3340 	call	322c334 <m_adj>
         break;
 323391c:	00000f06 	br	323395c <tcp_reass+0x298>
      }
      q = (struct tcpiphdr *)q->ti_next;
 3233920:	e0bffb17 	ldw	r2,-20(fp)
 3233924:	10800017 	ldw	r2,0(r2)
 3233928:	e0bffb15 	stw	r2,-20(fp)
      m = dtom(q->ti_prev);
 323392c:	e0bffb17 	ldw	r2,-20(fp)
 3233930:	11000117 	ldw	r4,4(r2)
 3233934:	322c55c0 	call	322c55c <dtom>
 3233938:	e0bff915 	stw	r2,-28(fp)
      remque (q->ti_prev);
 323393c:	e0bffb17 	ldw	r2,-20(fp)
 3233940:	11000117 	ldw	r4,4(r2)
 3233944:	322c6040 	call	322c604 <remque>
      m_freem (m);
 3233948:	e13ff917 	ldw	r4,-28(fp)
 323394c:	322bfcc0 	call	322bfcc <m_freem>

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 3233950:	e0fffc17 	ldw	r3,-16(fp)
 3233954:	e0bffb17 	ldw	r2,-20(fp)
 3233958:	10ffcc1e 	bne	r2,r3,323388c <tcp_reass+0x1c8>
   }

   /*
    * Stick new segment in its place.
    */
   insque(ti, q->ti_prev);
 323395c:	e0bffb17 	ldw	r2,-20(fp)
 3233960:	11400117 	ldw	r5,4(r2)
 3233964:	e13ffd17 	ldw	r4,-12(fp)
 3233968:	322c6740 	call	322c674 <insque>
present:
   /*
    * Present data to user, advancing rcv_nxt through
    * completed sequence space.
    */
   if (TCPS_HAVERCVDSYN (tp->t_state) == 0)
 323396c:	e0bffc17 	ldw	r2,-16(fp)
 3233970:	10800217 	ldw	r2,8(r2)
 3233974:	108000c8 	cmpgei	r2,r2,3
 3233978:	1000021e 	bne	r2,zero,3233984 <tcp_reass+0x2c0>
      return (0);
 323397c:	e03fff15 	stw	zero,-4(fp)
 3233980:	00004c06 	br	3233ab4 <tcp_reass+0x3f0>
   ti = tp->seg_next;
 3233984:	e0bffc17 	ldw	r2,-16(fp)
 3233988:	10800017 	ldw	r2,0(r2)
 323398c:	e0bffd15 	stw	r2,-12(fp)
   if (ti == (struct tcpiphdr *)tp || ti->ti_seq != tp->rcv_nxt)
 3233990:	e0fffc17 	ldw	r3,-16(fp)
 3233994:	e0bffd17 	ldw	r2,-12(fp)
 3233998:	10c00526 	beq	r2,r3,32339b0 <tcp_reass+0x2ec>
 323399c:	e0bffd17 	ldw	r2,-12(fp)
 32339a0:	10c00617 	ldw	r3,24(r2)
 32339a4:	e0bffc17 	ldw	r2,-16(fp)
 32339a8:	10801617 	ldw	r2,88(r2)
 32339ac:	18800226 	beq	r3,r2,32339b8 <tcp_reass+0x2f4>
      return (0);
 32339b0:	e03fff15 	stw	zero,-4(fp)
 32339b4:	00003f06 	br	3233ab4 <tcp_reass+0x3f0>
   if (tp->t_state == TCPS_SYN_RECEIVED && ti->ti_len)
 32339b8:	e0bffc17 	ldw	r2,-16(fp)
 32339bc:	10800217 	ldw	r2,8(r2)
 32339c0:	108000d8 	cmpnei	r2,r2,3
 32339c4:	1000071e 	bne	r2,zero,32339e4 <tcp_reass+0x320>
 32339c8:	e0bffd17 	ldw	r2,-12(fp)
 32339cc:	1080028b 	ldhu	r2,10(r2)
 32339d0:	10bfffcc 	andi	r2,r2,65535
 32339d4:	1005003a 	cmpeq	r2,r2,zero
 32339d8:	1000021e 	bne	r2,zero,32339e4 <tcp_reass+0x320>
      return (0);
 32339dc:	e03fff15 	stw	zero,-4(fp)
 32339e0:	00003406 	br	3233ab4 <tcp_reass+0x3f0>
   do 
   {
      tp->rcv_nxt += ti->ti_len;
 32339e4:	e0bffc17 	ldw	r2,-16(fp)
 32339e8:	10c01617 	ldw	r3,88(r2)
 32339ec:	e0bffd17 	ldw	r2,-12(fp)
 32339f0:	1080028b 	ldhu	r2,10(r2)
 32339f4:	10bfffcc 	andi	r2,r2,65535
 32339f8:	1887883a 	add	r3,r3,r2
 32339fc:	e0bffc17 	ldw	r2,-16(fp)
 3233a00:	10c01615 	stw	r3,88(r2)
      flags = ti->ti_flags & TH_FIN;
 3233a04:	e0bffd17 	ldw	r2,-12(fp)
 3233a08:	10800843 	ldbu	r2,33(r2)
 3233a0c:	10803fcc 	andi	r2,r2,255
 3233a10:	1080004c 	andi	r2,r2,1
 3233a14:	e0bff815 	stw	r2,-32(fp)
      remque(ti);
 3233a18:	e13ffd17 	ldw	r4,-12(fp)
 3233a1c:	322c6040 	call	322c604 <remque>
      m = dtom(ti);
 3233a20:	e13ffd17 	ldw	r4,-12(fp)
 3233a24:	322c55c0 	call	322c55c <dtom>
 3233a28:	e0bff915 	stw	r2,-28(fp)
      ti = (struct tcpiphdr *)ti->ti_next;
 3233a2c:	e0bffd17 	ldw	r2,-12(fp)
 3233a30:	10800017 	ldw	r2,0(r2)
 3233a34:	e0bffd15 	stw	r2,-12(fp)
      if (so->so_state & SS_CANTRCVMORE)
 3233a38:	e0bffa17 	ldw	r2,-24(fp)
 3233a3c:	1080088b 	ldhu	r2,34(r2)
 3233a40:	10bfffcc 	andi	r2,r2,65535
 3233a44:	1080080c 	andi	r2,r2,32
 3233a48:	1005003a 	cmpeq	r2,r2,zero
 3233a4c:	1000031e 	bne	r2,zero,3233a5c <tcp_reass+0x398>
         m_freem (m);
 3233a50:	e13ff917 	ldw	r4,-28(fp)
 3233a54:	322bfcc0 	call	322bfcc <m_freem>
 3233a58:	00000406 	br	3233a6c <tcp_reass+0x3a8>
      else
         sbappend (&so->so_rcv, m);
 3233a5c:	e0bffa17 	ldw	r2,-24(fp)
 3233a60:	11000a04 	addi	r4,r2,40
 3233a64:	e17ff917 	ldw	r5,-28(fp)
 3233a68:	32324340 	call	3232434 <sbappend>
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
 3233a6c:	e0fffc17 	ldw	r3,-16(fp)
 3233a70:	e0bffd17 	ldw	r2,-12(fp)
 3233a74:	10c00526 	beq	r2,r3,3233a8c <tcp_reass+0x3c8>
 3233a78:	e0bffd17 	ldw	r2,-12(fp)
 3233a7c:	10c00617 	ldw	r3,24(r2)
 3233a80:	e0bffc17 	ldw	r2,-16(fp)
 3233a84:	10801617 	ldw	r2,88(r2)
 3233a88:	18bfd626 	beq	r3,r2,32339e4 <tcp_reass+0x320>
      sorwakeup(so);
 3233a8c:	e0bffa17 	ldw	r2,-24(fp)
 3233a90:	11400a04 	addi	r5,r2,40
 3233a94:	e13ffa17 	ldw	r4,-24(fp)
 3233a98:	32322700 	call	3232270 <sbwakeup>
   return (flags);
 3233a9c:	e0bff817 	ldw	r2,-32(fp)
 3233aa0:	e0bfff15 	stw	r2,-4(fp)
 3233aa4:	00000306 	br	3233ab4 <tcp_reass+0x3f0>
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
 3233aa8:	e13ffe17 	ldw	r4,-8(fp)
 3233aac:	322bfcc0 	call	322bfcc <m_freem>
   return (0);
 3233ab0:	e03fff15 	stw	zero,-4(fp)
 3233ab4:	e0bfff17 	ldw	r2,-4(fp)
}
 3233ab8:	e037883a 	mov	sp,fp
 3233abc:	dfc00117 	ldw	ra,4(sp)
 3233ac0:	df000017 	ldw	fp,0(sp)
 3233ac4:	dec00204 	addi	sp,sp,8
 3233ac8:	f800283a 	ret

03233acc <tcp_input>:
 * RETURNS: void
 */

void
tcp_input(struct mbuf * m, NET ifp)
{
 3233acc:	deffd004 	addi	sp,sp,-192
 3233ad0:	dfc02f15 	stw	ra,188(sp)
 3233ad4:	df002e15 	stw	fp,184(sp)
 3233ad8:	df002e04 	addi	fp,sp,184
 3233adc:	e13ff015 	stw	r4,-64(fp)
 3233ae0:	e17ff115 	stw	r5,-60(fp)
   ip6_addr    ip6_src;
   ip6_addr    ip6_dst;
#endif   /* IP_V6 */
   struct tcpiphdr * ti;
   struct inpcb * inp;
   struct mbuf *  om =  0;
 3233ae4:	e03feb15 	stw	zero,-84(fp)
   int   len,  tlen, off;
   struct tcpcb * tp =  0;
 3233ae8:	e03fe715 	stw	zero,-100(fp)
   int   tiflags;
   struct socket *   so =  NULL;
 3233aec:	e03fe515 	stw	zero,-108(fp)
   int   todrop,  acked,   ourfinisacked, needoutput  =  0;
 3233af0:	e03fe115 	stw	zero,-124(fp)
   int   dropsocket  =  0;
 3233af4:	e03fe015 	stw	zero,-128(fp)
   long  iss   =  0;
 3233af8:	e03fdf15 	stw	zero,-132(fp)
#ifdef DO_TCPTRACE
   int   ostate;
#endif


   tcpstat.tcps_rcvtotal++;
 3233afc:	0080c9b4 	movhi	r2,806
 3233b00:	10b4b504 	addi	r2,r2,-11564
 3233b04:	10801917 	ldw	r2,100(r2)
 3233b08:	10c00044 	addi	r3,r2,1
 3233b0c:	0080c9b4 	movhi	r2,806
 3233b10:	10b4b504 	addi	r2,r2,-11564
 3233b14:	10c01915 	stw	r3,100(r2)
   TCP_MIB_INC(tcpInSegs);    /* keep MIB stats */
 3233b18:	0080c9b4 	movhi	r2,806
 3233b1c:	10b48704 	addi	r2,r2,-11748
 3233b20:	10800917 	ldw	r2,36(r2)
 3233b24:	10c00044 	addi	r3,r2,1
 3233b28:	0080c9b4 	movhi	r2,806
 3233b2c:	10b48704 	addi	r2,r2,-11748
 3233b30:	10c00915 	stw	r3,36(r2)
   {
      /*
       * Get IP and TCP header together in first mbuf.
       * Note: IP leaves IP header in first mbuf.
       */
      pip = mtod(m, struct ip *);
 3233b34:	e0bff017 	ldw	r2,-64(fp)
 3233b38:	10800317 	ldw	r2,12(r2)
 3233b3c:	e0bfee15 	stw	r2,-72(fp)
      if (pip->ip_ver_ihl > 0x45)   /* IP v4, 5 dword hdr len */
 3233b40:	e0bfee17 	ldw	r2,-72(fp)
 3233b44:	10800003 	ldbu	r2,0(r2)
 3233b48:	10803fcc 	andi	r2,r2,255
 3233b4c:	108011b0 	cmpltui	r2,r2,70
 3233b50:	1000061e 	bne	r2,zero,3233b6c <tcp_input+0xa0>
      {
         np_stripoptions(pip, (struct mbuf *)m);
 3233b54:	e13fee17 	ldw	r4,-72(fp)
 3233b58:	e17ff017 	ldw	r5,-64(fp)
 3233b5c:	322d0380 	call	322d038 <np_stripoptions>
         pip = mtod(m, struct ip *);
 3233b60:	e0bff017 	ldw	r2,-64(fp)
 3233b64:	10800317 	ldw	r2,12(r2)
 3233b68:	e0bfee15 	stw	r2,-72(fp)
      }
      if (m->m_len < ((sizeof (struct ip) + sizeof (struct tcphdr))))
 3233b6c:	e0bff017 	ldw	r2,-64(fp)
 3233b70:	10800217 	ldw	r2,8(r2)
 3233b74:	10800a28 	cmpgeui	r2,r2,40
 3233b78:	1000081e 	bne	r2,zero,3233b9c <tcp_input+0xd0>
      {
         tcpstat.tcps_rcvshort++;
 3233b7c:	0080c9b4 	movhi	r2,806
 3233b80:	10b4b504 	addi	r2,r2,-11564
 3233b84:	10801e17 	ldw	r2,120(r2)
 3233b88:	10c00044 	addi	r3,r2,1
 3233b8c:	0080c9b4 	movhi	r2,806
 3233b90:	10b4b504 	addi	r2,r2,-11564
 3233b94:	10c01e15 	stw	r3,120(r2)
         return;
 3233b98:	00091c06 	br	323600c <tcp_input+0x2540>
      }
      tlen = pip->ip_len;     /* this was fudged by IP layer */
 3233b9c:	e0bfee17 	ldw	r2,-72(fp)
 3233ba0:	1080008b 	ldhu	r2,2(r2)
 3233ba4:	10bfffcc 	andi	r2,r2,65535
 3233ba8:	e0bfe915 	stw	r2,-92(fp)
      /* The following is needed in the cases where the size of the
       * overlay structure is larger than the size of the ip header.
       * This can happen if the ih_next and ih_prev pointers in the
       * overlay structure are larger than 32 bit pointers.
       */
      ti = (struct tcpiphdr *)(m->m_data + sizeof(struct ip) - 
 3233bac:	e0bff017 	ldw	r2,-64(fp)
 3233bb0:	10800317 	ldw	r2,12(r2)
 3233bb4:	e0bfed15 	stw	r2,-76(fp)
         sizeof(struct ipovly));
      if ((char *)ti < m->pkt->nb_buff)
 3233bb8:	e0bff017 	ldw	r2,-64(fp)
 3233bbc:	10800117 	ldw	r2,4(r2)
 3233bc0:	10c00117 	ldw	r3,4(r2)
 3233bc4:	e0bfed17 	ldw	r2,-76(fp)
 3233bc8:	10c0032e 	bgeu	r2,r3,3233bd8 <tcp_input+0x10c>
      {
         panic("tcp_input");
 3233bcc:	0100c974 	movhi	r4,805
 3233bd0:	213e5504 	addi	r4,r4,-1708
 3233bd4:	32261540 	call	3226154 <panic>
   /*
    * Check that TCP offset makes sense,
    * pull out TCP options and adjust length.
    */

   off = GET_TH_OFF(ti->ti_t) << 2;
 3233bd8:	e0bfed17 	ldw	r2,-76(fp)
 3233bdc:	10800803 	ldbu	r2,32(r2)
 3233be0:	10803fcc 	andi	r2,r2,255
 3233be4:	1004d13a 	srli	r2,r2,4
 3233be8:	10803fcc 	andi	r2,r2,255
 3233bec:	1085883a 	add	r2,r2,r2
 3233bf0:	1085883a 	add	r2,r2,r2
 3233bf4:	e0bfe815 	stw	r2,-96(fp)
   if (off < sizeof (struct tcphdr) || off > tlen) 
 3233bf8:	e0bfe817 	ldw	r2,-96(fp)
 3233bfc:	10800530 	cmpltui	r2,r2,20
 3233c00:	1000031e 	bne	r2,zero,3233c10 <tcp_input+0x144>
 3233c04:	e0ffe817 	ldw	r3,-96(fp)
 3233c08:	e0bfe917 	ldw	r2,-92(fp)
 3233c0c:	10c0110e 	bge	r2,r3,3233c54 <tcp_input+0x188>
   {
#ifdef DO_TCPTRACE
      tcp_trace("tcp off: src %x off %d\n", ti->ti_src, off);
#endif
      tcpstat.tcps_rcvbadoff++;
 3233c10:	0080c9b4 	movhi	r2,806
 3233c14:	10b4b504 	addi	r2,r2,-11564
 3233c18:	10801d17 	ldw	r2,116(r2)
 3233c1c:	10c00044 	addi	r3,r2,1
 3233c20:	0080c9b4 	movhi	r2,806
 3233c24:	10b4b504 	addi	r2,r2,-11564
 3233c28:	10c01d15 	stw	r3,116(r2)
      TCP_MIB_INC(tcpInErrs);   /* keep MIB stats */
 3233c2c:	0080c9b4 	movhi	r2,806
 3233c30:	10b48704 	addi	r2,r2,-11748
 3233c34:	10800d17 	ldw	r2,52(r2)
 3233c38:	10c00044 	addi	r3,r2,1
 3233c3c:	0080c9b4 	movhi	r2,806
 3233c40:	10b48704 	addi	r2,r2,-11748
 3233c44:	10c00d15 	stw	r3,52(r2)
      GOTO_DROP;
 3233c48:	00805784 	movi	r2,350
 3233c4c:	d0a8e915 	stw	r2,-23644(gp)
 3233c50:	0008e206 	br	3235fdc <tcp_input+0x2510>
   }
   tlen -= (int)off;
 3233c54:	e0ffe917 	ldw	r3,-92(fp)
 3233c58:	e0bfe817 	ldw	r2,-96(fp)
 3233c5c:	1885c83a 	sub	r2,r3,r2
 3233c60:	e0bfe915 	stw	r2,-92(fp)
   ti->ti_len = (u_short)tlen;
 3233c64:	e0bfe917 	ldw	r2,-92(fp)
 3233c68:	1007883a 	mov	r3,r2
 3233c6c:	e0bfed17 	ldw	r2,-76(fp)
 3233c70:	10c0028d 	sth	r3,10(r2)
   if (off > sizeof (struct tcphdr)) 
 3233c74:	e0bfe817 	ldw	r2,-96(fp)
 3233c78:	10800570 	cmpltui	r2,r2,21
 3233c7c:	1000341e 	bne	r2,zero,3233d50 <tcp_input+0x284>
   {
      int olen;      /* length of options field */
      u_char * op;   /* scratch option pointer */

      olen = off - sizeof (struct tcphdr);   /* get options length */
 3233c80:	e0bfe817 	ldw	r2,-96(fp)
 3233c84:	10bffb04 	addi	r2,r2,-20
 3233c88:	e0bfdd15 	stw	r2,-140(fp)
      om = m_getwithdata (MT_RXDATA, olen);  /* get mbuf for opts */
 3233c8c:	01000044 	movi	r4,1
 3233c90:	e17fdd17 	ldw	r5,-140(fp)
 3233c94:	322bcf00 	call	322bcf0 <m_getnbuf>
 3233c98:	e0bfeb15 	stw	r2,-84(fp)
      if (om == 0)
 3233c9c:	e0bfeb17 	ldw	r2,-84(fp)
 3233ca0:	1004c03a 	cmpne	r2,r2,zero
 3233ca4:	1000031e 	bne	r2,zero,3233cb4 <tcp_input+0x1e8>
         GOTO_DROP;
 3233ca8:	00805a84 	movi	r2,362
 3233cac:	d0a8e915 	stw	r2,-23644(gp)
 3233cb0:	0008ca06 	br	3235fdc <tcp_input+0x2510>
      om->m_len = olen;       /* set mbuf length */
 3233cb4:	e0ffdd17 	ldw	r3,-140(fp)
 3233cb8:	e0bfeb17 	ldw	r2,-84(fp)
 3233cbc:	10c00215 	stw	r3,8(r2)
      /* set pointer to options field at end of TCP header */
      if(m->pkt->type == htons(0x86DD))   /* IPv6 packet */
 3233cc0:	e0bff017 	ldw	r2,-64(fp)
 3233cc4:	10800117 	ldw	r2,4(r2)
 3233cc8:	1080080b 	ldhu	r2,32(r2)
 3233ccc:	10ffffcc 	andi	r3,r2,65535
 3233cd0:	00b76194 	movui	r2,56710
 3233cd4:	1880051e 	bne	r3,r2,3233cec <tcp_input+0x220>
         op = (u_char*)(m->m_data + 20);  /* past TCP header */
 3233cd8:	e0bff017 	ldw	r2,-64(fp)
 3233cdc:	10800317 	ldw	r2,12(r2)
 3233ce0:	10800504 	addi	r2,r2,20
 3233ce4:	e0bfdc15 	stw	r2,-144(fp)
 3233ce8:	00000406 	br	3233cfc <tcp_input+0x230>
      else
         op = (u_char*)(m->m_data + 40);  /* past IP + TCP */
 3233cec:	e0bff017 	ldw	r2,-64(fp)
 3233cf0:	10800317 	ldw	r2,12(r2)
 3233cf4:	10800a04 	addi	r2,r2,40
 3233cf8:	e0bfdc15 	stw	r2,-144(fp)
      MEMCPY(om->m_data, op, olen); /* copy to new mbuf */
 3233cfc:	e0bfeb17 	ldw	r2,-84(fp)
 3233d00:	10c00317 	ldw	r3,12(r2)
 3233d04:	e1bfdd17 	ldw	r6,-140(fp)
 3233d08:	e0bfdc17 	ldw	r2,-144(fp)
 3233d0c:	1809883a 	mov	r4,r3
 3233d10:	100b883a 	mov	r5,r2
 3233d14:	3206ad00 	call	3206ad0 <memcpy>

      /* strip options from data mbuf. This actually just cuts the first 
       * m_len bytes from the TCP header, but it leaves the mbuf members 
       * set so the adjustment below does the right thing.
       */
      m->m_data += om->m_len;
 3233d18:	e0bff017 	ldw	r2,-64(fp)
 3233d1c:	10c00317 	ldw	r3,12(r2)
 3233d20:	e0bfeb17 	ldw	r2,-84(fp)
 3233d24:	10800217 	ldw	r2,8(r2)
 3233d28:	1887883a 	add	r3,r3,r2
 3233d2c:	e0bff017 	ldw	r2,-64(fp)
 3233d30:	10c00315 	stw	r3,12(r2)
      m->m_len -= om->m_len;
 3233d34:	e0bff017 	ldw	r2,-64(fp)
 3233d38:	10c00217 	ldw	r3,8(r2)
 3233d3c:	e0bfeb17 	ldw	r2,-84(fp)
 3233d40:	10800217 	ldw	r2,8(r2)
 3233d44:	1887c83a 	sub	r3,r3,r2
 3233d48:	e0bff017 	ldw	r2,-64(fp)
 3233d4c:	10c00215 	stw	r3,8(r2)
   }
   tiflags = ti->ti_flags;
 3233d50:	e0bfed17 	ldw	r2,-76(fp)
 3233d54:	10800843 	ldbu	r2,33(r2)
 3233d58:	10803fcc 	andi	r2,r2,255
 3233d5c:	e0bfe615 	stw	r2,-104(fp)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   /* Convert TCP protocol specific fields to host format. */
   ti->ti_seq = ntohl(ti->ti_seq);
 3233d60:	e0bfed17 	ldw	r2,-76(fp)
 3233d64:	10800617 	ldw	r2,24(r2)
 3233d68:	1004d63a 	srli	r2,r2,24
 3233d6c:	10c03fcc 	andi	r3,r2,255
 3233d70:	e0bfed17 	ldw	r2,-76(fp)
 3233d74:	10800617 	ldw	r2,24(r2)
 3233d78:	1004d23a 	srli	r2,r2,8
 3233d7c:	10bfc00c 	andi	r2,r2,65280
 3233d80:	1886b03a 	or	r3,r3,r2
 3233d84:	e0bfed17 	ldw	r2,-76(fp)
 3233d88:	10800617 	ldw	r2,24(r2)
 3233d8c:	10bfc00c 	andi	r2,r2,65280
 3233d90:	1004923a 	slli	r2,r2,8
 3233d94:	1886b03a 	or	r3,r3,r2
 3233d98:	e0bfed17 	ldw	r2,-76(fp)
 3233d9c:	10800617 	ldw	r2,24(r2)
 3233da0:	10803fcc 	andi	r2,r2,255
 3233da4:	1004963a 	slli	r2,r2,24
 3233da8:	1886b03a 	or	r3,r3,r2
 3233dac:	e0bfed17 	ldw	r2,-76(fp)
 3233db0:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = ntohl(ti->ti_ack);
 3233db4:	e0bfed17 	ldw	r2,-76(fp)
 3233db8:	10800717 	ldw	r2,28(r2)
 3233dbc:	1004d63a 	srli	r2,r2,24
 3233dc0:	10c03fcc 	andi	r3,r2,255
 3233dc4:	e0bfed17 	ldw	r2,-76(fp)
 3233dc8:	10800717 	ldw	r2,28(r2)
 3233dcc:	1004d23a 	srli	r2,r2,8
 3233dd0:	10bfc00c 	andi	r2,r2,65280
 3233dd4:	1886b03a 	or	r3,r3,r2
 3233dd8:	e0bfed17 	ldw	r2,-76(fp)
 3233ddc:	10800717 	ldw	r2,28(r2)
 3233de0:	10bfc00c 	andi	r2,r2,65280
 3233de4:	1004923a 	slli	r2,r2,8
 3233de8:	1886b03a 	or	r3,r3,r2
 3233dec:	e0bfed17 	ldw	r2,-76(fp)
 3233df0:	10800717 	ldw	r2,28(r2)
 3233df4:	10803fcc 	andi	r2,r2,255
 3233df8:	1004963a 	slli	r2,r2,24
 3233dfc:	1886b03a 	or	r3,r3,r2
 3233e00:	e0bfed17 	ldw	r2,-76(fp)
 3233e04:	10c00715 	stw	r3,28(r2)
   ti->ti_urp = ntohs(ti->ti_urp);
 3233e08:	e0bfed17 	ldw	r2,-76(fp)
 3233e0c:	1080098b 	ldhu	r2,38(r2)
 3233e10:	10bfffcc 	andi	r2,r2,65535
 3233e14:	1004d23a 	srli	r2,r2,8
 3233e18:	10803fcc 	andi	r2,r2,255
 3233e1c:	1009883a 	mov	r4,r2
 3233e20:	e0bfed17 	ldw	r2,-76(fp)
 3233e24:	1080098b 	ldhu	r2,38(r2)
 3233e28:	10bfffcc 	andi	r2,r2,65535
 3233e2c:	1004923a 	slli	r2,r2,8
 3233e30:	1007883a 	mov	r3,r2
 3233e34:	00bfc004 	movi	r2,-256
 3233e38:	1884703a 	and	r2,r3,r2
 3233e3c:	2084b03a 	or	r2,r4,r2
 3233e40:	1007883a 	mov	r3,r2
 3233e44:	e0bfed17 	ldw	r2,-76(fp)
 3233e48:	10c0098d 	sth	r3,38(r2)
   /*
    * Locate pcb for segment.
    */
findpcb:

   switch(m->pkt->type)
 3233e4c:	e0bff017 	ldw	r2,-64(fp)
 3233e50:	10800117 	ldw	r2,4(r2)
 3233e54:	1080080b 	ldhu	r2,32(r2)
 3233e58:	10bfffcc 	andi	r2,r2,65535
 3233e5c:	10800220 	cmpeqi	r2,r2,8
 3233e60:	1000011e 	bne	r2,zero,3233e68 <tcp_input+0x39c>
 3233e64:	00001f06 	br	3233ee4 <tcp_input+0x418>
   {
#ifdef IP_V4
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
 3233e68:	e0bff017 	ldw	r2,-64(fp)
 3233e6c:	10800317 	ldw	r2,12(r2)
 3233e70:	10c00a04 	addi	r3,r2,40
 3233e74:	e0bff017 	ldw	r2,-64(fp)
 3233e78:	10c00315 	stw	r3,12(r2)
      m->m_len -= 40;
 3233e7c:	e0bff017 	ldw	r2,-64(fp)
 3233e80:	10800217 	ldw	r2,8(r2)
 3233e84:	10fff604 	addi	r3,r2,-40
 3233e88:	e0bff017 	ldw	r2,-64(fp)
 3233e8c:	10c00215 	stw	r3,8(r2)

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 3233e90:	e0bfed17 	ldw	r2,-76(fp)
 3233e94:	11400317 	ldw	r5,12(r2)
 3233e98:	e0bfed17 	ldw	r2,-76(fp)
 3233e9c:	1080050b 	ldhu	r2,20(r2)
 3233ea0:	11bfffcc 	andi	r6,r2,65535
 3233ea4:	e0bfed17 	ldw	r2,-76(fp)
 3233ea8:	11c00417 	ldw	r7,16(r2)
 3233eac:	e0bfed17 	ldw	r2,-76(fp)
 3233eb0:	1080058b 	ldhu	r2,22(r2)
 3233eb4:	10bfffcc 	andi	r2,r2,65535
 3233eb8:	d8800015 	stw	r2,0(sp)
 3233ebc:	00800044 	movi	r2,1
 3233ec0:	d8800115 	stw	r2,4(sp)
 3233ec4:	0100c9b4 	movhi	r4,806
 3233ec8:	2134aa04 	addi	r4,r4,-11608
 3233ecc:	32488880 	call	3248888 <in_pcblookup>
 3233ed0:	e0bfec15 	stw	r2,-80(fp)
    * If the state is CLOSED (i.e., TCB does not exist) then
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
 3233ed4:	e0bfec17 	ldw	r2,-80(fp)
 3233ed8:	1005003a 	cmpeq	r2,r2,zero
 3233edc:	1000031e 	bne	r2,zero,3233eec <tcp_input+0x420>
 3233ee0:	00000506 	br	3233ef8 <tcp_input+0x42c>
      inp = ip6_pcblookup(&tcb, &ip6_src, ti->ti_sport, 
         &ip6_dst, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
#endif   /* IP_V6 */
   default:
      dtrap();
 3233ee4:	322aef00 	call	322aef0 <dtrap>
      return;
 3233ee8:	00084806 	br	323600c <tcp_input+0x2540>
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
      GOTO_DROPWITHRESET;
 3233eec:	00806b04 	movi	r2,428
 3233ef0:	d0a8e915 	stw	r2,-23644(gp)
 3233ef4:	0007f506 	br	3235ecc <tcp_input+0x2400>
   tp = intotcpcb (inp);
 3233ef8:	e0bfec17 	ldw	r2,-80(fp)
 3233efc:	10800917 	ldw	r2,36(r2)
 3233f00:	e0bfe715 	stw	r2,-100(fp)
   if (tp == 0)
 3233f04:	e0bfe717 	ldw	r2,-100(fp)
 3233f08:	1004c03a 	cmpne	r2,r2,zero
 3233f0c:	1000031e 	bne	r2,zero,3233f1c <tcp_input+0x450>
      GOTO_DROPWITHRESET;
 3233f10:	00806bc4 	movi	r2,431
 3233f14:	d0a8e915 	stw	r2,-23644(gp)
 3233f18:	0007ec06 	br	3235ecc <tcp_input+0x2400>
   if (tp->t_state == TCPS_CLOSED)
 3233f1c:	e0bfe717 	ldw	r2,-100(fp)
 3233f20:	10800217 	ldw	r2,8(r2)
 3233f24:	1004c03a 	cmpne	r2,r2,zero
 3233f28:	1000031e 	bne	r2,zero,3233f38 <tcp_input+0x46c>
      GOTO_DROP;
 3233f2c:	00806c44 	movi	r2,433
 3233f30:	d0a8e915 	stw	r2,-23644(gp)
 3233f34:	00082906 	br	3235fdc <tcp_input+0x2510>
   so = inp->inp_socket;
 3233f38:	e0bfec17 	ldw	r2,-80(fp)
 3233f3c:	10800817 	ldw	r2,32(r2)
 3233f40:	e0bfe515 	stw	r2,-108(fp)
      tcp_saveti = *ti;
   }
#endif

   /* figure out the size of the other guy's receive window */
   rx_win = (tcp_win)(ntohs(ti->ti_win));    /* convert endian */
 3233f44:	e0bfed17 	ldw	r2,-76(fp)
 3233f48:	1080088b 	ldhu	r2,34(r2)
 3233f4c:	10bfffcc 	andi	r2,r2,65535
 3233f50:	1004d23a 	srli	r2,r2,8
 3233f54:	10bfffcc 	andi	r2,r2,65535
 3233f58:	10c03fcc 	andi	r3,r2,255
 3233f5c:	e0bfed17 	ldw	r2,-76(fp)
 3233f60:	1080088b 	ldhu	r2,34(r2)
 3233f64:	10bfffcc 	andi	r2,r2,65535
 3233f68:	1004923a 	slli	r2,r2,8
 3233f6c:	10bfc00c 	andi	r2,r2,65280
 3233f70:	1884b03a 	or	r2,r3,r2
 3233f74:	e0bfde15 	stw	r2,-136(fp)
   {
      rx_win <<= tp->snd_wind_scale;         /* apply scale */
   }
#endif /* TCP_WIN_SCALE */

   if (so->so_options & SO_ACCEPTCONN) 
 3233f78:	e0bfe517 	ldw	r2,-108(fp)
 3233f7c:	10800417 	ldw	r2,16(r2)
 3233f80:	1080008c 	andi	r2,r2,2
 3233f84:	1005003a 	cmpeq	r2,r2,zero
 3233f88:	10002d1e 	bne	r2,zero,3234040 <tcp_input+0x574>
   {
      so = sonewconn(so);
 3233f8c:	e13fe517 	ldw	r4,-108(fp)
 3233f90:	3231d480 	call	3231d48 <sonewconn>
 3233f94:	e0bfe515 	stw	r2,-108(fp)
      if (so == 0)
 3233f98:	e0bfe517 	ldw	r2,-108(fp)
 3233f9c:	1004c03a 	cmpne	r2,r2,zero
 3233fa0:	1000031e 	bne	r2,zero,3233fb0 <tcp_input+0x4e4>
         GOTO_DROP;
 3233fa4:	00807344 	movi	r2,461
 3233fa8:	d0a8e915 	stw	r2,-23644(gp)
 3233fac:	00080b06 	br	3235fdc <tcp_input+0x2510>
       * flag dropsocket to see if the temporary
       * socket created here should be discarded.
       * We mark the socket as discardable until
       * we're committed to it below in TCPS_LISTEN.
       */
      dropsocket++;
 3233fb0:	e0bfe017 	ldw	r2,-128(fp)
 3233fb4:	10800044 	addi	r2,r2,1
 3233fb8:	e0bfe015 	stw	r2,-128(fp)

      inp = (struct inpcb *)so->so_pcb;
 3233fbc:	e0bfe517 	ldw	r2,-108(fp)
 3233fc0:	10800117 	ldw	r2,4(r2)
 3233fc4:	e0bfec15 	stw	r2,-80(fp)
      inp->ifp = ifp;      /* save iface to peer */
 3233fc8:	e0ffec17 	ldw	r3,-80(fp)
 3233fcc:	e0bff117 	ldw	r2,-60(fp)
 3233fd0:	18800a15 	stw	r2,40(r3)

      switch(so->so_domain)
 3233fd4:	e0bfe517 	ldw	r2,-108(fp)
 3233fd8:	10800517 	ldw	r2,20(r2)
 3233fdc:	108000a0 	cmpeqi	r2,r2,2
 3233fe0:	1000011e 	bne	r2,zero,3233fe8 <tcp_input+0x51c>
 3233fe4:	00000c06 	br	3234018 <tcp_input+0x54c>
      {
#ifdef IP_V4
      case AF_INET:
         inp->inp_laddr = ti->ti_dst;
 3233fe8:	e0bfed17 	ldw	r2,-76(fp)
 3233fec:	10c00417 	ldw	r3,16(r2)
 3233ff0:	e0bfec17 	ldw	r2,-80(fp)
 3233ff4:	10c00415 	stw	r3,16(r2)
#ifdef IP_PMTU
         inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
         inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 3233ff8:	e0bff117 	ldw	r2,-60(fp)
 3233ffc:	10c00917 	ldw	r3,36(r2)
 3234000:	e0bff117 	ldw	r2,-60(fp)
 3234004:	10800817 	ldw	r2,32(r2)
 3234008:	1885c83a 	sub	r2,r3,r2
 323400c:	10fff604 	addi	r3,r2,-40
 3234010:	e0bfec17 	ldw	r2,-80(fp)
 3234014:	10c00615 	stw	r3,24(r2)
         inp->inp_pmtu = ip6_pmtulookup(&ip6_src, ifp);
         break;
#endif   /* end v6 */
      }

      inp->inp_lport = ti->ti_dport;
 3234018:	e0bfed17 	ldw	r2,-76(fp)
 323401c:	10c0058b 	ldhu	r3,22(r2)
 3234020:	e0bfec17 	ldw	r2,-80(fp)
 3234024:	10c0078d 	sth	r3,30(r2)
      tp = intotcpcb(inp);
 3234028:	e0bfec17 	ldw	r2,-80(fp)
 323402c:	10800917 	ldw	r2,36(r2)
 3234030:	e0bfe715 	stw	r2,-100(fp)
      tp->t_state = TCPS_LISTEN;
 3234034:	e0ffe717 	ldw	r3,-100(fp)
 3234038:	00800044 	movi	r2,1
 323403c:	18800215 	stw	r2,8(r3)

   /*
    * Segment received on connection.
    * Reset idle time and keep-alive timer.
    */
   tp->t_idle = 0;
 3234040:	e0bfe717 	ldw	r2,-100(fp)
 3234044:	10001d15 	stw	zero,116(r2)
   tp->t_timer[TCPT_KEEP] = tcp_keepidle;
 3234048:	0080c974 	movhi	r2,805
 323404c:	108a9c04 	addi	r2,r2,10864
 3234050:	10c00017 	ldw	r3,0(r2)
 3234054:	e0bfe717 	ldw	r2,-100(fp)
 3234058:	10c00515 	stw	r3,20(r2)

   /*
    * Process options if not in LISTEN state,
    * else do it below (after getting remote address).
    */
   if (om && tp->t_state != TCPS_LISTEN) 
 323405c:	e0bfeb17 	ldw	r2,-84(fp)
 3234060:	1005003a 	cmpeq	r2,r2,zero
 3234064:	1000091e 	bne	r2,zero,323408c <tcp_input+0x5c0>
 3234068:	e0bfe717 	ldw	r2,-100(fp)
 323406c:	10800217 	ldw	r2,8(r2)
 3234070:	10800060 	cmpeqi	r2,r2,1
 3234074:	1000051e 	bne	r2,zero,323408c <tcp_input+0x5c0>
   {
      tcp_dooptions(tp, om, ti);
 3234078:	e13fe717 	ldw	r4,-100(fp)
 323407c:	e17feb17 	ldw	r5,-84(fp)
 3234080:	e1bfed17 	ldw	r6,-76(fp)
 3234084:	32360200 	call	3236020 <tcp_dooptions>
      om = 0;
 3234088:	e03feb15 	stw	zero,-84(fp)
   }

   acked = (int)(ti->ti_ack - tp->snd_una);
 323408c:	e0bfed17 	ldw	r2,-76(fp)
 3234090:	10c00717 	ldw	r3,28(r2)
 3234094:	e0bfe717 	ldw	r2,-100(fp)
 3234098:	10800e17 	ldw	r2,56(r2)
 323409c:	1885c83a 	sub	r2,r3,r2
 32340a0:	e0bfe315 	stw	r2,-116(fp)
    * Receive window is amount of space in rcv queue,
    * but not less than advertised window.
    */
   { long win;

      win = (long)sbspace(&so->so_rcv);
 32340a4:	e0bfe517 	ldw	r2,-108(fp)
 32340a8:	10800b17 	ldw	r2,44(r2)
 32340ac:	1007883a 	mov	r3,r2
 32340b0:	e0bfe517 	ldw	r2,-108(fp)
 32340b4:	10800a17 	ldw	r2,40(r2)
 32340b8:	1885c83a 	sub	r2,r3,r2
 32340bc:	1004803a 	cmplt	r2,r2,zero
 32340c0:	1000071e 	bne	r2,zero,32340e0 <tcp_input+0x614>
 32340c4:	e0bfe517 	ldw	r2,-108(fp)
 32340c8:	10c00b17 	ldw	r3,44(r2)
 32340cc:	e0bfe517 	ldw	r2,-108(fp)
 32340d0:	10800a17 	ldw	r2,40(r2)
 32340d4:	1885c83a 	sub	r2,r3,r2
 32340d8:	e0bffd15 	stw	r2,-12(fp)
 32340dc:	00000106 	br	32340e4 <tcp_input+0x618>
 32340e0:	e03ffd15 	stw	zero,-12(fp)
 32340e4:	e0bffd17 	ldw	r2,-12(fp)
 32340e8:	e0bfdb15 	stw	r2,-148(fp)
      if (win < 0)
 32340ec:	e0bfdb17 	ldw	r2,-148(fp)
 32340f0:	1004403a 	cmpge	r2,r2,zero
 32340f4:	1000011e 	bne	r2,zero,32340fc <tcp_input+0x630>
         win = 0;
 32340f8:	e03fdb15 	stw	zero,-148(fp)
      tp->rcv_wnd = (tcp_win)MAX((u_long)win, (tp->rcv_adv - tp->rcv_nxt));
 32340fc:	e0bfe717 	ldw	r2,-100(fp)
 3234100:	10c01917 	ldw	r3,100(r2)
 3234104:	e0bfe717 	ldw	r2,-100(fp)
 3234108:	10801617 	ldw	r2,88(r2)
 323410c:	1885c83a 	sub	r2,r3,r2
 3234110:	e0ffdb17 	ldw	r3,-148(fp)
 3234114:	e0fffc15 	stw	r3,-16(fp)
 3234118:	e0bffb15 	stw	r2,-20(fp)
 323411c:	e13ffb17 	ldw	r4,-20(fp)
 3234120:	e0bffc17 	ldw	r2,-16(fp)
 3234124:	2080022e 	bgeu	r4,r2,3234130 <tcp_input+0x664>
 3234128:	e0fffc17 	ldw	r3,-16(fp)
 323412c:	e0fffb15 	stw	r3,-20(fp)
 3234130:	e0bfe717 	ldw	r2,-100(fp)
 3234134:	e13ffb17 	ldw	r4,-20(fp)
 3234138:	11001515 	stw	r4,84(r2)
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 323413c:	e0bfe717 	ldw	r2,-100(fp)
 3234140:	10800217 	ldw	r2,8(r2)
 3234144:	10800118 	cmpnei	r2,r2,4
 3234148:	10010f1e 	bne	r2,zero,3234588 <tcp_input+0xabc>
 323414c:	e0bfe617 	ldw	r2,-104(fp)
 3234150:	10800dcc 	andi	r2,r2,55
 3234154:	10800418 	cmpnei	r2,r2,16
 3234158:	10010b1e 	bne	r2,zero,3234588 <tcp_input+0xabc>
 323415c:	e0bfed17 	ldw	r2,-76(fp)
 3234160:	10c00617 	ldw	r3,24(r2)
 3234164:	e0bfe717 	ldw	r2,-100(fp)
 3234168:	10801617 	ldw	r2,88(r2)
 323416c:	1881061e 	bne	r3,r2,3234588 <tcp_input+0xabc>
 3234170:	e0bfde17 	ldw	r2,-136(fp)
 3234174:	1005003a 	cmpeq	r2,r2,zero
 3234178:	1001031e 	bne	r2,zero,3234588 <tcp_input+0xabc>
 323417c:	e0bfe717 	ldw	r2,-100(fp)
 3234180:	10c01417 	ldw	r3,80(r2)
 3234184:	e0bfde17 	ldw	r2,-136(fp)
 3234188:	1880ff1e 	bne	r3,r2,3234588 <tcp_input+0xabc>
 323418c:	e0bfe717 	ldw	r2,-100(fp)
 3234190:	10c00f17 	ldw	r3,60(r2)
 3234194:	e0bfe717 	ldw	r2,-100(fp)
 3234198:	10801a17 	ldw	r2,104(r2)
 323419c:	1880fa1e 	bne	r3,r2,3234588 <tcp_input+0xabc>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
       (rx_win && rx_win == tp->snd_wnd) &&
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
 32341a0:	e0bfed17 	ldw	r2,-76(fp)
 32341a4:	1080028b 	ldhu	r2,10(r2)
 32341a8:	10bfffcc 	andi	r2,r2,65535
 32341ac:	1004c03a 	cmpne	r2,r2,zero
 32341b0:	1000651e 	bne	r2,zero,3234348 <tcp_input+0x87c>
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 32341b4:	e0bfed17 	ldw	r2,-76(fp)
 32341b8:	10c00717 	ldw	r3,28(r2)
 32341bc:	e0bfe717 	ldw	r2,-100(fp)
 32341c0:	10800e17 	ldw	r2,56(r2)
 32341c4:	1885c83a 	sub	r2,r3,r2
 32341c8:	10800050 	cmplti	r2,r2,1
 32341cc:	1000ee1e 	bne	r2,zero,3234588 <tcp_input+0xabc>
 32341d0:	e0bfed17 	ldw	r2,-76(fp)
 32341d4:	10c00717 	ldw	r3,28(r2)
 32341d8:	e0bfe717 	ldw	r2,-100(fp)
 32341dc:	10801a17 	ldw	r2,104(r2)
 32341e0:	1885c83a 	sub	r2,r3,r2
 32341e4:	10800048 	cmpgei	r2,r2,1
 32341e8:	1000e71e 	bne	r2,zero,3234588 <tcp_input+0xabc>
 32341ec:	e0bfe717 	ldw	r2,-100(fp)
 32341f0:	10c01b17 	ldw	r3,108(r2)
 32341f4:	e0bfe717 	ldw	r2,-100(fp)
 32341f8:	10801417 	ldw	r2,80(r2)
 32341fc:	1880e236 	bltu	r3,r2,3234588 <tcp_input+0xabc>
             tp->snd_cwnd >= tp->snd_wnd) 
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
 3234200:	0080c9b4 	movhi	r2,806
 3234204:	10b4b504 	addi	r2,r2,-11564
 3234208:	10803517 	ldw	r2,212(r2)
 323420c:	10c00044 	addi	r3,r2,1
 3234210:	0080c9b4 	movhi	r2,806
 3234214:	10b4b504 	addi	r2,r2,-11564
 3234218:	10c03515 	stw	r3,212(r2)
            if (tp->t_rttick && 
 323421c:	e0bfe717 	ldw	r2,-100(fp)
 3234220:	10801e17 	ldw	r2,120(r2)
 3234224:	1005003a 	cmpeq	r2,r2,zero
 3234228:	1000091e 	bne	r2,zero,3234250 <tcp_input+0x784>
 323422c:	e0bfed17 	ldw	r2,-76(fp)
 3234230:	10c00717 	ldw	r3,28(r2)
 3234234:	e0bfe717 	ldw	r2,-100(fp)
 3234238:	10801f17 	ldw	r2,124(r2)
 323423c:	1885c83a 	sub	r2,r3,r2
 3234240:	10800050 	cmplti	r2,r2,1
 3234244:	1000021e 	bne	r2,zero,3234250 <tcp_input+0x784>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
            {
               tcp_xmit_timer(tp);
 3234248:	e13fe717 	ldw	r4,-100(fp)
 323424c:	32362dc0 	call	32362dc <tcp_xmit_timer>
            }

            tcpstat.tcps_rcvackpack++;
 3234250:	0080c9b4 	movhi	r2,806
 3234254:	10b4b504 	addi	r2,r2,-11564
 3234258:	10802b17 	ldw	r2,172(r2)
 323425c:	10c00044 	addi	r3,r2,1
 3234260:	0080c9b4 	movhi	r2,806
 3234264:	10b4b504 	addi	r2,r2,-11564
 3234268:	10c02b15 	stw	r3,172(r2)
            tcpstat.tcps_rcvackbyte += acked;
 323426c:	0080c9b4 	movhi	r2,806
 3234270:	10b4b504 	addi	r2,r2,-11564
 3234274:	10c02c17 	ldw	r3,176(r2)
 3234278:	e0bfe317 	ldw	r2,-116(fp)
 323427c:	1887883a 	add	r3,r3,r2
 3234280:	0080c9b4 	movhi	r2,806
 3234284:	10b4b504 	addi	r2,r2,-11564
 3234288:	10c02c15 	stw	r3,176(r2)
            sbdrop(&so->so_snd, acked);
 323428c:	e0bfe517 	ldw	r2,-108(fp)
 3234290:	11001204 	addi	r4,r2,72
 3234294:	e17fe317 	ldw	r5,-116(fp)
 3234298:	3232a3c0 	call	3232a3c <sbdrop>
            tp->snd_una = ti->ti_ack;
 323429c:	e0bfed17 	ldw	r2,-76(fp)
 32342a0:	10c00717 	ldw	r3,28(r2)
 32342a4:	e0bfe717 	ldw	r2,-100(fp)
 32342a8:	10c00e15 	stw	r3,56(r2)
            m_freem(m);
 32342ac:	e13ff017 	ldw	r4,-64(fp)
 32342b0:	322bfcc0 	call	322bfcc <m_freem>
             * If process is waiting for space,
             * wakeup/selwakeup/signal.  If data
             * are ready to send, let tcp_output
             * decide between more output or persist.
             */
            if (tp->snd_una == tp->snd_max)
 32342b4:	e0bfe717 	ldw	r2,-100(fp)
 32342b8:	10c00e17 	ldw	r3,56(r2)
 32342bc:	e0bfe717 	ldw	r2,-100(fp)
 32342c0:	10801a17 	ldw	r2,104(r2)
 32342c4:	1880031e 	bne	r3,r2,32342d4 <tcp_input+0x808>
               tp->t_timer[TCPT_REXMT] = 0;
 32342c8:	e0bfe717 	ldw	r2,-100(fp)
 32342cc:	10000315 	stw	zero,12(r2)
 32342d0:	00000806 	br	32342f4 <tcp_input+0x828>
            else if (tp->t_timer[TCPT_PERSIST] == 0)
 32342d4:	e0bfe717 	ldw	r2,-100(fp)
 32342d8:	10800417 	ldw	r2,16(r2)
 32342dc:	1004c03a 	cmpne	r2,r2,zero
 32342e0:	1000041e 	bne	r2,zero,32342f4 <tcp_input+0x828>
               tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 32342e4:	e0bfe717 	ldw	r2,-100(fp)
 32342e8:	10c00817 	ldw	r3,32(r2)
 32342ec:	e0bfe717 	ldw	r2,-100(fp)
 32342f0:	10c00315 	stw	r3,12(r2)

            if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 32342f4:	e0bfe517 	ldw	r2,-108(fp)
 32342f8:	1080190b 	ldhu	r2,100(r2)
 32342fc:	10bfffcc 	andi	r2,r2,65535
 3234300:	1080030c 	andi	r2,r2,12
 3234304:	1005003a 	cmpeq	r2,r2,zero
 3234308:	1000041e 	bne	r2,zero,323431c <tcp_input+0x850>
               sowwakeup(so);
 323430c:	e0bfe517 	ldw	r2,-108(fp)
 3234310:	11401204 	addi	r5,r2,72
 3234314:	e13fe517 	ldw	r4,-108(fp)
 3234318:	32322700 	call	3232270 <sbwakeup>

            /* If there is more data in the send buffer, and some is
             * still unsent, then call tcp_output() to try to send it
             */
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
 323431c:	e0bfe517 	ldw	r2,-108(fp)
 3234320:	11001217 	ldw	r4,72(r2)
 3234324:	e0bfe717 	ldw	r2,-100(fp)
 3234328:	10c00f17 	ldw	r3,60(r2)
 323432c:	e0bfe717 	ldw	r2,-100(fp)
 3234330:	10800e17 	ldw	r2,56(r2)
 3234334:	1885c83a 	sub	r2,r3,r2
 3234338:	1107342e 	bgeu	r2,r4,323600c <tcp_input+0x2540>
               (void) tcp_output(tp);
 323433c:	e13fe717 	ldw	r4,-100(fp)
 3234340:	32366ac0 	call	32366ac <tcp_output>
            return;
 3234344:	00073106 	br	323600c <tcp_input+0x2540>
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 3234348:	e0bfed17 	ldw	r2,-76(fp)
 323434c:	10c00717 	ldw	r3,28(r2)
 3234350:	e0bfe717 	ldw	r2,-100(fp)
 3234354:	10800e17 	ldw	r2,56(r2)
 3234358:	18808b1e 	bne	r3,r2,3234588 <tcp_input+0xabc>
 323435c:	e0bfe717 	ldw	r2,-100(fp)
 3234360:	10c00017 	ldw	r3,0(r2)
 3234364:	e0bfe717 	ldw	r2,-100(fp)
 3234368:	1880871e 	bne	r3,r2,3234588 <tcp_input+0xabc>
 323436c:	e0bfed17 	ldw	r2,-76(fp)
 3234370:	1080028b 	ldhu	r2,10(r2)
 3234374:	10bfffcc 	andi	r2,r2,65535
 3234378:	e0bffa15 	stw	r2,-24(fp)
 323437c:	e0bfe517 	ldw	r2,-108(fp)
 3234380:	10800b17 	ldw	r2,44(r2)
 3234384:	1007883a 	mov	r3,r2
 3234388:	e0bfe517 	ldw	r2,-108(fp)
 323438c:	10800a17 	ldw	r2,40(r2)
 3234390:	1885c83a 	sub	r2,r3,r2
 3234394:	1004803a 	cmplt	r2,r2,zero
 3234398:	1000071e 	bne	r2,zero,32343b8 <tcp_input+0x8ec>
 323439c:	e0bfe517 	ldw	r2,-108(fp)
 32343a0:	10c00b17 	ldw	r3,44(r2)
 32343a4:	e0bfe517 	ldw	r2,-108(fp)
 32343a8:	10800a17 	ldw	r2,40(r2)
 32343ac:	1887c83a 	sub	r3,r3,r2
 32343b0:	e0fff915 	stw	r3,-28(fp)
 32343b4:	00000106 	br	32343bc <tcp_input+0x8f0>
 32343b8:	e03ff915 	stw	zero,-28(fp)
 32343bc:	e0bff917 	ldw	r2,-28(fp)
 32343c0:	e0fffa17 	ldw	r3,-24(fp)
 32343c4:	10c07036 	bltu	r2,r3,3234588 <tcp_input+0xabc>
#endif   /* TCP_ZEROCOPY */

         /* this may also be a garden-variety probe received because
          * the socket sendbuf was full.
          */
         if(tp->rcv_wnd == 0)
 32343c8:	e0bfe717 	ldw	r2,-100(fp)
 32343cc:	10801517 	ldw	r2,84(r2)
 32343d0:	1004c03a 	cmpne	r2,r2,zero
 32343d4:	10000c1e 	bne	r2,zero,3234408 <tcp_input+0x93c>
             * info in this seg, but Windows NT 4.0 has a nasty bug where it
             * will hammer us mericilessly with these probes (one customer
             * reports thousands per second) so we just dump it ASAP to
             * save cycles.
             */
            tcpstat.tcps_rcvwinprobe++;
 32343d8:	0080c9b4 	movhi	r2,806
 32343dc:	10b4b504 	addi	r2,r2,-11564
 32343e0:	10802817 	ldw	r2,160(r2)
 32343e4:	10c00044 	addi	r3,r2,1
 32343e8:	0080c9b4 	movhi	r2,806
 32343ec:	10b4b504 	addi	r2,r2,-11564
 32343f0:	10c02815 	stw	r3,160(r2)
            m_freem (m);      /* free the received mbuf */
 32343f4:	e13ff017 	ldw	r4,-64(fp)
 32343f8:	322bfcc0 	call	322bfcc <m_freem>
            tcp_output(tp);   /* send the ack now... */
 32343fc:	e13fe717 	ldw	r4,-100(fp)
 3234400:	32366ac0 	call	32366ac <tcp_output>
            return;
 3234404:	00070106 	br	323600c <tcp_input+0x2540>
         /*
          * this is a pure, in-sequence data packet
          * with nothing on the reassembly queue and
          * we have enough buffer space to take it.
          */
         ++tcpstat.tcps_preddat;
 3234408:	0080c9b4 	movhi	r2,806
 323440c:	10b4b504 	addi	r2,r2,-11564
 3234410:	10803617 	ldw	r2,216(r2)
 3234414:	10c00044 	addi	r3,r2,1
 3234418:	0080c9b4 	movhi	r2,806
 323441c:	10b4b504 	addi	r2,r2,-11564
 3234420:	10c03615 	stw	r3,216(r2)
         tp->rcv_nxt += ti->ti_len;
 3234424:	e0bfe717 	ldw	r2,-100(fp)
 3234428:	10c01617 	ldw	r3,88(r2)
 323442c:	e0bfed17 	ldw	r2,-76(fp)
 3234430:	1080028b 	ldhu	r2,10(r2)
 3234434:	10bfffcc 	andi	r2,r2,65535
 3234438:	1887883a 	add	r3,r3,r2
 323443c:	e0bfe717 	ldw	r2,-100(fp)
 3234440:	10c01615 	stw	r3,88(r2)
         tcpstat.tcps_rcvpack++;
 3234444:	0080c9b4 	movhi	r2,806
 3234448:	10b4b504 	addi	r2,r2,-11564
 323444c:	10801a17 	ldw	r2,104(r2)
 3234450:	10c00044 	addi	r3,r2,1
 3234454:	0080c9b4 	movhi	r2,806
 3234458:	10b4b504 	addi	r2,r2,-11564
 323445c:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 3234460:	0080c9b4 	movhi	r2,806
 3234464:	10b4b504 	addi	r2,r2,-11564
 3234468:	10c01b17 	ldw	r3,108(r2)
 323446c:	e0bfed17 	ldw	r2,-76(fp)
 3234470:	1080028b 	ldhu	r2,10(r2)
 3234474:	10bfffcc 	andi	r2,r2,65535
 3234478:	1887883a 	add	r3,r3,r2
 323447c:	0080c9b4 	movhi	r2,806
 3234480:	10b4b504 	addi	r2,r2,-11564
 3234484:	10c01b15 	stw	r3,108(r2)
         /*
          * Add data to socket buffer.
          */
         sbappend(&so->so_rcv, m);
 3234488:	e0bfe517 	ldw	r2,-108(fp)
 323448c:	11000a04 	addi	r4,r2,40
 3234490:	e17ff017 	ldw	r5,-64(fp)
 3234494:	32324340 	call	3232434 <sbappend>
         sorwakeup(so);
 3234498:	e0bfe517 	ldw	r2,-108(fp)
 323449c:	11400a04 	addi	r5,r2,40
 32344a0:	e13fe517 	ldw	r4,-108(fp)
 32344a4:	32322700 	call	3232270 <sbwakeup>
         /*
          * If this is a short packet, then ACK now - with Nagel
          *   congestion avoidance sender won't send more until
          *   he gets an ACK.
          */
         if (tiflags & TH_PUSH)
 32344a8:	e0bfe617 	ldw	r2,-104(fp)
 32344ac:	1080020c 	andi	r2,r2,8
 32344b0:	1005003a 	cmpeq	r2,r2,zero
 32344b4:	1000071e 	bne	r2,zero,32344d4 <tcp_input+0xa08>
            tp->t_flags |= TF_ACKNOW;
 32344b8:	e0bfe717 	ldw	r2,-100(fp)
 32344bc:	10800b0b 	ldhu	r2,44(r2)
 32344c0:	10800054 	ori	r2,r2,1
 32344c4:	1007883a 	mov	r3,r2
 32344c8:	e0bfe717 	ldw	r2,-100(fp)
 32344cc:	10c00b0d 	sth	r3,44(r2)
 32344d0:	00000606 	br	32344ec <tcp_input+0xa20>
         else
            tp->t_flags |= TF_DELACK;
 32344d4:	e0bfe717 	ldw	r2,-100(fp)
 32344d8:	10800b0b 	ldhu	r2,44(r2)
 32344dc:	10800094 	ori	r2,r2,2
 32344e0:	1007883a 	mov	r3,r2
 32344e4:	e0bfe717 	ldw	r2,-100(fp)
 32344e8:	10c00b0d 	sth	r3,44(r2)

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));
 32344ec:	e0bfe717 	ldw	r2,-100(fp)
 32344f0:	11001517 	ldw	r4,84(r2)
 32344f4:	e0bfe717 	ldw	r2,-100(fp)
 32344f8:	10c01917 	ldw	r3,100(r2)
 32344fc:	e0bfe717 	ldw	r2,-100(fp)
 3234500:	10801617 	ldw	r2,88(r2)
 3234504:	1885c83a 	sub	r2,r3,r2
 3234508:	2085c83a 	sub	r2,r4,r2
 323450c:	e0bfda15 	stw	r2,-152(fp)

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 3234510:	e0bfe717 	ldw	r2,-100(fp)
 3234514:	10800a0b 	ldhu	r2,40(r2)
 3234518:	10bfffcc 	andi	r2,r2,65535
 323451c:	1085883a 	add	r2,r2,r2
 3234520:	1007883a 	mov	r3,r2
 3234524:	e0bfda17 	ldw	r2,-152(fp)
 3234528:	10c0070e 	bge	r2,r3,3234548 <tcp_input+0xa7c>
 323452c:	e0bfe717 	ldw	r2,-100(fp)
 3234530:	10800b0b 	ldhu	r2,44(r2)
 3234534:	10bfffcc 	andi	r2,r2,65535
 3234538:	1080004c 	andi	r2,r2,1
 323453c:	10803fcc 	andi	r2,r2,255
 3234540:	1005003a 	cmpeq	r2,r2,zero
 3234544:	1006b11e 	bne	r2,zero,323600c <tcp_input+0x2540>
               tp->t_flags &= ~TF_ACKNOW;
               return;
            }
#endif   /* DO_DELAY_ACKS */

            tp->t_flags |= TF_ACKNOW;
 3234548:	e0bfe717 	ldw	r2,-100(fp)
 323454c:	10800b0b 	ldhu	r2,44(r2)
 3234550:	10800054 	ori	r2,r2,1
 3234554:	1007883a 	mov	r3,r2
 3234558:	e0bfe717 	ldw	r2,-100(fp)
 323455c:	10c00b0d 	sth	r3,44(r2)
            tp->t_flags &= ~TF_DELACK;
 3234560:	e0bfe717 	ldw	r2,-100(fp)
 3234564:	10c00b0b 	ldhu	r3,44(r2)
 3234568:	00bfff44 	movi	r2,-3
 323456c:	1884703a 	and	r2,r3,r2
 3234570:	1007883a 	mov	r3,r2
 3234574:	e0bfe717 	ldw	r2,-100(fp)
 3234578:	10c00b0d 	sth	r3,44(r2)
            tcp_output(tp);   /* send the ack now... */
 323457c:	e13fe717 	ldw	r4,-100(fp)
 3234580:	32366ac0 	call	32366ac <tcp_output>
         }

         return;
 3234584:	0006a106 	br	323600c <tcp_input+0x2540>
      }
   }

   switch (tp->t_state) 
 3234588:	e0bfe717 	ldw	r2,-100(fp)
 323458c:	10800217 	ldw	r2,8(r2)
 3234590:	e0bff815 	stw	r2,-32(fp)
 3234594:	e13ff817 	ldw	r4,-32(fp)
 3234598:	20800060 	cmpeqi	r2,r4,1
 323459c:	1000041e 	bne	r2,zero,32345b0 <tcp_input+0xae4>
 32345a0:	e0fff817 	ldw	r3,-32(fp)
 32345a4:	188000a0 	cmpeqi	r2,r3,2
 32345a8:	1000b91e 	bne	r2,zero,3234890 <tcp_input+0xdc4>
 32345ac:	00019806 	br	3234c10 <tcp_input+0x1144>
    */
   case TCPS_LISTEN: 
   {
         struct mbuf *  am;

         if (tiflags & TH_RST)
 32345b0:	e0bfe617 	ldw	r2,-104(fp)
 32345b4:	1080010c 	andi	r2,r2,4
 32345b8:	1005003a 	cmpeq	r2,r2,zero
 32345bc:	1000031e 	bne	r2,zero,32345cc <tcp_input+0xb00>
            GOTO_DROP;
 32345c0:	0080bec4 	movi	r2,763
 32345c4:	d0a8e915 	stw	r2,-23644(gp)
 32345c8:	00068406 	br	3235fdc <tcp_input+0x2510>
         if (tiflags & TH_ACK)
 32345cc:	e0bfe617 	ldw	r2,-104(fp)
 32345d0:	1080040c 	andi	r2,r2,16
 32345d4:	1005003a 	cmpeq	r2,r2,zero
 32345d8:	1000031e 	bne	r2,zero,32345e8 <tcp_input+0xb1c>
            GOTO_DROPWITHRESET;
 32345dc:	0080bf44 	movi	r2,765
 32345e0:	d0a8e915 	stw	r2,-23644(gp)
 32345e4:	00063906 	br	3235ecc <tcp_input+0x2400>
         if ((tiflags & TH_SYN) == 0)
 32345e8:	e0bfe617 	ldw	r2,-104(fp)
 32345ec:	1080008c 	andi	r2,r2,2
 32345f0:	1004c03a 	cmpne	r2,r2,zero
 32345f4:	1000031e 	bne	r2,zero,3234604 <tcp_input+0xb38>
            GOTO_DROP;
 32345f8:	0080bfc4 	movi	r2,767
 32345fc:	d0a8e915 	stw	r2,-23644(gp)
 3234600:	00067606 	br	3235fdc <tcp_input+0x2510>
         if(in_broadcast(ti->ti_dst.s_addr))
 3234604:	e0bfed17 	ldw	r2,-76(fp)
 3234608:	11000417 	ldw	r4,16(r2)
 323460c:	322cff80 	call	322cff8 <in_broadcast>
 3234610:	1005003a 	cmpeq	r2,r2,zero
 3234614:	1000031e 	bne	r2,zero,3234624 <tcp_input+0xb58>
            GOTO_DROP;
 3234618:	0080c044 	movi	r2,769
 323461c:	d0a8e915 	stw	r2,-23644(gp)
 3234620:	00066e06 	br	3235fdc <tcp_input+0x2510>
         am = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 3234624:	01000244 	movi	r4,9
 3234628:	01400404 	movi	r5,16
 323462c:	322bcf00 	call	322bcf0 <m_getnbuf>
 3234630:	e0bfd915 	stw	r2,-156(fp)
         if (am == NULL)
 3234634:	e0bfd917 	ldw	r2,-156(fp)
 3234638:	1004c03a 	cmpne	r2,r2,zero
 323463c:	1000031e 	bne	r2,zero,323464c <tcp_input+0xb80>
            GOTO_DROP;
 3234640:	0080c104 	movi	r2,772
 3234644:	d0a8e915 	stw	r2,-23644(gp)
 3234648:	00066406 	br	3235fdc <tcp_input+0x2510>

#ifdef IP_V4
         if(inp->inp_socket->so_domain == AF_INET)
 323464c:	e0bfec17 	ldw	r2,-80(fp)
 3234650:	10800817 	ldw	r2,32(r2)
 3234654:	10800517 	ldw	r2,20(r2)
 3234658:	10800098 	cmpnei	r2,r2,2
 323465c:	10002e1e 	bne	r2,zero,3234718 <tcp_input+0xc4c>
         {
         struct sockaddr_in * sin;
         am->m_len = sizeof (struct sockaddr_in);
 3234660:	e0ffd917 	ldw	r3,-156(fp)
 3234664:	00800404 	movi	r2,16
 3234668:	18800215 	stw	r2,8(r3)
         sin = mtod(am, struct sockaddr_in *);
 323466c:	e0bfd917 	ldw	r2,-156(fp)
 3234670:	10800317 	ldw	r2,12(r2)
 3234674:	e0bfd815 	stw	r2,-160(fp)
         sin->sin_family = AF_INET;
 3234678:	e0ffd817 	ldw	r3,-160(fp)
 323467c:	00800084 	movi	r2,2
 3234680:	1880000d 	sth	r2,0(r3)
         sin->sin_addr = ti->ti_src;
 3234684:	e0bfed17 	ldw	r2,-76(fp)
 3234688:	10c00317 	ldw	r3,12(r2)
 323468c:	e0bfd817 	ldw	r2,-160(fp)
 3234690:	10c00115 	stw	r3,4(r2)
         sin->sin_port = ti->ti_sport;
 3234694:	e0bfed17 	ldw	r2,-76(fp)
 3234698:	10c0050b 	ldhu	r3,20(r2)
 323469c:	e0bfd817 	ldw	r2,-160(fp)
 32346a0:	10c0008d 	sth	r3,2(r2)
         /* Assuming pcbconnect will work, we put the sender's address in 
          * the inp_laddr (after saving a local laddr copy). If the connect
          * fails we restore the inpcb before going to drop:
          */
         laddr = inp->inp_laddr;    /* save tmp laddr */
 32346a4:	e0bfec17 	ldw	r2,-80(fp)
 32346a8:	10800417 	ldw	r2,16(r2)
 32346ac:	e0bfef15 	stw	r2,-68(fp)
         if (inp->inp_laddr.s_addr == INADDR_ANY)
 32346b0:	e0bfec17 	ldw	r2,-80(fp)
 32346b4:	10800417 	ldw	r2,16(r2)
 32346b8:	1004c03a 	cmpne	r2,r2,zero
 32346bc:	1000041e 	bne	r2,zero,32346d0 <tcp_input+0xc04>
            inp->inp_laddr = ti->ti_dst;
 32346c0:	e0bfed17 	ldw	r2,-76(fp)
 32346c4:	10c00417 	ldw	r3,16(r2)
 32346c8:	e0bfec17 	ldw	r2,-80(fp)
 32346cc:	10c00415 	stw	r3,16(r2)
         if (in_pcbconnect (inp, am)) 
 32346d0:	e13fec17 	ldw	r4,-80(fp)
 32346d4:	e17fd917 	ldw	r5,-156(fp)
 32346d8:	32485200 	call	3248520 <in_pcbconnect>
 32346dc:	1005003a 	cmpeq	r2,r2,zero
 32346e0:	1000081e 	bne	r2,zero,3234704 <tcp_input+0xc38>
         {
            inp->inp_laddr = laddr;
 32346e4:	e0bfec17 	ldw	r2,-80(fp)
 32346e8:	e0ffef17 	ldw	r3,-68(fp)
 32346ec:	10c00415 	stw	r3,16(r2)
            (void) m_free(am);
 32346f0:	e13fd917 	ldw	r4,-156(fp)
 32346f4:	322be980 	call	322be98 <m_free>
            GOTO_DROP;
 32346f8:	0080c684 	movi	r2,794
 32346fc:	d0a8e915 	stw	r2,-23644(gp)
 3234700:	00063606 	br	3235fdc <tcp_input+0x2510>
         }
         
         inp->ifp = ifp;      /* set interface for conn.*/
 3234704:	e0ffec17 	ldw	r3,-80(fp)
 3234708:	e0bff117 	ldw	r2,-60(fp)
 323470c:	18800a15 	stw	r2,40(r3)
         
         (void) m_free (am);
 3234710:	e13fd917 	ldw	r4,-156(fp)
 3234714:	322be980 	call	322be98 <m_free>
            }
            (void) m_free(am);
         }
#endif   /* end v6 */

         tp->t_template = tcp_template(tp);
 3234718:	e13fe717 	ldw	r4,-100(fp)
 323471c:	3237a640 	call	3237a64 <tcp_template>
 3234720:	1007883a 	mov	r3,r2
 3234724:	e0bfe717 	ldw	r2,-100(fp)
 3234728:	10c00c15 	stw	r3,48(r2)
         if (tp->t_template == 0) 
 323472c:	e0bfe717 	ldw	r2,-100(fp)
 3234730:	10800c17 	ldw	r2,48(r2)
 3234734:	1004c03a 	cmpne	r2,r2,zero
 3234738:	1000071e 	bne	r2,zero,3234758 <tcp_input+0xc8c>
         {
            SETTP(tp, tcp_drop(tp, ENOBUFS));
 323473c:	e13fe717 	ldw	r4,-100(fp)
 3234740:	01401a44 	movi	r5,105
 3234744:	323811c0 	call	323811c <tcp_drop>
            dropsocket = 0;      /* socket is already gone */
 3234748:	e03fe015 	stw	zero,-128(fp)
            GOTO_DROP;
 323474c:	0080d1c4 	movi	r2,839
 3234750:	d0a8e915 	stw	r2,-23644(gp)
 3234754:	00062106 	br	3235fdc <tcp_input+0x2510>
         }
         if (om) 
 3234758:	e0bfeb17 	ldw	r2,-84(fp)
 323475c:	1005003a 	cmpeq	r2,r2,zero
 3234760:	1000051e 	bne	r2,zero,3234778 <tcp_input+0xcac>
         {
            tcp_dooptions(tp, om, ti);
 3234764:	e13fe717 	ldw	r4,-100(fp)
 3234768:	e17feb17 	ldw	r5,-84(fp)
 323476c:	e1bfed17 	ldw	r6,-76(fp)
 3234770:	32360200 	call	3236020 <tcp_dooptions>
            om = 0;
 3234774:	e03feb15 	stw	zero,-84(fp)
         }
         if (iss)
 3234778:	e0bfdf17 	ldw	r2,-132(fp)
 323477c:	1005003a 	cmpeq	r2,r2,zero
 3234780:	1000041e 	bne	r2,zero,3234794 <tcp_input+0xcc8>
            tp->iss = iss;
 3234784:	e0ffdf17 	ldw	r3,-132(fp)
 3234788:	e0bfe717 	ldw	r2,-100(fp)
 323478c:	10c01315 	stw	r3,76(r2)
 3234790:	00000506 	br	32347a8 <tcp_input+0xcdc>
         else
            tp->iss = tcp_iss;
 3234794:	0080c974 	movhi	r2,805
 3234798:	10934e04 	addi	r2,r2,19768
 323479c:	10c00017 	ldw	r3,0(r2)
 32347a0:	e0bfe717 	ldw	r2,-100(fp)
 32347a4:	10c01315 	stw	r3,76(r2)
         tcp_iss += (unsigned)(TCP_ISSINCR/2);
 32347a8:	0080c974 	movhi	r2,805
 32347ac:	10934e04 	addi	r2,r2,19768
 32347b0:	10c00017 	ldw	r3,0(r2)
 32347b4:	00be9fd4 	movui	r2,64127
 32347b8:	1887883a 	add	r3,r3,r2
 32347bc:	0080c974 	movhi	r2,805
 32347c0:	10934e04 	addi	r2,r2,19768
 32347c4:	10c00015 	stw	r3,0(r2)
         tp->irs = ti->ti_seq;
 32347c8:	e0bfed17 	ldw	r2,-76(fp)
 32347cc:	10c00617 	ldw	r3,24(r2)
 32347d0:	e0bfe717 	ldw	r2,-100(fp)
 32347d4:	10c01815 	stw	r3,96(r2)
         tcp_sendseqinit(tp);
 32347d8:	e0bfe717 	ldw	r2,-100(fp)
 32347dc:	10c01317 	ldw	r3,76(r2)
 32347e0:	e0bfe717 	ldw	r2,-100(fp)
 32347e4:	10c01015 	stw	r3,64(r2)
 32347e8:	e0bfe717 	ldw	r2,-100(fp)
 32347ec:	10c01017 	ldw	r3,64(r2)
 32347f0:	e0bfe717 	ldw	r2,-100(fp)
 32347f4:	10c01a15 	stw	r3,104(r2)
 32347f8:	e0bfe717 	ldw	r2,-100(fp)
 32347fc:	10c01a17 	ldw	r3,104(r2)
 3234800:	e0bfe717 	ldw	r2,-100(fp)
 3234804:	10c00f15 	stw	r3,60(r2)
 3234808:	e0bfe717 	ldw	r2,-100(fp)
 323480c:	10c00f17 	ldw	r3,60(r2)
 3234810:	e0bfe717 	ldw	r2,-100(fp)
 3234814:	10c00e15 	stw	r3,56(r2)
         tcp_rcvseqinit(tp);
 3234818:	e0bfe717 	ldw	r2,-100(fp)
 323481c:	10801817 	ldw	r2,96(r2)
 3234820:	10c00044 	addi	r3,r2,1
 3234824:	e0bfe717 	ldw	r2,-100(fp)
 3234828:	10c01615 	stw	r3,88(r2)
 323482c:	e0bfe717 	ldw	r2,-100(fp)
 3234830:	10c01617 	ldw	r3,88(r2)
 3234834:	e0bfe717 	ldw	r2,-100(fp)
 3234838:	10c01915 	stw	r3,100(r2)
         tp->t_flags |= TF_ACKNOW;
 323483c:	e0bfe717 	ldw	r2,-100(fp)
 3234840:	10800b0b 	ldhu	r2,44(r2)
 3234844:	10800054 	ori	r2,r2,1
 3234848:	1007883a 	mov	r3,r2
 323484c:	e0bfe717 	ldw	r2,-100(fp)
 3234850:	10c00b0d 	sth	r3,44(r2)
         tp->t_state = TCPS_SYN_RECEIVED;
 3234854:	e0ffe717 	ldw	r3,-100(fp)
 3234858:	008000c4 	movi	r2,3
 323485c:	18800215 	stw	r2,8(r3)
         tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 3234860:	e0ffe717 	ldw	r3,-100(fp)
 3234864:	00802584 	movi	r2,150
 3234868:	18800515 	stw	r2,20(r3)
         dropsocket = 0;      /* committed to socket */
 323486c:	e03fe015 	stw	zero,-128(fp)
         tcpstat.tcps_accepts++;
 3234870:	0080c9b4 	movhi	r2,806
 3234874:	10b4b504 	addi	r2,r2,-11564
 3234878:	10800117 	ldw	r2,4(r2)
 323487c:	10c00044 	addi	r3,r2,1
 3234880:	0080c9b4 	movhi	r2,806
 3234884:	10b4b504 	addi	r2,r2,-11564
 3234888:	10c00115 	stw	r3,4(r2)
         goto trimthenstep6;
 323488c:	00009d06 	br	3234b04 <tcp_input+0x1038>
    *   if SYN has been acked change to ESTABLISHED else SYN_RCVD state
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
 3234890:	e0ffec17 	ldw	r3,-80(fp)
 3234894:	e0bff117 	ldw	r2,-60(fp)
 3234898:	18800a15 	stw	r2,40(r3)
      if ((tiflags & TH_ACK) &&
 323489c:	e0bfe617 	ldw	r2,-104(fp)
 32348a0:	1080040c 	andi	r2,r2,16
 32348a4:	1005003a 	cmpeq	r2,r2,zero
 32348a8:	1000111e 	bne	r2,zero,32348f0 <tcp_input+0xe24>
 32348ac:	e0bfed17 	ldw	r2,-76(fp)
 32348b0:	10c00717 	ldw	r3,28(r2)
 32348b4:	e0bfe717 	ldw	r2,-100(fp)
 32348b8:	10801317 	ldw	r2,76(r2)
 32348bc:	1885c83a 	sub	r2,r3,r2
 32348c0:	10800050 	cmplti	r2,r2,1
 32348c4:	1000071e 	bne	r2,zero,32348e4 <tcp_input+0xe18>
 32348c8:	e0bfed17 	ldw	r2,-76(fp)
 32348cc:	10c00717 	ldw	r3,28(r2)
 32348d0:	e0bfe717 	ldw	r2,-100(fp)
 32348d4:	10801a17 	ldw	r2,104(r2)
 32348d8:	1885c83a 	sub	r2,r3,r2
 32348dc:	10800050 	cmplti	r2,r2,1
 32348e0:	1000031e 	bne	r2,zero,32348f0 <tcp_input+0xe24>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
          SEQ_GT(ti->ti_ack, tp->snd_max)))
      {
         GOTO_DROPWITHRESET;
 32348e4:	0080dc04 	movi	r2,880
 32348e8:	d0a8e915 	stw	r2,-23644(gp)
 32348ec:	00057706 	br	3235ecc <tcp_input+0x2400>
      }
      if (tiflags & TH_RST) 
 32348f0:	e0bfe617 	ldw	r2,-104(fp)
 32348f4:	1080010c 	andi	r2,r2,4
 32348f8:	1005003a 	cmpeq	r2,r2,zero
 32348fc:	10000a1e 	bne	r2,zero,3234928 <tcp_input+0xe5c>
      {
         if (tiflags & TH_ACK)
 3234900:	e0bfe617 	ldw	r2,-104(fp)
 3234904:	1080040c 	andi	r2,r2,16
 3234908:	1005003a 	cmpeq	r2,r2,zero
 323490c:	1000031e 	bne	r2,zero,323491c <tcp_input+0xe50>
            SETTP(tp, tcp_drop(tp, ECONNREFUSED));
 3234910:	e13fe717 	ldw	r4,-100(fp)
 3234914:	01401bc4 	movi	r5,111
 3234918:	323811c0 	call	323811c <tcp_drop>
         GOTO_DROP;
 323491c:	0080dd84 	movi	r2,886
 3234920:	d0a8e915 	stw	r2,-23644(gp)
 3234924:	0005ad06 	br	3235fdc <tcp_input+0x2510>
      }
      if ((tiflags & TH_SYN) == 0)
 3234928:	e0bfe617 	ldw	r2,-104(fp)
 323492c:	1080008c 	andi	r2,r2,2
 3234930:	1004c03a 	cmpne	r2,r2,zero
 3234934:	1000031e 	bne	r2,zero,3234944 <tcp_input+0xe78>
         GOTO_DROP;
 3234938:	0080de44 	movi	r2,889
 323493c:	d0a8e915 	stw	r2,-23644(gp)
 3234940:	0005a606 	br	3235fdc <tcp_input+0x2510>
      if (tiflags & TH_ACK) 
 3234944:	e0bfe617 	ldw	r2,-104(fp)
 3234948:	1080040c 	andi	r2,r2,16
 323494c:	1005003a 	cmpeq	r2,r2,zero
 3234950:	10000f1e 	bne	r2,zero,3234990 <tcp_input+0xec4>
      {
         tp->snd_una = ti->ti_ack;
 3234954:	e0bfed17 	ldw	r2,-76(fp)
 3234958:	10c00717 	ldw	r3,28(r2)
 323495c:	e0bfe717 	ldw	r2,-100(fp)
 3234960:	10c00e15 	stw	r3,56(r2)
         if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 3234964:	e0bfe717 	ldw	r2,-100(fp)
 3234968:	10c00f17 	ldw	r3,60(r2)
 323496c:	e0bfe717 	ldw	r2,-100(fp)
 3234970:	10800e17 	ldw	r2,56(r2)
 3234974:	1885c83a 	sub	r2,r3,r2
 3234978:	1004403a 	cmpge	r2,r2,zero
 323497c:	1000041e 	bne	r2,zero,3234990 <tcp_input+0xec4>
            tp->snd_nxt = tp->snd_una;
 3234980:	e0bfe717 	ldw	r2,-100(fp)
 3234984:	10c00e17 	ldw	r3,56(r2)
 3234988:	e0bfe717 	ldw	r2,-100(fp)
 323498c:	10c00f15 	stw	r3,60(r2)
      }
      tp->t_timer[TCPT_REXMT] = 0;
 3234990:	e0bfe717 	ldw	r2,-100(fp)
 3234994:	10000315 	stw	zero,12(r2)
      tp->irs = ti->ti_seq;
 3234998:	e0bfed17 	ldw	r2,-76(fp)
 323499c:	10c00617 	ldw	r3,24(r2)
 32349a0:	e0bfe717 	ldw	r2,-100(fp)
 32349a4:	10c01815 	stw	r3,96(r2)
      tcp_rcvseqinit(tp);
 32349a8:	e0bfe717 	ldw	r2,-100(fp)
 32349ac:	10801817 	ldw	r2,96(r2)
 32349b0:	10c00044 	addi	r3,r2,1
 32349b4:	e0bfe717 	ldw	r2,-100(fp)
 32349b8:	10c01615 	stw	r3,88(r2)
 32349bc:	e0bfe717 	ldw	r2,-100(fp)
 32349c0:	10c01617 	ldw	r3,88(r2)
 32349c4:	e0bfe717 	ldw	r2,-100(fp)
 32349c8:	10c01915 	stw	r3,100(r2)
      if (inp->inp_laddr.s_addr != ti->ti_dst.s_addr) 
 32349cc:	e0bfec17 	ldw	r2,-80(fp)
 32349d0:	10c00417 	ldw	r3,16(r2)
 32349d4:	e0bfed17 	ldw	r2,-76(fp)
 32349d8:	10800417 	ldw	r2,16(r2)
 32349dc:	18801926 	beq	r3,r2,3234a44 <tcp_input+0xf78>
          * the IP interface may have changed address since we sent our SYN
          * (e.g. PPP brings link up as a result of said SYN and gets new
          * address via IPCP); if so we need to update the inpcb and the
          * TCP header template with the new address.
          */
         if ((m->pkt->net != NULL)
 32349e0:	e0bff017 	ldw	r2,-64(fp)
 32349e4:	10800117 	ldw	r2,4(r2)
 32349e8:	10800617 	ldw	r2,24(r2)
 32349ec:	1005003a 	cmpeq	r2,r2,zero
 32349f0:	1000141e 	bne	r2,zero,3234a44 <tcp_input+0xf78>
 32349f4:	e0bff017 	ldw	r2,-64(fp)
 32349f8:	10800117 	ldw	r2,4(r2)
 32349fc:	10800617 	ldw	r2,24(r2)
 3234a00:	10c00a17 	ldw	r3,40(r2)
 3234a04:	e0bfed17 	ldw	r2,-76(fp)
 3234a08:	10800417 	ldw	r2,16(r2)
 3234a0c:	18800d1e 	bne	r3,r2,3234a44 <tcp_input+0xf78>
             && (m->pkt->net->n_ipaddr == ti->ti_dst.s_addr)) 
      /* send an ack */
         {
            inp->inp_laddr = ti->ti_dst;
 3234a10:	e0bfed17 	ldw	r2,-76(fp)
 3234a14:	10c00417 	ldw	r3,16(r2)
 3234a18:	e0bfec17 	ldw	r2,-80(fp)
 3234a1c:	10c00415 	stw	r3,16(r2)
            if (tp->t_template != NULL)
 3234a20:	e0bfe717 	ldw	r2,-100(fp)
 3234a24:	10800c17 	ldw	r2,48(r2)
 3234a28:	1005003a 	cmpeq	r2,r2,zero
 3234a2c:	1000051e 	bne	r2,zero,3234a44 <tcp_input+0xf78>
               tp->t_template->ti_src = ti->ti_dst;
 3234a30:	e0bfe717 	ldw	r2,-100(fp)
 3234a34:	10c00c17 	ldw	r3,48(r2)
 3234a38:	e0bfed17 	ldw	r2,-76(fp)
 3234a3c:	10800417 	ldw	r2,16(r2)
 3234a40:	18800315 	stw	r2,12(r3)
         }
      }
      tp->t_flags |= TF_ACKNOW;
 3234a44:	e0bfe717 	ldw	r2,-100(fp)
 3234a48:	10800b0b 	ldhu	r2,44(r2)
 3234a4c:	10800054 	ori	r2,r2,1
 3234a50:	1007883a 	mov	r3,r2
 3234a54:	e0bfe717 	ldw	r2,-100(fp)
 3234a58:	10c00b0d 	sth	r3,44(r2)
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 3234a5c:	e0bfe617 	ldw	r2,-104(fp)
 3234a60:	1080040c 	andi	r2,r2,16
 3234a64:	1005003a 	cmpeq	r2,r2,zero
 3234a68:	1000231e 	bne	r2,zero,3234af8 <tcp_input+0x102c>
 3234a6c:	e0bfe717 	ldw	r2,-100(fp)
 3234a70:	10c00e17 	ldw	r3,56(r2)
 3234a74:	e0bfe717 	ldw	r2,-100(fp)
 3234a78:	10801317 	ldw	r2,76(r2)
 3234a7c:	1885c83a 	sub	r2,r3,r2
 3234a80:	10800050 	cmplti	r2,r2,1
 3234a84:	10001c1e 	bne	r2,zero,3234af8 <tcp_input+0x102c>
      {
         tcpstat.tcps_connects++;
 3234a88:	0080c9b4 	movhi	r2,806
 3234a8c:	10b4b504 	addi	r2,r2,-11564
 3234a90:	10800217 	ldw	r2,8(r2)
 3234a94:	10c00044 	addi	r3,r2,1
 3234a98:	0080c9b4 	movhi	r2,806
 3234a9c:	10b4b504 	addi	r2,r2,-11564
 3234aa0:	10c00215 	stw	r3,8(r2)
         tp->t_state = TCPS_ESTABLISHED;
 3234aa4:	e0ffe717 	ldw	r3,-100(fp)
 3234aa8:	00800104 	movi	r2,4
 3234aac:	18800215 	stw	r2,8(r3)
         soisconnected (so);
 3234ab0:	e13fe517 	ldw	r4,-108(fp)
 3234ab4:	3231b040 	call	3231b04 <soisconnected>
         tp->t_maxseg = tcp_mss(so);
 3234ab8:	e13fe517 	ldw	r4,-108(fp)
 3234abc:	32365900 	call	3236590 <tcp_mss>
 3234ac0:	1007883a 	mov	r3,r2
 3234ac4:	e0bfe717 	ldw	r2,-100(fp)
 3234ac8:	10c00a0d 	sth	r3,40(r2)
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
 3234acc:	e13fe717 	ldw	r4,-100(fp)
 3234ad0:	000b883a 	mov	r5,zero
 3234ad4:	e1bff017 	ldw	r6,-64(fp)
 3234ad8:	32336c40 	call	32336c4 <tcp_reass>
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 3234adc:	e0bfe717 	ldw	r2,-100(fp)
 3234ae0:	10801e17 	ldw	r2,120(r2)
 3234ae4:	1005003a 	cmpeq	r2,r2,zero
 3234ae8:	1000061e 	bne	r2,zero,3234b04 <tcp_input+0x1038>
         {
            tcp_xmit_timer(tp);
 3234aec:	e13fe717 	ldw	r4,-100(fp)
 3234af0:	32362dc0 	call	32362dc <tcp_xmit_timer>
            if (tp->t_template != NULL)
               tp->t_template->ti_src = ti->ti_dst;
         }
      }
      tp->t_flags |= TF_ACKNOW;
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 3234af4:	00000306 	br	3234b04 <tcp_input+0x1038>
         if (tp->t_rttick) 
         {
            tcp_xmit_timer(tp);
         }
      } else
         tp->t_state = TCPS_SYN_RECEIVED;
 3234af8:	e0ffe717 	ldw	r3,-100(fp)
 3234afc:	008000c4 	movi	r2,3
 3234b00:	18800215 	stw	r2,8(r3)
      /*
       * Advance ti->ti_seq to correspond to first data byte.
       * If data, trim to stay within window,
       * dropping FIN if necessary.
       */
      ti->ti_seq++;
 3234b04:	e0bfed17 	ldw	r2,-76(fp)
 3234b08:	10800617 	ldw	r2,24(r2)
 3234b0c:	10c00044 	addi	r3,r2,1
 3234b10:	e0bfed17 	ldw	r2,-76(fp)
 3234b14:	10c00615 	stw	r3,24(r2)
      if ((tcp_win)ti->ti_len > tp->rcv_wnd) 
 3234b18:	e0bfed17 	ldw	r2,-76(fp)
 3234b1c:	1080028b 	ldhu	r2,10(r2)
 3234b20:	10ffffcc 	andi	r3,r2,65535
 3234b24:	e0bfe717 	ldw	r2,-100(fp)
 3234b28:	10801517 	ldw	r2,84(r2)
 3234b2c:	10c02e2e 	bgeu	r2,r3,3234be8 <tcp_input+0x111c>
      {
         todrop = ti->ti_len - (u_short)tp->rcv_wnd;
 3234b30:	e0bfed17 	ldw	r2,-76(fp)
 3234b34:	1080028b 	ldhu	r2,10(r2)
 3234b38:	10ffffcc 	andi	r3,r2,65535
 3234b3c:	e0bfe717 	ldw	r2,-100(fp)
 3234b40:	10801517 	ldw	r2,84(r2)
 3234b44:	10bfffcc 	andi	r2,r2,65535
 3234b48:	1885c83a 	sub	r2,r3,r2
 3234b4c:	e0bfe415 	stw	r2,-112(fp)
         /* XXX work around 4.2 m_adj bug */
         if (m->m_len) 
 3234b50:	e0bff017 	ldw	r2,-64(fp)
 3234b54:	10800217 	ldw	r2,8(r2)
 3234b58:	1005003a 	cmpeq	r2,r2,zero
 3234b5c:	1000051e 	bne	r2,zero,3234b74 <tcp_input+0x10a8>
         {
            m_adj(m, -todrop);
 3234b60:	e0bfe417 	ldw	r2,-112(fp)
 3234b64:	008bc83a 	sub	r5,zero,r2
 3234b68:	e13ff017 	ldw	r4,-64(fp)
 3234b6c:	322c3340 	call	322c334 <m_adj>
 3234b70:	00000506 	br	3234b88 <tcp_input+0x10bc>
         }
         else 
         {
            /* skip tcp/ip header in first mbuf */
            m_adj(m->m_next, -todrop);
 3234b74:	e0bff017 	ldw	r2,-64(fp)
 3234b78:	11000617 	ldw	r4,24(r2)
 3234b7c:	e0bfe417 	ldw	r2,-112(fp)
 3234b80:	008bc83a 	sub	r5,zero,r2
 3234b84:	322c3340 	call	322c334 <m_adj>
         }
         ti->ti_len = (u_short)tp->rcv_wnd;
 3234b88:	e0bfe717 	ldw	r2,-100(fp)
 3234b8c:	10801517 	ldw	r2,84(r2)
 3234b90:	1007883a 	mov	r3,r2
 3234b94:	e0bfed17 	ldw	r2,-76(fp)
 3234b98:	10c0028d 	sth	r3,10(r2)
         tiflags &= ~TH_FIN;
 3234b9c:	e0ffe617 	ldw	r3,-104(fp)
 3234ba0:	00bfff84 	movi	r2,-2
 3234ba4:	1884703a 	and	r2,r3,r2
 3234ba8:	e0bfe615 	stw	r2,-104(fp)
         tcpstat.tcps_rcvpackafterwin++;
 3234bac:	0080c9b4 	movhi	r2,806
 3234bb0:	10b4b504 	addi	r2,r2,-11564
 3234bb4:	10802517 	ldw	r2,148(r2)
 3234bb8:	10c00044 	addi	r3,r2,1
 3234bbc:	0080c9b4 	movhi	r2,806
 3234bc0:	10b4b504 	addi	r2,r2,-11564
 3234bc4:	10c02515 	stw	r3,148(r2)
         tcpstat.tcps_rcvbyteafterwin += todrop;
 3234bc8:	0080c9b4 	movhi	r2,806
 3234bcc:	10b4b504 	addi	r2,r2,-11564
 3234bd0:	10c02617 	ldw	r3,152(r2)
 3234bd4:	e0bfe417 	ldw	r2,-112(fp)
 3234bd8:	1887883a 	add	r3,r3,r2
 3234bdc:	0080c9b4 	movhi	r2,806
 3234be0:	10b4b504 	addi	r2,r2,-11564
 3234be4:	10c02615 	stw	r3,152(r2)
      }
      tp->snd_wl1 = ti->ti_seq - 1;
 3234be8:	e0bfed17 	ldw	r2,-76(fp)
 3234bec:	10800617 	ldw	r2,24(r2)
 3234bf0:	10ffffc4 	addi	r3,r2,-1
 3234bf4:	e0bfe717 	ldw	r2,-100(fp)
 3234bf8:	10c01115 	stw	r3,68(r2)
      tp->rcv_up = ti->ti_seq;
 3234bfc:	e0bfed17 	ldw	r2,-76(fp)
 3234c00:	10c00617 	ldw	r3,24(r2)
 3234c04:	e0bfe717 	ldw	r2,-100(fp)
 3234c08:	10c01715 	stw	r3,92(r2)
      goto step6;
 3234c0c:	00032406 	br	32358a0 <tcp_input+0x1dd4>
    * States other than LISTEN or SYN_SENT.
    * First check that at least some bytes of segment are within 
    * receive window.  If segment begins before rcv_nxt,
    * drop leading data (and SYN); if nothing left, just ack.
    */
   todrop = (int)(tp->rcv_nxt - ti->ti_seq);
 3234c10:	e0bfe717 	ldw	r2,-100(fp)
 3234c14:	10c01617 	ldw	r3,88(r2)
 3234c18:	e0bfed17 	ldw	r2,-76(fp)
 3234c1c:	10800617 	ldw	r2,24(r2)
 3234c20:	1885c83a 	sub	r2,r3,r2
 3234c24:	e0bfe415 	stw	r2,-112(fp)
   if (todrop > 0) 
 3234c28:	e0bfe417 	ldw	r2,-112(fp)
 3234c2c:	10800050 	cmplti	r2,r2,1
 3234c30:	1000971e 	bne	r2,zero,3234e90 <tcp_input+0x13c4>
   {
      if (tiflags & TH_SYN) 
 3234c34:	e0bfe617 	ldw	r2,-104(fp)
 3234c38:	1080008c 	andi	r2,r2,2
 3234c3c:	1005003a 	cmpeq	r2,r2,zero
 3234c40:	10001c1e 	bne	r2,zero,3234cb4 <tcp_input+0x11e8>
      {
         tiflags &= ~TH_SYN;
 3234c44:	e0ffe617 	ldw	r3,-104(fp)
 3234c48:	00bfff44 	movi	r2,-3
 3234c4c:	1884703a 	and	r2,r3,r2
 3234c50:	e0bfe615 	stw	r2,-104(fp)
         ti->ti_seq++;
 3234c54:	e0bfed17 	ldw	r2,-76(fp)
 3234c58:	10800617 	ldw	r2,24(r2)
 3234c5c:	10c00044 	addi	r3,r2,1
 3234c60:	e0bfed17 	ldw	r2,-76(fp)
 3234c64:	10c00615 	stw	r3,24(r2)
         if (ti->ti_urp > 1) 
 3234c68:	e0bfed17 	ldw	r2,-76(fp)
 3234c6c:	1080098b 	ldhu	r2,38(r2)
 3234c70:	10bfffcc 	andi	r2,r2,65535
 3234c74:	108000b0 	cmpltui	r2,r2,2
 3234c78:	1000071e 	bne	r2,zero,3234c98 <tcp_input+0x11cc>
            ti->ti_urp--;
 3234c7c:	e0bfed17 	ldw	r2,-76(fp)
 3234c80:	1080098b 	ldhu	r2,38(r2)
 3234c84:	10bfffc4 	addi	r2,r2,-1
 3234c88:	1007883a 	mov	r3,r2
 3234c8c:	e0bfed17 	ldw	r2,-76(fp)
 3234c90:	10c0098d 	sth	r3,38(r2)
 3234c94:	00000406 	br	3234ca8 <tcp_input+0x11dc>
         else
            tiflags &= ~TH_URG;
 3234c98:	e0bfe617 	ldw	r2,-104(fp)
 3234c9c:	00fff7c4 	movi	r3,-33
 3234ca0:	10c4703a 	and	r2,r2,r3
 3234ca4:	e0bfe615 	stw	r2,-104(fp)
         todrop--;
 3234ca8:	e0bfe417 	ldw	r2,-112(fp)
 3234cac:	10bfffc4 	addi	r2,r2,-1
 3234cb0:	e0bfe415 	stw	r2,-112(fp)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 3234cb4:	e0bfed17 	ldw	r2,-76(fp)
 3234cb8:	1080028b 	ldhu	r2,10(r2)
 3234cbc:	10ffffcc 	andi	r3,r2,65535
 3234cc0:	e0bfe417 	ldw	r2,-112(fp)
 3234cc4:	18800916 	blt	r3,r2,3234cec <tcp_input+0x1220>
 3234cc8:	e0bfed17 	ldw	r2,-76(fp)
 3234ccc:	1080028b 	ldhu	r2,10(r2)
 3234cd0:	10ffffcc 	andi	r3,r2,65535
 3234cd4:	e0bfe417 	ldw	r2,-112(fp)
 3234cd8:	18803a1e 	bne	r3,r2,3234dc4 <tcp_input+0x12f8>
 3234cdc:	e0bfe617 	ldw	r2,-104(fp)
 3234ce0:	1080004c 	andi	r2,r2,1
 3234ce4:	1004c03a 	cmpne	r2,r2,zero
 3234ce8:	1000361e 	bne	r2,zero,3234dc4 <tcp_input+0x12f8>
          ((todrop == (int)ti->ti_len) && 
          (tiflags&TH_FIN) == 0)) 
      {
         tcpstat.tcps_rcvduppack++;
 3234cec:	0080c9b4 	movhi	r2,806
 3234cf0:	10b4b504 	addi	r2,r2,-11564
 3234cf4:	10801f17 	ldw	r2,124(r2)
 3234cf8:	10c00044 	addi	r3,r2,1
 3234cfc:	0080c9b4 	movhi	r2,806
 3234d00:	10b4b504 	addi	r2,r2,-11564
 3234d04:	10c01f15 	stw	r3,124(r2)
         tcpstat.tcps_rcvdupbyte += ti->ti_len;
 3234d08:	0080c9b4 	movhi	r2,806
 3234d0c:	10b4b504 	addi	r2,r2,-11564
 3234d10:	10c02017 	ldw	r3,128(r2)
 3234d14:	e0bfed17 	ldw	r2,-76(fp)
 3234d18:	1080028b 	ldhu	r2,10(r2)
 3234d1c:	10bfffcc 	andi	r2,r2,65535
 3234d20:	1887883a 	add	r3,r3,r2
 3234d24:	0080c9b4 	movhi	r2,806
 3234d28:	10b4b504 	addi	r2,r2,-11564
 3234d2c:	10c02015 	stw	r3,128(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 3234d30:	e0bfe617 	ldw	r2,-104(fp)
 3234d34:	1080004c 	andi	r2,r2,1
 3234d38:	1080005c 	xori	r2,r2,1
 3234d3c:	10803fcc 	andi	r2,r2,255
 3234d40:	1004c03a 	cmpne	r2,r2,zero
 3234d44:	1000061e 	bne	r2,zero,3234d60 <tcp_input+0x1294>
 3234d48:	e0bfed17 	ldw	r2,-76(fp)
 3234d4c:	1080028b 	ldhu	r2,10(r2)
 3234d50:	10bfffcc 	andi	r2,r2,65535
 3234d54:	10c00044 	addi	r3,r2,1
 3234d58:	e0bfe417 	ldw	r2,-112(fp)
 3234d5c:	18800a26 	beq	r3,r2,3234d88 <tcp_input+0x12bc>
 3234d60:	e0bfe617 	ldw	r2,-104(fp)
 3234d64:	1080010c 	andi	r2,r2,4
 3234d68:	1005003a 	cmpeq	r2,r2,zero
 3234d6c:	1004451e 	bne	r2,zero,3235e84 <tcp_input+0x23b8>
 3234d70:	e0bfed17 	ldw	r2,-76(fp)
 3234d74:	10c00617 	ldw	r3,24(r2)
 3234d78:	e0bfe717 	ldw	r2,-100(fp)
 3234d7c:	10801617 	ldw	r2,88(r2)
 3234d80:	10bfffc4 	addi	r2,r2,-1
 3234d84:	18843f1e 	bne	r3,r2,3235e84 <tcp_input+0x23b8>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
         {
            todrop = ti->ti_len;
 3234d88:	e0bfed17 	ldw	r2,-76(fp)
 3234d8c:	1080028b 	ldhu	r2,10(r2)
 3234d90:	10bfffcc 	andi	r2,r2,65535
 3234d94:	e0bfe415 	stw	r2,-112(fp)
            tiflags &= ~TH_FIN;
 3234d98:	e0ffe617 	ldw	r3,-104(fp)
 3234d9c:	00bfff84 	movi	r2,-2
 3234da0:	1884703a 	and	r2,r3,r2
 3234da4:	e0bfe615 	stw	r2,-104(fp)
            tp->t_flags |= TF_ACKNOW;
 3234da8:	e0bfe717 	ldw	r2,-100(fp)
 3234dac:	10800b0b 	ldhu	r2,44(r2)
 3234db0:	10800054 	ori	r2,r2,1
 3234db4:	1007883a 	mov	r3,r2
 3234db8:	e0bfe717 	ldw	r2,-100(fp)
 3234dbc:	10c00b0d 	sth	r3,44(r2)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 3234dc0:	00000f06 	br	3234e00 <tcp_input+0x1334>
         else
            goto dropafterack;
      }
      else 
      {
         tcpstat.tcps_rcvpartduppack++;
 3234dc4:	0080c9b4 	movhi	r2,806
 3234dc8:	10b4b504 	addi	r2,r2,-11564
 3234dcc:	10802117 	ldw	r2,132(r2)
 3234dd0:	10c00044 	addi	r3,r2,1
 3234dd4:	0080c9b4 	movhi	r2,806
 3234dd8:	10b4b504 	addi	r2,r2,-11564
 3234ddc:	10c02115 	stw	r3,132(r2)
         tcpstat.tcps_rcvpartdupbyte += todrop;
 3234de0:	0080c9b4 	movhi	r2,806
 3234de4:	10b4b504 	addi	r2,r2,-11564
 3234de8:	10c02217 	ldw	r3,136(r2)
 3234dec:	e0bfe417 	ldw	r2,-112(fp)
 3234df0:	1887883a 	add	r3,r3,r2
 3234df4:	0080c9b4 	movhi	r2,806
 3234df8:	10b4b504 	addi	r2,r2,-11564
 3234dfc:	10c02215 	stw	r3,136(r2)
      }
      m_adj(m, todrop);
 3234e00:	e13ff017 	ldw	r4,-64(fp)
 3234e04:	e17fe417 	ldw	r5,-112(fp)
 3234e08:	322c3340 	call	322c334 <m_adj>
      ti->ti_seq += todrop;
 3234e0c:	e0bfed17 	ldw	r2,-76(fp)
 3234e10:	10c00617 	ldw	r3,24(r2)
 3234e14:	e0bfe417 	ldw	r2,-112(fp)
 3234e18:	1887883a 	add	r3,r3,r2
 3234e1c:	e0bfed17 	ldw	r2,-76(fp)
 3234e20:	10c00615 	stw	r3,24(r2)
      ti->ti_len -= (u_short)todrop;
 3234e24:	e0bfed17 	ldw	r2,-76(fp)
 3234e28:	10c0028b 	ldhu	r3,10(r2)
 3234e2c:	e0bfe417 	ldw	r2,-112(fp)
 3234e30:	1885c83a 	sub	r2,r3,r2
 3234e34:	1007883a 	mov	r3,r2
 3234e38:	e0bfed17 	ldw	r2,-76(fp)
 3234e3c:	10c0028d 	sth	r3,10(r2)
      if (ti->ti_urp > (u_short)todrop)
 3234e40:	e0bfed17 	ldw	r2,-76(fp)
 3234e44:	10c0098b 	ldhu	r3,38(r2)
 3234e48:	e0bfe417 	ldw	r2,-112(fp)
 3234e4c:	18ffffcc 	andi	r3,r3,65535
 3234e50:	10bfffcc 	andi	r2,r2,65535
 3234e54:	10c0082e 	bgeu	r2,r3,3234e78 <tcp_input+0x13ac>
         ti->ti_urp -= (u_short)todrop;
 3234e58:	e0bfed17 	ldw	r2,-76(fp)
 3234e5c:	10c0098b 	ldhu	r3,38(r2)
 3234e60:	e0bfe417 	ldw	r2,-112(fp)
 3234e64:	1885c83a 	sub	r2,r3,r2
 3234e68:	1007883a 	mov	r3,r2
 3234e6c:	e0bfed17 	ldw	r2,-76(fp)
 3234e70:	10c0098d 	sth	r3,38(r2)
 3234e74:	00000606 	br	3234e90 <tcp_input+0x13c4>
      else 
      {
         tiflags &= ~TH_URG;
 3234e78:	e0ffe617 	ldw	r3,-104(fp)
 3234e7c:	00bff7c4 	movi	r2,-33
 3234e80:	1884703a 	and	r2,r3,r2
 3234e84:	e0bfe615 	stw	r2,-104(fp)
         ti->ti_urp = 0;
 3234e88:	e0bfed17 	ldw	r2,-76(fp)
 3234e8c:	1000098d 	sth	zero,38(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 3234e90:	e0bfe517 	ldw	r2,-108(fp)
 3234e94:	1080088b 	ldhu	r2,34(r2)
 3234e98:	10bfffcc 	andi	r2,r2,65535
 3234e9c:	1080004c 	andi	r2,r2,1
 3234ea0:	10803fcc 	andi	r2,r2,255
 3234ea4:	1005003a 	cmpeq	r2,r2,zero
 3234ea8:	1000161e 	bne	r2,zero,3234f04 <tcp_input+0x1438>
 3234eac:	e0bfe717 	ldw	r2,-100(fp)
 3234eb0:	10800217 	ldw	r2,8(r2)
 3234eb4:	10800190 	cmplti	r2,r2,6
 3234eb8:	1000121e 	bne	r2,zero,3234f04 <tcp_input+0x1438>
 3234ebc:	e0bfed17 	ldw	r2,-76(fp)
 3234ec0:	1080028b 	ldhu	r2,10(r2)
 3234ec4:	10bfffcc 	andi	r2,r2,65535
 3234ec8:	1005003a 	cmpeq	r2,r2,zero
 3234ecc:	10000d1e 	bne	r2,zero,3234f04 <tcp_input+0x1438>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
   {
      tp = tcp_close(tp);
 3234ed0:	e13fe717 	ldw	r4,-100(fp)
 3234ed4:	32381c80 	call	32381c8 <tcp_close>
 3234ed8:	e0bfe715 	stw	r2,-100(fp)
      tcpstat.tcps_rcvafterclose++;
 3234edc:	0080c9b4 	movhi	r2,806
 3234ee0:	10b4b504 	addi	r2,r2,-11564
 3234ee4:	10802717 	ldw	r2,156(r2)
 3234ee8:	10c00044 	addi	r3,r2,1
 3234eec:	0080c9b4 	movhi	r2,806
 3234ef0:	10b4b504 	addi	r2,r2,-11564
 3234ef4:	10c02715 	stw	r3,156(r2)
      GOTO_DROPWITHRESET;
 3234ef8:	00810444 	movi	r2,1041
 3234efc:	d0a8e915 	stw	r2,-23644(gp)
 3234f00:	0003f206 	br	3235ecc <tcp_input+0x2400>

   /*
    * If segment ends after window, drop trailing data
    * (and PUSH and FIN); if nothing left, just ACK.
    */
   todrop = (int)((ti->ti_seq + (short)ti->ti_len) - (tp->rcv_nxt+tp->rcv_wnd));
 3234f04:	e0bfed17 	ldw	r2,-76(fp)
 3234f08:	10c00617 	ldw	r3,24(r2)
 3234f0c:	e0bfed17 	ldw	r2,-76(fp)
 3234f10:	1080028b 	ldhu	r2,10(r2)
 3234f14:	10bfffcc 	andi	r2,r2,65535
 3234f18:	10a0001c 	xori	r2,r2,32768
 3234f1c:	10a00004 	addi	r2,r2,-32768
 3234f20:	1889883a 	add	r4,r3,r2
 3234f24:	e0bfe717 	ldw	r2,-100(fp)
 3234f28:	10c01617 	ldw	r3,88(r2)
 3234f2c:	e0bfe717 	ldw	r2,-100(fp)
 3234f30:	10801517 	ldw	r2,84(r2)
 3234f34:	1885883a 	add	r2,r3,r2
 3234f38:	2085c83a 	sub	r2,r4,r2
 3234f3c:	e0bfe415 	stw	r2,-112(fp)
   if (todrop > 0) 
 3234f40:	e0bfe417 	ldw	r2,-112(fp)
 3234f44:	10800050 	cmplti	r2,r2,1
 3234f48:	10006b1e 	bne	r2,zero,32350f8 <tcp_input+0x162c>
   {
      tcpstat.tcps_rcvpackafterwin++;
 3234f4c:	0080c9b4 	movhi	r2,806
 3234f50:	10b4b504 	addi	r2,r2,-11564
 3234f54:	10802517 	ldw	r2,148(r2)
 3234f58:	10c00044 	addi	r3,r2,1
 3234f5c:	0080c9b4 	movhi	r2,806
 3234f60:	10b4b504 	addi	r2,r2,-11564
 3234f64:	10c02515 	stw	r3,148(r2)
      if (todrop >= (int)ti->ti_len) 
 3234f68:	e0bfed17 	ldw	r2,-76(fp)
 3234f6c:	1080028b 	ldhu	r2,10(r2)
 3234f70:	10ffffcc 	andi	r3,r2,65535
 3234f74:	e0bfe417 	ldw	r2,-112(fp)
 3234f78:	10c03e16 	blt	r2,r3,3235074 <tcp_input+0x15a8>
      {
         tcpstat.tcps_rcvbyteafterwin += ti->ti_len;
 3234f7c:	0080c9b4 	movhi	r2,806
 3234f80:	10b4b504 	addi	r2,r2,-11564
 3234f84:	10c02617 	ldw	r3,152(r2)
 3234f88:	e0bfed17 	ldw	r2,-76(fp)
 3234f8c:	1080028b 	ldhu	r2,10(r2)
 3234f90:	10bfffcc 	andi	r2,r2,65535
 3234f94:	1887883a 	add	r3,r3,r2
 3234f98:	0080c9b4 	movhi	r2,806
 3234f9c:	10b4b504 	addi	r2,r2,-11564
 3234fa0:	10c02615 	stw	r3,152(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 3234fa4:	e0bfe617 	ldw	r2,-104(fp)
 3234fa8:	1080008c 	andi	r2,r2,2
 3234fac:	1005003a 	cmpeq	r2,r2,zero
 3234fb0:	1000191e 	bne	r2,zero,3235018 <tcp_input+0x154c>
 3234fb4:	e0bfe717 	ldw	r2,-100(fp)
 3234fb8:	10800217 	ldw	r2,8(r2)
 3234fbc:	10800298 	cmpnei	r2,r2,10
 3234fc0:	1000151e 	bne	r2,zero,3235018 <tcp_input+0x154c>
 3234fc4:	e0bfed17 	ldw	r2,-76(fp)
 3234fc8:	10c00617 	ldw	r3,24(r2)
 3234fcc:	e0bfe717 	ldw	r2,-100(fp)
 3234fd0:	10801617 	ldw	r2,88(r2)
 3234fd4:	1885c83a 	sub	r2,r3,r2
 3234fd8:	10800050 	cmplti	r2,r2,1
 3234fdc:	10000e1e 	bne	r2,zero,3235018 <tcp_input+0x154c>
             tp->t_state == TCPS_TIME_WAIT &&
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
         {
            iss = (tcp_seq)(tp->rcv_nxt + (TCP_ISSINCR));
 3234fe0:	e0bfe717 	ldw	r2,-100(fp)
 3234fe4:	10c01617 	ldw	r3,88(r2)
 3234fe8:	008000b4 	movhi	r2,2
 3234fec:	10bd3fc4 	addi	r2,r2,-2817
 3234ff0:	1885883a 	add	r2,r3,r2
 3234ff4:	e0bfdf15 	stw	r2,-132(fp)
            if (iss & 0xff000000)
 3234ff8:	e0bfdf17 	ldw	r2,-132(fp)
 3234ffc:	10bfc02c 	andhi	r2,r2,65280
 3235000:	1005003a 	cmpeq	r2,r2,zero
 3235004:	1000011e 	bne	r2,zero,323500c <tcp_input+0x1540>
            {
               iss = 0L;
 3235008:	e03fdf15 	stw	zero,-132(fp)
            }
            (void) tcp_close(tp);
 323500c:	e13fe717 	ldw	r4,-100(fp)
 3235010:	32381c80 	call	32381c8 <tcp_close>
            goto findpcb;
 3235014:	003b8d06 	br	3233e4c <tcp_input+0x380>
          * window edge, and have to drop data and PUSH from
          * incoming segments.  Continue processing, but
          * remember to ack.  Otherwise, drop segment
          * and ack.
          */
         if ((tp->rcv_wnd == 0) && (ti->ti_seq == tp->rcv_nxt))
 3235018:	e0bfe717 	ldw	r2,-100(fp)
 323501c:	10801517 	ldw	r2,84(r2)
 3235020:	1004c03a 	cmpne	r2,r2,zero
 3235024:	1003971e 	bne	r2,zero,3235e84 <tcp_input+0x23b8>
 3235028:	e0bfed17 	ldw	r2,-76(fp)
 323502c:	10c00617 	ldw	r3,24(r2)
 3235030:	e0bfe717 	ldw	r2,-100(fp)
 3235034:	10801617 	ldw	r2,88(r2)
 3235038:	1883921e 	bne	r3,r2,3235e84 <tcp_input+0x23b8>
         {
            tp->t_flags |= TF_ACKNOW;
 323503c:	e0bfe717 	ldw	r2,-100(fp)
 3235040:	10800b0b 	ldhu	r2,44(r2)
 3235044:	10800054 	ori	r2,r2,1
 3235048:	1007883a 	mov	r3,r2
 323504c:	e0bfe717 	ldw	r2,-100(fp)
 3235050:	10c00b0d 	sth	r3,44(r2)
            tcpstat.tcps_rcvwinprobe++;
 3235054:	0080c9b4 	movhi	r2,806
 3235058:	10b4b504 	addi	r2,r2,-11564
 323505c:	10802817 	ldw	r2,160(r2)
 3235060:	10c00044 	addi	r3,r2,1
 3235064:	0080c9b4 	movhi	r2,806
 3235068:	10b4b504 	addi	r2,r2,-11564
 323506c:	10c02815 	stw	r3,160(r2)
 3235070:	00000806 	br	3235094 <tcp_input+0x15c8>
         } else
            goto dropafterack;
      } else
         tcpstat.tcps_rcvbyteafterwin += todrop;
 3235074:	0080c9b4 	movhi	r2,806
 3235078:	10b4b504 	addi	r2,r2,-11564
 323507c:	10c02617 	ldw	r3,152(r2)
 3235080:	e0bfe417 	ldw	r2,-112(fp)
 3235084:	1887883a 	add	r3,r3,r2
 3235088:	0080c9b4 	movhi	r2,806
 323508c:	10b4b504 	addi	r2,r2,-11564
 3235090:	10c02615 	stw	r3,152(r2)
      /* XXX work around m_adj bug */
      if (m->m_len) 
 3235094:	e0bff017 	ldw	r2,-64(fp)
 3235098:	10800217 	ldw	r2,8(r2)
 323509c:	1005003a 	cmpeq	r2,r2,zero
 32350a0:	1000051e 	bne	r2,zero,32350b8 <tcp_input+0x15ec>
      {
         m_adj(m, -todrop);
 32350a4:	e0bfe417 	ldw	r2,-112(fp)
 32350a8:	008bc83a 	sub	r5,zero,r2
 32350ac:	e13ff017 	ldw	r4,-64(fp)
 32350b0:	322c3340 	call	322c334 <m_adj>
 32350b4:	00000506 	br	32350cc <tcp_input+0x1600>
      }
      else 
      {
         /* skip tcp/ip header in first mbuf */
         m_adj(m->m_next, -todrop);
 32350b8:	e0bff017 	ldw	r2,-64(fp)
 32350bc:	11000617 	ldw	r4,24(r2)
 32350c0:	e0bfe417 	ldw	r2,-112(fp)
 32350c4:	008bc83a 	sub	r5,zero,r2
 32350c8:	322c3340 	call	322c334 <m_adj>
      }
      ti->ti_len -= (u_short)todrop;
 32350cc:	e0bfed17 	ldw	r2,-76(fp)
 32350d0:	10c0028b 	ldhu	r3,10(r2)
 32350d4:	e0bfe417 	ldw	r2,-112(fp)
 32350d8:	1885c83a 	sub	r2,r3,r2
 32350dc:	1007883a 	mov	r3,r2
 32350e0:	e0bfed17 	ldw	r2,-76(fp)
 32350e4:	10c0028d 	sth	r3,10(r2)
      tiflags &= ~(TH_PUSH|TH_FIN);
 32350e8:	e0ffe617 	ldw	r3,-104(fp)
 32350ec:	00bffd84 	movi	r2,-10
 32350f0:	1884703a 	and	r2,r3,r2
 32350f4:	e0bfe615 	stw	r2,-104(fp)
      tiflags &= ~TH_RST;  /* clear reset flag */
      goto dropafterack;   /* send an ack and drop current packet */
   }
#endif /* DOS_RST */

   if (tiflags&TH_RST) 
 32350f8:	e0bfe617 	ldw	r2,-104(fp)
 32350fc:	1080010c 	andi	r2,r2,4
 3235100:	1005003a 	cmpeq	r2,r2,zero
 3235104:	1000391e 	bne	r2,zero,32351ec <tcp_input+0x1720>
   {
      switch (tp->t_state) 
 3235108:	e0bfe717 	ldw	r2,-100(fp)
 323510c:	10800217 	ldw	r2,8(r2)
 3235110:	10bfff44 	addi	r2,r2,-3
 3235114:	e0bffe15 	stw	r2,-8(fp)
 3235118:	e13ffe17 	ldw	r4,-8(fp)
 323511c:	20800228 	cmpgeui	r2,r4,8
 3235120:	1000321e 	bne	r2,zero,32351ec <tcp_input+0x1720>
 3235124:	e0fffe17 	ldw	r3,-8(fp)
 3235128:	e0fffe17 	ldw	r3,-8(fp)
 323512c:	18c5883a 	add	r2,r3,r3
 3235130:	1087883a 	add	r3,r2,r2
 3235134:	0080c8f4 	movhi	r2,803
 3235138:	10945204 	addi	r2,r2,20808
 323513c:	1885883a 	add	r2,r3,r2
 3235140:	10800017 	ldw	r2,0(r2)
 3235144:	1000683a 	jmp	r2
 3235148:	03235168 	cmpgeui	r12,zero,36165
 323514c:	03235178 	rdprs	r12,zero,-29371
 3235150:	03235194 	movui	r12,36166
 3235154:	03235194 	movui	r12,36166
 3235158:	032351d8 	cmpnei	r12,zero,-29369
 323515c:	032351d8 	cmpnei	r12,zero,-29369
 3235160:	03235194 	movui	r12,36166
 3235164:	032351d8 	cmpnei	r12,zero,-29369
      {
   
      case TCPS_SYN_RECEIVED:
         so->so_error = ECONNREFUSED;
 3235168:	e0ffe517 	ldw	r3,-108(fp)
 323516c:	00801bc4 	movi	r2,111
 3235170:	18800615 	stw	r2,24(r3)
         goto close;
 3235174:	00000a06 	br	32351a0 <tcp_input+0x16d4>
   
      case TCPS_ESTABLISHED:
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 3235178:	0080c9b4 	movhi	r2,806
 323517c:	10b48704 	addi	r2,r2,-11748
 3235180:	10800717 	ldw	r2,28(r2)
 3235184:	10c00044 	addi	r3,r2,1
 3235188:	0080c9b4 	movhi	r2,806
 323518c:	10b48704 	addi	r2,r2,-11748
 3235190:	10c00715 	stw	r3,28(r2)
      case TCPS_FIN_WAIT_1:
      case TCPS_FIN_WAIT_2:
      case TCPS_CLOSE_WAIT:
         so->so_error = ECONNRESET;
 3235194:	e0ffe517 	ldw	r3,-108(fp)
 3235198:	00801a04 	movi	r2,104
 323519c:	18800615 	stw	r2,24(r3)
         close:
         tp->t_state = TCPS_CLOSED;
 32351a0:	e0bfe717 	ldw	r2,-100(fp)
 32351a4:	10000215 	stw	zero,8(r2)
         tcpstat.tcps_drops++;
 32351a8:	0080c9b4 	movhi	r2,806
 32351ac:	10b4b504 	addi	r2,r2,-11564
 32351b0:	10800317 	ldw	r2,12(r2)
 32351b4:	10c00044 	addi	r3,r2,1
 32351b8:	0080c9b4 	movhi	r2,806
 32351bc:	10b4b504 	addi	r2,r2,-11564
 32351c0:	10c00315 	stw	r3,12(r2)
         SETTP(tp, tcp_close(tp));
 32351c4:	e13fe717 	ldw	r4,-100(fp)
 32351c8:	32381c80 	call	32381c8 <tcp_close>
#ifdef TCP_ZEROCOPY
         if (so->rx_upcall)
            so->rx_upcall(so, NULL, ECONNRESET);
#endif   /* TCP_ZEROCOPY */
         GOTO_DROP;
 32351cc:	00812204 	movi	r2,1160
 32351d0:	d0a8e915 	stw	r2,-23644(gp)
 32351d4:	00038106 	br	3235fdc <tcp_input+0x2510>
   
      case TCPS_CLOSING:
      case TCPS_LAST_ACK:
      case TCPS_TIME_WAIT:
         SETTP(tp, tcp_close(tp));
 32351d8:	e13fe717 	ldw	r4,-100(fp)
 32351dc:	32381c80 	call	32381c8 <tcp_close>
         GOTO_DROP;
 32351e0:	00812384 	movi	r2,1166
 32351e4:	d0a8e915 	stw	r2,-23644(gp)
 32351e8:	00037c06 	br	3235fdc <tcp_input+0x2510>
     tcp_trace("rcvd SYN in established state - ignoring SYN.\n");
#endif
      GOTO_DROP;
   }
#else
   if (tiflags & TH_SYN) 
 32351ec:	e0bfe617 	ldw	r2,-104(fp)
 32351f0:	1080008c 	andi	r2,r2,2
 32351f4:	1005003a 	cmpeq	r2,r2,zero
 32351f8:	1000071e 	bne	r2,zero,3235218 <tcp_input+0x174c>
   {
      tp = tcp_drop(tp, ECONNRESET);
 32351fc:	e13fe717 	ldw	r4,-100(fp)
 3235200:	01401a04 	movi	r5,104
 3235204:	323811c0 	call	323811c <tcp_drop>
 3235208:	e0bfe715 	stw	r2,-100(fp)
      GOTO_DROPWITHRESET;
 323520c:	00812b04 	movi	r2,1196
 3235210:	d0a8e915 	stw	r2,-23644(gp)
 3235214:	00032d06 	br	3235ecc <tcp_input+0x2400>
#endif /* end of else of DOS_SYN */

   /*
    * If the ACK bit is off we drop the segment and return.
    */
   if ((tiflags & TH_ACK) == 0)
 3235218:	e0bfe617 	ldw	r2,-104(fp)
 323521c:	1080040c 	andi	r2,r2,16
 3235220:	1004c03a 	cmpne	r2,r2,zero
 3235224:	1000031e 	bne	r2,zero,3235234 <tcp_input+0x1768>
      GOTO_DROP;
 3235228:	00812d04 	movi	r2,1204
 323522c:	d0a8e915 	stw	r2,-23644(gp)
 3235230:	00036a06 	br	3235fdc <tcp_input+0x2510>

   /*
    * Ack processing.
    */
   switch (tp->t_state) 
 3235234:	e0bfe717 	ldw	r2,-100(fp)
 3235238:	10800217 	ldw	r2,8(r2)
 323523c:	e0bff715 	stw	r2,-36(fp)
 3235240:	e13ff717 	ldw	r4,-36(fp)
 3235244:	208000e0 	cmpeqi	r2,r4,3
 3235248:	1000071e 	bne	r2,zero,3235268 <tcp_input+0x179c>
 323524c:	e0fff717 	ldw	r3,-36(fp)
 3235250:	188000d0 	cmplti	r2,r3,3
 3235254:	1001921e 	bne	r2,zero,32358a0 <tcp_input+0x1dd4>
 3235258:	e13ff717 	ldw	r4,-36(fp)
 323525c:	208002c8 	cmpgei	r2,r4,11
 3235260:	10018f1e 	bne	r2,zero,32358a0 <tcp_input+0x1dd4>
 3235264:	00003206 	br	3235330 <tcp_input+0x1864>
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 3235268:	e0bfe717 	ldw	r2,-100(fp)
 323526c:	10c00e17 	ldw	r3,56(r2)
 3235270:	e0bfed17 	ldw	r2,-76(fp)
 3235274:	10800717 	ldw	r2,28(r2)
 3235278:	1885c83a 	sub	r2,r3,r2
 323527c:	10800048 	cmpgei	r2,r2,1
 3235280:	1000071e 	bne	r2,zero,32352a0 <tcp_input+0x17d4>
 3235284:	e0bfed17 	ldw	r2,-76(fp)
 3235288:	10c00717 	ldw	r3,28(r2)
 323528c:	e0bfe717 	ldw	r2,-100(fp)
 3235290:	10801a17 	ldw	r2,104(r2)
 3235294:	1885c83a 	sub	r2,r3,r2
 3235298:	10800050 	cmplti	r2,r2,1
 323529c:	10000a1e 	bne	r2,zero,32352c8 <tcp_input+0x17fc>
          SEQ_GT(ti->ti_ack, tp->snd_max))
      {
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 32352a0:	0080c9b4 	movhi	r2,806
 32352a4:	10b48704 	addi	r2,r2,-11748
 32352a8:	10800717 	ldw	r2,28(r2)
 32352ac:	10c00044 	addi	r3,r2,1
 32352b0:	0080c9b4 	movhi	r2,806
 32352b4:	10b48704 	addi	r2,r2,-11748
 32352b8:	10c00715 	stw	r3,28(r2)
         GOTO_DROPWITHRESET;
 32352bc:	00813184 	movi	r2,1222
 32352c0:	d0a8e915 	stw	r2,-23644(gp)
 32352c4:	00030106 	br	3235ecc <tcp_input+0x2400>
      }
      tcpstat.tcps_connects++;
 32352c8:	0080c9b4 	movhi	r2,806
 32352cc:	10b4b504 	addi	r2,r2,-11564
 32352d0:	10800217 	ldw	r2,8(r2)
 32352d4:	10c00044 	addi	r3,r2,1
 32352d8:	0080c9b4 	movhi	r2,806
 32352dc:	10b4b504 	addi	r2,r2,-11564
 32352e0:	10c00215 	stw	r3,8(r2)
      tp->t_state = TCPS_ESTABLISHED;
 32352e4:	e0ffe717 	ldw	r3,-100(fp)
 32352e8:	00800104 	movi	r2,4
 32352ec:	18800215 	stw	r2,8(r3)
      soisconnected(so);
 32352f0:	e13fe517 	ldw	r4,-108(fp)
 32352f4:	3231b040 	call	3231b04 <soisconnected>
      tp->t_maxseg = tcp_mss(so);
 32352f8:	e13fe517 	ldw	r4,-108(fp)
 32352fc:	32365900 	call	3236590 <tcp_mss>
 3235300:	1007883a 	mov	r3,r2
 3235304:	e0bfe717 	ldw	r2,-100(fp)
 3235308:	10c00a0d 	sth	r3,40(r2)
      (void) tcp_reass(tp, (struct tcpiphdr *)0, m);
 323530c:	e13fe717 	ldw	r4,-100(fp)
 3235310:	000b883a 	mov	r5,zero
 3235314:	e1bff017 	ldw	r6,-64(fp)
 3235318:	32336c40 	call	32336c4 <tcp_reass>
      tp->snd_wl1 = ti->ti_seq - 1;
 323531c:	e0bfed17 	ldw	r2,-76(fp)
 3235320:	10800617 	ldw	r2,24(r2)
 3235324:	10ffffc4 	addi	r3,r2,-1
 3235328:	e0bfe717 	ldw	r2,-100(fp)
 323532c:	10c01115 	stw	r3,68(r2)
   case TCPS_CLOSE_WAIT:
   case TCPS_CLOSING:
   case TCPS_LAST_ACK:
   case TCPS_TIME_WAIT:

      if (SEQ_LEQ(ti->ti_ack, tp->snd_una)) 
 3235330:	e0bfed17 	ldw	r2,-76(fp)
 3235334:	10c00717 	ldw	r3,28(r2)
 3235338:	e0bfe717 	ldw	r2,-100(fp)
 323533c:	10800e17 	ldw	r2,56(r2)
 3235340:	1885c83a 	sub	r2,r3,r2
 3235344:	10800048 	cmpgei	r2,r2,1
 3235348:	1000671e 	bne	r2,zero,32354e8 <tcp_input+0x1a1c>
      {
         if (ti->ti_len == 0 && rx_win == tp->snd_wnd) 
 323534c:	e0bfed17 	ldw	r2,-76(fp)
 3235350:	1080028b 	ldhu	r2,10(r2)
 3235354:	10bfffcc 	andi	r2,r2,65535
 3235358:	1004c03a 	cmpne	r2,r2,zero
 323535c:	10005f1e 	bne	r2,zero,32354dc <tcp_input+0x1a10>
 3235360:	e0bfe717 	ldw	r2,-100(fp)
 3235364:	10c01417 	ldw	r3,80(r2)
 3235368:	e0bfde17 	ldw	r2,-136(fp)
 323536c:	18805b1e 	bne	r3,r2,32354dc <tcp_input+0x1a10>
         {
            tcpstat.tcps_rcvdupack++;
 3235370:	0080c9b4 	movhi	r2,806
 3235374:	10b4b504 	addi	r2,r2,-11564
 3235378:	10802917 	ldw	r2,164(r2)
 323537c:	10c00044 	addi	r3,r2,1
 3235380:	0080c9b4 	movhi	r2,806
 3235384:	10b4b504 	addi	r2,r2,-11564
 3235388:	10c02915 	stw	r3,164(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 323538c:	e0bfe717 	ldw	r2,-100(fp)
 3235390:	10800317 	ldw	r2,12(r2)
 3235394:	1005003a 	cmpeq	r2,r2,zero
 3235398:	1000051e 	bne	r2,zero,32353b0 <tcp_input+0x18e4>
 323539c:	e0bfed17 	ldw	r2,-76(fp)
 32353a0:	10c00717 	ldw	r3,28(r2)
 32353a4:	e0bfe717 	ldw	r2,-100(fp)
 32353a8:	10800e17 	ldw	r2,56(r2)
 32353ac:	18800326 	beq	r3,r2,32353bc <tcp_input+0x18f0>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
 32353b0:	e0bfe717 	ldw	r2,-100(fp)
 32353b4:	10000915 	stw	zero,36(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 32353b8:	00013906 	br	32358a0 <tcp_input+0x1dd4>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
 32353bc:	e0bfe717 	ldw	r2,-100(fp)
 32353c0:	10800917 	ldw	r2,36(r2)
 32353c4:	10c00044 	addi	r3,r2,1
 32353c8:	e0bfe717 	ldw	r2,-100(fp)
 32353cc:	10c00915 	stw	r3,36(r2)
 32353d0:	e0bfe717 	ldw	r2,-100(fp)
 32353d4:	10c00917 	ldw	r3,36(r2)
 32353d8:	d0a03883 	ldbu	r2,-32542(gp)
 32353dc:	10803fcc 	andi	r2,r2,255
 32353e0:	1080201c 	xori	r2,r2,128
 32353e4:	10bfe004 	addi	r2,r2,-128
 32353e8:	18812d1e 	bne	r3,r2,32358a0 <tcp_input+0x1dd4>
            {
               tcp_seq onxt = tp->snd_nxt;
 32353ec:	e0bfe717 	ldw	r2,-100(fp)
 32353f0:	10800f17 	ldw	r2,60(r2)
 32353f4:	e0bfd715 	stw	r2,-164(fp)
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
               tp->t_maxseg;
 32353f8:	e0bfe717 	ldw	r2,-100(fp)
 32353fc:	10c01417 	ldw	r3,80(r2)
 3235400:	e0bfe717 	ldw	r2,-100(fp)
 3235404:	10801b17 	ldw	r2,108(r2)
 3235408:	e0bff615 	stw	r2,-40(fp)
 323540c:	e0fff515 	stw	r3,-44(fp)
 3235410:	e0bff617 	ldw	r2,-40(fp)
 3235414:	e0fff517 	ldw	r3,-44(fp)
 3235418:	10c0022e 	bgeu	r2,r3,3235424 <tcp_input+0x1958>
 323541c:	e13ff617 	ldw	r4,-40(fp)
 3235420:	e13ff515 	stw	r4,-44(fp)
 3235424:	e0bff517 	ldw	r2,-44(fp)
 3235428:	1008d07a 	srli	r4,r2,1
 323542c:	e0bfe717 	ldw	r2,-100(fp)
 3235430:	10800a0b 	ldhu	r2,40(r2)
 3235434:	117fffcc 	andi	r5,r2,65535
 3235438:	32047c00 	call	32047c0 <__udivsi3>
 323543c:	e0bfd60d 	sth	r2,-168(fp)

               if (win < 2)
 3235440:	e0bfd60b 	ldhu	r2,-168(fp)
 3235444:	108000a8 	cmpgeui	r2,r2,2
 3235448:	1000021e 	bne	r2,zero,3235454 <tcp_input+0x1988>
                  win = 2;
 323544c:	00800084 	movi	r2,2
 3235450:	e0bfd60d 	sth	r2,-168(fp)
               tp->snd_ssthresh = (u_short)(win * tp->t_maxseg);
 3235454:	e0bfe717 	ldw	r2,-100(fp)
 3235458:	10c00a0b 	ldhu	r3,40(r2)
 323545c:	e0bfd60b 	ldhu	r2,-168(fp)
 3235460:	1885383a 	mul	r2,r3,r2
 3235464:	10ffffcc 	andi	r3,r2,65535
 3235468:	e0bfe717 	ldw	r2,-100(fp)
 323546c:	10c01c15 	stw	r3,112(r2)

               tp->t_timer[TCPT_REXMT] = 0;
 3235470:	e0bfe717 	ldw	r2,-100(fp)
 3235474:	10000315 	stw	zero,12(r2)
               tp->t_rttick = 0;
 3235478:	e0bfe717 	ldw	r2,-100(fp)
 323547c:	10001e15 	stw	zero,120(r2)
               tp->snd_nxt = ti->ti_ack;
 3235480:	e0bfed17 	ldw	r2,-76(fp)
 3235484:	10c00717 	ldw	r3,28(r2)
 3235488:	e0bfe717 	ldw	r2,-100(fp)
 323548c:	10c00f15 	stw	r3,60(r2)
               tp->snd_cwnd = tp->t_maxseg;
 3235490:	e0bfe717 	ldw	r2,-100(fp)
 3235494:	10800a0b 	ldhu	r2,40(r2)
 3235498:	10ffffcc 	andi	r3,r2,65535
 323549c:	e0bfe717 	ldw	r2,-100(fp)
 32354a0:	10c01b15 	stw	r3,108(r2)
               (void) tcp_output(tp);
 32354a4:	e13fe717 	ldw	r4,-100(fp)
 32354a8:	32366ac0 	call	32366ac <tcp_output>

               if (SEQ_GT(onxt, tp->snd_nxt))
 32354ac:	e0bfe717 	ldw	r2,-100(fp)
 32354b0:	10c00f17 	ldw	r3,60(r2)
 32354b4:	e0bfd717 	ldw	r2,-164(fp)
 32354b8:	10c5c83a 	sub	r2,r2,r3
 32354bc:	10800050 	cmplti	r2,r2,1
 32354c0:	1000031e 	bne	r2,zero,32354d0 <tcp_input+0x1a04>
                  tp->snd_nxt = onxt;
 32354c4:	e0ffe717 	ldw	r3,-100(fp)
 32354c8:	e0bfd717 	ldw	r2,-164(fp)
 32354cc:	18800f15 	stw	r2,60(r3)
               GOTO_DROP;
 32354d0:	00814544 	movi	r2,1301
 32354d4:	d0a8e915 	stw	r2,-23644(gp)
 32354d8:	0002c006 	br	3235fdc <tcp_input+0x2510>
            }
         } else
            tp->t_dupacks = 0;
 32354dc:	e0bfe717 	ldw	r2,-100(fp)
 32354e0:	10000915 	stw	zero,36(r2)
         break;
 32354e4:	0000ee06 	br	32358a0 <tcp_input+0x1dd4>
      }
      tp->t_dupacks = 0;
 32354e8:	e0bfe717 	ldw	r2,-100(fp)
 32354ec:	10000915 	stw	zero,36(r2)
      if (SEQ_GT(ti->ti_ack, tp->snd_max)) 
 32354f0:	e0bfed17 	ldw	r2,-76(fp)
 32354f4:	10c00717 	ldw	r3,28(r2)
 32354f8:	e0bfe717 	ldw	r2,-100(fp)
 32354fc:	10801a17 	ldw	r2,104(r2)
 3235500:	1885c83a 	sub	r2,r3,r2
 3235504:	10800050 	cmplti	r2,r2,1
 3235508:	1000081e 	bne	r2,zero,323552c <tcp_input+0x1a60>
      {
         tcpstat.tcps_rcvacktoomuch++;
 323550c:	0080c9b4 	movhi	r2,806
 3235510:	10b4b504 	addi	r2,r2,-11564
 3235514:	10802a17 	ldw	r2,168(r2)
 3235518:	10c00044 	addi	r3,r2,1
 323551c:	0080c9b4 	movhi	r2,806
 3235520:	10b4b504 	addi	r2,r2,-11564
 3235524:	10c02a15 	stw	r3,168(r2)
         goto dropafterack;
 3235528:	00025606 	br	3235e84 <tcp_input+0x23b8>
      }
      acked = (int)(ti->ti_ack - tp->snd_una);
 323552c:	e0bfed17 	ldw	r2,-76(fp)
 3235530:	10c00717 	ldw	r3,28(r2)
 3235534:	e0bfe717 	ldw	r2,-100(fp)
 3235538:	10800e17 	ldw	r2,56(r2)
 323553c:	1885c83a 	sub	r2,r3,r2
 3235540:	e0bfe315 	stw	r2,-116(fp)
      tcpstat.tcps_rcvackpack++;
 3235544:	0080c9b4 	movhi	r2,806
 3235548:	10b4b504 	addi	r2,r2,-11564
 323554c:	10802b17 	ldw	r2,172(r2)
 3235550:	10c00044 	addi	r3,r2,1
 3235554:	0080c9b4 	movhi	r2,806
 3235558:	10b4b504 	addi	r2,r2,-11564
 323555c:	10c02b15 	stw	r3,172(r2)
      tcpstat.tcps_rcvackbyte += acked;
 3235560:	0080c9b4 	movhi	r2,806
 3235564:	10b4b504 	addi	r2,r2,-11564
 3235568:	10c02c17 	ldw	r3,176(r2)
 323556c:	e0bfe317 	ldw	r2,-116(fp)
 3235570:	1887883a 	add	r3,r3,r2
 3235574:	0080c9b4 	movhi	r2,806
 3235578:	10b4b504 	addi	r2,r2,-11564
 323557c:	10c02c15 	stw	r3,176(r2)
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 3235580:	e0bfe717 	ldw	r2,-100(fp)
 3235584:	10801e17 	ldw	r2,120(r2)
 3235588:	1005003a 	cmpeq	r2,r2,zero
 323558c:	1000091e 	bne	r2,zero,32355b4 <tcp_input+0x1ae8>
 3235590:	e0bfed17 	ldw	r2,-76(fp)
 3235594:	10c00717 	ldw	r3,28(r2)
 3235598:	e0bfe717 	ldw	r2,-100(fp)
 323559c:	10801f17 	ldw	r2,124(r2)
 32355a0:	1885c83a 	sub	r2,r3,r2
 32355a4:	10800050 	cmplti	r2,r2,1
 32355a8:	1000021e 	bne	r2,zero,32355b4 <tcp_input+0x1ae8>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
         tcp_xmit_timer(tp);
 32355ac:	e13fe717 	ldw	r4,-100(fp)
 32355b0:	32362dc0 	call	32362dc <tcp_xmit_timer>
       * If all outstanding data is acked, stop retransmit
       * timer and remember to restart (more output or persist).
       * If there is more data to be acked, restart retransmit
       * timer, using current (possibly backed-off) value.
       */
      if (ti->ti_ack == tp->snd_max) 
 32355b4:	e0bfed17 	ldw	r2,-76(fp)
 32355b8:	10c00717 	ldw	r3,28(r2)
 32355bc:	e0bfe717 	ldw	r2,-100(fp)
 32355c0:	10801a17 	ldw	r2,104(r2)
 32355c4:	1880051e 	bne	r3,r2,32355dc <tcp_input+0x1b10>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 32355c8:	e0bfe717 	ldw	r2,-100(fp)
 32355cc:	10000315 	stw	zero,12(r2)
         needoutput = 1;
 32355d0:	00800044 	movi	r2,1
 32355d4:	e0bfe115 	stw	r2,-124(fp)
 32355d8:	00000806 	br	32355fc <tcp_input+0x1b30>
      } else if (tp->t_timer[TCPT_PERSIST] == 0)
 32355dc:	e0bfe717 	ldw	r2,-100(fp)
 32355e0:	10800417 	ldw	r2,16(r2)
 32355e4:	1004c03a 	cmpne	r2,r2,zero
 32355e8:	1000041e 	bne	r2,zero,32355fc <tcp_input+0x1b30>
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 32355ec:	e0bfe717 	ldw	r2,-100(fp)
 32355f0:	10c00817 	ldw	r3,32(r2)
 32355f4:	e0bfe717 	ldw	r2,-100(fp)
 32355f8:	10c00315 	stw	r3,12(r2)
       * in flight, open exponentially (maxseg per packet).
       * Otherwise open linearly (maxseg per window,
       * or maxseg^2 / cwnd per packet).
       */
      {
         tcp_win  cw =  tp->snd_cwnd;
 32355fc:	e0bfe717 	ldw	r2,-100(fp)
 3235600:	10801b17 	ldw	r2,108(r2)
 3235604:	e0bfd515 	stw	r2,-172(fp)
         u_short  incr  =  tp->t_maxseg;
 3235608:	e0bfe717 	ldw	r2,-100(fp)
 323560c:	10800a0b 	ldhu	r2,40(r2)
 3235610:	e0bfd40d 	sth	r2,-176(fp)

         if (cw > tp->snd_ssthresh)
 3235614:	e0bfe717 	ldw	r2,-100(fp)
 3235618:	10c01c17 	ldw	r3,112(r2)
 323561c:	e0bfd517 	ldw	r2,-172(fp)
 3235620:	18800e2e 	bgeu	r3,r2,323565c <tcp_input+0x1b90>
            incr = MAX( (incr * incr / cw), (ALIGN_TYPE << 2) );
 3235624:	e0ffd40b 	ldhu	r3,-176(fp)
 3235628:	e0bfd40b 	ldhu	r2,-176(fp)
 323562c:	1885383a 	mul	r2,r3,r2
 3235630:	1009883a 	mov	r4,r2
 3235634:	e17fd517 	ldw	r5,-172(fp)
 3235638:	32047c00 	call	32047c0 <__udivsi3>
 323563c:	e0bff415 	stw	r2,-48(fp)
 3235640:	e0fff417 	ldw	r3,-48(fp)
 3235644:	18800428 	cmpgeui	r2,r3,16
 3235648:	1000021e 	bne	r2,zero,3235654 <tcp_input+0x1b88>
 323564c:	01000404 	movi	r4,16
 3235650:	e13ff415 	stw	r4,-48(fp)
 3235654:	e0bff417 	ldw	r2,-48(fp)
 3235658:	e0bfd40d 	sth	r2,-176(fp)

         tp->snd_cwnd = MIN(cw + (u_short)incr, (IP_MAXPACKET));
 323565c:	e0ffd40b 	ldhu	r3,-176(fp)
 3235660:	e0bfd517 	ldw	r2,-172(fp)
 3235664:	1885883a 	add	r2,r3,r2
 3235668:	e0bff315 	stw	r2,-52(fp)
 323566c:	e0fff317 	ldw	r3,-52(fp)
 3235670:	18980070 	cmpltui	r2,r3,24577
 3235674:	1000021e 	bne	r2,zero,3235680 <tcp_input+0x1bb4>
 3235678:	01180004 	movi	r4,24576
 323567c:	e13ff315 	stw	r4,-52(fp)
 3235680:	e0bfe717 	ldw	r2,-100(fp)
 3235684:	e0fff317 	ldw	r3,-52(fp)
 3235688:	10c01b15 	stw	r3,108(r2)
      }
      if (acked > (int)so->so_snd.sb_cc) 
 323568c:	e0bfe517 	ldw	r2,-108(fp)
 3235690:	10801217 	ldw	r2,72(r2)
 3235694:	1007883a 	mov	r3,r2
 3235698:	e0bfe317 	ldw	r2,-116(fp)
 323569c:	1880110e 	bge	r3,r2,32356e4 <tcp_input+0x1c18>
      {
         tp->snd_wnd -= (u_short)so->so_snd.sb_cc;
 32356a0:	e0bfe717 	ldw	r2,-100(fp)
 32356a4:	10c01417 	ldw	r3,80(r2)
 32356a8:	e0bfe517 	ldw	r2,-108(fp)
 32356ac:	10801217 	ldw	r2,72(r2)
 32356b0:	10bfffcc 	andi	r2,r2,65535
 32356b4:	1887c83a 	sub	r3,r3,r2
 32356b8:	e0bfe717 	ldw	r2,-100(fp)
 32356bc:	10c01415 	stw	r3,80(r2)
         sbdrop(&so->so_snd, (int)so->so_snd.sb_cc);
 32356c0:	e0bfe517 	ldw	r2,-108(fp)
 32356c4:	11001204 	addi	r4,r2,72
 32356c8:	e0bfe517 	ldw	r2,-108(fp)
 32356cc:	10801217 	ldw	r2,72(r2)
 32356d0:	100b883a 	mov	r5,r2
 32356d4:	3232a3c0 	call	3232a3c <sbdrop>
         ourfinisacked = 1;
 32356d8:	00800044 	movi	r2,1
 32356dc:	e0bfe215 	stw	r2,-120(fp)
 32356e0:	00000c06 	br	3235714 <tcp_input+0x1c48>
      } 
      else 
      {
         sbdrop(&so->so_snd, acked);
 32356e4:	e0bfe517 	ldw	r2,-108(fp)
 32356e8:	11001204 	addi	r4,r2,72
 32356ec:	e17fe317 	ldw	r5,-116(fp)
 32356f0:	3232a3c0 	call	3232a3c <sbdrop>
         tp->snd_wnd -= (u_short)acked;
 32356f4:	e0bfe717 	ldw	r2,-100(fp)
 32356f8:	10c01417 	ldw	r3,80(r2)
 32356fc:	e0bfe317 	ldw	r2,-116(fp)
 3235700:	10bfffcc 	andi	r2,r2,65535
 3235704:	1887c83a 	sub	r3,r3,r2
 3235708:	e0bfe717 	ldw	r2,-100(fp)
 323570c:	10c01415 	stw	r3,80(r2)
         ourfinisacked = 0;
 3235710:	e03fe215 	stw	zero,-120(fp)
      }

      if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 3235714:	e0bfe517 	ldw	r2,-108(fp)
 3235718:	1080190b 	ldhu	r2,100(r2)
 323571c:	10bfffcc 	andi	r2,r2,65535
 3235720:	1080030c 	andi	r2,r2,12
 3235724:	1005003a 	cmpeq	r2,r2,zero
 3235728:	1000041e 	bne	r2,zero,323573c <tcp_input+0x1c70>
         sowwakeup(so);
 323572c:	e0bfe517 	ldw	r2,-108(fp)
 3235730:	11401204 	addi	r5,r2,72
 3235734:	e13fe517 	ldw	r4,-108(fp)
 3235738:	32322700 	call	3232270 <sbwakeup>

      tp->snd_una = ti->ti_ack;
 323573c:	e0bfed17 	ldw	r2,-76(fp)
 3235740:	10c00717 	ldw	r3,28(r2)
 3235744:	e0bfe717 	ldw	r2,-100(fp)
 3235748:	10c00e15 	stw	r3,56(r2)
      if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 323574c:	e0bfe717 	ldw	r2,-100(fp)
 3235750:	10c00f17 	ldw	r3,60(r2)
 3235754:	e0bfe717 	ldw	r2,-100(fp)
 3235758:	10800e17 	ldw	r2,56(r2)
 323575c:	1885c83a 	sub	r2,r3,r2
 3235760:	1004403a 	cmpge	r2,r2,zero
 3235764:	1000041e 	bne	r2,zero,3235778 <tcp_input+0x1cac>
         tp->snd_nxt = tp->snd_una;
 3235768:	e0bfe717 	ldw	r2,-100(fp)
 323576c:	10c00e17 	ldw	r3,56(r2)
 3235770:	e0bfe717 	ldw	r2,-100(fp)
 3235774:	10c00f15 	stw	r3,60(r2)


      switch (tp->t_state) 
 3235778:	e0bfe717 	ldw	r2,-100(fp)
 323577c:	10800217 	ldw	r2,8(r2)
 3235780:	e0bff215 	stw	r2,-56(fp)
 3235784:	e13ff217 	ldw	r4,-56(fp)
 3235788:	208001e0 	cmpeqi	r2,r4,7
 323578c:	1000221e 	bne	r2,zero,3235818 <tcp_input+0x1d4c>
 3235790:	e0fff217 	ldw	r3,-56(fp)
 3235794:	18800208 	cmpgei	r2,r3,8
 3235798:	1000041e 	bne	r2,zero,32357ac <tcp_input+0x1ce0>
 323579c:	e13ff217 	ldw	r4,-56(fp)
 32357a0:	208001a0 	cmpeqi	r2,r4,6
 32357a4:	1000081e 	bne	r2,zero,32357c8 <tcp_input+0x1cfc>
 32357a8:	00003d06 	br	32358a0 <tcp_input+0x1dd4>
 32357ac:	e0fff217 	ldw	r3,-56(fp)
 32357b0:	18800220 	cmpeqi	r2,r3,8
 32357b4:	10002a1e 	bne	r2,zero,3235860 <tcp_input+0x1d94>
 32357b8:	e13ff217 	ldw	r4,-56(fp)
 32357bc:	208002a0 	cmpeqi	r2,r4,10
 32357c0:	10002f1e 	bne	r2,zero,3235880 <tcp_input+0x1db4>
 32357c4:	00003606 	br	32358a0 <tcp_input+0x1dd4>
       * In FIN_WAIT_1 STATE in addition to the processing
       * for the ESTABLISHED state if our FIN is now acknowledged
       * then enter FIN_WAIT_2.
       */
      case TCPS_FIN_WAIT_1:
         if (ourfinisacked) 
 32357c8:	e0bfe217 	ldw	r2,-120(fp)
 32357cc:	1005003a 	cmpeq	r2,r2,zero
 32357d0:	1000331e 	bne	r2,zero,32358a0 <tcp_input+0x1dd4>
             * data, then closing user can proceed.
             * Starting the timer is contrary to the
             * specification, but if we don't get a FIN
             * we'll hang forever.
             */
            if (so->so_state & SS_CANTRCVMORE) 
 32357d4:	e0bfe517 	ldw	r2,-108(fp)
 32357d8:	1080088b 	ldhu	r2,34(r2)
 32357dc:	10bfffcc 	andi	r2,r2,65535
 32357e0:	1080080c 	andi	r2,r2,32
 32357e4:	1005003a 	cmpeq	r2,r2,zero
 32357e8:	1000071e 	bne	r2,zero,3235808 <tcp_input+0x1d3c>
            {
               soisdisconnected(so);
 32357ec:	e13fe517 	ldw	r4,-108(fp)
 32357f0:	3231c8c0 	call	3231c8c <soisdisconnected>
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
 32357f4:	0080c974 	movhi	r2,805
 32357f8:	10934d04 	addi	r2,r2,19764
 32357fc:	10c00017 	ldw	r3,0(r2)
 3235800:	e0bfe717 	ldw	r2,-100(fp)
 3235804:	10c00615 	stw	r3,24(r2)
            }
            tp->t_state = TCPS_FIN_WAIT_2;
 3235808:	e0ffe717 	ldw	r3,-100(fp)
 323580c:	00800244 	movi	r2,9
 3235810:	18800215 	stw	r2,8(r3)
         }
         break;
 3235814:	00002206 	br	32358a0 <tcp_input+0x1dd4>
       * the ESTABLISHED state if the ACK acknowledges our FIN
       * then enter the TIME-WAIT state, otherwise ignore
       * the segment.
       */
      case TCPS_CLOSING:
         if (ourfinisacked) 
 3235818:	e0bfe217 	ldw	r2,-120(fp)
 323581c:	1005003a 	cmpeq	r2,r2,zero
 3235820:	10001f1e 	bne	r2,zero,32358a0 <tcp_input+0x1dd4>
         {
            tp->t_state = TCPS_TIME_WAIT;
 3235824:	e0ffe717 	ldw	r3,-100(fp)
 3235828:	00800284 	movi	r2,10
 323582c:	18800215 	stw	r2,8(r3)
            tcp_canceltimers(tp);
 3235830:	e13fe717 	ldw	r4,-100(fp)
 3235834:	32386940 	call	3238694 <tcp_canceltimers>
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 3235838:	0080c974 	movhi	r2,805
 323583c:	108a9904 	addi	r2,r2,10852
 3235840:	10800017 	ldw	r2,0(r2)
 3235844:	1085883a 	add	r2,r2,r2
 3235848:	1007883a 	mov	r3,r2
 323584c:	e0bfe717 	ldw	r2,-100(fp)
 3235850:	10c00615 	stw	r3,24(r2)
            soisdisconnected(so);
 3235854:	e13fe517 	ldw	r4,-108(fp)
 3235858:	3231c8c0 	call	3231c8c <soisdisconnected>
         }
         break;
 323585c:	00001006 	br	32358a0 <tcp_input+0x1dd4>
       * and/or to be acked, as well as for the ack of our FIN.
       * If our FIN is now acknowledged, delete the TCB,
       * enter the closed state and return.
       */
      case TCPS_LAST_ACK:
         if (ourfinisacked) 
 3235860:	e0bfe217 	ldw	r2,-120(fp)
 3235864:	1005003a 	cmpeq	r2,r2,zero
 3235868:	10000d1e 	bne	r2,zero,32358a0 <tcp_input+0x1dd4>
         {
            SETTP(tp, tcp_close(tp));
 323586c:	e13fe717 	ldw	r4,-100(fp)
 3235870:	32381c80 	call	32381c8 <tcp_close>
            GOTO_DROP;
 3235874:	00816644 	movi	r2,1433
 3235878:	d0a8e915 	stw	r2,-23644(gp)
 323587c:	0001d706 	br	3235fdc <tcp_input+0x2510>
       * In TIME_WAIT state the only thing that should arrive
       * is a retransmission of the remote FIN.  Acknowledge
       * it and restart the finack timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 3235880:	0080c974 	movhi	r2,805
 3235884:	108a9904 	addi	r2,r2,10852
 3235888:	10800017 	ldw	r2,0(r2)
 323588c:	1085883a 	add	r2,r2,r2
 3235890:	1007883a 	mov	r3,r2
 3235894:	e0bfe717 	ldw	r2,-100(fp)
 3235898:	10c00615 	stw	r3,24(r2)
         goto dropafterack;
 323589c:	00017906 	br	3235e84 <tcp_input+0x23b8>
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 32358a0:	e0bfe617 	ldw	r2,-104(fp)
 32358a4:	1080040c 	andi	r2,r2,16
 32358a8:	1005003a 	cmpeq	r2,r2,zero
 32358ac:	1000471e 	bne	r2,zero,32359cc <tcp_input+0x1f00>
 32358b0:	e0bfe717 	ldw	r2,-100(fp)
 32358b4:	10c01117 	ldw	r3,68(r2)
 32358b8:	e0bfed17 	ldw	r2,-76(fp)
 32358bc:	10800617 	ldw	r2,24(r2)
 32358c0:	1885c83a 	sub	r2,r3,r2
 32358c4:	1004803a 	cmplt	r2,r2,zero
 32358c8:	1000151e 	bne	r2,zero,3235920 <tcp_input+0x1e54>
 32358cc:	e0bfe717 	ldw	r2,-100(fp)
 32358d0:	10c01117 	ldw	r3,68(r2)
 32358d4:	e0bfed17 	ldw	r2,-76(fp)
 32358d8:	10800617 	ldw	r2,24(r2)
 32358dc:	18803b1e 	bne	r3,r2,32359cc <tcp_input+0x1f00>
 32358e0:	e0bfe717 	ldw	r2,-100(fp)
 32358e4:	10c01217 	ldw	r3,72(r2)
 32358e8:	e0bfed17 	ldw	r2,-76(fp)
 32358ec:	10800717 	ldw	r2,28(r2)
 32358f0:	1885c83a 	sub	r2,r3,r2
 32358f4:	1004803a 	cmplt	r2,r2,zero
 32358f8:	1000091e 	bne	r2,zero,3235920 <tcp_input+0x1e54>
 32358fc:	e0bfe717 	ldw	r2,-100(fp)
 3235900:	10c01217 	ldw	r3,72(r2)
 3235904:	e0bfed17 	ldw	r2,-76(fp)
 3235908:	10800717 	ldw	r2,28(r2)
 323590c:	18802f1e 	bne	r3,r2,32359cc <tcp_input+0x1f00>
 3235910:	e0bfe717 	ldw	r2,-100(fp)
 3235914:	10c01417 	ldw	r3,80(r2)
 3235918:	e0bfde17 	ldw	r2,-136(fp)
 323591c:	18802b2e 	bgeu	r3,r2,32359cc <tcp_input+0x1f00>
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 3235920:	e0bfed17 	ldw	r2,-76(fp)
 3235924:	1080028b 	ldhu	r2,10(r2)
 3235928:	10bfffcc 	andi	r2,r2,65535
 323592c:	1004c03a 	cmpne	r2,r2,zero
 3235930:	1000101e 	bne	r2,zero,3235974 <tcp_input+0x1ea8>
 3235934:	e0bfe717 	ldw	r2,-100(fp)
 3235938:	10c01217 	ldw	r3,72(r2)
 323593c:	e0bfed17 	ldw	r2,-76(fp)
 3235940:	10800717 	ldw	r2,28(r2)
 3235944:	18800b1e 	bne	r3,r2,3235974 <tcp_input+0x1ea8>
 3235948:	e0bfe717 	ldw	r2,-100(fp)
 323594c:	10c01417 	ldw	r3,80(r2)
 3235950:	e0bfde17 	ldw	r2,-136(fp)
 3235954:	1880072e 	bgeu	r3,r2,3235974 <tcp_input+0x1ea8>
          (tp->snd_wl2 == ti->ti_ack) &&
          (rx_win > tp->snd_wnd))
      {
         tcpstat.tcps_rcvwinupd++;
 3235958:	0080c9b4 	movhi	r2,806
 323595c:	10b4b504 	addi	r2,r2,-11564
 3235960:	10802d17 	ldw	r2,180(r2)
 3235964:	10c00044 	addi	r3,r2,1
 3235968:	0080c9b4 	movhi	r2,806
 323596c:	10b4b504 	addi	r2,r2,-11564
 3235970:	10c02d15 	stw	r3,180(r2)
      }
      tp->snd_wnd = rx_win;
 3235974:	e0ffe717 	ldw	r3,-100(fp)
 3235978:	e0bfde17 	ldw	r2,-136(fp)
 323597c:	18801415 	stw	r2,80(r3)
      tp->snd_wl1 = ti->ti_seq;
 3235980:	e0bfed17 	ldw	r2,-76(fp)
 3235984:	10c00617 	ldw	r3,24(r2)
 3235988:	e0bfe717 	ldw	r2,-100(fp)
 323598c:	10c01115 	stw	r3,68(r2)
      tp->snd_wl2 = ti->ti_ack;
 3235990:	e0bfed17 	ldw	r2,-76(fp)
 3235994:	10c00717 	ldw	r3,28(r2)
 3235998:	e0bfe717 	ldw	r2,-100(fp)
 323599c:	10c01215 	stw	r3,72(r2)
      if (tp->snd_wnd > tp->max_sndwnd)
 32359a0:	e0bfe717 	ldw	r2,-100(fp)
 32359a4:	10c01417 	ldw	r3,80(r2)
 32359a8:	e0bfe717 	ldw	r2,-100(fp)
 32359ac:	10802317 	ldw	r2,140(r2)
 32359b0:	10c0042e 	bgeu	r2,r3,32359c4 <tcp_input+0x1ef8>
         tp->max_sndwnd = tp->snd_wnd;
 32359b4:	e0bfe717 	ldw	r2,-100(fp)
 32359b8:	10c01417 	ldw	r3,80(r2)
 32359bc:	e0bfe717 	ldw	r2,-100(fp)
 32359c0:	10c02315 	stw	r3,140(r2)
      needoutput = 1;
 32359c4:	00800044 	movi	r2,1
 32359c8:	e0bfe115 	stw	r2,-124(fp)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 32359cc:	e0bfe617 	ldw	r2,-104(fp)
 32359d0:	1080080c 	andi	r2,r2,32
 32359d4:	1005003a 	cmpeq	r2,r2,zero
 32359d8:	10005a1e 	bne	r2,zero,3235b44 <tcp_input+0x2078>
 32359dc:	e0bfed17 	ldw	r2,-76(fp)
 32359e0:	1080098b 	ldhu	r2,38(r2)
 32359e4:	10bfffcc 	andi	r2,r2,65535
 32359e8:	1005003a 	cmpeq	r2,r2,zero
 32359ec:	1000551e 	bne	r2,zero,3235b44 <tcp_input+0x2078>
 32359f0:	e0bfe717 	ldw	r2,-100(fp)
 32359f4:	10800217 	ldw	r2,8(r2)
 32359f8:	10800288 	cmpgei	r2,r2,10
 32359fc:	1000511e 	bne	r2,zero,3235b44 <tcp_input+0x2078>
       * This is a kludge, but if we receive and accept
       * random urgent pointers, we'll crash in
       * soreceive.  It's hard to imagine someone
       * actually wanting to send this much urgent data.
       */
      if (ti->ti_urp + so->so_rcv.sb_cc > SB_MAX) 
 3235a00:	e0bfed17 	ldw	r2,-76(fp)
 3235a04:	1080098b 	ldhu	r2,38(r2)
 3235a08:	10ffffcc 	andi	r3,r2,65535
 3235a0c:	e0bfe517 	ldw	r2,-108(fp)
 3235a10:	10800a17 	ldw	r2,40(r2)
 3235a14:	1885883a 	add	r2,r3,r2
 3235a18:	10900070 	cmpltui	r2,r2,16385
 3235a1c:	1000071e 	bne	r2,zero,3235a3c <tcp_input+0x1f70>
      {
         ti->ti_urp = 0;         /* XXX */
 3235a20:	e0bfed17 	ldw	r2,-76(fp)
 3235a24:	1000098d 	sth	zero,38(r2)
         tiflags &= ~TH_URG;     /* XXX */
 3235a28:	e0ffe617 	ldw	r3,-104(fp)
 3235a2c:	00bff7c4 	movi	r2,-33
 3235a30:	1884703a 	and	r2,r3,r2
 3235a34:	e0bfe615 	stw	r2,-104(fp)
         goto dodata;         /* XXX */
 3235a38:	00004d06 	br	3235b70 <tcp_input+0x20a4>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
 3235a3c:	e0bfed17 	ldw	r2,-76(fp)
 3235a40:	10c00617 	ldw	r3,24(r2)
 3235a44:	e0bfed17 	ldw	r2,-76(fp)
 3235a48:	1080098b 	ldhu	r2,38(r2)
 3235a4c:	10bfffcc 	andi	r2,r2,65535
 3235a50:	1887883a 	add	r3,r3,r2
 3235a54:	e0bfe717 	ldw	r2,-100(fp)
 3235a58:	10801717 	ldw	r2,92(r2)
 3235a5c:	1885c83a 	sub	r2,r3,r2
 3235a60:	10800050 	cmplti	r2,r2,1
 3235a64:	1000261e 	bne	r2,zero,3235b00 <tcp_input+0x2034>
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
 3235a68:	e0bfed17 	ldw	r2,-76(fp)
 3235a6c:	10c00617 	ldw	r3,24(r2)
 3235a70:	e0bfed17 	ldw	r2,-76(fp)
 3235a74:	1080098b 	ldhu	r2,38(r2)
 3235a78:	10bfffcc 	andi	r2,r2,65535
 3235a7c:	1887883a 	add	r3,r3,r2
 3235a80:	e0bfe717 	ldw	r2,-100(fp)
 3235a84:	10c01715 	stw	r3,92(r2)
         so->so_oobmark = so->so_rcv.sb_cc +
 3235a88:	e0bfe517 	ldw	r2,-108(fp)
 3235a8c:	11000a17 	ldw	r4,40(r2)
 3235a90:	e0bfe717 	ldw	r2,-100(fp)
 3235a94:	10c01717 	ldw	r3,92(r2)
 3235a98:	e0bfe717 	ldw	r2,-100(fp)
 3235a9c:	10801617 	ldw	r2,88(r2)
 3235aa0:	1885c83a 	sub	r2,r3,r2
 3235aa4:	2085883a 	add	r2,r4,r2
 3235aa8:	10ffffc4 	addi	r3,r2,-1
 3235aac:	e0bfe517 	ldw	r2,-108(fp)
 3235ab0:	10c01a15 	stw	r3,104(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
         if (so->so_oobmark == 0)
 3235ab4:	e0bfe517 	ldw	r2,-108(fp)
 3235ab8:	10801a17 	ldw	r2,104(r2)
 3235abc:	1004c03a 	cmpne	r2,r2,zero
 3235ac0:	1000061e 	bne	r2,zero,3235adc <tcp_input+0x2010>
            so->so_state |= SS_RCVATMARK;
 3235ac4:	e0bfe517 	ldw	r2,-108(fp)
 3235ac8:	1080088b 	ldhu	r2,34(r2)
 3235acc:	10801014 	ori	r2,r2,64
 3235ad0:	1007883a 	mov	r3,r2
 3235ad4:	e0bfe517 	ldw	r2,-108(fp)
 3235ad8:	10c0088d 	sth	r3,34(r2)
         sohasoutofband(so);
 3235adc:	e13fe517 	ldw	r4,-108(fp)
 3235ae0:	3231a540 	call	3231a54 <sohasoutofband>
         tp->t_oobflags &= ~(TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 3235ae4:	e0bfe717 	ldw	r2,-100(fp)
 3235ae8:	10c02403 	ldbu	r3,144(r2)
 3235aec:	00bfff04 	movi	r2,-4
 3235af0:	1884703a 	and	r2,r3,r2
 3235af4:	1007883a 	mov	r3,r2
 3235af8:	e0bfe717 	ldw	r2,-100(fp)
 3235afc:	10c02405 	stb	r3,144(r2)
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 3235b00:	e0bfed17 	ldw	r2,-76(fp)
 3235b04:	10c0098b 	ldhu	r3,38(r2)
 3235b08:	e0bfed17 	ldw	r2,-76(fp)
 3235b0c:	1080028b 	ldhu	r2,10(r2)
 3235b10:	18ffffcc 	andi	r3,r3,65535
 3235b14:	10bfffcc 	andi	r2,r2,65535
 3235b18:	10c01536 	bltu	r2,r3,3235b70 <tcp_input+0x20a4>
 3235b1c:	e0bfe517 	ldw	r2,-108(fp)
 3235b20:	10800417 	ldw	r2,16(r2)
 3235b24:	1080400c 	andi	r2,r2,256
 3235b28:	1004c03a 	cmpne	r2,r2,zero
 3235b2c:	1000101e 	bne	r2,zero,3235b70 <tcp_input+0x20a4>
#ifdef SO_OOBINLINE
       && (so->so_options & SO_OOBINLINE) == 0
#endif
       )
      {
         tcp_pulloutofband(so, ti, m);
 3235b30:	e13fe517 	ldw	r4,-108(fp)
 3235b34:	e17fed17 	ldw	r5,-76(fp)
 3235b38:	e1bff017 	ldw	r6,-64(fp)
 3235b3c:	32361b00 	call	32361b0 <tcp_pulloutofband>
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 3235b40:	00000b06 	br	3235b70 <tcp_input+0x20a4>
      /*
       * If no out of band data is expected,
       * pull receive urgent pointer along
       * with the receive window.
       */
   if (SEQ_GT(tp->rcv_nxt, tp->rcv_up))
 3235b44:	e0bfe717 	ldw	r2,-100(fp)
 3235b48:	10c01617 	ldw	r3,88(r2)
 3235b4c:	e0bfe717 	ldw	r2,-100(fp)
 3235b50:	10801717 	ldw	r2,92(r2)
 3235b54:	1885c83a 	sub	r2,r3,r2
 3235b58:	10800050 	cmplti	r2,r2,1
 3235b5c:	1000041e 	bne	r2,zero,3235b70 <tcp_input+0x20a4>
      tp->rcv_up = tp->rcv_nxt;
 3235b60:	e0bfe717 	ldw	r2,-100(fp)
 3235b64:	10c01617 	ldw	r3,88(r2)
 3235b68:	e0bfe717 	ldw	r2,-100(fp)
 3235b6c:	10c01715 	stw	r3,92(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 3235b70:	e0bfed17 	ldw	r2,-76(fp)
 3235b74:	1080028b 	ldhu	r2,10(r2)
 3235b78:	10bfffcc 	andi	r2,r2,65535
 3235b7c:	1004c03a 	cmpne	r2,r2,zero
 3235b80:	1000051e 	bne	r2,zero,3235b98 <tcp_input+0x20cc>
 3235b84:	e0bfe617 	ldw	r2,-104(fp)
 3235b88:	1080004c 	andi	r2,r2,1
 3235b8c:	10803fcc 	andi	r2,r2,255
 3235b90:	1005003a 	cmpeq	r2,r2,zero
 3235b94:	10005c1e 	bne	r2,zero,3235d08 <tcp_input+0x223c>
 3235b98:	e0bfe717 	ldw	r2,-100(fp)
 3235b9c:	10800217 	ldw	r2,8(r2)
 3235ba0:	10800288 	cmpgei	r2,r2,10
 3235ba4:	1000581e 	bne	r2,zero,3235d08 <tcp_input+0x223c>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 3235ba8:	e0bfed17 	ldw	r2,-76(fp)
 3235bac:	10c00617 	ldw	r3,24(r2)
 3235bb0:	e0bfe717 	ldw	r2,-100(fp)
 3235bb4:	10801617 	ldw	r2,88(r2)
 3235bb8:	1880351e 	bne	r3,r2,3235c90 <tcp_input+0x21c4>
 3235bbc:	e0bfe717 	ldw	r2,-100(fp)
 3235bc0:	10c00017 	ldw	r3,0(r2)
 3235bc4:	e0bfe717 	ldw	r2,-100(fp)
 3235bc8:	1880311e 	bne	r3,r2,3235c90 <tcp_input+0x21c4>
 3235bcc:	e0bfe717 	ldw	r2,-100(fp)
 3235bd0:	10800217 	ldw	r2,8(r2)
 3235bd4:	10800118 	cmpnei	r2,r2,4
 3235bd8:	10002d1e 	bne	r2,zero,3235c90 <tcp_input+0x21c4>
         else
         {
            tp->t_flags |= TF_ACKNOW;
         }
#else    /* not DO_DELAY_ACKS */
            tp->t_flags |= TF_ACKNOW;
 3235bdc:	e0bfe717 	ldw	r2,-100(fp)
 3235be0:	10800b0b 	ldhu	r2,44(r2)
 3235be4:	10800054 	ori	r2,r2,1
 3235be8:	1007883a 	mov	r3,r2
 3235bec:	e0bfe717 	ldw	r2,-100(fp)
 3235bf0:	10c00b0d 	sth	r3,44(r2)
#endif   /* DO_DELAY_ACKS */

         tp->rcv_nxt += ti->ti_len;
 3235bf4:	e0bfe717 	ldw	r2,-100(fp)
 3235bf8:	10c01617 	ldw	r3,88(r2)
 3235bfc:	e0bfed17 	ldw	r2,-76(fp)
 3235c00:	1080028b 	ldhu	r2,10(r2)
 3235c04:	10bfffcc 	andi	r2,r2,65535
 3235c08:	1887883a 	add	r3,r3,r2
 3235c0c:	e0bfe717 	ldw	r2,-100(fp)
 3235c10:	10c01615 	stw	r3,88(r2)
         tiflags = ti->ti_flags & TH_FIN;
 3235c14:	e0bfed17 	ldw	r2,-76(fp)
 3235c18:	10800843 	ldbu	r2,33(r2)
 3235c1c:	10803fcc 	andi	r2,r2,255
 3235c20:	1080004c 	andi	r2,r2,1
 3235c24:	e0bfe615 	stw	r2,-104(fp)
         tcpstat.tcps_rcvpack++;
 3235c28:	0080c9b4 	movhi	r2,806
 3235c2c:	10b4b504 	addi	r2,r2,-11564
 3235c30:	10801a17 	ldw	r2,104(r2)
 3235c34:	10c00044 	addi	r3,r2,1
 3235c38:	0080c9b4 	movhi	r2,806
 3235c3c:	10b4b504 	addi	r2,r2,-11564
 3235c40:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 3235c44:	0080c9b4 	movhi	r2,806
 3235c48:	10b4b504 	addi	r2,r2,-11564
 3235c4c:	10c01b17 	ldw	r3,108(r2)
 3235c50:	e0bfed17 	ldw	r2,-76(fp)
 3235c54:	1080028b 	ldhu	r2,10(r2)
 3235c58:	10bfffcc 	andi	r2,r2,65535
 3235c5c:	1887883a 	add	r3,r3,r2
 3235c60:	0080c9b4 	movhi	r2,806
 3235c64:	10b4b504 	addi	r2,r2,-11564
 3235c68:	10c01b15 	stw	r3,108(r2)
         sbappend(&so->so_rcv, (m));
 3235c6c:	e0bfe517 	ldw	r2,-108(fp)
 3235c70:	11000a04 	addi	r4,r2,40
 3235c74:	e17ff017 	ldw	r5,-64(fp)
 3235c78:	32324340 	call	3232434 <sbappend>
         sorwakeup(so);
 3235c7c:	e0bfe517 	ldw	r2,-108(fp)
 3235c80:	11400a04 	addi	r5,r2,40
 3235c84:	e13fe517 	ldw	r4,-108(fp)
 3235c88:	32322700 	call	3232270 <sbwakeup>
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 3235c8c:	00000b06 	br	3235cbc <tcp_input+0x21f0>
#endif /* TCP_SACK */
      }
      else     /* received out of sequence segment */
      {
         /* Drop it in the reassmbly queue */
         tiflags = tcp_reass(tp, ti, m);
 3235c90:	e13fe717 	ldw	r4,-100(fp)
 3235c94:	e17fed17 	ldw	r5,-76(fp)
 3235c98:	e1bff017 	ldw	r6,-64(fp)
 3235c9c:	32336c40 	call	32336c4 <tcp_reass>
 3235ca0:	e0bfe615 	stw	r2,-104(fp)
         tp->t_flags |= TF_ACKNOW;
 3235ca4:	e0bfe717 	ldw	r2,-100(fp)
 3235ca8:	10800b0b 	ldhu	r2,44(r2)
 3235cac:	10800054 	ori	r2,r2,1
 3235cb0:	1007883a 	mov	r3,r2
 3235cb4:	e0bfe717 	ldw	r2,-100(fp)
 3235cb8:	10c00b0d 	sth	r3,44(r2)
      /*
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
 3235cbc:	e0bfe517 	ldw	r2,-108(fp)
 3235cc0:	11000b17 	ldw	r4,44(r2)
 3235cc4:	e0bfe717 	ldw	r2,-100(fp)
 3235cc8:	10c01917 	ldw	r3,100(r2)
 3235ccc:	e0bfe717 	ldw	r2,-100(fp)
 3235cd0:	10801617 	ldw	r2,88(r2)
 3235cd4:	1885c83a 	sub	r2,r3,r2
 3235cd8:	2085c83a 	sub	r2,r4,r2
 3235cdc:	e0bfea15 	stw	r2,-88(fp)
      if (len > (int)tp->max_rcvd)
 3235ce0:	e0bfe717 	ldw	r2,-100(fp)
 3235ce4:	10802217 	ldw	r2,136(r2)
 3235ce8:	1007883a 	mov	r3,r2
 3235cec:	e0bfea17 	ldw	r2,-88(fp)
 3235cf0:	18800b0e 	bge	r3,r2,3235d20 <tcp_input+0x2254>
         tp->max_rcvd = (u_short)len;
 3235cf4:	e0bfea17 	ldw	r2,-88(fp)
 3235cf8:	10ffffcc 	andi	r3,r2,65535
 3235cfc:	e0bfe717 	ldw	r2,-100(fp)
 3235d00:	10c02215 	stw	r3,136(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 3235d04:	00000606 	br	3235d20 <tcp_input+0x2254>
      }
#endif   /* TCP_ZEROCOPY */
   } 
   else
   {
      m_freem(m);
 3235d08:	e13ff017 	ldw	r4,-64(fp)
 3235d0c:	322bfcc0 	call	322bfcc <m_freem>
      tiflags &= ~TH_FIN;
 3235d10:	e0bfe617 	ldw	r2,-104(fp)
 3235d14:	00ffff84 	movi	r3,-2
 3235d18:	10c4703a 	and	r2,r2,r3
 3235d1c:	e0bfe615 	stw	r2,-104(fp)

   /*
    * If FIN is received ACK the FIN and let the user know
    * that the connection is closing.
    */
   if (tiflags & TH_FIN) 
 3235d20:	e0bfe617 	ldw	r2,-104(fp)
 3235d24:	1080004c 	andi	r2,r2,1
 3235d28:	10803fcc 	andi	r2,r2,255
 3235d2c:	1005003a 	cmpeq	r2,r2,zero
 3235d30:	1000471e 	bne	r2,zero,3235e50 <tcp_input+0x2384>
   {
      if (TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 3235d34:	e0bfe717 	ldw	r2,-100(fp)
 3235d38:	10800217 	ldw	r2,8(r2)
 3235d3c:	10800288 	cmpgei	r2,r2,10
 3235d40:	10000d1e 	bne	r2,zero,3235d78 <tcp_input+0x22ac>
      {
         socantrcvmore(so);
 3235d44:	e13fe517 	ldw	r4,-108(fp)
 3235d48:	32321800 	call	3232180 <socantrcvmore>
         tp->t_flags |= TF_ACKNOW;
 3235d4c:	e0bfe717 	ldw	r2,-100(fp)
 3235d50:	10800b0b 	ldhu	r2,44(r2)
 3235d54:	10800054 	ori	r2,r2,1
 3235d58:	1007883a 	mov	r3,r2
 3235d5c:	e0bfe717 	ldw	r2,-100(fp)
 3235d60:	10c00b0d 	sth	r3,44(r2)
         tp->rcv_nxt++;
 3235d64:	e0bfe717 	ldw	r2,-100(fp)
 3235d68:	10801617 	ldw	r2,88(r2)
 3235d6c:	10c00044 	addi	r3,r2,1
 3235d70:	e0bfe717 	ldw	r2,-100(fp)
 3235d74:	10c01615 	stw	r3,88(r2)
      }
      switch (tp->t_state) 
 3235d78:	e0bfe717 	ldw	r2,-100(fp)
 3235d7c:	10800217 	ldw	r2,8(r2)
 3235d80:	10bfff44 	addi	r2,r2,-3
 3235d84:	e0bfff15 	stw	r2,-4(fp)
 3235d88:	e0ffff17 	ldw	r3,-4(fp)
 3235d8c:	18800228 	cmpgeui	r2,r3,8
 3235d90:	10002f1e 	bne	r2,zero,3235e50 <tcp_input+0x2384>
 3235d94:	e13fff17 	ldw	r4,-4(fp)
 3235d98:	e13fff17 	ldw	r4,-4(fp)
 3235d9c:	2105883a 	add	r2,r4,r4
 3235da0:	1087883a 	add	r3,r2,r2
 3235da4:	0080c8f4 	movhi	r2,803
 3235da8:	10976e04 	addi	r2,r2,23992
 3235dac:	1885883a 	add	r2,r3,r2
 3235db0:	10800017 	ldw	r2,0(r2)
 3235db4:	1000683a 	jmp	r2
 3235db8:	03235dd8 	cmpnei	r12,zero,-29321
 3235dbc:	03235dd8 	cmpnei	r12,zero,-29321
 3235dc0:	03235e50 	cmplti	r12,zero,-29319
 3235dc4:	03235de8 	cmpgeui	r12,zero,36215
 3235dc8:	03235e50 	cmplti	r12,zero,-29319
 3235dcc:	03235e50 	cmplti	r12,zero,-29319
 3235dd0:	03235df8 	rdprs	r12,zero,-29321
 3235dd4:	03235e34 	movhi	r12,36216
       * In SYN_RECEIVED and ESTABLISHED STATES
       * enter the CLOSE_WAIT state.
       */
      case TCPS_SYN_RECEIVED:
      case TCPS_ESTABLISHED:
         tp->t_state = TCPS_CLOSE_WAIT;
 3235dd8:	e0ffe717 	ldw	r3,-100(fp)
 3235ddc:	00800144 	movi	r2,5
 3235de0:	18800215 	stw	r2,8(r3)
         break;
 3235de4:	00001a06 	br	3235e50 <tcp_input+0x2384>
       /*
       * If still in FIN_WAIT_1 STATE FIN has not been acked so
       * enter the CLOSING state.
       */
      case TCPS_FIN_WAIT_1:
         tp->t_state = TCPS_CLOSING;
 3235de8:	e0ffe717 	ldw	r3,-100(fp)
 3235dec:	008001c4 	movi	r2,7
 3235df0:	18800215 	stw	r2,8(r3)
         break;
 3235df4:	00001606 	br	3235e50 <tcp_input+0x2384>
       * In FIN_WAIT_2 state enter the TIME_WAIT state,
       * starting the time-wait timer, turning off the other 
       * standard timers.
       */
      case TCPS_FIN_WAIT_2:
         tp->t_state = TCPS_TIME_WAIT;
 3235df8:	e0ffe717 	ldw	r3,-100(fp)
 3235dfc:	00800284 	movi	r2,10
 3235e00:	18800215 	stw	r2,8(r3)
         tcp_canceltimers(tp);
 3235e04:	e13fe717 	ldw	r4,-100(fp)
 3235e08:	32386940 	call	3238694 <tcp_canceltimers>
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 3235e0c:	0080c974 	movhi	r2,805
 3235e10:	108a9904 	addi	r2,r2,10852
 3235e14:	10800017 	ldw	r2,0(r2)
 3235e18:	1085883a 	add	r2,r2,r2
 3235e1c:	1007883a 	mov	r3,r2
 3235e20:	e0bfe717 	ldw	r2,-100(fp)
 3235e24:	10c00615 	stw	r3,24(r2)
         soisdisconnected(so);
 3235e28:	e13fe517 	ldw	r4,-108(fp)
 3235e2c:	3231c8c0 	call	3231c8c <soisdisconnected>
         break;
 3235e30:	00000706 	br	3235e50 <tcp_input+0x2384>

      /*
       * In TIME_WAIT state restart the 2 MSL time_wait timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 3235e34:	0080c974 	movhi	r2,805
 3235e38:	108a9904 	addi	r2,r2,10852
 3235e3c:	10800017 	ldw	r2,0(r2)
 3235e40:	1085883a 	add	r2,r2,r2
 3235e44:	1007883a 	mov	r3,r2
 3235e48:	e0bfe717 	ldw	r2,-100(fp)
 3235e4c:	10c00615 	stw	r3,24(r2)
    ostate, tp, &tcp_saveti);
#endif
   /*
    * Return any desired output.
    */
   if (needoutput || (tp->t_flags & TF_ACKNOW))
 3235e50:	e0bfe117 	ldw	r2,-124(fp)
 3235e54:	1004c03a 	cmpne	r2,r2,zero
 3235e58:	1000071e 	bne	r2,zero,3235e78 <tcp_input+0x23ac>
 3235e5c:	e0bfe717 	ldw	r2,-100(fp)
 3235e60:	10800b0b 	ldhu	r2,44(r2)
 3235e64:	10bfffcc 	andi	r2,r2,65535
 3235e68:	1080004c 	andi	r2,r2,1
 3235e6c:	10803fcc 	andi	r2,r2,255
 3235e70:	1005003a 	cmpeq	r2,r2,zero
 3235e74:	1000651e 	bne	r2,zero,323600c <tcp_input+0x2540>
      (void) tcp_output(tp);
 3235e78:	e13fe717 	ldw	r4,-100(fp)
 3235e7c:	32366ac0 	call	32366ac <tcp_output>
   return;
 3235e80:	00006206 	br	323600c <tcp_input+0x2540>
dropafterack:
   /*
    * Generate an ACK dropping incoming segment if it occupies
    * sequence space, where the ACK reflects our state.
    */
   if (tiflags & TH_RST)
 3235e84:	e0bfe617 	ldw	r2,-104(fp)
 3235e88:	1080010c 	andi	r2,r2,4
 3235e8c:	1005003a 	cmpeq	r2,r2,zero
 3235e90:	1000031e 	bne	r2,zero,3235ea0 <tcp_input+0x23d4>
      GOTO_DROP;
 3235e94:	0081a904 	movi	r2,1700
 3235e98:	d0a8e915 	stw	r2,-23644(gp)
 3235e9c:	00004f06 	br	3235fdc <tcp_input+0x2510>
   m_freem (m);
 3235ea0:	e13ff017 	ldw	r4,-64(fp)
 3235ea4:	322bfcc0 	call	322bfcc <m_freem>
   tp->t_flags |= TF_ACKNOW;
 3235ea8:	e0bfe717 	ldw	r2,-100(fp)
 3235eac:	10800b0b 	ldhu	r2,44(r2)
 3235eb0:	10800054 	ori	r2,r2,1
 3235eb4:	1007883a 	mov	r3,r2
 3235eb8:	e0bfe717 	ldw	r2,-100(fp)
 3235ebc:	10c00b0d 	sth	r3,44(r2)
   (void) tcp_output (tp);
 3235ec0:	e13fe717 	ldw	r4,-100(fp)
 3235ec4:	32366ac0 	call	32366ac <tcp_output>
   return;
 3235ec8:	00005006 	br	323600c <tcp_input+0x2540>

dropwithreset:
   TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 3235ecc:	0080c9b4 	movhi	r2,806
 3235ed0:	10b48704 	addi	r2,r2,-11748
 3235ed4:	10800d17 	ldw	r2,52(r2)
 3235ed8:	10c00044 	addi	r3,r2,1
 3235edc:	0080c9b4 	movhi	r2,806
 3235ee0:	10b48704 	addi	r2,r2,-11748
 3235ee4:	10c00d15 	stw	r3,52(r2)
   if (om) 
 3235ee8:	e0bfeb17 	ldw	r2,-84(fp)
 3235eec:	1005003a 	cmpeq	r2,r2,zero
 3235ef0:	1000031e 	bne	r2,zero,3235f00 <tcp_input+0x2434>
   {
      (void) m_free(om);
 3235ef4:	e13feb17 	ldw	r4,-84(fp)
 3235ef8:	322be980 	call	322be98 <m_free>
      om = 0;
 3235efc:	e03feb15 	stw	zero,-84(fp)
   }

   /* Don't reset resets */
   if (tiflags & TH_RST)
 3235f00:	e0bfe617 	ldw	r2,-104(fp)
 3235f04:	1080010c 	andi	r2,r2,4
 3235f08:	1005003a 	cmpeq	r2,r2,zero
 3235f0c:	1000031e 	bne	r2,zero,3235f1c <tcp_input+0x2450>
      GOTO_DROP;
 3235f10:	0081ad04 	movi	r2,1716
 3235f14:	d0a8e915 	stw	r2,-23644(gp)
 3235f18:	00003006 	br	3235fdc <tcp_input+0x2510>
    * Generate a RST, dropping incoming segment.
    * Make ACK acceptable to originator of segment.
    * Don't bother to respond if destination was broadcast.
    */
#ifdef IP_V4
   if (in_broadcast(ti->ti_dst.s_addr))
 3235f1c:	e0bfed17 	ldw	r2,-76(fp)
 3235f20:	11000417 	ldw	r4,16(r2)
 3235f24:	322cff80 	call	322cff8 <in_broadcast>
 3235f28:	1005003a 	cmpeq	r2,r2,zero
 3235f2c:	1000031e 	bne	r2,zero,3235f3c <tcp_input+0x2470>
      GOTO_DROP;
 3235f30:	0081af44 	movi	r2,1725
 3235f34:	d0a8e915 	stw	r2,-23644(gp)
 3235f38:	00002806 	br	3235fdc <tcp_input+0x2510>
      IP6CPY(&(m->pkt->ip6_hdr->ip_src), &ip6_src);
      IP6CPY(&(m->pkt->ip6_hdr->ip_dest), &ip6_dst);
   }
#endif   /* IP_V6 */

   if (tiflags & TH_ACK)
 3235f3c:	e0bfe617 	ldw	r2,-104(fp)
 3235f40:	1080040c 	andi	r2,r2,16
 3235f44:	1005003a 	cmpeq	r2,r2,zero
 3235f48:	10000b1e 	bne	r2,zero,3235f78 <tcp_input+0x24ac>
      tcp_respond (tp, ti, (tcp_seq)0, ti->ti_ack, TH_RST, m);
 3235f4c:	e0bfed17 	ldw	r2,-76(fp)
 3235f50:	11c00717 	ldw	r7,28(r2)
 3235f54:	00800104 	movi	r2,4
 3235f58:	d8800015 	stw	r2,0(sp)
 3235f5c:	e0bff017 	ldw	r2,-64(fp)
 3235f60:	d8800115 	stw	r2,4(sp)
 3235f64:	e13fe717 	ldw	r4,-100(fp)
 3235f68:	e17fed17 	ldw	r5,-76(fp)
 3235f6c:	000d883a 	mov	r6,zero
 3235f70:	3237b7c0 	call	3237b7c <tcp_respond>
 3235f74:	00001306 	br	3235fc4 <tcp_input+0x24f8>
   else
   {
      if (tiflags & TH_SYN)
 3235f78:	e0bfe617 	ldw	r2,-104(fp)
 3235f7c:	1080008c 	andi	r2,r2,2
 3235f80:	1005003a 	cmpeq	r2,r2,zero
 3235f84:	1000051e 	bne	r2,zero,3235f9c <tcp_input+0x24d0>
         ti->ti_seq++;
 3235f88:	e0bfed17 	ldw	r2,-76(fp)
 3235f8c:	10800617 	ldw	r2,24(r2)
 3235f90:	10c00044 	addi	r3,r2,1
 3235f94:	e0bfed17 	ldw	r2,-76(fp)
 3235f98:	10c00615 	stw	r3,24(r2)
      tcp_respond(tp, ti, ti->ti_seq, (tcp_seq)0, TH_RST|TH_ACK, m);
 3235f9c:	e0bfed17 	ldw	r2,-76(fp)
 3235fa0:	11800617 	ldw	r6,24(r2)
 3235fa4:	00800504 	movi	r2,20
 3235fa8:	d8800015 	stw	r2,0(sp)
 3235fac:	e0bff017 	ldw	r2,-64(fp)
 3235fb0:	d8800115 	stw	r2,4(sp)
 3235fb4:	e13fe717 	ldw	r4,-100(fp)
 3235fb8:	e17fed17 	ldw	r5,-76(fp)
 3235fbc:	000f883a 	mov	r7,zero
 3235fc0:	3237b7c0 	call	3237b7c <tcp_respond>
   }
   /* destroy temporarily created socket */
   if (dropsocket)
 3235fc4:	e0bfe017 	ldw	r2,-128(fp)
 3235fc8:	1005003a 	cmpeq	r2,r2,zero
 3235fcc:	10000f1e 	bne	r2,zero,323600c <tcp_input+0x2540>
      (void) soabort(so);
 3235fd0:	e13fe517 	ldw	r4,-108(fp)
 3235fd4:	322fe600 	call	322fe60 <soabort>
   return;
 3235fd8:	00000c06 	br	323600c <tcp_input+0x2540>

drop:
   if (om)
 3235fdc:	e0bfeb17 	ldw	r2,-84(fp)
 3235fe0:	1005003a 	cmpeq	r2,r2,zero
 3235fe4:	1000021e 	bne	r2,zero,3235ff0 <tcp_input+0x2524>
      (void) m_free(om);
 3235fe8:	e13feb17 	ldw	r4,-84(fp)
 3235fec:	322be980 	call	322be98 <m_free>
#ifdef DO_TCPTRACE
   if (tp && (tp->t_inpcb->inp_socket->so_options & SO_DEBUG))
      tcp_trace("drop: state %d, tcpcb: %x, saveti: %x",
    ostate, tp, &tcp_saveti);
#endif
   m_freem(m);
 3235ff0:	e13ff017 	ldw	r4,-64(fp)
 3235ff4:	322bfcc0 	call	322bfcc <m_freem>
   /* destroy temporarily created socket */
   if (dropsocket)
 3235ff8:	e0bfe017 	ldw	r2,-128(fp)
 3235ffc:	1005003a 	cmpeq	r2,r2,zero
 3236000:	1000021e 	bne	r2,zero,323600c <tcp_input+0x2540>
      (void) soabort(so);
 3236004:	e13fe517 	ldw	r4,-108(fp)
 3236008:	322fe600 	call	322fe60 <soabort>
   return;
}
 323600c:	e037883a 	mov	sp,fp
 3236010:	dfc00117 	ldw	ra,4(sp)
 3236014:	df000017 	ldw	fp,0(sp)
 3236018:	dec00204 	addi	sp,sp,8
 323601c:	f800283a 	ret

03236020 <tcp_dooptions>:

void
tcp_dooptions(struct tcpcb * tp, 
   struct mbuf *  om,
   struct tcpiphdr * ti)
{
 3236020:	defff404 	addi	sp,sp,-48
 3236024:	dfc00b15 	stw	ra,44(sp)
 3236028:	df000a15 	stw	fp,40(sp)
 323602c:	df000a04 	addi	fp,sp,40
 3236030:	e13ffc15 	stw	r4,-16(fp)
 3236034:	e17ffd15 	stw	r5,-12(fp)
 3236038:	e1bffe15 	stw	r6,-8(fp)
   u_char * cp;   /* pointer into option buffer */
   int   opt;     /* current option code */
   int   optlen;  /* length of current option */
   int   cnt;     /* byte count left in header */
   struct socket * so = tp->t_inpcb->inp_socket;
 323603c:	e0bffc17 	ldw	r2,-16(fp)
 3236040:	10800d17 	ldw	r2,52(r2)
 3236044:	10800817 	ldw	r2,32(r2)
 3236048:	e0bff715 	stw	r2,-36(fp)
#ifdef TCP_TIMESTAMP
   int   gotstamp = FALSE;    /* TRUE if we got a timestamp */
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
 323604c:	e0bffd17 	ldw	r2,-12(fp)
 3236050:	10800317 	ldw	r2,12(r2)
 3236054:	e0bffb15 	stw	r2,-20(fp)
   cnt = om->m_len;
 3236058:	e0bffd17 	ldw	r2,-12(fp)
 323605c:	10800217 	ldw	r2,8(r2)
 3236060:	e0bff815 	stw	r2,-32(fp)
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 3236064:	00004806 	br	3236188 <tcp_dooptions+0x168>
   {
      opt = cp[0];
 3236068:	e0bffb17 	ldw	r2,-20(fp)
 323606c:	10800003 	ldbu	r2,0(r2)
 3236070:	10803fcc 	andi	r2,r2,255
 3236074:	e0bffa15 	stw	r2,-24(fp)
      if (opt == TCPOPT_EOL)
 3236078:	e0bffa17 	ldw	r2,-24(fp)
 323607c:	1005003a 	cmpeq	r2,r2,zero
 3236080:	1000441e 	bne	r2,zero,3236194 <tcp_dooptions+0x174>
         break;
      if (opt == TCPOPT_NOP)
 3236084:	e0bffa17 	ldw	r2,-24(fp)
 3236088:	10800058 	cmpnei	r2,r2,1
 323608c:	1000031e 	bne	r2,zero,323609c <tcp_dooptions+0x7c>
         optlen = 1;
 3236090:	00800044 	movi	r2,1
 3236094:	e0bff915 	stw	r2,-28(fp)
 3236098:	00000806 	br	32360bc <tcp_dooptions+0x9c>
      else 
      {
         optlen = cp[1];
 323609c:	e0bffb17 	ldw	r2,-20(fp)
 32360a0:	10800044 	addi	r2,r2,1
 32360a4:	10800003 	ldbu	r2,0(r2)
 32360a8:	10803fcc 	andi	r2,r2,255
 32360ac:	e0bff915 	stw	r2,-28(fp)
         if (optlen <= 0)
 32360b0:	e0bff917 	ldw	r2,-28(fp)
 32360b4:	10800050 	cmplti	r2,r2,1
 32360b8:	1000361e 	bne	r2,zero,3236194 <tcp_dooptions+0x174>
            break;
      }

      switch (opt) 
 32360bc:	e0bffa17 	ldw	r2,-24(fp)
 32360c0:	108000a0 	cmpeqi	r2,r2,2
 32360c4:	1000011e 	bne	r2,zero,32360cc <tcp_dooptions+0xac>
 32360c8:	00002606 	br	3236164 <tcp_dooptions+0x144>
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
 32360cc:	e0bff917 	ldw	r2,-28(fp)
 32360d0:	10800118 	cmpnei	r2,r2,4
 32360d4:	1000231e 	bne	r2,zero,3236164 <tcp_dooptions+0x144>
            continue;
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
 32360d8:	e0bffe17 	ldw	r2,-8(fp)
 32360dc:	10800843 	ldbu	r2,33(r2)
 32360e0:	10803fcc 	andi	r2,r2,255
 32360e4:	1080008c 	andi	r2,r2,2
 32360e8:	1005003a 	cmpeq	r2,r2,zero
 32360ec:	10001d1e 	bne	r2,zero,3236164 <tcp_dooptions+0x144>
            continue;
         mssval = *(u_short *)(cp + 2);
 32360f0:	e0bffb17 	ldw	r2,-20(fp)
 32360f4:	10800084 	addi	r2,r2,2
 32360f8:	1080000b 	ldhu	r2,0(r2)
 32360fc:	e0bff60d 	sth	r2,-40(fp)
         mssval = ntohs(mssval);
 3236100:	e0bff60b 	ldhu	r2,-40(fp)
 3236104:	1004d23a 	srli	r2,r2,8
 3236108:	10803fcc 	andi	r2,r2,255
 323610c:	1009883a 	mov	r4,r2
 3236110:	e0bff60b 	ldhu	r2,-40(fp)
 3236114:	1004923a 	slli	r2,r2,8
 3236118:	1007883a 	mov	r3,r2
 323611c:	00bfc004 	movi	r2,-256
 3236120:	1884703a 	and	r2,r3,r2
 3236124:	2084b03a 	or	r2,r4,r2
 3236128:	e0bff60d 	sth	r2,-40(fp)
         tp->t_maxseg = (u_short)MIN(mssval, (u_short)tcp_mss(so));
 323612c:	e13ff717 	ldw	r4,-36(fp)
 3236130:	32365900 	call	3236590 <tcp_mss>
 3236134:	10ffffcc 	andi	r3,r2,65535
 3236138:	e0bff60b 	ldhu	r2,-40(fp)
 323613c:	1880042e 	bgeu	r3,r2,3236150 <tcp_dooptions+0x130>
 3236140:	e13ff717 	ldw	r4,-36(fp)
 3236144:	32365900 	call	3236590 <tcp_mss>
 3236148:	e0bfff0d 	sth	r2,-4(fp)
 323614c:	00000206 	br	3236158 <tcp_dooptions+0x138>
 3236150:	e0bff60b 	ldhu	r2,-40(fp)
 3236154:	e0bfff0d 	sth	r2,-4(fp)
 3236158:	e0bffc17 	ldw	r2,-16(fp)
 323615c:	e0ffff0b 	ldhu	r3,-4(fp)
 3236160:	10c00a0d 	sth	r3,40(r2)
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
   cnt = om->m_len;
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 3236164:	e0fff817 	ldw	r3,-32(fp)
 3236168:	e0bff917 	ldw	r2,-28(fp)
 323616c:	1885c83a 	sub	r2,r3,r2
 3236170:	e0bff815 	stw	r2,-32(fp)
 3236174:	e0bff917 	ldw	r2,-28(fp)
 3236178:	1007883a 	mov	r3,r2
 323617c:	e0bffb17 	ldw	r2,-20(fp)
 3236180:	10c5883a 	add	r2,r2,r3
 3236184:	e0bffb15 	stw	r2,-20(fp)
 3236188:	e0bff817 	ldw	r2,-32(fp)
 323618c:	10800048 	cmpgei	r2,r2,1
 3236190:	103fb51e 	bne	r2,zero,3236068 <tcp_dooptions+0x48>

      default:
         break;
      }
   }
   (void) m_free(om);
 3236194:	e13ffd17 	ldw	r4,-12(fp)
 3236198:	322be980 	call	322be98 <m_free>
         tp->t_flags &= ~TF_TIMESTAMP;
   }
#endif /* TCP_TIMESTAMP */

   return;
}
 323619c:	e037883a 	mov	sp,fp
 32361a0:	dfc00117 	ldw	ra,4(sp)
 32361a4:	df000017 	ldw	fp,0(sp)
 32361a8:	dec00204 	addi	sp,sp,8
 32361ac:	f800283a 	ret

032361b0 <tcp_pulloutofband>:

void
tcp_pulloutofband(struct socket * so, 
   struct tcpiphdr * ti,
   struct mbuf *  m)
{
 32361b0:	defff804 	addi	sp,sp,-32
 32361b4:	dfc00715 	stw	ra,28(sp)
 32361b8:	df000615 	stw	fp,24(sp)
 32361bc:	df000604 	addi	fp,sp,24
 32361c0:	e13ffd15 	stw	r4,-12(fp)
 32361c4:	e17ffe15 	stw	r5,-8(fp)
 32361c8:	e1bfff15 	stw	r6,-4(fp)
   int   cnt   =  ti->ti_urp  -  1;
 32361cc:	e0bffe17 	ldw	r2,-8(fp)
 32361d0:	1080098b 	ldhu	r2,38(r2)
 32361d4:	10bfffcc 	andi	r2,r2,65535
 32361d8:	10bfffc4 	addi	r2,r2,-1
 32361dc:	e0bffc15 	stw	r2,-16(fp)

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 32361e0:	00003306 	br	32362b0 <tcp_pulloutofband+0x100>
   {
      if (m->m_len > (unsigned)cnt) 
 32361e4:	e0bfff17 	ldw	r2,-4(fp)
 32361e8:	10c00217 	ldw	r3,8(r2)
 32361ec:	e0bffc17 	ldw	r2,-16(fp)
 32361f0:	10c0242e 	bgeu	r2,r3,3236284 <tcp_pulloutofband+0xd4>
      {
         char *   cp =  mtod(m,  char *) +  cnt;
 32361f4:	e0bfff17 	ldw	r2,-4(fp)
 32361f8:	10c00317 	ldw	r3,12(r2)
 32361fc:	e0bffc17 	ldw	r2,-16(fp)
 3236200:	1885883a 	add	r2,r3,r2
 3236204:	e0bffb15 	stw	r2,-20(fp)
         struct tcpcb * tp =  sototcpcb(so);
 3236208:	e0bffd17 	ldw	r2,-12(fp)
 323620c:	10800117 	ldw	r2,4(r2)
 3236210:	10800917 	ldw	r2,36(r2)
 3236214:	e0bffa15 	stw	r2,-24(fp)

         tp->t_iobc = *cp;
 3236218:	e0bffb17 	ldw	r2,-20(fp)
 323621c:	10c00003 	ldbu	r3,0(r2)
 3236220:	e0bffa17 	ldw	r2,-24(fp)
 3236224:	10c02445 	stb	r3,145(r2)
         tp->t_oobflags |= TCPOOB_HAVEDATA;
 3236228:	e0bffa17 	ldw	r2,-24(fp)
 323622c:	10802403 	ldbu	r2,144(r2)
 3236230:	10800054 	ori	r2,r2,1
 3236234:	1007883a 	mov	r3,r2
 3236238:	e0bffa17 	ldw	r2,-24(fp)
 323623c:	10c02405 	stb	r3,144(r2)
         MEMCPY(cp, cp+1, (unsigned)(m->m_len - cnt - 1));
 3236240:	e0bffb17 	ldw	r2,-20(fp)
 3236244:	11400044 	addi	r5,r2,1
 3236248:	e0bfff17 	ldw	r2,-4(fp)
 323624c:	10c00217 	ldw	r3,8(r2)
 3236250:	e0bffc17 	ldw	r2,-16(fp)
 3236254:	1885c83a 	sub	r2,r3,r2
 3236258:	10ffffc4 	addi	r3,r2,-1
 323625c:	e0bffb17 	ldw	r2,-20(fp)
 3236260:	1009883a 	mov	r4,r2
 3236264:	180d883a 	mov	r6,r3
 3236268:	3206ad00 	call	3206ad0 <memcpy>
         m->m_len--;
 323626c:	e0bfff17 	ldw	r2,-4(fp)
 3236270:	10800217 	ldw	r2,8(r2)
 3236274:	10ffffc4 	addi	r3,r2,-1
 3236278:	e0bfff17 	ldw	r2,-4(fp)
 323627c:	10c00215 	stw	r3,8(r2)
         return;
 3236280:	00001106 	br	32362c8 <tcp_pulloutofband+0x118>
      }
      cnt -= m->m_len;
 3236284:	e0fffc17 	ldw	r3,-16(fp)
 3236288:	e0bfff17 	ldw	r2,-4(fp)
 323628c:	10800217 	ldw	r2,8(r2)
 3236290:	1885c83a 	sub	r2,r3,r2
 3236294:	e0bffc15 	stw	r2,-16(fp)
      m = m->m_next;
 3236298:	e0bfff17 	ldw	r2,-4(fp)
 323629c:	10800617 	ldw	r2,24(r2)
 32362a0:	e0bfff15 	stw	r2,-4(fp)
      if (m == 0)
 32362a4:	e0bfff17 	ldw	r2,-4(fp)
 32362a8:	1005003a 	cmpeq	r2,r2,zero
 32362ac:	1000031e 	bne	r2,zero,32362bc <tcp_pulloutofband+0x10c>
   struct mbuf *  m)
{
   int   cnt   =  ti->ti_urp  -  1;

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 32362b0:	e0bffc17 	ldw	r2,-16(fp)
 32362b4:	1004403a 	cmpge	r2,r2,zero
 32362b8:	103fca1e 	bne	r2,zero,32361e4 <tcp_pulloutofband+0x34>
      cnt -= m->m_len;
      m = m->m_next;
      if (m == 0)
         break;
   }
   panic("tcp_pulloutofband");
 32362bc:	0100c974 	movhi	r4,805
 32362c0:	213e5804 	addi	r4,r4,-1696
 32362c4:	32261540 	call	3226154 <panic>
}
 32362c8:	e037883a 	mov	sp,fp
 32362cc:	dfc00117 	ldw	ra,4(sp)
 32362d0:	df000017 	ldw	fp,0(sp)
 32362d4:	dec00204 	addi	sp,sp,8
 32362d8:	f800283a 	ret

032362dc <tcp_xmit_timer>:
 * RETURNS: 
 */

void
tcp_xmit_timer(struct tcpcb * tp)
{
 32362dc:	defffb04 	addi	sp,sp,-20
 32362e0:	dfc00415 	stw	ra,16(sp)
 32362e4:	df000315 	stw	fp,12(sp)
 32362e8:	df000304 	addi	fp,sp,12
 32362ec:	e13fff15 	stw	r4,-4(fp)
   int delta;
   int rtt;

#ifdef NPDEBUG
   if(tp->t_rttick == 0){ dtrap(); return; }
 32362f0:	e0bfff17 	ldw	r2,-4(fp)
 32362f4:	10801e17 	ldw	r2,120(r2)
 32362f8:	1004c03a 	cmpne	r2,r2,zero
 32362fc:	1000021e 	bne	r2,zero,3236308 <tcp_xmit_timer+0x2c>
 3236300:	322aef00 	call	322aef0 <dtrap>
 3236304:	00008b06 	br	3236534 <tcp_xmit_timer+0x258>
#endif

   tcpstat.tcps_rttupdated++;
 3236308:	0080c9b4 	movhi	r2,806
 323630c:	10b4b504 	addi	r2,r2,-11564
 3236310:	10800717 	ldw	r2,28(r2)
 3236314:	10c00044 	addi	r3,r2,1
 3236318:	0080c9b4 	movhi	r2,806
 323631c:	10b4b504 	addi	r2,r2,-11564
 3236320:	10c00715 	stw	r3,28(r2)

   /* get  this rtt. Convert from cticks to TCP slow ticks */
   rtt = (int)((cticks - tp->t_rttick) / (TPS/2));
 3236324:	0080c974 	movhi	r2,805
 3236328:	10934104 	addi	r2,r2,19716
 323632c:	10c00017 	ldw	r3,0(r2)
 3236330:	e0bfff17 	ldw	r2,-4(fp)
 3236334:	10801e17 	ldw	r2,120(r2)
 3236338:	1889c83a 	sub	r4,r3,r2
 323633c:	01407d04 	movi	r5,500
 3236340:	32047c00 	call	32047c0 <__udivsi3>
 3236344:	e0bffd15 	stw	r2,-12(fp)
   if(tp->t_srtt != 0)
 3236348:	e0bfff17 	ldw	r2,-4(fp)
 323634c:	10802017 	ldw	r2,128(r2)
 3236350:	1005003a 	cmpeq	r2,r2,zero
 3236354:	10004a1e 	bne	r2,zero,3236480 <tcp_xmit_timer+0x1a4>
   {
      if(rtt == 0)      /* fast path for small round trip */
 3236358:	e0bffd17 	ldw	r2,-12(fp)
 323635c:	1004c03a 	cmpne	r2,r2,zero
 3236360:	1000131e 	bne	r2,zero,32363b0 <tcp_xmit_timer+0xd4>
      {
         /* if either the rtt or varience is over 1, reduce it. */
         if(tp->t_srtt > 1)
 3236364:	e0bfff17 	ldw	r2,-4(fp)
 3236368:	10802017 	ldw	r2,128(r2)
 323636c:	10800090 	cmplti	r2,r2,2
 3236370:	1000051e 	bne	r2,zero,3236388 <tcp_xmit_timer+0xac>
            tp->t_srtt--;
 3236374:	e0bfff17 	ldw	r2,-4(fp)
 3236378:	10802017 	ldw	r2,128(r2)
 323637c:	10ffffc4 	addi	r3,r2,-1
 3236380:	e0bfff17 	ldw	r2,-4(fp)
 3236384:	10c02015 	stw	r3,128(r2)
         if(tp->t_rttvar > 1)
 3236388:	e0bfff17 	ldw	r2,-4(fp)
 323638c:	10802117 	ldw	r2,132(r2)
 3236390:	10800090 	cmplti	r2,r2,2
 3236394:	1000481e 	bne	r2,zero,32364b8 <tcp_xmit_timer+0x1dc>
            tp->t_rttvar--;
 3236398:	e0bfff17 	ldw	r2,-4(fp)
 323639c:	10802117 	ldw	r2,132(r2)
 32363a0:	10ffffc4 	addi	r3,r2,-1
 32363a4:	e0bfff17 	ldw	r2,-4(fp)
 32363a8:	10c02115 	stw	r3,132(r2)
 32363ac:	00004206 	br	32364b8 <tcp_xmit_timer+0x1dc>
       * The following magic is equivalent
       * to the smoothing algorithm in rfc793
       * with an alpha of .875
       * (srtt = rtt/8 + srtt*7/8 in fixed point).
       */
      delta = ((rtt - 1) << 2) - (int)(tp->t_srtt >> 3);
 32363b0:	e0bffd17 	ldw	r2,-12(fp)
 32363b4:	10bfffc4 	addi	r2,r2,-1
 32363b8:	1085883a 	add	r2,r2,r2
 32363bc:	1085883a 	add	r2,r2,r2
 32363c0:	1007883a 	mov	r3,r2
 32363c4:	e0bfff17 	ldw	r2,-4(fp)
 32363c8:	10802017 	ldw	r2,128(r2)
 32363cc:	1005d0fa 	srai	r2,r2,3
 32363d0:	1885c83a 	sub	r2,r3,r2
 32363d4:	e0bffe15 	stw	r2,-8(fp)
      if ((tp->t_srtt += delta) <= 0)
 32363d8:	e0bfff17 	ldw	r2,-4(fp)
 32363dc:	10c02017 	ldw	r3,128(r2)
 32363e0:	e0bffe17 	ldw	r2,-8(fp)
 32363e4:	1887883a 	add	r3,r3,r2
 32363e8:	e0bfff17 	ldw	r2,-4(fp)
 32363ec:	10c02015 	stw	r3,128(r2)
 32363f0:	e0bfff17 	ldw	r2,-4(fp)
 32363f4:	10802017 	ldw	r2,128(r2)
 32363f8:	10800048 	cmpgei	r2,r2,1
 32363fc:	1000031e 	bne	r2,zero,323640c <tcp_xmit_timer+0x130>
         tp->t_srtt = 1;
 3236400:	e0ffff17 	ldw	r3,-4(fp)
 3236404:	00800044 	movi	r2,1
 3236408:	18802015 	stw	r2,128(r3)
       * (scaled by 4).  The following is equivalent
       * to rfc793 smoothing with an alpha of .75
       * (rttvar = rttvar*3/4 + |delta| / 4).
       * This replaces rfc793's wired-in beta.
       */
      if (delta < 0)
 323640c:	e0bffe17 	ldw	r2,-8(fp)
 3236410:	1004403a 	cmpge	r2,r2,zero
 3236414:	1000031e 	bne	r2,zero,3236424 <tcp_xmit_timer+0x148>
         delta = -delta;
 3236418:	e0bffe17 	ldw	r2,-8(fp)
 323641c:	0085c83a 	sub	r2,zero,r2
 3236420:	e0bffe15 	stw	r2,-8(fp)
      delta -= (short)(tp->t_rttvar >> 1);
 3236424:	e0bfff17 	ldw	r2,-4(fp)
 3236428:	10802117 	ldw	r2,132(r2)
 323642c:	1005d07a 	srai	r2,r2,1
 3236430:	10ffffcc 	andi	r3,r2,65535
 3236434:	18e0001c 	xori	r3,r3,32768
 3236438:	18e00004 	addi	r3,r3,-32768
 323643c:	e0bffe17 	ldw	r2,-8(fp)
 3236440:	10c5c83a 	sub	r2,r2,r3
 3236444:	e0bffe15 	stw	r2,-8(fp)
      if ((tp->t_rttvar += delta) <= 0)
 3236448:	e0bfff17 	ldw	r2,-4(fp)
 323644c:	10c02117 	ldw	r3,132(r2)
 3236450:	e0bffe17 	ldw	r2,-8(fp)
 3236454:	1887883a 	add	r3,r3,r2
 3236458:	e0bfff17 	ldw	r2,-4(fp)
 323645c:	10c02115 	stw	r3,132(r2)
 3236460:	e0bfff17 	ldw	r2,-4(fp)
 3236464:	10802117 	ldw	r2,132(r2)
 3236468:	10800048 	cmpgei	r2,r2,1
 323646c:	1000121e 	bne	r2,zero,32364b8 <tcp_xmit_timer+0x1dc>
         tp->t_rttvar = 1;
 3236470:	e0ffff17 	ldw	r3,-4(fp)
 3236474:	00800044 	movi	r2,1
 3236478:	18802115 	stw	r2,132(r3)
 323647c:	00000e06 	br	32364b8 <tcp_xmit_timer+0x1dc>
       * No rtt measurement yet - use the
       * unsmoothed rtt.  Set the variance
       * to half the rtt (so our first
       * retransmit happens at 2*rtt)
       */
      if(rtt < 1)
 3236480:	e0bffd17 	ldw	r2,-12(fp)
 3236484:	10800048 	cmpgei	r2,r2,1
 3236488:	1000021e 	bne	r2,zero,3236494 <tcp_xmit_timer+0x1b8>
         rtt = 1;
 323648c:	00800044 	movi	r2,1
 3236490:	e0bffd15 	stw	r2,-12(fp)
      tp->t_srtt = rtt << 3;
 3236494:	e0bffd17 	ldw	r2,-12(fp)
 3236498:	100690fa 	slli	r3,r2,3
 323649c:	e0bfff17 	ldw	r2,-4(fp)
 32364a0:	10c02015 	stw	r3,128(r2)
      tp->t_rttvar = rtt << 1;
 32364a4:	e0bffd17 	ldw	r2,-12(fp)
 32364a8:	1085883a 	add	r2,r2,r2
 32364ac:	1007883a 	mov	r3,r2
 32364b0:	e0bfff17 	ldw	r2,-4(fp)
 32364b4:	10c02115 	stw	r3,132(r2)
   }
   tp->t_rttick = 0;       /* clear RT timer */
 32364b8:	e0bfff17 	ldw	r2,-4(fp)
 32364bc:	10001e15 	stw	zero,120(r2)
   tp->t_rxtshift = 0;
 32364c0:	e0bfff17 	ldw	r2,-4(fp)
 32364c4:	10000715 	stw	zero,28(r2)
   TCPT_RANGESET(tp->t_rxtcur, 
 32364c8:	e0bfff17 	ldw	r2,-4(fp)
 32364cc:	10802017 	ldw	r2,128(r2)
 32364d0:	1007d0ba 	srai	r3,r2,2
 32364d4:	e0bfff17 	ldw	r2,-4(fp)
 32364d8:	10802117 	ldw	r2,132(r2)
 32364dc:	1885883a 	add	r2,r3,r2
 32364e0:	1005d07a 	srai	r2,r2,1
 32364e4:	10ffffcc 	andi	r3,r2,65535
 32364e8:	18e0001c 	xori	r3,r3,32768
 32364ec:	18e00004 	addi	r3,r3,-32768
 32364f0:	e0bfff17 	ldw	r2,-4(fp)
 32364f4:	10c00815 	stw	r3,32(r2)
 32364f8:	e0bfff17 	ldw	r2,-4(fp)
 32364fc:	10800817 	ldw	r2,32(r2)
 3236500:	10800088 	cmpgei	r2,r2,2
 3236504:	1000041e 	bne	r2,zero,3236518 <tcp_xmit_timer+0x23c>
 3236508:	e0ffff17 	ldw	r3,-4(fp)
 323650c:	00800084 	movi	r2,2
 3236510:	18800815 	stw	r2,32(r3)
 3236514:	00000706 	br	3236534 <tcp_xmit_timer+0x258>
 3236518:	e0bfff17 	ldw	r2,-4(fp)
 323651c:	10800817 	ldw	r2,32(r2)
 3236520:	10802050 	cmplti	r2,r2,129
 3236524:	1000031e 	bne	r2,zero,3236534 <tcp_xmit_timer+0x258>
 3236528:	e0ffff17 	ldw	r3,-4(fp)
 323652c:	00802004 	movi	r2,128
 3236530:	18800815 	stw	r2,32(r3)
    ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1,
    TCPTV_MIN, TCPTV_REXMTMAX);
}
 3236534:	e037883a 	mov	sp,fp
 3236538:	dfc00117 	ldw	ra,4(sp)
 323653c:	df000017 	ldw	fp,0(sp)
 3236540:	dec00204 	addi	sp,sp,8
 3236544:	f800283a 	ret

03236548 <ip4_tcpmss>:


#ifdef IP_V4
int
ip4_tcpmss(struct socket * so)
{
 3236548:	defffd04 	addi	sp,sp,-12
 323654c:	df000215 	stw	fp,8(sp)
 3236550:	df000204 	addi	fp,sp,8
 3236554:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = so->so_pcb->ifp;
 3236558:	e0bfff17 	ldw	r2,-4(fp)
 323655c:	10800117 	ldw	r2,4(r2)
 3236560:	10800a17 	ldw	r2,40(r2)
 3236564:	e0bffe15 	stw	r2,-8(fp)
   return(ifp->n_mtu - (40 + ifp->n_lnh));
 3236568:	e0bffe17 	ldw	r2,-8(fp)
 323656c:	10c00917 	ldw	r3,36(r2)
 3236570:	e0bffe17 	ldw	r2,-8(fp)
 3236574:	10800817 	ldw	r2,32(r2)
 3236578:	1885c83a 	sub	r2,r3,r2
 323657c:	10bff604 	addi	r2,r2,-40
}
 3236580:	e037883a 	mov	sp,fp
 3236584:	df000017 	ldw	fp,0(sp)
 3236588:	dec00104 	addi	sp,sp,4
 323658c:	f800283a 	ret

03236590 <tcp_mss>:
 */


int
tcp_mss(struct socket * so)
{
 3236590:	defff904 	addi	sp,sp,-28
 3236594:	dfc00615 	stw	ra,24(sp)
 3236598:	df000515 	stw	fp,20(sp)
 323659c:	df000504 	addi	fp,sp,20
 32365a0:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 32365a4:	e0bffe17 	ldw	r2,-8(fp)
 32365a8:	1005003a 	cmpeq	r2,r2,zero
 32365ac:	1000091e 	bne	r2,zero,32365d4 <tcp_mss+0x44>
 32365b0:	e0bffe17 	ldw	r2,-8(fp)
 32365b4:	10800117 	ldw	r2,4(r2)
 32365b8:	1005003a 	cmpeq	r2,r2,zero
 32365bc:	1000051e 	bne	r2,zero,32365d4 <tcp_mss+0x44>
 32365c0:	e0bffe17 	ldw	r2,-8(fp)
 32365c4:	10800117 	ldw	r2,4(r2)
 32365c8:	10800a17 	ldw	r2,40(r2)
 32365cc:	1004c03a 	cmpne	r2,r2,zero
 32365d0:	1000071e 	bne	r2,zero,32365f0 <tcp_mss+0x60>
       (so->so_pcb == NULL) ||
       (so->so_pcb->ifp == NULL))
   {
      if (so->so_domain == AF_INET)  /* IPv4 */
 32365d4:	e0bffe17 	ldw	r2,-8(fp)
 32365d8:	10800517 	ldw	r2,20(r2)
 32365dc:	10800098 	cmpnei	r2,r2,2
 32365e0:	1000031e 	bne	r2,zero,32365f0 <tcp_mss+0x60>
         return TCP_MSS;            /* user defined */
 32365e4:	00816d04 	movi	r2,1460
 32365e8:	e0bfff15 	stw	r2,-4(fp)
 32365ec:	00002906 	br	3236694 <tcp_mss+0x104>
#endif   /* IP_V6 */


#ifdef IP_V4   /* Begin messy domain defines */
#ifndef IP_V6  /* V4 only version */
   mss = ip4_tcpmss(so);
 32365f0:	e13ffe17 	ldw	r4,-8(fp)
 32365f4:	32365480 	call	3236548 <ip4_tcpmss>
 32365f8:	e0bffd15 	stw	r2,-12(fp)
#endif         /* end of dual mode */
#else          /* no IP_v4, assume V6 only */
      mss = ip6_tcpmss(so, ifp);
#endif         /* end messy domain defines */

   if (mss > TCP_MSS)    /* check upper limit from compile */
 32365fc:	e0bffd17 	ldw	r2,-12(fp)
 3236600:	10816d50 	cmplti	r2,r2,1461
 3236604:	1000021e 	bne	r2,zero,3236610 <tcp_mss+0x80>
      mss = TCP_MSS;
 3236608:	00816d04 	movi	r2,1460
 323660c:	e0bffd15 	stw	r2,-12(fp)

   /* check upper limit which may be set by setsockopt() */
   inp = (struct inpcb *)so->so_pcb;         /* Map socket to IP cb */
 3236610:	e0bffe17 	ldw	r2,-8(fp)
 3236614:	10800117 	ldw	r2,4(r2)
 3236618:	e0bffc15 	stw	r2,-16(fp)
   tp = (struct tcpcb *)inp->inp_ppcb;       /* Map IP to TCP cb */
 323661c:	e0bffc17 	ldw	r2,-16(fp)
 3236620:	10800917 	ldw	r2,36(r2)
 3236624:	e0bffb15 	stw	r2,-20(fp)
   
   /* has user set max seg? */
   if (tp->t_flags & TF_MAXSEG)
 3236628:	e0bffb17 	ldw	r2,-20(fp)
 323662c:	10800b0b 	ldhu	r2,44(r2)
 3236630:	10bfffcc 	andi	r2,r2,65535
 3236634:	1081000c 	andi	r2,r2,1024
 3236638:	1005003a 	cmpeq	r2,r2,zero
 323663c:	1000051e 	bne	r2,zero,3236654 <tcp_mss+0xc4>
      return tp->t_maxseg;    /* yup */
 3236640:	e0bffb17 	ldw	r2,-20(fp)
 3236644:	10800a0b 	ldhu	r2,40(r2)
 3236648:	10bfffcc 	andi	r2,r2,65535
 323664c:	e0bfff15 	stw	r2,-4(fp)
 3236650:	00001006 	br	3236694 <tcp_mss+0x104>
      
   if (tp->t_maxseg && (mss > tp->t_maxseg))  /* check tcp's mss */
 3236654:	e0bffb17 	ldw	r2,-20(fp)
 3236658:	10800a0b 	ldhu	r2,40(r2)
 323665c:	10bfffcc 	andi	r2,r2,65535
 3236660:	1005003a 	cmpeq	r2,r2,zero
 3236664:	1000091e 	bne	r2,zero,323668c <tcp_mss+0xfc>
 3236668:	e0bffb17 	ldw	r2,-20(fp)
 323666c:	10800a0b 	ldhu	r2,40(r2)
 3236670:	10ffffcc 	andi	r3,r2,65535
 3236674:	e0bffd17 	ldw	r2,-12(fp)
 3236678:	1880040e 	bge	r3,r2,323668c <tcp_mss+0xfc>
   {
      mss = tp->t_maxseg;        /* limit new MSS to set MSS */
 323667c:	e0bffb17 	ldw	r2,-20(fp)
 3236680:	10800a0b 	ldhu	r2,40(r2)
 3236684:	10bfffcc 	andi	r2,r2,65535
 3236688:	e0bffd15 	stw	r2,-12(fp)
   }

   return mss;
 323668c:	e0bffd17 	ldw	r2,-12(fp)
 3236690:	e0bfff15 	stw	r2,-4(fp)
 3236694:	e0bfff17 	ldw	r2,-4(fp)
}
 3236698:	e037883a 	mov	sp,fp
 323669c:	dfc00117 	ldw	ra,4(sp)
 32366a0:	df000017 	ldw	fp,0(sp)
 32366a4:	dec00204 	addi	sp,sp,8
 32366a8:	f800283a 	ret

032366ac <tcp_output>:
 * RETURNS: 0 if OK, else a sockets error code.
 */

int
tcp_output(struct tcpcb * tp)
{
 32366ac:	deffe004 	addi	sp,sp,-128
 32366b0:	dfc01f15 	stw	ra,124(sp)
 32366b4:	df001e15 	stw	fp,120(sp)
 32366b8:	df001e04 	addi	fp,sp,120
 32366bc:	e13ff715 	stw	r4,-36(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 32366c0:	e0bff717 	ldw	r2,-36(fp)
 32366c4:	10800d17 	ldw	r2,52(r2)
 32366c8:	10800817 	ldw	r2,32(r2)
 32366cc:	e0bff515 	stw	r2,-44(fp)
   int   len;
   long  win;
   int   off,  flags,   error;
   struct mbuf *  m;
   struct tcpiphdr * ti;
   unsigned optlen = 0;
 32366d0:	e03fed15 	stw	zero,-76(fp)
    * Determine length of data that should be transmitted,
    * and flags that will be used.
    * If there is some data or critical controls (SYN, RST)
    * to send, then transmit; otherwise, investigate further.
    */
   idle = (tp->snd_max == tp->snd_una);
 32366d4:	e0bff717 	ldw	r2,-36(fp)
 32366d8:	10c01a17 	ldw	r3,104(r2)
 32366dc:	e0bff717 	ldw	r2,-36(fp)
 32366e0:	10800e17 	ldw	r2,56(r2)
 32366e4:	1885003a 	cmpeq	r2,r3,r2
 32366e8:	e0bfec15 	stw	r2,-80(fp)

again:
   sendalot = 0;
 32366ec:	e03feb15 	stw	zero,-84(fp)
   off = (int)(tp->snd_nxt - tp->snd_una);
 32366f0:	e0bff717 	ldw	r2,-36(fp)
 32366f4:	10c00f17 	ldw	r3,60(r2)
 32366f8:	e0bff717 	ldw	r2,-36(fp)
 32366fc:	10800e17 	ldw	r2,56(r2)
 3236700:	1885c83a 	sub	r2,r3,r2
 3236704:	e0bff215 	stw	r2,-56(fp)
   win = (long)tp->snd_wnd;   /* set basic send window */
 3236708:	e0bff717 	ldw	r2,-36(fp)
 323670c:	10801417 	ldw	r2,80(r2)
 3236710:	e0bff315 	stw	r2,-52(fp)
   if (win > (long)tp->snd_cwnd) /* see if we need congestion control */
 3236714:	e0bff717 	ldw	r2,-36(fp)
 3236718:	10801b17 	ldw	r2,108(r2)
 323671c:	1007883a 	mov	r3,r2
 3236720:	e0bff317 	ldw	r2,-52(fp)
 3236724:	1880060e 	bge	r3,r2,3236740 <tcp_output+0x94>
   {
      win = (int)(tp->snd_cwnd & ~(ALIGN_TYPE-1)); /* keep data aligned */
 3236728:	e0bff717 	ldw	r2,-36(fp)
 323672c:	10801b17 	ldw	r2,108(r2)
 3236730:	1007883a 	mov	r3,r2
 3236734:	00bfff04 	movi	r2,-4
 3236738:	1884703a 	and	r2,r3,r2
 323673c:	e0bff315 	stw	r2,-52(fp)
    * If in persist timeout with window of 0, send 1 byte.
    * Otherwise, if window is small but nonzero
    * and timer expired, we will send what we can
    * and go to transmit state.
    */
   if (tp->t_force) 
 3236740:	e0bff717 	ldw	r2,-36(fp)
 3236744:	10800a83 	ldbu	r2,42(r2)
 3236748:	10803fcc 	andi	r2,r2,255
 323674c:	1080201c 	xori	r2,r2,128
 3236750:	10bfe004 	addi	r2,r2,-128
 3236754:	1005003a 	cmpeq	r2,r2,zero
 3236758:	10000a1e 	bne	r2,zero,3236784 <tcp_output+0xd8>
   {
      if (win == 0)
 323675c:	e0bff317 	ldw	r2,-52(fp)
 3236760:	1004c03a 	cmpne	r2,r2,zero
 3236764:	1000031e 	bne	r2,zero,3236774 <tcp_output+0xc8>
         win = 1;
 3236768:	00800044 	movi	r2,1
 323676c:	e0bff315 	stw	r2,-52(fp)
 3236770:	00000406 	br	3236784 <tcp_output+0xd8>
      else 
      {
         tp->t_timer[TCPT_PERSIST] = 0;
 3236774:	e0bff717 	ldw	r2,-36(fp)
 3236778:	10000415 	stw	zero,16(r2)
         tp->t_rxtshift = 0;
 323677c:	e0bff717 	ldw	r2,-36(fp)
 3236780:	10000715 	stw	zero,28(r2)
   }
   else
#endif /* TCP_SACK */
   {
      /* set length of packets which are not sack resends */
      len = (int)MIN(so->so_snd.sb_cc, (unsigned)win) - off;
 3236784:	e0bff517 	ldw	r2,-44(fp)
 3236788:	10801217 	ldw	r2,72(r2)
 323678c:	e0fff317 	ldw	r3,-52(fp)
 3236790:	e0fffb15 	stw	r3,-20(fp)
 3236794:	e0bffa15 	stw	r2,-24(fp)
 3236798:	e0bffb17 	ldw	r2,-20(fp)
 323679c:	e0fffa17 	ldw	r3,-24(fp)
 32367a0:	10c0022e 	bgeu	r2,r3,32367ac <tcp_output+0x100>
 32367a4:	e0bffb17 	ldw	r2,-20(fp)
 32367a8:	e0bffa15 	stw	r2,-24(fp)
 32367ac:	e0fffa17 	ldw	r3,-24(fp)
 32367b0:	e0bff217 	ldw	r2,-56(fp)
 32367b4:	1885c83a 	sub	r2,r3,r2
 32367b8:	e0bff415 	stw	r2,-48(fp)
   }

   flags = tcp_outflags[tp->t_state];
 32367bc:	e0bff717 	ldw	r2,-36(fp)
 32367c0:	10c00217 	ldw	r3,8(r2)
 32367c4:	0080c974 	movhi	r2,805
 32367c8:	10895e04 	addi	r2,r2,9592
 32367cc:	10c5883a 	add	r2,r2,r3
 32367d0:	10800003 	ldbu	r2,0(r2)
 32367d4:	10803fcc 	andi	r2,r2,255
 32367d8:	e0bff115 	stw	r2,-60(fp)
   }
#else
   /* If other options not defined this build then don't bother to call bld_options() except 
    * on SYN packets
    */
   if(flags & TH_SYN)
 32367dc:	e0bff117 	ldw	r2,-60(fp)
 32367e0:	1080008c 	andi	r2,r2,2
 32367e4:	1005003a 	cmpeq	r2,r2,zero
 32367e8:	1000081e 	bne	r2,zero,323680c <tcp_output+0x160>
   {
      optlen = bld_options(tp, &tcp_optionbuf[optlen], flags, so);
 32367ec:	e0ffed17 	ldw	r3,-76(fp)
 32367f0:	d0a8ea04 	addi	r2,gp,-23640
 32367f4:	188b883a 	add	r5,r3,r2
 32367f8:	e13ff717 	ldw	r4,-36(fp)
 32367fc:	e1bff117 	ldw	r6,-60(fp)
 3236800:	e1fff517 	ldw	r7,-44(fp)
 3236804:	32379240 	call	3237924 <bld_options>
 3236808:	e0bfed15 	stw	r2,-76(fp)
   }
#endif

   if (len < 0)
 323680c:	e0bff417 	ldw	r2,-48(fp)
 3236810:	1004403a 	cmpge	r2,r2,zero
 3236814:	10000a1e 	bne	r2,zero,3236840 <tcp_output+0x194>
       * cancel pending retransmit and pull snd_nxt
       * back to (closed) window.  We will enter persist
       * state below.  If the window didn't close completely,
       * just wait for an ACK.
       */
      len = 0;
 3236818:	e03ff415 	stw	zero,-48(fp)
      if (win == 0) 
 323681c:	e0bff317 	ldw	r2,-52(fp)
 3236820:	1004c03a 	cmpne	r2,r2,zero
 3236824:	1000061e 	bne	r2,zero,3236840 <tcp_output+0x194>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 3236828:	e0bff717 	ldw	r2,-36(fp)
 323682c:	10000315 	stw	zero,12(r2)
         tp->snd_nxt = tp->snd_una;
 3236830:	e0bff717 	ldw	r2,-36(fp)
 3236834:	10c00e17 	ldw	r3,56(r2)
 3236838:	e0bff717 	ldw	r2,-36(fp)
 323683c:	10c00f15 	stw	r3,60(r2)
      }
   }

   if (len > (int)tp->t_maxseg)
 3236840:	e0bff717 	ldw	r2,-36(fp)
 3236844:	10800a0b 	ldhu	r2,40(r2)
 3236848:	10ffffcc 	andi	r3,r2,65535
 323684c:	e0bff417 	ldw	r2,-48(fp)
 3236850:	1880060e 	bge	r3,r2,323686c <tcp_output+0x1c0>
   {
      len = tp->t_maxseg;
 3236854:	e0bff717 	ldw	r2,-36(fp)
 3236858:	10800a0b 	ldhu	r2,40(r2)
 323685c:	10bfffcc 	andi	r2,r2,65535
 3236860:	e0bff415 	stw	r2,-48(fp)
      sendalot = 1;
 3236864:	00800044 	movi	r2,1
 3236868:	e0bfeb15 	stw	r2,-84(fp)
   /* We don't need a pmtu test for IPv6. V6 code limits t_maxseg to
    * the Path MTU, so the test above the v4 ifdef above covers us.
    */
#endif /* IP_V4 */

   if (SEQ_LT(tp->snd_nxt + len, tp->snd_una + so->so_snd.sb_cc))
 323686c:	e0bff717 	ldw	r2,-36(fp)
 3236870:	10c00f17 	ldw	r3,60(r2)
 3236874:	e0bff417 	ldw	r2,-48(fp)
 3236878:	1889883a 	add	r4,r3,r2
 323687c:	e0bff717 	ldw	r2,-36(fp)
 3236880:	10c00e17 	ldw	r3,56(r2)
 3236884:	e0bff517 	ldw	r2,-44(fp)
 3236888:	10801217 	ldw	r2,72(r2)
 323688c:	1885883a 	add	r2,r3,r2
 3236890:	2085c83a 	sub	r2,r4,r2
 3236894:	1004403a 	cmpge	r2,r2,zero
 3236898:	1000041e 	bne	r2,zero,32368ac <tcp_output+0x200>
      flags &= ~TH_FIN;
 323689c:	e0bff117 	ldw	r2,-60(fp)
 32368a0:	00ffff84 	movi	r3,-2
 32368a4:	10c4703a 	and	r2,r2,r3
 32368a8:	e0bff115 	stw	r2,-60(fp)
   win = (long)(sbspace(&so->so_rcv));
 32368ac:	e0bff517 	ldw	r2,-44(fp)
 32368b0:	10800b17 	ldw	r2,44(r2)
 32368b4:	1007883a 	mov	r3,r2
 32368b8:	e0bff517 	ldw	r2,-44(fp)
 32368bc:	10800a17 	ldw	r2,40(r2)
 32368c0:	1885c83a 	sub	r2,r3,r2
 32368c4:	1004803a 	cmplt	r2,r2,zero
 32368c8:	1000071e 	bne	r2,zero,32368e8 <tcp_output+0x23c>
 32368cc:	e0bff517 	ldw	r2,-44(fp)
 32368d0:	10c00b17 	ldw	r3,44(r2)
 32368d4:	e0bff517 	ldw	r2,-44(fp)
 32368d8:	10800a17 	ldw	r2,40(r2)
 32368dc:	1885c83a 	sub	r2,r3,r2
 32368e0:	e0bff915 	stw	r2,-28(fp)
 32368e4:	00000106 	br	32368ec <tcp_output+0x240>
 32368e8:	e03ff915 	stw	zero,-28(fp)
 32368ec:	e0fff917 	ldw	r3,-28(fp)
 32368f0:	e0fff315 	stw	r3,-52(fp)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 32368f4:	e0bff117 	ldw	r2,-60(fp)
 32368f8:	1080004c 	andi	r2,r2,1
 32368fc:	10803fcc 	andi	r2,r2,255
 3236900:	1005003a 	cmpeq	r2,r2,zero
 3236904:	10000f1e 	bne	r2,zero,3236944 <tcp_output+0x298>
 3236908:	e0bff517 	ldw	r2,-44(fp)
 323690c:	10801217 	ldw	r2,72(r2)
 3236910:	1004c03a 	cmpne	r2,r2,zero
 3236914:	10000b1e 	bne	r2,zero,3236944 <tcp_output+0x298>
 3236918:	e0bff717 	ldw	r2,-36(fp)
 323691c:	10800b0b 	ldhu	r2,44(r2)
 3236920:	10bfffcc 	andi	r2,r2,65535
 3236924:	1080040c 	andi	r2,r2,16
 3236928:	1005003a 	cmpeq	r2,r2,zero
 323692c:	1000721e 	bne	r2,zero,3236af8 <tcp_output+0x44c>
 3236930:	e0bff717 	ldw	r2,-36(fp)
 3236934:	10c00f17 	ldw	r3,60(r2)
 3236938:	e0bff717 	ldw	r2,-36(fp)
 323693c:	10800e17 	ldw	r2,56(r2)
 3236940:	18806d26 	beq	r3,r2,3236af8 <tcp_output+0x44c>
      goto send;
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
 3236944:	e0bff717 	ldw	r2,-36(fp)
 3236948:	10800b0b 	ldhu	r2,44(r2)
 323694c:	10bfffcc 	andi	r2,r2,65535
 3236950:	1080004c 	andi	r2,r2,1
 3236954:	10803fcc 	andi	r2,r2,255
 3236958:	1004c03a 	cmpne	r2,r2,zero
 323695c:	1000661e 	bne	r2,zero,3236af8 <tcp_output+0x44c>
      goto send;
   if (flags & (TH_SYN|TH_RST))
 3236960:	e0bff117 	ldw	r2,-60(fp)
 3236964:	1080018c 	andi	r2,r2,6
 3236968:	1004c03a 	cmpne	r2,r2,zero
 323696c:	1000621e 	bne	r2,zero,3236af8 <tcp_output+0x44c>
      goto send;
   if (SEQ_GT(tp->snd_up, tp->snd_una))
 3236970:	e0bff717 	ldw	r2,-36(fp)
 3236974:	10c01017 	ldw	r3,64(r2)
 3236978:	e0bff717 	ldw	r2,-36(fp)
 323697c:	10800e17 	ldw	r2,56(r2)
 3236980:	1885c83a 	sub	r2,r3,r2
 3236984:	10800048 	cmpgei	r2,r2,1
 3236988:	10005b1e 	bne	r2,zero,3236af8 <tcp_output+0x44c>
    * If peer's buffer is tiny, then send
    * when window is at least half open.
    * If retransmitting (possibly after persist timer forced us
    * to send into a small window), then must resend.
    */
   if (len)
 323698c:	e0bff417 	ldw	r2,-48(fp)
 3236990:	1005003a 	cmpeq	r2,r2,zero
 3236994:	1000281e 	bne	r2,zero,3236a38 <tcp_output+0x38c>
   {
      if (len == (int)tp->t_maxseg)
 3236998:	e0bff717 	ldw	r2,-36(fp)
 323699c:	10800a0b 	ldhu	r2,40(r2)
 32369a0:	10ffffcc 	andi	r3,r2,65535
 32369a4:	e0bff417 	ldw	r2,-48(fp)
 32369a8:	18805326 	beq	r3,r2,3236af8 <tcp_output+0x44c>
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 32369ac:	e0bfec17 	ldw	r2,-80(fp)
 32369b0:	1004c03a 	cmpne	r2,r2,zero
 32369b4:	1000061e 	bne	r2,zero,32369d0 <tcp_output+0x324>
 32369b8:	e0bff717 	ldw	r2,-36(fp)
 32369bc:	10800b0b 	ldhu	r2,44(r2)
 32369c0:	10bfffcc 	andi	r2,r2,65535
 32369c4:	1080010c 	andi	r2,r2,4
 32369c8:	1005003a 	cmpeq	r2,r2,zero
 32369cc:	1000061e 	bne	r2,zero,32369e8 <tcp_output+0x33c>
 32369d0:	e0fff417 	ldw	r3,-48(fp)
 32369d4:	e0bff217 	ldw	r2,-56(fp)
 32369d8:	1887883a 	add	r3,r3,r2
 32369dc:	e0bff517 	ldw	r2,-44(fp)
 32369e0:	10801217 	ldw	r2,72(r2)
 32369e4:	1880440e 	bge	r3,r2,3236af8 <tcp_output+0x44c>
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
      }
      if (tp->t_force)
 32369e8:	e0bff717 	ldw	r2,-36(fp)
 32369ec:	10800a83 	ldbu	r2,42(r2)
 32369f0:	10803fcc 	andi	r2,r2,255
 32369f4:	1080201c 	xori	r2,r2,128
 32369f8:	10bfe004 	addi	r2,r2,-128
 32369fc:	1004c03a 	cmpne	r2,r2,zero
 3236a00:	10003d1e 	bne	r2,zero,3236af8 <tcp_output+0x44c>
         goto send;
      if (len >= (int)(tp->max_sndwnd / 2))
 3236a04:	e0bff717 	ldw	r2,-36(fp)
 3236a08:	10802317 	ldw	r2,140(r2)
 3236a0c:	1004d07a 	srli	r2,r2,1
 3236a10:	1007883a 	mov	r3,r2
 3236a14:	e0bff417 	ldw	r2,-48(fp)
 3236a18:	10c0370e 	bge	r2,r3,3236af8 <tcp_output+0x44c>
         goto send;
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
 3236a1c:	e0bff717 	ldw	r2,-36(fp)
 3236a20:	10c00f17 	ldw	r3,60(r2)
 3236a24:	e0bff717 	ldw	r2,-36(fp)
 3236a28:	10801a17 	ldw	r2,104(r2)
 3236a2c:	1885c83a 	sub	r2,r3,r2
 3236a30:	1004803a 	cmplt	r2,r2,zero
 3236a34:	1000301e 	bne	r2,zero,3236af8 <tcp_output+0x44c>
    * known to peer (as advertised window less
    * next expected input).  If the difference is at least two
    * max size segments or at least 35% of the maximum possible
    * window, then want to send a window update to peer.
    */
   if (win > 0)
 3236a38:	e0bff317 	ldw	r2,-52(fp)
 3236a3c:	10800050 	cmplti	r2,r2,1
 3236a40:	10001b1e 	bne	r2,zero,3236ab0 <tcp_output+0x404>
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);
 3236a44:	e0bff717 	ldw	r2,-36(fp)
 3236a48:	10c01917 	ldw	r3,100(r2)
 3236a4c:	e0bff717 	ldw	r2,-36(fp)
 3236a50:	10801617 	ldw	r2,88(r2)
 3236a54:	1885c83a 	sub	r2,r3,r2
 3236a58:	1007883a 	mov	r3,r2
 3236a5c:	e0bff317 	ldw	r2,-52(fp)
 3236a60:	10c5c83a 	sub	r2,r2,r3
 3236a64:	e0bfe715 	stw	r2,-100(fp)

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
 3236a68:	e0bff517 	ldw	r2,-44(fp)
 3236a6c:	10800a17 	ldw	r2,40(r2)
 3236a70:	1004c03a 	cmpne	r2,r2,zero
 3236a74:	1000071e 	bne	r2,zero,3236a94 <tcp_output+0x3e8>
 3236a78:	e0bff717 	ldw	r2,-36(fp)
 3236a7c:	10800a0b 	ldhu	r2,40(r2)
 3236a80:	10bfffcc 	andi	r2,r2,65535
 3236a84:	1085883a 	add	r2,r2,r2
 3236a88:	1007883a 	mov	r3,r2
 3236a8c:	e0bfe717 	ldw	r2,-100(fp)
 3236a90:	10c0190e 	bge	r2,r3,3236af8 <tcp_output+0x44c>
         goto send;
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
 3236a94:	e0bfe717 	ldw	r2,-100(fp)
 3236a98:	11001924 	muli	r4,r2,100
 3236a9c:	e0bff517 	ldw	r2,-44(fp)
 3236aa0:	11400b17 	ldw	r5,44(r2)
 3236aa4:	32047c00 	call	32047c0 <__udivsi3>
 3236aa8:	108008e8 	cmpgeui	r2,r2,35
 3236aac:	1000121e 	bne	r2,zero,3236af8 <tcp_output+0x44c>
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 3236ab0:	e0bff517 	ldw	r2,-44(fp)
 3236ab4:	10801217 	ldw	r2,72(r2)
 3236ab8:	1005003a 	cmpeq	r2,r2,zero
 3236abc:	10000c1e 	bne	r2,zero,3236af0 <tcp_output+0x444>
 3236ac0:	e0bff717 	ldw	r2,-36(fp)
 3236ac4:	10800317 	ldw	r2,12(r2)
 3236ac8:	1004c03a 	cmpne	r2,r2,zero
 3236acc:	1000081e 	bne	r2,zero,3236af0 <tcp_output+0x444>
 3236ad0:	e0bff717 	ldw	r2,-36(fp)
 3236ad4:	10800417 	ldw	r2,16(r2)
 3236ad8:	1004c03a 	cmpne	r2,r2,zero
 3236adc:	1000041e 	bne	r2,zero,3236af0 <tcp_output+0x444>
       tp->t_timer[TCPT_PERSIST] == 0) 
   {
      tp->t_rxtshift = 0;
 3236ae0:	e0bff717 	ldw	r2,-36(fp)
 3236ae4:	10000715 	stw	zero,28(r2)
      tcp_setpersist(tp);
 3236ae8:	e13ff717 	ldw	r4,-36(fp)
 3236aec:	32378280 	call	3237828 <tcp_setpersist>
   }

   /*
    * No reason to send a segment, just return.
    */
   return (0);
 3236af0:	e03ff815 	stw	zero,-32(fp)
 3236af4:	00034606 	br	3237810 <tcp_output+0x1164>

send:
   ENTER_CRIT_SECTION(tp);
 3236af8:	322b0f00 	call	322b0f0 <irq_Mask>

   /* Limit send length to the current buffer so as to
    * avoid doing the "mbuf shuffle" in m_copy().
    */
   bufoff = off;
 3236afc:	e0bff217 	ldw	r2,-56(fp)
 3236b00:	e0bfe815 	stw	r2,-96(fp)
   sendm = so->so_snd.sb_mb;
 3236b04:	e0bff517 	ldw	r2,-44(fp)
 3236b08:	10801817 	ldw	r2,96(r2)
 3236b0c:	e0bfea15 	stw	r2,-88(fp)
   if (len)
 3236b10:	e0bff417 	ldw	r2,-48(fp)
 3236b14:	1005003a 	cmpeq	r2,r2,zero
 3236b18:	10006b1e 	bne	r2,zero,3236cc8 <tcp_output+0x61c>
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 3236b1c:	00000b06 	br	3236b4c <tcp_output+0x4a0>
      {
         bufoff -= sendm->m_len;
 3236b20:	e0ffe817 	ldw	r3,-96(fp)
 3236b24:	e0bfea17 	ldw	r2,-88(fp)
 3236b28:	10800217 	ldw	r2,8(r2)
 3236b2c:	1885c83a 	sub	r2,r3,r2
 3236b30:	e0bfe815 	stw	r2,-96(fp)
         if (bufoff < 0)   /* if off is in this buffer, break */
 3236b34:	e0bfe817 	ldw	r2,-96(fp)
 3236b38:	1004803a 	cmplt	r2,r2,zero
 3236b3c:	1000061e 	bne	r2,zero,3236b58 <tcp_output+0x4ac>
            break;
         sendm = sendm->m_next;
 3236b40:	e0bfea17 	ldw	r2,-88(fp)
 3236b44:	10800617 	ldw	r2,24(r2)
 3236b48:	e0bfea15 	stw	r2,-88(fp)
   bufoff = off;
   sendm = so->so_snd.sb_mb;
   if (len)
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 3236b4c:	e0bfea17 	ldw	r2,-88(fp)
 3236b50:	1004c03a 	cmpne	r2,r2,zero
 3236b54:	103ff21e 	bne	r2,zero,3236b20 <tcp_output+0x474>
         bufoff -= sendm->m_len;
         if (bufoff < 0)   /* if off is in this buffer, break */
            break;
         sendm = sendm->m_next;
      }
      if (!sendm) { dtrap();  /* shouldn't happen */ }
 3236b58:	e0bfea17 	ldw	r2,-88(fp)
 3236b5c:	1004c03a 	cmpne	r2,r2,zero
 3236b60:	1000011e 	bne	r2,zero,3236b68 <tcp_output+0x4bc>
 3236b64:	322aef00 	call	322aef0 <dtrap>
      bufoff += sendm->m_len; /* index to next data to send in msend */
 3236b68:	e0bfea17 	ldw	r2,-88(fp)
 3236b6c:	10c00217 	ldw	r3,8(r2)
 3236b70:	e0bfe817 	ldw	r2,-96(fp)
 3236b74:	1885883a 	add	r2,r3,r2
 3236b78:	e0bfe815 	stw	r2,-96(fp)

      /* if socket has multiple unsent mbufs, set flag for send to loop */
      if ((sendm->m_next) && (len > (int)sendm->m_len))
 3236b7c:	e0bfea17 	ldw	r2,-88(fp)
 3236b80:	10800617 	ldw	r2,24(r2)
 3236b84:	1005003a 	cmpeq	r2,r2,zero
 3236b88:	10000b1e 	bne	r2,zero,3236bb8 <tcp_output+0x50c>
 3236b8c:	e0bfea17 	ldw	r2,-88(fp)
 3236b90:	10800217 	ldw	r2,8(r2)
 3236b94:	1007883a 	mov	r3,r2
 3236b98:	e0bff417 	ldw	r2,-48(fp)
 3236b9c:	1880060e 	bge	r3,r2,3236bb8 <tcp_output+0x50c>
      {
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 3236ba0:	e0fff117 	ldw	r3,-60(fp)
 3236ba4:	00bfff84 	movi	r2,-2
 3236ba8:	1884703a 	and	r2,r3,r2
 3236bac:	e0bff115 	stw	r2,-60(fp)
         sendalot = 1;     /* set to send more segments */
 3236bb0:	00800044 	movi	r2,1
 3236bb4:	e0bfeb15 	stw	r2,-84(fp)
      }
      if((flags & TH_FIN) && (so->so_snd.sb_cc > (unsigned)len))
 3236bb8:	e0bff117 	ldw	r2,-60(fp)
 3236bbc:	1080004c 	andi	r2,r2,1
 3236bc0:	10803fcc 	andi	r2,r2,255
 3236bc4:	1005003a 	cmpeq	r2,r2,zero
 3236bc8:	1000081e 	bne	r2,zero,3236bec <tcp_output+0x540>
 3236bcc:	e0bff517 	ldw	r2,-44(fp)
 3236bd0:	10c01217 	ldw	r3,72(r2)
 3236bd4:	e0bff417 	ldw	r2,-48(fp)
 3236bd8:	10c0042e 	bgeu	r2,r3,3236bec <tcp_output+0x540>
      {
         /* This can happen on slow links (PPP) which retry the last 
          * segment - the one with the FIN bit attached to data.
          */
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 3236bdc:	e0bff117 	ldw	r2,-60(fp)
 3236be0:	00ffff84 	movi	r3,-2
 3236be4:	10c4703a 	and	r2,r2,r3
 3236be8:	e0bff115 	stw	r2,-60(fp)
      }

      /* only send the rest of msend */
      len = min(len, (int)sendm->m_len);
 3236bec:	e0bfea17 	ldw	r2,-88(fp)
 3236bf0:	10800217 	ldw	r2,8(r2)
 3236bf4:	e0fff417 	ldw	r3,-48(fp)
 3236bf8:	e0fffd15 	stw	r3,-12(fp)
 3236bfc:	e0bffc15 	stw	r2,-16(fp)
 3236c00:	e0bffd17 	ldw	r2,-12(fp)
 3236c04:	e0fffc17 	ldw	r3,-16(fp)
 3236c08:	10c0020e 	bge	r2,r3,3236c14 <tcp_output+0x568>
 3236c0c:	e0bffd17 	ldw	r2,-12(fp)
 3236c10:	e0bffc15 	stw	r2,-16(fp)
 3236c14:	e0fffc17 	ldw	r3,-16(fp)
 3236c18:	e0fff415 	stw	r3,-48(fp)
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 3236c1c:	e0bfe817 	ldw	r2,-96(fp)
 3236c20:	1004c03a 	cmpne	r2,r2,zero
 3236c24:	1000091e 	bne	r2,zero,3236c4c <tcp_output+0x5a0>
 3236c28:	e0bfea17 	ldw	r2,-88(fp)
 3236c2c:	10800317 	ldw	r2,12(r2)
 3236c30:	1007883a 	mov	r3,r2
 3236c34:	e0bfea17 	ldw	r2,-88(fp)
 3236c38:	10800417 	ldw	r2,16(r2)
 3236c3c:	1885c83a 	sub	r2,r3,r2
 3236c40:	108000cc 	andi	r2,r2,3
 3236c44:	1005003a 	cmpeq	r2,r2,zero
 3236c48:	10001f1e 	bne	r2,zero,3236cc8 <tcp_output+0x61c>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
      {
         len = min(len, (int)(sendm->m_len - bufoff));   /* limit len again */
 3236c4c:	e0bfea17 	ldw	r2,-88(fp)
 3236c50:	10c00217 	ldw	r3,8(r2)
 3236c54:	e0bfe817 	ldw	r2,-96(fp)
 3236c58:	1885c83a 	sub	r2,r3,r2
 3236c5c:	e0fff417 	ldw	r3,-48(fp)
 3236c60:	e0ffff15 	stw	r3,-4(fp)
 3236c64:	e0bffe15 	stw	r2,-8(fp)
 3236c68:	e0bfff17 	ldw	r2,-4(fp)
 3236c6c:	e0fffe17 	ldw	r3,-8(fp)
 3236c70:	10c0020e 	bge	r2,r3,3236c7c <tcp_output+0x5d0>
 3236c74:	e0bfff17 	ldw	r2,-4(fp)
 3236c78:	e0bffe15 	stw	r2,-8(fp)
 3236c7c:	e0fffe17 	ldw	r3,-8(fp)
 3236c80:	e0fff415 	stw	r3,-48(fp)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 3236c84:	0080c974 	movhi	r2,805
 3236c88:	108a9504 	addi	r2,r2,10836
 3236c8c:	10800017 	ldw	r2,0(r2)
 3236c90:	10bff204 	addi	r2,r2,-56
 3236c94:	1007883a 	mov	r3,r2
 3236c98:	e0bff417 	ldw	r2,-48(fp)
 3236c9c:	18800a0e 	bge	r3,r2,3236cc8 <tcp_output+0x61c>
 3236ca0:	0080c9b4 	movhi	r2,806
 3236ca4:	10b3ec04 	addi	r2,r2,-12368
 3236ca8:	10800217 	ldw	r2,8(r2)
 3236cac:	10800088 	cmpgei	r2,r2,2
 3236cb0:	1000051e 	bne	r2,zero,3236cc8 <tcp_output+0x61c>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
         {
            len = lilbufsiz - HDRSLEN;
 3236cb4:	0080c974 	movhi	r2,805
 3236cb8:	108a9504 	addi	r2,r2,10836
 3236cbc:	10800017 	ldw	r2,0(r2)
 3236cc0:	10bff204 	addi	r2,r2,-56
 3236cc4:	e0bff415 	stw	r2,-48(fp)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 3236cc8:	e0bff417 	ldw	r2,-48(fp)
 3236ccc:	1005003a 	cmpeq	r2,r2,zero
 3236cd0:	10003b1e 	bne	r2,zero,3236dc0 <tcp_output+0x714>
 3236cd4:	e0bfe817 	ldw	r2,-96(fp)
 3236cd8:	1004c03a 	cmpne	r2,r2,zero
 3236cdc:	1000381e 	bne	r2,zero,3236dc0 <tcp_output+0x714>
 3236ce0:	e0bfea17 	ldw	r2,-88(fp)
 3236ce4:	10800117 	ldw	r2,4(r2)
 3236ce8:	10800917 	ldw	r2,36(r2)
 3236cec:	10800058 	cmpnei	r2,r2,1
 3236cf0:	1000331e 	bne	r2,zero,3236dc0 <tcp_output+0x714>
 3236cf4:	e0bfea17 	ldw	r2,-88(fp)
 3236cf8:	10800317 	ldw	r2,12(r2)
 3236cfc:	1007883a 	mov	r3,r2
 3236d00:	e0bfea17 	ldw	r2,-88(fp)
 3236d04:	10800417 	ldw	r2,16(r2)
 3236d08:	1885c83a 	sub	r2,r3,r2
 3236d0c:	108000cc 	andi	r2,r2,3
 3236d10:	1004c03a 	cmpne	r2,r2,zero
 3236d14:	10002a1e 	bne	r2,zero,3236dc0 <tcp_output+0x714>
 3236d18:	e0bfed17 	ldw	r2,-76(fp)
 3236d1c:	1004c03a 	cmpne	r2,r2,zero
 3236d20:	1000271e 	bne	r2,zero,3236dc0 <tcp_output+0x714>
       (sendm->pkt->inuse == 1) &&
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
       (optlen == 0))
   {
      /* get an empty mbuf to "clone" the data */
      m = m_getnbuf(MT_TXDATA, 0);
 3236d24:	01000084 	movi	r4,2
 3236d28:	000b883a 	mov	r5,zero
 3236d2c:	322bcf00 	call	322bcf0 <m_getnbuf>
 3236d30:	e0bfef15 	stw	r2,-68(fp)
      if (!m)
 3236d34:	e0bfef17 	ldw	r2,-68(fp)
 3236d38:	1004c03a 	cmpne	r2,r2,zero
 3236d3c:	1000041e 	bne	r2,zero,3236d50 <tcp_output+0x6a4>
      {
         EXIT_CRIT_SECTION(tp);
 3236d40:	322b14c0 	call	322b14c <irq_Unmask>
         return (ENOBUFS);
 3236d44:	00801a44 	movi	r2,105
 3236d48:	e0bff815 	stw	r2,-32(fp)
 3236d4c:	0002b006 	br	3237810 <tcp_output+0x1164>
      }
      m->pkt = sendm->pkt; /* copy packet location in new mbuf */
 3236d50:	e0bfea17 	ldw	r2,-88(fp)
 3236d54:	10c00117 	ldw	r3,4(r2)
 3236d58:	e0bfef17 	ldw	r2,-68(fp)
 3236d5c:	10c00115 	stw	r3,4(r2)
      m->pkt->inuse++;     /* bump packet's use count */
 3236d60:	e0bfef17 	ldw	r2,-68(fp)
 3236d64:	10c00117 	ldw	r3,4(r2)
 3236d68:	18800917 	ldw	r2,36(r3)
 3236d6c:	10800044 	addi	r2,r2,1
 3236d70:	18800915 	stw	r2,36(r3)
      m->m_base = sendm->m_base; /* clone mbuf members */
 3236d74:	e0bfea17 	ldw	r2,-88(fp)
 3236d78:	10c00417 	ldw	r3,16(r2)
 3236d7c:	e0bfef17 	ldw	r2,-68(fp)
 3236d80:	10c00415 	stw	r3,16(r2)
      m->m_memsz = sendm->m_memsz;
 3236d84:	e0bfea17 	ldw	r2,-88(fp)
 3236d88:	10c00517 	ldw	r3,20(r2)
 3236d8c:	e0bfef17 	ldw	r2,-68(fp)
 3236d90:	10c00515 	stw	r3,20(r2)
      m->m_len = len + TCPIPHDRSZ;  /* adjust clone for header */
 3236d94:	e0bff417 	ldw	r2,-48(fp)
 3236d98:	10800a04 	addi	r2,r2,40
 3236d9c:	1007883a 	mov	r3,r2
 3236da0:	e0bfef17 	ldw	r2,-68(fp)
 3236da4:	10c00215 	stw	r3,8(r2)
      m->m_data = sendm->m_data - TCPIPHDRSZ;
 3236da8:	e0bfea17 	ldw	r2,-88(fp)
 3236dac:	10800317 	ldw	r2,12(r2)
 3236db0:	10fff604 	addi	r3,r2,-40
 3236db4:	e0bfef17 	ldw	r2,-68(fp)
 3236db8:	10c00315 	stw	r3,12(r2)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 3236dbc:	00002e06 	br	3236e78 <tcp_output+0x7cc>
   {
      /* Grab a header mbuf, attaching a copy of data to be 
       * transmitted, and initialize the header from 
       * the template for sends on this connection.
       */
      m = m_getwithdata (MT_HEADER, IFNETHDR_SIZE + TCPIPHDRSZ);
 3236dc0:	0080c974 	movhi	r2,805
 3236dc4:	10931a04 	addi	r2,r2,19560
 3236dc8:	10800017 	ldw	r2,0(r2)
 3236dcc:	11400a04 	addi	r5,r2,40
 3236dd0:	010000c4 	movi	r4,3
 3236dd4:	322bcf00 	call	322bcf0 <m_getnbuf>
 3236dd8:	e0bfef15 	stw	r2,-68(fp)
      if (m ==(struct mbuf *)NULL)
 3236ddc:	e0bfef17 	ldw	r2,-68(fp)
 3236de0:	1004c03a 	cmpne	r2,r2,zero
 3236de4:	1000041e 	bne	r2,zero,3236df8 <tcp_output+0x74c>
      {
         EXIT_CRIT_SECTION(tp);
 3236de8:	322b14c0 	call	322b14c <irq_Unmask>
         return ENOBUFS;
 3236dec:	00c01a44 	movi	r3,105
 3236df0:	e0fff815 	stw	r3,-32(fp)
 3236df4:	00028606 	br	3237810 <tcp_output+0x1164>
      }

      m->m_len = TCPIPHDRSZ;
 3236df8:	e0ffef17 	ldw	r3,-68(fp)
 3236dfc:	00800a04 	movi	r2,40
 3236e00:	18800215 	stw	r2,8(r3)
      m->m_data += IFNETHDR_SIZE;/* Move this to sizeof tcpip hdr leave*/
 3236e04:	e0bfef17 	ldw	r2,-68(fp)
 3236e08:	10c00317 	ldw	r3,12(r2)
 3236e0c:	0080c974 	movhi	r2,805
 3236e10:	10931a04 	addi	r2,r2,19560
 3236e14:	10800017 	ldw	r2,0(r2)
 3236e18:	1887883a 	add	r3,r3,r2
 3236e1c:	e0bfef17 	ldw	r2,-68(fp)
 3236e20:	10c00315 	stw	r3,12(r2)
      /* 14 bytes for ethernet header      */

      if (len) /* attach any data to send */
 3236e24:	e0bff417 	ldw	r2,-48(fp)
 3236e28:	1005003a 	cmpeq	r2,r2,zero
 3236e2c:	1000121e 	bne	r2,zero,3236e78 <tcp_output+0x7cc>
      {
         m->m_next = m_copy(so->so_snd.sb_mb, off, (int) len);
 3236e30:	e0bff517 	ldw	r2,-44(fp)
 3236e34:	11001817 	ldw	r4,96(r2)
 3236e38:	e17ff217 	ldw	r5,-56(fp)
 3236e3c:	e1bff417 	ldw	r6,-48(fp)
 3236e40:	322c0100 	call	322c010 <m_copy>
 3236e44:	1007883a 	mov	r3,r2
 3236e48:	e0bfef17 	ldw	r2,-68(fp)
 3236e4c:	10c00615 	stw	r3,24(r2)
         if (m->m_next == 0)
 3236e50:	e0bfef17 	ldw	r2,-68(fp)
 3236e54:	10800617 	ldw	r2,24(r2)
 3236e58:	1004c03a 	cmpne	r2,r2,zero
 3236e5c:	1000061e 	bne	r2,zero,3236e78 <tcp_output+0x7cc>
         {
            m_freem(m);
 3236e60:	e13fef17 	ldw	r4,-68(fp)
 3236e64:	322bfcc0 	call	322bfcc <m_freem>
            EXIT_CRIT_SECTION(tp);
 3236e68:	322b14c0 	call	322b14c <irq_Unmask>
            return ENOBUFS;
 3236e6c:	00801a44 	movi	r2,105
 3236e70:	e0bff815 	stw	r2,-32(fp)
 3236e74:	00026606 	br	3237810 <tcp_output+0x1164>
         }
      }
   }
   EXIT_CRIT_SECTION(tp);
 3236e78:	322b14c0 	call	322b14c <irq_Unmask>

   if (len) 
 3236e7c:	e0bff417 	ldw	r2,-48(fp)
 3236e80:	1005003a 	cmpeq	r2,r2,zero
 3236e84:	1000391e 	bne	r2,zero,3236f6c <tcp_output+0x8c0>
   {
      if (tp->t_force && len == 1)
 3236e88:	e0bff717 	ldw	r2,-36(fp)
 3236e8c:	10800a83 	ldbu	r2,42(r2)
 3236e90:	10803fcc 	andi	r2,r2,255
 3236e94:	1080201c 	xori	r2,r2,128
 3236e98:	10bfe004 	addi	r2,r2,-128
 3236e9c:	1005003a 	cmpeq	r2,r2,zero
 3236ea0:	10000b1e 	bne	r2,zero,3236ed0 <tcp_output+0x824>
 3236ea4:	e0bff417 	ldw	r2,-48(fp)
 3236ea8:	10800058 	cmpnei	r2,r2,1
 3236eac:	1000081e 	bne	r2,zero,3236ed0 <tcp_output+0x824>
         tcpstat.tcps_sndprobe++;
 3236eb0:	0080c9b4 	movhi	r2,806
 3236eb4:	10b4b504 	addi	r2,r2,-11564
 3236eb8:	10801517 	ldw	r2,84(r2)
 3236ebc:	10c00044 	addi	r3,r2,1
 3236ec0:	0080c9b4 	movhi	r2,806
 3236ec4:	10b4b504 	addi	r2,r2,-11564
 3236ec8:	10c01515 	stw	r3,84(r2)
   }
   EXIT_CRIT_SECTION(tp);

   if (len) 
   {
      if (tp->t_force && len == 1)
 3236ecc:	00005806 	br	3237030 <tcp_output+0x984>
         tcpstat.tcps_sndprobe++;
      else if (SEQ_LT(tp->snd_nxt, tp->snd_max)) 
 3236ed0:	e0bff717 	ldw	r2,-36(fp)
 3236ed4:	10c00f17 	ldw	r3,60(r2)
 3236ed8:	e0bff717 	ldw	r2,-36(fp)
 3236edc:	10801a17 	ldw	r2,104(r2)
 3236ee0:	1885c83a 	sub	r2,r3,r2
 3236ee4:	1004403a 	cmpge	r2,r2,zero
 3236ee8:	1000101e 	bne	r2,zero,3236f2c <tcp_output+0x880>
      {
         tcpstat.tcps_sndrexmitpack++;
 3236eec:	0080c9b4 	movhi	r2,806
 3236ef0:	10b4b504 	addi	r2,r2,-11564
 3236ef4:	10801217 	ldw	r2,72(r2)
 3236ef8:	10c00044 	addi	r3,r2,1
 3236efc:	0080c9b4 	movhi	r2,806
 3236f00:	10b4b504 	addi	r2,r2,-11564
 3236f04:	10c01215 	stw	r3,72(r2)
         tcpstat.tcps_sndrexmitbyte += len;
 3236f08:	0080c9b4 	movhi	r2,806
 3236f0c:	10b4b504 	addi	r2,r2,-11564
 3236f10:	10c01317 	ldw	r3,76(r2)
 3236f14:	e0bff417 	ldw	r2,-48(fp)
 3236f18:	1887883a 	add	r3,r3,r2
 3236f1c:	0080c9b4 	movhi	r2,806
 3236f20:	10b4b504 	addi	r2,r2,-11564
 3236f24:	10c01315 	stw	r3,76(r2)
 3236f28:	00004106 	br	3237030 <tcp_output+0x984>
         tcpstat.tcps_sackresend++;
#endif
      } 
      else 
      {
         tcpstat.tcps_sndpack++;
 3236f2c:	0080c9b4 	movhi	r2,806
 3236f30:	10b4b504 	addi	r2,r2,-11564
 3236f34:	10801017 	ldw	r2,64(r2)
 3236f38:	10c00044 	addi	r3,r2,1
 3236f3c:	0080c9b4 	movhi	r2,806
 3236f40:	10b4b504 	addi	r2,r2,-11564
 3236f44:	10c01015 	stw	r3,64(r2)
         tcpstat.tcps_sndbyte += len;
 3236f48:	0080c9b4 	movhi	r2,806
 3236f4c:	10b4b504 	addi	r2,r2,-11564
 3236f50:	10c01117 	ldw	r3,68(r2)
 3236f54:	e0bff417 	ldw	r2,-48(fp)
 3236f58:	1887883a 	add	r3,r3,r2
 3236f5c:	0080c9b4 	movhi	r2,806
 3236f60:	10b4b504 	addi	r2,r2,-11564
 3236f64:	10c01115 	stw	r3,68(r2)
 3236f68:	00003106 	br	3237030 <tcp_output+0x984>
      }
   }
   else if (tp->t_flags & TF_ACKNOW)
 3236f6c:	e0bff717 	ldw	r2,-36(fp)
 3236f70:	10800b0b 	ldhu	r2,44(r2)
 3236f74:	10bfffcc 	andi	r2,r2,65535
 3236f78:	1080004c 	andi	r2,r2,1
 3236f7c:	10803fcc 	andi	r2,r2,255
 3236f80:	1005003a 	cmpeq	r2,r2,zero
 3236f84:	1000081e 	bne	r2,zero,3236fa8 <tcp_output+0x8fc>
   {
      tcpstat.tcps_sndacks++;
 3236f88:	0080c9b4 	movhi	r2,806
 3236f8c:	10b4b504 	addi	r2,r2,-11564
 3236f90:	10801417 	ldw	r2,80(r2)
 3236f94:	10c00044 	addi	r3,r2,1
 3236f98:	0080c9b4 	movhi	r2,806
 3236f9c:	10b4b504 	addi	r2,r2,-11564
 3236fa0:	10c01415 	stw	r3,80(r2)
 3236fa4:	00002206 	br	3237030 <tcp_output+0x984>
   }
   else if (flags & (TH_SYN|TH_FIN|TH_RST))
 3236fa8:	e0bff117 	ldw	r2,-60(fp)
 3236fac:	108001cc 	andi	r2,r2,7
 3236fb0:	1005003a 	cmpeq	r2,r2,zero
 3236fb4:	1000081e 	bne	r2,zero,3236fd8 <tcp_output+0x92c>
      tcpstat.tcps_sndctrl++;
 3236fb8:	0080c9b4 	movhi	r2,806
 3236fbc:	10b4b504 	addi	r2,r2,-11564
 3236fc0:	10801817 	ldw	r2,96(r2)
 3236fc4:	10c00044 	addi	r3,r2,1
 3236fc8:	0080c9b4 	movhi	r2,806
 3236fcc:	10b4b504 	addi	r2,r2,-11564
 3236fd0:	10c01815 	stw	r3,96(r2)
 3236fd4:	00001606 	br	3237030 <tcp_output+0x984>
   else if (SEQ_GT(tp->snd_up, tp->snd_una))
 3236fd8:	e0bff717 	ldw	r2,-36(fp)
 3236fdc:	10c01017 	ldw	r3,64(r2)
 3236fe0:	e0bff717 	ldw	r2,-36(fp)
 3236fe4:	10800e17 	ldw	r2,56(r2)
 3236fe8:	1885c83a 	sub	r2,r3,r2
 3236fec:	10800050 	cmplti	r2,r2,1
 3236ff0:	1000081e 	bne	r2,zero,3237014 <tcp_output+0x968>
      tcpstat.tcps_sndurg++;
 3236ff4:	0080c9b4 	movhi	r2,806
 3236ff8:	10b4b504 	addi	r2,r2,-11564
 3236ffc:	10801617 	ldw	r2,88(r2)
 3237000:	10c00044 	addi	r3,r2,1
 3237004:	0080c9b4 	movhi	r2,806
 3237008:	10b4b504 	addi	r2,r2,-11564
 323700c:	10c01615 	stw	r3,88(r2)
 3237010:	00000706 	br	3237030 <tcp_output+0x984>
   else
      tcpstat.tcps_sndwinup++;
 3237014:	0080c9b4 	movhi	r2,806
 3237018:	10b4b504 	addi	r2,r2,-11564
 323701c:	10801717 	ldw	r2,92(r2)
 3237020:	10c00044 	addi	r3,r2,1
 3237024:	0080c9b4 	movhi	r2,806
 3237028:	10b4b504 	addi	r2,r2,-11564
 323702c:	10c01715 	stw	r3,92(r2)

   ti = (struct tcpiphdr *)(m->m_data+sizeof(struct ip)-sizeof(struct ipovly));
 3237030:	e0bfef17 	ldw	r2,-68(fp)
 3237034:	10800317 	ldw	r2,12(r2)
 3237038:	e0bfee15 	stw	r2,-72(fp)
   if ((char *)ti < m->pkt->nb_buff)
 323703c:	e0bfef17 	ldw	r2,-68(fp)
 3237040:	10800117 	ldw	r2,4(r2)
 3237044:	10c00117 	ldw	r3,4(r2)
 3237048:	e0bfee17 	ldw	r2,-72(fp)
 323704c:	10c0032e 	bgeu	r2,r3,323705c <tcp_output+0x9b0>
   {
      panic("tcp_out- packet ptr underflow\n");
 3237050:	0100c974 	movhi	r4,805
 3237054:	213e5d04 	addi	r4,r4,-1676
 3237058:	32261540 	call	3226154 <panic>
   }
   tcp_mbuf = m;        /* flag TCP header mbuf */
 323705c:	e0bfef17 	ldw	r2,-68(fp)
 3237060:	e0bfe915 	stw	r2,-92(fp)
      tcp_mbuf->m_data += sizeof(struct ipovly);
      tcp_mbuf->m_len -= sizeof(struct ipovly);
   }
#endif   /* end IP_V6 */

   if (tp->t_template == 0)
 3237064:	e0bff717 	ldw	r2,-36(fp)
 3237068:	10800c17 	ldw	r2,48(r2)
 323706c:	1004c03a 	cmpne	r2,r2,zero
 3237070:	1000031e 	bne	r2,zero,3237080 <tcp_output+0x9d4>
      panic("tcp_output");
 3237074:	0100c974 	movhi	r4,805
 3237078:	213e6504 	addi	r4,r4,-1644
 323707c:	32261540 	call	3226154 <panic>

   MEMCPY((char*)ti, (char*)tp->t_template, sizeof(struct tcpiphdr));
 3237080:	e0ffee17 	ldw	r3,-72(fp)
 3237084:	e0bff717 	ldw	r2,-36(fp)
 3237088:	10800c17 	ldw	r2,48(r2)
 323708c:	1809883a 	mov	r4,r3
 3237090:	100b883a 	mov	r5,r2
 3237094:	01800a04 	movi	r6,40
 3237098:	3206ad00 	call	3206ad0 <memcpy>
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 323709c:	e0bff117 	ldw	r2,-60(fp)
 32370a0:	1080004c 	andi	r2,r2,1
 32370a4:	10803fcc 	andi	r2,r2,255
 32370a8:	1005003a 	cmpeq	r2,r2,zero
 32370ac:	1000101e 	bne	r2,zero,32370f0 <tcp_output+0xa44>
 32370b0:	e0bff717 	ldw	r2,-36(fp)
 32370b4:	10800b0b 	ldhu	r2,44(r2)
 32370b8:	10bfffcc 	andi	r2,r2,65535
 32370bc:	1080040c 	andi	r2,r2,16
 32370c0:	1005003a 	cmpeq	r2,r2,zero
 32370c4:	10000a1e 	bne	r2,zero,32370f0 <tcp_output+0xa44>
 32370c8:	e0bff717 	ldw	r2,-36(fp)
 32370cc:	10c00f17 	ldw	r3,60(r2)
 32370d0:	e0bff717 	ldw	r2,-36(fp)
 32370d4:	10801a17 	ldw	r2,104(r2)
 32370d8:	1880051e 	bne	r3,r2,32370f0 <tcp_output+0xa44>
       tp->snd_nxt == tp->snd_max)
   {
      tp->snd_nxt--;
 32370dc:	e0bff717 	ldw	r2,-36(fp)
 32370e0:	10800f17 	ldw	r2,60(r2)
 32370e4:	10ffffc4 	addi	r3,r2,-1
 32370e8:	e0bff717 	ldw	r2,-36(fp)
 32370ec:	10c00f15 	stw	r3,60(r2)
   }

   ti->ti_seq = htonl(tp->snd_nxt);
 32370f0:	e0bff717 	ldw	r2,-36(fp)
 32370f4:	10800f17 	ldw	r2,60(r2)
 32370f8:	1004d63a 	srli	r2,r2,24
 32370fc:	10c03fcc 	andi	r3,r2,255
 3237100:	e0bff717 	ldw	r2,-36(fp)
 3237104:	10800f17 	ldw	r2,60(r2)
 3237108:	1004d23a 	srli	r2,r2,8
 323710c:	10bfc00c 	andi	r2,r2,65280
 3237110:	1886b03a 	or	r3,r3,r2
 3237114:	e0bff717 	ldw	r2,-36(fp)
 3237118:	10800f17 	ldw	r2,60(r2)
 323711c:	10bfc00c 	andi	r2,r2,65280
 3237120:	1004923a 	slli	r2,r2,8
 3237124:	1886b03a 	or	r3,r3,r2
 3237128:	e0bff717 	ldw	r2,-36(fp)
 323712c:	10800f17 	ldw	r2,60(r2)
 3237130:	10803fcc 	andi	r2,r2,255
 3237134:	1004963a 	slli	r2,r2,24
 3237138:	1886b03a 	or	r3,r3,r2
 323713c:	e0bfee17 	ldw	r2,-72(fp)
 3237140:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(tp->rcv_nxt);
 3237144:	e0bff717 	ldw	r2,-36(fp)
 3237148:	10801617 	ldw	r2,88(r2)
 323714c:	1004d63a 	srli	r2,r2,24
 3237150:	10c03fcc 	andi	r3,r2,255
 3237154:	e0bff717 	ldw	r2,-36(fp)
 3237158:	10801617 	ldw	r2,88(r2)
 323715c:	1004d23a 	srli	r2,r2,8
 3237160:	10bfc00c 	andi	r2,r2,65280
 3237164:	1886b03a 	or	r3,r3,r2
 3237168:	e0bff717 	ldw	r2,-36(fp)
 323716c:	10801617 	ldw	r2,88(r2)
 3237170:	10bfc00c 	andi	r2,r2,65280
 3237174:	1004923a 	slli	r2,r2,8
 3237178:	1886b03a 	or	r3,r3,r2
 323717c:	e0bff717 	ldw	r2,-36(fp)
 3237180:	10801617 	ldw	r2,88(r2)
 3237184:	10803fcc 	andi	r2,r2,255
 3237188:	1004963a 	slli	r2,r2,24
 323718c:	1886b03a 	or	r3,r3,r2
 3237190:	e0bfee17 	ldw	r2,-72(fp)
 3237194:	10c00715 	stw	r3,28(r2)
    * a retransmission, and the original SYN caused PPP to start
    * bringing the interface up, and PPP has got a new IP address
    * via IPCP), update the template and the inpcb with the new 
    * address.
    */
   if (flags & TH_SYN)
 3237198:	e0bff117 	ldw	r2,-60(fp)
 323719c:	1080008c 	andi	r2,r2,2
 32371a0:	1005003a 	cmpeq	r2,r2,zero
 32371a4:	1000221e 	bne	r2,zero,3237230 <tcp_output+0xb84>
   {
      struct inpcb * inp;
      inp = (struct inpcb *)so->so_pcb;
 32371a8:	e0bff517 	ldw	r2,-44(fp)
 32371ac:	10800117 	ldw	r2,4(r2)
 32371b0:	e0bfe615 	stw	r2,-104(fp)

      switch(so->so_domain)
 32371b4:	e0bff517 	ldw	r2,-44(fp)
 32371b8:	10800517 	ldw	r2,20(r2)
 32371bc:	108000a0 	cmpeqi	r2,r2,2
 32371c0:	1000011e 	bne	r2,zero,32371c8 <tcp_output+0xb1c>
 32371c4:	00001906 	br	323722c <tcp_output+0xb80>
         }
         }
#endif   /* INCLUDE_PPP */

         /* If this is a SYN (not a SYN/ACK) then set the pmtu */
         if((flags & TH_ACK) == 0)
 32371c8:	e0bff117 	ldw	r2,-60(fp)
 32371cc:	1080040c 	andi	r2,r2,16
 32371d0:	1004c03a 	cmpne	r2,r2,zero
 32371d4:	1000161e 	bne	r2,zero,3237230 <tcp_output+0xb84>
            inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
            {
               NET ifp;
               /* find iface for route. Pass "src" as nexthop return */
               ifp = iproute(ti->ti_dst.s_addr, &src);
 32371d8:	e0bfee17 	ldw	r2,-72(fp)
 32371dc:	11000417 	ldw	r4,16(r2)
 32371e0:	e17ff604 	addi	r5,fp,-40
 32371e4:	32408540 	call	3240854 <iproute>
 32371e8:	e0bfe515 	stw	r2,-108(fp)
               if(ifp)
 32371ec:	e0bfe517 	ldw	r2,-108(fp)
 32371f0:	1005003a 	cmpeq	r2,r2,zero
 32371f4:	1000091e 	bne	r2,zero,323721c <tcp_output+0xb70>
                  inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 32371f8:	e0bfe517 	ldw	r2,-108(fp)
 32371fc:	10c00917 	ldw	r3,36(r2)
 3237200:	e0bfe517 	ldw	r2,-108(fp)
 3237204:	10800817 	ldw	r2,32(r2)
 3237208:	1885c83a 	sub	r2,r3,r2
 323720c:	10fff604 	addi	r3,r2,-40
 3237210:	e0bfe617 	ldw	r2,-104(fp)
 3237214:	10c00615 	stw	r3,24(r2)
 3237218:	00000506 	br	3237230 <tcp_output+0xb84>
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
 323721c:	e0ffe617 	ldw	r3,-104(fp)
 3237220:	00809104 	movi	r2,580
 3237224:	18800615 	stw	r2,24(r3)
            }
#endif   /* IP_PMTU */
         }
         break;
 3237228:	00000106 	br	3237230 <tcp_output+0xb84>
         }
         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();    /* bad domain setting */
 323722c:	322aef00 	call	322aef0 <dtrap>
      }
   }

   /* fill in options if any are set */
   if (optlen)
 3237230:	e0bfed17 	ldw	r2,-76(fp)
 3237234:	1005003a 	cmpeq	r2,r2,zero
 3237238:	10002f1e 	bne	r2,zero,32372f8 <tcp_output+0xc4c>
   {
      struct mbuf * mopt;

      mopt = m_getwithdata(MT_TXDATA, MAXOPTLEN);
 323723c:	01000084 	movi	r4,2
 3237240:	01404004 	movi	r5,256
 3237244:	322bcf00 	call	322bcf0 <m_getnbuf>
 3237248:	e0bfe415 	stw	r2,-112(fp)
      if (mopt == NULL) 
 323724c:	e0bfe417 	ldw	r2,-112(fp)
 3237250:	1004c03a 	cmpne	r2,r2,zero
 3237254:	1000051e 	bne	r2,zero,323726c <tcp_output+0xbc0>
      {
         m_freem(m);
 3237258:	e13fef17 	ldw	r4,-68(fp)
 323725c:	322bfcc0 	call	322bfcc <m_freem>
         return (ENOBUFS);
 3237260:	00c01a44 	movi	r3,105
 3237264:	e0fff815 	stw	r3,-32(fp)
 3237268:	00016906 	br	3237810 <tcp_output+0x1164>
      }

      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
 323726c:	e0bfe917 	ldw	r2,-92(fp)
 3237270:	10c00617 	ldw	r3,24(r2)
 3237274:	e0bfe417 	ldw	r2,-112(fp)
 3237278:	10c00615 	stw	r3,24(r2)
      tcp_mbuf->m_next = mopt;
 323727c:	e0ffe917 	ldw	r3,-92(fp)
 3237280:	e0bfe417 	ldw	r2,-112(fp)
 3237284:	18800615 	stw	r2,24(r3)

      /* extend options to aligned address */
      while(optlen & 0x03)
 3237288:	00000706 	br	32372a8 <tcp_output+0xbfc>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;
 323728c:	e0ffed17 	ldw	r3,-76(fp)
 3237290:	d0a8ea04 	addi	r2,gp,-23640
 3237294:	1885883a 	add	r2,r3,r2
 3237298:	10000005 	stb	zero,0(r2)
 323729c:	e0bfed17 	ldw	r2,-76(fp)
 32372a0:	10800044 	addi	r2,r2,1
 32372a4:	e0bfed15 	stw	r2,-76(fp)
      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
      tcp_mbuf->m_next = mopt;

      /* extend options to aligned address */
      while(optlen & 0x03)
 32372a8:	e0bfed17 	ldw	r2,-76(fp)
 32372ac:	108000cc 	andi	r2,r2,3
 32372b0:	1004c03a 	cmpne	r2,r2,zero
 32372b4:	103ff51e 	bne	r2,zero,323728c <tcp_output+0xbe0>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;

      MEMCPY(mtod(mopt, char *), tcp_optionbuf, optlen);
 32372b8:	e0bfe417 	ldw	r2,-112(fp)
 32372bc:	10800317 	ldw	r2,12(r2)
 32372c0:	1009883a 	mov	r4,r2
 32372c4:	d168ea04 	addi	r5,gp,-23640
 32372c8:	e1bfed17 	ldw	r6,-76(fp)
 32372cc:	3206ad00 	call	3206ad0 <memcpy>
      mopt->m_len = optlen;
 32372d0:	e0ffe417 	ldw	r3,-112(fp)
 32372d4:	e0bfed17 	ldw	r2,-76(fp)
 32372d8:	18800215 	stw	r2,8(r3)
      /* use portable macro to set tcp data offset bits */
      SET_TH_OFF(ti->ti_t, ((sizeof (struct tcphdr) + optlen) >> 2));
 32372dc:	e0bfed17 	ldw	r2,-76(fp)
 32372e0:	10800504 	addi	r2,r2,20
 32372e4:	1004d0ba 	srli	r2,r2,2
 32372e8:	1004913a 	slli	r2,r2,4
 32372ec:	1007883a 	mov	r3,r2
 32372f0:	e0bfee17 	ldw	r2,-72(fp)
 32372f4:	10c00805 	stb	r3,32(r2)
   }

   ti->ti_flags = (u_char)flags;
 32372f8:	e0bff117 	ldw	r2,-60(fp)
 32372fc:	1007883a 	mov	r3,r2
 3237300:	e0bfee17 	ldw	r2,-72(fp)
 3237304:	10c00845 	stb	r3,33(r2)
   /*
    * Calculate receive window. Don't shrink window,
    * but avoid silly window syndrome.
    */
   if (win < (long)(so->so_rcv.sb_hiwat / 4) && win < (long)tp->t_maxseg)
 3237308:	e0bff517 	ldw	r2,-44(fp)
 323730c:	10800b17 	ldw	r2,44(r2)
 3237310:	1004d0ba 	srli	r2,r2,2
 3237314:	1007883a 	mov	r3,r2
 3237318:	e0bff317 	ldw	r2,-52(fp)
 323731c:	10c0060e 	bge	r2,r3,3237338 <tcp_output+0xc8c>
 3237320:	e0bff717 	ldw	r2,-36(fp)
 3237324:	10800a0b 	ldhu	r2,40(r2)
 3237328:	10ffffcc 	andi	r3,r2,65535
 323732c:	e0bff317 	ldw	r2,-52(fp)
 3237330:	10c0010e 	bge	r2,r3,3237338 <tcp_output+0xc8c>
      win = 0;
 3237334:	e03ff315 	stw	zero,-52(fp)
   if (win < (long)(tp->rcv_adv - tp->rcv_nxt))
 3237338:	e0bff717 	ldw	r2,-36(fp)
 323733c:	10c01917 	ldw	r3,100(r2)
 3237340:	e0bff717 	ldw	r2,-36(fp)
 3237344:	10801617 	ldw	r2,88(r2)
 3237348:	1885c83a 	sub	r2,r3,r2
 323734c:	1007883a 	mov	r3,r2
 3237350:	e0bff317 	ldw	r2,-52(fp)
 3237354:	10c0060e 	bge	r2,r3,3237370 <tcp_output+0xcc4>
      win = (long)(tp->rcv_adv - tp->rcv_nxt);
 3237358:	e0bff717 	ldw	r2,-36(fp)
 323735c:	10c01917 	ldw	r3,100(r2)
 3237360:	e0bff717 	ldw	r2,-36(fp)
 3237364:	10801617 	ldw	r2,88(r2)
 3237368:	1885c83a 	sub	r2,r3,r2
 323736c:	e0bff315 	stw	r2,-52(fp)

   /* do check for Iniche buffer limits -JB- */
   if (bigfreeq.q_len == 0)   /* If queue length is 0, set window to 0 */
 3237370:	0080c9b4 	movhi	r2,806
 3237374:	10b3ec04 	addi	r2,r2,-12368
 3237378:	10800217 	ldw	r2,8(r2)
 323737c:	1004c03a 	cmpne	r2,r2,zero
 3237380:	1000021e 	bne	r2,zero,323738c <tcp_output+0xce0>
   {
      win = 0;
 3237384:	e03ff315 	stw	zero,-52(fp)
 3237388:	00001406 	br	32373dc <tcp_output+0xd30>
   }
   else if(win > (((long)bigfreeq.q_len - 1) * (long)bigbufsiz))
 323738c:	0080c9b4 	movhi	r2,806
 3237390:	10b3ec04 	addi	r2,r2,-12368
 3237394:	10800217 	ldw	r2,8(r2)
 3237398:	10ffffc4 	addi	r3,r2,-1
 323739c:	0080c974 	movhi	r2,805
 32373a0:	108a9704 	addi	r2,r2,10844
 32373a4:	10800017 	ldw	r2,0(r2)
 32373a8:	1887383a 	mul	r3,r3,r2
 32373ac:	e0bff317 	ldw	r2,-52(fp)
 32373b0:	18800a0e 	bge	r3,r2,32373dc <tcp_output+0xd30>
   {
      win = ((long)bigfreeq.q_len - 1) * bigbufsiz;
 32373b4:	0080c9b4 	movhi	r2,806
 32373b8:	10b3ec04 	addi	r2,r2,-12368
 32373bc:	10800217 	ldw	r2,8(r2)
 32373c0:	10bfffc4 	addi	r2,r2,-1
 32373c4:	1007883a 	mov	r3,r2
 32373c8:	0080c974 	movhi	r2,805
 32373cc:	108a9704 	addi	r2,r2,10844
 32373d0:	10800017 	ldw	r2,0(r2)
 32373d4:	1885383a 	mul	r2,r3,r2
 32373d8:	e0bff315 	stw	r2,-52(fp)
      ti->ti_win = htons((u_short)(win >> tp->rcv_wind_scale)); /* apply scale */
   }
   else
#endif /* TCP_WIN_SCALE */
   {
      ti->ti_win = htons((u_short)win);
 32373dc:	e0bff317 	ldw	r2,-52(fp)
 32373e0:	10bfffcc 	andi	r2,r2,65535
 32373e4:	1004d23a 	srli	r2,r2,8
 32373e8:	10803fcc 	andi	r2,r2,255
 32373ec:	1009883a 	mov	r4,r2
 32373f0:	e0bff317 	ldw	r2,-52(fp)
 32373f4:	10bfffcc 	andi	r2,r2,65535
 32373f8:	1004923a 	slli	r2,r2,8
 32373fc:	1007883a 	mov	r3,r2
 3237400:	00bfc004 	movi	r2,-256
 3237404:	1884703a 	and	r2,r3,r2
 3237408:	2084b03a 	or	r2,r4,r2
 323740c:	1007883a 	mov	r3,r2
 3237410:	e0bfee17 	ldw	r2,-72(fp)
 3237414:	10c0088d 	sth	r3,34(r2)
   }

   if (SEQ_GT(tp->snd_up, tp->snd_nxt)) 
 3237418:	e0bff717 	ldw	r2,-36(fp)
 323741c:	10c01017 	ldw	r3,64(r2)
 3237420:	e0bff717 	ldw	r2,-36(fp)
 3237424:	10800f17 	ldw	r2,60(r2)
 3237428:	1885c83a 	sub	r2,r3,r2
 323742c:	10800050 	cmplti	r2,r2,1
 3237430:	1000201e 	bne	r2,zero,32374b4 <tcp_output+0xe08>
   {
      ti->ti_urp = htons((u_short)(tp->snd_up - tp->snd_nxt));
 3237434:	e0bff717 	ldw	r2,-36(fp)
 3237438:	10801017 	ldw	r2,64(r2)
 323743c:	1007883a 	mov	r3,r2
 3237440:	e0bff717 	ldw	r2,-36(fp)
 3237444:	10800f17 	ldw	r2,60(r2)
 3237448:	1885c83a 	sub	r2,r3,r2
 323744c:	10bfffcc 	andi	r2,r2,65535
 3237450:	1004d23a 	srli	r2,r2,8
 3237454:	10803fcc 	andi	r2,r2,255
 3237458:	1009883a 	mov	r4,r2
 323745c:	e0bff717 	ldw	r2,-36(fp)
 3237460:	10801017 	ldw	r2,64(r2)
 3237464:	1007883a 	mov	r3,r2
 3237468:	e0bff717 	ldw	r2,-36(fp)
 323746c:	10800f17 	ldw	r2,60(r2)
 3237470:	1885c83a 	sub	r2,r3,r2
 3237474:	10bfffcc 	andi	r2,r2,65535
 3237478:	1004923a 	slli	r2,r2,8
 323747c:	1007883a 	mov	r3,r2
 3237480:	00bfc004 	movi	r2,-256
 3237484:	1884703a 	and	r2,r3,r2
 3237488:	2084b03a 	or	r2,r4,r2
 323748c:	1007883a 	mov	r3,r2
 3237490:	e0bfee17 	ldw	r2,-72(fp)
 3237494:	10c0098d 	sth	r3,38(r2)
      ti->ti_flags |= TH_URG;
 3237498:	e0bfee17 	ldw	r2,-72(fp)
 323749c:	10800843 	ldbu	r2,33(r2)
 32374a0:	10800814 	ori	r2,r2,32
 32374a4:	1007883a 	mov	r3,r2
 32374a8:	e0bfee17 	ldw	r2,-72(fp)
 32374ac:	10c00845 	stb	r3,33(r2)
 32374b0:	00000406 	br	32374c4 <tcp_output+0xe18>
       * If no urgent pointer to send, then we pull
       * the urgent pointer to the left edge of the send window
       * so that it doesn't drift into the send window on sequence
       * number wraparound.
       */
      tp->snd_up = tp->snd_una;        /* drag it along */
 32374b4:	e0bff717 	ldw	r2,-36(fp)
 32374b8:	10c00e17 	ldw	r3,56(r2)
 32374bc:	e0bff717 	ldw	r2,-36(fp)
 32374c0:	10c01015 	stw	r3,64(r2)
   /*
    * If anything to send and we can send it all, set PUSH.
    * (This will keep happy those implementations which only
    * give data to the user when a buffer fills or a PUSH comes in.)
    */
   if (len && off+len == (int)so->so_snd.sb_cc)
 32374c4:	e0bff417 	ldw	r2,-48(fp)
 32374c8:	1005003a 	cmpeq	r2,r2,zero
 32374cc:	10000c1e 	bne	r2,zero,3237500 <tcp_output+0xe54>
 32374d0:	e0fff217 	ldw	r3,-56(fp)
 32374d4:	e0bff417 	ldw	r2,-48(fp)
 32374d8:	1887883a 	add	r3,r3,r2
 32374dc:	e0bff517 	ldw	r2,-44(fp)
 32374e0:	10801217 	ldw	r2,72(r2)
 32374e4:	1880061e 	bne	r3,r2,3237500 <tcp_output+0xe54>
      ti->ti_flags |= TH_PUSH;
 32374e8:	e0bfee17 	ldw	r2,-72(fp)
 32374ec:	10800843 	ldbu	r2,33(r2)
 32374f0:	10800214 	ori	r2,r2,8
 32374f4:	1007883a 	mov	r3,r2
 32374f8:	e0bfee17 	ldw	r2,-72(fp)
 32374fc:	10c00845 	stb	r3,33(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 3237500:	e0bff717 	ldw	r2,-36(fp)
 3237504:	10800a83 	ldbu	r2,42(r2)
 3237508:	10803fcc 	andi	r2,r2,255
 323750c:	1080201c 	xori	r2,r2,128
 3237510:	10bfe004 	addi	r2,r2,-128
 3237514:	1005003a 	cmpeq	r2,r2,zero
 3237518:	1000041e 	bne	r2,zero,323752c <tcp_output+0xe80>
 323751c:	e0bff717 	ldw	r2,-36(fp)
 3237520:	10800417 	ldw	r2,16(r2)
 3237524:	1004c03a 	cmpne	r2,r2,zero
 3237528:	1000561e 	bne	r2,zero,3237684 <tcp_output+0xfd8>
   {
      tcp_seq startseq = tp->snd_nxt;
 323752c:	e0bff717 	ldw	r2,-36(fp)
 3237530:	10800f17 	ldw	r2,60(r2)
 3237534:	e0bfe315 	stw	r2,-116(fp)

      /*
       * Advance snd_nxt over sequence space of this segment.
       */
      if (flags & TH_SYN)
 3237538:	e0bff117 	ldw	r2,-60(fp)
 323753c:	1080008c 	andi	r2,r2,2
 3237540:	1005003a 	cmpeq	r2,r2,zero
 3237544:	1000051e 	bne	r2,zero,323755c <tcp_output+0xeb0>
         tp->snd_nxt++;
 3237548:	e0bff717 	ldw	r2,-36(fp)
 323754c:	10800f17 	ldw	r2,60(r2)
 3237550:	10c00044 	addi	r3,r2,1
 3237554:	e0bff717 	ldw	r2,-36(fp)
 3237558:	10c00f15 	stw	r3,60(r2)

      if (flags & TH_FIN)
 323755c:	e0bff117 	ldw	r2,-60(fp)
 3237560:	1080004c 	andi	r2,r2,1
 3237564:	10803fcc 	andi	r2,r2,255
 3237568:	1005003a 	cmpeq	r2,r2,zero
 323756c:	10000b1e 	bne	r2,zero,323759c <tcp_output+0xef0>
      {
         tp->snd_nxt++;
 3237570:	e0bff717 	ldw	r2,-36(fp)
 3237574:	10800f17 	ldw	r2,60(r2)
 3237578:	10c00044 	addi	r3,r2,1
 323757c:	e0bff717 	ldw	r2,-36(fp)
 3237580:	10c00f15 	stw	r3,60(r2)
         tp->t_flags |= TF_SENTFIN;
 3237584:	e0bff717 	ldw	r2,-36(fp)
 3237588:	10800b0b 	ldhu	r2,44(r2)
 323758c:	10800414 	ori	r2,r2,16
 3237590:	1007883a 	mov	r3,r2
 3237594:	e0bff717 	ldw	r2,-36(fp)
 3237598:	10c00b0d 	sth	r3,44(r2)
      }
      tp->snd_nxt += len;
 323759c:	e0bff717 	ldw	r2,-36(fp)
 32375a0:	10c00f17 	ldw	r3,60(r2)
 32375a4:	e0bff417 	ldw	r2,-48(fp)
 32375a8:	1887883a 	add	r3,r3,r2
 32375ac:	e0bff717 	ldw	r2,-36(fp)
 32375b0:	10c00f15 	stw	r3,60(r2)
      if (SEQ_GT(tp->snd_nxt, tp->snd_max)) 
 32375b4:	e0bff717 	ldw	r2,-36(fp)
 32375b8:	10c00f17 	ldw	r3,60(r2)
 32375bc:	e0bff717 	ldw	r2,-36(fp)
 32375c0:	10801a17 	ldw	r2,104(r2)
 32375c4:	1885c83a 	sub	r2,r3,r2
 32375c8:	10800050 	cmplti	r2,r2,1
 32375cc:	1000171e 	bne	r2,zero,323762c <tcp_output+0xf80>
      {
         tp->snd_max = tp->snd_nxt;
 32375d0:	e0bff717 	ldw	r2,-36(fp)
 32375d4:	10c00f17 	ldw	r3,60(r2)
 32375d8:	e0bff717 	ldw	r2,-36(fp)
 32375dc:	10c01a15 	stw	r3,104(r2)
         /*
          * Time this transmission if not a retransmission and
          * not currently timing anything.
          */
         if (tp->t_rttick == 0) 
 32375e0:	e0bff717 	ldw	r2,-36(fp)
 32375e4:	10801e17 	ldw	r2,120(r2)
 32375e8:	1004c03a 	cmpne	r2,r2,zero
 32375ec:	10000f1e 	bne	r2,zero,323762c <tcp_output+0xf80>
         {
            tp->t_rttick = cticks;
 32375f0:	0080c974 	movhi	r2,805
 32375f4:	10934104 	addi	r2,r2,19716
 32375f8:	10c00017 	ldw	r3,0(r2)
 32375fc:	e0bff717 	ldw	r2,-36(fp)
 3237600:	10c01e15 	stw	r3,120(r2)
            tp->t_rtseq = startseq;
 3237604:	e0fff717 	ldw	r3,-36(fp)
 3237608:	e0bfe317 	ldw	r2,-116(fp)
 323760c:	18801f15 	stw	r2,124(r3)
            tcpstat.tcps_segstimed++;
 3237610:	0080c9b4 	movhi	r2,806
 3237614:	10b4b504 	addi	r2,r2,-11564
 3237618:	10800617 	ldw	r2,24(r2)
 323761c:	10c00044 	addi	r3,r2,1
 3237620:	0080c9b4 	movhi	r2,806
 3237624:	10b4b504 	addi	r2,r2,-11564
 3237628:	10c00615 	stw	r3,24(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 323762c:	e0bff717 	ldw	r2,-36(fp)
 3237630:	10800317 	ldw	r2,12(r2)
 3237634:	1004c03a 	cmpne	r2,r2,zero
 3237638:	1000211e 	bne	r2,zero,32376c0 <tcp_output+0x1014>
 323763c:	e0bff717 	ldw	r2,-36(fp)
 3237640:	10c00f17 	ldw	r3,60(r2)
 3237644:	e0bff717 	ldw	r2,-36(fp)
 3237648:	10800e17 	ldw	r2,56(r2)
 323764c:	18801c26 	beq	r3,r2,32376c0 <tcp_output+0x1014>
          tp->snd_nxt != tp->snd_una) 
      {
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 3237650:	e0bff717 	ldw	r2,-36(fp)
 3237654:	10c00817 	ldw	r3,32(r2)
 3237658:	e0bff717 	ldw	r2,-36(fp)
 323765c:	10c00315 	stw	r3,12(r2)
         if (tp->t_timer[TCPT_PERSIST]) 
 3237660:	e0bff717 	ldw	r2,-36(fp)
 3237664:	10800417 	ldw	r2,16(r2)
 3237668:	1005003a 	cmpeq	r2,r2,zero
 323766c:	1000141e 	bne	r2,zero,32376c0 <tcp_output+0x1014>
         {
            tp->t_timer[TCPT_PERSIST] = 0;
 3237670:	e0bff717 	ldw	r2,-36(fp)
 3237674:	10000415 	stw	zero,16(r2)
            tp->t_rxtshift = 0;
 3237678:	e0bff717 	ldw	r2,-36(fp)
 323767c:	10000715 	stw	zero,28(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 3237680:	00000f06 	br	32376c0 <tcp_output+0x1014>
         }
      }
   }
   else
   {
      if (SEQ_GT(tp->snd_nxt + len, tp->snd_max))
 3237684:	e0bff717 	ldw	r2,-36(fp)
 3237688:	10c00f17 	ldw	r3,60(r2)
 323768c:	e0bff417 	ldw	r2,-48(fp)
 3237690:	1887883a 	add	r3,r3,r2
 3237694:	e0bff717 	ldw	r2,-36(fp)
 3237698:	10801a17 	ldw	r2,104(r2)
 323769c:	1885c83a 	sub	r2,r3,r2
 32376a0:	10800050 	cmplti	r2,r2,1
 32376a4:	1000061e 	bne	r2,zero,32376c0 <tcp_output+0x1014>
         tp->snd_max = tp->snd_nxt + len;
 32376a8:	e0bff717 	ldw	r2,-36(fp)
 32376ac:	10c00f17 	ldw	r3,60(r2)
 32376b0:	e0bff417 	ldw	r2,-48(fp)
 32376b4:	1887883a 	add	r3,r3,r2
 32376b8:	e0bff717 	ldw	r2,-36(fp)
 32376bc:	10c01a15 	stw	r3,104(r2)
   tcp_trace("tcp_output: sending, state %d, tcpcb: %x",
    tp->t_state, tp );
#endif

#ifdef MUTE_WARNS
   error = 0;
 32376c0:	e03ff015 	stw	zero,-64(fp)
   if(so->so_domain != AF_INET6)
#endif   /* IP_V6 */
   {
      struct ip * pip;
   
      pip = mtod(m, struct ip *);
 32376c4:	e0bfef17 	ldw	r2,-68(fp)
 32376c8:	10800317 	ldw	r2,12(r2)
 32376cc:	e0bfe215 	stw	r2,-120(fp)
      /* Fill in IP length and send to IP level. */
      pip->ip_len = (u_short)(TCPIPHDRSZ + optlen + len);
 32376d0:	e0bfed17 	ldw	r2,-76(fp)
 32376d4:	1007883a 	mov	r3,r2
 32376d8:	e0bff417 	ldw	r2,-48(fp)
 32376dc:	1885883a 	add	r2,r3,r2
 32376e0:	10800a04 	addi	r2,r2,40
 32376e4:	1007883a 	mov	r3,r2
 32376e8:	e0bfe217 	ldw	r2,-120(fp)
 32376ec:	10c0008d 	sth	r3,2(r2)
      error = ip_output(m, so->so_optsPack);
 32376f0:	e0bff517 	ldw	r2,-44(fp)
 32376f4:	11401f17 	ldw	r5,124(r2)
 32376f8:	e13fef17 	ldw	r4,-68(fp)
 32376fc:	322ca000 	call	322ca00 <ip_output>
 3237700:	e0bff015 	stw	r2,-64(fp)
                    (sizeof(struct ipv6) + sizeof(struct tcphdr) + optlen + len),
                    (struct   ip_socopts *)0);          
   }
#endif   /* IP_V6 */

   if (error)
 3237704:	e0bff017 	ldw	r2,-64(fp)
 3237708:	1005003a 	cmpeq	r2,r2,zero
 323770c:	1000151e 	bne	r2,zero,3237764 <tcp_output+0x10b8>
   {
      if (error == ENOBUFS)   /* ip_output needed a copy buffer it couldn't get */
 3237710:	e0bff017 	ldw	r2,-64(fp)
 3237714:	10801a58 	cmpnei	r2,r2,105
 3237718:	10000f1e 	bne	r2,zero,3237758 <tcp_output+0x10ac>
      {
         if (m->m_type == MT_FREE)  /* ip_output() probably freed first mbuf */
 323771c:	e0bfef17 	ldw	r2,-68(fp)
 3237720:	10800817 	ldw	r2,32(r2)
 3237724:	1004c03a 	cmpne	r2,r2,zero
 3237728:	1000031e 	bne	r2,zero,3237738 <tcp_output+0x108c>
            m = m->m_next;
 323772c:	e0bfef17 	ldw	r2,-68(fp)
 3237730:	10800617 	ldw	r2,24(r2)
 3237734:	e0bfef15 	stw	r2,-68(fp)
         m_freem(m); /* free the mbuf chain */
 3237738:	e13fef17 	ldw	r4,-68(fp)
 323773c:	322bfcc0 	call	322bfcc <m_freem>
         tcp_quench(tp->t_inpcb);
 3237740:	e0bff717 	ldw	r2,-36(fp)
 3237744:	11000d17 	ldw	r4,52(r2)
 3237748:	32382b00 	call	32382b0 <tcp_quench>
         return (error);
 323774c:	e0bff017 	ldw	r2,-64(fp)
 3237750:	e0bff815 	stw	r2,-32(fp)
 3237754:	00002e06 	br	3237810 <tcp_output+0x1164>
      }
      return (error);
 3237758:	e0fff017 	ldw	r3,-64(fp)
 323775c:	e0fff815 	stw	r3,-32(fp)
 3237760:	00002b06 	br	3237810 <tcp_output+0x1164>

   /*
    * Data sent (as far as we can tell).
    */

   TCP_MIB_INC(tcpOutSegs);   /* keep MIB stats */
 3237764:	0080c9b4 	movhi	r2,806
 3237768:	10b48704 	addi	r2,r2,-11748
 323776c:	10800a17 	ldw	r2,40(r2)
 3237770:	10c00044 	addi	r3,r2,1
 3237774:	0080c9b4 	movhi	r2,806
 3237778:	10b48704 	addi	r2,r2,-11748
 323777c:	10c00a15 	stw	r3,40(r2)
   tcpstat.tcps_sndtotal++;
 3237780:	0080c9b4 	movhi	r2,806
 3237784:	10b4b504 	addi	r2,r2,-11564
 3237788:	10800f17 	ldw	r2,60(r2)
 323778c:	10c00044 	addi	r3,r2,1
 3237790:	0080c9b4 	movhi	r2,806
 3237794:	10b4b504 	addi	r2,r2,-11564
 3237798:	10c00f15 	stw	r3,60(r2)
   /*
    * If this advertises a larger window than any other segment,
    * then remember the size of the advertised window.
    * Any pending ACK has now been sent.
    */
   if (win > 0 && SEQ_GT(tp->rcv_nxt+win, tp->rcv_adv))
 323779c:	e0bff317 	ldw	r2,-52(fp)
 32377a0:	10800050 	cmplti	r2,r2,1
 32377a4:	10000f1e 	bne	r2,zero,32377e4 <tcp_output+0x1138>
 32377a8:	e0bff717 	ldw	r2,-36(fp)
 32377ac:	10c01617 	ldw	r3,88(r2)
 32377b0:	e0bff317 	ldw	r2,-52(fp)
 32377b4:	1887883a 	add	r3,r3,r2
 32377b8:	e0bff717 	ldw	r2,-36(fp)
 32377bc:	10801917 	ldw	r2,100(r2)
 32377c0:	1885c83a 	sub	r2,r3,r2
 32377c4:	10800050 	cmplti	r2,r2,1
 32377c8:	1000061e 	bne	r2,zero,32377e4 <tcp_output+0x1138>
      tp->rcv_adv = tp->rcv_nxt + (unsigned)win;
 32377cc:	e0bff717 	ldw	r2,-36(fp)
 32377d0:	10c01617 	ldw	r3,88(r2)
 32377d4:	e0bff317 	ldw	r2,-52(fp)
 32377d8:	1887883a 	add	r3,r3,r2
 32377dc:	e0bff717 	ldw	r2,-36(fp)
 32377e0:	10c01915 	stw	r3,100(r2)
   tp->t_flags &= ~(TF_ACKNOW|TF_SACKNOW|TF_DELACK);
 32377e4:	e0bff717 	ldw	r2,-36(fp)
 32377e8:	10c00b0b 	ldhu	r3,44(r2)
 32377ec:	00bfef04 	movi	r2,-68
 32377f0:	1884703a 	and	r2,r3,r2
 32377f4:	1007883a 	mov	r3,r2
 32377f8:	e0bff717 	ldw	r2,-36(fp)
 32377fc:	10c00b0d 	sth	r3,44(r2)
   if (sendalot)
 3237800:	e0bfeb17 	ldw	r2,-84(fp)
 3237804:	1004c03a 	cmpne	r2,r2,zero
 3237808:	103bb81e 	bne	r2,zero,32366ec <tcp_output+0x40>
      goto again;
   return (0);
 323780c:	e03ff815 	stw	zero,-32(fp)
 3237810:	e0bff817 	ldw	r2,-32(fp)
}
 3237814:	e037883a 	mov	sp,fp
 3237818:	dfc00117 	ldw	ra,4(sp)
 323781c:	df000017 	ldw	fp,0(sp)
 3237820:	dec00204 	addi	sp,sp,8
 3237824:	f800283a 	ret

03237828 <tcp_setpersist>:
 * RETURNS: NA
 */

void
tcp_setpersist(struct tcpcb * tp)
{
 3237828:	defffc04 	addi	sp,sp,-16
 323782c:	dfc00315 	stw	ra,12(sp)
 3237830:	df000215 	stw	fp,8(sp)
 3237834:	df000204 	addi	fp,sp,8
 3237838:	e13fff15 	stw	r4,-4(fp)
   int   t;

   t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 323783c:	e0bfff17 	ldw	r2,-4(fp)
 3237840:	10802017 	ldw	r2,128(r2)
 3237844:	1007d0ba 	srai	r3,r2,2
 3237848:	e0bfff17 	ldw	r2,-4(fp)
 323784c:	10802117 	ldw	r2,132(r2)
 3237850:	1885883a 	add	r2,r3,r2
 3237854:	1005d07a 	srai	r2,r2,1
 3237858:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_timer[TCPT_REXMT])
 323785c:	e0bfff17 	ldw	r2,-4(fp)
 3237860:	10800317 	ldw	r2,12(r2)
 3237864:	1005003a 	cmpeq	r2,r2,zero
 3237868:	1000031e 	bne	r2,zero,3237878 <tcp_setpersist+0x50>
      panic("tcp_output REXMT");
 323786c:	0100c974 	movhi	r4,805
 3237870:	213e6804 	addi	r4,r4,-1632
 3237874:	32261540 	call	3226154 <panic>
   /*
    * Start/restart persistance timer.
    */
   TCPT_RANGESET(tp->t_timer[TCPT_PERSIST],
 3237878:	e0bfff17 	ldw	r2,-4(fp)
 323787c:	10c00717 	ldw	r3,28(r2)
 3237880:	0080c974 	movhi	r2,805
 3237884:	108960c4 	addi	r2,r2,9603
 3237888:	10c5883a 	add	r2,r2,r3
 323788c:	10800003 	ldbu	r2,0(r2)
 3237890:	10c03fcc 	andi	r3,r2,255
 3237894:	e0bffe17 	ldw	r2,-8(fp)
 3237898:	1885383a 	mul	r2,r3,r2
 323789c:	10ffffcc 	andi	r3,r2,65535
 32378a0:	18e0001c 	xori	r3,r3,32768
 32378a4:	18e00004 	addi	r3,r3,-32768
 32378a8:	e0bfff17 	ldw	r2,-4(fp)
 32378ac:	10c00415 	stw	r3,16(r2)
 32378b0:	e0bfff17 	ldw	r2,-4(fp)
 32378b4:	10800417 	ldw	r2,16(r2)
 32378b8:	10800288 	cmpgei	r2,r2,10
 32378bc:	1000041e 	bne	r2,zero,32378d0 <tcp_setpersist+0xa8>
 32378c0:	e0ffff17 	ldw	r3,-4(fp)
 32378c4:	00800284 	movi	r2,10
 32378c8:	18800415 	stw	r2,16(r3)
 32378cc:	00000706 	br	32378ec <tcp_setpersist+0xc4>
 32378d0:	e0bfff17 	ldw	r2,-4(fp)
 32378d4:	10800417 	ldw	r2,16(r2)
 32378d8:	10801e50 	cmplti	r2,r2,121
 32378dc:	1000031e 	bne	r2,zero,32378ec <tcp_setpersist+0xc4>
 32378e0:	e0ffff17 	ldw	r3,-4(fp)
 32378e4:	00801e04 	movi	r2,120
 32378e8:	18800415 	stw	r2,16(r3)
    t * tcp_backoff[tp->t_rxtshift],
    TCPTV_PERSMIN, TCPTV_PERSMAX);
   if (tp->t_rxtshift < TCP_MAXRXTSHIFT)
 32378ec:	e0bfff17 	ldw	r2,-4(fp)
 32378f0:	10800717 	ldw	r2,28(r2)
 32378f4:	10800308 	cmpgei	r2,r2,12
 32378f8:	1000051e 	bne	r2,zero,3237910 <tcp_setpersist+0xe8>
      tp->t_rxtshift++;
 32378fc:	e0bfff17 	ldw	r2,-4(fp)
 3237900:	10800717 	ldw	r2,28(r2)
 3237904:	10c00044 	addi	r3,r2,1
 3237908:	e0bfff17 	ldw	r2,-4(fp)
 323790c:	10c00715 	stw	r3,28(r2)

}
 3237910:	e037883a 	mov	sp,fp
 3237914:	dfc00117 	ldw	ra,4(sp)
 3237918:	df000017 	ldw	fp,0(sp)
 323791c:	dec00204 	addi	sp,sp,8
 3237920:	f800283a 	ret

03237924 <bld_options>:
 * RETURNS: length of option data added to buffer
 */

static int
bld_options(struct tcpcb * tp, u_char * cp, int flags, struct socket * so)
{
 3237924:	defff704 	addi	sp,sp,-36
 3237928:	dfc00815 	stw	ra,32(sp)
 323792c:	df000715 	stw	fp,28(sp)
 3237930:	df000704 	addi	fp,sp,28
 3237934:	e13ffb15 	stw	r4,-20(fp)
 3237938:	e17ffc15 	stw	r5,-16(fp)
 323793c:	e1bffd15 	stw	r6,-12(fp)
 3237940:	e1fffe15 	stw	r7,-8(fp)
   int      len;
   u_short  mss;

   if(tp->t_flags & TF_NOOPT)    /* no options allowed? */
 3237944:	e0bffb17 	ldw	r2,-20(fp)
 3237948:	10800b0b 	ldhu	r2,44(r2)
 323794c:	10bfffcc 	andi	r2,r2,65535
 3237950:	1080020c 	andi	r2,r2,8
 3237954:	1005003a 	cmpeq	r2,r2,zero
 3237958:	1000021e 	bne	r2,zero,3237964 <bld_options+0x40>
      return 0;
 323795c:	e03fff15 	stw	zero,-4(fp)
 3237960:	00002406 	br	32379f4 <bld_options+0xd0>

   /* Alway put MSS option on SYN packets */
   if (flags & TH_SYN)
 3237964:	e0bffd17 	ldw	r2,-12(fp)
 3237968:	1080008c 	andi	r2,r2,2
 323796c:	1005003a 	cmpeq	r2,r2,zero
 3237970:	10001d1e 	bne	r2,zero,32379e8 <bld_options+0xc4>
   {
      mss   =  (u_short)tcp_mss(so);
 3237974:	e13ffe17 	ldw	r4,-8(fp)
 3237978:	32365900 	call	3236590 <tcp_mss>
 323797c:	e0bff90d 	sth	r2,-28(fp)

      /* always send MSS option on SYN, fill in MSS parm */
      *(cp + 0) = TCPOPT_MAXSEG;
 3237980:	e0fffc17 	ldw	r3,-16(fp)
 3237984:	00800084 	movi	r2,2
 3237988:	18800005 	stb	r2,0(r3)
      *(cp + 1) = MSSOPT_LEN;               /* length byte */
 323798c:	e0bffc17 	ldw	r2,-16(fp)
 3237990:	10c00044 	addi	r3,r2,1
 3237994:	00800104 	movi	r2,4
 3237998:	18800005 	stb	r2,0(r3)
      *(cp + 2)  = (u_char) ((mss & 0xff00) >> 8);
 323799c:	e0bffc17 	ldw	r2,-16(fp)
 32379a0:	10c00084 	addi	r3,r2,2
 32379a4:	e0bff90b 	ldhu	r2,-28(fp)
 32379a8:	10bfc00c 	andi	r2,r2,65280
 32379ac:	1005d23a 	srai	r2,r2,8
 32379b0:	18800005 	stb	r2,0(r3)
      *(cp + 3)  = (u_char) (mss & 0xff);
 32379b4:	e0bffc17 	ldw	r2,-16(fp)
 32379b8:	110000c4 	addi	r4,r2,3
 32379bc:	e0bff90b 	ldhu	r2,-28(fp)
 32379c0:	1007883a 	mov	r3,r2
 32379c4:	00bfffc4 	movi	r2,-1
 32379c8:	1884703a 	and	r2,r3,r2
 32379cc:	20800005 	stb	r2,0(r4)
      len = 4;
 32379d0:	00800104 	movi	r2,4
 32379d4:	e0bffa15 	stw	r2,-24(fp)
      cp += 4;
 32379d8:	e0bffc17 	ldw	r2,-16(fp)
 32379dc:	10800104 	addi	r2,r2,4
 32379e0:	e0bffc15 	stw	r2,-16(fp)
 32379e4:	00000106 	br	32379ec <bld_options+0xc8>
   }
   else
      len = 0;
 32379e8:	e03ffa15 	stw	zero,-24(fp)
      len += 10;
   }
#endif   /* TCP_TIMESTAMP */

   USE_ARG(so);
   return len;
 32379ec:	e0bffa17 	ldw	r2,-24(fp)
 32379f0:	e0bfff15 	stw	r2,-4(fp)
 32379f4:	e0bfff17 	ldw	r2,-4(fp)
}
 32379f8:	e037883a 	mov	sp,fp
 32379fc:	dfc00117 	ldw	ra,4(sp)
 3237a00:	df000017 	ldw	fp,0(sp)
 3237a04:	dec00204 	addi	sp,sp,8
 3237a08:	f800283a 	ret

03237a0c <tcp_init>:
 * RETURNS: 
 */

void
tcp_init()
{
 3237a0c:	deffff04 	addi	sp,sp,-4
 3237a10:	df000015 	stw	fp,0(sp)
 3237a14:	d839883a 	mov	fp,sp
   tcp_iss = 1;      /* wrong */
 3237a18:	00c0c974 	movhi	r3,805
 3237a1c:	18d34e04 	addi	r3,r3,19768
 3237a20:	00800044 	movi	r2,1
 3237a24:	18800015 	stw	r2,0(r3)
   tcb.inp_next = tcb.inp_prev = &tcb;
 3237a28:	00c0c9b4 	movhi	r3,806
 3237a2c:	18f4aa04 	addi	r3,r3,-11608
 3237a30:	0080c9b4 	movhi	r2,806
 3237a34:	10b4aa04 	addi	r2,r2,-11608
 3237a38:	18800115 	stw	r2,4(r3)
 3237a3c:	0080c9b4 	movhi	r2,806
 3237a40:	10b4aa04 	addi	r2,r2,-11608
 3237a44:	10c00117 	ldw	r3,4(r2)
 3237a48:	0080c9b4 	movhi	r2,806
 3237a4c:	10b4aa04 	addi	r2,r2,-11608
 3237a50:	10c00015 	stw	r3,0(r2)
}
 3237a54:	e037883a 	mov	sp,fp
 3237a58:	df000017 	ldw	fp,0(sp)
 3237a5c:	dec00104 	addi	sp,sp,4
 3237a60:	f800283a 	ret

03237a64 <tcp_template>:
 * RETURNS: 
 */

struct tcpiphdr * 
tcp_template(struct tcpcb * tp)
{
 3237a64:	defffa04 	addi	sp,sp,-24
 3237a68:	dfc00515 	stw	ra,20(sp)
 3237a6c:	df000415 	stw	fp,16(sp)
 3237a70:	df000404 	addi	fp,sp,16
 3237a74:	e13ffe15 	stw	r4,-8(fp)
   struct inpcb * inp   =  tp->t_inpcb;
 3237a78:	e0bffe17 	ldw	r2,-8(fp)
 3237a7c:	10800d17 	ldw	r2,52(r2)
 3237a80:	e0bffd15 	stw	r2,-12(fp)
   struct tcpiphdr * n;

   if ((n = tp->t_template) == 0)
 3237a84:	e0bffe17 	ldw	r2,-8(fp)
 3237a88:	10800c17 	ldw	r2,48(r2)
 3237a8c:	e0bffc15 	stw	r2,-16(fp)
 3237a90:	e0bffc17 	ldw	r2,-16(fp)
 3237a94:	1004c03a 	cmpne	r2,r2,zero
 3237a98:	1000081e 	bne	r2,zero,3237abc <tcp_template+0x58>
   {
      n = (struct tcpiphdr *)TPH_ALLOC (sizeof (*n));
 3237a9c:	01000a04 	movi	r4,40
 3237aa0:	322b9340 	call	322b934 <npalloc>
 3237aa4:	e0bffc15 	stw	r2,-16(fp)
      if (n == NULL)
 3237aa8:	e0bffc17 	ldw	r2,-16(fp)
 3237aac:	1004c03a 	cmpne	r2,r2,zero
 3237ab0:	1000021e 	bne	r2,zero,3237abc <tcp_template+0x58>
         return (0);
 3237ab4:	e03fff15 	stw	zero,-4(fp)
 3237ab8:	00002a06 	br	3237b64 <tcp_template+0x100>
   }
   n->ti_next = n->ti_prev = 0;
 3237abc:	e0bffc17 	ldw	r2,-16(fp)
 3237ac0:	10000115 	stw	zero,4(r2)
 3237ac4:	e0bffc17 	ldw	r2,-16(fp)
 3237ac8:	10c00117 	ldw	r3,4(r2)
 3237acc:	e0bffc17 	ldw	r2,-16(fp)
 3237ad0:	10c00015 	stw	r3,0(r2)
   n->ti_len = htons(sizeof (struct tcpiphdr) - sizeof (struct ip));
 3237ad4:	e0fffc17 	ldw	r3,-16(fp)
 3237ad8:	00850004 	movi	r2,5120
 3237adc:	1880028d 	sth	r2,10(r3)
   n->ti_src = inp->inp_laddr;
 3237ae0:	e0bffd17 	ldw	r2,-12(fp)
 3237ae4:	10c00417 	ldw	r3,16(r2)
 3237ae8:	e0bffc17 	ldw	r2,-16(fp)
 3237aec:	10c00315 	stw	r3,12(r2)
   n->ti_dst = inp->inp_faddr;
 3237af0:	e0bffd17 	ldw	r2,-12(fp)
 3237af4:	10c00317 	ldw	r3,12(r2)
 3237af8:	e0bffc17 	ldw	r2,-16(fp)
 3237afc:	10c00415 	stw	r3,16(r2)
   n->ti_sport = inp->inp_lport;
 3237b00:	e0bffd17 	ldw	r2,-12(fp)
 3237b04:	10c0078b 	ldhu	r3,30(r2)
 3237b08:	e0bffc17 	ldw	r2,-16(fp)
 3237b0c:	10c0050d 	sth	r3,20(r2)
   n->ti_dport = inp->inp_fport;
 3237b10:	e0bffd17 	ldw	r2,-12(fp)
 3237b14:	10c0070b 	ldhu	r3,28(r2)
 3237b18:	e0bffc17 	ldw	r2,-16(fp)
 3237b1c:	10c0058d 	sth	r3,22(r2)
   n->ti_seq = 0;
 3237b20:	e0bffc17 	ldw	r2,-16(fp)
 3237b24:	10000615 	stw	zero,24(r2)
   n->ti_ack = 0;
 3237b28:	e0bffc17 	ldw	r2,-16(fp)
 3237b2c:	10000715 	stw	zero,28(r2)
   n->ti_t.th_doff = (5 << 4);   /* NetPort */
 3237b30:	e0fffc17 	ldw	r3,-16(fp)
 3237b34:	00801404 	movi	r2,80
 3237b38:	18800805 	stb	r2,32(r3)
   n->ti_flags = 0;
 3237b3c:	e0bffc17 	ldw	r2,-16(fp)
 3237b40:	10000845 	stb	zero,33(r2)
   n->ti_win = 0;
 3237b44:	e0bffc17 	ldw	r2,-16(fp)
 3237b48:	1000088d 	sth	zero,34(r2)
   n->ti_sum = 0;
 3237b4c:	e0bffc17 	ldw	r2,-16(fp)
 3237b50:	1000090d 	sth	zero,36(r2)
   n->ti_urp = 0;
 3237b54:	e0bffc17 	ldw	r2,-16(fp)
 3237b58:	1000098d 	sth	zero,38(r2)
   return (n);
 3237b5c:	e0bffc17 	ldw	r2,-16(fp)
 3237b60:	e0bfff15 	stw	r2,-4(fp)
 3237b64:	e0bfff17 	ldw	r2,-4(fp)
}
 3237b68:	e037883a 	mov	sp,fp
 3237b6c:	dfc00117 	ldw	ra,4(sp)
 3237b70:	df000017 	ldw	fp,0(sp)
 3237b74:	dec00204 	addi	sp,sp,8
 3237b78:	f800283a 	ret

03237b7c <tcp_respond>:
   struct tcpiphdr * ti,
   tcp_seq  ack,
   tcp_seq  seq,
   int   flags,
   struct mbuf *  ti_mbuf)
{
 3237b7c:	defff104 	addi	sp,sp,-60
 3237b80:	dfc00e15 	stw	ra,56(sp)
 3237b84:	df000d15 	stw	fp,52(sp)
 3237b88:	df000d04 	addi	fp,sp,52
 3237b8c:	e13ffb15 	stw	r4,-20(fp)
 3237b90:	e17ffc15 	stw	r5,-16(fp)
 3237b94:	e1bffd15 	stw	r6,-12(fp)
 3237b98:	e1fffe15 	stw	r7,-8(fp)
   int      tlen;       /* tcp data len - 0 or 1 */
   int      domain;     /* AF_INET or AF_INET6 */
   int      win = 0;    /* window to use in sent packet */
 3237b9c:	e03ff815 	stw	zero,-32(fp)
   struct mbuf *  m;    /* mbuf to send */
   struct tcpiphdr * tmp_thdr;   /* scratch */

   if (tp)
 3237ba0:	e0bffb17 	ldw	r2,-20(fp)
 3237ba4:	1005003a 	cmpeq	r2,r2,zero
 3237ba8:	10001a1e 	bne	r2,zero,3237c14 <tcp_respond+0x98>
      win = (int)sbspace(&tp->t_inpcb->inp_socket->so_rcv);
 3237bac:	e0bffb17 	ldw	r2,-20(fp)
 3237bb0:	10800d17 	ldw	r2,52(r2)
 3237bb4:	10800817 	ldw	r2,32(r2)
 3237bb8:	10800b17 	ldw	r2,44(r2)
 3237bbc:	1007883a 	mov	r3,r2
 3237bc0:	e0bffb17 	ldw	r2,-20(fp)
 3237bc4:	10800d17 	ldw	r2,52(r2)
 3237bc8:	10800817 	ldw	r2,32(r2)
 3237bcc:	10800a17 	ldw	r2,40(r2)
 3237bd0:	1885c83a 	sub	r2,r3,r2
 3237bd4:	1004803a 	cmplt	r2,r2,zero
 3237bd8:	10000b1e 	bne	r2,zero,3237c08 <tcp_respond+0x8c>
 3237bdc:	e0bffb17 	ldw	r2,-20(fp)
 3237be0:	10800d17 	ldw	r2,52(r2)
 3237be4:	10800817 	ldw	r2,32(r2)
 3237be8:	10c00b17 	ldw	r3,44(r2)
 3237bec:	e0bffb17 	ldw	r2,-20(fp)
 3237bf0:	10800d17 	ldw	r2,52(r2)
 3237bf4:	10800817 	ldw	r2,32(r2)
 3237bf8:	10800a17 	ldw	r2,40(r2)
 3237bfc:	1885c83a 	sub	r2,r3,r2
 3237c00:	e0bfff15 	stw	r2,-4(fp)
 3237c04:	00000106 	br	3237c0c <tcp_respond+0x90>
 3237c08:	e03fff15 	stw	zero,-4(fp)
 3237c0c:	e0bfff17 	ldw	r2,-4(fp)
 3237c10:	e0bff815 	stw	r2,-32(fp)

   /* Figure out of we can recycle the passed buffer or if we need a 
    * new one. Construct the easy parts of the the TCP and IP headers.
    */
   if (flags == 0)   /* sending keepalive from timer */
 3237c14:	e0800217 	ldw	r2,8(fp)
 3237c18:	1004c03a 	cmpne	r2,r2,zero
 3237c1c:	1000391e 	bne	r2,zero,3237d04 <tcp_respond+0x188>
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
 3237c20:	010000c4 	movi	r4,3
 3237c24:	01401004 	movi	r5,64
 3237c28:	322bcf00 	call	322bcf0 <m_getnbuf>
 3237c2c:	e0bff715 	stw	r2,-36(fp)
      if (m == NULL)
 3237c30:	e0bff717 	ldw	r2,-36(fp)
 3237c34:	1005003a 	cmpeq	r2,r2,zero
 3237c38:	1000ed1e 	bne	r2,zero,3237ff0 <tcp_respond+0x474>
         return;
      tlen = 1;   /* Keepalives have one byte of data */
 3237c3c:	00800044 	movi	r2,1
 3237c40:	e0bffa15 	stw	r2,-24(fp)
      m->m_len = TCPIPHDRSZ + tlen;
 3237c44:	e0bffa17 	ldw	r2,-24(fp)
 3237c48:	10800a04 	addi	r2,r2,40
 3237c4c:	1007883a 	mov	r3,r2
 3237c50:	e0bff717 	ldw	r2,-36(fp)
 3237c54:	10c00215 	stw	r3,8(r2)
      /*
       * Copy template contents into the mbuf and set ti to point
       * to the header structure in the mbuf.
       */
      tmp_thdr = (struct tcpiphdr *)((char *)m->m_data+sizeof(struct ip)
 3237c58:	e0bff717 	ldw	r2,-36(fp)
 3237c5c:	10800317 	ldw	r2,12(r2)
 3237c60:	e0bff615 	stw	r2,-40(fp)
         - sizeof(struct ipovly));
      if ((char *)tmp_thdr < m->pkt->nb_buff)
 3237c64:	e0bff717 	ldw	r2,-36(fp)
 3237c68:	10800117 	ldw	r2,4(r2)
 3237c6c:	10c00117 	ldw	r3,4(r2)
 3237c70:	e0bff617 	ldw	r2,-40(fp)
 3237c74:	10c0032e 	bgeu	r2,r3,3237c84 <tcp_respond+0x108>
      {
         panic("tcp_respond- packet ptr underflow\n");
 3237c78:	0100c974 	movhi	r4,805
 3237c7c:	213e6d04 	addi	r4,r4,-1612
 3237c80:	32261540 	call	3226154 <panic>
      }
      MEMCPY(tmp_thdr, ti, sizeof(struct tcpiphdr));
 3237c84:	e13ff617 	ldw	r4,-40(fp)
 3237c88:	e0fffc17 	ldw	r3,-16(fp)
 3237c8c:	18800017 	ldw	r2,0(r3)
 3237c90:	20800015 	stw	r2,0(r4)
 3237c94:	18800117 	ldw	r2,4(r3)
 3237c98:	20800115 	stw	r2,4(r4)
 3237c9c:	18800217 	ldw	r2,8(r3)
 3237ca0:	20800215 	stw	r2,8(r4)
 3237ca4:	18800317 	ldw	r2,12(r3)
 3237ca8:	20800315 	stw	r2,12(r4)
 3237cac:	18800417 	ldw	r2,16(r3)
 3237cb0:	20800415 	stw	r2,16(r4)
 3237cb4:	18800517 	ldw	r2,20(r3)
 3237cb8:	20800515 	stw	r2,20(r4)
 3237cbc:	18800617 	ldw	r2,24(r3)
 3237cc0:	20800615 	stw	r2,24(r4)
 3237cc4:	18800717 	ldw	r2,28(r3)
 3237cc8:	20800715 	stw	r2,28(r4)
 3237ccc:	18800817 	ldw	r2,32(r3)
 3237cd0:	20800815 	stw	r2,32(r4)
 3237cd4:	18800917 	ldw	r2,36(r3)
 3237cd8:	20800915 	stw	r2,36(r4)
      ti = tmp_thdr;
 3237cdc:	e0bff617 	ldw	r2,-40(fp)
 3237ce0:	e0bffc15 	stw	r2,-16(fp)
      flags = TH_ACK;
 3237ce4:	00800404 	movi	r2,16
 3237ce8:	e0800215 	stw	r2,8(fp)
      domain = tp->t_inpcb->inp_socket->so_domain;
 3237cec:	e0bffb17 	ldw	r2,-20(fp)
 3237cf0:	10800d17 	ldw	r2,52(r2)
 3237cf4:	10800817 	ldw	r2,32(r2)
 3237cf8:	10800517 	ldw	r2,20(r2)
 3237cfc:	e0bff915 	stw	r2,-28(fp)
 3237d00:	00003b06 	br	3237df0 <tcp_respond+0x274>
   }
   else  /* Flag was passed (e.g. reset); recycle passed mbuf */
   {
      m = ti_mbuf;   /*dtom(ti);*/
 3237d04:	e0800317 	ldw	r2,12(fp)
 3237d08:	e0bff715 	stw	r2,-36(fp)
      if(m->pkt->type == IPTP)   /* IPv4 packet */
 3237d0c:	e0bff717 	ldw	r2,-36(fp)
 3237d10:	10800117 	ldw	r2,4(r2)
 3237d14:	1080080b 	ldhu	r2,32(r2)
 3237d18:	10bfffcc 	andi	r2,r2,65535
 3237d1c:	10800218 	cmpnei	r2,r2,8
 3237d20:	1000031e 	bne	r2,zero,3237d30 <tcp_respond+0x1b4>
         domain = AF_INET;
 3237d24:	00800084 	movi	r2,2
 3237d28:	e0bff915 	stw	r2,-28(fp)
 3237d2c:	00000206 	br	3237d38 <tcp_respond+0x1bc>
      else
         domain = AF_INET6;
 3237d30:	008000c4 	movi	r2,3
 3237d34:	e0bff915 	stw	r2,-28(fp)

      m_freem(m->m_next);
 3237d38:	e0bff717 	ldw	r2,-36(fp)
 3237d3c:	11000617 	ldw	r4,24(r2)
 3237d40:	322bfcc0 	call	322bfcc <m_freem>
      m->m_next = 0;
 3237d44:	e0bff717 	ldw	r2,-36(fp)
 3237d48:	10000615 	stw	zero,24(r2)
      tlen = 0;         /* NO data */
 3237d4c:	e03ffa15 	stw	zero,-24(fp)
      m->m_len = TCPIPHDRSZ;
 3237d50:	e0fff717 	ldw	r3,-36(fp)
 3237d54:	00800a04 	movi	r2,40
 3237d58:	18800215 	stw	r2,8(r3)
      xchg(ti->ti_dport, ti->ti_sport, u_short);
 3237d5c:	e0bffc17 	ldw	r2,-16(fp)
 3237d60:	1080058b 	ldhu	r2,22(r2)
 3237d64:	e0bff50d 	sth	r2,-44(fp)
 3237d68:	e0bffc17 	ldw	r2,-16(fp)
 3237d6c:	10c0050b 	ldhu	r3,20(r2)
 3237d70:	e0bffc17 	ldw	r2,-16(fp)
 3237d74:	10c0058d 	sth	r3,22(r2)
 3237d78:	e0fffc17 	ldw	r3,-16(fp)
 3237d7c:	e0bff50b 	ldhu	r2,-44(fp)
 3237d80:	1880050d 	sth	r2,20(r3)
      if(m->pkt->type == IPTP)
 3237d84:	e0bff717 	ldw	r2,-36(fp)
 3237d88:	10800117 	ldw	r2,4(r2)
 3237d8c:	1080080b 	ldhu	r2,32(r2)
 3237d90:	10bfffcc 	andi	r2,r2,65535
 3237d94:	10800218 	cmpnei	r2,r2,8
 3237d98:	10000a1e 	bne	r2,zero,3237dc4 <tcp_respond+0x248>
         xchg(ti->ti_dst.s_addr, ti->ti_src.s_addr, u_long);
 3237d9c:	e0bffc17 	ldw	r2,-16(fp)
 3237da0:	10800417 	ldw	r2,16(r2)
 3237da4:	e0bff415 	stw	r2,-48(fp)
 3237da8:	e0bffc17 	ldw	r2,-16(fp)
 3237dac:	10c00317 	ldw	r3,12(r2)
 3237db0:	e0bffc17 	ldw	r2,-16(fp)
 3237db4:	10c00415 	stw	r3,16(r2)
 3237db8:	e0fffc17 	ldw	r3,-16(fp)
 3237dbc:	e0bff417 	ldw	r2,-48(fp)
 3237dc0:	18800315 	stw	r2,12(r3)
      if (flags & TH_RST)  /* count resets in MIB */
 3237dc4:	e0800217 	ldw	r2,8(fp)
 3237dc8:	1080010c 	andi	r2,r2,4
 3237dcc:	1005003a 	cmpeq	r2,r2,zero
 3237dd0:	1000071e 	bne	r2,zero,3237df0 <tcp_respond+0x274>
         TCP_MIB_INC(tcpOutRsts);   /* keep MIB stats */
 3237dd4:	0080c9b4 	movhi	r2,806
 3237dd8:	10b48704 	addi	r2,r2,-11748
 3237ddc:	10800e17 	ldw	r2,56(r2)
 3237de0:	10c00044 	addi	r3,r2,1
 3237de4:	0080c9b4 	movhi	r2,806
 3237de8:	10b48704 	addi	r2,r2,-11748
 3237dec:	10c00e15 	stw	r3,56(r2)
   }

   /* finish constructing the TCP header */
   ti->ti_seq = htonl(seq);
 3237df0:	e0bffe17 	ldw	r2,-8(fp)
 3237df4:	1004d63a 	srli	r2,r2,24
 3237df8:	10c03fcc 	andi	r3,r2,255
 3237dfc:	e0bffe17 	ldw	r2,-8(fp)
 3237e00:	1004d23a 	srli	r2,r2,8
 3237e04:	10bfc00c 	andi	r2,r2,65280
 3237e08:	1886b03a 	or	r3,r3,r2
 3237e0c:	e0bffe17 	ldw	r2,-8(fp)
 3237e10:	10bfc00c 	andi	r2,r2,65280
 3237e14:	1004923a 	slli	r2,r2,8
 3237e18:	1886b03a 	or	r3,r3,r2
 3237e1c:	e0bffe17 	ldw	r2,-8(fp)
 3237e20:	10803fcc 	andi	r2,r2,255
 3237e24:	1004963a 	slli	r2,r2,24
 3237e28:	1886b03a 	or	r3,r3,r2
 3237e2c:	e0bffc17 	ldw	r2,-16(fp)
 3237e30:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(ack);
 3237e34:	e0bffd17 	ldw	r2,-12(fp)
 3237e38:	1004d63a 	srli	r2,r2,24
 3237e3c:	10c03fcc 	andi	r3,r2,255
 3237e40:	e0bffd17 	ldw	r2,-12(fp)
 3237e44:	1004d23a 	srli	r2,r2,8
 3237e48:	10bfc00c 	andi	r2,r2,65280
 3237e4c:	1886b03a 	or	r3,r3,r2
 3237e50:	e0bffd17 	ldw	r2,-12(fp)
 3237e54:	10bfc00c 	andi	r2,r2,65280
 3237e58:	1004923a 	slli	r2,r2,8
 3237e5c:	1886b03a 	or	r3,r3,r2
 3237e60:	e0bffd17 	ldw	r2,-12(fp)
 3237e64:	10803fcc 	andi	r2,r2,255
 3237e68:	1004963a 	slli	r2,r2,24
 3237e6c:	1886b03a 	or	r3,r3,r2
 3237e70:	e0bffc17 	ldw	r2,-16(fp)
 3237e74:	10c00715 	stw	r3,28(r2)
   ti->ti_t.th_doff = 0x50;      /* NetPort: init data offset bits */
 3237e78:	e0fffc17 	ldw	r3,-16(fp)
 3237e7c:	00801404 	movi	r2,80
 3237e80:	18800805 	stb	r2,32(r3)
   ti->ti_flags = (u_char)flags;
 3237e84:	e0800217 	ldw	r2,8(fp)
 3237e88:	1007883a 	mov	r3,r2
 3237e8c:	e0bffc17 	ldw	r2,-16(fp)
 3237e90:	10c00845 	stb	r3,33(r2)
   ti->ti_win = htons((u_short)win);
 3237e94:	e0bff817 	ldw	r2,-32(fp)
 3237e98:	10bfffcc 	andi	r2,r2,65535
 3237e9c:	1004d23a 	srli	r2,r2,8
 3237ea0:	10803fcc 	andi	r2,r2,255
 3237ea4:	1009883a 	mov	r4,r2
 3237ea8:	e0bff817 	ldw	r2,-32(fp)
 3237eac:	10bfffcc 	andi	r2,r2,65535
 3237eb0:	1004923a 	slli	r2,r2,8
 3237eb4:	1007883a 	mov	r3,r2
 3237eb8:	00bfc004 	movi	r2,-256
 3237ebc:	1884703a 	and	r2,r3,r2
 3237ec0:	2084b03a 	or	r2,r4,r2
 3237ec4:	1007883a 	mov	r3,r2
 3237ec8:	e0bffc17 	ldw	r2,-16(fp)
 3237ecc:	10c0088d 	sth	r3,34(r2)
   ti->ti_urp = 0;
 3237ed0:	e0bffc17 	ldw	r2,-16(fp)
 3237ed4:	1000098d 	sth	zero,38(r2)

   /* Finish constructing IP header and send, based on IP type in use */
   switch(domain)
 3237ed8:	e0bff917 	ldw	r2,-28(fp)
 3237edc:	108000a0 	cmpeqi	r2,r2,2
 3237ee0:	1000011e 	bne	r2,zero,3237ee8 <tcp_respond+0x36c>
 3237ee4:	00004106 	br	3237fec <tcp_respond+0x470>
#ifdef IP_V4
      case AF_INET:
      {
         struct ip * pip;

         pip = (struct ip *)((char*)ti+sizeof(struct ipovly)-sizeof(struct ip));
 3237ee8:	e0bffc17 	ldw	r2,-16(fp)
 3237eec:	e0bff315 	stw	r2,-52(fp)

         pip->ip_len = (unshort)(TCPIPHDRSZ + tlen);
 3237ef0:	e0bffa17 	ldw	r2,-24(fp)
 3237ef4:	10800a04 	addi	r2,r2,40
 3237ef8:	1007883a 	mov	r3,r2
 3237efc:	e0bff317 	ldw	r2,-52(fp)
 3237f00:	10c0008d 	sth	r3,2(r2)
         /* If our system's max. MAC header size is geater than the size 
          * of the MAC header in the received packet then we need to 
          * adjust the IP header offset to allow for this. Since the packets 
          * are only headers they should always fit.
          */
         if(pip >= (struct ip *)(m->pkt->nb_buff + MaxLnh))
 3237f04:	e0bff717 	ldw	r2,-36(fp)
 3237f08:	10800117 	ldw	r2,4(r2)
 3237f0c:	10c00117 	ldw	r3,4(r2)
 3237f10:	0080c974 	movhi	r2,805
 3237f14:	10931a04 	addi	r2,r2,19560
 3237f18:	10800017 	ldw	r2,0(r2)
 3237f1c:	1885883a 	add	r2,r3,r2
 3237f20:	1007883a 	mov	r3,r2
 3237f24:	e0bff317 	ldw	r2,-52(fp)
 3237f28:	10c00436 	bltu	r2,r3,3237f3c <tcp_respond+0x3c0>
         {
            m->m_data = (char*)pip; /* headers will fit, just set pointer */
 3237f2c:	e0fff317 	ldw	r3,-52(fp)
 3237f30:	e0bff717 	ldw	r2,-36(fp)
 3237f34:	10c00315 	stw	r3,12(r2)
 3237f38:	00001206 	br	3237f84 <tcp_respond+0x408>
         }
         else     /* MAC may not fit, adjust pointer and move headers back */
         {
            m->m_data = m->pkt->nb_prot = m->pkt->nb_buff + MaxLnh;  /* new ptr */
 3237f3c:	e0bff717 	ldw	r2,-36(fp)
 3237f40:	11000117 	ldw	r4,4(r2)
 3237f44:	e0bff717 	ldw	r2,-36(fp)
 3237f48:	10800117 	ldw	r2,4(r2)
 3237f4c:	10c00117 	ldw	r3,4(r2)
 3237f50:	0080c974 	movhi	r2,805
 3237f54:	10931a04 	addi	r2,r2,19560
 3237f58:	10800017 	ldw	r2,0(r2)
 3237f5c:	1885883a 	add	r2,r3,r2
 3237f60:	20800315 	stw	r2,12(r4)
 3237f64:	20c00317 	ldw	r3,12(r4)
 3237f68:	e0bff717 	ldw	r2,-36(fp)
 3237f6c:	10c00315 	stw	r3,12(r2)
            MEMMOVE(m->m_data, pip, TCPIPHDRSZ);  /* move back tcp/ip headers */
 3237f70:	e0bff717 	ldw	r2,-36(fp)
 3237f74:	11000317 	ldw	r4,12(r2)
 3237f78:	e17ff317 	ldw	r5,-52(fp)
 3237f7c:	01800a04 	movi	r6,40
 3237f80:	3206b700 	call	3206b70 <memmove>

         /*
          * In the case of a SYN DOS attack, many RST|ACK replies
          *   have no tp structure and need to be freed.
          */
         if (!tp)
 3237f84:	e0bffb17 	ldw	r2,-20(fp)
 3237f88:	1004c03a 	cmpne	r2,r2,zero
 3237f8c:	1000031e 	bne	r2,zero,3237f9c <tcp_respond+0x420>
              m_freem(m);
 3237f90:	e13ff717 	ldw	r4,-36(fp)
 3237f94:	322bfcc0 	call	322bfcc <m_freem>
 3237f98:	00001506 	br	3237ff0 <tcp_respond+0x474>
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 3237f9c:	e0bffb17 	ldw	r2,-20(fp)
 3237fa0:	10800d17 	ldw	r2,52(r2)
 3237fa4:	1005003a 	cmpeq	r2,r2,zero
 3237fa8:	10000c1e 	bne	r2,zero,3237fdc <tcp_respond+0x460>
 3237fac:	e0bffb17 	ldw	r2,-20(fp)
 3237fb0:	10800d17 	ldw	r2,52(r2)
 3237fb4:	10800817 	ldw	r2,32(r2)
 3237fb8:	1005003a 	cmpeq	r2,r2,zero
 3237fbc:	1000071e 	bne	r2,zero,3237fdc <tcp_respond+0x460>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
 3237fc0:	e0bffb17 	ldw	r2,-20(fp)
 3237fc4:	10800d17 	ldw	r2,52(r2)
 3237fc8:	10800817 	ldw	r2,32(r2)
 3237fcc:	11401f17 	ldw	r5,124(r2)
 3237fd0:	e13ff717 	ldw	r4,-36(fp)
 3237fd4:	322ca000 	call	322ca00 <ip_output>
          */
         if (!tp)
              m_freem(m);
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 3237fd8:	00000506 	br	3237ff0 <tcp_respond+0x474>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
 3237fdc:	e13ff717 	ldw	r4,-36(fp)
 3237fe0:	000b883a 	mov	r5,zero
 3237fe4:	322ca000 	call	322ca00 <ip_output>
		 }

         break;
 3237fe8:	00000106 	br	3237ff0 <tcp_respond+0x474>

         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();
 3237fec:	322aef00 	call	322aef0 <dtrap>
         break;
   }
   return;
}
 3237ff0:	e037883a 	mov	sp,fp
 3237ff4:	dfc00117 	ldw	ra,4(sp)
 3237ff8:	df000017 	ldw	fp,0(sp)
 3237ffc:	dec00204 	addi	sp,sp,8
 3238000:	f800283a 	ret

03238004 <tcp_newtcpcb>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_newtcpcb(struct inpcb * inp)
{
 3238004:	defffa04 	addi	sp,sp,-24
 3238008:	dfc00515 	stw	ra,20(sp)
 323800c:	df000415 	stw	fp,16(sp)
 3238010:	df000404 	addi	fp,sp,16
 3238014:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
   short t_time;

   tp = TCB_ALLOC(sizeof (*tp));
 3238018:	01002504 	movi	r4,148
 323801c:	322b9340 	call	322b934 <npalloc>
 3238020:	e0bffd15 	stw	r2,-12(fp)
   if (tp == NULL)
 3238024:	e0bffd17 	ldw	r2,-12(fp)
 3238028:	1004c03a 	cmpne	r2,r2,zero
 323802c:	1000021e 	bne	r2,zero,3238038 <tcp_newtcpcb+0x34>
      return (struct tcpcb *)NULL;
 3238030:	e03fff15 	stw	zero,-4(fp)
 3238034:	00003306 	br	3238104 <tcp_newtcpcb+0x100>
   tp->seg_next = tp->seg_prev = (struct tcpiphdr *)tp;
 3238038:	e0fffd17 	ldw	r3,-12(fp)
 323803c:	e0bffd17 	ldw	r2,-12(fp)
 3238040:	10c00115 	stw	r3,4(r2)
 3238044:	e0bffd17 	ldw	r2,-12(fp)
 3238048:	10c00117 	ldw	r3,4(r2)
 323804c:	e0bffd17 	ldw	r2,-12(fp)
 3238050:	10c00015 	stw	r3,0(r2)
   tp->t_maxseg = TCP_MSS;
 3238054:	e0fffd17 	ldw	r3,-12(fp)
 3238058:	00816d04 	movi	r2,1460
 323805c:	18800a0d 	sth	r2,40(r3)
   tp->t_flags = 0;        /* sends options! */
 3238060:	e0bffd17 	ldw	r2,-12(fp)
 3238064:	10000b0d 	sth	zero,44(r2)
   tp->t_inpcb = inp;
 3238068:	e0fffd17 	ldw	r3,-12(fp)
 323806c:	e0bffe17 	ldw	r2,-8(fp)
 3238070:	18800d15 	stw	r2,52(r3)
   /*
    * Init srtt to TCPTV_SRTTBASE (0), so we can tell that we have no
    * rtt estimate.  Set rttvar so that srtt + 2 * rttvar gives
    * reasonable initial retransmit time.
    */
   tp->t_srtt = TCPTV_SRTTBASE;
 3238074:	e0bffd17 	ldw	r2,-12(fp)
 3238078:	10002015 	stw	zero,128(r2)
   tp->t_rttvar = TCPTV_SRTTDFLT << 2;
 323807c:	e0fffd17 	ldw	r3,-12(fp)
 3238080:	00800604 	movi	r2,24
 3238084:	18802115 	stw	r2,132(r3)

   t_time = ((TCPTV_SRTTBASE >> 2) + (TCPTV_SRTTDFLT << 2)) >> 1;
 3238088:	00800304 	movi	r2,12
 323808c:	e0bffc0d 	sth	r2,-16(fp)
   TCPT_RANGESET(tp->t_rxtcur, t_time, TCPTV_MIN, TCPTV_REXMTMAX);
 3238090:	e0fffc0f 	ldh	r3,-16(fp)
 3238094:	e0bffd17 	ldw	r2,-12(fp)
 3238098:	10c00815 	stw	r3,32(r2)
 323809c:	e0bffd17 	ldw	r2,-12(fp)
 32380a0:	10800817 	ldw	r2,32(r2)
 32380a4:	10800088 	cmpgei	r2,r2,2
 32380a8:	1000041e 	bne	r2,zero,32380bc <tcp_newtcpcb+0xb8>
 32380ac:	e0fffd17 	ldw	r3,-12(fp)
 32380b0:	00800084 	movi	r2,2
 32380b4:	18800815 	stw	r2,32(r3)
 32380b8:	00000706 	br	32380d8 <tcp_newtcpcb+0xd4>
 32380bc:	e0bffd17 	ldw	r2,-12(fp)
 32380c0:	10800817 	ldw	r2,32(r2)
 32380c4:	10802050 	cmplti	r2,r2,129
 32380c8:	1000031e 	bne	r2,zero,32380d8 <tcp_newtcpcb+0xd4>
 32380cc:	e0fffd17 	ldw	r3,-12(fp)
 32380d0:	00802004 	movi	r2,128
 32380d4:	18800815 	stw	r2,32(r3)

   /* Set initial congestion window - RFC-2581, pg 4. */
   tp->snd_cwnd = 2 * TCP_MSS;
 32380d8:	e0fffd17 	ldw	r3,-12(fp)
 32380dc:	0082da04 	movi	r2,2920
 32380e0:	18801b15 	stw	r2,108(r3)

#ifdef DO_DELAY_ACKS
   tp->t_delacktime = 1;
#endif   /* DO_DELAY_ACKS */

   tp->snd_ssthresh = 65535;  /* Start with high slow-start threshold */
 32380e4:	e0fffd17 	ldw	r3,-12(fp)
 32380e8:	00bfffd4 	movui	r2,65535
 32380ec:	18801c15 	stw	r2,112(r3)

   inp->inp_ppcb = (char *)tp;
 32380f0:	e0fffd17 	ldw	r3,-12(fp)
 32380f4:	e0bffe17 	ldw	r2,-8(fp)
 32380f8:	10c00915 	stw	r3,36(r2)
   return (tp);
 32380fc:	e0bffd17 	ldw	r2,-12(fp)
 3238100:	e0bfff15 	stw	r2,-4(fp)
 3238104:	e0bfff17 	ldw	r2,-4(fp)
}
 3238108:	e037883a 	mov	sp,fp
 323810c:	dfc00117 	ldw	ra,4(sp)
 3238110:	df000017 	ldw	fp,0(sp)
 3238114:	dec00204 	addi	sp,sp,8
 3238118:	f800283a 	ret

0323811c <tcp_drop>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_drop(struct tcpcb * tp, int err)
{
 323811c:	defffb04 	addi	sp,sp,-20
 3238120:	dfc00415 	stw	ra,16(sp)
 3238124:	df000315 	stw	fp,12(sp)
 3238128:	df000304 	addi	fp,sp,12
 323812c:	e13ffe15 	stw	r4,-8(fp)
 3238130:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 3238134:	e0bffe17 	ldw	r2,-8(fp)
 3238138:	10800d17 	ldw	r2,52(r2)
 323813c:	10800817 	ldw	r2,32(r2)
 3238140:	e0bffd15 	stw	r2,-12(fp)

   if (TCPS_HAVERCVDSYN(tp->t_state)) 
 3238144:	e0bffe17 	ldw	r2,-8(fp)
 3238148:	10800217 	ldw	r2,8(r2)
 323814c:	108000d0 	cmplti	r2,r2,3
 3238150:	10000c1e 	bne	r2,zero,3238184 <tcp_drop+0x68>
   {
      tp->t_state = TCPS_CLOSED;
 3238154:	e0bffe17 	ldw	r2,-8(fp)
 3238158:	10000215 	stw	zero,8(r2)
      (void) tcp_output(tp);
 323815c:	e13ffe17 	ldw	r4,-8(fp)
 3238160:	32366ac0 	call	32366ac <tcp_output>
      tcpstat.tcps_drops++;
 3238164:	0080c9b4 	movhi	r2,806
 3238168:	10b4b504 	addi	r2,r2,-11564
 323816c:	10800317 	ldw	r2,12(r2)
 3238170:	10c00044 	addi	r3,r2,1
 3238174:	0080c9b4 	movhi	r2,806
 3238178:	10b4b504 	addi	r2,r2,-11564
 323817c:	10c00315 	stw	r3,12(r2)
 3238180:	00000706 	br	32381a0 <tcp_drop+0x84>
   }
   else
      tcpstat.tcps_conndrops++;
 3238184:	0080c9b4 	movhi	r2,806
 3238188:	10b4b504 	addi	r2,r2,-11564
 323818c:	10800417 	ldw	r2,16(r2)
 3238190:	10c00044 	addi	r3,r2,1
 3238194:	0080c9b4 	movhi	r2,806
 3238198:	10b4b504 	addi	r2,r2,-11564
 323819c:	10c00415 	stw	r3,16(r2)
   so->so_error = err;
 32381a0:	e0fffd17 	ldw	r3,-12(fp)
 32381a4:	e0bfff17 	ldw	r2,-4(fp)
 32381a8:	18800615 	stw	r2,24(r3)
#ifdef TCP_ZEROCOPY
   if (so->rx_upcall)
      so->rx_upcall(so, NULL, err);
#endif   /* TCP_ZEROCOPY */
   return (tcp_close(tp));
 32381ac:	e13ffe17 	ldw	r4,-8(fp)
 32381b0:	32381c80 	call	32381c8 <tcp_close>
}
 32381b4:	e037883a 	mov	sp,fp
 32381b8:	dfc00117 	ldw	ra,4(sp)
 32381bc:	df000017 	ldw	fp,0(sp)
 32381c0:	dec00204 	addi	sp,sp,8
 32381c4:	f800283a 	ret

032381c8 <tcp_close>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_close(struct tcpcb * tp)
{
 32381c8:	defff904 	addi	sp,sp,-28
 32381cc:	dfc00615 	stw	ra,24(sp)
 32381d0:	df000515 	stw	fp,20(sp)
 32381d4:	df000504 	addi	fp,sp,20
 32381d8:	e13fff15 	stw	r4,-4(fp)
   struct tcpiphdr * t;
   struct inpcb * inp   =  tp->t_inpcb;
 32381dc:	e0bfff17 	ldw	r2,-4(fp)
 32381e0:	10800d17 	ldw	r2,52(r2)
 32381e4:	e0bffd15 	stw	r2,-12(fp)
   struct socket *   so =  inp->inp_socket;
 32381e8:	e0bffd17 	ldw	r2,-12(fp)
 32381ec:	10800817 	ldw	r2,32(r2)
 32381f0:	e0bffc15 	stw	r2,-16(fp)
   struct mbuf *  m;

   t = tp->seg_next;
 32381f4:	e0bfff17 	ldw	r2,-4(fp)
 32381f8:	10800017 	ldw	r2,0(r2)
 32381fc:	e0bffe15 	stw	r2,-8(fp)
   while (t != (struct tcpiphdr *)tp) 
 3238200:	00000c06 	br	3238234 <tcp_close+0x6c>
   {
      t = (struct tcpiphdr *)t->ti_next;
 3238204:	e0bffe17 	ldw	r2,-8(fp)
 3238208:	10800017 	ldw	r2,0(r2)
 323820c:	e0bffe15 	stw	r2,-8(fp)
      m = dtom(t->ti_prev);
 3238210:	e0bffe17 	ldw	r2,-8(fp)
 3238214:	11000117 	ldw	r4,4(r2)
 3238218:	322c55c0 	call	322c55c <dtom>
 323821c:	e0bffb15 	stw	r2,-20(fp)
      remque(t->ti_prev);
 3238220:	e0bffe17 	ldw	r2,-8(fp)
 3238224:	11000117 	ldw	r4,4(r2)
 3238228:	322c6040 	call	322c604 <remque>
      m_freem (m);
 323822c:	e13ffb17 	ldw	r4,-20(fp)
 3238230:	322bfcc0 	call	322bfcc <m_freem>
   struct inpcb * inp   =  tp->t_inpcb;
   struct socket *   so =  inp->inp_socket;
   struct mbuf *  m;

   t = tp->seg_next;
   while (t != (struct tcpiphdr *)tp) 
 3238234:	e0ffff17 	ldw	r3,-4(fp)
 3238238:	e0bffe17 	ldw	r2,-8(fp)
 323823c:	10fff11e 	bne	r2,r3,3238204 <tcp_close+0x3c>
      t = (struct tcpiphdr *)t->ti_next;
      m = dtom(t->ti_prev);
      remque(t->ti_prev);
      m_freem (m);
   }
   if (tp->t_template)
 3238240:	e0bfff17 	ldw	r2,-4(fp)
 3238244:	10800c17 	ldw	r2,48(r2)
 3238248:	1005003a 	cmpeq	r2,r2,zero
 323824c:	1000031e 	bne	r2,zero,323825c <tcp_close+0x94>
      TPH_FREE (tp->t_template);
 3238250:	e0bfff17 	ldw	r2,-4(fp)
 3238254:	11000c17 	ldw	r4,48(r2)
 3238258:	322ba280 	call	322ba28 <npfree>
   TCB_FREE (tp);
 323825c:	e13fff17 	ldw	r4,-4(fp)
 3238260:	322ba280 	call	322ba28 <npfree>
   inp->inp_ppcb = 0;
 3238264:	e0bffd17 	ldw	r2,-12(fp)
 3238268:	10000915 	stw	zero,36(r2)
   soisdisconnected(so);
 323826c:	e13ffc17 	ldw	r4,-16(fp)
 3238270:	3231c8c0 	call	3231c8c <soisdisconnected>
   in_pcbdetach(inp);
 3238274:	e13ffd17 	ldw	r4,-12(fp)
 3238278:	32482780 	call	3248278 <in_pcbdetach>
   tcpstat.tcps_closed++;
 323827c:	0080c9b4 	movhi	r2,806
 3238280:	10b4b504 	addi	r2,r2,-11564
 3238284:	10800517 	ldw	r2,20(r2)
 3238288:	10c00044 	addi	r3,r2,1
 323828c:	0080c9b4 	movhi	r2,806
 3238290:	10b4b504 	addi	r2,r2,-11564
 3238294:	10c00515 	stw	r3,20(r2)
   return ((struct tcpcb *)0);
 3238298:	0005883a 	mov	r2,zero
}
 323829c:	e037883a 	mov	sp,fp
 32382a0:	dfc00117 	ldw	ra,4(sp)
 32382a4:	df000017 	ldw	fp,0(sp)
 32382a8:	dec00204 	addi	sp,sp,8
 32382ac:	f800283a 	ret

032382b0 <tcp_quench>:
 * RETURNS: 
 */

void
tcp_quench(struct inpcb * inp)
{
 32382b0:	defffd04 	addi	sp,sp,-12
 32382b4:	df000215 	stw	fp,8(sp)
 32382b8:	df000204 	addi	fp,sp,8
 32382bc:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp =  intotcpcb(inp);
 32382c0:	e0bfff17 	ldw	r2,-4(fp)
 32382c4:	10800917 	ldw	r2,36(r2)
 32382c8:	e0bffe15 	stw	r2,-8(fp)

   if (tp)
 32382cc:	e0bffe17 	ldw	r2,-8(fp)
 32382d0:	1005003a 	cmpeq	r2,r2,zero
 32382d4:	1000051e 	bne	r2,zero,32382ec <tcp_quench+0x3c>
      tp->snd_cwnd = tp->t_maxseg;
 32382d8:	e0bffe17 	ldw	r2,-8(fp)
 32382dc:	10800a0b 	ldhu	r2,40(r2)
 32382e0:	10ffffcc 	andi	r3,r2,65535
 32382e4:	e0bffe17 	ldw	r2,-8(fp)
 32382e8:	10c01b15 	stw	r3,108(r2)
}
 32382ec:	e037883a 	mov	sp,fp
 32382f0:	df000017 	ldw	fp,0(sp)
 32382f4:	dec00104 	addi	sp,sp,4
 32382f8:	f800283a 	ret

032382fc <tcp_putseq>:

/* tcp_putseq()  */

u_char *
tcp_putseq(u_char * cp, tcp_seq seq)
{
 32382fc:	defffc04 	addi	sp,sp,-16
 3238300:	df000315 	stw	fp,12(sp)
 3238304:	df000304 	addi	fp,sp,12
 3238308:	e13ffe15 	stw	r4,-8(fp)
 323830c:	e17fff15 	stw	r5,-4(fp)
   int   i;

   cp += 3;                /* do low byte first */
 3238310:	e0bffe17 	ldw	r2,-8(fp)
 3238314:	108000c4 	addi	r2,r2,3
 3238318:	e0bffe15 	stw	r2,-8(fp)
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 323831c:	e03ffd15 	stw	zero,-12(fp)
 3238320:	00000d06 	br	3238358 <tcp_putseq+0x5c>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
 3238324:	e0bfff17 	ldw	r2,-4(fp)
 3238328:	1007883a 	mov	r3,r2
 323832c:	e0bffe17 	ldw	r2,-8(fp)
 3238330:	10c00005 	stb	r3,0(r2)
 3238334:	e0bffe17 	ldw	r2,-8(fp)
 3238338:	10bfffc4 	addi	r2,r2,-1
 323833c:	e0bffe15 	stw	r2,-8(fp)
      seq >>= 8;
 3238340:	e0bfff17 	ldw	r2,-4(fp)
 3238344:	1004d23a 	srli	r2,r2,8
 3238348:	e0bfff15 	stw	r2,-4(fp)
tcp_putseq(u_char * cp, tcp_seq seq)
{
   int   i;

   cp += 3;                /* do low byte first */
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 323834c:	e0bffd17 	ldw	r2,-12(fp)
 3238350:	10800044 	addi	r2,r2,1
 3238354:	e0bffd15 	stw	r2,-12(fp)
 3238358:	e0bffd17 	ldw	r2,-12(fp)
 323835c:	10800110 	cmplti	r2,r2,4
 3238360:	103ff01e 	bne	r2,zero,3238324 <tcp_putseq+0x28>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
      seq >>= 8;
   }
   return (cp + 5);
 3238364:	e0bffe17 	ldw	r2,-8(fp)
 3238368:	10800144 	addi	r2,r2,5
}
 323836c:	e037883a 	mov	sp,fp
 3238370:	df000017 	ldw	fp,0(sp)
 3238374:	dec00104 	addi	sp,sp,4
 3238378:	f800283a 	ret

0323837c <tcp_getseq>:
 * RETURNS: a long in local endian
 */

u_long
tcp_getseq(u_char * cp)
{
 323837c:	defffc04 	addi	sp,sp,-16
 3238380:	df000315 	stw	fp,12(sp)
 3238384:	df000304 	addi	fp,sp,12
 3238388:	e13fff15 	stw	r4,-4(fp)
   int i;
   ulong seq = 0;
 323838c:	e03ffd15 	stw	zero,-12(fp)

   for(i = 0; i < 4; i++)
 3238390:	e03ffe15 	stw	zero,-8(fp)
 3238394:	00000f06 	br	32383d4 <tcp_getseq+0x58>
   {
      seq <<= 8;
 3238398:	e0bffd17 	ldw	r2,-12(fp)
 323839c:	1004923a 	slli	r2,r2,8
 32383a0:	e0bffd15 	stw	r2,-12(fp)
      seq += (u_long)*(cp++);
 32383a4:	e0bfff17 	ldw	r2,-4(fp)
 32383a8:	10800003 	ldbu	r2,0(r2)
 32383ac:	10c03fcc 	andi	r3,r2,255
 32383b0:	e0bffd17 	ldw	r2,-12(fp)
 32383b4:	10c5883a 	add	r2,r2,r3
 32383b8:	e0bffd15 	stw	r2,-12(fp)
 32383bc:	e0bfff17 	ldw	r2,-4(fp)
 32383c0:	10800044 	addi	r2,r2,1
 32383c4:	e0bfff15 	stw	r2,-4(fp)
tcp_getseq(u_char * cp)
{
   int i;
   ulong seq = 0;

   for(i = 0; i < 4; i++)
 32383c8:	e0bffe17 	ldw	r2,-8(fp)
 32383cc:	10800044 	addi	r2,r2,1
 32383d0:	e0bffe15 	stw	r2,-8(fp)
 32383d4:	e0bffe17 	ldw	r2,-8(fp)
 32383d8:	10800110 	cmplti	r2,r2,4
 32383dc:	103fee1e 	bne	r2,zero,3238398 <tcp_getseq+0x1c>
   {
      seq <<= 8;
      seq += (u_long)*(cp++);
   }
   return seq;
 32383e0:	e0bffd17 	ldw	r2,-12(fp)
}
 32383e4:	e037883a 	mov	sp,fp
 32383e8:	df000017 	ldw	fp,0(sp)
 32383ec:	dec00104 	addi	sp,sp,4
 32383f0:	f800283a 	ret

032383f4 <tcp_slowtimo>:
 * RETURNS: 
 */

void
tcp_slowtimo(void)
{
 32383f4:	defff704 	addi	sp,sp,-36
 32383f8:	dfc00815 	stw	ra,32(sp)
 32383fc:	df000715 	stw	fp,28(sp)
 3238400:	df000704 	addi	fp,sp,28
   struct tcpcb * tp;
   int   i;
   struct socket * so, * sonext;
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;
 3238404:	d0a03b17 	ldw	r2,-32532(gp)
 3238408:	100490fa 	slli	r2,r2,3
 323840c:	d0a8eb15 	stw	r2,-23636(gp)

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 3238410:	0080c9b4 	movhi	r2,806
 3238414:	10b48204 	addi	r2,r2,-11768
 3238418:	10800017 	ldw	r2,0(r2)
 323841c:	e0bffb15 	stw	r2,-20(fp)
 3238420:	00008306 	br	3238630 <tcp_slowtimo+0x23c>
   {
      sonext = so->next;
 3238424:	e0bffb17 	ldw	r2,-20(fp)
 3238428:	10800017 	ldw	r2,0(r2)
 323842c:	e0bffa15 	stw	r2,-24(fp)

      /* for SOCK_STREAM (TCP) sockets, we must do slow-timeout 
       * processing and (optionally) processing of pending 
       * zero-copy socket upcalls.
       */
      if (so->so_type == SOCK_STREAM)
 3238430:	e0bffb17 	ldw	r2,-20(fp)
 3238434:	10800983 	ldbu	r2,38(r2)
 3238438:	10803fcc 	andi	r2,r2,255
 323843c:	1080201c 	xori	r2,r2,128
 3238440:	10bfe004 	addi	r2,r2,-128
 3238444:	10800058 	cmpnei	r2,r2,1
 3238448:	1000471e 	bne	r2,zero,3238568 <tcp_slowtimo+0x174>
      {
         ip = so->so_pcb;
 323844c:	e0bffb17 	ldw	r2,-20(fp)
 3238450:	10800117 	ldw	r2,4(r2)
 3238454:	e0bfff15 	stw	r2,-4(fp)
         if (!ip)
 3238458:	e0bfff17 	ldw	r2,-4(fp)
 323845c:	1005003a 	cmpeq	r2,r2,zero
 3238460:	1000711e 	bne	r2,zero,3238628 <tcp_slowtimo+0x234>
            continue;
         ipnxt = ip->inp_next;
 3238464:	e0bfff17 	ldw	r2,-4(fp)
 3238468:	10800017 	ldw	r2,0(r2)
 323846c:	e0bffe15 	stw	r2,-8(fp)

         tp = intotcpcb(so->so_pcb);
 3238470:	e0bffb17 	ldw	r2,-20(fp)
 3238474:	10800117 	ldw	r2,4(r2)
 3238478:	10800917 	ldw	r2,36(r2)
 323847c:	e0bffd15 	stw	r2,-12(fp)
         if (!tp)
 3238480:	e0bffd17 	ldw	r2,-12(fp)
 3238484:	1005003a 	cmpeq	r2,r2,zero
 3238488:	1000671e 	bne	r2,zero,3238628 <tcp_slowtimo+0x234>
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 323848c:	e03ffc15 	stw	zero,-16(fp)
 3238490:	00002d06 	br	3238548 <tcp_slowtimo+0x154>
         {
            if (tp->t_timer[i] && --tp->t_timer[i] == 0) 
 3238494:	e0bffc17 	ldw	r2,-16(fp)
 3238498:	e0fffd17 	ldw	r3,-12(fp)
 323849c:	1085883a 	add	r2,r2,r2
 32384a0:	1085883a 	add	r2,r2,r2
 32384a4:	10c5883a 	add	r2,r2,r3
 32384a8:	10800304 	addi	r2,r2,12
 32384ac:	10800017 	ldw	r2,0(r2)
 32384b0:	1005003a 	cmpeq	r2,r2,zero
 32384b4:	1000211e 	bne	r2,zero,323853c <tcp_slowtimo+0x148>
 32384b8:	e0fffc17 	ldw	r3,-16(fp)
 32384bc:	e13ffd17 	ldw	r4,-12(fp)
 32384c0:	18c5883a 	add	r2,r3,r3
 32384c4:	1085883a 	add	r2,r2,r2
 32384c8:	1105883a 	add	r2,r2,r4
 32384cc:	10800304 	addi	r2,r2,12
 32384d0:	10800017 	ldw	r2,0(r2)
 32384d4:	117fffc4 	addi	r5,r2,-1
 32384d8:	e13ffd17 	ldw	r4,-12(fp)
 32384dc:	18c5883a 	add	r2,r3,r3
 32384e0:	1085883a 	add	r2,r2,r2
 32384e4:	1105883a 	add	r2,r2,r4
 32384e8:	10800304 	addi	r2,r2,12
 32384ec:	11400015 	stw	r5,0(r2)
 32384f0:	e13ffd17 	ldw	r4,-12(fp)
 32384f4:	18c5883a 	add	r2,r3,r3
 32384f8:	1085883a 	add	r2,r2,r2
 32384fc:	1105883a 	add	r2,r2,r4
 3238500:	10800304 	addi	r2,r2,12
 3238504:	10800017 	ldw	r2,0(r2)
 3238508:	1004c03a 	cmpne	r2,r2,zero
 323850c:	10000b1e 	bne	r2,zero,323853c <tcp_slowtimo+0x148>
            {
               /* call usrreq to do actual work */
               so->so_req = PRU_SLOWTIMO;
 3238510:	e0fffb17 	ldw	r3,-20(fp)
 3238514:	008004c4 	movi	r2,19
 3238518:	18800715 	stw	r2,28(r3)
               (void) tcp_usrreq(so, (struct mbuf *)0, 
 323851c:	e1bffc17 	ldw	r6,-16(fp)
 3238520:	e13ffb17 	ldw	r4,-20(fp)
 3238524:	000b883a 	mov	r5,zero
 3238528:	3238b8c0 	call	3238b8c <tcp_usrreq>
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
 323852c:	e0bffe17 	ldw	r2,-8(fp)
 3238530:	10c00117 	ldw	r3,4(r2)
 3238534:	e0bfff17 	ldw	r2,-4(fp)
 3238538:	18803b1e 	bne	r3,r2,3238628 <tcp_slowtimo+0x234>

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 323853c:	e0bffc17 	ldw	r2,-16(fp)
 3238540:	10800044 	addi	r2,r2,1
 3238544:	e0bffc15 	stw	r2,-16(fp)
 3238548:	e0bffc17 	ldw	r2,-16(fp)
 323854c:	10800110 	cmplti	r2,r2,4
 3238550:	103fd01e 	bne	r2,zero,3238494 <tcp_slowtimo+0xa0>
               }
            }
         }
#endif   /* TCP_ZEROCOPY */

         tp->t_idle++;
 3238554:	e0bffd17 	ldw	r2,-12(fp)
 3238558:	10801d17 	ldw	r2,116(r2)
 323855c:	10c00044 	addi	r3,r2,1
 3238560:	e0bffd17 	ldw	r2,-12(fp)
 3238564:	10c01d15 	stw	r3,116(r2)
      }

      /* wake up anyone sleeping in a select() involving this socket */
      sb = &so->so_rcv;
 3238568:	e0bffb17 	ldw	r2,-20(fp)
 323856c:	10800a04 	addi	r2,r2,40
 3238570:	e0bff915 	stw	r2,-28(fp)
      if (sb->sb_flags & SB_SEL) 
 3238574:	e0bff917 	ldw	r2,-28(fp)
 3238578:	1080070b 	ldhu	r2,28(r2)
 323857c:	10bfffcc 	andi	r2,r2,65535
 3238580:	1080020c 	andi	r2,r2,8
 3238584:	1005003a 	cmpeq	r2,r2,zero
 3238588:	10000d1e 	bne	r2,zero,32385c0 <tcp_slowtimo+0x1cc>
      {
         select_wait = 0;
 323858c:	0080c974 	movhi	r2,805
 3238590:	10934904 	addi	r2,r2,19748
 3238594:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 3238598:	0100c974 	movhi	r4,805
 323859c:	21134904 	addi	r4,r4,19748
 32385a0:	3226c640 	call	3226c64 <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 32385a4:	e0bff917 	ldw	r2,-28(fp)
 32385a8:	10c0070b 	ldhu	r3,28(r2)
 32385ac:	00bffdc4 	movi	r2,-9
 32385b0:	1884703a 	and	r2,r3,r2
 32385b4:	1007883a 	mov	r3,r2
 32385b8:	e0bff917 	ldw	r2,-28(fp)
 32385bc:	10c0070d 	sth	r3,28(r2)
      }
      sb = &so->so_snd;
 32385c0:	e0bffb17 	ldw	r2,-20(fp)
 32385c4:	10801204 	addi	r2,r2,72
 32385c8:	e0bff915 	stw	r2,-28(fp)
      if (sb->sb_flags & SB_SEL) 
 32385cc:	e0bff917 	ldw	r2,-28(fp)
 32385d0:	1080070b 	ldhu	r2,28(r2)
 32385d4:	10bfffcc 	andi	r2,r2,65535
 32385d8:	1080020c 	andi	r2,r2,8
 32385dc:	1005003a 	cmpeq	r2,r2,zero
 32385e0:	10000d1e 	bne	r2,zero,3238618 <tcp_slowtimo+0x224>
      {
         select_wait = 0;         
 32385e4:	0080c974 	movhi	r2,805
 32385e8:	10934904 	addi	r2,r2,19748
 32385ec:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 32385f0:	0100c974 	movhi	r4,805
 32385f4:	21134904 	addi	r4,r4,19748
 32385f8:	3226c640 	call	3226c64 <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 32385fc:	e0bff917 	ldw	r2,-28(fp)
 3238600:	10c0070b 	ldhu	r3,28(r2)
 3238604:	00bffdc4 	movi	r2,-9
 3238608:	1884703a 	and	r2,r3,r2
 323860c:	1007883a 	mov	r3,r2
 3238610:	e0bff917 	ldw	r2,-28(fp)
 3238614:	10c0070d 	sth	r3,28(r2)
      }

      /* wake any thread with a timer going for a connection state change */     
      tcp_wakeup((char*)&so->so_timeo);
 3238618:	e0bffb17 	ldw	r2,-20(fp)
 323861c:	10800904 	addi	r2,r2,36
 3238620:	1009883a 	mov	r4,r2
 3238624:	3226c640 	call	3226c64 <tcp_wakeup>
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 3238628:	e0bffa17 	ldw	r2,-24(fp)
 323862c:	e0bffb15 	stw	r2,-20(fp)
 3238630:	e0bffb17 	ldw	r2,-20(fp)
 3238634:	1004c03a 	cmpne	r2,r2,zero
 3238638:	103f7a1e 	bne	r2,zero,3238424 <tcp_slowtimo+0x30>

tpgone:
      ;
   }

   tcp_iss += (unsigned)(TCP_ISSINCR/PR_SLOWHZ);      /* increment iss */
 323863c:	0080c974 	movhi	r2,805
 3238640:	10934e04 	addi	r2,r2,19768
 3238644:	10c00017 	ldw	r3,0(r2)
 3238648:	00be9fd4 	movui	r2,64127
 323864c:	1887883a 	add	r3,r3,r2
 3238650:	0080c974 	movhi	r2,805
 3238654:	10934e04 	addi	r2,r2,19768
 3238658:	10c00015 	stw	r3,0(r2)

   if (tcp_iss & 0xff000000)
 323865c:	0080c974 	movhi	r2,805
 3238660:	10934e04 	addi	r2,r2,19768
 3238664:	10800017 	ldw	r2,0(r2)
 3238668:	10bfc02c 	andhi	r2,r2,65280
 323866c:	1005003a 	cmpeq	r2,r2,zero
 3238670:	1000031e 	bne	r2,zero,3238680 <tcp_slowtimo+0x28c>
      tcp_iss = 0L;
 3238674:	0080c974 	movhi	r2,805
 3238678:	10934e04 	addi	r2,r2,19768
 323867c:	10000015 	stw	zero,0(r2)
}
 3238680:	e037883a 	mov	sp,fp
 3238684:	dfc00117 	ldw	ra,4(sp)
 3238688:	df000017 	ldw	fp,0(sp)
 323868c:	dec00204 	addi	sp,sp,8
 3238690:	f800283a 	ret

03238694 <tcp_canceltimers>:
 * RETURNS: 
 */

void
tcp_canceltimers(struct tcpcb * tp)
{
 3238694:	defffd04 	addi	sp,sp,-12
 3238698:	df000215 	stw	fp,8(sp)
 323869c:	df000204 	addi	fp,sp,8
 32386a0:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 32386a4:	e03ffe15 	stw	zero,-8(fp)
 32386a8:	00000a06 	br	32386d4 <tcp_canceltimers+0x40>
      tp->t_timer[i] = 0;
 32386ac:	e0bffe17 	ldw	r2,-8(fp)
 32386b0:	e0ffff17 	ldw	r3,-4(fp)
 32386b4:	1085883a 	add	r2,r2,r2
 32386b8:	1085883a 	add	r2,r2,r2
 32386bc:	10c5883a 	add	r2,r2,r3
 32386c0:	10800304 	addi	r2,r2,12
 32386c4:	10000015 	stw	zero,0(r2)
void
tcp_canceltimers(struct tcpcb * tp)
{
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 32386c8:	e0bffe17 	ldw	r2,-8(fp)
 32386cc:	10800044 	addi	r2,r2,1
 32386d0:	e0bffe15 	stw	r2,-8(fp)
 32386d4:	e0bffe17 	ldw	r2,-8(fp)
 32386d8:	10800110 	cmplti	r2,r2,4
 32386dc:	103ff31e 	bne	r2,zero,32386ac <tcp_canceltimers+0x18>
      tp->t_timer[i] = 0;
}
 32386e0:	e037883a 	mov	sp,fp
 32386e4:	df000017 	ldw	fp,0(sp)
 32386e8:	dec00104 	addi	sp,sp,4
 32386ec:	f800283a 	ret

032386f0 <tcp_timers>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_timers(struct tcpcb * tp, int timer)
{
 32386f0:	defff504 	addi	sp,sp,-44
 32386f4:	dfc00a15 	stw	ra,40(sp)
 32386f8:	df000915 	stw	fp,36(sp)
 32386fc:	df000904 	addi	fp,sp,36
 3238700:	e13ffb15 	stw	r4,-20(fp)
 3238704:	e17ffc15 	stw	r5,-16(fp)
   int   rexmt;

   switch (timer) 
 3238708:	e0bffc17 	ldw	r2,-16(fp)
 323870c:	e0bffe15 	stw	r2,-8(fp)
 3238710:	e0fffe17 	ldw	r3,-8(fp)
 3238714:	18800060 	cmpeqi	r2,r3,1
 3238718:	1000bd1e 	bne	r2,zero,3238a10 <tcp_timers+0x320>
 323871c:	e0fffe17 	ldw	r3,-8(fp)
 3238720:	18800088 	cmpgei	r2,r3,2
 3238724:	1000041e 	bne	r2,zero,3238738 <tcp_timers+0x48>
 3238728:	e0fffe17 	ldw	r3,-8(fp)
 323872c:	1805003a 	cmpeq	r2,r3,zero
 3238730:	10001b1e 	bne	r2,zero,32387a0 <tcp_timers+0xb0>
 3238734:	00010f06 	br	3238b74 <tcp_timers+0x484>
 3238738:	e0fffe17 	ldw	r3,-8(fp)
 323873c:	188000a0 	cmpeqi	r2,r3,2
 3238740:	1000c41e 	bne	r2,zero,3238a54 <tcp_timers+0x364>
 3238744:	e0fffe17 	ldw	r3,-8(fp)
 3238748:	188000e0 	cmpeqi	r2,r3,3
 323874c:	1000011e 	bne	r2,zero,3238754 <tcp_timers+0x64>
 3238750:	00010806 	br	3238b74 <tcp_timers+0x484>
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 3238754:	e0bffb17 	ldw	r2,-20(fp)
 3238758:	10800217 	ldw	r2,8(r2)
 323875c:	108002a0 	cmpeqi	r2,r2,10
 3238760:	10000b1e 	bne	r2,zero,3238790 <tcp_timers+0xa0>
 3238764:	e0bffb17 	ldw	r2,-20(fp)
 3238768:	10c01d17 	ldw	r3,116(r2)
 323876c:	d0a8eb17 	ldw	r2,-23636(gp)
 3238770:	10c00716 	blt	r2,r3,3238790 <tcp_timers+0xa0>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
 3238774:	d0a03b17 	ldw	r2,-32532(gp)
 3238778:	10ffffcc 	andi	r3,r2,65535
 323877c:	18e0001c 	xori	r3,r3,32768
 3238780:	18e00004 	addi	r3,r3,-32768
 3238784:	e0bffb17 	ldw	r2,-20(fp)
 3238788:	10c00615 	stw	r3,24(r2)
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 323878c:	0000f906 	br	3238b74 <tcp_timers+0x484>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
      }
      else
         tp = tcp_close(tp);
 3238790:	e13ffb17 	ldw	r4,-20(fp)
 3238794:	32381c80 	call	32381c8 <tcp_close>
 3238798:	e0bffb15 	stw	r2,-20(fp)
      break;
 323879c:	0000f506 	br	3238b74 <tcp_timers+0x484>
    * Retransmission timer went off.  Message has not
    * been acked within retransmit interval.  Back off
    * to a longer retransmit interval and retransmit one segment.
    */
   case TCPT_REXMT:
      TCP_MIB_INC(tcpRetransSegs);     /* keep MIB stats */
 32387a0:	0080c9b4 	movhi	r2,806
 32387a4:	10b48704 	addi	r2,r2,-11748
 32387a8:	10800b17 	ldw	r2,44(r2)
 32387ac:	10c00044 	addi	r3,r2,1
 32387b0:	0080c9b4 	movhi	r2,806
 32387b4:	10b48704 	addi	r2,r2,-11748
 32387b8:	10c00b15 	stw	r3,44(r2)
      if (++tp->t_rxtshift > TCP_MAXRXTSHIFT) 
 32387bc:	e0bffb17 	ldw	r2,-20(fp)
 32387c0:	10800717 	ldw	r2,28(r2)
 32387c4:	10c00044 	addi	r3,r2,1
 32387c8:	e0bffb17 	ldw	r2,-20(fp)
 32387cc:	10c00715 	stw	r3,28(r2)
 32387d0:	e0bffb17 	ldw	r2,-20(fp)
 32387d4:	10800717 	ldw	r2,28(r2)
 32387d8:	10800350 	cmplti	r2,r2,13
 32387dc:	10000f1e 	bne	r2,zero,323881c <tcp_timers+0x12c>
      {
         tp->t_rxtshift = TCP_MAXRXTSHIFT;
 32387e0:	e0fffb17 	ldw	r3,-20(fp)
 32387e4:	00800304 	movi	r2,12
 32387e8:	18800715 	stw	r2,28(r3)
         tcpstat.tcps_timeoutdrop++;
 32387ec:	0080c9b4 	movhi	r2,806
 32387f0:	10b4b504 	addi	r2,r2,-11564
 32387f4:	10800917 	ldw	r2,36(r2)
 32387f8:	10c00044 	addi	r3,r2,1
 32387fc:	0080c9b4 	movhi	r2,806
 3238800:	10b4b504 	addi	r2,r2,-11564
 3238804:	10c00915 	stw	r3,36(r2)
         tp = tcp_drop(tp, ETIMEDOUT);
 3238808:	e13ffb17 	ldw	r4,-20(fp)
 323880c:	01401d04 	movi	r5,116
 3238810:	323811c0 	call	323811c <tcp_drop>
 3238814:	e0bffb15 	stw	r2,-20(fp)
         break;
 3238818:	0000d606 	br	3238b74 <tcp_timers+0x484>
      }
      tcpstat.tcps_rexmttimeo++;
 323881c:	0080c9b4 	movhi	r2,806
 3238820:	10b4b504 	addi	r2,r2,-11564
 3238824:	10800a17 	ldw	r2,40(r2)
 3238828:	10c00044 	addi	r3,r2,1
 323882c:	0080c9b4 	movhi	r2,806
 3238830:	10b4b504 	addi	r2,r2,-11564
 3238834:	10c00a15 	stw	r3,40(r2)
      rexmt = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 3238838:	e0bffb17 	ldw	r2,-20(fp)
 323883c:	10802017 	ldw	r2,128(r2)
 3238840:	1007d0ba 	srai	r3,r2,2
 3238844:	e0bffb17 	ldw	r2,-20(fp)
 3238848:	10802117 	ldw	r2,132(r2)
 323884c:	1885883a 	add	r2,r3,r2
 3238850:	1005d07a 	srai	r2,r2,1
 3238854:	e0bffa15 	stw	r2,-24(fp)
      rexmt *= tcp_backoff[tp->t_rxtshift];
 3238858:	e0bffb17 	ldw	r2,-20(fp)
 323885c:	10c00717 	ldw	r3,28(r2)
 3238860:	0080c974 	movhi	r2,805
 3238864:	108960c4 	addi	r2,r2,9603
 3238868:	10c5883a 	add	r2,r2,r3
 323886c:	10800003 	ldbu	r2,0(r2)
 3238870:	10c03fcc 	andi	r3,r2,255
 3238874:	e0bffa17 	ldw	r2,-24(fp)
 3238878:	10c5383a 	mul	r2,r2,r3
 323887c:	e0bffa15 	stw	r2,-24(fp)
      TCPT_RANGESET(tp->t_rxtcur, rexmt, TCPTV_MIN, TCPTV_REXMTMAX);
 3238880:	e0bffa17 	ldw	r2,-24(fp)
 3238884:	10ffffcc 	andi	r3,r2,65535
 3238888:	18e0001c 	xori	r3,r3,32768
 323888c:	18e00004 	addi	r3,r3,-32768
 3238890:	e0bffb17 	ldw	r2,-20(fp)
 3238894:	10c00815 	stw	r3,32(r2)
 3238898:	e0bffb17 	ldw	r2,-20(fp)
 323889c:	10800817 	ldw	r2,32(r2)
 32388a0:	10800088 	cmpgei	r2,r2,2
 32388a4:	1000041e 	bne	r2,zero,32388b8 <tcp_timers+0x1c8>
 32388a8:	e0fffb17 	ldw	r3,-20(fp)
 32388ac:	00800084 	movi	r2,2
 32388b0:	18800815 	stw	r2,32(r3)
 32388b4:	00000706 	br	32388d4 <tcp_timers+0x1e4>
 32388b8:	e0bffb17 	ldw	r2,-20(fp)
 32388bc:	10800817 	ldw	r2,32(r2)
 32388c0:	10802050 	cmplti	r2,r2,129
 32388c4:	1000031e 	bne	r2,zero,32388d4 <tcp_timers+0x1e4>
 32388c8:	e0fffb17 	ldw	r3,-20(fp)
 32388cc:	00802004 	movi	r2,128
 32388d0:	18800815 	stw	r2,32(r3)
      tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 32388d4:	e0bffb17 	ldw	r2,-20(fp)
 32388d8:	10c00817 	ldw	r3,32(r2)
 32388dc:	e0bffb17 	ldw	r2,-20(fp)
 32388e0:	10c00315 	stw	r3,12(r2)
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 32388e4:	e0bffb17 	ldw	r2,-20(fp)
 32388e8:	10800717 	ldw	r2,28(r2)
 32388ec:	10800110 	cmplti	r2,r2,4
 32388f0:	1000101e 	bne	r2,zero,3238934 <tcp_timers+0x244>
 32388f4:	e0bffb17 	ldw	r2,-20(fp)
 32388f8:	10800b0b 	ldhu	r2,44(r2)
 32388fc:	10bfffcc 	andi	r2,r2,65535
 3238900:	1080400c 	andi	r2,r2,256
 3238904:	1004c03a 	cmpne	r2,r2,zero
 3238908:	10000a1e 	bne	r2,zero,3238934 <tcp_timers+0x244>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
      {
         tp->t_rttvar += (tp->t_srtt >> 2);
 323890c:	e0bffb17 	ldw	r2,-20(fp)
 3238910:	10c02117 	ldw	r3,132(r2)
 3238914:	e0bffb17 	ldw	r2,-20(fp)
 3238918:	10802017 	ldw	r2,128(r2)
 323891c:	1005d0ba 	srai	r2,r2,2
 3238920:	1887883a 	add	r3,r3,r2
 3238924:	e0bffb17 	ldw	r2,-20(fp)
 3238928:	10c02115 	stw	r3,132(r2)
         tp->t_srtt = 0;
 323892c:	e0bffb17 	ldw	r2,-20(fp)
 3238930:	10002015 	stw	zero,128(r2)
      }
      tp->snd_nxt = tp->snd_una;
 3238934:	e0bffb17 	ldw	r2,-20(fp)
 3238938:	10c00e17 	ldw	r3,56(r2)
 323893c:	e0bffb17 	ldw	r2,-20(fp)
 3238940:	10c00f15 	stw	r3,60(r2)
      /*
       * If timing a segment in this window, stop the timer.
       */
      tp->t_rttick = 0;
 3238944:	e0bffb17 	ldw	r2,-20(fp)
 3238948:	10001e15 	stw	zero,120(r2)
       * to go below this.)
       *
       * Vers 1.9 - Skip slow start if the SO_NOSLOWSTART socket option
       * is set.
       */
      if((tp->t_inpcb->inp_socket->so_options & SO_NOSLOWSTART) == 0)
 323894c:	e0bffb17 	ldw	r2,-20(fp)
 3238950:	10800d17 	ldw	r2,52(r2)
 3238954:	10800817 	ldw	r2,32(r2)
 3238958:	10800417 	ldw	r2,16(r2)
 323895c:	1090000c 	andi	r2,r2,16384
 3238960:	1004c03a 	cmpne	r2,r2,zero
 3238964:	1000271e 	bne	r2,zero,3238a04 <tcp_timers+0x314>
      {
         u_int win = MIN(tp->snd_wnd, tp->snd_cwnd);
 3238968:	e0bffb17 	ldw	r2,-20(fp)
 323896c:	10c01417 	ldw	r3,80(r2)
 3238970:	e0bffb17 	ldw	r2,-20(fp)
 3238974:	10801b17 	ldw	r2,108(r2)
 3238978:	e0bffd15 	stw	r2,-12(fp)
 323897c:	e0ffff15 	stw	r3,-4(fp)
 3238980:	e0bffd17 	ldw	r2,-12(fp)
 3238984:	e0ffff17 	ldw	r3,-4(fp)
 3238988:	10c0022e 	bgeu	r2,r3,3238994 <tcp_timers+0x2a4>
 323898c:	e0bffd17 	ldw	r2,-12(fp)
 3238990:	e0bfff15 	stw	r2,-4(fp)
 3238994:	e0ffff17 	ldw	r3,-4(fp)
 3238998:	e0fff915 	stw	r3,-28(fp)
         win = win / 2 / tp->t_maxseg;
 323899c:	e0bff917 	ldw	r2,-28(fp)
 32389a0:	1008d07a 	srli	r4,r2,1
 32389a4:	e0bffb17 	ldw	r2,-20(fp)
 32389a8:	10800a0b 	ldhu	r2,40(r2)
 32389ac:	117fffcc 	andi	r5,r2,65535
 32389b0:	32047c00 	call	32047c0 <__udivsi3>
 32389b4:	e0bff915 	stw	r2,-28(fp)
         if (win < 2)
 32389b8:	e0bff917 	ldw	r2,-28(fp)
 32389bc:	108000a8 	cmpgeui	r2,r2,2
 32389c0:	1000021e 	bne	r2,zero,32389cc <tcp_timers+0x2dc>
            win = 2;
 32389c4:	00800084 	movi	r2,2
 32389c8:	e0bff915 	stw	r2,-28(fp)
         tp->snd_cwnd = tp->t_maxseg;
 32389cc:	e0bffb17 	ldw	r2,-20(fp)
 32389d0:	10800a0b 	ldhu	r2,40(r2)
 32389d4:	10ffffcc 	andi	r3,r2,65535
 32389d8:	e0bffb17 	ldw	r2,-20(fp)
 32389dc:	10c01b15 	stw	r3,108(r2)
         tp->snd_ssthresh = (u_short)win * tp->t_maxseg;
 32389e0:	e0bff917 	ldw	r2,-28(fp)
 32389e4:	10ffffcc 	andi	r3,r2,65535
 32389e8:	e0bffb17 	ldw	r2,-20(fp)
 32389ec:	10800a0b 	ldhu	r2,40(r2)
 32389f0:	10bfffcc 	andi	r2,r2,65535
 32389f4:	1885383a 	mul	r2,r3,r2
 32389f8:	1007883a 	mov	r3,r2
 32389fc:	e0bffb17 	ldw	r2,-20(fp)
 3238a00:	10c01c15 	stw	r3,112(r2)
      }
      (void) tcp_output(tp);
 3238a04:	e13ffb17 	ldw	r4,-20(fp)
 3238a08:	32366ac0 	call	32366ac <tcp_output>
      break;
 3238a0c:	00005906 	br	3238b74 <tcp_timers+0x484>
   /*
    * Persistance timer into zero window.
    * Force a byte to be output, if possible.
    */
   case TCPT_PERSIST:
      tcpstat.tcps_persisttimeo++;
 3238a10:	0080c9b4 	movhi	r2,806
 3238a14:	10b4b504 	addi	r2,r2,-11564
 3238a18:	10800b17 	ldw	r2,44(r2)
 3238a1c:	10c00044 	addi	r3,r2,1
 3238a20:	0080c9b4 	movhi	r2,806
 3238a24:	10b4b504 	addi	r2,r2,-11564
 3238a28:	10c00b15 	stw	r3,44(r2)
      tcp_setpersist(tp);
 3238a2c:	e13ffb17 	ldw	r4,-20(fp)
 3238a30:	32378280 	call	3237828 <tcp_setpersist>
      tp->t_force = 1;
 3238a34:	e0fffb17 	ldw	r3,-20(fp)
 3238a38:	00800044 	movi	r2,1
 3238a3c:	18800a85 	stb	r2,42(r3)
      (void) tcp_output(tp);
 3238a40:	e13ffb17 	ldw	r4,-20(fp)
 3238a44:	32366ac0 	call	32366ac <tcp_output>
      tp->t_force = 0;
 3238a48:	e0bffb17 	ldw	r2,-20(fp)
 3238a4c:	10000a85 	stb	zero,42(r2)
      break;
 3238a50:	00004806 	br	3238b74 <tcp_timers+0x484>
   /*
    * Keep-alive timer went off; send something
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
 3238a54:	0080c9b4 	movhi	r2,806
 3238a58:	10b4b504 	addi	r2,r2,-11564
 3238a5c:	10800c17 	ldw	r2,48(r2)
 3238a60:	10c00044 	addi	r3,r2,1
 3238a64:	0080c9b4 	movhi	r2,806
 3238a68:	10b4b504 	addi	r2,r2,-11564
 3238a6c:	10c00c15 	stw	r3,48(r2)
      if (tp->t_state < TCPS_ESTABLISHED)
 3238a70:	e0bffb17 	ldw	r2,-20(fp)
 3238a74:	10800217 	ldw	r2,8(r2)
 3238a78:	10800110 	cmplti	r2,r2,4
 3238a7c:	1000321e 	bne	r2,zero,3238b48 <tcp_timers+0x458>
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 3238a80:	e0bffb17 	ldw	r2,-20(fp)
 3238a84:	10800d17 	ldw	r2,52(r2)
 3238a88:	10800817 	ldw	r2,32(r2)
 3238a8c:	10800417 	ldw	r2,16(r2)
 3238a90:	1080020c 	andi	r2,r2,8
 3238a94:	1005003a 	cmpeq	r2,r2,zero
 3238a98:	1000241e 	bne	r2,zero,3238b2c <tcp_timers+0x43c>
 3238a9c:	e0bffb17 	ldw	r2,-20(fp)
 3238aa0:	10800217 	ldw	r2,8(r2)
 3238aa4:	10800188 	cmpgei	r2,r2,6
 3238aa8:	1000201e 	bne	r2,zero,3238b2c <tcp_timers+0x43c>
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
 3238aac:	e0bffb17 	ldw	r2,-20(fp)
 3238ab0:	11001d17 	ldw	r4,116(r2)
 3238ab4:	d0e03a17 	ldw	r3,-32536(gp)
 3238ab8:	d0a8eb17 	ldw	r2,-23636(gp)
 3238abc:	1885883a 	add	r2,r3,r2
 3238ac0:	2080210e 	bge	r4,r2,3238b48 <tcp_timers+0x458>
          * causes the transmitted zero-length segment
          * to lie outside the receive window;
          * by the protocol spec, this requires the
          * correspondent TCP to respond.
          */
         tcpstat.tcps_keepprobe++;
 3238ac4:	0080c9b4 	movhi	r2,806
 3238ac8:	10b4b504 	addi	r2,r2,-11564
 3238acc:	10800d17 	ldw	r2,52(r2)
 3238ad0:	10c00044 	addi	r3,r2,1
 3238ad4:	0080c9b4 	movhi	r2,806
 3238ad8:	10b4b504 	addi	r2,r2,-11564
 3238adc:	10c00d15 	stw	r3,52(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 3238ae0:	e0bffb17 	ldw	r2,-20(fp)
 3238ae4:	11400c17 	ldw	r5,48(r2)
 3238ae8:	e0bffb17 	ldw	r2,-20(fp)
 3238aec:	10801617 	ldw	r2,88(r2)
 3238af0:	11bfffc4 	addi	r6,r2,-1
 3238af4:	e0bffb17 	ldw	r2,-20(fp)
 3238af8:	10800e17 	ldw	r2,56(r2)
 3238afc:	11ffffc4 	addi	r7,r2,-1
 3238b00:	d8000015 	stw	zero,0(sp)
 3238b04:	d8000115 	stw	zero,4(sp)
 3238b08:	e13ffb17 	ldw	r4,-20(fp)
 3238b0c:	3237b7c0 	call	3237b7c <tcp_respond>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
 3238b10:	d0a03b17 	ldw	r2,-32532(gp)
 3238b14:	10ffffcc 	andi	r3,r2,65535
 3238b18:	18e0001c 	xori	r3,r3,32768
 3238b1c:	18e00004 	addi	r3,r3,-32768
 3238b20:	e0bffb17 	ldw	r2,-20(fp)
 3238b24:	10c00515 	stw	r3,20(r2)
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 3238b28:	00001206 	br	3238b74 <tcp_timers+0x484>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
 3238b2c:	d0a03a17 	ldw	r2,-32536(gp)
 3238b30:	10ffffcc 	andi	r3,r2,65535
 3238b34:	18e0001c 	xori	r3,r3,32768
 3238b38:	18e00004 	addi	r3,r3,-32768
 3238b3c:	e0bffb17 	ldw	r2,-20(fp)
 3238b40:	10c00515 	stw	r3,20(r2)
      break;
 3238b44:	00000b06 	br	3238b74 <tcp_timers+0x484>
      dropit:
      tcpstat.tcps_keepdrops++;
 3238b48:	0080c9b4 	movhi	r2,806
 3238b4c:	10b4b504 	addi	r2,r2,-11564
 3238b50:	10800e17 	ldw	r2,56(r2)
 3238b54:	10c00044 	addi	r3,r2,1
 3238b58:	0080c9b4 	movhi	r2,806
 3238b5c:	10b4b504 	addi	r2,r2,-11564
 3238b60:	10c00e15 	stw	r3,56(r2)
      tp = tcp_drop (tp, ETIMEDOUT);
 3238b64:	e13ffb17 	ldw	r4,-20(fp)
 3238b68:	01401d04 	movi	r5,116
 3238b6c:	323811c0 	call	323811c <tcp_drop>
 3238b70:	e0bffb15 	stw	r2,-20(fp)
      break;
   }
   return tp;
 3238b74:	e0bffb17 	ldw	r2,-20(fp)
}
 3238b78:	e037883a 	mov	sp,fp
 3238b7c:	dfc00117 	ldw	ra,4(sp)
 3238b80:	df000017 	ldw	fp,0(sp)
 3238b84:	dec00204 	addi	sp,sp,8
 3238b88:	f800283a 	ret

03238b8c <tcp_usrreq>:

int
tcp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 3238b8c:	defff504 	addi	sp,sp,-44
 3238b90:	dfc00a15 	stw	ra,40(sp)
 3238b94:	df000915 	stw	fp,36(sp)
 3238b98:	df000904 	addi	fp,sp,36
 3238b9c:	e13ffc15 	stw	r4,-16(fp)
 3238ba0:	e17ffd15 	stw	r5,-12(fp)
 3238ba4:	e1bffe15 	stw	r6,-8(fp)
   struct inpcb * inp;
   struct tcpcb * tp;
   int   error =  0;
 3238ba8:	e03ff915 	stw	zero,-28(fp)

#ifdef DO_TCPTRACE
   int   ostate;
#endif

   req = so->so_req;    /* get request from socket struct */
 3238bac:	e0bffc17 	ldw	r2,-16(fp)
 3238bb0:	10800717 	ldw	r2,28(r2)
 3238bb4:	e0bff815 	stw	r2,-32(fp)
   inp = sotoinpcb(so);
 3238bb8:	e0bffc17 	ldw	r2,-16(fp)
 3238bbc:	10800117 	ldw	r2,4(r2)
 3238bc0:	e0bffb15 	stw	r2,-20(fp)
   /*
    * When a TCP is attached to a socket, then there will be
    * a (struct inpcb) pointed at by the socket, and this
    * structure will point at a subsidary (struct tcpcb).
    */
   if (inp == 0 && req != PRU_ATTACH) 
 3238bc4:	e0bffb17 	ldw	r2,-20(fp)
 3238bc8:	1004c03a 	cmpne	r2,r2,zero
 3238bcc:	1000061e 	bne	r2,zero,3238be8 <tcp_usrreq+0x5c>
 3238bd0:	e0bff817 	ldw	r2,-32(fp)
 3238bd4:	1005003a 	cmpeq	r2,r2,zero
 3238bd8:	1000031e 	bne	r2,zero,3238be8 <tcp_usrreq+0x5c>
   {
      return (EINVAL);
 3238bdc:	00800584 	movi	r2,22
 3238be0:	e0bfff15 	stw	r2,-4(fp)
 3238be4:	0001a406 	br	3239278 <tcp_usrreq+0x6ec>
   }

   if (inp)
 3238be8:	e0bffb17 	ldw	r2,-20(fp)
 3238bec:	1005003a 	cmpeq	r2,r2,zero
 3238bf0:	1000041e 	bne	r2,zero,3238c04 <tcp_usrreq+0x78>
      tp = intotcpcb(inp);
 3238bf4:	e0bffb17 	ldw	r2,-20(fp)
 3238bf8:	10800917 	ldw	r2,36(r2)
 3238bfc:	e0bffa15 	stw	r2,-24(fp)
 3238c00:	00000906 	br	3238c28 <tcp_usrreq+0x9c>
   else  /* inp and tp not set, make sure this is OK: */
   { 
      if (req == PRU_ATTACH)
 3238c04:	e0bff817 	ldw	r2,-32(fp)
 3238c08:	1004c03a 	cmpne	r2,r2,zero
 3238c0c:	1000021e 	bne	r2,zero,3238c18 <tcp_usrreq+0x8c>
         tp = NULL;  /* stifle compiler warnings about using unassigned tp*/
 3238c10:	e03ffa15 	stw	zero,-24(fp)
 3238c14:	00000406 	br	3238c28 <tcp_usrreq+0x9c>
      else
      {
         dtrap(); /* programming error? */
 3238c18:	322aef00 	call	322aef0 <dtrap>
         return EINVAL;
 3238c1c:	00800584 	movi	r2,22
 3238c20:	e0bfff15 	stw	r2,-4(fp)
 3238c24:	00019406 	br	3239278 <tcp_usrreq+0x6ec>
      }
   }

   switch (req) 
 3238c28:	e0bff817 	ldw	r2,-32(fp)
 3238c2c:	10800528 	cmpgeui	r2,r2,20
 3238c30:	10018c1e 	bne	r2,zero,3239264 <tcp_usrreq+0x6d8>
 3238c34:	e0bff817 	ldw	r2,-32(fp)
 3238c38:	1085883a 	add	r2,r2,r2
 3238c3c:	1087883a 	add	r3,r2,r2
 3238c40:	0080c934 	movhi	r2,804
 3238c44:	10a31504 	addi	r2,r2,-29612
 3238c48:	1885883a 	add	r2,r3,r2
 3238c4c:	10800017 	ldw	r2,0(r2)
 3238c50:	1000683a 	jmp	r2
 3238c54:	03238ca4 	muli	r12,zero,-29134
 3238c58:	03238d14 	movui	r12,36404
 3238c5c:	03238d3c 	xorhi	r12,zero,36404
 3238c60:	03238d74 	movhi	r12,36405
 3238c64:	03238db4 	movhi	r12,36406
 3238c68:	03238f38 	rdprs	r12,zero,-29124
 3238c6c:	03238f2c 	andhi	r12,zero,36412
 3238c70:	03238fe4 	muli	r12,zero,-29121
 3238c74:	03239014 	movui	r12,36416
 3238c78:	03239020 	cmpeqi	r12,zero,-29120
 3238c7c:	03239078 	rdprs	r12,zero,-29119
 3238c80:	03239264 	muli	r12,zero,-29111
 3238c84:	03239088 	cmpgei	r12,zero,-29118
 3238c88:	03239094 	movui	r12,36418
 3238c8c:	03239164 	muli	r12,zero,-29115
 3238c90:	03239234 	movhi	r12,36424
 3238c94:	03239244 	movi	r12,-29111
 3238c98:	03238f20 	cmpeqi	r12,zero,-29124
 3238c9c:	03239264 	muli	r12,zero,-29111
 3238ca0:	03239254 	movui	r12,36425
   /*
    * TCP attaches to socket via PRU_ATTACH, reserving space,
    * and an internet control block.
    */
   case PRU_ATTACH:
      if (inp) 
 3238ca4:	e0bffb17 	ldw	r2,-20(fp)
 3238ca8:	1005003a 	cmpeq	r2,r2,zero
 3238cac:	1000031e 	bne	r2,zero,3238cbc <tcp_usrreq+0x130>
      {
         error = EISCONN;
 3238cb0:	00801fc4 	movi	r2,127
 3238cb4:	e0bff915 	stw	r2,-28(fp)
         break;
 3238cb8:	00016d06 	br	3239270 <tcp_usrreq+0x6e4>
      }
      error = tcp_attach(so);
 3238cbc:	e13ffc17 	ldw	r4,-16(fp)
 3238cc0:	32392900 	call	3239290 <tcp_attach>
 3238cc4:	e0bff915 	stw	r2,-28(fp)
      if (error)
 3238cc8:	e0bff917 	ldw	r2,-28(fp)
 3238ccc:	1004c03a 	cmpne	r2,r2,zero
 3238cd0:	1001671e 	bne	r2,zero,3239270 <tcp_usrreq+0x6e4>
         break;
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 3238cd4:	e0bffc17 	ldw	r2,-16(fp)
 3238cd8:	10800417 	ldw	r2,16(r2)
 3238cdc:	1080200c 	andi	r2,r2,128
 3238ce0:	1005003a 	cmpeq	r2,r2,zero
 3238ce4:	1001621e 	bne	r2,zero,3239270 <tcp_usrreq+0x6e4>
 3238ce8:	e0bffc17 	ldw	r2,-16(fp)
 3238cec:	1080080b 	ldhu	r2,32(r2)
 3238cf0:	10bfffcc 	andi	r2,r2,65535
 3238cf4:	10a0001c 	xori	r2,r2,32768
 3238cf8:	10a00004 	addi	r2,r2,-32768
 3238cfc:	1004c03a 	cmpne	r2,r2,zero
 3238d00:	10015b1e 	bne	r2,zero,3239270 <tcp_usrreq+0x6e4>
         so->so_linger = TCP_LINGERTIME;
 3238d04:	e0fffc17 	ldw	r3,-16(fp)
 3238d08:	00801e04 	movi	r2,120
 3238d0c:	1880080d 	sth	r2,32(r3)
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 3238d10:	00015706 	br	3239270 <tcp_usrreq+0x6e4>
    * do this directly: have to initiate a PRU_DISCONNECT,
    * which may finish later; embryonic TCB's can just
    * be discarded here.
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
 3238d14:	e0bffa17 	ldw	r2,-24(fp)
 3238d18:	10800217 	ldw	r2,8(r2)
 3238d1c:	10800090 	cmplti	r2,r2,2
 3238d20:	1000031e 	bne	r2,zero,3238d30 <tcp_usrreq+0x1a4>
         SETTP(tp, tcp_disconnect(tp));
 3238d24:	e13ffa17 	ldw	r4,-24(fp)
 3238d28:	32393c40 	call	32393c4 <tcp_disconnect>
 3238d2c:	00015006 	br	3239270 <tcp_usrreq+0x6e4>
      else
         SETTP(tp, tcp_close(tp));
 3238d30:	e13ffa17 	ldw	r4,-24(fp)
 3238d34:	32381c80 	call	32381c8 <tcp_close>
      break;
 3238d38:	00014d06 	br	3239270 <tcp_usrreq+0x6e4>
      /* bind is quite different for IPv4 and v6, so we use two 
       * seperate pcbbind routines. so_domain was checked for 
       * validity way up in t_bind()
       */
#ifdef IP_V4
      if(inp->inp_socket->so_domain == AF_INET)
 3238d3c:	e0bffb17 	ldw	r2,-20(fp)
 3238d40:	10800817 	ldw	r2,32(r2)
 3238d44:	10800517 	ldw	r2,20(r2)
 3238d48:	10800098 	cmpnei	r2,r2,2
 3238d4c:	1000051e 	bne	r2,zero,3238d64 <tcp_usrreq+0x1d8>
      {
         error = in_pcbbind(inp, nam);
 3238d50:	e13ffb17 	ldw	r4,-20(fp)
 3238d54:	e17ffe17 	ldw	r5,-8(fp)
 3238d58:	32482cc0 	call	32482cc <in_pcbbind>
 3238d5c:	e0bff915 	stw	r2,-28(fp)
         break;
 3238d60:	00014306 	br	3239270 <tcp_usrreq+0x6e4>
      {
         error = ip6_pcbbind(inp, nam);
         break;
      }
#endif /* IP_V6 */
      dtrap();    /* not v4 or v6? */
 3238d64:	322aef00 	call	322aef0 <dtrap>
      error = EINVAL;
 3238d68:	00800584 	movi	r2,22
 3238d6c:	e0bff915 	stw	r2,-28(fp)
      break;
 3238d70:	00013f06 	br	3239270 <tcp_usrreq+0x6e4>
   /*
    * Prepare to accept connections.
    */
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
 3238d74:	e0bffb17 	ldw	r2,-20(fp)
 3238d78:	1080078b 	ldhu	r2,30(r2)
 3238d7c:	10bfffcc 	andi	r2,r2,65535
 3238d80:	1004c03a 	cmpne	r2,r2,zero
 3238d84:	1000041e 	bne	r2,zero,3238d98 <tcp_usrreq+0x20c>
         error = in_pcbbind(inp, (struct mbuf *)0);
 3238d88:	e13ffb17 	ldw	r4,-20(fp)
 3238d8c:	000b883a 	mov	r5,zero
 3238d90:	32482cc0 	call	32482cc <in_pcbbind>
 3238d94:	e0bff915 	stw	r2,-28(fp)
      if (error == 0)
 3238d98:	e0bff917 	ldw	r2,-28(fp)
 3238d9c:	1004c03a 	cmpne	r2,r2,zero
 3238da0:	1001331e 	bne	r2,zero,3239270 <tcp_usrreq+0x6e4>
         tp->t_state = TCPS_LISTEN;
 3238da4:	e0fffa17 	ldw	r3,-24(fp)
 3238da8:	00800044 	movi	r2,1
 3238dac:	18800215 	stw	r2,8(r3)
      break;
 3238db0:	00012f06 	br	3239270 <tcp_usrreq+0x6e4>
    * Enter SYN_SENT state, and mark socket as connecting.
    * Start keep-alive timer, and seed output sequence space.
    * Send initial segment on connection.
    */
   case PRU_CONNECT:
      if (inp->inp_lport == 0) 
 3238db4:	e0bffb17 	ldw	r2,-20(fp)
 3238db8:	1080078b 	ldhu	r2,30(r2)
 3238dbc:	10bfffcc 	andi	r2,r2,65535
 3238dc0:	1004c03a 	cmpne	r2,r2,zero
 3238dc4:	1000071e 	bne	r2,zero,3238de4 <tcp_usrreq+0x258>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbbind(inp, (struct mbuf *)0);
 3238dc8:	e13ffb17 	ldw	r4,-20(fp)
 3238dcc:	000b883a 	mov	r5,zero
 3238dd0:	32482cc0 	call	32482cc <in_pcbbind>
 3238dd4:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
 3238dd8:	e0bff917 	ldw	r2,-28(fp)
 3238ddc:	1004c03a 	cmpne	r2,r2,zero
 3238de0:	1001231e 	bne	r2,zero,3239270 <tcp_usrreq+0x6e4>
            break;
      }

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbconnect(inp, nam);
 3238de4:	e13ffb17 	ldw	r4,-20(fp)
 3238de8:	e17ffe17 	ldw	r5,-8(fp)
 3238dec:	32485200 	call	3248520 <in_pcbconnect>
 3238df0:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
 3238df4:	e0bff917 	ldw	r2,-28(fp)
 3238df8:	1004c03a 	cmpne	r2,r2,zero
 3238dfc:	10011c1e 	bne	r2,zero,3239270 <tcp_usrreq+0x6e4>
         break;
      tp->t_template = tcp_template(tp);
 3238e00:	e13ffa17 	ldw	r4,-24(fp)
 3238e04:	3237a640 	call	3237a64 <tcp_template>
 3238e08:	1007883a 	mov	r3,r2
 3238e0c:	e0bffa17 	ldw	r2,-24(fp)
 3238e10:	10c00c15 	stw	r3,48(r2)
      if (tp->t_template == 0) 
 3238e14:	e0bffa17 	ldw	r2,-24(fp)
 3238e18:	10800c17 	ldw	r2,48(r2)
 3238e1c:	1004c03a 	cmpne	r2,r2,zero
 3238e20:	1000051e 	bne	r2,zero,3238e38 <tcp_usrreq+0x2ac>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
         in_pcbdisconnect(inp);
 3238e24:	e13ffb17 	ldw	r4,-20(fp)
 3238e28:	32487300 	call	3248730 <in_pcbdisconnect>
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
         ip6_pcbdisconnect(inp);
#endif   /* end v6 only */

         error = ENOBUFS;
 3238e2c:	00801a44 	movi	r2,105
 3238e30:	e0bff915 	stw	r2,-28(fp)
         break;
 3238e34:	00010e06 	br	3239270 <tcp_usrreq+0x6e4>
      }

      soisconnecting(so);
 3238e38:	e13ffc17 	ldw	r4,-16(fp)
 3238e3c:	3231a980 	call	3231a98 <soisconnecting>
      tcpstat.tcps_connattempt++;
 3238e40:	0080c9b4 	movhi	r2,806
 3238e44:	10b4b504 	addi	r2,r2,-11564
 3238e48:	10800017 	ldw	r2,0(r2)
 3238e4c:	10c00044 	addi	r3,r2,1
 3238e50:	0080c9b4 	movhi	r2,806
 3238e54:	10b4b504 	addi	r2,r2,-11564
 3238e58:	10c00015 	stw	r3,0(r2)
      tp->t_state = TCPS_SYN_SENT;
 3238e5c:	e0fffa17 	ldw	r3,-24(fp)
 3238e60:	00800084 	movi	r2,2
 3238e64:	18800215 	stw	r2,8(r3)
      tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 3238e68:	e0fffa17 	ldw	r3,-24(fp)
 3238e6c:	00802584 	movi	r2,150
 3238e70:	18800515 	stw	r2,20(r3)
      tp->iss = tcp_iss; 
 3238e74:	0080c974 	movhi	r2,805
 3238e78:	10934e04 	addi	r2,r2,19768
 3238e7c:	10c00017 	ldw	r3,0(r2)
 3238e80:	e0bffa17 	ldw	r2,-24(fp)
 3238e84:	10c01315 	stw	r3,76(r2)
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
 3238e88:	0080c974 	movhi	r2,805
 3238e8c:	10934e04 	addi	r2,r2,19768
 3238e90:	10c00017 	ldw	r3,0(r2)
 3238e94:	00be9fd4 	movui	r2,64127
 3238e98:	1887883a 	add	r3,r3,r2
 3238e9c:	0080c974 	movhi	r2,805
 3238ea0:	10934e04 	addi	r2,r2,19768
 3238ea4:	10c00015 	stw	r3,0(r2)
      tcp_sendseqinit(tp);
 3238ea8:	e0bffa17 	ldw	r2,-24(fp)
 3238eac:	10c01317 	ldw	r3,76(r2)
 3238eb0:	e0bffa17 	ldw	r2,-24(fp)
 3238eb4:	10c01015 	stw	r3,64(r2)
 3238eb8:	e0bffa17 	ldw	r2,-24(fp)
 3238ebc:	10c01017 	ldw	r3,64(r2)
 3238ec0:	e0bffa17 	ldw	r2,-24(fp)
 3238ec4:	10c01a15 	stw	r3,104(r2)
 3238ec8:	e0bffa17 	ldw	r2,-24(fp)
 3238ecc:	10c01a17 	ldw	r3,104(r2)
 3238ed0:	e0bffa17 	ldw	r2,-24(fp)
 3238ed4:	10c00f15 	stw	r3,60(r2)
 3238ed8:	e0bffa17 	ldw	r2,-24(fp)
 3238edc:	10c00f17 	ldw	r3,60(r2)
 3238ee0:	e0bffa17 	ldw	r2,-24(fp)
 3238ee4:	10c00e15 	stw	r3,56(r2)
      error = tcp_output(tp);
 3238ee8:	e13ffa17 	ldw	r4,-24(fp)
 3238eec:	32366ac0 	call	32366ac <tcp_output>
 3238ef0:	e0bff915 	stw	r2,-28(fp)
      if (!error)
 3238ef4:	e0bff917 	ldw	r2,-28(fp)
 3238ef8:	1004c03a 	cmpne	r2,r2,zero
 3238efc:	1000dc1e 	bne	r2,zero,3239270 <tcp_usrreq+0x6e4>
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
 3238f00:	0080c9b4 	movhi	r2,806
 3238f04:	10b48704 	addi	r2,r2,-11748
 3238f08:	10800417 	ldw	r2,16(r2)
 3238f0c:	10c00044 	addi	r3,r2,1
 3238f10:	0080c9b4 	movhi	r2,806
 3238f14:	10b48704 	addi	r2,r2,-11748
 3238f18:	10c00415 	stw	r3,16(r2)
      break;
 3238f1c:	0000d406 	br	3239270 <tcp_usrreq+0x6e4>

   /*
    * Create a TCP connection between two sockets.
    */
   case PRU_CONNECT2:
      error = EOPNOTSUPP;
 3238f20:	008017c4 	movi	r2,95
 3238f24:	e0bff915 	stw	r2,-28(fp)
      break;
 3238f28:	0000d106 	br	3239270 <tcp_usrreq+0x6e4>
    * when peer sends FIN and acks ours.
    *
    * SHOULD IMPLEMENT LATER PRU_CONNECT VIA REALLOC TCPCB.
    */
   case PRU_DISCONNECT:
      SETTP(tp, tcp_disconnect(tp));
 3238f2c:	e13ffa17 	ldw	r4,-24(fp)
 3238f30:	32393c40 	call	32393c4 <tcp_disconnect>
      break;
 3238f34:	0000ce06 	br	3239270 <tcp_usrreq+0x6e4>
    * done at higher levels; just return the address
    * of the peer, storing through addr.
    */
   case PRU_ACCEPT: 
   {
         struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 3238f38:	e0bffe17 	ldw	r2,-8(fp)
 3238f3c:	10800317 	ldw	r2,12(r2)
 3238f40:	e0bff715 	stw	r2,-36(fp)
            IP6CPY(&sin6->sin6_addr, &inp->ip6_faddr);
         }
#endif

#ifdef IP_V4
         if (so->so_domain == AF_INET)
 3238f44:	e0bffc17 	ldw	r2,-16(fp)
 3238f48:	10800517 	ldw	r2,20(r2)
 3238f4c:	10800098 	cmpnei	r2,r2,2
 3238f50:	10000e1e 	bne	r2,zero,3238f8c <tcp_usrreq+0x400>
         {
            nam->m_len = sizeof (struct sockaddr_in);
 3238f54:	e0fffe17 	ldw	r3,-8(fp)
 3238f58:	00800404 	movi	r2,16
 3238f5c:	18800215 	stw	r2,8(r3)
            sin->sin_family = AF_INET;
 3238f60:	e0fff717 	ldw	r3,-36(fp)
 3238f64:	00800084 	movi	r2,2
 3238f68:	1880000d 	sth	r2,0(r3)
            sin->sin_port = inp->inp_fport;
 3238f6c:	e0bffb17 	ldw	r2,-20(fp)
 3238f70:	10c0070b 	ldhu	r3,28(r2)
 3238f74:	e0bff717 	ldw	r2,-36(fp)
 3238f78:	10c0008d 	sth	r3,2(r2)
            sin->sin_addr = inp->inp_faddr;
 3238f7c:	e0bffb17 	ldw	r2,-20(fp)
 3238f80:	10c00317 	ldw	r3,12(r2)
 3238f84:	e0bff717 	ldw	r2,-36(fp)
 3238f88:	10c00115 	stw	r3,4(r2)
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 3238f8c:	e0bffc17 	ldw	r2,-16(fp)
 3238f90:	10800517 	ldw	r2,20(r2)
 3238f94:	108000a0 	cmpeqi	r2,r2,2
 3238f98:	10000a1e 	bne	r2,zero,3238fc4 <tcp_usrreq+0x438>
 3238f9c:	e0bffc17 	ldw	r2,-16(fp)
 3238fa0:	10800517 	ldw	r2,20(r2)
 3238fa4:	108000e0 	cmpeqi	r2,r2,3
 3238fa8:	1000061e 	bne	r2,zero,3238fc4 <tcp_usrreq+0x438>
              !(so->so_domain == AF_INET6)
             )
         {
            dprintf("*** PRU_ACCEPT bad domain = %d\n", so->so_domain);
 3238fac:	e0bffc17 	ldw	r2,-16(fp)
 3238fb0:	11400517 	ldw	r5,20(r2)
 3238fb4:	0100c974 	movhi	r4,805
 3238fb8:	213e7604 	addi	r4,r4,-1576
 3238fbc:	3206de00 	call	3206de0 <printf>
            dtrap();
 3238fc0:	322aef00 	call	322aef0 <dtrap>
         } 
         TCP_MIB_INC(tcpPassiveOpens);    /* keep MIB stats */
 3238fc4:	0080c9b4 	movhi	r2,806
 3238fc8:	10b48704 	addi	r2,r2,-11748
 3238fcc:	10800517 	ldw	r2,20(r2)
 3238fd0:	10c00044 	addi	r3,r2,1
 3238fd4:	0080c9b4 	movhi	r2,806
 3238fd8:	10b48704 	addi	r2,r2,-11748
 3238fdc:	10c00515 	stw	r3,20(r2)
         break;
 3238fe0:	0000a306 	br	3239270 <tcp_usrreq+0x6e4>

   /*
    * Mark the connection as being incapable of further output.
    */
   case PRU_SHUTDOWN:
      socantsendmore(so);
 3238fe4:	e13ffc17 	ldw	r4,-16(fp)
 3238fe8:	32321300 	call	3232130 <socantsendmore>
      tp = tcp_usrclosed(tp);
 3238fec:	e13ffa17 	ldw	r4,-24(fp)
 3238ff0:	32394980 	call	3239498 <tcp_usrclosed>
 3238ff4:	e0bffa15 	stw	r2,-24(fp)
      if (tp)
 3238ff8:	e0bffa17 	ldw	r2,-24(fp)
 3238ffc:	1005003a 	cmpeq	r2,r2,zero
 3239000:	10009b1e 	bne	r2,zero,3239270 <tcp_usrreq+0x6e4>
         error = tcp_output(tp);
 3239004:	e13ffa17 	ldw	r4,-24(fp)
 3239008:	32366ac0 	call	32366ac <tcp_output>
 323900c:	e0bff915 	stw	r2,-28(fp)
      break;
 3239010:	00009706 	br	3239270 <tcp_usrreq+0x6e4>

   /*
    * After a receive, possibly send window update to peer.
    */
   case PRU_RCVD:
      (void) tcp_output(tp);
 3239014:	e13ffa17 	ldw	r4,-24(fp)
 3239018:	32366ac0 	call	32366ac <tcp_output>
      break;
 323901c:	00009406 	br	3239270 <tcp_usrreq+0x6e4>
   /*
    * Do a send by putting data in output queue and updating urgent
    * marker if URG set.  Possibly send more data.
    */
   case PRU_SEND:
      if (so->so_pcb == NULL)
 3239020:	e0bffc17 	ldw	r2,-16(fp)
 3239024:	10800117 	ldw	r2,4(r2)
 3239028:	1004c03a 	cmpne	r2,r2,zero
 323902c:	1000031e 	bne	r2,zero,323903c <tcp_usrreq+0x4b0>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 3239030:	00800804 	movi	r2,32
 3239034:	e0bff915 	stw	r2,-28(fp)
         break;
 3239038:	00008d06 	br	3239270 <tcp_usrreq+0x6e4>
      }
      sbappend(&so->so_snd, m);
 323903c:	e0bffc17 	ldw	r2,-16(fp)
 3239040:	11001204 	addi	r4,r2,72
 3239044:	e17ffd17 	ldw	r5,-12(fp)
 3239048:	32324340 	call	3232434 <sbappend>
      error = tcp_output(tp);
 323904c:	e13ffa17 	ldw	r4,-24(fp)
 3239050:	32366ac0 	call	32366ac <tcp_output>
 3239054:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 3239058:	e0bff917 	ldw	r2,-28(fp)
 323905c:	10801a58 	cmpnei	r2,r2,105
 3239060:	1000831e 	bne	r2,zero,3239270 <tcp_usrreq+0x6e4>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 3239064:	e0bffc17 	ldw	r2,-16(fp)
 3239068:	11001204 	addi	r4,r2,72
 323906c:	e17ffd17 	ldw	r5,-12(fp)
 3239070:	3232c0c0 	call	3232c0c <sbdropend>
      break;
 3239074:	00007e06 	br	3239270 <tcp_usrreq+0x6e4>

   /*
    * Abort the TCP.
    */
   case PRU_ABORT:
      SETTP(tp, tcp_drop(tp, ECONNABORTED));
 3239078:	e13ffa17 	ldw	r4,-24(fp)
 323907c:	01401c44 	movi	r5,113
 3239080:	323811c0 	call	323811c <tcp_drop>
      break;
 3239084:	00007a06 	br	3239270 <tcp_usrreq+0x6e4>

   case PRU_SENSE:
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
 3239088:	322aef00 	call	322aef0 <dtrap>
      return (0);
 323908c:	e03fff15 	stw	zero,-4(fp)
 3239090:	00007906 	br	3239278 <tcp_usrreq+0x6ec>

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 3239094:	e0bffc17 	ldw	r2,-16(fp)
 3239098:	10801a17 	ldw	r2,104(r2)
 323909c:	1004c03a 	cmpne	r2,r2,zero
 32390a0:	1000061e 	bne	r2,zero,32390bc <tcp_usrreq+0x530>
 32390a4:	e0bffc17 	ldw	r2,-16(fp)
 32390a8:	1080088b 	ldhu	r2,34(r2)
 32390ac:	10bfffcc 	andi	r2,r2,65535
 32390b0:	1080100c 	andi	r2,r2,64
 32390b4:	1005003a 	cmpeq	r2,r2,zero
 32390b8:	10000b1e 	bne	r2,zero,32390e8 <tcp_usrreq+0x55c>
 32390bc:	e0bffc17 	ldw	r2,-16(fp)
 32390c0:	10800417 	ldw	r2,16(r2)
 32390c4:	1080400c 	andi	r2,r2,256
 32390c8:	1004c03a 	cmpne	r2,r2,zero
 32390cc:	1000061e 	bne	r2,zero,32390e8 <tcp_usrreq+0x55c>
 32390d0:	e0bffa17 	ldw	r2,-24(fp)
 32390d4:	10802403 	ldbu	r2,144(r2)
 32390d8:	10803fcc 	andi	r2,r2,255
 32390dc:	1080008c 	andi	r2,r2,2
 32390e0:	1005003a 	cmpeq	r2,r2,zero
 32390e4:	1000031e 	bne	r2,zero,32390f4 <tcp_usrreq+0x568>
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
       {
         error = EINVAL;
 32390e8:	00800584 	movi	r2,22
 32390ec:	e0bff915 	stw	r2,-28(fp)
         break;
 32390f0:	00005f06 	br	3239270 <tcp_usrreq+0x6e4>
      }
      if ((tp->t_oobflags & TCPOOB_HAVEDATA) == 0) 
 32390f4:	e0bffa17 	ldw	r2,-24(fp)
 32390f8:	10802403 	ldbu	r2,144(r2)
 32390fc:	10803fcc 	andi	r2,r2,255
 3239100:	1080004c 	andi	r2,r2,1
 3239104:	1004c03a 	cmpne	r2,r2,zero
 3239108:	1000031e 	bne	r2,zero,3239118 <tcp_usrreq+0x58c>
      {
         error = EWOULDBLOCK;
 323910c:	008002c4 	movi	r2,11
 3239110:	e0bff915 	stw	r2,-28(fp)
         break;
 3239114:	00005606 	br	3239270 <tcp_usrreq+0x6e4>
      }
      m->m_len = 1;
 3239118:	e0fffd17 	ldw	r3,-12(fp)
 323911c:	00800044 	movi	r2,1
 3239120:	18800215 	stw	r2,8(r3)
      *mtod(m, char *) = tp->t_iobc;
 3239124:	e0bffd17 	ldw	r2,-12(fp)
 3239128:	10c00317 	ldw	r3,12(r2)
 323912c:	e0bffa17 	ldw	r2,-24(fp)
 3239130:	10802443 	ldbu	r2,145(r2)
 3239134:	18800005 	stb	r2,0(r3)
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
 3239138:	e0bffe17 	ldw	r2,-8(fp)
 323913c:	1080008c 	andi	r2,r2,2
 3239140:	1004c03a 	cmpne	r2,r2,zero
 3239144:	10004a1e 	bne	r2,zero,3239270 <tcp_usrreq+0x6e4>
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 3239148:	e0bffa17 	ldw	r2,-24(fp)
 323914c:	10802403 	ldbu	r2,144(r2)
 3239150:	108000dc 	xori	r2,r2,3
 3239154:	1007883a 	mov	r3,r2
 3239158:	e0bffa17 	ldw	r2,-24(fp)
 323915c:	10c02405 	stb	r3,144(r2)
      break;
 3239160:	00004306 	br	3239270 <tcp_usrreq+0x6e4>

   case PRU_SENDOOB:
      if (so->so_pcb == NULL)
 3239164:	e0bffc17 	ldw	r2,-16(fp)
 3239168:	10800117 	ldw	r2,4(r2)
 323916c:	1004c03a 	cmpne	r2,r2,zero
 3239170:	1000031e 	bne	r2,zero,3239180 <tcp_usrreq+0x5f4>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 3239174:	00800804 	movi	r2,32
 3239178:	e0bff915 	stw	r2,-28(fp)
         break;
 323917c:	00003c06 	br	3239270 <tcp_usrreq+0x6e4>
      }
      if (sbspace(&so->so_snd) == 0) 
 3239180:	e0bffc17 	ldw	r2,-16(fp)
 3239184:	10801317 	ldw	r2,76(r2)
 3239188:	1007883a 	mov	r3,r2
 323918c:	e0bffc17 	ldw	r2,-16(fp)
 3239190:	10801217 	ldw	r2,72(r2)
 3239194:	1885c83a 	sub	r2,r3,r2
 3239198:	1004803a 	cmplt	r2,r2,zero
 323919c:	1000051e 	bne	r2,zero,32391b4 <tcp_usrreq+0x628>
 32391a0:	e0bffc17 	ldw	r2,-16(fp)
 32391a4:	10c01317 	ldw	r3,76(r2)
 32391a8:	e0bffc17 	ldw	r2,-16(fp)
 32391ac:	10801217 	ldw	r2,72(r2)
 32391b0:	1880051e 	bne	r3,r2,32391c8 <tcp_usrreq+0x63c>
      {
         m_freem(m);
 32391b4:	e13ffd17 	ldw	r4,-12(fp)
 32391b8:	322bfcc0 	call	322bfcc <m_freem>
         error = ENOBUFS;
 32391bc:	00801a44 	movi	r2,105
 32391c0:	e0bff915 	stw	r2,-28(fp)
         break;
 32391c4:	00002a06 	br	3239270 <tcp_usrreq+0x6e4>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section.
       * Otherwise, snd_up should be one lower.
       */
      sbappend(&so->so_snd, m);
 32391c8:	e0bffc17 	ldw	r2,-16(fp)
 32391cc:	11001204 	addi	r4,r2,72
 32391d0:	e17ffd17 	ldw	r5,-12(fp)
 32391d4:	32324340 	call	3232434 <sbappend>
      tp->snd_up = tp->snd_una + so->so_snd.sb_cc;
 32391d8:	e0bffa17 	ldw	r2,-24(fp)
 32391dc:	10c00e17 	ldw	r3,56(r2)
 32391e0:	e0bffc17 	ldw	r2,-16(fp)
 32391e4:	10801217 	ldw	r2,72(r2)
 32391e8:	1887883a 	add	r3,r3,r2
 32391ec:	e0bffa17 	ldw	r2,-24(fp)
 32391f0:	10c01015 	stw	r3,64(r2)
      tp->t_force = 1;
 32391f4:	e0fffa17 	ldw	r3,-24(fp)
 32391f8:	00800044 	movi	r2,1
 32391fc:	18800a85 	stb	r2,42(r3)
      error = tcp_output(tp);
 3239200:	e13ffa17 	ldw	r4,-24(fp)
 3239204:	32366ac0 	call	32366ac <tcp_output>
 3239208:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 323920c:	e0bff917 	ldw	r2,-28(fp)
 3239210:	10801a58 	cmpnei	r2,r2,105
 3239214:	1000041e 	bne	r2,zero,3239228 <tcp_usrreq+0x69c>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 3239218:	e0bffc17 	ldw	r2,-16(fp)
 323921c:	11001204 	addi	r4,r2,72
 3239220:	e17ffd17 	ldw	r5,-12(fp)
 3239224:	3232c0c0 	call	3232c0c <sbdropend>
      tp->t_force = 0;
 3239228:	e0bffa17 	ldw	r2,-24(fp)
 323922c:	10000a85 	stb	zero,42(r2)
      break;
 3239230:	00000f06 	br	3239270 <tcp_usrreq+0x6e4>
   case PRU_SOCKADDR:

   /* sockaddr and peeraddr have to switch based on IP type */
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setsockaddr(inp, nam);
 3239234:	e13ffb17 	ldw	r4,-20(fp)
 3239238:	e17ffe17 	ldw	r5,-8(fp)
 323923c:	32487900 	call	3248790 <in_setsockaddr>
         in_setsockaddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setsockaddr(inp, nam);
#endif
      break;         
 3239240:	00000b06 	br	3239270 <tcp_usrreq+0x6e4>

   case PRU_PEERADDR:
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setpeeraddr(inp, nam);
 3239244:	e13ffb17 	ldw	r4,-20(fp)
 3239248:	e17ffe17 	ldw	r5,-8(fp)
 323924c:	324880c0 	call	324880c <in_setpeeraddr>
         in_setpeeraddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setpeeraddr(inp, nam);
#endif
      break;
 3239250:	00000706 	br	3239270 <tcp_usrreq+0x6e4>

   case PRU_SLOWTIMO:
      SETTP(tp, tcp_timers(tp, (int)MBUF2LONG(nam)));
 3239254:	e17ffe17 	ldw	r5,-8(fp)
 3239258:	e13ffa17 	ldw	r4,-24(fp)
 323925c:	32386f00 	call	32386f0 <tcp_timers>
#ifdef DO_TCPTRACE
      req |= (long)nam << 8;        /* for debug's sake */
#endif
      break;
 3239260:	00000306 	br	3239270 <tcp_usrreq+0x6e4>

      default:
      panic("tcp_usrreq");
 3239264:	0100c974 	movhi	r4,805
 3239268:	213e7e04 	addi	r4,r4,-1544
 323926c:	32261540 	call	3226154 <panic>
#ifdef DO_TCPTRACE
   if (tp && (so->so_options & SO_DEBUG))
      tcp_trace("usrreq: state: %d, tcpcb: %x, req: %d",
    ostate, tp, req);
#endif
   return (error);
 3239270:	e0bff917 	ldw	r2,-28(fp)
 3239274:	e0bfff15 	stw	r2,-4(fp)
 3239278:	e0bfff17 	ldw	r2,-4(fp)
}
 323927c:	e037883a 	mov	sp,fp
 3239280:	dfc00117 	ldw	ra,4(sp)
 3239284:	df000017 	ldw	fp,0(sp)
 3239288:	dec00204 	addi	sp,sp,8
 323928c:	f800283a 	ret

03239290 <tcp_attach>:
 * RETURNS: 0 if OK, or nonzero error code.
 */

int
tcp_attach(struct socket * so)
{
 3239290:	defff804 	addi	sp,sp,-32
 3239294:	dfc00715 	stw	ra,28(sp)
 3239298:	df000615 	stw	fp,24(sp)
 323929c:	df000604 	addi	fp,sp,24
 32392a0:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
   struct inpcb * inp;
   int   error;

   if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) 
 32392a4:	e0bffe17 	ldw	r2,-8(fp)
 32392a8:	10801317 	ldw	r2,76(r2)
 32392ac:	1005003a 	cmpeq	r2,r2,zero
 32392b0:	1000041e 	bne	r2,zero,32392c4 <tcp_attach+0x34>
 32392b4:	e0bffe17 	ldw	r2,-8(fp)
 32392b8:	10800b17 	ldw	r2,44(r2)
 32392bc:	1004c03a 	cmpne	r2,r2,zero
 32392c0:	10000b1e 	bne	r2,zero,32392f0 <tcp_attach+0x60>
   {
      error = soreserve(so, tcp_sendspace, tcp_recvspace);
 32392c4:	d1603c17 	ldw	r5,-32528(gp)
 32392c8:	d1a03d17 	ldw	r6,-32524(gp)
 32392cc:	e13ffe17 	ldw	r4,-8(fp)
 32392d0:	323230c0 	call	323230c <soreserve>
 32392d4:	e0bffb15 	stw	r2,-20(fp)
      if (error)
 32392d8:	e0bffb17 	ldw	r2,-20(fp)
 32392dc:	1005003a 	cmpeq	r2,r2,zero
 32392e0:	1000031e 	bne	r2,zero,32392f0 <tcp_attach+0x60>
         return (error);
 32392e4:	e0bffb17 	ldw	r2,-20(fp)
 32392e8:	e0bfff15 	stw	r2,-4(fp)
 32392ec:	00002f06 	br	32393ac <tcp_attach+0x11c>
   }
   error = in_pcballoc(so, &tcb);
 32392f0:	e13ffe17 	ldw	r4,-8(fp)
 32392f4:	0140c9b4 	movhi	r5,806
 32392f8:	2974aa04 	addi	r5,r5,-11608
 32392fc:	32481e40 	call	32481e4 <in_pcballoc>
 3239300:	e0bffb15 	stw	r2,-20(fp)
   if (error)
 3239304:	e0bffb17 	ldw	r2,-20(fp)
 3239308:	1005003a 	cmpeq	r2,r2,zero
 323930c:	1000031e 	bne	r2,zero,323931c <tcp_attach+0x8c>
      return (error);
 3239310:	e0bffb17 	ldw	r2,-20(fp)
 3239314:	e0bfff15 	stw	r2,-4(fp)
 3239318:	00002406 	br	32393ac <tcp_attach+0x11c>
   inp = sotoinpcb(so);
 323931c:	e0bffe17 	ldw	r2,-8(fp)
 3239320:	10800117 	ldw	r2,4(r2)
 3239324:	e0bffc15 	stw	r2,-16(fp)
   tp = tcp_newtcpcb(inp);
 3239328:	e13ffc17 	ldw	r4,-16(fp)
 323932c:	32380040 	call	3238004 <tcp_newtcpcb>
 3239330:	e0bffd15 	stw	r2,-12(fp)
   if (tp == 0) 
 3239334:	e0bffd17 	ldw	r2,-12(fp)
 3239338:	1004c03a 	cmpne	r2,r2,zero
 323933c:	1000181e 	bne	r2,zero,32393a0 <tcp_attach+0x110>
   {
      int   nofd  =  so->so_state   &  SS_NOFDREF; /* XXX */
 3239340:	e0bffe17 	ldw	r2,-8(fp)
 3239344:	1080088b 	ldhu	r2,34(r2)
 3239348:	10bfffcc 	andi	r2,r2,65535
 323934c:	1080004c 	andi	r2,r2,1
 3239350:	e0bffa15 	stw	r2,-24(fp)

      so->so_state &= ~SS_NOFDREF;     /* don't free the socket yet */
 3239354:	e0bffe17 	ldw	r2,-8(fp)
 3239358:	10c0088b 	ldhu	r3,34(r2)
 323935c:	00bfff84 	movi	r2,-2
 3239360:	1884703a 	and	r2,r3,r2
 3239364:	1007883a 	mov	r3,r2
 3239368:	e0bffe17 	ldw	r2,-8(fp)
 323936c:	10c0088d 	sth	r3,34(r2)
      in_pcbdetach(inp);
 3239370:	e13ffc17 	ldw	r4,-16(fp)
 3239374:	32482780 	call	3248278 <in_pcbdetach>
      so->so_state |= nofd;
 3239378:	e0bffe17 	ldw	r2,-8(fp)
 323937c:	10c0088b 	ldhu	r3,34(r2)
 3239380:	e0bffa17 	ldw	r2,-24(fp)
 3239384:	1884b03a 	or	r2,r3,r2
 3239388:	1007883a 	mov	r3,r2
 323938c:	e0bffe17 	ldw	r2,-8(fp)
 3239390:	10c0088d 	sth	r3,34(r2)
      return (ENOBUFS);
 3239394:	00801a44 	movi	r2,105
 3239398:	e0bfff15 	stw	r2,-4(fp)
 323939c:	00000306 	br	32393ac <tcp_attach+0x11c>
   }
   tp->t_state = TCPS_CLOSED;
 32393a0:	e0bffd17 	ldw	r2,-12(fp)
 32393a4:	10000215 	stw	zero,8(r2)
   return (0);
 32393a8:	e03fff15 	stw	zero,-4(fp)
 32393ac:	e0bfff17 	ldw	r2,-4(fp)
}
 32393b0:	e037883a 	mov	sp,fp
 32393b4:	dfc00117 	ldw	ra,4(sp)
 32393b8:	df000017 	ldw	fp,0(sp)
 32393bc:	dec00204 	addi	sp,sp,8
 32393c0:	f800283a 	ret

032393c4 <tcp_disconnect>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_disconnect(struct tcpcb * tp)
{
 32393c4:	defffc04 	addi	sp,sp,-16
 32393c8:	dfc00315 	stw	ra,12(sp)
 32393cc:	df000215 	stw	fp,8(sp)
 32393d0:	df000204 	addi	fp,sp,8
 32393d4:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 32393d8:	e0bfff17 	ldw	r2,-4(fp)
 32393dc:	10800d17 	ldw	r2,52(r2)
 32393e0:	10800817 	ldw	r2,32(r2)
 32393e4:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_state < TCPS_ESTABLISHED)
 32393e8:	e0bfff17 	ldw	r2,-4(fp)
 32393ec:	10800217 	ldw	r2,8(r2)
 32393f0:	10800108 	cmpgei	r2,r2,4
 32393f4:	1000041e 	bne	r2,zero,3239408 <tcp_disconnect+0x44>
      tp = tcp_close(tp);
 32393f8:	e13fff17 	ldw	r4,-4(fp)
 32393fc:	32381c80 	call	32381c8 <tcp_close>
 3239400:	e0bfff15 	stw	r2,-4(fp)
 3239404:	00001e06 	br	3239480 <tcp_disconnect+0xbc>
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 3239408:	e0bffe17 	ldw	r2,-8(fp)
 323940c:	10800417 	ldw	r2,16(r2)
 3239410:	1080200c 	andi	r2,r2,128
 3239414:	1005003a 	cmpeq	r2,r2,zero
 3239418:	10000c1e 	bne	r2,zero,323944c <tcp_disconnect+0x88>
 323941c:	e0bffe17 	ldw	r2,-8(fp)
 3239420:	1080080b 	ldhu	r2,32(r2)
 3239424:	10bfffcc 	andi	r2,r2,65535
 3239428:	10a0001c 	xori	r2,r2,32768
 323942c:	10a00004 	addi	r2,r2,-32768
 3239430:	1004c03a 	cmpne	r2,r2,zero
 3239434:	1000051e 	bne	r2,zero,323944c <tcp_disconnect+0x88>
      tp = tcp_drop(tp, 0);
 3239438:	e13fff17 	ldw	r4,-4(fp)
 323943c:	000b883a 	mov	r5,zero
 3239440:	323811c0 	call	323811c <tcp_drop>
 3239444:	e0bfff15 	stw	r2,-4(fp)
{
   struct socket *   so =  tp->t_inpcb->inp_socket;

   if (tp->t_state < TCPS_ESTABLISHED)
      tp = tcp_close(tp);
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 3239448:	00000d06 	br	3239480 <tcp_disconnect+0xbc>
      tp = tcp_drop(tp, 0);
   else 
   {
      soisdisconnecting(so);
 323944c:	e13ffe17 	ldw	r4,-8(fp)
 3239450:	3231c000 	call	3231c00 <soisdisconnecting>
      sbflush(&so->so_rcv);
 3239454:	e0bffe17 	ldw	r2,-8(fp)
 3239458:	11000a04 	addi	r4,r2,40
 323945c:	32329ac0 	call	32329ac <sbflush>
      tp = tcp_usrclosed(tp);
 3239460:	e13fff17 	ldw	r4,-4(fp)
 3239464:	32394980 	call	3239498 <tcp_usrclosed>
 3239468:	e0bfff15 	stw	r2,-4(fp)
      if (tp)
 323946c:	e0bfff17 	ldw	r2,-4(fp)
 3239470:	1005003a 	cmpeq	r2,r2,zero
 3239474:	1000021e 	bne	r2,zero,3239480 <tcp_disconnect+0xbc>
         (void) tcp_output(tp);
 3239478:	e13fff17 	ldw	r4,-4(fp)
 323947c:	32366ac0 	call	32366ac <tcp_output>
   }
   return (tp);
 3239480:	e0bfff17 	ldw	r2,-4(fp)
}
 3239484:	e037883a 	mov	sp,fp
 3239488:	dfc00117 	ldw	ra,4(sp)
 323948c:	df000017 	ldw	fp,0(sp)
 3239490:	dec00204 	addi	sp,sp,8
 3239494:	f800283a 	ret

03239498 <tcp_usrclosed>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_usrclosed(struct tcpcb * tp)
{
 3239498:	defffc04 	addi	sp,sp,-16
 323949c:	dfc00315 	stw	ra,12(sp)
 32394a0:	df000215 	stw	fp,8(sp)
 32394a4:	df000204 	addi	fp,sp,8
 32394a8:	e13ffe15 	stw	r4,-8(fp)

   switch (tp->t_state) 
 32394ac:	e0bffe17 	ldw	r2,-8(fp)
 32394b0:	10800217 	ldw	r2,8(r2)
 32394b4:	e0bfff15 	stw	r2,-4(fp)
 32394b8:	e0ffff17 	ldw	r3,-4(fp)
 32394bc:	188001a8 	cmpgeui	r2,r3,6
 32394c0:	10001c1e 	bne	r2,zero,3239534 <tcp_usrclosed+0x9c>
 32394c4:	e13fff17 	ldw	r4,-4(fp)
 32394c8:	e13fff17 	ldw	r4,-4(fp)
 32394cc:	2105883a 	add	r2,r4,r4
 32394d0:	1087883a 	add	r3,r2,r2
 32394d4:	0080c934 	movhi	r2,804
 32394d8:	10a53a04 	addi	r2,r2,-27416
 32394dc:	1885883a 	add	r2,r3,r2
 32394e0:	10800017 	ldw	r2,0(r2)
 32394e4:	1000683a 	jmp	r2
 32394e8:	03239500 	call	323950 <OSCtxSw_SWITCH_PC+0x323910>
 32394ec:	03239500 	call	323950 <OSCtxSw_SWITCH_PC+0x323910>
 32394f0:	03239500 	call	323950 <OSCtxSw_SWITCH_PC+0x323910>
 32394f4:	03239518 	cmpnei	r12,zero,-29100
 32394f8:	03239518 	cmpnei	r12,zero,-29100
 32394fc:	03239528 	cmpgeui	r12,zero,36436
   {
   case TCPS_CLOSED:
   case TCPS_LISTEN:
   case TCPS_SYN_SENT:
      tp->t_state = TCPS_CLOSED;
 3239500:	e0bffe17 	ldw	r2,-8(fp)
 3239504:	10000215 	stw	zero,8(r2)
      tp = tcp_close(tp);
 3239508:	e13ffe17 	ldw	r4,-8(fp)
 323950c:	32381c80 	call	32381c8 <tcp_close>
 3239510:	e0bffe15 	stw	r2,-8(fp)
      break;
 3239514:	00000706 	br	3239534 <tcp_usrclosed+0x9c>

   case TCPS_SYN_RECEIVED:
   case TCPS_ESTABLISHED:
      tp->t_state = TCPS_FIN_WAIT_1;
 3239518:	e0fffe17 	ldw	r3,-8(fp)
 323951c:	00800184 	movi	r2,6
 3239520:	18800215 	stw	r2,8(r3)
      break;
 3239524:	00000306 	br	3239534 <tcp_usrclosed+0x9c>

   case TCPS_CLOSE_WAIT:
      tp->t_state = TCPS_LAST_ACK;
 3239528:	e0fffe17 	ldw	r3,-8(fp)
 323952c:	00800204 	movi	r2,8
 3239530:	18800215 	stw	r2,8(r3)
      break;
   }
   if (tp && tp->t_state >= TCPS_FIN_WAIT_2)
 3239534:	e0bffe17 	ldw	r2,-8(fp)
 3239538:	1005003a 	cmpeq	r2,r2,zero
 323953c:	1000081e 	bne	r2,zero,3239560 <tcp_usrclosed+0xc8>
 3239540:	e0bffe17 	ldw	r2,-8(fp)
 3239544:	10800217 	ldw	r2,8(r2)
 3239548:	10800250 	cmplti	r2,r2,9
 323954c:	1000041e 	bne	r2,zero,3239560 <tcp_usrclosed+0xc8>
      soisdisconnected(tp->t_inpcb->inp_socket);
 3239550:	e0bffe17 	ldw	r2,-8(fp)
 3239554:	10800d17 	ldw	r2,52(r2)
 3239558:	11000817 	ldw	r4,32(r2)
 323955c:	3231c8c0 	call	3231c8c <soisdisconnected>
   return (tp);
 3239560:	e0bffe17 	ldw	r2,-8(fp)
}
 3239564:	e037883a 	mov	sp,fp
 3239568:	dfc00117 	ldw	ra,4(sp)
 323956c:	df000017 	ldw	fp,0(sp)
 3239570:	dec00204 	addi	sp,sp,8
 3239574:	f800283a 	ret

03239578 <tcpinit>:
 * RETURNS: 0 if OK, else one of the ENP_ error codes
 */

int
tcpinit(void)
{
 3239578:	defffc04 	addi	sp,sp,-16
 323957c:	dfc00315 	stw	ra,12(sp)
 3239580:	df000215 	stw	fp,8(sp)
 3239584:	df000204 	addi	fp,sp,8
   tcp_sendspace = (TCP_MSS) * 2;
   tcp_recvspace = (TCP_MSS) * 2;
   TCPTV_MSL =    (4 * PR_SLOWHZ);     /* max seg lifetime default */
#endif

   e = nptcp_init();    /* call the NetPort init in nptcp.c */
 3239588:	322c6f00 	call	322c6f0 <nptcp_init>
 323958c:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 3239590:	e0bffe17 	ldw	r2,-8(fp)
 3239594:	1005003a 	cmpeq	r2,r2,zero
 3239598:	1000031e 	bne	r2,zero,32395a8 <tcpinit+0x30>
      return e;
 323959c:	e0bffe17 	ldw	r2,-8(fp)
 32395a0:	e0bfff15 	stw	r2,-4(fp)
 32395a4:	00000106 	br	32395ac <tcpinit+0x34>

   return 0;   /* good return */
 32395a8:	e03fff15 	stw	zero,-4(fp)
 32395ac:	e0bfff17 	ldw	r2,-4(fp)
}
 32395b0:	e037883a 	mov	sp,fp
 32395b4:	dfc00117 	ldw	ra,4(sp)
 32395b8:	df000017 	ldw	fp,0(sp)
 32395bc:	dec00204 	addi	sp,sp,8
 32395c0:	f800283a 	ret

032395c4 <udp_lookup>:
 * RETURNS: 
 */

UDPCONN
udp_lookup(struct socket * so)
{
 32395c4:	defffc04 	addi	sp,sp,-16
 32395c8:	df000315 	stw	fp,12(sp)
 32395cc:	df000304 	addi	fp,sp,12
 32395d0:	e13ffe15 	stw	r4,-8(fp)
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 32395d4:	0080c974 	movhi	r2,805
 32395d8:	10933504 	addi	r2,r2,19668
 32395dc:	10800017 	ldw	r2,0(r2)
 32395e0:	e0bffd15 	stw	r2,-12(fp)
 32395e4:	00000a06 	br	3239610 <udp_lookup+0x4c>
      if (tmp->u_data == (void*)so)
 32395e8:	e0bffd17 	ldw	r2,-12(fp)
 32395ec:	10c00617 	ldw	r3,24(r2)
 32395f0:	e0bffe17 	ldw	r2,-8(fp)
 32395f4:	1880031e 	bne	r3,r2,3239604 <udp_lookup+0x40>
      return (tmp);
 32395f8:	e0bffd17 	ldw	r2,-12(fp)
 32395fc:	e0bfff15 	stw	r2,-4(fp)
 3239600:	00000706 	br	3239620 <udp_lookup+0x5c>
UDPCONN
udp_lookup(struct socket * so)
{
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 3239604:	e0bffd17 	ldw	r2,-12(fp)
 3239608:	10800017 	ldw	r2,0(r2)
 323960c:	e0bffd15 	stw	r2,-12(fp)
 3239610:	e0bffd17 	ldw	r2,-12(fp)
 3239614:	1004c03a 	cmpne	r2,r2,zero
 3239618:	103ff31e 	bne	r2,zero,32395e8 <udp_lookup+0x24>
      if (tmp->u_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 323961c:	e03fff15 	stw	zero,-4(fp)
 3239620:	e0bfff17 	ldw	r2,-4(fp)
}
 3239624:	e037883a 	mov	sp,fp
 3239628:	df000017 	ldw	fp,0(sp)
 323962c:	dec00104 	addi	sp,sp,4
 3239630:	f800283a 	ret

03239634 <udp_soinput>:
 * RETURNS: 
 */

int
udp_soinput(PACKET pkt, void * so_ptr)
{
 3239634:	defff404 	addi	sp,sp,-48
 3239638:	dfc00b15 	stw	ra,44(sp)
 323963c:	df000a15 	stw	fp,40(sp)
 3239640:	df000a04 	addi	fp,sp,40
 3239644:	e13ffd15 	stw	r4,-12(fp)
 3239648:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 323964c:	e0bffe17 	ldw	r2,-8(fp)
 3239650:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;
   struct udp *   udpp;

   LOCK_NET_RESOURCE(NET_RESID); 
 3239654:	0009883a 	mov	r4,zero
 3239658:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 323965c:	e0bff717 	ldw	r2,-36(fp)
 3239660:	10c00a17 	ldw	r3,40(r2)
 3239664:	e0bffd17 	ldw	r2,-12(fp)
 3239668:	10800417 	ldw	r2,16(r2)
 323966c:	1887883a 	add	r3,r3,r2
 3239670:	e0bff717 	ldw	r2,-36(fp)
 3239674:	10800b17 	ldw	r2,44(r2)
 3239678:	18800536 	bltu	r3,r2,3239690 <udp_soinput+0x5c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 323967c:	0009883a 	mov	r4,zero
 3239680:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 3239684:	00801a44 	movi	r2,105
 3239688:	e0bfff15 	stw	r2,-4(fp)
 323968c:	00005106 	br	32397d4 <udp_soinput+0x1a0>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 3239690:	01000044 	movi	r4,1
 3239694:	000b883a 	mov	r5,zero
 3239698:	322bcf00 	call	322bcf0 <m_getnbuf>
 323969c:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 32396a0:	e0bff817 	ldw	r2,-32(fp)
 32396a4:	1004c03a 	cmpne	r2,r2,zero
 32396a8:	1000051e 	bne	r2,zero,32396c0 <udp_soinput+0x8c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 32396ac:	0009883a 	mov	r4,zero
 32396b0:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 32396b4:	00801a44 	movi	r2,105
 32396b8:	e0bfff15 	stw	r2,-4(fp)
 32396bc:	00004506 	br	32397d4 <udp_soinput+0x1a0>
   }

   /* set data mbuf to point to start of UDP data */
   m_in->pkt = pkt;
 32396c0:	e0fff817 	ldw	r3,-32(fp)
 32396c4:	e0bffd17 	ldw	r2,-12(fp)
 32396c8:	18800115 	stw	r2,4(r3)
   m_in->m_data = pkt->nb_prot;
 32396cc:	e0bffd17 	ldw	r2,-12(fp)
 32396d0:	10c00317 	ldw	r3,12(r2)
 32396d4:	e0bff817 	ldw	r2,-32(fp)
 32396d8:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 32396dc:	e0bffd17 	ldw	r2,-12(fp)
 32396e0:	10c00417 	ldw	r3,16(r2)
 32396e4:	e0bff817 	ldw	r2,-32(fp)
 32396e8:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;
 32396ec:	e0bffd17 	ldw	r2,-12(fp)
 32396f0:	10c00117 	ldw	r3,4(r2)
 32396f4:	e0bff817 	ldw	r2,-32(fp)
 32396f8:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 32396fc:	e0bffd17 	ldw	r2,-12(fp)
 3239700:	10c00217 	ldw	r3,8(r2)
 3239704:	e0bff817 	ldw	r2,-32(fp)
 3239708:	10c00515 	stw	r3,20(r2)

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 323970c:	e0bffd17 	ldw	r2,-12(fp)
 3239710:	10800717 	ldw	r2,28(r2)
 3239714:	e0bffa15 	stw	r2,-24(fp)
   udpp = (struct udp *)(pkt->nb_prot - sizeof(struct udp));
 3239718:	e0bffd17 	ldw	r2,-12(fp)
 323971c:	10800317 	ldw	r2,12(r2)
 3239720:	10bffe04 	addi	r2,r2,-8
 3239724:	e0bff615 	stw	r2,-40(fp)
   sin.sin_port = htons(udpp->ud_srcp);
 3239728:	e0bff617 	ldw	r2,-40(fp)
 323972c:	1080000b 	ldhu	r2,0(r2)
 3239730:	10bfffcc 	andi	r2,r2,65535
 3239734:	1004d23a 	srli	r2,r2,8
 3239738:	10803fcc 	andi	r2,r2,255
 323973c:	1009883a 	mov	r4,r2
 3239740:	e0bff617 	ldw	r2,-40(fp)
 3239744:	1080000b 	ldhu	r2,0(r2)
 3239748:	10bfffcc 	andi	r2,r2,65535
 323974c:	1004923a 	slli	r2,r2,8
 3239750:	1007883a 	mov	r3,r2
 3239754:	00bfc004 	movi	r2,-256
 3239758:	1884703a 	and	r2,r3,r2
 323975c:	2084b03a 	or	r2,r4,r2
 3239760:	e0bff98d 	sth	r2,-26(fp)
   sin.sin_family = AF_INET;
 3239764:	00800084 	movi	r2,2
 3239768:	e0bff90d 	sth	r2,-28(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 323976c:	e0bff717 	ldw	r2,-36(fp)
 3239770:	11000a04 	addi	r4,r2,40
 3239774:	e17ff904 	addi	r5,fp,-28
 3239778:	e1bff817 	ldw	r6,-32(fp)
 323977c:	32325bc0 	call	32325bc <sbappendaddr>
 3239780:	1004c03a 	cmpne	r2,r2,zero
 3239784:	1000091e 	bne	r2,zero,32397ac <udp_soinput+0x178>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       */
      m_in->pkt = NULL;
 3239788:	e0bff817 	ldw	r2,-32(fp)
 323978c:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 3239790:	e13ff817 	ldw	r4,-32(fp)
 3239794:	322be980 	call	322be98 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 3239798:	0009883a 	mov	r4,zero
 323979c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 32397a0:	00801a44 	movi	r2,105
 32397a4:	e0bfff15 	stw	r2,-4(fp)
 32397a8:	00000a06 	br	32397d4 <udp_soinput+0x1a0>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 32397ac:	e0bff717 	ldw	r2,-36(fp)
 32397b0:	11000a04 	addi	r4,r2,40
 32397b4:	3226c640 	call	3226c64 <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 32397b8:	e0bff717 	ldw	r2,-36(fp)
 32397bc:	11400a04 	addi	r5,r2,40
 32397c0:	e13ff717 	ldw	r4,-36(fp)
 32397c4:	32322700 	call	3232270 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 32397c8:	0009883a 	mov	r4,zero
 32397cc:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   return 0;
 32397d0:	e03fff15 	stw	zero,-4(fp)
 32397d4:	e0bfff17 	ldw	r2,-4(fp)
}
 32397d8:	e037883a 	mov	sp,fp
 32397dc:	dfc00117 	ldw	ra,4(sp)
 32397e0:	df000017 	ldw	fp,0(sp)
 32397e4:	dec00204 	addi	sp,sp,8
 32397e8:	f800283a 	ret

032397ec <udp_usrreq>:

int
udp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 32397ec:	defff704 	addi	sp,sp,-36
 32397f0:	dfc00815 	stw	ra,32(sp)
 32397f4:	df000715 	stw	fp,28(sp)
 32397f8:	df000704 	addi	fp,sp,28
 32397fc:	e13ffc15 	stw	r4,-16(fp)
 3239800:	e17ffd15 	stw	r5,-12(fp)
 3239804:	e1bffe15 	stw	r6,-8(fp)
   UDPCONN udpconn = (UDPCONN)NULL;
 3239808:	e03ffb15 	stw	zero,-20(fp)
   int   req;

   req = so->so_req;    /* get request from socket struct */
 323980c:	e0bffc17 	ldw	r2,-16(fp)
 3239810:	10800717 	ldw	r2,28(r2)
 3239814:	e0bffa15 	stw	r2,-24(fp)

   switch (req) 
 3239818:	e0bffa17 	ldw	r2,-24(fp)
 323981c:	10800468 	cmpgeui	r2,r2,17
 3239820:	10008b1e 	bne	r2,zero,3239a50 <udp_usrreq+0x264>
 3239824:	e0bffa17 	ldw	r2,-24(fp)
 3239828:	1085883a 	add	r2,r2,r2
 323982c:	1087883a 	add	r3,r2,r2
 3239830:	0080c934 	movhi	r2,804
 3239834:	10a61104 	addi	r2,r2,-26556
 3239838:	1885883a 	add	r2,r3,r2
 323983c:	10800017 	ldw	r2,0(r2)
 3239840:	1000683a 	jmp	r2
 3239844:	03239888 	cmpgei	r12,zero,-29086
 3239848:	03239910 	cmplti	r12,zero,-29084
 323984c:	03239954 	movui	r12,36453
 3239850:	03239a50 	cmplti	r12,zero,-29079
 3239854:	03239954 	movui	r12,36453
 3239858:	03239a50 	cmplti	r12,zero,-29079
 323985c:	03239a44 	movi	r12,-29079
 3239860:	03239a50 	cmplti	r12,zero,-29079
 3239864:	03239a44 	movi	r12,-29079
 3239868:	032399a4 	muli	r12,zero,-29082
 323986c:	03239a50 	cmplti	r12,zero,-29079
 3239870:	03239a50 	cmplti	r12,zero,-29079
 3239874:	03239a50 	cmplti	r12,zero,-29079
 3239878:	03239a50 	cmplti	r12,zero,-29079
 323987c:	03239a50 	cmplti	r12,zero,-29079
 3239880:	032399f4 	movhi	r12,36455
 3239884:	032399f4 	movhi	r12,36455
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = udp_maxalloc();
 3239888:	32455b40 	call	32455b4 <udp_maxalloc>
 323988c:	1007883a 	mov	r3,r2
 3239890:	e0bffc17 	ldw	r2,-16(fp)
 3239894:	10c01315 	stw	r3,76(r2)
 3239898:	e0bffc17 	ldw	r2,-16(fp)
 323989c:	10c01317 	ldw	r3,76(r2)
 32398a0:	e0bffc17 	ldw	r2,-16(fp)
 32398a4:	10c00b15 	stw	r3,44(r2)

#ifdef IP_V4
      /* make a NetPort UDP connection */
      /* unlock the net resource; UDP will immediatly re-lock it */
      if (so->so_domain  == AF_INET){
 32398a8:	e0bffc17 	ldw	r2,-16(fp)
 32398ac:	10800517 	ldw	r2,20(r2)
 32398b0:	10800098 	cmpnei	r2,r2,2
 32398b4:	10000e1e 	bne	r2,zero,32398f0 <udp_usrreq+0x104>
        UNLOCK_NET_RESOURCE(NET_RESID);
 32398b8:	0009883a 	mov	r4,zero
 32398bc:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
        udpconn = udp_open(0L, 0, udp_socket(), udp_soinput, so);
 32398c0:	32454240 	call	3245424 <udp_socket>
 32398c4:	11bfffcc 	andi	r6,r2,65535
 32398c8:	e0bffc17 	ldw	r2,-16(fp)
 32398cc:	d8800015 	stw	r2,0(sp)
 32398d0:	0009883a 	mov	r4,zero
 32398d4:	000b883a 	mov	r5,zero
 32398d8:	01c0c934 	movhi	r7,804
 32398dc:	39e58d04 	addi	r7,r7,-27084
 32398e0:	322aa400 	call	322aa40 <udp_open>
 32398e4:	e0bffb15 	stw	r2,-20(fp)
        LOCK_NET_RESOURCE(NET_RESID);
 32398e8:	0009883a 	mov	r4,zero
 32398ec:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
        UNLOCK_NET_RESOURCE(NET_RESID);
        udpconn = udp6_open(0L, 0, udp_socket(), udp6_soinput, so);
        LOCK_NET_RESOURCE(NET_RESID);
      }
#endif
      if (!udpconn)
 32398f0:	e0bffb17 	ldw	r2,-20(fp)
 32398f4:	1004c03a 	cmpne	r2,r2,zero
 32398f8:	1000031e 	bne	r2,zero,3239908 <udp_usrreq+0x11c>
         return(EINVAL);
 32398fc:	00800584 	movi	r2,22
 3239900:	e0bfff15 	stw	r2,-4(fp)
 3239904:	00005406 	br	3239a58 <udp_usrreq+0x26c>
      return 0;
 3239908:	e03fff15 	stw	zero,-4(fp)
 323990c:	00005206 	br	3239a58 <udp_usrreq+0x26c>
   case PRU_DETACH:
      /* delete the NetPort UDP connection */
      udpconn = udp_lookup(so);
 3239910:	e13ffc17 	ldw	r4,-16(fp)
 3239914:	32395c40 	call	32395c4 <udp_lookup>
 3239918:	e0bffb15 	stw	r2,-20(fp)
      if (!udpconn)
 323991c:	e0bffb17 	ldw	r2,-20(fp)
 3239920:	1004c03a 	cmpne	r2,r2,zero
 3239924:	1000031e 	bne	r2,zero,3239934 <udp_usrreq+0x148>
         return(EINVAL);
 3239928:	00800584 	movi	r2,22
 323992c:	e0bfff15 	stw	r2,-4(fp)
 3239930:	00004906 	br	3239a58 <udp_usrreq+0x26c>
      /* unlock the net resource; UDP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 3239934:	0009883a 	mov	r4,zero
 3239938:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      udp_close(udpconn);
 323993c:	e13ffb17 	ldw	r4,-20(fp)
 3239940:	322ac780 	call	322ac78 <udp_close>
      LOCK_NET_RESOURCE(NET_RESID);
 3239944:	0009883a 	mov	r4,zero
 3239948:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      return 0;
 323994c:	e03fff15 	stw	zero,-4(fp)
 3239950:	00004106 	br	3239a58 <udp_usrreq+0x26c>
   case PRU_CONNECT:
      /* Install foreign port for UDP, making a virtual connection */
      /* fall to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 3239954:	e0bffe17 	ldw	r2,-8(fp)
 3239958:	1004c03a 	cmpne	r2,r2,zero
 323995c:	1000031e 	bne	r2,zero,323996c <udp_usrreq+0x180>
         return(EINVAL);
 3239960:	00800584 	movi	r2,22
 3239964:	e0bfff15 	stw	r2,-4(fp)
 3239968:	00003b06 	br	3239a58 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 323996c:	e0bffc17 	ldw	r2,-16(fp)
 3239970:	10800517 	ldw	r2,20(r2)
 3239974:	10800098 	cmpnei	r2,r2,2
 3239978:	1000061e 	bne	r2,zero,3239994 <udp_usrreq+0x1a8>
        return udp4_sockbind(so, nam, req );
 323997c:	e13ffc17 	ldw	r4,-16(fp)
 3239980:	e17ffe17 	ldw	r5,-8(fp)
 3239984:	e1bffa17 	ldw	r6,-24(fp)
 3239988:	3239a700 	call	3239a70 <udp4_sockbind>
 323998c:	e0bfff15 	stw	r2,-4(fp)
 3239990:	00003106 	br	3239a58 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockbind(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 3239994:	322aef00 	call	322aef0 <dtrap>
      return EINVAL;
 3239998:	00800584 	movi	r2,22
 323999c:	e0bfff15 	stw	r2,-4(fp)
 32399a0:	00002d06 	br	3239a58 <udp_usrreq+0x26c>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 32399a4:	e0bffd17 	ldw	r2,-12(fp)
 32399a8:	1004c03a 	cmpne	r2,r2,zero
 32399ac:	1000031e 	bne	r2,zero,32399bc <udp_usrreq+0x1d0>
         return(EINVAL);
 32399b0:	00800584 	movi	r2,22
 32399b4:	e0bfff15 	stw	r2,-4(fp)
 32399b8:	00002706 	br	3239a58 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 32399bc:	e0bffc17 	ldw	r2,-16(fp)
 32399c0:	10800517 	ldw	r2,20(r2)
 32399c4:	10800098 	cmpnei	r2,r2,2
 32399c8:	1000061e 	bne	r2,zero,32399e4 <udp_usrreq+0x1f8>
        return udp4_socksend(so, m, nam );
 32399cc:	e13ffc17 	ldw	r4,-16(fp)
 32399d0:	e17ffd17 	ldw	r5,-12(fp)
 32399d4:	e1bffe17 	ldw	r6,-8(fp)
 32399d8:	3239dac0 	call	3239dac <udp4_socksend>
 32399dc:	e0bfff15 	stw	r2,-4(fp)
 32399e0:	00001d06 	br	3239a58 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_socksend(so, m, nam);
      }
#endif
      dtrap();   /* invalid address */
 32399e4:	322aef00 	call	322aef0 <dtrap>
      return EINVAL;
 32399e8:	00800584 	movi	r2,22
 32399ec:	e0bfff15 	stw	r2,-4(fp)
 32399f0:	00001906 	br	3239a58 <udp_usrreq+0x26c>

   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 32399f4:	e0bffe17 	ldw	r2,-8(fp)
 32399f8:	1004c03a 	cmpne	r2,r2,zero
 32399fc:	1000031e 	bne	r2,zero,3239a0c <udp_usrreq+0x220>
         return(EINVAL);
 3239a00:	00800584 	movi	r2,22
 3239a04:	e0bfff15 	stw	r2,-4(fp)
 3239a08:	00001306 	br	3239a58 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 3239a0c:	e0bffc17 	ldw	r2,-16(fp)
 3239a10:	10800517 	ldw	r2,20(r2)
 3239a14:	10800098 	cmpnei	r2,r2,2
 3239a18:	1000061e 	bne	r2,zero,3239a34 <udp_usrreq+0x248>
        return udp4_sockaddr(so, nam, req );
 3239a1c:	e13ffc17 	ldw	r4,-16(fp)
 3239a20:	e17ffe17 	ldw	r5,-8(fp)
 3239a24:	e1bffa17 	ldw	r6,-24(fp)
 3239a28:	323a1880 	call	323a188 <udp4_sockaddr>
 3239a2c:	e0bfff15 	stw	r2,-4(fp)
 3239a30:	00000906 	br	3239a58 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockaddr(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 3239a34:	322aef00 	call	322aef0 <dtrap>
      return EINVAL;
 3239a38:	00800584 	movi	r2,22
 3239a3c:	e0bfff15 	stw	r2,-4(fp)
 3239a40:	00000506 	br	3239a58 <udp_usrreq+0x26c>

   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 3239a44:	322aef00 	call	322aef0 <dtrap>
      return 0;
 3239a48:	e03fff15 	stw	zero,-4(fp)
 3239a4c:	00000206 	br	3239a58 <udp_usrreq+0x26c>
   case PRU_LISTEN:     /* don't support these for UDP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 3239a50:	008017c4 	movi	r2,95
 3239a54:	e0bfff15 	stw	r2,-4(fp)
 3239a58:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 3239a5c:	e037883a 	mov	sp,fp
 3239a60:	dfc00117 	ldw	ra,4(sp)
 3239a64:	df000017 	ldw	fp,0(sp)
 3239a68:	dec00204 	addi	sp,sp,8
 3239a6c:	f800283a 	ret

03239a70 <udp4_sockbind>:

#ifdef IP_V4
int udp4_sockbind(struct socket *so, struct mbuf *nam, int req ) 
{
 3239a70:	defff304 	addi	sp,sp,-52
 3239a74:	dfc00c15 	stw	ra,48(sp)
 3239a78:	df000b15 	stw	fp,44(sp)
 3239a7c:	df000b04 	addi	fp,sp,44
 3239a80:	e13ffc15 	stw	r4,-16(fp)
 3239a84:	e17ffd15 	stw	r5,-12(fp)
 3239a88:	e1bffe15 	stw	r6,-8(fp)
  u_short  lport;   /* local port (local byte order) */
  ip_addr fhost; /* host to send to/recv from (network byte order) */
  ip_addr lhost; /* local IP address to bind to (network byte order) */
  NET ifp;

  sin = mtod(nam, struct sockaddr_in *);
 3239a8c:	e0bffd17 	ldw	r2,-12(fp)
 3239a90:	10800317 	ldw	r2,12(r2)
 3239a94:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 3239a98:	e0bffb17 	ldw	r2,-20(fp)
 3239a9c:	1004c03a 	cmpne	r2,r2,zero
 3239aa0:	1000031e 	bne	r2,zero,3239ab0 <udp4_sockbind+0x40>
    return(EINVAL);
 3239aa4:	00800584 	movi	r2,22
 3239aa8:	e0bfff15 	stw	r2,-4(fp)
 3239aac:	0000b906 	br	3239d94 <udp4_sockbind+0x324>
  if (nam->m_len != sizeof (*sin))
 3239ab0:	e0bffd17 	ldw	r2,-12(fp)
 3239ab4:	10800217 	ldw	r2,8(r2)
 3239ab8:	10800420 	cmpeqi	r2,r2,16
 3239abc:	1000031e 	bne	r2,zero,3239acc <udp4_sockbind+0x5c>
    return(EINVAL);
 3239ac0:	00800584 	movi	r2,22
 3239ac4:	e0bfff15 	stw	r2,-4(fp)
 3239ac8:	0000b206 	br	3239d94 <udp4_sockbind+0x324>
  udpconn = udp_lookup(so);
 3239acc:	e13ffc17 	ldw	r4,-16(fp)
 3239ad0:	32395c40 	call	32395c4 <udp_lookup>
 3239ad4:	e0bffa15 	stw	r2,-24(fp)
  if (!udpconn)
 3239ad8:	e0bffa17 	ldw	r2,-24(fp)
 3239adc:	1004c03a 	cmpne	r2,r2,zero
 3239ae0:	1000031e 	bne	r2,zero,3239af0 <udp4_sockbind+0x80>
     return(EINVAL);
 3239ae4:	00800584 	movi	r2,22
 3239ae8:	e0bfff15 	stw	r2,-4(fp)
 3239aec:	0000a906 	br	3239d94 <udp4_sockbind+0x324>
  if (req == PRU_BIND)
 3239af0:	e0bffe17 	ldw	r2,-8(fp)
 3239af4:	10800098 	cmpnei	r2,r2,2
 3239af8:	1000601e 	bne	r2,zero,3239c7c <udp4_sockbind+0x20c>
     * if the caller-supplied port is 0, try to get
     * the port from the UDP endpoint, or pick a new
     * unique port; else, use the caller-supplied
     * port
     */
    if (sin->sin_port == 0)
 3239afc:	e0bffb17 	ldw	r2,-20(fp)
 3239b00:	1080008b 	ldhu	r2,2(r2)
 3239b04:	10bfffcc 	andi	r2,r2,65535
 3239b08:	1004c03a 	cmpne	r2,r2,zero
 3239b0c:	10000c1e 	bne	r2,zero,3239b40 <udp4_sockbind+0xd0>
    {
      if (udpconn->u_lport != 0)
 3239b10:	e0bffa17 	ldw	r2,-24(fp)
 3239b14:	1080018b 	ldhu	r2,6(r2)
 3239b18:	10bfffcc 	andi	r2,r2,65535
 3239b1c:	1005003a 	cmpeq	r2,r2,zero
 3239b20:	1000041e 	bne	r2,zero,3239b34 <udp4_sockbind+0xc4>
        lport = udpconn->u_lport;
 3239b24:	e0bffa17 	ldw	r2,-24(fp)
 3239b28:	1080018b 	ldhu	r2,6(r2)
 3239b2c:	e0bff80d 	sth	r2,-32(fp)
 3239b30:	00001206 	br	3239b7c <udp4_sockbind+0x10c>
      else
        lport = udp_socket();
 3239b34:	32454240 	call	3245424 <udp_socket>
 3239b38:	e0bff80d 	sth	r2,-32(fp)
 3239b3c:	00000f06 	br	3239b7c <udp4_sockbind+0x10c>
    }
    else
    {
      lport = ntohs(sin->sin_port);
 3239b40:	e0bffb17 	ldw	r2,-20(fp)
 3239b44:	1080008b 	ldhu	r2,2(r2)
 3239b48:	10bfffcc 	andi	r2,r2,65535
 3239b4c:	1004d23a 	srli	r2,r2,8
 3239b50:	10803fcc 	andi	r2,r2,255
 3239b54:	1009883a 	mov	r4,r2
 3239b58:	e0bffb17 	ldw	r2,-20(fp)
 3239b5c:	1080008b 	ldhu	r2,2(r2)
 3239b60:	10bfffcc 	andi	r2,r2,65535
 3239b64:	1004923a 	slli	r2,r2,8
 3239b68:	1007883a 	mov	r3,r2
 3239b6c:	00bfc004 	movi	r2,-256
 3239b70:	1884703a 	and	r2,r3,r2
 3239b74:	2084b03a 	or	r2,r4,r2
 3239b78:	e0bff80d 	sth	r2,-32(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * don't bind to a specific address; else, 
     * make sure the caller-supplied address is
     * an interface IP address and if so, bind to that
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 3239b7c:	e0bffb17 	ldw	r2,-20(fp)
 3239b80:	10800117 	ldw	r2,4(r2)
 3239b84:	1004c03a 	cmpne	r2,r2,zero
 3239b88:	1000021e 	bne	r2,zero,3239b94 <udp4_sockbind+0x124>
    {
      lhost = 0L;
 3239b8c:	e03ff615 	stw	zero,-40(fp)
 3239b90:	00001806 	br	3239bf4 <udp4_sockbind+0x184>
    }
    else
    {
      lhost = sin->sin_addr.s_addr;
 3239b94:	e0bffb17 	ldw	r2,-20(fp)
 3239b98:	10800117 	ldw	r2,4(r2)
 3239b9c:	e0bff615 	stw	r2,-40(fp)
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3239ba0:	0080c9b4 	movhi	r2,806
 3239ba4:	10b54604 	addi	r2,r2,-10984
 3239ba8:	10800017 	ldw	r2,0(r2)
 3239bac:	e0bff515 	stw	r2,-44(fp)
 3239bb0:	00000706 	br	3239bd0 <udp4_sockbind+0x160>
        if (ifp->n_ipaddr == lhost)
 3239bb4:	e0bff517 	ldw	r2,-44(fp)
 3239bb8:	10c00a17 	ldw	r3,40(r2)
 3239bbc:	e0bff617 	ldw	r2,-40(fp)
 3239bc0:	18800626 	beq	r3,r2,3239bdc <udp4_sockbind+0x16c>
    else
    {
      lhost = sin->sin_addr.s_addr;
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3239bc4:	e0bff517 	ldw	r2,-44(fp)
 3239bc8:	10800017 	ldw	r2,0(r2)
 3239bcc:	e0bff515 	stw	r2,-44(fp)
 3239bd0:	e0bff517 	ldw	r2,-44(fp)
 3239bd4:	1004c03a 	cmpne	r2,r2,zero
 3239bd8:	103ff61e 	bne	r2,zero,3239bb4 <udp4_sockbind+0x144>
        if (ifp->n_ipaddr == lhost)
          break;
      if (ifp == NULL)
 3239bdc:	e0bff517 	ldw	r2,-44(fp)
 3239be0:	1004c03a 	cmpne	r2,r2,zero
 3239be4:	1000031e 	bne	r2,zero,3239bf4 <udp4_sockbind+0x184>
        return(EADDRNOTAVAIL);
 3239be8:	00801f44 	movi	r2,125
 3239bec:	e0bfff15 	stw	r2,-4(fp)
 3239bf0:	00006806 	br	3239d94 <udp4_sockbind+0x324>
    }

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
 3239bf4:	e0bffc17 	ldw	r2,-16(fp)
 3239bf8:	10800417 	ldw	r2,16(r2)
 3239bfc:	1080010c 	andi	r2,r2,4
 3239c00:	1004c03a 	cmpne	r2,r2,zero
 3239c04:	1000161e 	bne	r2,zero,3239c60 <udp4_sockbind+0x1f0>
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 3239c08:	0080c974 	movhi	r2,805
 3239c0c:	10933504 	addi	r2,r2,19668
 3239c10:	10800017 	ldw	r2,0(r2)
 3239c14:	e0bff915 	stw	r2,-28(fp)
 3239c18:	00000e06 	br	3239c54 <udp4_sockbind+0x1e4>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
 3239c1c:	e0bff917 	ldw	r2,-28(fp)
 3239c20:	1080018b 	ldhu	r2,6(r2)
 3239c24:	10ffffcc 	andi	r3,r2,65535
 3239c28:	e0bff80b 	ldhu	r2,-32(fp)
 3239c2c:	1880061e 	bne	r3,r2,3239c48 <udp4_sockbind+0x1d8>
 3239c30:	e0fff917 	ldw	r3,-28(fp)
 3239c34:	e0bffa17 	ldw	r2,-24(fp)
 3239c38:	18800326 	beq	r3,r2,3239c48 <udp4_sockbind+0x1d8>
          return(EADDRINUSE);
 3239c3c:	00801c04 	movi	r2,112
 3239c40:	e0bfff15 	stw	r2,-4(fp)
 3239c44:	00005306 	br	3239d94 <udp4_sockbind+0x324>

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 3239c48:	e0bff917 	ldw	r2,-28(fp)
 3239c4c:	10800017 	ldw	r2,0(r2)
 3239c50:	e0bff915 	stw	r2,-28(fp)
 3239c54:	e0bff917 	ldw	r2,-28(fp)
 3239c58:	1004c03a 	cmpne	r2,r2,zero
 3239c5c:	103fef1e 	bne	r2,zero,3239c1c <udp4_sockbind+0x1ac>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
          return(EADDRINUSE);
    /* bind the UDP endpoint */
    udpconn->u_lport = lport;
 3239c60:	e0fffa17 	ldw	r3,-24(fp)
 3239c64:	e0bff80b 	ldhu	r2,-32(fp)
 3239c68:	1880018d 	sth	r2,6(r3)
    udpconn->u_lhost = lhost;
 3239c6c:	e0fffa17 	ldw	r3,-24(fp)
 3239c70:	e0bff617 	ldw	r2,-40(fp)
 3239c74:	18800315 	stw	r2,12(r3)
 3239c78:	00004506 	br	3239d90 <udp4_sockbind+0x320>
  else /* PRU_CONNECT */
  {
    /* connect the socket to a remote IP address and
     * UDP port.
     */
    fport = ntohs(sin->sin_port);
 3239c7c:	e0bffb17 	ldw	r2,-20(fp)
 3239c80:	1080008b 	ldhu	r2,2(r2)
 3239c84:	10bfffcc 	andi	r2,r2,65535
 3239c88:	1004d23a 	srli	r2,r2,8
 3239c8c:	10803fcc 	andi	r2,r2,255
 3239c90:	1009883a 	mov	r4,r2
 3239c94:	e0bffb17 	ldw	r2,-20(fp)
 3239c98:	1080008b 	ldhu	r2,2(r2)
 3239c9c:	10bfffcc 	andi	r2,r2,65535
 3239ca0:	1004923a 	slli	r2,r2,8
 3239ca4:	1007883a 	mov	r3,r2
 3239ca8:	00bfc004 	movi	r2,-256
 3239cac:	1884703a 	and	r2,r3,r2
 3239cb0:	2084b03a 	or	r2,r4,r2
 3239cb4:	e0bff88d 	sth	r2,-30(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * use the wildcard address; else, use the caller-
     * supplied address
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 3239cb8:	e0bffb17 	ldw	r2,-20(fp)
 3239cbc:	10800117 	ldw	r2,4(r2)
 3239cc0:	1004c03a 	cmpne	r2,r2,zero
 3239cc4:	1000021e 	bne	r2,zero,3239cd0 <udp4_sockbind+0x260>
      fhost = 0L;
 3239cc8:	e03ff715 	stw	zero,-36(fp)
 3239ccc:	00000306 	br	3239cdc <udp4_sockbind+0x26c>
    else
      fhost = sin->sin_addr.s_addr;
 3239cd0:	e0bffb17 	ldw	r2,-20(fp)
 3239cd4:	10800117 	ldw	r2,4(r2)
 3239cd8:	e0bff715 	stw	r2,-36(fp)
    /* prepare to bind the socket to the appropriate 
     * local interface address for the to-be-connected 
     * peer
     */
    lhost = ip_mymach(fhost);
 3239cdc:	e13ff717 	ldw	r4,-36(fp)
 3239ce0:	32404f00 	call	32404f0 <ip_mymach>
 3239ce4:	e0bff615 	stw	r2,-40(fp)
    if (lhost == 0)
 3239ce8:	e0bff617 	ldw	r2,-40(fp)
 3239cec:	1004c03a 	cmpne	r2,r2,zero
 3239cf0:	1000031e 	bne	r2,zero,3239d00 <udp4_sockbind+0x290>
      return(ENETUNREACH);
 3239cf4:	00801c84 	movi	r2,114
 3239cf8:	e0bfff15 	stw	r2,-4(fp)
 3239cfc:	00002506 	br	3239d94 <udp4_sockbind+0x324>
    /* if the socket hasn't been bound to a local
     * port yet, do so now
     */
    lport = udpconn->u_lport;
 3239d00:	e0bffa17 	ldw	r2,-24(fp)
 3239d04:	1080018b 	ldhu	r2,6(r2)
 3239d08:	e0bff80d 	sth	r2,-32(fp)
    if (lport == 0)
 3239d0c:	e0bff80b 	ldhu	r2,-32(fp)
 3239d10:	1004c03a 	cmpne	r2,r2,zero
 3239d14:	1000021e 	bne	r2,zero,3239d20 <udp4_sockbind+0x2b0>
      lport = udp_socket();
 3239d18:	32454240 	call	3245424 <udp_socket>
 3239d1c:	e0bff80d 	sth	r2,-32(fp)
    /* bind and connect the UDP endpoint */
    udpconn->u_lhost = lhost;
 3239d20:	e0fffa17 	ldw	r3,-24(fp)
 3239d24:	e0bff617 	ldw	r2,-40(fp)
 3239d28:	18800315 	stw	r2,12(r3)
    udpconn->u_lport = lport;
 3239d2c:	e0fffa17 	ldw	r3,-24(fp)
 3239d30:	e0bff80b 	ldhu	r2,-32(fp)
 3239d34:	1880018d 	sth	r2,6(r3)
    udpconn->u_fhost = fhost;
 3239d38:	e0fffa17 	ldw	r3,-24(fp)
 3239d3c:	e0bff717 	ldw	r2,-36(fp)
 3239d40:	18800415 	stw	r2,16(r3)
    udpconn->u_fport = fport;
 3239d44:	e0fffa17 	ldw	r3,-24(fp)
 3239d48:	e0bff88b 	ldhu	r2,-30(fp)
 3239d4c:	1880020d 	sth	r2,8(r3)
    /* mark the socket as connected */
    so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 3239d50:	e0bffc17 	ldw	r2,-16(fp)
 3239d54:	10c0088b 	ldhu	r3,34(r2)
 3239d58:	00bffcc4 	movi	r2,-13
 3239d5c:	1884703a 	and	r2,r3,r2
 3239d60:	1007883a 	mov	r3,r2
 3239d64:	e0bffc17 	ldw	r2,-16(fp)
 3239d68:	10c0088d 	sth	r3,34(r2)
    so->so_state |= SS_ISCONNECTED;
 3239d6c:	e0bffc17 	ldw	r2,-16(fp)
 3239d70:	1080088b 	ldhu	r2,34(r2)
 3239d74:	10800094 	ori	r2,r2,2
 3239d78:	1007883a 	mov	r3,r2
 3239d7c:	e0bffc17 	ldw	r2,-16(fp)
 3239d80:	10c0088d 	sth	r3,34(r2)
    /* since socket was in listen state, packets may be queued */
    sbflush(&so->so_rcv);   /* dump these now */
 3239d84:	e0bffc17 	ldw	r2,-16(fp)
 3239d88:	11000a04 	addi	r4,r2,40
 3239d8c:	32329ac0 	call	32329ac <sbflush>
  }
  return 0;
 3239d90:	e03fff15 	stw	zero,-4(fp)
 3239d94:	e0bfff17 	ldw	r2,-4(fp)
}
 3239d98:	e037883a 	mov	sp,fp
 3239d9c:	dfc00117 	ldw	ra,4(sp)
 3239da0:	df000017 	ldw	fp,0(sp)
 3239da4:	dec00204 	addi	sp,sp,8
 3239da8:	f800283a 	ret

03239dac <udp4_socksend>:

int udp4_socksend(struct socket *so, struct mbuf *m, 
		struct mbuf *nam ) 
{
 3239dac:	defff204 	addi	sp,sp,-56
 3239db0:	dfc00d15 	stw	ra,52(sp)
 3239db4:	df000c15 	stw	fp,48(sp)
 3239db8:	dc000b15 	stw	r16,44(sp)
 3239dbc:	df000b04 	addi	fp,sp,44
 3239dc0:	e13ffc15 	stw	r4,-16(fp)
 3239dc4:	e17ffd15 	stw	r5,-12(fp)
 3239dc8:	e1bffe15 	stw	r6,-8(fp)
  PACKET pkt;
#ifdef MULTI_HOMED
  NET ifp;
#endif

  udpconn = udp_lookup(so);
 3239dcc:	e13ffc17 	ldw	r4,-16(fp)
 3239dd0:	32395c40 	call	32395c4 <udp_lookup>
 3239dd4:	e0bff915 	stw	r2,-28(fp)
  if (!udpconn)
 3239dd8:	e0bff917 	ldw	r2,-28(fp)
 3239ddc:	1004c03a 	cmpne	r2,r2,zero
 3239de0:	1000051e 	bne	r2,zero,3239df8 <udp4_socksend+0x4c>
  {
    m_free(m);
 3239de4:	e13ffd17 	ldw	r4,-12(fp)
 3239de8:	322be980 	call	322be98 <m_free>
    /* may be bogus socket, but more likely the connection may 
       have closed due to ICMP dest unreachable from other side. */
    return(ECONNREFUSED);
 3239dec:	00801bc4 	movi	r2,111
 3239df0:	e0bfff15 	stw	r2,-4(fp)
 3239df4:	0000dd06 	br	323a16c <udp4_socksend+0x3c0>
  }

  if (nam == NULL)  /* no sendto() info passed, must be send() */
 3239df8:	e0bffe17 	ldw	r2,-8(fp)
 3239dfc:	1004c03a 	cmpne	r2,r2,zero
 3239e00:	1000101e 	bne	r2,zero,3239e44 <udp4_socksend+0x98>
  { 
    if (so->so_state & SS_ISCONNECTED)
 3239e04:	e0bffc17 	ldw	r2,-16(fp)
 3239e08:	1080088b 	ldhu	r2,34(r2)
 3239e0c:	10bfffcc 	andi	r2,r2,65535
 3239e10:	1080008c 	andi	r2,r2,2
 3239e14:	1005003a 	cmpeq	r2,r2,zero
 3239e18:	1000071e 	bne	r2,zero,3239e38 <udp4_socksend+0x8c>
    {
      fport = udpconn->u_fport;
 3239e1c:	e0bff917 	ldw	r2,-28(fp)
 3239e20:	1080020b 	ldhu	r2,8(r2)
 3239e24:	e0bff80d 	sth	r2,-32(fp)
      fhost = udpconn->u_fhost;
 3239e28:	e0bff917 	ldw	r2,-28(fp)
 3239e2c:	10800417 	ldw	r2,16(r2)
 3239e30:	e0bff715 	stw	r2,-36(fp)
 3239e34:	00003106 	br	3239efc <udp4_socksend+0x150>
    }
    else
      return (EINVAL);
 3239e38:	00800584 	movi	r2,22
 3239e3c:	e0bfff15 	stw	r2,-4(fp)
 3239e40:	0000ca06 	br	323a16c <udp4_socksend+0x3c0>
  }
  else if(nam->m_len != sizeof (*sin))
 3239e44:	e0bffe17 	ldw	r2,-8(fp)
 3239e48:	10800217 	ldw	r2,8(r2)
 3239e4c:	10800420 	cmpeqi	r2,r2,16
 3239e50:	1000041e 	bne	r2,zero,3239e64 <udp4_socksend+0xb8>
  {
    dtrap();
 3239e54:	322aef00 	call	322aef0 <dtrap>
    return (EINVAL);
 3239e58:	00800584 	movi	r2,22
 3239e5c:	e0bfff15 	stw	r2,-4(fp)
 3239e60:	0000c206 	br	323a16c <udp4_socksend+0x3c0>
  }
  else
  {
    sin = mtod(nam, struct sockaddr_in *);
 3239e64:	e0bffe17 	ldw	r2,-8(fp)
 3239e68:	10800317 	ldw	r2,12(r2)
 3239e6c:	e0bffa15 	stw	r2,-24(fp)
    fhost = sin->sin_addr.s_addr;
 3239e70:	e0bffa17 	ldw	r2,-24(fp)
 3239e74:	10800117 	ldw	r2,4(r2)
 3239e78:	e0bff715 	stw	r2,-36(fp)
    /* use caller's fport if specified, ours may be a wildcard */
    if (sin->sin_port)   /* caller gets to change fport on the fly */
 3239e7c:	e0bffa17 	ldw	r2,-24(fp)
 3239e80:	1080008b 	ldhu	r2,2(r2)
 3239e84:	10bfffcc 	andi	r2,r2,65535
 3239e88:	1005003a 	cmpeq	r2,r2,zero
 3239e8c:	1000101e 	bne	r2,zero,3239ed0 <udp4_socksend+0x124>
      fport = ntohs(sin->sin_port);
 3239e90:	e0bffa17 	ldw	r2,-24(fp)
 3239e94:	1080008b 	ldhu	r2,2(r2)
 3239e98:	10bfffcc 	andi	r2,r2,65535
 3239e9c:	1004d23a 	srli	r2,r2,8
 3239ea0:	10803fcc 	andi	r2,r2,255
 3239ea4:	1009883a 	mov	r4,r2
 3239ea8:	e0bffa17 	ldw	r2,-24(fp)
 3239eac:	1080008b 	ldhu	r2,2(r2)
 3239eb0:	10bfffcc 	andi	r2,r2,65535
 3239eb4:	1004923a 	slli	r2,r2,8
 3239eb8:	1007883a 	mov	r3,r2
 3239ebc:	00bfc004 	movi	r2,-256
 3239ec0:	1884703a 	and	r2,r3,r2
 3239ec4:	2084b03a 	or	r2,r4,r2
 3239ec8:	e0bff80d 	sth	r2,-32(fp)
 3239ecc:	00000b06 	br	3239efc <udp4_socksend+0x150>
    else  /* use port already set in UDP connection */
    {
      if (udpconn->u_fport == 0) /* don't send to port 0 */
 3239ed0:	e0bff917 	ldw	r2,-28(fp)
 3239ed4:	1080020b 	ldhu	r2,8(r2)
 3239ed8:	10bfffcc 	andi	r2,r2,65535
 3239edc:	1004c03a 	cmpne	r2,r2,zero
 3239ee0:	1000031e 	bne	r2,zero,3239ef0 <udp4_socksend+0x144>
        return (EINVAL);
 3239ee4:	00800584 	movi	r2,22
 3239ee8:	e0bfff15 	stw	r2,-4(fp)
 3239eec:	00009f06 	br	323a16c <udp4_socksend+0x3c0>
      fport = udpconn->u_fport;
 3239ef0:	e0bff917 	ldw	r2,-28(fp)
 3239ef4:	1080020b 	ldhu	r2,8(r2)
 3239ef8:	e0bff80d 	sth	r2,-32(fp)

  /* since our pkt->nb_buff size is tied to max packet size, we 
   * assume our UDP datagrams are always in one mbuf and that the 
   * mbuf 
   */
  if (m->m_len > (unsigned)udp_maxalloc()) /* but check anyway:*/
 3239efc:	e0bffd17 	ldw	r2,-12(fp)
 3239f00:	14000217 	ldw	r16,8(r2)
 3239f04:	32455b40 	call	32455b4 <udp_maxalloc>
 3239f08:	1400042e 	bgeu	r2,r16,3239f1c <udp4_socksend+0x170>
  {
    dtrap(); /* should never happen */
 3239f0c:	322aef00 	call	322aef0 <dtrap>
    return EMSGSIZE;  /* try to recover */
 3239f10:	00801e84 	movi	r2,122
 3239f14:	e0bfff15 	stw	r2,-4(fp)
 3239f18:	00009406 	br	323a16c <udp4_socksend+0x3c0>
  }
  pkt = udp_alloc(m->m_len, 0);    /* get a NetPort buffer for send */
 3239f1c:	e0bffd17 	ldw	r2,-12(fp)
 3239f20:	10800217 	ldw	r2,8(r2)
 3239f24:	1009883a 	mov	r4,r2
 3239f28:	000b883a 	mov	r5,zero
 3239f2c:	32454f40 	call	32454f4 <udp_alloc>
 3239f30:	e0bff615 	stw	r2,-40(fp)
  if (!pkt)
 3239f34:	e0bff617 	ldw	r2,-40(fp)
 3239f38:	1004c03a 	cmpne	r2,r2,zero
 3239f3c:	1000051e 	bne	r2,zero,3239f54 <udp4_socksend+0x1a8>
  {
    m_free(m);
 3239f40:	e13ffd17 	ldw	r4,-12(fp)
 3239f44:	322be980 	call	322be98 <m_free>
    return ENOBUFS;   /* report buffer shortages */
 3239f48:	00801a44 	movi	r2,105
 3239f4c:	e0bfff15 	stw	r2,-4(fp)
 3239f50:	00008606 	br	323a16c <udp4_socksend+0x3c0>
  }
  MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 3239f54:	e0bff617 	ldw	r2,-40(fp)
 3239f58:	10c00317 	ldw	r3,12(r2)
 3239f5c:	e0bffd17 	ldw	r2,-12(fp)
 3239f60:	11400317 	ldw	r5,12(r2)
 3239f64:	e0bffd17 	ldw	r2,-12(fp)
 3239f68:	10800217 	ldw	r2,8(r2)
 3239f6c:	1809883a 	mov	r4,r3
 3239f70:	100d883a 	mov	r6,r2
 3239f74:	3206ad00 	call	3206ad0 <memcpy>
  pkt->nb_plen = m->m_len;
 3239f78:	e0bffd17 	ldw	r2,-12(fp)
 3239f7c:	10c00217 	ldw	r3,8(r2)
 3239f80:	e0bff617 	ldw	r2,-40(fp)
 3239f84:	10c00415 	stw	r3,16(r2)
  /* finished with mbuf, free it now */
  m_free(m);
 3239f88:	e13ffd17 	ldw	r4,-12(fp)
 3239f8c:	322be980 	call	322be98 <m_free>
  pkt->fhost = fhost;
 3239f90:	e0fff617 	ldw	r3,-40(fp)
 3239f94:	e0bff717 	ldw	r2,-36(fp)
 3239f98:	18800715 	stw	r2,28(r3)
     * is up; if (after all that) we don't have an interface then we
     * fail with error EADDRNOTAVAIL; and finally, if we're built
     * for a single-homed configuration where there's only one
     * interface, we might as well use it, so we do.  
   */
  if (fhost == 0xffffffff)
 3239f9c:	e0bff717 	ldw	r2,-36(fp)
 3239fa0:	10bfffd8 	cmpnei	r2,r2,-1
 3239fa4:	10004f1e 	bne	r2,zero,323a0e4 <udp4_socksend+0x338>
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
 3239fa8:	e0bff917 	ldw	r2,-28(fp)
 3239fac:	10800317 	ldw	r2,12(r2)
 3239fb0:	1005003a 	cmpeq	r2,r2,zero
 3239fb4:	1000111e 	bne	r2,zero,3239ffc <udp4_socksend+0x250>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3239fb8:	0080c9b4 	movhi	r2,806
 3239fbc:	10b54604 	addi	r2,r2,-10984
 3239fc0:	10800017 	ldw	r2,0(r2)
 3239fc4:	e0bff515 	stw	r2,-44(fp)
 3239fc8:	00000806 	br	3239fec <udp4_socksend+0x240>
        if (ifp->n_ipaddr == udpconn->u_lhost)
 3239fcc:	e0bff517 	ldw	r2,-44(fp)
 3239fd0:	10c00a17 	ldw	r3,40(r2)
 3239fd4:	e0bff917 	ldw	r2,-28(fp)
 3239fd8:	10800317 	ldw	r2,12(r2)
 3239fdc:	18802126 	beq	r3,r2,323a064 <udp4_socksend+0x2b8>
  if (fhost == 0xffffffff)
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3239fe0:	e0bff517 	ldw	r2,-44(fp)
 3239fe4:	10800017 	ldw	r2,0(r2)
 3239fe8:	e0bff515 	stw	r2,-44(fp)
 3239fec:	e0bff517 	ldw	r2,-44(fp)
 3239ff0:	1004c03a 	cmpne	r2,r2,zero
 3239ff4:	103ff51e 	bne	r2,zero,3239fcc <udp4_socksend+0x220>
 3239ff8:	00001a06 	br	323a064 <udp4_socksend+0x2b8>
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 3239ffc:	0080c9b4 	movhi	r2,806
 323a000:	10b54604 	addi	r2,r2,-10984
 323a004:	10800017 	ldw	r2,0(r2)
 323a008:	e0bff515 	stw	r2,-44(fp)
 323a00c:	00001206 	br	323a058 <udp4_socksend+0x2ac>
        if ((ifp->n_flags & NF_BCAST) &&
 323a010:	e0bff517 	ldw	r2,-44(fp)
 323a014:	10802a17 	ldw	r2,168(r2)
 323a018:	1080004c 	andi	r2,r2,1
 323a01c:	10803fcc 	andi	r2,r2,255
 323a020:	1005003a 	cmpeq	r2,r2,zero
 323a024:	1000091e 	bne	r2,zero,323a04c <udp4_socksend+0x2a0>
 323a028:	e0bff517 	ldw	r2,-44(fp)
 323a02c:	10802717 	ldw	r2,156(r2)
 323a030:	1005003a 	cmpeq	r2,r2,zero
 323a034:	1000051e 	bne	r2,zero,323a04c <udp4_socksend+0x2a0>
 323a038:	e0bff517 	ldw	r2,-44(fp)
 323a03c:	10802717 	ldw	r2,156(r2)
 323a040:	10800617 	ldw	r2,24(r2)
 323a044:	10800060 	cmpeqi	r2,r2,1
 323a048:	1000061e 	bne	r2,zero,323a064 <udp4_socksend+0x2b8>
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 323a04c:	e0bff517 	ldw	r2,-44(fp)
 323a050:	10800017 	ldw	r2,0(r2)
 323a054:	e0bff515 	stw	r2,-44(fp)
 323a058:	e0bff517 	ldw	r2,-44(fp)
 323a05c:	1004c03a 	cmpne	r2,r2,zero
 323a060:	103feb1e 	bne	r2,zero,323a010 <udp4_socksend+0x264>
        if ((ifp->n_flags & NF_BCAST) &&
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
 323a064:	e0bff517 	ldw	r2,-44(fp)
 323a068:	1004c03a 	cmpne	r2,r2,zero
 323a06c:	10001a1e 	bne	r2,zero,323a0d8 <udp4_socksend+0x32c>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 323a070:	0080c9b4 	movhi	r2,806
 323a074:	10b54604 	addi	r2,r2,-10984
 323a078:	10800017 	ldw	r2,0(r2)
 323a07c:	e0bff515 	stw	r2,-44(fp)
 323a080:	00000c06 	br	323a0b4 <udp4_socksend+0x308>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 323a084:	e0bff517 	ldw	r2,-44(fp)
 323a088:	10802717 	ldw	r2,156(r2)
 323a08c:	1005003a 	cmpeq	r2,r2,zero
 323a090:	1000051e 	bne	r2,zero,323a0a8 <udp4_socksend+0x2fc>
 323a094:	e0bff517 	ldw	r2,-44(fp)
 323a098:	10802717 	ldw	r2,156(r2)
 323a09c:	10800617 	ldw	r2,24(r2)
 323a0a0:	10800060 	cmpeqi	r2,r2,1
 323a0a4:	1000061e 	bne	r2,zero,323a0c0 <udp4_socksend+0x314>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 323a0a8:	e0bff517 	ldw	r2,-44(fp)
 323a0ac:	10800017 	ldw	r2,0(r2)
 323a0b0:	e0bff515 	stw	r2,-44(fp)
 323a0b4:	e0bff517 	ldw	r2,-44(fp)
 323a0b8:	1004c03a 	cmpne	r2,r2,zero
 323a0bc:	103ff11e 	bne	r2,zero,323a084 <udp4_socksend+0x2d8>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
          break;
      if (ifp == NULL)
 323a0c0:	e0bff517 	ldw	r2,-44(fp)
 323a0c4:	1004c03a 	cmpne	r2,r2,zero
 323a0c8:	1000031e 	bne	r2,zero,323a0d8 <udp4_socksend+0x32c>
        return(EADDRNOTAVAIL);
 323a0cc:	00801f44 	movi	r2,125
 323a0d0:	e0bfff15 	stw	r2,-4(fp)
 323a0d4:	00002506 	br	323a16c <udp4_socksend+0x3c0>
    }
    pkt->net = ifp;
 323a0d8:	e0fff617 	ldw	r3,-40(fp)
 323a0dc:	e0bff517 	ldw	r2,-44(fp)
 323a0e0:	18800615 	stw	r2,24(r3)
#ifdef IP_MULTICAST

  /* If the socket has an IP moptions structure for multicast options,
   * place a pointer to this structure in the PACKET structure.
   */
  if (so->inp_moptions)
 323a0e4:	e0bffc17 	ldw	r2,-16(fp)
 323a0e8:	10800317 	ldw	r2,12(r2)
 323a0ec:	1005003a 	cmpeq	r2,r2,zero
 323a0f0:	1000041e 	bne	r2,zero,323a104 <udp4_socksend+0x358>
     pkt->imo = so->inp_moptions;
 323a0f4:	e0bffc17 	ldw	r2,-16(fp)
 323a0f8:	10c00317 	ldw	r3,12(r2)
 323a0fc:	e0bff617 	ldw	r2,-40(fp)
 323a100:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

   /* have we set options? */
   if (so->so_optsPack)
 323a104:	e0bffc17 	ldw	r2,-16(fp)
 323a108:	10801f17 	ldw	r2,124(r2)
 323a10c:	1005003a 	cmpeq	r2,r2,zero
 323a110:	1000041e 	bne	r2,zero,323a124 <udp4_socksend+0x378>
	   pkt->soxopts = so->so_optsPack; /* yup - copy to pkt */
 323a114:	e0bffc17 	ldw	r2,-16(fp)
 323a118:	10c01f17 	ldw	r3,124(r2)
 323a11c:	e0bff617 	ldw	r2,-40(fp)
 323a120:	10c00c15 	stw	r3,48(r2)

  /* unlock the net resource; UDP will immediately re-lock it */
  UNLOCK_NET_RESOURCE(NET_RESID);
 323a124:	0009883a 	mov	r4,zero
 323a128:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
  e = udp_send(fport, udpconn->u_lport, pkt);
 323a12c:	e13ff80b 	ldhu	r4,-32(fp)
 323a130:	e0bff917 	ldw	r2,-28(fp)
 323a134:	1080018b 	ldhu	r2,6(r2)
 323a138:	117fffcc 	andi	r5,r2,65535
 323a13c:	e1bff617 	ldw	r6,-40(fp)
 323a140:	324503c0 	call	324503c <udp_send>
 323a144:	e0bffb15 	stw	r2,-20(fp)
  LOCK_NET_RESOURCE(NET_RESID);
 323a148:	0009883a 	mov	r4,zero
 323a14c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
  if (e < 0) 
 323a150:	e0bffb17 	ldw	r2,-20(fp)
 323a154:	1004403a 	cmpge	r2,r2,zero
 323a158:	1000031e 	bne	r2,zero,323a168 <udp4_socksend+0x3bc>
     return(e);
 323a15c:	e0bffb17 	ldw	r2,-20(fp)
 323a160:	e0bfff15 	stw	r2,-4(fp)
 323a164:	00000106 	br	323a16c <udp4_socksend+0x3c0>
  return 0;
 323a168:	e03fff15 	stw	zero,-4(fp)
 323a16c:	e0bfff17 	ldw	r2,-4(fp)
}
 323a170:	e037883a 	mov	sp,fp
 323a174:	dfc00217 	ldw	ra,8(sp)
 323a178:	df000117 	ldw	fp,4(sp)
 323a17c:	dc000017 	ldw	r16,0(sp)
 323a180:	dec00304 	addi	sp,sp,12
 323a184:	f800283a 	ret

0323a188 <udp4_sockaddr>:

int udp4_sockaddr(struct socket *so, struct mbuf *nam , int req)
{
 323a188:	defff804 	addi	sp,sp,-32
 323a18c:	dfc00715 	stw	ra,28(sp)
 323a190:	df000615 	stw	fp,24(sp)
 323a194:	df000604 	addi	fp,sp,24
 323a198:	e13ffc15 	stw	r4,-16(fp)
 323a19c:	e17ffd15 	stw	r5,-12(fp)
 323a1a0:	e1bffe15 	stw	r6,-8(fp)
  struct sockaddr_in * sin;
  UDPCONN udpconn;

  sin = mtod(nam, struct sockaddr_in *);
 323a1a4:	e0bffd17 	ldw	r2,-12(fp)
 323a1a8:	10800317 	ldw	r2,12(r2)
 323a1ac:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 323a1b0:	e0bffb17 	ldw	r2,-20(fp)
 323a1b4:	1004c03a 	cmpne	r2,r2,zero
 323a1b8:	1000031e 	bne	r2,zero,323a1c8 <udp4_sockaddr+0x40>
     return(EINVAL);
 323a1bc:	00800584 	movi	r2,22
 323a1c0:	e0bfff15 	stw	r2,-4(fp)
 323a1c4:	00004106 	br	323a2cc <udp4_sockaddr+0x144>
  udpconn = udp_lookup(so);
 323a1c8:	e13ffc17 	ldw	r4,-16(fp)
 323a1cc:	32395c40 	call	32395c4 <udp_lookup>
 323a1d0:	e0bffa15 	stw	r2,-24(fp)
  if (!udpconn)
 323a1d4:	e0bffa17 	ldw	r2,-24(fp)
 323a1d8:	1004c03a 	cmpne	r2,r2,zero
 323a1dc:	1000031e 	bne	r2,zero,323a1ec <udp4_sockaddr+0x64>
     return(EINVAL);
 323a1e0:	00800584 	movi	r2,22
 323a1e4:	e0bfff15 	stw	r2,-4(fp)
 323a1e8:	00003806 	br	323a2cc <udp4_sockaddr+0x144>
  nam->m_len = sizeof(*sin);
 323a1ec:	e0fffd17 	ldw	r3,-12(fp)
 323a1f0:	00800404 	movi	r2,16
 323a1f4:	18800215 	stw	r2,8(r3)
  if (req == PRU_SOCKADDR)
 323a1f8:	e0bffe17 	ldw	r2,-8(fp)
 323a1fc:	108003d8 	cmpnei	r2,r2,15
 323a200:	1000191e 	bne	r2,zero,323a268 <udp4_sockaddr+0xe0>
  {
     sin->sin_family = AF_INET;
 323a204:	e0fffb17 	ldw	r3,-20(fp)
 323a208:	00800084 	movi	r2,2
 323a20c:	1880000d 	sth	r2,0(r3)
     sin->sin_port = htons(udpconn->u_lport);
 323a210:	e0bffa17 	ldw	r2,-24(fp)
 323a214:	1080018b 	ldhu	r2,6(r2)
 323a218:	10bfffcc 	andi	r2,r2,65535
 323a21c:	1004d23a 	srli	r2,r2,8
 323a220:	10803fcc 	andi	r2,r2,255
 323a224:	1009883a 	mov	r4,r2
 323a228:	e0bffa17 	ldw	r2,-24(fp)
 323a22c:	1080018b 	ldhu	r2,6(r2)
 323a230:	10bfffcc 	andi	r2,r2,65535
 323a234:	1004923a 	slli	r2,r2,8
 323a238:	1007883a 	mov	r3,r2
 323a23c:	00bfc004 	movi	r2,-256
 323a240:	1884703a 	and	r2,r3,r2
 323a244:	2084b03a 	or	r2,r4,r2
 323a248:	1007883a 	mov	r3,r2
 323a24c:	e0bffb17 	ldw	r2,-20(fp)
 323a250:	10c0008d 	sth	r3,2(r2)
     sin->sin_addr.s_addr = udpconn->u_lhost;
 323a254:	e0bffa17 	ldw	r2,-24(fp)
 323a258:	10c00317 	ldw	r3,12(r2)
 323a25c:	e0bffb17 	ldw	r2,-20(fp)
 323a260:	10c00115 	stw	r3,4(r2)
 323a264:	00001806 	br	323a2c8 <udp4_sockaddr+0x140>
  }
  else /* PRU_PEERADDR */
  {
    sin->sin_family = AF_INET;
 323a268:	e0fffb17 	ldw	r3,-20(fp)
 323a26c:	00800084 	movi	r2,2
 323a270:	1880000d 	sth	r2,0(r3)
    sin->sin_port = htons(udpconn->u_fport);
 323a274:	e0bffa17 	ldw	r2,-24(fp)
 323a278:	1080020b 	ldhu	r2,8(r2)
 323a27c:	10bfffcc 	andi	r2,r2,65535
 323a280:	1004d23a 	srli	r2,r2,8
 323a284:	10803fcc 	andi	r2,r2,255
 323a288:	1009883a 	mov	r4,r2
 323a28c:	e0bffa17 	ldw	r2,-24(fp)
 323a290:	1080020b 	ldhu	r2,8(r2)
 323a294:	10bfffcc 	andi	r2,r2,65535
 323a298:	1004923a 	slli	r2,r2,8
 323a29c:	1007883a 	mov	r3,r2
 323a2a0:	00bfc004 	movi	r2,-256
 323a2a4:	1884703a 	and	r2,r3,r2
 323a2a8:	2084b03a 	or	r2,r4,r2
 323a2ac:	1007883a 	mov	r3,r2
 323a2b0:	e0bffb17 	ldw	r2,-20(fp)
 323a2b4:	10c0008d 	sth	r3,2(r2)
    sin->sin_addr.s_addr = udpconn->u_fhost;
 323a2b8:	e0bffa17 	ldw	r2,-24(fp)
 323a2bc:	10c00417 	ldw	r3,16(r2)
 323a2c0:	e0bffb17 	ldw	r2,-20(fp)
 323a2c4:	10c00115 	stw	r3,4(r2)
  }
  return 0;
 323a2c8:	e03fff15 	stw	zero,-4(fp)
 323a2cc:	e0bfff17 	ldw	r2,-4(fp)
}
 323a2d0:	e037883a 	mov	sp,fp
 323a2d4:	dfc00117 	ldw	ra,4(sp)
 323a2d8:	df000017 	ldw	fp,0(sp)
 323a2dc:	dec00204 	addi	sp,sp,8
 323a2e0:	f800283a 	ret

0323a2e4 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 323a2e4:	defff404 	addi	sp,sp,-48
 323a2e8:	df000b15 	stw	fp,44(sp)
 323a2ec:	df000b04 	addi	fp,sp,44
 323a2f0:	e13ffb15 	stw	r4,-20(fp)
 323a2f4:	e17ffc15 	stw	r5,-16(fp)
 323a2f8:	e1bffd15 	stw	r6,-12(fp)
 323a2fc:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 323a300:	e03ff915 	stw	zero,-28(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 323a304:	0080c974 	movhi	r2,805
 323a308:	10935104 	addi	r2,r2,19780
 323a30c:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
 323a310:	1005003a 	cmpeq	r2,r2,zero
 323a314:	1000411e 	bne	r2,zero,323a41c <alt_alarm_start+0x138>
  {
    if (alarm)
 323a318:	e0bffb17 	ldw	r2,-20(fp)
 323a31c:	1005003a 	cmpeq	r2,r2,zero
 323a320:	10003b1e 	bne	r2,zero,323a410 <alt_alarm_start+0x12c>
    {
      alarm->callback = callback;
 323a324:	e0fffb17 	ldw	r3,-20(fp)
 323a328:	e0bffd17 	ldw	r2,-12(fp)
 323a32c:	18800315 	stw	r2,12(r3)
      alarm->context  = context;
 323a330:	e0fffb17 	ldw	r3,-20(fp)
 323a334:	e0bffe17 	ldw	r2,-8(fp)
 323a338:	18800515 	stw	r2,20(r3)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 323a33c:	0005303a 	rdctl	r2,status
 323a340:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 323a344:	e0fff817 	ldw	r3,-32(fp)
 323a348:	00bfff84 	movi	r2,-2
 323a34c:	1884703a 	and	r2,r3,r2
 323a350:	1001703a 	wrctl	status,r2
  
  return context;
 323a354:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
 323a358:	e0bffa15 	stw	r2,-24(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 323a35c:	0080c974 	movhi	r2,805
 323a360:	10935204 	addi	r2,r2,19784
 323a364:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
 323a368:	e0bff915 	stw	r2,-28(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 323a36c:	e0fffc17 	ldw	r3,-16(fp)
 323a370:	e0bff917 	ldw	r2,-28(fp)
 323a374:	1885883a 	add	r2,r3,r2
 323a378:	10c00044 	addi	r3,r2,1
 323a37c:	e0bffb17 	ldw	r2,-20(fp)
 323a380:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 323a384:	e0bffb17 	ldw	r2,-20(fp)
 323a388:	10c00217 	ldw	r3,8(r2)
 323a38c:	e0bff917 	ldw	r2,-28(fp)
 323a390:	1880042e 	bgeu	r3,r2,323a3a4 <alt_alarm_start+0xc0>
      {
        alarm->rollover = 1;
 323a394:	e0fffb17 	ldw	r3,-20(fp)
 323a398:	00800044 	movi	r2,1
 323a39c:	18800405 	stb	r2,16(r3)
 323a3a0:	00000206 	br	323a3ac <alt_alarm_start+0xc8>
      }
      else
      {
        alarm->rollover = 0;
 323a3a4:	e0bffb17 	ldw	r2,-20(fp)
 323a3a8:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 323a3ac:	e0fffb17 	ldw	r3,-20(fp)
 323a3b0:	0080c974 	movhi	r2,805
 323a3b4:	108aa704 	addi	r2,r2,10908
 323a3b8:	e0bff615 	stw	r2,-40(fp)
 323a3bc:	e0fff715 	stw	r3,-36(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 323a3c0:	e0fff717 	ldw	r3,-36(fp)
 323a3c4:	e0bff617 	ldw	r2,-40(fp)
 323a3c8:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 323a3cc:	e0bff617 	ldw	r2,-40(fp)
 323a3d0:	10c00017 	ldw	r3,0(r2)
 323a3d4:	e0bff717 	ldw	r2,-36(fp)
 323a3d8:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 323a3dc:	e0bff617 	ldw	r2,-40(fp)
 323a3e0:	10c00017 	ldw	r3,0(r2)
 323a3e4:	e0bff717 	ldw	r2,-36(fp)
 323a3e8:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 323a3ec:	e0fff617 	ldw	r3,-40(fp)
 323a3f0:	e0bff717 	ldw	r2,-36(fp)
 323a3f4:	18800015 	stw	r2,0(r3)
 323a3f8:	e0bffa17 	ldw	r2,-24(fp)
 323a3fc:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 323a400:	e0bff517 	ldw	r2,-44(fp)
 323a404:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 323a408:	e03fff15 	stw	zero,-4(fp)
 323a40c:	00000506 	br	323a424 <alt_alarm_start+0x140>
    }
    else
    {
      return -EINVAL;
 323a410:	00bffa84 	movi	r2,-22
 323a414:	e0bfff15 	stw	r2,-4(fp)
 323a418:	00000206 	br	323a424 <alt_alarm_start+0x140>
    }
  }
  else
  {
    return -ENOTSUP;
 323a41c:	00bfde84 	movi	r2,-134
 323a420:	e0bfff15 	stw	r2,-4(fp)
 323a424:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 323a428:	e037883a 	mov	sp,fp
 323a42c:	df000017 	ldw	fp,0(sp)
 323a430:	dec00104 	addi	sp,sp,4
 323a434:	f800283a 	ret

0323a438 <alt_close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 323a438:	defff804 	addi	sp,sp,-32
 323a43c:	dfc00715 	stw	ra,28(sp)
 323a440:	df000615 	stw	fp,24(sp)
 323a444:	df000604 	addi	fp,sp,24
 323a448:	e13ffc15 	stw	r4,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 323a44c:	e0bffc17 	ldw	r2,-16(fp)
 323a450:	1004803a 	cmplt	r2,r2,zero
 323a454:	1000081e 	bne	r2,zero,323a478 <alt_close+0x40>
 323a458:	e0bffc17 	ldw	r2,-16(fp)
 323a45c:	10800324 	muli	r2,r2,12
 323a460:	1007883a 	mov	r3,r2
 323a464:	0080c974 	movhi	r2,805
 323a468:	10896e04 	addi	r2,r2,9656
 323a46c:	1887883a 	add	r3,r3,r2
 323a470:	e0ffff15 	stw	r3,-4(fp)
 323a474:	00000106 	br	323a47c <alt_close+0x44>
 323a478:	e03fff15 	stw	zero,-4(fp)
 323a47c:	e0bfff17 	ldw	r2,-4(fp)
 323a480:	e0bffb15 	stw	r2,-20(fp)

  if (fd)
 323a484:	e0bffb17 	ldw	r2,-20(fp)
 323a488:	1005003a 	cmpeq	r2,r2,zero
 323a48c:	10001d1e 	bne	r2,zero,323a504 <alt_close+0xcc>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 323a490:	e0bffb17 	ldw	r2,-20(fp)
 323a494:	10800017 	ldw	r2,0(r2)
 323a498:	10800417 	ldw	r2,16(r2)
 323a49c:	1005003a 	cmpeq	r2,r2,zero
 323a4a0:	1000071e 	bne	r2,zero,323a4c0 <alt_close+0x88>
 323a4a4:	e0bffb17 	ldw	r2,-20(fp)
 323a4a8:	10800017 	ldw	r2,0(r2)
 323a4ac:	10800417 	ldw	r2,16(r2)
 323a4b0:	e13ffb17 	ldw	r4,-20(fp)
 323a4b4:	103ee83a 	callr	r2
 323a4b8:	e0bffe15 	stw	r2,-8(fp)
 323a4bc:	00000106 	br	323a4c4 <alt_close+0x8c>
 323a4c0:	e03ffe15 	stw	zero,-8(fp)
 323a4c4:	e0bffe17 	ldw	r2,-8(fp)
 323a4c8:	e0bffa15 	stw	r2,-24(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 323a4cc:	e13ffc17 	ldw	r4,-16(fp)
 323a4d0:	321514c0 	call	321514c <alt_release_fd>
    if (rval < 0)
 323a4d4:	e0bffa17 	ldw	r2,-24(fp)
 323a4d8:	1004403a 	cmpge	r2,r2,zero
 323a4dc:	1000071e 	bne	r2,zero,323a4fc <alt_close+0xc4>
    {
      ALT_ERRNO = -rval;
 323a4e0:	323a5340 	call	323a534 <alt_get_errno>
 323a4e4:	e0fffa17 	ldw	r3,-24(fp)
 323a4e8:	00c7c83a 	sub	r3,zero,r3
 323a4ec:	10c00015 	stw	r3,0(r2)
      return -1;
 323a4f0:	00bfffc4 	movi	r2,-1
 323a4f4:	e0bffd15 	stw	r2,-12(fp)
 323a4f8:	00000806 	br	323a51c <alt_close+0xe4>
    }
    return 0;
 323a4fc:	e03ffd15 	stw	zero,-12(fp)
 323a500:	00000606 	br	323a51c <alt_close+0xe4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 323a504:	323a5340 	call	323a534 <alt_get_errno>
 323a508:	1007883a 	mov	r3,r2
 323a50c:	00801444 	movi	r2,81
 323a510:	18800015 	stw	r2,0(r3)
    return -1;
 323a514:	00bfffc4 	movi	r2,-1
 323a518:	e0bffd15 	stw	r2,-12(fp)
 323a51c:	e0bffd17 	ldw	r2,-12(fp)
  }
}
 323a520:	e037883a 	mov	sp,fp
 323a524:	dfc00117 	ldw	ra,4(sp)
 323a528:	df000017 	ldw	fp,0(sp)
 323a52c:	dec00204 	addi	sp,sp,8
 323a530:	f800283a 	ret

0323a534 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 323a534:	defffd04 	addi	sp,sp,-12
 323a538:	dfc00215 	stw	ra,8(sp)
 323a53c:	df000115 	stw	fp,4(sp)
 323a540:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 323a544:	0080c974 	movhi	r2,805
 323a548:	108aa504 	addi	r2,r2,10900
 323a54c:	10800017 	ldw	r2,0(r2)
 323a550:	1005003a 	cmpeq	r2,r2,zero
 323a554:	1000061e 	bne	r2,zero,323a570 <alt_get_errno+0x3c>
 323a558:	0080c974 	movhi	r2,805
 323a55c:	108aa504 	addi	r2,r2,10900
 323a560:	10800017 	ldw	r2,0(r2)
 323a564:	103ee83a 	callr	r2
 323a568:	e0bfff15 	stw	r2,-4(fp)
 323a56c:	00000306 	br	323a57c <alt_get_errno+0x48>
 323a570:	0080c974 	movhi	r2,805
 323a574:	1092f804 	addi	r2,r2,19424
 323a578:	e0bfff15 	stw	r2,-4(fp)
 323a57c:	e0bfff17 	ldw	r2,-4(fp)
}
 323a580:	e037883a 	mov	sp,fp
 323a584:	dfc00117 	ldw	ra,4(sp)
 323a588:	df000017 	ldw	fp,0(sp)
 323a58c:	dec00204 	addi	sp,sp,8
 323a590:	f800283a 	ret

0323a594 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 323a594:	defffb04 	addi	sp,sp,-20
 323a598:	df000415 	stw	fp,16(sp)
 323a59c:	df000404 	addi	fp,sp,16
 323a5a0:	e13ffe15 	stw	r4,-8(fp)
 323a5a4:	e17fff15 	stw	r5,-4(fp)
  {
    len = NIOS2_DCACHE_SIZE;
  }
  #endif

  end = ((char*) start) + len; 
 323a5a8:	e0fffe17 	ldw	r3,-8(fp)
 323a5ac:	e0bfff17 	ldw	r2,-4(fp)
 323a5b0:	1885883a 	add	r2,r3,r2
 323a5b4:	e0bffc15 	stw	r2,-16(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 323a5b8:	e0bffe17 	ldw	r2,-8(fp)
 323a5bc:	e0bffd15 	stw	r2,-12(fp)
 323a5c0:	00000506 	br	323a5d8 <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
 323a5c4:	e0bffd17 	ldw	r2,-12(fp)
 323a5c8:	1000001b 	flushda	0(r2)
  }
  #endif

  end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 323a5cc:	e0bffd17 	ldw	r2,-12(fp)
 323a5d0:	10800804 	addi	r2,r2,32
 323a5d4:	e0bffd15 	stw	r2,-12(fp)
 323a5d8:	e0fffd17 	ldw	r3,-12(fp)
 323a5dc:	e0bffc17 	ldw	r2,-16(fp)
 323a5e0:	18bff836 	bltu	r3,r2,323a5c4 <alt_dcache_flush+0x30>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
 323a5e4:	e0bffe17 	ldw	r2,-8(fp)
 323a5e8:	108007cc 	andi	r2,r2,31
 323a5ec:	1005003a 	cmpeq	r2,r2,zero
 323a5f0:	1000021e 	bne	r2,zero,323a5fc <alt_dcache_flush+0x68>
  {
    ALT_FLUSH_DATA(i);
 323a5f4:	e0bffd17 	ldw	r2,-12(fp)
 323a5f8:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 323a5fc:	e037883a 	mov	sp,fp
 323a600:	df000017 	ldw	fp,0(sp)
 323a604:	dec00104 	addi	sp,sp,4
 323a608:	f800283a 	ret

0323a60c <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 323a60c:	defffe04 	addi	sp,sp,-8
 323a610:	df000115 	stw	fp,4(sp)
 323a614:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 323a618:	e03fff15 	stw	zero,-4(fp)
 323a61c:	00000506 	br	323a634 <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
 323a620:	e0bfff17 	ldw	r2,-4(fp)
 323a624:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 323a628:	e0bfff17 	ldw	r2,-4(fp)
 323a62c:	10800804 	addi	r2,r2,32
 323a630:	e0bfff15 	stw	r2,-4(fp)
 323a634:	e0bfff17 	ldw	r2,-4(fp)
 323a638:	10900030 	cmpltui	r2,r2,16384
 323a63c:	103ff81e 	bne	r2,zero,323a620 <alt_dcache_flush_all+0x14>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 323a640:	e037883a 	mov	sp,fp
 323a644:	df000017 	ldw	fp,0(sp)
 323a648:	dec00104 	addi	sp,sp,4
 323a64c:	f800283a 	ret

0323a650 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 323a650:	defffc04 	addi	sp,sp,-16
 323a654:	df000315 	stw	fp,12(sp)
 323a658:	df000304 	addi	fp,sp,12
 323a65c:	e13ffd15 	stw	r4,-12(fp)
 323a660:	e17ffe15 	stw	r5,-8(fp)
 323a664:	e1bfff15 	stw	r6,-4(fp)
  return len;
 323a668:	e0bfff17 	ldw	r2,-4(fp)
}
 323a66c:	e037883a 	mov	sp,fp
 323a670:	df000017 	ldw	fp,0(sp)
 323a674:	dec00104 	addi	sp,sp,4
 323a678:	f800283a 	ret

0323a67c <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 323a67c:	defff904 	addi	sp,sp,-28
 323a680:	dfc00615 	stw	ra,24(sp)
 323a684:	df000515 	stw	fp,20(sp)
 323a688:	df000504 	addi	fp,sp,20
 323a68c:	e13ffd15 	stw	r4,-12(fp)
 323a690:	e17ffe15 	stw	r5,-8(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 323a694:	e0bffd17 	ldw	r2,-12(fp)
 323a698:	1005003a 	cmpeq	r2,r2,zero
 323a69c:	1000041e 	bne	r2,zero,323a6b0 <alt_dev_llist_insert+0x34>
 323a6a0:	e0bffd17 	ldw	r2,-12(fp)
 323a6a4:	10800217 	ldw	r2,8(r2)
 323a6a8:	1004c03a 	cmpne	r2,r2,zero
 323a6ac:	1000071e 	bne	r2,zero,323a6cc <alt_dev_llist_insert+0x50>
  {
    ALT_ERRNO = EINVAL;
 323a6b0:	323a7300 	call	323a730 <alt_get_errno>
 323a6b4:	1007883a 	mov	r3,r2
 323a6b8:	00800584 	movi	r2,22
 323a6bc:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 323a6c0:	00bffa84 	movi	r2,-22
 323a6c4:	e0bfff15 	stw	r2,-4(fp)
 323a6c8:	00001306 	br	323a718 <alt_dev_llist_insert+0x9c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 323a6cc:	e0fffd17 	ldw	r3,-12(fp)
 323a6d0:	e0bffe17 	ldw	r2,-8(fp)
 323a6d4:	e0bffb15 	stw	r2,-20(fp)
 323a6d8:	e0fffc15 	stw	r3,-16(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 323a6dc:	e0fffc17 	ldw	r3,-16(fp)
 323a6e0:	e0bffb17 	ldw	r2,-20(fp)
 323a6e4:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 323a6e8:	e0bffb17 	ldw	r2,-20(fp)
 323a6ec:	10c00017 	ldw	r3,0(r2)
 323a6f0:	e0bffc17 	ldw	r2,-16(fp)
 323a6f4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 323a6f8:	e0bffb17 	ldw	r2,-20(fp)
 323a6fc:	10c00017 	ldw	r3,0(r2)
 323a700:	e0bffc17 	ldw	r2,-16(fp)
 323a704:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 323a708:	e0fffb17 	ldw	r3,-20(fp)
 323a70c:	e0bffc17 	ldw	r2,-16(fp)
 323a710:	18800015 	stw	r2,0(r3)

  return 0;  
 323a714:	e03fff15 	stw	zero,-4(fp)
 323a718:	e0bfff17 	ldw	r2,-4(fp)
}
 323a71c:	e037883a 	mov	sp,fp
 323a720:	dfc00117 	ldw	ra,4(sp)
 323a724:	df000017 	ldw	fp,0(sp)
 323a728:	dec00204 	addi	sp,sp,8
 323a72c:	f800283a 	ret

0323a730 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 323a730:	defffd04 	addi	sp,sp,-12
 323a734:	dfc00215 	stw	ra,8(sp)
 323a738:	df000115 	stw	fp,4(sp)
 323a73c:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 323a740:	0080c974 	movhi	r2,805
 323a744:	108aa504 	addi	r2,r2,10900
 323a748:	10800017 	ldw	r2,0(r2)
 323a74c:	1005003a 	cmpeq	r2,r2,zero
 323a750:	1000061e 	bne	r2,zero,323a76c <alt_get_errno+0x3c>
 323a754:	0080c974 	movhi	r2,805
 323a758:	108aa504 	addi	r2,r2,10900
 323a75c:	10800017 	ldw	r2,0(r2)
 323a760:	103ee83a 	callr	r2
 323a764:	e0bfff15 	stw	r2,-4(fp)
 323a768:	00000306 	br	323a778 <alt_get_errno+0x48>
 323a76c:	0080c974 	movhi	r2,805
 323a770:	1092f804 	addi	r2,r2,19424
 323a774:	e0bfff15 	stw	r2,-4(fp)
 323a778:	e0bfff17 	ldw	r2,-4(fp)
}
 323a77c:	e037883a 	mov	sp,fp
 323a780:	dfc00117 	ldw	ra,4(sp)
 323a784:	df000017 	ldw	fp,0(sp)
 323a788:	dec00204 	addi	sp,sp,8
 323a78c:	f800283a 	ret

0323a790 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 323a790:	defffd04 	addi	sp,sp,-12
 323a794:	dfc00215 	stw	ra,8(sp)
 323a798:	df000115 	stw	fp,4(sp)
 323a79c:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 323a7a0:	00bfff04 	movi	r2,-4
 323a7a4:	00c0c974 	movhi	r3,805
 323a7a8:	18f0db04 	addi	r3,r3,-15508
 323a7ac:	1885883a 	add	r2,r3,r2
 323a7b0:	e0bfff15 	stw	r2,-4(fp)
 323a7b4:	00000606 	br	323a7d0 <_do_ctors+0x40>
        (*ctor) (); 
 323a7b8:	e0bfff17 	ldw	r2,-4(fp)
 323a7bc:	10800017 	ldw	r2,0(r2)
 323a7c0:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 323a7c4:	e0bfff17 	ldw	r2,-4(fp)
 323a7c8:	10bfff04 	addi	r2,r2,-4
 323a7cc:	e0bfff15 	stw	r2,-4(fp)
 323a7d0:	e0ffff17 	ldw	r3,-4(fp)
 323a7d4:	0080c974 	movhi	r2,805
 323a7d8:	10b0da04 	addi	r2,r2,-15512
 323a7dc:	18bff62e 	bgeu	r3,r2,323a7b8 <_do_ctors+0x28>
        (*ctor) (); 
}
 323a7e0:	e037883a 	mov	sp,fp
 323a7e4:	dfc00117 	ldw	ra,4(sp)
 323a7e8:	df000017 	ldw	fp,0(sp)
 323a7ec:	dec00204 	addi	sp,sp,8
 323a7f0:	f800283a 	ret

0323a7f4 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 323a7f4:	defffd04 	addi	sp,sp,-12
 323a7f8:	dfc00215 	stw	ra,8(sp)
 323a7fc:	df000115 	stw	fp,4(sp)
 323a800:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 323a804:	00bfff04 	movi	r2,-4
 323a808:	00c0c974 	movhi	r3,805
 323a80c:	18f0db04 	addi	r3,r3,-15508
 323a810:	1885883a 	add	r2,r3,r2
 323a814:	e0bfff15 	stw	r2,-4(fp)
 323a818:	00000606 	br	323a834 <_do_dtors+0x40>
        (*dtor) (); 
 323a81c:	e0bfff17 	ldw	r2,-4(fp)
 323a820:	10800017 	ldw	r2,0(r2)
 323a824:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 323a828:	e0bfff17 	ldw	r2,-4(fp)
 323a82c:	10bfff04 	addi	r2,r2,-4
 323a830:	e0bfff15 	stw	r2,-4(fp)
 323a834:	e0ffff17 	ldw	r3,-4(fp)
 323a838:	0080c974 	movhi	r2,805
 323a83c:	10b0db04 	addi	r2,r2,-15508
 323a840:	18bff62e 	bgeu	r3,r2,323a81c <_do_dtors+0x28>
        (*dtor) (); 
}
 323a844:	e037883a 	mov	sp,fp
 323a848:	dfc00117 	ldw	ra,4(sp)
 323a84c:	df000017 	ldw	fp,0(sp)
 323a850:	dec00204 	addi	sp,sp,8
 323a854:	f800283a 	ret

0323a858 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 323a858:	defff904 	addi	sp,sp,-28
 323a85c:	dfc00615 	stw	ra,24(sp)
 323a860:	df000515 	stw	fp,20(sp)
 323a864:	df000504 	addi	fp,sp,20
 323a868:	e13ffd15 	stw	r4,-12(fp)
 323a86c:	e17ffe15 	stw	r5,-8(fp)
  alt_dev* next = (alt_dev*) llist->next;
 323a870:	e0bffe17 	ldw	r2,-8(fp)
 323a874:	10800017 	ldw	r2,0(r2)
 323a878:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 323a87c:	e13ffd17 	ldw	r4,-12(fp)
 323a880:	32084480 	call	3208448 <strlen>
 323a884:	10800044 	addi	r2,r2,1
 323a888:	e0bffb15 	stw	r2,-20(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 323a88c:	00000d06 	br	323a8c4 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 323a890:	e0bffc17 	ldw	r2,-16(fp)
 323a894:	11000217 	ldw	r4,8(r2)
 323a898:	e1bffb17 	ldw	r6,-20(fp)
 323a89c:	e17ffd17 	ldw	r5,-12(fp)
 323a8a0:	324bcc00 	call	324bcc0 <memcmp>
 323a8a4:	1004c03a 	cmpne	r2,r2,zero
 323a8a8:	1000031e 	bne	r2,zero,323a8b8 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 323a8ac:	e0bffc17 	ldw	r2,-16(fp)
 323a8b0:	e0bfff15 	stw	r2,-4(fp)
 323a8b4:	00000706 	br	323a8d4 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 323a8b8:	e0bffc17 	ldw	r2,-16(fp)
 323a8bc:	10800017 	ldw	r2,0(r2)
 323a8c0:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 323a8c4:	e0fffe17 	ldw	r3,-8(fp)
 323a8c8:	e0bffc17 	ldw	r2,-16(fp)
 323a8cc:	10fff01e 	bne	r2,r3,323a890 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 323a8d0:	e03fff15 	stw	zero,-4(fp)
 323a8d4:	e0bfff17 	ldw	r2,-4(fp)
}
 323a8d8:	e037883a 	mov	sp,fp
 323a8dc:	dfc00117 	ldw	ra,4(sp)
 323a8e0:	df000017 	ldw	fp,0(sp)
 323a8e4:	dec00204 	addi	sp,sp,8
 323a8e8:	f800283a 	ret

0323a8ec <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 323a8ec:	defffa04 	addi	sp,sp,-24
 323a8f0:	dfc00515 	stw	ra,20(sp)
 323a8f4:	df000415 	stw	fp,16(sp)
 323a8f8:	df000404 	addi	fp,sp,16
 323a8fc:	e13ffe15 	stw	r4,-8(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 323a900:	0080c974 	movhi	r2,805
 323a904:	108aa004 	addi	r2,r2,10880
 323a908:	10800017 	ldw	r2,0(r2)
 323a90c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 323a910:	00003306 	br	323a9e0 <alt_find_file+0xf4>
  {
    len = strlen(next->name);
 323a914:	e0bffd17 	ldw	r2,-12(fp)
 323a918:	11000217 	ldw	r4,8(r2)
 323a91c:	32084480 	call	3208448 <strlen>
 323a920:	e0bffc15 	stw	r2,-16(fp)
    
    if (next->name[len-1] == '/')
 323a924:	e0bffd17 	ldw	r2,-12(fp)
 323a928:	10c00217 	ldw	r3,8(r2)
 323a92c:	e0bffc17 	ldw	r2,-16(fp)
 323a930:	1885883a 	add	r2,r3,r2
 323a934:	10bfffc4 	addi	r2,r2,-1
 323a938:	10800003 	ldbu	r2,0(r2)
 323a93c:	10803fcc 	andi	r2,r2,255
 323a940:	1080201c 	xori	r2,r2,128
 323a944:	10bfe004 	addi	r2,r2,-128
 323a948:	10800bd8 	cmpnei	r2,r2,47
 323a94c:	1000031e 	bne	r2,zero,323a95c <alt_find_file+0x70>
    {
      len -= 1;
 323a950:	e0bffc17 	ldw	r2,-16(fp)
 323a954:	10bfffc4 	addi	r2,r2,-1
 323a958:	e0bffc15 	stw	r2,-16(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 323a95c:	e0bffc17 	ldw	r2,-16(fp)
 323a960:	1007883a 	mov	r3,r2
 323a964:	e0bffe17 	ldw	r2,-8(fp)
 323a968:	1885883a 	add	r2,r3,r2
 323a96c:	10800003 	ldbu	r2,0(r2)
 323a970:	10803fcc 	andi	r2,r2,255
 323a974:	1080201c 	xori	r2,r2,128
 323a978:	10bfe004 	addi	r2,r2,-128
 323a97c:	10800be0 	cmpeqi	r2,r2,47
 323a980:	10000a1e 	bne	r2,zero,323a9ac <alt_find_file+0xc0>
 323a984:	e0bffc17 	ldw	r2,-16(fp)
 323a988:	1007883a 	mov	r3,r2
 323a98c:	e0bffe17 	ldw	r2,-8(fp)
 323a990:	1885883a 	add	r2,r3,r2
 323a994:	10800003 	ldbu	r2,0(r2)
 323a998:	10803fcc 	andi	r2,r2,255
 323a99c:	1080201c 	xori	r2,r2,128
 323a9a0:	10bfe004 	addi	r2,r2,-128
 323a9a4:	1004c03a 	cmpne	r2,r2,zero
 323a9a8:	10000a1e 	bne	r2,zero,323a9d4 <alt_find_file+0xe8>
 323a9ac:	e0bffd17 	ldw	r2,-12(fp)
 323a9b0:	11000217 	ldw	r4,8(r2)
 323a9b4:	e1bffc17 	ldw	r6,-16(fp)
 323a9b8:	e17ffe17 	ldw	r5,-8(fp)
 323a9bc:	324bcc00 	call	324bcc0 <memcmp>
 323a9c0:	1004c03a 	cmpne	r2,r2,zero
 323a9c4:	1000031e 	bne	r2,zero,323a9d4 <alt_find_file+0xe8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 323a9c8:	e0bffd17 	ldw	r2,-12(fp)
 323a9cc:	e0bfff15 	stw	r2,-4(fp)
 323a9d0:	00000806 	br	323a9f4 <alt_find_file+0x108>
    }
    next = (alt_dev*) next->llist.next;
 323a9d4:	e0bffd17 	ldw	r2,-12(fp)
 323a9d8:	10800017 	ldw	r2,0(r2)
 323a9dc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 323a9e0:	00c0c974 	movhi	r3,805
 323a9e4:	18caa004 	addi	r3,r3,10880
 323a9e8:	e0bffd17 	ldw	r2,-12(fp)
 323a9ec:	10ffc91e 	bne	r2,r3,323a914 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 323a9f0:	e03fff15 	stw	zero,-4(fp)
 323a9f4:	e0bfff17 	ldw	r2,-4(fp)
}
 323a9f8:	e037883a 	mov	sp,fp
 323a9fc:	dfc00117 	ldw	ra,4(sp)
 323aa00:	df000017 	ldw	fp,0(sp)
 323aa04:	dec00204 	addi	sp,sp,8
 323aa08:	f800283a 	ret

0323aa0c <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 323aa0c:	defff804 	addi	sp,sp,-32
 323aa10:	dfc00715 	stw	ra,28(sp)
 323aa14:	df000615 	stw	fp,24(sp)
 323aa18:	df000604 	addi	fp,sp,24
 323aa1c:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 323aa20:	00bffa04 	movi	r2,-24
 323aa24:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
 323aa28:	0080c974 	movhi	r2,805
 323aa2c:	10934f04 	addi	r2,r2,19772
 323aa30:	10800017 	ldw	r2,0(r2)
 323aa34:	e0bffa15 	stw	r2,-24(fp)
 323aa38:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 323aa3c:	e17ffb0b 	ldhu	r5,-20(fp)
 323aa40:	e1bffe04 	addi	r6,fp,-8
 323aa44:	e13ffa17 	ldw	r4,-24(fp)
 323aa48:	321b0e80 	call	321b0e8 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 323aa4c:	e03ffd15 	stw	zero,-12(fp)
 323aa50:	00001e06 	br	323aacc <alt_get_fd+0xc0>
  {
    if (!alt_fd_list[i].dev)
 323aa54:	e0bffd17 	ldw	r2,-12(fp)
 323aa58:	00c0c974 	movhi	r3,805
 323aa5c:	18c96e04 	addi	r3,r3,9656
 323aa60:	10800324 	muli	r2,r2,12
 323aa64:	10c5883a 	add	r2,r2,r3
 323aa68:	10800017 	ldw	r2,0(r2)
 323aa6c:	1004c03a 	cmpne	r2,r2,zero
 323aa70:	1000131e 	bne	r2,zero,323aac0 <alt_get_fd+0xb4>
    {
      alt_fd_list[i].dev = dev;
 323aa74:	e0bffd17 	ldw	r2,-12(fp)
 323aa78:	00c0c974 	movhi	r3,805
 323aa7c:	18c96e04 	addi	r3,r3,9656
 323aa80:	10800324 	muli	r2,r2,12
 323aa84:	10c7883a 	add	r3,r2,r3
 323aa88:	e0bfff17 	ldw	r2,-4(fp)
 323aa8c:	18800015 	stw	r2,0(r3)
      if (i > alt_max_fd)
 323aa90:	0080c974 	movhi	r2,805
 323aa94:	108aa404 	addi	r2,r2,10896
 323aa98:	10c00017 	ldw	r3,0(r2)
 323aa9c:	e0bffd17 	ldw	r2,-12(fp)
 323aaa0:	1880040e 	bge	r3,r2,323aab4 <alt_get_fd+0xa8>
      {
        alt_max_fd = i;
 323aaa4:	00c0c974 	movhi	r3,805
 323aaa8:	18caa404 	addi	r3,r3,10896
 323aaac:	e0bffd17 	ldw	r2,-12(fp)
 323aab0:	18800015 	stw	r2,0(r3)
      }
      rc = i;
 323aab4:	e0bffd17 	ldw	r2,-12(fp)
 323aab8:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
 323aabc:	00000606 	br	323aad8 <alt_get_fd+0xcc>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 323aac0:	e0bffd17 	ldw	r2,-12(fp)
 323aac4:	10800044 	addi	r2,r2,1
 323aac8:	e0bffd15 	stw	r2,-12(fp)
 323aacc:	e0bffd17 	ldw	r2,-12(fp)
 323aad0:	10800810 	cmplti	r2,r2,32
 323aad4:	103fdf1e 	bne	r2,zero,323aa54 <alt_get_fd+0x48>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
 323aad8:	0080c974 	movhi	r2,805
 323aadc:	10934f04 	addi	r2,r2,19772
 323aae0:	11000017 	ldw	r4,0(r2)
 323aae4:	321b4e00 	call	321b4e0 <OSSemPost>

  return rc;
 323aae8:	e0bffc17 	ldw	r2,-16(fp)
}
 323aaec:	e037883a 	mov	sp,fp
 323aaf0:	dfc00117 	ldw	ra,4(sp)
 323aaf4:	df000017 	ldw	fp,0(sp)
 323aaf8:	dec00204 	addi	sp,sp,8
 323aafc:	f800283a 	ret

0323ab00 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 323ab00:	defffe04 	addi	sp,sp,-8
 323ab04:	dfc00115 	stw	ra,4(sp)
 323ab08:	df000015 	stw	fp,0(sp)
 323ab0c:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 323ab10:	0009883a 	mov	r4,zero
 323ab14:	01500004 	movi	r5,16384
 323ab18:	324a87c0 	call	324a87c <alt_icache_flush>
#endif
}
 323ab1c:	e037883a 	mov	sp,fp
 323ab20:	dfc00117 	ldw	ra,4(sp)
 323ab24:	df000017 	ldw	fp,0(sp)
 323ab28:	dec00204 	addi	sp,sp,8
 323ab2c:	f800283a 	ret

0323ab30 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 323ab30:	defff904 	addi	sp,sp,-28
 323ab34:	dfc00615 	stw	ra,24(sp)
 323ab38:	df000515 	stw	fp,20(sp)
 323ab3c:	df000504 	addi	fp,sp,20
 323ab40:	e13ffc15 	stw	r4,-16(fp)
 323ab44:	e17ffd15 	stw	r5,-12(fp)
 323ab48:	e1bffe15 	stw	r6,-8(fp)
 323ab4c:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 323ab50:	e13ffd17 	ldw	r4,-12(fp)
 323ab54:	e17ffe17 	ldw	r5,-8(fp)
 323ab58:	e1bfff17 	ldw	r6,-4(fp)
 323ab5c:	3214f640 	call	3214f64 <open>
 323ab60:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 323ab64:	e0bffb17 	ldw	r2,-20(fp)
 323ab68:	1004803a 	cmplt	r2,r2,zero
 323ab6c:	10001c1e 	bne	r2,zero,323abe0 <alt_open_fd+0xb0>
  {
    fd->dev      = alt_fd_list[old].dev;
 323ab70:	e0bffb17 	ldw	r2,-20(fp)
 323ab74:	00c0c974 	movhi	r3,805
 323ab78:	18c96e04 	addi	r3,r3,9656
 323ab7c:	10800324 	muli	r2,r2,12
 323ab80:	10c5883a 	add	r2,r2,r3
 323ab84:	10c00017 	ldw	r3,0(r2)
 323ab88:	e0bffc17 	ldw	r2,-16(fp)
 323ab8c:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 323ab90:	e0bffb17 	ldw	r2,-20(fp)
 323ab94:	00c0c974 	movhi	r3,805
 323ab98:	18c96e04 	addi	r3,r3,9656
 323ab9c:	10800324 	muli	r2,r2,12
 323aba0:	10c5883a 	add	r2,r2,r3
 323aba4:	10800104 	addi	r2,r2,4
 323aba8:	10c00017 	ldw	r3,0(r2)
 323abac:	e0bffc17 	ldw	r2,-16(fp)
 323abb0:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 323abb4:	e0bffb17 	ldw	r2,-20(fp)
 323abb8:	00c0c974 	movhi	r3,805
 323abbc:	18c96e04 	addi	r3,r3,9656
 323abc0:	10800324 	muli	r2,r2,12
 323abc4:	10c5883a 	add	r2,r2,r3
 323abc8:	10800204 	addi	r2,r2,8
 323abcc:	10c00017 	ldw	r3,0(r2)
 323abd0:	e0bffc17 	ldw	r2,-16(fp)
 323abd4:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 323abd8:	e13ffb17 	ldw	r4,-20(fp)
 323abdc:	321514c0 	call	321514c <alt_release_fd>
  }
} 
 323abe0:	e037883a 	mov	sp,fp
 323abe4:	dfc00117 	ldw	ra,4(sp)
 323abe8:	df000017 	ldw	fp,0(sp)
 323abec:	dec00204 	addi	sp,sp,8
 323abf0:	f800283a 	ret

0323abf4 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 323abf4:	defffb04 	addi	sp,sp,-20
 323abf8:	dfc00415 	stw	ra,16(sp)
 323abfc:	df000315 	stw	fp,12(sp)
 323ac00:	df000304 	addi	fp,sp,12
 323ac04:	e13ffd15 	stw	r4,-12(fp)
 323ac08:	e17ffe15 	stw	r5,-8(fp)
 323ac0c:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 323ac10:	0100c974 	movhi	r4,805
 323ac14:	21097104 	addi	r4,r4,9668
 323ac18:	e17ffd17 	ldw	r5,-12(fp)
 323ac1c:	01800044 	movi	r6,1
 323ac20:	01c07fc4 	movi	r7,511
 323ac24:	323ab300 	call	323ab30 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 323ac28:	0100c974 	movhi	r4,805
 323ac2c:	21096e04 	addi	r4,r4,9656
 323ac30:	e17ffe17 	ldw	r5,-8(fp)
 323ac34:	000d883a 	mov	r6,zero
 323ac38:	01c07fc4 	movi	r7,511
 323ac3c:	323ab300 	call	323ab30 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 323ac40:	0100c974 	movhi	r4,805
 323ac44:	21097404 	addi	r4,r4,9680
 323ac48:	e17fff17 	ldw	r5,-4(fp)
 323ac4c:	01800044 	movi	r6,1
 323ac50:	01c07fc4 	movi	r7,511
 323ac54:	323ab300 	call	323ab30 <alt_open_fd>
}  
 323ac58:	e037883a 	mov	sp,fp
 323ac5c:	dfc00117 	ldw	ra,4(sp)
 323ac60:	df000017 	ldw	fp,0(sp)
 323ac64:	dec00204 	addi	sp,sp,8
 323ac68:	f800283a 	ret

0323ac6c <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
 323ac6c:	deffef04 	addi	sp,sp,-68
 323ac70:	df001015 	stw	fp,64(sp)
 323ac74:	df001004 	addi	fp,sp,64
 323ac78:	e13ffc15 	stw	r4,-16(fp)
 323ac7c:	e17ffd15 	stw	r5,-12(fp)
 323ac80:	e1bffe15 	stw	r6,-8(fp)
  int rc = -EINVAL;  
 323ac84:	00bffa84 	movi	r2,-22
 323ac88:	e0bffb15 	stw	r2,-20(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 323ac8c:	e0bffc17 	ldw	r2,-16(fp)
 323ac90:	10800828 	cmpgeui	r2,r2,32
 323ac94:	1000601e 	bne	r2,zero,323ae18 <alt_irq_register+0x1ac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 323ac98:	0005303a 	rdctl	r2,status
 323ac9c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 323aca0:	e0fff917 	ldw	r3,-28(fp)
 323aca4:	00bfff84 	movi	r2,-2
 323aca8:	1884703a 	and	r2,r3,r2
 323acac:	1001703a 	wrctl	status,r2
  
  return context;
 323acb0:	e0bff917 	ldw	r2,-28(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
 323acb4:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = handler;
 323acb8:	e0bffc17 	ldw	r2,-16(fp)
 323acbc:	00c0c9b4 	movhi	r3,806
 323acc0:	18f56904 	addi	r3,r3,-10844
 323acc4:	100490fa 	slli	r2,r2,3
 323acc8:	10c7883a 	add	r3,r2,r3
 323accc:	e0bffe17 	ldw	r2,-8(fp)
 323acd0:	18800015 	stw	r2,0(r3)
    alt_irq[id].context = context;
 323acd4:	e0bffc17 	ldw	r2,-16(fp)
 323acd8:	00c0c9b4 	movhi	r3,806
 323acdc:	18f56904 	addi	r3,r3,-10844
 323ace0:	100490fa 	slli	r2,r2,3
 323ace4:	10c5883a 	add	r2,r2,r3
 323ace8:	10c00104 	addi	r3,r2,4
 323acec:	e0bffd17 	ldw	r2,-12(fp)
 323acf0:	18800015 	stw	r2,0(r3)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
 323acf4:	e0bffe17 	ldw	r2,-8(fp)
 323acf8:	1005003a 	cmpeq	r2,r2,zero
 323acfc:	1000201e 	bne	r2,zero,323ad80 <alt_irq_register+0x114>
 323ad00:	e0bffc17 	ldw	r2,-16(fp)
 323ad04:	e0bff715 	stw	r2,-36(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 323ad08:	0005303a 	rdctl	r2,status
 323ad0c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 323ad10:	e0fff617 	ldw	r3,-40(fp)
 323ad14:	00bfff84 	movi	r2,-2
 323ad18:	1884703a 	and	r2,r3,r2
 323ad1c:	1001703a 	wrctl	status,r2
  
  return context;
 323ad20:	e0bff617 	ldw	r2,-40(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 323ad24:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
 323ad28:	e0fff717 	ldw	r3,-36(fp)
 323ad2c:	00800044 	movi	r2,1
 323ad30:	10c4983a 	sll	r2,r2,r3
 323ad34:	1007883a 	mov	r3,r2
 323ad38:	0080c974 	movhi	r2,805
 323ad3c:	10935004 	addi	r2,r2,19776
 323ad40:	10800017 	ldw	r2,0(r2)
 323ad44:	1886b03a 	or	r3,r3,r2
 323ad48:	0080c974 	movhi	r2,805
 323ad4c:	10935004 	addi	r2,r2,19776
 323ad50:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 323ad54:	0080c974 	movhi	r2,805
 323ad58:	10935004 	addi	r2,r2,19776
 323ad5c:	10800017 	ldw	r2,0(r2)
 323ad60:	100170fa 	wrctl	ienable,r2
 323ad64:	e0bff817 	ldw	r2,-32(fp)
 323ad68:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 323ad6c:	e0bff517 	ldw	r2,-44(fp)
 323ad70:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 323ad74:	0005883a 	mov	r2,zero
 323ad78:	e0bfff15 	stw	r2,-4(fp)
 323ad7c:	00002006 	br	323ae00 <alt_irq_register+0x194>
 323ad80:	e0bffc17 	ldw	r2,-16(fp)
 323ad84:	e0bff315 	stw	r2,-52(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 323ad88:	0005303a 	rdctl	r2,status
 323ad8c:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 323ad90:	e0fff217 	ldw	r3,-56(fp)
 323ad94:	00bfff84 	movi	r2,-2
 323ad98:	1884703a 	and	r2,r3,r2
 323ad9c:	1001703a 	wrctl	status,r2
  
  return context;
 323ada0:	e0bff217 	ldw	r2,-56(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 323ada4:	e0bff415 	stw	r2,-48(fp)

  alt_irq_active &= ~(1 << id);
 323ada8:	e0fff317 	ldw	r3,-52(fp)
 323adac:	00800044 	movi	r2,1
 323adb0:	10c4983a 	sll	r2,r2,r3
 323adb4:	0084303a 	nor	r2,zero,r2
 323adb8:	1007883a 	mov	r3,r2
 323adbc:	0080c974 	movhi	r2,805
 323adc0:	10935004 	addi	r2,r2,19776
 323adc4:	10800017 	ldw	r2,0(r2)
 323adc8:	1886703a 	and	r3,r3,r2
 323adcc:	0080c974 	movhi	r2,805
 323add0:	10935004 	addi	r2,r2,19776
 323add4:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 323add8:	0080c974 	movhi	r2,805
 323addc:	10935004 	addi	r2,r2,19776
 323ade0:	10800017 	ldw	r2,0(r2)
 323ade4:	100170fa 	wrctl	ienable,r2
 323ade8:	e0bff417 	ldw	r2,-48(fp)
 323adec:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 323adf0:	e0bff117 	ldw	r2,-60(fp)
 323adf4:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 323adf8:	0005883a 	mov	r2,zero
 323adfc:	e0bfff15 	stw	r2,-4(fp)
 323ae00:	e0bfff17 	ldw	r2,-4(fp)
 323ae04:	e0bffb15 	stw	r2,-20(fp)
 323ae08:	e0bffa17 	ldw	r2,-24(fp)
 323ae0c:	e0bff015 	stw	r2,-64(fp)
 323ae10:	e0bff017 	ldw	r2,-64(fp)
 323ae14:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
 323ae18:	e0bffb17 	ldw	r2,-20(fp)
}
 323ae1c:	e037883a 	mov	sp,fp
 323ae20:	df000017 	ldw	fp,0(sp)
 323ae24:	dec00104 	addi	sp,sp,4
 323ae28:	f800283a 	ret

0323ae2c <alt_read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 323ae2c:	defff704 	addi	sp,sp,-36
 323ae30:	dfc00815 	stw	ra,32(sp)
 323ae34:	df000715 	stw	fp,28(sp)
 323ae38:	df000704 	addi	fp,sp,28
 323ae3c:	e13ffb15 	stw	r4,-20(fp)
 323ae40:	e17ffc15 	stw	r5,-16(fp)
 323ae44:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 323ae48:	e0bffb17 	ldw	r2,-20(fp)
 323ae4c:	1004803a 	cmplt	r2,r2,zero
 323ae50:	1000081e 	bne	r2,zero,323ae74 <alt_read+0x48>
 323ae54:	e0bffb17 	ldw	r2,-20(fp)
 323ae58:	10800324 	muli	r2,r2,12
 323ae5c:	1007883a 	mov	r3,r2
 323ae60:	0080c974 	movhi	r2,805
 323ae64:	10896e04 	addi	r2,r2,9656
 323ae68:	1887883a 	add	r3,r3,r2
 323ae6c:	e0ffff15 	stw	r3,-4(fp)
 323ae70:	00000106 	br	323ae78 <alt_read+0x4c>
 323ae74:	e03fff15 	stw	zero,-4(fp)
 323ae78:	e0bfff17 	ldw	r2,-4(fp)
 323ae7c:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 323ae80:	e0bffa17 	ldw	r2,-24(fp)
 323ae84:	1005003a 	cmpeq	r2,r2,zero
 323ae88:	1000241e 	bne	r2,zero,323af1c <alt_read+0xf0>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 323ae8c:	e0bffa17 	ldw	r2,-24(fp)
 323ae90:	10800217 	ldw	r2,8(r2)
 323ae94:	108000cc 	andi	r2,r2,3
 323ae98:	10800060 	cmpeqi	r2,r2,1
 323ae9c:	10001a1e 	bne	r2,zero,323af08 <alt_read+0xdc>
 323aea0:	e0bffa17 	ldw	r2,-24(fp)
 323aea4:	10800017 	ldw	r2,0(r2)
 323aea8:	10800517 	ldw	r2,20(r2)
 323aeac:	1005003a 	cmpeq	r2,r2,zero
 323aeb0:	1000151e 	bne	r2,zero,323af08 <alt_read+0xdc>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 323aeb4:	e0bffa17 	ldw	r2,-24(fp)
 323aeb8:	10800017 	ldw	r2,0(r2)
 323aebc:	10800517 	ldw	r2,20(r2)
 323aec0:	e17ffc17 	ldw	r5,-16(fp)
 323aec4:	e1bffd17 	ldw	r6,-12(fp)
 323aec8:	e13ffa17 	ldw	r4,-24(fp)
 323aecc:	103ee83a 	callr	r2
 323aed0:	e0bff915 	stw	r2,-28(fp)
 323aed4:	e0bff917 	ldw	r2,-28(fp)
 323aed8:	1004403a 	cmpge	r2,r2,zero
 323aedc:	1000071e 	bne	r2,zero,323aefc <alt_read+0xd0>
        {
          ALT_ERRNO = -rval;
 323aee0:	323af4c0 	call	323af4c <alt_get_errno>
 323aee4:	e0fff917 	ldw	r3,-28(fp)
 323aee8:	00c7c83a 	sub	r3,zero,r3
 323aeec:	10c00015 	stw	r3,0(r2)
          return -1;
 323aef0:	00bfffc4 	movi	r2,-1
 323aef4:	e0bffe15 	stw	r2,-8(fp)
 323aef8:	00000e06 	br	323af34 <alt_read+0x108>
        }
        return rval;
 323aefc:	e0bff917 	ldw	r2,-28(fp)
 323af00:	e0bffe15 	stw	r2,-8(fp)
 323af04:	00000b06 	br	323af34 <alt_read+0x108>
      }
      else
      {
        ALT_ERRNO = EACCES;
 323af08:	323af4c0 	call	323af4c <alt_get_errno>
 323af0c:	1007883a 	mov	r3,r2
 323af10:	00800344 	movi	r2,13
 323af14:	18800015 	stw	r2,0(r3)
 323af18:	00000406 	br	323af2c <alt_read+0x100>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 323af1c:	323af4c0 	call	323af4c <alt_get_errno>
 323af20:	1007883a 	mov	r3,r2
 323af24:	00801444 	movi	r2,81
 323af28:	18800015 	stw	r2,0(r3)
  }
  return -1;
 323af2c:	00bfffc4 	movi	r2,-1
 323af30:	e0bffe15 	stw	r2,-8(fp)
 323af34:	e0bffe17 	ldw	r2,-8(fp)
}
 323af38:	e037883a 	mov	sp,fp
 323af3c:	dfc00117 	ldw	ra,4(sp)
 323af40:	df000017 	ldw	fp,0(sp)
 323af44:	dec00204 	addi	sp,sp,8
 323af48:	f800283a 	ret

0323af4c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 323af4c:	defffd04 	addi	sp,sp,-12
 323af50:	dfc00215 	stw	ra,8(sp)
 323af54:	df000115 	stw	fp,4(sp)
 323af58:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 323af5c:	0080c974 	movhi	r2,805
 323af60:	108aa504 	addi	r2,r2,10900
 323af64:	10800017 	ldw	r2,0(r2)
 323af68:	1005003a 	cmpeq	r2,r2,zero
 323af6c:	1000061e 	bne	r2,zero,323af88 <alt_get_errno+0x3c>
 323af70:	0080c974 	movhi	r2,805
 323af74:	108aa504 	addi	r2,r2,10900
 323af78:	10800017 	ldw	r2,0(r2)
 323af7c:	103ee83a 	callr	r2
 323af80:	e0bfff15 	stw	r2,-4(fp)
 323af84:	00000306 	br	323af94 <alt_get_errno+0x48>
 323af88:	0080c974 	movhi	r2,805
 323af8c:	1092f804 	addi	r2,r2,19424
 323af90:	e0bfff15 	stw	r2,-4(fp)
 323af94:	e0bfff17 	ldw	r2,-4(fp)
}
 323af98:	e037883a 	mov	sp,fp
 323af9c:	dfc00117 	ldw	ra,4(sp)
 323afa0:	df000017 	ldw	fp,0(sp)
 323afa4:	dec00204 	addi	sp,sp,8
 323afa8:	f800283a 	ret

0323afac <alt_remap_cached>:
 * Convert a pointer to a block of uncached memory, into a block of
 * cached memory.
 */

void* alt_remap_cached (volatile void* ptr, alt_u32 len)
{
 323afac:	defffd04 	addi	sp,sp,-12
 323afb0:	df000215 	stw	fp,8(sp)
 323afb4:	df000204 	addi	fp,sp,8
 323afb8:	e13ffe15 	stw	r4,-8(fp)
 323afbc:	e17fff15 	stw	r5,-4(fp)
  return (void*) (((alt_u32) ptr) & ~BYPASS_DCACHE_MASK);
 323afc0:	e0bffe17 	ldw	r2,-8(fp)
 323afc4:	1007883a 	mov	r3,r2
 323afc8:	00a00034 	movhi	r2,32768
 323afcc:	10bfffc4 	addi	r2,r2,-1
 323afd0:	1884703a 	and	r2,r3,r2
}
 323afd4:	e037883a 	mov	sp,fp
 323afd8:	df000017 	ldw	fp,0(sp)
 323afdc:	dec00104 	addi	sp,sp,4
 323afe0:	f800283a 	ret

0323afe4 <alt_remap_uncached>:
 * Convert a pointer to a block of cached memory, into a block of
 * uncached memory.
 */

volatile void* alt_remap_uncached (void* ptr, alt_u32 len)
{
 323afe4:	defffc04 	addi	sp,sp,-16
 323afe8:	dfc00315 	stw	ra,12(sp)
 323afec:	df000215 	stw	fp,8(sp)
 323aff0:	df000204 	addi	fp,sp,8
 323aff4:	e13ffe15 	stw	r4,-8(fp)
 323aff8:	e17fff15 	stw	r5,-4(fp)
  alt_dcache_flush (ptr, len);
 323affc:	e13ffe17 	ldw	r4,-8(fp)
 323b000:	e17fff17 	ldw	r5,-4(fp)
 323b004:	323a5940 	call	323a594 <alt_dcache_flush>
  return (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK);
 323b008:	e0bffe17 	ldw	r2,-8(fp)
 323b00c:	10a00034 	orhi	r2,r2,32768
}
 323b010:	e037883a 	mov	sp,fp
 323b014:	dfc00117 	ldw	ra,4(sp)
 323b018:	df000017 	ldw	fp,0(sp)
 323b01c:	dec00204 	addi	sp,sp,8
 323b020:	f800283a 	ret

0323b024 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 323b024:	defffa04 	addi	sp,sp,-24
 323b028:	df000515 	stw	fp,20(sp)
 323b02c:	df000504 	addi	fp,sp,20
 323b030:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 323b034:	0005303a 	rdctl	r2,status
 323b038:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 323b03c:	e0fffd17 	ldw	r3,-12(fp)
 323b040:	00bfff84 	movi	r2,-2
 323b044:	1884703a 	and	r2,r3,r2
 323b048:	1001703a 	wrctl	status,r2
  
  return context;
 323b04c:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 323b050:	e0bffe15 	stw	r2,-8(fp)
  alt_llist_remove (&alarm->llist);
 323b054:	e0bfff17 	ldw	r2,-4(fp)
 323b058:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 323b05c:	e0bffc17 	ldw	r2,-16(fp)
 323b060:	10c00017 	ldw	r3,0(r2)
 323b064:	e0bffc17 	ldw	r2,-16(fp)
 323b068:	10800117 	ldw	r2,4(r2)
 323b06c:	18800115 	stw	r2,4(r3)
  entry->previous->next = entry->next;
 323b070:	e0bffc17 	ldw	r2,-16(fp)
 323b074:	10c00117 	ldw	r3,4(r2)
 323b078:	e0bffc17 	ldw	r2,-16(fp)
 323b07c:	10800017 	ldw	r2,0(r2)
 323b080:	18800015 	stw	r2,0(r3)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 323b084:	e0fffc17 	ldw	r3,-16(fp)
 323b088:	e0bffc17 	ldw	r2,-16(fp)
 323b08c:	18800115 	stw	r2,4(r3)
  entry->next     = entry;
 323b090:	e0fffc17 	ldw	r3,-16(fp)
 323b094:	e0bffc17 	ldw	r2,-16(fp)
 323b098:	18800015 	stw	r2,0(r3)
 323b09c:	e0bffe17 	ldw	r2,-8(fp)
 323b0a0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 323b0a4:	e0bffb17 	ldw	r2,-20(fp)
 323b0a8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 323b0ac:	e037883a 	mov	sp,fp
 323b0b0:	df000017 	ldw	fp,0(sp)
 323b0b4:	dec00104 	addi	sp,sp,4
 323b0b8:	f800283a 	ret

0323b0bc <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 323b0bc:	defffb04 	addi	sp,sp,-20
 323b0c0:	dfc00415 	stw	ra,16(sp)
 323b0c4:	df000315 	stw	fp,12(sp)
 323b0c8:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 323b0cc:	d0a04517 	ldw	r2,-32492(gp)
 323b0d0:	e0bffe15 	stw	r2,-8(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 323b0d4:	d0a8f017 	ldw	r2,-23616(gp)
 323b0d8:	10800044 	addi	r2,r2,1
 323b0dc:	d0a8f015 	stw	r2,-23616(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 323b0e0:	00003106 	br	323b1a8 <alt_tick+0xec>
  {
    next = (alt_alarm*) alarm->llist.next;
 323b0e4:	e0bffe17 	ldw	r2,-8(fp)
 323b0e8:	10800017 	ldw	r2,0(r2)
 323b0ec:	e0bfff15 	stw	r2,-4(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 323b0f0:	e0bffe17 	ldw	r2,-8(fp)
 323b0f4:	10800403 	ldbu	r2,16(r2)
 323b0f8:	10803fcc 	andi	r2,r2,255
 323b0fc:	1005003a 	cmpeq	r2,r2,zero
 323b100:	1000051e 	bne	r2,zero,323b118 <alt_tick+0x5c>
 323b104:	d0a8f017 	ldw	r2,-23616(gp)
 323b108:	1004c03a 	cmpne	r2,r2,zero
 323b10c:	1000021e 	bne	r2,zero,323b118 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
 323b110:	e0bffe17 	ldw	r2,-8(fp)
 323b114:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 323b118:	e0bffe17 	ldw	r2,-8(fp)
 323b11c:	10c00217 	ldw	r3,8(r2)
 323b120:	d0a8f017 	ldw	r2,-23616(gp)
 323b124:	10c01e36 	bltu	r2,r3,323b1a0 <alt_tick+0xe4>
 323b128:	e0bffe17 	ldw	r2,-8(fp)
 323b12c:	10800403 	ldbu	r2,16(r2)
 323b130:	10803fcc 	andi	r2,r2,255
 323b134:	1004c03a 	cmpne	r2,r2,zero
 323b138:	1000191e 	bne	r2,zero,323b1a0 <alt_tick+0xe4>
    {
      next_callback = alarm->callback (alarm->context);
 323b13c:	e0bffe17 	ldw	r2,-8(fp)
 323b140:	10c00317 	ldw	r3,12(r2)
 323b144:	e0bffe17 	ldw	r2,-8(fp)
 323b148:	11000517 	ldw	r4,20(r2)
 323b14c:	183ee83a 	callr	r3
 323b150:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 323b154:	e0bffd17 	ldw	r2,-12(fp)
 323b158:	1004c03a 	cmpne	r2,r2,zero
 323b15c:	1000031e 	bne	r2,zero,323b16c <alt_tick+0xb0>
      {
        alt_alarm_stop (alarm);
 323b160:	e13ffe17 	ldw	r4,-8(fp)
 323b164:	323b0240 	call	323b024 <alt_alarm_stop>
 323b168:	00000d06 	br	323b1a0 <alt_tick+0xe4>
      }
      else
      {
        alarm->time += next_callback;
 323b16c:	e0bffe17 	ldw	r2,-8(fp)
 323b170:	10c00217 	ldw	r3,8(r2)
 323b174:	e0bffd17 	ldw	r2,-12(fp)
 323b178:	1887883a 	add	r3,r3,r2
 323b17c:	e0bffe17 	ldw	r2,-8(fp)
 323b180:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 323b184:	e0bffe17 	ldw	r2,-8(fp)
 323b188:	10c00217 	ldw	r3,8(r2)
 323b18c:	d0a8f017 	ldw	r2,-23616(gp)
 323b190:	1880032e 	bgeu	r3,r2,323b1a0 <alt_tick+0xe4>
        {
          alarm->rollover = 1;
 323b194:	e0fffe17 	ldw	r3,-8(fp)
 323b198:	00800044 	movi	r2,1
 323b19c:	18800405 	stb	r2,16(r3)
        }
      }
    }
    alarm = next;
 323b1a0:	e0bfff17 	ldw	r2,-4(fp)
 323b1a4:	e0bffe15 	stw	r2,-8(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 323b1a8:	d0e04504 	addi	r3,gp,-32492
 323b1ac:	e0bffe17 	ldw	r2,-8(fp)
 323b1b0:	10ffcc1e 	bne	r2,r3,323b0e4 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 323b1b4:	32162cc0 	call	32162cc <OSTimeTick>
}
 323b1b8:	e037883a 	mov	sp,fp
 323b1bc:	dfc00117 	ldw	ra,4(sp)
 323b1c0:	df000017 	ldw	fp,0(sp)
 323b1c4:	dec00204 	addi	sp,sp,8
 323b1c8:	f800283a 	ret

0323b1cc <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 323b1cc:	defff904 	addi	sp,sp,-28
 323b1d0:	dfc00615 	stw	ra,24(sp)
 323b1d4:	df000515 	stw	fp,20(sp)
 323b1d8:	dc000415 	stw	r16,16(sp)
 323b1dc:	df000404 	addi	fp,sp,16
 323b1e0:	e13ffe15 	stw	r4,-8(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
 323b1e4:	0080c974 	movhi	r2,805
 323b1e8:	10930644 	addi	r2,r2,19481
 323b1ec:	10800003 	ldbu	r2,0(r2)
 323b1f0:	10803fcc 	andi	r2,r2,255
 323b1f4:	1004c03a 	cmpne	r2,r2,zero
 323b1f8:	1000041e 	bne	r2,zero,323b20c <usleep+0x40>
  {
    return alt_busy_sleep (us);
 323b1fc:	e13ffe17 	ldw	r4,-8(fp)
 323b200:	324a57c0 	call	324a57c <alt_busy_sleep>
 323b204:	e0bfff15 	stw	r2,-4(fp)
 323b208:	00002f06 	br	323b2c8 <usleep+0xfc>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 323b20c:	0080c974 	movhi	r2,805
 323b210:	10935104 	addi	r2,r2,19780
 323b214:	10800017 	ldw	r2,0(r2)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
 323b218:	e0bffc15 	stw	r2,-16(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
 323b21c:	e13ffe17 	ldw	r4,-8(fp)
 323b220:	014003f4 	movhi	r5,15
 323b224:	29509004 	addi	r5,r5,16960
 323b228:	32047c00 	call	32047c0 <__udivsi3>
 323b22c:	1007883a 	mov	r3,r2
 323b230:	e0bffc17 	ldw	r2,-16(fp)
 323b234:	18a1383a 	mul	r16,r3,r2
 323b238:	e13ffe17 	ldw	r4,-8(fp)
 323b23c:	014003f4 	movhi	r5,15
 323b240:	29509004 	addi	r5,r5,16960
 323b244:	32047c80 	call	32047c8 <__umodsi3>
 323b248:	1007883a 	mov	r3,r2
 323b24c:	e0bffc17 	ldw	r2,-16(fp)
 323b250:	1889383a 	mul	r4,r3,r2
 323b254:	014003f4 	movhi	r5,15
 323b258:	29509004 	addi	r5,r5,16960
 323b25c:	32047c00 	call	32047c0 <__udivsi3>
 323b260:	8085883a 	add	r2,r16,r2
 323b264:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 323b268:	00000706 	br	323b288 <usleep+0xbc>
  {
    OSTimeDly(0xffff);
 323b26c:	013fffd4 	movui	r4,65535
 323b270:	321d27c0 	call	321d27c <OSTimeDly>
    ticks -= 0xffff;
 323b274:	e0bffd17 	ldw	r2,-12(fp)
 323b278:	00fffff4 	movhi	r3,65535
 323b27c:	18c00044 	addi	r3,r3,1
 323b280:	10c5883a 	add	r2,r2,r3
 323b284:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 323b288:	e0fffd17 	ldw	r3,-12(fp)
 323b28c:	00bfffd4 	movui	r2,65535
 323b290:	10fff636 	bltu	r2,r3,323b26c <usleep+0xa0>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
 323b294:	e0bffd17 	ldw	r2,-12(fp)
 323b298:	113fffcc 	andi	r4,r2,65535
 323b29c:	321d27c0 	call	321d27c <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
 323b2a0:	010003f4 	movhi	r4,15
 323b2a4:	21109004 	addi	r4,r4,16960
 323b2a8:	e17ffc17 	ldw	r5,-16(fp)
 323b2ac:	32047c00 	call	32047c0 <__udivsi3>
 323b2b0:	100b883a 	mov	r5,r2
 323b2b4:	e13ffe17 	ldw	r4,-8(fp)
 323b2b8:	32047c80 	call	32047c8 <__umodsi3>
 323b2bc:	1009883a 	mov	r4,r2
 323b2c0:	324a57c0 	call	324a57c <alt_busy_sleep>

  return 0;  
 323b2c4:	e03fff15 	stw	zero,-4(fp)
 323b2c8:	e0bfff17 	ldw	r2,-4(fp)
}
 323b2cc:	e037883a 	mov	sp,fp
 323b2d0:	dfc00217 	ldw	ra,8(sp)
 323b2d4:	df000117 	ldw	fp,4(sp)
 323b2d8:	dc000017 	ldw	r16,0(sp)
 323b2dc:	dec00304 	addi	sp,sp,12
 323b2e0:	f800283a 	ret

0323b2e4 <alt_write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 323b2e4:	defff704 	addi	sp,sp,-36
 323b2e8:	dfc00815 	stw	ra,32(sp)
 323b2ec:	df000715 	stw	fp,28(sp)
 323b2f0:	df000704 	addi	fp,sp,28
 323b2f4:	e13ffb15 	stw	r4,-20(fp)
 323b2f8:	e17ffc15 	stw	r5,-16(fp)
 323b2fc:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 323b300:	e0bffb17 	ldw	r2,-20(fp)
 323b304:	1004803a 	cmplt	r2,r2,zero
 323b308:	1000081e 	bne	r2,zero,323b32c <alt_write+0x48>
 323b30c:	e0bffb17 	ldw	r2,-20(fp)
 323b310:	10800324 	muli	r2,r2,12
 323b314:	1007883a 	mov	r3,r2
 323b318:	0080c974 	movhi	r2,805
 323b31c:	10896e04 	addi	r2,r2,9656
 323b320:	1887883a 	add	r3,r3,r2
 323b324:	e0ffff15 	stw	r3,-4(fp)
 323b328:	00000106 	br	323b330 <alt_write+0x4c>
 323b32c:	e03fff15 	stw	zero,-4(fp)
 323b330:	e0bfff17 	ldw	r2,-4(fp)
 323b334:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 323b338:	e0bffa17 	ldw	r2,-24(fp)
 323b33c:	1005003a 	cmpeq	r2,r2,zero
 323b340:	1000241e 	bne	r2,zero,323b3d4 <alt_write+0xf0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 323b344:	e0bffa17 	ldw	r2,-24(fp)
 323b348:	10800217 	ldw	r2,8(r2)
 323b34c:	108000cc 	andi	r2,r2,3
 323b350:	1005003a 	cmpeq	r2,r2,zero
 323b354:	10001a1e 	bne	r2,zero,323b3c0 <alt_write+0xdc>
 323b358:	e0bffa17 	ldw	r2,-24(fp)
 323b35c:	10800017 	ldw	r2,0(r2)
 323b360:	10800617 	ldw	r2,24(r2)
 323b364:	1005003a 	cmpeq	r2,r2,zero
 323b368:	1000151e 	bne	r2,zero,323b3c0 <alt_write+0xdc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 323b36c:	e0bffa17 	ldw	r2,-24(fp)
 323b370:	10800017 	ldw	r2,0(r2)
 323b374:	10800617 	ldw	r2,24(r2)
 323b378:	e17ffc17 	ldw	r5,-16(fp)
 323b37c:	e1bffd17 	ldw	r6,-12(fp)
 323b380:	e13ffa17 	ldw	r4,-24(fp)
 323b384:	103ee83a 	callr	r2
 323b388:	e0bff915 	stw	r2,-28(fp)
 323b38c:	e0bff917 	ldw	r2,-28(fp)
 323b390:	1004403a 	cmpge	r2,r2,zero
 323b394:	1000071e 	bne	r2,zero,323b3b4 <alt_write+0xd0>
      {
        ALT_ERRNO = -rval;
 323b398:	323b4040 	call	323b404 <alt_get_errno>
 323b39c:	e0fff917 	ldw	r3,-28(fp)
 323b3a0:	00c7c83a 	sub	r3,zero,r3
 323b3a4:	10c00015 	stw	r3,0(r2)
        return -1;
 323b3a8:	00bfffc4 	movi	r2,-1
 323b3ac:	e0bffe15 	stw	r2,-8(fp)
 323b3b0:	00000e06 	br	323b3ec <alt_write+0x108>
      }
      return rval;
 323b3b4:	e0bff917 	ldw	r2,-28(fp)
 323b3b8:	e0bffe15 	stw	r2,-8(fp)
 323b3bc:	00000b06 	br	323b3ec <alt_write+0x108>
    }
    else
    {
      ALT_ERRNO = EACCES;
 323b3c0:	323b4040 	call	323b404 <alt_get_errno>
 323b3c4:	1007883a 	mov	r3,r2
 323b3c8:	00800344 	movi	r2,13
 323b3cc:	18800015 	stw	r2,0(r3)
 323b3d0:	00000406 	br	323b3e4 <alt_write+0x100>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 323b3d4:	323b4040 	call	323b404 <alt_get_errno>
 323b3d8:	1007883a 	mov	r3,r2
 323b3dc:	00801444 	movi	r2,81
 323b3e0:	18800015 	stw	r2,0(r3)
  }
  return -1;
 323b3e4:	00bfffc4 	movi	r2,-1
 323b3e8:	e0bffe15 	stw	r2,-8(fp)
 323b3ec:	e0bffe17 	ldw	r2,-8(fp)
}
 323b3f0:	e037883a 	mov	sp,fp
 323b3f4:	dfc00117 	ldw	ra,4(sp)
 323b3f8:	df000017 	ldw	fp,0(sp)
 323b3fc:	dec00204 	addi	sp,sp,8
 323b400:	f800283a 	ret

0323b404 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 323b404:	defffd04 	addi	sp,sp,-12
 323b408:	dfc00215 	stw	ra,8(sp)
 323b40c:	df000115 	stw	fp,4(sp)
 323b410:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 323b414:	0080c974 	movhi	r2,805
 323b418:	108aa504 	addi	r2,r2,10900
 323b41c:	10800017 	ldw	r2,0(r2)
 323b420:	1005003a 	cmpeq	r2,r2,zero
 323b424:	1000061e 	bne	r2,zero,323b440 <alt_get_errno+0x3c>
 323b428:	0080c974 	movhi	r2,805
 323b42c:	108aa504 	addi	r2,r2,10900
 323b430:	10800017 	ldw	r2,0(r2)
 323b434:	103ee83a 	callr	r2
 323b438:	e0bfff15 	stw	r2,-4(fp)
 323b43c:	00000306 	br	323b44c <alt_get_errno+0x48>
 323b440:	0080c974 	movhi	r2,805
 323b444:	1092f804 	addi	r2,r2,19424
 323b448:	e0bfff15 	stw	r2,-4(fp)
 323b44c:	e0bfff17 	ldw	r2,-4(fp)
}
 323b450:	e037883a 	mov	sp,fp
 323b454:	dfc00117 	ldw	ra,4(sp)
 323b458:	df000017 	ldw	fp,0(sp)
 323b45c:	dec00204 	addi	sp,sp,8
 323b460:	f800283a 	ret

0323b464 <altera_nios2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_irq_init(void) 
{
 323b464:	deffff04 	addi	sp,sp,-4
 323b468:	df000015 	stw	fp,0(sp)
 323b46c:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 323b470:	000170fa 	wrctl	ienable,zero
}
 323b474:	e037883a 	mov	sp,fp
 323b478:	df000017 	ldw	fp,0(sp)
 323b47c:	dec00104 	addi	sp,sp,4
 323b480:	f800283a 	ret

0323b484 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
 323b484:	defff504 	addi	sp,sp,-44
      bltu  sp, et, .Lstack_overflow

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
 323b488:	d0e00117 	ldw	r3,-32764(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
 323b48c:	d128b317 	ldw	r4,-23860(gp)

      stw ra,  0(sp)
 323b490:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
 323b494:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
 323b498:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
 323b49c:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
 323b4a0:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
 323b4a4:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
 323b4a8:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
 323b4ac:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
 323b4b0:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
 323b4b4:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
 323b4b8:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
 323b4bc:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 323b4c0:	323b8a40 	call	323b8a4 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
 323b4c4:	d128ae17 	ldw	r4,-23880(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
 323b4c8:	d168a607 	ldb	r5,-23912(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
 323b4cc:	d128b315 	stw	r4,-23860(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
 323b4d0:	d168a645 	stb	r5,-23911(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
 323b4d4:	26c00017 	ldw	sp,0(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
 323b4d8:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
 323b4dc:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
 323b4e0:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
 323b4e4:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
 323b4e8:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
 323b4ec:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
 323b4f0:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
 323b4f4:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
 323b4f8:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
 323b4fc:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
 323b500:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
 323b504:	d0e00115 	stw	r3,-32764(gp)

      stw et, %gprel(alt_stack_limit_value)(gp)

#endif

      addi sp, sp, 44
 323b508:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
 323b50c:	f800283a 	ret

0323b510 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
 323b510:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
 323b514:	047fff84 	movi	r17,-2
      and   r18, r18, r17
 323b518:	9464703a 	and	r18,r18,r17
      wrctl status, r18
 323b51c:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 323b520:	323b8a40 	call	323b8a4 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
 323b524:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
 323b528:	d4a8a445 	stb	r18,-23919(gp)

      /*
       * start execution of the new task.
       */

      br 9b
 323b52c:	003fe506 	br	323b4c4 <OSCtxSw+0x40>

0323b530 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
 323b530:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
 323b534:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
 323b538:	10800054 	ori	r2,r2,1
      wrctl status, r2
 323b53c:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
 323b540:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
 323b544:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
 323b548:	dec00204 	addi	sp,sp,8

      callr r2
 323b54c:	103ee83a 	callr	r2

      nop
 323b550:	0001883a 	nop

0323b554 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
 323b554:	defff704 	addi	sp,sp,-36
 323b558:	dfc00815 	stw	ra,32(sp)
 323b55c:	df000715 	stw	fp,28(sp)
 323b560:	df000704 	addi	fp,sp,28
 323b564:	e13ffc15 	stw	r4,-16(fp)
 323b568:	e17ffd15 	stw	r5,-12(fp)
 323b56c:	e1bffe15 	stw	r6,-8(fp)
 323b570:	e1ffff0d 	sth	r7,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
 323b574:	e0bffe17 	ldw	r2,-8(fp)
 323b578:	1007883a 	mov	r3,r2
 323b57c:	00bfff04 	movi	r2,-4
 323b580:	1884703a 	and	r2,r3,r2
 323b584:	10bf0004 	addi	r2,r2,-1024
 323b588:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
 323b58c:	e0bff917 	ldw	r2,-28(fp)
 323b590:	10000015 	stw	zero,0(r2)
 323b594:	e0bff917 	ldw	r2,-28(fp)
 323b598:	10c0bb04 	addi	r3,r2,748
 323b59c:	e0bff917 	ldw	r2,-28(fp)
 323b5a0:	10c00115 	stw	r3,4(r2)
 323b5a4:	e0bff917 	ldw	r2,-28(fp)
 323b5a8:	1080bb04 	addi	r2,r2,748
 323b5ac:	10c01704 	addi	r3,r2,92
 323b5b0:	e0bff917 	ldw	r2,-28(fp)
 323b5b4:	10c00215 	stw	r3,8(r2)
 323b5b8:	e0bff917 	ldw	r2,-28(fp)
 323b5bc:	1080bb04 	addi	r2,r2,748
 323b5c0:	10c02e04 	addi	r3,r2,184
 323b5c4:	e0bff917 	ldw	r2,-28(fp)
 323b5c8:	10c00315 	stw	r3,12(r2)
 323b5cc:	e0bff917 	ldw	r2,-28(fp)
 323b5d0:	10000415 	stw	zero,16(r2)
 323b5d4:	e0bff917 	ldw	r2,-28(fp)
 323b5d8:	10800504 	addi	r2,r2,20
 323b5dc:	1009883a 	mov	r4,r2
 323b5e0:	01800644 	movi	r6,25
 323b5e4:	000b883a 	mov	r5,zero
 323b5e8:	3206c500 	call	3206c50 <memset>
 323b5ec:	e0bff917 	ldw	r2,-28(fp)
 323b5f0:	10000c15 	stw	zero,48(r2)
 323b5f4:	e0fff917 	ldw	r3,-28(fp)
 323b5f8:	0080c974 	movhi	r2,805
 323b5fc:	10be8404 	addi	r2,r2,-1520
 323b600:	18800d15 	stw	r2,52(r3)
 323b604:	e0bff917 	ldw	r2,-28(fp)
 323b608:	10000e15 	stw	zero,56(r2)
 323b60c:	e0bff917 	ldw	r2,-28(fp)
 323b610:	10000f15 	stw	zero,60(r2)
 323b614:	e0bff917 	ldw	r2,-28(fp)
 323b618:	10001015 	stw	zero,64(r2)
 323b61c:	e0bff917 	ldw	r2,-28(fp)
 323b620:	10001115 	stw	zero,68(r2)
 323b624:	e0bff917 	ldw	r2,-28(fp)
 323b628:	10001215 	stw	zero,72(r2)
 323b62c:	e0bff917 	ldw	r2,-28(fp)
 323b630:	10001315 	stw	zero,76(r2)
 323b634:	e0bff917 	ldw	r2,-28(fp)
 323b638:	10001415 	stw	zero,80(r2)
 323b63c:	e0bff917 	ldw	r2,-28(fp)
 323b640:	10001515 	stw	zero,84(r2)
 323b644:	e0bff917 	ldw	r2,-28(fp)
 323b648:	10001615 	stw	zero,88(r2)
 323b64c:	e0bff917 	ldw	r2,-28(fp)
 323b650:	10001715 	stw	zero,92(r2)
 323b654:	e0bff917 	ldw	r2,-28(fp)
 323b658:	10001805 	stb	zero,96(r2)
 323b65c:	e0bff917 	ldw	r2,-28(fp)
 323b660:	10801f04 	addi	r2,r2,124
 323b664:	10000015 	stw	zero,0(r2)
 323b668:	10000115 	stw	zero,4(r2)
 323b66c:	10000215 	stw	zero,8(r2)
 323b670:	10000315 	stw	zero,12(r2)
 323b674:	10000415 	stw	zero,16(r2)
 323b678:	10000515 	stw	zero,20(r2)
 323b67c:	10000615 	stw	zero,24(r2)
 323b680:	10000715 	stw	zero,28(r2)
 323b684:	10000815 	stw	zero,32(r2)
 323b688:	e0bff917 	ldw	r2,-28(fp)
 323b68c:	10002815 	stw	zero,160(r2)
 323b690:	e0fff917 	ldw	r3,-28(fp)
 323b694:	00800044 	movi	r2,1
 323b698:	18802915 	stw	r2,164(r3)
 323b69c:	18002a15 	stw	zero,168(r3)
 323b6a0:	e0fff917 	ldw	r3,-28(fp)
 323b6a4:	008cc384 	movi	r2,13070
 323b6a8:	18802b0d 	sth	r2,172(r3)
 323b6ac:	e0fff917 	ldw	r3,-28(fp)
 323b6b0:	00aaf344 	movi	r2,-21555
 323b6b4:	18802b8d 	sth	r2,174(r3)
 323b6b8:	e0fff917 	ldw	r3,-28(fp)
 323b6bc:	00848d04 	movi	r2,4660
 323b6c0:	18802c0d 	sth	r2,176(r3)
 323b6c4:	e0fff917 	ldw	r3,-28(fp)
 323b6c8:	00b99b44 	movi	r2,-6547
 323b6cc:	18802c8d 	sth	r2,178(r3)
 323b6d0:	e0fff917 	ldw	r3,-28(fp)
 323b6d4:	00b7bb04 	movi	r2,-8468
 323b6d8:	18802d0d 	sth	r2,180(r3)
 323b6dc:	e0fff917 	ldw	r3,-28(fp)
 323b6e0:	00800144 	movi	r2,5
 323b6e4:	18802d8d 	sth	r2,182(r3)
 323b6e8:	e0fff917 	ldw	r3,-28(fp)
 323b6ec:	008002c4 	movi	r2,11
 323b6f0:	18802e0d 	sth	r2,184(r3)
 323b6f4:	e0bff917 	ldw	r2,-28(fp)
 323b6f8:	10002f15 	stw	zero,188(r2)
 323b6fc:	e0bff917 	ldw	r2,-28(fp)
 323b700:	10003015 	stw	zero,192(r2)
 323b704:	e0bff917 	ldw	r2,-28(fp)
 323b708:	10003115 	stw	zero,196(r2)
 323b70c:	e0bff917 	ldw	r2,-28(fp)
 323b710:	10003215 	stw	zero,200(r2)
 323b714:	e0bff917 	ldw	r2,-28(fp)
 323b718:	10003315 	stw	zero,204(r2)
 323b71c:	e0bff917 	ldw	r2,-28(fp)
 323b720:	10003415 	stw	zero,208(r2)
 323b724:	e0bff917 	ldw	r2,-28(fp)
 323b728:	10003e15 	stw	zero,248(r2)
 323b72c:	e0bff917 	ldw	r2,-28(fp)
 323b730:	10003f15 	stw	zero,252(r2)
 323b734:	e0bff917 	ldw	r2,-28(fp)
 323b738:	10004015 	stw	zero,256(r2)
 323b73c:	e0bff917 	ldw	r2,-28(fp)
 323b740:	10004115 	stw	zero,260(r2)
 323b744:	e0bff917 	ldw	r2,-28(fp)
 323b748:	10004215 	stw	zero,264(r2)
 323b74c:	e0bff917 	ldw	r2,-28(fp)
 323b750:	10004315 	stw	zero,268(r2)
 323b754:	e0bff917 	ldw	r2,-28(fp)
 323b758:	10004415 	stw	zero,272(r2)
 323b75c:	e0bff917 	ldw	r2,-28(fp)
 323b760:	10004515 	stw	zero,276(r2)
 323b764:	e0bff917 	ldw	r2,-28(fp)
 323b768:	10004615 	stw	zero,280(r2)
 323b76c:	e0bff917 	ldw	r2,-28(fp)
 323b770:	10004715 	stw	zero,284(r2)
 323b774:	e0bff917 	ldw	r2,-28(fp)
 323b778:	10003505 	stb	zero,212(r2)
 323b77c:	e0bff917 	ldw	r2,-28(fp)
 323b780:	10003705 	stb	zero,220(r2)
 323b784:	e0bff917 	ldw	r2,-28(fp)
 323b788:	10003d15 	stw	zero,244(r2)
 323b78c:	e0bff917 	ldw	r2,-28(fp)
 323b790:	10005215 	stw	zero,328(r2)
 323b794:	e0bff917 	ldw	r2,-28(fp)
 323b798:	10005315 	stw	zero,332(r2)
 323b79c:	e0bff917 	ldw	r2,-28(fp)
 323b7a0:	10005415 	stw	zero,336(r2)
 323b7a4:	e0bff917 	ldw	r2,-28(fp)
 323b7a8:	10005515 	stw	zero,340(r2)
 323b7ac:	e0bff917 	ldw	r2,-28(fp)
 323b7b0:	1000b515 	stw	zero,724(r2)
 323b7b4:	e0bff917 	ldw	r2,-28(fp)
 323b7b8:	10007515 	stw	zero,468(r2)
 323b7bc:	e0bff917 	ldw	r2,-28(fp)
 323b7c0:	1000b715 	stw	zero,732(r2)
 323b7c4:	e0bff917 	ldw	r2,-28(fp)
 323b7c8:	1000b815 	stw	zero,736(r2)
 323b7cc:	e0bff917 	ldw	r2,-28(fp)
 323b7d0:	1000b915 	stw	zero,740(r2)
 323b7d4:	e0bff917 	ldw	r2,-28(fp)
 323b7d8:	1000ba15 	stw	zero,744(r2)
 323b7dc:	e0bff917 	ldw	r2,-28(fp)
 323b7e0:	1080bb04 	addi	r2,r2,748
 323b7e4:	1009883a 	mov	r4,r2
 323b7e8:	01804504 	movi	r6,276
 323b7ec:	000b883a 	mov	r5,zero
 323b7f0:	3206c500 	call	3206c50 <memset>
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
 323b7f4:	e0bff917 	ldw	r2,-28(fp)
 323b7f8:	e0bffb15 	stw	r2,-20(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
 323b7fc:	e0bffb17 	ldw	r2,-20(fp)
 323b800:	10bff304 	addi	r2,r2,-52
 323b804:	e0bffa15 	stw	r2,-24(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
 323b808:	e0bffa17 	ldw	r2,-24(fp)
 323b80c:	10c00c04 	addi	r3,r2,48
 323b810:	e0bffc17 	ldw	r2,-16(fp)
 323b814:	18800015 	stw	r2,0(r3)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
 323b818:	e0bffa17 	ldw	r2,-24(fp)
 323b81c:	10c00b04 	addi	r3,r2,44
 323b820:	e0bffd17 	ldw	r2,-12(fp)
 323b824:	18800015 	stw	r2,0(r3)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
 323b828:	e0bffa17 	ldw	r2,-24(fp)
 323b82c:	10c00a04 	addi	r3,r2,40
 323b830:	e0bff917 	ldw	r2,-28(fp)
 323b834:	18800015 	stw	r2,0(r3)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
 323b838:	0080c934 	movhi	r2,804
 323b83c:	10ad4c04 	addi	r2,r2,-19152
 323b840:	10c00104 	addi	r3,r2,4
 323b844:	e0bffa17 	ldw	r2,-24(fp)
 323b848:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
 323b84c:	e0bffa17 	ldw	r2,-24(fp)
}
 323b850:	e037883a 	mov	sp,fp
 323b854:	dfc00117 	ldw	ra,4(sp)
 323b858:	df000017 	ldw	fp,0(sp)
 323b85c:	dec00204 	addi	sp,sp,8
 323b860:	f800283a 	ret

0323b864 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
 323b864:	defffe04 	addi	sp,sp,-8
 323b868:	df000115 	stw	fp,4(sp)
 323b86c:	df000104 	addi	fp,sp,4
 323b870:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
 323b874:	e037883a 	mov	sp,fp
 323b878:	df000017 	ldw	fp,0(sp)
 323b87c:	dec00104 	addi	sp,sp,4
 323b880:	f800283a 	ret

0323b884 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
 323b884:	defffe04 	addi	sp,sp,-8
 323b888:	df000115 	stw	fp,4(sp)
 323b88c:	df000104 	addi	fp,sp,4
 323b890:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
 323b894:	e037883a 	mov	sp,fp
 323b898:	df000017 	ldw	fp,0(sp)
 323b89c:	dec00104 	addi	sp,sp,4
 323b8a0:	f800283a 	ret

0323b8a4 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
 323b8a4:	deffff04 	addi	sp,sp,-4
 323b8a8:	df000015 	stw	fp,0(sp)
 323b8ac:	d839883a 	mov	fp,sp
}
 323b8b0:	e037883a 	mov	sp,fp
 323b8b4:	df000017 	ldw	fp,0(sp)
 323b8b8:	dec00104 	addi	sp,sp,4
 323b8bc:	f800283a 	ret

0323b8c0 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
 323b8c0:	deffff04 	addi	sp,sp,-4
 323b8c4:	df000015 	stw	fp,0(sp)
 323b8c8:	d839883a 	mov	fp,sp
}
 323b8cc:	e037883a 	mov	sp,fp
 323b8d0:	df000017 	ldw	fp,0(sp)
 323b8d4:	dec00104 	addi	sp,sp,4
 323b8d8:	f800283a 	ret

0323b8dc <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
 323b8dc:	defffe04 	addi	sp,sp,-8
 323b8e0:	dfc00115 	stw	ra,4(sp)
 323b8e4:	df000015 	stw	fp,0(sp)
 323b8e8:	d839883a 	mov	fp,sp
    }
#endif  
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
 323b8ec:	322b0840 	call	322b084 <cticks_hook>
#endif
}
 323b8f0:	e037883a 	mov	sp,fp
 323b8f4:	dfc00117 	ldw	ra,4(sp)
 323b8f8:	df000017 	ldw	fp,0(sp)
 323b8fc:	dec00204 	addi	sp,sp,8
 323b900:	f800283a 	ret

0323b904 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
 323b904:	deffff04 	addi	sp,sp,-4
 323b908:	df000015 	stw	fp,0(sp)
 323b90c:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
#endif
}
 323b910:	e037883a 	mov	sp,fp
 323b914:	df000017 	ldw	fp,0(sp)
 323b918:	dec00104 	addi	sp,sp,4
 323b91c:	f800283a 	ret

0323b920 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
 323b920:	deffff04 	addi	sp,sp,-4
 323b924:	df000015 	stw	fp,0(sp)
 323b928:	d839883a 	mov	fp,sp
}
 323b92c:	e037883a 	mov	sp,fp
 323b930:	df000017 	ldw	fp,0(sp)
 323b934:	dec00104 	addi	sp,sp,4
 323b938:	f800283a 	ret

0323b93c <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
 323b93c:	deffff04 	addi	sp,sp,-4
 323b940:	df000015 	stw	fp,0(sp)
 323b944:	d839883a 	mov	fp,sp
}
 323b948:	e037883a 	mov	sp,fp
 323b94c:	df000017 	ldw	fp,0(sp)
 323b950:	dec00104 	addi	sp,sp,4
 323b954:	f800283a 	ret

0323b958 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
 323b958:	defffe04 	addi	sp,sp,-8
 323b95c:	df000115 	stw	fp,4(sp)
 323b960:	df000104 	addi	fp,sp,4
 323b964:	e13fff15 	stw	r4,-4(fp)
}
 323b968:	e037883a 	mov	sp,fp
 323b96c:	df000017 	ldw	fp,0(sp)
 323b970:	dec00104 	addi	sp,sp,4
 323b974:	f800283a 	ret

0323b978 <alt_program_amd>:
 * then writes Addr, Data Addr, Data etc.
 */
int alt_program_amd(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 323b978:	defff704 	addi	sp,sp,-36
 323b97c:	dfc00815 	stw	ra,32(sp)
 323b980:	df000715 	stw	fp,28(sp)
 323b984:	df000704 	addi	fp,sp,28
 323b988:	e13ffc15 	stw	r4,-16(fp)
 323b98c:	e17ffd15 	stw	r5,-12(fp)
 323b990:	e1bffe15 	stw	r6,-8(fp)
 323b994:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 323b998:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 323b99c:	e0bffc17 	ldw	r2,-16(fp)
 323b9a0:	e0bffa15 	stw	r2,-24(fp)
  
  
  ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 323b9a4:	e1bfff17 	ldw	r6,-4(fp)
 323b9a8:	0080c934 	movhi	r2,804
 323b9ac:	10af4704 	addi	r2,r2,-17124
 323b9b0:	d8800015 	stw	r2,0(sp)
 323b9b4:	e13ffa17 	ldw	r4,-24(fp)
 323b9b8:	e17ffe17 	ldw	r5,-8(fp)
 323b9bc:	e1c00217 	ldw	r7,8(fp)
 323b9c0:	321df400 	call	321df40 <alt_flash_program_block>
 323b9c4:	e0bffb15 	stw	r2,-20(fp)
                                    alt_write_word_amd);
  return ret_code;
 323b9c8:	e0bffb17 	ldw	r2,-20(fp)
}
 323b9cc:	e037883a 	mov	sp,fp
 323b9d0:	dfc00117 	ldw	ra,4(sp)
 323b9d4:	df000017 	ldw	fp,0(sp)
 323b9d8:	dec00204 	addi	sp,sp,8
 323b9dc:	f800283a 	ret

0323b9e0 <alt_erase_block_amd>:
 * alt_erase_block_amd
 * 
 * Erase the selected erase block
 */
int alt_erase_block_amd(alt_flash_dev* flash_info, int block_offset)
{
 323b9e0:	defff804 	addi	sp,sp,-32
 323b9e4:	dfc00715 	stw	ra,28(sp)
 323b9e8:	df000615 	stw	fp,24(sp)
 323b9ec:	df000604 	addi	fp,sp,24
 323b9f0:	e13ffe15 	stw	r4,-8(fp)
 323b9f4:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 323b9f8:	e03ffc15 	stw	zero,-16(fp)
  int   timeout;
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 323b9fc:	e0bffe17 	ldw	r2,-8(fp)
 323ba00:	e0bffa15 	stw	r2,-24(fp)
  volatile alt_u8  value;

  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 323ba04:	e0bffa17 	ldw	r2,-24(fp)
 323ba08:	10c03317 	ldw	r3,204(r2)
 323ba0c:	e0bffa17 	ldw	r2,-24(fp)
 323ba10:	11000a17 	ldw	r4,40(r2)
 323ba14:	01415544 	movi	r5,1365
 323ba18:	01802a84 	movi	r6,170
 323ba1c:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 323ba20:	e0bffa17 	ldw	r2,-24(fp)
 323ba24:	10c03317 	ldw	r3,204(r2)
 323ba28:	e0bffa17 	ldw	r2,-24(fp)
 323ba2c:	11000a17 	ldw	r4,40(r2)
 323ba30:	0140aa84 	movi	r5,682
 323ba34:	01801544 	movi	r6,85
 323ba38:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0x80);
 323ba3c:	e0bffa17 	ldw	r2,-24(fp)
 323ba40:	10c03317 	ldw	r3,204(r2)
 323ba44:	e0bffa17 	ldw	r2,-24(fp)
 323ba48:	11000a17 	ldw	r4,40(r2)
 323ba4c:	01415544 	movi	r5,1365
 323ba50:	01802004 	movi	r6,128
 323ba54:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 323ba58:	e0bffa17 	ldw	r2,-24(fp)
 323ba5c:	10c03317 	ldw	r3,204(r2)
 323ba60:	e0bffa17 	ldw	r2,-24(fp)
 323ba64:	11000a17 	ldw	r4,40(r2)
 323ba68:	01415544 	movi	r5,1365
 323ba6c:	01802a84 	movi	r6,170
 323ba70:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 323ba74:	e0bffa17 	ldw	r2,-24(fp)
 323ba78:	10c03317 	ldw	r3,204(r2)
 323ba7c:	e0bffa17 	ldw	r2,-24(fp)
 323ba80:	11000a17 	ldw	r4,40(r2)
 323ba84:	0140aa84 	movi	r5,682
 323ba88:	01801544 	movi	r6,85
 323ba8c:	183ee83a 	callr	r3

  (*flash->write_native)((alt_u8*)flash->dev.base_addr+block_offset, 0x30);
 323ba90:	e0bffa17 	ldw	r2,-24(fp)
 323ba94:	11803517 	ldw	r6,212(r2)
 323ba98:	e0bffa17 	ldw	r2,-24(fp)
 323ba9c:	10800a17 	ldw	r2,40(r2)
 323baa0:	1007883a 	mov	r3,r2
 323baa4:	e0bfff17 	ldw	r2,-4(fp)
 323baa8:	1889883a 	add	r4,r3,r2
 323baac:	01400c04 	movi	r5,48
 323bab0:	303ee83a 	callr	r6

  /*
   * Delay to meet AM29LV065D timing requirements
   */
  usleep(10000);
 323bab4:	0109c404 	movi	r4,10000
 323bab8:	323b1cc0 	call	323b1cc <usleep>
  
  /*
   * Bit 3 indicates that the erase command has been accepted
   * this last 50S
   */
  timeout = 50;   
 323babc:	00800c84 	movi	r2,50
 323bac0:	e0bffb15 	stw	r2,-20(fp)
  do 
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 323bac4:	e0bffa17 	ldw	r2,-24(fp)
 323bac8:	10800a17 	ldw	r2,40(r2)
 323bacc:	1007883a 	mov	r3,r2
 323bad0:	e0bfff17 	ldw	r2,-4(fp)
 323bad4:	1885883a 	add	r2,r3,r2
 323bad8:	10800023 	ldbuio	r2,0(r2)
 323badc:	e0bffd05 	stb	r2,-12(fp)
    usleep(1000);
 323bae0:	0100fa04 	movi	r4,1000
 323bae4:	323b1cc0 	call	323b1cc <usleep>
    timeout--;
 323bae8:	e0bffb17 	ldw	r2,-20(fp)
 323baec:	10bfffc4 	addi	r2,r2,-1
 323baf0:	e0bffb15 	stw	r2,-20(fp)
  }while(!(value & 0x8) && (timeout > 0));
 323baf4:	e0bffd03 	ldbu	r2,-12(fp)
 323baf8:	10803fcc 	andi	r2,r2,255
 323bafc:	1080020c 	andi	r2,r2,8
 323bb00:	1004c03a 	cmpne	r2,r2,zero
 323bb04:	1000031e 	bne	r2,zero,323bb14 <alt_erase_block_amd+0x134>
 323bb08:	e0bffb17 	ldw	r2,-20(fp)
 323bb0c:	10800048 	cmpgei	r2,r2,1
 323bb10:	103fec1e 	bne	r2,zero,323bac4 <alt_erase_block_amd+0xe4>


  timeout = flash->erase_timeout;
 323bb14:	e0bffa17 	ldw	r2,-24(fp)
 323bb18:	10803117 	ldw	r2,196(r2)
 323bb1c:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 323bb20:	00001706 	br	323bb80 <alt_erase_block_amd+0x1a0>
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 323bb24:	e0bffa17 	ldw	r2,-24(fp)
 323bb28:	10800a17 	ldw	r2,40(r2)
 323bb2c:	1007883a 	mov	r3,r2
 323bb30:	e0bfff17 	ldw	r2,-4(fp)
 323bb34:	1885883a 	add	r2,r3,r2
 323bb38:	10800023 	ldbuio	r2,0(r2)
 323bb3c:	e0bffd05 	stb	r2,-12(fp)
    if ((value & 0x80) || (value &0x20))
 323bb40:	e0bffd03 	ldbu	r2,-12(fp)
 323bb44:	10803fcc 	andi	r2,r2,255
 323bb48:	1080201c 	xori	r2,r2,128
 323bb4c:	10bfe004 	addi	r2,r2,-128
 323bb50:	1004803a 	cmplt	r2,r2,zero
 323bb54:	10000d1e 	bne	r2,zero,323bb8c <alt_erase_block_amd+0x1ac>
 323bb58:	e0bffd03 	ldbu	r2,-12(fp)
 323bb5c:	10803fcc 	andi	r2,r2,255
 323bb60:	1080080c 	andi	r2,r2,32
 323bb64:	1004c03a 	cmpne	r2,r2,zero
 323bb68:	1000081e 	bne	r2,zero,323bb8c <alt_erase_block_amd+0x1ac>
    {
      break;
    }
    usleep(1000);
 323bb6c:	0100fa04 	movi	r4,1000
 323bb70:	323b1cc0 	call	323b1cc <usleep>
    timeout -= 1000;
 323bb74:	e0bffb17 	ldw	r2,-20(fp)
 323bb78:	10bf0604 	addi	r2,r2,-1000
 323bb7c:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 323bb80:	e0bffb17 	ldw	r2,-20(fp)
 323bb84:	10800048 	cmpgei	r2,r2,1
 323bb88:	103fe61e 	bne	r2,zero,323bb24 <alt_erase_block_amd+0x144>
    }
    usleep(1000);
    timeout -= 1000;
  }
  
  if (timeout <= 0)
 323bb8c:	e0bffb17 	ldw	r2,-20(fp)
 323bb90:	10800048 	cmpgei	r2,r2,1
 323bb94:	1000031e 	bne	r2,zero,323bba4 <alt_erase_block_amd+0x1c4>
  {
    ret_code = -ETIMEDOUT;
 323bb98:	00bfe304 	movi	r2,-116
 323bb9c:	e0bffc15 	stw	r2,-16(fp)
 323bba0:	00000f06 	br	323bbe0 <alt_erase_block_amd+0x200>
  }
  else
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 323bba4:	e0bffa17 	ldw	r2,-24(fp)
 323bba8:	10800a17 	ldw	r2,40(r2)
 323bbac:	1007883a 	mov	r3,r2
 323bbb0:	e0bfff17 	ldw	r2,-4(fp)
 323bbb4:	1885883a 	add	r2,r3,r2
 323bbb8:	10800023 	ldbuio	r2,0(r2)
 323bbbc:	e0bffd05 	stb	r2,-12(fp)
    if (!(value & 0x80))
 323bbc0:	e0bffd03 	ldbu	r2,-12(fp)
 323bbc4:	10803fcc 	andi	r2,r2,255
 323bbc8:	1080201c 	xori	r2,r2,128
 323bbcc:	10bfe004 	addi	r2,r2,-128
 323bbd0:	1004803a 	cmplt	r2,r2,zero
 323bbd4:	1000021e 	bne	r2,zero,323bbe0 <alt_erase_block_amd+0x200>
    {
      ret_code = -EIO;
 323bbd8:	00bffec4 	movi	r2,-5
 323bbdc:	e0bffc15 	stw	r2,-16(fp)
    }
  }    
  
  return ret_code;
 323bbe0:	e0bffc17 	ldw	r2,-16(fp)
}
 323bbe4:	e037883a 	mov	sp,fp
 323bbe8:	dfc00117 	ldw	ra,4(sp)
 323bbec:	df000017 	ldw	fp,0(sp)
 323bbf0:	dec00204 	addi	sp,sp,8
 323bbf4:	f800283a 	ret

0323bbf8 <alt_wait_for_command_to_complete_amd>:
 */
 
int alt_wait_for_command_to_complete_amd(alt_flash_cfi_dev* flash,
                                         int offset, 
                                          alt_u8 data)
{
 323bbf8:	defff804 	addi	sp,sp,-32
 323bbfc:	dfc00715 	stw	ra,28(sp)
 323bc00:	df000615 	stw	fp,24(sp)
 323bc04:	df000604 	addi	fp,sp,24
 323bc08:	e13ffd15 	stw	r4,-12(fp)
 323bc0c:	e17ffe15 	stw	r5,-8(fp)
 323bc10:	e1bfff05 	stb	r6,-4(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
 323bc14:	e0bffd17 	ldw	r2,-12(fp)
 323bc18:	10803017 	ldw	r2,192(r2)
 323bc1c:	10801924 	muli	r2,r2,100
 323bc20:	e0bffb15 	stw	r2,-20(fp)
  int ret_code = 0;
 323bc24:	e03ffa15 	stw	zero,-24(fp)
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
 323bc28:	e0bffd17 	ldw	r2,-12(fp)
 323bc2c:	10800a17 	ldw	r2,40(r2)
 323bc30:	1007883a 	mov	r3,r2
 323bc34:	e0bffe17 	ldw	r2,-8(fp)
 323bc38:	1885883a 	add	r2,r3,r2
 323bc3c:	10800023 	ldbuio	r2,0(r2)
 323bc40:	e0bffc05 	stb	r2,-16(fp)
  while (timeout > 0)
 323bc44:	00001706 	br	323bca4 <alt_wait_for_command_to_complete_amd+0xac>
  {
    if (((value & 0x80 ) == (data &0x80)) ||
 323bc48:	e0bffc03 	ldbu	r2,-16(fp)
 323bc4c:	10803fcc 	andi	r2,r2,255
 323bc50:	10c0200c 	andi	r3,r2,128
 323bc54:	e0bfff03 	ldbu	r2,-4(fp)
 323bc58:	1080200c 	andi	r2,r2,128
 323bc5c:	18801426 	beq	r3,r2,323bcb0 <alt_wait_for_command_to_complete_amd+0xb8>
 323bc60:	e0bffc03 	ldbu	r2,-16(fp)
 323bc64:	10803fcc 	andi	r2,r2,255
 323bc68:	1080080c 	andi	r2,r2,32
 323bc6c:	1004c03a 	cmpne	r2,r2,zero
 323bc70:	10000f1e 	bne	r2,zero,323bcb0 <alt_wait_for_command_to_complete_amd+0xb8>
        (value & 0x20))
    {
      break;
    }
    usleep (1);
 323bc74:	01000044 	movi	r4,1
 323bc78:	323b1cc0 	call	323b1cc <usleep>
    timeout--;
 323bc7c:	e0bffb17 	ldw	r2,-20(fp)
 323bc80:	10bfffc4 	addi	r2,r2,-1
 323bc84:	e0bffb15 	stw	r2,-20(fp)
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 323bc88:	e0bffd17 	ldw	r2,-12(fp)
 323bc8c:	10800a17 	ldw	r2,40(r2)
 323bc90:	1007883a 	mov	r3,r2
 323bc94:	e0bffe17 	ldw	r2,-8(fp)
 323bc98:	1885883a 	add	r2,r3,r2
 323bc9c:	10800023 	ldbuio	r2,0(r2)
 323bca0:	e0bffc05 	stb	r2,-16(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
  int ret_code = 0;
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
  while (timeout > 0)
 323bca4:	e0bffb17 	ldw	r2,-20(fp)
 323bca8:	10800048 	cmpgei	r2,r2,1
 323bcac:	103fe61e 	bne	r2,zero,323bc48 <alt_wait_for_command_to_complete_amd+0x50>
    usleep (1);
    timeout--;
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
  }
  
  if (timeout == 0)
 323bcb0:	e0bffb17 	ldw	r2,-20(fp)
 323bcb4:	1004c03a 	cmpne	r2,r2,zero
 323bcb8:	1000031e 	bne	r2,zero,323bcc8 <alt_wait_for_command_to_complete_amd+0xd0>
  {
    ret_code = -ETIMEDOUT;
 323bcbc:	00bfe304 	movi	r2,-116
 323bcc0:	e0bffa15 	stw	r2,-24(fp)
 323bcc4:	00000f06 	br	323bd04 <alt_wait_for_command_to_complete_amd+0x10c>
  }
  else
  {
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 323bcc8:	e0bffd17 	ldw	r2,-12(fp)
 323bccc:	10800a17 	ldw	r2,40(r2)
 323bcd0:	1007883a 	mov	r3,r2
 323bcd4:	e0bffe17 	ldw	r2,-8(fp)
 323bcd8:	1885883a 	add	r2,r3,r2
 323bcdc:	10800023 	ldbuio	r2,0(r2)
 323bce0:	e0bffc05 	stb	r2,-16(fp)
    if ((value & 0x80) != (data&0x80))
 323bce4:	e0bffc03 	ldbu	r2,-16(fp)
 323bce8:	10803fcc 	andi	r2,r2,255
 323bcec:	10c0200c 	andi	r3,r2,128
 323bcf0:	e0bfff03 	ldbu	r2,-4(fp)
 323bcf4:	1080200c 	andi	r2,r2,128
 323bcf8:	18800226 	beq	r3,r2,323bd04 <alt_wait_for_command_to_complete_amd+0x10c>
    {
      ret_code = -EIO;
 323bcfc:	00bffec4 	movi	r2,-5
 323bd00:	e0bffa15 	stw	r2,-24(fp)
    }
  }    
  return ret_code;
 323bd04:	e0bffa17 	ldw	r2,-24(fp)
}
 323bd08:	e037883a 	mov	sp,fp
 323bd0c:	dfc00117 	ldw	ra,4(sp)
 323bd10:	df000017 	ldw	fp,0(sp)
 323bd14:	dec00204 	addi	sp,sp,8
 323bd18:	f800283a 	ret

0323bd1c <alt_write_word_amd>:

static int alt_write_word_amd(  alt_flash_cfi_dev* flash, 
                                const int offset, 
                                const alt_u8* src_addr)
{
 323bd1c:	defff904 	addi	sp,sp,-28
 323bd20:	dfc00615 	stw	ra,24(sp)
 323bd24:	df000515 	stw	fp,20(sp)
 323bd28:	df000504 	addi	fp,sp,20
 323bd2c:	e13ffd15 	stw	r4,-12(fp)
 323bd30:	e17ffe15 	stw	r5,-8(fp)
 323bd34:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 323bd38:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 value;
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 323bd3c:	e0bffd17 	ldw	r2,-12(fp)
 323bd40:	10c03317 	ldw	r3,204(r2)
 323bd44:	e0bffd17 	ldw	r2,-12(fp)
 323bd48:	11000a17 	ldw	r4,40(r2)
 323bd4c:	01415544 	movi	r5,1365
 323bd50:	01802a84 	movi	r6,170
 323bd54:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 323bd58:	e0bffd17 	ldw	r2,-12(fp)
 323bd5c:	10c03317 	ldw	r3,204(r2)
 323bd60:	e0bffd17 	ldw	r2,-12(fp)
 323bd64:	11000a17 	ldw	r4,40(r2)
 323bd68:	0140aa84 	movi	r5,682
 323bd6c:	01801544 	movi	r6,85
 323bd70:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xA0);
 323bd74:	e0bffd17 	ldw	r2,-12(fp)
 323bd78:	10c03317 	ldw	r3,204(r2)
 323bd7c:	e0bffd17 	ldw	r2,-12(fp)
 323bd80:	11000a17 	ldw	r4,40(r2)
 323bd84:	01415544 	movi	r5,1365
 323bd88:	01802804 	movi	r6,160
 323bd8c:	183ee83a 	callr	r3
  
  value = *src_addr;
 323bd90:	e0bfff17 	ldw	r2,-4(fp)
 323bd94:	10800003 	ldbu	r2,0(r2)
 323bd98:	e0bffb05 	stb	r2,-20(fp)

  alt_write_value_to_flash(flash, offset, src_addr);
 323bd9c:	e13ffd17 	ldw	r4,-12(fp)
 323bda0:	e17ffe17 	ldw	r5,-8(fp)
 323bda4:	e1bfff17 	ldw	r6,-4(fp)
 323bda8:	321dddc0 	call	321dddc <alt_write_value_to_flash>
  
  ret_code = alt_wait_for_command_to_complete_amd(flash, 
 323bdac:	e1bffb03 	ldbu	r6,-20(fp)
 323bdb0:	e13ffd17 	ldw	r4,-12(fp)
 323bdb4:	e17ffe17 	ldw	r5,-8(fp)
 323bdb8:	323bbf80 	call	323bbf8 <alt_wait_for_command_to_complete_amd>
 323bdbc:	e0bffc15 	stw	r2,-16(fp)
                                                  offset,
                                                  value);
  return ret_code;
 323bdc0:	e0bffc17 	ldw	r2,-16(fp)
  
}
 323bdc4:	e037883a 	mov	sp,fp
 323bdc8:	dfc00117 	ldw	ra,4(sp)
 323bdcc:	df000017 	ldw	fp,0(sp)
 323bdd0:	dec00204 	addi	sp,sp,8
 323bdd4:	f800283a 	ret

0323bdd8 <alt_program_intel>:
 * Program a block (or part of one)
 */
int alt_program_intel(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 323bdd8:	defff704 	addi	sp,sp,-36
 323bddc:	dfc00815 	stw	ra,32(sp)
 323bde0:	df000715 	stw	fp,28(sp)
 323bde4:	df000704 	addi	fp,sp,28
 323bde8:	e13ffc15 	stw	r4,-16(fp)
 323bdec:	e17ffd15 	stw	r5,-12(fp)
 323bdf0:	e1bffe15 	stw	r6,-8(fp)
 323bdf4:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 323bdf8:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 323bdfc:	e0bffc17 	ldw	r2,-16(fp)
 323be00:	e0bffa15 	stw	r2,-24(fp)
  
   /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 323be04:	e13ffa17 	ldw	r4,-24(fp)
 323be08:	e17ffd17 	ldw	r5,-12(fp)
 323be0c:	323bfd00 	call	323bfd0 <alt_unlock_block_intel>
 323be10:	e0bffb15 	stw	r2,-20(fp)

  if (!ret_code)
 323be14:	e0bffb17 	ldw	r2,-20(fp)
 323be18:	1004c03a 	cmpne	r2,r2,zero
 323be1c:	1000091e 	bne	r2,zero,323be44 <alt_program_intel+0x6c>
  {

    ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 323be20:	e1bfff17 	ldw	r6,-4(fp)
 323be24:	0080c934 	movhi	r2,804
 323be28:	10b05704 	addi	r2,r2,-16036
 323be2c:	d8800015 	stw	r2,0(sp)
 323be30:	e13ffa17 	ldw	r4,-24(fp)
 323be34:	e17ffe17 	ldw	r5,-8(fp)
 323be38:	e1c00217 	ldw	r7,8(fp)
 323be3c:	321df400 	call	321df40 <alt_flash_program_block>
 323be40:	e0bffb15 	stw	r2,-20(fp)
                                        alt_write_word_intel);
  }
  
  return ret_code;
 323be44:	e0bffb17 	ldw	r2,-20(fp)
}
 323be48:	e037883a 	mov	sp,fp
 323be4c:	dfc00117 	ldw	ra,4(sp)
 323be50:	df000017 	ldw	fp,0(sp)
 323be54:	dec00204 	addi	sp,sp,8
 323be58:	f800283a 	ret

0323be5c <alt_erase_block_intel>:
 * alt_erase_block_intel
 * 
 * Erase the selected erase block
 */
int alt_erase_block_intel(alt_flash_dev* flash_info, int block_offset)
{
 323be5c:	defff804 	addi	sp,sp,-32
 323be60:	dfc00715 	stw	ra,28(sp)
 323be64:	df000615 	stw	fp,24(sp)
 323be68:	df000604 	addi	fp,sp,24
 323be6c:	e13ffe15 	stw	r4,-8(fp)
 323be70:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 323be74:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 323be78:	e0bffe17 	ldw	r2,-8(fp)
 323be7c:	e0bffb15 	stw	r2,-20(fp)
  volatile alt_u8  status;
  int   timeout = flash->erase_timeout;
 323be80:	e0bffb17 	ldw	r2,-20(fp)
 323be84:	10803117 	ldw	r2,196(r2)
 323be88:	e0bffa15 	stw	r2,-24(fp)

  /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 323be8c:	e13ffb17 	ldw	r4,-20(fp)
 323be90:	e17fff17 	ldw	r5,-4(fp)
 323be94:	323bfd00 	call	323bfd0 <alt_unlock_block_intel>
 323be98:	e0bffc15 	stw	r2,-16(fp)

  if (!ret_code)
 323be9c:	e0bffc17 	ldw	r2,-16(fp)
 323bea0:	1004c03a 	cmpne	r2,r2,zero
 323bea4:	1000441e 	bne	r2,zero,323bfb8 <alt_erase_block_intel+0x15c>
  {

    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x20);
 323bea8:	e0bffb17 	ldw	r2,-20(fp)
 323beac:	11803517 	ldw	r6,212(r2)
 323beb0:	e0bffb17 	ldw	r2,-20(fp)
 323beb4:	10800a17 	ldw	r2,40(r2)
 323beb8:	1007883a 	mov	r3,r2
 323bebc:	e0bfff17 	ldw	r2,-4(fp)
 323bec0:	1889883a 	add	r4,r3,r2
 323bec4:	01400804 	movi	r5,32
 323bec8:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 323becc:	e0bffb17 	ldw	r2,-20(fp)
 323bed0:	11803517 	ldw	r6,212(r2)
 323bed4:	e0bffb17 	ldw	r2,-20(fp)
 323bed8:	10800a17 	ldw	r2,40(r2)
 323bedc:	1007883a 	mov	r3,r2
 323bee0:	e0bfff17 	ldw	r2,-4(fp)
 323bee4:	1889883a 	add	r4,r3,r2
 323bee8:	01403404 	movi	r5,208
 323beec:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 323bef0:	e0bffb17 	ldw	r2,-20(fp)
 323bef4:	10800a17 	ldw	r2,40(r2)
 323bef8:	1007883a 	mov	r3,r2
 323befc:	e0bfff17 	ldw	r2,-4(fp)
 323bf00:	1885883a 	add	r2,r3,r2
 323bf04:	10800023 	ldbuio	r2,0(r2)
 323bf08:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 323bf0c:	e0bffd03 	ldbu	r2,-12(fp)
 323bf10:	10803fcc 	andi	r2,r2,255
 323bf14:	1080201c 	xori	r2,r2,128
 323bf18:	10bfe004 	addi	r2,r2,-128
 323bf1c:	1004803a 	cmplt	r2,r2,zero
 323bf20:	1000081e 	bne	r2,zero,323bf44 <alt_erase_block_intel+0xe8>
      {
        break;
      }
      usleep(1000);
 323bf24:	0100fa04 	movi	r4,1000
 323bf28:	323b1cc0 	call	323b1cc <usleep>
      timeout -= 1000;
 323bf2c:	e0bffa17 	ldw	r2,-24(fp)
 323bf30:	10bf0604 	addi	r2,r2,-1000
 323bf34:	e0bffa15 	stw	r2,-24(fp)
    }while(timeout > 0);
 323bf38:	e0bffa17 	ldw	r2,-24(fp)
 323bf3c:	10800048 	cmpgei	r2,r2,1
 323bf40:	103feb1e 	bne	r2,zero,323bef0 <alt_erase_block_intel+0x94>
    
    if (timeout <= 0)
 323bf44:	e0bffa17 	ldw	r2,-24(fp)
 323bf48:	10800048 	cmpgei	r2,r2,1
 323bf4c:	1000031e 	bne	r2,zero,323bf5c <alt_erase_block_intel+0x100>
    {
      ret_code = -ETIMEDOUT;
 323bf50:	00bfe304 	movi	r2,-116
 323bf54:	e0bffc15 	stw	r2,-16(fp)
 323bf58:	00000e06 	br	323bf94 <alt_erase_block_intel+0x138>
    }
    else if (status & 0x7f)
 323bf5c:	e0bffd03 	ldbu	r2,-12(fp)
 323bf60:	10803fcc 	andi	r2,r2,255
 323bf64:	10801fcc 	andi	r2,r2,127
 323bf68:	1005003a 	cmpeq	r2,r2,zero
 323bf6c:	1000091e 	bne	r2,zero,323bf94 <alt_erase_block_intel+0x138>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 323bf70:	00bffec4 	movi	r2,-5
 323bf74:	e0bffc15 	stw	r2,-16(fp)
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 323bf78:	e0bffb17 	ldw	r2,-20(fp)
 323bf7c:	10800a17 	ldw	r2,40(r2)
 323bf80:	1007883a 	mov	r3,r2
 323bf84:	e0bfff17 	ldw	r2,-4(fp)
 323bf88:	1885883a 	add	r2,r3,r2
 323bf8c:	10800023 	ldbuio	r2,0(r2)
 323bf90:	e0bffd05 	stb	r2,-12(fp)
    }

    /* Put the device back into read array mode */
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 323bf94:	e0bffb17 	ldw	r2,-20(fp)
 323bf98:	11803517 	ldw	r6,212(r2)
 323bf9c:	e0bffb17 	ldw	r2,-20(fp)
 323bfa0:	10800a17 	ldw	r2,40(r2)
 323bfa4:	1007883a 	mov	r3,r2
 323bfa8:	e0bfff17 	ldw	r2,-4(fp)
 323bfac:	1889883a 	add	r4,r3,r2
 323bfb0:	01403fc4 	movi	r5,255
 323bfb4:	303ee83a 	callr	r6
  }
  
  return ret_code;
 323bfb8:	e0bffc17 	ldw	r2,-16(fp)
}
 323bfbc:	e037883a 	mov	sp,fp
 323bfc0:	dfc00117 	ldw	ra,4(sp)
 323bfc4:	df000017 	ldw	fp,0(sp)
 323bfc8:	dec00204 	addi	sp,sp,8
 323bfcc:	f800283a 	ret

0323bfd0 <alt_unlock_block_intel>:
/*
* Private Intel specific functions
*/

static int alt_unlock_block_intel(alt_flash_cfi_dev* flash, int block_offset)
{
 323bfd0:	defff904 	addi	sp,sp,-28
 323bfd4:	dfc00615 	stw	ra,24(sp)
 323bfd8:	df000515 	stw	fp,20(sp)
 323bfdc:	df000504 	addi	fp,sp,20
 323bfe0:	e13ffe15 	stw	r4,-8(fp)
 323bfe4:	e17fff15 	stw	r5,-4(fp)
  alt_u8  locked;
  alt_u8  status;
  int ret_code = 0;
 323bfe8:	e03ffc15 	stw	zero,-16(fp)
  int timeout = flash->write_timeout * 100;
 323bfec:	e0bffe17 	ldw	r2,-8(fp)
 323bff0:	10803017 	ldw	r2,192(r2)
 323bff4:	10801924 	muli	r2,r2,100
 323bff8:	e0bffb15 	stw	r2,-20(fp)


  /*
  * Is this block locked?
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x90);
 323bffc:	e0bffe17 	ldw	r2,-8(fp)
 323c000:	11803517 	ldw	r6,212(r2)
 323c004:	e0bffe17 	ldw	r2,-8(fp)
 323c008:	10800a17 	ldw	r2,40(r2)
 323c00c:	1007883a 	mov	r3,r2
 323c010:	e0bfff17 	ldw	r2,-4(fp)
 323c014:	1889883a 	add	r4,r3,r2
 323c018:	01402404 	movi	r5,144
 323c01c:	303ee83a 	callr	r6
  locked = IORD_8DIRECT(flash->dev.base_addr, block_offset + 4);
 323c020:	e0bffe17 	ldw	r2,-8(fp)
 323c024:	10800a17 	ldw	r2,40(r2)
 323c028:	1007883a 	mov	r3,r2
 323c02c:	e0bfff17 	ldw	r2,-4(fp)
 323c030:	1885883a 	add	r2,r3,r2
 323c034:	10800104 	addi	r2,r2,4
 323c038:	10800023 	ldbuio	r2,0(r2)
 323c03c:	e0bffd45 	stb	r2,-11(fp)
  if (locked & 0x1)
 323c040:	e0bffd43 	ldbu	r2,-11(fp)
 323c044:	1080004c 	andi	r2,r2,1
 323c048:	10803fcc 	andi	r2,r2,255
 323c04c:	1005003a 	cmpeq	r2,r2,zero
 323c050:	1000331e 	bne	r2,zero,323c120 <alt_unlock_block_intel+0x150>
  {
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x60);
 323c054:	e0bffe17 	ldw	r2,-8(fp)
 323c058:	11803517 	ldw	r6,212(r2)
 323c05c:	e0bffe17 	ldw	r2,-8(fp)
 323c060:	10800a17 	ldw	r2,40(r2)
 323c064:	1007883a 	mov	r3,r2
 323c068:	e0bfff17 	ldw	r2,-4(fp)
 323c06c:	1889883a 	add	r4,r3,r2
 323c070:	01401804 	movi	r5,96
 323c074:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 323c078:	e0bffe17 	ldw	r2,-8(fp)
 323c07c:	11803517 	ldw	r6,212(r2)
 323c080:	e0bffe17 	ldw	r2,-8(fp)
 323c084:	10800a17 	ldw	r2,40(r2)
 323c088:	1007883a 	mov	r3,r2
 323c08c:	e0bfff17 	ldw	r2,-4(fp)
 323c090:	1889883a 	add	r4,r3,r2
 323c094:	01403404 	movi	r5,208
 323c098:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 323c09c:	e0bffe17 	ldw	r2,-8(fp)
 323c0a0:	10800a17 	ldw	r2,40(r2)
 323c0a4:	1007883a 	mov	r3,r2
 323c0a8:	e0bfff17 	ldw	r2,-4(fp)
 323c0ac:	1885883a 	add	r2,r3,r2
 323c0b0:	10800023 	ldbuio	r2,0(r2)
 323c0b4:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 323c0b8:	e0bffd03 	ldbu	r2,-12(fp)
 323c0bc:	10803fcc 	andi	r2,r2,255
 323c0c0:	1080201c 	xori	r2,r2,128
 323c0c4:	10bfe004 	addi	r2,r2,-128
 323c0c8:	1004803a 	cmplt	r2,r2,zero
 323c0cc:	1000081e 	bne	r2,zero,323c0f0 <alt_unlock_block_intel+0x120>
      {
        break;
      }
      timeout--;
 323c0d0:	e0bffb17 	ldw	r2,-20(fp)
 323c0d4:	10bfffc4 	addi	r2,r2,-1
 323c0d8:	e0bffb15 	stw	r2,-20(fp)
      usleep(1);
 323c0dc:	01000044 	movi	r4,1
 323c0e0:	323b1cc0 	call	323b1cc <usleep>
    }while(timeout > 0);
 323c0e4:	e0bffb17 	ldw	r2,-20(fp)
 323c0e8:	10800048 	cmpgei	r2,r2,1
 323c0ec:	103feb1e 	bne	r2,zero,323c09c <alt_unlock_block_intel+0xcc>

    if (timeout == 0)
 323c0f0:	e0bffb17 	ldw	r2,-20(fp)
 323c0f4:	1004c03a 	cmpne	r2,r2,zero
 323c0f8:	1000031e 	bne	r2,zero,323c108 <alt_unlock_block_intel+0x138>
    {
      ret_code = -ETIMEDOUT;
 323c0fc:	00bfe304 	movi	r2,-116
 323c100:	e0bffc15 	stw	r2,-16(fp)
 323c104:	00000606 	br	323c120 <alt_unlock_block_intel+0x150>
    }
    else if (status & 0x7f)
 323c108:	e0bffd03 	ldbu	r2,-12(fp)
 323c10c:	10801fcc 	andi	r2,r2,127
 323c110:	1005003a 	cmpeq	r2,r2,zero
 323c114:	1000021e 	bne	r2,zero,323c120 <alt_unlock_block_intel+0x150>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 323c118:	00bffec4 	movi	r2,-5
 323c11c:	e0bffc15 	stw	r2,-16(fp)
  }

  /*
  * Back to Read Array mode
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 323c120:	e0bffe17 	ldw	r2,-8(fp)
 323c124:	11803517 	ldw	r6,212(r2)
 323c128:	e0bffe17 	ldw	r2,-8(fp)
 323c12c:	10800a17 	ldw	r2,40(r2)
 323c130:	1007883a 	mov	r3,r2
 323c134:	e0bfff17 	ldw	r2,-4(fp)
 323c138:	1889883a 	add	r4,r3,r2
 323c13c:	01403fc4 	movi	r5,255
 323c140:	303ee83a 	callr	r6

  return ret_code;
 323c144:	e0bffc17 	ldw	r2,-16(fp)
}
 323c148:	e037883a 	mov	sp,fp
 323c14c:	dfc00117 	ldw	ra,4(sp)
 323c150:	df000017 	ldw	fp,0(sp)
 323c154:	dec00204 	addi	sp,sp,8
 323c158:	f800283a 	ret

0323c15c <alt_write_word_intel>:
 * offset bytes into the flash
 */
 
int alt_write_word_intel( alt_flash_cfi_dev* flash, 
                                  const int offset, const alt_u8* src_addr)
{ 
 323c15c:	defff904 	addi	sp,sp,-28
 323c160:	dfc00615 	stw	ra,24(sp)
 323c164:	df000515 	stw	fp,20(sp)
 323c168:	df000504 	addi	fp,sp,20
 323c16c:	e13ffd15 	stw	r4,-12(fp)
 323c170:	e17ffe15 	stw	r5,-8(fp)
 323c174:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 323c178:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 status;
  (*flash->write_native)((alt_u8*)flash->dev.base_addr+offset, 0x40);
 323c17c:	e0bffd17 	ldw	r2,-12(fp)
 323c180:	11803517 	ldw	r6,212(r2)
 323c184:	e0bffd17 	ldw	r2,-12(fp)
 323c188:	10800a17 	ldw	r2,40(r2)
 323c18c:	1007883a 	mov	r3,r2
 323c190:	e0bffe17 	ldw	r2,-8(fp)
 323c194:	1889883a 	add	r4,r3,r2
 323c198:	01401004 	movi	r5,64
 323c19c:	303ee83a 	callr	r6
  alt_write_value_to_flash(flash, offset, src_addr);
 323c1a0:	e13ffd17 	ldw	r4,-12(fp)
 323c1a4:	e17ffe17 	ldw	r5,-8(fp)
 323c1a8:	e1bfff17 	ldw	r6,-4(fp)
 323c1ac:	321dddc0 	call	321dddc <alt_write_value_to_flash>

  do
  {
    status = IORD_8DIRECT(flash->dev.base_addr, offset);
 323c1b0:	e0bffd17 	ldw	r2,-12(fp)
 323c1b4:	10800a17 	ldw	r2,40(r2)
 323c1b8:	1007883a 	mov	r3,r2
 323c1bc:	e0bffe17 	ldw	r2,-8(fp)
 323c1c0:	1885883a 	add	r2,r3,r2
 323c1c4:	10800023 	ldbuio	r2,0(r2)
 323c1c8:	e0bffb05 	stb	r2,-20(fp)
  }while(!(status & 0x80));
 323c1cc:	e0bffb03 	ldbu	r2,-20(fp)
 323c1d0:	10803fcc 	andi	r2,r2,255
 323c1d4:	1080201c 	xori	r2,r2,128
 323c1d8:	10bfe004 	addi	r2,r2,-128
 323c1dc:	1004403a 	cmpge	r2,r2,zero
 323c1e0:	103ff31e 	bne	r2,zero,323c1b0 <alt_write_word_intel+0x54>

  /* If we have an error of some kind bomb out */
  if (status & 0x7f)
 323c1e4:	e0bffb03 	ldbu	r2,-20(fp)
 323c1e8:	10801fcc 	andi	r2,r2,127
 323c1ec:	1005003a 	cmpeq	r2,r2,zero
 323c1f0:	1000021e 	bne	r2,zero,323c1fc <alt_write_word_intel+0xa0>
  {
    ret_code = -EIO;
 323c1f4:	00bffec4 	movi	r2,-5
 323c1f8:	e0bffc15 	stw	r2,-16(fp)
  }

  /* Put the device back into read array mode */
  flash->write_native((alt_u8*)flash->dev.base_addr + offset, 0xFF);
 323c1fc:	e0bffd17 	ldw	r2,-12(fp)
 323c200:	11803517 	ldw	r6,212(r2)
 323c204:	e0bffd17 	ldw	r2,-12(fp)
 323c208:	10800a17 	ldw	r2,40(r2)
 323c20c:	1007883a 	mov	r3,r2
 323c210:	e0bffe17 	ldw	r2,-8(fp)
 323c214:	1889883a 	add	r4,r3,r2
 323c218:	01403fc4 	movi	r5,255
 323c21c:	303ee83a 	callr	r6
  
  return ret_code;
 323c220:	e0bffc17 	ldw	r2,-16(fp)
}
 323c224:	e037883a 	mov	sp,fp
 323c228:	dfc00117 	ldw	ra,4(sp)
 323c22c:	df000017 	ldw	fp,0(sp)
 323c230:	dec00204 	addi	sp,sp,8
 323c234:	f800283a 	ret

0323c238 <eth_ocm_set_phy_addr>:

static eth_ocm_phy_profile* eth_ocm_phy_profile_array[ETH_OCM_PHY_MAX_PROFILES] = {0}; 

static int eth_ocm_wait(int base);

void eth_ocm_set_phy_addr(int base, int phyad, int reg){
 323c238:	defffc04 	addi	sp,sp,-16
 323c23c:	df000315 	stw	fp,12(sp)
 323c240:	df000304 	addi	fp,sp,12
 323c244:	e13ffd15 	stw	r4,-12(fp)
 323c248:	e17ffe15 	stw	r5,-8(fp)
 323c24c:	e1bfff15 	stw	r6,-4(fp)
    phyad &= ETH_OCM_MIIADDRESS_FIAD_MSK; 
 323c250:	e0bffe17 	ldw	r2,-8(fp)
 323c254:	108007cc 	andi	r2,r2,31
 323c258:	e0bffe15 	stw	r2,-8(fp)
    reg = reg << ETH_OCM_MIIADDRESS_RGAD_OFST; 
 323c25c:	e0bfff17 	ldw	r2,-4(fp)
 323c260:	1004923a 	slli	r2,r2,8
 323c264:	e0bfff15 	stw	r2,-4(fp)
    reg &= ETH_OCM_MIIADDRESS_RGAD_MSK;
 323c268:	e0bfff17 	ldw	r2,-4(fp)
 323c26c:	1087c00c 	andi	r2,r2,7936
 323c270:	e0bfff15 	stw	r2,-4(fp)
    phyad |= reg;
 323c274:	e0fffe17 	ldw	r3,-8(fp)
 323c278:	e0bfff17 	ldw	r2,-4(fp)
 323c27c:	1884b03a 	or	r2,r3,r2
 323c280:	e0bffe15 	stw	r2,-8(fp)
    IOWR_ETH_OCM_MIIADDRESS(base, phyad); 
 323c284:	e0bffd17 	ldw	r2,-12(fp)
 323c288:	10800c04 	addi	r2,r2,48
 323c28c:	1007883a 	mov	r3,r2
 323c290:	e0bffe17 	ldw	r2,-8(fp)
 323c294:	18800035 	stwio	r2,0(r3)
}
 323c298:	e037883a 	mov	sp,fp
 323c29c:	df000017 	ldw	fp,0(sp)
 323c2a0:	dec00104 	addi	sp,sp,4
 323c2a4:	f800283a 	ret

0323c2a8 <eth_ocm_write_phy_reg>:

void eth_ocm_write_phy_reg(int base, int phyad, int reg, int data){
 323c2a8:	defffa04 	addi	sp,sp,-24
 323c2ac:	dfc00515 	stw	ra,20(sp)
 323c2b0:	df000415 	stw	fp,16(sp)
 323c2b4:	df000404 	addi	fp,sp,16
 323c2b8:	e13ffc15 	stw	r4,-16(fp)
 323c2bc:	e17ffd15 	stw	r5,-12(fp)
 323c2c0:	e1bffe15 	stw	r6,-8(fp)
 323c2c4:	e1ffff15 	stw	r7,-4(fp)
    eth_ocm_set_phy_addr(base, phyad, reg);
 323c2c8:	e13ffc17 	ldw	r4,-16(fp)
 323c2cc:	e17ffd17 	ldw	r5,-12(fp)
 323c2d0:	e1bffe17 	ldw	r6,-8(fp)
 323c2d4:	323c2380 	call	323c238 <eth_ocm_set_phy_addr>
    IOWR_ETH_OCM_MIITX_DATA(base, data);
 323c2d8:	e0bffc17 	ldw	r2,-16(fp)
 323c2dc:	10800d04 	addi	r2,r2,52
 323c2e0:	1007883a 	mov	r3,r2
 323c2e4:	e0bfff17 	ldw	r2,-4(fp)
 323c2e8:	18800035 	stwio	r2,0(r3)
    IOWR_ETH_OCM_MIICOMMAND(base, ETH_OCM_MIICOMMAND_WCTRLDATA_MSK);
 323c2ec:	e0bffc17 	ldw	r2,-16(fp)
 323c2f0:	10800b04 	addi	r2,r2,44
 323c2f4:	1007883a 	mov	r3,r2
 323c2f8:	00800104 	movi	r2,4
 323c2fc:	18800035 	stwio	r2,0(r3)
    eth_ocm_wait(base);
 323c300:	e13ffc17 	ldw	r4,-16(fp)
 323c304:	323c4300 	call	323c430 <eth_ocm_wait>
}
 323c308:	e037883a 	mov	sp,fp
 323c30c:	dfc00117 	ldw	ra,4(sp)
 323c310:	df000017 	ldw	fp,0(sp)
 323c314:	dec00204 	addi	sp,sp,8
 323c318:	f800283a 	ret

0323c31c <eth_ocm_read_phy_reg>:

int  eth_ocm_read_phy_reg(int base, int phyad, int reg){
 323c31c:	defffa04 	addi	sp,sp,-24
 323c320:	dfc00515 	stw	ra,20(sp)
 323c324:	df000415 	stw	fp,16(sp)
 323c328:	df000404 	addi	fp,sp,16
 323c32c:	e13ffd15 	stw	r4,-12(fp)
 323c330:	e17ffe15 	stw	r5,-8(fp)
 323c334:	e1bfff15 	stw	r6,-4(fp)
    int result;

    eth_ocm_set_phy_addr(base, phyad, reg);
 323c338:	e13ffd17 	ldw	r4,-12(fp)
 323c33c:	e17ffe17 	ldw	r5,-8(fp)
 323c340:	e1bfff17 	ldw	r6,-4(fp)
 323c344:	323c2380 	call	323c238 <eth_ocm_set_phy_addr>
    IOWR_ETH_OCM_MIICOMMAND(base, ETH_OCM_MIICOMMAND_RSTAT_MSK);
 323c348:	e0bffd17 	ldw	r2,-12(fp)
 323c34c:	10800b04 	addi	r2,r2,44
 323c350:	1007883a 	mov	r3,r2
 323c354:	00800084 	movi	r2,2
 323c358:	18800035 	stwio	r2,0(r3)
    eth_ocm_wait(base);
 323c35c:	e13ffd17 	ldw	r4,-12(fp)
 323c360:	323c4300 	call	323c430 <eth_ocm_wait>
    result = IORD_ETH_OCM_MIIRX_DATA(base);
 323c364:	e0bffd17 	ldw	r2,-12(fp)
 323c368:	10800e04 	addi	r2,r2,56
 323c36c:	10800037 	ldwio	r2,0(r2)
 323c370:	e0bffc15 	stw	r2,-16(fp)
    return result;
 323c374:	e0bffc17 	ldw	r2,-16(fp)
}
 323c378:	e037883a 	mov	sp,fp
 323c37c:	dfc00117 	ldw	ra,4(sp)
 323c380:	df000017 	ldw	fp,0(sp)
 323c384:	dec00204 	addi	sp,sp,8
 323c388:	f800283a 	ret

0323c38c <eth_ocm_phy_add_profile>:

int eth_ocm_phy_add_profile(eth_ocm_phy_profile *profile){
 323c38c:	defffc04 	addi	sp,sp,-16
 323c390:	df000315 	stw	fp,12(sp)
 323c394:	df000304 	addi	fp,sp,12
 323c398:	e13ffe15 	stw	r4,-8(fp)
    int i;
    i = 0;
 323c39c:	e03ffd15 	stw	zero,-12(fp)

    for(i=0;i<ETH_OCM_PHY_MAX_PROFILES;i++){
 323c3a0:	e03ffd15 	stw	zero,-12(fp)
 323c3a4:	00001806 	br	323c408 <eth_ocm_phy_add_profile+0x7c>
        if(eth_ocm_phy_profile_array[i] == 0){
 323c3a8:	e0bffd17 	ldw	r2,-12(fp)
 323c3ac:	00c0c974 	movhi	r3,805
 323c3b0:	18d59a04 	addi	r3,r3,22120
 323c3b4:	1085883a 	add	r2,r2,r2
 323c3b8:	1085883a 	add	r2,r2,r2
 323c3bc:	10c5883a 	add	r2,r2,r3
 323c3c0:	10800017 	ldw	r2,0(r2)
 323c3c4:	1004c03a 	cmpne	r2,r2,zero
 323c3c8:	10000c1e 	bne	r2,zero,323c3fc <eth_ocm_phy_add_profile+0x70>
            eth_ocm_phy_profile_array[i] = profile;
 323c3cc:	e0bffd17 	ldw	r2,-12(fp)
 323c3d0:	00c0c974 	movhi	r3,805
 323c3d4:	18d59a04 	addi	r3,r3,22120
 323c3d8:	1085883a 	add	r2,r2,r2
 323c3dc:	1085883a 	add	r2,r2,r2
 323c3e0:	10c7883a 	add	r3,r2,r3
 323c3e4:	e0bffe17 	ldw	r2,-8(fp)
 323c3e8:	18800015 	stw	r2,0(r3)
            i = ETH_OCM_PHY_MAX_PROFILES;
 323c3ec:	008000c4 	movi	r2,3
 323c3f0:	e0bffd15 	stw	r2,-12(fp)
            return 0;
 323c3f4:	e03fff15 	stw	zero,-4(fp)
 323c3f8:	00000806 	br	323c41c <eth_ocm_phy_add_profile+0x90>

int eth_ocm_phy_add_profile(eth_ocm_phy_profile *profile){
    int i;
    i = 0;

    for(i=0;i<ETH_OCM_PHY_MAX_PROFILES;i++){
 323c3fc:	e0bffd17 	ldw	r2,-12(fp)
 323c400:	10800044 	addi	r2,r2,1
 323c404:	e0bffd15 	stw	r2,-12(fp)
 323c408:	e0bffd17 	ldw	r2,-12(fp)
 323c40c:	108000d0 	cmplti	r2,r2,3
 323c410:	103fe51e 	bne	r2,zero,323c3a8 <eth_ocm_phy_add_profile+0x1c>
            i = ETH_OCM_PHY_MAX_PROFILES;
            return 0;
        }
    }

    return -1;
 323c414:	00bfffc4 	movi	r2,-1
 323c418:	e0bfff15 	stw	r2,-4(fp)
 323c41c:	e0bfff17 	ldw	r2,-4(fp)
}
 323c420:	e037883a 	mov	sp,fp
 323c424:	df000017 	ldw	fp,0(sp)
 323c428:	dec00104 	addi	sp,sp,4
 323c42c:	f800283a 	ret

0323c430 <eth_ocm_wait>:

static int eth_ocm_wait(int base){
 323c430:	defffc04 	addi	sp,sp,-16
 323c434:	df000315 	stw	fp,12(sp)
 323c438:	df000304 	addi	fp,sp,12
 323c43c:	e13fff15 	stw	r4,-4(fp)
    int temp;
    int i;
    i = 0;
 323c440:	e03ffd15 	stw	zero,-12(fp)
    temp = 1;
 323c444:	00800044 	movi	r2,1
 323c448:	e0bffe15 	stw	r2,-8(fp)
    while(temp && i<1000){
 323c44c:	00000a06 	br	323c478 <eth_ocm_wait+0x48>
        temp = IORD_ETH_OCM_MIISTATUS(base);
 323c450:	e0bfff17 	ldw	r2,-4(fp)
 323c454:	10800f04 	addi	r2,r2,60
 323c458:	10800037 	ldwio	r2,0(r2)
 323c45c:	e0bffe15 	stw	r2,-8(fp)
        #if(ETH_OCM_DBG_LVL > 0)
        if(temp & ETH_OCM_MIISTATUS_NVALID_MSK)
            printf("Invalid bit set in MII Status register\n");
        #endif
        temp &= ETH_OCM_MIISTATUS_BUSY_MSK;
 323c460:	e0bffe17 	ldw	r2,-8(fp)
 323c464:	1080008c 	andi	r2,r2,2
 323c468:	e0bffe15 	stw	r2,-8(fp)
        i++;
 323c46c:	e0bffd17 	ldw	r2,-12(fp)
 323c470:	10800044 	addi	r2,r2,1
 323c474:	e0bffd15 	stw	r2,-12(fp)
static int eth_ocm_wait(int base){
    int temp;
    int i;
    i = 0;
    temp = 1;
    while(temp && i<1000){
 323c478:	e0bffe17 	ldw	r2,-8(fp)
 323c47c:	1005003a 	cmpeq	r2,r2,zero
 323c480:	1000031e 	bne	r2,zero,323c490 <eth_ocm_wait+0x60>
 323c484:	e0bffd17 	ldw	r2,-12(fp)
 323c488:	1080fa10 	cmplti	r2,r2,1000
 323c48c:	103ff01e 	bne	r2,zero,323c450 <eth_ocm_wait+0x20>
    #if(ETH_OCM_DBG_LVL > 0)
    if(i == 1000)
        printf("[eth_ocm_set_phy_reg] Failed waiting for MII module to be ready!\n");
    #endif
        
    return temp;
 323c490:	e0bffe17 	ldw	r2,-8(fp)
    
}
 323c494:	e037883a 	mov	sp,fp
 323c498:	df000017 	ldw	fp,0(sp)
 323c49c:	dec00104 	addi	sp,sp,4
 323c4a0:	f800283a 	ret

0323c4a4 <eth_ocm_phy_init>:
 *
 * @param  dev Pointer to eth_ocm_dev struct which contains needed base address
 * @return 1 if Link is established in Full duplex.
 *         0 if Link is established in Half duplex.
 */
int eth_ocm_phy_init(eth_ocm_dev *dev){
 323c4a4:	defff104 	addi	sp,sp,-60
 323c4a8:	dfc00e15 	stw	ra,56(sp)
 323c4ac:	df000d15 	stw	fp,52(sp)
 323c4b0:	df000d04 	addi	fp,sp,52
 323c4b4:	e13ffe15 	stw	r4,-8(fp)
    int base;
    int found;
    eth_ocm_phy_profile *profile;
    // determine PHY speed: This is PHY dependent and you need to change
    // this according to your PHY's specifications
    duplex = 1;
 323c4b8:	00800044 	movi	r2,1
 323c4bc:	e0bffd15 	stw	r2,-12(fp)
    dat = 0;
 323c4c0:	e03ff715 	stw	zero,-36(fp)
    found = 0;
 323c4c4:	e03ff415 	stw	zero,-48(fp)
    base = dev->base;
 323c4c8:	e0bffe17 	ldw	r2,-8(fp)
 323c4cc:	10800717 	ldw	r2,28(r2)
 323c4d0:	e0bff515 	stw	r2,-44(fp)

    // Add internal PHY profiles
    eth_ocm_phy_profiles_init();
 323c4d4:	323c8380 	call	323c838 <eth_ocm_phy_profiles_init>

    // ------------------------------
    // PHY detection
    // ------------------------------
    phyid = eth_ocm_read_phy_reg(base, dat, ETH_OCM_PHY_ADDR_PHY_ID1);
 323c4d8:	e13ff517 	ldw	r4,-44(fp)
 323c4dc:	e17ff717 	ldw	r5,-36(fp)
 323c4e0:	01800084 	movi	r6,2
 323c4e4:	323c31c0 	call	323c31c <eth_ocm_read_phy_reg>
 323c4e8:	e0bffc15 	stw	r2,-16(fp)
    for (dat = 0x00; dat < 0xff; dat++){
 323c4ec:	e03ff715 	stw	zero,-36(fp)
 323c4f0:	00002906 	br	323c598 <eth_ocm_phy_init+0xf4>
        phyid = eth_ocm_read_phy_reg(base, dat, ETH_OCM_PHY_ADDR_PHY_ID1);
 323c4f4:	e13ff517 	ldw	r4,-44(fp)
 323c4f8:	e17ff717 	ldw	r5,-36(fp)
 323c4fc:	01800084 	movi	r6,2
 323c500:	323c31c0 	call	323c31c <eth_ocm_read_phy_reg>
 323c504:	e0bffc15 	stw	r2,-16(fp)
        phyid2 = eth_ocm_read_phy_reg(base, dat, ETH_OCM_PHY_ADDR_PHY_ID2);
 323c508:	e13ff517 	ldw	r4,-44(fp)
 323c50c:	e17ff717 	ldw	r5,-36(fp)
 323c510:	018000c4 	movi	r6,3
 323c514:	323c31c0 	call	323c31c <eth_ocm_read_phy_reg>
 323c518:	e0bffb15 	stw	r2,-20(fp)

        if (phyid != phyid2 && (phyid2 != 0xffff)){ // Found the PHY
 323c51c:	e0fffc17 	ldw	r3,-16(fp)
 323c520:	e0bffb17 	ldw	r2,-20(fp)
 323c524:	18801926 	beq	r3,r2,323c58c <eth_ocm_phy_init+0xe8>
 323c528:	e0fffb17 	ldw	r3,-20(fp)
 323c52c:	00bfffd4 	movui	r2,65535
 323c530:	18801626 	beq	r3,r2,323c58c <eth_ocm_phy_init+0xe8>
            // Extract phy info
            oui = phyid << 6;
 323c534:	e0bffc17 	ldw	r2,-16(fp)
 323c538:	100491ba 	slli	r2,r2,6
 323c53c:	e0bffa15 	stw	r2,-24(fp)
            oui |= ((phyid2 >> 10) & 0x003F);
 323c540:	e0bffb17 	ldw	r2,-20(fp)
 323c544:	1005d2ba 	srai	r2,r2,10
 323c548:	10c00fcc 	andi	r3,r2,63
 323c54c:	e0bffa17 	ldw	r2,-24(fp)
 323c550:	10c4b03a 	or	r2,r2,r3
 323c554:	e0bffa15 	stw	r2,-24(fp)
            mdl = ((phyid2 >> 4) & 0x03F);
 323c558:	e0bffb17 	ldw	r2,-20(fp)
 323c55c:	1005d13a 	srai	r2,r2,4
 323c560:	10800fcc 	andi	r2,r2,63
 323c564:	e0bff915 	stw	r2,-28(fp)
            rev = (phyid2 & 0x000F);
 323c568:	e0bffb17 	ldw	r2,-20(fp)
 323c56c:	108003cc 	andi	r2,r2,15
 323c570:	e0bff815 	stw	r2,-32(fp)
                    "  OUI: 0x%x\n"
                    "  Model: 0x%x\n"
                    "  Rev: 0x%x\n",
                    dat, oui, mdl, rev);
            #endif
            phyadd = dat;
 323c574:	e0bff717 	ldw	r2,-36(fp)
 323c578:	e0bff615 	stw	r2,-40(fp)
            dat = 0xff; // end loop
 323c57c:	00803fc4 	movi	r2,255
 323c580:	e0bff715 	stw	r2,-36(fp)
            found = 1;
 323c584:	00800044 	movi	r2,1
 323c588:	e0bff415 	stw	r2,-48(fp)

    // ------------------------------
    // PHY detection
    // ------------------------------
    phyid = eth_ocm_read_phy_reg(base, dat, ETH_OCM_PHY_ADDR_PHY_ID1);
    for (dat = 0x00; dat < 0xff; dat++){
 323c58c:	e0bff717 	ldw	r2,-36(fp)
 323c590:	10800044 	addi	r2,r2,1
 323c594:	e0bff715 	stw	r2,-36(fp)
 323c598:	e0bff717 	ldw	r2,-36(fp)
 323c59c:	10803fd0 	cmplti	r2,r2,255
 323c5a0:	103fd41e 	bne	r2,zero,323c4f4 <eth_ocm_phy_init+0x50>
            dat = 0xff; // end loop
            found = 1;
        }
    }

    if(!found){
 323c5a4:	e0bff417 	ldw	r2,-48(fp)
 323c5a8:	1004c03a 	cmpne	r2,r2,zero
 323c5ac:	1000021e 	bne	r2,zero,323c5b8 <eth_ocm_phy_init+0x114>
        #if(ETH_OCM_DBG_LVL > 0)
        printf("[eth_ocm_phy_init] NO PHY FOUND!\n");
        #endif
        return 0;
 323c5b0:	e03fff15 	stw	zero,-4(fp)
 323c5b4:	00006b06 	br	323c764 <eth_ocm_phy_init+0x2c0>
    }


    // A PHY was found, let's move on
    // Lookup PHY in table
    found = 0;
 323c5b8:	e03ff415 	stw	zero,-48(fp)
    for(dat=0;(dat<ETH_OCM_PHY_MAX_PROFILES) && (eth_ocm_phy_profile_array[dat] != 0); dat++){
 323c5bc:	e03ff715 	stw	zero,-36(fp)
 323c5c0:	00001606 	br	323c61c <eth_ocm_phy_init+0x178>
        profile = eth_ocm_phy_profile_array[dat];
 323c5c4:	e0bff717 	ldw	r2,-36(fp)
 323c5c8:	00c0c974 	movhi	r3,805
 323c5cc:	18d59a04 	addi	r3,r3,22120
 323c5d0:	1085883a 	add	r2,r2,r2
 323c5d4:	1085883a 	add	r2,r2,r2
 323c5d8:	10c5883a 	add	r2,r2,r3
 323c5dc:	10800017 	ldw	r2,0(r2)
 323c5e0:	e0bff315 	stw	r2,-52(fp)
        // We compare oui & model number but not rev.
        if( (profile->oui == oui) && (profile->model_number == mdl)){
 323c5e4:	e0bff317 	ldw	r2,-52(fp)
 323c5e8:	10c01417 	ldw	r3,80(r2)
 323c5ec:	e0bffa17 	ldw	r2,-24(fp)
 323c5f0:	1880071e 	bne	r3,r2,323c610 <eth_ocm_phy_init+0x16c>
 323c5f4:	e0bff317 	ldw	r2,-52(fp)
 323c5f8:	10801503 	ldbu	r2,84(r2)
 323c5fc:	10c03fcc 	andi	r3,r2,255
 323c600:	e0bff917 	ldw	r2,-28(fp)
 323c604:	1880021e 	bne	r3,r2,323c610 <eth_ocm_phy_init+0x16c>
            // Found a match in the table
            found = 1;
 323c608:	00800044 	movi	r2,1
 323c60c:	e0bff415 	stw	r2,-48(fp)


    // A PHY was found, let's move on
    // Lookup PHY in table
    found = 0;
    for(dat=0;(dat<ETH_OCM_PHY_MAX_PROFILES) && (eth_ocm_phy_profile_array[dat] != 0); dat++){
 323c610:	e0bff717 	ldw	r2,-36(fp)
 323c614:	10800044 	addi	r2,r2,1
 323c618:	e0bff715 	stw	r2,-36(fp)
 323c61c:	e0bff717 	ldw	r2,-36(fp)
 323c620:	108000c8 	cmpgei	r2,r2,3
 323c624:	1000091e 	bne	r2,zero,323c64c <eth_ocm_phy_init+0x1a8>
 323c628:	e0bff717 	ldw	r2,-36(fp)
 323c62c:	00c0c974 	movhi	r3,805
 323c630:	18d59a04 	addi	r3,r3,22120
 323c634:	1085883a 	add	r2,r2,r2
 323c638:	1085883a 	add	r2,r2,r2
 323c63c:	10c5883a 	add	r2,r2,r3
 323c640:	10800017 	ldw	r2,0(r2)
 323c644:	1004c03a 	cmpne	r2,r2,zero
 323c648:	103fde1e 	bne	r2,zero,323c5c4 <eth_ocm_phy_init+0x120>
            printf("[eth_ocm_phy_init] Found PHY: %s\n", profile->name);
            #endif
        }
    }

    if(!found){
 323c64c:	e0bff417 	ldw	r2,-48(fp)
 323c650:	1004c03a 	cmpne	r2,r2,zero
 323c654:	1000021e 	bne	r2,zero,323c660 <eth_ocm_phy_init+0x1bc>
        #if(ETH_OCM_DBG_LVL > 0)
        printf("[eth_ocm_phy_init] Could not find matching PHY profile!\n");
        #endif
        return 0;
 323c658:	e03fff15 	stw	zero,-4(fp)
 323c65c:	00004106 	br	323c764 <eth_ocm_phy_init+0x2c0>
    }

    dev->phyadd = phyadd;
 323c660:	e0fff617 	ldw	r3,-40(fp)
 323c664:	e0bffe17 	ldw	r2,-8(fp)
 323c668:	10c00815 	stw	r3,32(r2)
    // Call the config function if provided
    if(profile->phy_cfg != NULL)
 323c66c:	e0bff317 	ldw	r2,-52(fp)
 323c670:	10801617 	ldw	r2,88(r2)
 323c674:	1005003a 	cmpeq	r2,r2,zero
 323c678:	1000041e 	bne	r2,zero,323c68c <eth_ocm_phy_init+0x1e8>
        profile->phy_cfg(dev);
 323c67c:	e0bff317 	ldw	r2,-52(fp)
 323c680:	10801617 	ldw	r2,88(r2)
 323c684:	e13ffe17 	ldw	r4,-8(fp)
 323c688:	103ee83a 	callr	r2
        eth_ocm_write_phy_reg(base, phyadd, ETH_OCM_PHY_ADDR_CONTROL,PCS_CTL_an_enable | PCS_CTL_sw_reset);    // send PHY reset command
        dprintf("[eth_ocm_phy_init] PHY Reset\n" );
    }
    */
    
    if(!(eth_ocm_read_phy_reg(base, phyadd, ETH_OCM_PHY_ADDR_STATUS)& PCS_ST_an_done)) {
 323c68c:	e13ff517 	ldw	r4,-44(fp)
 323c690:	e17ff617 	ldw	r5,-40(fp)
 323c694:	01800044 	movi	r6,1
 323c698:	323c31c0 	call	323c31c <eth_ocm_read_phy_reg>
 323c69c:	1080080c 	andi	r2,r2,32
 323c6a0:	1004c03a 	cmpne	r2,r2,zero
 323c6a4:	1000141e 	bne	r2,zero,323c6f8 <eth_ocm_phy_init+0x254>
        #if(ETH_OCM_DBG_LVL > 0)
        printf("[eth_ocm_phy_init] Waiting on PHY link...");
        #endif
        dat=0;
 323c6a8:	e03ff715 	stw	zero,-36(fp)
        while( (eth_ocm_read_phy_reg(base, phyadd, ETH_OCM_PHY_ADDR_STATUS) & PCS_ST_an_done) == 0 ){
 323c6ac:	00000b06 	br	323c6dc <eth_ocm_phy_init+0x238>
            if( dat++ > ETH_OCM_PHY_TIMEOUT_THRESHOLD) {
 323c6b0:	e0fff717 	ldw	r3,-36(fp)
 323c6b4:	008000b4 	movhi	r2,2
 323c6b8:	10a1a804 	addi	r2,r2,-31072
 323c6bc:	10c4803a 	cmplt	r2,r2,r3
 323c6c0:	1007883a 	mov	r3,r2
 323c6c4:	e0bff717 	ldw	r2,-36(fp)
 323c6c8:	10800044 	addi	r2,r2,1
 323c6cc:	e0bff715 	stw	r2,-36(fp)
 323c6d0:	18803fcc 	andi	r2,r3,255
 323c6d4:	1004c03a 	cmpne	r2,r2,zero
 323c6d8:	1000071e 	bne	r2,zero,323c6f8 <eth_ocm_phy_init+0x254>
    if(!(eth_ocm_read_phy_reg(base, phyadd, ETH_OCM_PHY_ADDR_STATUS)& PCS_ST_an_done)) {
        #if(ETH_OCM_DBG_LVL > 0)
        printf("[eth_ocm_phy_init] Waiting on PHY link...");
        #endif
        dat=0;
        while( (eth_ocm_read_phy_reg(base, phyadd, ETH_OCM_PHY_ADDR_STATUS) & PCS_ST_an_done) == 0 ){
 323c6dc:	e13ff517 	ldw	r4,-44(fp)
 323c6e0:	e17ff617 	ldw	r5,-40(fp)
 323c6e4:	01800044 	movi	r6,1
 323c6e8:	323c31c0 	call	323c31c <eth_ocm_read_phy_reg>
 323c6ec:	1080080c 	andi	r2,r2,32
 323c6f0:	1005003a 	cmpeq	r2,r2,zero
 323c6f4:	103fee1e 	bne	r2,zero,323c6b0 <eth_ocm_phy_init+0x20c>
        #if(ETH_OCM_DBG_LVL > 0)
        printf("OK. x=%d, PHY STATUS=%04x\n",dat, eth_ocm_read_phy_reg(base, phyadd, ETH_OCM_PHY_ADDR_STATUS));
        #endif
    }

    if(profile->duplex_status_read != NULL){
 323c6f8:	e0bff317 	ldw	r2,-52(fp)
 323c6fc:	10801717 	ldw	r2,92(r2)
 323c700:	1005003a 	cmpeq	r2,r2,zero
 323c704:	1000071e 	bne	r2,zero,323c724 <eth_ocm_phy_init+0x280>
        duplex = profile->duplex_status_read(dev) & 0x01;
 323c708:	e0bff317 	ldw	r2,-52(fp)
 323c70c:	10801717 	ldw	r2,92(r2)
 323c710:	e13ffe17 	ldw	r4,-8(fp)
 323c714:	103ee83a 	callr	r2
 323c718:	1080004c 	andi	r2,r2,1
 323c71c:	e0bffd15 	stw	r2,-12(fp)
 323c720:	00000e06 	br	323c75c <eth_ocm_phy_init+0x2b8>
    }else{
        dat = eth_ocm_read_phy_reg(base, phyadd, profile->status_reg_location);
 323c724:	e0bff317 	ldw	r2,-52(fp)
 323c728:	10801583 	ldbu	r2,86(r2)
 323c72c:	11803fcc 	andi	r6,r2,255
 323c730:	e13ff517 	ldw	r4,-44(fp)
 323c734:	e17ff617 	ldw	r5,-40(fp)
 323c738:	323c31c0 	call	323c31c <eth_ocm_read_phy_reg>
 323c73c:	e0bff715 	stw	r2,-36(fp)
        duplex = (dat >> profile->duplex_bit_location) & 0x01;
 323c740:	e0bff317 	ldw	r2,-52(fp)
 323c744:	108015c3 	ldbu	r2,87(r2)
 323c748:	10c03fcc 	andi	r3,r2,255
 323c74c:	e0bff717 	ldw	r2,-36(fp)
 323c750:	10c5d83a 	sra	r2,r2,r3
 323c754:	1080004c 	andi	r2,r2,1
 323c758:	e0bffd15 	stw	r2,-12(fp)

    #if(ETH_OCM_DBG_LVL > 0)
    printf("[eth_ocm_phy_init] Full Duplex is %d\n", duplex);
    #endif

    return duplex;
 323c75c:	e0bffd17 	ldw	r2,-12(fp)
 323c760:	e0bfff15 	stw	r2,-4(fp)
 323c764:	e0bfff17 	ldw	r2,-4(fp)
}
 323c768:	e037883a 	mov	sp,fp
 323c76c:	dfc00117 	ldw	ra,4(sp)
 323c770:	df000017 	ldw	fp,0(sp)
 323c774:	dec00204 	addi	sp,sp,8
 323c778:	f800283a 	ret

0323c77c <phy_cfg_MVL88E1111>:

// ***************
// Marvell 88E1111
// ***************
#ifdef ETH_OCM_PHY_SUPPORT_MVL88E1111
static alt_32 phy_cfg_MVL88E1111(eth_ocm_dev *dev){
 323c77c:	defff904 	addi	sp,sp,-28
 323c780:	dfc00615 	stw	ra,24(sp)
 323c784:	df000515 	stw	fp,20(sp)
 323c788:	df000504 	addi	fp,sp,20
 323c78c:	e13fff15 	stw	r4,-4(fp)
    int duplex;     /* 1 = full ; 0 = half*/
    int dat;
    int phyadd;
    int base;

    duplex = 1;
 323c790:	00800044 	movi	r2,1
 323c794:	e0bffe15 	stw	r2,-8(fp)
    dat = 0;
 323c798:	e03ffd15 	stw	zero,-12(fp)
    phyadd = 0;
 323c79c:	e03ffc15 	stw	zero,-16(fp)
    base = dev->base;
 323c7a0:	e0bfff17 	ldw	r2,-4(fp)
 323c7a4:	10800717 	ldw	r2,28(r2)
 323c7a8:	e0bffb15 	stw	r2,-20(fp)
    phyadd = dev->phyadd;
 323c7ac:	e0bfff17 	ldw	r2,-4(fp)
 323c7b0:	10800817 	ldw	r2,32(r2)
 323c7b4:	e0bffc15 	stw	r2,-16(fp)

    // Disable 1000BASE-T Autonegotiation
    dat = eth_ocm_read_phy_reg(base, phyadd, 0x09);
 323c7b8:	e13ffb17 	ldw	r4,-20(fp)
 323c7bc:	e17ffc17 	ldw	r5,-16(fp)
 323c7c0:	01800244 	movi	r6,9
 323c7c4:	323c31c0 	call	323c31c <eth_ocm_read_phy_reg>
 323c7c8:	e0bffd15 	stw	r2,-12(fp)
    dat &= 0xFCFF;
 323c7cc:	e0bffd17 	ldw	r2,-12(fp)
 323c7d0:	10bf3fcc 	andi	r2,r2,64767
 323c7d4:	e0bffd15 	stw	r2,-12(fp)
    eth_ocm_write_phy_reg(base, phyadd, 0x09, dat);    
 323c7d8:	e13ffb17 	ldw	r4,-20(fp)
 323c7dc:	e17ffc17 	ldw	r5,-16(fp)
 323c7e0:	01800244 	movi	r6,9
 323c7e4:	e1fffd17 	ldw	r7,-12(fp)
 323c7e8:	323c2a80 	call	323c2a8 <eth_ocm_write_phy_reg>
    // Restart autonegotiation
    dat = eth_ocm_read_phy_reg(base, phyadd, ETH_OCM_PHY_ADDR_CONTROL);
 323c7ec:	e13ffb17 	ldw	r4,-20(fp)
 323c7f0:	e17ffc17 	ldw	r5,-16(fp)
 323c7f4:	000d883a 	mov	r6,zero
 323c7f8:	323c31c0 	call	323c31c <eth_ocm_read_phy_reg>
 323c7fc:	e0bffd15 	stw	r2,-12(fp)
    dat |=  PCS_CTL_an_restart;
 323c800:	e0bffd17 	ldw	r2,-12(fp)
 323c804:	10808014 	ori	r2,r2,512
 323c808:	e0bffd15 	stw	r2,-12(fp)
    eth_ocm_write_phy_reg(base, phyadd, ETH_OCM_PHY_ADDR_CONTROL, dat);
 323c80c:	e13ffb17 	ldw	r4,-20(fp)
 323c810:	e17ffc17 	ldw	r5,-16(fp)
 323c814:	000d883a 	mov	r6,zero
 323c818:	e1fffd17 	ldw	r7,-12(fp)
 323c81c:	323c2a80 	call	323c2a8 <eth_ocm_write_phy_reg>
    
    return 0;
 323c820:	0005883a 	mov	r2,zero
}
 323c824:	e037883a 	mov	sp,fp
 323c828:	dfc00117 	ldw	ra,4(sp)
 323c82c:	df000017 	ldw	fp,0(sp)
 323c830:	dec00204 	addi	sp,sp,8
 323c834:	f800283a 	ret

0323c838 <eth_ocm_phy_profiles_init>:
	NULL
};
 
#endif // ETH_OCM_PHY_SUPPORT_VSC8641

void eth_ocm_phy_profiles_init(){
 323c838:	defffe04 	addi	sp,sp,-8
 323c83c:	dfc00115 	stw	ra,4(sp)
 323c840:	df000015 	stw	fp,0(sp)
 323c844:	d839883a 	mov	fp,sp
#ifdef ETH_OCM_PHY_SUPPORT_LXT972A
    eth_ocm_phy_add_profile(&profile_LXT972A);
#endif

#ifdef ETH_OCM_PHY_SUPPORT_MVL88E1111
    eth_ocm_phy_add_profile(&profile_MVL88E1111);
 323c848:	0100c974 	movhi	r4,805
 323c84c:	2109ce04 	addi	r4,r4,10040
 323c850:	323c38c0 	call	323c38c <eth_ocm_phy_add_profile>
#endif

#ifdef ETH_OCM_PHY_SUPPORT_DP83848C
    eth_ocm_phy_add_profile(&profile_DP83848C);
 323c854:	0100c974 	movhi	r4,805
 323c858:	2109e604 	addi	r4,r4,10136
 323c85c:	323c38c0 	call	323c38c <eth_ocm_phy_add_profile>
#endif

#ifdef ETH_OCM_PHY_SUPPORT_VSC8641
    eth_ocm_phy_add_profile(&profile_VSC8641);
#endif
}
 323c860:	e037883a 	mov	sp,fp
 323c864:	dfc00117 	ldw	ra,4(sp)
 323c868:	df000017 	ldw	fp,0(sp)
 323c86c:	dec00204 	addi	sp,sp,8
 323c870:	f800283a 	ret

0323c874 <netmain_init>:
 * RETURNS: 
 */

void 
netmain_init(void)
{
 323c874:	defffb04 	addi	sp,sp,-20
 323c878:	dfc00415 	stw	ra,16(sp)
 323c87c:	df000315 	stw	fp,12(sp)
 323c880:	dc000215 	stw	r16,8(sp)
 323c884:	df000204 	addi	fp,sp,8
   int   e = 0;
 323c888:	e03fff15 	stw	zero,-4(fp)
   char *   msg;
#ifdef IP_V6
   ip6_addr host;
#endif

   printf("%s\n", name);
 323c88c:	d1204717 	ldw	r4,-32484(gp)
 323c890:	32071080 	call	3207108 <puts>
   printf("Copyright 1996-2008 by InterNiche Technologies. All rights reserved. \n");
 323c894:	0100c974 	movhi	r4,805
 323c898:	213e9004 	addi	r4,r4,-1472
 323c89c:	32071080 	call	3207108 <puts>
#ifdef IN_MENUS
   install_version("allports3.1");
#endif
#ifndef SUPERLOOP
   /* call this to do pre-task setup including intialization of port_prep */
   msg = pre_task_setup();
 323c8a0:	322b8340 	call	322b834 <pre_task_setup>
 323c8a4:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 323c8a8:	e0bffe17 	ldw	r2,-8(fp)
 323c8ac:	1005003a 	cmpeq	r2,r2,zero
 323c8b0:	1000021e 	bne	r2,zero,323c8bc <netmain_init+0x48>
      panic(msg);
 323c8b4:	e13ffe17 	ldw	r4,-8(fp)
 323c8b8:	32261540 	call	3226154 <panic>
      printf("global_log_create() failed\n");
   }
   glog_with_type(LOG_TYPE_INFO, "INICHE LOG initialized", 1);
#endif

   msg = ip_startup();
 323c8bc:	3223c9c0 	call	3223c9c <ip_startup>
 323c8c0:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 323c8c4:	e0bffe17 	ldw	r2,-8(fp)
 323c8c8:	1005003a 	cmpeq	r2,r2,zero
 323c8cc:	1000071e 	bne	r2,zero,323c8ec <netmain_init+0x78>
   {
      printf("inet startup error: %s\n", msg);
 323c8d0:	0100c974 	movhi	r4,805
 323c8d4:	213ea204 	addi	r4,r4,-1400
 323c8d8:	e17ffe17 	ldw	r5,-8(fp)
 323c8dc:	3206de00 	call	3206de0 <printf>
      panic("IP");
 323c8e0:	0100c974 	movhi	r4,805
 323c8e4:	213ea804 	addi	r4,r4,-1376
 323c8e8:	32261540 	call	3226154 <panic>
   }

#if defined(MEMDEV_SIZE) && defined(VFS_FILES)
   init_memdev(); /* init the mem and null test devices */
 323c8ec:	32473fc0 	call	32473fc <init_memdev>
#endif

#ifdef IP_MULTICAST
#ifdef INCLUDE_TCP
   /* call the IP multicast test program */
   u_mctest_init();
 323c8f0:	32469c40 	call	32469c4 <u_mctest_init>

   /* clear debugging flags. Port can optionally turn them
    * back on in post_task_setup();
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    
 323c8f4:	0080c974 	movhi	r2,805
 323c8f8:	10931c04 	addi	r2,r2,19568
 323c8fc:	10000015 	stw	zero,0(r2)

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 323c900:	0080c9b4 	movhi	r2,806
 323c904:	10b54604 	addi	r2,r2,-10984
 323c908:	10800017 	ldw	r2,0(r2)
 323c90c:	14000104 	addi	r16,r2,4
 323c910:	0080c9b4 	movhi	r2,806
 323c914:	10b54604 	addi	r2,r2,-10984
 323c918:	10800017 	ldw	r2,0(r2)
 323c91c:	11000a17 	ldw	r4,40(r2)
 323c920:	3225fb40 	call	3225fb4 <print_ipad>
 323c924:	100d883a 	mov	r6,r2
 323c928:	0100c974 	movhi	r4,805
 323c92c:	213ea904 	addi	r4,r4,-1372
 323c930:	800b883a 	mov	r5,r16
 323c934:	3206de00 	call	3206de0 <printf>
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 
#ifndef SUPERLOOP
   /* call this per-target routine after basic tasks & net are up */
   msg = post_task_setup();
 323c938:	322b8a80 	call	322b8a8 <post_task_setup>
 323c93c:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 323c940:	e0bffe17 	ldw	r2,-8(fp)
 323c944:	1005003a 	cmpeq	r2,r2,zero
 323c948:	1000021e 	bne	r2,zero,323c954 <netmain_init+0xe0>
      panic(msg);
 323c94c:	e13ffe17 	ldw	r4,-8(fp)
 323c950:	32261540 	call	3226154 <panic>
#ifdef USE_AUTOIP
   Upnp_init();      /* start Auto IP before DHCP client */
#endif   /* USE_AUTOIP */

#ifdef DHCP_CLIENT
   dhc_setup();   /* kick off any DHCP clients */
 323c954:	32470700 	call	3247070 <dhc_setup>
      panic("prep_modules");
   }
#endif
   USE_ARG(e);    /* Avoid compiler warnings */

} /* end of netmain_init() */
 323c958:	e037883a 	mov	sp,fp
 323c95c:	dfc00217 	ldw	ra,8(sp)
 323c960:	df000117 	ldw	fp,4(sp)
 323c964:	dc000017 	ldw	r16,0(sp)
 323c968:	dec00304 	addi	sp,sp,12
 323c96c:	f800283a 	ret

0323c970 <icmp_port_du>:
 * RETURNS: 
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
 323c970:	defffb04 	addi	sp,sp,-20
 323c974:	dfc00415 	stw	ra,16(sp)
 323c978:	df000315 	stw	fp,12(sp)
 323c97c:	dc000215 	stw	r16,8(sp)
 323c980:	df000204 	addi	fp,sp,8
 323c984:	e13ffe15 	stw	r4,-8(fp)
 323c988:	e17fff15 	stw	r5,-4(fp)
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
 323c98c:	e0bfff17 	ldw	r2,-4(fp)
 323c990:	10800003 	ldbu	r2,0(r2)
 323c994:	10803fcc 	andi	r2,r2,255
 323c998:	1080201c 	xori	r2,r2,128
 323c99c:	10bfe004 	addi	r2,r2,-128
 323c9a0:	00c0c974 	movhi	r3,805
 323c9a4:	18c9fe04 	addi	r3,r3,10232
 323c9a8:	1085883a 	add	r2,r2,r2
 323c9ac:	1085883a 	add	r2,r2,r2
 323c9b0:	10c5883a 	add	r2,r2,r3
 323c9b4:	14000017 	ldw	r16,0(r2)
 323c9b8:	e0bffe17 	ldw	r2,-8(fp)
 323c9bc:	11000717 	ldw	r4,28(r2)
 323c9c0:	3225fb40 	call	3225fb4 <print_ipad>
 323c9c4:	100d883a 	mov	r6,r2
 323c9c8:	0100c974 	movhi	r4,805
 323c9cc:	213eb904 	addi	r4,r4,-1308
 323c9d0:	800b883a 	mov	r5,r16
 323c9d4:	3206de00 	call	3206de0 <printf>
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
   dprintf(prompt);
 323c9d8:	d1204817 	ldw	r4,-32480(gp)
 323c9dc:	3206de00 	call	3206de0 <printf>
}
 323c9e0:	e037883a 	mov	sp,fp
 323c9e4:	dfc00217 	ldw	ra,8(sp)
 323c9e8:	df000117 	ldw	fp,4(sp)
 323c9ec:	dc000017 	ldw	r16,0(sp)
 323c9f0:	dec00304 	addi	sp,sp,12
 323c9f4:	f800283a 	ret

0323c9f8 <station_state>:
 * RETURNS: 
 */

int
station_state(void * pio)
{
 323c9f8:	defff904 	addi	sp,sp,-28
 323c9fc:	dfc00615 	stw	ra,24(sp)
 323ca00:	df000515 	stw	fp,20(sp)
 323ca04:	dc000415 	stw	r16,16(sp)
 323ca08:	df000404 	addi	fp,sp,16
 323ca0c:	e13fff15 	stw	r4,-4(fp)
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 323ca10:	e03ffe15 	stw	zero,-8(fp)
 323ca14:	0080c9b4 	movhi	r2,806
 323ca18:	10b54604 	addi	r2,r2,-10984
 323ca1c:	10800017 	ldw	r2,0(r2)
 323ca20:	e0bffd15 	stw	r2,-12(fp)
 323ca24:	00002206 	br	323cab0 <station_state+0xb8>
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
 323ca28:	e0bffd17 	ldw	r2,-12(fp)
 323ca2c:	14000104 	addi	r16,r2,4
 323ca30:	e0bffd17 	ldw	r2,-12(fp)
 323ca34:	11000a17 	ldw	r4,40(r2)
 323ca38:	3225fb40 	call	3225fb4 <print_ipad>
 323ca3c:	d8800015 	stw	r2,0(sp)
 323ca40:	e13fff17 	ldw	r4,-4(fp)
 323ca44:	0140c974 	movhi	r5,805
 323ca48:	297ec204 	addi	r5,r5,-1272
 323ca4c:	e1bffe17 	ldw	r6,-8(fp)
 323ca50:	800f883a 	mov	r7,r16
 323ca54:	322637c0 	call	322637c <ns_printf>
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
 323ca58:	e0bffd17 	ldw	r2,-12(fp)
 323ca5c:	11000c17 	ldw	r4,48(r2)
 323ca60:	3225fb40 	call	3225fb4 <print_ipad>
 323ca64:	100d883a 	mov	r6,r2
 323ca68:	e13fff17 	ldw	r4,-4(fp)
 323ca6c:	0140c974 	movhi	r5,805
 323ca70:	297ec904 	addi	r5,r5,-1244
 323ca74:	322637c0 	call	322637c <ns_printf>
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
 323ca78:	e0bffd17 	ldw	r2,-12(fp)
 323ca7c:	11000d17 	ldw	r4,52(r2)
 323ca80:	3225fb40 	call	3225fb4 <print_ipad>
 323ca84:	100d883a 	mov	r6,r2
 323ca88:	e13fff17 	ldw	r4,-4(fp)
 323ca8c:	0140c974 	movhi	r5,805
 323ca90:	297ecc04 	addi	r5,r5,-1232
 323ca94:	322637c0 	call	322637c <ns_printf>
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 323ca98:	e0bffd17 	ldw	r2,-12(fp)
 323ca9c:	10800017 	ldw	r2,0(r2)
 323caa0:	e0bffd15 	stw	r2,-12(fp)
 323caa4:	e0bffe17 	ldw	r2,-8(fp)
 323caa8:	10800044 	addi	r2,r2,1
 323caac:	e0bffe15 	stw	r2,-8(fp)
 323cab0:	e0bffd17 	ldw	r2,-12(fp)
 323cab4:	1004c03a 	cmpne	r2,r2,zero
 323cab8:	103fdb1e 	bne	r2,zero,323ca28 <station_state+0x30>
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
   }
#endif   /* NO_INET_STACK */

   ns_printf(pio, "current tick count %lu\n", cticks);
 323cabc:	0080c974 	movhi	r2,805
 323cac0:	10934104 	addi	r2,r2,19716
 323cac4:	11800017 	ldw	r6,0(r2)
 323cac8:	e13fff17 	ldw	r4,-4(fp)
 323cacc:	0140c974 	movhi	r5,805
 323cad0:	297ecf04 	addi	r5,r5,-1220
 323cad4:	322637c0 	call	322637c <ns_printf>

   ns_printf(pio, "common delay parameter:  %lu ticks (%lu ms).\n", pingdelay, (pingdelay * TIMEFOR1TICK));
 323cad8:	d1a04917 	ldw	r6,-32476(gp)
 323cadc:	d1e04917 	ldw	r7,-32476(gp)
 323cae0:	e13fff17 	ldw	r4,-4(fp)
 323cae4:	0140c974 	movhi	r5,805
 323cae8:	297ed504 	addi	r5,r5,-1196
 323caec:	322637c0 	call	322637c <ns_printf>
   ns_printf(pio, "common host parameter: %s\n", print_ipad(activehost));
 323caf0:	d128f117 	ldw	r4,-23612(gp)
 323caf4:	3225fb40 	call	3225fb4 <print_ipad>
 323caf8:	100d883a 	mov	r6,r2
 323cafc:	e13fff17 	ldw	r4,-4(fp)
 323cb00:	0140c974 	movhi	r5,805
 323cb04:	297ee104 	addi	r5,r5,-1148
 323cb08:	322637c0 	call	322637c <ns_printf>
   ns_printf(pio, "common length parameter: %d\n", deflength);
 323cb0c:	d1a04a17 	ldw	r6,-32472(gp)
 323cb10:	e13fff17 	ldw	r4,-4(fp)
 323cb14:	0140c974 	movhi	r5,805
 323cb18:	297ee804 	addi	r5,r5,-1120
 323cb1c:	322637c0 	call	322637c <ns_printf>
#ifdef USE_PPP
   ns_printf(pio, "current dial-in user name is %s\n", pppcfg.username);
   ns_printf(pio, "current dial-in password is %s\n", pppcfg.password);
#endif   /* USE_PPP */

   task_stats(pio);
 323cb20:	e13fff17 	ldw	r4,-4(fp)
 323cb24:	323d0ec0 	call	323d0ec <task_stats>

   return 0;
 323cb28:	0005883a 	mov	r2,zero
}
 323cb2c:	e037883a 	mov	sp,fp
 323cb30:	dfc00217 	ldw	ra,8(sp)
 323cb34:	df000117 	ldw	fp,4(sp)
 323cb38:	dc000017 	ldw	r16,0(sp)
 323cb3c:	dec00304 	addi	sp,sp,12
 323cb40:	f800283a 	ret

0323cb44 <sysuptime>:
 * RETURNS: 
 */

unsigned long
sysuptime()
{
 323cb44:	defffe04 	addi	sp,sp,-8
 323cb48:	dfc00115 	stw	ra,4(sp)
 323cb4c:	df000015 	stw	fp,0(sp)
 323cb50:	d839883a 	mov	fp,sp
   return ((cticks/TPS)*100);    /* 100ths of a sec since boot time */
 323cb54:	0080c974 	movhi	r2,805
 323cb58:	10934104 	addi	r2,r2,19716
 323cb5c:	11000017 	ldw	r4,0(r2)
 323cb60:	0140fa04 	movi	r5,1000
 323cb64:	32047c00 	call	32047c0 <__udivsi3>
 323cb68:	10801924 	muli	r2,r2,100
}
 323cb6c:	e037883a 	mov	sp,fp
 323cb70:	dfc00117 	ldw	ra,4(sp)
 323cb74:	df000017 	ldw	fp,0(sp)
 323cb78:	dec00204 	addi	sp,sp,8
 323cb7c:	f800283a 	ret

0323cb80 <packet_check>:

static int inside_pktdemux = 0; 

void
packet_check(void)
{
 323cb80:	defffe04 	addi	sp,sp,-8
 323cb84:	dfc00115 	stw	ra,4(sp)
 323cb88:	df000015 	stw	fp,0(sp)
 323cb8c:	d839883a 	mov	fp,sp
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
 323cb90:	d0a8f217 	ldw	r2,-23608(gp)
 323cb94:	1004c03a 	cmpne	r2,r2,zero
 323cb98:	1000071e 	bne	r2,zero,323cbb8 <packet_check+0x38>
      return;           /* do not re-enter pktdemux(), packet will wait... */
   inside_pktdemux++;   /* set re-entrany flag */
 323cb9c:	d0a8f217 	ldw	r2,-23608(gp)
 323cba0:	10800044 	addi	r2,r2,1
 323cba4:	d0a8f215 	stw	r2,-23608(gp)
   pktdemux();          /* process low level packet input */
 323cba8:	32236540 	call	3223654 <pktdemux>
   inside_pktdemux--;   /* clear re-entrany flag */
 323cbac:	d0a8f217 	ldw	r2,-23608(gp)
 323cbb0:	10bfffc4 	addi	r2,r2,-1
 323cbb4:	d0a8f215 	stw	r2,-23608(gp)
}
 323cbb8:	e037883a 	mov	sp,fp
 323cbbc:	dfc00117 	ldw	ra,4(sp)
 323cbc0:	df000017 	ldw	fp,0(sp)
 323cbc4:	dec00204 	addi	sp,sp,8
 323cbc8:	f800283a 	ret

0323cbcc <mcastlist>:
 * RETURNS: 
 */

int
mcastlist(struct in_multi * multi_ptr)
{
 323cbcc:	defffe04 	addi	sp,sp,-8
 323cbd0:	df000115 	stw	fp,4(sp)
 323cbd4:	df000104 	addi	fp,sp,4
 323cbd8:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(multi_ptr);

   return 0;
 323cbdc:	0005883a 	mov	r2,zero
}
 323cbe0:	e037883a 	mov	sp,fp
 323cbe4:	df000017 	ldw	fp,0(sp)
 323cbe8:	dec00104 	addi	sp,sp,4
 323cbec:	f800283a 	ret

0323cbf0 <prep_modules>:
#ifdef USE_MODEM
extern   int   prep_modem(void);
#endif   /* USE_MODEM */

int prep_modules(void)
{
 323cbf0:	defffd04 	addi	sp,sp,-12
 323cbf4:	dfc00215 	stw	ra,8(sp)
 323cbf8:	df000115 	stw	fp,4(sp)
 323cbfc:	df000104 	addi	fp,sp,4
#ifdef IP_V6
   ip6_addr host;
   int i;
#endif

int e = 0;
 323cc00:	e03fff15 	stw	zero,-4(fp)
      panic("prep_modules");
   }
#endif   /* SMTP_ALERTS */

#ifdef VFS_FILES
   e = prep_vfs();
 323cc04:	324a5580 	call	324a558 <prep_vfs>
 323cc08:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0)
 323cc0c:	e0bfff17 	ldw	r2,-4(fp)
 323cc10:	1005003a 	cmpeq	r2,r2,zero
 323cc14:	1000061e 	bne	r2,zero,323cc30 <prep_modules+0x40>
   {
      dprintf("VFS Module prep failed\n");
 323cc18:	0100c974 	movhi	r4,805
 323cc1c:	213ef004 	addi	r4,r4,-1088
 323cc20:	32071080 	call	3207108 <puts>
      panic("prep_modules");
 323cc24:	0100c974 	movhi	r4,805
 323cc28:	213ef604 	addi	r4,r4,-1064
 323cc2c:	32261540 	call	3226154 <panic>
   {
      dprintf("sslapp_init() failed\n");
      panic("prep_modules");
   }
#endif
   return 0;
 323cc30:	0005883a 	mov	r2,zero
}
 323cc34:	e037883a 	mov	sp,fp
 323cc38:	dfc00117 	ldw	ra,4(sp)
 323cc3c:	df000017 	ldw	fp,0(sp)
 323cc40:	dec00204 	addi	sp,sp,8
 323cc44:	f800283a 	ret

0323cc48 <inet_timer>:
 * RETURNS: 
 */

void
inet_timer(void)
{
 323cc48:	defffe04 	addi	sp,sp,-8
 323cc4c:	dfc00115 	stw	ra,4(sp)
 323cc50:	df000015 	stw	fp,0(sp)
 323cc54:	d839883a 	mov	fp,sp
#ifdef IP_FRAGMENTS
   /* run thru' the IP reassembly queue (once every second) */
   if (ire_cticks < cticks)
 323cc58:	0080c974 	movhi	r2,805
 323cc5c:	10936204 	addi	r2,r2,19848
 323cc60:	10c00017 	ldw	r3,0(r2)
 323cc64:	0080c974 	movhi	r2,805
 323cc68:	10934104 	addi	r2,r2,19716
 323cc6c:	10800017 	ldw	r2,0(r2)
 323cc70:	1880012e 	bgeu	r3,r2,323cc78 <inet_timer+0x30>
      ip_reasm_process_timer_tick ();
 323cc74:	32421f80 	call	32421f8 <ip_reasm_process_timer_tick>
#endif

#ifdef INCLUDE_TCP
   tcp_tick();          /* run TCP timers */
 323cc78:	322d4780 	call	322d478 <tcp_tick>
#endif

#ifdef INICHE_TIMERS    /* interval timers? */
   check_interval_timers();
 323cc7c:	323cd0c0 	call	323cd0c <check_interval_timers>
#endif

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Call igmp timeout routine */
   if (igmp_cticks < cticks)  /* Call igmp timeout routine 5 times per sec */
 323cc80:	0080c974 	movhi	r2,805
 323cc84:	10932004 	addi	r2,r2,19584
 323cc88:	10c00017 	ldw	r3,0(r2)
 323cc8c:	0080c974 	movhi	r2,805
 323cc90:	10934104 	addi	r2,r2,19716
 323cc94:	10800017 	ldw	r2,0(r2)
 323cc98:	1880012e 	bgeu	r3,r2,323cca0 <inet_timer+0x58>
      igmp_fasttimo();
 323cc9c:	32242f40 	call	32242f4 <igmp_fasttimo>
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 323cca0:	d0a8f317 	ldw	r2,-23604(gp)
 323cca4:	00c0c974 	movhi	r3,805
 323cca8:	18d34104 	addi	r3,r3,19716
 323ccac:	18c00017 	ldw	r3,0(r3)
 323ccb0:	10c00636 	bltu	r2,r3,323cccc <inet_timer+0x84>
 323ccb4:	0080c974 	movhi	r2,805
 323ccb8:	10934104 	addi	r2,r2,19716
 323ccbc:	10800017 	ldw	r2,0(r2)
 323ccc0:	10c9c404 	addi	r3,r2,10000
 323ccc4:	d0a8f317 	ldw	r2,-23604(gp)
 323ccc8:	18800b2e 	bgeu	r3,r2,323ccf8 <inet_timer+0xb0>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
   {
      nextppp = cticks + TPS;
 323cccc:	0080c974 	movhi	r2,805
 323ccd0:	10934104 	addi	r2,r2,19716
 323ccd4:	10800017 	ldw	r2,0(r2)
 323ccd8:	1080fa04 	addi	r2,r2,1000
 323ccdc:	d0a8f315 	stw	r2,-23604(gp)

      if (port_1s_callout != NULL)
 323cce0:	d0a8f417 	ldw	r2,-23600(gp)
 323cce4:	1005003a 	cmpeq	r2,r2,zero
 323cce8:	1000021e 	bne	r2,zero,323ccf4 <inet_timer+0xac>
         (*port_1s_callout)();
 323ccec:	d0a8f417 	ldw	r2,-23600(gp)
 323ccf0:	103ee83a 	callr	r2

#ifdef USE_PPP
      ppp_timeisup();
#endif
#ifdef DHCP_CLIENT
      dhc_second();
 323ccf4:	32295480 	call	3229548 <dhc_second>
#endif
#ifdef IPSEC
      IPSecTimer();
#endif
   }
}
 323ccf8:	e037883a 	mov	sp,fp
 323ccfc:	dfc00117 	ldw	ra,4(sp)
 323cd00:	df000017 	ldw	fp,0(sp)
 323cd04:	dec00204 	addi	sp,sp,8
 323cd08:	f800283a 	ret

0323cd0c <check_interval_timers>:

static int numtimers = 0;     /* number of active timers */

static void
check_interval_timers(void)
{
 323cd0c:	defffc04 	addi	sp,sp,-16
 323cd10:	dfc00315 	stw	ra,12(sp)
 323cd14:	df000215 	stw	fp,8(sp)
 323cd18:	df000204 	addi	fp,sp,8
   int   i;
   int   found = 0;  /* number of valid timers found */
 323cd1c:	e03ffe15 	stw	zero,-8(fp)

   /* if no timers, just return */
   if (numtimers > 0)
 323cd20:	d0a8f517 	ldw	r2,-23596(gp)
 323cd24:	10800050 	cmplti	r2,r2,1
 323cd28:	1000591e 	bne	r2,zero,323ce90 <check_interval_timers+0x184>
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 323cd2c:	e03fff15 	stw	zero,-4(fp)
 323cd30:	00005406 	br	323ce84 <check_interval_timers+0x178>
      {
         if (intimers[i].callback)   /* is this timer active? */
 323cd34:	e0bfff17 	ldw	r2,-4(fp)
 323cd38:	00c0c9b4 	movhi	r3,806
 323cd3c:	18f4ed04 	addi	r3,r3,-11340
 323cd40:	10800524 	muli	r2,r2,20
 323cd44:	10c5883a 	add	r2,r2,r3
 323cd48:	10800017 	ldw	r2,0(r2)
 323cd4c:	1005003a 	cmpeq	r2,r2,zero
 323cd50:	1000491e 	bne	r2,zero,323ce78 <check_interval_timers+0x16c>
	 {
            if ((intimers[i].tmo < cticks) && (!intimers[i].inuse))  /* timer ready fire? */
 323cd54:	e0bfff17 	ldw	r2,-4(fp)
 323cd58:	00c0c9b4 	movhi	r3,806
 323cd5c:	18f4ed04 	addi	r3,r3,-11340
 323cd60:	10800524 	muli	r2,r2,20
 323cd64:	10c5883a 	add	r2,r2,r3
 323cd68:	10800304 	addi	r2,r2,12
 323cd6c:	10c00017 	ldw	r3,0(r2)
 323cd70:	0080c974 	movhi	r2,805
 323cd74:	10934104 	addi	r2,r2,19716
 323cd78:	10800017 	ldw	r2,0(r2)
 323cd7c:	1880382e 	bgeu	r3,r2,323ce60 <check_interval_timers+0x154>
 323cd80:	e0bfff17 	ldw	r2,-4(fp)
 323cd84:	00c0c9b4 	movhi	r3,806
 323cd88:	18f4ed04 	addi	r3,r3,-11340
 323cd8c:	10800524 	muli	r2,r2,20
 323cd90:	10c5883a 	add	r2,r2,r3
 323cd94:	10800404 	addi	r2,r2,16
 323cd98:	10800017 	ldw	r2,0(r2)
 323cd9c:	1004c03a 	cmpne	r2,r2,zero
 323cda0:	10002f1e 	bne	r2,zero,323ce60 <check_interval_timers+0x154>
            {
               intimers[i].tmo = intimers[i].interval + cticks;   /* set next tmo */
 323cda4:	e17fff17 	ldw	r5,-4(fp)
 323cda8:	e0bfff17 	ldw	r2,-4(fp)
 323cdac:	00c0c9b4 	movhi	r3,806
 323cdb0:	18f4ed04 	addi	r3,r3,-11340
 323cdb4:	10800524 	muli	r2,r2,20
 323cdb8:	10c5883a 	add	r2,r2,r3
 323cdbc:	10800204 	addi	r2,r2,8
 323cdc0:	10c00017 	ldw	r3,0(r2)
 323cdc4:	0080c974 	movhi	r2,805
 323cdc8:	10934104 	addi	r2,r2,19716
 323cdcc:	10800017 	ldw	r2,0(r2)
 323cdd0:	1889883a 	add	r4,r3,r2
 323cdd4:	00c0c9b4 	movhi	r3,806
 323cdd8:	18f4ed04 	addi	r3,r3,-11340
 323cddc:	28800524 	muli	r2,r5,20
 323cde0:	10c5883a 	add	r2,r2,r3
 323cde4:	10800304 	addi	r2,r2,12
 323cde8:	11000015 	stw	r4,0(r2)
               intimers[i].inuse = TRUE;
 323cdec:	e0bfff17 	ldw	r2,-4(fp)
 323cdf0:	00c0c9b4 	movhi	r3,806
 323cdf4:	18f4ed04 	addi	r3,r3,-11340
 323cdf8:	10800524 	muli	r2,r2,20
 323cdfc:	10c5883a 	add	r2,r2,r3
 323ce00:	10c00404 	addi	r3,r2,16
 323ce04:	00800044 	movi	r2,1
 323ce08:	18800015 	stw	r2,0(r3)
               intimers[i].callback(intimers[i].parm);      /* call user routine */
 323ce0c:	e0bfff17 	ldw	r2,-4(fp)
 323ce10:	00c0c9b4 	movhi	r3,806
 323ce14:	18f4ed04 	addi	r3,r3,-11340
 323ce18:	10800524 	muli	r2,r2,20
 323ce1c:	10c5883a 	add	r2,r2,r3
 323ce20:	11400017 	ldw	r5,0(r2)
 323ce24:	e0bfff17 	ldw	r2,-4(fp)
 323ce28:	00c0c9b4 	movhi	r3,806
 323ce2c:	18f4ed04 	addi	r3,r3,-11340
 323ce30:	10800524 	muli	r2,r2,20
 323ce34:	10c5883a 	add	r2,r2,r3
 323ce38:	10800104 	addi	r2,r2,4
 323ce3c:	11000017 	ldw	r4,0(r2)
 323ce40:	283ee83a 	callr	r5
               intimers[i].inuse = FALSE;
 323ce44:	e0bfff17 	ldw	r2,-4(fp)
 323ce48:	00c0c9b4 	movhi	r3,806
 323ce4c:	18f4ed04 	addi	r3,r3,-11340
 323ce50:	10800524 	muli	r2,r2,20
 323ce54:	10c5883a 	add	r2,r2,r3
 323ce58:	10800404 	addi	r2,r2,16
 323ce5c:	10000015 	stw	zero,0(r2)
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
 323ce60:	e0bffe17 	ldw	r2,-8(fp)
 323ce64:	10800044 	addi	r2,r2,1
 323ce68:	e0bffe15 	stw	r2,-8(fp)
 323ce6c:	d0e8f517 	ldw	r3,-23596(gp)
 323ce70:	e0bffe17 	ldw	r2,-8(fp)
 323ce74:	10c0060e 	bge	r2,r3,323ce90 <check_interval_timers+0x184>

   /* if no timers, just return */
   if (numtimers > 0)
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 323ce78:	e0bfff17 	ldw	r2,-4(fp)
 323ce7c:	10800044 	addi	r2,r2,1
 323ce80:	e0bfff15 	stw	r2,-4(fp)
 323ce84:	e0bfff17 	ldw	r2,-4(fp)
 323ce88:	10800150 	cmplti	r2,r2,5
 323ce8c:	103fa91e 	bne	r2,zero,323cd34 <check_interval_timers+0x28>
            if (++found >= numtimers)
               break;
         }
      }
   }
}
 323ce90:	e037883a 	mov	sp,fp
 323ce94:	dfc00117 	ldw	ra,4(sp)
 323ce98:	df000017 	ldw	fp,0(sp)
 323ce9c:	dec00204 	addi	sp,sp,8
 323cea0:	f800283a 	ret

0323cea4 <in_timerset>:
 * RETURNS: timer ID if OK, else if table is full.
 */

long
in_timerset(void (*callback)(long), long msecs, long parm)
{
 323cea4:	defff804 	addi	sp,sp,-32
 323cea8:	dfc00715 	stw	ra,28(sp)
 323ceac:	df000615 	stw	fp,24(sp)
 323ceb0:	dc000515 	stw	r16,20(sp)
 323ceb4:	df000504 	addi	fp,sp,20
 323ceb8:	e13ffc15 	stw	r4,-16(fp)
 323cebc:	e17ffd15 	stw	r5,-12(fp)
 323cec0:	e1bffe15 	stw	r6,-8(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 323cec4:	e03ffb15 	stw	zero,-20(fp)
 323cec8:	00004a06 	br	323cff4 <in_timerset+0x150>
   {
      if(intimers[i].callback == NULL)
 323cecc:	e0bffb17 	ldw	r2,-20(fp)
 323ced0:	00c0c9b4 	movhi	r3,806
 323ced4:	18f4ed04 	addi	r3,r3,-11340
 323ced8:	10800524 	muli	r2,r2,20
 323cedc:	10c5883a 	add	r2,r2,r3
 323cee0:	10800017 	ldw	r2,0(r2)
 323cee4:	1004c03a 	cmpne	r2,r2,zero
 323cee8:	10003f1e 	bne	r2,zero,323cfe8 <in_timerset+0x144>
      {
         /* found empty table entry, set up new timer */
         intimers[i].callback = callback;
 323ceec:	e0bffb17 	ldw	r2,-20(fp)
 323cef0:	00c0c9b4 	movhi	r3,806
 323cef4:	18f4ed04 	addi	r3,r3,-11340
 323cef8:	10800524 	muli	r2,r2,20
 323cefc:	10c7883a 	add	r3,r2,r3
 323cf00:	e0bffc17 	ldw	r2,-16(fp)
 323cf04:	18800015 	stw	r2,0(r3)
         intimers[i].parm = parm;
 323cf08:	e0bffb17 	ldw	r2,-20(fp)
 323cf0c:	00c0c9b4 	movhi	r3,806
 323cf10:	18f4ed04 	addi	r3,r3,-11340
 323cf14:	10800524 	muli	r2,r2,20
 323cf18:	10c5883a 	add	r2,r2,r3
 323cf1c:	10c00104 	addi	r3,r2,4
 323cf20:	e0bffe17 	ldw	r2,-8(fp)
 323cf24:	18800015 	stw	r2,0(r3)
         /* set interval, in TPS (cticks) units */
         intimers[i].interval = (msecs * TPS)/1000;
 323cf28:	e43ffb17 	ldw	r16,-20(fp)
 323cf2c:	e0bffd17 	ldw	r2,-12(fp)
 323cf30:	1100fa24 	muli	r4,r2,1000
 323cf34:	0140fa04 	movi	r5,1000
 323cf38:	32047c00 	call	32047c0 <__udivsi3>
 323cf3c:	1009883a 	mov	r4,r2
 323cf40:	00c0c9b4 	movhi	r3,806
 323cf44:	18f4ed04 	addi	r3,r3,-11340
 323cf48:	80800524 	muli	r2,r16,20
 323cf4c:	10c5883a 	add	r2,r2,r3
 323cf50:	10800204 	addi	r2,r2,8
 323cf54:	11000015 	stw	r4,0(r2)
         intimers[i].tmo = intimers[i].interval + cticks;   /* first tmo */
 323cf58:	e17ffb17 	ldw	r5,-20(fp)
 323cf5c:	e0bffb17 	ldw	r2,-20(fp)
 323cf60:	00c0c9b4 	movhi	r3,806
 323cf64:	18f4ed04 	addi	r3,r3,-11340
 323cf68:	10800524 	muli	r2,r2,20
 323cf6c:	10c5883a 	add	r2,r2,r3
 323cf70:	10800204 	addi	r2,r2,8
 323cf74:	10c00017 	ldw	r3,0(r2)
 323cf78:	0080c974 	movhi	r2,805
 323cf7c:	10934104 	addi	r2,r2,19716
 323cf80:	10800017 	ldw	r2,0(r2)
 323cf84:	1889883a 	add	r4,r3,r2
 323cf88:	00c0c9b4 	movhi	r3,806
 323cf8c:	18f4ed04 	addi	r3,r3,-11340
 323cf90:	28800524 	muli	r2,r5,20
 323cf94:	10c5883a 	add	r2,r2,r3
 323cf98:	10800304 	addi	r2,r2,12
 323cf9c:	11000015 	stw	r4,0(r2)
		 intimers[i].inuse = FALSE;
 323cfa0:	e0bffb17 	ldw	r2,-20(fp)
 323cfa4:	00c0c9b4 	movhi	r3,806
 323cfa8:	18f4ed04 	addi	r3,r3,-11340
 323cfac:	10800524 	muli	r2,r2,20
 323cfb0:	10c5883a 	add	r2,r2,r3
 323cfb4:	10800404 	addi	r2,r2,16
 323cfb8:	10000015 	stw	zero,0(r2)
         numtimers++;
 323cfbc:	d0a8f517 	ldw	r2,-23596(gp)
 323cfc0:	10800044 	addi	r2,r2,1
 323cfc4:	d0a8f515 	stw	r2,-23596(gp)
         return (long)&intimers[i];
 323cfc8:	e0bffb17 	ldw	r2,-20(fp)
 323cfcc:	10800524 	muli	r2,r2,20
 323cfd0:	1007883a 	mov	r3,r2
 323cfd4:	0080c9b4 	movhi	r2,806
 323cfd8:	10b4ed04 	addi	r2,r2,-11340
 323cfdc:	1885883a 	add	r2,r3,r2
 323cfe0:	e0bfff15 	stw	r2,-4(fp)
 323cfe4:	00000706 	br	323d004 <in_timerset+0x160>
long
in_timerset(void (*callback)(long), long msecs, long parm)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 323cfe8:	e0bffb17 	ldw	r2,-20(fp)
 323cfec:	10800044 	addi	r2,r2,1
 323cff0:	e0bffb15 	stw	r2,-20(fp)
 323cff4:	e0bffb17 	ldw	r2,-20(fp)
 323cff8:	10800150 	cmplti	r2,r2,5
 323cffc:	103fb31e 	bne	r2,zero,323cecc <in_timerset+0x28>
		 intimers[i].inuse = FALSE;
         numtimers++;
         return (long)&intimers[i];
      }
   }
   return 0;
 323d000:	e03fff15 	stw	zero,-4(fp)
 323d004:	e0bfff17 	ldw	r2,-4(fp)
}
 323d008:	e037883a 	mov	sp,fp
 323d00c:	dfc00217 	ldw	ra,8(sp)
 323d010:	df000117 	ldw	fp,4(sp)
 323d014:	dc000017 	ldw	r16,0(sp)
 323d018:	dec00304 	addi	sp,sp,12
 323d01c:	f800283a 	ret

0323d020 <in_timerkill>:
 */


int
in_timerkill(long timer)
{
 323d020:	defffb04 	addi	sp,sp,-20
 323d024:	dfc00415 	stw	ra,16(sp)
 323d028:	df000315 	stw	fp,12(sp)
 323d02c:	df000304 	addi	fp,sp,12
 323d030:	e13ffe15 	stw	r4,-8(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 323d034:	e03ffd15 	stw	zero,-12(fp)
 323d038:	00001706 	br	323d098 <in_timerkill+0x78>
   {
      if(timer == (long)&intimers[i])
 323d03c:	e0bffd17 	ldw	r2,-12(fp)
 323d040:	10800524 	muli	r2,r2,20
 323d044:	1007883a 	mov	r3,r2
 323d048:	0080c9b4 	movhi	r2,806
 323d04c:	10b4ed04 	addi	r2,r2,-11340
 323d050:	1885883a 	add	r2,r3,r2
 323d054:	1007883a 	mov	r3,r2
 323d058:	e0bffe17 	ldw	r2,-8(fp)
 323d05c:	18800b1e 	bne	r3,r2,323d08c <in_timerkill+0x6c>
      {
         intimers[i].callback = NULL;
 323d060:	e0bffd17 	ldw	r2,-12(fp)
 323d064:	00c0c9b4 	movhi	r3,806
 323d068:	18f4ed04 	addi	r3,r3,-11340
 323d06c:	10800524 	muli	r2,r2,20
 323d070:	10c5883a 	add	r2,r2,r3
 323d074:	10000015 	stw	zero,0(r2)
         numtimers--;
 323d078:	d0a8f517 	ldw	r2,-23596(gp)
 323d07c:	10bfffc4 	addi	r2,r2,-1
 323d080:	d0a8f515 	stw	r2,-23596(gp)
         return 0;      /* OK return */
 323d084:	e03fff15 	stw	zero,-4(fp)
 323d088:	00000906 	br	323d0b0 <in_timerkill+0x90>
int
in_timerkill(long timer)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 323d08c:	e0bffd17 	ldw	r2,-12(fp)
 323d090:	10800044 	addi	r2,r2,1
 323d094:	e0bffd15 	stw	r2,-12(fp)
 323d098:	e0bffd17 	ldw	r2,-12(fp)
 323d09c:	10800150 	cmplti	r2,r2,5
 323d0a0:	103fe61e 	bne	r2,zero,323d03c <in_timerkill+0x1c>
         intimers[i].callback = NULL;
         numtimers--;
         return 0;      /* OK return */
      }
   }
   dtrap();    /* timer to kill not found */
 323d0a4:	322aef00 	call	322aef0 <dtrap>
   return ENP_PARAM;
 323d0a8:	00bffd84 	movi	r2,-10
 323d0ac:	e0bfff15 	stw	r2,-4(fp)
 323d0b0:	e0bfff17 	ldw	r2,-4(fp)
}
 323d0b4:	e037883a 	mov	sp,fp
 323d0b8:	dfc00117 	ldw	ra,4(sp)
 323d0bc:	df000017 	ldw	fp,0(sp)
 323d0c0:	dec00204 	addi	sp,sp,8
 323d0c4:	f800283a 	ret

0323d0c8 <create_apptasks>:
#endif
/* per-application thread definitions */

int
create_apptasks(void)
{
 323d0c8:	defffe04 	addi	sp,sp,-8
 323d0cc:	df000115 	stw	fp,4(sp)
 323d0d0:	df000104 	addi	fp,sp,4
int e = 0;
 323d0d4:	e03fff15 	stw	zero,-4(fp)
#endif
/* 
 * Altera Niche Stack Nios port modification:
 * return error code, if any 
 */
   return e;
 323d0d8:	e0bfff17 	ldw	r2,-4(fp)
}
 323d0dc:	e037883a 	mov	sp,fp
 323d0e0:	df000017 	ldw	fp,0(sp)
 323d0e4:	dec00104 	addi	sp,sp,4
 323d0e8:	f800283a 	ret

0323d0ec <task_stats>:
 */


void
task_stats(void * pio)
{
 323d0ec:	defffd04 	addi	sp,sp,-12
 323d0f0:	dfc00215 	stw	ra,8(sp)
 323d0f4:	df000115 	stw	fp,4(sp)
 323d0f8:	df000104 	addi	fp,sp,4
 323d0fc:	e13fff15 	stw	r4,-4(fp)
   ns_printf(pio, "Task wakeups:");
 323d100:	e13fff17 	ldw	r4,-4(fp)
 323d104:	0140c974 	movhi	r5,805
 323d108:	297efa04 	addi	r5,r5,-1048
 323d10c:	322637c0 	call	322637c <ns_printf>

#ifndef NO_INET_STACK
   ns_printf(pio, "netmain: %lu\n", netmain_wakes);
 323d110:	0080c974 	movhi	r2,805
 323d114:	10932304 	addi	r2,r2,19596
 323d118:	11800017 	ldw	r6,0(r2)
 323d11c:	e13fff17 	ldw	r4,-4(fp)
 323d120:	0140c974 	movhi	r5,805
 323d124:	297efe04 	addi	r5,r5,-1032
 323d128:	322637c0 	call	322637c <ns_printf>
#endif
#ifndef NO_INET_TICK
   ns_printf(pio, "nettick: %lu\n", nettick_wakes);
 323d12c:	0080c974 	movhi	r2,805
 323d130:	10932404 	addi	r2,r2,19600
 323d134:	11800017 	ldw	r6,0(r2)
 323d138:	e13fff17 	ldw	r4,-4(fp)
 323d13c:	0140c974 	movhi	r5,805
 323d140:	297f0204 	addi	r5,r5,-1016
 323d144:	322637c0 	call	322637c <ns_printf>
   ns_printf(pio, "browtask: %lu  ", browtask_wakes);
#endif
#ifdef INCLUDE_SSLAPP
   ns_printf(pio, "INCLUDE_SSLAPP: %lu  ", sslapp_wakes);
#endif
   ns_printf(pio, "\n");
 323d148:	e13fff17 	ldw	r4,-4(fp)
 323d14c:	0140c974 	movhi	r5,805
 323d150:	297f0604 	addi	r5,r5,-1000
 323d154:	322637c0 	call	322637c <ns_printf>
}
 323d158:	e037883a 	mov	sp,fp
 323d15c:	dfc00117 	ldw	ra,4(sp)
 323d160:	df000017 	ldw	fp,0(sp)
 323d164:	dec00204 	addi	sp,sp,8
 323d168:	f800283a 	ret

0323d16c <fcntl>:
 * (for files and device drivers) or calls the InterNiche bsd_ioctl for 
 * sockets.
 */
 
int fcntl (int file, int cmd, ...)
{
 323d16c:	defff704 	addi	sp,sp,-36
 323d170:	dfc00615 	stw	ra,24(sp)
 323d174:	df000515 	stw	fp,20(sp)
 323d178:	df000504 	addi	fp,sp,20
 323d17c:	e13ffd15 	stw	r4,-12(fp)
 323d180:	e1800215 	stw	r6,8(fp)
 323d184:	e1c00315 	stw	r7,12(fp)
 323d188:	e17ffe15 	stw	r5,-8(fp)
  long     flags;
  va_list  argp;

  if (file < ALT_MAX_FD)
 323d18c:	e0bffd17 	ldw	r2,-12(fp)
 323d190:	10800808 	cmpgei	r2,r2,32
 323d194:	10000e1e 	bne	r2,zero,323d1d0 <fcntl+0x64>
  {
    va_start(argp, cmd);
 323d198:	e0800204 	addi	r2,fp,8
 323d19c:	e0bffc15 	stw	r2,-16(fp)
    flags = va_arg(argp, long);
 323d1a0:	e0fffc17 	ldw	r3,-16(fp)
 323d1a4:	18800104 	addi	r2,r3,4
 323d1a8:	e0bffc15 	stw	r2,-16(fp)
 323d1ac:	1805883a 	mov	r2,r3
 323d1b0:	10800017 	ldw	r2,0(r2)
 323d1b4:	e0bffb15 	stw	r2,-20(fp)
    va_end(argp);
    return alt_fcntl(file, cmd, flags);
 323d1b8:	e13ffd17 	ldw	r4,-12(fp)
 323d1bc:	e17ffe17 	ldw	r5,-8(fp)
 323d1c0:	e1bffb17 	ldw	r6,-20(fp)
 323d1c4:	324a6c80 	call	324a6c8 <alt_fcntl>
 323d1c8:	e0bfff15 	stw	r2,-4(fp)
 323d1cc:	00000d06 	br	323d204 <fcntl+0x98>
  }
  else
  {
    va_start(argp, cmd);
 323d1d0:	e0800204 	addi	r2,fp,8
 323d1d4:	e0bffc15 	stw	r2,-16(fp)
    flags = va_arg(argp, long);
 323d1d8:	e0fffc17 	ldw	r3,-16(fp)
 323d1dc:	18800104 	addi	r2,r3,4
 323d1e0:	e0bffc15 	stw	r2,-16(fp)
 323d1e4:	1805883a 	mov	r2,r3
 323d1e8:	10800017 	ldw	r2,0(r2)
 323d1ec:	e0bffb15 	stw	r2,-20(fp)
    va_end(argp);
    return bsd_ioctl(file, cmd, flags);
 323d1f0:	e17ffe17 	ldw	r5,-8(fp)
 323d1f4:	e13ffd17 	ldw	r4,-12(fp)
 323d1f8:	e1bffb17 	ldw	r6,-20(fp)
 323d1fc:	32257c40 	call	32257c4 <bsd_ioctl>
 323d200:	e0bfff15 	stw	r2,-4(fp)
 323d204:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 323d208:	e037883a 	mov	sp,fp
 323d20c:	dfc00117 	ldw	ra,4(sp)
 323d210:	df000017 	ldw	fp,0(sp)
 323d214:	dec00404 	addi	sp,sp,16
 323d218:	f800283a 	ret

0323d21c <etainit>:
 * RETURNS: int               0 if OK, else nonzero
 */

int
etainit(void)
{
 323d21c:	defffd04 	addi	sp,sp,-12
 323d220:	dfc00215 	stw	ra,8(sp)
 323d224:	df000115 	stw	fp,4(sp)
 323d228:	df000104 	addi	fp,sp,4
   /* register ARP type with the Net Driver */
   if (reg_type(ET_ARP) != 0)
 323d22c:	01018204 	movi	r4,1544
 323d230:	323e8200 	call	323e820 <reg_type>
 323d234:	1005003a 	cmpeq	r2,r2,zero
 323d238:	1000061e 	bne	r2,zero,323d254 <etainit+0x38>
   {
#ifdef NPDEBUG
      dprintf("ARP: unable to register type with MAC Driver\n");
 323d23c:	0100c974 	movhi	r4,805
 323d240:	213f0704 	addi	r4,r4,-996
 323d244:	32071080 	call	3207108 <puts>
#endif
      return (1);
 323d248:	00800044 	movi	r2,1
 323d24c:	e0bfff15 	stw	r2,-4(fp)
 323d250:	00000106 	br	323d258 <etainit+0x3c>
   }
   return (0);
 323d254:	e03fff15 	stw	zero,-4(fp)
 323d258:	e0bfff17 	ldw	r2,-4(fp)
}
 323d25c:	e037883a 	mov	sp,fp
 323d260:	dfc00117 	ldw	ra,4(sp)
 323d264:	df000017 	ldw	fp,0(sp)
 323d268:	dec00204 	addi	sp,sp,8
 323d26c:	f800283a 	ret

0323d270 <et_send>:
 * and MIB info in the packet header. 
 */

int
et_send(PACKET pkt, struct arptabent *tp)
{
 323d270:	defff904 	addi	sp,sp,-28
 323d274:	dfc00615 	stw	ra,24(sp)
 323d278:	df000515 	stw	fp,20(sp)
 323d27c:	df000504 	addi	fp,sp,20
 323d280:	e13ffe15 	stw	r4,-8(fp)
 323d284:	e17fff15 	stw	r5,-4(fp)
   char *ethhdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 323d288:	e0bffe17 	ldw	r2,-8(fp)
 323d28c:	10800617 	ldw	r2,24(r2)
 323d290:	10802717 	ldw	r2,156(r2)
 323d294:	e0bffc15 	stw	r2,-16(fp)
   int err;

   tp->lasttime = cticks;
 323d298:	0080c974 	movhi	r2,805
 323d29c:	10934104 	addi	r2,r2,19716
 323d2a0:	10c00017 	ldw	r3,0(r2)
 323d2a4:	e0bfff17 	ldw	r2,-4(fp)
 323d2a8:	10c00615 	stw	r3,24(r2)
   pkt->nb_prot -= ETHHDR_SIZE;  /* prepare for prepending ethernet header */
 323d2ac:	e0bffe17 	ldw	r2,-8(fp)
 323d2b0:	10800317 	ldw	r2,12(r2)
 323d2b4:	10fffc04 	addi	r3,r2,-16
 323d2b8:	e0bffe17 	ldw	r2,-8(fp)
 323d2bc:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen += ETHHDR_SIZE;
 323d2c0:	e0bffe17 	ldw	r2,-8(fp)
 323d2c4:	10800417 	ldw	r2,16(r2)
 323d2c8:	10c00404 	addi	r3,r2,16
 323d2cc:	e0bffe17 	ldw	r2,-8(fp)
 323d2d0:	10c00415 	stw	r3,16(r2)
   ethhdr = pkt->nb_prot + ETHHDR_BIAS;
 323d2d4:	e0bffe17 	ldw	r2,-8(fp)
 323d2d8:	10800317 	ldw	r2,12(r2)
 323d2dc:	10800084 	addi	r2,r2,2
 323d2e0:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(snap, snapdata, 6);
      snap->type = ARPIP;
   }
#endif   /* IEEE_802_3 */

   if (ethhdr < pkt->nb_buff)   /* sanity check pointer */
 323d2e4:	e0bffe17 	ldw	r2,-8(fp)
 323d2e8:	10c00117 	ldw	r3,4(r2)
 323d2ec:	e0bffd17 	ldw	r2,-12(fp)
 323d2f0:	10c0032e 	bgeu	r2,r3,323d300 <et_send+0x90>
      panic("et_send: prepend");
 323d2f4:	0100c974 	movhi	r4,805
 323d2f8:	213f1304 	addi	r4,r4,-948
 323d2fc:	32261540 	call	3226154 <panic>

   MEMMOVE(ethhdr + ET_DSTOFF, tp->t_phy_addr, 6);  /* set pkt's MAC dst addr */
 323d300:	e0bfff17 	ldw	r2,-4(fp)
 323d304:	11400104 	addi	r5,r2,4
 323d308:	e13ffd17 	ldw	r4,-12(fp)
 323d30c:	01800184 	movi	r6,6
 323d310:	3206b700 	call	3206b70 <memmove>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);  /* MAC src */
 323d314:	e0bffd17 	ldw	r2,-12(fp)
 323d318:	11000184 	addi	r4,r2,6
 323d31c:	e0bffc17 	ldw	r2,-16(fp)
 323d320:	11400517 	ldw	r5,20(r2)
 323d324:	01800184 	movi	r6,6
 323d328:	3206b700 	call	3206b70 <memmove>

   /* nice clean ethernet II header */
   if ((tp->flags & (ET_ETH2|ET_SNAP)) != ET_SNAP)
 323d32c:	e0bfff17 	ldw	r2,-4(fp)
 323d330:	1080070b 	ldhu	r2,28(r2)
 323d334:	10bfffcc 	andi	r2,r2,65535
 323d338:	108000cc 	andi	r2,r2,3
 323d33c:	108000a0 	cmpeqi	r2,r2,2
 323d340:	1000041e 	bne	r2,zero,323d354 <et_send+0xe4>
      ET_TYPE_SET(ethhdr, ntohs(ARPIP));
 323d344:	e0bffd17 	ldw	r2,-12(fp)
 323d348:	10c00304 	addi	r3,r2,12
 323d34c:	00800204 	movi	r2,8
 323d350:	18800005 	stb	r2,0(r3)
 323d354:	e0bffd17 	ldw	r2,-12(fp)
 323d358:	10800344 	addi	r2,r2,13
 323d35c:	10000005 	stb	zero,0(r2)
      ET_TYPE_SET(ethhdr, len8023);
   }
#endif   /* IEEE_802_3 */

   /* if a packet oriented send exists, use it: */
   if (pkt->net->pkt_send)
 323d360:	e0bffe17 	ldw	r2,-8(fp)
 323d364:	10800617 	ldw	r2,24(r2)
 323d368:	10800417 	ldw	r2,16(r2)
 323d36c:	1005003a 	cmpeq	r2,r2,zero
 323d370:	1000071e 	bne	r2,zero,323d390 <et_send+0x120>
      err = pkt->net->pkt_send(pkt);   /* send packet to media */
 323d374:	e0bffe17 	ldw	r2,-8(fp)
 323d378:	10800617 	ldw	r2,24(r2)
 323d37c:	10800417 	ldw	r2,16(r2)
 323d380:	e13ffe17 	ldw	r4,-8(fp)
 323d384:	103ee83a 	callr	r2
 323d388:	e0bffb15 	stw	r2,-20(fp)
 323d38c:	00001106 	br	323d3d4 <et_send+0x164>
   else  /* else use older raw_send routine */
   {
      /* sent to media */
      err = pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 323d390:	e0bffe17 	ldw	r2,-8(fp)
 323d394:	10800617 	ldw	r2,24(r2)
 323d398:	10c00317 	ldw	r3,12(r2)
 323d39c:	e0bffe17 	ldw	r2,-8(fp)
 323d3a0:	11000617 	ldw	r4,24(r2)
 323d3a4:	e0bffe17 	ldw	r2,-8(fp)
 323d3a8:	11400317 	ldw	r5,12(r2)
 323d3ac:	e0bffe17 	ldw	r2,-8(fp)
 323d3b0:	11800417 	ldw	r6,16(r2)
 323d3b4:	183ee83a 	callr	r3
 323d3b8:	e0bffb15 	stw	r2,-20(fp)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 323d3bc:	01000084 	movi	r4,2
 323d3c0:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 323d3c4:	e13ffe17 	ldw	r4,-8(fp)
 323d3c8:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323d3cc:	01000084 	movi	r4,2
 323d3d0:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   }

   return (err);
 323d3d4:	e0bffb17 	ldw	r2,-20(fp)
}
 323d3d8:	e037883a 	mov	sp,fp
 323d3dc:	dfc00117 	ldw	ra,4(sp)
 323d3e0:	df000017 	ldw	fp,0(sp)
 323d3e4:	dec00204 	addi	sp,sp,8
 323d3e8:	f800283a 	ret

0323d3ec <arp_free_pending>:
 * and mark the entry "unused".
 */

void
arp_free_pending(struct arptabent *entry)
{
 323d3ec:	defffb04 	addi	sp,sp,-20
 323d3f0:	dfc00415 	stw	ra,16(sp)
 323d3f4:	df000315 	stw	fp,12(sp)
 323d3f8:	df000304 	addi	fp,sp,12
 323d3fc:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt;
   PACKET nextpkt;

   /* entry->pending has the linked list of all pending packets */
   tmppkt = entry->pending;
 323d400:	e0bfff17 	ldw	r2,-4(fp)
 323d404:	10800417 	ldw	r2,16(r2)
 323d408:	e0bffe15 	stw	r2,-8(fp)
   entry->pending = (PACKET)NULL;
 323d40c:	e0bfff17 	ldw	r2,-4(fp)
 323d410:	10000415 	stw	zero,16(r2)

   LOCK_NET_RESOURCE(FREEQ_RESID);
 323d414:	01000084 	movi	r4,2
 323d418:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>

   /* free all pending packets */
   while (tmppkt)
 323d41c:	00000906 	br	323d444 <arp_free_pending+0x58>
   {
      nextpkt = tmppkt->next;        /* save the next packet in list */
 323d420:	e0bffe17 	ldw	r2,-8(fp)
 323d424:	10800017 	ldw	r2,0(r2)
 323d428:	e0bffd15 	stw	r2,-12(fp)
      tmppkt->next = (PACKET)NULL;
 323d42c:	e0bffe17 	ldw	r2,-8(fp)
 323d430:	10000015 	stw	zero,0(r2)
      pk_free(tmppkt);               /* free current packet */
 323d434:	e13ffe17 	ldw	r4,-8(fp)
 323d438:	322a6400 	call	322a640 <pk_free>
      tmppkt = nextpkt;              /* process the next packet */
 323d43c:	e0bffd17 	ldw	r2,-12(fp)
 323d440:	e0bffe15 	stw	r2,-8(fp)
   entry->pending = (PACKET)NULL;

   LOCK_NET_RESOURCE(FREEQ_RESID);

   /* free all pending packets */
   while (tmppkt)
 323d444:	e0bffe17 	ldw	r2,-8(fp)
 323d448:	1004c03a 	cmpne	r2,r2,zero
 323d44c:	103ff41e 	bne	r2,zero,323d420 <arp_free_pending+0x34>
      tmppkt->next = (PACKET)NULL;
      pk_free(tmppkt);               /* free current packet */
      tmppkt = nextpkt;              /* process the next packet */
   }

   entry->t_pro_addr = 0;     /* mark the entry "unused" */
 323d450:	e0bfff17 	ldw	r2,-4(fp)
 323d454:	10000015 	stw	zero,0(r2)

   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323d458:	01000084 	movi	r4,2
 323d45c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
}
 323d460:	e037883a 	mov	sp,fp
 323d464:	dfc00117 	ldw	ra,4(sp)
 323d468:	df000017 	ldw	fp,0(sp)
 323d46c:	dec00204 	addi	sp,sp,8
 323d470:	f800283a 	ret

0323d474 <arp_send_pending>:
 * Clear the list (entry->pending) after sending the packets.
 */

void
arp_send_pending(struct arptabent *entry)
{
 323d474:	defffc04 	addi	sp,sp,-16
 323d478:	dfc00315 	stw	ra,12(sp)
 323d47c:	df000215 	stw	fp,8(sp)
 323d480:	df000204 	addi	fp,sp,8
 323d484:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt = entry->pending;
 323d488:	e0bfff17 	ldw	r2,-4(fp)
 323d48c:	10800417 	ldw	r2,16(r2)
 323d490:	e0bffe15 	stw	r2,-8(fp)

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 323d494:	00000906 	br	323d4bc <arp_send_pending+0x48>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
 323d498:	e0bffe17 	ldw	r2,-8(fp)
 323d49c:	10c00017 	ldw	r3,0(r2)
 323d4a0:	e0bfff17 	ldw	r2,-4(fp)
 323d4a4:	10c00415 	stw	r3,16(r2)
      tmppkt->next = (PACKET)NULL;
 323d4a8:	e0bffe17 	ldw	r2,-8(fp)
 323d4ac:	10000015 	stw	zero,0(r2)
      et_send(tmppkt, entry);          /* try send again */
 323d4b0:	e13ffe17 	ldw	r4,-8(fp)
 323d4b4:	e17fff17 	ldw	r5,-4(fp)
 323d4b8:	323d2700 	call	323d270 <et_send>
   PACKET tmppkt = entry->pending;

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 323d4bc:	e0bfff17 	ldw	r2,-4(fp)
 323d4c0:	10800417 	ldw	r2,16(r2)
 323d4c4:	e0bffe15 	stw	r2,-8(fp)
 323d4c8:	e0bffe17 	ldw	r2,-8(fp)
 323d4cc:	1004c03a 	cmpne	r2,r2,zero
 323d4d0:	103ff11e 	bne	r2,zero,323d498 <arp_send_pending+0x24>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
      tmppkt->next = (PACKET)NULL;
      et_send(tmppkt, entry);          /* try send again */
   }
}
 323d4d4:	e037883a 	mov	sp,fp
 323d4d8:	dfc00117 	ldw	ra,4(sp)
 323d4dc:	df000017 	ldw	fp,0(sp)
 323d4e0:	dec00204 	addi	sp,sp,8
 323d4e4:	f800283a 	ret

0323d4e8 <send_arp>:
 * timeout will eventually free packet. 
 */

int
send_arp(PACKET pkt, ip_addr dest_ip)
{
 323d4e8:	defff304 	addi	sp,sp,-52
 323d4ec:	dfc00c15 	stw	ra,48(sp)
 323d4f0:	df000b15 	stw	fp,44(sp)
 323d4f4:	df000b04 	addi	fp,sp,44
 323d4f8:	e13ffd15 	stw	r4,-12(fp)
 323d4fc:	e17ffe15 	stw	r5,-8(fp)
   struct arptabent *   oldest;
   char * ethhdr;
   NET net = pkt->net;
 323d500:	e0bffd17 	ldw	r2,-12(fp)
 323d504:	10800617 	ldw	r2,24(r2)
 323d508:	e0bff915 	stw	r2,-28(fp)
   struct arp_hdr *  arphdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 323d50c:	e0bffd17 	ldw	r2,-12(fp)
 323d510:	10800617 	ldw	r2,24(r2)
 323d514:	10802717 	ldw	r2,156(r2)
 323d518:	e0bff715 	stw	r2,-36(fp)
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 323d51c:	e0bffe17 	ldw	r2,-8(fp)
 323d520:	10bfffe0 	cmpeqi	r2,r2,-1
 323d524:	10001b1e 	bne	r2,zero,323d594 <send_arp+0xac>
 323d528:	e0bff917 	ldw	r2,-28(fp)
 323d52c:	10800c17 	ldw	r2,48(r2)
 323d530:	0086303a 	nor	r3,zero,r2
 323d534:	e0bffe17 	ldw	r2,-8(fp)
 323d538:	1886703a 	and	r3,r3,r2
 323d53c:	e0bff917 	ldw	r2,-28(fp)
 323d540:	10800c17 	ldw	r2,48(r2)
 323d544:	0084303a 	nor	r2,zero,r2
 323d548:	18801226 	beq	r3,r2,323d594 <send_arp+0xac>
 323d54c:	e0bffe17 	ldw	r2,-8(fp)
 323d550:	1004d63a 	srli	r2,r2,24
 323d554:	10c03fcc 	andi	r3,r2,255
 323d558:	e0bffe17 	ldw	r2,-8(fp)
 323d55c:	1004d23a 	srli	r2,r2,8
 323d560:	10bfc00c 	andi	r2,r2,65280
 323d564:	1886b03a 	or	r3,r3,r2
 323d568:	e0bffe17 	ldw	r2,-8(fp)
 323d56c:	10bfc00c 	andi	r2,r2,65280
 323d570:	1004923a 	slli	r2,r2,8
 323d574:	1886b03a 	or	r3,r3,r2
 323d578:	e0bffe17 	ldw	r2,-8(fp)
 323d57c:	10803fcc 	andi	r2,r2,255
 323d580:	1004963a 	slli	r2,r2,24
 323d584:	1884b03a 	or	r2,r3,r2
 323d588:	10fc002c 	andhi	r3,r2,61440
 323d58c:	00b80034 	movhi	r2,57344
 323d590:	1880441e 	bne	r3,r2,323d6a4 <send_arp+0x1bc>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask))))

#endif /* IP_MULTICAST */
   {
      /* get unused or oldest entry in table */
      oldest = make_arp_entry(dest_ip, pkt->net);
 323d594:	e0bffd17 	ldw	r2,-12(fp)
 323d598:	11400617 	ldw	r5,24(r2)
 323d59c:	e13ffe17 	ldw	r4,-8(fp)
 323d5a0:	323db280 	call	323db28 <make_arp_entry>
 323d5a4:	e0bffb15 	stw	r2,-20(fp)

      /* set MAC destination to ethernet broadcast (all FFs) */
      MEMSET(oldest->t_phy_addr, 0xFF, 6);
 323d5a8:	e0bffb17 	ldw	r2,-20(fp)
 323d5ac:	10c00104 	addi	r3,r2,4
 323d5b0:	00bfffc4 	movi	r2,-1
 323d5b4:	18800005 	stb	r2,0(r3)
 323d5b8:	00bfffc4 	movi	r2,-1
 323d5bc:	18800045 	stb	r2,1(r3)
 323d5c0:	00bfffc4 	movi	r2,-1
 323d5c4:	18800085 	stb	r2,2(r3)
 323d5c8:	00bfffc4 	movi	r2,-1
 323d5cc:	188000c5 	stb	r2,3(r3)
 323d5d0:	00bfffc4 	movi	r2,-1
 323d5d4:	18800105 	stb	r2,4(r3)
 323d5d8:	00bfffc4 	movi	r2,-1
 323d5dc:	18800145 	stb	r2,5(r3)
#ifdef IP_MULTICAST
      /* If n_mcastlist routine is defined in the net structure,
         map IP mcast to Ether multicast  */

#ifdef ETHMCAST
      if ((pkt->net->n_mcastlist) && (IN_MULTICAST(ntohl(dest_ip))))
 323d5e0:	e0bffd17 	ldw	r2,-12(fp)
 323d5e4:	10800617 	ldw	r2,24(r2)
 323d5e8:	10802b17 	ldw	r2,172(r2)
 323d5ec:	1005003a 	cmpeq	r2,r2,zero
 323d5f0:	1000271e 	bne	r2,zero,323d690 <send_arp+0x1a8>
 323d5f4:	e0bffe17 	ldw	r2,-8(fp)
 323d5f8:	1004d63a 	srli	r2,r2,24
 323d5fc:	10c03fcc 	andi	r3,r2,255
 323d600:	e0bffe17 	ldw	r2,-8(fp)
 323d604:	1004d23a 	srli	r2,r2,8
 323d608:	10bfc00c 	andi	r2,r2,65280
 323d60c:	1886b03a 	or	r3,r3,r2
 323d610:	e0bffe17 	ldw	r2,-8(fp)
 323d614:	10bfc00c 	andi	r2,r2,65280
 323d618:	1004923a 	slli	r2,r2,8
 323d61c:	1886b03a 	or	r3,r3,r2
 323d620:	e0bffe17 	ldw	r2,-8(fp)
 323d624:	10803fcc 	andi	r2,r2,255
 323d628:	1004963a 	slli	r2,r2,24
 323d62c:	1884b03a 	or	r2,r3,r2
 323d630:	10fc002c 	andhi	r3,r2,61440
 323d634:	00b80034 	movhi	r2,57344
 323d638:	1880151e 	bne	r3,r2,323d690 <send_arp+0x1a8>
      {
         /* If IP mcast to be mapped to Ethernet multicast */
         dest_ip_ptr.l = dest_ip;
 323d63c:	e0bffe17 	ldw	r2,-8(fp)
 323d640:	e0bffc15 	stw	r2,-16(fp)
         oldest->t_phy_addr[0] = 0x01;
 323d644:	e0fffb17 	ldw	r3,-20(fp)
 323d648:	00800044 	movi	r2,1
 323d64c:	18800105 	stb	r2,4(r3)
         oldest->t_phy_addr[1] = 0x00;
 323d650:	e0bffb17 	ldw	r2,-20(fp)
 323d654:	10000145 	stb	zero,5(r2)
         oldest->t_phy_addr[2] = 0x5e;
 323d658:	e0fffb17 	ldw	r3,-20(fp)
 323d65c:	00801784 	movi	r2,94
 323d660:	18800185 	stb	r2,6(r3)
         oldest->t_phy_addr[3] = (u_char )(dest_ip_ptr.c[1] & 0x7f);
 323d664:	e0bffc43 	ldbu	r2,-15(fp)
 323d668:	10801fcc 	andi	r2,r2,127
 323d66c:	1007883a 	mov	r3,r2
 323d670:	e0bffb17 	ldw	r2,-20(fp)
 323d674:	10c001c5 	stb	r3,7(r2)
         oldest->t_phy_addr[4] = (u_char )dest_ip_ptr.c[2];
 323d678:	e0fffc83 	ldbu	r3,-14(fp)
 323d67c:	e0bffb17 	ldw	r2,-20(fp)
 323d680:	10c00205 	stb	r3,8(r2)
         oldest->t_phy_addr[5] = (u_char )dest_ip_ptr.c[3];
 323d684:	e0fffcc3 	ldbu	r3,-13(fp)
 323d688:	e0bffb17 	ldw	r2,-20(fp)
 323d68c:	10c00245 	stb	r3,9(r2)
      }
#endif /* ETHMCAST */
#endif /* IP_MULTICAST */
      return (et_send(pkt, oldest));
 323d690:	e13ffd17 	ldw	r4,-12(fp)
 323d694:	e17ffb17 	ldw	r5,-20(fp)
 323d698:	323d2700 	call	323d270 <et_send>
 323d69c:	e0bfff15 	stw	r2,-4(fp)
 323d6a0:	0000b106 	br	323d968 <send_arp+0x480>

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 323d6a4:	e0bffd17 	ldw	r2,-12(fp)
 323d6a8:	10c00717 	ldw	r3,28(r2)
 323d6ac:	e0bffd17 	ldw	r2,-12(fp)
 323d6b0:	10800617 	ldw	r2,24(r2)
 323d6b4:	10800a17 	ldw	r2,40(r2)
 323d6b8:	18800e1e 	bne	r3,r2,323d6f4 <send_arp+0x20c>
 323d6bc:	e0bffd17 	ldw	r2,-12(fp)
 323d6c0:	10800717 	ldw	r2,28(r2)
 323d6c4:	10803fcc 	andi	r2,r2,255
 323d6c8:	10801fe0 	cmpeqi	r2,r2,127
 323d6cc:	1000091e 	bne	r2,zero,323d6f4 <send_arp+0x20c>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 323d6d0:	01000084 	movi	r4,2
 323d6d4:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 323d6d8:	e13ffd17 	ldw	r4,-12(fp)
 323d6dc:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323d6e0:	01000084 	movi	r4,2
 323d6e4:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return ENP_NO_ROUTE;
 323d6e8:	00bff7c4 	movi	r2,-33
 323d6ec:	e0bfff15 	stw	r2,-4(fp)
 323d6f0:	00009d06 	br	323d968 <send_arp+0x480>
   }

   /* not broadcasting, so get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 323d6f4:	01000084 	movi	r4,2
 323d6f8:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 323d6fc:	01000c04 	movi	r4,48
 323d700:	322a2ac0 	call	322a2ac <pk_alloc>
 323d704:	e0bff615 	stw	r2,-40(fp)
   if (!arppkt)
 323d708:	e0bff617 	ldw	r2,-40(fp)
 323d70c:	1004c03a 	cmpne	r2,r2,zero
 323d710:	1000071e 	bne	r2,zero,323d730 <send_arp+0x248>
   {
      pk_free(pkt);
 323d714:	e13ffd17 	ldw	r4,-12(fp)
 323d718:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323d71c:	01000084 	movi	r4,2
 323d720:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 323d724:	00bffa84 	movi	r2,-22
 323d728:	e0bfff15 	stw	r2,-4(fp)
 323d72c:	00008e06 	br	323d968 <send_arp+0x480>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323d730:	01000084 	movi	r4,2
 323d734:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 323d738:	e0bff617 	ldw	r2,-40(fp)
 323d73c:	10c00117 	ldw	r3,4(r2)
 323d740:	e0bff617 	ldw	r2,-40(fp)
 323d744:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 323d748:	e0fff617 	ldw	r3,-40(fp)
 323d74c:	00800c04 	movi	r2,48
 323d750:	18800415 	stw	r2,16(r3)
   arppkt->net = pkt->net;
 323d754:	e0bffd17 	ldw	r2,-12(fp)
 323d758:	10c00617 	ldw	r3,24(r2)
 323d75c:	e0bff617 	ldw	r2,-40(fp)
 323d760:	10c00615 	stw	r3,24(r2)

   /* get unused or oldest entry in table */
   oldest = make_arp_entry(dest_ip, pkt->net);
 323d764:	e0bffd17 	ldw	r2,-12(fp)
 323d768:	11400617 	ldw	r5,24(r2)
 323d76c:	e13ffe17 	ldw	r4,-8(fp)
 323d770:	323db280 	call	323db28 <make_arp_entry>
 323d774:	e0bffb15 	stw	r2,-20(fp)

   oldest->pending = pkt;           /* packet is "pended", not pk_free()d */
 323d778:	e0fffb17 	ldw	r3,-20(fp)
 323d77c:	e0bffd17 	ldw	r2,-12(fp)
 323d780:	18800415 	stw	r2,16(r3)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 323d784:	e0bff617 	ldw	r2,-40(fp)
 323d788:	10800117 	ldw	r2,4(r2)
 323d78c:	10800084 	addi	r2,r2,2
 323d790:	e0bffa15 	stw	r2,-24(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 323d794:	e0bff617 	ldw	r2,-40(fp)
 323d798:	10800117 	ldw	r2,4(r2)
 323d79c:	10800404 	addi	r2,r2,16
 323d7a0:	e0bff815 	stw	r2,-32(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 323d7a4:	e0fff817 	ldw	r3,-32(fp)
 323d7a8:	00804004 	movi	r2,256
 323d7ac:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 323d7b0:	e0fff817 	ldw	r3,-32(fp)
 323d7b4:	00800204 	movi	r2,8
 323d7b8:	1880008d 	sth	r2,2(r3)
   arphdr->ar_hln = 6;
 323d7bc:	e0fff817 	ldw	r3,-32(fp)
 323d7c0:	00800184 	movi	r2,6
 323d7c4:	18800105 	stb	r2,4(r3)
   arphdr->ar_pln = 4;
 323d7c8:	e0fff817 	ldw	r3,-32(fp)
 323d7cc:	00800104 	movi	r2,4
 323d7d0:	18800145 	stb	r2,5(r3)
   arphdr->ar_op = ARREQ;
 323d7d4:	e0fff817 	ldw	r3,-32(fp)
 323d7d8:	00804004 	movi	r2,256
 323d7dc:	1880018d 	sth	r2,6(r3)
   arphdr->ar_tpa = dest_ip;        /* target's IP address */
 323d7e0:	e0fff817 	ldw	r3,-32(fp)
 323d7e4:	e0bffe17 	ldw	r2,-8(fp)
 323d7e8:	18800715 	stw	r2,28(r3)
   arphdr->ar_spa = pkt->net->n_ipaddr;   /* my IP address */
 323d7ec:	e0bffd17 	ldw	r2,-12(fp)
 323d7f0:	10800617 	ldw	r2,24(r2)
 323d7f4:	10c00a17 	ldw	r3,40(r2)
 323d7f8:	e0bff817 	ldw	r2,-32(fp)
 323d7fc:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 323d800:	e0bff817 	ldw	r2,-32(fp)
 323d804:	11000204 	addi	r4,r2,8
 323d808:	e0bff717 	ldw	r2,-36(fp)
 323d80c:	11400517 	ldw	r5,20(r2)
 323d810:	01800184 	movi	r6,6
 323d814:	3206b700 	call	3206b70 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 323d818:	e0fffa17 	ldw	r3,-24(fp)
 323d81c:	00bfffc4 	movi	r2,-1
 323d820:	18800005 	stb	r2,0(r3)
 323d824:	00bfffc4 	movi	r2,-1
 323d828:	18800045 	stb	r2,1(r3)
 323d82c:	00bfffc4 	movi	r2,-1
 323d830:	18800085 	stb	r2,2(r3)
 323d834:	00bfffc4 	movi	r2,-1
 323d838:	188000c5 	stb	r2,3(r3)
 323d83c:	00bfffc4 	movi	r2,-1
 323d840:	18800105 	stb	r2,4(r3)
 323d844:	00bfffc4 	movi	r2,-1
 323d848:	18800145 	stb	r2,5(r3)
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 323d84c:	e0bffa17 	ldw	r2,-24(fp)
 323d850:	11000184 	addi	r4,r2,6
 323d854:	e0bff717 	ldw	r2,-36(fp)
 323d858:	11400517 	ldw	r5,20(r2)
 323d85c:	01800184 	movi	r6,6
 323d860:	3206b700 	call	3206b70 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 323d864:	e0bffa17 	ldw	r2,-24(fp)
 323d868:	10c00304 	addi	r3,r2,12
 323d86c:	00800204 	movi	r2,8
 323d870:	18800005 	stb	r2,0(r3)
 323d874:	e0bffa17 	ldw	r2,-24(fp)
 323d878:	10c00344 	addi	r3,r2,13
 323d87c:	00800184 	movi	r2,6
 323d880:	18800005 	stb	r2,0(r3)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 323d884:	e0bff817 	ldw	r2,-32(fp)
 323d888:	e0bff515 	stw	r2,-44(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 323d88c:	e0bff517 	ldw	r2,-44(fp)
 323d890:	11000204 	addi	r4,r2,8
 323d894:	e0bff817 	ldw	r2,-32(fp)
 323d898:	11400204 	addi	r5,r2,8
 323d89c:	01800184 	movi	r6,6
 323d8a0:	3206b700 	call	3206b70 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 323d8a4:	e0bff517 	ldw	r2,-44(fp)
 323d8a8:	10800204 	addi	r2,r2,8
 323d8ac:	11000184 	addi	r4,r2,6
 323d8b0:	e0bff817 	ldw	r2,-32(fp)
 323d8b4:	11400404 	addi	r5,r2,16
 323d8b8:	01800104 	movi	r6,4
 323d8bc:	3206b700 	call	3206b70 <memmove>
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 323d8c0:	e0bff517 	ldw	r2,-44(fp)
 323d8c4:	10800204 	addi	r2,r2,8
 323d8c8:	11000284 	addi	r4,r2,10
 323d8cc:	e0bff817 	ldw	r2,-32(fp)
 323d8d0:	11400504 	addi	r5,r2,20
 323d8d4:	01800184 	movi	r6,6
 323d8d8:	3206b700 	call	3206b70 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 323d8dc:	e0bff517 	ldw	r2,-44(fp)
 323d8e0:	10800204 	addi	r2,r2,8
 323d8e4:	11000404 	addi	r4,r2,16
 323d8e8:	e0bff817 	ldw	r2,-32(fp)
 323d8ec:	11400704 	addi	r5,r2,28
 323d8f0:	01800104 	movi	r6,4
 323d8f4:	3206b700 	call	3206b70 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 323d8f8:	e0bff917 	ldw	r2,-28(fp)
 323d8fc:	10800417 	ldw	r2,16(r2)
 323d900:	1005003a 	cmpeq	r2,r2,zero
 323d904:	1000051e 	bne	r2,zero,323d91c <send_arp+0x434>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 323d908:	e0bff917 	ldw	r2,-28(fp)
 323d90c:	10800417 	ldw	r2,16(r2)
 323d910:	e13ff617 	ldw	r4,-40(fp)
 323d914:	103ee83a 	callr	r2
 323d918:	00000e06 	br	323d954 <send_arp+0x46c>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 323d91c:	e0bff917 	ldw	r2,-28(fp)
 323d920:	10c00317 	ldw	r3,12(r2)
 323d924:	e0bff617 	ldw	r2,-40(fp)
 323d928:	11000617 	ldw	r4,24(r2)
 323d92c:	e0bff617 	ldw	r2,-40(fp)
 323d930:	11400117 	ldw	r5,4(r2)
 323d934:	01800c04 	movi	r6,48
 323d938:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 323d93c:	01000084 	movi	r4,2
 323d940:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 323d944:	e13ff617 	ldw	r4,-40(fp)
 323d948:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323d94c:	01000084 	movi	r4,2
 323d950:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 323d954:	d0a8f917 	ldw	r2,-23580(gp)
 323d958:	10800044 	addi	r2,r2,1
 323d95c:	d0a8f915 	stw	r2,-23580(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 323d960:	00800044 	movi	r2,1
 323d964:	e0bfff15 	stw	r2,-4(fp)
 323d968:	e0bfff17 	ldw	r2,-4(fp)
}
 323d96c:	e037883a 	mov	sp,fp
 323d970:	dfc00117 	ldw	ra,4(sp)
 323d974:	df000017 	ldw	fp,0(sp)
 323d978:	dec00204 	addi	sp,sp,8
 323d97c:	f800283a 	ret

0323d980 <find_oldest_arp>:
 * Old entries are removed from the table.
 */

struct arptabent * 
find_oldest_arp(ip_addr dest_ip)
{
 323d980:	defff604 	addi	sp,sp,-40
 323d984:	dfc00915 	stw	ra,36(sp)
 323d988:	df000815 	stw	fp,32(sp)
 323d98c:	df000804 	addi	fp,sp,32
 323d990:	e13ffd15 	stw	r4,-12(fp)
   struct arptabent *tp;
   struct arptabent *exact  = (struct arptabent *)NULL;
 323d994:	e03ffb15 	stw	zero,-20(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
 323d998:	e03ffa15 	stw	zero,-24(fp)
   struct arptabent *empty  = (struct arptabent *)NULL;
 323d99c:	e03ff915 	stw	zero,-28(fp)
   unsigned long lticks = cticks;
 323d9a0:	0080c974 	movhi	r2,805
 323d9a4:	10934104 	addi	r2,r2,19716
 323d9a8:	10800017 	ldw	r2,0(r2)
 323d9ac:	e0bff815 	stw	r2,-32(fp)

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 323d9b0:	0080c9b4 	movhi	r2,806
 323d9b4:	10b50604 	addi	r2,r2,-11240
 323d9b8:	e0bffc15 	stw	r2,-16(fp)
 323d9bc:	00004006 	br	323dac0 <find_oldest_arp+0x140>
   {
      /* age out old, pending entries */
      if (tp->pending)
 323d9c0:	e0bffc17 	ldw	r2,-16(fp)
 323d9c4:	10800417 	ldw	r2,16(r2)
 323d9c8:	1005003a 	cmpeq	r2,r2,zero
 323d9cc:	10000b1e 	bne	r2,zero,323d9fc <find_oldest_arp+0x7c>
      {
         /* purge if pending for more than one second */
         if ((lticks - tp->createtime) > TPS)
 323d9d0:	e0bffc17 	ldw	r2,-16(fp)
 323d9d4:	10c00517 	ldw	r3,20(r2)
 323d9d8:	e0bff817 	ldw	r2,-32(fp)
 323d9dc:	10c5c83a 	sub	r2,r2,r3
 323d9e0:	1080fa70 	cmpltui	r2,r2,1001
 323d9e4:	1000181e 	bne	r2,zero,323da48 <find_oldest_arp+0xc8>
         {
            arp_free_pending(tp);   /* free pending packets */
 323d9e8:	e13ffc17 	ldw	r4,-16(fp)
 323d9ec:	323d3ec0 	call	323d3ec <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 323d9f0:	e0bffc17 	ldw	r2,-16(fp)
 323d9f4:	10000015 	stw	zero,0(r2)
 323d9f8:	00001306 	br	323da48 <find_oldest_arp+0xc8>
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 323d9fc:	e0bffc17 	ldw	r2,-16(fp)
 323da00:	10800017 	ldw	r2,0(r2)
 323da04:	1005003a 	cmpeq	r2,r2,zero
 323da08:	10000f1e 	bne	r2,zero,323da48 <find_oldest_arp+0xc8>
 323da0c:	e0bffc17 	ldw	r2,-16(fp)
 323da10:	10c00517 	ldw	r3,20(r2)
 323da14:	e0bff817 	ldw	r2,-32(fp)
 323da18:	10c5c83a 	sub	r2,r2,r3
 323da1c:	1007883a 	mov	r3,r2
 323da20:	d0a04b17 	ldw	r2,-32468(gp)
 323da24:	18800816 	blt	r3,r2,323da48 <find_oldest_arp+0xc8>
 323da28:	e0bffc17 	ldw	r2,-16(fp)
 323da2c:	10c00617 	ldw	r3,24(r2)
 323da30:	e0bff817 	ldw	r2,-32(fp)
 323da34:	10c5c83a 	sub	r2,r2,r3
 323da38:	1080fa30 	cmpltui	r2,r2,1000
 323da3c:	1000021e 	bne	r2,zero,323da48 <find_oldest_arp+0xc8>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
               ((int)(lticks - tp->lasttime)   >= TPS))
      {
         /* entry has "expired" and has not been reference in 1 sec. */
         tp->t_pro_addr = 0;     /* mark entry as "unused" */
 323da40:	e0bffc17 	ldw	r2,-16(fp)
 323da44:	10000015 	stw	zero,0(r2)
      }

      if (tp->t_pro_addr == dest_ip)   /* ip addr already has entry */
 323da48:	e0bffc17 	ldw	r2,-16(fp)
 323da4c:	10c00017 	ldw	r3,0(r2)
 323da50:	e0bffd17 	ldw	r2,-12(fp)
 323da54:	1880031e 	bne	r3,r2,323da64 <find_oldest_arp+0xe4>
      {
         exact = tp;
 323da58:	e0bffc17 	ldw	r2,-16(fp)
 323da5c:	e0bffb15 	stw	r2,-20(fp)
 323da60:	00001406 	br	323dab4 <find_oldest_arp+0x134>
      }
      else if (tp->t_pro_addr != 0)
 323da64:	e0bffc17 	ldw	r2,-16(fp)
 323da68:	10800017 	ldw	r2,0(r2)
 323da6c:	1005003a 	cmpeq	r2,r2,zero
 323da70:	10000b1e 	bne	r2,zero,323daa0 <find_oldest_arp+0x120>
      {
         if (!oldest || (tp->lasttime < oldest->lasttime))
 323da74:	e0bffa17 	ldw	r2,-24(fp)
 323da78:	1005003a 	cmpeq	r2,r2,zero
 323da7c:	1000051e 	bne	r2,zero,323da94 <find_oldest_arp+0x114>
 323da80:	e0bffc17 	ldw	r2,-16(fp)
 323da84:	10c00617 	ldw	r3,24(r2)
 323da88:	e0bffa17 	ldw	r2,-24(fp)
 323da8c:	10800617 	ldw	r2,24(r2)
 323da90:	1880082e 	bgeu	r3,r2,323dab4 <find_oldest_arp+0x134>
            oldest = tp;
 323da94:	e0bffc17 	ldw	r2,-16(fp)
 323da98:	e0bffa15 	stw	r2,-24(fp)
 323da9c:	00000506 	br	323dab4 <find_oldest_arp+0x134>
      }
      else if (!empty)
 323daa0:	e0bff917 	ldw	r2,-28(fp)
 323daa4:	1004c03a 	cmpne	r2,r2,zero
 323daa8:	1000021e 	bne	r2,zero,323dab4 <find_oldest_arp+0x134>
         empty = tp;          /* grab first empty slot */
 323daac:	e0bffc17 	ldw	r2,-16(fp)
 323dab0:	e0bff915 	stw	r2,-28(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
   struct arptabent *empty  = (struct arptabent *)NULL;
   unsigned long lticks = cticks;

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 323dab4:	e0bffc17 	ldw	r2,-16(fp)
 323dab8:	10800804 	addi	r2,r2,32
 323dabc:	e0bffc15 	stw	r2,-16(fp)
 323dac0:	00c0c9b4 	movhi	r3,806
 323dac4:	18f54604 	addi	r3,r3,-10984
 323dac8:	e0bffc17 	ldw	r2,-16(fp)
 323dacc:	10ffbc36 	bltu	r2,r3,323d9c0 <find_oldest_arp+0x40>
      }
      else if (!empty)
         empty = tp;          /* grab first empty slot */
   }

   return ((exact) ? exact : ((empty) ? empty : oldest));
 323dad0:	e0bffb17 	ldw	r2,-20(fp)
 323dad4:	1004c03a 	cmpne	r2,r2,zero
 323dad8:	10000b1e 	bne	r2,zero,323db08 <find_oldest_arp+0x188>
 323dadc:	e0bff917 	ldw	r2,-28(fp)
 323dae0:	1005003a 	cmpeq	r2,r2,zero
 323dae4:	1000031e 	bne	r2,zero,323daf4 <find_oldest_arp+0x174>
 323dae8:	e0bff917 	ldw	r2,-28(fp)
 323daec:	e0bffe15 	stw	r2,-8(fp)
 323daf0:	00000206 	br	323dafc <find_oldest_arp+0x17c>
 323daf4:	e0bffa17 	ldw	r2,-24(fp)
 323daf8:	e0bffe15 	stw	r2,-8(fp)
 323dafc:	e0bffe17 	ldw	r2,-8(fp)
 323db00:	e0bfff15 	stw	r2,-4(fp)
 323db04:	00000206 	br	323db10 <find_oldest_arp+0x190>
 323db08:	e0bffb17 	ldw	r2,-20(fp)
 323db0c:	e0bfff15 	stw	r2,-4(fp)
 323db10:	e0bfff17 	ldw	r2,-4(fp)
}
 323db14:	e037883a 	mov	sp,fp
 323db18:	dfc00117 	ldw	ra,4(sp)
 323db1c:	df000017 	ldw	fp,0(sp)
 323db20:	dec00204 	addi	sp,sp,8
 323db24:	f800283a 	ret

0323db28 <make_arp_entry>:
 * active.
 */

struct arptabent *   
make_arp_entry(ip_addr dest_ip, NET net)
{
 323db28:	defffa04 	addi	sp,sp,-24
 323db2c:	dfc00515 	stw	ra,20(sp)
 323db30:	df000415 	stw	fp,16(sp)
 323db34:	df000404 	addi	fp,sp,16
 323db38:	e13ffe15 	stw	r4,-8(fp)
 323db3c:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *oldest;
   unsigned long lticks = cticks;
 323db40:	0080c974 	movhi	r2,805
 323db44:	10934104 	addi	r2,r2,19716
 323db48:	10800017 	ldw	r2,0(r2)
 323db4c:	e0bffc15 	stw	r2,-16(fp)

   /* find usable (or existing) ARP table entry */
   oldest = find_oldest_arp(dest_ip);
 323db50:	e13ffe17 	ldw	r4,-8(fp)
 323db54:	323d9800 	call	323d980 <find_oldest_arp>
 323db58:	e0bffd15 	stw	r2,-12(fp)

   /* If recycling entry, don't leak packets which may be stuck here */
   if (oldest->pending && (oldest->t_pro_addr != dest_ip))
 323db5c:	e0bffd17 	ldw	r2,-12(fp)
 323db60:	10800417 	ldw	r2,16(r2)
 323db64:	1005003a 	cmpeq	r2,r2,zero
 323db68:	1000061e 	bne	r2,zero,323db84 <make_arp_entry+0x5c>
 323db6c:	e0bffd17 	ldw	r2,-12(fp)
 323db70:	10c00017 	ldw	r3,0(r2)
 323db74:	e0bffe17 	ldw	r2,-8(fp)
 323db78:	18800226 	beq	r3,r2,323db84 <make_arp_entry+0x5c>
   {
      arp_free_pending(oldest);
 323db7c:	e13ffd17 	ldw	r4,-12(fp)
 323db80:	323d3ec0 	call	323d3ec <arp_free_pending>
   }

   /* partially fill in arp entry */
   oldest->t_pro_addr = dest_ip;
 323db84:	e0fffd17 	ldw	r3,-12(fp)
 323db88:	e0bffe17 	ldw	r2,-8(fp)
 323db8c:	18800015 	stw	r2,0(r3)
   oldest->net = net;
 323db90:	e0fffd17 	ldw	r3,-12(fp)
 323db94:	e0bfff17 	ldw	r2,-4(fp)
 323db98:	18800315 	stw	r2,12(r3)
   oldest->flags = 0;
 323db9c:	e0bffd17 	ldw	r2,-12(fp)
 323dba0:	1000070d 	sth	zero,28(r2)
   MEMSET(oldest->t_phy_addr, '\0', 6);   /* clear mac address */
 323dba4:	e0bffd17 	ldw	r2,-12(fp)
 323dba8:	10800104 	addi	r2,r2,4
 323dbac:	10000005 	stb	zero,0(r2)
 323dbb0:	10000045 	stb	zero,1(r2)
 323dbb4:	10000085 	stb	zero,2(r2)
 323dbb8:	100000c5 	stb	zero,3(r2)
 323dbbc:	10000105 	stb	zero,4(r2)
 323dbc0:	10000145 	stb	zero,5(r2)
   oldest->createtime = oldest->lasttime = lticks;
 323dbc4:	e0fffd17 	ldw	r3,-12(fp)
 323dbc8:	e0bffc17 	ldw	r2,-16(fp)
 323dbcc:	18800615 	stw	r2,24(r3)
 323dbd0:	e0bffd17 	ldw	r2,-12(fp)
 323dbd4:	10c00617 	ldw	r3,24(r2)
 323dbd8:	e0bffd17 	ldw	r2,-12(fp)
 323dbdc:	10c00515 	stw	r3,20(r2)

   /* start a ARP timer if there isn't one already */
   /* update the timeout value if there is a timer */
   /* time is specified in milliseconds */
   if (arp_timer == 0)
 323dbe0:	d0a8f617 	ldw	r2,-23592(gp)
 323dbe4:	1004c03a 	cmpne	r2,r2,zero
 323dbe8:	1000071e 	bne	r2,zero,323dc08 <make_arp_entry+0xe0>
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
 323dbec:	0100c934 	movhi	r4,804
 323dbf0:	2138b604 	addi	r4,r4,-7464
 323dbf4:	0149c404 	movi	r5,10000
 323dbf8:	000d883a 	mov	r6,zero
 323dbfc:	323cea40 	call	323cea4 <in_timerset>
 323dc00:	d0a8f615 	stw	r2,-23592(gp)
 323dc04:	00000706 	br	323dc24 <make_arp_entry+0xfc>
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 323dc08:	d0a8f617 	ldw	r2,-23592(gp)
 323dc0c:	1009883a 	mov	r4,r2
 323dc10:	d0a8f617 	ldw	r2,-23592(gp)
 323dc14:	10c00217 	ldw	r3,8(r2)
 323dc18:	e0bffc17 	ldw	r2,-16(fp)
 323dc1c:	1885883a 	add	r2,r3,r2
 323dc20:	20800315 	stw	r2,12(r4)
              ((struct intimer *)arp_timer)->interval + lticks;
   }

   return oldest;
 323dc24:	e0bffd17 	ldw	r2,-12(fp)
}
 323dc28:	e037883a 	mov	sp,fp
 323dc2c:	dfc00117 	ldw	ra,4(sp)
 323dc30:	df000017 	ldw	fp,0(sp)
 323dc34:	dec00204 	addi	sp,sp,8
 323dc38:	f800283a 	ret

0323dc3c <arpReply>:
 * must be freed (or reused) herein. 
 */

void
arpReply(PACKET pkt)
{
 323dc3c:	defff704 	addi	sp,sp,-36
 323dc40:	dfc00815 	stw	ra,32(sp)
 323dc44:	df000715 	stw	fp,28(sp)
 323dc48:	df000704 	addi	fp,sp,28
 323dc4c:	e13fff15 	stw	r4,-4(fp)
   struct arp_hdr *in;
   struct arp_hdr *out;
   char *ethout;
   char *ethin;

   LOCK_NET_RESOURCE(FREEQ_RESID);
 323dc50:	01000084 	movi	r4,2
 323dc54:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   outpkt = pk_alloc(arpsize);
 323dc58:	01000c04 	movi	r4,48
 323dc5c:	322a2ac0 	call	322a2ac <pk_alloc>
 323dc60:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323dc64:	01000084 	movi	r4,2
 323dc68:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   if (!outpkt)
 323dc6c:	e0bffe17 	ldw	r2,-8(fp)
 323dc70:	1004c03a 	cmpne	r2,r2,zero
 323dc74:	1000021e 	bne	r2,zero,323dc80 <arpReply+0x44>
   {
      dtrap();
 323dc78:	322aef00 	call	322aef0 <dtrap>
      return;
 323dc7c:	00008f06 	br	323debc <arpReply+0x280>
   }

   outpkt->net = pkt->net;    /* send back out the iface it came from */
 323dc80:	e0bfff17 	ldw	r2,-4(fp)
 323dc84:	10c00617 	ldw	r3,24(r2)
 323dc88:	e0bffe17 	ldw	r2,-8(fp)
 323dc8c:	10c00615 	stw	r3,24(r2)

   ethin = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 323dc90:	e0bfff17 	ldw	r2,-4(fp)
 323dc94:	10800317 	ldw	r2,12(r2)
 323dc98:	10bffc84 	addi	r2,r2,-14
 323dc9c:	e0bffa15 	stw	r2,-24(fp)
   ethout = outpkt->nb_buff + ETHHDR_BIAS;
 323dca0:	e0bffe17 	ldw	r2,-8(fp)
 323dca4:	10800117 	ldw	r2,4(r2)
 323dca8:	10800084 	addi	r2,r2,2
 323dcac:	e0bffb15 	stw	r2,-20(fp)
      snap->type = ET_ARP;
   }
   else
#endif   /* IEEE_802_3 */
   {
      ET_TYPE_SET(ethout, ntohs(ET_ARP));   /* 0x0806 - ARP type on ethernet */
 323dcb0:	e0bffb17 	ldw	r2,-20(fp)
 323dcb4:	10c00304 	addi	r3,r2,12
 323dcb8:	00800204 	movi	r2,8
 323dcbc:	18800005 	stb	r2,0(r3)
 323dcc0:	e0bffb17 	ldw	r2,-20(fp)
 323dcc4:	10c00344 	addi	r3,r2,13
 323dcc8:	00800184 	movi	r2,6
 323dccc:	18800005 	stb	r2,0(r3)
      in = (struct arp_hdr *)(pkt->nb_prot);
 323dcd0:	e0bfff17 	ldw	r2,-4(fp)
 323dcd4:	10800317 	ldw	r2,12(r2)
 323dcd8:	e0bffd15 	stw	r2,-12(fp)
      out = (struct arp_hdr *)(outpkt->nb_buff + ETHHDR_SIZE);
 323dcdc:	e0bffe17 	ldw	r2,-8(fp)
 323dce0:	10800117 	ldw	r2,4(r2)
 323dce4:	10800404 	addi	r2,r2,16
 323dce8:	e0bffc15 	stw	r2,-16(fp)
      outpkt->nb_plen = arpsize;
 323dcec:	e0fffe17 	ldw	r3,-8(fp)
 323dcf0:	00800c04 	movi	r2,48
 323dcf4:	18800415 	stw	r2,16(r3)

   /* prepare outgoing arp packet */
#ifdef IEEE_802_3
   out->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   out->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 323dcf8:	e0fffc17 	ldw	r3,-16(fp)
 323dcfc:	00804004 	movi	r2,256
 323dd00:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   out->ar_pro = ARPIP;
 323dd04:	e0fffc17 	ldw	r3,-16(fp)
 323dd08:	00800204 	movi	r2,8
 323dd0c:	1880008d 	sth	r2,2(r3)
   out->ar_hln = 6;
 323dd10:	e0fffc17 	ldw	r3,-16(fp)
 323dd14:	00800184 	movi	r2,6
 323dd18:	18800105 	stb	r2,4(r3)
   out->ar_pln = 4;
 323dd1c:	e0fffc17 	ldw	r3,-16(fp)
 323dd20:	00800104 	movi	r2,4
 323dd24:	18800145 	stb	r2,5(r3)
   out->ar_op = ARREP;
 323dd28:	e0fffc17 	ldw	r3,-16(fp)
 323dd2c:	00808004 	movi	r2,512
 323dd30:	1880018d 	sth	r2,6(r3)
   out->ar_tpa = in->ar_spa;     /* swap IP addresses */
 323dd34:	e0bffd17 	ldw	r2,-12(fp)
 323dd38:	10c00417 	ldw	r3,16(r2)
 323dd3c:	e0bffc17 	ldw	r2,-16(fp)
 323dd40:	10c00715 	stw	r3,28(r2)
   out->ar_spa = in->ar_tpa;
 323dd44:	e0bffd17 	ldw	r2,-12(fp)
 323dd48:	10c00717 	ldw	r3,28(r2)
 323dd4c:	e0bffc17 	ldw	r2,-16(fp)
 323dd50:	10c00415 	stw	r3,16(r2)
   MEMMOVE(out->ar_tha, in->ar_sha, 6);    /* move his MAC address */
 323dd54:	e0bffc17 	ldw	r2,-16(fp)
 323dd58:	11000504 	addi	r4,r2,20
 323dd5c:	e0bffd17 	ldw	r2,-12(fp)
 323dd60:	11400204 	addi	r5,r2,8
 323dd64:	01800184 	movi	r6,6
 323dd68:	3206b700 	call	3206b70 <memmove>
   MEMMOVE(out->ar_sha, outpkt->net->n_mib->ifPhysAddress, 6);  /* fill in our mac address */
 323dd6c:	e0bffc17 	ldw	r2,-16(fp)
 323dd70:	11000204 	addi	r4,r2,8
 323dd74:	e0bffe17 	ldw	r2,-8(fp)
 323dd78:	10800617 	ldw	r2,24(r2)
 323dd7c:	10802717 	ldw	r2,156(r2)
 323dd80:	11400517 	ldw	r5,20(r2)
 323dd84:	01800184 	movi	r6,6
 323dd88:	3206b700 	call	3206b70 <memmove>

   /* prepend ethernet unicast header to arp reply */
   MEMMOVE(ethout + ET_DSTOFF, ethin + ET_SRCOFF, 6);
 323dd8c:	e0bffa17 	ldw	r2,-24(fp)
 323dd90:	11400184 	addi	r5,r2,6
 323dd94:	e13ffb17 	ldw	r4,-20(fp)
 323dd98:	01800184 	movi	r6,6
 323dd9c:	3206b700 	call	3206b70 <memmove>
   MEMMOVE(ethout + ET_SRCOFF, outpkt->net->n_mib->ifPhysAddress, 6);
 323dda0:	e0bffb17 	ldw	r2,-20(fp)
 323dda4:	11000184 	addi	r4,r2,6
 323dda8:	e0bffe17 	ldw	r2,-8(fp)
 323ddac:	10800617 	ldw	r2,24(r2)
 323ddb0:	10802717 	ldw	r2,156(r2)
 323ddb4:	11400517 	ldw	r5,20(r2)
 323ddb8:	01800184 	movi	r6,6
 323ddbc:	3206b700 	call	3206b70 <memmove>

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)out;
 323ddc0:	e0bffc17 	ldw	r2,-16(fp)
 323ddc4:	e0bff915 	stw	r2,-28(fp)
      MEMMOVE(&arwp->data[AR_SHA], out->ar_sha, 6);
 323ddc8:	e0bff917 	ldw	r2,-28(fp)
 323ddcc:	11000204 	addi	r4,r2,8
 323ddd0:	e0bffc17 	ldw	r2,-16(fp)
 323ddd4:	11400204 	addi	r5,r2,8
 323ddd8:	01800184 	movi	r6,6
 323dddc:	3206b700 	call	3206b70 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &out->ar_spa, 4);
 323dde0:	e0bff917 	ldw	r2,-28(fp)
 323dde4:	10800204 	addi	r2,r2,8
 323dde8:	11000184 	addi	r4,r2,6
 323ddec:	e0bffc17 	ldw	r2,-16(fp)
 323ddf0:	11400404 	addi	r5,r2,16
 323ddf4:	01800104 	movi	r6,4
 323ddf8:	3206b700 	call	3206b70 <memmove>
      MEMMOVE(&arwp->data[AR_THA], out->ar_tha, 6);
 323ddfc:	e0bff917 	ldw	r2,-28(fp)
 323de00:	10800204 	addi	r2,r2,8
 323de04:	11000284 	addi	r4,r2,10
 323de08:	e0bffc17 	ldw	r2,-16(fp)
 323de0c:	11400504 	addi	r5,r2,20
 323de10:	01800184 	movi	r6,6
 323de14:	3206b700 	call	3206b70 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &out->ar_tpa, 4);
 323de18:	e0bff917 	ldw	r2,-28(fp)
 323de1c:	10800204 	addi	r2,r2,8
 323de20:	11000404 	addi	r4,r2,16
 323de24:	e0bffc17 	ldw	r2,-16(fp)
 323de28:	11400704 	addi	r5,r2,28
 323de2c:	01800104 	movi	r6,4
 323de30:	3206b700 	call	3206b70 <memmove>
   }
#endif   /* NO_CC_PACKING */

   /* if a packet oriented send exists, use it: */
   if (outpkt->net->pkt_send)
 323de34:	e0bffe17 	ldw	r2,-8(fp)
 323de38:	10800617 	ldw	r2,24(r2)
 323de3c:	10800417 	ldw	r2,16(r2)
 323de40:	1005003a 	cmpeq	r2,r2,zero
 323de44:	10000a1e 	bne	r2,zero,323de70 <arpReply+0x234>
   {
      outpkt->nb_prot = outpkt->nb_buff;
 323de48:	e0bffe17 	ldw	r2,-8(fp)
 323de4c:	10c00117 	ldw	r3,4(r2)
 323de50:	e0bffe17 	ldw	r2,-8(fp)
 323de54:	10c00315 	stw	r3,12(r2)
      outpkt->net->pkt_send(outpkt);
 323de58:	e0bffe17 	ldw	r2,-8(fp)
 323de5c:	10800617 	ldw	r2,24(r2)
 323de60:	10800417 	ldw	r2,16(r2)
 323de64:	e13ffe17 	ldw	r4,-8(fp)
 323de68:	103ee83a 	callr	r2
 323de6c:	00001006 	br	323deb0 <arpReply+0x274>
   }
   else
   {
      outpkt->net->raw_send(pkt->net, outpkt->nb_buff, outpkt->nb_plen);
 323de70:	e0bffe17 	ldw	r2,-8(fp)
 323de74:	10800617 	ldw	r2,24(r2)
 323de78:	10c00317 	ldw	r3,12(r2)
 323de7c:	e0bfff17 	ldw	r2,-4(fp)
 323de80:	11000617 	ldw	r4,24(r2)
 323de84:	e0bffe17 	ldw	r2,-8(fp)
 323de88:	11400117 	ldw	r5,4(r2)
 323de8c:	e0bffe17 	ldw	r2,-8(fp)
 323de90:	11800417 	ldw	r6,16(r2)
 323de94:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 323de98:	01000084 	movi	r4,2
 323de9c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(outpkt);
 323dea0:	e13ffe17 	ldw	r4,-8(fp)
 323dea4:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323dea8:	01000084 	movi	r4,2
 323deac:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   }
   /* input 'pkt' will be freed by caller */
   arpRepsOut++;
 323deb0:	d0a8fb17 	ldw	r2,-23572(gp)
 323deb4:	10800044 	addi	r2,r2,1
 323deb8:	d0a8fb15 	stw	r2,-23572(gp)
}
 323debc:	e037883a 	mov	sp,fp
 323dec0:	dfc00117 	ldw	ra,4(sp)
 323dec4:	df000017 	ldw	fp,0(sp)
 323dec8:	dec00204 	addi	sp,sp,8
 323decc:	f800283a 	ret

0323ded0 <arprcv>:
 *                            else a negative error code. 
 */

int
arprcv(PACKET pkt)
{
 323ded0:	defff804 	addi	sp,sp,-32
 323ded4:	dfc00715 	stw	ra,28(sp)
 323ded8:	df000615 	stw	fp,24(sp)
 323dedc:	df000604 	addi	fp,sp,24
 323dee0:	e13ffe15 	stw	r4,-8(fp)
   char *eth;
#ifdef IEEE_802_3
   int      ieee = FALSE;     /* TRUE if received packet is 802.3 */
#endif

   eth = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 323dee4:	e0bffe17 	ldw	r2,-8(fp)
 323dee8:	10800317 	ldw	r2,12(r2)
 323deec:	10bffc84 	addi	r2,r2,-14
 323def0:	e0bffb15 	stw	r2,-20(fp)
   arphdr = (struct arp_hdr *)(pkt->nb_prot);
 323def4:	e0bffe17 	ldw	r2,-8(fp)
 323def8:	10800317 	ldw	r2,12(r2)
 323defc:	e0bffd15 	stw	r2,-12(fp)
#endif   /* IEEE_802_3_ONLY */
#endif   /* IEEE_802_3 */

#ifdef NO_CC_PACKING    /* force ARP fields to local CPU valid boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 323df00:	e0bffd17 	ldw	r2,-12(fp)
 323df04:	e0bffa15 	stw	r2,-24(fp)
      MEMMOVE(&arphdr->ar_tpa, &arwp->data[AR_TPA], 4);
 323df08:	e0bffd17 	ldw	r2,-12(fp)
 323df0c:	11000704 	addi	r4,r2,28
 323df10:	e0bffa17 	ldw	r2,-24(fp)
 323df14:	10800204 	addi	r2,r2,8
 323df18:	11400404 	addi	r5,r2,16
 323df1c:	01800104 	movi	r6,4
 323df20:	3206b700 	call	3206b70 <memmove>
      MEMMOVE(arphdr->ar_tha, &arwp->data[AR_THA], 6);
 323df24:	e0bffd17 	ldw	r2,-12(fp)
 323df28:	11000504 	addi	r4,r2,20
 323df2c:	e0bffa17 	ldw	r2,-24(fp)
 323df30:	10800204 	addi	r2,r2,8
 323df34:	11400284 	addi	r5,r2,10
 323df38:	01800184 	movi	r6,6
 323df3c:	3206b700 	call	3206b70 <memmove>
      MEMMOVE(&arphdr->ar_spa, &arwp->data[AR_SPA], 4);
 323df40:	e0bffd17 	ldw	r2,-12(fp)
 323df44:	11000404 	addi	r4,r2,16
 323df48:	e0bffa17 	ldw	r2,-24(fp)
 323df4c:	10800204 	addi	r2,r2,8
 323df50:	11400184 	addi	r5,r2,6
 323df54:	01800104 	movi	r6,4
 323df58:	3206b700 	call	3206b70 <memmove>
      MEMMOVE(arphdr->ar_sha, &arwp->data[AR_SHA], 6);
 323df5c:	e0bffd17 	ldw	r2,-12(fp)
 323df60:	11000204 	addi	r4,r2,8
 323df64:	e0bffa17 	ldw	r2,-24(fp)
 323df68:	11400204 	addi	r5,r2,8
 323df6c:	01800184 	movi	r6,6
 323df70:	3206b700 	call	3206b70 <memmove>
   }
#endif

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 323df74:	e0bffd17 	ldw	r2,-12(fp)
 323df78:	10c00717 	ldw	r3,28(r2)
 323df7c:	e0bffe17 	ldw	r2,-8(fp)
 323df80:	10800617 	ldw	r2,24(r2)
 323df84:	10800a17 	ldw	r2,40(r2)
 323df88:	18801f26 	beq	r3,r2,323e008 <arprcv+0x138>
 323df8c:	e0bffd17 	ldw	r2,-12(fp)
 323df90:	10800717 	ldw	r2,28(r2)
 323df94:	1004d63a 	srli	r2,r2,24
 323df98:	10c03fcc 	andi	r3,r2,255
 323df9c:	e0bffd17 	ldw	r2,-12(fp)
 323dfa0:	10800717 	ldw	r2,28(r2)
 323dfa4:	1004d23a 	srli	r2,r2,8
 323dfa8:	10bfc00c 	andi	r2,r2,65280
 323dfac:	1886b03a 	or	r3,r3,r2
 323dfb0:	e0bffd17 	ldw	r2,-12(fp)
 323dfb4:	10800717 	ldw	r2,28(r2)
 323dfb8:	10bfc00c 	andi	r2,r2,65280
 323dfbc:	1004923a 	slli	r2,r2,8
 323dfc0:	1886b03a 	or	r3,r3,r2
 323dfc4:	e0bffd17 	ldw	r2,-12(fp)
 323dfc8:	10800717 	ldw	r2,28(r2)
 323dfcc:	10803fcc 	andi	r2,r2,255
 323dfd0:	1004963a 	slli	r2,r2,24
 323dfd4:	1884b03a 	or	r2,r3,r2
 323dfd8:	10fc002c 	andhi	r3,r2,61440
 323dfdc:	00b80034 	movhi	r2,57344
 323dfe0:	18800926 	beq	r3,r2,323e008 <arprcv+0x138>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
#else
   if (arphdr->ar_tpa != pkt->net->n_ipaddr)
#endif /* IP_MULTICAST */
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 323dfe4:	01000084 	movi	r4,2
 323dfe8:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(pkt);     /* not for us, dump & ret (proxy here later?) */
 323dfec:	e13ffe17 	ldw	r4,-8(fp)
 323dff0:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323dff4:	01000084 	movi	r4,2
 323dff8:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return (ENP_NOT_MINE);
 323dffc:	00800084 	movi	r2,2
 323e000:	e0bfff15 	stw	r2,-4(fp)
 323e004:	00004406 	br	323e118 <arprcv+0x248>
   }

   if (arphdr->ar_op == ARREQ)   /* is it an arp request? */
 323e008:	e0bffd17 	ldw	r2,-12(fp)
 323e00c:	1080018b 	ldhu	r2,6(r2)
 323e010:	10bfffcc 	andi	r2,r2,65535
 323e014:	10804018 	cmpnei	r2,r2,256
 323e018:	10000b1e 	bne	r2,zero,323e048 <arprcv+0x178>
   {
      arpReqsIn++;   /* count these */
 323e01c:	d0a8f817 	ldw	r2,-23584(gp)
 323e020:	10800044 	addi	r2,r2,1
 323e024:	d0a8f815 	stw	r2,-23584(gp)
      arpReply(pkt); /* send arp reply */
 323e028:	e13ffe17 	ldw	r4,-8(fp)
 323e02c:	323dc3c0 	call	323dc3c <arpReply>
      /* make partial ARP table entry */
      make_arp_entry(arphdr->ar_spa, pkt->net);
 323e030:	e0bffd17 	ldw	r2,-12(fp)
 323e034:	11000417 	ldw	r4,16(r2)
 323e038:	e0bffe17 	ldw	r2,-8(fp)
 323e03c:	11400617 	ldw	r5,24(r2)
 323e040:	323db280 	call	323db28 <make_arp_entry>
 323e044:	00000306 	br	323e054 <arprcv+0x184>
      /* fall thru to arp reply logic to finish our table entry */
   }
   else     /* ARP reply, count and fall thru to logic to update table */
   {
      arpRepsIn++;
 323e048:	d0a8fa17 	ldw	r2,-23576(gp)
 323e04c:	10800044 	addi	r2,r2,1
 323e050:	d0a8fa15 	stw	r2,-23576(gp)
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 323e054:	0080c9b4 	movhi	r2,806
 323e058:	10b50604 	addi	r2,r2,-11240
 323e05c:	e0bffc15 	stw	r2,-16(fp)
 323e060:	00002106 	br	323e0e8 <arprcv+0x218>
   {
      if (tp->t_pro_addr == arphdr->ar_spa)     /* we found IP address, update entry */
 323e064:	e0bffc17 	ldw	r2,-16(fp)
 323e068:	10c00017 	ldw	r3,0(r2)
 323e06c:	e0bffd17 	ldw	r2,-12(fp)
 323e070:	10800417 	ldw	r2,16(r2)
 323e074:	1880191e 	bne	r3,r2,323e0dc <arprcv+0x20c>
            tp->flags |= ET_SNAP;
         else
            tp->flags |= ET_ETH2;      /* else it's ethernet II */
#endif   /* IEEE_802_3 */

         MEMMOVE(tp->t_phy_addr, arphdr->ar_sha, 6);   /* update MAC adddress */
 323e078:	e0bffc17 	ldw	r2,-16(fp)
 323e07c:	11000104 	addi	r4,r2,4
 323e080:	e0bffd17 	ldw	r2,-12(fp)
 323e084:	11400204 	addi	r5,r2,8
 323e088:	01800184 	movi	r6,6
 323e08c:	3206b700 	call	3206b70 <memmove>
         tp->lasttime = cticks;
 323e090:	0080c974 	movhi	r2,805
 323e094:	10934104 	addi	r2,r2,19716
 323e098:	10c00017 	ldw	r3,0(r2)
 323e09c:	e0bffc17 	ldw	r2,-16(fp)
 323e0a0:	10c00615 	stw	r3,24(r2)
         if (tp->pending)     /* packet waiting for this IP entry? */
 323e0a4:	e0bffc17 	ldw	r2,-16(fp)
 323e0a8:	10800417 	ldw	r2,16(r2)
 323e0ac:	1005003a 	cmpeq	r2,r2,zero
 323e0b0:	1000021e 	bne	r2,zero,323e0bc <arprcv+0x1ec>
         {
            arp_send_pending(tp);
 323e0b4:	e13ffc17 	ldw	r4,-16(fp)
 323e0b8:	323d4740 	call	323d474 <arp_send_pending>
         }
         LOCK_NET_RESOURCE(FREEQ_RESID);
 323e0bc:	01000084 	movi	r4,2
 323e0c0:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 323e0c4:	e13ffe17 	ldw	r4,-8(fp)
 323e0c8:	322a6400 	call	322a640 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323e0cc:	01000084 	movi	r4,2
 323e0d0:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

         return (0);
 323e0d4:	e03fff15 	stw	zero,-4(fp)
 323e0d8:	00000f06 	br	323e118 <arprcv+0x248>
      arpRepsIn++;
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 323e0dc:	e0bffc17 	ldw	r2,-16(fp)
 323e0e0:	10800804 	addi	r2,r2,32
 323e0e4:	e0bffc15 	stw	r2,-16(fp)
 323e0e8:	00c0c9b4 	movhi	r3,806
 323e0ec:	18f54604 	addi	r3,r3,-10984
 323e0f0:	e0bffc17 	ldw	r2,-16(fp)
 323e0f4:	10ffdb36 	bltu	r2,r3,323e064 <arprcv+0x194>

#ifdef IEEE_802_3_ONLY
drop:
#endif /* IEEE_802_3_ONLY */
   /* fall to here if packet is not in table */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 323e0f8:	01000084 	movi	r4,2
 323e0fc:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   pk_free(pkt);
 323e100:	e13ffe17 	ldw	r4,-8(fp)
 323e104:	322a6400 	call	322a640 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323e108:	01000084 	movi	r4,2
 323e10c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   return ENP_NOT_MINE;
 323e110:	00800084 	movi	r2,2
 323e114:	e0bfff15 	stw	r2,-4(fp)
 323e118:	e0bfff17 	ldw	r2,-4(fp)
}
 323e11c:	e037883a 	mov	sp,fp
 323e120:	dfc00117 	ldw	ra,4(sp)
 323e124:	df000017 	ldw	fp,0(sp)
 323e128:	dec00204 	addi	sp,sp,8
 323e12c:	f800283a 	ret

0323e130 <send_via_arp>:
 * change the PC's IP address. 
 */

int
send_via_arp(PACKET pkt, ip_addr dest_ip)
{
 323e130:	defff704 	addi	sp,sp,-36
 323e134:	dfc00815 	stw	ra,32(sp)
 323e138:	df000715 	stw	fp,28(sp)
 323e13c:	df000704 	addi	fp,sp,28
 323e140:	e13ffd15 	stw	r4,-12(fp)
 323e144:	e17ffe15 	stw	r5,-8(fp)
   struct arptabent *tp;
   unsigned long lticks = cticks;
 323e148:	0080c974 	movhi	r2,805
 323e14c:	10934104 	addi	r2,r2,19716
 323e150:	10800017 	ldw	r2,0(r2)
 323e154:	e0bffb15 	stw	r2,-20(fp)
   int err;

   /* don't allow zero dest */
   if (dest_ip == 0)
 323e158:	e0bffe17 	ldw	r2,-8(fp)
 323e15c:	1004c03a 	cmpne	r2,r2,zero
 323e160:	1000091e 	bne	r2,zero,323e188 <send_via_arp+0x58>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 323e164:	01000084 	movi	r4,2
 323e168:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 323e16c:	e13ffd17 	ldw	r4,-12(fp)
 323e170:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323e174:	01000084 	movi	r4,2
 323e178:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return SEND_DROPPED; 
 323e17c:	00bffa84 	movi	r2,-22
 323e180:	e0bfff15 	stw	r2,-4(fp)
 323e184:	00004e06 	br	323e2c0 <send_via_arp+0x190>
   }

   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
 323e188:	d0e8fc17 	ldw	r3,-23568(gp)
 323e18c:	e0bffb17 	ldw	r2,-20(fp)
 323e190:	10c5c83a 	sub	r2,r2,r3
 323e194:	1080fa70 	cmpltui	r2,r2,1001
 323e198:	1000011e 	bne	r2,zero,323e1a0 <send_via_arp+0x70>
      arpcache = (struct arptabent *)NULL;
 323e19c:	d028f715 	stw	zero,-23588(gp)

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 323e1a0:	d0a8f717 	ldw	r2,-23588(gp)
 323e1a4:	1005003a 	cmpeq	r2,r2,zero
 323e1a8:	1000071e 	bne	r2,zero,323e1c8 <send_via_arp+0x98>
 323e1ac:	d0a8f717 	ldw	r2,-23588(gp)
 323e1b0:	10c00017 	ldw	r3,0(r2)
 323e1b4:	e0bffe17 	ldw	r2,-8(fp)
 323e1b8:	1880031e 	bne	r3,r2,323e1c8 <send_via_arp+0x98>
      tp = arpcache;
 323e1bc:	d0a8f717 	ldw	r2,-23588(gp)
 323e1c0:	e0bffc15 	stw	r2,-16(fp)
   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
      arpcache = (struct arptabent *)NULL;

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 323e1c4:	00000306 	br	323e1d4 <send_via_arp+0xa4>
      tp = arpcache;
   else
   {
      /* scan arp table for an existing entry */
      tp = find_oldest_arp(dest_ip);
 323e1c8:	e13ffe17 	ldw	r4,-8(fp)
 323e1cc:	323d9800 	call	323d980 <find_oldest_arp>
 323e1d0:	e0bffc15 	stw	r2,-16(fp)
   }

   if (tp->t_pro_addr == dest_ip)   /* we found our entry */
 323e1d4:	e0bffc17 	ldw	r2,-16(fp)
 323e1d8:	10c00017 	ldw	r3,0(r2)
 323e1dc:	e0bffe17 	ldw	r2,-8(fp)
 323e1e0:	1880311e 	bne	r3,r2,323e2a8 <send_via_arp+0x178>
   {
      if (tp->pending)  /* arp already pending for this IP? */
 323e1e4:	e0bffc17 	ldw	r2,-16(fp)
 323e1e8:	10800417 	ldw	r2,16(r2)
 323e1ec:	1005003a 	cmpeq	r2,r2,zero
 323e1f0:	1000241e 	bne	r2,zero,323e284 <send_via_arp+0x154>
      {
         if (lilfreeq.q_len < 2)
 323e1f4:	0080c9b4 	movhi	r2,806
 323e1f8:	10b3a704 	addi	r2,r2,-12644
 323e1fc:	10800217 	ldw	r2,8(r2)
 323e200:	10800088 	cmpgei	r2,r2,2
 323e204:	1000091e 	bne	r2,zero,323e22c <send_via_arp+0xfc>
         {
            /* system is depleted of resources - free the
             * pkt instead of queueing it - so that we are in a
             * position to receive an arp reply 
             */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 323e208:	01000084 	movi	r4,2
 323e20c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
            pk_free(pkt);  /* sorry, we have to dump this one.. */
 323e210:	e13ffd17 	ldw	r4,-12(fp)
 323e214:	322a6400 	call	322a640 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323e218:	01000084 	movi	r4,2
 323e21c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
            err = SEND_DROPPED;    /* pkts already waiting for this IP entry */
 323e220:	00bffa84 	movi	r2,-22
 323e224:	e0bffa15 	stw	r2,-24(fp)
 323e228:	00002306 	br	323e2b8 <send_via_arp+0x188>
         }
         else
         {
            PACKET tmppkt=tp->pending;
 323e22c:	e0bffc17 	ldw	r2,-16(fp)
 323e230:	10800417 	ldw	r2,16(r2)
 323e234:	e0bff915 	stw	r2,-28(fp)

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 323e238:	00000306 	br	323e248 <send_via_arp+0x118>
               tmppkt = tmppkt->next;
 323e23c:	e0bff917 	ldw	r2,-28(fp)
 323e240:	10800017 	ldw	r2,0(r2)
 323e244:	e0bff915 	stw	r2,-28(fp)
         else
         {
            PACKET tmppkt=tp->pending;

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 323e248:	e0bff917 	ldw	r2,-28(fp)
 323e24c:	10800017 	ldw	r2,0(r2)
 323e250:	1004c03a 	cmpne	r2,r2,zero
 323e254:	103ff91e 	bne	r2,zero,323e23c <send_via_arp+0x10c>
               tmppkt = tmppkt->next;
            tmppkt->next = pkt;      /* add new pkt to end of list */
 323e258:	e0fff917 	ldw	r3,-28(fp)
 323e25c:	e0bffd17 	ldw	r2,-12(fp)
 323e260:	18800015 	stw	r2,0(r3)
            if (pkt->next)
 323e264:	e0bffd17 	ldw	r2,-12(fp)
 323e268:	10800017 	ldw	r2,0(r2)
 323e26c:	1005003a 	cmpeq	r2,r2,zero
 323e270:	1000011e 	bne	r2,zero,323e278 <send_via_arp+0x148>
            {
               dtrap();              /* chain of pkts to be sent ??? */
 323e274:	322aef00 	call	322aef0 <dtrap>
            }
            err = ENP_SEND_PENDING; /* packet queued pending ARP reply */
 323e278:	00800044 	movi	r2,1
 323e27c:	e0bffa15 	stw	r2,-24(fp)
 323e280:	00000d06 	br	323e2b8 <send_via_arp+0x188>
         }
      }
      else  /* just send it */
      {
         arpcache = tp;       /* cache this entry */
 323e284:	e0bffc17 	ldw	r2,-16(fp)
 323e288:	d0a8f715 	stw	r2,-23588(gp)
         cachetime = lticks;  /* mark time we cached */
 323e28c:	e0bffb17 	ldw	r2,-20(fp)
 323e290:	d0a8fc15 	stw	r2,-23568(gp)
         err = et_send(pkt, tp);
 323e294:	e13ffd17 	ldw	r4,-12(fp)
 323e298:	e17ffc17 	ldw	r5,-16(fp)
 323e29c:	323d2700 	call	323d270 <et_send>
 323e2a0:	e0bffa15 	stw	r2,-24(fp)
 323e2a4:	00000406 	br	323e2b8 <send_via_arp+0x188>
      }
   }
   else
      /* start the ARP process for this IP address */
      err = send_arp(pkt, dest_ip);
 323e2a8:	e13ffd17 	ldw	r4,-12(fp)
 323e2ac:	e17ffe17 	ldw	r5,-8(fp)
 323e2b0:	323d4e80 	call	323d4e8 <send_arp>
 323e2b4:	e0bffa15 	stw	r2,-24(fp)

   return (err);
 323e2b8:	e0bffa17 	ldw	r2,-24(fp)
 323e2bc:	e0bfff15 	stw	r2,-4(fp)
 323e2c0:	e0bfff17 	ldw	r2,-4(fp)
}
 323e2c4:	e037883a 	mov	sp,fp
 323e2c8:	dfc00117 	ldw	ra,4(sp)
 323e2cc:	df000017 	ldw	fp,0(sp)
 323e2d0:	dec00204 	addi	sp,sp,8
 323e2d4:	f800283a 	ret

0323e2d8 <cb_arpent_tmo>:
 *
 * If there are no more unresolved entries, cancel the timer.
 */
void
cb_arpent_tmo(long arg)
{
 323e2d8:	defffa04 	addi	sp,sp,-24
 323e2dc:	dfc00515 	stw	ra,20(sp)
 323e2e0:	df000415 	stw	fp,16(sp)
 323e2e4:	df000404 	addi	fp,sp,16
 323e2e8:	e13fff15 	stw	r4,-4(fp)
   struct arptabent *tp;
   int arp_count = 0;
 323e2ec:	e03ffd15 	stw	zero,-12(fp)
   unsigned long lticks = cticks;
 323e2f0:	0080c974 	movhi	r2,805
 323e2f4:	10934104 	addi	r2,r2,19716
 323e2f8:	10800017 	ldw	r2,0(r2)
 323e2fc:	e0bffc15 	stw	r2,-16(fp)

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 323e300:	0080c9b4 	movhi	r2,806
 323e304:	10b50604 	addi	r2,r2,-11240
 323e308:	e0bffe15 	stw	r2,-8(fp)
 323e30c:	00002906 	br	323e3b4 <cb_arpent_tmo+0xdc>
   {
      if (tp->t_pro_addr != 0)
 323e310:	e0bffe17 	ldw	r2,-8(fp)
 323e314:	10800017 	ldw	r2,0(r2)
 323e318:	1005003a 	cmpeq	r2,r2,zero
 323e31c:	1000221e 	bne	r2,zero,323e3a8 <cb_arpent_tmo+0xd0>
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 323e320:	e0bffe17 	ldw	r2,-8(fp)
 323e324:	10800417 	ldw	r2,16(r2)
 323e328:	1005003a 	cmpeq	r2,r2,zero
 323e32c:	10000b1e 	bne	r2,zero,323e35c <cb_arpent_tmo+0x84>
 323e330:	e0bffe17 	ldw	r2,-8(fp)
 323e334:	10c00517 	ldw	r3,20(r2)
 323e338:	e0bffc17 	ldw	r2,-16(fp)
 323e33c:	10c5c83a 	sub	r2,r2,r3
 323e340:	1080fa70 	cmpltui	r2,r2,1001
 323e344:	1000051e 	bne	r2,zero,323e35c <cb_arpent_tmo+0x84>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
 323e348:	e13ffe17 	ldw	r4,-8(fp)
 323e34c:	323d3ec0 	call	323d3ec <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 323e350:	e0bffe17 	ldw	r2,-8(fp)
 323e354:	10000015 	stw	zero,0(r2)
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
   {
      if (tp->t_pro_addr != 0)
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 323e358:	00001306 	br	323e3a8 <cb_arpent_tmo+0xd0>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 323e35c:	e0bffe17 	ldw	r2,-8(fp)
 323e360:	10c00517 	ldw	r3,20(r2)
 323e364:	e0bffc17 	ldw	r2,-16(fp)
 323e368:	10c5c83a 	sub	r2,r2,r3
 323e36c:	1007883a 	mov	r3,r2
 323e370:	d0a04b17 	ldw	r2,-32468(gp)
 323e374:	18800916 	blt	r3,r2,323e39c <cb_arpent_tmo+0xc4>
 323e378:	e0bffe17 	ldw	r2,-8(fp)
 323e37c:	10c00617 	ldw	r3,24(r2)
 323e380:	e0bffc17 	ldw	r2,-16(fp)
 323e384:	10c5c83a 	sub	r2,r2,r3
 323e388:	1080fa30 	cmpltui	r2,r2,1000
 323e38c:	1000031e 	bne	r2,zero,323e39c <cb_arpent_tmo+0xc4>
                  ((int)(lticks - tp->lasttime)   >= TPS))
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 323e390:	e0bffe17 	ldw	r2,-8(fp)
 323e394:	10000015 	stw	zero,0(r2)
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 323e398:	00000306 	br	323e3a8 <cb_arpent_tmo+0xd0>
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else
            arp_count++;
 323e39c:	e0bffd17 	ldw	r2,-12(fp)
 323e3a0:	10800044 	addi	r2,r2,1
 323e3a4:	e0bffd15 	stw	r2,-12(fp)
{
   struct arptabent *tp;
   int arp_count = 0;
   unsigned long lticks = cticks;

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 323e3a8:	e0bffe17 	ldw	r2,-8(fp)
 323e3ac:	10800804 	addi	r2,r2,32
 323e3b0:	e0bffe15 	stw	r2,-8(fp)
 323e3b4:	00c0c9b4 	movhi	r3,806
 323e3b8:	18f54604 	addi	r3,r3,-10984
 323e3bc:	e0bffe17 	ldw	r2,-8(fp)
 323e3c0:	10ffd336 	bltu	r2,r3,323e310 <cb_arpent_tmo+0x38>
            arp_count++;
      }
   }

   /* if there are no more "pending" entries, kill the timer */
   if (arp_count == 0)
 323e3c4:	e0bffd17 	ldw	r2,-12(fp)
 323e3c8:	1004c03a 	cmpne	r2,r2,zero
 323e3cc:	1000031e 	bne	r2,zero,323e3dc <cb_arpent_tmo+0x104>
   {
      in_timerkill(arp_timer);
 323e3d0:	d128f617 	ldw	r4,-23592(gp)
 323e3d4:	323d0200 	call	323d020 <in_timerkill>
      arp_timer = 0;
 323e3d8:	d028f615 	stw	zero,-23592(gp)
   }
      
   USE_ARG(arg);
}
 323e3dc:	e037883a 	mov	sp,fp
 323e3e0:	dfc00117 	ldw	ra,4(sp)
 323e3e4:	df000017 	ldw	fp,0(sp)
 323e3e8:	dec00204 	addi	sp,sp,8
 323e3ec:	f800283a 	ret

0323e3f0 <grat_arp>:
 * RETURNS: Returns 0 if OK, or the usual ENP_ errors 
 */

int
grat_arp(NET net, int flag)
{
 323e3f0:	defff604 	addi	sp,sp,-40
 323e3f4:	dfc00915 	stw	ra,36(sp)
 323e3f8:	df000815 	stw	fp,32(sp)
 323e3fc:	df000804 	addi	fp,sp,32
 323e400:	e13ffd15 	stw	r4,-12(fp)
 323e404:	e17ffe15 	stw	r5,-8(fp)
   char * ethhdr;
   struct arp_hdr *  arphdr;
   IFMIB etif = net->n_mib;    /* mib info for this ethernet interface */
 323e408:	e0bffd17 	ldw	r2,-12(fp)
 323e40c:	10802717 	ldw	r2,156(r2)
 323e410:	e0bffa15 	stw	r2,-24(fp)
   PACKET arppkt;

   /* get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 323e414:	01000084 	movi	r4,2
 323e418:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 323e41c:	01000c04 	movi	r4,48
 323e420:	322a2ac0 	call	322a2ac <pk_alloc>
 323e424:	e0bff915 	stw	r2,-28(fp)
   if (!arppkt)
 323e428:	e0bff917 	ldw	r2,-28(fp)
 323e42c:	1004c03a 	cmpne	r2,r2,zero
 323e430:	1000051e 	bne	r2,zero,323e448 <grat_arp+0x58>
   {
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323e434:	01000084 	movi	r4,2
 323e438:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 323e43c:	00bffa84 	movi	r2,-22
 323e440:	e0bfff15 	stw	r2,-4(fp)
 323e444:	00009706 	br	323e6a4 <grat_arp+0x2b4>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323e448:	01000084 	movi	r4,2
 323e44c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 323e450:	e0bff917 	ldw	r2,-28(fp)
 323e454:	10c00117 	ldw	r3,4(r2)
 323e458:	e0bff917 	ldw	r2,-28(fp)
 323e45c:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 323e460:	e0fff917 	ldw	r3,-28(fp)
 323e464:	00800c04 	movi	r2,48
 323e468:	18800415 	stw	r2,16(r3)
   arppkt->net = net;
 323e46c:	e0fff917 	ldw	r3,-28(fp)
 323e470:	e0bffd17 	ldw	r2,-12(fp)
 323e474:	18800615 	stw	r2,24(r3)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 323e478:	e0bff917 	ldw	r2,-28(fp)
 323e47c:	10800117 	ldw	r2,4(r2)
 323e480:	10800084 	addi	r2,r2,2
 323e484:	e0bffc15 	stw	r2,-16(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 323e488:	e0bff917 	ldw	r2,-28(fp)
 323e48c:	10800117 	ldw	r2,4(r2)
 323e490:	10800404 	addi	r2,r2,16
 323e494:	e0bffb15 	stw	r2,-20(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 323e498:	e0fffb17 	ldw	r3,-20(fp)
 323e49c:	00804004 	movi	r2,256
 323e4a0:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 323e4a4:	e0fffb17 	ldw	r3,-20(fp)
 323e4a8:	00800204 	movi	r2,8
 323e4ac:	1880008d 	sth	r2,2(r3)
   arphdr->ar_hln = 6;
 323e4b0:	e0fffb17 	ldw	r3,-20(fp)
 323e4b4:	00800184 	movi	r2,6
 323e4b8:	18800105 	stb	r2,4(r3)
   arphdr->ar_pln = 4;
 323e4bc:	e0fffb17 	ldw	r3,-20(fp)
 323e4c0:	00800104 	movi	r2,4
 323e4c4:	18800145 	stb	r2,5(r3)
   
   /* ARP req? */
   if (flag == 0)
 323e4c8:	e0bffe17 	ldw	r2,-8(fp)
 323e4cc:	1004c03a 	cmpne	r2,r2,zero
 323e4d0:	1000041e 	bne	r2,zero,323e4e4 <grat_arp+0xf4>
      /* yup */
      arphdr->ar_op = ARREQ;
 323e4d4:	e0fffb17 	ldw	r3,-20(fp)
 323e4d8:	00804004 	movi	r2,256
 323e4dc:	1880018d 	sth	r2,6(r3)
 323e4e0:	00000306 	br	323e4f0 <grat_arp+0x100>
   else
     /* nope */
      arphdr->ar_op = ARREP;
 323e4e4:	e0fffb17 	ldw	r3,-20(fp)
 323e4e8:	00808004 	movi	r2,512
 323e4ec:	1880018d 	sth	r2,6(r3)
      
   arphdr->ar_tpa = net->n_ipaddr;        /* target's IP address */
 323e4f0:	e0bffd17 	ldw	r2,-12(fp)
 323e4f4:	10c00a17 	ldw	r3,40(r2)
 323e4f8:	e0bffb17 	ldw	r2,-20(fp)
 323e4fc:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = net->n_ipaddr;   /* my IP address */
 323e500:	e0bffd17 	ldw	r2,-12(fp)
 323e504:	10c00a17 	ldw	r3,40(r2)
 323e508:	e0bffb17 	ldw	r2,-20(fp)
 323e50c:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 323e510:	e0bffb17 	ldw	r2,-20(fp)
 323e514:	11000204 	addi	r4,r2,8
 323e518:	e0bffa17 	ldw	r2,-24(fp)
 323e51c:	11400517 	ldw	r5,20(r2)
 323e520:	01800184 	movi	r6,6
 323e524:	3206b700 	call	3206b70 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 323e528:	e0fffc17 	ldw	r3,-16(fp)
 323e52c:	00bfffc4 	movi	r2,-1
 323e530:	18800005 	stb	r2,0(r3)
 323e534:	00bfffc4 	movi	r2,-1
 323e538:	18800045 	stb	r2,1(r3)
 323e53c:	00bfffc4 	movi	r2,-1
 323e540:	18800085 	stb	r2,2(r3)
 323e544:	00bfffc4 	movi	r2,-1
 323e548:	188000c5 	stb	r2,3(r3)
 323e54c:	00bfffc4 	movi	r2,-1
 323e550:	18800105 	stb	r2,4(r3)
 323e554:	00bfffc4 	movi	r2,-1
 323e558:	18800145 	stb	r2,5(r3)
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 323e55c:	e0bffc17 	ldw	r2,-16(fp)
 323e560:	11000184 	addi	r4,r2,6
 323e564:	e0bffa17 	ldw	r2,-24(fp)
 323e568:	11400517 	ldw	r5,20(r2)
 323e56c:	01800184 	movi	r6,6
 323e570:	3206b700 	call	3206b70 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 323e574:	e0bffc17 	ldw	r2,-16(fp)
 323e578:	10c00304 	addi	r3,r2,12
 323e57c:	00800204 	movi	r2,8
 323e580:	18800005 	stb	r2,0(r3)
 323e584:	e0bffc17 	ldw	r2,-16(fp)
 323e588:	10c00344 	addi	r3,r2,13
 323e58c:	00800184 	movi	r2,6
 323e590:	18800005 	stb	r2,0(r3)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 323e594:	e0bffb17 	ldw	r2,-20(fp)
 323e598:	e0bff815 	stw	r2,-32(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 323e59c:	e0bff817 	ldw	r2,-32(fp)
 323e5a0:	11000204 	addi	r4,r2,8
 323e5a4:	e0bffb17 	ldw	r2,-20(fp)
 323e5a8:	11400204 	addi	r5,r2,8
 323e5ac:	01800184 	movi	r6,6
 323e5b0:	3206b700 	call	3206b70 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 323e5b4:	e0bff817 	ldw	r2,-32(fp)
 323e5b8:	10800204 	addi	r2,r2,8
 323e5bc:	11000184 	addi	r4,r2,6
 323e5c0:	e0bffb17 	ldw	r2,-20(fp)
 323e5c4:	11400404 	addi	r5,r2,16
 323e5c8:	01800104 	movi	r6,4
 323e5cc:	3206b700 	call	3206b70 <memmove>

   /* ARP req? */
   if (flag == 0)
 323e5d0:	e0bffe17 	ldw	r2,-8(fp)
 323e5d4:	1004c03a 	cmpne	r2,r2,zero
 323e5d8:	1000081e 	bne	r2,zero,323e5fc <grat_arp+0x20c>
      /* yup */      
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 323e5dc:	e0bff817 	ldw	r2,-32(fp)
 323e5e0:	10800204 	addi	r2,r2,8
 323e5e4:	11000284 	addi	r4,r2,10
 323e5e8:	e0bffb17 	ldw	r2,-20(fp)
 323e5ec:	11400504 	addi	r5,r2,20
 323e5f0:	01800184 	movi	r6,6
 323e5f4:	3206b700 	call	3206b70 <memmove>
 323e5f8:	00000706 	br	323e618 <grat_arp+0x228>
   else
      /* nope */
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_sha, 6);
 323e5fc:	e0bff817 	ldw	r2,-32(fp)
 323e600:	10800204 	addi	r2,r2,8
 323e604:	11000284 	addi	r4,r2,10
 323e608:	e0bffb17 	ldw	r2,-20(fp)
 323e60c:	11400204 	addi	r5,r2,8
 323e610:	01800184 	movi	r6,6
 323e614:	3206b700 	call	3206b70 <memmove>
      
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 323e618:	e0bff817 	ldw	r2,-32(fp)
 323e61c:	10800204 	addi	r2,r2,8
 323e620:	11000404 	addi	r4,r2,16
 323e624:	e0bffb17 	ldw	r2,-20(fp)
 323e628:	11400704 	addi	r5,r2,28
 323e62c:	01800104 	movi	r6,4
 323e630:	3206b700 	call	3206b70 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 323e634:	e0bffd17 	ldw	r2,-12(fp)
 323e638:	10800417 	ldw	r2,16(r2)
 323e63c:	1005003a 	cmpeq	r2,r2,zero
 323e640:	1000051e 	bne	r2,zero,323e658 <grat_arp+0x268>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 323e644:	e0bffd17 	ldw	r2,-12(fp)
 323e648:	10800417 	ldw	r2,16(r2)
 323e64c:	e13ff917 	ldw	r4,-28(fp)
 323e650:	103ee83a 	callr	r2
 323e654:	00000e06 	br	323e690 <grat_arp+0x2a0>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 323e658:	e0bffd17 	ldw	r2,-12(fp)
 323e65c:	10c00317 	ldw	r3,12(r2)
 323e660:	e0bff917 	ldw	r2,-28(fp)
 323e664:	11000617 	ldw	r4,24(r2)
 323e668:	e0bff917 	ldw	r2,-28(fp)
 323e66c:	11400117 	ldw	r5,4(r2)
 323e670:	01800c04 	movi	r6,48
 323e674:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 323e678:	01000084 	movi	r4,2
 323e67c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 323e680:	e13ff917 	ldw	r4,-28(fp)
 323e684:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323e688:	01000084 	movi	r4,2
 323e68c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 323e690:	d0a8f917 	ldw	r2,-23580(gp)
 323e694:	10800044 	addi	r2,r2,1
 323e698:	d0a8f915 	stw	r2,-23580(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 323e69c:	00800044 	movi	r2,1
 323e6a0:	e0bfff15 	stw	r2,-4(fp)
 323e6a4:	e0bfff17 	ldw	r2,-4(fp)
}
 323e6a8:	e037883a 	mov	sp,fp
 323e6ac:	dfc00117 	ldw	ra,4(sp)
 323e6b0:	df000017 	ldw	fp,0(sp)
 323e6b4:	dec00204 	addi	sp,sp,8
 323e6b8:	f800283a 	ret

0323e6bc <if_getbynum>:
 * RETURNS: Returns NET pointer, or NULL if out of range
 */

NET
if_getbynum(int ifnum)
{
 323e6bc:	defffb04 	addi	sp,sp,-20
 323e6c0:	dfc00415 	stw	ra,16(sp)
 323e6c4:	df000315 	stw	fp,12(sp)
 323e6c8:	df000304 	addi	fp,sp,12
 323e6cc:	e13ffe15 	stw	r4,-8(fp)
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 323e6d0:	0080c9b4 	movhi	r2,806
 323e6d4:	10b54604 	addi	r2,r2,-10984
 323e6d8:	10800017 	ldw	r2,0(r2)
 323e6dc:	e0bffd15 	stw	r2,-12(fp)
 323e6e0:	00000c06 	br	323e714 <if_getbynum+0x58>
   {
      if(ifnum-- == 0)
 323e6e4:	e0bffe17 	ldw	r2,-8(fp)
 323e6e8:	10bfffc4 	addi	r2,r2,-1
 323e6ec:	e0bffe15 	stw	r2,-8(fp)
 323e6f0:	e0bffe17 	ldw	r2,-8(fp)
 323e6f4:	10bfffd8 	cmpnei	r2,r2,-1
 323e6f8:	1000031e 	bne	r2,zero,323e708 <if_getbynum+0x4c>
         return ifp;
 323e6fc:	e0bffd17 	ldw	r2,-12(fp)
 323e700:	e0bfff15 	stw	r2,-4(fp)
 323e704:	00000806 	br	323e728 <if_getbynum+0x6c>

NET
if_getbynum(int ifnum)
{
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 323e708:	e0bffd17 	ldw	r2,-12(fp)
 323e70c:	10800017 	ldw	r2,0(r2)
 323e710:	e0bffd15 	stw	r2,-12(fp)
 323e714:	e0bffd17 	ldw	r2,-12(fp)
 323e718:	1004c03a 	cmpne	r2,r2,zero
 323e71c:	103ff11e 	bne	r2,zero,323e6e4 <if_getbynum+0x28>
   {
      if(ifnum-- == 0)
         return ifp;
   }
   dtrap();
 323e720:	322aef00 	call	322aef0 <dtrap>
   return NULL;   /* list is not long enough */
 323e724:	e03fff15 	stw	zero,-4(fp)
 323e728:	e0bfff17 	ldw	r2,-4(fp)
}
 323e72c:	e037883a 	mov	sp,fp
 323e730:	dfc00117 	ldw	ra,4(sp)
 323e734:	df000017 	ldw	fp,0(sp)
 323e738:	dec00204 	addi	sp,sp,8
 323e73c:	f800283a 	ret

0323e740 <isbcast>:
 * RETURNS:  Returns TRUE if broadcast, else false. 
 */

int
isbcast(NET ifc, unsigned char * addr)
{
 323e740:	defffc04 	addi	sp,sp,-16
 323e744:	df000315 	stw	fp,12(sp)
 323e748:	df000304 	addi	fp,sp,12
 323e74c:	e13ffd15 	stw	r4,-12(fp)
 323e750:	e17ffe15 	stw	r5,-8(fp)
#if (ALIGN_TYPE > 2)
   /* On systems with 32bit alignment requirements we have to make
    * sure our tests are aligned. Specifically, this results in "data
    * abort" errors on the Samsung/ARM port. 
    */
   if((u_long)addr & (ALIGN_TYPE - 1))
 323e754:	e0bffe17 	ldw	r2,-8(fp)
 323e758:	108000cc 	andi	r2,r2,3
 323e75c:	1005003a 	cmpeq	r2,r2,zero
 323e760:	10000e1e 	bne	r2,zero,323e79c <isbcast+0x5c>
   {
      /* check first two bytes */
      if ((u_short)*(u_short*)(addr) != 0xFFFF)
 323e764:	e0bffe17 	ldw	r2,-8(fp)
 323e768:	1080000b 	ldhu	r2,0(r2)
 323e76c:	10ffffcc 	andi	r3,r2,65535
 323e770:	00bfffd4 	movui	r2,65535
 323e774:	18800226 	beq	r3,r2,323e780 <isbcast+0x40>
         return(FALSE);
 323e778:	e03fff15 	stw	zero,-4(fp)
 323e77c:	00002306 	br	323e80c <isbcast+0xcc>
      if ((u_long)(*(u_long*)(addr + 2)) != 0xFFFFFFFF)
 323e780:	e0bffe17 	ldw	r2,-8(fp)
 323e784:	10800084 	addi	r2,r2,2
 323e788:	10800017 	ldw	r2,0(r2)
 323e78c:	10bfffe0 	cmpeqi	r2,r2,-1
 323e790:	1000101e 	bne	r2,zero,323e7d4 <isbcast+0x94>
         return FALSE;
 323e794:	e03fff15 	stw	zero,-4(fp)
 323e798:	00001c06 	br	323e80c <isbcast+0xcc>
#endif /* ALIGN_TYPE > 4 */
   {
      /* check first four bytes for all ones. Since this is the fastest
       * test, do it first
       */
      if ((u_long)(*(u_long*)addr) != 0xFFFFFFFF)
 323e79c:	e0bffe17 	ldw	r2,-8(fp)
 323e7a0:	10800017 	ldw	r2,0(r2)
 323e7a4:	10bfffe0 	cmpeqi	r2,r2,-1
 323e7a8:	1000021e 	bne	r2,zero,323e7b4 <isbcast+0x74>
         return FALSE;
 323e7ac:	e03fff15 	stw	zero,-4(fp)
 323e7b0:	00001606 	br	323e80c <isbcast+0xcc>

      /* check last two bytes */
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
 323e7b4:	e0bffe17 	ldw	r2,-8(fp)
 323e7b8:	10800104 	addi	r2,r2,4
 323e7bc:	1080000b 	ldhu	r2,0(r2)
 323e7c0:	10ffffcc 	andi	r3,r2,65535
 323e7c4:	00bfffd4 	movui	r2,65535
 323e7c8:	18800226 	beq	r3,r2,323e7d4 <isbcast+0x94>
         return(FALSE);
 323e7cc:	e03fff15 	stw	zero,-4(fp)
 323e7d0:	00000e06 	br	323e80c <isbcast+0xcc>
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 323e7d4:	e0bffd17 	ldw	r2,-12(fp)
 323e7d8:	10802717 	ldw	r2,156(r2)
 323e7dc:	10800217 	ldw	r2,8(r2)
 323e7e0:	108005e0 	cmpeqi	r2,r2,23
 323e7e4:	1000051e 	bne	r2,zero,323e7fc <isbcast+0xbc>
 323e7e8:	e0bffd17 	ldw	r2,-12(fp)
 323e7ec:	10802717 	ldw	r2,156(r2)
 323e7f0:	10800217 	ldw	r2,8(r2)
 323e7f4:	10800718 	cmpnei	r2,r2,28
 323e7f8:	1000021e 	bne	r2,zero,323e804 <isbcast+0xc4>
       (ifc->n_mib->ifType == SLIP))
   {
      return FALSE;
 323e7fc:	e03fff15 	stw	zero,-4(fp)
 323e800:	00000206 	br	323e80c <isbcast+0xcc>
   }

   /* passed all tests, must be broadcast */
   return(TRUE);
 323e804:	00800044 	movi	r2,1
 323e808:	e0bfff15 	stw	r2,-4(fp)
 323e80c:	e0bfff17 	ldw	r2,-4(fp)
}
 323e810:	e037883a 	mov	sp,fp
 323e814:	df000017 	ldw	fp,0(sp)
 323e818:	dec00104 	addi	sp,sp,4
 323e81c:	f800283a 	ret

0323e820 <reg_type>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
reg_type(unshort type)
{
 323e820:	defffa04 	addi	sp,sp,-24
 323e824:	dfc00515 	stw	ra,20(sp)
 323e828:	df000415 	stw	fp,16(sp)
 323e82c:	df000404 	addi	fp,sp,16
 323e830:	e13ffe0d 	sth	r4,-8(fp)
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 323e834:	0080c9b4 	movhi	r2,806
 323e838:	10b54604 	addi	r2,r2,-10984
 323e83c:	10800017 	ldw	r2,0(r2)
 323e840:	e0bffd15 	stw	r2,-12(fp)
 323e844:	00001306 	br	323e894 <reg_type+0x74>
   {
      if (ifp->n_reg_type)    /* make sure call exists */
 323e848:	e0bffd17 	ldw	r2,-12(fp)
 323e84c:	10800617 	ldw	r2,24(r2)
 323e850:	1005003a 	cmpeq	r2,r2,zero
 323e854:	10000c1e 	bne	r2,zero,323e888 <reg_type+0x68>
      {
         e = (ifp->n_reg_type)(type, ifp);
 323e858:	e0bffd17 	ldw	r2,-12(fp)
 323e85c:	10800617 	ldw	r2,24(r2)
 323e860:	e13ffe0b 	ldhu	r4,-8(fp)
 323e864:	e17ffd17 	ldw	r5,-12(fp)
 323e868:	103ee83a 	callr	r2
 323e86c:	e0bffc15 	stw	r2,-16(fp)
         if (e)
 323e870:	e0bffc17 	ldw	r2,-16(fp)
 323e874:	1005003a 	cmpeq	r2,r2,zero
 323e878:	1000031e 	bne	r2,zero,323e888 <reg_type+0x68>
            return e;   /* bails out if error */
 323e87c:	e0bffc17 	ldw	r2,-16(fp)
 323e880:	e0bfff15 	stw	r2,-4(fp)
 323e884:	00000706 	br	323e8a4 <reg_type+0x84>
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 323e888:	e0bffd17 	ldw	r2,-12(fp)
 323e88c:	10800017 	ldw	r2,0(r2)
 323e890:	e0bffd15 	stw	r2,-12(fp)
 323e894:	e0bffd17 	ldw	r2,-12(fp)
 323e898:	1004c03a 	cmpne	r2,r2,zero
 323e89c:	103fea1e 	bne	r2,zero,323e848 <reg_type+0x28>
         e = (ifp->n_reg_type)(type, ifp);
         if (e)
            return e;   /* bails out if error */
      }
   }
   return 0;   /* OK code */
 323e8a0:	e03fff15 	stw	zero,-4(fp)
 323e8a4:	e0bfff17 	ldw	r2,-4(fp)
}
 323e8a8:	e037883a 	mov	sp,fp
 323e8ac:	dfc00117 	ldw	ra,4(sp)
 323e8b0:	df000017 	ldw	fp,0(sp)
 323e8b4:	dec00204 	addi	sp,sp,8
 323e8b8:	f800283a 	ret

0323e8bc <if_killsocks>:
 */

      /* kill this NETs sockets */
void
if_killsocks(NET ifp)
{
 323e8bc:	defffa04 	addi	sp,sp,-24
 323e8c0:	dfc00515 	stw	ra,20(sp)
 323e8c4:	df000415 	stw	fp,16(sp)
 323e8c8:	df000404 	addi	fp,sp,16
 323e8cc:	e13fff15 	stw	r4,-4(fp)
   struct socket * so;
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
 323e8d0:	0080c9b4 	movhi	r2,806
 323e8d4:	10b48204 	addi	r2,r2,-11768
 323e8d8:	10800017 	ldw	r2,0(r2)
 323e8dc:	e0bffe15 	stw	r2,-8(fp)
   while(so)
 323e8e0:	00001406 	br	323e934 <if_killsocks+0x78>
   {
      if(so->so_pcb)
 323e8e4:	e0bffe17 	ldw	r2,-8(fp)
 323e8e8:	10800117 	ldw	r2,4(r2)
 323e8ec:	1005003a 	cmpeq	r2,r2,zero
 323e8f0:	1000051e 	bne	r2,zero,323e908 <if_killsocks+0x4c>
         so_ifp = so->so_pcb->ifp;
 323e8f4:	e0bffe17 	ldw	r2,-8(fp)
 323e8f8:	10800117 	ldw	r2,4(r2)
 323e8fc:	10800a17 	ldw	r2,40(r2)
 323e900:	e0bffc15 	stw	r2,-16(fp)
 323e904:	00000106 	br	323e90c <if_killsocks+0x50>
      else
         so_ifp = NULL;
 323e908:	e03ffc15 	stw	zero,-16(fp)
      next = (struct socket *)so->next;
 323e90c:	e0bffe17 	ldw	r2,-8(fp)
 323e910:	10800017 	ldw	r2,0(r2)
 323e914:	e0bffd15 	stw	r2,-12(fp)
      if (so_ifp == ifp)
 323e918:	e0fffc17 	ldw	r3,-16(fp)
 323e91c:	e0bfff17 	ldw	r2,-4(fp)
 323e920:	1880021e 	bne	r3,r2,323e92c <if_killsocks+0x70>
      {
         /* this is a direct heavy-handed close. A reset is sent
          * and all data is lost. The user should really have closed
          * all the sockets gracfully first.... 
          */
         soabort(so);
 323e924:	e13ffe17 	ldw	r4,-8(fp)
 323e928:	322fe600 	call	322fe60 <soabort>
      }
      so = next;
 323e92c:	e0bffd17 	ldw	r2,-12(fp)
 323e930:	e0bffe15 	stw	r2,-8(fp)
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
   while(so)
 323e934:	e0bffe17 	ldw	r2,-8(fp)
 323e938:	1004c03a 	cmpne	r2,r2,zero
 323e93c:	103fe91e 	bne	r2,zero,323e8e4 <if_killsocks+0x28>
          */
         soabort(so);
      }
      so = next;
   }
}
 323e940:	e037883a 	mov	sp,fp
 323e944:	dfc00117 	ldw	ra,4(sp)
 323e948:	df000017 	ldw	fp,0(sp)
 323e94c:	dec00204 	addi	sp,sp,8
 323e950:	f800283a 	ret

0323e954 <ip_init>:
 * OK, else returns a non-zero error code. 
 */

int
ip_init(void)
{
 323e954:	defffd04 	addi	sp,sp,-12
 323e958:	dfc00215 	stw	ra,8(sp)
 323e95c:	df000115 	stw	fp,4(sp)
 323e960:	df000104 	addi	fp,sp,4

   /* register IP type with link layer drivers */
   if (reg_type(IP_TYPE) != 0)
 323e964:	01000204 	movi	r4,8
 323e968:	323e8200 	call	323e820 <reg_type>
 323e96c:	1005003a 	cmpeq	r2,r2,zero
 323e970:	1000061e 	bne	r2,zero,323e98c <ip_init+0x38>
   {   
#ifdef NPDEBUG
      dprintf("IP_INIT: unable to register type with MAC driver\n");
 323e974:	0100c974 	movhi	r4,805
 323e978:	213f1804 	addi	r4,r4,-928
 323e97c:	32071080 	call	3207108 <puts>
#endif
      return(1);
 323e980:	00800044 	movi	r2,1
 323e984:	e0bfff15 	stw	r2,-4(fp)
 323e988:	00002b06 	br	323ea38 <ip_init+0xe4>
   }

   /* initialize the IP mib */
   MEMSET(&ip_mib, 0, sizeof(ip_mib));
 323e98c:	0080c9b4 	movhi	r2,806
 323e990:	10b54b04 	addi	r2,r2,-10964
 323e994:	1009883a 	mov	r4,r2
 323e998:	01801404 	movi	r6,80
 323e99c:	000b883a 	mov	r5,zero
 323e9a0:	3206c500 	call	3206c50 <memset>
   ip_mib.ipForwarding = 2;   /* default to host, not gateway (router) */
 323e9a4:	00c0c9b4 	movhi	r3,806
 323e9a8:	18f54b04 	addi	r3,r3,-10964
 323e9ac:	00800084 	movi	r2,2
 323e9b0:	18800015 	stw	r2,0(r3)
   ip_mib.ipDefaultTTL = IP_TTL;
 323e9b4:	00c0c9b4 	movhi	r3,806
 323e9b8:	18f54b04 	addi	r3,r3,-10964
 323e9bc:	00801004 	movi	r2,64
 323e9c0:	18800115 	stw	r2,4(r3)

#ifdef IP_ROUTING
   /* alloc space for the route table */
   rt_mib = (struct RtMib*)RT_ALLOC(ipRoutes * sizeof(struct RtMib));
 323e9c4:	d0a04d17 	ldw	r2,-32460(gp)
 323e9c8:	11000f24 	muli	r4,r2,60
 323e9cc:	322b9340 	call	322b934 <npalloc>
 323e9d0:	d0a8fd15 	stw	r2,-23564(gp)
   if (!rt_mib)
 323e9d4:	d0a8fd17 	ldw	r2,-23564(gp)
 323e9d8:	1004c03a 	cmpne	r2,r2,zero
 323e9dc:	1000061e 	bne	r2,zero,323e9f8 <ip_init+0xa4>
   {
#ifdef NPDEBUG
      dprintf("IP_INIT ERROR: can't alloc route table\n");
 323e9e0:	0100c974 	movhi	r4,805
 323e9e4:	213f2504 	addi	r4,r4,-876
 323e9e8:	32071080 	call	3207108 <puts>
#endif   /* NPDEBUG */
      return(ENP_NOMEM);
 323e9ec:	00bffb04 	movi	r2,-20
 323e9f0:	e0bfff15 	stw	r2,-4(fp)
 323e9f4:	00001006 	br	323ea38 <ip_init+0xe4>
   }

  MEMSET(rt_mib,0, ipRoutes * sizeof(struct RtMib)) ;
 323e9f8:	d0e8fd17 	ldw	r3,-23564(gp)
 323e9fc:	d0a04d17 	ldw	r2,-32460(gp)
 323ea00:	10800f24 	muli	r2,r2,60
 323ea04:	1809883a 	mov	r4,r3
 323ea08:	100d883a 	mov	r6,r2
 323ea0c:	000b883a 	mov	r5,zero
 323ea10:	3206c500 	call	3206c50 <memset>
  ip_mib.ipForwarding = 1;   /* override default, be gateway (router) */
 323ea14:	00c0c9b4 	movhi	r3,806
 323ea18:	18f54b04 	addi	r3,r3,-10964
 323ea1c:	00800044 	movi	r2,1
 323ea20:	18800015 	stw	r2,0(r3)
#endif   /* IP_ROUTING */

   /* set IP reassembly timeout */
   ip_mib.ipReasmTimeout = IRE_TMO;
 323ea24:	00c0c9b4 	movhi	r3,806
 323ea28:	18f54b04 	addi	r3,r3,-10964
 323ea2c:	00801e04 	movi	r2,120
 323ea30:	18800c15 	stw	r2,48(r3)
      return(1);
   }
#endif   /* IPSEC */

   /* everything opened OK return 0 */
   return(SUCCESS);
 323ea34:	e03fff15 	stw	zero,-4(fp)
 323ea38:	e0bfff17 	ldw	r2,-4(fp)
}
 323ea3c:	e037883a 	mov	sp,fp
 323ea40:	dfc00117 	ldw	ra,4(sp)
 323ea44:	df000017 	ldw	fp,0(sp)
 323ea48:	dec00204 	addi	sp,sp,8
 323ea4c:	f800283a 	ret

0323ea50 <ip_bldhead>:
 * RETURNS: void
 */

void
ip_bldhead(PACKET p, unsigned pid, u_char prot, unshort fragword)
{
 323ea50:	defff804 	addi	sp,sp,-32
 323ea54:	dfc00715 	stw	ra,28(sp)
 323ea58:	df000615 	stw	fp,24(sp)
 323ea5c:	df000604 	addi	fp,sp,24
 323ea60:	e13ffc15 	stw	r4,-16(fp)
 323ea64:	e17ffd15 	stw	r5,-12(fp)
 323ea68:	e1bffe05 	stb	r6,-8(fp)
 323ea6c:	e1ffff0d 	sth	r7,-4(fp)
   struct ip * pip;
   struct ip_socopts *sopts;

   /* prepend IP header to packet data */
   p->nb_prot -= sizeof(struct ip);       /* this assumes no send options! */
 323ea70:	e0bffc17 	ldw	r2,-16(fp)
 323ea74:	10800317 	ldw	r2,12(r2)
 323ea78:	10fffb04 	addi	r3,r2,-20
 323ea7c:	e0bffc17 	ldw	r2,-16(fp)
 323ea80:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 323ea84:	e0bffc17 	ldw	r2,-16(fp)
 323ea88:	10800417 	ldw	r2,16(r2)
 323ea8c:	10c00504 	addi	r3,r2,20
 323ea90:	e0bffc17 	ldw	r2,-16(fp)
 323ea94:	10c00415 	stw	r3,16(r2)

   pip = (struct ip*)p->nb_prot;
 323ea98:	e0bffc17 	ldw	r2,-16(fp)
 323ea9c:	10800317 	ldw	r2,12(r2)
 323eaa0:	e0bffb15 	stw	r2,-20(fp)

   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 323eaa4:	e0fffb17 	ldw	r3,-20(fp)
 323eaa8:	00801144 	movi	r2,69
 323eaac:	18800005 	stb	r2,0(r3)
   pip->ip_flgs_foff = fragword; /* fragment flags and offset */
 323eab0:	e0fffb17 	ldw	r3,-20(fp)
 323eab4:	e0bfff0b 	ldhu	r2,-4(fp)
 323eab8:	1880018d 	sth	r2,6(r3)
   pip->ip_id = htons((unshort)pid);   /* IP datagram ID */
 323eabc:	e0bffd17 	ldw	r2,-12(fp)
 323eac0:	10bfffcc 	andi	r2,r2,65535
 323eac4:	1004d23a 	srli	r2,r2,8
 323eac8:	10803fcc 	andi	r2,r2,255
 323eacc:	1009883a 	mov	r4,r2
 323ead0:	e0bffd17 	ldw	r2,-12(fp)
 323ead4:	10bfffcc 	andi	r2,r2,65535
 323ead8:	1004923a 	slli	r2,r2,8
 323eadc:	1007883a 	mov	r3,r2
 323eae0:	00bfc004 	movi	r2,-256
 323eae4:	1884703a 	and	r2,r3,r2
 323eae8:	2084b03a 	or	r2,r4,r2
 323eaec:	1007883a 	mov	r3,r2
 323eaf0:	e0bffb17 	ldw	r2,-20(fp)
 323eaf4:	10c0010d 	sth	r3,4(r2)
   pip->ip_len = htons((unshort)p->nb_plen);
 323eaf8:	e0bffc17 	ldw	r2,-16(fp)
 323eafc:	10800417 	ldw	r2,16(r2)
 323eb00:	10bfffcc 	andi	r2,r2,65535
 323eb04:	1004d23a 	srli	r2,r2,8
 323eb08:	10803fcc 	andi	r2,r2,255
 323eb0c:	1009883a 	mov	r4,r2
 323eb10:	e0bffc17 	ldw	r2,-16(fp)
 323eb14:	10800417 	ldw	r2,16(r2)
 323eb18:	10bfffcc 	andi	r2,r2,65535
 323eb1c:	1004923a 	slli	r2,r2,8
 323eb20:	1007883a 	mov	r3,r2
 323eb24:	00bfc004 	movi	r2,-256
 323eb28:	1884703a 	and	r2,r3,r2
 323eb2c:	2084b03a 	or	r2,r4,r2
 323eb30:	1007883a 	mov	r3,r2
 323eb34:	e0bffb17 	ldw	r2,-20(fp)
 323eb38:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;          /* install protocol ID (TCP, UDP, etc) */
 323eb3c:	e0fffb17 	ldw	r3,-20(fp)
 323eb40:	e0bffe03 	ldbu	r2,-8(fp)
 323eb44:	18800245 	stb	r2,9(r3)

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 323eb48:	e0bffc17 	ldw	r2,-16(fp)
 323eb4c:	10800c17 	ldw	r2,48(r2)
 323eb50:	e0bffa15 	stw	r2,-24(fp)
 323eb54:	e0bffa17 	ldw	r2,-24(fp)
 323eb58:	1005003a 	cmpeq	r2,r2,zero
 323eb5c:	1000121e 	bne	r2,zero,323eba8 <ip_bldhead+0x158>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 323eb60:	e0bffa17 	ldw	r2,-24(fp)
 323eb64:	10800043 	ldbu	r2,1(r2)
 323eb68:	10803fcc 	andi	r2,r2,255
 323eb6c:	1005003a 	cmpeq	r2,r2,zero
 323eb70:	1000051e 	bne	r2,zero,323eb88 <ip_bldhead+0x138>
         pip->ip_time = sopts->ip_ttl;
 323eb74:	e0bffa17 	ldw	r2,-24(fp)
 323eb78:	10c00043 	ldbu	r3,1(r2)
 323eb7c:	e0bffb17 	ldw	r2,-20(fp)
 323eb80:	10c00205 	stb	r3,8(r2)
 323eb84:	00000306 	br	323eb94 <ip_bldhead+0x144>
	  else
         pip->ip_time = (u_char)IP_TTL;     /* default number of hops, really */
 323eb88:	e0fffb17 	ldw	r3,-20(fp)
 323eb8c:	00801004 	movi	r2,64
 323eb90:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 323eb94:	e0bffa17 	ldw	r2,-24(fp)
 323eb98:	10c00003 	ldbu	r3,0(r2)
 323eb9c:	e0bffb17 	ldw	r2,-20(fp)
 323eba0:	10c00045 	stb	r3,1(r2)
 323eba4:	00000506 	br	323ebbc <ip_bldhead+0x16c>
   }
   else
   {
	  /* nope */
      pip->ip_time = (u_char)IP_TTL;       /* default number of hops, really */
 323eba8:	e0bffb17 	ldw	r2,-20(fp)
 323ebac:	00c01004 	movi	r3,64
 323ebb0:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 323ebb4:	e0bffb17 	ldw	r2,-20(fp)
 323ebb8:	10000045 	stb	zero,1(r2)
   }
   
   pip->ip_chksum = IPXSUM;      /* clear checksum field for summing */
 323ebbc:	e0bffb17 	ldw	r2,-20(fp)
 323ebc0:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 323ebc4:	e13ffb17 	ldw	r4,-20(fp)
 323ebc8:	01400284 	movi	r5,10
 323ebcc:	3225d5c0 	call	3225d5c <cksum>
 323ebd0:	0084303a 	nor	r2,zero,r2
 323ebd4:	1007883a 	mov	r3,r2
 323ebd8:	e0bffb17 	ldw	r2,-20(fp)
 323ebdc:	10c0028d 	sth	r3,10(r2)
}
 323ebe0:	e037883a 	mov	sp,fp
 323ebe4:	dfc00117 	ldw	ra,4(sp)
 323ebe8:	df000017 	ldw	fp,0(sp)
 323ebec:	dec00204 	addi	sp,sp,8
 323ebf0:	f800283a 	ret

0323ebf4 <ip_write_internal>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_write_internal(PACKET p)
{
 323ebf4:	deffed04 	addi	sp,sp,-76
 323ebf8:	dfc01215 	stw	ra,72(sp)
 323ebfc:	df001115 	stw	fp,68(sp)
 323ec00:	df001104 	addi	fp,sp,68
 323ec04:	e13ffc15 	stw	r4,-16(fp)
   PACKET newpkt;
   unsigned maxbuflen;

#ifdef IP_MULTICAST
   /* If destination address is multicast, process multicast options */
   if (IN_MULTICAST(ntohl(p->fhost)))
 323ec08:	e0bffc17 	ldw	r2,-16(fp)
 323ec0c:	10800717 	ldw	r2,28(r2)
 323ec10:	1004d63a 	srli	r2,r2,24
 323ec14:	10c03fcc 	andi	r3,r2,255
 323ec18:	e0bffc17 	ldw	r2,-16(fp)
 323ec1c:	10800717 	ldw	r2,28(r2)
 323ec20:	1004d23a 	srli	r2,r2,8
 323ec24:	10bfc00c 	andi	r2,r2,65280
 323ec28:	1886b03a 	or	r3,r3,r2
 323ec2c:	e0bffc17 	ldw	r2,-16(fp)
 323ec30:	10800717 	ldw	r2,28(r2)
 323ec34:	10bfc00c 	andi	r2,r2,65280
 323ec38:	1004923a 	slli	r2,r2,8
 323ec3c:	1886b03a 	or	r3,r3,r2
 323ec40:	e0bffc17 	ldw	r2,-16(fp)
 323ec44:	10800717 	ldw	r2,28(r2)
 323ec48:	10803fcc 	andi	r2,r2,255
 323ec4c:	1004963a 	slli	r2,r2,24
 323ec50:	1884b03a 	or	r2,r3,r2
 323ec54:	10fc002c 	andhi	r3,r2,61440
 323ec58:	00b80034 	movhi	r2,57344
 323ec5c:	1880b31e 	bne	r3,r2,323ef2c <ip_write_internal+0x338>
   {
      if (p->imo != NULL)
 323ec60:	e0bffc17 	ldw	r2,-16(fp)
 323ec64:	10800b17 	ldw	r2,44(r2)
 323ec68:	1005003a 	cmpeq	r2,r2,zero
 323ec6c:	1000131e 	bne	r2,zero,323ecbc <ip_write_internal+0xc8>
         if (p->imo->imo_multicast_netp)
 323ec70:	e0bffc17 	ldw	r2,-16(fp)
 323ec74:	10800b17 	ldw	r2,44(r2)
 323ec78:	10800017 	ldw	r2,0(r2)
 323ec7c:	1005003a 	cmpeq	r2,r2,zero
 323ec80:	1000061e 	bne	r2,zero,323ec9c <ip_write_internal+0xa8>
            p->net = p->imo->imo_multicast_netp;
 323ec84:	e0bffc17 	ldw	r2,-16(fp)
 323ec88:	10800b17 	ldw	r2,44(r2)
 323ec8c:	10c00017 	ldw	r3,0(r2)
 323ec90:	e0bffc17 	ldw	r2,-16(fp)
 323ec94:	10c00615 	stw	r3,24(r2)
 323ec98:	00002606 	br	323ed34 <ip_write_internal+0x140>
         else
            p->net = iproute(p->fhost, &firsthop);
 323ec9c:	e0bffc17 	ldw	r2,-16(fp)
 323eca0:	11000717 	ldw	r4,28(r2)
 323eca4:	e17ffb04 	addi	r5,fp,-20
 323eca8:	32408540 	call	3240854 <iproute>
 323ecac:	1007883a 	mov	r3,r2
 323ecb0:	e0bffc17 	ldw	r2,-16(fp)
 323ecb4:	10c00615 	stw	r3,24(r2)
 323ecb8:	00001e06 	br	323ed34 <ip_write_internal+0x140>
      else
      {
         for (i = 0; i < ifNumber; i++)
 323ecbc:	e03ff815 	stw	zero,-32(fp)
 323ecc0:	00001706 	br	323ed20 <ip_write_internal+0x12c>
            if (nets[i]->n_mcastlist)
 323ecc4:	e0bff817 	ldw	r2,-32(fp)
 323ecc8:	00c0c9b4 	movhi	r3,806
 323eccc:	18f34504 	addi	r3,r3,-13036
 323ecd0:	1085883a 	add	r2,r2,r2
 323ecd4:	1085883a 	add	r2,r2,r2
 323ecd8:	10c5883a 	add	r2,r2,r3
 323ecdc:	10800017 	ldw	r2,0(r2)
 323ece0:	10802b17 	ldw	r2,172(r2)
 323ece4:	1005003a 	cmpeq	r2,r2,zero
 323ece8:	10000a1e 	bne	r2,zero,323ed14 <ip_write_internal+0x120>
            {
               p->net = nets[i];
 323ecec:	e0bff817 	ldw	r2,-32(fp)
 323ecf0:	00c0c9b4 	movhi	r3,806
 323ecf4:	18f34504 	addi	r3,r3,-13036
 323ecf8:	1085883a 	add	r2,r2,r2
 323ecfc:	1085883a 	add	r2,r2,r2
 323ed00:	10c5883a 	add	r2,r2,r3
 323ed04:	10c00017 	ldw	r3,0(r2)
 323ed08:	e0bffc17 	ldw	r2,-16(fp)
 323ed0c:	10c00615 	stw	r3,24(r2)
               break;
 323ed10:	00000806 	br	323ed34 <ip_write_internal+0x140>
            p->net = p->imo->imo_multicast_netp;
         else
            p->net = iproute(p->fhost, &firsthop);
      else
      {
         for (i = 0; i < ifNumber; i++)
 323ed14:	e0bff817 	ldw	r2,-32(fp)
 323ed18:	10800044 	addi	r2,r2,1
 323ed1c:	e0bff815 	stw	r2,-32(fp)
 323ed20:	0080c974 	movhi	r2,805
 323ed24:	10931d04 	addi	r2,r2,19572
 323ed28:	10c00017 	ldw	r3,0(r2)
 323ed2c:	e0bff817 	ldw	r2,-32(fp)
 323ed30:	10ffe436 	bltu	r2,r3,323ecc4 <ip_write_internal+0xd0>
               break;
            }
      }

      /* Confirm that the outgoing interface supports multicast. */
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
 323ed34:	e0bffc17 	ldw	r2,-16(fp)
 323ed38:	10800617 	ldw	r2,24(r2)
 323ed3c:	1005003a 	cmpeq	r2,r2,zero
 323ed40:	1000051e 	bne	r2,zero,323ed58 <ip_write_internal+0x164>
 323ed44:	e0bffc17 	ldw	r2,-16(fp)
 323ed48:	10800617 	ldw	r2,24(r2)
 323ed4c:	10802b17 	ldw	r2,172(r2)
 323ed50:	1004c03a 	cmpne	r2,r2,zero
 323ed54:	10002e1e 	bne	r2,zero,323ee10 <ip_write_internal+0x21c>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 323ed58:	0080c974 	movhi	r2,805
 323ed5c:	10931c04 	addi	r2,r2,19568
 323ed60:	10800017 	ldw	r2,0(r2)
 323ed64:	1080840c 	andi	r2,r2,528
 323ed68:	1005003a 	cmpeq	r2,r2,zero
 323ed6c:	1000181e 	bne	r2,zero,323edd0 <ip_write_internal+0x1dc>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 323ed70:	e0bffc17 	ldw	r2,-16(fp)
 323ed74:	11800417 	ldw	r6,16(r2)
 323ed78:	e0bffc17 	ldw	r2,-16(fp)
 323ed7c:	10800717 	ldw	r2,28(r2)
 323ed80:	11c03fcc 	andi	r7,r2,255
 323ed84:	e0bffc17 	ldw	r2,-16(fp)
 323ed88:	10800717 	ldw	r2,28(r2)
 323ed8c:	1004d23a 	srli	r2,r2,8
 323ed90:	11003fcc 	andi	r4,r2,255
 323ed94:	e0bffc17 	ldw	r2,-16(fp)
 323ed98:	10800717 	ldw	r2,28(r2)
 323ed9c:	1004d43a 	srli	r2,r2,16
 323eda0:	10c03fcc 	andi	r3,r2,255
 323eda4:	e0bffc17 	ldw	r2,-16(fp)
 323eda8:	10800717 	ldw	r2,28(r2)
 323edac:	1004d63a 	srli	r2,r2,24
 323edb0:	d9000015 	stw	r4,0(sp)
 323edb4:	d8c00115 	stw	r3,4(sp)
 323edb8:	d8800215 	stw	r2,8(sp)
 323edbc:	0100c974 	movhi	r4,805
 323edc0:	213f2f04 	addi	r4,r4,-836
 323edc4:	e17ffc17 	ldw	r5,-16(fp)
 323edc8:	3206de00 	call	3206de0 <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 323edcc:	322aef00 	call	322aef0 <dtrap>
         }
#endif
         ip_mib.ipOutNoRoutes++;
 323edd0:	0080c9b4 	movhi	r2,806
 323edd4:	10b54b04 	addi	r2,r2,-10964
 323edd8:	10800b17 	ldw	r2,44(r2)
 323eddc:	10c00044 	addi	r3,r2,1
 323ede0:	0080c9b4 	movhi	r2,806
 323ede4:	10b54b04 	addi	r2,r2,-10964
 323ede8:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 323edec:	01000084 	movi	r4,2
 323edf0:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pk_free(p);
 323edf4:	e13ffc17 	ldw	r4,-16(fp)
 323edf8:	322a6400 	call	322a640 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323edfc:	01000084 	movi	r4,2
 323ee00:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 323ee04:	00bff7c4 	movi	r2,-33
 323ee08:	e0bffd15 	stw	r2,-12(fp)
 323ee0c:	00015306 	br	323f35c <ip_write_internal+0x768>
       * If we belong to the destination multicast group
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
 323ee10:	e0bffc17 	ldw	r2,-16(fp)
 323ee14:	11000717 	ldw	r4,28(r2)
 323ee18:	e0bffc17 	ldw	r2,-16(fp)
 323ee1c:	11400617 	ldw	r5,24(r2)
 323ee20:	3243a500 	call	3243a50 <lookup_mcast>
 323ee24:	e0bff915 	stw	r2,-28(fp)
      if ((inm != NULL) &&
 323ee28:	e0bff917 	ldw	r2,-28(fp)
 323ee2c:	1005003a 	cmpeq	r2,r2,zero
 323ee30:	10001f1e 	bne	r2,zero,323eeb0 <ip_write_internal+0x2bc>
 323ee34:	e0bffc17 	ldw	r2,-16(fp)
 323ee38:	10800b17 	ldw	r2,44(r2)
 323ee3c:	1005003a 	cmpeq	r2,r2,zero
 323ee40:	1000061e 	bne	r2,zero,323ee5c <ip_write_internal+0x268>
 323ee44:	e0bffc17 	ldw	r2,-16(fp)
 323ee48:	10800b17 	ldw	r2,44(r2)
 323ee4c:	10800143 	ldbu	r2,5(r2)
 323ee50:	10803fcc 	andi	r2,r2,255
 323ee54:	1005003a 	cmpeq	r2,r2,zero
 323ee58:	1000151e 	bne	r2,zero,323eeb0 <ip_write_internal+0x2bc>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
      {
         p->type = IPTP;
 323ee5c:	e0fffc17 	ldw	r3,-16(fp)
 323ee60:	00800204 	movi	r2,8
 323ee64:	1880080d 	sth	r2,32(r3)
         pkt2 = ip_copypkt(p);
 323ee68:	e13ffc17 	ldw	r4,-16(fp)
 323ee6c:	3240ac00 	call	3240ac0 <ip_copypkt>
 323ee70:	e0bffa15 	stw	r2,-24(fp)
         if (pkt2)
 323ee74:	e0bffa17 	ldw	r2,-24(fp)
 323ee78:	1005003a 	cmpeq	r2,r2,zero
 323ee7c:	10000c1e 	bne	r2,zero,323eeb0 <ip_write_internal+0x2bc>
         {
            LOCK_NET_RESOURCE(RXQ_RESID);
 323ee80:	01000044 	movi	r4,1
 323ee84:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
            putq(&rcvdq, (q_elt)pkt2);
 323ee88:	e17ffa17 	ldw	r5,-24(fp)
 323ee8c:	0100c9b4 	movhi	r4,806
 323ee90:	21328004 	addi	r4,r4,-13824
 323ee94:	322a8800 	call	322a880 <putq>
            UNLOCK_NET_RESOURCE(RXQ_RESID);
 323ee98:	01000044 	movi	r4,1
 323ee9c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
            SignalPktDemux();
 323eea0:	0080c974 	movhi	r2,805
 323eea4:	10934404 	addi	r2,r2,19728
 323eea8:	11000017 	ldw	r4,0(r2)
 323eeac:	321b4e00 	call	321b4e0 <OSSemPost>
       * Also, multicasts addressed to the loopback interface
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
 323eeb0:	e0bffc17 	ldw	r2,-16(fp)
 323eeb4:	10800317 	ldw	r2,12(r2)
 323eeb8:	e0bff715 	stw	r2,-36(fp)
      if ((pip->ip_time == 0) || 
 323eebc:	e0bff717 	ldw	r2,-36(fp)
 323eec0:	10800203 	ldbu	r2,8(r2)
 323eec4:	10803fcc 	andi	r2,r2,255
 323eec8:	1005003a 	cmpeq	r2,r2,zero
 323eecc:	10000b1e 	bne	r2,zero,323eefc <ip_write_internal+0x308>
 323eed0:	e0bffc17 	ldw	r2,-16(fp)
 323eed4:	10800717 	ldw	r2,28(r2)
 323eed8:	10803fcc 	andi	r2,r2,255
 323eedc:	10801fe0 	cmpeqi	r2,r2,127
 323eee0:	1000061e 	bne	r2,zero,323eefc <ip_write_internal+0x308>
 323eee4:	e0bffc17 	ldw	r2,-16(fp)
 323eee8:	10c00717 	ldw	r3,28(r2)
 323eeec:	e0bffc17 	ldw	r2,-16(fp)
 323eef0:	10800617 	ldw	r2,24(r2)
 323eef4:	10800a17 	ldw	r2,40(r2)
 323eef8:	1880081e 	bne	r3,r2,323ef1c <ip_write_internal+0x328>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
          (p->fhost == p->net->n_ipaddr))
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 323eefc:	01000084 	movi	r4,2
 323ef00:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pk_free(p);
 323ef04:	e13ffc17 	ldw	r4,-16(fp)
 323ef08:	322a6400 	call	322a640 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323ef0c:	01000084 	movi	r4,2
 323ef10:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return(SUCCESS);
 323ef14:	e03ffd15 	stw	zero,-12(fp)
 323ef18:	00011006 	br	323f35c <ip_write_internal+0x768>
      }

      firsthop = p->fhost;
 323ef1c:	e0bffc17 	ldw	r2,-16(fp)
 323ef20:	10800717 	ldw	r2,28(r2)
 323ef24:	e0bffb15 	stw	r2,-20(fp)

      goto sendit;
 323ef28:	00004106 	br	323f030 <ip_write_internal+0x43c>
   }

#endif /* IP_MULTICAST */

   /* if this is a broadcast packet, use the caller-selected network */
   if (p->fhost == 0xFFFFFFFF)
 323ef2c:	e0bffc17 	ldw	r2,-16(fp)
 323ef30:	10800717 	ldw	r2,28(r2)
 323ef34:	10bfffd8 	cmpnei	r2,r2,-1
 323ef38:	1000041e 	bne	r2,zero,323ef4c <ip_write_internal+0x358>
   {
      firsthop = p->fhost;
 323ef3c:	e0bffc17 	ldw	r2,-16(fp)
 323ef40:	10800717 	ldw	r2,28(r2)
 323ef44:	e0bffb15 	stw	r2,-20(fp)
 323ef48:	00003906 	br	323f030 <ip_write_internal+0x43c>
   }
   else
   {
      p->net = iproute(p->fhost, &firsthop);
 323ef4c:	e0bffc17 	ldw	r2,-16(fp)
 323ef50:	11000717 	ldw	r4,28(r2)
 323ef54:	e17ffb04 	addi	r5,fp,-20
 323ef58:	32408540 	call	3240854 <iproute>
 323ef5c:	1007883a 	mov	r3,r2
 323ef60:	e0bffc17 	ldw	r2,-16(fp)
 323ef64:	10c00615 	stw	r3,24(r2)
      if (p->net == NULL)
 323ef68:	e0bffc17 	ldw	r2,-16(fp)
 323ef6c:	10800617 	ldw	r2,24(r2)
 323ef70:	1004c03a 	cmpne	r2,r2,zero
 323ef74:	10002e1e 	bne	r2,zero,323f030 <ip_write_internal+0x43c>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 323ef78:	0080c974 	movhi	r2,805
 323ef7c:	10931c04 	addi	r2,r2,19568
 323ef80:	10800017 	ldw	r2,0(r2)
 323ef84:	1080840c 	andi	r2,r2,528
 323ef88:	1005003a 	cmpeq	r2,r2,zero
 323ef8c:	1000181e 	bne	r2,zero,323eff0 <ip_write_internal+0x3fc>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 323ef90:	e0bffc17 	ldw	r2,-16(fp)
 323ef94:	11800417 	ldw	r6,16(r2)
 323ef98:	e0bffc17 	ldw	r2,-16(fp)
 323ef9c:	10800717 	ldw	r2,28(r2)
 323efa0:	11c03fcc 	andi	r7,r2,255
 323efa4:	e0bffc17 	ldw	r2,-16(fp)
 323efa8:	10800717 	ldw	r2,28(r2)
 323efac:	1004d23a 	srli	r2,r2,8
 323efb0:	11003fcc 	andi	r4,r2,255
 323efb4:	e0bffc17 	ldw	r2,-16(fp)
 323efb8:	10800717 	ldw	r2,28(r2)
 323efbc:	1004d43a 	srli	r2,r2,16
 323efc0:	10c03fcc 	andi	r3,r2,255
 323efc4:	e0bffc17 	ldw	r2,-16(fp)
 323efc8:	10800717 	ldw	r2,28(r2)
 323efcc:	1004d63a 	srli	r2,r2,24
 323efd0:	d9000015 	stw	r4,0(sp)
 323efd4:	d8c00115 	stw	r3,4(sp)
 323efd8:	d8800215 	stw	r2,8(sp)
 323efdc:	0100c974 	movhi	r4,805
 323efe0:	213f2f04 	addi	r4,r4,-836
 323efe4:	e17ffc17 	ldw	r5,-16(fp)
 323efe8:	3206de00 	call	3206de0 <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 323efec:	322aef00 	call	322aef0 <dtrap>
         }
#endif   /* NPDEBUG */
         ip_mib.ipOutNoRoutes++;
 323eff0:	0080c9b4 	movhi	r2,806
 323eff4:	10b54b04 	addi	r2,r2,-10964
 323eff8:	10800b17 	ldw	r2,44(r2)
 323effc:	10c00044 	addi	r3,r2,1
 323f000:	0080c9b4 	movhi	r2,806
 323f004:	10b54b04 	addi	r2,r2,-10964
 323f008:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 323f00c:	01000084 	movi	r4,2
 323f010:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pk_free(p);
 323f014:	e13ffc17 	ldw	r4,-16(fp)
 323f018:	322a6400 	call	322a640 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323f01c:	01000084 	movi	r4,2
 323f020:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 323f024:	00fff7c4 	movi	r3,-33
 323f028:	e0fffd15 	stw	r3,-12(fp)
 323f02c:	0000cb06 	br	323f35c <ip_write_internal+0x768>
#ifdef   IP_MULTICAST
sendit:  /* label used for multicast packets to skip routing logic */
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
 323f030:	0080c974 	movhi	r2,805
 323f034:	10931c04 	addi	r2,r2,19568
 323f038:	10800017 	ldw	r2,0(r2)
 323f03c:	1080800c 	andi	r2,r2,512
 323f040:	1005003a 	cmpeq	r2,r2,zero
 323f044:	1000231e 	bne	r2,zero,323f0d4 <ip_write_internal+0x4e0>
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 323f048:	e0bffc17 	ldw	r2,-16(fp)
 323f04c:	11400417 	ldw	r5,16(r2)
 323f050:	e0bffc17 	ldw	r2,-16(fp)
 323f054:	10800717 	ldw	r2,28(r2)
 323f058:	11803fcc 	andi	r6,r2,255
 323f05c:	e0bffc17 	ldw	r2,-16(fp)
 323f060:	10800717 	ldw	r2,28(r2)
 323f064:	1004d23a 	srli	r2,r2,8
 323f068:	11c03fcc 	andi	r7,r2,255
 323f06c:	e0bffc17 	ldw	r2,-16(fp)
 323f070:	10800717 	ldw	r2,28(r2)
 323f074:	1004d43a 	srli	r2,r2,16
 323f078:	10c03fcc 	andi	r3,r2,255
 323f07c:	e0bffc17 	ldw	r2,-16(fp)
 323f080:	10800717 	ldw	r2,28(r2)
 323f084:	1004d63a 	srli	r2,r2,24
 323f088:	d8c00015 	stw	r3,0(sp)
 323f08c:	d8800115 	stw	r2,4(sp)
 323f090:	0100c974 	movhi	r4,805
 323f094:	213f3f04 	addi	r4,r4,-772
 323f098:	3206de00 	call	3206de0 <printf>
       p->nb_plen, PUSH_IPADDR(p->fhost));
      dprintf(" route %u.%u.%u.%u\n", PUSH_IPADDR(firsthop));
 323f09c:	e0bffb17 	ldw	r2,-20(fp)
 323f0a0:	11403fcc 	andi	r5,r2,255
 323f0a4:	e0bffb17 	ldw	r2,-20(fp)
 323f0a8:	1004d23a 	srli	r2,r2,8
 323f0ac:	11803fcc 	andi	r6,r2,255
 323f0b0:	e0bffb17 	ldw	r2,-20(fp)
 323f0b4:	1004d43a 	srli	r2,r2,16
 323f0b8:	11c03fcc 	andi	r7,r2,255
 323f0bc:	e0bffb17 	ldw	r2,-20(fp)
 323f0c0:	1004d63a 	srli	r2,r2,24
 323f0c4:	d8800015 	stw	r2,0(sp)
 323f0c8:	0100c974 	movhi	r4,805
 323f0cc:	213f4804 	addi	r4,r4,-736
 323f0d0:	3206de00 	call	3206de0 <printf>
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 323f0d4:	e0bffc17 	ldw	r2,-16(fp)
 323f0d8:	10800617 	ldw	r2,24(r2)
 323f0dc:	10c00a17 	ldw	r3,40(r2)
 323f0e0:	e0bffc17 	ldw	r2,-16(fp)
 323f0e4:	10800717 	ldw	r2,28(r2)
 323f0e8:	18802a1e 	bne	r3,r2,323f194 <ip_write_internal+0x5a0>
 323f0ec:	e0bffc17 	ldw	r2,-16(fp)
 323f0f0:	10800717 	ldw	r2,28(r2)
 323f0f4:	10803fcc 	andi	r2,r2,255
 323f0f8:	10801fe0 	cmpeqi	r2,r2,127
 323f0fc:	1000251e 	bne	r2,zero,323f194 <ip_write_internal+0x5a0>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
   {
      if (!(p->net->n_flags & NF_NBPROT))
 323f100:	e0bffc17 	ldw	r2,-16(fp)
 323f104:	10800617 	ldw	r2,24(r2)
 323f108:	10802a17 	ldw	r2,168(r2)
 323f10c:	1080020c 	andi	r2,r2,8
 323f110:	1004c03a 	cmpne	r2,r2,zero
 323f114:	10000a1e 	bne	r2,zero,323f140 <ip_write_internal+0x54c>
          * IP or ARP protocol header) and nb_type to the protocol
          * type, and set the NF_NBPROT flag in its interfaces'
          * n_flags fields.
          */
#ifdef NPDEBUG
         dtrap();
 323f118:	322aef00 	call	322aef0 <dtrap>
#endif
         LOCK_NET_RESOURCE(FREEQ_RESID);
 323f11c:	01000084 	movi	r4,2
 323f120:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pk_free(p);
 323f124:	e13ffc17 	ldw	r4,-16(fp)
 323f128:	322a6400 	call	322a640 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323f12c:	01000084 	movi	r4,2
 323f130:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_LOGIC;
 323f134:	00bffd44 	movi	r2,-11
 323f138:	e0bffd15 	stw	r2,-12(fp)
 323f13c:	00008706 	br	323f35c <ip_write_internal+0x768>
      }
      p->type = IPTP;
 323f140:	e0fffc17 	ldw	r3,-16(fp)
 323f144:	00800204 	movi	r2,8
 323f148:	1880080d 	sth	r2,32(r3)
      UNLOCK_NET_RESOURCE(NET_RESID);
 323f14c:	0009883a 	mov	r4,zero
 323f150:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(RXQ_RESID);
 323f154:	01000044 	movi	r4,1
 323f158:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      putq(&rcvdq, (q_elt)p);
 323f15c:	e17ffc17 	ldw	r5,-16(fp)
 323f160:	0100c9b4 	movhi	r4,806
 323f164:	21328004 	addi	r4,r4,-13824
 323f168:	322a8800 	call	322a880 <putq>
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 323f16c:	01000044 	movi	r4,1
 323f170:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(NET_RESID);
 323f174:	0009883a 	mov	r4,zero
 323f178:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);

      SignalPktDemux();
 323f17c:	0080c974 	movhi	r2,805
 323f180:	10934404 	addi	r2,r2,19728
 323f184:	11000017 	ldw	r4,0(r2)
 323f188:	321b4e00 	call	321b4e0 <OSSemPost>

      return SUCCESS;
 323f18c:	e03ffd15 	stw	zero,-12(fp)
 323f190:	00007206 	br	323f35c <ip_write_internal+0x768>
   }

   /* determine if the buffer that needs to be transmitted is interrupt-safe */
   intrsafe_buf = ((p->flags & PKF_INTRUNSAFE) ? 0 : 1);
 323f194:	e0bffc17 	ldw	r2,-16(fp)
 323f198:	10800a17 	ldw	r2,40(r2)
 323f19c:	1080040c 	andi	r2,r2,16
 323f1a0:	1005003a 	cmpeq	r2,r2,zero
 323f1a4:	e0bff605 	stb	r2,-40(fp)
   /* obtain the length of the largest interrupt-safe buffer that can be 
    * allocated via pk_alloc () */
   maxbuflen = pk_get_max_intrsafe_buf_len ();
 323f1a8:	322a6ec0 	call	322a6ec <pk_get_max_intrsafe_buf_len>
 323f1ac:	e0bff315 	stw	r2,-52(fp)
    * the original buffer is interrupt-safe, we just need to consider the
    * MTU of the egress interface.  If the original buffer is interrupt-
    * unsafe, we compute the MIN of the largest interrupt-safe buffer that
    * we can use and the MTU of the egress interface (since we must satisfy
    * both constraints) */
   if (!intrsafe_buf)
 323f1b0:	e0bff603 	ldbu	r2,-40(fp)
 323f1b4:	1004c03a 	cmpne	r2,r2,zero
 323f1b8:	10000e1e 	bne	r2,zero,323f1f4 <ip_write_internal+0x600>
       limit = MIN(maxbuflen,p->net->n_mtu);
 323f1bc:	e0bffc17 	ldw	r2,-16(fp)
 323f1c0:	10800617 	ldw	r2,24(r2)
 323f1c4:	10800917 	ldw	r2,36(r2)
 323f1c8:	e0fff317 	ldw	r3,-52(fp)
 323f1cc:	e0ffff15 	stw	r3,-4(fp)
 323f1d0:	e0bffe15 	stw	r2,-8(fp)
 323f1d4:	e0bfff17 	ldw	r2,-4(fp)
 323f1d8:	e0fffe17 	ldw	r3,-8(fp)
 323f1dc:	10c0022e 	bgeu	r2,r3,323f1e8 <ip_write_internal+0x5f4>
 323f1e0:	e0bfff17 	ldw	r2,-4(fp)
 323f1e4:	e0bffe15 	stw	r2,-8(fp)
 323f1e8:	e0fffe17 	ldw	r3,-8(fp)
 323f1ec:	e0fff515 	stw	r3,-44(fp)
 323f1f0:	00000406 	br	323f204 <ip_write_internal+0x610>
   else
       limit = p->net->n_mtu;
 323f1f4:	e0bffc17 	ldw	r2,-16(fp)
 323f1f8:	10800617 	ldw	r2,24(r2)
 323f1fc:	10800917 	ldw	r2,36(r2)
 323f200:	e0bff515 	stw	r2,-44(fp)

   if ((p->nb_plen + p->net->n_lnh) > limit)
 323f204:	e0bffc17 	ldw	r2,-16(fp)
 323f208:	10c00417 	ldw	r3,16(r2)
 323f20c:	e0bffc17 	ldw	r2,-16(fp)
 323f210:	10800617 	ldw	r2,24(r2)
 323f214:	10800817 	ldw	r2,32(r2)
 323f218:	1887883a 	add	r3,r3,r2
 323f21c:	e0bff517 	ldw	r2,-44(fp)
 323f220:	10c0072e 	bgeu	r2,r3,323f240 <ip_write_internal+0x64c>
   {
#ifdef IP_FRAGMENTS
      int err;
      err = ip_fragment(p, firsthop);
 323f224:	e17ffb17 	ldw	r5,-20(fp)
 323f228:	e13ffc17 	ldw	r4,-16(fp)
 323f22c:	323fecc0 	call	323fecc <ip_fragment>
 323f230:	e0bff215 	stw	r2,-56(fp)
      IN_PROFILER(PF_IP, PF_EXIT);
      return(err);
 323f234:	e0bff217 	ldw	r2,-56(fp)
 323f238:	e0bffd15 	stw	r2,-12(fp)
 323f23c:	00004706 	br	323f35c <ip_write_internal+0x768>
   }
   else
   {
      /* fragmentation is not required; check to see if we need to copy out of
       * an interrupt-unsafe buffer */ 
      if (!intrsafe_buf)
 323f240:	e0bff603 	ldbu	r2,-40(fp)
 323f244:	1004c03a 	cmpne	r2,r2,zero
 323f248:	1000401e 	bne	r2,zero,323f34c <ip_write_internal+0x758>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 323f24c:	01000084 	movi	r4,2
 323f250:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         newpkt = pk_alloc(p->nb_plen + p->net->n_lnh);
 323f254:	e0bffc17 	ldw	r2,-16(fp)
 323f258:	10c00417 	ldw	r3,16(r2)
 323f25c:	e0bffc17 	ldw	r2,-16(fp)
 323f260:	10800617 	ldw	r2,24(r2)
 323f264:	10800817 	ldw	r2,32(r2)
 323f268:	1889883a 	add	r4,r3,r2
 323f26c:	322a2ac0 	call	322a2ac <pk_alloc>
 323f270:	e0bff415 	stw	r2,-48(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323f274:	01000084 	movi	r4,2
 323f278:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         if (newpkt == 0)
 323f27c:	e0bff417 	ldw	r2,-48(fp)
 323f280:	1004c03a 	cmpne	r2,r2,zero
 323f284:	1000091e 	bne	r2,zero,323f2ac <ip_write_internal+0x6b8>
         {
            /* can't allocate interrupt-safe buffer, so free the packet that 
             * we are working with */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 323f288:	01000084 	movi	r4,2
 323f28c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
            pk_free(p);
 323f290:	e13ffc17 	ldw	r4,-16(fp)
 323f294:	322a6400 	call	322a640 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323f298:	01000084 	movi	r4,2
 323f29c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NOBUFFER;
 323f2a0:	00fffac4 	movi	r3,-21
 323f2a4:	e0fffd15 	stw	r3,-12(fp)
 323f2a8:	00002c06 	br	323f35c <ip_write_internal+0x768>
         }
         else
         {
            /* copy from interrupt-unsafe buffer into interrupt-safe buffer */
            newpkt->nb_prot = newpkt->nb_buff + p->net->n_lnh;
 323f2ac:	e0bff417 	ldw	r2,-48(fp)
 323f2b0:	10c00117 	ldw	r3,4(r2)
 323f2b4:	e0bffc17 	ldw	r2,-16(fp)
 323f2b8:	10800617 	ldw	r2,24(r2)
 323f2bc:	10800817 	ldw	r2,32(r2)
 323f2c0:	1887883a 	add	r3,r3,r2
 323f2c4:	e0bff417 	ldw	r2,-48(fp)
 323f2c8:	10c00315 	stw	r3,12(r2)
            MEMCPY(newpkt->nb_prot, p->nb_prot, p->nb_plen);
 323f2cc:	e0bff417 	ldw	r2,-48(fp)
 323f2d0:	10c00317 	ldw	r3,12(r2)
 323f2d4:	e0bffc17 	ldw	r2,-16(fp)
 323f2d8:	11400317 	ldw	r5,12(r2)
 323f2dc:	e0bffc17 	ldw	r2,-16(fp)
 323f2e0:	10800417 	ldw	r2,16(r2)
 323f2e4:	1809883a 	mov	r4,r3
 323f2e8:	100d883a 	mov	r6,r2
 323f2ec:	3206ad00 	call	3206ad0 <memcpy>
            /* setup various fields in the newly allocated PACKET structure */
            newpkt->nb_plen = p->nb_plen;
 323f2f0:	e0bffc17 	ldw	r2,-16(fp)
 323f2f4:	10c00417 	ldw	r3,16(r2)
 323f2f8:	e0bff417 	ldw	r2,-48(fp)
 323f2fc:	10c00415 	stw	r3,16(r2)
            newpkt->net = p->net;
 323f300:	e0bffc17 	ldw	r2,-16(fp)
 323f304:	10c00617 	ldw	r3,24(r2)
 323f308:	e0bff417 	ldw	r2,-48(fp)
 323f30c:	10c00615 	stw	r3,24(r2)
            newpkt->fhost = p->fhost;
 323f310:	e0bffc17 	ldw	r2,-16(fp)
 323f314:	10c00717 	ldw	r3,28(r2)
 323f318:	e0bff417 	ldw	r2,-48(fp)
 323f31c:	10c00715 	stw	r3,28(r2)
            /* free the original packet since it is no longer needed */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 323f320:	01000084 	movi	r4,2
 323f324:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
            pk_free(p);
 323f328:	e13ffc17 	ldw	r4,-16(fp)
 323f32c:	322a6400 	call	322a640 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323f330:	01000084 	movi	r4,2
 323f334:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            /* send packet to MAC layer. This will try to resolve MAC layer addressing 
             * and send packet. ip2mac() can return SUCCESS, PENDING, or error codes. 
             */
            return(ip2mac(newpkt, firsthop));
 323f338:	e17ffb17 	ldw	r5,-20(fp)
 323f33c:	e13ff417 	ldw	r4,-48(fp)
 323f340:	3223af80 	call	3223af8 <ip2mac>
 323f344:	e0bffd15 	stw	r2,-12(fp)
 323f348:	00000406 	br	323f35c <ip_write_internal+0x768>
      else
      {
         /* since the packet is in an interrupt-safe buffer, it can be passed to 
          * ip2mac () without any additional work. */
         IN_PROFILER(PF_IP, PF_EXIT);
         return(ip2mac(p, firsthop));
 323f34c:	e17ffb17 	ldw	r5,-20(fp)
 323f350:	e13ffc17 	ldw	r4,-16(fp)
 323f354:	3223af80 	call	3223af8 <ip2mac>
 323f358:	e0bffd15 	stw	r2,-12(fp)
 323f35c:	e0bffd17 	ldw	r2,-12(fp)
      }
   }
}
 323f360:	e037883a 	mov	sp,fp
 323f364:	dfc00117 	ldw	ra,4(sp)
 323f368:	df000017 	ldw	fp,0(sp)
 323f36c:	dec00204 	addi	sp,sp,8
 323f370:	f800283a 	ret

0323f374 <ip_write>:

int
ip_write(
   u_char   prot,
   PACKET   p)
{
 323f374:	defff904 	addi	sp,sp,-28
 323f378:	dfc00615 	stw	ra,24(sp)
 323f37c:	df000515 	stw	fp,20(sp)
 323f380:	df000504 	addi	fp,sp,20
 323f384:	e17fff15 	stw	r5,-4(fp)
 323f388:	e13ffe05 	stb	r4,-8(fp)
   u_char ttl;
   struct ip_socopts *sopts;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 323f38c:	0080c9b4 	movhi	r2,806
 323f390:	10b54b04 	addi	r2,r2,-10964
 323f394:	10800917 	ldw	r2,36(r2)
 323f398:	10c00044 	addi	r3,r2,1
 323f39c:	0080c9b4 	movhi	r2,806
 323f3a0:	10b54b04 	addi	r2,r2,-10964
 323f3a4:	10c00915 	stw	r3,36(r2)

   /* make room for IP header, and form a pointer to it (pip) */
   p->nb_prot -= sizeof(struct ip);
 323f3a8:	e0bfff17 	ldw	r2,-4(fp)
 323f3ac:	10800317 	ldw	r2,12(r2)
 323f3b0:	10fffb04 	addi	r3,r2,-20
 323f3b4:	e0bfff17 	ldw	r2,-4(fp)
 323f3b8:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 323f3bc:	e0bfff17 	ldw	r2,-4(fp)
 323f3c0:	10800417 	ldw	r2,16(r2)
 323f3c4:	10c00504 	addi	r3,r2,20
 323f3c8:	e0bfff17 	ldw	r2,-4(fp)
 323f3cc:	10c00415 	stw	r3,16(r2)
   pip = (struct ip*)(p->nb_prot);
 323f3d0:	e0bfff17 	ldw	r2,-4(fp)
 323f3d4:	10800317 	ldw	r2,12(r2)
 323f3d8:	e0bffd15 	stw	r2,-12(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 323f3dc:	e0fffd17 	ldw	r3,-12(fp)
 323f3e0:	00801144 	movi	r2,69
 323f3e4:	18800005 	stb	r2,0(r3)
   pip->ip_flgs_foff = 0;        /* clear fragmentation info field */
 323f3e8:	e0bffd17 	ldw	r2,-12(fp)
 323f3ec:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 323f3f0:	d0a04c17 	ldw	r2,-32464(gp)
 323f3f4:	10bfffcc 	andi	r2,r2,65535
 323f3f8:	1004d23a 	srli	r2,r2,8
 323f3fc:	10803fcc 	andi	r2,r2,255
 323f400:	1009883a 	mov	r4,r2
 323f404:	d0a04c17 	ldw	r2,-32464(gp)
 323f408:	10bfffcc 	andi	r2,r2,65535
 323f40c:	1004923a 	slli	r2,r2,8
 323f410:	1007883a 	mov	r3,r2
 323f414:	00bfc004 	movi	r2,-256
 323f418:	1884703a 	and	r2,r3,r2
 323f41c:	2084b03a 	or	r2,r4,r2
 323f420:	1007883a 	mov	r3,r2
 323f424:	e0bffd17 	ldw	r2,-12(fp)
 323f428:	10c0010d 	sth	r3,4(r2)
   uid++;
 323f42c:	d0a04c17 	ldw	r2,-32464(gp)
 323f430:	10800044 	addi	r2,r2,1
 323f434:	d0a04c15 	stw	r2,-32464(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 323f438:	e0bfff17 	ldw	r2,-4(fp)
 323f43c:	10800417 	ldw	r2,16(r2)
 323f440:	10bfffcc 	andi	r2,r2,65535
 323f444:	1004d23a 	srli	r2,r2,8
 323f448:	10803fcc 	andi	r2,r2,255
 323f44c:	1009883a 	mov	r4,r2
 323f450:	e0bfff17 	ldw	r2,-4(fp)
 323f454:	10800417 	ldw	r2,16(r2)
 323f458:	10bfffcc 	andi	r2,r2,65535
 323f45c:	1004923a 	slli	r2,r2,8
 323f460:	1007883a 	mov	r3,r2
 323f464:	00bfc004 	movi	r2,-256
 323f468:	1884703a 	and	r2,r3,r2
 323f46c:	2084b03a 	or	r2,r4,r2
 323f470:	1007883a 	mov	r3,r2
 323f474:	e0bffd17 	ldw	r2,-12(fp)
 323f478:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 323f47c:	e0fffd17 	ldw	r3,-12(fp)
 323f480:	e0bffe03 	ldbu	r2,-8(fp)
 323f484:	18800245 	stb	r2,9(r3)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 323f488:	e0bffd17 	ldw	r2,-12(fp)
 323f48c:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 323f490:	00801004 	movi	r2,64
 323f494:	e0bffc05 	stb	r2,-16(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 323f498:	e0bfff17 	ldw	r2,-4(fp)
 323f49c:	10800717 	ldw	r2,28(r2)
 323f4a0:	1004d63a 	srli	r2,r2,24
 323f4a4:	10c03fcc 	andi	r3,r2,255
 323f4a8:	e0bfff17 	ldw	r2,-4(fp)
 323f4ac:	10800717 	ldw	r2,28(r2)
 323f4b0:	1004d23a 	srli	r2,r2,8
 323f4b4:	10bfc00c 	andi	r2,r2,65280
 323f4b8:	1886b03a 	or	r3,r3,r2
 323f4bc:	e0bfff17 	ldw	r2,-4(fp)
 323f4c0:	10800717 	ldw	r2,28(r2)
 323f4c4:	10bfc00c 	andi	r2,r2,65280
 323f4c8:	1004923a 	slli	r2,r2,8
 323f4cc:	1886b03a 	or	r3,r3,r2
 323f4d0:	e0bfff17 	ldw	r2,-4(fp)
 323f4d4:	10800717 	ldw	r2,28(r2)
 323f4d8:	10803fcc 	andi	r2,r2,255
 323f4dc:	1004963a 	slli	r2,r2,24
 323f4e0:	1884b03a 	or	r2,r3,r2
 323f4e4:	10fc002c 	andhi	r3,r2,61440
 323f4e8:	00b80034 	movhi	r2,57344
 323f4ec:	1880081e 	bne	r3,r2,323f510 <ip_write+0x19c>
 323f4f0:	e0bfff17 	ldw	r2,-4(fp)
 323f4f4:	10800b17 	ldw	r2,44(r2)
 323f4f8:	1005003a 	cmpeq	r2,r2,zero
 323f4fc:	1000041e 	bne	r2,zero,323f510 <ip_write+0x19c>
      ttl = p->imo->imo_multicast_ttl;
 323f500:	e0bfff17 	ldw	r2,-4(fp)
 323f504:	10800b17 	ldw	r2,44(r2)
 323f508:	10800103 	ldbu	r2,4(r2)
 323f50c:	e0bffc05 	stb	r2,-16(fp)
#endif /* IP_MULTICAST */

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 323f510:	e0bfff17 	ldw	r2,-4(fp)
 323f514:	10800c17 	ldw	r2,48(r2)
 323f518:	e0bffb15 	stw	r2,-20(fp)
 323f51c:	e0bffb17 	ldw	r2,-20(fp)
 323f520:	1005003a 	cmpeq	r2,r2,zero
 323f524:	1000121e 	bne	r2,zero,323f570 <ip_write+0x1fc>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 323f528:	e0bffb17 	ldw	r2,-20(fp)
 323f52c:	10800043 	ldbu	r2,1(r2)
 323f530:	10803fcc 	andi	r2,r2,255
 323f534:	1005003a 	cmpeq	r2,r2,zero
 323f538:	1000051e 	bne	r2,zero,323f550 <ip_write+0x1dc>
         pip->ip_time = sopts->ip_ttl;
 323f53c:	e0bffb17 	ldw	r2,-20(fp)
 323f540:	10c00043 	ldbu	r3,1(r2)
 323f544:	e0bffd17 	ldw	r2,-12(fp)
 323f548:	10c00205 	stb	r3,8(r2)
 323f54c:	00000306 	br	323f55c <ip_write+0x1e8>
	  else
         pip->ip_time = ttl;
 323f550:	e0fffd17 	ldw	r3,-12(fp)
 323f554:	e0bffc03 	ldbu	r2,-16(fp)
 323f558:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 323f55c:	e0bffb17 	ldw	r2,-20(fp)
 323f560:	10c00003 	ldbu	r3,0(r2)
 323f564:	e0bffd17 	ldw	r2,-12(fp)
 323f568:	10c00045 	stb	r3,1(r2)
 323f56c:	00000506 	br	323f584 <ip_write+0x210>
   }
   else
   {
	  /* nope */
      pip->ip_time = ttl;
 323f570:	e0bffd17 	ldw	r2,-12(fp)
 323f574:	e0fffc03 	ldbu	r3,-16(fp)
 323f578:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 323f57c:	e0bffd17 	ldw	r2,-12(fp)
 323f580:	10000045 	stb	zero,1(r2)
   }
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum(pip, 10);
 323f584:	e13ffd17 	ldw	r4,-12(fp)
 323f588:	01400284 	movi	r5,10
 323f58c:	3225d5c0 	call	3225d5c <cksum>
 323f590:	0084303a 	nor	r2,zero,r2
 323f594:	1007883a 	mov	r3,r2
 323f598:	e0bffd17 	ldw	r2,-12(fp)
 323f59c:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 323f5a0:	e13fff17 	ldw	r4,-4(fp)
 323f5a4:	323ebf40 	call	323ebf4 <ip_write_internal>
}
 323f5a8:	e037883a 	mov	sp,fp
 323f5ac:	dfc00117 	ldw	ra,4(sp)
 323f5b0:	df000017 	ldw	fp,0(sp)
 323f5b4:	dec00204 	addi	sp,sp,8
 323f5b8:	f800283a 	ret

0323f5bc <ip_write2>:
 * OUTPUT: This function returns the return code from 
 *         ip_write_internal ().
 */

int ip_write2 (u_char prot, PACKET p, u_char * optp)
{
 323f5bc:	defff504 	addi	sp,sp,-44
 323f5c0:	dfc00a15 	stw	ra,40(sp)
 323f5c4:	df000915 	stw	fp,36(sp)
 323f5c8:	df000904 	addi	fp,sp,36
 323f5cc:	e17ffe15 	stw	r5,-8(fp)
 323f5d0:	e1bfff15 	stw	r6,-4(fp)
 323f5d4:	e13ffd05 	stb	r4,-12(fp)
   struct ip * pip;
   u_char ttl;
   struct ip_socopts * sopts;
   u_char iphlen = sizeof (struct ip);
 323f5d8:	00800504 	movi	r2,20
 323f5dc:	e0bff905 	stb	r2,-28(fp)
   u_char iphlen_pad;
   u_char i;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 323f5e0:	0080c9b4 	movhi	r2,806
 323f5e4:	10b54b04 	addi	r2,r2,-10964
 323f5e8:	10800917 	ldw	r2,36(r2)
 323f5ec:	10c00044 	addi	r3,r2,1
 323f5f0:	0080c9b4 	movhi	r2,806
 323f5f4:	10b54b04 	addi	r2,r2,-10964
 323f5f8:	10c00915 	stw	r3,36(r2)

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 323f5fc:	e0bfff17 	ldw	r2,-4(fp)
 323f600:	e0bff815 	stw	r2,-32(fp)
 323f604:	00000c06 	br	323f638 <ip_write2+0x7c>
   {
      /* account for options, if any (caller has already created
       * adequate space for the requested option) */
      switch (*tmpp)
 323f608:	e0bff817 	ldw	r2,-32(fp)
 323f60c:	10800003 	ldbu	r2,0(r2)
 323f610:	10803fcc 	andi	r2,r2,255
 323f614:	10800520 	cmpeqi	r2,r2,20
 323f618:	1000011e 	bne	r2,zero,323f620 <ip_write2+0x64>
 323f61c:	00000306 	br	323f62c <ip_write2+0x70>
      {
         case IP_RTR_ALERT_OPT:
            iphlen += IP_RTR_ALERT_OPT_SIZE;
 323f620:	e0bff903 	ldbu	r2,-28(fp)
 323f624:	10800104 	addi	r2,r2,4
 323f628:	e0bff905 	stb	r2,-28(fp)
   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 323f62c:	e0bff817 	ldw	r2,-32(fp)
 323f630:	10800044 	addi	r2,r2,1
 323f634:	e0bff815 	stw	r2,-32(fp)
 323f638:	e0bff817 	ldw	r2,-32(fp)
 323f63c:	10800003 	ldbu	r2,0(r2)
 323f640:	10803fcc 	andi	r2,r2,255
 323f644:	1004c03a 	cmpne	r2,r2,zero
 323f648:	103fef1e 	bne	r2,zero,323f608 <ip_write2+0x4c>
   }

   /* compute the amount of padding required, if any (to ensure
    * that the IP header (including options) ends on a dword
    * (four byte) boundary */
   if (iphlen & 0x3)
 323f64c:	e0bff903 	ldbu	r2,-28(fp)
 323f650:	108000cc 	andi	r2,r2,3
 323f654:	1005003a 	cmpeq	r2,r2,zero
 323f658:	1000071e 	bne	r2,zero,323f678 <ip_write2+0xbc>
      iphlen_pad = 4 - (iphlen & 0x3);
 323f65c:	e0bff903 	ldbu	r2,-28(fp)
 323f660:	108000cc 	andi	r2,r2,3
 323f664:	1007883a 	mov	r3,r2
 323f668:	00800104 	movi	r2,4
 323f66c:	10c5c83a 	sub	r2,r2,r3
 323f670:	e0bff745 	stb	r2,-35(fp)
 323f674:	00000106 	br	323f67c <ip_write2+0xc0>
   else iphlen_pad = 0; /* no header padding required */
 323f678:	e03ff745 	stb	zero,-35(fp)
   /* the packet passed to ip_write2 () has its nb_prot set to
    * point to start of the protocol's (e.g., IGMP) data, and 
    * nb_plen set to the length of that data.  locate start of 
    * the IP header (account for IP options), and form a pointer 
    * to it (pip) */
   p->nb_prot -= (iphlen + iphlen_pad);
 323f67c:	e0bffe17 	ldw	r2,-8(fp)
 323f680:	11000317 	ldw	r4,12(r2)
 323f684:	e0fff903 	ldbu	r3,-28(fp)
 323f688:	e0bff743 	ldbu	r2,-35(fp)
 323f68c:	1885883a 	add	r2,r3,r2
 323f690:	2087c83a 	sub	r3,r4,r2
 323f694:	e0bffe17 	ldw	r2,-8(fp)
 323f698:	10c00315 	stw	r3,12(r2)
   /* add padding length to the total length of the IP datagram */
   p->nb_plen += (iphlen + iphlen_pad);
 323f69c:	e0bffe17 	ldw	r2,-8(fp)
 323f6a0:	11000417 	ldw	r4,16(r2)
 323f6a4:	e0fff903 	ldbu	r3,-28(fp)
 323f6a8:	e0bff743 	ldbu	r2,-35(fp)
 323f6ac:	1885883a 	add	r2,r3,r2
 323f6b0:	2087883a 	add	r3,r4,r2
 323f6b4:	e0bffe17 	ldw	r2,-8(fp)
 323f6b8:	10c00415 	stw	r3,16(r2)
   pip = (struct ip *) (p->nb_prot);
 323f6bc:	e0bffe17 	ldw	r2,-8(fp)
 323f6c0:	10800317 	ldw	r2,12(r2)
 323f6c4:	e0bffc15 	stw	r2,-16(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = ((IP_VER << 4) | ((iphlen + iphlen_pad) >> 2));
 323f6c8:	e0fff903 	ldbu	r3,-28(fp)
 323f6cc:	e0bff743 	ldbu	r2,-35(fp)
 323f6d0:	1885883a 	add	r2,r3,r2
 323f6d4:	1005d0ba 	srai	r2,r2,2
 323f6d8:	10801014 	ori	r2,r2,64
 323f6dc:	1007883a 	mov	r3,r2
 323f6e0:	e0bffc17 	ldw	r2,-16(fp)
 323f6e4:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0; /* clear fragmentation info field */
 323f6e8:	e0bffc17 	ldw	r2,-16(fp)
 323f6ec:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 323f6f0:	d0a04c17 	ldw	r2,-32464(gp)
 323f6f4:	10bfffcc 	andi	r2,r2,65535
 323f6f8:	1004d23a 	srli	r2,r2,8
 323f6fc:	10803fcc 	andi	r2,r2,255
 323f700:	1009883a 	mov	r4,r2
 323f704:	d0a04c17 	ldw	r2,-32464(gp)
 323f708:	10bfffcc 	andi	r2,r2,65535
 323f70c:	1004923a 	slli	r2,r2,8
 323f710:	1007883a 	mov	r3,r2
 323f714:	00bfc004 	movi	r2,-256
 323f718:	1884703a 	and	r2,r3,r2
 323f71c:	2084b03a 	or	r2,r4,r2
 323f720:	1007883a 	mov	r3,r2
 323f724:	e0bffc17 	ldw	r2,-16(fp)
 323f728:	10c0010d 	sth	r3,4(r2)
   uid++;
 323f72c:	d0a04c17 	ldw	r2,-32464(gp)
 323f730:	10800044 	addi	r2,r2,1
 323f734:	d0a04c15 	stw	r2,-32464(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 323f738:	e0bffe17 	ldw	r2,-8(fp)
 323f73c:	10800417 	ldw	r2,16(r2)
 323f740:	10bfffcc 	andi	r2,r2,65535
 323f744:	1004d23a 	srli	r2,r2,8
 323f748:	10803fcc 	andi	r2,r2,255
 323f74c:	1009883a 	mov	r4,r2
 323f750:	e0bffe17 	ldw	r2,-8(fp)
 323f754:	10800417 	ldw	r2,16(r2)
 323f758:	10bfffcc 	andi	r2,r2,65535
 323f75c:	1004923a 	slli	r2,r2,8
 323f760:	1007883a 	mov	r3,r2
 323f764:	00bfc004 	movi	r2,-256
 323f768:	1884703a 	and	r2,r3,r2
 323f76c:	2084b03a 	or	r2,r4,r2
 323f770:	1007883a 	mov	r3,r2
 323f774:	e0bffc17 	ldw	r2,-16(fp)
 323f778:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 323f77c:	e0fffc17 	ldw	r3,-16(fp)
 323f780:	e0bffd03 	ldbu	r2,-12(fp)
 323f784:	18800245 	stb	r2,9(r3)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 323f788:	e0bffc17 	ldw	r2,-16(fp)
 323f78c:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 323f790:	00801004 	movi	r2,64
 323f794:	e0bffb05 	stb	r2,-20(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 323f798:	e0bffe17 	ldw	r2,-8(fp)
 323f79c:	10800717 	ldw	r2,28(r2)
 323f7a0:	1004d63a 	srli	r2,r2,24
 323f7a4:	10c03fcc 	andi	r3,r2,255
 323f7a8:	e0bffe17 	ldw	r2,-8(fp)
 323f7ac:	10800717 	ldw	r2,28(r2)
 323f7b0:	1004d23a 	srli	r2,r2,8
 323f7b4:	10bfc00c 	andi	r2,r2,65280
 323f7b8:	1886b03a 	or	r3,r3,r2
 323f7bc:	e0bffe17 	ldw	r2,-8(fp)
 323f7c0:	10800717 	ldw	r2,28(r2)
 323f7c4:	10bfc00c 	andi	r2,r2,65280
 323f7c8:	1004923a 	slli	r2,r2,8
 323f7cc:	1886b03a 	or	r3,r3,r2
 323f7d0:	e0bffe17 	ldw	r2,-8(fp)
 323f7d4:	10800717 	ldw	r2,28(r2)
 323f7d8:	10803fcc 	andi	r2,r2,255
 323f7dc:	1004963a 	slli	r2,r2,24
 323f7e0:	1884b03a 	or	r2,r3,r2
 323f7e4:	10fc002c 	andhi	r3,r2,61440
 323f7e8:	00b80034 	movhi	r2,57344
 323f7ec:	1880081e 	bne	r3,r2,323f810 <ip_write2+0x254>
 323f7f0:	e0bffe17 	ldw	r2,-8(fp)
 323f7f4:	10800b17 	ldw	r2,44(r2)
 323f7f8:	1005003a 	cmpeq	r2,r2,zero
 323f7fc:	1000041e 	bne	r2,zero,323f810 <ip_write2+0x254>
      ttl = p->imo->imo_multicast_ttl;
 323f800:	e0bffe17 	ldw	r2,-8(fp)
 323f804:	10800b17 	ldw	r2,44(r2)
 323f808:	10800103 	ldbu	r2,4(r2)
 323f80c:	e0bffb05 	stb	r2,-20(fp)
#endif /* IP_MULTICAST */

   /* have TOS or TTL been set (via socket options)? */
   if ((sopts = p->soxopts))
 323f810:	e0bffe17 	ldw	r2,-8(fp)
 323f814:	10800c17 	ldw	r2,48(r2)
 323f818:	e0bffa15 	stw	r2,-24(fp)
 323f81c:	e0bffa17 	ldw	r2,-24(fp)
 323f820:	1005003a 	cmpeq	r2,r2,zero
 323f824:	1000121e 	bne	r2,zero,323f870 <ip_write2+0x2b4>
   {
      if (sopts->ip_ttl)
 323f828:	e0bffa17 	ldw	r2,-24(fp)
 323f82c:	10800043 	ldbu	r2,1(r2)
 323f830:	10803fcc 	andi	r2,r2,255
 323f834:	1005003a 	cmpeq	r2,r2,zero
 323f838:	1000051e 	bne	r2,zero,323f850 <ip_write2+0x294>
         pip->ip_time = sopts->ip_ttl;
 323f83c:	e0bffa17 	ldw	r2,-24(fp)
 323f840:	10c00043 	ldbu	r3,1(r2)
 323f844:	e0bffc17 	ldw	r2,-16(fp)
 323f848:	10c00205 	stb	r3,8(r2)
 323f84c:	00000306 	br	323f85c <ip_write2+0x2a0>
      else
         pip->ip_time = ttl;
 323f850:	e0fffc17 	ldw	r3,-16(fp)
 323f854:	e0bffb03 	ldbu	r2,-20(fp)
 323f858:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 323f85c:	e0bffa17 	ldw	r2,-24(fp)
 323f860:	10c00003 	ldbu	r3,0(r2)
 323f864:	e0bffc17 	ldw	r2,-16(fp)
 323f868:	10c00045 	stb	r3,1(r2)
 323f86c:	00000506 	br	323f884 <ip_write2+0x2c8>
   }
   else
   {
      pip->ip_time = ttl;
 323f870:	e0bffc17 	ldw	r2,-16(fp)
 323f874:	e0fffb03 	ldbu	r3,-20(fp)
 323f878:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 323f87c:	e0bffc17 	ldw	r2,-16(fp)
 323f880:	10000045 	stb	zero,1(r2)
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 323f884:	e0bffe17 	ldw	r2,-8(fp)
 323f888:	10800317 	ldw	r2,12(r2)
 323f88c:	10800504 	addi	r2,r2,20
 323f890:	e0bff815 	stw	r2,-32(fp)
 323f894:	00000f06 	br	323f8d4 <ip_write2+0x318>
   {
      /* caller has already provided adequate space for the requested options */
      switch (*optp)
 323f898:	e0bfff17 	ldw	r2,-4(fp)
 323f89c:	10800003 	ldbu	r2,0(r2)
 323f8a0:	10803fcc 	andi	r2,r2,255
 323f8a4:	10800520 	cmpeqi	r2,r2,20
 323f8a8:	1000011e 	bne	r2,zero,323f8b0 <ip_write2+0x2f4>
 323f8ac:	00000606 	br	323f8c8 <ip_write2+0x30c>
      {
         case IP_RTR_ALERT_OPT:
            *((u_long *) tmpp) = htonl (IP_RTR_ALERT_OPT_DATA);
 323f8b0:	e0fff817 	ldw	r3,-32(fp)
 323f8b4:	00812504 	movi	r2,1172
 323f8b8:	18800015 	stw	r2,0(r3)
            /* this option is 4 bytes long */
            tmpp += IP_RTR_ALERT_OPT_SIZE;
 323f8bc:	e0bff817 	ldw	r2,-32(fp)
 323f8c0:	10800104 	addi	r2,r2,4
 323f8c4:	e0bff815 	stw	r2,-32(fp)
      pip->ip_time = ttl;
      pip->ip_tos = IP_TOS_DEFVAL;
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 323f8c8:	e0bfff17 	ldw	r2,-4(fp)
 323f8cc:	10800044 	addi	r2,r2,1
 323f8d0:	e0bfff15 	stw	r2,-4(fp)
 323f8d4:	e0bfff17 	ldw	r2,-4(fp)
 323f8d8:	10800003 	ldbu	r2,0(r2)
 323f8dc:	10803fcc 	andi	r2,r2,255
 323f8e0:	1004c03a 	cmpne	r2,r2,zero
 323f8e4:	103fec1e 	bne	r2,zero,323f898 <ip_write2+0x2dc>
            break;
      }
   }

   /* add one (or more) one-byte long End of Option options (if required) */
   for (i = 0; i < iphlen_pad; ++i) *(tmpp + i) = 0;
 323f8e8:	e03ff705 	stb	zero,-36(fp)
 323f8ec:	00000806 	br	323f910 <ip_write2+0x354>
 323f8f0:	e0bff703 	ldbu	r2,-36(fp)
 323f8f4:	1007883a 	mov	r3,r2
 323f8f8:	e0bff817 	ldw	r2,-32(fp)
 323f8fc:	1885883a 	add	r2,r3,r2
 323f900:	10000005 	stb	zero,0(r2)
 323f904:	e0bff703 	ldbu	r2,-36(fp)
 323f908:	10800044 	addi	r2,r2,1
 323f90c:	e0bff705 	stb	r2,-36(fp)
 323f910:	e0fff703 	ldbu	r3,-36(fp)
 323f914:	e0bff743 	ldbu	r2,-35(fp)
 323f918:	18bff536 	bltu	r3,r2,323f8f0 <ip_write2+0x334>
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum (pip, ((iphlen + iphlen_pad)/2));
 323f91c:	e0fff903 	ldbu	r3,-28(fp)
 323f920:	e0bff743 	ldbu	r2,-35(fp)
 323f924:	1887883a 	add	r3,r3,r2
 323f928:	1804d7fa 	srli	r2,r3,31
 323f92c:	10c5883a 	add	r2,r2,r3
 323f930:	1005d07a 	srai	r2,r2,1
 323f934:	100b883a 	mov	r5,r2
 323f938:	e13ffc17 	ldw	r4,-16(fp)
 323f93c:	3225d5c0 	call	3225d5c <cksum>
 323f940:	0084303a 	nor	r2,zero,r2
 323f944:	1007883a 	mov	r3,r2
 323f948:	e0bffc17 	ldw	r2,-16(fp)
 323f94c:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal (p));
 323f950:	e13ffe17 	ldw	r4,-8(fp)
 323f954:	323ebf40 	call	323ebf4 <ip_write_internal>
}
 323f958:	e037883a 	mov	sp,fp
 323f95c:	dfc00117 	ldw	ra,4(sp)
 323f960:	df000017 	ldw	fp,0(sp)
 323f964:	dec00204 	addi	sp,sp,8
 323f968:	f800283a 	ret

0323f96c <ip_raw_write>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_raw_write(PACKET p)
{
 323f96c:	defffc04 	addi	sp,sp,-16
 323f970:	dfc00315 	stw	ra,12(sp)
 323f974:	df000215 	stw	fp,8(sp)
 323f978:	df000204 	addi	fp,sp,8
 323f97c:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 323f980:	0080c9b4 	movhi	r2,806
 323f984:	10b54b04 	addi	r2,r2,-10964
 323f988:	10800917 	ldw	r2,36(r2)
 323f98c:	10c00044 	addi	r3,r2,1
 323f990:	0080c9b4 	movhi	r2,806
 323f994:	10b54b04 	addi	r2,r2,-10964
 323f998:	10c00915 	stw	r3,36(r2)

   /* form a pointer to IP header (pip) */
   pip = (struct ip*)(p->nb_prot);
 323f99c:	e0bfff17 	ldw	r2,-4(fp)
 323f9a0:	10800317 	ldw	r2,12(r2)
 323f9a4:	e0bffe15 	stw	r2,-8(fp)
   
   /* if there's no IP id, give it one */
   if (pip->ip_id == 0)
 323f9a8:	e0bffe17 	ldw	r2,-8(fp)
 323f9ac:	1080010b 	ldhu	r2,4(r2)
 323f9b0:	10bfffcc 	andi	r2,r2,65535
 323f9b4:	1004c03a 	cmpne	r2,r2,zero
 323f9b8:	1000121e 	bne	r2,zero,323fa04 <ip_raw_write+0x98>
   {
      pip->ip_id = htons((unshort)uid);
 323f9bc:	d0a04c17 	ldw	r2,-32464(gp)
 323f9c0:	10bfffcc 	andi	r2,r2,65535
 323f9c4:	1004d23a 	srli	r2,r2,8
 323f9c8:	10803fcc 	andi	r2,r2,255
 323f9cc:	1009883a 	mov	r4,r2
 323f9d0:	d0a04c17 	ldw	r2,-32464(gp)
 323f9d4:	10bfffcc 	andi	r2,r2,65535
 323f9d8:	1004923a 	slli	r2,r2,8
 323f9dc:	1007883a 	mov	r3,r2
 323f9e0:	00bfc004 	movi	r2,-256
 323f9e4:	1884703a 	and	r2,r3,r2
 323f9e8:	2084b03a 	or	r2,r4,r2
 323f9ec:	1007883a 	mov	r3,r2
 323f9f0:	e0bffe17 	ldw	r2,-8(fp)
 323f9f4:	10c0010d 	sth	r3,4(r2)
      uid++;
 323f9f8:	d0a04c17 	ldw	r2,-32464(gp)
 323f9fc:	10800044 	addi	r2,r2,1
 323fa00:	d0a04c15 	stw	r2,-32464(gp)
   }

   /* checksum the IP header */
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 323fa04:	e0bffe17 	ldw	r2,-8(fp)
 323fa08:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 323fa0c:	e13ffe17 	ldw	r4,-8(fp)
 323fa10:	01400284 	movi	r5,10
 323fa14:	3225d5c0 	call	3225d5c <cksum>
 323fa18:	0084303a 	nor	r2,zero,r2
 323fa1c:	1007883a 	mov	r3,r2
 323fa20:	e0bffe17 	ldw	r2,-8(fp)
 323fa24:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 323fa28:	e13fff17 	ldw	r4,-4(fp)
 323fa2c:	323ebf40 	call	323ebf4 <ip_write_internal>
}
 323fa30:	e037883a 	mov	sp,fp
 323fa34:	dfc00117 	ldw	ra,4(sp)
 323fa38:	df000017 	ldw	fp,0(sp)
 323fa3c:	dec00204 	addi	sp,sp,8
 323fa40:	f800283a 	ret

0323fa44 <ip_fragment_lc>:
 *              invocation of ip2mac () for the last generated fragment
 */

int
ip_fragment_lc(PACKET p, ip_addr firsthop)
{
 323fa44:	deffed04 	addi	sp,sp,-76
 323fa48:	dfc01215 	stw	ra,72(sp)
 323fa4c:	df001115 	stw	fp,68(sp)
 323fa50:	df001104 	addi	fp,sp,68
 323fa54:	e13ffa15 	stw	r4,-24(fp)
 323fa58:	e17ffb15 	stw	r5,-20(fp)
   int      e;
   struct ip * pip;
   int      iphlen;     /* IP header length */
   unshort  tmp_fraginfo   ;

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 323fa5c:	0080c9b4 	movhi	r2,806
 323fa60:	10b54b04 	addi	r2,r2,-10964
 323fa64:	10801017 	ldw	r2,64(r2)
 323fa68:	10c00044 	addi	r3,r2,1
 323fa6c:	0080c9b4 	movhi	r2,806
 323fa70:	10b54b04 	addi	r2,r2,-10964
 323fa74:	10c01015 	stw	r3,64(r2)
   pip = (struct ip *)(p->nb_prot);          /* get ptr to IP header */
 323fa78:	e0bffa17 	ldw	r2,-24(fp)
 323fa7c:	10800317 	ldw	r2,12(r2)
 323fa80:	e0bff115 	stw	r2,-60(fp)
   iphlen = (pip->ip_ver_ihl & 0xf) << 2;    /* and its length */
 323fa84:	e0bff117 	ldw	r2,-60(fp)
 323fa88:	10800003 	ldbu	r2,0(r2)
 323fa8c:	10803fcc 	andi	r2,r2,255
 323fa90:	108003cc 	andi	r2,r2,15
 323fa94:	1085883a 	add	r2,r2,r2
 323fa98:	1085883a 	add	r2,r2,r2
 323fa9c:	e0bff015 	stw	r2,-64(fp)
   left = (int)p->nb_plen - iphlen; /* bytes left to send in datagram */
 323faa0:	e0bffa17 	ldw	r2,-24(fp)
 323faa4:	10800417 	ldw	r2,16(r2)
 323faa8:	1007883a 	mov	r3,r2
 323faac:	e0bff017 	ldw	r2,-64(fp)
 323fab0:	1885c83a 	sub	r2,r3,r2
 323fab4:	e0bff415 	stw	r2,-48(fp)
    * of fragments to get a fragment length that will result
    * in similarly-sized segments (remembering to round this
    * length up to a multiple of 8 because that's how the IP 
    * Fragment Offset field is scaled).
    */
   maxipsize = p->net->n_mtu - (iphlen + p->net->n_lnh + 8);   /* 8 == for rounding up */
 323fab8:	e0bffa17 	ldw	r2,-24(fp)
 323fabc:	10800617 	ldw	r2,24(r2)
 323fac0:	11000917 	ldw	r4,36(r2)
 323fac4:	e0bffa17 	ldw	r2,-24(fp)
 323fac8:	10800617 	ldw	r2,24(r2)
 323facc:	10c00817 	ldw	r3,32(r2)
 323fad0:	e0bff017 	ldw	r2,-64(fp)
 323fad4:	1885883a 	add	r2,r3,r2
 323fad8:	2085c83a 	sub	r2,r4,r2
 323fadc:	10bffe04 	addi	r2,r2,-8
 323fae0:	e0bff815 	stw	r2,-32(fp)
   if (maxipsize < 64)  /* to small to use */
 323fae4:	e0bff817 	ldw	r2,-32(fp)
 323fae8:	10801028 	cmpgeui	r2,r2,64
 323faec:	1000041e 	bne	r2,zero,323fb00 <ip_fragment_lc+0xbc>
   {
      dtrap();    /* probably bad programming */
 323faf0:	322aef00 	call	322aef0 <dtrap>
      return ENP_LOGIC;
 323faf4:	00bffd44 	movi	r2,-11
 323faf8:	e0bffe15 	stw	r2,-8(fp)
 323fafc:	0000ed06 	br	323feb4 <ip_fragment_lc+0x470>
   }
   numfrags = (p->nb_plen/maxipsize) + 1;    /* number of fragments */
 323fb00:	e0bffa17 	ldw	r2,-24(fp)
 323fb04:	11000417 	ldw	r4,16(r2)
 323fb08:	e17ff817 	ldw	r5,-32(fp)
 323fb0c:	32047c00 	call	32047c0 <__udivsi3>
 323fb10:	10800044 	addi	r2,r2,1
 323fb14:	e0bff715 	stw	r2,-36(fp)
   fragsize = (((p->nb_plen + (numfrags - 1)) / numfrags) + 7) & ~7; 
 323fb18:	e0bffa17 	ldw	r2,-24(fp)
 323fb1c:	10c00417 	ldw	r3,16(r2)
 323fb20:	e0bff717 	ldw	r2,-36(fp)
 323fb24:	1885883a 	add	r2,r3,r2
 323fb28:	113fffc4 	addi	r4,r2,-1
 323fb2c:	e17ff717 	ldw	r5,-36(fp)
 323fb30:	32047c00 	call	32047c0 <__udivsi3>
 323fb34:	10c001c4 	addi	r3,r2,7
 323fb38:	00bffe04 	movi	r2,-8
 323fb3c:	1884703a 	and	r2,r3,r2
 323fb40:	e0bff915 	stw	r2,-28(fp)
   foffset = 0;
 323fb44:	e03ff615 	stw	zero,-40(fp)

   /* Now update from any previous info */
   tmp_fraginfo = ntohs(pip->ip_flgs_foff);     /* get current frag info*/
 323fb48:	e0bff117 	ldw	r2,-60(fp)
 323fb4c:	1080018b 	ldhu	r2,6(r2)
 323fb50:	10bfffcc 	andi	r2,r2,65535
 323fb54:	1004d23a 	srli	r2,r2,8
 323fb58:	10803fcc 	andi	r2,r2,255
 323fb5c:	1009883a 	mov	r4,r2
 323fb60:	e0bff117 	ldw	r2,-60(fp)
 323fb64:	1080018b 	ldhu	r2,6(r2)
 323fb68:	10bfffcc 	andi	r2,r2,65535
 323fb6c:	1004923a 	slli	r2,r2,8
 323fb70:	1007883a 	mov	r3,r2
 323fb74:	00bfc004 	movi	r2,-256
 323fb78:	1884703a 	and	r2,r3,r2
 323fb7c:	2084b03a 	or	r2,r4,r2
 323fb80:	e0bfef0d 	sth	r2,-68(fp)
   if ( tmp_fraginfo & (~IP_FLG_MASK) )
 323fb84:	e0ffef0b 	ldhu	r3,-68(fp)
 323fb88:	00bffff4 	movhi	r2,65535
 323fb8c:	1087ffc4 	addi	r2,r2,8191
 323fb90:	1884703a 	and	r2,r3,r2
 323fb94:	1005003a 	cmpeq	r2,r2,zero
 323fb98:	1000081e 	bne	r2,zero,323fbbc <ip_fragment_lc+0x178>
   {
      /* When fragmenting an already fragmented packet, we need to
         add the initial offset */
      foffset = (tmp_fraginfo & (~IP_FLG_MASK))  ;
 323fb9c:	e0ffef0b 	ldhu	r3,-68(fp)
 323fba0:	00bffff4 	movhi	r2,65535
 323fba4:	1087ffc4 	addi	r2,r2,8191
 323fba8:	1884703a 	and	r2,r3,r2
 323fbac:	e0bff615 	stw	r2,-40(fp)
      foffset <<= 3;    /* Multiply by 8 to get "offset in num of bytes" */
 323fbb0:	e0bff617 	ldw	r2,-40(fp)
 323fbb4:	100490fa 	slli	r2,r2,3
 323fbb8:	e0bff615 	stw	r2,-40(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
 323fbbc:	e0bffa17 	ldw	r2,-24(fp)
 323fbc0:	e0bff315 	stw	r2,-52(fp)
   e = 0;
 323fbc4:	e03ff215 	stw	zero,-56(fp)
   while (left > 1)  /* more data left to send? */
 323fbc8:	0000b506 	br	323fea0 <ip_fragment_lc+0x45c>
   {
      p = pkt2;  /* move next fragment up */
 323fbcc:	e0bff317 	ldw	r2,-52(fp)
 323fbd0:	e0bffa15 	stw	r2,-24(fp)
      pip = (struct ip *)(p->nb_prot);
 323fbd4:	e0bffa17 	ldw	r2,-24(fp)
 323fbd8:	10800317 	ldw	r2,12(r2)
 323fbdc:	e0bff115 	stw	r2,-60(fp)
      p->nb_plen = min((int)fragsize, left) + iphlen; /* set size of fragment */
 323fbe0:	e0bff917 	ldw	r2,-28(fp)
 323fbe4:	e0fff417 	ldw	r3,-48(fp)
 323fbe8:	e0ffff15 	stw	r3,-4(fp)
 323fbec:	e0bffd15 	stw	r2,-12(fp)
 323fbf0:	e0bfff17 	ldw	r2,-4(fp)
 323fbf4:	e0fffd17 	ldw	r3,-12(fp)
 323fbf8:	10c0020e 	bge	r2,r3,323fc04 <ip_fragment_lc+0x1c0>
 323fbfc:	e0bfff17 	ldw	r2,-4(fp)
 323fc00:	e0bffd15 	stw	r2,-12(fp)
 323fc04:	e0bff017 	ldw	r2,-64(fp)
 323fc08:	e0fffd17 	ldw	r3,-12(fp)
 323fc0c:	1885883a 	add	r2,r3,r2
 323fc10:	1007883a 	mov	r3,r2
 323fc14:	e0bffa17 	ldw	r2,-24(fp)
 323fc18:	10c00415 	stw	r3,16(r2)
      left -= fragsize; /* decrement count of bytes left to send */
 323fc1c:	e0fff417 	ldw	r3,-48(fp)
 323fc20:	e0bff917 	ldw	r2,-28(fp)
 323fc24:	1885c83a 	sub	r2,r3,r2
 323fc28:	e0bff415 	stw	r2,-48(fp)

      /* set the IP datagram length */
      pip->ip_len = htons((unshort)p->nb_plen);
 323fc2c:	e0bffa17 	ldw	r2,-24(fp)
 323fc30:	10800417 	ldw	r2,16(r2)
 323fc34:	10bfffcc 	andi	r2,r2,65535
 323fc38:	1004d23a 	srli	r2,r2,8
 323fc3c:	10803fcc 	andi	r2,r2,255
 323fc40:	1009883a 	mov	r4,r2
 323fc44:	e0bffa17 	ldw	r2,-24(fp)
 323fc48:	10800417 	ldw	r2,16(r2)
 323fc4c:	10bfffcc 	andi	r2,r2,65535
 323fc50:	1004923a 	slli	r2,r2,8
 323fc54:	1007883a 	mov	r3,r2
 323fc58:	00bfc004 	movi	r2,-256
 323fc5c:	1884703a 	and	r2,r3,r2
 323fc60:	2084b03a 	or	r2,r4,r2
 323fc64:	1007883a 	mov	r3,r2
 323fc68:	e0bff117 	ldw	r2,-60(fp)
 323fc6c:	10c0008d 	sth	r3,2(r2)

      /* build 16bit IP header field value for fragment flags & offset */
      fraginfo = (unshort)(foffset >> 3);    /* offset, in 8 byte chunks */
 323fc70:	e0bff617 	ldw	r2,-40(fp)
 323fc74:	1004d0fa 	srli	r2,r2,3
 323fc78:	e0bff50d 	sth	r2,-44(fp)
      fraginfo |= ((left>1)?IP_FLG_MF:0);    /* OR in MoreFrags flag */
 323fc7c:	e0bff417 	ldw	r2,-48(fp)
 323fc80:	10800090 	cmplti	r2,r2,2
 323fc84:	1000031e 	bne	r2,zero,323fc94 <ip_fragment_lc+0x250>
 323fc88:	00880004 	movi	r2,8192
 323fc8c:	e0bffc0d 	sth	r2,-16(fp)
 323fc90:	00000106 	br	323fc98 <ip_fragment_lc+0x254>
 323fc94:	e03ffc0d 	sth	zero,-16(fp)
 323fc98:	e0bff50b 	ldhu	r2,-44(fp)
 323fc9c:	e0fffc0b 	ldhu	r3,-16(fp)
 323fca0:	1884b03a 	or	r2,r3,r2
 323fca4:	e0bff50d 	sth	r2,-44(fp)

      if ( tmp_fraginfo & IP_FLG_MF )             
 323fca8:	e0bfef0b 	ldhu	r2,-68(fp)
 323fcac:	1088000c 	andi	r2,r2,8192
 323fcb0:	1005003a 	cmpeq	r2,r2,zero
 323fcb4:	1000031e 	bne	r2,zero,323fcc4 <ip_fragment_lc+0x280>
      {
         /* As flag is set in main packet, it should be set in all
          * fragmented packets also 
          */
         fraginfo |= IP_FLG_MF;
 323fcb8:	e0bff50b 	ldhu	r2,-44(fp)
 323fcbc:	10880014 	ori	r2,r2,8192
 323fcc0:	e0bff50d 	sth	r2,-44(fp)
      }

      pip->ip_flgs_foff = htons(fraginfo);   /* do htons macro on separate line */
 323fcc4:	e0bff50b 	ldhu	r2,-44(fp)
 323fcc8:	1004d23a 	srli	r2,r2,8
 323fccc:	10803fcc 	andi	r2,r2,255
 323fcd0:	1009883a 	mov	r4,r2
 323fcd4:	e0bff50b 	ldhu	r2,-44(fp)
 323fcd8:	1004923a 	slli	r2,r2,8
 323fcdc:	1007883a 	mov	r3,r2
 323fce0:	00bfc004 	movi	r2,-256
 323fce4:	1884703a 	and	r2,r3,r2
 323fce8:	2084b03a 	or	r2,r4,r2
 323fcec:	1007883a 	mov	r3,r2
 323fcf0:	e0bff117 	ldw	r2,-60(fp)
 323fcf4:	10c0018d 	sth	r3,6(r2)
      /* set up & save next fragment (pkt2) since ip2mac() will delete p */
      if (left > 1)
 323fcf8:	e0bff417 	ldw	r2,-48(fp)
 323fcfc:	10800090 	cmplti	r2,r2,2
 323fd00:	1000401e 	bne	r2,zero,323fe04 <ip_fragment_lc+0x3c0>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 323fd04:	01000084 	movi	r4,2
 323fd08:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pkt2 = pk_alloc(left + iphlen + MaxLnh);
 323fd0c:	e0fff417 	ldw	r3,-48(fp)
 323fd10:	e0bff017 	ldw	r2,-64(fp)
 323fd14:	1887883a 	add	r3,r3,r2
 323fd18:	0080c974 	movhi	r2,805
 323fd1c:	10931a04 	addi	r2,r2,19560
 323fd20:	10800017 	ldw	r2,0(r2)
 323fd24:	1885883a 	add	r2,r3,r2
 323fd28:	1009883a 	mov	r4,r2
 323fd2c:	322a2ac0 	call	322a2ac <pk_alloc>
 323fd30:	e0bff315 	stw	r2,-52(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323fd34:	01000084 	movi	r4,2
 323fd38:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         if (!pkt2)
 323fd3c:	e0bff317 	ldw	r2,-52(fp)
 323fd40:	1004c03a 	cmpne	r2,r2,zero
 323fd44:	1000111e 	bne	r2,zero,323fd8c <ip_fragment_lc+0x348>
         {
            dtrap();
 323fd48:	322aef00 	call	322aef0 <dtrap>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 323fd4c:	01000084 	movi	r4,2
 323fd50:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
            pk_free(p);
 323fd54:	e13ffa17 	ldw	r4,-24(fp)
 323fd58:	322a6400 	call	322a640 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323fd5c:	01000084 	movi	r4,2
 323fd60:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 323fd64:	0080c9b4 	movhi	r2,806
 323fd68:	10b54b04 	addi	r2,r2,-10964
 323fd6c:	10801117 	ldw	r2,68(r2)
 323fd70:	10c00044 	addi	r3,r2,1
 323fd74:	0080c9b4 	movhi	r2,806
 323fd78:	10b54b04 	addi	r2,r2,-10964
 323fd7c:	10c01115 	stw	r3,68(r2)
            return ENP_RESOURCE;
 323fd80:	00bffa84 	movi	r2,-22
 323fd84:	e0bffe15 	stw	r2,-8(fp)
 323fd88:	00004a06 	br	323feb4 <ip_fragment_lc+0x470>
         }

         pkt2->net = p->net;       /* copy critical parms to new packet */
 323fd8c:	e0bffa17 	ldw	r2,-24(fp)
 323fd90:	10c00617 	ldw	r3,24(r2)
 323fd94:	e0bff317 	ldw	r2,-52(fp)
 323fd98:	10c00615 	stw	r3,24(r2)
         pkt2->fhost = p->fhost;
 323fd9c:	e0bffa17 	ldw	r2,-24(fp)
 323fda0:	10c00717 	ldw	r3,28(r2)
 323fda4:	e0bff317 	ldw	r2,-52(fp)
 323fda8:	10c00715 	stw	r3,28(r2)
         /* Duplicate the IPHeader */
         MEMCPY(pkt2->nb_prot, p->nb_prot, iphlen);
 323fdac:	e0bff317 	ldw	r2,-52(fp)
 323fdb0:	11000317 	ldw	r4,12(r2)
 323fdb4:	e0bffa17 	ldw	r2,-24(fp)
 323fdb8:	10800317 	ldw	r2,12(r2)
 323fdbc:	e0fff017 	ldw	r3,-64(fp)
 323fdc0:	100b883a 	mov	r5,r2
 323fdc4:	180d883a 	mov	r6,r3
 323fdc8:	3206ad00 	call	3206ad0 <memcpy>
         /* copy data for NEXT fragment from p to pkt2 */
         MEMCPY(pkt2->nb_prot + iphlen, p->nb_prot + iphlen + fragsize, left);
 323fdcc:	e0bff317 	ldw	r2,-52(fp)
 323fdd0:	10c00317 	ldw	r3,12(r2)
 323fdd4:	e0bff017 	ldw	r2,-64(fp)
 323fdd8:	1889883a 	add	r4,r3,r2
 323fddc:	e0bffa17 	ldw	r2,-24(fp)
 323fde0:	10c00317 	ldw	r3,12(r2)
 323fde4:	e0bff017 	ldw	r2,-64(fp)
 323fde8:	1887883a 	add	r3,r3,r2
 323fdec:	e0bff917 	ldw	r2,-28(fp)
 323fdf0:	1885883a 	add	r2,r3,r2
 323fdf4:	e0fff417 	ldw	r3,-48(fp)
 323fdf8:	100b883a 	mov	r5,r2
 323fdfc:	180d883a 	mov	r6,r3
 323fe00:	3206ad00 	call	3206ad0 <memcpy>
      }

      /* we've changed the IP header, so recalculate the checksum */
      pip->ip_chksum = IPXSUM;
 323fe04:	e0bff117 	ldw	r2,-60(fp)
 323fe08:	1000028d 	sth	zero,10(r2)
      pip->ip_chksum = ~cksum(pip, 10);
 323fe0c:	e13ff117 	ldw	r4,-60(fp)
 323fe10:	01400284 	movi	r5,10
 323fe14:	3225d5c0 	call	3225d5c <cksum>
 323fe18:	0084303a 	nor	r2,zero,r2
 323fe1c:	1007883a 	mov	r3,r2
 323fe20:	e0bff117 	ldw	r2,-60(fp)
 323fe24:	10c0028d 	sth	r3,10(r2)

      /* ip_dump(p); */

      e = ip2mac(p, firsthop);   /* send fragment in p */
 323fe28:	e13ffa17 	ldw	r4,-24(fp)
 323fe2c:	e17ffb17 	ldw	r5,-20(fp)
 323fe30:	3223af80 	call	3223af8 <ip2mac>
 323fe34:	e0bff215 	stw	r2,-56(fp)
      ip_mib.ipFragCreates++;
 323fe38:	0080c9b4 	movhi	r2,806
 323fe3c:	10b54b04 	addi	r2,r2,-10964
 323fe40:	10801217 	ldw	r2,72(r2)
 323fe44:	10c00044 	addi	r3,r2,1
 323fe48:	0080c9b4 	movhi	r2,806
 323fe4c:	10b54b04 	addi	r2,r2,-10964
 323fe50:	10c01215 	stw	r3,72(r2)
      if (e < 0)
 323fe54:	e0bff217 	ldw	r2,-56(fp)
 323fe58:	1004403a 	cmpge	r2,r2,zero
 323fe5c:	10000c1e 	bne	r2,zero,323fe90 <ip_fragment_lc+0x44c>
      {
         if (left > 1) 
 323fe60:	e0bff417 	ldw	r2,-48(fp)
 323fe64:	10800090 	cmplti	r2,r2,2
 323fe68:	1000061e 	bne	r2,zero,323fe84 <ip_fragment_lc+0x440>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 323fe6c:	01000084 	movi	r4,2
 323fe70:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
            pk_free(pkt2);
 323fe74:	e13ff317 	ldw	r4,-52(fp)
 323fe78:	322a6400 	call	322a640 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323fe7c:	01000084 	movi	r4,2
 323fe80:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         }
         return e;
 323fe84:	e0fff217 	ldw	r3,-56(fp)
 323fe88:	e0fffe15 	stw	r3,-8(fp)
 323fe8c:	00000906 	br	323feb4 <ip_fragment_lc+0x470>
      }
      foffset += fragsize;    /* offset for next fragment */
 323fe90:	e0bff617 	ldw	r2,-40(fp)
 323fe94:	e0fff917 	ldw	r3,-28(fp)
 323fe98:	10c5883a 	add	r2,r2,r3
 323fe9c:	e0bff615 	stw	r2,-40(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
   e = 0;
   while (left > 1)  /* more data left to send? */
 323fea0:	e0bff417 	ldw	r2,-48(fp)
 323fea4:	10800088 	cmpgei	r2,r2,2
 323fea8:	103f481e 	bne	r2,zero,323fbcc <ip_fragment_lc+0x188>
         }
         return e;
      }
      foffset += fragsize;    /* offset for next fragment */
   }
   return e;
 323feac:	e0bff217 	ldw	r2,-56(fp)
 323feb0:	e0bffe15 	stw	r2,-8(fp)
 323feb4:	e0bffe17 	ldw	r2,-8(fp)
}
 323feb8:	e037883a 	mov	sp,fp
 323febc:	dfc00117 	ldw	ra,4(sp)
 323fec0:	df000017 	ldw	fp,0(sp)
 323fec4:	dec00204 	addi	sp,sp,8
 323fec8:	f800283a 	ret

0323fecc <ip_fragment>:
 *              generated fragment, if less than zero
 *          (5) 0, if everything went okay
 */

int ip_fragment(PACKET p, ip_addr firsthop)
{
 323fecc:	deffed04 	addi	sp,sp,-76
 323fed0:	dfc01215 	stw	ra,72(sp)
 323fed4:	df001115 	stw	fp,68(sp)
 323fed8:	df001104 	addi	fp,sp,68
 323fedc:	e13ffa15 	stw	r4,-24(fp)
 323fee0:	e17ffb15 	stw	r5,-20(fp)
   u_short parent_mf;
   PACKET newpkt;
   struct ip * newpip;
   int e;

   pip = ip_head(p);
 323fee4:	e0bffa17 	ldw	r2,-24(fp)
 323fee8:	10800317 	ldw	r2,12(r2)
 323feec:	e0bff815 	stw	r2,-32(fp)
   if ((ntohs(pip->ip_flgs_foff)) & IP_FLG_DF)
 323fef0:	e0bff817 	ldw	r2,-32(fp)
 323fef4:	1080018b 	ldhu	r2,6(r2)
 323fef8:	10bfffcc 	andi	r2,r2,65535
 323fefc:	1004d23a 	srli	r2,r2,8
 323ff00:	10bfffcc 	andi	r2,r2,65535
 323ff04:	10c03fcc 	andi	r3,r2,255
 323ff08:	e0bff817 	ldw	r2,-32(fp)
 323ff0c:	1080018b 	ldhu	r2,6(r2)
 323ff10:	10bfffcc 	andi	r2,r2,65535
 323ff14:	1004923a 	slli	r2,r2,8
 323ff18:	10bfc00c 	andi	r2,r2,65280
 323ff1c:	1884b03a 	or	r2,r3,r2
 323ff20:	1090000c 	andi	r2,r2,16384
 323ff24:	1005003a 	cmpeq	r2,r2,zero
 323ff28:	10001a1e 	bne	r2,zero,323ff94 <ip_fragment+0xc8>
   {
      /* can't fragment a packet with the DF bit set */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 323ff2c:	01000084 	movi	r4,2
 323ff30:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(p);
 323ff34:	e13ffa17 	ldw	r4,-24(fp)
 323ff38:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 323ff3c:	01000084 	movi	r4,2
 323ff40:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      ip_mib.ipFragFails++;
 323ff44:	0080c9b4 	movhi	r2,806
 323ff48:	10b54b04 	addi	r2,r2,-10964
 323ff4c:	10801117 	ldw	r2,68(r2)
 323ff50:	10c00044 	addi	r3,r2,1
 323ff54:	0080c9b4 	movhi	r2,806
 323ff58:	10b54b04 	addi	r2,r2,-10964
 323ff5c:	10c01115 	stw	r3,68(r2)
#ifdef FULL_ICMP
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 323ff60:	e0bff817 	ldw	r2,-32(fp)
 323ff64:	11000317 	ldw	r4,12(r2)
 323ff68:	e0bffa17 	ldw	r2,-24(fp)
 323ff6c:	10800617 	ldw	r2,24(r2)
 323ff70:	11400a17 	ldw	r5,40(r2)
 323ff74:	e0bffa17 	ldw	r2,-24(fp)
 323ff78:	10800617 	ldw	r2,24(r2)
 323ff7c:	d8800015 	stw	r2,0(sp)
 323ff80:	e1bff817 	ldw	r6,-32(fp)
 323ff84:	01c00104 	movi	r7,4
 323ff88:	324b5400 	call	324b540 <icmp_destun>
#endif   /* FULL_ICMP */
      return 0;
 323ff8c:	e03ffe15 	stw	zero,-8(fp)
 323ff90:	00015106 	br	32404d8 <ip_fragment+0x60c>
   }

   maxbuflen = pk_get_max_intrsafe_buf_len ();
 323ff94:	322a6ec0 	call	322a6ec <pk_get_max_intrsafe_buf_len>
 323ff98:	e0bff915 	stw	r2,-28(fp)

   /* the maximum amount of data that will be sent to ip2mac ().  Please note that
    * our definition of MTU is different from the traditional definition of that
    * parameter (which excludes the data link layer header). */
   maxl3_len = (unsigned short int) (MIN(maxbuflen, ((unsigned) p->net->n_mtu)));
 323ff9c:	e0bffa17 	ldw	r2,-24(fp)
 323ffa0:	10800617 	ldw	r2,24(r2)
 323ffa4:	10800917 	ldw	r2,36(r2)
 323ffa8:	e0fff917 	ldw	r3,-28(fp)
 323ffac:	e0ffff15 	stw	r3,-4(fp)
 323ffb0:	e0bffd15 	stw	r2,-12(fp)
 323ffb4:	e0bfff17 	ldw	r2,-4(fp)
 323ffb8:	e0fffd17 	ldw	r3,-12(fp)
 323ffbc:	10c0022e 	bgeu	r2,r3,323ffc8 <ip_fragment+0xfc>
 323ffc0:	e0bfff17 	ldw	r2,-4(fp)
 323ffc4:	e0bffd15 	stw	r2,-12(fp)
 323ffc8:	e0fffd17 	ldw	r3,-12(fp)
 323ffcc:	e0fff58d 	sth	r3,-42(fp)

   /* get the length of the IP header of the original, unfragmented datagram */
   iphlen = ip_hlen(pip);
 323ffd0:	e0bff817 	ldw	r2,-32(fp)
 323ffd4:	10800003 	ldbu	r2,0(r2)
 323ffd8:	108003cc 	andi	r2,r2,15
 323ffdc:	1085883a 	add	r2,r2,r2
 323ffe0:	1085883a 	add	r2,r2,r2
 323ffe4:	e0bff7c5 	stb	r2,-33(fp)

   /* obtain the useable payload length in an IP datagram (after accounting for the 
    * length of the IP and data link layer headers) */
   l2hdr_len = (u_char) p->net->n_lnh;
 323ffe8:	e0bffa17 	ldw	r2,-24(fp)
 323ffec:	10800617 	ldw	r2,24(r2)
 323fff0:	10800817 	ldw	r2,32(r2)
 323fff4:	e0bff785 	stb	r2,-34(fp)
   useable_payload_len = maxl3_len - iphlen - l2hdr_len;
 323fff8:	e0fff7c3 	ldbu	r3,-33(fp)
 323fffc:	e0bff58b 	ldhu	r2,-42(fp)
 3240000:	10c5c83a 	sub	r2,r2,r3
 3240004:	1007883a 	mov	r3,r2
 3240008:	e0bff783 	ldbu	r2,-34(fp)
 324000c:	1885c83a 	sub	r2,r3,r2
 3240010:	e0bff70d 	sth	r2,-36(fp)

   /* IP fragments must always have a length that is a multiple of 8 bytes, so we
    * need to round 'payload_len' down to the nearest multiple of 8 bytes. */
   useable_payload_len &= (~((unsigned short int) 0x07));
 3240014:	e0fff70b 	ldhu	r3,-36(fp)
 3240018:	00bffe04 	movi	r2,-8
 324001c:	1884703a 	and	r2,r3,r2
 3240020:	e0bff70d 	sth	r2,-36(fp)

   /* compute the number of packets that we need to send.  First compute the total
    * payload length of the "original" datagram (which could itself be a fragment). 
    */
   total_payload_len = (ntohs(pip->ip_len)) - iphlen;
 3240024:	e0bff817 	ldw	r2,-32(fp)
 3240028:	1080008b 	ldhu	r2,2(r2)
 324002c:	10bfffcc 	andi	r2,r2,65535
 3240030:	1004d23a 	srli	r2,r2,8
 3240034:	10803fcc 	andi	r2,r2,255
 3240038:	1009883a 	mov	r4,r2
 324003c:	e0bff817 	ldw	r2,-32(fp)
 3240040:	1080008b 	ldhu	r2,2(r2)
 3240044:	10bfffcc 	andi	r2,r2,65535
 3240048:	1004923a 	slli	r2,r2,8
 324004c:	1007883a 	mov	r3,r2
 3240050:	00bfc004 	movi	r2,-256
 3240054:	1884703a 	and	r2,r3,r2
 3240058:	2084b03a 	or	r2,r4,r2
 324005c:	1007883a 	mov	r3,r2
 3240060:	e0bff7c3 	ldbu	r2,-33(fp)
 3240064:	1885c83a 	sub	r2,r3,r2
 3240068:	e0bff68d 	sth	r2,-38(fp)
   num_frags = (total_payload_len / useable_payload_len);
 324006c:	e13ff68b 	ldhu	r4,-38(fp)
 3240070:	e17ff70b 	ldhu	r5,-36(fp)
 3240074:	32047c00 	call	32047c0 <__udivsi3>
 3240078:	e0bff50d 	sth	r2,-44(fp)
   if ((last_payload_len = (total_payload_len % useable_payload_len)) != 0)
 324007c:	e13ff68b 	ldhu	r4,-38(fp)
 3240080:	e17ff70b 	ldhu	r5,-36(fp)
 3240084:	32047c80 	call	32047c8 <__umodsi3>
 3240088:	e0bff60d 	sth	r2,-40(fp)
 324008c:	e0bff60b 	ldhu	r2,-40(fp)
 3240090:	1005003a 	cmpeq	r2,r2,zero
 3240094:	1000031e 	bne	r2,zero,32400a4 <ip_fragment+0x1d8>
   {
      /* we will have one additional (also last) fragment that is smaller than the 
       * other fragments */
      ++num_frags;
 3240098:	e0bff50b 	ldhu	r2,-44(fp)
 324009c:	10800044 	addi	r2,r2,1
 32400a0:	e0bff50d 	sth	r2,-44(fp)
    * the one passed to this function) is interrupt-safe, then we use 
    * ip_fragment_lc () for creating the child fragments.  This decreases the 
    * amount of copying that needs to be done in those cases (as compared to this 
    * function); however, for larger packets, ip_fragment () becomes more efficient 
    * (than ip_fragment_lc ()). */
   if ((num_frags <= FRAG_SCHEME_SWITCH_THRESHOLD) && (!(p->flags & PKF_INTRUNSAFE)))
 32400a4:	e0bff50b 	ldhu	r2,-44(fp)
 32400a8:	10800128 	cmpgeui	r2,r2,4
 32400ac:	10000a1e 	bne	r2,zero,32400d8 <ip_fragment+0x20c>
 32400b0:	e0bffa17 	ldw	r2,-24(fp)
 32400b4:	10800a17 	ldw	r2,40(r2)
 32400b8:	1080040c 	andi	r2,r2,16
 32400bc:	1004c03a 	cmpne	r2,r2,zero
 32400c0:	1000051e 	bne	r2,zero,32400d8 <ip_fragment+0x20c>
   {
      return (ip_fragment_lc (p, firsthop));
 32400c4:	e13ffa17 	ldw	r4,-24(fp)
 32400c8:	e17ffb17 	ldw	r5,-20(fp)
 32400cc:	323fa440 	call	323fa44 <ip_fragment_lc>
 32400d0:	e0bffe15 	stw	r2,-8(fp)
 32400d4:	00010006 	br	32404d8 <ip_fragment+0x60c>
   }

   parent_frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 32400d8:	e0bff817 	ldw	r2,-32(fp)
 32400dc:	1080018b 	ldhu	r2,6(r2)
 32400e0:	10bfffcc 	andi	r2,r2,65535
 32400e4:	1004d23a 	srli	r2,r2,8
 32400e8:	10803fcc 	andi	r2,r2,255
 32400ec:	1009883a 	mov	r4,r2
 32400f0:	e0bff817 	ldw	r2,-32(fp)
 32400f4:	1080018b 	ldhu	r2,6(r2)
 32400f8:	10bfffcc 	andi	r2,r2,65535
 32400fc:	1004923a 	slli	r2,r2,8
 3240100:	1007883a 	mov	r3,r2
 3240104:	00bfc004 	movi	r2,-256
 3240108:	1884703a 	and	r2,r3,r2
 324010c:	2084b03a 	or	r2,r4,r2
 3240110:	1087ffcc 	andi	r2,r2,8191
 3240114:	100490fa 	slli	r2,r2,3
 3240118:	e0bff38d 	sth	r2,-50(fp)
   parent_mf = ((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF);
 324011c:	e0bff817 	ldw	r2,-32(fp)
 3240120:	1080018b 	ldhu	r2,6(r2)
 3240124:	10bfffcc 	andi	r2,r2,65535
 3240128:	1004d23a 	srli	r2,r2,8
 324012c:	10803fcc 	andi	r2,r2,255
 3240130:	1009883a 	mov	r4,r2
 3240134:	e0bff817 	ldw	r2,-32(fp)
 3240138:	1080018b 	ldhu	r2,6(r2)
 324013c:	10bfffcc 	andi	r2,r2,65535
 3240140:	1004923a 	slli	r2,r2,8
 3240144:	1007883a 	mov	r3,r2
 3240148:	00bfc004 	movi	r2,-256
 324014c:	1884703a 	and	r2,r3,r2
 3240150:	2084b03a 	or	r2,r4,r2
 3240154:	1088000c 	andi	r2,r2,8192
 3240158:	e0bff30d 	sth	r2,-52(fp)
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 324015c:	e03ff48d 	sth	zero,-46(fp)
 3240160:	0000cc06 	br	3240494 <ip_fragment+0x5c8>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 3240164:	01000084 	movi	r4,2
 3240168:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      newpkt = pk_alloc (useable_payload_len + iphlen + l2hdr_len); 
 324016c:	e0fff70b 	ldhu	r3,-36(fp)
 3240170:	e0bff7c3 	ldbu	r2,-33(fp)
 3240174:	1887883a 	add	r3,r3,r2
 3240178:	e0bff783 	ldbu	r2,-34(fp)
 324017c:	1885883a 	add	r2,r3,r2
 3240180:	1009883a 	mov	r4,r2
 3240184:	322a2ac0 	call	322a2ac <pk_alloc>
 3240188:	e0bff215 	stw	r2,-56(fp)
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324018c:	01000084 	movi	r4,2
 3240190:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

      if (newpkt == 0)
 3240194:	e0bff217 	ldw	r2,-56(fp)
 3240198:	1004c03a 	cmpne	r2,r2,zero
 324019c:	1000101e 	bne	r2,zero,32401e0 <ip_fragment+0x314>
      {
         /* free the packet that we are working with */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 32401a0:	01000084 	movi	r4,2
 32401a4:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pk_free(p);
 32401a8:	e13ffa17 	ldw	r4,-24(fp)
 32401ac:	322a6400 	call	322a640 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32401b0:	01000084 	movi	r4,2
 32401b4:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         ip_mib.ipFragFails++;
 32401b8:	0080c9b4 	movhi	r2,806
 32401bc:	10b54b04 	addi	r2,r2,-10964
 32401c0:	10801117 	ldw	r2,68(r2)
 32401c4:	10c00044 	addi	r3,r2,1
 32401c8:	0080c9b4 	movhi	r2,806
 32401cc:	10b54b04 	addi	r2,r2,-10964
 32401d0:	10c01115 	stw	r3,68(r2)
         return ENP_NOBUFFER;
 32401d4:	00bffac4 	movi	r2,-21
 32401d8:	e0bffe15 	stw	r2,-8(fp)
 32401dc:	0000be06 	br	32404d8 <ip_fragment+0x60c>
      }
      else
      {
         /* copy the IP header from the original datagram into the fragment */
         MEMCPY((newpkt->nb_buff + l2hdr_len), p->nb_prot, iphlen);
 32401e0:	e0bff217 	ldw	r2,-56(fp)
 32401e4:	10c00117 	ldw	r3,4(r2)
 32401e8:	e0bff783 	ldbu	r2,-34(fp)
 32401ec:	1889883a 	add	r4,r3,r2
 32401f0:	e0bffa17 	ldw	r2,-24(fp)
 32401f4:	10800317 	ldw	r2,12(r2)
 32401f8:	e0fff7c3 	ldbu	r3,-33(fp)
 32401fc:	100b883a 	mov	r5,r2
 3240200:	180d883a 	mov	r6,r3
 3240204:	3206ad00 	call	3206ad0 <memcpy>

         /* compute the amount of payload that needs to be copied into each 
          * child fragment */
         if (i < (num_frags - 1))
 3240208:	e0fff48b 	ldhu	r3,-46(fp)
 324020c:	e0bff50b 	ldhu	r2,-44(fp)
 3240210:	10bfffc4 	addi	r2,r2,-1
 3240214:	1880030e 	bge	r3,r2,3240224 <ip_fragment+0x358>
         {
            amt_to_copy = useable_payload_len;
 3240218:	e0bff70b 	ldhu	r2,-36(fp)
 324021c:	e0bff40d 	sth	r2,-48(fp)
 3240220:	00000a06 	br	324024c <ip_fragment+0x380>
         }
         else
         {
            amt_to_copy = ((last_payload_len == 0) ? useable_payload_len : last_payload_len);
 3240224:	e0bff60b 	ldhu	r2,-40(fp)
 3240228:	1004c03a 	cmpne	r2,r2,zero
 324022c:	1000031e 	bne	r2,zero,324023c <ip_fragment+0x370>
 3240230:	e0fff70b 	ldhu	r3,-36(fp)
 3240234:	e0fffc0d 	sth	r3,-16(fp)
 3240238:	00000206 	br	3240244 <ip_fragment+0x378>
 324023c:	e0bff60b 	ldhu	r2,-40(fp)
 3240240:	e0bffc0d 	sth	r2,-16(fp)
 3240244:	e0fffc0b 	ldhu	r3,-16(fp)
 3240248:	e0fff40d 	sth	r3,-48(fp)
         }
         MEMCPY((newpkt->nb_buff + l2hdr_len + iphlen), p->nb_prot + iphlen + (useable_payload_len * i), amt_to_copy);
 324024c:	e0bff217 	ldw	r2,-56(fp)
 3240250:	10c00117 	ldw	r3,4(r2)
 3240254:	e0bff783 	ldbu	r2,-34(fp)
 3240258:	1887883a 	add	r3,r3,r2
 324025c:	e0bff7c3 	ldbu	r2,-33(fp)
 3240260:	188b883a 	add	r5,r3,r2
 3240264:	e0bffa17 	ldw	r2,-24(fp)
 3240268:	10c00317 	ldw	r3,12(r2)
 324026c:	e0bff7c3 	ldbu	r2,-33(fp)
 3240270:	1889883a 	add	r4,r3,r2
 3240274:	e0fff70b 	ldhu	r3,-36(fp)
 3240278:	e0bff48b 	ldhu	r2,-46(fp)
 324027c:	1885383a 	mul	r2,r3,r2
 3240280:	2085883a 	add	r2,r4,r2
 3240284:	e0fff40b 	ldhu	r3,-48(fp)
 3240288:	2809883a 	mov	r4,r5
 324028c:	100b883a 	mov	r5,r2
 3240290:	180d883a 	mov	r6,r3
 3240294:	3206ad00 	call	3206ad0 <memcpy>

         /* set up the various netbuf fields for the fragment */
         newpkt->nb_prot = newpkt->nb_buff + l2hdr_len;
 3240298:	e0bff217 	ldw	r2,-56(fp)
 324029c:	10c00117 	ldw	r3,4(r2)
 32402a0:	e0bff783 	ldbu	r2,-34(fp)
 32402a4:	1887883a 	add	r3,r3,r2
 32402a8:	e0bff217 	ldw	r2,-56(fp)
 32402ac:	10c00315 	stw	r3,12(r2)
         newpkt->nb_plen = iphlen + amt_to_copy;
 32402b0:	e0fff7c3 	ldbu	r3,-33(fp)
 32402b4:	e0bff40b 	ldhu	r2,-48(fp)
 32402b8:	1885883a 	add	r2,r3,r2
 32402bc:	1007883a 	mov	r3,r2
 32402c0:	e0bff217 	ldw	r2,-56(fp)
 32402c4:	10c00415 	stw	r3,16(r2)
         newpkt->net = p->net;
 32402c8:	e0bffa17 	ldw	r2,-24(fp)
 32402cc:	10c00617 	ldw	r3,24(r2)
 32402d0:	e0bff217 	ldw	r2,-56(fp)
 32402d4:	10c00615 	stw	r3,24(r2)
         newpkt->fhost = p->fhost;
 32402d8:	e0bffa17 	ldw	r2,-24(fp)
 32402dc:	10c00717 	ldw	r3,28(r2)
 32402e0:	e0bff217 	ldw	r2,-56(fp)
 32402e4:	10c00715 	stw	r3,28(r2)
         /* type and nb_tstamp fields are not used in the egress direction, but we set 'type' anyway */
         newpkt->type = htons(IPTP);
 32402e8:	e0fff217 	ldw	r3,-56(fp)
 32402ec:	00820004 	movi	r2,2048
 32402f0:	1880080d 	sth	r2,32(r3)

         /* now set the Total Length, Fragment Offset, and More Fragments fields */
         newpip = ip_head(newpkt);
 32402f4:	e0bff217 	ldw	r2,-56(fp)
 32402f8:	10800317 	ldw	r2,12(r2)
 32402fc:	e0bff115 	stw	r2,-60(fp)
         newpip->ip_len = htons(newpkt->nb_plen);
 3240300:	e0bff217 	ldw	r2,-56(fp)
 3240304:	10800417 	ldw	r2,16(r2)
 3240308:	1004d23a 	srli	r2,r2,8
 324030c:	10803fcc 	andi	r2,r2,255
 3240310:	1009883a 	mov	r4,r2
 3240314:	e0bff217 	ldw	r2,-56(fp)
 3240318:	10800417 	ldw	r2,16(r2)
 324031c:	1004923a 	slli	r2,r2,8
 3240320:	1007883a 	mov	r3,r2
 3240324:	00bfc004 	movi	r2,-256
 3240328:	1884703a 	and	r2,r3,r2
 324032c:	2084b03a 	or	r2,r4,r2
 3240330:	1007883a 	mov	r3,r2
 3240334:	e0bff117 	ldw	r2,-60(fp)
 3240338:	10c0008d 	sth	r3,2(r2)
         /* the following statement will reset DF and MF bits */
         newpip->ip_flgs_foff = htons((parent_frag_offset + (useable_payload_len * i)) >> 3);
 324033c:	e13ff38b 	ldhu	r4,-50(fp)
 3240340:	e0fff70b 	ldhu	r3,-36(fp)
 3240344:	e0bff48b 	ldhu	r2,-46(fp)
 3240348:	1885383a 	mul	r2,r3,r2
 324034c:	2085883a 	add	r2,r4,r2
 3240350:	1005d2fa 	srai	r2,r2,11
 3240354:	10803fcc 	andi	r2,r2,255
 3240358:	100b883a 	mov	r5,r2
 324035c:	e13ff38b 	ldhu	r4,-50(fp)
 3240360:	e0fff70b 	ldhu	r3,-36(fp)
 3240364:	e0bff48b 	ldhu	r2,-46(fp)
 3240368:	1885383a 	mul	r2,r3,r2
 324036c:	2085883a 	add	r2,r4,r2
 3240370:	1005d0fa 	srai	r2,r2,3
 3240374:	1004923a 	slli	r2,r2,8
 3240378:	1007883a 	mov	r3,r2
 324037c:	00bfc004 	movi	r2,-256
 3240380:	1884703a 	and	r2,r3,r2
 3240384:	2884b03a 	or	r2,r5,r2
 3240388:	1007883a 	mov	r3,r2
 324038c:	e0bff117 	ldw	r2,-60(fp)
 3240390:	10c0018d 	sth	r3,6(r2)
          *     child fragments but the last will have the MF bit set)
          * (2) Parent fragment offset = x, MF = 1: first or middle fragment (FF or MF)
          *     (all child fragments will have the MF bit set)
          * (3) Parent fragment offset > 0, MF = 0: last fragment (LF) (all child fragments
          *     except the last will have the MF bit set) */
         if (i < (num_frags - 1))
 3240394:	e0fff48b 	ldhu	r3,-46(fp)
 3240398:	e0bff50b 	ldhu	r2,-44(fp)
 324039c:	10bfffc4 	addi	r2,r2,-1
 32403a0:	1880070e 	bge	r3,r2,32403c0 <ip_fragment+0x4f4>
         {
            newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 32403a4:	e0bff117 	ldw	r2,-60(fp)
 32403a8:	1080018b 	ldhu	r2,6(r2)
 32403ac:	10800814 	ori	r2,r2,32
 32403b0:	1007883a 	mov	r3,r2
 32403b4:	e0bff117 	ldw	r2,-60(fp)
 32403b8:	10c0018d 	sth	r3,6(r2)
 32403bc:	00000906 	br	32403e4 <ip_fragment+0x518>
         }
         else
         {
            if (parent_mf)
 32403c0:	e0bff30b 	ldhu	r2,-52(fp)
 32403c4:	1005003a 	cmpeq	r2,r2,zero
 32403c8:	1000061e 	bne	r2,zero,32403e4 <ip_fragment+0x518>
            {
               newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 32403cc:	e0bff117 	ldw	r2,-60(fp)
 32403d0:	1080018b 	ldhu	r2,6(r2)
 32403d4:	10800814 	ori	r2,r2,32
 32403d8:	1007883a 	mov	r3,r2
 32403dc:	e0bff117 	ldw	r2,-60(fp)
 32403e0:	10c0018d 	sth	r3,6(r2)
            }
         }

         /* finally, update the checksum */
         newpip->ip_chksum = IPXSUM;
 32403e4:	e0bff117 	ldw	r2,-60(fp)
 32403e8:	1000028d 	sth	zero,10(r2)
         newpip->ip_chksum = ~cksum(newpip, (iphlen/2));
 32403ec:	e0bff7c3 	ldbu	r2,-33(fp)
 32403f0:	1004d07a 	srli	r2,r2,1
 32403f4:	11403fcc 	andi	r5,r2,255
 32403f8:	e13ff117 	ldw	r4,-60(fp)
 32403fc:	3225d5c0 	call	3225d5c <cksum>
 3240400:	0084303a 	nor	r2,zero,r2
 3240404:	1007883a 	mov	r3,r2
 3240408:	e0bff117 	ldw	r2,-60(fp)
 324040c:	10c0028d 	sth	r3,10(r2)

         ip_mib.ipFragCreates++;
 3240410:	0080c9b4 	movhi	r2,806
 3240414:	10b54b04 	addi	r2,r2,-10964
 3240418:	10801217 	ldw	r2,72(r2)
 324041c:	10c00044 	addi	r3,r2,1
 3240420:	0080c9b4 	movhi	r2,806
 3240424:	10b54b04 	addi	r2,r2,-10964
 3240428:	10c01215 	stw	r3,72(r2)

         /* we're done; hand the packet off to ip2mac () */
         e = ip2mac (newpkt, firsthop);
 324042c:	e13ff217 	ldw	r4,-56(fp)
 3240430:	e17ffb17 	ldw	r5,-20(fp)
 3240434:	3223af80 	call	3223af8 <ip2mac>
 3240438:	e0bff015 	stw	r2,-64(fp)
         if (e < 0)
 324043c:	e0bff017 	ldw	r2,-64(fp)
 3240440:	1004403a 	cmpge	r2,r2,zero
 3240444:	1000101e 	bne	r2,zero,3240488 <ip_fragment+0x5bc>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 3240448:	01000084 	movi	r4,2
 324044c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
            pk_free(p);
 3240450:	e13ffa17 	ldw	r4,-24(fp)
 3240454:	322a6400 	call	322a640 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3240458:	01000084 	movi	r4,2
 324045c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 3240460:	0080c9b4 	movhi	r2,806
 3240464:	10b54b04 	addi	r2,r2,-10964
 3240468:	10801117 	ldw	r2,68(r2)
 324046c:	10c00044 	addi	r3,r2,1
 3240470:	0080c9b4 	movhi	r2,806
 3240474:	10b54b04 	addi	r2,r2,-10964
 3240478:	10c01115 	stw	r3,68(r2)
            return e;
 324047c:	e0bff017 	ldw	r2,-64(fp)
 3240480:	e0bffe15 	stw	r2,-8(fp)
 3240484:	00001406 	br	32404d8 <ip_fragment+0x60c>
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 3240488:	e0bff48b 	ldhu	r2,-46(fp)
 324048c:	10800044 	addi	r2,r2,1
 3240490:	e0bff48d 	sth	r2,-46(fp)
 3240494:	e0fff48b 	ldhu	r3,-46(fp)
 3240498:	e0bff50b 	ldhu	r2,-44(fp)
 324049c:	18bf3136 	bltu	r3,r2,3240164 <ip_fragment+0x298>

   } /* end FOR (all child fragments) */

   /* free the parent buffer since all of the data from it have been copied 
    * out into the child fragments */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 32404a0:	01000084 	movi	r4,2
 32404a4:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   pk_free(p);
 32404a8:	e13ffa17 	ldw	r4,-24(fp)
 32404ac:	322a6400 	call	322a640 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32404b0:	01000084 	movi	r4,2
 32404b4:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 32404b8:	0080c9b4 	movhi	r2,806
 32404bc:	10b54b04 	addi	r2,r2,-10964
 32404c0:	10801017 	ldw	r2,64(r2)
 32404c4:	10c00044 	addi	r3,r2,1
 32404c8:	0080c9b4 	movhi	r2,806
 32404cc:	10b54b04 	addi	r2,r2,-10964
 32404d0:	10c01015 	stw	r3,64(r2)

   return 0;
 32404d4:	e03ffe15 	stw	zero,-8(fp)
 32404d8:	e0bffe17 	ldw	r2,-8(fp)
}
 32404dc:	e037883a 	mov	sp,fp
 32404e0:	dfc00117 	ldw	ra,4(sp)
 32404e4:	df000017 	ldw	fp,0(sp)
 32404e8:	dec00204 	addi	sp,sp,8
 32404ec:	f800283a 	ret

032404f0 <ip_mymach>:
 * certain foreign host. 
 */

ip_addr
ip_mymach(ip_addr host)
{
 32404f0:	defff904 	addi	sp,sp,-28
 32404f4:	dfc00615 	stw	ra,24(sp)
 32404f8:	df000515 	stw	fp,20(sp)
 32404fc:	df000504 	addi	fp,sp,20
 3240500:	e13ffe15 	stw	r4,-8(fp)

#ifndef MULTI_HOMED /* single static interface */
   USE_ARG(host);
   return(nets[0]->n_ipaddr);   /* always use address from only net */
#else   /* MULTI_HOMED */
   tnet = iproute(host, &temp);
 3240504:	e17ffd04 	addi	r5,fp,-12
 3240508:	e13ffe17 	ldw	r4,-8(fp)
 324050c:	32408540 	call	3240854 <iproute>
 3240510:	e0bffc15 	stw	r2,-16(fp)
   if (tnet == 0)
 3240514:	e0bffc17 	ldw	r2,-16(fp)
 3240518:	1004c03a 	cmpne	r2,r2,zero
 324051c:	1000161e 	bne	r2,zero,3240578 <ip_mymach+0x88>
   {
#ifdef   NPDEBUG
      if (NDEBUG & (PROTERR|INFOMSG))
 3240520:	0080c974 	movhi	r2,805
 3240524:	10931c04 	addi	r2,r2,19568
 3240528:	10800017 	ldw	r2,0(r2)
 324052c:	1080050c 	andi	r2,r2,20
 3240530:	1005003a 	cmpeq	r2,r2,zero
 3240534:	10000e1e 	bne	r2,zero,3240570 <ip_mymach+0x80>
         dprintf("IP: Couldn't route to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 3240538:	e0bffe17 	ldw	r2,-8(fp)
 324053c:	11403fcc 	andi	r5,r2,255
 3240540:	e0bffe17 	ldw	r2,-8(fp)
 3240544:	1004d23a 	srli	r2,r2,8
 3240548:	11803fcc 	andi	r6,r2,255
 324054c:	e0bffe17 	ldw	r2,-8(fp)
 3240550:	1004d43a 	srli	r2,r2,16
 3240554:	11c03fcc 	andi	r7,r2,255
 3240558:	e0bffe17 	ldw	r2,-8(fp)
 324055c:	1004d63a 	srli	r2,r2,24
 3240560:	d8800015 	stw	r2,0(sp)
 3240564:	0100c974 	movhi	r4,805
 3240568:	213f4d04 	addi	r4,r4,-716
 324056c:	3206de00 	call	3206de0 <printf>
#endif   /* NPDEBUG */
      return 0L;
 3240570:	e03fff15 	stw	zero,-4(fp)
 3240574:	00000306 	br	3240584 <ip_mymach+0x94>
   }
   return tnet->n_ipaddr;
 3240578:	e0bffc17 	ldw	r2,-16(fp)
 324057c:	10800a17 	ldw	r2,40(r2)
 3240580:	e0bfff15 	stw	r2,-4(fp)
 3240584:	e0bfff17 	ldw	r2,-4(fp)
#endif /* MULTI_HOMED */
}
 3240588:	e037883a 	mov	sp,fp
 324058c:	dfc00117 	ldw	ra,4(sp)
 3240590:	df000017 	ldw	fp,0(sp)
 3240594:	dec00204 	addi	sp,sp,8
 3240598:	f800283a 	ret

0324059c <ip_dump>:
 * RETURNS: void
 */

void
ip_dump(PACKET p)
{
 324059c:	defff204 	addi	sp,sp,-56
 32405a0:	dfc00d15 	stw	ra,52(sp)
 32405a4:	df000c15 	stw	fp,48(sp)
 32405a8:	df000c04 	addi	fp,sp,48
 32405ac:	e13ffa15 	stw	r4,-24(fp)
   struct ip * pip;
   unsigned char * cp;
   unsigned short xsum, osum;

   pip = ip_head(p);
 32405b0:	e0bffa17 	ldw	r2,-24(fp)
 32405b4:	10800317 	ldw	r2,12(r2)
 32405b8:	e0bff915 	stw	r2,-28(fp)
   osum = pip->ip_chksum;
 32405bc:	e0bff917 	ldw	r2,-28(fp)
 32405c0:	1080028b 	ldhu	r2,10(r2)
 32405c4:	e0bff70d 	sth	r2,-36(fp)
   pip->ip_chksum = 0;
 32405c8:	e0bff917 	ldw	r2,-28(fp)
 32405cc:	1000028d 	sth	zero,10(r2)
   xsum = ~cksum(pip, ip_hlen(pip) >> 1);
 32405d0:	e0bff917 	ldw	r2,-28(fp)
 32405d4:	10800003 	ldbu	r2,0(r2)
 32405d8:	10803fcc 	andi	r2,r2,255
 32405dc:	108003cc 	andi	r2,r2,15
 32405e0:	1085883a 	add	r2,r2,r2
 32405e4:	1085883a 	add	r2,r2,r2
 32405e8:	1005d07a 	srai	r2,r2,1
 32405ec:	100b883a 	mov	r5,r2
 32405f0:	e13ff917 	ldw	r4,-28(fp)
 32405f4:	3225d5c0 	call	3225d5c <cksum>
 32405f8:	0084303a 	nor	r2,zero,r2
 32405fc:	e0bff78d 	sth	r2,-34(fp)

   if (osum != xsum)          /* trap here if checksum is wrong */
 3240600:	e0fff70b 	ldhu	r3,-36(fp)
 3240604:	e0bff78b 	ldhu	r2,-34(fp)
 3240608:	18800126 	beq	r3,r2,3240610 <ip_dump+0x74>
   {
      dtrap();
 324060c:	322aef00 	call	322aef0 <dtrap>
   /* dtrap() is fatal in the default Windows implementation, so
    * we comment it out */
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
 3240610:	0009883a 	mov	r4,zero
 3240614:	0140c974 	movhi	r5,805
 3240618:	297f5604 	addi	r5,r5,-680
 324061c:	322637c0 	call	322637c <ns_printf>
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
 3240620:	e0bff917 	ldw	r2,-28(fp)
 3240624:	e0bff815 	stw	r2,-32(fp)
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 3240628:	e0bff817 	ldw	r2,-32(fp)
 324062c:	10800003 	ldbu	r2,0(r2)
 3240630:	11803fcc 	andi	r6,r2,255
 3240634:	e0bff817 	ldw	r2,-32(fp)
 3240638:	10800044 	addi	r2,r2,1
 324063c:	10800003 	ldbu	r2,0(r2)
 3240640:	11c03fcc 	andi	r7,r2,255
 3240644:	e0bff917 	ldw	r2,-28(fp)
 3240648:	1080008b 	ldhu	r2,2(r2)
 324064c:	10bfffcc 	andi	r2,r2,65535
 3240650:	1004d23a 	srli	r2,r2,8
 3240654:	10bfffcc 	andi	r2,r2,65535
 3240658:	10c03fcc 	andi	r3,r2,255
 324065c:	e0bff917 	ldw	r2,-28(fp)
 3240660:	1080008b 	ldhu	r2,2(r2)
 3240664:	10bfffcc 	andi	r2,r2,65535
 3240668:	1004923a 	slli	r2,r2,8
 324066c:	10bfc00c 	andi	r2,r2,65280
 3240670:	1888b03a 	or	r4,r3,r2
 3240674:	e0bff917 	ldw	r2,-28(fp)
 3240678:	1080010b 	ldhu	r2,4(r2)
 324067c:	10bfffcc 	andi	r2,r2,65535
 3240680:	1004d23a 	srli	r2,r2,8
 3240684:	10bfffcc 	andi	r2,r2,65535
 3240688:	10c03fcc 	andi	r3,r2,255
 324068c:	e0bff917 	ldw	r2,-28(fp)
 3240690:	1080010b 	ldhu	r2,4(r2)
 3240694:	10bfffcc 	andi	r2,r2,65535
 3240698:	1004923a 	slli	r2,r2,8
 324069c:	10bfc00c 	andi	r2,r2,65280
 32406a0:	1884b03a 	or	r2,r3,r2
 32406a4:	d9000015 	stw	r4,0(sp)
 32406a8:	d8800115 	stw	r2,4(sp)
 32406ac:	0009883a 	mov	r4,zero
 32406b0:	0140c974 	movhi	r5,805
 32406b4:	297f5b04 	addi	r5,r5,-660
 32406b8:	322637c0 	call	322637c <ns_printf>
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 32406bc:	e0bff817 	ldw	r2,-32(fp)
 32406c0:	10800184 	addi	r2,r2,6
 32406c4:	1080000b 	ldhu	r2,0(r2)
 32406c8:	10bfffcc 	andi	r2,r2,65535
 32406cc:	1004d23a 	srli	r2,r2,8
 32406d0:	10bfffcc 	andi	r2,r2,65535
 32406d4:	10c03fcc 	andi	r3,r2,255
 32406d8:	e0bff817 	ldw	r2,-32(fp)
 32406dc:	10800184 	addi	r2,r2,6
 32406e0:	1080000b 	ldhu	r2,0(r2)
 32406e4:	10bfffcc 	andi	r2,r2,65535
 32406e8:	1004923a 	slli	r2,r2,8
 32406ec:	10bfc00c 	andi	r2,r2,65280
 32406f0:	1886b03a 	or	r3,r3,r2
 32406f4:	e0ffff15 	stw	r3,-4(fp)
 32406f8:	e0bff917 	ldw	r2,-28(fp)
 32406fc:	10800203 	ldbu	r2,8(r2)
 3240700:	10803fcc 	andi	r2,r2,255
 3240704:	e0bffe15 	stw	r2,-8(fp)
 3240708:	e0bff917 	ldw	r2,-28(fp)
 324070c:	10800243 	ldbu	r2,9(r2)
 3240710:	10803fcc 	andi	r2,r2,255
 3240714:	e0bffd15 	stw	r2,-12(fp)
 3240718:	e0bff70b 	ldhu	r2,-36(fp)
 324071c:	1004d23a 	srli	r2,r2,8
 3240720:	10bfffcc 	andi	r2,r2,65535
 3240724:	10c03fcc 	andi	r3,r2,255
 3240728:	e0bff70b 	ldhu	r2,-36(fp)
 324072c:	1004923a 	slli	r2,r2,8
 3240730:	10bfc00c 	andi	r2,r2,65280
 3240734:	1886b03a 	or	r3,r3,r2
 3240738:	e0fffc15 	stw	r3,-16(fp)
 324073c:	e0fff70b 	ldhu	r3,-36(fp)
 3240740:	e0bff78b 	ldhu	r2,-34(fp)
 3240744:	1880041e 	bne	r3,r2,3240758 <ip_dump+0x1bc>
 3240748:	0080c974 	movhi	r2,805
 324074c:	10bf6704 	addi	r2,r2,-612
 3240750:	e0bffb15 	stw	r2,-20(fp)
 3240754:	00000306 	br	3240764 <ip_dump+0x1c8>
 3240758:	0080c974 	movhi	r2,805
 324075c:	10bf6804 	addi	r2,r2,-608
 3240760:	e0bffb15 	stw	r2,-20(fp)
 3240764:	e0bffd17 	ldw	r2,-12(fp)
 3240768:	d8800015 	stw	r2,0(sp)
 324076c:	e0bffc17 	ldw	r2,-16(fp)
 3240770:	d8800115 	stw	r2,4(sp)
 3240774:	e0bffb17 	ldw	r2,-20(fp)
 3240778:	d8800215 	stw	r2,8(sp)
 324077c:	0009883a 	mov	r4,zero
 3240780:	0140c974 	movhi	r5,805
 3240784:	297f6904 	addi	r5,r5,-604
 3240788:	e1bfff17 	ldw	r6,-4(fp)
 324078c:	e1fffe17 	ldw	r7,-8(fp)
 3240790:	322637c0 	call	322637c <ns_printf>
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
   ns_printf(NULL ,"src: %u.%u.%u.%u  ", PUSH_IPADDR(pip->ip_src));
 3240794:	e0bff917 	ldw	r2,-28(fp)
 3240798:	10800317 	ldw	r2,12(r2)
 324079c:	11803fcc 	andi	r6,r2,255
 32407a0:	e0bff917 	ldw	r2,-28(fp)
 32407a4:	10800317 	ldw	r2,12(r2)
 32407a8:	1004d23a 	srli	r2,r2,8
 32407ac:	11c03fcc 	andi	r7,r2,255
 32407b0:	e0bff917 	ldw	r2,-28(fp)
 32407b4:	10800317 	ldw	r2,12(r2)
 32407b8:	1004d43a 	srli	r2,r2,16
 32407bc:	10c03fcc 	andi	r3,r2,255
 32407c0:	e0bff917 	ldw	r2,-28(fp)
 32407c4:	10800317 	ldw	r2,12(r2)
 32407c8:	1004d63a 	srli	r2,r2,24
 32407cc:	d8c00015 	stw	r3,0(sp)
 32407d0:	d8800115 	stw	r2,4(sp)
 32407d4:	0009883a 	mov	r4,zero
 32407d8:	0140c974 	movhi	r5,805
 32407dc:	297f7904 	addi	r5,r5,-540
 32407e0:	322637c0 	call	322637c <ns_printf>
   ns_printf(NULL ,"dest: %u.%u.%u.%u\n", PUSH_IPADDR(pip->ip_dest));
 32407e4:	e0bff917 	ldw	r2,-28(fp)
 32407e8:	10800417 	ldw	r2,16(r2)
 32407ec:	11803fcc 	andi	r6,r2,255
 32407f0:	e0bff917 	ldw	r2,-28(fp)
 32407f4:	10800417 	ldw	r2,16(r2)
 32407f8:	1004d23a 	srli	r2,r2,8
 32407fc:	11c03fcc 	andi	r7,r2,255
 3240800:	e0bff917 	ldw	r2,-28(fp)
 3240804:	10800417 	ldw	r2,16(r2)
 3240808:	1004d43a 	srli	r2,r2,16
 324080c:	10c03fcc 	andi	r3,r2,255
 3240810:	e0bff917 	ldw	r2,-28(fp)
 3240814:	10800417 	ldw	r2,16(r2)
 3240818:	1004d63a 	srli	r2,r2,24
 324081c:	d8c00015 	stw	r3,0(sp)
 3240820:	d8800115 	stw	r2,4(sp)
 3240824:	0009883a 	mov	r4,zero
 3240828:	0140c974 	movhi	r5,805
 324082c:	297f7e04 	addi	r5,r5,-520
 3240830:	322637c0 	call	322637c <ns_printf>

   pip->ip_chksum = osum;     /* fix what we clobbered */
 3240834:	e0fff917 	ldw	r3,-28(fp)
 3240838:	e0bff70b 	ldhu	r2,-36(fp)
 324083c:	1880028d 	sth	r2,10(r3)
}
 3240840:	e037883a 	mov	sp,fp
 3240844:	dfc00117 	ldw	ra,4(sp)
 3240848:	df000017 	ldw	fp,0(sp)
 324084c:	dec00204 	addi	sp,sp,8
 3240850:	f800283a 	ret

03240854 <iproute>:
 * RETURNS: Returns NULL when unable to route, else returns a NET pointer.
 */

NET
iproute(ip_addr host, ip_addr * hop1)
{
 3240854:	defff704 	addi	sp,sp,-36
 3240858:	dfc00815 	stw	ra,32(sp)
 324085c:	df000715 	stw	fp,28(sp)
 3240860:	df000704 	addi	fp,sp,28
 3240864:	e13ffd15 	stw	r4,-12(fp)
 3240868:	e17ffe15 	stw	r5,-8(fp)
   NET      ifp;
#ifdef IP_ROUTING
   RTMIB    rtp;
#endif   /* IP_ROUTING */

   if (host == 0L)      /* Sanity check parameter. */
 324086c:	e0bffd17 	ldw	r2,-12(fp)
 3240870:	1004c03a 	cmpne	r2,r2,zero
 3240874:	1000021e 	bne	r2,zero,3240880 <iproute+0x2c>
      return NULL;
 3240878:	e03fff15 	stw	zero,-4(fp)
 324087c:	00008a06 	br	3240aa8 <iproute+0x254>
    * stack has been initialized (tk_yield() gets called out of the 
    * dialer code as part of PPP initialization), one symptom of 
    * which is the routing table not being present yet. if this 
    * happens, quit. 
    */
   if (rt_mib == NULL)
 3240880:	d0a8fd17 	ldw	r2,-23564(gp)
 3240884:	1004c03a 	cmpne	r2,r2,zero
 3240888:	1000021e 	bne	r2,zero,3240894 <iproute+0x40>
      return NULL;
 324088c:	e03fff15 	stw	zero,-4(fp)
 3240890:	00008506 	br	3240aa8 <iproute+0x254>
#endif   /* BTREE_ROUTING */

   /* see if the host matches the cached route */
   if (cachedRoute)     /* don't test this if route is null  */
 3240894:	0080c974 	movhi	r2,805
 3240898:	10936904 	addi	r2,r2,19876
 324089c:	10800017 	ldw	r2,0(r2)
 32408a0:	1005003a 	cmpeq	r2,r2,zero
 32408a4:	1000191e 	bne	r2,zero,324090c <iproute+0xb8>
   {
      if (cachedRoute->ipRouteDest == host)    /* exact match */
 32408a8:	0080c974 	movhi	r2,805
 32408ac:	10936904 	addi	r2,r2,19876
 32408b0:	10800017 	ldw	r2,0(r2)
 32408b4:	10c00017 	ldw	r3,0(r2)
 32408b8:	e0bffd17 	ldw	r2,-12(fp)
 32408bc:	1880131e 	bne	r3,r2,324090c <iproute+0xb8>
      {
         *hop1 = cachedRoute->ipRouteNextHop;   /* fill in nexthop IP addr */
 32408c0:	0080c974 	movhi	r2,805
 32408c4:	10936904 	addi	r2,r2,19876
 32408c8:	10800017 	ldw	r2,0(r2)
 32408cc:	10c00617 	ldw	r3,24(r2)
 32408d0:	e0bffe17 	ldw	r2,-8(fp)
 32408d4:	10c00015 	stw	r3,0(r2)
         cachedRoute->ipRouteAge = cticks;      /* timestamp route entry */
 32408d8:	0080c974 	movhi	r2,805
 32408dc:	10936904 	addi	r2,r2,19876
 32408e0:	10c00017 	ldw	r3,0(r2)
 32408e4:	0080c974 	movhi	r2,805
 32408e8:	10934104 	addi	r2,r2,19716
 32408ec:	10800017 	ldw	r2,0(r2)
 32408f0:	18800915 	stw	r2,36(r3)
         return(cachedRoute->ifp); /* net to send on */
 32408f4:	0080c974 	movhi	r2,805
 32408f8:	10936904 	addi	r2,r2,19876
 32408fc:	10800017 	ldw	r2,0(r2)
 3240900:	10800e17 	ldw	r2,56(r2)
 3240904:	e0bfff15 	stw	r2,-4(fp)
 3240908:	00006706 	br	3240aa8 <iproute+0x254>
      }
   }

   rtp = rt_lookup(host);
 324090c:	e13ffd17 	ldw	r4,-12(fp)
 3240910:	32440f40 	call	32440f4 <rt_lookup>
 3240914:	e0bffa15 	stw	r2,-24(fp)
   if(rtp)
 3240918:	e0bffa17 	ldw	r2,-24(fp)
 324091c:	1005003a 	cmpeq	r2,r2,zero
 3240920:	10000c1e 	bne	r2,zero,3240954 <iproute+0x100>
   {
      cachedRoute = rtp;
 3240924:	00c0c974 	movhi	r3,805
 3240928:	18d36904 	addi	r3,r3,19876
 324092c:	e0bffa17 	ldw	r2,-24(fp)
 3240930:	18800015 	stw	r2,0(r3)
      *hop1 = rtp->ipRouteNextHop;  /* fill in IP dest (next hop) */
 3240934:	e0bffa17 	ldw	r2,-24(fp)
 3240938:	10c00617 	ldw	r3,24(r2)
 324093c:	e0bffe17 	ldw	r2,-8(fp)
 3240940:	10c00015 	stw	r3,0(r2)
      return(rtp->ifp);             /* return pointer to net */
 3240944:	e0bffa17 	ldw	r2,-24(fp)
 3240948:	10800e17 	ldw	r2,56(r2)
 324094c:	e0bfff15 	stw	r2,-4(fp)
 3240950:	00005506 	br	3240aa8 <iproute+0x254>
    * the initial state for the for loop that iterates through the
    * list), but only build the iterator for multi-homed systems
    * because single-homed systems are often memory-limited systems as
    * well.  
    */
   ifp = (NET)(netlist.q_head);
 3240954:	0080c9b4 	movhi	r2,806
 3240958:	10b54604 	addi	r2,r2,-10984
 324095c:	10800017 	ldw	r2,0(r2)
 3240960:	e0bffb15 	stw	r2,-20(fp)
   i = 0;
 3240964:	e03ffc15 	stw	zero,-16(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 3240968:	00002f06 	br	3240a28 <iproute+0x1d4>
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 324096c:	e0bffb17 	ldw	r2,-20(fp)
 3240970:	10800c17 	ldw	r2,48(r2)
 3240974:	1005003a 	cmpeq	r2,r2,zero
 3240978:	1000251e 	bne	r2,zero,3240a10 <iproute+0x1bc>
 324097c:	e0bffb17 	ldw	r2,-20(fp)
 3240980:	10800a17 	ldw	r2,40(r2)
 3240984:	1005003a 	cmpeq	r2,r2,zero
 3240988:	1000211e 	bne	r2,zero,3240a10 <iproute+0x1bc>
 324098c:	e0bffb17 	ldw	r2,-20(fp)
 3240990:	10c00a17 	ldw	r3,40(r2)
 3240994:	e0bffb17 	ldw	r2,-20(fp)
 3240998:	10800c17 	ldw	r2,48(r2)
 324099c:	1888703a 	and	r4,r3,r2
 32409a0:	e0bffb17 	ldw	r2,-20(fp)
 32409a4:	10c00c17 	ldw	r3,48(r2)
 32409a8:	e0bffd17 	ldw	r2,-12(fp)
 32409ac:	1884703a 	and	r2,r3,r2
 32409b0:	2080171e 	bne	r4,r2,3240a10 <iproute+0x1bc>
         (ifp->n_ipaddr != 0) && 
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
      {
#ifdef IP_ROUTING
         /* make a cached Route entry for next time */
         cachedRoute = add_route(host, 0xFFFFFFFF, host, i, IPRP_OTHER);
 32409b4:	00800044 	movi	r2,1
 32409b8:	d8800015 	stw	r2,0(sp)
 32409bc:	e13ffd17 	ldw	r4,-12(fp)
 32409c0:	017fffc4 	movi	r5,-1
 32409c4:	e1bffd17 	ldw	r6,-12(fp)
 32409c8:	e1fffc17 	ldw	r7,-16(fp)
 32409cc:	32442780 	call	3244278 <add_route>
 32409d0:	1007883a 	mov	r3,r2
 32409d4:	0080c974 	movhi	r2,805
 32409d8:	10936904 	addi	r2,r2,19876
 32409dc:	10c00015 	stw	r3,0(r2)
#ifdef NPDEBUG
         if (cachedRoute == NULL)
 32409e0:	0080c974 	movhi	r2,805
 32409e4:	10936904 	addi	r2,r2,19876
 32409e8:	10800017 	ldw	r2,0(r2)
 32409ec:	1004c03a 	cmpne	r2,r2,zero
 32409f0:	1000011e 	bne	r2,zero,32409f8 <iproute+0x1a4>
            dtrap();
 32409f4:	322aef00 	call	322aef0 <dtrap>
#endif   /* NPDEBUG */
#endif   /* IP_ROUTING */
         *hop1 = host;
 32409f8:	e0fffe17 	ldw	r3,-8(fp)
 32409fc:	e0bffd17 	ldw	r2,-12(fp)
 3240a00:	18800015 	stw	r2,0(r3)
         return ifp;
 3240a04:	e0bffb17 	ldw	r2,-20(fp)
 3240a08:	e0bfff15 	stw	r2,-4(fp)
 3240a0c:	00002606 	br	3240aa8 <iproute+0x254>
    * well.  
    */
   ifp = (NET)(netlist.q_head);
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 3240a10:	e0bffb17 	ldw	r2,-20(fp)
 3240a14:	10800017 	ldw	r2,0(r2)
 3240a18:	e0bffb15 	stw	r2,-20(fp)
 3240a1c:	e0bffc17 	ldw	r2,-16(fp)
 3240a20:	10800044 	addi	r2,r2,1
 3240a24:	e0bffc15 	stw	r2,-16(fp)
 3240a28:	e0bffb17 	ldw	r2,-20(fp)
 3240a2c:	1004c03a 	cmpne	r2,r2,zero
 3240a30:	103fce1e 	bne	r2,zero,324096c <iproute+0x118>
#endif   /* IP_LOOPBACK */

   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
 3240a34:	0080c9b4 	movhi	r2,806
 3240a38:	10b54604 	addi	r2,r2,-10984
 3240a3c:	10800017 	ldw	r2,0(r2)
 3240a40:	e0bffb15 	stw	r2,-20(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 3240a44:	00000e06 	br	3240a80 <iproute+0x22c>
#endif   /* MULTI_HOMED */
   {
      /* Check if this net has a gateway */
      if(ifp->n_defgw)
 3240a48:	e0bffb17 	ldw	r2,-20(fp)
 3240a4c:	10800d17 	ldw	r2,52(r2)
 3240a50:	1005003a 	cmpeq	r2,r2,zero
 3240a54:	1000071e 	bne	r2,zero,3240a74 <iproute+0x220>
      {
         *hop1 = ifp->n_defgw;
 3240a58:	e0bffb17 	ldw	r2,-20(fp)
 3240a5c:	10c00d17 	ldw	r3,52(r2)
 3240a60:	e0bffe17 	ldw	r2,-8(fp)
 3240a64:	10c00015 	stw	r3,0(r2)
         return ifp;
 3240a68:	e0bffb17 	ldw	r2,-20(fp)
 3240a6c:	e0bfff15 	stw	r2,-4(fp)
 3240a70:	00000d06 	br	3240aa8 <iproute+0x254>
   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 3240a74:	e0bffb17 	ldw	r2,-20(fp)
 3240a78:	10800017 	ldw	r2,0(r2)
 3240a7c:	e0bffb15 	stw	r2,-20(fp)
 3240a80:	e0bffb17 	ldw	r2,-20(fp)
 3240a84:	1004c03a 	cmpne	r2,r2,zero
 3240a88:	103fef1e 	bne	r2,zero,3240a48 <iproute+0x1f4>
   /* if no gateway is set, then change the first hop address to the 
    * host we're trying to route to. this is just a kluge to make 
    * this work with arp routing. otherwise, we would try to return 
    * some sort of error indication. 
    */
   *hop1 = host;
 3240a8c:	e0fffe17 	ldw	r3,-8(fp)
 3240a90:	e0bffd17 	ldw	r2,-12(fp)
 3240a94:	18800015 	stw	r2,0(r3)
   return((NET)(netlist.q_head));
 3240a98:	0080c9b4 	movhi	r2,806
 3240a9c:	10b54604 	addi	r2,r2,-10984
 3240aa0:	10800017 	ldw	r2,0(r2)
 3240aa4:	e0bfff15 	stw	r2,-4(fp)
 3240aa8:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* STRICT_SUBNETTING */
}
 3240aac:	e037883a 	mov	sp,fp
 3240ab0:	dfc00117 	ldw	ra,4(sp)
 3240ab4:	df000017 	ldw	fp,0(sp)
 3240ab8:	dec00204 	addi	sp,sp,8
 3240abc:	f800283a 	ret

03240ac0 <ip_copypkt>:
 * RETURNS: a pointer to the new copy of the packet,
 *          or NULL if no packet buffer could be allocated
 */
PACKET
ip_copypkt(PACKET p)
{
 3240ac0:	defffa04 	addi	sp,sp,-24
 3240ac4:	dfc00515 	stw	ra,20(sp)
 3240ac8:	df000415 	stw	fp,16(sp)
 3240acc:	df000404 	addi	fp,sp,16
 3240ad0:	e13ffe15 	stw	r4,-8(fp)
   int len;

   /* figure out how much we need to copy from the packet, 
    * and allocate a new buffer to hold it 
    */
   len = p->nb_plen + (p->nb_prot - p->nb_buff);
 3240ad4:	e0bffe17 	ldw	r2,-8(fp)
 3240ad8:	11000417 	ldw	r4,16(r2)
 3240adc:	e0bffe17 	ldw	r2,-8(fp)
 3240ae0:	10800317 	ldw	r2,12(r2)
 3240ae4:	1007883a 	mov	r3,r2
 3240ae8:	e0bffe17 	ldw	r2,-8(fp)
 3240aec:	10800117 	ldw	r2,4(r2)
 3240af0:	1885c83a 	sub	r2,r3,r2
 3240af4:	2085883a 	add	r2,r4,r2
 3240af8:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 3240afc:	01000084 	movi	r4,2
 3240b00:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   np = pk_alloc(len);
 3240b04:	e13ffc17 	ldw	r4,-16(fp)
 3240b08:	322a2ac0 	call	322a2ac <pk_alloc>
 3240b0c:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3240b10:	01000084 	movi	r4,2
 3240b14:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   if (np == NULL)
 3240b18:	e0bffd17 	ldw	r2,-12(fp)
 3240b1c:	1004c03a 	cmpne	r2,r2,zero
 3240b20:	1000061e 	bne	r2,zero,3240b3c <ip_copypkt+0x7c>
   {
#ifdef NPDEBUG
      dprintf("ip_copypkt(): unable to obtain packet (len %d)\n", len);
 3240b24:	0100c974 	movhi	r4,805
 3240b28:	213f8304 	addi	r4,r4,-500
 3240b2c:	e17ffc17 	ldw	r5,-16(fp)
 3240b30:	3206de00 	call	3206de0 <printf>
#endif
      return NULL;
 3240b34:	e03fff15 	stw	zero,-4(fp)
 3240b38:	00002906 	br	3240be0 <ip_copypkt+0x120>
   }

   /* copy packet data into new buffer */
   MEMCPY(np->nb_buff, p->nb_buff, len);
 3240b3c:	e0bffd17 	ldw	r2,-12(fp)
 3240b40:	11000117 	ldw	r4,4(r2)
 3240b44:	e0bffe17 	ldw	r2,-8(fp)
 3240b48:	10800117 	ldw	r2,4(r2)
 3240b4c:	e0fffc17 	ldw	r3,-16(fp)
 3240b50:	100b883a 	mov	r5,r2
 3240b54:	180d883a 	mov	r6,r3
 3240b58:	3206ad00 	call	3206ad0 <memcpy>

   /* copy relevant packet fields */
   np->nb_prot = np->nb_buff + (p->nb_prot - p->nb_buff);
 3240b5c:	e0bffd17 	ldw	r2,-12(fp)
 3240b60:	11000117 	ldw	r4,4(r2)
 3240b64:	e0bffe17 	ldw	r2,-8(fp)
 3240b68:	10800317 	ldw	r2,12(r2)
 3240b6c:	1007883a 	mov	r3,r2
 3240b70:	e0bffe17 	ldw	r2,-8(fp)
 3240b74:	10800117 	ldw	r2,4(r2)
 3240b78:	1885c83a 	sub	r2,r3,r2
 3240b7c:	2087883a 	add	r3,r4,r2
 3240b80:	e0bffd17 	ldw	r2,-12(fp)
 3240b84:	10c00315 	stw	r3,12(r2)
   np->nb_plen = p->nb_plen;
 3240b88:	e0bffe17 	ldw	r2,-8(fp)
 3240b8c:	10c00417 	ldw	r3,16(r2)
 3240b90:	e0bffd17 	ldw	r2,-12(fp)
 3240b94:	10c00415 	stw	r3,16(r2)
   np->net = p->net;
 3240b98:	e0bffe17 	ldw	r2,-8(fp)
 3240b9c:	10c00617 	ldw	r3,24(r2)
 3240ba0:	e0bffd17 	ldw	r2,-12(fp)
 3240ba4:	10c00615 	stw	r3,24(r2)
   np->fhost = p->fhost;
 3240ba8:	e0bffe17 	ldw	r2,-8(fp)
 3240bac:	10c00717 	ldw	r3,28(r2)
 3240bb0:	e0bffd17 	ldw	r2,-12(fp)
 3240bb4:	10c00715 	stw	r3,28(r2)
   np->type = p->type;
 3240bb8:	e0bffe17 	ldw	r2,-8(fp)
 3240bbc:	10c0080b 	ldhu	r3,32(r2)
 3240bc0:	e0bffd17 	ldw	r2,-12(fp)
 3240bc4:	10c0080d 	sth	r3,32(r2)
   np->nb_tstamp = p->nb_tstamp;
 3240bc8:	e0bffe17 	ldw	r2,-8(fp)
 3240bcc:	10c00517 	ldw	r3,20(r2)
 3240bd0:	e0bffd17 	ldw	r2,-12(fp)
 3240bd4:	10c00515 	stw	r3,20(r2)

   /* return pointer to the copy */
   return np;
 3240bd8:	e0bffd17 	ldw	r2,-12(fp)
 3240bdc:	e0bfff15 	stw	r2,-4(fp)
 3240be0:	e0bfff17 	ldw	r2,-4(fp)
}
 3240be4:	e037883a 	mov	sp,fp
 3240be8:	dfc00117 	ldw	ra,4(sp)
 3240bec:	df000017 	ldw	fp,0(sp)
 3240bf0:	dec00204 	addi	sp,sp,8
 3240bf4:	f800283a 	ret

03240bf8 <ip_reasm_match_frag_with_ire>:
packet being processed.  If no such entry is found, this function returns 
NULL.
*/

IREP ip_reasm_match_frag_with_ire (struct ip * pip)
{
 3240bf8:	defff904 	addi	sp,sp,-28
 3240bfc:	df000615 	stw	fp,24(sp)
 3240c00:	df000604 	addi	fp,sp,24
 3240c04:	e13ffe15 	stw	r4,-8(fp)
   ip_addr dest;
   u_char prot;
   u_short id;
   IREP tmpp;
 
   src = pip->ip_src;
 3240c08:	e0bffe17 	ldw	r2,-8(fp)
 3240c0c:	10800317 	ldw	r2,12(r2)
 3240c10:	e0bffd15 	stw	r2,-12(fp)
   dest = pip->ip_dest;
 3240c14:	e0bffe17 	ldw	r2,-8(fp)
 3240c18:	10800417 	ldw	r2,16(r2)
 3240c1c:	e0bffc15 	stw	r2,-16(fp)
   prot = pip->ip_prot;
 3240c20:	e0bffe17 	ldw	r2,-8(fp)
 3240c24:	10800243 	ldbu	r2,9(r2)
 3240c28:	e0bffb85 	stb	r2,-18(fp)
   id = pip->ip_id;
 3240c2c:	e0bffe17 	ldw	r2,-8(fp)
 3240c30:	1080010b 	ldhu	r2,4(r2)
 3240c34:	e0bffb0d 	sth	r2,-20(fp)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 3240c38:	d0a8ff17 	ldw	r2,-23556(gp)
 3240c3c:	e0bffa15 	stw	r2,-24(fp)
 3240c40:	00001806 	br	3240ca4 <ip_reasm_match_frag_with_ire+0xac>
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 3240c44:	e0bffa17 	ldw	r2,-24(fp)
 3240c48:	10c00117 	ldw	r3,4(r2)
 3240c4c:	e0bffd17 	ldw	r2,-12(fp)
 3240c50:	1880111e 	bne	r3,r2,3240c98 <ip_reasm_match_frag_with_ire+0xa0>
 3240c54:	e0bffa17 	ldw	r2,-24(fp)
 3240c58:	10c00217 	ldw	r3,8(r2)
 3240c5c:	e0bffc17 	ldw	r2,-16(fp)
 3240c60:	18800d1e 	bne	r3,r2,3240c98 <ip_reasm_match_frag_with_ire+0xa0>
 3240c64:	e0bffa17 	ldw	r2,-24(fp)
 3240c68:	10800383 	ldbu	r2,14(r2)
 3240c6c:	10c03fcc 	andi	r3,r2,255
 3240c70:	e0bffb83 	ldbu	r2,-18(fp)
 3240c74:	1880081e 	bne	r3,r2,3240c98 <ip_reasm_match_frag_with_ire+0xa0>
 3240c78:	e0bffa17 	ldw	r2,-24(fp)
 3240c7c:	1080030b 	ldhu	r2,12(r2)
 3240c80:	10ffffcc 	andi	r3,r2,65535
 3240c84:	e0bffb0b 	ldhu	r2,-20(fp)
 3240c88:	1880031e 	bne	r3,r2,3240c98 <ip_reasm_match_frag_with_ire+0xa0>
          (tmpp->prot == prot) && (tmpp->id == id))
         {
         return tmpp; /* we've found a match */
 3240c8c:	e0bffa17 	ldw	r2,-24(fp)
 3240c90:	e0bfff15 	stw	r2,-4(fp)
 3240c94:	00000706 	br	3240cb4 <ip_reasm_match_frag_with_ire+0xbc>
   prot = pip->ip_prot;
   id = pip->ip_id;

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 3240c98:	e0bffa17 	ldw	r2,-24(fp)
 3240c9c:	10800017 	ldw	r2,0(r2)
 3240ca0:	e0bffa15 	stw	r2,-24(fp)
 3240ca4:	e0bffa17 	ldw	r2,-24(fp)
 3240ca8:	1004c03a 	cmpne	r2,r2,zero
 3240cac:	103fe51e 	bne	r2,zero,3240c44 <ip_reasm_match_frag_with_ire+0x4c>
         return tmpp; /* we've found a match */
         }
      }

   /* no match found */
   return NULL;
 3240cb0:	e03fff15 	stw	zero,-4(fp)
 3240cb4:	e0bfff17 	ldw	r2,-4(fp)
}
 3240cb8:	e037883a 	mov	sp,fp
 3240cbc:	df000017 	ldw	fp,0(sp)
 3240cc0:	dec00104 	addi	sp,sp,4
 3240cc4:	f800283a 	ret

03240cc8 <ip_reasm_determine_type_of_frag>:
OUTPUT: One of the various IP_FRAGTYPE values (IP_CP, IP_FF, IP_MF, 
or IP_LF)
*/

IP_FRAGTYPE ip_reasm_determine_type_of_frag (struct ip * pip)
{
 3240cc8:	defffc04 	addi	sp,sp,-16
 3240ccc:	df000315 	stw	fp,12(sp)
 3240cd0:	df000304 	addi	fp,sp,12
 3240cd4:	e13fff15 	stw	r4,-4(fp)
  u_short mf;
  u_short foff;
  IP_FRAGTYPE rc;

  mf = (((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF) >> 13);
 3240cd8:	e0bfff17 	ldw	r2,-4(fp)
 3240cdc:	1080018b 	ldhu	r2,6(r2)
 3240ce0:	10bfffcc 	andi	r2,r2,65535
 3240ce4:	1004d23a 	srli	r2,r2,8
 3240ce8:	10bfffcc 	andi	r2,r2,65535
 3240cec:	10c03fcc 	andi	r3,r2,255
 3240cf0:	e0bfff17 	ldw	r2,-4(fp)
 3240cf4:	1080018b 	ldhu	r2,6(r2)
 3240cf8:	10bfffcc 	andi	r2,r2,65535
 3240cfc:	1004923a 	slli	r2,r2,8
 3240d00:	10bfc00c 	andi	r2,r2,65280
 3240d04:	1884b03a 	or	r2,r3,r2
 3240d08:	1088000c 	andi	r2,r2,8192
 3240d0c:	1005d37a 	srai	r2,r2,13
 3240d10:	e0bffe8d 	sth	r2,-6(fp)
  foff = ((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF);
 3240d14:	e0bfff17 	ldw	r2,-4(fp)
 3240d18:	1080018b 	ldhu	r2,6(r2)
 3240d1c:	10bfffcc 	andi	r2,r2,65535
 3240d20:	1004d23a 	srli	r2,r2,8
 3240d24:	10803fcc 	andi	r2,r2,255
 3240d28:	1009883a 	mov	r4,r2
 3240d2c:	e0bfff17 	ldw	r2,-4(fp)
 3240d30:	1080018b 	ldhu	r2,6(r2)
 3240d34:	10bfffcc 	andi	r2,r2,65535
 3240d38:	1004923a 	slli	r2,r2,8
 3240d3c:	1007883a 	mov	r3,r2
 3240d40:	00bfc004 	movi	r2,-256
 3240d44:	1884703a 	and	r2,r3,r2
 3240d48:	2084b03a 	or	r2,r4,r2
 3240d4c:	1087ffcc 	andi	r2,r2,8191
 3240d50:	e0bffe0d 	sth	r2,-8(fp)

  if (mf == 0)
 3240d54:	e0bffe8b 	ldhu	r2,-6(fp)
 3240d58:	1004c03a 	cmpne	r2,r2,zero
 3240d5c:	1000081e 	bne	r2,zero,3240d80 <ip_reasm_determine_type_of_frag+0xb8>
     {
     if (foff == 0) {rc = IP_CP;}
 3240d60:	e0bffe0b 	ldhu	r2,-8(fp)
 3240d64:	1004c03a 	cmpne	r2,r2,zero
 3240d68:	1000021e 	bne	r2,zero,3240d74 <ip_reasm_determine_type_of_frag+0xac>
 3240d6c:	e03ffd15 	stw	zero,-12(fp)
 3240d70:	00000b06 	br	3240da0 <ip_reasm_determine_type_of_frag+0xd8>
     else {rc = IP_LF;}
 3240d74:	00800144 	movi	r2,5
 3240d78:	e0bffd15 	stw	r2,-12(fp)
 3240d7c:	00000806 	br	3240da0 <ip_reasm_determine_type_of_frag+0xd8>
     }
  else
     {
     if (foff == 0) {rc = IP_FF;}
 3240d80:	e0bffe0b 	ldhu	r2,-8(fp)
 3240d84:	1004c03a 	cmpne	r2,r2,zero
 3240d88:	1000031e 	bne	r2,zero,3240d98 <ip_reasm_determine_type_of_frag+0xd0>
 3240d8c:	00800044 	movi	r2,1
 3240d90:	e0bffd15 	stw	r2,-12(fp)
 3240d94:	00000206 	br	3240da0 <ip_reasm_determine_type_of_frag+0xd8>
     else {rc = IP_MF;}
 3240d98:	008000c4 	movi	r2,3
 3240d9c:	e0bffd15 	stw	r2,-12(fp)
     }

  return rc;
 3240da0:	e0bffd17 	ldw	r2,-12(fp)
}
 3240da4:	e037883a 	mov	sp,fp
 3240da8:	df000017 	ldw	fp,0(sp)
 3240dac:	dec00104 	addi	sp,sp,4
 3240db0:	f800283a 	ret

03240db4 <ip_reasm_check_mem_useage>:
OUTPUT: ENP_RESOURCE, if the increment request can't be allowed; 
otherwise it returns IPREASM_OK.
*/

int ip_reasm_check_mem_useage (u_short increment)
{
 3240db4:	defffd04 	addi	sp,sp,-12
 3240db8:	df000215 	stw	fp,8(sp)
 3240dbc:	df000204 	addi	fp,sp,8
 3240dc0:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity check */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 3240dc4:	d0e8fe17 	ldw	r3,-23560(gp)
 3240dc8:	008001b4 	movhi	r2,6
 3240dcc:	10c0072e 	bgeu	r2,r3,3240dec <ip_reasm_check_mem_useage+0x38>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 3240dd0:	0080c9b4 	movhi	r2,806
 3240dd4:	10b55f04 	addi	r2,r2,-10884
 3240dd8:	10800217 	ldw	r2,8(r2)
 3240ddc:	10c00044 	addi	r3,r2,1
 3240de0:	0080c9b4 	movhi	r2,806
 3240de4:	10b55f04 	addi	r2,r2,-10884
 3240de8:	10c00215 	stw	r3,8(r2)
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 3240dec:	d0e8fe17 	ldw	r3,-23560(gp)
 3240df0:	008001b4 	movhi	r2,6
 3240df4:	18800526 	beq	r3,r2,3240e0c <ip_reasm_check_mem_useage+0x58>
 3240df8:	e0fffe0b 	ldhu	r3,-8(fp)
 3240dfc:	d0a8fe17 	ldw	r2,-23560(gp)
 3240e00:	1887883a 	add	r3,r3,r2
 3240e04:	008001b4 	movhi	r2,6
 3240e08:	10c00a2e 	bgeu	r2,r3,3240e34 <ip_reasm_check_mem_useage+0x80>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
   {
      /* return an error indication */
      ++ire_stats.mem_check_fail;
 3240e0c:	0080c9b4 	movhi	r2,806
 3240e10:	10b55f04 	addi	r2,r2,-10884
 3240e14:	10800317 	ldw	r2,12(r2)
 3240e18:	10c00044 	addi	r3,r2,1
 3240e1c:	0080c9b4 	movhi	r2,806
 3240e20:	10b55f04 	addi	r2,r2,-10884
 3240e24:	10c00315 	stw	r3,12(r2)
      return ENP_RESOURCE;
 3240e28:	00bffa84 	movi	r2,-22
 3240e2c:	e0bfff15 	stw	r2,-4(fp)
 3240e30:	00000106 	br	3240e38 <ip_reasm_check_mem_useage+0x84>
   }

   /* memory limits will not be exceeded with this increment */
   return IPREASM_OK;
 3240e34:	e03fff15 	stw	zero,-4(fp)
 3240e38:	e0bfff17 	ldw	r2,-4(fp)
}
 3240e3c:	e037883a 	mov	sp,fp
 3240e40:	df000017 	ldw	fp,0(sp)
 3240e44:	dec00104 	addi	sp,sp,4
 3240e48:	f800283a 	ret

03240e4c <ip_reasm_incr_mem_useage>:
system exceeding the maximum limit or if the system has already exceeded 
the prespecified limit for memory useage; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_incr_mem_useage (u_short increment)
{
 3240e4c:	defffd04 	addi	sp,sp,-12
 3240e50:	df000215 	stw	fp,8(sp)
 3240e54:	df000204 	addi	fp,sp,8
 3240e58:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 3240e5c:	d0e8fe17 	ldw	r3,-23560(gp)
 3240e60:	008001b4 	movhi	r2,6
 3240e64:	10c00a2e 	bgeu	r2,r3,3240e90 <ip_reasm_incr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 3240e68:	0080c9b4 	movhi	r2,806
 3240e6c:	10b55f04 	addi	r2,r2,-10884
 3240e70:	10800217 	ldw	r2,8(r2)
 3240e74:	10c00044 	addi	r3,r2,1
 3240e78:	0080c9b4 	movhi	r2,806
 3240e7c:	10b55f04 	addi	r2,r2,-10884
 3240e80:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 3240e84:	00bffa84 	movi	r2,-22
 3240e88:	e0bfff15 	stw	r2,-4(fp)
 3240e8c:	00001406 	br	3240ee0 <ip_reasm_incr_mem_useage+0x94>
   }
   if (ipr_curr_mem + increment > IP_REASM_MAX_MEM)
 3240e90:	e0fffe0b 	ldhu	r3,-8(fp)
 3240e94:	d0a8fe17 	ldw	r2,-23560(gp)
 3240e98:	1887883a 	add	r3,r3,r2
 3240e9c:	008001b4 	movhi	r2,6
 3240ea0:	10c00a2e 	bgeu	r2,r3,3240ecc <ip_reasm_incr_mem_useage+0x80>
   {
      /* this should never happen since caller should have 
       * checked prior to asking for the increment */
      ++ire_stats.mem_incr_fail;
 3240ea4:	0080c9b4 	movhi	r2,806
 3240ea8:	10b55f04 	addi	r2,r2,-10884
 3240eac:	10800417 	ldw	r2,16(r2)
 3240eb0:	10c00044 	addi	r3,r2,1
 3240eb4:	0080c9b4 	movhi	r2,806
 3240eb8:	10b55f04 	addi	r2,r2,-10884
 3240ebc:	10c00415 	stw	r3,16(r2)
      return ENP_RESOURCE;
 3240ec0:	00bffa84 	movi	r2,-22
 3240ec4:	e0bfff15 	stw	r2,-4(fp)
 3240ec8:	00000506 	br	3240ee0 <ip_reasm_incr_mem_useage+0x94>
   }

   ipr_curr_mem += increment;
 3240ecc:	e0bffe0b 	ldhu	r2,-8(fp)
 3240ed0:	d0e8fe17 	ldw	r3,-23560(gp)
 3240ed4:	10c5883a 	add	r2,r2,r3
 3240ed8:	d0a8fe15 	stw	r2,-23560(gp)

   /* successfully incremented memory useage counter */
   return IPREASM_OK;
 3240edc:	e03fff15 	stw	zero,-4(fp)
 3240ee0:	e0bfff17 	ldw	r2,-4(fp)
}
 3240ee4:	e037883a 	mov	sp,fp
 3240ee8:	df000017 	ldw	fp,0(sp)
 3240eec:	dec00104 	addi	sp,sp,4
 3240ef0:	f800283a 	ret

03240ef4 <ip_reasm_decr_mem_useage>:
exceeded the prespecified limit for memory useage; otherwise, it returns 
IPREASM_OK.
*/

int ip_reasm_decr_mem_useage (u_short decrement)
{
 3240ef4:	defffd04 	addi	sp,sp,-12
 3240ef8:	df000215 	stw	fp,8(sp)
 3240efc:	df000204 	addi	fp,sp,8
 3240f00:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 3240f04:	d0e8fe17 	ldw	r3,-23560(gp)
 3240f08:	008001b4 	movhi	r2,6
 3240f0c:	10c00a2e 	bgeu	r2,r3,3240f38 <ip_reasm_decr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 3240f10:	0080c9b4 	movhi	r2,806
 3240f14:	10b55f04 	addi	r2,r2,-10884
 3240f18:	10800217 	ldw	r2,8(r2)
 3240f1c:	10c00044 	addi	r3,r2,1
 3240f20:	0080c9b4 	movhi	r2,806
 3240f24:	10b55f04 	addi	r2,r2,-10884
 3240f28:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 3240f2c:	00bffa84 	movi	r2,-22
 3240f30:	e0bfff15 	stw	r2,-4(fp)
 3240f34:	00001206 	br	3240f80 <ip_reasm_decr_mem_useage+0x8c>
   }
   if (ipr_curr_mem < decrement)
 3240f38:	e0fffe0b 	ldhu	r3,-8(fp)
 3240f3c:	d0a8fe17 	ldw	r2,-23560(gp)
 3240f40:	10c00a2e 	bgeu	r2,r3,3240f6c <ip_reasm_decr_mem_useage+0x78>
   {
      /* this should never happen since the current memory useage
       * counter must always be greater than or at least equal to
       * the allocation that is being "returned" */
      ++ire_stats.mem_decr_fail;
 3240f44:	0080c9b4 	movhi	r2,806
 3240f48:	10b55f04 	addi	r2,r2,-10884
 3240f4c:	10800517 	ldw	r2,20(r2)
 3240f50:	10c00044 	addi	r3,r2,1
 3240f54:	0080c9b4 	movhi	r2,806
 3240f58:	10b55f04 	addi	r2,r2,-10884
 3240f5c:	10c00515 	stw	r3,20(r2)
      return ENP_RESOURCE;
 3240f60:	00bffa84 	movi	r2,-22
 3240f64:	e0bfff15 	stw	r2,-4(fp)
 3240f68:	00000506 	br	3240f80 <ip_reasm_decr_mem_useage+0x8c>
   }

   ipr_curr_mem -= decrement;
 3240f6c:	d0a8fe17 	ldw	r2,-23560(gp)
 3240f70:	e0fffe0b 	ldhu	r3,-8(fp)
 3240f74:	10c5c83a 	sub	r2,r2,r3
 3240f78:	d0a8fe15 	stw	r2,-23560(gp)

   /* successfully decremented memory useage counter */
   return IPREASM_OK;
 3240f7c:	e03fff15 	stw	zero,-4(fp)
 3240f80:	e0bfff17 	ldw	r2,-4(fp)
}
 3240f84:	e037883a 	mov	sp,fp
 3240f88:	df000017 	ldw	fp,0(sp)
 3240f8c:	dec00104 	addi	sp,sp,4
 3240f90:	f800283a 	ret

03240f94 <ip_reasm_process_first_fragment>:
OUTPUT: ENP_RESOURCE if the memory check (in ip_reasm_check_mem_useage ()) 
or the allocation for an IRE fails; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_process_first_fragment (PACKET p)
{
 3240f94:	defff604 	addi	sp,sp,-40
 3240f98:	dfc00915 	stw	ra,36(sp)
 3240f9c:	df000815 	stw	fp,32(sp)
 3240fa0:	df000804 	addi	fp,sp,32
 3240fa4:	e13ffe15 	stw	r4,-8(fp)
   u_short total_len;
   int rc;

   /* this is a fragment from a hitherto unknown fragment stream; 
    * check for resource limits before accepting it */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (IRE)))) != IPREASM_OK)
 3240fa8:	e0bffe17 	ldw	r2,-8(fp)
 3240fac:	10800217 	ldw	r2,8(r2)
 3240fb0:	10802204 	addi	r2,r2,136
 3240fb4:	113fffcc 	andi	r4,r2,65535
 3240fb8:	3240db40 	call	3240db4 <ip_reasm_check_mem_useage>
 3240fbc:	e0bff815 	stw	r2,-32(fp)
 3240fc0:	e0bff817 	ldw	r2,-32(fp)
 3240fc4:	1005003a 	cmpeq	r2,r2,zero
 3240fc8:	1000101e 	bne	r2,zero,324100c <ip_reasm_process_first_fragment+0x78>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 3240fcc:	01000084 	movi	r4,2
 3240fd0:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free (p);
 3240fd4:	e13ffe17 	ldw	r4,-8(fp)
 3240fd8:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3240fdc:	01000084 	movi	r4,2
 3240fe0:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 3240fe4:	0080c9b4 	movhi	r2,806
 3240fe8:	10b54b04 	addi	r2,r2,-10964
 3240fec:	10800f17 	ldw	r2,60(r2)
 3240ff0:	10c00044 	addi	r3,r2,1
 3240ff4:	0080c9b4 	movhi	r2,806
 3240ff8:	10b54b04 	addi	r2,r2,-10964
 3240ffc:	10c00f15 	stw	r3,60(r2)
      return rc;
 3241000:	e0bff817 	ldw	r2,-32(fp)
 3241004:	e0bfff15 	stw	r2,-4(fp)
 3241008:	00009406 	br	324125c <ip_reasm_process_first_fragment+0x2c8>
   }

   /* we are ok wrt memory limits; since this is the first fragment, we need 
    * to create an IRE entry */
   irep = (IREP) IPR_ALLOC(sizeof(IRE));
 324100c:	01002204 	movi	r4,136
 3241010:	322b9340 	call	322b934 <npalloc>
 3241014:	e0bffc15 	stw	r2,-16(fp)
   if (irep == 0) 
 3241018:	e0bffc17 	ldw	r2,-16(fp)
 324101c:	1004c03a 	cmpne	r2,r2,zero
 3241020:	1000101e 	bne	r2,zero,3241064 <ip_reasm_process_first_fragment+0xd0>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 3241024:	01000084 	movi	r4,2
 3241028:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free (p);
 324102c:	e13ffe17 	ldw	r4,-8(fp)
 3241030:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241034:	01000084 	movi	r4,2
 3241038:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 324103c:	0080c9b4 	movhi	r2,806
 3241040:	10b54b04 	addi	r2,r2,-10964
 3241044:	10800f17 	ldw	r2,60(r2)
 3241048:	10c00044 	addi	r3,r2,1
 324104c:	0080c9b4 	movhi	r2,806
 3241050:	10b54b04 	addi	r2,r2,-10964
 3241054:	10c00f15 	stw	r3,60(r2)
      return ENP_RESOURCE;
 3241058:	00bffa84 	movi	r2,-22
 324105c:	e0bfff15 	stw	r2,-4(fp)
 3241060:	00007e06 	br	324125c <ip_reasm_process_first_fragment+0x2c8>
   }

   pip = ip_head(p);
 3241064:	e0bffe17 	ldw	r2,-8(fp)
 3241068:	10800317 	ldw	r2,12(r2)
 324106c:	e0bffd15 	stw	r2,-12(fp)
   iphlen = ip_hlen(pip);
 3241070:	e0bffd17 	ldw	r2,-12(fp)
 3241074:	10800003 	ldbu	r2,0(r2)
 3241078:	108003cc 	andi	r2,r2,15
 324107c:	1085883a 	add	r2,r2,r2
 3241080:	1085883a 	add	r2,r2,r2
 3241084:	e0bffa05 	stb	r2,-24(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 3241088:	e13ffd17 	ldw	r4,-12(fp)
 324108c:	3240cc80 	call	3240cc8 <ip_reasm_determine_type_of_frag>
 3241090:	e0bffb15 	stw	r2,-20(fp)
   frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 3241094:	e0bffd17 	ldw	r2,-12(fp)
 3241098:	1080018b 	ldhu	r2,6(r2)
 324109c:	10bfffcc 	andi	r2,r2,65535
 32410a0:	1004d23a 	srli	r2,r2,8
 32410a4:	10803fcc 	andi	r2,r2,255
 32410a8:	1009883a 	mov	r4,r2
 32410ac:	e0bffd17 	ldw	r2,-12(fp)
 32410b0:	1080018b 	ldhu	r2,6(r2)
 32410b4:	10bfffcc 	andi	r2,r2,65535
 32410b8:	1004923a 	slli	r2,r2,8
 32410bc:	1007883a 	mov	r3,r2
 32410c0:	00bfc004 	movi	r2,-256
 32410c4:	1884703a 	and	r2,r3,r2
 32410c8:	2084b03a 	or	r2,r4,r2
 32410cc:	1087ffcc 	andi	r2,r2,8191
 32410d0:	100490fa 	slli	r2,r2,3
 32410d4:	e0bff98d 	sth	r2,-26(fp)
   total_len = ntohs(pip->ip_len);
 32410d8:	e0bffd17 	ldw	r2,-12(fp)
 32410dc:	1080008b 	ldhu	r2,2(r2)
 32410e0:	10bfffcc 	andi	r2,r2,65535
 32410e4:	1004d23a 	srli	r2,r2,8
 32410e8:	10803fcc 	andi	r2,r2,255
 32410ec:	1009883a 	mov	r4,r2
 32410f0:	e0bffd17 	ldw	r2,-12(fp)
 32410f4:	1080008b 	ldhu	r2,2(r2)
 32410f8:	10bfffcc 	andi	r2,r2,65535
 32410fc:	1004923a 	slli	r2,r2,8
 3241100:	1007883a 	mov	r3,r2
 3241104:	00bfc004 	movi	r2,-256
 3241108:	1884703a 	and	r2,r3,r2
 324110c:	2084b03a 	or	r2,r4,r2
 3241110:	e0bff90d 	sth	r2,-28(fp)

   /* now setup various fields in the IRE entry (multi-byte fields stored in network 
    * byte order) */
   irep->src = pip->ip_src;
 3241114:	e0bffd17 	ldw	r2,-12(fp)
 3241118:	10c00317 	ldw	r3,12(r2)
 324111c:	e0bffc17 	ldw	r2,-16(fp)
 3241120:	10c00115 	stw	r3,4(r2)
   irep->dest = pip->ip_dest;
 3241124:	e0bffd17 	ldw	r2,-12(fp)
 3241128:	10c00417 	ldw	r3,16(r2)
 324112c:	e0bffc17 	ldw	r2,-16(fp)
 3241130:	10c00215 	stw	r3,8(r2)
   irep->prot = pip->ip_prot;
 3241134:	e0bffd17 	ldw	r2,-12(fp)
 3241138:	10c00243 	ldbu	r3,9(r2)
 324113c:	e0bffc17 	ldw	r2,-16(fp)
 3241140:	10c00385 	stb	r3,14(r2)
   irep->id = pip->ip_id;
 3241144:	e0bffd17 	ldw	r2,-12(fp)
 3241148:	10c0010b 	ldhu	r3,4(r2)
 324114c:	e0bffc17 	ldw	r2,-16(fp)
 3241150:	10c0030d 	sth	r3,12(r2)
   if (ftype == IP_LF)
 3241154:	e0bffb17 	ldw	r2,-20(fp)
 3241158:	10800158 	cmpnei	r2,r2,5
 324115c:	10000a1e 	bne	r2,zero,3241188 <ip_reasm_process_first_fragment+0x1f4>
      {
      irep->length = frag_offset + (total_len - iphlen);
 3241160:	e0fffa03 	ldbu	r3,-24(fp)
 3241164:	e0bff90b 	ldhu	r2,-28(fp)
 3241168:	10c5c83a 	sub	r2,r2,r3
 324116c:	1007883a 	mov	r3,r2
 3241170:	e0bff98b 	ldhu	r2,-26(fp)
 3241174:	1885883a 	add	r2,r3,r2
 3241178:	1007883a 	mov	r3,r2
 324117c:	e0bffc17 	ldw	r2,-16(fp)
 3241180:	10c0040d 	sth	r3,16(r2)
 3241184:	00000a06 	br	32411b0 <ip_reasm_process_first_fragment+0x21c>
      }
   else if (ftype == IP_FF)
 3241188:	e0bffb17 	ldw	r2,-20(fp)
 324118c:	10800058 	cmpnei	r2,r2,1
 3241190:	1000071e 	bne	r2,zero,32411b0 <ip_reasm_process_first_fragment+0x21c>
       * out, and results in the transmission of an ICMP Time Exceeded message (with the
       * code set to "fragment reassembly time exceeded").  Please note that the 'l2_hdr' 
       * as set below may not be the start address for the L2 header (but it is adequate 
       * for our use).  If the FF is never received, these fields stay at their initial
       * value of 0. */
      irep->l2_hdr = p->nb_buff;
 3241194:	e0bffe17 	ldw	r2,-8(fp)
 3241198:	10c00117 	ldw	r3,4(r2)
 324119c:	e0bffc17 	ldw	r2,-16(fp)
 32411a0:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 32411a4:	e0fffd17 	ldw	r3,-12(fp)
 32411a8:	e0bffc17 	ldw	r2,-16(fp)
 32411ac:	10c02015 	stw	r3,128(r2)
      }

   /* note that the 'rcvd' and 'length' counters only keep track of the data part of 
    * the IP datagram */
   irep->rcvd = total_len - iphlen;
 32411b0:	e0fffa03 	ldbu	r3,-24(fp)
 32411b4:	e0bff90b 	ldhu	r2,-28(fp)
 32411b8:	10c5c83a 	sub	r2,r2,r3
 32411bc:	1007883a 	mov	r3,r2
 32411c0:	e0bffc17 	ldw	r2,-16(fp)
 32411c4:	10c0048d 	sth	r3,18(r2)
   irep->age = 0;
 32411c8:	e0bffc17 	ldw	r2,-16(fp)
 32411cc:	10000515 	stw	zero,20(r2)

   /* all RFQs are compact when created */
   irep->flags |= IPR_RFQ_COMPACT;
 32411d0:	e0bffc17 	ldw	r2,-16(fp)
 32411d4:	10802103 	ldbu	r2,132(r2)
 32411d8:	10800054 	ori	r2,r2,1
 32411dc:	1007883a 	mov	r3,r2
 32411e0:	e0bffc17 	ldw	r2,-16(fp)
 32411e4:	10c02105 	stb	r3,132(r2)

   /* store PACKET pointer in the first location of the first RFQ */
   irep->rfq.bufp[0] = p;
 32411e8:	e0fffc17 	ldw	r3,-16(fp)
 32411ec:	e0bffe17 	ldw	r2,-8(fp)
 32411f0:	18800715 	stw	r2,28(r3)
   irep->rfq.frag_offset[0] = frag_offset;
 32411f4:	e0fffc17 	ldw	r3,-16(fp)
 32411f8:	e0bff98b 	ldhu	r2,-26(fp)
 32411fc:	1880170d 	sth	r2,92(r3)
   /* the next pointer in the RFQ is already 0 */

   p->nb_prot += iphlen;
 3241200:	e0bffe17 	ldw	r2,-8(fp)
 3241204:	10c00317 	ldw	r3,12(r2)
 3241208:	e0bffa03 	ldbu	r2,-24(fp)
 324120c:	1887883a 	add	r3,r3,r2
 3241210:	e0bffe17 	ldw	r2,-8(fp)
 3241214:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 3241218:	e0bffe17 	ldw	r2,-8(fp)
 324121c:	10c00417 	ldw	r3,16(r2)
 3241220:	e0bffa03 	ldbu	r2,-24(fp)
 3241224:	1887c83a 	sub	r3,r3,r2
 3241228:	e0bffe17 	ldw	r2,-8(fp)
 324122c:	10c00415 	stw	r3,16(r2)

   /* insert at start of global IRE list */
   irep->next = h_ireq;
 3241230:	d0e8ff17 	ldw	r3,-23556(gp)
 3241234:	e0bffc17 	ldw	r2,-16(fp)
 3241238:	10c00015 	stw	r3,0(r2)
   h_ireq = irep;
 324123c:	e0bffc17 	ldw	r2,-16(fp)
 3241240:	d0a8ff15 	stw	r2,-23556(gp)

   /* increment the memory useage */
   ip_reasm_incr_mem_useage (p->nb_blen + (sizeof (IRE)));
 3241244:	e0bffe17 	ldw	r2,-8(fp)
 3241248:	10800217 	ldw	r2,8(r2)
 324124c:	10802204 	addi	r2,r2,136
 3241250:	113fffcc 	andi	r4,r2,65535
 3241254:	3240e4c0 	call	3240e4c <ip_reasm_incr_mem_useage>

   return IPREASM_OK;
 3241258:	e03fff15 	stw	zero,-4(fp)
 324125c:	e0bfff17 	ldw	r2,-4(fp)
}
 3241260:	e037883a 	mov	sp,fp
 3241264:	dfc00117 	ldw	ra,4(sp)
 3241268:	df000017 	ldw	fp,0(sp)
 324126c:	dec00204 	addi	sp,sp,8
 3241270:	f800283a 	ret

03241274 <ip_reassm>:
merely passes their return code back to its caller.  Otherwise, it returns
IPREASM_OK indicating that the fragment was successfully processed.
*/

int ip_reassm (PACKET p)
{
 3241274:	defff804 	addi	sp,sp,-32
 3241278:	dfc00715 	stw	ra,28(sp)
 324127c:	df000615 	stw	fp,24(sp)
 3241280:	df000604 	addi	fp,sp,24
 3241284:	e13ffe15 	stw	r4,-8(fp)
   IREP irep;
   struct ip * pip;
   int rc1, rc2;

   pip = ip_head(p);
 3241288:	e0bffe17 	ldw	r2,-8(fp)
 324128c:	10800317 	ldw	r2,12(r2)
 3241290:	e0bffc15 	stw	r2,-16(fp)

   /* we have just received a fragment, so let's start processing it.  First
    * check for a matching IRE entry. */
   irep = ip_reasm_match_frag_with_ire (pip);
 3241294:	e13ffc17 	ldw	r4,-16(fp)
 3241298:	3240bf80 	call	3240bf8 <ip_reasm_match_frag_with_ire>
 324129c:	e0bffd15 	stw	r2,-12(fp)

   if (!irep)
 32412a0:	e0bffd17 	ldw	r2,-12(fp)
 32412a4:	1004c03a 	cmpne	r2,r2,zero
 32412a8:	1000091e 	bne	r2,zero,32412d0 <ip_reassm+0x5c>
   {
      /* this is the first packet for a "new" fragment stream */
      if ((rc1 = ip_reasm_process_first_fragment (p)) != IPREASM_OK)
 32412ac:	e13ffe17 	ldw	r4,-8(fp)
 32412b0:	3240f940 	call	3240f94 <ip_reasm_process_first_fragment>
 32412b4:	e0bffb15 	stw	r2,-20(fp)
 32412b8:	e0bffb17 	ldw	r2,-20(fp)
 32412bc:	1005003a 	cmpeq	r2,r2,zero
 32412c0:	10000d1e 	bne	r2,zero,32412f8 <ip_reassm+0x84>
      {
         /* ip_reasm_process_first_fragment () will free the packet */
         return rc1;
 32412c4:	e0bffb17 	ldw	r2,-20(fp)
 32412c8:	e0bfff15 	stw	r2,-4(fp)
 32412cc:	00000b06 	br	32412fc <ip_reassm+0x88>
      }
   }
   else
   {
      /* a matching IRE already exists for this fragment */
      if ((rc2 = ip_reasm_process_subsequent_fragments (p, irep)) != IPREASM_OK)
 32412d0:	e13ffe17 	ldw	r4,-8(fp)
 32412d4:	e17ffd17 	ldw	r5,-12(fp)
 32412d8:	32418a40 	call	32418a4 <ip_reasm_process_subsequent_fragments>
 32412dc:	e0bffa15 	stw	r2,-24(fp)
 32412e0:	e0bffa17 	ldw	r2,-24(fp)
 32412e4:	1005003a 	cmpeq	r2,r2,zero
 32412e8:	1000031e 	bne	r2,zero,32412f8 <ip_reassm+0x84>
      {
         /* ip_reasm_process_subsequent_fragments () has already deleted the IRE entry */
         return rc2;
 32412ec:	e0bffa17 	ldw	r2,-24(fp)
 32412f0:	e0bfff15 	stw	r2,-4(fp)
 32412f4:	00000106 	br	32412fc <ip_reassm+0x88>
      }
   }

   return IPREASM_OK;
 32412f8:	e03fff15 	stw	zero,-4(fp)
 32412fc:	e0bfff17 	ldw	r2,-4(fp)
}
 3241300:	e037883a 	mov	sp,fp
 3241304:	dfc00117 	ldw	ra,4(sp)
 3241308:	df000017 	ldw	fp,0(sp)
 324130c:	dec00204 	addi	sp,sp,8
 3241310:	f800283a 	ret

03241314 <ip_reasm_compute_overlap>:
            (i.e., contains "unique" data).
*/

IPREASM_RC ip_reasm_compute_overlap (PACKET p, IREP irep, u_short * indexp, 
 RFQP * last_rfqpp, u_short * frag_offsetp, u_char * hole_createdp)
{
 3241314:	defff204 	addi	sp,sp,-56
 3241318:	dfc00d15 	stw	ra,52(sp)
 324131c:	df000c15 	stw	fp,48(sp)
 3241320:	df000c04 	addi	fp,sp,48
 3241324:	e13ffb15 	stw	r4,-20(fp)
 3241328:	e17ffc15 	stw	r5,-16(fp)
 324132c:	e1bffd15 	stw	r6,-12(fp)
 3241330:	e1fffe15 	stw	r7,-8(fp)
   u_short currend;
   u_short drop_len;
   u_char iphlen;
   u_short i;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 3241334:	e13ffc17 	ldw	r4,-16(fp)
 3241338:	3241e380 	call	3241e38 <ip_reasm_find_ire>
 324133c:	10803fcc 	andi	r2,r2,255
 3241340:	10800060 	cmpeqi	r2,r2,1
 3241344:	1000101e 	bne	r2,zero,3241388 <ip_reasm_compute_overlap+0x74>
      {
      ++ire_stats.bad_irep;
 3241348:	0080c9b4 	movhi	r2,806
 324134c:	10b55f04 	addi	r2,r2,-10884
 3241350:	10800017 	ldw	r2,0(r2)
 3241354:	10c00044 	addi	r3,r2,1
 3241358:	0080c9b4 	movhi	r2,806
 324135c:	10b55f04 	addi	r2,r2,-10884
 3241360:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 3241364:	01000084 	movi	r4,2
 3241368:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free (p);
 324136c:	e13ffb17 	ldw	r4,-20(fp)
 3241370:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241374:	01000084 	movi	r4,2
 3241378:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return IPREASM_DROP_FRAG_BAD_PARAM;
 324137c:	00800044 	movi	r2,1
 3241380:	e0bfff15 	stw	r2,-4(fp)
 3241384:	00014106 	br	324188c <ip_reasm_compute_overlap+0x578>
      }

   jrip = ip_head(p);
 3241388:	e0bffb17 	ldw	r2,-20(fp)
 324138c:	10800317 	ldw	r2,12(r2)
 3241390:	e0bff815 	stw	r2,-32(fp)
   iphlen = ip_hlen (jrip);
 3241394:	e0bff817 	ldw	r2,-32(fp)
 3241398:	10800003 	ldbu	r2,0(r2)
 324139c:	108003cc 	andi	r2,r2,15
 32413a0:	1085883a 	add	r2,r2,r2
 32413a4:	1085883a 	add	r2,r2,r2
 32413a8:	e0bff485 	stb	r2,-46(fp)
   jrstart = (((ntohs(jrip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 32413ac:	e0bff817 	ldw	r2,-32(fp)
 32413b0:	1080018b 	ldhu	r2,6(r2)
 32413b4:	10bfffcc 	andi	r2,r2,65535
 32413b8:	1004d23a 	srli	r2,r2,8
 32413bc:	10803fcc 	andi	r2,r2,255
 32413c0:	1009883a 	mov	r4,r2
 32413c4:	e0bff817 	ldw	r2,-32(fp)
 32413c8:	1080018b 	ldhu	r2,6(r2)
 32413cc:	10bfffcc 	andi	r2,r2,65535
 32413d0:	1004923a 	slli	r2,r2,8
 32413d4:	1007883a 	mov	r3,r2
 32413d8:	00bfc004 	movi	r2,-256
 32413dc:	1884703a 	and	r2,r3,r2
 32413e0:	2084b03a 	or	r2,r4,r2
 32413e4:	1087ffcc 	andi	r2,r2,8191
 32413e8:	100490fa 	slli	r2,r2,3
 32413ec:	e0bff70d 	sth	r2,-36(fp)
   jrend =   jrstart + ((ntohs(jrip->ip_len)) - iphlen) - 1;
 32413f0:	e0bff817 	ldw	r2,-32(fp)
 32413f4:	1080008b 	ldhu	r2,2(r2)
 32413f8:	10bfffcc 	andi	r2,r2,65535
 32413fc:	1004d23a 	srli	r2,r2,8
 3241400:	10803fcc 	andi	r2,r2,255
 3241404:	1009883a 	mov	r4,r2
 3241408:	e0bff817 	ldw	r2,-32(fp)
 324140c:	1080008b 	ldhu	r2,2(r2)
 3241410:	10bfffcc 	andi	r2,r2,65535
 3241414:	1004923a 	slli	r2,r2,8
 3241418:	1007883a 	mov	r3,r2
 324141c:	00bfc004 	movi	r2,-256
 3241420:	1884703a 	and	r2,r3,r2
 3241424:	2084b03a 	or	r2,r4,r2
 3241428:	1007883a 	mov	r3,r2
 324142c:	e0bff483 	ldbu	r2,-46(fp)
 3241430:	1885c83a 	sub	r2,r3,r2
 3241434:	1007883a 	mov	r3,r2
 3241438:	e0bff70b 	ldhu	r2,-36(fp)
 324143c:	1885883a 	add	r2,r3,r2
 3241440:	10bfffc4 	addi	r2,r2,-1
 3241444:	e0bff68d 	sth	r2,-38(fp)
   /* skip past the IP header of the just received fragment as we get ready 
    * to compare for overlap between the just received fragment and the 
    * fragments that are currently queued in the IRE entry for this fragment 
    * chain */
   p->nb_prot += iphlen;
 3241448:	e0bffb17 	ldw	r2,-20(fp)
 324144c:	10c00317 	ldw	r3,12(r2)
 3241450:	e0bff483 	ldbu	r2,-46(fp)
 3241454:	1887883a 	add	r3,r3,r2
 3241458:	e0bffb17 	ldw	r2,-20(fp)
 324145c:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 3241460:	e0bffb17 	ldw	r2,-20(fp)
 3241464:	10c00417 	ldw	r3,16(r2)
 3241468:	e0bff483 	ldbu	r2,-46(fp)
 324146c:	1887c83a 	sub	r3,r3,r2
 3241470:	e0bffb17 	ldw	r2,-20(fp)
 3241474:	10c00415 	stw	r3,16(r2)

   *frag_offsetp = jrstart;
 3241478:	e0c00217 	ldw	r3,8(fp)
 324147c:	e0bff70b 	ldhu	r2,-36(fp)
 3241480:	1880000d 	sth	r2,0(r3)
   *indexp = INVALID_FRAG_INDEX;
 3241484:	e0fffd17 	ldw	r3,-12(fp)
 3241488:	00800404 	movi	r2,16
 324148c:	1880000d 	sth	r2,0(r3)
   *last_rfqpp = 0;
 3241490:	e0bffe17 	ldw	r2,-8(fp)
 3241494:	10000015 	stw	zero,0(r2)
   *hole_createdp = IPREASM_FALSE;
 3241498:	e0800317 	ldw	r2,12(fp)
 324149c:	10000005 	stb	zero,0(r2)

   rfqp = &(irep->rfq);
 32414a0:	e0bffc17 	ldw	r2,-16(fp)
 32414a4:	10800604 	addi	r2,r2,24
 32414a8:	e0bffa15 	stw	r2,-24(fp)

   while (rfqp)
 32414ac:	0000ef06 	br	324186c <ip_reasm_compute_overlap+0x558>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 32414b0:	e03ff40d 	sth	zero,-48(fp)
 32414b4:	0000df06 	br	3241834 <ip_reasm_compute_overlap+0x520>
         {
         if ((currpkt = rfqp->bufp[i]) != 0)
 32414b8:	e0bff40b 	ldhu	r2,-48(fp)
 32414bc:	e0fffa17 	ldw	r3,-24(fp)
 32414c0:	1085883a 	add	r2,r2,r2
 32414c4:	1085883a 	add	r2,r2,r2
 32414c8:	10c5883a 	add	r2,r2,r3
 32414cc:	10800104 	addi	r2,r2,4
 32414d0:	10800017 	ldw	r2,0(r2)
 32414d4:	e0bff915 	stw	r2,-28(fp)
 32414d8:	e0bff917 	ldw	r2,-28(fp)
 32414dc:	1005003a 	cmpeq	r2,r2,zero
 32414e0:	1000bf1e 	bne	r2,zero,32417e0 <ip_reasm_compute_overlap+0x4cc>
            {
            currstart = rfqp->frag_offset[i];
 32414e4:	e0bff40b 	ldhu	r2,-48(fp)
 32414e8:	e0fffa17 	ldw	r3,-24(fp)
 32414ec:	1085883a 	add	r2,r2,r2
 32414f0:	10c5883a 	add	r2,r2,r3
 32414f4:	10801104 	addi	r2,r2,68
 32414f8:	1080000b 	ldhu	r2,0(r2)
 32414fc:	e0bff60d 	sth	r2,-40(fp)
            currend = currstart + currpkt->nb_plen - 1;
 3241500:	e0bff917 	ldw	r2,-28(fp)
 3241504:	10800417 	ldw	r2,16(r2)
 3241508:	1007883a 	mov	r3,r2
 324150c:	e0bff60b 	ldhu	r2,-40(fp)
 3241510:	1885883a 	add	r2,r3,r2
 3241514:	10bfffc4 	addi	r2,r2,-1
 3241518:	e0bff58d 	sth	r2,-42(fp)

            if (currstart < jrstart)
 324151c:	e0fff60b 	ldhu	r3,-40(fp)
 3241520:	e0bff70b 	ldhu	r2,-36(fp)
 3241524:	18802b2e 	bgeu	r3,r2,32415d4 <ip_reasm_compute_overlap+0x2c0>
               {
               if (currend < jrend) /* cases A1 and A2 */
 3241528:	e0fff58b 	ldhu	r3,-42(fp)
 324152c:	e0bff68b 	ldhu	r2,-38(fp)
 3241530:	1880202e 	bgeu	r3,r2,32415b4 <ip_reasm_compute_overlap+0x2a0>
                  {
                  if (currend < jrstart) /* A1 */
 3241534:	e0fff58b 	ldhu	r3,-42(fp)
 3241538:	e0bff70b 	ldhu	r2,-36(fp)
 324153c:	1880ba36 	bltu	r3,r2,3241828 <ip_reasm_compute_overlap+0x514>
                     {
                     /* the just received fragment partially overlaps current 
                      * fragment on the latter's right; increment start 
                      * pointer and decrement length of just received fragment.
                      * Move on to the next fragment in the RFQ. */
                     drop_len = (currend - jrstart) + 1;
 3241540:	e0fff58b 	ldhu	r3,-42(fp)
 3241544:	e0bff70b 	ldhu	r2,-36(fp)
 3241548:	1885c83a 	sub	r2,r3,r2
 324154c:	10800044 	addi	r2,r2,1
 3241550:	e0bff50d 	sth	r2,-44(fp)
                     p->nb_prot += drop_len;
 3241554:	e0bffb17 	ldw	r2,-20(fp)
 3241558:	10c00317 	ldw	r3,12(r2)
 324155c:	e0bff50b 	ldhu	r2,-44(fp)
 3241560:	1887883a 	add	r3,r3,r2
 3241564:	e0bffb17 	ldw	r2,-20(fp)
 3241568:	10c00315 	stw	r3,12(r2)
                     p->nb_plen -= drop_len;
 324156c:	e0bffb17 	ldw	r2,-20(fp)
 3241570:	10c00417 	ldw	r3,16(r2)
 3241574:	e0bff50b 	ldhu	r2,-44(fp)
 3241578:	1887c83a 	sub	r3,r3,r2
 324157c:	e0bffb17 	ldw	r2,-20(fp)
 3241580:	10c00415 	stw	r3,16(r2)
                     jrstart += drop_len;
 3241584:	e0fff70b 	ldhu	r3,-36(fp)
 3241588:	e0bff50b 	ldhu	r2,-44(fp)
 324158c:	1885883a 	add	r2,r3,r2
 3241590:	e0bff70d 	sth	r2,-36(fp)
                     jrend = jrstart + p->nb_plen - 1;
 3241594:	e0bffb17 	ldw	r2,-20(fp)
 3241598:	10800417 	ldw	r2,16(r2)
 324159c:	1007883a 	mov	r3,r2
 32415a0:	e0bff70b 	ldhu	r2,-36(fp)
 32415a4:	1885883a 	add	r2,r3,r2
 32415a8:	10bfffc4 	addi	r2,r2,-1
 32415ac:	e0bff68d 	sth	r2,-38(fp)
 32415b0:	00009d06 	br	3241828 <ip_reasm_compute_overlap+0x514>
               else
                  {
                  /* currend is greater than or equal to jrend (cases E1 and E2).
                   * The current fragment is a superset of the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 32415b4:	01000084 	movi	r4,2
 32415b8:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
                  pk_free (p);
 32415bc:	e13ffb17 	ldw	r4,-20(fp)
 32415c0:	322a6400 	call	322a640 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 32415c4:	01000084 	movi	r4,2
 32415c8:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 32415cc:	e03fff15 	stw	zero,-4(fp)
 32415d0:	0000ae06 	br	324188c <ip_reasm_compute_overlap+0x578>
                  }
               }
            else if (currstart > jrstart)
 32415d4:	e0fff60b 	ldhu	r3,-40(fp)
 32415d8:	e0bff70b 	ldhu	r2,-36(fp)
 32415dc:	10c04d2e 	bgeu	r2,r3,3241714 <ip_reasm_compute_overlap+0x400>
               {
               if (currend > jrend) /* cases B1 and B2 */
 32415e0:	e0fff58b 	ldhu	r3,-42(fp)
 32415e4:	e0bff68b 	ldhu	r2,-38(fp)
 32415e8:	10c0112e 	bgeu	r2,r3,3241630 <ip_reasm_compute_overlap+0x31c>
                  {
                  if (currstart > jrend) /* B1 */
 32415ec:	e0fff60b 	ldhu	r3,-40(fp)
 32415f0:	e0bff68b 	ldhu	r2,-38(fp)
 32415f4:	10c08c36 	bltu	r2,r3,3241828 <ip_reasm_compute_overlap+0x514>
                     {
                     /* just received fragment partially overlaps current 
                      * fragment on the latter's left; decrement length of 
                      * just received fragment.  Move on to the next fragment 
                      * in the RFQ. */
                     p->nb_plen = currstart - jrstart;
 32415f8:	e0fff60b 	ldhu	r3,-40(fp)
 32415fc:	e0bff70b 	ldhu	r2,-36(fp)
 3241600:	1885c83a 	sub	r2,r3,r2
 3241604:	1007883a 	mov	r3,r2
 3241608:	e0bffb17 	ldw	r2,-20(fp)
 324160c:	10c00415 	stw	r3,16(r2)
                     /* start offset remains unchanged, but jrend must be updated */
                     jrend = jrstart + p->nb_plen - 1;
 3241610:	e0bffb17 	ldw	r2,-20(fp)
 3241614:	10800417 	ldw	r2,16(r2)
 3241618:	1007883a 	mov	r3,r2
 324161c:	e0bff70b 	ldhu	r2,-36(fp)
 3241620:	1885883a 	add	r2,r3,r2
 3241624:	10bfffc4 	addi	r2,r2,-1
 3241628:	e0bff68d 	sth	r2,-38(fp)
 324162c:	00007e06 	br	3241828 <ip_reasm_compute_overlap+0x514>
                     }
                  }
               else if (currend == jrend) /* F1 */
 3241630:	e0fff58b 	ldhu	r3,-42(fp)
 3241634:	e0bff68b 	ldhu	r2,-38(fp)
 3241638:	18800e1e 	bne	r3,r2,3241674 <ip_reasm_compute_overlap+0x360>
                  {
                  /* current fragment is a subset of the just received fragment.  
                   * Decrement the length of the just received fragment.  Move
                   * on to the next fragment in the RFQ. */
                  p->nb_plen = currstart - jrstart;
 324163c:	e0fff60b 	ldhu	r3,-40(fp)
 3241640:	e0bff70b 	ldhu	r2,-36(fp)
 3241644:	1885c83a 	sub	r2,r3,r2
 3241648:	1007883a 	mov	r3,r2
 324164c:	e0bffb17 	ldw	r2,-20(fp)
 3241650:	10c00415 	stw	r3,16(r2)
                  jrend = jrstart + p->nb_plen - 1;
 3241654:	e0bffb17 	ldw	r2,-20(fp)
 3241658:	10800417 	ldw	r2,16(r2)
 324165c:	1007883a 	mov	r3,r2
 3241660:	e0bff70b 	ldhu	r2,-36(fp)
 3241664:	1885883a 	add	r2,r3,r2
 3241668:	10bfffc4 	addi	r2,r2,-1
 324166c:	e0bff68d 	sth	r2,-38(fp)
 3241670:	00006d06 	br	3241828 <ip_reasm_compute_overlap+0x514>
                  {
                  /* currend is less than jrend (case F2).  current fragment is 
                   * a subset of the just received fragment.  Drop current
                   * fragment.  Move on to the next fragment in the RFQ.  Decrement
                   * the amount of memory currently in use. */
                  ip_reasm_decr_mem_useage (currpkt->nb_blen);
 3241674:	e0bff917 	ldw	r2,-28(fp)
 3241678:	10800217 	ldw	r2,8(r2)
 324167c:	113fffcc 	andi	r4,r2,65535
 3241680:	3240ef40 	call	3240ef4 <ip_reasm_decr_mem_useage>
                  irep->rcvd -= currpkt->nb_plen;
 3241684:	e0bffc17 	ldw	r2,-16(fp)
 3241688:	10c0048b 	ldhu	r3,18(r2)
 324168c:	e0bff917 	ldw	r2,-28(fp)
 3241690:	10800417 	ldw	r2,16(r2)
 3241694:	1885c83a 	sub	r2,r3,r2
 3241698:	1007883a 	mov	r3,r2
 324169c:	e0bffc17 	ldw	r2,-16(fp)
 32416a0:	10c0048d 	sth	r3,18(r2)
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 32416a4:	01000084 	movi	r4,2
 32416a8:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
                  pk_free (currpkt);
 32416ac:	e13ff917 	ldw	r4,-28(fp)
 32416b0:	322a6400 	call	322a640 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 32416b4:	01000084 	movi	r4,2
 32416b8:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
                  rfqp->bufp[i] = 0; /* mark slot as unused */
 32416bc:	e0bff40b 	ldhu	r2,-48(fp)
 32416c0:	e0fffa17 	ldw	r3,-24(fp)
 32416c4:	1085883a 	add	r2,r2,r2
 32416c8:	1085883a 	add	r2,r2,r2
 32416cc:	10c5883a 	add	r2,r2,r3
 32416d0:	10800104 	addi	r2,r2,4
 32416d4:	10000015 	stw	zero,0(r2)
                  /* save the location of the empty slot */
                  if ((*indexp) == INVALID_FRAG_INDEX) 
 32416d8:	e0bffd17 	ldw	r2,-12(fp)
 32416dc:	1080000b 	ldhu	r2,0(r2)
 32416e0:	10bfffcc 	andi	r2,r2,65535
 32416e4:	10800418 	cmpnei	r2,r2,16
 32416e8:	1000061e 	bne	r2,zero,3241704 <ip_reasm_compute_overlap+0x3f0>
                     {
                     *indexp = i;
 32416ec:	e0fffd17 	ldw	r3,-12(fp)
 32416f0:	e0bff40b 	ldhu	r2,-48(fp)
 32416f4:	1880000d 	sth	r2,0(r3)
                     *last_rfqpp = rfqp;
 32416f8:	e0fffe17 	ldw	r3,-8(fp)
 32416fc:	e0bffa17 	ldw	r2,-24(fp)
 3241700:	18800015 	stw	r2,0(r3)
                     }
                  /* we've just created a hole; the array may no longer be "compact" */
                  *hole_createdp = IPREASM_TRUE;
 3241704:	e0c00317 	ldw	r3,12(fp)
 3241708:	00800044 	movi	r2,1
 324170c:	18800005 	stb	r2,0(r3)
 3241710:	00004506 	br	3241828 <ip_reasm_compute_overlap+0x514>
                  }
               }
            else
               {
               /* currstart and jrstart are equal */
               if (currend == jrend) /* case C */
 3241714:	e0fff58b 	ldhu	r3,-42(fp)
 3241718:	e0bff68b 	ldhu	r2,-38(fp)
 324171c:	1880081e 	bne	r3,r2,3241740 <ip_reasm_compute_overlap+0x42c>
                  {
                  /* the current fragment is identical to the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 3241720:	01000084 	movi	r4,2
 3241724:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
                  pk_free (p);
 3241728:	e13ffb17 	ldw	r4,-20(fp)
 324172c:	322a6400 	call	322a640 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241730:	01000084 	movi	r4,2
 3241734:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 3241738:	e03fff15 	stw	zero,-4(fp)
 324173c:	00005306 	br	324188c <ip_reasm_compute_overlap+0x578>
                  }
               else if (currend > jrend) /* case D1 */
 3241740:	e0fff58b 	ldhu	r3,-42(fp)
 3241744:	e0bff68b 	ldhu	r2,-38(fp)
 3241748:	10c0082e 	bgeu	r2,r3,324176c <ip_reasm_compute_overlap+0x458>
                  {
                  /* current fragment is a superset of just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 324174c:	01000084 	movi	r4,2
 3241750:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
                  pk_free (p);
 3241754:	e13ffb17 	ldw	r4,-20(fp)
 3241758:	322a6400 	call	322a640 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 324175c:	01000084 	movi	r4,2
 3241760:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 3241764:	e03fff15 	stw	zero,-4(fp)
 3241768:	00004806 	br	324188c <ip_reasm_compute_overlap+0x578>
                  /* currend is less than jrend (case D2).  current fragment 
                   * is a subset of the just received fragment.  Increment 
                   * the start pointer and decrement the length of the just
                   * received fragment.  Move on to the next fragment in 
                   * the RFQ. */
                  drop_len = (currend - jrstart) + 1;
 324176c:	e0fff58b 	ldhu	r3,-42(fp)
 3241770:	e0bff70b 	ldhu	r2,-36(fp)
 3241774:	1885c83a 	sub	r2,r3,r2
 3241778:	10800044 	addi	r2,r2,1
 324177c:	e0bff50d 	sth	r2,-44(fp)
                  p->nb_prot += drop_len;
 3241780:	e0bffb17 	ldw	r2,-20(fp)
 3241784:	10c00317 	ldw	r3,12(r2)
 3241788:	e0bff50b 	ldhu	r2,-44(fp)
 324178c:	1887883a 	add	r3,r3,r2
 3241790:	e0bffb17 	ldw	r2,-20(fp)
 3241794:	10c00315 	stw	r3,12(r2)
                  p->nb_plen -= drop_len;
 3241798:	e0bffb17 	ldw	r2,-20(fp)
 324179c:	10c00417 	ldw	r3,16(r2)
 32417a0:	e0bff50b 	ldhu	r2,-44(fp)
 32417a4:	1887c83a 	sub	r3,r3,r2
 32417a8:	e0bffb17 	ldw	r2,-20(fp)
 32417ac:	10c00415 	stw	r3,16(r2)
                  jrstart += drop_len;
 32417b0:	e0fff70b 	ldhu	r3,-36(fp)
 32417b4:	e0bff50b 	ldhu	r2,-44(fp)
 32417b8:	1885883a 	add	r2,r3,r2
 32417bc:	e0bff70d 	sth	r2,-36(fp)
                  jrend = jrstart + p->nb_plen - 1;
 32417c0:	e0bffb17 	ldw	r2,-20(fp)
 32417c4:	10800417 	ldw	r2,16(r2)
 32417c8:	1007883a 	mov	r3,r2
 32417cc:	e0bff70b 	ldhu	r2,-36(fp)
 32417d0:	1885883a 	add	r2,r3,r2
 32417d4:	10bfffc4 	addi	r2,r2,-1
 32417d8:	e0bff68d 	sth	r2,-38(fp)
 32417dc:	00001206 	br	3241828 <ip_reasm_compute_overlap+0x514>
                  }
               }
            } /* end if (PACKET buffer exists at this slot) */
         else
            {
            if ((*indexp) == INVALID_FRAG_INDEX)
 32417e0:	e0bffd17 	ldw	r2,-12(fp)
 32417e4:	1080000b 	ldhu	r2,0(r2)
 32417e8:	10bfffcc 	andi	r2,r2,65535
 32417ec:	10800418 	cmpnei	r2,r2,16
 32417f0:	1000061e 	bne	r2,zero,324180c <ip_reasm_compute_overlap+0x4f8>
               {
               *indexp = i;
 32417f4:	e0fffd17 	ldw	r3,-12(fp)
 32417f8:	e0bff40b 	ldhu	r2,-48(fp)
 32417fc:	1880000d 	sth	r2,0(r3)
               *last_rfqpp = rfqp;               
 3241800:	e0fffe17 	ldw	r3,-8(fp)
 3241804:	e0bffa17 	ldw	r2,-24(fp)
 3241808:	18800015 	stw	r2,0(r3)
               }
            if (irep->flags & IPR_RFQ_COMPACT)
 324180c:	e0bffc17 	ldw	r2,-16(fp)
 3241810:	10802103 	ldbu	r2,132(r2)
 3241814:	10803fcc 	andi	r2,r2,255
 3241818:	1080004c 	andi	r2,r2,1
 324181c:	10803fcc 	andi	r2,r2,255
 3241820:	1004c03a 	cmpne	r2,r2,zero
 3241824:	1000061e 	bne	r2,zero,3241840 <ip_reasm_compute_overlap+0x52c>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 3241828:	e0bff40b 	ldhu	r2,-48(fp)
 324182c:	10800044 	addi	r2,r2,1
 3241830:	e0bff40d 	sth	r2,-48(fp)
 3241834:	e0bff40b 	ldhu	r2,-48(fp)
 3241838:	10800430 	cmpltui	r2,r2,16
 324183c:	103f1e1e 	bne	r2,zero,32414b8 <ip_reasm_compute_overlap+0x1a4>
               }
            }
         } /* end FOR (0...(IPR_MAX_FRAGS - 1)) */

      /* skip saving RFQ pointer if we've already found an empty slot */
      if ((*indexp) == INVALID_FRAG_INDEX) 
 3241840:	e0bffd17 	ldw	r2,-12(fp)
 3241844:	1080000b 	ldhu	r2,0(r2)
 3241848:	10bfffcc 	andi	r2,r2,65535
 324184c:	10800418 	cmpnei	r2,r2,16
 3241850:	1000031e 	bne	r2,zero,3241860 <ip_reasm_compute_overlap+0x54c>
         {
         *last_rfqpp = rfqp;
 3241854:	e0fffe17 	ldw	r3,-8(fp)
 3241858:	e0bffa17 	ldw	r2,-24(fp)
 324185c:	18800015 	stw	r2,0(r3)
         }
      rfqp = rfqp->next;
 3241860:	e0bffa17 	ldw	r2,-24(fp)
 3241864:	10800017 	ldw	r2,0(r2)
 3241868:	e0bffa15 	stw	r2,-24(fp)
   *last_rfqpp = 0;
   *hole_createdp = IPREASM_FALSE;

   rfqp = &(irep->rfq);

   while (rfqp)
 324186c:	e0bffa17 	ldw	r2,-24(fp)
 3241870:	1004c03a 	cmpne	r2,r2,zero
 3241874:	103f0e1e 	bne	r2,zero,32414b0 <ip_reasm_compute_overlap+0x19c>
      } /* end while (rfqp) */

   /* if no empty slots were found, (*last_rfqpp) will contain a pointer 
    * to the last RFQ that we were working with */

   *frag_offsetp = jrstart; /* stored in host byte order */
 3241878:	e0c00217 	ldw	r3,8(fp)
 324187c:	e0bff70b 	ldhu	r2,-36(fp)
 3241880:	1880000d 	sth	r2,0(r3)

   return IPREASM_ACCEPT_FRAG;
 3241884:	00800084 	movi	r2,2
 3241888:	e0bfff15 	stw	r2,-4(fp)
 324188c:	e0bfff17 	ldw	r2,-4(fp)
}
 3241890:	e037883a 	mov	sp,fp
 3241894:	dfc00117 	ldw	ra,4(sp)
 3241898:	df000017 	ldw	fp,0(sp)
 324189c:	dec00204 	addi	sp,sp,8
 32418a0:	f800283a 	ret

032418a4 <ip_reasm_process_subsequent_fragments>:
            queued fragments (and hence has been dropped), or if the fragment
            has been processed successfully.
*/

int ip_reasm_process_subsequent_fragments (PACKET p, IREP irep)
{
 32418a4:	deffed04 	addi	sp,sp,-76
 32418a8:	dfc01215 	stw	ra,72(sp)
 32418ac:	df001115 	stw	fp,68(sp)
 32418b0:	df001104 	addi	fp,sp,68
 32418b4:	e13ffa15 	stw	r4,-24(fp)
 32418b8:	e17ffb15 	stw	r5,-20(fp)
   PACKET reassy_pkt;
   struct ip * pip;
   RFQP new_rfqp = 0;
 32418bc:	e03ff415 	stw	zero,-48(fp)
   u_short index;
   RFQP rfqp;
   u_short frag_offset;
   u_char hole_created;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 32418c0:	e13ffb17 	ldw	r4,-20(fp)
 32418c4:	3241e380 	call	3241e38 <ip_reasm_find_ire>
 32418c8:	10803fcc 	andi	r2,r2,255
 32418cc:	10800060 	cmpeqi	r2,r2,1
 32418d0:	1000171e 	bne	r2,zero,3241930 <ip_reasm_process_subsequent_fragments+0x8c>
      {
      ++ire_stats.bad_irep;
 32418d4:	0080c9b4 	movhi	r2,806
 32418d8:	10b55f04 	addi	r2,r2,-10884
 32418dc:	10800017 	ldw	r2,0(r2)
 32418e0:	10c00044 	addi	r3,r2,1
 32418e4:	0080c9b4 	movhi	r2,806
 32418e8:	10b55f04 	addi	r2,r2,-10884
 32418ec:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 32418f0:	01000084 	movi	r4,2
 32418f4:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free (p);
 32418f8:	e13ffa17 	ldw	r4,-24(fp)
 32418fc:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241900:	01000084 	movi	r4,2
 3241904:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 3241908:	0080c9b4 	movhi	r2,806
 324190c:	10b54b04 	addi	r2,r2,-10964
 3241910:	10800f17 	ldw	r2,60(r2)
 3241914:	10c00044 	addi	r3,r2,1
 3241918:	0080c9b4 	movhi	r2,806
 324191c:	10b54b04 	addi	r2,r2,-10964
 3241920:	10c00f15 	stw	r3,60(r2)
      return ENP_PARAM;
 3241924:	00bffd84 	movi	r2,-10
 3241928:	e0bffe15 	stw	r2,-8(fp)
 324192c:	00013c06 	br	3241e20 <ip_reasm_process_subsequent_fragments+0x57c>
      }

   pip = ip_head(p);
 3241930:	e0bffa17 	ldw	r2,-24(fp)
 3241934:	10800317 	ldw	r2,12(r2)
 3241938:	e0bff515 	stw	r2,-44(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 324193c:	e13ff517 	ldw	r4,-44(fp)
 3241940:	3240cc80 	call	3240cc8 <ip_reasm_determine_type_of_frag>
 3241944:	e0bff215 	stw	r2,-56(fp)
   /* this fragment is a destined for an already queued fragment stream.
    * we update the 'length' field for LFs here because ip_reasm_compute_overlap ()
    * modifies the received fragment's nb_prot pointer (thereby making its IP header 
    * inaccessible) */
   if (ftype == IP_LF)
 3241948:	e0bff217 	ldw	r2,-56(fp)
 324194c:	10800158 	cmpnei	r2,r2,5
 3241950:	10002c1e 	bne	r2,zero,3241a04 <ip_reasm_process_subsequent_fragments+0x160>
      {
      irep->length = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3) + ((ntohs(pip->ip_len)) - ip_hlen(pip));
 3241954:	e0bff517 	ldw	r2,-44(fp)
 3241958:	1080018b 	ldhu	r2,6(r2)
 324195c:	10bfffcc 	andi	r2,r2,65535
 3241960:	1004d23a 	srli	r2,r2,8
 3241964:	10803fcc 	andi	r2,r2,255
 3241968:	1009883a 	mov	r4,r2
 324196c:	e0bff517 	ldw	r2,-44(fp)
 3241970:	1080018b 	ldhu	r2,6(r2)
 3241974:	10bfffcc 	andi	r2,r2,65535
 3241978:	1004923a 	slli	r2,r2,8
 324197c:	1007883a 	mov	r3,r2
 3241980:	00bfc004 	movi	r2,-256
 3241984:	1884703a 	and	r2,r3,r2
 3241988:	2084b03a 	or	r2,r4,r2
 324198c:	1087ffcc 	andi	r2,r2,8191
 3241990:	100490fa 	slli	r2,r2,3
 3241994:	100b883a 	mov	r5,r2
 3241998:	e0bff517 	ldw	r2,-44(fp)
 324199c:	1080008b 	ldhu	r2,2(r2)
 32419a0:	10bfffcc 	andi	r2,r2,65535
 32419a4:	1004d23a 	srli	r2,r2,8
 32419a8:	10803fcc 	andi	r2,r2,255
 32419ac:	1009883a 	mov	r4,r2
 32419b0:	e0bff517 	ldw	r2,-44(fp)
 32419b4:	1080008b 	ldhu	r2,2(r2)
 32419b8:	10bfffcc 	andi	r2,r2,65535
 32419bc:	1004923a 	slli	r2,r2,8
 32419c0:	1007883a 	mov	r3,r2
 32419c4:	00bfc004 	movi	r2,-256
 32419c8:	1884703a 	and	r2,r3,r2
 32419cc:	2084b03a 	or	r2,r4,r2
 32419d0:	1007883a 	mov	r3,r2
 32419d4:	e0bff517 	ldw	r2,-44(fp)
 32419d8:	10800003 	ldbu	r2,0(r2)
 32419dc:	10803fcc 	andi	r2,r2,255
 32419e0:	108003cc 	andi	r2,r2,15
 32419e4:	1085883a 	add	r2,r2,r2
 32419e8:	1085883a 	add	r2,r2,r2
 32419ec:	1885c83a 	sub	r2,r3,r2
 32419f0:	2885883a 	add	r2,r5,r2
 32419f4:	1007883a 	mov	r3,r2
 32419f8:	e0bffb17 	ldw	r2,-20(fp)
 32419fc:	10c0040d 	sth	r3,16(r2)
 3241a00:	00000a06 	br	3241a2c <ip_reasm_process_subsequent_fragments+0x188>
      }
   else if (ftype == IP_FF)
 3241a04:	e0bff217 	ldw	r2,-56(fp)
 3241a08:	10800058 	cmpnei	r2,r2,1
 3241a0c:	1000071e 	bne	r2,zero,3241a2c <ip_reasm_process_subsequent_fragments+0x188>
      {
      irep->l2_hdr = p->nb_buff;
 3241a10:	e0bffa17 	ldw	r2,-24(fp)
 3241a14:	10c00117 	ldw	r3,4(r2)
 3241a18:	e0bffb17 	ldw	r2,-20(fp)
 3241a1c:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 3241a20:	e0fff517 	ldw	r3,-44(fp)
 3241a24:	e0bffb17 	ldw	r2,-20(fp)
 3241a28:	10c02015 	stw	r3,128(r2)
      }

   /* Check for overlap, and determine the increase in memory resource 
    * requirements from the newly arrived fragment */
   if ((rc2 = ip_reasm_compute_overlap (p, irep, &index, &rfqp, &frag_offset, &hole_created)) != IPREASM_ACCEPT_FRAG)
 3241a2c:	e1bff704 	addi	r6,fp,-36
 3241a30:	e1fff804 	addi	r7,fp,-32
 3241a34:	e0bff904 	addi	r2,fp,-28
 3241a38:	d8800015 	stw	r2,0(sp)
 3241a3c:	e0bff984 	addi	r2,fp,-26
 3241a40:	d8800115 	stw	r2,4(sp)
 3241a44:	e13ffa17 	ldw	r4,-24(fp)
 3241a48:	e17ffb17 	ldw	r5,-20(fp)
 3241a4c:	32413140 	call	3241314 <ip_reasm_compute_overlap>
 3241a50:	e0bff115 	stw	r2,-60(fp)
 3241a54:	e0bff117 	ldw	r2,-60(fp)
 3241a58:	108000a0 	cmpeqi	r2,r2,2
 3241a5c:	10000e1e 	bne	r2,zero,3241a98 <ip_reasm_process_subsequent_fragments+0x1f4>
      {
      switch (rc2)
 3241a60:	e0fff117 	ldw	r3,-60(fp)
 3241a64:	e0ffff15 	stw	r3,-4(fp)
 3241a68:	e13fff17 	ldw	r4,-4(fp)
 3241a6c:	2005003a 	cmpeq	r2,r4,zero
 3241a70:	1000041e 	bne	r2,zero,3241a84 <ip_reasm_process_subsequent_fragments+0x1e0>
 3241a74:	e0ffff17 	ldw	r3,-4(fp)
 3241a78:	18800060 	cmpeqi	r2,r3,1
 3241a7c:	1000031e 	bne	r2,zero,3241a8c <ip_reasm_process_subsequent_fragments+0x1e8>
 3241a80:	00000506 	br	3241a98 <ip_reasm_process_subsequent_fragments+0x1f4>
         {
         case IPREASM_DROP_FRAG_DUPLICATE:
            /* this isn't really an error, since it indicates that the received 
             * fragment's information is a duplicate of what is present in the 
             * already queued fragments */
            return IPREASM_OK;
 3241a84:	e03ffe15 	stw	zero,-8(fp)
 3241a88:	0000e506 	br	3241e20 <ip_reasm_process_subsequent_fragments+0x57c>
         case IPREASM_DROP_FRAG_BAD_PARAM:
            /* this is a real error */
            return ENP_PARAM;
 3241a8c:	013ffd84 	movi	r4,-10
 3241a90:	e13ffe15 	stw	r4,-8(fp)
 3241a94:	0000e206 	br	3241e20 <ip_reasm_process_subsequent_fragments+0x57c>
      }

   /* this is a fragment from an existing fragment stream; 
    * check for resource limits before accepting it.  For now
    * assume that an extra RFQ is not required. */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen)) != IPREASM_OK)
 3241a98:	e0bffa17 	ldw	r2,-24(fp)
 3241a9c:	10800217 	ldw	r2,8(r2)
 3241aa0:	113fffcc 	andi	r4,r2,65535
 3241aa4:	3240db40 	call	3240db4 <ip_reasm_check_mem_useage>
 3241aa8:	e0bff315 	stw	r2,-52(fp)
 3241aac:	e0bff317 	ldw	r2,-52(fp)
 3241ab0:	1005003a 	cmpeq	r2,r2,zero
 3241ab4:	1000121e 	bne	r2,zero,3241b00 <ip_reasm_process_subsequent_fragments+0x25c>
      {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 3241ab8:	01000084 	movi	r4,2
 3241abc:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free (p);
 3241ac0:	e13ffa17 	ldw	r4,-24(fp)
 3241ac4:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241ac8:	01000084 	movi	r4,2
 3241acc:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      ip_reasm_delete_ire (irep);
 3241ad0:	e13ffb17 	ldw	r4,-20(fp)
 3241ad4:	32422dc0 	call	32422dc <ip_reasm_delete_ire>
      ++ip_mib.ipReasmFails;
 3241ad8:	0080c9b4 	movhi	r2,806
 3241adc:	10b54b04 	addi	r2,r2,-10964
 3241ae0:	10800f17 	ldw	r2,60(r2)
 3241ae4:	10c00044 	addi	r3,r2,1
 3241ae8:	0080c9b4 	movhi	r2,806
 3241aec:	10b54b04 	addi	r2,r2,-10964
 3241af0:	10c00f15 	stw	r3,60(r2)
      return rc;
 3241af4:	e0bff317 	ldw	r2,-52(fp)
 3241af8:	e0bffe15 	stw	r2,-8(fp)
 3241afc:	0000c806 	br	3241e20 <ip_reasm_process_subsequent_fragments+0x57c>

   /* the two combinations of index and rfqp are as follows:
    * (1) index = INVALID_FRAG_INDEX, rfqp = non-zero: no empty slot found in RFQ(s),
    *     and rfqp points to the last RFQ that was processed
    * (2) index != INVALID_FRAG_INDEX, rfqp = non-zero: empty slot found in RFQ(s) */
   if (index != INVALID_FRAG_INDEX)
 3241b00:	e0bff70b 	ldhu	r2,-36(fp)
 3241b04:	10bfffcc 	andi	r2,r2,65535
 3241b08:	10800420 	cmpeqi	r2,r2,16
 3241b0c:	1000121e 	bne	r2,zero,3241b58 <ip_reasm_process_subsequent_fragments+0x2b4>
      {
      /* we have an empty slot in the PACKET array into which we can place 
       * the just received fragment */
      rfqp->bufp[index] = p;
 3241b10:	e0fff817 	ldw	r3,-32(fp)
 3241b14:	e0bff70b 	ldhu	r2,-36(fp)
 3241b18:	10bfffcc 	andi	r2,r2,65535
 3241b1c:	1085883a 	add	r2,r2,r2
 3241b20:	1085883a 	add	r2,r2,r2
 3241b24:	10c5883a 	add	r2,r2,r3
 3241b28:	10c00104 	addi	r3,r2,4
 3241b2c:	e0bffa17 	ldw	r2,-24(fp)
 3241b30:	18800015 	stw	r2,0(r3)
      rfqp->frag_offset[index] = frag_offset;
 3241b34:	e0fff817 	ldw	r3,-32(fp)
 3241b38:	e0bff70b 	ldhu	r2,-36(fp)
 3241b3c:	10bfffcc 	andi	r2,r2,65535
 3241b40:	e13ff90b 	ldhu	r4,-28(fp)
 3241b44:	1085883a 	add	r2,r2,r2
 3241b48:	10c5883a 	add	r2,r2,r3
 3241b4c:	10801104 	addi	r2,r2,68
 3241b50:	1100000d 	sth	r4,0(r2)
 3241b54:	00003c06 	br	3241c48 <ip_reasm_process_subsequent_fragments+0x3a4>
      }
   else
      {
      /* since we need to allocate an extra RFQ, check for memory useage again... */
      if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (RFQ)))) != IPREASM_OK)
 3241b58:	e0bffa17 	ldw	r2,-24(fp)
 3241b5c:	10800217 	ldw	r2,8(r2)
 3241b60:	10801904 	addi	r2,r2,100
 3241b64:	113fffcc 	andi	r4,r2,65535
 3241b68:	3240db40 	call	3240db4 <ip_reasm_check_mem_useage>
 3241b6c:	e0bff315 	stw	r2,-52(fp)
 3241b70:	e0bff317 	ldw	r2,-52(fp)
 3241b74:	1005003a 	cmpeq	r2,r2,zero
 3241b78:	1000121e 	bne	r2,zero,3241bc4 <ip_reasm_process_subsequent_fragments+0x320>
         {
         LOCK_NET_RESOURCE (FREEQ_RESID);
 3241b7c:	01000084 	movi	r4,2
 3241b80:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pk_free (p);
 3241b84:	e13ffa17 	ldw	r4,-24(fp)
 3241b88:	322a6400 	call	322a640 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241b8c:	01000084 	movi	r4,2
 3241b90:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 3241b94:	e13ffb17 	ldw	r4,-20(fp)
 3241b98:	32422dc0 	call	32422dc <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 3241b9c:	0080c9b4 	movhi	r2,806
 3241ba0:	10b54b04 	addi	r2,r2,-10964
 3241ba4:	10800f17 	ldw	r2,60(r2)
 3241ba8:	10c00044 	addi	r3,r2,1
 3241bac:	0080c9b4 	movhi	r2,806
 3241bb0:	10b54b04 	addi	r2,r2,-10964
 3241bb4:	10c00f15 	stw	r3,60(r2)
         return rc;
 3241bb8:	e0fff317 	ldw	r3,-52(fp)
 3241bbc:	e0fffe15 	stw	r3,-8(fp)
 3241bc0:	00009706 	br	3241e20 <ip_reasm_process_subsequent_fragments+0x57c>
         }

      /* no slots are available in the one (or more) existing RFQs; we 
       * need to create a new RFQ to store the just received fragment */
      new_rfqp = (RFQP) IPR_ALLOC (sizeof(RFQ));
 3241bc4:	01001904 	movi	r4,100
 3241bc8:	322b9340 	call	322b934 <npalloc>
 3241bcc:	e0bff415 	stw	r2,-48(fp)
      if (new_rfqp == 0)
 3241bd0:	e0bff417 	ldw	r2,-48(fp)
 3241bd4:	1004c03a 	cmpne	r2,r2,zero
 3241bd8:	1000121e 	bne	r2,zero,3241c24 <ip_reasm_process_subsequent_fragments+0x380>
         {
         /* can't store the existing fragment, so we'll drop it */
         LOCK_NET_RESOURCE (FREEQ_RESID);
 3241bdc:	01000084 	movi	r4,2
 3241be0:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pk_free (p);
 3241be4:	e13ffa17 	ldw	r4,-24(fp)
 3241be8:	322a6400 	call	322a640 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241bec:	01000084 	movi	r4,2
 3241bf0:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 3241bf4:	e13ffb17 	ldw	r4,-20(fp)
 3241bf8:	32422dc0 	call	32422dc <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 3241bfc:	0080c9b4 	movhi	r2,806
 3241c00:	10b54b04 	addi	r2,r2,-10964
 3241c04:	10800f17 	ldw	r2,60(r2)
 3241c08:	10c00044 	addi	r3,r2,1
 3241c0c:	0080c9b4 	movhi	r2,806
 3241c10:	10b54b04 	addi	r2,r2,-10964
 3241c14:	10c00f15 	stw	r3,60(r2)
         return ENP_RESOURCE;
 3241c18:	013ffa84 	movi	r4,-22
 3241c1c:	e13ffe15 	stw	r4,-8(fp)
 3241c20:	00007f06 	br	3241e20 <ip_reasm_process_subsequent_fragments+0x57c>
         }
      else
         {
         new_rfqp->bufp[0] = p;
 3241c24:	e0fff417 	ldw	r3,-48(fp)
 3241c28:	e0bffa17 	ldw	r2,-24(fp)
 3241c2c:	18800115 	stw	r2,4(r3)
         new_rfqp->frag_offset[0] = frag_offset;
 3241c30:	e0fff90b 	ldhu	r3,-28(fp)
 3241c34:	e0bff417 	ldw	r2,-48(fp)
 3241c38:	10c0110d 	sth	r3,68(r2)
         rfqp->next = new_rfqp;
 3241c3c:	e0fff817 	ldw	r3,-32(fp)
 3241c40:	e0bff417 	ldw	r2,-48(fp)
 3241c44:	18800015 	stw	r2,0(r3)
         }
      }
      
      /* check to see if the RFQ is still compact, but only if hole(s) were created 
       * in ip_reasm_compute_overlap () */
      if (hole_created)
 3241c48:	e0bff983 	ldbu	r2,-26(fp)
 3241c4c:	10803fcc 	andi	r2,r2,255
 3241c50:	1005003a 	cmpeq	r2,r2,zero
 3241c54:	1000161e 	bne	r2,zero,3241cb0 <ip_reasm_process_subsequent_fragments+0x40c>
         {
         if ((rc = ip_reasm_mark_compact_rfq (irep)) != IPREASM_OK)
 3241c58:	e13ffb17 	ldw	r4,-20(fp)
 3241c5c:	32424a40 	call	32424a4 <ip_reasm_mark_compact_rfq>
 3241c60:	e0bff315 	stw	r2,-52(fp)
 3241c64:	e0bff317 	ldw	r2,-52(fp)
 3241c68:	1005003a 	cmpeq	r2,r2,zero
 3241c6c:	1000101e 	bne	r2,zero,3241cb0 <ip_reasm_process_subsequent_fragments+0x40c>
            {
            /* an error return is due to a bad IRE pointer, which ip_reasm_mark_compact_rfq () logs */
            LOCK_NET_RESOURCE (FREEQ_RESID);
 3241c70:	01000084 	movi	r4,2
 3241c74:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
            pk_free (p);
 3241c78:	e13ffa17 	ldw	r4,-24(fp)
 3241c7c:	322a6400 	call	322a640 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241c80:	01000084 	movi	r4,2
 3241c84:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
            ++ip_mib.ipReasmFails;
 3241c88:	0080c9b4 	movhi	r2,806
 3241c8c:	10b54b04 	addi	r2,r2,-10964
 3241c90:	10800f17 	ldw	r2,60(r2)
 3241c94:	10c00044 	addi	r3,r2,1
 3241c98:	0080c9b4 	movhi	r2,806
 3241c9c:	10b54b04 	addi	r2,r2,-10964
 3241ca0:	10c00f15 	stw	r3,60(r2)
            return rc;
 3241ca4:	e0bff317 	ldw	r2,-52(fp)
 3241ca8:	e0bffe15 	stw	r2,-8(fp)
 3241cac:	00005c06 	br	3241e20 <ip_reasm_process_subsequent_fragments+0x57c>

   /* compute the total number of bytes queued in this IRE.  Note 
    * that the RHS has been updated to reflect the amount of "unique"
    * data in the just received fragment (the IP header has been dropped,
    * and perhaps additional duplicate data too (if present)) */
   irep->rcvd += (u_short) (p->nb_plen);
 3241cb0:	e0bffb17 	ldw	r2,-20(fp)
 3241cb4:	10c0048b 	ldhu	r3,18(r2)
 3241cb8:	e0bffa17 	ldw	r2,-24(fp)
 3241cbc:	10800417 	ldw	r2,16(r2)
 3241cc0:	1885883a 	add	r2,r3,r2
 3241cc4:	1007883a 	mov	r3,r2
 3241cc8:	e0bffb17 	ldw	r2,-20(fp)
 3241ccc:	10c0048d 	sth	r3,18(r2)
   ip_reasm_incr_mem_useage (p->nb_blen + ((new_rfqp == 0) ? 0 : (sizeof(RFQ))));
 3241cd0:	e0bffa17 	ldw	r2,-24(fp)
 3241cd4:	10800217 	ldw	r2,8(r2)
 3241cd8:	e0bffd0d 	sth	r2,-12(fp)
 3241cdc:	e0bff417 	ldw	r2,-48(fp)
 3241ce0:	1004c03a 	cmpne	r2,r2,zero
 3241ce4:	1000021e 	bne	r2,zero,3241cf0 <ip_reasm_process_subsequent_fragments+0x44c>
 3241ce8:	e03ffc0d 	sth	zero,-16(fp)
 3241cec:	00000206 	br	3241cf8 <ip_reasm_process_subsequent_fragments+0x454>
 3241cf0:	00c01904 	movi	r3,100
 3241cf4:	e0fffc0d 	sth	r3,-16(fp)
 3241cf8:	e13ffd0b 	ldhu	r4,-12(fp)
 3241cfc:	e0fffc0b 	ldhu	r3,-16(fp)
 3241d00:	20c5883a 	add	r2,r4,r3
 3241d04:	113fffcc 	andi	r4,r2,65535
 3241d08:	3240e4c0 	call	3240e4c <ip_reasm_incr_mem_useage>

   if (irep->length != 0)
 3241d0c:	e0bffb17 	ldw	r2,-20(fp)
 3241d10:	1080040b 	ldhu	r2,16(r2)
 3241d14:	10bfffcc 	andi	r2,r2,65535
 3241d18:	1005003a 	cmpeq	r2,r2,zero
 3241d1c:	10003f1e 	bne	r2,zero,3241e1c <ip_reasm_process_subsequent_fragments+0x578>
      {
      /* we know the total length of the original unfragmented datagram; 
       * let's check to see if we have all of the bytes... */
      if (irep->rcvd == irep->length)
 3241d20:	e0bffb17 	ldw	r2,-20(fp)
 3241d24:	10c0048b 	ldhu	r3,18(r2)
 3241d28:	e0bffb17 	ldw	r2,-20(fp)
 3241d2c:	1080040b 	ldhu	r2,16(r2)
 3241d30:	18ffffcc 	andi	r3,r3,65535
 3241d34:	10bfffcc 	andi	r2,r2,65535
 3241d38:	1880381e 	bne	r3,r2,3241e1c <ip_reasm_process_subsequent_fragments+0x578>
          * Ensure that we allocate space for the data link header, IP header, 
          * and the payload of the original, unfragmented datagram.  We pick 
          * the data link layer and IP headers from the First Fragment (FF), 
          * but we need to adjust some of the fields in the IP header after 
          * reassembly is complete. */
         pip = (struct ip *) irep->l3_hdr;
 3241d3c:	e0bffb17 	ldw	r2,-20(fp)
 3241d40:	10802017 	ldw	r2,128(r2)
 3241d44:	e0bff515 	stw	r2,-44(fp)
         LOCK_NET_RESOURCE (FREEQ_RESID);
 3241d48:	01000084 	movi	r4,2
 3241d4c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         reassy_pkt = pk_alloc (irep->length + (irep->l3_hdr - irep->l2_hdr) + ip_hlen (pip));
 3241d50:	e0bffb17 	ldw	r2,-20(fp)
 3241d54:	1080040b 	ldhu	r2,16(r2)
 3241d58:	113fffcc 	andi	r4,r2,65535
 3241d5c:	e0bffb17 	ldw	r2,-20(fp)
 3241d60:	10802017 	ldw	r2,128(r2)
 3241d64:	1007883a 	mov	r3,r2
 3241d68:	e0bffb17 	ldw	r2,-20(fp)
 3241d6c:	10801f17 	ldw	r2,124(r2)
 3241d70:	1885c83a 	sub	r2,r3,r2
 3241d74:	2087883a 	add	r3,r4,r2
 3241d78:	e0bff517 	ldw	r2,-44(fp)
 3241d7c:	10800003 	ldbu	r2,0(r2)
 3241d80:	10803fcc 	andi	r2,r2,255
 3241d84:	108003cc 	andi	r2,r2,15
 3241d88:	1085883a 	add	r2,r2,r2
 3241d8c:	1085883a 	add	r2,r2,r2
 3241d90:	1885883a 	add	r2,r3,r2
 3241d94:	1009883a 	mov	r4,r2
 3241d98:	322a2ac0 	call	322a2ac <pk_alloc>
 3241d9c:	e0bff615 	stw	r2,-40(fp)
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241da0:	01000084 	movi	r4,2
 3241da4:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         if (reassy_pkt == 0)
 3241da8:	e0bff617 	ldw	r2,-40(fp)
 3241dac:	1004c03a 	cmpne	r2,r2,zero
 3241db0:	10000c1e 	bne	r2,zero,3241de4 <ip_reasm_process_subsequent_fragments+0x540>
            {
            /* the following call will delete all queued fragments, including
             * the currently received one */
            ip_reasm_delete_ire (irep);
 3241db4:	e13ffb17 	ldw	r4,-20(fp)
 3241db8:	32422dc0 	call	32422dc <ip_reasm_delete_ire>
            ++ip_mib.ipReasmFails;
 3241dbc:	0080c9b4 	movhi	r2,806
 3241dc0:	10b54b04 	addi	r2,r2,-10964
 3241dc4:	10800f17 	ldw	r2,60(r2)
 3241dc8:	10c00044 	addi	r3,r2,1
 3241dcc:	0080c9b4 	movhi	r2,806
 3241dd0:	10b54b04 	addi	r2,r2,-10964
 3241dd4:	10c00f15 	stw	r3,60(r2)
            return ENP_NOBUFFER;
 3241dd8:	013ffac4 	movi	r4,-21
 3241ddc:	e13ffe15 	stw	r4,-8(fp)
 3241de0:	00000f06 	br	3241e20 <ip_reasm_process_subsequent_fragments+0x57c>
            }
         else
            {
            ip_reasm_copy_queued_fragments_into_reassy_buffer (reassy_pkt, irep);
 3241de4:	e13ff617 	ldw	r4,-40(fp)
 3241de8:	e17ffb17 	ldw	r5,-20(fp)
 3241dec:	3241e9c0 	call	3241e9c <ip_reasm_copy_queued_fragments_into_reassy_buffer>
            /* free the IRE structure (and its constituent elements) */
            ip_reasm_delete_ire (irep);
 3241df0:	e13ffb17 	ldw	r4,-20(fp)
 3241df4:	32422dc0 	call	32422dc <ip_reasm_delete_ire>
            /* at this point, 'irep' is no longer a valid pointer, and so should 
             * not be referenced.  We're done, and we now pass the packet for 
             * demux'ing to the appropriate entity (e.g., UDP, TCP, etc.).  Note
             * that ip_demux () expects 'nb_prot' to point to the beginning of 
             * the IP header. */
            ++ip_mib.ipReasmOKs;
 3241df8:	0080c9b4 	movhi	r2,806
 3241dfc:	10b54b04 	addi	r2,r2,-10964
 3241e00:	10800e17 	ldw	r2,56(r2)
 3241e04:	10c00044 	addi	r3,r2,1
 3241e08:	0080c9b4 	movhi	r2,806
 3241e0c:	10b54b04 	addi	r2,r2,-10964
 3241e10:	10c00e15 	stw	r3,56(r2)
            ip_demux (reassy_pkt);
 3241e14:	e13ff617 	ldw	r4,-40(fp)
 3241e18:	32433a00 	call	32433a0 <ip_demux>
      {
      /* we haven't received the LF (so we don't know the total amount of data in 
       * the original, unfragmented datagram), and therefore reassembly can't complete yet */
      }

   return IPREASM_OK;
 3241e1c:	e03ffe15 	stw	zero,-8(fp)
 3241e20:	e0bffe17 	ldw	r2,-8(fp)
}
 3241e24:	e037883a 	mov	sp,fp
 3241e28:	dfc00117 	ldw	ra,4(sp)
 3241e2c:	df000017 	ldw	fp,0(sp)
 3241e30:	dec00204 	addi	sp,sp,8
 3241e34:	f800283a 	ret

03241e38 <ip_reasm_find_ire>:
OUTPUT: This function returns a IPREASM_TRUE if the IRE exists in the master 
IRE list; otherwise, it returns a IPREASM_FALSE.
*/

u_char ip_reasm_find_ire (IREP irep)
{
 3241e38:	defffc04 	addi	sp,sp,-16
 3241e3c:	df000315 	stw	fp,12(sp)
 3241e40:	df000304 	addi	fp,sp,12
 3241e44:	e13ffe15 	stw	r4,-8(fp)
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 3241e48:	d0a8ff17 	ldw	r2,-23556(gp)
 3241e4c:	e0bffd15 	stw	r2,-12(fp)
 3241e50:	00000906 	br	3241e78 <ip_reasm_find_ire+0x40>
      {
      if (tmpp == irep) 
 3241e54:	e0fffd17 	ldw	r3,-12(fp)
 3241e58:	e0bffe17 	ldw	r2,-8(fp)
 3241e5c:	1880031e 	bne	r3,r2,3241e6c <ip_reasm_find_ire+0x34>
         {
         return IPREASM_TRUE;
 3241e60:	00800044 	movi	r2,1
 3241e64:	e0bfff15 	stw	r2,-4(fp)
 3241e68:	00000706 	br	3241e88 <ip_reasm_find_ire+0x50>
u_char ip_reasm_find_ire (IREP irep)
{
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 3241e6c:	e0bffd17 	ldw	r2,-12(fp)
 3241e70:	10800017 	ldw	r2,0(r2)
 3241e74:	e0bffd15 	stw	r2,-12(fp)
 3241e78:	e0bffd17 	ldw	r2,-12(fp)
 3241e7c:	1004c03a 	cmpne	r2,r2,zero
 3241e80:	103ff41e 	bne	r2,zero,3241e54 <ip_reasm_find_ire+0x1c>
         {
         return IPREASM_TRUE;
         }
      }

   return IPREASM_FALSE;
 3241e84:	e03fff15 	stw	zero,-4(fp)
 3241e88:	e0bfff17 	ldw	r2,-4(fp)
}
 3241e8c:	e037883a 	mov	sp,fp
 3241e90:	df000017 	ldw	fp,0(sp)
 3241e94:	dec00104 	addi	sp,sp,4
 3241e98:	f800283a 	ret

03241e9c <ip_reasm_copy_queued_fragments_into_reassy_buffer>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_copy_queued_fragments_into_reassy_buffer (PACKET reassy_pkt, IREP irep)
{
 3241e9c:	defff404 	addi	sp,sp,-48
 3241ea0:	dfc00b15 	stw	ra,44(sp)
 3241ea4:	df000a15 	stw	fp,40(sp)
 3241ea8:	df000a04 	addi	fp,sp,40
 3241eac:	e13ffe15 	stw	r4,-8(fp)
 3241eb0:	e17fff15 	stw	r5,-4(fp)
   RFQP rfqp;
   u_short i;
   PACKET p;
   u_char iphlen;
   char * writep;
   PACKET sav_pkt = 0;
 3241eb4:	e03ff615 	stw	zero,-40(fp)

   pip = (struct ip *) irep->l3_hdr;
 3241eb8:	e0bfff17 	ldw	r2,-4(fp)
 3241ebc:	10802017 	ldw	r2,128(r2)
 3241ec0:	e0bffd15 	stw	r2,-12(fp)
   iphlen = ip_hlen (pip);
 3241ec4:	e0bffd17 	ldw	r2,-12(fp)
 3241ec8:	10800003 	ldbu	r2,0(r2)
 3241ecc:	108003cc 	andi	r2,r2,15
 3241ed0:	1085883a 	add	r2,r2,r2
 3241ed4:	1085883a 	add	r2,r2,r2
 3241ed8:	e0bff805 	stb	r2,-32(fp)

   /* copy the data link and IP layer headers into place.  These headers are 
    * from the First Fragment (FF). */
   offset = (u_char) ((irep->l3_hdr - irep->l2_hdr) + iphlen);
 3241edc:	e0bfff17 	ldw	r2,-4(fp)
 3241ee0:	10802017 	ldw	r2,128(r2)
 3241ee4:	1007883a 	mov	r3,r2
 3241ee8:	e0bfff17 	ldw	r2,-4(fp)
 3241eec:	10801f17 	ldw	r2,124(r2)
 3241ef0:	1885c83a 	sub	r2,r3,r2
 3241ef4:	1007883a 	mov	r3,r2
 3241ef8:	e0bff803 	ldbu	r2,-32(fp)
 3241efc:	1885883a 	add	r2,r3,r2
 3241f00:	e0bffc05 	stb	r2,-16(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);
 3241f04:	e0bffe17 	ldw	r2,-8(fp)
 3241f08:	11000117 	ldw	r4,4(r2)
 3241f0c:	e0bfff17 	ldw	r2,-4(fp)
 3241f10:	10801f17 	ldw	r2,124(r2)
 3241f14:	e0fffc03 	ldbu	r3,-16(fp)
 3241f18:	100b883a 	mov	r5,r2
 3241f1c:	180d883a 	mov	r6,r3
 3241f20:	3206ad00 	call	3206ad0 <memcpy>

   rfqp = &(irep->rfq);
 3241f24:	e0bfff17 	ldw	r2,-4(fp)
 3241f28:	10800604 	addi	r2,r2,24
 3241f2c:	e0bffb15 	stw	r2,-20(fp)
   writep = reassy_pkt->nb_buff + offset;
 3241f30:	e0bffe17 	ldw	r2,-8(fp)
 3241f34:	10c00117 	ldw	r3,4(r2)
 3241f38:	e0bffc03 	ldbu	r2,-16(fp)
 3241f3c:	1885883a 	add	r2,r3,r2
 3241f40:	e0bff715 	stw	r2,-36(fp)

   while (rfqp)
 3241f44:	00004606 	br	3242060 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1c4>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 3241f48:	e03ffa0d 	sth	zero,-24(fp)
 3241f4c:	00003e06 	br	3242048 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1ac>
         {
         if ((p = rfqp->bufp [i]) != 0)
 3241f50:	e0bffa0b 	ldhu	r2,-24(fp)
 3241f54:	e0fffb17 	ldw	r3,-20(fp)
 3241f58:	1085883a 	add	r2,r2,r2
 3241f5c:	1085883a 	add	r2,r2,r2
 3241f60:	10c5883a 	add	r2,r2,r3
 3241f64:	10800104 	addi	r2,r2,4
 3241f68:	10800017 	ldw	r2,0(r2)
 3241f6c:	e0bff915 	stw	r2,-28(fp)
 3241f70:	e0bff917 	ldw	r2,-28(fp)
 3241f74:	1005003a 	cmpeq	r2,r2,zero
 3241f78:	1000291e 	bne	r2,zero,3242020 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x184>
            {
            /* note that rfqp->frag_offset[i] is the true value of the offset field, 
             * and does not require any scaling (like the Fragment Offset field in 
             * the IP header) */
            MEMCPY((writep + rfqp->frag_offset[i]), p->nb_prot, p->nb_plen);
 3241f7c:	e0bffa0b 	ldhu	r2,-24(fp)
 3241f80:	e0fffb17 	ldw	r3,-20(fp)
 3241f84:	1085883a 	add	r2,r2,r2
 3241f88:	10c5883a 	add	r2,r2,r3
 3241f8c:	10801104 	addi	r2,r2,68
 3241f90:	1080000b 	ldhu	r2,0(r2)
 3241f94:	10bfffcc 	andi	r2,r2,65535
 3241f98:	1007883a 	mov	r3,r2
 3241f9c:	e0bff717 	ldw	r2,-36(fp)
 3241fa0:	1887883a 	add	r3,r3,r2
 3241fa4:	e0bff917 	ldw	r2,-28(fp)
 3241fa8:	11400317 	ldw	r5,12(r2)
 3241fac:	e0bff917 	ldw	r2,-28(fp)
 3241fb0:	10800417 	ldw	r2,16(r2)
 3241fb4:	1809883a 	mov	r4,r3
 3241fb8:	100d883a 	mov	r6,r2
 3241fbc:	3206ad00 	call	3206ad0 <memcpy>
            /* free fragment after we've copied data out from it (unless we need to
             * save it so that we can copy some fields from it later (after exiting 
             * from the loop)) */
            if (!sav_pkt) sav_pkt = p;
 3241fc0:	e0bff617 	ldw	r2,-40(fp)
 3241fc4:	1004c03a 	cmpne	r2,r2,zero
 3241fc8:	1000031e 	bne	r2,zero,3241fd8 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x13c>
 3241fcc:	e0bff917 	ldw	r2,-28(fp)
 3241fd0:	e0bff615 	stw	r2,-40(fp)
 3241fd4:	00000a06 	br	3242000 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x164>
            else
               {
               ip_reasm_decr_mem_useage (p->nb_blen);
 3241fd8:	e0bff917 	ldw	r2,-28(fp)
 3241fdc:	10800217 	ldw	r2,8(r2)
 3241fe0:	113fffcc 	andi	r4,r2,65535
 3241fe4:	3240ef40 	call	3240ef4 <ip_reasm_decr_mem_useage>
               LOCK_NET_RESOURCE (FREEQ_RESID);
 3241fe8:	01000084 	movi	r4,2
 3241fec:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
               pk_free (p);
 3241ff0:	e13ff917 	ldw	r4,-28(fp)
 3241ff4:	322a6400 	call	322a640 <pk_free>
               UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3241ff8:	01000084 	movi	r4,2
 3241ffc:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
               }
            /* since we're done with the packet, mark slot as unused */
            rfqp->bufp [i] = 0;
 3242000:	e0bffa0b 	ldhu	r2,-24(fp)
 3242004:	e0fffb17 	ldw	r3,-20(fp)
 3242008:	1085883a 	add	r2,r2,r2
 324200c:	1085883a 	add	r2,r2,r2
 3242010:	10c5883a 	add	r2,r2,r3
 3242014:	10800104 	addi	r2,r2,4
 3242018:	10000015 	stw	zero,0(r2)
 324201c:	00000706 	br	324203c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1a0>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 3242020:	e0bfff17 	ldw	r2,-4(fp)
 3242024:	10802103 	ldbu	r2,132(r2)
 3242028:	10803fcc 	andi	r2,r2,255
 324202c:	1080004c 	andi	r2,r2,1
 3242030:	10803fcc 	andi	r2,r2,255
 3242034:	1004c03a 	cmpne	r2,r2,zero
 3242038:	1000061e 	bne	r2,zero,3242054 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1b8>
   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 324203c:	e0bffa0b 	ldhu	r2,-24(fp)
 3242040:	10800044 	addi	r2,r2,1
 3242044:	e0bffa0d 	sth	r2,-24(fp)
 3242048:	e0bffa0b 	ldhu	r2,-24(fp)
 324204c:	10800430 	cmpltui	r2,r2,16
 3242050:	103fbf1e 	bne	r2,zero,3241f50 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xb4>
               break;
               }
            }
          }

      rfqp = rfqp->next;
 3242054:	e0bffb17 	ldw	r2,-20(fp)
 3242058:	10800017 	ldw	r2,0(r2)
 324205c:	e0bffb15 	stw	r2,-20(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);

   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
 3242060:	e0bffb17 	ldw	r2,-20(fp)
 3242064:	1004c03a 	cmpne	r2,r2,zero
 3242068:	103fb71e 	bne	r2,zero,3241f48 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xac>
      }

   /* update various fields in the reassembled packet.  Some fields will be 
    * picked from one of the constituent fragments (sav_pkt) which hasn't
    * been deleted yet. */
   reassy_pkt->nb_prot = reassy_pkt->nb_buff + (irep->l3_hdr - irep->l2_hdr);
 324206c:	e0bffe17 	ldw	r2,-8(fp)
 3242070:	11000117 	ldw	r4,4(r2)
 3242074:	e0bfff17 	ldw	r2,-4(fp)
 3242078:	10802017 	ldw	r2,128(r2)
 324207c:	1007883a 	mov	r3,r2
 3242080:	e0bfff17 	ldw	r2,-4(fp)
 3242084:	10801f17 	ldw	r2,124(r2)
 3242088:	1885c83a 	sub	r2,r3,r2
 324208c:	2087883a 	add	r3,r4,r2
 3242090:	e0bffe17 	ldw	r2,-8(fp)
 3242094:	10c00315 	stw	r3,12(r2)
   reassy_pkt->nb_plen = irep->length + iphlen;
 3242098:	e0bfff17 	ldw	r2,-4(fp)
 324209c:	1080040b 	ldhu	r2,16(r2)
 32420a0:	10ffffcc 	andi	r3,r2,65535
 32420a4:	e0bff803 	ldbu	r2,-32(fp)
 32420a8:	1885883a 	add	r2,r3,r2
 32420ac:	1007883a 	mov	r3,r2
 32420b0:	e0bffe17 	ldw	r2,-8(fp)
 32420b4:	10c00415 	stw	r3,16(r2)
   reassy_pkt->nb_tstamp = cticks;
 32420b8:	0080c974 	movhi	r2,805
 32420bc:	10934104 	addi	r2,r2,19716
 32420c0:	10800017 	ldw	r2,0(r2)
 32420c4:	1007883a 	mov	r3,r2
 32420c8:	e0bffe17 	ldw	r2,-8(fp)
 32420cc:	10c00515 	stw	r3,20(r2)
   reassy_pkt->flags |= ((sav_pkt->flags) & (PKF_BCAST | PKF_MCAST));
 32420d0:	e0bffe17 	ldw	r2,-8(fp)
 32420d4:	10c00a17 	ldw	r3,40(r2)
 32420d8:	e0bff617 	ldw	r2,-40(fp)
 32420dc:	10800a17 	ldw	r2,40(r2)
 32420e0:	108000cc 	andi	r2,r2,3
 32420e4:	1886b03a 	or	r3,r3,r2
 32420e8:	e0bffe17 	ldw	r2,-8(fp)
 32420ec:	10c00a15 	stw	r3,40(r2)
   reassy_pkt->net = sav_pkt->net;
 32420f0:	e0bff617 	ldw	r2,-40(fp)
 32420f4:	10c00617 	ldw	r3,24(r2)
 32420f8:	e0bffe17 	ldw	r2,-8(fp)
 32420fc:	10c00615 	stw	r3,24(r2)
   reassy_pkt->type = sav_pkt->type;
 3242100:	e0bff617 	ldw	r2,-40(fp)
 3242104:	10c0080b 	ldhu	r3,32(r2)
 3242108:	e0bffe17 	ldw	r2,-8(fp)
 324210c:	10c0080d 	sth	r3,32(r2)
   /* fhost is set by ip_demux () before handing off to the packet to its 
    * intended destination (protocol) */

   /* free the saved packet too, since we don't need it anymore */
   ip_reasm_decr_mem_useage (sav_pkt->nb_blen);
 3242110:	e0bff617 	ldw	r2,-40(fp)
 3242114:	10800217 	ldw	r2,8(r2)
 3242118:	113fffcc 	andi	r4,r2,65535
 324211c:	3240ef40 	call	3240ef4 <ip_reasm_decr_mem_useage>
   LOCK_NET_RESOURCE (FREEQ_RESID);
 3242120:	01000084 	movi	r4,2
 3242124:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   pk_free (sav_pkt);
 3242128:	e13ff617 	ldw	r4,-40(fp)
 324212c:	322a6400 	call	322a640 <pk_free>
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 3242130:	01000084 	movi	r4,2
 3242134:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   /* after the reassembly is complete, we update the following fields in
    * the IP header: Total Length, Flags/Fragment Offset, header checksum */
   pip = ip_head(reassy_pkt);
 3242138:	e0bffe17 	ldw	r2,-8(fp)
 324213c:	10800317 	ldw	r2,12(r2)
 3242140:	e0bffd15 	stw	r2,-12(fp)
   pip->ip_len = htons(reassy_pkt->nb_plen);
 3242144:	e0bffe17 	ldw	r2,-8(fp)
 3242148:	10800417 	ldw	r2,16(r2)
 324214c:	1004d23a 	srli	r2,r2,8
 3242150:	10803fcc 	andi	r2,r2,255
 3242154:	1009883a 	mov	r4,r2
 3242158:	e0bffe17 	ldw	r2,-8(fp)
 324215c:	10800417 	ldw	r2,16(r2)
 3242160:	1004923a 	slli	r2,r2,8
 3242164:	1007883a 	mov	r3,r2
 3242168:	00bfc004 	movi	r2,-256
 324216c:	1884703a 	and	r2,r3,r2
 3242170:	2084b03a 	or	r2,r4,r2
 3242174:	1007883a 	mov	r3,r2
 3242178:	e0bffd17 	ldw	r2,-12(fp)
 324217c:	10c0008d 	sth	r3,2(r2)
   /* turn off More Fragments (MF) bit; the DF bit stays unchanged */
   pip->ip_flgs_foff &= htons(~((u_short) IP_FLG_MF));
 3242180:	e0bffd17 	ldw	r2,-12(fp)
 3242184:	10c0018b 	ldhu	r3,6(r2)
 3242188:	00bff7c4 	movi	r2,-33
 324218c:	1884703a 	and	r2,r3,r2
 3242190:	1007883a 	mov	r3,r2
 3242194:	e0bffd17 	ldw	r2,-12(fp)
 3242198:	10c0018d 	sth	r3,6(r2)
   /* clear the Fragment Offset bits */
   pip->ip_flgs_foff &= htons(~((u_short) IP_EXTRACT_FOFF)); 
 324219c:	e0bffd17 	ldw	r2,-12(fp)
 32421a0:	1080018b 	ldhu	r2,6(r2)
 32421a4:	1080380c 	andi	r2,r2,224
 32421a8:	1007883a 	mov	r3,r2
 32421ac:	e0bffd17 	ldw	r2,-12(fp)
 32421b0:	10c0018d 	sth	r3,6(r2)
   /* the following isn't really required, and can be removed */
   pip->ip_chksum = IPXSUM;
 32421b4:	e0bffd17 	ldw	r2,-12(fp)
 32421b8:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum (pip, (iphlen/2));
 32421bc:	e0bff803 	ldbu	r2,-32(fp)
 32421c0:	1004d07a 	srli	r2,r2,1
 32421c4:	11403fcc 	andi	r5,r2,255
 32421c8:	e13ffd17 	ldw	r4,-12(fp)
 32421cc:	3225d5c0 	call	3225d5c <cksum>
 32421d0:	0084303a 	nor	r2,zero,r2
 32421d4:	1007883a 	mov	r3,r2
 32421d8:	e0bffd17 	ldw	r2,-12(fp)
 32421dc:	10c0028d 	sth	r3,10(r2)

   return IPREASM_OK;
 32421e0:	0005883a 	mov	r2,zero
}
 32421e4:	e037883a 	mov	sp,fp
 32421e8:	dfc00117 	ldw	ra,4(sp)
 32421ec:	df000017 	ldw	fp,0(sp)
 32421f0:	dec00204 	addi	sp,sp,8
 32421f4:	f800283a 	ret

032421f8 <ip_reasm_process_timer_tick>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_process_timer_tick (void)
{
 32421f8:	defffc04 	addi	sp,sp,-16
 32421fc:	dfc00315 	stw	ra,12(sp)
 3242200:	df000215 	stw	fp,8(sp)
 3242204:	df000204 	addi	fp,sp,8
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 3242208:	0009883a 	mov	r4,zero
 324220c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 3242210:	d0a8ff17 	ldw	r2,-23556(gp)
 3242214:	e0bfff15 	stw	r2,-4(fp)
 3242218:	00002006 	br	324229c <ip_reasm_process_timer_tick+0xa4>
      {
      /* save the next pointer for the IRE that may be deleted */
      nxt_tmpp = tmpp->next;
 324221c:	e0bfff17 	ldw	r2,-4(fp)
 3242220:	10800017 	ldw	r2,0(r2)
 3242224:	e0bffe15 	stw	r2,-8(fp)
      ++tmpp->age;
 3242228:	e0bfff17 	ldw	r2,-4(fp)
 324222c:	10800517 	ldw	r2,20(r2)
 3242230:	10c00044 	addi	r3,r2,1
 3242234:	e0bfff17 	ldw	r2,-4(fp)
 3242238:	10c00515 	stw	r3,20(r2)
      /* check to see if this entry has reached its max age (expired)? */
      if (tmpp->age == IRE_TMO)
 324223c:	e0bfff17 	ldw	r2,-4(fp)
 3242240:	10800517 	ldw	r2,20(r2)
 3242244:	10801e18 	cmpnei	r2,r2,120
 3242248:	1000121e 	bne	r2,zero,3242294 <ip_reasm_process_timer_tick+0x9c>
         {
         /* it has...and therefore must be deleted. */
         ++ire_stats.ire_timed_out;
 324224c:	0080c9b4 	movhi	r2,806
 3242250:	10b55f04 	addi	r2,r2,-10884
 3242254:	10800117 	ldw	r2,4(r2)
 3242258:	10c00044 	addi	r3,r2,1
 324225c:	0080c9b4 	movhi	r2,806
 3242260:	10b55f04 	addi	r2,r2,-10884
 3242264:	10c00115 	stw	r3,4(r2)
#ifdef FULL_ICMP
         /* send ICMP Time Exceeded message with code 1 ("fragment reassembly time exceeded") */
         ip_reasm_send_icmp_timex (tmpp);
 3242268:	e13fff17 	ldw	r4,-4(fp)
 324226c:	32429400 	call	3242940 <ip_reasm_send_icmp_timex>
#endif
         ip_reasm_delete_ire (tmpp);
 3242270:	e13fff17 	ldw	r4,-4(fp)
 3242274:	32422dc0 	call	32422dc <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 3242278:	0080c9b4 	movhi	r2,806
 324227c:	10b54b04 	addi	r2,r2,-10964
 3242280:	10800f17 	ldw	r2,60(r2)
 3242284:	10c00044 	addi	r3,r2,1
 3242288:	0080c9b4 	movhi	r2,806
 324228c:	10b54b04 	addi	r2,r2,-10964
 3242290:	10c00f15 	stw	r3,60(r2)
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 3242294:	e0bffe17 	ldw	r2,-8(fp)
 3242298:	e0bfff15 	stw	r2,-4(fp)
 324229c:	e0bfff17 	ldw	r2,-4(fp)
 32422a0:	1004c03a 	cmpne	r2,r2,zero
 32422a4:	103fdd1e 	bne	r2,zero,324221c <ip_reasm_process_timer_tick+0x24>
         ++ip_mib.ipReasmFails;
         }
      }

   /* set the time for the next invocation of this routine (one second later) */
   ire_cticks = cticks + TPS;
 32422a8:	0080c974 	movhi	r2,805
 32422ac:	10934104 	addi	r2,r2,19716
 32422b0:	10800017 	ldw	r2,0(r2)
 32422b4:	1080fa04 	addi	r2,r2,1000
 32422b8:	d0a90015 	stw	r2,-23552(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 32422bc:	0009883a 	mov	r4,zero
 32422c0:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   return IPREASM_OK;
 32422c4:	0005883a 	mov	r2,zero
}
 32422c8:	e037883a 	mov	sp,fp
 32422cc:	dfc00117 	ldw	ra,4(sp)
 32422d0:	df000017 	ldw	fp,0(sp)
 32422d4:	dec00204 	addi	sp,sp,8
 32422d8:	f800283a 	ret

032422dc <ip_reasm_delete_ire>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in the 
master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_delete_ire (IREP irep)
{
 32422dc:	defff504 	addi	sp,sp,-44
 32422e0:	dfc00a15 	stw	ra,40(sp)
 32422e4:	df000915 	stw	fp,36(sp)
 32422e8:	df000904 	addi	fp,sp,36
 32422ec:	e13ffe15 	stw	r4,-8(fp)
   RFQP rfqp, first_rfqp, prev_rfqp;
   u_short i;
   PACKET p;
   IREP tmpp;
   IREP prev_tmpp = 0;
 32422f0:	e03ff715 	stw	zero,-36(fp)

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 32422f4:	d0a8ff17 	ldw	r2,-23556(gp)
 32422f8:	e0bff815 	stw	r2,-32(fp)
 32422fc:	00001406 	br	3242350 <ip_reasm_delete_ire+0x74>
      {
      if (tmpp == irep) 
 3242300:	e0fff817 	ldw	r3,-32(fp)
 3242304:	e0bffe17 	ldw	r2,-8(fp)
 3242308:	18800c1e 	bne	r3,r2,324233c <ip_reasm_delete_ire+0x60>
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
 324230c:	d0e8ff17 	ldw	r3,-23556(gp)
 3242310:	e0bff817 	ldw	r2,-32(fp)
 3242314:	10c0041e 	bne	r2,r3,3242328 <ip_reasm_delete_ire+0x4c>
 3242318:	e0bffe17 	ldw	r2,-8(fp)
 324231c:	10800017 	ldw	r2,0(r2)
 3242320:	d0a8ff15 	stw	r2,-23556(gp)
 3242324:	00000d06 	br	324235c <ip_reasm_delete_ire+0x80>
         else prev_tmpp->next = irep->next;
 3242328:	e0bffe17 	ldw	r2,-8(fp)
 324232c:	10c00017 	ldw	r3,0(r2)
 3242330:	e0bff717 	ldw	r2,-36(fp)
 3242334:	10c00015 	stw	r3,0(r2)
         break;
 3242338:	00000806 	br	324235c <ip_reasm_delete_ire+0x80>
         }
      prev_tmpp = tmpp;
 324233c:	e0bff817 	ldw	r2,-32(fp)
 3242340:	e0bff715 	stw	r2,-36(fp)
   IREP tmpp;
   IREP prev_tmpp = 0;

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 3242344:	e0bff817 	ldw	r2,-32(fp)
 3242348:	10800017 	ldw	r2,0(r2)
 324234c:	e0bff815 	stw	r2,-32(fp)
 3242350:	e0bff817 	ldw	r2,-32(fp)
 3242354:	1004c03a 	cmpne	r2,r2,zero
 3242358:	103fe91e 	bne	r2,zero,3242300 <ip_reasm_delete_ire+0x24>
      prev_tmpp = tmpp;
      }

   /* if the IRE entry does not exist in the master table, return an error 
    * to the caller */
   if (!tmpp)
 324235c:	e0bff817 	ldw	r2,-32(fp)
 3242360:	1004c03a 	cmpne	r2,r2,zero
 3242364:	10000a1e 	bne	r2,zero,3242390 <ip_reasm_delete_ire+0xb4>
      {
      ++ire_stats.bad_irep;
 3242368:	0080c9b4 	movhi	r2,806
 324236c:	10b55f04 	addi	r2,r2,-10884
 3242370:	10800017 	ldw	r2,0(r2)
 3242374:	10c00044 	addi	r3,r2,1
 3242378:	0080c9b4 	movhi	r2,806
 324237c:	10b55f04 	addi	r2,r2,-10884
 3242380:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 3242384:	00bffd84 	movi	r2,-10
 3242388:	e0bfff15 	stw	r2,-4(fp)
 324238c:	00003f06 	br	324248c <ip_reasm_delete_ire+0x1b0>
      }

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);
 3242390:	e0bffe17 	ldw	r2,-8(fp)
 3242394:	10800604 	addi	r2,r2,24
 3242398:	e0bffc15 	stw	r2,-16(fp)
 324239c:	e0bffc17 	ldw	r2,-16(fp)
 32423a0:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 32423a4:	00003106 	br	324246c <ip_reasm_delete_ire+0x190>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 32423a8:	e03ffa0d 	sth	zero,-24(fp)
 32423ac:	00002006 	br	3242430 <ip_reasm_delete_ire+0x154>
         {
         if ((p = rfqp->bufp [i]) != 0)
 32423b0:	e0bffa0b 	ldhu	r2,-24(fp)
 32423b4:	e0fffd17 	ldw	r3,-12(fp)
 32423b8:	1085883a 	add	r2,r2,r2
 32423bc:	1085883a 	add	r2,r2,r2
 32423c0:	10c5883a 	add	r2,r2,r3
 32423c4:	10800104 	addi	r2,r2,4
 32423c8:	10800017 	ldw	r2,0(r2)
 32423cc:	e0bff915 	stw	r2,-28(fp)
 32423d0:	e0bff917 	ldw	r2,-28(fp)
 32423d4:	1005003a 	cmpeq	r2,r2,zero
 32423d8:	10000b1e 	bne	r2,zero,3242408 <ip_reasm_delete_ire+0x12c>
            {
            ip_reasm_decr_mem_useage (p->nb_blen);
 32423dc:	e0bff917 	ldw	r2,-28(fp)
 32423e0:	10800217 	ldw	r2,8(r2)
 32423e4:	113fffcc 	andi	r4,r2,65535
 32423e8:	3240ef40 	call	3240ef4 <ip_reasm_decr_mem_useage>
            LOCK_NET_RESOURCE (FREEQ_RESID);
 32423ec:	01000084 	movi	r4,2
 32423f0:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
            pk_free (p);
 32423f4:	e13ff917 	ldw	r4,-28(fp)
 32423f8:	322a6400 	call	322a640 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);               
 32423fc:	01000084 	movi	r4,2
 3242400:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
 3242404:	00000706 	br	3242424 <ip_reasm_delete_ire+0x148>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 3242408:	e0bffe17 	ldw	r2,-8(fp)
 324240c:	10802103 	ldbu	r2,132(r2)
 3242410:	10803fcc 	andi	r2,r2,255
 3242414:	1080004c 	andi	r2,r2,1
 3242418:	10803fcc 	andi	r2,r2,255
 324241c:	1004c03a 	cmpne	r2,r2,zero
 3242420:	1000061e 	bne	r2,zero,324243c <ip_reasm_delete_ire+0x160>
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 3242424:	e0bffa0b 	ldhu	r2,-24(fp)
 3242428:	10800044 	addi	r2,r2,1
 324242c:	e0bffa0d 	sth	r2,-24(fp)
 3242430:	e0bffa0b 	ldhu	r2,-24(fp)
 3242434:	10800430 	cmpltui	r2,r2,16
 3242438:	103fdd1e 	bne	r2,zero,32423b0 <ip_reasm_delete_ire+0xd4>
               break;
               }
            }
          }

       prev_rfqp = rfqp;
 324243c:	e0bffd17 	ldw	r2,-12(fp)
 3242440:	e0bffb15 	stw	r2,-20(fp)
       rfqp = rfqp->next;
 3242444:	e0bffd17 	ldw	r2,-12(fp)
 3242448:	10800017 	ldw	r2,0(r2)
 324244c:	e0bffd15 	stw	r2,-12(fp)
       /* the first RFQ is statically allocated, and cannot be freed */
       if (prev_rfqp != first_rfqp)
 3242450:	e0fffb17 	ldw	r3,-20(fp)
 3242454:	e0bffc17 	ldw	r2,-16(fp)
 3242458:	18800426 	beq	r3,r2,324246c <ip_reasm_delete_ire+0x190>
          {
          ip_reasm_decr_mem_useage (sizeof(RFQ));
 324245c:	01001904 	movi	r4,100
 3242460:	3240ef40 	call	3240ef4 <ip_reasm_decr_mem_useage>
          IPR_FREE (prev_rfqp);
 3242464:	e13ffb17 	ldw	r4,-20(fp)
 3242468:	322ba280 	call	322ba28 <npfree>

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
 324246c:	e0bffd17 	ldw	r2,-12(fp)
 3242470:	1004c03a 	cmpne	r2,r2,zero
 3242474:	103fcc1e 	bne	r2,zero,32423a8 <ip_reasm_delete_ire+0xcc>
          IPR_FREE (prev_rfqp);
          }
      }

   /* now free the parent entity */
   ip_reasm_decr_mem_useage (sizeof(IRE));
 3242478:	01002204 	movi	r4,136
 324247c:	3240ef40 	call	3240ef4 <ip_reasm_decr_mem_useage>
   IPR_FREE (irep);
 3242480:	e13ffe17 	ldw	r4,-8(fp)
 3242484:	322ba280 	call	322ba28 <npfree>

   return IPREASM_OK;
 3242488:	e03fff15 	stw	zero,-4(fp)
 324248c:	e0bfff17 	ldw	r2,-4(fp)
}
 3242490:	e037883a 	mov	sp,fp
 3242494:	dfc00117 	ldw	ra,4(sp)
 3242498:	df000017 	ldw	fp,0(sp)
 324249c:	dec00204 	addi	sp,sp,8
 32424a0:	f800283a 	ret

032424a4 <ip_reasm_mark_compact_rfq>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in 
the master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_mark_compact_rfq (IREP irep)
{
 32424a4:	defffa04 	addi	sp,sp,-24
 32424a8:	dfc00515 	stw	ra,20(sp)
 32424ac:	df000415 	stw	fp,16(sp)
 32424b0:	df000404 	addi	fp,sp,16
 32424b4:	e13ffe15 	stw	r4,-8(fp)
   RFQP rfqp;
   u_short i;
   u_char empty_slot_discovered = IPREASM_FALSE;
 32424b8:	e03ffc45 	stb	zero,-15(fp)
   u_char compact = IPREASM_TRUE;
 32424bc:	00800044 	movi	r2,1
 32424c0:	e0bffc05 	stb	r2,-16(fp)

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 32424c4:	e13ffe17 	ldw	r4,-8(fp)
 32424c8:	3241e380 	call	3241e38 <ip_reasm_find_ire>
 32424cc:	10803fcc 	andi	r2,r2,255
 32424d0:	10800060 	cmpeqi	r2,r2,1
 32424d4:	10000a1e 	bne	r2,zero,3242500 <ip_reasm_mark_compact_rfq+0x5c>
   {
      ++ire_stats.bad_irep;
 32424d8:	0080c9b4 	movhi	r2,806
 32424dc:	10b55f04 	addi	r2,r2,-10884
 32424e0:	10800017 	ldw	r2,0(r2)
 32424e4:	10c00044 	addi	r3,r2,1
 32424e8:	0080c9b4 	movhi	r2,806
 32424ec:	10b55f04 	addi	r2,r2,-10884
 32424f0:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 32424f4:	00bffd84 	movi	r2,-10
 32424f8:	e0bfff15 	stw	r2,-4(fp)
 32424fc:	00003506 	br	32425d4 <ip_reasm_mark_compact_rfq+0x130>
   }

   rfqp = &(irep->rfq);
 3242500:	e0bffe17 	ldw	r2,-8(fp)
 3242504:	10800604 	addi	r2,r2,24
 3242508:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 324250c:	00001c06 	br	3242580 <ip_reasm_mark_compact_rfq+0xdc>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 3242510:	e03ffc8d 	sth	zero,-14(fp)
 3242514:	00001406 	br	3242568 <ip_reasm_mark_compact_rfq+0xc4>
         {
         if (rfqp->bufp [i] == 0)
 3242518:	e0bffc8b 	ldhu	r2,-14(fp)
 324251c:	e0fffd17 	ldw	r3,-12(fp)
 3242520:	1085883a 	add	r2,r2,r2
 3242524:	1085883a 	add	r2,r2,r2
 3242528:	10c5883a 	add	r2,r2,r3
 324252c:	10800104 	addi	r2,r2,4
 3242530:	10800017 	ldw	r2,0(r2)
 3242534:	1004c03a 	cmpne	r2,r2,zero
 3242538:	1000031e 	bne	r2,zero,3242548 <ip_reasm_mark_compact_rfq+0xa4>
            {            
            empty_slot_discovered = IPREASM_TRUE;
 324253c:	00800044 	movi	r2,1
 3242540:	e0bffc45 	stb	r2,-15(fp)
 3242544:	00000506 	br	324255c <ip_reasm_mark_compact_rfq+0xb8>
            }
         else
            {
            if (empty_slot_discovered) 
 3242548:	e0bffc43 	ldbu	r2,-15(fp)
 324254c:	1005003a 	cmpeq	r2,r2,zero
 3242550:	1000021e 	bne	r2,zero,324255c <ip_reasm_mark_compact_rfq+0xb8>
               {
               compact = IPREASM_FALSE;
 3242554:	e03ffc05 	stb	zero,-16(fp)
               break;
 3242558:	00000606 	br	3242574 <ip_reasm_mark_compact_rfq+0xd0>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 324255c:	e0bffc8b 	ldhu	r2,-14(fp)
 3242560:	10800044 	addi	r2,r2,1
 3242564:	e0bffc8d 	sth	r2,-14(fp)
 3242568:	e0bffc8b 	ldhu	r2,-14(fp)
 324256c:	10800430 	cmpltui	r2,r2,16
 3242570:	103fe91e 	bne	r2,zero,3242518 <ip_reasm_mark_compact_rfq+0x74>
               compact = IPREASM_FALSE;
               break;
               }
            }
          }
       rfqp = rfqp->next;
 3242574:	e0bffd17 	ldw	r2,-12(fp)
 3242578:	10800017 	ldw	r2,0(r2)
 324257c:	e0bffd15 	stw	r2,-12(fp)
      return ENP_PARAM;
   }

   rfqp = &(irep->rfq);

   while (rfqp)
 3242580:	e0bffd17 	ldw	r2,-12(fp)
 3242584:	1004c03a 	cmpne	r2,r2,zero
 3242588:	103fe11e 	bne	r2,zero,3242510 <ip_reasm_mark_compact_rfq+0x6c>
            }
          }
       rfqp = rfqp->next;
      }

   if (compact) 
 324258c:	e0bffc03 	ldbu	r2,-16(fp)
 3242590:	1005003a 	cmpeq	r2,r2,zero
 3242594:	1000071e 	bne	r2,zero,32425b4 <ip_reasm_mark_compact_rfq+0x110>
      {
      irep->flags |= IPR_RFQ_COMPACT;
 3242598:	e0bffe17 	ldw	r2,-8(fp)
 324259c:	10802103 	ldbu	r2,132(r2)
 32425a0:	10800054 	ori	r2,r2,1
 32425a4:	1007883a 	mov	r3,r2
 32425a8:	e0bffe17 	ldw	r2,-8(fp)
 32425ac:	10c02105 	stb	r3,132(r2)
 32425b0:	00000706 	br	32425d0 <ip_reasm_mark_compact_rfq+0x12c>
      }
   else 
      {
      irep->flags &= ~IPR_RFQ_COMPACT;
 32425b4:	e0bffe17 	ldw	r2,-8(fp)
 32425b8:	10c02103 	ldbu	r3,132(r2)
 32425bc:	00bfff84 	movi	r2,-2
 32425c0:	1884703a 	and	r2,r3,r2
 32425c4:	1007883a 	mov	r3,r2
 32425c8:	e0bffe17 	ldw	r2,-8(fp)
 32425cc:	10c02105 	stb	r3,132(r2)
      }

   return IPREASM_OK;
 32425d0:	e03fff15 	stw	zero,-4(fp)
 32425d4:	e0bfff17 	ldw	r2,-4(fp)
}
 32425d8:	e037883a 	mov	sp,fp
 32425dc:	dfc00117 	ldw	ra,4(sp)
 32425e0:	df000017 	ldw	fp,0(sp)
 32425e4:	dec00204 	addi	sp,sp,8
 32425e8:	f800283a 	ret

032425ec <ipr_stats>:

OUTPUT: This function always returns IPREASM_OK.
*/

int ipr_stats(void * pio)
{
 32425ec:	deffec04 	addi	sp,sp,-80
 32425f0:	dfc01315 	stw	ra,76(sp)
 32425f4:	df001215 	stw	fp,72(sp)
 32425f8:	dc001115 	stw	r16,68(sp)
 32425fc:	df001104 	addi	fp,sp,68
 3242600:	e13fff15 	stw	r4,-4(fp)
   unsigned long ticks_elapsed = cticks;
 3242604:	0080c974 	movhi	r2,805
 3242608:	10934104 	addi	r2,r2,19716
 324260c:	10800017 	ldw	r2,0(r2)
 3242610:	e0bffe15 	stw	r2,-8(fp)
   u_short size_ire = sizeof(IRE);
 3242614:	00802204 	movi	r2,136
 3242618:	e0bffd8d 	sth	r2,-10(fp)
   u_short size_rfq = sizeof(RFQ);
 324261c:	00801904 	movi	r2,100
 3242620:	e0bffd0d 	sth	r2,-12(fp)
   IREP tmpp;
   u_short count = 0;
 3242624:	e03ffb0d 	sth	zero,-20(fp)
   RFQP rfqp;
   u_short frag_count = 0;
 3242628:	e03ff98d 	sth	zero,-26(fp)
   u_short i;

   ns_printf(pio,"IP reassembly statistics:\n");
 324262c:	e13fff17 	ldw	r4,-4(fp)
 3242630:	0140c974 	movhi	r5,805
 3242634:	297f8f04 	addi	r5,r5,-452
 3242638:	322637c0 	call	322637c <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
 324263c:	d428fe17 	ldw	r16,-23560(gp)
 3242640:	e13ffe17 	ldw	r4,-8(fp)
 3242644:	0140fa04 	movi	r5,1000
 3242648:	32047c00 	call	32047c0 <__udivsi3>
 324264c:	e0fffd8b 	ldhu	r3,-10(fp)
 3242650:	e13ffd0b 	ldhu	r4,-12(fp)
 3242654:	d8800015 	stw	r2,0(sp)
 3242658:	d8c00115 	stw	r3,4(sp)
 324265c:	d9000215 	stw	r4,8(sp)
 3242660:	e13fff17 	ldw	r4,-4(fp)
 3242664:	0140c974 	movhi	r5,805
 3242668:	297f9604 	addi	r5,r5,-424
 324266c:	800d883a 	mov	r6,r16
 3242670:	e1fffe17 	ldw	r7,-8(fp)
 3242674:	322637c0 	call	322637c <ns_printf>
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
 3242678:	0080c9b4 	movhi	r2,806
 324267c:	10b55f04 	addi	r2,r2,-10884
 3242680:	11800117 	ldw	r6,4(r2)
 3242684:	0080c9b4 	movhi	r2,806
 3242688:	10b55f04 	addi	r2,r2,-10884
 324268c:	11c00017 	ldw	r7,0(r2)
 3242690:	0080c9b4 	movhi	r2,806
 3242694:	10b55f04 	addi	r2,r2,-10884
 3242698:	11000217 	ldw	r4,8(r2)
 324269c:	0080c9b4 	movhi	r2,806
 32426a0:	10b55f04 	addi	r2,r2,-10884
 32426a4:	11400317 	ldw	r5,12(r2)
 32426a8:	0080c9b4 	movhi	r2,806
 32426ac:	10b55f04 	addi	r2,r2,-10884
 32426b0:	10c00417 	ldw	r3,16(r2)
 32426b4:	0080c9b4 	movhi	r2,806
 32426b8:	10b55f04 	addi	r2,r2,-10884
 32426bc:	10800517 	ldw	r2,20(r2)
 32426c0:	d9000015 	stw	r4,0(sp)
 32426c4:	d9400115 	stw	r5,4(sp)
 32426c8:	d8c00215 	stw	r3,8(sp)
 32426cc:	d8800315 	stw	r2,12(sp)
 32426d0:	e13fff17 	ldw	r4,-4(fp)
 32426d4:	0140c974 	movhi	r5,805
 32426d8:	297fa604 	addi	r5,r5,-360
 32426dc:	322637c0 	call	322637c <ns_printf>
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
 32426e0:	d1a8ff17 	ldw	r6,-23556(gp)
 32426e4:	e13fff17 	ldw	r4,-4(fp)
 32426e8:	0140c974 	movhi	r5,805
 32426ec:	297fbb04 	addi	r5,r5,-276
 32426f0:	322637c0 	call	322637c <ns_printf>
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 32426f4:	d0a8ff17 	ldw	r2,-23556(gp)
 32426f8:	e0bffc15 	stw	r2,-16(fp)
 32426fc:	00008106 	br	3242904 <ipr_stats+0x318>
      {
      ++count;
 3242700:	e0bffb0b 	ldhu	r2,-20(fp)
 3242704:	10800044 	addi	r2,r2,1
 3242708:	e0bffb0d 	sth	r2,-20(fp)
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
 324270c:	e0bffc17 	ldw	r2,-16(fp)
 3242710:	10800604 	addi	r2,r2,24
 3242714:	e0bffa15 	stw	r2,-24(fp)
      while (rfqp)
 3242718:	00001f06 	br	3242798 <ipr_stats+0x1ac>
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 324271c:	e03ff90d 	sth	zero,-28(fp)
 3242720:	00001706 	br	3242780 <ipr_stats+0x194>
            {
            if (rfqp->bufp [i] != 0)
 3242724:	e0bff90b 	ldhu	r2,-28(fp)
 3242728:	e0fffa17 	ldw	r3,-24(fp)
 324272c:	1085883a 	add	r2,r2,r2
 3242730:	1085883a 	add	r2,r2,r2
 3242734:	10c5883a 	add	r2,r2,r3
 3242738:	10800104 	addi	r2,r2,4
 324273c:	10800017 	ldw	r2,0(r2)
 3242740:	1005003a 	cmpeq	r2,r2,zero
 3242744:	1000041e 	bne	r2,zero,3242758 <ipr_stats+0x16c>
               {
               ++frag_count;            
 3242748:	e0bff98b 	ldhu	r2,-26(fp)
 324274c:	10800044 	addi	r2,r2,1
 3242750:	e0bff98d 	sth	r2,-26(fp)
 3242754:	00000706 	br	3242774 <ipr_stats+0x188>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
 3242758:	e0bffc17 	ldw	r2,-16(fp)
 324275c:	10802103 	ldbu	r2,132(r2)
 3242760:	10803fcc 	andi	r2,r2,255
 3242764:	1080004c 	andi	r2,r2,1
 3242768:	10803fcc 	andi	r2,r2,255
 324276c:	1004c03a 	cmpne	r2,r2,zero
 3242770:	1000061e 	bne	r2,zero,324278c <ipr_stats+0x1a0>
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 3242774:	e0bff90b 	ldhu	r2,-28(fp)
 3242778:	10800044 	addi	r2,r2,1
 324277c:	e0bff90d 	sth	r2,-28(fp)
 3242780:	e0bff90b 	ldhu	r2,-28(fp)
 3242784:	10800430 	cmpltui	r2,r2,16
 3242788:	103fe61e 	bne	r2,zero,3242724 <ipr_stats+0x138>
                  {
                  break;
                  }
               }
            }
         rfqp = rfqp->next;
 324278c:	e0bffa17 	ldw	r2,-24(fp)
 3242790:	10800017 	ldw	r2,0(r2)
 3242794:	e0bffa15 	stw	r2,-24(fp)
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
 3242798:	e0bffa17 	ldw	r2,-24(fp)
 324279c:	1004c03a 	cmpne	r2,r2,zero
 32427a0:	103fde1e 	bne	r2,zero,324271c <ipr_stats+0x130>
                  }
               }
            }
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
 32427a4:	e1fff98b 	ldhu	r7,-26(fp)
 32427a8:	e0bffc17 	ldw	r2,-16(fp)
 32427ac:	10800117 	ldw	r2,4(r2)
 32427b0:	1004d63a 	srli	r2,r2,24
 32427b4:	10c03fcc 	andi	r3,r2,255
 32427b8:	e0bffc17 	ldw	r2,-16(fp)
 32427bc:	10800117 	ldw	r2,4(r2)
 32427c0:	1004d23a 	srli	r2,r2,8
 32427c4:	10bfc00c 	andi	r2,r2,65280
 32427c8:	1886b03a 	or	r3,r3,r2
 32427cc:	e0bffc17 	ldw	r2,-16(fp)
 32427d0:	10800117 	ldw	r2,4(r2)
 32427d4:	10bfc00c 	andi	r2,r2,65280
 32427d8:	1004923a 	slli	r2,r2,8
 32427dc:	1886b03a 	or	r3,r3,r2
 32427e0:	e0bffc17 	ldw	r2,-16(fp)
 32427e4:	10800117 	ldw	r2,4(r2)
 32427e8:	10803fcc 	andi	r2,r2,255
 32427ec:	1004963a 	slli	r2,r2,24
 32427f0:	1888b03a 	or	r4,r3,r2
 32427f4:	e0bffc17 	ldw	r2,-16(fp)
 32427f8:	10800217 	ldw	r2,8(r2)
 32427fc:	1004d63a 	srli	r2,r2,24
 3242800:	10c03fcc 	andi	r3,r2,255
 3242804:	e0bffc17 	ldw	r2,-16(fp)
 3242808:	10800217 	ldw	r2,8(r2)
 324280c:	1004d23a 	srli	r2,r2,8
 3242810:	10bfc00c 	andi	r2,r2,65280
 3242814:	1886b03a 	or	r3,r3,r2
 3242818:	e0bffc17 	ldw	r2,-16(fp)
 324281c:	10800217 	ldw	r2,8(r2)
 3242820:	10bfc00c 	andi	r2,r2,65280
 3242824:	1004923a 	slli	r2,r2,8
 3242828:	1886b03a 	or	r3,r3,r2
 324282c:	e0bffc17 	ldw	r2,-16(fp)
 3242830:	10800217 	ldw	r2,8(r2)
 3242834:	10803fcc 	andi	r2,r2,255
 3242838:	1004963a 	slli	r2,r2,24
 324283c:	188ab03a 	or	r5,r3,r2
 3242840:	e0bffc17 	ldw	r2,-16(fp)
 3242844:	10800383 	ldbu	r2,14(r2)
 3242848:	11803fcc 	andi	r6,r2,255
 324284c:	e0bffc17 	ldw	r2,-16(fp)
 3242850:	1080030b 	ldhu	r2,12(r2)
 3242854:	10bfffcc 	andi	r2,r2,65535
 3242858:	1004d23a 	srli	r2,r2,8
 324285c:	10bfffcc 	andi	r2,r2,65535
 3242860:	10c03fcc 	andi	r3,r2,255
 3242864:	e0bffc17 	ldw	r2,-16(fp)
 3242868:	1080030b 	ldhu	r2,12(r2)
 324286c:	10bfffcc 	andi	r2,r2,65535
 3242870:	1004923a 	slli	r2,r2,8
 3242874:	10bfc00c 	andi	r2,r2,65280
 3242878:	1886b03a 	or	r3,r3,r2
 324287c:	e0bffc17 	ldw	r2,-16(fp)
 3242880:	1080040b 	ldhu	r2,16(r2)
 3242884:	123fffcc 	andi	r8,r2,65535
 3242888:	e0bffc17 	ldw	r2,-16(fp)
 324288c:	1080048b 	ldhu	r2,18(r2)
 3242890:	127fffcc 	andi	r9,r2,65535
 3242894:	e0bffc17 	ldw	r2,-16(fp)
 3242898:	12800517 	ldw	r10,20(r2)
 324289c:	e0bffc17 	ldw	r2,-16(fp)
 32428a0:	12c01f17 	ldw	r11,124(r2)
 32428a4:	e0bffc17 	ldw	r2,-16(fp)
 32428a8:	13002017 	ldw	r12,128(r2)
 32428ac:	e0bffc17 	ldw	r2,-16(fp)
 32428b0:	10802103 	ldbu	r2,132(r2)
 32428b4:	10803fcc 	andi	r2,r2,255
 32428b8:	1080004c 	andi	r2,r2,1
 32428bc:	d9000015 	stw	r4,0(sp)
 32428c0:	d9400115 	stw	r5,4(sp)
 32428c4:	d9800215 	stw	r6,8(sp)
 32428c8:	d8c00315 	stw	r3,12(sp)
 32428cc:	da000415 	stw	r8,16(sp)
 32428d0:	da400515 	stw	r9,20(sp)
 32428d4:	da800615 	stw	r10,24(sp)
 32428d8:	dac00715 	stw	r11,28(sp)
 32428dc:	db000815 	stw	r12,32(sp)
 32428e0:	d8800915 	stw	r2,36(sp)
 32428e4:	e13fff17 	ldw	r4,-4(fp)
 32428e8:	0140c974 	movhi	r5,805
 32428ec:	297fc104 	addi	r5,r5,-252
 32428f0:	e1bffc17 	ldw	r6,-16(fp)
 32428f4:	322637c0 	call	322637c <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 32428f8:	e0bffc17 	ldw	r2,-16(fp)
 32428fc:	10800017 	ldw	r2,0(r2)
 3242900:	e0bffc15 	stw	r2,-16(fp)
 3242904:	e0bffc17 	ldw	r2,-16(fp)
 3242908:	1004c03a 	cmpne	r2,r2,zero
 324290c:	103f7c1e 	bne	r2,zero,3242700 <ipr_stats+0x114>
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
      } /* end FOR (IRE linked list) */

   ns_printf(pio,"Found a total of %u IRE entries\n",count);
 3242910:	e1bffb0b 	ldhu	r6,-20(fp)
 3242914:	e13fff17 	ldw	r4,-4(fp)
 3242918:	0140c974 	movhi	r5,805
 324291c:	297fdc04 	addi	r5,r5,-144
 3242920:	322637c0 	call	322637c <ns_printf>

   return IPREASM_OK;
 3242924:	0005883a 	mov	r2,zero
}
 3242928:	e037883a 	mov	sp,fp
 324292c:	dfc00217 	ldw	ra,8(sp)
 3242930:	df000117 	ldw	fp,4(sp)
 3242934:	dc000017 	ldw	r16,0(sp)
 3242938:	dec00304 	addi	sp,sp,12
 324293c:	f800283a 	ret

03242940 <ip_reasm_send_icmp_timex>:
OUTPUT: This function always returns IPREASM_OK.
*/

#ifdef FULL_ICMP
u_long ip_reasm_send_icmp_timex (IREP irep)
{
 3242940:	defffc04 	addi	sp,sp,-16
 3242944:	dfc00315 	stw	ra,12(sp)
 3242948:	df000215 	stw	fp,8(sp)
 324294c:	df000204 	addi	fp,sp,8
 3242950:	e13fff15 	stw	r4,-4(fp)

   /* we can only send an ICMP Time Exceeded message with code 1 ("fragment reassembly 
    * time exceeded") if we have received the First Fragment (FF) of the original, 
    * unfragmented datagram.  This is indicated by a non-zero value for the l2_hdr and
    * l3_hdr fields in the IRE data structure. */
   if (irep->l2_hdr)
 3242954:	e0bfff17 	ldw	r2,-4(fp)
 3242958:	10801f17 	ldw	r2,124(r2)
 324295c:	1005003a 	cmpeq	r2,r2,zero
 3242960:	1000061e 	bne	r2,zero,324297c <ip_reasm_send_icmp_timex+0x3c>
      {
      pip = (struct ip *) irep->l3_hdr;
 3242964:	e0bfff17 	ldw	r2,-4(fp)
 3242968:	10802017 	ldw	r2,128(r2)
 324296c:	e0bffe15 	stw	r2,-8(fp)
      icmp_timex (pip, TIMEX_REASSY_FAILED);
 3242970:	e13ffe17 	ldw	r4,-8(fp)
 3242974:	01400044 	movi	r5,1
 3242978:	324b8900 	call	324b890 <icmp_timex>
      }

   return IPREASM_OK;
 324297c:	0005883a 	mov	r2,zero
}
 3242980:	e037883a 	mov	sp,fp
 3242984:	dfc00117 	ldw	ra,4(sp)
 3242988:	df000017 	ldw	fp,0(sp)
 324298c:	dec00204 	addi	sp,sp,8
 3242990:	f800283a 	ret

03242994 <ip_rcv>:
 * RETURNS: 
 */

int
ip_rcv(PACKET p)
{
 3242994:	defff204 	addi	sp,sp,-56
 3242998:	dfc00d15 	stw	ra,52(sp)
 324299c:	df000c15 	stw	fp,48(sp)
 32429a0:	dc000b15 	stw	r16,44(sp)
 32429a4:	df000b04 	addi	fp,sp,44
 32429a8:	e13ffe15 	stw	r4,-8(fp)
   unsigned hdrlen;  /* length of IP header including options */
   unsigned len;     /* total length including IP header */
   unsigned short int num_pkts;
   PACKET * pktp;
   unsigned char i;
   int rcvrc = -1;
 32429ac:	00bfffc4 	movi	r2,-1
 32429b0:	e0bff515 	stw	r2,-44(fp)
   unsigned char rc_ret;
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 32429b4:	0080c974 	movhi	r2,805
 32429b8:	10931c04 	addi	r2,r2,19568
 32429bc:	10800017 	ldw	r2,0(r2)
 32429c0:	1081000c 	andi	r2,r2,1024
 32429c4:	1005003a 	cmpeq	r2,r2,zero
 32429c8:	1000101e 	bne	r2,zero,3242a0c <ip_rcv+0x78>
 32429cc:	0080c974 	movhi	r2,805
 32429d0:	10931c04 	addi	r2,r2,19568
 32429d4:	10800017 	ldw	r2,0(r2)
 32429d8:	1080800c 	andi	r2,r2,512
 32429dc:	1005003a 	cmpeq	r2,r2,zero
 32429e0:	10000a1e 	bne	r2,zero,3242a0c <ip_rcv+0x78>
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 32429e4:	e0bffe17 	ldw	r2,-8(fp)
 32429e8:	14000417 	ldw	r16,16(r2)
 32429ec:	e0bffe17 	ldw	r2,-8(fp)
 32429f0:	11000617 	ldw	r4,24(r2)
 32429f4:	32240bc0 	call	32240bc <if_netnumber>
 32429f8:	100d883a 	mov	r6,r2
 32429fc:	0100c974 	movhi	r4,805
 3242a00:	213fe504 	addi	r4,r4,-108
 3242a04:	800b883a 	mov	r5,r16
 3242a08:	3206de00 	call	3206de0 <printf>
         p->nb_plen, net_num(p->net));
#endif

   IN_PROFILER(PF_IP, PF_ENTRY);

   nt = p->net;      /* which interface it came in on */
 3242a0c:	e0bffe17 	ldw	r2,-8(fp)
 3242a10:	10800617 	ldw	r2,24(r2)
 3242a14:	e0bffb15 	stw	r2,-20(fp)
   ip_mib.ipInReceives++;
 3242a18:	0080c9b4 	movhi	r2,806
 3242a1c:	10b54b04 	addi	r2,r2,-10964
 3242a20:	10800217 	ldw	r2,8(r2)
 3242a24:	10c00044 	addi	r3,r2,1
 3242a28:	0080c9b4 	movhi	r2,806
 3242a2c:	10b54b04 	addi	r2,r2,-10964
 3242a30:	10c00215 	stw	r3,8(r2)
   pip = ip_head(p);
 3242a34:	e0bffe17 	ldw	r2,-8(fp)
 3242a38:	10800317 	ldw	r2,12(r2)
 3242a3c:	e0bffd15 	stw	r2,-12(fp)

   /* test received MAC len against IP header len */
   if (p->nb_plen < (unsigned)htons(pip->ip_len))
 3242a40:	e0bffe17 	ldw	r2,-8(fp)
 3242a44:	11000417 	ldw	r4,16(r2)
 3242a48:	e0bffd17 	ldw	r2,-12(fp)
 3242a4c:	1080008b 	ldhu	r2,2(r2)
 3242a50:	10bfffcc 	andi	r2,r2,65535
 3242a54:	1004d23a 	srli	r2,r2,8
 3242a58:	10bfffcc 	andi	r2,r2,65535
 3242a5c:	10c03fcc 	andi	r3,r2,255
 3242a60:	e0bffd17 	ldw	r2,-12(fp)
 3242a64:	1080008b 	ldhu	r2,2(r2)
 3242a68:	10bfffcc 	andi	r2,r2,65535
 3242a6c:	1004923a 	slli	r2,r2,8
 3242a70:	10bfc00c 	andi	r2,r2,65280
 3242a74:	1884b03a 	or	r2,r3,r2
 3242a78:	2080272e 	bgeu	r4,r2,3242b18 <ip_rcv+0x184>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 3242a7c:	0080c974 	movhi	r2,805
 3242a80:	10931c04 	addi	r2,r2,19568
 3242a84:	10800017 	ldw	r2,0(r2)
 3242a88:	1081000c 	andi	r2,r2,1024
 3242a8c:	1005003a 	cmpeq	r2,r2,zero
 3242a90:	1000111e 	bne	r2,zero,3242ad8 <ip_rcv+0x144>
 3242a94:	0080c974 	movhi	r2,805
 3242a98:	10931c04 	addi	r2,r2,19568
 3242a9c:	10800017 	ldw	r2,0(r2)
 3242aa0:	1080800c 	andi	r2,r2,512
 3242aa4:	1005003a 	cmpeq	r2,r2,zero
 3242aa8:	10000b1e 	bne	r2,zero,3242ad8 <ip_rcv+0x144>
      {
         dprintf("ip_rcv: bad pkt len\n");
 3242aac:	0100c974 	movhi	r4,805
 3242ab0:	213fee04 	addi	r4,r4,-72
 3242ab4:	32071080 	call	3207108 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 3242ab8:	0080c974 	movhi	r2,805
 3242abc:	10931c04 	addi	r2,r2,19568
 3242ac0:	10800017 	ldw	r2,0(r2)
 3242ac4:	1080008c 	andi	r2,r2,2
 3242ac8:	1005003a 	cmpeq	r2,r2,zero
 3242acc:	1000021e 	bne	r2,zero,3242ad8 <ip_rcv+0x144>
 3242ad0:	e13ffe17 	ldw	r4,-8(fp)
 3242ad4:	324059c0 	call	324059c <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 3242ad8:	0080c9b4 	movhi	r2,806
 3242adc:	10b54b04 	addi	r2,r2,-10964
 3242ae0:	10800317 	ldw	r2,12(r2)
 3242ae4:	10c00044 	addi	r3,r2,1
 3242ae8:	0080c9b4 	movhi	r2,806
 3242aec:	10b54b04 	addi	r2,r2,-10964
 3242af0:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 3242af4:	01000084 	movi	r4,2
 3242af8:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(p);
 3242afc:	e13ffe17 	ldw	r4,-8(fp)
 3242b00:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3242b04:	01000084 	movi	r4,2
 3242b08:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 3242b0c:	00bff804 	movi	r2,-32
 3242b10:	e0bfff15 	stw	r2,-4(fp)
 3242b14:	00009806 	br	3242d78 <ip_rcv+0x3e4>
   }

   /* use length from IP header; MAC value may be padded */
   len = htons(pip->ip_len);
 3242b18:	e0bffd17 	ldw	r2,-12(fp)
 3242b1c:	1080008b 	ldhu	r2,2(r2)
 3242b20:	10bfffcc 	andi	r2,r2,65535
 3242b24:	1004d23a 	srli	r2,r2,8
 3242b28:	10bfffcc 	andi	r2,r2,65535
 3242b2c:	10c03fcc 	andi	r3,r2,255
 3242b30:	e0bffd17 	ldw	r2,-12(fp)
 3242b34:	1080008b 	ldhu	r2,2(r2)
 3242b38:	10bfffcc 	andi	r2,r2,65535
 3242b3c:	1004923a 	slli	r2,r2,8
 3242b40:	10bfc00c 	andi	r2,r2,65280
 3242b44:	1884b03a 	or	r2,r3,r2
 3242b48:	e0bff915 	stw	r2,-28(fp)
   p->nb_plen = len;       /* fix pkt len */
 3242b4c:	e0fffe17 	ldw	r3,-8(fp)
 3242b50:	e0bff917 	ldw	r2,-28(fp)
 3242b54:	18800415 	stw	r2,16(r3)

   if ( ((pip->ip_ver_ihl & 0xf0) >> 4) != IP_VER)
 3242b58:	e0bffd17 	ldw	r2,-12(fp)
 3242b5c:	10800003 	ldbu	r2,0(r2)
 3242b60:	10803fcc 	andi	r2,r2,255
 3242b64:	10803c0c 	andi	r2,r2,240
 3242b68:	1005d13a 	srai	r2,r2,4
 3242b6c:	10800120 	cmpeqi	r2,r2,4
 3242b70:	1000271e 	bne	r2,zero,3242c10 <ip_rcv+0x27c>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 3242b74:	0080c974 	movhi	r2,805
 3242b78:	10931c04 	addi	r2,r2,19568
 3242b7c:	10800017 	ldw	r2,0(r2)
 3242b80:	1081000c 	andi	r2,r2,1024
 3242b84:	1005003a 	cmpeq	r2,r2,zero
 3242b88:	1000111e 	bne	r2,zero,3242bd0 <ip_rcv+0x23c>
 3242b8c:	0080c974 	movhi	r2,805
 3242b90:	10931c04 	addi	r2,r2,19568
 3242b94:	10800017 	ldw	r2,0(r2)
 3242b98:	1080800c 	andi	r2,r2,512
 3242b9c:	1005003a 	cmpeq	r2,r2,zero
 3242ba0:	10000b1e 	bne	r2,zero,3242bd0 <ip_rcv+0x23c>
      {
         dprintf("ip_rcv: bad version number\n");
 3242ba4:	0100c974 	movhi	r4,805
 3242ba8:	213ff304 	addi	r4,r4,-52
 3242bac:	32071080 	call	3207108 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 3242bb0:	0080c974 	movhi	r2,805
 3242bb4:	10931c04 	addi	r2,r2,19568
 3242bb8:	10800017 	ldw	r2,0(r2)
 3242bbc:	1080008c 	andi	r2,r2,2
 3242bc0:	1005003a 	cmpeq	r2,r2,zero
 3242bc4:	1000021e 	bne	r2,zero,3242bd0 <ip_rcv+0x23c>
 3242bc8:	e13ffe17 	ldw	r4,-8(fp)
 3242bcc:	324059c0 	call	324059c <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 3242bd0:	0080c9b4 	movhi	r2,806
 3242bd4:	10b54b04 	addi	r2,r2,-10964
 3242bd8:	10800317 	ldw	r2,12(r2)
 3242bdc:	10c00044 	addi	r3,r2,1
 3242be0:	0080c9b4 	movhi	r2,806
 3242be4:	10b54b04 	addi	r2,r2,-10964
 3242be8:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 3242bec:	01000084 	movi	r4,2
 3242bf0:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(p);
 3242bf4:	e13ffe17 	ldw	r4,-8(fp)
 3242bf8:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3242bfc:	01000084 	movi	r4,2
 3242c00:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 3242c04:	00bff804 	movi	r2,-32
 3242c08:	e0bfff15 	stw	r2,-4(fp)
 3242c0c:	00005a06 	br	3242d78 <ip_rcv+0x3e4>
   }

   csum = pip->ip_chksum;
 3242c10:	e0bffd17 	ldw	r2,-12(fp)
 3242c14:	1080028b 	ldhu	r2,10(r2)
 3242c18:	e0bffc8d 	sth	r2,-14(fp)
   pip->ip_chksum = 0;
 3242c1c:	e0bffd17 	ldw	r2,-12(fp)
 3242c20:	1000028d 	sth	zero,10(r2)
   hdrlen = ip_hlen(pip);
 3242c24:	e0bffd17 	ldw	r2,-12(fp)
 3242c28:	10800003 	ldbu	r2,0(r2)
 3242c2c:	10803fcc 	andi	r2,r2,255
 3242c30:	108003cc 	andi	r2,r2,15
 3242c34:	1085883a 	add	r2,r2,r2
 3242c38:	1085883a 	add	r2,r2,r2
 3242c3c:	e0bffa15 	stw	r2,-24(fp)
   tempsum = ~cksum(pip, hdrlen >> 1);
 3242c40:	e0bffa17 	ldw	r2,-24(fp)
 3242c44:	100ad07a 	srli	r5,r2,1
 3242c48:	e13ffd17 	ldw	r4,-12(fp)
 3242c4c:	3225d5c0 	call	3225d5c <cksum>
 3242c50:	0084303a 	nor	r2,zero,r2
 3242c54:	e0bffc0d 	sth	r2,-16(fp)

   if (csum != tempsum)
 3242c58:	e0fffc8b 	ldhu	r3,-14(fp)
 3242c5c:	e0bffc0b 	ldhu	r2,-16(fp)
 3242c60:	18802a26 	beq	r3,r2,3242d0c <ip_rcv+0x378>
   {
      pip->ip_chksum = csum;
 3242c64:	e0fffd17 	ldw	r3,-12(fp)
 3242c68:	e0bffc8b 	ldhu	r2,-14(fp)
 3242c6c:	1880028d 	sth	r2,10(r3)
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 3242c70:	0080c974 	movhi	r2,805
 3242c74:	10931c04 	addi	r2,r2,19568
 3242c78:	10800017 	ldw	r2,0(r2)
 3242c7c:	1081000c 	andi	r2,r2,1024
 3242c80:	1005003a 	cmpeq	r2,r2,zero
 3242c84:	1000111e 	bne	r2,zero,3242ccc <ip_rcv+0x338>
 3242c88:	0080c974 	movhi	r2,805
 3242c8c:	10931c04 	addi	r2,r2,19568
 3242c90:	10800017 	ldw	r2,0(r2)
 3242c94:	1080800c 	andi	r2,r2,512
 3242c98:	1005003a 	cmpeq	r2,r2,zero
 3242c9c:	10000b1e 	bne	r2,zero,3242ccc <ip_rcv+0x338>
      {
         dprintf("ip_rcv: bad xsum\n");
 3242ca0:	0100c974 	movhi	r4,805
 3242ca4:	213ffa04 	addi	r4,r4,-24
 3242ca8:	32071080 	call	3207108 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 3242cac:	0080c974 	movhi	r2,805
 3242cb0:	10931c04 	addi	r2,r2,19568
 3242cb4:	10800017 	ldw	r2,0(r2)
 3242cb8:	1080008c 	andi	r2,r2,2
 3242cbc:	1005003a 	cmpeq	r2,r2,zero
 3242cc0:	1000021e 	bne	r2,zero,3242ccc <ip_rcv+0x338>
 3242cc4:	e13ffe17 	ldw	r4,-8(fp)
 3242cc8:	324059c0 	call	324059c <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 3242ccc:	0080c9b4 	movhi	r2,806
 3242cd0:	10b54b04 	addi	r2,r2,-10964
 3242cd4:	10800317 	ldw	r2,12(r2)
 3242cd8:	10c00044 	addi	r3,r2,1
 3242cdc:	0080c9b4 	movhi	r2,806
 3242ce0:	10b54b04 	addi	r2,r2,-10964
 3242ce4:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 3242ce8:	01000084 	movi	r4,2
 3242cec:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(p);
 3242cf0:	e13ffe17 	ldw	r4,-8(fp)
 3242cf4:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3242cf8:	01000084 	movi	r4,2
 3242cfc:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 3242d00:	00bff804 	movi	r2,-32
 3242d04:	e0bfff15 	stw	r2,-4(fp)
 3242d08:	00001b06 	br	3242d78 <ip_rcv+0x3e4>
   }

   pip->ip_chksum = csum;
 3242d0c:	e0fffd17 	ldw	r3,-12(fp)
 3242d10:	e0bffc8b 	ldhu	r2,-14(fp)
 3242d14:	1880028d 	sth	r2,10(r3)
#endif

    /* start off by assuming that we will only process the "current" packet;
     * these values may get overwritten by the NAT module if it returns
     * more than one packet back to this function (ip_rcv ()) */
    num_pkts = 1;
 3242d18:	00800044 	movi	r2,1
 3242d1c:	e0bff80d 	sth	r2,-32(fp)
    pktp = &p;
 3242d20:	e0bffe04 	addi	r2,fp,-8
 3242d24:	e0bff715 	stw	r2,-36(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 3242d28:	e03ff605 	stb	zero,-40(fp)
 3242d2c:	00000c06 	br	3242d60 <ip_rcv+0x3cc>
   {
      rcvrc = ip_rcv_phase2 (*(pktp + i));
 3242d30:	e0bff603 	ldbu	r2,-40(fp)
 3242d34:	1085883a 	add	r2,r2,r2
 3242d38:	1085883a 	add	r2,r2,r2
 3242d3c:	1007883a 	mov	r3,r2
 3242d40:	e0bff717 	ldw	r2,-36(fp)
 3242d44:	1885883a 	add	r2,r3,r2
 3242d48:	11000017 	ldw	r4,0(r2)
 3242d4c:	3242d940 	call	3242d94 <ip_rcv_phase2>
 3242d50:	e0bff515 	stw	r2,-44(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 3242d54:	e0bff603 	ldbu	r2,-40(fp)
 3242d58:	10800044 	addi	r2,r2,1
 3242d5c:	e0bff605 	stb	r2,-40(fp)
 3242d60:	e0bff603 	ldbu	r2,-40(fp)
 3242d64:	10ffffcc 	andi	r3,r2,65535
 3242d68:	e0bff80b 	ldhu	r2,-32(fp)
 3242d6c:	18bff036 	bltu	r3,r2,3242d30 <ip_rcv+0x39c>
   if (pktp != &p) nat_free (pktp);
#endif /* NATRT */

   /* when multiple packets are processed in the loop above, the return code
    * contains the return code for the last packet */
   return rcvrc;
 3242d70:	e0bff517 	ldw	r2,-44(fp)
 3242d74:	e0bfff15 	stw	r2,-4(fp)
 3242d78:	e0bfff17 	ldw	r2,-4(fp)
}
 3242d7c:	e037883a 	mov	sp,fp
 3242d80:	dfc00217 	ldw	ra,8(sp)
 3242d84:	df000117 	ldw	fp,4(sp)
 3242d88:	dc000017 	ldw	r16,0(sp)
 3242d8c:	dec00304 	addi	sp,sp,12
 3242d90:	f800283a 	ret

03242d94 <ip_rcv_phase2>:


int ip_rcv_phase2 (PACKET p)
{
 3242d94:	defff404 	addi	sp,sp,-48
 3242d98:	dfc00b15 	stw	ra,44(sp)
 3242d9c:	df000a15 	stw	fp,40(sp)
 3242da0:	df000a04 	addi	fp,sp,40
 3242da4:	e13ffe15 	stw	r4,-8(fp)

   struct ip * pip;     /* the internet header */
   NET nt;
   unsigned short tempsum;

   pip = ip_head(p);
 3242da8:	e0bffe17 	ldw	r2,-8(fp)
 3242dac:	10800317 	ldw	r2,12(r2)
 3242db0:	e0bffc15 	stw	r2,-16(fp)
   nt = p->net;      /* which interface it came in on */
 3242db4:	e0bffe17 	ldw	r2,-8(fp)
 3242db8:	10800617 	ldw	r2,24(r2)
 3242dbc:	e0bffb15 	stw	r2,-20(fp)

#ifdef IP_MULTICAST

   if (IN_MULTICAST(ntohl(pip->ip_dest))) 
 3242dc0:	e0bffc17 	ldw	r2,-16(fp)
 3242dc4:	10800417 	ldw	r2,16(r2)
 3242dc8:	1004d63a 	srli	r2,r2,24
 3242dcc:	10c03fcc 	andi	r3,r2,255
 3242dd0:	e0bffc17 	ldw	r2,-16(fp)
 3242dd4:	10800417 	ldw	r2,16(r2)
 3242dd8:	1004d23a 	srli	r2,r2,8
 3242ddc:	10bfc00c 	andi	r2,r2,65280
 3242de0:	1886b03a 	or	r3,r3,r2
 3242de4:	e0bffc17 	ldw	r2,-16(fp)
 3242de8:	10800417 	ldw	r2,16(r2)
 3242dec:	10bfc00c 	andi	r2,r2,65280
 3242df0:	1004923a 	slli	r2,r2,8
 3242df4:	1886b03a 	or	r3,r3,r2
 3242df8:	e0bffc17 	ldw	r2,-16(fp)
 3242dfc:	10800417 	ldw	r2,16(r2)
 3242e00:	10803fcc 	andi	r2,r2,255
 3242e04:	1004963a 	slli	r2,r2,24
 3242e08:	1884b03a 	or	r2,r3,r2
 3242e0c:	10fc002c 	andhi	r3,r2,61440
 3242e10:	00b80034 	movhi	r2,57344
 3242e14:	1880181e 	bne	r3,r2,3242e78 <ip_rcv_phase2+0xe4>
      struct in_multi * inm;
      /*
       * See if we belong to the destination multicast group on the
       * arrival interface.
       */
      inm = lookup_mcast(pip->ip_dest, nt);
 3242e18:	e0bffc17 	ldw	r2,-16(fp)
 3242e1c:	11000417 	ldw	r4,16(r2)
 3242e20:	e17ffb17 	ldw	r5,-20(fp)
 3242e24:	3243a500 	call	3243a50 <lookup_mcast>
 3242e28:	e0bff915 	stw	r2,-28(fp)
      if (inm == NULL) 
 3242e2c:	e0bff917 	ldw	r2,-28(fp)
 3242e30:	1004c03a 	cmpne	r2,r2,zero
 3242e34:	10010d1e 	bne	r2,zero,324326c <ip_rcv_phase2+0x4d8>
      {
         ip_mib.ipOutNoRoutes++;
 3242e38:	0080c9b4 	movhi	r2,806
 3242e3c:	10b54b04 	addi	r2,r2,-10964
 3242e40:	10800b17 	ldw	r2,44(r2)
 3242e44:	10c00044 	addi	r3,r2,1
 3242e48:	0080c9b4 	movhi	r2,806
 3242e4c:	10b54b04 	addi	r2,r2,-10964
 3242e50:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 3242e54:	01000084 	movi	r4,2
 3242e58:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pk_free(p);
 3242e5c:	e13ffe17 	ldw	r4,-8(fp)
 3242e60:	322a6400 	call	322a640 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3242e64:	01000084 	movi	r4,2
 3242e68:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
 3242e6c:	00800084 	movi	r2,2
 3242e70:	e0bfff15 	stw	r2,-4(fp)
 3242e74:	00014406 	br	3243388 <ip_rcv_phase2+0x5f4>
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 3242e78:	e0bffc17 	ldw	r2,-16(fp)
 3242e7c:	10c00417 	ldw	r3,16(r2)
 3242e80:	e0bffb17 	ldw	r2,-20(fp)
 3242e84:	10800a17 	ldw	r2,40(r2)
 3242e88:	1880f826 	beq	r3,r2,324326c <ip_rcv_phase2+0x4d8>
 3242e8c:	e0bffc17 	ldw	r2,-16(fp)
 3242e90:	10800417 	ldw	r2,16(r2)
 3242e94:	10bfffe0 	cmpeqi	r2,r2,-1
 3242e98:	1000f41e 	bne	r2,zero,324326c <ip_rcv_phase2+0x4d8>
 3242e9c:	e0bffc17 	ldw	r2,-16(fp)
 3242ea0:	10c00417 	ldw	r3,16(r2)
 3242ea4:	e0bffb17 	ldw	r2,-20(fp)
 3242ea8:	10800e17 	ldw	r2,56(r2)
 3242eac:	1880ef26 	beq	r3,r2,324326c <ip_rcv_phase2+0x4d8>
 3242eb0:	e0bffc17 	ldw	r2,-16(fp)
 3242eb4:	10c00417 	ldw	r3,16(r2)
 3242eb8:	e0bffb17 	ldw	r2,-20(fp)
 3242ebc:	10800f17 	ldw	r2,60(r2)
 3242ec0:	1880ea26 	beq	r3,r2,324326c <ip_rcv_phase2+0x4d8>
 3242ec4:	e0bffc17 	ldw	r2,-16(fp)
 3242ec8:	10c00417 	ldw	r3,16(r2)
 3242ecc:	e0bffb17 	ldw	r2,-20(fp)
 3242ed0:	10801017 	ldw	r2,64(r2)
 3242ed4:	1880e526 	beq	r3,r2,324326c <ip_rcv_phase2+0x4d8>
 3242ed8:	e0bffb17 	ldw	r2,-20(fp)
 3242edc:	10c00a17 	ldw	r3,40(r2)
 3242ee0:	e0bffb17 	ldw	r2,-20(fp)
 3242ee4:	10800c17 	ldw	r2,48(r2)
 3242ee8:	0084303a 	nor	r2,zero,r2
 3242eec:	1884703a 	and	r2,r3,r2
 3242ef0:	1005003a 	cmpeq	r2,r2,zero
 3242ef4:	1000dd1e 	bne	r2,zero,324326c <ip_rcv_phase2+0x4d8>
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 3242ef8:	0080c974 	movhi	r2,805
 3242efc:	10931c04 	addi	r2,r2,19568
 3242f00:	10800017 	ldw	r2,0(r2)
 3242f04:	1081000c 	andi	r2,r2,1024
 3242f08:	1005003a 	cmpeq	r2,r2,zero
 3242f0c:	1000181e 	bne	r2,zero,3242f70 <ip_rcv_phase2+0x1dc>
 3242f10:	0080c974 	movhi	r2,805
 3242f14:	10931c04 	addi	r2,r2,19568
 3242f18:	10800017 	ldw	r2,0(r2)
 3242f1c:	1080800c 	andi	r2,r2,512
 3242f20:	1005003a 	cmpeq	r2,r2,zero
 3242f24:	1000121e 	bne	r2,zero,3242f70 <ip_rcv_phase2+0x1dc>
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 3242f28:	e0bffc17 	ldw	r2,-16(fp)
 3242f2c:	10800417 	ldw	r2,16(r2)
 3242f30:	11403fcc 	andi	r5,r2,255
 3242f34:	e0bffc17 	ldw	r2,-16(fp)
 3242f38:	10800417 	ldw	r2,16(r2)
 3242f3c:	1004d23a 	srli	r2,r2,8
 3242f40:	11803fcc 	andi	r6,r2,255
 3242f44:	e0bffc17 	ldw	r2,-16(fp)
 3242f48:	10800417 	ldw	r2,16(r2)
 3242f4c:	1004d43a 	srli	r2,r2,16
 3242f50:	11c03fcc 	andi	r7,r2,255
 3242f54:	e0bffc17 	ldw	r2,-16(fp)
 3242f58:	10800417 	ldw	r2,16(r2)
 3242f5c:	1004d63a 	srli	r2,r2,24
 3242f60:	d8800015 	stw	r2,0(sp)
 3242f64:	0100c974 	movhi	r4,805
 3242f68:	213fff04 	addi	r4,r4,-4
 3242f6c:	3206de00 	call	3206de0 <printf>

#ifdef IP_ROUTING    /* if multi-homed router, try to route */
      /* Do routing only if ipForwarding is enabled in the IP MIB. This
       * is the switch for routing whether SNMP is used or not.
       */
      if (ip_mib.ipForwarding == 2)
 3242f70:	0080c9b4 	movhi	r2,806
 3242f74:	10b54b04 	addi	r2,r2,-10964
 3242f78:	10800017 	ldw	r2,0(r2)
 3242f7c:	10800098 	cmpnei	r2,r2,2
 3242f80:	1000101e 	bne	r2,zero,3242fc4 <ip_rcv_phase2+0x230>
      {
         ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 3242f84:	0080c9b4 	movhi	r2,806
 3242f88:	10b54b04 	addi	r2,r2,-10964
 3242f8c:	10800a17 	ldw	r2,40(r2)
 3242f90:	10c00044 	addi	r3,r2,1
 3242f94:	0080c9b4 	movhi	r2,806
 3242f98:	10b54b04 	addi	r2,r2,-10964
 3242f9c:	10c00a15 	stw	r3,40(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 3242fa0:	01000084 	movi	r4,2
 3242fa4:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
         pk_free(p);
 3242fa8:	e13ffe17 	ldw	r4,-8(fp)
 3242fac:	322a6400 	call	322a640 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3242fb0:	01000084 	movi	r4,2
 3242fb4:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_NO_ROUTE;
 3242fb8:	00bff7c4 	movi	r2,-33
 3242fbc:	e0bfff15 	stw	r2,-4(fp)
 3242fc0:	0000f106 	br	3243388 <ip_rcv_phase2+0x5f4>
         NET outnet;
#ifdef IP_FRAGMENTS
         int err;
#endif

         ip_mib.ipForwDatagrams++;  /* Count MIB-2 route attempts here */
 3242fc4:	0080c9b4 	movhi	r2,806
 3242fc8:	10b54b04 	addi	r2,r2,-10964
 3242fcc:	10800517 	ldw	r2,20(r2)
 3242fd0:	10c00044 	addi	r3,r2,1
 3242fd4:	0080c9b4 	movhi	r2,806
 3242fd8:	10b54b04 	addi	r2,r2,-10964
 3242fdc:	10c00515 	stw	r3,20(r2)
         if (pip->ip_time <= 1)     /* Time to Live (hopcount) expired? */
 3242fe0:	e0bffc17 	ldw	r2,-16(fp)
 3242fe4:	10800203 	ldbu	r2,8(r2)
 3242fe8:	10803fcc 	andi	r2,r2,255
 3242fec:	108000a8 	cmpgeui	r2,r2,2
 3242ff0:	10001b1e 	bne	r2,zero,3243060 <ip_rcv_phase2+0x2cc>
         {
            ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 3242ff4:	0080c9b4 	movhi	r2,806
 3242ff8:	10b54b04 	addi	r2,r2,-10964
 3242ffc:	10800a17 	ldw	r2,40(r2)
 3243000:	10c00044 	addi	r3,r2,1
 3243004:	0080c9b4 	movhi	r2,806
 3243008:	10b54b04 	addi	r2,r2,-10964
 324300c:	10c00a15 	stw	r3,40(r2)
#ifdef FULL_ICMP
            icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, (TIMEX <<8), p->net);
 3243010:	e0bffc17 	ldw	r2,-16(fp)
 3243014:	11000317 	ldw	r4,12(r2)
 3243018:	e0bffe17 	ldw	r2,-8(fp)
 324301c:	10800617 	ldw	r2,24(r2)
 3243020:	11400a17 	ldw	r5,40(r2)
 3243024:	e0bffe17 	ldw	r2,-8(fp)
 3243028:	10800617 	ldw	r2,24(r2)
 324302c:	d8800015 	stw	r2,0(sp)
 3243030:	e1bffc17 	ldw	r6,-16(fp)
 3243034:	01c2c004 	movi	r7,2816
 3243038:	324b5400 	call	324b540 <icmp_destun>
#endif   /* FULL_ICMP */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 324303c:	01000084 	movi	r4,2
 3243040:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
            pk_free(p);
 3243044:	e13ffe17 	ldw	r4,-8(fp)
 3243048:	322a6400 	call	322a640 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324304c:	01000084 	movi	r4,2
 3243050:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 3243054:	00bff7c4 	movi	r2,-33
 3243058:	e0bfff15 	stw	r2,-4(fp)
 324305c:	0000ca06 	br	3243388 <ip_rcv_phase2+0x5f4>
         }

         p->fhost = pip->ip_dest;   /* set packet's target IP in net endian */
 3243060:	e0bffc17 	ldw	r2,-16(fp)
 3243064:	10c00417 	ldw	r3,16(r2)
 3243068:	e0bffe17 	ldw	r2,-8(fp)
 324306c:	10c00715 	stw	r3,28(r2)
         if ((outnet = iproute(p->fhost, &firsthop)) == NULL)  /* find route */
 3243070:	e0bffe17 	ldw	r2,-8(fp)
 3243074:	11000717 	ldw	r4,28(r2)
 3243078:	e17ffd04 	addi	r5,fp,-12
 324307c:	32408540 	call	3240854 <iproute>
 3243080:	e0bff815 	stw	r2,-32(fp)
 3243084:	e0bff817 	ldw	r2,-32(fp)
 3243088:	1004c03a 	cmpne	r2,r2,zero
 324308c:	1000101e 	bne	r2,zero,32430d0 <ip_rcv_phase2+0x33c>
         {
            ip_mib.ipOutNoRoutes++; /* count unroutable pkts */
 3243090:	0080c9b4 	movhi	r2,806
 3243094:	10b54b04 	addi	r2,r2,-10964
 3243098:	10800b17 	ldw	r2,44(r2)
 324309c:	10c00044 	addi	r3,r2,1
 32430a0:	0080c9b4 	movhi	r2,806
 32430a4:	10b54b04 	addi	r2,r2,-10964
 32430a8:	10c00b15 	stw	r3,44(r2)
            LOCK_NET_RESOURCE(FREEQ_RESID);
 32430ac:	01000084 	movi	r4,2
 32430b0:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
            pk_free(p);
 32430b4:	e13ffe17 	ldw	r4,-8(fp)
 32430b8:	322a6400 	call	322a640 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32430bc:	01000084 	movi	r4,2
 32430c0:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 32430c4:	00bff7c4 	movi	r2,-33
 32430c8:	e0bfff15 	stw	r2,-4(fp)
 32430cc:	0000ae06 	br	3243388 <ip_rcv_phase2+0x5f4>
         /* Check to see if the packet was is addressed to one of our IP
          * addresses other than the interface it was received on. If so,
          * routing should have returned that interface and we can trap this
          * situation by checking the interfaces IP address.
          */
         if(pip->ip_dest == outnet->n_ipaddr)
 32430d0:	e0bffc17 	ldw	r2,-16(fp)
 32430d4:	10c00417 	ldw	r3,16(r2)
 32430d8:	e0bff817 	ldw	r2,-32(fp)
 32430dc:	10800a17 	ldw	r2,40(r2)
 32430e0:	18806226 	beq	r3,r2,324326c <ip_rcv_phase2+0x4d8>
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 32430e4:	e0bffc17 	ldw	r2,-16(fp)
 32430e8:	10c00417 	ldw	r3,16(r2)
 32430ec:	e0bff817 	ldw	r2,-32(fp)
 32430f0:	10800e17 	ldw	r2,56(r2)
 32430f4:	18805d26 	beq	r3,r2,324326c <ip_rcv_phase2+0x4d8>
 32430f8:	e0bffc17 	ldw	r2,-16(fp)
 32430fc:	10c00417 	ldw	r3,16(r2)
 3243100:	e0bffe17 	ldw	r2,-8(fp)
 3243104:	10800617 	ldw	r2,24(r2)
 3243108:	10800e17 	ldw	r2,56(r2)
 324310c:	18805726 	beq	r3,r2,324326c <ip_rcv_phase2+0x4d8>
         {
            goto ours;            
         }

         /* Routed OK, prepare to send */
         p->net = outnet;           /* set iface to send on */
 3243110:	e0fffe17 	ldw	r3,-8(fp)
 3243114:	e0bff817 	ldw	r2,-32(fp)
 3243118:	18800615 	stw	r2,24(r3)
            }
         }
#endif   /* IPSEC */

         /* see if packet is too big for media of dest net */
         if ((p->nb_plen + p->net->n_lnh) > (unsigned)outnet->n_mtu)
 324311c:	e0bffe17 	ldw	r2,-8(fp)
 3243120:	10c00417 	ldw	r3,16(r2)
 3243124:	e0bffe17 	ldw	r2,-8(fp)
 3243128:	10800617 	ldw	r2,24(r2)
 324312c:	10800817 	ldw	r2,32(r2)
 3243130:	1887883a 	add	r3,r3,r2
 3243134:	e0bff817 	ldw	r2,-32(fp)
 3243138:	10800917 	ldw	r2,36(r2)
 324313c:	10c0372e 	bgeu	r2,r3,324321c <ip_rcv_phase2+0x488>
         {
#ifdef IP_FRAGMENTS
            /* see if we're not supposed to fragment it */
            if (ntohs(pip->ip_flgs_foff) & IP_FLG_DF)
 3243140:	e0bffc17 	ldw	r2,-16(fp)
 3243144:	1080018b 	ldhu	r2,6(r2)
 3243148:	10bfffcc 	andi	r2,r2,65535
 324314c:	1004d23a 	srli	r2,r2,8
 3243150:	10bfffcc 	andi	r2,r2,65535
 3243154:	10c03fcc 	andi	r3,r2,255
 3243158:	e0bffc17 	ldw	r2,-16(fp)
 324315c:	1080018b 	ldhu	r2,6(r2)
 3243160:	10bfffcc 	andi	r2,r2,65535
 3243164:	1004923a 	slli	r2,r2,8
 3243168:	10bfc00c 	andi	r2,r2,65280
 324316c:	1884b03a 	or	r2,r3,r2
 3243170:	1090000c 	andi	r2,r2,16384
 3243174:	1005003a 	cmpeq	r2,r2,zero
 3243178:	10001b1e 	bne	r2,zero,32431e8 <ip_rcv_phase2+0x454>
            {
#ifdef FULL_ICMP
               icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 324317c:	e0bffc17 	ldw	r2,-16(fp)
 3243180:	11000317 	ldw	r4,12(r2)
 3243184:	e0bffe17 	ldw	r2,-8(fp)
 3243188:	10800617 	ldw	r2,24(r2)
 324318c:	11400a17 	ldw	r5,40(r2)
 3243190:	e0bffe17 	ldw	r2,-8(fp)
 3243194:	10800617 	ldw	r2,24(r2)
 3243198:	d8800015 	stw	r2,0(sp)
 324319c:	e1bffc17 	ldw	r6,-16(fp)
 32431a0:	01c00104 	movi	r7,4
 32431a4:	324b5400 	call	324b540 <icmp_destun>
#endif   /* FULL_ICMP */
               ip_mib.ipFragFails++;
 32431a8:	0080c9b4 	movhi	r2,806
 32431ac:	10b54b04 	addi	r2,r2,-10964
 32431b0:	10801117 	ldw	r2,68(r2)
 32431b4:	10c00044 	addi	r3,r2,1
 32431b8:	0080c9b4 	movhi	r2,806
 32431bc:	10b54b04 	addi	r2,r2,-10964
 32431c0:	10c01115 	stw	r3,68(r2)
               LOCK_NET_RESOURCE(FREEQ_RESID);
 32431c4:	01000084 	movi	r4,2
 32431c8:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
               pk_free(p);
 32431cc:	e13ffe17 	ldw	r4,-8(fp)
 32431d0:	322a6400 	call	322a640 <pk_free>
               UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32431d4:	01000084 	movi	r4,2
 32431d8:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
               IN_PROFILER(PF_IP, PF_EXIT);
               return ENP_LOGIC;
 32431dc:	00bffd44 	movi	r2,-11
 32431e0:	e0bfff15 	stw	r2,-4(fp)
 32431e4:	00006806 	br	3243388 <ip_rcv_phase2+0x5f4>
            }

            /* fall to here if we're going to fragment it. */
            pip->ip_time--;            /* datagram's hop count */
 32431e8:	e0bffc17 	ldw	r2,-16(fp)
 32431ec:	10800203 	ldbu	r2,8(r2)
 32431f0:	10bfffc4 	addi	r2,r2,-1
 32431f4:	1007883a 	mov	r3,r2
 32431f8:	e0bffc17 	ldw	r2,-16(fp)
 32431fc:	10c00205 	stb	r3,8(r2)
            err = ip_fragment(p, firsthop);
 3243200:	e17ffd17 	ldw	r5,-12(fp)
 3243204:	e13ffe17 	ldw	r4,-8(fp)
 3243208:	323fecc0 	call	323fecc <ip_fragment>
 324320c:	e0bff715 	stw	r2,-36(fp)
            IN_PROFILER(PF_IP, PF_EXIT);
            return(err);
 3243210:	e0bff717 	ldw	r2,-36(fp)
 3243214:	e0bfff15 	stw	r2,-4(fp)
 3243218:	00005b06 	br	3243388 <ip_rcv_phase2+0x5f4>
            pk_free(p);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
            return ENP_LOGIC;
#endif   /* IP_FRAGMENTS */
         }
         pip->ip_time--;            /* datagram's hop count */
 324321c:	e0bffc17 	ldw	r2,-16(fp)
 3243220:	10800203 	ldbu	r2,8(r2)
 3243224:	10bfffc4 	addi	r2,r2,-1
 3243228:	1007883a 	mov	r3,r2
 324322c:	e0bffc17 	ldw	r2,-16(fp)
 3243230:	10c00205 	stb	r3,8(r2)
         pip->ip_chksum = IPXSUM;   /* clear checksum field for summing */
 3243234:	e0bffc17 	ldw	r2,-16(fp)
 3243238:	1000028d 	sth	zero,10(r2)
         pip->ip_chksum = ~cksum(pip, 10);   /* new xsum */
 324323c:	e13ffc17 	ldw	r4,-16(fp)
 3243240:	01400284 	movi	r5,10
 3243244:	3225d5c0 	call	3225d5c <cksum>
 3243248:	0084303a 	nor	r2,zero,r2
 324324c:	1007883a 	mov	r3,r2
 3243250:	e0bffc17 	ldw	r2,-16(fp)
 3243254:	10c0028d 	sth	r3,10(r2)
         IN_PROFILER(PF_IP, PF_EXIT);
#ifdef RF_SIMULATION
         if(rfsim_routing)
            return(rfsim_send(p, firsthop));
#endif   /* RF_SIMULATION */
         return(ip2mac(p, firsthop));
 3243258:	e17ffd17 	ldw	r5,-12(fp)
 324325c:	e13ffe17 	ldw	r4,-8(fp)
 3243260:	3223af80 	call	3223af8 <ip2mac>
 3243264:	e0bfff15 	stw	r2,-4(fp)
 3243268:	00004706 	br	3243388 <ip_rcv_phase2+0x5f4>
#if defined (IP_MULTICAST) || defined (IP_ROUTING)
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
 324326c:	e0bffc17 	ldw	r2,-16(fp)
 3243270:	1080018b 	ldhu	r2,6(r2)
 3243274:	10bfffcc 	andi	r2,r2,65535
 3243278:	1004d23a 	srli	r2,r2,8
 324327c:	10803fcc 	andi	r2,r2,255
 3243280:	1009883a 	mov	r4,r2
 3243284:	e0bffc17 	ldw	r2,-16(fp)
 3243288:	1080018b 	ldhu	r2,6(r2)
 324328c:	10bfffcc 	andi	r2,r2,65535
 3243290:	1004923a 	slli	r2,r2,8
 3243294:	1007883a 	mov	r3,r2
 3243298:	00bfc004 	movi	r2,-256
 324329c:	1884703a 	and	r2,r3,r2
 32432a0:	2084b03a 	or	r2,r4,r2
 32432a4:	e0bffa0d 	sth	r2,-24(fp)
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 32432a8:	e0bffa0b 	ldhu	r2,-24(fp)
 32432ac:	1088000c 	andi	r2,r2,8192
 32432b0:	1004c03a 	cmpne	r2,r2,zero
 32432b4:	1000061e 	bne	r2,zero,32432d0 <ip_rcv_phase2+0x53c>
 32432b8:	e0fffa0b 	ldhu	r3,-24(fp)
 32432bc:	00bffff4 	movhi	r2,65535
 32432c0:	1087ffc4 	addi	r2,r2,8191
 32432c4:	1884703a 	and	r2,r3,r2
 32432c8:	1005003a 	cmpeq	r2,r2,zero
 32432cc:	10002b1e 	bne	r2,zero,324337c <ip_rcv_phase2+0x5e8>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 32432d0:	0080c974 	movhi	r2,805
 32432d4:	10931c04 	addi	r2,r2,19568
 32432d8:	10800017 	ldw	r2,0(r2)
 32432dc:	1081000c 	andi	r2,r2,1024
 32432e0:	1005003a 	cmpeq	r2,r2,zero
 32432e4:	10001a1e 	bne	r2,zero,3243350 <ip_rcv_phase2+0x5bc>
 32432e8:	0080c974 	movhi	r2,805
 32432ec:	10931c04 	addi	r2,r2,19568
 32432f0:	10800017 	ldw	r2,0(r2)
 32432f4:	1080800c 	andi	r2,r2,512
 32432f8:	1005003a 	cmpeq	r2,r2,zero
 32432fc:	1000141e 	bne	r2,zero,3243350 <ip_rcv_phase2+0x5bc>
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 3243300:	e0bffc17 	ldw	r2,-16(fp)
 3243304:	10800317 	ldw	r2,12(r2)
 3243308:	11403fcc 	andi	r5,r2,255
 324330c:	e0bffc17 	ldw	r2,-16(fp)
 3243310:	10800317 	ldw	r2,12(r2)
 3243314:	1004d23a 	srli	r2,r2,8
 3243318:	11803fcc 	andi	r6,r2,255
 324331c:	e0bffc17 	ldw	r2,-16(fp)
 3243320:	10800317 	ldw	r2,12(r2)
 3243324:	1004d43a 	srli	r2,r2,16
 3243328:	11c03fcc 	andi	r7,r2,255
 324332c:	e0bffc17 	ldw	r2,-16(fp)
 3243330:	10800317 	ldw	r2,12(r2)
 3243334:	1004d63a 	srli	r2,r2,24
 3243338:	d8800015 	stw	r2,0(sp)
 324333c:	0100c974 	movhi	r4,805
 3243340:	21000b04 	addi	r4,r4,44
 3243344:	3206de00 	call	3206de0 <printf>
          PUSH_IPADDR(pip->ip_src));
         ip_dump(p);
 3243348:	e13ffe17 	ldw	r4,-8(fp)
 324334c:	324059c0 	call	324059c <ip_dump>
      }
#endif
      ip_mib.ipReasmReqds++;     /* got a reassemble request; ie a frag */
 3243350:	0080c9b4 	movhi	r2,806
 3243354:	10b54b04 	addi	r2,r2,-10964
 3243358:	10800d17 	ldw	r2,52(r2)
 324335c:	10c00044 	addi	r3,r2,1
 3243360:	0080c9b4 	movhi	r2,806
 3243364:	10b54b04 	addi	r2,r2,-10964
 3243368:	10c00d15 	stw	r3,52(r2)
#ifdef IP_FRAGMENTS
      return(ip_reassm(p));
 324336c:	e13ffe17 	ldw	r4,-8(fp)
 3243370:	32412740 	call	3241274 <ip_reassm>
 3243374:	e0bfff15 	stw	r2,-4(fp)
 3243378:	00000306 	br	3243388 <ip_rcv_phase2+0x5f4>
   {
      return ENP_LOGIC;
   }
#endif /* IPSEC */

   return(ip_demux(p));    /* demux to correct to upper layer */
 324337c:	e13ffe17 	ldw	r4,-8(fp)
 3243380:	32433a00 	call	32433a0 <ip_demux>
 3243384:	e0bfff15 	stw	r2,-4(fp)
 3243388:	e0bfff17 	ldw	r2,-4(fp)
}
 324338c:	e037883a 	mov	sp,fp
 3243390:	dfc00117 	ldw	ra,4(sp)
 3243394:	df000017 	ldw	fp,0(sp)
 3243398:	dec00204 	addi	sp,sp,8
 324339c:	f800283a 	ret

032433a0 <ip_demux>:
 * RETURNS: Same return values as ip_rcv(). 
 */

int
ip_demux(PACKET p)
{
 32433a0:	defff704 	addi	sp,sp,-36
 32433a4:	dfc00815 	stw	ra,32(sp)
 32433a8:	df000715 	stw	fp,28(sp)
 32433ac:	df000704 	addi	fp,sp,28
 32433b0:	e13ffd15 	stw	r4,-12(fp)
   int   err;

   /* The packet is verified; the header is correct. Now we have
    * to demultiplex it among our internet connections.
    */
   pip = (struct ip *)(p->nb_prot);
 32433b4:	e0bffd17 	ldw	r2,-12(fp)
 32433b8:	10800317 	ldw	r2,12(r2)
 32433bc:	e0bffc15 	stw	r2,-16(fp)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
 32433c0:	e0bffc17 	ldw	r2,-16(fp)
 32433c4:	10800003 	ldbu	r2,0(r2)
 32433c8:	10803fcc 	andi	r2,r2,255
 32433cc:	10801160 	cmpeqi	r2,r2,69
 32433d0:	1000131e 	bne	r2,zero,3243420 <ip_demux+0x80>
   {
      if((pip->ip_ver_ihl < 0x45) ||
 32433d4:	e0bffc17 	ldw	r2,-16(fp)
 32433d8:	10800003 	ldbu	r2,0(r2)
 32433dc:	10803fcc 	andi	r2,r2,255
 32433e0:	10801170 	cmpltui	r2,r2,69
 32433e4:	1000051e 	bne	r2,zero,32433fc <ip_demux+0x5c>
 32433e8:	e0bffc17 	ldw	r2,-16(fp)
 32433ec:	10800003 	ldbu	r2,0(r2)
 32433f0:	10803fcc 	andi	r2,r2,255
 32433f4:	10801230 	cmpltui	r2,r2,72
 32433f8:	1000091e 	bne	r2,zero,3243420 <ip_demux+0x80>
         (pip->ip_ver_ihl > 0x47))
      {
         dprintf("ip_demux: bad IP type 0x%x\n", pip->ip_ver_ihl);
 32433fc:	e0bffc17 	ldw	r2,-16(fp)
 3243400:	10800003 	ldbu	r2,0(r2)
 3243404:	11403fcc 	andi	r5,r2,255
 3243408:	0100c974 	movhi	r4,805
 324340c:	21001404 	addi	r4,r4,80
 3243410:	3206de00 	call	3206de0 <printf>
         return ENP_LOGIC;
 3243414:	00bffd44 	movi	r2,-11
 3243418:	e0bfff15 	stw	r2,-4(fp)
 324341c:	0000e606 	br	32437b8 <ip_demux+0x418>

   /* for profiling purposes count the upper layers (UDP, ICMP) in the IP
    * profile bucket. TCP will insert it's own nested profile calls 
    */
   IN_PROFILER(PF_IP, PF_ENTRY);
   p->fhost = pip->ip_src;
 3243420:	e0bffc17 	ldw	r2,-16(fp)
 3243424:	10c00317 	ldw	r3,12(r2)
 3243428:	e0bffd17 	ldw	r2,-12(fp)
 324342c:	10c00715 	stw	r3,28(r2)

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 3243430:	0080c974 	movhi	r2,805
 3243434:	10931c04 	addi	r2,r2,19568
 3243438:	10800017 	ldw	r2,0(r2)
 324343c:	1081000c 	andi	r2,r2,1024
 3243440:	1005003a 	cmpeq	r2,r2,zero
 3243444:	1000241e 	bne	r2,zero,32434d8 <ip_demux+0x138>
 3243448:	0080c974 	movhi	r2,805
 324344c:	10931c04 	addi	r2,r2,19568
 3243450:	10800017 	ldw	r2,0(r2)
 3243454:	1080800c 	andi	r2,r2,512
 3243458:	1005003a 	cmpeq	r2,r2,zero
 324345c:	10001e1e 	bne	r2,zero,32434d8 <ip_demux+0x138>
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 3243460:	e0bffc17 	ldw	r2,-16(fp)
 3243464:	10800243 	ldbu	r2,9(r2)
 3243468:	11403fcc 	andi	r5,r2,255
 324346c:	e0bffc17 	ldw	r2,-16(fp)
 3243470:	10800317 	ldw	r2,12(r2)
 3243474:	11803fcc 	andi	r6,r2,255
 3243478:	e0bffc17 	ldw	r2,-16(fp)
 324347c:	10800317 	ldw	r2,12(r2)
 3243480:	1004d23a 	srli	r2,r2,8
 3243484:	11c03fcc 	andi	r7,r2,255
 3243488:	e0bffc17 	ldw	r2,-16(fp)
 324348c:	10800317 	ldw	r2,12(r2)
 3243490:	1004d43a 	srli	r2,r2,16
 3243494:	10c03fcc 	andi	r3,r2,255
 3243498:	e0bffc17 	ldw	r2,-16(fp)
 324349c:	10800317 	ldw	r2,12(r2)
 32434a0:	1004d63a 	srli	r2,r2,24
 32434a4:	d8c00015 	stw	r3,0(sp)
 32434a8:	d8800115 	stw	r2,4(sp)
 32434ac:	0100c974 	movhi	r4,805
 32434b0:	21001b04 	addi	r4,r4,108
 32434b4:	3206de00 	call	3206de0 <printf>
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
      if (NDEBUG & DUMP) ip_dump(p);
 32434b8:	0080c974 	movhi	r2,805
 32434bc:	10931c04 	addi	r2,r2,19568
 32434c0:	10800017 	ldw	r2,0(r2)
 32434c4:	1080008c 	andi	r2,r2,2
 32434c8:	1005003a 	cmpeq	r2,r2,zero
 32434cc:	1000021e 	bne	r2,zero,32434d8 <ip_demux+0x138>
 32434d0:	e13ffd17 	ldw	r4,-12(fp)
 32434d4:	324059c0 	call	324059c <ip_dump>
   }
#endif

   switch (pip->ip_prot)
 32434d8:	e0bffc17 	ldw	r2,-16(fp)
 32434dc:	10800243 	ldbu	r2,9(r2)
 32434e0:	10803fcc 	andi	r2,r2,255
 32434e4:	e0bffe15 	stw	r2,-8(fp)
 32434e8:	e0fffe17 	ldw	r3,-8(fp)
 32434ec:	188000a0 	cmpeqi	r2,r3,2
 32434f0:	1000241e 	bne	r2,zero,3243584 <ip_demux+0x1e4>
 32434f4:	e0fffe17 	ldw	r3,-8(fp)
 32434f8:	188000c8 	cmpgei	r2,r3,3
 32434fc:	1000041e 	bne	r2,zero,3243510 <ip_demux+0x170>
 3243500:	e0fffe17 	ldw	r3,-8(fp)
 3243504:	18800060 	cmpeqi	r2,r3,1
 3243508:	1000131e 	bne	r2,zero,3243558 <ip_demux+0x1b8>
 324350c:	00003306 	br	32435dc <ip_demux+0x23c>
 3243510:	e0fffe17 	ldw	r3,-8(fp)
 3243514:	188001a0 	cmpeqi	r2,r3,6
 3243518:	1000251e 	bne	r2,zero,32435b0 <ip_demux+0x210>
 324351c:	e0fffe17 	ldw	r3,-8(fp)
 3243520:	18800460 	cmpeqi	r2,r3,17
 3243524:	1000011e 	bne	r2,zero,324352c <ip_demux+0x18c>
 3243528:	00002c06 	br	32435dc <ip_demux+0x23c>
   {
   case UDP_PROT:
      ip_mib.ipInDelivers++;
 324352c:	0080c9b4 	movhi	r2,806
 3243530:	10b54b04 	addi	r2,r2,-10964
 3243534:	10800817 	ldw	r2,32(r2)
 3243538:	10c00044 	addi	r3,r2,1
 324353c:	0080c9b4 	movhi	r2,806
 3243540:	10b54b04 	addi	r2,r2,-10964
 3243544:	10c00815 	stw	r3,32(r2)
      err = udpdemux(p);
 3243548:	e13ffd17 	ldw	r4,-12(fp)
 324354c:	32447e40 	call	32447e4 <udpdemux>
 3243550:	e0bffb15 	stw	r2,-20(fp)
      break;
 3243554:	00002b06 	br	3243604 <ip_demux+0x264>
   case ICMP_PROT:
      ip_mib.ipInDelivers++;
 3243558:	0080c9b4 	movhi	r2,806
 324355c:	10b54b04 	addi	r2,r2,-10964
 3243560:	10800817 	ldw	r2,32(r2)
 3243564:	10c00044 	addi	r3,r2,1
 3243568:	0080c9b4 	movhi	r2,806
 324356c:	10b54b04 	addi	r2,r2,-10964
 3243570:	10c00815 	stw	r3,32(r2)
      err = icmprcv(p);
 3243574:	e13ffd17 	ldw	r4,-12(fp)
 3243578:	324a90c0 	call	324a90c <icmprcv>
 324357c:	e0bffb15 	stw	r2,-20(fp)
      break;
 3243580:	00002006 	br	3243604 <ip_demux+0x264>
#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   case IGMP_PROT:
      ip_mib.ipInDelivers++;
 3243584:	0080c9b4 	movhi	r2,806
 3243588:	10b54b04 	addi	r2,r2,-10964
 324358c:	10800817 	ldw	r2,32(r2)
 3243590:	10c00044 	addi	r3,r2,1
 3243594:	0080c9b4 	movhi	r2,806
 3243598:	10b54b04 	addi	r2,r2,-10964
 324359c:	10c00815 	stw	r3,32(r2)
      err = igmp_input(p);
 32435a0:	e13ffd17 	ldw	r4,-12(fp)
 32435a4:	32241fc0 	call	32241fc <igmp_input>
 32435a8:	e0bffb15 	stw	r2,-20(fp)
      break;
 32435ac:	00001506 	br	3243604 <ip_demux+0x264>
#endif   /* IP_MULTICAST and (IGMPv1 or IGMPv2) */
#ifdef INCLUDE_TCP
   case TCP_PROT:
      ip_mib.ipInDelivers++;
 32435b0:	0080c9b4 	movhi	r2,806
 32435b4:	10b54b04 	addi	r2,r2,-10964
 32435b8:	10800817 	ldw	r2,32(r2)
 32435bc:	10c00044 	addi	r3,r2,1
 32435c0:	0080c9b4 	movhi	r2,806
 32435c4:	10b54b04 	addi	r2,r2,-10964
 32435c8:	10c00815 	stw	r3,32(r2)
      err = tcp_rcv(p);
 32435cc:	e13ffd17 	ldw	r4,-12(fp)
 32435d0:	322c8140 	call	322c814 <tcp_rcv>
 32435d4:	e0bffb15 	stw	r2,-20(fp)
      break;
 32435d8:	00000a06 	br	3243604 <ip_demux+0x264>
      err = v6t_rcv(p);
      break;
#endif /* IPV6_TUNNEL */
   default: /* unknown upper protocol */
#ifdef IP_RAW
      ip_mib.ipInDelivers++;
 32435dc:	0080c9b4 	movhi	r2,806
 32435e0:	10b54b04 	addi	r2,r2,-10964
 32435e4:	10800817 	ldw	r2,32(r2)
 32435e8:	10c00044 	addi	r3,r2,1
 32435ec:	0080c9b4 	movhi	r2,806
 32435f0:	10b54b04 	addi	r2,r2,-10964
 32435f4:	10c00815 	stw	r3,32(r2)
      err = ip_raw_input(p);
 32435f8:	e13ffd17 	ldw	r4,-12(fp)
 32435fc:	3243d540 	call	3243d54 <ip_raw_input>
 3243600:	e0bffb15 	stw	r2,-20(fp)
#endif /* IP_RAW */
   }

   IN_PROFILER(PF_IP, PF_EXIT);

   if(err != ENP_PARAM)
 3243604:	e0bffb17 	ldw	r2,-20(fp)
 3243608:	10bffda0 	cmpeqi	r2,r2,-10
 324360c:	1000031e 	bne	r2,zero,324361c <ip_demux+0x27c>
   {
      return err;
 3243610:	e0bffb17 	ldw	r2,-20(fp)
 3243614:	e0bfff15 	stw	r2,-4(fp)
 3243618:	00006706 	br	32437b8 <ip_demux+0x418>

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 324361c:	e0bffc17 	ldw	r2,-16(fp)
 3243620:	10800417 	ldw	r2,16(r2)
 3243624:	10bfffe0 	cmpeqi	r2,r2,-1
 3243628:	1000541e 	bne	r2,zero,324377c <ip_demux+0x3dc>
 324362c:	e0bffc17 	ldw	r2,-16(fp)
 3243630:	10800417 	ldw	r2,16(r2)
 3243634:	1004d63a 	srli	r2,r2,24
 3243638:	10c03fcc 	andi	r3,r2,255
 324363c:	e0bffc17 	ldw	r2,-16(fp)
 3243640:	10800417 	ldw	r2,16(r2)
 3243644:	1004d23a 	srli	r2,r2,8
 3243648:	10bfc00c 	andi	r2,r2,65280
 324364c:	1886b03a 	or	r3,r3,r2
 3243650:	e0bffc17 	ldw	r2,-16(fp)
 3243654:	10800417 	ldw	r2,16(r2)
 3243658:	10bfc00c 	andi	r2,r2,65280
 324365c:	1004923a 	slli	r2,r2,8
 3243660:	1886b03a 	or	r3,r3,r2
 3243664:	e0bffc17 	ldw	r2,-16(fp)
 3243668:	10800417 	ldw	r2,16(r2)
 324366c:	10803fcc 	andi	r2,r2,255
 3243670:	1004963a 	slli	r2,r2,24
 3243674:	1884b03a 	or	r2,r3,r2
 3243678:	10fc002c 	andhi	r3,r2,61440
 324367c:	00b80034 	movhi	r2,57344
 3243680:	18803e26 	beq	r3,r2,324377c <ip_demux+0x3dc>
 3243684:	e0bffc17 	ldw	r2,-16(fp)
 3243688:	10c00417 	ldw	r3,16(r2)
 324368c:	e0bffd17 	ldw	r2,-12(fp)
 3243690:	10800617 	ldw	r2,24(r2)
 3243694:	10800e17 	ldw	r2,56(r2)
 3243698:	18803826 	beq	r3,r2,324377c <ip_demux+0x3dc>
 324369c:	e0bffc17 	ldw	r2,-16(fp)
 32436a0:	10c00417 	ldw	r3,16(r2)
 32436a4:	e0bffd17 	ldw	r2,-12(fp)
 32436a8:	10800617 	ldw	r2,24(r2)
 32436ac:	10800f17 	ldw	r2,60(r2)
 32436b0:	18803226 	beq	r3,r2,324377c <ip_demux+0x3dc>
 32436b4:	e0bffc17 	ldw	r2,-16(fp)
 32436b8:	10c00417 	ldw	r3,16(r2)
 32436bc:	e0bffd17 	ldw	r2,-12(fp)
 32436c0:	10800617 	ldw	r2,24(r2)
 32436c4:	10801017 	ldw	r2,64(r2)
 32436c8:	18802c26 	beq	r3,r2,324377c <ip_demux+0x3dc>
 32436cc:	e0bffd17 	ldw	r2,-12(fp)
 32436d0:	10800617 	ldw	r2,24(r2)
 32436d4:	10c00a17 	ldw	r3,40(r2)
 32436d8:	e0bffd17 	ldw	r2,-12(fp)
 32436dc:	10800617 	ldw	r2,24(r2)
 32436e0:	10801017 	ldw	r2,64(r2)
 32436e4:	18802526 	beq	r3,r2,324377c <ip_demux+0x3dc>
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
   {

#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 32436e8:	0080c974 	movhi	r2,805
 32436ec:	10931c04 	addi	r2,r2,19568
 32436f0:	10800017 	ldw	r2,0(r2)
 32436f4:	1081000c 	andi	r2,r2,1024
 32436f8:	1005003a 	cmpeq	r2,r2,zero
 32436fc:	1000141e 	bne	r2,zero,3243750 <ip_demux+0x3b0>
 3243700:	0080c974 	movhi	r2,805
 3243704:	10931c04 	addi	r2,r2,19568
 3243708:	10800017 	ldw	r2,0(r2)
 324370c:	1080800c 	andi	r2,r2,512
 3243710:	1005003a 	cmpeq	r2,r2,zero
 3243714:	10000e1e 	bne	r2,zero,3243750 <ip_demux+0x3b0>
      {
         dprintf("ip_demux: unhandled prot %u\n", pip->ip_prot);
 3243718:	e0bffc17 	ldw	r2,-16(fp)
 324371c:	10800243 	ldbu	r2,9(r2)
 3243720:	11403fcc 	andi	r5,r2,255
 3243724:	0100c974 	movhi	r4,805
 3243728:	21002504 	addi	r4,r4,148
 324372c:	3206de00 	call	3206de0 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 3243730:	0080c974 	movhi	r2,805
 3243734:	10931c04 	addi	r2,r2,19568
 3243738:	10800017 	ldw	r2,0(r2)
 324373c:	1080008c 	andi	r2,r2,2
 3243740:	1005003a 	cmpeq	r2,r2,zero
 3243744:	1000021e 	bne	r2,zero,3243750 <ip_demux+0x3b0>
 3243748:	e13ffd17 	ldw	r4,-12(fp)
 324374c:	324059c0 	call	324059c <ip_dump>
      }
#endif   /* NPDEBUG */
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTPROT, p->net);
 3243750:	e0bffc17 	ldw	r2,-16(fp)
 3243754:	11000317 	ldw	r4,12(r2)
 3243758:	e0bffd17 	ldw	r2,-12(fp)
 324375c:	10800617 	ldw	r2,24(r2)
 3243760:	11400a17 	ldw	r5,40(r2)
 3243764:	e0bffd17 	ldw	r2,-12(fp)
 3243768:	10800617 	ldw	r2,24(r2)
 324376c:	d8800015 	stw	r2,0(sp)
 3243770:	e1bffc17 	ldw	r6,-16(fp)
 3243774:	01c00084 	movi	r7,2
 3243778:	324b5400 	call	324b540 <icmp_destun>
   }
#endif   /* FULL_ICMP */

   ip_mib.ipUnknownProtos++;
 324377c:	0080c9b4 	movhi	r2,806
 3243780:	10b54b04 	addi	r2,r2,-10964
 3243784:	10800617 	ldw	r2,24(r2)
 3243788:	10c00044 	addi	r3,r2,1
 324378c:	0080c9b4 	movhi	r2,806
 3243790:	10b54b04 	addi	r2,r2,-10964
 3243794:	10c00615 	stw	r3,24(r2)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 3243798:	01000084 	movi	r4,2
 324379c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   pk_free(p);
 32437a0:	e13ffd17 	ldw	r4,-12(fp)
 32437a4:	322a6400 	call	322a640 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32437a8:	01000084 	movi	r4,2
 32437ac:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   return ENP_NOT_MINE;
 32437b0:	00c00084 	movi	r3,2
 32437b4:	e0ffff15 	stw	r3,-4(fp)
 32437b8:	e0bfff17 	ldw	r2,-4(fp)
}
 32437bc:	e037883a 	mov	sp,fp
 32437c0:	dfc00117 	ldw	ra,4(sp)
 32437c4:	df000017 	ldw	fp,0(sp)
 32437c8:	dec00204 	addi	sp,sp,8
 32437cc:	f800283a 	ret

032437d0 <in_addmulti>:
 * RETURNS: 
 */

struct in_multi * 
in_addmulti(ip_addr *ap, struct net *netp, int addrtype)
{
 32437d0:	defff804 	addi	sp,sp,-32
 32437d4:	dfc00715 	stw	ra,28(sp)
 32437d8:	df000615 	stw	fp,24(sp)
 32437dc:	df000604 	addi	fp,sp,24
 32437e0:	e13ffc15 	stw	r4,-16(fp)
 32437e4:	e17ffd15 	stw	r5,-12(fp)
 32437e8:	e1bffe15 	stw	r6,-8(fp)
   struct in_multi *inm = (struct in_multi *)NULL;
 32437ec:	e03ffb15 	stw	zero,-20(fp)
   int error;

   /* check for good addr. */
   if ((ap == (ip_addr *)NULL) || (*ap == 0))
 32437f0:	e0bffc17 	ldw	r2,-16(fp)
 32437f4:	1005003a 	cmpeq	r2,r2,zero
 32437f8:	1000041e 	bne	r2,zero,324380c <in_addmulti+0x3c>
 32437fc:	e0bffc17 	ldw	r2,-16(fp)
 3243800:	10800017 	ldw	r2,0(r2)
 3243804:	1004c03a 	cmpne	r2,r2,zero
 3243808:	1000021e 	bne	r2,zero,3243814 <in_addmulti+0x44>
      return ((struct in_multi *)NULL);  
 324380c:	e03fff15 	stw	zero,-4(fp)
 3243810:	00004306 	br	3243920 <in_addmulti+0x150>

   ENTER_CRIT_SECTION(netp);
 3243814:	322b0f00 	call	322b0f0 <irq_Mask>
#ifdef IP_V6
   if(addrtype == 6)
      inm = v6_lookup_mcast((ip6_addr*)ap, netp);
#endif
#ifdef IP_V4
   if(addrtype != 6)
 3243818:	e0bffe17 	ldw	r2,-8(fp)
 324381c:	108001a0 	cmpeqi	r2,r2,6
 3243820:	1000051e 	bne	r2,zero,3243838 <in_addmulti+0x68>
      inm = lookup_mcast(*ap, netp);
 3243824:	e0bffc17 	ldw	r2,-16(fp)
 3243828:	11000017 	ldw	r4,0(r2)
 324382c:	e17ffd17 	ldw	r5,-12(fp)
 3243830:	3243a500 	call	3243a50 <lookup_mcast>
 3243834:	e0bffb15 	stw	r2,-20(fp)
#endif

   if (inm != (struct in_multi *)NULL) 
 3243838:	e0bffb17 	ldw	r2,-20(fp)
 324383c:	1005003a 	cmpeq	r2,r2,zero
 3243840:	1000061e 	bne	r2,zero,324385c <in_addmulti+0x8c>
   {
      /* Found it; just increment the reference count. */
      ++inm->inm_refcount;
 3243844:	e0bffb17 	ldw	r2,-20(fp)
 3243848:	10800217 	ldw	r2,8(r2)
 324384c:	10c00044 	addi	r3,r2,1
 3243850:	e0bffb17 	ldw	r2,-20(fp)
 3243854:	10c00215 	stw	r3,8(r2)
 3243858:	00002e06 	br	3243914 <in_addmulti+0x144>
   {
      /*
       * New address; allocate a new multicast record
       * and link it into the interface's multicast list.
       */
      inm = (struct in_multi *)INM_ALLOC(sizeof(*inm));
 324385c:	01000604 	movi	r4,24
 3243860:	322b9340 	call	322b934 <npalloc>
 3243864:	e0bffb15 	stw	r2,-20(fp)

      if (inm == (struct in_multi *)NULL) 
 3243868:	e0bffb17 	ldw	r2,-20(fp)
 324386c:	1004c03a 	cmpne	r2,r2,zero
 3243870:	1000031e 	bne	r2,zero,3243880 <in_addmulti+0xb0>
      {
         EXIT_CRIT_SECTION(netp);
 3243874:	322b14c0 	call	322b14c <irq_Unmask>
         return ((struct in_multi *)NULL);
 3243878:	e03fff15 	stw	zero,-4(fp)
 324387c:	00002806 	br	3243920 <in_addmulti+0x150>
#ifdef IP_V6
      if(addrtype == 6)
         IP6CPY(&inm->ip6addr, (struct in6_addr *)ap);
#endif
#ifdef IP_V4
      if(addrtype != 6)
 3243880:	e0bffe17 	ldw	r2,-8(fp)
 3243884:	108001a0 	cmpeqi	r2,r2,6
 3243888:	1000041e 	bne	r2,zero,324389c <in_addmulti+0xcc>
         inm->inm_addr = *ap;
 324388c:	e0bffc17 	ldw	r2,-16(fp)
 3243890:	10c00017 	ldw	r3,0(r2)
 3243894:	e0bffb17 	ldw	r2,-20(fp)
 3243898:	10c00015 	stw	r3,0(r2)
#endif
      inm->inm_netp = netp;
 324389c:	e0fffb17 	ldw	r3,-20(fp)
 32438a0:	e0bffd17 	ldw	r2,-12(fp)
 32438a4:	18800115 	stw	r2,4(r3)
      inm->inm_refcount = 1;
 32438a8:	e0fffb17 	ldw	r3,-20(fp)
 32438ac:	00800044 	movi	r2,1
 32438b0:	18800215 	stw	r2,8(r3)
      inm->inm_next = netp->mc_list;
 32438b4:	e0bffd17 	ldw	r2,-12(fp)
 32438b8:	10c02c17 	ldw	r3,176(r2)
 32438bc:	e0bffb17 	ldw	r2,-20(fp)
 32438c0:	10c00515 	stw	r3,20(r2)
      netp->mc_list = inm;
 32438c4:	e0fffd17 	ldw	r3,-12(fp)
 32438c8:	e0bffb17 	ldw	r2,-20(fp)
 32438cc:	18802c15 	stw	r2,176(r3)
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the new address.
       */
      if(netp->n_mcastlist)
 32438d0:	e0bffd17 	ldw	r2,-12(fp)
 32438d4:	10802b17 	ldw	r2,172(r2)
 32438d8:	1005003a 	cmpeq	r2,r2,zero
 32438dc:	1000061e 	bne	r2,zero,32438f8 <in_addmulti+0x128>
         error = netp->n_mcastlist(inm);
 32438e0:	e0bffd17 	ldw	r2,-12(fp)
 32438e4:	10802b17 	ldw	r2,172(r2)
 32438e8:	e13ffb17 	ldw	r4,-20(fp)
 32438ec:	103ee83a 	callr	r2
 32438f0:	e0bffa15 	stw	r2,-24(fp)
 32438f4:	00000106 	br	32438fc <in_addmulti+0x12c>
      else
         error = 0;
 32438f8:	e03ffa15 	stw	zero,-24(fp)
#if defined (IGMP_V1) || defined (IGMP_V2)
      /*
       * Let IGMP know that we have joined a new IP multicast group.
       */
      if (inm->inm_addr) igmp_joingroup(inm);
 32438fc:	e0bffb17 	ldw	r2,-20(fp)
 3243900:	10800017 	ldw	r2,0(r2)
 3243904:	1005003a 	cmpeq	r2,r2,zero
 3243908:	1000021e 	bne	r2,zero,3243914 <in_addmulti+0x144>
 324390c:	e13ffb17 	ldw	r4,-20(fp)
 3243910:	32247380 	call	3224738 <igmp_joingroup>
#endif      
   }

   EXIT_CRIT_SECTION(netp);
 3243914:	322b14c0 	call	322b14c <irq_Unmask>
   USE_ARG(error);

   return (inm);
 3243918:	e0bffb17 	ldw	r2,-20(fp)
 324391c:	e0bfff15 	stw	r2,-4(fp)
 3243920:	e0bfff17 	ldw	r2,-4(fp)
}
 3243924:	e037883a 	mov	sp,fp
 3243928:	dfc00117 	ldw	ra,4(sp)
 324392c:	df000017 	ldw	fp,0(sp)
 3243930:	dec00204 	addi	sp,sp,8
 3243934:	f800283a 	ret

03243938 <in_delmulti>:
 * RETURNS: 
 */

void
in_delmulti(struct in_multi * inm)
{
 3243938:	defffa04 	addi	sp,sp,-24
 324393c:	dfc00515 	stw	ra,20(sp)
 3243940:	df000415 	stw	fp,16(sp)
 3243944:	df000404 	addi	fp,sp,16
 3243948:	e13fff15 	stw	r4,-4(fp)
   struct in_multi * p;
   NET         netp = inm->inm_netp;
 324394c:	e0bfff17 	ldw	r2,-4(fp)
 3243950:	10800117 	ldw	r2,4(r2)
 3243954:	e0bffd15 	stw	r2,-12(fp)
   int error;

   ENTER_CRIT_SECTION(inm);
 3243958:	322b0f00 	call	322b0f0 <irq_Mask>
   if (--inm->inm_refcount == 0) 
 324395c:	e0bfff17 	ldw	r2,-4(fp)
 3243960:	10800217 	ldw	r2,8(r2)
 3243964:	10ffffc4 	addi	r3,r2,-1
 3243968:	e0bfff17 	ldw	r2,-4(fp)
 324396c:	10c00215 	stw	r3,8(r2)
 3243970:	e0bfff17 	ldw	r2,-4(fp)
 3243974:	10800217 	ldw	r2,8(r2)
 3243978:	1004c03a 	cmpne	r2,r2,zero
 324397c:	10002e1e 	bne	r2,zero,3243a38 <in_delmulti+0x100>
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 3243980:	e0bffd17 	ldw	r2,-12(fp)
 3243984:	10802c17 	ldw	r2,176(r2)
 3243988:	e0bffe15 	stw	r2,-8(fp)
 324398c:	00001406 	br	32439e0 <in_delmulti+0xa8>
      {
         if(p == inm)   /* inm is first in mc_list */
 3243990:	e0fffe17 	ldw	r3,-8(fp)
 3243994:	e0bfff17 	ldw	r2,-4(fp)
 3243998:	1880051e 	bne	r3,r2,32439b0 <in_delmulti+0x78>
         {
            netp->mc_list = p->inm_next;  /* unlink */
 324399c:	e0bffe17 	ldw	r2,-8(fp)
 32439a0:	10c00517 	ldw	r3,20(r2)
 32439a4:	e0bffd17 	ldw	r2,-12(fp)
 32439a8:	10c02c15 	stw	r3,176(r2)
            break;
 32439ac:	00000f06 	br	32439ec <in_delmulti+0xb4>
         }
         else if(p->inm_next == inm)   /* inm is next */
 32439b0:	e0bffe17 	ldw	r2,-8(fp)
 32439b4:	10c00517 	ldw	r3,20(r2)
 32439b8:	e0bfff17 	ldw	r2,-4(fp)
 32439bc:	1880051e 	bne	r3,r2,32439d4 <in_delmulti+0x9c>
         {
            p->inm_next = inm->inm_next;  /* unlink */
 32439c0:	e0bfff17 	ldw	r2,-4(fp)
 32439c4:	10c00517 	ldw	r3,20(r2)
 32439c8:	e0bffe17 	ldw	r2,-8(fp)
 32439cc:	10c00515 	stw	r3,20(r2)
            break;
 32439d0:	00000606 	br	32439ec <in_delmulti+0xb4>

   ENTER_CRIT_SECTION(inm);
   if (--inm->inm_refcount == 0) 
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 32439d4:	e0bffe17 	ldw	r2,-8(fp)
 32439d8:	10800517 	ldw	r2,20(r2)
 32439dc:	e0bffe15 	stw	r2,-8(fp)
 32439e0:	e0bffe17 	ldw	r2,-8(fp)
 32439e4:	1004c03a 	cmpne	r2,r2,zero
 32439e8:	103fe91e 	bne	r2,zero,3243990 <in_delmulti+0x58>
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the deleted address.
       */
      if(netp->n_mcastlist)
 32439ec:	e0bffd17 	ldw	r2,-12(fp)
 32439f0:	10802b17 	ldw	r2,172(r2)
 32439f4:	1005003a 	cmpeq	r2,r2,zero
 32439f8:	1000061e 	bne	r2,zero,3243a14 <in_delmulti+0xdc>
         error = netp->n_mcastlist(inm);
 32439fc:	e0bffd17 	ldw	r2,-12(fp)
 3243a00:	10802b17 	ldw	r2,172(r2)
 3243a04:	e13fff17 	ldw	r4,-4(fp)
 3243a08:	103ee83a 	callr	r2
 3243a0c:	e0bffc15 	stw	r2,-16(fp)
 3243a10:	00000106 	br	3243a18 <in_delmulti+0xe0>
      else
         error = 0;
 3243a14:	e03ffc15 	stw	zero,-16(fp)
#if defined (IGMP_V2)
      /*
       * No remaining claims to this record; let IGMP know that
       * we are leaving the multicast group.
       */
      if (inm->inm_addr) igmp_leavegroup(inm);
 3243a18:	e0bfff17 	ldw	r2,-4(fp)
 3243a1c:	10800017 	ldw	r2,0(r2)
 3243a20:	1005003a 	cmpeq	r2,r2,zero
 3243a24:	1000021e 	bne	r2,zero,3243a30 <in_delmulti+0xf8>
 3243a28:	e13fff17 	ldw	r4,-4(fp)
 3243a2c:	32249a40 	call	32249a4 <igmp_leavegroup>
#endif      

      IM_FREE(inm);
 3243a30:	e13fff17 	ldw	r4,-4(fp)
 3243a34:	322ba280 	call	322ba28 <npfree>
   }
   EXIT_CRIT_SECTION(inm);
 3243a38:	322b14c0 	call	322b14c <irq_Unmask>
}
 3243a3c:	e037883a 	mov	sp,fp
 3243a40:	dfc00117 	ldw	ra,4(sp)
 3243a44:	df000017 	ldw	fp,0(sp)
 3243a48:	dec00204 	addi	sp,sp,8
 3243a4c:	f800283a 	ret

03243a50 <lookup_mcast>:
 * RETURNS: pointer to mcast addr structure, or NULL if not found.
 */

struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
 3243a50:	defffb04 	addi	sp,sp,-20
 3243a54:	df000415 	stw	fp,16(sp)
 3243a58:	df000404 	addi	fp,sp,16
 3243a5c:	e13ffd15 	stw	r4,-12(fp)
 3243a60:	e17ffe15 	stw	r5,-8(fp)
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 3243a64:	e0bffe17 	ldw	r2,-8(fp)
 3243a68:	10802c17 	ldw	r2,176(r2)
 3243a6c:	e0bffc15 	stw	r2,-16(fp)
 3243a70:	00000a06 	br	3243a9c <lookup_mcast+0x4c>
   {
      if(imp->inm_addr == addr)
 3243a74:	e0bffc17 	ldw	r2,-16(fp)
 3243a78:	10c00017 	ldw	r3,0(r2)
 3243a7c:	e0bffd17 	ldw	r2,-12(fp)
 3243a80:	1880031e 	bne	r3,r2,3243a90 <lookup_mcast+0x40>
         return imp;
 3243a84:	e0bffc17 	ldw	r2,-16(fp)
 3243a88:	e0bfff15 	stw	r2,-4(fp)
 3243a8c:	00000706 	br	3243aac <lookup_mcast+0x5c>
struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 3243a90:	e0bffc17 	ldw	r2,-16(fp)
 3243a94:	10800517 	ldw	r2,20(r2)
 3243a98:	e0bffc15 	stw	r2,-16(fp)
 3243a9c:	e0bffc17 	ldw	r2,-16(fp)
 3243aa0:	1004c03a 	cmpne	r2,r2,zero
 3243aa4:	103ff31e 	bne	r2,zero,3243a74 <lookup_mcast+0x24>
   {
      if(imp->inm_addr == addr)
         return imp;
   }
   return NULL;   /* addr not found in mcast list */
 3243aa8:	e03fff15 	stw	zero,-4(fp)
 3243aac:	e0bfff17 	ldw	r2,-4(fp)
}
 3243ab0:	e037883a 	mov	sp,fp
 3243ab4:	df000017 	ldw	fp,0(sp)
 3243ab8:	dec00104 	addi	sp,sp,4
 3243abc:	f800283a 	ret

03243ac0 <prep_ifaces>:
 * passed value. 
 */

int
prep_ifaces(int ifaces_found)
{
 3243ac0:	defffc04 	addi	sp,sp,-16
 3243ac4:	dfc00315 	stw	ra,12(sp)
 3243ac8:	df000215 	stw	fp,8(sp)
 3243acc:	df000204 	addi	fp,sp,8
 3243ad0:	e13ffe15 	stw	r4,-8(fp)
   if (port_prep)
 3243ad4:	d0a90117 	ldw	r2,-23548(gp)
 3243ad8:	1005003a 	cmpeq	r2,r2,zero
 3243adc:	1000041e 	bne	r2,zero,3243af0 <prep_ifaces+0x30>
      ifaces_found = port_prep(ifaces_found);
 3243ae0:	d0a90117 	ldw	r2,-23548(gp)
 3243ae4:	e13ffe17 	ldw	r4,-8(fp)
 3243ae8:	103ee83a 	callr	r2
 3243aec:	e0bffe15 	stw	r2,-8(fp)

#ifdef MAC_LOOPBACK
   ifaces_found = prep_lb(ifaces_found);
#endif   /* MAC_LOOPBACK */

   ifNumber = ifaces_found;   /* set global interface counter */
 3243af0:	e0fffe17 	ldw	r3,-8(fp)
 3243af4:	0080c974 	movhi	r2,805
 3243af8:	10931d04 	addi	r2,r2,19572
 3243afc:	10c00015 	stw	r3,0(r2)

   initmsg("prepped %u interface%s, initializing...\n", 
 3243b00:	e0bffe17 	ldw	r2,-8(fp)
 3243b04:	10800058 	cmpnei	r2,r2,1
 3243b08:	1000041e 	bne	r2,zero,3243b1c <prep_ifaces+0x5c>
 3243b0c:	0080c974 	movhi	r2,805
 3243b10:	10802d04 	addi	r2,r2,180
 3243b14:	e0bfff15 	stw	r2,-4(fp)
 3243b18:	00000306 	br	3243b28 <prep_ifaces+0x68>
 3243b1c:	0080c974 	movhi	r2,805
 3243b20:	10802e04 	addi	r2,r2,184
 3243b24:	e0bfff15 	stw	r2,-4(fp)
 3243b28:	0100c974 	movhi	r4,805
 3243b2c:	21002f04 	addi	r4,r4,188
 3243b30:	e17ffe17 	ldw	r5,-8(fp)
 3243b34:	e1bfff17 	ldw	r6,-4(fp)
 3243b38:	3206de00 	call	3206de0 <printf>
      ifaces_found, ifaces_found==1?"":"s");

   return ifaces_found;
 3243b3c:	e0bffe17 	ldw	r2,-8(fp)
}
 3243b40:	e037883a 	mov	sp,fp
 3243b44:	dfc00117 	ldw	ra,4(sp)
 3243b48:	df000017 	ldw	fp,0(sp)
 3243b4c:	dec00204 	addi	sp,sp,8
 3243b50:	f800283a 	ret

03243b54 <netexit>:
 * RETURNS: SHould not return
 */

void
netexit(int err)      /* exit error level */
{
 3243b54:	defffd04 	addi	sp,sp,-12
 3243b58:	dfc00215 	stw	ra,8(sp)
 3243b5c:	df000115 	stw	fp,4(sp)
 3243b60:	df000104 	addi	fp,sp,4
 3243b64:	e13fff15 	stw	r4,-4(fp)
   net_system_exit = TRUE; /* set flag for shutting down */
 3243b68:	00800044 	movi	r2,1
 3243b6c:	d0a90215 	stw	r2,-23544(gp)
   ip_exit();  /* do the exit_hook()ed stuff */
 3243b70:	3223fec0 	call	3223fec <ip_exit>

   PORT_EXIT_FUNC(err);    /* should not return! */
 3243b74:	e13fff17 	ldw	r4,-4(fp)
 3243b78:	324bc600 	call	324bc60 <exit>

03243b7c <evtmap_setup>:
 * INPUT: None.
 * OUTPUT: None
 */
 
void evtmap_setup (void)
{
 3243b7c:	deffff04 	addi	sp,sp,-4
 3243b80:	df000015 	stw	fp,0(sp)
 3243b84:	d839883a 	mov	fp,sp
#ifdef SOCK_MAP_EVENTS
   so_evtmap = TRUE;
   so_evtmap_create = evtmap_create;
   so_evtmap_delete = evtmap_delete;
#else
   so_evtmap = FALSE;
 3243b88:	d0290505 	stb	zero,-23532(gp)
   so_evtmap_create = 0;
 3243b8c:	d0290315 	stw	zero,-23540(gp)
   so_evtmap_delete = 0;
 3243b90:	d0290415 	stw	zero,-23536(gp)
#endif   /* SOCK_MAP_EVENTS */ 

}
 3243b94:	e037883a 	mov	sp,fp
 3243b98:	df000017 	ldw	fp,0(sp)
 3243b9c:	dec00104 	addi	sp,sp,4
 3243ba0:	f800283a 	ret

03243ba4 <ip_raw_open>:
ip_raw_open(u_char prot,
            ip_addr laddr,
            ip_addr faddr,
            int (*handler)(PACKET, void *),
            void * data)
{
 3243ba4:	defff804 	addi	sp,sp,-32
 3243ba8:	dfc00715 	stw	ra,28(sp)
 3243bac:	df000615 	stw	fp,24(sp)
 3243bb0:	df000604 	addi	fp,sp,24
 3243bb4:	e17ffc15 	stw	r5,-16(fp)
 3243bb8:	e1bffd15 	stw	r6,-12(fp)
 3243bbc:	e1fffe15 	stw	r7,-8(fp)
 3243bc0:	e13ffb05 	stb	r4,-20(fp)
   struct ipraw_ep * ep;

   LOCK_NET_RESOURCE(NET_RESID);
 3243bc4:	0009883a 	mov	r4,zero
 3243bc8:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>

   /* allocate a structure for the endpoint */
   ep = (struct ipraw_ep *)IEP_ALLOC(sizeof(struct ipraw_ep));
 3243bcc:	01000604 	movi	r4,24
 3243bd0:	322b9340 	call	322b934 <npalloc>
 3243bd4:	e0bffa15 	stw	r2,-24(fp)
   if (ep == NULL)
 3243bd8:	e0bffa17 	ldw	r2,-24(fp)
 3243bdc:	1004c03a 	cmpne	r2,r2,zero
 3243be0:	10000e1e 	bne	r2,zero,3243c1c <ip_raw_open+0x78>
   {
#ifdef NPDEBUG
      if (NDEBUG & INFOMSG)
 3243be4:	0080c974 	movhi	r2,805
 3243be8:	10931c04 	addi	r2,r2,19568
 3243bec:	10800017 	ldw	r2,0(r2)
 3243bf0:	1080010c 	andi	r2,r2,4
 3243bf4:	1005003a 	cmpeq	r2,r2,zero
 3243bf8:	1000031e 	bne	r2,zero,3243c08 <ip_raw_open+0x64>
         dprintf("IP: Couldn't allocate ep storage.\n");
 3243bfc:	0100c974 	movhi	r4,805
 3243c00:	21003a04 	addi	r4,r4,232
 3243c04:	32071080 	call	3207108 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 3243c08:	0009883a 	mov	r4,zero
 3243c0c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return ep;
 3243c10:	e0bffa17 	ldw	r2,-24(fp)
 3243c14:	e0bfff15 	stw	r2,-4(fp)
 3243c18:	00001806 	br	3243c7c <ip_raw_open+0xd8>
   }

   /* fill it in with the caller's requested binding */
   ep->ipr_laddr = laddr;
 3243c1c:	e0fffa17 	ldw	r3,-24(fp)
 3243c20:	e0bffc17 	ldw	r2,-16(fp)
 3243c24:	18800115 	stw	r2,4(r3)
   ep->ipr_faddr = faddr;
 3243c28:	e0fffa17 	ldw	r3,-24(fp)
 3243c2c:	e0bffd17 	ldw	r2,-12(fp)
 3243c30:	18800215 	stw	r2,8(r3)
   ep->ipr_prot = prot;
 3243c34:	e0fffa17 	ldw	r3,-24(fp)
 3243c38:	e0bffb03 	ldbu	r2,-20(fp)
 3243c3c:	18800505 	stb	r2,20(r3)
   ep->ipr_rcv = handler;
 3243c40:	e0fffa17 	ldw	r3,-24(fp)
 3243c44:	e0bffe17 	ldw	r2,-8(fp)
 3243c48:	18800315 	stw	r2,12(r3)
   ep->ipr_data = data;
 3243c4c:	e0fffa17 	ldw	r3,-24(fp)
 3243c50:	e0800217 	ldw	r2,8(fp)
 3243c54:	18800415 	stw	r2,16(r3)

   /* link it into the list 
    * (at the head, because that's simple and fast) 
    */
   ep->ipr_next = ipraw_eps;
 3243c58:	d0e90617 	ldw	r3,-23528(gp)
 3243c5c:	e0bffa17 	ldw	r2,-24(fp)
 3243c60:	10c00015 	stw	r3,0(r2)
   ipraw_eps = ep;
 3243c64:	e0bffa17 	ldw	r2,-24(fp)
 3243c68:	d0a90615 	stw	r2,-23528(gp)

   /* and return the pointer to the endpoint */
   UNLOCK_NET_RESOURCE(NET_RESID);
 3243c6c:	0009883a 	mov	r4,zero
 3243c70:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   return ep;
 3243c74:	e0bffa17 	ldw	r2,-24(fp)
 3243c78:	e0bfff15 	stw	r2,-4(fp)
 3243c7c:	e0bfff17 	ldw	r2,-4(fp)
}
 3243c80:	e037883a 	mov	sp,fp
 3243c84:	dfc00117 	ldw	ra,4(sp)
 3243c88:	df000017 	ldw	fp,0(sp)
 3243c8c:	dec00204 	addi	sp,sp,8
 3243c90:	f800283a 	ret

03243c94 <ip_raw_close>:
 *                               that is to be closed
 * RETURNS: void
 */
void
ip_raw_close(struct ipraw_ep * ep)
{
 3243c94:	defffb04 	addi	sp,sp,-20
 3243c98:	dfc00415 	stw	ra,16(sp)
 3243c9c:	df000315 	stw	fp,12(sp)
 3243ca0:	df000304 	addi	fp,sp,12
 3243ca4:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * prev_ep;
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);
 3243ca8:	0009883a 	mov	r4,zero
 3243cac:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 3243cb0:	e03ffe15 	stw	zero,-8(fp)
 3243cb4:	d0a90617 	ldw	r2,-23528(gp)
 3243cb8:	e0bffd15 	stw	r2,-12(fp)
        curr_ep != NULL;
 3243cbc:	00000806 	br	3243ce0 <ip_raw_close+0x4c>
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
 3243cc0:	e0fffd17 	ldw	r3,-12(fp)
 3243cc4:	e0bfff17 	ldw	r2,-4(fp)
 3243cc8:	18800826 	beq	r3,r2,3243cec <ip_raw_close+0x58>
         break;
      prev_ep = curr_ep;
 3243ccc:	e0bffd17 	ldw	r2,-12(fp)
 3243cd0:	e0bffe15 	stw	r2,-8(fp)
   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
 3243cd4:	e0bffd17 	ldw	r2,-12(fp)
 3243cd8:	10800017 	ldw	r2,0(r2)
 3243cdc:	e0bffd15 	stw	r2,-12(fp)

   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
 3243ce0:	e0bffd17 	ldw	r2,-12(fp)
 3243ce4:	1004c03a 	cmpne	r2,r2,zero
 3243ce8:	103ff51e 	bne	r2,zero,3243cc0 <ip_raw_close+0x2c>
         break;
      prev_ep = curr_ep;
   }

   /* if we didn't find it, we can't close it, so just return */
   if (curr_ep == NULL)
 3243cec:	e0bffd17 	ldw	r2,-12(fp)
 3243cf0:	1004c03a 	cmpne	r2,r2,zero
 3243cf4:	1000041e 	bne	r2,zero,3243d08 <ip_raw_close+0x74>
   {
#ifdef NPDEBUG
      /* caller passed pointer to endpoint not in list 
       * -- not fatal, but may be programming error
       */
      dtrap();
 3243cf8:	322aef00 	call	322aef0 <dtrap>
#endif /* NPDEBUG */
      UNLOCK_NET_RESOURCE(NET_RESID);
 3243cfc:	0009883a 	mov	r4,zero
 3243d00:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return;
 3243d04:	00000e06 	br	3243d40 <ip_raw_close+0xac>
   }

   /* unlink it from the list */
   if (prev_ep)
 3243d08:	e0bffe17 	ldw	r2,-8(fp)
 3243d0c:	1005003a 	cmpeq	r2,r2,zero
 3243d10:	1000041e 	bne	r2,zero,3243d24 <ip_raw_close+0x90>
      prev_ep = curr_ep->ipr_next;
 3243d14:	e0bffd17 	ldw	r2,-12(fp)
 3243d18:	10800017 	ldw	r2,0(r2)
 3243d1c:	e0bffe15 	stw	r2,-8(fp)
 3243d20:	00000306 	br	3243d30 <ip_raw_close+0x9c>
   else
      ipraw_eps = curr_ep->ipr_next;
 3243d24:	e0bffd17 	ldw	r2,-12(fp)
 3243d28:	10800017 	ldw	r2,0(r2)
 3243d2c:	d0a90615 	stw	r2,-23528(gp)

   /* free its storage */
   IEP_FREE(curr_ep);
 3243d30:	e13ffd17 	ldw	r4,-12(fp)
 3243d34:	322ba280 	call	322ba28 <npfree>

   /* and return */
   UNLOCK_NET_RESOURCE(NET_RESID);
 3243d38:	0009883a 	mov	r4,zero
 3243d3c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
}
 3243d40:	e037883a 	mov	sp,fp
 3243d44:	dfc00117 	ldw	ra,4(sp)
 3243d48:	df000017 	ldw	fp,0(sp)
 3243d4c:	dec00204 	addi	sp,sp,8
 3243d50:	f800283a 	ret

03243d54 <ip_raw_input>:
 *          freed); else an error code indicating that the
 *          received packet was not accepted/processed
 */
int
ip_raw_input(PACKET p)
{
 3243d54:	defff604 	addi	sp,sp,-40
 3243d58:	dfc00915 	stw	ra,36(sp)
 3243d5c:	df000815 	stw	fp,32(sp)
 3243d60:	df000804 	addi	fp,sp,32
 3243d64:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;              /* the internet header */
   struct ipraw_ep * ep;
   struct ipraw_ep * next_ep;
   struct ipraw_ep * matched_ep = NULL;
 3243d68:	e03ffb15 	stw	zero,-20(fp)
   int err;
   int delivered;

   /* start out expecting to not deliver the packet */
   delivered = 0;
 3243d6c:	e03ff915 	stw	zero,-28(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);
 3243d70:	e0bfff17 	ldw	r2,-4(fp)
 3243d74:	10800317 	ldw	r2,12(r2)
 3243d78:	e0bffe15 	stw	r2,-8(fp)

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 3243d7c:	d0a90617 	ldw	r2,-23528(gp)
 3243d80:	e0bffd15 	stw	r2,-12(fp)
 3243d84:	00004d06 	br	3243ebc <ip_raw_input+0x168>
   {
      /* keep track of next endpoint -- defense against upcall
       * function closing its own endpoint
       */
      next_ep = ep->ipr_next;
 3243d88:	e0bffd17 	ldw	r2,-12(fp)
 3243d8c:	10800017 	ldw	r2,0(r2)
 3243d90:	e0bffc15 	stw	r2,-16(fp)

      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
 3243d94:	e0bffd17 	ldw	r2,-12(fp)
 3243d98:	10800503 	ldbu	r2,20(r2)
 3243d9c:	10803fcc 	andi	r2,r2,255
 3243da0:	1005003a 	cmpeq	r2,r2,zero
 3243da4:	1000071e 	bne	r2,zero,3243dc4 <ip_raw_input+0x70>
 3243da8:	e0bffd17 	ldw	r2,-12(fp)
 3243dac:	10c00503 	ldbu	r3,20(r2)
 3243db0:	e0bffe17 	ldw	r2,-8(fp)
 3243db4:	10800243 	ldbu	r2,9(r2)
 3243db8:	18c03fcc 	andi	r3,r3,255
 3243dbc:	10803fcc 	andi	r2,r2,255
 3243dc0:	18803c1e 	bne	r3,r2,3243eb4 <ip_raw_input+0x160>
         continue;
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
 3243dc4:	e0bffd17 	ldw	r2,-12(fp)
 3243dc8:	10800117 	ldw	r2,4(r2)
 3243dcc:	1005003a 	cmpeq	r2,r2,zero
 3243dd0:	1000051e 	bne	r2,zero,3243de8 <ip_raw_input+0x94>
 3243dd4:	e0bffd17 	ldw	r2,-12(fp)
 3243dd8:	10c00117 	ldw	r3,4(r2)
 3243ddc:	e0bffe17 	ldw	r2,-8(fp)
 3243de0:	10800417 	ldw	r2,16(r2)
 3243de4:	1880331e 	bne	r3,r2,3243eb4 <ip_raw_input+0x160>
         continue;
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
 3243de8:	e0bffd17 	ldw	r2,-12(fp)
 3243dec:	10800217 	ldw	r2,8(r2)
 3243df0:	1005003a 	cmpeq	r2,r2,zero
 3243df4:	1000051e 	bne	r2,zero,3243e0c <ip_raw_input+0xb8>
 3243df8:	e0bffd17 	ldw	r2,-12(fp)
 3243dfc:	10c00217 	ldw	r3,8(r2)
 3243e00:	e0bffe17 	ldw	r2,-8(fp)
 3243e04:	10800317 	ldw	r2,12(r2)
 3243e08:	18802a1e 	bne	r3,r2,3243eb4 <ip_raw_input+0x160>
         continue;

      /* if the endpoint has a receive upcall function, 
       * keep track of the endpoint
       */
      if (ep->ipr_rcv != NULL)
 3243e0c:	e0bffd17 	ldw	r2,-12(fp)
 3243e10:	10800317 	ldw	r2,12(r2)
 3243e14:	1005003a 	cmpeq	r2,r2,zero
 3243e18:	1000261e 	bne	r2,zero,3243eb4 <ip_raw_input+0x160>
          * copy the packet into a new buffer,
          * and pass the new copy to the previously matched 
          * endpoint's upcall function 
          * before we forget the previous endpoint
          */
         if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 3243e1c:	e0bffb17 	ldw	r2,-20(fp)
 3243e20:	1005003a 	cmpeq	r2,r2,zero
 3243e24:	1000211e 	bne	r2,zero,3243eac <ip_raw_input+0x158>
 3243e28:	e0bffb17 	ldw	r2,-20(fp)
 3243e2c:	10800317 	ldw	r2,12(r2)
 3243e30:	1005003a 	cmpeq	r2,r2,zero
 3243e34:	10001d1e 	bne	r2,zero,3243eac <ip_raw_input+0x158>
         {
            PACKET p2;

            p2 = ip_copypkt(p);
 3243e38:	e13fff17 	ldw	r4,-4(fp)
 3243e3c:	3240ac00 	call	3240ac0 <ip_copypkt>
 3243e40:	e0bff815 	stw	r2,-32(fp)
            if (p2)
 3243e44:	e0bff817 	ldw	r2,-32(fp)
 3243e48:	1005003a 	cmpeq	r2,r2,zero
 3243e4c:	1000171e 	bne	r2,zero,3243eac <ip_raw_input+0x158>
            {
               UNLOCK_NET_RESOURCE(NET_RESID);
 3243e50:	0009883a 	mov	r4,zero
 3243e54:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
               err = ((*matched_ep->ipr_rcv)(p2, matched_ep->ipr_data));
 3243e58:	e0bffb17 	ldw	r2,-20(fp)
 3243e5c:	10c00317 	ldw	r3,12(r2)
 3243e60:	e0bffb17 	ldw	r2,-20(fp)
 3243e64:	11400417 	ldw	r5,16(r2)
 3243e68:	e13ff817 	ldw	r4,-32(fp)
 3243e6c:	183ee83a 	callr	r3
 3243e70:	e0bffa15 	stw	r2,-24(fp)
               LOCK_NET_RESOURCE(NET_RESID);
 3243e74:	0009883a 	mov	r4,zero
 3243e78:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
               if (err)
 3243e7c:	e0bffa17 	ldw	r2,-24(fp)
 3243e80:	1005003a 	cmpeq	r2,r2,zero
 3243e84:	1000071e 	bne	r2,zero,3243ea4 <ip_raw_input+0x150>
               {
                  LOCK_NET_RESOURCE(FREEQ_RESID);
 3243e88:	01000084 	movi	r4,2
 3243e8c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
                  pk_free(p2);
 3243e90:	e13ff817 	ldw	r4,-32(fp)
 3243e94:	322a6400 	call	322a640 <pk_free>
                  UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3243e98:	01000084 	movi	r4,2
 3243e9c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
 3243ea0:	00000206 	br	3243eac <ip_raw_input+0x158>
               }
               else
                  delivered = 1;
 3243ea4:	00800044 	movi	r2,1
 3243ea8:	e0bff915 	stw	r2,-28(fp)
            }
         }
         matched_ep = ep;
 3243eac:	e0bffd17 	ldw	r2,-12(fp)
 3243eb0:	e0bffb15 	stw	r2,-20(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 3243eb4:	e0bffc17 	ldw	r2,-16(fp)
 3243eb8:	e0bffd15 	stw	r2,-12(fp)
 3243ebc:	e0bffd17 	ldw	r2,-12(fp)
 3243ec0:	1004c03a 	cmpne	r2,r2,zero
 3243ec4:	103fb01e 	bne	r2,zero,3243d88 <ip_raw_input+0x34>
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 3243ec8:	e0bffb17 	ldw	r2,-20(fp)
 3243ecc:	1005003a 	cmpeq	r2,r2,zero
 3243ed0:	1000151e 	bne	r2,zero,3243f28 <ip_raw_input+0x1d4>
 3243ed4:	e0bffb17 	ldw	r2,-20(fp)
 3243ed8:	10800317 	ldw	r2,12(r2)
 3243edc:	1005003a 	cmpeq	r2,r2,zero
 3243ee0:	1000111e 	bne	r2,zero,3243f28 <ip_raw_input+0x1d4>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 3243ee4:	0009883a 	mov	r4,zero
 3243ee8:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
 3243eec:	e0bffb17 	ldw	r2,-20(fp)
 3243ef0:	10c00317 	ldw	r3,12(r2)
 3243ef4:	e0bffb17 	ldw	r2,-20(fp)
 3243ef8:	11400417 	ldw	r5,16(r2)
 3243efc:	e13fff17 	ldw	r4,-4(fp)
 3243f00:	183ee83a 	callr	r3
 3243f04:	e0bffa15 	stw	r2,-24(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 3243f08:	0009883a 	mov	r4,zero
 3243f0c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      if (err == 0)
 3243f10:	e0bffa17 	ldw	r2,-24(fp)
 3243f14:	1004c03a 	cmpne	r2,r2,zero
 3243f18:	10000c1e 	bne	r2,zero,3243f4c <ip_raw_input+0x1f8>
         delivered = 1;
 3243f1c:	00800044 	movi	r2,1
 3243f20:	e0bff915 	stw	r2,-28(fp)
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 3243f24:	00000906 	br	3243f4c <ip_raw_input+0x1f8>
      if (err == 0)
         delivered = 1;
   }
   else
   {
      err = ENP_PARAM;
 3243f28:	00bffd84 	movi	r2,-10
 3243f2c:	e0bffa15 	stw	r2,-24(fp)
      ip_mib.ipUnknownProtos++;
 3243f30:	0080c9b4 	movhi	r2,806
 3243f34:	10b54b04 	addi	r2,r2,-10964
 3243f38:	10800617 	ldw	r2,24(r2)
 3243f3c:	10c00044 	addi	r3,r2,1
 3243f40:	0080c9b4 	movhi	r2,806
 3243f44:	10b54b04 	addi	r2,r2,-10964
 3243f48:	10c00615 	stw	r3,24(r2)
   }

   if (!delivered)
 3243f4c:	e0bff917 	ldw	r2,-28(fp)
 3243f50:	1004c03a 	cmpne	r2,r2,zero
 3243f54:	1000071e 	bne	r2,zero,3243f74 <ip_raw_input+0x220>
      ip_mib.ipInDelivers--;
 3243f58:	0080c9b4 	movhi	r2,806
 3243f5c:	10b54b04 	addi	r2,r2,-10964
 3243f60:	10800817 	ldw	r2,32(r2)
 3243f64:	10ffffc4 	addi	r3,r2,-1
 3243f68:	0080c9b4 	movhi	r2,806
 3243f6c:	10b54b04 	addi	r2,r2,-10964
 3243f70:	10c00815 	stw	r3,32(r2)

   return err;
 3243f74:	e0bffa17 	ldw	r2,-24(fp)
}
 3243f78:	e037883a 	mov	sp,fp
 3243f7c:	dfc00117 	ldw	ra,4(sp)
 3243f80:	df000017 	ldw	fp,0(sp)
 3243f84:	dec00204 	addi	sp,sp,8
 3243f88:	f800283a 	ret

03243f8c <ip_raw_alloc>:
 *          inclhdr is zero.
 */

PACKET
ip_raw_alloc(int reqlen, int hdrincl)
{
 3243f8c:	defffa04 	addi	sp,sp,-24
 3243f90:	dfc00515 	stw	ra,20(sp)
 3243f94:	df000415 	stw	fp,16(sp)
 3243f98:	df000404 	addi	fp,sp,16
 3243f9c:	e13ffe15 	stw	r4,-8(fp)
 3243fa0:	e17fff15 	stw	r5,-4(fp)
   int len;
   PACKET p;

   len = (reqlen + 1) & ~1;
 3243fa4:	e0bffe17 	ldw	r2,-8(fp)
 3243fa8:	10c00044 	addi	r3,r2,1
 3243fac:	00bfff84 	movi	r2,-2
 3243fb0:	1884703a 	and	r2,r3,r2
 3243fb4:	e0bffd15 	stw	r2,-12(fp)
   if (!hdrincl)
 3243fb8:	e0bfff17 	ldw	r2,-4(fp)
 3243fbc:	1004c03a 	cmpne	r2,r2,zero
 3243fc0:	1000031e 	bne	r2,zero,3243fd0 <ip_raw_alloc+0x44>
      len += IPHSIZ;
 3243fc4:	e0bffd17 	ldw	r2,-12(fp)
 3243fc8:	10800504 	addi	r2,r2,20
 3243fcc:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 3243fd0:	01000084 	movi	r4,2
 3243fd4:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + MaxLnh);
 3243fd8:	0080c974 	movhi	r2,805
 3243fdc:	10931a04 	addi	r2,r2,19560
 3243fe0:	10c00017 	ldw	r3,0(r2)
 3243fe4:	e0bffd17 	ldw	r2,-12(fp)
 3243fe8:	1885883a 	add	r2,r3,r2
 3243fec:	1009883a 	mov	r4,r2
 3243ff0:	322a2ac0 	call	322a2ac <pk_alloc>
 3243ff4:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3243ff8:	01000084 	movi	r4,2
 3243ffc:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   if (p)
 3244000:	e0bffc17 	ldw	r2,-16(fp)
 3244004:	1005003a 	cmpeq	r2,r2,zero
 3244008:	10000d1e 	bne	r2,zero,3244040 <ip_raw_alloc+0xb4>
   {
      if (!hdrincl)
 324400c:	e0bfff17 	ldw	r2,-4(fp)
 3244010:	1004c03a 	cmpne	r2,r2,zero
 3244014:	10000a1e 	bne	r2,zero,3244040 <ip_raw_alloc+0xb4>
      {
         p->nb_prot += IPHSIZ;
 3244018:	e0bffc17 	ldw	r2,-16(fp)
 324401c:	10800317 	ldw	r2,12(r2)
 3244020:	10c00504 	addi	r3,r2,20
 3244024:	e0bffc17 	ldw	r2,-16(fp)
 3244028:	10c00315 	stw	r3,12(r2)
         p->nb_plen -= IPHSIZ;
 324402c:	e0bffc17 	ldw	r2,-16(fp)
 3244030:	10800417 	ldw	r2,16(r2)
 3244034:	10fffb04 	addi	r3,r2,-20
 3244038:	e0bffc17 	ldw	r2,-16(fp)
 324403c:	10c00415 	stw	r3,16(r2)
      }
   }
   return p;
 3244040:	e0bffc17 	ldw	r2,-16(fp)
}
 3244044:	e037883a 	mov	sp,fp
 3244048:	dfc00117 	ldw	ra,4(sp)
 324404c:	df000017 	ldw	fp,0(sp)
 3244050:	dec00204 	addi	sp,sp,8
 3244054:	f800283a 	ret

03244058 <ip_raw_free>:
 * RETURNS: void
 */

void
ip_raw_free(PACKET p)
{
 3244058:	defffd04 	addi	sp,sp,-12
 324405c:	dfc00215 	stw	ra,8(sp)
 3244060:	df000115 	stw	fp,4(sp)
 3244064:	df000104 	addi	fp,sp,4
 3244068:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 324406c:	01000084 	movi	r4,2
 3244070:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   pk_free(p);
 3244074:	e13fff17 	ldw	r4,-4(fp)
 3244078:	322a6400 	call	322a640 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324407c:	01000084 	movi	r4,2
 3244080:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
}
 3244084:	e037883a 	mov	sp,fp
 3244088:	dfc00117 	ldw	ra,4(sp)
 324408c:	df000017 	ldw	fp,0(sp)
 3244090:	dec00204 	addi	sp,sp,8
 3244094:	f800283a 	ret

03244098 <ip_raw_maxalloc>:
 *          for 
 */

int
ip_raw_maxalloc(int hdrincl)
{
 3244098:	defffd04 	addi	sp,sp,-12
 324409c:	df000215 	stw	fp,8(sp)
 32440a0:	df000204 	addi	fp,sp,8
 32440a4:	e13fff15 	stw	r4,-4(fp)
   int len;

   len = bigbufsiz - MaxLnh;
 32440a8:	0080c974 	movhi	r2,805
 32440ac:	108a9704 	addi	r2,r2,10844
 32440b0:	10c00017 	ldw	r3,0(r2)
 32440b4:	0080c974 	movhi	r2,805
 32440b8:	10931a04 	addi	r2,r2,19560
 32440bc:	10800017 	ldw	r2,0(r2)
 32440c0:	1885c83a 	sub	r2,r3,r2
 32440c4:	e0bffe15 	stw	r2,-8(fp)
   if (!hdrincl)
 32440c8:	e0bfff17 	ldw	r2,-4(fp)
 32440cc:	1004c03a 	cmpne	r2,r2,zero
 32440d0:	1000031e 	bne	r2,zero,32440e0 <ip_raw_maxalloc+0x48>
      len -= IPHSIZ;
 32440d4:	e0bffe17 	ldw	r2,-8(fp)
 32440d8:	10bffb04 	addi	r2,r2,-20
 32440dc:	e0bffe15 	stw	r2,-8(fp)
   return len;
 32440e0:	e0bffe17 	ldw	r2,-8(fp)
}
 32440e4:	e037883a 	mov	sp,fp
 32440e8:	df000017 	ldw	fp,0(sp)
 32440ec:	dec00104 	addi	sp,sp,4
 32440f0:	f800283a 	ret

032440f4 <rt_lookup>:
 * entry was found.
 */

RTMIB
rt_lookup(ip_addr host)
{
 32440f4:	defff804 	addi	sp,sp,-32
 32440f8:	df000715 	stw	fp,28(sp)
 32440fc:	df000704 	addi	fp,sp,28
 3244100:	e13fff15 	stw	r4,-4(fp)
   RTMIB    rtp;
   RTMIB    netmatch;
   unsigned char max_bits_matched = 0;
 3244104:	e03ffc45 	stb	zero,-15(fp)
   unsigned char curr_bits_matched;
   ip_addr  entry_mask;
   unsigned long int bitcount_mask;
   unsigned long int extracted_bit;

   netmatch = NULL;
 3244108:	e03ffd15 	stw	zero,-12(fp)

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 324410c:	0080c974 	movhi	r2,805
 3244110:	10935f04 	addi	r2,r2,19836
 3244114:	10800017 	ldw	r2,0(r2)
 3244118:	e0bffe15 	stw	r2,-8(fp)
 324411c:	00003e06 	br	3244218 <rt_lookup+0x124>
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
 3244120:	e0bffe17 	ldw	r2,-8(fp)
 3244124:	10800617 	ldw	r2,24(r2)
 3244128:	1005003a 	cmpeq	r2,r2,zero
 324412c:	1000371e 	bne	r2,zero,324420c <rt_lookup+0x118>
#ifdef RIP_SUPPORT
      /* skip RIP private entries */
      if (rtp->ipRouteFlags & RIP_PRIVATE)
         continue;
#endif
      entry_mask = rtp->ipRouteMask;
 3244130:	e0bffe17 	ldw	r2,-8(fp)
 3244134:	10800a17 	ldw	r2,40(r2)
 3244138:	e0bffb15 	stw	r2,-20(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
 324413c:	e0bffe17 	ldw	r2,-8(fp)
 3244140:	10c00017 	ldw	r3,0(r2)
 3244144:	e0bffb17 	ldw	r2,-20(fp)
 3244148:	1888703a 	and	r4,r3,r2
 324414c:	e0ffff17 	ldw	r3,-4(fp)
 3244150:	e0bffb17 	ldw	r2,-20(fp)
 3244154:	1884703a 	and	r2,r3,r2
 3244158:	20802c1e 	bne	r4,r2,324420c <rt_lookup+0x118>
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 324415c:	e03ffc05 	stb	zero,-16(fp)
 3244160:	00a00034 	movhi	r2,32768
 3244164:	e0bffa15 	stw	r2,-24(fp)
 3244168:	00001b06 	br	32441d8 <rt_lookup+0xe4>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
 324416c:	e0bffb17 	ldw	r2,-20(fp)
 3244170:	1004d63a 	srli	r2,r2,24
 3244174:	10c03fcc 	andi	r3,r2,255
 3244178:	e0bffb17 	ldw	r2,-20(fp)
 324417c:	1004d23a 	srli	r2,r2,8
 3244180:	10bfc00c 	andi	r2,r2,65280
 3244184:	1886b03a 	or	r3,r3,r2
 3244188:	e0bffb17 	ldw	r2,-20(fp)
 324418c:	10bfc00c 	andi	r2,r2,65280
 3244190:	1004923a 	slli	r2,r2,8
 3244194:	1886b03a 	or	r3,r3,r2
 3244198:	e0bffb17 	ldw	r2,-20(fp)
 324419c:	10803fcc 	andi	r2,r2,255
 32441a0:	1004963a 	slli	r2,r2,24
 32441a4:	1886b03a 	or	r3,r3,r2
 32441a8:	e0bffa17 	ldw	r2,-24(fp)
 32441ac:	1884703a 	and	r2,r3,r2
 32441b0:	e0bff915 	stw	r2,-28(fp)
            if (extracted_bit) ++curr_bits_matched;
 32441b4:	e0bff917 	ldw	r2,-28(fp)
 32441b8:	1005003a 	cmpeq	r2,r2,zero
 32441bc:	1000031e 	bne	r2,zero,32441cc <rt_lookup+0xd8>
 32441c0:	e0bffc03 	ldbu	r2,-16(fp)
 32441c4:	10800044 	addi	r2,r2,1
 32441c8:	e0bffc05 	stb	r2,-16(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 32441cc:	e0bffa17 	ldw	r2,-24(fp)
 32441d0:	1004d07a 	srli	r2,r2,1
 32441d4:	e0bffa15 	stw	r2,-24(fp)
 32441d8:	e0bffa17 	ldw	r2,-24(fp)
 32441dc:	1004c03a 	cmpne	r2,r2,zero
 32441e0:	103fe21e 	bne	r2,zero,324416c <rt_lookup+0x78>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
            if (extracted_bit) ++curr_bits_matched;
         }
         if (curr_bits_matched > max_bits_matched)
 32441e4:	e0fffc03 	ldbu	r3,-16(fp)
 32441e8:	e0bffc43 	ldbu	r2,-15(fp)
 32441ec:	10c0072e 	bgeu	r2,r3,324420c <rt_lookup+0x118>
         {
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
 32441f0:	e0bffc03 	ldbu	r2,-16(fp)
 32441f4:	e0bffc45 	stb	r2,-15(fp)
            netmatch = rtp;
 32441f8:	e0bffe17 	ldw	r2,-8(fp)
 32441fc:	e0bffd15 	stw	r2,-12(fp)
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
 3244200:	e0bffc43 	ldbu	r2,-15(fp)
 3244204:	10800820 	cmpeqi	r2,r2,32
 3244208:	10000e1e 	bne	r2,zero,3244244 <rt_lookup+0x150>
   unsigned long int extracted_bit;

   netmatch = NULL;

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 324420c:	e0bffe17 	ldw	r2,-8(fp)
 3244210:	10800f04 	addi	r2,r2,60
 3244214:	e0bffe15 	stw	r2,-8(fp)
 3244218:	0080c974 	movhi	r2,805
 324421c:	108aaf04 	addi	r2,r2,10940
 3244220:	10800017 	ldw	r2,0(r2)
 3244224:	10800f24 	muli	r2,r2,60
 3244228:	1007883a 	mov	r3,r2
 324422c:	0080c974 	movhi	r2,805
 3244230:	10935f04 	addi	r2,r2,19836
 3244234:	10800017 	ldw	r2,0(r2)
 3244238:	1887883a 	add	r3,r3,r2
 324423c:	e0bffe17 	ldw	r2,-8(fp)
 3244240:	10ffb736 	bltu	r2,r3,3244120 <rt_lookup+0x2c>
               break;
         }
      }
   }

   if (netmatch)
 3244244:	e0bffd17 	ldw	r2,-12(fp)
 3244248:	1005003a 	cmpeq	r2,r2,zero
 324424c:	1000051e 	bne	r2,zero,3244264 <rt_lookup+0x170>
      netmatch->ipRouteAge = cticks;   /* timestamp entry we used */
 3244250:	0080c974 	movhi	r2,805
 3244254:	10934104 	addi	r2,r2,19716
 3244258:	10c00017 	ldw	r3,0(r2)
 324425c:	e0bffd17 	ldw	r2,-12(fp)
 3244260:	10c00915 	stw	r3,36(r2)

   return netmatch;
 3244264:	e0bffd17 	ldw	r2,-12(fp)
}
 3244268:	e037883a 	mov	sp,fp
 324426c:	df000017 	ldw	fp,0(sp)
 3244270:	dec00104 	addi	sp,sp,4
 3244274:	f800283a 	ret

03244278 <add_route>:
   ip_addr  dest,       /* ultimate destination */
   ip_addr  mask,       /* net mask, 0xFFFFFFFF if dest is host address */
   ip_addr  nexthop,    /* where to forward to */
   int      iface,      /* interface (net) for nexthop */
   int      prot)       /* how we know it: icmp, table, etc */
{
 3244278:	defff604 	addi	sp,sp,-40
 324427c:	dfc00915 	stw	ra,36(sp)
 3244280:	df000815 	stw	fp,32(sp)
 3244284:	df000804 	addi	fp,sp,32
 3244288:	e13ffb15 	stw	r4,-20(fp)
 324428c:	e17ffc15 	stw	r5,-16(fp)
 3244290:	e1bffd15 	stw	r6,-12(fp)
 3244294:	e1fffe15 	stw	r7,-8(fp)
   RTMIB rtp;           /* scratch route table entrry pointer */
   RTMIB newrt;         /* best entry for new route */
   struct net * ifp;    /* interface (net) for nexthop */

   newrt = NULL;     /* may be replaced with empty or more expendable entry */
 3244298:	e03ff915 	stw	zero,-28(fp)
					 
   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   ifp = if_getbynum(iface);
 324429c:	e13ffe17 	ldw	r4,-8(fp)
 32442a0:	323e6bc0 	call	323e6bc <if_getbynum>
 32442a4:	e0bff815 	stw	r2,-32(fp)
   if(!ifp)
 32442a8:	e0bff817 	ldw	r2,-32(fp)
 32442ac:	1004c03a 	cmpne	r2,r2,zero
 32442b0:	1000021e 	bne	r2,zero,32442bc <add_route+0x44>
      return NULL;
 32442b4:	e03fff15 	stw	zero,-4(fp)
 32442b8:	0000f306 	br	3244688 <add_route+0x410>

   if (rt_mib == NULL)
 32442bc:	0080c974 	movhi	r2,805
 32442c0:	10935f04 	addi	r2,r2,19836
 32442c4:	10800017 	ldw	r2,0(r2)
 32442c8:	1004c03a 	cmpne	r2,r2,zero
 32442cc:	1000021e 	bne	r2,zero,32442d8 <add_route+0x60>
      return NULL;
 32442d0:	e03fff15 	stw	zero,-4(fp)
 32442d4:	0000ec06 	br	3244688 <add_route+0x410>

   /* Don't add null masks or IP addresses - they give false positives on
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
 32442d8:	e0bffb17 	ldw	r2,-20(fp)
 32442dc:	1005003a 	cmpeq	r2,r2,zero
 32442e0:	1000031e 	bne	r2,zero,32442f0 <add_route+0x78>
 32442e4:	e0bffc17 	ldw	r2,-16(fp)
 32442e8:	1004c03a 	cmpne	r2,r2,zero
 32442ec:	1000241e 	bne	r2,zero,3244380 <add_route+0x108>
   {
      dtrap();    /* bad configuration? */
 32442f0:	322aef00 	call	322aef0 <dtrap>
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 32442f4:	e0bffb17 	ldw	r2,-20(fp)
 32442f8:	1004d63a 	srli	r2,r2,24
 32442fc:	10c03fcc 	andi	r3,r2,255
 3244300:	e0bffb17 	ldw	r2,-20(fp)
 3244304:	1004d23a 	srli	r2,r2,8
 3244308:	10bfc00c 	andi	r2,r2,65280
 324430c:	1886b03a 	or	r3,r3,r2
 3244310:	e0bffb17 	ldw	r2,-20(fp)
 3244314:	10bfc00c 	andi	r2,r2,65280
 3244318:	1004923a 	slli	r2,r2,8
 324431c:	1886b03a 	or	r3,r3,r2
 3244320:	e0bffb17 	ldw	r2,-20(fp)
 3244324:	10803fcc 	andi	r2,r2,255
 3244328:	1004963a 	slli	r2,r2,24
 324432c:	188ab03a 	or	r5,r3,r2
 3244330:	e0bffc17 	ldw	r2,-16(fp)
 3244334:	1004d63a 	srli	r2,r2,24
 3244338:	10c03fcc 	andi	r3,r2,255
 324433c:	e0bffc17 	ldw	r2,-16(fp)
 3244340:	1004d23a 	srli	r2,r2,8
 3244344:	10bfc00c 	andi	r2,r2,65280
 3244348:	1886b03a 	or	r3,r3,r2
 324434c:	e0bffc17 	ldw	r2,-16(fp)
 3244350:	10bfc00c 	andi	r2,r2,65280
 3244354:	1004923a 	slli	r2,r2,8
 3244358:	1886b03a 	or	r3,r3,r2
 324435c:	e0bffc17 	ldw	r2,-16(fp)
 3244360:	10803fcc 	andi	r2,r2,255
 3244364:	1004963a 	slli	r2,r2,24
 3244368:	188cb03a 	or	r6,r3,r2
 324436c:	0100c974 	movhi	r4,805
 3244370:	21004304 	addi	r4,r4,268
 3244374:	3206de00 	call	3206de0 <printf>
	      htonl(dest), htonl(mask) );
      return NULL;
 3244378:	e03fff15 	stw	zero,-4(fp)
 324437c:	0000c206 	br	3244688 <add_route+0x410>
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 3244380:	0080c974 	movhi	r2,805
 3244384:	10935f04 	addi	r2,r2,19836
 3244388:	10800017 	ldw	r2,0(r2)
 324438c:	e0bffa15 	stw	r2,-24(fp)
 3244390:	00006f06 	br	3244550 <add_route+0x2d8>
   {
      if (rtp->ipRouteDest == dest) /* found existing entry for target */
 3244394:	e0bffa17 	ldw	r2,-24(fp)
 3244398:	10c00017 	ldw	r3,0(r2)
 324439c:	e0bffb17 	ldw	r2,-20(fp)
 32443a0:	1880181e 	bne	r3,r2,3244404 <add_route+0x18c>
      {
         rtp->ipRouteNextHop = nexthop;      /* fix entry */
 32443a4:	e0fffa17 	ldw	r3,-24(fp)
 32443a8:	e0bffd17 	ldw	r2,-12(fp)
 32443ac:	18800615 	stw	r2,24(r3)
         rtp->ipRouteAge = cticks;           /* timestamp it */
 32443b0:	0080c974 	movhi	r2,805
 32443b4:	10934104 	addi	r2,r2,19716
 32443b8:	10c00017 	ldw	r3,0(r2)
 32443bc:	e0bffa17 	ldw	r2,-24(fp)
 32443c0:	10c00915 	stw	r3,36(r2)
         /* set the rfc1213 1-based SNMP-ish interface index */
         rtp->ipRouteIfIndex = (long)(iface) + 1;
 32443c4:	e0bffe17 	ldw	r2,-8(fp)
 32443c8:	10c00044 	addi	r3,r2,1
 32443cc:	e0bffa17 	ldw	r2,-24(fp)
 32443d0:	10c00115 	stw	r3,4(r2)
         rtp->ipRouteProto = prot;           /* icmp, or whatever */
 32443d4:	e0fffa17 	ldw	r3,-24(fp)
 32443d8:	e0800217 	ldw	r2,8(fp)
 32443dc:	18800815 	stw	r2,32(r3)
         rtp->ipRouteMask = mask;
 32443e0:	e0fffa17 	ldw	r3,-24(fp)
 32443e4:	e0bffc17 	ldw	r2,-16(fp)
 32443e8:	18800a15 	stw	r2,40(r3)
         rtp->ifp = ifp;
 32443ec:	e0fffa17 	ldw	r3,-24(fp)
 32443f0:	e0bff817 	ldw	r2,-32(fp)
 32443f4:	18800e15 	stw	r2,56(r3)
         return(rtp);   /* just update and exit */
 32443f8:	e0bffa17 	ldw	r2,-24(fp)
 32443fc:	e0bfff15 	stw	r2,-4(fp)
 3244400:	0000a106 	br	3244688 <add_route+0x410>
      }
      /* if we didn't find empty slot yet, look for good slot to recycle */
      if (!newrt || (newrt->ipRouteProto != 0))
 3244404:	e0bff917 	ldw	r2,-28(fp)
 3244408:	1005003a 	cmpeq	r2,r2,zero
 324440c:	1000041e 	bne	r2,zero,3244420 <add_route+0x1a8>
 3244410:	e0bff917 	ldw	r2,-28(fp)
 3244414:	10800817 	ldw	r2,32(r2)
 3244418:	1005003a 	cmpeq	r2,r2,zero
 324441c:	1000491e 	bne	r2,zero,3244544 <add_route+0x2cc>
      {
         if (!rtp->ipRouteNextHop)  /* found empty slot for use */
 3244420:	e0bffa17 	ldw	r2,-24(fp)
 3244424:	10800617 	ldw	r2,24(r2)
 3244428:	1004c03a 	cmpne	r2,r2,zero
 324442c:	1000051e 	bne	r2,zero,3244444 <add_route+0x1cc>
         {
            newrt = rtp;   /* record empty route for use */
 3244430:	e0bffa17 	ldw	r2,-24(fp)
 3244434:	e0bff915 	stw	r2,-28(fp)
            newrt->ipRouteProto = 0;
 3244438:	e0bff917 	ldw	r2,-28(fp)
 324443c:	10000815 	stw	zero,32(r2)
            continue;
 3244440:	00004006 	br	3244544 <add_route+0x2cc>
         }
         /* else see if the new route has higher priority than this slot: */
         if (rtp_priority[prot] >= rtp_priority[rtp->ipRouteProto])
 3244444:	e0c00217 	ldw	r3,8(fp)
 3244448:	0080c974 	movhi	r2,805
 324444c:	108a0404 	addi	r2,r2,10256
 3244450:	10c5883a 	add	r2,r2,r3
 3244454:	11000003 	ldbu	r4,0(r2)
 3244458:	e0bffa17 	ldw	r2,-24(fp)
 324445c:	10c00817 	ldw	r3,32(r2)
 3244460:	0080c974 	movhi	r2,805
 3244464:	108a0404 	addi	r2,r2,10256
 3244468:	10c5883a 	add	r2,r2,r3
 324446c:	10800003 	ldbu	r2,0(r2)
 3244470:	20c03fcc 	andi	r3,r4,255
 3244474:	10803fcc 	andi	r2,r2,255
 3244478:	18803236 	bltu	r3,r2,3244544 <add_route+0x2cc>
         {
            if (!newrt)
 324447c:	e0bff917 	ldw	r2,-28(fp)
 3244480:	1004c03a 	cmpne	r2,r2,zero
 3244484:	1000031e 	bne	r2,zero,3244494 <add_route+0x21c>
            {
               newrt = rtp;
 3244488:	e0bffa17 	ldw	r2,-24(fp)
 324448c:	e0bff915 	stw	r2,-28(fp)
               continue;
 3244490:	00002c06 	br	3244544 <add_route+0x2cc>
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 3244494:	e0bffa17 	ldw	r2,-24(fp)
 3244498:	10c00817 	ldw	r3,32(r2)
 324449c:	0080c974 	movhi	r2,805
 32444a0:	108a0404 	addi	r2,r2,10256
 32444a4:	10c5883a 	add	r2,r2,r3
 32444a8:	11000003 	ldbu	r4,0(r2)
 32444ac:	e0bff917 	ldw	r2,-28(fp)
 32444b0:	10c00817 	ldw	r3,32(r2)
 32444b4:	0080c974 	movhi	r2,805
 32444b8:	108a0404 	addi	r2,r2,10256
 32444bc:	10c5883a 	add	r2,r2,r3
 32444c0:	10800003 	ldbu	r2,0(r2)
 32444c4:	20c03fcc 	andi	r3,r4,255
 32444c8:	10803fcc 	andi	r2,r2,255
 32444cc:	1880032e 	bgeu	r3,r2,32444dc <add_route+0x264>
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
 32444d0:	e0bffa17 	ldw	r2,-24(fp)
 32444d4:	e0bff915 	stw	r2,-28(fp)
 32444d8:	00001a06 	br	3244544 <add_route+0x2cc>
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 32444dc:	e0bffa17 	ldw	r2,-24(fp)
 32444e0:	10c00817 	ldw	r3,32(r2)
 32444e4:	0080c974 	movhi	r2,805
 32444e8:	108a0404 	addi	r2,r2,10256
 32444ec:	10c5883a 	add	r2,r2,r3
 32444f0:	11000003 	ldbu	r4,0(r2)
 32444f4:	e0bff917 	ldw	r2,-28(fp)
 32444f8:	10c00817 	ldw	r3,32(r2)
 32444fc:	0080c974 	movhi	r2,805
 3244500:	108a0404 	addi	r2,r2,10256
 3244504:	10c5883a 	add	r2,r2,r3
 3244508:	10800003 	ldbu	r2,0(r2)
 324450c:	20c03fcc 	andi	r3,r4,255
 3244510:	10803fcc 	andi	r2,r2,255
 3244514:	18800b1e 	bne	r3,r2,3244544 <add_route+0x2cc>
                rtp_priority[newrt->ipRouteProto])
            {
               /* if equal priority, keep the older entry for deletion */
               if (c_older(rtp->ipRouteAge, newrt->ipRouteAge) == rtp->ipRouteAge)
 3244518:	e0bffa17 	ldw	r2,-24(fp)
 324451c:	11000917 	ldw	r4,36(r2)
 3244520:	e0bff917 	ldw	r2,-28(fp)
 3244524:	11400917 	ldw	r5,36(r2)
 3244528:	3223a280 	call	3223a28 <c_older>
 324452c:	1007883a 	mov	r3,r2
 3244530:	e0bffa17 	ldw	r2,-24(fp)
 3244534:	10800917 	ldw	r2,36(r2)
 3244538:	1880021e 	bne	r3,r2,3244544 <add_route+0x2cc>
                  newrt = rtp;   /* got an older one */
 324453c:	e0bffa17 	ldw	r2,-24(fp)
 3244540:	e0bff915 	stw	r2,-28(fp)
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 3244544:	e0bffa17 	ldw	r2,-24(fp)
 3244548:	10800f04 	addi	r2,r2,60
 324454c:	e0bffa15 	stw	r2,-24(fp)
 3244550:	0080c974 	movhi	r2,805
 3244554:	108aaf04 	addi	r2,r2,10940
 3244558:	10800017 	ldw	r2,0(r2)
 324455c:	10800f24 	muli	r2,r2,60
 3244560:	1007883a 	mov	r3,r2
 3244564:	0080c974 	movhi	r2,805
 3244568:	10935f04 	addi	r2,r2,19836
 324456c:	10800017 	ldw	r2,0(r2)
 3244570:	1887883a 	add	r3,r3,r2
 3244574:	e0bffa17 	ldw	r2,-24(fp)
 3244578:	10ff8636 	bltu	r2,r3,3244394 <add_route+0x11c>
         }
      }
   }

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
 324457c:	e0bff917 	ldw	r2,-28(fp)
 3244580:	1005003a 	cmpeq	r2,r2,zero
 3244584:	10002a1e 	bne	r2,zero,3244630 <add_route+0x3b8>
      rtp = newrt;   /* create new entry in lowest priority slot */
 3244588:	e0bff917 	ldw	r2,-28(fp)
 324458c:	e0bffa15 	stw	r2,-24(fp)
   else  /* all slots have higher priority, new entry looses */
      return NULL;

   /* set default value in new route entry, caller can modiy further. */
   rtp->ifp = ifp;
 3244590:	e0fffa17 	ldw	r3,-24(fp)
 3244594:	e0bff817 	ldw	r2,-32(fp)
 3244598:	18800e15 	stw	r2,56(r3)
   rtp->ipRouteDest = dest;
 324459c:	e0fffa17 	ldw	r3,-24(fp)
 32445a0:	e0bffb17 	ldw	r2,-20(fp)
 32445a4:	18800015 	stw	r2,0(r3)
   rtp->ipRouteIfIndex = (long)(if_netnumber(ifp)) + 1; /* set interface number */
 32445a8:	e13ff817 	ldw	r4,-32(fp)
 32445ac:	32240bc0 	call	32240bc <if_netnumber>
 32445b0:	10c00044 	addi	r3,r2,1
 32445b4:	e0bffa17 	ldw	r2,-24(fp)
 32445b8:	10c00115 	stw	r3,4(r2)
   rtp->ipRouteMetric1 = ip_mib.ipDefaultTTL;
 32445bc:	0080c9b4 	movhi	r2,806
 32445c0:	10b54b04 	addi	r2,r2,-10964
 32445c4:	10800117 	ldw	r2,4(r2)
 32445c8:	1007883a 	mov	r3,r2
 32445cc:	e0bffa17 	ldw	r2,-24(fp)
 32445d0:	10c00215 	stw	r3,8(r2)
   rtp->ipRouteMetric2 = -1;
 32445d4:	e0fffa17 	ldw	r3,-24(fp)
 32445d8:	00bfffc4 	movi	r2,-1
 32445dc:	18800315 	stw	r2,12(r3)
   rtp->ipRouteMetric3 = -1;
 32445e0:	e0fffa17 	ldw	r3,-24(fp)
 32445e4:	00bfffc4 	movi	r2,-1
 32445e8:	18800415 	stw	r2,16(r3)
   rtp->ipRouteMetric4 = -1;
 32445ec:	e0fffa17 	ldw	r3,-24(fp)
 32445f0:	00bfffc4 	movi	r2,-1
 32445f4:	18800515 	stw	r2,20(r3)
   rtp->ipRouteNextHop = nexthop;
 32445f8:	e0fffa17 	ldw	r3,-24(fp)
 32445fc:	e0bffd17 	ldw	r2,-12(fp)
 3244600:	18800615 	stw	r2,24(r3)
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */
 3244604:	e0fffa17 	ldw	r3,-24(fp)
 3244608:	e0800217 	ldw	r2,8(fp)
 324460c:	18800815 	stw	r2,32(r3)

   if ((dest & mask) == (nexthop & mask))
 3244610:	e0fffb17 	ldw	r3,-20(fp)
 3244614:	e0bffc17 	ldw	r2,-16(fp)
 3244618:	1888703a 	and	r4,r3,r2
 324461c:	e0fffd17 	ldw	r3,-12(fp)
 3244620:	e0bffc17 	ldw	r2,-16(fp)
 3244624:	1884703a 	and	r2,r3,r2
 3244628:	20800326 	beq	r4,r2,3244638 <add_route+0x3c0>
 324462c:	00000606 	br	3244648 <add_route+0x3d0>

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
      rtp = newrt;   /* create new entry in lowest priority slot */
   else  /* all slots have higher priority, new entry looses */
      return NULL;
 3244630:	e03fff15 	stw	zero,-4(fp)
 3244634:	00001406 	br	3244688 <add_route+0x410>
   rtp->ipRouteMetric4 = -1;
   rtp->ipRouteNextHop = nexthop;
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */

   if ((dest & mask) == (nexthop & mask))
      rtp->ipRouteType = IPRT_DIRECT;
 3244638:	e0fffa17 	ldw	r3,-24(fp)
 324463c:	008000c4 	movi	r2,3
 3244640:	18800715 	stw	r2,28(r3)
 3244644:	00000306 	br	3244654 <add_route+0x3dc>
   else
      rtp->ipRouteType = IPRT_INDIRECT;
 3244648:	e0fffa17 	ldw	r3,-24(fp)
 324464c:	00800104 	movi	r2,4
 3244650:	18800715 	stw	r2,28(r3)

   rtp->ipRouteAge = cticks;        /* timestamp it */
 3244654:	0080c974 	movhi	r2,805
 3244658:	10934104 	addi	r2,r2,19716
 324465c:	10c00017 	ldw	r3,0(r2)
 3244660:	e0bffa17 	ldw	r2,-24(fp)
 3244664:	10c00915 	stw	r3,36(r2)
   rtp->ipRouteMask = mask;
 3244668:	e0fffa17 	ldw	r3,-24(fp)
 324466c:	e0bffc17 	ldw	r2,-16(fp)
 3244670:	18800a15 	stw	r2,40(r3)
   rtp->ipRouteMetric5 = -1;
 3244674:	e0fffa17 	ldw	r3,-24(fp)
 3244678:	00bfffc4 	movi	r2,-1
 324467c:	18800b15 	stw	r2,44(r3)
   return(rtp);
 3244680:	e0bffa17 	ldw	r2,-24(fp)
 3244684:	e0bfff15 	stw	r2,-4(fp)
 3244688:	e0bfff17 	ldw	r2,-4(fp)
}
 324468c:	e037883a 	mov	sp,fp
 3244690:	dfc00117 	ldw	ra,4(sp)
 3244694:	df000017 	ldw	fp,0(sp)
 3244698:	dec00204 	addi	sp,sp,8
 324469c:	f800283a 	ret

032446a0 <del_route>:
 * RETURNS: Returns number of route table entries deleted. 
 */

int
del_route(ip_addr dest, ip_addr mask, int iface)
{
 32446a0:	defff704 	addi	sp,sp,-36
 32446a4:	dfc00815 	stw	ra,32(sp)
 32446a8:	df000715 	stw	fp,28(sp)
 32446ac:	df000704 	addi	fp,sp,28
 32446b0:	e13ffc15 	stw	r4,-16(fp)
 32446b4:	e17ffd15 	stw	r5,-12(fp)
 32446b8:	e1bffe15 	stw	r6,-8(fp)
   RTMIB rtp;
   int   retval   =  0;
 32446bc:	e03ffa15 	stw	zero,-24(fp)

   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   if(iface == -1)
 32446c0:	e0bffe17 	ldw	r2,-8(fp)
 32446c4:	10bfffd8 	cmpnei	r2,r2,-1
 32446c8:	1000021e 	bne	r2,zero,32446d4 <del_route+0x34>
      ifp = NULL;    /* wildcard */
 32446cc:	e03ff915 	stw	zero,-28(fp)
 32446d0:	00000306 	br	32446e0 <del_route+0x40>
   else
      ifp = if_getbynum(iface);
 32446d4:	e13ffe17 	ldw	r4,-8(fp)
 32446d8:	323e6bc0 	call	323e6bc <if_getbynum>
 32446dc:	e0bff915 	stw	r2,-28(fp)

   if (rt_mib == NULL)     /* Make sure we're up */
 32446e0:	0080c974 	movhi	r2,805
 32446e4:	10935f04 	addi	r2,r2,19836
 32446e8:	10800017 	ldw	r2,0(r2)
 32446ec:	1004c03a 	cmpne	r2,r2,zero
 32446f0:	1000021e 	bne	r2,zero,32446fc <del_route+0x5c>
      return 0;
 32446f4:	e03fff15 	stw	zero,-4(fp)
 32446f8:	00003406 	br	32447cc <del_route+0x12c>

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 32446fc:	0080c974 	movhi	r2,805
 3244700:	10935f04 	addi	r2,r2,19836
 3244704:	10800017 	ldw	r2,0(r2)
 3244708:	e0bffb15 	stw	r2,-20(fp)
 324470c:	00002206 	br	3244798 <del_route+0xf8>
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
 3244710:	e0bffb17 	ldw	r2,-20(fp)
 3244714:	10800617 	ldw	r2,24(r2)
 3244718:	1005003a 	cmpeq	r2,r2,zero
 324471c:	10001b1e 	bne	r2,zero,324478c <del_route+0xec>
         continue;
      if(ifp != NULL && ifp != rtp->ifp)
 3244720:	e0bff917 	ldw	r2,-28(fp)
 3244724:	1005003a 	cmpeq	r2,r2,zero
 3244728:	1000041e 	bne	r2,zero,324473c <del_route+0x9c>
 324472c:	e0bffb17 	ldw	r2,-20(fp)
 3244730:	10c00e17 	ldw	r3,56(r2)
 3244734:	e0bff917 	ldw	r2,-28(fp)
 3244738:	1880141e 	bne	r3,r2,324478c <del_route+0xec>
         continue;   /* interface didn't match */
      if ((rtp->ipRouteDest & mask) == (dest & mask))
 324473c:	e0bffb17 	ldw	r2,-20(fp)
 3244740:	10c00017 	ldw	r3,0(r2)
 3244744:	e0bffd17 	ldw	r2,-12(fp)
 3244748:	1888703a 	and	r4,r3,r2
 324474c:	e0fffc17 	ldw	r3,-16(fp)
 3244750:	e0bffd17 	ldw	r2,-12(fp)
 3244754:	1884703a 	and	r2,r3,r2
 3244758:	2080081e 	bne	r4,r2,324477c <del_route+0xdc>
      {
         MEMSET(rtp, 0, sizeof(*rtp)); /* clear entry */
 324475c:	e0bffb17 	ldw	r2,-20(fp)
 3244760:	1009883a 	mov	r4,r2
 3244764:	01800f04 	movi	r6,60
 3244768:	000b883a 	mov	r5,zero
 324476c:	3206c500 	call	3206c50 <memset>
         retval++;
 3244770:	e0bffa17 	ldw	r2,-24(fp)
 3244774:	10800044 	addi	r2,r2,1
 3244778:	e0bffa15 	stw	r2,-24(fp)
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
 324477c:	d0e90717 	ldw	r3,-23524(gp)
 3244780:	e0bffb17 	ldw	r2,-20(fp)
 3244784:	1880011e 	bne	r3,r2,324478c <del_route+0xec>
         cachedRoute = NULL;
 3244788:	d0290715 	stw	zero,-23524(gp)
      ifp = if_getbynum(iface);

   if (rt_mib == NULL)     /* Make sure we're up */
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 324478c:	e0bffb17 	ldw	r2,-20(fp)
 3244790:	10800f04 	addi	r2,r2,60
 3244794:	e0bffb15 	stw	r2,-20(fp)
 3244798:	0080c974 	movhi	r2,805
 324479c:	108aaf04 	addi	r2,r2,10940
 32447a0:	10800017 	ldw	r2,0(r2)
 32447a4:	10800f24 	muli	r2,r2,60
 32447a8:	1007883a 	mov	r3,r2
 32447ac:	0080c974 	movhi	r2,805
 32447b0:	10935f04 	addi	r2,r2,19836
 32447b4:	10800017 	ldw	r2,0(r2)
 32447b8:	1887883a 	add	r3,r3,r2
 32447bc:	e0bffb17 	ldw	r2,-20(fp)
 32447c0:	10ffd336 	bltu	r2,r3,3244710 <del_route+0x70>
         retval++;
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
         cachedRoute = NULL;
   }
   return retval;
 32447c4:	e0bffa17 	ldw	r2,-24(fp)
 32447c8:	e0bfff15 	stw	r2,-4(fp)
 32447cc:	e0bfff17 	ldw	r2,-4(fp)
}
 32447d0:	e037883a 	mov	sp,fp
 32447d4:	dfc00117 	ldw	ra,4(sp)
 32447d8:	df000017 	ldw	fp,0(sp)
 32447dc:	dec00204 	addi	sp,sp,8
 32447e0:	f800283a 	ret

032447e4 <udpdemux>:
 * RETURNS: 0 if OK or ENP error code
 */

int
udpdemux(PACKET p)
{
 32447e4:	deffec04 	addi	sp,sp,-80
 32447e8:	dfc01315 	stw	ra,76(sp)
 32447ec:	df001215 	stw	fp,72(sp)
 32447f0:	df001204 	addi	fp,sp,72
 32447f4:	e13ffe15 	stw	r4,-8(fp)
   unsigned short osum, xsum; /* scratch checksum holders */
   unsigned plen; /* packet length */
   int   e;    /* general error holder */

   /* First let's verify that it's a valid UDP packet. */
   pip = ip_head(p);       /* we'll need IP header info */
 32447f8:	e0bffe17 	ldw	r2,-8(fp)
 32447fc:	10800317 	ldw	r2,12(r2)
 3244800:	e0bffa15 	stw	r2,-24(fp)
   pup = (struct udp*)ip_data(pip);   /*  also need UDP header */
 3244804:	e0bffa17 	ldw	r2,-24(fp)
 3244808:	10800003 	ldbu	r2,0(r2)
 324480c:	10803fcc 	andi	r2,r2,255
 3244810:	108003cc 	andi	r2,r2,15
 3244814:	1085883a 	add	r2,r2,r2
 3244818:	1085883a 	add	r2,r2,r2
 324481c:	1007883a 	mov	r3,r2
 3244820:	e0bffa17 	ldw	r2,-24(fp)
 3244824:	1885883a 	add	r2,r3,r2
 3244828:	e0bff915 	stw	r2,-28(fp)
   plen = htons(pup->ud_len);
 324482c:	e0bff917 	ldw	r2,-28(fp)
 3244830:	1080010b 	ldhu	r2,4(r2)
 3244834:	10bfffcc 	andi	r2,r2,65535
 3244838:	1004d23a 	srli	r2,r2,8
 324483c:	10bfffcc 	andi	r2,r2,65535
 3244840:	10c03fcc 	andi	r3,r2,255
 3244844:	e0bff917 	ldw	r2,-28(fp)
 3244848:	1080010b 	ldhu	r2,4(r2)
 324484c:	10bfffcc 	andi	r2,r2,65535
 3244850:	1004923a 	slli	r2,r2,8
 3244854:	10bfc00c 	andi	r2,r2,65280
 3244858:	1884b03a 	or	r2,r3,r2
 324485c:	e0bff615 	stw	r2,-40(fp)

   if (plen > p->nb_plen)
 3244860:	e0bffe17 	ldw	r2,-8(fp)
 3244864:	10c00417 	ldw	r3,16(r2)
 3244868:	e0bff617 	ldw	r2,-40(fp)
 324486c:	18802a2e 	bgeu	r3,r2,3244918 <udpdemux+0x134>
#ifdef   NPDEBUG
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 3244870:	0080c974 	movhi	r2,805
 3244874:	10931c04 	addi	r2,r2,19568
 3244878:	10800017 	ldw	r2,0(r2)
 324487c:	1081000c 	andi	r2,r2,1024
 3244880:	1005003a 	cmpeq	r2,r2,zero
 3244884:	1000181e 	bne	r2,zero,32448e8 <udpdemux+0x104>
 3244888:	0080c974 	movhi	r2,805
 324488c:	10931c04 	addi	r2,r2,19568
 3244890:	10800017 	ldw	r2,0(r2)
 3244894:	1080400c 	andi	r2,r2,256
 3244898:	1005003a 	cmpeq	r2,r2,zero
 324489c:	1000121e 	bne	r2,zero,32448e8 <udpdemux+0x104>
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 32448a0:	e0bffe17 	ldw	r2,-8(fp)
 32448a4:	11400417 	ldw	r5,16(r2)
 32448a8:	e0bff917 	ldw	r2,-28(fp)
 32448ac:	1080010b 	ldhu	r2,4(r2)
 32448b0:	10bfffcc 	andi	r2,r2,65535
 32448b4:	1004d23a 	srli	r2,r2,8
 32448b8:	10bfffcc 	andi	r2,r2,65535
 32448bc:	10c03fcc 	andi	r3,r2,255
 32448c0:	e0bff917 	ldw	r2,-28(fp)
 32448c4:	1080010b 	ldhu	r2,4(r2)
 32448c8:	10bfffcc 	andi	r2,r2,65535
 32448cc:	1004923a 	slli	r2,r2,8
 32448d0:	10bfc00c 	andi	r2,r2,65280
 32448d4:	1884b03a 	or	r2,r3,r2
 32448d8:	11800204 	addi	r6,r2,8
 32448dc:	0100c974 	movhi	r4,805
 32448e0:	21005104 	addi	r4,r4,324
 32448e4:	3206de00 	call	3206de0 <printf>
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
#endif
      udp_mib.udpInErrors++;
 32448e8:	0080c9b4 	movhi	r2,806
 32448ec:	10b56504 	addi	r2,r2,-10860
 32448f0:	10800217 	ldw	r2,8(r2)
 32448f4:	10c00044 	addi	r3,r2,1
 32448f8:	0080c9b4 	movhi	r2,806
 32448fc:	10b56504 	addi	r2,r2,-10860
 3244900:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 3244904:	e13ffe17 	ldw	r4,-8(fp)
 3244908:	32455e00 	call	32455e0 <udp_free>
      return ENP_BAD_HEADER;
 324490c:	00bff804 	movi	r2,-32
 3244910:	e0bfff15 	stw	r2,-4(fp)
 3244914:	0001c306 	br	3245024 <udpdemux+0x840>
   }

   osum = pup->ud_cksum;
 3244918:	e0bff917 	ldw	r2,-28(fp)
 324491c:	1080018b 	ldhu	r2,6(r2)
 3244920:	e0bff78d 	sth	r2,-34(fp)
   /* did other guy use checksumming? */
   if (osum)
 3244924:	e0bff78b 	ldhu	r2,-34(fp)
 3244928:	1005003a 	cmpeq	r2,r2,zero
 324492c:	1000631e 	bne	r2,zero,3244abc <udpdemux+0x2d8>
   {
      if (plen & 1) ((char *)pup)[plen] = 0;
 3244930:	e0bff617 	ldw	r2,-40(fp)
 3244934:	1080004c 	andi	r2,r2,1
 3244938:	10803fcc 	andi	r2,r2,255
 324493c:	1005003a 	cmpeq	r2,r2,zero
 3244940:	1000041e 	bne	r2,zero,3244954 <udpdemux+0x170>
 3244944:	e0bff917 	ldw	r2,-28(fp)
 3244948:	e0fff617 	ldw	r3,-40(fp)
 324494c:	10c5883a 	add	r2,r2,r3
 3244950:	10000005 	stb	zero,0(r2)
         php.ph_src = p->fhost;
 3244954:	e0bffe17 	ldw	r2,-8(fp)
 3244958:	10800717 	ldw	r2,28(r2)
 324495c:	e0bffb15 	stw	r2,-20(fp)
      php.ph_dest = pip->ip_dest;
 3244960:	e0bffa17 	ldw	r2,-24(fp)
 3244964:	10800417 	ldw	r2,16(r2)
 3244968:	e0bffc15 	stw	r2,-16(fp)
      php.ph_zero = 0;
 324496c:	e03ffd05 	stb	zero,-12(fp)
      php.ph_prot = UDP_PROT;
 3244970:	00800444 	movi	r2,17
 3244974:	e0bffd45 	stb	r2,-11(fp)
      php.ph_len  = pup->ud_len;
 3244978:	e0bff917 	ldw	r2,-28(fp)
 324497c:	1080010b 	ldhu	r2,4(r2)
 3244980:	e0bffd8d 	sth	r2,-10(fp)

      pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 3244984:	e13ffb04 	addi	r4,fp,-20
 3244988:	01400184 	movi	r5,6
 324498c:	3225d5c0 	call	3225d5c <cksum>
 3244990:	1007883a 	mov	r3,r2
 3244994:	e0bff917 	ldw	r2,-28(fp)
 3244998:	10c0018d 	sth	r3,6(r2)
      xsum = ~cksum(pup, (plen+1)>>1);
 324499c:	e0bff617 	ldw	r2,-40(fp)
 32449a0:	10800044 	addi	r2,r2,1
 32449a4:	100ad07a 	srli	r5,r2,1
 32449a8:	e13ff917 	ldw	r4,-28(fp)
 32449ac:	3225d5c0 	call	3225d5c <cksum>
 32449b0:	0084303a 	nor	r2,zero,r2
 32449b4:	e0bff70d 	sth	r2,-36(fp)
      if (!xsum)
 32449b8:	e0bff70b 	ldhu	r2,-36(fp)
 32449bc:	1004c03a 	cmpne	r2,r2,zero
 32449c0:	1000021e 	bne	r2,zero,32449cc <udpdemux+0x1e8>
         xsum = 0xffff;
 32449c4:	00bfffc4 	movi	r2,-1
 32449c8:	e0bff70d 	sth	r2,-36(fp)
      pup->ud_cksum = osum;
 32449cc:	e0fff917 	ldw	r3,-28(fp)
 32449d0:	e0bff78b 	ldhu	r2,-34(fp)
 32449d4:	1880018d 	sth	r2,6(r3)
      if (xsum != osum)
 32449d8:	e0fff70b 	ldhu	r3,-36(fp)
 32449dc:	e0bff78b 	ldhu	r2,-34(fp)
 32449e0:	18803626 	beq	r3,r2,3244abc <udpdemux+0x2d8>
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 32449e4:	0080c974 	movhi	r2,805
 32449e8:	10931c04 	addi	r2,r2,19568
 32449ec:	10800017 	ldw	r2,0(r2)
 32449f0:	1081000c 	andi	r2,r2,1024
 32449f4:	1005003a 	cmpeq	r2,r2,zero
 32449f8:	1000241e 	bne	r2,zero,3244a8c <udpdemux+0x2a8>
 32449fc:	0080c974 	movhi	r2,805
 3244a00:	10931c04 	addi	r2,r2,19568
 3244a04:	10800017 	ldw	r2,0(r2)
 3244a08:	1080400c 	andi	r2,r2,256
 3244a0c:	1005003a 	cmpeq	r2,r2,zero
 3244a10:	10001e1e 	bne	r2,zero,3244a8c <udpdemux+0x2a8>
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 3244a14:	e17ff78b 	ldhu	r5,-34(fp)
 3244a18:	e1bff70b 	ldhu	r6,-36(fp)
 3244a1c:	e0bffe17 	ldw	r2,-8(fp)
 3244a20:	10800717 	ldw	r2,28(r2)
 3244a24:	11c03fcc 	andi	r7,r2,255
 3244a28:	e0bffe17 	ldw	r2,-8(fp)
 3244a2c:	10800717 	ldw	r2,28(r2)
 3244a30:	1004d23a 	srli	r2,r2,8
 3244a34:	11003fcc 	andi	r4,r2,255
 3244a38:	e0bffe17 	ldw	r2,-8(fp)
 3244a3c:	10800717 	ldw	r2,28(r2)
 3244a40:	1004d43a 	srli	r2,r2,16
 3244a44:	10c03fcc 	andi	r3,r2,255
 3244a48:	e0bffe17 	ldw	r2,-8(fp)
 3244a4c:	10800717 	ldw	r2,28(r2)
 3244a50:	1004d63a 	srli	r2,r2,24
 3244a54:	d9000015 	stw	r4,0(sp)
 3244a58:	d8c00115 	stw	r3,4(sp)
 3244a5c:	d8800215 	stw	r2,8(sp)
 3244a60:	0100c974 	movhi	r4,805
 3244a64:	21005b04 	addi	r4,r4,364
 3244a68:	3206de00 	call	3206de0 <printf>
                    osum, xsum, PUSH_IPADDR(p->fhost));
            if (NDEBUG & DUMP)
 3244a6c:	0080c974 	movhi	r2,805
 3244a70:	10931c04 	addi	r2,r2,19568
 3244a74:	10800017 	ldw	r2,0(r2)
 3244a78:	1080008c 	andi	r2,r2,2
 3244a7c:	1005003a 	cmpeq	r2,r2,zero
 3244a80:	1000021e 	bne	r2,zero,3244a8c <udpdemux+0x2a8>
               ip_dump(p);
 3244a84:	e13ffe17 	ldw	r4,-8(fp)
 3244a88:	324059c0 	call	324059c <ip_dump>
         }
#endif
         udp_mib.udpInErrors++;
 3244a8c:	0080c9b4 	movhi	r2,806
 3244a90:	10b56504 	addi	r2,r2,-10860
 3244a94:	10800217 	ldw	r2,8(r2)
 3244a98:	10c00044 	addi	r3,r2,1
 3244a9c:	0080c9b4 	movhi	r2,806
 3244aa0:	10b56504 	addi	r2,r2,-10860
 3244aa4:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 3244aa8:	e13ffe17 	ldw	r4,-8(fp)
 3244aac:	32455e00 	call	32455e0 <udp_free>
         return ENP_BAD_HEADER;
 3244ab0:	00bff804 	movi	r2,-32
 3244ab4:	e0bfff15 	stw	r2,-4(fp)
 3244ab8:	00015a06 	br	3245024 <udpdemux+0x840>
      }
   }

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 3244abc:	e13ff917 	ldw	r4,-28(fp)
 3244ac0:	32452f40 	call	32452f4 <udpswap>
#endif

   /* Prior to upcall, adjust nb_prot for size of IP and UDP headers */
   e = (sizeof(struct udp) + ip_hlen(pip));
 3244ac4:	e0bffa17 	ldw	r2,-24(fp)
 3244ac8:	10800003 	ldbu	r2,0(r2)
 3244acc:	10803fcc 	andi	r2,r2,255
 3244ad0:	108003cc 	andi	r2,r2,15
 3244ad4:	1085883a 	add	r2,r2,r2
 3244ad8:	1085883a 	add	r2,r2,r2
 3244adc:	10800204 	addi	r2,r2,8
 3244ae0:	e0bff515 	stw	r2,-44(fp)
   p->nb_plen -= e;
 3244ae4:	e0bffe17 	ldw	r2,-8(fp)
 3244ae8:	10c00417 	ldw	r3,16(r2)
 3244aec:	e0bff517 	ldw	r2,-44(fp)
 3244af0:	1887c83a 	sub	r3,r3,r2
 3244af4:	e0bffe17 	ldw	r2,-8(fp)
 3244af8:	10c00415 	stw	r3,16(r2)
   p->nb_prot += e;
 3244afc:	e0bffe17 	ldw	r2,-8(fp)
 3244b00:	10c00317 	ldw	r3,12(r2)
 3244b04:	e0bff517 	ldw	r2,-44(fp)
 3244b08:	1887883a 	add	r3,r3,r2
 3244b0c:	e0bffe17 	ldw	r2,-8(fp)
 3244b10:	10c00315 	stw	r3,12(r2)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 3244b14:	0080c974 	movhi	r2,805
 3244b18:	10931c04 	addi	r2,r2,19568
 3244b1c:	10800017 	ldw	r2,0(r2)
 3244b20:	1081000c 	andi	r2,r2,1024
 3244b24:	1005003a 	cmpeq	r2,r2,zero
 3244b28:	1000221e 	bne	r2,zero,3244bb4 <udpdemux+0x3d0>
 3244b2c:	0080c974 	movhi	r2,805
 3244b30:	10931c04 	addi	r2,r2,19568
 3244b34:	10800017 	ldw	r2,0(r2)
 3244b38:	1080400c 	andi	r2,r2,256
 3244b3c:	1005003a 	cmpeq	r2,r2,zero
 3244b40:	10001c1e 	bne	r2,zero,3244bb4 <udpdemux+0x3d0>
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 3244b44:	e0bffe17 	ldw	r2,-8(fp)
 3244b48:	10800717 	ldw	r2,28(r2)
 3244b4c:	11803fcc 	andi	r6,r2,255
 3244b50:	e0bffe17 	ldw	r2,-8(fp)
 3244b54:	10800717 	ldw	r2,28(r2)
 3244b58:	1004d23a 	srli	r2,r2,8
 3244b5c:	11c03fcc 	andi	r7,r2,255
 3244b60:	e0bffe17 	ldw	r2,-8(fp)
 3244b64:	10800717 	ldw	r2,28(r2)
 3244b68:	1004d43a 	srli	r2,r2,16
 3244b6c:	10c03fcc 	andi	r3,r2,255
 3244b70:	e0bffe17 	ldw	r2,-8(fp)
 3244b74:	10800717 	ldw	r2,28(r2)
 3244b78:	1008d63a 	srli	r4,r2,24
 3244b7c:	e0bff917 	ldw	r2,-28(fp)
 3244b80:	1080000b 	ldhu	r2,0(r2)
 3244b84:	117fffcc 	andi	r5,r2,65535
 3244b88:	e0bff917 	ldw	r2,-28(fp)
 3244b8c:	1080008b 	ldhu	r2,2(r2)
 3244b90:	10bfffcc 	andi	r2,r2,65535
 3244b94:	d8c00015 	stw	r3,0(sp)
 3244b98:	d9000115 	stw	r4,4(sp)
 3244b9c:	d9400215 	stw	r5,8(sp)
 3244ba0:	d8800315 	stw	r2,12(sp)
 3244ba4:	0100c974 	movhi	r4,805
 3244ba8:	21006904 	addi	r4,r4,420
 3244bac:	e17ff617 	ldw	r5,-40(fp)
 3244bb0:	3206de00 	call	3206de0 <printf>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 3244bb4:	0080c974 	movhi	r2,805
 3244bb8:	10933504 	addi	r2,r2,19668
 3244bbc:	10800017 	ldw	r2,0(r2)
 3244bc0:	e0bff815 	stw	r2,-32(fp)
 3244bc4:	0000b106 	br	3244e8c <udpdemux+0x6a8>
         continue;
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
 3244bc8:	e0bff817 	ldw	r2,-32(fp)
 3244bcc:	1080018b 	ldhu	r2,6(r2)
 3244bd0:	10bfffcc 	andi	r2,r2,65535
 3244bd4:	1005003a 	cmpeq	r2,r2,zero
 3244bd8:	1000071e 	bne	r2,zero,3244bf8 <udpdemux+0x414>
 3244bdc:	e0bff817 	ldw	r2,-32(fp)
 3244be0:	10c0018b 	ldhu	r3,6(r2)
 3244be4:	e0bff917 	ldw	r2,-28(fp)
 3244be8:	1080008b 	ldhu	r2,2(r2)
 3244bec:	18ffffcc 	andi	r3,r3,65535
 3244bf0:	10bfffcc 	andi	r2,r2,65535
 3244bf4:	1880a21e 	bne	r3,r2,3244e80 <udpdemux+0x69c>
         continue;
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
 3244bf8:	e0bff817 	ldw	r2,-32(fp)
 3244bfc:	1080020b 	ldhu	r2,8(r2)
 3244c00:	10bfffcc 	andi	r2,r2,65535
 3244c04:	1005003a 	cmpeq	r2,r2,zero
 3244c08:	1000071e 	bne	r2,zero,3244c28 <udpdemux+0x444>
 3244c0c:	e0bff817 	ldw	r2,-32(fp)
 3244c10:	10c0020b 	ldhu	r3,8(r2)
 3244c14:	e0bff917 	ldw	r2,-28(fp)
 3244c18:	1080000b 	ldhu	r2,0(r2)
 3244c1c:	18ffffcc 	andi	r3,r3,65535
 3244c20:	10bfffcc 	andi	r2,r2,65535
 3244c24:	1880961e 	bne	r3,r2,3244e80 <udpdemux+0x69c>
         continue;
      if (con->u_fhost && (con->u_fhost != p->fhost))
 3244c28:	e0bff817 	ldw	r2,-32(fp)
 3244c2c:	10800417 	ldw	r2,16(r2)
 3244c30:	1005003a 	cmpeq	r2,r2,zero
 3244c34:	1000051e 	bne	r2,zero,3244c4c <udpdemux+0x468>
 3244c38:	e0bff817 	ldw	r2,-32(fp)
 3244c3c:	10c00417 	ldw	r3,16(r2)
 3244c40:	e0bffe17 	ldw	r2,-8(fp)
 3244c44:	10800717 	ldw	r2,28(r2)
 3244c48:	18808d1e 	bne	r3,r2,3244e80 <udpdemux+0x69c>
#ifdef IP_MULTICAST
      /* In the case of multicast, check if there is multicast membership
       * attached to this socket and if so, is the incoming packet
       * addressed to the multicast address
       */
      if (IN_MULTICAST(ntohl(pip->ip_dest)))
 3244c4c:	e0bffa17 	ldw	r2,-24(fp)
 3244c50:	10800417 	ldw	r2,16(r2)
 3244c54:	1004d63a 	srli	r2,r2,24
 3244c58:	10c03fcc 	andi	r3,r2,255
 3244c5c:	e0bffa17 	ldw	r2,-24(fp)
 3244c60:	10800417 	ldw	r2,16(r2)
 3244c64:	1004d23a 	srli	r2,r2,8
 3244c68:	10bfc00c 	andi	r2,r2,65280
 3244c6c:	1886b03a 	or	r3,r3,r2
 3244c70:	e0bffa17 	ldw	r2,-24(fp)
 3244c74:	10800417 	ldw	r2,16(r2)
 3244c78:	10bfc00c 	andi	r2,r2,65280
 3244c7c:	1004923a 	slli	r2,r2,8
 3244c80:	1886b03a 	or	r3,r3,r2
 3244c84:	e0bffa17 	ldw	r2,-24(fp)
 3244c88:	10800417 	ldw	r2,16(r2)
 3244c8c:	10803fcc 	andi	r2,r2,255
 3244c90:	1004963a 	slli	r2,r2,24
 3244c94:	1884b03a 	or	r2,r3,r2
 3244c98:	10fc002c 	andhi	r3,r2,61440
 3244c9c:	00b80034 	movhi	r2,57344
 3244ca0:	1880301e 	bne	r3,r2,3244d64 <udpdemux+0x580>
      {
         struct socket *soptr = (struct socket *)con->u_data;
 3244ca4:	e0bff817 	ldw	r2,-32(fp)
 3244ca8:	10800617 	ldw	r2,24(r2)
 3244cac:	e0bff415 	stw	r2,-48(fp)

         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
 3244cb0:	e0bff817 	ldw	r2,-32(fp)
 3244cb4:	10c00517 	ldw	r3,20(r2)
 3244cb8:	0080c934 	movhi	r2,804
 3244cbc:	10a58d04 	addi	r2,r2,-27084
 3244cc0:	1880281e 	bne	r3,r2,3244d64 <udpdemux+0x580>
 3244cc4:	e0bff417 	ldw	r2,-48(fp)
 3244cc8:	10800317 	ldw	r2,12(r2)
 3244ccc:	1005003a 	cmpeq	r2,r2,zero
 3244cd0:	1000241e 	bne	r2,zero,3244d64 <udpdemux+0x580>
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;
 3244cd4:	e0bff417 	ldw	r2,-48(fp)
 3244cd8:	10800317 	ldw	r2,12(r2)
 3244cdc:	e0bff215 	stw	r2,-56(fp)

            for (i = 0; i < imo->imo_num_memberships; ++i)
 3244ce0:	e03ff30d 	sth	zero,-52(fp)
 3244ce4:	00001906 	br	3244d4c <udpdemux+0x568>
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 3244ce8:	e0bff30b 	ldhu	r2,-52(fp)
 3244cec:	e0fff217 	ldw	r3,-56(fp)
 3244cf0:	1085883a 	add	r2,r2,r2
 3244cf4:	1085883a 	add	r2,r2,r2
 3244cf8:	10c5883a 	add	r2,r2,r3
 3244cfc:	10800204 	addi	r2,r2,8
 3244d00:	10800017 	ldw	r2,0(r2)
 3244d04:	10c00117 	ldw	r3,4(r2)
 3244d08:	e0bffe17 	ldw	r2,-8(fp)
 3244d0c:	10800617 	ldw	r2,24(r2)
 3244d10:	18800b1e 	bne	r3,r2,3244d40 <udpdemux+0x55c>
 3244d14:	e0bff30b 	ldhu	r2,-52(fp)
 3244d18:	e0fff217 	ldw	r3,-56(fp)
 3244d1c:	1085883a 	add	r2,r2,r2
 3244d20:	1085883a 	add	r2,r2,r2
 3244d24:	10c5883a 	add	r2,r2,r3
 3244d28:	10800204 	addi	r2,r2,8
 3244d2c:	10800017 	ldw	r2,0(r2)
 3244d30:	10c00017 	ldw	r3,0(r2)
 3244d34:	e0bffa17 	ldw	r2,-24(fp)
 3244d38:	10800417 	ldw	r2,16(r2)
 3244d3c:	18800926 	beq	r3,r2,3244d64 <udpdemux+0x580>
         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
 3244d40:	e0bff30b 	ldhu	r2,-52(fp)
 3244d44:	10800044 	addi	r2,r2,1
 3244d48:	e0bff30d 	sth	r2,-52(fp)
 3244d4c:	e0bff217 	ldw	r2,-56(fp)
 3244d50:	1080018b 	ldhu	r2,6(r2)
 3244d54:	10ffffcc 	andi	r3,r2,65535
 3244d58:	e0bff30b 	ldhu	r2,-52(fp)
 3244d5c:	10ffe236 	bltu	r2,r3,3244ce8 <udpdemux+0x504>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
               }
            }
            continue;
 3244d60:	00004706 	br	3244e80 <udpdemux+0x69c>
#endif /* INCLUDE_TCP */

      /* if this endpoint has been bound to a local interface address,
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
 3244d64:	e0bffa17 	ldw	r2,-24(fp)
 3244d68:	10800417 	ldw	r2,16(r2)
 3244d6c:	1004d63a 	srli	r2,r2,24
 3244d70:	10c03fcc 	andi	r3,r2,255
 3244d74:	e0bffa17 	ldw	r2,-24(fp)
 3244d78:	10800417 	ldw	r2,16(r2)
 3244d7c:	1004d23a 	srli	r2,r2,8
 3244d80:	10bfc00c 	andi	r2,r2,65280
 3244d84:	1886b03a 	or	r3,r3,r2
 3244d88:	e0bffa17 	ldw	r2,-24(fp)
 3244d8c:	10800417 	ldw	r2,16(r2)
 3244d90:	10bfc00c 	andi	r2,r2,65280
 3244d94:	1004923a 	slli	r2,r2,8
 3244d98:	1886b03a 	or	r3,r3,r2
 3244d9c:	e0bffa17 	ldw	r2,-24(fp)
 3244da0:	10800417 	ldw	r2,16(r2)
 3244da4:	10803fcc 	andi	r2,r2,255
 3244da8:	1004963a 	slli	r2,r2,24
 3244dac:	1884b03a 	or	r2,r3,r2
 3244db0:	10fc002c 	andhi	r3,r2,61440
 3244db4:	00b80034 	movhi	r2,57344
 3244db8:	18800926 	beq	r3,r2,3244de0 <udpdemux+0x5fc>
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
 3244dbc:	e0bff817 	ldw	r2,-32(fp)
 3244dc0:	10800317 	ldw	r2,12(r2)
 3244dc4:	1005003a 	cmpeq	r2,r2,zero
 3244dc8:	1000051e 	bne	r2,zero,3244de0 <udpdemux+0x5fc>
 3244dcc:	e0bff817 	ldw	r2,-32(fp)
 3244dd0:	10c00317 	ldw	r3,12(r2)
 3244dd4:	e0bffa17 	ldw	r2,-24(fp)
 3244dd8:	10800417 	ldw	r2,16(r2)
 3244ddc:	1880281e 	bne	r3,r2,3244e80 <udpdemux+0x69c>
            continue;
      }

      /* fall to here if we found it */
      udp_mib.udpInDatagrams++;
 3244de0:	0080c9b4 	movhi	r2,806
 3244de4:	10b56504 	addi	r2,r2,-10860
 3244de8:	10800017 	ldw	r2,0(r2)
 3244dec:	10c00044 	addi	r3,r2,1
 3244df0:	0080c9b4 	movhi	r2,806
 3244df4:	10b56504 	addi	r2,r2,-10860
 3244df8:	10c00015 	stw	r3,0(r2)
      if (con->u_rcv)         /* if upcall address is set... */
 3244dfc:	e0bff817 	ldw	r2,-32(fp)
 3244e00:	10800517 	ldw	r2,20(r2)
 3244e04:	1005003a 	cmpeq	r2,r2,zero
 3244e08:	10000c1e 	bne	r2,zero,3244e3c <udpdemux+0x658>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 3244e0c:	0009883a 	mov	r4,zero
 3244e10:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         e = ((*con->u_rcv)(p, con->u_data));   /* upcall it */
 3244e14:	e0bff817 	ldw	r2,-32(fp)
 3244e18:	10c00517 	ldw	r3,20(r2)
 3244e1c:	e0bff817 	ldw	r2,-32(fp)
 3244e20:	11400617 	ldw	r5,24(r2)
 3244e24:	e13ffe17 	ldw	r4,-8(fp)
 3244e28:	183ee83a 	callr	r3
 3244e2c:	e0bff515 	stw	r2,-44(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 3244e30:	0009883a 	mov	r4,zero
 3244e34:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
 3244e38:	00000206 	br	3244e44 <udpdemux+0x660>
      }
      else
         e = ENP_LOGIC;
 3244e3c:	00bffd44 	movi	r2,-11
 3244e40:	e0bff515 	stw	r2,-44(fp)

      /* if error occurred in upcall or there was no upcall hander
         its up to this routine to free the packet buffer */
      if (e)
 3244e44:	e0bff517 	ldw	r2,-44(fp)
 3244e48:	1005003a 	cmpeq	r2,r2,zero
 3244e4c:	1000091e 	bne	r2,zero,3244e74 <udpdemux+0x690>
      {
         udp_mib.udpInErrors++;
 3244e50:	0080c9b4 	movhi	r2,806
 3244e54:	10b56504 	addi	r2,r2,-10860
 3244e58:	10800217 	ldw	r2,8(r2)
 3244e5c:	10c00044 	addi	r3,r2,1
 3244e60:	0080c9b4 	movhi	r2,806
 3244e64:	10b56504 	addi	r2,r2,-10860
 3244e68:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 3244e6c:	e13ffe17 	ldw	r4,-8(fp)
 3244e70:	32455e00 	call	32455e0 <udp_free>
      }

      return(e);
 3244e74:	e0bff517 	ldw	r2,-44(fp)
 3244e78:	e0bfff15 	stw	r2,-4(fp)
 3244e7c:	00006906 	br	3245024 <udpdemux+0x840>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 3244e80:	e0bff817 	ldw	r2,-32(fp)
 3244e84:	10800017 	ldw	r2,0(r2)
 3244e88:	e0bff815 	stw	r2,-32(fp)
 3244e8c:	e0bff817 	ldw	r2,-32(fp)
 3244e90:	1004c03a 	cmpne	r2,r2,zero
 3244e94:	103f4c1e 	bne	r2,zero,3244bc8 <udpdemux+0x3e4>

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 3244e98:	e0bffa17 	ldw	r2,-24(fp)
 3244e9c:	10800417 	ldw	r2,16(r2)
 3244ea0:	10bfffe0 	cmpeqi	r2,r2,-1
 3244ea4:	1000121e 	bne	r2,zero,3244ef0 <udpdemux+0x70c>
 3244ea8:	e0bffa17 	ldw	r2,-24(fp)
 3244eac:	10c00417 	ldw	r3,16(r2)
 3244eb0:	e0bffe17 	ldw	r2,-8(fp)
 3244eb4:	10800617 	ldw	r2,24(r2)
 3244eb8:	10800e17 	ldw	r2,56(r2)
 3244ebc:	18800c26 	beq	r3,r2,3244ef0 <udpdemux+0x70c>
 3244ec0:	e0bffa17 	ldw	r2,-24(fp)
 3244ec4:	10c00417 	ldw	r3,16(r2)
 3244ec8:	e0bffe17 	ldw	r2,-8(fp)
 3244ecc:	10800617 	ldw	r2,24(r2)
 3244ed0:	10800f17 	ldw	r2,60(r2)
 3244ed4:	18800626 	beq	r3,r2,3244ef0 <udpdemux+0x70c>
 3244ed8:	e0bffa17 	ldw	r2,-24(fp)
 3244edc:	10c00417 	ldw	r3,16(r2)
 3244ee0:	e0bffe17 	ldw	r2,-8(fp)
 3244ee4:	10800617 	ldw	r2,24(r2)
 3244ee8:	10801017 	ldw	r2,64(r2)
 3244eec:	18801b1e 	bne	r3,r2,3244f5c <udpdemux+0x778>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
   {
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 3244ef0:	0080c974 	movhi	r2,805
 3244ef4:	10931c04 	addi	r2,r2,19568
 3244ef8:	10800017 	ldw	r2,0(r2)
 3244efc:	1081000c 	andi	r2,r2,1024
 3244f00:	1005003a 	cmpeq	r2,r2,zero
 3244f04:	1000091e 	bne	r2,zero,3244f2c <udpdemux+0x748>
 3244f08:	0080c974 	movhi	r2,805
 3244f0c:	10931c04 	addi	r2,r2,19568
 3244f10:	10800017 	ldw	r2,0(r2)
 3244f14:	1080400c 	andi	r2,r2,256
 3244f18:	1005003a 	cmpeq	r2,r2,zero
 3244f1c:	1000031e 	bne	r2,zero,3244f2c <udpdemux+0x748>
         dprintf("UDP: ignoring ip broadcast\n");
 3244f20:	0100c974 	movhi	r4,805
 3244f24:	21007304 	addi	r4,r4,460
 3244f28:	32071080 	call	3207108 <puts>
#endif
      udp_mib.udpInErrors++;
 3244f2c:	0080c9b4 	movhi	r2,806
 3244f30:	10b56504 	addi	r2,r2,-10860
 3244f34:	10800217 	ldw	r2,8(r2)
 3244f38:	10c00044 	addi	r3,r2,1
 3244f3c:	0080c9b4 	movhi	r2,806
 3244f40:	10b56504 	addi	r2,r2,-10860
 3244f44:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 3244f48:	e13ffe17 	ldw	r4,-8(fp)
 3244f4c:	32455e00 	call	32455e0 <udp_free>
      return ENP_NOT_MINE;
 3244f50:	00800084 	movi	r2,2
 3244f54:	e0bfff15 	stw	r2,-4(fp)
 3244f58:	00003206 	br	3245024 <udpdemux+0x840>
   }

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 3244f5c:	0080c974 	movhi	r2,805
 3244f60:	10931c04 	addi	r2,r2,19568
 3244f64:	10800017 	ldw	r2,0(r2)
 3244f68:	1081000c 	andi	r2,r2,1024
 3244f6c:	1005003a 	cmpeq	r2,r2,zero
 3244f70:	1000141e 	bne	r2,zero,3244fc4 <udpdemux+0x7e0>
 3244f74:	0080c974 	movhi	r2,805
 3244f78:	10931c04 	addi	r2,r2,19568
 3244f7c:	10800017 	ldw	r2,0(r2)
 3244f80:	1080400c 	andi	r2,r2,256
 3244f84:	1005003a 	cmpeq	r2,r2,zero
 3244f88:	10000e1e 	bne	r2,zero,3244fc4 <udpdemux+0x7e0>
   {
      dprintf("UDP: unexpected port %04x\n", pup->ud_dstp);
 3244f8c:	e0bff917 	ldw	r2,-28(fp)
 3244f90:	1080008b 	ldhu	r2,2(r2)
 3244f94:	117fffcc 	andi	r5,r2,65535
 3244f98:	0100c974 	movhi	r4,805
 3244f9c:	21007a04 	addi	r4,r4,488
 3244fa0:	3206de00 	call	3206de0 <printf>
      if (NDEBUG & DUMP) 
 3244fa4:	0080c974 	movhi	r2,805
 3244fa8:	10931c04 	addi	r2,r2,19568
 3244fac:	10800017 	ldw	r2,0(r2)
 3244fb0:	1080008c 	andi	r2,r2,2
 3244fb4:	1005003a 	cmpeq	r2,r2,zero
 3244fb8:	1000021e 	bne	r2,zero,3244fc4 <udpdemux+0x7e0>
         ip_dump(p);
 3244fbc:	e13ffe17 	ldw	r4,-8(fp)
 3244fc0:	324059c0 	call	324059c <ip_dump>
#ifdef FULL_ICMP
   /* send destination unreachable.  Swap back all the swapped information */
   /* so that the destun packet format is correct */

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 3244fc4:	e13ff917 	ldw	r4,-28(fp)
 3244fc8:	32452f40 	call	32452f4 <udpswap>
#endif   /* BYTE_ORDER */
   
   icmp_destun(p->fhost, p->net->n_ipaddr, pip, DSTPORT, p->net);
 3244fcc:	e0bffe17 	ldw	r2,-8(fp)
 3244fd0:	11000717 	ldw	r4,28(r2)
 3244fd4:	e0bffe17 	ldw	r2,-8(fp)
 3244fd8:	10800617 	ldw	r2,24(r2)
 3244fdc:	11400a17 	ldw	r5,40(r2)
 3244fe0:	e0bffe17 	ldw	r2,-8(fp)
 3244fe4:	10800617 	ldw	r2,24(r2)
 3244fe8:	d8800015 	stw	r2,0(sp)
 3244fec:	e1bffa17 	ldw	r6,-24(fp)
 3244ff0:	01c000c4 	movi	r7,3
 3244ff4:	324b5400 	call	324b540 <icmp_destun>
#endif   /* FULL_ICMP */

   udp_mib.udpNoPorts++;
 3244ff8:	0080c9b4 	movhi	r2,806
 3244ffc:	10b56504 	addi	r2,r2,-10860
 3245000:	10800117 	ldw	r2,4(r2)
 3245004:	10c00044 	addi	r3,r2,1
 3245008:	0080c9b4 	movhi	r2,806
 324500c:	10b56504 	addi	r2,r2,-10860
 3245010:	10c00115 	stw	r3,4(r2)
   udp_free(p);
 3245014:	e13ffe17 	ldw	r4,-8(fp)
 3245018:	32455e00 	call	32455e0 <udp_free>
   return ENP_NOT_MINE;
 324501c:	00800084 	movi	r2,2
 3245020:	e0bfff15 	stw	r2,-4(fp)
 3245024:	e0bfff17 	ldw	r2,-4(fp)
}
 3245028:	e037883a 	mov	sp,fp
 324502c:	dfc00117 	ldw	ra,4(sp)
 3245030:	df000017 	ldw	fp,0(sp)
 3245034:	dec00204 	addi	sp,sp,8
 3245038:	f800283a 	ret

0324503c <udp_send>:
 * detected. 
 */

int
udp_send(unshort fport, unshort lport, PACKET p)
{
 324503c:	deffee04 	addi	sp,sp,-72
 3245040:	dfc01115 	stw	ra,68(sp)
 3245044:	df001015 	stw	fp,64(sp)
 3245048:	df001004 	addi	fp,sp,64
 324504c:	e1bffe15 	stw	r6,-8(fp)
 3245050:	e13ffc0d 	sth	r4,-16(fp)
 3245054:	e17ffd0d 	sth	r5,-12(fp)
   int         udplen;
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
 3245058:	0080c974 	movhi	r2,805
 324505c:	10931c04 	addi	r2,r2,19568
 3245060:	10800017 	ldw	r2,0(r2)
 3245064:	1080410c 	andi	r2,r2,260
 3245068:	1005003a 	cmpeq	r2,r2,zero
 324506c:	10001c1e 	bne	r2,zero,32450e0 <udp_send+0xa4>
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 3245070:	e0bffe17 	ldw	r2,-8(fp)
 3245074:	11800417 	ldw	r6,16(r2)
 3245078:	e1fffd0b 	ldhu	r7,-12(fp)
 324507c:	e0bffe17 	ldw	r2,-8(fp)
 3245080:	10800717 	ldw	r2,28(r2)
 3245084:	12003fcc 	andi	r8,r2,255
 3245088:	e0bffe17 	ldw	r2,-8(fp)
 324508c:	10800717 	ldw	r2,28(r2)
 3245090:	1004d23a 	srli	r2,r2,8
 3245094:	11003fcc 	andi	r4,r2,255
 3245098:	e0bffe17 	ldw	r2,-8(fp)
 324509c:	10800717 	ldw	r2,28(r2)
 32450a0:	1004d43a 	srli	r2,r2,16
 32450a4:	11403fcc 	andi	r5,r2,255
 32450a8:	e0bffe17 	ldw	r2,-8(fp)
 32450ac:	10800717 	ldw	r2,28(r2)
 32450b0:	1004d63a 	srli	r2,r2,24
 32450b4:	e0fffc0b 	ldhu	r3,-16(fp)
 32450b8:	d9000015 	stw	r4,0(sp)
 32450bc:	d9400115 	stw	r5,4(sp)
 32450c0:	d8800215 	stw	r2,8(sp)
 32450c4:	d8c00315 	stw	r3,12(sp)
 32450c8:	0100c974 	movhi	r4,805
 32450cc:	21008104 	addi	r4,r4,516
 32450d0:	300b883a 	mov	r5,r6
 32450d4:	380d883a 	mov	r6,r7
 32450d8:	400f883a 	mov	r7,r8
 32450dc:	3206de00 	call	3206de0 <printf>
    PUSH_IPADDR(p->fhost), fport);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 32450e0:	0009883a 	mov	r4,zero
 32450e4:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   /* prepend UDP header to upper layer's data */
   p->nb_prot -= sizeof(struct udp);
 32450e8:	e0bffe17 	ldw	r2,-8(fp)
 32450ec:	10800317 	ldw	r2,12(r2)
 32450f0:	10fffe04 	addi	r3,r2,-8
 32450f4:	e0bffe17 	ldw	r2,-8(fp)
 32450f8:	10c00315 	stw	r3,12(r2)
   pup = (struct udp*)p->nb_prot;
 32450fc:	e0bffe17 	ldw	r2,-8(fp)
 3245100:	10800317 	ldw	r2,12(r2)
 3245104:	e0bff815 	stw	r2,-32(fp)
   udplen = p->nb_plen + sizeof(struct udp);
 3245108:	e0bffe17 	ldw	r2,-8(fp)
 324510c:	10800417 	ldw	r2,16(r2)
 3245110:	10800204 	addi	r2,r2,8
 3245114:	e0bff615 	stw	r2,-40(fp)
   p->nb_plen = udplen;
 3245118:	e0fff617 	ldw	r3,-40(fp)
 324511c:	e0bffe17 	ldw	r2,-8(fp)
 3245120:	10c00415 	stw	r3,16(r2)
   if (udplen & 1) ((char *)pup)[udplen] = 0;
 3245124:	e0bff617 	ldw	r2,-40(fp)
 3245128:	1080004c 	andi	r2,r2,1
 324512c:	10803fcc 	andi	r2,r2,255
 3245130:	1005003a 	cmpeq	r2,r2,zero
 3245134:	1000041e 	bne	r2,zero,3245148 <udp_send+0x10c>
 3245138:	e0fff817 	ldw	r3,-32(fp)
 324513c:	e0bff617 	ldw	r2,-40(fp)
 3245140:	1885883a 	add	r2,r3,r2
 3245144:	10000005 	stb	zero,0(r2)

      pup->ud_len = (unshort)udplen;   /* fill in the UDP header */
 3245148:	e0bff617 	ldw	r2,-40(fp)
 324514c:	1007883a 	mov	r3,r2
 3245150:	e0bff817 	ldw	r2,-32(fp)
 3245154:	10c0010d 	sth	r3,4(r2)
   pup->ud_srcp = lport;
 3245158:	e0fff817 	ldw	r3,-32(fp)
 324515c:	e0bffd0b 	ldhu	r2,-12(fp)
 3245160:	1880000d 	sth	r2,0(r3)
   pup->ud_dstp = fport;
 3245164:	e0fff817 	ldw	r3,-32(fp)
 3245168:	e0bffc0b 	ldhu	r2,-16(fp)
 324516c:	1880008d 	sth	r2,2(r3)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 3245170:	e13ff817 	ldw	r4,-32(fp)
 3245174:	32452f40 	call	32452f4 <udpswap>
#endif   /* BYTE_ORDER */
   
#ifdef MULTI_HOMED
   /* getting the source IP address for a broadcast is a bit tricky: */
   if (p->fhost == 0xffffffff)
 3245178:	e0bffe17 	ldw	r2,-8(fp)
 324517c:	10800717 	ldw	r2,28(r2)
 3245180:	10bfffd8 	cmpnei	r2,r2,-1
 3245184:	1000111e 	bne	r2,zero,32451cc <udp_send+0x190>
   {
      if (!p->net)
 3245188:	e0bffe17 	ldw	r2,-8(fp)
 324518c:	10800617 	ldw	r2,24(r2)
 3245190:	1004c03a 	cmpne	r2,r2,zero
 3245194:	1000081e 	bne	r2,zero,32451b8 <udp_send+0x17c>
      {
         dtrap();    /* programmer forgot to select iface */
 3245198:	322aef00 	call	322aef0 <dtrap>
         /* it would appear that the callers of udp_send() expect it
            to do cleanup on failure, so free the packet buffer here */
         udp_free(p);
 324519c:	e13ffe17 	ldw	r4,-8(fp)
 32451a0:	32455e00 	call	32455e0 <udp_free>
         UNLOCK_NET_RESOURCE(NET_RESID);
 32451a4:	0009883a 	mov	r4,zero
 32451a8:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
         return ENP_NO_IFACE;
 32451ac:	00bff784 	movi	r2,-34
 32451b0:	e0bfff15 	stw	r2,-4(fp)
 32451b4:	00004906 	br	32452dc <udp_send+0x2a0>
      }
      src_ip = p->net->n_ipaddr;
 32451b8:	e0bffe17 	ldw	r2,-8(fp)
 32451bc:	10800617 	ldw	r2,24(r2)
 32451c0:	10800a17 	ldw	r2,40(r2)
 32451c4:	e0bff415 	stw	r2,-48(fp)
 32451c8:	00000406 	br	32451dc <udp_send+0x1a0>
   /* set the IP addresses in the IP header. The pseudo header used for
    * checksumming overlays the addresses on the IP header area in the
    * buffer, so setting them there (which we need to do for cksum
    * anyway) sets up for IP too.
    */
   src_ip = ip_mymach(p->fhost);
 32451cc:	e0bffe17 	ldw	r2,-8(fp)
 32451d0:	11000717 	ldw	r4,28(r2)
 32451d4:	32404f00 	call	32404f0 <ip_mymach>
 32451d8:	e0bff415 	stw	r2,-48(fp)
   php.ph_src = src_ip;
 32451dc:	e0bff417 	ldw	r2,-48(fp)
 32451e0:	e0bff915 	stw	r2,-28(fp)
   php.ph_dest = p->fhost;
 32451e4:	e0bffe17 	ldw	r2,-8(fp)
 32451e8:	10800717 	ldw	r2,28(r2)
 32451ec:	e0bffa15 	stw	r2,-24(fp)
#ifdef NO_UDP_CKSUM
   /* If no UDP checksum support, just zero the checksum field */
   pup->ud_cksum = 0;
#else
   /* finish filling in the pseudo header required for checksumming */
   php.ph_zero = 0;
 32451f0:	e03ffb05 	stb	zero,-20(fp)
   php.ph_prot = UDP_PROT;
 32451f4:	00800444 	movi	r2,17
 32451f8:	e0bffb45 	stb	r2,-19(fp)
   php.ph_len = pup->ud_len;
 32451fc:	e0bff817 	ldw	r2,-32(fp)
 3245200:	1080010b 	ldhu	r2,4(r2)
 3245204:	e0bffb8d 	sth	r2,-18(fp)
   pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 3245208:	e13ff904 	addi	r4,fp,-28
 324520c:	01400184 	movi	r5,6
 3245210:	3225d5c0 	call	3225d5c <cksum>
 3245214:	1007883a 	mov	r3,r2
 3245218:	e0bff817 	ldw	r2,-32(fp)
 324521c:	10c0018d 	sth	r3,6(r2)
   pup->ud_cksum = ~cksum(pup, (udplen+1)>>1);
 3245220:	e0bff617 	ldw	r2,-40(fp)
 3245224:	10800044 	addi	r2,r2,1
 3245228:	1005d07a 	srai	r2,r2,1
 324522c:	100b883a 	mov	r5,r2
 3245230:	e13ff817 	ldw	r4,-32(fp)
 3245234:	3225d5c0 	call	3225d5c <cksum>
 3245238:	0084303a 	nor	r2,zero,r2
 324523c:	1007883a 	mov	r3,r2
 3245240:	e0bff817 	ldw	r2,-32(fp)
 3245244:	10c0018d 	sth	r3,6(r2)
   if (pup->ud_cksum == 0)
 3245248:	e0bff817 	ldw	r2,-32(fp)
 324524c:	1080018b 	ldhu	r2,6(r2)
 3245250:	10bfffcc 	andi	r2,r2,65535
 3245254:	1004c03a 	cmpne	r2,r2,zero
 3245258:	1000031e 	bne	r2,zero,3245268 <udp_send+0x22c>
      pup->ud_cksum = 0xffff;
 324525c:	e0fff817 	ldw	r3,-32(fp)
 3245260:	00bfffc4 	movi	r2,-1
 3245264:	1880018d 	sth	r2,6(r3)
#endif

   /* need to fill in IP addresses at this layer too */
   pip = (struct ip *)(p->nb_prot - sizeof(struct ip));
 3245268:	e0bffe17 	ldw	r2,-8(fp)
 324526c:	10800317 	ldw	r2,12(r2)
 3245270:	10bffb04 	addi	r2,r2,-20
 3245274:	e0bff715 	stw	r2,-36(fp)
   pip->ip_src = src_ip;
 3245278:	e0fff717 	ldw	r3,-36(fp)
 324527c:	e0bff417 	ldw	r2,-48(fp)
 3245280:	18800315 	stw	r2,12(r3)
   pip->ip_dest = p->fhost;
 3245284:	e0bffe17 	ldw	r2,-8(fp)
 3245288:	10c00717 	ldw	r3,28(r2)
 324528c:	e0bff717 	ldw	r2,-36(fp)
 3245290:	10c00415 	stw	r3,16(r2)

   udp_mib.udpOutDatagrams++;
 3245294:	0080c9b4 	movhi	r2,806
 3245298:	10b56504 	addi	r2,r2,-10860
 324529c:	10800317 	ldw	r2,12(r2)
 32452a0:	10c00044 	addi	r3,r2,1
 32452a4:	0080c9b4 	movhi	r2,806
 32452a8:	10b56504 	addi	r2,r2,-10860
 32452ac:	10c00315 	stw	r3,12(r2)

   p->nb_plen = udplen;       /* nb_prot was adjusted above */
 32452b0:	e0fff617 	ldw	r3,-40(fp)
 32452b4:	e0bffe17 	ldw	r2,-8(fp)
 32452b8:	10c00415 	stw	r3,16(r2)
   e = ip_write(UDP_PROT, p);
 32452bc:	01000444 	movi	r4,17
 32452c0:	e17ffe17 	ldw	r5,-8(fp)
 32452c4:	323f3740 	call	323f374 <ip_write>
 32452c8:	e0bff515 	stw	r2,-44(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 32452cc:	0009883a 	mov	r4,zero
 32452d0:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   return e;
 32452d4:	e0bff517 	ldw	r2,-44(fp)
 32452d8:	e0bfff15 	stw	r2,-4(fp)
 32452dc:	e0bfff17 	ldw	r2,-4(fp)
}
 32452e0:	e037883a 	mov	sp,fp
 32452e4:	dfc00117 	ldw	ra,4(sp)
 32452e8:	df000017 	ldw	fp,0(sp)
 32452ec:	dec00204 	addi	sp,sp,8
 32452f0:	f800283a 	ret

032452f4 <udpswap>:
 */

#if (BYTE_ORDER == LITTLE_ENDIAN)
void
udpswap(struct udp *pup)
{
 32452f4:	defffe04 	addi	sp,sp,-8
 32452f8:	df000115 	stw	fp,4(sp)
 32452fc:	df000104 	addi	fp,sp,4
 3245300:	e13fff15 	stw	r4,-4(fp)

   pup->ud_srcp = htons(pup->ud_srcp);
 3245304:	e0bfff17 	ldw	r2,-4(fp)
 3245308:	1080000b 	ldhu	r2,0(r2)
 324530c:	10bfffcc 	andi	r2,r2,65535
 3245310:	1004d23a 	srli	r2,r2,8
 3245314:	10803fcc 	andi	r2,r2,255
 3245318:	1009883a 	mov	r4,r2
 324531c:	e0bfff17 	ldw	r2,-4(fp)
 3245320:	1080000b 	ldhu	r2,0(r2)
 3245324:	10bfffcc 	andi	r2,r2,65535
 3245328:	1004923a 	slli	r2,r2,8
 324532c:	1007883a 	mov	r3,r2
 3245330:	00bfc004 	movi	r2,-256
 3245334:	1884703a 	and	r2,r3,r2
 3245338:	2084b03a 	or	r2,r4,r2
 324533c:	1007883a 	mov	r3,r2
 3245340:	e0bfff17 	ldw	r2,-4(fp)
 3245344:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = htons(pup->ud_dstp);
 3245348:	e0bfff17 	ldw	r2,-4(fp)
 324534c:	1080008b 	ldhu	r2,2(r2)
 3245350:	10bfffcc 	andi	r2,r2,65535
 3245354:	1004d23a 	srli	r2,r2,8
 3245358:	10803fcc 	andi	r2,r2,255
 324535c:	1009883a 	mov	r4,r2
 3245360:	e0bfff17 	ldw	r2,-4(fp)
 3245364:	1080008b 	ldhu	r2,2(r2)
 3245368:	10bfffcc 	andi	r2,r2,65535
 324536c:	1004923a 	slli	r2,r2,8
 3245370:	1007883a 	mov	r3,r2
 3245374:	00bfc004 	movi	r2,-256
 3245378:	1884703a 	and	r2,r3,r2
 324537c:	2084b03a 	or	r2,r4,r2
 3245380:	1007883a 	mov	r3,r2
 3245384:	e0bfff17 	ldw	r2,-4(fp)
 3245388:	10c0008d 	sth	r3,2(r2)
   pup->ud_len = htons(pup->ud_len);
 324538c:	e0bfff17 	ldw	r2,-4(fp)
 3245390:	1080010b 	ldhu	r2,4(r2)
 3245394:	10bfffcc 	andi	r2,r2,65535
 3245398:	1004d23a 	srli	r2,r2,8
 324539c:	10803fcc 	andi	r2,r2,255
 32453a0:	1009883a 	mov	r4,r2
 32453a4:	e0bfff17 	ldw	r2,-4(fp)
 32453a8:	1080010b 	ldhu	r2,4(r2)
 32453ac:	10bfffcc 	andi	r2,r2,65535
 32453b0:	1004923a 	slli	r2,r2,8
 32453b4:	1007883a 	mov	r3,r2
 32453b8:	00bfc004 	movi	r2,-256
 32453bc:	1884703a 	and	r2,r3,r2
 32453c0:	2084b03a 	or	r2,r4,r2
 32453c4:	1007883a 	mov	r3,r2
 32453c8:	e0bfff17 	ldw	r2,-4(fp)
 32453cc:	10c0010d 	sth	r3,4(r2)
   pup->ud_cksum = htons(pup->ud_cksum);
 32453d0:	e0bfff17 	ldw	r2,-4(fp)
 32453d4:	1080018b 	ldhu	r2,6(r2)
 32453d8:	10bfffcc 	andi	r2,r2,65535
 32453dc:	1004d23a 	srli	r2,r2,8
 32453e0:	10803fcc 	andi	r2,r2,255
 32453e4:	1009883a 	mov	r4,r2
 32453e8:	e0bfff17 	ldw	r2,-4(fp)
 32453ec:	1080018b 	ldhu	r2,6(r2)
 32453f0:	10bfffcc 	andi	r2,r2,65535
 32453f4:	1004923a 	slli	r2,r2,8
 32453f8:	1007883a 	mov	r3,r2
 32453fc:	00bfc004 	movi	r2,-256
 3245400:	1884703a 	and	r2,r3,r2
 3245404:	2084b03a 	or	r2,r4,r2
 3245408:	1007883a 	mov	r3,r2
 324540c:	e0bfff17 	ldw	r2,-4(fp)
 3245410:	10c0018d 	sth	r3,6(r2)
}
 3245414:	e037883a 	mov	sp,fp
 3245418:	df000017 	ldw	fp,0(sp)
 324541c:	dec00104 	addi	sp,sp,4
 3245420:	f800283a 	ret

03245424 <udp_socket>:
#define  MINSOCKET   1200
static unshort usocket = 0;   /* next socket to grab */

unshort
udp_socket(void)
{
 3245424:	defffe04 	addi	sp,sp,-8
 3245428:	df000115 	stw	fp,4(sp)
 324542c:	df000104 	addi	fp,sp,4
   UDPCONN tmp;

   if (usocket < MINSOCKET)
 3245430:	d0a9080b 	ldhu	r2,-23520(gp)
 3245434:	10bfffcc 	andi	r2,r2,65535
 3245438:	10812c28 	cmpgeui	r2,r2,1200
 324543c:	10000c1e 	bne	r2,zero,3245470 <udp_socket+0x4c>
   {
      /* logic for for init and after wraps */
      usocket = (unshort)(cticks & 0x7fff);
 3245440:	0080c974 	movhi	r2,805
 3245444:	10934104 	addi	r2,r2,19716
 3245448:	10800017 	ldw	r2,0(r2)
 324544c:	109fffcc 	andi	r2,r2,32767
 3245450:	d0a9080d 	sth	r2,-23520(gp)
      if (usocket < MINSOCKET)
 3245454:	d0a9080b 	ldhu	r2,-23520(gp)
 3245458:	10bfffcc 	andi	r2,r2,65535
 324545c:	10812c28 	cmpgeui	r2,r2,1200
 3245460:	1000031e 	bne	r2,zero,3245470 <udp_socket+0x4c>
         usocket += MINSOCKET;
 3245464:	d0a9080b 	ldhu	r2,-23520(gp)
 3245468:	10812c04 	addi	r2,r2,1200
 324546c:	d0a9080d 	sth	r2,-23520(gp)
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 3245470:	0080c974 	movhi	r2,805
 3245474:	10933504 	addi	r2,r2,19668
 3245478:	10800017 	ldw	r2,0(r2)
 324547c:	e0bfff15 	stw	r2,-4(fp)
 3245480:	00001006 	br	32454c4 <udp_socket+0xa0>
   {
      if (tmp->u_lport == usocket)
 3245484:	e0bfff17 	ldw	r2,-4(fp)
 3245488:	1080018b 	ldhu	r2,6(r2)
 324548c:	d0e9080b 	ldhu	r3,-23520(gp)
 3245490:	113fffcc 	andi	r4,r2,65535
 3245494:	18bfffcc 	andi	r2,r3,65535
 3245498:	2080071e 	bne	r4,r2,32454b8 <udp_socket+0x94>
      {
         usocket++;     /* bump socket number */
 324549c:	d0a9080b 	ldhu	r2,-23520(gp)
 32454a0:	10800044 	addi	r2,r2,1
 32454a4:	d0a9080d 	sth	r2,-23520(gp)
         tmp = firstudp;   /* restart scan */
 32454a8:	0080c974 	movhi	r2,805
 32454ac:	10933504 	addi	r2,r2,19668
 32454b0:	10800017 	ldw	r2,0(r2)
 32454b4:	e0bfff15 	stw	r2,-4(fp)
      usocket = (unshort)(cticks & 0x7fff);
      if (usocket < MINSOCKET)
         usocket += MINSOCKET;
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 32454b8:	e0bfff17 	ldw	r2,-4(fp)
 32454bc:	10800017 	ldw	r2,0(r2)
 32454c0:	e0bfff15 	stw	r2,-4(fp)
 32454c4:	e0bfff17 	ldw	r2,-4(fp)
 32454c8:	1004c03a 	cmpne	r2,r2,zero
 32454cc:	103fed1e 	bne	r2,zero,3245484 <udp_socket+0x60>
         usocket++;     /* bump socket number */
         tmp = firstudp;   /* restart scan */
         continue;
      }
   }
   return usocket++;
 32454d0:	d0a9080b 	ldhu	r2,-23520(gp)
 32454d4:	10ffffcc 	andi	r3,r2,65535
 32454d8:	10800044 	addi	r2,r2,1
 32454dc:	d0a9080d 	sth	r2,-23520(gp)
 32454e0:	1805883a 	mov	r2,r3
}
 32454e4:	e037883a 	mov	sp,fp
 32454e8:	df000017 	ldw	fp,0(sp)
 32454ec:	dec00104 	addi	sp,sp,4
 32454f0:	f800283a 	ret

032454f4 <udp_alloc>:
 * RETURNS:  Returns buffer, or NULL in no buffer was available. 
 */

PACKET
udp_alloc(int datalen, int optlen)
{
 32454f4:	defffa04 	addi	sp,sp,-24
 32454f8:	dfc00515 	stw	ra,20(sp)
 32454fc:	df000415 	stw	fp,16(sp)
 3245500:	df000404 	addi	fp,sp,16
 3245504:	e13ffe15 	stw	r4,-8(fp)
 3245508:	e17fff15 	stw	r5,-4(fp)
   int   len;
   PACKET p;

   len = (datalen + sizeof(struct udp) + 1) & ~1;
 324550c:	e0bffe17 	ldw	r2,-8(fp)
 3245510:	10800244 	addi	r2,r2,9
 3245514:	1007883a 	mov	r3,r2
 3245518:	00bfff84 	movi	r2,-2
 324551c:	1884703a 	and	r2,r3,r2
 3245520:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 3245524:	01000084 	movi	r4,2
 3245528:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + UDPHDRSLEN + optlen);
 324552c:	e0fffd17 	ldw	r3,-12(fp)
 3245530:	e0bfff17 	ldw	r2,-4(fp)
 3245534:	1885883a 	add	r2,r3,r2
 3245538:	10800904 	addi	r2,r2,36
 324553c:	1009883a 	mov	r4,r2
 3245540:	322a2ac0 	call	322a2ac <pk_alloc>
 3245544:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3245548:	01000084 	movi	r4,2
 324554c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   if (p != (PACKET)NULL)
 3245550:	e0bffc17 	ldw	r2,-16(fp)
 3245554:	1005003a 	cmpeq	r2,r2,zero
 3245558:	1000101e 	bne	r2,zero,324559c <udp_alloc+0xa8>
   {
      /* set prot pointers past end of UDP header  */
      len = sizeof(struct ip) + (optlen >> 2) + sizeof(struct udp);
 324555c:	e0bfff17 	ldw	r2,-4(fp)
 3245560:	1005d0ba 	srai	r2,r2,2
 3245564:	10800704 	addi	r2,r2,28
 3245568:	e0bffd15 	stw	r2,-12(fp)
      p->nb_prot += len;
 324556c:	e0bffc17 	ldw	r2,-16(fp)
 3245570:	10c00317 	ldw	r3,12(r2)
 3245574:	e0bffd17 	ldw	r2,-12(fp)
 3245578:	1887883a 	add	r3,r3,r2
 324557c:	e0bffc17 	ldw	r2,-16(fp)
 3245580:	10c00315 	stw	r3,12(r2)
      p->nb_plen -= len;
 3245584:	e0bffc17 	ldw	r2,-16(fp)
 3245588:	10c00417 	ldw	r3,16(r2)
 324558c:	e0bffd17 	ldw	r2,-12(fp)
 3245590:	1887c83a 	sub	r3,r3,r2
 3245594:	e0bffc17 	ldw	r2,-16(fp)
 3245598:	10c00415 	stw	r3,16(r2)
   }

   return (p);
 324559c:	e0bffc17 	ldw	r2,-16(fp)
}
 32455a0:	e037883a 	mov	sp,fp
 32455a4:	dfc00117 	ldw	ra,4(sp)
 32455a8:	df000017 	ldw	fp,0(sp)
 32455ac:	dec00204 	addi	sp,sp,8
 32455b0:	f800283a 	ret

032455b4 <udp_maxalloc>:
 *          returned value, the allocation will fail
 */

int
udp_maxalloc(void)
{
 32455b4:	deffff04 	addi	sp,sp,-4
 32455b8:	df000015 	stw	fp,0(sp)
 32455bc:	d839883a 	mov	fp,sp
    * created is ((2^16 - 1) - (size of IP and UDP headers)) */
   return (0xFFFF - (sizeof (struct ip) + sizeof (struct udp)));
#else
   /* if heap buffers are not available, the largest size of a UDP datagram
    * is constrained by what will fit inside a big buffer */
   return (bigbufsiz - UDPHDRSLEN);
 32455c0:	0080c974 	movhi	r2,805
 32455c4:	108a9704 	addi	r2,r2,10844
 32455c8:	10800017 	ldw	r2,0(r2)
 32455cc:	10bff704 	addi	r2,r2,-36
#endif
}
 32455d0:	e037883a 	mov	sp,fp
 32455d4:	df000017 	ldw	fp,0(sp)
 32455d8:	dec00104 	addi	sp,sp,4
 32455dc:	f800283a 	ret

032455e0 <udp_free>:
 * RETURNS: void
 */

void
udp_free(PACKET p)
{
 32455e0:	defffd04 	addi	sp,sp,-12
 32455e4:	dfc00215 	stw	ra,8(sp)
 32455e8:	df000115 	stw	fp,4(sp)
 32455ec:	df000104 	addi	fp,sp,4
 32455f0:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 32455f4:	01000084 	movi	r4,2
 32455f8:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   pk_free(p);
 32455fc:	e13fff17 	ldw	r4,-4(fp)
 3245600:	322a6400 	call	322a640 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3245604:	01000084 	movi	r4,2
 3245608:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
}
 324560c:	e037883a 	mov	sp,fp
 3245610:	dfc00117 	ldw	ra,4(sp)
 3245614:	df000017 	ldw	fp,0(sp)
 3245618:	dec00204 	addi	sp,sp,8
 324561c:	f800283a 	ret

03245620 <igmpv1_input>:
 * OUTPUT: This function returns IGMP_ERR if it is passed an "unknown"
 * packet type.  Otherwise, it returns IGMP_OK.
 */

int igmpv1_input(PACKET p)
{
 3245620:	defff704 	addi	sp,sp,-36
 3245624:	dfc00815 	stw	ra,32(sp)
 3245628:	df000715 	stw	fp,28(sp)
 324562c:	df000704 	addi	fp,sp,28
 3245630:	e13ffe15 	stw	r4,-8(fp)
   struct igmp *  igmp;
   struct ip *    pip;
   struct in_multi * inm;
   NET netp  = p->net;
 3245634:	e0bffe17 	ldw	r2,-8(fp)
 3245638:	10800617 	ldw	r2,24(r2)
 324563c:	e0bffa15 	stw	r2,-24(fp)
   int rc;
         
   pip = ip_head (p);
 3245640:	e0bffe17 	ldw	r2,-8(fp)
 3245644:	10800317 	ldw	r2,12(r2)
 3245648:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));
 324564c:	e0bffc17 	ldw	r2,-16(fp)
 3245650:	10800003 	ldbu	r2,0(r2)
 3245654:	10803fcc 	andi	r2,r2,255
 3245658:	108003cc 	andi	r2,r2,15
 324565c:	1085883a 	add	r2,r2,r2
 3245660:	1085883a 	add	r2,r2,r2
 3245664:	1007883a 	mov	r3,r2
 3245668:	e0bffc17 	ldw	r2,-16(fp)
 324566c:	1885883a 	add	r2,r3,r2
 3245670:	e0bffd15 	stw	r2,-12(fp)

   switch (igmp->igmp_type) 
 3245674:	e0bffd17 	ldw	r2,-12(fp)
 3245678:	10800003 	ldbu	r2,0(r2)
 324567c:	10803fcc 	andi	r2,r2,255
 3245680:	e0bfff15 	stw	r2,-4(fp)
 3245684:	e0ffff17 	ldw	r3,-4(fp)
 3245688:	18800460 	cmpeqi	r2,r3,17
 324568c:	1000041e 	bne	r2,zero,32456a0 <igmpv1_input+0x80>
 3245690:	e0ffff17 	ldw	r3,-4(fp)
 3245694:	188004a0 	cmpeqi	r2,r3,18
 3245698:	1000611e 	bne	r2,zero,3245820 <igmpv1_input+0x200>
 324569c:	00008506 	br	32458b4 <igmpv1_input+0x294>
   {
   case IGMP_HOST_MEMBERSHIP_QUERY:
      ++igmpstats.igmpv1mode_v1_queries_rcvd;
 32456a0:	0080c9b4 	movhi	r2,806
 32456a4:	10b34904 	addi	r2,r2,-13020
 32456a8:	10800117 	ldw	r2,4(r2)
 32456ac:	10c00044 	addi	r3,r2,1
 32456b0:	0080c9b4 	movhi	r2,806
 32456b4:	10b34904 	addi	r2,r2,-13020
 32456b8:	10c00115 	stw	r3,4(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 32456bc:	e0bffa17 	ldw	r2,-24(fp)
 32456c0:	10802c17 	ldw	r2,176(r2)
 32456c4:	e0bffb15 	stw	r2,-20(fp)
 32456c8:	00005006 	br	324580c <igmpv1_input+0x1ec>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
 32456cc:	e0bffb17 	ldw	r2,-20(fp)
 32456d0:	10800017 	ldw	r2,0(r2)
 32456d4:	1005003a 	cmpeq	r2,r2,zero
 32456d8:	1000491e 	bne	r2,zero,3245800 <igmpv1_input+0x1e0>
            continue;
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 32456dc:	e0bffb17 	ldw	r2,-20(fp)
 32456e0:	10c00017 	ldw	r3,0(r2)
 32456e4:	0080c974 	movhi	r2,805
 32456e8:	10932104 	addi	r2,r2,19588
 32456ec:	10800017 	ldw	r2,0(r2)
 32456f0:	18804326 	beq	r3,r2,3245800 <igmpv1_input+0x1e0>
         {
            if (inm->inm_timer == 0)
 32456f4:	e0bffb17 	ldw	r2,-20(fp)
 32456f8:	10800317 	ldw	r2,12(r2)
 32456fc:	1004c03a 	cmpne	r2,r2,zero
 3245700:	10003f1e 	bne	r2,zero,3245800 <igmpv1_input+0x1e0>
            {
               inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 3245704:	0080c9b4 	movhi	r2,806
 3245708:	10b54b04 	addi	r2,r2,-10964
 324570c:	11000217 	ldw	r4,8(r2)
 3245710:	0080c9b4 	movhi	r2,806
 3245714:	10b34504 	addi	r2,r2,-13036
 3245718:	10800017 	ldw	r2,0(r2)
 324571c:	10800a17 	ldw	r2,40(r2)
 3245720:	1004d63a 	srli	r2,r2,24
 3245724:	10c03fcc 	andi	r3,r2,255
 3245728:	0080c9b4 	movhi	r2,806
 324572c:	10b34504 	addi	r2,r2,-13036
 3245730:	10800017 	ldw	r2,0(r2)
 3245734:	10800a17 	ldw	r2,40(r2)
 3245738:	1004d23a 	srli	r2,r2,8
 324573c:	10bfc00c 	andi	r2,r2,65280
 3245740:	1886b03a 	or	r3,r3,r2
 3245744:	0080c9b4 	movhi	r2,806
 3245748:	10b34504 	addi	r2,r2,-13036
 324574c:	10800017 	ldw	r2,0(r2)
 3245750:	10800a17 	ldw	r2,40(r2)
 3245754:	10bfc00c 	andi	r2,r2,65280
 3245758:	1004923a 	slli	r2,r2,8
 324575c:	1886b03a 	or	r3,r3,r2
 3245760:	0080c9b4 	movhi	r2,806
 3245764:	10b34504 	addi	r2,r2,-13036
 3245768:	10800017 	ldw	r2,0(r2)
 324576c:	10800a17 	ldw	r2,40(r2)
 3245770:	10803fcc 	andi	r2,r2,255
 3245774:	1004963a 	slli	r2,r2,24
 3245778:	1884b03a 	or	r2,r3,r2
 324577c:	2089883a 	add	r4,r4,r2
 3245780:	e0bffb17 	ldw	r2,-20(fp)
 3245784:	10800017 	ldw	r2,0(r2)
 3245788:	1004d63a 	srli	r2,r2,24
 324578c:	10c03fcc 	andi	r3,r2,255
 3245790:	e0bffb17 	ldw	r2,-20(fp)
 3245794:	10800017 	ldw	r2,0(r2)
 3245798:	1004d23a 	srli	r2,r2,8
 324579c:	10bfc00c 	andi	r2,r2,65280
 32457a0:	1886b03a 	or	r3,r3,r2
 32457a4:	e0bffb17 	ldw	r2,-20(fp)
 32457a8:	10800017 	ldw	r2,0(r2)
 32457ac:	10bfc00c 	andi	r2,r2,65280
 32457b0:	1004923a 	slli	r2,r2,8
 32457b4:	1886b03a 	or	r3,r3,r2
 32457b8:	e0bffb17 	ldw	r2,-20(fp)
 32457bc:	10800017 	ldw	r2,0(r2)
 32457c0:	10803fcc 	andi	r2,r2,255
 32457c4:	1004963a 	slli	r2,r2,24
 32457c8:	1884b03a 	or	r2,r3,r2
 32457cc:	2089883a 	add	r4,r4,r2
 32457d0:	01400c84 	movi	r5,50
 32457d4:	32047c80 	call	32047c8 <__umodsi3>
 32457d8:	10c00044 	addi	r3,r2,1
 32457dc:	e0bffb17 	ldw	r2,-20(fp)
 32457e0:	10c00315 	stw	r3,12(r2)
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
 32457e4:	0080c974 	movhi	r2,805
 32457e8:	10931f04 	addi	r2,r2,19580
 32457ec:	10800017 	ldw	r2,0(r2)
 32457f0:	10c00044 	addi	r3,r2,1
 32457f4:	0080c974 	movhi	r2,805
 32457f8:	10931f04 	addi	r2,r2,19580
 32457fc:	10c00015 	stw	r3,0(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 3245800:	e0bffb17 	ldw	r2,-20(fp)
 3245804:	10800517 	ldw	r2,20(r2)
 3245808:	e0bffb15 	stw	r2,-20(fp)
 324580c:	e0bffb17 	ldw	r2,-20(fp)
 3245810:	1004c03a 	cmpne	r2,r2,zero
 3245814:	103fad1e 	bne	r2,zero,32456cc <igmpv1_input+0xac>
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
            }   
         }
      }
      rc = IGMP_OK;
 3245818:	e03ff915 	stw	zero,-28(fp)
      break;
 324581c:	00002e06 	br	32458d8 <igmpv1_input+0x2b8>

   case IGMP_HOST_MEMBERSHIP_REPORT:
      ++igmpstats.igmpv1mode_v1_reports_rcvd;
 3245820:	0080c9b4 	movhi	r2,806
 3245824:	10b34904 	addi	r2,r2,-13020
 3245828:	10800217 	ldw	r2,8(r2)
 324582c:	10c00044 	addi	r3,r2,1
 3245830:	0080c9b4 	movhi	r2,806
 3245834:	10b34904 	addi	r2,r2,-13020
 3245838:	10c00215 	stw	r3,8(r2)
      /*
       * If we belong to the group being reported and have a 
       * running timer for that group, stop our timer for that 
       * group.
       */
      inm = lookup_mcast(igmp->igmp_group, netp);
 324583c:	e0bffd17 	ldw	r2,-12(fp)
 3245840:	11000117 	ldw	r4,4(r2)
 3245844:	e17ffa17 	ldw	r5,-24(fp)
 3245848:	3243a500 	call	3243a50 <lookup_mcast>
 324584c:	e0bffb15 	stw	r2,-20(fp)
      if (inm != NULL) 
 3245850:	e0bffb17 	ldw	r2,-20(fp)
 3245854:	1005003a 	cmpeq	r2,r2,zero
 3245858:	1000141e 	bne	r2,zero,32458ac <igmpv1_input+0x28c>
      {
         if (inm->inm_timer > 0)
 324585c:	e0bffb17 	ldw	r2,-20(fp)
 3245860:	10800317 	ldw	r2,12(r2)
 3245864:	1005003a 	cmpeq	r2,r2,zero
 3245868:	1000101e 	bne	r2,zero,32458ac <igmpv1_input+0x28c>
         {
            inm->inm_timer = 0;
 324586c:	e0bffb17 	ldw	r2,-20(fp)
 3245870:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 3245874:	0080c974 	movhi	r2,805
 3245878:	10931f04 	addi	r2,r2,19580
 324587c:	10800017 	ldw	r2,0(r2)
 3245880:	10ffffc4 	addi	r3,r2,-1
 3245884:	0080c974 	movhi	r2,805
 3245888:	10931f04 	addi	r2,r2,19580
 324588c:	10c00015 	stw	r3,0(r2)
            ++igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer;
 3245890:	0080c9b4 	movhi	r2,806
 3245894:	10b34904 	addi	r2,r2,-13020
 3245898:	10800317 	ldw	r2,12(r2)
 324589c:	10c00044 	addi	r3,r2,1
 32458a0:	0080c9b4 	movhi	r2,806
 32458a4:	10b34904 	addi	r2,r2,-13020
 32458a8:	10c00315 	stw	r3,12(r2)
         }
      }
      rc = IGMP_OK;
 32458ac:	e03ff915 	stw	zero,-28(fp)
      break;
 32458b0:	00000906 	br	32458d8 <igmpv1_input+0x2b8>
      
   default:
      ++igmpstats.igmpv1mode_unknown_pkttype;
 32458b4:	0080c9b4 	movhi	r2,806
 32458b8:	10b34904 	addi	r2,r2,-13020
 32458bc:	10801017 	ldw	r2,64(r2)
 32458c0:	10c00044 	addi	r3,r2,1
 32458c4:	0080c9b4 	movhi	r2,806
 32458c8:	10b34904 	addi	r2,r2,-13020
 32458cc:	10c01015 	stw	r3,64(r2)
      rc = IGMP_ERR;
 32458d0:	00bfffc4 	movi	r2,-1
 32458d4:	e0bff915 	stw	r2,-28(fp)
      break;   
   }

   /* we're done with the received packet; return packet buffer back 
    * to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 32458d8:	01000084 	movi	r4,2
 32458dc:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   pk_free(p);
 32458e0:	e13ffe17 	ldw	r4,-8(fp)
 32458e4:	322a6400 	call	322a640 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 32458e8:	01000084 	movi	r4,2
 32458ec:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      
   return rc;
 32458f0:	e0bff917 	ldw	r2,-28(fp)
}
 32458f4:	e037883a 	mov	sp,fp
 32458f8:	dfc00117 	ldw	ra,4(sp)
 32458fc:	df000017 	ldw	fp,0(sp)
 3245900:	dec00204 	addi	sp,sp,8
 3245904:	f800283a 	ret

03245908 <igmpv2_input>:
 * from igmpv2_process_report (), IGMP_OK (for a received Leave Group
 * message only), or IGMP_ERR (for a message of an "unknown" type).
 */

int igmpv2_input (PACKET p)
{
 3245908:	defff704 	addi	sp,sp,-36
 324590c:	dfc00815 	stw	ra,32(sp)
 3245910:	df000715 	stw	fp,28(sp)
 3245914:	df000704 	addi	fp,sp,28
 3245918:	e13ffe15 	stw	r4,-8(fp)
   struct ip * pip;
   int igmplen;
   u_char type;
   int rc;

   pip = ip_head (p);    
 324591c:	e0bffe17 	ldw	r2,-8(fp)
 3245920:	10800317 	ldw	r2,12(r2)
 3245924:	e0bffc15 	stw	r2,-16(fp)
   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */   
   igmplen = p->nb_plen - ip_hlen (pip);
 3245928:	e0bffe17 	ldw	r2,-8(fp)
 324592c:	10c00417 	ldw	r3,16(r2)
 3245930:	e0bffc17 	ldw	r2,-16(fp)
 3245934:	10800003 	ldbu	r2,0(r2)
 3245938:	10803fcc 	andi	r2,r2,255
 324593c:	108003cc 	andi	r2,r2,15
 3245940:	1085883a 	add	r2,r2,r2
 3245944:	1085883a 	add	r2,r2,r2
 3245948:	1885c83a 	sub	r2,r3,r2
 324594c:	e0bffb15 	stw	r2,-20(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 3245950:	e0bffc17 	ldw	r2,-16(fp)
 3245954:	10800003 	ldbu	r2,0(r2)
 3245958:	10803fcc 	andi	r2,r2,255
 324595c:	108003cc 	andi	r2,r2,15
 3245960:	1085883a 	add	r2,r2,r2
 3245964:	1085883a 	add	r2,r2,r2
 3245968:	1007883a 	mov	r3,r2
 324596c:	e0bffc17 	ldw	r2,-16(fp)
 3245970:	1885883a 	add	r2,r3,r2
 3245974:	e0bffd15 	stw	r2,-12(fp)
   /* extract the IGMP packet type from received packet */
   type = igmp->igmp_type;
 3245978:	e0bffd17 	ldw	r2,-12(fp)
 324597c:	10800003 	ldbu	r2,0(r2)
 3245980:	e0bffa05 	stb	r2,-24(fp)

   switch (type) 
 3245984:	e0bffa03 	ldbu	r2,-24(fp)
 3245988:	e0bfff15 	stw	r2,-4(fp)
 324598c:	e0ffff17 	ldw	r3,-4(fp)
 3245990:	188004a0 	cmpeqi	r2,r3,18
 3245994:	1000121e 	bne	r2,zero,32459e0 <igmpv2_input+0xd8>
 3245998:	e0ffff17 	ldw	r3,-4(fp)
 324599c:	188004c8 	cmpgei	r2,r3,19
 32459a0:	1000041e 	bne	r2,zero,32459b4 <igmpv2_input+0xac>
 32459a4:	e0ffff17 	ldw	r3,-4(fp)
 32459a8:	18800460 	cmpeqi	r2,r3,17
 32459ac:	1000081e 	bne	r2,zero,32459d0 <igmpv2_input+0xc8>
 32459b0:	00001806 	br	3245a14 <igmpv2_input+0x10c>
 32459b4:	e0ffff17 	ldw	r3,-4(fp)
 32459b8:	188005a0 	cmpeqi	r2,r3,22
 32459bc:	1000081e 	bne	r2,zero,32459e0 <igmpv2_input+0xd8>
 32459c0:	e0ffff17 	ldw	r3,-4(fp)
 32459c4:	188005e0 	cmpeqi	r2,r3,23
 32459c8:	1000091e 	bne	r2,zero,32459f0 <igmpv2_input+0xe8>
 32459cc:	00001106 	br	3245a14 <igmpv2_input+0x10c>
   {
      case IGMP_HOST_MEMBERSHIP_QUERY:
         rc = igmpv2_process_query (p);
 32459d0:	e13ffe17 	ldw	r4,-8(fp)
 32459d4:	3245bb40 	call	3245bb4 <igmpv2_process_query>
 32459d8:	e0bff915 	stw	r2,-28(fp)
         break;
 32459dc:	00001606 	br	3245a38 <igmpv2_input+0x130>

      case IGMP_HOST_MEMBERSHIP_REPORT:
      case IGMPv2_MEMBERSHIP_REPORT:
         rc = igmpv2_process_report (p);
 32459e0:	e13ffe17 	ldw	r4,-8(fp)
 32459e4:	3245a680 	call	3245a68 <igmpv2_process_report>
 32459e8:	e0bff915 	stw	r2,-28(fp)
         break;
 32459ec:	00001206 	br	3245a38 <igmpv2_input+0x130>
          * expect to receive such messages.  However, according to
          * RFC 2236, some implementations of an older version of the 
          * IGMPv2 specification send leave messages to the group 
          * being left.  If we do receive such a message, we will 
          * drop it. */       
         ++igmpstats.igmpv2mode_v2_leave_msgs_rcvd;
 32459f0:	0080c9b4 	movhi	r2,806
 32459f4:	10b34904 	addi	r2,r2,-13020
 32459f8:	10800917 	ldw	r2,36(r2)
 32459fc:	10c00044 	addi	r3,r2,1
 3245a00:	0080c9b4 	movhi	r2,806
 3245a04:	10b34904 	addi	r2,r2,-13020
 3245a08:	10c00915 	stw	r3,36(r2)
         rc = IGMP_OK;
 3245a0c:	e03ff915 	stw	zero,-28(fp)
         break;               
 3245a10:	00000906 	br	3245a38 <igmpv2_input+0x130>

      default:     
         ++igmpstats.igmpv2mode_unknown_pkttype;
 3245a14:	0080c9b4 	movhi	r2,806
 3245a18:	10b34904 	addi	r2,r2,-13020
 3245a1c:	10801517 	ldw	r2,84(r2)
 3245a20:	10c00044 	addi	r3,r2,1
 3245a24:	0080c9b4 	movhi	r2,806
 3245a28:	10b34904 	addi	r2,r2,-13020
 3245a2c:	10c01515 	stw	r3,84(r2)
         rc = IGMP_ERR;         
 3245a30:	00bfffc4 	movi	r2,-1
 3245a34:	e0bff915 	stw	r2,-28(fp)
         break;
   } /* end SWITCH */

   /* we're done processing the received packet; return packet buffer 
    * back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 3245a38:	01000084 	movi	r4,2
 3245a3c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   pk_free(p);
 3245a40:	e13ffe17 	ldw	r4,-8(fp)
 3245a44:	322a6400 	call	322a640 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 3245a48:	01000084 	movi	r4,2
 3245a4c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
   
   return rc;
 3245a50:	e0bff917 	ldw	r2,-28(fp)
}
 3245a54:	e037883a 	mov	sp,fp
 3245a58:	dfc00117 	ldw	ra,4(sp)
 3245a5c:	df000017 	ldw	fp,0(sp)
 3245a60:	dec00204 	addi	sp,sp,8
 3245a64:	f800283a 	ret

03245a68 <igmpv2_process_report>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_report (PACKET p)
{
 3245a68:	defff904 	addi	sp,sp,-28
 3245a6c:	dfc00615 	stw	ra,24(sp)
 3245a70:	df000515 	stw	fp,20(sp)
 3245a74:	df000504 	addi	fp,sp,20
 3245a78:	e13fff15 	stw	r4,-4(fp)
   struct igmp * igmp;
   struct ip * pip;
   NET netp;
   struct in_multi * inm;

   netp = p->net;
 3245a7c:	e0bfff17 	ldw	r2,-4(fp)
 3245a80:	10800617 	ldw	r2,24(r2)
 3245a84:	e0bffc15 	stw	r2,-16(fp)
   pip = ip_head (p);
 3245a88:	e0bfff17 	ldw	r2,-4(fp)
 3245a8c:	10800317 	ldw	r2,12(r2)
 3245a90:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 3245a94:	e0bffd17 	ldw	r2,-12(fp)
 3245a98:	10800003 	ldbu	r2,0(r2)
 3245a9c:	10803fcc 	andi	r2,r2,255
 3245aa0:	108003cc 	andi	r2,r2,15
 3245aa4:	1085883a 	add	r2,r2,r2
 3245aa8:	1085883a 	add	r2,r2,r2
 3245aac:	1007883a 	mov	r3,r2
 3245ab0:	e0bffd17 	ldw	r2,-12(fp)
 3245ab4:	1885883a 	add	r2,r3,r2
 3245ab8:	e0bffe15 	stw	r2,-8(fp)
    * processing IGMPv2 packets (it has "downgraded" itself because
    * there are IGMPv1 routers on that network); however, we do not
    * know that, and hence we don't cancel our timer (for the 
    * subsequent transmission of a IGMPv1 report).
    */
   inm = lookup_mcast(igmp->igmp_group, netp);
 3245abc:	e0bffe17 	ldw	r2,-8(fp)
 3245ac0:	11000117 	ldw	r4,4(r2)
 3245ac4:	e17ffc17 	ldw	r5,-16(fp)
 3245ac8:	3243a500 	call	3243a50 <lookup_mcast>
 3245acc:	e0bffb15 	stw	r2,-20(fp)
   if (inm != NULL) 
 3245ad0:	e0bffb17 	ldw	r2,-20(fp)
 3245ad4:	1005003a 	cmpeq	r2,r2,zero
 3245ad8:	1000291e 	bne	r2,zero,3245b80 <igmpv2_process_report+0x118>
   {
      if (inm->inm_timer != 0)
 3245adc:	e0bffb17 	ldw	r2,-20(fp)
 3245ae0:	10800317 	ldw	r2,12(r2)
 3245ae4:	1005003a 	cmpeq	r2,r2,zero
 3245ae8:	10001d1e 	bne	r2,zero,3245b60 <igmpv2_process_report+0xf8>
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 3245aec:	e0bffc17 	ldw	r2,-16(fp)
 3245af0:	10802d03 	ldbu	r2,180(r2)
 3245af4:	10803fcc 	andi	r2,r2,255
 3245af8:	1005003a 	cmpeq	r2,r2,zero
 3245afc:	1000051e 	bne	r2,zero,3245b14 <igmpv2_process_report+0xac>
 3245b00:	e0bffe17 	ldw	r2,-8(fp)
 3245b04:	10800003 	ldbu	r2,0(r2)
 3245b08:	10803fcc 	andi	r2,r2,255
 3245b0c:	108005a0 	cmpeqi	r2,r2,22
 3245b10:	1000221e 	bne	r2,zero,3245b9c <igmpv2_process_report+0x134>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
         {
            /* cancel timer */
            inm->inm_timer = 0;
 3245b14:	e0bffb17 	ldw	r2,-20(fp)
 3245b18:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 3245b1c:	0080c974 	movhi	r2,805
 3245b20:	10931f04 	addi	r2,r2,19580
 3245b24:	10800017 	ldw	r2,0(r2)
 3245b28:	10ffffc4 	addi	r3,r2,-1
 3245b2c:	0080c974 	movhi	r2,805
 3245b30:	10931f04 	addi	r2,r2,19580
 3245b34:	10c00015 	stw	r3,0(r2)
            /* indicate that we are not the last host to send a 
             * report for this group */
            inm->last2send_report = IGMP_FALSE;
 3245b38:	e0bffb17 	ldw	r2,-20(fp)
 3245b3c:	10000405 	stb	zero,16(r2)
            ++igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer;
 3245b40:	0080c9b4 	movhi	r2,806
 3245b44:	10b34904 	addi	r2,r2,-13020
 3245b48:	10800717 	ldw	r2,28(r2)
 3245b4c:	10c00044 	addi	r3,r2,1
 3245b50:	0080c9b4 	movhi	r2,806
 3245b54:	10b34904 	addi	r2,r2,-13020
 3245b58:	10c00715 	stw	r3,28(r2)
 3245b5c:	00000f06 	br	3245b9c <igmpv2_process_report+0x134>
      else
      {
         /* we don't have a timer running; perhaps the source
          * host has just joined the group, and has sent an
          * unsolicited report */
         ++igmpstats.igmpv2mode_v12_reports_rcvd_no_timer;   
 3245b60:	0080c9b4 	movhi	r2,806
 3245b64:	10b34904 	addi	r2,r2,-13020
 3245b68:	10800817 	ldw	r2,32(r2)
 3245b6c:	10c00044 	addi	r3,r2,1
 3245b70:	0080c9b4 	movhi	r2,806
 3245b74:	10b34904 	addi	r2,r2,-13020
 3245b78:	10c00815 	stw	r3,32(r2)
 3245b7c:	00000706 	br	3245b9c <igmpv2_process_report+0x134>
       * on that interface.  Even if imperfect filtering at the 
       * device level causes reports for unregistered groups to 
       * be passed up to the IP module, ip_rcv_phase2 () is 
       * responsible for dropping them, and so we should never
       * receive such packets. */
      ++igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd;
 3245b80:	0080c9b4 	movhi	r2,806
 3245b84:	10b34904 	addi	r2,r2,-13020
 3245b88:	10801317 	ldw	r2,76(r2)
 3245b8c:	10c00044 	addi	r3,r2,1
 3245b90:	0080c9b4 	movhi	r2,806
 3245b94:	10b34904 	addi	r2,r2,-13020
 3245b98:	10c01315 	stw	r3,76(r2)
   }
   
   return IGMP_OK;   
 3245b9c:	0005883a 	mov	r2,zero
}
 3245ba0:	e037883a 	mov	sp,fp
 3245ba4:	dfc00117 	ldw	ra,4(sp)
 3245ba8:	df000017 	ldw	fp,0(sp)
 3245bac:	dec00204 	addi	sp,sp,8
 3245bb0:	f800283a 	ret

03245bb4 <igmpv2_process_query>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_query (PACKET p)
{
 3245bb4:	defff704 	addi	sp,sp,-36
 3245bb8:	dfc00815 	stw	ra,32(sp)
 3245bbc:	df000715 	stw	fp,28(sp)
 3245bc0:	df000704 	addi	fp,sp,28
 3245bc4:	e13fff15 	stw	r4,-4(fp)
   u_short max_resp_time;
   u_char process_all;
   struct in_multi * inm;
   ip_addr mcgrp_addr;

   netp = p->net;
 3245bc8:	e0bfff17 	ldw	r2,-4(fp)
 3245bcc:	10800617 	ldw	r2,24(r2)
 3245bd0:	e0bffc15 	stw	r2,-16(fp)
   pip = ip_head (p);
 3245bd4:	e0bfff17 	ldw	r2,-4(fp)
 3245bd8:	10800317 	ldw	r2,12(r2)
 3245bdc:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));
 3245be0:	e0bffd17 	ldw	r2,-12(fp)
 3245be4:	10800003 	ldbu	r2,0(r2)
 3245be8:	10803fcc 	andi	r2,r2,255
 3245bec:	108003cc 	andi	r2,r2,15
 3245bf0:	1085883a 	add	r2,r2,r2
 3245bf4:	1085883a 	add	r2,r2,r2
 3245bf8:	1007883a 	mov	r3,r2
 3245bfc:	e0bffd17 	ldw	r2,-12(fp)
 3245c00:	1885883a 	add	r2,r3,r2
 3245c04:	e0bffe15 	stw	r2,-8(fp)
   mcgrp_addr = ntohl(igmp->igmp_group);
 3245c08:	e0bffe17 	ldw	r2,-8(fp)
 3245c0c:	10800117 	ldw	r2,4(r2)
 3245c10:	1004d63a 	srli	r2,r2,24
 3245c14:	10c03fcc 	andi	r3,r2,255
 3245c18:	e0bffe17 	ldw	r2,-8(fp)
 3245c1c:	10800117 	ldw	r2,4(r2)
 3245c20:	1004d23a 	srli	r2,r2,8
 3245c24:	10bfc00c 	andi	r2,r2,65280
 3245c28:	1886b03a 	or	r3,r3,r2
 3245c2c:	e0bffe17 	ldw	r2,-8(fp)
 3245c30:	10800117 	ldw	r2,4(r2)
 3245c34:	10bfc00c 	andi	r2,r2,65280
 3245c38:	1004923a 	slli	r2,r2,8
 3245c3c:	1886b03a 	or	r3,r3,r2
 3245c40:	e0bffe17 	ldw	r2,-8(fp)
 3245c44:	10800117 	ldw	r2,4(r2)
 3245c48:	10803fcc 	andi	r2,r2,255
 3245c4c:	1004963a 	slli	r2,r2,24
 3245c50:	1884b03a 	or	r2,r3,r2
 3245c54:	e0bff915 	stw	r2,-28(fp)

   if (igmp->igmp_code == 0)
 3245c58:	e0bffe17 	ldw	r2,-8(fp)
 3245c5c:	10800043 	ldbu	r2,1(r2)
 3245c60:	10803fcc 	andi	r2,r2,255
 3245c64:	1004c03a 	cmpne	r2,r2,zero
 3245c68:	1000141e 	bne	r2,zero,3245cbc <igmpv2_process_query+0x108>
   {
      /* this is a IGMPv1 Host Membership Query */
      netp->igmpv1_rtr_present = IGMP_TRUE;
 3245c6c:	e0fffc17 	ldw	r3,-16(fp)
 3245c70:	00800044 	movi	r2,1
 3245c74:	18802d05 	stb	r2,180(r3)
      netp->igmpv1_query_rcvd_time = cticks;      
 3245c78:	0080c974 	movhi	r2,805
 3245c7c:	10934104 	addi	r2,r2,19716
 3245c80:	10c00017 	ldw	r3,0(r2)
 3245c84:	e0bffc17 	ldw	r2,-16(fp)
 3245c88:	10c02e15 	stw	r3,184(r2)
      ++igmpstats.igmpv2mode_v1_queries_rcvd;
 3245c8c:	0080c9b4 	movhi	r2,806
 3245c90:	10b34904 	addi	r2,r2,-13020
 3245c94:	10800417 	ldw	r2,16(r2)
 3245c98:	10c00044 	addi	r3,r2,1
 3245c9c:	0080c9b4 	movhi	r2,806
 3245ca0:	10b34904 	addi	r2,r2,-13020
 3245ca4:	10c00415 	stw	r3,16(r2)
      /* set maximum time to respond to the equivalent of 10 
       * seconds worth of "ticks" (the timeout routine is
       * intended to be invoked PR_FASTHZ (5) times a second,
       * so each tick is equal to 200 ms) */
      max_resp_time = IGMP_MAX_HOST_REPORT_DELAY * PR_FASTHZ;
 3245ca8:	00800c84 	movi	r2,50
 3245cac:	e0bffb8d 	sth	r2,-18(fp)
      process_all = IGMP_TRUE;
 3245cb0:	00800044 	movi	r2,1
 3245cb4:	e0bffb05 	stb	r2,-20(fp)
 3245cb8:	00001d06 	br	3245d30 <igmpv2_process_query+0x17c>
   }
   else
   {
      /* this is either a IGMPv2 General Query or 
       * a IGMPv2 Group-Specific Query */
      if (igmp->igmp_group == 0)
 3245cbc:	e0bffe17 	ldw	r2,-8(fp)
 3245cc0:	10800117 	ldw	r2,4(r2)
 3245cc4:	1004c03a 	cmpne	r2,r2,zero
 3245cc8:	10000a1e 	bne	r2,zero,3245cf4 <igmpv2_process_query+0x140>
      {
         /* this is a IGMPv2 General Query */
         ++igmpstats.igmpv2mode_v2_general_queries_rcvd;
 3245ccc:	0080c9b4 	movhi	r2,806
 3245cd0:	10b34904 	addi	r2,r2,-13020
 3245cd4:	10800517 	ldw	r2,20(r2)
 3245cd8:	10c00044 	addi	r3,r2,1
 3245cdc:	0080c9b4 	movhi	r2,806
 3245ce0:	10b34904 	addi	r2,r2,-13020
 3245ce4:	10c00515 	stw	r3,20(r2)
         process_all = IGMP_TRUE;
 3245ce8:	00800044 	movi	r2,1
 3245cec:	e0bffb05 	stb	r2,-20(fp)
 3245cf0:	00000806 	br	3245d14 <igmpv2_process_query+0x160>
      }
      else
      {
         /* this is a IGMPv2 Group-Specific Query */       
         ++igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd;
 3245cf4:	0080c9b4 	movhi	r2,806
 3245cf8:	10b34904 	addi	r2,r2,-13020
 3245cfc:	10800617 	ldw	r2,24(r2)
 3245d00:	10c00044 	addi	r3,r2,1
 3245d04:	0080c9b4 	movhi	r2,806
 3245d08:	10b34904 	addi	r2,r2,-13020
 3245d0c:	10c00615 	stw	r3,24(r2)
         process_all = IGMP_FALSE;
 3245d10:	e03ffb05 	stb	zero,-20(fp)
       * IGMPv2 General Query or a IGMPv2 Group-Specific Query,
       * set maximum time to respond to value extracted 
       * from received message. The value in the message
       * is in tenths of a second.  max_resp_time is in
       * units of ticks (where one tick is 200 ms) */
      max_resp_time = (igmp->igmp_code * PR_FASTHZ) / 10;
 3245d14:	e0bffe17 	ldw	r2,-8(fp)
 3245d18:	10800043 	ldbu	r2,1(r2)
 3245d1c:	10c03fcc 	andi	r3,r2,255
 3245d20:	1804d7fa 	srli	r2,r3,31
 3245d24:	10c5883a 	add	r2,r2,r3
 3245d28:	1005d07a 	srai	r2,r2,1
 3245d2c:	e0bffb8d 	sth	r2,-18(fp)
   
   /* process all entries in a link's multicast address linked
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
 3245d30:	e0bffb03 	ldbu	r2,-20(fp)
 3245d34:	1005003a 	cmpeq	r2,r2,zero
 3245d38:	1000181e 	bne	r2,zero,3245d9c <igmpv2_process_query+0x1e8>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 3245d3c:	e0bffc17 	ldw	r2,-16(fp)
 3245d40:	10802c17 	ldw	r2,176(r2)
 3245d44:	e0bffa15 	stw	r2,-24(fp)
 3245d48:	00001006 	br	3245d8c <igmpv2_process_query+0x1d8>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 3245d4c:	e0bffa17 	ldw	r2,-24(fp)
 3245d50:	10800017 	ldw	r2,0(r2)
 3245d54:	1005003a 	cmpeq	r2,r2,zero
 3245d58:	1000091e 	bne	r2,zero,3245d80 <igmpv2_process_query+0x1cc>
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 3245d5c:	e0bffa17 	ldw	r2,-24(fp)
 3245d60:	10c00017 	ldw	r3,0(r2)
 3245d64:	0080c974 	movhi	r2,805
 3245d68:	10932104 	addi	r2,r2,19588
 3245d6c:	10800017 	ldw	r2,0(r2)
 3245d70:	18800326 	beq	r3,r2,3245d80 <igmpv2_process_query+0x1cc>
            igmpv2_chk_set_timer (inm, max_resp_time);
 3245d74:	e17ffb8b 	ldhu	r5,-18(fp)
 3245d78:	e13ffa17 	ldw	r4,-24(fp)
 3245d7c:	3245e000 	call	3245e00 <igmpv2_chk_set_timer>
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 3245d80:	e0bffa17 	ldw	r2,-24(fp)
 3245d84:	10800517 	ldw	r2,20(r2)
 3245d88:	e0bffa15 	stw	r2,-24(fp)
 3245d8c:	e0bffa17 	ldw	r2,-24(fp)
 3245d90:	1004c03a 	cmpne	r2,r2,zero
 3245d94:	103fed1e 	bne	r2,zero,3245d4c <igmpv2_process_query+0x198>
 3245d98:	00001306 	br	3245de8 <igmpv2_process_query+0x234>
   {
      /* process one (for IGMPv2 Group-Specific Query) entry (the 
       * one that corresponds to the address listed in the received 
       * query) - it should be present in the link's multicast
       * address list */
      inm = lookup_mcast(igmp->igmp_group, netp);
 3245d9c:	e0bffe17 	ldw	r2,-8(fp)
 3245da0:	11000117 	ldw	r4,4(r2)
 3245da4:	e17ffc17 	ldw	r5,-16(fp)
 3245da8:	3243a500 	call	3243a50 <lookup_mcast>
 3245dac:	e0bffa15 	stw	r2,-24(fp)
      if (inm != NULL)
 3245db0:	e0bffa17 	ldw	r2,-24(fp)
 3245db4:	1005003a 	cmpeq	r2,r2,zero
 3245db8:	1000041e 	bne	r2,zero,3245dcc <igmpv2_process_query+0x218>
         igmpv2_chk_set_timer (inm, max_resp_time);
 3245dbc:	e17ffb8b 	ldhu	r5,-18(fp)
 3245dc0:	e13ffa17 	ldw	r4,-24(fp)
 3245dc4:	3245e000 	call	3245e00 <igmpv2_chk_set_timer>
 3245dc8:	00000706 	br	3245de8 <igmpv2_process_query+0x234>
      else ++igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd;
 3245dcc:	0080c9b4 	movhi	r2,806
 3245dd0:	10b34904 	addi	r2,r2,-13020
 3245dd4:	10801217 	ldw	r2,72(r2)
 3245dd8:	10c00044 	addi	r3,r2,1
 3245ddc:	0080c9b4 	movhi	r2,806
 3245de0:	10b34904 	addi	r2,r2,-13020
 3245de4:	10c01215 	stw	r3,72(r2)
   } /* end ELSE (process ALL) */
   
   /* return success; caller will the received packet back to the 
    * free pool */
   return IGMP_OK;
 3245de8:	0005883a 	mov	r2,zero
}
 3245dec:	e037883a 	mov	sp,fp
 3245df0:	dfc00117 	ldw	ra,4(sp)
 3245df4:	df000017 	ldw	fp,0(sp)
 3245df8:	dec00204 	addi	sp,sp,8
 3245dfc:	f800283a 	ret

03245e00 <igmpv2_chk_set_timer>:
 *
 * OUTPUT: None.
 */

void igmpv2_chk_set_timer (struct in_multi * inm, u_short max_resp_time)
{  
 3245e00:	defffc04 	addi	sp,sp,-16
 3245e04:	dfc00315 	stw	ra,12(sp)
 3245e08:	df000215 	stw	fp,8(sp)
 3245e0c:	df000204 	addi	fp,sp,8
 3245e10:	e13ffe15 	stw	r4,-8(fp)
 3245e14:	e17fff0d 	sth	r5,-4(fp)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 3245e18:	e0bffe17 	ldw	r2,-8(fp)
 3245e1c:	10c00317 	ldw	r3,12(r2)
 3245e20:	e0bfff0b 	ldhu	r2,-4(fp)
 3245e24:	10c00436 	bltu	r2,r3,3245e38 <igmpv2_chk_set_timer+0x38>
 3245e28:	e0bffe17 	ldw	r2,-8(fp)
 3245e2c:	10800317 	ldw	r2,12(r2)
 3245e30:	1004c03a 	cmpne	r2,r2,zero
 3245e34:	1000431e 	bne	r2,zero,3245f44 <igmpv2_chk_set_timer+0x144>
       (inm->inm_timer == 0))
   {
      if (inm->inm_timer == 0) ++igmp_timers_are_running;
 3245e38:	e0bffe17 	ldw	r2,-8(fp)
 3245e3c:	10800317 	ldw	r2,12(r2)
 3245e40:	1004c03a 	cmpne	r2,r2,zero
 3245e44:	1000071e 	bne	r2,zero,3245e64 <igmpv2_chk_set_timer+0x64>
 3245e48:	0080c974 	movhi	r2,805
 3245e4c:	10931f04 	addi	r2,r2,19580
 3245e50:	10800017 	ldw	r2,0(r2)
 3245e54:	10c00044 	addi	r3,r2,1
 3245e58:	0080c974 	movhi	r2,805
 3245e5c:	10931f04 	addi	r2,r2,19580
 3245e60:	10c00015 	stw	r3,0(r2)
      inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY (max_resp_time, inm->inm_addr);                     
 3245e64:	0080c9b4 	movhi	r2,806
 3245e68:	10b54b04 	addi	r2,r2,-10964
 3245e6c:	11000217 	ldw	r4,8(r2)
 3245e70:	0080c9b4 	movhi	r2,806
 3245e74:	10b34504 	addi	r2,r2,-13036
 3245e78:	10800017 	ldw	r2,0(r2)
 3245e7c:	10800a17 	ldw	r2,40(r2)
 3245e80:	1004d63a 	srli	r2,r2,24
 3245e84:	10c03fcc 	andi	r3,r2,255
 3245e88:	0080c9b4 	movhi	r2,806
 3245e8c:	10b34504 	addi	r2,r2,-13036
 3245e90:	10800017 	ldw	r2,0(r2)
 3245e94:	10800a17 	ldw	r2,40(r2)
 3245e98:	1004d23a 	srli	r2,r2,8
 3245e9c:	10bfc00c 	andi	r2,r2,65280
 3245ea0:	1886b03a 	or	r3,r3,r2
 3245ea4:	0080c9b4 	movhi	r2,806
 3245ea8:	10b34504 	addi	r2,r2,-13036
 3245eac:	10800017 	ldw	r2,0(r2)
 3245eb0:	10800a17 	ldw	r2,40(r2)
 3245eb4:	10bfc00c 	andi	r2,r2,65280
 3245eb8:	1004923a 	slli	r2,r2,8
 3245ebc:	1886b03a 	or	r3,r3,r2
 3245ec0:	0080c9b4 	movhi	r2,806
 3245ec4:	10b34504 	addi	r2,r2,-13036
 3245ec8:	10800017 	ldw	r2,0(r2)
 3245ecc:	10800a17 	ldw	r2,40(r2)
 3245ed0:	10803fcc 	andi	r2,r2,255
 3245ed4:	1004963a 	slli	r2,r2,24
 3245ed8:	1884b03a 	or	r2,r3,r2
 3245edc:	2089883a 	add	r4,r4,r2
 3245ee0:	e0bffe17 	ldw	r2,-8(fp)
 3245ee4:	10800017 	ldw	r2,0(r2)
 3245ee8:	1004d63a 	srli	r2,r2,24
 3245eec:	10c03fcc 	andi	r3,r2,255
 3245ef0:	e0bffe17 	ldw	r2,-8(fp)
 3245ef4:	10800017 	ldw	r2,0(r2)
 3245ef8:	1004d23a 	srli	r2,r2,8
 3245efc:	10bfc00c 	andi	r2,r2,65280
 3245f00:	1886b03a 	or	r3,r3,r2
 3245f04:	e0bffe17 	ldw	r2,-8(fp)
 3245f08:	10800017 	ldw	r2,0(r2)
 3245f0c:	10bfc00c 	andi	r2,r2,65280
 3245f10:	1004923a 	slli	r2,r2,8
 3245f14:	1886b03a 	or	r3,r3,r2
 3245f18:	e0bffe17 	ldw	r2,-8(fp)
 3245f1c:	10800017 	ldw	r2,0(r2)
 3245f20:	10803fcc 	andi	r2,r2,255
 3245f24:	1004963a 	slli	r2,r2,24
 3245f28:	1884b03a 	or	r2,r3,r2
 3245f2c:	2089883a 	add	r4,r4,r2
 3245f30:	e17fff0b 	ldhu	r5,-4(fp)
 3245f34:	32047c80 	call	32047c8 <__umodsi3>
 3245f38:	10c00044 	addi	r3,r2,1
 3245f3c:	e0bffe17 	ldw	r2,-8(fp)
 3245f40:	10c00315 	stw	r3,12(r2)
   }

   return;
}
 3245f44:	e037883a 	mov	sp,fp
 3245f48:	dfc00117 	ldw	ra,4(sp)
 3245f4c:	df000017 	ldw	fp,0(sp)
 3245f50:	dec00204 	addi	sp,sp,8
 3245f54:	f800283a 	ret

03245f58 <igmpv2_chk4_rtr_alert_opt>:
 *         the IP Router Alert option in the received
 *         packet, and IGMP_FALSE otherwise.
 */

u_char igmpv2_chk4_rtr_alert_opt (struct ip * pip)
{
 3245f58:	defff904 	addi	sp,sp,-28
 3245f5c:	df000615 	stw	fp,24(sp)
 3245f60:	df000604 	addi	fp,sp,24
 3245f64:	e13ffd15 	stw	r4,-12(fp)
   u_long * rtr_alert_optp;
   u_char total_optlen;
   u_char optlen;
   u_char optval;

   total_optlen = ip_hlen (pip) - sizeof (struct ip);
 3245f68:	e0bffd17 	ldw	r2,-12(fp)
 3245f6c:	10800003 	ldbu	r2,0(r2)
 3245f70:	108003cc 	andi	r2,r2,15
 3245f74:	1085883a 	add	r2,r2,r2
 3245f78:	1085883a 	add	r2,r2,r2
 3245f7c:	10bffb04 	addi	r2,r2,-20
 3245f80:	e0bffa85 	stb	r2,-22(fp)

   if (total_optlen > 0)
 3245f84:	e0bffa83 	ldbu	r2,-22(fp)
 3245f88:	1005003a 	cmpeq	r2,r2,zero
 3245f8c:	1000481e 	bne	r2,zero,32460b0 <igmpv2_chk4_rtr_alert_opt+0x158>
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
 3245f90:	e0bffd17 	ldw	r2,-12(fp)
 3245f94:	10800504 	addi	r2,r2,20
 3245f98:	e0bffc15 	stw	r2,-16(fp)
  
      while (total_optlen > 0)
 3245f9c:	00004106 	br	32460a4 <igmpv2_chk4_rtr_alert_opt+0x14c>
      {
         /* only the lowermost 5 bits are significant */    
         optval = (*optp) & IPOPT_TYPE_MASK;
 3245fa0:	e0bffc17 	ldw	r2,-16(fp)
 3245fa4:	10800003 	ldbu	r2,0(r2)
 3245fa8:	108007cc 	andi	r2,r2,31
 3245fac:	e0bffa05 	stb	r2,-24(fp)
         switch (optval)
 3245fb0:	e0bffa03 	ldbu	r2,-24(fp)
 3245fb4:	e0bfff15 	stw	r2,-4(fp)
 3245fb8:	e0ffff17 	ldw	r3,-4(fp)
 3245fbc:	18800060 	cmpeqi	r2,r3,1
 3245fc0:	10000b1e 	bne	r2,zero,3245ff0 <igmpv2_chk4_rtr_alert_opt+0x98>
 3245fc4:	e0ffff17 	ldw	r3,-4(fp)
 3245fc8:	18800520 	cmpeqi	r2,r3,20
 3245fcc:	10000b1e 	bne	r2,zero,3245ffc <igmpv2_chk4_rtr_alert_opt+0xa4>
 3245fd0:	e0ffff17 	ldw	r3,-4(fp)
 3245fd4:	1805003a 	cmpeq	r2,r3,zero
 3245fd8:	1000011e 	bne	r2,zero,3245fe0 <igmpv2_chk4_rtr_alert_opt+0x88>
 3245fdc:	00002306 	br	324606c <igmpv2_chk4_rtr_alert_opt+0x114>
         {
            case EOL_OPT:
               /* we've encountered the End of Option List option, 
                * and so setting optlen isn't necessary */
               optlen = 1;
 3245fe0:	00800044 	movi	r2,1
 3245fe4:	e0bffa45 	stb	r2,-23(fp)
               /* we're done - we couldn't locate the IP Router Alert 
                * option in this IP header */
               return IGMP_FALSE;
 3245fe8:	e03ffe15 	stw	zero,-8(fp)
 3245fec:	00003106 	br	32460b4 <igmpv2_chk4_rtr_alert_opt+0x15c>
         
            case NOOP_OPT:
               /* skip past the one byte of the No Operation option */
               optlen = 1;
 3245ff0:	00800044 	movi	r2,1
 3245ff4:	e0bffa45 	stb	r2,-23(fp)
               break;
 3245ff8:	00002106 	br	3246080 <igmpv2_chk4_rtr_alert_opt+0x128>
         
            case IP_RTR_ALERT_OPT:
               rtr_alert_optp = (u_long *) optp; 
 3245ffc:	e0bffc17 	ldw	r2,-16(fp)
 3246000:	e0bffb15 	stw	r2,-20(fp)
               if ((ntohl (*rtr_alert_optp)) == IP_RTR_ALERT_OPT_DATA)
 3246004:	e0bffb17 	ldw	r2,-20(fp)
 3246008:	10800017 	ldw	r2,0(r2)
 324600c:	1004d63a 	srli	r2,r2,24
 3246010:	10c03fcc 	andi	r3,r2,255
 3246014:	e0bffb17 	ldw	r2,-20(fp)
 3246018:	10800017 	ldw	r2,0(r2)
 324601c:	1004d23a 	srli	r2,r2,8
 3246020:	10bfc00c 	andi	r2,r2,65280
 3246024:	1886b03a 	or	r3,r3,r2
 3246028:	e0bffb17 	ldw	r2,-20(fp)
 324602c:	10800017 	ldw	r2,0(r2)
 3246030:	10bfc00c 	andi	r2,r2,65280
 3246034:	1004923a 	slli	r2,r2,8
 3246038:	1886b03a 	or	r3,r3,r2
 324603c:	e0bffb17 	ldw	r2,-20(fp)
 3246040:	10800017 	ldw	r2,0(r2)
 3246044:	10803fcc 	andi	r2,r2,255
 3246048:	1004963a 	slli	r2,r2,24
 324604c:	1886b03a 	or	r3,r3,r2
 3246050:	00a50134 	movhi	r2,37892
 3246054:	1880031e 	bne	r3,r2,3246064 <igmpv2_chk4_rtr_alert_opt+0x10c>
                  /* found the option, return success */
                  return IGMP_TRUE;
 3246058:	00800044 	movi	r2,1
 324605c:	e0bffe15 	stw	r2,-8(fp)
 3246060:	00001406 	br	32460b4 <igmpv2_chk4_rtr_alert_opt+0x15c>
               else return IGMP_FALSE;
 3246064:	e03ffe15 	stw	zero,-8(fp)
 3246068:	00001206 	br	32460b4 <igmpv2_chk4_rtr_alert_opt+0x15c>
          
            default:
               /* extract the length of the current option, and compute
                * the total length of this option */
               optlen = (*(optp + 1)) + 2;
 324606c:	e0bffc17 	ldw	r2,-16(fp)
 3246070:	10800044 	addi	r2,r2,1
 3246074:	10800003 	ldbu	r2,0(r2)
 3246078:	10800084 	addi	r2,r2,2
 324607c:	e0bffa45 	stb	r2,-23(fp)
               break;
         }
         
         /* skip past the bytes associated with the current option to 
          * point to the next option. */
         optp += optlen;
 3246080:	e0bffa43 	ldbu	r2,-23(fp)
 3246084:	1007883a 	mov	r3,r2
 3246088:	e0bffc17 	ldw	r2,-16(fp)
 324608c:	10c5883a 	add	r2,r2,r3
 3246090:	e0bffc15 	stw	r2,-16(fp)
         total_optlen -= optlen;
 3246094:	e0fffa83 	ldbu	r3,-22(fp)
 3246098:	e0bffa43 	ldbu	r2,-23(fp)
 324609c:	1885c83a 	sub	r2,r3,r2
 32460a0:	e0bffa85 	stb	r2,-22(fp)
   if (total_optlen > 0)
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
  
      while (total_optlen > 0)
 32460a4:	e0bffa83 	ldbu	r2,-22(fp)
 32460a8:	1004c03a 	cmpne	r2,r2,zero
 32460ac:	103fbc1e 	bne	r2,zero,3245fa0 <igmpv2_chk4_rtr_alert_opt+0x48>
         total_optlen -= optlen;
      } /* end WHILE */
   }

   /* didn't find IP Alert option in IP header of rcvd packet */
   return IGMP_FALSE;
 32460b0:	e03ffe15 	stw	zero,-8(fp)
 32460b4:	e0bffe17 	ldw	r2,-8(fp)
}
 32460b8:	e037883a 	mov	sp,fp
 32460bc:	df000017 	ldw	fp,0(sp)
 32460c0:	dec00104 	addi	sp,sp,4
 32460c4:	f800283a 	ret

032460c8 <IPADDR_TO_NETP>:
 * RETURNS: 
 */

void
IPADDR_TO_NETP(ip_addr addr, NET* netp)
{
 32460c8:	defffc04 	addi	sp,sp,-16
 32460cc:	df000315 	stw	fp,12(sp)
 32460d0:	df000304 	addi	fp,sp,12
 32460d4:	e13ffe15 	stw	r4,-8(fp)
 32460d8:	e17fff15 	stw	r5,-4(fp)
   u_short  idx   =  0;
 32460dc:	e03ffd0d 	sth	zero,-12(fp)
   *netp = nets[idx];
 32460e0:	e0bffd0b 	ldhu	r2,-12(fp)
 32460e4:	00c0c9b4 	movhi	r3,806
 32460e8:	18f34504 	addi	r3,r3,-13036
 32460ec:	1085883a 	add	r2,r2,r2
 32460f0:	1085883a 	add	r2,r2,r2
 32460f4:	10c5883a 	add	r2,r2,r3
 32460f8:	10c00017 	ldw	r3,0(r2)
 32460fc:	e0bfff17 	ldw	r2,-4(fp)
 3246100:	10c00015 	stw	r3,0(r2)
/*
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
 3246104:	e0bffe17 	ldw	r2,-8(fp)
 3246108:	1004c03a 	cmpne	r2,r2,zero
 324610c:	1000331e 	bne	r2,zero,32461dc <IPADDR_TO_NETP+0x114>
   {
      for (idx = 0; idx < ifNumber; idx++)
 3246110:	e03ffd0d 	sth	zero,-12(fp)
 3246114:	00001706 	br	3246174 <IPADDR_TO_NETP+0xac>
      {
         if (nets[idx]->n_mcastlist)
 3246118:	e0bffd0b 	ldhu	r2,-12(fp)
 324611c:	00c0c9b4 	movhi	r3,806
 3246120:	18f34504 	addi	r3,r3,-13036
 3246124:	1085883a 	add	r2,r2,r2
 3246128:	1085883a 	add	r2,r2,r2
 324612c:	10c5883a 	add	r2,r2,r3
 3246130:	10800017 	ldw	r2,0(r2)
 3246134:	10802b17 	ldw	r2,172(r2)
 3246138:	1005003a 	cmpeq	r2,r2,zero
 324613c:	10000a1e 	bne	r2,zero,3246168 <IPADDR_TO_NETP+0xa0>
         {
            *netp = nets[idx];
 3246140:	e0bffd0b 	ldhu	r2,-12(fp)
 3246144:	00c0c9b4 	movhi	r3,806
 3246148:	18f34504 	addi	r3,r3,-13036
 324614c:	1085883a 	add	r2,r2,r2
 3246150:	1085883a 	add	r2,r2,r2
 3246154:	10c5883a 	add	r2,r2,r3
 3246158:	10c00017 	ldw	r3,0(r2)
 324615c:	e0bfff17 	ldw	r2,-4(fp)
 3246160:	10c00015 	stw	r3,0(r2)
            break;
 3246164:	00002606 	br	3246200 <IPADDR_TO_NETP+0x138>
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
   {
      for (idx = 0; idx < ifNumber; idx++)
 3246168:	e0bffd0b 	ldhu	r2,-12(fp)
 324616c:	10800044 	addi	r2,r2,1
 3246170:	e0bffd0d 	sth	r2,-12(fp)
 3246174:	e0bffd0b 	ldhu	r2,-12(fp)
 3246178:	00c0c974 	movhi	r3,805
 324617c:	18d31d04 	addi	r3,r3,19572
 3246180:	18c00017 	ldw	r3,0(r3)
 3246184:	10ffe436 	bltu	r2,r3,3246118 <IPADDR_TO_NETP+0x50>
 3246188:	00001d06 	br	3246200 <IPADDR_TO_NETP+0x138>
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
      {
         idx++;
 324618c:	e0bffd0b 	ldhu	r2,-12(fp)
 3246190:	10800044 	addi	r2,r2,1
 3246194:	e0bffd0d 	sth	r2,-12(fp)
         if (idx >= ifNumber)
 3246198:	e0fffd0b 	ldhu	r3,-12(fp)
 324619c:	0080c974 	movhi	r2,805
 32461a0:	10931d04 	addi	r2,r2,19572
 32461a4:	10800017 	ldw	r2,0(r2)
 32461a8:	18800336 	bltu	r3,r2,32461b8 <IPADDR_TO_NETP+0xf0>
         {
            *netp = NULL;
 32461ac:	e0bfff17 	ldw	r2,-4(fp)
 32461b0:	10000015 	stw	zero,0(r2)
            break;
 32461b4:	00001206 	br	3246200 <IPADDR_TO_NETP+0x138>
         }
         else
            *netp = nets[idx];
 32461b8:	e0bffd0b 	ldhu	r2,-12(fp)
 32461bc:	00c0c9b4 	movhi	r3,806
 32461c0:	18f34504 	addi	r3,r3,-13036
 32461c4:	1085883a 	add	r2,r2,r2
 32461c8:	1085883a 	add	r2,r2,r2
 32461cc:	10c5883a 	add	r2,r2,r3
 32461d0:	10c00017 	ldw	r3,0(r2)
 32461d4:	e0bfff17 	ldw	r2,-4(fp)
 32461d8:	10c00015 	stw	r3,0(r2)
         }
      }
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
 32461dc:	e0bfff17 	ldw	r2,-4(fp)
 32461e0:	10800017 	ldw	r2,0(r2)
 32461e4:	1005003a 	cmpeq	r2,r2,zero
 32461e8:	1000051e 	bne	r2,zero,3246200 <IPADDR_TO_NETP+0x138>
 32461ec:	e0bfff17 	ldw	r2,-4(fp)
 32461f0:	10800017 	ldw	r2,0(r2)
 32461f4:	10c00a17 	ldw	r3,40(r2)
 32461f8:	e0bffe17 	ldw	r2,-8(fp)
 32461fc:	18bfe31e 	bne	r3,r2,324618c <IPADDR_TO_NETP+0xc4>
         }
         else
            *netp = nets[idx];
      }
   }
}
 3246200:	e037883a 	mov	sp,fp
 3246204:	df000017 	ldw	fp,0(sp)
 3246208:	dec00104 	addi	sp,sp,4
 324620c:	f800283a 	ret

03246210 <ip_setmoptions>:
 * RETURNS: 
 */

int
ip_setmoptions(int optname, struct socket * so, void * val)
{
 3246210:	defff104 	addi	sp,sp,-60
 3246214:	dfc00e15 	stw	ra,56(sp)
 3246218:	df000d15 	stw	fp,52(sp)
 324621c:	dc000c15 	stw	r16,48(sp)
 3246220:	df000c04 	addi	fp,sp,48
 3246224:	e13ffb15 	stw	r4,-20(fp)
 3246228:	e17ffc15 	stw	r5,-16(fp)
 324622c:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 3246230:	e03ff915 	stw	zero,-28(fp)
   u_short  i;
   struct ip_mreq *  mreq;
   struct net *   netp  =  NULL;
 3246234:	e03ffa15 	stw	zero,-24(fp)
   struct ip_moptions * imo   =  so->inp_moptions;
 3246238:	e0bffc17 	ldw	r2,-16(fp)
 324623c:	10800317 	ldw	r2,12(r2)
 3246240:	e0bff615 	stw	r2,-40(fp)
   struct ip_moptions **imop  =  &so->inp_moptions;
 3246244:	e0bffc17 	ldw	r2,-16(fp)
 3246248:	10800304 	addi	r2,r2,12
 324624c:	e0bff515 	stw	r2,-44(fp)
   ip_addr addr;


   if (imo == NULL) 
 3246250:	e0bff617 	ldw	r2,-40(fp)
 3246254:	1004c03a 	cmpne	r2,r2,zero
 3246258:	1000161e 	bne	r2,zero,32462b4 <ip_setmoptions+0xa4>
   {
   /*
    * No multicast option buffer attached to the pcb;
    * allocate one and initialize to default values.
    */
      imo = (struct ip_moptions*)IM_ALLOC(sizeof(*imo));
 324625c:	01001604 	movi	r4,88
 3246260:	322b9340 	call	322b934 <npalloc>
 3246264:	e0bff615 	stw	r2,-40(fp)

      if (imo == NULL)
 3246268:	e0bff617 	ldw	r2,-40(fp)
 324626c:	1004c03a 	cmpne	r2,r2,zero
 3246270:	1000031e 	bne	r2,zero,3246280 <ip_setmoptions+0x70>
         return (ENOBUFS);
 3246274:	00801a44 	movi	r2,105
 3246278:	e0bffe15 	stw	r2,-8(fp)
 324627c:	00015906 	br	32467e4 <ip_setmoptions+0x5d4>
      *imop = imo;
 3246280:	e0fff517 	ldw	r3,-44(fp)
 3246284:	e0bff617 	ldw	r2,-40(fp)
 3246288:	18800015 	stw	r2,0(r3)
      imo->imo_multicast_netp = NULL;
 324628c:	e0bff617 	ldw	r2,-40(fp)
 3246290:	10000015 	stw	zero,0(r2)
      imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
 3246294:	e0fff617 	ldw	r3,-40(fp)
 3246298:	00800044 	movi	r2,1
 324629c:	18800105 	stb	r2,4(r3)
      imo->imo_multicast_loop = IP_DEFAULT_MULTICAST_LOOP;
 32462a0:	e0fff617 	ldw	r3,-40(fp)
 32462a4:	00800044 	movi	r2,1
 32462a8:	18800145 	stb	r2,5(r3)
      imo->imo_num_memberships = 0;
 32462ac:	e0bff617 	ldw	r2,-40(fp)
 32462b0:	1000018d 	sth	zero,6(r2)
   }

   switch (optname) 
 32462b4:	e0bffb17 	ldw	r2,-20(fp)
 32462b8:	10bffdc4 	addi	r2,r2,-9
 32462bc:	e0bfff15 	stw	r2,-4(fp)
 32462c0:	e0ffff17 	ldw	r3,-4(fp)
 32462c4:	18800168 	cmpgeui	r2,r3,5
 32462c8:	10012a1e 	bne	r2,zero,3246774 <ip_setmoptions+0x564>
 32462cc:	e13fff17 	ldw	r4,-4(fp)
 32462d0:	e13fff17 	ldw	r4,-4(fp)
 32462d4:	2105883a 	add	r2,r4,r4
 32462d8:	1087883a 	add	r3,r2,r2
 32462dc:	0080c934 	movhi	r2,804
 32462e0:	1098bc04 	addi	r2,r2,25328
 32462e4:	1885883a 	add	r2,r3,r2
 32462e8:	10800017 	ldw	r2,0(r2)
 32462ec:	1000683a 	jmp	r2
 32462f0:	03246304 	movi	r12,-28276
 32462f4:	03246378 	rdprs	r12,zero,-28275
 32462f8:	0324638c 	andi	r12,zero,37262
 32462fc:	032463c0 	call	32463c <OSCtxSw_SWITCH_PC+0x3245fc>
 3246300:	03246590 	cmplti	r12,zero,-28266

   case IP_MULTICAST_IF:
      /*
       * Select the interface for outgoing multicast packets.
       */
      addr = *(ip_addr *)val;
 3246304:	e0bffd17 	ldw	r2,-12(fp)
 3246308:	10800017 	ldw	r2,0(r2)
 324630c:	e0bff415 	stw	r2,-48(fp)
         /*
          * AADDR is used to remove a previous selection.
          * When no interface is selected, a default one is
          * chosen every time a multicast packet is sent.
          */
      if (addr == AADDR) 
 3246310:	e0bff417 	ldw	r2,-48(fp)
 3246314:	1004c03a 	cmpne	r2,r2,zero
 3246318:	1000031e 	bne	r2,zero,3246328 <ip_setmoptions+0x118>
      {
         imo->imo_multicast_netp = NULL;
 324631c:	e0bff617 	ldw	r2,-40(fp)
 3246320:	10000015 	stw	zero,0(r2)
         break;
 3246324:	00011506 	br	324677c <ip_setmoptions+0x56c>
         /*
          * The selected interface is identified by its local
          * IP address.  Find the interface and confirm that
          * it supports multicasting.
          */
      IPADDR_TO_NETP(addr, &netp);
 3246328:	e17ffa04 	addi	r5,fp,-24
 324632c:	e13ff417 	ldw	r4,-48(fp)
 3246330:	32460c80 	call	32460c8 <IPADDR_TO_NETP>
      if ((netp == NULL) || (netp->n_mcastlist) == NULL) 
 3246334:	e0bffa17 	ldw	r2,-24(fp)
 3246338:	1005003a 	cmpeq	r2,r2,zero
 324633c:	1000041e 	bne	r2,zero,3246350 <ip_setmoptions+0x140>
 3246340:	e0bffa17 	ldw	r2,-24(fp)
 3246344:	10802b17 	ldw	r2,172(r2)
 3246348:	1004c03a 	cmpne	r2,r2,zero
 324634c:	1000031e 	bne	r2,zero,324635c <ip_setmoptions+0x14c>
      {
         error = EADDRNOTAVAIL;
 3246350:	00801f44 	movi	r2,125
 3246354:	e0bff915 	stw	r2,-28(fp)
         break;
 3246358:	00010806 	br	324677c <ip_setmoptions+0x56c>
      }
      if (addr != AADDR) 
 324635c:	e0bff417 	ldw	r2,-48(fp)
 3246360:	1005003a 	cmpeq	r2,r2,zero
 3246364:	1001051e 	bne	r2,zero,324677c <ip_setmoptions+0x56c>
         imo->imo_multicast_netp = netp;
 3246368:	e0fffa17 	ldw	r3,-24(fp)
 324636c:	e0bff617 	ldw	r2,-40(fp)
 3246370:	10c00015 	stw	r3,0(r2)
      break;
 3246374:	00010106 	br	324677c <ip_setmoptions+0x56c>

   case IP_MULTICAST_TTL:
      /*
       * Set the IP time-to-live for outgoing multicast packets.
       */
      imo->imo_multicast_ttl = *(u_char *)val;
 3246378:	e0bffd17 	ldw	r2,-12(fp)
 324637c:	10c00003 	ldbu	r3,0(r2)
 3246380:	e0bff617 	ldw	r2,-40(fp)
 3246384:	10c00105 	stb	r3,4(r2)
      break;
 3246388:	0000fc06 	br	324677c <ip_setmoptions+0x56c>
   case IP_MULTICAST_LOOP:
      /*
       * Set the loopback flag for outgoing multicast packets.
       * Must be zero or one.
       */
      if (*(u_char *)val > 1) 
 324638c:	e0bffd17 	ldw	r2,-12(fp)
 3246390:	10800003 	ldbu	r2,0(r2)
 3246394:	10803fcc 	andi	r2,r2,255
 3246398:	108000b0 	cmpltui	r2,r2,2
 324639c:	1000031e 	bne	r2,zero,32463ac <ip_setmoptions+0x19c>
      {
         error = EINVAL;
 32463a0:	00800584 	movi	r2,22
 32463a4:	e0bff915 	stw	r2,-28(fp)
         break;
 32463a8:	0000f406 	br	324677c <ip_setmoptions+0x56c>
      }
      imo->imo_multicast_loop = *(u_char *)(val);
 32463ac:	e0bffd17 	ldw	r2,-12(fp)
 32463b0:	10c00003 	ldbu	r3,0(r2)
 32463b4:	e0bff617 	ldw	r2,-40(fp)
 32463b8:	10c00145 	stb	r3,5(r2)
      break;
 32463bc:	0000ef06 	br	324677c <ip_setmoptions+0x56c>
   case IP_ADD_MEMBERSHIP:
      /*
       * Add a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 32463c0:	e0bffd17 	ldw	r2,-12(fp)
 32463c4:	e0bff715 	stw	r2,-36(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 32463c8:	e0bff717 	ldw	r2,-36(fp)
 32463cc:	10800017 	ldw	r2,0(r2)
 32463d0:	1004d63a 	srli	r2,r2,24
 32463d4:	10c03fcc 	andi	r3,r2,255
 32463d8:	e0bff717 	ldw	r2,-36(fp)
 32463dc:	10800017 	ldw	r2,0(r2)
 32463e0:	1004d23a 	srli	r2,r2,8
 32463e4:	10bfc00c 	andi	r2,r2,65280
 32463e8:	1886b03a 	or	r3,r3,r2
 32463ec:	e0bff717 	ldw	r2,-36(fp)
 32463f0:	10800017 	ldw	r2,0(r2)
 32463f4:	10bfc00c 	andi	r2,r2,65280
 32463f8:	1004923a 	slli	r2,r2,8
 32463fc:	1886b03a 	or	r3,r3,r2
 3246400:	e0bff717 	ldw	r2,-36(fp)
 3246404:	10800017 	ldw	r2,0(r2)
 3246408:	10803fcc 	andi	r2,r2,255
 324640c:	1004963a 	slli	r2,r2,24
 3246410:	1884b03a 	or	r2,r3,r2
 3246414:	10fc002c 	andhi	r3,r2,61440
 3246418:	00b80034 	movhi	r2,57344
 324641c:	18800326 	beq	r3,r2,324642c <ip_setmoptions+0x21c>
      {
         error = EINVAL;
 3246420:	00800584 	movi	r2,22
 3246424:	e0bff915 	stw	r2,-28(fp)
         break;
 3246428:	0000d406 	br	324677c <ip_setmoptions+0x56c>
       * If no interface address was provided, use the interface of
       * the route to the given multicast address.
       * For the Iniche stack implementation, look for a default
       * interface that supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 324642c:	e0bff717 	ldw	r2,-36(fp)
 3246430:	11000117 	ldw	r4,4(r2)
 3246434:	e17ffa04 	addi	r5,fp,-24
 3246438:	32460c80 	call	32460c8 <IPADDR_TO_NETP>
      /*
       * See if we found an interface, and confirm that it
       * supports multicast.
       */
      if (netp == NULL || (netp->n_mcastlist) == NULL) 
 324643c:	e0bffa17 	ldw	r2,-24(fp)
 3246440:	1005003a 	cmpeq	r2,r2,zero
 3246444:	1000041e 	bne	r2,zero,3246458 <ip_setmoptions+0x248>
 3246448:	e0bffa17 	ldw	r2,-24(fp)
 324644c:	10802b17 	ldw	r2,172(r2)
 3246450:	1004c03a 	cmpne	r2,r2,zero
 3246454:	1000031e 	bne	r2,zero,3246464 <ip_setmoptions+0x254>
      {
         error = EADDRNOTAVAIL;
 3246458:	00801f44 	movi	r2,125
 324645c:	e0bff915 	stw	r2,-28(fp)
         break;
 3246460:	0000c606 	br	324677c <ip_setmoptions+0x56c>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 3246464:	e03ff80d 	sth	zero,-32(fp)
 3246468:	00001806 	br	32464cc <ip_setmoptions+0x2bc>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 324646c:	e0bff80b 	ldhu	r2,-32(fp)
 3246470:	e0fff617 	ldw	r3,-40(fp)
 3246474:	1085883a 	add	r2,r2,r2
 3246478:	1085883a 	add	r2,r2,r2
 324647c:	10c5883a 	add	r2,r2,r3
 3246480:	10800204 	addi	r2,r2,8
 3246484:	10800017 	ldw	r2,0(r2)
 3246488:	10c00117 	ldw	r3,4(r2)
 324648c:	e0bffa17 	ldw	r2,-24(fp)
 3246490:	18800b1e 	bne	r3,r2,32464c0 <ip_setmoptions+0x2b0>
 3246494:	e0bff80b 	ldhu	r2,-32(fp)
 3246498:	e0fff617 	ldw	r3,-40(fp)
 324649c:	1085883a 	add	r2,r2,r2
 32464a0:	1085883a 	add	r2,r2,r2
 32464a4:	10c5883a 	add	r2,r2,r3
 32464a8:	10800204 	addi	r2,r2,8
 32464ac:	10800017 	ldw	r2,0(r2)
 32464b0:	10c00017 	ldw	r3,0(r2)
 32464b4:	e0bff717 	ldw	r2,-36(fp)
 32464b8:	10800017 	ldw	r2,0(r2)
 32464bc:	18800826 	beq	r3,r2,32464e0 <ip_setmoptions+0x2d0>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 32464c0:	e0bff80b 	ldhu	r2,-32(fp)
 32464c4:	10800044 	addi	r2,r2,1
 32464c8:	e0bff80d 	sth	r2,-32(fp)
 32464cc:	e0bff617 	ldw	r2,-40(fp)
 32464d0:	1080018b 	ldhu	r2,6(r2)
 32464d4:	10ffffcc 	andi	r3,r2,65535
 32464d8:	e0bff80b 	ldhu	r2,-32(fp)
 32464dc:	10ffe336 	bltu	r2,r3,324646c <ip_setmoptions+0x25c>
             == mreq->imr_multiaddr)
         {
            break;
         }
      }
      if (i < imo->imo_num_memberships) 
 32464e0:	e0bff617 	ldw	r2,-40(fp)
 32464e4:	1080018b 	ldhu	r2,6(r2)
 32464e8:	10ffffcc 	andi	r3,r2,65535
 32464ec:	e0bff80b 	ldhu	r2,-32(fp)
 32464f0:	10c0032e 	bgeu	r2,r3,3246500 <ip_setmoptions+0x2f0>
      {
         error = EADDRINUSE;
 32464f4:	00801c04 	movi	r2,112
 32464f8:	e0bff915 	stw	r2,-28(fp)
         break;
 32464fc:	00009f06 	br	324677c <ip_setmoptions+0x56c>
      }
      if (i == IP_MAX_MEMBERSHIPS) 
 3246500:	e0bff80b 	ldhu	r2,-32(fp)
 3246504:	10800518 	cmpnei	r2,r2,20
 3246508:	1000031e 	bne	r2,zero,3246518 <ip_setmoptions+0x308>
      {
         error = ETOOMANYREFS;
 324650c:	00802044 	movi	r2,129
 3246510:	e0bff915 	stw	r2,-28(fp)
         break;
 3246514:	00009906 	br	324677c <ip_setmoptions+0x56c>
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 3246518:	e43ff80b 	ldhu	r16,-32(fp)
 324651c:	e13ff717 	ldw	r4,-36(fp)
 3246520:	e17ffa17 	ldw	r5,-24(fp)
 3246524:	01800104 	movi	r6,4
 3246528:	32437d00 	call	32437d0 <in_addmulti>
 324652c:	1009883a 	mov	r4,r2
 3246530:	e0fff617 	ldw	r3,-40(fp)
 3246534:	8405883a 	add	r2,r16,r16
 3246538:	1085883a 	add	r2,r2,r2
 324653c:	10c5883a 	add	r2,r2,r3
 3246540:	10800204 	addi	r2,r2,8
 3246544:	11000015 	stw	r4,0(r2)
 3246548:	e0fff617 	ldw	r3,-40(fp)
 324654c:	8405883a 	add	r2,r16,r16
 3246550:	1085883a 	add	r2,r2,r2
 3246554:	10c5883a 	add	r2,r2,r3
 3246558:	10800204 	addi	r2,r2,8
 324655c:	10800017 	ldw	r2,0(r2)
 3246560:	1004c03a 	cmpne	r2,r2,zero
 3246564:	1000031e 	bne	r2,zero,3246574 <ip_setmoptions+0x364>
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
      {
         error = ENOBUFS;
 3246568:	00801a44 	movi	r2,105
 324656c:	e0bff915 	stw	r2,-28(fp)
         break;
 3246570:	00008206 	br	324677c <ip_setmoptions+0x56c>
      }
      ++imo->imo_num_memberships;
 3246574:	e0bff617 	ldw	r2,-40(fp)
 3246578:	1080018b 	ldhu	r2,6(r2)
 324657c:	10800044 	addi	r2,r2,1
 3246580:	1007883a 	mov	r3,r2
 3246584:	e0bff617 	ldw	r2,-40(fp)
 3246588:	10c0018d 	sth	r3,6(r2)
      break;
 324658c:	00007b06 	br	324677c <ip_setmoptions+0x56c>
   case IP_DROP_MEMBERSHIP:
      /*
       * Drop a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 3246590:	e0bffd17 	ldw	r2,-12(fp)
 3246594:	e0bff715 	stw	r2,-36(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 3246598:	e0bff717 	ldw	r2,-36(fp)
 324659c:	10800017 	ldw	r2,0(r2)
 32465a0:	1004d63a 	srli	r2,r2,24
 32465a4:	10c03fcc 	andi	r3,r2,255
 32465a8:	e0bff717 	ldw	r2,-36(fp)
 32465ac:	10800017 	ldw	r2,0(r2)
 32465b0:	1004d23a 	srli	r2,r2,8
 32465b4:	10bfc00c 	andi	r2,r2,65280
 32465b8:	1886b03a 	or	r3,r3,r2
 32465bc:	e0bff717 	ldw	r2,-36(fp)
 32465c0:	10800017 	ldw	r2,0(r2)
 32465c4:	10bfc00c 	andi	r2,r2,65280
 32465c8:	1004923a 	slli	r2,r2,8
 32465cc:	1886b03a 	or	r3,r3,r2
 32465d0:	e0bff717 	ldw	r2,-36(fp)
 32465d4:	10800017 	ldw	r2,0(r2)
 32465d8:	10803fcc 	andi	r2,r2,255
 32465dc:	1004963a 	slli	r2,r2,24
 32465e0:	1884b03a 	or	r2,r3,r2
 32465e4:	10fc002c 	andhi	r3,r2,61440
 32465e8:	00b80034 	movhi	r2,57344
 32465ec:	18800326 	beq	r3,r2,32465fc <ip_setmoptions+0x3ec>
      {
         error = EINVAL;
 32465f0:	00800584 	movi	r2,22
 32465f4:	e0bff915 	stw	r2,-28(fp)
         break;
 32465f8:	00006006 	br	324677c <ip_setmoptions+0x56c>
       * If an interface address was specified, get a pointer
       * to its ifnet structure. If an interface address was not
       * specified, get a pointer to the first interface that
       * supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 32465fc:	e0bff717 	ldw	r2,-36(fp)
 3246600:	11000117 	ldw	r4,4(r2)
 3246604:	e17ffa04 	addi	r5,fp,-24
 3246608:	32460c80 	call	32460c8 <IPADDR_TO_NETP>
      if (netp == NULL) 
 324660c:	e0bffa17 	ldw	r2,-24(fp)
 3246610:	1004c03a 	cmpne	r2,r2,zero
 3246614:	1000031e 	bne	r2,zero,3246624 <ip_setmoptions+0x414>
      {
         error = EADDRNOTAVAIL;
 3246618:	00801f44 	movi	r2,125
 324661c:	e0bff915 	stw	r2,-28(fp)
         break;
 3246620:	00005606 	br	324677c <ip_setmoptions+0x56c>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 3246624:	e03ff80d 	sth	zero,-32(fp)
 3246628:	00001b06 	br	3246698 <ip_setmoptions+0x488>
      {
         if ((netp == NULL ||
 324662c:	e0bffa17 	ldw	r2,-24(fp)
 3246630:	1005003a 	cmpeq	r2,r2,zero
 3246634:	10000a1e 	bne	r2,zero,3246660 <ip_setmoptions+0x450>
 3246638:	e0bff80b 	ldhu	r2,-32(fp)
 324663c:	e0fff617 	ldw	r3,-40(fp)
 3246640:	1085883a 	add	r2,r2,r2
 3246644:	1085883a 	add	r2,r2,r2
 3246648:	10c5883a 	add	r2,r2,r3
 324664c:	10800204 	addi	r2,r2,8
 3246650:	10800017 	ldw	r2,0(r2)
 3246654:	10c00117 	ldw	r3,4(r2)
 3246658:	e0bffa17 	ldw	r2,-24(fp)
 324665c:	18800b1e 	bne	r3,r2,324668c <ip_setmoptions+0x47c>
 3246660:	e0bff80b 	ldhu	r2,-32(fp)
 3246664:	e0fff617 	ldw	r3,-40(fp)
 3246668:	1085883a 	add	r2,r2,r2
 324666c:	1085883a 	add	r2,r2,r2
 3246670:	10c5883a 	add	r2,r2,r3
 3246674:	10800204 	addi	r2,r2,8
 3246678:	10800017 	ldw	r2,0(r2)
 324667c:	10c00017 	ldw	r3,0(r2)
 3246680:	e0bff717 	ldw	r2,-36(fp)
 3246684:	10800017 	ldw	r2,0(r2)
 3246688:	18800826 	beq	r3,r2,32466ac <ip_setmoptions+0x49c>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 324668c:	e0bff80b 	ldhu	r2,-32(fp)
 3246690:	10800044 	addi	r2,r2,1
 3246694:	e0bff80d 	sth	r2,-32(fp)
 3246698:	e0bff617 	ldw	r2,-40(fp)
 324669c:	1080018b 	ldhu	r2,6(r2)
 32466a0:	10ffffcc 	andi	r3,r2,65535
 32466a4:	e0bff80b 	ldhu	r2,-32(fp)
 32466a8:	10ffe036 	bltu	r2,r3,324662c <ip_setmoptions+0x41c>
             mreq->imr_multiaddr)
         {
            break;
         }
      }
      if (i == imo->imo_num_memberships) 
 32466ac:	e0bff617 	ldw	r2,-40(fp)
 32466b0:	1080018b 	ldhu	r2,6(r2)
 32466b4:	10ffffcc 	andi	r3,r2,65535
 32466b8:	e0bff80b 	ldhu	r2,-32(fp)
 32466bc:	1880031e 	bne	r3,r2,32466cc <ip_setmoptions+0x4bc>
      {
         error = EADDRNOTAVAIL;
 32466c0:	00801f44 	movi	r2,125
 32466c4:	e0bff915 	stw	r2,-28(fp)
         break;
 32466c8:	00002c06 	br	324677c <ip_setmoptions+0x56c>
      }
      /*
       * Give up the multicast address record to which the
       * membership points.
       */
      in_delmulti(imo->imo_membership[i]);
 32466cc:	e0bff80b 	ldhu	r2,-32(fp)
 32466d0:	e0fff617 	ldw	r3,-40(fp)
 32466d4:	1085883a 	add	r2,r2,r2
 32466d8:	1085883a 	add	r2,r2,r2
 32466dc:	10c5883a 	add	r2,r2,r3
 32466e0:	10800204 	addi	r2,r2,8
 32466e4:	11000017 	ldw	r4,0(r2)
 32466e8:	32439380 	call	3243938 <in_delmulti>
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 32466ec:	e0bff80b 	ldhu	r2,-32(fp)
 32466f0:	10800044 	addi	r2,r2,1
 32466f4:	e0bff80d 	sth	r2,-32(fp)
 32466f8:	00001206 	br	3246744 <ip_setmoptions+0x534>
         imo->imo_membership[i-1] = imo->imo_membership[i];
 32466fc:	e0bff80b 	ldhu	r2,-32(fp)
 3246700:	113fffc4 	addi	r4,r2,-1
 3246704:	e0bff80b 	ldhu	r2,-32(fp)
 3246708:	e0fff617 	ldw	r3,-40(fp)
 324670c:	1085883a 	add	r2,r2,r2
 3246710:	1085883a 	add	r2,r2,r2
 3246714:	10c5883a 	add	r2,r2,r3
 3246718:	10800204 	addi	r2,r2,8
 324671c:	11400017 	ldw	r5,0(r2)
 3246720:	e0fff617 	ldw	r3,-40(fp)
 3246724:	2105883a 	add	r2,r4,r4
 3246728:	1085883a 	add	r2,r2,r2
 324672c:	10c5883a 	add	r2,r2,r3
 3246730:	10800204 	addi	r2,r2,8
 3246734:	11400015 	stw	r5,0(r2)
       */
      in_delmulti(imo->imo_membership[i]);
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 3246738:	e0bff80b 	ldhu	r2,-32(fp)
 324673c:	10800044 	addi	r2,r2,1
 3246740:	e0bff80d 	sth	r2,-32(fp)
 3246744:	e0bff617 	ldw	r2,-40(fp)
 3246748:	1080018b 	ldhu	r2,6(r2)
 324674c:	10ffffcc 	andi	r3,r2,65535
 3246750:	e0bff80b 	ldhu	r2,-32(fp)
 3246754:	10ffe936 	bltu	r2,r3,32466fc <ip_setmoptions+0x4ec>
         imo->imo_membership[i-1] = imo->imo_membership[i];
      --imo->imo_num_memberships;
 3246758:	e0bff617 	ldw	r2,-40(fp)
 324675c:	1080018b 	ldhu	r2,6(r2)
 3246760:	10bfffc4 	addi	r2,r2,-1
 3246764:	1007883a 	mov	r3,r2
 3246768:	e0bff617 	ldw	r2,-40(fp)
 324676c:	10c0018d 	sth	r3,6(r2)
      break;
 3246770:	00000206 	br	324677c <ip_setmoptions+0x56c>

      default:
      error = EOPNOTSUPP;
 3246774:	008017c4 	movi	r2,95
 3246778:	e0bff915 	stw	r2,-28(fp)
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 324677c:	e0bff617 	ldw	r2,-40(fp)
 3246780:	10800017 	ldw	r2,0(r2)
 3246784:	1004c03a 	cmpne	r2,r2,zero
 3246788:	1000141e 	bne	r2,zero,32467dc <ip_setmoptions+0x5cc>
 324678c:	e0bff617 	ldw	r2,-40(fp)
 3246790:	10800103 	ldbu	r2,4(r2)
 3246794:	10803fcc 	andi	r2,r2,255
 3246798:	10800058 	cmpnei	r2,r2,1
 324679c:	10000f1e 	bne	r2,zero,32467dc <ip_setmoptions+0x5cc>
 32467a0:	e0bff617 	ldw	r2,-40(fp)
 32467a4:	10800143 	ldbu	r2,5(r2)
 32467a8:	10803fcc 	andi	r2,r2,255
 32467ac:	10800058 	cmpnei	r2,r2,1
 32467b0:	10000a1e 	bne	r2,zero,32467dc <ip_setmoptions+0x5cc>
 32467b4:	e0bff617 	ldw	r2,-40(fp)
 32467b8:	1080018b 	ldhu	r2,6(r2)
 32467bc:	10bfffcc 	andi	r2,r2,65535
 32467c0:	1004c03a 	cmpne	r2,r2,zero
 32467c4:	1000051e 	bne	r2,zero,32467dc <ip_setmoptions+0x5cc>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
       imo->imo_num_memberships == 0) 
   {
      IM_FREE(*imop);
 32467c8:	e0bff517 	ldw	r2,-44(fp)
 32467cc:	11000017 	ldw	r4,0(r2)
 32467d0:	322ba280 	call	322ba28 <npfree>
      *imop = NULL;
 32467d4:	e0bff517 	ldw	r2,-44(fp)
 32467d8:	10000015 	stw	zero,0(r2)
   }
   return (error);
 32467dc:	e0bff917 	ldw	r2,-28(fp)
 32467e0:	e0bffe15 	stw	r2,-8(fp)
 32467e4:	e0bffe17 	ldw	r2,-8(fp)
}
 32467e8:	e037883a 	mov	sp,fp
 32467ec:	dfc00217 	ldw	ra,8(sp)
 32467f0:	df000117 	ldw	fp,4(sp)
 32467f4:	dc000017 	ldw	r16,0(sp)
 32467f8:	dec00304 	addi	sp,sp,12
 32467fc:	f800283a 	ret

03246800 <ip_getmoptions>:
 * RETURNS: 
 */

int
ip_getmoptions(int optname, struct socket * so, void * val)
{
 3246800:	defff604 	addi	sp,sp,-40
 3246804:	df000915 	stw	fp,36(sp)
 3246808:	df000904 	addi	fp,sp,36
 324680c:	e13ffb15 	stw	r4,-20(fp)
 3246810:	e17ffc15 	stw	r5,-16(fp)
 3246814:	e1bffd15 	stw	r6,-12(fp)
   u_char * ttl;
   u_char * loop;
   ip_addr *addr;
   struct ip_moptions*  imo   =  so->inp_moptions;
 3246818:	e0bffc17 	ldw	r2,-16(fp)
 324681c:	10800317 	ldw	r2,12(r2)
 3246820:	e0bff715 	stw	r2,-36(fp)
   /* The following code will be commented out for Iniche stack.
    * Don't allocate a buffer here.
    *
    *        *mp = m_get(M_WAIT, MT_SOOPTS);
    */
   switch (optname) 
 3246824:	e0bffb17 	ldw	r2,-20(fp)
 3246828:	e0bfff15 	stw	r2,-4(fp)
 324682c:	e0ffff17 	ldw	r3,-4(fp)
 3246830:	18800260 	cmpeqi	r2,r3,9
 3246834:	10000a1e 	bne	r2,zero,3246860 <ip_getmoptions+0x60>
 3246838:	e0ffff17 	ldw	r3,-4(fp)
 324683c:	18800250 	cmplti	r2,r3,9
 3246840:	1000381e 	bne	r2,zero,3246924 <ip_getmoptions+0x124>
 3246844:	e0ffff17 	ldw	r3,-4(fp)
 3246848:	188002a0 	cmpeqi	r2,r3,10
 324684c:	1000171e 	bne	r2,zero,32468ac <ip_getmoptions+0xac>
 3246850:	e0ffff17 	ldw	r3,-4(fp)
 3246854:	188002e0 	cmpeqi	r2,r3,11
 3246858:	1000231e 	bne	r2,zero,32468e8 <ip_getmoptions+0xe8>
 324685c:	00003106 	br	3246924 <ip_getmoptions+0x124>
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
 3246860:	e0bffd17 	ldw	r2,-12(fp)
 3246864:	e0bff815 	stw	r2,-32(fp)
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 3246868:	e0bff717 	ldw	r2,-36(fp)
 324686c:	1005003a 	cmpeq	r2,r2,zero
 3246870:	1000041e 	bne	r2,zero,3246884 <ip_getmoptions+0x84>
 3246874:	e0bff717 	ldw	r2,-36(fp)
 3246878:	10800017 	ldw	r2,0(r2)
 324687c:	1004c03a 	cmpne	r2,r2,zero
 3246880:	1000031e 	bne	r2,zero,3246890 <ip_getmoptions+0x90>
         *addr = AADDR;
 3246884:	e0bff817 	ldw	r2,-32(fp)
 3246888:	10000015 	stw	zero,0(r2)
   switch (optname) 
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 324688c:	00000506 	br	32468a4 <ip_getmoptions+0xa4>
         *addr = AADDR;
      else
         *addr = imo->imo_multicast_netp->n_ipaddr;
 3246890:	e0bff717 	ldw	r2,-36(fp)
 3246894:	10800017 	ldw	r2,0(r2)
 3246898:	10c00a17 	ldw	r3,40(r2)
 324689c:	e0bff817 	ldw	r2,-32(fp)
 32468a0:	10c00015 	stw	r3,0(r2)
      return (0);
 32468a4:	e03ffe15 	stw	zero,-8(fp)
 32468a8:	00002006 	br	324692c <ip_getmoptions+0x12c>

   case IP_MULTICAST_TTL:
      ttl = (u_char *)val;
 32468ac:	e0bffd17 	ldw	r2,-12(fp)
 32468b0:	e0bffa15 	stw	r2,-24(fp)
      if (imo == NULL)
 32468b4:	e0bff717 	ldw	r2,-36(fp)
 32468b8:	1004c03a 	cmpne	r2,r2,zero
 32468bc:	1000041e 	bne	r2,zero,32468d0 <ip_getmoptions+0xd0>
         *ttl = IP_DEFAULT_MULTICAST_TTL;
 32468c0:	e0fffa17 	ldw	r3,-24(fp)
 32468c4:	00800044 	movi	r2,1
 32468c8:	18800005 	stb	r2,0(r3)
 32468cc:	00000406 	br	32468e0 <ip_getmoptions+0xe0>
      else
         *ttl = imo->imo_multicast_ttl;
 32468d0:	e0bff717 	ldw	r2,-36(fp)
 32468d4:	10c00103 	ldbu	r3,4(r2)
 32468d8:	e0bffa17 	ldw	r2,-24(fp)
 32468dc:	10c00005 	stb	r3,0(r2)
      return (0);
 32468e0:	e03ffe15 	stw	zero,-8(fp)
 32468e4:	00001106 	br	324692c <ip_getmoptions+0x12c>

   case IP_MULTICAST_LOOP:
      loop = (u_char *)val;
 32468e8:	e0bffd17 	ldw	r2,-12(fp)
 32468ec:	e0bff915 	stw	r2,-28(fp)
      if (imo == NULL)
 32468f0:	e0bff717 	ldw	r2,-36(fp)
 32468f4:	1004c03a 	cmpne	r2,r2,zero
 32468f8:	1000041e 	bne	r2,zero,324690c <ip_getmoptions+0x10c>
         *loop = IP_DEFAULT_MULTICAST_LOOP;
 32468fc:	e0fff917 	ldw	r3,-28(fp)
 3246900:	00800044 	movi	r2,1
 3246904:	18800005 	stb	r2,0(r3)
 3246908:	00000406 	br	324691c <ip_getmoptions+0x11c>
      else
         *loop = imo->imo_multicast_loop;
 324690c:	e0bff717 	ldw	r2,-36(fp)
 3246910:	10c00143 	ldbu	r3,5(r2)
 3246914:	e0bff917 	ldw	r2,-28(fp)
 3246918:	10c00005 	stb	r3,0(r2)
      return (0);
 324691c:	e03ffe15 	stw	zero,-8(fp)
 3246920:	00000206 	br	324692c <ip_getmoptions+0x12c>

      default:
      return (EOPNOTSUPP);
 3246924:	008017c4 	movi	r2,95
 3246928:	e0bffe15 	stw	r2,-8(fp)
 324692c:	e0bffe17 	ldw	r2,-8(fp)
   }
}
 3246930:	e037883a 	mov	sp,fp
 3246934:	df000017 	ldw	fp,0(sp)
 3246938:	dec00104 	addi	sp,sp,4
 324693c:	f800283a 	ret

03246940 <ip_freemoptions>:
 * RETURNS: 
 */

void
ip_freemoptions(struct ip_moptions * imo)
{
 3246940:	defffc04 	addi	sp,sp,-16
 3246944:	dfc00315 	stw	ra,12(sp)
 3246948:	df000215 	stw	fp,8(sp)
 324694c:	df000204 	addi	fp,sp,8
 3246950:	e13fff15 	stw	r4,-4(fp)
   u_short  i;

   if (imo != NULL) 
 3246954:	e0bfff17 	ldw	r2,-4(fp)
 3246958:	1005003a 	cmpeq	r2,r2,zero
 324695c:	1000141e 	bne	r2,zero,32469b0 <ip_freemoptions+0x70>
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 3246960:	e03ffe0d 	sth	zero,-8(fp)
 3246964:	00000b06 	br	3246994 <ip_freemoptions+0x54>
         in_delmulti(imo->imo_membership[i]);
 3246968:	e0bffe0b 	ldhu	r2,-8(fp)
 324696c:	e0ffff17 	ldw	r3,-4(fp)
 3246970:	1085883a 	add	r2,r2,r2
 3246974:	1085883a 	add	r2,r2,r2
 3246978:	10c5883a 	add	r2,r2,r3
 324697c:	10800204 	addi	r2,r2,8
 3246980:	11000017 	ldw	r4,0(r2)
 3246984:	32439380 	call	3243938 <in_delmulti>
{
   u_short  i;

   if (imo != NULL) 
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 3246988:	e0bffe0b 	ldhu	r2,-8(fp)
 324698c:	10800044 	addi	r2,r2,1
 3246990:	e0bffe0d 	sth	r2,-8(fp)
 3246994:	e0bfff17 	ldw	r2,-4(fp)
 3246998:	1080018b 	ldhu	r2,6(r2)
 324699c:	10ffffcc 	andi	r3,r2,65535
 32469a0:	e0bffe0b 	ldhu	r2,-8(fp)
 32469a4:	10fff036 	bltu	r2,r3,3246968 <ip_freemoptions+0x28>
         in_delmulti(imo->imo_membership[i]);
      npfree(imo);
 32469a8:	e13fff17 	ldw	r4,-4(fp)
 32469ac:	322ba280 	call	322ba28 <npfree>
   }
}
 32469b0:	e037883a 	mov	sp,fp
 32469b4:	dfc00117 	ldw	ra,4(sp)
 32469b8:	df000017 	ldw	fp,0(sp)
 32469bc:	dec00204 	addi	sp,sp,8
 32469c0:	f800283a 	ret

032469c4 <u_mctest_init>:
 *
 * RETURNS: 
 */

void u_mctest_init()
{
 32469c4:	defffe04 	addi	sp,sp,-8
 32469c8:	dfc00115 	stw	ra,4(sp)
 32469cc:	df000015 	stw	fp,0(sp)
 32469d0:	d839883a 	mov	fp,sp
   printf("mctest init called\n");
 32469d4:	0100c974 	movhi	r4,805
 32469d8:	21008b04 	addi	r4,r4,556
 32469dc:	32071080 	call	3207108 <puts>
// altera changes end (cadler@altera.com)
   install_menu(u_mctest_menu);
// altera changes begin (cadler@altera.com)
#endif //IN_MENUS
// altera changes end (cadler@altera.com)
}
 32469e0:	e037883a 	mov	sp,fp
 32469e4:	dfc00117 	ldw	ra,4(sp)
 32469e8:	df000017 	ldw	fp,0(sp)
 32469ec:	dec00204 	addi	sp,sp,8
 32469f0:	f800283a 	ret

032469f4 <u_mctest_run>:
 *
 * RETURNS: 
 */

int u_mctest_run(void * pio)
{
 32469f4:	defede04 	addi	sp,sp,-1160
 32469f8:	dfc12115 	stw	ra,1156(sp)
 32469fc:	df012015 	stw	fp,1152(sp)
 3246a00:	df012004 	addi	fp,sp,1152
 3246a04:	e13fff15 	stw	r4,-4(fp)
    struct sockaddr_in   stLocal, stTo, stFrom;
    char  achIn[BUFSIZE];
    char  achOut[] = "Message number:              ";
 3246a08:	00c0c974 	movhi	r3,805
 3246a0c:	18c13704 	addi	r3,r3,1244
 3246a10:	18800017 	ldw	r2,0(r3)
 3246a14:	e0bff215 	stw	r2,-56(fp)
 3246a18:	18800117 	ldw	r2,4(r3)
 3246a1c:	e0bff315 	stw	r2,-52(fp)
 3246a20:	18800217 	ldw	r2,8(r3)
 3246a24:	e0bff415 	stw	r2,-48(fp)
 3246a28:	18800317 	ldw	r2,12(r3)
 3246a2c:	e0bff515 	stw	r2,-44(fp)
 3246a30:	18800417 	ldw	r2,16(r3)
 3246a34:	e0bff615 	stw	r2,-40(fp)
 3246a38:	18800517 	ldw	r2,20(r3)
 3246a3c:	e0bff715 	stw	r2,-36(fp)
 3246a40:	18800617 	ldw	r2,24(r3)
 3246a44:	e0bff815 	stw	r2,-32(fp)
 3246a48:	1880070b 	ldhu	r2,28(r3)
 3246a4c:	e0bff90d 	sth	r2,-28(fp)
    struct ip_mreq stMreq;
    u_char cTmp;
    unsigned long endtime;

   /* get a datagram socket */
   s = t_socket(AF_INET,SOCK_DGRAM, 0);
 3246a50:	01000084 	movi	r4,2
 3246a54:	01400084 	movi	r5,2
 3246a58:	000d883a 	mov	r6,zero
 3246a5c:	322df740 	call	322df74 <t_socket>
 3246a60:	e0bee515 	stw	r2,-1132(fp)

   if (s == INVALID_SOCKET) 
 3246a64:	e0bee517 	ldw	r2,-1132(fp)
 3246a68:	10bfffd8 	cmpnei	r2,r2,-1
 3246a6c:	1000091e 	bne	r2,zero,3246a94 <u_mctest_run+0xa0>
   {
      ns_printf (pio,"t_socket() failed, Err: %d\n", t_errno(s));
 3246a70:	e13ee517 	ldw	r4,-1132(fp)
 3246a74:	322f6880 	call	322f688 <t_errno>
 3246a78:	100d883a 	mov	r6,r2
 3246a7c:	e13fff17 	ldw	r4,-4(fp)
 3246a80:	0140c974 	movhi	r5,805
 3246a84:	29409004 	addi	r5,r5,576
 3246a88:	322637c0 	call	322637c <ns_printf>
      exit(1);
 3246a8c:	01000044 	movi	r4,1
 3246a90:	324bc600 	call	324bc60 <exit>
   }

   /* avoid EADDRINUSE error on bind() */ 
   iTmp = 1;
 3246a94:	00800044 	movi	r2,1
 3246a98:	e0bffa15 	stw	r2,-24(fp)
   iRet = t_setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&iTmp, sizeof(iTmp));
 3246a9c:	e1fffa04 	addi	r7,fp,-24
 3246aa0:	00800104 	movi	r2,4
 3246aa4:	d8800015 	stw	r2,0(sp)
 3246aa8:	e13ee517 	ldw	r4,-1132(fp)
 3246aac:	017fffc4 	movi	r5,-1
 3246ab0:	01800104 	movi	r6,4
 3246ab4:	322ea280 	call	322ea28 <t_setsockopt>
 3246ab8:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 3246abc:	e0bee317 	ldw	r2,-1140(fp)
 3246ac0:	10bfffd8 	cmpnei	r2,r2,-1
 3246ac4:	1000071e 	bne	r2,zero,3246ae4 <u_mctest_run+0xf0>
   {
      ns_printf (pio,"t_setsockopt() SO_REUSEADDR failed, Err: %d\n",
 3246ac8:	e13ee517 	ldw	r4,-1132(fp)
 3246acc:	322f6880 	call	322f688 <t_errno>
 3246ad0:	100d883a 	mov	r6,r2
 3246ad4:	e13fff17 	ldw	r4,-4(fp)
 3246ad8:	0140c974 	movhi	r5,805
 3246adc:	29409704 	addi	r5,r5,604
 3246ae0:	322637c0 	call	322637c <ns_printf>
       t_errno(s));
   }

   /* name the socket */
   stLocal.sin_family =   AF_INET;
 3246ae4:	00800084 	movi	r2,2
 3246ae8:	e0bee60d 	sth	r2,-1128(fp)
   stLocal.sin_addr.s_addr = htonl(INADDR_ANY);
 3246aec:	e03ee715 	stw	zero,-1124(fp)
   stLocal.sin_port =   htons(TEST_PORT);
 3246af0:	00a00344 	movi	r2,-32755
 3246af4:	e0bee68d 	sth	r2,-1126(fp)
   iRet = t_bind(s, (struct sockaddr*) &stLocal, sizeof(struct sockaddr_in));
 3246af8:	e17ee604 	addi	r5,fp,-1128
 3246afc:	e13ee517 	ldw	r4,-1132(fp)
 3246b00:	01800404 	movi	r6,16
 3246b04:	322e0040 	call	322e004 <t_bind>
 3246b08:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 3246b0c:	e0bee317 	ldw	r2,-1140(fp)
 3246b10:	10bfffd8 	cmpnei	r2,r2,-1
 3246b14:	1000061e 	bne	r2,zero,3246b30 <u_mctest_run+0x13c>
   {
      printf ("t_bind() failed, Err: %d\n",
 3246b18:	e13ee517 	ldw	r4,-1132(fp)
 3246b1c:	322f6880 	call	322f688 <t_errno>
 3246b20:	100b883a 	mov	r5,r2
 3246b24:	0100c974 	movhi	r4,805
 3246b28:	2100a304 	addi	r4,r4,652
 3246b2c:	3206de00 	call	3206de0 <printf>
       t_errno(s));
   }

   /* join the multicast group. TEST_ADDR */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR);
 3246b30:	e13fff17 	ldw	r4,-4(fp)
 3246b34:	0140c974 	movhi	r5,805
 3246b38:	2940aa04 	addi	r5,r5,680
 3246b3c:	0180c974 	movhi	r6,805
 3246b40:	3180b204 	addi	r6,r6,712
 3246b44:	322637c0 	call	322637c <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 3246b48:	0100c974 	movhi	r4,805
 3246b4c:	2100b204 	addi	r4,r4,712
 3246b50:	3247b240 	call	3247b24 <inet_addr>
 3246b54:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 3246b58:	0080c9b4 	movhi	r2,806
 3246b5c:	10b28504 	addi	r2,r2,-13804
 3246b60:	10800a17 	ldw	r2,40(r2)
 3246b64:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP,
 3246b68:	e1fffb04 	addi	r7,fp,-20
 3246b6c:	00800204 	movi	r2,8
 3246b70:	d8800015 	stw	r2,0(sp)
 3246b74:	e13ee517 	ldw	r4,-1132(fp)
 3246b78:	000b883a 	mov	r5,zero
 3246b7c:	01800304 	movi	r6,12
 3246b80:	322ea280 	call	322ea28 <t_setsockopt>
 3246b84:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 3246b88:	e0bee317 	ldw	r2,-1140(fp)
 3246b8c:	10bfffd8 	cmpnei	r2,r2,-1
 3246b90:	1000071e 	bne	r2,zero,3246bb0 <u_mctest_run+0x1bc>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 3246b94:	e13ee517 	ldw	r4,-1132(fp)
 3246b98:	322f6880 	call	322f688 <t_errno>
 3246b9c:	100d883a 	mov	r6,r2
 3246ba0:	e13fff17 	ldw	r4,-4(fp)
 3246ba4:	0140c974 	movhi	r5,805
 3246ba8:	2940b504 	addi	r5,r5,724
 3246bac:	322637c0 	call	322637c <ns_printf>
                     t_errno(s));
   } 
   tk_yield();
 3246bb0:	3226ddc0 	call	3226ddc <tk_yield>

   /* join the multicast group. TEST_ADDR1 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR1);
 3246bb4:	e13fff17 	ldw	r4,-4(fp)
 3246bb8:	0140c974 	movhi	r5,805
 3246bbc:	2940aa04 	addi	r5,r5,680
 3246bc0:	0180c974 	movhi	r6,805
 3246bc4:	3180c204 	addi	r6,r6,776
 3246bc8:	322637c0 	call	322637c <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR1);
 3246bcc:	0100c974 	movhi	r4,805
 3246bd0:	2100c204 	addi	r4,r4,776
 3246bd4:	3247b240 	call	3247b24 <inet_addr>
 3246bd8:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 3246bdc:	0080c9b4 	movhi	r2,806
 3246be0:	10b28504 	addi	r2,r2,-13804
 3246be4:	10800a17 	ldw	r2,40(r2)
 3246be8:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 3246bec:	e1fffb04 	addi	r7,fp,-20
 3246bf0:	00800204 	movi	r2,8
 3246bf4:	d8800015 	stw	r2,0(sp)
 3246bf8:	e13ee517 	ldw	r4,-1132(fp)
 3246bfc:	000b883a 	mov	r5,zero
 3246c00:	01800304 	movi	r6,12
 3246c04:	322ea280 	call	322ea28 <t_setsockopt>
 3246c08:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 3246c0c:	e0bee317 	ldw	r2,-1140(fp)
 3246c10:	10bfffd8 	cmpnei	r2,r2,-1
 3246c14:	1000071e 	bne	r2,zero,3246c34 <u_mctest_run+0x240>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 3246c18:	e13ee517 	ldw	r4,-1132(fp)
 3246c1c:	322f6880 	call	322f688 <t_errno>
 3246c20:	100d883a 	mov	r6,r2
 3246c24:	e13fff17 	ldw	r4,-4(fp)
 3246c28:	0140c974 	movhi	r5,805
 3246c2c:	2940b504 	addi	r5,r5,724
 3246c30:	322637c0 	call	322637c <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 3246c34:	3226ddc0 	call	3226ddc <tk_yield>

   /* join the multicast group. TEST_ADDR2 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR2);
 3246c38:	e13fff17 	ldw	r4,-4(fp)
 3246c3c:	0140c974 	movhi	r5,805
 3246c40:	2940aa04 	addi	r5,r5,680
 3246c44:	0180c974 	movhi	r6,805
 3246c48:	3180c504 	addi	r6,r6,788
 3246c4c:	322637c0 	call	322637c <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR2);
 3246c50:	0100c974 	movhi	r4,805
 3246c54:	2100c504 	addi	r4,r4,788
 3246c58:	3247b240 	call	3247b24 <inet_addr>
 3246c5c:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 3246c60:	0080c9b4 	movhi	r2,806
 3246c64:	10b28504 	addi	r2,r2,-13804
 3246c68:	10800a17 	ldw	r2,40(r2)
 3246c6c:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 3246c70:	e1fffb04 	addi	r7,fp,-20
 3246c74:	00800204 	movi	r2,8
 3246c78:	d8800015 	stw	r2,0(sp)
 3246c7c:	e13ee517 	ldw	r4,-1132(fp)
 3246c80:	000b883a 	mov	r5,zero
 3246c84:	01800304 	movi	r6,12
 3246c88:	322ea280 	call	322ea28 <t_setsockopt>
 3246c8c:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 3246c90:	e0bee317 	ldw	r2,-1140(fp)
 3246c94:	10bfffd8 	cmpnei	r2,r2,-1
 3246c98:	1000071e 	bne	r2,zero,3246cb8 <u_mctest_run+0x2c4>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 3246c9c:	e13ee517 	ldw	r4,-1132(fp)
 3246ca0:	322f6880 	call	322f688 <t_errno>
 3246ca4:	100d883a 	mov	r6,r2
 3246ca8:	e13fff17 	ldw	r4,-4(fp)
 3246cac:	0140c974 	movhi	r5,805
 3246cb0:	2940b504 	addi	r5,r5,724
 3246cb4:	322637c0 	call	322637c <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 3246cb8:	3226ddc0 	call	3226ddc <tk_yield>

   /* set TTL to traverse up to multiple routers */
   cTmp = TTL_VALUE;
 3246cbc:	00800084 	movi	r2,2
 3246cc0:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, (char *)&cTmp, sizeof(cTmp));
 3246cc4:	e1fffd04 	addi	r7,fp,-12
 3246cc8:	00800044 	movi	r2,1
 3246ccc:	d8800015 	stw	r2,0(sp)
 3246cd0:	e13ee517 	ldw	r4,-1132(fp)
 3246cd4:	000b883a 	mov	r5,zero
 3246cd8:	01800284 	movi	r6,10
 3246cdc:	322ea280 	call	322ea28 <t_setsockopt>
 3246ce0:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 3246ce4:	e0bee317 	ldw	r2,-1140(fp)
 3246ce8:	10bfffd8 	cmpnei	r2,r2,-1
 3246cec:	1000071e 	bne	r2,zero,3246d0c <u_mctest_run+0x318>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_TTL failed, Err: %d\n",
 3246cf0:	e13ee517 	ldw	r4,-1132(fp)
 3246cf4:	322f6880 	call	322f688 <t_errno>
 3246cf8:	100d883a 	mov	r6,r2
 3246cfc:	e13fff17 	ldw	r4,-4(fp)
 3246d00:	0140c974 	movhi	r5,805
 3246d04:	2940c804 	addi	r5,r5,800
 3246d08:	322637c0 	call	322637c <ns_printf>
                     t_errno(s));
   }

   /* enable loopback */
   cTmp = 1;
 3246d0c:	00800044 	movi	r2,1
 3246d10:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, (char *)&cTmp, sizeof(cTmp));
 3246d14:	e1fffd04 	addi	r7,fp,-12
 3246d18:	00800044 	movi	r2,1
 3246d1c:	d8800015 	stw	r2,0(sp)
 3246d20:	e13ee517 	ldw	r4,-1132(fp)
 3246d24:	000b883a 	mov	r5,zero
 3246d28:	018002c4 	movi	r6,11
 3246d2c:	322ea280 	call	322ea28 <t_setsockopt>
 3246d30:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 3246d34:	e0bee317 	ldw	r2,-1140(fp)
 3246d38:	10bfffd8 	cmpnei	r2,r2,-1
 3246d3c:	1000071e 	bne	r2,zero,3246d5c <u_mctest_run+0x368>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_LOOP failed, Err: %d\n",
 3246d40:	e13ee517 	ldw	r4,-1132(fp)
 3246d44:	322f6880 	call	322f688 <t_errno>
 3246d48:	100d883a 	mov	r6,r2
 3246d4c:	e13fff17 	ldw	r4,-4(fp)
 3246d50:	0140c974 	movhi	r5,805
 3246d54:	2940d504 	addi	r5,r5,852
 3246d58:	322637c0 	call	322637c <ns_printf>
                     t_errno(s));
   }

   /* assign our destination address */
   stTo.sin_family =      AF_INET;
 3246d5c:	00800084 	movi	r2,2
 3246d60:	e0beea0d 	sth	r2,-1112(fp)
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
 3246d64:	0100c974 	movhi	r4,805
 3246d68:	2100c204 	addi	r4,r4,776
 3246d6c:	3247b240 	call	3247b24 <inet_addr>
 3246d70:	e0beeb15 	stw	r2,-1108(fp)
   stTo.sin_port =        htons(TEST_PORT);
 3246d74:	00a00344 	movi	r2,-32755
 3246d78:	e0beea8d 	sth	r2,-1110(fp)
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
 3246d7c:	e13fff17 	ldw	r4,-4(fp)
 3246d80:	0140c974 	movhi	r5,805
 3246d84:	2940e204 	addi	r5,r5,904
 3246d88:	0180c974 	movhi	r6,805
 3246d8c:	3180c204 	addi	r6,r6,776
 3246d90:	322637c0 	call	322637c <ns_printf>
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 3246d94:	e03ee415 	stw	zero,-1136(fp)
 3246d98:	00008506 	br	3246fb0 <u_mctest_run+0x5bc>
   {
      static int iCounter = 1;

      /* send to the multicast address */
      sprintf(&achOut[16], "%d", iCounter++);
 3246d9c:	e0bff204 	addi	r2,fp,-56
 3246da0:	11000404 	addi	r4,r2,16
 3246da4:	d0a04e17 	ldw	r2,-32456(gp)
 3246da8:	100d883a 	mov	r6,r2
 3246dac:	10800044 	addi	r2,r2,1
 3246db0:	d0a04e15 	stw	r2,-32456(gp)
 3246db4:	0140c974 	movhi	r5,805
 3246db8:	2940f104 	addi	r5,r5,964
 3246dbc:	32079c00 	call	32079c0 <sprintf>
      iRet = t_sendto(s, achOut, sizeof(achOut), 0, (struct sockaddr*)&stTo,
 3246dc0:	e0beea04 	addi	r2,fp,-1112
 3246dc4:	e17ff204 	addi	r5,fp,-56
 3246dc8:	d8800015 	stw	r2,0(sp)
 3246dcc:	00800404 	movi	r2,16
 3246dd0:	d8800115 	stw	r2,4(sp)
 3246dd4:	e13ee517 	ldw	r4,-1132(fp)
 3246dd8:	01800784 	movi	r6,30
 3246ddc:	000f883a 	mov	r7,zero
 3246de0:	322efe80 	call	322efe8 <t_sendto>
 3246de4:	e0bee315 	stw	r2,-1140(fp)
                      sizeof(struct sockaddr_in));
      if (iRet < 0) 
 3246de8:	e0bee317 	ldw	r2,-1140(fp)
 3246dec:	1004403a 	cmpge	r2,r2,zero
 3246df0:	1000081e 	bne	r2,zero,3246e14 <u_mctest_run+0x420>
      {
         /*      perror("sendto() failed\n"); */
         ns_printf (pio,"t_sendto() failed, Error: %d\n", t_errno(s));
 3246df4:	e13ee517 	ldw	r4,-1132(fp)
 3246df8:	322f6880 	call	322f688 <t_errno>
 3246dfc:	100d883a 	mov	r6,r2
 3246e00:	e13fff17 	ldw	r4,-4(fp)
 3246e04:	0140c974 	movhi	r5,805
 3246e08:	2940f204 	addi	r5,r5,968
 3246e0c:	322637c0 	call	322637c <ns_printf>
         /*     exit(1); */
         goto exitloop;
 3246e10:	00006a06 	br	3246fbc <u_mctest_run+0x5c8>
      }

      /* make the socket non-blocking */
      iTmp = 1;
 3246e14:	00800044 	movi	r2,1
 3246e18:	e0bffa15 	stw	r2,-24(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&iTmp, sizeof(iTmp));
 3246e1c:	e1fffa04 	addi	r7,fp,-24
 3246e20:	00800104 	movi	r2,4
 3246e24:	d8800015 	stw	r2,0(sp)
 3246e28:	e13ee517 	ldw	r4,-1132(fp)
 3246e2c:	017fffc4 	movi	r5,-1
 3246e30:	01840584 	movi	r6,4118
 3246e34:	322ea280 	call	322ea28 <t_setsockopt>
 3246e38:	e0bee315 	stw	r2,-1140(fp)
      if (iRet == SOCKET_ERROR) 
 3246e3c:	e0bee317 	ldw	r2,-1140(fp)
 3246e40:	10bfffd8 	cmpnei	r2,r2,-1
 3246e44:	1000071e 	bne	r2,zero,3246e64 <u_mctest_run+0x470>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (1) failed, Err: %d\n",
 3246e48:	e13ee517 	ldw	r4,-1132(fp)
 3246e4c:	322f6880 	call	322f688 <t_errno>
 3246e50:	100d883a 	mov	r6,r2
 3246e54:	e13fff17 	ldw	r4,-4(fp)
 3246e58:	0140c974 	movhi	r5,805
 3246e5c:	2940fa04 	addi	r5,r5,1000
 3246e60:	322637c0 	call	322637c <ns_printf>
                        t_errno(s));
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);
 3246e64:	0080c974 	movhi	r2,805
 3246e68:	10934104 	addi	r2,r2,19716
 3246e6c:	10800017 	ldw	r2,0(r2)
 3246e70:	1084e204 	addi	r2,r2,5000
 3246e74:	e0bee215 	stw	r2,-1144(fp)

      while (cticks < endtime)
 3246e78:	00003206 	br	3246f44 <u_mctest_run+0x550>
      {
         int sa_size = sizeof(struct sockaddr_in);
 3246e7c:	00800404 	movi	r2,16
 3246e80:	e0bffe15 	stw	r2,-8(fp)
         tk_yield();
 3246e84:	3226ddc0 	call	3226ddc <tk_yield>

         iRet = t_recvfrom(s, achIn, BUFSIZE, 0, (struct sockaddr*)&stFrom, &sa_size);
 3246e88:	e0beee04 	addi	r2,fp,-1096
 3246e8c:	e17ef204 	addi	r5,fp,-1080
 3246e90:	d8800015 	stw	r2,0(sp)
 3246e94:	e0bffe04 	addi	r2,fp,-8
 3246e98:	d8800115 	stw	r2,4(sp)
 3246e9c:	e13ee517 	ldw	r4,-1132(fp)
 3246ea0:	01810004 	movi	r6,1024
 3246ea4:	000f883a 	mov	r7,zero
 3246ea8:	322ee980 	call	322ee98 <t_recvfrom>
 3246eac:	e0bee315 	stw	r2,-1140(fp)
         if (iRet < 0) 
 3246eb0:	e0bee317 	ldw	r2,-1140(fp)
 3246eb4:	1004403a 	cmpge	r2,r2,zero
 3246eb8:	10000c1e 	bne	r2,zero,3246eec <u_mctest_run+0x4f8>
         {
            if (t_errno(s) != EWOULDBLOCK)
 3246ebc:	e13ee517 	ldw	r4,-1132(fp)
 3246ec0:	322f6880 	call	322f688 <t_errno>
 3246ec4:	108002e0 	cmpeqi	r2,r2,11
 3246ec8:	1000081e 	bne	r2,zero,3246eec <u_mctest_run+0x4f8>
            {
               /*      perror("recvfrom() failed\n"); */
               ns_printf (pio,"t_recvfrom() failed, Error: %d\n", t_errno(s));
 3246ecc:	e13ee517 	ldw	r4,-1132(fp)
 3246ed0:	322f6880 	call	322f688 <t_errno>
 3246ed4:	100d883a 	mov	r6,r2
 3246ed8:	e13fff17 	ldw	r4,-4(fp)
 3246edc:	0140c974 	movhi	r5,805
 3246ee0:	29410604 	addi	r5,r5,1048
 3246ee4:	322637c0 	call	322637c <ns_printf>
               /*     exit(1); */
               goto exitloop;
 3246ee8:	00003406 	br	3246fbc <u_mctest_run+0x5c8>
            }
         }
         if (iRet > 0)
 3246eec:	e0bee317 	ldw	r2,-1140(fp)
 3246ef0:	10800050 	cmplti	r2,r2,1
 3246ef4:	1000131e 	bne	r2,zero,3246f44 <u_mctest_run+0x550>
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 3246ef8:	e13eef17 	ldw	r4,-1092(fp)
 3246efc:	3225fb40 	call	3225fb4 <print_ipad>
 3246f00:	100d883a 	mov	r6,r2
 3246f04:	e0beee8b 	ldhu	r2,-1094(fp)
 3246f08:	10bfffcc 	andi	r2,r2,65535
 3246f0c:	1004d23a 	srli	r2,r2,8
 3246f10:	10bfffcc 	andi	r2,r2,65535
 3246f14:	10c03fcc 	andi	r3,r2,255
 3246f18:	e0beee8b 	ldhu	r2,-1094(fp)
 3246f1c:	10bfffcc 	andi	r2,r2,65535
 3246f20:	1004923a 	slli	r2,r2,8
 3246f24:	10bfc00c 	andi	r2,r2,65280
 3246f28:	188eb03a 	or	r7,r3,r2
 3246f2c:	e0bef204 	addi	r2,fp,-1080
 3246f30:	d8800015 	stw	r2,0(sp)
 3246f34:	e13fff17 	ldw	r4,-4(fp)
 3246f38:	0140c974 	movhi	r5,805
 3246f3c:	29410e04 	addi	r5,r5,1080
 3246f40:	322637c0 	call	322637c <ns_printf>
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);

      while (cticks < endtime)
 3246f44:	0080c974 	movhi	r2,805
 3246f48:	10934104 	addi	r2,r2,19716
 3246f4c:	10c00017 	ldw	r3,0(r2)
 3246f50:	e0bee217 	ldw	r2,-1144(fp)
 3246f54:	18bfc936 	bltu	r3,r2,3246e7c <u_mctest_run+0x488>
             ntohs(stFrom.sin_port), achIn);
         }
      }   /* end while (cticks...) */

      /* make the socket blocking */
      cTmp = 0;
 3246f58:	e03ffd05 	stb	zero,-12(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&cTmp, sizeof(cTmp));
 3246f5c:	e1fffd04 	addi	r7,fp,-12
 3246f60:	00800044 	movi	r2,1
 3246f64:	d8800015 	stw	r2,0(sp)
 3246f68:	e13ee517 	ldw	r4,-1132(fp)
 3246f6c:	017fffc4 	movi	r5,-1
 3246f70:	01840584 	movi	r6,4118
 3246f74:	322ea280 	call	322ea28 <t_setsockopt>
 3246f78:	e0bee315 	stw	r2,-1140(fp)
      if (iRet == SOCKET_ERROR) 
 3246f7c:	e0bee317 	ldw	r2,-1140(fp)
 3246f80:	10bfffd8 	cmpnei	r2,r2,-1
 3246f84:	1000071e 	bne	r2,zero,3246fa4 <u_mctest_run+0x5b0>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (0) failed, Err: %d\n",
 3246f88:	e13ee517 	ldw	r4,-1132(fp)
 3246f8c:	322f6880 	call	322f688 <t_errno>
 3246f90:	100d883a 	mov	r6,r2
 3246f94:	e13fff17 	ldw	r4,-4(fp)
 3246f98:	0140c974 	movhi	r5,805
 3246f9c:	29411504 	addi	r5,r5,1108
 3246fa0:	322637c0 	call	322637c <ns_printf>
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
   stTo.sin_port =        htons(TEST_PORT);
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 3246fa4:	e0bee417 	ldw	r2,-1136(fp)
 3246fa8:	10800044 	addi	r2,r2,1
 3246fac:	e0bee415 	stw	r2,-1136(fp)
 3246fb0:	e0bee417 	ldw	r2,-1136(fp)
 3246fb4:	108000d0 	cmplti	r2,r2,3
 3246fb8:	103f781e 	bne	r2,zero,3246d9c <u_mctest_run+0x3a8>
      }
   }   /* end for(;;) */

exitloop:
   /* delete the multicast group. */
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 3246fbc:	0100c974 	movhi	r4,805
 3246fc0:	2100b204 	addi	r4,r4,712
 3246fc4:	3247b240 	call	3247b24 <inet_addr>
 3246fc8:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 3246fcc:	0080c9b4 	movhi	r2,806
 3246fd0:	10b28504 	addi	r2,r2,-13804
 3246fd4:	10800a17 	ldw	r2,40(r2)
 3246fd8:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char *)&stMreq, sizeof(stMreq));
 3246fdc:	e1fffb04 	addi	r7,fp,-20
 3246fe0:	00800204 	movi	r2,8
 3246fe4:	d8800015 	stw	r2,0(sp)
 3246fe8:	e13ee517 	ldw	r4,-1132(fp)
 3246fec:	000b883a 	mov	r5,zero
 3246ff0:	01800344 	movi	r6,13
 3246ff4:	322ea280 	call	322ea28 <t_setsockopt>
 3246ff8:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 3246ffc:	e0bee317 	ldw	r2,-1140(fp)
 3247000:	10bfffd8 	cmpnei	r2,r2,-1
 3247004:	1000071e 	bne	r2,zero,3247024 <u_mctest_run+0x630>
   {
      ns_printf (pio,"t_setsockopt() IP_DROP_MEMBERSHIP failed, Err: %d\n",
 3247008:	e13ee517 	ldw	r4,-1132(fp)
 324700c:	322f6880 	call	322f688 <t_errno>
 3247010:	100d883a 	mov	r6,r2
 3247014:	e13fff17 	ldw	r4,-4(fp)
 3247018:	0140c974 	movhi	r5,805
 324701c:	29412104 	addi	r5,r5,1156
 3247020:	322637c0 	call	322637c <ns_printf>
   {
      ns_printf (pio,"t_shutdown failed.  Err: %d\n", t_errno(s));
   }
#endif

   iRet = t_socketclose(s);
 3247024:	e13ee517 	ldw	r4,-1132(fp)
 3247028:	322f5200 	call	322f520 <t_socketclose>
 324702c:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 3247030:	e0bee317 	ldw	r2,-1140(fp)
 3247034:	10bfffd8 	cmpnei	r2,r2,-1
 3247038:	1000071e 	bne	r2,zero,3247058 <u_mctest_run+0x664>
   {
      ns_printf (pio,"t_socketclose() failed.  Err: %d\n", t_errno(s));
 324703c:	e13ee517 	ldw	r4,-1132(fp)
 3247040:	322f6880 	call	322f688 <t_errno>
 3247044:	100d883a 	mov	r6,r2
 3247048:	e13fff17 	ldw	r4,-4(fp)
 324704c:	0140c974 	movhi	r5,805
 3247050:	29412e04 	addi	r5,r5,1208
 3247054:	322637c0 	call	322637c <ns_printf>
   }

   return(0);
 3247058:	0005883a 	mov	r2,zero
}  /* end main() */  
 324705c:	e037883a 	mov	sp,fp
 3247060:	dfc00117 	ldw	ra,4(sp)
 3247064:	df000017 	ldw	fp,0(sp)
 3247068:	dec00204 	addi	sp,sp,8
 324706c:	f800283a 	ret

03247070 <dhc_setup>:
 * RETURNS: void
 */

void
dhc_setup(void)
{  
 3247070:	defff604 	addi	sp,sp,-40
 3247074:	dfc00915 	stw	ra,36(sp)
 3247078:	df000815 	stw	fp,32(sp)
 324707c:	df000804 	addi	fp,sp,32
   int      iface;
   ulong    dhcp_started;
   ip_addr  dhcp_saveaddr[STATIC_NETS];
   int      e;
   int      dhcnets = 0;   /* number of nets doing DHCP */
 3247080:	e03ff815 	stw	zero,-32(fp)

   e = dhc_init();
 3247084:	32270a00 	call	32270a0 <dhc_init>
 3247088:	e0bff915 	stw	r2,-28(fp)

   if (e)
 324708c:	e0bff917 	ldw	r2,-28(fp)
 3247090:	1005003a 	cmpeq	r2,r2,zero
 3247094:	1000051e 	bne	r2,zero,32470ac <dhc_setup+0x3c>
   {
      printf("Error starting DHCP client code.\n");
 3247098:	0100c974 	movhi	r4,805
 324709c:	21013f04 	addi	r4,r4,1276
 32470a0:	32071080 	call	3207108 <puts>
      netexit(1);
 32470a4:	01000044 	movi	r4,1
 32470a8:	3243b540 	call	3243b54 <netexit>
   }

   dhcp_started = cticks;  /* init timeout */
 32470ac:	0080c974 	movhi	r2,805
 32470b0:	10934104 	addi	r2,r2,19716
 32470b4:	10800017 	ldw	r2,0(r2)
 32470b8:	e0bffa15 	stw	r2,-24(fp)

   for (iface = 0; iface < STATIC_NETS; iface++)
 32470bc:	e03ffb15 	stw	zero,-20(fp)
 32470c0:	00005106 	br	3247208 <dhc_setup+0x198>
   {
      if (!nets[iface])
 32470c4:	e0bffb17 	ldw	r2,-20(fp)
 32470c8:	00c0c9b4 	movhi	r3,806
 32470cc:	18f34504 	addi	r3,r3,-13036
 32470d0:	1085883a 	add	r2,r2,r2
 32470d4:	1085883a 	add	r2,r2,r2
 32470d8:	10c5883a 	add	r2,r2,r3
 32470dc:	10800017 	ldw	r2,0(r2)
 32470e0:	1005003a 	cmpeq	r2,r2,zero
 32470e4:	1000451e 	bne	r2,zero,32471fc <dhc_setup+0x18c>
#ifdef INCLUDE_NVPARMS
      if (inet_nvparms.ifs[iface].client_dhcp)
         nets[iface]->n_flags |= NF_DHCPC ; /* use DHCP Client on this iface */
#endif   /* INCLUDE_NVPARMS */

      if (!(nets[iface]->n_flags & NF_DHCPC))
 32470e8:	e0bffb17 	ldw	r2,-20(fp)
 32470ec:	00c0c9b4 	movhi	r3,806
 32470f0:	18f34504 	addi	r3,r3,-13036
 32470f4:	1085883a 	add	r2,r2,r2
 32470f8:	1085883a 	add	r2,r2,r2
 32470fc:	10c5883a 	add	r2,r2,r3
 3247100:	10800017 	ldw	r2,0(r2)
 3247104:	10802a17 	ldw	r2,168(r2)
 3247108:	1080400c 	andi	r2,r2,256
 324710c:	1005003a 	cmpeq	r2,r2,zero
 3247110:	10003a1e 	bne	r2,zero,32471fc <dhc_setup+0x18c>
         continue;

      /* If callback is not already in use (by AutoIP) grab it for
       * our printf routine.
       */
      if(dhc_states[iface].callback == NULL)
 3247114:	e0bffb17 	ldw	r2,-20(fp)
 3247118:	00c0c9b4 	movhi	r3,806
 324711c:	18f36b04 	addi	r3,r3,-12884
 3247120:	10800f24 	muli	r2,r2,60
 3247124:	10c5883a 	add	r2,r2,r3
 3247128:	10800e04 	addi	r2,r2,56
 324712c:	10800017 	ldw	r2,0(r2)
 3247130:	1004c03a 	cmpne	r2,r2,zero
 3247134:	1000041e 	bne	r2,zero,3247148 <dhc_setup+0xd8>
      {
         dhc_set_callback(iface, dhc_main_ipset);
 3247138:	e13ffb17 	ldw	r4,-20(fp)
 324713c:	0140c934 	movhi	r5,804
 3247140:	295cbe04 	addi	r5,r5,29432
 3247144:	322715c0 	call	322715c <dhc_set_callback>
      }

      /* start DHCP on the iface - first save the default address */
      dhcp_saveaddr[iface] = nets[iface]->n_ipaddr;
 3247148:	e13ffb17 	ldw	r4,-20(fp)
 324714c:	e0bffb17 	ldw	r2,-20(fp)
 3247150:	00c0c9b4 	movhi	r3,806
 3247154:	18f34504 	addi	r3,r3,-13036
 3247158:	1085883a 	add	r2,r2,r2
 324715c:	1085883a 	add	r2,r2,r2
 3247160:	10c5883a 	add	r2,r2,r3
 3247164:	10800017 	ldw	r2,0(r2)
 3247168:	10c00a17 	ldw	r3,40(r2)
 324716c:	2105883a 	add	r2,r4,r4
 3247170:	1085883a 	add	r2,r2,r2
 3247174:	e13ff804 	addi	r4,fp,-32
 3247178:	1105883a 	add	r2,r2,r4
 324717c:	10800404 	addi	r2,r2,16
 3247180:	10c00015 	stw	r3,0(r2)

      if (dhcp_saveaddr[iface] == 0L)  /* see if there is a default */
 3247184:	e0bffb17 	ldw	r2,-20(fp)
 3247188:	1085883a 	add	r2,r2,r2
 324718c:	1085883a 	add	r2,r2,r2
 3247190:	e0fff804 	addi	r3,fp,-32
 3247194:	10c5883a 	add	r2,r2,r3
 3247198:	10800404 	addi	r2,r2,16
 324719c:	10800017 	ldw	r2,0(r2)
 32471a0:	1004c03a 	cmpne	r2,r2,zero
 32471a4:	1000041e 	bne	r2,zero,32471b8 <dhc_setup+0x148>
         dhc_state_init(iface, TRUE);  /* Put DHCPClient in INIT state */
 32471a8:	e13ffb17 	ldw	r4,-20(fp)
 32471ac:	01400044 	movi	r5,1
 32471b0:	3229d3c0 	call	3229d3c <dhc_state_init>
 32471b4:	00000306 	br	32471c4 <dhc_setup+0x154>
      else
         dhc_state_init(iface, FALSE); /* Put DHCPClient in INIT-REBOOT state */
 32471b8:	e13ffb17 	ldw	r4,-20(fp)
 32471bc:	000b883a 	mov	r5,zero
 32471c0:	3229d3c0 	call	3229d3c <dhc_state_init>

      e=dhc_second();                  /* To send the DISCOVER/REQUEST pkt */
 32471c4:	32295480 	call	3229548 <dhc_second>
 32471c8:	e0bff915 	stw	r2,-28(fp)
      if (e)
 32471cc:	e0bff917 	ldw	r2,-28(fp)
 32471d0:	1005003a 	cmpeq	r2,r2,zero
 32471d4:	1000061e 	bne	r2,zero,32471f0 <dhc_setup+0x180>
      {
         printf("Error sending DHCP packet on iface %d.\n", iface);
 32471d8:	0100c974 	movhi	r4,805
 32471dc:	21014804 	addi	r4,r4,1312
 32471e0:	e17ffb17 	ldw	r5,-20(fp)
 32471e4:	3206de00 	call	3206de0 <printf>
         netexit(1);
 32471e8:	01000044 	movi	r4,1
 32471ec:	3243b540 	call	3243b54 <netexit>
      /* If we are not using Auto IP then we want to block below waiting
       * for DHCP completion. If we are using Auto IP then we want to
       * return and let the Auto IP code handle the DHCP completion.
       * "dhcnets" is a flag which allows this.
       */
      dhcnets++;
 32471f0:	e0bff817 	ldw	r2,-32(fp)
 32471f4:	10800044 	addi	r2,r2,1
 32471f8:	e0bff815 	stw	r2,-32(fp)
      netexit(1);
   }

   dhcp_started = cticks;  /* init timeout */

   for (iface = 0; iface < STATIC_NETS; iface++)
 32471fc:	e0bffb17 	ldw	r2,-20(fp)
 3247200:	10800044 	addi	r2,r2,1
 3247204:	e0bffb15 	stw	r2,-20(fp)
 3247208:	e0bffb17 	ldw	r2,-20(fp)
 324720c:	10800110 	cmplti	r2,r2,4
 3247210:	103fac1e 	bne	r2,zero,32470c4 <dhc_setup+0x54>
       */
      dhcnets++;
#endif
   }

   if(dhcnets == 0)  /* no nets doing DHCP? */
 3247214:	e0bff817 	ldw	r2,-32(fp)
 3247218:	1005003a 	cmpeq	r2,r2,zero
 324721c:	1000311e 	bne	r2,zero,32472e4 <dhc_setup+0x274>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 3247220:	00000206 	br	324722c <dhc_setup+0x1bc>
   {
      /* let other tasks spin. This is required, since some systems
       * increment cticks in tasks, or use a polling task to receive
       * packets. Without this activity this loop will never exit.
       */
      tk_yield();
 3247224:	3226ddc0 	call	3226ddc <tk_yield>
      pktdemux();
 3247228:	32236540 	call	3223654 <pktdemux>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 324722c:	0080c974 	movhi	r2,805
 3247230:	10934104 	addi	r2,r2,19716
 3247234:	10c00017 	ldw	r3,0(r2)
 3247238:	e0bffa17 	ldw	r2,-24(fp)
 324723c:	1887c83a 	sub	r3,r3,r2
 3247240:	008000b4 	movhi	r2,2
 3247244:	10bef3c4 	addi	r2,r2,-1073
 3247248:	10c00336 	bltu	r2,r3,3247258 <dhc_setup+0x1e8>
 324724c:	3229d9c0 	call	3229d9c <dhc_alldone>
 3247250:	1005003a 	cmpeq	r2,r2,zero
 3247254:	103ff31e 	bne	r2,zero,3247224 <dhc_setup+0x1b4>
#ifdef SUPERLOOP
      dhc_second ();
#endif
   }

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
 3247258:	3229d9c0 	call	3229d9c <dhc_alldone>
 324725c:	1004c03a 	cmpne	r2,r2,zero
 3247260:	1000201e 	bne	r2,zero,32472e4 <dhc_setup+0x274>
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
 3247264:	0100c974 	movhi	r4,805
 3247268:	21015204 	addi	r4,r4,1352
 324726c:	32071080 	call	3207108 <puts>
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 3247270:	e03ffb15 	stw	zero,-20(fp)
 3247274:	00001806 	br	32472d8 <dhc_setup+0x268>
      {
         if (dhc_ifacedone(iface) == FALSE)
 3247278:	e13ffb17 	ldw	r4,-20(fp)
 324727c:	3229e2c0 	call	3229e2c <dhc_ifacedone>
 3247280:	1004c03a 	cmpne	r2,r2,zero
 3247284:	1000111e 	bne	r2,zero,32472cc <dhc_setup+0x25c>
         {
            dhc_halt(iface);
 3247288:	e13ffb17 	ldw	r4,-20(fp)
 324728c:	3229ae40 	call	3229ae4 <dhc_halt>
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
 3247290:	e0bffb17 	ldw	r2,-20(fp)
 3247294:	00c0c9b4 	movhi	r3,806
 3247298:	18f34504 	addi	r3,r3,-13036
 324729c:	1085883a 	add	r2,r2,r2
 32472a0:	1085883a 	add	r2,r2,r2
 32472a4:	10c5883a 	add	r2,r2,r3
 32472a8:	10c00017 	ldw	r3,0(r2)
 32472ac:	e0bffb17 	ldw	r2,-20(fp)
 32472b0:	1085883a 	add	r2,r2,r2
 32472b4:	1085883a 	add	r2,r2,r2
 32472b8:	e13ff804 	addi	r4,fp,-32
 32472bc:	1105883a 	add	r2,r2,r4
 32472c0:	10800404 	addi	r2,r2,16
 32472c4:	10800017 	ldw	r2,0(r2)
 32472c8:	18800a15 	stw	r2,40(r3)

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 32472cc:	e0bffb17 	ldw	r2,-20(fp)
 32472d0:	10800044 	addi	r2,r2,1
 32472d4:	e0bffb15 	stw	r2,-20(fp)
 32472d8:	e0bffb17 	ldw	r2,-20(fp)
 32472dc:	10800110 	cmplti	r2,r2,4
 32472e0:	103fe51e 	bne	r2,zero,3247278 <dhc_setup+0x208>
            dhc_halt(iface);
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
         }
      }
   }
}
 32472e4:	e037883a 	mov	sp,fp
 32472e8:	dfc00117 	ldw	ra,4(sp)
 32472ec:	df000017 	ldw	fp,0(sp)
 32472f0:	dec00204 	addi	sp,sp,8
 32472f4:	f800283a 	ret

032472f8 <dhc_main_ipset>:
 * RETURNS: 
 */

int
dhc_main_ipset(int iface, int state)
{
 32472f8:	defffc04 	addi	sp,sp,-16
 32472fc:	dfc00315 	stw	ra,12(sp)
 3247300:	df000215 	stw	fp,8(sp)
 3247304:	df000204 	addi	fp,sp,8
 3247308:	e13ffe15 	stw	r4,-8(fp)
 324730c:	e17fff15 	stw	r5,-4(fp)
   if ( state == DHCS_BOUND )
 3247310:	e0bfff17 	ldw	r2,-4(fp)
 3247314:	10800198 	cmpnei	r2,r2,6
 3247318:	1000321e 	bne	r2,zero,32473e4 <dhc_main_ipset+0xec>
   {
      /* print IP address acquired through DHCP Client - for user's benefit */
      printf("Acquired IP address via DHCP client for interface: %s\n",
 324731c:	e0bffe17 	ldw	r2,-8(fp)
 3247320:	00c0c9b4 	movhi	r3,806
 3247324:	18f34504 	addi	r3,r3,-13036
 3247328:	1085883a 	add	r2,r2,r2
 324732c:	1085883a 	add	r2,r2,r2
 3247330:	10c5883a 	add	r2,r2,r3
 3247334:	10800017 	ldw	r2,0(r2)
 3247338:	11400104 	addi	r5,r2,4
 324733c:	0100c974 	movhi	r4,805
 3247340:	21016004 	addi	r4,r4,1408
 3247344:	3206de00 	call	3206de0 <printf>
              nets[iface]->name);

      printf("IP address : %s\n", print_ipad(nets[iface]->n_ipaddr));
 3247348:	e0bffe17 	ldw	r2,-8(fp)
 324734c:	00c0c9b4 	movhi	r3,806
 3247350:	18f34504 	addi	r3,r3,-13036
 3247354:	1085883a 	add	r2,r2,r2
 3247358:	1085883a 	add	r2,r2,r2
 324735c:	10c5883a 	add	r2,r2,r3
 3247360:	10800017 	ldw	r2,0(r2)
 3247364:	11000a17 	ldw	r4,40(r2)
 3247368:	3225fb40 	call	3225fb4 <print_ipad>
 324736c:	100b883a 	mov	r5,r2
 3247370:	0100c974 	movhi	r4,805
 3247374:	21016e04 	addi	r4,r4,1464
 3247378:	3206de00 	call	3206de0 <printf>
      printf("Subnet Mask: %s\n", print_ipad(nets[iface]->snmask));
 324737c:	e0bffe17 	ldw	r2,-8(fp)
 3247380:	00c0c9b4 	movhi	r3,806
 3247384:	18f34504 	addi	r3,r3,-13036
 3247388:	1085883a 	add	r2,r2,r2
 324738c:	1085883a 	add	r2,r2,r2
 3247390:	10c5883a 	add	r2,r2,r3
 3247394:	10800017 	ldw	r2,0(r2)
 3247398:	11000c17 	ldw	r4,48(r2)
 324739c:	3225fb40 	call	3225fb4 <print_ipad>
 32473a0:	100b883a 	mov	r5,r2
 32473a4:	0100c974 	movhi	r4,805
 32473a8:	21017304 	addi	r4,r4,1484
 32473ac:	3206de00 	call	3206de0 <printf>
      printf("Gateway    : %s\n", print_ipad(nets[iface]->n_defgw));
 32473b0:	e0bffe17 	ldw	r2,-8(fp)
 32473b4:	00c0c9b4 	movhi	r3,806
 32473b8:	18f34504 	addi	r3,r3,-13036
 32473bc:	1085883a 	add	r2,r2,r2
 32473c0:	1085883a 	add	r2,r2,r2
 32473c4:	10c5883a 	add	r2,r2,r3
 32473c8:	10800017 	ldw	r2,0(r2)
 32473cc:	11000d17 	ldw	r4,52(r2)
 32473d0:	3225fb40 	call	3225fb4 <print_ipad>
 32473d4:	100b883a 	mov	r5,r2
 32473d8:	0100c974 	movhi	r4,805
 32473dc:	21017804 	addi	r4,r4,1504
 32473e0:	3206de00 	call	3206de0 <printf>
   }
   return 0;
 32473e4:	0005883a 	mov	r2,zero
}
 32473e8:	e037883a 	mov	sp,fp
 32473ec:	dfc00117 	ldw	ra,4(sp)
 32473f0:	df000017 	ldw	fp,0(sp)
 32473f4:	dec00204 	addi	sp,sp,8
 32473f8:	f800283a 	ret

032473fc <init_memdev>:
 * RETURNS: 
 */

int
init_memdev(void)
{
 32473fc:	deffff04 	addi	sp,sp,-4
 3247400:	df000015 	stw	fp,0(sp)
 3247404:	d839883a 	mov	fp,sp
   /* add our IO pointer to master list */
   mdio.next = vfsystems;
 3247408:	0080c974 	movhi	r2,805
 324740c:	10936d04 	addi	r2,r2,19892
 3247410:	10c00017 	ldw	r3,0(r2)
 3247414:	0080c974 	movhi	r2,805
 3247418:	108a0704 	addi	r2,r2,10268
 324741c:	10c00015 	stw	r3,0(r2)
   vfsystems = &mdio;
 3247420:	00c0c974 	movhi	r3,805
 3247424:	18d36d04 	addi	r3,r3,19892
 3247428:	0080c974 	movhi	r2,805
 324742c:	108a0704 	addi	r2,r2,10268
 3247430:	18800015 	stw	r2,0(r3)

   /* add the memory device files to vfs list */
   mdlist[0].next = vfsfiles;
 3247434:	0080c974 	movhi	r2,805
 3247438:	10936f04 	addi	r2,r2,19900
 324743c:	10c00017 	ldw	r3,0(r2)
 3247440:	0080c974 	movhi	r2,805
 3247444:	108a1004 	addi	r2,r2,10304
 3247448:	10c00015 	stw	r3,0(r2)
   vfsfiles = &mdlist[3];
 324744c:	00c0c974 	movhi	r3,805
 3247450:	18ca3104 	addi	r3,r3,10436
 3247454:	0080c974 	movhi	r2,805
 3247458:	10936f04 	addi	r2,r2,19900
 324745c:	10c00015 	stw	r3,0(r2)

   return 0;
 3247460:	0005883a 	mov	r2,zero
}
 3247464:	e037883a 	mov	sp,fp
 3247468:	df000017 	ldw	fp,0(sp)
 324746c:	dec00104 	addi	sp,sp,4
 3247470:	f800283a 	ret

03247474 <md_fopen>:
 * RETURNS: 
 */

VFILE* 
md_fopen(char * name, char * mode)
{
 3247474:	defffd04 	addi	sp,sp,-12
 3247478:	df000215 	stw	fp,8(sp)
 324747c:	df000204 	addi	fp,sp,8
 3247480:	e13ffe15 	stw	r4,-8(fp)
 3247484:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(mode);
   USE_ARG(name);
   return NULL;
 3247488:	0005883a 	mov	r2,zero
}
 324748c:	e037883a 	mov	sp,fp
 3247490:	df000017 	ldw	fp,0(sp)
 3247494:	dec00104 	addi	sp,sp,4
 3247498:	f800283a 	ret

0324749c <md_fclose>:
 * RETURNS: 
 */

void   
md_fclose(VFILE * vfd)
{
 324749c:	defffe04 	addi	sp,sp,-8
 32474a0:	df000115 	stw	fp,4(sp)
 32474a4:	df000104 	addi	fp,sp,4
 32474a8:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);
}
 32474ac:	e037883a 	mov	sp,fp
 32474b0:	df000017 	ldw	fp,0(sp)
 32474b4:	dec00104 	addi	sp,sp,4
 32474b8:	f800283a 	ret

032474bc <md_fread>:
 * RETURNS: 
 */

int    
md_fread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 32474bc:	defff604 	addi	sp,sp,-40
 32474c0:	dfc00915 	stw	ra,36(sp)
 32474c4:	df000815 	stw	fp,32(sp)
 32474c8:	df000804 	addi	fp,sp,32
 32474cc:	e13ffb15 	stw	r4,-20(fp)
 32474d0:	e17ffc15 	stw	r5,-16(fp)
 32474d4:	e1bffd15 	stw	r6,-12(fp)
 32474d8:	e1fffe15 	stw	r7,-8(fp)
   u_long   bcount;     /* number of bytes put in caller's buffer */
   u_long   location;   /* current offset into file */
   unsigned long file_size = MEMDEV_SIZE;
 32474dc:	00800834 	movhi	r2,32
 32474e0:	e0bff815 	stw	r2,-32(fp)
   if(vfd && vfd->file)
 32474e4:	e0bffe17 	ldw	r2,-8(fp)
 32474e8:	1005003a 	cmpeq	r2,r2,zero
 32474ec:	1000081e 	bne	r2,zero,3247510 <md_fread+0x54>
 32474f0:	e0bffe17 	ldw	r2,-8(fp)
 32474f4:	10800117 	ldw	r2,4(r2)
 32474f8:	1005003a 	cmpeq	r2,r2,zero
 32474fc:	1000041e 	bne	r2,zero,3247510 <md_fread+0x54>
   {
      file_size = vfd->file->real_size; 
 3247500:	e0bffe17 	ldw	r2,-8(fp)
 3247504:	10800117 	ldw	r2,4(r2)
 3247508:	10800717 	ldw	r2,28(r2)
 324750c:	e0bff815 	stw	r2,-32(fp)
#ifdef SEG16_16   /* 16-bit x86 must include segment. */
   if(vfd->cmploc == (u_char*)0xFFFFFFFF)   /* at EOF */
      return 0;
   location = (u_long)(((char huge *)vfd->cmploc) - ((char huge *)vfd->file->data));
#else
   location = (u_long)(vfd->cmploc - vfd->file->data);
 3247510:	e0bffe17 	ldw	r2,-8(fp)
 3247514:	10800217 	ldw	r2,8(r2)
 3247518:	1007883a 	mov	r3,r2
 324751c:	e0bffe17 	ldw	r2,-8(fp)
 3247520:	10800117 	ldw	r2,4(r2)
 3247524:	10800617 	ldw	r2,24(r2)
 3247528:	1885c83a 	sub	r2,r3,r2
 324752c:	e0bff915 	stw	r2,-28(fp)
#endif   /* SEG16_16 */

   bcount = (items * (u_long)size);     /* number of bytes to transfer */
 3247530:	e0fffd17 	ldw	r3,-12(fp)
 3247534:	e0bffc17 	ldw	r2,-16(fp)
 3247538:	1885383a 	mul	r2,r3,r2
 324753c:	e0bffa15 	stw	r2,-24(fp)

   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
 3247540:	e0fff917 	ldw	r3,-28(fp)
 3247544:	e0bffa17 	ldw	r2,-24(fp)
 3247548:	1887883a 	add	r3,r3,r2
 324754c:	e0bff817 	ldw	r2,-32(fp)
 3247550:	10c0042e 	bgeu	r2,r3,3247564 <md_fread+0xa8>
      bcount = ((u_long)file_size - location);
 3247554:	e0bff817 	ldw	r2,-32(fp)
 3247558:	e0fff917 	ldw	r3,-28(fp)
 324755c:	10c5c83a 	sub	r2,r2,r3
 3247560:	e0bffa15 	stw	r2,-24(fp)

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 3247564:	e0fff917 	ldw	r3,-28(fp)
 3247568:	e0bff817 	ldw	r2,-32(fp)
 324756c:	1880072e 	bgeu	r3,r2,324758c <md_fread+0xd0>
 3247570:	e0bffa17 	ldw	r2,-24(fp)
 3247574:	10bfffec 	andhi	r2,r2,65535
 3247578:	1004c03a 	cmpne	r2,r2,zero
 324757c:	1000031e 	bne	r2,zero,324758c <md_fread+0xd0>
 3247580:	e0bffa17 	ldw	r2,-24(fp)
 3247584:	1004c03a 	cmpne	r2,r2,zero
 3247588:	1000021e 	bne	r2,zero,3247594 <md_fread+0xd8>
      (bcount  & 0xFFFF0000) ||
      (bcount == 0))
   {
      return 0;
 324758c:	e03fff15 	stw	zero,-4(fp)
 3247590:	00002406 	br	3247624 <md_fread+0x168>
   /* Use VF_NODATA if memory devices have a size, but no
      data. This can be used to measure file read speed
      without introducing an undefined data copy. */
   /* VF_NODATA is defined in ../h/vfsfiles.h */
   
   if (!(vfd->file->flags & VF_NODATA))
 3247594:	e0bffe17 	ldw	r2,-8(fp)
 3247598:	10800117 	ldw	r2,4(r2)
 324759c:	1080058b 	ldhu	r2,22(r2)
 32475a0:	10bfffcc 	andi	r2,r2,65535
 32475a4:	10a0001c 	xori	r2,r2,32768
 32475a8:	10a00004 	addi	r2,r2,-32768
 32475ac:	1004803a 	cmplt	r2,r2,zero
 32475b0:	1000111e 	bne	r2,zero,32475f8 <md_fread+0x13c>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 32475b4:	e0bffe17 	ldw	r2,-8(fp)
 32475b8:	10800117 	ldw	r2,4(r2)
 32475bc:	10800103 	ldbu	r2,4(r2)
 32475c0:	10803fcc 	andi	r2,r2,255
 32475c4:	1080201c 	xori	r2,r2,128
 32475c8:	10bfe004 	addi	r2,r2,-128
 32475cc:	10801b58 	cmpnei	r2,r2,109
 32475d0:	1000091e 	bne	r2,zero,32475f8 <md_fread+0x13c>
         MEMCPY(buf, vfd->cmploc + MEMDEV_BASE, (unsigned)bcount);
 32475d4:	e0bffe17 	ldw	r2,-8(fp)
 32475d8:	10c00217 	ldw	r3,8(r2)
 32475dc:	00800834 	movhi	r2,32
 32475e0:	1887883a 	add	r3,r3,r2
 32475e4:	e0bffb17 	ldw	r2,-20(fp)
 32475e8:	1009883a 	mov	r4,r2
 32475ec:	180b883a 	mov	r5,r3
 32475f0:	e1bffa17 	ldw	r6,-24(fp)
 32475f4:	3206ad00 	call	3206ad0 <memcpy>
         vfd->cmploc = (u_char *)cp;
      else     /* read wrapped memory, set pointer to EOF value */
         vfd->cmploc = (u_char*)(0xFFFFFFFF);  /* EOF */
   }
#else
   vfd->cmploc += bcount;  /* adjust location */
 32475f8:	e0bffe17 	ldw	r2,-8(fp)
 32475fc:	10c00217 	ldw	r3,8(r2)
 3247600:	e0bffa17 	ldw	r2,-24(fp)
 3247604:	1887883a 	add	r3,r3,r2
 3247608:	e0bffe17 	ldw	r2,-8(fp)
 324760c:	10c00215 	stw	r3,8(r2)
#endif
   
   return ((int)bcount/size);
 3247610:	e0bffa17 	ldw	r2,-24(fp)
 3247614:	1009883a 	mov	r4,r2
 3247618:	e17ffc17 	ldw	r5,-16(fp)
 324761c:	32047c00 	call	32047c0 <__udivsi3>
 3247620:	e0bfff15 	stw	r2,-4(fp)
 3247624:	e0bfff17 	ldw	r2,-4(fp)
}
 3247628:	e037883a 	mov	sp,fp
 324762c:	dfc00117 	ldw	ra,4(sp)
 3247630:	df000017 	ldw	fp,0(sp)
 3247634:	dec00204 	addi	sp,sp,8
 3247638:	f800283a 	ret

0324763c <md_fwrite>:
 * RETURNS: 
 */

int    
md_fwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 324763c:	defffa04 	addi	sp,sp,-24
 3247640:	df000515 	stw	fp,20(sp)
 3247644:	df000504 	addi	fp,sp,20
 3247648:	e13ffb15 	stw	r4,-20(fp)
 324764c:	e17ffc15 	stw	r5,-16(fp)
 3247650:	e1bffd15 	stw	r6,-12(fp)
 3247654:	e1fffe15 	stw	r7,-8(fp)
   if (vfd->file->name[0] == 'm')   /* memory device */
 3247658:	e0bffe17 	ldw	r2,-8(fp)
 324765c:	10800117 	ldw	r2,4(r2)
 3247660:	10800103 	ldbu	r2,4(r2)
 3247664:	10803fcc 	andi	r2,r2,255
 3247668:	1080201c 	xori	r2,r2,128
 324766c:	10bfe004 	addi	r2,r2,-128
 3247670:	10801b58 	cmpnei	r2,r2,109
 3247674:	1000021e 	bne	r2,zero,3247680 <md_fwrite+0x44>
      return 0;   /* not writable device */
 3247678:	e03fff15 	stw	zero,-4(fp)
 324767c:	00000a06 	br	32476a8 <md_fwrite+0x6c>

   vfd->cmploc += (items * size);   /* adjust location */
 3247680:	e0bffe17 	ldw	r2,-8(fp)
 3247684:	11000217 	ldw	r4,8(r2)
 3247688:	e0fffd17 	ldw	r3,-12(fp)
 324768c:	e0bffc17 	ldw	r2,-16(fp)
 3247690:	1885383a 	mul	r2,r3,r2
 3247694:	2087883a 	add	r3,r4,r2
 3247698:	e0bffe17 	ldw	r2,-8(fp)
 324769c:	10c00215 	stw	r3,8(r2)

   USE_ARG(buf);     /* supress compiler warnings */

   return (items);
 32476a0:	e0bffd17 	ldw	r2,-12(fp)
 32476a4:	e0bfff15 	stw	r2,-4(fp)
 32476a8:	e0bfff17 	ldw	r2,-4(fp)
}
 32476ac:	e037883a 	mov	sp,fp
 32476b0:	df000017 	ldw	fp,0(sp)
 32476b4:	dec00104 	addi	sp,sp,4
 32476b8:	f800283a 	ret

032476bc <md_fseek>:
 * RETURNS: 
 */

int
md_fseek(VFILE * vfd, long offset, int mode)
{
 32476bc:	defffc04 	addi	sp,sp,-16
 32476c0:	df000315 	stw	fp,12(sp)
 32476c4:	df000304 	addi	fp,sp,12
 32476c8:	e13ffd15 	stw	r4,-12(fp)
 32476cc:	e17ffe15 	stw	r5,-8(fp)
 32476d0:	e1bfff15 	stw	r6,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   USE_ARG(offset);
   USE_ARG(mode);
   return 0;
 32476d4:	0005883a 	mov	r2,zero
}
 32476d8:	e037883a 	mov	sp,fp
 32476dc:	df000017 	ldw	fp,0(sp)
 32476e0:	dec00104 	addi	sp,sp,4
 32476e4:	f800283a 	ret

032476e8 <md_ftell>:
 * RETURNS: 
 */

long   
md_ftell(VFILE * vfd)
{
 32476e8:	defffe04 	addi	sp,sp,-8
 32476ec:	df000115 	stw	fp,4(sp)
 32476f0:	df000104 	addi	fp,sp,4
 32476f4:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   return MEMDEV_SIZE;
 32476f8:	00800834 	movhi	r2,32
}
 32476fc:	e037883a 	mov	sp,fp
 3247700:	df000017 	ldw	fp,0(sp)
 3247704:	dec00104 	addi	sp,sp,4
 3247708:	f800283a 	ret

0324770c <md_fgetc>:
 * RETURNS: 
 */

int    
md_fgetc(VFILE * vfd)
{
 324770c:	defffb04 	addi	sp,sp,-20
 3247710:	df000415 	stw	fp,16(sp)
 3247714:	df000404 	addi	fp,sp,16
 3247718:	e13ffe15 	stw	r4,-8(fp)
   unsigned location;   /* current offset infile */
   int   retval   =  0;
 324771c:	e03ffc15 	stw	zero,-16(fp)

   location = vfd->cmploc - vfd->file->data;
 3247720:	e0bffe17 	ldw	r2,-8(fp)
 3247724:	10800217 	ldw	r2,8(r2)
 3247728:	1007883a 	mov	r3,r2
 324772c:	e0bffe17 	ldw	r2,-8(fp)
 3247730:	10800117 	ldw	r2,4(r2)
 3247734:	10800617 	ldw	r2,24(r2)
 3247738:	1885c83a 	sub	r2,r3,r2
 324773c:	e0bffd15 	stw	r2,-12(fp)
   if (location >= vfd->file->real_size)     /* at end of file? */
 3247740:	e0bffe17 	ldw	r2,-8(fp)
 3247744:	10800117 	ldw	r2,4(r2)
 3247748:	10c00717 	ldw	r3,28(r2)
 324774c:	e0bffd17 	ldw	r2,-12(fp)
 3247750:	10c00336 	bltu	r2,r3,3247760 <md_fgetc+0x54>
      return EOF;
 3247754:	00bfffc4 	movi	r2,-1
 3247758:	e0bfff15 	stw	r2,-4(fp)
 324775c:	00001c06 	br	32477d0 <md_fgetc+0xc4>

   if (!(vfd->file->flags & VF_NODATA))
 3247760:	e0bffe17 	ldw	r2,-8(fp)
 3247764:	10800117 	ldw	r2,4(r2)
 3247768:	1080058b 	ldhu	r2,22(r2)
 324776c:	10bfffcc 	andi	r2,r2,65535
 3247770:	10a0001c 	xori	r2,r2,32768
 3247774:	10a00004 	addi	r2,r2,-32768
 3247778:	1004803a 	cmplt	r2,r2,zero
 324777c:	10000d1e 	bne	r2,zero,32477b4 <md_fgetc+0xa8>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 3247780:	e0bffe17 	ldw	r2,-8(fp)
 3247784:	10800117 	ldw	r2,4(r2)
 3247788:	10800103 	ldbu	r2,4(r2)
 324778c:	10803fcc 	andi	r2,r2,255
 3247790:	1080201c 	xori	r2,r2,128
 3247794:	10bfe004 	addi	r2,r2,-128
 3247798:	10801b58 	cmpnei	r2,r2,109
 324779c:	1000051e 	bne	r2,zero,32477b4 <md_fgetc+0xa8>
         retval = (int)(*vfd->cmploc) & 0xFF ;
 32477a0:	e0bffe17 	ldw	r2,-8(fp)
 32477a4:	10800217 	ldw	r2,8(r2)
 32477a8:	10800003 	ldbu	r2,0(r2)
 32477ac:	10803fcc 	andi	r2,r2,255
 32477b0:	e0bffc15 	stw	r2,-16(fp)
   }

   /* else for null device or files without data, 
      use whatever is in retval */

   vfd->cmploc++;    /* adjust location */
 32477b4:	e0bffe17 	ldw	r2,-8(fp)
 32477b8:	10800217 	ldw	r2,8(r2)
 32477bc:	10c00044 	addi	r3,r2,1
 32477c0:	e0bffe17 	ldw	r2,-8(fp)
 32477c4:	10c00215 	stw	r3,8(r2)
   return retval;
 32477c8:	e0bffc17 	ldw	r2,-16(fp)
 32477cc:	e0bfff15 	stw	r2,-4(fp)
 32477d0:	e0bfff17 	ldw	r2,-4(fp)
}
 32477d4:	e037883a 	mov	sp,fp
 32477d8:	df000017 	ldw	fp,0(sp)
 32477dc:	dec00104 	addi	sp,sp,4
 32477e0:	f800283a 	ret

032477e4 <md_unlink>:
 * RETURNS: 
 */

int    
md_unlink(char * filename)
{
 32477e4:	defffe04 	addi	sp,sp,-8
 32477e8:	df000115 	stw	fp,4(sp)
 32477ec:	df000104 	addi	fp,sp,4
 32477f0:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(filename);     /* supress compiler warnings */
   return 0;
 32477f4:	0005883a 	mov	r2,zero
}
 32477f8:	e037883a 	mov	sp,fp
 32477fc:	df000017 	ldw	fp,0(sp)
 3247800:	dec00104 	addi	sp,sp,4
 3247804:	f800283a 	ret

03247808 <parse_ipad>:

char *   
parse_ipad(ip_addr * ipout,   /* pointer to IP address to set */
   unsigned *  sbits,      /* default subnet bit number */
   char *   stringin)      /* buffer with ascii to parse */
{
 3247808:	defff504 	addi	sp,sp,-44
 324780c:	dfc00a15 	stw	ra,40(sp)
 3247810:	df000915 	stw	fp,36(sp)
 3247814:	df000904 	addi	fp,sp,36
 3247818:	e13ffc15 	stw	r4,-16(fp)
 324781c:	e17ffd15 	stw	r5,-12(fp)
 3247820:	e1bffe15 	stw	r6,-8(fp)
   char *   cp;
   int   dots  =  0; /* periods imbedded in input string */
 3247824:	e03ff915 	stw	zero,-28(fp)
   union   
   {
      u_char   c[4];
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";
 3247828:	0080c974 	movhi	r2,805
 324782c:	10817d04 	addi	r2,r2,1524
 3247830:	e0bff715 	stw	r2,-36(fp)

   cp = stringin;
 3247834:	e0bffe17 	ldw	r2,-8(fp)
 3247838:	e0bffa15 	stw	r2,-24(fp)
   while (*cp)
 324783c:	00002606 	br	32478d8 <parse_ipad+0xd0>
   {
      if (*cp > '9' || *cp < '.' || *cp == '/')
 3247840:	e0bffa17 	ldw	r2,-24(fp)
 3247844:	10800003 	ldbu	r2,0(r2)
 3247848:	10803fcc 	andi	r2,r2,255
 324784c:	1080201c 	xori	r2,r2,128
 3247850:	10bfe004 	addi	r2,r2,-128
 3247854:	10800e88 	cmpgei	r2,r2,58
 3247858:	10000e1e 	bne	r2,zero,3247894 <parse_ipad+0x8c>
 324785c:	e0bffa17 	ldw	r2,-24(fp)
 3247860:	10800003 	ldbu	r2,0(r2)
 3247864:	10803fcc 	andi	r2,r2,255
 3247868:	1080201c 	xori	r2,r2,128
 324786c:	10bfe004 	addi	r2,r2,-128
 3247870:	10800b90 	cmplti	r2,r2,46
 3247874:	1000071e 	bne	r2,zero,3247894 <parse_ipad+0x8c>
 3247878:	e0bffa17 	ldw	r2,-24(fp)
 324787c:	10800003 	ldbu	r2,0(r2)
 3247880:	10803fcc 	andi	r2,r2,255
 3247884:	1080201c 	xori	r2,r2,128
 3247888:	10bfe004 	addi	r2,r2,-128
 324788c:	10800bd8 	cmpnei	r2,r2,47
 3247890:	1000041e 	bne	r2,zero,32478a4 <parse_ipad+0x9c>
         return("all chars must be digits (0-9) or dots (.)");
 3247894:	0080c974 	movhi	r2,805
 3247898:	10818604 	addi	r2,r2,1560
 324789c:	e0bfff15 	stw	r2,-4(fp)
 32478a0:	00009a06 	br	3247b0c <parse_ipad+0x304>
      if (*cp == '.')dots++;
 32478a4:	e0bffa17 	ldw	r2,-24(fp)
 32478a8:	10800003 	ldbu	r2,0(r2)
 32478ac:	10803fcc 	andi	r2,r2,255
 32478b0:	1080201c 	xori	r2,r2,128
 32478b4:	10bfe004 	addi	r2,r2,-128
 32478b8:	10800b98 	cmpnei	r2,r2,46
 32478bc:	1000031e 	bne	r2,zero,32478cc <parse_ipad+0xc4>
 32478c0:	e0bff917 	ldw	r2,-28(fp)
 32478c4:	10800044 	addi	r2,r2,1
 32478c8:	e0bff915 	stw	r2,-28(fp)
         cp++;
 32478cc:	e0bffa17 	ldw	r2,-24(fp)
 32478d0:	10800044 	addi	r2,r2,1
 32478d4:	e0bffa15 	stw	r2,-24(fp)
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";

   cp = stringin;
   while (*cp)
 32478d8:	e0bffa17 	ldw	r2,-24(fp)
 32478dc:	10800003 	ldbu	r2,0(r2)
 32478e0:	10803fcc 	andi	r2,r2,255
 32478e4:	1080201c 	xori	r2,r2,128
 32478e8:	10bfe004 	addi	r2,r2,-128
 32478ec:	1004c03a 	cmpne	r2,r2,zero
 32478f0:	103fd31e 	bne	r2,zero,3247840 <parse_ipad+0x38>
         return("all chars must be digits (0-9) or dots (.)");
      if (*cp == '.')dots++;
         cp++;
   }

   if ( dots < 1 || dots > 3 )
 32478f4:	e0bff917 	ldw	r2,-28(fp)
 32478f8:	10800050 	cmplti	r2,r2,1
 32478fc:	1000031e 	bne	r2,zero,324790c <parse_ipad+0x104>
 3247900:	e0bff917 	ldw	r2,-28(fp)
 3247904:	10800110 	cmplti	r2,r2,4
 3247908:	1000041e 	bne	r2,zero,324791c <parse_ipad+0x114>
      return("string must contain 1 - 3 dots (.)");
 324790c:	0080c974 	movhi	r2,805
 3247910:	10819104 	addi	r2,r2,1604
 3247914:	e0bfff15 	stw	r2,-4(fp)
 3247918:	00007c06 	br	3247b0c <parse_ipad+0x304>

   cp = stringin;
 324791c:	e0bffe17 	ldw	r2,-8(fp)
 3247920:	e0bffa15 	stw	r2,-24(fp)
   if ((number = atoi(cp)) > 255)   /* set net number */
 3247924:	e13ffa17 	ldw	r4,-24(fp)
 3247928:	324bc380 	call	324bc38 <atoi>
 324792c:	e0bff815 	stw	r2,-32(fp)
 3247930:	e0bff817 	ldw	r2,-32(fp)
 3247934:	10804010 	cmplti	r2,r2,256
 3247938:	1000031e 	bne	r2,zero,3247948 <parse_ipad+0x140>
      return(toobig);
 324793c:	e0bff717 	ldw	r2,-36(fp)
 3247940:	e0bfff15 	stw	r2,-4(fp)
 3247944:	00007106 	br	3247b0c <parse_ipad+0x304>

   retval.c[0] = (u_char)number;
 3247948:	e0bff817 	ldw	r2,-32(fp)
 324794c:	e0bffb05 	stb	r2,-20(fp)

   while (*cp != '.')cp++; /* find dot (end of number) */
 3247950:	00000306 	br	3247960 <parse_ipad+0x158>
 3247954:	e0bffa17 	ldw	r2,-24(fp)
 3247958:	10800044 	addi	r2,r2,1
 324795c:	e0bffa15 	stw	r2,-24(fp)
 3247960:	e0bffa17 	ldw	r2,-24(fp)
 3247964:	10800003 	ldbu	r2,0(r2)
 3247968:	10803fcc 	andi	r2,r2,255
 324796c:	1080201c 	xori	r2,r2,128
 3247970:	10bfe004 	addi	r2,r2,-128
 3247974:	10800b98 	cmpnei	r2,r2,46
 3247978:	103ff61e 	bne	r2,zero,3247954 <parse_ipad+0x14c>
      cp++;             /* point past dot */
 324797c:	e0bffa17 	ldw	r2,-24(fp)
 3247980:	10800044 	addi	r2,r2,1
 3247984:	e0bffa15 	stw	r2,-24(fp)

   if (dots == 1 || dots == 2) retval.c[1] = 0;
 3247988:	e0bff917 	ldw	r2,-28(fp)
 324798c:	10800060 	cmpeqi	r2,r2,1
 3247990:	1000031e 	bne	r2,zero,32479a0 <parse_ipad+0x198>
 3247994:	e0bff917 	ldw	r2,-28(fp)
 3247998:	10800098 	cmpnei	r2,r2,2
 324799c:	1000021e 	bne	r2,zero,32479a8 <parse_ipad+0x1a0>
 32479a0:	e03ffb45 	stb	zero,-19(fp)
 32479a4:	00001906 	br	3247a0c <parse_ipad+0x204>
      else
   {
      number = atoi(cp);
 32479a8:	e13ffa17 	ldw	r4,-24(fp)
 32479ac:	324bc380 	call	324bc38 <atoi>
 32479b0:	e0bff815 	stw	r2,-32(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 32479b4:	00000306 	br	32479c4 <parse_ipad+0x1bc>
 32479b8:	e0bffa17 	ldw	r2,-24(fp)
 32479bc:	10800044 	addi	r2,r2,1
 32479c0:	e0bffa15 	stw	r2,-24(fp)
 32479c4:	e0bffa17 	ldw	r2,-24(fp)
 32479c8:	10800003 	ldbu	r2,0(r2)
 32479cc:	10803fcc 	andi	r2,r2,255
 32479d0:	1080201c 	xori	r2,r2,128
 32479d4:	10bfe004 	addi	r2,r2,-128
 32479d8:	10800b98 	cmpnei	r2,r2,46
 32479dc:	103ff61e 	bne	r2,zero,32479b8 <parse_ipad+0x1b0>
         cp++;             /* point past dot */
 32479e0:	e0bffa17 	ldw	r2,-24(fp)
 32479e4:	10800044 	addi	r2,r2,1
 32479e8:	e0bffa15 	stw	r2,-24(fp)
      if (number > 255) return(toobig);
 32479ec:	e0bff817 	ldw	r2,-32(fp)
 32479f0:	10804010 	cmplti	r2,r2,256
 32479f4:	1000031e 	bne	r2,zero,3247a04 <parse_ipad+0x1fc>
 32479f8:	e0bff717 	ldw	r2,-36(fp)
 32479fc:	e0bfff15 	stw	r2,-4(fp)
 3247a00:	00004206 	br	3247b0c <parse_ipad+0x304>
         retval.c[1] = (u_char)number;
 3247a04:	e0bff817 	ldw	r2,-32(fp)
 3247a08:	e0bffb45 	stb	r2,-19(fp)
   }

   if (dots == 1) retval.c[2] = 0;
 3247a0c:	e0bff917 	ldw	r2,-28(fp)
 3247a10:	10800058 	cmpnei	r2,r2,1
 3247a14:	1000021e 	bne	r2,zero,3247a20 <parse_ipad+0x218>
 3247a18:	e03ffb85 	stb	zero,-18(fp)
 3247a1c:	00001906 	br	3247a84 <parse_ipad+0x27c>
      else
   {
      number = atoi(cp);
 3247a20:	e13ffa17 	ldw	r4,-24(fp)
 3247a24:	324bc380 	call	324bc38 <atoi>
 3247a28:	e0bff815 	stw	r2,-32(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 3247a2c:	00000306 	br	3247a3c <parse_ipad+0x234>
 3247a30:	e0bffa17 	ldw	r2,-24(fp)
 3247a34:	10800044 	addi	r2,r2,1
 3247a38:	e0bffa15 	stw	r2,-24(fp)
 3247a3c:	e0bffa17 	ldw	r2,-24(fp)
 3247a40:	10800003 	ldbu	r2,0(r2)
 3247a44:	10803fcc 	andi	r2,r2,255
 3247a48:	1080201c 	xori	r2,r2,128
 3247a4c:	10bfe004 	addi	r2,r2,-128
 3247a50:	10800b98 	cmpnei	r2,r2,46
 3247a54:	103ff61e 	bne	r2,zero,3247a30 <parse_ipad+0x228>
         cp++;             /* point past dot */
 3247a58:	e0bffa17 	ldw	r2,-24(fp)
 3247a5c:	10800044 	addi	r2,r2,1
 3247a60:	e0bffa15 	stw	r2,-24(fp)
      if (number > 255) return(toobig);
 3247a64:	e0bff817 	ldw	r2,-32(fp)
 3247a68:	10804010 	cmplti	r2,r2,256
 3247a6c:	1000031e 	bne	r2,zero,3247a7c <parse_ipad+0x274>
 3247a70:	e0bff717 	ldw	r2,-36(fp)
 3247a74:	e0bfff15 	stw	r2,-4(fp)
 3247a78:	00002406 	br	3247b0c <parse_ipad+0x304>
         retval.c[2] = (u_char)number;
 3247a7c:	e0bff817 	ldw	r2,-32(fp)
 3247a80:	e0bffb85 	stb	r2,-18(fp)
   }

   if ((number = atoi(cp)) > 255)
 3247a84:	e13ffa17 	ldw	r4,-24(fp)
 3247a88:	324bc380 	call	324bc38 <atoi>
 3247a8c:	e0bff815 	stw	r2,-32(fp)
 3247a90:	e0bff817 	ldw	r2,-32(fp)
 3247a94:	10804010 	cmplti	r2,r2,256
 3247a98:	1000031e 	bne	r2,zero,3247aa8 <parse_ipad+0x2a0>
      return(toobig);
 3247a9c:	e0bff717 	ldw	r2,-36(fp)
 3247aa0:	e0bfff15 	stw	r2,-4(fp)
 3247aa4:	00001906 	br	3247b0c <parse_ipad+0x304>
   retval.c[3] = (u_char)number;
 3247aa8:	e0bff817 	ldw	r2,-32(fp)
 3247aac:	e0bffbc5 	stb	r2,-17(fp)

   if (retval.c[0] < 128) *sbits = 8;
 3247ab0:	e0bffb03 	ldbu	r2,-20(fp)
 3247ab4:	10803fcc 	andi	r2,r2,255
 3247ab8:	10802028 	cmpgeui	r2,r2,128
 3247abc:	1000041e 	bne	r2,zero,3247ad0 <parse_ipad+0x2c8>
 3247ac0:	e0fffd17 	ldw	r3,-12(fp)
 3247ac4:	00800204 	movi	r2,8
 3247ac8:	18800015 	stw	r2,0(r3)
 3247acc:	00000b06 	br	3247afc <parse_ipad+0x2f4>
      else if(retval.c[0] < 192) *sbits = 16;
 3247ad0:	e0bffb03 	ldbu	r2,-20(fp)
 3247ad4:	10803fcc 	andi	r2,r2,255
 3247ad8:	10803028 	cmpgeui	r2,r2,192
 3247adc:	1000041e 	bne	r2,zero,3247af0 <parse_ipad+0x2e8>
 3247ae0:	e0fffd17 	ldw	r3,-12(fp)
 3247ae4:	00800404 	movi	r2,16
 3247ae8:	18800015 	stw	r2,0(r3)
 3247aec:	00000306 	br	3247afc <parse_ipad+0x2f4>
      else *sbits = 24;
 3247af0:	e0fffd17 	ldw	r3,-12(fp)
 3247af4:	00800604 	movi	r2,24
 3247af8:	18800015 	stw	r2,0(r3)

      *ipout = retval.l;      /* everything went OK, return number */
 3247afc:	e0fffb17 	ldw	r3,-20(fp)
 3247b00:	e0bffc17 	ldw	r2,-16(fp)
 3247b04:	10c00015 	stw	r3,0(r2)
   return(NULL);        /* return OK code (no error string) */
 3247b08:	e03fff15 	stw	zero,-4(fp)
 3247b0c:	e0bfff17 	ldw	r2,-4(fp)
}
 3247b10:	e037883a 	mov	sp,fp
 3247b14:	dfc00117 	ldw	ra,4(sp)
 3247b18:	df000017 	ldw	fp,0(sp)
 3247b1c:	dec00204 	addi	sp,sp,8
 3247b20:	f800283a 	ret

03247b24 <inet_addr>:
 * RETURNS: u_long ipaddr
 */

u_long 
inet_addr(char FAR * str)
{
 3247b24:	defffa04 	addi	sp,sp,-24
 3247b28:	dfc00515 	stw	ra,20(sp)
 3247b2c:	df000415 	stw	fp,16(sp)
 3247b30:	df000404 	addi	fp,sp,16
 3247b34:	e13ffe15 	stw	r4,-8(fp)
    * we need to make the conversion. Usually this function will be 
    * used for debugging, so I think we can bear the STRCPY overhead.
    */
   static char nearBuf[30];

   strcpy((char FAR *)nearBuf,str);
 3247b38:	0100c974 	movhi	r4,805
 3247b3c:	21159d04 	addi	r4,r4,22132
 3247b40:	e17ffe17 	ldw	r5,-8(fp)
 3247b44:	324bd340 	call	324bd34 <strcpy>
   if ( parse_ipad(&ipaddr,&bits,nearBuf) == NULL )
 3247b48:	e17ffd04 	addi	r5,fp,-12
 3247b4c:	e13ffc04 	addi	r4,fp,-16
 3247b50:	0180c974 	movhi	r6,805
 3247b54:	31959d04 	addi	r6,r6,22132
 3247b58:	32478080 	call	3247808 <parse_ipad>
 3247b5c:	1004c03a 	cmpne	r2,r2,zero
 3247b60:	1000031e 	bne	r2,zero,3247b70 <inet_addr+0x4c>
   {
      return ipaddr ;
 3247b64:	e0bffc17 	ldw	r2,-16(fp)
 3247b68:	e0bfff15 	stw	r2,-4(fp)
 3247b6c:	00000106 	br	3247b74 <inet_addr+0x50>
   }
   else
   {
      return (u_long)NULL ;
 3247b70:	e03fff15 	stw	zero,-4(fp)
 3247b74:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 3247b78:	e037883a 	mov	sp,fp
 3247b7c:	dfc00117 	ldw	ra,4(sp)
 3247b80:	df000017 	ldw	fp,0(sp)
 3247b84:	dec00204 	addi	sp,sp,8
 3247b88:	f800283a 	ret

03247b8c <hextoa>:
 * RETURNS: character 0-9 or A-F
 */

char
hextoa(int val)
{
 3247b8c:	defffd04 	addi	sp,sp,-12
 3247b90:	df000215 	stw	fp,8(sp)
 3247b94:	df000204 	addi	fp,sp,8
 3247b98:	e13ffe15 	stw	r4,-8(fp)
   val &= 0x0f;
 3247b9c:	e0bffe17 	ldw	r2,-8(fp)
 3247ba0:	108003cc 	andi	r2,r2,15
 3247ba4:	e0bffe15 	stw	r2,-8(fp)
   if(val < 10)
 3247ba8:	e0bffe17 	ldw	r2,-8(fp)
 3247bac:	10800288 	cmpgei	r2,r2,10
 3247bb0:	1000071e 	bne	r2,zero,3247bd0 <hextoa+0x44>
      return (char)(val + '0');
 3247bb4:	e0bffe17 	ldw	r2,-8(fp)
 3247bb8:	10800c04 	addi	r2,r2,48
 3247bbc:	10803fcc 	andi	r2,r2,255
 3247bc0:	1080201c 	xori	r2,r2,128
 3247bc4:	10bfe004 	addi	r2,r2,-128
 3247bc8:	e0bfff15 	stw	r2,-4(fp)
 3247bcc:	00000606 	br	3247be8 <hextoa+0x5c>
   else
      return (char)(val + 55);   /* converts 10-15 -> "A-F" */
 3247bd0:	e0bffe17 	ldw	r2,-8(fp)
 3247bd4:	10800dc4 	addi	r2,r2,55
 3247bd8:	10803fcc 	andi	r2,r2,255
 3247bdc:	1080201c 	xori	r2,r2,128
 3247be0:	10bfe004 	addi	r2,r2,-128
 3247be4:	e0bfff15 	stw	r2,-4(fp)
 3247be8:	e0bfff17 	ldw	r2,-4(fp)
}
 3247bec:	e037883a 	mov	sp,fp
 3247bf0:	df000017 	ldw	fp,0(sp)
 3247bf4:	dec00104 	addi	sp,sp,4
 3247bf8:	f800283a 	ret

03247bfc <inet_pton>:

char * pton_error = "";

int
inet_pton(int af, const char * src, void * dst)
{
 3247bfc:	defff704 	addi	sp,sp,-36
 3247c00:	dfc00815 	stw	ra,32(sp)
 3247c04:	df000715 	stw	fp,28(sp)
 3247c08:	df000704 	addi	fp,sp,28
 3247c0c:	e13ffc15 	stw	r4,-16(fp)
 3247c10:	e17ffd15 	stw	r5,-12(fp)
 3247c14:	e1bffe15 	stw	r6,-8(fp)
   int            words;   /* count of words written to dest */
#endif

#if defined(IP_V4) || defined(MINI_IP)
   /* RFC 2133 wants us to support both types of address */
   if(af == AF_INET)    /* wants a v4 address */
 3247c18:	e0bffc17 	ldw	r2,-16(fp)
 3247c1c:	10800098 	cmpnei	r2,r2,2
 3247c20:	10001a1e 	bne	r2,zero,3247c8c <inet_pton+0x90>
   {
      u_long ip4addr;
      unsigned sbits;
      char * err;
      
      err = parse_ipad(&ip4addr, &sbits, (char *) src);
 3247c24:	e13ffa04 	addi	r4,fp,-24
 3247c28:	e17ffb04 	addi	r5,fp,-20
 3247c2c:	e1bffd17 	ldw	r6,-12(fp)
 3247c30:	32478080 	call	3247808 <parse_ipad>
 3247c34:	e0bff915 	stw	r2,-28(fp)
      if(err == NULL)
 3247c38:	e0bff917 	ldw	r2,-28(fp)
 3247c3c:	1004c03a 	cmpne	r2,r2,zero
 3247c40:	10000c1e 	bne	r2,zero,3247c74 <inet_pton+0x78>
      {
         /* copy the parsed address into caller's buffer, and 
          * return success
          */
         MEMCPY(dst, &ip4addr, sizeof (u_long));
 3247c44:	e13ffe17 	ldw	r4,-8(fp)
 3247c48:	e0fffa04 	addi	r3,fp,-24
 3247c4c:	18800003 	ldbu	r2,0(r3)
 3247c50:	20800005 	stb	r2,0(r4)
 3247c54:	18800043 	ldbu	r2,1(r3)
 3247c58:	20800045 	stb	r2,1(r4)
 3247c5c:	18800083 	ldbu	r2,2(r3)
 3247c60:	20800085 	stb	r2,2(r4)
 3247c64:	188000c3 	ldbu	r2,3(r3)
 3247c68:	208000c5 	stb	r2,3(r4)
         return 0;
 3247c6c:	e03fff15 	stw	zero,-4(fp)
 3247c70:	00000706 	br	3247c90 <inet_pton+0x94>
      }
      else
      {
         /* return failure */
         pton_error = "IPv4 address parse failure";
 3247c74:	0080c974 	movhi	r2,805
 3247c78:	10819b04 	addi	r2,r2,1644
 3247c7c:	d0a05015 	stw	r2,-32448(gp)
         return 1;
 3247c80:	00800044 	movi	r2,1
 3247c84:	e0bfff15 	stw	r2,-4(fp)
 3247c88:	00000106 	br	3247c90 <inet_pton+0x94>
      pton_error = "too short - missing colon?";
      return 1;
   }
   
#endif /* IP_V6 */   
   return 0;
 3247c8c:	e03fff15 	stw	zero,-4(fp)
 3247c90:	e0bfff17 	ldw	r2,-4(fp)
}
 3247c94:	e037883a 	mov	sp,fp
 3247c98:	dfc00117 	ldw	ra,4(sp)
 3247c9c:	df000017 	ldw	fp,0(sp)
 3247ca0:	dec00204 	addi	sp,sp,8
 3247ca4:	f800283a 	ret

03247ca8 <inet_ntop>:
 * address output (40 bytes).
 */

const char *
inet_ntop(int af, const void *addr, char *str, size_t size)
{
 3247ca8:	defff704 	addi	sp,sp,-36
 3247cac:	dfc00815 	stw	ra,32(sp)
 3247cb0:	df000715 	stw	fp,28(sp)
 3247cb4:	df000704 	addi	fp,sp,28
 3247cb8:	e13ffb15 	stw	r4,-20(fp)
 3247cbc:	e17ffc15 	stw	r5,-16(fp)
 3247cc0:	e1bffd15 	stw	r6,-12(fp)
 3247cc4:	e1fffe15 	stw	r7,-8(fp)
   char *cp;

#if defined(IP_V4) || defined(MINI_IP)
   if (af == AF_INET)
 3247cc8:	e0bffb17 	ldw	r2,-20(fp)
 3247ccc:	10800098 	cmpnei	r2,r2,2
 3247cd0:	1000111e 	bne	r2,zero,3247d18 <inet_ntop+0x70>
   {
      u_long   ip4addr;

      ip4addr = *(u_long*)addr;
 3247cd4:	e0bffc17 	ldw	r2,-16(fp)
 3247cd8:	10800017 	ldw	r2,0(r2)
 3247cdc:	e0bff915 	stw	r2,-28(fp)
      cp = print_ipad(ip4addr);
 3247ce0:	e13ff917 	ldw	r4,-28(fp)
 3247ce4:	3225fb40 	call	3225fb4 <print_ipad>
 3247ce8:	e0bffa15 	stw	r2,-24(fp)
      if (strlen(cp) < size)
 3247cec:	e13ffa17 	ldw	r4,-24(fp)
 3247cf0:	32084480 	call	3208448 <strlen>
 3247cf4:	1007883a 	mov	r3,r2
 3247cf8:	e0bffe17 	ldw	r2,-8(fp)
 3247cfc:	1880062e 	bgeu	r3,r2,3247d18 <inet_ntop+0x70>
      {
         strcpy(str, cp);
 3247d00:	e13ffd17 	ldw	r4,-12(fp)
 3247d04:	e17ffa17 	ldw	r5,-24(fp)
 3247d08:	324bd340 	call	324bd34 <strcpy>
         return (str);
 3247d0c:	e0bffd17 	ldw	r2,-12(fp)
 3247d10:	e0bfff15 	stw	r2,-4(fp)
 3247d14:	00000106 	br	3247d1c <inet_ntop+0x74>
         return (str);
      }
   }
#endif

   return ((const char *)NULL);
 3247d18:	e03fff15 	stw	zero,-4(fp)
 3247d1c:	e0bfff17 	ldw	r2,-4(fp)
}
 3247d20:	e037883a 	mov	sp,fp
 3247d24:	dfc00117 	ldw	ra,4(sp)
 3247d28:	df000017 	ldw	fp,0(sp)
 3247d2c:	dec00204 	addi	sp,sp,8
 3247d30:	f800283a 	ret

03247d34 <print46_addr>:
 *
 * RETURNS: Pointer to string with the address in readable format.
 */

char * print46_addr(struct sockaddr *ipaddr)
{
 3247d34:	defffb04 	addi	sp,sp,-20
 3247d38:	dfc00415 	stw	ra,16(sp)
 3247d3c:	df000315 	stw	fp,12(sp)
 3247d40:	df000304 	addi	fp,sp,12
 3247d44:	e13ffe15 	stw	r4,-8(fp)
   if (ipaddr->sa_family == AF_INET)
 3247d48:	e0bffe17 	ldw	r2,-8(fp)
 3247d4c:	1080000b 	ldhu	r2,0(r2)
 3247d50:	10bfffcc 	andi	r2,r2,65535
 3247d54:	10800098 	cmpnei	r2,r2,2
 3247d58:	1000071e 	bne	r2,zero,3247d78 <print46_addr+0x44>
   {
      struct sockaddr_in * addr = (struct sockaddr_in *)ipaddr;
 3247d5c:	e0bffe17 	ldw	r2,-8(fp)
 3247d60:	e0bffd15 	stw	r2,-12(fp)
      return print_ipad(addr->sin_addr.s_addr);
 3247d64:	e0bffd17 	ldw	r2,-12(fp)
 3247d68:	11000117 	ldw	r4,4(r2)
 3247d6c:	3225fb40 	call	3225fb4 <print_ipad>
 3247d70:	e0bfff15 	stw	r2,-4(fp)
 3247d74:	00000106 	br	3247d7c <print46_addr+0x48>
      static char namebuf[46];  /* max len of IPv6 addr */
      return (char *)inet_ntop(AF_INET6,&addr->sin6_addr, namebuf, sizeof(namebuf));
   }
#endif

   return NULL;
 3247d78:	e03fff15 	stw	zero,-4(fp)
 3247d7c:	e0bfff17 	ldw	r2,-4(fp)
}
 3247d80:	e037883a 	mov	sp,fp
 3247d84:	dfc00117 	ldw	ra,4(sp)
 3247d88:	df000017 	ldw	fp,0(sp)
 3247d8c:	dec00204 	addi	sp,sp,8
 3247d90:	f800283a 	ret

03247d94 <inet46_addr>:
 *
 */

int 
inet46_addr(char * str, struct sockaddr *address)
{
 3247d94:	defffb04 	addi	sp,sp,-20
 3247d98:	dfc00415 	stw	ra,16(sp)
 3247d9c:	df000315 	stw	fp,12(sp)
 3247da0:	df000304 	addi	fp,sp,12
 3247da4:	e13ffe15 	stw	r4,-8(fp)
 3247da8:	e17fff15 	stw	r5,-4(fp)
   /* Read the IPv4/IPv6 address */
   address->sa_family = AF_INET; /* assume IPv4 address by default */
 3247dac:	e0ffff17 	ldw	r3,-4(fp)
 3247db0:	00800084 	movi	r2,2
 3247db4:	1880000d 	sth	r2,0(r3)

   if ((str[1] == '.') || (str[2] == '.') || (str[3] == '.'))
 3247db8:	e0bffe17 	ldw	r2,-8(fp)
 3247dbc:	10800044 	addi	r2,r2,1
 3247dc0:	10800003 	ldbu	r2,0(r2)
 3247dc4:	10803fcc 	andi	r2,r2,255
 3247dc8:	1080201c 	xori	r2,r2,128
 3247dcc:	10bfe004 	addi	r2,r2,-128
 3247dd0:	10800ba0 	cmpeqi	r2,r2,46
 3247dd4:	1000101e 	bne	r2,zero,3247e18 <inet46_addr+0x84>
 3247dd8:	e0bffe17 	ldw	r2,-8(fp)
 3247ddc:	10800084 	addi	r2,r2,2
 3247de0:	10800003 	ldbu	r2,0(r2)
 3247de4:	10803fcc 	andi	r2,r2,255
 3247de8:	1080201c 	xori	r2,r2,128
 3247dec:	10bfe004 	addi	r2,r2,-128
 3247df0:	10800ba0 	cmpeqi	r2,r2,46
 3247df4:	1000081e 	bne	r2,zero,3247e18 <inet46_addr+0x84>
 3247df8:	e0bffe17 	ldw	r2,-8(fp)
 3247dfc:	108000c4 	addi	r2,r2,3
 3247e00:	10800003 	ldbu	r2,0(r2)
 3247e04:	10803fcc 	andi	r2,r2,255
 3247e08:	1080201c 	xori	r2,r2,128
 3247e0c:	10bfe004 	addi	r2,r2,-128
 3247e10:	10800b98 	cmpnei	r2,r2,46
 3247e14:	10000a1e 	bne	r2,zero,3247e40 <inet46_addr+0xac>
   {
      struct sockaddr_in *addr = (struct sockaddr_in *)address;
 3247e18:	e0bfff17 	ldw	r2,-4(fp)
 3247e1c:	e0bffd15 	stw	r2,-12(fp)
      addr->sin_addr.s_addr = inet_addr(str);
 3247e20:	e13ffe17 	ldw	r4,-8(fp)
 3247e24:	3247b240 	call	3247b24 <inet_addr>
 3247e28:	1007883a 	mov	r3,r2
 3247e2c:	e0bffd17 	ldw	r2,-12(fp)
 3247e30:	10c00115 	stw	r3,4(r2)
      addr->sin_family = AF_INET;
 3247e34:	e0fffd17 	ldw	r3,-12(fp)
 3247e38:	00800084 	movi	r2,2
 3247e3c:	1880000d 	sth	r2,0(r3)
      inet_pton(AF_INET6, str, &addr->sin6_addr);
      addr->sin6_family = AF_INET6;
   }
#endif

   return 0;
 3247e40:	0005883a 	mov	r2,zero
}
 3247e44:	e037883a 	mov	sp,fp
 3247e48:	dfc00117 	ldw	ra,4(sp)
 3247e4c:	df000017 	ldw	fp,0(sp)
 3247e50:	dec00204 	addi	sp,sp,8
 3247e54:	f800283a 	ret

03247e58 <inet_setport>:
 *
 * RETURNS: -
 */

void inet_setport(struct sockaddr *addr,int port) 
{
 3247e58:	defffc04 	addi	sp,sp,-16
 3247e5c:	df000315 	stw	fp,12(sp)
 3247e60:	df000304 	addi	fp,sp,12
 3247e64:	e13ffe15 	stw	r4,-8(fp)
 3247e68:	e17fff15 	stw	r5,-4(fp)
   if (addr->sa_family == AF_INET)
 3247e6c:	e0bffe17 	ldw	r2,-8(fp)
 3247e70:	1080000b 	ldhu	r2,0(r2)
 3247e74:	10bfffcc 	andi	r2,r2,65535
 3247e78:	10800098 	cmpnei	r2,r2,2
 3247e7c:	10000f1e 	bne	r2,zero,3247ebc <inet_setport+0x64>
   {
      struct sockaddr_in *si = (struct sockaddr_in *)addr;
 3247e80:	e0bffe17 	ldw	r2,-8(fp)
 3247e84:	e0bffd15 	stw	r2,-12(fp)
      si->sin_port = htons(port);  
 3247e88:	e0bfff17 	ldw	r2,-4(fp)
 3247e8c:	1005d23a 	srai	r2,r2,8
 3247e90:	10803fcc 	andi	r2,r2,255
 3247e94:	1009883a 	mov	r4,r2
 3247e98:	e0bfff17 	ldw	r2,-4(fp)
 3247e9c:	1004923a 	slli	r2,r2,8
 3247ea0:	1007883a 	mov	r3,r2
 3247ea4:	00bfc004 	movi	r2,-256
 3247ea8:	1884703a 	and	r2,r3,r2
 3247eac:	2084b03a 	or	r2,r4,r2
 3247eb0:	1007883a 	mov	r3,r2
 3247eb4:	e0bffd17 	ldw	r2,-12(fp)
 3247eb8:	10c0008d 	sth	r3,2(r2)
      struct sockaddr_in6 *si = (struct sockaddr_in6 *)addr;
      si->sin6_port = htons(port);
   }
#endif

}
 3247ebc:	e037883a 	mov	sp,fp
 3247ec0:	df000017 	ldw	fp,0(sp)
 3247ec4:	dec00104 	addi	sp,sp,4
 3247ec8:	f800283a 	ret

03247ecc <convert_ip>:
 *Returns:
 *
 */

unsigned long convert_ip(const char *p)
{
 3247ecc:	defff804 	addi	sp,sp,-32
 3247ed0:	df000715 	stw	fp,28(sp)
 3247ed4:	df000704 	addi	fp,sp,28
 3247ed8:	e13ffe15 	stw	r4,-8(fp)
   const char *cp = p;
 3247edc:	e0bffe17 	ldw	r2,-8(fp)
 3247ee0:	e0bffc15 	stw	r2,-16(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
 3247ee4:	e0bffd04 	addi	r2,fp,-12
 3247ee8:	e0bffb15 	stw	r2,-20(fp)
   int n = 0;
 3247eec:	e03ffa15 	stw	zero,-24(fp)
   unsigned short v = 0;
 3247ef0:	e03ff90d 	sth	zero,-28(fp)
   dw = 0;
 3247ef4:	e03ffd15 	stw	zero,-12(fp)
   while(*cp)
 3247ef8:	00003306 	br	3247fc8 <convert_ip+0xfc>
   {
      if( *cp == '.')
 3247efc:	e0bffc17 	ldw	r2,-16(fp)
 3247f00:	10800003 	ldbu	r2,0(r2)
 3247f04:	10803fcc 	andi	r2,r2,255
 3247f08:	1080201c 	xori	r2,r2,128
 3247f0c:	10bfe004 	addi	r2,r2,-128
 3247f10:	10800b98 	cmpnei	r2,r2,46
 3247f14:	1000101e 	bne	r2,zero,3247f58 <convert_ip+0x8c>
      {
         lpb[n] = (unsigned char) v;
 3247f18:	e0bffa17 	ldw	r2,-24(fp)
 3247f1c:	1007883a 	mov	r3,r2
 3247f20:	e0bffb17 	ldw	r2,-20(fp)
 3247f24:	1887883a 	add	r3,r3,r2
 3247f28:	e0bff90b 	ldhu	r2,-28(fp)
 3247f2c:	18800005 	stb	r2,0(r3)
         v = 0;
 3247f30:	e03ff90d 	sth	zero,-28(fp)
         n++;
 3247f34:	e0bffa17 	ldw	r2,-24(fp)
 3247f38:	10800044 	addi	r2,r2,1
 3247f3c:	e0bffa15 	stw	r2,-24(fp)
         if(n > 3)
 3247f40:	e0bffa17 	ldw	r2,-24(fp)
 3247f44:	10800110 	cmplti	r2,r2,4
 3247f48:	10001c1e 	bne	r2,zero,3247fbc <convert_ip+0xf0>
         {
            return dw;
 3247f4c:	e0bffd17 	ldw	r2,-12(fp)
 3247f50:	e0bfff15 	stw	r2,-4(fp)
 3247f54:	00002b06 	br	3248004 <convert_ip+0x138>
         }
      }
      else if(((*cp >= '0') && (*cp <= '9')))
 3247f58:	e0bffc17 	ldw	r2,-16(fp)
 3247f5c:	10800003 	ldbu	r2,0(r2)
 3247f60:	10803fcc 	andi	r2,r2,255
 3247f64:	1080201c 	xori	r2,r2,128
 3247f68:	10bfe004 	addi	r2,r2,-128
 3247f6c:	10800c10 	cmplti	r2,r2,48
 3247f70:	1000121e 	bne	r2,zero,3247fbc <convert_ip+0xf0>
 3247f74:	e0bffc17 	ldw	r2,-16(fp)
 3247f78:	10800003 	ldbu	r2,0(r2)
 3247f7c:	10803fcc 	andi	r2,r2,255
 3247f80:	1080201c 	xori	r2,r2,128
 3247f84:	10bfe004 	addi	r2,r2,-128
 3247f88:	10800e88 	cmpgei	r2,r2,58
 3247f8c:	10000b1e 	bne	r2,zero,3247fbc <convert_ip+0xf0>
      {
         v = (v * 10) + (*cp - '0');
 3247f90:	e0bff90b 	ldhu	r2,-28(fp)
 3247f94:	108002a4 	muli	r2,r2,10
 3247f98:	1007883a 	mov	r3,r2
 3247f9c:	e0bffc17 	ldw	r2,-16(fp)
 3247fa0:	10800003 	ldbu	r2,0(r2)
 3247fa4:	10803fcc 	andi	r2,r2,255
 3247fa8:	1080201c 	xori	r2,r2,128
 3247fac:	10bfe004 	addi	r2,r2,-128
 3247fb0:	1885883a 	add	r2,r3,r2
 3247fb4:	10bff404 	addi	r2,r2,-48
 3247fb8:	e0bff90d 	sth	r2,-28(fp)
      }
      cp++;
 3247fbc:	e0bffc17 	ldw	r2,-16(fp)
 3247fc0:	10800044 	addi	r2,r2,1
 3247fc4:	e0bffc15 	stw	r2,-16(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
   int n = 0;
   unsigned short v = 0;
   dw = 0;
   while(*cp)
 3247fc8:	e0bffc17 	ldw	r2,-16(fp)
 3247fcc:	10800003 	ldbu	r2,0(r2)
 3247fd0:	10803fcc 	andi	r2,r2,255
 3247fd4:	1080201c 	xori	r2,r2,128
 3247fd8:	10bfe004 	addi	r2,r2,-128
 3247fdc:	1004c03a 	cmpne	r2,r2,zero
 3247fe0:	103fc61e 	bne	r2,zero,3247efc <convert_ip+0x30>
      {
         v = (v * 10) + (*cp - '0');
      }
      cp++;
   }
   lpb[n] = (unsigned char) v;
 3247fe4:	e0bffa17 	ldw	r2,-24(fp)
 3247fe8:	1007883a 	mov	r3,r2
 3247fec:	e0bffb17 	ldw	r2,-20(fp)
 3247ff0:	1887883a 	add	r3,r3,r2
 3247ff4:	e0bff90b 	ldhu	r2,-28(fp)
 3247ff8:	18800005 	stb	r2,0(r3)
   return dw;
 3247ffc:	e0bffd17 	ldw	r2,-12(fp)
 3248000:	e0bfff15 	stw	r2,-4(fp)
 3248004:	e0bfff17 	ldw	r2,-4(fp)
}  /* convert_ip() */
 3248008:	e037883a 	mov	sp,fp
 324800c:	df000017 	ldw	fp,0(sp)
 3248010:	dec00104 	addi	sp,sp,4
 3248014:	f800283a 	ret

03248018 <tcp_cksum>:
 * RETURNS: 
 */

unshort
tcp_cksum(struct ip * pip)
{
 3248018:	defff804 	addi	sp,sp,-32
 324801c:	dfc00715 	stw	ra,28(sp)
 3248020:	df000615 	stw	fp,24(sp)
 3248024:	df000604 	addi	fp,sp,24
 3248028:	e13fff15 	stw	r4,-4(fp)
   unshort  oldsum;
   unshort  newsum;
   struct tcphdr * tp;

#ifdef MUTE_WARNS    /* stifle compiler warnings */
   tcpdata = (char *)NULL;
 324802c:	e03ffd15 	stw	zero,-12(fp)
#endif   /* MUTE_WARNS */

   IN_PROFILER(PF_TSUM, PF_ENTRY);

   oddchar = 0;
 3248030:	e03ffc05 	stb	zero,-16(fp)

   iphlen = (unshort)ip_hlen(pip);
 3248034:	e0bfff17 	ldw	r2,-4(fp)
 3248038:	10800003 	ldbu	r2,0(r2)
 324803c:	10803fcc 	andi	r2,r2,255
 3248040:	108003cc 	andi	r2,r2,15
 3248044:	1085883a 	add	r2,r2,r2
 3248048:	1085883a 	add	r2,r2,r2
 324804c:	e0bffe8d 	sth	r2,-6(fp)
   tcplen = htons(pip->ip_len) - iphlen;
 3248050:	e0bfff17 	ldw	r2,-4(fp)
 3248054:	1080008b 	ldhu	r2,2(r2)
 3248058:	10bfffcc 	andi	r2,r2,65535
 324805c:	1004d23a 	srli	r2,r2,8
 3248060:	10803fcc 	andi	r2,r2,255
 3248064:	1009883a 	mov	r4,r2
 3248068:	e0bfff17 	ldw	r2,-4(fp)
 324806c:	1080008b 	ldhu	r2,2(r2)
 3248070:	10bfffcc 	andi	r2,r2,65535
 3248074:	1004923a 	slli	r2,r2,8
 3248078:	1007883a 	mov	r3,r2
 324807c:	00bfc004 	movi	r2,-256
 3248080:	1884703a 	and	r2,r3,r2
 3248084:	2084b03a 	or	r2,r4,r2
 3248088:	1007883a 	mov	r3,r2
 324808c:	e0bffe8b 	ldhu	r2,-6(fp)
 3248090:	1885c83a 	sub	r2,r3,r2
 3248094:	e0bffe0d 	sth	r2,-8(fp)

   tp = (struct tcphdr*)ip_data(pip);     /* get TCP header */
 3248098:	e0bfff17 	ldw	r2,-4(fp)
 324809c:	10800003 	ldbu	r2,0(r2)
 32480a0:	10803fcc 	andi	r2,r2,255
 32480a4:	108003cc 	andi	r2,r2,15
 32480a8:	1085883a 	add	r2,r2,r2
 32480ac:	1085883a 	add	r2,r2,r2
 32480b0:	1007883a 	mov	r3,r2
 32480b4:	e0bfff17 	ldw	r2,-4(fp)
 32480b8:	1885883a 	add	r2,r3,r2
 32480bc:	e0bffa15 	stw	r2,-24(fp)
   oldsum = tp->th_sum;       /* Save passed checksum */
 32480c0:	e0bffa17 	ldw	r2,-24(fp)
 32480c4:	1080040b 	ldhu	r2,16(r2)
 32480c8:	e0bffb8d 	sth	r2,-18(fp)
    * cannot overflow a 16 bit field) and put them in the cksum field. 
    * We include the IP addresses by passing them to the lower level 
    * fast sum routine. This results in their values being factored into 
    * the sum and the cksum field contributes zero.
    */
   tp->th_sum = htons(tcplen + 6);
 32480cc:	e0bffe0b 	ldhu	r2,-8(fp)
 32480d0:	10800184 	addi	r2,r2,6
 32480d4:	1005d23a 	srai	r2,r2,8
 32480d8:	10803fcc 	andi	r2,r2,255
 32480dc:	1009883a 	mov	r4,r2
 32480e0:	e0bffe0b 	ldhu	r2,-8(fp)
 32480e4:	10800184 	addi	r2,r2,6
 32480e8:	1004923a 	slli	r2,r2,8
 32480ec:	1007883a 	mov	r3,r2
 32480f0:	00bfc004 	movi	r2,-256
 32480f4:	1884703a 	and	r2,r3,r2
 32480f8:	2084b03a 	or	r2,r4,r2
 32480fc:	1007883a 	mov	r3,r2
 3248100:	e0bffa17 	ldw	r2,-24(fp)
 3248104:	10c0040d 	sth	r3,16(r2)

   /* zero pad odd sized packets for checksumming */
   if (tcplen & 1)   
 3248108:	e0bffe0b 	ldhu	r2,-8(fp)
 324810c:	1080004c 	andi	r2,r2,1
 3248110:	10803fcc 	andi	r2,r2,255
 3248114:	1005003a 	cmpeq	r2,r2,zero
 3248118:	10000f1e 	bne	r2,zero,3248158 <tcp_cksum+0x140>
   {
      tcpdata = ((char*)pip) + iphlen + tcplen;    /* end of packet */
 324811c:	e0bffe8b 	ldhu	r2,-6(fp)
 3248120:	1007883a 	mov	r3,r2
 3248124:	e0bfff17 	ldw	r2,-4(fp)
 3248128:	1887883a 	add	r3,r3,r2
 324812c:	e0bffe0b 	ldhu	r2,-8(fp)
 3248130:	1885883a 	add	r2,r3,r2
 3248134:	e0bffd15 	stw	r2,-12(fp)
      oddchar = *tcpdata;
 3248138:	e0bffd17 	ldw	r2,-12(fp)
 324813c:	10800003 	ldbu	r2,0(r2)
 3248140:	e0bffc05 	stb	r2,-16(fp)
      *tcpdata = '\0';        /* zero out pad byte */
 3248144:	e0bffd17 	ldw	r2,-12(fp)
 3248148:	10000005 	stb	zero,0(r2)
      tcplen++;               /* bump length to pass to cksum() */
 324814c:	e0bffe0b 	ldhu	r2,-8(fp)
 3248150:	10800044 	addi	r2,r2,1
 3248154:	e0bffe0d 	sth	r2,-8(fp)

   /* Pass a pointer to the beginning of the IP address area into the IP header
    * the the low level sum routine. Add the size of these two IP addresses to
    * the length, and convert the length to 16 bit words.
    */
   newsum = ~cksum(((char*)tp) - 8, (tcplen + 8) >> 1);
 3248158:	e0bffa17 	ldw	r2,-24(fp)
 324815c:	113ffe04 	addi	r4,r2,-8
 3248160:	e0bffe0b 	ldhu	r2,-8(fp)
 3248164:	10800204 	addi	r2,r2,8
 3248168:	1005d07a 	srai	r2,r2,1
 324816c:	100b883a 	mov	r5,r2
 3248170:	3225d5c0 	call	3225d5c <cksum>
 3248174:	0084303a 	nor	r2,zero,r2
 3248178:	e0bffb0d 	sth	r2,-20(fp)

   /* If the old checksum is 0xffff, but the actual checksum is 0x0000,
    * declare that to be a match.
    */
   if ((newsum != oldsum) && (oldsum == 0xffff) && (newsum == 0x0000))
 324817c:	e0fffb0b 	ldhu	r3,-20(fp)
 3248180:	e0bffb8b 	ldhu	r2,-18(fp)
 3248184:	18800826 	beq	r3,r2,32481a8 <tcp_cksum+0x190>
 3248188:	e0fffb8b 	ldhu	r3,-18(fp)
 324818c:	00bfffd4 	movui	r2,65535
 3248190:	1880051e 	bne	r3,r2,32481a8 <tcp_cksum+0x190>
 3248194:	e0bffb0b 	ldhu	r2,-20(fp)
 3248198:	1004c03a 	cmpne	r2,r2,zero
 324819c:	1000021e 	bne	r2,zero,32481a8 <tcp_cksum+0x190>
      newsum = 0xffff;
 32481a0:	00bfffc4 	movi	r2,-1
 32481a4:	e0bffb0d 	sth	r2,-20(fp)

   /* restore what we clobbered */
   tp->th_sum = oldsum;       /* put back passed checksum */
 32481a8:	e0fffa17 	ldw	r3,-24(fp)
 32481ac:	e0bffb8b 	ldhu	r2,-18(fp)
 32481b0:	1880040d 	sth	r2,16(r3)
   if (oddchar)
 32481b4:	e0bffc07 	ldb	r2,-16(fp)
 32481b8:	1005003a 	cmpeq	r2,r2,zero
 32481bc:	1000031e 	bne	r2,zero,32481cc <tcp_cksum+0x1b4>
      *tcpdata = oddchar;     /* restore odd byte if we zeroed it */
 32481c0:	e0fffd17 	ldw	r3,-12(fp)
 32481c4:	e0bffc03 	ldbu	r2,-16(fp)
 32481c8:	18800005 	stb	r2,0(r3)

   IN_PROFILER(PF_TSUM, PF_EXIT);

   return newsum;
 32481cc:	e0bffb0b 	ldhu	r2,-20(fp)
}
 32481d0:	e037883a 	mov	sp,fp
 32481d4:	dfc00117 	ldw	ra,4(sp)
 32481d8:	df000017 	ldw	fp,0(sp)
 32481dc:	dec00204 	addi	sp,sp,8
 32481e0:	f800283a 	ret

032481e4 <in_pcballoc>:
 */

int
in_pcballoc(struct socket * so, 
   struct inpcb * head)
{
 32481e4:	defffa04 	addi	sp,sp,-24
 32481e8:	dfc00515 	stw	ra,20(sp)
 32481ec:	df000415 	stw	fp,16(sp)
 32481f0:	df000404 	addi	fp,sp,16
 32481f4:	e13ffd15 	stw	r4,-12(fp)
 32481f8:	e17ffe15 	stw	r5,-8(fp)
   struct inpcb * inp;

   inp = INP_ALLOC (sizeof (*inp));
 32481fc:	01000b04 	movi	r4,44
 3248200:	322b9340 	call	322b934 <npalloc>
 3248204:	e0bffc15 	stw	r2,-16(fp)
   if (inp == 0)
 3248208:	e0bffc17 	ldw	r2,-16(fp)
 324820c:	1004c03a 	cmpne	r2,r2,zero
 3248210:	1000031e 	bne	r2,zero,3248220 <in_pcballoc+0x3c>
      return ENOMEM;
 3248214:	00800304 	movi	r2,12
 3248218:	e0bfff15 	stw	r2,-4(fp)
 324821c:	00001006 	br	3248260 <in_pcballoc+0x7c>
   inp->inp_head = head;
 3248220:	e0fffc17 	ldw	r3,-16(fp)
 3248224:	e0bffe17 	ldw	r2,-8(fp)
 3248228:	18800215 	stw	r2,8(r3)
   inp->inp_socket = so;
 324822c:	e0fffc17 	ldw	r3,-16(fp)
 3248230:	e0bffd17 	ldw	r2,-12(fp)
 3248234:	18800815 	stw	r2,32(r3)

   /* Set Path MTU to a very small default. It should get expanded 
    * later by v4 or v6 specific SYN code. We don't want it zero 
    * in case it doesn't get expanded promptly.
    */
   inp->inp_pmtu = 512;
 3248238:	e0fffc17 	ldw	r3,-16(fp)
 324823c:	00808004 	movi	r2,512
 3248240:	18800615 	stw	r2,24(r3)
   insque(inp, head);
 3248244:	e13ffc17 	ldw	r4,-16(fp)
 3248248:	e17ffe17 	ldw	r5,-8(fp)
 324824c:	322c6740 	call	322c674 <insque>
   so->so_pcb = inp;
 3248250:	e0fffd17 	ldw	r3,-12(fp)
 3248254:	e0bffc17 	ldw	r2,-16(fp)
 3248258:	18800115 	stw	r2,4(r3)
   return 0;
 324825c:	e03fff15 	stw	zero,-4(fp)
 3248260:	e0bfff17 	ldw	r2,-4(fp)
}
 3248264:	e037883a 	mov	sp,fp
 3248268:	dfc00117 	ldw	ra,4(sp)
 324826c:	df000017 	ldw	fp,0(sp)
 3248270:	dec00204 	addi	sp,sp,8
 3248274:	f800283a 	ret

03248278 <in_pcbdetach>:
 * RETURNS: 
 */

void
in_pcbdetach(struct inpcb * inp)
{
 3248278:	defffc04 	addi	sp,sp,-16
 324827c:	dfc00315 	stw	ra,12(sp)
 3248280:	df000215 	stw	fp,8(sp)
 3248284:	df000204 	addi	fp,sp,8
 3248288:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  inp->inp_socket;
 324828c:	e0bfff17 	ldw	r2,-4(fp)
 3248290:	10800817 	ldw	r2,32(r2)
 3248294:	e0bffe15 	stw	r2,-8(fp)

   so->so_pcb = 0;
 3248298:	e0bffe17 	ldw	r2,-8(fp)
 324829c:	10000115 	stw	zero,4(r2)
   sofree(so);
 32482a0:	e13ffe17 	ldw	r4,-8(fp)
 32482a4:	322fa3c0 	call	322fa3c <sofree>
   remque(inp);
 32482a8:	e13fff17 	ldw	r4,-4(fp)
 32482ac:	322c6040 	call	322c604 <remque>
   INP_FREE (inp);
 32482b0:	e13fff17 	ldw	r4,-4(fp)
 32482b4:	322ba280 	call	322ba28 <npfree>
}
 32482b8:	e037883a 	mov	sp,fp
 32482bc:	dfc00117 	ldw	ra,4(sp)
 32482c0:	df000017 	ldw	fp,0(sp)
 32482c4:	dec00204 	addi	sp,sp,8
 32482c8:	f800283a 	ret

032482cc <in_pcbbind>:

int
in_pcbbind(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 32482cc:	defff404 	addi	sp,sp,-48
 32482d0:	dfc00b15 	stw	ra,44(sp)
 32482d4:	df000a15 	stw	fp,40(sp)
 32482d8:	df000a04 	addi	fp,sp,40
 32482dc:	e13ffd15 	stw	r4,-12(fp)
 32482e0:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so =  inp->inp_socket;
 32482e4:	e0bffd17 	ldw	r2,-12(fp)
 32482e8:	10800817 	ldw	r2,32(r2)
 32482ec:	e0bffc15 	stw	r2,-16(fp)
   struct inpcb * head  =  inp->inp_head;
 32482f0:	e0bffd17 	ldw	r2,-12(fp)
 32482f4:	10800217 	ldw	r2,8(r2)
 32482f8:	e0bffb15 	stw	r2,-20(fp)
   struct sockaddr_in * sin;
   u_short  lport =  0;
 32482fc:	e03ff90d 	sth	zero,-28(fp)


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
 3248300:	e0bffd17 	ldw	r2,-12(fp)
 3248304:	1080078b 	ldhu	r2,30(r2)
 3248308:	10bfffcc 	andi	r2,r2,65535
 324830c:	1004c03a 	cmpne	r2,r2,zero
 3248310:	1000041e 	bne	r2,zero,3248324 <in_pcbbind+0x58>
 3248314:	e0bffd17 	ldw	r2,-12(fp)
 3248318:	10800417 	ldw	r2,16(r2)
 324831c:	1005003a 	cmpeq	r2,r2,zero
 3248320:	1000031e 	bne	r2,zero,3248330 <in_pcbbind+0x64>
      return (EINVAL);
 3248324:	00800584 	movi	r2,22
 3248328:	e0bfff15 	stw	r2,-4(fp)
 324832c:	00007606 	br	3248508 <in_pcbbind+0x23c>
   if (nam == 0)
 3248330:	e0bffe17 	ldw	r2,-8(fp)
 3248334:	1005003a 	cmpeq	r2,r2,zero
 3248338:	10003e1e 	bne	r2,zero,3248434 <in_pcbbind+0x168>
      goto noname;
   sin = mtod(nam, struct sockaddr_in *);
 324833c:	e0bffe17 	ldw	r2,-8(fp)
 3248340:	10800317 	ldw	r2,12(r2)
 3248344:	e0bffa15 	stw	r2,-24(fp)
   /*
    * removed test here for "if (nam->m_len != sizeof (*sin))"
    * since it really complicatges supporting dual IPv4/v6, and 
    * the 2.0 stack now checks this in t_bind(). -JB-
    */
   if (sin->sin_addr.s_addr != INADDR_ANY) 
 3248348:	e0bffa17 	ldw	r2,-24(fp)
 324834c:	10800117 	ldw	r2,4(r2)
 3248350:	1005003a 	cmpeq	r2,r2,zero
 3248354:	10000a1e 	bne	r2,zero,3248380 <in_pcbbind+0xb4>
   {
      if (ip_mymach(sin->sin_addr.s_addr) != sin->sin_addr.s_addr)
 3248358:	e0bffa17 	ldw	r2,-24(fp)
 324835c:	11000117 	ldw	r4,4(r2)
 3248360:	32404f00 	call	32404f0 <ip_mymach>
 3248364:	1007883a 	mov	r3,r2
 3248368:	e0bffa17 	ldw	r2,-24(fp)
 324836c:	10800117 	ldw	r2,4(r2)
 3248370:	18800326 	beq	r3,r2,3248380 <in_pcbbind+0xb4>
      return (EADDRNOTAVAIL);
 3248374:	00801f44 	movi	r2,125
 3248378:	e0bfff15 	stw	r2,-4(fp)
 324837c:	00006206 	br	3248508 <in_pcbbind+0x23c>
   }
   lport = sin->sin_port;
 3248380:	e0bffa17 	ldw	r2,-24(fp)
 3248384:	1080008b 	ldhu	r2,2(r2)
 3248388:	e0bff90d 	sth	r2,-28(fp)
   if (lport) 
 324838c:	e0bff90b 	ldhu	r2,-28(fp)
 3248390:	1005003a 	cmpeq	r2,r2,zero
 3248394:	1000231e 	bne	r2,zero,3248424 <in_pcbbind+0x158>
   {
      int   wild  =  0;
 3248398:	e03ff815 	stw	zero,-32(fp)

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 324839c:	e0bffc17 	ldw	r2,-16(fp)
 32483a0:	10800417 	ldw	r2,16(r2)
 32483a4:	1080010c 	andi	r2,r2,4
 32483a8:	1004c03a 	cmpne	r2,r2,zero
 32483ac:	10000e1e 	bne	r2,zero,32483e8 <in_pcbbind+0x11c>
 32483b0:	e0bffc17 	ldw	r2,-16(fp)
 32483b4:	10800217 	ldw	r2,8(r2)
 32483b8:	1080010b 	ldhu	r2,4(r2)
 32483bc:	10bfffcc 	andi	r2,r2,65535
 32483c0:	1080010c 	andi	r2,r2,4
 32483c4:	1005003a 	cmpeq	r2,r2,zero
 32483c8:	1000051e 	bne	r2,zero,32483e0 <in_pcbbind+0x114>
 32483cc:	e0bffc17 	ldw	r2,-16(fp)
 32483d0:	10800417 	ldw	r2,16(r2)
 32483d4:	1080008c 	andi	r2,r2,2
 32483d8:	1004c03a 	cmpne	r2,r2,zero
 32483dc:	1000021e 	bne	r2,zero,32483e8 <in_pcbbind+0x11c>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
          (so->so_options & SO_ACCEPTCONN) == 0))
      {
         wild = INPLOOKUP_WILDCARD;
 32483e0:	00800044 	movi	r2,1
 32483e4:	e0bff815 	stw	r2,-32(fp)
      }
      if (in_pcblookup(head,
 32483e8:	e0bffa17 	ldw	r2,-24(fp)
 32483ec:	11c00117 	ldw	r7,4(r2)
 32483f0:	e0bff90b 	ldhu	r2,-28(fp)
 32483f4:	d8800015 	stw	r2,0(sp)
 32483f8:	e0bff817 	ldw	r2,-32(fp)
 32483fc:	d8800115 	stw	r2,4(sp)
 3248400:	e13ffb17 	ldw	r4,-20(fp)
 3248404:	000b883a 	mov	r5,zero
 3248408:	000d883a 	mov	r6,zero
 324840c:	32488880 	call	3248888 <in_pcblookup>
 3248410:	1005003a 	cmpeq	r2,r2,zero
 3248414:	1000031e 	bne	r2,zero,3248424 <in_pcbbind+0x158>
          0L, 0, sin->sin_addr.s_addr, lport, wild))
      {
         return (EADDRINUSE);
 3248418:	00801c04 	movi	r2,112
 324841c:	e0bfff15 	stw	r2,-4(fp)
 3248420:	00003906 	br	3248508 <in_pcbbind+0x23c>
      }
   }
   inp->inp_laddr = sin->sin_addr;
 3248424:	e0bffa17 	ldw	r2,-24(fp)
 3248428:	10c00117 	ldw	r3,4(r2)
 324842c:	e0bffd17 	ldw	r2,-12(fp)
 3248430:	10c00415 	stw	r3,16(r2)
noname:
   if (lport == 0)
 3248434:	e0bff90b 	ldhu	r2,-28(fp)
 3248438:	1004c03a 	cmpne	r2,r2,zero
 324843c:	10002e1e 	bne	r2,zero,32484f8 <in_pcbbind+0x22c>
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 3248440:	e0bffb17 	ldw	r2,-20(fp)
 3248444:	10c0078b 	ldhu	r3,30(r2)
 3248448:	18bfffcc 	andi	r2,r3,65535
 324844c:	10810030 	cmpltui	r2,r2,1024
 3248450:	1009883a 	mov	r4,r2
 3248454:	18800044 	addi	r2,r3,1
 3248458:	1007883a 	mov	r3,r2
 324845c:	e0bffb17 	ldw	r2,-20(fp)
 3248460:	10c0078d 	sth	r3,30(r2)
 3248464:	20803fcc 	andi	r2,r4,255
 3248468:	1004c03a 	cmpne	r2,r2,zero
 324846c:	1000051e 	bne	r2,zero,3248484 <in_pcbbind+0x1b8>
 3248470:	e0bffb17 	ldw	r2,-20(fp)
 3248474:	1080078b 	ldhu	r2,30(r2)
 3248478:	10bfffcc 	andi	r2,r2,65535
 324847c:	1084e270 	cmpltui	r2,r2,5001
 3248480:	1000031e 	bne	r2,zero,3248490 <in_pcbbind+0x1c4>
             head->inp_lport > IPPORT_USERRESERVED)
         {
            head->inp_lport = IPPORT_RESERVED;
 3248484:	e0fffb17 	ldw	r3,-20(fp)
 3248488:	00810004 	movi	r2,1024
 324848c:	1880078d 	sth	r2,30(r3)
         }
         lport = htons(head->inp_lport);
 3248490:	e0bffb17 	ldw	r2,-20(fp)
 3248494:	1080078b 	ldhu	r2,30(r2)
 3248498:	10bfffcc 	andi	r2,r2,65535
 324849c:	1004d23a 	srli	r2,r2,8
 32484a0:	10803fcc 	andi	r2,r2,255
 32484a4:	1009883a 	mov	r4,r2
 32484a8:	e0bffb17 	ldw	r2,-20(fp)
 32484ac:	1080078b 	ldhu	r2,30(r2)
 32484b0:	10bfffcc 	andi	r2,r2,65535
 32484b4:	1004923a 	slli	r2,r2,8
 32484b8:	1007883a 	mov	r3,r2
 32484bc:	00bfc004 	movi	r2,-256
 32484c0:	1884703a 	and	r2,r3,r2
 32484c4:	2084b03a 	or	r2,r4,r2
 32484c8:	e0bff90d 	sth	r2,-28(fp)
      } while(in_pcblookup(head, 0L, 0, inp->inp_laddr.s_addr, lport, 0));
 32484cc:	e0bffd17 	ldw	r2,-12(fp)
 32484d0:	11c00417 	ldw	r7,16(r2)
 32484d4:	e0bff90b 	ldhu	r2,-28(fp)
 32484d8:	d8800015 	stw	r2,0(sp)
 32484dc:	d8000115 	stw	zero,4(sp)
 32484e0:	e13ffb17 	ldw	r4,-20(fp)
 32484e4:	000b883a 	mov	r5,zero
 32484e8:	000d883a 	mov	r6,zero
 32484ec:	32488880 	call	3248888 <in_pcblookup>
 32484f0:	1004c03a 	cmpne	r2,r2,zero
 32484f4:	103fd21e 	bne	r2,zero,3248440 <in_pcbbind+0x174>
   }
   inp->inp_lport = lport;
 32484f8:	e0fffd17 	ldw	r3,-12(fp)
 32484fc:	e0bff90b 	ldhu	r2,-28(fp)
 3248500:	1880078d 	sth	r2,30(r3)
   return (0);
 3248504:	e03fff15 	stw	zero,-4(fp)
 3248508:	e0bfff17 	ldw	r2,-4(fp)
}
 324850c:	e037883a 	mov	sp,fp
 3248510:	dfc00117 	ldw	ra,4(sp)
 3248514:	df000017 	ldw	fp,0(sp)
 3248518:	dec00204 	addi	sp,sp,8
 324851c:	f800283a 	ret

03248520 <in_pcbconnect>:
 */

int
in_pcbconnect(struct inpcb * inp, 
   struct mbuf *  nam)
{
 3248520:	defff504 	addi	sp,sp,-44
 3248524:	dfc00a15 	stw	ra,40(sp)
 3248528:	df000915 	stw	fp,36(sp)
 324852c:	df000904 	addi	fp,sp,36
 3248530:	e13ffd15 	stw	r4,-12(fp)
 3248534:	e17ffe15 	stw	r5,-8(fp)
   unsigned long ifaddr;
   struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 3248538:	e0bffe17 	ldw	r2,-8(fp)
 324853c:	10800317 	ldw	r2,12(r2)
 3248540:	e0bffa15 	stw	r2,-24(fp)

   if (nam->m_len < sizeof (*sin))
 3248544:	e0bffe17 	ldw	r2,-8(fp)
 3248548:	10800217 	ldw	r2,8(r2)
 324854c:	10800428 	cmpgeui	r2,r2,16
 3248550:	1000031e 	bne	r2,zero,3248560 <in_pcbconnect+0x40>
      return (EINVAL);
 3248554:	00800584 	movi	r2,22
 3248558:	e0bfff15 	stw	r2,-4(fp)
 324855c:	00006e06 	br	3248718 <in_pcbconnect+0x1f8>
   if (sin->sin_family != AF_INET)
 3248560:	e0bffa17 	ldw	r2,-24(fp)
 3248564:	1080000b 	ldhu	r2,0(r2)
 3248568:	10bfffcc 	andi	r2,r2,65535
 324856c:	10a0001c 	xori	r2,r2,32768
 3248570:	10a00004 	addi	r2,r2,-32768
 3248574:	108000a0 	cmpeqi	r2,r2,2
 3248578:	1000031e 	bne	r2,zero,3248588 <in_pcbconnect+0x68>
      return (EAFNOSUPPORT);
 324857c:	00801a84 	movi	r2,106
 3248580:	e0bfff15 	stw	r2,-4(fp)
 3248584:	00006406 	br	3248718 <in_pcbconnect+0x1f8>
   if (sin->sin_port == 0)
 3248588:	e0bffa17 	ldw	r2,-24(fp)
 324858c:	1080008b 	ldhu	r2,2(r2)
 3248590:	10bfffcc 	andi	r2,r2,65535
 3248594:	1004c03a 	cmpne	r2,r2,zero
 3248598:	1000031e 	bne	r2,zero,32485a8 <in_pcbconnect+0x88>
      return (EADDRNOTAVAIL);
 324859c:	00801f44 	movi	r2,125
 32485a0:	e0bfff15 	stw	r2,-4(fp)
 32485a4:	00005c06 	br	3248718 <in_pcbconnect+0x1f8>
    * use the primary local address.
    * If the supplied address is INADDR_BROADCAST,
    * and the primary interface supports broadcast,
    * choose the broadcast address for that interface.
    */
   if (sin->sin_addr.s_addr == INADDR_ANY)
 32485a8:	e0bffa17 	ldw	r2,-24(fp)
 32485ac:	10800117 	ldw	r2,4(r2)
 32485b0:	1004c03a 	cmpne	r2,r2,zero
 32485b4:	1000101e 	bne	r2,zero,32485f8 <in_pcbconnect+0xd8>
   {
      if (inp && inp->ifp)
 32485b8:	e0bffd17 	ldw	r2,-12(fp)
 32485bc:	1005003a 	cmpeq	r2,r2,zero
 32485c0:	10000a1e 	bne	r2,zero,32485ec <in_pcbconnect+0xcc>
 32485c4:	e0bffd17 	ldw	r2,-12(fp)
 32485c8:	10800a17 	ldw	r2,40(r2)
 32485cc:	1005003a 	cmpeq	r2,r2,zero
 32485d0:	1000061e 	bne	r2,zero,32485ec <in_pcbconnect+0xcc>
         sin->sin_addr.s_addr = inp->ifp->n_ipaddr;
 32485d4:	e0bffd17 	ldw	r2,-12(fp)
 32485d8:	10800a17 	ldw	r2,40(r2)
 32485dc:	10c00a17 	ldw	r3,40(r2)
 32485e0:	e0bffa17 	ldw	r2,-24(fp)
 32485e4:	10c00115 	stw	r3,4(r2)
 32485e8:	00000a06 	br	3248614 <in_pcbconnect+0xf4>
      else
         return (EADDRNOTAVAIL);
 32485ec:	00801f44 	movi	r2,125
 32485f0:	e0bfff15 	stw	r2,-4(fp)
 32485f4:	00004806 	br	3248718 <in_pcbconnect+0x1f8>
   }
   else if (sin->sin_addr.s_addr == INADDR_BROADCAST)
 32485f8:	e0bffa17 	ldw	r2,-24(fp)
 32485fc:	10800117 	ldw	r2,4(r2)
 3248600:	10bfffd8 	cmpnei	r2,r2,-1
 3248604:	1000031e 	bne	r2,zero,3248614 <in_pcbconnect+0xf4>
      return (EADDRNOTAVAIL);
 3248608:	00801f44 	movi	r2,125
 324860c:	e0bfff15 	stw	r2,-4(fp)
 3248610:	00004106 	br	3248718 <in_pcbconnect+0x1f8>


   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 3248614:	e0bffd17 	ldw	r2,-12(fp)
 3248618:	10800417 	ldw	r2,16(r2)
 324861c:	1004c03a 	cmpne	r2,r2,zero
 3248620:	10000f1e 	bne	r2,zero,3248660 <in_pcbconnect+0x140>
   {
#ifdef MULTI_HOMED
      ip_addr hop1;     /* dummy for pass to iproute() */
      NET npnet;     /* the netport iface we can send on */
      /* call netport stack's IP routing */
      npnet = iproute(sin->sin_addr.s_addr, &hop1);
 3248624:	e0bffa17 	ldw	r2,-24(fp)
 3248628:	11000117 	ldw	r4,4(r2)
 324862c:	e17ffc04 	addi	r5,fp,-16
 3248630:	32408540 	call	3240854 <iproute>
 3248634:	e0bff915 	stw	r2,-28(fp)
      if (!npnet)
 3248638:	e0bff917 	ldw	r2,-28(fp)
 324863c:	1004c03a 	cmpne	r2,r2,zero
 3248640:	1000031e 	bne	r2,zero,3248650 <in_pcbconnect+0x130>
         return EADDRNOTAVAIL;
 3248644:	00801f44 	movi	r2,125
 3248648:	e0bfff15 	stw	r2,-4(fp)
 324864c:	00003206 	br	3248718 <in_pcbconnect+0x1f8>
      ifaddr = npnet->n_ipaddr;  /* local address for this host */
 3248650:	e0bff917 	ldw	r2,-28(fp)
 3248654:	10800a17 	ldw	r2,40(r2)
 3248658:	e0bffb15 	stw	r2,-20(fp)
 324865c:	00000306 	br	324866c <in_pcbconnect+0x14c>
#else    /* not netport MULTI_HOMED, use 0th (only) iface */
      ifaddr = nets[0]->n_ipaddr;
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */
 3248660:	e0bffd17 	ldw	r2,-12(fp)
 3248664:	10800417 	ldw	r2,16(r2)
 3248668:	e0bffb15 	stw	r2,-20(fp)

   if (in_pcblookup(inp->inp_head,
 324866c:	e0bffd17 	ldw	r2,-12(fp)
 3248670:	11000217 	ldw	r4,8(r2)
 3248674:	e0bffa17 	ldw	r2,-24(fp)
 3248678:	11400117 	ldw	r5,4(r2)
 324867c:	e0bffa17 	ldw	r2,-24(fp)
 3248680:	1080008b 	ldhu	r2,2(r2)
 3248684:	11bfffcc 	andi	r6,r2,65535
 3248688:	e0bffd17 	ldw	r2,-12(fp)
 324868c:	1080078b 	ldhu	r2,30(r2)
 3248690:	10bfffcc 	andi	r2,r2,65535
 3248694:	d8800015 	stw	r2,0(sp)
 3248698:	d8000115 	stw	zero,4(sp)
 324869c:	e1fffb17 	ldw	r7,-20(fp)
 32486a0:	32488880 	call	3248888 <in_pcblookup>
 32486a4:	1005003a 	cmpeq	r2,r2,zero
 32486a8:	1000031e 	bne	r2,zero,32486b8 <in_pcbconnect+0x198>
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
       0))
   {
      return (EADDRINUSE);
 32486ac:	00801c04 	movi	r2,112
 32486b0:	e0bfff15 	stw	r2,-4(fp)
 32486b4:	00001806 	br	3248718 <in_pcbconnect+0x1f8>
   }
   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 32486b8:	e0bffd17 	ldw	r2,-12(fp)
 32486bc:	10800417 	ldw	r2,16(r2)
 32486c0:	1004c03a 	cmpne	r2,r2,zero
 32486c4:	10000b1e 	bne	r2,zero,32486f4 <in_pcbconnect+0x1d4>
   {
      if (inp->inp_lport == 0)
 32486c8:	e0bffd17 	ldw	r2,-12(fp)
 32486cc:	1080078b 	ldhu	r2,30(r2)
 32486d0:	10bfffcc 	andi	r2,r2,65535
 32486d4:	1004c03a 	cmpne	r2,r2,zero
 32486d8:	1000031e 	bne	r2,zero,32486e8 <in_pcbconnect+0x1c8>
         (void)in_pcbbind(inp, (struct mbuf *)0);
 32486dc:	e13ffd17 	ldw	r4,-12(fp)
 32486e0:	000b883a 	mov	r5,zero
 32486e4:	32482cc0 	call	32482cc <in_pcbbind>
      inp->inp_laddr.s_addr = ifaddr;
 32486e8:	e0fffd17 	ldw	r3,-12(fp)
 32486ec:	e0bffb17 	ldw	r2,-20(fp)
 32486f0:	18800415 	stw	r2,16(r3)
   }
   inp->inp_faddr = sin->sin_addr;
 32486f4:	e0bffa17 	ldw	r2,-24(fp)
 32486f8:	10c00117 	ldw	r3,4(r2)
 32486fc:	e0bffd17 	ldw	r2,-12(fp)
 3248700:	10c00315 	stw	r3,12(r2)
   inp->inp_fport = sin->sin_port;
 3248704:	e0bffa17 	ldw	r2,-24(fp)
 3248708:	10c0008b 	ldhu	r3,2(r2)
 324870c:	e0bffd17 	ldw	r2,-12(fp)
 3248710:	10c0070d 	sth	r3,28(r2)
   return 0;
 3248714:	e03fff15 	stw	zero,-4(fp)
 3248718:	e0bfff17 	ldw	r2,-4(fp)
}
 324871c:	e037883a 	mov	sp,fp
 3248720:	dfc00117 	ldw	ra,4(sp)
 3248724:	df000017 	ldw	fp,0(sp)
 3248728:	dec00204 	addi	sp,sp,8
 324872c:	f800283a 	ret

03248730 <in_pcbdisconnect>:
 * RETURNS: 
 */

void
in_pcbdisconnect(struct inpcb * inp)
{
 3248730:	defffd04 	addi	sp,sp,-12
 3248734:	dfc00215 	stw	ra,8(sp)
 3248738:	df000115 	stw	fp,4(sp)
 324873c:	df000104 	addi	fp,sp,4
 3248740:	e13fff15 	stw	r4,-4(fp)

   inp->inp_faddr.s_addr = INADDR_ANY;
 3248744:	e0bfff17 	ldw	r2,-4(fp)
 3248748:	10000315 	stw	zero,12(r2)
   inp->inp_fport = 0;
 324874c:	e0bfff17 	ldw	r2,-4(fp)
 3248750:	1000070d 	sth	zero,28(r2)
   if (inp->inp_socket->so_state & SS_NOFDREF)
 3248754:	e0bfff17 	ldw	r2,-4(fp)
 3248758:	10800817 	ldw	r2,32(r2)
 324875c:	1080088b 	ldhu	r2,34(r2)
 3248760:	10bfffcc 	andi	r2,r2,65535
 3248764:	1080004c 	andi	r2,r2,1
 3248768:	10803fcc 	andi	r2,r2,255
 324876c:	1005003a 	cmpeq	r2,r2,zero
 3248770:	1000021e 	bne	r2,zero,324877c <in_pcbdisconnect+0x4c>
      in_pcbdetach (inp);
 3248774:	e13fff17 	ldw	r4,-4(fp)
 3248778:	32482780 	call	3248278 <in_pcbdetach>
}
 324877c:	e037883a 	mov	sp,fp
 3248780:	dfc00117 	ldw	ra,4(sp)
 3248784:	df000017 	ldw	fp,0(sp)
 3248788:	dec00204 	addi	sp,sp,8
 324878c:	f800283a 	ret

03248790 <in_setsockaddr>:
 */

void
in_setsockaddr(struct inpcb * inp, 
   struct mbuf *  nam)
{
 3248790:	defffc04 	addi	sp,sp,-16
 3248794:	df000315 	stw	fp,12(sp)
 3248798:	df000304 	addi	fp,sp,12
 324879c:	e13ffe15 	stw	r4,-8(fp)
 32487a0:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 32487a4:	e0ffff17 	ldw	r3,-4(fp)
 32487a8:	00800404 	movi	r2,16
 32487ac:	18800215 	stw	r2,8(r3)
   sin = mtod(nam, struct sockaddr_in *);
 32487b0:	e0bfff17 	ldw	r2,-4(fp)
 32487b4:	10800317 	ldw	r2,12(r2)
 32487b8:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 32487bc:	e0bffd17 	ldw	r2,-12(fp)
 32487c0:	10000015 	stw	zero,0(r2)
 32487c4:	10000115 	stw	zero,4(r2)
 32487c8:	10000215 	stw	zero,8(r2)
 32487cc:	10000315 	stw	zero,12(r2)
   sin->sin_family = AF_INET;
 32487d0:	e0fffd17 	ldw	r3,-12(fp)
 32487d4:	00800084 	movi	r2,2
 32487d8:	1880000d 	sth	r2,0(r3)
   sin->sin_port = inp->inp_lport;
 32487dc:	e0bffe17 	ldw	r2,-8(fp)
 32487e0:	10c0078b 	ldhu	r3,30(r2)
 32487e4:	e0bffd17 	ldw	r2,-12(fp)
 32487e8:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_laddr;
 32487ec:	e0bffe17 	ldw	r2,-8(fp)
 32487f0:	10c00417 	ldw	r3,16(r2)
 32487f4:	e0bffd17 	ldw	r2,-12(fp)
 32487f8:	10c00115 	stw	r3,4(r2)
}
 32487fc:	e037883a 	mov	sp,fp
 3248800:	df000017 	ldw	fp,0(sp)
 3248804:	dec00104 	addi	sp,sp,4
 3248808:	f800283a 	ret

0324880c <in_setpeeraddr>:

void
in_setpeeraddr(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 324880c:	defffc04 	addi	sp,sp,-16
 3248810:	df000315 	stw	fp,12(sp)
 3248814:	df000304 	addi	fp,sp,12
 3248818:	e13ffe15 	stw	r4,-8(fp)
 324881c:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 3248820:	e0ffff17 	ldw	r3,-4(fp)
 3248824:	00800404 	movi	r2,16
 3248828:	18800215 	stw	r2,8(r3)
   sin = mtod(nam, struct sockaddr_in *);
 324882c:	e0bfff17 	ldw	r2,-4(fp)
 3248830:	10800317 	ldw	r2,12(r2)
 3248834:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 3248838:	e0bffd17 	ldw	r2,-12(fp)
 324883c:	10000015 	stw	zero,0(r2)
 3248840:	10000115 	stw	zero,4(r2)
 3248844:	10000215 	stw	zero,8(r2)
 3248848:	10000315 	stw	zero,12(r2)
   sin->sin_family = AF_INET;
 324884c:	e0fffd17 	ldw	r3,-12(fp)
 3248850:	00800084 	movi	r2,2
 3248854:	1880000d 	sth	r2,0(r3)
   sin->sin_port = inp->inp_fport;
 3248858:	e0bffe17 	ldw	r2,-8(fp)
 324885c:	10c0070b 	ldhu	r3,28(r2)
 3248860:	e0bffd17 	ldw	r2,-12(fp)
 3248864:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_faddr;
 3248868:	e0bffe17 	ldw	r2,-8(fp)
 324886c:	10c00317 	ldw	r3,12(r2)
 3248870:	e0bffd17 	ldw	r2,-12(fp)
 3248874:	10c00115 	stw	r3,4(r2)
}
 3248878:	e037883a 	mov	sp,fp
 324887c:	df000017 	ldw	fp,0(sp)
 3248880:	dec00104 	addi	sp,sp,4
 3248884:	f800283a 	ret

03248888 <in_pcblookup>:
   u_long   faddr, 
   unshort  xfport,
   u_long   laddr,
   unshort  xlport,
   int   flags)
{
 3248888:	defff404 	addi	sp,sp,-48
 324888c:	df000b15 	stw	fp,44(sp)
 3248890:	df000b04 	addi	fp,sp,44
 3248894:	e13ffa15 	stw	r4,-24(fp)
 3248898:	e17ffb15 	stw	r5,-20(fp)
 324889c:	e1fffd15 	stw	r7,-12(fp)
 32488a0:	e0800117 	ldw	r2,4(fp)
 32488a4:	e1bffc0d 	sth	r6,-16(fp)
 32488a8:	e0bffe0d 	sth	r2,-8(fp)
   struct inpcb * inp, *   match =  0;
 32488ac:	e03ff815 	stw	zero,-32(fp)
   unshort  fport =  xfport; 
 32488b0:	e0bffc0b 	ldhu	r2,-16(fp)
 32488b4:	e0bff78d 	sth	r2,-34(fp)
   unshort  lport =  xlport;
 32488b8:	e0bffe0b 	ldhu	r2,-8(fp)
 32488bc:	e0bff70d 	sth	r2,-36(fp)
   int   matchwild   =  3;
 32488c0:	008000c4 	movi	r2,3
 32488c4:	e0bff615 	stw	r2,-40(fp)
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 32488c8:	e0bffa17 	ldw	r2,-24(fp)
 32488cc:	10800017 	ldw	r2,0(r2)
 32488d0:	e0bff915 	stw	r2,-28(fp)
 32488d4:	00005006 	br	3248a18 <in_pcblookup+0x190>
   {
      if (inp->inp_lport != lport)
 32488d8:	e0bff917 	ldw	r2,-28(fp)
 32488dc:	1080078b 	ldhu	r2,30(r2)
 32488e0:	10ffffcc 	andi	r3,r2,65535
 32488e4:	e0bff70b 	ldhu	r2,-36(fp)
 32488e8:	1880481e 	bne	r3,r2,3248a0c <in_pcblookup+0x184>
         continue;

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
 32488ec:	e0bff917 	ldw	r2,-28(fp)
 32488f0:	10800817 	ldw	r2,32(r2)
 32488f4:	10800517 	ldw	r2,20(r2)
 32488f8:	10800098 	cmpnei	r2,r2,2
 32488fc:	1000431e 	bne	r2,zero,3248a0c <in_pcblookup+0x184>
         continue;

      wildcard = 0;
 3248900:	e03ff515 	stw	zero,-44(fp)
      if (inp->inp_laddr.s_addr != INADDR_ANY) 
 3248904:	e0bff917 	ldw	r2,-28(fp)
 3248908:	10800417 	ldw	r2,16(r2)
 324890c:	1005003a 	cmpeq	r2,r2,zero
 3248910:	10000c1e 	bne	r2,zero,3248944 <in_pcblookup+0xbc>
      {
         if (laddr == INADDR_ANY)
 3248914:	e0bffd17 	ldw	r2,-12(fp)
 3248918:	1004c03a 	cmpne	r2,r2,zero
 324891c:	1000041e 	bne	r2,zero,3248930 <in_pcblookup+0xa8>
            wildcard++;
 3248920:	e0bff517 	ldw	r2,-44(fp)
 3248924:	10800044 	addi	r2,r2,1
 3248928:	e0bff515 	stw	r2,-44(fp)
 324892c:	00000b06 	br	324895c <in_pcblookup+0xd4>
         else if (inp->inp_laddr.s_addr != laddr)
 3248930:	e0bff917 	ldw	r2,-28(fp)
 3248934:	10c00417 	ldw	r3,16(r2)
 3248938:	e0bffd17 	ldw	r2,-12(fp)
 324893c:	1880331e 	bne	r3,r2,3248a0c <in_pcblookup+0x184>
            continue;
 3248940:	00000606 	br	324895c <in_pcblookup+0xd4>
      }
      else 
      {
         if (laddr != INADDR_ANY)
 3248944:	e0bffd17 	ldw	r2,-12(fp)
 3248948:	1005003a 	cmpeq	r2,r2,zero
 324894c:	1000031e 	bne	r2,zero,324895c <in_pcblookup+0xd4>
            wildcard++;
 3248950:	e0bff517 	ldw	r2,-44(fp)
 3248954:	10800044 	addi	r2,r2,1
 3248958:	e0bff515 	stw	r2,-44(fp)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
 324895c:	e0bff917 	ldw	r2,-28(fp)
 3248960:	10800317 	ldw	r2,12(r2)
 3248964:	1005003a 	cmpeq	r2,r2,zero
 3248968:	1000111e 	bne	r2,zero,32489b0 <in_pcblookup+0x128>
      {
         if (faddr == INADDR_ANY)
 324896c:	e0bffb17 	ldw	r2,-20(fp)
 3248970:	1004c03a 	cmpne	r2,r2,zero
 3248974:	1000041e 	bne	r2,zero,3248988 <in_pcblookup+0x100>
            wildcard++;
 3248978:	e0bff517 	ldw	r2,-44(fp)
 324897c:	10800044 	addi	r2,r2,1
 3248980:	e0bff515 	stw	r2,-44(fp)
 3248984:	00001006 	br	32489c8 <in_pcblookup+0x140>
         else if (inp->inp_faddr.s_addr != faddr ||
 3248988:	e0bff917 	ldw	r2,-28(fp)
 324898c:	10c00317 	ldw	r3,12(r2)
 3248990:	e0bffb17 	ldw	r2,-20(fp)
 3248994:	18801d1e 	bne	r3,r2,3248a0c <in_pcblookup+0x184>
 3248998:	e0bff917 	ldw	r2,-28(fp)
 324899c:	1080070b 	ldhu	r2,28(r2)
 32489a0:	10ffffcc 	andi	r3,r2,65535
 32489a4:	e0bff78b 	ldhu	r2,-34(fp)
 32489a8:	1880181e 	bne	r3,r2,3248a0c <in_pcblookup+0x184>
 32489ac:	00000606 	br	32489c8 <in_pcblookup+0x140>
         {
            continue;
         }
      } else 
      {
         if (faddr != INADDR_ANY)
 32489b0:	e0bffb17 	ldw	r2,-20(fp)
 32489b4:	1005003a 	cmpeq	r2,r2,zero
 32489b8:	1000031e 	bne	r2,zero,32489c8 <in_pcblookup+0x140>
            wildcard++;
 32489bc:	e0bff517 	ldw	r2,-44(fp)
 32489c0:	10800044 	addi	r2,r2,1
 32489c4:	e0bff515 	stw	r2,-44(fp)
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
 32489c8:	e0bff517 	ldw	r2,-44(fp)
 32489cc:	1005003a 	cmpeq	r2,r2,zero
 32489d0:	1000041e 	bne	r2,zero,32489e4 <in_pcblookup+0x15c>
 32489d4:	e0800217 	ldw	r2,8(fp)
 32489d8:	1080004c 	andi	r2,r2,1
 32489dc:	1005003a 	cmpeq	r2,r2,zero
 32489e0:	10000a1e 	bne	r2,zero,3248a0c <in_pcblookup+0x184>
         continue;
      if (wildcard < matchwild) 
 32489e4:	e0fff517 	ldw	r3,-44(fp)
 32489e8:	e0bff617 	ldw	r2,-40(fp)
 32489ec:	1880070e 	bge	r3,r2,3248a0c <in_pcblookup+0x184>
      {
         match = inp;
 32489f0:	e0bff917 	ldw	r2,-28(fp)
 32489f4:	e0bff815 	stw	r2,-32(fp)
         matchwild = wildcard;
 32489f8:	e0bff517 	ldw	r2,-44(fp)
 32489fc:	e0bff615 	stw	r2,-40(fp)
         if (matchwild == 0)
 3248a00:	e0bff617 	ldw	r2,-40(fp)
 3248a04:	1005003a 	cmpeq	r2,r2,zero
 3248a08:	1000061e 	bne	r2,zero,3248a24 <in_pcblookup+0x19c>
   unshort  fport =  xfport; 
   unshort  lport =  xlport;
   int   matchwild   =  3;
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 3248a0c:	e0bff917 	ldw	r2,-28(fp)
 3248a10:	10800017 	ldw	r2,0(r2)
 3248a14:	e0bff915 	stw	r2,-28(fp)
 3248a18:	e0fff917 	ldw	r3,-28(fp)
 3248a1c:	e0bffa17 	ldw	r2,-24(fp)
 3248a20:	18bfad1e 	bne	r3,r2,32488d8 <in_pcblookup+0x50>
         matchwild = wildcard;
         if (matchwild == 0)
            break;
      }
   }
   if (match == NULL)
 3248a24:	e0bff817 	ldw	r2,-32(fp)
 3248a28:	1004c03a 	cmpne	r2,r2,zero
 3248a2c:	1000031e 	bne	r2,zero,3248a3c <in_pcblookup+0x1b4>
      return match;
 3248a30:	e0bff817 	ldw	r2,-32(fp)
 3248a34:	e0bfff15 	stw	r2,-4(fp)
 3248a38:	00002506 	br	3248ad0 <in_pcblookup+0x248>

   if (head->inp_next == match)  /* got cache hit? */
 3248a3c:	e0bffa17 	ldw	r2,-24(fp)
 3248a40:	10c00017 	ldw	r3,0(r2)
 3248a44:	e0bff817 	ldw	r2,-32(fp)
 3248a48:	1880041e 	bne	r3,r2,3248a5c <in_pcblookup+0x1d4>
   {
      inpcb_cachehits++;
 3248a4c:	d0a90917 	ldw	r2,-23516(gp)
 3248a50:	10800044 	addi	r2,r2,1
 3248a54:	d0a90915 	stw	r2,-23516(gp)
 3248a58:	00001b06 	br	3248ac8 <in_pcblookup+0x240>
   }
   else
   {
      inpcb_cachemiss++;
 3248a5c:	d0a90a17 	ldw	r2,-23512(gp)
 3248a60:	10800044 	addi	r2,r2,1
 3248a64:	d0a90a15 	stw	r2,-23512(gp)
      /* "cache" the match to be first checked next time. */
      match->inp_next->inp_prev = match->inp_prev; /*unlink match */
 3248a68:	e0bff817 	ldw	r2,-32(fp)
 3248a6c:	10c00017 	ldw	r3,0(r2)
 3248a70:	e0bff817 	ldw	r2,-32(fp)
 3248a74:	10800117 	ldw	r2,4(r2)
 3248a78:	18800115 	stw	r2,4(r3)
      match->inp_prev->inp_next = match->inp_next;
 3248a7c:	e0bff817 	ldw	r2,-32(fp)
 3248a80:	10c00117 	ldw	r3,4(r2)
 3248a84:	e0bff817 	ldw	r2,-32(fp)
 3248a88:	10800017 	ldw	r2,0(r2)
 3248a8c:	18800015 	stw	r2,0(r3)

      /* relink match as head->inp_next */
      match->inp_next = head->inp_next;
 3248a90:	e0bffa17 	ldw	r2,-24(fp)
 3248a94:	10c00017 	ldw	r3,0(r2)
 3248a98:	e0bff817 	ldw	r2,-32(fp)
 3248a9c:	10c00015 	stw	r3,0(r2)
      head->inp_next = match;
 3248aa0:	e0fffa17 	ldw	r3,-24(fp)
 3248aa4:	e0bff817 	ldw	r2,-32(fp)
 3248aa8:	18800015 	stw	r2,0(r3)
      match->inp_prev = head;
 3248aac:	e0fff817 	ldw	r3,-32(fp)
 3248ab0:	e0bffa17 	ldw	r2,-24(fp)
 3248ab4:	18800115 	stw	r2,4(r3)
      match->inp_next->inp_prev = match;
 3248ab8:	e0bff817 	ldw	r2,-32(fp)
 3248abc:	10c00017 	ldw	r3,0(r2)
 3248ac0:	e0bff817 	ldw	r2,-32(fp)
 3248ac4:	18800115 	stw	r2,4(r3)
   }
   return (match);
 3248ac8:	e0bff817 	ldw	r2,-32(fp)
 3248acc:	e0bfff15 	stw	r2,-4(fp)
 3248ad0:	e0bfff17 	ldw	r2,-4(fp)
}
 3248ad4:	e037883a 	mov	sp,fp
 3248ad8:	df000017 	ldw	fp,0(sp)
 3248adc:	dec00104 	addi	sp,sp,4
 3248ae0:	f800283a 	ret

03248ae4 <set_vfopen_error>:
 *
 * RETURNS: 
 */

void set_vfopen_error(int error)
{
 3248ae4:	defffe04 	addi	sp,sp,-8
 3248ae8:	df000115 	stw	fp,4(sp)
 3248aec:	df000104 	addi	fp,sp,4
 3248af0:	e13fff15 	stw	r4,-4(fp)
   vfopen_error = error;
 3248af4:	e0bfff17 	ldw	r2,-4(fp)
 3248af8:	d0a90e15 	stw	r2,-23496(gp)
}
 3248afc:	e037883a 	mov	sp,fp
 3248b00:	df000017 	ldw	fp,0(sp)
 3248b04:	dec00104 	addi	sp,sp,4
 3248b08:	f800283a 	ret

03248b0c <get_vfopen_error>:
 *
 * RETURNS: 
 */

int get_vfopen_error()
{
 3248b0c:	deffff04 	addi	sp,sp,-4
 3248b10:	df000015 	stw	fp,0(sp)
 3248b14:	d839883a 	mov	fp,sp
   return vfopen_error;
 3248b18:	d0a90e17 	ldw	r2,-23496(gp)
}
 3248b1c:	e037883a 	mov	sp,fp
 3248b20:	df000017 	ldw	fp,0(sp)
 3248b24:	dec00104 	addi	sp,sp,4
 3248b28:	f800283a 	ret

03248b2c <vf_alloc_and_link_vop>:
 *
 * RETURNS: 
 */

VFILE * vf_alloc_and_link_vop()
{
 3248b2c:	defffc04 	addi	sp,sp,-16
 3248b30:	dfc00315 	stw	ra,12(sp)
 3248b34:	df000215 	stw	fp,8(sp)
 3248b38:	df000204 	addi	fp,sp,8
   struct vfs_open * vop;

   /* enforce maximum number of simultaneously open files */
   if (vfs_open_files >= VFS_MAX_OPEN_FILES)
 3248b3c:	d0a91017 	ldw	r2,-23488(gp)
 3248b40:	10803ff0 	cmpltui	r2,r2,255
 3248b44:	1000021e 	bne	r2,zero,3248b50 <vf_alloc_and_link_vop+0x24>
   {
#ifdef VFS_VERBOSE
      dprintf("vfs_open_files too big (%ld) in vf_alloc_and_link_vop()\n",
       vfs_open_files);
#endif   /* VFS_VERBOSE */
      return NULL;
 3248b48:	e03fff15 	stw	zero,-4(fp)
 3248b4c:	00001006 	br	3248b90 <vf_alloc_and_link_vop+0x64>
   }

   /* allocate a structure to represent the open file */
   vop = VFS_VFS_OPEN_ALLOC();
 3248b50:	01000504 	movi	r4,20
 3248b54:	322b9340 	call	322b934 <npalloc>
 3248b58:	e0bffe15 	stw	r2,-8(fp)

   /* if the allocation succeeded */
   if (vop)
 3248b5c:	e0bffe17 	ldw	r2,-8(fp)
 3248b60:	1005003a 	cmpeq	r2,r2,zero
 3248b64:	1000081e 	bne	r2,zero,3248b88 <vf_alloc_and_link_vop+0x5c>
   {
      /* add to the beginning of the list of open files */
      vop->next = vfiles;
 3248b68:	d0e90c17 	ldw	r3,-23504(gp)
 3248b6c:	e0bffe17 	ldw	r2,-8(fp)
 3248b70:	10c00015 	stw	r3,0(r2)
      vfiles = vop;
 3248b74:	e0bffe17 	ldw	r2,-8(fp)
 3248b78:	d0a90c15 	stw	r2,-23504(gp)
      /* increment the count of open files */
      vfs_open_files++;
 3248b7c:	d0a91017 	ldw	r2,-23488(gp)
 3248b80:	10800044 	addi	r2,r2,1
 3248b84:	d0a91015 	stw	r2,-23488(gp)
#ifdef VFS_VERBOSE
   else
      dprintf("VFS_VFS_OPEN_ALLOC() failed in vf_alloc_and_link_vop()\n");
#endif   /* VFS_VERBOSE */

   return vop;
 3248b88:	e0bffe17 	ldw	r2,-8(fp)
 3248b8c:	e0bfff15 	stw	r2,-4(fp)
 3248b90:	e0bfff17 	ldw	r2,-4(fp)
}
 3248b94:	e037883a 	mov	sp,fp
 3248b98:	dfc00117 	ldw	ra,4(sp)
 3248b9c:	df000017 	ldw	fp,0(sp)
 3248ba0:	dec00204 	addi	sp,sp,8
 3248ba4:	f800283a 	ret

03248ba8 <vf_alloc_buffer>:
 *
 * RETURNS: 
 */

unsigned char * vf_alloc_buffer(unsigned long size)
{
 3248ba8:	defff804 	addi	sp,sp,-32
 3248bac:	dfc00715 	stw	ra,28(sp)
 3248bb0:	df000615 	stw	fp,24(sp)
 3248bb4:	df000604 	addi	fp,sp,24
 3248bb8:	e13ffe15 	stw	r4,-8(fp)
   unsigned int long_size,int_size;
#endif   /* MUTE_WARNS */

   /* make sure the requested allocation does not exceed the total
      memory space reserved for file buffers */
   if ((vfs_total_rw_space + size) > VFS_MAX_TOTAL_RW_SPACE)
 3248bbc:	d0e91117 	ldw	r3,-23484(gp)
 3248bc0:	e0bffe17 	ldw	r2,-8(fp)
 3248bc4:	1887883a 	add	r3,r3,r2
 3248bc8:	00bfffd4 	movui	r2,65535
 3248bcc:	10c0022e 	bgeu	r2,r3,3248bd8 <vf_alloc_buffer+0x30>
      return NULL;
 3248bd0:	e03fff15 	stw	zero,-4(fp)
 3248bd4:	00002406 	br	3248c68 <vf_alloc_buffer+0xc0>
    * any bigger than what will fit in an unsigned int 
    */
#ifdef MUTE_WARNS
   /* the idiotic hoops you got to jump through to suppress compiler
      warnings */
   long_size   =  sizeof(unsigned   long);
 3248bd8:	00800104 	movi	r2,4
 3248bdc:	e0bffc15 	stw	r2,-16(fp)
   int_size = sizeof(unsigned int);
 3248be0:	00800104 	movi	r2,4
 3248be4:	e0bffb15 	stw	r2,-20(fp)
   if (long_size > int_size)
 3248be8:	e0fffc17 	ldw	r3,-16(fp)
 3248bec:	e0bffb17 	ldw	r2,-20(fp)
 3248bf0:	10c0112e 	bgeu	r2,r3,3248c38 <vf_alloc_buffer+0x90>
       * most systems where this "if" expression will evaluate to 
       * true (2 byte ints, 4 byte longs). if any of those upper bits 
       * are on in your requested size, you otta luck.
       */
#ifdef MUTE_WARNS
      switch (int_size)
 3248bf4:	e0bffb17 	ldw	r2,-20(fp)
 3248bf8:	108000a0 	cmpeqi	r2,r2,2
 3248bfc:	1000011e 	bne	r2,zero,3248c04 <vf_alloc_buffer+0x5c>
 3248c00:	00000806 	br	3248c24 <vf_alloc_buffer+0x7c>
#else
      switch (sizeof(unsigned int))
#endif   /* MUTE_WARNS */
      {
      case 2 :
         mem_mask = 0xffff0000;
 3248c04:	00bffff4 	movhi	r2,65535
 3248c08:	e0bffa15 	stw	r2,-24(fp)
         default :
            dtrap();    /* you have a weird compiler */
         return NULL;
      }

      if (size & mem_mask)
 3248c0c:	e0fffe17 	ldw	r3,-8(fp)
 3248c10:	e0bffa17 	ldw	r2,-24(fp)
 3248c14:	1884703a 	and	r2,r3,r2
 3248c18:	1004c03a 	cmpne	r2,r2,zero
 3248c1c:	1000041e 	bne	r2,zero,3248c30 <vf_alloc_buffer+0x88>
 3248c20:	00000506 	br	3248c38 <vf_alloc_buffer+0x90>
      {
      case 2 :
         mem_mask = 0xffff0000;
         break;
         default :
            dtrap();    /* you have a weird compiler */
 3248c24:	322aef00 	call	322aef0 <dtrap>
         return NULL;
 3248c28:	e03fff15 	stw	zero,-4(fp)
 3248c2c:	00000e06 	br	3248c68 <vf_alloc_buffer+0xc0>
      }

      if (size & mem_mask)
         return NULL;
 3248c30:	e03fff15 	stw	zero,-4(fp)
 3248c34:	00000c06 	br	3248c68 <vf_alloc_buffer+0xc0>
   }

   /* try to allocate a buffer of the requested size */
   buffer = (unsigned char *) npalloc((unsigned int) size);
 3248c38:	e13ffe17 	ldw	r4,-8(fp)
 3248c3c:	322b9340 	call	322b934 <npalloc>
 3248c40:	e0bffd15 	stw	r2,-12(fp)

   /* if the allocation succeeded */
   if (buffer)
 3248c44:	e0bffd17 	ldw	r2,-12(fp)
 3248c48:	1005003a 	cmpeq	r2,r2,zero
 3248c4c:	1000041e 	bne	r2,zero,3248c60 <vf_alloc_buffer+0xb8>
   {
      /* add size to the count of total buffer space allocated */
      vfs_total_rw_space += size;
 3248c50:	d0a91117 	ldw	r2,-23484(gp)
 3248c54:	e0fffe17 	ldw	r3,-8(fp)
 3248c58:	10c5883a 	add	r2,r2,r3
 3248c5c:	d0a91115 	stw	r2,-23484(gp)
   }

   return buffer;
 3248c60:	e0bffd17 	ldw	r2,-12(fp)
 3248c64:	e0bfff15 	stw	r2,-4(fp)
 3248c68:	e0bfff17 	ldw	r2,-4(fp)
}
 3248c6c:	e037883a 	mov	sp,fp
 3248c70:	dfc00117 	ldw	ra,4(sp)
 3248c74:	df000017 	ldw	fp,0(sp)
 3248c78:	dec00204 	addi	sp,sp,8
 3248c7c:	f800283a 	ret

03248c80 <vf_free_buffer>:
 *
 * RETURNS: 
 */

void vf_free_buffer(unsigned char * buffer, unsigned long size)
{
 3248c80:	defffc04 	addi	sp,sp,-16
 3248c84:	dfc00315 	stw	ra,12(sp)
 3248c88:	df000215 	stw	fp,8(sp)
 3248c8c:	df000204 	addi	fp,sp,8
 3248c90:	e13ffe15 	stw	r4,-8(fp)
 3248c94:	e17fff15 	stw	r5,-4(fp)
   /* free the buffer */
   if (buffer)
 3248c98:	e0bffe17 	ldw	r2,-8(fp)
 3248c9c:	1005003a 	cmpeq	r2,r2,zero
 3248ca0:	1000021e 	bne	r2,zero,3248cac <vf_free_buffer+0x2c>
      npfree(buffer);
 3248ca4:	e13ffe17 	ldw	r4,-8(fp)
 3248ca8:	322ba280 	call	322ba28 <npfree>

   /* and subtract its size from the total buffer space count */
   vfs_total_rw_space -= size;
 3248cac:	d0a91117 	ldw	r2,-23484(gp)
 3248cb0:	e0ffff17 	ldw	r3,-4(fp)
 3248cb4:	10c5c83a 	sub	r2,r2,r3
 3248cb8:	d0a91115 	stw	r2,-23484(gp)
}
 3248cbc:	e037883a 	mov	sp,fp
 3248cc0:	dfc00117 	ldw	ra,4(sp)
 3248cc4:	df000017 	ldw	fp,0(sp)
 3248cc8:	dec00204 	addi	sp,sp,8
 3248ccc:	f800283a 	ret

03248cd0 <vfopen_locked>:
 * RETURNS: 
 */

VFILE *
vfopen_locked(char * name, char * mode)
{
 3248cd0:	defff804 	addi	sp,sp,-32
 3248cd4:	dfc00715 	stw	ra,28(sp)
 3248cd8:	df000615 	stw	fp,24(sp)
 3248cdc:	df000604 	addi	fp,sp,24
 3248ce0:	e13ffd15 	stw	r4,-12(fp)
 3248ce4:	e17ffe15 	stw	r5,-8(fp)
   struct vfs_file * vfp;
   struct vfs_open * vop;

   /* clear any previous vfopen() error */
   set_vfopen_error(0);
 3248ce8:	0009883a 	mov	r4,zero
 3248cec:	3248ae40 	call	3248ae4 <set_vfopen_error>

   /* the old code used to do special handling of '?' in files for 
    * the benefit of the web server. the web server should be doing 
    * this now. this is here to make sure that its doing it 
    */
   if (strchr(name,'?'))
 3248cf0:	e13ffd17 	ldw	r4,-12(fp)
 3248cf4:	01400fc4 	movi	r5,63
 3248cf8:	3207cf40 	call	3207cf4 <strchr>
 3248cfc:	1005003a 	cmpeq	r2,r2,zero
 3248d00:	1000031e 	bne	r2,zero,3248d10 <vfopen_locked+0x40>
   {
      dtrap();
 3248d04:	322aef00 	call	322aef0 <dtrap>
      return NULL;
 3248d08:	e03fff15 	stw	zero,-4(fp)
 3248d0c:	0000c406 	br	3249020 <vfopen_locked+0x350>
   }

   /* determine if the file exists */
   /* if the directory exists, vfp will point to its directory entry
      structure else vfp will be NULL */
   vfp = vfslookup_locked(name);
 3248d10:	e13ffd17 	ldw	r4,-12(fp)
 3248d14:	324a07c0 	call	324a07c <vfslookup_locked>
 3248d18:	e0bffc15 	stw	r2,-16(fp)

   /* if the file exists */
   if (vfp)
 3248d1c:	e0bffc17 	ldw	r2,-16(fp)
 3248d20:	1005003a 	cmpeq	r2,r2,zero
 3248d24:	10004e1e 	bne	r2,zero,3248e60 <vfopen_locked+0x190>

#ifdef HT_RWVFS

      /* if mode begins with 'w' we will truncate to end of file */
      /* make sure the file is writable before proceeding */
      if ((*mode == 'w') && !(vfp->flags & VF_WRITE))
 3248d28:	e0bffe17 	ldw	r2,-8(fp)
 3248d2c:	10800003 	ldbu	r2,0(r2)
 3248d30:	10803fcc 	andi	r2,r2,255
 3248d34:	1080201c 	xori	r2,r2,128
 3248d38:	10bfe004 	addi	r2,r2,-128
 3248d3c:	10801dd8 	cmpnei	r2,r2,119
 3248d40:	10000a1e 	bne	r2,zero,3248d6c <vfopen_locked+0x9c>
 3248d44:	e0bffc17 	ldw	r2,-16(fp)
 3248d48:	1080058b 	ldhu	r2,22(r2)
 3248d4c:	10bfffcc 	andi	r2,r2,65535
 3248d50:	1080080c 	andi	r2,r2,32
 3248d54:	1004c03a 	cmpne	r2,r2,zero
 3248d58:	1000041e 	bne	r2,zero,3248d6c <vfopen_locked+0x9c>
      {
         set_vfopen_error(ENP_FILEIO);
 3248d5c:	013ff984 	movi	r4,-26
 3248d60:	3248ae40 	call	3248ae4 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("mode w with no VF_WRITE\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 3248d64:	e03fff15 	stw	zero,-4(fp)
 3248d68:	0000ad06 	br	3249020 <vfopen_locked+0x350>
      }

#endif   /* HT_RWVFS */

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 3248d6c:	3248b2c0 	call	3248b2c <vf_alloc_and_link_vop>
 3248d70:	e0bffb15 	stw	r2,-20(fp)

      /* check for failure */
      if (!vop)
 3248d74:	e0bffb17 	ldw	r2,-20(fp)
 3248d78:	1004c03a 	cmpne	r2,r2,zero
 3248d7c:	1000041e 	bne	r2,zero,3248d90 <vfopen_locked+0xc0>
      {
         set_vfopen_error(ENP_NOMEM);
 3248d80:	013ffb04 	movi	r4,-20
 3248d84:	3248ae40 	call	3248ae4 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 1\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 3248d88:	e03fff15 	stw	zero,-4(fp)
 3248d8c:	0000a406 	br	3249020 <vfopen_locked+0x350>
      }

      /* link to the file's directory entry structure */
      vop->file = vfp;
 3248d90:	e0fffb17 	ldw	r3,-20(fp)
 3248d94:	e0bffc17 	ldw	r2,-16(fp)
 3248d98:	18800115 	stw	r2,4(r3)

      /* by default start at the beginning of the file */
      /* note that vfp->data could be NULL at this point since empty
         files might have no data buffer allocated to them */
      vop->cmploc = vfp->data;   /* start at beginning of file */
 3248d9c:	e0bffc17 	ldw	r2,-16(fp)
 3248da0:	10c00617 	ldw	r3,24(r2)
 3248da4:	e0bffb17 	ldw	r2,-20(fp)
 3248da8:	10c00215 	stw	r3,8(r2)

#ifdef HT_RWVFS

      /* if mode begins with 'a', seek to end of file */
      if (*mode == 'a')
 3248dac:	e0bffe17 	ldw	r2,-8(fp)
 3248db0:	10800003 	ldbu	r2,0(r2)
 3248db4:	10803fcc 	andi	r2,r2,255
 3248db8:	1080201c 	xori	r2,r2,128
 3248dbc:	10bfe004 	addi	r2,r2,-128
 3248dc0:	10801858 	cmpnei	r2,r2,97
 3248dc4:	10000b1e 	bne	r2,zero,3248df4 <vfopen_locked+0x124>
      {
         if (vfp->data)
 3248dc8:	e0bffc17 	ldw	r2,-16(fp)
 3248dcc:	10800617 	ldw	r2,24(r2)
 3248dd0:	1005003a 	cmpeq	r2,r2,zero
 3248dd4:	1000071e 	bne	r2,zero,3248df4 <vfopen_locked+0x124>
         {
            vop->cmploc = vfp->data + vfp->comp_size;
 3248dd8:	e0bffc17 	ldw	r2,-16(fp)
 3248ddc:	10c00617 	ldw	r3,24(r2)
 3248de0:	e0bffc17 	ldw	r2,-16(fp)
 3248de4:	10800817 	ldw	r2,32(r2)
 3248de8:	1887883a 	add	r3,r3,r2
 3248dec:	e0bffb17 	ldw	r2,-20(fp)
 3248df0:	10c00215 	stw	r3,8(r2)
         }
      }

      /* if mode begins with 'w', truncate to end of file */
      if (*mode == 'w')
 3248df4:	e0bffe17 	ldw	r2,-8(fp)
 3248df8:	10800003 	ldbu	r2,0(r2)
 3248dfc:	10803fcc 	andi	r2,r2,255
 3248e00:	1080201c 	xori	r2,r2,128
 3248e04:	10bfe004 	addi	r2,r2,-128
 3248e08:	10801dd8 	cmpnei	r2,r2,119
 3248e0c:	1000111e 	bne	r2,zero,3248e54 <vfopen_locked+0x184>
      {
         /* set the size of the file before compression to 0 */
         vfp->real_size = 0;
 3248e10:	e0bffc17 	ldw	r2,-16(fp)
 3248e14:	10000715 	stw	zero,28(r2)
         /* set the size of the compressed data to 0 */
         vfp->comp_size = 0;
 3248e18:	e0bffc17 	ldw	r2,-16(fp)
 3248e1c:	10000815 	stw	zero,32(r2)
         /* note we leave the pointer to the file buffer and its length
            alone since first writes will go to it */
         /* flag that the file has been modified */
         vfp->flags |= VF_STALE;
 3248e20:	e0bffc17 	ldw	r2,-16(fp)
 3248e24:	1080058b 	ldhu	r2,22(r2)
 3248e28:	10808014 	ori	r2,r2,512
 3248e2c:	1007883a 	mov	r3,r2
 3248e30:	e0bffc17 	ldw	r2,-16(fp)
 3248e34:	10c0058d 	sth	r3,22(r2)

         /* turn off the compression flag */
         vfp->flags &= ~VF_HTMLCOMPRESSED;
 3248e38:	e0bffc17 	ldw	r2,-16(fp)
 3248e3c:	10c0058b 	ldhu	r3,22(r2)
 3248e40:	00bfff84 	movi	r2,-2
 3248e44:	1884703a 	and	r2,r3,r2
 3248e48:	1007883a 	mov	r3,r2
 3248e4c:	e0bffc17 	ldw	r2,-16(fp)
 3248e50:	10c0058d 	sth	r3,22(r2)
      }

#endif   /* HT_RWVFS */

      return vop;
 3248e54:	e0bffb17 	ldw	r2,-20(fp)
 3248e58:	e0bfff15 	stw	r2,-4(fp)
 3248e5c:	00007006 	br	3249020 <vfopen_locked+0x350>

#ifdef HT_EXTDEV

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 3248e60:	e0bffe17 	ldw	r2,-8(fp)
 3248e64:	10800003 	ldbu	r2,0(r2)
 3248e68:	10803fcc 	andi	r2,r2,255
 3248e6c:	1080201c 	xori	r2,r2,128
 3248e70:	10bfe004 	addi	r2,r2,-128
 3248e74:	10801ca0 	cmpeqi	r2,r2,114
 3248e78:	1000151e 	bne	r2,zero,3248ed0 <vfopen_locked+0x200>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 3248e7c:	d0a90b17 	ldw	r2,-23508(gp)
 3248e80:	e0bffa15 	stw	r2,-24(fp)
 3248e84:	00000f06 	br	3248ec4 <vfopen_locked+0x1f4>
      {
         if ((vop = vfs->r_fopen(name, mode)) != NULL)
 3248e88:	e0bffa17 	ldw	r2,-24(fp)
 3248e8c:	10800117 	ldw	r2,4(r2)
 3248e90:	e13ffd17 	ldw	r4,-12(fp)
 3248e94:	e17ffe17 	ldw	r5,-8(fp)
 3248e98:	103ee83a 	callr	r2
 3248e9c:	e0bffb15 	stw	r2,-20(fp)
 3248ea0:	e0bffb17 	ldw	r2,-20(fp)
 3248ea4:	1005003a 	cmpeq	r2,r2,zero
 3248ea8:	1000031e 	bne	r2,zero,3248eb8 <vfopen_locked+0x1e8>
         {
            return vop;
 3248eac:	e0bffb17 	ldw	r2,-20(fp)
 3248eb0:	e0bfff15 	stw	r2,-4(fp)
 3248eb4:	00005a06 	br	3249020 <vfopen_locked+0x350>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 3248eb8:	e0bffa17 	ldw	r2,-24(fp)
 3248ebc:	10800017 	ldw	r2,0(r2)
 3248ec0:	e0bffa15 	stw	r2,-24(fp)
 3248ec4:	e0bffa17 	ldw	r2,-24(fp)
 3248ec8:	1004c03a 	cmpne	r2,r2,zero
 3248ecc:	103fee1e 	bne	r2,zero,3248e88 <vfopen_locked+0x1b8>

#ifdef HT_RWVFS

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 3248ed0:	e0bffe17 	ldw	r2,-8(fp)
 3248ed4:	10800003 	ldbu	r2,0(r2)
 3248ed8:	10803fcc 	andi	r2,r2,255
 3248edc:	1080201c 	xori	r2,r2,128
 3248ee0:	10bfe004 	addi	r2,r2,-128
 3248ee4:	10801ca0 	cmpeqi	r2,r2,114
 3248ee8:	10004a1e 	bne	r2,zero,3249014 <vfopen_locked+0x344>
   {
      /* enforce maximum number of files */
      if (vfs_total_dyna_files >= VFS_MAX_DYNA_FILES)
 3248eec:	d0a91217 	ldw	r2,-23480(gp)
 3248ef0:	10803ff0 	cmpltui	r2,r2,255
 3248ef4:	1000041e 	bne	r2,zero,3248f08 <vfopen_locked+0x238>
      {
         set_vfopen_error(ENP_NOMEM);
 3248ef8:	013ffb04 	movi	r4,-20
 3248efc:	3248ae40 	call	3248ae4 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_total_dyna_files too big in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 3248f00:	e03fff15 	stw	zero,-4(fp)
 3248f04:	00004606 	br	3249020 <vfopen_locked+0x350>
      }

      /* make sure the file name is not too long for the VFS */
      if (strlen(name) > FILENAMEMAX)
 3248f08:	e13ffd17 	ldw	r4,-12(fp)
 3248f0c:	32084480 	call	3208448 <strlen>
 3248f10:	10800470 	cmpltui	r2,r2,17
 3248f14:	1000041e 	bne	r2,zero,3248f28 <vfopen_locked+0x258>
      {
         set_vfopen_error(ENP_PARAM);
 3248f18:	013ffd84 	movi	r4,-10
 3248f1c:	3248ae40 	call	3248ae4 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("file name too long in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 3248f20:	e03fff15 	stw	zero,-4(fp)
 3248f24:	00003e06 	br	3249020 <vfopen_locked+0x350>
      }

      /* allocate a vfs_file structure to hold the new file entry in */
      vfp = VFS_VFS_FILE_ALLOC();
 3248f28:	01000b04 	movi	r4,44
 3248f2c:	322b9340 	call	322b934 <npalloc>
 3248f30:	e0bffc15 	stw	r2,-16(fp)

      /* check for memory allocation failure */
      if (!vfp)
 3248f34:	e0bffc17 	ldw	r2,-16(fp)
 3248f38:	1004c03a 	cmpne	r2,r2,zero
 3248f3c:	1000041e 	bne	r2,zero,3248f50 <vfopen_locked+0x280>
      {
         set_vfopen_error(ENP_NOMEM);
 3248f40:	013ffb04 	movi	r4,-20
 3248f44:	3248ae40 	call	3248ae4 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("VFS_VFS_FILE_ALLOC() failed in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 3248f48:	e03fff15 	stw	zero,-4(fp)
 3248f4c:	00003406 	br	3249020 <vfopen_locked+0x350>
      }

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 3248f50:	3248b2c0 	call	3248b2c <vf_alloc_and_link_vop>
 3248f54:	e0bffb15 	stw	r2,-20(fp)

      /* check for memory allocation failure */
      if (!vop)
 3248f58:	e0bffb17 	ldw	r2,-20(fp)
 3248f5c:	1004c03a 	cmpne	r2,r2,zero
 3248f60:	1000061e 	bne	r2,zero,3248f7c <vfopen_locked+0x2ac>
      {
         VFS_VFS_FILE_FREE(vfp); /* free the allocated vfs_file entry */
 3248f64:	e13ffc17 	ldw	r4,-16(fp)
 3248f68:	322ba280 	call	322ba28 <npfree>
         set_vfopen_error(ENP_NOMEM);
 3248f6c:	013ffb04 	movi	r4,-20
 3248f70:	3248ae40 	call	3248ae4 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 2\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 3248f74:	e03fff15 	stw	zero,-4(fp)
 3248f78:	00002906 	br	3249020 <vfopen_locked+0x350>
      }

      /* add the vfs_file structure to the head of the list */

      vfp->next = vfsfiles;
 3248f7c:	d0e90d17 	ldw	r3,-23500(gp)
 3248f80:	e0bffc17 	ldw	r2,-16(fp)
 3248f84:	10c00015 	stw	r3,0(r2)
      vfsfiles = vfp;
 3248f88:	e0bffc17 	ldw	r2,-16(fp)
 3248f8c:	d0a90d15 	stw	r2,-23500(gp)

      /* increment count of total files */
      vfs_total_dyna_files++;
 3248f90:	d0a91217 	ldw	r2,-23480(gp)
 3248f94:	10800044 	addi	r2,r2,1
 3248f98:	d0a91215 	stw	r2,-23480(gp)

      /* remove leading directory separator before storing name */
      if (*name == '/' || *name == '\\')
 3248f9c:	e0bffd17 	ldw	r2,-12(fp)
 3248fa0:	10800003 	ldbu	r2,0(r2)
 3248fa4:	10803fcc 	andi	r2,r2,255
 3248fa8:	1080201c 	xori	r2,r2,128
 3248fac:	10bfe004 	addi	r2,r2,-128
 3248fb0:	10800be0 	cmpeqi	r2,r2,47
 3248fb4:	1000071e 	bne	r2,zero,3248fd4 <vfopen_locked+0x304>
 3248fb8:	e0bffd17 	ldw	r2,-12(fp)
 3248fbc:	10800003 	ldbu	r2,0(r2)
 3248fc0:	10803fcc 	andi	r2,r2,255
 3248fc4:	1080201c 	xori	r2,r2,128
 3248fc8:	10bfe004 	addi	r2,r2,-128
 3248fcc:	10801718 	cmpnei	r2,r2,92
 3248fd0:	1000031e 	bne	r2,zero,3248fe0 <vfopen_locked+0x310>
         name++;
 3248fd4:	e0bffd17 	ldw	r2,-12(fp)
 3248fd8:	10800044 	addi	r2,r2,1
 3248fdc:	e0bffd15 	stw	r2,-12(fp)

      /* store the converted name in the directory entry structure */
      strcpy(vfp->name,name);
 3248fe0:	e0bffc17 	ldw	r2,-16(fp)
 3248fe4:	11000104 	addi	r4,r2,4
 3248fe8:	e17ffd17 	ldw	r5,-12(fp)
 3248fec:	324bd340 	call	324bd34 <strcpy>

      /* set the flags */
      vfp->flags = VF_DYNAMICINFO   /* the directory entry was allocated */
 3248ff0:	e0fffc17 	ldw	r3,-16(fp)
 3248ff4:	0080d804 	movi	r2,864
 3248ff8:	1880058d 	sth	r2,22(r3)
       * note that this means the data pointer contains a null 
       * because we don't allocate any buffer to hold the data 
       * in until the first write 
       */
      /* link to the file's directory entry structure */
      vop->file = vfp;
 3248ffc:	e0fffb17 	ldw	r3,-20(fp)
 3249000:	e0bffc17 	ldw	r2,-16(fp)
 3249004:	18800115 	stw	r2,4(r3)
      /* the cmploc and tag fields of the vop retain their NULLs from 
       * npalloc(). cmploc contains NULL because there is no data 
       * buffer to point to yet. tag contains NULL because no 
       * decompression operation has started yet
       */
      return vop;
 3249008:	e0bffb17 	ldw	r2,-20(fp)
 324900c:	e0bfff15 	stw	r2,-4(fp)
 3249010:	00000306 	br	3249020 <vfopen_locked+0x350>
   /* pass the open to the local file system */
   return (VFILE *) fopen(name,mode);

#else

   set_vfopen_error(ENP_NOFILE);
 3249014:	013ff9c4 	movi	r4,-25
 3249018:	3248ae40 	call	3248ae4 <set_vfopen_error>
#ifdef VFS_VERBOSE
   dprintf("fell thru to end of vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
   return NULL;
 324901c:	e03fff15 	stw	zero,-4(fp)
 3249020:	e0bfff17 	ldw	r2,-4(fp)

#endif   /* HT_LOCALFS */
}
 3249024:	e037883a 	mov	sp,fp
 3249028:	dfc00117 	ldw	ra,4(sp)
 324902c:	df000017 	ldw	fp,0(sp)
 3249030:	dec00204 	addi	sp,sp,8
 3249034:	f800283a 	ret

03249038 <vfopen>:
 * RETURNS: 
 */

VFILE *
vfopen(char * name, char * mode)
{
 3249038:	defffb04 	addi	sp,sp,-20
 324903c:	dfc00415 	stw	ra,16(sp)
 3249040:	df000315 	stw	fp,12(sp)
 3249044:	df000304 	addi	fp,sp,12
 3249048:	e13ffe15 	stw	r4,-8(fp)
 324904c:	e17fff15 	stw	r5,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfopen() passed >%s<,%s\n",name,mode);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 3249050:	01000144 	movi	r4,5
 3249054:	322b4ec0 	call	322b4ec <wait_app_sem>

   vfd = vfopen_locked(name,mode);
 3249058:	e13ffe17 	ldw	r4,-8(fp)
 324905c:	e17fff17 	ldw	r5,-4(fp)
 3249060:	3248cd00 	call	3248cd0 <vfopen_locked>
 3249064:	e0bffd15 	stw	r2,-12(fp)

   vfs_unlock();
 3249068:	01000144 	movi	r4,5
 324906c:	322b5a00 	call	322b5a0 <post_app_sem>

   return vfd;
 3249070:	e0bffd17 	ldw	r2,-12(fp)
}
 3249074:	e037883a 	mov	sp,fp
 3249078:	dfc00117 	ldw	ra,4(sp)
 324907c:	df000017 	ldw	fp,0(sp)
 3249080:	dec00204 	addi	sp,sp,8
 3249084:	f800283a 	ret

03249088 <vfclose_locked>:
 * RETURNS: 
 */

void 
vfclose_locked(VFILE * vfd)
{
 3249088:	defff804 	addi	sp,sp,-32
 324908c:	dfc00715 	stw	ra,28(sp)
 3249090:	df000615 	stw	fp,24(sp)
 3249094:	df000604 	addi	fp,sp,24
 3249098:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;
   VFILE * vlast;

   vlast = NULL;
 324909c:	e03ffd15 	stw	zero,-12(fp)

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
 32490a0:	d0a90c17 	ldw	r2,-23504(gp)
 32490a4:	e0bffe15 	stw	r2,-8(fp)
   while (vtmp)
 32490a8:	00000806 	br	32490cc <vfclose_locked+0x44>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
 32490ac:	e0ffff17 	ldw	r3,-4(fp)
 32490b0:	e0bffe17 	ldw	r2,-8(fp)
 32490b4:	18800826 	beq	r3,r2,32490d8 <vfclose_locked+0x50>
         break;

      /* bump the next and previous pointers along to try the next one */
      vlast = vtmp;
 32490b8:	e0bffe17 	ldw	r2,-8(fp)
 32490bc:	e0bffd15 	stw	r2,-12(fp)
      vtmp = vtmp->next;
 32490c0:	e0bffe17 	ldw	r2,-8(fp)
 32490c4:	10800017 	ldw	r2,0(r2)
 32490c8:	e0bffe15 	stw	r2,-8(fp)
   vlast = NULL;

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
   while (vtmp)
 32490cc:	e0bffe17 	ldw	r2,-8(fp)
 32490d0:	1004c03a 	cmpne	r2,r2,zero
 32490d4:	103ff51e 	bne	r2,zero,32490ac <vfclose_locked+0x24>
      vlast = vtmp;
      vtmp = vtmp->next;
   }

   /* if the passed in handle was not in the list we maintain */
   if (vfd != vtmp)
 32490d8:	e0ffff17 	ldw	r3,-4(fp)
 32490dc:	e0bffe17 	ldw	r2,-8(fp)
 32490e0:	18804e1e 	bne	r3,r2,324921c <vfclose_locked+0x194>

   /* this not really a forever loop. it exists so we can break easily
      and deal with all the ifdefs */
   while (1)
   {
      struct vfs_file * vfp   =  vfd->file;
 32490e4:	e0bfff17 	ldw	r2,-4(fp)
 32490e8:	10800117 	ldw	r2,4(r2)
 32490ec:	e0bffc15 	stw	r2,-16(fp)
      /* vfd->file will be null if somebody unlinked the file after
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
 32490f0:	e0bffc17 	ldw	r2,-16(fp)
 32490f4:	1005003a 	cmpeq	r2,r2,zero
 32490f8:	1000381e 	bne	r2,zero,32491dc <vfclose_locked+0x154>
         break;
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 32490fc:	e0bffc17 	ldw	r2,-16(fp)
 3249100:	10800a17 	ldw	r2,40(r2)
 3249104:	1005003a 	cmpeq	r2,r2,zero
 3249108:	1000081e 	bne	r2,zero,324912c <vfclose_locked+0xa4>
      {
         /* call that file system's fclose() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)(vfp->method);
 324910c:	e0bffc17 	ldw	r2,-16(fp)
 3249110:	10800a17 	ldw	r2,40(r2)
 3249114:	e0bffa15 	stw	r2,-24(fp)

         vfs->r_fclose(vfd);
 3249118:	e0bffa17 	ldw	r2,-24(fp)
 324911c:	10800217 	ldw	r2,8(r2)
 3249120:	e13fff17 	ldw	r4,-4(fp)
 3249124:	103ee83a 	callr	r2
         break;   /* break to list deletion code after end of phoney loop */
 3249128:	00002c06 	br	32491dc <vfclose_locked+0x154>

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 324912c:	e0bffc17 	ldw	r2,-16(fp)
 3249130:	1080058b 	ldhu	r2,22(r2)
 3249134:	10bfffcc 	andi	r2,r2,65535
 3249138:	1080200c 	andi	r2,r2,128
 324913c:	1005003a 	cmpeq	r2,r2,zero
 3249140:	1000261e 	bne	r2,zero,32491dc <vfclose_locked+0x154>
 3249144:	e0bffc17 	ldw	r2,-16(fp)
 3249148:	10c00917 	ldw	r3,36(r2)
 324914c:	e0bffc17 	ldw	r2,-16(fp)
 3249150:	10800817 	ldw	r2,32(r2)
 3249154:	1885c83a 	sub	r2,r3,r2
 3249158:	10804030 	cmpltui	r2,r2,256
 324915c:	10001f1e 	bne	r2,zero,32491dc <vfclose_locked+0x154>
 3249160:	e0bffc17 	ldw	r2,-16(fp)
 3249164:	10800617 	ldw	r2,24(r2)
 3249168:	1005003a 	cmpeq	r2,r2,zero
 324916c:	10001b1e 	bne	r2,zero,32491dc <vfclose_locked+0x154>
          vfp->data) /* this last test is a sanity check */
      {
         /* try to reclaim the unused data */

         /* allocate a new buffer just big enough for the data */
         new_buffer = vf_alloc_buffer(vfp->comp_size);
 3249170:	e0bffc17 	ldw	r2,-16(fp)
 3249174:	11000817 	ldw	r4,32(r2)
 3249178:	3248ba80 	call	3248ba8 <vf_alloc_buffer>
 324917c:	e0bffb15 	stw	r2,-20(fp)

         /* if the allocation worked */
         if (new_buffer)
 3249180:	e0bffb17 	ldw	r2,-20(fp)
 3249184:	1005003a 	cmpeq	r2,r2,zero
 3249188:	1000141e 	bne	r2,zero,32491dc <vfclose_locked+0x154>
         {
            /* copy the old buffer to the new one */
            MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 324918c:	e0bffc17 	ldw	r2,-16(fp)
 3249190:	10c00617 	ldw	r3,24(r2)
 3249194:	e0bffc17 	ldw	r2,-16(fp)
 3249198:	11800817 	ldw	r6,32(r2)
 324919c:	e0bffb17 	ldw	r2,-20(fp)
 32491a0:	1009883a 	mov	r4,r2
 32491a4:	180b883a 	mov	r5,r3
 32491a8:	3206ad00 	call	3206ad0 <memcpy>
            /* free the old buffer */
            vf_free_buffer(vfp->data,vfp->buf_size);
 32491ac:	e0bffc17 	ldw	r2,-16(fp)
 32491b0:	11000617 	ldw	r4,24(r2)
 32491b4:	e0bffc17 	ldw	r2,-16(fp)
 32491b8:	11400917 	ldw	r5,36(r2)
 32491bc:	3248c800 	call	3248c80 <vf_free_buffer>
            /* update the buffer pointer and size to reflect the
               just big enough buffer */
            vfp->data = new_buffer;
 32491c0:	e0fffc17 	ldw	r3,-16(fp)
 32491c4:	e0bffb17 	ldw	r2,-20(fp)
 32491c8:	18800615 	stw	r2,24(r3)
            vfp->buf_size = vfp->comp_size;
 32491cc:	e0bffc17 	ldw	r2,-16(fp)
 32491d0:	10c00817 	ldw	r3,32(r2)
 32491d4:	e0bffc17 	ldw	r2,-16(fp)
 32491d8:	10c00915 	stw	r3,36(r2)
      /* break to list deletion code below */
      break;

   }

   if (vlast)  /* unlink from list of open files */
 32491dc:	e0bffd17 	ldw	r2,-12(fp)
 32491e0:	1005003a 	cmpeq	r2,r2,zero
 32491e4:	1000051e 	bne	r2,zero,32491fc <vfclose_locked+0x174>
      vlast->next = vtmp->next;
 32491e8:	e0bffe17 	ldw	r2,-8(fp)
 32491ec:	10c00017 	ldw	r3,0(r2)
 32491f0:	e0bffd17 	ldw	r2,-12(fp)
 32491f4:	10c00015 	stw	r3,0(r2)
 32491f8:	00000306 	br	3249208 <vfclose_locked+0x180>
   else
      vfiles = vtmp->next;
 32491fc:	e0bffe17 	ldw	r2,-8(fp)
 3249200:	10800017 	ldw	r2,0(r2)
 3249204:	d0a90c15 	stw	r2,-23504(gp)

   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
 3249208:	e13ffe17 	ldw	r4,-8(fp)
 324920c:	322ba280 	call	322ba28 <npfree>
   /* decrement the number of open files */
   vfs_open_files--;
 3249210:	d0a91017 	ldw	r2,-23488(gp)
 3249214:	10bfffc4 	addi	r2,r2,-1
 3249218:	d0a91015 	stw	r2,-23488(gp)
   return;
}
 324921c:	e037883a 	mov	sp,fp
 3249220:	dfc00117 	ldw	ra,4(sp)
 3249224:	df000017 	ldw	fp,0(sp)
 3249228:	dec00204 	addi	sp,sp,8
 324922c:	f800283a 	ret

03249230 <vfclose>:
 *
 * RETURNS: 
 */

void vfclose(VFILE * vfd)
{
 3249230:	defffd04 	addi	sp,sp,-12
 3249234:	dfc00215 	stw	ra,8(sp)
 3249238:	df000115 	stw	fp,4(sp)
 324923c:	df000104 	addi	fp,sp,4
 3249240:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 3249244:	01000144 	movi	r4,5
 3249248:	322b4ec0 	call	322b4ec <wait_app_sem>

   vfclose_locked(vfd);
 324924c:	e13fff17 	ldw	r4,-4(fp)
 3249250:	32490880 	call	3249088 <vfclose_locked>

   vfs_unlock();
 3249254:	01000144 	movi	r4,5
 3249258:	322b5a00 	call	322b5a0 <post_app_sem>
}
 324925c:	e037883a 	mov	sp,fp
 3249260:	dfc00117 	ldw	ra,4(sp)
 3249264:	df000017 	ldw	fp,0(sp)
 3249268:	dec00204 	addi	sp,sp,8
 324926c:	f800283a 	ret

03249270 <vfflush>:
 *
 * RETURNS: 
 */

int vfflush(VFILE * vfd)
{
 3249270:	defffd04 	addi	sp,sp,-12
 3249274:	dfc00215 	stw	ra,8(sp)
 3249278:	df000115 	stw	fp,4(sp)
 324927c:	df000104 	addi	fp,sp,4
 3249280:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 3249284:	01000144 	movi	r4,5
 3249288:	322b4ec0 	call	322b4ec <wait_app_sem>

   printf("vfflush(): This function needs to be implemented\n");
 324928c:	0100c974 	movhi	r4,805
 3249290:	2101a204 	addi	r4,r4,1672
 3249294:	32071080 	call	3207108 <puts>

   vfs_unlock();
 3249298:	01000144 	movi	r4,5
 324929c:	322b5a00 	call	322b5a0 <post_app_sem>
   return(0);
 32492a0:	0005883a 	mov	r2,zero
}
 32492a4:	e037883a 	mov	sp,fp
 32492a8:	dfc00117 	ldw	ra,4(sp)
 32492ac:	df000017 	ldw	fp,0(sp)
 32492b0:	dec00204 	addi	sp,sp,8
 32492b4:	f800283a 	ret

032492b8 <vfgets>:

char * vfgets(char * s, int lim, VFILE * fp) 
{
 32492b8:	defff804 	addi	sp,sp,-32
 32492bc:	dfc00715 	stw	ra,28(sp)
 32492c0:	df000615 	stw	fp,24(sp)
 32492c4:	df000604 	addi	fp,sp,24
 32492c8:	e13ffc15 	stw	r4,-16(fp)
 32492cc:	e17ffd15 	stw	r5,-12(fp)
 32492d0:	e1bffe15 	stw	r6,-8(fp)
   int c;
   char * ret;

   ret = s;
 32492d4:	e0bffc17 	ldw	r2,-16(fp)
 32492d8:	e0bffa15 	stw	r2,-24(fp)
   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 32492dc:	00001106 	br	3249324 <vfgets+0x6c>
      if (( *ret ++ = c) == '\n')
 32492e0:	e0bffb17 	ldw	r2,-20(fp)
 32492e4:	1007883a 	mov	r3,r2
 32492e8:	e0bffa17 	ldw	r2,-24(fp)
 32492ec:	10c00005 	stb	r3,0(r2)
 32492f0:	e0bffa17 	ldw	r2,-24(fp)
 32492f4:	10800003 	ldbu	r2,0(r2)
 32492f8:	10803fcc 	andi	r2,r2,255
 32492fc:	1080201c 	xori	r2,r2,128
 3249300:	10bfe004 	addi	r2,r2,-128
 3249304:	108002a0 	cmpeqi	r2,r2,10
 3249308:	1007883a 	mov	r3,r2
 324930c:	e0bffa17 	ldw	r2,-24(fp)
 3249310:	10800044 	addi	r2,r2,1
 3249314:	e0bffa15 	stw	r2,-24(fp)
 3249318:	18803fcc 	andi	r2,r3,255
 324931c:	1004c03a 	cmpne	r2,r2,zero
 3249320:	10000c1e 	bne	r2,zero,3249354 <vfgets+0x9c>
{
   int c;
   char * ret;

   ret = s;
   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 3249324:	e0bffd17 	ldw	r2,-12(fp)
 3249328:	10bfffc4 	addi	r2,r2,-1
 324932c:	e0bffd15 	stw	r2,-12(fp)
 3249330:	e0bffd17 	ldw	r2,-12(fp)
 3249334:	10800050 	cmplti	r2,r2,1
 3249338:	1000061e 	bne	r2,zero,3249354 <vfgets+0x9c>
 324933c:	e13ffe17 	ldw	r4,-8(fp)
 3249340:	324a0340 	call	324a034 <vgetc>
 3249344:	e0bffb15 	stw	r2,-20(fp)
 3249348:	e0bffb17 	ldw	r2,-20(fp)
 324934c:	10bfffd8 	cmpnei	r2,r2,-1
 3249350:	103fe31e 	bne	r2,zero,32492e0 <vfgets+0x28>
      if (( *ret ++ = c) == '\n')
         break;
   *ret = '\0';
 3249354:	e0bffa17 	ldw	r2,-24(fp)
 3249358:	10000005 	stb	zero,0(r2)
   return ( c == EOF && ret == s) ? NULL : s;
 324935c:	e0bffb17 	ldw	r2,-20(fp)
 3249360:	10bfffd8 	cmpnei	r2,r2,-1
 3249364:	1000031e 	bne	r2,zero,3249374 <vfgets+0xbc>
 3249368:	e0fffa17 	ldw	r3,-24(fp)
 324936c:	e0bffc17 	ldw	r2,-16(fp)
 3249370:	18800326 	beq	r3,r2,3249380 <vfgets+0xc8>
 3249374:	e0bffc17 	ldw	r2,-16(fp)
 3249378:	e0bfff15 	stw	r2,-4(fp)
 324937c:	00000106 	br	3249384 <vfgets+0xcc>
 3249380:	e03fff15 	stw	zero,-4(fp)
 3249384:	e0bfff17 	ldw	r2,-4(fp)
}
 3249388:	e037883a 	mov	sp,fp
 324938c:	dfc00117 	ldw	ra,4(sp)
 3249390:	df000017 	ldw	fp,0(sp)
 3249394:	dec00204 	addi	sp,sp,8
 3249398:	f800283a 	ret

0324939c <vfeof>:
 *
 * RETURNS: 1 if the file pointer is at EOF, otherwise 0
 */
 
int vfeof(VFILE * vfd)
{
 324939c:	defffb04 	addi	sp,sp,-20
 32493a0:	dfc00415 	stw	ra,16(sp)
 32493a4:	df000315 	stw	fp,12(sp)
 32493a8:	df000304 	addi	fp,sp,12
 32493ac:	e13ffe15 	stw	r4,-8(fp)
   int c = 0;
 32493b0:	e03ffd15 	stw	zero,-12(fp)

#ifdef HT_LOCALFS
   return(feof((FILE*)vfd));
#endif
   if ((c = vgetc(vfd)) == EOF )
 32493b4:	e13ffe17 	ldw	r4,-8(fp)
 32493b8:	324a0340 	call	324a034 <vgetc>
 32493bc:	e0bffd15 	stw	r2,-12(fp)
 32493c0:	e0bffd17 	ldw	r2,-12(fp)
 32493c4:	10bfffd8 	cmpnei	r2,r2,-1
 32493c8:	1000031e 	bne	r2,zero,32493d8 <vfeof+0x3c>
   {
      return 1;
 32493cc:	00800044 	movi	r2,1
 32493d0:	e0bfff15 	stw	r2,-4(fp)
 32493d4:	00000106 	br	32493dc <vfeof+0x40>
   }   
   return 0;
 32493d8:	e03fff15 	stw	zero,-4(fp)
 32493dc:	e0bfff17 	ldw	r2,-4(fp)
}
 32493e0:	e037883a 	mov	sp,fp
 32493e4:	dfc00117 	ldw	ra,4(sp)
 32493e8:	df000017 	ldw	fp,0(sp)
 32493ec:	dec00204 	addi	sp,sp,8
 32493f0:	f800283a 	ret

032493f4 <vunlink_flag_open_files>:
 *
 * RETURNS: 
 */

void vunlink_flag_open_files(struct vfs_file * vfp)
{
 32493f4:	defffd04 	addi	sp,sp,-12
 32493f8:	df000215 	stw	fp,8(sp)
 32493fc:	df000204 	addi	fp,sp,8
 3249400:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 3249404:	d0a90c17 	ldw	r2,-23504(gp)
 3249408:	e0bffe15 	stw	r2,-8(fp)
 324940c:	00000906 	br	3249434 <vunlink_flag_open_files+0x40>
   {
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
 3249410:	e0bffe17 	ldw	r2,-8(fp)
 3249414:	10c00117 	ldw	r3,4(r2)
 3249418:	e0bfff17 	ldw	r2,-4(fp)
 324941c:	1880021e 	bne	r3,r2,3249428 <vunlink_flag_open_files+0x34>
         vtmp->file = NULL;
 3249420:	e0bffe17 	ldw	r2,-8(fp)
 3249424:	10000115 	stw	zero,4(r2)
void vunlink_flag_open_files(struct vfs_file * vfp)
{
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 3249428:	e0bffe17 	ldw	r2,-8(fp)
 324942c:	10800017 	ldw	r2,0(r2)
 3249430:	e0bffe15 	stw	r2,-8(fp)
 3249434:	e0bffe17 	ldw	r2,-8(fp)
 3249438:	1004c03a 	cmpne	r2,r2,zero
 324943c:	103ff41e 	bne	r2,zero,3249410 <vunlink_flag_open_files+0x1c>
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
         vtmp->file = NULL;
   }
}
 3249440:	e037883a 	mov	sp,fp
 3249444:	df000017 	ldw	fp,0(sp)
 3249448:	dec00104 	addi	sp,sp,4
 324944c:	f800283a 	ret

03249450 <vunlink>:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
int
vunlink(const char * const_name)
{
 3249450:	defff504 	addi	sp,sp,-44
 3249454:	dfc00a15 	stw	ra,40(sp)
 3249458:	df000915 	stw	fp,36(sp)
 324945c:	df000904 	addi	fp,sp,36
 3249460:	e13ffe15 	stw	r4,-8(fp)
   struct vfs_file * vfp;
   int   rc =  0;
 3249464:	e03ffc15 	stw	zero,-16(fp)
/*
 * Altera Niche Stack Nios port modification:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
   char * name = malloc(strlen(const_name));
 3249468:	e13ffe17 	ldw	r4,-8(fp)
 324946c:	32084480 	call	3208448 <strlen>
 3249470:	1009883a 	mov	r4,r2
 3249474:	324bcac0 	call	324bcac <malloc>
 3249478:	e0bff815 	stw	r2,-32(fp)
   strcpy(name, const_name);
 324947c:	e13ff817 	ldw	r4,-32(fp)
 3249480:	e17ffe17 	ldw	r5,-8(fp)
 3249484:	324bd340 	call	324bd34 <strcpy>
   if (vfs_log_file_name)
      dprintf("vunlink() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 3249488:	01000144 	movi	r4,5
 324948c:	322b4ec0 	call	322b4ec <wait_app_sem>

   /* see if the converted name is one of the one's in our list */
   /* if it isn't */
   if ((vfp = vfslookup_locked(name)) == NULL)
 3249490:	e13ff817 	ldw	r4,-32(fp)
 3249494:	324a07c0 	call	324a07c <vfslookup_locked>
 3249498:	e0bffd15 	stw	r2,-12(fp)
 324949c:	e0bffd17 	ldw	r2,-12(fp)
 32494a0:	1004c03a 	cmpne	r2,r2,zero
 32494a4:	1000071e 	bne	r2,zero,32494c4 <vunlink+0x74>
   {
      vfs_unlock();
 32494a8:	01000144 	movi	r4,5
 32494ac:	322b5a00 	call	322b5a0 <post_app_sem>
#ifdef HT_LOCALFS
      /* default to call on local system */
      return remove(name);
#else
      /* no local file system, so return error condition */
      free(name);
 32494b0:	e13ff817 	ldw	r4,-32(fp)
 32494b4:	324bc980 	call	324bc98 <free>
      return -1;
 32494b8:	00bfffc4 	movi	r2,-1
 32494bc:	e0bfff15 	stw	r2,-4(fp)
 32494c0:	00006506 	br	3249658 <vunlink+0x208>
#ifdef   HT_RWVFS
   /* save the next link pointer since in one path through the code, 
    * the vfs_file structure gets freed before its unlinked from the 
    * list
    */
   vfnext = vfp->next;
 32494c4:	e0bffd17 	ldw	r2,-12(fp)
 32494c8:	10800017 	ldw	r2,0(r2)
 32494cc:	e0bff915 	stw	r2,-28(fp)

   /* search list of files to determine predecessor in list */
   vflast = NULL;
 32494d0:	e03ffa15 	stw	zero,-24(fp)
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 32494d4:	d0a90d17 	ldw	r2,-23500(gp)
 32494d8:	e0bffb15 	stw	r2,-20(fp)
 32494dc:	00000806 	br	3249500 <vunlink+0xb0>
   {
      if (vtmp == vfp)
 32494e0:	e0fffb17 	ldw	r3,-20(fp)
 32494e4:	e0bffd17 	ldw	r2,-12(fp)
 32494e8:	18800826 	beq	r3,r2,324950c <vunlink+0xbc>
         break;
      vflast = vtmp;
 32494ec:	e0bffb17 	ldw	r2,-20(fp)
 32494f0:	e0bffa15 	stw	r2,-24(fp)
    */
   vfnext = vfp->next;

   /* search list of files to determine predecessor in list */
   vflast = NULL;
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 32494f4:	e0bffb17 	ldw	r2,-20(fp)
 32494f8:	10800017 	ldw	r2,0(r2)
 32494fc:	e0bffb15 	stw	r2,-20(fp)
 3249500:	e0bffb17 	ldw	r2,-20(fp)
 3249504:	1004c03a 	cmpne	r2,r2,zero
 3249508:	103ff51e 	bne	r2,zero,32494e0 <vunlink+0x90>
      vflast = vtmp;
   }

   /* this shouldn't happen since vfslookup_locked() already searched
      the list, but just in case */
   if (vtmp == NULL)
 324950c:	e0bffb17 	ldw	r2,-20(fp)
 3249510:	1004c03a 	cmpne	r2,r2,zero
 3249514:	1000081e 	bne	r2,zero,3249538 <vunlink+0xe8>
   {
      dtrap();
 3249518:	322aef00 	call	322aef0 <dtrap>
      vfs_unlock();
 324951c:	01000144 	movi	r4,5
 3249520:	322b5a00 	call	322b5a0 <post_app_sem>
      free(name);
 3249524:	e13ff817 	ldw	r4,-32(fp)
 3249528:	324bc980 	call	324bc98 <free>
      return -1;
 324952c:	00bfffc4 	movi	r2,-1
 3249530:	e0bfff15 	stw	r2,-4(fp)
 3249534:	00004806 	br	3249658 <vunlink+0x208>
   while (1)
   {

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 3249538:	e0bffd17 	ldw	r2,-12(fp)
 324953c:	10800a17 	ldw	r2,40(r2)
 3249540:	1005003a 	cmpeq	r2,r2,zero
 3249544:	1000091e 	bne	r2,zero,324956c <vunlink+0x11c>
      {
         /* call that file system's unlink() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfp->method);
 3249548:	e0bffd17 	ldw	r2,-12(fp)
 324954c:	10800a17 	ldw	r2,40(r2)
 3249550:	e0bff715 	stw	r2,-36(fp)

         rc = vfs->r_unlink(name);
 3249554:	e0bff717 	ldw	r2,-36(fp)
 3249558:	10800817 	ldw	r2,32(r2)
 324955c:	e13ff817 	ldw	r4,-32(fp)
 3249560:	103ee83a 	callr	r2
 3249564:	e0bffc15 	stw	r2,-16(fp)
         break;   /* break to list deletion code after end of phoney loop */
 3249568:	00002806 	br	324960c <vunlink+0x1bc>
      }
#endif   /* HT_EXTDEV */

      /* if the file is not write enabled, return error condition */
      if (!(vfp->flags & VF_WRITE))
 324956c:	e0bffd17 	ldw	r2,-12(fp)
 3249570:	1080058b 	ldhu	r2,22(r2)
 3249574:	10bfffcc 	andi	r2,r2,65535
 3249578:	1080080c 	andi	r2,r2,32
 324957c:	1004c03a 	cmpne	r2,r2,zero
 3249580:	1000071e 	bne	r2,zero,32495a0 <vunlink+0x150>
      {
         vfs_unlock();
 3249584:	01000144 	movi	r4,5
 3249588:	322b5a00 	call	322b5a0 <post_app_sem>
         free(name);
 324958c:	e13ff817 	ldw	r4,-32(fp)
 3249590:	324bc980 	call	324bc98 <free>
         return -1;
 3249594:	00bfffc4 	movi	r2,-1
 3249598:	e0bfff15 	stw	r2,-4(fp)
 324959c:	00002e06 	br	3249658 <vunlink+0x208>
      }

      /* if the data buffer containing the file's data was dynamically
         allocated and is not null */
      if ((vfp->flags & VF_DYNAMICDATA) && (vfp->data))
 32495a0:	e0bffd17 	ldw	r2,-12(fp)
 32495a4:	1080058b 	ldhu	r2,22(r2)
 32495a8:	10bfffcc 	andi	r2,r2,65535
 32495ac:	1080200c 	andi	r2,r2,128
 32495b0:	1005003a 	cmpeq	r2,r2,zero
 32495b4:	1000091e 	bne	r2,zero,32495dc <vunlink+0x18c>
 32495b8:	e0bffd17 	ldw	r2,-12(fp)
 32495bc:	10800617 	ldw	r2,24(r2)
 32495c0:	1005003a 	cmpeq	r2,r2,zero
 32495c4:	1000051e 	bne	r2,zero,32495dc <vunlink+0x18c>
      {
         /* free the buffer */
         vf_free_buffer(vfp->data,vfp->buf_size);
 32495c8:	e0bffd17 	ldw	r2,-12(fp)
 32495cc:	11000617 	ldw	r4,24(r2)
 32495d0:	e0bffd17 	ldw	r2,-12(fp)
 32495d4:	11400917 	ldw	r5,36(r2)
 32495d8:	3248c800 	call	3248c80 <vf_free_buffer>
      }

      /* if the vfs_file structure itself was allocated dynamically */
      if (vfp->flags & VF_DYNAMICINFO)
 32495dc:	e0bffd17 	ldw	r2,-12(fp)
 32495e0:	1080058b 	ldhu	r2,22(r2)
 32495e4:	10bfffcc 	andi	r2,r2,65535
 32495e8:	1080100c 	andi	r2,r2,64
 32495ec:	1005003a 	cmpeq	r2,r2,zero
 32495f0:	1000051e 	bne	r2,zero,3249608 <vunlink+0x1b8>
      {
         /* decrement count of total files */
         vfs_total_dyna_files--;
 32495f4:	d0a91217 	ldw	r2,-23480(gp)
 32495f8:	10bfffc4 	addi	r2,r2,-1
 32495fc:	d0a91215 	stw	r2,-23480(gp)

         /* free the vfs_file structure */
         VFS_VFS_FILE_FREE(vfp);
 3249600:	e13ffd17 	ldw	r4,-12(fp)
 3249604:	322ba280 	call	322ba28 <npfree>
         the vfs_file has been deleted from the list */
#ifdef VFS_AUTO_SYNC
      do_sync = 1;
#endif
      /* we were successful at our unlink */
      rc = 0;
 3249608:	e03ffc15 	stw	zero,-16(fp)

      break;
   }

   /* delete the vfs_file structure from the list headed by vfsfiles */
   if (vflast)
 324960c:	e0bffa17 	ldw	r2,-24(fp)
 3249610:	1005003a 	cmpeq	r2,r2,zero
 3249614:	1000041e 	bne	r2,zero,3249628 <vunlink+0x1d8>
      vflast->next = vfnext;
 3249618:	e0fffa17 	ldw	r3,-24(fp)
 324961c:	e0bff917 	ldw	r2,-28(fp)
 3249620:	18800015 	stw	r2,0(r3)
 3249624:	00000206 	br	3249630 <vunlink+0x1e0>
   else
      vfsfiles = vfnext;
 3249628:	e0bff917 	ldw	r2,-28(fp)
 324962c:	d0a90d15 	stw	r2,-23500(gp)

   /* fix up references to deleted file in list of currently open VFILEs */
   vunlink_flag_open_files(vfp);
 3249630:	e13ffd17 	ldw	r4,-12(fp)
 3249634:	32493f40 	call	32493f4 <vunlink_flag_open_files>

   /* flag that the directory is stale so vfs_sync() knows it has to do
      something */
   vfs_dir_stale = TRUE;
 3249638:	00800044 	movi	r2,1
 324963c:	d0a90f15 	stw	r2,-23492(gp)

   /* unlinks not allowed on read-only VFS */
   rc = -1;

#endif   /* HT_RWVFS */
   vfs_unlock();
 3249640:	01000144 	movi	r4,5
 3249644:	322b5a00 	call	322b5a0 <post_app_sem>
   free(name);
 3249648:	e13ff817 	ldw	r4,-32(fp)
 324964c:	324bc980 	call	324bc98 <free>
   return rc;
 3249650:	e0bffc17 	ldw	r2,-16(fp)
 3249654:	e0bfff15 	stw	r2,-4(fp)
 3249658:	e0bfff17 	ldw	r2,-4(fp)
}
 324965c:	e037883a 	mov	sp,fp
 3249660:	dfc00117 	ldw	ra,4(sp)
 3249664:	df000017 	ldw	fp,0(sp)
 3249668:	dec00204 	addi	sp,sp,8
 324966c:	f800283a 	ret

03249670 <vfread>:
 * RETURNS: 
 */

int 
vfread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 3249670:	defff504 	addi	sp,sp,-44
 3249674:	dfc00a15 	stw	ra,40(sp)
 3249678:	df000915 	stw	fp,36(sp)
 324967c:	df000904 	addi	fp,sp,36
 3249680:	e13ffb15 	stw	r4,-20(fp)
 3249684:	e17ffc15 	stw	r5,-16(fp)
 3249688:	e1bffd15 	stw	r6,-12(fp)
 324968c:	e1fffe15 	stw	r7,-8(fp)
   unsigned bcount;  /* number of bytes put in caller's buffer */

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 3249690:	01000144 	movi	r4,5
 3249694:	322b4ec0 	call	322b4ec <wait_app_sem>

   /* if the file is in our list of open files */
   if (isvfile_locked(vfd))
 3249698:	e13ffe17 	ldw	r4,-8(fp)
 324969c:	324a3e40 	call	324a3e4 <isvfile_locked>
 32496a0:	1005003a 	cmpeq	r2,r2,zero
 32496a4:	1000541e 	bne	r2,zero,32497f8 <vfread+0x188>
   {

#ifdef HT_RWVFS
      /* the caller is trying to read a handle to a file that's been
         deleted, so he gets 0 data back */
      if (vfd->file == NULL)
 32496a8:	e0bffe17 	ldw	r2,-8(fp)
 32496ac:	10800117 	ldw	r2,4(r2)
 32496b0:	1004c03a 	cmpne	r2,r2,zero
 32496b4:	1000041e 	bne	r2,zero,32496c8 <vfread+0x58>
      {
         vfs_unlock();
 32496b8:	01000144 	movi	r4,5
 32496bc:	322b5a00 	call	322b5a0 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 32496c0:	e03fff15 	stw	zero,-4(fp)
 32496c4:	00004f06 	br	3249804 <vfread+0x194>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfd->file->method)
 32496c8:	e0bffe17 	ldw	r2,-8(fp)
 32496cc:	10800117 	ldw	r2,4(r2)
 32496d0:	10800a17 	ldw	r2,40(r2)
 32496d4:	1005003a 	cmpeq	r2,r2,zero
 32496d8:	1000111e 	bne	r2,zero,3249720 <vfread+0xb0>
      {
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 32496dc:	e0bffe17 	ldw	r2,-8(fp)
 32496e0:	10800117 	ldw	r2,4(r2)
 32496e4:	10800a17 	ldw	r2,40(r2)
 32496e8:	e0bff915 	stw	r2,-28(fp)
         int   rc;

         /* call that system's fread() */
         rc = vfs->r_fread(buf,size,items,vfd);
 32496ec:	e0bff917 	ldw	r2,-28(fp)
 32496f0:	10800317 	ldw	r2,12(r2)
 32496f4:	e13ffb17 	ldw	r4,-20(fp)
 32496f8:	e17ffc17 	ldw	r5,-16(fp)
 32496fc:	e1bffd17 	ldw	r6,-12(fp)
 3249700:	e1fffe17 	ldw	r7,-8(fp)
 3249704:	103ee83a 	callr	r2
 3249708:	e0bff815 	stw	r2,-32(fp)
         vfs_unlock();
 324970c:	01000144 	movi	r4,5
 3249710:	322b5a00 	call	322b5a0 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return rc;
 3249714:	e0bff817 	ldw	r2,-32(fp)
 3249718:	e0bfff15 	stw	r2,-4(fp)
 324971c:	00003906 	br	3249804 <vfread+0x194>
#ifdef HT_RWVFS
      /* the data pointer can be NULL if somebody tries to read from 
       * a freshly created file, in which case there is no data in 
       * the file, so return 0
       */
      if (!(vfd->file->data))
 3249720:	e0bffe17 	ldw	r2,-8(fp)
 3249724:	10800117 	ldw	r2,4(r2)
 3249728:	10800617 	ldw	r2,24(r2)
 324972c:	1004c03a 	cmpne	r2,r2,zero
 3249730:	1000041e 	bne	r2,zero,3249744 <vfread+0xd4>
      {
         vfs_unlock();
 3249734:	01000144 	movi	r4,5
 3249738:	322b5a00 	call	322b5a0 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 324973c:	e03fff15 	stw	zero,-4(fp)
 3249740:	00003006 	br	3249804 <vfread+0x194>
      }
#endif   /* HT_RWVFS */

      bcount = items * size;  /* number of bytes to transfer */
 3249744:	e0fffd17 	ldw	r3,-12(fp)
 3249748:	e0bffc17 	ldw	r2,-16(fp)
 324974c:	1885383a 	mul	r2,r3,r2
 3249750:	e0bffa15 	stw	r2,-24(fp)
         return(items); /* filled user buffer, return # items copied */
      }
      else  /* else fall to faster non-compression code */
#endif   /* HTML_COMPRESSION */
      {  /* get here to do simple uncompressed data read */
         unsigned location = vfd->cmploc - vfd->file->data;
 3249754:	e0bffe17 	ldw	r2,-8(fp)
 3249758:	10800217 	ldw	r2,8(r2)
 324975c:	1007883a 	mov	r3,r2
 3249760:	e0bffe17 	ldw	r2,-8(fp)
 3249764:	10800117 	ldw	r2,4(r2)
 3249768:	10800617 	ldw	r2,24(r2)
 324976c:	1885c83a 	sub	r2,r3,r2
 3249770:	e0bff715 	stw	r2,-36(fp)

         if (((unsigned long)location + bcount) > vfd->file->comp_size)
 3249774:	e0fff717 	ldw	r3,-36(fp)
 3249778:	e0bffa17 	ldw	r2,-24(fp)
 324977c:	1887883a 	add	r3,r3,r2
 3249780:	e0bffe17 	ldw	r2,-8(fp)
 3249784:	10800117 	ldw	r2,4(r2)
 3249788:	10800817 	ldw	r2,32(r2)
 324978c:	10c0062e 	bgeu	r2,r3,32497a8 <vfread+0x138>
            bcount = (unsigned)(vfd->file->comp_size - location);
 3249790:	e0bffe17 	ldw	r2,-8(fp)
 3249794:	10800117 	ldw	r2,4(r2)
 3249798:	10c00817 	ldw	r3,32(r2)
 324979c:	e0bff717 	ldw	r2,-36(fp)
 32497a0:	1885c83a 	sub	r2,r3,r2
 32497a4:	e0bffa15 	stw	r2,-24(fp)
         MEMCPY(buf, vfd->cmploc, bcount);
 32497a8:	e0bffe17 	ldw	r2,-8(fp)
 32497ac:	10c00217 	ldw	r3,8(r2)
 32497b0:	e0bffb17 	ldw	r2,-20(fp)
 32497b4:	1009883a 	mov	r4,r2
 32497b8:	180b883a 	mov	r5,r3
 32497bc:	e1bffa17 	ldw	r6,-24(fp)
 32497c0:	3206ad00 	call	3206ad0 <memcpy>
         vfd->cmploc += bcount;
 32497c4:	e0bffe17 	ldw	r2,-8(fp)
 32497c8:	10c00217 	ldw	r3,8(r2)
 32497cc:	e0bffa17 	ldw	r2,-24(fp)
 32497d0:	1887883a 	add	r3,r3,r2
 32497d4:	e0bffe17 	ldw	r2,-8(fp)
 32497d8:	10c00215 	stw	r3,8(r2)
      }
      vfs_unlock();
 32497dc:	01000144 	movi	r4,5
 32497e0:	322b5a00 	call	322b5a0 <post_app_sem>
      IN_PROFILER(PF_FS, PF_EXIT);
      return (bcount/size);
 32497e4:	e13ffa17 	ldw	r4,-24(fp)
 32497e8:	e17ffc17 	ldw	r5,-16(fp)
 32497ec:	32047c00 	call	32047c0 <__udivsi3>
 32497f0:	e0bfff15 	stw	r2,-4(fp)
 32497f4:	00000306 	br	3249804 <vfread+0x194>
   }

   vfs_unlock();
 32497f8:	01000144 	movi	r4,5
 32497fc:	322b5a00 	call	322b5a0 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fread(buf, size, items, (FILE*)vfd));
#else
   return 0;
 3249800:	e03fff15 	stw	zero,-4(fp)
 3249804:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 3249808:	e037883a 	mov	sp,fp
 324980c:	dfc00117 	ldw	ra,4(sp)
 3249810:	df000017 	ldw	fp,0(sp)
 3249814:	dec00204 	addi	sp,sp,8
 3249818:	f800283a 	ret

0324981c <vfwrite_locked>:
 * RETURNS: 
 */

int 
vfwrite_locked(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 324981c:	defff104 	addi	sp,sp,-60
 3249820:	dfc00e15 	stw	ra,56(sp)
 3249824:	df000d15 	stw	fp,52(sp)
 3249828:	df000d04 	addi	fp,sp,52
 324982c:	e13ffb15 	stw	r4,-20(fp)
 3249830:	e17ffc15 	stw	r5,-16(fp)
 3249834:	e1bffd15 	stw	r6,-12(fp)
 3249838:	e1fffe15 	stw	r7,-8(fp)
   unsigned long current_offset;
   struct vfs_file * vfp;
#endif   /* HT_RWVFS */

   /* if the file is not in our list of files */
   if (!isvfile_locked(vfd))
 324983c:	e13ffe17 	ldw	r4,-8(fp)
 3249840:	324a3e40 	call	324a3e4 <isvfile_locked>
 3249844:	1004c03a 	cmpne	r2,r2,zero
 3249848:	1000031e 	bne	r2,zero,3249858 <vfwrite_locked+0x3c>
   {
#ifdef HT_LOCALFS
      /* default to call on local system */
      return(fwrite(buf, size, items, (FILE*)vfd));
#else
      return EBADF;
 324984c:	00800244 	movi	r2,9
 3249850:	e0bfff15 	stw	r2,-4(fp)
 3249854:	0000e506 	br	3249bec <vfwrite_locked+0x3d0>
   }
   /* this file is in our list of files */

#ifdef HT_EXTDEV
   /* if the file was created by an external file system */
   if (vfd->file->method)
 3249858:	e0bffe17 	ldw	r2,-8(fp)
 324985c:	10800117 	ldw	r2,4(r2)
 3249860:	10800a17 	ldw	r2,40(r2)
 3249864:	1005003a 	cmpeq	r2,r2,zero
 3249868:	10000f1e 	bne	r2,zero,32498a8 <vfwrite_locked+0x8c>
   {
      struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 324986c:	e0bffe17 	ldw	r2,-8(fp)
 3249870:	10800117 	ldw	r2,4(r2)
 3249874:	10800a17 	ldw	r2,40(r2)
 3249878:	e0bff715 	stw	r2,-36(fp)
      int   rc;

      /* call that system's fwrite() */
      rc = vfs->r_fwrite(buf,size,items,vfd);
 324987c:	e0bff717 	ldw	r2,-36(fp)
 3249880:	10800417 	ldw	r2,16(r2)
 3249884:	e13ffb17 	ldw	r4,-20(fp)
 3249888:	e17ffc17 	ldw	r5,-16(fp)
 324988c:	e1bffd17 	ldw	r6,-12(fp)
 3249890:	e1fffe17 	ldw	r7,-8(fp)
 3249894:	103ee83a 	callr	r2
 3249898:	e0bff615 	stw	r2,-40(fp)
      return rc;
 324989c:	e0bff617 	ldw	r2,-40(fp)
 32498a0:	e0bfff15 	stw	r2,-4(fp)
 32498a4:	0000d106 	br	3249bec <vfwrite_locked+0x3d0>

#else    /* HT_RWVFS */

   /* the caller is trying to write to a file that's been deleted,
      so he writes 0 data */
   if (vfd->file == NULL)
 32498a8:	e0bffe17 	ldw	r2,-8(fp)
 32498ac:	10800117 	ldw	r2,4(r2)
 32498b0:	1004c03a 	cmpne	r2,r2,zero
 32498b4:	1000021e 	bne	r2,zero,32498c0 <vfwrite_locked+0xa4>
   {
      return 0;
 32498b8:	e03fff15 	stw	zero,-4(fp)
 32498bc:	0000cb06 	br	3249bec <vfwrite_locked+0x3d0>
   }

   vfp = vfd->file;
 32498c0:	e0bffe17 	ldw	r2,-8(fp)
 32498c4:	10800117 	ldw	r2,4(r2)
 32498c8:	e0bff815 	stw	r2,-32(fp)

   /* if the file is not writable, return error condition */
   if (!(vfp->flags & VF_WRITE))
 32498cc:	e0bff817 	ldw	r2,-32(fp)
 32498d0:	1080058b 	ldhu	r2,22(r2)
 32498d4:	10bfffcc 	andi	r2,r2,65535
 32498d8:	1080080c 	andi	r2,r2,32
 32498dc:	1004c03a 	cmpne	r2,r2,zero
 32498e0:	1000051e 	bne	r2,zero,32498f8 <vfwrite_locked+0xdc>
   {
      vfd->error = ENP_FILEIO;
 32498e4:	e0fffe17 	ldw	r3,-8(fp)
 32498e8:	00bff984 	movi	r2,-26
 32498ec:	18800415 	stw	r2,16(r3)
      return 0;
 32498f0:	e03fff15 	stw	zero,-4(fp)
 32498f4:	0000bd06 	br	3249bec <vfwrite_locked+0x3d0>
   }

   /* compute number of bytes to write */
   bcount = size * items;
 32498f8:	e0fffc17 	ldw	r3,-16(fp)
 32498fc:	e0bffd17 	ldw	r2,-12(fp)
 3249900:	1885383a 	mul	r2,r3,r2
 3249904:	e0bffa15 	stw	r2,-24(fp)

   /* get rid of this degenerate case up front */
   if (bcount == 0)
 3249908:	e0bffa17 	ldw	r2,-24(fp)
 324990c:	1004c03a 	cmpne	r2,r2,zero
 3249910:	1000021e 	bne	r2,zero,324991c <vfwrite_locked+0x100>
   {
      return 0;
 3249914:	e03fff15 	stw	zero,-4(fp)
 3249918:	0000b406 	br	3249bec <vfwrite_locked+0x3d0>
   }

   /* if the file currently has no data buffer */
   if (vfp->data == NULL)
 324991c:	e0bff817 	ldw	r2,-32(fp)
 3249920:	10800617 	ldw	r2,24(r2)
 3249924:	1004c03a 	cmpne	r2,r2,zero
 3249928:	1000401e 	bne	r2,zero,3249a2c <vfwrite_locked+0x210>
   {
      /* compute the size of the buffer to be created */
      /* we round up the size of the data to be written so we dont have
         the overhead of a memory allocation on every write */
      unsigned long buf_size = VFS_ROUND_UP((unsigned long)bcount);
 324992c:	e0bffa17 	ldw	r2,-24(fp)
 3249930:	10bfffc4 	addi	r2,r2,-1
 3249934:	1004d37a 	srli	r2,r2,13
 3249938:	1004937a 	slli	r2,r2,13
 324993c:	10880004 	addi	r2,r2,8192
 3249940:	e0bff515 	stw	r2,-44(fp)

      /* allocate a buffer of that size */
      vfp->data = vf_alloc_buffer(buf_size);
 3249944:	e13ff517 	ldw	r4,-44(fp)
 3249948:	3248ba80 	call	3248ba8 <vf_alloc_buffer>
 324994c:	1007883a 	mov	r3,r2
 3249950:	e0bff817 	ldw	r2,-32(fp)
 3249954:	10c00615 	stw	r3,24(r2)

      /* if the allocation failed */
      if (!(vfp->data))
 3249958:	e0bff817 	ldw	r2,-32(fp)
 324995c:	10800617 	ldw	r2,24(r2)
 3249960:	1004c03a 	cmpne	r2,r2,zero
 3249964:	1000051e 	bne	r2,zero,324997c <vfwrite_locked+0x160>
      {
         vfd->error = ENP_NOMEM;
 3249968:	e0fffe17 	ldw	r3,-8(fp)
 324996c:	00bffb04 	movi	r2,-20
 3249970:	18800415 	stw	r2,16(r3)
         return 0;
 3249974:	e03fff15 	stw	zero,-4(fp)
 3249978:	00009c06 	br	3249bec <vfwrite_locked+0x3d0>
      }

      /* store the size of the allocated buffer */
      vfp->buf_size = buf_size;
 324997c:	e0fff817 	ldw	r3,-32(fp)
 3249980:	e0bff517 	ldw	r2,-44(fp)
 3249984:	18800915 	stw	r2,36(r3)

      /* store the number of bytes written in the real and compressed
         file sizes */
      vfp->real_size = bcount;
 3249988:	e0fff817 	ldw	r3,-32(fp)
 324998c:	e0bffa17 	ldw	r2,-24(fp)
 3249990:	18800715 	stw	r2,28(r3)
      vfp->comp_size = bcount;
 3249994:	e0fff817 	ldw	r3,-32(fp)
 3249998:	e0bffa17 	ldw	r2,-24(fp)
 324999c:	18800815 	stw	r2,32(r3)

      /* set the file pointer to the first byte following the last
         byte written */
      vfd->cmploc = vfp->data + bcount;
 32499a0:	e0bff817 	ldw	r2,-32(fp)
 32499a4:	10c00617 	ldw	r3,24(r2)
 32499a8:	e0bffa17 	ldw	r2,-24(fp)
 32499ac:	1887883a 	add	r3,r3,r2
 32499b0:	e0bffe17 	ldw	r2,-8(fp)
 32499b4:	10c00215 	stw	r3,8(r2)

      /* turn off the compression flag */
      vfp->flags &= ~VF_HTMLCOMPRESSED;
 32499b8:	e0bff817 	ldw	r2,-32(fp)
 32499bc:	10c0058b 	ldhu	r3,22(r2)
 32499c0:	00bfff84 	movi	r2,-2
 32499c4:	1884703a 	and	r2,r3,r2
 32499c8:	1007883a 	mov	r3,r2
 32499cc:	e0bff817 	ldw	r2,-32(fp)
 32499d0:	10c0058d 	sth	r3,22(r2)

      /* the data in the file is stale */
      vfp->flags |= VF_STALE;
 32499d4:	e0bff817 	ldw	r2,-32(fp)
 32499d8:	1080058b 	ldhu	r2,22(r2)
 32499dc:	10808014 	ori	r2,r2,512
 32499e0:	1007883a 	mov	r3,r2
 32499e4:	e0bff817 	ldw	r2,-32(fp)
 32499e8:	10c0058d 	sth	r3,22(r2)

      /* the buffer data was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 32499ec:	e0bff817 	ldw	r2,-32(fp)
 32499f0:	1080058b 	ldhu	r2,22(r2)
 32499f4:	10802014 	ori	r2,r2,128
 32499f8:	1007883a 	mov	r3,r2
 32499fc:	e0bff817 	ldw	r2,-32(fp)
 3249a00:	10c0058d 	sth	r3,22(r2)

      /* copy the data to be written to the file buffer */
      MEMCPY(vfp->data,buf,bcount);
 3249a04:	e0bff817 	ldw	r2,-32(fp)
 3249a08:	10800617 	ldw	r2,24(r2)
 3249a0c:	e0fffb17 	ldw	r3,-20(fp)
 3249a10:	1009883a 	mov	r4,r2
 3249a14:	180b883a 	mov	r5,r3
 3249a18:	e1bffa17 	ldw	r6,-24(fp)
 3249a1c:	3206ad00 	call	3206ad0 <memcpy>

      /* return the number of "items" written */
      return items;
 3249a20:	e0bffd17 	ldw	r2,-12(fp)
 3249a24:	e0bfff15 	stw	r2,-4(fp)
 3249a28:	00007006 	br	3249bec <vfwrite_locked+0x3d0>
   }

   /* compute the current offset into the file */
   current_offset = vfd->cmploc - vfp->data;
 3249a2c:	e0bffe17 	ldw	r2,-8(fp)
 3249a30:	10800217 	ldw	r2,8(r2)
 3249a34:	1007883a 	mov	r3,r2
 3249a38:	e0bff817 	ldw	r2,-32(fp)
 3249a3c:	10800617 	ldw	r2,24(r2)
 3249a40:	1885c83a 	sub	r2,r3,r2
 3249a44:	e0bff915 	stw	r2,-28(fp)

   /* if the data to be written wont fit into the file buffer */
   if ((current_offset + bcount) > vfp->buf_size)
 3249a48:	e0fff917 	ldw	r3,-28(fp)
 3249a4c:	e0bffa17 	ldw	r2,-24(fp)
 3249a50:	1887883a 	add	r3,r3,r2
 3249a54:	e0bff817 	ldw	r2,-32(fp)
 3249a58:	10800917 	ldw	r2,36(r2)
 3249a5c:	10c0382e 	bgeu	r2,r3,3249b40 <vfwrite_locked+0x324>
   {
      /* compute the size of a new buffer to hold the data */
      unsigned long new_buf_size = VFS_ROUND_UP(current_offset + bcount);
 3249a60:	e0fff917 	ldw	r3,-28(fp)
 3249a64:	e0bffa17 	ldw	r2,-24(fp)
 3249a68:	1885883a 	add	r2,r3,r2
 3249a6c:	10bfffc4 	addi	r2,r2,-1
 3249a70:	1004d37a 	srli	r2,r2,13
 3249a74:	1004937a 	slli	r2,r2,13
 3249a78:	10880004 	addi	r2,r2,8192
 3249a7c:	e0bff415 	stw	r2,-48(fp)
      unsigned char *new_buffer;

      /* allocate a new buffer */
      new_buffer = vf_alloc_buffer(new_buf_size);
 3249a80:	e13ff417 	ldw	r4,-48(fp)
 3249a84:	3248ba80 	call	3248ba8 <vf_alloc_buffer>
 3249a88:	e0bff315 	stw	r2,-52(fp)

      /* check for allocation failure */
      if (!new_buffer)
 3249a8c:	e0bff317 	ldw	r2,-52(fp)
 3249a90:	1004c03a 	cmpne	r2,r2,zero
 3249a94:	1000051e 	bne	r2,zero,3249aac <vfwrite_locked+0x290>
      {
         vfd->error = ENP_NOMEM;
 3249a98:	e0fffe17 	ldw	r3,-8(fp)
 3249a9c:	00bffb04 	movi	r2,-20
 3249aa0:	18800415 	stw	r2,16(r3)
         return 0;
 3249aa4:	e03fff15 	stw	zero,-4(fp)
 3249aa8:	00005006 	br	3249bec <vfwrite_locked+0x3d0>
      }

      /* copy the old buffer contents to the new buffer */
      MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 3249aac:	e0bff817 	ldw	r2,-32(fp)
 3249ab0:	10c00617 	ldw	r3,24(r2)
 3249ab4:	e0bff817 	ldw	r2,-32(fp)
 3249ab8:	11800817 	ldw	r6,32(r2)
 3249abc:	e0bff317 	ldw	r2,-52(fp)
 3249ac0:	1009883a 	mov	r4,r2
 3249ac4:	180b883a 	mov	r5,r3
 3249ac8:	3206ad00 	call	3206ad0 <memcpy>

      /* if the old buffer had been dynamically allocated */
      if (vfp->flags & VF_DYNAMICDATA)
 3249acc:	e0bff817 	ldw	r2,-32(fp)
 3249ad0:	1080058b 	ldhu	r2,22(r2)
 3249ad4:	10bfffcc 	andi	r2,r2,65535
 3249ad8:	1080200c 	andi	r2,r2,128
 3249adc:	1005003a 	cmpeq	r2,r2,zero
 3249ae0:	1000051e 	bne	r2,zero,3249af8 <vfwrite_locked+0x2dc>
      {
         /* free it */
         vf_free_buffer(vfp->data,vfp->buf_size);
 3249ae4:	e0bff817 	ldw	r2,-32(fp)
 3249ae8:	11000617 	ldw	r4,24(r2)
 3249aec:	e0bff817 	ldw	r2,-32(fp)
 3249af0:	11400917 	ldw	r5,36(r2)
 3249af4:	3248c800 	call	3248c80 <vf_free_buffer>
      }

      /* store the new buffer in the file structure */
      vfp->data = new_buffer;
 3249af8:	e0fff817 	ldw	r3,-32(fp)
 3249afc:	e0bff317 	ldw	r2,-52(fp)
 3249b00:	18800615 	stw	r2,24(r3)

      /* store the new buffer size in the file structure */
      vfp->buf_size = new_buf_size;
 3249b04:	e0fff817 	ldw	r3,-32(fp)
 3249b08:	e0bff417 	ldw	r2,-48(fp)
 3249b0c:	18800915 	stw	r2,36(r3)

      /* the new buffer was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 3249b10:	e0bff817 	ldw	r2,-32(fp)
 3249b14:	1080058b 	ldhu	r2,22(r2)
 3249b18:	10802014 	ori	r2,r2,128
 3249b1c:	1007883a 	mov	r3,r2
 3249b20:	e0bff817 	ldw	r2,-32(fp)
 3249b24:	10c0058d 	sth	r3,22(r2)
       * buffer note that this means the VFS does not support 
       * simultaneous opens of the same file, since for that to work, 
       * all the other cmploc's that point to this file would 
       * have to be updated also 
       */
      vfd->cmploc = vfp->data + current_offset;
 3249b28:	e0bff817 	ldw	r2,-32(fp)
 3249b2c:	10c00617 	ldw	r3,24(r2)
 3249b30:	e0bff917 	ldw	r2,-28(fp)
 3249b34:	1887883a 	add	r3,r3,r2
 3249b38:	e0bffe17 	ldw	r2,-8(fp)
 3249b3c:	10c00215 	stw	r3,8(r2)
   }

   /* copy the data to the current file pointer */
   MEMCPY(vfd->cmploc,buf,bcount);
 3249b40:	e0bffe17 	ldw	r2,-8(fp)
 3249b44:	10800217 	ldw	r2,8(r2)
 3249b48:	e0fffb17 	ldw	r3,-20(fp)
 3249b4c:	1009883a 	mov	r4,r2
 3249b50:	180b883a 	mov	r5,r3
 3249b54:	e1bffa17 	ldw	r6,-24(fp)
 3249b58:	3206ad00 	call	3206ad0 <memcpy>

   /* update the current file pointer */
   vfd->cmploc += bcount;
 3249b5c:	e0bffe17 	ldw	r2,-8(fp)
 3249b60:	10c00217 	ldw	r3,8(r2)
 3249b64:	e0bffa17 	ldw	r2,-24(fp)
 3249b68:	1887883a 	add	r3,r3,r2
 3249b6c:	e0bffe17 	ldw	r2,-8(fp)
 3249b70:	10c00215 	stw	r3,8(r2)

   /* if the resulting current offset is greater than the file size */
   if (current_offset + bcount > vfp->comp_size)
 3249b74:	e0fff917 	ldw	r3,-28(fp)
 3249b78:	e0bffa17 	ldw	r2,-24(fp)
 3249b7c:	1887883a 	add	r3,r3,r2
 3249b80:	e0bff817 	ldw	r2,-32(fp)
 3249b84:	10800817 	ldw	r2,32(r2)
 3249b88:	10c0052e 	bgeu	r2,r3,3249ba0 <vfwrite_locked+0x384>
   {
      /* update the "compressed" file size */
      vfp->comp_size = current_offset + bcount;
 3249b8c:	e0fff917 	ldw	r3,-28(fp)
 3249b90:	e0bffa17 	ldw	r2,-24(fp)
 3249b94:	1887883a 	add	r3,r3,r2
 3249b98:	e0bff817 	ldw	r2,-32(fp)
 3249b9c:	10c00815 	stw	r3,32(r2)
   }

   /* since we turn off the compression bit below, the "real" size and
      the compressed size must be the same */
   vfp->real_size = vfp->comp_size;
 3249ba0:	e0bff817 	ldw	r2,-32(fp)
 3249ba4:	10c00817 	ldw	r3,32(r2)
 3249ba8:	e0bff817 	ldw	r2,-32(fp)
 3249bac:	10c00715 	stw	r3,28(r2)

   /* turn off the compression flag */
   vfp->flags &= ~VF_HTMLCOMPRESSED;
 3249bb0:	e0bff817 	ldw	r2,-32(fp)
 3249bb4:	10c0058b 	ldhu	r3,22(r2)
 3249bb8:	00bfff84 	movi	r2,-2
 3249bbc:	1884703a 	and	r2,r3,r2
 3249bc0:	1007883a 	mov	r3,r2
 3249bc4:	e0bff817 	ldw	r2,-32(fp)
 3249bc8:	10c0058d 	sth	r3,22(r2)

   /* the data in the file is stale */
   vfp->flags |= VF_STALE;
 3249bcc:	e0bff817 	ldw	r2,-32(fp)
 3249bd0:	1080058b 	ldhu	r2,22(r2)
 3249bd4:	10808014 	ori	r2,r2,512
 3249bd8:	1007883a 	mov	r3,r2
 3249bdc:	e0bff817 	ldw	r2,-32(fp)
 3249be0:	10c0058d 	sth	r3,22(r2)

   /* return the number of "items" written */
   return items;
 3249be4:	e0bffd17 	ldw	r2,-12(fp)
 3249be8:	e0bfff15 	stw	r2,-4(fp)
 3249bec:	e0bfff17 	ldw	r2,-4(fp)

#endif   /* HT_RWVFS */
}
 3249bf0:	e037883a 	mov	sp,fp
 3249bf4:	dfc00117 	ldw	ra,4(sp)
 3249bf8:	df000017 	ldw	fp,0(sp)
 3249bfc:	dec00204 	addi	sp,sp,8
 3249c00:	f800283a 	ret

03249c04 <vfwrite>:
 * RETURNS: 
 */

int
vfwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 3249c04:	defff904 	addi	sp,sp,-28
 3249c08:	dfc00615 	stw	ra,24(sp)
 3249c0c:	df000515 	stw	fp,20(sp)
 3249c10:	df000504 	addi	fp,sp,20
 3249c14:	e13ffc15 	stw	r4,-16(fp)
 3249c18:	e17ffd15 	stw	r5,-12(fp)
 3249c1c:	e1bffe15 	stw	r6,-8(fp)
 3249c20:	e1ffff15 	stw	r7,-4(fp)
   int   rc;

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 3249c24:	01000144 	movi	r4,5
 3249c28:	322b4ec0 	call	322b4ec <wait_app_sem>

   /* do the write */
   rc = vfwrite_locked(buf, size, items, vfd);
 3249c2c:	e13ffc17 	ldw	r4,-16(fp)
 3249c30:	e17ffd17 	ldw	r5,-12(fp)
 3249c34:	e1bffe17 	ldw	r6,-8(fp)
 3249c38:	e1ffff17 	ldw	r7,-4(fp)
 3249c3c:	324981c0 	call	324981c <vfwrite_locked>
 3249c40:	e0bffb15 	stw	r2,-20(fp)

   /* unlock the VFS */
   vfs_unlock();
 3249c44:	01000144 	movi	r4,5
 3249c48:	322b5a00 	call	322b5a0 <post_app_sem>

   IN_PROFILER(PF_FS, PF_EXIT);

   return rc;
 3249c4c:	e0bffb17 	ldw	r2,-20(fp)
}
 3249c50:	e037883a 	mov	sp,fp
 3249c54:	dfc00117 	ldw	ra,4(sp)
 3249c58:	df000017 	ldw	fp,0(sp)
 3249c5c:	dec00204 	addi	sp,sp,8
 3249c60:	f800283a 	ret

03249c64 <vfseek>:
 * RETURNS: 
 */

int 
vfseek(VFILE * vfd, long offset, int mode)
{
 3249c64:	defff704 	addi	sp,sp,-36
 3249c68:	dfc00815 	stw	ra,32(sp)
 3249c6c:	df000715 	stw	fp,28(sp)
 3249c70:	df000704 	addi	fp,sp,28
 3249c74:	e13ffb15 	stw	r4,-20(fp)
 3249c78:	e17ffc15 	stw	r5,-16(fp)
 3249c7c:	e1bffd15 	stw	r6,-12(fp)
   /* lock the VFS */
   vfs_lock();
 3249c80:	01000144 	movi	r4,5
 3249c84:	322b4ec0 	call	322b4ec <wait_app_sem>

   if (isvfile_locked(vfd))
 3249c88:	e13ffb17 	ldw	r4,-20(fp)
 3249c8c:	324a3e40 	call	324a3e4 <isvfile_locked>
 3249c90:	1005003a 	cmpeq	r2,r2,zero
 3249c94:	1000481e 	bne	r2,zero,3249db8 <vfseek+0x154>
   {
#ifdef HT_RWVFS
      /* the caller is trying to seek a file that's been deleted,
         so return an error indication */
      if (vfd->file == NULL)
 3249c98:	e0bffb17 	ldw	r2,-20(fp)
 3249c9c:	10800117 	ldw	r2,4(r2)
 3249ca0:	1004c03a 	cmpne	r2,r2,zero
 3249ca4:	1000051e 	bne	r2,zero,3249cbc <vfseek+0x58>
      {
         vfs_unlock();
 3249ca8:	01000144 	movi	r4,5
 3249cac:	322b5a00 	call	322b5a0 <post_app_sem>
         return -1;
 3249cb0:	00bfffc4 	movi	r2,-1
 3249cb4:	e0bffe15 	stw	r2,-8(fp)
 3249cb8:	00004306 	br	3249dc8 <vfseek+0x164>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 3249cbc:	e0bffb17 	ldw	r2,-20(fp)
 3249cc0:	10800117 	ldw	r2,4(r2)
 3249cc4:	10800a17 	ldw	r2,40(r2)
 3249cc8:	1005003a 	cmpeq	r2,r2,zero
 3249ccc:	1000101e 	bne	r2,zero,3249d10 <vfseek+0xac>
      {
         struct vfroutines *vfp = (struct vfroutines*)(vfd->file->method);
 3249cd0:	e0bffb17 	ldw	r2,-20(fp)
 3249cd4:	10800117 	ldw	r2,4(r2)
 3249cd8:	10800a17 	ldw	r2,40(r2)
 3249cdc:	e0bffa15 	stw	r2,-24(fp)
         int   rc;

         rc = vfp->r_fseek(vfd, offset, mode);
 3249ce0:	e0bffa17 	ldw	r2,-24(fp)
 3249ce4:	10800517 	ldw	r2,20(r2)
 3249ce8:	e13ffb17 	ldw	r4,-20(fp)
 3249cec:	e17ffc17 	ldw	r5,-16(fp)
 3249cf0:	e1bffd17 	ldw	r6,-12(fp)
 3249cf4:	103ee83a 	callr	r2
 3249cf8:	e0bff915 	stw	r2,-28(fp)
         vfs_unlock();
 3249cfc:	01000144 	movi	r4,5
 3249d00:	322b5a00 	call	322b5a0 <post_app_sem>
         return rc;
 3249d04:	e0fff917 	ldw	r3,-28(fp)
 3249d08:	e0fffe15 	stw	r3,-8(fp)
 3249d0c:	00002e06 	br	3249dc8 <vfseek+0x164>
      }
#endif   /* HT_EXTDEV */
      /* this vfseek() currently only supports seek to exact
         end or begining of file */
      switch (mode)
 3249d10:	e0bffd17 	ldw	r2,-12(fp)
 3249d14:	e0bfff15 	stw	r2,-4(fp)
 3249d18:	e0ffff17 	ldw	r3,-4(fp)
 3249d1c:	18800060 	cmpeqi	r2,r3,1
 3249d20:	10000f1e 	bne	r2,zero,3249d60 <vfseek+0xfc>
 3249d24:	e0ffff17 	ldw	r3,-4(fp)
 3249d28:	188000a0 	cmpeqi	r2,r3,2
 3249d2c:	1000131e 	bne	r2,zero,3249d7c <vfseek+0x118>
 3249d30:	e0ffff17 	ldw	r3,-4(fp)
 3249d34:	1805003a 	cmpeq	r2,r3,zero
 3249d38:	1000011e 	bne	r2,zero,3249d40 <vfseek+0xdc>
 3249d3c:	00001a06 	br	3249da8 <vfseek+0x144>
      {
      case SEEK_SET:
         vfd->cmploc = vfd->file->data + offset;
 3249d40:	e0bffb17 	ldw	r2,-20(fp)
 3249d44:	10800117 	ldw	r2,4(r2)
 3249d48:	10c00617 	ldw	r3,24(r2)
 3249d4c:	e0bffc17 	ldw	r2,-16(fp)
 3249d50:	1887883a 	add	r3,r3,r2
 3249d54:	e0bffb17 	ldw	r2,-20(fp)
 3249d58:	10c00215 	stw	r3,8(r2)
         break;
 3249d5c:	00001206 	br	3249da8 <vfseek+0x144>
      case SEEK_CUR:
         /* If the file is compressed, then the following
          * adjustment is inaccurate. Currently we don't have
          * any scenario where this happens. - handle later */
         vfd->cmploc += offset; 
 3249d60:	e0bffb17 	ldw	r2,-20(fp)
 3249d64:	10c00217 	ldw	r3,8(r2)
 3249d68:	e0bffc17 	ldw	r2,-16(fp)
 3249d6c:	1887883a 	add	r3,r3,r2
 3249d70:	e0bffb17 	ldw	r2,-20(fp)
 3249d74:	10c00215 	stw	r3,8(r2)
         break;
 3249d78:	00000b06 	br	3249da8 <vfseek+0x144>
      case SEEK_END:
         vfd->cmploc = vfd->file->data + vfd->file->comp_size + offset;
 3249d7c:	e0bffb17 	ldw	r2,-20(fp)
 3249d80:	10800117 	ldw	r2,4(r2)
 3249d84:	10c00617 	ldw	r3,24(r2)
 3249d88:	e0bffb17 	ldw	r2,-20(fp)
 3249d8c:	10800117 	ldw	r2,4(r2)
 3249d90:	10800817 	ldw	r2,32(r2)
 3249d94:	1887883a 	add	r3,r3,r2
 3249d98:	e0bffc17 	ldw	r2,-16(fp)
 3249d9c:	1887883a 	add	r3,r3,r2
 3249da0:	e0bffb17 	ldw	r2,-20(fp)
 3249da4:	10c00215 	stw	r3,8(r2)
         break;
      }
      vfs_unlock();
 3249da8:	01000144 	movi	r4,5
 3249dac:	322b5a00 	call	322b5a0 <post_app_sem>
      return(0);
 3249db0:	e03ffe15 	stw	zero,-8(fp)
 3249db4:	00000406 	br	3249dc8 <vfseek+0x164>
   }

   vfs_unlock();
 3249db8:	01000144 	movi	r4,5
 3249dbc:	322b5a00 	call	322b5a0 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fseek((FILE*)vfd, offset, mode));
#else
   return -1;
 3249dc0:	00bfffc4 	movi	r2,-1
 3249dc4:	e0bffe15 	stw	r2,-8(fp)
 3249dc8:	e0bffe17 	ldw	r2,-8(fp)
#endif   /* HT_LOCALFS */
}
 3249dcc:	e037883a 	mov	sp,fp
 3249dd0:	dfc00117 	ldw	ra,4(sp)
 3249dd4:	df000017 	ldw	fp,0(sp)
 3249dd8:	dec00204 	addi	sp,sp,8
 3249ddc:	f800283a 	ret

03249de0 <vftell>:
 * RETURNS: 
 */

long
vftell(VFILE * vfd)
{
 3249de0:	defffa04 	addi	sp,sp,-24
 3249de4:	dfc00515 	stw	ra,20(sp)
 3249de8:	df000415 	stw	fp,16(sp)
 3249dec:	df000404 	addi	fp,sp,16
 3249df0:	e13ffe15 	stw	r4,-8(fp)
   /* lock the VFS */
   vfs_lock();
 3249df4:	01000144 	movi	r4,5
 3249df8:	322b4ec0 	call	322b4ec <wait_app_sem>

   if (isvfile_locked(vfd))
 3249dfc:	e13ffe17 	ldw	r4,-8(fp)
 3249e00:	324a3e40 	call	324a3e4 <isvfile_locked>
 3249e04:	1005003a 	cmpeq	r2,r2,zero
 3249e08:	1000381e 	bne	r2,zero,3249eec <vftell+0x10c>
   {
#ifdef HT_RWVFS
      /* the caller is trying to ftell a deleted file,
         so return an error condition */
      if (vfd->file == NULL)
 3249e0c:	e0bffe17 	ldw	r2,-8(fp)
 3249e10:	10800117 	ldw	r2,4(r2)
 3249e14:	1004c03a 	cmpne	r2,r2,zero
 3249e18:	1000051e 	bne	r2,zero,3249e30 <vftell+0x50>
      {
         vfs_unlock();
 3249e1c:	01000144 	movi	r4,5
 3249e20:	322b5a00 	call	322b5a0 <post_app_sem>
         return -1;
 3249e24:	00bfffc4 	movi	r2,-1
 3249e28:	e0bfff15 	stw	r2,-4(fp)
 3249e2c:	00003306 	br	3249efc <vftell+0x11c>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 3249e30:	e0bffe17 	ldw	r2,-8(fp)
 3249e34:	10800117 	ldw	r2,4(r2)
 3249e38:	10800a17 	ldw	r2,40(r2)
 3249e3c:	1005003a 	cmpeq	r2,r2,zero
 3249e40:	10000e1e 	bne	r2,zero,3249e7c <vftell+0x9c>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 3249e44:	e0bffe17 	ldw	r2,-8(fp)
 3249e48:	10800117 	ldw	r2,4(r2)
 3249e4c:	10800a17 	ldw	r2,40(r2)
 3249e50:	e0bffd15 	stw	r2,-12(fp)
         long  rc;

         rc = vfp->r_ftell(vfd);
 3249e54:	e0bffd17 	ldw	r2,-12(fp)
 3249e58:	10800617 	ldw	r2,24(r2)
 3249e5c:	e13ffe17 	ldw	r4,-8(fp)
 3249e60:	103ee83a 	callr	r2
 3249e64:	e0bffc15 	stw	r2,-16(fp)
         vfs_unlock();
 3249e68:	01000144 	movi	r4,5
 3249e6c:	322b5a00 	call	322b5a0 <post_app_sem>
         return rc;
 3249e70:	e0bffc17 	ldw	r2,-16(fp)
 3249e74:	e0bfff15 	stw	r2,-4(fp)
 3249e78:	00002006 	br	3249efc <vftell+0x11c>
      }
#endif   /* HT_EXTDEV */
      /* if file has been fseeked to end, return uncompressed size.
         else return current location in compression stream */
      if (vfd->cmploc == vfd->file->data + vfd->file->comp_size)
 3249e7c:	e0bffe17 	ldw	r2,-8(fp)
 3249e80:	11000217 	ldw	r4,8(r2)
 3249e84:	e0bffe17 	ldw	r2,-8(fp)
 3249e88:	10800117 	ldw	r2,4(r2)
 3249e8c:	10c00617 	ldw	r3,24(r2)
 3249e90:	e0bffe17 	ldw	r2,-8(fp)
 3249e94:	10800117 	ldw	r2,4(r2)
 3249e98:	10800817 	ldw	r2,32(r2)
 3249e9c:	1885883a 	add	r2,r3,r2
 3249ea0:	2080071e 	bne	r4,r2,3249ec0 <vftell+0xe0>
      {
         vfs_unlock();
 3249ea4:	01000144 	movi	r4,5
 3249ea8:	322b5a00 	call	322b5a0 <post_app_sem>

         return vfd->file->comp_size;
 3249eac:	e0bffe17 	ldw	r2,-8(fp)
 3249eb0:	10800117 	ldw	r2,4(r2)
 3249eb4:	10800817 	ldw	r2,32(r2)
 3249eb8:	e0bfff15 	stw	r2,-4(fp)
 3249ebc:	00000f06 	br	3249efc <vftell+0x11c>
      }
      else
      {
         vfs_unlock();
 3249ec0:	01000144 	movi	r4,5
 3249ec4:	322b5a00 	call	322b5a0 <post_app_sem>

         return (vfd->cmploc - vfd->file->data);
 3249ec8:	e0bffe17 	ldw	r2,-8(fp)
 3249ecc:	10800217 	ldw	r2,8(r2)
 3249ed0:	1007883a 	mov	r3,r2
 3249ed4:	e0bffe17 	ldw	r2,-8(fp)
 3249ed8:	10800117 	ldw	r2,4(r2)
 3249edc:	10800617 	ldw	r2,24(r2)
 3249ee0:	1887c83a 	sub	r3,r3,r2
 3249ee4:	e0ffff15 	stw	r3,-4(fp)
 3249ee8:	00000406 	br	3249efc <vftell+0x11c>
      }
   }

   vfs_unlock();
 3249eec:	01000144 	movi	r4,5
 3249ef0:	322b5a00 	call	322b5a0 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(ftell((FILE*)vfd));
#else
   return EBADF;
 3249ef4:	00800244 	movi	r2,9
 3249ef8:	e0bfff15 	stw	r2,-4(fp)
 3249efc:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 3249f00:	e037883a 	mov	sp,fp
 3249f04:	dfc00117 	ldw	ra,4(sp)
 3249f08:	df000017 	ldw	fp,0(sp)
 3249f0c:	dec00204 	addi	sp,sp,8
 3249f10:	f800283a 	ret

03249f14 <vgetc_locked>:
 * RETURNS: 
 */

int
vgetc_locked(VFILE * vfd)
{
 3249f14:	defffa04 	addi	sp,sp,-24
 3249f18:	dfc00515 	stw	ra,20(sp)
 3249f1c:	df000415 	stw	fp,16(sp)
 3249f20:	df000404 	addi	fp,sp,16
 3249f24:	e13ffe15 	stw	r4,-8(fp)
   int   chr;

   if (isvfile_locked(vfd))
 3249f28:	e13ffe17 	ldw	r4,-8(fp)
 3249f2c:	324a3e40 	call	324a3e4 <isvfile_locked>
 3249f30:	1005003a 	cmpeq	r2,r2,zero
 3249f34:	1000361e 	bne	r2,zero,324a010 <vgetc_locked+0xfc>
   {
#ifdef HT_RWVFS
      /* the caller is trying to read a file that's been deleted,
         so return an error condition */
      if (vfd->file == NULL)
 3249f38:	e0bffe17 	ldw	r2,-8(fp)
 3249f3c:	10800117 	ldw	r2,4(r2)
 3249f40:	1004c03a 	cmpne	r2,r2,zero
 3249f44:	1000031e 	bne	r2,zero,3249f54 <vgetc_locked+0x40>
      {
         return EOF;
 3249f48:	00bfffc4 	movi	r2,-1
 3249f4c:	e0bfff15 	stw	r2,-4(fp)
 3249f50:	00003206 	br	324a01c <vgetc_locked+0x108>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 3249f54:	e0bffe17 	ldw	r2,-8(fp)
 3249f58:	10800117 	ldw	r2,4(r2)
 3249f5c:	10800a17 	ldw	r2,40(r2)
 3249f60:	1005003a 	cmpeq	r2,r2,zero
 3249f64:	10000a1e 	bne	r2,zero,3249f90 <vgetc_locked+0x7c>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 3249f68:	e0bffe17 	ldw	r2,-8(fp)
 3249f6c:	10800117 	ldw	r2,4(r2)
 3249f70:	10800a17 	ldw	r2,40(r2)
 3249f74:	e0bffc15 	stw	r2,-16(fp)
         return (vfp->r_fgetc(vfd));
 3249f78:	e0bffc17 	ldw	r2,-16(fp)
 3249f7c:	10800717 	ldw	r2,28(r2)
 3249f80:	e13ffe17 	ldw	r4,-8(fp)
 3249f84:	103ee83a 	callr	r2
 3249f88:	e0bfff15 	stw	r2,-4(fp)
 3249f8c:	00002306 	br	324a01c <vgetc_locked+0x108>
#endif   /* HT_EXTDEV */

#ifdef HT_RWVFS
      /* a freshly created file might not have a data buffer associated
         with it yet */
      if (vfd->file->data == NULL)
 3249f90:	e0bffe17 	ldw	r2,-8(fp)
 3249f94:	10800117 	ldw	r2,4(r2)
 3249f98:	10800617 	ldw	r2,24(r2)
 3249f9c:	1004c03a 	cmpne	r2,r2,zero
 3249fa0:	1000031e 	bne	r2,zero,3249fb0 <vgetc_locked+0x9c>
         return EOF;
 3249fa4:	00bfffc4 	movi	r2,-1
 3249fa8:	e0bfff15 	stw	r2,-4(fp)
 3249fac:	00001b06 	br	324a01c <vgetc_locked+0x108>
      }
      else  /* HTML compression flag not set */
      {
#endif   /* HTML_COMPRESSION */
         /* Check to see if read has advanced to end of file */
         if (vfd->cmploc >= (vfd->file->data + vfd->file->comp_size))
 3249fb0:	e0bffe17 	ldw	r2,-8(fp)
 3249fb4:	11000217 	ldw	r4,8(r2)
 3249fb8:	e0bffe17 	ldw	r2,-8(fp)
 3249fbc:	10800117 	ldw	r2,4(r2)
 3249fc0:	10c00617 	ldw	r3,24(r2)
 3249fc4:	e0bffe17 	ldw	r2,-8(fp)
 3249fc8:	10800117 	ldw	r2,4(r2)
 3249fcc:	10800817 	ldw	r2,32(r2)
 3249fd0:	1885883a 	add	r2,r3,r2
 3249fd4:	20800336 	bltu	r4,r2,3249fe4 <vgetc_locked+0xd0>
            chr = EOF;
 3249fd8:	00bfffc4 	movi	r2,-1
 3249fdc:	e0bffd15 	stw	r2,-12(fp)
 3249fe0:	00000806 	br	324a004 <vgetc_locked+0xf0>
         else  /* else just get next char to return */
            chr = *(vfd->cmploc++);
 3249fe4:	e0bffe17 	ldw	r2,-8(fp)
 3249fe8:	10c00217 	ldw	r3,8(r2)
 3249fec:	18800003 	ldbu	r2,0(r3)
 3249ff0:	10803fcc 	andi	r2,r2,255
 3249ff4:	e0bffd15 	stw	r2,-12(fp)
 3249ff8:	18c00044 	addi	r3,r3,1
 3249ffc:	e0bffe17 	ldw	r2,-8(fp)
 324a000:	10c00215 	stw	r3,8(r2)
#ifdef HTML_COMPRESSION
      }  /* need to close brace form if...else; */
#endif   /* HTML_COMPRESSION */

      return chr;
 324a004:	e0bffd17 	ldw	r2,-12(fp)
 324a008:	e0bfff15 	stw	r2,-4(fp)
 324a00c:	00000306 	br	324a01c <vgetc_locked+0x108>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(getc((FILE*)vfd));
#else
   dtrap(); /* can this happen? */
 324a010:	322aef00 	call	322aef0 <dtrap>
   return EOF;
 324a014:	00bfffc4 	movi	r2,-1
 324a018:	e0bfff15 	stw	r2,-4(fp)
 324a01c:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 324a020:	e037883a 	mov	sp,fp
 324a024:	dfc00117 	ldw	ra,4(sp)
 324a028:	df000017 	ldw	fp,0(sp)
 324a02c:	dec00204 	addi	sp,sp,8
 324a030:	f800283a 	ret

0324a034 <vgetc>:
 * RETURNS: 
 */

int
vgetc(VFILE * vfd)
{
 324a034:	defffc04 	addi	sp,sp,-16
 324a038:	dfc00315 	stw	ra,12(sp)
 324a03c:	df000215 	stw	fp,8(sp)
 324a040:	df000204 	addi	fp,sp,8
 324a044:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 324a048:	01000144 	movi	r4,5
 324a04c:	322b4ec0 	call	322b4ec <wait_app_sem>

   /* get the character */
   rc = vgetc_locked(vfd);
 324a050:	e13fff17 	ldw	r4,-4(fp)
 324a054:	3249f140 	call	3249f14 <vgetc_locked>
 324a058:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 324a05c:	01000144 	movi	r4,5
 324a060:	322b5a00 	call	322b5a0 <post_app_sem>
   return rc;
 324a064:	e0bffe17 	ldw	r2,-8(fp)
}
 324a068:	e037883a 	mov	sp,fp
 324a06c:	dfc00117 	ldw	ra,4(sp)
 324a070:	df000017 	ldw	fp,0(sp)
 324a074:	dec00204 	addi	sp,sp,8
 324a078:	f800283a 	ret

0324a07c <vfslookup_locked>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup_locked(char * name)
{
 324a07c:	defffa04 	addi	sp,sp,-24
 324a080:	dfc00515 	stw	ra,20(sp)
 324a084:	df000415 	stw	fp,16(sp)
 324a088:	df000404 	addi	fp,sp,16
 324a08c:	e13ffe15 	stw	r4,-8(fp)

#ifdef VFS_STRIPPATH
   char *   cp;

   /* If root path is prepended to name, skip past it */
   if (*name == '/' || *name == '\\')
 324a090:	e0bffe17 	ldw	r2,-8(fp)
 324a094:	10800003 	ldbu	r2,0(r2)
 324a098:	10803fcc 	andi	r2,r2,255
 324a09c:	1080201c 	xori	r2,r2,128
 324a0a0:	10bfe004 	addi	r2,r2,-128
 324a0a4:	10800be0 	cmpeqi	r2,r2,47
 324a0a8:	1000071e 	bne	r2,zero,324a0c8 <vfslookup_locked+0x4c>
 324a0ac:	e0bffe17 	ldw	r2,-8(fp)
 324a0b0:	10800003 	ldbu	r2,0(r2)
 324a0b4:	10803fcc 	andi	r2,r2,255
 324a0b8:	1080201c 	xori	r2,r2,128
 324a0bc:	10bfe004 	addi	r2,r2,-128
 324a0c0:	10801718 	cmpnei	r2,r2,92
 324a0c4:	10001a1e 	bne	r2,zero,324a130 <vfslookup_locked+0xb4>
   {
      cp = strippath(name);
 324a0c8:	e13ffe17 	ldw	r4,-8(fp)
 324a0cc:	324a1fc0 	call	324a1fc <strippath>
 324a0d0:	e0bffc15 	stw	r2,-16(fp)

      if (!cp) /* strippath coundn't match our path */
 324a0d4:	e0bffc17 	ldw	r2,-16(fp)
 324a0d8:	1004c03a 	cmpne	r2,r2,zero
 324a0dc:	1000121e 	bne	r2,zero,324a128 <vfslookup_locked+0xac>
      {
         /* Files like "/hub47.gif" need to be taken care of */
         if (*name == '/' || *name == '\\')
 324a0e0:	e0bffe17 	ldw	r2,-8(fp)
 324a0e4:	10800003 	ldbu	r2,0(r2)
 324a0e8:	10803fcc 	andi	r2,r2,255
 324a0ec:	1080201c 	xori	r2,r2,128
 324a0f0:	10bfe004 	addi	r2,r2,-128
 324a0f4:	10800be0 	cmpeqi	r2,r2,47
 324a0f8:	1000071e 	bne	r2,zero,324a118 <vfslookup_locked+0x9c>
 324a0fc:	e0bffe17 	ldw	r2,-8(fp)
 324a100:	10800003 	ldbu	r2,0(r2)
 324a104:	10803fcc 	andi	r2,r2,255
 324a108:	1080201c 	xori	r2,r2,128
 324a10c:	10bfe004 	addi	r2,r2,-128
 324a110:	10801718 	cmpnei	r2,r2,92
 324a114:	1000061e 	bne	r2,zero,324a130 <vfslookup_locked+0xb4>
            name++;
 324a118:	e0bffe17 	ldw	r2,-8(fp)
 324a11c:	10800044 	addi	r2,r2,1
 324a120:	e0bffe15 	stw	r2,-8(fp)
 324a124:	00000206 	br	324a130 <vfslookup_locked+0xb4>
      }
      else
         name = cp ;
 324a128:	e0bffc17 	ldw	r2,-16(fp)
 324a12c:	e0bffe15 	stw	r2,-8(fp)
   }
#endif   /* VFS_STRIPPATH */

   /* see if there is a question mark in the file name */
   if (strchr(name,'?'))
 324a130:	e13ffe17 	ldw	r4,-8(fp)
 324a134:	01400fc4 	movi	r5,63
 324a138:	3207cf40 	call	3207cf4 <strchr>
 324a13c:	1005003a 	cmpeq	r2,r2,zero
 324a140:	1000031e 	bne	r2,zero,324a150 <vfslookup_locked+0xd4>
   {
      dtrap(); /* is this still allowed? */
 324a144:	322aef00 	call	322aef0 <dtrap>
      return NULL;
 324a148:	e03fff15 	stw	zero,-4(fp)
 324a14c:	00001306 	br	324a19c <vfslookup_locked+0x120>
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 324a150:	d0a90d17 	ldw	r2,-23500(gp)
 324a154:	e0bffd15 	stw	r2,-12(fp)
 324a158:	00000c06 	br	324a18c <vfslookup_locked+0x110>
   {
      if (strcmp(name, vp->name) == 0)
 324a15c:	e0bffd17 	ldw	r2,-12(fp)
 324a160:	11400104 	addi	r5,r2,4
 324a164:	e13ffe17 	ldw	r4,-8(fp)
 324a168:	320eebc0 	call	320eebc <strcmp>
 324a16c:	1004c03a 	cmpne	r2,r2,zero
 324a170:	1000031e 	bne	r2,zero,324a180 <vfslookup_locked+0x104>
         return vp;
 324a174:	e0bffd17 	ldw	r2,-12(fp)
 324a178:	e0bfff15 	stw	r2,-4(fp)
 324a17c:	00000706 	br	324a19c <vfslookup_locked+0x120>
   {
      dtrap(); /* is this still allowed? */
      return NULL;
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 324a180:	e0bffd17 	ldw	r2,-12(fp)
 324a184:	10800017 	ldw	r2,0(r2)
 324a188:	e0bffd15 	stw	r2,-12(fp)
 324a18c:	e0bffd17 	ldw	r2,-12(fp)
 324a190:	1004c03a 	cmpne	r2,r2,zero
 324a194:	103ff11e 	bne	r2,zero,324a15c <vfslookup_locked+0xe0>
   {
      if (strcmp(name, vp->name) == 0)
         return vp;
   }

   return NULL;   /* fall to here if not found in for loop */
 324a198:	e03fff15 	stw	zero,-4(fp)
 324a19c:	e0bfff17 	ldw	r2,-4(fp)
}
 324a1a0:	e037883a 	mov	sp,fp
 324a1a4:	dfc00117 	ldw	ra,4(sp)
 324a1a8:	df000017 	ldw	fp,0(sp)
 324a1ac:	dec00204 	addi	sp,sp,8
 324a1b0:	f800283a 	ret

0324a1b4 <vfslookup>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup(char * name) 
{
 324a1b4:	defffc04 	addi	sp,sp,-16
 324a1b8:	dfc00315 	stw	ra,12(sp)
 324a1bc:	df000215 	stw	fp,8(sp)
 324a1c0:	df000204 	addi	fp,sp,8
 324a1c4:	e13fff15 	stw	r4,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfslookup() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 324a1c8:	01000144 	movi	r4,5
 324a1cc:	322b4ec0 	call	322b4ec <wait_app_sem>

   /* do the lookup */
   vp = vfslookup_locked(name);
 324a1d0:	e13fff17 	ldw	r4,-4(fp)
 324a1d4:	324a07c0 	call	324a07c <vfslookup_locked>
 324a1d8:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 324a1dc:	01000144 	movi	r4,5
 324a1e0:	322b5a00 	call	322b5a0 <post_app_sem>
   return vp;
 324a1e4:	e0bffe17 	ldw	r2,-8(fp)
}
 324a1e8:	e037883a 	mov	sp,fp
 324a1ec:	dfc00117 	ldw	ra,4(sp)
 324a1f0:	df000017 	ldw	fp,0(sp)
 324a1f4:	dec00204 	addi	sp,sp,8
 324a1f8:	f800283a 	ret

0324a1fc <strippath>:
 * have the http_root_path prepended; or on any error. 
 */

char * 
strippath(char * name)
{
 324a1fc:	defff804 	addi	sp,sp,-32
 324a200:	dfc00715 	stw	ra,28(sp)
 324a204:	df000615 	stw	fp,24(sp)
 324a208:	df000604 	addi	fp,sp,24
 324a20c:	e13ffe15 	stw	r4,-8(fp)
   char *   path; /* pointer into system path */
   char *   ptmp; /* another pointer into path */
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
 324a210:	e13ffe17 	ldw	r4,-8(fp)
 324a214:	32262fc0 	call	32262fc <uslash>
 324a218:	e0bffb15 	stw	r2,-20(fp)
   path = http_root_path; /* The servers root path, at least one UNIX slash */
 324a21c:	d0a05117 	ldw	r2,-32444(gp)
 324a220:	e0bffd15 	stw	r2,-12(fp)
   while (*path && *ntmp)
 324a224:	00003e06 	br	324a320 <strippath+0x124>
   {
      while (*path == '/') path++;   /* strip leading slash */
 324a228:	e0bffd17 	ldw	r2,-12(fp)
 324a22c:	10800044 	addi	r2,r2,1
 324a230:	e0bffd15 	stw	r2,-12(fp)
 324a234:	e0bffd17 	ldw	r2,-12(fp)
 324a238:	10800003 	ldbu	r2,0(r2)
 324a23c:	10803fcc 	andi	r2,r2,255
 324a240:	1080201c 	xori	r2,r2,128
 324a244:	10bfe004 	addi	r2,r2,-128
 324a248:	10800be0 	cmpeqi	r2,r2,47
 324a24c:	103ff61e 	bne	r2,zero,324a228 <strippath+0x2c>
         if (*path == 0)
 324a250:	e0bffd17 	ldw	r2,-12(fp)
 324a254:	10800003 	ldbu	r2,0(r2)
 324a258:	10803fcc 	andi	r2,r2,255
 324a25c:	1080201c 	xori	r2,r2,128
 324a260:	10bfe004 	addi	r2,r2,-128
 324a264:	1005003a 	cmpeq	r2,r2,zero
 324a268:	10003b1e 	bne	r2,zero,324a358 <strippath+0x15c>
         break;
      /* find number of chars in this directory layer's name */
      ptmp = strchr(path, '/');   /* location of next slash in path */
 324a26c:	e13ffd17 	ldw	r4,-12(fp)
 324a270:	01400bc4 	movi	r5,47
 324a274:	3207cf40 	call	3207cf4 <strchr>
 324a278:	e0bffc15 	stw	r2,-16(fp)
      if (ptmp)
 324a27c:	e0bffc17 	ldw	r2,-16(fp)
 324a280:	1005003a 	cmpeq	r2,r2,zero
 324a284:	1000051e 	bne	r2,zero,324a29c <strippath+0xa0>
         dirlen = ptmp - path;
 324a288:	e0bffc17 	ldw	r2,-16(fp)
 324a28c:	e0fffd17 	ldw	r3,-12(fp)
 324a290:	10c5c83a 	sub	r2,r2,r3
 324a294:	e0bffa15 	stw	r2,-24(fp)
 324a298:	00000706 	br	324a2b8 <strippath+0xbc>
      else
         dirlen = strlen(path);
 324a29c:	e13ffd17 	ldw	r4,-12(fp)
 324a2a0:	32084480 	call	3208448 <strlen>
 324a2a4:	e0bffa15 	stw	r2,-24(fp)

      while (*ntmp == '/') ntmp++;   /* strip leading slash */
 324a2a8:	00000306 	br	324a2b8 <strippath+0xbc>
 324a2ac:	e0bffb17 	ldw	r2,-20(fp)
 324a2b0:	10800044 	addi	r2,r2,1
 324a2b4:	e0bffb15 	stw	r2,-20(fp)
 324a2b8:	e0bffb17 	ldw	r2,-20(fp)
 324a2bc:	10800003 	ldbu	r2,0(r2)
 324a2c0:	10803fcc 	andi	r2,r2,255
 324a2c4:	1080201c 	xori	r2,r2,128
 324a2c8:	10bfe004 	addi	r2,r2,-128
 324a2cc:	10800be0 	cmpeqi	r2,r2,47
 324a2d0:	103ff61e 	bne	r2,zero,324a2ac <strippath+0xb0>
         if (strncmp(ntmp, path, dirlen) == 0)
 324a2d4:	e1bffa17 	ldw	r6,-24(fp)
 324a2d8:	e13ffb17 	ldw	r4,-20(fp)
 324a2dc:	e17ffd17 	ldw	r5,-12(fp)
 324a2e0:	324bdc00 	call	324bdc0 <strncmp>
 324a2e4:	1004c03a 	cmpne	r2,r2,zero
 324a2e8:	10000b1e 	bne	r2,zero,324a318 <strippath+0x11c>
      {
         path += dirlen;
 324a2ec:	e0bffa17 	ldw	r2,-24(fp)
 324a2f0:	1007883a 	mov	r3,r2
 324a2f4:	e0bffd17 	ldw	r2,-12(fp)
 324a2f8:	10c5883a 	add	r2,r2,r3
 324a2fc:	e0bffd15 	stw	r2,-12(fp)
         ntmp += dirlen;
 324a300:	e0bffa17 	ldw	r2,-24(fp)
 324a304:	1007883a 	mov	r3,r2
 324a308:	e0bffb17 	ldw	r2,-20(fp)
 324a30c:	10c5883a 	add	r2,r2,r3
 324a310:	e0bffb15 	stw	r2,-20(fp)
 324a314:	00000206 	br	324a320 <strippath+0x124>
      }
      else
         return NULL;   /* didn't match */
 324a318:	e03fff15 	stw	zero,-4(fp)
 324a31c:	00002b06 	br	324a3cc <strippath+0x1d0>
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
   path = http_root_path; /* The servers root path, at least one UNIX slash */
   while (*path && *ntmp)
 324a320:	e0bffd17 	ldw	r2,-12(fp)
 324a324:	10800003 	ldbu	r2,0(r2)
 324a328:	10803fcc 	andi	r2,r2,255
 324a32c:	1080201c 	xori	r2,r2,128
 324a330:	10bfe004 	addi	r2,r2,-128
 324a334:	1005003a 	cmpeq	r2,r2,zero
 324a338:	1000071e 	bne	r2,zero,324a358 <strippath+0x15c>
 324a33c:	e0bffb17 	ldw	r2,-20(fp)
 324a340:	10800003 	ldbu	r2,0(r2)
 324a344:	10803fcc 	andi	r2,r2,255
 324a348:	1080201c 	xori	r2,r2,128
 324a34c:	10bfe004 	addi	r2,r2,-128
 324a350:	1004c03a 	cmpne	r2,r2,zero
 324a354:	103fb71e 	bne	r2,zero,324a234 <strippath+0x38>
         ntmp += dirlen;
      }
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
 324a358:	e0bffd17 	ldw	r2,-12(fp)
 324a35c:	10800003 	ldbu	r2,0(r2)
 324a360:	10803fcc 	andi	r2,r2,255
 324a364:	1080201c 	xori	r2,r2,128
 324a368:	10bfe004 	addi	r2,r2,-128
 324a36c:	1004c03a 	cmpne	r2,r2,zero
 324a370:	1000151e 	bne	r2,zero,324a3c8 <strippath+0x1cc>
   {
      while (*ntmp == '\\' || *ntmp == '/')
 324a374:	00000306 	br	324a384 <strippath+0x188>
         ntmp++;
 324a378:	e0bffb17 	ldw	r2,-20(fp)
 324a37c:	10800044 	addi	r2,r2,1
 324a380:	e0bffb15 	stw	r2,-20(fp)
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
   {
      while (*ntmp == '\\' || *ntmp == '/')
 324a384:	e0bffb17 	ldw	r2,-20(fp)
 324a388:	10800003 	ldbu	r2,0(r2)
 324a38c:	10803fcc 	andi	r2,r2,255
 324a390:	1080201c 	xori	r2,r2,128
 324a394:	10bfe004 	addi	r2,r2,-128
 324a398:	10801720 	cmpeqi	r2,r2,92
 324a39c:	103ff61e 	bne	r2,zero,324a378 <strippath+0x17c>
 324a3a0:	e0bffb17 	ldw	r2,-20(fp)
 324a3a4:	10800003 	ldbu	r2,0(r2)
 324a3a8:	10803fcc 	andi	r2,r2,255
 324a3ac:	1080201c 	xori	r2,r2,128
 324a3b0:	10bfe004 	addi	r2,r2,-128
 324a3b4:	10800be0 	cmpeqi	r2,r2,47
 324a3b8:	103fef1e 	bne	r2,zero,324a378 <strippath+0x17c>
         ntmp++;
      return ntmp;
 324a3bc:	e0bffb17 	ldw	r2,-20(fp)
 324a3c0:	e0bfff15 	stw	r2,-4(fp)
 324a3c4:	00000106 	br	324a3cc <strippath+0x1d0>
   }
   else
      return NULL;
 324a3c8:	e03fff15 	stw	zero,-4(fp)
 324a3cc:	e0bfff17 	ldw	r2,-4(fp)
}
 324a3d0:	e037883a 	mov	sp,fp
 324a3d4:	dfc00117 	ldw	ra,4(sp)
 324a3d8:	df000017 	ldw	fp,0(sp)
 324a3dc:	dec00204 	addi	sp,sp,8
 324a3e0:	f800283a 	ret

0324a3e4 <isvfile_locked>:
 * RETURNS: 
 */

int
isvfile_locked(VFILE * vfp)
{
 324a3e4:	defffc04 	addi	sp,sp,-16
 324a3e8:	df000315 	stw	fp,12(sp)
 324a3ec:	df000304 	addi	fp,sp,12
 324a3f0:	e13ffe15 	stw	r4,-8(fp)
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 324a3f4:	d0a90c17 	ldw	r2,-23504(gp)
 324a3f8:	e0bffd15 	stw	r2,-12(fp)
 324a3fc:	00000906 	br	324a424 <isvfile_locked+0x40>
      if (vtmp == vfp)
 324a400:	e0fffd17 	ldw	r3,-12(fp)
 324a404:	e0bffe17 	ldw	r2,-8(fp)
 324a408:	1880031e 	bne	r3,r2,324a418 <isvfile_locked+0x34>
      return TRUE;
 324a40c:	00800044 	movi	r2,1
 324a410:	e0bfff15 	stw	r2,-4(fp)
 324a414:	00000706 	br	324a434 <isvfile_locked+0x50>
int
isvfile_locked(VFILE * vfp)
{
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 324a418:	e0bffd17 	ldw	r2,-12(fp)
 324a41c:	10800017 	ldw	r2,0(r2)
 324a420:	e0bffd15 	stw	r2,-12(fp)
 324a424:	e0bffd17 	ldw	r2,-12(fp)
 324a428:	1004c03a 	cmpne	r2,r2,zero
 324a42c:	103ff41e 	bne	r2,zero,324a400 <isvfile_locked+0x1c>
      if (vtmp == vfp)
      return TRUE;

   return FALSE;  /* passed pointer not found in list */
 324a430:	e03fff15 	stw	zero,-4(fp)
 324a434:	e0bfff17 	ldw	r2,-4(fp)
}
 324a438:	e037883a 	mov	sp,fp
 324a43c:	df000017 	ldw	fp,0(sp)
 324a440:	dec00104 	addi	sp,sp,4
 324a444:	f800283a 	ret

0324a448 <isvfile>:
 * RETURNS: 
 */

int
isvfile(VFILE * vfp)
{
 324a448:	defffc04 	addi	sp,sp,-16
 324a44c:	dfc00315 	stw	ra,12(sp)
 324a450:	df000215 	stw	fp,8(sp)
 324a454:	df000204 	addi	fp,sp,8
 324a458:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 324a45c:	01000144 	movi	r4,5
 324a460:	322b4ec0 	call	322b4ec <wait_app_sem>

   /* do the lookup */
   rc = isvfile_locked(vfp);
 324a464:	e13fff17 	ldw	r4,-4(fp)
 324a468:	324a3e40 	call	324a3e4 <isvfile_locked>
 324a46c:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 324a470:	01000144 	movi	r4,5
 324a474:	322b5a00 	call	322b5a0 <post_app_sem>
   return rc;
 324a478:	e0bffe17 	ldw	r2,-8(fp)
}
 324a47c:	e037883a 	mov	sp,fp
 324a480:	dfc00117 	ldw	ra,4(sp)
 324a484:	df000017 	ldw	fp,0(sp)
 324a488:	dec00204 	addi	sp,sp,8
 324a48c:	f800283a 	ret

0324a490 <vferror>:
 * RETURNS: 
 */

int
vferror(VFILE * vfd)
{
 324a490:	defffc04 	addi	sp,sp,-16
 324a494:	dfc00315 	stw	ra,12(sp)
 324a498:	df000215 	stw	fp,8(sp)
 324a49c:	df000204 	addi	fp,sp,8
 324a4a0:	e13ffe15 	stw	r4,-8(fp)
   /* lock the VFS */
   vfs_lock();
 324a4a4:	01000144 	movi	r4,5
 324a4a8:	322b4ec0 	call	322b4ec <wait_app_sem>

   if (isvfile_locked(vfd))
 324a4ac:	e13ffe17 	ldw	r4,-8(fp)
 324a4b0:	324a3e40 	call	324a3e4 <isvfile_locked>
 324a4b4:	1005003a 	cmpeq	r2,r2,zero
 324a4b8:	1000061e 	bne	r2,zero,324a4d4 <vferror+0x44>
   {
      vfs_unlock();
 324a4bc:	01000144 	movi	r4,5
 324a4c0:	322b5a00 	call	322b5a0 <post_app_sem>

      return vfd->error;
 324a4c4:	e0bffe17 	ldw	r2,-8(fp)
 324a4c8:	10800417 	ldw	r2,16(r2)
 324a4cc:	e0bfff15 	stw	r2,-4(fp)
 324a4d0:	00000406 	br	324a4e4 <vferror+0x54>
   }

   vfs_unlock();
 324a4d4:	01000144 	movi	r4,5
 324a4d8:	322b5a00 	call	322b5a0 <post_app_sem>

#ifdef HT_LOCALFS
   return(ferror((FILE*)vfd));
#else /* not a VFILE, and no local FS */
   return -1;  /* should this be an error? */
 324a4dc:	00bfffc4 	movi	r2,-1
 324a4e0:	e0bfff15 	stw	r2,-4(fp)
 324a4e4:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 324a4e8:	e037883a 	mov	sp,fp
 324a4ec:	dfc00117 	ldw	ra,4(sp)
 324a4f0:	df000017 	ldw	fp,0(sp)
 324a4f4:	dec00204 	addi	sp,sp,8
 324a4f8:	f800283a 	ret

0324a4fc <vclearerr>:
 *
 * RETURNS: 
 */

void vclearerr(VFILE * vfd)
{
 324a4fc:	defffd04 	addi	sp,sp,-12
 324a500:	dfc00215 	stw	ra,8(sp)
 324a504:	df000115 	stw	fp,4(sp)
 324a508:	df000104 	addi	fp,sp,4
 324a50c:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 324a510:	01000144 	movi	r4,5
 324a514:	322b4ec0 	call	322b4ec <wait_app_sem>

   if (isvfile_locked(vfd))
 324a518:	e13fff17 	ldw	r4,-4(fp)
 324a51c:	324a3e40 	call	324a3e4 <isvfile_locked>
 324a520:	1005003a 	cmpeq	r2,r2,zero
 324a524:	1000051e 	bne	r2,zero,324a53c <vclearerr+0x40>
   {
      vfs_unlock();
 324a528:	01000144 	movi	r4,5
 324a52c:	322b5a00 	call	322b5a0 <post_app_sem>

      vfd->error = 0;
 324a530:	e0bfff17 	ldw	r2,-4(fp)
 324a534:	10000415 	stw	zero,16(r2)
      return;
 324a538:	00000206 	br	324a544 <vclearerr+0x48>
   }

   vfs_unlock();
 324a53c:	01000144 	movi	r4,5
 324a540:	322b5a00 	call	322b5a0 <post_app_sem>

#ifdef HT_LOCALFS
   clearerr((FILE *) vfd);
#endif   /* HT_LOCALFS */
}
 324a544:	e037883a 	mov	sp,fp
 324a548:	dfc00117 	ldw	ra,4(sp)
 324a54c:	df000017 	ldw	fp,0(sp)
 324a550:	dec00204 	addi	sp,sp,8
 324a554:	f800283a 	ret

0324a558 <prep_vfs>:
 * PARAMS: NONE
 *
 * RETURNS: Error Code or 0 for OK
 */
int prep_vfs(void)
{
 324a558:	defffe04 	addi	sp,sp,-8
 324a55c:	df000115 	stw	fp,4(sp)
 324a560:	df000104 	addi	fp,sp,4
int e = 0;
 324a564:	e03fff15 	stw	zero,-4(fp)
   {
      dprintf("unable to install VFS NVPARMS, reconfigure nv_formats[]\n");
      dtrap();
   }
#endif   /* INCLUDE_NVPARMS */
   return e;
 324a568:	e0bfff17 	ldw	r2,-4(fp)
}
 324a56c:	e037883a 	mov	sp,fp
 324a570:	df000017 	ldw	fp,0(sp)
 324a574:	dec00104 	addi	sp,sp,4
 324a578:	f800283a 	ret

0324a57c <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 324a57c:	defffa04 	addi	sp,sp,-24
 324a580:	dfc00515 	stw	ra,20(sp)
 324a584:	df000415 	stw	fp,16(sp)
 324a588:	df000404 	addi	fp,sp,16
 324a58c:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 324a590:	008000c4 	movi	r2,3
 324a594:	e0bffc15 	stw	r2,-16(fp)
  }
  

  big_loops = us / (INT_MAX/
 324a598:	e0fffc17 	ldw	r3,-16(fp)
 324a59c:	008003f4 	movhi	r2,15
 324a5a0:	10909004 	addi	r2,r2,16960
 324a5a4:	188b383a 	mul	r5,r3,r2
 324a5a8:	01017db4 	movhi	r4,1526
 324a5ac:	21384004 	addi	r4,r4,-7936
 324a5b0:	32047c00 	call	32047c0 <__udivsi3>
 324a5b4:	100b883a 	mov	r5,r2
 324a5b8:	01200034 	movhi	r4,32768
 324a5bc:	213fffc4 	addi	r4,r4,-1
 324a5c0:	32047c00 	call	32047c0 <__udivsi3>
 324a5c4:	100b883a 	mov	r5,r2
 324a5c8:	e13fff17 	ldw	r4,-4(fp)
 324a5cc:	32047c00 	call	32047c0 <__udivsi3>
 324a5d0:	e0bffd15 	stw	r2,-12(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 324a5d4:	e0bffd17 	ldw	r2,-12(fp)
 324a5d8:	1005003a 	cmpeq	r2,r2,zero
 324a5dc:	1000281e 	bne	r2,zero,324a680 <alt_busy_sleep+0x104>
  {
    for(i=0;i<big_loops;i++)
 324a5e0:	e03ffe15 	stw	zero,-8(fp)
 324a5e4:	00001606 	br	324a640 <alt_busy_sleep+0xc4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 324a5e8:	00a00034 	movhi	r2,32768
 324a5ec:	10bfffc4 	addi	r2,r2,-1
 324a5f0:	10bfffc4 	addi	r2,r2,-1
 324a5f4:	103ffe1e 	bne	r2,zero,324a5f0 <alt_busy_sleep+0x74>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 324a5f8:	e0fffc17 	ldw	r3,-16(fp)
 324a5fc:	008003f4 	movhi	r2,15
 324a600:	10909004 	addi	r2,r2,16960
 324a604:	188b383a 	mul	r5,r3,r2
 324a608:	01017db4 	movhi	r4,1526
 324a60c:	21384004 	addi	r4,r4,-7936
 324a610:	32047c00 	call	32047c0 <__udivsi3>
 324a614:	100b883a 	mov	r5,r2
 324a618:	01200034 	movhi	r4,32768
 324a61c:	213fffc4 	addi	r4,r4,-1
 324a620:	32047c00 	call	32047c0 <__udivsi3>
 324a624:	1007883a 	mov	r3,r2
 324a628:	e0bfff17 	ldw	r2,-4(fp)
 324a62c:	10c5c83a 	sub	r2,r2,r3
 324a630:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 324a634:	e0bffe17 	ldw	r2,-8(fp)
 324a638:	10800044 	addi	r2,r2,1
 324a63c:	e0bffe15 	stw	r2,-8(fp)
 324a640:	e0fffe17 	ldw	r3,-8(fp)
 324a644:	e0bffd17 	ldw	r2,-12(fp)
 324a648:	18bfe716 	blt	r3,r2,324a5e8 <alt_busy_sleep+0x6c>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 324a64c:	e0fffc17 	ldw	r3,-16(fp)
 324a650:	008003f4 	movhi	r2,15
 324a654:	10909004 	addi	r2,r2,16960
 324a658:	188b383a 	mul	r5,r3,r2
 324a65c:	01017db4 	movhi	r4,1526
 324a660:	21384004 	addi	r4,r4,-7936
 324a664:	32047c00 	call	32047c0 <__udivsi3>
 324a668:	1007883a 	mov	r3,r2
 324a66c:	e0bfff17 	ldw	r2,-4(fp)
 324a670:	1885383a 	mul	r2,r3,r2
 324a674:	10bfffc4 	addi	r2,r2,-1
 324a678:	103ffe1e 	bne	r2,zero,324a674 <alt_busy_sleep+0xf8>
 324a67c:	00000c06 	br	324a6b0 <alt_busy_sleep+0x134>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 324a680:	e0fffc17 	ldw	r3,-16(fp)
 324a684:	008003f4 	movhi	r2,15
 324a688:	10909004 	addi	r2,r2,16960
 324a68c:	188b383a 	mul	r5,r3,r2
 324a690:	01017db4 	movhi	r4,1526
 324a694:	21384004 	addi	r4,r4,-7936
 324a698:	32047c00 	call	32047c0 <__udivsi3>
 324a69c:	1007883a 	mov	r3,r2
 324a6a0:	e0bfff17 	ldw	r2,-4(fp)
 324a6a4:	1885383a 	mul	r2,r3,r2
 324a6a8:	10bfffc4 	addi	r2,r2,-1
 324a6ac:	00bffe16 	blt	zero,r2,324a6a8 <alt_busy_sleep+0x12c>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 324a6b0:	0005883a 	mov	r2,zero
}
 324a6b4:	e037883a 	mov	sp,fp
 324a6b8:	dfc00117 	ldw	ra,4(sp)
 324a6bc:	df000017 	ldw	fp,0(sp)
 324a6c0:	dec00204 	addi	sp,sp,8
 324a6c4:	f800283a 	ret

0324a6c8 <alt_fcntl>:
 *
 * ALT_FCNTL is mapped onto the fcntl() system call in alt_syscall.h
 */
 
int ALT_FCNTL (int file, int cmd, ...)
{ 
 324a6c8:	defff404 	addi	sp,sp,-48
 324a6cc:	dfc00915 	stw	ra,36(sp)
 324a6d0:	df000815 	stw	fp,32(sp)
 324a6d4:	df000804 	addi	fp,sp,32
 324a6d8:	e13ffb15 	stw	r4,-20(fp)
 324a6dc:	e1800215 	stw	r6,8(fp)
 324a6e0:	e1c00315 	stw	r7,12(fp)
 324a6e4:	e17ffc15 	stw	r5,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 324a6e8:	e0bffb17 	ldw	r2,-20(fp)
 324a6ec:	1004803a 	cmplt	r2,r2,zero
 324a6f0:	1000081e 	bne	r2,zero,324a714 <alt_fcntl+0x4c>
 324a6f4:	e0bffb17 	ldw	r2,-20(fp)
 324a6f8:	10800324 	muli	r2,r2,12
 324a6fc:	1007883a 	mov	r3,r2
 324a700:	0080c974 	movhi	r2,805
 324a704:	10896e04 	addi	r2,r2,9656
 324a708:	1887883a 	add	r3,r3,r2
 324a70c:	e0fffe15 	stw	r3,-8(fp)
 324a710:	00000106 	br	324a718 <alt_fcntl+0x50>
 324a714:	e03ffe15 	stw	zero,-8(fp)
 324a718:	e0bffe17 	ldw	r2,-8(fp)
 324a71c:	e0bff915 	stw	r2,-28(fp)
  
  if (fd)
 324a720:	e0bff917 	ldw	r2,-28(fp)
 324a724:	1005003a 	cmpeq	r2,r2,zero
 324a728:	1000301e 	bne	r2,zero,324a7ec <alt_fcntl+0x124>
  {
    switch (cmd)
 324a72c:	e0fffc17 	ldw	r3,-16(fp)
 324a730:	e0ffff15 	stw	r3,-4(fp)
 324a734:	e0ffff17 	ldw	r3,-4(fp)
 324a738:	188000e0 	cmpeqi	r2,r3,3
 324a73c:	1000041e 	bne	r2,zero,324a750 <alt_fcntl+0x88>
 324a740:	e0ffff17 	ldw	r3,-4(fp)
 324a744:	18800120 	cmpeqi	r2,r3,4
 324a748:	1000081e 	bne	r2,zero,324a76c <alt_fcntl+0xa4>
 324a74c:	00002006 	br	324a7d0 <alt_fcntl+0x108>
    {
    case F_GETFL:
      return fd->fd_flags & ~((alt_u32) ALT_FD_FLAGS_MASK);
 324a750:	e0bff917 	ldw	r2,-28(fp)
 324a754:	10c00217 	ldw	r3,8(r2)
 324a758:	00900034 	movhi	r2,16384
 324a75c:	10bfffc4 	addi	r2,r2,-1
 324a760:	1886703a 	and	r3,r3,r2
 324a764:	e0fffd15 	stw	r3,-12(fp)
 324a768:	00002606 	br	324a804 <alt_fcntl+0x13c>
    case F_SETFL:
      va_start(argp, cmd);
 324a76c:	e0800204 	addi	r2,fp,8
 324a770:	e0bffa15 	stw	r2,-24(fp)
      flags = va_arg(argp, long);
 324a774:	e0fffa17 	ldw	r3,-24(fp)
 324a778:	18800104 	addi	r2,r3,4
 324a77c:	e0bffa15 	stw	r2,-24(fp)
 324a780:	1805883a 	mov	r2,r3
 324a784:	10800017 	ldw	r2,0(r2)
 324a788:	e0bff815 	stw	r2,-32(fp)
      fd->fd_flags &= ~ALT_FCNTL_FLAGS_MASK;
 324a78c:	e0bff917 	ldw	r2,-28(fp)
 324a790:	10c00217 	ldw	r3,8(r2)
 324a794:	00affdc4 	movi	r2,-16393
 324a798:	1886703a 	and	r3,r3,r2
 324a79c:	e0bff917 	ldw	r2,-28(fp)
 324a7a0:	10c00215 	stw	r3,8(r2)
      fd->fd_flags |= (flags & ALT_FCNTL_FLAGS_MASK);
 324a7a4:	e0bff917 	ldw	r2,-28(fp)
 324a7a8:	10800217 	ldw	r2,8(r2)
 324a7ac:	1007883a 	mov	r3,r2
 324a7b0:	e0bff817 	ldw	r2,-32(fp)
 324a7b4:	1090020c 	andi	r2,r2,16392
 324a7b8:	1884b03a 	or	r2,r3,r2
 324a7bc:	1007883a 	mov	r3,r2
 324a7c0:	e0bff917 	ldw	r2,-28(fp)
 324a7c4:	10c00215 	stw	r3,8(r2)
      va_end(argp);
      return 0;
 324a7c8:	e03ffd15 	stw	zero,-12(fp)
 324a7cc:	00000d06 	br	324a804 <alt_fcntl+0x13c>
    default:
      ALT_ERRNO = EINVAL;
 324a7d0:	324a81c0 	call	324a81c <alt_get_errno>
 324a7d4:	1007883a 	mov	r3,r2
 324a7d8:	00800584 	movi	r2,22
 324a7dc:	18800015 	stw	r2,0(r3)
      return -1;
 324a7e0:	00bfffc4 	movi	r2,-1
 324a7e4:	e0bffd15 	stw	r2,-12(fp)
 324a7e8:	00000606 	br	324a804 <alt_fcntl+0x13c>
    }
  }

  ALT_ERRNO = EBADFD;
 324a7ec:	324a81c0 	call	324a81c <alt_get_errno>
 324a7f0:	1007883a 	mov	r3,r2
 324a7f4:	00801444 	movi	r2,81
 324a7f8:	18800015 	stw	r2,0(r3)
  return -1;
 324a7fc:	00ffffc4 	movi	r3,-1
 324a800:	e0fffd15 	stw	r3,-12(fp)
 324a804:	e0bffd17 	ldw	r2,-12(fp)
}
 324a808:	e037883a 	mov	sp,fp
 324a80c:	dfc00117 	ldw	ra,4(sp)
 324a810:	df000017 	ldw	fp,0(sp)
 324a814:	dec00404 	addi	sp,sp,16
 324a818:	f800283a 	ret

0324a81c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 324a81c:	defffd04 	addi	sp,sp,-12
 324a820:	dfc00215 	stw	ra,8(sp)
 324a824:	df000115 	stw	fp,4(sp)
 324a828:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 324a82c:	0080c974 	movhi	r2,805
 324a830:	108aa504 	addi	r2,r2,10900
 324a834:	10800017 	ldw	r2,0(r2)
 324a838:	1005003a 	cmpeq	r2,r2,zero
 324a83c:	1000061e 	bne	r2,zero,324a858 <alt_get_errno+0x3c>
 324a840:	0080c974 	movhi	r2,805
 324a844:	108aa504 	addi	r2,r2,10900
 324a848:	10800017 	ldw	r2,0(r2)
 324a84c:	103ee83a 	callr	r2
 324a850:	e0bfff15 	stw	r2,-4(fp)
 324a854:	00000306 	br	324a864 <alt_get_errno+0x48>
 324a858:	0080c974 	movhi	r2,805
 324a85c:	1092f804 	addi	r2,r2,19424
 324a860:	e0bfff15 	stw	r2,-4(fp)
 324a864:	e0bfff17 	ldw	r2,-4(fp)
}
 324a868:	e037883a 	mov	sp,fp
 324a86c:	dfc00117 	ldw	ra,4(sp)
 324a870:	df000017 	ldw	fp,0(sp)
 324a874:	dec00204 	addi	sp,sp,8
 324a878:	f800283a 	ret

0324a87c <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
 324a87c:	defffb04 	addi	sp,sp,-20
 324a880:	df000415 	stw	fp,16(sp)
 324a884:	df000404 	addi	fp,sp,16
 324a888:	e13ffe15 	stw	r4,-8(fp)
 324a88c:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
 324a890:	e0bfff17 	ldw	r2,-4(fp)
 324a894:	10900070 	cmpltui	r2,r2,16385
 324a898:	1000021e 	bne	r2,zero,324a8a4 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
 324a89c:	00900004 	movi	r2,16384
 324a8a0:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
 324a8a4:	e0fffe17 	ldw	r3,-8(fp)
 324a8a8:	e0bfff17 	ldw	r2,-4(fp)
 324a8ac:	1885883a 	add	r2,r3,r2
 324a8b0:	e0bffc15 	stw	r2,-16(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 324a8b4:	e0bffe17 	ldw	r2,-8(fp)
 324a8b8:	e0bffd15 	stw	r2,-12(fp)
 324a8bc:	00000506 	br	324a8d4 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 324a8c0:	e0bffd17 	ldw	r2,-12(fp)
 324a8c4:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 324a8c8:	e0bffd17 	ldw	r2,-12(fp)
 324a8cc:	10800804 	addi	r2,r2,32
 324a8d0:	e0bffd15 	stw	r2,-12(fp)
 324a8d4:	e0fffd17 	ldw	r3,-12(fp)
 324a8d8:	e0bffc17 	ldw	r2,-16(fp)
 324a8dc:	18bff836 	bltu	r3,r2,324a8c0 <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 324a8e0:	e0bffe17 	ldw	r2,-8(fp)
 324a8e4:	108007cc 	andi	r2,r2,31
 324a8e8:	1005003a 	cmpeq	r2,r2,zero
 324a8ec:	1000021e 	bne	r2,zero,324a8f8 <alt_icache_flush+0x7c>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 324a8f0:	e0bffd17 	ldw	r2,-12(fp)
 324a8f4:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 324a8f8:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
 324a8fc:	e037883a 	mov	sp,fp
 324a900:	df000017 	ldw	fp,0(sp)
 324a904:	dec00104 	addi	sp,sp,4
 324a908:	f800283a 	ret

0324a90c <icmprcv>:
};
#endif /* USER_PING_TSTAMP */

int
icmprcv(PACKET p)      /* the incoming packet */
{
 324a90c:	deffed04 	addi	sp,sp,-76
 324a910:	dfc01215 	stw	ra,72(sp)
 324a914:	df001115 	stw	fp,68(sp)
 324a918:	dc401015 	stw	r17,64(sp)
 324a91c:	dc000f15 	stw	r16,60(sp)
 324a920:	df000f04 	addi	fp,sp,60
 324a924:	e13ffd15 	stw	r4,-12(fp)
   unsigned short xsum;
#ifdef FULL_ICMP
   struct redirect * rd;
   struct destun *   pdp;
#endif   /* FULL_ICMP */
   char sav_ch = 0;
 324a928:	e03ff505 	stb	zero,-44(fp)
   int i;

   icmp_mib.icmpInMsgs++;                 /* received one more icmp */
 324a92c:	0080c9b4 	movhi	r2,806
 324a930:	10b5a904 	addi	r2,r2,-10588
 324a934:	10800017 	ldw	r2,0(r2)
 324a938:	10c00044 	addi	r3,r2,1
 324a93c:	0080c9b4 	movhi	r2,806
 324a940:	10b5a904 	addi	r2,r2,-10588
 324a944:	10c00015 	stw	r3,0(r2)

   pip = ip_head(p);                      /* find IP header */
 324a948:	e0bffd17 	ldw	r2,-12(fp)
 324a94c:	10800317 	ldw	r2,12(r2)
 324a950:	e0bffa15 	stw	r2,-24(fp)
   len = p->nb_plen - (ip_hlen(pip));     /* strip IP header length */
 324a954:	e0bffd17 	ldw	r2,-12(fp)
 324a958:	10c00417 	ldw	r3,16(r2)
 324a95c:	e0bffa17 	ldw	r2,-24(fp)
 324a960:	10800003 	ldbu	r2,0(r2)
 324a964:	10803fcc 	andi	r2,r2,255
 324a968:	108003cc 	andi	r2,r2,15
 324a96c:	1085883a 	add	r2,r2,r2
 324a970:	1085883a 	add	r2,r2,r2
 324a974:	1885c83a 	sub	r2,r3,r2
 324a978:	e0bffc15 	stw	r2,-16(fp)
   host = p->fhost;                       /* filled in by IP layer */
 324a97c:	e0bffd17 	ldw	r2,-12(fp)
 324a980:	10800717 	ldw	r2,28(r2)
 324a984:	e0bffb15 	stw	r2,-20(fp)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 324a988:	0080c974 	movhi	r2,805
 324a98c:	10931c04 	addi	r2,r2,19568
 324a990:	10800017 	ldw	r2,0(r2)
 324a994:	1081000c 	andi	r2,r2,1024
 324a998:	1005003a 	cmpeq	r2,r2,zero
 324a99c:	1000161e 	bne	r2,zero,324a9f8 <icmprcv+0xec>
 324a9a0:	0080c974 	movhi	r2,805
 324a9a4:	10931c04 	addi	r2,r2,19568
 324a9a8:	10800017 	ldw	r2,0(r2)
 324a9ac:	1080800c 	andi	r2,r2,512
 324a9b0:	1005003a 	cmpeq	r2,r2,zero
 324a9b4:	1000101e 	bne	r2,zero,324a9f8 <icmprcv+0xec>
      dprintf("ICMP: p[%u] from %u.%u.%u.%u\n", len, PUSH_IPADDR(host));
 324a9b8:	e0bffb17 	ldw	r2,-20(fp)
 324a9bc:	11803fcc 	andi	r6,r2,255
 324a9c0:	e0bffb17 	ldw	r2,-20(fp)
 324a9c4:	1004d23a 	srli	r2,r2,8
 324a9c8:	11c03fcc 	andi	r7,r2,255
 324a9cc:	e0bffb17 	ldw	r2,-20(fp)
 324a9d0:	1004d43a 	srli	r2,r2,16
 324a9d4:	10c03fcc 	andi	r3,r2,255
 324a9d8:	e0bffb17 	ldw	r2,-20(fp)
 324a9dc:	1004d63a 	srli	r2,r2,24
 324a9e0:	d8c00015 	stw	r3,0(sp)
 324a9e4:	d8800115 	stw	r2,4(sp)
 324a9e8:	0100c974 	movhi	r4,805
 324a9ec:	2101af04 	addi	r4,r4,1724
 324a9f0:	e17ffc17 	ldw	r5,-16(fp)
 324a9f4:	3206de00 	call	3206de0 <printf>
#endif

   e = (struct ping *)ip_data(pip);       /* finally, extract ICMP header */
 324a9f8:	e0bffa17 	ldw	r2,-24(fp)
 324a9fc:	10800003 	ldbu	r2,0(r2)
 324aa00:	10803fcc 	andi	r2,r2,255
 324aa04:	108003cc 	andi	r2,r2,15
 324aa08:	1085883a 	add	r2,r2,r2
 324aa0c:	1085883a 	add	r2,r2,r2
 324aa10:	1007883a 	mov	r3,r2
 324aa14:	e0bffa17 	ldw	r2,-24(fp)
 324aa18:	1885883a 	add	r2,r3,r2
 324aa1c:	e0bff915 	stw	r2,-28(fp)

   osum = e->pchksum;
 324aa20:	e0bff917 	ldw	r2,-28(fp)
 324aa24:	1080008b 	ldhu	r2,2(r2)
 324aa28:	e0bff88d 	sth	r2,-30(fp)
   e->pchksum = 0;
 324aa2c:	e0bff917 	ldw	r2,-28(fp)
 324aa30:	1000008d 	sth	zero,2(r2)

   if (len&1)
 324aa34:	e0bffc17 	ldw	r2,-16(fp)
 324aa38:	1080004c 	andi	r2,r2,1
 324aa3c:	10803fcc 	andi	r2,r2,255
 324aa40:	1005003a 	cmpeq	r2,r2,zero
 324aa44:	1000091e 	bne	r2,zero,324aa6c <icmprcv+0x160>
   {
      sav_ch = *(((char *) e) + len);
 324aa48:	e0fff917 	ldw	r3,-28(fp)
 324aa4c:	e0bffc17 	ldw	r2,-16(fp)
 324aa50:	1885883a 	add	r2,r3,r2
 324aa54:	10800003 	ldbu	r2,0(r2)
 324aa58:	e0bff505 	stb	r2,-44(fp)
      ((char *)e)[len] = 0;
 324aa5c:	e0fff917 	ldw	r3,-28(fp)
 324aa60:	e0bffc17 	ldw	r2,-16(fp)
 324aa64:	1885883a 	add	r2,r3,r2
 324aa68:	10000005 	stb	zero,0(r2)
   }

   xsum = ~cksum(e, (len+1)>>1);
 324aa6c:	e0bffc17 	ldw	r2,-16(fp)
 324aa70:	10800044 	addi	r2,r2,1
 324aa74:	100ad07a 	srli	r5,r2,1
 324aa78:	e13ff917 	ldw	r4,-28(fp)
 324aa7c:	3225d5c0 	call	3225d5c <cksum>
 324aa80:	0084303a 	nor	r2,zero,r2
 324aa84:	e0bff80d 	sth	r2,-32(fp)
   if (len&1) *(((char *) e) + len) = sav_ch;
 324aa88:	e0bffc17 	ldw	r2,-16(fp)
 324aa8c:	1080004c 	andi	r2,r2,1
 324aa90:	10803fcc 	andi	r2,r2,255
 324aa94:	1005003a 	cmpeq	r2,r2,zero
 324aa98:	1000051e 	bne	r2,zero,324aab0 <icmprcv+0x1a4>
 324aa9c:	e0fff917 	ldw	r3,-28(fp)
 324aaa0:	e0bffc17 	ldw	r2,-16(fp)
 324aaa4:	1887883a 	add	r3,r3,r2
 324aaa8:	e0bff503 	ldbu	r2,-44(fp)
 324aaac:	18800005 	stb	r2,0(r3)
   if (xsum != osum)
 324aab0:	e0fff80b 	ldhu	r3,-32(fp)
 324aab4:	e0bff88b 	ldhu	r2,-30(fp)
 324aab8:	18802c26 	beq	r3,r2,324ab6c <icmprcv+0x260>
   {
      e->pchksum = osum;
 324aabc:	e0fff917 	ldw	r3,-28(fp)
 324aac0:	e0bff88b 	ldhu	r2,-30(fp)
 324aac4:	1880008d 	sth	r2,2(r3)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 324aac8:	0080c974 	movhi	r2,805
 324aacc:	10931c04 	addi	r2,r2,19568
 324aad0:	10800017 	ldw	r2,0(r2)
 324aad4:	1081000c 	andi	r2,r2,1024
 324aad8:	1005003a 	cmpeq	r2,r2,zero
 324aadc:	1000131e 	bne	r2,zero,324ab2c <icmprcv+0x220>
 324aae0:	0080c974 	movhi	r2,805
 324aae4:	10931c04 	addi	r2,r2,19568
 324aae8:	10800017 	ldw	r2,0(r2)
 324aaec:	1080800c 	andi	r2,r2,512
 324aaf0:	1005003a 	cmpeq	r2,r2,zero
 324aaf4:	10000d1e 	bne	r2,zero,324ab2c <icmprcv+0x220>
      {
         dprintf("ICMP: Bad xsum %04x should have been %04x\n",
 324aaf8:	e17ff88b 	ldhu	r5,-30(fp)
 324aafc:	e1bff80b 	ldhu	r6,-32(fp)
 324ab00:	0100c974 	movhi	r4,805
 324ab04:	2101b704 	addi	r4,r4,1756
 324ab08:	3206de00 	call	3206de0 <printf>
          osum, xsum);
         if (NDEBUG & DUMP) ip_dump(p);
 324ab0c:	0080c974 	movhi	r2,805
 324ab10:	10931c04 	addi	r2,r2,19568
 324ab14:	10800017 	ldw	r2,0(r2)
 324ab18:	1080008c 	andi	r2,r2,2
 324ab1c:	1005003a 	cmpeq	r2,r2,zero
 324ab20:	1000021e 	bne	r2,zero,324ab2c <icmprcv+0x220>
 324ab24:	e13ffd17 	ldw	r4,-12(fp)
 324ab28:	324059c0 	call	324059c <ip_dump>
      }
#endif
      icmp_mib.icmpInErrors++;
 324ab2c:	0080c9b4 	movhi	r2,806
 324ab30:	10b5a904 	addi	r2,r2,-10588
 324ab34:	10800117 	ldw	r2,4(r2)
 324ab38:	10c00044 	addi	r3,r2,1
 324ab3c:	0080c9b4 	movhi	r2,806
 324ab40:	10b5a904 	addi	r2,r2,-10588
 324ab44:	10c00115 	stw	r3,4(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 324ab48:	01000084 	movi	r4,2
 324ab4c:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(p);
 324ab50:	e13ffd17 	ldw	r4,-12(fp)
 324ab54:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324ab58:	01000084 	movi	r4,2
 324ab5c:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 324ab60:	00bff804 	movi	r2,-32
 324ab64:	e0bfff15 	stw	r2,-4(fp)
 324ab68:	00026d06 	br	324b520 <icmprcv+0xc14>
   }

   e->pchksum = osum;
 324ab6c:	e0fff917 	ldw	r3,-28(fp)
 324ab70:	e0bff88b 	ldhu	r2,-30(fp)
 324ab74:	1880008d 	sth	r2,2(r3)

   switch (e->ptype) 
 324ab78:	e0bff917 	ldw	r2,-28(fp)
 324ab7c:	10800003 	ldbu	r2,0(r2)
 324ab80:	10803fcc 	andi	r2,r2,255
 324ab84:	1080201c 	xori	r2,r2,128
 324ab88:	10bfe004 	addi	r2,r2,-128
 324ab8c:	e0bffe15 	stw	r2,-8(fp)
 324ab90:	e0fffe17 	ldw	r3,-8(fp)
 324ab94:	18800428 	cmpgeui	r2,r3,16
 324ab98:	1002401e 	bne	r2,zero,324b49c <icmprcv+0xb90>
 324ab9c:	e13ffe17 	ldw	r4,-8(fp)
 324aba0:	e13ffe17 	ldw	r4,-8(fp)
 324aba4:	2105883a 	add	r2,r4,r4
 324aba8:	1087883a 	add	r3,r2,r2
 324abac:	0080c974 	movhi	r2,805
 324abb0:	10aaf004 	addi	r2,r2,-21568
 324abb4:	1885883a 	add	r2,r3,r2
 324abb8:	10800017 	ldw	r2,0(r2)
 324abbc:	1000683a 	jmp	r2
 324abc0:	0324aea4 	muli	r12,zero,-27974
 324abc4:	0324b49c 	xori	r12,zero,37586
 324abc8:	0324b49c 	xori	r12,zero,37586
 324abcc:	0324aed0 	cmplti	r12,zero,-27973
 324abd0:	0324afc0 	call	324afc <OSCtxSw_SWITCH_PC+0x324abc>
 324abd4:	0324b068 	cmpgeui	r12,zero,37569
 324abd8:	0324b49c 	xori	r12,zero,37586
 324abdc:	0324b49c 	xori	r12,zero,37586
 324abe0:	0324ac00 	call	324ac0 <OSCtxSw_SWITCH_PC+0x324a80>
 324abe4:	0324b49c 	xori	r12,zero,37586
 324abe8:	0324b49c 	xori	r12,zero,37586
 324abec:	0324b188 	cmpgei	r12,zero,-27962
 324abf0:	0324b290 	cmplti	r12,zero,-27958
 324abf4:	0324b30c 	andi	r12,zero,37580
 324abf8:	0324b49c 	xori	r12,zero,37586
 324abfc:	0324b45c 	xori	r12,zero,37585
   {
   case ECHOREQ:  /* got ping request, send reply */
      icmp_mib.icmpInEchos++;
 324ac00:	0080c9b4 	movhi	r2,806
 324ac04:	10b5a904 	addi	r2,r2,-10588
 324ac08:	10800717 	ldw	r2,28(r2)
 324ac0c:	10c00044 	addi	r3,r2,1
 324ac10:	0080c9b4 	movhi	r2,806
 324ac14:	10b5a904 	addi	r2,r2,-10588
 324ac18:	10c00715 	stw	r3,28(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 324ac1c:	0080c974 	movhi	r2,805
 324ac20:	10931c04 	addi	r2,r2,19568
 324ac24:	10800017 	ldw	r2,0(r2)
 324ac28:	1081000c 	andi	r2,r2,1024
 324ac2c:	1005003a 	cmpeq	r2,r2,zero
 324ac30:	1000141e 	bne	r2,zero,324ac84 <icmprcv+0x378>
 324ac34:	0080c974 	movhi	r2,805
 324ac38:	10931c04 	addi	r2,r2,19568
 324ac3c:	10800017 	ldw	r2,0(r2)
 324ac40:	1080800c 	andi	r2,r2,512
 324ac44:	1005003a 	cmpeq	r2,r2,zero
 324ac48:	10000e1e 	bne	r2,zero,324ac84 <icmprcv+0x378>
         dprintf("ICMP: echo reply to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 324ac4c:	e0bffb17 	ldw	r2,-20(fp)
 324ac50:	11403fcc 	andi	r5,r2,255
 324ac54:	e0bffb17 	ldw	r2,-20(fp)
 324ac58:	1004d23a 	srli	r2,r2,8
 324ac5c:	11803fcc 	andi	r6,r2,255
 324ac60:	e0bffb17 	ldw	r2,-20(fp)
 324ac64:	1004d43a 	srli	r2,r2,16
 324ac68:	11c03fcc 	andi	r7,r2,255
 324ac6c:	e0bffb17 	ldw	r2,-20(fp)
 324ac70:	1004d63a 	srli	r2,r2,24
 324ac74:	d8800015 	stw	r2,0(sp)
 324ac78:	0100c974 	movhi	r4,805
 324ac7c:	2101c204 	addi	r4,r4,1800
 324ac80:	3206de00 	call	3206de0 <printf>
#endif
      e->ptype = ECHOREP;
 324ac84:	e0bff917 	ldw	r2,-28(fp)
 324ac88:	10000005 	stb	zero,0(r2)
      e->pchksum = 0;
 324ac8c:	e0bff917 	ldw	r2,-28(fp)
 324ac90:	1000008d 	sth	zero,2(r2)
      if (len&1)  /* pad odd length packets for checksum routine */
 324ac94:	e0bffc17 	ldw	r2,-16(fp)
 324ac98:	1080004c 	andi	r2,r2,1
 324ac9c:	10803fcc 	andi	r2,r2,255
 324aca0:	1005003a 	cmpeq	r2,r2,zero
 324aca4:	1000091e 	bne	r2,zero,324accc <icmprcv+0x3c0>
      {
         sav_ch = *(((char *) e) + len);
 324aca8:	e0fff917 	ldw	r3,-28(fp)
 324acac:	e0bffc17 	ldw	r2,-16(fp)
 324acb0:	1885883a 	add	r2,r3,r2
 324acb4:	10800003 	ldbu	r2,0(r2)
 324acb8:	e0bff505 	stb	r2,-44(fp)
         ((char *)e)[len] = 0;
 324acbc:	e0fff917 	ldw	r3,-28(fp)
 324acc0:	e0bffc17 	ldw	r2,-16(fp)
 324acc4:	1885883a 	add	r2,r3,r2
 324acc8:	10000005 	stb	zero,0(r2)
      }

      e->pchksum = ~cksum(e, (len+1)>>1);
 324accc:	e0bffc17 	ldw	r2,-16(fp)
 324acd0:	10800044 	addi	r2,r2,1
 324acd4:	100ad07a 	srli	r5,r2,1
 324acd8:	e13ff917 	ldw	r4,-28(fp)
 324acdc:	3225d5c0 	call	3225d5c <cksum>
 324ace0:	0084303a 	nor	r2,zero,r2
 324ace4:	1007883a 	mov	r3,r2
 324ace8:	e0bff917 	ldw	r2,-28(fp)
 324acec:	10c0008d 	sth	r3,2(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
 324acf0:	e0bffc17 	ldw	r2,-16(fp)
 324acf4:	1080004c 	andi	r2,r2,1
 324acf8:	10803fcc 	andi	r2,r2,255
 324acfc:	1005003a 	cmpeq	r2,r2,zero
 324ad00:	1000051e 	bne	r2,zero,324ad18 <icmprcv+0x40c>
 324ad04:	e0fff917 	ldw	r3,-28(fp)
 324ad08:	e0bffc17 	ldw	r2,-16(fp)
 324ad0c:	1887883a 	add	r3,r3,r2
 324ad10:	e0bff503 	ldbu	r2,-44(fp)
 324ad14:	18800005 	stb	r2,0(r3)
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 324ad18:	e0bffa17 	ldw	r2,-24(fp)
 324ad1c:	10800417 	ldw	r2,16(r2)
 324ad20:	10bfffe0 	cmpeqi	r2,r2,-1
 324ad24:	1000211e 	bne	r2,zero,324adac <icmprcv+0x4a0>
 324ad28:	e0bffa17 	ldw	r2,-24(fp)
 324ad2c:	10800417 	ldw	r2,16(r2)
 324ad30:	1004d63a 	srli	r2,r2,24
 324ad34:	10c03fcc 	andi	r3,r2,255
 324ad38:	e0bffa17 	ldw	r2,-24(fp)
 324ad3c:	10800417 	ldw	r2,16(r2)
 324ad40:	1004d23a 	srli	r2,r2,8
 324ad44:	10bfc00c 	andi	r2,r2,65280
 324ad48:	1886b03a 	or	r3,r3,r2
 324ad4c:	e0bffa17 	ldw	r2,-24(fp)
 324ad50:	10800417 	ldw	r2,16(r2)
 324ad54:	10bfc00c 	andi	r2,r2,65280
 324ad58:	1004923a 	slli	r2,r2,8
 324ad5c:	1886b03a 	or	r3,r3,r2
 324ad60:	e0bffa17 	ldw	r2,-24(fp)
 324ad64:	10800417 	ldw	r2,16(r2)
 324ad68:	10803fcc 	andi	r2,r2,255
 324ad6c:	1004963a 	slli	r2,r2,24
 324ad70:	1884b03a 	or	r2,r3,r2
 324ad74:	10fc002c 	andhi	r3,r2,61440
 324ad78:	00b80034 	movhi	r2,57344
 324ad7c:	18800b26 	beq	r3,r2,324adac <icmprcv+0x4a0>
 324ad80:	e0bffa17 	ldw	r2,-24(fp)
 324ad84:	11000417 	ldw	r4,16(r2)
 324ad88:	e0bffd17 	ldw	r2,-12(fp)
 324ad8c:	10800617 	ldw	r2,24(r2)
 324ad90:	10c00a17 	ldw	r3,40(r2)
 324ad94:	e0bffd17 	ldw	r2,-12(fp)
 324ad98:	10800617 	ldw	r2,24(r2)
 324ad9c:	10800c17 	ldw	r2,48(r2)
 324ada0:	0084303a 	nor	r2,zero,r2
 324ada4:	1884b03a 	or	r2,r3,r2
 324ada8:	2080061e 	bne	r4,r2,324adc4 <icmprcv+0x4b8>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
 324adac:	e0bffd17 	ldw	r2,-12(fp)
 324adb0:	10800617 	ldw	r2,24(r2)
 324adb4:	10c00a17 	ldw	r3,40(r2)
 324adb8:	e0bffa17 	ldw	r2,-24(fp)
 324adbc:	10c00315 	stw	r3,12(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 324adc0:	00000406 	br	324add4 <icmprcv+0x4c8>
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
      }
      else pip->ip_src = pip->ip_dest;
 324adc4:	e0bffa17 	ldw	r2,-24(fp)
 324adc8:	10c00417 	ldw	r3,16(r2)
 324adcc:	e0bffa17 	ldw	r2,-24(fp)
 324add0:	10c00315 	stw	r3,12(r2)

      pip->ip_dest = host;
 324add4:	e0fffa17 	ldw	r3,-24(fp)
 324add8:	e0bffb17 	ldw	r2,-20(fp)
 324addc:	18800415 	stw	r2,16(r3)
      icmp_mib.icmpOutEchoReps++;
 324ade0:	0080c9b4 	movhi	r2,806
 324ade4:	10b5a904 	addi	r2,r2,-10588
 324ade8:	10801517 	ldw	r2,84(r2)
 324adec:	10c00044 	addi	r3,r2,1
 324adf0:	0080c9b4 	movhi	r2,806
 324adf4:	10b5a904 	addi	r2,r2,-10588
 324adf8:	10c01515 	stw	r3,84(r2)
      icmp_mib.icmpOutMsgs++;
 324adfc:	0080c9b4 	movhi	r2,806
 324ae00:	10b5a904 	addi	r2,r2,-10588
 324ae04:	10800d17 	ldw	r2,52(r2)
 324ae08:	10c00044 	addi	r3,r2,1
 324ae0c:	0080c9b4 	movhi	r2,806
 324ae10:	10b5a904 	addi	r2,r2,-10588
 324ae14:	10c00d15 	stw	r3,52(r2)
      p->fhost = host;
 324ae18:	e0fffd17 	ldw	r3,-12(fp)
 324ae1c:	e0bffb17 	ldw	r2,-20(fp)
 324ae20:	18800715 	stw	r2,28(r3)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 324ae24:	e0bffd17 	ldw	r2,-12(fp)
 324ae28:	10c00317 	ldw	r3,12(r2)
 324ae2c:	e0bffa17 	ldw	r2,-24(fp)
 324ae30:	10800003 	ldbu	r2,0(r2)
 324ae34:	10803fcc 	andi	r2,r2,255
 324ae38:	108003cc 	andi	r2,r2,15
 324ae3c:	1085883a 	add	r2,r2,r2
 324ae40:	1085883a 	add	r2,r2,r2
 324ae44:	1887883a 	add	r3,r3,r2
 324ae48:	e0bffd17 	ldw	r2,-12(fp)
 324ae4c:	10c00315 	stw	r3,12(r2)
      p->nb_plen = len;
 324ae50:	e0fffd17 	ldw	r3,-12(fp)
 324ae54:	e0bffc17 	ldw	r2,-16(fp)
 324ae58:	18800415 	stw	r2,16(r3)

      i = ip_write(ICMP_PROT, p);
 324ae5c:	01000044 	movi	r4,1
 324ae60:	e17ffd17 	ldw	r5,-12(fp)
 324ae64:	323f3740 	call	323f374 <ip_write>
 324ae68:	e0bff415 	stw	r2,-48(fp)
      if (i < 0)
 324ae6c:	e0bff417 	ldw	r2,-48(fp)
 324ae70:	1004403a 	cmpge	r2,r2,zero
 324ae74:	1000091e 	bne	r2,zero,324ae9c <icmprcv+0x590>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (UPCTRACE))
 324ae78:	0080c974 	movhi	r2,805
 324ae7c:	10931c04 	addi	r2,r2,19568
 324ae80:	10800017 	ldw	r2,0(r2)
 324ae84:	1081000c 	andi	r2,r2,1024
 324ae88:	1005003a 	cmpeq	r2,r2,zero
 324ae8c:	1000031e 	bne	r2,zero,324ae9c <icmprcv+0x590>
            dprintf("icmp: reply failed\n");
 324ae90:	0100c974 	movhi	r4,805
 324ae94:	2101cb04 	addi	r4,r4,1836
 324ae98:	32071080 	call	3207108 <puts>
#endif
      }
      /* reused p will be freed by net->xxx_send() */
      return 0;
 324ae9c:	e03fff15 	stw	zero,-4(fp)
 324aea0:	00019f06 	br	324b520 <icmprcv+0xc14>
   case ECHOREP:
      icmp_mib.icmpInEchoReps++;
 324aea4:	0080c9b4 	movhi	r2,806
 324aea8:	10b5a904 	addi	r2,r2,-10588
 324aeac:	10800817 	ldw	r2,32(r2)
 324aeb0:	10c00044 	addi	r3,r2,1
 324aeb4:	0080c9b4 	movhi	r2,806
 324aeb8:	10b5a904 	addi	r2,r2,-10588
 324aebc:	10c00815 	stw	r3,32(r2)
      
/* 
 * Altera Niche Stack Nios port modification
 */
#if defined(ALT_INICHE) && !defined(PING_APP) && defined(IP_RAW)
      return(ip_raw_input(p));
 324aec0:	e13ffd17 	ldw	r4,-12(fp)
 324aec4:	3243d540 	call	3243d54 <ip_raw_input>
 324aec8:	e0bfff15 	stw	r2,-4(fp)
 324aecc:	00019406 	br	324b520 <icmprcv+0xc14>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
      return(0);
#endif   /* PING_APP */
#ifdef FULL_ICMP
   case DESTIN:
      icmp_mib.icmpInDestUnreachs++;
 324aed0:	0080c9b4 	movhi	r2,806
 324aed4:	10b5a904 	addi	r2,r2,-10588
 324aed8:	10800217 	ldw	r2,8(r2)
 324aedc:	10c00044 	addi	r3,r2,1
 324aee0:	0080c9b4 	movhi	r2,806
 324aee4:	10b5a904 	addi	r2,r2,-10588
 324aee8:	10c00215 	stw	r3,8(r2)
      pdp = (struct destun *)e;
 324aeec:	e0bff917 	ldw	r2,-28(fp)
 324aef0:	e0bff615 	stw	r2,-40(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 324aef4:	0080c974 	movhi	r2,805
 324aef8:	10931c04 	addi	r2,r2,19568
 324aefc:	10800017 	ldw	r2,0(r2)
 324af00:	1081000c 	andi	r2,r2,1024
 324af04:	1005003a 	cmpeq	r2,r2,zero
 324af08:	1000291e 	bne	r2,zero,324afb0 <icmprcv+0x6a4>
      {
         dprintf("ICMP: got dest unreachable type ");
 324af0c:	0100c974 	movhi	r4,805
 324af10:	2101d004 	addi	r4,r4,1856
 324af14:	3206de00 	call	3206de0 <printf>
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 324af18:	e0bff617 	ldw	r2,-40(fp)
 324af1c:	10800043 	ldbu	r2,1(r2)
 324af20:	11403fcc 	andi	r5,r2,255
 324af24:	2940201c 	xori	r5,r5,128
 324af28:	297fe004 	addi	r5,r5,-128
 324af2c:	e0bff617 	ldw	r2,-40(fp)
 324af30:	10800617 	ldw	r2,24(r2)
 324af34:	11803fcc 	andi	r6,r2,255
 324af38:	e0bff617 	ldw	r2,-40(fp)
 324af3c:	10800617 	ldw	r2,24(r2)
 324af40:	1004d23a 	srli	r2,r2,8
 324af44:	11c03fcc 	andi	r7,r2,255
 324af48:	e0bff617 	ldw	r2,-40(fp)
 324af4c:	10800617 	ldw	r2,24(r2)
 324af50:	1004d43a 	srli	r2,r2,16
 324af54:	10c03fcc 	andi	r3,r2,255
 324af58:	e0bff617 	ldw	r2,-40(fp)
 324af5c:	10800617 	ldw	r2,24(r2)
 324af60:	1004d63a 	srli	r2,r2,24
 324af64:	d8c00015 	stw	r3,0(sp)
 324af68:	d8800115 	stw	r2,4(sp)
 324af6c:	0100c974 	movhi	r4,805
 324af70:	2101d904 	addi	r4,r4,1892
 324af74:	3206de00 	call	3206de0 <printf>
          PUSH_IPADDR(pdp->dip.ip_dest));
         dprintf("from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 324af78:	e0bffb17 	ldw	r2,-20(fp)
 324af7c:	11403fcc 	andi	r5,r2,255
 324af80:	e0bffb17 	ldw	r2,-20(fp)
 324af84:	1004d23a 	srli	r2,r2,8
 324af88:	11803fcc 	andi	r6,r2,255
 324af8c:	e0bffb17 	ldw	r2,-20(fp)
 324af90:	1004d43a 	srli	r2,r2,16
 324af94:	11c03fcc 	andi	r7,r2,255
 324af98:	e0bffb17 	ldw	r2,-20(fp)
 324af9c:	1004d63a 	srli	r2,r2,24
 324afa0:	d8800015 	stw	r2,0(sp)
 324afa4:	0100c974 	movhi	r4,805
 324afa8:	2101de04 	addi	r4,r4,1912
 324afac:	3206de00 	call	3206de0 <printf>
      }
#endif   /* NPDEBUG */
      icmp_du(p, pdp);
 324afb0:	e13ffd17 	ldw	r4,-12(fp)
 324afb4:	e17ff617 	ldw	r5,-40(fp)
 324afb8:	324bbc40 	call	324bbc4 <icmp_du>
      break;
 324afbc:	00015606 	br	324b518 <icmprcv+0xc0c>
   case SOURCEQ:
      icmp_mib.icmpInSrcQuenchs++;
 324afc0:	0080c9b4 	movhi	r2,806
 324afc4:	10b5a904 	addi	r2,r2,-10588
 324afc8:	10800517 	ldw	r2,20(r2)
 324afcc:	10c00044 	addi	r3,r2,1
 324afd0:	0080c9b4 	movhi	r2,806
 324afd4:	10b5a904 	addi	r2,r2,-10588
 324afd8:	10c00515 	stw	r3,20(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 324afdc:	0080c974 	movhi	r2,805
 324afe0:	10931c04 	addi	r2,r2,19568
 324afe4:	10800017 	ldw	r2,0(r2)
 324afe8:	1081000c 	andi	r2,r2,1024
 324afec:	1005003a 	cmpeq	r2,r2,zero
 324aff0:	1000161e 	bne	r2,zero,324b04c <icmprcv+0x740>
      {
         dprintf("ICMP: source quench from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 324aff4:	e0bffb17 	ldw	r2,-20(fp)
 324aff8:	11403fcc 	andi	r5,r2,255
 324affc:	e0bffb17 	ldw	r2,-20(fp)
 324b000:	1004d23a 	srli	r2,r2,8
 324b004:	11803fcc 	andi	r6,r2,255
 324b008:	e0bffb17 	ldw	r2,-20(fp)
 324b00c:	1004d43a 	srli	r2,r2,16
 324b010:	11c03fcc 	andi	r7,r2,255
 324b014:	e0bffb17 	ldw	r2,-20(fp)
 324b018:	1004d63a 	srli	r2,r2,24
 324b01c:	d8800015 	stw	r2,0(sp)
 324b020:	0100c974 	movhi	r4,805
 324b024:	2101e304 	addi	r4,r4,1932
 324b028:	3206de00 	call	3206de0 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 324b02c:	0080c974 	movhi	r2,805
 324b030:	10931c04 	addi	r2,r2,19568
 324b034:	10800017 	ldw	r2,0(r2)
 324b038:	1080008c 	andi	r2,r2,2
 324b03c:	1005003a 	cmpeq	r2,r2,zero
 324b040:	1000021e 	bne	r2,zero,324b04c <icmprcv+0x740>
 324b044:	e13ffd17 	ldw	r4,-12(fp)
 324b048:	324059c0 	call	324059c <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 324b04c:	01000084 	movi	r4,2
 324b050:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(p);
 324b054:	e13ffd17 	ldw	r4,-12(fp)
 324b058:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324b05c:	01000084 	movi	r4,2
 324b060:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      break;
 324b064:	00012c06 	br	324b518 <icmprcv+0xc0c>
   case REDIR:          /* got an icmp redirect */
      icmp_mib.icmpInRedirects++;
 324b068:	0080c9b4 	movhi	r2,806
 324b06c:	10b5a904 	addi	r2,r2,-10588
 324b070:	10800617 	ldw	r2,24(r2)
 324b074:	10c00044 	addi	r3,r2,1
 324b078:	0080c9b4 	movhi	r2,806
 324b07c:	10b5a904 	addi	r2,r2,-10588
 324b080:	10c00615 	stw	r3,24(r2)
      rd = (struct redirect *)e;
 324b084:	e0bff917 	ldw	r2,-28(fp)
 324b088:	e0bff715 	stw	r2,-36(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 324b08c:	0080c974 	movhi	r2,805
 324b090:	10931c04 	addi	r2,r2,19568
 324b094:	10800017 	ldw	r2,0(r2)
 324b098:	1081000c 	andi	r2,r2,1024
 324b09c:	1005003a 	cmpeq	r2,r2,zero
 324b0a0:	1000241e 	bne	r2,zero,324b134 <icmprcv+0x828>
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 324b0a4:	e0bff717 	ldw	r2,-36(fp)
 324b0a8:	10800617 	ldw	r2,24(r2)
 324b0ac:	11403fcc 	andi	r5,r2,255
 324b0b0:	e0bff717 	ldw	r2,-36(fp)
 324b0b4:	10800617 	ldw	r2,24(r2)
 324b0b8:	1004d23a 	srli	r2,r2,8
 324b0bc:	11803fcc 	andi	r6,r2,255
 324b0c0:	e0bff717 	ldw	r2,-36(fp)
 324b0c4:	10800617 	ldw	r2,24(r2)
 324b0c8:	1004d43a 	srli	r2,r2,16
 324b0cc:	11c03fcc 	andi	r7,r2,255
 324b0d0:	e0bff717 	ldw	r2,-36(fp)
 324b0d4:	10800617 	ldw	r2,24(r2)
 324b0d8:	1004d63a 	srli	r2,r2,24
 324b0dc:	d8800015 	stw	r2,0(sp)
 324b0e0:	0100c974 	movhi	r4,805
 324b0e4:	2101ed04 	addi	r4,r4,1972
 324b0e8:	3206de00 	call	3206de0 <printf>
          PUSH_IPADDR(rd->rdip.ip_dest));
         dprintf("to %u.%u.%u.%u\n", PUSH_IPADDR(rd->rdgw));
 324b0ec:	e0bff717 	ldw	r2,-36(fp)
 324b0f0:	10800117 	ldw	r2,4(r2)
 324b0f4:	11403fcc 	andi	r5,r2,255
 324b0f8:	e0bff717 	ldw	r2,-36(fp)
 324b0fc:	10800117 	ldw	r2,4(r2)
 324b100:	1004d23a 	srli	r2,r2,8
 324b104:	11803fcc 	andi	r6,r2,255
 324b108:	e0bff717 	ldw	r2,-36(fp)
 324b10c:	10800117 	ldw	r2,4(r2)
 324b110:	1004d43a 	srli	r2,r2,16
 324b114:	11c03fcc 	andi	r7,r2,255
 324b118:	e0bff717 	ldw	r2,-36(fp)
 324b11c:	10800117 	ldw	r2,4(r2)
 324b120:	1004d63a 	srli	r2,r2,24
 324b124:	d8800015 	stw	r2,0(sp)
 324b128:	0100c974 	movhi	r4,805
 324b12c:	2101f704 	addi	r4,r4,2012
 324b130:	3206de00 	call	3206de0 <printf>
      }
#endif   /* NPDEBUG */
#ifdef IP_ROUTING
      /* try to add/update route table */
      add_route(rd->rdip.ip_dest, 0xFFFFFFFF, rd->rdgw, 
 324b134:	e0bff717 	ldw	r2,-36(fp)
 324b138:	14000617 	ldw	r16,24(r2)
 324b13c:	e0bff717 	ldw	r2,-36(fp)
 324b140:	14400117 	ldw	r17,4(r2)
 324b144:	e0bffd17 	ldw	r2,-12(fp)
 324b148:	11000617 	ldw	r4,24(r2)
 324b14c:	32240bc0 	call	32240bc <if_netnumber>
 324b150:	100f883a 	mov	r7,r2
 324b154:	00800104 	movi	r2,4
 324b158:	d8800015 	stw	r2,0(sp)
 324b15c:	8009883a 	mov	r4,r16
 324b160:	017fffc4 	movi	r5,-1
 324b164:	880d883a 	mov	r6,r17
 324b168:	32442780 	call	3244278 <add_route>
       net_num(p->net), IPRP_ICMP);
#endif   /* IP_ROUTING */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 324b16c:	01000084 	movi	r4,2
 324b170:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(p);
 324b174:	e13ffd17 	ldw	r4,-12(fp)
 324b178:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324b17c:	01000084 	movi	r4,2
 324b180:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      break;
 324b184:	0000e406 	br	324b518 <icmprcv+0xc0c>
   case TIMEX:
      icmp_mib.icmpInTimeExcds++;
 324b188:	0080c9b4 	movhi	r2,806
 324b18c:	10b5a904 	addi	r2,r2,-10588
 324b190:	10800317 	ldw	r2,12(r2)
 324b194:	10c00044 	addi	r3,r2,1
 324b198:	0080c9b4 	movhi	r2,806
 324b19c:	10b5a904 	addi	r2,r2,-10588
 324b1a0:	10c00315 	stw	r3,12(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 324b1a4:	0080c974 	movhi	r2,805
 324b1a8:	10931c04 	addi	r2,r2,19568
 324b1ac:	10800017 	ldw	r2,0(r2)
 324b1b0:	1081000c 	andi	r2,r2,1024
 324b1b4:	1005003a 	cmpeq	r2,r2,zero
 324b1b8:	10002e1e 	bne	r2,zero,324b274 <icmprcv+0x968>
      {
         struct timex * pt =  (struct  timex *)e;
 324b1bc:	e0bff917 	ldw	r2,-28(fp)
 324b1c0:	e0bff315 	stw	r2,-52(fp)

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 324b1c4:	e0bffd17 	ldw	r2,-12(fp)
 324b1c8:	10800717 	ldw	r2,28(r2)
 324b1cc:	11403fcc 	andi	r5,r2,255
 324b1d0:	e0bffd17 	ldw	r2,-12(fp)
 324b1d4:	10800717 	ldw	r2,28(r2)
 324b1d8:	1004d23a 	srli	r2,r2,8
 324b1dc:	11803fcc 	andi	r6,r2,255
 324b1e0:	e0bffd17 	ldw	r2,-12(fp)
 324b1e4:	10800717 	ldw	r2,28(r2)
 324b1e8:	1004d43a 	srli	r2,r2,16
 324b1ec:	11c03fcc 	andi	r7,r2,255
 324b1f0:	e0bffd17 	ldw	r2,-12(fp)
 324b1f4:	10800717 	ldw	r2,28(r2)
 324b1f8:	1004d63a 	srli	r2,r2,24
 324b1fc:	d8800015 	stw	r2,0(sp)
 324b200:	0100c974 	movhi	r4,805
 324b204:	2101fb04 	addi	r4,r4,2028
 324b208:	3206de00 	call	3206de0 <printf>
          PUSH_IPADDR(p->fhost));
         dprintf(" about %u.%u.%u.%u\n", PUSH_IPADDR(pt->tip.ip_dest));
 324b20c:	e0bff317 	ldw	r2,-52(fp)
 324b210:	10800617 	ldw	r2,24(r2)
 324b214:	11403fcc 	andi	r5,r2,255
 324b218:	e0bff317 	ldw	r2,-52(fp)
 324b21c:	10800617 	ldw	r2,24(r2)
 324b220:	1004d23a 	srli	r2,r2,8
 324b224:	11803fcc 	andi	r6,r2,255
 324b228:	e0bff317 	ldw	r2,-52(fp)
 324b22c:	10800617 	ldw	r2,24(r2)
 324b230:	1004d43a 	srli	r2,r2,16
 324b234:	11c03fcc 	andi	r7,r2,255
 324b238:	e0bff317 	ldw	r2,-52(fp)
 324b23c:	10800617 	ldw	r2,24(r2)
 324b240:	1004d63a 	srli	r2,r2,24
 324b244:	d8800015 	stw	r2,0(sp)
 324b248:	0100c974 	movhi	r4,805
 324b24c:	21020404 	addi	r4,r4,2064
 324b250:	3206de00 	call	3206de0 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 324b254:	0080c974 	movhi	r2,805
 324b258:	10931c04 	addi	r2,r2,19568
 324b25c:	10800017 	ldw	r2,0(r2)
 324b260:	1080008c 	andi	r2,r2,2
 324b264:	1005003a 	cmpeq	r2,r2,zero
 324b268:	1000021e 	bne	r2,zero,324b274 <icmprcv+0x968>
 324b26c:	e13ffd17 	ldw	r4,-12(fp)
 324b270:	324059c0 	call	324059c <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 324b274:	01000084 	movi	r4,2
 324b278:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(p);
 324b27c:	e13ffd17 	ldw	r4,-12(fp)
 324b280:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324b284:	01000084 	movi	r4,2
 324b288:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      break;
 324b28c:	0000a206 	br	324b518 <icmprcv+0xc0c>
   case PARAM:
      icmp_mib.icmpInParmProbs++;
 324b290:	0080c9b4 	movhi	r2,806
 324b294:	10b5a904 	addi	r2,r2,-10588
 324b298:	10800417 	ldw	r2,16(r2)
 324b29c:	10c00044 	addi	r3,r2,1
 324b2a0:	0080c9b4 	movhi	r2,806
 324b2a4:	10b5a904 	addi	r2,r2,-10588
 324b2a8:	10c00415 	stw	r3,16(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 324b2ac:	0080c974 	movhi	r2,805
 324b2b0:	10931c04 	addi	r2,r2,19568
 324b2b4:	10800017 	ldw	r2,0(r2)
 324b2b8:	1081000c 	andi	r2,r2,1024
 324b2bc:	1005003a 	cmpeq	r2,r2,zero
 324b2c0:	1000031e 	bne	r2,zero,324b2d0 <icmprcv+0x9c4>
         dprintf("ICMP: got param problem message\n");
 324b2c4:	0100c974 	movhi	r4,805
 324b2c8:	21020904 	addi	r4,r4,2084
 324b2cc:	32071080 	call	3207108 <puts>
      if (NDEBUG & DUMP)
 324b2d0:	0080c974 	movhi	r2,805
 324b2d4:	10931c04 	addi	r2,r2,19568
 324b2d8:	10800017 	ldw	r2,0(r2)
 324b2dc:	1080008c 	andi	r2,r2,2
 324b2e0:	1005003a 	cmpeq	r2,r2,zero
 324b2e4:	1000021e 	bne	r2,zero,324b2f0 <icmprcv+0x9e4>
      {
         ip_dump(p);
 324b2e8:	e13ffd17 	ldw	r4,-12(fp)
 324b2ec:	324059c0 	call	324059c <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 324b2f0:	01000084 	movi	r4,2
 324b2f4:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(p);
 324b2f8:	e13ffd17 	ldw	r4,-12(fp)
 324b2fc:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324b300:	01000084 	movi	r4,2
 324b304:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      break;
 324b308:	00008306 	br	324b518 <icmprcv+0xc0c>
   case TIMEREQ:
      icmp_mib.icmpInTimestamps++;
 324b30c:	0080c9b4 	movhi	r2,806
 324b310:	10b5a904 	addi	r2,r2,-10588
 324b314:	10800917 	ldw	r2,36(r2)
 324b318:	10c00044 	addi	r3,r2,1
 324b31c:	0080c9b4 	movhi	r2,806
 324b320:	10b5a904 	addi	r2,r2,-10588
 324b324:	10c00915 	stw	r3,36(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 324b328:	0080c974 	movhi	r2,805
 324b32c:	10931c04 	addi	r2,r2,19568
 324b330:	10800017 	ldw	r2,0(r2)
 324b334:	1081000c 	andi	r2,r2,1024
 324b338:	1005003a 	cmpeq	r2,r2,zero
 324b33c:	1000031e 	bne	r2,zero,324b34c <icmprcv+0xa40>
         dprintf("ICMP: got timestamp request\n");
 324b340:	0100c974 	movhi	r4,805
 324b344:	21021104 	addi	r4,r4,2116
 324b348:	32071080 	call	3207108 <puts>
#endif   /* NPDEBUG */
      e->ptype = TIMEREP;
 324b34c:	e0fff917 	ldw	r3,-28(fp)
 324b350:	00800384 	movi	r2,14
 324b354:	18800005 	stb	r2,0(r3)
      e->pchksum = 0;
 324b358:	e0bff917 	ldw	r2,-28(fp)
 324b35c:	1000008d 	sth	zero,2(r2)
		   */
		  sstmp->dtstamp[1] = sstmp->dtstamp[2] = user_UTCtime();
	  }
#endif /* USER_PING_TSTAMP */

      e->pchksum = ~cksum(e, sizeof(struct tstamp)>>1);
 324b360:	e13ff917 	ldw	r4,-28(fp)
 324b364:	01400284 	movi	r5,10
 324b368:	3225d5c0 	call	3225d5c <cksum>
 324b36c:	0084303a 	nor	r2,zero,r2
 324b370:	1007883a 	mov	r3,r2
 324b374:	e0bff917 	ldw	r2,-28(fp)
 324b378:	10c0008d 	sth	r3,2(r2)
      pip->ip_src = pip->ip_dest;
 324b37c:	e0bffa17 	ldw	r2,-24(fp)
 324b380:	10c00417 	ldw	r3,16(r2)
 324b384:	e0bffa17 	ldw	r2,-24(fp)
 324b388:	10c00315 	stw	r3,12(r2)
      pip->ip_dest = host;
 324b38c:	e0fffa17 	ldw	r3,-24(fp)
 324b390:	e0bffb17 	ldw	r2,-20(fp)
 324b394:	18800415 	stw	r2,16(r3)
      icmp_mib.icmpOutMsgs++;
 324b398:	0080c9b4 	movhi	r2,806
 324b39c:	10b5a904 	addi	r2,r2,-10588
 324b3a0:	10800d17 	ldw	r2,52(r2)
 324b3a4:	10c00044 	addi	r3,r2,1
 324b3a8:	0080c9b4 	movhi	r2,806
 324b3ac:	10b5a904 	addi	r2,r2,-10588
 324b3b0:	10c00d15 	stw	r3,52(r2)
      icmp_mib.icmpOutTimestampReps++;
 324b3b4:	0080c9b4 	movhi	r2,806
 324b3b8:	10b5a904 	addi	r2,r2,-10588
 324b3bc:	10801717 	ldw	r2,92(r2)
 324b3c0:	10c00044 	addi	r3,r2,1
 324b3c4:	0080c9b4 	movhi	r2,806
 324b3c8:	10b5a904 	addi	r2,r2,-10588
 324b3cc:	10c01715 	stw	r3,92(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 324b3d0:	e0bffd17 	ldw	r2,-12(fp)
 324b3d4:	10c00317 	ldw	r3,12(r2)
 324b3d8:	e0bffa17 	ldw	r2,-24(fp)
 324b3dc:	10800003 	ldbu	r2,0(r2)
 324b3e0:	10803fcc 	andi	r2,r2,255
 324b3e4:	108003cc 	andi	r2,r2,15
 324b3e8:	1085883a 	add	r2,r2,r2
 324b3ec:	1085883a 	add	r2,r2,r2
 324b3f0:	1887883a 	add	r3,r3,r2
 324b3f4:	e0bffd17 	ldw	r2,-12(fp)
 324b3f8:	10c00315 	stw	r3,12(r2)
      p->nb_plen = sizeof(struct tstamp);
 324b3fc:	e0fffd17 	ldw	r3,-12(fp)
 324b400:	00800504 	movi	r2,20
 324b404:	18800415 	stw	r2,16(r3)
      p->fhost = host;
 324b408:	e0fffd17 	ldw	r3,-12(fp)
 324b40c:	e0bffb17 	ldw	r2,-20(fp)
 324b410:	18800715 	stw	r2,28(r3)
      i = ip_write(ICMP_PROT, p);
 324b414:	01000044 	movi	r4,1
 324b418:	e17ffd17 	ldw	r5,-12(fp)
 324b41c:	323f3740 	call	323f374 <ip_write>
 324b420:	e0bff415 	stw	r2,-48(fp)
      if (i < 0)
 324b424:	e0bff417 	ldw	r2,-48(fp)
 324b428:	1004403a 	cmpge	r2,r2,zero
 324b42c:	1000091e 	bne	r2,zero,324b454 <icmprcv+0xb48>
      {
#ifdef   NPDEBUG
         if (NDEBUG & UPCTRACE)
 324b430:	0080c974 	movhi	r2,805
 324b434:	10931c04 	addi	r2,r2,19568
 324b438:	10800017 	ldw	r2,0(r2)
 324b43c:	1081000c 	andi	r2,r2,1024
 324b440:	1005003a 	cmpeq	r2,r2,zero
 324b444:	1000031e 	bne	r2,zero,324b454 <icmprcv+0xb48>
            dprintf("icmp: can't send timestamp reply\n");
 324b448:	0100c974 	movhi	r4,805
 324b44c:	21021804 	addi	r4,r4,2144
 324b450:	32071080 	call	3207108 <puts>
#endif   /* NPDEBUG */
      }
      /* re-used packet was pk_free()d by net->send() */
      return (0);
 324b454:	e03fff15 	stw	zero,-4(fp)
 324b458:	00003106 	br	324b520 <icmprcv+0xc14>
   case INFO:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 324b45c:	0080c974 	movhi	r2,805
 324b460:	10931c04 	addi	r2,r2,19568
 324b464:	10800017 	ldw	r2,0(r2)
 324b468:	1081000c 	andi	r2,r2,1024
 324b46c:	1005003a 	cmpeq	r2,r2,zero
 324b470:	1000031e 	bne	r2,zero,324b480 <icmprcv+0xb74>
         dprintf("icmp: got info request\n");
 324b474:	0100c974 	movhi	r4,805
 324b478:	21022104 	addi	r4,r4,2180
 324b47c:	32071080 	call	3207108 <puts>
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 324b480:	01000084 	movi	r4,2
 324b484:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(p);
 324b488:	e13ffd17 	ldw	r4,-12(fp)
 324b48c:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324b490:	01000084 	movi	r4,2
 324b494:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      break;
 324b498:	00001f06 	br	324b518 <icmprcv+0xc0c>
#endif   /* FULL_ICMP */
   default:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 324b49c:	0080c974 	movhi	r2,805
 324b4a0:	10931c04 	addi	r2,r2,19568
 324b4a4:	10800017 	ldw	r2,0(r2)
 324b4a8:	1081000c 	andi	r2,r2,1024
 324b4ac:	1005003a 	cmpeq	r2,r2,zero
 324b4b0:	1000101e 	bne	r2,zero,324b4f4 <icmprcv+0xbe8>
      {
         dprintf("icmp: unhandled type %u\n", e->ptype);
 324b4b4:	e0bff917 	ldw	r2,-28(fp)
 324b4b8:	10800003 	ldbu	r2,0(r2)
 324b4bc:	11403fcc 	andi	r5,r2,255
 324b4c0:	2940201c 	xori	r5,r5,128
 324b4c4:	297fe004 	addi	r5,r5,-128
 324b4c8:	0100c974 	movhi	r4,805
 324b4cc:	21022704 	addi	r4,r4,2204
 324b4d0:	3206de00 	call	3206de0 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 324b4d4:	0080c974 	movhi	r2,805
 324b4d8:	10931c04 	addi	r2,r2,19568
 324b4dc:	10800017 	ldw	r2,0(r2)
 324b4e0:	1080008c 	andi	r2,r2,2
 324b4e4:	1005003a 	cmpeq	r2,r2,zero
 324b4e8:	1000021e 	bne	r2,zero,324b4f4 <icmprcv+0xbe8>
 324b4ec:	e13ffd17 	ldw	r4,-12(fp)
 324b4f0:	324059c0 	call	324059c <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 324b4f4:	01000084 	movi	r4,2
 324b4f8:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
      pk_free(p);
 324b4fc:	e13ffd17 	ldw	r4,-12(fp)
 324b500:	322a6400 	call	322a640 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324b504:	01000084 	movi	r4,2
 324b508:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>
      return ENP_NOT_MINE;
 324b50c:	00800084 	movi	r2,2
 324b510:	e0bfff15 	stw	r2,-4(fp)
 324b514:	00000206 	br	324b520 <icmprcv+0xc14>
   }
#ifdef FULL_ICMP
   return ENP_NOT_MINE;
 324b518:	00c00084 	movi	r3,2
 324b51c:	e0ffff15 	stw	r3,-4(fp)
 324b520:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* FULL_ICMP */
}
 324b524:	e037883a 	mov	sp,fp
 324b528:	dfc00317 	ldw	ra,12(sp)
 324b52c:	df000217 	ldw	fp,8(sp)
 324b530:	dc400117 	ldw	r17,4(sp)
 324b534:	dc000017 	ldw	r16,0(sp)
 324b538:	dec00404 	addi	sp,sp,16
 324b53c:	f800283a 	ret

0324b540 <icmp_destun>:
icmp_destun(ip_addr host,  /* host to complain to */
   ip_addr src_addr, /* source address for outgoing ICMP/IP packet header */
   struct ip * ip,   /* IP header of offending packet */
   unsigned typecode,    /* type & code of DU to send (PROT, PORT, HOST) */
   NET   net)        /* interface that this packet came in on */
{
 324b540:	defff404 	addi	sp,sp,-48
 324b544:	dfc00b15 	stw	ra,44(sp)
 324b548:	df000a15 	stw	fp,40(sp)
 324b54c:	df000a04 	addi	fp,sp,40
 324b550:	e13ffc15 	stw	r4,-16(fp)
 324b554:	e17ffd15 	stw	r5,-12(fp)
 324b558:	e1bffe15 	stw	r6,-8(fp)
 324b55c:	e1ffff15 	stw	r7,-4(fp)
   struct destun *   d;
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 324b560:	0080c974 	movhi	r2,805
 324b564:	10931c04 	addi	r2,r2,19568
 324b568:	10800017 	ldw	r2,0(r2)
 324b56c:	1080040c 	andi	r2,r2,16
 324b570:	1005003a 	cmpeq	r2,r2,zero
 324b574:	1000171e 	bne	r2,zero,324b5d4 <icmp_destun+0x94>
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 324b578:	e0bfff17 	ldw	r2,-4(fp)
 324b57c:	10803fcc 	andi	r2,r2,255
 324b580:	00c0c974 	movhi	r3,805
 324b584:	18ca5c04 	addi	r3,r3,10608
 324b588:	1085883a 	add	r2,r2,r2
 324b58c:	1085883a 	add	r2,r2,r2
 324b590:	10c5883a 	add	r2,r2,r3
 324b594:	11400017 	ldw	r5,0(r2)
 324b598:	e0bffc17 	ldw	r2,-16(fp)
 324b59c:	11803fcc 	andi	r6,r2,255
 324b5a0:	e0bffc17 	ldw	r2,-16(fp)
 324b5a4:	1004d23a 	srli	r2,r2,8
 324b5a8:	11c03fcc 	andi	r7,r2,255
 324b5ac:	e0bffc17 	ldw	r2,-16(fp)
 324b5b0:	1004d43a 	srli	r2,r2,16
 324b5b4:	10c03fcc 	andi	r3,r2,255
 324b5b8:	e0bffc17 	ldw	r2,-16(fp)
 324b5bc:	1004d63a 	srli	r2,r2,24
 324b5c0:	d8c00015 	stw	r3,0(sp)
 324b5c4:	d8800115 	stw	r2,4(sp)
 324b5c8:	0100c974 	movhi	r4,805
 324b5cc:	21024104 	addi	r4,r4,2308
 324b5d0:	3206de00 	call	3206de0 <printf>
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(FREEQ_RESID);
 324b5d4:	01000084 	movi	r4,2
 324b5d8:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
   p = pk_alloc(512 + IPHSIZ);   /* get packet to send icmp dest unreachable */
 324b5dc:	01008504 	movi	r4,532
 324b5e0:	322a2ac0 	call	322a2ac <pk_alloc>
 324b5e4:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324b5e8:	01000084 	movi	r4,2
 324b5ec:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 324b5f0:	e0bffb17 	ldw	r2,-20(fp)
 324b5f4:	1004c03a 	cmpne	r2,r2,zero
 324b5f8:	1000111e 	bne	r2,zero,324b640 <icmp_destun+0x100>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 324b5fc:	0080c974 	movhi	r2,805
 324b600:	10931c04 	addi	r2,r2,19568
 324b604:	10800017 	ldw	r2,0(r2)
 324b608:	1080800c 	andi	r2,r2,512
 324b60c:	1005003a 	cmpeq	r2,r2,zero
 324b610:	1000031e 	bne	r2,zero,324b620 <icmp_destun+0xe0>
         dprintf("icmp: can't alloc pkt\n");
 324b614:	0100c974 	movhi	r4,805
 324b618:	21024e04 	addi	r4,r4,2360
 324b61c:	32071080 	call	3207108 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 324b620:	0080c9b4 	movhi	r2,806
 324b624:	10b5a904 	addi	r2,r2,-10588
 324b628:	10800e17 	ldw	r2,56(r2)
 324b62c:	10c00044 	addi	r3,r2,1
 324b630:	0080c9b4 	movhi	r2,806
 324b634:	10b5a904 	addi	r2,r2,-10588
 324b638:	10c00e15 	stw	r3,56(r2)
      return;
 324b63c:	00008f06 	br	324b87c <icmp_destun+0x33c>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 324b640:	e0bffb17 	ldw	r2,-20(fp)
 324b644:	10800317 	ldw	r2,12(r2)
 324b648:	e0bff915 	stw	r2,-28(fp)
   pip->ip_src = src_addr;
 324b64c:	e0fff917 	ldw	r3,-28(fp)
 324b650:	e0bffd17 	ldw	r2,-12(fp)
 324b654:	18800315 	stw	r2,12(r3)
   pip->ip_dest = host;
 324b658:	e0fff917 	ldw	r3,-28(fp)
 324b65c:	e0bffc17 	ldw	r2,-16(fp)
 324b660:	18800415 	stw	r2,16(r3)

   /* allow space for icmp header */
   p->nb_prot += sizeof(struct ip);
 324b664:	e0bffb17 	ldw	r2,-20(fp)
 324b668:	10800317 	ldw	r2,12(r2)
 324b66c:	10c00504 	addi	r3,r2,20
 324b670:	e0bffb17 	ldw	r2,-20(fp)
 324b674:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= sizeof(struct ip);
 324b678:	e0bffb17 	ldw	r2,-20(fp)
 324b67c:	10800417 	ldw	r2,16(r2)
 324b680:	10fffb04 	addi	r3,r2,-20
 324b684:	e0bffb17 	ldw	r2,-20(fp)
 324b688:	10c00415 	stw	r3,16(r2)
   p->net = net;     /* Put in the interface that this packet came in on */
 324b68c:	e0fffb17 	ldw	r3,-20(fp)
 324b690:	e0800217 	ldw	r2,8(fp)
 324b694:	18800615 	stw	r2,24(r3)

   d = (struct destun *)p->nb_prot;
 324b698:	e0bffb17 	ldw	r2,-20(fp)
 324b69c:	10800317 	ldw	r2,12(r2)
 324b6a0:	e0bffa15 	stw	r2,-24(fp)

   if (typecode & 0xFF00)               /* if the type was sent */
 324b6a4:	e0bfff17 	ldw	r2,-4(fp)
 324b6a8:	10bfc00c 	andi	r2,r2,65280
 324b6ac:	1005003a 	cmpeq	r2,r2,zero
 324b6b0:	1000061e 	bne	r2,zero,324b6cc <icmp_destun+0x18c>
      d->dtype = (char)(typecode >>8);  /* then use it */
 324b6b4:	e0bfff17 	ldw	r2,-4(fp)
 324b6b8:	1004d23a 	srli	r2,r2,8
 324b6bc:	1007883a 	mov	r3,r2
 324b6c0:	e0bffa17 	ldw	r2,-24(fp)
 324b6c4:	10c00005 	stb	r3,0(r2)
 324b6c8:	00000306 	br	324b6d8 <icmp_destun+0x198>
   else                                 /* else use default */
      d->dtype = DESTIN;
 324b6cc:	e0fffa17 	ldw	r3,-24(fp)
 324b6d0:	008000c4 	movi	r2,3
 324b6d4:	18800005 	stb	r2,0(r3)
   d->dcode = (char)(typecode & 0xFF);
 324b6d8:	e0bfff17 	ldw	r2,-4(fp)
 324b6dc:	1007883a 	mov	r3,r2
 324b6e0:	e0bffa17 	ldw	r2,-24(fp)
 324b6e4:	10c00045 	stb	r3,1(r2)
   d->dno1 = d->dno2 = 0;
 324b6e8:	e0bffa17 	ldw	r2,-24(fp)
 324b6ec:	1000018d 	sth	zero,6(r2)
 324b6f0:	e0bffa17 	ldw	r2,-24(fp)
 324b6f4:	10c0018b 	ldhu	r3,6(r2)
 324b6f8:	e0bffa17 	ldw	r2,-24(fp)
 324b6fc:	10c0010d 	sth	r3,4(r2)
#ifndef ICMP_SUPPRESS_PMTU
   if ((typecode & 0xFF) == DSTFRAG)
 324b700:	e0bfff17 	ldw	r2,-4(fp)
 324b704:	10803fcc 	andi	r2,r2,255
 324b708:	10800118 	cmpnei	r2,r2,4
 324b70c:	1000151e 	bne	r2,zero,324b764 <icmp_destun+0x224>
      d->dno2 = htons(net->n_mtu - net->n_lnh);
 324b710:	e0800217 	ldw	r2,8(fp)
 324b714:	10c00917 	ldw	r3,36(r2)
 324b718:	e0800217 	ldw	r2,8(fp)
 324b71c:	10800817 	ldw	r2,32(r2)
 324b720:	1885c83a 	sub	r2,r3,r2
 324b724:	1005d23a 	srai	r2,r2,8
 324b728:	10803fcc 	andi	r2,r2,255
 324b72c:	1009883a 	mov	r4,r2
 324b730:	e0800217 	ldw	r2,8(fp)
 324b734:	10c00917 	ldw	r3,36(r2)
 324b738:	e0800217 	ldw	r2,8(fp)
 324b73c:	10800817 	ldw	r2,32(r2)
 324b740:	1885c83a 	sub	r2,r3,r2
 324b744:	1004923a 	slli	r2,r2,8
 324b748:	1007883a 	mov	r3,r2
 324b74c:	00bfc004 	movi	r2,-256
 324b750:	1884703a 	and	r2,r3,r2
 324b754:	2084b03a 	or	r2,r4,r2
 324b758:	1007883a 	mov	r3,r2
 324b75c:	e0bffa17 	ldw	r2,-24(fp)
 324b760:	10c0018d 	sth	r3,6(r2)
#endif    /* ICMP_SUPPRESS_PMTU */
   MEMCPY(&d->dip, ip, (sizeof(struct ip) + ICMPDUDATA));
 324b764:	e0bffa17 	ldw	r2,-24(fp)
 324b768:	11000204 	addi	r4,r2,8
 324b76c:	e0fffe17 	ldw	r3,-8(fp)
 324b770:	18800017 	ldw	r2,0(r3)
 324b774:	20800015 	stw	r2,0(r4)
 324b778:	18800117 	ldw	r2,4(r3)
 324b77c:	20800115 	stw	r2,4(r4)
 324b780:	18800217 	ldw	r2,8(r3)
 324b784:	20800215 	stw	r2,8(r4)
 324b788:	18800317 	ldw	r2,12(r3)
 324b78c:	20800315 	stw	r2,12(r4)
 324b790:	18800417 	ldw	r2,16(r3)
 324b794:	20800415 	stw	r2,16(r4)
 324b798:	18800517 	ldw	r2,20(r3)
 324b79c:	20800515 	stw	r2,20(r4)
 324b7a0:	18800617 	ldw	r2,24(r3)
 324b7a4:	20800615 	stw	r2,24(r4)

   d->dchksum = 0;
 324b7a8:	e0bffa17 	ldw	r2,-24(fp)
 324b7ac:	1000008d 	sth	zero,2(r2)
   d->dchksum = ~cksum(d, sizeof(struct destun)>>1);
 324b7b0:	e13ffa17 	ldw	r4,-24(fp)
 324b7b4:	01400484 	movi	r5,18
 324b7b8:	3225d5c0 	call	3225d5c <cksum>
 324b7bc:	0084303a 	nor	r2,zero,r2
 324b7c0:	1007883a 	mov	r3,r2
 324b7c4:	e0bffa17 	ldw	r2,-24(fp)
 324b7c8:	10c0008d 	sth	r3,2(r2)

   p->nb_plen =  sizeof(struct destun);
 324b7cc:	e0fffb17 	ldw	r3,-20(fp)
 324b7d0:	00800904 	movi	r2,36
 324b7d4:	18800415 	stw	r2,16(r3)
   p->fhost = host;
 324b7d8:	e0fffb17 	ldw	r3,-20(fp)
 324b7dc:	e0bffc17 	ldw	r2,-16(fp)
 324b7e0:	18800715 	stw	r2,28(r3)
   i = ip_write(ICMP_PROT, p);
 324b7e4:	01000044 	movi	r4,1
 324b7e8:	e17ffb17 	ldw	r5,-20(fp)
 324b7ec:	323f3740 	call	323f374 <ip_write>
 324b7f0:	e0bff815 	stw	r2,-32(fp)
   if (i < 0)
 324b7f4:	e0bff817 	ldw	r2,-32(fp)
 324b7f8:	1004403a 	cmpge	r2,r2,zero
 324b7fc:	1000111e 	bne	r2,zero,324b844 <icmp_destun+0x304>
   {
      icmp_mib.icmpOutErrors++;
 324b800:	0080c9b4 	movhi	r2,806
 324b804:	10b5a904 	addi	r2,r2,-10588
 324b808:	10800e17 	ldw	r2,56(r2)
 324b80c:	10c00044 	addi	r3,r2,1
 324b810:	0080c9b4 	movhi	r2,806
 324b814:	10b5a904 	addi	r2,r2,-10588
 324b818:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 324b81c:	0080c974 	movhi	r2,805
 324b820:	10931c04 	addi	r2,r2,19568
 324b824:	10800017 	ldw	r2,0(r2)
 324b828:	1080860c 	andi	r2,r2,536
 324b82c:	1005003a 	cmpeq	r2,r2,zero
 324b830:	1000121e 	bne	r2,zero,324b87c <icmp_destun+0x33c>
         dprintf("ICMP: Can't send dest unreachable\n");
 324b834:	0100c974 	movhi	r4,805
 324b838:	21025404 	addi	r4,r4,2384
 324b83c:	32071080 	call	3207108 <puts>
#endif   /* NPDEBUG  */
      return;
 324b840:	00000e06 	br	324b87c <icmp_destun+0x33c>
   }
   icmp_mib.icmpOutMsgs++;
 324b844:	0080c9b4 	movhi	r2,806
 324b848:	10b5a904 	addi	r2,r2,-10588
 324b84c:	10800d17 	ldw	r2,52(r2)
 324b850:	10c00044 	addi	r3,r2,1
 324b854:	0080c9b4 	movhi	r2,806
 324b858:	10b5a904 	addi	r2,r2,-10588
 324b85c:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutDestUnreachs++;
 324b860:	0080c9b4 	movhi	r2,806
 324b864:	10b5a904 	addi	r2,r2,-10588
 324b868:	10800f17 	ldw	r2,60(r2)
 324b86c:	10c00044 	addi	r3,r2,1
 324b870:	0080c9b4 	movhi	r2,806
 324b874:	10b5a904 	addi	r2,r2,-10588
 324b878:	10c00f15 	stw	r3,60(r2)
   return;
}
 324b87c:	e037883a 	mov	sp,fp
 324b880:	dfc00117 	ldw	ra,4(sp)
 324b884:	df000017 	ldw	fp,0(sp)
 324b888:	dec00204 	addi	sp,sp,8
 324b88c:	f800283a 	ret

0324b890 <icmp_timex>:
 *
 * RETURNS: void
 */

void icmp_timex (struct ip * ip, char code) 
{
 324b890:	defff504 	addi	sp,sp,-44
 324b894:	dfc00a15 	stw	ra,40(sp)
 324b898:	df000915 	stw	fp,36(sp)
 324b89c:	df000904 	addi	fp,sp,36
 324b8a0:	e13ffe15 	stw	r4,-8(fp)
 324b8a4:	e17fff05 	stb	r5,-4(fp)
   struct ip * pip;
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 324b8a8:	0080c974 	movhi	r2,805
 324b8ac:	10931c04 	addi	r2,r2,19568
 324b8b0:	10800017 	ldw	r2,0(r2)
 324b8b4:	1080040c 	andi	r2,r2,16
 324b8b8:	1005003a 	cmpeq	r2,r2,zero
 324b8bc:	1000301e 	bne	r2,zero,324b980 <icmp_timex+0xf0>
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 324b8c0:	e17fff07 	ldb	r5,-4(fp)
 324b8c4:	e0bffe17 	ldw	r2,-8(fp)
 324b8c8:	10800317 	ldw	r2,12(r2)
 324b8cc:	1004d23a 	srli	r2,r2,8
 324b8d0:	10c03fcc 	andi	r3,r2,255
 324b8d4:	e0bffe17 	ldw	r2,-8(fp)
 324b8d8:	10800317 	ldw	r2,12(r2)
 324b8dc:	1004923a 	slli	r2,r2,8
 324b8e0:	10bfc00c 	andi	r2,r2,65280
 324b8e4:	1884b03a 	or	r2,r3,r2
 324b8e8:	11803fcc 	andi	r6,r2,255
 324b8ec:	e0bffe17 	ldw	r2,-8(fp)
 324b8f0:	10800317 	ldw	r2,12(r2)
 324b8f4:	1004d23a 	srli	r2,r2,8
 324b8f8:	10c03fcc 	andi	r3,r2,255
 324b8fc:	e0bffe17 	ldw	r2,-8(fp)
 324b900:	10800317 	ldw	r2,12(r2)
 324b904:	1004923a 	slli	r2,r2,8
 324b908:	10bfc00c 	andi	r2,r2,65280
 324b90c:	1884b03a 	or	r2,r3,r2
 324b910:	1004d23a 	srli	r2,r2,8
 324b914:	11c03fcc 	andi	r7,r2,255
 324b918:	e0bffe17 	ldw	r2,-8(fp)
 324b91c:	10800317 	ldw	r2,12(r2)
 324b920:	1004d23a 	srli	r2,r2,8
 324b924:	10c03fcc 	andi	r3,r2,255
 324b928:	e0bffe17 	ldw	r2,-8(fp)
 324b92c:	10800317 	ldw	r2,12(r2)
 324b930:	1004923a 	slli	r2,r2,8
 324b934:	10bfc00c 	andi	r2,r2,65280
 324b938:	1884b03a 	or	r2,r3,r2
 324b93c:	1004d43a 	srli	r2,r2,16
 324b940:	11003fcc 	andi	r4,r2,255
 324b944:	e0bffe17 	ldw	r2,-8(fp)
 324b948:	10800317 	ldw	r2,12(r2)
 324b94c:	1004d23a 	srli	r2,r2,8
 324b950:	10c03fcc 	andi	r3,r2,255
 324b954:	e0bffe17 	ldw	r2,-8(fp)
 324b958:	10800317 	ldw	r2,12(r2)
 324b95c:	1004923a 	slli	r2,r2,8
 324b960:	10bfc00c 	andi	r2,r2,65280
 324b964:	1884b03a 	or	r2,r3,r2
 324b968:	1004d63a 	srli	r2,r2,24
 324b96c:	d9000015 	stw	r4,0(sp)
 324b970:	d8800115 	stw	r2,4(sp)
 324b974:	0100c974 	movhi	r4,805
 324b978:	21025d04 	addi	r4,r4,2420
 324b97c:	3206de00 	call	3206de0 <printf>
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
#endif   /* NPDEBUG */

   icmp_pkt_len = ICMPTIMEX_HDR_LEN + ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN;
 324b980:	e0bffe17 	ldw	r2,-8(fp)
 324b984:	10800003 	ldbu	r2,0(r2)
 324b988:	108003cc 	andi	r2,r2,15
 324b98c:	1085883a 	add	r2,r2,r2
 324b990:	1085883a 	add	r2,r2,r2
 324b994:	10800404 	addi	r2,r2,16
 324b998:	e0bff905 	stb	r2,-28(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 324b99c:	01000084 	movi	r4,2
 324b9a0:	322b1900 	call	322b190 <LOCK_NET_RESOURCE>
    * length of the "outer" IP header, length of the ICMP header (ICMPTIMEX_HDR_LEN,
    * 8 bytes), length of the "inner" IP header, and length of "user" data 
    * (ICMPTIMEX_PAYLOAD_DATA_LEN, 8 bytes) (just past the "inner" IP header).  The 
    * latter two items are from the packet that the ICMP Time Exceeded message is 
    * being sent in response to. */
   p = pk_alloc(MaxLnh + IPHSIZ + icmp_pkt_len);
 324b9a4:	e0fff903 	ldbu	r3,-28(fp)
 324b9a8:	0080c974 	movhi	r2,805
 324b9ac:	10931a04 	addi	r2,r2,19560
 324b9b0:	10800017 	ldw	r2,0(r2)
 324b9b4:	1885883a 	add	r2,r3,r2
 324b9b8:	11000504 	addi	r4,r2,20
 324b9bc:	322a2ac0 	call	322a2ac <pk_alloc>
 324b9c0:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 324b9c4:	01000084 	movi	r4,2
 324b9c8:	322b2500 	call	322b250 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 324b9cc:	e0bffd17 	ldw	r2,-12(fp)
 324b9d0:	1004c03a 	cmpne	r2,r2,zero
 324b9d4:	1000111e 	bne	r2,zero,324ba1c <icmp_timex+0x18c>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 324b9d8:	0080c974 	movhi	r2,805
 324b9dc:	10931c04 	addi	r2,r2,19568
 324b9e0:	10800017 	ldw	r2,0(r2)
 324b9e4:	1080800c 	andi	r2,r2,512
 324b9e8:	1005003a 	cmpeq	r2,r2,zero
 324b9ec:	1000031e 	bne	r2,zero,324b9fc <icmp_timex+0x16c>
         dprintf("icmp: can't alloc pkt\n");
 324b9f0:	0100c974 	movhi	r4,805
 324b9f4:	21024e04 	addi	r4,r4,2360
 324b9f8:	32071080 	call	3207108 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 324b9fc:	0080c9b4 	movhi	r2,806
 324ba00:	10b5a904 	addi	r2,r2,-10588
 324ba04:	10800e17 	ldw	r2,56(r2)
 324ba08:	10c00044 	addi	r3,r2,1
 324ba0c:	0080c9b4 	movhi	r2,806
 324ba10:	10b5a904 	addi	r2,r2,-10588
 324ba14:	10c00e15 	stw	r3,56(r2)
      return;
 324ba18:	00006506 	br	324bbb0 <icmp_timex+0x320>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 324ba1c:	e0bffd17 	ldw	r2,-12(fp)
 324ba20:	10800317 	ldw	r2,12(r2)
 324ba24:	e0bffb15 	stw	r2,-20(fp)
   /* source IP address of packet is our address (i.e., destination IP address 
    * in the datagram whose reassembly timed out) */
   pip->ip_src = ip->ip_dest;
 324ba28:	e0bffe17 	ldw	r2,-8(fp)
 324ba2c:	10c00417 	ldw	r3,16(r2)
 324ba30:	e0bffb17 	ldw	r2,-20(fp)
 324ba34:	10c00315 	stw	r3,12(r2)
   /* the destination address is the same as the source IP address of the 
    * datagram whose reassembly timed out */
   pip->ip_dest = ip->ip_src;
 324ba38:	e0bffe17 	ldw	r2,-8(fp)
 324ba3c:	10c00317 	ldw	r3,12(r2)
 324ba40:	e0bffb17 	ldw	r2,-20(fp)
 324ba44:	10c00415 	stw	r3,16(r2)

   /* move past space for IP header to get to start of ICMP header */
   p->nb_prot += sizeof(struct ip);
 324ba48:	e0bffd17 	ldw	r2,-12(fp)
 324ba4c:	10800317 	ldw	r2,12(r2)
 324ba50:	10c00504 	addi	r3,r2,20
 324ba54:	e0bffd17 	ldw	r2,-12(fp)
 324ba58:	10c00315 	stw	r3,12(r2)

   tx = (struct timex *) p->nb_prot;
 324ba5c:	e0bffd17 	ldw	r2,-12(fp)
 324ba60:	10800317 	ldw	r2,12(r2)
 324ba64:	e0bffc15 	stw	r2,-16(fp)

   tx->ttype = TIMEX;
 324ba68:	e0fffc17 	ldw	r3,-16(fp)
 324ba6c:	008002c4 	movi	r2,11
 324ba70:	18800005 	stb	r2,0(r3)
   tx->tcode = code;
 324ba74:	e0fffc17 	ldw	r3,-16(fp)
 324ba78:	e0bfff03 	ldbu	r2,-4(fp)
 324ba7c:	18800045 	stb	r2,1(r3)
   tx->tno1 = tx->tno2 = 0;
 324ba80:	e0bffc17 	ldw	r2,-16(fp)
 324ba84:	1000018d 	sth	zero,6(r2)
 324ba88:	e0bffc17 	ldw	r2,-16(fp)
 324ba8c:	10c0018b 	ldhu	r3,6(r2)
 324ba90:	e0bffc17 	ldw	r2,-16(fp)
 324ba94:	10c0010d 	sth	r3,4(r2)
   MEMCPY(&tx->tip, ip, (ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN));
 324ba98:	e0bffc17 	ldw	r2,-16(fp)
 324ba9c:	11000204 	addi	r4,r2,8
 324baa0:	e0bffe17 	ldw	r2,-8(fp)
 324baa4:	10800003 	ldbu	r2,0(r2)
 324baa8:	10803fcc 	andi	r2,r2,255
 324baac:	108003cc 	andi	r2,r2,15
 324bab0:	1085883a 	add	r2,r2,r2
 324bab4:	1085883a 	add	r2,r2,r2
 324bab8:	10800204 	addi	r2,r2,8
 324babc:	1007883a 	mov	r3,r2
 324bac0:	e0bffe17 	ldw	r2,-8(fp)
 324bac4:	100b883a 	mov	r5,r2
 324bac8:	180d883a 	mov	r6,r3
 324bacc:	3206ad00 	call	3206ad0 <memcpy>

   tx->tchksum = 0;
 324bad0:	e0bffc17 	ldw	r2,-16(fp)
 324bad4:	1000008d 	sth	zero,2(r2)
   tx->tchksum = ~cksum(tx, (icmp_pkt_len>>1));
 324bad8:	e0bff903 	ldbu	r2,-28(fp)
 324badc:	1004d07a 	srli	r2,r2,1
 324bae0:	11403fcc 	andi	r5,r2,255
 324bae4:	e13ffc17 	ldw	r4,-16(fp)
 324bae8:	3225d5c0 	call	3225d5c <cksum>
 324baec:	0084303a 	nor	r2,zero,r2
 324baf0:	1007883a 	mov	r3,r2
 324baf4:	e0bffc17 	ldw	r2,-16(fp)
 324baf8:	10c0008d 	sth	r3,2(r2)

   p->nb_plen = icmp_pkt_len;
 324bafc:	e0fff903 	ldbu	r3,-28(fp)
 324bb00:	e0bffd17 	ldw	r2,-12(fp)
 324bb04:	10c00415 	stw	r3,16(r2)
   /* p->fhost is expected to be in network byte order */
   p->fhost = pip->ip_dest;
 324bb08:	e0bffb17 	ldw	r2,-20(fp)
 324bb0c:	10c00417 	ldw	r3,16(r2)
 324bb10:	e0bffd17 	ldw	r2,-12(fp)
 324bb14:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 324bb18:	01000044 	movi	r4,1
 324bb1c:	e17ffd17 	ldw	r5,-12(fp)
 324bb20:	323f3740 	call	323f374 <ip_write>
 324bb24:	e0bffa15 	stw	r2,-24(fp)
   if (i < 0)
 324bb28:	e0bffa17 	ldw	r2,-24(fp)
 324bb2c:	1004403a 	cmpge	r2,r2,zero
 324bb30:	1000111e 	bne	r2,zero,324bb78 <icmp_timex+0x2e8>
   {
      icmp_mib.icmpOutErrors++;
 324bb34:	0080c9b4 	movhi	r2,806
 324bb38:	10b5a904 	addi	r2,r2,-10588
 324bb3c:	10800e17 	ldw	r2,56(r2)
 324bb40:	10c00044 	addi	r3,r2,1
 324bb44:	0080c9b4 	movhi	r2,806
 324bb48:	10b5a904 	addi	r2,r2,-10588
 324bb4c:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 324bb50:	0080c974 	movhi	r2,805
 324bb54:	10931c04 	addi	r2,r2,19568
 324bb58:	10800017 	ldw	r2,0(r2)
 324bb5c:	1080860c 	andi	r2,r2,536
 324bb60:	1005003a 	cmpeq	r2,r2,zero
 324bb64:	1000121e 	bne	r2,zero,324bbb0 <icmp_timex+0x320>
         dprintf("ICMP: Can't send Time Exceeded\n");
 324bb68:	0100c974 	movhi	r4,805
 324bb6c:	21026d04 	addi	r4,r4,2484
 324bb70:	32071080 	call	3207108 <puts>
#endif   /* NPDEBUG  */
      return;
 324bb74:	00000e06 	br	324bbb0 <icmp_timex+0x320>
   }
   icmp_mib.icmpOutMsgs++;
 324bb78:	0080c9b4 	movhi	r2,806
 324bb7c:	10b5a904 	addi	r2,r2,-10588
 324bb80:	10800d17 	ldw	r2,52(r2)
 324bb84:	10c00044 	addi	r3,r2,1
 324bb88:	0080c9b4 	movhi	r2,806
 324bb8c:	10b5a904 	addi	r2,r2,-10588
 324bb90:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutTimeExcds++;
 324bb94:	0080c9b4 	movhi	r2,806
 324bb98:	10b5a904 	addi	r2,r2,-10588
 324bb9c:	10801017 	ldw	r2,64(r2)
 324bba0:	10c00044 	addi	r3,r2,1
 324bba4:	0080c9b4 	movhi	r2,806
 324bba8:	10b5a904 	addi	r2,r2,-10588
 324bbac:	10c01015 	stw	r3,64(r2)
   return;
}
 324bbb0:	e037883a 	mov	sp,fp
 324bbb4:	dfc00117 	ldw	ra,4(sp)
 324bbb8:	df000017 	ldw	fp,0(sp)
 324bbbc:	dec00204 	addi	sp,sp,8
 324bbc0:	f800283a 	ret

0324bbc4 <icmp_du>:
 * RETURNS: void
 */

void  
icmp_du(PACKET p, struct destun * pdp)
{
 324bbc4:	defffc04 	addi	sp,sp,-16
 324bbc8:	dfc00315 	stw	ra,12(sp)
 324bbcc:	df000215 	stw	fp,8(sp)
 324bbd0:	df000204 	addi	fp,sp,8
 324bbd4:	e13ffe15 	stw	r4,-8(fp)
 324bbd8:	e17fff15 	stw	r5,-4(fp)
   /* see if user app wants notification first */
   if (icmpdu_hook)
 324bbdc:	d0a91317 	ldw	r2,-23476(gp)
 324bbe0:	1005003a 	cmpeq	r2,r2,zero
 324bbe4:	1000041e 	bne	r2,zero,324bbf8 <icmp_du+0x34>
      icmpdu_hook(p, pdp);
 324bbe8:	d0a91317 	ldw	r2,-23476(gp)
 324bbec:	e13ffe17 	ldw	r4,-8(fp)
 324bbf0:	e17fff17 	ldw	r5,-4(fp)
 324bbf4:	103ee83a 	callr	r2

#ifdef INCLUDE_TCP
   /* Tell the sockets layer so it can correct the problem. */
   so_icmpdu(p, pdp);   /* this call should free packet p */
 324bbf8:	e13ffe17 	ldw	r4,-8(fp)
 324bbfc:	e17fff17 	ldw	r5,-4(fp)
 324bc00:	322d1200 	call	322d120 <so_icmpdu>
done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(p); /* else just free packet */
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif   /* INCLUDE_TCP */
}
 324bc04:	e037883a 	mov	sp,fp
 324bc08:	dfc00117 	ldw	ra,4(sp)
 324bc0c:	df000017 	ldw	fp,0(sp)
 324bc10:	dec00204 	addi	sp,sp,8
 324bc14:	f800283a 	ret

0324bc18 <atexit>:
 324bc18:	200b883a 	mov	r5,r4
 324bc1c:	000d883a 	mov	r6,zero
 324bc20:	0009883a 	mov	r4,zero
 324bc24:	000f883a 	mov	r7,zero
 324bc28:	324c0141 	jmpi	324c014 <__register_exitproc>

0324bc2c <_atoi_r>:
 324bc2c:	000d883a 	mov	r6,zero
 324bc30:	01c00284 	movi	r7,10
 324bc34:	32105e41 	jmpi	32105e4 <_strtol_r>

0324bc38 <atoi>:
 324bc38:	000b883a 	mov	r5,zero
 324bc3c:	01800284 	movi	r6,10
 324bc40:	32108281 	jmpi	3210828 <strtol>

0324bc44 <calloc>:
 324bc44:	0180c974 	movhi	r6,805
 324bc48:	318a6304 	addi	r6,r6,10636
 324bc4c:	2007883a 	mov	r3,r4
 324bc50:	31000017 	ldw	r4,0(r6)
 324bc54:	280d883a 	mov	r6,r5
 324bc58:	180b883a 	mov	r5,r3
 324bc5c:	321133c1 	jmpi	321133c <_calloc_r>

0324bc60 <exit>:
 324bc60:	defffe04 	addi	sp,sp,-8
 324bc64:	000b883a 	mov	r5,zero
 324bc68:	dc000015 	stw	r16,0(sp)
 324bc6c:	dfc00115 	stw	ra,4(sp)
 324bc70:	2021883a 	mov	r16,r4
 324bc74:	324c14c0 	call	324c14c <__call_exitprocs>
 324bc78:	0080c974 	movhi	r2,805
 324bc7c:	108a6404 	addi	r2,r2,10640
 324bc80:	11000017 	ldw	r4,0(r2)
 324bc84:	20800f17 	ldw	r2,60(r4)
 324bc88:	10000126 	beq	r2,zero,324bc90 <exit+0x30>
 324bc8c:	103ee83a 	callr	r2
 324bc90:	8009883a 	mov	r4,r16
 324bc94:	324c33c0 	call	324c33c <_exit>

0324bc98 <free>:
 324bc98:	0080c974 	movhi	r2,805
 324bc9c:	108a6304 	addi	r2,r2,10636
 324bca0:	200b883a 	mov	r5,r4
 324bca4:	11000017 	ldw	r4,0(r2)
 324bca8:	32051101 	jmpi	3205110 <_free_r>

0324bcac <malloc>:
 324bcac:	0080c974 	movhi	r2,805
 324bcb0:	108a6304 	addi	r2,r2,10636
 324bcb4:	200b883a 	mov	r5,r4
 324bcb8:	11000017 	ldw	r4,0(r2)
 324bcbc:	32062ac1 	jmpi	32062ac <_malloc_r>

0324bcc0 <memcmp>:
 324bcc0:	00c000c4 	movi	r3,3
 324bcc4:	1980032e 	bgeu	r3,r6,324bcd4 <memcmp+0x14>
 324bcc8:	2144b03a 	or	r2,r4,r5
 324bccc:	10c4703a 	and	r2,r2,r3
 324bcd0:	10000f26 	beq	r2,zero,324bd10 <memcmp+0x50>
 324bcd4:	31ffffc4 	addi	r7,r6,-1
 324bcd8:	3000061e 	bne	r6,zero,324bcf4 <memcmp+0x34>
 324bcdc:	00000a06 	br	324bd08 <memcmp+0x48>
 324bce0:	39ffffc4 	addi	r7,r7,-1
 324bce4:	00bfffc4 	movi	r2,-1
 324bce8:	21000044 	addi	r4,r4,1
 324bcec:	29400044 	addi	r5,r5,1
 324bcf0:	38800526 	beq	r7,r2,324bd08 <memcmp+0x48>
 324bcf4:	20c00003 	ldbu	r3,0(r4)
 324bcf8:	28800003 	ldbu	r2,0(r5)
 324bcfc:	18bff826 	beq	r3,r2,324bce0 <memcmp+0x20>
 324bd00:	1885c83a 	sub	r2,r3,r2
 324bd04:	f800283a 	ret
 324bd08:	0005883a 	mov	r2,zero
 324bd0c:	f800283a 	ret
 324bd10:	180f883a 	mov	r7,r3
 324bd14:	20c00017 	ldw	r3,0(r4)
 324bd18:	28800017 	ldw	r2,0(r5)
 324bd1c:	18bfed1e 	bne	r3,r2,324bcd4 <memcmp+0x14>
 324bd20:	31bfff04 	addi	r6,r6,-4
 324bd24:	21000104 	addi	r4,r4,4
 324bd28:	29400104 	addi	r5,r5,4
 324bd2c:	39bff936 	bltu	r7,r6,324bd14 <memcmp+0x54>
 324bd30:	003fe806 	br	324bcd4 <memcmp+0x14>

0324bd34 <strcpy>:
 324bd34:	2904b03a 	or	r2,r5,r4
 324bd38:	108000cc 	andi	r2,r2,3
 324bd3c:	10000826 	beq	r2,zero,324bd60 <strcpy+0x2c>
 324bd40:	2007883a 	mov	r3,r4
 324bd44:	28800003 	ldbu	r2,0(r5)
 324bd48:	29400044 	addi	r5,r5,1
 324bd4c:	18800005 	stb	r2,0(r3)
 324bd50:	18c00044 	addi	r3,r3,1
 324bd54:	103ffb1e 	bne	r2,zero,324bd44 <strcpy+0x10>
 324bd58:	2005883a 	mov	r2,r4
 324bd5c:	f800283a 	ret
 324bd60:	29800017 	ldw	r6,0(r5)
 324bd64:	023fbff4 	movhi	r8,65279
 324bd68:	423fbfc4 	addi	r8,r8,-257
 324bd6c:	02a02074 	movhi	r10,32897
 324bd70:	52a02004 	addi	r10,r10,-32640
 324bd74:	3205883a 	add	r2,r6,r8
 324bd78:	0186303a 	nor	r3,zero,r6
 324bd7c:	10c4703a 	and	r2,r2,r3
 324bd80:	1284703a 	and	r2,r2,r10
 324bd84:	200f883a 	mov	r7,r4
 324bd88:	10000b1e 	bne	r2,zero,324bdb8 <strcpy+0x84>
 324bd8c:	4013883a 	mov	r9,r8
 324bd90:	5011883a 	mov	r8,r10
 324bd94:	39800015 	stw	r6,0(r7)
 324bd98:	29400104 	addi	r5,r5,4
 324bd9c:	29800017 	ldw	r6,0(r5)
 324bda0:	39c00104 	addi	r7,r7,4
 324bda4:	3245883a 	add	r2,r6,r9
 324bda8:	0186303a 	nor	r3,zero,r6
 324bdac:	10c4703a 	and	r2,r2,r3
 324bdb0:	1204703a 	and	r2,r2,r8
 324bdb4:	103ff726 	beq	r2,zero,324bd94 <strcpy+0x60>
 324bdb8:	3807883a 	mov	r3,r7
 324bdbc:	003fe106 	br	324bd44 <strcpy+0x10>

0324bdc0 <strncmp>:
 324bdc0:	30003926 	beq	r6,zero,324bea8 <strncmp+0xe8>
 324bdc4:	2144b03a 	or	r2,r4,r5
 324bdc8:	108000cc 	andi	r2,r2,3
 324bdcc:	028000c4 	movi	r10,3
 324bdd0:	1000241e 	bne	r2,zero,324be64 <strncmp+0xa4>
 324bdd4:	2011883a 	mov	r8,r4
 324bdd8:	280f883a 	mov	r7,r5
 324bddc:	51801f2e 	bgeu	r10,r6,324be5c <strncmp+0x9c>
 324bde0:	21000017 	ldw	r4,0(r4)
 324bde4:	28800017 	ldw	r2,0(r5)
 324bde8:	20801c1e 	bne	r4,r2,324be5c <strncmp+0x9c>
 324bdec:	31bfff04 	addi	r6,r6,-4
 324bdf0:	30002d26 	beq	r6,zero,324bea8 <strncmp+0xe8>
 324bdf4:	027fbff4 	movhi	r9,65279
 324bdf8:	4a7fbfc4 	addi	r9,r9,-257
 324bdfc:	2247883a 	add	r3,r4,r9
 324be00:	01602074 	movhi	r5,32897
 324be04:	29602004 	addi	r5,r5,-32640
 324be08:	1946703a 	and	r3,r3,r5
 324be0c:	0104303a 	nor	r2,zero,r4
 324be10:	10c4703a 	and	r2,r2,r3
 324be14:	1000241e 	bne	r2,zero,324bea8 <strncmp+0xe8>
 324be18:	5017883a 	mov	r11,r10
 324be1c:	4815883a 	mov	r10,r9
 324be20:	2813883a 	mov	r9,r5
 324be24:	00000a06 	br	324be50 <strncmp+0x90>
 324be28:	41000017 	ldw	r4,0(r8)
 324be2c:	39400017 	ldw	r5,0(r7)
 324be30:	2285883a 	add	r2,r4,r10
 324be34:	1244703a 	and	r2,r2,r9
 324be38:	0106303a 	nor	r3,zero,r4
 324be3c:	1886703a 	and	r3,r3,r2
 324be40:	2140061e 	bne	r4,r5,324be5c <strncmp+0x9c>
 324be44:	31bfff04 	addi	r6,r6,-4
 324be48:	30001726 	beq	r6,zero,324bea8 <strncmp+0xe8>
 324be4c:	1800161e 	bne	r3,zero,324bea8 <strncmp+0xe8>
 324be50:	42000104 	addi	r8,r8,4
 324be54:	39c00104 	addi	r7,r7,4
 324be58:	59bff336 	bltu	r11,r6,324be28 <strncmp+0x68>
 324be5c:	4009883a 	mov	r4,r8
 324be60:	380b883a 	mov	r5,r7
 324be64:	31bfffc4 	addi	r6,r6,-1
 324be68:	01ffffc4 	movi	r7,-1
 324be6c:	31c00a1e 	bne	r6,r7,324be98 <strncmp+0xd8>
 324be70:	20c00003 	ldbu	r3,0(r4)
 324be74:	28800003 	ldbu	r2,0(r5)
 324be78:	1885c83a 	sub	r2,r3,r2
 324be7c:	f800283a 	ret
 324be80:	30000926 	beq	r6,zero,324bea8 <strncmp+0xe8>
 324be84:	18000826 	beq	r3,zero,324bea8 <strncmp+0xe8>
 324be88:	31bfffc4 	addi	r6,r6,-1
 324be8c:	21000044 	addi	r4,r4,1
 324be90:	29400044 	addi	r5,r5,1
 324be94:	31fff626 	beq	r6,r7,324be70 <strncmp+0xb0>
 324be98:	20c00007 	ldb	r3,0(r4)
 324be9c:	28800007 	ldb	r2,0(r5)
 324bea0:	18bff726 	beq	r3,r2,324be80 <strncmp+0xc0>
 324bea4:	003ff206 	br	324be70 <strncmp+0xb0>
 324bea8:	0005883a 	mov	r2,zero
 324beac:	f800283a 	ret

0324beb0 <strncpy>:
 324beb0:	2904b03a 	or	r2,r5,r4
 324beb4:	108000cc 	andi	r2,r2,3
 324beb8:	00c000c4 	movi	r3,3
 324bebc:	1000291e 	bne	r2,zero,324bf64 <strncpy+0xb4>
 324bec0:	1980282e 	bgeu	r3,r6,324bf64 <strncpy+0xb4>
 324bec4:	1817883a 	mov	r11,r3
 324bec8:	2011883a 	mov	r8,r4
 324becc:	02bfbff4 	movhi	r10,65279
 324bed0:	52bfbfc4 	addi	r10,r10,-257
 324bed4:	02602074 	movhi	r9,32897
 324bed8:	4a602004 	addi	r9,r9,-32640
 324bedc:	29c00017 	ldw	r7,0(r5)
 324bee0:	3a85883a 	add	r2,r7,r10
 324bee4:	01c6303a 	nor	r3,zero,r7
 324bee8:	10c4703a 	and	r2,r2,r3
 324beec:	1244703a 	and	r2,r2,r9
 324bef0:	1000051e 	bne	r2,zero,324bf08 <strncpy+0x58>
 324bef4:	31bfff04 	addi	r6,r6,-4
 324bef8:	41c00015 	stw	r7,0(r8)
 324befc:	29400104 	addi	r5,r5,4
 324bf00:	42000104 	addi	r8,r8,4
 324bf04:	59bff536 	bltu	r11,r6,324bedc <strncpy+0x2c>
 324bf08:	400f883a 	mov	r7,r8
 324bf0c:	30001326 	beq	r6,zero,324bf5c <strncpy+0xac>
 324bf10:	28800003 	ldbu	r2,0(r5)
 324bf14:	31bfffc4 	addi	r6,r6,-1
 324bf18:	38c00044 	addi	r3,r7,1
 324bf1c:	38800005 	stb	r2,0(r7)
 324bf20:	10000826 	beq	r2,zero,324bf44 <strncpy+0x94>
 324bf24:	29400044 	addi	r5,r5,1
 324bf28:	30000c26 	beq	r6,zero,324bf5c <strncpy+0xac>
 324bf2c:	28800003 	ldbu	r2,0(r5)
 324bf30:	31bfffc4 	addi	r6,r6,-1
 324bf34:	29400044 	addi	r5,r5,1
 324bf38:	18800005 	stb	r2,0(r3)
 324bf3c:	18c00044 	addi	r3,r3,1
 324bf40:	103ff91e 	bne	r2,zero,324bf28 <strncpy+0x78>
 324bf44:	30000526 	beq	r6,zero,324bf5c <strncpy+0xac>
 324bf48:	1805883a 	mov	r2,r3
 324bf4c:	30cd883a 	add	r6,r6,r3
 324bf50:	10000005 	stb	zero,0(r2)
 324bf54:	10800044 	addi	r2,r2,1
 324bf58:	30bffd1e 	bne	r6,r2,324bf50 <strncpy+0xa0>
 324bf5c:	2005883a 	mov	r2,r4
 324bf60:	f800283a 	ret
 324bf64:	200f883a 	mov	r7,r4
 324bf68:	003fe806 	br	324bf0c <strncpy+0x5c>

0324bf6c <_vprintf_r>:
 324bf6c:	2807883a 	mov	r3,r5
 324bf70:	21400217 	ldw	r5,8(r4)
 324bf74:	300f883a 	mov	r7,r6
 324bf78:	180d883a 	mov	r6,r3
 324bf7c:	320851c1 	jmpi	320851c <___vfprintf_internal_r>

0324bf80 <vprintf>:
 324bf80:	0080c974 	movhi	r2,805
 324bf84:	108a6304 	addi	r2,r2,10636
 324bf88:	12000017 	ldw	r8,0(r2)
 324bf8c:	280f883a 	mov	r7,r5
 324bf90:	200d883a 	mov	r6,r4
 324bf94:	41400217 	ldw	r5,8(r8)
 324bf98:	4009883a 	mov	r4,r8
 324bf9c:	320851c1 	jmpi	320851c <___vfprintf_internal_r>

0324bfa0 <_vsprintf_r>:
 324bfa0:	deffe804 	addi	sp,sp,-96
 324bfa4:	00808204 	movi	r2,520
 324bfa8:	2811883a 	mov	r8,r5
 324bfac:	02600034 	movhi	r9,32768
 324bfb0:	4a7fffc4 	addi	r9,r9,-1
 324bfb4:	d880030d 	sth	r2,12(sp)
 324bfb8:	d80b883a 	mov	r5,sp
 324bfbc:	00bfffc4 	movi	r2,-1
 324bfc0:	dfc01715 	stw	ra,92(sp)
 324bfc4:	da000415 	stw	r8,16(sp)
 324bfc8:	da400515 	stw	r9,20(sp)
 324bfcc:	d880038d 	sth	r2,14(sp)
 324bfd0:	da000015 	stw	r8,0(sp)
 324bfd4:	da400215 	stw	r9,8(sp)
 324bfd8:	320851c0 	call	320851c <___vfprintf_internal_r>
 324bfdc:	d8c00017 	ldw	r3,0(sp)
 324bfe0:	18000005 	stb	zero,0(r3)
 324bfe4:	dfc01717 	ldw	ra,92(sp)
 324bfe8:	dec01804 	addi	sp,sp,96
 324bfec:	f800283a 	ret

0324bff0 <vsprintf>:
 324bff0:	0080c974 	movhi	r2,805
 324bff4:	108a6304 	addi	r2,r2,10636
 324bff8:	2013883a 	mov	r9,r4
 324bffc:	11000017 	ldw	r4,0(r2)
 324c000:	2805883a 	mov	r2,r5
 324c004:	300f883a 	mov	r7,r6
 324c008:	480b883a 	mov	r5,r9
 324c00c:	100d883a 	mov	r6,r2
 324c010:	324bfa01 	jmpi	324bfa0 <_vsprintf_r>

0324c014 <__register_exitproc>:
 324c014:	defffa04 	addi	sp,sp,-24
 324c018:	0080c974 	movhi	r2,805
 324c01c:	108a6404 	addi	r2,r2,10640
 324c020:	dc000015 	stw	r16,0(sp)
 324c024:	14000017 	ldw	r16,0(r2)
 324c028:	dd000415 	stw	r20,16(sp)
 324c02c:	2829883a 	mov	r20,r5
 324c030:	81405217 	ldw	r5,328(r16)
 324c034:	dcc00315 	stw	r19,12(sp)
 324c038:	dc800215 	stw	r18,8(sp)
 324c03c:	dc400115 	stw	r17,4(sp)
 324c040:	dfc00515 	stw	ra,20(sp)
 324c044:	2023883a 	mov	r17,r4
 324c048:	3027883a 	mov	r19,r6
 324c04c:	3825883a 	mov	r18,r7
 324c050:	28002526 	beq	r5,zero,324c0e8 <__register_exitproc+0xd4>
 324c054:	29000117 	ldw	r4,4(r5)
 324c058:	008007c4 	movi	r2,31
 324c05c:	11002716 	blt	r2,r4,324c0fc <__register_exitproc+0xe8>
 324c060:	8800101e 	bne	r17,zero,324c0a4 <__register_exitproc+0x90>
 324c064:	2105883a 	add	r2,r4,r4
 324c068:	1085883a 	add	r2,r2,r2
 324c06c:	20c00044 	addi	r3,r4,1
 324c070:	1145883a 	add	r2,r2,r5
 324c074:	0009883a 	mov	r4,zero
 324c078:	15000215 	stw	r20,8(r2)
 324c07c:	28c00115 	stw	r3,4(r5)
 324c080:	2005883a 	mov	r2,r4
 324c084:	dfc00517 	ldw	ra,20(sp)
 324c088:	dd000417 	ldw	r20,16(sp)
 324c08c:	dcc00317 	ldw	r19,12(sp)
 324c090:	dc800217 	ldw	r18,8(sp)
 324c094:	dc400117 	ldw	r17,4(sp)
 324c098:	dc000017 	ldw	r16,0(sp)
 324c09c:	dec00604 	addi	sp,sp,24
 324c0a0:	f800283a 	ret
 324c0a4:	29802204 	addi	r6,r5,136
 324c0a8:	00800044 	movi	r2,1
 324c0ac:	110e983a 	sll	r7,r2,r4
 324c0b0:	30c04017 	ldw	r3,256(r6)
 324c0b4:	2105883a 	add	r2,r4,r4
 324c0b8:	1085883a 	add	r2,r2,r2
 324c0bc:	1185883a 	add	r2,r2,r6
 324c0c0:	19c6b03a 	or	r3,r3,r7
 324c0c4:	14802015 	stw	r18,128(r2)
 324c0c8:	14c00015 	stw	r19,0(r2)
 324c0cc:	00800084 	movi	r2,2
 324c0d0:	30c04015 	stw	r3,256(r6)
 324c0d4:	88bfe31e 	bne	r17,r2,324c064 <__register_exitproc+0x50>
 324c0d8:	30804117 	ldw	r2,260(r6)
 324c0dc:	11c4b03a 	or	r2,r2,r7
 324c0e0:	30804115 	stw	r2,260(r6)
 324c0e4:	003fdf06 	br	324c064 <__register_exitproc+0x50>
 324c0e8:	0080c9b4 	movhi	r2,806
 324c0ec:	10b5c304 	addi	r2,r2,-10484
 324c0f0:	100b883a 	mov	r5,r2
 324c0f4:	80805215 	stw	r2,328(r16)
 324c0f8:	003fd606 	br	324c054 <__register_exitproc+0x40>
 324c0fc:	0080c974 	movhi	r2,805
 324c100:	10af2b04 	addi	r2,r2,-17236
 324c104:	1000021e 	bne	r2,zero,324c110 <__register_exitproc+0xfc>
 324c108:	013fffc4 	movi	r4,-1
 324c10c:	003fdc06 	br	324c080 <__register_exitproc+0x6c>
 324c110:	01006404 	movi	r4,400
 324c114:	103ee83a 	callr	r2
 324c118:	1007883a 	mov	r3,r2
 324c11c:	103ffa26 	beq	r2,zero,324c108 <__register_exitproc+0xf4>
 324c120:	80805217 	ldw	r2,328(r16)
 324c124:	180b883a 	mov	r5,r3
 324c128:	18000115 	stw	zero,4(r3)
 324c12c:	18800015 	stw	r2,0(r3)
 324c130:	80c05215 	stw	r3,328(r16)
 324c134:	18006215 	stw	zero,392(r3)
 324c138:	18006315 	stw	zero,396(r3)
 324c13c:	0009883a 	mov	r4,zero
 324c140:	883fc826 	beq	r17,zero,324c064 <__register_exitproc+0x50>
 324c144:	003fd706 	br	324c0a4 <__register_exitproc+0x90>

0324c148 <register_fini>:
 324c148:	f800283a 	ret

0324c14c <__call_exitprocs>:
 324c14c:	0080c974 	movhi	r2,805
 324c150:	108a6404 	addi	r2,r2,10640
 324c154:	10800017 	ldw	r2,0(r2)
 324c158:	defff304 	addi	sp,sp,-52
 324c15c:	df000b15 	stw	fp,44(sp)
 324c160:	d8800115 	stw	r2,4(sp)
 324c164:	0080c974 	movhi	r2,805
 324c168:	10af2604 	addi	r2,r2,-17256
 324c16c:	1005003a 	cmpeq	r2,r2,zero
 324c170:	d8800215 	stw	r2,8(sp)
 324c174:	d8800117 	ldw	r2,4(sp)
 324c178:	dd400815 	stw	r21,32(sp)
 324c17c:	dd000715 	stw	r20,28(sp)
 324c180:	10805204 	addi	r2,r2,328
 324c184:	dfc00c15 	stw	ra,48(sp)
 324c188:	ddc00a15 	stw	r23,40(sp)
 324c18c:	dd800915 	stw	r22,36(sp)
 324c190:	dcc00615 	stw	r19,24(sp)
 324c194:	dc800515 	stw	r18,20(sp)
 324c198:	dc400415 	stw	r17,16(sp)
 324c19c:	dc000315 	stw	r16,12(sp)
 324c1a0:	282b883a 	mov	r21,r5
 324c1a4:	2039883a 	mov	fp,r4
 324c1a8:	d8800015 	stw	r2,0(sp)
 324c1ac:	2829003a 	cmpeq	r20,r5,zero
 324c1b0:	d8800117 	ldw	r2,4(sp)
 324c1b4:	14405217 	ldw	r17,328(r2)
 324c1b8:	88001026 	beq	r17,zero,324c1fc <__call_exitprocs+0xb0>
 324c1bc:	ddc00017 	ldw	r23,0(sp)
 324c1c0:	88800117 	ldw	r2,4(r17)
 324c1c4:	8c802204 	addi	r18,r17,136
 324c1c8:	143fffc4 	addi	r16,r2,-1
 324c1cc:	80000916 	blt	r16,zero,324c1f4 <__call_exitprocs+0xa8>
 324c1d0:	05bfffc4 	movi	r22,-1
 324c1d4:	a000151e 	bne	r20,zero,324c22c <__call_exitprocs+0xe0>
 324c1d8:	8409883a 	add	r4,r16,r16
 324c1dc:	2105883a 	add	r2,r4,r4
 324c1e0:	1485883a 	add	r2,r2,r18
 324c1e4:	10c02017 	ldw	r3,128(r2)
 324c1e8:	a8c01126 	beq	r21,r3,324c230 <__call_exitprocs+0xe4>
 324c1ec:	843fffc4 	addi	r16,r16,-1
 324c1f0:	85bff81e 	bne	r16,r22,324c1d4 <__call_exitprocs+0x88>
 324c1f4:	d8800217 	ldw	r2,8(sp)
 324c1f8:	10003126 	beq	r2,zero,324c2c0 <__call_exitprocs+0x174>
 324c1fc:	dfc00c17 	ldw	ra,48(sp)
 324c200:	df000b17 	ldw	fp,44(sp)
 324c204:	ddc00a17 	ldw	r23,40(sp)
 324c208:	dd800917 	ldw	r22,36(sp)
 324c20c:	dd400817 	ldw	r21,32(sp)
 324c210:	dd000717 	ldw	r20,28(sp)
 324c214:	dcc00617 	ldw	r19,24(sp)
 324c218:	dc800517 	ldw	r18,20(sp)
 324c21c:	dc400417 	ldw	r17,16(sp)
 324c220:	dc000317 	ldw	r16,12(sp)
 324c224:	dec00d04 	addi	sp,sp,52
 324c228:	f800283a 	ret
 324c22c:	8409883a 	add	r4,r16,r16
 324c230:	88c00117 	ldw	r3,4(r17)
 324c234:	2105883a 	add	r2,r4,r4
 324c238:	1445883a 	add	r2,r2,r17
 324c23c:	18ffffc4 	addi	r3,r3,-1
 324c240:	11800217 	ldw	r6,8(r2)
 324c244:	1c001526 	beq	r3,r16,324c29c <__call_exitprocs+0x150>
 324c248:	10000215 	stw	zero,8(r2)
 324c24c:	303fe726 	beq	r6,zero,324c1ec <__call_exitprocs+0xa0>
 324c250:	00c00044 	movi	r3,1
 324c254:	1c06983a 	sll	r3,r3,r16
 324c258:	90804017 	ldw	r2,256(r18)
 324c25c:	8cc00117 	ldw	r19,4(r17)
 324c260:	1884703a 	and	r2,r3,r2
 324c264:	10001426 	beq	r2,zero,324c2b8 <__call_exitprocs+0x16c>
 324c268:	90804117 	ldw	r2,260(r18)
 324c26c:	1884703a 	and	r2,r3,r2
 324c270:	10000c1e 	bne	r2,zero,324c2a4 <__call_exitprocs+0x158>
 324c274:	2105883a 	add	r2,r4,r4
 324c278:	1485883a 	add	r2,r2,r18
 324c27c:	11400017 	ldw	r5,0(r2)
 324c280:	e009883a 	mov	r4,fp
 324c284:	303ee83a 	callr	r6
 324c288:	88800117 	ldw	r2,4(r17)
 324c28c:	98bfc81e 	bne	r19,r2,324c1b0 <__call_exitprocs+0x64>
 324c290:	b8800017 	ldw	r2,0(r23)
 324c294:	147fd526 	beq	r2,r17,324c1ec <__call_exitprocs+0xa0>
 324c298:	003fc506 	br	324c1b0 <__call_exitprocs+0x64>
 324c29c:	8c000115 	stw	r16,4(r17)
 324c2a0:	003fea06 	br	324c24c <__call_exitprocs+0x100>
 324c2a4:	2105883a 	add	r2,r4,r4
 324c2a8:	1485883a 	add	r2,r2,r18
 324c2ac:	11000017 	ldw	r4,0(r2)
 324c2b0:	303ee83a 	callr	r6
 324c2b4:	003ff406 	br	324c288 <__call_exitprocs+0x13c>
 324c2b8:	303ee83a 	callr	r6
 324c2bc:	003ff206 	br	324c288 <__call_exitprocs+0x13c>
 324c2c0:	88800117 	ldw	r2,4(r17)
 324c2c4:	1000081e 	bne	r2,zero,324c2e8 <__call_exitprocs+0x19c>
 324c2c8:	89000017 	ldw	r4,0(r17)
 324c2cc:	20000726 	beq	r4,zero,324c2ec <__call_exitprocs+0x1a0>
 324c2d0:	b9000015 	stw	r4,0(r23)
 324c2d4:	8809883a 	mov	r4,r17
 324c2d8:	324bc980 	call	324bc98 <free>
 324c2dc:	bc400017 	ldw	r17,0(r23)
 324c2e0:	883fb71e 	bne	r17,zero,324c1c0 <__call_exitprocs+0x74>
 324c2e4:	003fc506 	br	324c1fc <__call_exitprocs+0xb0>
 324c2e8:	89000017 	ldw	r4,0(r17)
 324c2ec:	882f883a 	mov	r23,r17
 324c2f0:	2023883a 	mov	r17,r4
 324c2f4:	883fb21e 	bne	r17,zero,324c1c0 <__call_exitprocs+0x74>
 324c2f8:	003fc006 	br	324c1fc <__call_exitprocs+0xb0>

0324c2fc <alt_sim_halt>:

/*
 * Routine called on exit.
 */
static ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
 324c2fc:	defffd04 	addi	sp,sp,-12
 324c300:	df000215 	stw	fp,8(sp)
 324c304:	df000204 	addi	fp,sp,8
 324c308:	e13fff15 	stw	r4,-4(fp)
  int r2 = exit_code;
 324c30c:	e0bfff17 	ldw	r2,-4(fp)
 324c310:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 324c314:	e0bffe17 	ldw	r2,-8(fp)
 324c318:	1005003a 	cmpeq	r2,r2,zero
 324c31c:	1000021e 	bne	r2,zero,324c328 <alt_sim_halt+0x2c>
    ALT_SIM_FAIL();
 324c320:	002af070 	cmpltui	zero,zero,43969
 324c324:	00000106 	br	324c32c <alt_sim_halt+0x30>
  } else {
    ALT_SIM_PASS();
 324c328:	002af0b0 	cmpltui	zero,zero,43970
  }
#endif /* DEBUG_STUB */
}
 324c32c:	e037883a 	mov	sp,fp
 324c330:	df000017 	ldw	fp,0(sp)
 324c334:	dec00104 	addi	sp,sp,4
 324c338:	f800283a 	ret

0324c33c <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 324c33c:	defffd04 	addi	sp,sp,-12
 324c340:	dfc00215 	stw	ra,8(sp)
 324c344:	df000115 	stw	fp,4(sp)
 324c348:	df000104 	addi	fp,sp,4
 324c34c:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 324c350:	0080c974 	movhi	r2,805
 324c354:	10930644 	addi	r2,r2,19481
 324c358:	10000005 	stb	zero,0(r2)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
  ALT_SIM_HALT(exit_code);
 324c35c:	e13fff17 	ldw	r4,-4(fp)
 324c360:	324c2fc0 	call	324c2fc <alt_sim_halt>

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 324c364:	003fff06 	br	324c364 <_exit+0x28>
 324c368:	0324c148 	cmpgei	r12,zero,-27899
